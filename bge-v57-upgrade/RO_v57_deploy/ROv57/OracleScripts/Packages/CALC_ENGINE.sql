CREATE OR REPLACE PACKAGE CALC_ENGINE IS
--Revision $Revision: 1.14 $

  -- Author  : JHUMPHRIES
  -- Created : 1/21/2008 8:36:18 AM
  -- Purpose : Implements the Calculation Engine - used to evaluate/execute logic in
  --			Calculation Processes and to evaluate/execute Formula Charges on behalf of
  --			the Billing Engine

-- Values used for p_COMMIT_FREQUENCY parameter of API
c_COMMIT_NEVER CONSTANT PLS_INTEGER := 0;
c_COMMIT_PROCESS CONSTANT PLS_INTEGER := 1;
c_COMMIT_STEP CONSTANT PLS_INTEGER := 2;
c_COMMIT_AUTO CONSTANT PLS_INTEGER := -1;

-- Values for COMPONENT_FORMULA_INPUT.ENTITY_ID that point to iterator values
c_ITER_FIRST CONSTANT PLS_INTEGER := -11;
c_ITER_LAST	CONSTANT PLS_INTEGER := c_ITER_FIRST-FML_UTIL.c_MAX_ITERATORS+1;

TYPE ITERATOR_VALS IS VARRAY(10) OF VARCHAR2(256);

FUNCTION WHAT_VERSION RETURN VARCHAR2;

-- Runs a calculation process for the specified dates, entities, and statement type. This
-- will create an entry in the process log and will perform commits as governed by the
-- System Dictionary entry:
--        Global -> Calculation Process -> Settings -> Default Commit Frequency
-- The p_STATUS parameter will be zero if the process is successful, otherwise it will
-- indicate the SQLCODE of the fatal exception.
PROCEDURE RUN_CALC_PROCESS
	(
	p_CALC_PROCESS_ID IN NUMBER,
	p_ENTITY_IDs IN NUMBER_COLLECTION,
	p_STATEMENT_TYPE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_PROCESS_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR2
	);

-- This is the same as the above procedure, except that it will not create a process log
-- entry, and it will perform commits as instructed by the p_COMMIT_FREQUENCY parameter.
-- If an exception occurs, this procedure will re-throw it instead of catching it and
-- returning its SQLCODE as the one above does.
PROCEDURE CALC_REQUEST
	(
	p_CALC_PROCESS_ID IN NUMBER,
	p_ENTITY_IDs IN NUMBER_COLLECTION,
	p_STATEMENT_TYPE_ID IN NUMBER,
	p_CUT_BEGIN_DATE_TIME IN DATE,
	p_CUT_END_DATE_TIME IN DATE,
	p_AS_OF_DATE IN DATE,
	p_COMMIT_FREQUENCY IN PLS_INTEGER := c_COMMIT_NEVER,
	p_UPDATE_PROGRESS IN BOOLEAN := FALSE
	);

-- Runs a single component. If the component’s entity will be used to determine how
-- calculation results are handled. An entity of ‘Calc.Process’ will cause the
-- calculation process component’s results to be evaluated. Otherwise, the results are
-- a charge quantity and charge rate. The PROC_NAME and STEP_NAME parameters are used for
-- any log messages that are recorded from formulas.
PROCEDURE RUN_FORMULA_COMPONENT
	(
	p_CHARGE_ID IN NUMBER,
	p_PRIOR_CHARGE_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_DATES_ARE_CUT IN BOOLEAN,
	p_TIME_ZONE IN VARCHAR2,
	p_AS_OF_DATE IN DATE,
	p_WEEK_BEGIN IN VARCHAR2,
	p_CONTEXT IN OUT NOCOPY UT.STRING_MAP,
	p_PROC_NAME IN VARCHAR2
	);

-- Logging methods to simplify logging from within formulas. They will reference private
-- package variables, g_PROC_NAME and g_STEP_NAME, for the procedure and step name to use
-- for the log message. These variables are set by RUN_FORMULA_COMPONENT.
FUNCTION LOG_FATAL
	(
	p_EVENT_TEXT IN VARCHAR2,
	p_SOURCE IN VARCHAR2 := NULL
	) RETURN NUMBER;
FUNCTION LOG_ERROR
	(
	p_EVENT_TEXT IN VARCHAR2,
	p_SOURCE IN VARCHAR2 := NULL
	) RETURN NUMBER;
FUNCTION LOG_WARN
	(
	p_EVENT_TEXT IN VARCHAR2,
	p_SOURCE IN VARCHAR2 := NULL
	) RETURN NUMBER;
FUNCTION LOG_INFO
	(
	p_EVENT_TEXT IN VARCHAR2,
	p_SOURCE IN VARCHAR2 := NULL
	) RETURN NUMBER;
FUNCTION LOG_DEBUG
	(
	p_EVENT_TEXT IN VARCHAR2,
	p_SOURCE IN VARCHAR2 := NULL
	) RETURN NUMBER;
-- Logs a fatal message and aborts calculation process
FUNCTION DIE
	(
	p_EVENT_TEXT IN VARCHAR2
	) RETURN NUMBER;
-- Alert methods to simplify raising alerts from within formulas
FUNCTION ALERT_FATAL
	(
	p_TRIGGER_VALUE IN VARCHAR2,
	p_ALERT_MESSAGE IN VARCHAR2
	) RETURN NUMBER;
FUNCTION ALERT_ERROR
	(
	p_TRIGGER_VALUE IN VARCHAR2,
	p_ALERT_MESSAGE IN VARCHAR2
	) RETURN NUMBER;
FUNCTION ALERT_WARN
	(
	p_TRIGGER_VALUE IN VARCHAR2,
	p_ALERT_MESSAGE IN VARCHAR2
	) RETURN NUMBER;
FUNCTION ALERT_NOTICE
	(
	p_TRIGGER_VALUE IN VARCHAR2,
	p_ALERT_MESSAGE IN VARCHAR2
	) RETURN NUMBER;

-- These functions are used by PC for implementing I/O API used by billing import
-- logic to create entries in the formula charge drill-down tables
PROCEDURE PRIOR_FORMULA_CHARGE
	(
	p_PRIOR_CHARGE_ID IN NUMBER,
	p_FORMULA_CHARGE IN OUT FORMULA_CHARGE%ROWTYPE
	);

PROCEDURE PUT_FORMULA_CHARGE
	(
	p_FORMULA_CHARGE IN FORMULA_CHARGE%ROWTYPE
	);

PROCEDURE PUT_FORMULA_CHARGE_VAR
	(
	p_FORMULA_CHARGE_VAR IN FORMULA_CHARGE_VARIABLE%ROWTYPE
	);

PROCEDURE PUT_FORMULA_ITERATOR
	(
	p_FORMULA_CHARGE_ITERATOR IN FORMULA_CHARGE_ITERATOR%ROWTYPE
	);

PROCEDURE PUT_FORMULA_ITERATOR_NAMES
	(
	p_FORMULA_CHARGE_ITERATOR_NAME IN FORMULA_CHARGE_ITERATOR_NAME%ROWTYPE
	);

-- Returns a collection of all valid context entity IDs for the specified
-- calculation process and time period
FUNCTION GET_ENTITY_IDs_FOR_PROCESS
	(
	p_CALC_PROCESS_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	) RETURN NUMBER_COLLECTION PIPELINED;

PROCEDURE GET_FORMULA_CHARGE_ITERATOR_ID
	(
	p_CHARGE_ID 		IN FORMULA_CHARGE_ITERATOR.CHARGE_ID%TYPE,
	p_ITERATOR_NAMES	IN OUT NOCOPY ITERATOR_VALS,
	p_ITERATOR_VALS 	IN OUT NOCOPY ITERATOR_VALS,
	p_ITERATOR_ID 		IN OUT NUMBER
	);

$if $$UNIT_TEST_MODE = 1 $then

PROCEDURE INIT_FLAGS;

$end

END CALC_ENGINE;
/
CREATE OR REPLACE PACKAGE BODY CALC_ENGINE IS
----------------------------------------------------------------------------------------------------
-- Data types
TYPE ID_FLAG_MAP IS TABLE OF BOOLEAN INDEX BY PLS_INTEGER;
TYPE BIGKEY_ID_MAP IS TABLE OF NUMBER(9) INDEX BY VARCHAR2(4000);

TYPE ITERATOR_TABLE IS TABLE OF COMPONENT_FORMULA_ITERATOR%ROWTYPE;
TYPE INPUT_TABLE IS TABLE OF COMPONENT_FORMULA_INPUT%ROWTYPE;
TYPE INTERMEDIATE_TABLE IS TABLE OF COMPONENT_FORMULA_VARIABLE%ROWTYPE;
TYPE RESULT_TABLE IS TABLE OF COMPONENT_FORMULA_RESULT%ROWTYPE;

TYPE VARIABLE_TYPE IS RECORD (
	NAME VARCHAR2(32),
	VALUE NUMBER
	);
TYPE VARIABLE_TABLE IS TABLE OF VARIABLE_TYPE;

-- Flags for how to handle errors during formula evaluation
g_CANCEL_ON_NULL_INPUT			BOOLEAN := FALSE;
g_CANCEL_ON_FORMULA_ERROR		BOOLEAN := TRUE;
g_CANCEL_ON_MISSING_OUTPUT		BOOLEAN := TRUE;
g_CANCEL_ON_TOO_MANY_OUTPUTS	BOOLEAN := TRUE;
g_CANCEL_ON_BAD_OUTPUTINTERVAL	BOOLEAN := TRUE;

g_NEED_LOCK						BOOLEAN := TRUE;

g_DATA_LOCK_BEHAVIOR            VARCHAR2(32) := 'Error';

-- Used when creating lock name
c_LOCK_DATE_FORMAT CONSTANT VARCHAR2(20) := 'YYYY-MM-DD HH24:MI';

-- Defaults for various input and result fields
c_DEFAULT_STATEMENT_TYPE 		CONSTANT VARCHAR2(16) := ':statement_type';
c_DEFAULT_SET_NUMBER			CONSTANT VARCHAR2(16) := 1;
c_DEFAULT_STATE					CONSTANT VARCHAR2(16) := GA.INTERNAL_STATE;
c_DEFAULT_CODE					CONSTANT VARCHAR2(16) := '''A''';
c_DEFAULT_MEASUREMENT_SOURCE	CONSTANT VARCHAR2(40) := 'SRC.PRIMARY_MEASUREMENT_SOURCE_ID';

-- Special abbreviation for this "non-standard" interval
c_METER_POINT_INTERVAL_ABBR		CONSTANT VARCHAR2(16) := '*MP';

-- Special bit used to indicate a value depends on an input or intermediate
-- variable vs. just on iterators
c_SPECIAL_BIT	CONSTANT PLS_INTEGER := 2 * FML_UTIL.c_SINGLE_ITER_DEPENDS(FML_UTIL.c_MAX_ITERATORS);

-- Used for logging procedures - these are set in RUN_FORMULA_COMPONENT and then
-- referenced in log API in case a formula needs to log something
g_PROC_NAME 	VARCHAR2(512);
g_STEP_NAME		PROCESS_LOG_EVENT.STEP_NAME%TYPE;
g_SOURCE_NAME	PROCESS_LOG_EVENT.SOURCE_NAME%TYPE;
---------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR2 IS
BEGIN
    RETURN '$Revision: 1.14 $';
END WHAT_VERSION;
----------------------------------------------------------------------------------------------------
FUNCTION GET_DICTIONARY
	(
	p_SETTING_NAME IN VARCHAR2,
	p_DEFAULT_VAL IN VARCHAR2 := NULL,
	p_KEY1 IN VARCHAR2 := '?',
	p_KEY2 IN VARCHAR2 := '?',
	p_KEY3 IN VARCHAR2 := '?'
	) RETURN VARCHAR2 IS
BEGIN
	RETURN NVL(GET_DICTIONARY_VALUE(p_SETTING_NAME, 0, 'Calculation Process', p_KEY1, p_KEY2, p_KEY3), p_DEFAULT_VAL);
END GET_DICTIONARY;
----------------------------------------------------------------------------------------------------
FUNCTION GET_SETTING
	(
	p_SETTING_NAME IN VARCHAR2,
	p_DEFAULT_VAL IN VARCHAR2 := NULL,
	p_KEY2 IN VARCHAR2 := '?',
	p_KEY3 IN VARCHAR2 := '?'
	) RETURN VARCHAR2 IS
BEGIN
	RETURN GET_DICTIONARY(p_SETTING_NAME, p_DEFAULT_VAL, 'Settings', p_KEY2, p_KEY3);
END GET_SETTING;
---------------------------------------------------------------------------------------------------
FUNCTION GET_CONTEXT_TRACE
    (
	p_CONTEXT IN OUT NOCOPY UT.STRING_MAP
    ) RETURN CLOB IS

    v_KEY VARCHAR2(4000);
    v_RTN CLOB;

BEGIN

    v_KEY := p_CONTEXT.FIRST;
	v_RTN := '----------------------------------------------' || UTL_TCP.CRLF ;
    WHILE p_CONTEXT.EXISTS(v_KEY) LOOP
        v_RTN := v_RTN || v_KEY||' := '||p_CONTEXT(v_KEY) || UTL_TCP.CRLF;
        v_KEY := p_CONTEXT.NEXT(v_KEY);
    END LOOP;
	v_RTN := v_RTN || '----------------------------------------------' || UTL_TCP.CRLF ;

    RETURN v_RTN;

END GET_CONTEXT_TRACE;
---------------------------------------------------------------------------------------------------
PROCEDURE TRACE_CONTEXT
	(
	p_FROM_WHERE IN VARCHAR2,
	p_CONTEXT IN OUT NOCOPY UT.STRING_MAP
	) AS
    v_LINES PARSE_UTIL.BIG_STRING_TABLE_MP;
BEGIN
	IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
		LOGS.LOG_DEBUG_DETAIL('Tracing formula context at '||p_FROM_WHERE||':');
        PARSE_UTIL.PARSE_CLOB_INTO_LINES(GET_CONTEXT_TRACE(p_CONTEXT), v_LINES);
        FOR v_IDX IN v_LINES.FIRST..v_LINES.LAST LOOP
            LOGS.LOG_DEBUG_DETAIL(v_LINES(v_IDX));
        END LOOP;
	END IF;
END TRACE_CONTEXT;
---------------------------------------------------------------------------------------------------
PROCEDURE LOG_FAILURE_CONTEXT
    (
    p_PREFIX IN VARCHAR2,
    p_DATE IN DATE,
    p_COMPONENT_ID IN NUMBER,
    p_CONTEXT IN OUT NOCOPY UT.STRING_MAP
    ) AS

    v_ERROR_MESSAGE VARCHAR2(4000);

BEGIN

    v_ERROR_MESSAGE := p_PREFIX || UTL_TCP.CRLF;
    IF p_COMPONENT_ID IS NOT NULL THEN
        v_ERROR_MESSAGE := v_ERROR_MESSAGE || 'Component: ' || TEXT_UTIL.TO_CHAR_ENTITY(p_COMPONENT_ID, EC.ED_COMPONENT) || UTL_TCP.CRLF;
    END IF;

    IF g_PROC_NAME IS NOT NULL THEN
        v_ERROR_MESSAGE := v_ERROR_MESSAGE || 'Process: ' || g_PROC_NAME || UTL_TCP.CRLF;
    END IF;

    IF p_DATE IS NOT NULL THEN
        v_ERROR_MESSAGE := v_ERROR_MESSAGE || 'Interval: ' || TEXT_UTIL.TO_CHAR_TIME(p_DATE) || UTL_TCP.CRLF;
    END IF;
    LOGS.LOG_ERROR(v_ERROR_MESSAGE);
    LOGS.POST_EVENT_DETAILS('Formula Context Trace',CONSTANTS.MIME_TYPE_TEXT,GET_CONTEXT_TRACE(p_CONTEXT));

END LOG_FAILURE_CONTEXT;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_FORMULA_CHARGE
	(
	p_FORMULA_CHARGE IN FORMULA_CHARGE%ROWTYPE
	) AS

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PUT_FORMULA_CHARGE: ' ||
			TO_CHAR(p_FORMULA_CHARGE.CHARGE_ID) || ',' ||
		    TEXT_UTIL.TO_CHAR_DATE(p_FORMULA_CHARGE.CHARGE_DATE) || ',' ||
			TO_CHAR(p_FORMULA_CHARGE.ITERATOR_ID) || ',' ||
		    TO_CHAR(p_FORMULA_CHARGE.CHARGE_QUANTITY) || ',' ||
		    TO_CHAR(p_FORMULA_CHARGE.CHARGE_RATE) || ',' ||
		    TO_CHAR(p_FORMULA_CHARGE.CHARGE_FACTOR) || ',' ||
		    TO_CHAR(p_FORMULA_CHARGE.CHARGE_AMOUNT) || ',' ||
		    TO_CHAR(p_FORMULA_CHARGE.BILL_QUANTITY) || ',' ||
		    TO_CHAR(p_FORMULA_CHARGE.BILL_AMOUNT));
	END IF;

    UPDATE FORMULA_CHARGE SET
		ROW = p_FORMULA_CHARGE
	WHERE CHARGE_ID = p_FORMULA_CHARGE.CHARGE_ID
	    AND CHARGE_DATE = p_FORMULA_CHARGE.CHARGE_DATE
		AND ITERATOR_ID = p_FORMULA_CHARGE.ITERATOR_ID;

	IF SQL%NOTFOUND THEN
	    INSERT INTO FORMULA_CHARGE VALUES p_FORMULA_CHARGE;
	END IF;

END PUT_FORMULA_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_FORMULA_CHARGE_VAR
	(
	p_FORMULA_CHARGE_VAR IN FORMULA_CHARGE_VARIABLE%ROWTYPE
	) AS

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PUT_FORMULA_CHARGE_VAR: ' ||
			TO_CHAR(p_FORMULA_CHARGE_VAR.CHARGE_ID) || ',' ||
		    TEXT_UTIL.TO_CHAR_DATE(p_FORMULA_CHARGE_VAR.CHARGE_DATE) || ',' ||
			TO_CHAR(p_FORMULA_CHARGE_VAR.ITERATOR_ID) || ',' ||
		    p_FORMULA_CHARGE_VAR.VARIABLE_NAME || ',' ||
		    TO_CHAR(p_FORMULA_CHARGE_VAR.VARIABLE_VAL));
	END IF;

	INSERT INTO FORMULA_CHARGE_VARIABLE VALUES p_FORMULA_CHARGE_VAR;
    
EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        UPDATE FORMULA_CHARGE_VARIABLE SET
	        VARIABLE_VAL = p_FORMULA_CHARGE_VAR.VARIABLE_VAL
	    WHERE CHARGE_ID = p_FORMULA_CHARGE_VAR.CHARGE_ID
	      AND CHARGE_DATE = p_FORMULA_CHARGE_VAR.CHARGE_DATE
		  AND ITERATOR_ID = p_FORMULA_CHARGE_VAR.ITERATOR_ID
          AND VARIABLE_NAME = p_FORMULA_CHARGE_VAR.VARIABLE_NAME;

END PUT_FORMULA_CHARGE_VAR;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_FORMULA_CHARGE_ITERATOR
	(
	p_CHARGE_ID IN NUMBER,
	p_ITERATOR_ID IN NUMBER,
	p_ITERATOR_NAMES IN ITERATOR_VALS,
	p_ITERATOR_VALS IN ITERATOR_VALS
	) AS
v_ITERATOR_NAMES ITERATOR_VALS := p_ITERATOR_NAMES;
v_ITERATOR_VALS ITERATOR_VALS := p_ITERATOR_VALS;
BEGIN
	IF v_ITERATOR_NAMES IS NULL THEN
		v_ITERATOR_NAMES := ITERATOR_VALS(NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
	END IF;
	IF v_ITERATOR_VALS IS NULL THEN
		v_ITERATOR_VALS := ITERATOR_VALS(NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PUT_FORMULA_CHARGE_ITERATOR: ' ||
			TO_CHAR(p_CHARGE_ID) || ',' ||
			TO_CHAR(p_ITERATOR_ID) || ',' ||
			v_ITERATOR_NAMES(1) || ' = '||v_ITERATOR_VALS(1)||',' ||
			v_ITERATOR_NAMES(2) || ' = '||v_ITERATOR_VALS(2)||',' ||
			v_ITERATOR_NAMES(3) || ' = '||v_ITERATOR_VALS(3)||',' ||
			v_ITERATOR_NAMES(4) || ' = '||v_ITERATOR_VALS(4)||',' ||
			v_ITERATOR_NAMES(5) || ' = '||v_ITERATOR_VALS(5)||',' ||
			v_ITERATOR_NAMES(6) || ' = '||v_ITERATOR_VALS(6)||',' ||
			v_ITERATOR_NAMES(7) || ' = '||v_ITERATOR_VALS(7)||',' ||
			v_ITERATOR_NAMES(8) || ' = '||v_ITERATOR_VALS(8)||',' ||
			v_ITERATOR_NAMES(9) || ' = '||v_ITERATOR_VALS(9)||',' ||
			v_ITERATOR_NAMES(10) || ' = '||v_ITERATOR_VALS(10));
	END IF;

	-- if this is the first Iterator, then update the NAMES, too
	IF p_ITERATOR_ID <= 1 THEN
		UPDATE FORMULA_CHARGE_ITERATOR_NAME
		SET ITERATOR_NAME1 = v_ITERATOR_NAMES(1),
			ITERATOR_NAME2 = v_ITERATOR_NAMES(2),
			ITERATOR_NAME3 = v_ITERATOR_NAMES(3),
			ITERATOR_NAME4 = v_ITERATOR_NAMES(4),
			ITERATOR_NAME5 = v_ITERATOR_NAMES(5),
			ITERATOR_NAME6 = v_ITERATOR_NAMES(6),
			ITERATOR_NAME7 = v_ITERATOR_NAMES(7),
			ITERATOR_NAME8 = v_ITERATOR_NAMES(8),
			ITERATOR_NAME9 = v_ITERATOR_NAMES(9),
			ITERATOR_NAME10 = v_ITERATOR_NAMES(10)
		WHERE CHARGE_ID = p_CHARGE_ID;

		IF SQL%NOTFOUND THEN
			INSERT INTO FORMULA_CHARGE_ITERATOR_NAME
				(CHARGE_ID,
				 ITERATOR_NAME1, ITERATOR_NAME2, ITERATOR_NAME3, ITERATOR_NAME4, ITERATOR_NAME5,
				 ITERATOR_NAME6, ITERATOR_NAME7, ITERATOR_NAME8, ITERATOR_NAME9, ITERATOR_NAME10)
			VALUES
				(p_CHARGE_ID,
				 v_ITERATOR_NAMES(1), v_ITERATOR_NAMES(2), v_ITERATOR_NAMES(3), v_ITERATOR_NAMES(4), v_ITERATOR_NAMES(5),
				 v_ITERATOR_NAMES(6), v_ITERATOR_NAMES(7), v_ITERATOR_NAMES(8), v_ITERATOR_NAMES(9), v_ITERATOR_NAMES(10));
		END IF;
	END IF;

    INSERT INTO FORMULA_CHARGE_ITERATOR
		(CHARGE_ID, ITERATOR_ID,
		 ITERATOR1, ITERATOR2, ITERATOR3, ITERATOR4, ITERATOR5,
		 ITERATOR6, ITERATOR7, ITERATOR8, ITERATOR9, ITERATOR10)
	VALUES
		(p_CHARGE_ID, p_ITERATOR_ID,
		 v_ITERATOR_VALS(1), v_ITERATOR_VALS(2), v_ITERATOR_VALS(3), v_ITERATOR_VALS(4), v_ITERATOR_VALS(5),
		 v_ITERATOR_VALS(6), v_ITERATOR_VALS(7), v_ITERATOR_VALS(8), v_ITERATOR_VALS(9), v_ITERATOR_VALS(10));

END PUT_FORMULA_CHARGE_ITERATOR;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_FORMULA_ITERATOR
	(
	p_FORMULA_CHARGE_ITERATOR IN FORMULA_CHARGE_ITERATOR%ROWTYPE
	) AS
BEGIN

    UPDATE FORMULA_CHARGE_ITERATOR SET
		ROW = p_FORMULA_CHARGE_ITERATOR
	WHERE CHARGE_ID = p_FORMULA_CHARGE_ITERATOR.CHARGE_ID
		AND ITERATOR_ID = p_FORMULA_CHARGE_ITERATOR.ITERATOR_ID;

	IF SQL%NOTFOUND THEN
	    INSERT INTO FORMULA_CHARGE_ITERATOR VALUES p_FORMULA_CHARGE_ITERATOR;
	END IF;

END PUT_FORMULA_ITERATOR;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_FORMULA_ITERATOR_NAMES
	(
	p_FORMULA_CHARGE_ITERATOR_NAME IN FORMULA_CHARGE_ITERATOR_NAME%ROWTYPE
	) AS
BEGIN

    UPDATE FORMULA_CHARGE_ITERATOR_NAME SET
		ROW = p_FORMULA_CHARGE_ITERATOR_NAME
	WHERE CHARGE_ID = p_FORMULA_CHARGE_ITERATOR_NAME.CHARGE_ID;

	IF SQL%NOTFOUND THEN
	    INSERT INTO FORMULA_CHARGE_ITERATOR_NAME VALUES p_FORMULA_CHARGE_ITERATOR_NAME;
	END IF;

END PUT_FORMULA_ITERATOR_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_FORMULA_CHARGE_ITERATOR_ID
	(
	p_CHARGE_ID 		IN FORMULA_CHARGE_ITERATOR.CHARGE_ID%TYPE,
	p_ITERATOR_NAMES	IN OUT NOCOPY ITERATOR_VALS,
	p_ITERATOR_VALS 	IN OUT NOCOPY ITERATOR_VALS,
	p_ITERATOR_ID 		IN OUT NUMBER
	) AS
BEGIN
	BEGIN
		SELECT ITERATOR_ID
		INTO p_ITERATOR_ID
		FROM FORMULA_CHARGE_ITERATOR
		WHERE CHARGE_ID = p_CHARGE_ID
			AND (ITERATOR1 = p_ITERATOR_VALS(1) OR (ITERATOR1 IS NULL AND p_ITERATOR_VALS(1) IS NULL))
			AND (ITERATOR2 = p_ITERATOR_VALS(2) OR (ITERATOR2 IS NULL AND p_ITERATOR_VALS(2) IS NULL))
			AND (ITERATOR3 = p_ITERATOR_VALS(3) OR (ITERATOR3 IS NULL AND p_ITERATOR_VALS(3) IS NULL))
			AND (ITERATOR4 = p_ITERATOR_VALS(4) OR (ITERATOR4 IS NULL AND p_ITERATOR_VALS(4) IS NULL))
			AND (ITERATOR5 = p_ITERATOR_VALS(5) OR (ITERATOR5 IS NULL AND p_ITERATOR_VALS(5) IS NULL))
			AND (ITERATOR6 = p_ITERATOR_VALS(6) OR (ITERATOR6 IS NULL AND p_ITERATOR_VALS(6) IS NULL))
			AND (ITERATOR7 = p_ITERATOR_VALS(7) OR (ITERATOR7 IS NULL AND p_ITERATOR_VALS(7) IS NULL))
			AND (ITERATOR8 = p_ITERATOR_VALS(8) OR (ITERATOR8 IS NULL AND p_ITERATOR_VALS(8) IS NULL))
			AND (ITERATOR9 = p_ITERATOR_VALS(9) OR (ITERATOR9 IS NULL AND p_ITERATOR_VALS(9) IS NULL))
			AND (ITERATOR10 = p_ITERATOR_VALS(10) OR (ITERATOR10 IS NULL AND p_ITERATOR_VALS(10) IS NULL));
	EXCEPTION
		WHEN TOO_MANY_ROWS THEN
			ERRS.LOG_AND_RAISE('More than one Iterator ID found for a set of Iterator Values.');
		WHEN NO_DATA_FOUND THEN
			SELECT NVL(MAX(ITERATOR_ID),0)+1
			INTO p_ITERATOR_ID
			FROM FORMULA_CHARGE_ITERATOR
			WHERE CHARGE_ID = p_CHARGE_ID;
			-- save the new iterator ID and info
			PUT_FORMULA_CHARGE_ITERATOR(p_CHARGE_ID, p_ITERATOR_ID, p_ITERATOR_NAMES, p_ITERATOR_VALS);
	END;
END GET_FORMULA_CHARGE_ITERATOR_ID;
---------------------------------------------------------------------------------------------------
PROCEDURE PRIOR_FORMULA_CHARGE
	(
	p_PRIOR_CHARGE_ID IN NUMBER,
	p_FORMULA_CHARGE IN OUT FORMULA_CHARGE%ROWTYPE
	) AS

BEGIN

	IF GA.APPLY_PRIOR_BILL_CHARGES AND NOT p_PRIOR_CHARGE_ID = CONSTANTS.NOT_ASSIGNED THEN
		SELECT CHARGE_QUANTITY, CHARGE_AMOUNT
		INTO p_FORMULA_CHARGE.BILL_QUANTITY, p_FORMULA_CHARGE.BILL_AMOUNT
		FROM FORMULA_CHARGE
		WHERE CHARGE_ID = p_PRIOR_CHARGE_ID
		    	AND CHARGE_DATE = p_FORMULA_CHARGE.CHARGE_DATE
				AND ITERATOR_ID = p_FORMULA_CHARGE.ITERATOR_ID;
		p_FORMULA_CHARGE.BILL_QUANTITY := p_FORMULA_CHARGE.CHARGE_QUANTITY - p_FORMULA_CHARGE.BILL_QUANTITY;
		p_FORMULA_CHARGE.BILL_AMOUNT := p_FORMULA_CHARGE.CHARGE_AMOUNT - p_FORMULA_CHARGE.BILL_AMOUNT;
	ELSE
		p_FORMULA_CHARGE.BILL_QUANTITY := p_FORMULA_CHARGE.CHARGE_QUANTITY;
		p_FORMULA_CHARGE.BILL_AMOUNT := p_FORMULA_CHARGE.CHARGE_AMOUNT;
	END IF;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		p_FORMULA_CHARGE.BILL_QUANTITY := p_FORMULA_CHARGE.CHARGE_QUANTITY;
		p_FORMULA_CHARGE.BILL_AMOUNT := p_FORMULA_CHARGE.CHARGE_AMOUNT;
	WHEN OTHERS THEN
		ERRS.LOG_AND_RAISE;

END PRIOR_FORMULA_CHARGE;
---------------------------------------------------------------------------------------------------
FUNCTION GET_VARIABLE_VALUE
	(
	p_CHARGE_ID IN NUMBER,
	p_CHARGE_DATE IN DATE,
	p_VARIABLE_NAME IN VARCHAR2,
	p_ITERATOR_ID IN NUMBER
	) RETURN NUMBER IS
v_RET NUMBER;
BEGIN
	SELECT VARIABLE_VAL
	INTO v_RET
	FROM FORMULA_CHARGE_VARIABLE
	WHERE CHARGE_ID = p_CHARGE_ID
		AND CHARGE_DATE = p_CHARGE_DATE
		AND ITERATOR_ID = p_ITERATOR_ID
		AND VARIABLE_NAME = p_VARIABLE_NAME;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('Re-using value for '||p_VARIABLE_NAME||' from previous iterator ('||
						p_ITERATOR_ID||'): '||v_RET);
	END IF;

	RETURN v_RET;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
		RETURN NULL;
END GET_VARIABLE_VALUE;
---------------------------------------------------------------------------------------------------
FUNCTION REUSE_VALUE
	(
	p_VARIABLE_NAME IN VARCHAR2,
	p_VARIABLE_CACHE IN UT.STRING_MAP
	) RETURN NUMBER IS
v_STR VARCHAR2(256);
v_RET NUMBER;
BEGIN
	IF p_VARIABLE_CACHE.EXISTS(p_VARIABLE_NAME) THEN
		v_STR := p_VARIABLE_CACHE(p_VARIABLE_NAME);
		-- cache has PL/SQL literals, so this will "translate" that into a number
	    EXECUTE IMMEDIATE 'BEGIN :R := '||v_STR||'; END;' USING OUT v_RET;

		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG('Re-using value already in cache for '||p_VARIABLE_NAME||': '||v_RET);
		END IF;

		RETURN v_RET;
	ELSE
		RETURN NULL;
	END IF;
EXCEPTION
	WHEN OTHERS THEN
		RETURN NULL;
END REUSE_VALUE;
---------------------------------------------------------------------------------------------------
FUNCTION GET_FML_REALM_CACHE_KEY
	(
	p_REALM_ID IN NUMBER,
	p_ITERATORS IN PLS_INTEGER,
	p_ITERATOR_VALS IN ITERATOR_VALS
	) RETURN VARCHAR2 IS
v_RET VARCHAR2(4000) := p_REALM_ID;
BEGIN
	--Bitwise-loop through p_ITERATORS to find which bits are set.
	--  If a bit is set, we append its iterator value onto the return key.
	FOR v_IDX IN 1..FML_UTIL.c_MAX_ITERATORS LOOP
		IF BITAND(p_ITERATORS, FML_UTIL.c_SINGLE_ITER_DEPENDS(v_IDX)) <> 0 THEN
			v_RET := v_RET||';'||p_ITERATOR_VALS(v_IDX);
		END IF;
	END LOOP;

	RETURN v_RET;
END GET_FML_REALM_CACHE_KEY;
---------------------------------------------------------------------------------------------------
PROCEDURE CACHE_FML_REALM_ENTITIES
	(
	p_REALM_ID IN NUMBER,
	p_VARIABLE_CACHE IN OUT NOCOPY UT.STRING_MAP,
	p_ITERATOR_DEPENDS IN FML_UTIL.ITERATOR_DEPENDS,
	p_ITERATORS IN OUT PLS_INTEGER,
	p_WORK_ID OUT  NUMBER
	) AS
v_SQL_INIT VARCHAR2(32767);
v_SQL_FINAL VARCHAR2(32767);
BEGIN
    UT.GET_RTO_WORK_ID(p_WORK_ID);

	-- build the SQL query for this realm
	v_SQL_INIT := SD.GET_REALM_QUERY(p_REALM_ID, ':1');
	IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
		LOGS.LOG_DEBUG_DETAIL('Formula Charge Realm Query (before) =');
		LOGS.LOG_DEBUG_DETAIL(v_SQL_INIT);
	END IF;

	-- substitute formula references with actual values
	FML_UTIL.REBUILD_FORMULA(v_SQL_INIT, p_VARIABLE_CACHE, p_ITERATOR_DEPENDS, p_ITERATORS, v_SQL_FINAL,
							TRUE, TRUE, FML_UTIL.c_PLSQL_NO, TRUE);
	-- create DML
	v_SQL_FINAL := 'INSERT INTO RTO_WORK(WORK_ID, WORK_XID) '||v_SQL_FINAL;

	IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
		LOGS.LOG_DEBUG_DETAIL('Formula Charge Realm Query (after) =');
		LOGS.LOG_DEBUG_DETAIL(v_SQL_FINAL);
	END IF;

	--Run it
	EXECUTE IMMEDIATE v_SQL_FINAL USING p_WORK_ID;
END CACHE_FML_REALM_ENTITIES;
---------------------------------------------------------------------------------------------------
PROCEDURE PROCESS_REALM
	(
	p_REALM_ID IN NUMBER,
	p_ITERATOR_VALS IN ITERATOR_VALS,
	p_NAME IN VARCHAR2,
	p_ITERATORS IN OUT PLS_INTEGER,
	p_VARIABLE_CACHE IN OUT NOCOPY UT.STRING_MAP,
	p_ITERATOR_DEPENDS IN OUT NOCOPY FML_UTIL.ITERATOR_DEPENDS,
	p_FML_REALMS IN OUT NOCOPY ID_FLAG_MAP,
	p_FML_REALM_WORK_IDs IN OUT NOCOPY BIGKEY_ID_MAP,
	p_ENTITY_ID OUT NUMBER,
	p_IS_FML_CHARGE_REALM OUT BOOLEAN
	) AS

v_REALM_CALC_TYPE	SYSTEM_REALM.REALM_CALC_TYPE%TYPE;
v_WORK_ID_KEY 		VARCHAR2(4000);
v_ITERATORS			PLS_INTEGER;
v_REALM_NAME		VARCHAR2(80) := p_NAME||'*REALM*';

BEGIN
	IF p_FML_REALMS.EXISTS(p_REALM_ID) THEN
		p_IS_FML_CHARGE_REALM := p_FML_REALMS(p_REALM_ID);
	ELSE
		SELECT NVL(MAX(REALM_CALC_TYPE),0)
		INTO v_REALM_CALC_TYPE
		FROM SYSTEM_REALM
		WHERE REALM_ID = p_REALM_ID;

		p_IS_FML_CHARGE_REALM := v_REALM_CALC_TYPE IN (EM.c_REALM_CALC_TYPE_FML, EM.c_REALM_CALC_TYPE_CALC);
		p_FML_REALMS(p_REALM_ID) := p_IS_FML_CHARGE_REALM;
	END IF;
	-- it is a formula charge realm? then we need to cache IDs if not already
	IF p_IS_FML_CHARGE_REALM THEN
		FML_UTIL.LOG_ITERATOR_DEPENDS(p_ITERATOR_DEPENDS);
		IF p_ITERATOR_DEPENDS.EXISTS(v_REALM_NAME) THEN
			-- see if we've already cached it - if not, cache it now
			v_ITERATORS := p_ITERATOR_DEPENDS(v_REALM_NAME);
			v_WORK_ID_KEY := GET_FML_REALM_CACHE_KEY(p_REALM_ID, v_ITERATORS, p_ITERATOR_VALS);

			IF p_FML_REALM_WORK_IDs.EXISTS(v_WORK_ID_KEY) AND
					-- don't re-use if "special" bit is set - indicates realm depends on inputs or
					-- intermediates (mainly occurs with realms used to define results/outputs for
					-- calc components)
					BITAND(v_ITERATORS, c_SPECIAL_BIT) = 0 THEN
				p_ENTITY_ID := p_FML_REALM_WORK_IDs(v_WORK_ID_KEY);
				IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
					LOGS.LOG_DEBUG_DETAIL('Already cached realm entity IDs.');
				END IF;
			ELSE
				CACHE_FML_REALM_ENTITIES(p_REALM_ID, p_VARIABLE_CACHE, p_ITERATOR_DEPENDS, v_ITERATORS, p_ENTITY_ID);
				p_FML_REALM_WORK_IDs(v_WORK_ID_KEY) := p_ENTITY_ID;
			END IF;
		ELSE
			-- don't have dependancies for this input? then cache IDs and track the iterators it depends on
			CACHE_FML_REALM_ENTITIES(p_REALM_ID, p_VARIABLE_CACHE, p_ITERATOR_DEPENDS, v_ITERATORS, p_ENTITY_ID);
			v_WORK_ID_KEY := GET_FML_REALM_CACHE_KEY(p_REALM_ID, v_ITERATORS, p_ITERATOR_VALS);
			p_FML_REALM_WORK_IDs(v_WORK_ID_KEY) := p_ENTITY_ID;
			-- store dependencies just for this realm
			p_ITERATOR_DEPENDS(v_REALM_NAME) := v_ITERATORS;
		END IF;
		-- update outbound dependencies to include those from this realm
		p_ITERATORS := FML_UTIL.COMBINE_DEPENDS(p_ITERATORS,v_ITERATORS);

		IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
			LOGS.LOG_DEBUG_DETAIL('FmlChargeRealm-WorkKey='||v_WORK_ID_KEY);
			LOGS.LOG_DEBUG_DETAIL('FmlChargeRealm-WorkID='||p_ENTITY_ID);
		END IF;
	ELSE
		-- nothing special to do - return the realm ID
		p_ENTITY_ID := p_REALM_ID;
		-- no additional dependencies
	END IF;
END PROCESS_REALM;
---------------------------------------------------------------------------------------------------
PROCEDURE PARSE_FIELD_FOR_TRANSACTION
	(
	p_FIELD IN VARCHAR2,
	p_IS_TRAIT OUT BOOLEAN,
	p_TRAIT_GROUP_ID OUT NUMBER,
	p_TRAIT_INDEX OUT NUMBER
	) AS
v_TOKENS GA.STRING_TABLE;
BEGIN
	IF SUBSTR(p_FIELD,1,9) = 'TRAIT_VAL' THEN
		p_IS_TRAIT := TRUE;
		UT.TOKENS_FROM_STRING(p_FIELD,':',v_TOKENS);
		-- second and third token are group ID and trait index
		p_TRAIT_GROUP_ID := v_TOKENS(v_TOKENS.NEXT(v_TOKENS.FIRST));
		p_TRAIT_INDEX := v_TOKENS(v_TOKENS.NEXT(v_TOKENS.NEXT(v_TOKENS.FIRST)));
	ELSE
		p_IS_TRAIT := FALSE;
	END IF;
END PARSE_FIELD_FOR_TRANSACTION;
---------------------------------------------------------------------------------------------------
PROCEDURE PARSE_FIELD_FOR_METER_POINT
	(
	p_FIELD IN VARCHAR2,
	p_ALLOW_LOSS_FACTOR IN BOOLEAN,
	p_COLUMN_NAME OUT VARCHAR2,
	p_IS_LOSS_FACTOR OUT BOOLEAN,
	p_LOSS_FORM OUT NUMBER,
	p_RAW_METER_VALS OUT BOOLEAN
	) AS
BEGIN
	p_COLUMN_NAME := p_FIELD;
	p_RAW_METER_VALS := FALSE;

	IF p_ALLOW_LOSS_FACTOR AND SUBSTR(p_COLUMN_NAME,1,12) = 'LOSS_FACTOR:' THEN
		p_IS_LOSS_FACTOR := TRUE;
		p_COLUMN_NAME := SUBSTR(p_COLUMN_NAME,13);
	ELSE
		p_IS_LOSS_FACTOR := FALSE;

		-- * at the end of COLUMN_NAME indicates raw values
		IF SUBSTR(p_COLUMN_NAME, -1) = '*' THEN
			p_COLUMN_NAME := SUBSTR(p_COLUMN_NAME, 1, LENGTH(p_COLUMN_NAME)-1);
			p_RAW_METER_VALS := TRUE;
		END IF;

		-- :A or :L indicates loss-adjusted values or loss energy values respectively
		IF SUBSTR(p_COLUMN_NAME, -2) IN (':A',':L') THEN
			p_LOSS_FORM := CASE SUBSTR(p_COLUMN_NAME, -1)
							WHEN 'A' THEN CALC_UTIL.c_FORM_LOSS_ADJUSTED_ENERGY
							ELSE CALC_UTIL.c_FORM_LOSSES_ONLY
							END;
			p_COLUMN_NAME := SUBSTR(p_COLUMN_NAME, 1, LENGTH(p_COLUMN_NAME)-2);
		ELSE
			p_LOSS_FORM := NULL; -- no loss form - just query for meter values
		END IF;

	END IF;

END PARSE_FIELD_FOR_METER_POINT;
---------------------------------------------------------------------------------------------------
PROCEDURE REBUILD_QUERY_PORTION
	(
	p_QUERY_PORTION IN VARCHAR2,
	p_VARIABLE_CACHE IN OUT NOCOPY UT.STRING_MAP,
	p_ITERATOR_DEPENDS IN FML_UTIL.ITERATOR_DEPENDS,
	p_ITERATORS IN OUT PLS_INTEGER,
	p_RESULT OUT VARCHAR2
	) AS
v_ITERATORS PLS_INTEGER;
BEGIN
	-- translate query portion, processing variable references
	FML_UTIL.REBUILD_FORMULA(p_QUERY_PORTION, p_VARIABLE_CACHE, p_ITERATOR_DEPENDS, v_ITERATORS, p_RESULT,
							 TRUE, TRUE, FML_UTIL.c_PLSQL_NO, TRUE);
	-- combine dependencies of this portion with existing dependency info
	p_ITERATORS := FML_UTIL.COMBINE_DEPENDS(p_ITERATORS, v_ITERATORS);
END REBUILD_QUERY_PORTION;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_FORMULA_INPUT_VALUES
	(
    p_COMPONENT_ID IN NUMBER,
	p_CHARGE_ID IN NUMBER,
	p_ITERATOR_ID IN NUMBER,
    p_CHARGE_INTERVAL IN VARCHAR2,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_LOCAL_BEGIN_DATE IN DATE,
    p_LOCAL_END_DATE IN DATE,
    p_THE_DATE IN DATE,
	p_WEEK_BEGIN IN VARCHAR2,
    p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_DATE_OUTERMOST_LOOP IN BOOLEAN,
    p_INPUTS IN INPUT_TABLE,
	p_ITERATOR_VALS IN ITERATOR_VALS,
    p_VARIABLES IN OUT NOCOPY VARIABLE_TABLE,
	p_VARIABLE_CACHE IN OUT NOCOPY UT.STRING_MAP,
	p_CHANGED_ITERATORS IN PLS_INTEGER,
	p_ITERATOR_DEPENDS IN OUT NOCOPY FML_UTIL.ITERATOR_DEPENDS,
	p_FML_REALMS IN OUT NOCOPY ID_FLAG_MAP,
	p_FML_REALM_WORK_IDs IN OUT NOCOPY BIGKEY_ID_MAP
    ) AS
v_VALUE 		NUMBER;
v_LOCAL_BEGIN_DATE DATE;
v_LOCAL_END_DATE DATE;
v_BEGIN_DATE	DATE;
v_END_DATE 		DATE;
v_FUNCTION 		VARCHAR2(32);
v_COLUMN_NAME 	VARCHAR2(96); -- must fit column name plus surrounding expressions - like to check op code for sub-station meter point values
v_DAILY_DATE_COL_NAME VARCHAR2(256);
v_DATE_COL_NAME VARCHAR2(40);
v_INTERVAL_COL_NAME VARCHAR2(256);
v_ID_JOIN_COL_NAME vARCHAR2(40);
v_SELECT_CLAUSE	VARCHAR2(4000);
v_FROM_CLAUSE 	VARCHAR2(4000);
v_WHERE_CLAUSE_BEFORE VARCHAR2(4000);
v_WHERE_CLAUSE_AFTER VARCHAR2(4000);
v_QUERY_PORTION	VARCHAR2(32767);
v_SQL 			VARCHAR2(32767);
v_TRUNC_DATE 	BOOLEAN;
v_SIMPLE_DATE 	BOOLEAN;
v_AS_OF_DATE 	DATE;
v_INDEX 		PLS_INTEGER;
v_ENTITY_ID 	NUMBER;
v_IS_FML_CHARGE_REALM BOOLEAN;
v_IS_TRAIT 		BOOLEAN;
v_TG_ID 		TRANSACTION_TRAIT.TRAIT_GROUP_ID%TYPE;
v_T_IDX 		TRANSACTION_TRAIT.TRAIT_INDEX%TYPE;
v_USE_SCHEDULE_TYPE TRANSACTION_TRAIT_GROUP.IS_STATEMENT_TYPE_SPECIFIC%TYPE;
v_IS_SPARSE		TRANSACTION_TRAIT_GROUP.IS_SPARSE%TYPE;
v_NEED_PRI_SOURCE BOOLEAN;
v_MTR_PT_STRING	VARCHAR2(40);
v_ITERATORS		PLS_INTEGER;
v_ALL_ENTITIES	BOOLEAN;
v_IS_LOSS_FACTOR BOOLEAN;
v_LOSS_FORM		NUMBER;
v_RAW_METER_VALS BOOLEAN;
v_MTR_PT_TBL_ALIAS VARCHAR2(30);
BEGIN
	v_INDEX := p_INPUTS.FIRST;
    WHILE p_INPUTS.EXISTS(v_INDEX) LOOP
		IF (p_INPUTS(v_INDEX).PERSIST_VALUE = 1 OR p_DATE_OUTERMOST_LOOP) AND
		   NOT FML_UTIL.DEPENDS_CHANGED(p_ITERATOR_ID,p_CHANGED_ITERATORS, p_ITERATOR_DEPENDS, p_INPUTS(v_INDEX).INPUT_NAME)
		   THEN

			IF NOT p_DATE_OUTERMOST_LOOP THEN
				-- date is inner loop? then get value for this date from previous iterator ID
				v_VALUE := GET_VARIABLE_VALUE(p_CHARGE_ID, p_THE_DATE, p_INPUTS(v_INDEX).INPUT_NAME, p_ITERATOR_ID-1);
			ELSE
				-- date is outer loop? just re-use value in collection
				v_VALUE := REUSE_VALUE(p_INPUTS(v_INDEX).INPUT_NAME, p_VARIABLE_CACHE);
			END IF;

		ELSE
			v_VALUE := NULL;
		END IF;
		-- if dependants have changed or missing prior value, then query the value
		IF v_VALUE IS NULL THEN
        	v_FUNCTION := UPPER(p_INPUTS(v_INDEX).FUNCTION);
            v_TRUNC_DATE := v_FUNCTION IN ('CHOOSE','SPREAD');
			v_SIMPLE_DATE := v_FUNCTION = 'SELECT';
			v_ALL_ENTITIES := FALSE;
            v_ENTITY_ID := p_INPUTS(v_INDEX).ENTITY_ID;
			v_ITERATORS := FML_UTIL.c_SINGLE_ITER_NODEPENDS;

			-- we need four values - begin and end times in both local and CUT time zones.
			-- leave blank the ones that need calculation based on time zone
    		IF v_FUNCTION IN ('YTD SUM','YTD AVERAGE') THEN
            	v_LOCAL_BEGIN_DATE := TRUNC(p_LOCAL_BEGIN_DATE,'YY')+1/86400;
				v_BEGIN_DATE := NULL;
                v_LOCAL_END_DATE := p_LOCAL_BEGIN_DATE-1/86400;
				v_END_DATE := p_BEGIN_DATE-1/86400;
            ELSIF v_FUNCTION IN ('YTD-INC SUM','YTD-INC AVERAGE') THEN
            	v_LOCAL_BEGIN_DATE := TRUNC(p_LOCAL_BEGIN_DATE,'YY')+1/86400;
				v_BEGIN_DATE := NULL;
                v_LOCAL_END_DATE := p_LOCAL_END_DATE;
                v_END_DATE := p_END_DATE;
    		ELSIF v_FUNCTION IN ('MTD SUM','MTD AVERAGE') THEN
            	v_LOCAL_BEGIN_DATE := TRUNC(p_LOCAL_BEGIN_DATE,'MM')+1/86400;
				v_BEGIN_DATE := NULL;
                v_LOCAL_END_DATE := p_LOCAL_BEGIN_DATE-1/86400;
				v_END_DATE := p_BEGIN_DATE-1/86400;
            ELSIF v_FUNCTION IN ('MTD-INC SUM','MTD-INC AVERAGE') THEN
            	v_LOCAL_BEGIN_DATE := TRUNC(p_LOCAL_BEGIN_DATE,'MM')+1/86400;
				v_BEGIN_DATE := NULL;
                v_LOCAL_END_DATE := p_LOCAL_END_DATE;
                v_END_DATE := p_END_DATE;
            ELSIF v_FUNCTION IN ('ANNUAL SUM', 'ANNUAL AVERAGE') THEN
            	v_LOCAL_BEGIN_DATE := ADD_MONTHS(p_LOCAL_BEGIN_DATE,-12);
            	v_BEGIN_DATE := NULL;
                v_LOCAL_END_DATE := p_LOCAL_BEGIN_DATE-1/86400;
				v_END_DATE := p_BEGIN_DATE-1/86400;
            ELSIF v_FUNCTION IN ('ANNUAL-INC SUM', 'ANNUAL-INC AVERAGE') THEN
            	v_LOCAL_BEGIN_DATE := ADD_MONTHS(p_LOCAL_END_DATE,-12)+1/86400;
				v_BEGIN_DATE := p_BEGIN_DATE;
                v_LOCAL_END_DATE := p_LOCAL_END_DATE;
                v_END_DATE := p_END_DATE;
            ELSIF v_FUNCTION IN ('MAX','MIN','AVERAGE','NZ-MIN','NZ-AVERAGE','SUM') THEN
    			v_LOCAL_BEGIN_DATE := p_LOCAL_BEGIN_DATE;
    			v_BEGIN_DATE := p_BEGIN_DATE;
                v_LOCAL_END_DATE := p_LOCAL_END_DATE;
                v_END_DATE := p_END_DATE;
			ELSIF v_FUNCTION = 'SELECT' THEN
				-- might need v_LOCAL_BEGIN_DATE if input references entity group or
				-- if input is a meter data point and we want to look-up primary measurement source
				v_LOCAL_BEGIN_DATE := p_LOCAL_BEGIN_DATE;
				-- otherwise, just need v_BEGIN_DATE set for this one
				v_BEGIN_DATE := p_THE_DATE;
            ELSE
    			XS.CUSTOM_FORMULA_FUNCTION_DATES(v_FUNCTION,p_LOCAL_BEGIN_DATE,p_LOCAL_END_DATE,v_LOCAL_BEGIN_DATE,v_LOCAL_END_DATE);
				v_BEGIN_DATE := NULL;
				v_END_DATE := NULL;
            END IF;

			IF v_FUNCTION = 'SELECT' THEN
				IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
					LOGS.LOG_DEBUG_DETAIL('v_begin_date = '||TEXT_UTIL.TO_CHAR_TIME(v_BEGIN_DATE));
				END IF;
			ELSE
				-- if necessary, calculate time zone shift for dates
				IF v_BEGIN_DATE IS NULL THEN
					-- TO_CUT will truncate to the minute when the timestamp indicates one second past midnight because
					-- that is how it distinguishes between the two HE 2s on the 25-hour day - so we must add the second back
					-- to the begin date+time
					v_BEGIN_DATE := TO_CUT(v_LOCAL_BEGIN_DATE,p_TIME_ZONE)+1/86400;
				END IF;
				IF v_END_DATE IS NULL THEN
					v_END_DATE := TO_CUT(v_LOCAL_END_DATE,p_TIME_ZONE);
				END IF;

				IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
					LOGS.LOG_DEBUG_DETAIL('v_local_begin_date = '||TEXT_UTIL.TO_CHAR_TIME(v_LOCAL_BEGIN_DATE));
					LOGS.LOG_DEBUG_DETAIL('v_local_end_date = '||TEXT_UTIL.TO_CHAR_TIME(v_LOCAL_END_DATE));
					LOGS.LOG_DEBUG_DETAIL('v_begin_date = '||TEXT_UTIL.TO_CHAR_TIME(v_BEGIN_DATE));
					LOGS.LOG_DEBUG_DETAIL('v_end_date = '||TEXT_UTIL.TO_CHAR_TIME(v_END_DATE));
				END IF;
			END IF;

			-- realm? then see if it's a formula charge realm and if so cache all IDs
			-- if necessary
			IF p_INPUTS(v_INDEX).ENTITY_TYPE = 'R' THEN
				PROCESS_REALM(v_ENTITY_ID, p_ITERATOR_VALS, p_INPUTS(v_INDEX).INPUT_NAME,
							v_ITERATORS, p_VARIABLE_CACHE,
							p_ITERATOR_DEPENDS, p_FML_REALMS, p_FML_REALM_WORK_IDs,
							v_ENTITY_ID, v_IS_FML_CHARGE_REALM);
			END IF;

			v_COLUMN_NAME := 'DATA.'||p_INPUTS(v_INDEX).WHAT_FIELD;
			v_IS_TRAIT := FALSE;
			v_NEED_PRI_SOURCE := FALSE;

        	-- grab input from appropriate table based on input's domain ID

			-- TRANSACTIONS
            IF p_INPUTS(v_INDEX).ENTITY_DOMAIN_ID = EC.ED_TRANSACTION THEN
				PARSE_FIELD_FOR_TRANSACTION(p_INPUTS(v_INDEX).WHAT_FIELD, v_IS_TRAIT, v_TG_ID, v_T_IDX);
				IF v_IS_TRAIT THEN
					v_COLUMN_NAME := 'DATA.TRAIT_VAL';
					-- get attributes of selected trait group
					SELECT MAX(IS_STATEMENT_TYPE_SPECIFIC),
							MAX(IS_SPARSE)
					INTO v_USE_SCHEDULE_TYPE, v_IS_SPARSE
					FROM TRANSACTION_TRAIT_GROUP
					WHERE TRAIT_GROUP_ID = v_TG_ID;
					-- can't do sparse traits!
					ASSERT(NVL(v_IS_SPARSE,0)=0, 'Cannot use sparse traits as inputs');
				END IF;

                v_DAILY_DATE_COL_NAME := 'DATA.SCHEDULE_DATE';
                v_DATE_COL_NAME := 'DATA.SCHEDULE_DATE';
				v_ID_JOIN_COL_NAME := 'TBL.TRANSACTION_ID';

                v_FROM_CLAUSE := 'INTERCHANGE_TRANSACTION TBL, ';
				IF v_IS_TRAIT THEN
					-- join trait tables and use trait's interval
	                v_INTERVAL_COL_NAME := 'CASE TG.TRAIT_GROUP_INTERVAL WHEN ''<Offer>'' THEN MM.GET_BID_OFFER_INTERVAL(TBL.TRANSACTION_ID) ELSE TG.TRAIT_GROUP_INTERVAL END';
					v_FROM_CLAUSE := v_FROM_CLAUSE||'TRANSACTION_TRAIT_GROUP TG, IT_TRAIT_SCHEDULE DATA';
					v_WHERE_CLAUSE_BEFORE := 'DATA.TRANSACTION_ID = TBL.TRANSACTION_ID';
					v_WHERE_CLAUSE_BEFORE := v_WHERE_CLAUSE_BEFORE||' AND TG.TRAIT_GROUP_ID = DATA.TRAIT_GROUP_ID';
					v_WHERE_CLAUSE_BEFORE := v_WHERE_CLAUSE_BEFORE||' AND DATA.TRAIT_GROUP_ID = :TG';
					v_WHERE_CLAUSE_BEFORE := v_WHERE_CLAUSE_BEFORE||' AND DATA.TRAIT_INDEX = :TI';
					REBUILD_QUERY_PORTION(p_INPUTS(v_INDEX).SET_NUMBER_FML, p_VARIABLE_CACHE, p_ITERATOR_DEPENDS,
											v_ITERATORS, v_QUERY_PORTION);
					v_WHERE_CLAUSE_BEFORE := v_WHERE_CLAUSE_BEFORE||' AND DATA.SET_NUMBER = '||NVL(v_QUERY_PORTION,c_DEFAULT_SET_NUMBER);
					IF v_USE_SCHEDULE_TYPE = 1 THEN
						IF p_INPUTS(v_INDEX).STATEMENT_TYPE_FML IS NULL THEN
							-- make sure we have a statement type - error if we don't
							IF NOT p_VARIABLE_CACHE.EXISTS(c_DEFAULT_STATEMENT_TYPE) THEN
								ERRS.RAISE(MSGCODES.c_ERR_NO_STATEMENT_TYPE);
							END IF;
							v_QUERY_PORTION := p_VARIABLE_CACHE(c_DEFAULT_STATEMENT_TYPE);
						ELSE
							REBUILD_QUERY_PORTION(p_INPUTS(v_INDEX).STATEMENT_TYPE_FML, p_VARIABLE_CACHE, p_ITERATOR_DEPENDS,
													v_ITERATORS, v_QUERY_PORTION);
						END IF;
						v_WHERE_CLAUSE_BEFORE := v_WHERE_CLAUSE_BEFORE||' AND DATA.STATEMENT_TYPE_ID = '||v_QUERY_PORTION;
					ELSE
						v_WHERE_CLAUSE_BEFORE := v_WHERE_CLAUSE_BEFORE||' AND DATA.STATEMENT_TYPE_ID = 0';
					END IF;
					REBUILD_QUERY_PORTION(p_INPUTS(v_INDEX).STATE_FML, p_VARIABLE_CACHE, p_ITERATOR_DEPENDS,
											v_ITERATORS, v_QUERY_PORTION);
					v_WHERE_CLAUSE_BEFORE := v_WHERE_CLAUSE_BEFORE||' AND DATA.SCHEDULE_STATE = '||NVL(v_QUERY_PORTION,c_DEFAULT_STATE);
					v_WHERE_CLAUSE_AFTER := NULL;
				ELSE
					-- just use IT_SCHEDULE table
	                v_INTERVAL_COL_NAME := 'TBL.TRANSACTION_INTERVAL';
					v_FROM_CLAUSE := v_FROM_CLAUSE||'IT_SCHEDULE DATA';
					v_WHERE_CLAUSE_BEFORE := 'DATA.TRANSACTION_ID = TBL.TRANSACTION_ID';
					IF p_INPUTS(v_INDEX).STATEMENT_TYPE_FML IS NULL THEN
						-- make sure we have a statement type - error if we don't
						IF NOT p_VARIABLE_CACHE.EXISTS(c_DEFAULT_STATEMENT_TYPE) THEN
							ERRS.RAISE(MSGCODES.c_ERR_NO_STATEMENT_TYPE);
						END IF;
						v_QUERY_PORTION := p_VARIABLE_CACHE(c_DEFAULT_STATEMENT_TYPE);
					ELSE
						REBUILD_QUERY_PORTION(p_INPUTS(v_INDEX).STATEMENT_TYPE_FML, p_VARIABLE_CACHE, p_ITERATOR_DEPENDS,
												v_ITERATORS, v_QUERY_PORTION);
					END IF;
					v_WHERE_CLAUSE_BEFORE := v_WHERE_CLAUSE_BEFORE||' AND DATA.SCHEDULE_TYPE = '||v_QUERY_PORTION;
					REBUILD_QUERY_PORTION(p_INPUTS(v_INDEX).STATE_FML, p_VARIABLE_CACHE, p_ITERATOR_DEPENDS,
											v_ITERATORS, v_QUERY_PORTION);
					v_WHERE_CLAUSE_BEFORE := v_WHERE_CLAUSE_BEFORE||' AND DATA.SCHEDULE_STATE = '||NVL(v_QUERY_PORTION,c_DEFAULT_STATE);
					IF GA.VERSION_SCHEDULE THEN
						v_AS_OF_DATE := p_AS_OF_DATE;
						v_WHERE_CLAUSE_AFTER := ' AND DATA.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)';
						v_WHERE_CLAUSE_AFTER := v_WHERE_CLAUSE_AFTER||' FROM IT_SCHEDULE';
						v_WHERE_CLAUSE_AFTER := v_WHERE_CLAUSE_AFTER||' WHERE TRANSACTION_ID = DATA.TRANSACTION_ID';
						v_WHERE_CLAUSE_AFTER := v_WHERE_CLAUSE_AFTER||' AND SCHEDULE_TYPE = DATA.SCHEDULE_TYPE';
						v_WHERE_CLAUSE_AFTER := v_WHERE_CLAUSE_AFTER||' AND SCHEDULE_STATE = DATA.SCHEDULE_STATE';
						v_WHERE_CLAUSE_AFTER := v_WHERE_CLAUSE_AFTER||' AND SCHEDULE_DATE = DATA.SCHEDULE_DATE';
						v_WHERE_CLAUSE_AFTER := v_WHERE_CLAUSE_AFTER||' AND AS_OF_DATE <= :4)';
					ELSE
						v_AS_OF_DATE := CONSTANTS.LOW_DATE;
						v_WHERE_CLAUSE_AFTER := ' AND DATA.AS_OF_DATE = :4';
					END IF;
				END IF;

			-- MARKET PRICES
            ELSIF p_INPUTS(v_INDEX).ENTITY_DOMAIN_ID = EC.ED_MARKET_PRICE THEN
				IF v_SIMPLE_DATE THEN
					-- dates are not stored as second-past-midnight in MARKET_PRICE_VALUE so strip off any seconds from
					-- join date
					v_BEGIN_DATE := TRUNC(v_BEGIN_DATE,'MI');
				END IF;

                v_DAILY_DATE_COL_NAME := 'DATA.PRICE_DATE+1/86400';
                v_DATE_COL_NAME := 'DATA.PRICE_DATE';
                v_INTERVAL_COL_NAME := 'TBL.MARKET_PRICE_INTERVAL';
				v_ID_JOIN_COL_NAME := 'TBL.MARKET_PRICE_ID';
                v_FROM_CLAUSE := 'MARKET_PRICE TBL, MARKET_PRICE_VALUE DATA';
				v_WHERE_CLAUSE_BEFORE := 'DATA.MARKET_PRICE_ID = TBL.MARKET_PRICE_ID';
				IF NVL(p_INPUTS(v_INDEX).CODE_FML,'?') = '?' THEN
					-- use best available price code if no price code specified
					v_WHERE_CLAUSE_AFTER := ' AND DATA.PRICE_CODE = (SELECT DECODE(MAX(DECODE(PRICE_CODE,''F'',1,''P'',2,''A'',3)),1,''F'',2,''P'',3,''A'')';
					v_WHERE_CLAUSE_AFTER := v_WHERE_CLAUSE_AFTER||' FROM MARKET_PRICE_VALUE';
					v_WHERE_CLAUSE_AFTER := v_WHERE_CLAUSE_AFTER||' WHERE MARKET_PRICE_ID = DATA.MARKET_PRICE_ID';
					v_WHERE_CLAUSE_AFTER := v_WHERE_CLAUSE_AFTER||' AND PRICE_DATE = DATA.PRICE_DATE)';
				ELSE
					REBUILD_QUERY_PORTION(p_INPUTS(v_INDEX).CODE_FML, p_VARIABLE_CACHE, p_ITERATOR_DEPENDS,
											v_ITERATORS, v_QUERY_PORTION);
					v_WHERE_CLAUSE_AFTER := ' AND DATA.PRICE_CODE = '||v_QUERY_PORTION;
				END IF;
                IF GA.VERSION_MARKET_PRICE THEN
                	v_AS_OF_DATE := p_AS_OF_DATE;
    	            v_WHERE_CLAUSE_AFTER := v_WHERE_CLAUSE_AFTER||' AND DATA.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)';
    	            v_WHERE_CLAUSE_AFTER := v_WHERE_CLAUSE_AFTER||' FROM MARKET_PRICE_VALUE';
    	            v_WHERE_CLAUSE_AFTER := v_WHERE_CLAUSE_AFTER||' WHERE MARKET_PRICE_ID = DATA.MARKET_PRICE_ID';
    	            v_WHERE_CLAUSE_AFTER := v_WHERE_CLAUSE_AFTER||' AND PRICE_CODE = DATA.PRICE_CODE';
    	            v_WHERE_CLAUSE_AFTER := v_WHERE_CLAUSE_AFTER||' AND PRICE_DATE = DATA.PRICE_DATE';
    	            v_WHERE_CLAUSE_AFTER := v_WHERE_CLAUSE_AFTER||' AND AS_OF_DATE <= :4)';
    			ELSE
                	v_AS_OF_DATE := CONSTANTS.LOW_DATE;
    				v_WHERE_CLAUSE_AFTER := v_WHERE_CLAUSE_AFTER||' AND DATA.AS_OF_DATE = :4';
                END IF;

			-- SUB-STATIONS, SUB-STATION METERS, and SUB-STATION METER DATA POINTS
			ELSIF p_INPUTS(v_INDEX).ENTITY_DOMAIN_ID IN (EC.ED_SUB_STATION, EC.ED_SUB_STATION_METER, EC.ED_SUB_STATION_METER_POINT) THEN
                v_INTERVAL_COL_NAME := '''Hour''';

				PARSE_FIELD_FOR_METER_POINT(p_INPUTS(v_INDEX).WHAT_FIELD,
							p_INPUTS(v_INDEX).ENTITY_DOMAIN_ID = EC.ED_SUB_STATION_METER_POINT, -- only allow loss factor for meter points
							v_COLUMN_NAME, v_IS_LOSS_FACTOR, v_LOSS_FORM, v_RAW_METER_VALS);

				IF v_IS_LOSS_FACTOR THEN
					v_DAILY_DATE_COL_NAME := 'DATA.CUT_DATE';
					v_DATE_COL_NAME := 'DATA.CUT_DATE';
					v_COLUMN_NAME := 'CALC_UTIL.GET_METER_LOSS_FACTOR('||
										'TBL.METER_POINT_ID, DATA.CUT_DATE, '''||p_TIME_ZONE||''')';
					v_ID_JOIN_COL_NAME := 'TBL.METER_POINT_ID';
					-- no actual data table since data comes from function call to CALC_UTIL.
					-- so just query system_date_time to make sure we're including every hourly
					-- interval and invoke the function to get the loss factor for each hour
					v_FROM_CLAUSE := 'TX_SUB_STATION_METER_POINT TBL, SYSTEM_DATE_TIME DATA';
					v_WHERE_CLAUSE_BEFORE := 'DATA.TIME_ZONE = '''||p_TIME_ZONE||'''';
					v_WHERE_CLAUSE_BEFORE := v_WHERE_CLAUSE_BEFORE||' AND DATA.DATA_INTERVAL_TYPE = 1 AND DATA.DAY_TYPE = ''1''';
					v_WHERE_CLAUSE_BEFORE := v_WHERE_CLAUSE_BEFORE||' AND DATA.MINIMUM_INTERVAL_NUMBER >= '||GET_INTERVAL_NUMBER('HH');
				ELSE
					v_DAILY_DATE_COL_NAME := 'DATA.METER_DATE';
					v_DATE_COL_NAME := 'DATA.METER_DATE';
					v_COLUMN_NAME := 'DATA.'||v_COLUMN_NAME;

					IF v_LOSS_FORM IS NOT NULL THEN
						-- have SQL use CALC_UTIL to get loss factor and multiply with column value
						v_COLUMN_NAME := '('||v_COLUMN_NAME||'*CALC_UTIL.GET_METER_LOSS_FACTOR('||
										'DATA.METER_POINT_ID, DATA.METER_DATE, '''||p_TIME_ZONE||''', '||
										'p_FORM => '||v_LOSS_FORM||'))';
					END IF;

					IF NOT v_RAW_METER_VALS THEN
						-- add in logic to use meter point's operation code
						IF p_INPUTS(v_INDEX).ENTITY_DOMAIN_ID = EC.ED_SUB_STATION_METER_POINT THEN
							v_MTR_PT_TBL_ALIAS := 'TBL';
						ELSE
							v_MTR_PT_TBL_ALIAS := 'MTRPT';
						END IF;
						v_COLUMN_NAME := 'CASE '||v_MTR_PT_TBL_ALIAS||'.OPERATION_CODE WHEN ''S'' THEN -1 WHEN ''A'' THEN 1 ELSE 0 END * '||v_COLUMN_NAME;
					END IF;

					IF p_INPUTS(v_INDEX).ENTITY_DOMAIN_ID = EC.ED_SUB_STATION THEN
						v_ID_JOIN_COL_NAME := 'TBL.SUB_STATION_ID';
						v_MTR_PT_STRING	:= 'MTRPT.METER_POINT_ID';
						v_FROM_CLAUSE := 'TX_SUB_STATION TBL, TX_SUB_STATION_METER MTR, TX_SUB_STATION_METER_POINT MTRPT, TX_SUB_STATION_METER_PT_VALUE DATA';
						v_WHERE_CLAUSE_BEFORE := 'MTR.SUB_STATION_ID = TBL.SUB_STATION_ID';
						v_WHERE_CLAUSE_BEFORE := v_WHERE_CLAUSE_BEFORE||' AND MTRPT.METER_ID = MTR.METER_ID';
						v_WHERE_CLAUSE_BEFORE := v_WHERE_CLAUSE_BEFORE||' AND DATA.METER_POINT_ID = MTRPT.METER_POINT_ID';
					ELSIF p_INPUTS(v_INDEX).ENTITY_DOMAIN_ID = EC.ED_SUB_STATION_METER THEN
						v_ID_JOIN_COL_NAME := 'TBL.METER_ID';
						v_MTR_PT_STRING	:= 'MTRPT.METER_POINT_ID';
						v_FROM_CLAUSE := 'TX_SUB_STATION_METER TBL, TX_SUB_STATION_METER_POINT MTRPT, TX_SUB_STATION_METER_PT_VALUE DATA';
						v_WHERE_CLAUSE_BEFORE := 'MTRPT.METER_ID = TBL.METER_ID';
						v_WHERE_CLAUSE_BEFORE := v_WHERE_CLAUSE_BEFORE||' AND DATA.METER_POINT_ID = MTRPT.METER_POINT_ID';
					ELSE -- EC.ED_SUB_STATION_METER_POINT
						v_ID_JOIN_COL_NAME := 'TBL.METER_POINT_ID';
						v_MTR_PT_STRING	:= 'TBL.METER_POINT_ID';
						v_FROM_CLAUSE := 'TX_SUB_STATION_METER_POINT TBL, TX_SUB_STATION_METER_PT_VALUE DATA';
						v_WHERE_CLAUSE_BEFORE := 'DATA.METER_POINT_ID = TBL.METER_POINT_ID';
					END IF;

					IF NVL(p_INPUTS(v_INDEX).MEASUREMENT_SOURCE_FML,'?') = '?' THEN
						-- use default measurement source for this meter point
						v_NEED_PRI_SOURCE := TRUE;
						v_FROM_CLAUSE := v_FROM_CLAUSE||', TX_SUB_STATION_METER_PT_SOURCE MTRPTSRC';
						v_WHERE_CLAUSE_BEFORE := v_WHERE_CLAUSE_BEFORE||' AND MTRPTSRC.METER_POINT_ID = '||v_MTR_PT_STRING;
						v_WHERE_CLAUSE_BEFORE := v_WHERE_CLAUSE_BEFORE||' AND MTRPTSRC.IS_PRIMARY = 1';
						v_WHERE_CLAUSE_BEFORE := v_WHERE_CLAUSE_BEFORE||' AND :D BETWEEN MTRPTSRC.BEGIN_DATE AND NVL(MTRPTSRC.END_DATE,:H)';
						v_WHERE_CLAUSE_BEFORE := v_WHERE_CLAUSE_BEFORE||' AND DATA.MEASUREMENT_SOURCE_ID = MTRPTSRC.MEASUREMENT_SOURCE_ID';
					ELSE
						REBUILD_QUERY_PORTION(p_INPUTS(v_INDEX).MEASUREMENT_SOURCE_FML, p_VARIABLE_CACHE, p_ITERATOR_DEPENDS,
												v_ITERATORS, v_QUERY_PORTION);
						v_WHERE_CLAUSE_BEFORE := v_WHERE_CLAUSE_BEFORE||' AND DATA.MEASUREMENT_SOURCE_ID = '||v_QUERY_PORTION;
					END IF;

					IF NVL(p_INPUTS(v_INDEX).CODE_FML,'?') = '?' THEN
						-- use best available price code if no price code specified
						v_WHERE_CLAUSE_AFTER := ' AND DATA.METER_CODE = (SELECT DECODE(MAX(DECODE(METER_CODE,''F'',1,''P'',2,''A'',3)),1,''F'',2,''P'',3,''A'')';
						v_WHERE_CLAUSE_AFTER := v_WHERE_CLAUSE_AFTER||' FROM TX_SUB_STATION_METER_PT_VALUE';
						v_WHERE_CLAUSE_AFTER := v_WHERE_CLAUSE_AFTER||' WHERE METER_POINT_ID = DATA.METER_POINT_ID';
						v_WHERE_CLAUSE_AFTER := v_WHERE_CLAUSE_AFTER||' AND MEASUREMENT_SOURCE_ID = DATA.MEASUREMENT_SOURCE_ID';
						v_WHERE_CLAUSE_AFTER := v_WHERE_CLAUSE_AFTER||' AND METER_DATE = DATA.METER_DATE)';
					ELSE
						REBUILD_QUERY_PORTION(p_INPUTS(v_INDEX).CODE_FML, p_VARIABLE_CACHE, p_ITERATOR_DEPENDS,
												v_ITERATORS, v_QUERY_PORTION);
						v_WHERE_CLAUSE_AFTER := ' AND DATA.METER_CODE = '||v_QUERY_PORTION;
					END IF;

				END IF;

			-- MEASUREMENT SOURCES
            ELSIF p_INPUTS(v_INDEX).ENTITY_DOMAIN_ID = EC.ED_MEASUREMENT_SOURCE THEN
                v_DAILY_DATE_COL_NAME := 'DATA.SOURCE_DATE';
                v_DATE_COL_NAME := 'DATA.SOURCE_DATE';
                v_INTERVAL_COL_NAME := 'TBL.MEASUREMENT_SOURCE_INTERVAL';
				v_ID_JOIN_COL_NAME := 'TBL.MEASUREMENT_SOURCE_ID';
                v_FROM_CLAUSE := 'MEASUREMENT_SOURCE TBL, MEASUREMENT_SOURCE_VALUE DATA';
				v_WHERE_CLAUSE_BEFORE := 'DATA.MEASUREMENT_SOURCE_ID = TBL.MEASUREMENT_SOURCE_ID';

    		ELSE
            	v_COLUMN_NAME := NULL;
                v_DAILY_DATE_COL_NAME := NULL;
				v_ID_JOIN_COL_NAME := NULL;
                v_INTERVAL_COL_NAME := NULL;
				v_FROM_CLAUSE := NULL;
                v_WHERE_CLAUSE_BEFORE := NULL;
                v_WHERE_CLAUSE_AFTER := NULL;
            END IF;

			-- add additional info to query portions for realms
			IF p_INPUTS(v_INDEX).ENTITY_TYPE = 'R' THEN
				IF v_ENTITY_ID = SD.g_ALL_DATA_REALM_ID THEN
					v_ALL_ENTITIES := TRUE;
				ELSE
					IF v_IS_FML_CHARGE_REALM THEN
						-- formula charge realms have IDs cached in RTO_WORK
						v_FROM_CLAUSE := v_FROM_CLAUSE||', RTO_WORK ENT';
						v_WHERE_CLAUSE_BEFORE := 'ENT.WORK_ID = :3 AND '||v_ID_JOIN_COL_NAME||' = ENT.WORK_XID AND '||v_WHERE_CLAUSE_BEFORE;
					ELSE
						v_FROM_CLAUSE := v_FROM_CLAUSE||', SYSTEM_REALM_ENTITY ENT';
						v_WHERE_CLAUSE_BEFORE := 'ENT.REALM_ID = :3 AND '||v_ID_JOIN_COL_NAME||' = ENT.ENTITY_ID AND '||v_WHERE_CLAUSE_BEFORE;
					END IF;
				END IF;

			-- add additional info to query portions for entity groups
			ELSIF p_INPUTS(v_INDEX).ENTITY_TYPE = 'G' THEN
				-- include entire group hierarchy
				v_FROM_CLAUSE := v_FROM_CLAUSE||', (SELECT ENTITY_GROUP_ID FROM ENTITY_GROUP START WITH ENTITY_GROUP_ID = :3 CONNECT BY PARENT_GROUP_ID = PRIOR ENTITY_GROUP_ID AND ENTITY_DOMAIN_ID = PRIOR ENTITY_DOMAIN_ID) GRP, ENTITY_GROUP_ASSIGNMENT ENT';
				v_WHERE_CLAUSE_BEFORE := 'ENT.ENTITY_GROUP_ID = GRP.ENTITY_GROUP_ID AND '||v_ID_JOIN_COL_NAME||' = ENT.ENTITY_ID AND :D BETWEEN ENT.BEGIN_DATE AND NVL(ENT.END_DATE,:H) AND '||v_WHERE_CLAUSE_BEFORE;

			-- add final info to query portions for entities
			ELSE-- ENTITY_TYPE = 'E'
				v_WHERE_CLAUSE_BEFORE := v_ID_JOIN_COL_NAME||' = :3 AND '||v_WHERE_CLAUSE_BEFORE;
			END IF;


            -- stick the date clauses in
			IF v_SIMPLE_DATE THEN
            	v_WHERE_CLAUSE_BEFORE := v_WHERE_CLAUSE_BEFORE||' AND '||v_DATE_COL_NAME||' = :1';
            ELSIF NOT v_TRUNC_DATE THEN
                -- use interval to determine if we need to use local begin/end dates or CUT begin/end times
            	v_WHERE_CLAUSE_BEFORE := v_WHERE_CLAUSE_BEFORE||' AND '||v_DATE_COL_NAME||' BETWEEN :1 AND :2';
            	v_WHERE_CLAUSE_BEFORE := v_WHERE_CLAUSE_BEFORE||' AND ((SUBSTR(UPPER('||v_INTERVAL_COL_NAME||'),1,2) IN (''DA'',''WE'',''MO'',''QU'',''YE'')';
            	v_WHERE_CLAUSE_BEFORE := v_WHERE_CLAUSE_BEFORE||'     AND '||v_DAILY_DATE_COL_NAME||' BETWEEN :A and :B)';
            	v_WHERE_CLAUSE_BEFORE := v_WHERE_CLAUSE_BEFORE||'   OR (NOT (SUBSTR(UPPER('||v_INTERVAL_COL_NAME||'),1,2) IN (''DA'',''WE'',''MO'',''QU'',''YE''))';
            	v_WHERE_CLAUSE_BEFORE := v_WHERE_CLAUSE_BEFORE||'     AND '||v_DATE_COL_NAME||' BETWEEN :C and :D))';
            ELSE
            	v_WHERE_CLAUSE_BEFORE := v_WHERE_CLAUSE_BEFORE||' AND '||v_DATE_COL_NAME||' BETWEEN TRUNC(:1, DATE_UTIL.GET_ORA_TRUNC_INTERVAL('||v_INTERVAL_COL_NAME||')) AND :2';
            	v_WHERE_CLAUSE_BEFORE := v_WHERE_CLAUSE_BEFORE||' AND ((SUBSTR(UPPER('||v_INTERVAL_COL_NAME||'),1,2) IN (''DA'',''WE'',''MO'',''QU'',''YE'')';
                v_WHERE_CLAUSE_BEFORE := v_WHERE_CLAUSE_BEFORE||'     AND DATE_UTIL.PROPER_TRUNC_DATE('||v_DAILY_DATE_COL_NAME||','||v_INTERVAL_COL_NAME||','''||p_CHARGE_INTERVAL||''','''||p_TIME_ZONE||''','''||p_WEEK_BEGIN||''')';
                v_WHERE_CLAUSE_BEFORE := v_WHERE_CLAUSE_BEFORE||'        = DATE_UTIL.PROPER_TRUNC_DATE(:A,'''||p_CHARGE_INTERVAL||''','||v_INTERVAL_COL_NAME||','''||p_TIME_ZONE||''','''||p_WEEK_BEGIN||'''))';
            	v_WHERE_CLAUSE_BEFORE := v_WHERE_CLAUSE_BEFORE||'   OR (NOT (SUBSTR(UPPER('||v_INTERVAL_COL_NAME||'),1,2) IN (''DA'',''WE'',''MO'',''QU'',''YE''))';
                v_WHERE_CLAUSE_BEFORE := v_WHERE_CLAUSE_BEFORE||'     AND DATE_UTIL.PROPER_TRUNC_DATE('||v_DATE_COL_NAME||','||v_INTERVAL_COL_NAME||','''||p_CHARGE_INTERVAL||''','''||p_TIME_ZONE||''','''||p_WEEK_BEGIN||''')';
                v_WHERE_CLAUSE_BEFORE := v_WHERE_CLAUSE_BEFORE||'        = DATE_UTIL.PROPER_TRUNC_DATE(:A,'''||p_CHARGE_INTERVAL||''','||v_INTERVAL_COL_NAME||','''||p_TIME_ZONE||''','''||p_WEEK_BEGIN||''')))';
            END IF;

    		IF v_FUNCTION IN ('YTD SUM','YTD-INC SUM','MTD SUM','MTD-INC SUM','ANNUAL SUM','ANNUAL-INC SUM','SUM') THEN
            	v_SELECT_CLAUSE := 'SELECT SUM('||v_COLUMN_NAME||')';
            ELSIF v_FUNCTION IN ('YTD AVERAGE','YTD-INC AVERAGE','MTD AVERAGE','MTD-INC AVERAGE','ANNUAL AVERAGE','ANNUAL-INC AVERAGE','AVERAGE','NZ-AVERAGE') THEN
            	v_SELECT_CLAUSE := 'SELECT AVG('||v_COLUMN_NAME||')';
            ELSIF v_FUNCTION IN ('MIN', 'NZ-MIN') THEN
            	v_SELECT_CLAUSE := 'SELECT MIN('||v_COLUMN_NAME||')';
            ELSIF v_FUNCTION = 'MAX' THEN
            	v_SELECT_CLAUSE := 'SELECT MAX('||v_COLUMN_NAME||')';
    		ELSIF v_FUNCTION IN ('CHOOSE','SELECT') THEN
            	v_SELECT_CLAUSE := 'SELECT '||v_COLUMN_NAME;
            ELSIF v_FUNCTION = 'SPREAD' THEN
            	v_SELECT_CLAUSE := 'SELECT '||v_COLUMN_NAME||'/DATE_UTIL.GET_INTERVAL_DIVISOR('||v_INTERVAL_COL_NAME||','''||p_CHARGE_INTERVAL||''','||v_DAILY_DATE_COL_NAME||','''||p_TIME_ZONE||''','''||p_WEEK_BEGIN||''')';
            ELSE
    			XS.CUSTOM_FORMULA_FUNCTION_SELECT(v_FUNCTION,v_COLUMN_NAME,v_SELECT_CLAUSE);
            END IF;


			-- Add any custom where clause criteria
			IF NVL(TRIM(p_INPUTS(v_INDEX).WHERE_CLAUSE),'?') = '?' THEN
				-- no custom where clause
				v_WHERE_CLAUSE_BEFORE := ' WHERE '||v_WHERE_CLAUSE_BEFORE;
			ELSE
				-- interpret any variable references in the where clause
				REBUILD_QUERY_PORTION(p_INPUTS(v_INDEX).WHERE_CLAUSE, p_VARIABLE_CACHE,
									p_ITERATOR_DEPENDS, v_ITERATORS, v_QUERY_PORTION);

				v_WHERE_CLAUSE_BEFORE := ' '||v_QUERY_PORTION||' AND '||v_WHERE_CLAUSE_BEFORE;
			END IF;

			-- update iterator dependency mask and flag it with "special" bit indicating
			-- it depends on input or intermediate variable
			p_ITERATOR_DEPENDS(p_INPUTS(v_INDEX).INPUT_NAME) := FML_UTIL.COMBINE_DEPENDS(v_ITERATORS, c_SPECIAL_BIT);

			-- Build the final SQL
            v_SQL := v_SELECT_CLAUSE||' FROM '||v_FROM_CLAUSE||v_WHERE_CLAUSE_BEFORE||' '||v_WHERE_CLAUSE_AFTER;

            -- add non-zero clause
            IF SUBSTR(v_FUNCTION,1,3) = 'NZ-' THEN
            	v_SQL := v_SQL||' AND '||v_COLUMN_NAME||' <> 0';
            END IF;
            IF v_TRUNC_DATE THEN
            	v_SQL := v_SQL||' AND ROWNUM=1';
            END IF;

            IF LOGS.IS_DEBUG_ENABLED THEN
				LOGS.LOG_DEBUG('Input query (before) = ');
				LOGS.LOG_DEBUG(v_SQL);
            END IF;

            -- execute the query to get the value!
            BEGIN
				-- NOTE!!!! There are numerous conditions for bind variable list, so please use
				-- EXTREME CAUTION when updating any of the following 'execute immediate' cases to make
				-- sure all cases are adequately covered!

				-- All entities? then leave ENTITY_ID out from bind variable set
				IF v_ALL_ENTITIES THEN
					-- Groups have additional bind variables for testing BEGIN_DATE and END_DATE
					-- in ENTITY_GROUP_ASSIGNMENT
					IF p_INPUTS(v_INDEX).ENTITY_TYPE = 'G' THEN
						-- Traits have additional bind variabels for the group ID and trait index
						IF v_IS_TRAIT THEN
							IF v_TRUNC_DATE THEN
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, v_TG_ID, v_T_IDX, v_LOCAL_BEGIN_DATE-1, v_LOCAL_END_DATE+1, p_THE_DATE, p_THE_DATE;
							ELSIF v_SIMPLE_DATE THEN
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, v_TG_ID, v_T_IDX, v_BEGIN_DATE;
							ELSE
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, v_TG_ID, v_T_IDX, v_LOCAL_BEGIN_DATE-1, v_LOCAL_END_DATE+1, v_LOCAL_BEGIN_DATE, v_LOCAL_END_DATE, v_BEGIN_DATE, v_END_DATE;
							END IF;
						-- schedules and prices have an AS_OF_DATE
						ELSIF p_INPUTS(v_INDEX).ENTITY_DOMAIN_ID IN (EC.ED_TRANSACTION, EC.ED_MARKET_PRICE) THEN
							IF v_TRUNC_DATE THEN
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, v_LOCAL_BEGIN_DATE-1, v_LOCAL_END_DATE+1, p_THE_DATE, p_THE_DATE, v_AS_OF_DATE;
							ELSIF v_SIMPLE_DATE THEN
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, v_BEGIN_DATE, v_AS_OF_DATE;
							ELSE
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, v_LOCAL_BEGIN_DATE-1, v_LOCAL_END_DATE+1, v_LOCAL_BEGIN_DATE, v_LOCAL_END_DATE, v_BEGIN_DATE, v_END_DATE, v_AS_OF_DATE;
							END IF;
						-- meter values that need a primary source need extra bind variable for join to TX_SUB_STATION_METER_PT_SOURCE
						ELSIF v_NEED_PRI_SOURCE THEN
							IF v_TRUNC_DATE THEN
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, v_LOCAL_BEGIN_DATE-1, v_LOCAL_END_DATE+1, p_THE_DATE, p_THE_DATE;
							ELSIF v_SIMPLE_DATE THEN
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, v_BEGIN_DATE;
							ELSE
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, v_LOCAL_BEGIN_DATE-1, v_LOCAL_END_DATE+1, v_LOCAL_BEGIN_DATE, v_LOCAL_END_DATE, v_BEGIN_DATE, v_END_DATE;
							END IF;
						ELSE
							IF v_TRUNC_DATE THEN
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, v_LOCAL_BEGIN_DATE-1, v_LOCAL_END_DATE+1, p_THE_DATE, p_THE_DATE;
							ELSIF v_SIMPLE_DATE THEN
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, v_BEGIN_DATE;
							ELSE
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, v_LOCAL_BEGIN_DATE-1, v_LOCAL_END_DATE+1, v_LOCAL_BEGIN_DATE, v_LOCAL_END_DATE, v_BEGIN_DATE, v_END_DATE;
							END IF;
						END IF;
					ELSE
						-- Traits have additional bind variables for the group ID and trait index
						IF v_IS_TRAIT THEN
							IF v_TRUNC_DATE THEN
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING v_TG_ID, v_T_IDX, v_LOCAL_BEGIN_DATE-1, v_LOCAL_END_DATE+1, p_THE_DATE, p_THE_DATE;
							ELSIF v_SIMPLE_DATE THEN
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING v_TG_ID, v_T_IDX, v_BEGIN_DATE;
							ELSE
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING v_TG_ID, v_T_IDX, v_LOCAL_BEGIN_DATE-1, v_LOCAL_END_DATE+1, v_LOCAL_BEGIN_DATE, v_LOCAL_END_DATE, v_BEGIN_DATE, v_END_DATE;
							END IF;
						-- schedules and prices have an AS_OF_DATE
						ELSIF p_INPUTS(v_INDEX).ENTITY_DOMAIN_ID IN (EC.ED_TRANSACTION, EC.ED_MARKET_PRICE) THEN
							IF v_TRUNC_DATE THEN
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING v_LOCAL_BEGIN_DATE-1, v_LOCAL_END_DATE+1, p_THE_DATE, p_THE_DATE, v_AS_OF_DATE;
							ELSIF v_SIMPLE_DATE THEN
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING v_BEGIN_DATE, v_AS_OF_DATE;
							ELSE
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING v_LOCAL_BEGIN_DATE-1, v_LOCAL_END_DATE+1, v_LOCAL_BEGIN_DATE, v_LOCAL_END_DATE, v_BEGIN_DATE, v_END_DATE, v_AS_OF_DATE;
							END IF;
						-- meter values that need a primary source need extra bind variable for join to TX_SUB_STATION_METER_PT_SOURCE
						ELSIF v_NEED_PRI_SOURCE THEN
							IF v_TRUNC_DATE THEN
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, v_LOCAL_BEGIN_DATE-1, v_LOCAL_END_DATE+1, p_THE_DATE, p_THE_DATE;
							ELSIF v_SIMPLE_DATE THEN
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, v_BEGIN_DATE;
							ELSE
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, v_LOCAL_BEGIN_DATE-1, v_LOCAL_END_DATE+1, v_LOCAL_BEGIN_DATE, v_LOCAL_END_DATE, v_BEGIN_DATE, v_END_DATE;
							END IF;
						ELSE
							IF v_TRUNC_DATE THEN
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING v_LOCAL_BEGIN_DATE-1, v_LOCAL_END_DATE+1, p_THE_DATE, p_THE_DATE;
							ELSIF v_SIMPLE_DATE THEN
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING v_BEGIN_DATE;
							ELSE
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING v_LOCAL_BEGIN_DATE-1, v_LOCAL_END_DATE+1, v_LOCAL_BEGIN_DATE, v_LOCAL_END_DATE, v_BEGIN_DATE, v_END_DATE;
							END IF;
						END IF;
					END IF;
				ELSE
					-- Groups have additional bind variables for testing BEGIN_DATE and END_DATE
					-- in ENTITY_GROUP_ASSIGNMENT
					IF p_INPUTS(v_INDEX).ENTITY_TYPE = 'G' THEN
						-- Traits have additional bind variabels for the group ID and trait index
						IF v_IS_TRAIT THEN
							IF v_TRUNC_DATE THEN
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING v_ENTITY_ID, TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, v_TG_ID, v_T_IDX, v_LOCAL_BEGIN_DATE-1, v_LOCAL_END_DATE+1, p_THE_DATE, p_THE_DATE;
							ELSIF v_SIMPLE_DATE THEN
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING v_ENTITY_ID, TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, v_TG_ID, v_T_IDX, v_BEGIN_DATE;
							ELSE
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING v_ENTITY_ID, TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, v_TG_ID, v_T_IDX, v_LOCAL_BEGIN_DATE-1, v_LOCAL_END_DATE+1, v_LOCAL_BEGIN_DATE, v_LOCAL_END_DATE, v_BEGIN_DATE, v_END_DATE;
							END IF;
						-- schedules and prices have an AS_OF_DATE
						ELSIF p_INPUTS(v_INDEX).ENTITY_DOMAIN_ID IN (EC.ED_TRANSACTION, EC.ED_MARKET_PRICE) THEN
							IF v_TRUNC_DATE THEN
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING v_ENTITY_ID, TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, v_LOCAL_BEGIN_DATE-1, v_LOCAL_END_DATE+1, p_THE_DATE, p_THE_DATE, v_AS_OF_DATE;
							ELSIF v_SIMPLE_DATE THEN
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING v_ENTITY_ID, TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, v_BEGIN_DATE, v_AS_OF_DATE;
							ELSE
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING v_ENTITY_ID, TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, v_LOCAL_BEGIN_DATE-1, v_LOCAL_END_DATE+1, v_LOCAL_BEGIN_DATE, v_LOCAL_END_DATE, v_BEGIN_DATE, v_END_DATE, v_AS_OF_DATE;
							END IF;
						-- meter values that need a primary source need extra bind variable for join to TX_SUB_STATION_METER_PT_SOURCE
						ELSIF v_NEED_PRI_SOURCE THEN
							IF v_TRUNC_DATE THEN
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING v_ENTITY_ID, TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, v_LOCAL_BEGIN_DATE-1, v_LOCAL_END_DATE+1, p_THE_DATE, p_THE_DATE;
							ELSIF v_SIMPLE_DATE THEN
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING v_ENTITY_ID, TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, v_BEGIN_DATE;
							ELSE
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING v_ENTITY_ID, TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, v_LOCAL_BEGIN_DATE-1, v_LOCAL_END_DATE+1, v_LOCAL_BEGIN_DATE, v_LOCAL_END_DATE, v_BEGIN_DATE, v_END_DATE;
							END IF;
						ELSE
							IF v_TRUNC_DATE THEN
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING v_ENTITY_ID, TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, v_LOCAL_BEGIN_DATE-1, v_LOCAL_END_DATE+1, p_THE_DATE, p_THE_DATE;
							ELSIF v_SIMPLE_DATE THEN
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING v_ENTITY_ID, TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, v_BEGIN_DATE;
							ELSE
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING v_ENTITY_ID, TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, v_LOCAL_BEGIN_DATE-1, v_LOCAL_END_DATE+1, v_LOCAL_BEGIN_DATE, v_LOCAL_END_DATE, v_BEGIN_DATE, v_END_DATE;
							END IF;
						END IF;
					ELSE
						-- Traits have additional bind variables for the group ID and trait index
						IF v_IS_TRAIT THEN
							IF v_TRUNC_DATE THEN
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING v_ENTITY_ID, v_TG_ID, v_T_IDX, v_LOCAL_BEGIN_DATE-1, v_LOCAL_END_DATE+1, p_THE_DATE, p_THE_DATE;
							ELSIF v_SIMPLE_DATE THEN
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING v_ENTITY_ID, v_TG_ID, v_T_IDX, v_BEGIN_DATE;
							ELSE
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING v_ENTITY_ID, v_TG_ID, v_T_IDX, v_LOCAL_BEGIN_DATE-1, v_LOCAL_END_DATE+1, v_LOCAL_BEGIN_DATE, v_LOCAL_END_DATE, v_BEGIN_DATE, v_END_DATE;
							END IF;
						-- schedules and prices have an AS_OF_DATE
						ELSIF p_INPUTS(v_INDEX).ENTITY_DOMAIN_ID IN (EC.ED_TRANSACTION, EC.ED_MARKET_PRICE) THEN
							IF v_TRUNC_DATE THEN
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING v_ENTITY_ID, v_LOCAL_BEGIN_DATE-1, v_LOCAL_END_DATE+1, p_THE_DATE, p_THE_DATE, v_AS_OF_DATE;
							ELSIF v_SIMPLE_DATE THEN
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING v_ENTITY_ID, v_BEGIN_DATE, v_AS_OF_DATE;
							ELSE
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING v_ENTITY_ID, v_LOCAL_BEGIN_DATE-1, v_LOCAL_END_DATE+1, v_LOCAL_BEGIN_DATE, v_LOCAL_END_DATE, v_BEGIN_DATE, v_END_DATE, v_AS_OF_DATE;
							END IF;
						-- meter values that need a primary source need extra bind variable for join to TX_SUB_STATION_METER_PT_SOURCE
						ELSIF v_NEED_PRI_SOURCE THEN
							IF v_TRUNC_DATE THEN
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING v_ENTITY_ID, TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, v_LOCAL_BEGIN_DATE-1, v_LOCAL_END_DATE+1, p_THE_DATE, p_THE_DATE;
							ELSIF v_SIMPLE_DATE THEN
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING v_ENTITY_ID, TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, v_BEGIN_DATE;
							ELSE
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING v_ENTITY_ID, TRUNC(v_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, v_LOCAL_BEGIN_DATE-1, v_LOCAL_END_DATE+1, v_LOCAL_BEGIN_DATE, v_LOCAL_END_DATE, v_BEGIN_DATE, v_END_DATE;
							END IF;
						ELSE
							IF v_TRUNC_DATE THEN
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING v_ENTITY_ID, v_LOCAL_BEGIN_DATE-1, v_LOCAL_END_DATE+1, p_THE_DATE, p_THE_DATE;
							ELSIF v_SIMPLE_DATE THEN
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING v_ENTITY_ID, v_BEGIN_DATE;
							ELSE
								EXECUTE IMMEDIATE v_SQL INTO v_VALUE USING v_ENTITY_ID, v_LOCAL_BEGIN_DATE-1, v_LOCAL_END_DATE+1, v_LOCAL_BEGIN_DATE, v_LOCAL_END_DATE, v_BEGIN_DATE, v_END_DATE;
							END IF;
						END IF;
					END IF;
				END IF;
            EXCEPTION
            	WHEN NO_DATA_FOUND THEN
                	IF g_CANCEL_ON_NULL_INPUT THEN
                        LOG_FAILURE_CONTEXT('Input: '''||p_INPUTS(v_INDEX).INPUT_NAME||''' -- No Data Found',
                                            p_THE_DATE,
                                            p_COMPONENT_ID,
                                            p_VARIABLE_CACHE);
						LOGS.POST_EVENT_DETAILS('Input Query', CONSTANTS.MIME_TYPE_TEXT, v_SQL);
						ERRS.LOG_AND_RAISE;
                    ELSE
    	            	v_VALUE := NULL;
    				END IF;
            	WHEN OTHERS THEN
                    LOG_FAILURE_CONTEXT('Input: '''||p_INPUTS(v_INDEX).INPUT_NAME||'''',
                                            p_THE_DATE,
                                            p_COMPONENT_ID,
                                            p_VARIABLE_CACHE);
					LOGS.POST_EVENT_DETAILS('Input Query', CONSTANTS.MIME_TYPE_TEXT, v_SQL);
					ERRS.LOG_AND_RAISE;
            END;

            IF v_VALUE IS NULL THEN
            	v_VALUE := 0;
                IF LOGS.IS_DEBUG_ENABLED THEN
                	LOGS.LOG_DEBUG('GET_FORMULA_INPUTS: Value for input '''||p_INPUTS(v_INDEX).INPUT_NAME||''' is null! Using zero.');
                END IF;
            END IF;
		END IF;
        IF LOGS.IS_DEBUG_ENABLED THEN
        	LOGS.LOG_DEBUG ('  INPUT '||p_INPUTS(v_INDEX).INPUT_NAME||' = '||v_VALUE);
        END IF;
		-- put values into tables
		IF UT.BOOLEAN_FROM_NUMBER(p_INPUTS(v_INDEX).PERSIST_VALUE) THEN
			p_VARIABLES.EXTEND;
			p_VARIABLES(p_VARIABLES.LAST).NAME := p_INPUTS(v_INDEX).INPUT_NAME;
			p_VARIABLES(p_VARIABLES.LAST).VALUE := v_VALUE;
		END IF;
		p_VARIABLE_CACHE(p_INPUTS(v_INDEX).INPUT_NAME) := '('||v_VALUE||')';
        -- increment loop counter
        v_INDEX := p_INPUTS.NEXT(v_INDEX);
    END LOOP;
END GET_FORMULA_INPUT_VALUES;
---------------------------------------------------------------------------------------------------
PROCEDURE EVALUATE_FORMULA
	(
    p_FORMULA			IN VARCHAR2,
	p_VARIABLE_CACHE	IN OUT NOCOPY UT.STRING_MAP,
	p_ITERATOR_DEPENDS	IN FML_UTIL.ITERATOR_DEPENDS,
	p_ITERATORS			OUT PLS_INTEGER,
	p_RESULT			OUT NUMBER,
	p_MULTI_RESULTS		OUT NUMBER_COLLECTION,
	p_IS_MULTICOLUMN	IN BOOLEAN := FALSE,
	p_IS_PLSQL			IN BOOLEAN := FALSE
    ) AS
v_FORMULA VARCHAR2(32767);
v_PLSQL PLS_INTEGER;
BEGIN
	IF LOGS.IS_DEBUG_ENABLED THEN
    	LOGS.LOG_DEBUG ('Formula = '||p_FORMULA);
    END IF;

	IF p_IS_PLSQL AND p_IS_MULTICOLUMN THEN
		v_PLSQL := FML_UTIL.c_PLSQL_MULTI;
	ELSIF p_IS_PLSQL THEN
		v_PLSQL := FML_UTIL.c_PLSQL_YES;
	ELSE
		v_PLSQL := FML_UTIL.c_PLSQL_NO;
	END IF;

	FML_UTIL.REBUILD_FORMULA(p_FORMULA, p_VARIABLE_CACHE, p_ITERATOR_DEPENDS, p_ITERATORS, v_FORMULA,
							 FALSE, TRUE, v_PLSQL, TRUE);

	IF LOGS.IS_DEBUG_ENABLED THEN
    	LOGS.LOG_DEBUG ('Formula After Processing = '||v_FORMULA);
    END IF;

	IF NOT p_IS_PLSQL THEN
		v_FORMULA := 'SELECT ('||v_FORMULA||') FROM DUAL';
	END IF;

	BEGIN
		IF p_IS_PLSQL THEN
			-- PL/SQL uses OUT parameters
			IF p_IS_MULTICOLUMN THEN
				EXECUTE IMMEDIATE v_FORMULA USING OUT p_MULTI_RESULTS;
			ELSE
				EXECUTE IMMEDIATE v_FORMULA USING OUT p_RESULT;
			END IF;
		ELSE
			-- but SQL uses "into" to get result
			IF p_IS_MULTICOLUMN THEN
				EXECUTE IMMEDIATE v_FORMULA INTO p_MULTI_RESULTS;
			ELSE
				EXECUTE IMMEDIATE v_FORMULA INTO p_RESULT;
			END IF;
		END IF;
	EXCEPTION
		WHEN MSGCODES.e_ERR_DATA_LOCKED THEN
			DATA_LOCK.HANDLE_DATA_LOCKED_EXCEPTION(g_DATA_LOCK_BEHAVIOR);
	END;

	IF LOGS.IS_DEBUG_ENABLED THEN
    	LOGS.LOG_DEBUG ('Formula Result = '||p_RESULT);
    END IF;

EXCEPTION
	WHEN OTHERS THEN
    	IF g_CANCEL_ON_FORMULA_ERROR THEN
			ERRS.LOG_AND_RAISE('Error occurred processing formula: '||p_FORMULA);
        ELSE
           	LOGS.LOG_WARN('EVALUATE_FORMULA: Error occurred processing formula: '||p_FORMULA, p_SQLERRM => SQLERRM);
			IF p_IS_MULTICOLUMN THEN
				p_MULTI_RESULTS := NUMBER_COLLECTION(0);
			ELSE
				p_RESULT := 0;
			END IF;
		END IF;
END EVALUATE_FORMULA;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_FORMULA_INTERMEDIATE_VALS
	(
    p_COMPONENT_ID IN NUMBER,
	p_CHARGE_ID IN NUMBER,
	p_ITERATOR_ID IN NUMBER,
	p_THE_DATE IN DATE,
	p_DATE_OUTERMOST_LOOP IN BOOLEAN,
    p_INTERMEDIATES IN INTERMEDIATE_TABLE,
    p_VARIABLES IN OUT NOCOPY VARIABLE_TABLE,
	p_VARIABLE_CACHE IN OUT NOCOPY UT.STRING_MAP,
	p_CHANGED_ITERATORS IN PLS_INTEGER,
	p_ITERATOR_DEPENDS IN OUT NOCOPY FML_UTIL.ITERATOR_DEPENDS
    ) AS
v_VALUE			NUMBER;
v_MULTI_VALUES	NUMBER_COLLECTION;
v_VAR_NAMES		GA.STRING_TABLE;
v_EVALUATE_IT	BOOLEAN;
v_INDEX			PLS_INTEGER;
v_JDX			PLS_INTEGER;
v_KDX			PLS_INTEGER;
v_ITERATORS		PLS_INTEGER;
BEGIN
    v_INDEX := p_INTERMEDIATES.FIRST;
    WHILE p_INTERMEDIATES.EXISTS(v_INDEX) LOOP
        BEGIN
            v_EVALUATE_IT := TRUE;

            -- parse variable name(s)
            IF NVL(p_INTERMEDIATES(v_INDEX).IS_MULTICOLUMN,0) = 1 THEN
                UT.TOKENS_FROM_STRING(p_INTERMEDIATES(v_INDEX).VARIABLE_NAME, ',', v_VAR_NAMES);
            ELSE
                v_VAR_NAMES.DELETE;
                v_VAR_NAMES(1) := p_INTERMEDIATES(v_INDEX).VARIABLE_NAME;
            END IF;

            -- can't re-use if values weren't persisted - but if date is outer-most loop, then we
            -- can re-use by just getting the value out of the variable cache
            IF (p_INTERMEDIATES(v_INDEX).PERSIST_VALUE = 1 OR p_DATE_OUTERMOST_LOOP) AND
               NOT FML_UTIL.DEPENDS_CHANGED(p_ITERATOR_ID,p_CHANGED_ITERATORS, p_ITERATOR_DEPENDS, p_INTERMEDIATES(v_INDEX).VARIABLE_NAME)
               THEN

                -- get all values defined by this intermediate variable record
                v_MULTI_VALUES := NUMBER_COLLECTION();
                v_JDX := v_VAR_NAMES.FIRST;
                WHILE v_VAR_NAMES.EXISTS(v_JDX) LOOP
                    IF NOT p_DATE_OUTERMOST_LOOP THEN
                        -- date is inner loop? then get value for this date from previous iterator ID
                        v_VALUE := GET_VARIABLE_VALUE(p_CHARGE_ID, p_THE_DATE, v_VAR_NAMES(v_JDX), p_ITERATOR_ID-1);
                    ELSE
                        -- date is outer loop? just re-use value in collection
                        v_VALUE := REUSE_VALUE(v_VAR_NAMES(v_JDX), p_VARIABLE_CACHE);
                    END IF;
                    IF v_VALUE IS NULL THEN
                        -- couldn't find the value? then we must re-evaluate
                        v_EVALUATE_IT := TRUE;
                        EXIT;
                    ELSE
                        v_MULTI_VALUES.EXTEND;
                        v_MULTI_VALUES(v_MULTI_VALUES.LAST) := v_VALUE;
                    END IF;
                    v_JDX := v_VAR_NAMES.NEXT(v_JDX);
                END LOOP;

            END IF;
            -- if dependants changed, or prior value couldn't be found, evaluate it
            IF v_EVALUATE_IT THEN
                EVALUATE_FORMULA(p_INTERMEDIATES(v_INDEX).FORMULA, p_VARIABLE_CACHE, p_ITERATOR_DEPENDS,
                                 v_ITERATORS, v_VALUE, v_MULTI_VALUES,
                                 NVL(p_INTERMEDIATES(v_INDEX).IS_MULTICOLUMN,0) = 1,
                                 NVL(p_INTERMEDIATES(v_INDEX).IS_PLSQL,0) = 1);

                IF NVL(p_INTERMEDIATES(v_INDEX).IS_MULTICOLUMN,0) <> 1 THEN
                    v_MULTI_VALUES := NUMBER_COLLECTION(v_VALUE);
                END IF;

                -- Incorrect number of values?
                ASSERT(v_VAR_NAMES.COUNT = v_MULTI_VALUES.COUNT,
                       'Expecting '||v_VAR_NAMES.COUNT||' values for ['||p_INTERMEDIATES(v_INDEX).VARIABLE_NAME||'] but received '||v_MULTI_VALUES.COUNT);
            END IF;

            -- set all variables
            v_JDX := v_VAR_NAMES.FIRST;
            v_KDX := V_MULTI_VALUES.FIRST;
            WHILE v_VAR_NAMES.EXISTS(v_JDX) LOOP
                IF LOGS.IS_DEBUG_ENABLED THEN
                    LOGS.LOG_DEBUG('  INTERMEDIATE '||v_VAR_NAMES(v_JDX)||' = '||v_MULTI_VALUES(v_KDX));
                END IF;

                -- put values into tables
                IF UT.BOOLEAN_FROM_NUMBER(p_INTERMEDIATES(v_INDEX).PERSIST_VALUE) THEN
                    p_VARIABLES.EXTEND;
                    p_VARIABLES(p_VARIABLES.LAST).NAME := v_VAR_NAMES(v_JDX);
                    p_VARIABLES(p_VARIABLES.LAST).VALUE := v_MULTI_VALUES(v_KDX);
                    p_ITERATOR_DEPENDS(v_VAR_NAMES(v_JDX)) := FML_UTIL.COMBINE_DEPENDS(v_ITERATORS, c_SPECIAL_BIT);
                                                                    -- keep dependancy map up-to-date and flag
                                                                    -- intermediates with "special" bit indicating
                                                                    -- dependency on input or intermediate
                END IF;
                p_VARIABLE_CACHE(v_VAR_NAMES(v_JDX)) := UT.GET_LITERAL_FOR_NUMBER(v_MULTI_VALUES(v_KDX));

                v_JDX := v_VAR_NAMES.NEXT(v_JDX);
                v_KDX := v_MULTI_VALUES.NEXT(v_KDX);
            END LOOP;
        EXCEPTION
        WHEN OTHERS THEN
            LOG_FAILURE_CONTEXT('Intermediate Variable: ''' || p_INTERMEDIATES(v_INDEX).VARIABLE_NAME || '''',
                                p_THE_DATE,
                                p_COMPONENT_ID,
                                p_VARIABLE_CACHE);
            ERRS.LOG_AND_RAISE;
        END;
        v_INDEX := p_INTERMEDIATES.NEXT(v_INDEX);
    END LOOP;

END GET_FORMULA_INTERMEDIATE_VALS;
---------------------------------------------------------------------------------------------------
FUNCTION GET_RESULT_DISPLAY_NAME
    (
    p_RESULT IN COMPONENT_FORMULA_RESULT%ROWTYPE
    ) RETURN VARCHAR2 IS
    v_RTN VARCHAR2(2000);
BEGIN
    v_RTN := 'Result: Entity Domain: ' || TEXT_UTIL.TO_CHAR_ENTITY(p_RESULT.ENTITY_DOMAIN_ID, EC.ED_ENTITY_DOMAIN);
    
    IF p_RESULT.ENTITY_TYPE = 'R' THEN
        v_RTN := v_RTN || ' ' || TEXT_UTIL.TO_CHAR_ENTITY(p_RESULT.ENTITY_ID,EC.ED_SYSTEM_REALM,TRUE);
    ELSIF p_RESULT.ENTITY_TYPE = 'G' THEN
        v_RTN := v_RTN || ' ' || TEXT_UTIL.TO_CHAR_ENTITY(p_RESULT.ENTITY_ID,EC.ED_ENTITY_GROUP,TRUE);
    ELSE
        v_RTN := v_RTN || ' ' || TEXT_UTIL.TO_CHAR_ENTITY(p_RESULT.ENTITY_ID,p_RESULT.ENTITY_DOMAIN_ID);
    END IF;
    
    v_RTN := v_RTN || ' Field: ' || p_RESULT.WHAT_FIELD;
    
    RETURN v_RTN;
END GET_RESULT_DISPLAY_NAME;
---------------------------------------------------------------------------------------------------
FUNCTION GET_RESULT_NAME
	(
	p_RESULT IN COMPONENT_FORMULA_RESULT%ROWTYPE
	) RETURN VARCHAR2 IS
BEGIN
	-- create a name that will be unique - must include all unique fields of the
	-- result definition
	RETURN '%RET:'||p_RESULT.ENTITY_DOMAIN_ID||':'||p_RESULT.ENTITY_TYPE||':'||
					p_RESULT.ENTITY_ID||':'||TO_CHAR(p_RESULT.BEGIN_DATE,'YYYYDDD')||':'||
					p_RESULT.WHAT_FIELD||'%';
END GET_RESULT_NAME;
---------------------------------------------------------------------------------------------------
PROCEDURE CALC_FORMULA_RESULT_VALS
	(
    p_COMPONENT_ID IN NUMBER,
	p_IS_BILL IN BOOLEAN,
	p_ITERATOR_ID IN NUMBER,
    p_QUANTITY_FML IN VARCHAR2,
    p_RATE_FML IN VARCHAR2,
	p_RESULTS IN RESULT_TABLE,
	p_ITERATOR_VALS IN ITERATOR_VALS,
	p_VARIABLE_CACHE IN OUT NOCOPY UT.STRING_MAP,
	p_CHANGED_ITERATORS IN PLS_INTEGER,
	p_ITERATOR_DEPENDS IN OUT NOCOPY FML_UTIL.ITERATOR_DEPENDS,
	p_FML_REALMS IN OUT NOCOPY ID_FLAG_MAP,
	p_FML_REALM_WORK_IDs IN OUT NOCOPY BIGKEY_ID_MAP,
    p_CHARGE_INTERVAL IN VARCHAR2,
	p_DATE IN DATE,
	p_LOCAL_BEGIN_DATE IN DATE,
    p_CHARGE_QUANTITY OUT NUMBER,
    p_CHARGE_RATE OUT NUMBER
	) AS
v_VALUE			NUMBER;
v_MULTI_VALUES	NUMBER_COLLECTION;
v_ITERATORS		PLS_INTEGER;
v_INDEX			PLS_INTEGER;
v_JDX			PLS_INTEGER;
v_RESULT_NAME	VARCHAR2(64);
v_ENTITY_ID		NUMBER(9);
v_IS_FML_CHARGE_REALM BOOLEAN;
v_ENTITY_INTERVAL VARCHAR2(32);
v_IS_TRAIT BOOLEAN;
v_TG_ID TRANSACTION_TRAIT.TRAIT_GROUP_ID%TYPE;
v_T_IDX TRANSACTION_TRAIT.TRAIT_INDEX%TYPE;
v_USE_SCHEDULE_TYPE TRANSACTION_TRAIT_GROUP.IS_STATEMENT_TYPE_SPECIFIC%TYPE;
v_IS_SPARSE		TRANSACTION_TRAIT_GROUP.IS_SPARSE%TYPE;
v_DATE			DATE;
v_AS_OF_DATE	DATE;
v_COLUMN_NAME 	VARCHAR2(40);
v_DATE_COL_NAME VARCHAR2(100);
v_ID_JOIN_COL_NAME vARCHAR2(40);
v_TABLE_NAME	VARCHAR2(32);
v_QUERY_PORTION	VARCHAR2(32767);
v_SRC_QUERY		VARCHAR2(4000);
v_NEED_PRI_SOURCE BOOLEAN;
v_OTHER_COLS	STRING_COLLECTION := STRING_COLLECTION();
v_OTHER_VALS	STRING_COLLECTION := STRING_COLLECTION();
BEGIN
	IF p_IS_BILL THEN
		-- finally, compute the charge quantity and rate
        BEGIN
		    EVALUATE_FORMULA(p_QUANTITY_FML, p_VARIABLE_CACHE, p_ITERATOR_DEPENDS, v_ITERATORS, p_CHARGE_QUANTITY, v_MULTI_VALUES);
        EXCEPTION
        WHEN OTHERS THEN
            LOG_FAILURE_CONTEXT('Quantity Formula: ''' || p_QUANTITY_FML || '''',
                p_DATE,
                p_COMPONENT_ID,
                p_VARIABLE_CACHE);
            ERRS.LOG_AND_RAISE;
        END;

        BEGIN
		    EVALUATE_FORMULA(p_RATE_FML, p_VARIABLE_CACHE, p_ITERATOR_DEPENDS, v_ITERATORS, p_CHARGE_RATE, v_MULTI_VALUES);
        EXCEPTION
        WHEN OTHERS THEN
            LOG_FAILURE_CONTEXT('Rate Formula: ''' || p_RATE_FML || '''',
                p_DATE,
                p_COMPONENT_ID,
                p_VARIABLE_CACHE);
            ERRS.LOG_AND_RAISE;
        END;
	ELSE
		-- calculate formula results
		v_INDEX := p_RESULTS.FIRST;
		WHILE p_RESULTS.EXISTS(v_INDEX) LOOP
			v_RESULT_NAME := GET_RESULT_NAME(p_RESULTS(v_INDEX));
            BEGIN
    			-- only re-evaluate this result if necessary (based on its iterator dependencies)
                IF FML_UTIL.DEPENDS_CHANGED(p_ITERATOR_ID, p_CHANGED_ITERATORS, p_ITERATOR_DEPENDS, v_RESULT_NAME) THEN

                    -- first, get the value
                    EVALUATE_FORMULA(p_RESULTS(v_INDEX).FORMULA, p_VARIABLE_CACHE, p_ITERATOR_DEPENDS, v_ITERATORS, v_VALUE, v_MULTI_VALUES);

                    -- now record the value to the defined output

                    v_ENTITY_ID := p_RESULTS(v_INDEX).ENTITY_ID;
                    -- realm? then see if it's a formula charge realm and if so cache all IDs
                    -- if necessary
                    IF p_RESULTS(v_INDEX).ENTITY_TYPE = 'R' THEN

                        PROCESS_REALM(v_ENTITY_ID, p_ITERATOR_VALS,	v_RESULT_NAME, v_ITERATORS,
                                    p_VARIABLE_CACHE, p_ITERATOR_DEPENDS,
                                    p_FML_REALMS, p_FML_REALM_WORK_IDs,
                                    v_ENTITY_ID, v_IS_FML_CHARGE_REALM);

                        -- now find the one entity for this realm
                        BEGIN
                            IF v_IS_FML_CHARGE_REALM THEN
                                -- grab the entity ID from the work table
                                SELECT WORK_XID INTO v_ENTITY_ID
                                FROM RTO_WORK
                                WHERE WORK_ID = v_ENTITY_ID;
                            ELSE
                                SELECT ENTITY_ID INTO v_ENTITY_ID
                                FROM SYSTEM_REALM_ENTITY
                                WHERE REALM_ID = v_ENTITY_ID;
                            END IF;
                        EXCEPTION
                            WHEN NO_DATA_FOUND THEN
                                IF g_CANCEL_ON_MISSING_OUTPUT THEN
                                    ERRS.LOG_AND_RAISE('Could not determine output entity for realm '||TEXT_UTIL.TO_CHAR_ENTITY(p_RESULTS(v_INDEX).ENTITY_ID, EC.ED_SYSTEM_REALM));
                                ELSE
                                    -- set to NULL to continue to next result definition
                                    v_ENTITY_ID := NULL;
                                END IF;
                            WHEN TOO_MANY_ROWS THEN
                                IF g_CANCEL_ON_TOO_MANY_OUTPUTS THEN
                                    ERRS.LOG_AND_RAISE('Found more than one output entity for realm '||TEXT_UTIL.TO_CHAR_ENTITY(p_RESULTS(v_INDEX).ENTITY_ID, EC.ED_SYSTEM_REALM));
                                ELSE
                                -- set to NULL to continue to next result definition
                                    v_ENTITY_ID := NULL;
                                END IF;
                        END;
                    END IF;

                    IF p_RESULTS(v_INDEX).ENTITY_DOMAIN_ID = EC.ED_TRANSACTION THEN
                        SELECT MAX(TRANSACTION_INTERVAL)
                        INTO v_ENTITY_INTERVAL
                        FROM INTERCHANGE_TRANSACTION
                        WHERE TRANSACTION_ID = v_ENTITY_ID;
                    ELSIF p_RESULTS(v_INDEX).ENTITY_DOMAIN_ID = EC.ED_MARKET_PRICE THEN
                        SELECT MAX(MARKET_PRICE_INTERVAL)
                        INTO v_ENTITY_INTERVAL
                        FROM MARKET_PRICE
                        WHERE MARKET_PRICE_ID = v_ENTITY_ID;
                    ELSIF p_RESULTS(v_INDEX).ENTITY_DOMAIN_ID = EC.ED_SUB_STATION_METER THEN
                        -- sub-station meter data is always hourly
                        v_ENTITY_INTERVAL := 'Hour';
                    ELSIF p_RESULTS(v_INDEX).ENTITY_DOMAIN_ID = EC.ED_MEASUREMENT_SOURCE THEN
                        SELECT MAX(MEASUREMENT_SOURCE_INTERVAL)
                        INTO v_ENTITY_INTERVAL
                        FROM MEASUREMENT_SOURCE
                        WHERE MEASUREMENT_SOURCE_ID = v_ENTITY_ID;
                    ELSE
                        v_ENTITY_INTERVAL := NULL;
                    END IF;

                    IF NVL(UPPER(p_CHARGE_INTERVAL),'?') <> NVL(UPPER(v_ENTITY_INTERVAL),'?') THEN
                        IF g_CANCEL_ON_BAD_OUTPUTINTERVAL THEN
                            -- set to NULL to continue to next result definition
                            v_ENTITY_ID := NULL;
                        ELSE
                            ERRS.RAISE_BAD_ARGUMENT('Entity Interval',v_ENTITY_INTERVAL,'Entity Interval does not match Component Interval: '||p_CHARGE_INTERVAL);
                        END IF;
                    END IF;

                    IF v_ENTITY_ID IS NOT NULL THEN
                        v_DATE := p_DATE;
                        v_IS_TRAIT := FALSE;
                        v_NEED_PRI_SOURCE := FALSE;

                        -- build DML to put the value into the result table
                        v_COLUMN_NAME := p_RESULTS(v_INDEX).WHAT_FIELD;
                        v_OTHER_COLS.DELETE;
                        v_OTHER_VALS.DELETE;

                        -- TRANSACTIONS
                        IF p_RESULTS(v_INDEX).ENTITY_DOMAIN_ID = EC.ED_TRANSACTION THEN
                            v_SRC_QUERY := 'SELECT * FROM INTERCHANGE_TRANSACTION WHERE TRANSACTION_ID = :ID';

                            PARSE_FIELD_FOR_TRANSACTION(v_COLUMN_NAME, v_IS_TRAIT, v_TG_ID, v_T_IDX);
                            IF v_IS_TRAIT THEN
                                v_COLUMN_NAME := 'TRAIT_VAL';
                                -- get attributes of selected trait group
                                SELECT MAX(IS_STATEMENT_TYPE_SPECIFIC),
                                        MAX(IS_SPARSE)
                                INTO v_USE_SCHEDULE_TYPE, v_IS_SPARSE
                                FROM TRANSACTION_TRAIT_GROUP
                                WHERE TRAIT_GROUP_ID = v_TG_ID;
                                -- can't do sparse traits!
                                ASSERT(NVL(v_IS_SPARSE,0)=0, 'Cannot use sparse traits as results');
                            END IF;

                            v_DATE_COL_NAME := 'SCHEDULE_DATE';
                            v_ID_JOIN_COL_NAME := 'TRANSACTION_ID';

                            IF v_IS_TRAIT THEN
                                -- join trait tables and use trait's interval
                                v_TABLE_NAME := 'IT_TRAIT_SCHEDULE';

                                v_OTHER_COLS.EXTEND;
                                v_OTHER_COLS(v_OTHER_COLS.LAST) := 'SET_NUMBER';
                                REBUILD_QUERY_PORTION(p_RESULTS(v_INDEX).SET_NUMBER_FML, p_VARIABLE_CACHE,
                                                        p_ITERATOR_DEPENDS, v_ITERATORS, v_QUERY_PORTION);
                                v_OTHER_VALS.EXTEND;
                                v_OTHER_VALS(v_OTHER_VALS.LAST) := NVL(v_QUERY_PORTION,c_DEFAULT_SET_NUMBER);

                                v_OTHER_COLS.EXTEND;
                                v_OTHER_COLS(v_OTHER_COLS.LAST) := 'STATEMENT_TYPE_ID';
                                IF v_USE_SCHEDULE_TYPE = 1 THEN
                                    IF p_RESULTS(v_INDEX).STATEMENT_TYPE_FML IS NULL THEN
                                        -- make sure we have a statement type - error if we don't
                                        IF NOT p_VARIABLE_CACHE.EXISTS(c_DEFAULT_STATEMENT_TYPE) THEN
                                            ERRS.RAISE(MSGCODES.c_ERR_NO_STATEMENT_TYPE);
                                        END IF;
                                        v_QUERY_PORTION := p_VARIABLE_CACHE(c_DEFAULT_STATEMENT_TYPE);
                                    ELSE
                                        REBUILD_QUERY_PORTION(p_RESULTS(v_INDEX).STATEMENT_TYPE_FML,
                                                              p_VARIABLE_CACHE, p_ITERATOR_DEPENDS, v_ITERATORS, v_QUERY_PORTION);
                                    END IF;
                                ELSE
                                    v_QUERY_PORTION := 0;
                                END IF;
                                v_OTHER_VALS.EXTEND;
                                v_OTHER_VALS(v_OTHER_VALS.LAST) := v_QUERY_PORTION;

                                v_OTHER_COLS.EXTEND;
                                v_OTHER_COLS(v_OTHER_COLS.LAST) := 'SCHEDULE_STATE';
                                REBUILD_QUERY_PORTION(p_RESULTS(v_INDEX).STATE_FML, p_VARIABLE_CACHE,
                                                        p_ITERATOR_DEPENDS, v_ITERATORS, v_QUERY_PORTION);
                                v_OTHER_VALS.EXTEND;
                                v_OTHER_VALS(v_OTHER_VALS.LAST) := NVL(v_QUERY_PORTION,c_DEFAULT_STATE);
                            ELSE
                                -- just use IT_SCHEDULE table
                                v_TABLE_NAME := 'IT_SCHEDULE';

                                v_OTHER_COLS.EXTEND;
                                v_OTHER_COLS(v_OTHER_COLS.LAST) := 'SCHEDULE_TYPE';
                                IF p_RESULTS(v_INDEX).STATEMENT_TYPE_FML IS NULL THEN
                                    -- make sure we have a statement type - error if we don't
                                    IF NOT p_VARIABLE_CACHE.EXISTS(c_DEFAULT_STATEMENT_TYPE) THEN
                                        ERRS.RAISE(MSGCODES.c_ERR_NO_STATEMENT_TYPE);
                                    END IF;
                                    v_QUERY_PORTION := p_VARIABLE_CACHE(c_DEFAULT_STATEMENT_TYPE);
                                ELSE
                                    REBUILD_QUERY_PORTION(p_RESULTS(v_INDEX).STATEMENT_TYPE_FML,
                                                          p_VARIABLE_CACHE, p_ITERATOR_DEPENDS, v_ITERATORS, v_QUERY_PORTION);
                                END IF;
                                v_OTHER_VALS.EXTEND;
                                v_OTHER_VALS(v_OTHER_VALS.LAST) := v_QUERY_PORTION;

                                v_OTHER_COLS.EXTEND;
                                v_OTHER_COLS(v_OTHER_COLS.LAST) := 'SCHEDULE_STATE';
                                REBUILD_QUERY_PORTION(p_RESULTS(v_INDEX).STATE_FML, p_VARIABLE_CACHE,
                                                        p_ITERATOR_DEPENDS, v_ITERATORS, v_QUERY_PORTION);
                                v_OTHER_VALS.EXTEND;
                                v_OTHER_VALS(v_OTHER_VALS.LAST) := NVL(v_QUERY_PORTION,c_DEFAULT_STATE);

                                IF GA.VERSION_SCHEDULE THEN
                                    v_AS_OF_DATE := SYSDATE;
                                ELSE
                                    v_AS_OF_DATE := CONSTANTS.LOW_DATE;
                                END IF;
                            END IF;

                        -- MARKET PRICES
                        ELSIF p_RESULTS(v_INDEX).ENTITY_DOMAIN_ID = EC.ED_MARKET_PRICE THEN
                            v_SRC_QUERY := 'SELECT * FROM MARKET_PRICE WHERE MARKET_PRICE_ID = :ID';

                            -- dates are not stored as second-past-midnight in MARKET_PRICE_VALUE so strip off any seconds from
                            -- join date
                            v_DATE := TRUNC(v_DATE,'MI');

                            v_TABLE_NAME := 'MARKET_PRICE_VALUE';
                            v_DATE_COL_NAME := 'PRICE_DATE';
                            v_ID_JOIN_COL_NAME := 'MARKET_PRICE_ID';

                            v_OTHER_COLS.EXTEND;
                            v_OTHER_COLS(v_OTHER_COLS.LAST) := 'PRICE_CODE';
                            REBUILD_QUERY_PORTION(p_RESULTS(v_INDEX).CODE_FML, p_VARIABLE_CACHE,
                                                    p_ITERATOR_DEPENDS, v_ITERATORS, v_QUERY_PORTION);
                            v_OTHER_VALS.EXTEND;
                            v_OTHER_VALS(v_OTHER_VALS.LAST) := NVL(v_QUERY_PORTION,c_DEFAULT_CODE);

                            IF GA.VERSION_MARKET_PRICE THEN
                                v_AS_OF_DATE := SYSDATE;
                            ELSE
                                v_AS_OF_DATE := CONSTANTS.LOW_DATE;
                            END IF;

                        -- SUB-STATION METER DATA POINTS
                        ELSIF p_RESULTS(v_INDEX).ENTITY_DOMAIN_ID = EC.ED_SUB_STATION_METER_POINT THEN
                            v_TABLE_NAME := 'TX_SUB_STATION_METER_PT_VALUE';
                            v_DATE_COL_NAME := 'METER_DATE';
                            v_ID_JOIN_COL_NAME := 'METER_POINT_ID';

                            v_OTHER_COLS.EXTEND;
                            v_OTHER_COLS(v_OTHER_COLS.LAST) := 'MEASUREMENT_SOURCE_ID';
                            v_OTHER_VALS.EXTEND;
                            IF NVL(p_RESULTS(v_INDEX).MEASUREMENT_SOURCE_FML,'?') = '?' THEN
                                -- if unspecified, use meter point's default source
                                v_NEED_PRI_SOURCE := TRUE;
                                v_SRC_QUERY := 'SELECT A.*, B.MEASUREMENT_SOURCE_ID as PRIMARY_MEASUREMENT_SOURCE_ID
                                                FROM TX_SUB_STATION_METER_POINT A, TX_SUB_STATION_METER_PT_SOURCE B
                                                WHERE A.METER_POINT_ID = :ID
                                                    AND B.METER_POINT_ID = A.METER_POINT_ID
                                                    AND B.IS_PRIMARY = 1
                                                    AND :D BETWEEN B.BEGIN_DATE AND NVL(B.END_DATE,:H)';
                                v_OTHER_VALS.EXTEND;
                                v_OTHER_VALS(v_OTHER_VALS.LAST) := c_DEFAULT_MEASUREMENT_SOURCE;
                            ELSE
                                v_SRC_QUERY := 'SELECT * FROM TX_SUB_STATION_METER_POINT WHERE METER_POINT_ID = :ID';

                                REBUILD_QUERY_PORTION(p_RESULTS(v_INDEX).MEASUREMENT_SOURCE_FML, p_VARIABLE_CACHE,
                                                    p_ITERATOR_DEPENDS, v_ITERATORS, v_QUERY_PORTION);
                                v_OTHER_VALS(v_OTHER_VALS.LAST) := v_QUERY_PORTION;
                            END IF;

                            v_OTHER_COLS.EXTEND;
                            v_OTHER_COLS(v_OTHER_COLS.LAST) := 'METER_CODE';
                            REBUILD_QUERY_PORTION(p_RESULTS(v_INDEX).CODE_FML, p_VARIABLE_CACHE,
                                                    p_ITERATOR_DEPENDS, v_ITERATORS, v_QUERY_PORTION);
                            v_OTHER_VALS.EXTEND;
                            v_OTHER_VALS(v_OTHER_VALS.LAST) := NVL(v_QUERY_PORTION,c_DEFAULT_CODE);

                            IF GA.VERSION_MARKET_PRICE THEN
                                v_AS_OF_DATE := SYSDATE;
                            ELSE
                                v_AS_OF_DATE := CONSTANTS.LOW_DATE;
                            END IF;

                        -- MEASUREMENT SOURCES
                        ELSIF p_RESULTS(v_INDEX).ENTITY_DOMAIN_ID = EC.ED_MEASUREMENT_SOURCE THEN
                            v_SRC_QUERY := 'SELECT * FROM MEASUREMENT_SOURCE WHERE MEASUREMENT_SOURCE_ID = :ID';

                            v_TABLE_NAME := 'MEASUREMENT_SOURCE_VALUE';
                            v_DATE_COL_NAME := 'SOURCE_DATE';
                            v_ID_JOIN_COL_NAME := 'MEASUREMENT_SOURCE_ID';

                        ELSE
                            v_SRC_QUERY := NULL;
                            v_TABLE_NAME := NULL;
                            v_COLUMN_NAME := NULL;
                            v_DATE_COL_NAME := NULL;
                            v_ID_JOIN_COL_NAME := NULL;
                        END IF;

                        -- update dependency map now that we have all dependencies from query portions
                        p_ITERATOR_DEPENDS(v_RESULT_NAME) := v_ITERATORS;

                        -- build single DML - a merge statement that will upsert the value
                        v_QUERY_PORTION := 'MERGE INTO '||v_TABLE_NAME||' TBL USING ('||v_SRC_QUERY||') SRC';
                        -- join conditions that find the row to update:
                        v_QUERY_PORTION := v_QUERY_PORTION||' ON (TBL.'||v_ID_JOIN_COL_NAME||' = SRC.'||v_ID_JOIN_COL_NAME;
                        v_QUERY_PORTION := v_QUERY_PORTION||' AND TBL.'||v_DATE_COL_NAME||' = :2';
                        IF v_IS_TRAIT THEN
                            v_QUERY_PORTION := v_QUERY_PORTION||' AND TBL.TRAIT_GROUP_ID = :3A';
                            v_QUERY_PORTION := v_QUERY_PORTION||' AND TBL.TRAIT_INDEX = :3B';
                        ELSIF p_RESULTS(v_INDEX).ENTITY_DOMAIN_ID IN (EC.ED_TRANSACTION, EC.ED_MARKET_PRICE) THEN
                            v_QUERY_PORTION := v_QUERY_PORTION||' AND TBL.AS_OF_DATE = :3';
                        END IF;
                        -- enumerate other field values
                        v_JDX := v_OTHER_COLS.FIRST;
                        WHILE v_OTHER_COLS.EXISTS(v_JDX) LOOP
                            v_QUERY_PORTION := v_QUERY_PORTION||' AND TBL.'||v_OTHER_COLS(v_JDX)||' = '||v_OTHER_VALS(v_JDX);
                            v_JDX := v_OTHER_COLS.NEXT(v_JDX);
                        END LOOP;
                        v_QUERY_PORTION := v_QUERY_PORTION||')';
                        -- update portion
                        v_QUERY_PORTION := v_QUERY_PORTION||' WHEN MATCHED THEN UPDATE SET TBL.'||v_COLUMN_NAME||' = :4';
                        -- insert portion
                        v_QUERY_PORTION := v_QUERY_PORTION||' WHEN NOT MATCHED THEN INSERT (TBL.'||v_ID_JOIN_COL_NAME||', TBL.'||v_DATE_COL_NAME;
                        IF v_IS_TRAIT THEN
                            v_QUERY_PORTION := v_QUERY_PORTION||', TBL.TRAIT_GROUP_ID, TBL.TRAIT_INDEX';
                        ELSIF p_RESULTS(v_INDEX).ENTITY_DOMAIN_ID IN (EC.ED_TRANSACTION, EC.ED_MARKET_PRICE) THEN
                            v_QUERY_PORTION := v_QUERY_PORTION||', TBL.AS_OF_DATE';
                        END IF;
                        v_QUERY_PORTION := v_QUERY_PORTION||', TBL.'||v_COLUMN_NAME;
                        -- first, enumerate column names for insert
                        v_JDX := v_OTHER_COLS.FIRST;
                        WHILE v_OTHER_COLS.EXISTS(v_JDX) LOOP
                            v_QUERY_PORTION := v_QUERY_PORTION||', '||v_OTHER_COLS(v_JDX);
                            v_JDX := v_OTHER_COLS.NEXT(v_JDX);
                        END LOOP;
                        v_QUERY_PORTION := v_QUERY_PORTION||') VALUES (:1, :2, :3';
                        IF v_IS_TRAIT THEN
                            -- trait group ID and trait index
                            v_QUERY_PORTION := v_QUERY_PORTION||', :3B';
                            v_QUERY_PORTION := v_QUERY_PORTION||', :4';
                        ELSIF p_RESULTS(v_INDEX).ENTITY_DOMAIN_ID IN (EC.ED_TRANSACTION, EC.ED_MARKET_PRICE) THEN
                            -- as of date
                            v_QUERY_PORTION := v_QUERY_PORTION||', :4';
                        END IF;
                        -- second, enumerate values for insert
                        v_JDX := v_OTHER_VALS.FIRST;
                        WHILE v_OTHER_VALS.EXISTS(v_JDX) LOOP
                            v_QUERY_PORTION := v_QUERY_PORTION||', '||v_OTHER_VALS(v_JDX);
                            v_JDX := v_OTHER_VALS.NEXT(v_JDX);
                        END LOOP;
                        v_QUERY_PORTION := v_QUERY_PORTION||')';

                        IF LOGS.IS_DEBUG_ENABLED THEN
                            LOGS.LOG_DEBUG('Result DML below for Entity Id=' || v_ENTITY_ID);
                            LOGS.LOG_DEBUG(v_QUERY_PORTION);
                        END IF;

                        -- Now, execute the upsert!
                        BEGIN
                            IF v_IS_TRAIT THEN
                                EXECUTE IMMEDIATE v_QUERY_PORTION
                                    USING v_ENTITY_ID, v_DATE, v_TG_ID, v_T_IDX, v_VALUE, v_ENTITY_ID, v_DATE, v_TG_ID, v_T_IDX, v_VALUE;
                            ELSIF p_RESULTS(v_INDEX).ENTITY_DOMAIN_ID IN (EC.ED_TRANSACTION, EC.ED_MARKET_PRICE) THEN
                                EXECUTE IMMEDIATE v_QUERY_PORTION
                                    USING v_ENTITY_ID, v_DATE, v_AS_OF_DATE, v_VALUE, v_ENTITY_ID, v_DATE, v_AS_OF_DATE, v_VALUE;
                            ELSIF v_NEED_PRI_SOURCE THEN
                                EXECUTE IMMEDIATE v_QUERY_PORTION
                                    USING v_ENTITY_ID, TRUNC(p_LOCAL_BEGIN_DATE), CONSTANTS.HIGH_DATE, v_DATE, v_VALUE, v_ENTITY_ID, v_DATE, v_VALUE;
                            ELSE
                                EXECUTE IMMEDIATE v_QUERY_PORTION
                                    USING v_ENTITY_ID, v_DATE, v_VALUE, v_ENTITY_ID, v_DATE, v_VALUE;
                            END IF;
                        EXCEPTION
                            WHEN MSGCODES.e_ERR_DATA_LOCKED THEN
                                DATA_LOCK.HANDLE_DATA_LOCKED_EXCEPTION(g_DATA_LOCK_BEHAVIOR);
                        END;


                    END IF;

                END IF;

            EXCEPTION
            WHEN OTHERS THEN
                LOG_FAILURE_CONTEXT(GET_RESULT_DISPLAY_NAME(p_RESULTS(v_INDEX)) || UTL_TCP.CRLF
                    || 'Formula: ''' || p_RESULTS(v_INDEX).FORMULA || '''',
                    p_DATE,
                    p_COMPONENT_ID,
                    p_VARIABLE_CACHE);
                ERRS.LOG_AND_RAISE;
            END;

			v_INDEX := p_RESULTS.NEXT(v_INDEX);
		END LOOP;
	END IF;
END CALC_FORMULA_RESULT_VALS;
---------------------------------------------------------------------------------------------------
PROCEDURE EVALUATE_FORMULAS
	(
    p_CHARGE_ID IN NUMBER,
	p_PRIOR_CHARGE_ID IN NUMBER,
	p_IS_BILL IN BOOLEAN,
    p_COMPONENT_ID IN NUMBER,
	p_COMPONENT_FACTOR IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_LOCAL_BEGIN_DATE IN DATE,
    p_LOCAL_END_DATE IN DATE,
	p_DATE IN DATE,
	p_DATE2 IN DATE,
	p_WEEK_BEGIN IN VARCHAR2,
    p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
    p_CHARGE_INTERVAL IN VARCHAR2,
	p_DATE_OUTERMOST_LOOP IN BOOLEAN,
    p_INPUTS IN INPUT_TABLE,
    p_INTERMEDIATES IN INTERMEDIATE_TABLE,
	p_RESULTS IN RESULT_TABLE,
    p_QUANTITY_FML IN VARCHAR2,
    p_RATE_FML IN VARCHAR2,
	p_ITERATOR_VALS IN ITERATOR_VALS,
	p_ITERATOR_ID IN NUMBER,
	p_VARIABLE_CACHE IN OUT NOCOPY UT.STRING_MAP,
	p_CHANGED_ITERATORS IN VARCHAR2,
	p_ITERATOR_DEPENDS IN OUT NOCOPY FML_UTIL.ITERATOR_DEPENDS,
	p_FML_REALMS IN OUT NOCOPY ID_FLAG_MAP,
	p_FML_REALM_WORK_IDs IN OUT NOCOPY BIGKEY_ID_MAP
    ) AS
v_VARIABLES VARIABLE_TABLE := VARIABLE_TABLE();
v_CHARGE_QUANTITY NUMBER;
v_CHARGE_RATE NUMBER;
v_FORMULA_CHARGE FORMULA_CHARGE%ROWTYPE;
v_FORMULA_CHARGE_VAR FORMULA_CHARGE_VARIABLE%ROWTYPE;
v_INDEX PLS_INTEGER;
BEGIN
    IF LOGS.IS_DEBUG_ENABLED THEN
    	LOGS.LOG_DEBUG('EVALUATE_FORMULAS');
    	LOGS.LOG_DEBUG('  BEGIN_DATE = '||TEXT_UTIL.TO_CHAR_TIME(p_BEGIN_DATE));
    	LOGS.LOG_DEBUG('  END_DATE = '||TEXT_UTIL.TO_CHAR_TIME(p_END_DATE));
    END IF;

    GET_FORMULA_INPUT_VALUES(p_COMPONENT_ID,p_CHARGE_ID, p_ITERATOR_ID, p_CHARGE_INTERVAL,
							p_BEGIN_DATE, p_END_DATE, p_LOCAL_BEGIN_DATE, p_LOCAL_END_DATE,
							p_DATE, p_WEEK_BEGIN, p_AS_OF_DATE, p_TIME_ZONE,
							p_DATE_OUTERMOST_LOOP, p_INPUTS,
							p_ITERATOR_VALS, v_VARIABLES, p_VARIABLE_CACHE,
							p_CHANGED_ITERATORS, p_ITERATOR_DEPENDS,
							p_FML_REALMS, p_FML_REALM_WORK_IDs);
    GET_FORMULA_INTERMEDIATE_VALS(p_COMPONENT_ID,p_CHARGE_ID, p_ITERATOR_ID, p_DATE, p_DATE_OUTERMOST_LOOP,
							p_INTERMEDIATES, v_VARIABLES, p_VARIABLE_CACHE,
							p_CHANGED_ITERATORS, p_ITERATOR_DEPENDS);
	CALC_FORMULA_RESULT_VALS(p_COMPONENT_ID,p_IS_BILL, p_ITERATOR_ID, p_QUANTITY_FML, p_RATE_FML, p_RESULTS,
							p_ITERATOR_VALS, p_VARIABLE_CACHE, p_CHANGED_ITERATORS,
							p_ITERATOR_DEPENDS,	p_FML_REALMS, p_FML_REALM_WORK_IDs,
							p_CHARGE_INTERVAL, p_DATE, p_LOCAL_BEGIN_DATE,
							v_CHARGE_QUANTITY, v_CHARGE_RATE);

    IF LOGS.IS_DEBUG_ENABLED THEN
    	LOGS.LOG_DEBUG('Formula Charge Quantity = '||v_CHARGE_QUANTITY);
    	LOGS.LOG_DEBUG('Formula Charge Rate = '||v_CHARGE_RATE);
    END IF;

	v_FORMULA_CHARGE.CHARGE_ID := p_CHARGE_ID;
	v_FORMULA_CHARGE.CHARGE_DATE := p_DATE;
	v_FORMULA_CHARGE.PERIOD_END_DATE := p_DATE2;
	v_FORMULA_CHARGE.ITERATOR_ID := p_ITERATOR_ID;
	IF p_IS_BILL THEN
		v_FORMULA_CHARGE.CHARGE_QUANTITY := v_CHARGE_QUANTITY;
		v_FORMULA_CHARGE.CHARGE_RATE := v_CHARGE_RATE;
		v_FORMULA_CHARGE.CHARGE_FACTOR := p_COMPONENT_FACTOR;
		v_FORMULA_CHARGE.CHARGE_AMOUNT := v_CHARGE_QUANTITY * v_CHARGE_RATE * v_FORMULA_CHARGE.CHARGE_FACTOR;
	END IF;
	PRIOR_FORMULA_CHARGE(p_PRIOR_CHARGE_ID, v_FORMULA_CHARGE);
    PUT_FORMULA_CHARGE (v_FORMULA_CHARGE);

	v_FORMULA_CHARGE_VAR.CHARGE_ID := p_CHARGE_ID;
	v_FORMULA_CHARGE_VAR.CHARGE_DATE := p_DATE;
	v_FORMULA_CHARGE_VAR.ITERATOR_ID := p_ITERATOR_ID;
    v_INDEX := v_VARIABLES.FIRST;
    WHILE v_VARIABLES.EXISTS(v_INDEX) LOOP
		v_FORMULA_CHARGE_VAR.VARIABLE_NAME := v_VARIABLES(v_INDEX).NAME;
		v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_VARIABLES(v_INDEX).VALUE;
		v_FORMULA_CHARGE_VAR.ROW_NUMBER := v_INDEX;
		PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
        v_INDEX := v_VARIABLES.NEXT(v_INDEX);
    END LOOP;
    v_VARIABLES.DELETE;

END EVALUATE_FORMULAS;
---------------------------------------------------------------------------------------------------
PROCEDURE GATHER_FORMULA_ITERATORS
	(
    p_COMPONENT_ID IN NUMBER,
    p_DATE IN DATE,
    p_ITERATORS IN OUT NOCOPY ITERATOR_TABLE,
	p_DO_INNER IN BOOLEAN
    ) AS
v_IS_INNER_LOOP NUMBER := CASE WHEN p_DO_INNER THEN 1 ELSE 0 END;
BEGIN
    SELECT * BULK COLLECT INTO p_ITERATORS
    FROM COMPONENT_FORMULA_ITERATOR
    WHERE COMPONENT_ID = p_COMPONENT_ID
    	AND SUB_COMPONENT_TYPE =  CONSTANTS.UNDEFINED_ATTRIBUTE
        AND SUB_COMPONENT_ID = CONSTANTS.NOT_ASSIGNED
		AND p_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE,CONSTANTS.HIGH_DATE)
		AND NVL(IS_INNER_LOOP,0) = v_IS_INNER_LOOP
	ORDER BY ROW_NUMBER, ITERATOR_NAME;
END GATHER_FORMULA_ITERATORS;
---------------------------------------------------------------------------------------------------
PROCEDURE GATHER_FORMULA_INPUTS
	(
    p_COMPONENT_ID IN NUMBER,
    p_DATE IN DATE,
    p_INPUTS IN OUT NOCOPY INPUT_TABLE
    ) AS
BEGIN
    SELECT * BULK COLLECT INTO p_INPUTS
    FROM COMPONENT_FORMULA_INPUT
    WHERE COMPONENT_ID = p_COMPONENT_ID
    	AND SUB_COMPONENT_TYPE =  CONSTANTS.UNDEFINED_ATTRIBUTE
        AND SUB_COMPONENT_ID = CONSTANTS.NOT_ASSIGNED
		AND p_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE,CONSTANTS.HIGH_DATE)
	ORDER BY ROW_NUMBER, INPUT_NAME;
END GATHER_FORMULA_INPUTS;
---------------------------------------------------------------------------------------------------
PROCEDURE GATHER_FORMULA_INTERMEDIATES
	(
    p_COMPONENT_ID IN NUMBER,
    p_DATE IN DATE,
    p_INTERMEDIATES IN OUT NOCOPY INTERMEDIATE_TABLE
    ) AS
BEGIN
    SELECT * BULK COLLECT INTO p_INTERMEDIATES
    FROM COMPONENT_FORMULA_VARIABLE
    WHERE COMPONENT_ID = p_COMPONENT_ID
    	AND SUB_COMPONENT_TYPE =  CONSTANTS.UNDEFINED_ATTRIBUTE
        AND SUB_COMPONENT_ID = CONSTANTS.NOT_ASSIGNED
		AND p_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE,CONSTANTS.HIGH_DATE)
        AND VARIABLE_NAME <> '#CHARGE QUANTITY#'
        AND VARIABLE_NAME <> '#CHARGE RATE#'
    ORDER BY ROW_NUMBER, VARIABLE_NAME;
END GATHER_FORMULA_INTERMEDIATES;
---------------------------------------------------------------------------------------------------
PROCEDURE GATHER_FORMULA_RESULTS
	(
    p_COMPONENT_ID IN NUMBER,
    p_DATE IN DATE,
    p_RESULTS IN OUT NOCOPY RESULT_TABLE
    ) AS
BEGIN
    SELECT * BULK COLLECT INTO p_RESULTS
    FROM COMPONENT_FORMULA_RESULT
    WHERE COMPONENT_ID = p_COMPONENT_ID
    	AND SUB_COMPONENT_TYPE =  CONSTANTS.UNDEFINED_ATTRIBUTE
        AND SUB_COMPONENT_ID = CONSTANTS.NOT_ASSIGNED
		AND p_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE,CONSTANTS.HIGH_DATE);
END GATHER_FORMULA_RESULTS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_COMPONENT_FACTOR
	(
    p_COMPONENT_ID IN NUMBER,
    p_DATE IN DATE,
	p_FACTOR OUT NUMBER,
	p_END_DATE OUT DATE
    ) AS
BEGIN
	SELECT PERCENT_VAL / 100.0, END_DATE
	INTO p_FACTOR, p_END_DATE
	FROM COMPONENT_PERCENTAGE
	WHERE COMPONENT_ID = p_COMPONENT_ID
        AND p_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE, CONSTANTS.HIGH_DATE)
		AND ROWNUM = 1;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
		p_FACTOR := 1.0;
		p_END_DATE := NULL;
END GET_COMPONENT_FACTOR;
---------------------------------------------------------------------------------------------------
-- forward declaration required by circular recursion
PROCEDURE FORMULA_ITERATOR_LOOP
	(
    p_CHARGE_ID IN NUMBER,
	p_PRIOR_CHARGE_ID IN NUMBER,
    p_COMPONENT_ID IN NUMBER,
	p_IS_BILL IN BOOLEAN,
	p_COMPONENT_FACTOR IN NUMBER,
    p_BEGIN_DATE IN OUT DATE,
    p_END_DATE IN DATE,
    p_LOCAL_BEGIN_DATE IN OUT DATE,
    p_LOCAL_END_DATE IN DATE,
	p_DATE IN DATE,
	p_DATE2 IN DATE,
	p_WEEK_BEGIN IN VARCHAR2,
    p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
    p_INTERVAL_ENDING IN BOOLEAN,
    p_CHARGE_INTERVAL IN VARCHAR2,
    p_TRUNC_INTERVAL IN VARCHAR2,
    p_INPUTS IN INPUT_TABLE,
    p_INTERMEDIATES IN INTERMEDIATE_TABLE,
    p_RESULTS IN RESULT_TABLE,
    p_QUANTITY_FML IN VARCHAR2,
    p_RATE_FML IN VARCHAR2,
	p_ITERATORS IN ITERATOR_TABLE,
	p_ITERATOR_INDEX IN NUMBER,
	p_DO_INNER IN BOOLEAN,
	p_ITERATOR_NAMES IN OUT NOCOPY ITERATOR_VALS,
	p_ITERATOR_VALS IN OUT NOCOPY ITERATOR_VALS,
	p_ITERATOR_NUM_OUTER IN NUMBER,
	p_ITERATOR_NUM_INNER IN NUMBER,
	p_ITERATOR_ID IN OUT NUMBER,
	p_VARIABLE_CACHE IN OUT NOCOPY UT.STRING_MAP,
	p_CHANGED_ITERATORS IN PLS_INTEGER,
	p_ITERATOR_DEPENDS IN OUT NOCOPY FML_UTIL.ITERATOR_DEPENDS,
	p_FML_REALMS IN OUT NOCOPY ID_FLAG_MAP,
	p_FML_REALM_WORK_IDs IN OUT NOCOPY BIGKEY_ID_MAP
	);
---------------------------------------------------------------------------------------------------
PROCEDURE FORMULA_DATE_LOOP
	(
    p_CHARGE_ID IN NUMBER,
	p_PRIOR_CHARGE_ID IN NUMBER,
    p_COMPONENT_ID IN NUMBER,
	p_IS_BILL IN BOOLEAN,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_LOCAL_BEGIN_DATE IN DATE,
	p_LOCAL_END_DATE IN DATE,
	p_WEEK_BEGIN IN VARCHAR2,
    p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
    p_INTERVAL_ENDING IN BOOLEAN,
    p_CHARGE_INTERVAL IN VARCHAR2,
    p_TRUNC_INTERVAL IN VARCHAR2,
	p_ITERATOR_NAMES IN OUT NOCOPY ITERATOR_VALS,
	p_ITERATOR_VALS IN OUT NOCOPY ITERATOR_VALS,
	p_ITERATOR_NUM_OUTER IN NUMBER,
	p_ITERATOR_NUM_INNER IN NUMBER,
	p_ITERATOR_ID IN OUT NUMBER,
	p_VARIABLE_CACHE IN OUT NOCOPY UT.STRING_MAP,
	p_CHANGED_ITERATORS IN VARCHAR2,
	p_ITERATOR_DEPENDS IN OUT NOCOPY FML_UTIL.ITERATOR_DEPENDS,
	p_FML_REALMS IN OUT NOCOPY ID_FLAG_MAP,
	p_FML_REALM_WORK_IDs IN OUT NOCOPY BIGKEY_ID_MAP
	) AS
v_IS_DST_DAY		BOOLEAN;
v_LOCAL_LAST_DATE	DATE;
v_DAY				DATE;
v_ITERATORS			ITERATOR_TABLE := ITERATOR_TABLE();
v_INPUTS			INPUT_TABLE := INPUT_TABLE();
v_INTERMEDIATES		INTERMEDIATE_TABLE := INTERMEDIATE_TABLE();
v_RESULTS			RESULT_TABLE := RESULT_TABLE();
v_COMPONENT_FACTOR	FORMULA_CHARGE.CHARGE_FACTOR%TYPE;
v_COMPONENT_FACTOR_END DATE;
v_QUANTITY_FML		COMPONENT_FORMULA_VARIABLE.FORMULA%TYPE;
v_RATE_FML			COMPONENT_FORMULA_VARIABLE.FORMULA%TYPE;
v_BEGIN_DATE		DATE := p_BEGIN_DATE;
v_LOCAL_BEGIN_DATE	DATE := p_LOCAL_BEGIN_DATE;
v_LOOP_END_DATE		DATE;
v_LOCAL_LOOP_END_DATE DATE;
v_DATE				DATE;
v_DATE2				DATE;
v_TZ_DATE			DATE;
v_INDEX				PLS_INTEGER;
BEGIN
	-- Seed the caches and determine if the first interval is for a DST day.
	-- TODO: the code below is duplicated inside the loop, too. Ideally, we
	-- refactor the flow slightly so we can consolidate.

	-- query for input and formula definitions
	IF p_TRUNC_INTERVAL = c_METER_POINT_INTERVAL_ABBR THEN
		v_LOOP_END_DATE := p_END_DATE;
		v_LOCAL_LOOP_END_DATE := p_LOCAL_END_DATE;
	ELSE
	    v_LOOP_END_DATE := DATE_UTIL.GET_INTERVAL_END_DATE(v_BEGIN_DATE, p_TRUNC_INTERVAL, p_WEEK_BEGIN);
	    v_LOCAL_LOOP_END_DATE := DATE_UTIL.GET_INTERVAL_END_DATE(v_LOCAL_BEGIN_DATE, p_TRUNC_INTERVAL, p_WEEK_BEGIN);
	END IF;
    v_LOCAL_LAST_DATE := TRUNC(v_LOCAL_LOOP_END_DATE-1/86400);

	GATHER_FORMULA_ITERATORS(p_COMPONENT_ID, v_LOCAL_LAST_DATE, v_ITERATORS, TRUE);
	GATHER_FORMULA_INPUTS(p_COMPONENT_ID, v_LOCAL_LAST_DATE, v_INPUTS);
	GATHER_FORMULA_INTERMEDIATES(p_COMPONENT_ID, v_LOCAL_LAST_DATE, v_INTERMEDIATES);
	IF p_IS_BILL THEN
		GET_COMPONENT_FACTOR(p_COMPONENT_ID, v_LOCAL_LAST_DATE, v_COMPONENT_FACTOR, v_COMPONENT_FACTOR_END);
	ELSE
		GATHER_FORMULA_RESULTS(p_COMPONENT_ID, v_LOCAL_LAST_DATE, v_RESULTS);
	END IF;
    -- get formula definitions for quantity and rate
	IF p_IS_BILL THEN
		SELECT FORMULA INTO v_QUANTITY_FML
		FROM COMPONENT_FORMULA_VARIABLE
		WHERE COMPONENT_ID = p_COMPONENT_ID
			AND SUB_COMPONENT_TYPE =  CONSTANTS.UNDEFINED_ATTRIBUTE
			AND SUB_COMPONENT_ID = CONSTANTS.NOT_ASSIGNED
			AND VARIABLE_NAME = '#CHARGE QUANTITY#';

		SELECT FORMULA INTO v_RATE_FML
		FROM COMPONENT_FORMULA_VARIABLE
		WHERE COMPONENT_ID = p_COMPONENT_ID
			AND SUB_COMPONENT_TYPE =  CONSTANTS.UNDEFINED_ATTRIBUTE
			AND SUB_COMPONENT_ID = CONSTANTS.NOT_ASSIGNED
			AND VARIABLE_NAME = '#CHARGE RATE#';
	END IF;

	-- will be true if current interval is on or encompasses a DST shift day
    v_IS_DST_DAY := TRUNC(DST_SPRING_AHEAD_DATE(v_LOCAL_BEGIN_DATE)) BETWEEN TRUNC(v_LOCAL_BEGIN_DATE) AND TRUNC(v_LOCAL_LOOP_END_DATE-1/86400)
    			OR TRUNC(DST_FALL_BACK_DATE(v_LOCAL_BEGIN_DATE)) BETWEEN TRUNC(v_LOCAL_BEGIN_DATE) AND TRUNC(v_LOCAL_LOOP_END_DATE-1/86400);

	WHILE v_BEGIN_DATE <= p_END_DATE LOOP
		IF p_TRUNC_INTERVAL = c_METER_POINT_INTERVAL_ABBR THEN
			v_LOOP_END_DATE := p_END_DATE;
			v_LOCAL_LOOP_END_DATE := p_LOCAL_END_DATE;
		ELSE
			v_LOOP_END_DATE := DATE_UTIL.GET_INTERVAL_END_DATE(v_BEGIN_DATE, p_TRUNC_INTERVAL, p_WEEK_BEGIN);
			v_LOCAL_LOOP_END_DATE := DATE_UTIL.GET_INTERVAL_END_DATE(v_LOCAL_BEGIN_DATE, p_TRUNC_INTERVAL, p_WEEK_BEGIN);
		END IF;
		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG('Charge start = '||TO_CHAR(v_LOCAL_BEGIN_DATE,'mm/dd/yyyy hh24:mi:ss'));
			LOGS.LOG_DEBUG('Charge end = '||TO_CHAR(v_LOCAL_LOOP_END_DATE,'mm/dd/yyyy hh24:mi:ss'));
			LOGS.LOG_DEBUG('Charge start(CUT) = '||TO_CHAR(v_BEGIN_DATE,'mm/dd/yyyy hh24:mi:ss'));
			LOGS.LOG_DEBUG('Charge end(CUT) = '||TO_CHAR(v_LOOP_END_DATE,'mm/dd/yyyy hh24:mi:ss'));
		END IF;
    	-- new billing day?
        v_DAY := TRUNC(v_LOCAL_LOOP_END_DATE-1/86400);
    	IF v_LOCAL_LAST_DATE <> v_DAY THEN
			-- re-query iterators/inputs/formulas definitions if necessary

            v_INDEX := v_ITERATORS.FIRST;
            WHILE v_ITERATORS.EXISTS(v_INDEX) LOOP
            	IF v_DAY > NVL(v_ITERATORS(v_INDEX).END_DATE, CONSTANTS.HIGH_DATE) THEN
                	GATHER_FORMULA_ITERATORS(p_COMPONENT_ID, v_DAY, v_ITERATORS, TRUE);
                	EXIT;
                END IF;
            	v_INDEX := v_ITERATORS.NEXT(v_INDEX);
            END LOOP;

            v_INDEX := v_INPUTS.FIRST;
            WHILE v_INPUTS.EXISTS(v_INDEX) LOOP
            	IF v_DAY > NVL(v_INPUTS(v_INDEX).END_DATE, CONSTANTS.HIGH_DATE) THEN
                	GATHER_FORMULA_INPUTS(p_COMPONENT_ID, v_DAY, v_INPUTS);
                	EXIT;
                END IF;
            	v_INDEX := v_INPUTS.NEXT(v_INDEX);
            END LOOP;

            v_INDEX := v_INTERMEDIATES.FIRST;
            WHILE v_INTERMEDIATES.EXISTS(v_INDEX) LOOP
            	IF v_DAY > NVL(v_INTERMEDIATES(v_INDEX).END_DATE, CONSTANTS.HIGH_DATE) THEN
		        	GATHER_FORMULA_INTERMEDIATES(p_COMPONENT_ID, v_DAY, v_INTERMEDIATES);
                	EXIT;
                END IF;
            	v_INDEX := v_INTERMEDIATES.NEXT(v_INDEX);
            END LOOP;

			IF p_IS_BILL THEN
				-- see if component factor changed and re-query if needed
				IF v_DAY > NVL(v_COMPONENT_FACTOR_END, CONSTANTS.HIGH_DATE) THEN
					GET_COMPONENT_FACTOR(p_COMPONENT_ID, v_LOCAL_LAST_DATE, v_COMPONENT_FACTOR, v_COMPONENT_FACTOR_END);
				END IF;
			ELSE
				-- gather result definitions if needed
				v_INDEX := v_RESULTS.FIRST;
				WHILE v_RESULTS.EXISTS(v_INDEX) LOOP
					IF v_DAY > NVL(v_RESULTS(v_INDEX).END_DATE, CONSTANTS.HIGH_DATE) THEN
						GATHER_FORMULA_RESULTS(p_COMPONENT_ID, v_DAY, v_RESULTS);
						EXIT;
					END IF;
					v_INDEX := v_RESULTS.NEXT(v_INDEX);
				END LOOP;
			END IF;

        	-- needs to be true if current interval is on or encompasses a DST shift day
            v_IS_DST_DAY := TRUNC(DST_SPRING_AHEAD_DATE(v_LOCAL_BEGIN_DATE)) BETWEEN TRUNC(v_LOCAL_BEGIN_DATE) AND TRUNC(v_LOCAL_LOOP_END_DATE-1/86400)
            			OR TRUNC(DST_FALL_BACK_DATE(v_LOCAL_BEGIN_DATE)) BETWEEN TRUNC(v_LOCAL_BEGIN_DATE) AND TRUNC(v_LOCAL_LOOP_END_DATE-1/86400);
        END IF;
        v_LOCAL_LAST_DATE := v_DAY;
        -- get end date for this interval
		IF p_INTERVAL_ENDING THEN
			-- get end date for this interval in local time
			IF v_IS_DST_DAY THEN
        	    v_LOCAL_LOOP_END_DATE := FROM_CUT(v_LOOP_END_DATE, p_TIME_ZONE);
    		ELSE
            	v_LOCAL_LOOP_END_DATE := v_LOCAL_BEGIN_DATE + (v_LOOP_END_DATE-v_BEGIN_DATE);
            END IF;
        ELSE
			-- get end date for this interval in cut time
			IF v_IS_DST_DAY THEN
        	    v_LOOP_END_DATE := TO_CUT(v_LOCAL_LOOP_END_DATE, p_TIME_ZONE);
    		ELSE
            	v_LOOP_END_DATE := v_BEGIN_DATE + (v_LOCAL_LOOP_END_DATE-v_LOCAL_BEGIN_DATE);
            END IF;
		END IF;
        -- restrict length of interval if necessary
        IF v_LOOP_END_DATE > p_END_DATE THEN
        	v_LOOP_END_DATE := p_END_DATE;
        END IF;

        IF p_INTERVAL_ENDING THEN
        	v_DATE := v_LOOP_END_DATE;
            v_TZ_DATE := v_LOCAL_LOOP_END_DATE;
        ELSE
        	v_DATE := v_LOCAL_BEGIN_DATE;
            v_TZ_DATE := v_DATE;
        END IF;
		IF p_TRUNC_INTERVAL = c_METER_POINT_INTERVAL_ABBR THEN
			v_DATE2 := v_DAY;
		ELSE
			v_DATE2 := NULL;
		END IF;
        -- insert special variable values
        p_VARIABLE_CACHE(':now') := UT.GET_LITERAL_FOR_DATE(v_TZ_DATE);
    	p_VARIABLE_CACHE(':cut_now') := UT.GET_LITERAL_FOR_DATE(v_DATE);
        p_VARIABLE_CACHE(':begin_date') := UT.GET_LITERAL_FOR_DATE(v_LOCAL_BEGIN_DATE);
    	p_VARIABLE_CACHE(':cut_begin_date') := UT.GET_LITERAL_FOR_DATE(v_BEGIN_DATE);
        p_VARIABLE_CACHE(':end_date') := UT.GET_LITERAL_FOR_DATE(v_LOCAL_LOOP_END_DATE);
    	p_VARIABLE_CACHE(':cut_end_date') := UT.GET_LITERAL_FOR_DATE(v_LOOP_END_DATE);

        FORMULA_ITERATOR_LOOP(
            p_CHARGE_ID, p_PRIOR_CHARGE_ID, p_COMPONENT_ID, p_IS_BILL, v_COMPONENT_FACTOR,
            v_BEGIN_DATE, v_LOOP_END_DATE, v_LOCAL_BEGIN_DATE, v_LOCAL_LOOP_END_DATE,
            v_DATE, v_DATE2, p_WEEK_BEGIN, p_AS_OF_DATE, p_TIME_ZONE, p_INTERVAL_ENDING, p_CHARGE_INTERVAL,
			p_TRUNC_INTERVAL, v_INPUTS, v_INTERMEDIATES, v_RESULTS, v_QUANTITY_FML, v_RATE_FML,
            v_ITERATORS, v_ITERATORS.FIRST, TRUE,
			p_ITERATOR_NAMES, p_ITERATOR_VALS, p_ITERATOR_NUM_OUTER, p_ITERATOR_NUM_INNER,
			p_ITERATOR_ID, p_VARIABLE_CACHE, p_CHANGED_ITERATORS, p_ITERATOR_DEPENDS,
            p_FML_REALMS, p_FML_REALM_WORK_IDs);

		v_BEGIN_DATE := v_LOOP_END_DATE+1/86400;
        v_LOCAL_BEGIN_DATE := v_LOCAL_LOOP_END_DATE+1/86400;
	END LOOP;

	v_INPUTS.DELETE;
	v_INTERMEDIATES.DELETE;

END FORMULA_DATE_LOOP;
---------------------------------------------------------------------------------------------------
PROCEDURE FORMULA_ITERATOR_LOOP
	(
    p_CHARGE_ID IN NUMBER,
	p_PRIOR_CHARGE_ID IN NUMBER,
    p_COMPONENT_ID IN NUMBER,
	p_IS_BILL IN BOOLEAN,
	p_COMPONENT_FACTOR IN NUMBER,
    p_BEGIN_DATE IN OUT DATE,
    p_END_DATE IN DATE,
    p_LOCAL_BEGIN_DATE IN OUT DATE,
    p_LOCAL_END_DATE IN DATE,
	p_DATE IN DATE,
	p_DATE2 IN DATE,
	p_WEEK_BEGIN IN VARCHAR2,
    p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
    p_INTERVAL_ENDING IN BOOLEAN,
    p_CHARGE_INTERVAL IN VARCHAR2,
    p_TRUNC_INTERVAL IN VARCHAR2,
    p_INPUTS IN INPUT_TABLE,
    p_INTERMEDIATES IN INTERMEDIATE_TABLE,
    p_RESULTS IN RESULT_TABLE,
    p_QUANTITY_FML IN VARCHAR2,
    p_RATE_FML IN VARCHAR2,
	p_ITERATORS IN ITERATOR_TABLE,
	p_ITERATOR_INDEX IN NUMBER,
	p_DO_INNER IN BOOLEAN,
	p_ITERATOR_NAMES IN OUT NOCOPY ITERATOR_VALS,
	p_ITERATOR_VALS IN OUT NOCOPY ITERATOR_VALS,
	p_ITERATOR_NUM_OUTER IN NUMBER,
	p_ITERATOR_NUM_INNER IN NUMBER,
	p_ITERATOR_ID IN OUT NUMBER,
	p_VARIABLE_CACHE IN OUT NOCOPY UT.STRING_MAP,
	p_CHANGED_ITERATORS IN PLS_INTEGER,
	p_ITERATOR_DEPENDS IN OUT NOCOPY FML_UTIL.ITERATOR_DEPENDS,
	p_FML_REALMS IN OUT NOCOPY ID_FLAG_MAP,
	p_FML_REALM_WORK_IDs IN OUT NOCOPY BIGKEY_ID_MAP
	) AS
v_RECORD			STRING_COLLECTION;
v_COL_NAMES			GA.STRING_TABLE;
v_COLNUM			PLS_INTEGER;
v_ITERATOR_COL_COUNT PLS_INTEGER;
v_CURSOR			GA.REFCURSOR;
v_QUERY				COMPONENT_FORMULA_ITERATOR.ITERATOR_QUERY%TYPE;
v_IDX				PLS_INTEGER;
v_VAL				VARCHAR2(256);
v_CHANGED_ITERATORS	PLS_INTEGER := p_CHANGED_ITERATORS;
v_ITERATORS			PLS_INTEGER;
v_FIRST				BOOLEAN := TRUE;
v_NEW_DEPENDS		PLS_INTEGER;
v_ITERATOR_DEF		COMPONENT_FORMULA_ITERATOR%ROWTYPE;
v_ITERATOR_NUM		NUMBER := p_ITERATOR_NUM_OUTER+p_ITERATOR_NUM_INNER;
v_DATE_INNERMOST_LOOP BOOLEAN := p_ITERATOR_NUM_INNER = 0;
v_DATE_OUTERMOST_LOOP BOOLEAN := p_ITERATOR_NUM_OUTER = 0;
BEGIN
	IF p_ITERATORS.EXISTS(p_ITERATOR_INDEX) AND v_ITERATOR_NUM < FML_UTIL.c_MAX_ITERATORS THEN

		v_ITERATOR_DEF := p_ITERATORS(p_ITERATOR_INDEX);

		BEGIN
            IF LOGS.IS_DEBUG_ENABLED THEN
                LOGS.LOG_DEBUG('Iterator Query (before) = ');
                LOGS.LOG_DEBUG(v_ITERATOR_DEF.ITERATOR_QUERY);
            END IF;

            -- Require formal syntax for iterator queries
            FML_UTIL.REBUILD_FORMULA(v_ITERATOR_DEF.ITERATOR_QUERY, p_VARIABLE_CACHE, p_ITERATOR_DEPENDS, v_ITERATORS, v_QUERY,
                                     TRUE, TRUE, FML_UTIL.c_PLSQL_NO, TRUE);

            IF LOGS.IS_DEBUG_ENABLED THEN
                LOGS.LOG_DEBUG('Iterator Query (after) = ');
                LOGS.LOG_DEBUG(v_QUERY);
            END IF;

            OPEN v_CURSOR FOR v_QUERY;

            -- get some metadata for cursor
            IF v_ITERATOR_DEF.IS_MULTICOLUMN = 1 THEN
                -- parse the name - comma-separated list of names
                UT.TOKENS_FROM_STRING(v_ITERATOR_DEF.ITERATOR_NAME, ',', v_COL_NAMES);

                v_COLNUM := v_COL_NAMES.COUNT;

                v_ITERATOR_COL_COUNT := LEAST(FML_UTIL.c_MAX_ITERATORS - v_ITERATOR_NUM, v_COLNUM, NVL(v_ITERATOR_DEF.IDENT_COLUMNS,v_COLNUM));
                FOR v_IDX IN 1..v_COLNUM LOOP
                    v_COL_NAMES(v_IDX) := TRIM(v_COL_NAMES(v_IDX)); -- eliminate extra whitespace
                    IF v_IDX <= v_ITERATOR_COL_COUNT THEN
                        p_ITERATOR_NAMES(v_ITERATOR_NUM+v_IDX) := v_COL_NAMES(v_IDX);
                    END IF;
                END LOOP;
            ELSE
                v_ITERATOR_COL_COUNT := 1;
                v_COLNUM := 1;
                p_ITERATOR_NAMES(v_ITERATOR_NUM+1) := v_ITERATOR_DEF.ITERATOR_NAME;
                v_COL_NAMES(1) := v_ITERATOR_DEF.ITERATOR_NAME;
            END IF;
        EXCEPTION
        WHEN OTHERS THEN
            LOG_FAILURE_CONTEXT('Iterator: ''' || v_ITERATOR_DEF.ITERATOR_NAME || '''',
                                p_DATE,
                                p_COMPONENT_ID,
                                p_VARIABLE_CACHE);
            ERRS.LOG_AND_RAISE;
        END;

		-- loop through each record in cursor
		LOOP
			IF v_ITERATOR_DEF.IS_MULTICOLUMN = 1 THEN
				FETCH v_CURSOR INTO v_RECORD;
				EXIT WHEN v_CURSOR%NOTFOUND;

				ASSERT(v_RECORD.COUNT = v_COLNUM,
					  'Expecting '||v_COLNUM||' values for ['||v_ITERATOR_DEF.ITERATOR_NAME||'] but received '||v_RECORD.COUNT);
			ELSE
				v_RECORD := STRING_COLLECTION(NULL);
				FETCH v_CURSOR INTO v_RECORD(1);
				EXIT WHEN v_CURSOR%NOTFOUND;
			END IF;

			v_NEW_DEPENDS := FML_UTIL.c_SINGLE_ITER_NODEPENDS;

			FOR v_IDX IN 1..v_COLNUM LOOP
				v_VAL := UT.GET_LITERAL_FOR_STRING(v_RECORD(v_IDX));
				p_VARIABLE_CACHE(v_COL_NAMES(v_IDX)) := v_VAL;
				IF v_IDX <= v_ITERATOR_COL_COUNT THEN
					-- move to iterator value array
					p_ITERATOR_VALS(v_ITERATOR_NUM+v_IDX) := v_RECORD(v_IDX);
					p_VARIABLE_CACHE(':iter'||(v_ITERATOR_NUM+v_IDX)) := v_VAL;
					--update ITERATOR depends so that these names depend on this iterator
					p_ITERATOR_DEPENDS(':iter'||(v_ITERATOR_NUM+v_IDX)) := FML_UTIL.c_SINGLE_ITER_DEPENDS(v_ITERATOR_NUM+v_IDX);
					p_ITERATOR_DEPENDS(v_COL_NAMES(v_IDX)) := FML_UTIL.c_SINGLE_ITER_DEPENDS(v_ITERATOR_NUM+v_IDX);
					v_NEW_DEPENDS := FML_UTIL.COMBINE_DEPENDS(v_NEW_DEPENDS, FML_UTIL.c_SINGLE_ITER_DEPENDS(v_ITERATOR_NUM+v_IDX));
				ELSE
					-- not an iterator, just data? make it depend on all iterators
					-- defined by this query
					p_ITERATOR_DEPENDS(v_COL_NAMES(v_IDX)) := v_NEW_DEPENDS;
				END IF;
			END LOOP;

    		-- then recurse
        	FORMULA_ITERATOR_LOOP(
        		p_CHARGE_ID, p_PRIOR_CHARGE_ID, p_COMPONENT_ID, p_IS_BILL,
				p_COMPONENT_FACTOR, p_BEGIN_DATE, p_END_DATE, p_LOCAL_BEGIN_DATE, p_LOCAL_END_DATE,
        		p_DATE, p_DATE2, p_WEEK_BEGIN, p_AS_OF_DATE, p_TIME_ZONE, p_INTERVAL_ENDING,
				p_CHARGE_INTERVAL, p_TRUNC_INTERVAL,
				p_INPUTS, p_INTERMEDIATES, p_RESULTS, p_QUANTITY_FML, p_RATE_FML,
    			p_ITERATORS, p_ITERATORS.NEXT(p_ITERATOR_INDEX), p_DO_INNER,
				p_ITERATOR_NAMES, p_ITERATOR_VALS,
				p_ITERATOR_NUM_OUTER + CASE WHEN p_DO_INNER THEN 0 ELSE v_ITERATOR_COL_COUNT END,
				p_ITERATOR_NUM_INNER + CASE WHEN p_DO_INNER THEN v_ITERATOR_COL_COUNT ELSE 0 END,
				p_ITERATOR_ID, p_VARIABLE_CACHE, FML_UTIL.COMBINE_DEPENDS(v_CHANGED_ITERATORS,v_NEW_DEPENDS),
				p_ITERATOR_DEPENDS, p_FML_REALMS, p_FML_REALM_WORK_IDs);

			-- update changed flags so that dependant inputs know whether or not
			-- they should be re-queried
			IF v_FIRST THEN
				v_CHANGED_ITERATORS := FML_UTIL.c_SINGLE_ITER_NODEPENDS;
				v_FIRST := FALSE;
			END IF;
		END LOOP;

		IF v_RECORD IS NOT NULL THEN
			v_RECORD.DELETE;
		END IF;
		v_COL_NAMES.DELETE;

		CLOSE v_CURSOR;

	ELSE
		-- no more iterators? then process inner calculation loop
		IF NOT p_DO_INNER THEN
			-- if there are no inner iterators, then all iterator queries have been evaluated
			-- and we can safely establish iterator ID and values
			IF v_DATE_INNERMOST_LOOP THEN
				IF v_ITERATOR_NUM = 0 THEN
					PUT_FORMULA_CHARGE_ITERATOR(p_CHARGE_ID, 0, NULL, NULL);
				ELSE
					p_ITERATOR_ID := p_ITERATOR_ID+1;
					PUT_FORMULA_CHARGE_ITERATOR(p_CHARGE_ID, p_ITERATOR_ID, p_ITERATOR_NAMES, p_ITERATOR_VALS);
				END IF;
			END IF;

			-- Date Loop - which will recursively call this procedure to evaluate any
			-- "inner loop" iterators
        	FORMULA_DATE_LOOP(
        		p_CHARGE_ID, p_PRIOR_CHARGE_ID, p_COMPONENT_ID, p_IS_BILL,
				p_BEGIN_DATE, p_END_DATE, p_LOCAL_BEGIN_DATE, p_LOCAL_END_DATE,
				p_WEEK_BEGIN, p_AS_OF_DATE, p_TIME_ZONE, p_INTERVAL_ENDING,
				p_CHARGE_INTERVAL, p_TRUNC_INTERVAL,
    			p_ITERATOR_NAMES, p_ITERATOR_VALS,
				p_ITERATOR_NUM_OUTER, p_ITERATOR_NUM_INNER, p_ITERATOR_ID,
				p_VARIABLE_CACHE, p_CHANGED_ITERATORS, p_ITERATOR_DEPENDS,
				p_FML_REALMS, p_FML_REALM_WORK_IDs);
		ELSE
			-- at this point all iterator queries have been evaluated. If there were inner
			-- iterators, then we haven't yet been able to persist the iterator names and values
			-- so do it now
			IF NOT v_DATE_INNERMOST_LOOP THEN
				GET_FORMULA_CHARGE_ITERATOR_ID(p_CHARGE_ID, p_ITERATOR_NAMES, p_ITERATOR_VALS, p_ITERATOR_ID);
			END IF;

			-- All iterator and date loops have started, so now we evaluate the formula inputs,
			-- intermediates, and results for this iteration
    		EVALUATE_FORMULAS(
				p_CHARGE_ID, p_PRIOR_CHARGE_ID, p_IS_BILL, p_COMPONENT_ID, p_COMPONENT_FACTOR,
				p_BEGIN_DATE, p_END_DATE, p_LOCAL_BEGIN_DATE, p_LOCAL_END_DATE,
				p_DATE, p_DATE2, p_WEEK_BEGIN, p_AS_OF_DATE, p_TIME_ZONE,
				p_CHARGE_INTERVAL,v_DATE_OUTERMOST_LOOP,
				p_INPUTS, p_INTERMEDIATES, p_RESULTS,
				p_QUANTITY_FML, p_RATE_FML,
				p_ITERATOR_VALS, p_ITERATOR_ID, p_VARIABLE_CACHE,
				p_CHANGED_ITERATORS, p_ITERATOR_DEPENDS,
				p_FML_REALMS, p_FML_REALM_WORK_IDs);
		END IF;
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			IF v_CURSOR%ISOPEN THEN
				-- in case it has been opened, make sure to close it
				CLOSE v_CURSOR;
			END IF;
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE;
		END;
		ERRS.LOG_AND_RAISE;
END FORMULA_ITERATOR_LOOP;
---------------------------------------------------------------------------------------------------
PROCEDURE CLEAN_FML_REALM_WORK_IDs
	(
	p_FML_REALM_WORK_IDs IN BIGKEY_ID_MAP
	) AS
v_KEY VARCHAR2(4000);
BEGIN
	v_KEY := p_FML_REALM_WORK_IDs.FIRST;
	WHILE p_FML_REALM_WORK_IDs.EXISTS(v_KEY) LOOP
		UT.PURGE_RTO_WORK(p_FML_REALM_WORK_IDs(v_KEY));
		v_KEY := p_FML_REALM_WORK_IDs.NEXT(v_KEY);
	END LOOP;
END CLEAN_FML_REALM_WORK_IDs;
----------------------------------------------------------------------------------------------------
-- Runs a calculation process for the specified dates, entities, and statement type. This
-- will create an entry in the process log and will perform commits as governed by the
-- System Dictionary entry:
--        Global -> Calculation Process -> Settings -> Default Commit Frequency
-- The p_STATUS parameter will be zero if the process is successful, otherwise it will
-- indicate the SQLCODE of the fatal exception.
PROCEDURE RUN_CALC_PROCESS
	(
	p_CALC_PROCESS_ID IN NUMBER,
	p_ENTITY_IDs IN NUMBER_COLLECTION,
	p_STATEMENT_TYPE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_PROCESS_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR2
	) AS
v_COMMIT_FREQ 					PLS_INTEGER;
v_COMMIT_FREQ_VAL				SYSTEM_DICTIONARY.VALUE%TYPE;
v_DOMAIN_ID						CALCULATION_PROCESS.CONTEXT_DOMAIN_ID%TYPE;
v_IS_STATEMENT_TYPE_SPECIFIC 	CALCULATION_PROCESS.IS_STATEMENT_TYPE_SPECIFIC%TYPE;
v_PROCESS_INTERVAL				CALCULATION_PROCESS.PROCESS_INTERVAL%TYPE;
v_PROCESS_BEGIN_DATE              DATE;
v_PROCESS_END_DATE                DATE;
v_TIME_ZONE						CALCULATION_PROCESS.TIME_ZONE%TYPE;
v_WEEK_BEGIN                    CALCULATION_PROCESS.WEEK_BEGIN%TYPE;
BEGIN

	--Start the process.
	--Leave the begin and end dates null until we can calculate them and set them below.
	LOGS.START_PROCESS(TEXT_UTIL.TO_CHAR_ENTITY(p_CALC_PROCESS_ID, EC.ED_CALC_PROCESS, TRUE),
						p_TRACE_ON => p_TRACE_ON);

	-- Get some info about the calculation process
	SELECT CONTEXT_DOMAIN_ID, IS_STATEMENT_TYPE_SPECIFIC, PROCESS_INTERVAL, TIME_ZONE, WEEK_BEGIN
	INTO v_DOMAIN_ID, v_IS_STATEMENT_TYPE_SPECIFIC, v_PROCESS_INTERVAL, v_TIME_ZONE, v_WEEK_BEGIN
	FROM CALCULATION_PROCESS
	WHERE CALC_PROCESS_ID = p_CALC_PROCESS_ID;

	-- Get the full date range that will be run so that we can log it accurately.
	IF DATE_UTIL.IS_SUB_DAILY(v_PROCESS_INTERVAL) THEN
		v_PROCESS_BEGIN_DATE := TRUNC(p_BEGIN_DATE);
		v_PROCESS_END_DATE := TRUNC(p_END_DATE);
	ELSE
		DATE_UTIL.EXPAND_DAY_RANGE_FOR_INTERVAL(p_BEGIN_DATE, p_END_DATE, v_PROCESS_INTERVAL, v_PROCESS_BEGIN_DATE, v_PROCESS_END_DATE, v_WEEK_BEGIN);
	END IF;

	-- set target parameter information
	LOGS.SET_PROCESS_TARGET_PARAMETER('CALC_PROCESS', TEXT_UTIL.TO_CHAR_ENTITY(p_CALC_PROCESS_ID, EC.ED_CALC_PROCESS));
	LOGS.SET_PROCESS_TARGET_PARAMETER(LOGS.c_TARGET_PARAM_BEGIN_DATE, TEXT_UTIL.TO_CHAR_DATE(v_PROCESS_BEGIN_DATE));
	LOGS.SET_PROCESS_TARGET_PARAMETER(LOGS.c_TARGET_PARAM_END_DATE, TEXT_UTIL.TO_CHAR_DATE(v_PROCESS_END_DATE));
	IF NVL(v_DOMAIN_ID,CONSTANTS.NOT_ASSIGNED) <> CONSTANTS.NOT_ASSIGNED THEN
		LOGS.SET_PROCESS_TARGET_PARAMETER('ENTITY_IDs', TEXT_UTIL.TO_CHAR_ENTITY_LIST(p_ENTITY_IDs, v_DOMAIN_ID));
	END IF;
	IF v_IS_STATEMENT_TYPE_SPECIFIC = 1 THEN
		LOGS.SET_PROCESS_TARGET_PARAMETER('STATEMENT_TYPE', TEXT_UTIL.TO_CHAR_ENTITY(p_STATEMENT_TYPE_ID, EC.ED_STATEMENT_TYPE));
	END IF;

	-- determine commit frequency from system dictionary
	v_COMMIT_FREQ_VAL := UPPER(TRIM(GET_SETTING('Default Commit Frequency', 'AUTO')));
	v_COMMIT_FREQ :=
		CASE v_COMMIT_FREQ_VAL
		WHEN 'NEVER' THEN c_COMMIT_NEVER
		WHEN 'PROCESS' THEN c_COMMIT_PROCESS
		WHEN 'STEP' THEN c_COMMIT_STEP
		WHEN 'AUTO' THEN c_COMMIT_AUTO
		ELSE NULL
		END;

	IF v_COMMIT_FREQ IS NULL THEN
		LOGS.LOG_WARN('Invalid commit frequency: '||v_COMMIT_FREQ_VAL||'. Using AUTO');
		v_COMMIT_FREQ := c_COMMIT_AUTO;
	END IF;

	-- Now run the calculations!
	-- Pass process dates in as a second past the day so it is clear they are "daily" dates.
	CALC_REQUEST(p_CALC_PROCESS_ID,
			p_ENTITY_IDs,
			p_STATEMENT_TYPE_ID,
			v_PROCESS_BEGIN_DATE + 1/86400,
			v_PROCESS_END_DATE + 1/86400,
			p_AS_OF_DATE, v_COMMIT_FREQ, TRUE);

	LOGS.STOP_PROCESS(p_MESSAGE, p_PROCESS_STATUS);

	-- Done
	COMMIT;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.ABORT_PROCESS;

END RUN_CALC_PROCESS;
----------------------------------------------------------------------------------------------------
PROCEDURE EVALUATE_GLOBALS
	(
	p_RUN_ID IN NUMBER,
	p_CALC_PROCESS_ID IN NUMBER,
	p_CONTEXT IN OUT NOCOPY UT.STRING_MAP
	) AS
PRAGMA AUTONOMOUS_TRANSACTION;
v_FML VARCHAR2(32767);
v_VAL NUMBER;
v_ROW_NUMBER PLS_INTEGER := 1;
BEGIN
	FOR v_GLOBAL IN (SELECT * FROM CALCULATION_PROCESS_GLOBAL
					 WHERE CALC_PROCESS_ID = p_CALC_PROCESS_ID
					 ORDER BY ROW_NUMBER, GLOBAL_NAME) LOOP

            IF LOGS.IS_DEBUG_ENABLED THEN
                LOGS.LOG_DEBUG('Evaluating global '''||v_GLOBAL.GLOBAL_NAME||'''');
                LOGS.LOG_DEBUG('  Formula (before) = '||v_GLOBAL.FORMULA);
            END IF;

            v_FML := FML_UTIL.REBUILD_FORMULA(v_GLOBAL.FORMULA, p_CONTEXT);

            IF LOGS.IS_DEBUG_ENABLED THEN
                LOGS.LOG_DEBUG('  Formula (after) = '||v_FML);
            END IF;

            EXECUTE IMMEDIATE 'SELECT ('||v_FML||') FROM DUAL' INTO v_VAL;

            p_CONTEXT(v_GLOBAL.GLOBAL_NAME) := UT.GET_LITERAL_FOR_NUMBER(v_VAL);

            IF v_GLOBAL.PERSIST_VALUE = 1 THEN
                INSERT INTO CALCULATION_RUN_GLOBAL (CALC_RUN_ID, GLOBAL_NAME, GLOBAL_VAL, ROW_NUMBER)
                    VALUES (p_RUN_ID, v_GLOBAL.GLOBAL_NAME, v_VAL, v_ROW_NUMBER);
                v_ROW_NUMBER := v_ROW_NUMBER+1;
            END IF;
	END LOOP;

	COMMIT;
END EVALUATE_GLOBALS;
----------------------------------------------------------------------------------------------------
PROCEDURE EVALUATE_PARAMETERS
	(
	p_CHARGE_ID IN NUMBER,
	p_CALC_STEP_ID IN NUMBER,
	p_CONTEXT IN OUT NOCOPY UT.STRING_MAP
	) AS
PRAGMA AUTONOMOUS_TRANSACTION;
v_FML VARCHAR2(32767);
v_VAL NUMBER;
v_ROW_NUMBER PLS_INTEGER := 1;
BEGIN
	FOR v_PARM IN  (SELECT * FROM CALCULATION_PROCESS_STEP_PARM
					 WHERE CALC_STEP_ID = p_CALC_STEP_ID
					 ORDER BY ROW_NUMBER, PARAMETER_NAME) LOOP

            IF LOGS.IS_DEBUG_ENABLED THEN
                LOGS.LOG_DEBUG('Evaluating parameter '''||v_PARM.PARAMETER_NAME||'''');
                LOGS.LOG_DEBUG('  Formula (before) = '||v_PARM.FORMULA);
            END IF;

            v_FML := FML_UTIL.REBUILD_FORMULA(v_PARM.FORMULA, p_CONTEXT);

            IF LOGS.IS_DEBUG_ENABLED THEN
                LOGS.LOG_DEBUG('  Formula (after) = '||v_FML);
            END IF;

            EXECUTE IMMEDIATE 'SELECT ('||v_FML||') FROM DUAL' INTO v_VAL;

            p_CONTEXT(v_PARM.PARAMETER_NAME) := UT.GET_LITERAL_FOR_NUMBER(v_VAL);

            INSERT INTO CALCULATION_RUN_STEP_PARM (CHARGE_ID, PARAMETER_NAME, PARAMETER_VAL, ROW_NUMBER)
                VALUES (p_CHARGE_ID, v_PARM.PARAMETER_NAME, v_VAL, v_ROW_NUMBER);
            v_ROW_NUMBER := v_ROW_NUMBER+1;
	END LOOP;

	COMMIT;
END EVALUATE_PARAMETERS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_RUN_ENTITIES
	(
	p_ENTITY_IDs IN NUMBER_COLLECTION,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_RUN_ACTION_ID IN NUMBER,
	p_REALM_ID IN NUMBER,
	p_GROUP_ID IN NUMBER,
	p_DATE IN DATE,
	p_OUT_ENTITY_IDs OUT NUMBER_COLLECTION,
	p_ALLOWED_ENTITY_IDs OUT ID_TABLE,
	p_RUNNING_ALL OUT BOOLEAN
	) AS
v_ALLOWED	BOOLEAN;
v_IDX		PLS_INTEGER;
v_WORK_ID	RTO_WORK.WORK_ID%TYPE;
BEGIN
	-- no domain? then no entities - just return a single, NULL entry
	IF NVL(p_ENTITY_DOMAIN_ID,CONSTANTS.NOT_ASSIGNED) = CONSTANTS.NOT_ASSIGNED THEN
		-- make sure user has access to run this process
		IF p_RUN_ACTION_ID IS NULL THEN
			v_ALLOWED := SD.GET_ENTITY_IS_ALLOWED(ENTITY_UTIL.c_DEFAULT_RUN_NA_ACTION_NAME, SD.g_ALL_DATA_ENTITY_ID, CONSTANTS.NOT_ASSIGNED);
		ELSE
			v_ALLOWED := SD.GET_ENTITY_IS_ALLOWED(p_RUN_ACTION_ID, SD.g_ALL_DATA_ENTITY_ID, CONSTANTS.NOT_ASSIGNED);
		END IF;
		IF NOT v_ALLOWED THEN
			p_OUT_ENTITY_IDs := NULL;
		ELSE
			p_OUT_ENTITY_IDs := NUMBER_COLLECTION(NULL);
		END IF;
		p_RUNNING_ALL := TRUE;
		-- finished
		RETURN;
	END IF;

	-- does the list contain <ALL> (ID = -1)
	p_RUNNING_ALL := FALSE;
	v_IDX := p_ENTITY_IDs.FIRST;
	WHILE p_ENTITY_IDs.EXISTS(v_IDX) LOOP
		IF p_ENTITY_IDs(v_IDX) = CONSTANTS.ALL_ID THEN
			p_RUNNING_ALL := TRUE;
		END IF;
		v_IDX := p_ENTITY_IDs.NEXT(v_IDX);
	END LOOP;

	IF NOT p_RUNNING_ALL THEN

		-- just use the list as it is - we'll check security on the list as we process
		-- each element therein
		p_OUT_ENTITY_IDs := p_ENTITY_IDs;

		-- we'll need the set of allowed IDs to validate the elements of the list
		IF p_RUN_ACTION_ID IS NULL THEN
			p_ALLOWED_ENTITY_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(ENTITY_UTIL.c_DEFAULT_RUN_ACTION_NAME, p_ENTITY_DOMAIN_ID);
		ELSE
			p_ALLOWED_ENTITY_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(p_RUN_ACTION_ID, p_ENTITY_DOMAIN_ID);
		END IF;

	ELSE

		-- enumerate entities
		IF p_RUN_ACTION_ID IS NULL THEN
			SD.ENUMERATE_ENTITIES(ENTITY_UTIL.c_DEFAULT_RUN_ACTION_NAME, p_ENTITY_DOMAIN_ID,
								v_WORK_ID, p_REALM_ID, p_GROUP_ID, p_DATE, p_DATE, TRUE);
		ELSE
			SD.ENUMERATE_ENTITIES(p_RUN_ACTION_ID, p_ENTITY_DOMAIN_ID,
								v_WORK_ID, p_REALM_ID, p_GROUP_ID, p_DATE, p_DATE, TRUE);
		END IF;

		SELECT WORK_XID
		BULK COLLECT INTO p_OUT_ENTITY_IDs
		FROM RTO_WORK
		WHERE WORK_ID = v_WORK_ID;

		UT.PURGE_RTO_WORK(v_WORK_ID);
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		IF v_WORK_ID IS NOT NULL THEN
			UT.PURGE_RTO_WORK(v_WORK_ID);
		END IF;
		ERRS.LOG_AND_RAISE;
END GET_RUN_ENTITIES;
----------------------------------------------------------------------------------------------------
FUNCTION CAN_RUN_ENTITY
	(
	p_ENTITY_ID IN NUMBER,
	p_ALLOWED_ENTITY_IDs IN ID_TABLE,
	p_REALM_ID IN NUMBER,
	p_GROUP_ID IN NUMBER,
	p_DATE IN DATE
	) RETURN BOOLEAN IS
BEGIN
	-- do not have access to this entity?
	IF p_ALLOWED_ENTITY_IDs IS NULL THEN
		RETURN FALSE;
	END IF;
	IF NOT UT.ID_TABLE_CONTAINS(p_ALLOWED_ENTITY_IDs, p_ENTITY_ID)
			AND NOT UT.ID_TABLE_CONTAINS(p_ALLOWED_ENTITY_IDs, SD.g_ALL_DATA_ENTITY_ID) THEN
		RETURN FALSE;
	END IF;

	IF p_REALM_ID IS NOT NULL THEN
		-- is this ID the set of context realm entities?
		RETURN p_REALM_ID = SD.g_ALL_DATA_REALM_ID
			OR SD.IS_MEMBER_OF_SYSTEM_REALM(p_ENTITY_ID, p_REALM_ID);
	ELSE
		-- is this ID the set of context group entities?
		RETURN SD.IS_MEMBER_OF_ENTITY_GROUP(p_ENTITY_ID, p_GROUP_ID, p_DATE, p_DATE, TRUE);
	END IF;
END CAN_RUN_ENTITY;
----------------------------------------------------------------------------------------------------
FUNCTION GET_MUTEX_NAME
	(
	p_CALC_PROCESS_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_STATEMENT_TYPE_ID IN NUMBER,
	p_PROCESS_DATE IN DATE
	) RETURN VARCHAR2 AS
BEGIN
	RETURN 'Calc.Process:'||p_CALC_PROCESS_ID||':'||p_ENTITY_ID||':'||p_STATEMENT_TYPE_ID||':'||TO_CHAR(p_PROCESS_DATE, c_LOCK_DATE_FORMAT);
END GET_MUTEX_NAME;
----------------------------------------------------------------------------------------------------
FUNCTION GET_PROCEDURE_NAME
	(
	p_CALC_PROCESS_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_STATEMENT_TYPE_ID IN NUMBER,
	p_PROCESS_DATE IN DATE
	) RETURN VARCHAR2 AS
BEGIN
	RETURN SUBSTR( TEXT_UTIL.TO_CHAR_ENTITY(p_CALC_PROCESS_ID, EC.ED_CALC_PROCESS) || ': ' ||
						CASE WHEN NVL(p_ENTITY_DOMAIN_ID,CONSTANTS.NOT_ASSIGNED) <> CONSTANTS.NOT_ASSIGNED THEN TEXT_UTIL.TO_CHAR_ENTITY(p_ENTITY_ID, p_ENTITY_DOMAIN_ID)||', ' ELSE NULL END ||
						CASE WHEN p_STATEMENT_TYPE_ID <> 0 THEN TEXT_UTIL.TO_CHAR_ENTITY(p_STATEMENT_TYPE_ID, EC.ED_STATEMENT_TYPE)||', ' ELSE NULL END ||
						TEXT_UTIL.TO_CHAR_TIME(p_PROCESS_DATE),
					1, 512 );
END GET_PROCEDURE_NAME;
----------------------------------------------------------------------------------------------------
PROCEDURE INIT_FLAGS AS
BEGIN
	g_CANCEL_ON_NULL_INPUT := UT.BOOLEAN_FROM_STRING(
								GET_SETTING('CancelOnNullInput', 'N', 'Errors')
								);
	g_CANCEL_ON_FORMULA_ERROR := UT.BOOLEAN_FROM_STRING(
								GET_SETTING('CancelOnFormulaError', 'Y', 'Errors')
								);
	g_CANCEL_ON_MISSING_OUTPUT := UT.BOOLEAN_FROM_STRING(
								GET_SETTING('CancelOnMissingOutput', 'Y', 'Errors')
								);
	g_CANCEL_ON_TOO_MANY_OUTPUTS := UT.BOOLEAN_FROM_STRING(
								GET_SETTING('CancelOnTooManyOutputs', 'Y', 'Errors')
								);
	g_CANCEL_ON_BAD_OUTPUTINTERVAL := UT.BOOLEAN_FROM_STRING(
								GET_SETTING('CancelOnOutputIntervalMismatch', 'Y', 'Errors')
								);
	g_NEED_LOCK := UT.BOOLEAN_FROM_STRING(
								GET_SETTING('Serialize Calculations', 'Y')
								);

	g_DATA_LOCK_BEHAVIOR := GET_SETTING('Data Locked Behavior', 'Error');

END INIT_FLAGS;
----------------------------------------------------------------------------------------------------
PROCEDURE START_CALCULATION_RUN
	(
	p_CALC_PROCESS_ID IN NUMBER,
	p_RUN_DATE IN DATE,
	p_STATEMENT_TYPE_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_PROCESS_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_RUN_ID OUT NUMBER
	) AS
PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
	-- Purge previous results
	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('Deleting old intermediate results records');
	END IF;

	DELETE CALCULATION_RUN
	WHERE CALC_PROCESS_ID = p_CALC_PROCESS_ID
		AND RUN_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
		AND (STATEMENT_TYPE_ID = p_STATEMENT_TYPE_ID
				OR (STATEMENT_TYPE_ID IS NULL AND p_STATEMENT_TYPE_ID IS NULL))
		AND (CONTEXT_ENTITY_ID = p_ENTITY_ID
				OR (CONTEXT_ENTITY_ID IS NULL AND p_ENTITY_ID IS NULL));

	-- now for the new one...
	SELECT RUN_ID.NEXTVAL INTO p_RUN_ID FROM DUAL;

	INSERT INTO CALCULATION_RUN
		(CALC_RUN_ID, CALC_PROCESS_ID, RUN_DATE, STATEMENT_TYPE_ID, CONTEXT_ENTITY_ID,
		 START_TIME, END_TIME, PROCESS_ID)
	VALUES
		(p_RUN_ID, p_CALC_PROCESS_ID, p_RUN_DATE, p_STATEMENT_TYPE_ID,
		 p_ENTITY_ID, SYSDATE, NULL, p_PROCESS_ID);

	COMMIT;
END START_CALCULATION_RUN;
----------------------------------------------------------------------------------------------------
PROCEDURE STOP_CALCULATION_RUN
	(
	p_RUN_ID IN NUMBER
	) AS
PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
	UPDATE CALCULATION_RUN
		SET END_TIME = SYSDATE
	WHERE CALC_RUN_ID = p_RUN_ID;

	COMMIT;
END STOP_CALCULATION_RUN;
----------------------------------------------------------------------------------------------------
PROCEDURE START_CALCULATION_RUN_STEP
	(
	p_RUN_ID IN NUMBER,
	p_STEP_NUMBER IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_CHARGE_ID OUT NUMBER
	) AS
PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
	SELECT BID.NEXTVAL INTO p_CHARGE_ID FROM DUAL;

	INSERT INTO CALCULATION_RUN_STEP
		(CHARGE_ID, CALC_RUN_ID, STEP_NUMBER, COMPONENT_ID,
		 START_TIME, END_TIME)
	VALUES
		(p_CHARGE_ID, p_RUN_ID, p_STEP_NUMBER, p_COMPONENT_ID,
		 SYSDATE, NULL);

	COMMIT;
END START_CALCULATION_RUN_STEP;
----------------------------------------------------------------------------------------------------
PROCEDURE STOP_CALCULATION_RUN_STEP
	(
	p_CHARGE_ID IN NUMBER
	) AS
PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
	UPDATE CALCULATION_RUN_STEP
		SET END_TIME = SYSDATE
	WHERE CHARGE_ID = p_CHARGE_ID;

	COMMIT;
END STOP_CALCULATION_RUN_STEP;
----------------------------------------------------------------------------------------------------
-- This is the same as the above RUN_CALC_PROCESS procedure, except that it will not create a process log
-- entry, and it will perform commits as instructed by the p_COMMIT_FREQUENCY parameter.
-- If an exception occurs, this procedure will re-throw it instead of catching it and
-- returning its SQLCODE as the one above does.
PROCEDURE CALC_REQUEST
	(
	p_CALC_PROCESS_ID IN NUMBER,
	p_ENTITY_IDs IN NUMBER_COLLECTION,
	p_STATEMENT_TYPE_ID IN NUMBER,
	p_CUT_BEGIN_DATE_TIME IN DATE,
	p_CUT_END_DATE_TIME IN DATE,
	p_AS_OF_DATE IN DATE,
	p_COMMIT_FREQUENCY IN PLS_INTEGER := c_COMMIT_NEVER,
	p_UPDATE_PROGRESS IN BOOLEAN := FALSE
	) AS
v_RUN_BEGIN_DATE DATE;
v_RUN_END_DATE  DATE;
v_CALC_PROCESS	CALCULATION_PROCESS%ROWTYPE;
v_RUN_ACTION_ID	CALCULATION_PROCESS_SECURITY.RUN_ACTION_ID%TYPE;
v_STATEMENT_TYPE_ID STATEMENT_TYPE.STATEMENT_TYPE_ID%TYPE;
v_THE_DATE 		DATE;
v_ENTITIES 		NUMBER_COLLECTION;
v_TOTAL_WORK	PLS_INTEGER;
v_WORK_UNITS	PROCESS_LOG.PROGRESS_UNITS%TYPE;
v_INTERVAL		VARCHAR2(4);
v_IS_SUB_DAILY	BOOLEAN;
v_IDX			PLS_INTEGER;
v_PROCESS_DATE	DATE;
v_BEGIN_DATE	DATE;
v_END_DATE		DATE;
v_CUT_BEGIN_DATE DATE;
v_CUT_END_DATE	DATE;
v_CHARGE_BEGIN	DATE;
v_CHARGE_END	DATE;
v_LAST_PROCESS_DATE	DATE;
v_LOCK			MUTEX.t_HANDLE;
v_RUN_ID		CALCULATION_RUN.CALC_RUN_ID%TYPE;
v_CONTEXT		UT.STRING_MAP;
v_COMPONENT		COMPONENT%ROWTYPE;
v_SKIP_CHARGE	BOOLEAN;
v_PROC_NAME		VARCHAR2(512);
v_RUNNING_ALL	BOOLEAN;
v_ALLOWED_IDs	ID_TABLE;

v_IS_COMP_SUB_DAILY BOOLEAN;
CURSOR c_STEPS(p_DATE IN DATE)  IS
	SELECT *
	FROM CALCULATION_PROCESS_STEP
	WHERE CALC_PROCESS_ID = p_CALC_PROCESS_ID
		AND BEGIN_DATE <= TRUNC(p_DATE)
		AND NVL(END_DATE,CONSTANTS.HIGH_DATE) >= TRUNC(p_DATE)
	ORDER BY STEP_NUMBER;
BEGIN
	SAVEPOINT BEFORE_CALC_REQUEST;

	SELECT * INTO v_CALC_PROCESS
	FROM CALCULATION_PROCESS
	WHERE CALC_PROCESS_ID = p_CALC_PROCESS_ID;

	SELECT MAX(RUN_ACTION_ID) INTO v_RUN_ACTION_ID
	FROM CALCULATION_PROCESS_SECURITY
	WHERE CALC_PROCESS_ID = p_CALC_PROCESS_ID;

	-- determine full process date range.
	v_INTERVAL := GET_INTERVAL_ABBREVIATION(v_CALC_PROCESS.PROCESS_INTERVAL);
	v_IS_SUB_DAILY := DATE_UTIL.IS_SUB_DAILY(v_INTERVAL);
	IF v_IS_SUB_DAILY THEN
		IF TO_CHAR(p_CUT_BEGIN_DATE_TIME, 'SS') = '01' THEN
			v_THE_DATE := TRUNC(p_CUT_BEGIN_DATE_TIME);
			UT.CUT_DATE_RANGE(1, p_CUT_BEGIN_DATE_TIME, p_CUT_END_DATE_TIME, v_CALC_PROCESS.TIME_ZONE, v_INTERVAL, v_RUN_BEGIN_DATE, v_RUN_END_DATE);
		ELSE
			v_THE_DATE := TRUNC(FROM_CUT(p_CUT_BEGIN_DATE_TIME, v_CALC_PROCESS.TIME_ZONE) - 1/86400);
			v_RUN_BEGIN_DATE := p_CUT_BEGIN_DATE_TIME;
			v_RUN_END_DATE := p_CUT_END_DATE_TIME;
		END IF;
	ELSE
		IF TO_CHAR(p_CUT_BEGIN_DATE_TIME, 'SS') = '01' THEN
			v_RUN_BEGIN_DATE := p_CUT_BEGIN_DATE_TIME;
			v_RUN_END_DATE := p_CUT_END_DATE_TIME;
		ELSE
			-- subtract a second so that midnight will fall on previous day (since it represents HE 24 of previous
			-- day) and then add back a second when finished since day and greater intervals are represented by
			-- one second past midnight.
			v_RUN_BEGIN_DATE := TRUNC(FROM_CUT(p_CUT_BEGIN_DATE_TIME, v_CALC_PROCESS.TIME_ZONE)-1/86400) + 1/86400;
			v_RUN_END_DATE := TRUNC(FROM_CUT(p_CUT_END_DATE_TIME, v_CALC_PROCESS.TIME_ZONE)-1/86400) + 1/86400;
		END IF;
		v_THE_DATE := TRUNC(v_RUN_BEGIN_DATE);
	END IF;

	-- filter list of entities for data-level security
	GET_RUN_ENTITIES(p_ENTITY_IDs, v_CALC_PROCESS.CONTEXT_DOMAIN_ID, v_RUN_ACTION_ID,
					v_CALC_PROCESS.CONTEXT_REALM_ID, v_CALC_PROCESS.CONTEXT_GROUP_ID,
					v_THE_DATE, v_ENTITIES, v_ALLOWED_IDs, v_RUNNING_ALL);

	IF v_ENTITIES IS NULL THEN
		LOGS.LOG_WARN('Insufficient privileges to run '''||TEXT_UTIL.TO_CHAR_ENTITY(p_CALC_PROCESS_ID, EC.ED_CALC_PROCESS, TRUE)||'''');
	ELSE
		-- prepare parameters and determine amount of work we'll be doing
		IF p_UPDATE_PROGRESS THEN
			IF NVL(v_CALC_PROCESS.CONTEXT_DOMAIN_ID,CONSTANTS.NOT_ASSIGNED) = CONSTANTS.NOT_ASSIGNED
				 	OR v_ENTITIES.COUNT > 0 THEN
				v_TOTAL_WORK := 1;
				v_WORK_UNITS := 'Calc.Process';
			ELSE
				v_TOTAL_WORK := v_ENTITIES.COUNT;
				v_WORK_UNITS := SUBSTR(EI.GET_ENTITY_NAME(EC.ED_ENTITY_DOMAIN, v_CALC_PROCESS.CONTEXT_DOMAIN_ID),1,32);
			END IF;
			LOGS.INIT_PROCESS_PROGRESS(NULL, v_TOTAL_WORK, v_WORK_UNITS, TRUE);
		END IF;

		INIT_FLAGS;

		-- initialize context
		IF v_CALC_PROCESS.IS_STATEMENT_TYPE_SPECIFIC = 1 THEN
			v_STATEMENT_TYPE_ID := p_STATEMENT_TYPE_ID;
			v_CONTEXT(':statement_type') := p_STATEMENT_TYPE_ID;
		ELSE
			v_STATEMENT_TYPE_ID := NULL;
		END IF;

		v_CONTEXT(':process_id') := UT.GET_LITERAL_FOR_NUMBER(LOGS.CURRENT_PROCESS_ID);
		v_CONTEXT(':session_id') := UT.GET_LITERAL_FOR_NUMBER(LOGS.CURRENT_PROCESS_ID);
		v_CONTEXT(':time_zone') := UT.GET_LITERAL_FOR_STRING(v_CALC_PROCESS.TIME_ZONE);
		v_CONTEXT(':as_of') := UT.GET_LITERAL_FOR_DATE(p_AS_OF_DATE);
		v_CONTEXT(':calc_process') := UT.GET_LITERAL_FOR_NUMBER(p_CALC_PROCESS_ID);
		v_CONTEXT(':calc_process_category') := UT.GET_LITERAL_FOR_STRING(v_CALC_PROCESS.CALC_PROCESS_CATEGORY);

		v_IDX := v_ENTITIES.FIRST;
		WHILE v_ENTITIES.EXISTS(v_IDX) LOOP
			IF LOGS.IS_DEBUG_ENABLED AND v_ENTITIES(v_IDX) IS NOT NULL THEN
				LOGS.LOG_DEBUG('Running calculation processes for '||TEXT_UTIL.TO_CHAR_ENTITY(v_ENTITIES(v_IDX),v_CALC_PROCESS.CONTEXT_DOMAIN_ID,TRUE));
			END IF;

			-- make sure this entity is valid - if we are running all, then we' ve already
			-- done this test when creating the list of all valid entities
			IF v_RUNNING_ALL OR CAN_RUN_ENTITY(v_ENTITIES(v_IDX), v_ALLOWED_IDs, v_CALC_PROCESS.CONTEXT_REALM_ID,
												v_CALC_PROCESS.CONTEXT_GROUP_ID, v_THE_DATE) THEN
				-- add context entity variables
				v_CONTEXT(':context') := UT.GET_LITERAL_FOR_NUMBER(v_ENTITIES(v_IDX));
				IF NVL(v_CALC_PROCESS.CONTEXT_NAME,'?') <> '?' THEN
					-- if a name was specified, bind it now
					v_CONTEXT(v_CALC_PROCESS.CONTEXT_NAME) := UT.GET_LITERAL_FOR_NUMBER(v_ENTITIES(v_IDX));
				END IF;

				v_PROCESS_DATE := DATE_UTIL.HED_TRUNC(v_RUN_BEGIN_DATE, v_INTERVAL, v_CALC_PROCESS.WEEK_BEGIN, TRUE);
				v_LAST_PROCESS_DATE := DATE_UTIL.HED_TRUNC(v_RUN_END_DATE, v_INTERVAL, v_CALC_PROCESS.WEEK_BEGIN, TRUE);

				WHILE v_PROCESS_DATE <= v_LAST_PROCESS_DATE LOOP
					IF LOGS.IS_DEBUG_ENABLED AND v_ENTITIES(v_IDX) IS NOT NULL THEN
						LOGS.LOG_DEBUG('Running calculation process for '||TEXT_UTIL.TO_CHAR_TIME(v_PROCESS_DATE));
					END IF;

					-- come up with date/time range for this process interval
					IF v_IS_SUB_DAILY THEN
						DATE_UTIL.GET_DATE_RANGE(v_PROCESS_DATE, v_INTERVAL, v_CUT_BEGIN_DATE, v_CUT_END_DATE, v_CALC_PROCESS.WEEK_BEGIN);
						v_BEGIN_DATE := FROM_CUT(v_CUT_BEGIN_DATE, v_CALC_PROCESS.TIME_ZONE);
						v_END_DATE := FROM_CUT(v_CUT_END_DATE, v_CALC_PROCESS.TIME_ZONE);
					ELSE
						DATE_UTIL.GET_DATE_RANGE(v_PROCESS_DATE, v_INTERVAL, v_BEGIN_DATE, v_END_DATE, v_CALC_PROCESS.WEEK_BEGIN);
						-- TO_CUT will truncate to the minute when the timestamp indicates one second past midnight because
						-- that is how it distinguishes between the two HE 2s on the 25-hour day - so we must add the second back
						-- to the begin date+time
						v_CUT_BEGIN_DATE := TO_CUT(v_BEGIN_DATE, v_CALC_PROCESS.TIME_ZONE)+1/86400;
						v_CUT_END_DATE := TO_CUT(v_END_DATE, v_CALC_PROCESS.TIME_ZONE);
					END IF;

					v_CONTEXT(':process_date') := UT.GET_LITERAL_FOR_DATE(v_PROCESS_DATE);
					v_CONTEXT(':cut_process_begin_date') := UT.GET_LITERAL_FOR_DATE(v_CUT_BEGIN_DATE);
					v_CONTEXT(':cut_process_end_date') := UT.GET_LITERAL_FOR_DATE(v_CUT_END_DATE);
					v_CONTEXT(':process_begin_date') := UT.GET_LITERAL_FOR_DATE(v_BEGIN_DATE);
					v_CONTEXT(':process_end_date') := UT.GET_LITERAL_FOR_DATE(v_END_DATE);

					-- Serialize calculations if necessary
					IF g_NEED_LOCK THEN
						LOGS.LOG_DEBUG('Acquiring lock');
						v_LOCK := MUTEX.ACQUIRE(GET_MUTEX_NAME(p_CALC_PROCESS_ID, v_ENTITIES(v_IDX),
												v_STATEMENT_TYPE_ID, v_PROCESS_DATE));
						LOGS.LOG_DEBUG('Got it!');
					END IF;
					v_PROC_NAME := GET_PROCEDURE_NAME(p_CALC_PROCESS_ID, v_ENTITIES(v_IDX),
														v_CALC_PROCESS.CONTEXT_DOMAIN_ID, v_STATEMENT_TYPE_ID,
														v_PROCESS_DATE);

					-- Add row to CALCULATION_RUN
					START_CALCULATION_RUN(p_CALC_PROCESS_ID, v_PROCESS_DATE, v_STATEMENT_TYPE_ID,
										 v_ENTITIES(v_IDX), LOGS.CURRENT_PROCESS_ID,
										 -- sub-daily is stored in CUT
										 CASE WHEN v_IS_SUB_DAILY THEN v_CUT_BEGIN_DATE ELSE v_BEGIN_DATE END,
										 CASE WHEN v_IS_SUB_DAILY THEN v_CUT_END_DATE ELSE v_END_DATE END,
										 -- capture resulting run ID
										 v_RUN_ID);

					IF LOGS.IS_DEBUG_ENABLED THEN
						LOGS.LOG_DEBUG('Added new record for run (CALC_RUN_ID = '||v_RUN_ID||')');
					END IF;

					v_CONTEXT(':run_id') := UT.GET_LITERAL_FOR_NUMBER(v_RUN_ID);

					-- Evaluate globals
					IF LOGS.IS_DEBUG_ENABLED THEN
						LOGS.LOG_DEBUG('Evaluating Global Variables');
					END IF;
					EVALUATE_GLOBALS(v_RUN_ID, p_CALC_PROCESS_ID, v_CONTEXT);

					FOR v_STEP IN c_STEPS(v_BEGIN_DATE) LOOP
						SELECT * INTO v_COMPONENT
						FROM COMPONENT
						WHERE COMPONENT_ID = v_STEP.COMPONENT_ID;

						IF LOGS.IS_DEBUG_ENABLED THEN
							LOGS.LOG_DEBUG('Running step #'||v_STEP.STEP_NUMBER||': '||v_COMPONENT.COMPONENT_NAME);
						END IF;

						-- if charge interval is greater than process interval, then this
						-- charge should only show up on first or last process date of charge
						-- interval (i.e. monthly charge should show up on 1st or last day
						-- of month when process interval is daily)
						v_SKIP_CHARGE := FALSE;

                        /* the begin and end date are in cut when the compnent's interval is sub-daily*/
                        v_IS_COMP_SUB_DAILY := DATE_UTIL.IS_SUB_DAILY(v_COMPONENT.RATE_INTERVAL);
						IF DATE_UTIL.INTERVAL_ORD(v_COMPONENT.RATE_INTERVAL) > DATE_UTIL.INTERVAL_ORD(v_CALC_PROCESS.PROCESS_INTERVAL) THEN
							DATE_UTIL.GET_DATE_RANGE(CASE WHEN v_IS_COMP_SUB_DAILY THEN v_CUT_BEGIN_DATE ELSE v_BEGIN_DATE END,
                                v_COMPONENT.RATE_INTERVAL, v_CHARGE_BEGIN, v_CHARGE_END, v_CALC_PROCESS.WEEK_BEGIN);
							-- When the process interval corresponds to the first interval in the charge's interval
							-- (e.g. process interval is the first day of the month) then the process's and charge's
							-- "begin" timestamps will match. Similarly, when the process interval corresponds to the
							-- last interval in the charge then the process's and charge's "end" timestamps will match.

                            IF v_IS_COMP_SUB_DAILY THEN
                                v_SKIP_CHARGE :=
                                    CASE UPPER(v_COMPONENT.WHICH_INTERVAL)
                                        WHEN 'FIRST' THEN v_CUT_BEGIN_DATE > v_CHARGE_BEGIN
                                        ELSE v_CUT_END_DATE < v_CHARGE_END
                                        END;
                            ELSE
                                v_SKIP_CHARGE :=
                                    CASE UPPER(v_COMPONENT.WHICH_INTERVAL)
                                        WHEN 'FIRST' THEN v_BEGIN_DATE > v_CHARGE_BEGIN
                                        ELSE v_END_DATE < v_CHARGE_END
                                        END;
                            END IF;

							IF v_SKIP_CHARGE THEN
								LOGS.LOG_DEBUG_DETAIL('Skipping charge.');
							END IF;
						ELSE
                            IF v_IS_COMP_SUB_DAILY THEN
                                v_CHARGE_BEGIN := v_CUT_BEGIN_DATE;
                                v_CHARGE_END := v_CUT_END_DATE;
                            ELSE
                                v_CHARGE_BEGIN := v_BEGIN_DATE;
                                v_CHARGE_END := v_END_DATE;
                            END IF;
						END IF;
						LOGS.LOG_DEBUG_DETAIL('Local Charge Begin='||TEXT_UTIL.TO_CHAR_TIME(v_CHARGE_BEGIN)||' Local Charge End='||TEXT_UTIL.TO_CHAR_TIME(v_CHARGE_END));

						IF NOT v_SKIP_CHARGE THEN
							DECLARE
								-- make a copy of the context
								v_CONTEXT_FOR_STEP 	UT.STRING_MAP := v_CONTEXT;
								v_CHARGE_ID 		CALCULATION_RUN_STEP.CHARGE_ID%TYPE;
							BEGIN
								-- Add row to CALCULATION_RUN_STEP
								START_CALCULATION_RUN_STEP(v_RUN_ID, v_STEP.STEP_NUMBER, v_STEP.COMPONENT_ID, v_CHARGE_ID);

								IF LOGS.IS_DEBUG_ENABLED THEN
									LOGS.LOG_DEBUG('Added new record for step (CHARGE_ID = '||v_CHARGE_ID||')');
								END IF;

								-- evaluate parameters
								IF LOGS.IS_DEBUG_ENABLED THEN
									LOGS.LOG_DEBUG('Evaluating Step Parameters');
								END IF;
								EVALUATE_PARAMETERS(v_CHARGE_ID, v_STEP.CALC_STEP_ID, v_CONTEXT_FOR_STEP);

								-- Evaluate step
								RUN_FORMULA_COMPONENT(v_CHARGE_ID, NULL, v_COMPONENT, v_CHARGE_BEGIN, v_CHARGE_END, v_IS_COMP_SUB_DAILY,
                                    /* the begin and end date are in cut when the compnent's interval is sub-daily*/
													v_CALC_PROCESS.TIME_ZONE, p_AS_OF_DATE, v_CALC_PROCESS.WEEK_BEGIN,
													v_CONTEXT_FOR_STEP, v_PROC_NAME);

								-- set end time
								STOP_CALCULATION_RUN_STEP(v_CHARGE_ID);

								-- commit?
								IF p_COMMIT_FREQUENCY = c_COMMIT_STEP OR (p_COMMIT_FREQUENCY = c_COMMIT_AUTO AND NOT v_IS_SUB_DAILY) THEN
									COMMIT;
									-- immediately redefine savepoint
									SAVEPOINT BEFORE_CALC_REQUEST;
								END IF;
							END;
						END IF;

					END LOOP;

					-- set end time
					STOP_CALCULATION_RUN(v_RUN_ID);

					-- commit?
					IF p_COMMIT_FREQUENCY = c_COMMIT_PROCESS OR (p_COMMIT_FREQUENCY = c_COMMIT_AUTO AND v_IS_SUB_DAILY) THEN
						COMMIT;
					END IF;
					-- Redefine savepoint so we won't rollback completed processes
					SAVEPOINT BEFORE_CALC_REQUEST;

					-- Serialize calculations if necessary
					IF v_LOCK IS NOT NULL THEN
						LOGS.LOG_DEBUG('Releasing lock');
						MUTEX.RELEASE(v_LOCK);
						v_LOCK := NULL;
						LOGS.LOG_DEBUG('Released!');
					END IF;

					-- advance to the next date
					IF v_IS_SUB_DAILY THEN
						v_PROCESS_DATE := ADVANCE_DATE(v_PROCESS_DATE,v_INTERVAL);
					-- daily and greater intervals are stored interval-beginning, so just
					-- tick the previous end time by one second to get it
					ELSE
						v_PROCESS_DATE := v_END_DATE + 1/86400;
					END IF;
				END LOOP;
			ELSE
				LOGS.LOG_WARN('Insufficient privileges to run '''||TEXT_UTIL.TO_CHAR_ENTITY(p_CALC_PROCESS_ID, EC.ED_CALC_PROCESS, TRUE)||
								''' for '''||TEXT_UTIL.TO_CHAR_ENTITY(v_ENTITIES(v_IDX), v_CALC_PROCESS.CONTEXT_DOMAIN_ID, TRUE)||'''');
			END IF;

			v_IDX := v_ENTITIES.NEXT(v_IDX);
		END LOOP;
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		-- clean up
		IF v_LOCK IS NOT NULL THEN
			LOGS.LOG_DEBUG('Releasing lock');
			MUTEX.RELEASE(v_LOCK);
			LOGS.LOG_DEBUG('Released!');
		END IF;
		-- and get outta here!
		ERRS.LOG_AND_RAISE(p_SAVEPOINT_NAME => 'BEFORE_CALC_REQUEST');

END CALC_REQUEST;
----------------------------------------------------------------------------------------------------
PROCEDURE EVALUATE_ENTITY_REFS
	(
	p_COMPONENT_ID IN NUMBER,
	p_CONTEXT IN OUT NOCOPY UT.STRING_MAP
	) AS
BEGIN
	FOR v_REF IN (SELECT * FROM COMPONENT_FORMULA_ENTITY_REF
					 WHERE COMPONENT_ID = p_COMPONENT_ID) LOOP
		p_CONTEXT(v_REF.REFERENCE_NAME) := UT.GET_LITERAL_FOR_NUMBER(v_REF.ENTITY_ID);
	END LOOP;
END EVALUATE_ENTITY_REFS;
----------------------------------------------------------------------------------------------------
-- Runs a single component. If the component’s entity will be used to determine how
-- calculation results are handled. An entity of ‘Calc.Process’ will cause the
-- calculation process component’s results to be evaluated. Otherwise, the results are
-- a charge quantity and charge rate. The PROC_NAME and STEP_NAME parameters are used for
-- any log messages that are recorded from formulas.
PROCEDURE RUN_FORMULA_COMPONENT
	(
	p_CHARGE_ID IN NUMBER,
	p_PRIOR_CHARGE_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_DATES_ARE_CUT IN BOOLEAN,
	p_TIME_ZONE IN VARCHAR2,
	p_AS_OF_DATE IN DATE,
	p_WEEK_BEGIN IN VARCHAR2,
	p_CONTEXT IN OUT NOCOPY UT.STRING_MAP,
	p_PROC_NAME IN VARCHAR2
	) AS
v_INTERVAL			VARCHAR2(32);
v_IS_BILL			BOOLEAN := NVL(UPPER(p_COMPONENT.COMPONENT_ENTITY),'?') <> 'CALC.PROCESS';
v_BEGIN_DATE		DATE;
v_END_DATE			DATE;
v_LOCAL_BEGIN_DATE	DATE;
v_LOCAL_END_DATE	DATE;
v_INTERVAL_ENDING	BOOLEAN;
v_ITERATORS			ITERATOR_TABLE := ITERATOR_TABLE();
v_ITERATOR_VALS		ITERATOR_VALS := ITERATOR_VALS(NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
v_ITERATOR_NAMES	ITERATOR_VALS := ITERATOR_VALS(NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
v_ITERATOR_ID		PLS_INTEGER := 0;
v_ITERATOR_DEPENDS	FML_UTIL.ITERATOR_DEPENDS;
v_FML_REALMS		ID_FLAG_MAP;
v_FML_REALM_WORK_IDs BIGKEY_ID_MAP;
BEGIN
	g_PROC_NAME := SUBSTR(p_PROC_NAME,1,512);
	g_STEP_NAME := SUBSTR(p_COMPONENT.COMPONENT_NAME,1,64);

	IF p_DATES_ARE_CUT THEN
		v_BEGIN_DATE := p_BEGIN_DATE;
		v_END_DATE := p_END_DATE;
		v_LOCAL_BEGIN_DATE := FROM_CUT(p_BEGIN_DATE, p_TIME_ZONE);
		v_LOCAL_END_DATE := FROM_CUT(p_END_DATE, p_TIME_ZONE);
	ELSE
		v_LOCAL_BEGIN_DATE := p_BEGIN_DATE;
		v_LOCAL_END_DATE := p_END_DATE;
		-- TO_CUT will truncate to the minute when the timestamp indicates one second past midnight because
		-- that is how it distinguishes between the two HE 2s on the 25-hour day - so we must add the second back
		-- to the begin date+time
		v_BEGIN_DATE := TO_CUT(p_BEGIN_DATE, p_TIME_ZONE)+1/86400;
		v_END_DATE := TO_CUT(p_END_DATE, p_TIME_ZONE);
	END IF;

	IF UPPER(p_COMPONENT.RATE_INTERVAL) = 'METER PERIOD' THEN
		v_INTERVAL := c_METER_POINT_INTERVAL_ABBR;
	ELSE
		v_INTERVAL := NVL(GET_INTERVAL_ABBREVIATION(p_COMPONENT.RATE_INTERVAL),'HH');
	END IF;
    IF UPPER(SUBSTR(v_INTERVAL,1,2)) = 'MI' OR UPPER(SUBSTR(v_INTERVAL,1,2)) = 'HH' THEN
    	v_INTERVAL_ENDING := TRUE;
    ELSE
    	v_INTERVAL_ENDING := FALSE;
	END IF;

	-- intialize some variables
	p_CONTEXT(':charge_id') := UT.GET_LITERAL_FOR_NUMBER(p_CHARGE_ID);
	p_CONTEXT(':component') := UT.GET_LITERAL_FOR_NUMBER(p_COMPONENT.COMPONENT_ID);
	p_CONTEXT(':interval') := UT.GET_LITERAL_FOR_STRING(p_COMPONENT.RATE_INTERVAL);

	EVALUATE_ENTITY_REFS(p_COMPONENT.COMPONENT_ID, p_CONTEXT);

	TRACE_CONTEXT('RUN_FORMULA_COMPONENT', p_CONTEXT);

	GATHER_FORMULA_ITERATORS(p_COMPONENT.COMPONENT_ID, v_LOCAL_BEGIN_DATE, v_ITERATORS, FALSE);

	-- run through outer-loops of formula charge evaluation
	--  these include any iterators defined - this will in turn
	--  call FORMULA_DATE_LOOP wherein each charge interval in the
	--  date range is iterated over and has formulas evaluated
    FORMULA_ITERATOR_LOOP(p_CHARGE_ID, p_PRIOR_CHARGE_ID,
		p_COMPONENT.COMPONENT_ID, v_IS_BILL, NULL, v_BEGIN_DATE, v_END_DATE,
		v_LOCAL_BEGIN_DATE, v_LOCAL_END_DATE, NULL, NULL, p_WEEK_BEGIN, p_AS_OF_DATE, p_TIME_ZONE,
		v_INTERVAL_ENDING, p_COMPONENT.RATE_INTERVAL, v_INTERVAL,
        NULL, NULL, NULL, NULL, NULL, v_ITERATORS, v_ITERATORS.FIRST, FALSE,
        v_ITERATOR_NAMES, v_ITERATOR_VALS, 0, 0, v_ITERATOR_ID,
        p_CONTEXT, '', v_ITERATOR_DEPENDS, v_FML_REALMS, v_FML_REALM_WORK_IDs);

	v_ITERATORS.DELETE;
	v_ITERATOR_VALS.DELETE;
	v_ITERATOR_NAMES.DELETE;
	v_ITERATOR_DEPENDS.DELETE;
	v_FML_REALMS.DELETE;

	CLEAN_FML_REALM_WORK_IDs(v_FML_REALM_WORK_IDs);
	v_FML_REALM_WORK_IDs.DELETE;

EXCEPTION
	WHEN OTHERS THEN
		CLEAN_FML_REALM_WORK_IDs(v_FML_REALM_WORK_IDs);
        ERRS.LOG_AND_RAISE;
END RUN_FORMULA_COMPONENT;
----------------------------------------------------------------------------------------------------
-- Logging methods to simplify logging from within formulas. They will reference private
-- package variables, g_PROC_NAME and g_STEP_NAME, for the procedure and step name to use
-- for the log message. These variables are set by RUN_FORMULA_COMPONENT.
FUNCTION LOG_FATAL
	(
	p_EVENT_TEXT IN VARCHAR2,
	p_SOURCE IN VARCHAR2 := NULL
	) RETURN NUMBER AS
BEGIN
	LOGS.LOG_FATAL(p_EVENT_TEXT, g_PROC_NAME, g_STEP_NAME,
					NVL(p_SOURCE, g_SOURCE_NAME));
	RETURN 0;
END LOG_FATAL;
----------------------------------------------------------------------------------------------------
FUNCTION LOG_ERROR
	(
	p_EVENT_TEXT IN VARCHAR2,
	p_SOURCE IN VARCHAR2 := NULL
	) RETURN NUMBER AS
BEGIN
	LOGS.LOG_ERROR(p_EVENT_TEXT, g_PROC_NAME, g_STEP_NAME,
					NVL(p_SOURCE, g_SOURCE_NAME));
	RETURN 0;
END LOG_ERROR;
----------------------------------------------------------------------------------------------------
FUNCTION LOG_WARN
	(
	p_EVENT_TEXT IN VARCHAR2,
	p_SOURCE IN VARCHAR2 := NULL
	) RETURN NUMBER AS
BEGIN
	LOGS.LOG_WARN(p_EVENT_TEXT, g_PROC_NAME, g_STEP_NAME,
					NVL(p_SOURCE, g_SOURCE_NAME));
	RETURN 0;
END LOG_WARN;
----------------------------------------------------------------------------------------------------
FUNCTION LOG_INFO
	(
	p_EVENT_TEXT IN VARCHAR2,
	p_SOURCE IN VARCHAR2 := NULL
	) RETURN NUMBER AS
BEGIN
	LOGS.LOG_INFO(p_EVENT_TEXT, g_PROC_NAME, g_STEP_NAME,
					NVL(p_SOURCE, g_SOURCE_NAME));
	RETURN 0;
END LOG_INFO;
----------------------------------------------------------------------------------------------------
FUNCTION LOG_DEBUG
	(
	p_EVENT_TEXT IN VARCHAR2,
	p_SOURCE IN VARCHAR2 := NULL
	) RETURN NUMBER AS
BEGIN
	LOGS.LOG_DEBUG(p_EVENT_TEXT, g_PROC_NAME, g_STEP_NAME,
					NVL(p_SOURCE, g_SOURCE_NAME));
	RETURN 0;
END LOG_DEBUG;
----------------------------------------------------------------------------------------------------
-- Logs a fatal message and aborts calculation process
FUNCTION DIE
	(
	p_EVENT_TEXT IN VARCHAR2
	) RETURN NUMBER AS
BEGIN
	ERRS.RAISE(MSGCODES.c_ERR_PROCESS_DIED, p_EVENT_TEXT);
	RETURN 0; -- just to make compiler happy - above step will prevent us from actually getting here
END DIE;
----------------------------------------------------------------------------------------------------
-- Alert methods to simplify raising alerts from within formulas
FUNCTION ALERT_FATAL
	(
	p_TRIGGER_VALUE IN VARCHAR2,
	p_ALERT_MESSAGE IN VARCHAR2
	) RETURN NUMBER AS
BEGIN
	ALERTS.TRIGGER_ALERTS(p_TRIGGER_VALUE, LOGS.c_LEVEL_FATAL, p_ALERT_MESSAGE);
	RETURN 0;
END ALERT_FATAL;
----------------------------------------------------------------------------------------------------
FUNCTION ALERT_ERROR
	(
	p_TRIGGER_VALUE IN VARCHAR2,
	p_ALERT_MESSAGE IN VARCHAR2
	) RETURN NUMBER AS
BEGIN
	ALERTS.TRIGGER_ALERTS(p_TRIGGER_VALUE, LOGS.c_LEVEL_ERROR, p_ALERT_MESSAGE);
	RETURN 0;
END ALERT_ERROR;
----------------------------------------------------------------------------------------------------
FUNCTION ALERT_WARN
	(
	p_TRIGGER_VALUE IN VARCHAR2,
	p_ALERT_MESSAGE IN VARCHAR2
	) RETURN NUMBER AS
BEGIN
	ALERTS.TRIGGER_ALERTS(p_TRIGGER_VALUE, LOGS.c_LEVEL_WARN, p_ALERT_MESSAGE);
	RETURN 0;
END ALERT_WARN;
----------------------------------------------------------------------------------------------------
FUNCTION ALERT_NOTICE
	(
	p_TRIGGER_VALUE IN VARCHAR2,
	p_ALERT_MESSAGE IN VARCHAR2
	) RETURN NUMBER AS
BEGIN
	ALERTS.TRIGGER_ALERTS(p_TRIGGER_VALUE, LOGS.c_LEVEL_NOTICE, p_ALERT_MESSAGE);
	RETURN 0;
END ALERT_NOTICE;
----------------------------------------------------------------------------------------------------
-- Returns a collection of all valid context entity IDs for the specified
-- calculation process and time period
FUNCTION GET_ENTITY_IDs_FOR_PROCESS
	(
	p_CALC_PROCESS_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	) RETURN NUMBER_COLLECTION PIPELINED IS
v_DOMAIN_ID CALCULATION_PROCESS.CONTEXT_DOMAIN_ID%TYPE;
v_REALM_ID	CALCULATION_PROCESS.CONTEXT_REALM_ID%TYPE;
v_GROUP_ID	CALCULATION_PROCESS.CONTEXT_GROUP_ID%TYPE;
v_TIME_ZONE	CALCULATION_PROCESS.TIME_ZONE%TYPE;
v_INTERVAL	CALCULATION_PROCESS.PROCESS_INTERVAL%TYPE;
v_WEEK_BEGIN CALCULATION_PROCESS.WEEK_BEGIN%TYPE;
v_WORK_ID	RTO_WORK.WORK_ID%TYPE;
v_BEGIN_DATE DATE;
v_END_DATE	DATE;
BEGIN
	-- query for info about the specified process
	SELECT MAX(CONTEXT_DOMAIN_ID), MAX(CONTEXT_REALM_ID), MAX(CONTEXT_GROUP_ID), MAX(TIME_ZONE), MAX(PROCESS_INTERVAL), MAX(WEEK_BEGIN)
	INTO v_DOMAIN_ID, v_REALM_ID, v_GROUP_ID, v_TIME_ZONE, v_INTERVAL, v_WEEK_BEGIN
	FROM CALCULATION_PROCESS
	WHERE CALC_PROCESS_ID = p_CALC_PROCESS_ID;

	IF NVL(v_DOMAIN_ID,CONSTANTS.NOT_ASSIGNED) <> CONSTANTS.NOT_ASSIGNED THEN
		-- enumerate entities if process has a context domain

		-- we only need to worry about begin and end dates for groups - if process uses context realm,
		-- don't bother since those relationships are not temporal
		IF v_GROUP_ID IS NOT NULL THEN
			IF INTERVAL_IS_ATLEAST_DAILY(v_INTERVAL) THEN
				-- day and greater intervals stored as local dates as 1-second past midnight
				v_BEGIN_DATE := TRUNC(p_BEGIN_DATE);
				v_END_DATE := TRUNC(p_END_DATE);
				-- advance end date to the last day of this last interval
				v_END_DATE := DATE_UTIL.END_DATE_FOR_INTERVAL(v_END_DATE, v_INTERVAL, v_WEEK_BEGIN);
			ELSE
				-- sub-daily intervals are stored as CUT
				v_BEGIN_DATE := TRUNC(TO_CUT(p_BEGIN_DATE, v_TIME_ZONE)-1/86400);
				v_END_DATE := TRUNC(TO_CUT(p_BEGIN_DATE, v_TIME_ZONE)-1/86400);
			END IF;
		END IF;

		SD.ENUMERATE_ENTITIES(TO_NUMBER(NULL), v_DOMAIN_ID, v_WORK_ID, v_REALM_ID, v_GROUP_ID, v_BEGIN_DATE, v_END_DATE, TRUE);

		FOR v_ENTITY IN ENTITY_UTIL.g_cur_ENTITY_IDs(v_WORK_ID) LOOP
			PIPE ROW(v_ENTITY.ENTITY_ID);
		END LOOP;

		UT.PURGE_RTO_WORK(v_WORK_ID);

	END IF;

	RETURN;
END GET_ENTITY_IDs_FOR_PROCESS;
----------------------------------------------------------------------------------------------------
END CALC_ENGINE;
/
