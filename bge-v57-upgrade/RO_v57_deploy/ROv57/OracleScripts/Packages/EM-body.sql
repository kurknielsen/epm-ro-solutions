CREATE OR REPLACE PACKAGE BODY EM AS
---------------------------------------------------------------------------------------------------
g_BALANCING_ASSIGNMENT_TYPE VARCHAR2(32) := 'LoadBalancing';

DEFAULT_EM_SUBTREE VARCHAR2(32) := 'ENTITY_LIST';
DEFAULT_TREE_LIST_PROC VARCHAR2(32) := 'GUI_UTIL.ENTITY_TREE_LIST';
---------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
    RETURN '$Revision: 1.17 $';
END WHAT_VERSION;
----------------------------------------------------------------------------------------------------
PROCEDURE FILTERED_ENTITY_DOMAINS
	(
	p_ALL IN NUMBER,
	p_NOT_ASSIGNED IN NUMBER,
	p_PSEUDO IN NUMBER,
	p_EXCLUDED_DOMAIN IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) IS

BEGIN

	OPEN p_CURSOR FOR
		SELECT '<ALL>' ENTITY_DOMAIN_NAME,
			-1 ENTITY_DOMAIN_ID
		FROM DUAL
		WHERE p_ALL = 1

		UNION ALL

		SELECT ENTITY_DOMAIN_NAME,
			ENTITY_DOMAIN_ID
		FROM (SELECT ENTITY_DOMAIN_NAME,
					ENTITY_DOMAIN_ID
				FROM ENTITY_DOMAIN ED
				WHERE NVL(ED.IS_PSEUDO, 0) <= p_PSEUDO
					AND (p_NOT_ASSIGNED = 1 OR ED.ENTITY_DOMAIN_ID <> 0)
					AND ENTITY_DOMAIN_ID != p_EXCLUDED_DOMAIN
				ORDER BY 1);

END FILTERED_ENTITY_DOMAINS;
----------------------------------------------------------------------------------------------------
PROCEDURE NULL_CURSOR
    (
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
		SELECT NULL FROM DUAL;

END NULL_CURSOR;
----------------------------------------------------------------------------------------------------
PROCEDURE TREE_BRANCHES_ENTITY_MANAGER
	(
	p_REPORT_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the branches for the entity manager tree from the ENTITY_DOMAIN table.
v_WORK_ID	NUMBER;
v_TREE_ID	NUMBER(9);
BEGIN

	v_WORK_ID := SO.ENUMERATE_HIERARCHY(p_REPORT_ID, 1, FALSE, FALSE, FALSE, STRING_COLLECTION('IO Table'));

	-- GET THE TREE'S ID FOR THE SUBTREE FORMULA
	SELECT MIN(SO2.OBJECT_ID) -- GET THE FIRST TREE, ASSUME ITS OUR TREE FILTER
	INTO v_TREE_ID
	FROM SYSTEM_OBJECT SO1, SYSTEM_OBJECT SO2 -- SO1 is the referenced entry, SO2 is the same or corresponding shared object if there is one
	WHERE SO2.OBJECT_CATEGORY = 'Tree'
	START WITH SO1.OBJECT_ID = p_REPORT_ID
		AND SO2.OBJECT_ID = SO.RESOLVE_OBJECT_ID(p_REPORT_ID)
    CONNECT BY PRIOR SO2.OBJECT_CATEGORY <> 'Tree'
		AND SO1.PARENT_OBJECT_ID = PRIOR SO2.OBJECT_ID
		AND SO2.OBJECT_ID = SO.RESOLVE_OBJECT_ID(SO1.OBJECT_ID);

   	-- not stand-alone?
 	 OPEN p_CURSOR FOR
    	   SELECT ENTITY_DOMAIN_CATEGORY "ENTITY_DOMAIN_DESC",
           			 NVL(DISPLAY_NAME,ENTITY_DOMAIN_NAME) "ENTITY_DOMAIN_NAME",
                     ENTITY_DOMAIN_TABLE_ALIAS "ENTITY_TYPE",
                     ENTITY_DOMAIN_ID,
                     NVL(SO.GET_ATTRIBUTE_VAL(W.WORK_XID, 204 /* tree list routine */), DEFAULT_TREE_LIST_PROC) "TREE_LIST_PROC",
					 EM.GET_SUBTREE_FOR_ENTITY_TYPE(ENTITY_DOMAIN_TABLE_ALIAS, v_TREE_ID) "EM_SUBTREE"
    		FROM ENTITY_DOMAIN ED,
				RTO_WORK W
			-- prune nodes to which current user has no select access
    		WHERE (SECURITY_CONTROLS.IS_SUPER_USER=1 OR EXISTS (SELECT 1
						  FROM TABLE(CAST(SECURITY_CONTROLS.CURRENT_ROLES as ID_TABLE)) ROLES,
						  		SYSTEM_ACTION SA, SYSTEM_ACTION_ROLE AR
						  WHERE SA.ACTION_NAME = EN.g_DEFAULT_ACTION_NAME
						  	AND AR.ROLE_ID = ROLES.ID
							AND AR.ACTION_ID = SA.ACTION_ID
							AND AR.ENTITY_DOMAIN_ID = ED.ENTITY_DOMAIN_ID))
				AND ED.ENTITY_DOMAIN_CATEGORY IS NOT NULL
				AND W.WORK_ID = v_WORK_ID
				AND UPPER(W.WORK_DATA) = UPPER(ED.ENTITY_DOMAIN_TABLE_ALIAS)
    		ORDER BY 1,2;

	UT.PURGE_RTO_WORK(v_WORK_ID);

END TREE_BRANCHES_ENTITY_MANAGER;
---------------------------------------------------------------------------------------------------
FUNCTION GET_SUBTREE_FOR_ENTITY_TYPE
	(
	p_ENTITY_TYPE IN VARCHAR2,
	p_TREE_ID IN NUMBER
	) RETURN VARCHAR2 IS

v_TREE_NAME VARCHAR2(256);

v_TREE_ID NUMBER(9);

BEGIN

	v_TREE_ID := SO.RESOLVE_OBJECT_ID(p_TREE_ID);

	SELECT MAX(SO.OBJECT_NAME)
	INTO v_TREE_NAME
		FROM SYSTEM_OBJECT SO
	WHERE SO.PARENT_OBJECT_ID = v_TREE_ID
		AND SO.OBJECT_CATEGORY = 'Tree'
			AND UPPER(SO.OBJECT_NAME) = UPPER(p_ENTITY_TYPE);

	RETURN NVL(v_TREE_NAME, DEFAULT_EM_SUBTREE);

END GET_SUBTREE_FOR_ENTITY_TYPE;
---------------------------------------------------------------------------------------------------
PROCEDURE BILL_CYCLE_PERIODS
	(
	p_BILL_CYCLE_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the CONTRACTs for the given ACCOUNT.

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_BILL_CYCLE_ID, EC.ED_BILL_CYCLE);

	 OPEN p_CURSOR FOR
	    SELECT BILL_CYCLE_ID, BILL_CYCLE_MONTH, BEGIN_DATE, END_DATE, ENTRY_DATE
		FROM BILL_CYCLE_PERIOD
		WHERE	BILL_CYCLE_ID = p_BILL_CYCLE_ID
		ORDER BY 2,3;

END BILL_CYCLE_PERIODS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_BILL_CYCLE_PERIOD
	(
	p_BILL_CYCLE_ID IN NUMBER,
	p_BILL_CYCLE_MONTH IN DATE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_BILL_CYCLE_MONTH IN DATE,
	p_OLD_BEGIN_DATE IN DATE
	)AS

CURSOR c_BILL_CYCLE_PERIOD IS
	SELECT *
	FROM BILL_CYCLE_PERIOD
	WHERE BILL_CYCLE_ID = p_BILL_CYCLE_ID
		AND BILL_CYCLE_MONTH = TRUNC(p_BILL_CYCLE_MONTH,'MM')
	ORDER BY BEGIN_DATE DESC;


v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
v_BILL_CYCLE_PERIOD BILL_CYCLE_PERIOD%ROWTYPE;
v_END_DATE DATE;
v_INITIAL BOOLEAN;
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_BILL_CYCLE_ID, EC.ED_BILL_CYCLE);

	v_KEY_NEW('BILL_CYCLE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_BILL_CYCLE_ID);
    v_KEY_OLD('BILL_CYCLE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_BILL_CYCLE_ID);
	v_KEY_NEW('BILL_CYCLE_MONTH') := UT.GET_LITERAL_FOR_DATE(p_BILL_CYCLE_MONTH);
	v_KEY_OLD('BILL_CYCLE_MONTH') := UT.GET_LITERAL_FOR_DATE(p_OLD_BILL_CYCLE_MONTH);

	UT.PUT_TEMPORAL_DATA_UI('BILL_CYCLE_PERIOD',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

	OPEN c_BILL_CYCLE_PERIOD;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_BILL_CYCLE_PERIOD INTO v_BILL_CYCLE_PERIOD;
		EXIT WHEN c_BILL_CYCLE_PERIOD%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_BILL_CYCLE_PERIOD.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE BILL_CYCLE_PERIOD
		SET END_DATE = GREATEST(v_END_DATE, v_BILL_CYCLE_PERIOD.BEGIN_DATE)
		WHERE BILL_CYCLE_ID = v_BILL_CYCLE_PERIOD.BILL_CYCLE_ID
			AND BILL_CYCLE_MONTH = v_BILL_CYCLE_PERIOD.BILL_CYCLE_MONTH
			AND BEGIN_DATE = v_BILL_CYCLE_PERIOD.BEGIN_DATE;
		v_END_DATE := v_BILL_CYCLE_PERIOD.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_BILL_CYCLE_PERIOD;

END PUT_BILL_CYCLE_PERIOD;
------------------------------------------------------------------------------------------------
PROCEDURE PSE_ESPS
	(
	p_ESP_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the CONTRACTs for the given ACCOUNT.

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ESP_ID, EC.ED_ESP);

	 OPEN p_CURSOR FOR
	    SELECT PSE_ID, BEGIN_DATE, END_DATE, ENTRY_DATE, ESP_ID
		FROM PSE_ESP A
		WHERE ESP_ID = p_ESP_ID
		ORDER BY 2;

END PSE_ESPS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_PSE_ESP
	(
	p_ESP_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_PSE_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE
	)
	AS

CURSOR c_PSE_ESP IS
	SELECT *
	FROM PSE_ESP
	WHERE ESP_ID = p_ESP_ID
	ORDER BY BEGIN_DATE DESC;

v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
v_PSE_ESP PSE_ESP%ROWTYPE;
v_END_DATE DATE;
v_INITIAL BOOLEAN;

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ESP_ID, EC.ED_ESP);

	v_KEY_NEW('ESP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_ESP_ID);
    v_KEY_OLD('ESP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_ESP_ID);
	v_KEY_NEW('PSE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_PSE_ID);
	v_KEY_OLD('PSE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_PSE_ID);

	UT.PUT_TEMPORAL_DATA_UI('PSE_ESP',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
			);

	OPEN c_PSE_ESP;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_PSE_ESP INTO v_PSE_ESP;
		EXIT WHEN c_PSE_ESP%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_PSE_ESP.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE PSE_ESP
		SET END_DATE = GREATEST(v_END_DATE, v_PSE_ESP.BEGIN_DATE)
		WHERE ESP_ID = v_PSE_ESP.ESP_ID
			AND PSE_ID = v_PSE_ESP.PSE_ID
			AND BEGIN_DATE = v_PSE_ESP.BEGIN_DATE;
		v_END_DATE := v_PSE_ESP.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_PSE_ESP;

END PUT_PSE_ESP;

------------------------------------------------------------------------------------------------
PROCEDURE PSE_CUSTOM_INVOICES
	(
	p_PSE_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the CONTRACTs for the given ACCOUNT.

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_PSE_ID, EC.ED_PSE);

	 OPEN p_CURSOR FOR
	    SELECT PSE_ID, BEGIN_DATE, END_DATE, ENTRY_DATE
		FROM PSE_CUSTOM_INVOICE A
		WHERE PSE_ID = p_PSE_ID
		ORDER BY 2;

END PSE_CUSTOM_INVOICES;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_PSE_CUSTOM_INVOICE
	(
	p_PSE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_PSE_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE
	)
	AS

CURSOR c_PSE_CUSTOM_INVOICE IS
	SELECT *
	FROM PSE_CUSTOM_INVOICE
	WHERE PSE_ID = p_PSE_ID
	ORDER BY BEGIN_DATE DESC;

v_PSE_ID VARCHAR2(9);
v_OLD_PSE_ID VARCHAR2(9);
v_PSE_CUSTOM_INVOICE PSE_CUSTOM_INVOICE%ROWTYPE;
v_END_DATE DATE;
v_INITIAL BOOLEAN;

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_PSE_ID, EC.ED_PSE);

	v_END_DATE := NULL_DATE(p_END_DATE);
	v_PSE_ID := UT.GET_LITERAL_FOR_NUMBER(p_PSE_ID);
	v_OLD_PSE_ID := UT.GET_LITERAL_FOR_NUMBER(p_OLD_PSE_ID);

	UT.PUT_TEMPORAL_DATA_UI('PSE_CUSTOM_INVOICE',
						p_BEGIN_DATE,
						p_END_DATE,
						p_OLD_BEGIN_DATE,
						TRUE,
						'PSE_ID',
						v_PSE_ID,
						v_OLD_PSE_ID,
						TRUE
			);

	OPEN c_PSE_CUSTOM_INVOICE;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_PSE_CUSTOM_INVOICE INTO v_PSE_CUSTOM_INVOICE;
		EXIT WHEN c_PSE_CUSTOM_INVOICE%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_PSE_CUSTOM_INVOICE.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE PSE_CUSTOM_INVOICE
		SET END_DATE = GREATEST(v_END_DATE, v_PSE_CUSTOM_INVOICE.BEGIN_DATE)
		WHERE PSE_ID = v_PSE_CUSTOM_INVOICE.PSE_ID
			AND BEGIN_DATE = v_PSE_CUSTOM_INVOICE.BEGIN_DATE;
		v_END_DATE := v_PSE_CUSTOM_INVOICE.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_PSE_CUSTOM_INVOICE;

END PUT_PSE_CUSTOM_INVOICE;

----------------------------------------------------------------------------------------------------
PROCEDURE ESP_POOLS
	(
	p_POOL_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the ESPS FOR THE GIVEN POOL

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_POOL_ID, EC.ED_POOL);

	 OPEN p_CURSOR FOR
	   SELECT ESP_ID, ALLOCATION_PCT, BEGIN_DATE, END_DATE, ENTRY_DATE, POOL_ID
		FROM ESP_POOL
		WHERE POOL_ID = p_POOL_ID
		ORDER BY 3;

END ESP_POOLS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_ESP_POOL
	(
	p_POOL_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_ALLOCATION_PCT IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_ESP_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE
	)
	AS

v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
v_ESP_POOL ESP_POOL%ROWTYPE;
v_END_DATE DATE;
v_INITIAL BOOLEAN;

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_POOL_ID, EC.ED_POOL);

	v_KEY_NEW('POOL_ID') := UT.GET_LITERAL_FOR_NUMBER(p_POOL_ID);
	v_KEY_OLD('POOL_ID') := UT.GET_LITERAL_FOR_NUMBER(p_POOL_ID);
    v_KEY_NEW('ESP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_ESP_ID);
	v_KEY_OLD('ESP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_ESP_ID);
    v_DATA('ALLOCATION_PCT') := UT.GET_LITERAL_FOR_NUMBER(p_ALLOCATION_PCT);

    UT.PUT_TEMPORAL_DATA_UI('ESP_POOL',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
			);

END PUT_ESP_POOL;
----------------------------------------------------------------------------------------------------
PROCEDURE POOL_SUB_POOLS
	(
	p_POOL_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the Sub-Pools FOR THE GIVEN POOL

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_POOL_ID, EC.ED_POOL);

	 OPEN p_CURSOR FOR
	   SELECT SUB_POOL_ID, ALLOCATION_PCT, BEGIN_DATE, END_DATE, ENTRY_DATE, POOL_ID
		FROM POOL_SUB_POOL
		WHERE POOL_ID = p_POOL_ID
		ORDER BY 3;

END POOL_SUB_POOLS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_POOL_SUB_POOL
	(
	p_POOL_ID IN NUMBER,
	p_SUB_POOL_ID IN NUMBER,
	p_ALLOCATION_PCT IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_SUB_POOL_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE
	)
	AS

v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_POOL_ID, EC.ED_POOL);

    v_KEY_NEW('POOL_ID') := UT.GET_LITERAL_FOR_NUMBER(p_POOL_ID);
    v_KEY_OLD('POOL_ID') := UT.GET_LITERAL_FOR_NUMBER(p_POOL_ID);
    v_KEY_NEW('SUB_POOL_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SUB_POOL_ID);
    v_KEY_OLD('SUB_POOL_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_SUB_POOL_ID);
    v_DATA('ALLOCATION_PCT') := UT.GET_LITERAL_FOR_NUMBER(p_ALLOCATION_PCT);

    UT.PUT_TEMPORAL_DATA_UI('POOL_SUB_POOL',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

END PUT_POOL_SUB_POOL;
----------------------------------------------------------------------------------------------------
PROCEDURE EDC_RATE_CLASSS
	(
	p_EDC_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the ESPS FOR THE GIVEN POOL

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_EDC_ID, EC.ED_EDC);

	 OPEN p_CURSOR FOR
	    SELECT A.RATE_CLASS, A.EDC_ID
		FROM EDC_RATE_CLASS A
		WHERE EDC_ID = p_EDC_ID
		ORDER BY 1;

END EDC_RATE_CLASSS;
---------------------------------------------------------------------------------------------------

PROCEDURE PUT_EDC_RATE_CLASS
	(
	p_EDC_ID IN NUMBER,
	p_RATE_CLASS IN VARCHAR,
	p_OLD_RATE_CLASS IN VARCHAR
	)
	AS

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_EDC_ID, EC.ED_EDC);


-- UPDATE THE CURRENT ASSIGNMENT IF ONE EXISTS

	UPDATE EDC_RATE_CLASS SET
		RATE_CLASS = LTRIM(RTRIM(NVL(p_RATE_CLASS,GA.UNDEFINED_ATTRIBUTE)))
	WHERE EDC_ID = p_EDC_ID
		AND LTRIM(RTRIM(UPPER(RATE_CLASS))) = LTRIM(RTRIM(UPPER(p_OLD_RATE_CLASS)));

-- NO ASSIGNMENT UPDATE FOR THIS COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO EDC_RATE_CLASS
			(
			EDC_ID,
			RATE_CLASS
			)
		VALUES
			(
			p_EDC_ID,
			LTRIM(RTRIM(NVL(p_RATE_CLASS,GA.UNDEFINED_ATTRIBUTE)))
			);
	END IF;

END PUT_EDC_RATE_CLASS;
---------------------------------------------------------------------------------------------------
PROCEDURE EDC_LOSS_FACTORS
	(
	p_EDC_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the CASE LABELS for the given CATEGORY

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_EDC_ID, EC.ED_EDC);


	OPEN p_CURSOR FOR
	   SELECT A.CASE_ID, A.BEGIN_DATE, A.END_DATE, A.LOSS_FACTOR_ID, A.ENTRY_DATE, A.EDC_ID
		FROM EDC_LOSS_FACTOR A
		WHERE A.EDC_ID = p_EDC_ID
		ORDER BY 2;

END EDC_LOSS_FACTORS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_EDC_LOSS_FACTOR
	(
	p_EDC_ID IN NUMBER,
	p_CASE_ID IN NUMBER,
	p_LOSS_FACTOR_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_CASE_ID IN NUMBER,
	p_OLD_LOSS_FACTOR_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE
	)
	AS

CURSOR c_EDC_LOSS_FACTOR IS
	SELECT *
	FROM EDC_LOSS_FACTOR
	WHERE EDC_ID = p_EDC_ID
		AND CASE_ID = p_CASE_ID
	ORDER BY BEGIN_DATE DESC;

v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
v_EDC_LOSS_FACTOR EDC_LOSS_FACTOR%ROWTYPE;
v_END_DATE DATE;
v_INITIAL BOOLEAN;

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_EDC_ID, EC.ED_EDC);

	v_END_DATE := NULL_DATE(p_END_DATE);

	v_KEY_NEW('EDC_ID') := UT.GET_LITERAL_FOR_NUMBER(p_EDC_ID);
    v_KEY_OLD('EDC_ID') := UT.GET_LITERAL_FOR_NUMBER(p_EDC_ID);
	v_KEY_NEW('CASE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_CASE_ID);
	v_KEY_OLD('CASE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_CASE_ID);
	v_KEY_NEW('LOSS_FACTOR_ID') := UT.GET_LITERAL_FOR_NUMBER(p_LOSS_FACTOR_ID);
	v_KEY_OLD('LOSS_FACTOR_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_LOSS_FACTOR_ID);

	UT.PUT_TEMPORAL_DATA_UI('EDC_LOSS_FACTOR',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
			);

	OPEN c_EDC_LOSS_FACTOR;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_EDC_LOSS_FACTOR INTO v_EDC_LOSS_FACTOR;
		EXIT WHEN c_EDC_LOSS_FACTOR%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_EDC_LOSS_FACTOR.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE EDC_LOSS_FACTOR
		SET END_DATE = GREATEST(v_END_DATE, v_EDC_LOSS_FACTOR.BEGIN_DATE)
		WHERE EDC_ID = v_EDC_LOSS_FACTOR.EDC_ID
			AND CASE_ID = v_EDC_LOSS_FACTOR.CASE_ID
			AND LOSS_FACTOR_ID = v_EDC_LOSS_FACTOR.LOSS_FACTOR_ID
			AND BEGIN_DATE = v_EDC_LOSS_FACTOR.BEGIN_DATE;
		v_END_DATE := v_EDC_LOSS_FACTOR.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_EDC_LOSS_FACTOR;

END PUT_EDC_LOSS_FACTOR;

---------------------------------------------------------------------------------------------------
PROCEDURE SYSTEM_LOAD_AREAS
	(
	p_SYSTEM_LOAD_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the SYSTEM_LOAD_AREA's for the given SYSTEM_LOAD.

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_SYSTEM_LOAD_ID, EC.ED_SYSTEM_LOAD);

	OPEN p_CURSOR FOR
	    SELECT A.SYSTEM_LOAD_ID,
			A.AREA_ID,
			A.OPERATION_CODE
		FROM SYSTEM_LOAD_AREA A
		WHERE A.SYSTEM_LOAD_ID = p_SYSTEM_LOAD_ID;

END SYSTEM_LOAD_AREAS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_SYSTEM_LOAD_AREA
	(
	p_SYSTEM_LOAD_ID IN NUMBER,
	p_AREA_ID IN NUMBER,
	p_OPERATION_CODE IN CHAR,
	p_OLD_AREA_ID IN NUMBER
	)
	AS

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_SYSTEM_LOAD_ID, EC.ED_SYSTEM_LOAD);


-- UPDATE THE CURRENT ASSIGNMENT IF ONE EXISTS

	UPDATE SYSTEM_LOAD_AREA SET
		AREA_ID = p_AREA_ID,
		OPERATION_CODE = NVL(p_OPERATION_CODE,GA.UNDEFINED_ATTRIBUTE)
	WHERE SYSTEM_LOAD_ID = p_SYSTEM_LOAD_ID
		AND AREA_ID = p_OLD_AREA_ID;

-- NO ASSIGNMENT UPDATE FOR THIS  COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO SYSTEM_LOAD_AREA
			(
			SYSTEM_LOAD_ID,
			AREA_ID,
			OPERATION_CODE
			)
		VALUES
			(
			p_SYSTEM_LOAD_ID,
			p_AREA_ID,
			NVL(p_OPERATION_CODE,GA.UNDEFINED_ATTRIBUTE)
			);
	END IF;


END PUT_SYSTEM_LOAD_AREA;
----------------------------------------------------------------------------------------------------
PROCEDURE EDC_CONVERSION_FACTORS
	(
	p_EDC_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the CONTRACTs for the given EDC.

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_EDC_ID, EC.ED_EDC);

	 OPEN p_CURSOR FOR
	    SELECT A.SERVICE_AREA_ID,
			A.FACTOR_CODE,
			A.BEGIN_DATE,
			A.END_DATE,
			A.FACTOR_VAL,
			A.ENTRY_DATE
		FROM EDC_CONVERSION_FACTOR A
		WHERE	A.EDC_ID = p_EDC_ID
		ORDER BY 4 DESC, 2 ASC;

END EDC_CONVERSION_FACTORS;
---------------------------------------------------------------------------------------------------

PROCEDURE PUT_EDC_CONVERSION_FACTOR
	(
	p_EDC_ID IN NUMBER,
	p_SERVICE_AREA_ID IN NUMBER,
	p_FACTOR_CODE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_FACTOR_VAL IN NUMBER,
	p_OLD_SERVICE_AREA_ID IN NUMBER,
	p_OLD_FACTOR_CODE IN CHAR,
	p_OLD_BEGIN_DATE IN DATE
	)
	AS

-- CURSOR c_EDC_CONVERSION_FACTOR IS
-- 	SELECT *
-- 	FROM EDC_CONVERSION_FACTOR
-- 	WHERE EDC_ID = p_EDC_ID
-- 			AND SERVICE_AREA_ID = p_SERVICE_AREA_ID
-- 	ORDER BY BEGIN_DATE DESC;
--
-- v_EDC_CONVERSION_FACTOR EDC_CONVERSION_FACTOR%ROWTYPE;

v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
v_END_DATE DATE;
v_FACTOR_CODE CHAR(1);

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_EDC_ID, EC.ED_EDC);

	v_END_DATE := NULL_DATE(p_END_DATE);
	v_FACTOR_CODE := SUBSTR(p_FACTOR_CODE, 1, 1);

	v_KEY_NEW('EDC_ID') := UT.GET_LITERAL_FOR_NUMBER(p_EDC_ID);
    v_KEY_OLD('EDC_ID') := UT.GET_LITERAL_FOR_NUMBER(p_EDC_ID);
	v_KEY_NEW('SERVICE_AREA_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SERVICE_AREA_ID);
	v_KEY_OLD('SERVICE_AREA_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_SERVICE_AREA_ID);
	v_KEY_NEW('FACTOR_CODE') := UT.GET_LITERAL_FOR_STRING(v_FACTOR_CODE);
	v_KEY_OLD('FACTOR_CODE') := UT.GET_LITERAL_FOR_STRING(p_OLD_FACTOR_CODE);

	v_DATA('FACTOR_VAL') := UT.GET_LITERAL_FOR_NUMBER(p_FACTOR_VAL);

	UT.PUT_TEMPORAL_DATA_UI('EDC_CONVERSION_FACTOR',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
			);

END PUT_EDC_CONVERSION_FACTOR;
----------------------------------------------------------------------------------------------------
PROCEDURE STATION_PARAMETERS
	(
	p_STATION_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the WEATHER_STATION_PARAMETERS's for the given STATION.

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_STATION_ID, EC.ED_WEATHER_STATION);

	OPEN p_CURSOR FOR
	    SELECT A.PARAMETER_ID,
	    	B.PARAMETER_NAME,
	    	1 "IS_SELECTED",
			A.STATION_ID
		FROM WEATHER_STATION_PARAMETER A, WEATHER_PARAMETER B
		WHERE A.STATION_ID = p_STATION_ID
			AND A.PARAMETER_ID = B.PARAMETER_ID
			AND A.PARAMETER_ID > 0

		UNION

		SELECT PARAMETER_ID,
			PARAMETER_NAME,
			0 "IS_SELECTED",
			p_STATION_ID "STATION_ID"
		FROM WEATHER_PARAMETER
		WHERE NOT PARAMETER_ID IN (SELECT PARAMETER_ID
									FROM WEATHER_STATION_PARAMETER
									WHERE STATION_ID = p_STATION_ID)
			AND PARAMETER_ID > 0

		ORDER BY 3 DESC, 2 ASC;

END STATION_PARAMETERS;
---------------------------------------------------------------------------------------------------


PROCEDURE PUT_STATION_PARAMETER
	(
	p_STATION_ID IN NUMBER,
	p_PARAMETER_ID IN NUMBER,
	p_IS_SELECTED IN NUMBER
	)
	AS

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_STATION_ID, EC.ED_WEATHER_STATION);


	--DELETE THE CURRENT ASSIGNMENT IF NOT SELECTED.
	IF p_IS_SELECTED = 0 THEN
		DELETE FROM WEATHER_STATION_PARAMETER
		WHERE STATION_ID = p_STATION_ID
			AND PARAMETER_ID = p_PARAMETER_ID;
	ELSE
	-- UPDATE THE CURRENT ACCOUNT ANCILLARY_SERVICE ASSIGNMENT IF ONE EXISTS

		UPDATE WEATHER_STATION_PARAMETER SET
			PARAMETER_ID = p_PARAMETER_ID
		WHERE STATION_ID = p_STATION_ID
			AND PARAMETER_ID = p_PARAMETER_ID;

	-- NO ASSIGNMENT UPDATE FOR THIS ACCOUNT AND ANCILLARY_SERVICE COMBINATION SO INSERT A NEW ASSIGNMENT

		IF SQL%NOTFOUND THEN
			INSERT INTO WEATHER_STATION_PARAMETER
				(
				STATION_ID,
				PARAMETER_ID
				)
			VALUES
				(
				p_STATION_ID,
				p_PARAMETER_ID
				);
		END IF;
	END IF;

END PUT_STATION_PARAMETER;
---------------------------------------------------------------------------------------------------

PROCEDURE STATION_COMPOSITES
	(
	p_STATION_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	)  AS

-- Answer the WEATHER_STATION_COMPOSITE's for the given STATION.

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_STATION_ID, EC.ED_WEATHER_STATION);

	OPEN p_CURSOR FOR
	    SELECT A.COMPOSITE_STATION_ID,
	    	B.STATION_NAME "COMPOSITE_STATION_NAME",
	    	A.COMPOSITE_PERCENT,
	    	1 "IS_SELECTED",
			A.STATION_ID
		FROM WEATHER_STATION_COMPOSITE A, WEATHER_STATION B
		WHERE A.STATION_ID = p_STATION_ID
			AND A.COMPOSITE_STATION_ID = B.STATION_ID
			AND A.STATION_ID > 0

		UNION

		SELECT STATION_ID "COMPOSITE_STATION_ID",
			STATION_NAME "COMPOSITE_STATION_NAME",
			0 "COMPOSITE_PERCENT",
			0 "IS_SELECTED",
			p_STATION_ID "STATION_ID"
		FROM WEATHER_STATION
		WHERE IS_COMPOSITE = 0
			AND NOT STATION_ID IN (SELECT COMPOSITE_STATION_ID
									FROM WEATHER_STATION_COMPOSITE
									WHERE STATION_ID = p_STATION_ID)
			AND NOT STATION_ID = p_STATION_ID
			AND STATION_ID > 0

		ORDER BY 4 DESC, 2 ASC;


END STATION_COMPOSITES;
---------------------------------------------------------------------------------------------------

PROCEDURE PUT_STATION_COMPOSITE
	(
	p_STATION_ID IN NUMBER,
	p_COMPOSITE_STATION_ID IN NUMBER,
	p_COMPOSITE_PERCENT IN NUMBER,
	p_IS_SELECTED IN NUMBER
	)
	AS

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_STATION_ID, EC.ED_WEATHER_STATION);


-- IF THIS ASSIGNMENT IS NOT SELECTED, DELETE IT.
	IF p_IS_SELECTED = 0 THEN
		DELETE FROM WEATHER_STATION_COMPOSITE
		WHERE STATION_ID = p_STATION_ID
			AND COMPOSITE_STATION_ID = p_COMPOSITE_STATION_ID;
	ELSE


	-- UPDATE THE CURRENT ASSIGNMENT IF ONE EXISTS

		UPDATE WEATHER_STATION_COMPOSITE SET
			COMPOSITE_PERCENT = p_COMPOSITE_PERCENT
		WHERE STATION_ID = p_STATION_ID
			AND COMPOSITE_STATION_ID = p_COMPOSITE_STATION_ID;

	-- NO ASSIGNMENT UPDATE FOR THIS ACCOUNT AND ANCILLARY_SERVICE COMBINATION SO INSERT A NEW ASSIGNMENT

		IF SQL%NOTFOUND THEN
			INSERT INTO WEATHER_STATION_COMPOSITE
				(
				STATION_ID,
				COMPOSITE_STATION_ID,
				COMPOSITE_PERCENT
				)
			VALUES
				(
				p_STATION_ID,
				p_COMPOSITE_STATION_ID,
				p_COMPOSITE_PERCENT
				);
		END IF;

	END IF;

END PUT_STATION_COMPOSITE;
---------------------------------------------------------------------------------------------------
PROCEDURE PARAMETER_COMPOSITES
	(
	p_PARAMETER_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	)  AS

-- Answer the WEATHER_PARAMETER_COMPOSITE's for the given PARAMETER.

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_PARAMETER_ID, EC.ED_WEATHER_PARAMETER);

	OPEN p_CURSOR FOR
	    SELECT A.COMPOSITE_PARAMETER_ID,
	    	B.PARAMETER_NAME "COMPOSITE_PARAMETER_NAME",
	    	A.COMPOSITE_COEFFICIENT,
	    	1 "IS_SELECTED",
			A.PARAMETER_ID
		FROM WEATHER_PARAMETER_COMPOSITE A, WEATHER_PARAMETER B
		WHERE A.PARAMETER_ID = p_PARAMETER_ID
			AND A.COMPOSITE_PARAMETER_ID = B.PARAMETER_ID
			AND A.PARAMETER_ID > 0

		UNION

		SELECT PARAMETER_ID "COMPOSITE_PARAMETER_ID",
			PARAMETER_NAME "COMPOSITE_PARAMETER_NAME",
			0 "COMPOSITE_COEFFICIENT",
			0 "IS_SELECTED",
			p_PARAMETER_ID "PARAMETER_ID"
		FROM WEATHER_PARAMETER
		WHERE IS_COMPOSITE = 0
			AND NOT PARAMETER_ID IN (SELECT COMPOSITE_PARAMETER_ID
									FROM WEATHER_PARAMETER_COMPOSITE
									WHERE PARAMETER_ID = p_PARAMETER_ID)
			AND NOT PARAMETER_ID = p_PARAMETER_ID
			AND PARAMETER_ID > 0

		ORDER BY 4 DESC, 2 ASC;


END PARAMETER_COMPOSITES;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_PARAMETER_COMPOSITE
	(
	p_PARAMETER_ID IN NUMBER,
	p_COMPOSITE_PARAMETER_ID IN NUMBER,
	p_COMPOSITE_COEFFICIENT IN NUMBER,
	p_IS_SELECTED IN NUMBER
	)
	AS

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_PARAMETER_ID, EC.ED_WEATHER_PARAMETER);


	--DELETE THE EXISTING ASSIGNMENT IF NOT SELECTED.
	IF p_IS_SELECTED = 0 THEN
		DELETE FROM WEATHER_PARAMETER_COMPOSITE
		WHERE PARAMETER_ID = p_PARAMETER_ID
			AND COMPOSITE_PARAMETER_ID = p_COMPOSITE_PARAMETER_ID;

	ELSE
	-- UPDATE THE CURRENT ASSIGNMENT IF ONE EXISTS

		UPDATE WEATHER_PARAMETER_COMPOSITE SET
			COMPOSITE_COEFFICIENT = p_COMPOSITE_COEFFICIENT
		WHERE PARAMETER_ID = p_PARAMETER_ID
			AND COMPOSITE_PARAMETER_ID = p_COMPOSITE_PARAMETER_ID;

	-- NO ASSIGNMENT UPDATE FOR THIS ACCOUNT AND ANCILLARY_SERVICE COMBINATION SO INSERT A NEW ASSIGNMENT

		IF SQL%NOTFOUND THEN
			INSERT INTO WEATHER_PARAMETER_COMPOSITE
				(
				PARAMETER_ID,
				COMPOSITE_PARAMETER_ID,
				COMPOSITE_COEFFICIENT
				)
			VALUES
				(
				p_PARAMETER_ID,
				p_COMPOSITE_PARAMETER_ID,
				p_COMPOSITE_COEFFICIENT
				);
		END IF;
	END IF;

END PUT_PARAMETER_COMPOSITE;
----------------------------------------------------------------------------------------------------
PROCEDURE PATH_PROVIDERS
	(
   p_PATH_ID IN NUMBER,
   p_CURSOR OUT GA.REFCURSOR
   ) AS
-- ANSWER A RECORDSET CONTAINING THE LEGS FOR THE GIVEN PATH ID
BEGIN

        OPEN p_CURSOR FOR
                SELECT PATH_ID,
					 	LEG_NBR,
						CA_ID,
						TP_ID,
						PSE_ID,
						TP_PRODUCT_CODE,
						TP_PATH_NAME,
						TP_ASSIGNMENT_REF,
						TP_PRODUCT_LEVEL,
						MISC_INFO,
						MISC_REF,
						ENTRY_DATE
                FROM PATH_PROVIDER
                WHERE PATH_ID = p_PATH_ID
                ORDER BY LEG_NBR;

END PATH_PROVIDERS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_PATH_PROVIDER
	(
   p_PATH_ID IN NUMBER,
   p_LEG_NBR IN NUMBER,
   p_CA_ID IN NUMBER,
   p_TP_ID IN NUMBER,
   p_PSE_ID IN NUMBER,
   p_TP_PRODUCT_CODE IN VARCHAR2,
   p_TP_PATH_NAME IN VARCHAR2,
   p_TP_ASSIGNMENT_REF IN VARCHAR2,
   p_TP_PRODUCT_LEVEL IN VARCHAR2,
   p_MISC_INFO IN VARCHAR2,
   p_MISC_REF IN VARCHAR2
	) AS
-- CREATE OR UPDATE A PROVIDER_PATH LEG FOR A TX_PATH
v_COUNT NUMBER;
BEGIN

        SELECT COUNT(*)
        INTO v_COUNT
        FROM PATH_PROVIDER
        WHERE PATH_ID = p_PATH_ID AND
              LEG_NBR = p_LEG_NBR;
-- UPDATE EXISTING RECORD
        IF v_COUNT > 0 THEN
                UPDATE PATH_PROVIDER SET
                        PATH_ID = p_PATH_ID,
                        LEG_NBR = p_LEG_NBR,
                        CA_ID = p_CA_ID,
                        TP_ID = p_TP_ID,
                        PSE_ID = p_PSE_ID,
                        TP_PRODUCT_CODE = p_TP_PRODUCT_CODE,
                        TP_PATH_NAME = p_TP_PATH_NAME,
                        TP_ASSIGNMENT_REF = p_TP_ASSIGNMENT_REF,
                        TP_PRODUCT_LEVEL = p_TP_PRODUCT_LEVEL,
                        MISC_INFO = p_MISC_INFO,
                        MISC_REF = p_MISC_REF,
                        ENTRY_DATE = SYSDATE
                WHERE PATH_ID = p_PATH_ID AND
                      LEG_NBR = p_LEG_NBR;
        ELSE
-- INSERT A NEW RECORD
                INSERT INTO PATH_PROVIDER (
                        PATH_ID,
                        LEG_NBR,
                        CA_ID,
                        TP_ID,
                        PSE_ID,
                        TP_PRODUCT_CODE,
                        TP_PATH_NAME,
                        TP_ASSIGNMENT_REF,
                        TP_PRODUCT_LEVEL,
                        MISC_INFO,
                        MISC_REF,
                        ENTRY_DATE)
                VALUES (p_PATH_ID,
                        p_LEG_NBR,
                        p_CA_ID,
                        p_TP_ID,
                        p_PSE_ID,
                        p_TP_PRODUCT_CODE,
                        p_TP_PATH_NAME,
                        p_TP_ASSIGNMENT_REF,
                        p_TP_PRODUCT_LEVEL,
                        p_MISC_INFO,
                        p_MISC_REF,
                        SYSDATE);
	END IF;
	EXCEPTION
		WHEN OTHERS THEN
			RAISE;
END PUT_PATH_PROVIDER;
----------------------------------------------------------------------------------------------------
PROCEDURE CUSTOMER_AGGREGATE_ACCOUNTS
	(
	p_CUSTOMER_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_CUSTOMER_ID, EC.ED_CUSTOMER);

	OPEN p_CURSOR FOR
		  SELECT A.AGGREGATE_ID, B.ACCOUNT_ID, A.BEGIN_DATE, A.END_DATE, B.ESP_ID, B.POOL_ID, C.EDC_RATE_CLASS, C.EDC_STRATA, A.ENTRY_DATE
		  FROM AGGREGATE_ACCOUNT_CUSTOMER A, AGGREGATE_ACCOUNT_ESP B, ACCOUNT_EDC C
		  WHERE CUSTOMER_ID = p_CUSTOMER_ID
		  		AND B.AGGREGATE_ID = A.AGGREGATE_ID
				AND B.BEGIN_DATE <= NVL(A.END_DATE, HIGH_DATE)
				AND NVL(B.END_DATE, HIGH_DATE) >= A.BEGIN_DATE
				AND C.ACCOUNT_ID = B.ACCOUNT_ID
				AND C.BEGIN_DATE <= NVL(A.END_DATE, HIGH_DATE)
				AND NVL(C.END_DATE, HIGH_DATE) >= A.BEGIN_DATE
		  ORDER BY 3;

END CUSTOMER_AGGREGATE_ACCOUNTS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_CUSTOMER_AGGREGATE_ACCOUNT
	(
	p_CUSTOMER_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_AGGREGATE_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE
	) AS
v_AGGREGATE_ID NUMBER(9);
v_END_DATE DATE := NULL_DATE(p_END_DATE);
v_COUNT NUMBER;
v_POOL_ID NUMBER(9) := NVL(p_POOL_ID, 0);
v_STATUS NUMBER;
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_CUSTOMER_ID, EC.ED_CUSTOMER);


--DETERMINE IF THE AGGREGATE_ID EXISTS.
	SELECT COUNT(*)
		INTO v_COUNT
		FROM AGGREGATE_ACCOUNT_ESP
		WHERE ACCOUNT_ID = p_ACCOUNT_ID
			AND ESP_ID = p_ESP_ID
			AND POOL_ID = v_POOL_ID
			AND BEGIN_DATE <= NVL(v_END_DATE,HIGH_DATE)
			AND NVL(END_DATE,HIGH_DATE) >= p_BEGIN_DATE;

--CREATE IT IF IT DOESN'T.
	IF v_COUNT < 1 THEN
  		 RA.PUT_AGGREGATE_ACCOUNT_ESP(p_ACCOUNT_ID, p_ESP_ID, v_POOL_ID, p_BEGIN_DATE, p_END_DATE, p_ESP_ID, v_POOL_ID, p_BEGIN_DATE, v_STATUS);
		 ERRS.VALIDATE_STATUS('RA.PUT_AGGREGATE_ACCOUNT_ESP', v_STATUS);
	ELSIF v_COUNT > 1 THEN
		ERRS.RAISE_BAD_DATE_RANGE(p_BEGIN_DATE,p_END_DATE);
	END IF;

	SELECT AGGREGATE_ID
	INTO v_AGGREGATE_ID
	FROM AGGREGATE_ACCOUNT_ESP
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND ESP_ID = p_ESP_ID
		AND POOL_ID = v_POOL_ID
		AND BEGIN_DATE <= NVL(v_END_DATE,HIGH_DATE)
		AND NVL(END_DATE, HIGH_DATE) >= p_BEGIN_DATE;

-- UPDATE AN EXISTING RECORD
	UPDATE AGGREGATE_ACCOUNT_CUSTOMER SET
		AGGREGATE_ID = v_AGGREGATE_ID,
		BEGIN_DATE = p_BEGIN_DATE,
		END_DATE = v_END_DATE,
		ENTRY_DATE = SYSDATE
	WHERE CUSTOMER_ID = p_CUSTOMER_ID
		AND AGGREGATE_ID = p_OLD_AGGREGATE_ID
		AND BEGIN_DATE = p_OLD_BEGIN_DATE;

-- IF THE PREVIOUS UPDATE DID NOT FIND A MATCH, THEN INSERT A NEW RECORD.
	IF SQL%NOTFOUND THEN
		INSERT INTO AGGREGATE_ACCOUNT_CUSTOMER (
			AGGREGATE_ID,
			CUSTOMER_ID,
			BEGIN_DATE,
			END_DATE,
			ENTRY_DATE)
		VALUES (
			v_AGGREGATE_ID,
			p_CUSTOMER_ID,
			p_BEGIN_DATE,
			v_END_DATE,
			SYSDATE);
	END IF;

END PUT_CUSTOMER_AGGREGATE_ACCOUNT;
---------------------------------------------------------------------------------------------------
PROCEDURE CONTACT_PHONE_NUMBERS
	(
	p_CONTACT_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_CONTACT_ID, EC.ED_CONTACT);

	OPEN p_CURSOR FOR
	   SELECT A.VALUE as PHONE_TYPE, B.PHONE_NUMBER, B.ENTRY_DATE
		FROM SYSTEM_LABEL A, PHONE_NUMBER B
		WHERE A.MODEL_ID = CONSTANTS.GLOBAL_MODEL
			AND A.MODULE = 'Entity Manager'
			AND A.KEY1 = 'Contact'
			AND A.KEY2 = 'Phone Types'
			AND A.KEY3 = '?'
			AND B.PHONE_TYPE(+) = A.VALUE
			AND B.CONTACT_ID(+) = p_CONTACT_ID
		ORDER BY A.POSITION;

END CONTACT_PHONE_NUMBERS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_CONTACT_PHONE_NUMBER
	(
	p_CONTACT_ID IN NUMBER,
	p_PHONE_TYPE IN VARCHAR2,
	p_PHONE_NUMBER IN VARCHAR2
	) AS

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_CONTACT_ID, EC.ED_CONTACT);

	IF p_PHONE_NUMBER IS NULL THEN
		DX.REMOVE_CONTACT_PHONE_NUMBER(p_CONTACT_ID, p_PHONE_TYPE);
	ELSE
		UPDATE PHONE_NUMBER SET
			PHONE_NUMBER = p_PHONE_NUMBER,
			ENTRY_DATE = SYSDATE
		WHERE CONTACT_ID = p_CONTACT_ID
			AND PHONE_TYPE = p_PHONE_TYPE;

		IF SQL%NOTFOUND THEN
			INSERT INTO PHONE_NUMBER
				(
				CONTACT_ID,
				PHONE_TYPE,
				PHONE_NUMBER,
				ENTRY_DATE
				)
			VALUES
				(
				p_CONTACT_ID,
				p_PHONE_TYPE,
				p_PHONE_NUMBER,
				SYSDATE
				);
		END IF;
	END IF;

END PUT_CONTACT_PHONE_NUMBER;
----------------------------------------------------------------------------------------------------
PROCEDURE CUSTOMER_PRODUCTS
	(
	p_CUSTOMER_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_CUSTOMER_ID, EC.ED_CUSTOMER);

	OPEN p_CURSOR FOR
		 SELECT PRODUCT_ID, BEGIN_DATE, END_DATE, PRODUCT_TYPE, ENTRY_DATE
		 FROM CUSTOMER_PRODUCT
		 WHERE CUSTOMER_ID = p_CUSTOMER_ID
		 ORDER BY 1;

END CUSTOMER_PRODUCTS;
---------------------------------------------------------------------------------------------------

PROCEDURE PUT_CUSTOMER_PRODUCT
	(
	p_CUSTOMER_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_PRODUCT_TYPE IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_PRODUCT_ID IN NUMBER,
	p_OLD_PRODUCT_TYPE IN VARCHAR,
	p_OLD_BEGIN_DATE IN DATE
	) AS

v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_CUSTOMER_ID, EC.ED_CUSTOMER);

	v_KEY_NEW('CUSTOMER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_CUSTOMER_ID);
    v_KEY_OLD('CUSTOMER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_CUSTOMER_ID);
	v_KEY_NEW('PRODUCT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_PRODUCT_ID);
	v_KEY_OLD('PRODUCT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_PRODUCT_ID);
	v_KEY_NEW('PRODUCT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_PRODUCT_TYPE);
	v_KEY_OLD('PRODUCT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_OLD_PRODUCT_TYPE);

	UT.PUT_TEMPORAL_DATA_UI('CUSTOMER_PRODUCT',
			p_BEGIN_DATE,
			p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

END PUT_CUSTOMER_PRODUCT;
---------------------------------------------------------------------------------------------------

PROCEDURE CUSTOMER_ANCILLARY_SERVICES
	(
	p_CUSTOMER_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_CUSTOMER_ID, EC.ED_CUSTOMER);

	OPEN p_CURSOR FOR
		 SELECT ANCILLARY_SERVICE_ID, BEGIN_DATE, END_DATE, SERVICE_VAL, ENTRY_DATE
		 FROM CUSTOMER_ANCILLARY_SERVICE
		 WHERE CUSTOMER_ID = p_CUSTOMER_ID
		 ORDER BY 2;

END CUSTOMER_ANCILLARY_SERVICES;
---------------------------------------------------------------------------------------------------

PROCEDURE PUT_CUSTOMER_ANCILLARY_SERVICE
	(
	p_CUSTOMER_ID IN NUMBER,
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SERVICE_VAL IN NUMBER,
	p_OLD_ANCILLARY_SERVICE_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE
	) AS

v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_CUSTOMER_ID, EC.ED_CUSTOMER);

	v_KEY_NEW('CUSTOMER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_CUSTOMER_ID);
	v_KEY_OLD('CUSTOMER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_CUSTOMER_ID);
    v_KEY_NEW('ANCILLARY_SERVICE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_ANCILLARY_SERVICE_ID);
	v_KEY_OLD('ANCILLARY_SERVICE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_ANCILLARY_SERVICE_ID);
    v_DATA('SERVICE_VAL') := UT.GET_LITERAL_FOR_NUMBER(p_SERVICE_VAL);

	UT.PUT_TEMPORAL_DATA_UI('CUSTOMER_ANCILLARY_SERVICE',
			p_BEGIN_DATE,
			p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

END PUT_CUSTOMER_ANCILLARY_SERVICE;
---------------------------------------------------------------------------------------------------

PROCEDURE CUSTOMER_BILL_CYCLES
	(
	p_CUSTOMER_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_CUSTOMER_ID, EC.ED_CUSTOMER);

	OPEN p_CURSOR FOR
		 SELECT BILL_CYCLE_ID, BILL_CYCLE_ENTITY, BEGIN_DATE, END_DATE, ENTRY_DATE
		 FROM CUSTOMER_BILL_CYCLE
		 WHERE CUSTOMER_ID = p_CUSTOMER_ID
		 ORDER BY 2;

END CUSTOMER_BILL_CYCLES;
---------------------------------------------------------------------------------------------------

PROCEDURE PUT_CUSTOMER_BILL_CYCLE
	(
	p_CUSTOMER_ID IN NUMBER,
	p_BILL_CYCLE_ID IN NUMBER,
	p_BILL_CYCLE_ENTITY IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_BILL_CYCLE_ID IN NUMBER,
	p_OLD_BILL_CYCLE_ENTITY IN VARCHAR,
	p_OLD_BEGIN_DATE IN DATE
	) AS

v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_CUSTOMER_ID, EC.ED_CUSTOMER);

	v_KEY_NEW('CUSTOMER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_CUSTOMER_ID);
    v_KEY_OLD('CUSTOMER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_CUSTOMER_ID);
	v_KEY_NEW('BILL_CYCLE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_BILL_CYCLE_ID);
	v_KEY_OLD('BILL_CYCLE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_BILL_CYCLE_ID);
	v_KEY_NEW('BILL_CYCLE_ENTITY') := UT.GET_LITERAL_FOR_STRING(p_BILL_CYCLE_ENTITY);
	v_KEY_OLD('BILL_CYCLE_ENTITY') := UT.GET_LITERAL_FOR_STRING(p_OLD_BILL_CYCLE_ENTITY);

	UT.PUT_TEMPORAL_DATA_UI('CUSTOMER_BILL_CYCLE',
			p_BEGIN_DATE,
			p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

END PUT_CUSTOMER_BILL_CYCLE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_DOMAIN_KEYWORD_FROM_ID
	(
    p_DOMAIN_ID IN NUMBER,
    p_DOMAIN_KEYWORD OUT VARCHAR
    ) AS
v_NAME VARCHAR2(64);
BEGIN
	-- get the domain's "keyword" - i.e. the word that is used by the routines that auto-generate
    -- the EN and IO package to create EN.*_LIST, IO.PUT_*, and IO.GET_* routines.
	SELECT RTRIM(LTRIM(UPPER(NVL(B.ALIAS,B.TABLE_NAME))))
    INTO v_NAME
	FROM ENTITY_DOMAIN A, NERO_TABLE_PROPERTY_INDEX B
	WHERE A.ENTITY_DOMAIN_ID = p_DOMAIN_ID
		AND RTRIM(LTRIM(UPPER(A.ENTITY_DOMAIN_TABLE))) = RTRIM(LTRIM(UPPER(B.TABLE_NAME)));

	p_DOMAIN_KEYWORD := v_NAME;

EXCEPTION
	WHEN OTHERS THEN
    	p_DOMAIN_KEYWORD := NULL;
END GET_DOMAIN_KEYWORD_FROM_ID;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_DOMAIN_ALIAS_FROM_ID
	(
    p_DOMAIN_ID IN NUMBER,
    p_DOMAIN_ALIAS OUT VARCHAR2
    ) AS

v_ALIAS VARCHAR2(32);
BEGIN
	-- get the domain's alias from the ENTITY_DOMAIN table
    SELECT ENTITY_DOMAIN_TABLE_ALIAS
    INTO v_ALIAS
    FROM ENTITY_DOMAIN
    WHERE ENTITY_DOMAIN_ID = p_DOMAIN_ID;


    p_DOMAIN_ALIAS := v_ALIAS;

EXCEPTION
	WHEN OTHERS THEN
    	p_DOMAIN_ALIAS := NULL;
END GET_DOMAIN_ALIAS_FROM_ID;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_DOMAIN_NAME_FROM_ID
	(
    p_DOMAIN_ID IN NUMBER,
    p_DOMAIN_NAME OUT VARCHAR
    ) AS
v_NAME VARCHAR2(64);
BEGIN
	-- get the domain's name from the ENTITY_DOMAIN table
    SELECT NVL(DISPLAY_NAME,ENTITY_DOMAIN_NAME) "ENTITY_DOMAIN_NAME"
    INTO v_NAME
    FROM ENTITY_DOMAIN
    WHERE ENTITY_DOMAIN_ID = p_DOMAIN_ID;

    p_DOMAIN_NAME := v_NAME;

EXCEPTION
	WHEN OTHERS THEN
    	p_DOMAIN_NAME := NULL;
END GET_DOMAIN_NAME_FROM_ID;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_ENTITY_NAME_FROM_IDs
	(
    p_DOMAIN_ID IN NUMBER,
    p_ENTITY_ID IN NUMBER,
    p_ENTITY_NAME OUT VARCHAR
    ) AS
v_NAME VARCHAR2(64);
v_TABLE_NAME VARCHAR2(64);
v_ID_FIELD VARCHAR2(64);
v_NAME_FIELD VARCHAR2(64);
BEGIN
	-- get the domain's name from the ENTITY_DOMAIN table
    SELECT A.ENTITY_DOMAIN_TABLE,
    	RTRIM(LTRIM(UPPER(B.PRIMARY_ID_COLUMN)))
    INTO v_TABLE_NAME, v_ID_FIELD
    FROM ENTITY_DOMAIN A, NERO_TABLE_PROPERTY_INDEX B
    WHERE A.ENTITY_DOMAIN_ID = p_DOMAIN_ID
    	AND RTRIM(LTRIM(UPPER(A.ENTITY_DOMAIN_TABLE))) = RTRIM(LTRIM(UPPER(B.TABLE_NAME)));

    v_NAME_FIELD := SUBSTR(v_ID_FIELD,1,LENGTH(v_ID_FIELD)-2)||'NAME';

    EXECUTE IMMEDIATE ('SELECT '||v_NAME_FIELD||' FROM '||v_TABLE_NAME||' WHERE '||v_ID_FIELD||' = '||p_ENTITY_ID)
    	INTO v_NAME;

    p_ENTITY_NAME := v_NAME;

EXCEPTION
	WHEN OTHERS THEN
    	p_ENTITY_NAME := NULL;
END GET_ENTITY_NAME_FROM_IDs;
---------------------------------------------------------------------------------------------------
PROCEDURE TP_CONTRACT_NUMBERS
	(
	p_CONTRACT_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the CONTRACTs for the given ACCOUNT.

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_CONTRACT_ID, EC.ED_INTERCHANGE_CONTRACT);

	 OPEN p_CURSOR FOR
	    SELECT TP_ID, BEGIN_DATE, END_DATE, CONTRACT_NAME, CONTRACT_NUMBER, ENTRY_DATE, CONTRACT_ID
		FROM TP_CONTRACT_NUMBER A
		WHERE CONTRACT_ID = p_CONTRACT_ID
		ORDER BY 2,3;

END TP_CONTRACT_NUMBERS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_TP_CONTRACT_NUMBER
	(
	p_CONTRACT_ID IN NUMBER,
	p_TP_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CONTRACT_NAME IN VARCHAR2,
	p_CONTRACT_NUMBER IN VARCHAR2,
	p_OLD_TP_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE
	)
	AS

CURSOR c_TP_CONTRACT_NUMBER IS
	SELECT *
	FROM TP_CONTRACT_NUMBER
	WHERE CONTRACT_ID = p_CONTRACT_ID
		AND TP_ID = p_TP_ID
	ORDER BY BEGIN_DATE DESC;

v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
v_TP_CONTRACT_NUMBER TP_CONTRACT_NUMBER%ROWTYPE;
v_END_DATE DATE;
v_INITIAL BOOLEAN;

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_CONTRACT_ID, EC.ED_INTERCHANGE_CONTRACT);

	v_END_DATE := NULL_DATE(p_END_DATE);

	v_KEY_NEW('CONTRACT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_CONTRACT_ID);
    v_KEY_OLD('CONTRACT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_CONTRACT_ID);
	v_KEY_NEW('TP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_TP_ID);
	v_KEY_OLD('TP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_TP_ID);

	v_DATA('CONTRACT_NAME') := UT.GET_LITERAL_FOR_STRING(p_CONTRACT_NAME);
	v_DATA('CONTRACT_NUMBER') := UT.GET_LITERAL_FOR_STRING(p_CONTRACT_NUMBER);

	UT.PUT_TEMPORAL_DATA_UI('TP_CONTRACT_NUMBER',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
			);

	OPEN c_TP_CONTRACT_NUMBER;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_TP_CONTRACT_NUMBER INTO v_TP_CONTRACT_NUMBER;
		EXIT WHEN c_TP_CONTRACT_NUMBER%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_TP_CONTRACT_NUMBER.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE TP_CONTRACT_NUMBER
		SET END_DATE = GREATEST(v_END_DATE, v_TP_CONTRACT_NUMBER.BEGIN_DATE)
		WHERE CONTRACT_ID = v_TP_CONTRACT_NUMBER.CONTRACT_ID
			AND TP_ID = v_TP_CONTRACT_NUMBER.TP_ID
			AND BEGIN_DATE = v_TP_CONTRACT_NUMBER.BEGIN_DATE;
		v_END_DATE := v_TP_CONTRACT_NUMBER.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_TP_CONTRACT_NUMBER;

END PUT_TP_CONTRACT_NUMBER;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_CONTRACT_PROD_COMPONENT
	(
	p_CONTRACT_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_PRODUCT_ID IN NUMBER,
	p_OLD_COMPONENT_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE
	) AS

CURSOR c_CONTRACT_PROD_COMPONENT IS
	SELECT *
	FROM CONTRACT_PRODUCT_COMPONENT
	WHERE CONTRACT_ID = p_CONTRACT_ID
		AND PRODUCT_ID = p_PRODUCT_ID
		AND COMPONENT_ID = p_COMPONENT_ID
	ORDER BY BEGIN_DATE DESC;


v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
v_CONTRACT_PROD_COMPONENT CONTRACT_PRODUCT_COMPONENT%ROWTYPE;
v_INITIAL BOOLEAN;
v_END_DATE DATE;

BEGIN

	v_END_DATE := NULL_DATE(p_END_DATE);

	v_KEY_NEW('CONTRACT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_CONTRACT_ID);
    v_KEY_OLD('CONTRACT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_CONTRACT_ID);
	v_KEY_NEW('PRODUCT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_PRODUCT_ID);
	v_KEY_OLD('PRODUCT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_PRODUCT_ID);
	v_KEY_NEW('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_COMPONENT_ID);
	v_KEY_OLD('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_COMPONENT_ID);

	UT.PUT_TEMPORAL_DATA_UI('CONTRACT_PRODUCT_COMPONENT',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

--MAKE SURE THAT COMPONENTS DON'T OVERLAP
	OPEN c_CONTRACT_PROD_COMPONENT;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_CONTRACT_PROD_COMPONENT INTO v_CONTRACT_PROD_COMPONENT;
		EXIT WHEN c_CONTRACT_PROD_COMPONENT%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_CONTRACT_PROD_COMPONENT.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		IF NVL(v_END_DATE,HIGH_DATE) < NVL(v_CONTRACT_PROD_COMPONENT.END_DATE,HIGH_DATE) THEN
			UPDATE CONTRACT_PRODUCT_COMPONENT
			SET END_DATE = v_END_DATE
			WHERE CONTRACT_ID = v_CONTRACT_PROD_COMPONENT.CONTRACT_ID
				AND PRODUCT_ID = v_CONTRACT_PROD_COMPONENT.PRODUCT_ID
				AND COMPONENT_ID = v_CONTRACT_PROD_COMPONENT.COMPONENT_ID
				AND BEGIN_DATE = v_CONTRACT_PROD_COMPONENT.BEGIN_DATE;
		END IF;
		v_END_DATE := v_CONTRACT_PROD_COMPONENT.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_CONTRACT_PROD_COMPONENT;

	EXCEPTION
		WHEN OTHERS THEN
			ERRS.LOG_AND_RAISE();

END PUT_CONTRACT_PROD_COMPONENT;
----------------------------------------------------------------------------------------------------
PROCEDURE CONTRACT_COMP_ASSIGNMENTS
	(
	p_CONTRACT_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_CONTRACT_ID, EC.ED_INTERCHANGE_CONTRACT);


	OPEN p_CURSOR FOR
        SELECT C.PRODUCT_ID,
            C.COMPONENT_ID,
            C.BEGIN_DATE,
            C.END_DATE,
            C.ENTRY_DATE,
            (SELECT CASE WHEN COUNT(*)>0 THEN 0 ELSE 1 END
                FROM PRODUCT_COMPONENT PC
                WHERE PC.PRODUCT_ID = C.PRODUCT_ID
                    AND PC.COMPONENT_ID = C.COMPONENT_ID
                    AND PC.BEGIN_DATE <= NVL(C.END_DATE, CONSTANTS.HIGH_DATE)
                    AND NVL(PC.END_DATE, CONSTANTS.HIGH_DATE) >= C.BEGIN_DATE) AS INVALID_PROD_COMP_ASSGN
        FROM CONTRACT_PRODUCT_COMPONENT C,
            COMPONENT COMP,
            PRODUCT PROD
        WHERE C.CONTRACT_ID = p_CONTRACT_ID
            AND COMP.COMPONENT_ID(+) = C.COMPONENT_ID
            AND PROD.PRODUCT_ID(+) = C.PRODUCT_ID
        ORDER BY C.BEGIN_DATE, C.END_DATE, PROD.PRODUCT_NAME, COMP.COMPONENT_NAME;

END CONTRACT_COMP_ASSIGNMENTS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_CONTRACT_COMP_ASSIGNMENT
	(
	p_CONTRACT_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_PRODUCT_ID IN NUMBER,
	p_OLD_COMPONENT_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE
	) AS
v_FIRST BOOLEAN;
v_OLD_COMPONENT_ID NUMBER;
CURSOR c_COMPS IS
	SELECT COMPONENT_ID,
		GREATEST(BEGIN_DATE,p_BEGIN_DATE) "BEGIN_DATE",
		LEAST(NVL(END_DATE,HIGH_DATE),NVL(p_END_DATE,HIGH_DATE)) "END_DATE"
	FROM PRODUCT_COMPONENT
	WHERE PRODUCT_ID = p_PRODUCT_ID
		AND BEGIN_DATE <= NVL(TRUNC(p_END_DATE),HIGH_DATE)
		AND NVL(END_DATE,HIGH_DATE) >= TRUNC(p_BEGIN_DATE);
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_CONTRACT_ID, EC.ED_INTERCHANGE_CONTRACT);


	-- insert multiple components if they specified all
	IF p_COMPONENT_ID = CONSTANTS.ALL_ID THEN
		FOR v_COMP IN c_COMPS LOOP
			IF v_FIRST THEN
				v_OLD_COMPONENT_ID := p_OLD_COMPONENT_ID;
				v_FIRST := FALSE;
			ELSE
				v_OLD_COMPONENT_ID := v_COMP.COMPONENT_ID;
			END IF;
			PUT_CONTRACT_PROD_COMPONENT(p_CONTRACT_ID, p_PRODUCT_ID, v_COMP.COMPONENT_ID, TRUNC(v_COMP.BEGIN_DATE), TRUNC(v_COMP.END_DATE), p_OLD_PRODUCT_ID, v_OLD_COMPONENT_ID, TRUNC(p_OLD_BEGIN_DATE));
		END LOOP;
	ELSE
		PUT_CONTRACT_PROD_COMPONENT(p_CONTRACT_ID, p_PRODUCT_ID, p_COMPONENT_ID, TRUNC(p_BEGIN_DATE), TRUNC(p_END_DATE), p_OLD_PRODUCT_ID, p_OLD_COMPONENT_ID, p_OLD_BEGIN_DATE);
	END IF;

END PUT_CONTRACT_COMP_ASSIGNMENT;
---------------------------------------------------------------------------------------------------
PROCEDURE CONTRACT_LIMIT_QUANTITYS
	(
	p_CONTRACT_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the CONTRACT LIMITs for the given CONTRACT.

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_CONTRACT_ID, EC.ED_INTERCHANGE_CONTRACT);
	OPEN p_CURSOR FOR
	    SELECT C.LIMIT_ID,
			C.BEGIN_DATE,
			C.END_DATE,
			C.LIMIT_QUANTITY,
			C.ENTRY_DATE
		FROM CONTRACT_LIMIT_QUANTITY C
		WHERE C.CONTRACT_ID = p_CONTRACT_ID
		ORDER BY C.BEGIN_DATE;
END CONTRACT_LIMIT_QUANTITYS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_CONTRACT_LIMIT_QUANTITY
	(
	p_CONTRACT_ID IN NUMBER,
	p_LIMIT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_LIMIT_QUANTITY IN NUMBER,
	p_OLD_LIMIT_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE
	)
	AS
v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_CONTRACT_ID, EC.ED_CONTRACT);

    v_KEY_NEW('CONTRACT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_CONTRACT_ID);
    v_KEY_OLD('CONTRACT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_CONTRACT_ID);
    v_KEY_NEW('LIMIT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_LIMIT_ID);
    v_KEY_OLD('LIMIT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_LIMIT_ID);
    v_DATA('LIMIT_QUANTITY') := UT.GET_LITERAL_FOR_NUMBER(p_LIMIT_QUANTITY);

    UT.PUT_TEMPORAL_DATA_UI('CONTRACT_LIMIT_QUANTITY',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

END PUT_CONTRACT_LIMIT_QUANTITY;
----------------------------------------------------------------------------------------------------
PROCEDURE BILLING_ENTITY_LIST
	(
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the COUNTER PARTIES OF THE GIVEN TYPE

BEGIN
    OPEN p_CURSOR FOR
        SELECT PSE_NAME, PSE_ID
        FROM PURCHASING_SELLING_ENTITY
        WHERE PSE_STATUS = 'Active'
	        AND NVL(IS_BILLING_ENTITY,0) = 1
        ORDER BY 1;

END BILLING_ENTITY_LIST;
---------------------------------------------------------------------------------------------------

PROCEDURE SCHEDULE_TEMPLATE_LIST
	(
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the Schedule Template names

BEGIN
 	 OPEN p_CURSOR FOR
	 		SELECT TEMPLATE_NAME
			FROM SCHEDULE_TEMPLATE
			ORDER BY TEMPLATE_ORDER, TEMPLATE_NAME;

END SCHEDULE_TEMPLATE_LIST;
---------------------------------------------------------------------------------------------------

PROCEDURE COMPONENT_FOR_PRODUCT_LIST
	(
	p_PRODUCT_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the Components assigned to the specified product

BEGIN
	 OPEN p_CURSOR FOR
	 		SELECT COMPONENT_NAME, COMPONENT_ID
			FROM COMPONENT
				 WHERE COMPONENT_ID IN (SELECT COMPONENT_ID
				 		FROM PRODUCT_COMPONENT
						WHERE PRODUCT_ID = p_PRODUCT_ID)
			ORDER BY 1;

END COMPONENT_FOR_PRODUCT_LIST;
---------------------------------------------------------------------------------------------------

PROCEDURE MODEL_LIST
	(
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the Models (Electric, Gas)

BEGIN
	 OPEN p_CURSOR FOR
	 		SELECT 'Electric',1 FROM DUAL
			UNION ALL
			SELECT 'Gas',2 FROM DUAL;

END MODEL_LIST;
---------------------------------------------------------------------------------------------------
PROCEDURE LIST_FILTERED_STATEMENT_TYPES
	(
	p_AVAILABLE_IDS IN ID_TABLE,
    p_CURSOR OUT GA.REFCURSOR
    ) AS

BEGIN
	OPEN p_CURSOR FOR
 		SELECT A.Statement_Type_NAME, A.STATEMENT_TYPE_ID, A.STATEMENT_TYPE_ALIAS
		FROM STATEMENT_TYPE A,
			TABLE(CAST(p_AVAILABLE_IDS AS ID_TABLE)) X
		WHERE (X.ID = SD.g_ALL_DATA_ENTITY_ID OR A.STATEMENT_TYPE_ID = X.ID)
			AND A.STATEMENT_TYPE_ID > 0
		ORDER BY STATEMENT_TYPE_ORDER;

END LIST_FILTERED_STATEMENT_TYPES;
---------------------------------------------------------------------------------------------------
PROCEDURE LIST_STATEMENT_TYPES
	(
    p_CURSOR OUT GA.REFCURSOR
    ) AS
v_AVAILABLE_IDS ID_TABLE := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_STATEMENT_TYPE_LIST);
BEGIN

	LIST_FILTERED_STATEMENT_TYPES (v_AVAILABLE_IDS, p_CURSOR);

END LIST_STATEMENT_TYPES;
---------------------------------------------------------------------------------------------------
PROCEDURE LIST_ALL_STATEMENT_TYPES
	(
    p_CURSOR OUT GA.REFCURSOR
    ) AS
v_AVAILABLE_IDS ID_TABLE := ID_TABLE(ID_TYPE(SD.g_ALL_DATA_ENTITY_ID));
BEGIN

	LIST_FILTERED_STATEMENT_TYPES (v_AVAILABLE_IDS, p_CURSOR);

END LIST_ALL_STATEMENT_TYPES;
---------------------------------------------------------------------------------------------------
PROCEDURE EDC_SETTLEMENT_AGENT_LIST
	(
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN
 	 OPEN p_CURSOR FOR
	 		SELECT SETTLEMENT_AGENT_NAME
			FROM EDC_SETTLEMENT_AGENT
			ORDER BY 1;

END EDC_SETTLEMENT_AGENT_LIST;
---------------------------------------------------------------------------------------------------
PROCEDURE PORTFOLIO_SERVICE_POINTS
	(
	p_PORTFOLIO_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS


BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_PORTFOLIO_ID, EC.ED_PORTFOLIO);

	OPEN p_CURSOR FOR
	    SELECT A.SERVICE_POINT_ID,
	    	B.SERVICE_POINT_NAME,
	    	1 "IS_SELECTED",
			A.PORTFOLIO_ID
		FROM PORTFOLIO_SERVICE_POINT A, SERVICE_POINT B
		WHERE A.PORTFOLIO_ID = p_PORTFOLIO_ID
			AND A.SERVICE_POINT_ID = B.SERVICE_POINT_ID
			AND A.SERVICE_POINT_ID > 0

		UNION

		SELECT SERVICE_POINT_ID,
			SERVICE_POINT_NAME,
			0 "IS_SELECTED",
			p_PORTFOLIO_ID "PORTFOLIO_ID"
		FROM SERVICE_POINT
		WHERE NOT SERVICE_POINT_ID IN (SELECT SERVICE_POINT_ID
									FROM PORTFOLIO_SERVICE_POINT
									WHERE PORTFOLIO_ID = p_PORTFOLIO_ID)
			AND SERVICE_POINT_ID > 0

		ORDER BY 3 DESC, 2 ASC;

END PORTFOLIO_SERVICE_POINTS;
---------------------------------------------------------------------------------------------------


PROCEDURE PUT_PORTFOLIO_SERVICE_POINT
	(
	p_PORTFOLIO_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_IS_SELECTED IN NUMBER
	)
	AS

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_PORTFOLIO_ID, EC.ED_PORTFOLIO);


	--DELETE THE CURRENT ASSIGNMENT IF NOT SELECTED.
	IF p_IS_SELECTED = 0 THEN
		DELETE FROM PORTFOLIO_SERVICE_POINT
		WHERE PORTFOLIO_ID = p_PORTFOLIO_ID
			AND SERVICE_POINT_ID = p_SERVICE_POINT_ID;
	ELSE
	-- UPDATE THE CURRENT ASSIGNMENT IF ONE EXISTS

		UPDATE PORTFOLIO_SERVICE_POINT SET
			SERVICE_POINT_ID = p_SERVICE_POINT_ID
		WHERE PORTFOLIO_ID = p_PORTFOLIO_ID
			AND SERVICE_POINT_ID = p_SERVICE_POINT_ID;

	-- NO ASSIGNMENT UPDATE FOR THIS ACCOUNT AND ANCILLARY_SERVICE COMBINATION SO INSERT A NEW ASSIGNMENT

		IF SQL%NOTFOUND THEN
			INSERT INTO PORTFOLIO_SERVICE_POINT
				(
				PORTFOLIO_ID,
				SERVICE_POINT_ID
				)
			VALUES
				(
				p_PORTFOLIO_ID,
				p_SERVICE_POINT_ID
				);
		END IF;
	END IF;

END PUT_PORTFOLIO_SERVICE_POINT;
---------------------------------------------------------------------------------------------------
PROCEDURE SUB_SERVICE_POINTS
	(
	p_SERVICE_POINT_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS


BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_SERVICE_POINT_ID, EC.ED_SERVICE_POINT);


   OPEN p_CURSOR FOR
		SELECT A.BEGIN_DATE,
			 A.END_DATE,
			 A.ALLOCATION_PCT,
			 A.SUB_SERVICE_POINT_ID,
			 B.SERVICE_POINT_NAME "SUB_SERVICE_POINT_NAME",
			 A.ENTRY_DATE,
			 A.SERVICE_POINT_ID
		FROM SERVICE_POINT_AGGREGATE A, SERVICE_POINT B
		WHERE A.SERVICE_POINT_ID = p_SERVICE_POINT_ID
			AND A.SUB_SERVICE_POINT_ID = B.SERVICE_POINT_ID
		ORDER BY 5, 1;

END SUB_SERVICE_POINTS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_SUB_SERVICE_POINT
	(
	p_SERVICE_POINT_ID IN NUMBER,
	p_SUB_SERVICE_POINT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ALLOCATION_PCT IN NUMBER,
	p_OLD_SUB_SERVICE_POINT_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE
	)
	AS

v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
v_END_DATE DATE;

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_SERVICE_POINT_ID, EC.ED_SERVICE_POINT);

	v_END_DATE := NULL_DATE(p_END_DATE);

	v_KEY_NEW('SERVICE_POINT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SERVICE_POINT_ID);
    v_KEY_OLD('SERVICE_POINT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SERVICE_POINT_ID);
	v_KEY_NEW('SUB_SERVICE_POINT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SUB_SERVICE_POINT_ID);
    v_KEY_OLD('SUB_SERVICE_POINT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_SUB_SERVICE_POINT_ID);
    v_DATA('ALLOCATION_PCT') := UT.GET_LITERAL_FOR_NUMBER(p_ALLOCATION_PCT);

	UT.PUT_TEMPORAL_DATA_UI('SERVICE_POINT_AGGREGATE',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
			);

END PUT_SUB_SERVICE_POINT;
----------------------------------------------------------------------------------------------------
PROCEDURE SUB_SERVICE_POINT_LIST
	(
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the list of SERVICE_POINTS available to be Sub Service Points

BEGIN
 	 OPEN p_CURSOR FOR
	 	 SELECT SERVICE_POINT_NAME, SERVICE_POINT_ID
		 FROM SERVICE_POINT
		 WHERE NODE_TYPE IN ('Bus', 'BUS')
		 ORDER BY 1;

END SUB_SERVICE_POINT_LIST;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_IT_STATUS
	(
	p_TRANSACTION_ID IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_TRANSACTION_STATUS_NAME OUT VARCHAR,
	p_TRANSACTION_IS_ACTIVE OUT NUMBER
	) AS

v_AS_OF_DATE DATE := LOW_DATE;

BEGIN
	IF GA.VERSION_SCHEDULE THEN
		BEGIN
			SELECT MAX(AS_OF_DATE)
			INTO v_AS_OF_DATE
			FROM IT_STATUS
			WHERE TRANSACTION_ID = p_TRANSACTION_ID
				AND AS_OF_DATE <= p_AS_OF_DATE;

			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					v_AS_OF_DATE := p_AS_OF_DATE;
				WHEN OTHERS THEN
					RAISE;
		END;
	END IF;

	SELECT TRANSACTION_STATUS_NAME, TRANSACTION_IS_ACTIVE
		INTO p_TRANSACTION_STATUS_NAME, p_TRANSACTION_IS_ACTIVE
	FROM IT_STATUS
	WHERE TRANSACTION_ID = p_TRANSACTION_ID
		AND AS_OF_DATE = v_AS_OF_DATE;

END GET_IT_STATUS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_IT_STATUS
	(
	p_TRANSACTION_ID IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_TRANSACTION_STATUS_NAME IN VARCHAR,
	p_TRANSACTION_IS_ACTIVE IN NUMBER
	) AS

v_AS_OF_DATE DATE;

BEGIN
	IF GA.VERSION_SCHEDULE THEN
		v_AS_OF_DATE := CORRECTED_AS_OF_DATE(p_AS_OF_DATE);
	ELSE
		v_AS_OF_DATE := LOW_DATE;
	END IF;

	UPDATE IT_STATUS
	SET TRANSACTION_STATUS_NAME = p_TRANSACTION_STATUS_NAME,
		TRANSACTION_IS_ACTIVE = p_TRANSACTION_IS_ACTIVE
	WHERE TRANSACTION_ID = p_TRANSACTION_ID
		AND AS_OF_DATE = v_AS_OF_DATE;

	IF SQL%NOTFOUND THEN
		INSERT INTO IT_STATUS (
			TRANSACTION_ID,
			AS_OF_DATE,
			TRANSACTION_STATUS_NAME,
			TRANSACTION_IS_ACTIVE)
		VALUES (
			p_TRANSACTION_ID,
			v_AS_OF_DATE,
			p_TRANSACTION_STATUS_NAME,
			p_TRANSACTION_IS_ACTIVE);
	END IF;

END PUT_IT_STATUS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_TRANSACTION
	(
	o_OID OUT NUMBER,
	p_TRANSACTION_NAME IN VARCHAR2,
	p_TRANSACTION_ALIAS IN VARCHAR2,
	p_TRANSACTION_DESC IN VARCHAR2,
	p_TRANSACTION_ID IN NUMBER,
    p_TRANSACTION_STATUS IN VARCHAR2,
	p_TRANSACTION_TYPE IN VARCHAR2,
	p_TRANSACTION_IDENTIFIER IN VARCHAR2,
	p_IS_FIRM IN NUMBER,
	p_IS_IMPORT_SCHEDULE IN NUMBER,
	p_IS_EXPORT_SCHEDULE IN NUMBER,
	p_IS_BALANCE_TRANSACTION IN NUMBER,
	p_IS_BID_OFFER IN NUMBER,
	p_IS_EXCLUDE_FROM_POSITION IN NUMBER,
    p_IS_IMPORT_EXPORT IN NUMBER,
	p_IS_DISPATCHABLE IN NUMBER,
	p_TRANSACTION_INTERVAL IN VARCHAR2,
	p_EXTERNAL_INTERVAL IN VARCHAR2,
	p_ETAG_CODE IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PURCHASER_ID IN NUMBER,
	p_SELLER_ID IN NUMBER,
	p_CONTRACT_ID IN NUMBER,
	p_SC_ID IN NUMBER,
	p_POR_ID IN NUMBER,
	p_POD_ID IN NUMBER,
	p_COMMODITY_ID IN NUMBER,
	p_SERVICE_TYPE_ID IN NUMBER,
	p_TX_TRANSACTION_ID IN NUMBER,
	p_PATH_ID IN NUMBER,
	p_LINK_TRANSACTION_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_SCHEDULE_GROUP_ID IN NUMBER,
	p_MARKET_PRICE_ID IN NUMBER,
	p_ZOR_ID IN NUMBER,
	p_ZOD_ID IN NUMBER,
	p_SOURCE_ID IN NUMBER,
	p_SINK_ID IN NUMBER,
	p_RESOURCE_ID IN NUMBER,
    p_AGREEMENT_TYPE IN VARCHAR2,
    p_APPROVAL_TYPE IN VARCHAR2,
    p_LOSS_OPTION IN VARCHAR2,
    p_TRAIT_CATEGORY IN VARCHAR2,
	p_TP_ID IN NUMBER
	) AS
v_IS_ACTIVE NUMBER(1);
v_CODE CHAR(1);
BEGIN
	-- get proper transaction code first
    BEGIN
        SELECT SUBSTR(CODE,1,1) INTO v_CODE
        FROM SYSTEM_LABEL
        WHERE MODEL_ID = 1
        	AND MODULE = 'Scheduling'
            AND KEY1 = 'TransactionDialog'
            AND KEY2 = 'Combo Lists'
            AND KEY3 = 'Transaction Type'
            AND VALUE = p_TRANSACTION_TYPE
			AND ROWNUM = 1;
	EXCEPTION
    	WHEN NO_DATA_FOUND THEN
        	v_CODE := NULL;
	END;
    -- then put the transaction
	IO.PUT_TRANSACTION(o_OID,p_TRANSACTION_NAME,p_TRANSACTION_ALIAS,p_TRANSACTION_DESC,
		p_TRANSACTION_ID,p_TRANSACTION_TYPE,v_CODE,p_TRANSACTION_IDENTIFIER,
        p_IS_FIRM,p_IS_IMPORT_SCHEDULE,p_IS_EXPORT_SCHEDULE,p_IS_BALANCE_TRANSACTION,
        p_IS_BID_OFFER,p_IS_EXCLUDE_FROM_POSITION,p_IS_IMPORT_EXPORT,p_IS_DISPATCHABLE,p_TRANSACTION_INTERVAL,
        p_EXTERNAL_INTERVAL,p_ETAG_CODE,p_BEGIN_DATE,p_END_DATE,p_PURCHASER_ID,p_SELLER_ID,
        p_CONTRACT_ID,p_SC_ID,p_POR_ID,p_POD_ID,p_COMMODITY_ID,p_SERVICE_TYPE_ID,
        p_TX_TRANSACTION_ID,p_PATH_ID,p_LINK_TRANSACTION_ID,p_EDC_ID,p_PSE_ID,p_ESP_ID,
        p_POOL_ID,p_SCHEDULE_GROUP_ID,p_MARKET_PRICE_ID,p_ZOR_ID,p_ZOD_ID,p_SOURCE_ID,
        p_SINK_ID,p_RESOURCE_ID,p_AGREEMENT_TYPE,p_APPROVAL_TYPE,p_LOSS_OPTION,p_TRAIT_CATEGORY,p_TP_ID);
	-- then put the transaction status
	BEGIN
    	SELECT TRANSACTION_IS_ACTIVE INTO v_IS_ACTIVE
        FROM INTERCHANGE_TRANSACTION_STATUS
        WHERE TRANSACTION_STATUS_NAME = p_TRANSACTION_STATUS;
    EXCEPTION
    	WHEN OTHERS THEN
        	v_IS_ACTIVE := 0;
    END;
	PUT_IT_STATUS(o_OID,SYSDATE,p_TRANSACTION_STATUS,v_IS_ACTIVE);
    -- done!
END PUT_TRANSACTION;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_TRANSACTION
	(
	p_TRANSACTION_ID IN NUMBER,
	p_TRANSACTION_NAME OUT VARCHAR2,
	p_TRANSACTION_ALIAS OUT VARCHAR2,
	p_TRANSACTION_DESC OUT VARCHAR2,
    p_TRANSACTION_STATUS OUT VARCHAR2,
	p_TRANSACTION_TYPE OUT VARCHAR2,
	p_TRANSACTION_CODE OUT CHAR,
	p_TRANSACTION_IDENTIFIER OUT VARCHAR2,
	p_IS_FIRM OUT NUMBER,
	p_IS_IMPORT_SCHEDULE OUT NUMBER,
	p_IS_EXPORT_SCHEDULE OUT NUMBER,
	p_IS_BALANCE_TRANSACTION OUT NUMBER,
	p_IS_BID_OFFER OUT NUMBER,
	p_IS_EXCLUDE_FROM_POSITION OUT NUMBER,
	p_IS_IMPORT_EXPORT OUT NUMBER,
	p_IS_DISPATCHABLE OUT NUMBER,
	p_TRANSACTION_INTERVAL OUT VARCHAR2,
	p_EXTERNAL_INTERVAL OUT VARCHAR2,
	p_ETAG_CODE OUT VARCHAR2,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE,
	p_PURCHASER_ID OUT NUMBER,
	p_PURCHASER_DISP OUT VARCHAR2,
	p_SELLER_ID OUT NUMBER,
	p_SELLER_DISP OUT VARCHAR2,
	p_CONTRACT_ID OUT NUMBER,
	p_CONTRACT_DISP OUT VARCHAR2,
	p_SC_ID OUT NUMBER,
	p_SC_DISP OUT VARCHAR2,
	p_POR_ID OUT NUMBER,
	p_POR_DISP OUT VARCHAR2,
	p_POD_ID OUT NUMBER,
	p_POD_DISP OUT VARCHAR2,
	p_COMMODITY_ID OUT NUMBER,
	p_COMMODITY_DISP OUT VARCHAR2,
	p_SERVICE_TYPE_ID OUT NUMBER,
	p_SERVICE_TYPE_DISP OUT VARCHAR2,
	p_TX_TRANSACTION_ID OUT NUMBER,
	p_TX_TRANSACTION_DISP OUT VARCHAR2,
	p_PATH_ID OUT NUMBER,
	p_PATH_DISP OUT VARCHAR2,
	p_LINK_TRANSACTION_ID OUT NUMBER,
	p_LINK_TRANSACTION_DISP OUT VARCHAR2,
	p_EDC_ID OUT NUMBER,
	p_EDC_DISP OUT VARCHAR2,
	p_PSE_ID OUT NUMBER,
	p_PSE_DISP OUT VARCHAR2,
	p_ESP_ID OUT NUMBER,
	p_ESP_DISP OUT VARCHAR2,
	p_POOL_ID OUT NUMBER,
	p_POOL_DISP OUT VARCHAR2,
	p_SCHEDULE_GROUP_ID OUT NUMBER,
	p_SCHEDULE_GROUP_DISP OUT VARCHAR2,
	p_MARKET_PRICE_ID OUT NUMBER,
	p_MARKET_PRICE_DISP OUT VARCHAR2,
	p_ZOR_ID OUT NUMBER,
	p_ZOR_DISP OUT VARCHAR2,
	p_ZOD_ID OUT NUMBER,
	p_ZOD_DISP OUT VARCHAR2,
	p_SOURCE_ID OUT NUMBER,
	p_SOURCE_DISP OUT VARCHAR2,
	p_SINK_ID OUT NUMBER,
	p_SINK_DISP OUT VARCHAR2,
	p_RESOURCE_ID OUT NUMBER,
	p_RESOURCE_DISP OUT VARCHAR2,
	p_AGREEMENT_TYPE OUT VARCHAR2,
	p_APPROVAL_TYPE OUT VARCHAR2,
	p_LOSS_OPTION OUT VARCHAR2,
	p_TRAIT_CATEGORY OUT VARCHAR2,
	p_TP_ID OUT NUMBER,
	p_TP_DISP OUT VARCHAR2
	) AS
v_IS_ACTIVE NUMBER(1);
BEGIN
	EM_GET.TRANSACTION(p_TRANSACTION_ID,
						p_TRANSACTION_NAME,
						p_TRANSACTION_ALIAS,
						p_TRANSACTION_DESC,
						p_TRANSACTION_TYPE,
						p_TRANSACTION_CODE,
						p_TRANSACTION_IDENTIFIER,
						p_IS_FIRM,
						p_IS_IMPORT_SCHEDULE,
						p_IS_EXPORT_SCHEDULE,
						p_IS_BALANCE_TRANSACTION,
						p_IS_BID_OFFER,
						p_IS_EXCLUDE_FROM_POSITION,
						p_IS_IMPORT_EXPORT,
						p_IS_DISPATCHABLE,
						p_TRANSACTION_INTERVAL,
						p_EXTERNAL_INTERVAL,
						p_ETAG_CODE,
						p_BEGIN_DATE,
						p_END_DATE,
						p_PURCHASER_ID,
						p_PURCHASER_DISP,
						p_SELLER_ID,
						p_SELLER_DISP,
						p_CONTRACT_ID,
						p_CONTRACT_DISP,
						p_SC_ID,
						p_SC_DISP,
						p_POR_ID,
						p_POR_DISP,
						p_POD_ID,
						p_POD_DISP,
						p_COMMODITY_ID,
						p_COMMODITY_DISP,
						p_SERVICE_TYPE_ID,
						p_SERVICE_TYPE_DISP,
						p_TX_TRANSACTION_ID,
						p_TX_TRANSACTION_DISP,
						p_PATH_ID,
						p_PATH_DISP,
						p_LINK_TRANSACTION_ID,
						p_LINK_TRANSACTION_DISP,
						p_EDC_ID,
						p_EDC_DISP,
						p_PSE_ID,
						p_PSE_DISP,
						p_ESP_ID,
						p_ESP_DISP,
						p_POOL_ID,
						p_POOL_DISP,
						p_SCHEDULE_GROUP_ID,
						p_SCHEDULE_GROUP_DISP,
						p_MARKET_PRICE_ID,
						p_MARKET_PRICE_DISP,
						p_ZOR_ID,
						p_ZOR_DISP,
						p_ZOD_ID,
						p_ZOD_DISP,
						p_SOURCE_ID,
						p_SOURCE_DISP,
						p_SINK_ID,
						p_SINK_DISP,
						p_RESOURCE_ID,
						p_RESOURCE_DISP,
						p_AGREEMENT_TYPE,
						p_APPROVAL_TYPE,
						p_LOSS_OPTION,
						p_TRAIT_CATEGORY,
						p_TP_ID,
						p_TP_DISP
						);
	GET_IT_STATUS(p_TRANSACTION_ID,SYSDATE,p_TRANSACTION_STATUS,v_IS_ACTIVE);
END GET_TRANSACTION;
----------------------------------------------------------------------------------------------------
PROCEDURE LIST_TRANSACTIONS
	(
	p_SEARCH_STRING IN VARCHAR,
	p_SEARCH_OPTION IN VARCHAR,
	p_SEARCH_TYPE	IN NUMBER,
	p_FIND_ENTITY_ID IN NUMBER,
	p_ACTION_NAME IN VARCHAR2,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
	p_CURSOR OUT GA.REFCURSOR
	)
	AS

-- Answer the given entities
v_IDs ID_TABLE;
BEGIN

	--Make sure user has appropriate access.
	IF p_ACTION_NAME IS NULL THEN
		v_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(EN.g_DEFAULT_ACTION_NAME,EC.ED_TRANSACTION);
	ELSE
		v_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(p_ACTION_NAME,EC.ED_TRANSACTION);
	END IF;

	IF NVL(p_SEARCH_TYPE, CONSTANTS.SEARCH_TYPE_NORMAL) = CONSTANTS.SEARCH_TYPE_NORMAL THEN
		IF p_SEARCH_STRING = '%' OR p_SEARCH_STRING IS NULL THEN

			OPEN p_CURSOR FOR
			SELECT
				A.TRANSACTION_NAME "ENTITY_NAME",
				A.TRANSACTION_ID "ENTITY_ID",
				A.TRANSACTION_ALIAS "ENTITY_ALIAS",
				B.TRANSACTION_STATUS_NAME "ENTITY_STATUS"
			FROM INTERCHANGE_TRANSACTION A,
				IT_STATUS B,
				TABLE(CAST(v_IDs AS ID_TABLE)) IDs
			WHERE IDs.ID IN (A.TRANSACTION_ID, SD.g_ALL_DATA_ENTITY_ID)
				AND A.BEGIN_DATE <= p_END_DATE -- filter by dates
				AND NVL(A.END_DATE,HIGH_DATE) >= p_BEGIN_DATE
				AND B.TRANSACTION_ID = A.TRANSACTION_ID -- join for status
				AND B.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
									FROM IT_STATUS
									WHERE TRANSACTION_ID = B.TRANSACTION_ID
										AND AS_OF_DATE <= SYSDATE)
			ORDER BY DECODE(NVL(p_SEARCH_OPTION,CONSTANTS.SEARCH_OPTION_BY_NAME), CONSTANTS.SEARCH_OPTION_BY_NAME, TRANSACTION_NAME, TRANSACTION_ALIAS);

		ELSE

			OPEN p_CURSOR FOR
			SELECT
				A.TRANSACTION_NAME "ENTITY_NAME",
				A.TRANSACTION_ID "ENTITY_ID",
				A.TRANSACTION_ALIAS "ENTITY_ALIAS",
				B.TRANSACTION_STATUS_NAME "ENTITY_STATUS"
			FROM INTERCHANGE_TRANSACTION A,
				IT_STATUS B,
				TABLE(CAST(v_IDs AS ID_TABLE)) IDs
			WHERE IDs.ID IN (A.TRANSACTION_ID, SD.g_ALL_DATA_ENTITY_ID)
				AND A.BEGIN_DATE <= p_END_DATE -- filter by dates
				AND NVL(A.END_DATE,HIGH_DATE) >= p_BEGIN_DATE
				AND B.TRANSACTION_ID = A.TRANSACTION_ID -- join for status
				AND B.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
									FROM IT_STATUS
									WHERE TRANSACTION_ID = B.TRANSACTION_ID
										AND AS_OF_DATE <= SYSDATE)
				AND ((p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_NAME
					AND TRANSACTION_NAME LIKE p_SEARCH_STRING)
                   OR (p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_ALIAS
					AND TRANSACTION_ALIAS LIKE p_SEARCH_STRING))
            ORDER BY DECODE(p_SEARCH_OPTION, CONSTANTS.SEARCH_OPTION_BY_NAME, TRANSACTION_NAME, TRANSACTION_ALIAS);

		END IF;

        -- Specific Value
	ELSIF p_SEARCH_TYPE = CONSTANTS.SEARCH_TYPE_BY_VAL THEN

		OPEN p_CURSOR FOR
		SELECT
			A.TRANSACTION_NAME "ENTITY_NAME",
			A.TRANSACTION_ID "ENTITY_ID",
			A.TRANSACTION_ALIAS "ENTITY_ALIAS",
			B.TRANSACTION_STATUS_NAME "ENTITY_STATUS"
		FROM INTERCHANGE_TRANSACTION A,
			IT_STATUS B,
			TABLE(CAST(v_IDs AS ID_TABLE)) IDs
		WHERE IDs.ID IN (A.TRANSACTION_ID, SD.g_ALL_DATA_ENTITY_ID)
			AND A.BEGIN_DATE <= p_END_DATE -- filter by dates
			AND NVL(A.END_DATE,HIGH_DATE) >= p_BEGIN_DATE
			AND B.TRANSACTION_ID = A.TRANSACTION_ID -- join for status
			AND B.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
								FROM IT_STATUS
								WHERE TRANSACTION_ID = B.TRANSACTION_ID
									AND AS_OF_DATE <= SYSDATE)
			AND A.TRANSACTION_ID = p_FIND_ENTITY_ID;

	END IF;

END LIST_TRANSACTIONS;
----------------------------------------------------------------------------------------------------
PROCEDURE BALANCE_TRANSACTIONS
	(
	p_TRANSACTION_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_TRANSACTION_ID, EC.ED_TRANSACTION);


   OPEN p_CURSOR FOR
		SELECT A.FROM_TRANSACTION_ID "TRANSACTION_ID",
        	A.TO_TRANSACTION_ID "BALANCE_TRANSACTION_ID",
            T.TRANSACTION_NAME "BALANCE_TRANSACTION_NAME",
	        P.BEGIN_DATE,
			P.END_DATE,
			A.ENTRY_DATE
		FROM IT_ASSIGNMENT A,
			IT_ASSIGNMENT_PERIOD P,
			INTERCHANGE_TRANSACTION T
		WHERE A.FROM_TRANSACTION_ID = p_TRANSACTION_ID
			AND A.ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE
			AND T.TRANSACTION_ID = A.TO_TRANSACTION_ID
			AND P.ASSIGNMENT_ID = A.ASSIGNMENT_ID
		ORDER BY P.BEGIN_DATE, A.ENTRY_DATE;

END BALANCE_TRANSACTIONS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_BALANCE_TRANSACTION
	(
    p_TRANSACTION_ID IN NUMBER,
    p_BALANCE_TRANSACTION_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
	p_OLD_BALANCE_TRANSACTION_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE
    ) AS

v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
v_OLD_ASSIGNMENT_ID NUMBER(9);
v_NEW_ASSIGNMENT_ID NUMBER(9);
v_COUNT_PERIODS NUMBER;
v_END_DATE DATE;
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_TRANSACTION_ID, EC.ED_TRANSACTION);
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_BALANCE_TRANSACTION_ID, EC.ED_TRANSACTION);
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_OLD_BALANCE_TRANSACTION_ID, EC.ED_TRANSACTION);

	v_END_DATE := NULL_DATE(p_END_DATE);

	-- get old and new assignment IDs
	BEGIN
    	SELECT ASSIGNMENT_ID
    	INTO v_OLD_ASSIGNMENT_ID
    	FROM IT_ASSIGNMENT
    	WHERE FROM_TRANSACTION_ID = p_TRANSACTION_ID
    		AND TO_TRANSACTION_ID = p_OLD_BALANCE_TRANSACTION_ID
    		AND ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			v_OLD_ASSIGNMENT_ID := 0;
	END;

	BEGIN
    	SELECT ASSIGNMENT_ID
    	INTO v_NEW_ASSIGNMENT_ID
    	FROM IT_ASSIGNMENT
    	WHERE FROM_TRANSACTION_ID = p_TRANSACTION_ID
    		AND TO_TRANSACTION_ID = p_BALANCE_TRANSACTION_ID
    		AND ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			SELECT OID.NEXTVAL INTO v_NEW_ASSIGNMENT_ID FROM DUAL;
			INSERT INTO IT_ASSIGNMENT
				(ASSIGNMENT_ID, TO_TRANSACTION_ID, FROM_TRANSACTION_ID,
				ASSIGNMENT_TYPE, ENTRY_DATE)
			VALUES
				(v_NEW_ASSIGNMENT_ID, p_BALANCE_TRANSACTION_ID, p_TRANSACTION_ID,
				g_BALANCING_ASSIGNMENT_TYPE, SYSDATE);
	END;

	v_KEY_NEW('ASSIGNMENT_ID') := UT.GET_LITERAL_FOR_NUMBER(v_NEW_ASSIGNMENT_ID);
    v_KEY_OLD('ASSIGNMENT_ID') := UT.GET_LITERAL_FOR_NUMBER(v_OLD_ASSIGNMENT_ID);

	UT.PUT_TEMPORAL_DATA_UI('IT_ASSIGNMENT_PERIOD',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            FALSE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
			);

END PUT_BALANCE_TRANSACTION;
----------------------------------------------------------------------------------------------------
PROCEDURE BALANCING_TRANSACTIONS
	(
	p_TRANSACTION_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_TRANSACTION_ID, EC.ED_TRANSACTION);


   OPEN p_CURSOR FOR
		SELECT A.TO_TRANSACTION_ID "TRANSACTION_ID",
        	A.FROM_TRANSACTION_ID "BALANCING_TRANSACTION_ID",
            T.TRANSACTION_NAME "BALANCING_TRANSACTION_NAME",
	        P.BEGIN_DATE,
			P.END_DATE,
			A.ENTRY_DATE
		FROM IT_ASSIGNMENT A,
			IT_ASSIGNMENT_PERIOD P,
			INTERCHANGE_TRANSACTION T
		WHERE A.TO_TRANSACTION_ID = p_TRANSACTION_ID
			AND A.ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE
			AND T.TRANSACTION_ID = A.FROM_TRANSACTION_ID
			AND P.ASSIGNMENT_ID = A.ASSIGNMENT_ID
		ORDER BY P.BEGIN_DATE, A.ENTRY_DATE;

END BALANCING_TRANSACTIONS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_BALANCING_TRANSACTION
	(
    p_TRANSACTION_ID IN NUMBER,
    p_BALANCING_TRANSACTION_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
	p_OLD_BALANCING_TRANSACTION_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE
    ) AS

v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
v_OLD_ASSIGNMENT_ID NUMBER(9);
v_NEW_ASSIGNMENT_ID NUMBER(9);
v_COUNT_PERIODS NUMBER;
v_END_DATE DATE;
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_TRANSACTION_ID, EC.ED_TRANSACTION);
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_BALANCING_TRANSACTION_ID, EC.ED_TRANSACTION);

	v_END_DATE := NULL_DATE(p_END_DATE);

	-- get old and new assignment IDs
	BEGIN
    	SELECT ASSIGNMENT_ID
    	INTO v_OLD_ASSIGNMENT_ID
    	FROM IT_ASSIGNMENT
		WHERE FROM_TRANSACTION_ID = p_OLD_BALANCING_TRANSACTION_ID
			AND TO_TRANSACTION_ID = p_TRANSACTION_ID
    		AND ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			v_OLD_ASSIGNMENT_ID := 0;
	END;

	BEGIN
    	SELECT ASSIGNMENT_ID
    	INTO v_NEW_ASSIGNMENT_ID
    	FROM IT_ASSIGNMENT
		WHERE FROM_TRANSACTION_ID = p_BALANCING_TRANSACTION_ID
			AND TO_TRANSACTION_ID = p_TRANSACTION_ID
    		AND ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			SELECT OID.NEXTVAL INTO v_NEW_ASSIGNMENT_ID FROM DUAL;
			INSERT INTO IT_ASSIGNMENT
				(ASSIGNMENT_ID, TO_TRANSACTION_ID, FROM_TRANSACTION_ID,
				ASSIGNMENT_TYPE, ENTRY_DATE)
			VALUES
				(v_NEW_ASSIGNMENT_ID, p_TRANSACTION_ID, p_BALANCING_TRANSACTION_ID,
				g_BALANCING_ASSIGNMENT_TYPE, SYSDATE);
	END;

	v_KEY_NEW('ASSIGNMENT_ID') := UT.GET_LITERAL_FOR_NUMBER(v_NEW_ASSIGNMENT_ID);
    v_KEY_OLD('ASSIGNMENT_ID') := UT.GET_LITERAL_FOR_NUMBER(v_OLD_ASSIGNMENT_ID);

	UT.PUT_TEMPORAL_DATA_UI('IT_ASSIGNMENT_PERIOD',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            FALSE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

		-- there was an assignment updated? then see if we need to clean up
		-- parent record from IT_ASSIGNMENT
    	SELECT COUNT(*)
    	INTO v_COUNT_PERIODS
    	FROM IT_ASSIGNMENT_PERIOD
    	WHERE ASSIGNMENT_ID = v_OLD_ASSIGNMENT_ID;

    	IF v_COUNT_PERIODS = 0 THEN
    		DELETE FROM IT_ASSIGNMENT
    		WHERE ASSIGNMENT_ID = v_OLD_ASSIGNMENT_ID;
    	END IF;

END PUT_BALANCING_TRANSACTION;
----------------------------------------------------------------------------------------------------
PROCEDURE ETAG_DETAILS
	(
	p_TRANSACTION_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_TRANSACTION_ID, EC.ED_TRANSACTION);


	OPEN p_CURSOR FOR
		SELECT
			T.TRANSACTION_ID,
			ETX.ETAG_ID,
			E.TAG_IDENT
		FROM ETAG_TRANSACTION ETX, INTERCHANGE_TRANSACTION T, ETAG E
		WHERE ETX.TRANSACTION_ID = p_TRANSACTION_ID
			AND T.TRANSACTION_ID = ETX.TRANSACTION_ID
			AND E.ETAG_ID = ETX.ETAG_ID;

END ETAG_DETAILS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ETAG_DETAIL
	(
	p_TRANSACTION_ID IN NUMBER,
    p_ETAG_ID IN NUMBER,
    p_OLD_ETAG_ID  IN NUMBER
	) AS

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_TRANSACTION_ID, EC.ED_TRANSACTION);


	-- UPDATE THE CURRENT ASSIGNMENT IF ONE EXISTS
	UPDATE ETAG_TRANSACTION SET
        ETAG_ID  = p_ETAG_ID
	 WHERE TRANSACTION_ID = p_TRANSACTION_ID
        AND ETAG_ID = p_OLD_ETAG_ID;

	-- NO ASSIGNMENT UPDATE FOR THIS PATH/SEGMENT COMBINATION SO INSERT A NEW ASSIGNMENT
	IF SQL%NOTFOUND THEN
		INSERT INTO ETAG_TRANSACTION
            (
            TRANSACTION_ID,
            ETAG_ID
            )
		VALUES
            (
			p_TRANSACTION_ID,
            p_ETAG_ID
            );
	END IF;

END PUT_ETAG_DETAIL;
----------------------------------------------------------------------------------------------------
PROCEDURE BALANCE_SUPPLY_TRANSACTIONS
	(
	p_COMMODITY_ID IN NUMBER,
	p_INTERVAL IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT A.TRANSACTION_NAME, A.TRANSACTION_ID
		FROM INTERCHANGE_TRANSACTION A,
			IT_COMMODITY B,
			IT_COMMODITY C
		WHERE A.BEGIN_DATE <= NVL(p_END_DATE,A.BEGIN_DATE)
			AND A.END_DATE >= NVL(p_BEGIN_DATE,A.END_DATE)
			AND A.TRANSACTION_INTERVAL = p_INTERVAL
			AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) IN ('PU','GE')
			AND B.COMMODITY_ID = A.COMMODITY_ID
			AND C.COMMODITY_ID = p_COMMODITY_ID
			AND C.COMMODITY_TYPE = B.COMMODITY_TYPE
		ORDER BY A.TRANSACTION_NAME;
END BALANCE_SUPPLY_TRANSACTIONS;
----------------------------------------------------------------------------------------------------
PROCEDURE BALANCE_LOAD_TRANSACTIONS
	(
	p_COMMODITY_ID IN NUMBER,
	p_INTERVAL IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT A.TRANSACTION_NAME, A.TRANSACTION_ID
		FROM INTERCHANGE_TRANSACTION A,
			IT_COMMODITY B,
			IT_COMMODITY C
		WHERE A.BEGIN_DATE <= NVL(p_END_DATE,A.BEGIN_DATE)
			AND A.END_DATE >= NVL(p_BEGIN_DATE,A.END_DATE)
			AND A.TRANSACTION_INTERVAL = p_INTERVAL
			AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) IN ('LO','SA')
            AND NVL(A.IS_BALANCE_TRANSACTION,0) = 1
			AND B.COMMODITY_ID = A.COMMODITY_ID
			AND C.COMMODITY_ID = p_COMMODITY_ID
			AND C.COMMODITY_TYPE = B.COMMODITY_TYPE
		ORDER BY A.TRANSACTION_NAME;
END BALANCE_LOAD_TRANSACTIONS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SHOW_FIND_FOR_ENTITY
	(
	p_MODEL_ID IN NUMBER,
    p_ENTITY_DOMAIN_ALIAS IN VARCHAR2,
    p_VALUE OUT VARCHAR2,
	p_STATUS OUT NUMBER
	) AS

-- THIS PROCEDURE IS USED BY THE PROFILE AND DATA MANAGEMENT
-- VB MODULES.  PLEASE DO NOT CHANGE ITS SIGNATURE UNTIL
-- THESE VB MODULES HAVE BEEN REMOVED

-- Answer the SYSTEM_DICTIONARY value for the given ENTITY NAME

BEGIN
	p_VALUE := MODEL_VALUE_AT_KEY(p_MODEL_ID, 'Entity Manager', g_SHOW_FIND_IN_TREE, p_ENTITY_DOMAIN_ALIAS, 0);

END GET_SHOW_FIND_FOR_ENTITY;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_HOLIDAY_OBSERVANCE
	(
	p_HOLIDAY_ID IN NUMBER,
	p_HOLIDAY_YEAR IN NUMBER,
	p_HOLIDAY_DATE IN DATE,
	p_OLD_HOLIDAY_YEAR IN NUMBER
	) AS
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_HOLIDAY_ID, EC.ED_HOLIDAY);
-- UPDATE AN EXISTING RECORD
	UPDATE HOLIDAY_OBSERVANCE SET
		HOLIDAY_DATE = TRUNC(p_HOLIDAY_DATE),
		HOLIDAY_YEAR = p_HOLIDAY_YEAR,
		ENTRY_DATE = SYSDATE
	WHERE HOLIDAY_ID = p_HOLIDAY_ID
		AND HOLIDAY_YEAR = p_OLD_HOLIDAY_YEAR;
-- IF THE PREVIOUS UPDATE DID NOT FIND A MATCH, THEN INSERT A NEW RECORD
	IF SQL%NOTFOUND THEN
		INSERT INTO HOLIDAY_OBSERVANCE (
			HOLIDAY_ID,
			HOLIDAY_YEAR,
			HOLIDAY_DATE,
			ENTRY_DATE)
		VALUES (
			p_HOLIDAY_ID,
			p_HOLIDAY_YEAR,
			TRUNC(p_HOLIDAY_DATE),
			SYSDATE);
	END IF;
END PUT_HOLIDAY_OBSERVANCE;
----------------------------------------------------------------------------------------------------
PROCEDURE HOLIDAY_OBSERVANCES
	(
	p_HOLIDAY_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
-- ANSWER THE HOLIDAY YEAR AND DATE FOR THE APPROPRIATE HOLIDAY
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_HOLIDAY_ID, EC.ED_HOLIDAY);


	OPEN p_CURSOR FOR
		  SELECT HOLIDAY_YEAR, HOLIDAY_DATE, ENTRY_DATE
		  FROM HOLIDAY_OBSERVANCE
		  WHERE HOLIDAY_ID = p_HOLIDAY_ID
		  ORDER BY HOLIDAY_YEAR;

END HOLIDAY_OBSERVANCES;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_HOLIDAY_SET_EDC
	(
	p_HOLIDAY_SET_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_IS_SELECTED IN NUMBER
	)
	AS

v_HOLIDAY_SET_ID NUMBER(9);
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_EDC_ID, EC.ED_EDC);


-- UPDATE THE CURRENT EDC TO BE ASSIGNED OR NOT TO THE SET.

	IF p_IS_SELECTED = 0 THEN
		v_HOLIDAY_SET_ID := 0;
	ELSE
		v_HOLIDAY_SET_ID := p_HOLIDAY_SET_ID;
	END IF;

	UPDATE ENERGY_DISTRIBUTION_COMPANY
	SET EDC_HOLIDAY_SET_ID = v_HOLIDAY_SET_ID
	WHERE EDC_ID = p_EDC_ID;

END PUT_HOLIDAY_SET_EDC;
---------------------------------------------------------------------------------------------------

PROCEDURE HOLIDAY_SET_EDCS
	(
	p_HOLIDAY_SET_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the HOLIDAYS for the given SET.

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_HOLIDAY_SET_ID, EC.ED_HOLIDAY_SET);


	OPEN p_CURSOR FOR
		  SELECT EDC_ID,
		  		EDC_NAME,
				DECODE(EDC_HOLIDAY_SET_ID, p_HOLIDAY_SET_ID, 1, 0) AS IS_SELECTED
		  FROM ENERGY_DISTRIBUTION_COMPANY
		  WHERE EDC_ID > 0
		  ORDER BY 3 DESC, 2 ASC;


END HOLIDAY_SET_EDCS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_INCLUDED_HOLIDAY
	(
	p_HOLIDAY_SET_ID IN NUMBER,
	p_HOLIDAY_ID IN NUMBER,
	p_IS_SELECTED IN NUMBER
	) AS

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_HOLIDAY_SET_ID, EC.ED_HOLIDAY_SET);


	--DELETE THE CURRENT ASSIGNMENT IF NOT SELECTED.
	IF p_IS_SELECTED = 0 THEN
		DELETE FROM HOLIDAY_SCHEDULE
		WHERE HOLIDAY_SET_ID = p_HOLIDAY_SET_ID
			AND HOLIDAY_ID = p_HOLIDAY_ID;
	ELSE

		UPDATE HOLIDAY_SCHEDULE SET
			HOLIDAY_ID = p_HOLIDAY_ID
		WHERE HOLIDAY_SET_ID = p_HOLIDAY_SET_ID
			AND HOLIDAY_ID = p_HOLIDAY_ID;


		IF SQL%NOTFOUND THEN
			INSERT INTO HOLIDAY_SCHEDULE
				(
				HOLIDAY_SET_ID,
				HOLIDAY_ID
				)
			VALUES
				(
				p_HOLIDAY_SET_ID,
				p_HOLIDAY_ID
				);
		END IF;
	END IF;

END PUT_INCLUDED_HOLIDAY;
---------------------------------------------------------------------------------------------------
PROCEDURE INCLUDED_HOLIDAYS
	(
	p_HOLIDAY_SET_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the HOLIDAYS for the given SET.

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_HOLIDAY_SET_ID, EC.ED_HOLIDAY_SET);


	IF p_HOLIDAY_SET_ID = 0 THEN
		OPEN p_CURSOR FOR
			  SELECT HOLIDAY_ID, HOLIDAY_NAME, 0 AS IS_SELECTED
			  FROM HOLIDAY
			  ORDER BY 2 ASC;
	ELSE
		OPEN p_CURSOR FOR
		    SELECT A.HOLIDAY_ID,
		    	B.HOLIDAY_NAME,
		    	1 AS IS_SELECTED
			FROM HOLIDAY_SCHEDULE A, HOLIDAY B
			WHERE A.HOLIDAY_SET_ID = p_HOLIDAY_SET_ID
				AND A.HOLIDAY_ID = B.HOLIDAY_ID

			UNION

			SELECT HOLIDAY_ID,
				HOLIDAY_NAME,
				0 AS IS_SELECTED
			FROM HOLIDAY
			WHERE NOT HOLIDAY_ID IN (SELECT HOLIDAY_ID
										FROM HOLIDAY_SCHEDULE
										WHERE HOLIDAY_SET_ID = p_HOLIDAY_SET_ID)
			ORDER BY 3 DESC, 2 ASC;

	END IF;

END INCLUDED_HOLIDAYS;
---------------------------------------------------------------------------------------------------
PROCEDURE HOLIDAY_SCHEDULES
	(
	p_HOLIDAY_SET_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_HOLIDAY_SET_ID, EC.ED_HOLIDAY_SET);


	OPEN p_CURSOR FOR
		  SELECT B.HOLIDAY_NAME,
				C.HOLIDAY_YEAR,
				TO_CHAR(C.HOLIDAY_DATE, 'MM/DD') "HOLIDAY_DATE"
		  FROM HOLIDAY B, HOLIDAY_OBSERVANCE C, HOLIDAY_SCHEDULE D
		  WHERE D.HOLIDAY_SET_ID = p_HOLIDAY_SET_ID
		  	  AND B.HOLIDAY_ID = D.HOLIDAY_ID
			  AND C.HOLIDAY_ID = B.HOLIDAY_ID
		  ORDER BY 1,2,3;

END HOLIDAY_SCHEDULES;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_CHARGE_COMPONENT
	(
	p_COMPONENT_ID IN NUMBER,
	p_COMPONENT_NAME OUT VARCHAR2,
	p_COMPONENT_ALIAS OUT VARCHAR2,
	p_COMPONENT_DESC OUT VARCHAR2,
	p_COMPONENT_ENTITY OUT VARCHAR2,
	p_CHARGE_TYPE OUT VARCHAR2,
	p_RATE_STRUCTURE OUT VARCHAR2,
	p_RATE_INTERVAL OUT VARCHAR2,
	p_IS_REBILL OUT NUMBER,
	p_IS_TAXED OUT NUMBER,
	p_IS_CUSTOM_CHARGE OUT NUMBER,
	p_IS_CREDIT_CHARGE OUT NUMBER,
	p_IS_INCLUDE_TX_LOSS OUT NUMBER,
	p_IS_INCLUDE_DX_LOSS OUT NUMBER,
	p_TEMPLATE_ID OUT NUMBER,
	p_TEMPLATE_DISP OUT VARCHAR2,
	p_MARKET_PRICE_ID OUT NUMBER,
	p_MARKET_PRICE_DISP OUT VARCHAR2,
	p_SERVICE_POINT_ID OUT NUMBER,
	p_SERVICE_POINT_DISP OUT VARCHAR2,
	p_MODEL_ID OUT NUMBER,
	p_EVENT_ID OUT NUMBER,
	p_EVENT_DISP OUT VARCHAR2,
	p_COMPONENT_REFERENCE OUT VARCHAR2,
	p_INVOICE_GROUP_ID OUT NUMBER,
	p_INVOICE_GROUP_DISP OUT VARCHAR2,
	p_INVOICE_GROUP_ORDER OUT NUMBER,
	p_COMPUTATION_ORDER OUT NUMBER,
	p_QUANTITY_UNIT OUT VARCHAR2,
	p_CURRENCY_UNIT OUT VARCHAR2,
	p_QUANTITY_TYPE OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_COMPONENT_CATEGORY OUT VARCHAR2,
	p_GL_DEBIT_ACCOUNT OUT VARCHAR2,
	p_GL_CREDIT_ACCOUNT OUT VARCHAR2,
	p_FIRM_NON_FIRM OUT VARCHAR2,
	p_EXCLUDE_FROM_INVOICE OUT NUMBER,
	p_EXCLUDE_FROM_INVOICE_TOTAL OUT NUMBER,
	p_IMBALANCE_TYPE OUT VARCHAR2,
	p_ACCUMULATION_PERIOD OUT NUMBER,
	p_BASE_COMPONENT_ID OUT NUMBER,
	p_BASE_COMPONENT_DISP OUT VARCHAR2,
	p_BASE_LIMIT_ID OUT NUMBER,
	p_BASE_LIMIT_DISP OUT VARCHAR2,
	p_MARKET_TYPE OUT VARCHAR2,
	p_MARKET_PRICE_TYPE OUT VARCHAR2,
	p_WHICH_INTERVAL OUT VARCHAR2,
	p_LMP_PRICE_CALC OUT VARCHAR2,
	p_LMP_INCLUDE_EXT OUT NUMBER,
	p_LMP_INCLUDE_SALES OUT VARCHAR2,
	p_CHARGE_WHEN OUT VARCHAR2,
	p_BILATERALS_SIGN OUT NUMBER,
	p_LMP_COMMODITY_ID OUT NUMBER,
	p_LMP_COMMODITY_DISP OUT VARCHAR2,
	p_LMP_BASE_COMMODITY_ID OUT NUMBER,
	p_LMP_BASE_COMMODITY_DISP OUT VARCHAR2,
	p_USE_ZONAL_PRICE OUT NUMBER,
	p_ALTERNATE_PRICE OUT VARCHAR2,
	p_ALTERNATE_PRICE_FUNCTION OUT VARCHAR2,
	p_EXCLUDE_FROM_BILLING_EXPORT OUT NUMBER,
	p_IS_DEFAULT_TEMPLATE OUT NUMBER,
	p_KWH_MULTIPLIER OUT NUMBER,
	p_ANCILLARY_SERVICE_ID OUT NUMBER,
	p_ANCILLARY_SERVICE_DISP OUT VARCHAR2,
	p_PRODUCT_ID OUT NUMBER,
    p_APPLY_RATE_FOR OUT VARCHAR2,
	p_LOSS_ADJ_TYPE OUT NUMBER
	) AS
BEGIN
	EM_GET.COMPONENT(p_COMPONENT_ID => p_COMPONENT_ID,
                  p_COMPONENT_NAME => p_COMPONENT_NAME,
                  p_COMPONENT_ALIAS => p_COMPONENT_ALIAS,
                  p_COMPONENT_DESC => p_COMPONENT_DESC,
                  p_COMPONENT_ENTITY => p_COMPONENT_ENTITY,
                  p_CHARGE_TYPE => p_CHARGE_TYPE,
                  p_RATE_STRUCTURE => p_RATE_STRUCTURE,
                  p_RATE_INTERVAL => p_RATE_INTERVAL,
                  p_IS_REBILL => p_IS_REBILL,
                  p_IS_TAXED => p_IS_TAXED,
                  p_IS_CUSTOM_CHARGE => p_IS_CUSTOM_CHARGE,
                  p_IS_CREDIT_CHARGE => p_IS_CREDIT_CHARGE,
                  p_IS_INCLUDE_TX_LOSS => p_IS_INCLUDE_TX_LOSS,
                  p_IS_INCLUDE_DX_LOSS => p_IS_INCLUDE_DX_LOSS,
                  p_TEMPLATE_ID => p_TEMPLATE_ID,
                  p_TEMPLATE_DISP => p_TEMPLATE_DISP,
                  p_MARKET_PRICE_ID => p_MARKET_PRICE_ID,
                  p_MARKET_PRICE_DISP => p_MARKET_PRICE_DISP,
                  p_SERVICE_POINT_ID => p_SERVICE_POINT_ID,
                  p_SERVICE_POINT_DISP => p_SERVICE_POINT_DISP,
                  p_MODEL_ID => p_MODEL_ID,
                  p_EVENT_ID => p_EVENT_ID,
                  p_EVENT_DISP => p_EVENT_DISP,
                  p_COMPONENT_REFERENCE => p_COMPONENT_REFERENCE,
                  p_INVOICE_GROUp_ID => p_INVOICE_GROUp_ID,
                  p_INVOICE_GROUp_DISP => p_INVOICE_GROUp_DISP,
                  p_INVOICE_GROUp_ORDER => p_INVOICE_GROUp_ORDER,
                  p_COMPUTATION_ORDER => p_COMPUTATION_ORDER,
                  p_QUANTITY_UNIT => p_QUANTITY_UNIT,
                  p_CURRENCY_UNIT => p_CURRENCY_UNIT,
                  p_QUANTITY_TYPE => p_QUANTITY_TYPE,
                  p_EXTERNAL_IDENTIFIER => p_EXTERNAL_IDENTIFIER,
                  p_COMPONENT_CATEGORY => p_COMPONENT_CATEGORY,
                  p_GL_DEBIT_ACCOUNT => p_GL_DEBIT_ACCOUNT,
                  p_GL_CREDIT_ACCOUNT => p_GL_CREDIT_ACCOUNT,
                  p_FIRM_NON_FIRM => p_FIRM_NON_FIRM,
                  p_EXCLUDE_FROM_INVOICE => p_EXCLUDE_FROM_INVOICE,
                  p_EXCLUDE_FROM_INVOICE_TOTAL => p_EXCLUDE_FROM_INVOICE_TOTAL,
                  p_IMBALANCE_TYPE => p_IMBALANCE_TYPE,
                  p_ACCUMULATION_PERIOD => p_ACCUMULATION_PERIOD,
                  p_BASE_COMPONENT_ID => p_BASE_COMPONENT_ID,
                  p_BASE_COMPONENT_DISP => p_BASE_COMPONENT_DISP,
                  p_BASE_LIMIT_ID => p_BASE_LIMIT_ID,
                  p_BASE_LIMIT_DISP => p_BASE_LIMIT_DISP,
                  p_MARKET_TYPE => p_MARKET_TYPE,
                  p_MARKET_PRICE_TYPE => p_MARKET_PRICE_TYPE,
                  p_WHICH_INTERVAL => p_WHICH_INTERVAL,
                  p_LMp_PRICE_CALC => p_LMp_PRICE_CALC,
                  p_LMp_INCLUDE_EXT => p_LMp_INCLUDE_EXT,
                  p_LMp_INCLUDE_SALES => p_LMp_INCLUDE_SALES,
                  p_CHARGE_WHEN => p_CHARGE_WHEN,
                  p_BILATERALS_SIGN => p_BILATERALS_SIGN,
                  p_LMp_COMMODITY_ID => p_LMp_COMMODITY_ID,
                  p_LMp_COMMODITY_DISP => p_LMp_COMMODITY_DISP,
                  p_LMp_BASE_COMMODITY_ID => p_LMp_BASE_COMMODITY_ID,
                  p_LMp_BASE_COMMODITY_DISP => p_LMp_BASE_COMMODITY_DISP,
                  p_USE_ZONAL_PRICE => p_USE_ZONAL_PRICE,
                  p_ALTERNATE_PRICE => p_ALTERNATE_PRICE,
                  p_ALTERNATE_PRICE_FUNCTION => p_ALTERNATE_PRICE_FUNCTION,
                  p_EXCLUDE_FROM_BILLING_EXPORT => p_EXCLUDE_FROM_BILLING_EXPORT,
                  p_IS_DEFAULT_TEMPLATE => p_IS_DEFAULT_TEMPLATE,
                  p_KWH_MULTIPLIER => p_KWH_MULTIPLIER,
                  p_ANCILLARY_SERVICE_ID => p_ANCILLARY_SERVICE_ID,
                  p_ANCILLARY_SERVICE_DISP => p_ANCILLARY_SERVICE_DISP,
                  p_APPLY_RATE_FOR => p_APPLY_RATE_FOR,
				  p_LOSS_ADJ_TYPE => p_LOSS_ADJ_TYPE);
	BEGIN
		SELECT DISTINCT PRODUCT_ID
		INTO p_PRODUCT_ID
		FROM PRODUCT_COMPONENT
		WHERE COMPONENT_ID = p_COMPONENT_ID;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_PRODUCT_ID := NULL;
		WHEN TOO_MANY_ROWS THEN
			p_PRODUCT_ID := -1; -- multiple
	END;
END GET_CHARGE_COMPONENT;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_CHARGE_COMPONENT
	(
	o_OID OUT NUMBER,
	p_COMPONENT_NAME IN VARCHAR2,
	p_COMPONENT_ALIAS IN VARCHAR2,
	p_COMPONENT_DESC IN VARCHAR2,
	p_COMPONENT_ID IN NUMBER,
	p_COMPONENT_ENTITY IN VARCHAR2,
	p_CHARGE_TYPE IN VARCHAR2,
	p_RATE_STRUCTURE IN VARCHAR2,
	p_RATE_INTERVAL IN VARCHAR2,
	p_IS_REBILL IN NUMBER,
	p_IS_TAXED IN NUMBER,
	p_IS_CUSTOM_CHARGE IN NUMBER,
	p_IS_CREDIT_CHARGE IN NUMBER,
	p_IS_INCLUDE_TX_LOSS IN NUMBER,
	p_IS_INCLUDE_DX_LOSS IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_MARKET_PRICE_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_MODEL_ID IN NUMBER,
	p_EVENT_ID IN NUMBER,
	p_COMPONENT_REFERENCE IN VARCHAR2,
	p_INVOICE_GROUP_ID IN NUMBER,
	p_INVOICE_GROUP_ORDER IN NUMBER,
	p_COMPUTATION_ORDER IN NUMBER,
	p_QUANTITY_UNIT IN VARCHAR2,
	p_CURRENCY_UNIT IN VARCHAR2,
	p_QUANTITY_TYPE IN VARCHAR2,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_COMPONENT_CATEGORY IN VARCHAR2,
	p_GL_DEBIT_ACCOUNT IN VARCHAR2,
	p_GL_CREDIT_ACCOUNT IN VARCHAR2,
	p_FIRM_NON_FIRM IN VARCHAR2,
	p_EXCLUDE_FROM_INVOICE IN NUMBER,
	p_EXCLUDE_FROM_INVOICE_TOTAL IN NUMBER,
	p_IMBALANCE_TYPE IN VARCHAR2,
	p_ACCUMULATION_PERIOD IN NUMBER,
	p_BASE_COMPONENT_ID IN NUMBER,
	p_BASE_LIMIT_ID IN NUMBER,
	p_MARKET_TYPE IN VARCHAR2,
	p_MARKET_PRICE_TYPE IN VARCHAR2,
	p_WHICH_INTERVAL IN VARCHAR2,
	p_LMP_PRICE_CALC IN VARCHAR2,
	p_LMP_INCLUDE_EXT IN NUMBER,
	p_LMP_INCLUDE_SALES IN VARCHAR2,
	p_CHARGE_WHEN IN VARCHAR2,
	p_BILATERALS_SIGN IN NUMBER,
	p_LMP_COMMODITY_ID IN NUMBER,
	p_LMP_BASE_COMMODITY_ID IN NUMBER,
	p_USE_ZONAL_PRICE IN NUMBER,
	p_ALTERNATE_PRICE IN VARCHAR2,
	p_ALTERNATE_PRICE_FUNCTION IN VARCHAR2,
	p_EXCLUDE_FROM_BILLING_EXPORT IN NUMBER,
	p_IS_DEFAULT_TEMPLATE IN NUMBER,
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_KWH_MULTIPLIER IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
    p_APPLY_RATE_FOR IN VARCHAR2,
	p_LOSS_ADJ_TYPE IN NUMBER
	) AS

v_PRODUCT_IDS NUMBER_COLLECTION := NUMBER_COLLECTION();
v_ALLOWED_ENTITIES NUMBER_COLLECTION := NUMBER_COLLECTION();
v_NOT_ALLOWED_ENTITIES NUMBER_COLLECTION := NUMBER_COLLECTION();
v_COUNT NUMBER;
v_MESSAGE VARCHAR2(4000);
BEGIN

	IO.PUT_COMPONENT(
		o_OID,
		p_COMPONENT_NAME,
		p_COMPONENT_ALIAS,
		p_COMPONENT_DESC,
		p_COMPONENT_ID,
		p_COMPONENT_ENTITY,
		p_CHARGE_TYPE,
		p_RATE_STRUCTURE,
		p_RATE_INTERVAL,
		p_IS_REBILL,
		p_IS_TAXED,
		p_IS_CUSTOM_CHARGE,
		p_IS_CREDIT_CHARGE,
		p_IS_INCLUDE_TX_LOSS,
		p_IS_INCLUDE_DX_LOSS,
		p_TEMPLATE_ID,
		p_MARKET_PRICE_ID,
		p_SERVICE_POINT_ID,
		p_MODEL_ID,
		p_EVENT_ID,
		p_COMPONENT_REFERENCE,
		p_INVOICE_GROUP_ID,
		p_INVOICE_GROUP_ORDER,
		p_COMPUTATION_ORDER,
		p_QUANTITY_UNIT,
		p_CURRENCY_UNIT,
		p_QUANTITY_TYPE,
		p_EXTERNAL_IDENTIFIER,
		p_COMPONENT_CATEGORY,
		p_GL_DEBIT_ACCOUNT,
		p_GL_CREDIT_ACCOUNT,
		p_FIRM_NON_FIRM,
		p_EXCLUDE_FROM_INVOICE,
		p_EXCLUDE_FROM_INVOICE_TOTAL,
		p_IMBALANCE_TYPE,
		p_ACCUMULATION_PERIOD,
		p_BASE_COMPONENT_ID,
		p_BASE_LIMIT_ID,
		p_MARKET_TYPE,
		p_MARKET_PRICE_TYPE,
		p_WHICH_INTERVAL,
		p_LMP_PRICE_CALC,
		p_LMP_INCLUDE_EXT,
		p_LMP_INCLUDE_SALES,
		p_CHARGE_WHEN,
		p_BILATERALS_SIGN,
		p_LMP_COMMODITY_ID,
		p_LMP_BASE_COMMODITY_ID,
		p_USE_ZONAL_PRICE,
		p_ALTERNATE_PRICE,
		p_ALTERNATE_PRICE_FUNCTION,
		p_EXCLUDE_FROM_BILLING_EXPORT,
		p_IS_DEFAULT_TEMPLATE,
		p_KWH_MULTIPLIER,
		p_ANCILLARY_SERVICE_ID,
        p_APPLY_RATE_FOR,
		p_LOSS_ADJ_TYPE
		);

		IF o_OID > 0 THEN
			-- If we are saving one product link to the component
			IF NVL(p_PRODUCT_ID,CONSTANTS.NOT_ASSIGNED) NOT IN (CONSTANTS.NOT_ASSIGNED, -1) THEN
				-- Check if user can update the product
				SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_PRODUCT_ID, EC.ED_PRODUCT);

				-- Get all existing products linked to the component
				SELECT DISTINCT PC.PRODUCT_ID
				BULK COLLECT INTO v_PRODUCT_IDS
				FROM PRODUCT_COMPONENT PC
				WHERE PC.COMPONENT_ID = o_OID;

				-- Get the products that the user can update
				v_ALLOWED_ENTITIES := SD.GET_ALLOWED_IDS_FROM_SELECTION(SD.g_ACTION_UPDATE_ENT,EC.ED_PRODUCT,v_PRODUCT_IDS, FALSE);

				-- if all the products connected to component can be updated, then delete the links and update the
				-- product/component link with one entity.
				IF (v_ALLOWED_ENTITIES.COUNT = v_PRODUCT_IDS.COUNT) THEN
					-- Delete all product/component links except this Product
					DELETE FROM PRODUCT_COMPONENT PC
					WHERE PC.COMPONENT_ID = o_OID
                        AND PC.PRODUCT_ID <> p_PRODUCT_ID;

                    -- Determine if this relationship already exists
					SELECT COUNT(1)
					INTO v_COUNT
					FROM PRODUCT_COMPONENT PC
					WHERE PC.COMPONENT_ID = o_OID
                    AND PC.PRODUCT_ID = p_PRODUCT_ID;

					IF v_COUNT = 0 THEN
                        INSERT INTO PRODUCT_COMPONENT
                        	(PRODUCT_ID, COMPONENT_ID, BEGIN_DATE, END_DATE, ENTRY_DATE)
                        SELECT p_PRODUCT_ID, o_OID, P.BEGIN_DATE, NULL, SYSDATE
                           FROM PRODUCT P
					    WHERE P.PRODUCT_ID = p_PRODUCT_ID;
					END IF;

				ELSE
					-- Get values not allowed
					SELECT X.COLUMN_VALUE
					BULK COLLECT INTO v_NOT_ALLOWED_ENTITIES
					FROM (TABLE(CAST(v_PRODUCT_IDS as NUMBER_COLLECTION))) X
					MINUS
					SELECT Y.COLUMN_VALUE
					FROM (TABLE(CAST(v_ALLOWED_ENTITIES as NUMBER_COLLECTION))) Y ;

					v_COUNT := NVL(GET_DICTIONARY_VALUE('Referencing Entities Threshold', 0, 'Entity Manager'),5);
					v_MESSAGE := 'Could not update Product-Component assignments. User does not have sufficient privilege to update ';

					IF v_NOT_ALLOWED_ENTITIES.COUNT <= v_COUNT THEN
						v_MESSAGE := v_MESSAGE || TEXT_UTIL.TO_CHAR_ENTITY_LIST(v_NOT_ALLOWED_ENTITIES,
													   EC.ED_PRODUCT,
													   TRUE,
													   FALSE);
					ELSE
						v_MESSAGE := v_MESSAGE || 'all Product entities. See Process log for more details.';
						LOGS.LOG_ERROR(v_MESSAGE);
						LOGS.POST_EVENT_DETAILS('Entity List', CONSTANTS.MIME_TYPE_TEXT, TEXT_UTIL.TO_CLOB_ENTITY_LIST(v_NOT_ALLOWED_ENTITIES,EC.ED_PRODUCT));
					END IF;

					ERRS.RAISE(MSGCODES.c_ERR_PRIVILEGES, v_MESSAGE);
				END IF;
			END IF;
		END IF;

END PUT_CHARGE_COMPONENT;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_PRODUCT_COMPONENT
	(
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_PRODUCT_ID IN NUMBER,
	p_OLD_COMPONENT_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE
	) AS

v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_PRODUCT_ID, EC.ED_PRODUCT);

    v_KEY_NEW('PRODUCT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_PRODUCT_ID);
    v_KEY_OLD('PRODUCT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_PRODUCT_ID);
    v_KEY_NEW('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_COMPONENT_ID);
    v_KEY_OLD('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_COMPONENT_ID);

    UT.PUT_TEMPORAL_DATA_UI('PRODUCT_COMPONENT',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA
                            );

END PUT_PRODUCT_COMPONENT;

----------------------------------------------------------------------------------------------------
PROCEDURE PRODUCT_COMPONENTS
	(
	p_PRODUCT_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_PRODUCT_ID, EC.ED_PRODUCT);


	OPEN p_CURSOR FOR
		SELECT A.PRODUCT_ID, A.COMPONENT_ID, A.BEGIN_DATE, A.END_DATE, A.ENTRY_DATE
		FROM PRODUCT_COMPONENT A
		WHERE A.PRODUCT_ID = p_PRODUCT_ID
		ORDER BY BEGIN_DATE;

END PRODUCT_COMPONENTS;
----------------------------------------------------------------------------------------------------
PROCEDURE PRODUCT_COMPONENT_FOR_COMP
	(
	p_COMPONENT_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN
	-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);

	OPEN p_CURSOR FOR
		SELECT  A.PRODUCT_ID, A.BEGIN_DATE, A.END_DATE, A.ENTRY_DATE
		FROM PRODUCT_COMPONENT A
		WHERE A.COMPONENT_ID = p_COMPONENT_ID
		ORDER BY BEGIN_DATE;

END PRODUCT_COMPONENT_FOR_COMP;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_COMPONENT_PERCENTAGE
	(
	p_COMPONENT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PERCENT_VAL IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE
	)AS
CURSOR c_COMPONENT_PERCENTAGE IS
	SELECT *
	FROM COMPONENT_PERCENTAGE
	WHERE COMPONENT_ID = p_COMPONENT_ID
	ORDER BY BEGIN_DATE DESC;

v_COMPONENT_ID VARCHAR2(9);
v_PERCENT_VAL VARCHAR2(10);
v_COMPONENT_PERCENTAGE COMPONENT_PERCENTAGE%ROWTYPE;
v_INITIAL BOOLEAN;
v_END_DATE DATE;
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);
	v_END_DATE := NULL_DATE(p_END_DATE);

	v_COMPONENT_ID := UT.GET_LITERAL_FOR_NUMBER(p_COMPONENT_ID);
    v_PERCENT_VAL := UT.GET_LITERAL_FOR_NUMBER(p_PERCENT_VAL);

	UT.PUT_TEMPORAL_DATA_UI('COMPONENT_PERCENTAGE',
							p_BEGIN_DATE,
							p_END_DATE,
							p_OLD_BEGIN_DATE,
							TRUE,
							'COMPONENT_ID',
							v_COMPONENT_ID,
							v_COMPONENT_ID,
							TRUE,
							'PERCENT_VAL',
							v_PERCENT_VAL,
							NULL,
							FALSE
			);

	OPEN c_COMPONENT_PERCENTAGE;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_COMPONENT_PERCENTAGE INTO v_COMPONENT_PERCENTAGE;
		EXIT WHEN c_COMPONENT_PERCENTAGE%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_COMPONENT_PERCENTAGE.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE COMPONENT_PERCENTAGE
		SET END_DATE = GREATEST(v_END_DATE, v_COMPONENT_PERCENTAGE.BEGIN_DATE)
		WHERE COMPONENT_ID = v_COMPONENT_PERCENTAGE.COMPONENT_ID
			AND BEGIN_DATE = v_COMPONENT_PERCENTAGE.BEGIN_DATE;
		v_END_DATE := v_COMPONENT_PERCENTAGE.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_COMPONENT_PERCENTAGE;
END PUT_COMPONENT_PERCENTAGE;
----------------------------------------------------------------------------------------------------
PROCEDURE COMPONENT_PERCENTAGES
	(
	p_COMPONENT_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);


	OPEN p_CURSOR FOR
		SELECT A.COMPONENT_ID, A.PERCENT_VAL, A.BEGIN_DATE, A.END_DATE, A.ENTRY_DATE
		FROM COMPONENT_PERCENTAGE A
		WHERE A.COMPONENT_ID = p_COMPONENT_ID
		ORDER BY BEGIN_DATE;

END COMPONENT_PERCENTAGES;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_MARKET_FORWARD_PRICE
	(
	p_MARKET_PRICE_ID IN NUMBER,
	p_CONTRACT_MONTH IN DATE,
	p_CONTRACT_TYPE IN CHAR,
	p_CONTRACT_DATE IN DATE,
	p_BID_PRICE IN NUMBER,
	p_ASK_PRICE IN NUMBER,
	p_LOW_PRICE IN NUMBER,
	p_HIGH_PRICE IN NUMBER,
	p_OLD_CONTRACT_MONTH IN DATE,
	p_OLD_CONTRACT_TYPE IN CHAR,
	p_OLD_CONTRACT_DATE IN DATE
	) AS
v_CONTRACT_TYPE CHAR(1);
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_MARKET_PRICE_ID, EC.ED_MARKET_PRICE);

	v_CONTRACT_TYPE := SUBSTR(p_CONTRACT_TYPE, 1, 1);

-- UPDATE THE CURRENT ASSIGNMENT IF ONE EXISTS

	UPDATE MARKET_FORWARD_PRICE SET
		CONTRACT_MONTH = TRUNC(p_CONTRACT_MONTH, 'MM'),
		CONTRACT_TYPE = NVL(v_CONTRACT_TYPE, CONSTANTS.UNDEFINED_ATTRIBUTE),
		CONTRACT_DATE = TRUNC(p_CONTRACT_DATE),
		BID_PRICE = NVL(p_BID_PRICE,0),
		ASK_PRICE = NVL(p_ASK_PRICE,0),
		LOW_PRICE = NVL(p_LOW_PRICE,0),
		HIGH_PRICE = NVL(p_HIGH_PRICE,0),
		ENTRY_DATE = SYSDATE
	WHERE MARKET_PRICE_ID = p_MARKET_PRICE_ID
		AND CONTRACT_MONTH = TRUNC(p_OLD_CONTRACT_MONTH, 'MM')
		AND CONTRACT_TYPE = p_OLD_CONTRACT_TYPE
		AND CONTRACT_DATE = TRUNC(p_OLD_CONTRACT_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO MARKET_FORWARD_PRICE
			(
			MARKET_PRICE_ID,
			CONTRACT_MONTH,
			CONTRACT_TYPE,
			CONTRACT_DATE,
			BID_PRICE,
			ASK_PRICE,
			LOW_PRICE,
			HIGH_PRICE,
			ENTRY_DATE
			)
		VALUES
			(
			p_MARKET_PRICE_ID,
			TRUNC(p_CONTRACT_MONTH,'MM'),
			NVL(v_CONTRACT_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE),
			TRUNC(p_CONTRACT_DATE),
			NVL(p_BID_PRICE,0),
			NVL(p_ASK_PRICE,0),
			NVL(p_LOW_PRICE,0),
			NVL(p_HIGH_PRICE,0),
			SYSDATE
			);
	END IF;

END PUT_MARKET_FORWARD_PRICE;
---------------------------------------------------------------------------------------------------
PROCEDURE MARKET_FORWARD_PRICES
	(
	p_MARKET_PRICE_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
-- ANSWER THE APPROPRIATE ENTRIES IN MARKET_FORWARD_PRICE TABLE.
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_MARKET_PRICE_ID, EC.ED_MARKET_PRICE);

	OPEN p_CURSOR FOR
	    SELECT MARKET_PRICE_ID,
		  	 CONTRACT_MONTH,
			 CONTRACT_TYPE,
			 CONTRACT_DATE,
			 BID_PRICE,
			 ASK_PRICE,
			 LOW_PRICE,
			 HIGH_PRICE,
			 ENTRY_DATE
		FROM MARKET_FORWARD_PRICE
	   WHERE MARKET_PRICE_ID = p_MARKET_PRICE_ID
		ORDER BY CONTRACT_MONTH, CONTRACT_DATE, CONTRACT_TYPE;

END MARKET_FORWARD_PRICES;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_MARKET_PRICE_COMPOSITE
	(
	p_MARKET_PRICE_ID IN NUMBER,
	p_COMPOSITE_PRICE_ID IN NUMBER,
	p_COMPOSITE_MULTIPLIER IN NUMBER,
	p_COMPOSITE_OPTION IN VARCHAR,
	p_OLD_COMPOSITE_PRICE_ID IN NUMBER
	) AS
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_MARKET_PRICE_ID, EC.ED_MARKET_PRICE);
-- UPDATE AN EXISTING RECORD
	UPDATE MARKET_PRICE_COMPOSITE SET
		COMPOSITE_MARKET_PRICE_ID = p_COMPOSITE_PRICE_ID,
		COMPOSITE_MULTIPLIER = NVL(p_COMPOSITE_MULTIPLIER,1),
		COMPOSITE_OPTION = NVL(p_COMPOSITE_OPTION,CONSTANTS.UNDEFINED_ATTRIBUTE)
	WHERE MARKET_PRICE_ID = p_MARKET_PRICE_ID
		AND COMPOSITE_MARKET_PRICE_ID = p_OLD_COMPOSITE_PRICE_ID;
-- IF THE PREVIOUS UPDATE DID NOT FIND A MATCH, THEN INSERT A NEW RECORD
	IF SQL%NOTFOUND THEN
		INSERT INTO MARKET_PRICE_COMPOSITE (
			MARKET_PRICE_ID,
			COMPOSITE_MARKET_PRICE_ID,
			COMPOSITE_MULTIPLIER,
			COMPOSITE_OPTION)
		VALUES (
			p_MARKET_PRICE_ID,
			p_COMPOSITE_PRICE_ID,
			NVL(p_COMPOSITE_MULTIPLIER,1),
			NVL(p_COMPOSITE_OPTION,CONSTANTS.UNDEFINED_ATTRIBUTE));
	END IF;
END PUT_MARKET_PRICE_COMPOSITE;
----------------------------------------------------------------------------------------------------
PROCEDURE MARKET_PRICE_COMPOSITES
	(
	p_MARKET_PRICE_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
-- ANSWER THE MARKET_PRICE_ID, NAME, MULTIPLIER, AND OPTION OF THE APPROPRIATE ENTRIES IN MARKET_PRICE_COMPOSITE
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_MARKET_PRICE_ID, EC.ED_MARKET_PRICE);
	OPEN p_CURSOR FOR
		SELECT A.COMPOSITE_MARKET_PRICE_ID "COMPOSITE_PRICE_ID",
        	A.COMPOSITE_MULTIPLIER,
			A.COMPOSITE_OPTION,
            B.MARKET_PRICE_NAME AS COMPOSITE_PRICE_NAME
		FROM MARKET_PRICE_COMPOSITE A, MARKET_PRICE B
		WHERE A.MARKET_PRICE_ID = p_MARKET_PRICE_ID
			AND A.COMPOSITE_MARKET_PRICE_ID = B.MARKET_PRICE_ID
		ORDER BY COMPOSITE_PRICE_NAME;
END MARKET_PRICE_COMPOSITES;
---------------------------------------------------------------------------------------------------
PROCEDURE NON_COMPOSITE_MARKET_PRICES
	(
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
	OPEN p_CURSOR FOR
    	SELECT MARKET_PRICE_NAME, MARKET_PRICE_ID
		FROM MARKET_PRICE
        WHERE UPPER(SUBSTR(MARKET_PRICE_TYPE,1,9)) <> 'COMPOSITE'
        ORDER BY 2,1;
END NON_COMPOSITE_MARKET_PRICES;
---------------------------------------------------------------------------------------------------
PROCEDURE GEOGRAPHY_PARENT_LIST
	(
    p_GEOGRAPHY_TYPE IN VARCHAR2,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
	OPEN p_CURSOR FOR
    	SELECT DISTINCT GEOGRAPHY_NAME, GEOGRAPHY_ID
		FROM GEOGRAPHY A,
        	SYSTEM_LABEL B
        WHERE B.POSITION < (SELECT POSITION FROM SYSTEM_LABEL
        					WHERE MODEL_ID = 0
                            	AND MODULE = 'Product'
                                AND KEY1 = 'Geography'
                                AND KEY2 = 'Geography Types'
                                AND KEY3 = '?'
                                AND UPPER(VALUE) = UPPER(p_GEOGRAPHY_TYPE))
			AND A.GEOGRAPHY_TYPE = B.VALUE
        ORDER BY 2,1;
END GEOGRAPHY_PARENT_LIST;
---------------------------------------------------------------------------------------------------
PROCEDURE CONTACT_CATEGORYS
    (
    p_CONTACT_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_CONTACT_ID, EC.ED_CONTACT);

    OPEN p_CURSOR FOR
        SELECT A.CATEGORY_ID,
			A.CATEGORY_NAME,
			CASE WHEN B.CONTACT_ID IS NULL THEN 0 ELSE 1 END as IS_SELECTED,
            B.ENTRY_DATE
        FROM CATEGORY A, CONTACT_CATEGORY B
        WHERE B.CONTACT_ID(+) = p_CONTACT_ID
			AND B.CATEGORY_ID(+) = A.CATEGORY_ID
        ORDER BY A.CATEGORY_NAME;

END CONTACT_CATEGORYS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_CONTACT_CATEGORY
    (
    p_CONTACT_ID IN NUMBER,
    p_CATEGORY_ID IN NUMBER,
	p_IS_SELECTED IN NUMBER
    ) AS
v_COUNT PLS_INTEGER;
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_CONTACT_ID, EC.ED_CONTACT);

	IF NVL(p_IS_SELECTED,0) = 0 THEN
		-- not selected? remove relationship
		DX.REMOVE_CONTACT_CATEGORY(p_CONTACT_ID, p_CATEGORY_ID);
	ELSE
		-- selected? add a record
		SELECT COUNT(1)
		INTO v_COUNT
		FROM CONTACT_CATEGORY
		WHERE CONTACT_ID = p_CONTACT_ID
			AND CATEGORY_ID = p_CATEGORY_ID;

		IF v_COUNT = 0 THEN -- no such assignment? add it
			INSERT INTO CONTACT_CATEGORY (
				CONTACT_ID,
				CATEGORY_ID,
				ENTRY_DATE)
			VALUES (
				p_CONTACT_ID,
				p_CATEGORY_ID,
				SYSDATE);
		END IF;
    END IF;

END PUT_CONTACT_CATEGORY;
---------------------------------------------------------------------------------------------------
PROCEDURE ADDRESS_GEOGRAPHY_LIST
	(
	p_ANCESTOR_TYPE IN STRING_COLLECTION,
	p_ANCESTOR_NAME IN STRING_COLLECTION,
	p_ANCESTOR_ABBR IN NUMBER_COLLECTION,
    p_LIST_TYPE IN VARCHAR2,
    p_LIST_ABBR IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
v_GEOGRAPHY_ID NUMBER := 0;
v_IDX PLS_INTEGER;
BEGIN
	-- loop through specified ancestors to find first non-zero ID
	IF p_ANCESTOR_TYPE IS NOT NULL THEN
		v_IDX := p_ANCESTOR_TYPE.FIRST;
		WHILE p_ANCESTOR_TYPE.EXISTS(v_IDX) LOOP
			EXIT WHEN v_GEOGRAPHY_ID <> 0;

			BEGIN
				SELECT GEOGRAPHY_ID INTO v_GEOGRAPHY_ID
				FROM GEOGRAPHY
				WHERE GEOGRAPHY_TYPE = p_ANCESTOR_TYPE(v_IDX)
					AND CASE
						WHEN p_ANCESTOR_ABBR(v_IDX) = 0 THEN
							NVL(DISPLAY_NAME,GEOGRAPHY_NAME)
						ELSE
							NVL(ABBREVIATION,NVL(DISPLAY_NAME,GEOGRAPHY_NAME))
						END = p_ANCESTOR_NAME(v_IDX)
					AND ROWNUM=1;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					v_GEOGRAPHY_ID := 0;
			END;
			v_IDX := p_ANCESTOR_TYPE.NEXT(v_IDX);
		END LOOP;
	END IF;

	-- using that ID, enumerate all descendants of the specified type
	IF v_GEOGRAPHY_ID = 0 THEN
		-- ID of zero? then enumerate all of the specified type
		OPEN p_CURSOR FOR
    		SELECT CASE
		       		WHEN p_LIST_ABBR=0 THEN
	                	NVL(DISPLAY_NAME,GEOGRAPHY_NAME)
	                ELSE
	                	NVL(ABBREVIATION,NVL(DISPLAY_NAME,GEOGRAPHY_NAME))
	                END "NAME"
			FROM GEOGRAPHY
	        WHERE GEOGRAPHY_TYPE = p_LIST_TYPE
	        START WITH PARENT_GEOGRAPHY_ID = 0
	        CONNECT BY PRIOR GEOGRAPHY_ID = PARENT_GEOGRAPHY_ID
	        ORDER BY 1;
	ELSE
		OPEN p_CURSOR FOR
    		SELECT CASE
		       		WHEN p_LIST_ABBR=0 THEN
	                	NVL(DISPLAY_NAME,GEOGRAPHY_NAME)
	                ELSE
	                	NVL(ABBREVIATION,NVL(DISPLAY_NAME,GEOGRAPHY_NAME))
	                END "NAME"
			FROM GEOGRAPHY
	        WHERE GEOGRAPHY_TYPE = p_LIST_TYPE
	        START WITH GEOGRAPHY_ID = v_GEOGRAPHY_ID
	        CONNECT BY PRIOR GEOGRAPHY_ID = PARENT_GEOGRAPHY_ID
	        ORDER BY 1;
	END IF;

END ADDRESS_GEOGRAPHY_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_CONTACT_LIST
	(
	p_CATEGORY_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT B.CONTACT_NAME, B.CONTACT_ID
		FROM CONTACT_CATEGORY A, CONTACT B
		WHERE A.CATEGORY_ID = p_CATEGORY_ID
			AND B.CONTACT_ID = A.CONTACT_ID
		ORDER BY B.CONTACT_NAME;

END GET_CONTACT_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_CONTACT_INFO
	(
	p_CONTACT_ID IN NUMBER,
	p_EMAIL_ADDRESS OUT VARCHAR2,
	p_PHONE_NUMBER OUT VARCHAR2
	) AS

CURSOR cur_PHONES IS
	SELECT PHONE_TYPE||': '||PHONE_NUMBER as PHONE_NUMBER
	FROM (SELECT A.PHONE_TYPE, A.PHONE_NUMBER
		  FROM PHONE_NUMBER A, SYSTEM_LABEL B
		  WHERE A.CONTACT_ID = p_CONTACT_ID
			-- join to system label to determine sort order
			AND B.MODEL_ID = CONSTANTS.GLOBAL_MODEL
			AND B.MODULE = 'Entity Manager'
			AND B.KEY1 = 'Contact'
			AND B.KEY2 = 'Phone Types'
			AND B.KEY3 = '?'
			AND B.VALUE = A.PHONE_TYPE
		  ORDER BY B.POSITION ASC);
BEGIN
	BEGIN
		SELECT EMAIL_ADDRESS
		INTO p_EMAIL_ADDRESS
		FROM CONTACT
		WHERE CONTACT_ID = p_CONTACT_ID;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			-- Invalid contact ID? leave OUT parameters NULL
			RETURN;
	END;

	-- Get first phone number - use SYSTEM_LABEL.POSITION field
	-- to determine "priority" of phone numbers - used by
	-- ORDER BY to identify the "first" phone number
	FOR v_PHONE IN cur_PHONES LOOP
		IF p_PHONE_NUMBER IS NULL THEN
			p_PHONE_NUMBER := v_PHONE.PHONE_NUMBER;
		ELSE
			p_PHONE_NUMBER := p_PHONE_NUMBER||' **'; -- double asterisk indicates there are
													 -- other phone numbers defined for this
													 -- contact
			EXIT; -- exit loop
		END IF;
	END LOOP;

END GET_CONTACT_INFO;
----------------------------------------------------------------------------------------------------
PROCEDURE ENTITY_DOMAIN_CONTACTS
    (
	p_OWNER_ENTITY_DOMAIN_ID IN NUMBER,
	p_OWNER_ENTITY_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_OWNER_ENTITY_ID, p_OWNER_ENTITY_DOMAIN_ID);

    OPEN p_CURSOR FOR
        SELECT A.CATEGORY_ID,
			B.CATEGORY_NAME,
            A.CONTACT_ID,
			C.CONTACT_NAME,
            A.ENTRY_DATE
        FROM ENTITY_DOMAIN_CONTACT A, CATEGORY B, CONTACT C
        WHERE A.ENTITY_DOMAIN_ID = p_OWNER_ENTITY_DOMAIN_ID
			AND A.OWNER_ENTITY_ID = p_OWNER_ENTITY_ID
			AND B.CATEGORY_ID = A.CATEGORY_ID
			AND C.CONTACT_ID = A.CONTACT_ID
        ORDER BY B.CATEGORY_NAME, C.CONTACT_NAME;

END ENTITY_DOMAIN_CONTACTS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ENTITY_DOMAIN_CONTACT
    (
	p_OWNER_ENTITY_DOMAIN_ID IN NUMBER,
	p_OWNER_ENTITY_ID IN NUMBER,
	p_CATEGORY_ID IN NUMBER,
	p_CONTACT_ID IN NUMBER,
	p_OLD_CATEGORY_ID IN NUMBER,
	p_OLD_CONTACT_ID IN NUMBER
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_OWNER_ENTITY_ID, p_OWNER_ENTITY_DOMAIN_ID);

    UPDATE ENTITY_DOMAIN_CONTACT SET
        CATEGORY_ID = p_CATEGORY_ID,
        CONTACT_ID = p_CONTACT_ID,
        ENTRY_DATE = SYSDATE
    WHERE ENTITY_DOMAIN_ID = p_OWNER_ENTITY_DOMAIN_ID
        AND OWNER_ENTITY_ID = p_OWNER_ENTITY_ID
        AND CATEGORY_ID = p_OLD_CATEGORY_ID
        AND CONTACT_ID = p_OLD_CONTACT_ID;

    IF SQL%NOTFOUND THEN
        INSERT INTO ENTITY_DOMAIN_CONTACT (
            ENTITY_DOMAIN_ID,
            OWNER_ENTITY_ID,
            CATEGORY_ID,
            CONTACT_ID,
            ENTRY_DATE)
        VALUES (
            p_OWNER_ENTITY_DOMAIN_ID,
            p_OWNER_ENTITY_ID,
            p_CATEGORY_ID,
            p_CONTACT_ID,
            SYSDATE);
    END IF;

END PUT_ENTITY_DOMAIN_CONTACT;
----------------------------------------------------------------------------------------------------
PROCEDURE ENTITY_DOMAIN_ADDRESSES
    (
    p_OWNER_ENTITY_DOMAIN_ID IN NUMBER,
	p_OWNER_ENTITY_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_OWNER_ENTITY_ID, p_OWNER_ENTITY_DOMAIN_ID);

    OPEN p_CURSOR FOR
        SELECT A.CATEGORY_ID,
			A.CATEGORY_NAME,
            B.STREET,
			B.STREET2,
			-- translate GEOGRAPHY_ID into the various elements
			(SELECT NVL(DISPLAY_NAME,GEOGRAPHY_NAME)
			 FROM GEOGRAPHY
			 WHERE GEOGRAPHY_TYPE = 'City'
				AND ROWNUM = 1
			 START WITH GEOGRAPHY_ID = B.GEOGRAPHY_ID
			 CONNECT BY PRIOR PARENT_GEOGRAPHY_ID = GEOGRAPHY_ID) as CITY,
			(SELECT NVL(ABBREVIATION,NVL(DISPLAY_NAME,GEOGRAPHY_NAME))
			 FROM GEOGRAPHY
			 WHERE GEOGRAPHY_TYPE = 'State/Province'
				AND ROWNUM = 1
			 START WITH GEOGRAPHY_ID = B.GEOGRAPHY_ID
			 CONNECT BY PRIOR PARENT_GEOGRAPHY_ID = GEOGRAPHY_ID) as STATE_CODE,
			(SELECT NVL(DISPLAY_NAME,GEOGRAPHY_NAME)
			 FROM GEOGRAPHY
			 WHERE GEOGRAPHY_TYPE = 'Postal Code'
				AND ROWNUM = 1
			 START WITH GEOGRAPHY_ID = B.GEOGRAPHY_ID
			 CONNECT BY PRIOR PARENT_GEOGRAPHY_ID = GEOGRAPHY_ID) as POSTAL_CODE,
			(SELECT NVL(ABBREVIATION,NVL(DISPLAY_NAME,GEOGRAPHY_NAME))
			 FROM GEOGRAPHY
			 WHERE GEOGRAPHY_TYPE = 'Country'
				AND ROWNUM = 1
			 START WITH GEOGRAPHY_ID = B.GEOGRAPHY_ID
			 CONNECT BY PRIOR PARENT_GEOGRAPHY_ID = GEOGRAPHY_ID) as COUNTRY_CODE,
            B.ENTRY_DATE
        FROM CATEGORY A, ENTITY_DOMAIN_ADDRESS B
        WHERE B.CATEGORY_ID(+) = A.CATEGORY_ID
			AND B.ENTITY_DOMAIN_ID(+) = p_OWNER_ENTITY_DOMAIN_ID
			AND B.OWNER_ENTITY_ID(+) = p_OWNER_ENTITY_ID
		ORDER BY A.CATEGORY_NAME;

END ENTITY_DOMAIN_ADDRESSES;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ENTITY_DOMAIN_ADDRESS
    (
    p_OWNER_ENTITY_DOMAIN_ID IN NUMBER,
    p_OWNER_ENTITY_ID IN NUMBER,
    p_CATEGORY_ID IN NUMBER,
	p_STREET IN VARCHAR2,
	p_STREET2 IN VARCHAR2,
	p_CITY IN VARCHAR2,
	p_STATE_CODE IN VARCHAR2,
	p_POSTAL_CODE IN VARCHAR2,
	p_COUNTRY_CODE IN VARCHAR2,
    p_OLD_CATEGORY_ID IN NUMBER
    ) AS
v_GEOGRAPHY_ID NUMBER;
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_OWNER_ENTITY_ID, p_OWNER_ENTITY_DOMAIN_ID);

	IF p_CITY IS NULL AND p_STATE_CODE IS NULL AND p_POSTAL_CODE IS NULL AND p_COUNTRY_CODE IS NULL THEN
		-- nothing specified? then NULL geography
		v_GEOGRAPHY_ID := NULL;
	ELSE
		-- translate parameters into a Geography ID
		ID.ID_FOR_GEOGRAPHY(p_CITY,p_STATE_CODE,p_POSTAL_CODE,p_COUNTRY_CODE,TRUE,v_GEOGRAPHY_ID);
	END IF;

	IF p_STREET IS NULL AND v_GEOGRAPHY_ID IS NULL THEN
		-- everything blank? remove this address
		DX.REMOVE_ENTITY_DOMAIN_ADDRESS(p_OWNER_ENTITY_DOMAIN_ID, p_OWNER_ENTITY_ID, p_CATEGORY_ID);
	ELSE

		UPDATE ENTITY_DOMAIN_ADDRESS SET
			CATEGORY_ID = p_CATEGORY_ID,
			STREET = p_STREET,
			STREET2 = p_STREET2,
			GEOGRAPHY_ID = v_GEOGRAPHY_ID,
			ENTRY_DATE = SYSDATE
		WHERE ENTITY_DOMAIN_ID = p_OWNER_ENTITY_DOMAIN_ID
			AND OWNER_ENTITY_ID = p_OWNER_ENTITY_ID
			AND CATEGORY_ID = p_OLD_CATEGORY_ID;

		IF SQL%NOTFOUND THEN
			INSERT INTO ENTITY_DOMAIN_ADDRESS (
				ENTITY_DOMAIN_ID,
				OWNER_ENTITY_ID,
				CATEGORY_ID,
				STREET,
				STREET2,
				GEOGRAPHY_ID,
				ENTRY_DATE)
			VALUES (
				p_OWNER_ENTITY_DOMAIN_ID,
				p_OWNER_ENTITY_ID,
				p_CATEGORY_ID,
				p_STREET,
				p_STREET2,
				v_GEOGRAPHY_ID,
				SYSDATE);
		END IF;

	END IF;

END PUT_ENTITY_DOMAIN_ADDRESS;
----------------------------------------------------------------------------------------------------
PROCEDURE ENTITY_ATTRIBUTE_VALUES
	(
	p_OWNER_ENTITY_DOMAIN_ID IN NUMBER,
	p_OWNER_ENTITY_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_OWNER_ENTITY_ID, p_OWNER_ENTITY_DOMAIN_ID);

	OPEN p_CURSOR FOR
		SELECT A.ATTRIBUTE_ID,
			B.ATTRIBUTE_NAME,
			A.ATTRIBUTE_VAL,
			A.BEGIN_DATE,
			A.END_DATE,
			A.ENTRY_DATE,
			B.ATTRIBUTE_TYPE
		FROM TEMPORAL_ENTITY_ATTRIBUTE A,
			ENTITY_ATTRIBUTE B
		WHERE B.ENTITY_DOMAIN_ID = p_OWNER_ENTITY_DOMAIN_ID
			AND A.OWNER_ENTITY_ID = p_OWNER_ENTITY_ID
			AND A.ENTITY_DOMAIN_ID = p_OWNER_ENTITY_DOMAIN_ID
			AND A.ATTRIBUTE_ID = B.ATTRIBUTE_ID
		UNION ALL
		SELECT B.ATTRIBUTE_ID, B.ATTRIBUTE_NAME, NULL "ATTRIBUTE_VAL", NULL "BEGIN_DATE", NULL "END_DATE", NULL "ENTRY_DATE", B.ATTRIBUTE_TYPE
		FROM ENTITY_ATTRIBUTE B
		WHERE B.ENTITY_DOMAIN_ID = p_OWNER_ENTITY_DOMAIN_ID
			AND B.ATTRIBUTE_SHOW = 1
			AND NOT EXISTS (SELECT 1 FROM TEMPORAL_ENTITY_ATTRIBUTE X
							WHERE X.OWNER_ENTITY_ID = p_OWNER_ENTITY_ID
							AND X.ATTRIBUTE_ID = B.ATTRIBUTE_ID)
		ORDER BY ATTRIBUTE_NAME, BEGIN_DATE;

END ENTITY_ATTRIBUTE_VALUES;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ENTITY_ATTRIBUTE
	(
	p_OWNER_ENTITY_DOMAIN_ID IN NUMBER,
	p_ATTRIBUTE_NAME IN VARCHAR2,
	p_ATTRIBUTE_ID IN NUMBER,
	p_ATTRIBUTE_TYPE IN VARCHAR2,
	p_ATTRIBUTE_SHOW IN NUMBER
	) AS
v_OID NUMBER(9);
BEGIN

-- FIRST TRY TO UPDATE AN EXISTING ENTITY ATTRIBUTE FOR THE OWNING ENTITY
	IF p_ATTRIBUTE_ID > 0 THEN
		UPDATE ENTITY_ATTRIBUTE SET
			ATTRIBUTE_NAME = p_ATTRIBUTE_NAME,
			ATTRIBUTE_TYPE = p_ATTRIBUTE_TYPE,
			ATTRIBUTE_SHOW = p_ATTRIBUTE_SHOW,
			ENTRY_DATE = SYSDATE
		WHERE ENTITY_DOMAIN_ID = p_OWNER_ENTITY_DOMAIN_ID
			AND ATTRIBUTE_ID = p_ATTRIBUTE_ID;
	ELSE

-- IF THE UPDATE FAILED TO FIND AN EXISTING ENTITY THEN INSERT A NEW ENTITY
		SELECT OID.NEXTVAL INTO v_OID FROM DUAL;
		INSERT INTO ENTITY_ATTRIBUTE (
			ENTITY_DOMAIN_ID,
			ATTRIBUTE_NAME,
			ATTRIBUTE_ID,
			ATTRIBUTE_TYPE,
			ATTRIBUTE_SHOW,
			ENTRY_DATE)
		VALUES (
			p_OWNER_ENTITY_DOMAIN_ID,
			p_ATTRIBUTE_NAME,
			v_OID,
			p_ATTRIBUTE_TYPE,
			p_ATTRIBUTE_SHOW,
			SYSDATE);
	END IF;
	EXCEPTION
		WHEN OTHERS THEN
			ERRS.LOG_AND_RAISE();
END PUT_ENTITY_ATTRIBUTE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ENTITY_ATTRIBUTE_VALUE
	(
	p_OWNER_ENTITY_DOMAIN_ID IN NUMBER,
	p_OWNER_ENTITY_ID IN NUMBER,
	p_ATTRIBUTE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ATTRIBUTE_VAL IN VARCHAR2,
	p_OLD_OWNER_ENTITY_ID IN NUMBER,
	p_OLD_ATTRIBUTE_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE
	) AS
v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
BEGIN
	-- no-op
	IF p_BEGIN_DATE IS NULL AND p_END_DATE IS NULL AND p_ATTRIBUTE_VAL IS NULL AND p_OLD_BEGIN_DATE IS NULL THEN
		-- sometimes happen when copying an entity - this gets called w/ no data
		RETURN;
	END IF;

-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_OWNER_ENTITY_ID, p_OWNER_ENTITY_DOMAIN_ID);

    v_KEY_NEW('OWNER_ENTITY_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OWNER_ENTITY_ID);
    v_KEY_OLD('OWNER_ENTITY_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_OWNER_ENTITY_ID);
    v_KEY_NEW('ATTRIBUTE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_ATTRIBUTE_ID);
    v_KEY_OLD('ATTRIBUTE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_ATTRIBUTE_ID);
    v_DATA('ENTITY_DOMAIN_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OWNER_ENTITY_DOMAIN_ID);
    v_DATA('ATTRIBUTE_VAL') := UT.GET_LITERAL_FOR_STRING(p_ATTRIBUTE_VAL);

    UT.PUT_TEMPORAL_DATA_UI('TEMPORAL_ENTITY_ATTRIBUTE',
                            NVL(p_BEGIN_DATE,LOW_DATE),
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

END PUT_ENTITY_ATTRIBUTE_VALUE;
---------------------------------------------------------------------------------------------------
PROCEDURE EXTERNAL_SYSTEM_LIST
	(
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN

    OPEN p_CURSOR FOR
        SELECT A.EXTERNAL_SYSTEM_NAME, A.EXTERNAL_SYSTEM_ID
        FROM EXTERNAL_SYSTEM A
        WHERE A.IS_ENABLED = 1
        ORDER BY 1;

END EXTERNAL_SYSTEM_LIST;
---------------------------------------------------------------------------------------------------
PROCEDURE EXTERNAL_SYSTEM_LIST_ALL
	(
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
    OPEN p_CURSOR FOR
		SELECT '<ALL>' as EXTERNAL_SYSTEM_NAME, -1 as EXTERNAL_SYSTEM_ID
		FROM DUAL
		UNION ALL
		SELECT EXTERNAL_SYSTEM_NAME, EXTERNAL_SYSTEM_ID
		FROM (SELECT A.EXTERNAL_SYSTEM_NAME, A.EXTERNAL_SYSTEM_ID
                FROM EXTERNAL_SYSTEM A
                WHERE A.IS_ENABLED = 1
                ORDER BY 1);

END EXTERNAL_SYSTEM_LIST_ALL;
---------------------------------------------------------------------------------------------------
PROCEDURE EXTERNAL_SYSTEM_IDENTIFIERS
  (
	p_OWNER_ENTITY_DOMAIN_ID IN NUMBER,
	p_OWNER_ENTITY_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
  ) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT A.EXTERNAL_SYSTEM_ID, NVL(B.IDENTIFIER_TYPE,'Default') "IDENTIFIER_TYPE", B.EXTERNAL_IDENTIFIER
		FROM EXTERNAL_SYSTEM A, EXTERNAL_SYSTEM_IDENTIFIER B
		WHERE A.EXTERNAL_SYSTEM_ID = B.EXTERNAL_SYSTEM_ID(+)
    AND A.IS_ENABLED = 1
    AND B.ENTITY_ID(+) = p_OWNER_ENTITY_ID
    AND B.ENTITY_DOMAIN_ID(+) = p_OWNER_ENTITY_DOMAIN_ID
		ORDER BY 1;
END EXTERNAL_SYSTEM_IDENTIFIERS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_EXTERNAL_SYSTEM_IDENTIFIER
	(
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_OWNER_ENTITY_DOMAIN_ID IN NUMBER,
	p_OWNER_ENTITY_ID IN NUMBER,
	p_IDENTIFIER_TYPE IN VARCHAR2,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_OLD_IDENTIFIER_TYPE IN VARCHAR2
	) AS
BEGIN

	IF p_EXTERNAL_IDENTIFIER IS NULL THEN
    -- CLEAR AN EXISTING ENTRY
      DELETE EXTERNAL_SYSTEM_IDENTIFIER
      WHERE
         ENTITY_DOMAIN_ID = p_OWNER_ENTITY_DOMAIN_ID
         AND ENTITY_ID = p_OWNER_ENTITY_ID
         AND IDENTIFIER_TYPE = p_OLD_IDENTIFIER_TYPE
         AND EXTERNAL_SYSTEM_ID = p_EXTERNAL_SYSTEM_ID;
	ELSE
    -- UPDATE AN EXISTING RECORD
      UPDATE EXTERNAL_SYSTEM_IDENTIFIER A
      SET
         A.IDENTIFIER_TYPE = p_IDENTIFIER_TYPE,
         A.EXTERNAL_IDENTIFIER = p_EXTERNAL_IDENTIFIER
      WHERE
         A.ENTITY_DOMAIN_ID = p_OWNER_ENTITY_DOMAIN_ID
         AND A.ENTITY_ID = p_OWNER_ENTITY_ID
         AND A.IDENTIFIER_TYPE = p_OLD_IDENTIFIER_TYPE
         AND A.EXTERNAL_SYSTEM_ID = p_EXTERNAL_SYSTEM_ID;

    -- IF THE PREVIOUS UPDATE DID NOT FIND A MATCH, THEN INSERT A NEW RECORD.
    	IF SQL%NOTFOUND THEN
    		INSERT INTO EXTERNAL_SYSTEM_IDENTIFIER(
		EXTERNAL_SYSTEM_ID,
        ENTITY_DOMAIN_ID,
        ENTITY_ID,
        IDENTIFIER_TYPE,
        EXTERNAL_IDENTIFIER,
        ENTRY_DATE)
    		VALUES (
          		p_EXTERNAL_SYSTEM_ID,
    			p_OWNER_ENTITY_DOMAIN_ID,
    			p_OWNER_ENTITY_ID,
    			p_IDENTIFIER_TYPE,
    			p_EXTERNAL_IDENTIFIER,
    			SYSDATE);
    	END IF;
	END IF;

END PUT_EXTERNAL_SYSTEM_IDENTIFIER;
---------------------------------------------------------------------------------------------------
PROCEDURE ENTITY_ATTRIBUTES_FOR_DOMAIN
	(
	p_OWNER_ENTITY_DOMAIN_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT ATTRIBUTE_NAME, ATTRIBUTE_ID, ATTRIBUTE_TYPE, ATTRIBUTE_SHOW
		FROM ENTITY_ATTRIBUTE
		WHERE ENTITY_DOMAIN_ID = p_OWNER_ENTITY_DOMAIN_ID
		ORDER BY 1;
END ENTITY_ATTRIBUTES_FOR_DOMAIN;
---------------------------------------------------------------------------------------------------
PROCEDURE LIST_TEMPLATES
	(
	p_SEARCH_STRING IN VARCHAR,
	p_SEARCH_OPTION IN VARCHAR,
	p_SEARCH_TYPE	IN NUMBER,
	p_FIND_ENTITY_ID IN NUMBER,
	p_ACTION_NAME IN VARCHAR2,
	p_IS_DAY_TYPE IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	)
	AS

-- Answer the given entities
v_IDs ID_TABLE;
v_DOMAIN_ID NUMBER(9) := CASE WHEN p_IS_DAY_TYPE = 1 THEN EC.ED_DAY_TYPE_TEMPLATE ELSE EC.ED_TEMPLATE END;

BEGIN

	--Make sure user has appropriate access.
	IF p_ACTION_NAME IS NULL THEN
		v_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(EN.g_DEFAULT_ACTION_NAME,v_DOMAIN_ID);
	ELSE
		v_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(p_ACTION_NAME,v_DOMAIN_ID);
	END IF;

	IF NVL(p_SEARCH_TYPE, CONSTANTS.SEARCH_TYPE_NORMAL) = CONSTANTS.SEARCH_TYPE_NORMAL THEN
		IF p_SEARCH_STRING = '%' OR p_SEARCH_STRING IS NULL THEN

			OPEN p_CURSOR FOR
			SELECT
				A.TEMPLATE_NAME "ENTITY_NAME",
				A.TEMPLATE_ID "ENTITY_ID",
				A.TEMPLATE_ALIAS "ENTITY_ALIAS",
				'Active' "ENTITY_STATUS"
			FROM TEMPLATE A, TABLE(CAST(v_IDs AS ID_TABLE)) IDs
			WHERE IDs.ID IN (A.TEMPLATE_ID, SD.g_ALL_DATA_ENTITY_ID)
				AND NVL(A.IS_DAY_TYPE,0) = p_IS_DAY_TYPE
			ORDER BY DECODE(NVL(p_SEARCH_OPTION,CONSTANTS.SEARCH_OPTION_BY_NAME), CONSTANTS.SEARCH_OPTION_BY_NAME, TEMPLATE_NAME, TEMPLATE_ALIAS);

		ELSE

			OPEN p_CURSOR FOR
			SELECT
				A.TEMPLATE_NAME "ENTITY_NAME",
				A.TEMPLATE_ID "ENTITY_ID",
				A.TEMPLATE_ALIAS "ENTITY_ALIAS",
				'Active' "ENTITY_STATUS"
			FROM TEMPLATE A, TABLE(CAST(v_IDs AS ID_TABLE)) IDs
			WHERE IDs.ID IN (A.TEMPLATE_ID, SD.g_ALL_DATA_ENTITY_ID)
				AND NVL(A.IS_DAY_TYPE,0) = p_IS_DAY_TYPE
				AND ((p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_NAME
						AND TEMPLATE_NAME LIKE p_SEARCH_STRING)
                    OR (p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_ALIAS
						AND TEMPLATE_ALIAS LIKE p_SEARCH_STRING))
			ORDER BY DECODE(p_SEARCH_OPTION, CONSTANTS.SEARCH_OPTION_BY_NAME, TEMPLATE_NAME, TEMPLATE_ALIAS);

		END IF;

        -- Specific Value
	ELSIF p_SEARCH_TYPE = CONSTANTS.SEARCH_TYPE_BY_VAL THEN

		OPEN p_CURSOR FOR
		SELECT
			A.TEMPLATE_NAME "ENTITY_NAME",
			A.TEMPLATE_ID "ENTITY_ID",
			A.TEMPLATE_ALIAS "ENTITY_ALIAS",
			'Active' "ENTITY_STATUS"
		FROM TEMPLATE A, TABLE(CAST(v_IDs AS ID_TABLE)) IDs
		WHERE IDs.ID IN (A.TEMPLATE_ID, SD.g_ALL_DATA_ENTITY_ID)
			AND NVL(A.IS_DAY_TYPE,0) = p_IS_DAY_TYPE
			AND A.TEMPLATE_ID = p_FIND_ENTITY_ID;

	END IF;

END LIST_TEMPLATES;
---------------------------------------------------------------------------------------------------
PROCEDURE LIST_TEMPLATES
	(
	p_SEARCH_STRING IN VARCHAR,
	p_SEARCH_OPTION IN VARCHAR,
	p_SEARCH_TYPE	IN NUMBER,
	p_FIND_ENTITY_ID IN NUMBER,
	p_ACTION_NAME IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	)
	AS
BEGIN
	LIST_TEMPLATES(p_SEARCH_STRING, p_SEARCH_OPTION,
					p_SEARCH_TYPE, p_FIND_ENTITY_ID, p_ACTION_NAME,
					0, p_CURSOR);
END LIST_TEMPLATES;
----------------------------------------------------------------------------------------------------
PROCEDURE LIST_DAY_TYPE_TEMPLATES
	(
	p_SEARCH_STRING IN VARCHAR,
	p_SEARCH_OPTION IN VARCHAR,
	p_SEARCH_TYPE	IN NUMBER,
	p_FIND_ENTITY_ID IN NUMBER,
	p_ACTION_NAME IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	)
	AS
BEGIN
	LIST_TEMPLATES(p_SEARCH_STRING, p_SEARCH_OPTION,
					p_SEARCH_TYPE, p_FIND_ENTITY_ID, p_ACTION_NAME,
					1, p_CURSOR);
END LIST_DAY_TYPE_TEMPLATES;
----------------------------------------------------------------------------------------------------
PROCEDURE DOMAIN_ENTITY_ATTRIBUTES
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the CONTRACTs for the given ACCOUNT.

BEGIN
	 OPEN p_CURSOR FOR
	    SELECT ATTRIBUTE_ID, ATTRIBUTE_NAME, ATTRIBUTE_TYPE, ATTRIBUTE_SHOW
		FROM ENTITY_ATTRIBUTE
		WHERE ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID
		ORDER BY 2;

END DOMAIN_ENTITY_ATTRIBUTES;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_DOMAIN_ENTITY_ATTRIBUTE
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ATTRIBUTE_ID IN NUMBER,
	p_ATTRIBUTE_NAME IN VARCHAR2,
	p_ATTRIBUTE_TYPE IN VARCHAR2,
	p_ATTRIBUTE_SHOW IN NUMBER
	)
	AS
v_ATTRIBUTE_ID NUMBER(9) := NVL(p_ATTRIBUTE_ID, 0);
BEGIN

	SP.PUT_ENTITY_ATTRIBUTE(v_ATTRIBUTE_ID, p_ENTITY_DOMAIN_ID, p_ATTRIBUTE_NAME, v_ATTRIBUTE_ID, p_ATTRIBUTE_TYPE, p_ATTRIBUTE_SHOW);

END PUT_DOMAIN_ENTITY_ATTRIBUTE;
----------------------------------------------------------------------------------------------------
PROCEDURE PATH_SEGMENTS
	(
	p_PATH_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_PATH_ID, EC.ED_PATH);


	OPEN p_CURSOR FOR
	   SELECT A.SEGMENT_POS, A.SEGMENT_ID
		FROM TX_PATH_SEGMENT A
		WHERE A.PATH_ID = p_PATH_ID
		ORDER BY 1;

END PATH_SEGMENTS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_PATH_SEGMENT
	(
	p_PATH_ID IN NUMBER,
	p_SEGMENT_ID IN NUMBER,
	p_SEGMENT_POS IN NUMBER,
	p_OLD_SEGMENT_ID IN NUMBER,
	p_OLD_SEGMENT_POS IN NUMBER
	)
	AS

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_PATH_ID, EC.ED_PATH);


-- UPDATE THE CURRENT SSIGNMENT IF ONE EXISTS

	UPDATE TX_PATH_SEGMENT SET
		SEGMENT_ID = p_SEGMENT_ID,
		SEGMENT_POS = p_SEGMENT_POS
	WHERE PATH_ID = p_PATH_ID
		AND SEGMENT_ID = p_OLD_SEGMENT_ID
		AND SEGMENT_POS = p_OLD_SEGMENT_POS;

-- NO ASSIGNMENT UPDATE FOR THIS COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO TX_PATH_SEGMENT
			(
			PATH_ID,
			SEGMENT_ID,
			SEGMENT_POS
			)
		VALUES
			(
			p_PATH_ID,
			p_SEGMENT_ID,
			p_SEGMENT_POS
			);
	END IF;

END PUT_PATH_SEGMENT;

---------------------------------------------------------------------------------------------------
PROCEDURE SYSTEM_ACTION_ROLES
	(
	p_ACTION_ID IN NUMBER,
    p_ENTITY_DOMAIN_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ACTION_ID, EC.ED_SYSTEM_ACTION);


    -- If the Entity Domain for the Action is not All and specific to one particular
    -- Domain, then the Realm Role Subtab will have only Role and Realm COlumns which
    -- can be modified. So the Action is applicable to
    -- this particular. We then define which user has access to which Realms in this domain
    -- table.  In this case, the Realm Column will query on
    -- the Enitity Domain Id specified for this Action.

    IF p_ENTITY_DOMAIN_ID != -1 THEN
		OPEN p_CURSOR FOR
	   	SELECT A.ROLE_ID, A.REALM_ID
		FROM SYSTEM_ACTION_ROLE A
		WHERE A.ACTION_ID = p_ACTION_ID
			AND A.ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID
		ORDER BY 1;


    -- Now If the Entity Domain Id for the Action is ALL. Basically, that means
    -- that the Action is applicable to all domains. Then we have to specify which
    -- Role can access what realms. Here, we have an addition column
    -- ENTITY_DOMAIN_ID which can be used to filter the Realm Column. Otherwise,
    -- we will have to figure which domain the realm belongs to and then come back
    -- and pick the realms.

	ELSE
		-- return no rows
		OPEN p_CURSOR FOR
			SELECT NULL ROLE_ID, NULL REALM_ID
			FROM DUAL
			WHERE 0 = 1;
    END IF;

END SYSTEM_ACTION_ROLES;
---------------------------------------------------------------------------------------------------
PROCEDURE SYSTEM_ACTION_ROLES_DOMAIN
	(
	p_ACTION_ID IN NUMBER,
    p_ENTITY_DOMAIN_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN

    -- If the Entity Domain for the Action is not All and specific to one particular
    -- Domain, then the Realm Role Subtab will have only Role and Realm COlumns which
    -- can be modified. So the Action is applicable to
    -- this particular. We then define which user has access to which Realms in this domain
    -- table.  In this case, the Realm Column will query on
    -- the Enitity Domain Id specified for this Action.
    -- Now If the Entity Domain Id for the Action is ALL. Basically, that means
    -- that the Action is applicable to all domains. Then we have to specify which
    -- Role can access what realms. Here, we have an addition column
    -- ENTITY_DOMAIN_ID which can be used to filter the Realm Column. Otherwise,
    -- we will have to figure which domain the realm belongs to and then come back
    -- and pick the realms.

	IF p_ENTITY_DOMAIN_ID = -1 THEN

        OPEN p_CURSOR FOR
        SELECT A.ROLE_ID, A.REALM_ID, A.ENTITY_DOMAIN_ID "DOMAIN_ID"
        FROM SYSTEM_ACTION_ROLE A
        WHERE A.ACTION_ID = p_ACTION_ID
    	ORDER BY 1;
	ELSE
		-- return no rows
		OPEN p_CURSOR FOR
			SELECT NULL ROLE_ID, NULL REALM_ID, NULL DOMAIN_ID
			FROM DUAL
			WHERE 0 = 1;
    END IF;

END SYSTEM_ACTION_ROLES_DOMAIN;
-------------------------------------------------------------------------------------------------------------------------------
PROCEDURE PUT_SYSTEM_ACTION_ROLE
	(
	p_ACTION_ID IN NUMBER,
	p_ROLE_ID IN NUMBER,
	p_REALM_ID IN NUMBER,
    p_ENTITY_DOMAIN_ID IN NUMBER,
	p_OLD_ROLE_ID IN NUMBER,
	p_OLD_REALM_ID IN NUMBER,
    p_OLD_ENTITY_DOMAIN_ID IN NUMBER
	)
	AS

	v_CURR_USR_IN_ROLE BOOLEAN;
	v_HAS_REALM NUMBER(9) := 0;

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACTION_ID, EC.ED_SYSTEM_ACTION);

    -- CHECK IF REALM WAS SET TO BLANK (NVL)
    -- ABG -- 6/5/8 -- BZ 14908
    -- p_REALM_ID is null in the table when it's not assigned, this is a problem when
    -- a user does a fill on the table using the unassigned cell as a start point
    IF NVL(p_REALM_ID, -1) = -1 THEN
		IF p_OLD_ROLE_ID = p_ROLE_ID AND
 		   NVL(p_OLD_ENTITY_DOMAIN_ID,SD.g_ALL_ENTITY_DOMAINS_ID) = NVL(p_ENTITY_DOMAIN_ID,SD.g_ALL_ENTITY_DOMAINS_ID)
		THEN

        	DELETE FROM SYSTEM_ACTION_ROLE A
            WHERE A.ACTION_ID = p_ACTION_ID
                AND A.ROLE_ID = p_OLD_ROLE_ID
                AND A.ENTITY_DOMAIN_ID = NVL(p_OLD_ENTITY_DOMAIN_ID,SD.g_ALL_ENTITY_DOMAINS_ID)
				AND A.REALM_ID = p_OLD_REALM_ID;

		END IF;
    ELSE

		v_CURR_USR_IN_ROLE := UT.ID_TABLE_CONTAINS(SECURITY_CONTROLS.CURRENT_ROLES,
							p_ROLE_ID);

		-- USER IS ATTEMPTING TO EDIT PRIVILEGES FOR A ROLE TO WHICH
		-- THEY BELONG, CHECK TO SEE THAT THEY'RE NOT ESCELATING THEIR PRIVS
		-- DON'T DO THIS IF THE USER IS A SUPER_USER
		IF v_CURR_USR_IN_ROLE AND SECURITY_CONTROLS.IS_SUPER_USER = 0 THEN
			-- DO THEY HAVE ANOTHER ROLE WHICH HAS ALL_DATA, OR THE REALM TRYING
			-- TO ADD TO THIS ROLE?

			SELECT COUNT(1) INTO v_HAS_REALM
			FROM SYSTEM_ACTION_ROLE SA,
				TABLE(CAST (SECURITY_CONTROLS.CURRENT_ROLES AS ID_TABLE)) ROLES
			WHERE SA.ROLE_ID = ROLES.ID AND
				SA.ACTION_ID = p_ACTION_ID AND
				SA.ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID AND
				SA.REALM_ID IN (SD.g_ALL_DATA_REALM_ID, p_REALM_ID);

			IF v_HAS_REALM = 0 THEN
				ERRS.RAISE(MSGCODES.c_ERR_ALTER_PRIVS);
			END IF;

		END IF;

		-- UPDATE THE CURRENT ASSIGNMENT IF ONE EXISTS

			UPDATE SYSTEM_ACTION_ROLE SET
				ROLE_ID = p_ROLE_ID,
				REALM_ID = p_REALM_ID,
                ENTITY_DOMAIN_ID = NVL(p_ENTITY_DOMAIN_ID,SD.g_ALL_ENTITY_DOMAINS_ID),
				ENTRY_DATE = SYSDATE
			WHERE ACTION_ID = p_ACTION_ID
				AND ROLE_ID = p_OLD_ROLE_ID
				AND REALM_ID = p_OLD_REALM_ID
                AND ENTITY_DOMAIN_ID = NVL(p_OLD_ENTITY_DOMAIN_ID,SD.g_ALL_ENTITY_DOMAINS_ID);

		-- NO ASSIGNMENT UPDATE FOR THIS COMBINATION SO INSERT A NEW ASSIGNMENT

			IF SQL%NOTFOUND THEN
				INSERT INTO SYSTEM_ACTION_ROLE
				(
				ACTION_ID,
				ROLE_ID,
				REALM_ID,
                ENTITY_DOMAIN_ID,
				ENTRY_DATE
				)
				VALUES
				(
				p_ACTION_ID,
				p_ROLE_ID,
				p_REALM_ID,
                NVL(p_ENTITY_DOMAIN_ID,SD.g_ALL_ENTITY_DOMAINS_ID),
				SYSDATE
				);
			END IF;
	END IF;

END PUT_SYSTEM_ACTION_ROLE;

---------------------------------------------------------------------------------------------------

PROCEDURE PUT_SYSTEM_ACTION_DOMAIN
	(
    p_ACTION_ID IN NUMBER,
	p_ROLE_ID IN NUMBER,
	p_REALM_ID IN NUMBER,
    p_DOMAIN_ID IN NUMBER,
	p_OLD_ROLE_ID IN NUMBER,
	p_OLD_REALM_ID IN NUMBER,
    p_OLD_DOMAIN_ID IN NUMBER
	)
	AS
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACTION_ID, EC.ED_SYSTEM_ACTION);

    -- CHECK IF REALM WAS SET TO BLANK
    IF p_REALM_ID = -1 THEN
        	DELETE FROM SYSTEM_ACTION_ROLE A
            WHERE A.ACTION_ID = p_ACTION_ID
            AND A.ROLE_ID = p_ROLE_ID
            AND A.ENTITY_DOMAIN_ID = p_DOMAIN_ID;
    ELSE
		-- UPDATE THE CURRENT ASSIGNMENT IF ONE EXISTS

			UPDATE SYSTEM_ACTION_ROLE SET
				ROLE_ID = p_ROLE_ID,
				REALM_ID = p_REALM_ID,
                ENTITY_DOMAIN_ID = p_DOMAIN_ID,
				ENTRY_DATE = SYSDATE
			WHERE ACTION_ID = p_ACTION_ID
				AND ROLE_ID = p_OLD_ROLE_ID
				AND REALM_ID = p_OLD_REALM_ID
                AND ENTITY_DOMAIN_ID = p_OLD_DOMAIN_ID;

		-- NO ASSIGNMENT UPDATE FOR THIS COMBINATION SO INSERT A NEW ASSIGNMENT

			IF SQL%NOTFOUND THEN
				INSERT INTO SYSTEM_ACTION_ROLE
				(
				ACTION_ID,
				ROLE_ID,
				REALM_ID,
				ENTRY_DATE,
                ENTITY_DOMAIN_ID
				)
				VALUES
				(
				p_ACTION_ID,
				p_ROLE_ID,
				p_REALM_ID,
				SYSDATE,
                p_DOMAIN_ID
				);
			END IF;
	END IF;

END PUT_SYSTEM_ACTION_DOMAIN;
------------------------------------------------------------------------------------------------------------------------
FUNCTION ESCAPE_MARKUP_CHARS
	(
	p_VAL IN VARCHAR2
	) RETURN VARCHAR2 IS
BEGIN
	RETURN REPLACE(REPLACE(REPLACE(REPLACE(p_VAL,CHR(38),CHR(38)||'amp;'),'<',CHR(38)||'lt;'),'>',CHR(38)||'gt;'),'"',CHR(38)||'quot;');
END ESCAPE_MARKUP_CHARS;
------------------------------------------------------------------------------------------------------------------------
PROCEDURE ENTITY_COLUMNS
	(
	p_REALM_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
	)
	AS

v_COLUMN_VALS VARCHAR2(4000) := NULL;
CURSOR c_COLS IS
    SELECT A.ENTITY_COLUMN, A.IS_EXCLUDING_VALS
	FROM SYSTEM_REALM_COLUMN A
    WHERE A.REALM_ID = p_REALM_ID;
v_COL_VALS GA.REFCURSOR;
v_ENTITY_COL_ID VARCHAR2(64);
v_ENTITY_COL_VAL VARCHAR2(64);
v_IS_EXCLUDING_VALS NUMBER(1);
v_VALS_ARE_IDs NUMBER(1);
v_ALLOW_REFS NUMBER(1);
v_IS_UNAVAILABLE NUMBER := 0;
v_IS_SELECTED NUMBER;
v_STATUS NUMBER;
v_COLUMN_VALS_ARRAY ENTITY_SUBTAB_COLS_TABLE := ENTITY_SUBTAB_COLS_TABLE();

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_REALM_ID, EC.ED_SYSTEM_REALM);

    -- This procedure needs to return the
	FOR v_COL IN c_COLS LOOP
		SD.GET_ENTITY_COL_VALS(p_REALM_ID, v_COL.ENTITY_COLUMN, 1, v_IS_EXCLUDING_VALS, v_VALS_ARE_IDs, v_ALLOW_REFS, v_COL_VALS);
		IF NVL(v_STATUS,0) = 0 THEN
			-- only process rows if procedure call returned success
			LOOP
				FETCH v_COL_VALS INTO v_IS_SELECTED, v_IS_UNAVAILABLE, v_ENTITY_COL_ID, v_ENTITY_COL_VAL;
				EXIT WHEN v_COL_VALS%NOTFOUND;

				-- filter out invalid values - i.e. only add this value
				-- if either it is not an identifier references or if references are allowed.

				IF v_ALLOW_REFS <> 0 OR SUBSTR(v_ENTITY_COL_VAL,1,2) <> '${' THEN
					v_ENTITY_COL_VAL := ESCAPE_MARKUP_CHARS(v_ENTITY_COL_VAL);
					IF NVL(v_IS_UNAVAILABLE,0) <> 0 THEN
						v_ENTITY_COL_VAL := '<strike>'||v_ENTITY_COL_VAL||'</strike>';
					END IF;

					IF v_COLUMN_VALS IS NULL THEN
						v_COLUMN_VALS := '<html><body>';
					ELSE
						v_COLUMN_VALS := v_COLUMN_VALS || ', ';
					END IF;
					v_COLUMN_VALS := v_COLUMN_VALS || v_ENTITY_COL_VAL;
				END IF;
			END LOOP;
		END IF;

		-- clean up cursor
		BEGIN
			CLOSE v_COL_VALS;
		EXCEPTION
			WHEN OTHERS THEN
				NULL; -- ignore error here
		END;

		IF v_COLUMN_VALS IS NOT NULL THEN
			v_COLUMN_VALS := v_COLUMN_VALS || '</body></html>';
		END IF;

		v_COLUMN_VALS_ARRAY.EXTEND();
		v_COLUMN_VALS_ARRAY(v_COLUMN_VALS_ARRAY.LAST) := ENTITY_SUBTAB_COLS_TYPE(v_COL.ENTITY_COLUMN,v_COL.IS_EXCLUDING_VALS,v_COLUMN_VALS);
		v_COLUMN_VALS := '';
	END LOOP;

	OPEN p_CURSOR FOR
    	SELECT ENTITY_COLUMN,
				IS_EXCLUDING_VALS,
				COLUMN_VALS AS COLUMN_VALUE_NAMES,
				1 AS AVAILABLE
        FROM TABLE(CAST(v_COLUMN_VALS_ARRAY AS ENTITY_SUBTAB_COLS_TABLE)) T
    	ORDER BY 1;

EXCEPTION
	WHEN OTHERS THEN
		IF v_COL_VALS%ISOPEN THEN
			CLOSE v_COL_VALS;
		END IF;
		RAISE;
END ENTITY_COLUMNS;
-----------------------------------------------------------------------------------------------------------------

PROCEDURE PUT_ENTITY_COLUMN
	(
    p_REALM_ID IN NUMBER,
    p_ENTITY_COLUMN IN VARCHAR2,
    p_IS_EXCLUDING_VALS IN NUMBER,
    p_OLD_ENTITY_COLUMN IN VARCHAR2
    ) AS

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_REALM_ID, EC.ED_SYSTEM_REALM);


    UPDATE SYSTEM_REALM_COLUMN SET
        	ENTITY_COLUMN = p_ENTITY_COLUMN,
            IS_EXCLUDING_VALS = NVL(p_IS_EXCLUDING_VALS,0),
			-- reset column values if a different column name has been chosen
			COLUMN_VALS = CASE WHEN UPPER(LTRIM(RTRIM(p_OLD_ENTITY_COLUMN))) != UPPER(LTRIM(RTRIM(p_ENTITY_COLUMN))) THEN
									SD.c_EMPTY_COLUMN_VALS
								ELSE
									COLUMN_VALS
								END
        WHERE REALM_ID = p_REALM_ID AND
           	ENTITY_COLUMN = p_OLD_ENTITY_COLUMN;

    -- Not able to update an existing row, so insert the new row.
    IF SQL%NOTFOUND THEN

    		INSERT INTO SYSTEM_REALM_COLUMN
                (
                REALM_ID,
                ENTITY_COLUMN,
                IS_EXCLUDING_VALS,
                COLUMN_VALS,
                ENTRY_DATE
                )
             VALUES
             	(
             	p_REALM_ID,
                p_ENTITY_COLUMN,
                NVL(p_IS_EXCLUDING_VALS,0),
                SD.c_EMPTY_COLUMN_VALS,
                SYSDATE
                );
    END IF;

END PUT_ENTITY_COLUMN;
--------------------------------------------------------------------------------------------------------
PROCEDURE HEAT_RATE_CURVE_POINTS
	(
	p_HEAT_RATE_CURVE_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_HEAT_RATE_CURVE_ID, EC.ED_HEAT_RATE_CURVE);


	OPEN p_CURSOR FOR
	   SELECT A.PARAMETER_1_VAL, A.PARAMETER_2_VAL, A.PARAMETER_3_VAL,
	   		A.AMOUNT, A.OPERATING_MODE, A.PRICE, A.ENTRY_DATE
		FROM HEAT_RATE_CURVE_POINT A
		WHERE A.HEAT_RATE_CURVE_ID = p_HEAT_RATE_CURVE_ID
		ORDER BY 1;

END HEAT_RATE_CURVE_POINTS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_HEAT_RATE_CURVE_POINT
	(
	p_HEAT_RATE_CURVE_ID IN NUMBER,
	p_PARAMETER_1_VAL IN NUMBER,
	p_PARAMETER_2_VAL IN NUMBER,
	p_PARAMETER_3_VAL IN NUMBER,
	p_AMOUNT IN NUMBER,
	p_OPERATING_MODE IN VARCHAR2,
	p_PRICE IN NUMBER,
	p_OLD_PARAMETER_1_VAL IN NUMBER,
	p_OLD_PARAMETER_2_VAL IN NUMBER,
	p_OLD_PARAMETER_3_VAL IN NUMBER,
	p_OLD_AMOUNT IN NUMBER,
	p_OLD_OPERATING_MODE IN VARCHAR2
	)
	AS

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_HEAT_RATE_CURVE_ID, EC.ED_HEAT_RATE_CURVE);


-- UPDATE THE CURRENT SSIGNMENT IF ONE EXISTS

	UPDATE HEAT_RATE_CURVE_POINT SET
		PARAMETER_1_VAL = p_PARAMETER_1_VAL,
		PARAMETER_2_VAL = p_PARAMETER_2_VAL,
		PARAMETER_3_VAL = p_PARAMETER_3_VAL,
		AMOUNT = p_AMOUNT,
		OPERATING_MODE = p_OPERATING_MODE,
		PRICE = p_PRICE,
		ENTRY_DATE = SYSDATE
	WHERE HEAT_RATE_CURVE_ID = p_HEAT_RATE_CURVE_ID
		AND PARAMETER_1_VAL = p_OLD_PARAMETER_1_VAL
		AND PARAMETER_2_VAL = p_OLD_PARAMETER_2_VAL
		AND PARAMETER_3_VAL = p_OLD_PARAMETER_3_VAL
		AND AMOUNT = p_OLD_AMOUNT
		AND OPERATING_MODE = p_OLD_OPERATING_MODE		;

-- NO ASSIGNMENT UPDATE FOR THIS COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO HEAT_RATE_CURVE_POINT
			(
			HEAT_RATE_CURVE_ID,
			PARAMETER_1_VAL,
			PARAMETER_2_VAL,
			PARAMETER_3_VAL,
			AMOUNT,
			OPERATING_MODE,
			PRICE,
			ENTRY_DATE
			)
		VALUES
			(
			p_HEAT_RATE_CURVE_ID,
			p_PARAMETER_1_VAL,
			p_PARAMETER_2_VAL,
			p_PARAMETER_3_VAL,
			p_AMOUNT,
			p_OPERATING_MODE,
			p_PRICE,
			SYSDATE
			);
	END IF;

END PUT_HEAT_RATE_CURVE_POINT;

---------------------------------------------------------------------------------------------------
PROCEDURE TRANSACTION_LIMITS
	(
	p_TRANSACTION_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_TRANSACTION_ID, EC.ED_TRANSACTION);


	OPEN p_CURSOR FOR
		SELECT A.BEGIN_DATE,
			A.END_DATE,
			A.LIMIT_INTERVAL,
			A.MIN_TRANSACTION_ID,
			A.LIMIT_TRANSACTION_ID,
			A.ENTRY_DATE
		FROM INTERCHANGE_TRANSACTION_LIMIT A
		WHERE A.TRANSACTION_ID = p_TRANSACTION_ID
		ORDER BY A.BEGIN_DATE, A.END_DATE;

END TRANSACTION_LIMITS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_TRANSACTION_LIMIT
	(
	p_TRANSACTION_ID IN NUMBER,
	p_LIMIT_INTERVAL IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_MIN_TRANSACTION_ID IN NUMBER,
	p_LIMIT_TRANSACTION_ID IN NUMBER,
	p_OLD_LIMIT_INTERVAL IN VARCHAR2,
	p_OLD_BEGIN_DATE IN DATE
	) AS

v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_TRANSACTION_ID, EC.ED_TRANSACTION);

	v_KEY_NEW('TRANSACTION_ID') := UT.GET_LITERAL_FOR_NUMBER(p_TRANSACTION_ID);
    v_KEY_OLD('TRANSACTION_ID') := UT.GET_LITERAL_FOR_NUMBER(p_TRANSACTION_ID);
	v_KEY_NEW('LIMIT_INTERVAL') := UT.GET_LITERAL_FOR_STRING(p_LIMIT_INTERVAL);
	v_KEY_OLD('LIMIT_INTERVAL') := UT.GET_LITERAL_FOR_STRING(p_OLD_LIMIT_INTERVAL);
    v_DATA('MIN_TRANSACTION_ID') := UT.GET_LITERAL_FOR_NUMBER(p_MIN_TRANSACTION_ID);
	v_DATA('LIMIT_TRANSACTION_ID') := UT.GET_LITERAL_FOR_NUMBER(p_LIMIT_TRANSACTION_ID);

	UT.PUT_TEMPORAL_DATA_UI('INTERCHANGE_TRANSACTION_LIMIT',
			p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

END PUT_TRANSACTION_LIMIT;
----------------------------------------------------------------------------------------------------
PROCEDURE SYSTEM_ALERT_ROLES
	(
	p_ALERT_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the WEATHER_STATION_PARAMETERS's for the given STATION.

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ALERT_ID, EC.ED_SYSTEM_ALERT);

	OPEN p_CURSOR FOR
	    SELECT A.ROLE_ID,
	    	B.ROLE_NAME,
	    	1 "IS_SELECTED",
			A.ALERT_ID "ALERT_ID",
      A.EMAIL_REC_TYPE
		FROM SYSTEM_ALERT_ROLE A, APPLICATION_ROLE B
		WHERE A.ALERT_ID = p_ALERT_ID
			AND A.ROLE_ID = B.ROLE_ID
			AND A.ROLE_ID > 0

		UNION ALL

		SELECT ROLE_ID,
			ROLE_NAME,
			0 "IS_SELECTED",
			p_ALERT_ID "SYSTEM_ALERT_ID",
      '' "EMAIL_REC_TYPE"
		FROM APPLICATION_ROLE
		WHERE NOT ROLE_ID IN (SELECT ROLE_ID
									FROM SYSTEM_ALERT_ROLE
									WHERE ALERT_ID = p_ALERT_ID)
			AND ROLE_ID > 0

		ORDER BY 3 DESC, 2 ASC;

END SYSTEM_ALERT_ROLES;
---------------------------------------------------------------------------------------------------

PROCEDURE PUT_SYSTEM_ALERT_ROLE
	(
	p_ALERT_ID IN NUMBER,
	p_ROLE_ID IN NUMBER,
	p_IS_SELECTED IN NUMBER,
	p_EMAIL_REC_TYPE IN VARCHAR2
	)
	AS
  v_EMAIL_REC_TYPE VARCHAR2(10);
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ALERT_ID, EC.ED_SYSTEM_ALERT);

  IF TRIM(p_EMAIL_REC_TYPE) IS NULL THEN
     v_EMAIL_REC_TYPE := 'TO';
  ELSE
     v_EMAIL_REC_TYPE := p_EMAIL_REC_TYPE;
  END IF;


	--DELETE THE CURRENT ASSIGNMENT IF NOT SELECTED.
	IF p_IS_SELECTED = 0 THEN
		DELETE FROM SYSTEM_ALERT_ROLE
		WHERE ALERT_ID = p_ALERT_ID
			AND ROLE_ID = p_ROLE_ID;
	ELSE
	-- UPDATE THE CURRENT ACCOUNT ASSIGNMENT IF ONE EXISTS

		UPDATE SYSTEM_ALERT_ROLE SET
			ROLE_ID = p_ROLE_ID,
      EMAIL_REC_TYPE = TRIM(Upper(v_EMAIL_REC_TYPE))
		WHERE ALERT_ID = p_ALERT_ID
			AND ROLE_ID = p_ROLE_ID;

	-- NO ASSIGNMENT UPDATE FOR THIS ACCOUNT AND COMBINATION SO INSERT A NEW ASSIGNMENT

		IF SQL%NOTFOUND THEN
			INSERT INTO SYSTEM_ALERT_ROLE
				(
				ALERT_ID,
				ROLE_ID,
        EMAIL_REC_TYPE
				)
			VALUES
				(
				p_ALERT_ID,
				p_ROLE_ID,
        TRIM(Upper(v_EMAIL_REC_TYPE))
				);
		END IF;
	END IF;

END PUT_SYSTEM_ALERT_ROLE;
---------------------------------------------------------------------------------------------------

PROCEDURE ETAG_MARKET_SEGMENTS
	(
	p_ETAG_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

	-- Return Market Segment cursor

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ETAG_ID, EC.ED_ETAG);


	OPEN p_CURSOR FOR
        SELECT

    		MARKET_SEGMENT_NID  MARKET_SEGMENT_ID,
    		PS.TAG_CODE "PSE",
            PD.CODE "PRODUCT CODE",
    		NULL  "CONTRACT",  -- CONTRACT_NUMBER_LIST_ID
    		NULL  "MISC",  -- MISC_INFO_LIST_ID
    		CURRENT_CORRECTION_NID  CURRENT_CORRECTION_ID
        FROM ETAG_MARKET_SEGMENT MS, TSIN_PSE_REGISTRY PS, TSIN_PRODUCT_REGISTRY PD
        WHERE ETAG_ID = p_ETAG_ID -- 100 --
			AND PS.TAGGING_ENTITY_ID(+) = MS.PSE_CODE
			AND PD.PRODUCTID(+) = MS.ENERGY_PRODUCT_REF
    	ORDER BY MARKET_SEGMENT_NID;



END ETAG_MARKET_SEGMENTS;
----------------------------------------------------------------------------------------------------
PROCEDURE ETAG_PHYSICAL_SEGMENTS
	(
	p_ETAG_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

	-- Return Physical Segment cursor
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ETAG_ID, EC.ED_ETAG);


	OPEN p_CURSOR FOR
        -- Resource (Generation or Load) Segment
		SELECT

    		RS.MARKET_SEGMENT_NID  MARKET_SEGMENT_ID,
    		RS.PHYSICAL_SEGMENT_NID  PHYSICAL_SEGMENT_ID,
    		RS.SEGMENT_TYPE,
			NULL  "CA",  --
			NULL  "TP",  --
			PS.TAG_CODE  "PSE",
			NULL  "POR_CODE",  --
			NULL  "POD_CODE",  --
    		NULL  "CONTRACT",  -- CONTRACT_NUMBER_LIST_ID
    		NULL  "MISC",  -- MISC_INFO_LIST_ID
    		RS.CURRENT_CORRECTION_NID  CURRENT_CORRECTION_ID
        FROM ETAG_RESOURCE_SEGMENT RS, ETAG_MARKET_SEGMENT MS, TSIN_PSE_REGISTRY PS  -- , ETAG_RESOURCE R
        WHERE RS.ETAG_ID = p_ETAG_ID -- 100 --
			AND MS.MARKET_SEGMENT_NID = RS.MARKET_SEGMENT_NID
			AND PS.TAGGING_ENTITY_ID(+) = MS.PSE_CODE
		UNION
        --Transmission Segment
        SELECT
    		TS.MARKET_SEGMENT_NID  MARKET_SEGMENT_ID,
    		TS.PHYSICAL_SEGMENT_NID  PHYSICAL_SEGMENT_ID,
    		TS.SEGMENT_TYPE,
			NULL  "CA",  --
			NULL  "TP",  --
			PS.TAG_CODE  "PSE",  --
            POR.POINTNAME POR_CODE,
			POD.POINTNAME POD_CODE,
    		NULL  "CONTRACT",  -- CONTRACT_NUMBER_LIST_ID
    		NULL  "MISC",  -- MISC_INFO_LIST_ID
    		TS.CURRENT_CORRECTION_NID  CURRENT_CORRECTION_ID
        FROM ETAG_TRANSMISSION_SEGMENT TS, ETAG_MARKET_SEGMENT MS, TSIN_PSE_REGISTRY PS,  TSIN_POR_POD_POINT POR,  TSIN_POR_POD_POINT POD
        WHERE TS.ETAG_ID = p_ETAG_ID -- 100 --
			AND PS.TAGGING_ENTITY_ID(+) = MS.PSE_CODE
			AND MS.MARKET_SEGMENT_NID = TS.MARKET_SEGMENT_NID
			AND POR.PORPODPOINTID(+) = TS.POR_CODE
			AND POD.PORPODPOINTID(+) = TS.POD_CODE
    	ORDER BY MARKET_SEGMENT_ID,PHYSICAL_SEGMENT_ID;



END ETAG_PHYSICAL_SEGMENTS;
----------------------------------------------------------------------------------------------------
PROCEDURE ETAG_PROFILES
	(
	p_ETAG_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ETAG_ID, EC.ED_ETAG);


	OPEN p_CURSOR FOR
        SELECT
    		P.PARENT_TYPE "USED BY",
            P.PROFILE_STYLE "USE TYPE",
    		P.PARENT_NID "PARENT ID",
    		V.START_DATE,
    		V.END_DATE,
    		V.MW_LEVEL MW
        FROM ETAG_PROFILE P, ETAG_PROFILE_VALUE V
        WHERE  ETAG_ID = p_ETAG_ID -- 100 --
            AND P.PROFILE_KEY_ID = V.PROFILE_KEY_ID
    	ORDER BY V.START_DATE;

END ETAG_PROFILES;
----------------------------------------------------------------------------------------------------
PROCEDURE TRANSACTION_TRAITS
	(
	p_TRAIT_GROUP_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_TRAIT_GROUP_ID, EC.ED_TRANSACTION_TRAIT_GROUP);


	OPEN p_CURSOR FOR
        SELECT
			A.DISPLAY_NAME,
			A.DISPLAY_ORDER,
			A.DATA_TYPE,
			A.FORMAT,
			A.COMBO_LIST,
			A.EDIT_MASK,
      A.AFTER_EDIT,
			A.TRAIT_GROUP_ID,
			A.TRAIT_INDEX,
			A.SYSTEM_OBJECT_ID
        FROM TRANSACTION_TRAIT_ATTRIBUTES A
        WHERE TRAIT_GROUP_ID = p_TRAIT_GROUP_ID
    	ORDER BY A.DISPLAY_ORDER;

END TRANSACTION_TRAITS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_TRANSACTION_TRAIT
	(
	p_TRAIT_GROUP_ID IN NUMBER,
	p_TRAIT_INDEX IN NUMBER,
	p_SYSTEM_OBJECT_ID IN NUMBER,
	p_DISPLAY_NAME IN VARCHAR2,
	p_DISPLAY_ORDER IN NUMBER,
	p_DATA_TYPE IN VARCHAR2,
	p_FORMAT IN VARCHAR2,
	p_COMBO_LIST IN VARCHAR2,
	p_EDIT_MASK IN VARCHAR2,
	p_AFTER_EDIT IN VARCHAR2
	) AS
	v_SYSTEM_OBJECT_ID NUMBER(9);
	v_PARENT_OBJECT_ID NUMBER(9);
	v_TRAIT_INDEX NUMBER(3);
	v_OBJECT_NAME SYSTEM_OBJECT.OBJECT_NAME%TYPE;
	v_STATUS NUMBER;

	PROCEDURE UPDATE_TRAIT_ATTRIBUTES
		(
		p_OBJECT_ID IN NUMBER
		) AS

		PROCEDURE UPDATE_ATTR (p_ATTRIBUTE_ID IN NUMBER, p_VAL IN VARCHAR2) AS BEGIN
			SO.PUT_SYSTEM_OBJECT_ATTRIBUTE(p_OBJECT_ID, p_ATTRIBUTE_ID, p_VAL, v_STATUS);
			ERRS.VALIDATE_STATUS('SO.PUT_SYSTEM_OBJECT_ATTRIBUTE', v_STATUS);
		END;
	BEGIN
		UPDATE_ATTR(3, p_FORMAT);
		UPDATE_ATTR(4, p_DATA_TYPE);
		UPDATE_ATTR(5, p_COMBO_LIST);
		UPDATE_ATTR(6, p_EDIT_MASK);
 		UPDATE_ATTR(7, p_AFTER_EDIT);
	END UPDATE_TRAIT_ATTRIBUTES;

	PROCEDURE UPSERT_TRAIT
		(
		p_TRAIT_GROUP_ID IN NUMBER,
		p_TRAIT_INDEX IN NUMBER,
		p_SYSTEM_OBJECT_ID IN NUMBER
		) AS
	--Insert/Update the row into the Trait table.
	BEGIN
		INSERT INTO TRANSACTION_TRAIT(TRAIT_GROUP_ID, TRAIT_INDEX, SYSTEM_OBJECT_ID, ENTRY_DATE)
		VALUES(p_TRAIT_GROUP_ID, p_TRAIT_INDEX, p_SYSTEM_OBJECT_ID, SYSDATE);
	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			UPDATE TRANSACTION_TRAIT
			SET SYSTEM_OBJECT_ID = p_SYSTEM_OBJECT_ID
			WHERE TRAIT_GROUP_ID = p_TRAIT_GROUP_ID
				AND TRAIT_INDEX = p_TRAIT_INDEX;
	END UPSERT_TRAIT;

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_TRAIT_GROUP_ID, EC.ED_TRANSACTION_TRAIT_GROUP);


	--Get the ID for the parent module.
	SO.ID_FOR_SYSTEM_OBJECT(0, 'Transaction Traits', 0, 'Module', 'Default', TRUE, v_PARENT_OBJECT_ID);

    IF p_TRAIT_INDEX IS NULL THEN
		v_SYSTEM_OBJECT_ID := 0;
	ELSE
    	--See if the Trait already exists.
    	SELECT NVL(MAX(SYSTEM_OBJECT_ID),0)
    	INTO v_SYSTEM_OBJECT_ID
    	FROM TRANSACTION_TRAIT
    	WHERE TRAIT_GROUP_ID = p_TRAIT_GROUP_ID
    		AND TRAIT_INDEX = p_TRAIT_INDEX;

    	--If we didn't get it the first time, try looking for the name incase
    	--it was orphaned.
    	IF v_SYSTEM_OBJECT_ID <= 0 THEN
    		SELECT NVL(MAX(OBJECT_ID),0)
    		INTO v_SYSTEM_OBJECT_ID
    		FROM SYSTEM_OBJECT A, TRANSACTION_TRAIT_GROUP B
    		WHERE B.TRAIT_GROUP_ID = p_TRAIT_GROUP_ID
    			AND UPPER(A.OBJECT_NAME) = UPPER(B.TRAIT_GROUP_NAME || '.' || p_TRAIT_INDEX)
				AND A.PARENT_OBJECT_ID = v_PARENT_OBJECT_ID
				AND A.OBJECT_CATEGORY = 'Column'
				AND NOT EXISTS (SELECT 1 FROM TRANSACTION_TRAIT T WHERE T.SYSTEM_OBJECT_ID = A.OBJECT_ID);

    		--Try inserting the trait, or updating its system_object_id
    		UPSERT_TRAIT(p_TRAIT_GROUP_ID, p_TRAIT_INDEX, v_SYSTEM_OBJECT_ID);

    	END IF;
    END IF;

	IF v_SYSTEM_OBJECT_ID > 0 THEN

		--If so, update its attributes.
		UPDATE_TRAIT_ATTRIBUTES(v_SYSTEM_OBJECT_ID);

		--And update its display properties.
		UPDATE SYSTEM_OBJECT
		SET OBJECT_DISPLAY_NAME = p_DISPLAY_NAME,
			OBJECT_ORDER = p_DISPLAY_ORDER
		WHERE OBJECT_ID = v_SYSTEM_OBJECT_ID;

	ELSE
		--Get the next index for this group.
		IF p_TRAIT_INDEX > 0 THEN
			v_TRAIT_INDEX := p_TRAIT_INDEX;
		ELSE
			SELECT NVL(MAX(TRAIT_INDEX),0) + 1
			INTO v_TRAIT_INDEX
			FROM TRANSACTION_TRAIT
			WHERE TRAIT_GROUP_ID = p_TRAIT_GROUP_ID;
		END IF;

		--Create a new System Object.
		SELECT TRAIT_GROUP_NAME || '.' || TO_CHAR(v_TRAIT_INDEX)
		INTO v_OBJECT_NAME
		FROM TRANSACTION_TRAIT_GROUP
		WHERE TRAIT_GROUP_ID = p_TRAIT_GROUP_ID;

		v_OBJECT_NAME := SO.GET_OBJECT_NAME(v_OBJECT_NAME, 0, 'Default', 'Column', v_PARENT_OBJECT_ID);

		SO.PUT_SYSTEM_OBJECT(v_SYSTEM_OBJECT_ID, 0, v_PARENT_OBJECT_ID, v_OBJECT_NAME, 0, 'Column', 'Default', NULL, 'Transaction Type Configuration Object', p_DISPLAY_NAME, p_DISPLAY_ORDER, 0, NULL);

		--Update its attributes.
		UPDATE_TRAIT_ATTRIBUTES(v_SYSTEM_OBJECT_ID);

		UPSERT_TRAIT(p_TRAIT_GROUP_ID, v_TRAIT_INDEX, v_SYSTEM_OBJECT_ID);

	END IF;

END PUT_TRANSACTION_TRAIT;
----------------------------------------------------------------------------------------------------
PROCEDURE CONDITIONAL_FORMAT_ITEMS
	(
	p_CONDITIONAL_FORMAT_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_CONDITIONAL_FORMAT_ID, EC.ED_CONDITIONAL_FORMAT);


	OPEN p_CURSOR FOR
		SELECT *
		FROM CONDITIONAL_FORMAT_ITEM A
		WHERE A.CONDITIONAL_FORMAT_ID = p_CONDITIONAL_FORMAT_ID
        ORDER BY A.ITEM_NUMBER;

END CONDITIONAL_FORMAT_ITEMS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_CONDITIONAL_FORMAT_ITEM
	(
	p_CONDITIONAL_FORMAT_ID IN NUMBER,
    p_ITEM_NUMBER IN NUMBER,
    p_COLOR_WHEN_FORMULA IN VARCHAR,
    p_FOREGROUND_COLOR IN NUMBER,
    p_BACKGROUND_COLOR IN NUMBER,
    p_IS_BOLD IN NUMBER,
    p_IS_ITALIC IN NUMBER,
    p_IS_STRIKE_THROUGH IN NUMBER,
    p_IS_UNDERLINE IN NUMBER
	) AS
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_CONDITIONAL_FORMAT_ID, EC.ED_CONDITIONAL_FORMAT);


	UPDATE CONDITIONAL_FORMAT_ITEM A SET
        A.COLOR_WHEN_FORMULA = p_COLOR_WHEN_FORMULA,
        A.FOREGROUND_COLOR = p_FOREGROUND_COLOR,
        A.BACKGROUND_COLOR = p_BACKGROUND_COLOR,
        A.IS_BOLD = p_IS_BOLD,
        A.IS_ITALIC = p_IS_ITALIC,
        A.IS_STRIKE_THROUGH = p_IS_STRIKE_THROUGH,
        A.IS_UNDERLINE = p_IS_UNDERLINE,
		A.ENTRY_DATE = SYSDATE
	 WHERE A.CONDITIONAL_FORMAT_ID = p_CONDITIONAL_FORMAT_ID
     AND A.ITEM_NUMBER = p_ITEM_NUMBER;

	IF SQL%NOTFOUND THEN
		INSERT INTO CONDITIONAL_FORMAT_ITEM
            (
            CONDITIONAL_FORMAT_ID,
            ITEM_NUMBER,
            COLOR_WHEN_FORMULA,
            FOREGROUND_COLOR,
            BACKGROUND_COLOR,
            IS_BOLD,
            IS_ITALIC,
            IS_STRIKE_THROUGH,
            IS_UNDERLINE,
			ENTRY_DATE
            )
		VALUES
            (
			p_CONDITIONAL_FORMAT_ID,
            p_ITEM_NUMBER,
            p_COLOR_WHEN_FORMULA,
            p_FOREGROUND_COLOR,
            p_BACKGROUND_COLOR,
            p_IS_BOLD,
            p_IS_ITALIC,
            p_IS_STRIKE_THROUGH,
            p_IS_UNDERLINE,
			SYSDATE
            );
	END IF;

END PUT_CONDITIONAL_FORMAT_ITEM;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_FORMAT_WITH_ITEMS
	(
	p_CONDITIONAL_FORMAT_NAME IN VARCHAR,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN

	OPEN p_CURSOR FOR
		SELECT A.CONDITIONAL_FORMAT_ID,
            A.CONDITIONAL_FORMAT_NAME,
            B.COLOR_WHEN_FORMULA,
            B.FOREGROUND_COLOR,
            B.BACKGROUND_COLOR,
            B.IS_BOLD,
            B.IS_ITALIC,
            B.IS_STRIKE_THROUGH,
            B.IS_UNDERLINE
		FROM CONDITIONAL_FORMAT A, CONDITIONAL_FORMAT_ITEM B
		WHERE B.CONDITIONAL_FORMAT_ID = A.CONDITIONAL_FORMAT_ID
        AND A.CONDITIONAL_FORMAT_NAME = p_CONDITIONAL_FORMAT_NAME
        ORDER BY B.ITEM_NUMBER;

END GET_FORMAT_WITH_ITEMS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SERVICE_POINT_NODE_TYPES
	(
	p_SERVICE_POINT_TYPE IN VARCHAR,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_COUNT BINARY_INTEGER;
v_KEY3 VARCHAR2(64) := p_SERVICE_POINT_TYPE;
BEGIN
	SELECT COUNT(*)
	INTO v_COUNT
	FROM SYSTEM_LABEL
	WHERE MODEL_ID = 0
		AND MODULE = 'Entity Manager'
		AND KEY1 = 'Service Point'
		AND KEY2 = 'Node Type'
		AND KEY3 = v_KEY3;

	IF v_COUNT = 0 THEN
		v_KEY3 := '?';
	END IF;

	OPEN p_CURSOR FOR
		SELECT VALUE
    	FROM SYSTEM_LABEL
    	WHERE MODEL_ID = 0
    		AND MODULE = 'Entity Manager'
    		AND KEY1 = 'Service Point'
    		AND KEY2 = 'Node Type'
    		AND KEY3 = v_KEY3
		ORDER BY POSITION;

END GET_SERVICE_POINT_NODE_TYPES;
----------------------------------------------------------------------------------------------------
PROCEDURE STORAGE_CAPACITYS
	(
	p_CONTRACT_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_CONTRACT_ID, EC.ED_INTERCHANGE_CONTRACT);

	OPEN p_CURSOR FOR
		SELECT CONTRACT_ID,
            BEGIN_DATE,
            END_DATE,
            MAX_CAPACITY,
            MAX_DAILY_INJECTIONS,
            MAX_DAILY_WITHDRAWALS,
            INJECTION_FUEL_PCT,
            WITHDRAWAL_FUEL_PCT,
            ENTRY_DATE
		FROM STORAGE_CAPACITY
		WHERE CONTRACT_ID = p_CONTRACT_ID
		ORDER BY BEGIN_DATE;

END STORAGE_CAPACITYS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_STORAGE_CAPACITY
	(
    p_CONTRACT_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_MAX_CAPACITY IN NUMBER,
    p_MAX_DAILY_INJECTIONS IN NUMBER,
    p_MAX_DAILY_WITHDRAWALS IN NUMBER,
    p_INJECTION_FUEL_PCT IN NUMBER,
    p_WITHDRAWAL_FUEL_PCT IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE
	) AS

v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_CONTRACT_ID, EC.ED_INTERCHANGE_CONTRACT);

	v_KEY_NEW('CONTRACT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_CONTRACT_ID);
    v_KEY_OLD('CONTRACT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_CONTRACT_ID);

	v_DATA('MAX_CAPACITY') := UT.GET_LITERAL_FOR_NUMBER(p_MAX_CAPACITY);
	v_DATA('MAX_DAILY_INJECTIONS') := UT.GET_LITERAL_FOR_NUMBER(p_MAX_DAILY_INJECTIONS);
	v_DATA('MAX_DAILY_WITHDRAWALS') := UT.GET_LITERAL_FOR_NUMBER(p_MAX_DAILY_WITHDRAWALS);
	v_DATA('INJECTION_FUEL_PCT') := UT.GET_LITERAL_FOR_NUMBER(p_INJECTION_FUEL_PCT);
	v_DATA('WITHDRAWAL_FUEL_PCT') := UT.GET_LITERAL_FOR_NUMBER(p_WITHDRAWAL_FUEL_PCT);

	UT.PUT_TEMPORAL_DATA_UI('STORAGE_CAPACITY',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

END PUT_STORAGE_CAPACITY;
----------------------------------------------------------------------------------------------------
PROCEDURE STORAGE_RATCHETS
	(
	p_CONTRACT_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_CONTRACT_ID, EC.ED_INTERCHANGE_CONTRACT);

	OPEN p_CURSOR FOR
		SELECT CONTRACT_ID,
            BEGIN_DATE,
            END_DATE,
            PERIOD_BEGIN,
            PERIOD_END,
            FROM_PCT_FULL,
            TO_PCT_FULL,
            MAX_INJECTION_PCT,
            MAX_WITHDRAWAL_PCT,
            ENTRY_DATE
		FROM STORAGE_RATCHET
		WHERE CONTRACT_ID = p_CONTRACT_ID
		ORDER BY BEGIN_DATE, PERIOD_BEGIN, FROM_PCT_FULL;

END STORAGE_RATCHETS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_STORAGE_RATCHET
	(
    p_CONTRACT_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
	p_PERIOD_BEGIN IN DATE,
	p_PERIOD_END IN DATE,
	p_FROM_PCT_FULL IN NUMBER,
	p_TO_PCT_FULL IN NUMBER,
	p_MAX_INJECTION_PCT IN NUMBER,
	p_MAX_WITHDRAWAL_PCT IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_OLD_PERIOD_BEGIN IN DATE,
	p_OLD_FROM_PCT_FULL IN NUMBER
	) AS

v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
v_STORAGE_RATCHET STORAGE_RATCHET%ROWTYPE;
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_CONTRACT_ID, EC.ED_INTERCHANGE_CONTRACT);

	IF p_PERIOD_BEGIN IS NULL THEN
		v_STORAGE_RATCHET.PERIOD_BEGIN := LOW_DATE;
	ELSE
		v_STORAGE_RATCHET.PERIOD_BEGIN := GET_PERIOD_DATE(p_PERIOD_BEGIN);
	END IF;
	IF p_PERIOD_END IS NULL THEN
		v_STORAGE_RATCHET.PERIOD_END := ADD_MONTHS(LOW_DATE,12)-1;
	ELSE
		v_STORAGE_RATCHET.PERIOD_END := GET_PERIOD_DATE(p_PERIOD_END);
	END IF;

	v_KEY_NEW('CONTRACT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_CONTRACT_ID);
    v_KEY_OLD('CONTRACT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_CONTRACT_ID);
	v_KEY_NEW('PERIOD_BEGIN') := UT.GET_LITERAL_FOR_DATE(v_STORAGE_RATCHET.PERIOD_BEGIN);
	v_KEY_OLD('PERIOD_BEGIN') := UT.GET_LITERAL_FOR_DATE(p_OLD_PERIOD_BEGIN);
	v_KEY_NEW('FROM_PCT_FULL') := UT.GET_LITERAL_FOR_NUMBER(p_FROM_PCT_FULL);
	v_KEY_OLD('FROM_PCT_FULL') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_FROM_PCT_FULL);

	v_DATA('PERIOD_END') := UT.GET_LITERAL_FOR_DATE(v_STORAGE_RATCHET.PERIOD_END);
	v_DATA('TO_PCT_FULL') := UT.GET_LITERAL_FOR_NUMBER(p_TO_PCT_FULL);
	v_DATA('MAX_INJECTION_PCT') := UT.GET_LITERAL_FOR_NUMBER(p_MAX_INJECTION_PCT);
	v_DATA('MAX_WITHDRAWAL_PCT') := UT.GET_LITERAL_FOR_NUMBER(p_MAX_WITHDRAWAL_PCT);

	UT.PUT_TEMPORAL_DATA_UI('STORAGE_RATCHET',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

END PUT_STORAGE_RATCHET;
----------------------------------------------------------------------------------------------------
PROCEDURE PIPELINE_POINT_LIMITS
	(
	p_CONTRACT_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_CONTRACT_ID, EC.ED_INTERCHANGE_CONTRACT);

	OPEN p_CURSOR FOR
		SELECT CONTRACT_ID,
            PPL.SERVICE_POINT_ID,
            BEGIN_DATE,
            END_DATE,
            PERIOD_BEGIN,
            PERIOD_END,
            MAX_DAILY_QUANTITY,
            PPL.ENTRY_DATE
		FROM PIPELINE_POINT_LIMIT PPL, SERVICE_POINT SP
		WHERE CONTRACT_ID = p_CONTRACT_ID
			AND SP.SERVICE_POINT_ID = PPL.SERVICE_POINT_ID
		ORDER BY SERVICE_POINT_NAME, BEGIN_DATE;

END PIPELINE_POINT_LIMITS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_PIPELINE_POINT_LIMIT
	(
    p_CONTRACT_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
	p_PERIOD_BEGIN IN DATE,
	p_PERIOD_END IN DATE,
	p_MAX_DAILY_QUANTITY IN NUMBER,
	p_OLD_SERVICE_POINT_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_OLD_PERIOD_BEGIN IN DATE
	) AS

v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
v_PIPELINE_POINT_LIMIT PIPELINE_POINT_LIMIT%ROWTYPE;
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_CONTRACT_ID, EC.ED_INTERCHANGE_CONTRACT);

	IF p_PERIOD_BEGIN IS NULL THEN
		v_PIPELINE_POINT_LIMIT.PERIOD_BEGIN := LOW_DATE;
	ELSE
		v_PIPELINE_POINT_LIMIT.PERIOD_BEGIN := GET_PERIOD_DATE(p_PERIOD_BEGIN);
	END IF;
	IF p_PERIOD_END IS NULL THEN
		v_PIPELINE_POINT_LIMIT.PERIOD_END := ADD_MONTHS(LOW_DATE,12)-1;
	ELSE
		v_PIPELINE_POINT_LIMIT.PERIOD_END := GET_PERIOD_DATE(p_PERIOD_END);
	END IF;

	v_KEY_NEW('CONTRACT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_CONTRACT_ID);
    v_KEY_OLD('CONTRACT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_CONTRACT_ID);
	v_KEY_NEW('SERVICE_POINT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SERVICE_POINT_ID);
	v_KEY_OLD('SERVICE_POINT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_SERVICE_POINT_ID);
	v_KEY_NEW('PERIOD_BEGIN') := UT.GET_LITERAL_FOR_DATE(v_PIPELINE_POINT_LIMIT.PERIOD_BEGIN);
	v_KEY_OLD('PERIOD_BEGIN') := UT.GET_LITERAL_FOR_DATE(p_OLD_PERIOD_BEGIN);

	v_DATA('PERIOD_END') := UT.GET_LITERAL_FOR_DATE(v_PIPELINE_POINT_LIMIT.PERIOD_END);
	v_DATA('MAX_DAILY_QUANTITY') := UT.GET_LITERAL_FOR_NUMBER(p_MAX_DAILY_QUANTITY);

	UT.PUT_TEMPORAL_DATA_UI('PIPELINE_POINT_LIMIT',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

END PUT_PIPELINE_POINT_LIMIT;
----------------------------------------------------------------------------------------------------
PROCEDURE PIPELINE_SEGMENT_LIMITS
	(
	p_CONTRACT_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_CONTRACT_ID, EC.ED_INTERCHANGE_CONTRACT);

	OPEN p_CURSOR FOR
		SELECT CONTRACT_ID,
            POR_ID,
			POD_ID,
            BEGIN_DATE,
            END_DATE,
            PERIOD_BEGIN,
            PERIOD_END,
            MAX_DAILY_QUANTITY,
            PSL.ENTRY_DATE
		FROM PIPELINE_SEGMENT_LIMIT PSL, SERVICE_POINT POR, SERVICE_POINT POD
		WHERE CONTRACT_ID = p_CONTRACT_ID
			AND POR.SERVICE_POINT_ID = PSL.POR_ID
			AND POD.SERVICE_POINT_ID = PSL.POD_ID
		ORDER BY POR.SERVICE_POINT_NAME, POD.SERVICE_POINT_NAME, BEGIN_DATE;

END PIPELINE_SEGMENT_LIMITS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_PIPELINE_SEGMENT_LIMIT
	(
    p_CONTRACT_ID IN NUMBER,
	p_POR_ID IN NUMBER,
	p_POD_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
	p_PERIOD_BEGIN IN DATE,
	p_PERIOD_END IN DATE,
	p_MAX_DAILY_QUANTITY IN NUMBER,
	p_OLD_POR_ID IN NUMBER,
	p_OLD_POD_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_OLD_PERIOD_BEGIN IN DATE
	) AS


v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
v_PIPELINE_SEGMENT_LIMIT PIPELINE_SEGMENT_LIMIT%ROWTYPE;
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_CONTRACT_ID, EC.ED_INTERCHANGE_CONTRACT);

	IF p_PERIOD_BEGIN IS NULL THEN
		v_PIPELINE_SEGMENT_LIMIT.PERIOD_BEGIN := LOW_DATE;
	ELSE
		v_PIPELINE_SEGMENT_LIMIT.PERIOD_BEGIN := GET_PERIOD_DATE(p_PERIOD_BEGIN);
	END IF;
	IF p_PERIOD_END IS NULL THEN
		v_PIPELINE_SEGMENT_LIMIT.PERIOD_END := ADD_MONTHS(LOW_DATE,12)-1;
	ELSE
		v_PIPELINE_SEGMENT_LIMIT.PERIOD_END := GET_PERIOD_DATE(p_PERIOD_END);
	END IF;

	v_KEY_NEW('CONTRACT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_CONTRACT_ID);
    v_KEY_OLD('CONTRACT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_CONTRACT_ID);
	v_KEY_NEW('POR_ID') := UT.GET_LITERAL_FOR_NUMBER(p_POR_ID);
    v_KEY_OLD('POR_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_POR_ID);
	v_KEY_NEW('POD_ID') := UT.GET_LITERAL_FOR_NUMBER(p_POD_ID);
	v_KEY_OLD('POD_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_POD_ID);
	v_KEY_NEW('PERIOD_BEGIN') := UT.GET_LITERAL_FOR_DATE(v_PIPELINE_SEGMENT_LIMIT.PERIOD_BEGIN);
	v_KEY_OLD('PERIOD_BEGIN') := UT.GET_LITERAL_FOR_DATE(p_OLD_PERIOD_BEGIN);

	v_DATA('PERIOD_END') := UT.GET_LITERAL_FOR_DATE(v_PIPELINE_SEGMENT_LIMIT.PERIOD_END);
	v_DATA('MAX_DAILY_QUANTITY') := UT.GET_LITERAL_FOR_NUMBER(p_MAX_DAILY_QUANTITY);

	UT.PUT_TEMPORAL_DATA_UI('PIPELINE_SEGMENT_LIMIT',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

END PUT_PIPELINE_SEGMENT_LIMIT;
----------------------------------------------------------------------------------------------------
PROCEDURE PIPELINE_TARIFF_RATES
	(
	p_CONTRACT_ID IN NUMBER,
	p_PIPELINE_TARIFF_TYPE IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_CONTRACT_ID, EC.ED_INTERCHANGE_CONTRACT);

	OPEN p_CURSOR FOR
		SELECT CONTRACT_ID,
            PIPELINE_TARIFF_TYPE,
            BEGIN_DATE,
            END_DATE,
            PERIOD_BEGIN,
            PERIOD_END,
            ZOR_ID,
            ZOD_ID,
            ZONE_ORDER,
            FROM_MILEAGE,
            TO_MILEAGE,
            COMMODITY_CHARGE,
            FUEL_PCT,
            FUEL_CHARGE,
            PTR.ENTRY_DATE
		FROM PIPELINE_TARIFF_RATE PTR, SERVICE_ZONE Z1, SERVICE_ZONE Z2
		WHERE CONTRACT_ID = p_CONTRACT_ID
			AND PIPELINE_TARIFF_TYPE = p_PIPELINE_TARIFF_TYPE
			AND Z1.SERVICE_ZONE_ID = ZOR_ID
			AND Z2.SERVICE_ZONE_ID = ZOD_ID
		ORDER BY BEGIN_DATE, PERIOD_BEGIN, Z1.SERVICE_ZONE_NAME, Z2.SERVICE_ZONE_NAME, ZONE_ORDER, FROM_MILEAGE;

END PIPELINE_TARIFF_RATES;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_PIPELINE_TARIFF_RATE
	(
    p_CONTRACT_ID IN NUMBER,
	p_PIPELINE_TARIFF_TYPE IN VARCHAR2,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
	p_PERIOD_BEGIN IN DATE,
	p_PERIOD_END IN DATE,
	p_ZOR_ID IN NUMBER,
	p_ZOD_ID IN NUMBER,
	p_ZONE_ORDER IN NUMBER,
	p_FROM_MILEAGE IN NUMBER,
	p_TO_MILEAGE IN NUMBER,
	p_COMMODITY_CHARGE IN NUMBER,
	p_FUEL_PCT IN NUMBER,
	p_FUEL_CHARGE IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_OLD_PERIOD_BEGIN IN DATE,
	p_OLD_ZOR_ID IN NUMBER,
	p_OLD_ZOD_ID IN NUMBER,
	p_OLD_ZONE_ORDER IN NUMBER,
	p_OLD_FROM_MILEAGE IN NUMBER
	) AS

v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
v_PIPELINE_TARIFF_RATE PIPELINE_TARIFF_RATE%ROWTYPE;
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_CONTRACT_ID, EC.ED_INTERCHANGE_CONTRACT);

	IF p_PERIOD_BEGIN IS NULL THEN
		v_PIPELINE_TARIFF_RATE.PERIOD_BEGIN := LOW_DATE;
	ELSE
		v_PIPELINE_TARIFF_RATE.PERIOD_BEGIN := GET_PERIOD_DATE(p_PERIOD_BEGIN);
	END IF;
	IF p_PERIOD_END IS NULL THEN
		v_PIPELINE_TARIFF_RATE.PERIOD_END := ADD_MONTHS(LOW_DATE,12)-1;
	ELSE
		v_PIPELINE_TARIFF_RATE.PERIOD_END := GET_PERIOD_DATE(p_PERIOD_END);
	END IF;

	v_KEY_NEW('CONTRACT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_CONTRACT_ID);
    v_KEY_OLD('CONTRACT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_CONTRACT_ID);
	v_KEY_NEW('PIPELINE_TARIFF_TYPE') := UT.GET_LITERAL_FOR_STRING(p_PIPELINE_TARIFF_TYPE);
    v_KEY_OLD('PIPELINE_TARIFF_TYPE') := UT.GET_LITERAL_FOR_STRING(p_PIPELINE_TARIFF_TYPE);
	v_KEY_NEW('PERIOD_BEGIN') := UT.GET_LITERAL_FOR_DATE(v_PIPELINE_TARIFF_RATE.PERIOD_BEGIN);
	v_KEY_OLD('PERIOD_BEGIN') := UT.GET_LITERAL_FOR_DATE(p_OLD_PERIOD_BEGIN);
	v_KEY_NEW('ZOR_ID') := UT.GET_LITERAL_FOR_NUMBER(p_ZOR_ID);
	v_KEY_OLD('ZOR_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_ZOR_ID);
	v_KEY_NEW('ZOD_ID') := UT.GET_LITERAL_FOR_NUMBER(p_ZOD_ID);
	v_KEY_OLD('ZOD_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_ZOD_ID);
	v_KEY_NEW('ZONE_ORDER') := UT.GET_LITERAL_FOR_NUMBER(p_ZONE_ORDER);
	v_KEY_OLD('ZONE_ORDER') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_ZONE_ORDER);
	v_KEY_NEW('FROM_MILEAGE') := UT.GET_LITERAL_FOR_NUMBER(p_FROM_MILEAGE);
	v_KEY_OLD('FROM_MILEAGE') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_FROM_MILEAGE);

	v_DATA('PERIOD_END') := UT.GET_LITERAL_FOR_DATE(v_PIPELINE_TARIFF_RATE.PERIOD_END);
	v_DATA('TO_MILEAGE') := UT.GET_LITERAL_FOR_NUMBER(p_TO_MILEAGE);
	v_DATA('COMMODITY_CHARGE') := UT.GET_LITERAL_FOR_NUMBER(p_COMMODITY_CHARGE);
	v_DATA('FUEL_PCT') := UT.GET_LITERAL_FOR_NUMBER(p_FUEL_PCT);
	v_DATA('FUEL_CHARGE') := UT.GET_LITERAL_FOR_NUMBER(p_FUEL_CHARGE);

	UT.PUT_TEMPORAL_DATA_UI('PIPELINE_TARIFF_RATE',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

END PUT_PIPELINE_TARIFF_RATE;
----------------------------------------------------------------------------------------------------
PROCEDURE IT_SEGMENTS
	(
	p_TRANSACTION_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_TRANSACTION_ID, EC.ED_TRANSACTION);

	OPEN p_CURSOR FOR
		SELECT IT_SEGMENT_ID,
            TRANSACTION_ID,
            POR_ID,
            POD_ID,
            BEGIN_DATE,
            END_DATE,
            SEGMENT_ORDER,
            CONTRACT_ID,
            ENTRY_DATE
		FROM IT_SEGMENT
		WHERE TRANSACTION_ID = p_TRANSACTION_ID
		ORDER BY BEGIN_DATE, SEGMENT_ORDER;

END IT_SEGMENTS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_IT_SEGMENT
	(
	p_IT_SEGMENT_ID IN NUMBER,
    p_TRANSACTION_ID IN NUMBER,
	p_POR_ID IN NUMBER,
	p_POD_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
	p_SEGMENT_ORDER IN NUMBER,
	p_CONTRACT_ID IN NUMBER
	) AS
v_IT_SEGMENT IT_SEGMENT%ROWTYPE;
v_OLD_TRANSACTION_ID NUMBER;
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_TRANSACTION_ID, EC.ED_TRANSACTION);

	v_IT_SEGMENT.IT_SEGMENT_ID := p_IT_SEGMENT_ID;
	v_IT_SEGMENT.TRANSACTION_ID := p_TRANSACTION_ID;
	v_IT_SEGMENT.POR_ID := p_POR_ID;
	v_IT_SEGMENT.POD_ID := p_POD_ID;
	v_IT_SEGMENT.BEGIN_DATE := p_BEGIN_DATE;
	v_IT_SEGMENT.END_DATE := p_END_DATE;
	v_IT_SEGMENT.SEGMENT_ORDER := p_SEGMENT_ORDER;
	v_IT_SEGMENT.CONTRACT_ID := p_CONTRACT_ID;
	v_IT_SEGMENT.ENTRY_DATE := SYSDATE;

	IF NVL(p_IT_SEGMENT_ID,0) = 0 THEN -- row does not exist
		SELECT OID.NEXTVAL INTO v_IT_SEGMENT.IT_SEGMENT_ID FROM DUAL;
		INSERT INTO IT_SEGMENT VALUES v_IT_SEGMENT;
	ELSE
		SELECT MAX(TRANSACTION_ID) INTO v_OLD_TRANSACTION_ID
		FROM IT_SEGMENT WHERE IT_SEGMENT_ID = p_IT_SEGMENT_ID;

		IF v_OLD_TRANSACTION_ID <> p_TRANSACTION_ID THEN
			-- transaction is different? we must be copying this row to
			-- new transaction
    		SELECT OID.NEXTVAL INTO v_IT_SEGMENT.IT_SEGMENT_ID FROM DUAL;
    		INSERT INTO IT_SEGMENT VALUES v_IT_SEGMENT;
		ELSE
        	UPDATE IT_SEGMENT
        		SET ROW = v_IT_SEGMENT
        	WHERE IT_SEGMENT_ID = p_IT_SEGMENT_ID;
    	END IF;
	END IF;

END PUT_IT_SEGMENT;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_PIPELINE_CONTRACTS
	(
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT CONTRACT_NAME, CONTRACT_ID
		FROM INTERCHANGE_CONTRACT
		WHERE CONTRACT_TYPE = 'Pipeline'
		ORDER BY 1;
END GET_PIPELINE_CONTRACTS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_PIPELINE_POINTS
	(
	p_PIPELINE_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT SERVICE_POINT_NAME, SERVICE_POINT_ID
		FROM SERVICE_POINT
		WHERE SERVICE_POINT_TYPE = 'Pipeline'
			AND PIPELINE_ID = p_PIPELINE_ID
		ORDER BY 1;
END GET_PIPELINE_POINTS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_PIPELINE_CONSTRAINT_POINTS
	(
	p_PIPELINE_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT SERVICE_POINT_NAME, SERVICE_POINT_ID
		FROM SERVICE_POINT SP
		WHERE SERVICE_POINT_TYPE = 'Pipeline'
			AND PIPELINE_ID = p_PIPELINE_ID
			AND NOT EXISTS (SELECT TEA.ATTRIBUTE_VAL
							FROM ENTITY_ATTRIBUTE EA, TEMPORAL_ENTITY_ATTRIBUTE TEA
							WHERE EA.ENTITY_DOMAIN_ID = EC.ED_SERVICE_POINT
								AND EA.ATTRIBUTE_NAME = 'Constraint Point'
								AND TEA.OWNER_ENTITY_ID = SP.SERVICE_POINT_ID
								AND TEA.ATTRIBUTE_ID = EA.ATTRIBUTE_ID
								AND TRUNC(SYSDATE) BETWEEN TEA.BEGIN_DATE AND NVL(TEA.END_DATE,HIGH_DATE)
								AND NVL(TEA.ATTRIBUTE_VAL,'?') <> '?')
		ORDER BY 1;
END GET_PIPELINE_CONSTRAINT_POINTS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_PL_POINTS_FOR_CONTRACT
	(
	p_PIPELINE_CONTRACT_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT SERVICE_POINT_NAME, SERVICE_POINT_ID
		FROM SERVICE_POINT SP, INTERCHANGE_CONTRACT IC
		WHERE IC.CONTRACT_ID = p_PIPELINE_CONTRACT_ID
			AND	SP.SERVICE_POINT_TYPE = 'Pipeline'
			AND SP.PIPELINE_ID = IC.PIPELINE_ID
		ORDER BY 1;
END GET_PL_POINTS_FOR_CONTRACT;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_PIPELINE_ZONES
	(
	p_PIPELINE_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT DISTINCT Z.SERVICE_ZONE_NAME, Z.SERVICE_ZONE_ID
		FROM SERVICE_ZONE Z, SERVICE_POINT P
		WHERE P.SERVICE_POINT_TYPE = 'Pipeline'
			AND P.PIPELINE_ID = p_PIPELINE_ID
			AND Z.SERVICE_ZONE_ID = P.SERVICE_ZONE_ID
		ORDER BY 1;
END GET_PIPELINE_ZONES;
----------------------------------------------------------------------------------------------------
FUNCTION GET_TX_COMMODITY_TYPE
	(
	p_COMMODITY_ID IN NUMBER
	) RETURN VARCHAR2 AS
v_RET VARCHAR2(64);
BEGIN
	SELECT MAX(COMMODITY_TYPE)
	INTO v_RET
	FROM IT_COMMODITY
	WHERE COMMODITY_ID = p_COMMODITY_ID;

	RETURN v_RET;
END GET_TX_COMMODITY_TYPE;
----------------------------------------------------------------------------------------------------
PROCEDURE ENTITY_ASSIGNMENTS
	(
	p_ENTITY_GROUP_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_ENTITY_IDs ID_TABLE;
v_DOMAIN_ID  ENTITY_GROUP.ENTITY_DOMAIN_ID%TYPE;
v_ALLOW_ALL NUMBER(10) := 0;
v_FIRST ID_TYPE;
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ENTITY_GROUP_ID, EC.ED_ENTITY_GROUP);

	-- MAX() will effectively get NULL for invalid group IDs
	SELECT MAX(ENTITY_DOMAIN_ID)
	INTO v_DOMAIN_ID
	FROM ENTITY_GROUP
	WHERE ENTITY_GROUP_ID = p_ENTITY_GROUP_ID;

	-- only show entities to which current user has 'select' privilege - will return empty list
	-- if domain ID is NULL from above query
	v_ENTITY_IDS := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_SELECT_ENT, v_DOMAIN_ID);

	IF v_ENTITY_IDS.COUNT > 0 THEN
		v_FIRST := v_ENTITY_IDS(v_ENTITY_IDS.FIRST);
		v_ALLOW_ALL := UT.NUMBER_FROM_BOOLEAN ( v_FIRST.ID = SD.g_ALL_DATA_ENTITY_ID);
	END IF;

	OPEN p_CURSOR FOR
		SELECT E.ENTITY_ID, E.ENTITY2_ID, E.ENTITY3_ID, E.ENTITY4_ID,
		E.ENTITY5_ID, E.ENTITY6_ID, E.ENTITY7_ID, E.ENTITY8_ID, E.ENTITY9_ID,
		E.ENTITY10_ID, E.BEGIN_DATE, E.END_DATE, E.ENTRY_DATE
		FROM ENTITY_GROUP_ASSIGNMENT E
		WHERE E.ENTITY_GROUP_ID = p_ENTITY_GROUP_ID
			AND (v_ALLOW_ALL = 1 OR (ENTITY_ID IN (SELECT ID FROM TABLE(CAST(v_ENTITY_IDS AS ID_TABLE)))))
			AND (v_ALLOW_ALL = 1 OR (ENTITY2_ID IS NULL OR ENTITY2_ID IN (SELECT ID FROM TABLE(CAST(v_ENTITY_IDS AS ID_TABLE)))))
			AND (v_ALLOW_ALL = 1 OR (ENTITY3_ID IS NULL OR ENTITY3_ID IN (SELECT ID FROM TABLE(CAST(v_ENTITY_IDS AS ID_TABLE)))))
			AND (v_ALLOW_ALL = 1 OR (ENTITY4_ID IS NULL OR ENTITY4_ID IN (SELECT ID FROM TABLE(CAST(v_ENTITY_IDS AS ID_TABLE)))))
			AND (v_ALLOW_ALL = 1 OR (ENTITY5_ID IS NULL OR ENTITY5_ID IN (SELECT ID FROM TABLE(CAST(v_ENTITY_IDS AS ID_TABLE)))))
			AND (v_ALLOW_ALL = 1 OR (ENTITY6_ID IS NULL OR ENTITY6_ID IN (SELECT ID FROM TABLE(CAST(v_ENTITY_IDS AS ID_TABLE)))))
			AND (v_ALLOW_ALL = 1 OR (ENTITY7_ID IS NULL OR ENTITY7_ID IN (SELECT ID FROM TABLE(CAST(v_ENTITY_IDS AS ID_TABLE)))))
			AND (v_ALLOW_ALL = 1 OR (ENTITY8_ID IS NULL OR ENTITY8_ID IN (SELECT ID FROM TABLE(CAST(v_ENTITY_IDS AS ID_TABLE)))))
			AND (v_ALLOW_ALL = 1 OR (ENTITY9_ID IS NULL OR ENTITY9_ID IN (SELECT ID FROM TABLE(CAST(v_ENTITY_IDS AS ID_TABLE)))))
			AND (v_ALLOW_ALL = 1 OR (ENTITY10_ID IS NULL OR ENTITY10_ID IN (SELECT ID FROM TABLE(CAST(v_ENTITY_IDS AS ID_TABLE)))));

END ENTITY_ASSIGNMENTS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ENTITY_ASSIGNMENT
	(
	p_ENTITY_GROUP_ID IN NUMBER,
    p_ENTITY_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_ENTITY_ID IN NUMBER,
    p_OLD_BEGIN_DATE IN DATE,
	p_ENTITY2_ID IN NUMBER,
	p_OLD_ENTITY2_ID IN NUMBER,
	p_ENTITY3_ID IN NUMBER,
	p_OLD_ENTITY3_ID IN NUMBER,
	p_ENTITY4_ID IN NUMBER,
	p_OLD_ENTITY4_ID IN NUMBER,
	p_ENTITY5_ID IN NUMBER,
	p_OLD_ENTITY5_ID IN NUMBER,
	p_ENTITY6_ID IN NUMBER,
	p_OLD_ENTITY6_ID IN NUMBER,
	p_ENTITY7_ID IN NUMBER,
	p_OLD_ENTITY7_ID IN NUMBER,
	p_ENTITY8_ID IN NUMBER,
	p_OLD_ENTITY8_ID IN NUMBER,
	p_ENTITY9_ID IN NUMBER,
	p_OLD_ENTITY9_ID IN NUMBER,
	p_ENTITY10_ID IN NUMBER,
	p_OLD_ENTITY10_ID IN NUMBER
	) AS

  v_KEY_NEW UT.STRING_MAP;
  v_KEY_OLD UT.STRING_MAP;
  v_DATA UT.STRING_MAP;

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ENTITY_GROUP_ID, EC.ED_ENTITY_GROUP);

	v_KEY_NEW('ENTITY_GROUP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_ENTITY_GROUP_ID);
	v_KEY_OLD('ENTITY_GROUP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_ENTITY_GROUP_ID);

	v_KEY_NEW('ENTITY_ID') := UT.GET_LITERAL_FOR_NUMBER(p_ENTITY_ID);
	v_KEY_OLD('ENTITY_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_ENTITY_ID);
	v_KEY_NEW('ENTITY2_ID') := UT.GET_LITERAL_FOR_NUMBER(CASE WHEN NVL(p_ENTITY2_ID, CONSTANTS.NULL_ID) = CONSTANTS.NULL_ID THEN NULL ELSE p_ENTITY2_ID END);
	v_KEY_OLD('ENTITY2_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_ENTITY2_ID);
	v_KEY_NEW('ENTITY3_ID') := UT.GET_LITERAL_FOR_NUMBER(CASE WHEN NVL(p_ENTITY3_ID, CONSTANTS.NULL_ID) = CONSTANTS.NULL_ID THEN NULL ELSE p_ENTITY3_ID END);
	v_KEY_OLD('ENTITY3_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_ENTITY3_ID);
	v_KEY_NEW('ENTITY4_ID') := UT.GET_LITERAL_FOR_NUMBER(CASE WHEN NVL(p_ENTITY4_ID, CONSTANTS.NULL_ID) = CONSTANTS.NULL_ID THEN NULL ELSE p_ENTITY4_ID END);
	v_KEY_OLD('ENTITY4_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_ENTITY4_ID);
	v_KEY_NEW('ENTITY5_ID') := UT.GET_LITERAL_FOR_NUMBER(CASE WHEN NVL(p_ENTITY5_ID, CONSTANTS.NULL_ID) = CONSTANTS.NULL_ID THEN NULL ELSE p_ENTITY5_ID END);
	v_KEY_OLD('ENTITY5_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_ENTITY5_ID);
	v_KEY_NEW('ENTITY6_ID') := UT.GET_LITERAL_FOR_NUMBER(CASE WHEN NVL(p_ENTITY6_ID, CONSTANTS.NULL_ID) = CONSTANTS.NULL_ID THEN NULL ELSE p_ENTITY6_ID END);
	v_KEY_OLD('ENTITY6_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_ENTITY6_ID);
	v_KEY_NEW('ENTITY7_ID') := UT.GET_LITERAL_FOR_NUMBER(CASE WHEN NVL(p_ENTITY7_ID, CONSTANTS.NULL_ID) = CONSTANTS.NULL_ID THEN NULL ELSE p_ENTITY7_ID END);
	v_KEY_OLD('ENTITY7_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_ENTITY7_ID);
	v_KEY_NEW('ENTITY8_ID') := UT.GET_LITERAL_FOR_NUMBER(CASE WHEN NVL(p_ENTITY8_ID, CONSTANTS.NULL_ID) = CONSTANTS.NULL_ID THEN NULL ELSE p_ENTITY8_ID END);
	v_KEY_OLD('ENTITY8_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_ENTITY8_ID);
	v_KEY_NEW('ENTITY9_ID') := UT.GET_LITERAL_FOR_NUMBER(CASE WHEN NVL(p_ENTITY9_ID, CONSTANTS.NULL_ID) = CONSTANTS.NULL_ID THEN NULL ELSE p_ENTITY9_ID END);
	v_KEY_OLD('ENTITY9_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_ENTITY9_ID);
	v_KEY_NEW('ENTITY10_ID') := UT.GET_LITERAL_FOR_NUMBER(CASE WHEN NVL(p_ENTITY10_ID, CONSTANTS.NULL_ID) = CONSTANTS.NULL_ID THEN NULL ELSE p_ENTITY10_ID END);
	v_KEY_OLD('ENTITY10_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_ENTITY10_ID);

	UT.PUT_TEMPORAL_DATA_UI('ENTITY_GROUP_ASSIGNMENT',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                           v_KEY_NEW,
						   v_KEY_OLD,
						   V_DATA);

END PUT_ENTITY_ASSIGNMENT;
----------------------------------------------------------------------------------------------------
PROCEDURE GROUP_ASSIGNMENTS
	(
	p_OWNER_ENTITY_DOMAIN_ID IN NUMBER,
	p_OWNER_ENTITY_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_GROUP_IDs ID_TABLE;
BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_OWNER_ENTITY_ID, p_OWNER_ENTITY_DOMAIN_ID);

	-- only show groups to which current user has 'select' privilege
	v_GROUP_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_SELECT_ENT, EC.ED_ENTITY_GROUP);

	-- show all groups to which current entity is assigned
	OPEN p_CURSOR FOR
		SELECT A.ENTITY_GROUP_ID, A.BEGIN_DATE, A.END_DATE, A.ENTRY_DATE
		FROM ENTITY_GROUP G, ENTITY_GROUP_ASSIGNMENT A, TABLE(CAST(v_GROUP_IDs as ID_TABLE)) IDs
		WHERE (IDs.ID = SD.g_ALL_DATA_ENTITY_ID OR G.ENTITY_GROUP_ID = IDs.ID)
			AND G.ENTITY_DOMAIN_ID = p_OWNER_ENTITY_DOMAIN_ID
			AND A.ENTITY_GROUP_ID = G.ENTITY_GROUP_ID
			AND A.ENTITY_ID = p_OWNER_ENTITY_ID
			AND NVL(G.IS_MATRIX, 0) = 0;

END GROUP_ASSIGNMENTS;
----------------------------------------------------------------------------------------------------
PROCEDURE CLEANUP_ENTITY_ASSIGNMENT
(
	p_ENTITY_GROUP_ID IN NUMBER,
	p_IS_MATRIX IN NUMBER
) AS

	v_BEGIN_DATES DATE_COLLECTION;
	v_END_DATES DATE_COLLECTION;
	v_ENTITY_IDS NUMBER_COLLECTION;

	v_IDX_IDS BINARY_INTEGER;
	v_IDX_BEGIN BINARY_INTEGER;
	v_IDX_END BINARY_INTEGER;

	-- COUNT ENTITY_ID 2-10, TO SEE IF WE ACTUALLY HAVE TUPLES
	v_c2 NUMBER(9) := 0;
	v_c3 NUMBER(9) := 0;
	v_c4 NUMBER(9) := 0;
	v_c5 NUMBER(9) := 0;
	v_c6 NUMBER(9) := 0;
	v_c7 NUMBER(9) := 0;
	v_c8 NUMBER(9) := 0;
	v_c9 NUMBER(9) := 0;
	v_c10 NUMBER(9) := 0;

	v_TOT NUMBER(9) := 0;

BEGIN

	IF NVL(p_IS_MATRIX, 0) = 0 THEN

	  -- NOW LOOK TO SEE IF WE ACTUALLY HAVE ANY TUPLES, IF WE DO
	  -- WE WILL GO AHEAD OTHTERWISE DON'T; IT WOULD BE UNNECESSARY
	  -- AND POSSIBLE CONFUSING FOR THE USER SINCE WE COLLAPSE RANGES
	  SELECT COUNT(A.ENTITY2_ID),
	  		 COUNT(A.ENTITY3_ID),
			 COUNT(A.ENTITY4_ID),
			 COUNT(A.ENTITY5_ID),
			 COUNT(A.ENTITY6_ID),
			 COUNT(A.ENTITY7_ID),
			 COUNT(A.ENTITY8_ID),
			 COUNT(A.ENTITY9_ID),
			 COUNT(A.ENTITY10_ID)
	  INTO v_c2,
	  	   v_c3,
		   v_c4,
		   v_c5,
		   v_c6,
		   v_c7,
		   v_c8,
		   v_c9,
		   v_c10
	  FROM ENTITY_GROUP_ASSIGNMENT A
	  WHERE A.ENTITY_GROUP_ID = p_ENTITY_GROUP_ID;

	  v_TOT := v_c2 + v_c3 + v_c4 + v_c5 + v_c6 + v_c7 + v_c8 + v_c9 + v_c10;

	  IF v_TOT > 0 THEN

		-- LOOK UP ALL THE ASSIGNMENTS WE WANT TO CHANGE
		SELECT ENTITY_ID, BEGIN_DATE, END_DATE
		BULK COLLECT INTO v_ENTITY_IDS, v_BEGIN_DATES, v_END_DATES
		FROM ( SELECT A.ENTITY_ID, A.BEGIN_DATE, A.END_DATE
			   FROM ENTITY_GROUP_ASSIGNMENT A
			   WHERE A.ENTITY_GROUP_ID = p_ENTITY_GROUP_ID );

		-- NOW DELETE THEM, WE'RE GOING TO REINSERT USING UT.PUT_TEMPORAL_DATA
		-- TO MANAGE OUR DATE RANGES
		DELETE FROM ENTITY_GROUP_ASSIGNMENT A
		WHERE A.ENTITY_GROUP_ID = p_ENTITY_GROUP_ID;

		v_IDX_IDS := v_ENTITY_IDS.FIRST;
		v_IDX_BEGIN := v_BEGIN_DATES.FIRST;
		v_IDX_END := v_END_DATES.FIRST;

		WHILE v_ENTITY_IDS.EXISTS(v_IDX_IDS) LOOP

			-- We use PUT_TEMPORAL_DATA rather than PUT_..._UI since we're
			-- already deleting Entity Assignments with the same first entity
			-- it's not really meaningful to try to retain user date ranges, go
			-- ahead and collapse them intelligently
			UT.PUT_TEMPORAL_DATA('ENTITY_GROUP_ASSIGNMENT',
								 v_BEGIN_DATES(v_IDX_BEGIN),
								 v_END_DATES(v_IDX_END),
								 FALSE,
								 TRUE,
								 -- COLUMN 1
								 'ENTITY_GROUP_ID',
								 UT.GET_LITERAL_FOR_NUMBER(p_ENTITY_GROUP_ID),
								 TRUE,
								 'ENTITY_ID',
								 UT.GET_LITERAL_FOR_NUMBER(v_ENTITY_IDS(v_IDX_IDS)),
								 TRUE);

		  v_IDX_IDS := v_ENTITY_IDS.NEXT(v_IDX_IDS);
		  v_IDX_BEGIN := v_BEGIN_DATES.NEXT(v_IDX_BEGIN);
		  v_IDX_END := v_END_DATES.NEXT(v_IDX_END);
		END LOOP;

	  END IF;

	END IF;



END CLEANUP_ENTITY_ASSIGNMENT;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_GROUP_ASSIGNMENT
	(
	p_ENTITY_GROUP_ID IN NUMBER,
	p_OWNER_ENTITY_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_ENTITY_GROUP_ID IN NUMBER,
    p_OLD_BEGIN_DATE IN DATE
	) AS

BEGIN
-- DATA LEVEL SECURITY
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ENTITY_GROUP_ID, EC.ED_ENTITY_GROUP);
	-- must have permission to edit both groups since we are effectively removing from one and adding to the other
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_OLD_ENTITY_GROUP_ID, EC.ED_ENTITY_GROUP);

	UT.PUT_TEMPORAL_DATA_UI('ENTITY_GROUP_ASSIGNMENT',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            --COLUMN 1
                            'ENTITY_GROUP_ID',
                            UT.GET_LITERAL_FOR_NUMBER(p_ENTITY_GROUP_ID),
                            UT.GET_LITERAL_FOR_NUMBER(p_OLD_ENTITY_GROUP_ID),
                            TRUE,
                            -- COLUMN 2
                            'ENTITY_ID',
                            UT.GET_LITERAL_FOR_NUMBER(p_OWNER_ENTITY_ID),
                            UT.GET_LITERAL_FOR_NUMBER(p_OWNER_ENTITY_ID),
                            TRUE);

END PUT_GROUP_ASSIGNMENT;
----------------------------------------------------------------------------------------------------
PROCEDURE POTENTIAL_PARENT_ENT_GROUPS
(
	p_ENTITY_GROUP_ID IN NUMBER,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_GROUP_CATEGORY IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
) AS

BEGIN

	OPEN p_CURSOR FOR
		SELECT A.ENTITY_GROUP_NAME||' ('||A.GROUP_CATEGORY||')' as ENTITY_GROUP_NAME, A.ENTITY_GROUP_ID
		FROM (SELECT E.ENTITY_GROUP_NAME, E.ENTITY_GROUP_ID, E.GROUP_CATEGORY
				FROM ENTITY_GROUP E
				WHERE E.ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID
					AND NVL(E.IS_MATRIX, 0) = 0
				MINUS
				SELECT E.ENTITY_GROUP_NAME, E.ENTITY_GROUP_ID, E.GROUP_CATEGORY
				FROM ENTITY_GROUP E
				START WITH E.ENTITY_GROUP_ID = p_ENTITY_GROUP_ID
				CONNECT BY E.PARENT_GROUP_ID = PRIOR E.ENTITY_GROUP_ID) A
		-- sort groups with the same category towards the top
		ORDER BY CASE WHEN A.GROUP_CATEGORY = p_GROUP_CATEGORY THEN 0 ELSE 1 END, A.ENTITY_GROUP_NAME;

END POTENTIAL_PARENT_ENT_GROUPS;
----------------------------------------------------------------------------------------------------
PROCEDURE ENTITY_GROUP_CATEGORIES
	(
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN
	OPEN p_CURSOR FOR
	SELECT DISTINCT E.GROUP_CATEGORY
	FROM ENTITY_GROUP E;
END ENTITY_GROUP_CATEGORIES;
----------------------------------------------------------------------------------------------------
PROCEDURE ENTITIES_FOR_GROUP
	(
	p_ENTITY_GROUP_ID IN NUMBER,
	p_INCLUDE_NULL IN NUMBER := 0,
	p_CURSOR OUT GA.REFCURSOR
	) AS

	v_ENTITY_DOMAIN_ID	NUMBER;
	v_WORK_ID			RTO_WORK.WORK_ID%TYPE;

BEGIN
	-- SOMEONE HAS CLICKED THE COMBO BOX ON A NULL ENTITY, IGNORE THIS
	IF NVL(p_ENTITY_GROUP_ID, -1) < 0 THEN
		OPEN p_CURSOR FOR SELECT NULL FROM DUAL;
		RETURN;
	END IF;

	-- LOOKUP THE ENTITY DOMAIN
	SELECT E.ENTITY_DOMAIN_ID INTO v_ENTITY_DOMAIN_ID
	FROM ENTITY_GROUP E
	WHERE E.ENTITY_GROUP_ID = p_ENTITY_GROUP_ID;

	SD.ENUMERATE_ENTITIES(SD.g_ACTION_SELECT_ENT, v_ENTITY_DOMAIN_ID, v_WORK_ID);

	IF NVL(p_INCLUDE_NULL,0) = 1 THEN
		OPEN p_CURSOR FOR
			SELECT ' ' as ENTITY_NAME, CONSTANTS.NULL_ID as ENTITY_ID
			FROM DUAL
			UNION ALL
			SELECT ENTITY_NAME, ENTITY_ID
			FROM (SELECT WORK_DATA as ENTITY_NAME, WORK_XID as ENTITY_ID
					FROM RTO_WORK
					WHERE WORK_ID = v_WORK_ID
					ORDER BY 1);
	ELSE
		OPEN p_CURSOR FOR
			SELECT WORK_DATA as ENTITY_NAME, WORK_XID as ENTITY_ID
			FROM RTO_WORK
			WHERE WORK_ID = v_WORK_ID
			ORDER BY 1;
	END IF;

END ENTITIES_FOR_GROUP;
----------------------------------------------------------------------------------------------------
PROCEDURE DOMAINS_FOR_ENTITY_GROUP
(
	p_CURSOR OUT GA.REFCURSOR
) AS

BEGIN
	OPEN p_CURSOR FOR
		SELECT E.ENTITY_DOMAIN_NAME, E.ENTITY_DOMAIN_ID
		FROM ENTITY_DOMAIN E
		WHERE E.INCLUDE_GROUPS = 1 -- get all domains that include groups
			AND E.ENTITY_DOMAIN_ID <> EC.ED_ENTITY_GROUP -- cannot have groups of groups - use PARENT_GROUP_ID instead
		ORDER BY 1;

END DOMAINS_FOR_ENTITY_GROUP;
----------------------------------------------------------------------------------------------------
FUNCTION GET_GROUP_CATEGORY
	(
	p_ENTITY_GROUP_ID IN NUMBER
	) RETURN VARCHAR2 AS
v_RET ENTITY_GROUP.GROUP_CATEGORY%TYPE;
BEGIN
	SELECT MAX(GROUP_CATEGORY)
	INTO v_RET
	FROM ENTITY_GROUP
	WHERE ENTITY_GROUP_ID = p_ENTITY_GROUP_ID;

	RETURN CASE WHEN v_RET = '?' THEN NULL ELSE v_RET END;
END GET_GROUP_CATEGORY;
----------------------------------------------------------------------------------------------------
PROCEDURE GROUPS_FOR_ENTITY
	(
	p_OWNER_ENTITY_DOMAIN_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

	v_IDs ID_TABLE;

BEGIN
	-- to what groups does user have access?
	v_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_SELECT_ENT, EC.ED_ENTITY_GROUP);

	-- only show the groups to which user has 'select' privilege
	OPEN p_CURSOR FOR
		SELECT A.ENTITY_GROUP_NAME, A.ENTITY_GROUP_ID
		FROM ENTITY_GROUP A, TABLE(CAST(v_IDs as ID_TABLE)) B
		WHERE (B.ID = SD.g_ALL_DATA_ENTITY_ID OR A.ENTITY_GROUP_ID = B.ID)
			AND A.ENTITY_DOMAIN_ID = p_OWNER_ENTITY_DOMAIN_ID
			AND NVL(A.IS_MATRIX, 0) = 0
		ORDER BY 1;

END GROUPS_FOR_ENTITY;
---------------------------------------------------------------------------------------------------
PROCEDURE LIST_COMPONENTS
	(
	p_SEARCH_STRING IN VARCHAR,
	p_SEARCH_OPTION IN VARCHAR,
	p_SEARCH_TYPE	IN NUMBER,
	p_FIND_ENTITY_ID IN NUMBER,
	p_ACTION_NAME IN VARCHAR2,
	p_IS_CALC IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	)
	AS

-- Answer the given entities
v_IDs ID_TABLE;
v_DOMAIN_ID NUMBER(9) := CASE WHEN p_IS_CALC = 1 THEN EC.ED_CALC_COMPONENT ELSE EC.ED_COMPONENT END;

BEGIN

	--Make sure user has appropriate access.
	IF p_ACTION_NAME IS NULL THEN
		v_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(EN.g_DEFAULT_ACTION_NAME,v_DOMAIN_ID);
	ELSE
		v_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(p_ACTION_NAME,v_DOMAIN_ID);
	END IF;

	IF NVL(p_SEARCH_TYPE, CONSTANTS.SEARCH_TYPE_NORMAL) = CONSTANTS.SEARCH_TYPE_NORMAL THEN
		IF p_SEARCH_STRING = '%' OR p_SEARCH_STRING IS NULL THEN
			OPEN p_CURSOR FOR
			SELECT COMPONENT_NAME "ENTITY_NAME",
				COMPONENT_ID "ENTITY_ID",
				COMPONENT_ALIAS "ENTITY_ALIAS",
				'Active' "ENTITY_STATUS"
			FROM COMPONENT A,
				TABLE(CAST(v_IDs AS ID_TABLE)) X
			WHERE X.ID IN (A.COMPONENT_ID, SD.g_ALL_DATA_ENTITY_ID)
				AND ((p_IS_CALC = 1 AND UPPER(A.COMPONENT_ENTITY) = 'CALC.PROCESS')
					OR (p_IS_CALC = 0 AND UPPER(A.COMPONENT_ENTITY) <> 'CALC.PROCESS'))
			ORDER BY DECODE(NVL(p_SEARCH_OPTION,CONSTANTS.SEARCH_OPTION_BY_NAME), CONSTANTS.SEARCH_OPTION_BY_NAME, COMPONENT_NAME, COMPONENT_ALIAS);
		ELSE
			OPEN p_CURSOR FOR
			SELECT COMPONENT_NAME "ENTITY_NAME",
				COMPONENT_ID "ENTITY_ID",
				COMPONENT_ALIAS "ENTITY_ALIAS",
				'Active' "ENTITY_STATUS"
			FROM COMPONENT A,
				TABLE(CAST(v_IDs AS ID_TABLE)) X
			WHERE X.ID IN (A.COMPONENT_ID, SD.g_ALL_DATA_ENTITY_ID)
				AND ((p_IS_CALC = 1 AND UPPER(A.COMPONENT_ENTITY) = 'CALC.PROCESS')
					OR (p_IS_CALC = 0 AND UPPER(A.COMPONENT_ENTITY) <> 'CALC.PROCESS'))
				AND ((p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_NAME
						AND COMPONENT_NAME LIKE p_SEARCH_STRING)
                    OR (p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_ALIAS
						AND COMPONENT_ALIAS LIKE p_SEARCH_STRING))
			ORDER BY DECODE(p_SEARCH_OPTION, CONSTANTS.SEARCH_OPTION_BY_NAME, COMPONENT_NAME, COMPONENT_ALIAS);
		END IF;

        -- Specific Value
	ELSIF p_SEARCH_TYPE = CONSTANTS.SEARCH_TYPE_BY_VAL THEN

		OPEN p_CURSOR FOR
		SELECT COMPONENT_NAME "ENTITY_NAME",
			COMPONENT_ID "ENTITY_ID",
			COMPONENT_ALIAS "ENTITY_ALIAS",
			'Active' "ENTITY_STATUS"
		FROM COMPONENT A,
			TABLE(CAST(v_IDs AS ID_TABLE)) X
		WHERE X.ID IN (A.COMPONENT_ID, SD.g_ALL_DATA_ENTITY_ID)
			AND ((p_IS_CALC = 1 AND UPPER(A.COMPONENT_ENTITY) = 'CALC.PROCESS')
				OR (p_IS_CALC = 0 AND UPPER(A.COMPONENT_ENTITY) <> 'CALC.PROCESS'))
			AND A.COMPONENT_ID = p_FIND_ENTITY_ID;
	END IF;

END LIST_COMPONENTS;
----------------------------------------------------------------------------------------------------
PROCEDURE LIST_CHARGE_COMPONENTS
	(
	p_SEARCH_STRING IN VARCHAR,
	p_SEARCH_OPTION IN VARCHAR,
	p_SEARCH_TYPE	IN NUMBER,
	p_FIND_ENTITY_ID IN NUMBER,
	p_ACTION_NAME IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	)
	AS
BEGIN
	LIST_COMPONENTS(p_SEARCH_STRING, p_SEARCH_OPTION,
					p_SEARCH_TYPE, p_FIND_ENTITY_ID,
					p_ACTION_NAME, 0, p_CURSOR);
END LIST_CHARGE_COMPONENTS;
---------------------------------------------------------------------------------------------------
PROCEDURE LIST_CALCULATION_COMPONENTS
	(
	p_SEARCH_STRING IN VARCHAR,
	p_SEARCH_OPTION IN VARCHAR,
	p_SEARCH_TYPE	IN NUMBER,
	p_FIND_ENTITY_ID IN NUMBER,
	p_ACTION_NAME IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	)
	AS
BEGIN
	LIST_COMPONENTS(p_SEARCH_STRING, p_SEARCH_OPTION,
					p_SEARCH_TYPE, p_FIND_ENTITY_ID,
					p_ACTION_NAME, 1, p_CURSOR);
END LIST_CALCULATION_COMPONENTS;
---------------------------------------------------------------------------------------------------
PROCEDURE LIST_REALMS
	(
	p_SEARCH_STRING IN VARCHAR,
	p_SEARCH_OPTION IN VARCHAR,
	p_SEARCH_TYPE	IN NUMBER,
	p_FIND_ENTITY_ID IN NUMBER,
	p_ACTION_NAME IN VARCHAR2,
	p_REALM_CALC_TYPE IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	)
	AS

-- Answer the given entities
v_IDs ID_TABLE;
v_DOMAIN_ID NUMBER(9) := CASE p_REALM_CALC_TYPE
							WHEN 2 THEN EC.ED_CALC_REALM
							WHEN 1 THEN EC.ED_FORMULA_REALM
							ELSE EC.ED_SYSTEM_REALM
							END;

BEGIN

	--Make sure user has appropriate access.
	IF p_ACTION_NAME IS NULL THEN
		v_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(EN.g_DEFAULT_ACTION_NAME,v_DOMAIN_ID);
	ELSE
		v_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(p_ACTION_NAME,v_DOMAIN_ID);
	END IF;

	IF NVL(p_SEARCH_TYPE, CONSTANTS.SEARCH_TYPE_NORMAL) = CONSTANTS.SEARCH_TYPE_NORMAL THEN
		IF p_SEARCH_STRING = '%' OR p_SEARCH_STRING IS NULL THEN
			OPEN p_CURSOR FOR
			SELECT REALM_NAME "ENTITY_NAME",
				REALM_ID "ENTITY_ID",
				REALM_ALIAS "ENTITY_ALIAS",
				'Active' "ENTITY_STATUS"
			FROM SYSTEM_REALM A,
				TABLE(CAST(v_IDs AS ID_TABLE)) X
			WHERE X.ID IN (A.REALM_ID, SD.g_ALL_DATA_ENTITY_ID)
				AND A.REALM_CALC_TYPE = p_REALM_CALC_TYPE
			ORDER BY DECODE(NVL(p_SEARCH_OPTION,CONSTANTS.SEARCH_OPTION_BY_NAME), CONSTANTS.SEARCH_OPTION_BY_NAME, REALM_NAME, REALM_ALIAS);
		ELSE
			OPEN p_CURSOR FOR
			SELECT REALM_NAME "ENTITY_NAME",
				REALM_ID "ENTITY_ID",
				REALM_ALIAS "ENTITY_ALIAS",
				'Active' "ENTITY_STATUS"
			FROM SYSTEM_REALM A,
				TABLE(CAST(v_IDs AS ID_TABLE)) X
			WHERE X.ID IN (A.REALM_ID, SD.g_ALL_DATA_ENTITY_ID)
				AND A.REALM_CALC_TYPE = p_REALM_CALC_TYPE
				AND ((p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_NAME
						AND REALM_NAME LIKE p_SEARCH_STRING)
                    OR (p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_ALIAS
						AND REALM_ALIAS LIKE p_SEARCH_STRING))
			ORDER BY DECODE(p_SEARCH_OPTION, CONSTANTS.SEARCH_OPTION_BY_NAME, REALM_NAME, REALM_ALIAS);
		END IF;

        -- Specific Value
	ELSIF p_SEARCH_TYPE = CONSTANTS.SEARCH_TYPE_BY_VAL THEN
		OPEN p_CURSOR FOR
		SELECT REALM_NAME "ENTITY_NAME",
			REALM_ID "ENTITY_ID",
			REALM_ALIAS "ENTITY_ALIAS",
			'Active' "ENTITY_STATUS"
		FROM SYSTEM_REALM A,
			TABLE(CAST(v_IDs AS ID_TABLE)) X
		WHERE X.ID IN (A.REALM_ID, SD.g_ALL_DATA_ENTITY_ID)
			AND A.REALM_CALC_TYPE = p_REALM_CALC_TYPE
			AND A.REALM_ID = p_FIND_ENTITY_ID;
	END IF;

END LIST_REALMS;
----------------------------------------------------------------------------------------------------
PROCEDURE LIST_SYSTEM_REALMS
	(
	p_SEARCH_STRING IN VARCHAR,
	p_SEARCH_OPTION IN VARCHAR,
	p_SEARCH_TYPE	IN NUMBER,
	p_FIND_ENTITY_ID IN NUMBER,
	p_ACTION_NAME IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	)
	AS
BEGIN
	LIST_REALMS(p_SEARCH_STRING, p_SEARCH_OPTION, p_SEARCH_TYPE,
					p_FIND_ENTITY_ID, p_ACTION_NAME,
					c_REALM_CALC_TYPE_SYSTEM, p_CURSOR);
END LIST_SYSTEM_REALMS;
----------------------------------------------------------------------------------------------------
PROCEDURE LIST_FORMULA_REALMS
	(
	p_SEARCH_STRING IN VARCHAR,
	p_SEARCH_OPTION IN VARCHAR,
	p_SEARCH_TYPE	IN NUMBER,
	p_FIND_ENTITY_ID IN NUMBER,
	p_ACTION_NAME IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	)
	AS
BEGIN
	LIST_REALMS(p_SEARCH_STRING, p_SEARCH_OPTION, p_SEARCH_TYPE,
					p_FIND_ENTITY_ID, p_ACTION_NAME,
					c_REALM_CALC_TYPE_FML, p_CURSOR);
END LIST_FORMULA_REALMS;
---------------------------------------------------------------------------------------------------
PROCEDURE LIST_CALCULATION_REALMS
	(
	p_SEARCH_STRING IN VARCHAR,
	p_SEARCH_OPTION IN VARCHAR,
	p_SEARCH_TYPE	IN NUMBER,
	p_FIND_ENTITY_ID IN NUMBER,
	p_ACTION_NAME IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	)
	AS
BEGIN
	LIST_REALMS(p_SEARCH_STRING, p_SEARCH_OPTION, p_SEARCH_TYPE,
					p_FIND_ENTITY_ID, p_ACTION_NAME,
					c_REALM_CALC_TYPE_CALC, p_CURSOR);
END LIST_CALCULATION_REALMS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_CALC_PROCESS
	(
	o_OID OUT NUMBER,
	p_CALC_PROCESS_NAME IN VARCHAR2,
	p_CALC_PROCESS_ALIAS IN VARCHAR2,
	p_CALC_PROCESS_DESC IN VARCHAR2,
	p_CALC_PROCESS_ID IN NUMBER,
	p_CALC_PROCESS_CATEGORY IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_PROCESS_INTERVAL IN VARCHAR2,
	p_WEEK_BEGIN IN VARCHAR2,
	p_CONTEXT_DOMAIN_ID IN NUMBER,
	p_CONTEXT_ENTITIES_ID IN NUMBER,
	p_CONTEXT_NAME IN VARCHAR2,
	p_IS_STATEMENT_TYPE_SPECIFIC IN NUMBER
	) AS
v_CONTEXT_REALM_ID NUMBER;
v_CONTEXT_GROUP_ID NUMBER;
BEGIN
	-- negative ID represents a group
	IF NVL(p_CONTEXT_DOMAIN_ID,0) = 0 THEN
		v_CONTEXT_GROUP_ID := NULL;
		v_CONTEXT_REALM_ID := NULL;
	ELSIF p_CONTEXT_ENTITIES_ID < 0 THEN
		v_CONTEXT_GROUP_ID := -p_CONTEXT_ENTITIES_ID;
		v_CONTEXT_REALM_ID := NULL;
	ELSE
		v_CONTEXT_REALM_ID := p_CONTEXT_ENTITIES_ID;
		v_CONTEXT_GROUP_ID := NULL;
	END IF;
	IO.PUT_CALC_PROCESS(o_OID, p_CALC_PROCESS_NAME, p_CALC_PROCESS_ALIAS, p_CALC_PROCESS_DESC,
						p_CALC_PROCESS_ID, p_CALC_PROCESS_CATEGORY, p_TIME_ZONE, p_PROCESS_INTERVAL,
						p_WEEK_BEGIN, p_CONTEXT_DOMAIN_ID, v_CONTEXT_REALM_ID, v_CONTEXT_GROUP_ID,
						p_CONTEXT_NAME, p_IS_STATEMENT_TYPE_SPECIFIC);
END PUT_CALC_PROCESS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_CALC_PROCESS
	(
	p_CALC_PROCESS_ID IN NUMBER,
	p_CALC_PROCESS_NAME OUT VARCHAR2,
	p_CALC_PROCESS_ALIAS OUT VARCHAR2,
	p_CALC_PROCESS_DESC OUT VARCHAR2,
	p_CALC_PROCESS_CATEGORY OUT VARCHAR2,
	p_TIME_ZONE OUT VARCHAR2,
	p_PROCESS_INTERVAL OUT VARCHAR2,
	p_WEEK_BEGIN OUT VARCHAR2,
	p_CONTEXT_DOMAIN_ID OUT NUMBER,
	p_CONTEXT_DOMAIN_DISP OUT VARCHAR2,
	p_CONTEXT_ENTITIES_ID OUT NUMBER,
	p_CONTEXT_ENTITIES_DISP OUT VARCHAR2,
	p_CONTEXT_NAME OUT VARCHAR2,
	p_IS_STATEMENT_TYPE_SPECIFIC OUT NUMBER
	) AS
v_CONTEXT_REALM_ID NUMBER;
v_CONTEXT_REALM_DISP VARCHAR2(32);
v_CONTEXT_GROUP_ID NUMBER;
v_CONTEXT_GROUP_DISP VARCHAR2(32);
BEGIN
	EM_GET.CALC_PROCESS(p_CALC_PROCESS_ID, p_CALC_PROCESS_NAME, p_CALC_PROCESS_ALIAS, p_CALC_PROCESS_DESC,
						p_CALC_PROCESS_CATEGORY, p_TIME_ZONE, p_PROCESS_INTERVAL,
						p_WEEK_BEGIN, p_CONTEXT_DOMAIN_ID, p_CONTEXT_DOMAIN_DISP, v_CONTEXT_REALM_ID, v_CONTEXT_REALM_DISP,
						v_CONTEXT_GROUP_ID, v_CONTEXT_GROUP_DISP, p_CONTEXT_NAME, p_IS_STATEMENT_TYPE_SPECIFIC);
	IF v_CONTEXT_REALM_ID IS NOT NULL THEN
		p_CONTEXT_ENTITIES_ID := v_CONTEXT_REALM_ID;
		p_CONTEXT_ENTITIES_DISP := '<html><b>Realm:</b> ' || v_CONTEXT_REALM_DISP || '</html>';
	ELSE
		p_CONTEXT_ENTITIES_ID := -v_CONTEXT_GROUP_ID;
		p_CONTEXT_ENTITIES_DISP := '<html><b>Group:</b> ' || v_CONTEXT_GROUP_DISP || '</html>';
	END IF;
END GET_CALC_PROCESS;
----------------------------------------------------------------------------------------------------
PROCEDURE REALMS_AND_GROUPS
	(
	p_DOMAIN_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT ENTITY_NAME, ENTITY_ID
		FROM (SELECT '<html><b>Realm: </b>'||REALM_NAME||'</html>' as ENTITY_NAME,
						REALM_ID as ENTITY_ID,
						1 as SORT
				FROM SYSTEM_REALM
				WHERE REALM_CALC_TYPE = 0
					AND (ENTITY_DOMAIN_ID = p_DOMAIN_ID or REALM_ID = SD.g_ALL_DATA_REALM_ID)
				UNION ALL
				SELECT '<html><b>Group: </b>'||ENTITY_GROUP_NAME||'</html>' as ENTITY_NAME,
						-ENTITY_GROUP_ID as ENTITY_ID,
						2 as SORT
				FROM ENTITY_GROUP
				WHERE ENTITY_DOMAIN_ID = p_DOMAIN_ID
					AND NVL(IS_MATRIX,0) = 0)
		ORDER BY SORT, ENTITY_NAME;

END REALMS_AND_GROUPS;
----------------------------------------------------------------------------------------------------
PROCEDURE CALC_PROCESS_CATEGORIES
	(
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT DISTINCT CALC_PROCESS_CATEGORY
		FROM CALCULATION_PROCESS PROC
		WHERE PROC.CALC_PROCESS_CATEGORY <> '?'
		ORDER BY 1;
END CALC_PROCESS_CATEGORIES;
----------------------------------------------------------------------------------------------------
PROCEDURE DOMAINS_FOR_CALC_PROCESS
	(
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT ENTITY_DOMAIN_NAME, ENTITY_DOMAIN_ID
		FROM ENTITY_DOMAIN
		WHERE (IS_PSEUDO = 0
			AND UPPER(ENTITY_DOMAIN_CATEGORY) NOT IN ('CALCULATIONS','CONFIGURATION','SECURITY'))
			OR ENTITY_DOMAIN_ID = 0 -- include 'Not Assigned' domain
		ORDER BY 1;
END DOMAINS_FOR_CALC_PROCESS;
----------------------------------------------------------------------------------------------------
PROCEDURE CALC_PROCESS_GLOBALS
    (
    p_CALC_PROCESS_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_CALC_PROCESS_ID, EC.ED_CALC_PROCESS);

    OPEN p_CURSOR FOR
        SELECT CALC_PROCESS_ID,
            GLOBAL_NAME,
            FORMULA,
            COMMENTS,
            ROW_NUMBER,
            PERSIST_VALUE,
            ENTRY_DATE
        FROM CALCULATION_PROCESS_GLOBAL
        WHERE CALC_PROCESS_ID = p_CALC_PROCESS_ID
        ORDER BY GLOBAL_NAME;

END CALC_PROCESS_GLOBALS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_CALC_PROCESS_GLOBAL
    (
    p_CALC_PROCESS_ID IN NUMBER,
    p_GLOBAL_NAME IN VARCHAR2,
    p_FORMULA IN VARCHAR2,
    p_COMMENTS IN VARCHAR2,
    p_ROW_NUMBER IN NUMBER,
    p_PERSIST_VALUE IN NUMBER,
    p_OLD_GLOBAL_NAME IN VARCHAR2
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_CALC_PROCESS_ID, EC.ED_CALC_PROCESS);

    UPDATE CALCULATION_PROCESS_GLOBAL SET
        GLOBAL_NAME = p_GLOBAL_NAME,
        FORMULA = p_FORMULA,
        COMMENTS = p_COMMENTS,
        ROW_NUMBER = p_ROW_NUMBER,
        PERSIST_VALUE = p_PERSIST_VALUE,
        ENTRY_DATE = SYSDATE
    WHERE CALC_PROCESS_ID = p_CALC_PROCESS_ID
        AND GLOBAL_NAME = p_OLD_GLOBAL_NAME;

    IF SQL%NOTFOUND THEN
        INSERT INTO CALCULATION_PROCESS_GLOBAL (
            CALC_PROCESS_ID,
            GLOBAL_NAME,
            FORMULA,
            COMMENTS,
            ROW_NUMBER,
            PERSIST_VALUE,
            ENTRY_DATE)
        VALUES (
            p_CALC_PROCESS_ID,
            p_GLOBAL_NAME,
            p_FORMULA,
            p_COMMENTS,
            p_ROW_NUMBER,
            p_PERSIST_VALUE,
            SYSDATE);
    END IF;

END PUT_CALC_PROCESS_GLOBAL;
--------------------------------------------------------------------------------
PROCEDURE CALC_PROCESS_STEPS
    (
    p_CALC_PROCESS_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_CALC_PROCESS_ID, EC.ED_CALC_PROCESS);

    OPEN p_CURSOR FOR
        SELECT CALC_STEP_ID,
            CALC_PROCESS_ID,
            STEP_NUMBER,
            BEGIN_DATE,
            END_DATE,
            COMPONENT_ID,
            ENTRY_DATE,
			(SELECT COUNT(1)
				FROM COMPONENT_FORMULA_PARAMETER P
			 	WHERE P.COMPONENT_ID = S.COMPONENT_ID) as NUM_PARMS,
			(SELECT COUNT(1)
				FROM COMPONENT_FORMULA_PARAMETER P,
					CALCULATION_PROCESS_STEP_PARM SP
			 	WHERE P.COMPONENT_ID = S.COMPONENT_ID
					AND SP.CALC_STEP_ID = S.CALC_STEP_ID
					AND SP.PARAMETER_NAME = P.PARAMETER_NAME) as NUM_ACTUAL_PARMS,
			SUMMARIZE_STEP_PARMS(CALC_STEP_ID) as PARMS
        FROM CALCULATION_PROCESS_STEP S
        WHERE CALC_PROCESS_ID = p_CALC_PROCESS_ID
        ORDER BY STEP_NUMBER,
            BEGIN_DATE;

END CALC_PROCESS_STEPS;
--------------------------------------------------------------------------------
FUNCTION SUMMARIZE_STEP_PARMS
	(
	p_CALC_STEP_ID IN NUMBER
	) RETURN VARCHAR2 IS
v_RET VARCHAR2(4001);
BEGIN
	FOR v_REC IN (SELECT PARAMETER_NAME, FORMULA
					FROM CALCULATION_PROCESS_STEP_PARM
					WHERE CALC_STEP_ID = p_CALC_STEP_ID
					ORDER BY ROW_NUMBER) LOOP
		IF v_RET IS NOT NULL THEN
			v_RET := v_RET||'; ';
		END IF;
		v_RET := SUBSTR(v_RET||v_REC.PARAMETER_NAME||' = '||v_REC.FORMULA,1,4000);
		IF LENGTH(v_RET) = 4000 THEN
			-- we've hit the length limit, so clip and return
			RETURN SUBSTR(v_RET,1,3997)||'...';
		END IF;
	END LOOP;

	RETURN v_RET;
END SUMMARIZE_STEP_PARMS;
--------------------------------------------------------------------------------
PROCEDURE PUT_CALC_PROCESS_STEP
    (
    p_CALC_PROCESS_ID IN NUMBER,
    p_STEP_NUMBER IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_COMPONENT_ID IN NUMBER,
    p_OLD_STEP_NUMBER IN NUMBER,
    p_OLD_BEGIN_DATE IN DATE
    ) AS
v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_CALC_PROCESS_ID, EC.ED_CALC_PROCESS);

    v_KEY_NEW('CALC_PROCESS_ID') := UT.GET_LITERAL_FOR_NUMBER(p_CALC_PROCESS_ID);
    v_KEY_OLD('CALC_PROCESS_ID') := UT.GET_LITERAL_FOR_NUMBER(p_CALC_PROCESS_ID);
    v_KEY_NEW('STEP_NUMBER') := UT.GET_LITERAL_FOR_NUMBER(p_STEP_NUMBER);
    v_KEY_OLD('STEP_NUMBER') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_STEP_NUMBER);
    v_DATA('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_COMPONENT_ID);

    UT.PUT_TEMPORAL_DATA_UI('CALCULATION_PROCESS_STEP',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            'CALC_STEP_ID',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

END PUT_CALC_PROCESS_STEP;
--------------------------------------------------------------------------------
PROCEDURE COMPONENT_FORMULA_PARMS
    (
    p_COMPONENT_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);

    OPEN p_CURSOR FOR
        SELECT COMPONENT_ID,
            PARAMETER_NAME,
            ENTRY_DATE
        FROM COMPONENT_FORMULA_PARAMETER
        WHERE COMPONENT_ID = p_COMPONENT_ID
        ORDER BY PARAMETER_NAME;

END COMPONENT_FORMULA_PARMS;
--------------------------------------------------------------------------------
PROCEDURE PUT_COMPONENT_FORMULA_PARM
    (
    p_COMPONENT_ID IN NUMBER,
    p_PARAMETER_NAME IN VARCHAR2,
    p_OLD_PARAMETER_NAME IN VARCHAR2
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);

    UPDATE COMPONENT_FORMULA_PARAMETER SET
        PARAMETER_NAME = p_PARAMETER_NAME,
        ENTRY_DATE = SYSDATE
    WHERE COMPONENT_ID = p_COMPONENT_ID
        AND PARAMETER_NAME = p_OLD_PARAMETER_NAME;

    IF SQL%NOTFOUND THEN
        INSERT INTO COMPONENT_FORMULA_PARAMETER (
            COMPONENT_ID,
            PARAMETER_NAME,
            ENTRY_DATE)
        VALUES (
            p_COMPONENT_ID,
            p_PARAMETER_NAME,
            SYSDATE);
    END IF;

END PUT_COMPONENT_FORMULA_PARM;
----------------------------------------------------------------------------------------------------
PROCEDURE CALC_PROCESS_STEP_PARMS
	(
	p_CALC_STEP_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	-- get list of all required parameters - outer-join actual parameter values
	-- so resulting cursor shows all parms with NULLs for those that have no value
	OPEN p_CURSOR FOR
		SELECT S.CALC_STEP_ID,
			S.PARAMETER_NAME,
			SP.FORMULA,
			SP.COMMENTS,
			SP.ROW_NUMBER,
			SP.ENTRY_DATE
		FROM (SELECT S.CALC_STEP_ID, CP.PARAMETER_NAME
				FROM CALCULATION_PROCESS_STEP S,
					COMPONENT_FORMULA_PARAMETER CP
				WHERE S.CALC_STEP_ID = p_CALC_STEP_ID
					AND CP.COMPONENT_ID = S.COMPONENT_ID) S,
			CALCULATION_PROCESS_STEP_PARM SP
		WHERE SP.CALC_STEP_ID(+) = S.CALC_STEP_ID
			AND SP.PARAMETER_NAME(+) = S.PARAMETER_NAME
		ORDER BY SP.ROW_NUMBER, SP.PARAMETER_NAME;
END CALC_PROCESS_STEP_PARMS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_CALC_PROCESS_STEP_PARM
	(
	p_CALC_STEP_ID IN NUMBER,
	p_PARAMETER_NAME IN VARCHAR2,
	p_ROW_NUMBER IN NUMBER,
	p_FORMULA IN VARCHAR2,
	p_COMMENTS IN VARCHAR2
	) AS
BEGIN
	IF p_FORMULA IS NULL THEN
		DELETE CALCULATION_PROCESS_STEP_PARM
		WHERE CALC_STEP_ID = p_CALC_STEP_ID
			AND PARAMETER_NAME = p_PARAMETER_NAME;
	ELSE
		UPDATE CALCULATION_PROCESS_STEP_PARM
			SET ROW_NUMBER = p_ROW_NUMBER,
				FORMULA = p_FORMULA,
				COMMENTS = p_COMMENTS,
				ENTRY_DATE = SYSDATE
		WHERE CALC_STEP_ID = p_CALC_STEP_ID
			AND PARAMETER_NAME = p_PARAMETER_NAME;

		IF SQL%NOTFOUND THEN
			INSERT INTO CALCULATION_PROCESS_STEP_PARM (
				CALC_STEP_ID,
				PARAMETER_NAME,
				FORMULA,
				COMMENTS,
				ROW_NUMBER,
				ENTRY_DATE)
			VALUES (
				p_CALC_STEP_ID,
				p_PARAMETER_NAME,
				p_FORMULA,
				p_COMMENTS,
				p_ROW_NUMBER,
				SYSDATE);
		END IF;
	END IF;
END PUT_CALC_PROCESS_STEP_PARM;
----------------------------------------------------------------------------------------------------
PROCEDURE SYSTEM_ALERT_TRIGGERS
    (
    p_ALERT_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ALERT_ID, EC.ED_SYSTEM_ALERT);

    OPEN p_CURSOR FOR
        SELECT ALERT_ID,
            TRIGGER_TYPE,
            TRIGGER_LEVEL AS TRIGGER_LEVEL_ID,
            EXACT_LEVEL,
            PROCESS_NAME,
            NAME_IS_REG_EXP,
            TRIGGER_VALUE,
            VALUE_IS_REG_EXP
        FROM SYSTEM_ALERT_TRIGGER
        WHERE ALERT_ID = p_ALERT_ID
        ORDER BY TRIGGER_TYPE,
            TRIGGER_LEVEL,
            EXACT_LEVEL,
            PROCESS_NAME,
            NAME_IS_REG_EXP,
            TRIGGER_VALUE,
            VALUE_IS_REG_EXP;

END SYSTEM_ALERT_TRIGGERS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_SYSTEM_ALERT_TRIGGER
    (
    p_ALERT_ID IN NUMBER,
    p_TRIGGER_TYPE IN VARCHAR2,
    p_TRIGGER_LEVEL_ID IN NUMBER,
    p_EXACT_LEVEL IN NUMBER,
    p_PROCESS_NAME IN VARCHAR2,
    p_NAME_IS_REG_EXP IN NUMBER,
    p_TRIGGER_VALUE IN VARCHAR2,
    p_VALUE_IS_REG_EXP IN NUMBER,
    p_OLD_TRIGGER_TYPE IN VARCHAR2,
    p_OLD_TRIGGER_LEVEL_ID IN NUMBER,
    p_OLD_EXACT_LEVEL IN NUMBER,
    p_OLD_PROCESS_NAME IN VARCHAR2,
    p_OLD_NAME_IS_REG_EXP IN NUMBER,
    p_OLD_TRIGGER_VALUE IN VARCHAR2,
    p_OLD_VALUE_IS_REG_EXP IN NUMBER
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ALERT_ID, EC.ED_SYSTEM_ALERT);

    UPDATE SYSTEM_ALERT_TRIGGER SET
        TRIGGER_TYPE = p_TRIGGER_TYPE,
        TRIGGER_LEVEL = p_TRIGGER_LEVEL_ID,
        EXACT_LEVEL = NVL(p_EXACT_LEVEL, 0),
        PROCESS_NAME = p_PROCESS_NAME,
        NAME_IS_REG_EXP = NVL(p_NAME_IS_REG_EXP, 0),
        TRIGGER_VALUE = p_TRIGGER_VALUE,
        VALUE_IS_REG_EXP = NVL(p_VALUE_IS_REG_EXP, 0)
    WHERE ALERT_ID = p_ALERT_ID
        AND TRIGGER_TYPE = p_OLD_TRIGGER_TYPE
        AND TRIGGER_LEVEL = p_OLD_TRIGGER_LEVEL_ID
        AND EXACT_LEVEL = p_OLD_EXACT_LEVEL
        AND PROCESS_NAME = p_OLD_PROCESS_NAME
        AND NAME_IS_REG_EXP = p_OLD_NAME_IS_REG_EXP
        AND TRIGGER_VALUE = p_OLD_TRIGGER_VALUE
        AND VALUE_IS_REG_EXP = p_OLD_VALUE_IS_REG_EXP;

    IF SQL%NOTFOUND THEN
        INSERT INTO SYSTEM_ALERT_TRIGGER (
            ALERT_ID,
            TRIGGER_TYPE,
            TRIGGER_LEVEL,
            EXACT_LEVEL,
            PROCESS_NAME,
            NAME_IS_REG_EXP,
            TRIGGER_VALUE,
            VALUE_IS_REG_EXP)
        VALUES (
            p_ALERT_ID,
            p_TRIGGER_TYPE,
            p_TRIGGER_LEVEL_ID,
            NVL(p_EXACT_LEVEL,0),
            p_PROCESS_NAME,
            NVL(p_NAME_IS_REG_EXP,0),
            p_TRIGGER_VALUE,
            NVL(p_VALUE_IS_REG_EXP,0));
    END IF;

END PUT_SYSTEM_ALERT_TRIGGER;
--------------------------------------------------------------------------------
PROCEDURE SUB_STATION_METER_OWNERS
    (
    p_METER_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_METER_ID, EC.ED_SUB_STATION_METER);

    OPEN p_CURSOR FOR
        SELECT METER_ID,
            BEGIN_DATE,
            END_DATE,
            OWNER_ID,
            PARTY1_ID,
            PARTY2_ID,
            ENTRY_DATE
        FROM TX_SUB_STATION_METER_OWNER
        WHERE METER_ID = p_METER_ID
        ORDER BY BEGIN_DATE;

END SUB_STATION_METER_OWNERS;
--------------------------------------------------------------------------------
PROCEDURE PUT_SUB_STATION_METER_OWNER
    (
    p_METER_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_OWNER_ID IN NUMBER,
    p_PARTY1_ID IN NUMBER,
    p_PARTY2_ID IN NUMBER,
    p_OLD_BEGIN_DATE IN DATE
    ) AS
v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_METER_ID, EC.ED_SUB_STATION_METER);

    v_KEY_NEW('METER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_METER_ID);
    v_KEY_OLD('METER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_METER_ID);
    v_DATA('OWNER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OWNER_ID);
    v_DATA('PARTY1_ID') := UT.GET_LITERAL_FOR_NUMBER(p_PARTY1_ID);
    v_DATA('PARTY2_ID') := UT.GET_LITERAL_FOR_NUMBER(p_PARTY2_ID);

    UT.PUT_TEMPORAL_DATA_UI('TX_SUB_STATION_METER_OWNER',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

END PUT_SUB_STATION_METER_OWNER;
--------------------------------------------------------------------------------
PROCEDURE SUB_STATION_MTR_PT_SRCS
    (
    p_METER_POINT_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_METER_POINT_ID, EC.ED_SUB_STATION_METER_POINT);

    OPEN p_CURSOR FOR
        SELECT METER_POINT_ID,
            MEASUREMENT_SOURCE_ID,
            BEGIN_DATE,
            END_DATE,
            IS_PRIMARY,
            ENTRY_DATE
        FROM TX_SUB_STATION_METER_PT_SOURCE
        WHERE METER_POINT_ID = p_METER_POINT_ID
        ORDER BY MEASUREMENT_SOURCE_ID,
            BEGIN_DATE;

END SUB_STATION_MTR_PT_SRCS;
--------------------------------------------------------------------------------
PROCEDURE PUT_SUB_STATION_MTR_PT_SRC
    (
    p_METER_POINT_ID IN NUMBER,
    p_MEASUREMENT_SOURCE_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_IS_PRIMARY IN NUMBER,
    p_OLD_MEASUREMENT_SOURCE_ID IN NUMBER,
    p_OLD_BEGIN_DATE IN DATE
    ) AS
v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_METER_POINT_ID, EC.ED_SUB_STATION_METER_POINT);

    v_KEY_NEW('METER_POINT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_METER_POINT_ID);
    v_KEY_OLD('METER_POINT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_METER_POINT_ID);
    v_KEY_NEW('MEASUREMENT_SOURCE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_MEASUREMENT_SOURCE_ID);
    v_KEY_OLD('MEASUREMENT_SOURCE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_MEASUREMENT_SOURCE_ID);
    v_DATA('IS_PRIMARY') := UT.GET_LITERAL_FOR_NUMBER(p_IS_PRIMARY);

    UT.PUT_TEMPORAL_DATA_UI('TX_SUB_STATION_METER_PT_SOURCE',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

END PUT_SUB_STATION_MTR_PT_SRC;
--------------------------------------------------------------------------------
PROCEDURE SUB_STATION_MTR_PT_LOSSS
    (
    p_METER_POINT_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_METER_POINT_ID, EC.ED_SUB_STATION_METER_POINT);

    OPEN p_CURSOR FOR
        SELECT METER_POINT_ID,
            BEGIN_DATE,
            END_DATE,
            FACTOR_TYPE,
            LOSS_FACTOR_ID,
            ENTRY_DATE
        FROM TX_SUB_STATION_METER_PT_LOSS
        WHERE METER_POINT_ID = p_METER_POINT_ID
        ORDER BY BEGIN_DATE;

END SUB_STATION_MTR_PT_LOSSS;
--------------------------------------------------------------------------------
PROCEDURE PUT_SUB_STATION_MTR_PT_LOSS
    (
    p_METER_POINT_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_FACTOR_TYPE IN VARCHAR2,
    p_LOSS_FACTOR_ID IN NUMBER,
    p_OLD_BEGIN_DATE IN DATE
    ) AS
v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_METER_POINT_ID, EC.ED_SUB_STATION_METER_POINT);

    v_KEY_NEW('METER_POINT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_METER_POINT_ID);
    v_KEY_OLD('METER_POINT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_METER_POINT_ID);
    v_DATA('FACTOR_TYPE') := UT.GET_LITERAL_FOR_STRING(p_FACTOR_TYPE);
    v_DATA('LOSS_FACTOR_ID') := UT.GET_LITERAL_FOR_NUMBER(p_LOSS_FACTOR_ID);

    UT.PUT_TEMPORAL_DATA_UI('TX_SUB_STATION_METER_PT_LOSS',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

END PUT_SUB_STATION_MTR_PT_LOSS;
--------------------------------------------------------------------------------
PROCEDURE RESOURCE_OWNERS
    (
    p_RESOURCE_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_RESOURCE_ID, EC.ED_SUPPLY_RESOURCE);

    OPEN p_CURSOR FOR
        SELECT RESOURCE_ID,
            OWNER_ID,
            BEGIN_DATE,
            END_DATE,
            OWNER_PCT,
            IS_RESIDUAL,
            ENTRY_DATE
        FROM SUPPLY_RESOURCE_OWNER
        WHERE RESOURCE_ID = p_RESOURCE_ID
        ORDER BY OWNER_ID,
            BEGIN_DATE;

END RESOURCE_OWNERS;
--------------------------------------------------------------------------------
PROCEDURE PUT_RESOURCE_OWNER
    (
    p_RESOURCE_ID IN NUMBER,
    p_OWNER_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_OWNER_PCT IN NUMBER,
    p_IS_RESIDUAL IN NUMBER,
    p_OLD_OWNER_ID IN NUMBER,
    p_OLD_BEGIN_DATE IN DATE
    ) AS
v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_RESOURCE_ID, EC.ED_SUPPLY_RESOURCE);

    v_KEY_NEW('RESOURCE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_RESOURCE_ID);
    v_KEY_OLD('RESOURCE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_RESOURCE_ID);
    v_KEY_NEW('OWNER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OWNER_ID);
    v_KEY_OLD('OWNER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_OWNER_ID);
    v_DATA('OWNER_PCT') := UT.GET_LITERAL_FOR_NUMBER(CASE WHEN NVL(p_IS_RESIDUAL,0)=1 THEN NULL ELSE p_OWNER_PCT END);
    v_DATA('IS_RESIDUAL') := UT.GET_LITERAL_FOR_NUMBER(NVL(p_IS_RESIDUAL,0));

    UT.PUT_TEMPORAL_DATA_UI('SUPPLY_RESOURCE_OWNER',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

END PUT_RESOURCE_OWNER;
--------------------------------------------------------------------------------
PROCEDURE RESOURCE_METERS
    (
    p_RESOURCE_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_RESOURCE_ID, EC.ED_SUPPLY_RESOURCE);

    OPEN p_CURSOR FOR
        SELECT RESOURCE_ID,
            METER_ID,
            BEGIN_DATE,
            END_DATE,
            ASSIGNMENT_PCT,
            ENTRY_DATE
        FROM SUPPLY_RESOURCE_METER
        WHERE RESOURCE_ID = p_RESOURCE_ID
        ORDER BY METER_ID,
            BEGIN_DATE;

END RESOURCE_METERS;
--------------------------------------------------------------------------------
PROCEDURE PUT_RESOURCE_METER
    (
    p_RESOURCE_ID IN NUMBER,
    p_METER_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_ASSIGNMENT_PCT IN NUMBER,
    p_OLD_METER_ID IN NUMBER,
    p_OLD_BEGIN_DATE IN DATE
    ) AS
v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_RESOURCE_ID, EC.ED_SUPPLY_RESOURCE);

    v_KEY_NEW('RESOURCE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_RESOURCE_ID);
    v_KEY_OLD('RESOURCE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_RESOURCE_ID);
    v_KEY_NEW('METER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_METER_ID);
    v_KEY_OLD('METER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_METER_ID);
    v_DATA('ASSIGNMENT_PCT') := UT.GET_LITERAL_FOR_NUMBER(p_ASSIGNMENT_PCT);

    UT.PUT_TEMPORAL_DATA_UI('SUPPLY_RESOURCE_METER',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

END PUT_RESOURCE_METER;
----------------------------------------------------------------------------------------------------
PROCEDURE COMPONENT_FML_ENTITY_REFS
    (
    p_COMPONENT_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);

    OPEN p_CURSOR FOR
        SELECT COMPONENT_ID,
            REFERENCE_NAME,
            ENTITY_DOMAIN_ID,
            ENTITY_ID,
            ENTRY_DATE
        FROM COMPONENT_FORMULA_ENTITY_REF
        WHERE COMPONENT_ID = p_COMPONENT_ID
        ORDER BY REFERENCE_NAME;

END COMPONENT_FML_ENTITY_REFS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_COMPONENT_FML_ENTITY_REF
    (
    p_COMPONENT_ID IN NUMBER,
    p_REFERENCE_NAME IN VARCHAR2,
    p_ENTITY_DOMAIN_ID IN NUMBER,
    p_ENTITY_ID IN NUMBER,
    p_OLD_REFERENCE_NAME IN VARCHAR2
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);

    UPDATE COMPONENT_FORMULA_ENTITY_REF SET
        REFERENCE_NAME = p_REFERENCE_NAME,
        ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID,
        ENTITY_ID = p_ENTITY_ID,
        ENTRY_DATE = SYSDATE
    WHERE COMPONENT_ID = p_COMPONENT_ID
        AND REFERENCE_NAME = p_OLD_REFERENCE_NAME;

    IF SQL%NOTFOUND THEN
        INSERT INTO COMPONENT_FORMULA_ENTITY_REF (
            COMPONENT_ID,
            REFERENCE_NAME,
            ENTITY_DOMAIN_ID,
            ENTITY_ID,
            ENTRY_DATE)
        VALUES (
            p_COMPONENT_ID,
            p_REFERENCE_NAME,
            p_ENTITY_DOMAIN_ID,
            p_ENTITY_ID,
            SYSDATE);
    END IF;

END PUT_COMPONENT_FML_ENTITY_REF;
----------------------------------------------------------------------------------------------------
PROCEDURE ENTITIES_FOR_DOMAIN
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_FILTER_VIA_DLS IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_WORK_ID	RTO_WORK.WORK_ID%TYPE;
BEGIN
	IF NVL(p_ENTITY_DOMAIN_ID,CONSTANTS.NOT_ASSIGNED) = CONSTANTS.NOT_ASSIGNED THEN
		OPEN p_CURSOR FOR SELECT NULL FROM DUAL WHERE 0=1;
		RETURN;
	END IF;

	SD.ENUMERATE_ENTITIES(CASE WHEN UT.BOOLEAN_FROM_NUMBER(p_FILTER_VIA_DLS)
							THEN SD.g_ACTION_SELECT_ENT
							ELSE NULL
							END,
						p_ENTITY_DOMAIN_ID, v_WORK_ID);

	OPEN p_CURSOR FOR
		SELECT WORK_DATA as ENTITY_NAME, WORK_XID as ENTITY_ID
		FROM RTO_WORK
		WHERE WORK_ID = v_WORK_ID
		ORDER BY 1;

END ENTITIES_FOR_DOMAIN;
----------------------------------------------------------------------------------------------------
PROCEDURE LOSS_FACTOR_MODELS
	(
	p_LOSS_FACTOR_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	) AS
	v_BEGIN_DATE DATE;
	v_END_DATE DATE;
BEGIN
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_LOSS_FACTOR_ID, EC.ED_LOSS_FACTOR);

	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	OPEN p_CURSOR FOR
		SELECT MODEL.LOSS_FACTOR_ID, MODEL.LOSS_TYPE, MODEL.BEGIN_DATE AS MODEL_BEGIN_DATE,
			MODEL.END_DATE AS MODEL_END_DATE, MODEL.FACTOR_TYPE, MODEL.MODEL_TYPE,
			MODEL.INTERVAL, MODEL.PATTERN_ID, MODEL.ENTRY_DATE,
			CASE WHEN MODEL.FACTOR_TYPE = CONSTANTS.LOSS_FACTOR_EXPANSION THEN
					AVG(PATTERN.EXPANSION_VAL)
				 WHEN MODEL.FACTOR_TYPE = CONSTANTS.LOSS_FACTOR_LOSS THEN
					AVG(PATTERN.LOSS_VAL)
				 ELSE
					NULL
			END AS VAL
		FROM LOSS_FACTOR_MODEL MODEL, LOSS_FACTOR_PATTERN PATTERN
		WHERE MODEL.LOSS_FACTOR_ID = p_LOSS_FACTOR_ID
			AND MODEL.BEGIN_DATE <= p_END_DATE
			AND NVL(MODEL.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND PATTERN.PATTERN_ID(+) = MODEL.PATTERN_ID
			AND PATTERN.PATTERN_DATE(+) BETWEEN CASE MODEL.MODEL_TYPE
													WHEN CONSTANTS.LOSS_FACTOR_MODEL_SCHEDULE THEN v_BEGIN_DATE
													ELSE CONSTANTS.LOW_DATE
													END
											AND CASE MODEL.MODEL_TYPE
													WHEN CONSTANTS.LOSS_FACTOR_MODEL_SCHEDULE THEN v_END_DATE
													ELSE CONSTANTS.LOW_DATE+1
													END
		GROUP BY MODEL.LOSS_FACTOR_ID, MODEL.LOSS_TYPE, MODEL.BEGIN_DATE, MODEL.END_DATE,
			MODEL.FACTOR_TYPE, MODEL.MODEL_TYPE, MODEL.INTERVAL, MODEL.PATTERN_ID,
			MODEL.ENTRY_DATE
		ORDER BY MODEL.LOSS_TYPE, MODEL.BEGIN_DATE;


END LOSS_FACTOR_MODELS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_LOSS_FACTOR_MODEL
	(
	p_LOSS_FACTOR_ID IN NUMBER,
	p_LOSS_TYPE IN VARCHAR2,
	p_OLD_LOSS_TYPE IN VARCHAR2,
	p_MODEL_BEGIN_DATE IN DATE,
	p_OLD_MODEL_BEGIN_DATE IN DATE,
	p_MODEL_END_DATE IN DATE,
	p_FACTOR_TYPE IN VARCHAR2,
	p_MODEL_TYPE IN VARCHAR2,
	p_INTERVAL IN VARCHAR2,
	p_PATTERN_ID IN NUMBER,
	p_VAL IN NUMBER
	) AS

   v_KEY_NEW UT.STRING_MAP;
   v_KEY_OLD UT.STRING_MAP;
   v_DATA UT.STRING_MAP;

   v_MODEL_BEGIN DATE := p_MODEL_BEGIN_DATE;
   v_MODEL_END DATE := p_MODEL_END_DATE;
   v_OLD_MODEL_BEGIN DATE := p_OLD_MODEL_BEGIN_DATE;

   v_PATTERN_ID NUMBER;

BEGIN

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_LOSS_FACTOR_ID, EC.ED_LOSS_FACTOR);

	-- If we copy a loss factor, we'll get an old pattern ID but with a new loss factor ID -
	-- make sure this pattern ID matches the specified loss factor and generate a new pattern
	-- ID if not
	SELECT MAX(PATTERN_ID)
	INTO v_PATTERN_ID
	FROM LOSS_FACTOR_MODEL
	WHERE PATTERN_ID = p_PATTERN_ID
		AND LOSS_FACTOR_ID = p_LOSS_FACTOR_ID;

	-- NEW PATTERN
	IF v_PATTERN_ID IS NULL THEN
		SELECT OID.NEXTVAL INTO v_PATTERN_ID
		FROM DUAL;
	END IF;

	IF NOT SP.SYSTEM_LABEL_CONTAINS(0, 'Entity Manager', 'Loss Factor', 'Interval', p_MODEL_TYPE,
		p_INTERVAL) THEN
		ERRS.RAISE(MSGCODES.c_ERR_ARGUMENT, 'Interval ' || p_INTERVAL || ' is not valid for '
			|| ' a loss factor model of type ' || p_MODEL_TYPE);
	END IF;

	v_KEY_NEW('LOSS_FACTOR_ID') := UT.GET_LITERAL_FOR_NUMBER(p_LOSS_FACTOR_ID);
	v_KEY_NEW('LOSS_TYPE') := UT.GET_LITERAL_FOR_STRING(p_LOSS_TYPE);
	v_KEY_OLD('LOSS_FACTOR_ID') := UT.GET_LITERAL_FOR_NUMBER(p_LOSS_FACTOR_ID);
	v_KEY_OLD('LOSS_TYPE') := UT.GET_LITERAL_FOR_STRING(p_OLD_LOSS_TYPE);

	v_DATA('FACTOR_TYPE') := UT.GET_LITERAL_FOR_STRING(p_FACTOR_TYPE);
	v_DATA('MODEL_TYPE') := UT.GET_LITERAL_FOR_STRING(p_MODEL_TYPE);
	v_DATA('INTERVAL') := UT.GET_LITERAL_FOR_STRING(p_INTERVAL);
	v_DATA('PATTERN_ID') := UT.GET_LITERAL_FOR_NUMBER(v_PATTERN_ID);

	UT.PUT_TEMPORAL_DATA_UI( 'LOSS_FACTOR_MODEL',
							v_MODEL_BEGIN,
							v_MODEL_END,
							v_OLD_MODEL_BEGIN,
							TRUE,
							v_KEY_NEW,
							v_KEY_OLD,
							v_DATA);

	IF p_INTERVAL = CONSTANTS.INTERVAL_DAY AND
		p_MODEL_TYPE = CONSTANTS.LOSS_FACTOR_MODEL_PATTERN THEN

		UPDATE LOSS_FACTOR_PATTERN
		SET EXPANSION_VAL = CASE p_FACTOR_TYPE
								WHEN CONSTANTS.LOSS_FACTOR_EXPANSION
								THEN p_VAL
								ELSE NULL
								END,
			 LOSS_VAL = CASE p_FACTOR_TYPE
			 				WHEN CONSTANTS.LOSS_FACTOR_LOSS
							THEN p_VAL
							ELSE NULL
							END
		WHERE PATTERN_ID = v_PATTERN_ID
			AND PATTERN_DATE = LOW_DATE;

		IF SQL%NOTFOUND THEN
			INSERT INTO LOSS_FACTOR_PATTERN (
				PATTERN_ID,
				PATTERN_DATE,
				EXPANSION_VAL, LOSS_VAL
			) VALUES (
				v_PATTERN_ID,
				CONSTANTS.LOW_DATE,
				CASE p_FACTOR_TYPE
					WHEN CONSTANTS.LOSS_FACTOR_EXPANSION
					THEN p_VAL
					ELSE NULL
					END,
				CASE p_FACTOR_TYPE
					WHEN CONSTANTS.LOSS_FACTOR_LOSS
					THEN p_VAL
					ELSE NULL
					END
			);
		END IF;
	END IF;

END PUT_LOSS_FACTOR_MODEL;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_LOSS_FACTOR_PATTERNS
	(
	p_PATTERN_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_MODEL_TYPE OUT VARCHAR2,
	p_FACTOR_TYPE OUT VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	) AS

	v_INTERVAL		LOSS_FACTOR_MODEL.INTERVAL%TYPE;
	v_LOSS_FACTOR_ID LOSS_FACTOR_MODEL.LOSS_FACTOR_ID%TYPE;

	v_MODEL_BEGIN	DATE;
	v_MODEL_END		DATE;

	v_BEGIN_DATE	DATE;
	v_END_DATE		DATE;

	v_IS_EXPANSION	NUMBER := 0;

	v_INTERVAL_NUM	NUMBER(9);
	v_INTERVAL_COUNT NUMBER(9);

BEGIN

	IF p_PATTERN_ID IS NULL THEN
		-- THE MODEL IN QUESTION HASN'T BEEN CREATED YET
		-- (FOR THE INTERVAL LOSS FACTOR FRAMEWORK VIEW)
		-- JUST INGORE THIS CALL
		OPEN p_CURSOR FOR
			SELECT NULL
			FROM DUAL
			WHERE 0=1;
	ELSE

	  SELECT MODEL.MODEL_TYPE, MODEL.FACTOR_TYPE, MODEL.INTERVAL,
		  MODEL.BEGIN_DATE, NVL(MODEL.END_DATE, CONSTANTS.HIGH_DATE),
		  MODEL.LOSS_FACTOR_ID
	  INTO p_MODEL_TYPE, p_FACTOR_TYPE, v_INTERVAL,
	  	  v_MODEL_BEGIN, v_MODEL_END,
		  v_LOSS_FACTOR_ID
	  FROM LOSS_FACTOR_MODEL MODEL
	  WHERE MODEL.PATTERN_ID = p_PATTERN_ID;

	  SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, v_LOSS_FACTOR_ID, EC.ED_LOSS_FACTOR);

	  IF p_FACTOR_TYPE = CONSTANTS.LOSS_FACTOR_EXPANSION THEN
		  v_IS_EXPANSION := 1;
	  END IF;

	  IF p_MODEL_TYPE = CONSTANTS.LOSS_FACTOR_MODEL_PATTERN THEN
		  -- GET THE NUMBER OF INTERVALS IN A  DAY
		  v_INTERVAL_COUNT := DATE_UTIL.GET_INTERVAL_DIVISOR('DD', v_INTERVAL);

		  OPEN p_CURSOR FOR
			  SELECT SUBSTR(FROM_CUT_AS_HED(DATES.PATTERN_DATE, GA.CUT_TIME_ZONE,
						  'MI5'), 12) AS PATTERN_DATE, -- 'MI' SINCE WE'RE ALWAYS SUB-DAILY FOR PATTERNS
				  DATES.PATTERN_DATE AS CUT_DATE,
				  CASE WHEN v_IS_EXPANSION = 1 THEN
					  PATTERN.EXPANSION_VAL
				  ELSE
					  PATTERN.LOSS_VAL
				  END AS PATTERN_VAL
			  FROM LOSS_FACTOR_PATTERN PATTERN,
				  (SELECT (CONSTANTS.LOW_DATE + LEVEL/v_INTERVAL_COUNT) AS PATTERN_DATE
					  FROM DUAL
					  CONNECT BY LEVEL <= v_INTERVAL_COUNT ) DATES
			  WHERE PATTERN.PATTERN_DATE(+) = DATES.PATTERN_DATE
				  AND PATTERN.PATTERN_ID(+) = p_PATTERN_ID
			  ORDER BY DATES.PATTERN_DATE;

	  ELSE
		  -- ONLY THE GREATEST BEGIN_DATE AND LEAST END_DATE ARE IN EFFECT
		  UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, GREATEST(p_BEGIN_DATE, v_MODEL_BEGIN),
			  LEAST(p_END_DATE, v_MODEL_END), p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

		  SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, GREATEST(p_BEGIN_DATE, v_MODEL_BEGIN),
			  LEAST(p_END_DATE, v_MODEL_END) );

		  v_INTERVAL_NUM := GET_INTERVAL_NUMBER(v_INTERVAL);

		  OPEN p_CURSOR FOR
			  SELECT SDT.NO_ROLLUP_YYYY_MM_DD as PATTERN_DATE,
					 SDT.CUT_DATE,
					CASE WHEN v_IS_EXPANSION = 1 THEN
						PATTERN.EXPANSION_VAL
					ELSE
						PATTERN.LOSS_VAL
					END AS PATTERN_VAL
			  FROM LOSS_FACTOR_PATTERN PATTERN, SYSTEM_DATE_TIME SDT
			  WHERE SDT.TIME_ZONE = p_TIME_ZONE
				  AND SDT.DATA_INTERVAL_TYPE = 1
				  AND SDT.DAY_TYPE = '1'
				  AND PATTERN.PATTERN_DATE(+) = SDT.CUT_DATE
				  AND PATTERN.PATTERN_ID(+) = p_PATTERN_ID
				  AND SDT.CUT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				  AND SDT.MINIMUM_INTERVAL_NUMBER >= v_INTERVAL_NUM
			  ORDER BY PATTERN_DATE;

	  END IF;
	END IF;

END GET_LOSS_FACTOR_PATTERNS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_LOSS_FACTOR_PATTERN
	(
	p_PATTERN_ID IN NUMBER,
	p_CUT_DATE IN DATE,
	p_PATTERN_VAL IN NUMBER
	) AS

	v_FACTOR_TYPE		LOSS_FACTOR_MODEL.FACTOR_TYPE%TYPE;
	v_LOSS_FACTOR_ID	LOSS_FACTOR_MODEL.LOSS_FACTOR_ID%TYPE;

BEGIN

	SELECT MODEL.FACTOR_TYPE, MODEL.LOSS_FACTOR_ID
	INTO v_FACTOR_TYPE, v_LOSS_FACTOR_ID
	FROM LOSS_FACTOR_MODEL MODEL
	WHERE MODEL.PATTERN_ID = p_PATTERN_ID;

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, v_LOSS_FACTOR_ID, EC.ED_LOSS_FACTOR);

	UPDATE LOSS_FACTOR_PATTERN PAT SET
		PAT.EXPANSION_VAL = CASE v_FACTOR_TYPE
							WHEN CONSTANTS.LOSS_FACTOR_EXPANSION
							THEN p_PATTERN_VAL
							ELSE NULL
							END,
		PAT.LOSS_VAL = CASE v_FACTOR_TYPE
						WHEN CONSTANTS.LOSS_FACTOR_LOSS
						THEN p_PATTERN_vAL
						ELSE NULL
						END
	WHERE PAT.PATTERN_ID = p_PATTERN_ID
		AND PAT.PATTERN_DATE = p_CUT_DATE;

	IF SQL%NOTFOUND THEN
		INSERT INTO LOSS_FACTOR_PATTERN (
	  		PATTERN_ID,
		  	PATTERN_DATE,
			EXPANSION_VAL,
			LOSS_VAL
		) VALUES (
			p_PATTERN_ID,
			p_CUT_DATE,
			CASE v_FACTOR_TYPE
				WHEN CONSTANTS.LOSS_FACTOR_EXPANSION
				THEN p_PATTERN_VAL
				ELSE NULL
				END,
			CASE v_FACTOR_TYPE
				WHEN CONSTANTS.LOSS_FACTOR_LOSS
				THEN p_PATTERN_VAL
				ELSE NULL
				END
		);
	END IF;

END PUT_LOSS_FACTOR_PATTERN;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_SCENARIO
	(
	o_OID OUT NUMBER,
	p_SCENARIO_NAME IN VARCHAR2,
	p_SCENARIO_ALIAS IN VARCHAR2,
	p_SCENARIO_DESC IN VARCHAR2,
	p_SCENARIO_ID IN NUMBER,
	p_SCENARIO_CATEGORY IN VARCHAR2,
	p_WEATHER_CASE_ID IN NUMBER,
	p_AREA_LOAD_CASE_ID IN NUMBER,
	p_ENROLLMENT_CASE_ID IN NUMBER,
	p_CALENDAR_CASE_ID IN NUMBER,
	p_USAGE_FACTOR_CASE_ID IN NUMBER,
	p_GROWTH_FACTOR_CASE_ID IN NUMBER,
	p_LOSS_FACTOR_CASE_ID IN NUMBER,
	p_USE_DAY_TYPES IN NUMBER,
	p_RUN_MODE IN NUMBER
	) AS

	v_STATUS NUMBER(9);

BEGIN

	IO.PUT_SCENARIO(o_OID,
		p_SCENARIO_NAME,
		p_SCENARIO_ALIAS,
		p_SCENARIO_DESC,
		p_SCENARIO_ID,
		p_SCENARIO_CATEGORY);

	IF UPPER(p_SCENARIO_CATEGORY) = UPPER(CONSTANTS.SCENARIO_LOAD_FORECAST) THEN
		SP.PUT_LOAD_FORECAST_SCENARIO(o_OID,
			p_WEATHER_CASE_ID,
			p_AREA_LOAD_CASE_ID,
			p_ENROLLMENT_CASE_ID,
			p_CALENDAR_CASE_ID,
			p_USAGE_FACTOR_CASE_ID,
			p_GROWTH_FACTOR_CASE_ID,
			p_LOSS_FACTOR_CASE_ID,
			p_RUN_MODE,
			p_USE_DAY_TYPES,
			SP.IGNORE_LIST,
			v_STATUS);
	END IF;

END PUT_SCENARIO;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SCENARIO
	(
	p_SCENARIO_ID IN NUMBER,
	p_SCENARIO_NAME OUT VARCHAR2,
	p_SCENARIO_ALIAS OUT VARCHAR2,
	p_SCENARIO_DESC OUT VARCHAR2,
	p_SCENARIO_CATEGORY OUT VARCHAR2,
	p_WEATHER_CASE_ID OUT NUMBER,
	p_WEATHER_CASE_DISP OUT VARCHAR2,
	p_AREA_LOAD_CASE_ID OUT NUMBER,
	p_AREA_LOAD_CASE_DISP OUT VARCHAR2,
	p_ENROLLMENT_CASE_ID OUT NUMBER,
	p_ENROLLMENT_CASE_DISP OUT VARCHAR2,
	p_CALENDAR_CASE_ID OUT NUMBER,
	p_CALENDAR_CASE_DISP OUT VARCHAR2,
	p_USAGE_FACTOR_CASE_ID OUT NUMBER,
	p_USAGE_FACTOR_CASE_DISP OUT VARCHAR2,
	p_GROWTH_FACTOR_CASE_ID OUT NUMBER,
	p_GROWTH_FACTOR_CASE_DISP OUT VARCHAR2,
	p_LOSS_FACTOR_CASE_ID OUT NUMBER,
	p_LOSS_FACTOR_CASE_DISP OUT VARCHAR2,
	p_USE_DAY_TYPES OUT NUMBER,
	p_RUN_MODE OUT NUMBER
	) AS

	v_STATUS_LIST VARCHAR2(500);
	v_STATUS NUMBER(9);

BEGIN

	IO.GET_SCENARIO(p_SCENARIO_ID,
					p_SCENARIO_NAME,
					p_SCENARIO_ALIAS,
					p_SCENARIO_DESC,
					p_SCENARIO_CATEGORY
					);

	IF UPPER(p_SCENARIO_CATEGORY) = UPPER(CONSTANTS.SCENARIO_LOAD_FORECAST) THEN
		SP.GET_LOAD_FORECAST_SCENARIO(p_SCENARIO_ID,
									  p_WEATHER_CASE_ID,
									  p_AREA_LOAD_CASE_ID,
									  p_ENROLLMENT_CASE_ID,
									  p_CALENDAR_CASE_ID,
									  p_USAGE_FACTOR_CASE_ID,
									  p_GROWTH_FACTOR_CASE_ID,
									  p_LOSS_FACTOR_CASE_ID,
									  p_RUN_MODE,
									  p_USE_DAY_TYPES,
									  v_STATUS_LIST,
									  v_STATUS);

		p_WEATHER_CASE_DISP := ENTITY_NAME_FROM_IDS(EC.ED_CASE_LABEL, p_WEATHER_CASE_ID);
		p_AREA_LOAD_CASE_DISP := ENTITY_NAME_FROM_IDS(EC.ED_CASE_LABEL, p_AREA_LOAD_CASE_ID);
		p_ENROLLMENT_CASE_DISP := ENTITY_NAME_FROM_IDS(EC.ED_CASE_LABEL, p_ENROLLMENT_CASE_ID);
		p_CALENDAR_CASE_DISP := ENTITY_NAME_FROM_IDS(EC.ED_CASE_LABEL, p_CALENDAR_CASE_ID);
		p_USAGE_FACTOR_CASE_DISP := ENTITY_NAME_FROM_IDS(EC.ED_CASE_LABEL, p_USAGE_FACTOR_CASE_ID);
		p_GROWTH_FACTOR_CASE_DISP := ENTITY_NAME_FROM_IDS(EC.ED_CASE_LABEL, p_GROWTH_FACTOR_CASE_ID);
		p_LOSS_FACTOR_CASE_DISP := ENTITY_NAME_FROM_IDS(EC.ED_CASE_LABEL, p_LOSS_FACTOR_CASE_ID);

	END IF;

END GET_SCENARIO;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SCENARIO_ACCT_STATUS
	(
	p_SCENARIO_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_SCENARIO_ID, EC.ED_SCENARIO);

	OPEN p_CURSOR FOR
	SELECT NAMES.STATUS_NAME,
		   NAMES.IS_ACTIVE,
		   CASE WHEN LF_STATUS.SCENARIO_ID IS NOT NULL
		   	THEN 1
			ELSE 0 END AS IS_ASSIGNED
	FROM ACCOUNT_STATUS_NAME NAMES,
		LOAD_FORECAST_SCENARIO_STATUS LF_STATUS
	WHERE LF_STATUS.STATUS_NAME (+) = NAMES.STATUS_NAME
		AND LF_STATUS.SCENARIO_ID (+) = p_SCENARIO_ID;

END GET_SCENARIO_ACCT_STATUS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_SCENARIO_ACCT_STATUS
	(
	p_SCENARIO_ID IN NUMBER,
	p_STATUS_NAME IN VARCHAR2,
	p_IS_ASSIGNED IN NUMBER
	) AS

	v_HAS_ASSIGNMENT NUMBER(9);

BEGIN

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_SCENARIO_ID, EC.ED_SCENARIO);

	SELECT COUNT(1) INTO v_HAS_ASSIGNMENT
	FROM LOAD_FORECAST_SCENARIO_STATUS LF_STATUS
	WHERE LF_STATUS.SCENARIO_ID = p_SCENARIO_ID
		AND LF_STATUS.STATUS_NAME = p_STATUS_NAME;

	IF p_IS_ASSIGNED = 0 AND v_HAS_ASSIGNMENT > 0 THEN

		DELETE FROM LOAD_FORECAST_SCENARIO_STATUS
		WHERE SCENARIO_ID = p_SCENARIO_ID
			AND STATUS_NAME = p_STATUS_NAME;

	END IF;

	IF p_IS_ASSIGNED = 1 AND v_HAS_ASSIGNMENT = 0 THEN

		INSERT INTO LOAD_FORECAST_SCENARIO_STATUS (SCENARIO_ID, STATUS_NAME)
			VALUES (p_SCENARIO_ID, p_STATUS_NAME);

	END IF;

END PUT_SCENARIO_ACCT_STATUS;
----------------------------------------------------------------------------------------------------
PROCEDURE CALENDAR_PROFILES
	(
	p_CALENDAR_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
	SELECT CAPR.PROFILE_ID,
		   CAPR.BEGIN_DATE,
		   CAPR.END_DATE
	FROM CALENDAR_PROFILE CAPR
	WHERE CAPR.CALENDAR_ID = p_CALENDAR_ID;
END CALENDAR_PROFILES;
----------------------------------------------------------------------------------------------------
PROCEDURE SET_CALENDAR_PROFILE_STATUS
  (
  p_PROFILE_STATUS in VARCHAR2,
  p_PROFILE_ID IN NUMBER
  ) AS
  BEGIN
  
  UPDATE LOAD_PROFILE_STATISTICS SET PROFILE_STATUS = p_PROFILE_STATUS
  WHERE PROFILE_ID = p_PROFILE_ID;
  
  END SET_CALENDAR_PROFILE_STATUS;
-----------------------------------------------------------------------------------------------------  
PROCEDURE SET_CALENDAR_PROFILE_OPERATION
  (
  p_OPERATION in VARCHAR2,
  p_PROFILE_ID IN NUMBER
  ) AS
    
  BEGIN
  
  UPDATE LOAD_PROFILE SET PROFILE_OPERATION = p_OPERATION
  WHERE PROFILE_ID = p_PROFILE_ID;
  
  END SET_CALENDAR_PROFILE_OPERATION;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_PROFILE_INFO
	(
	p_PROFILE_ID IN NUMBER,
	p_STATUS OUT VARCHAR2,
	p_TYPE OUT VARCHAR2,
	p_OPERATION OUT VARCHAR2,
	p_SOURCE_BEGIN_DATE OUT DATE,
	p_SOURCE_END_DATE OUT DATE,
	p_PROFILE_MIN OUT NUMBER,
	p_PROFILE_MAX OUT NUMBER,
	p_PROFILE_ENTRY OUT DATE
	) AS

BEGIN

	SELECT STAT.PROFILE_STATUS,
	       PROF.PROFILE_TYPE,
		   PROF.PROFILE_OPERATION,
		   PROF.PROFILE_SOURCE_BEGIN_DATE,
		   PROF.PROFILE_SOURCE_END_DATE,
		   STAT.PROFILE_MIN,
		   STAT.PROFILE_MAX,
		   PROF.ENTRY_DATE
	INTO p_STATUS,
	     p_TYPE,
		 p_OPERATION,
		 p_SOURCE_BEGIN_DATE,
		 p_SOURCE_END_DATE,
		 p_PROFILE_MIN,
		 p_PROFILE_MAX,
		 p_PROFILE_ENTRY
	FROM LOAD_PROFILE PROF, LOAD_PROFILE_STATISTICS STAT
	WHERE PROF.PROFILE_ID = p_PROFILE_ID
		AND STAT.PROFILE_ID(+) = PROF.PROFILE_ID;

END GET_PROFILE_INFO;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_PROFILES_FOR_CALENDAR
	(
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
		SELECT DISTINCT PROF.PROFILE_ID,
		   STAT.PROFILE_STATUS,
		   PROF.PROFILE_OPERATION
	FROM CALENDAR_PROFILE CAL,
		 LOAD_PROFILE PROF,
		 LOAD_PROFILE_STATISTICS STAT
	WHERE CAL.PROFILE_ID = PROF.PROFILE_ID
		AND STAT.PROFILE_ID(+) = PROF.PROFILE_ID;

END GET_PROFILES_FOR_CALENDAR;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_PROFILES_FOR_CALENDAR
	(
	p_PROFILE_ID IN NUMBER,
	p_PROFILE_STATUS IN VARCHAR2,
	p_PROFILE_OPERATION IN VARCHAR2
	) AS

BEGIN

	UPDATE LOAD_PROFILE PROF
	SET PROF.PROFILE_OPERATION = p_PROFILE_OPERATION
	WHERE PROF.PROFILE_ID = p_PROFILE_ID;

	UPDATE LOAD_PROFILE_STATISTICS STAT
	SET STAT.PROFILE_STATUS = p_PROFILE_STATUS
	WHERE STAT.PROFILE_ID = p_PROFILE_ID;

	IF SQL%NOTFOUND THEN
		INSERT INTO LOAD_PROFILE_STATISTICS
			(PROFILE_ID, AS_OF_DATE, PROFILE_STATUS)
		VALUES
			(p_PROFILE_ID, LOW_DATE(), p_PROFILE_STATUS);
	END IF;
END PUT_PROFILES_FOR_CALENDAR;
----------------------------------------------------------------------------------------------------
PROCEDURE CALENDAR_LIBRARYS
	(
	p_CALENDAR_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
	SELECT LIB.PROFILE_LIBRARY_ID,
		LIB.BEGIN_DATE,
		LIB.END_DATE,
		LIB.ENTRY_DATE
	FROM CALENDAR_PROFILE_LIBRARY LIB
	WHERE LIB.CALENDAR_ID = p_CALENDAR_ID;

END CALENDAR_LIBRARYS;
----------------------------------------------------------------------------------------------------
PROCEDURE CALENDAR_ADJUSTMENTS
	(
	p_CALENDAR_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
	SELECT ADJ.BEGIN_DATE, ADJ.END_DATE, ADJ.ADJ_OP, ADJ.ADJ_VAL, ADJ.ENTRY_DATE
	FROM CALENDAR_ADJUSTMENT ADJ
	WHERE ADJ.CALENDAR_ID = p_CALENDAR_ID;

END CALENDAR_ADJUSTMENTS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_CALENDAR_RESULTS
	(
	p_CALENDAR_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_WEATHER_STATION_ID IN NUMBER,
	p_WEATHER_CODE IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
    p_INTERVAL OUT VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	) AS

	v_CURRENT_DATE DATE := TRUNC(p_BEGIN_DATE);
	v_TOTAL_PROFILE	STRING_TABLE := STRING_TABLE();
	v_CURRENT_PROFILE GA.NUMBER_TABLE;

	v_INDEX NUMBER(9);
	v_VALUE NUMBER;
	v_COUNT NUMBER;
	v_IS_DAILY BOOLEAN;

	v_INT_DIV NUMBER;

BEGIN
	-- nothing to see if no calendar is specified
	IF p_CALENDAR_ID IS NULL OR p_CALENDAR_ID IN (CONSTANTS.NOT_ASSIGNED,CONSTANTS.NEW_ENT_ID) THEN
		NULL_CURSOR(p_CURSOR);
		RETURN;
	END IF;

	WHILE v_CURRENT_DATE <= p_END_DATE LOOP
		FS.COMPOSITE_PROFILE_FOR_CALENDAR(p_WEATHER_STATION_ID,
										  p_CALENDAR_ID,
										  p_EDC_ID,
										  v_CURRENT_DATE,
										  v_CURRENT_PROFILE,
										  TRUE,
										  SUBSTR(p_WEATHER_CODE,1,1) );

		v_COUNT := 1;

		p_INTERVAL := FP.GET_INTERVAL_FOR_CALENDAR(p_CALENDAR_ID, v_CURRENT_DATE);
		v_INT_DIV := DATE_UTIL.GET_INTERVAL_DIVISOR('DD', p_INTERVAL, v_CURRENT_DATE, GA.CUT_TIME_ZONE);
		v_IS_DAILY := v_CURRENT_PROFILE.FIRST = v_CURRENT_PROFILE.LAST;
		FOR v_INDEX IN v_CURRENT_PROFILE.FIRST..v_CURRENT_PROFILE.LAST LOOP
			IF v_CURRENT_PROFILE.EXISTS(v_INDEX) THEN
				v_VALUE := v_CURRENT_PROFILE(v_INDEX);
			ELSE
				v_VALUE := 0;
			END IF;

			v_TOTAL_PROFILE.EXTEND();

			--Daily Profile -- do not put any hours on the date.
			IF v_IS_DAILY THEN
				v_TOTAL_PROFILE(v_TOTAL_PROFILE.LAST):=
					STRING_TYPE(TO_CHAR(v_CURRENT_DATE, 'YYYY-MM-DD')
						|| ';' || TO_CHAR(v_VALUE));
			--Sub-Daily Profile -- include time on the date.
			ELSE
				v_TOTAL_PROFILE(v_TOTAL_PROFILE.LAST):=
					STRING_TYPE(TO_HED(v_CURRENT_DATE+v_COUNT/v_INT_DIV,
								GET_INTERVAL_ABBREVIATION(p_INTERVAL))
						|| ';' || TO_CHAR(v_VALUE));
			END IF;

			v_COUNT := v_COUNT + 1;
		END LOOP;

		v_CURRENT_DATE := v_CURRENT_DATE + 1;
	END LOOP;

	OPEN p_CURSOR FOR
	SELECT SUBSTR(PROF.STRING_VAL, 1, INSTR(PROF.STRING_VAL, ';')-1) AS LOAD_DATE,
			TO_NUMBER(SUBSTR(PROF.STRING_VAL, INSTR(PROF.STRING_VAL, ';')+1)) AS LOAD_VALUE
	FROM TABLE(CAST(v_TOTAL_PROFILE AS STRING_TABLE)) PROF;

END GET_CALENDAR_RESULTS;
----------------------------------------------------------------------------------------------------
PROCEDURE ENTITY_NOTES
    (
    p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ENTITY_ID, p_ENTITY_DOMAIN_ID);

    OPEN p_CURSOR FOR
        SELECT ENTITY_DOMAIN_ID,
            ENTITY_ID,
            NOTE_TYPE,
            NOTE_DATE,
			USER_ID AS NOTE_AUTHOR_ID,
            NVL(USER_DISPLAY_NAME, USER_NAME) AS NOTE_AUTHOR_NAME,
            NOTE_TEXT,
			ENTITY_ID AS OLD_ENTITY_ID,
            NOTE_TYPE AS OLD_NOTE_TYPE,
            NOTE_DATE AS OLD_NOTE_DATE,
            USER_ID AS OLD_NOTE_AUTHOR_ID
        FROM ENTITY_NOTE,
			APPLICATION_USER
        WHERE ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID
			AND ENTITY_ID = p_ENTITY_ID
			AND USER_ID = NOTE_AUTHOR_ID
        ORDER BY ENTITY_ID,
            NOTE_TYPE,
            NOTE_DATE,
            NVL(USER_DISPLAY_NAME, USER_NAME);

END ENTITY_NOTES;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ENTITY_NOTE
    (
    p_ENTITY_DOMAIN_ID IN NUMBER,
    p_ENTITY_ID IN NUMBER,
    p_NOTE_TYPE IN VARCHAR2,
    p_NOTE_TEXT IN VARCHAR2,
    p_NOTE_DATE IN DATE,
    p_NOTE_AUTHOR_ID IN NUMBER,
    p_OLD_NOTE_TYPE IN VARCHAR2
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ENTITY_ID, p_ENTITY_DOMAIN_ID);

    UPDATE ENTITY_NOTE SET
        NOTE_TYPE = p_NOTE_TYPE,
        NOTE_DATE = SYSDATE,
        -- set author to current user if note text was updated
        NOTE_AUTHOR_ID = CASE WHEN NOTE_TEXT=p_NOTE_TEXT THEN NOTE_AUTHOR_ID ELSE SECURITY_CONTROLS.CURRENT_USER_ID END,
        NOTE_TEXT = p_NOTE_TEXT
    WHERE ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID
        AND ENTITY_ID = p_ENTITY_ID
        AND NOTE_TYPE = p_OLD_NOTE_TYPE
        AND NOTE_DATE = p_NOTE_DATE
        AND NOTE_AUTHOR_ID = p_NOTE_AUTHOR_ID;

    IF SQL%NOTFOUND THEN
        INSERT INTO ENTITY_NOTE (
            ENTITY_DOMAIN_ID,
            ENTITY_ID,
            NOTE_TYPE,
            NOTE_DATE,
            NOTE_AUTHOR_ID,
            NOTE_TEXT)
        VALUES (
            p_ENTITY_DOMAIN_ID,
            p_ENTITY_ID,
            p_NOTE_TYPE,
            SYSDATE,
            SECURITY_CONTROLS.CURRENT_USER_ID,
            p_NOTE_TEXT);
    END IF;

END PUT_ENTITY_NOTE;
----------------------------------------------------------------------------------------------------
PROCEDURE DELETE_ENTITY
	(
	p_ENTITY_ID IN NUMBER,
	p_ENTITY_TYPE IN VARCHAR2
	) AS

v_STATUS NUMBER := 0;
v_PROC VARCHAR2(40) := 'BEGIN DE.DEL_' || UPPER(p_ENTITY_TYPE) || '(:1, :2); END;';

BEGIN

	BEGIN

		EXECUTE IMMEDIATE v_PROC USING IN p_ENTITY_ID, OUT v_STATUS;

	EXCEPTION
		WHEN ERRS.e_COMPILE_ERROR THEN
			ERRS.RAISE(MSGCODES.c_ERR_CANNOT_FIND_DEL_PROC);
	END;

END DELETE_ENTITY;
--------------------------------------------------------------------------------
PROCEDURE DATA_VALIDATION_RULES
    (
    p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ENTITY_ID, p_ENTITY_DOMAIN_ID);

    OPEN p_CURSOR FOR
        SELECT ENTITY_DOMAIN_ID,
            ENTITY_ID,
            BEGIN_DATE,
            END_DATE,
            MIN_VAL,
            MAX_VAL,
            DECODE(HOUR_COMPARE,'P','Percentage','A','Absolute','N','None') AS HOUR_COMPARE,
            HOUR_VAL,
            DISALLOW_NEG,
            ENTRY_DATE
        FROM DATA_VALIDATION_RULE
        WHERE ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID
			AND ENTITY_ID = p_ENTITY_ID
        ORDER BY BEGIN_DATE, END_DATE;

END DATA_VALIDATION_RULES;
--------------------------------------------------------------------------------
PROCEDURE PUT_DATA_VALIDATION_RULE
    (
    p_ENTITY_DOMAIN_ID IN NUMBER,
    p_ENTITY_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_MIN_VAL IN NUMBER,
    p_MAX_VAL IN NUMBER,
    p_HOUR_COMPARE IN VARCHAR2,
    p_HOUR_VAL IN NUMBER,
    p_DISALLOW_NEG IN NUMBER,
    p_OLD_BEGIN_DATE IN DATE
    ) AS
v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ENTITY_ID, p_ENTITY_DOMAIN_ID);

    v_KEY_NEW('ENTITY_DOMAIN_ID') := UT.GET_LITERAL_FOR_NUMBER(p_ENTITY_DOMAIN_ID);
    v_KEY_OLD('ENTITY_DOMAIN_ID') := UT.GET_LITERAL_FOR_NUMBER(p_ENTITY_DOMAIN_ID);
	v_KEY_NEW('ENTITY_ID') := UT.GET_LITERAL_FOR_NUMBER(p_ENTITY_ID);
    v_KEY_OLD('ENTITY_ID') := UT.GET_LITERAL_FOR_NUMBER(p_ENTITY_ID);
    v_DATA('MIN_VAL') := UT.GET_LITERAL_FOR_NUMBER(p_MIN_VAL);
	v_DATA('MAX_VAL') := UT.GET_LITERAL_FOR_NUMBER(p_MAX_VAL);
	v_DATA('HOUR_COMPARE') := UT.GET_LITERAL_FOR_STRING(SUBSTR(p_HOUR_COMPARE,1,1));
	v_DATA('HOUR_VAL') := UT.GET_LITERAL_FOR_STRING(p_HOUR_VAL);
	v_DATA('DISALLOW_NEG') := UT.GET_LITERAL_FOR_NUMBER(p_DISALLOW_NEG);

    UT.PUT_TEMPORAL_DATA_UI('DATA_VALIDATION_RULE',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA);

END PUT_DATA_VALIDATION_RULE;
----------------------------------------------------------------------------------------------------
PROCEDURE CONTRACT_LIST
	(
	p_SEARCH_STRING IN VARCHAR2,
	p_SEARCH_OPTION IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN
	ASSERT(p_SEARCH_OPTION IN (CONSTANTS.SEARCH_OPTION_BY_NAME, CONSTANTS.SEARCH_OPTION_BY_ALIAS, 'By External Identifier'),
			'Search option must be one of ''By Name'', ''By Alias'', and ''By External Identifier''',
			MSGCODES.c_ERR_ARGUMENT);

	IF p_SEARCH_STRING = '%' OR p_SEARCH_STRING IS NULL THEN

		OPEN p_CURSOR FOR
			SELECT CONTRACT_NAME||CASE p_SEARCH_OPTION
									WHEN 'By External Identifier' THEN ' ('||NVL(EXTERNAL_IDENTIFIER,'?')||')'
									WHEN CONSTANTS.SEARCH_OPTION_BY_ALIAS THEN ' ('||NVL(CONTRACT_ALIAS,'?')||')'
									ELSE NULL END as ENTITY_NAME,
					CONTRACT_ID as ENTITY_ID
			FROM SERVICE_CONTRACT
			ORDER BY 1;

	ELSE

		OPEN p_CURSOR FOR
			SELECT CONTRACT_NAME||CASE p_SEARCH_OPTION
									WHEN 'By External Identifier' THEN ' ('||NVL(EXTERNAL_IDENTIFIER,'?')||')'
									WHEN CONSTANTS.SEARCH_OPTION_BY_ALIAS THEN ' ('||NVL(CONTRACT_ALIAS,'?')||')'
									ELSE NULL END as ENTITY_NAME,
					CONTRACT_ID as ENTITY_ID
			FROM SERVICE_CONTRACT
			WHERE CASE p_SEARCH_OPTION
					  WHEN 'By External Identifier' THEN NVL(EXTERNAL_IDENTIFIER,'?')
					  WHEN CONSTANTS.SEARCH_OPTION_BY_ALIAS THEN NVL(CONTRACT_ALIAS,'?')
					  ELSE CONTRACT_NAME END LIKE p_SEARCH_STRING
			ORDER BY 1;

	END IF;
END CONTRACT_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE COPY_CALENDAR
	(
	p_CALENDAR_ID IN NUMBER,
	p_NEW_CALENDAR_ID OUT NUMBER,
	p_FILTER_STRING OUT VARCHAR2
	) AS

	v_CALENDAR_REC CALENDAR%ROWTYPE;

BEGIN

	IO.GET_CALENDAR(p_CALENDAR_ID,
					v_CALENDAR_REC.CALENDAR_NAME,
					v_CALENDAR_REC.CALENDAR_ALIAS,
					v_CALENDAR_REC.CALENDAR_DESC,
					v_CALENDAR_REC.ASSIGNMENT_TYPE,
					v_CALENDAR_REC.HAS_ADJUSTMENTS);

	-- MAKE A FILTER STRING THAT INCLUDES BOTH THE ORIGINAL CALENADAR AND THE COPY
	p_FILTER_STRING := '%' || v_CALENDAR_REC.CALENDAR_NAME || '%';

	v_CALENDAR_REC.CALENDAR_NAME := ENTITY_UTIL.GET_COPY_OF_ENTITY_NAME(v_CALENDAR_REC.CALENDAR_NAME,
						EC.ED_CALENDAR);

	IO.PUT_CALENDAR(p_NEW_CALENDAR_ID,
					v_CALENDAR_REC.CALENDAR_NAME,
					v_CALENDAR_REC.CALENDAR_ALIAS,
					v_CALENDAR_REC.CALENDAR_DESC,
					0,
					v_CALENDAR_REC.ASSIGNMENT_TYPE,
					v_CALENDAR_REC.HAS_ADJUSTMENTS);

	INSERT INTO CALENDAR_PROFILE(CALENDAR_ID, PROFILE_ID, BEGIN_DATE, END_DATE, ENTRY_DATE)
	SELECT p_NEW_CALENDAR_ID, PROFILE_ID, BEGIN_DATE, END_DATE, SYSDATE
	FROM CALENDAR_PROFILE
	WHERE CALENDAR_ID = p_CALENDAR_ID;

	INSERT INTO CALENDAR_ADJUSTMENT (CALENDAR_ID, BEGIN_DATE, END_DATE, ADJ_OP, ADJ_VAL, ENTRY_DATE)
	SELECT p_NEW_CALENDAR_ID, BEGIN_DATE, END_DATE, ADJ_OP, ADJ_VAL, SYSDATE
	FROM CALENDAR_ADJUSTMENT
	WHERE CALENDAR_ID = p_CALENDAR_ID;

	INSERT INTO CALENDAR_PROFILE_LIBRARY (CALENDAR_ID, PROFILE_LIBRARY_ID, BEGIN_DATE, END_DATE, ENTRY_DATE)
	SELECT p_NEW_CALENDAR_ID, PROFILE_LIBRARY_ID, BEGIN_DATE, END_DATE, SYSDATE
	FROM CALENDAR_PROFILE_LIBRARY
	WHERE CALENDAR_ID = p_CALENDAR_ID;

	-- copy the common subtabs
	ENTITY_UTIL.COPY_COMMON_SUBTABS(EC.ED_CALENDAR, p_CALENDAR_ID, p_NEW_CALENDAR_ID);

END COPY_CALENDAR;
----------------------------------------------------------------------------------------------------
PROCEDURE COPY_CONTRACT
	(
	p_CONTRACT_ID IN NUMBER,
	p_NEW_CONTRACT_ID OUT NUMBER,
	p_FILTER_STRING OUT VARCHAR2
	) AS

	v_CONTRACT_REC SERVICE_CONTRACT%ROWTYPE;

BEGIN

	IO.GET_CONTRACT(p_CONTRACT_ID,
				v_CONTRACT_REC.CONTRACT_NAME,
				v_CONTRACT_REC.CONTRACT_ALIAS,
				v_CONTRACT_REC.CONTRACT_DESC,
				v_CONTRACT_REC.EXTERNAL_IDENTIFIER,
				v_CONTRACT_REC.BEGIN_DATE,
				v_CONTRACT_REC.END_DATE,
				v_CONTRACT_REC.IS_ESTIMATED_END_DATE,
				v_CONTRACT_REC.IS_EVERGREEN,
				v_CONTRACT_REC.IS_INTERRUPTIBLE,
				v_CONTRACT_REC.EXPECTED_RENEWAL_PCT,
				v_CONTRACT_REC.NEXT_ACTION_DATE,
				v_CONTRACT_REC.NOTIFICATION_REQUIREMENTS,
				v_CONTRACT_REC.CURTAILMENT_ABILITY,
				v_CONTRACT_REC.PENALTY_CLAUSES,
				v_CONTRACT_REC.PRICING_MODEL);

	p_FILTER_STRING := '%' || v_CONTRACT_REC.CONTRACT_NAME || '%';
	v_CONTRACT_REC.CONTRACT_NAME := ENTITY_UTIL.GET_COPY_OF_ENTITY_NAME(v_CONTRACT_REC.CONTRACT_NAME,
															EC.ED_CONTRACT);

	IO.PUT_CONTRACT(p_NEW_CONTRACT_ID,
				v_CONTRACT_REC.CONTRACT_NAME,
				v_CONTRACT_REC.CONTRACT_ALIAS,
				v_CONTRACT_REC.CONTRACT_DESC,
				0,
				v_CONTRACT_REC.EXTERNAL_IDENTIFIER,
				v_CONTRACT_REC.BEGIN_DATE,
				v_CONTRACT_REC.END_DATE,
				v_CONTRACT_REC.IS_ESTIMATED_END_DATE,
				v_CONTRACT_REC.IS_EVERGREEN,
				v_CONTRACT_REC.IS_INTERRUPTIBLE,
				v_CONTRACT_REC.EXPECTED_RENEWAL_PCT,
				v_CONTRACT_REC.NEXT_ACTION_DATE,
				v_CONTRACT_REC.NOTIFICATION_REQUIREMENTS,
				v_CONTRACT_REC.CURTAILMENT_ABILITY,
				v_CONTRACT_REC.PENALTY_CLAUSES,
				v_CONTRACT_REC.PRICING_MODEL);


	INSERT INTO CONTRACT_ASSIGNMENT (CONTRACT_ID, ENTITY_DOMAIN_ID, OWNER_ENTITY_ID,
							BEGIN_DATE, END_DATE, ENTITY_NAME, ENTRY_DATE)
	SELECT p_NEW_CONTRACT_ID, ENTITY_DOMAIN_ID, OWNER_ENTITY_ID, BEGIN_DATE, END_DATE,
		ENTITY_NAME, SYSDATE
	FROM CONTRACT_ASSIGNMENT
	WHERE CONTRACT_ID = p_CONTRACT_ID;

	ENTITY_UTIL.COPY_COMMON_SUBTABS(EC.ED_CONTRACT, p_CONTRACT_ID,
									p_NEW_CONTRACT_ID);


END COPY_CONTRACT;
----------------------------------------------------------------------------------------------------
PROCEDURE CONTRACT_ASSIGNMENT_NUMEROUS
(
	p_IS_NUMEROUS OUT NUMBER
) AS

	v_NUM_NUMEROUS NUMBER(9);

BEGIN

	SELECT SUM(CASE WHEN SD.VALUE = 1 THEN 1 ELSE 0 END)
	INTO v_NUM_NUMEROUS
	FROM SYSTEM_DICTIONARY SD,
		SYSTEM_LABEL SL
	WHERE SD.MODEL_ID = CONSTANTS.GLOBAL_MODEL
		AND SD.MODULE = 'Entity Manager'
		AND SD.KEY1 = g_SHOW_FIND_IN_TREE
		AND NVL(SD.KEY2, '?') = '?'
		AND NVL(SD.KEY3, '?') = '?'
		AND UPPER(SD.SETTING_NAME) = UPPER(SL.VALUE)
		AND SL.MODEL_ID = CONSTANTS.GLOBAL_MODEL
		AND SL.MODULE = 'Load Management'
		AND SL.KEY1 = 'Contracts'
		AND SL.KEY2 = 'Assignable Domains'
		AND NVL(SL.KEY3, '?') = '?';

	IF v_NUM_NUMEROUS > 0 THEN
		p_IS_NUMEROUS := 1;
	ELSE
		p_IS_NUMEROUS := 0;
	END IF;

END CONTRACT_ASSIGNMENT_NUMEROUS;
----------------------------------------------------------------------------------------------------
PROCEDURE CONTRACT_ENTITY_DOMAINS
(
	p_CURSOR OUT GA.REFCURSOR
) AS

BEGIN

	OPEN p_CURSOR FOR
	SELECT ED.ENTITY_DOMAIN_ID, ED.ENTITY_DOMAIN_NAME
	FROM ENTITY_DOMAIN ED, SYSTEM_LABEL SL
	WHERE SL.MODEL_ID = CONSTANTS.GLOBAL_MODEL
	AND SL.MODULE = 'Load Management'
	AND SL.KEY1 = 'Contracts'
	AND SL.KEY2 = 'Assignable Domains'
	AND NVL(SL.KEY3, '?') = '?'
	AND UPPER(SL.VALUE) = UPPER(ED.ENTITY_DOMAIN_NAME);

END CONTRACT_ENTITY_DOMAINS;
----------------------------------------------------------------------------------------------------
PROCEDURE CONTRACT_ASSIGNMENTS
(
	p_CONTRACT_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
) AS

BEGIN

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_CONTRACT_ID, EC.ED_CONTRACT);

	OPEN p_CURSOR FOR
	SELECT CA.ENTITY_DOMAIN_ID,
		ED.ENTITY_DOMAIN_NAME "ENTITY_DOMAIN_DISPLAY_NAME",
		CA.OWNER_ENTITY_ID "ENTITY_ID",
		ENTITY_NAME_FROM_IDS(CA.ENTITY_DOMAIN_ID, CA.OWNER_ENTITY_ID) "ENTITY_DISPLAY_NAME",
		CA.BEGIN_DATE,
		CA.END_DATE,
		CA.ENTRY_DATE
	FROM CONTRACT_ASSIGNMENT CA, ENTITY_DOMAIN ED
	WHERE CA.CONTRACT_ID = p_CONTRACT_ID
		AND CA.ENTITY_DOMAIN_ID = ED.ENTITY_DOMAIN_ID
	ORDER BY ENTITY_DOMAIN_DISPLAY_NAME,
		ENTITY_DISPLAY_NAME,
		BEGIN_DATE;

END CONTRACT_ASSIGNMENTS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_CONTRACT_ASSIGNMENT
	(
	p_CONTRACT_ID IN NUMBER,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_ENTITY_DOMAIN_ID IN NUMBER,
	p_OLD_ENTITY_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE
	) AS

	BEGIN

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_CONTRACT_ID, EC.ED_CONTRACT);

	UT.PUT_TEMPORAL_DATA_UI('CONTRACT_ASSIGNMENT',
							p_BEGIN_DATE,
							p_END_DATE,
							p_OLD_BEGIN_DATE,
							TRUE,
							'ENTITY_DOMAIN_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_ENTITY_DOMAIN_ID),
							UT.GET_LITERAL_FOR_NUMBER(p_OLD_ENTITY_DOMAIN_ID),
							TRUE,
							'OWNER_ENTITY_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_ENTITY_ID),
							UT.GET_LITERAL_FOR_NUMBER(p_OLD_ENTITY_ID),
							TRUE,
							'CONTRACT_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_CONTRACT_ID),
							UT.GET_LITERAL_FOR_NUMBER(p_CONTRACT_ID),
							TRUE);

END PUT_CONTRACT_ASSIGNMENT;
-------------------------------------------------------------------------------------------
PROCEDURE GET_DER_TYPE
	(
	p_DER_TYPE_ID IN NUMBER,
	p_DER_TYPE_NAME OUT VARCHAR2,
	p_DER_TYPE_ALIAS OUT VARCHAR2,
	p_DER_TYPE_DESC OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_RUNNING_RATE OUT VARCHAR2,
	p_DER_TYPE_FUNCTION OUT VARCHAR2,
	p_DER_TYPE_CATEGORY OUT VARCHAR2,
	p_DEFAULT_FAILURE_PCT OUT NUMBER,
	p_USE_DEFAULT_FAIL_PCT OUT NUMBER
	) AS

	v_TOTAL_FAILED NUMBER(9);
	v_TOTAL_SIGNALED NUMBER(9);
	v_COUNT_HISTORY NUMBER(9);

	v_RUNNING_RATE NUMBER(5,2);

BEGIN

	EM_GET.DER_TYPE(p_DER_TYPE_ID,
					p_DER_TYPE_NAME,
					p_DER_TYPE_ALIAS,
					p_DER_TYPE_DESC,
					p_DER_TYPE_FUNCTION,
					p_DER_TYPE_CATEGORY,
					p_DEFAULT_FAILURE_PCT,
					p_USE_DEFAULT_FAIL_PCT,
					p_EXTERNAL_IDENTIFIER);

	IF p_DER_TYPE_ID > 0 THEN
		SELECT SUM(HIST.TOTAL_FAILED), SUM(HIST.TOTAL_SIGNALED), COUNT(1)
		INTO v_TOTAL_FAILED, v_TOTAL_SIGNALED, v_COUNT_HISTORY
		FROM DER_TYPE_HISTORY HIST
		WHERE HIST.DER_TYPE_ID = p_DER_TYPE_ID;

		v_RUNNING_RATE := (v_TOTAL_FAILED/v_TOTAL_SIGNALED)*100;

		IF v_COUNT_HISTORY > 0 THEN
			p_RUNNING_RATE := v_RUNNING_RATE || '% (' || v_COUNT_HISTORY || ' Events)';
		ELSE
			p_RUNNING_RATE := 'N/A (0 Events)';
		END IF;
	END IF;

END GET_DER_TYPE;
----------------------------------------------------------------------------------------------------
PROCEDURE DER_TYPES
	(
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
	SELECT DT.DER_TYPE_ID, DT.DER_TYPE_NAME
	FROM DER_TYPE DT
	WHERE DT.DER_TYPE_ID <> CONSTANTS.NOT_ASSIGNED;

END DER_TYPES;
----------------------------------------------------------------------------------------------------
PROCEDURE DER_TYPE_CALENDARS
    (
    p_DER_TYPE_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_DER_TYPE_ID, EC.ED_DER_TYPE);

    OPEN p_CURSOR FOR
        SELECT DC.DER_TYPE_ID,
			DC.CASE_ID,
            DC.BEGIN_DATE,
            DC.END_DATE,
            DC.CALENDAR_ID,
			CAL.CALENDAR_NAME,
			CL.CASE_NAME,
            DC.ENTRY_DATE
        FROM DER_TYPE_CALENDAR DC,
			CASE_LABEL CL,
			CALENDAR CAL
        WHERE DC.DER_TYPE_ID = p_DER_TYPE_ID
			AND CAL.CALENDAR_ID = DC.CALENDAR_ID
			AND CL.CASE_ID = DC.CASE_ID
        ORDER BY BEGIN_DATE;

END DER_TYPE_CALENDARS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_DER_TYPE_CALENDAR
    (
    p_DER_TYPE_ID IN NUMBER,
	p_CASE_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_CALENDAR_ID IN NUMBER,
	p_OLD_CASE_ID IN NUMBER,
    p_OLD_BEGIN_DATE IN DATE
    ) AS
v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_DER_TYPE_ID, EC.ED_DER_TYPE);

    v_KEY_NEW('DER_TYPE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_DER_TYPE_ID);
    v_KEY_OLD('DER_TYPE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_DER_TYPE_ID);
	v_KEY_NEW('CASE_ID') := UT.GET_LITERAL_FOR_NUMBER(NVL(p_CASE_ID, GA.BASE_CASE_ID));
    v_KEY_OLD('CASE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_CASE_ID);
    v_DATA('CALENDAR_ID') := UT.GET_LITERAL_FOR_NUMBER(p_CALENDAR_ID);

    UT.PUT_TEMPORAL_DATA_UI('DER_TYPE_CALENDAR',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

END PUT_DER_TYPE_CALENDAR;
----------------------------------------------------------------------------------------------------
PROCEDURE DER_CALENDARS
    (
    p_DER_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_DER_ID, EC.ED_DER);

    OPEN p_CURSOR FOR
        SELECT DC.DER_ID,
			DC.CASE_ID,
            DC.BEGIN_DATE,
            DC.END_DATE,
            DC.CALENDAR_ID,
			CAL.CALENDAR_NAME,
			CL.CASE_NAME,
            DC.ENTRY_DATE
        FROM DER_CALENDAR DC,
			CALENDAR CAL,
			CASE_LABEL CL
        WHERE DC.DER_ID = p_DER_ID
			AND CL.CASE_ID = DC.CASE_ID
			AND CAL.CALENDAR_ID = DC.CALENDAR_ID
        ORDER BY BEGIN_DATE;

END DER_CALENDARS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_DER_CALENDAR
    (
    p_DER_ID IN NUMBER,
	p_CASE_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_CALENDAR_ID IN NUMBER,
	p_OLD_CASE_ID IN NUMBER,
    p_OLD_BEGIN_DATE IN DATE
    ) AS
v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_DER_ID, EC.ED_DER);

    v_KEY_NEW('DER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_DER_ID);
    v_KEY_OLD('DER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_DER_ID);
	v_KEY_NEW('CASE_ID') := UT.GET_LITERAL_FOR_NUMBER(NVL(p_CASE_ID, GA.BASE_CASE_ID));
    v_KEY_OLD('CASE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_CASE_ID);
    v_DATA('CALENDAR_ID') := UT.GET_LITERAL_FOR_NUMBER(p_CALENDAR_ID);

    UT.PUT_TEMPORAL_DATA_UI('DER_CALENDAR',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

END PUT_DER_CALENDAR;
----------------------------------------------------------------------------------------------------
PROCEDURE DER_SCALE_FACTORS
    (
    p_DER_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_DER_ID, EC.ED_DER);

    OPEN p_CURSOR FOR
        SELECT DSF.DER_ID,
			DSF.CASE_ID,
            DSF.BEGIN_DATE,
            DSF.END_DATE,
            DSF.SCALE_FACTOR,
			CL.CASE_NAME,
            DSF.ENTRY_DATE
        FROM DER_SCALE_FACTOR DSF,
			CASE_LABEL CL
        WHERE DSF.DER_ID = p_DER_ID
			AND DSF.CASE_ID = CL.CASE_ID
        ORDER BY BEGIN_DATE;

END DER_SCALE_FACTORS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_DER_SCALE_FACTOR
    (
    p_DER_ID IN NUMBER,
	p_CASE_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_SCALE_FACTOR IN NUMBER,
	p_OLD_CASE_ID IN NUMBER,
    p_OLD_BEGIN_DATE IN DATE
    ) AS
v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_DER_ID, EC.ED_DER);

    v_KEY_NEW('DER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_DER_ID);
    v_KEY_OLD('DER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_DER_ID);
	v_KEY_NEW('CASE_ID') := UT.GET_LITERAL_FOR_NUMBER(NVL(p_CASE_ID, GA.BASE_CASE_ID));
    v_KEY_OLD('CASE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_CASE_ID);
    v_DATA('SCALE_FACTOR') := UT.GET_LITERAL_FOR_NUMBER(p_SCALE_FACTOR);

    UT.PUT_TEMPORAL_DATA_UI('DER_SCALE_FACTOR',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

END PUT_DER_SCALE_FACTOR;
----------------------------------------------------------------------------------------------------
PROCEDURE DER_STATUSES
    (
    p_DER_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_DER_ID, EC.ED_DER);

    OPEN p_CURSOR FOR
        SELECT DER_ID,
            BEGIN_DATE,
            END_DATE,
            STATUS_NAME,
            ENTRY_DATE
        FROM DER_STATUS
        WHERE DER_ID = p_DER_ID
        ORDER BY BEGIN_DATE;

END DER_STATUSES;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_DER_STATUS
    (
    p_DER_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_STATUS_NAME IN VARCHAR2,
    p_OLD_BEGIN_DATE IN DATE
    ) AS
v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_DER_ID, EC.ED_DER);

    v_KEY_NEW('DER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_DER_ID);
    v_KEY_OLD('DER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_DER_ID);
    v_DATA('STATUS_NAME') := UT.GET_LITERAL_FOR_STRING(p_STATUS_NAME);

    UT.PUT_TEMPORAL_DATA_UI('DER_STATUS',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

END PUT_DER_STATUS;
----------------------------------------------------------------------------------------------------
PROCEDURE COPY_CALC_COMPONENT
(
	p_ENTITY_ID IN NUMBER,
	p_NEW_ENTITY_ID OUT NUMBER,
	p_NEW_ENTITY_NAME OUT VARCHAR2
) AS

BEGIN

	ENTITY_UTIL.COPY_ENTITY(p_ENTITY_ID,
							'CALC_COMPONENT',
							p_NEW_ENTITY_ID,
							p_NEW_ENTITY_NAME);

	INSERT INTO COMPONENT_FORMULA_ITERATOR (COMPONENT_ID, SUB_COMPONENT_TYPE,
		SUB_COMPONENT_ID, ITERATOR_NAME, BEGIN_DATE, END_DATE,
		ITERATOR_QUERY, IS_MULTICOLUMN, IDENT_COLUMNS, IS_INNER_LOOP,
		COMMENTS, ROW_NUMBER, ENTRY_DATE)
	SELECT p_NEW_ENTITY_ID, SUB_COMPONENT_TYPE,
		SUB_COMPONENT_ID, ITERATOR_NAME, BEGIN_DATE, END_DATE,
		ITERATOR_QUERY, IS_MULTICOLUMN, IDENT_COLUMNS, IS_INNER_LOOP,
		COMMENTS, ROW_NUMBER, SYSDATE
	FROM COMPONENT_FORMULA_ITERATOR
	WHERE COMPONENT_ID = p_ENTITY_ID;

	INSERT INTO COMPONENT_FORMULA_INPUT (COMPONENT_ID, SUB_COMPONENT_TYPE,
		SUB_COMPONENT_ID, INPUT_NAME, BEGIN_DATE, END_DATE, FUNCTION,
		WHERE_CLAUSE, ENTITY_DOMAIN_ID, ENTITY_TYPE, ENTITY_ID, WHAT_FIELD,
		COMMENTS, ROW_NUMBER, VIEW_ORDER, PERSIST_VALUE, STATE_FML,
		STATEMENT_TYPE_FML, SET_NUMBER_FML, CODE_FML, MEASUREMENT_SOURCE_FML,
		ENTRY_DATE)
	SELECT p_NEW_ENTITY_ID, SUB_COMPONENT_TYPE,
		SUB_COMPONENT_ID, INPUT_NAME, BEGIN_DATE, END_DATE, FUNCTION,
		WHERE_CLAUSE, ENTITY_DOMAIN_ID, ENTITY_TYPE, ENTITY_ID, WHAT_FIELD,
		COMMENTS, ROW_NUMBER, VIEW_ORDER, PERSIST_VALUE, STATE_FML,
		STATEMENT_TYPE_FML, SET_NUMBER_FML, CODE_FML, MEASUREMENT_SOURCE_FML,
		SYSDATE
	FROM COMPONENT_FORMULA_INPUT
	WHERE COMPONENT_ID = p_ENTITY_ID;

	INSERT INTO COMPONENT_FORMULA_RESULT (COMPONENT_ID, SUB_COMPONENT_TYPE,
		SUB_COMPONENT_ID, ENTITY_DOMAIN_ID, ENTITY_TYPE, ENTITY_ID, BEGIN_DATE,
		END_DATE, WHAT_FIELD, FORMULA, COMMENTS, STATE_FML, STATEMENT_TYPE_FML,
		SET_NUMBER_FML, CODE_FML, MEASUREMENT_SOURCE_FML, ENTRY_DATE)
	SELECT p_NEW_ENTITY_ID, SUB_COMPONENT_TYPE,
		SUB_COMPONENT_ID, ENTITY_DOMAIN_ID, ENTITY_TYPE, ENTITY_ID, BEGIN_DATE,
		END_DATE, WHAT_FIELD, FORMULA, COMMENTS, STATE_FML, STATEMENT_TYPE_FML,
		SET_NUMBER_FML, CODE_FML, MEASUREMENT_SOURCE_FML, SYSDATE
	FROM COMPONENT_FORMULA_RESULT
	WHERE COMPONENT_ID = p_ENTITY_ID;

	INSERT INTO COMPONENT_FORMULA_VARIABLE (COMPONENT_ID, SUB_COMPONENT_TYPE,
		SUB_COMPONENT_ID, VARIABLE_NAME, BEGIN_DATE, END_DATE, FORMULA, IS_MULTICOLUMN,
		IS_PLSQL, COMMENTS, ROW_NUMBER, VIEW_ORDER, PERSIST_VALUE, ENTRY_DATE)
	SELECT p_NEW_ENTITY_ID, SUB_COMPONENT_TYPE,
		SUB_COMPONENT_ID, VARIABLE_NAME, BEGIN_DATE, END_DATE, FORMULA, IS_MULTICOLUMN,
		IS_PLSQL, COMMENTS, ROW_NUMBER, VIEW_ORDER, PERSIST_VALUE, SYSDATE
	FROM COMPONENT_FORMULA_VARIABLE
	WHERE COMPONENT_ID = p_ENTITY_ID;

END COPY_CALC_COMPONENT;
----------------------------------------------------------------------------------------------------
PROCEDURE COPY_CHARGE_COMPONENT
(
	p_ENTITY_ID IN NUMBER,
	p_NEW_ENTITY_ID OUT NUMBER,
	p_NEW_ENTITY_NAME OUT VARCHAR2,
	p_MESSAGE OUT VARCHAR2
) AS

v_COMPONENT_NAME COMPONENT.COMPONENT_NAME%TYPE;
v_TABS_TO_EXCLUDE STRING_COLLECTION := STRING_COLLECTION(1);
v_PRODUCT_IDS NUMBER_COLLECTION := NUMBER_COLLECTION();
v_ALLOWED_ENTITIES NUMBER_COLLECTION := NUMBER_COLLECTION();
v_NOT_ALLOWED_ENTITIES NUMBER_COLLECTION := NUMBER_COLLECTION();
v_COUNT NUMBER;
v_MESSAGE VARCHAR2(4000);
v_NEW_IMBALANCE_ID NUMBER;

BEGIN

	ENTITY_UTIL.COPY_ENTITY(p_ENTITY_ID, 'COMPONENT', p_NEW_ENTITY_ID, p_NEW_ENTITY_NAME);

	-- Copy PRODUCT_COMPONENT Subtab
	-- Get all existing products linked to the component
	SELECT DISTINCT PC.PRODUCT_ID
	BULK COLLECT INTO v_PRODUCT_IDS
	FROM PRODUCT_COMPONENT PC
	WHERE PC.COMPONENT_ID = p_ENTITY_ID;

	-- Get the products that the user can update
	v_ALLOWED_ENTITIES := SD.GET_ALLOWED_IDS_FROM_SELECTION(SD.g_ACTION_UPDATE_ENT,EC.ED_PRODUCT,v_PRODUCT_IDS,FALSE);

	INSERT INTO PRODUCT_COMPONENT(PRODUCT_ID,COMPONENT_ID,BEGIN_DATE,END_DATE,ENTRY_DATE)
	SELECT PC.PRODUCT_ID, p_NEW_ENTITY_ID, PC.BEGIN_DATE, PC.END_DATE, SYSDATE
	FROM PRODUCT_COMPONENT PC,
		TABLE(CAST(v_ALLOWED_ENTITIES AS NUMBER_COLLECTION)) X
	WHERE PC.COMPONENT_ID = p_ENTITY_ID
		AND PC.PRODUCT_ID = X.COLUMN_VALUE;

	IF (v_ALLOWED_ENTITIES.COUNT != v_PRODUCT_IDS.COUNT) THEN
			-- Get values not allowed
		SELECT X.COLUMN_VALUE
		BULK COLLECT INTO v_NOT_ALLOWED_ENTITIES
		FROM (TABLE(CAST(v_PRODUCT_IDS as NUMBER_COLLECTION))) X
		MINUS
		SELECT Y.COLUMN_VALUE
		FROM (TABLE(CAST(v_ALLOWED_ENTITIES as NUMBER_COLLECTION))) Y;

		v_COUNT := NVL(GET_DICTIONARY_VALUE('Referencing Entities Threshold', 0, 'Entity Manager'),5);
		v_MESSAGE := 'Could not copy Product-Component assignments. User does not have sufficient privilege to update ';

		IF v_NOT_ALLOWED_ENTITIES.COUNT <= v_COUNT THEN
			v_MESSAGE := v_MESSAGE || TEXT_UTIL.TO_CHAR_ENTITY_LIST(v_NOT_ALLOWED_ENTITIES,
										   EC.ED_PRODUCT,
										   TRUE,
										   FALSE);
		ELSE
			v_MESSAGE := v_MESSAGE || 'Product entities. See Process log for more details.';
			LOGS.LOG_NOTICE(v_MESSAGE);
			LOGS.POST_EVENT_DETAILS('Entity List', CONSTANTS.MIME_TYPE_TEXT, TEXT_UTIL.TO_CLOB_ENTITY_LIST(v_NOT_ALLOWED_ENTITIES,EC.ED_PRODUCT));
		END IF;

		p_MESSAGE := v_MESSAGE;
	END IF;

	INSERT INTO COMPONENT_FORMULA_ITERATOR (COMPONENT_ID, SUB_COMPONENT_TYPE,
		SUB_COMPONENT_ID, ITERATOR_NAME, BEGIN_DATE, END_DATE,
		ITERATOR_QUERY, IS_MULTICOLUMN, IDENT_COLUMNS, IS_INNER_LOOP,
		COMMENTS, ROW_NUMBER, ENTRY_DATE)
	SELECT p_NEW_ENTITY_ID, SUB_COMPONENT_TYPE,
		SUB_COMPONENT_ID, ITERATOR_NAME, BEGIN_DATE, END_DATE,
		ITERATOR_QUERY, IS_MULTICOLUMN, IDENT_COLUMNS, IS_INNER_LOOP,
		COMMENTS, ROW_NUMBER, SYSDATE
	FROM COMPONENT_FORMULA_ITERATOR
	WHERE COMPONENT_ID = p_ENTITY_ID;

	INSERT INTO COMPONENT_FORMULA_INPUT (COMPONENT_ID, SUB_COMPONENT_TYPE,
		SUB_COMPONENT_ID, INPUT_NAME, BEGIN_DATE, END_DATE, FUNCTION,
		WHERE_CLAUSE, ENTITY_DOMAIN_ID, ENTITY_TYPE, ENTITY_ID, WHAT_FIELD,
		COMMENTS, ROW_NUMBER, VIEW_ORDER, PERSIST_VALUE, STATE_FML,
		STATEMENT_TYPE_FML, SET_NUMBER_FML, CODE_FML, MEASUREMENT_SOURCE_FML,
		ENTRY_DATE)
	SELECT p_NEW_ENTITY_ID, SUB_COMPONENT_TYPE,
		SUB_COMPONENT_ID, INPUT_NAME, BEGIN_DATE, END_DATE, FUNCTION,
		WHERE_CLAUSE, ENTITY_DOMAIN_ID, ENTITY_TYPE, ENTITY_ID, WHAT_FIELD,
		COMMENTS, ROW_NUMBER, VIEW_ORDER, PERSIST_VALUE, STATE_FML,
		STATEMENT_TYPE_FML, SET_NUMBER_FML, CODE_FML, MEASUREMENT_SOURCE_FML,
		SYSDATE
	FROM COMPONENT_FORMULA_INPUT
	WHERE COMPONENT_ID = p_ENTITY_ID;

	INSERT INTO COMPONENT_FORMULA_RESULT (COMPONENT_ID, SUB_COMPONENT_TYPE,
		SUB_COMPONENT_ID, ENTITY_DOMAIN_ID, ENTITY_TYPE, ENTITY_ID, BEGIN_DATE,
		END_DATE, WHAT_FIELD, FORMULA, COMMENTS, STATE_FML, STATEMENT_TYPE_FML,
		SET_NUMBER_FML, CODE_FML, MEASUREMENT_SOURCE_FML, ENTRY_DATE)
	SELECT p_NEW_ENTITY_ID, SUB_COMPONENT_TYPE,
		SUB_COMPONENT_ID, ENTITY_DOMAIN_ID, ENTITY_TYPE, ENTITY_ID, BEGIN_DATE,
		END_DATE, WHAT_FIELD, FORMULA, COMMENTS, STATE_FML, STATEMENT_TYPE_FML,
		SET_NUMBER_FML, CODE_FML, MEASUREMENT_SOURCE_FML, SYSDATE
	FROM COMPONENT_FORMULA_RESULT
	WHERE COMPONENT_ID = p_ENTITY_ID;

	INSERT INTO COMPONENT_FORMULA_VARIABLE (COMPONENT_ID, SUB_COMPONENT_TYPE,
		SUB_COMPONENT_ID, VARIABLE_NAME, BEGIN_DATE, END_DATE, FORMULA, IS_MULTICOLUMN,
		IS_PLSQL, COMMENTS, ROW_NUMBER, VIEW_ORDER, PERSIST_VALUE, ENTRY_DATE)
	SELECT p_NEW_ENTITY_ID, SUB_COMPONENT_TYPE,
		SUB_COMPONENT_ID, VARIABLE_NAME, BEGIN_DATE, END_DATE, FORMULA, IS_MULTICOLUMN,
		IS_PLSQL, COMMENTS, ROW_NUMBER, VIEW_ORDER, PERSIST_VALUE, SYSDATE
	FROM COMPONENT_FORMULA_VARIABLE
	WHERE COMPONENT_ID = p_ENTITY_ID;

	INSERT INTO COMPONENT_BLOCK_RATE ( COMPONENT_ID, SUB_COMPONENT_TYPE,
		SUB_COMPONENT_ID, BEGIN_DATE, END_DATE, BLOCK_MIN, BLOCK_MAX,
		RATE, CHARGE_MIN, ENTRY_DATE)
	SELECT p_NEW_ENTITY_ID, SUB_COMPONENT_TYPE,
		SUB_COMPONENT_ID, BEGIN_DATE, END_DATE, BLOCK_MIN, BLOCK_MAX,
		RATE, CHARGE_MIN, SYSDATE
	FROM COMPONENT_BLOCK_RATE
	WHERE COMPONENT_ID = p_ENTITY_ID;

	INSERT INTO COMPONENT_COINCIDENT_PEAK ( COMPONENT_ID, SUB_COMPONENT_TYPE,
		SUB_COMPONENT_ID, BEGIN_DATE, END_DATE, A_SYSTEM_LOAD_ID, B_SYSTEM_LOAD_ID,
		RATE, ENTRY_DATE)
	SELECT p_NEW_ENTITY_ID, SUB_COMPONENT_TYPE,
		SUB_COMPONENT_ID, BEGIN_DATE, END_DATE, A_SYSTEM_LOAD_ID, B_SYSTEM_LOAD_ID,
		RATE, SYSDATE
	FROM COMPONENT_COINCIDENT_PEAK
	WHERE COMPONENT_ID = p_ENTITY_ID;

	INSERT INTO COMPONENT_COMBINATION ( COMPONENT_ID, SUB_COMPONENT_TYPE,
		SUB_COMPONENT_ID, COMBINED_COMPONENT_ID,  BEGIN_DATE, END_DATE,
		COEFFICIENT, ENTRY_DATE)
	SELECT p_NEW_ENTITY_ID, SUB_COMPONENT_TYPE,
		SUB_COMPONENT_ID, COMBINED_COMPONENT_ID,  BEGIN_DATE, END_DATE,
		COEFFICIENT, SYSDATE
	FROM COMPONENT_COMBINATION
	WHERE COMPONENT_ID = p_ENTITY_ID;

	INSERT INTO COMPONENT_COMPOSITE ( COMPONENT_ID, SUB_COMPONENT_TYPE,
		SUB_COMPONENT_ID, BEGIN_DATE, END_DATE, BLOCK_MIN, BLOCK_MAX,
		COMPOSITE_COMPONENT_ID, ENTRY_DATE)
	SELECT p_NEW_ENTITY_ID, SUB_COMPONENT_TYPE,
		SUB_COMPONENT_ID, BEGIN_DATE, END_DATE, BLOCK_MIN, BLOCK_MAX,
		COMPOSITE_COMPONENT_ID, SYSDATE
	FROM COMPONENT_COMPOSITE
	WHERE COMPONENT_ID = p_ENTITY_ID;

	INSERT INTO COMPONENT_CONVERSION_RATE ( COMPONENT_ID, SUB_COMPONENT_TYPE,
	 	SUB_COMPONENT_ID,  SCHEDULE_GROUP_ID, BEGIN_DATE, END_DATE,
		COEFF_X3, COEFF_X2, COEFF_X1, CONST_K, RATE, CHARGE_MIN, ENTRY_DATE)
	SELECT p_NEW_ENTITY_ID, SUB_COMPONENT_TYPE,
	 	SUB_COMPONENT_ID,  SCHEDULE_GROUP_ID, BEGIN_DATE, END_DATE,
		COEFF_X3, COEFF_X2, COEFF_X1, CONST_K, RATE, CHARGE_MIN, SYSDATE
	FROM COMPONENT_CONVERSION_RATE
	WHERE COMPONENT_ID = p_ENTITY_ID;

	INSERT INTO COMPONENT_ENTITY_ATTRIBUTE (COMPONENT_ID, SUB_COMPONENT_TYPE,
		SUB_COMPONENT_ID, ENTITY_DOMAIN_ID, ENTITY_ATTRIBUTE_ID, BEGIN_DATE,
		END_DATE, ENTRY_DATE)
	SELECT p_NEW_ENTITY_ID, SUB_COMPONENT_TYPE,
		SUB_COMPONENT_ID, ENTITY_DOMAIN_ID, ENTITY_ATTRIBUTE_ID, BEGIN_DATE,
		END_DATE, SYSDATE
	FROM COMPONENT_ENTITY_ATTRIBUTE
	WHERE COMPONENT_ID = p_ENTITY_ID;

	INSERT INTO COMPONENT_FLAT_RATE (COMPONENT_ID, SUB_COMPONENT_TYPE,
		SUB_COMPONENT_ID, BEGIN_DATE, END_DATE, RATE, CHARGE_MIN, ENTRY_DATE)
	SELECT p_NEW_ENTITY_ID, SUB_COMPONENT_TYPE,
		SUB_COMPONENT_ID, BEGIN_DATE, END_DATE, RATE, CHARGE_MIN, SYSDATE
	FROM COMPONENT_FLAT_RATE
	WHERE COMPONENT_ID = p_ENTITY_ID;

	FOR v_REC IN (SELECT CI.SUB_COMPONENT_TYPE,  CI.SUB_COMPONENT_ID,
		CI.BEGIN_DATE, CI.END_DATE, CI.SERVICE_POINT_ID, CI.UNDER_UNDER_PRICE_ID, CI.UNDER_OVER_PRICE_ID,
		CI.OVER_UNDER_PRICE_ID, CI.OVER_OVER_PRICE_ID, CI.IS_PERCENT, CI.IS_PRORATE,
		CI.SETTLEMENT_AGENT, CI.IMBALANCE_ID FROM COMPONENT_IMBALANCE CI WHERE CI.COMPONENT_ID = p_ENTITY_ID) LOOP

		SELECT OID.NEXTVAL INTO v_NEW_IMBALANCE_ID FROM DUAL;

		INSERT INTO COMPONENT_IMBALANCE (COMPONENT_ID, SUB_COMPONENT_TYPE, SUB_COMPONENT_ID,
		BEGIN_DATE, END_DATE, SERVICE_POINT_ID, UNDER_UNDER_PRICE_ID, UNDER_OVER_PRICE_ID,
		OVER_UNDER_PRICE_ID, OVER_OVER_PRICE_ID, IS_PERCENT, IS_PRORATE,
		SETTLEMENT_AGENT, IMBALANCE_ID, ENTRY_DATE)
		VALUES (
		p_NEW_ENTITY_ID,
		v_REC.SUB_COMPONENT_TYPE,
		v_REC.SUB_COMPONENT_ID,
		v_REC.BEGIN_DATE,
		v_REC.END_DATE,
		v_REC.SERVICE_POINT_ID,
		v_REC.UNDER_UNDER_PRICE_ID,
		v_REC.UNDER_OVER_PRICE_ID,
		v_REC.OVER_UNDER_PRICE_ID,
		v_REC.OVER_OVER_PRICE_ID,
		v_REC.IS_PERCENT,
		v_REC.IS_PRORATE,
		v_REC.SETTLEMENT_AGENT,
		v_NEW_IMBALANCE_ID, -- New Imbalance Id
		SYSDATE );

		-- Copy COMPONENT_IMBALANCE_BAND
		INSERT INTO COMPONENT_IMBALANCE_BAND (IMBALANCE_ID, BAND_TYPE, BAND_NUMBER, BAND_MINIMUM, BAND_THRESHOLD,
		BAND_MULTIPLIER, BAND_CHARGE, ENTRY_DATE)
		SELECT v_NEW_IMBALANCE_ID, CIM.BAND_TYPE, CIM.BAND_NUMBER, CIM.BAND_MINIMUM, CIM.BAND_THRESHOLD,
		CIM.BAND_MULTIPLIER, CIM.BAND_CHARGE, SYSDATE
		FROM COMPONENT_IMBALANCE_BAND CIM
		WHERE CIM.IMBALANCE_ID = v_REC.IMBALANCE_ID;

	END LOOP;

	INSERT INTO COMPONENT_MARKET_PRICE (COMPONENT_ID, SUB_COMPONENT_TYPE, SUB_COMPONENT_ID,
		BEGIN_DATE, END_DATE, RATE_ADDER, RATE_MULTIPLIER, ENTRY_DATE)
	SELECT p_NEW_ENTITY_ID, SUB_COMPONENT_TYPE, SUB_COMPONENT_ID,
		BEGIN_DATE, END_DATE, RATE_ADDER, RATE_MULTIPLIER, SYSDATE
	FROM COMPONENT_MARKET_PRICE
	WHERE COMPONENT_ID = p_ENTITY_ID;

	INSERT INTO COMPONENT_TOU_RATE (COMPONENT_ID, SUB_COMPONENT_TYPE, SUB_COMPONENT_ID,
		PERIOD_ID, BEGIN_DATE, END_DATE, RATE, CHARGE_MIN, ENTRY_DATE)
	SELECT p_NEW_ENTITY_ID, SUB_COMPONENT_TYPE, SUB_COMPONENT_ID,
		PERIOD_ID, BEGIN_DATE, END_DATE, RATE, CHARGE_MIN, SYSDATE
	FROM COMPONENT_TOU_RATE
	WHERE COMPONENT_ID = p_ENTITY_ID;

END COPY_CHARGE_COMPONENT;
----------------------------------------------------------------------------------------------------
-- CALLED ONLY ONCE A TOU TEMPLATE HAS BEEN VERIFIED TO BE EXHAUSTIVE AND NON-OVERLAPPING, THIS
-- PROCEDURE FILLS TEMPLATE_DAY_TYPE FOR THE TEMPLATE
PROCEDURE FILL_TEMPLATE_DAY_TYPE
	(
	p_TEMPLATE_ID IN NUMBER
	) AS

	v_DAY_NAMES STRING_COLLECTION := STRING_COLLECTION('Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun', 'Hol');

	-- SPRING AHEAD AND FALL BACK HOUR IN THE DST_TYPE_PERIOD TIMESTAMP ENCODING
	v_DST_SA_HR NUMBER := TO_NUMBER(TO_CHAR(DST_SPRING_AHEAD_DATE(LOW_DATE), 'HH24')) / 24;
	v_DST_FB_HR NUMBER := TO_NUMBER(TO_CHAR(DST_FALL_BACK_DATE(LOW_DATE), 'HH24')) / 24;

BEGIN

	-- FIRST, CLEAR OUT TEMPLATE_DAY_TYPE_PERIOD FOR THIS TEMPLATE
	DELETE FROM TEMPLATE_DAY_TYPE_PERIOD TDTP
	WHERE TDTP.DAY_TYPE_ID IN (SELECT TDT.DAY_TYPE_ID
								FROM TEMPLATE_DAY_TYPE TDT
								WHERE TDT.TEMPLATE_ID = p_TEMPLATE_ID);

	INSERT INTO TEMPLATE_DAY_TYPE_PERIOD (DAY_TYPE_ID, TIME_STAMP, MINIMUM_INTERVAL_NUMBER, PERIOD_ID)
	SELECT EM.ENSURE_DAY_TYPE_RECORD(p_TEMPLATE_ID,
									ST.SEASON_ID,
									DN.COLUMN_VALUE,
									DST_TYPES.DST_TYPE),
			TIMES.TS,
			-- WE CAN'T GIVE AN INTERVAL NUMBER GREATER THAN HOURLY BECAUSE
			-- THEN IT DEPENDS ON TIME_ZONE (WHETHER IT'S DAILY OR NOT)
			LEAST(
				POPULATE_SYSTEM_DATE_TIME.GET_MINIMUM_INTERVAL_NUMBER(LOW_DATE+TIMES.TS),
				GET_INTERVAL_NUMBER('HH')),
			ST.PERIOD_ID
	FROM SEASON_TEMPLATE ST,
		TABLE(CAST(v_DAY_NAMES AS STRING_COLLECTION)) DN,
		(SELECT LEVEL/288 AS TS,
			LEVEL*5 AS INTVL
			FROM DUAL
			CONNECT BY LEVEL <= 288) TIMES,
		-- WE FILL BOTH DST 24 HOUR DST_TYPES AT THE SAME TIME
		(SELECT CONSTANTS.DST_TYPE_NONE AS DST_TYPE
			FROM DUAL
		UNION ALL
		SELECT CONSTANTS.DST_TYPE_DST_PERIOD AS DST_TYPE
			FROM DUAL) DST_TYPES
	WHERE ST.TEMPLATE_ID = p_TEMPLATE_ID
		AND ST.DAY_NAME = DN.COLUMN_VALUE
			-- CONVERT THE STRING ENCODINGS TO THE NUMBER OF MINUTES PAST MIDNIGHT
			-- (INCLUDING THE SECONDS FIELD)
		AND TIMES.INTVL BETWEEN ( TO_NUMBER(SUBSTR(ST.BEGIN_INTERVAL, 1, 2))*60	+
									TO_NUMBER(SUBSTR(ST.BEGIN_INTERVAL, 4, 2)) +
									TO_NUMBER(SUBSTR(ST.BEGIN_INTERVAL, 7, 2)/60))
							AND ( TO_NUMBER(SUBSTR(ST.END_INTERVAL, 1, 2))*60 +
									TO_NUMBER(SUBSTR(ST.END_INTERVAL, 4, 2)+
									TO_NUMBER(SUBSTR(ST.END_INTERVAL, 7, 2)/60)) );

	INSERT INTO TEMPLATE_DAY_TYPE_PERIOD (DAY_TYPE_ID, TIME_STAMP, MINIMUM_INTERVAL_NUMBER, PERIOD_ID)
	SELECT ENSURE_DAY_TYPE_RECORD(TDT.TEMPLATE_ID,
								TDT.SEASON_ID,
								TDT.DAY_NAME,
								CONSTANTS.DST_TYPE_SPRING_AHEAD),
		CASE WHEN PER.TIME_STAMP > v_DST_SA_HR
			THEN (ROUND(PER.TIME_STAMP*288)  - 12)/288
			ELSE PER.TIME_STAMP END,
		PER.MINIMUM_INTERVAL_NUMBER,
		PER.PERIOD_ID
	FROM TEMPLATE_DAY_TYPE_PERIOD PER,
		TEMPLATE_DAY_TYPE TDT
	WHERE TDT.TEMPLATE_ID = p_TEMPLATE_ID
		AND TDT.DST_TYPE = CONSTANTS.DST_TYPE_NONE
		AND PER.TIME_STAMP NOT BETWEEN (v_DST_SA_HR + 1/86400)
								AND (v_DST_SA_HR + 1/24)
		AND PER.DAY_TYPE_ID = TDT.DAY_TYPE_ID;

	INSERT INTO TEMPLATE_DAY_TYPE_PERIOD (DAY_TYPE_ID, TIME_STAMP, MINIMUM_INTERVAL_NUMBER, PERIOD_ID)
	SELECT ENSURE_DAY_TYPE_RECORD(TDT.TEMPLATE_ID,
								TDT.SEASON_ID,
								TDT.DAY_NAME,
								CONSTANTS.DST_TYPE_FALL_BACK),
		CASE WHEN TDT.DST_TYPE = CONSTANTS.DST_TYPE_DST_PERIOD
			THEN PER.TIME_STAMP
			ELSE (ROUND(PER.TIME_STAMP*288) + 12)/288 END,
		PER.MINIMUM_INTERVAL_NUMBER,
		PER.PERIOD_ID
	FROM TEMPLATE_DAY_TYPE_PERIOD PER,
		TEMPLATE_DAY_TYPE TDT
	WHERE TDT.TEMPLATE_ID = p_TEMPLATE_ID
		AND PER.DAY_TYPE_ID = TDT.DAY_TYPE_ID
		AND ((TDT.DST_TYPE = CONSTANTS.DST_TYPE_DST_PERIOD
				AND PER.TIME_STAMP <= v_DST_FB_HR) OR
			  (TDT.DST_TYPE = CONSTANTS.DST_TYPE_NONE
				AND PER.TIME_STAMP > v_DST_FB_HR))

	UNION ALL

	SELECT ENSURE_DAY_TYPE_RECORD(TDT.TEMPLATE_ID,
								TDT.SEASON_ID,
								TDT.DAY_NAME,
								CONSTANTS.DST_TYPE_FALL_BACK),
		(ROUND(PER.TIME_STAMP*288) + TIMES.FIVE_MIN)/288,
		POPULATE_SYSTEM_DATE_TIME.GET_MINIMUM_INTERVAL_NUMBER
					   (LOW_DATE+ PER.TIME_STAMP + TIMES.FIVE_MIN/288),
		PER.PERIOD_ID
	FROM TEMPLATE_DAY_TYPE_PERIOD PER,
		TEMPLATE_DAY_TYPE TDT,
		(SELECT LEVEL AS FIVE_MIN
		 FROM DUAL
		 CONNECT BY LEVEL <= 12) TIMES
	WHERE TDT.TEMPLATE_ID = p_TEMPLATE_ID
		AND TDT.DST_TYPE = CONSTANTS.DST_TYPE_DST_PERIOD
		AND PER.DAY_TYPE_ID = TDT.DAY_TYPE_ID
		AND PER.TIME_STAMP = v_DST_FB_HR;

END FILL_TEMPLATE_DAY_TYPE;
----------------------------------------------------------------------------------------------------
PROCEDURE COPY_TEMPLATE
(
	p_ENTITY_ID IN NUMBER,
	p_NEW_ENTITY_ID OUT NUMBER,
	p_NEW_ENTITY_NAME OUT VARCHAR2
) AS

	v_VALIDATION_MESSAGE TEMPLATE.VALIDATION_MESSAGE%TYPE;

BEGIN

	ENTITY_UTIL.COPY_ENTITY(p_ENTITY_ID,
							'TEMPLATE',
							p_NEW_ENTITY_ID,
							p_NEW_ENTITY_NAME);

	SELECT T.VALIDATION_MESSAGE
	INTO v_VALIDATION_MESSAGE
	FROM TEMPLATE T
	WHERE T.TEMPLATE_ID = p_ENTITY_ID;

	-- IF THE SEASON_TEMPLATE FOR THIS TEMPATE IS VALID, GO AHEAD
	-- AND CALL THROUGH TO FILL_TEMPLATE_DAY_TYPE FOR THE NEW COPY
	IF v_VALIDATION_MESSAGE IS NULL THEN
		EM.FILL_TEMPLATE_DAY_TYPE(p_NEW_ENTITY_ID);
	ELSE
		-- UPDATING SEASON_TEMPLATE OUTSIDE OF UI WILL CLEAR OUT
		-- THE EXISTING VALIDATION MESSAGE, RESET IT
		UPDATE TEMPLATE T
		SET VALIDATION_MESSAGE = v_VALIDATION_MESSAGE
		WHERE T.TEMPLATE_ID = p_NEW_ENTITY_ID;
	END IF;

END COPY_TEMPLATE;
----------------------------------------------------------------------------------------------------
PROCEDURE COPY_DAY_TYPE_TEMPLATE
(
	p_ENTITY_ID IN NUMBER,
	p_NEW_ENTITY_ID OUT NUMBER,
	p_NEW_ENTITY_NAME OUT VARCHAR2
) AS

BEGIN

	ENTITY_UTIL.COPY_ENTITY(p_ENTITY_ID,
							'TEMPLATE',
							p_NEW_ENTITY_ID,
							p_NEW_ENTITY_NAME);

	INSERT INTO TEMPLATE_SEASON_DAY_NAME
	SELECT p_NEW_ENTITY_ID,
		TSDN.SEASON_ID,
		TSDN.DAY_NAME,
		SYSDATE
	FROM TEMPLATE_SEASON_DAY_NAME TSDN
	WHERE TSDN.TEMPLATE_ID = p_ENTITY_ID;

END COPY_DAY_TYPE_TEMPLATE;
----------------------------------------------------------------------------------------------------
PROCEDURE COPY_SYSTEM_REALM
(
	p_ENTITY_ID IN NUMBER,
	p_NEW_ENTITY_ID OUT NUMBER,
	p_NEW_ENTITY_NAME OUT VARCHAR2
) AS

BEGIN

	ENTITY_UTIL.COPY_ENTITY(p_ENTITY_ID,
							'SYSTEM_REALM',
							p_NEW_ENTITY_ID,
							p_NEW_ENTITY_NAME);

	IF p_ENTITY_ID <> 1 THEN
		-- DON'T TRY TO POPULATE ENTITIES FOR THE ALL_DATA REALM
		SD.POPULATE_ENTITIES_FOR_REALM(p_NEW_ENTITY_ID);
	END IF;

END COPY_SYSTEM_REALM;
----------------------------------------------------------------------------------------------------
PROCEDURE COPY_SCENARIO
(
	p_ENTITY_ID IN NUMBER,
	p_NEW_ENTITY_ID OUT NUMBER,
	p_NEW_ENTITY_NAME OUT VARCHAR2
) AS

	v_SCENARIO_CATEGORY VARCHAR2(64);
	v_SCENARIO_NAME VARCHAR2(128);

BEGIN

	SELECT OID.NEXTVAL INTO p_NEW_ENTITY_ID
	FROM DUAL;

	SELECT SC.SCENARIO_CATEGORY, SC.SCENARIO_NAME
	INTO v_SCENARIO_CATEGORY, v_SCENARIO_NAME
	FROM SCENARIO SC
	WHERE SC.SCENARIO_ID = p_ENTITY_ID;

	p_NEW_ENTITY_NAME := ENTITY_UTIL.GET_COPY_OF_ENTITY_NAME(v_SCENARIO_NAME, EC.ED_SCENARIO);

	-- we can't use the normal COPY_ENTITY flow because the load forecast status subtab
	-- table has a foreign key to load forecast scenario
	ENTITY_UTIL.COPY_ENTITY_TABLE(p_ENTITY_ID,
								'SCENARIO',
								p_NEW_ENTITY_ID,
								p_NEW_ENTITY_NAME);

	IF UPPER(v_SCENARIO_CATEGORY) = UPPER(CONSTANTS.SCENARIO_LOAD_FORECAST) THEN
		INSERT INTO LOAD_FORECAST_SCENARIO (SCENARIO_ID, WEATHER_CASE_ID, AREA_LOAD_CASE_ID, ENROLLMENT_CASE_ID,
			CALENDAR_CASE_ID, USAGE_FACTOR_CASE_ID, LOSS_FACTOR_CASE_ID, GROWTH_FACTOR_CASE_ID,
			RUN_MODE, SCENARIO_USE_DAY_TYPE, ENTRY_DATE)
		SELECT p_NEW_ENTITY_ID, WEATHER_CASE_ID, AREA_LOAD_CASE_ID, ENROLLMENT_CASE_ID,
			CALENDAR_CASE_ID, USAGE_FACTOR_CASE_ID, LOSS_FACTOR_CASE_ID, GROWTH_FACTOR_CASE_ID,
			RUN_MODE, SCENARIO_USE_DAY_TYPE, SYSDATE
		FROM LOAD_FORECAST_SCENARIO
		WHERE SCENARIO_ID = p_ENTITY_ID;
	END IF;

	ENTITY_UTIL.COPY_ENTITY_SUBTABS(p_ENTITY_ID,
									'SCENARIO',
									p_NEW_ENTITY_ID);

	ENTITY_UTIL.COPY_COMMON_SUBTABS(EC.ED_SCENARIO,
									p_ENTITY_ID,
									p_NEW_ENTITY_ID);

END COPY_SCENARIO;
----------------------------------------------------------------------------------------------------
PROCEDURE COPY_SUB_STATION_METER_POINT
(
	p_ENTITY_ID IN NUMBER,
	p_NEW_ENTITY_ID OUT NUMBER,
	p_NEW_ENTITY_NAME OUT VARCHAR2
) AS

BEGIN

	ENTITY_UTIL.COPY_ENTITY(p_ENTITY_ID,
							'SUB_STATION_METER_POINT',
							p_NEW_ENTITY_ID,
							p_NEW_ENTITY_NAME);

	INSERT INTO DATA_VALIDATION_RULE (ENTITY_DOMAIN_ID, ENTITY_ID, BEGIN_DATE, END_DATE,
		MIN_VAL, MAX_VAL, HOUR_COMPARE, HOUR_VAL, DISALLOW_NEG, ENTRY_DATE)
	SELECT EC.ED_SUB_STATION_METER_POINT, p_NEW_ENTITY_ID, BEGIN_DATE, END_DATE,
		MIN_VAL, MAX_VAL, HOUR_COMPARE, HOUR_VAL, DISALLOW_NEG, SYSDATE
	FROM DATA_VALIDATION_RULE
	WHERE ENTITY_DOMAIN_ID = EC.ED_SUB_STATION_METER_POINT
		AND ENTITY_ID = p_ENTITY_ID;

END COPY_SUB_STATION_METER_POINT;
----------------------------------------------------------------------------------------------------
PROCEDURE COPY_TRANSACTION
(
	p_ENTITY_ID IN NUMBER,
	p_NEW_ENTITY_ID OUT NUMBER,
	p_NEW_ENTITY_NAME OUT VARCHAR2
) AS

	v_IS_BALANCE INTERCHANGE_TRANSACTION.TRANSACTION_ID%TYPE;
	v_TRANSACTION_TYPE INTERCHANGE_TRANSACTION.TRANSACTION_TYPE%TYPE;
	v_COMMODITY IT_COMMODITY.COMMODITY_NAME%TYPE;

	CURSOR cur_IT_ASSIGNS_TO IS
	SELECT *
	FROM IT_ASSIGNMENT ITA
	WHERE ITA.TO_TRANSACTION_ID = p_ENTITY_ID;

	CURSOR cur_IT_ASSIGNS_FROM IS
	SELECT *
	FROM IT_ASSIGNMENT ITA
	WHERE ITA.FROM_TRANSACTION_ID = p_ENTITY_ID;

	v_ASSIGNMENT_ID NUMBER(9);

BEGIN

	ENTITY_UTIL.COPY_ENTITY(p_ENTITY_ID,
							'TRANSACTION',
							p_NEW_ENTITY_ID,
							p_NEW_ENTITY_NAME);

	SELECT IT.TRANSACTION_TYPE, IT.IS_BALANCE_TRANSACTION
	INTO v_TRANSACTION_TYPE, v_IS_BALANCE
	FROM INTERCHANGE_TRANSACTION IT
	WHERE IT.TRANSACTION_ID = p_ENTITY_ID;

	SELECT ITC.COMMODITY_TYPE INTO v_COMMODITY
	FROM INTERCHANGE_TRANSACTION IT, IT_COMMODITY ITC
	WHERE IT.TRANSACTION_ID = p_ENTITY_ID
		AND ITC.COMMODITY_ID = IT.COMMODITY_ID;

	IF (v_TRANSACTION_TYPE = 'Purchase' or v_TRANSACTION_TYPE = 'Generation')
		AND v_COMMODITY = 'Energy' THEN

		FOR v_IT_ASSIGN_REC IN cur_IT_ASSIGNS_FROM LOOP

			SELECT OID.NEXTVAL INTO v_ASSIGNMENT_ID
			FROM DUAL;

			INSERT INTO IT_ASSIGNMENT (ASSIGNMENT_ID, TO_TRANSACTION_ID, FROM_TRANSACTION_ID,
				ASSIGNMENT_TYPE, ENTRY_DATE)
			VALUES (v_ASSIGNMENT_ID, v_IT_ASSIGN_REC.TO_TRANSACTION_ID, p_NEW_ENTITY_ID,
				v_IT_ASSIGN_REC.ASSIGNMENT_TYPE, SYSDATE);

			INSERT INTO IT_ASSIGNMENT_PERIOD (ASSIGNMENT_ID, BEGIN_DATE, END_DATE)
			SELECT v_ASSIGNMENT_ID, BEGIN_DATE, END_DATE
			FROM IT_ASSIGNMENT_PERIOD ITP
			WHERE ITP.ASSIGNMENT_ID = v_IT_ASSIGN_REC.ASSIGNMENT_ID;

		END LOOP;

	ELSIF (v_IS_BALANCE = 1 AND (v_TRANSACTION_TYPE = 'Load' OR v_TRANSACTION_TYPE = 'Sale') )
		and v_COMMODITY = 'Energy' then

		FOR v_IT_ASSIGN_REC IN cur_IT_ASSIGNS_TO LOOP

			SELECT OID.NEXTVAL INTO v_ASSIGNMENT_ID
			FROM DUAL;

			INSERT INTO IT_ASSIGNMENT (ASSIGNMENT_ID, TO_TRANSACTION_ID, FROM_TRANSACTION_ID,
				ASSIGNMENT_TYPE, ENTRY_DATE)
			VALUES (v_ASSIGNMENT_ID, p_NEW_ENTITY_ID, v_IT_ASSIGN_REC.FROM_TRANSACTION_ID,
				v_IT_ASSIGN_REC.ASSIGNMENT_TYPE, SYSDATE);

			INSERT INTO IT_ASSIGNMENT_PERIOD (ASSIGNMENT_ID, BEGIN_DATE, END_DATE)
			SELECT v_ASSIGNMENT_ID, BEGIN_DATE, END_DATE
			FROM IT_ASSIGNMENT_PERIOD ITP
			WHERE ITP.ASSIGNMENT_ID = v_IT_ASSIGN_REC.ASSIGNMENT_ID;

		END LOOP;

	END IF;

	INSERT INTO IT_SEGMENT( IT_SEGMENT_ID, TRANSACTION_ID, POR_ID,
		POD_ID, BEGIN_DATE,  END_DATE, SEGMENT_ORDER, CONTRACT_ID, ENTRY_DATE)
	SELECT OID.NEXTVAL, p_NEW_ENTITY_ID, POR_ID,
		POD_ID, BEGIN_DATE,  END_DATE, SEGMENT_ORDER, CONTRACT_ID, SYSDATE
	FROM IT_SEGMENT ITS
	WHERE ITS.TRANSACTION_ID = p_ENTITY_ID;

END COPY_TRANSACTION;
----------------------------------------------------------------------------------------------------
PROCEDURE COPY_TRANSACTION_TRAIT_GROUP
(
	p_ENTITY_ID IN NUMBER,
	p_NEW_ENTITY_ID OUT NUMBER,
	p_NEW_ENTITY_NAME OUT VARCHAR2
) AS

	CURSOR cur_TRAN_TRAIT IS
	SELECT TT.TRAIT_GROUP_ID, TT.TRAIT_INDEX, TT.SYSTEM_OBJECT_ID, TT.ENTRY_DATE,
		SO.PARENT_OBJECT_ID, SO.OBJECT_NAME, SO.OBJECT_INDEX, SO.OBJECT_CATEGORY, SO.OBJECT_TYPE,
		SO.OBJECT_DISPLAY_NAME, SO.OBJECT_IS_HIDDEN, SO.OBJECT_ORDER
	FROM TRANSACTION_TRAIT TT,
		SYSTEM_OBJECT SO
	WHERE TT.TRAIT_GROUP_ID = p_ENTITY_ID
		AND SO.OBJECT_ID = TT.SYSTEM_OBJECT_ID;

	v_SYSTEM_OBJECT_ID NUMBER(9);

BEGIN

	ENTITY_UTIL.COPY_ENTITY(p_ENTITY_ID,
							'TRANSACTION_TRAIT_GROUP',
							p_NEW_ENTITY_ID,
							p_NEW_ENTITY_NAME);

	FOR v_TRAN_TRAIT IN cur_TRAN_TRAIT LOOP

		SO.ID_FOR_SYSTEM_OBJECT(v_TRAN_TRAIT.PARENT_OBJECT_ID,
			p_NEW_ENTITY_NAME || '.' || v_TRAN_TRAIT.OBJECT_ORDER,
			v_TRAN_TRAIT.OBJECT_INDEX, v_TRAN_TRAIT.OBJECT_CATEGORY,
			v_TRAN_TRAIT.OBJECT_TYPE, TRUE, v_SYSTEM_OBJECT_ID);

		UPDATE SYSTEM_OBJECT
		SET OBJECT_DISPLAY_NAME = v_TRAN_TRAIT.OBJECT_DISPLAY_NAME,
			OBJECT_IS_HIDDEN = v_TRAN_TRAIT.OBJECT_IS_HIDDEN,
			OBJECT_ORDER = v_TRAN_TRAIT.OBJECT_ORDER
		WHERE OBJECT_ID = v_SYSTEM_OBJECT_ID;

		INSERT INTO TRANSACTION_TRAIT(TRAIT_GROUP_ID, TRAIT_INDEX, SYSTEM_OBJECT_ID, ENTRY_DATE)
		VALUES (p_NEW_ENTITY_ID, v_TRAN_TRAIT.TRAIT_INDEX, v_SYSTEM_OBJECT_ID, SYSDATE);

		-- COPY OVER THE SYSTEM ATTRIBUTES
		INSERT INTO SYSTEM_OBJECT_ATTRIBUTE (OBJECT_ID, ATTRIBUTE_ID, ATTRIBUTE_VAL)
		SELECT v_SYSTEM_OBJECT_ID, ATTRIBUTE_ID, ATTRIBUTE_VAL
		FROM SYSTEM_OBJECT_ATTRIBUTE
		WHERE OBJECT_ID = v_TRAN_TRAIT.SYSTEM_OBJECT_ID;

	END LOOP;

END COPY_TRANSACTION_TRAIT_GROUP;
----------------------------------------------------------------------------------------------------
PROCEDURE COPY_CALC_PROCESS
(
	p_ENTITY_ID IN NUMBER,
	p_NEW_ENTITY_ID OUT NUMBER,
	p_NEW_ENTITY_NAME OUT VARCHAR2
) AS

CURSOR cur_STEPS IS
SELECT *
FROM CALCULATION_PROCESS_STEP
WHERE CALC_PROCESS_ID = p_ENTITY_ID;

v_STEP_ID NUMBER(9);

BEGIN

	ENTITY_UTIL.COPY_ENTITY(p_ENTITY_ID,
							'CALC_PROCESS',
							p_NEW_ENTITY_ID,
							p_NEW_ENTITY_NAME);

	INSERT INTO CALCULATION_PROCESS_SECURITY (CALC_PROCESS_ID, SELECT_ACTION_ID,
		RUN_ACTION_ID, PURGE_ACTION_ID, LOCK_STATE_ACTION_ID)
	SELECT p_NEW_ENTITY_ID, SELECT_ACTION_ID, RUN_ACTION_ID, PURGE_ACTION_ID,
		LOCK_STATE_ACTION_ID
	FROM CALCULATION_PROCESS_SECURITY
	WHERE CALC_PROCESS_ID = p_ENTITY_ID;

	FOR v_STEP IN cur_STEPS LOOP

		SELECT OID.NEXTVAL INTO v_STEP_ID
		FROM DUAL;

		INSERT INTO CALCULATION_PROCESS_STEP (CALC_STEP_ID, CALC_PROCESS_ID,
			STEP_NUMBER, BEGIN_DATE, END_DATE, COMPONENT_ID, ENTRY_DATE)
		VALUES (v_STEP_ID, p_NEW_ENTITY_ID, v_STEP.STEP_NUMBER, v_STEP.BEGIN_DATE,
			v_STEP.END_DATE, v_STEP.COMPONENT_ID, SYSDATE);

		INSERT INTO CALCULATION_PROCESS_STEP_PARM (CALC_STEP_ID, PARAMETER_NAME,
			FORMULA, COMMENTS, ROW_NUMBER, ENTRY_DATE)
		SELECT v_STEP_ID, PARAMETER_NAME, FORMULA, COMMENTS, ROW_NUMBER, SYSDATE
		FROM CALCULATION_PROCESS_STEP_PARM
		WHERE CALC_STEP_ID = v_STEP.CALC_STEP_ID;

	END LOOP;

END COPY_CALC_PROCESS;
----------------------------------------------------------------------------------------------------
PROCEDURE COPY_LOSS_FACTOR
(
	p_ENTITY_ID IN NUMBER,
	p_NEW_ENTITY_ID OUT NUMBER,
	p_NEW_ENTITY_NAME OUT VARCHAR2
) AS

CURSOR cur_MODELS IS
SELECT MODEL.*
FROM LOSS_FACTOR_MODEL MODEL
WHERE MODEL.LOSS_FACTOR_ID = p_ENTITY_ID;

v_PATTERN_ID NUMBER(9);

BEGIN

	ENTITY_UTIL.COPY_ENTITY(p_ENTITY_ID,
							'LOSS_FACTOR',
							p_NEW_ENTITY_ID,
							p_NEW_ENTITY_NAME);

	FOR v_MODEL IN cur_MODELS LOOP
		SELECT OID.NEXTVAL INTO v_PATTERN_ID
		FROM DUAL;

		INSERT INTO LOSS_FACTOR_MODEL (LOSS_FACTOR_ID, LOSS_TYPE, BEGIN_DATE,
			END_DATE, FACTOR_TYPE, MODEL_TYPE, INTERVAL, PATTERN_ID, ENTRY_DATE)
		VALUES (p_NEW_ENTITY_ID, v_MODEL.LOSS_TYPE, v_MODEL.BEGIN_DATE,
			v_MODEL.END_DATE, v_MODEL.FACTOR_TYPE, v_MODEL.MODEL_TYPE,
			v_MODEL.INTERVAL, v_PATTERN_ID, SYSDATE);

		-- COPY THE LOSS FACTOR PATTERN
		INSERT INTO LOSS_FACTOR_PATTERN(PATTERN_ID, PATTERN_DATE, EXPANSION_VAL, LOSS_VAL)
		SELECT v_PATTERN_ID, PATTERN_DATE, EXPANSION_VAL, LOSS_VAL
		FROM LOSS_FACTOR_PATTERN
		WHERE PATTERN_ID = v_MODEL.PATTERN_ID;

	END LOOP;


END COPY_LOSS_FACTOR;
----------------------------------------------------------------------------------------------------
PROCEDURE PAYMENT_TYPE_LIST
	(
	p_PROGRAM_TYPE IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	IF p_PROGRAM_TYPE = DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_DLC THEN
		OPEN p_CURSOR FOR
			SELECT L.VALUE
			FROM SYSTEM_LABEL L
			WHERE L.MODEL_ID = 0
				AND L.MODULE = 'Product'
				AND L.KEY1 = 'Smart Grid Programs'
				AND L.KEY2 = 'Payment Period';
	ELSE
		OPEN p_CURSOR FOR
			SELECT NULL FROM DUAL;
	END IF;
END PAYMENT_TYPE_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE COMPONENT_LIST
	(
	p_COMPONENT_ENTITY IN VARCHAR2,
	p_RATE_STRUCTURE IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT C.COMPONENT_NAME, C.COMPONENT_ID
		FROM COMPONENT C
		WHERE C.COMPONENT_ENTITY = p_COMPONENT_ENTITY
			AND C.RATE_STRUCTURE = p_RATE_STRUCTURE;
END COMPONENT_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE DER_TYPE_LIST
	(
	p_PROGRAM_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT D.DER_TYPE_NAME, D.DER_TYPE_ID
		FROM PROGRAM_DER_TYPE P,
			DER_TYPE D
		WHERE P.PROGRAM_ID = p_PROGRAM_ID
			AND D.DER_TYPE_ID = P.DER_TYPE_ID
		ORDER BY D.DER_TYPE_NAME;
END DER_TYPE_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_PROGRAM
	(
	p_PROGRAM_ID IN NUMBER,
	p_PROGRAM_NAME OUT VARCHAR2,
	p_PROGRAM_ALIAS OUT VARCHAR2,
	p_PROGRAM_DESC OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_PROGRAM_TYPE OUT VARCHAR2,
	p_PROGRAM_INTERVAL OUT VARCHAR2,
	p_CUSTOMER_TYPE OUT VARCHAR2,
	p_MAX_DURATION_HOUR OUT NUMBER,
	p_MAX_DURATION_MINUTE OUT NUMBER,
	p_MIN_OFF_TIME_HOUR OUT NUMBER,
	p_MIN_OFF_TIME_MINUTE OUT NUMBER,
	p_DEGREE_INCREASE OUT NUMBER,
	p_DEGREE_DECREASE OUT NUMBER,
	p_ALLOW_CUSTOMER_OVERRIDE OUT NUMBER,
	p_DEFAULT_OPT_OUT_PCT OUT NUMBER,
	p_DEFAULT_OVERRIDE_PCT OUT NUMBER,
	p_RUNNING_OPT_OUT OUT VARCHAR2,
	p_RUNNING_OVERRIDE OUT VARCHAR2,
	p_USE_DEFAULT_OPT_OUT_OVERRIDE OUT NUMBER,
	p_VALIDATION_METHOD OUT VARCHAR2,
	p_COMPONENT_ID OUT NUMBER,
	p_COMPONENT_DISP OUT VARCHAR2,
	p_TRANSACTION_ID OUT NUMBER,
	p_TRANSACTION_DISP OUT VARCHAR2,
	p_SIGNAL_TYPE OUT VARCHAR2
	) AS

	v_TOTAL_OPT_OUTS NUMBER(9);
	v_TOTAL_OVERRIDES NUMBER(9);
	v_TOTAL_SIGNALED NUMBER(9);
	v_COUNT_HISTORY NUMBER(9);
	v_RUNNING_OPT_OUT_RATE NUMBER(5,2);
	v_RUNNING_OVERRIDE_RATE NUMBER(5,2);

BEGIN

	EM_GET.PROGRAM(p_PROGRAM_ID,
		p_PROGRAM_NAME,
		p_PROGRAM_ALIAS,
		p_PROGRAM_DESC,
		p_EXTERNAL_IDENTIFIER,
		p_PROGRAM_TYPE,
		p_PROGRAM_INTERVAL,
		p_CUSTOMER_TYPE,
		p_MAX_DURATION_HOUR,
		p_MAX_DURATION_MINUTE,
		p_MIN_OFF_TIME_HOUR,
		p_MIN_OFF_TIME_MINUTE,
		p_DEGREE_INCREASE,
		p_DEGREE_DECREASE,
		p_ALLOW_CUSTOMER_OVERRIDE,
		p_DEFAULT_OPT_OUT_PCT,
		p_DEFAULT_OVERRIDE_PCT,
		p_USE_DEFAULT_OPT_OUT_OVERRIDE,
		p_VALIDATION_METHOD,
		p_TRANSACTION_ID,
		p_TRANSACTION_DISP,
		p_COMPONENT_ID,
		p_COMPONENT_DISP,
  		p_SIGNAL_TYPE);

	IF p_PROGRAM_ID > 0 THEN
		SELECT SUM(HIST.TOTAL_OPT_OUTS), SUM(HIST.TOTAL_OVERRIDES), SUM(HIST.TOTAL_SIGNALED), COUNT(1)
		INTO v_TOTAL_OPT_OUTS, v_TOTAL_OVERRIDES, v_TOTAL_SIGNALED, v_COUNT_HISTORY
		FROM PROGRAM_EVENT_HISTORY HIST
		WHERE HIST.PROGRAM_ID = p_PROGRAM_ID;

		IF v_COUNT_HISTORY > 0 AND v_TOTAL_SIGNALED > 0 THEN
			v_RUNNING_OPT_OUT_RATE := (v_TOTAL_OPT_OUTS/v_TOTAL_SIGNALED)*100;
			v_RUNNING_OVERRIDE_RATE := (v_TOTAL_OVERRIDES/v_TOTAL_SIGNALED)*100;
			p_RUNNING_OPT_OUT := v_RUNNING_OPT_OUT_RATE || '% (' || v_COUNT_HISTORY || ' Events)';
			p_RUNNING_OVERRIDE := v_RUNNING_OVERRIDE_RATE || '% (' || v_COUNT_HISTORY || ' Events)';
		ELSE
			p_RUNNING_OPT_OUT := 'N/A (0 Events)';
			p_RUNNING_OVERRIDE := 'N/A (0 Events)';
		END IF;
	END IF;

END GET_PROGRAM;
--------------------------------------------------------------------------------
PROCEDURE PROGRAM_EXECUTION_TYPES
    (
    p_PROGRAM_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_PROGRAM_ID, EC.ED_PROGRAM);

    OPEN p_CURSOR FOR
		SELECT p_PROGRAM_ID AS PROGRAM_ID,
			L.VALUE AS EXECUTION_TYPE,
			CASE WHEN E.PROGRAM_ID IS NULL THEN 0 ELSE 1 END as IS_SELECTED,
			E.ENTRY_DATE
		FROM SYSTEM_LABEL L,
			PROGRAM_EXECUTION_TYPE E
		WHERE MODEL_ID = 0
			AND MODULE = 'Product'
			AND KEY1 = 'Smart Grid Programs'
			AND KEY2 = 'Execution Types'
			AND E.EXECUTION_TYPE(+) = L.VALUE
			AND E.PROGRAM_ID(+) = p_PROGRAM_ID
		ORDER BY POSITION;

END PROGRAM_EXECUTION_TYPES;
--------------------------------------------------------------------------------
PROCEDURE PUT_PROGRAM_EXECUTION_TYPE
    (
    p_PROGRAM_ID IN NUMBER,
    p_EXECUTION_TYPE IN VARCHAR2,
	p_IS_SELECTED IN NUMBER
    ) AS
	v_COUNT NUMBER;
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_PROGRAM_ID, EC.ED_PROGRAM);

	IF NVL(p_IS_SELECTED,0) = 0 THEN
		-- not selected? remove relationship
		DX.REMOVE_PROGRAM_EXECUTION_TYPE(p_PROGRAM_ID, p_EXECUTION_TYPE);
	ELSE
		-- selected? add a record
		SELECT COUNT(1)
		INTO v_COUNT
		FROM PROGRAM_EXECUTION_TYPE
		WHERE PROGRAM_ID = p_PROGRAM_ID
			AND EXECUTION_TYPE = p_EXECUTION_TYPE;

		IF v_COUNT = 0 THEN -- no such assignment? add it
	       INSERT INTO PROGRAM_EXECUTION_TYPE (
				PROGRAM_ID,
				EXECUTION_TYPE,
				ENTRY_DATE)
        	VALUES (
				p_PROGRAM_ID,
				p_EXECUTION_TYPE,
				SYSDATE);
		END IF;
    END IF;

END PUT_PROGRAM_EXECUTION_TYPE;
--------------------------------------------------------------------------------
PROCEDURE PROGRAM_NOTIFICATIONS
    (
    p_PROGRAM_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_PROGRAM_ID, EC.ED_PROGRAM);

    OPEN p_CURSOR FOR
        SELECT PROGRAM_ID,
            HOUR AS NOTIF_HOUR,
            MINUTE AS NOTIF_MINUTE,
            METHOD,
            MESSAGE_TEXT,
            ENTRY_DATE
        FROM PROGRAM_NOTIFICATION
        WHERE PROGRAM_ID = p_PROGRAM_ID
        ORDER BY HOUR,
            MINUTE,
            METHOD;

END PROGRAM_NOTIFICATIONS;
--------------------------------------------------------------------------------
PROCEDURE PUT_PROGRAM_NOTIFICATION
    (
    p_PROGRAM_ID IN NUMBER,
    p_NOTIF_HOUR IN NUMBER,
    p_NOTIF_MINUTE IN NUMBER,
    p_METHOD IN VARCHAR2,
    p_MESSAGE_TEXT IN VARCHAR2,
    p_OLD_NOTIF_HOUR IN NUMBER,
    p_OLD_NOTIF_MINUTE IN NUMBER,
    p_OLD_METHOD IN VARCHAR2
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_PROGRAM_ID, EC.ED_PROGRAM);

    UPDATE PROGRAM_NOTIFICATION SET
        HOUR = p_NOTIF_HOUR,
        MINUTE = p_NOTIF_MINUTE,
        METHOD = p_METHOD,
        MESSAGE_TEXT = p_MESSAGE_TEXT,
        ENTRY_DATE = SYSDATE
    WHERE PROGRAM_ID = p_PROGRAM_ID
        AND HOUR = p_OLD_NOTIF_HOUR
        AND MINUTE = p_OLD_NOTIF_MINUTE
        AND METHOD = p_OLD_METHOD;

    IF SQL%NOTFOUND THEN
        INSERT INTO PROGRAM_NOTIFICATION (
            PROGRAM_ID,
            HOUR,
            MINUTE,
            METHOD,
            MESSAGE_TEXT,
            ENTRY_DATE)
        VALUES (
            p_PROGRAM_ID,
            p_NOTIF_HOUR,
            p_NOTIF_MINUTE,
            p_METHOD,
            p_MESSAGE_TEXT,
            SYSDATE);
    END IF;

END PUT_PROGRAM_NOTIFICATION;
--------------------------------------------------------------------------------
PROCEDURE PROGRAM_LIMITS
    (
    p_PROGRAM_ID IN NUMBER,
	p_LIMIT_TYPE IN VARCHAR2,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_PROGRAM_ID, EC.ED_PROGRAM);

    OPEN p_CURSOR FOR
        SELECT PROGRAM_ID,
            LIMIT_PERIOD,
            TEMPLATE_ID,
            PERIOD_ID,
            MAX_LIMIT,
            ENTRY_DATE
        FROM PROGRAM_LIMIT
        WHERE PROGRAM_ID = p_PROGRAM_ID
			AND LIMIT_TYPE = p_LIMIT_TYPE
        ORDER BY 3,4,5,6;

END PROGRAM_LIMITS;
--------------------------------------------------------------------------------
PROCEDURE PUT_PROGRAM_LIMIT
    (
    p_PROGRAM_ID IN NUMBER,
    p_LIMIT_TYPE IN VARCHAR2,
    p_LIMIT_PERIOD IN VARCHAR2,
    p_TEMPLATE_ID IN NUMBER,
    p_PERIOD_ID IN NUMBER,
    p_MAX_LIMIT IN NUMBER,
    p_OLD_LIMIT_PERIOD IN VARCHAR2,
	p_OLD_TEMPLATE_ID IN NUMBER,
	p_OLD_PERIOD_ID IN NUMBER
    ) AS
	v_PROGRAM_LIMIT_ID  PROGRAM_LIMIT.PROGRAM_LIMIT_ID%TYPE;
	v_COUNT             BINARY_INTEGER;
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_PROGRAM_ID, EC.ED_PROGRAM);

	-- Find out if user is attempting to make changes after a program has been executed.
	SELECT MAX(PROGRAM_LIMIT_ID)
	INTO v_PROGRAM_LIMIT_ID
	FROM PROGRAM_LIMIT
    WHERE PROGRAM_ID = p_PROGRAM_ID
        AND LIMIT_TYPE = p_LIMIT_TYPE
        AND LIMIT_PERIOD = p_OLD_LIMIT_PERIOD
		AND TEMPLATE_ID = p_OLD_TEMPLATE_ID
		AND PERIOD_ID = p_OLD_PERIOD_ID;

	-- If we found a record, then we are updating.
	IF v_PROGRAM_LIMIT_ID IS NOT NULL THEN

		-- User cannot change Template, Period, or Limit Period after an event has occurred.
		IF p_OLD_TEMPLATE_ID <> p_TEMPLATE_ID OR p_OLD_PERIOD_ID <> p_PERIOD_ID OR p_OLD_LIMIT_PERIOD <> p_LIMIT_PERIOD THEN

			SELECT COUNT(1)
			INTO v_COUNT
			FROM PROGRAM_LIMIT_HITS_USED
			WHERE PROGRAM_LIMIT_ID = v_PROGRAM_LIMIT_ID
				AND ROWNUM = 1;

			IF v_COUNT > 0 THEN
				ERRS.RAISE(MSGCODES.c_ERR_CANNOT_MODIFY_PROG_LIMIT);
			END IF;

		END IF;

		UPDATE PROGRAM_LIMIT SET
			LIMIT_PERIOD = p_LIMIT_PERIOD,
			TEMPLATE_ID = p_TEMPLATE_ID,
			PERIOD_ID = p_PERIOD_ID,
			MAX_LIMIT = p_MAX_LIMIT,
			ENTRY_DATE = SYSDATE
		WHERE PROGRAM_LIMIT_ID = v_PROGRAM_LIMIT_ID;

	ELSE

		SELECT OID.NEXTVAL INTO v_PROGRAM_LIMIT_ID FROM DUAL;
		INSERT INTO PROGRAM_LIMIT (
			PROGRAM_ID,
			LIMIT_TYPE,
			LIMIT_PERIOD,
			TEMPLATE_ID,
			PERIOD_ID,
			MAX_LIMIT,
			PROGRAM_LIMIT_ID,
			ENTRY_DATE)
		VALUES (
			p_PROGRAM_ID,
			p_LIMIT_TYPE,
			p_LIMIT_PERIOD,
			p_TEMPLATE_ID,
			p_PERIOD_ID,
			p_MAX_LIMIT,
			v_PROGRAM_LIMIT_ID,
			SYSDATE);

	END IF;

END PUT_PROGRAM_LIMIT;
--------------------------------------------------------------------------------
PROCEDURE PROGRAM_LIMIT_TEMPLATE_LIST
	(
	p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT TEMPLATE_ID, TEMPLATE_NAME
		FROM TEMPLATE
		WHERE IS_DAY_TYPE = 0;
END PROGRAM_LIMIT_TEMPLATE_LIST;
--------------------------------------------------------------------------------
PROCEDURE PROGRAM_REQ_EQUIPMENTS
    (
    p_PROGRAM_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_PROGRAM_ID, EC.ED_PROGRAM);

    OPEN p_CURSOR FOR
		SELECT p_PROGRAM_ID AS PROGRAM_ID,
			L.VALUE AS EQUIPMENT_TYPE,
			CASE WHEN E.PROGRAM_ID IS NULL THEN 0 ELSE 1 END as IS_REQUIRED,
			E.ENTRY_DATE
		FROM SYSTEM_LABEL L,
			PROGRAM_REQUIRED_EQUIPMENT E
		WHERE MODEL_ID = 0
			AND MODULE = 'Product'
			AND KEY1 = 'Smart Grid Programs'
			AND KEY2 = 'Required Equipment'
			AND E.EQUIPMENT_TYPE(+) = L.VALUE
			AND E.PROGRAM_ID(+) = p_PROGRAM_ID
		ORDER BY POSITION;

END PROGRAM_REQ_EQUIPMENTS;
--------------------------------------------------------------------------------
PROCEDURE PUT_PROGRAM_REQ_EQUIPMENT
    (
    p_PROGRAM_ID IN NUMBER,
    p_EQUIPMENT_TYPE IN VARCHAR2,
	p_IS_REQUIRED IN NUMBER
    ) AS
	v_COUNT NUMBER;
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_PROGRAM_ID, EC.ED_PROGRAM);

	IF NVL(p_IS_REQUIRED,0) = 0 THEN
		-- not selected? remove relationship
		DX.REMOVE_PROGRAM_REQ_EQUIPMENT(p_PROGRAM_ID, p_EQUIPMENT_TYPE);
	ELSE
		-- selected? add a record
		SELECT COUNT(1)
		INTO v_COUNT
		FROM PROGRAM_REQUIRED_EQUIPMENT
		WHERE PROGRAM_ID = p_PROGRAM_ID
			AND EQUIPMENT_TYPE = p_EQUIPMENT_TYPE;

		IF v_COUNT = 0 THEN -- no such assignment? add it
		   INSERT INTO PROGRAM_REQUIRED_EQUIPMENT (
				PROGRAM_ID,
				EQUIPMENT_TYPE,
				ENTRY_DATE)
			VALUES (
				p_PROGRAM_ID,
				p_EQUIPMENT_TYPE,
				SYSDATE);
		END IF;
    END IF;

END PUT_PROGRAM_REQ_EQUIPMENT;
--------------------------------------------------------------------------------
PROCEDURE PROGRAM_DER_TYPES
    (
    p_PROGRAM_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_PROGRAM_ID, EC.ED_PROGRAM);

    OPEN p_CURSOR FOR
		SELECT p_PROGRAM_ID AS PROGRAM_ID,
			DT.DER_TYPE_ID,
			DT.DER_TYPE_NAME,
			CASE WHEN PD.PROGRAM_ID IS NULL THEN 0 ELSE 1 END as IS_PARTICIPATING,
			PD.ENTRY_DATE
		FROM DER_TYPE DT,
			PROGRAM_DER_TYPE PD
		WHERE PD.DER_TYPE_ID(+) = DT.DER_TYPE_ID
			AND PD.PROGRAM_ID(+) = p_PROGRAM_ID
			AND DT.DER_TYPE_ID > 0
		ORDER BY DER_TYPE_NAME;

END PROGRAM_DER_TYPES;
--------------------------------------------------------------------------------
PROCEDURE PUT_PROGRAM_DER_TYPE
    (
    p_PROGRAM_ID IN NUMBER,
    p_DER_TYPE_ID IN NUMBER,
    p_IS_PARTICIPATING IN NUMBER
    ) AS
	v_COUNT NUMBER;
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_PROGRAM_ID, EC.ED_PROGRAM);

	IF NVL(p_IS_PARTICIPATING,0) = 0 THEN
		-- not selected? remove relationship
		DX.REMOVE_PROGRAM_DER_TYPE(p_PROGRAM_ID, p_DER_TYPE_ID);
	ELSE
		-- selected? add a record
		SELECT COUNT(1)
		INTO v_COUNT
		FROM PROGRAM_DER_TYPE
		WHERE PROGRAM_ID = p_PROGRAM_ID
			AND DER_TYPE_ID = p_DER_TYPE_ID;

		IF v_COUNT = 0 THEN -- no such assignment? add it
			INSERT INTO PROGRAM_DER_TYPE (
				PROGRAM_ID,
				DER_TYPE_ID,
				ENTRY_DATE)
			VALUES (
				p_PROGRAM_ID,
				p_DER_TYPE_ID,
				SYSDATE);
		END IF;
    END IF;

END PUT_PROGRAM_DER_TYPE;
--------------------------------------------------------------------------------
PROCEDURE PROGRAM_DER_PAYMENTS
    (
    p_PROGRAM_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_PROGRAM_ID, EC.ED_PROGRAM);

	OPEN p_CURSOR FOR
        SELECT PROGRAM_ID,
            PAYMENT_TYPE,
            DER_TYPE_ID,
            AMOUNT,
            ENTRY_DATE
        FROM PROGRAM_DER_PAYMENT
        WHERE PROGRAM_ID = p_PROGRAM_ID
        ORDER BY PAYMENT_TYPE;

END PROGRAM_DER_PAYMENTS;
--------------------------------------------------------------------------------
PROCEDURE PUT_PROGRAM_DER_PAYMENT
    (
    p_PROGRAM_ID IN NUMBER,
    p_PAYMENT_TYPE IN VARCHAR2,
    p_DER_TYPE_ID IN NUMBER,
    p_AMOUNT IN NUMBER,
    p_OLD_PAYMENT_TYPE IN VARCHAR2,
	p_OLD_DER_TYPE_ID IN NUMBER
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_PROGRAM_ID, EC.ED_PROGRAM);

    UPDATE PROGRAM_DER_PAYMENT SET
        PAYMENT_TYPE = p_PAYMENT_TYPE,
        DER_TYPE_ID = p_DER_TYPE_ID,
        AMOUNT = p_AMOUNT,
        ENTRY_DATE = SYSDATE
    WHERE PROGRAM_ID = p_PROGRAM_ID
        AND PAYMENT_TYPE = p_OLD_PAYMENT_TYPE
		AND DER_TYPE_ID = p_OLD_DER_TYPE_ID;

    IF SQL%NOTFOUND THEN
        INSERT INTO PROGRAM_DER_PAYMENT (
            PROGRAM_ID,
            PAYMENT_TYPE,
            DER_TYPE_ID,
            AMOUNT,
            ENTRY_DATE)
        VALUES (
            p_PROGRAM_ID,
            p_PAYMENT_TYPE,
            p_DER_TYPE_ID,
            p_AMOUNT,
            SYSDATE);
    END IF;

END PUT_PROGRAM_DER_PAYMENT;
--------------------------------------------------------------------------------
PROCEDURE PROGRAM_PAYMENTS
    (
    p_PROGRAM_ID IN NUMBER,
	p_ALLOWED_TYPES IN STRING_COLLECTION,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_PROGRAM_ID, EC.ED_PROGRAM);

    OPEN p_CURSOR FOR
        SELECT PROGRAM_ID,
			PAYMENT_TYPE,
            BEGIN_DATE,
            END_DATE,
            AMOUNT,
            ENTRY_DATE
        FROM PROGRAM_PAYMENT,
			TABLE(CAST(p_ALLOWED_TYPES AS STRING_COLLECTION)) X
        WHERE PROGRAM_ID = p_PROGRAM_ID
			AND PAYMENT_TYPE = X.COLUMN_VALUE
        ORDER BY BEGIN_DATE;

END PROGRAM_PAYMENTS;
--------------------------------------------------------------------------------
PROCEDURE PUT_PROGRAM_PAYMENT
    (
    p_PROGRAM_ID IN NUMBER,
	p_PAYMENT_TYPE IN VARCHAR2,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_AMOUNT IN NUMBER,
    p_OLD_BEGIN_DATE IN DATE,
	p_OLD_PAYMENT_TYPE IN VARCHAR2
    ) AS
v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_PROGRAM_ID, EC.ED_PROGRAM);

    v_KEY_NEW('PROGRAM_ID') := UT.GET_LITERAL_FOR_NUMBER(p_PROGRAM_ID);
    v_KEY_OLD('PROGRAM_ID') := UT.GET_LITERAL_FOR_NUMBER(p_PROGRAM_ID);
	v_KEY_NEW('PAYMENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_PAYMENT_TYPE);
	v_KEY_OLD('PAYMENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_OLD_PAYMENT_TYPE);
    v_DATA('AMOUNT') := UT.GET_LITERAL_FOR_NUMBER(p_AMOUNT);

    UT.PUT_TEMPORAL_DATA_UI('PROGRAM_PAYMENT',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

END PUT_PROGRAM_PAYMENT;
--------------------------------------------------------------------------------
PROCEDURE ENV_SIGNAL_SCHEDULES
(
	p_PROGRAM_ID IN NUMBER,
	p_PROGRAM_TYPE IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
) AS
	v_BEGIN_DATE DATE;
	v_END_DATE DATE;
	v_TXN_ID INTERCHANGE_TRANSACTION.TRANSACTION_ID%TYPE;
	v_INTERVAL INTERCHANGE_TRANSACTION.TRANSACTION_INTERVAL%TYPE;
	v_INTERVAL_NUM SYSTEM_DATE_TIME.MINIMUM_INTERVAL_NUMBER%TYPE;
	v_DATA_INTERVAL_TYPE SYSTEM_DATE_TIME.DATA_INTERVAL_TYPE%TYPE;
BEGIN

	ASSERT(p_PROGRAM_ID IS NOT NULL AND p_PROGRAM_TYPE = DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_ENVIR_EMISSION,
			'Incorrect Environment/Emission Program.',
			MSGCODES.c_ERR_ARGUMENT);

	IF p_PROGRAM_ID IS NOT NULL AND p_PROGRAM_TYPE = DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_ENVIR_EMISSION THEN
		BEGIN
			SELECT T.TRANSACTION_INTERVAL, T.TRANSACTION_ID INTO v_INTERVAL, v_TXN_ID
			FROM PROGRAM P,
				INTERCHANGE_TRANSACTION T
			WHERE P.PROGRAM_ID = p_PROGRAM_ID
				AND T.TRANSACTION_ID = P.TRANSACTION_ID;

			DATE_UTIL.CUT_DATE_RANGE_SCHEDULING(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, GET_INTERVAL_ABBREVIATION(v_INTERVAL), v_INTERVAL, v_BEGIN_DATE, v_END_DATE);

			SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, p_BEGIN_DATE, p_END_DATE);

			v_INTERVAL_NUM := GET_INTERVAL_NUMBER(v_INTERVAL);
			v_DATA_INTERVAL_TYPE := CASE WHEN DATE_UTIL.IS_SUB_DAILY(v_INTERVAL) THEN 1 ELSE 2 END;

			OPEN p_CURSOR FOR
				SELECT SDT.NO_ROLLUP_YYYY_MM_DD AS SCHEDULE_DATE,
					SDT.CUT_DATE,
					S.AMOUNT,
					S.PRICE,
					DEMAND_RESPONSE_UI.GET_ENV_SIGNAL_NAME(p_PROGRAM_ID, S.AMOUNT) AS SIGNAL
				FROM IT_SCHEDULE S, SYSTEM_DATE_TIME SDT
				WHERE SDT.TIME_ZONE = p_TIME_ZONE
					  AND SDT.DATA_INTERVAL_TYPE = v_DATA_INTERVAL_TYPE
					  AND SDT.DAY_TYPE = '1'
					  AND S.SCHEDULE_DATE(+) = SDT.CUT_DATE
					  AND S.TRANSACTION_ID(+) = v_TXN_ID
					  AND SDT.CUT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
					  AND SDT.MINIMUM_INTERVAL_NUMBER >= v_INTERVAL_NUM
				ORDER BY SCHEDULE_DATE;

		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				OPEN p_CURSOR FOR
					SELECT NULL FROM DUAL;
		END;
	ELSE
		OPEN p_CURSOR FOR
			SELECT NULL FROM DUAL;
	END IF;
END ENV_SIGNAL_SCHEDULES;
--------------------------------------------------------------------------------
PROCEDURE PROGRAM_EVENT_HISTORY
(
	p_PROGRAM_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT p_PROGRAM_ID AS PROGRAM_ID,
			FROM_CUT(E.START_TIME, p_TIME_ZONE) AS START_TIME,
			FROM_CUT(E.STOP_TIME, p_TIME_ZONE) AS STOP_TIME,
			E.EVENT_ID,
			E.EVENT_NAME,
			S.SERVICE_ZONE_NAME,
			E.EVENT_DESC AS COMMENTS,
			E.ENTRY_DATE
		FROM DR_EVENT E,
			VPP V,
			SERVICE_ZONE S
		WHERE V.VPP_ID = E.VPP_ID
			AND V.PROGRAM_ID = p_PROGRAM_ID
			AND S.SERVICE_ZONE_ID = V.SERVICE_ZONE_ID
		ORDER BY 1,2,3,4;
END PROGRAM_EVENT_HISTORY;
--------------------------------------------------------------------------------
PROCEDURE CRITICAL_PEAK_EVENT_SCHEDULES
(
	p_PROGRAM_ID IN NUMBER,
	p_PROGRAM_TYPE IN VARCHAR2,
	p_EVENT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
) AS
	v_CUT_BEGIN_DATE DATE;
	v_CUT_END_DATE DATE;
	v_INTERVAL PROGRAM.PROGRAM_INTERVAL%TYPE;
	v_INTERVAL_NUMBER SYSTEM_DATE_TIME.MINIMUM_INTERVAL_NUMBER%TYPE;
	v_DATA_INTERVAL_TYPE SYSTEM_DATE_TIME.DATA_INTERVAL_TYPE%TYPE;
	v_COMPONENT_ID COMPONENT.COMPONENT_ID%TYPE;
	v_TEMPLATE_ID TEMPLATE.TEMPLATE_ID%TYPE;
	v_EVENT_START DR_EVENT.START_TIME%TYPE;
	v_EVENT_STOP DR_EVENT.STOP_TIME%TYPE;
	v_HOLIDAY_SET_ID HOLIDAY_SET.HOLIDAY_SET_ID%TYPE;

BEGIN

	ASSERT(p_PROGRAM_ID IS NOT NULL AND p_PROGRAM_TYPE = DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_CRIT_PRICING,
			'Incorrect Critical Peak Pricing Program.',
			MSGCODES.c_ERR_ARGUMENT);

	IF p_PROGRAM_ID IS NOT NULL AND p_PROGRAM_TYPE = DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_CRIT_PRICING THEN
		SELECT P.COMPONENT_ID, P.PROGRAM_INTERVAL, C.TEMPLATE_ID
		INTO v_COMPONENT_ID, v_INTERVAL, v_TEMPLATE_ID
		FROM PROGRAM P, COMPONENT C
		WHERE P.PROGRAM_ID = p_PROGRAM_ID
			AND C.COMPONENT_ID = P.COMPONENT_ID;

		SELECT NVL(E.START_TIME, CONSTANTS.LOW_DATE), NVL(E.STOP_TIME, CONSTANTS.HIGH_DATE)
		INTO v_EVENT_START, v_EVENT_STOP
		FROM DR_EVENT E
		WHERE EVENT_ID = p_EVENT_ID;

		-- Get the Holiday set either from EDC or ESP
		SELECT NVL(MAX(EDC.EDC_HOLIDAY_SET_ID), CONSTANTS.NOT_ASSIGNED) INTO v_HOLIDAY_SET_ID
		FROM INCUMBENT_ENTITY IE, ENERGY_DISTRIBUTION_COMPANY EDC
		WHERE IE.INCUMBENT_TYPE = 'EDC'
			AND EDC.EDC_ID = IE.INCUMBENT_ID;

		DATE_UTIL.CUT_DATE_RANGE_SCHEDULING(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, GET_INTERVAL_ABBREVIATION(v_INTERVAL), v_INTERVAL, v_CUT_BEGIN_DATE, v_CUT_END_DATE);

		SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, v_CUT_BEGIN_DATE, v_CUT_END_DATE);

		SP.CHECK_TEMPLATE_DATES(v_TEMPLATE_ID,
								v_HOLIDAY_SET_ID,
								p_TIME_ZONE,
								p_BEGIN_DATE,
								p_END_DATE);

		v_INTERVAL_NUMBER := GET_INTERVAL_NUMBER(v_INTERVAL);
		v_DATA_INTERVAL_TYPE := CASE WHEN DATE_UTIL.IS_SUB_DAILY(v_INTERVAL) THEN 1 ELSE 2 END;

		OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(PER.CUT_DATE, p_TIME_ZONE,
					NULL, GA.ELECTRIC_MODEL, GA.STANDARD, v_DATA_INTERVAL_TYPE) AS DATE_TIME,
			CASE WHEN PER.CUT_DATE BETWEEN v_EVENT_START AND v_EVENT_STOP
				THEN 1 ELSE 0 END AS IS_CRIT_PEAK,
			P.PERIOD_COLOR,
			CASE WHEN PER.CUT_DATE BETWEEN v_EVENT_START AND v_EVENT_STOP
				THEN TOU.RATE + NVL(ES.PRICE,0) + NVL(PAY.AMOUNT, 0)
				ELSE TOU.RATE END AS RATE
		FROM PERIOD P,
				COMPONENT_TOU_RATE TOU,
				DR_EVENT_SCHEDULE ES,
				PROGRAM_PAYMENT PAY,
				(SELECT C.COMPONENT_ID, (TD.CUT_BEGIN_DATE + DT.TIME_STAMP) AS CUT_DATE,
					TD.LOCAL_DATE, DT.PERIOD_ID
				 FROM TEMPLATE_DATES TD,
				 	TEMPLATE_DAY_TYPE_PERIOD DT,
					COMPONENT C
				 WHERE TD.TIME_ZONE = p_TIME_ZONE
					AND TD.HOLIDAY_SET_ID = v_HOLIDAY_SET_ID
					AND v_CUT_BEGIN_DATE <= TD.CUT_END_DATE
					AND v_CUT_END_DATE > TD.CUT_BEGIN_DATE
					AND DT.DAY_TYPE_ID = TD.DAY_TYPE_ID
					AND DT.MINIMUM_INTERVAL_NUMBER >= v_INTERVAL_NUMBER
					AND TD.TEMPLATE_ID = C.TEMPLATE_ID
					-- Determine the current period
					AND C.COMPONENT_ID = v_COMPONENT_ID) PER
		WHERE -- programs associated TOU component
			P.PERIOD_ID = PER.PERIOD_ID
			-- Get the rate for this period
			AND TOU.COMPONENT_ID = PER.COMPONENT_ID
			AND TOU.SUB_COMPONENT_TYPE = CONSTANTS.UNDEFINED_ATTRIBUTE -- '?'
			AND TOU.SUB_COMPONENT_ID = CONSTANTS.NOT_ASSIGNED -- 0
			AND PER.LOCAL_DATE BETWEEN TOU.BEGIN_DATE
						AND NVL(TOU.END_DATE, CONSTANTS.HIGH_DATE)
			AND TOU.PERIOD_ID = PER.PERIOD_ID
			-- Now apply Critical Peak Pricing permium
			AND ES.EVENT_ID(+) = p_EVENT_ID
			AND ES.SCHEDULE_DATE(+) = PER.CUT_DATE
			AND ES.SCHEDULE_DATE(+) BETWEEN v_EVENT_START AND v_EVENT_STOP
			AND PAY.PROGRAM_ID (+) = p_PROGRAM_ID
			AND PAY.PAYMENT_TYPE (+) = DEMAND_RESPONSE_UTIL.c_PAYMENT_TYPE_CPP_PREMIUM
			AND PER.LOCAL_DATE BETWEEN PAY.BEGIN_DATE (+)
					AND NVL(PAY.END_DATE (+), CONSTANTS.HIGH_DATE)
		ORDER BY DATE_TIME;
	END IF;

END CRITICAL_PEAK_EVENT_SCHEDULES;
--------------------------------------------------------------------------------
PROCEDURE TX_SEGMENT_LOSS_FACTORS
    (
    p_FEEDER_SEGMENT_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_FEEDER_SEGMENT_ID, EC.ED_TX_FEEDER_SEGMENT);

    OPEN p_CURSOR FOR
        SELECT FEEDER_SEGMENT_ID,
            BEGIN_DATE,
            END_DATE,
            LOSS_FACTOR_ID,
            ENTRY_DATE
        FROM TX_FEEDER_SEGMENT_LOSS_FACTOR
        WHERE FEEDER_SEGMENT_ID = p_FEEDER_SEGMENT_ID
        ORDER BY BEGIN_DATE;

END TX_SEGMENT_LOSS_FACTORS;
--------------------------------------------------------------------------------
PROCEDURE PUT_TX_SEGMENT_LOSS_FACTOR
    (
    p_FEEDER_SEGMENT_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_LOSS_FACTOR_ID IN NUMBER,
    p_OLD_BEGIN_DATE IN DATE
    ) AS
v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_FEEDER_SEGMENT_ID, EC.ED_TX_FEEDER_SEGMENT);

    v_KEY_NEW('FEEDER_SEGMENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_FEEDER_SEGMENT_ID);
    v_KEY_OLD('FEEDER_SEGMENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_FEEDER_SEGMENT_ID);
    v_DATA('LOSS_FACTOR_ID') := UT.GET_LITERAL_FOR_NUMBER(p_LOSS_FACTOR_ID);

    UT.PUT_TEMPORAL_DATA_UI('TX_FEEDER_SEGMENT_LOSS_FACTOR',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

END PUT_TX_SEGMENT_LOSS_FACTOR;
--------------------------------------------------------------------------------
PROCEDURE PROGRAM_THRESHOLDS
    (
    p_PROGRAM_ID IN NUMBER,
	p_SIGNAL_TYPE IN VARCHAR2,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_PROGRAM_ID, EC.ED_PROGRAM);

	OPEN p_CURSOR FOR
		SELECT p_PROGRAM_ID AS PROGRAM_ID,
			L.VALUE AS THRESHOLD_NAME,
			T.MIN_VALUE,
			T.MAX_VALUE,
			T.ENTRY_DATE
		FROM SYSTEM_LABEL L,
			PROGRAM_THRESHOLD T
		WHERE MODEL_ID = 0
			AND MODULE = 'Product'
			AND KEY1 = 'Smart Grid Programs'
			AND KEY2 = 'Signal Type'
			AND KEY3 = p_SIGNAL_TYPE
			AND T.THRESHOLD_NAME(+) = L.VALUE
			AND T.PROGRAM_ID(+) = p_PROGRAM_ID
		ORDER BY T.MIN_VALUE, L.KEY3;


END PROGRAM_THRESHOLDS;
--------------------------------------------------------------------------------
PROCEDURE PUT_PROGRAM_THRESHOLD
    (
    p_PROGRAM_ID IN NUMBER,
    p_THRESHOLD_NAME IN VARCHAR2,
    p_MIN_VALUE IN NUMBER,
    p_MAX_VALUE IN NUMBER,
    p_OLD_THRESHOLD_NAME IN VARCHAR2,
    p_OLD_MIN_VALUE IN NUMBER
    ) AS
v_COUNT NUMBER;
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_PROGRAM_ID, EC.ED_PROGRAM);

	-- Check if there are any overlapping date range
	SELECT COUNT(1) INTO v_COUNT
	FROM PROGRAM_THRESHOLD T
	WHERE T.PROGRAM_ID = p_PROGRAM_ID
		AND T.THRESHOLD_NAME <> p_THRESHOLD_NAME
		AND p_MIN_VALUE < NVL(T.MAX_VALUE,p_MIN_VALUE+1) and ( p_MAX_VALUE is NULL or p_MAX_VALUE > T.MIN_VALUE);

	IF v_COUNT > 0 THEN
		ERRS.RAISE_BAD_ARGUMENT('Threshold range',
								TO_CHAR(p_MIN_VALUE) || '-' || NVL(TO_CHAR(p_MAX_VALUE),'NULL'),
								'One or more range overlap the Min and Max Value.');
	END IF;

    UPDATE PROGRAM_THRESHOLD SET
        THRESHOLD_NAME = p_THRESHOLD_NAME,
        MIN_VALUE = p_MIN_VALUE,
        MAX_VALUE = p_MAX_VALUE,
        ENTRY_DATE = SYSDATE
    WHERE PROGRAM_ID = p_PROGRAM_ID
        AND THRESHOLD_NAME = p_OLD_THRESHOLD_NAME
        AND MIN_VALUE = p_OLD_MIN_VALUE;

    IF SQL%NOTFOUND THEN
        INSERT INTO PROGRAM_THRESHOLD (
            PROGRAM_ID,
            THRESHOLD_NAME,
            MIN_VALUE,
            MAX_VALUE,
            ENTRY_DATE)
        VALUES (
            p_PROGRAM_ID,
            p_THRESHOLD_NAME,
            p_MIN_VALUE,
            p_MAX_VALUE,
            SYSDATE);
    END IF;

END PUT_PROGRAM_THRESHOLD;
----------------------------------------------------------------------------------------------------
PROCEDURE COPY_PROGRAM
	(
	p_ENTITY_ID IN NUMBER,
	p_NEW_ENTITY_ID OUT NUMBER,
	p_NEW_ENTITY_NAME OUT VARCHAR2
	) AS
v_PROGRAM_LIMIT_ID PROGRAM_LIMIT.PROGRAM_LIMIT_ID%TYPE;
v_PROGRAM_LIMIT PROGRAM_LIMIT%ROWTYPE;
CURSOR c_PROGRAM_LIMITS IS
	SELECT L.*
	FROM PROGRAM_LIMIT L
	WHERE L.PROGRAM_ID = p_ENTITY_ID;
BEGIN
	ENTITY_UTIL.COPY_ENTITY(p_ENTITY_ID,
							'PROGRAM',
							p_NEW_ENTITY_ID,
							p_NEW_ENTITY_NAME);

	FOR v_PROGRAM_LIMIT IN c_PROGRAM_LIMITS LOOP
		-- Get the next Program Limit ID
		SELECT OID.NEXTVAL
		INTO v_PROGRAM_LIMIT_ID
		FROM DUAL;

		-- Copy Program Limit
		INSERT INTO PROGRAM_LIMIT(PROGRAM_ID, LIMIT_TYPE, LIMIT_PERIOD, TEMPLATE_ID,
			PERIOD_ID, MAX_LIMIT, PROGRAM_LIMIT_ID, ENTRY_DATE)
		VALUES( p_NEW_ENTITY_ID, v_PROGRAM_LIMIT.LIMIT_TYPE , v_PROGRAM_LIMIT.LIMIT_PERIOD, v_PROGRAM_LIMIT.TEMPLATE_ID,
			v_PROGRAM_LIMIT.PERIOD_ID, v_PROGRAM_LIMIT.MAX_LIMIT, v_PROGRAM_LIMIT_ID, SYSDATE);
	END LOOP;

END COPY_PROGRAM;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_IT_SCHEDULE_MANAGEMENT_MAP
    (
    p_TRANSACTION_ID IN NUMBER,
    p_STATEMENT_TYPE_ID IN NUMBER,
    p_SCHEDULE_STATE IN NUMBER,
    p_SCHED_MGMT_CID IN VARCHAR2,
    p_SCHED_MGMT_DATA_SOURCE IN CHAR,
	p_OLD_TRANSACTION_ID IN NUMBER,
    p_OLD_STATEMENT_TYPE_ID IN NUMBER,
	p_OLD_SCHEDULE_STATE IN NUMBER
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_SCHED_MAN_MAP, p_TRANSACTION_ID, EC.ED_TRANSACTION);

	-- TODO: GET RID OF THIS NULL CHECK, IT'S NECESSITATED BY BZ 19695
	IF p_SCHED_MGMT_CID IS NOT NULL AND p_SCHED_MGMT_DATA_SOURCE IS NOT NULL THEN

		UPDATE IT_SCHEDULE_MANAGEMENT_MAP SET
			TRANSACTION_ID = p_TRANSACTION_ID,
			STATEMENT_TYPE_ID = p_STATEMENT_TYPE_ID,
			SCHEDULE_STATE = p_SCHEDULE_STATE,
			SCHED_MGMT_CID = p_SCHED_MGMT_CID,
			SCHED_MGMT_DATA_SOURCE = p_SCHED_MGMT_DATA_SOURCE
		WHERE TRANSACTION_ID = p_OLD_TRANSACTION_ID
			AND STATEMENT_TYPE_ID = p_OLD_STATEMENT_TYPE_ID
			AND SCHEDULE_STATE = p_OLD_SCHEDULE_STATE;

		IF SQL%NOTFOUND THEN
			INSERT INTO IT_SCHEDULE_MANAGEMENT_MAP (
				TRANSACTION_ID,
				STATEMENT_TYPE_ID,
				SCHEDULE_STATE,
				SCHED_MGMT_CID,
				SCHED_MGMT_DATA_SOURCE)
			VALUES (
				p_TRANSACTION_ID,
				p_STATEMENT_TYPE_ID,
				p_SCHEDULE_STATE,
				p_SCHED_MGMT_CID,
				p_SCHED_MGMT_DATA_SOURCE);
		END IF;

	END IF;

END PUT_IT_SCHEDULE_MANAGEMENT_MAP;
----------------------------------------------------------------------------------------------------
PROCEDURE IT_SCHEDULE_MANAGEMENT_MAPS
    (
    p_TRANSACTION_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_TRANSACTION_ID, EC.ED_TRANSACTION);

	OPEN p_CURSOR FOR
	SELECT p_TRANSACTION_ID AS TRANSACTION_ID,
		TYPES.STATEMENT_TYPE_ID,
		TYPES.STATEMENT_TYPE_NAME,
		TYPES.SCHEDULE_STATE,
		TYPES.SCHEDULE_STATE_NAME,
		MP.SCHED_MGMT_CID,
		MP.SCHED_MGMT_DATA_SOURCE,
		CASE MP.SCHED_MGMT_DATA_SOURCE
			WHEN 'P' THEN 'Preschedule'
			WHEN 'I' THEN 'Instruction'
			WHEN 'A' THEN 'Actual'
			WHEN 'D' THEN 'Day-Ahead'
			WHEN 'R' THEN 'Real-Time'
			WHEN 'O' THEN 'ISO Imported'
		END AS SCHED_MGMT_DATA_SOURCE_DISP
	FROM (SELECT ST.STATEMENT_TYPE_ID, ST.STATEMENT_TYPE_NAME, ST.STATEMENT_TYPE_ORDER,
				1 AS SCHEDULE_STATE,
				'Internal' AS SCHEDULE_STATE_NAME
			FROM STATEMENT_TYPE ST
			WHERE ST.STATEMENT_TYPE_ID <> CONSTANTS.NOT_ASSIGNED
			UNION ALL
			SELECT ST.STATEMENT_TYPE_ID, ST.STATEMENT_TYPE_NAME, ST.STATEMENT_TYPE_ORDER,
				2 AS SCHEDULE_STATE,
				'External' AS SCHEDULE_STATE_NAME
			FROM STATEMENT_TYPE ST
			WHERE ST.STATEMENT_TYPE_ID <> CONSTANTS.NOT_ASSIGNED) TYPES,
	IT_SCHEDULE_MANAGEMENT_MAP MP
	WHERE MP.STATEMENT_TYPE_ID (+) = TYPES.STATEMENT_TYPE_ID
		AND MP.SCHEDULE_STATE (+) = TYPES.SCHEDULE_STATE
		AND MP.TRANSACTION_ID (+) = p_TRANSACTION_ID
	ORDER BY TYPES.STATEMENT_TYPE_ORDER, TYPES.STATEMENT_TYPE_NAME, TYPES.SCHEDULE_STATE;

END IT_SCHEDULE_MANAGEMENT_MAPS;
----------------------------------------------------------------------------------------------------
FUNCTION IS_VPP_ASSOCIATED_WITH_EVENTS
	(
	p_ENTITY_ID IN NUMBER
	) RETURN NUMBER
AS
	v_RESULT NUMBER(1);
BEGIN
	SELECT CASE WHEN COUNT(1) > 0 THEN 1 ELSE 0 END INTO v_RESULT
	FROM DR_EVENT E
	WHERE E.VPP_ID = p_ENTITY_ID;

	RETURN v_RESULT;
END IS_VPP_ASSOCIATED_WITH_EVENTS;
----------------------------------------------------------------------------------------------------
PROCEDURE PARAMETERS_FOR_STATION_LIST
	(
	p_STATION_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT WP.PARAMETER_NAME, WSP.PARAMETER_ID
		FROM WEATHER_STATION_PARAMETER WSP,
			WEATHER_PARAMETER WP
		WHERE WSP.STATION_ID = p_STATION_ID
			AND WP.PARAMETER_ID = WSP.PARAMETER_ID
		ORDER BY 1;
END PARAMETERS_FOR_STATION_LIST;
----------------------------------------------------------------------------------------------------
FUNCTION ENSURE_DAY_TYPE_RECORD
	(
	p_TEMPLATE_ID IN NUMBER,
	p_SEASON_ID IN NUMBER,
	p_DAY_NAME IN VARCHAR2,
	p_DST_TYPE IN NUMBER
	) RETURN NUMBER IS

	v_DAY_TYPE_ID NUMBER(9);

BEGIN

	SELECT MAX(TDT.DAY_TYPE_ID)
	INTO v_DAY_TYPE_ID
	FROM TEMPLATE_DAY_TYPE TDT
	WHERE TDT.TEMPLATE_ID = p_TEMPLATE_ID
		AND TDT.SEASON_ID = p_SEASON_ID
		AND TDT.DAY_NAME = p_DAY_NAME
		AND TDT.DST_TYPE = p_DST_TYPE;

	-- NOT THERE, CREATE IT
	IF v_DAY_TYPE_ID IS NULL THEN

		SELECT DAY_TYPE_ID.NEXTVAL
		INTO v_DAY_TYPE_ID
		FROM DUAL;

		INSERT INTO TEMPLATE_DAY_TYPE (DAY_TYPE_ID, TEMPLATE_ID, SEASON_ID, DAY_NAME, DST_TYPE)
		VALUES (v_DAY_TYPE_ID, p_TEMPLATE_ID, p_SEASON_ID, p_DAY_NAME, p_DST_TYPE);

	END IF;

	RETURN v_DAY_TYPE_ID;

END ENSURE_DAY_TYPE_RECORD;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_SEASON_TEMPLATE
	(
	p_TEMPLATE_ID IN NUMBER,
	p_SEASON_ID IN NUMBER,
	p_DAY_NAME IN VARCHAR2,
	p_BEGIN_INTERVAL IN VARCHAR2,
	p_END_INTERVAL IN VARCHAR2,
	p_PERIOD_ID IN NUMBER,
	p_OLD_SEASON_ID IN NUMBER,
	p_OLD_DAY_NAME IN VARCHAR2,
	p_OLD_BEGIN_INTERVAL IN VARCHAR2
	) AS

	v_NUM_HR NUMBER(2);
	v_NUM_MIN NUMBER(2);

	v_BEGIN_NUM NUMBER(4,2);
	v_END_NUM NUMBER(4,2);

	v_BEGIN_INTERVAL SEASON_TEMPLATE.BEGIN_INTERVAL%TYPE;
	v_OLD_BEGIN_INTERVAL SEASON_TEMPLATE.BEGIN_INTERVAL%TYPE;

BEGIN

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_TEMPLATE_ID, EC.ED_TEMPLATE);

	v_NUM_HR := TO_NUMBER(SUBSTR(p_BEGIN_INTERVAL, 1, 2));
	v_NUM_MIN := TO_NUMBER(SUBSTR(p_BEGIN_INTERVAL, 4, 2));

	IF v_NUM_HR NOT BETWEEN 0 AND 24 OR (v_NUM_HR = 24 AND v_NUM_MIN > 0)
		OR v_NUM_MIN NOT BETWEEN 0 AND 60 THEN
		ERRS.RAISE_BAD_ARGUMENT('BEGIN_INTERVAL', p_BEGIN_INTERVAL, 'BEGIN_INTERVAL should be in the'
							|| ' format HH24:MI.');
	END IF;

	v_BEGIN_NUM := v_NUM_HR + v_NUM_MIN/100;

	v_NUM_HR := TO_NUMBER(SUBSTR(p_END_INTERVAL, 1, 2));
	v_NUM_MIN := TO_NUMBER(SUBSTR(p_END_INTERVAL, 4, 2));

	IF v_NUM_HR NOT BETWEEN 0 AND 24 OR (v_NUM_HR = 24 AND v_NUM_MIN > 0)
		OR v_NUM_MIN NOT BETWEEN 0 AND 60 THEN
		ERRS.RAISE_BAD_ARGUMENT('END_INTERVAL', p_END_INTERVAL, 'BEGIN_INTERVAL should be in the'
							|| ' format HH24:MI.');
	END IF;

	v_END_NUM := v_NUM_HR + v_NUM_MIN/100;

	IF v_BEGIN_NUM >= v_END_NUM THEN
		ERRS.RAISE_BAD_ARGUMENT('BEGIN_INTERVAL/END_INTERVAL', p_BEGIN_INTERVAL || '/' || p_END_INTERVAL,
			'BEGIN_INTERVAL should be before END_INTERVAL.');
	END IF;

	-- ADD A SECOND TO THE BEGIN INTERVAL, SINCE WE'RE IN INTERVAL-ENDING TIME
	v_BEGIN_INTERVAL := p_BEGIN_INTERVAL || ':01';
	v_OLD_BEGIN_INTERVAL := p_OLD_BEGIN_INTERVAL || ':01';

	UPDATE SEASON_TEMPLATE ST
	SET ST.SEASON_ID = p_SEASON_ID,
		ST.DAY_NAME = p_DAY_NAME,
		ST.BEGIN_INTERVAL = v_BEGIN_INTERVAL,
		ST.END_INTERVAL = p_END_INTERVAL || ':00',
		ST.PERIOD_ID = p_PERIOD_ID,
		ST.ENTRY_DATE = SYSDATE
	WHERE ST.SEASON_ID = p_OLD_SEASON_ID
		AND ST.DAY_NAME = p_OLD_DAY_NAME
		AND ST.BEGIN_INTERVAL = v_OLD_BEGIN_INTERVAL
		AND ST.TEMPLATE_ID = p_TEMPLATE_ID;

	IF SQL%NOTFOUND THEN
		INSERT INTO SEASON_TEMPLATE (TEMPLATE_ID, SEASON_ID, DAY_NAME, BEGIN_INTERVAL,
			END_INTERVAL, PERIOD_ID, ENTRY_DATE)
		VALUES (p_TEMPLATE_ID, p_SEASON_ID, p_DAY_NAME, v_BEGIN_INTERVAL, p_END_INTERVAL || ':00',
			p_PERIOD_ID, SYSDATE);
	END IF;

END PUT_SEASON_TEMPLATE;
----------------------------------------------------------------------------------------------------
PROCEDURE VALIDATE_TOU_TEMPLATE
	(
	p_TEMPLATE_ID IN NUMBER,
	p_MESSAGE OUT VARCHAR2
	) AS

	v_PREV_END DATE;
	v_PREV_SEASON_ID NUMBER(9);

	v_FIRST_BEGIN DATE;
	v_FIRST_SEASON_ID NUMBER(9);

	v_PREV_END_INTERVAL SEASON_TEMPLATE.BEGIN_INTERVAL%TYPE;
	v_PREV_END_INT_NUM NUMBER;
	v_PREV_PERIOD_ID NUMBER(9);

	v_AT_LEAST_TWO BOOLEAN := FALSE;

	v_DAY_NAMES STRING_COLLECTION;

------------
FUNCTION GET_DATE_RANGE
	(
	p_RANGE_BEGIN DATE,
	p_RANGE_END DATE
	) RETURN VARCHAR2 IS

	BEGIN

	RETURN TO_CHAR(p_RANGE_BEGIN, 'Mon DD') || ' -> ' || TO_CHAR(p_RANGE_END, 'Mon DD');

END GET_DATE_RANGE;
------------

BEGIN

	FOR v_REC IN (SELECT DISTINCT S.SEASON_ID, S.BEGIN_DATE, S.END_DATE
					FROM SEASON_TEMPLATE ST,
						SEASON S
					WHERE ST.TEMPLATE_ID = p_TEMPLATE_ID
						AND S.SEASON_ID = ST.SEASON_ID
					ORDER BY S.BEGIN_DATE) LOOP

		IF v_FIRST_BEGIN IS NULL THEN
			v_FIRST_BEGIN := v_REC.BEGIN_DATE;
			v_FIRST_SEASON_ID := v_REC.SEASON_ID;
		ELSE
			-- WE HAVE AT LEAST TWO SEASONS
			v_AT_LEAST_TWO := TRUE;
		END IF;

		IF v_PREV_END IS NOT NULL AND v_REC.BEGIN_DATE > (v_PREV_END+1) THEN
			p_MESSAGE := 'The date range ' || GET_DATE_RANGE(v_PREV_END + 1, v_REC.BEGIN_DATE - 1)
				|| ' is not covered by any Season.';
		END IF;

		IF v_PREV_END IS NOT NULL AND v_REC.BEGIN_DATE < (v_PREV_END+1) THEN
			p_MESSAGE := 'The date range ' || GET_DATE_RANGE(v_PREV_END + 1, v_REC.BEGIN_DATE - 1)
				|| ' is covered by both Season ' || TEXT_UTIL.TO_CHAR_ENTITY(v_REC.SEASON_ID, EC.ED_SEASON)
				|| ' and Season ' || TEXT_UTIL.TO_CHAR_ENTITY(v_PREV_SEASON_ID, EC.ED_SEASON) || '.';
		END IF;

		-- ENCOUNTERED A VALIDATION ERROR, EXIT THE LOOP
		EXIT WHEN p_MESSAGE IS NOT NULL;

		v_PREV_END := v_REC.END_DATE;
		v_PREV_SEASON_ID := v_REC.SEASON_ID;
	END LOOP;

	IF p_MESSAGE IS NULL AND v_PREV_END < DATE '1900-12-31' THEN
		p_MESSAGE := 'The date range ' || GET_DATE_RANGE(v_PREV_END + 1, v_FIRST_BEGIN - 1)
			|| ' is not covered by any Season.';
	END IF;

	-- LAST STEP IS TO VALIDATE THE LAST SEASON AGAINST THE FIRST SEASON
	IF v_PREV_END = DATE '1900-12-31' THEN
		-- SUBTRACT A YEAR FROM THE LAST RECORD'S END DATE IF IT ENDS
		-- ON 12/31 TO MAKE THE LOGIC WORK IN THE NEXT STEP (OTHERWISE WE'D BE LOOKING FOR 1/1/1901);
		v_PREV_END := ADD_MONTHS(v_PREV_END, -12);
	END IF;

	IF p_MESSAGE IS NULL AND (v_FIRST_BEGIN > (v_PREV_END+1)
								-- IF WE HAD ONLY ONE SEASON AND IT WASN'T THE ANYTIME SEASON
								OR (v_AT_LEAST_TWO <> TRUE AND (v_FIRST_BEGIN <> DATE '1900-01-01'
										OR v_PREV_END <> DATE '1899-12-31'))) THEN
		p_MESSAGE := 'The date range ' || GET_DATE_RANGE(v_PREV_END + 1, v_FIRST_BEGIN - 1)
			|| ' is not covered by any Season.';
	END IF;

	IF p_MESSAGE IS NULL AND v_FIRST_BEGIN < (v_PREV_END+1) THEN
		p_MESSAGE := 'The date range ' || GET_DATE_RANGE(v_PREV_END + 1, v_FIRST_BEGIN - 1)
			|| ' is covered by both Season ' || TEXT_UTIL.TO_CHAR_ENTITY(v_PREV_SEASON_ID, EC.ED_SEASON)
			|| ' and Season ' || TEXT_UTIL.TO_CHAR_ENTITY(v_FIRST_SEASON_ID, EC.ED_SEASON) || '.';
	END IF;

	-- make sure all day names are covered FOR ALL SEASONS
	FOR v_SEASON IN (SELECT DISTINCT ST.SEASON_ID
					FROM SEASON_TEMPLATE ST
					WHERE ST.TEMPLATE_ID = p_TEMPLATE_ID) LOOP

		SELECT DN.VALUE AS DAY_NAME
		BULK COLLECT INTO v_DAY_NAMES
		FROM SYSTEM_LABEL DN
			WHERE DN.MODEL_ID = 0
				AND DN.MODULE = 'Entity Manager'
				AND DN.KEY1 = 'TOU Template'
				AND DN.KEY2 = 'Template Definition'
				AND DN.KEY3 = 'Day Names'
				AND NOT EXISTS (SELECT 1
								FROM SEASON_TEMPLATE ST
								WHERE ST.SEASON_ID = v_SEASON.SEASON_ID
									AND ST.TEMPLATE_ID = p_TEMPLATE_ID
									AND ST.DAY_NAME = DN.VALUE);

		IF v_DAY_NAMES.COUNT > 0 THEN
			p_MESSAGE := 'Day Name(s) ' || TEXT_UTIL.TO_CHAR_STRING_LIST(v_DAY_NAMES, FALSE)
				|| ' are not covered by ' || TEXT_UTIL.TO_CHAR_ENTITY(v_SEASON.SEASON_ID,
																	EC.ED_SEASON, TRUE) || '.';
		END IF;
	END LOOP;



	-- VALIDATE THE COVERAGE FOR EACH SEASON / DAY NAME
	FOR v_SEASON_DN_REC IN (SELECT DISTINCT ST.SEASON_ID, ST.DAY_NAME
							FROM SEASON_TEMPLATE ST
							WHERE ST.TEMPLATE_ID = p_TEMPLATE_ID) LOOP

		-- ENCOUNTERED A VALIDATION ERROR (POSSIBLY IN THE PREVIOUS STEP), EXIT THE LOOP
		EXIT WHEN p_MESSAGE IS NOT NULL;

		v_PREV_END_INT_NUM := NULL;
		v_PREV_END_INTERVAL := NULL;

		FOR v_REC IN (SELECT S.*
						FROM (SELECT ST.BEGIN_INTERVAL, ST.END_INTERVAL,
							(TO_NUMBER(SUBSTR(ST.BEGIN_INTERVAL, 1, 2))*60 +
									TO_NUMBER(SUBSTR(ST.BEGIN_INTERVAL, 4, 2)) +
									TO_NUMBER(SUBSTR(ST.BEGIN_INTERVAL, 7, 2)/60)) AS BEGIN_NUM,
							(TO_NUMBER(SUBSTR(ST.END_INTERVAL, 1, 2))*60 +
									TO_NUMBER(SUBSTR(ST.END_INTERVAL, 4, 2)) +
									TO_NUMBER(SUBSTR(ST.END_INTERVAL, 7, 2)/60)) AS END_NUM,
							ST.PERIOD_ID
						FROM SEASON_TEMPLATE ST
						WHERE ST.TEMPLATE_ID = p_TEMPLATE_ID
							AND ST.SEASON_ID = v_SEASON_DN_REC.SEASON_ID
							AND ST.DAY_NAME = v_SEASON_DN_REC.DAY_NAME) S
						ORDER BY S.BEGIN_NUM) LOOP

			IF v_PREV_END_INTERVAL IS NULL AND v_REC.BEGIN_INTERVAL <> '00:00:01' THEN
				-- THE FIRST INTERVAL MUST START ON SECOND 1 OF THE DAY
				p_MESSAGE := 'The interval 00:00:01 -> ' || v_REC.BEGIN_INTERVAL
					|| ' is not covered by any Period for Season '
					|| TEXT_UTIL.TO_CHAR_ENTITY(v_SEASON_DN_REC.SEASON_ID, EC.ED_SEASON)
					|| ' and Day Name ' || v_SEASON_DN_REC.DAY_NAME || '.';
				EXIT;
			END IF;

			IF v_PREV_END_INTERVAL IS NOT NULL AND v_REC.BEGIN_NUM < (v_PREV_END_INT_NUM + 1/60) THEN
				p_MESSAGE := 'The interval ' || v_REC.BEGIN_INTERVAL || ' -> ' || v_PREV_END_INTERVAL
					|| ' is covered by both Period ' || TEXT_UTIL.TO_CHAR_ENTITY(v_PREV_PERIOD_ID, EC.ED_PERIOD)
					|| ' and Period ' || TEXT_UTIL.TO_CHAR_ENTITY(v_REC.PERIOD_ID, EC.ED_PERIOD)
					|| ' for Season '
					|| TEXT_UTIL.TO_CHAR_ENTITY(v_SEASON_DN_REC.SEASON_ID, EC.ED_SEASON)
					|| ' and Day Name ' || v_SEASON_DN_REC.DAY_NAME || '.';
				EXIT;
			END IF;

			IF v_PREV_END_INTERVAL IS NOT NULL AND v_REC.BEGIN_NUM > (v_PREV_END_INT_NUM + 1/60) THEN
				p_MESSAGE := 'The interval ' || v_REC.BEGIN_INTERVAL || ' -> ' || v_PREV_END_INTERVAL
					|| ' is not covered by any Period for Season '
					|| TEXT_UTIL.TO_CHAR_ENTITY(v_SEASON_DN_REC.SEASON_ID, EC.ED_SEASON)
					|| ' and Day Name ' || v_SEASON_DN_REC.DAY_NAME || '.';
				EXIT;
			END IF;

			-- ENCOUNTERED A VALIDATION ERROR, EXIT THE LOOP
			EXIT WHEN p_MESSAGE IS NOT NULL;

			v_PREV_END_INT_NUM := v_REC.END_NUM;
			v_PREV_END_INTERVAL := v_REC.END_INTERVAL;
			v_PREV_PERIOD_ID := v_REC.PERIOD_ID;
		END LOOP;

		-- CHECK THE LAST INTERVAL
		IF p_MESSAGE IS NULL AND v_PREV_END_INTERVAL <> '24:00:00' THEN
			p_MESSAGE := 'The interval ' || v_PREV_END_INTERVAL || ' -> 24:00:00 '
					|| ' is not covered by any Period for Season '
					|| TEXT_UTIL.TO_CHAR_ENTITY(v_SEASON_DN_REC.SEASON_ID, EC.ED_SEASON)
					|| ' and Day Name ' || v_SEASON_DN_REC.DAY_NAME || '.';
		END IF;
	END LOOP;

	IF p_MESSAGE IS NOT NULL THEN
		DELETE TEMPLATE_DATES TD
		WHERE TD.TEMPLATE_ID = p_TEMPLATE_ID;

		DELETE TEMPLATE_DAY_TYPE TDT
		WHERE TDT.TEMPLATE_ID = p_TEMPLATE_ID;

		UPDATE TEMPLATE T
		SET T.VALIDATION_MESSAGE = p_MESSAGE
		WHERE T.TEMPLATE_ID = p_TEMPLATE_ID;
	ELSE
		UPDATE TEMPLATE T
		SET T.VALIDATION_MESSAGE = NULL
		WHERE T.TEMPLATE_ID = p_TEMPLATE_ID;

		EM.FILL_TEMPLATE_DAY_TYPE(p_TEMPLATE_ID);
	END IF;

END VALIDATE_TOU_TEMPLATE;
----------------------------------------------------------------------------------------------------
PROCEDURE FILL_TEMPLATE_DATES
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONES IN STRING_COLLECTION,
	p_PROCESS_ID OUT VARCHAR2,
	p_PROCESS_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR2
	) AS

	v_TRUNC_BEGIN DATE := TRUNC(p_BEGIN_DATE);
	v_TRUNC_END DATE := TRUNC(p_END_DATE);

	v_TARGET_PARAMS UT.STRING_MAP;

BEGIN

	ASSERT(p_TIME_ZONES.COUNT <> 0, 'At least one time zone must be selected.', MSGCODES.c_ERR_ARGUMENT);

	v_TARGET_PARAMS('Time Zones') := TEXT_UTIL.TO_CHAR_STRING_LIST(p_TIME_ZONES);

	LOGS.START_PROCESS('Fill Template Dates', p_BEGIN_DATE, p_END_DATE, v_TARGET_PARAMS);

	-- WE PROCESS EACH TIME_ZONE, PLUS 1 STEP FOR DELETING EXISTING RECORDS
	LOGS.INIT_PROCESS_PROGRESS(p_TOTAL_WORK => p_TIME_ZONES.COUNT + 1);

	-- CLEAR OUT ANY EXISTING RECORDS IN TEMPLATE_DATES
	DELETE FROM TEMPLATE_DATES TD
	WHERE TD.LOCAL_DATE BETWEEN v_TRUNC_BEGIN AND v_TRUNC_END
		AND TD.TIME_ZONE IN (SELECT X.COLUMN_VALUE
								FROM TABLE(CAST(p_TIME_ZONES AS STRING_COLLECTION)) X);

	LOGS.INCREMENT_PROCESS_PROGRESS;

	FOR v_IDX IN 1..p_TIME_ZONES.COUNT LOOP
		INSERT INTO TEMPLATE_DATES (TIME_ZONE, TEMPLATE_ID, HOLIDAY_SET_ID, LOCAL_DATE, CUT_BEGIN_DATE,
			CUT_END_DATE, DAY_TYPE_ID)
		SELECT p_TIME_ZONES(v_IDX) AS TIME_ZONE,
				T.TEMPLATE_ID,
				DATES.HOLIDAY_SET_ID,
				DATES.DT AS LOCAL_DATE,
				TO_CUT(DATES.DT,
					CASE WHEN T.IS_DST_OBSERVANT = 1 THEN
						p_TIME_ZONES(v_IDX)
					ELSE
						STD_TIME_ZONE(p_TIME_ZONES(v_IDX))
					END) AS CUT_BEGIN_DATE,
				TO_CUT(DATES.DT + 1,
					CASE WHEN T.IS_DST_OBSERVANT = 1 THEN
						p_TIME_ZONES(v_IDX)
					ELSE
						STD_TIME_ZONE(p_TIME_ZONES(v_IDX))
					END) AS CUT_END_DATE,
				TDT.DAY_TYPE_ID
		FROM (SELECT HSCHED.HOLIDAY_SET_ID, HO.HOLIDAY_DATE
				FROM HOLIDAY_SCHEDULE HSCHED,
					HOLIDAY_OBSERVANCE HO
				WHERE HO.HOLIDAY_ID = HSCHED.HOLIDAY_ID
					AND HO.HOLIDAY_DATE BETWEEN v_TRUNC_BEGIN AND v_TRUNC_END
			  UNION ALL
			  -- THE 'ALL HOLIDAYS' HOLIDAY SET OBSERVES ALL HOLIDAYS
			  SELECT DISTINCT CONSTANTS.ALL_HOLIDAYS_HOLIDAY_SET AS HOLIDAY_SET_ID,
			  	 HO.HOLIDAY_DATE
			  FROM HOLIDAY_OBSERVANCE HO
			  WHERE HO.HOLIDAY_DATE BETWEEN v_TRUNC_BEGIN AND v_TRUNC_END) HOL,
			SEASON_DATES SD,
			TEMPLATE T,
			DST_TYPE DT,
			(SELECT DTS.DT, HS.HOLIDAY_SET_ID
				FROM (SELECT v_TRUNC_BEGIN + (LEVEL-1) AS DT
					  FROM DUAL
					  CONNECT BY LEVEL <= (v_TRUNC_END - v_TRUNC_BEGIN + 1)) DTS,
					HOLIDAY_SET HS) DATES,
			TEMPLATE_DAY_TYPE TDT
		WHERE HOL.HOLIDAY_SET_ID (+) = DATES.HOLIDAY_SET_ID
			AND HOL.HOLIDAY_DATE (+) = DATES.DT
			AND DATES.DT BETWEEN SD.BEGIN_DATE AND SD.END_DATE
			AND T.IS_DAY_TYPE = 0
			AND T.VALIDATION_MESSAGE IS NULL
			AND DATES.DT BETWEEN DT.BEGIN_DATE AND DT.END_DATE
			AND TDT.TEMPLATE_ID = T.TEMPLATE_ID
			AND TDT.SEASON_ID = SD.SEASON_ID
			AND TDT.DST_TYPE = (CASE WHEN T.IS_DST_OBSERVANT = 1
							AND SUBSTR(p_TIME_ZONES(v_IDX), 2, 1) = 'D'
								THEN DT.DST_TYPE
								ELSE 0 END)
			AND TDT.DAY_NAME = (CASE WHEN HOL.HOLIDAY_SET_ID IS NOT NULL
								THEN 'Hol'
								ELSE TO_CHAR(DATES.DT, 'Dy') END);


		LOGS.INCREMENT_PROCESS_PROGRESS;
	END LOOP;

	p_PROCESS_ID := LOGS.CURRENT_PROCESS_ID;
	LOGS.STOP_PROCESS(p_MESSAGE, p_PROCESS_STATUS);

EXCEPTION
	WHEN OTHERS THEN
		ERRS.ABORT_PROCESS;
END FILL_TEMPLATE_DATES;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_SEASON
	(
	o_OID OUT NUMBER,
	p_SEASON_NAME IN VARCHAR2,
	p_SEASON_ALIAS IN VARCHAR2,
	p_SEASON_DESC IN VARCHAR2,
	p_SEASON_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	) AS

BEGIN

	IO.PUT_SEASON(o_OID,
				p_SEASON_NAME,
				p_SEASON_ALIAS,
				p_SEASON_DESC,
				p_SEASON_ID,
				DATE_UTIL.SET_DATE_YEAR(p_BEGIN_DATE, 1900),
				DATE_UTIL.SET_DATE_YEAR(p_END_DATE, 1900));

END PUT_SEASON;
----------------------------------------------------------------------------------------------------
PROCEDURE SEASON_TEMPLATES
	(
	p_TEMPLATE_ID IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_TEMPLATE_ID, EC.ED_TEMPLATE);

	OPEN p_CURSOR FOR
	SELECT S.SEASON_ID, S.SEASON_NAME,
		ST.DAY_NAME,
		-- REMOVE THE SECOND PORTION OF THE INTERVALS
		SUBSTR(ST.BEGIN_INTERVAL, 1, 5) AS BEGIN_INTERVAL,
		SUBSTR(ST.END_INTERVAL, 1, 5) AS END_INTERVAL,
		P.PERIOD_ID, P.PERIOD_NAME,
		ST.ENTRY_DATE
	FROM SEASON_TEMPLATE ST,
		SEASON S,
		PERIOD P
	WHERE ST.TEMPLATE_ID = p_TEMPLATE_ID
		AND S.SEASON_ID = ST.SEASON_ID
		AND P.PERIOD_ID = ST.PERIOD_ID
	ORDER BY S.BEGIN_DATE,
		DECODE(ST.DAY_NAME, 'Mon', 1,
							'Tue', 2,
							'Wed', 3,
							'Thu', 4,
							'Fri', 5,
							'Sat', 6,
							'Sun', 7,
							'Hol', 8, -1),
		ST.BEGIN_INTERVAL;

END SEASON_TEMPLATES ;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_TEMPLATE_SEASON_DAY_NAMES
	(
	p_TEMPLATE_ID IN NUMBER,
	p_SEASON_IDS IN VARCHAR2,
	p_DAY_NAMES IN VARCHAR2
	) AS

	v_SEASON_IDS NUMBER_COLLECTION;
	v_DAY_NAMES STRING_COLLECTION;

BEGIN

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_TEMPLATE_ID, EC.ED_DAY_TYPE_TEMPLATE);

	--DELETE THE EXISTING ASSOCIATIONS.
	DELETE TEMPLATE_SEASON_DAY_NAME
	WHERE TEMPLATE_ID = p_TEMPLATE_ID;

	UT.STRING_COLLECTION_FROM_STRING(p_DAY_NAMES, ';', v_DAY_NAMES);
	UT.NUMBER_COLL_FROM_STRING(p_SEASON_IDS, ';', v_SEASON_IDS);

	INSERT INTO TEMPLATE_SEASON_DAY_NAME (TEMPLATE_ID, SEASON_ID, DAY_NAME, ENTRY_DATE)
	SELECT p_TEMPLATE_ID,
		TO_NUMBER(S.COLUMN_VALUE),
		TO_CHAR(DN.COLUMN_VALUE),
		SYSDATE
	FROM TABLE(CAST(v_DAY_NAMES AS STRING_COLLECTION)) DN,
		TABLE(CAST(v_SEASON_IDS AS NUMBER_COLLECTION)) S;

END PUT_TEMPLATE_SEASON_DAY_NAMES;
----------------------------------------------------------------------------------------------------
PROCEDURE TEMPLATE_DAY_NAMES
   	(
	p_TEMPLATE_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_TEMPLATE_ID, EC.ED_DAY_TYPE_TEMPLATE);

	OPEN p_CURSOR FOR
	SELECT DISTINCT
		CASE WHEN TSDN.TEMPLATE_ID IS NULL
			THEN 0
			ELSE 1 END "IS_DEFINED",
		DN.DAY_NAME,
		DN.POSITION
	FROM TEMPLATE_SEASON_DAY_NAME TSDN,
		(SELECT SL.VALUE "DAY_NAME", SL.POSITION
		FROM SYSTEM_LABEL SL
		WHERE SL.MODULE = 'Entity Manager'
			AND SL.KEY1 = 'TOU Template'
			AND SL.KEY2 = 'Template Definition'
			AND SL.KEY3 = 'Day Names') DN
	WHERE TSDN.TEMPLATE_ID(+) = p_TEMPLATE_ID
		AND TSDN.DAY_NAME(+) = DN.DAY_NAME
	ORDER BY DN.POSITION;

END TEMPLATE_DAY_NAMES;
----------------------------------------------------------------------------------------------------
PROCEDURE TEMPLATE_SEASONS
    (
	p_TEMPLATE_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_TEMPLATE_ID, EC.ED_DAY_TYPE_TEMPLATE);

	OPEN p_CURSOR FOR
	SELECT DISTINCT
		CASE WHEN TSDN.TEMPLATE_ID IS NULL
			THEN 0
			ELSE 1 END "IS_DEFINED",
		S.SEASON_NAME,
		S.SEASON_ID,
		S.BEGIN_DATE
	FROM TEMPLATE_SEASON_DAY_NAME TSDN,
		SEASON S
	WHERE TSDN.TEMPLATE_ID(+) = p_TEMPLATE_ID
		AND TSDN.SEASON_ID(+) = S.SEASON_ID
	ORDER BY S.BEGIN_DATE, S.SEASON_NAME;

END TEMPLATE_SEASONS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_TEMPLATE
	(
	o_OID OUT NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_TEMPLATE_NAME IN VARCHAR2,
	p_TEMPLATE_ALIAS IN VARCHAR2,
	p_TEMPLATE_DESC IN VARCHAR2,
	p_IS_DST_OBSERVANT IN NUMBER
	) AS

BEGIN

	IO.PUT_TEMPLATE(o_OID,
					p_TEMPLATE_NAME,
					p_TEMPLATE_ALIAS,
					p_TEMPLATE_DESC,
					p_TEMPLATE_ID,
					0,
					p_IS_DST_OBSERVANT,
					NULL);

	-- IO.PUT_TEMPLATE IS GOING TO CAST OUR NULL VALIDATION MESSAGE TO '?', FIX THAT
	UPDATE TEMPLATE T
	SET T.VALIDATION_MESSAGE = NULL
	WHERE T.TEMPLATE_ID = o_OID;

END PUT_TEMPLATE;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_TOU_TEMPLATES
	(
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
	SELECT T.TEMPLATE_ID, T.TEMPLATE_NAME
	FROM TEMPLATE T
	WHERE T.IS_DAY_TYPE = 0
	ORDER BY T.TEMPLATE_NAME;

END GET_TOU_TEMPLATES;
----------------------------------------------------------------------------------------------------

-- Retrieves the list of invoice e-mail recipients for the specified PSE. This
-- procedure will be generated using UT.CREATE_EM_ROUTINES. It will be tweaked to
-- return CONTACT_ID and CONTACT_GROUP_ID as a single column. This procedure will use
-- the same trick as EM.GET_CALC_PROCESS uses to return CONTEXT_REALM_ID and
-- CONTEXT_GROUP_ID as a single column: if the value is from CONTACT_ID then the
-- number will be positive, otherwise the number will be negative.
PROCEDURE PSE_INVOICE_RECIPIENTS
    (
    p_PSE_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_PSE_ID, EC.ED_PSE);

    OPEN p_CURSOR FOR
        SELECT PSE_ID,
            CASE WHEN PIR.CONTACT_ID IS NOT NULL THEN PIR.CONTACT_ID
				ELSE -PIR.CONTACT_GROUP_ID
				END as RECIPIENT_ID,
			CASE WHEN PIR.CONTACT_ID IS NOT NULL THEN '<html><b>Contact:</b> ' || C.CONTACT_NAME || '</html>'
				ELSE '<html><b>Group:</b> ' || EG.ENTITY_GROUP_NAME || '</html>' END as RECIPIENT_NAME,
            PIR.EMAIL_REC_TYPE
        FROM PSE_INVOICE_RECIPIENT PIR,
			CONTACT C,
			ENTITY_GROUP EG
        WHERE PIR.PSE_ID = p_PSE_ID
			AND PIR.CONTACT_GROUP_ID = EG.ENTITY_GROUP_ID (+)
			AND PIR.CONTACT_ID  = C.CONTACT_ID (+)
        ORDER BY 3 DESC;

END PSE_INVOICE_RECIPIENTS;
----------------------------------------------------------------------------------------------------
-- Saves an invoice e-mail recipient. This procedure will be generated using
-- UT.CREATE_EM_ROUTINES. It will be tweaked so that if p_CONTACT_ID is negative, it
-- is saved as the CONTACT_GROUP_ID value and CONTACT_ID is set to null, otherwise
-- vice versa.
PROCEDURE PUT_PSE_INVOICE_RECIPIENT
	(
	p_PSE_ID IN NUMBER,
	p_EMAIL_REC_TYPE IN VARCHAR2,
	p_RECIPIENT_ID IN NUMBER,
	p_OLD_RECIPIENT_ID IN NUMBER
	) AS
v_CONTACT_GROUP_ID NUMBER;
v_CONTACT_ID NUMBER;

v_OLD_CONTACT_GROUP_ID NUMBER;
v_OLD_CONTACT_ID NUMBER;
BEGIN
	-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_PSE_ID, EC.ED_PSE);

	IF p_RECIPIENT_ID < 0 THEN
		v_CONTACT_GROUP_ID := -p_RECIPIENT_ID;
		v_CONTACT_ID := NULL;

		v_OLD_CONTACT_GROUP_ID := -p_OLD_RECIPIENT_ID;
		v_OLD_CONTACT_ID := NULL;
	ELSE
		v_CONTACT_GROUP_ID := NULL;
		v_CONTACT_ID := p_RECIPIENT_ID;

		v_OLD_CONTACT_GROUP_ID := NULL;
		v_OLD_CONTACT_ID := p_OLD_RECIPIENT_ID;
	END IF;

	IF v_OLD_CONTACT_GROUP_ID IS NOT NULL OR v_OLD_CONTACT_ID IS NOT NULL THEN
		UPDATE PSE_INVOICE_RECIPIENT SET
			CONTACT_GROUP_ID = v_CONTACT_GROUP_ID,
			CONTACT_ID = v_CONTACT_ID,
			EMAIL_REC_TYPE = p_EMAIL_REC_TYPE
		WHERE PSE_ID = p_PSE_ID
			AND (v_OLD_CONTACT_GROUP_ID IS NULL OR CONTACT_GROUP_ID = v_OLD_CONTACT_GROUP_ID)
			AND (v_OLD_CONTACT_ID IS NULL OR CONTACT_ID = v_OLD_CONTACT_ID);
	ELSE
        INSERT INTO PSE_INVOICE_RECIPIENT (
            PSE_ID,
            CONTACT_GROUP_ID,
            CONTACT_ID,
            EMAIL_REC_TYPE)
        VALUES (
            p_PSE_ID,
            v_CONTACT_GROUP_ID,
            v_CONTACT_ID,
            p_EMAIL_REC_TYPE);
    END IF;

END PUT_PSE_INVOICE_RECIPIENT;
----------------------------------------------------------------------------------------------------
-- Retrieves a list of Contacts and Contact Groups. Contact Groups are represented as
-- negative IDs. The entity name will include a prefix of Contact: or Group: and
-- the text will use HTML to make the prefix appear in bold-face.
PROCEDURE GET_CONTACTS_AND_GROUPS
	(
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN

	OPEN p_CURSOR FOR
		SELECT C.CONTACT_ID recipient_id,
			'<html><b>Contact:</b> ' || C.CONTACT_NAME || '</html>' as RECIPIENT_NAME
		FROM CONTACT C
		UNION ALL
		SELECT -EG.ENTITY_GROUP_ID recipient_id,
			'<html><b>Group:</b> ' || EG.ENTITY_GROUP_NAME || '</html>' as RECIPIENT_NAME
		FROM ENTITY_GROUP EG
		ORDER BY 2 ASC;

END GET_CONTACTS_AND_GROUPS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_PSE
	(
	o_OID OUT NUMBER,
	p_PSE_NAME IN VARCHAR2,
	p_PSE_ALIAS IN VARCHAR2,
	p_PSE_DESC IN VARCHAR2,
	p_PSE_ID IN NUMBER,
	p_PSE_NERC_CODE IN VARCHAR2,
	p_PSE_STATUS IN VARCHAR2,
	p_PSE_DUNS_NUMBER IN VARCHAR2,
	p_PSE_BANK IN VARCHAR2,
	p_PSE_ACH_NUMBER IN VARCHAR2,
	p_PSE_TYPE IN VARCHAR2,
	p_PSE_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_PSE_IS_RETAIL_AGGREGATOR IN NUMBER,
	p_PSE_IS_BACKUP_GENERATION IN NUMBER,
	p_PSE_EXCLUDE_LOAD_SCHEDULE IN NUMBER,
	p_IS_BILLING_ENTITY IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_STATEMENT_INTERVAL IN VARCHAR2,
	p_INVOICE_INTERVAL IN VARCHAR2,
	p_WEEK_BEGIN IN VARCHAR2,
	p_INVOICE_LINE_ITEM_OPTION IN VARCHAR2,
	p_SCHEDULE_NAME_PREFIX IN VARCHAR2,
	p_SCHEDULE_FORMAT IN VARCHAR2,
	p_SCHEDULE_INTERVAL IN VARCHAR2,
	p_LOAD_ROUNDING_PREFERENCE IN VARCHAR2,
	p_LOSS_ROUNDING_PREFERENCE IN VARCHAR2,
	p_CREATE_TX_LOSS_SCHEDULE IN NUMBER,
	p_CREATE_DX_LOSS_SCHEDULE IN NUMBER,
	p_CREATE_UFE_SCHEDULE IN NUMBER,
	p_MINIMUM_SCHEDULE_AMT IN NUMBER,
	p_INVOICE_EMAIL_SUBJECT IN VARCHAR2,
	p_INVOICE_EMAIL_PRIORITY IN NUMBER
	) AS

v_INVOICE_EMAIL_BODY			PURCHASING_SELLING_ENTITY.INVOICE_EMAIL_BODY%TYPE;
v_INVOICE_EMAIL_BODY_MIME_TYPE	PURCHASING_SELLING_ENTITY.INVOICE_EMAIL_BODY_MIME_TYPE%TYPE;

BEGIN

	SELECT PSE.INVOICE_EMAIL_BODY, PSE.INVOICE_EMAIL_BODY_MIME_TYPE
	INTO v_INVOICE_EMAIL_BODY, v_INVOICE_EMAIL_BODY_MIME_TYPE
	FROM PURCHASING_SELLING_ENTITY PSE
	WHERE PSE.PSE_ID = p_PSE_ID;

	IO.PUT_PSE
		(
		o_OID,
		p_PSE_NAME,
		p_PSE_ALIAS,
		p_PSE_DESC,
		p_PSE_ID,
		p_PSE_NERC_CODE,
		p_PSE_STATUS,
		p_PSE_DUNS_NUMBER,
		p_PSE_BANK,
		p_PSE_ACH_NUMBER,
		p_PSE_TYPE,
		p_PSE_EXTERNAL_IDENTIFIER,
		p_PSE_IS_RETAIL_AGGREGATOR,
		p_PSE_IS_BACKUP_GENERATION,
		p_PSE_EXCLUDE_LOAD_SCHEDULE,
		p_IS_BILLING_ENTITY,
		p_TIME_ZONE,
		p_STATEMENT_INTERVAL,
		p_INVOICE_INTERVAL,
		p_WEEK_BEGIN,
		p_INVOICE_LINE_ITEM_OPTION,
		p_INVOICE_EMAIL_SUBJECT,
		p_INVOICE_EMAIL_PRIORITY,
		v_INVOICE_EMAIL_BODY,
		v_INVOICE_EMAIL_BODY_MIME_TYPE,
		p_SCHEDULE_NAME_PREFIX,
		p_SCHEDULE_FORMAT,
		p_SCHEDULE_INTERVAL,
		p_LOAD_ROUNDING_PREFERENCE,
		p_LOSS_ROUNDING_PREFERENCE,
		p_CREATE_TX_LOSS_SCHEDULE,
		p_CREATE_DX_LOSS_SCHEDULE,
		p_CREATE_UFE_SCHEDULE,
		p_MINIMUM_SCHEDULE_AMT
		);

END PUT_PSE;
----------------------------------------------------------------------------------------------------
PROCEDURE INVOICE_BODYS
	(
	p_PSE_ID IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
		SELECT PSE.INVOICE_EMAIL_BODY,
			PSE.INVOICE_EMAIL_BODY_MIME_TYPE
		FROM PURCHASING_SELLING_ENTITY PSE
		WHERE PSE.PSE_ID = p_PSE_ID;

END INVOICE_BODYS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_INVOICE_BODY
	(
	p_PSE_ID IN NUMBER,
	p_INVOICE_EMAIL_BODY_MIME_TYPE IN VARCHAR2,
	p_INVOICE_EMAIL_BODY IN VARCHAR2
	) AS
BEGIN

	UPDATE PURCHASING_SELLING_ENTITY PSE
	SET PSE.INVOICE_EMAIL_BODY = p_INVOICE_EMAIL_BODY,
		PSE.INVOICE_EMAIL_BODY_MIME_TYPE = p_INVOICE_EMAIL_BODY_MIME_TYPE
	WHERE PSE.PSE_ID = p_PSE_ID;

END PUT_INVOICE_BODY;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_LOAD_PROFILE
	(
	p_PROFILE_ID IN NUMBER,
	p_PROFILE_LIBRARY_ID OUT NUMBER,
	p_PROFILE_NAME OUT VARCHAR2,
	p_PROFILE_ALIAS OUT VARCHAR2,
	p_PROFILE_DESC OUT VARCHAR2,
	p_PROFILE_TYPE OUT VARCHAR2,
	p_PROFILE_OPERATION OUT VARCHAR2,
	p_PROFILE_ORIGIN OUT VARCHAR2,
	p_PROFILE_RATE_CLASS OUT VARCHAR2,
	p_PROFILE_DAY_TYPE OUT VARCHAR2,
	p_PROFILE_ACCOUNT_ID OUT NUMBER,
    p_PROFILE_ACCT_MODEL_OPT OUT VARCHAR2,
	p_PROFILE_METER_REF OUT VARCHAR2,
	p_PROFILE_SIC_CODE OUT VARCHAR2,
	p_PROFILE_SEASON OUT VARCHAR2,
	p_PROFILE_SYSTEM_LOAD OUT VARCHAR2,
	p_PROFILE_ADJUSTMENT_OPTION OUT VARCHAR2,
	p_PROFILE_STATION_ID OUT NUMBER,
	p_PROFILE_TEMPLATE_ID OUT NUMBER,
	p_PROFILE_SOURCE_BEGIN_DATE OUT DATE,
	p_PROFILE_SOURCE_END_DATE OUT DATE,
	p_PROFILE_SOURCE_ID OUT NUMBER,
	p_PROFILE_INTERVAL OUT NUMBER,
	p_PROFILE_SOURCE_VERSION OUT DATE,
	p_PROFILE_BREAKPOINT_INTERVAL OUT VARCHAR2,
	p_IS_EXTERNAL_PROFILE OUT NUMBER
	) AS
    v_PROFILE_ACCOUNT_REF LOAD_PROFILE.PROFILE_ACCOUNT_REF%TYPE;
BEGIN
    IO.GET_LOAD_PROFILE(p_PROFILE_LIBRARY_ID          => p_PROFILE_LIBRARY_ID,
                        p_PROFILE_ID                  => p_PROFILE_ID,
                        p_PROFILE_NAME                => p_PROFILE_NAME,
                        p_PROFILE_ALIAS               => p_PROFILE_ALIAS,
                        p_PROFILE_DESC                => p_PROFILE_DESC,
                        p_PROFILE_TYPE                => p_PROFILE_TYPE,
                        p_PROFILE_OPERATION           => p_PROFILE_OPERATION,
                        p_PROFILE_ORIGIN              => p_PROFILE_ORIGIN,
                        p_PROFILE_RATE_CLASS          => p_PROFILE_RATE_CLASS,
                        p_PROFILE_DAY_TYPE            => p_PROFILE_DAY_TYPE,
                        p_PROFILE_ACCOUNT_REF         => v_PROFILE_ACCOUNT_REF,
                        p_PROFILE_METER_REF           => p_PROFILE_METER_REF,
                        p_PROFILE_SIC_CODE            => p_PROFILE_SIC_CODE,
                        p_PROFILE_SEASON              => p_PROFILE_SEASON,
                        p_PROFILE_SYSTEM_LOAD         => p_PROFILE_SYSTEM_LOAD,
                        p_PROFILE_ADJUSTMENT_OPTION   => p_PROFILE_ADJUSTMENT_OPTION,
                        p_PROFILE_STATION_ID          => p_PROFILE_STATION_ID,
                        p_PROFILE_TEMPLATE_ID         => p_PROFILE_TEMPLATE_ID,
                        p_PROFILE_SOURCE_BEGIN_DATE   => p_PROFILE_SOURCE_BEGIN_DATE,
                        p_PROFILE_SOURCE_END_DATE     => p_PROFILE_SOURCE_END_DATE,
                        p_PROFILE_SOURCE_ID           => p_PROFILE_SOURCE_ID,
                        p_PROFILE_INTERVAL            => p_PROFILE_INTERVAL,
                        p_PROFILE_SOURCE_VERSION      => p_PROFILE_SOURCE_VERSION,
                        p_PROFILE_BREAKPOINT_INTERVAL => p_PROFILE_BREAKPOINT_INTERVAL,
                        p_IS_EXTERNAL_PROFILE         => p_IS_EXTERNAL_PROFILE);
                        
    IF v_PROFILE_ACCOUNT_REF = GA.UNDEFINED_ATTRIBUTE OR v_PROFILE_ACCOUNT_REF IS NULL THEN
        p_PROFILE_ACCOUNT_ID := NULL;
    ELSE
        p_PROFILE_ACCOUNT_ID := TO_NUMBER(v_PROFILE_ACCOUNT_REF);
        
        BEGIN
            SELECT A.ACCOUNT_MODEL_OPTION
            INTO p_PROFILE_ACCT_MODEL_OPT
            FROM ACCOUNT A
            WHERE A.ACCOUNT_ID = p_PROFILE_ACCOUNT_ID;
        EXCEPTION WHEN NO_DATA_FOUND THEN
            -- this exception would occur when an account reference on a load profile
            -- refers to an account that no longer exists; in this case, null out the account reference
            PUT_LOAD_PROFILE_ACCT_ID(p_PROFILE_ID, NULL);
            p_PROFILE_ACCOUNT_ID := NULL;
        END;
    END IF;
    
    IF p_PROFILE_OPERATION = GA.UNDEFINED_ATTRIBUTE OR p_PROFILE_OPERATION IS NULL THEN
        p_PROFILE_OPERATION := EM.g_SPACE_OPT;
    END IF;
END GET_LOAD_PROFILE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_LOAD_PROFILE
	(
	o_OID OUT NUMBER,
    p_PROFILE_ID IN NUMBER,
	p_PROFILE_NAME IN VARCHAR2,
	p_PROFILE_ALIAS IN VARCHAR2,
	p_PROFILE_DESC IN VARCHAR2,
    p_PROFILE_TYPE IN VARCHAR2,
    p_PROFILE_OPERATION IN VARCHAR2,
    p_PROFILE_ORIGIN IN VARCHAR2,
    p_PROFILE_RATE_CLASS IN VARCHAR2,
    p_PROFILE_ADJUSTMENT_OPTION IN VARCHAR2,
	p_IS_EXTERNAL_PROFILE IN NUMBER
    ) AS
    v_REC LOAD_PROFILE%ROWTYPE;
BEGIN
    v_REC.PROFILE_LIBRARY_ID := CONSTANTS.NOT_ASSIGNED;
    v_REC.PROFILE_ID := p_PROFILE_ID;
	v_REC.PROFILE_NAME := TRIM(p_PROFILE_NAME);
	v_REC.PROFILE_ALIAS := TRIM(NVL(p_PROFILE_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PROFILE_DESC := TRIM(NVL(p_PROFILE_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
    v_REC.PROFILE_TYPE := TRIM(NVL(p_PROFILE_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
    IF p_PROFILE_OPERATION = '<html>&nbsp;</html>' THEN
        v_REC.PROFILE_OPERATION := CONSTANTS.UNDEFINED_ATTRIBUTE;
    ELSE
        v_REC.PROFILE_OPERATION := p_PROFILE_OPERATION;
    END IF;
    v_REC.PROFILE_ORIGIN := TRIM(NVL(p_PROFILE_ORIGIN,CONSTANTS.UNDEFINED_ATTRIBUTE));
    v_REC.PROFILE_RATE_CLASS := TRIM(NVL(p_PROFILE_RATE_CLASS,CONSTANTS.UNDEFINED_ATTRIBUTE));
    v_REC.PROFILE_ADJUSTMENT_OPTION := TRIM(NVL(p_PROFILE_ADJUSTMENT_OPTION,CONSTANTS.UNDEFINED_ATTRIBUTE));
    v_REC.IS_EXTERNAL_PROFILE := p_IS_EXTERNAL_PROFILE;
    v_REC.ENTRY_DATE := SYSDATE;

	IF p_PROFILE_ID > 0 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_PROFILE_ID, EC.ED_LOAD_PROFILE) 
                 AND IO_UTIL.LOAD_PROFILE_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_LOAD_PROFILE, p_PROFILE_ID);
		END IF;
        
        UPDATE LOAD_PROFILE LP
        SET LP.PROFILE_NAME = v_REC.PROFILE_NAME,
            LP.PROFILE_ALIAS = v_REC.PROFILE_ALIAS,
            LP.PROFILE_DESC = v_REC.PROFILE_DESC,
            LP.PROFILE_TYPE = v_REC.PROFILE_TYPE,
            LP.PROFILE_OPERATION = v_REC.PROFILE_OPERATION,
            LP.PROFILE_ORIGIN = v_REC.PROFILE_ORIGIN,
            LP.PROFILE_RATE_CLASS = v_REC.PROFILE_RATE_CLASS,
            LP.PROFILE_ADJUSTMENT_OPTION = v_REC.PROFILE_ADJUSTMENT_OPTION,
            LP.IS_EXTERNAL_PROFILE = v_REC.IS_EXTERNAL_PROFILE
        WHERE LP.PROFILE_ID = p_PROFILE_ID;
            
        o_OID := p_PROFILE_ID;
        
	ELSIF p_PROFILE_ID IS NULL OR p_PROFILE_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.LOAD_PROFILE_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_LOAD_PROFILE, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.PROFILE_ID := o_OID;
		-- save it!
		INSERT INTO LOAD_PROFILE VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_PROFILE_ID;
        
    END IF;
END PUT_LOAD_PROFILE;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_LOAD_PROFILE_ACCT_ID
    (
    p_PROFILE_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
    v_PROFILE_EXISTS NUMBER(1);
    v_PROFILE_ACCOUNT_REF LOAD_PROFILE.PROFILE_ACCOUNT_REF%TYPE;
BEGIN
    SELECT COUNT(1)
    INTO v_PROFILE_EXISTS
    FROM LOAD_PROFILE LP
    WHERE LP.PROFILE_ID = p_PROFILE_ID;
    
    IF v_PROFILE_EXISTS = 0 THEN
        OPEN p_CURSOR FOR
        SELECT NULL AS PROFILE_ACCOUNT_ID
        FROM DUAL;
    ELSE
        SELECT LP.PROFILE_ACCOUNT_REF
        INTO v_PROFILE_ACCOUNT_REF
        FROM LOAD_PROFILE LP    
        WHERE LP.PROFILE_ID = p_PROFILE_ID;
        
        IF v_PROFILE_ACCOUNT_REF = CONSTANTS.UNDEFINED_ATTRIBUTE OR v_PROFILE_ACCOUNT_REF IS NULL THEN
            OPEN p_CURSOR FOR
            SELECT NULL AS PROFILE_ACCOUNT_ID
            FROM DUAL;
        ELSE
            OPEN p_CURSOR FOR
            SELECT TO_NUMBER(v_PROFILE_ACCOUNT_REF) AS PROFILE_ACCOUNT_ID
            FROM DUAL;
        END IF;
    END IF;
END GET_LOAD_PROFILE_ACCT_ID;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_LOAD_PROFILE_ACCT_ID
    (
    p_PROFILE_ID IN NUMBER,
    p_PROFILE_ACCOUNT_ID IN NUMBER
    ) AS
    v_PROFILE_ACCOUNT_REF LOAD_PROFILE.PROFILE_ACCOUNT_REF%TYPE;
BEGIN
    IF p_PROFILE_ACCOUNT_ID IS NULL THEN
        v_PROFILE_ACCOUNT_REF := CONSTANTS.UNDEFINED_ATTRIBUTE;
    ELSE
        v_PROFILE_ACCOUNT_REF := TO_CHAR(p_PROFILE_ACCOUNT_ID);
    END IF;

    UPDATE LOAD_PROFILE LP
    SET LP.PROFILE_ACCOUNT_REF = v_PROFILE_ACCOUNT_REF,
        LP.PROFILE_METER_REF = NULL
    WHERE LP.PROFILE_ID = p_PROFILE_ID;
END PUT_LOAD_PROFILE_ACCT_ID;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_LOAD_PROFILE_METER_ID
    (
    p_PROFILE_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
    v_PROFILE_EXISTS NUMBER(1);
    v_PROFILE_METER_REF LOAD_PROFILE.PROFILE_METER_REF%TYPE;
BEGIN
    SELECT COUNT(1)
    INTO v_PROFILE_EXISTS
    FROM LOAD_PROFILE LP
    WHERE LP.PROFILE_ID = p_PROFILE_ID;
    
    IF v_PROFILE_EXISTS = 0 THEN
        OPEN p_CURSOR FOR
        SELECT NULL AS METER_ID
        FROM DUAL;
    ELSE
        SELECT LP.PROFILE_METER_REF
        INTO v_PROFILE_METER_REF
        FROM LOAD_PROFILE LP    
        WHERE LP.PROFILE_ID = p_PROFILE_ID;
        
        IF v_PROFILE_METER_REF = CONSTANTS.UNDEFINED_ATTRIBUTE OR v_PROFILE_METER_REF IS NULL THEN
            OPEN p_CURSOR FOR
            SELECT NULL AS METER_ID
            FROM DUAL;
        ELSE
            OPEN p_CURSOR FOR
            SELECT TO_NUMBER(v_PROFILE_METER_REF) AS METER_ID
            FROM DUAL;
        END IF;
    END IF;
END GET_LOAD_PROFILE_METER_ID;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_LOAD_PROFILE_METER_ID
    (
    p_PROFILE_ID IN NUMBER,
    p_METER_ID IN NUMBER
    ) AS
    v_PROFILE_METER_REF LOAD_PROFILE.PROFILE_METER_REF%TYPE;
BEGIN
    IF p_METER_ID IS NULL THEN
        v_PROFILE_METER_REF := CONSTANTS.UNDEFINED_ATTRIBUTE;
    ELSE
        v_PROFILE_METER_REF := TO_CHAR(p_METER_ID);
    END IF;

    UPDATE LOAD_PROFILE LP
    SET LP.PROFILE_METER_REF = v_PROFILE_METER_REF
    WHERE LP.PROFILE_ID = p_PROFILE_ID;
END PUT_LOAD_PROFILE_METER_ID;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_METERS_FOR_ACCOUNT
    (
    p_ACCOUNT_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
    OPEN p_CURSOR FOR
    SELECT M.METER_ID,
           M.METER_NAME
    FROM ACCOUNT_SERVICE_LOCATION ASL,
         SERVICE_LOCATION_METER SLM,
         METER M
    WHERE ASL.ACCOUNT_ID = p_ACCOUNT_ID
      AND ASL.SERVICE_LOCATION_ID = SLM.SERVICE_LOCATION_ID
      AND SLM.METER_ID = M.METER_ID
    ORDER BY METER_NAME;
END GET_METERS_FOR_ACCOUNT;
----------------------------------------------------------------------------------------------------
END EM;
/
