CREATE OR REPLACE PACKAGE DEMAND_RESPONSE IS
-- $Revision: 1.9 $

TYPE t_VPP_SCHEDULE IS RECORD (
	CUT_DATE		DATE,
	SCHEDULE_DAY	VARCHAR2(10),
	SCHEDULE_TIME	VARCHAR2(8),
	VPP_ID			NUMBER(9),
	VPP_NAME		VIRTUAL_POWER_PLANT.VPP_NAME%TYPE,
	VPP_ALIAS		VIRTUAL_POWER_PLANT.VPP_ALIAS%TYPE,
	RESULT_TYPE		VARCHAR2(32),
	RESULT_TYPE_DISP VARCHAR2(32),
	NEW_AMOUNT		NUMBER,
	CURRENT_AMOUNT 	NUMBER
);

TYPE t_cur_VPP_SCHEDULE IS REF CURSOR RETURN t_VPP_SCHEDULE;

c_RESULT_TYPE_FORECAST CONSTANT VARCHAR2(32) := 		'Forecast';
c_RESULT_TYPE_BACKCAST CONSTANT VARCHAR2(32) := 		'Backcast';
c_RESULT_TYPE_UNCONSTRAINED CONSTANT VARCHAR(32) :=		'Unconstrained';

c_OPENADR_EVENT_PRIORITY CONSTANT VARCHAR(32) :=		'Event Priority';
c_OPENADR_SIGNAL_TYPE CONSTANT VARCHAR(32) :=		    'Signal Type';
c_OPENADR_SIGNAL_NAME CONSTANT VARCHAR(32) :=		    'Signal Name';
c_OPENADR_RESPONSE_REQUIRED CONSTANT VARCHAR(32) :=		'Response Required';
c_OPENADR_SIGNAL_UNIT CONSTANT VARCHAR(32) :=		'Signal Unit';
c_OPENADR_SIGNAL_UNIT_DESC CONSTANT VARCHAR(32) :=		'Signal Unit Description';

FUNCTION WHAT_VERSION RETURN VARCHAR2;

PROCEDURE CREATE_EVENT
	(
	p_VPP_ID           IN NUMBER,
	p_START_TIME       IN DATE,
	p_STOP_TIME        IN DATE,
	p_EVENT_TYPE       IN VARCHAR2,
	p_EVENT_DESC       IN VARCHAR2,
	p_SCHEDULE_DATES   IN DATE_COLLECTION,
	p_SCHEDULE_AMOUNTS IN NUMBER_COLLECTION,
	p_SCHEDULE_PRICES  IN NUMBER_COLLECTION,
	p_EVENT_ID         OUT NUMBER,
	p_SUCCESS_COUNT    OUT BINARY_INTEGER,
	p_FAIL_COUNT       OUT BINARY_INTEGER
	);

PROCEDURE PUT_EVENT
	(
	p_EVENT_ID IN OUT NUMBER,
	p_EVENT_NAME IN VARCHAR2,
	p_VPP_ID IN NUMBER,
	p_EVENT_STATUS IN VARCHAR2,
	p_START_TIME IN DATE,
	p_STOP_TIME IN DATE,
	p_EVENT_TYPE IN VARCHAR2,
	p_EVENT_ALIAS IN VARCHAR2,
	p_EVENT_DESC IN VARCHAR2
	);

PROCEDURE PUT_EVENT_INTERVAL_DATA
	(
	p_EVENT_ID         IN NUMBER,
	p_START_TIME       IN DATE,
	p_STOP_TIME        IN DATE,
	p_SCHEDULE_DATES   IN DATE_COLLECTION,
	p_SCHEDULE_AMOUNTS IN NUMBER_COLLECTION,
	p_SCHEDULE_PRICES  IN NUMBER_COLLECTION
	);

PROCEDURE UPDATE_EVENT
	(
	p_EVENT_ID         IN NUMBER,
	p_START_TIME       IN DATE,
	p_STOP_TIME        IN DATE,
	p_EVENT_TYPE       IN VARCHAR2,
	p_EVENT_DESC       IN VARCHAR2,
	p_SCHEDULE_DATES   IN DATE_COLLECTION,
	p_SCHEDULE_AMOUNTS IN NUMBER_COLLECTION,
	p_SCHEDULE_PRICES  IN NUMBER_COLLECTION,
	p_SUCCESS_COUNT    OUT BINARY_INTEGER,
	p_FAIL_COUNT       OUT BINARY_INTEGER
	);

PROCEDURE SUBMIT_EVENT
	(
	p_EVENT_ID IN NUMBER,
	p_MESSAGE OUT VARCHAR2,
	p_SUCCESS_COUNT OUT BINARY_INTEGER,
	p_FAIL_COUNT OUT BINARY_INTEGER
	);

PROCEDURE UPDATE_EVENT_STATUS
	(
	p_EVENT_ID IN NUMBER,
	p_EVENT_STATUS IN VARCHAR2
	);

PROCEDURE START_EVENT
	(
	p_EVENT_ID           IN NUMBER,
	p_EXTERNAL_SYSTEM_ID IN NUMBER
	);

PROCEDURE CONFIRM_EVENT
	(
	p_EVENT_ID           IN NUMBER,
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_DER_OPTOUT_IDS     IN NUMBER_COLLECTION,
	p_DER_OPTOUT_DATES   IN DATE_COLLECTION
	);

PROCEDURE CANCEL_EVENT
	(
	p_EVENT_ID IN NUMBER,
	p_SUCCESS_COUNT OUT BINARY_INTEGER,
	p_FAIL_COUNT OUT BINARY_INTEGER
	);

PROCEDURE STOP_ALL_EVENTS;

PROCEDURE RESUME_ALL_EVENTS;

PROCEDURE IMPORT_EVENT_REDUCTION
	(
	p_EVENT_ID           IN NUMBER,
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_FEEDER_SEGMENT_IDS IN NUMBER_COLLECTION,
	p_SCHEDULE_DATES     IN DATE_COLLECTION_COLLECTION,
	p_SCHEDULE_AMOUNTS   IN NUMBER_COLLECTION_COLLECTION
	);

PROCEDURE IMPORT_PREMISE_RESULTS
	(
	p_EVENT_ID             IN NUMBER,
	p_EXTERNAL_SYSTEM_ID   IN NUMBER,
	p_PREMISE_IDS          IN NUMBER_COLLECTION,
	p_DER_TYPE_IDS         IN NUMBER_COLLECTION,
	p_OPTOUT_DATES         IN DATE_COLLECTION,
	p_OVERRIDE_DATES 	   IN DATE_COLLECTION,
	p_FAILURES             IN NUMBER_COLLECTION,
	p_SCHEDULE_DATES       IN DATE_COLLECTION_COLLECTION,
	p_SCHEDULE_AMOUNTS     IN NUMBER_COLLECTION_COLLECTION
	);

PROCEDURE IMPORT_DER_RESULTS
	(
	p_EVENT_ID             IN NUMBER,
	p_EXTERNAL_SYSTEM_ID   IN NUMBER,
	p_DER_IDS              IN NUMBER_COLLECTION,
	p_DER_IS_OVERRIDE_DATE IN DATE_COLLECTION,
	p_DER_IS_FAILURE_DATE  IN DATE_COLLECTION,
	p_SCHEDULE_DATES       IN DATE_COLLECTION_COLLECTION,
	p_SCHEDULE_AMOUNTS     IN NUMBER_COLLECTION_COLLECTION
	);

PROCEDURE IMPORT_DERMS_FORECAST
	(
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_PROGRAM_ID         IN NUMBER,
	p_FEEDER_SEGMENT_IDS IN NUMBER_COLLECTION,
	p_DATES              IN DATE_COLLECTION_COLLECTION,
	p_AVAILABILTY        IN NUMBER_COLLECTION_COLLECTION,
	p_CAPABILITY         IN NUMBER_COLLECTION_COLLECTION,
	p_DER_COUNT          IN NUMBER_COLLECTION_COLLECTION
	);

PROCEDURE IMPORT_FEEDER_SEGMENT_PRIORITY
	(
	p_FEEDER_SEGMENT_IDS IN NUMBER_COLLECTION,
	p_PRIORITIES         IN NUMBER_COLLECTION
	);

PROCEDURE CHECK_VPP_ALIASES
	(
	p_VPP_IDS IN NUMBER_COLLECTION,
	p_INCLUDE_ALL IN NUMBER
	);

PROCEDURE VPP_SCHEDULES
	(
	p_VPP_IDs IN NUMBER_COLLECTION,
	p_CUT_BEGIN_DATE IN DATE,
	p_CUT_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SCHEDULE_UNIT OUT VARCHAR2,
	p_CURSOR OUT t_cur_VPP_SCHEDULE,
	p_SERVICE_CODE IN CHAR := 'F',
	p_IS_EXTERNAL IN NUMBER := 0
	);

PROCEDURE ACCEPT_VPPS_INTO_SCHEDULES
	(
	p_CUT_BEGIN_DATE IN DATE,
	p_CUT_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SERVICE_CODE IN CHAR := 'F',
	p_IS_EXTERNAL IN NUMBER := 0,
	p_VPP_IDs IN NUMBER_COLLECTION := NUMBER_COLLECTION(-1)
	);

END DEMAND_RESPONSE;
/
CREATE OR REPLACE PACKAGE BODY DEMAND_RESPONSE IS
--------------------------------------------------------------------------------
c_TEMP_TABLE_HITS CONSTANT VARCHAR2(32) := 'TEMP_PROGRAM_HITS_LIST';
c_NEW_EVENT_STATUS CONSTANT VARCHAR2(3) := 'New';

-- PRIVATE Procedures and Functions
--------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR2 IS
BEGIN
    RETURN '$Revision: 1.9 $';
END WHAT_VERSION;
---------------------------------------------------------------------------------------------------
FUNCTION GET_DER
	(
	p_EVENT_ID IN NUMBER,
	p_PROGRAM_ID IN NUMBER,
	p_PREMISE_ID IN NUMBER,
	p_DER_TYPE_ID IN NUMBER
	) RETURN NUMBER AS
v_DER_ID DISTRIBUTED_ENERGY_RESOURCE.DER_ID%TYPE;
BEGIN
	-- Lookup the DER for this DER_TYPE and SERVICE_LOCATION

	SELECT MAX(D.DER_ID)
	INTO v_DER_ID
	FROM DISTRIBUTED_ENERGY_RESOURCE D,
	     DR_EVENT E,
		 DER_PROGRAM P
	WHERE D.SERVICE_LOCATION_ID = p_PREMISE_ID
	  AND D.DER_ID = P.DER_ID
	  AND E.START_TIME BETWEEN P.BEGIN_DATE AND NVL(P.END_DATE,CONSTANTS.HIGH_DATE)
	  AND P.PROGRAM_ID = p_PROGRAM_ID
	  AND D.DER_TYPE_ID = p_DER_TYPE_ID
	  AND E.START_TIME BETWEEN D.BEGIN_DATE AND NVL(D.END_DATE,CONSTANTS.HIGH_DATE)
	  AND E.EVENT_ID = p_EVENT_ID
	ORDER BY D.DER_ID;

	IF v_DER_ID IS NULL THEN
		LOGS.LOG_WARN('Could not find a DER enrolled in the Program. Attempting to find any DER. No Device found for ' ||
			'Event = ' || TEXT_UTIL.TO_CHAR_ENTITY(p_EVENT_ID, EC.ED_DR_EVENT, TRUE) || ', ' ||
			'DER Type = ' || TEXT_UTIL.TO_CHAR_ENTITY(p_DER_TYPE_ID, EC.ED_DER_TYPE, TRUE) || ', ' ||
			'Program = ' || TEXT_UTIL.TO_CHAR_ENTITY(p_PROGRAM_ID, EC.ED_PROGRAM, TRUE) || ', ' ||
			'Premise = ' || TEXT_UTIL.TO_CHAR_ENTITY(p_PREMISE_ID, EC.ED_SERVICE_LOCATION, TRUE));

		SELECT MAX(D.DER_ID)
		INTO v_DER_ID
		FROM DISTRIBUTED_ENERGY_RESOURCE D,
			 DR_EVENT E
		WHERE D.SERVICE_LOCATION_ID = p_PREMISE_ID
		  AND D.DER_TYPE_ID = p_DER_TYPE_ID
		  AND E.START_TIME BETWEEN D.BEGIN_DATE AND NVL(D.END_DATE,CONSTANTS.HIGH_DATE)
		  AND E.EVENT_ID = p_EVENT_ID
		ORDER BY D.DER_ID;
	END IF;

	RETURN v_DER_ID;
END GET_DER;
----------------------------------------------------------------------------------------------------
FUNCTION GET_EVENT_INTERVAL
	(
	p_EVENT_ID IN NUMBER
	) RETURN VARCHAR2 IS
v_PROGRAM_INTERVAL PROGRAM.PROGRAM_INTERVAL%TYPE;
BEGIN

	SELECT NVL(MAX(P.PROGRAM_INTERVAL), '15 MINUTE')
	INTO v_PROGRAM_INTERVAL
	FROM DR_EVENT E, VPP V, PROGRAM P
	WHERE V.PROGRAM_ID = P.PROGRAM_ID
	  AND E.VPP_ID = V.VPP_ID
	  AND E.EVENT_ID = p_EVENT_ID;

	RETURN v_PROGRAM_INTERVAL;

END GET_EVENT_INTERVAL;
--------------------------------------------------------------------------------
PROCEDURE PUT_EVENT_PARTICIPATION
	(
	p_EVENT_ID IN NUMBER,
	p_DER_ID IN NUMBER
	) AS
BEGIN
	-- Update the DR_EVENT_PARTICIPATION table
	INSERT INTO DR_EVENT_PARTICIPATION (EVENT_ID, DER_ID, ENTRY_DATE)
	VALUES (p_EVENT_ID, p_DER_ID, SYSDATE);
EXCEPTION
	WHEN DUP_VAL_ON_INDEX THEN
		ERRS.LOG_AND_CONTINUE('The Device already participated in this event. (EVENT_ID = '
			|| p_EVENT_ID || ', DER_ID = ' || p_DER_ID || ')', LOGS.c_LEVEL_DEBUG);
		UPDATE DR_EVENT_PARTICIPATION
		SET ENTRY_DATE = SYSDATE
		WHERE EVENT_ID = p_EVENT_ID
		AND DER_ID = p_DER_ID;
END PUT_EVENT_PARTICIPATION;
--------------------------------------------------------------------------------
PROCEDURE PUT_EVENT_EXCEPTION
	(
	p_EVENT_ID       IN NUMBER,
	p_DER_ID         IN NUMBER,
	p_EXCEPTION_TYPE IN VARCHAR2,
	p_EXCEPTION_DATE IN DATE
	) AS
v_CURRENT_EXCEPTION_DATE DATE;
BEGIN
-- First check to see if an exception already exists
	SELECT MIN(EXCEPTION_DATE)
	INTO v_CURRENT_EXCEPTION_DATE
	FROM DR_EVENT_EXCEPTION
	WHERE EVENT_ID = p_EVENT_ID
	AND DER_ID = p_DER_ID;

-- Insert or Update the DR_EVENT_EXCEPTION table
	IF v_CURRENT_EXCEPTION_DATE IS NULL THEN
		INSERT INTO DR_EVENT_EXCEPTION
			(EVENT_ID, DER_ID, EXCEPTION_TYPE, EXCEPTION_DATE, ENTRY_DATE)
		VALUES
			(p_EVENT_ID, p_DER_ID, p_EXCEPTION_TYPE, p_EXCEPTION_DATE, SYSDATE);
	ELSIF v_CURRENT_EXCEPTION_DATE > p_EXCEPTION_DATE THEN
		UPDATE DR_EVENT_EXCEPTION
		SET EXCEPTION_TYPE = p_EXCEPTION_TYPE,
			EXCEPTION_DATE = p_EXCEPTION_DATE,
			ENTRY_DATE     = SYSDATE
		WHERE EVENT_ID = p_EVENT_ID
			  AND DER_ID = p_DER_ID;
	END IF;

END PUT_EVENT_EXCEPTION;
--------------------------------------------------------------------------------
PROCEDURE UPDATE_DEVICE_HISTORY
	(
	p_EVENT_ID IN NUMBER
	) AS
v_NUM_EVENTS_TO_KEEP NUMBER(9);
v_TOTAL_HISTORY_RECORDS NUMBER(9);
BEGIN
	-- Get the limit for the number of events retain
	v_NUM_EVENTS_TO_KEEP := GET_DICTIONARY_VALUE('Num Events for Running Rate', 0, 'Load Management', 'Demand Response');

	-- Remove all existing history for this Event
	DELETE FROM DER_TYPE_HISTORY H WHERE H.EVENT_ID = p_EVENT_ID;

	-- Update the Total Signalled and Total Failed for each Device Type
	MERGE INTO DER_TYPE_HISTORY T
	USING (SELECT A.EVENT_ID,
				  A.DER_TYPE_ID,
				  SUM(A.TOTAL_FAILED) AS TOTAL_FAILED,
				  SUM(A.TOTAL_SIGNALED) AS TOTAL_SIGNALED
			FROM (SELECT X.EVENT_ID,
						 D.DER_ID,
						 D.DER_NAME,
						 D.DER_TYPE_ID,
						 CASE WHEN D.DER_ID IS NOT NULL THEN 1 ELSE 0 END AS TOTAL_FAILED,
						 0 AS TOTAL_SIGNALED
				  FROM DR_EVENT_EXCEPTION X, DISTRIBUTED_ENERGY_RESOURCE D
				  WHERE X.DER_ID = D.DER_ID
				  AND X.EVENT_ID = p_EVENT_ID
				  AND X.EXCEPTION_TYPE = DEMAND_RESPONSE_UTIL.c_EXCEPTION_TYPE_FAILURE
				  UNION ALL
				  SELECT P.EVENT_ID,
						   D.DER_ID,
						   D.DER_NAME,
						   D.DER_TYPE_ID,
						   0 AS TOTAL_FAILED,
						   CASE WHEN P.DER_ID IS NOT NULL THEN 1 ELSE 0 END AS TOTAL_SIGNALED
				  FROM DR_EVENT_PARTICIPATION P, DISTRIBUTED_ENERGY_RESOURCE D
				  WHERE P.DER_ID = D.DER_ID
				  AND P.EVENT_ID = p_EVENT_ID) A
			GROUP BY EVENT_ID, DER_TYPE_ID) S
	ON (T.DER_TYPE_ID = S.DER_TYPE_ID AND T.EVENT_ID = S.EVENT_ID)
	WHEN MATCHED
	THEN
	UPDATE
	SET T.TOTAL_FAILED = S.TOTAL_FAILED,
	    T.TOTAL_SIGNALED = S.TOTAL_SIGNALED
	WHEN NOT MATCHED
	THEN
	INSERT (T.DER_TYPE_ID, T.EVENT_ID, T.TOTAL_FAILED, T.TOTAL_SIGNALED)
	VALUES (S.DER_TYPE_ID, S.EVENT_ID, S.TOTAL_FAILED, S.TOTAL_SIGNALED);

	-- Get the total number of records in the DER_TYPE_HISTORY table
	SELECT DISTINCT COUNT(EVENT_ID)
	INTO v_TOTAL_HISTORY_RECORDS
	FROM DER_TYPE_HISTORY;

	-- Clean up the DER_TYPE_HISTORY table
	DELETE FROM DER_TYPE_HISTORY H
	WHERE H.EVENT_ID IN (SELECT A.EVENT_ID
						 FROM (SELECT D.EVENT_ID, E.STOP_TIME
      						   FROM DER_TYPE_HISTORY D,
							        DR_EVENT E
							   WHERE E.EVENT_ID (+) = D.EVENT_ID
	  						   ORDER BY STOP_TIME ASC) A
						 WHERE ROWNUM <= (v_TOTAL_HISTORY_RECORDS - v_NUM_EVENTS_TO_KEEP));

END UPDATE_DEVICE_HISTORY;
--------------------------------------------------------------------------------
FUNCTION GET_PROGRAM_FOR_EVENT
	(
	p_EVENT_ID IN NUMBER
	) RETURN NUMBER AS
v_PROGRAM_ID PROGRAM.PROGRAM_ID%TYPE;
BEGIN
	SELECT V.PROGRAM_ID
	INTO v_PROGRAM_ID
	FROM DR_EVENT E, VPP V
	WHERE E.VPP_ID = V.VPP_ID
	  AND E.EVENT_ID = p_EVENT_ID;

	RETURN v_PROGRAM_ID;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'Program Id for ' || TEXT_UTIL.TO_CHAR_ENTITY(p_EVENT_ID, EC.ED_DR_EVENT, TRUE), TRUE);
END GET_PROGRAM_FOR_EVENT;
--------------------------------------------------------------------------------
PROCEDURE UPDATE_PROGRAM_HISTORY
	(
	p_EVENT_ID IN NUMBER
	) AS
v_NUM_EVENTS_TO_KEEP NUMBER(9);
v_TOTAL_HISTORY_RECORDS NUMBER(9);
v_PROGRAM_ID PROGRAM.PROGRAM_ID%TYPE;
BEGIN
	-- Get the limit for the number of events retain
	v_NUM_EVENTS_TO_KEEP := GET_DICTIONARY_VALUE('Num Events for Running Rate', 0, 'Load Management', 'Demand Response');

	v_PROGRAM_ID := GET_PROGRAM_FOR_EVENT(p_EVENT_ID);

	-- Remove all existing history for this Event
	DELETE FROM PROGRAM_EVENT_HISTORY H
	WHERE H.EVENT_ID = p_EVENT_ID
	  AND H.PROGRAM_ID = v_PROGRAM_ID;

	-- Update the Total Signalled and Total Failed for each Device Type
	MERGE INTO PROGRAM_EVENT_HISTORY T
	USING (SELECT A.EVENT_ID,
	              v_PROGRAM_ID AS PROGRAM_ID,
				  SUM(A.TOTAL_OVERRIDES) AS TOTAL_OVERRIDES,
				  SUM(A.TOTAL_OPT_OUTS) AS TOTAL_OPT_OUTS,
				  SUM(A.TOTAL_SIGNALED) AS TOTAL_SIGNALED
		   FROM (SELECT X.EVENT_ID,
		                CASE WHEN X.EXCEPTION_TYPE = DEMAND_RESPONSE_UTIL.c_EXCEPTION_TYPE_OVERRIDE THEN 1 ELSE 0 END AS TOTAL_OVERRIDES,
		                CASE WHEN X.EXCEPTION_TYPE = DEMAND_RESPONSE_UTIL.c_EXCEPTION_TYPE_OPTOUT THEN 1 ELSE 0 END AS TOTAL_OPT_OUTS,
		                0 TOTAL_SIGNALED
		         FROM DR_EVENT_EXCEPTION X
		         WHERE X.EXCEPTION_TYPE IN (DEMAND_RESPONSE_UTIL.c_EXCEPTION_TYPE_OVERRIDE, DEMAND_RESPONSE_UTIL.c_EXCEPTION_TYPE_OPTOUT)
		           AND X.EVENT_ID = p_EVENT_ID
		         UNION ALL
		         SELECT P.EVENT_ID,
		                0 AS TOTAL_OVERRIDES,
		                0 AS TOTAL_OPT_OUTS,
		                CASE WHEN P.EVENT_ID IS NOT NULL THEN 1 ELSE 0 END AS TOTAL_SIGNALED
		         FROM DR_EVENT_PARTICIPATION P
		         WHERE P.EVENT_ID = p_EVENT_ID) A
		   GROUP BY A.EVENT_ID, v_PROGRAM_ID) S
	ON (T.PROGRAM_ID = S.PROGRAM_ID AND T.EVENT_ID = S.EVENT_ID)
	WHEN MATCHED
	THEN
	UPDATE
	SET T.TOTAL_OVERRIDES = S.TOTAL_OVERRIDES,
		T.TOTAL_OPT_OUTS = S.TOTAL_OPT_OUTS,
	    T.TOTAL_SIGNALED = S.TOTAL_SIGNALED
	WHEN NOT MATCHED
	THEN
	INSERT (T.PROGRAM_ID, T.EVENT_ID, T.TOTAL_OVERRIDES, T.TOTAL_OPT_OUTS, T.TOTAL_SIGNALED)
	VALUES (S.PROGRAM_ID, S.EVENT_ID, S.TOTAL_OVERRIDES, S.TOTAL_OPT_OUTS, S.TOTAL_SIGNALED);

	-- Get the total number of records in the DER_TYPE_HISTORY table
	SELECT DISTINCT COUNT(EVENT_ID)
	INTO v_TOTAL_HISTORY_RECORDS
	FROM PROGRAM_EVENT_HISTORY;

	-- Clean up the DER_TYPE_HISTORY table
	DELETE FROM PROGRAM_EVENT_HISTORY H
	WHERE H.EVENT_ID IN (SELECT A.EVENT_ID
						 FROM (SELECT H.EVENT_ID, E.STOP_TIME
      						   FROM PROGRAM_EVENT_HISTORY H,
							        DR_EVENT E
							   WHERE E.EVENT_ID (+) = H.EVENT_ID
	  						   ORDER BY STOP_TIME ASC) A
						 WHERE ROWNUM <= (v_TOTAL_HISTORY_RECORDS - v_NUM_EVENTS_TO_KEEP));

END UPDATE_PROGRAM_HISTORY;
-------------------------------------------------------------------------------
PROCEDURE UPDATE_EVENT_STATUS
	(
	p_EVENT_ID IN NUMBER,
	p_EVENT_STATUS IN VARCHAR2
	) AS
v_DR_EVENT_REC DR_EVENT%ROWTYPE;
v_EVENT_ID DR_EVENT.EVENT_ID%TYPE := p_EVENT_ID;
BEGIN
	-- Get the original Event data
	IO.GET_DR_EVENT(v_EVENT_ID,
		v_DR_EVENT_REC.EVENT_NAME,
		v_DR_EVENT_REC.EVENT_ALIAS,
		v_DR_EVENT_REC.EVENT_DESC,
		v_DR_EVENT_REC.VPP_ID,
		v_DR_EVENT_REC.EVENT_STATUS,
		v_DR_EVENT_REC.START_TIME,
		v_DR_EVENT_REC.STOP_TIME,
		v_DR_EVENT_REC.EVENT_TYPE);

	IF TRIM(v_DR_EVENT_REC.EVENT_NAME) IS NULL THEN
		ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY,'Event Id = [' || NVL(TO_CHAR(p_EVENT_ID), 'NULL') || '].');
	END IF;

	IF  p_EVENT_STATUS IS NOT NULL AND
	    (v_DR_EVENT_REC.EVENT_STATUS IS NULL OR
		p_EVENT_STATUS <> v_DR_EVENT_REC.EVENT_STATUS) THEN
		-- Update the Event with the original data plus the new Status.
		-- This ensures that Data Level Security is enforced properly
		PUT_EVENT(v_EVENT_ID,
			v_DR_EVENT_REC.EVENT_NAME,
			v_DR_EVENT_REC.VPP_ID,
			p_EVENT_STATUS,
			v_DR_EVENT_REC.START_TIME,
			v_DR_EVENT_REC.STOP_TIME,
			v_DR_EVENT_REC.EVENT_TYPE,
			v_DR_EVENT_REC.EVENT_ALIAS,
			v_DR_EVENT_REC.EVENT_DESC);
	END IF;
END UPDATE_EVENT_STATUS;
--------------------------------------------------------------------------------
-- Public Procedures and Functions
--------------------------------------------------------------------------------
-- Process event and send message
PROCEDURE SUBMIT_EVENT
(
	p_EVENT_ID IN NUMBER,
	p_MESSAGE OUT VARCHAR2,
	p_SUCCESS_COUNT OUT BINARY_INTEGER,
	p_FAIL_COUNT OUT BINARY_INTEGER
) AS

v_CUT_BEGIN			DATE;
v_CUT_END			DATE;
v_EVENT_STATUS		DR_EVENT.EVENT_STATUS%TYPE;
v_USE_OPENADR_PAYLOAD SYSTEM_DICTIONARY.VALUE%TYPE;
v_PROGRAM_TYPE PROGRAM.PROGRAM_TYPE%TYPE;

BEGIN
	-- one second past start time so that we do not include the
	-- interval that ends with start time.
	SELECT EVENT_STATUS, START_TIME+1/86400, STOP_TIME
	INTO v_EVENT_STATUS, v_CUT_BEGIN, v_CUT_END
	FROM DR_EVENT
	WHERE EVENT_ID = p_EVENT_ID;

	IF v_EVENT_STATUS = DEMAND_RESPONSE_UTIL.c_EVENT_STATUS_CANCELLED THEN

		DEMAND_RESPONSE_UTIL.SEND_EVENT_CANCEL_MESSAGE(p_EVENT_ID, p_SUCCESS_COUNT, p_FAIL_COUNT);
		p_MESSAGE := 'Successfully sent '||p_SUCCESS_COUNT||' cancellation messages. Failed to send '||p_FAIL_COUNT||' cancellation messages';

	ELSE
    
  -- Get the Program Type
  SELECT P.PROGRAM_TYPE
         INTO v_PROGRAM_TYPE
  FROM DR_EVENT E, VPP V, PROGRAM P
    WHERE E.EVENT_ID = p_EVENT_ID
    AND E.VPP_ID = V.VPP_ID
    AND P.PROGRAM_ID = V.PROGRAM_ID;
    
    -- Disaggregate into segment-level dispatch data for DLC
    IF v_PROGRAM_TYPE = DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_DLC THEN      
      DER_CAPACITY_ENGINE.PROCESS_EVENT_SCHEDULE(p_EVENT_ID,v_CUT_BEGIN,v_CUT_END,p_MESSAGE);
    END IF;

		IF p_MESSAGE IS NULL THEN -- no error message? then send the data
            v_USE_OPENADR_PAYLOAD := GET_DICTIONARY_VALUE('Use OpenADR Payload', 0, 'Load Management', 'Demand Response', 'Event Dispatch Message');
			-- Send Dispatch Schedule
            IF v_USE_OPENADR_PAYLOAD = '' OR UPPER(NVL(v_USE_OPENADR_PAYLOAD,'TRUE')) = 'TRUE' THEN
                DEMAND_RESPONSE_UTIL.SEND_OPENADR_MSG(p_EVENT_ID => p_EVENT_ID,
                                                                p_CUT_BEGIN_DATE => v_CUT_BEGIN,
                                                                p_CUT_END_DATE => v_CUT_END,
                                                                p_SUCCESS_COUNT => p_SUCCESS_COUNT,
                                                                p_FAIL_COUNT => p_FAIL_COUNT);
            ELSE
			          DEMAND_RESPONSE_UTIL.SEND_DERMS_DISPATCH_MESSAGE(p_EVENT_ID => p_EVENT_ID,
                                                                p_CUT_BEGIN_DATE => v_CUT_BEGIN,
                                                                p_CUT_END_DATE => v_CUT_END,
                                                                p_SUCCESS_COUNT => p_SUCCESS_COUNT,
                                                                p_FAIL_COUNT => p_FAIL_COUNT);
            END IF;

			IF NVL(p_SUCCESS_COUNT,0) > 0 THEN
				-- Set the Status to 'Submitted'
				UPDATE_EVENT_STATUS(p_EVENT_ID, DEMAND_RESPONSE_UTIL.c_EVENT_STATUS_SUBMITTED);
			END IF;

			p_MESSAGE := 'Successfully sent '||p_SUCCESS_COUNT||' dispatch messages. Failed to send '||p_FAIL_COUNT||' dispatch messages';
		END IF;

	END IF;

END SUBMIT_EVENT;
--------------------------------------------------------------------------------
PROCEDURE CREATE_EVENT
	(
	p_VPP_ID           IN NUMBER,
	p_START_TIME       IN DATE,
	p_STOP_TIME        IN DATE,
	p_EVENT_TYPE       IN VARCHAR2,
	p_EVENT_DESC       IN VARCHAR2,
	p_SCHEDULE_DATES   IN DATE_COLLECTION,
	p_SCHEDULE_AMOUNTS IN NUMBER_COLLECTION,
	p_SCHEDULE_PRICES  IN NUMBER_COLLECTION,
	p_EVENT_ID         OUT NUMBER,
	p_SUCCESS_COUNT    OUT BINARY_INTEGER,
	p_FAIL_COUNT       OUT BINARY_INTEGER
	) AS
v_MESSAGE VARCHAR2(4000);
v_FINISH_MESSAGE PROCESS_LOG.PROCESS_FINISH_TEXT%TYPE;
v_STATUS NUMBER(9);
BEGIN
	LOGS.START_PROCESS('Create Event');

	LOGS.SET_PROCESS_TARGET_PARAMETER('VPP_ID', TEXT_UTIL.TO_CHAR_ENTITY(p_VPP_ID, EC.ED_VPP, TRUE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('START_TIME', TEXT_UTIL.TO_CHAR_TIME(p_START_TIME));
	LOGS.SET_PROCESS_TARGET_PARAMETER('STOP_TIME', TEXT_UTIL.TO_CHAR_TIME(p_STOP_TIME));
	LOGS.SET_PROCESS_TARGET_PARAMETER('EVENT_TYPE', p_EVENT_TYPE);
	LOGS.SET_PROCESS_TARGET_PARAMETER('EVENT_DESC', p_EVENT_DESC);

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('SCHEDULE_DATES = ' || TEXT_UTIL.TO_CHAR_TIME_LIST(p_SCHEDULE_DATES));
		LOGS.LOG_DEBUG('SCHEDULE_AMOUNTS = ' || TEXT_UTIL.TO_CHAR_NUMBER_LIST(p_SCHEDULE_AMOUNTS));
		LOGS.LOG_DEBUG('SCHEDULE_PRICES = ' || TEXT_UTIL.TO_CHAR_NUMBER_LIST(p_SCHEDULE_PRICES));
	END IF;

	-- Validation
	IF p_VPP_ID IS NULL THEN
		ERRS.RAISE_BAD_ARGUMENT('VPP',p_VPP_ID);
	END IF;

	IF p_START_TIME IS NULL THEN
		ERRS.RAISE_BAD_ARGUMENT('Start Time',p_START_TIME);
	END IF;

	IF p_STOP_TIME IS NULL THEN
		ERRS.RAISE_BAD_ARGUMENT('Stop Time',p_STOP_TIME);
	END IF;

	-- Create the DR_EVENT
	PUT_EVENT(p_EVENT_ID, -- Input as NULL
		NULL, -- NAME
		p_VPP_ID,
		DEMAND_RESPONSE_UTIL.c_EVENT_STATUS_NEW,
		p_START_TIME,
		p_STOP_TIME,
		p_EVENT_TYPE,
		NULL, -- ALIAS
		p_EVENT_DESC);

	IF p_EVENT_ID > 0 THEN
		-- Insert the schedule
		PUT_EVENT_INTERVAL_DATA(p_EVENT_ID,p_START_TIME,p_STOP_TIME,p_SCHEDULE_DATES,p_SCHEDULE_AMOUNTS,p_SCHEDULE_PRICES);
		COMMIT; -- if we've gotten his far, commit. We can't allow anything to roll back beyond this point because the
				-- next step could successfully send messages based on the data as it is now

		-- Submit the DR_EVENT to the Disaggregator
		-- Just ignore the outbound message
		SUBMIT_EVENT(p_EVENT_ID, v_MESSAGE, p_SUCCESS_COUNT, p_FAIL_COUNT);
	END IF;

	LOGS.STOP_PROCESS(v_FINISH_MESSAGE,v_STATUS);
	COMMIT;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.ABORT_PROCESS();
END CREATE_EVENT;
--------------------------------------------------------------------------------
PROCEDURE PUT_EVENT
(
	p_EVENT_ID IN OUT NUMBER,
	p_EVENT_NAME IN VARCHAR2,
	p_VPP_ID IN NUMBER,
	p_EVENT_STATUS IN VARCHAR2,
	p_START_TIME IN DATE,
	p_STOP_TIME IN DATE,
	p_EVENT_TYPE IN VARCHAR2,
	p_EVENT_ALIAS IN VARCHAR2,
	p_EVENT_DESC IN VARCHAR2
) AS

v_EVENT_NAME VARCHAR2(32);
v_EVENT_NUM NUMBER(9);

v_TEST PLS_INTEGER;

BEGIN

	IF NVL(p_START_TIME, CONSTANTS.LOW_DATE) > NVL(p_STOP_TIME, CONSTANTS.HIGH_DATE) THEN
		ERRS.RAISE_BAD_ARGUMENT('START_TIME/STOP_TIME', TEXT_UTIL.TO_CHAR_TIME(p_START_TIME) || '/'
			|| TEXT_UTIL.TO_CHAR_TIME(p_STOP_TIME), 'The start time for an event must be before the stop time.');
	END IF;

	IF p_EVENT_ID IS NULL AND p_EVENT_NAME IS NULL THEN
		SELECT DR_EVENT_NAME.NEXTVAL
		INTO v_EVENT_NUM
		FROM DUAL;

		v_EVENT_NAME := 'Event ' || v_EVENT_NUM;

		-- WE HAVE A GENERATED NAME, MAKE SURE NO ONE ACCIDENTALLY ALREADY CREATED AN EVENT
		-- WITH THE SAME NAME
		v_EVENT_NAME := ENTITY_UTIL.RESOLVE_ENTITY_NAME_CONFLICT(v_EVENT_NAME, EC.ED_DR_EVENT);
	END IF;

	/* ABG -- BZ 20073 -- If trying to create a new event that had the same VPP / Start Time
	   association for an existing event we would hit a unique constraint, but the problem
	   was that IO would interpret this to mean a DR Event with the same name already existed.
	   So before calling IO we check for this case and throw a custom exception. */

	IF NVL(p_EVENT_ID,0) = 0 THEN
		-- CHECK TO SEE IF THIS VIOLATES THE VPP /START TIME UK AND THROW AN EXCEPTION IF SO
		SELECT COUNT(1)
		INTO v_TEST
		FROM DR_EVENT EVT
		WHERE EVT.VPP_ID = p_VPP_ID
			AND EVT.START_TIME = p_START_TIME;

		IF v_TEST > 0 THEN
			ERRS.RAISE(MSGCODES.c_ERR_CONFLICT_DR_EVENT);
		END IF;

	END IF;

	IO.PUT_DR_EVENT(p_EVENT_ID,
			NVL(p_EVENT_NAME, v_EVENT_NAME),
			p_EVENT_ALIAS,
			p_EVENT_DESC,
			NVL(p_EVENT_ID,0),
			p_VPP_ID,
			NVL(p_EVENT_STATUS, c_NEW_EVENT_STATUS),
			p_START_TIME,
			p_STOP_TIME,
			p_EVENT_TYPE);
	-- Set up the Event Identifier for Webservices
	IF p_EVENT_ID IS NOT NULL AND p_EVENT_ID > 0 THEN
		EI.PUT_WS_IDENTIFIER_FOR_ID(NVL(p_EVENT_NAME, v_EVENT_NAME), p_EVENT_ID, EC.ED_DR_EVENT, NULL);
	END IF;

END PUT_EVENT;
--------------------------------------------------------------------------------
PROCEDURE PUT_EVENT_INTERVAL_DATA
	(
	p_EVENT_ID         IN NUMBER,
	p_START_TIME       IN DATE,
	p_STOP_TIME        IN DATE,
	p_SCHEDULE_DATES   IN DATE_COLLECTION,
	p_SCHEDULE_AMOUNTS IN NUMBER_COLLECTION,
	p_SCHEDULE_PRICES  IN NUMBER_COLLECTION
	) AS
v_IDX NUMBER;
v_USE_MW BOOLEAN;
v_UNIT_MULTIPLIER NUMBER := 1.0;
v_PROGRAM_INTERVAL PROGRAM.PROGRAM_INTERVAL%TYPE;
BEGIN

	-- Validation (START_TIME & STOP_TIME must be non-null)
	IF p_START_TIME IS NULL THEN
		ERRS.RAISE_BAD_ARGUMENT('Start Time',p_START_TIME);
	END IF;

	IF p_STOP_TIME IS NULL THEN
		ERRS.RAISE_BAD_ARGUMENT('Stop Time',p_STOP_TIME);
	END IF;

	-- Data Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_EVENT_ID, EC.ED_DR_EVENT);

	v_USE_MW := UT.BOOLEAN_FROM_STRING(NVL(GET_DICTIONARY_VALUE('Event Schedule as MW', 0, 'Load Management', 'Demand Response'),'Y'));

	IF v_USE_MW THEN
		v_PROGRAM_INTERVAL := GET_EVENT_INTERVAL(p_EVENT_ID);
		v_UNIT_MULTIPLIER := DATE_UTIL.GET_INTERVAL_DIVISOR(v_PROGRAM_INTERVAL,'');
	END IF;

	IF p_SCHEDULE_DATES IS NULL AND p_SCHEDULE_AMOUNTS IS NULL AND p_SCHEDULE_PRICES IS NULL THEN
		-- All the collections are NULL, just trim the DR_EVENT_SCHEDULE based on the START_TIME and STOP_TIME.
		DELETE FROM DR_EVENT_SCHEDULE S
		WHERE S.EVENT_ID = p_EVENT_ID
			AND (S.SCHEDULE_DATE <= p_START_TIME -- START_TIME is Interval-Begining but SCHEDULE_DATE is Interval-Ending
			OR S.SCHEDULE_DATE > p_STOP_TIME);
	ELSE
		-- Validate that collection are all the same size
		IF p_SCHEDULE_DATES.COUNT() = p_SCHEDULE_AMOUNTS.COUNT() AND p_SCHEDULE_DATES.COUNT() = p_SCHEDULE_PRICES.COUNT() THEN
			FORALL v_IDX IN 1..p_SCHEDULE_AMOUNTS.COUNT()
				MERGE INTO DR_EVENT_SCHEDULE TGT
				USING (SELECT p_EVENT_ID AS EVENT_ID, p_SCHEDULE_DATES(v_IDX) AS SCHEDULE_DATE, p_SCHEDULE_AMOUNTS(v_IDX) AS AMOUNT, p_SCHEDULE_PRICES(v_IDX) AS PRICE FROM DUAL) SRC
				ON   (TGT.EVENT_ID = SRC.EVENT_ID AND TGT.SCHEDULE_DATE = SRC.SCHEDULE_DATE)
				WHEN MATCHED
				THEN
				UPDATE
				SET TGT.AMOUNT = SRC.AMOUNT * v_UNIT_MULTIPLIER,
					TGT.PRICE = SRC.PRICE
				WHEN NOT MATCHED
				THEN
				INSERT (TGT.EVENT_ID, TGT.SCHEDULE_DATE, TGT.AMOUNT, TGT.PRICE)
				VALUES (SRC.EVENT_ID, SRC.SCHEDULE_DATE, SRC.AMOUNT * v_UNIT_MULTIPLIER, SRC.PRICE);
		ELSE
			ERRS.RAISE(MSGCODES.c_ERR_ARGUMENT, 'SCHEDULE_DATES, SCHEDULE_AMOUNTS, and SCHEDULE_PRICES must be the same size.');
		END IF;
	END IF;
END PUT_EVENT_INTERVAL_DATA;
--------------------------------------------------------------------------------
PROCEDURE UPDATE_EVENT
	(
	p_EVENT_ID         IN NUMBER,
	p_START_TIME       IN DATE,
	p_STOP_TIME        IN DATE,
	p_EVENT_TYPE       IN VARCHAR2,
	p_EVENT_DESC       IN VARCHAR2,
	p_SCHEDULE_DATES   IN DATE_COLLECTION,
	p_SCHEDULE_AMOUNTS IN NUMBER_COLLECTION,
	p_SCHEDULE_PRICES  IN NUMBER_COLLECTION,
	p_SUCCESS_COUNT	   OUT BINARY_INTEGER,
	p_FAIL_COUNT 	   OUT BINARY_INTEGER
	) AS
v_DR_EVENT_REC DR_EVENT%ROWTYPE;
v_EVENT_ID DR_EVENT.EVENT_ID%TYPE := p_EVENT_ID;
v_MESSAGE VARCHAR2(4000);
v_FINISH_MESSAGE PROCESS_LOG.PROCESS_FINISH_TEXT%TYPE;
v_STATUS NUMBER(9);
BEGIN
	LOGS.START_PROCESS('Update Event');

	ASSERT(p_EVENT_ID IS NOT NULL, 'The Event Id must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_EVENT_ID > 0, 'Event Id = ' || p_EVENT_ID, MSGCODES.c_ERR_ARGUMENT);

	LOGS.SET_PROCESS_TARGET_PARAMETER('EVENT_ID', TEXT_UTIL.TO_CHAR_ENTITY(p_EVENT_ID, EC.ED_DR_EVENT, TRUE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('START_TIME', TEXT_UTIL.TO_CHAR_TIME(p_START_TIME));
	LOGS.SET_PROCESS_TARGET_PARAMETER('STOP_TIME', TEXT_UTIL.TO_CHAR_TIME(p_STOP_TIME));
	LOGS.SET_PROCESS_TARGET_PARAMETER('EVENT_TYPE', p_EVENT_TYPE);
	LOGS.SET_PROCESS_TARGET_PARAMETER('EVENT_DESC', p_EVENT_DESC);

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('SCHEDULE_DATES = ' || TEXT_UTIL.TO_CHAR_TIME_LIST(p_SCHEDULE_DATES));
		LOGS.LOG_DEBUG('SCHEDULE_AMOUNTS = ' || TEXT_UTIL.TO_CHAR_NUMBER_LIST(p_SCHEDULE_AMOUNTS));
		LOGS.LOG_DEBUG('SCHEDULE_PRICES = ' || TEXT_UTIL.TO_CHAR_NUMBER_LIST(p_SCHEDULE_PRICES));
	END IF;

	-- GET ORIGINAL EVENT DATA
	IO.GET_DR_EVENT(p_EVENT_ID,
		v_DR_EVENT_REC.EVENT_NAME,
		v_DR_EVENT_REC.EVENT_ALIAS,
		v_DR_EVENT_REC.EVENT_DESC,
		v_DR_EVENT_REC.VPP_ID,
		v_DR_EVENT_REC.EVENT_STATUS,
		v_DR_EVENT_REC.START_TIME,
		v_DR_EVENT_REC.STOP_TIME,
		v_DR_EVENT_REC.EVENT_TYPE);

	IF TRIM(v_DR_EVENT_REC.EVENT_NAME) IS NULL THEN
		ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY,'Event Id = [' || NVL(TO_CHAR(p_EVENT_ID), 'NULL') || '].');
	END IF;

	-- Update the 4 attributes on the Event if populated
	PUT_EVENT(v_EVENT_ID,
		v_DR_EVENT_REC.EVENT_NAME,
		v_DR_EVENT_REC.VPP_ID,
		DEMAND_RESPONSE_UTIL.c_EVENT_STATUS_CHANGED,
		NVL(p_START_TIME, v_DR_EVENT_REC.START_TIME),
		NVL(p_STOP_TIME, v_DR_EVENT_REC.STOP_TIME),
		NVL(p_EVENT_TYPE, v_DR_EVENT_REC.EVENT_TYPE),
		v_DR_EVENT_REC.EVENT_ALIAS,
		NVL(p_EVENT_DESC, v_DR_EVENT_REC.EVENT_DESC));

	-- Insert the schedule
	PUT_EVENT_INTERVAL_DATA(p_EVENT_ID,
		NVL(p_START_TIME, v_DR_EVENT_REC.START_TIME),
		NVL(p_STOP_TIME, v_DR_EVENT_REC.STOP_TIME),
		p_SCHEDULE_DATES,
		p_SCHEDULE_AMOUNTS,
		p_SCHEDULE_PRICES);

	COMMIT; -- if we've gotten his far, commit. We can't allow anything to roll back beyond this point because the
			-- next step could successfully send messages based on the data as it is now

	-- Submit the DR_EVENT to the Disaggregator
	-- Just ignore the outbound message
	SUBMIT_EVENT(p_EVENT_ID, v_MESSAGE, p_SUCCESS_COUNT, p_FAIL_COUNT);

	LOGS.STOP_PROCESS(v_FINISH_MESSAGE,v_STATUS);
	COMMIT;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.ABORT_PROCESS();
END UPDATE_EVENT;
--------------------------------------------------------------------------------
PROCEDURE START_EVENT
	(
	p_EVENT_ID           IN NUMBER,
	p_EXTERNAL_SYSTEM_ID IN NUMBER
	) AS
v_FINISH_MESSAGE PROCESS_LOG.PROCESS_FINISH_TEXT%TYPE;
v_STATUS NUMBER(9);
BEGIN
	LOGS.START_PROCESS('Start Event');

	ASSERT(p_EVENT_ID IS NOT NULL, 'The Event Id must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_EVENT_ID > 0, 'Event Id = ' || p_EVENT_ID, MSGCODES.c_ERR_ARGUMENT);

	LOGS.SET_PROCESS_TARGET_PARAMETER('EVENT_ID', TEXT_UTIL.TO_CHAR_ENTITY(p_EVENT_ID, EC.ED_DR_EVENT, TRUE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('EXTERNAL_SYSTEM_ID', TEXT_UTIL.TO_CHAR_ENTITY(p_EXTERNAL_SYSTEM_ID, EC.ED_EXTERNAL_SYSTEM, TRUE));

	-- Ignore EXTERNAL_SYSTEM_ID for now.
	UPDATE_EVENT_STATUS(p_EVENT_ID, DEMAND_RESPONSE_UTIL.c_EVENT_STATUS_STARTED);

	LOGS.STOP_PROCESS(v_FINISH_MESSAGE,v_STATUS);
	COMMIT;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.ABORT_PROCESS();
END START_EVENT;
--------------------------------------------------------------------------------
PROCEDURE CONFIRM_EVENT
	(
	p_EVENT_ID           IN NUMBER,
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_DER_OPTOUT_IDS     IN NUMBER_COLLECTION,
	p_DER_OPTOUT_DATES   IN DATE_COLLECTION
	) AS
v_FINISH_MESSAGE PROCESS_LOG.PROCESS_FINISH_TEXT%TYPE;
v_STATUS NUMBER(9);
BEGIN
	LOGS.START_PROCESS('Confirm Event');

	ASSERT(p_EVENT_ID IS NOT NULL, 'The Event Id must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_EVENT_ID > 0, 'Event Id = ' || p_EVENT_ID, MSGCODES.c_ERR_ARGUMENT);

	LOGS.SET_PROCESS_TARGET_PARAMETER('EVENT_ID', TEXT_UTIL.TO_CHAR_ENTITY(p_EVENT_ID, EC.ED_DR_EVENT, TRUE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('EXTERNAL_SYSTEM_ID', TEXT_UTIL.TO_CHAR_ENTITY(p_EXTERNAL_SYSTEM_ID, EC.ED_EXTERNAL_SYSTEM, TRUE));

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('DER_OPTOUT_IDS = ' || TEXT_UTIL.TO_CHAR_NUMBER_LIST(p_DER_OPTOUT_IDS));
		LOGS.LOG_DEBUG('DER_OPTOUT_DATES = ' || TEXT_UTIL.TO_CHAR_TIME_LIST(p_DER_OPTOUT_DATES));
	END IF;

	-- Ignore EXTERNAL_SYSTEM_ID for now.
	-- Update the DER_EVENT_EXCEPTION table
	IF p_DER_OPTOUT_IDS IS NOT NULL AND p_DER_OPTOUT_DATES IS NOT NULL THEN
		IF p_DER_OPTOUT_IDS.COUNT() = p_DER_OPTOUT_DATES.COUNT() THEN
			FOR v_IDX IN p_DER_OPTOUT_IDS.FIRST..p_DER_OPTOUT_IDS.LAST LOOP
				PUT_EVENT_EXCEPTION(p_EVENT_ID, p_DER_OPTOUT_IDS(v_IDX), DEMAND_RESPONSE_UTIL.c_EXCEPTION_TYPE_OPTOUT, p_DER_OPTOUT_DATES(v_IDX));
			END LOOP;
		ELSE
			ERRS.RAISE(MSGCODES.c_ERR_ARGUMENT, 'DER_OPTOUT_IDS and DER_OPTOUT_DATES must be the same size.');
		END IF;
	END IF;

	UPDATE_EVENT_STATUS(p_EVENT_ID, DEMAND_RESPONSE_UTIL.c_EVENT_STATUS_CONFIRMED);

	LOGS.STOP_PROCESS(v_FINISH_MESSAGE,v_STATUS);
	COMMIT;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.ABORT_PROCESS();
END CONFIRM_EVENT;
--------------------------------------------------------------------------------
PROCEDURE CANCEL_EVENT
	(
	p_EVENT_ID IN NUMBER,
	p_SUCCESS_COUNT OUT BINARY_INTEGER,
	p_FAIL_COUNT OUT BINARY_INTEGER
	) AS
v_FINISH_MESSAGE 	PROCESS_LOG.PROCESS_FINISH_TEXT%TYPE;
v_MESSAGE 			VARCHAR2(4000);
v_STATUS 			NUMBER(9);
BEGIN
	LOGS.START_PROCESS('Cancel Event');

	ASSERT(p_EVENT_ID IS NOT NULL, 'The Event Id must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_EVENT_ID > 0, 'Event Id = ' || p_EVENT_ID, MSGCODES.c_ERR_ARGUMENT);

	LOGS.SET_PROCESS_TARGET_PARAMETER('EVENT_ID', TEXT_UTIL.TO_CHAR_ENTITY(p_EVENT_ID, EC.ED_DR_EVENT, TRUE));

	UPDATE_EVENT_STATUS(p_EVENT_ID, DEMAND_RESPONSE_UTIL.c_EVENT_STATUS_CANCELLED);

	COMMIT; -- if we've gotten his far, commit. We can't allow anything to roll back beyond this point because the
			-- next step could successfully send messages based on the data as it is now

	-- Submit the cancellation to the disaggregator
	-- Just ignore the outbound message
	SUBMIT_EVENT(p_EVENT_ID, v_MESSAGE, p_SUCCESS_COUNT, p_FAIL_COUNT);

	LOGS.STOP_PROCESS(v_FINISH_MESSAGE,v_STATUS);
	COMMIT;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.ABORT_PROCESS();
END CANCEL_EVENT;
--------------------------------------------------------------------------------
PROCEDURE STOP_ALL_EVENTS AS
v_STARTED_EVENT_IDS NUMBER_COLLECTION;
v_FINISH_MESSAGE PROCESS_LOG.PROCESS_FINISH_TEXT%TYPE;
v_STATUS NUMBER(9);
BEGIN
	LOGS.START_PROCESS('Stop All Events');

	SELECT E.EVENT_ID
	BULK COLLECT INTO v_STARTED_EVENT_IDS
	FROM DR_EVENT E
	WHERE E.EVENT_STATUS = DEMAND_RESPONSE_UTIL.c_EVENT_STATUS_STARTED;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('STARTED_EVENT_IDS = ' || TEXT_UTIL.TO_CHAR_NUMBER_LIST(v_STARTED_EVENT_IDS));
	END IF;

	IF v_STARTED_EVENT_IDS IS NOT NULL THEN
		-- Not as efficient as FORALL but enforces Data Level Security
		FOR v_IDX IN v_STARTED_EVENT_IDS.FIRST..v_STARTED_EVENT_IDS.LAST LOOP
			UPDATE_EVENT_STATUS(v_STARTED_EVENT_IDS(v_IDX), DEMAND_RESPONSE_UTIL.c_EVENT_STATUS_SYSTEM_OVERRIDE);
		END LOOP;
	END IF;

	LOGS.STOP_PROCESS(v_FINISH_MESSAGE,v_STATUS);
	COMMIT;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.ABORT_PROCESS();
END STOP_ALL_EVENTS;
--------------------------------------------------------------------------------
PROCEDURE RESUME_ALL_EVENTS AS
v_SYSTEM_OVERRIDE_EVENT_IDS NUMBER_COLLECTION;
v_FINISH_MESSAGE PROCESS_LOG.PROCESS_FINISH_TEXT%TYPE;
v_STATUS NUMBER(9);
BEGIN
	LOGS.START_PROCESS('Resume All Events');

	SELECT E.EVENT_ID
	BULK COLLECT INTO v_SYSTEM_OVERRIDE_EVENT_IDS
	FROM DR_EVENT E
	WHERE E.EVENT_STATUS = DEMAND_RESPONSE_UTIL.c_EVENT_STATUS_SYSTEM_OVERRIDE;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('SYSTEM_OVERRIDE_EVENT_IDS = ' || TEXT_UTIL.TO_CHAR_NUMBER_LIST(v_SYSTEM_OVERRIDE_EVENT_IDS));
	END IF;

	IF v_SYSTEM_OVERRIDE_EVENT_IDS IS NOT NULL THEN
		-- Not as efficient as FORALL but enforces Data Level Security
		FOR v_IDX IN v_SYSTEM_OVERRIDE_EVENT_IDS.FIRST..v_SYSTEM_OVERRIDE_EVENT_IDS.LAST LOOP
			UPDATE_EVENT_STATUS(v_SYSTEM_OVERRIDE_EVENT_IDS(v_IDX), DEMAND_RESPONSE_UTIL.c_EVENT_STATUS_RESUMED);
		END LOOP;
	END IF;

	LOGS.STOP_PROCESS(v_FINISH_MESSAGE,v_STATUS);
	COMMIT;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.ABORT_PROCESS();
END RESUME_ALL_EVENTS;
--------------------------------------------------------------------------------
PROCEDURE IMPORT_EVENT_REDUCTION
	(
	p_EVENT_ID           IN NUMBER,
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_FEEDER_SEGMENT_IDS IN NUMBER_COLLECTION,
	p_SCHEDULE_DATES     IN DATE_COLLECTION_COLLECTION,
	p_SCHEDULE_AMOUNTS   IN NUMBER_COLLECTION_COLLECTION
	) AS
v_PROGRAM_ID     PROGRAM.PROGRAM_ID%TYPE;
v_FINISH_MESSAGE PROCESS_LOG.PROCESS_FINISH_TEXT%TYPE;
v_STATUS         NUMBER(9);
BEGIN
	LOGS.START_PROCESS('Import Event Reduction');

	ASSERT(p_EVENT_ID IS NOT NULL, 'The Event Id must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_EVENT_ID > 0, 'Event Id = ' || p_EVENT_ID, MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_EXTERNAL_SYSTEM_ID IS NOT NULL, 'The External System must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_EXTERNAL_SYSTEM_ID > 0, 'External System Id = ' || p_EXTERNAL_SYSTEM_ID, MSGCODES.c_ERR_ARGUMENT);ASSERT(p_FEEDER_SEGMENT_IDS IS NOT NULL, 'The Feeder Segments must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_SCHEDULE_DATES IS NOT NULL, 'The Schedule Dates must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_SCHEDULE_AMOUNTS IS NOT NULL, 'The Schedule Amounts must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_FEEDER_SEGMENT_IDS.COUNT = p_SCHEDULE_DATES.COUNT AND p_SCHEDULE_DATES.COUNT = p_SCHEDULE_AMOUNTS.COUNT,
		'The feeder segments, dates, and amounts must be of the same size.', MSGCODES.c_ERR_ARGUMENT);

	LOGS.SET_PROCESS_TARGET_PARAMETER('EVENT_ID', TEXT_UTIL.TO_CHAR_ENTITY(p_EVENT_ID, EC.ED_DR_EVENT, TRUE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('EXTERNAL_SYSTEM_ID', TEXT_UTIL.TO_CHAR_ENTITY(p_EXTERNAL_SYSTEM_ID, EC.ED_EXTERNAL_SYSTEM, TRUE));

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('FEEDER_SEGMENT_IDS = ' || TEXT_UTIL.TO_CHAR_NUMBER_LIST(p_FEEDER_SEGMENT_IDS));
		LOGS.LOG_DEBUG('SCHEDULE_DATES = ' || TEXT_UTIL.TO_CHAR_2D_TIME_LIST(p_SCHEDULE_DATES));
		LOGS.LOG_DEBUG('SCHEDULE_AMOUNTS = ' || TEXT_UTIL.TO_CHAR_2D_NUMBER_LIST(p_SCHEDULE_AMOUNTS));
	END IF;

	UPDATE_EVENT_STATUS(p_EVENT_ID, DEMAND_RESPONSE_UTIL.c_EVENT_STATUS_STARTED);

	v_PROGRAM_ID := GET_PROGRAM_FOR_EVENT(p_EVENT_ID);

	FOR v_IDX IN p_FEEDER_SEGMENT_IDS.FIRST..p_FEEDER_SEGMENT_IDS.LAST LOOP
		DER_CAPACITY_ENGINE.PUT_SEGMENT_EXTERNAL_RESULT(
			p_EXTERNAL_SYSTEM_ID,
			p_FEEDER_SEGMENT_IDS(v_IDX),
			v_PROGRAM_ID,
			p_SCHEDULE_DATES(v_IDX),
			p_SCHEDULE_AMOUNTS(v_IDX), -- Availability
			NULL, -- Capability
			NULL, -- DER Count
			CONSTANTS.CODE_BACKCAST,
			GA.BASE_SCENARIO_ID);
	END LOOP;

	LOGS.STOP_PROCESS(v_FINISH_MESSAGE,v_STATUS);
	COMMIT;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.ABORT_PROCESS();
END IMPORT_EVENT_REDUCTION;
--------------------------------------------------------------------------------
PROCEDURE GET_PERIOD_LIMIT_CUT_DATES
	(
	p_DATE IN DATE,
	p_PERIOD IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE
	) AS

	v_BEGIN DATE;
	v_END DATE;

BEGIN

	v_BEGIN := p_DATE - 1/86400;

	IF UPPER(p_PERIOD) <> 'HOURLY' THEN
		-- IF NOT HOURLY WE ARE CONCERNED WITH MAKING SURE WE ARE IN THE
		-- CORRECT DAY FOR THIS TIME ZONE
		v_BEGIN := FROM_CUT(v_BEGIN, p_TIME_ZONE);
	END IF;

	IF UPPER(p_PERIOD) = 'MONTHLY' THEN
		v_BEGIN := TRUNC(v_BEGIN, 'MM');
		-- WE STOP ON THE FIRST DAY OF THE NEXT MONTH
		v_END := ADD_MONTHS(v_BEGIN, 1);
		v_END := v_END - 1;
	ELSIF UPPER(p_PERIOD) = 'ANNUAL' THEN
		v_BEGIN := TRUNC(v_BEGIN, 'YYYY');
		v_END := ADD_MONTHS(v_BEGIN, 12);
		v_END := v_END - 1;
	ELSIF UPPER(p_PERIOD) = 'WEEKLY' THEN
		v_BEGIN := DATE_UTIL.WEEK_TRUNC(v_BEGIN);
		v_END := v_BEGIN + 6;
	ELSIF UPPER(p_PERIOD) = 'DAILY' THEN
		v_BEGIN := TRUNC(v_BEGIN, 'DD');
		v_END := v_BEGIN;
	ELSIF UPPER(p_PERIOD) = 'HOURLY' THEN
		v_BEGIN := TRUNC(v_BEGIN, 'HH24');
		v_END := v_BEGIN + 1/24;
	END IF;

	IF UPPER(p_PERIOD) <> 'HOURLY' THEN
		UT.CUT_DATE_RANGE(CONSTANTS.ELECTRIC_MODEL, v_BEGIN, v_END, p_TIME_ZONE,
			p_BEGIN_DATE, p_END_DATE);
	ELSE
		-- ADD A SECOND TO THE BEGIN DATE SO ALL OF OUR PERIODS CAN BE QUERIED INCLUSIVELY FOR HITS
		p_BEGIN_DATE := v_BEGIN + 1/86400;
		p_END_DATE := v_END;
	END IF;

END GET_PERIOD_LIMIT_CUT_DATES;
----------------------------------------------------------------------------------------------------
PROCEDURE CLEAR_EVENT_HITS_LIST AS
BEGIN

	EXECUTE IMMEDIATE 'TRUNCATE TABLE '||c_TEMP_TABLE_HITS;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE;
END CLEAR_EVENT_HITS_LIST;
--------------------------------------------------------------------------------
PROCEDURE CREATE_EVENT_HITS_LIST
	(
	p_EVENT_ID			   IN NUMBER
	) AS

	v_DATE DATE;
	v_PERIOD_BEGIN DATE;
	v_PERIOD_END DATE;

	v_CUT_BEGIN DATE;
	v_CUT_END DATE;

	v_TIME_ZONE SERVICE_ZONE.TIME_ZONE%TYPE;
	v_PROGRAM_ID NUMBER(9);

	CURSOR v_CUR (p_PROGRAM_ID IN NUMBER,
					p_TIME_ZONE IN VARCHAR2,
					p_BEGIN IN DATE,
					p_END IN DATE) IS
	SELECT DISTINCT PL.LIMIT_PERIOD, PL.PERIOD_ID, PL.TEMPLATE_ID,
					PL.PROGRAM_LIMIT_ID, HS.HOLIDAY_SET_ID
	FROM PROGRAM_LIMIT PL,
		HOLIDAY_SET HS,
		TEMPLATE_DATES TD,
		TEMPLATE_DAY_TYPE_PERIOD TDTP
	WHERE PL.PROGRAM_ID = p_PROGRAM_ID
		AND PL.LIMIT_TYPE = DEMAND_RESPONSE_UTIL.c_LIMIT_TYPE_EXECUTION
		AND TD.TEMPLATE_ID = PL.TEMPLATE_ID
		AND TD.TIME_ZONE = p_TIME_ZONE
		AND TD.HOLIDAY_SET_ID = HS.HOLIDAY_SET_ID
		AND p_END > TD.CUT_BEGIN_DATE
		AND p_BEGIN <= TD.CUT_END_DATE
		AND TDTP.DAY_TYPE_ID = TD.DAY_TYPE_ID
		AND TDTP.TIME_STAMP BETWEEN (p_BEGIN-TD.CUT_BEGIN_DATE)
								AND (p_END-TD.CUT_BEGIN_DATE)
		AND TDTP.PERIOD_ID = PL.PERIOD_ID
		AND TDTP.MINIMUM_INTERVAL_NUMBER >= CONSTANTS.INTERVAL_NUMBER_HOUR;

	v_TEMPLATES NUMBER_COLLECTION;
	v_HOLIDAY_SETS NUMBER_COLLECTION;

BEGIN

	CLEAR_EVENT_HITS_LIST;

	SELECT EVT.START_TIME, EVT.STOP_TIME, VPP.PROGRAM_ID, SZ.TIME_ZONE
	INTO v_CUT_BEGIN, v_CUT_END, v_PROGRAM_ID, v_TIME_ZONE
	FROM DR_EVENT EVT,
		VIRTUAL_POWER_PLANT VPP,
		SERVICE_ZONE SZ
	WHERE EVT.EVENT_ID = p_EVENT_ID
		AND VPP.VPP_ID = EVT.VPP_ID
		AND SZ.SERVICE_ZONE_ID = VPP.SERVICE_ZONE_ID;

	SELECT DISTINCT PL.TEMPLATE_ID
	BULK COLLECT INTO v_TEMPLATES
	FROM PROGRAM_LIMIT PL
	WHERE PL.PROGRAM_ID = v_PROGRAM_ID;

	SELECT HS.HOLIDAY_SET_ID
	BULK COLLECT INTO v_HOLIDAY_SETS
	FROM HOLIDAY_SET HS;

	SP.CHECK_TEMPLATE_DATES(v_TEMPLATES,
							v_HOLIDAY_SETS,
							v_TIME_ZONE,
							TRUNC(FROM_CUT(v_CUT_BEGIN, v_TIME_ZONE)),
							TRUNC(FROM_CUT(v_CUT_END, v_TIME_ZONE)));

	FOR v_REC IN v_CUR(v_PROGRAM_ID, v_TIME_ZONE, v_CUT_BEGIN, v_CUT_END)  LOOP

		v_DATE := v_CUT_BEGIN + 1/86400;

		WHILE v_DATE < v_CUT_END LOOP

			GET_PERIOD_LIMIT_CUT_DATES(v_DATE,
									 v_REC.LIMIT_PERIOD,
									 v_TIME_ZONE,
									 v_PERIOD_BEGIN,
									 v_PERIOD_END);

			INSERT INTO TEMP_PROGRAM_HITS_LIST (PROGRAM_LIMIT_ID, PERIOD_START_DATE, PERIOD_STOP_DATE,
							HOLIDAY_SET_ID)
			VALUES (v_REC.PROGRAM_LIMIT_ID, v_PERIOD_BEGIN, v_PERIOD_END, v_REC.HOLIDAY_SET_ID);


			IF UPPER(v_REC.LIMIT_PERIOD) <> 'HOURLY' THEN
				v_DATE := v_PERIOD_END + 1;
			ELSE
				v_DATE := v_PERIOD_END;
			END IF;
		END LOOP;
	END LOOP;

END CREATE_EVENT_HITS_LIST;
--------------------------------------------------------------------------------
PROCEDURE LOG_DER_HIT
	(
	p_EVENT_ID IN NUMBER,
	p_DER_ID   IN NUMBER
	) AS
BEGIN

	MERGE INTO PROGRAM_LIMIT_HITS_USED PLHU
	USING (SELECT TPHL.PROGRAM_LIMIT_ID, TPHL.PERIOD_START_DATE, TPHL.PERIOD_STOP_DATE,
				DER.SERVICE_LOCATION_ID, p_EVENT_ID AS EVENT_ID
			FROM DISTRIBUTED_ENERGY_RESOURCE DER,
				DR_EVENT EVT,
				TEMP_PROGRAM_HITS_LIST TPHL
			WHERE EVT.EVENT_ID = p_EVENT_ID
				AND DER.DER_ID = p_DER_ID
				AND TPHL.HOLIDAY_SET_ID =
					DER_CAPACITY_ENGINE.GET_HOLIDAY_SET_FOR_SERV_LOC(DER.SERVICE_LOCATION_ID,
						TRUNC(EVT.STOP_TIME))) TLHU
		ON (TLHU.PROGRAM_LIMIT_ID = PLHU.PROGRAM_LIMIT_ID
			AND TLHU.SERVICE_LOCATION_ID = PLHU.SERVICE_LOCATION_ID
			AND TLHU.EVENT_ID = PLHU.EVENT_ID
			AND TLHU.PERIOD_START_DATE = PLHU.PERIOD_START_DATE
			AND TLHU.PERIOD_STOP_DATE = PLHU.PERIOD_STOP_DATE)
		WHEN NOT MATCHED THEN
			INSERT (PROGRAM_LIMIT_ID, SERVICE_LOCATION_ID, EVENT_ID, PERIOD_START_DATE,
				PERIOD_STOP_DATE, HITS_USED)
			VALUES (TLHU.PROGRAM_LIMIT_ID, TLHU.SERVICE_LOCATION_ID, TLHU.EVENT_ID,
				TLHU.PERIOD_START_DATE, TLHU.PERIOD_STOP_DATE, 1);

END LOG_DER_HIT;
--------------------------------------------------------------------------------
PROCEDURE IMPORT_PREMISE_RESULTS
	(
	p_EVENT_ID             IN NUMBER,
	p_EXTERNAL_SYSTEM_ID   IN NUMBER,
	p_PREMISE_IDS          IN NUMBER_COLLECTION,
	p_DER_TYPE_IDS         IN NUMBER_COLLECTION,
	p_OPTOUT_DATES         IN DATE_COLLECTION,
	p_OVERRIDE_DATES 	   IN DATE_COLLECTION,
	p_FAILURES             IN NUMBER_COLLECTION,
	p_SCHEDULE_DATES       IN DATE_COLLECTION_COLLECTION,
	p_SCHEDULE_AMOUNTS     IN NUMBER_COLLECTION_COLLECTION
	) AS
v_DER_ID DISTRIBUTED_ENERGY_RESOURCE.DER_ID%TYPE;
v_DER_TYPE_ID DER_TYPE.DER_TYPE_ID%TYPE;
v_PREMISE_ID SERVICE_LOCATION.SERVICE_LOCATION_ID%TYPE;
v_OPTOUT_DATE DATE;
v_OVERRIDE_DATE DATE;
v_IS_FAILURE NUMBER(1);
v_PROGRAM_ID PROGRAM.PROGRAM_ID%TYPE;
v_PROGRAM_INTERVAL PROGRAM.PROGRAM_INTERVAL%TYPE;
v_FINISH_MESSAGE PROCESS_LOG.PROCESS_FINISH_TEXT%TYPE;
v_STATUS NUMBER(9);

FUNCTION HAS_SCHEDULE(p_DATES DATE_COLLECTION,p_AMTS NUMBER_COLLECTION) RETURN BOOLEAN AS
BEGIN
	RETURN p_DATES IS NOT NULL AND p_AMTS IS NOT NULL AND
			p_DATES.COUNT > 0 AND p_AMTS.COUNT = p_DATES.COUNT AND
			p_DATES(1) IS NOT NULL AND p_AMTS(1) IS NOT NULL;
END;

BEGIN
	LOGS.START_PROCESS('Import Premise Results');

	ASSERT(p_EVENT_ID IS NOT NULL, 'The Event Id must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_EVENT_ID > 0, 'Event Id = ' || p_EVENT_ID, MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_EXTERNAL_SYSTEM_ID IS NOT NULL, 'The External System must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_EXTERNAL_SYSTEM_ID > 0, 'External System Id = ' || p_EXTERNAL_SYSTEM_ID, MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_PREMISE_IDS IS NOT NULL, 'The Premise list must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_DER_TYPE_IDS IS NOT NULL, 'The DER Type list must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_OPTOUT_DATES IS NOT NULL, 'The Optout Date list must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_OVERRIDE_DATES IS NOT NULL, 'The Overide Date list must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_FAILURES IS NOT NULL, 'The Failure list must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_SCHEDULE_DATES IS NOT NULL, 'The Schedule Dates must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_SCHEDULE_AMOUNTS IS NOT NULL, 'The Schedule Amounts must not be null.', MSGCODES.c_ERR_ARGUMENT);

	LOGS.SET_PROCESS_TARGET_PARAMETER('EVENT_ID',TEXT_UTIL.TO_CHAR_ENTITY(p_EVENT_ID, EC.ED_DR_EVENT, TRUE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('EXTERNAL_SYSTEM_ID',TEXT_UTIL.TO_CHAR_ENTITY(p_EXTERNAL_SYSTEM_ID, EC.ED_EXTERNAL_SYSTEM, TRUE));

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PREMISE_IDS = ' || TEXT_UTIL.TO_CHAR_NUMBER_LIST(p_PREMISE_IDS));
		LOGS.LOG_DEBUG('DER_TYPE_IDS = ' || TEXT_UTIL.TO_CHAR_NUMBER_LIST(p_DER_TYPE_IDS));
		LOGS.LOG_DEBUG('OPTOUT_DATES = ' || TEXT_UTIL.TO_CHAR_TIME_LIST(p_OPTOUT_DATES));
		LOGS.LOG_DEBUG('OVERRIDE_DATES = ' || TEXT_UTIL.TO_CHAR_TIME_LIST(p_OVERRIDE_DATES));
		LOGS.LOG_DEBUG('FAILURES = ' || TEXT_UTIL.TO_CHAR_NUMBER_LIST(p_FAILURES));
		LOGS.LOG_DEBUG('SCHEDULE_DATES = ' || TEXT_UTIL.TO_CHAR_2D_TIME_LIST(p_SCHEDULE_DATES));
		LOGS.LOG_DEBUG('SCHEDULE_AMOUNTS = ' || TEXT_UTIL.TO_CHAR_2D_NUMBER_LIST(p_SCHEDULE_AMOUNTS));
	END IF;

	v_PROGRAM_ID := GET_PROGRAM_FOR_EVENT(p_EVENT_ID);
	v_PROGRAM_INTERVAL := GET_EVENT_INTERVAL(p_EVENT_ID);

	DER_CAPACITY_ENGINE.BEFORE_STORE_EXT_DER_RESULTS;
	CREATE_EVENT_HITS_LIST(p_EVENT_ID);

	FOR v_IDX IN p_PREMISE_IDS.FIRST..p_PREMISE_IDS.LAST LOOP
		-- initialize the locals
		v_DER_TYPE_ID := p_DER_TYPE_IDS(v_IDX);
		v_PREMISE_ID := p_PREMISE_IDS(v_IDX);
		v_OPTOUT_DATE := p_OPTOUT_DATES(v_IDX);
		v_OVERRIDE_DATE := p_OVERRIDE_DATES(v_IDX);
		v_IS_FAILURE := NVL(p_FAILURES(v_IDX), 0);

		v_DER_ID := GET_DER(p_EVENT_ID, v_PROGRAM_ID, v_PREMISE_ID, v_DER_TYPE_ID);

		IF v_DER_ID IS NOT NULL AND v_DER_ID > 0 THEN
			-- Handle Participation, Hits and Schedule
			IF HAS_SCHEDULE(p_SCHEDULE_DATES(v_IDX),p_SCHEDULE_AMOUNTS(v_IDX)) THEN

				-- Update the DR_EVENT_PARTICIPATION, DER_DAILY_RESULT, LOAD_SHAPE_RESULT_ID, and LOAD_SHAPE_RESULT_DATA tables
				PUT_EVENT_PARTICIPATION(p_EVENT_ID, v_DER_ID);

				-- Handle Hits Budget, Only count it as a hit if it did not fail.
				IF v_IS_FAILURE = 0 THEN
					LOG_DER_HIT(p_EVENT_ID, v_DER_ID);
				END IF;

				DER_CAPACITY_ENGINE.STORE_EXTERNAL_DER_RESULTS(v_DER_ID,
					CONSTANTS.CODE_BACKCAST,
					v_PROGRAM_INTERVAL,
					p_SCHEDULE_DATES(v_IDX),
					p_SCHEDULE_AMOUNTS(v_IDX));
			END IF;

			-- Handle OptOuts, Overrides, and Failures
			IF v_OPTOUT_DATE IS NOT NULL THEN
				PUT_EVENT_EXCEPTION(p_EVENT_ID, v_DER_ID, DEMAND_RESPONSE_UTIL.c_EXCEPTION_TYPE_OPTOUT, v_OPTOUT_DATE);
			ELSIF v_OVERRIDE_DATE IS NOT NULL THEN
				PUT_EVENT_EXCEPTION(p_EVENT_ID, v_DER_ID, DEMAND_RESPONSE_UTIL.c_EXCEPTION_TYPE_OVERRIDE, v_OVERRIDE_DATE);
			ELSIF v_IS_FAILURE = 1 THEN
				PUT_EVENT_EXCEPTION(p_EVENT_ID, v_DER_ID, DEMAND_RESPONSE_UTIL.c_EXCEPTION_TYPE_FAILURE, SYSDATE);
			END IF;
		ELSE
				LOGS.LOG_ERROR('Could not update participation. No Device found for ' ||
					'Event = ' || TEXT_UTIL.TO_CHAR_ENTITY(p_EVENT_ID, EC.ED_DR_EVENT, TRUE) || ', ' ||
					'DER Type = ' || TEXT_UTIL.TO_CHAR_ENTITY(v_DER_TYPE_ID, EC.ED_DER_TYPE, TRUE) || ', ' ||
					'Premise = ' || TEXT_UTIL.TO_CHAR_ENTITY(v_PREMISE_ID, EC.ED_SERVICE_LOCATION, TRUE));
		END IF;

	END LOOP;

	DER_CAPACITY_ENGINE.AFTER_STORE_EXT_DER_RESULTS;
	CLEAR_EVENT_HITS_LIST;

	UPDATE_DEVICE_HISTORY(p_EVENT_ID);
	UPDATE_PROGRAM_HISTORY(p_EVENT_ID);
	UPDATE_EVENT_STATUS(p_EVENT_ID, DEMAND_RESPONSE_UTIL.c_EVENT_STATUS_ENDED);

	LOGS.STOP_PROCESS(v_FINISH_MESSAGE,v_STATUS);
	COMMIT;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.ABORT_PROCESS();
END IMPORT_PREMISE_RESULTS;
----------------------------------------------------------------------------------------------------
PROCEDURE IMPORT_DER_RESULTS
	(
	p_EVENT_ID             IN NUMBER,
	p_EXTERNAL_SYSTEM_ID   IN NUMBER,
	p_DER_IDS              IN NUMBER_COLLECTION,
	p_DER_IS_OVERRIDE_DATE IN DATE_COLLECTION,
	p_DER_IS_FAILURE_DATE  IN DATE_COLLECTION,
	p_SCHEDULE_DATES       IN DATE_COLLECTION_COLLECTION,
	p_SCHEDULE_AMOUNTS     IN NUMBER_COLLECTION_COLLECTION
	) AS
v_DER_ID DISTRIBUTED_ENERGY_RESOURCE.DER_ID%TYPE;
v_OVERRIDE_DATE DATE;
v_FAILURE_DATE  DATE;
v_PROGRAM_INTERVAL PROGRAM.PROGRAM_INTERVAL%TYPE;
v_FINISH_MESSAGE PROCESS_LOG.PROCESS_FINISH_TEXT%TYPE;
v_STATUS NUMBER(9);
BEGIN
	LOGS.START_PROCESS('Import DER Results');

	ASSERT(p_EVENT_ID IS NOT NULL, 'The Event Id must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_EVENT_ID > 0, 'Event Id = ' || p_EVENT_ID, MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_EXTERNAL_SYSTEM_ID IS NOT NULL, 'The External System must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_EXTERNAL_SYSTEM_ID > 0, 'External System Id = ' || p_EXTERNAL_SYSTEM_ID, MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_DER_IDS IS NOT NULL, 'The DER list must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_DER_IS_OVERRIDE_DATE IS NOT NULL, 'The DER Overide Date list must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_DER_IS_FAILURE_DATE IS NOT NULL, 'The DER Failure list must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_SCHEDULE_DATES IS NOT NULL, 'The Schedule Dates must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_SCHEDULE_AMOUNTS IS NOT NULL, 'The Schedule Amounts must not be null.', MSGCODES.c_ERR_ARGUMENT);

	LOGS.SET_PROCESS_TARGET_PARAMETER('EVENT_ID',TEXT_UTIL.TO_CHAR_ENTITY(p_EVENT_ID, EC.ED_DR_EVENT, TRUE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('EXTERNAL_SYSTEM_ID', TEXT_UTIL.TO_CHAR_ENTITY(p_EXTERNAL_SYSTEM_ID, EC.ED_EXTERNAL_SYSTEM, TRUE));

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('DER_IDS = ' || TEXT_UTIL.TO_CHAR_NUMBER_LIST(p_DER_IDS));
		LOGS.LOG_DEBUG('DER_IS_OVERRIDE_DATE = ' || TEXT_UTIL.TO_CHAR_TIME_LIST(p_DER_IS_OVERRIDE_DATE));
		LOGS.LOG_DEBUG('DER_IS_FAILURE_DATE = ' || TEXT_UTIL.TO_CHAR_TIME_LIST(p_DER_IS_FAILURE_DATE));
		LOGS.LOG_DEBUG('SCHEDULE_DATES = ' || TEXT_UTIL.TO_CHAR_2D_TIME_LIST(p_SCHEDULE_DATES));
		LOGS.LOG_DEBUG('SCHEDULE_AMOUNTS = ' || TEXT_UTIL.TO_CHAR_2D_NUMBER_LIST(p_SCHEDULE_AMOUNTS));
	END IF;

	SELECT NVL(MAX(P.PROGRAM_INTERVAL), '15 MINUTE')
	INTO v_PROGRAM_INTERVAL
	FROM DR_EVENT E, VPP V, PROGRAM P
	WHERE V.PROGRAM_ID = P.PROGRAM_ID
	  AND E.VPP_ID = V.VPP_ID
	  AND E.EVENT_ID = p_EVENT_ID;

	DER_CAPACITY_ENGINE.BEFORE_STORE_EXT_DER_RESULTS;
	CREATE_EVENT_HITS_LIST(p_EVENT_ID);

	FOR v_IDX IN p_DER_IDS.FIRST..p_DER_IDS.LAST LOOP
		-- initialize the locals
		v_DER_ID := p_DER_IDS(v_IDX);
		v_OVERRIDE_DATE := p_DER_IS_OVERRIDE_DATE(v_IDX);
		v_FAILURE_DATE := p_DER_IS_FAILURE_DATE(v_IDX);

		IF v_OVERRIDE_DATE IS NULL AND v_FAILURE_DATE IS NULL THEN
			-- Update the DR_EVENT_PARTICIPATION table
			PUT_EVENT_PARTICIPATION(p_EVENT_ID, v_DER_ID);

			-- Log Hits Used for the DER
			LOG_DER_HIT(p_EVENT_ID, v_DER_ID);

			-- Update the DER_DAILY_RESULT, LOAD_SHAPE_RESULT_ID, and LOAD_SHAPE_RESULT_DATA tables
			DER_CAPACITY_ENGINE.STORE_EXTERNAL_DER_RESULTS(v_DER_ID,
				CONSTANTS.CODE_BACKCAST,
				v_PROGRAM_INTERVAL,
				p_SCHEDULE_DATES(v_IDX),
				p_SCHEDULE_AMOUNTS(v_IDX));
		ELSE
			-- Override or Failure? Update the DR_EVENT_EXCEPTION table
			IF v_OVERRIDE_DATE IS NOT NULL AND v_FAILURE_DATE IS NOT NULL THEN
				-- Both an Override and Failure set, choose the one with the lowest date
				IF v_FAILURE_DATE < v_OVERRIDE_DATE THEN
					PUT_EVENT_EXCEPTION(p_EVENT_ID, v_DER_ID, DEMAND_RESPONSE_UTIL.c_EXCEPTION_TYPE_FAILURE, v_FAILURE_DATE);
				ELSE
					PUT_EVENT_EXCEPTION(p_EVENT_ID, v_DER_ID, DEMAND_RESPONSE_UTIL.c_EXCEPTION_TYPE_OVERRIDE, v_OVERRIDE_DATE);
				END IF;
			ELSIF v_OVERRIDE_DATE IS NOT NULL THEN
				PUT_EVENT_EXCEPTION(p_EVENT_ID, v_DER_ID, DEMAND_RESPONSE_UTIL.c_EXCEPTION_TYPE_OVERRIDE, v_OVERRIDE_DATE);
			ELSIF v_FAILURE_DATE IS NOT NULL THEN
				PUT_EVENT_EXCEPTION(p_EVENT_ID, v_DER_ID, DEMAND_RESPONSE_UTIL.c_EXCEPTION_TYPE_FAILURE, v_FAILURE_DATE);
			END IF;
		END IF;

	END LOOP;

	DER_CAPACITY_ENGINE.AFTER_STORE_EXT_DER_RESULTS;
	CLEAR_EVENT_HITS_LIST;

	UPDATE_DEVICE_HISTORY(p_EVENT_ID);
	UPDATE_PROGRAM_HISTORY(p_EVENT_ID);
	UPDATE_EVENT_STATUS(p_EVENT_ID, DEMAND_RESPONSE_UTIL.c_EVENT_STATUS_ENDED);

	LOGS.STOP_PROCESS(v_FINISH_MESSAGE,v_STATUS);
	COMMIT;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.ABORT_PROCESS();
END IMPORT_DER_RESULTS;
--------------------------------------------------------------------------------
PROCEDURE IMPORT_DERMS_FORECAST
	(
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_PROGRAM_ID         IN NUMBER,
	p_FEEDER_SEGMENT_IDS IN NUMBER_COLLECTION,
	p_DATES              IN DATE_COLLECTION_COLLECTION,
	p_AVAILABILTY        IN NUMBER_COLLECTION_COLLECTION,
	p_CAPABILITY         IN NUMBER_COLLECTION_COLLECTION,
	p_DER_COUNT          IN NUMBER_COLLECTION_COLLECTION
	) AS
v_FINISH_MESSAGE PROCESS_LOG.PROCESS_FINISH_TEXT%TYPE;
v_STATUS NUMBER(9);
BEGIN
	LOGS.START_PROCESS('Import DERMS Forecast');

	ASSERT(p_EXTERNAL_SYSTEM_ID IS NOT NULL, 'The External System must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_EXTERNAL_SYSTEM_ID > 0, 'External System Id = ' || p_EXTERNAL_SYSTEM_ID, MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_PROGRAM_ID IS NOT NULL, 'The Program must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_PROGRAM_ID > 0, 'Program Id = ' || p_PROGRAM_ID, MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_FEEDER_SEGMENT_IDS IS NOT NULL, 'The Feeder Segment list must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_DATES IS NOT NULL, 'The Forecast Dates must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_AVAILABILTY IS NOT NULL, 'The Forecast Availablity list must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_CAPABILITY IS NOT NULL, 'The Forecast Capability list must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_DER_COUNT IS NOT NULL, 'The Forecast DER Count list must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_FEEDER_SEGMENT_IDS.COUNT = p_DATES.COUNT AND p_DATES.COUNT = p_AVAILABILTY.COUNT
		AND p_AVAILABILTY.COUNT = p_CAPABILITY.COUNT AND p_CAPABILITY.COUNT = p_DER_COUNT.COUNT,
		'The feeder segments, dates, availability, capability, and der count must be of the same size.', MSGCODES.c_ERR_ARGUMENT);

	LOGS.SET_PROCESS_TARGET_PARAMETER('EXTERNAL_SYSTEM_ID', TEXT_UTIL.TO_CHAR_ENTITY(p_EXTERNAL_SYSTEM_ID, EC.ED_EXTERNAL_SYSTEM, TRUE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('PROGRAM_ID', TEXT_UTIL.TO_CHAR_ENTITY(p_PROGRAM_ID, EC.ED_PROGRAM, TRUE));

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('FEEDER_SEGMENT_IDS = ' || TEXT_UTIL.TO_CHAR_NUMBER_LIST(p_FEEDER_SEGMENT_IDS));
		LOGS.LOG_DEBUG('DATES = ' || TEXT_UTIL.TO_CHAR_2D_TIME_LIST(p_DATES));
		LOGS.LOG_DEBUG('AVAILABILTY = ' || TEXT_UTIL.TO_CHAR_2D_NUMBER_LIST(p_AVAILABILTY));
		LOGS.LOG_DEBUG('CAPABILITY = ' || TEXT_UTIL.TO_CHAR_2D_NUMBER_LIST(p_CAPABILITY));
		LOGS.LOG_DEBUG('DER_COUNT = ' ||  TEXT_UTIL.TO_CHAR_2D_NUMBER_LIST(p_DER_COUNT));
	END IF;

	FOR v_IDX IN p_FEEDER_SEGMENT_IDS.FIRST..p_FEEDER_SEGMENT_IDS.LAST LOOP
		DER_CAPACITY_ENGINE.PUT_SEGMENT_EXTERNAL_RESULT(
			p_EXTERNAL_SYSTEM_ID,
			p_FEEDER_SEGMENT_IDS(v_IDX),
			p_PROGRAM_ID,
			p_DATES(v_IDX),
			p_AVAILABILTY(v_IDX),
			p_CAPABILITY(v_IDX),
			p_DER_COUNT(v_IDX),
			CONSTANTS.CODE_FORECAST,
			GA.BASE_SCENARIO_ID);
	END LOOP;

	LOGS.STOP_PROCESS(v_FINISH_MESSAGE,v_STATUS);
	COMMIT;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.ABORT_PROCESS();
END IMPORT_DERMS_FORECAST;
--------------------------------------------------------------------------------
PROCEDURE IMPORT_FEEDER_SEGMENT_PRIORITY
	(
	p_FEEDER_SEGMENT_IDS IN NUMBER_COLLECTION,
	p_PRIORITIES         IN NUMBER_COLLECTION
	) AS
v_FINISH_MESSAGE PROCESS_LOG.PROCESS_FINISH_TEXT%TYPE;
v_STATUS NUMBER(9);
BEGIN
	LOGS.START_PROCESS('Import Feeder Segment Priority');

	ASSERT(p_FEEDER_SEGMENT_IDS IS NOT NULL, 'The Feeder Segment list must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_PRIORITIES IS NOT NULL, 'The Priorities list must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_FEEDER_SEGMENT_IDS.COUNT = p_PRIORITIES.COUNT,
		'The Feeder Segments and Priorities must be of the same size.', MSGCODES.c_ERR_ARGUMENT);

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('FEEDER_SEGMENT_IDS = ' ||  TEXT_UTIL.TO_CHAR_NUMBER_LIST(p_FEEDER_SEGMENT_IDS));
		LOGS.LOG_DEBUG('PRIORITIES = ' || TEXT_UTIL.TO_CHAR_NUMBER_LIST(p_PRIORITIES));
	END IF;

	FORALL v_IDX IN 1..P_FEEDER_SEGMENT_IDS.COUNT()
		UPDATE TX_FEEDER_SEGMENT
		SET PRIORITY = P_PRIORITIES(v_IDX)
		WHERE FEEDER_SEGMENT_ID = P_FEEDER_SEGMENT_IDS(v_IDX);

	LOGS.STOP_PROCESS(v_FINISH_MESSAGE,v_STATUS);
	COMMIT;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.ABORT_PROCESS();
END IMPORT_FEEDER_SEGMENT_PRIORITY;
--------------------------------------------------------------------------------
PROCEDURE CHECK_VPP_ALIASES
	(
	p_VPP_IDS IN NUMBER_COLLECTION,
	p_INCLUDE_ALL IN NUMBER
	) AS

	v_ALIAS_CONFLICT_COUNT NUMBER(9);
	v_NULL_ALIAS_COUNT NUMBER(9);

	v_ERR_MESSAGE VARCHAR2(500);

BEGIN

	-- CHECK TO SEE THAT ALL THE VPPS HAVE UNIQUE, NON-NULL VPP ALIASES
	SELECT SUM(CASE WHEN VPP.VPP_ALIAS IS NULL THEN 1 ELSE 0 END),
		SUM((SELECT MAX(1) FROM VIRTUAL_POWER_PLANT V WHERE V.VPP_ALIAS = VPP.VPP_ALIAS
															AND V.VPP_ID <> VPP.VPP_ID))
	INTO v_NULL_ALIAS_COUNT, v_ALIAS_CONFLICT_COUNT
	FROM VIRTUAL_POWER_PLANT VPP,
		TABLE(CAST(p_VPP_IDs AS NUMBER_COLLECTION)) X
	WHERE (VPP.VPP_ID = X.COLUMN_VALUE AND p_INCLUDE_ALL = 0)
		OR (p_INCLUDE_ALL = 1 AND X.COLUMN_VALUE = CONSTANTS.ALL_ID);

	IF v_NULL_ALIAS_COUNT <> 0 THEN
		v_ERR_MESSAGE := 'There are ' || v_NULL_ALIAS_COUNT || ' VPP(s) with null aliases.';
	END IF;

	IF v_ALIAS_CONFLICT_COUNT <> 0 THEN
		IF v_ERR_MESSAGE IS NOT NULL THEN
			v_ERR_MESSAGE := v_ERR_MESSAGE || '  Also, t';
		ELSE
			v_ERR_MESSAGE := 'T';
		END IF;
		v_ERR_MESSAGE := v_ERR_MESSAGE || 'here are ' || v_ALIAS_CONFLICT_COUNT || ' VPPs with the same alias as another VPP.';
	END IF;

	IF v_ERR_MESSAGE IS NOT NULL THEN
		ERRS.RAISE_BAD_ARGUMENT('VPP_IDS', TEXT_UTIL.TO_CHAR_ENTITY_LIST(p_VPP_IDs, EC.ED_VPP),
		 	v_ERR_MESSAGE);
	END IF;

END CHECK_VPP_ALIASES;
--------------------------------------------------------------------------------
PROCEDURE VPP_SCHEDULES
	(
	p_VPP_IDs IN NUMBER_COLLECTION,
	p_CUT_BEGIN_DATE IN DATE,
	p_CUT_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SCHEDULE_UNIT OUT VARCHAR2,
	p_CURSOR OUT t_cur_VPP_SCHEDULE,
	p_SERVICE_CODE IN CHAR := 'F',
	p_IS_EXTERNAL IN NUMBER := 0
	) AS
v_INCLUDE_ALL_VPPs NUMBER(1) := 0;
v_VPP_SCHEDULES_AS_MW SYSTEM_DICTIONARY.VALUE%TYPE;
v_IS_EXTERNAL NUMBER(1) := NVL(p_IS_EXTERNAL, 0);
BEGIN

	-- Check if the VPP_IDs collection includes 'All' VPPs
	SELECT CASE WHEN COUNT(1) > 0 THEN 1 ELSE 0 END INTO v_INCLUDE_ALL_VPPs
	FROM TABLE(CAST(p_VPP_IDs AS NUMBER_COLLECTION)) X
	WHERE X.COLUMN_VALUE = CONSTANTS.ALL_ID;

	CHECK_VPP_ALIASES(p_VPP_IDs, v_INCLUDE_ALL_VPPs);

	-- Get the System Dictionary flag for MW to MWH conversion
	SP.GET_SYSTEM_DICTIONARY_VALUE(0,
								'Load Management',
								'Demand Response',
								'?',
								'?',
								'VPP Schedules in MW',
								v_VPP_SCHEDULES_AS_MW);

	-- Set the Schedule Unit
	IF UT.BOOLEAN_FROM_STRING(v_VPP_SCHEDULES_AS_MW) THEN
		p_SCHEDULE_UNIT := 'MW';
	ELSE
		p_SCHEDULE_UNIT := 'MWh';
	END IF;

	OPEN p_CURSOR FOR
		SELECT DISTINCT D.RESULT_DATE AS CUT_DATE,
			SUBSTR(FROM_CUT_AS_HED(D.RESULT_DATE, p_TIME_ZONE, GET_INTERVAL_ABBREVIATION(P.PROGRAM_INTERVAL)), 1, 10) AS SCHEDULE_DAY,
			SUBSTR(FROM_CUT_AS_HED(D.RESULT_DATE, p_TIME_ZONE, GET_INTERVAL_ABBREVIATION(P.PROGRAM_INTERVAL)), 12) AS SCHEDULE_TIME,
			VPP.VPP_ID,
			VPP.VPP_NAME,
			VPP.VPP_ALIAS,
			CASE WHEN p_SERVICE_CODE = CONSTANTS.CODE_FORECAST
				THEN c_RESULT_TYPE_FORECAST
				ELSE c_RESULT_TYPE_BACKCAST
			END AS RESULT_TYPE,
			CASE WHEN p_SERVICE_CODE = CONSTANTS.CODE_FORECAST
				THEN c_RESULT_TYPE_FORECAST || ' (' || p_SCHEDULE_UNIT || ')'
				ELSE c_RESULT_TYPE_BACKCAST || ' (' || p_SCHEDULE_UNIT || ')'
			END AS RESULT_TYPE_DISP,
			(D.LOAD_VAL + D.FAILURE_VAL + D.OPT_OUT_VAL + D.OVERRIDE_VAL
					+ D.TX_LOSS_VAL + D.DX_LOSS_VAL) *
				-- Convert from MWh to MW if the System Dictionary flag is set to true
				(CASE WHEN p_SCHEDULE_UNIT = 'MWh'
					THEN 1
					ELSE DATE_UTIL.GET_INTERVAL_DIVISOR('', P.PROGRAM_INTERVAL, D.RESULT_DATE, p_TIME_ZONE)
				END) AS NEW_AMOUNT,
			SCHED.AMOUNT AS CURRENT_AMOUNT
		FROM (SELECT Y.*
		      FROM TABLE(CAST(p_VPP_IDs AS NUMBER_COLLECTION)) X, VIRTUAL_POWER_PLANT Y
			  WHERE (v_INCLUDE_ALL_VPPs = 1 OR Y.VPP_ID = X.COLUMN_VALUE)) VPP,
			DER_VPP_RESULT R,
			DER_VPP_RESULT_DATA D,
			PROGRAM	P,
			(SELECT R.DER_VPP_RESULT_ID, IT.SCHEDULE_DATE, IT.AMOUNT
			FROM INTERCHANGE_TRANSACTION T,
				IT_SCHEDULE IT,
				(SELECT Y.*
		      	 FROM TABLE(CAST(p_VPP_IDs AS NUMBER_COLLECTION)) X, VIRTUAL_POWER_PLANT Y
			  	 WHERE (v_INCLUDE_ALL_VPPs = 1 OR Y.VPP_ID = X.COLUMN_VALUE)) VPP,
				DER_VPP_RESULT R
			WHERE T.TRANSACTION_NAME = VPP.VPP_ALIAS || ' Results'
				AND R.SERVICE_ZONE_ID = VPP.SERVICE_ZONE_ID
				AND R.PROGRAM_ID = VPP.PROGRAM_ID
				AND R.IS_EXTERNAL = v_IS_EXTERNAL
				AND R.SERVICE_CODE = p_SERVICE_CODE
				AND R.SCENARIO_ID = GA.BASE_SCENARIO_ID
				AND IT.TRANSACTION_ID = T.TRANSACTION_ID
				AND IT.SCHEDULE_TYPE = CASE WHEN p_SERVICE_CODE = CONSTANTS.CODE_FORECAST THEN 1 ELSE 3 END
				AND IT.SCHEDULE_STATE = CASE WHEN v_IS_EXTERNAL = 1 THEN 2 ELSE 1 END
				AND IT.SCHEDULE_DATE BETWEEN p_CUT_BEGIN_DATE AND p_CUT_END_DATE) SCHED
		WHERE R.IS_EXTERNAL = v_IS_EXTERNAL
			AND R.SERVICE_CODE = p_SERVICE_CODE
			AND D.DER_VPP_RESULT_ID = R.DER_VPP_RESULT_ID
			AND R.SERVICE_ZONE_ID = VPP.SERVICE_ZONE_ID
			AND R.PROGRAM_ID = VPP.PROGRAM_ID
			AND R.SCENARIO_ID = GA.BASE_SCENARIO_ID
			AND D.RESULT_DATE BETWEEN p_CUT_BEGIN_DATE AND p_CUT_END_DATE
			AND P.PROGRAM_ID = VPP.PROGRAM_ID
			AND SCHED.DER_VPP_RESULT_ID (+) = D.DER_VPP_RESULT_ID
			AND SCHED.SCHEDULE_DATE (+) = D.RESULT_DATE

		UNION ALL

		SELECT D.RESULT_DATE AS CUT_DATE,
			SUBSTR(FROM_CUT_AS_HED(D.RESULT_DATE, p_TIME_ZONE, GET_INTERVAL_ABBREVIATION(P.PROGRAM_INTERVAL)), 1, 10) AS SCHEDULE_DAY,
			SUBSTR(FROM_CUT_AS_HED(D.RESULT_DATE, p_TIME_ZONE, GET_INTERVAL_ABBREVIATION(P.PROGRAM_INTERVAL)), 12) AS SCHEDULE_TIME,
			VPP.VPP_ID,
			VPP.VPP_NAME,
			VPP.VPP_ALIAS,
			c_RESULT_TYPE_UNCONSTRAINED AS RESULT_TYPE,
			c_RESULT_TYPE_UNCONSTRAINED || ' (' || p_SCHEDULE_UNIT || ')' AS RESULT_TYPE_DISP,
			(D.UNCONSTRAINED_LOAD_VAL + NVL(D.UNCONSTRAINED_TX_LOSS_VAL,0) +
				NVL(D.UNCONSTRAINED_DX_LOSS_VAL,0)) *
				-- Convert from MWh to MW if the System Dictionary flag is set to true
				(CASE WHEN p_SCHEDULE_UNIT = 'MWh'
					THEN 1
					ELSE DATE_UTIL.GET_INTERVAL_DIVISOR('', P.PROGRAM_INTERVAL, D.RESULT_DATE, p_TIME_ZONE)
				END) AS NEW_AMOUNT,
			SCHED.AMOUNT AS CURRENT_AMOUNT
		FROM (SELECT Y.*
			  FROM TABLE(CAST(p_VPP_IDs AS NUMBER_COLLECTION)) X, VIRTUAL_POWER_PLANT Y
			  WHERE ((v_INCLUDE_ALL_VPPs = 1 OR Y.VPP_ID = X.COLUMN_VALUE)
			    -- Only Include Unconstrained Schedule if this is SERVICE_CODE = 'F'
			    AND p_SERVICE_CODE = CONSTANTS.CODE_FORECAST)) VPP,
			DER_VPP_RESULT R,
			DER_VPP_RESULT_DATA D,
			PROGRAM	P,
			(SELECT R.DER_VPP_RESULT_ID, IT.SCHEDULE_DATE, IT.AMOUNT
			FROM INTERCHANGE_TRANSACTION T,
				IT_SCHEDULE IT,
				(SELECT Y.*
		      	 FROM TABLE(CAST(p_VPP_IDs AS NUMBER_COLLECTION)) X, VIRTUAL_POWER_PLANT Y
			  	 WHERE ((v_INCLUDE_ALL_VPPs = 1 OR Y.VPP_ID = X.COLUMN_VALUE)
				   -- Only Include Unconstrained Schedule if this is SERVICE_CODE = 'F'
				   AND p_SERVICE_CODE = CONSTANTS.CODE_FORECAST)) VPP,
				DER_VPP_RESULT R
			WHERE T.TRANSACTION_NAME = VPP.VPP_ALIAS || ' Unconstrained Results'
				AND R.SERVICE_ZONE_ID = VPP.SERVICE_ZONE_ID
				AND R.PROGRAM_ID = VPP.PROGRAM_ID
				AND R.IS_EXTERNAL = v_IS_EXTERNAL
				AND R.SERVICE_CODE = p_SERVICE_CODE
				AND R.SCENARIO_ID = GA.BASE_SCENARIO_ID
				AND IT.TRANSACTION_ID = T.TRANSACTION_ID
				AND IT.SCHEDULE_TYPE = 1
				AND IT.SCHEDULE_STATE = CASE WHEN v_IS_EXTERNAL = 1 THEN 2 ELSE 1 END
				AND IT.SCHEDULE_DATE BETWEEN p_CUT_BEGIN_DATE AND p_CUT_END_DATE) SCHED
		WHERE R.IS_EXTERNAL = v_IS_EXTERNAL
			AND R.SERVICE_CODE = CONSTANTS.CODE_FORECAST
			AND D.DER_VPP_RESULT_ID = R.DER_VPP_RESULT_ID
			AND R.SERVICE_ZONE_ID = VPP.SERVICE_ZONE_ID
			AND R.PROGRAM_ID = VPP.PROGRAM_ID
			AND R.SCENARIO_ID = GA.BASE_SCENARIO_ID
			AND D.RESULT_DATE BETWEEN p_CUT_BEGIN_DATE AND p_CUT_END_DATE
			AND P.PROGRAM_ID = VPP.PROGRAM_ID
			AND SCHED.DER_VPP_RESULT_ID (+) = D.DER_VPP_RESULT_ID
			AND SCHED.SCHEDULE_DATE (+) = D.RESULT_DATE

		ORDER BY VPP_ID, RESULT_TYPE, CUT_DATE;

END VPP_SCHEDULES;
--------------------------------------------------------------------------------
PROCEDURE GET_VPP_MIN_MAX_DATES
	(
	p_VPP_ID IN NUMBER,
	p_SERVICE_CODE IN CHAR,
	p_IS_EXTERNAL IN NUMBER,
	p_CUT_BEGIN_DATE IN DATE,
	p_CUT_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_MIN_DATE OUT DATE,
	p_MAX_DATE OUT DATE
	) AS

BEGIN

	SELECT MIN(D.RESULT_DATE), MAX(D.RESULT_DATE)
	INTO p_MIN_DATE, p_MAX_DATE
	FROM DER_VPP_RESULT R,
		DER_VPP_RESULT_DATA D,
		VIRTUAL_POWER_PLANT VPP
	WHERE VPP.VPP_ID = p_VPP_ID
		AND R.PROGRAM_ID = VPP.PROGRAM_ID
		AND R.SERVICE_ZONE_ID = VPP.SERVICE_ZONE_ID
		AND R.IS_EXTERNAL = p_IS_EXTERNAL
		AND R.SERVICE_CODE = p_SERVICE_CODE
		AND R.SCENARIO_ID = GA.BASE_SCENARIO_ID
		AND D.DER_VPP_RESULT_ID = R.DER_VPP_RESULT_ID
		AND D.RESULT_DATE BETWEEN p_CUT_BEGIN_DATE AND p_CUT_END_DATE;

	p_MIN_DATE := DATE_UTIL.HED_TRUNC(FROM_CUT(p_MIN_DATE, p_TIME_ZONE), 'DD');
	p_MAX_DATE := DATE_UTIL.HED_TRUNC(FROM_CUT(p_MAX_DATE, p_TIME_ZONE), 'DD');

END GET_VPP_MIN_MAX_DATES;
--------------------------------------------------------------------------------
PROCEDURE ACCEPT_VPPS_INTO_SCHEDULES
	(
	p_CUT_BEGIN_DATE IN DATE,
	p_CUT_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SERVICE_CODE IN CHAR := 'F',
	p_IS_EXTERNAL IN NUMBER := 0,
	p_VPP_IDs IN NUMBER_COLLECTION := NUMBER_COLLECTION(-1)
	) AS
	c_VPP_SCHEDULES t_cur_VPP_SCHEDULE;
	v_SCHEDULE_UNIT VARCHAR2(8);

	-- VPP Schedule Cursor variables
	v_REC_VPP_SCHEDULE t_VPP_SCHEDULE;
	v_PREV_VPP_ID VPP.VPP_ID%TYPE := -1;
	v_PREV_RESULT_TYPE VARCHAR2(32) := 'FIRST';

	-- Interchange Transaction variables
	v_OID INTERCHANGE_TRANSACTION.TRANSACTION_ID%TYPE;
	v_BEGIN_DATE INTERCHANGE_TRANSACTION.BEGIN_DATE%TYPE;
	v_END_DATE INTERCHANGE_TRANSACTION.END_DATE%TYPE;
	v_TRANSACTION_ID INTERCHANGE_TRANSACTION.TRANSACTION_ID%TYPE;
	v_TXN_NAME INTERCHANGE_TRANSACTION.TRANSACTION_NAME%TYPE;

	v_TXN_FOUND NUMBER(1);
	v_STATUS NUMBER;

	v_PROGRAM_INTERVAL PROGRAM.PROGRAM_INTERVAL%TYPE;
	v_SERVICE_ZONE_ID SERVICE_ZONE.SERVICE_ZONE_ID%TYPE;

	c_ENT_ATT_VPP_CAPABILITY_SCHED CONSTANT ENTITY_ATTRIBUTE.ATTRIBUTE_NAME%TYPE := 'Accepted VPP Capability Schedule';
	c_ENT_ATT_VPP_RESULTS_SCHED CONSTANT ENTITY_ATTRIBUTE.ATTRIBUTE_NAME%TYPE := 'Accepted VPP Results Schedule';

	v_MIN_DATE DATE;
	v_MAX_DATE DATE;

	v_IS_EXTERNAL NUMBER(1) := NVL(p_IS_EXTERNAL, 0);

BEGIN

	VPP_SCHEDULES(p_VPP_IDs, p_CUT_BEGIN_DATE, p_CUT_END_DATE, CUT_TIME_ZONE(), v_SCHEDULE_UNIT, c_VPP_SCHEDULES, p_SERVICE_CODE, v_IS_EXTERNAL);

	LOOP
		FETCH c_VPP_SCHEDULES INTO v_REC_VPP_SCHEDULE;
		EXIT WHEN c_VPP_SCHEDULES%NOTFOUND;

		IF v_PREV_VPP_ID <> v_REC_VPP_SCHEDULE.VPP_ID
			OR v_PREV_RESULT_TYPE <> v_REC_VPP_SCHEDULE.RESULT_TYPE  THEN

			v_PREV_VPP_ID := v_REC_VPP_SCHEDULE.VPP_ID;
			v_PREV_RESULT_TYPE := v_REC_VPP_SCHEDULE.RESULT_TYPE;

			-- Generate a transaction name <VPP Alias> Results
			v_TXN_NAME := v_REC_VPP_SCHEDULE.VPP_ALIAS ||
				CASE WHEN v_REC_VPP_SCHEDULE.RESULT_TYPE = c_RESULT_TYPE_UNCONSTRAINED THEN
						' Unconstrained Results'
				ELSE ' Results' END;

			-- Check if the TXN already exists
			SELECT CASE WHEN COUNT(1) > 0 THEN 1 ELSE 0 END INTO v_TXN_FOUND
			FROM INTERCHANGE_TRANSACTION
			WHERE TRANSACTION_NAME = v_TXN_NAME;

			IF v_TXN_FOUND = 1 THEN
				SELECT TRANSACTION_ID, BEGIN_DATE, END_DATE
				INTO v_TRANSACTION_ID, v_BEGIN_DATE, v_END_DATE
				FROM INTERCHANGE_TRANSACTION
				WHERE TRANSACTION_NAME = v_TXN_NAME;

				GET_VPP_MIN_MAX_DATES(v_REC_VPP_SCHEDULE.VPP_ID,
									  p_SERVICE_CODE,
									  v_IS_EXTERNAL,
									  p_CUT_BEGIN_DATE,
									  p_CUT_END_DATE,
									  p_TIME_ZONE,
									  v_MIN_DATE,
									  v_MAX_DATE);

				v_BEGIN_DATE := LEAST(v_BEGIN_DATE, v_MIN_DATE);
				v_END_DATE := GREATEST(v_END_DATE, v_MAX_DATE);
			ELSE
				-- Create new transaction
				v_TRANSACTION_ID := 0;
				-- Begin and End Date of the VPP schecule
				GET_VPP_MIN_MAX_DATES(v_REC_VPP_SCHEDULE.VPP_ID,
										  p_SERVICE_CODE,
										  v_IS_EXTERNAL,
										  p_CUT_BEGIN_DATE,
										  p_CUT_END_DATE,
										  p_TIME_ZONE,
										  v_BEGIN_DATE,
										  v_END_DATE);
			END IF;

			-- Get the Program Interval and VPP Service Zone
			SELECT P.PROGRAM_INTERVAL, VPP.SERVICE_ZONE_ID
			INTO v_PROGRAM_INTERVAL, v_SERVICE_ZONE_ID
			FROM PROGRAM P, VIRTUAL_POWER_PLANT VPP
			WHERE VPP.VPP_ID = v_REC_VPP_SCHEDULE.VPP_ID
				AND P.PROGRAM_ID = VPP.PROGRAM_ID;

			-- Update or create a new Transaction
			EM.PUT_TRANSACTION(
					v_OID,--O_OID,
					v_TXN_NAME,--P_TRANSACTION_NAME,
					v_TXN_NAME,--P_TRANSACTION_ALIAS,
					v_TXN_NAME,--P_TRANSACTION_DESC,
					v_TRANSACTION_ID,--P_TRANSACTION_ID,
					'Active',--P_TRANSACTION_STATUS
					CASE WHEN v_REC_VPP_SCHEDULE.RESULT_TYPE = c_RESULT_TYPE_UNCONSTRAINED
							THEN 'Unconstr. Limit'
					 	ELSE 'Limit' END,
					NULL,--P_TRANSACTION_IDENTIFIER,
					0, -- --P_IS_FIRM,
					0,--P_IS_IMPORT_SCHEDULE,
					0,--P_IS_EXPORT_SCHEDULE,
					0,--P_IS_BALANCE_TRANSACTION,
					0,--P_IS_BID_OFFER,
					0,--P_IS_EXCLUDE_FROM_POSITION,
					0,--P_IS_IMPORT_EXPORT,
					0,--P_IS_DISPATCHABLE,
					v_PROGRAM_INTERVAL,--P_TRANSACTION_INTERVAL,
					NULL,--P_EXTERNAL_INTERVAL,
					NULL,--P_ETAG_CODE,
					v_BEGIN_DATE,--P_BEGIN_DATE,
					v_END_DATE,--p_END_DATE,
					0,--P_PURCHASER_ID,
					0,--P_SELLER_ID,
					0,--P_CONTRACT_ID,
					0,--P_SC_ID,
					0,--P_POR_ID,
					0,--P_POD_ID,
					CASE WHEN v_SCHEDULE_UNIT = 'MW' THEN EI.GET_ID_FROM_NAME('Capacity',EC.ED_IT_COMMODITY) ELSE EI.GET_ID_FROM_NAME('Energy',EC.ED_IT_COMMODITY) END,-- P_COMMODITY_ID,
					0,--P_SERVICE_TYPE_ID,
					0,--P_TX_TRANSACTION_ID,
					0,--P_PATH_ID,
					0,--P_LINK_TRANSACTION_ID,
					0,--P_EDC_ID,
					NULL, --P_PSE_ID,
					0,--P_ESP_ID,
					0,--P_POOL_ID,
					0,--P_SCHEDULE_GROUP_ID,
					0,--P_MARKET_PRICE_ID,
					0,--P_ZOR_ID,
					v_SERVICE_ZONE_ID,--P_ZOD_ID,
					0,--P_SOURCE_ID,
					0,--P_SINK_ID,
					0,--P_RESOURCE_ID,
					0,--P_AGREEMENT_TYPE,
					NULL,--P_APPROVAL_TYPE,
					NULL,--P_LOSS_OPTION,
					NULL,--P_TRAIT_CATEGORY,
					0--P_TP_ID
					);

			-- Set the Entity Attribute flag
			RO.PUT_ENTITY_ATTRIBUTE(p_ATTRIBUTE_NAME => CASE WHEN p_SERVICE_CODE = 'F' THEN c_ENT_ATT_VPP_CAPABILITY_SCHED ELSE c_ENT_ATT_VPP_RESULTS_SCHED END,
									p_ENTITY_DOMAIN_ID => EC.ED_TRANSACTION,
									p_OWNER_ENTITY_ID  => v_OID,
									p_ATTRIBUTE_TYPE   => 'Boolean',
									p_ATTRIBUTE_VAL    => '1',
									p_BEGIN_DATE       => v_BEGIN_DATE,
									p_END_DATE         => v_END_DATE);

			v_TRANSACTION_ID := v_OID;
		END IF;

		-- Update the IT_SCHEDULE
		ITJ.PUT_IT_SCHEDULE(p_TRANSACTION_ID => v_TRANSACTION_ID,
							p_SCHEDULE_TYPE => CASE WHEN p_SERVICE_CODE = CONSTANTS.CODE_FORECAST THEN 1 ELSE 3 END,
							p_SCHEDULE_STATE => CASE WHEN v_IS_EXTERNAL = 1 THEN 2 ELSE 1 END,
							p_SCHEDULE_DATE => v_REC_VPP_SCHEDULE.CUT_DATE,
							p_AS_OF_DATE => LOW_DATE,
							p_AMOUNT => v_REC_VPP_SCHEDULE.NEW_AMOUNT,
							p_PRICE => NULL,
							p_STATUS => v_STATUS);
	END LOOP;

 	CLOSE c_VPP_SCHEDULES;

		-- Now call the XS hook
	XS.AFTER_ACCEPT_VPPS_TO_SCHEDULES(p_CUT_BEGIN_DATE, p_CUT_END_DATE, p_TIME_ZONE, p_SERVICE_CODE, p_IS_EXTERNAL, p_VPP_IDs);

	EXCEPTION
		WHEN OTHERS THEN
			BEGIN
				IF c_VPP_SCHEDULES%ISOPEN THEN
					CLOSE c_VPP_SCHEDULES;
				END IF;
			EXCEPTION
				WHEN OTHERS THEN
					ERRS.LOG_AND_CONTINUE;
			END;
			ERRS.LOG_AND_RAISE;

END ACCEPT_VPPS_INTO_SCHEDULES;
--------------------------------------------------------------------------------
END DEMAND_RESPONSE;
/
