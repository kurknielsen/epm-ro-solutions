CREATE OR REPLACE PACKAGE TG AS
--Revision $Revision: 1.32 $

-- Transaction Traits and Groups package

FUNCTION WHAT_VERSION RETURN VARCHAR;

FUNCTION TO_CHAR_TRAIT_VAL
(
	p_TRAIT_VAL IN VARCHAR2,
	p_DATA_TYPE IN VARCHAR2
) RETURN VARCHAR2;

PROCEDURE FIND_TRANSACTION_LIST
	(
	p_SEARCH_STRING IN VARCHAR,
	p_SEARCH_BY_ALIAS IN NUMBER,
	p_INCLUDE_INACTIVE IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_MODEL_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE IT_TRAIT_STATUS_DETAIL
	(
	p_TRANSACTION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE IT_TRAIT_STATUS_SUMMARY_TOP
	(
	p_SC_ID IN NUMBER,
	p_TRANSACTION_TYPE IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE IT_TRAIT_STATUS_SUMMARY_LOW
	(
	p_SC_ID IN NUMBER,
	p_TRANSACTION_TYPE IN VARCHAR2,
	p_POD_ID IN NUMBER,
	p_SCHEDULE_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_IT_TRAIT_SCHED_TRAIT_RPT
    (
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_REPORT_TYPE IN VARCHAR2,
	p_TRAIT_GROUP_FILTER IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_DATE_OFFSET IN NUMBER DEFAULT 0,
	p_INTERVAL IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR,
	p_TRADING_DATE_OFFSET IN NUMBER DEFAULT NULL
	);

PROCEDURE PUT_IT_TRAIT_SCHEDULE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_DATE IN DATE,
	p_TRAIT_GROUP_ID IN NUMBER,
	p_TRAIT_INDEX IN NUMBER,
	p_SET_NUMBER IN NUMBER,
	p_TRAIT_VAL IN VARCHAR,
	p_TIME_ZONE IN VARCHAR
	);

PROCEDURE PUT_IT_TRAIT_SCHEDULE_AS_CUT
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_CUT_DATE_SCHEDULING IN DATE,
	p_TRAIT_GROUP_ID IN NUMBER,
	p_TRAIT_INDEX IN NUMBER,
	p_SET_NUMBER IN NUMBER,
	p_TRAIT_VAL IN VARCHAR
	);

PROCEDURE GET_IT_TRAIT_SCHED_SPARSE_RPT
    (
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_REPORT_TYPE IN VARCHAR2,
	p_TRAIT_GROUP_FILTER IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_DATE_OFFSET IN NUMBER DEFAULT 0,
	p_INTERVAL IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE GET_IT_TRAIT_SPARSE_SERIES_RPT
    (
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_REPORT_TYPE IN VARCHAR2,
	p_TRAIT_GROUP_FILTER IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_DATE_OFFSET IN NUMBER DEFAULT 0,
	p_INTERVAL IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PUT_IT_TRAIT_SCHED_SPARSE_RPT
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_DATE IN DATE,
	p_SCHEDULE_TIME IN VARCHAR2,
	p_SCHEDULE_END_DATE IN DATE,
	p_SCHEDULE_END_TIME IN VARCHAR2,
	p_TRAIT_GROUP_INDEX_ID IN NUMBER,
	p_SET_NUMBER IN NUMBER,
	p_TRAIT_VAL IN VARCHAR,
	p_ORIG_SCHEDULE_DATE IN DATE,
	p_OLD_TRAIT_GROUP_INDEX_ID IN NUMBER,
	p_OLD_SET_NUMBER IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_IT_TRAIT_SCHEDULE_SPARSE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_DATE IN DATE,
	p_SCHEDULE_END_DATE IN DATE,
	p_TRAIT_GROUP_ID IN NUMBER,
	p_TRAIT_INDEX IN NUMBER,
	p_SET_NUMBER IN NUMBER,
	p_TRAIT_VAL IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_IT_TRAIT_SCHED_DETAIL_RPT
    (
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_REPORT_TYPE IN VARCHAR2,
	p_TRAIT_GROUP_FILTER IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_DATE_OFFSET IN NUMBER DEFAULT 0,
	p_INTERVAL IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PUT_IT_TRAIT_SCHED_DETAIL_RPT
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_CUT_DATE_SCHEDULING IN DATE,
	p_TRAIT_GROUP_ID IN NUMBER,
	p_TRAIT_INDEX IN NUMBER,
	p_SET_NUMBER IN NUMBER,
	p_TRAIT_VAL IN VARCHAR,
	p_REASON_FOR_CHANGE IN VARCHAR2,
	p_OTHER_REASON IN VARCHAR2,
	p_PROCESS_MESSAGE IN VARCHAR2
	);

PROCEDURE GET_SUBMIT_HOURS
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ACTION IN VARCHAR,
	p_ENTITY_LIST IN VARCHAR2,
	p_ENTITY_LIST_DELIMITER IN CHAR,
	p_CURSOR IN OUT GA.REFCURSOR,
    p_STATUS OUT NUMBER
	);

PROCEDURE GET_FILL_GRID_CONFIG
    (
    p_PARENT_OBJECT_ID IN NUMBER,
    p_TRANSACTION_ID IN NUMBER,
    p_TYPE IN VARCHAR,
	p_CURSOR IN OUT GA.REFCURSOR,
	p_MESSAGE OUT VARCHAR,
    p_STATUS OUT NUMBER
    );

PROCEDURE GET_TRAIT_FILL_TEMPLATE
    (
    p_TRANSACTION_ID IN NUMBER,
    p_TEMPLATE_NAME IN VARCHAR,
    p_TYPE IN VARCHAR,
	p_CURSOR IN OUT GA.REFCURSOR,
	p_MESSAGE OUT VARCHAR,
    p_STATUS OUT NUMBER
    );

PROCEDURE PUT_TRAIT_FILL_TEMPLATE
    (
     p_TRANSACTION_ID IN NUMBER,
     p_TEMPLATE_NAME IN VARCHAR,
     p_TYPE IN VARCHAR,
     p_ROW_NUMBER IN NUMBER,
     p_TEMPLATE_DATA IN VARCHAR,
     p_STATUS OUT NUMBER
     );

PROCEDURE REMOVE_TRAIT_FILL_TEMPLATE
	(
	p_TRANSACTION_ID IN NUMBER,
    p_TEMPLATE_NAME IN VARCHAR,
    p_TYPE IN VARCHAR,
    p_STATUS OUT NUMBER
    );

PROCEDURE FILL_IT_TRAIT_SCHEDULE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
    p_BEGIN_HOUR IN NUMBER,
    p_END_HOUR IN NUMBER,
    p_INCLUDE_HOLIDAYS IN NUMBER,
	p_DAY_TEMPLATE IN VARCHAR,
	p_TRAIT_TEMPLATE IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE IT_TRAIT_STATUS_ACCEPT
	(
	p_TRANSACTION_ID IN NUMBER,
	p_CUT_DATE_SCHEDULING IN DATE_COLLECTION
	);

PROCEDURE IT_TRAIT_STATUS_ACCEPT_TXNS
	(
	p_TRANSACTION_ID IN NUMBER_COLLECTION,
	p_SCHEDULE_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2
	);

PROCEDURE IT_TRAIT_ACCEPT_EXTERNAL
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE
	);

PROCEDURE UPSERT_TRAIT_GROUP
	(
	p_TRANSACTION_TRAIT_GROUP IN TRANSACTION_TRAIT_GROUP%ROWTYPE
	);

PROCEDURE COPY_IT_TRAIT_SCHEDULE
	(
	p_SRC_TRANSACTION_ID IN NUMBER,
	p_SRC_BEGIN_DATE IN DATE,
	p_SRC_END_DATE IN DATE,
	p_SRC_SCHEDULE_STATE IN NUMBER,
	p_TRG_TRANSACTION_ID IN NUMBER,
	p_TRG_BEGIN_DATE IN DATE,
	p_TRG_END_DATE IN DATE,
	p_TRG_SCHEDULE_STATE IN NUMBER,
	p_TRG_DELETE IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE TRAIT_GROUP_INDEX_LIST_SPARSE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_TRAIT_GROUP_FILTER IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE GET_BID_CURVE_EDITOR
	(
	p_TRANSACTION_ID IN NUMBER,
	p_TRAIT_GROUP_ID IN NUMBER,
	p_CUT_DATE_SCHEDULING IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PUT_BID_CURVE_EDITOR
	(
	p_TRANSACTION_ID IN NUMBER,
	p_CUT_DATE_SCHEDULING IN DATE,
	p_TRAIT_GROUP_ID IN NUMBER,
	p_TRAIT_INDEX IN NUMBER,
	p_SET_NUMBER IN NUMBER,
	p_TRAIT_VAL IN VARCHAR2,
	p_STATUS OUT NUMBER
	);

PROCEDURE ROLL_FORWARD_TRAIT_GROUPS
	(
	p_FROM_DATE IN DATE,
	p_TO_DATE IN DATE,
	p_TRAIT_GROUP_IDS IN ID_TABLE,
	p_DELETE_EXISTING_DATA IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_MESSAGE IN OUT VARCHAR2
	);

PROCEDURE PUT_STATUS_REASON
	(
	p_TRANSACTION_ID IN NUMBER,
	p_CUT_DATE_SCHEDULING IN DATE,
	p_REASON_FOR_CHANGE IN VARCHAR,
	p_OTHER_REASON IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_BID_OFFERS_TEMPLATES
    (
	p_TRANSACTION_ID IN NUMBER,
    p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

FUNCTION GET_RATE_VAL
    (
    p_TRAIT_GROUP_ID IN NUMBER,
    p_TRANSACTION_ID IN NUMBER,
    p_TRAIT_NAME IN VARCHAR2,
    p_DATE IN DATE
     )RETURN NUMBER;

FUNCTION GET_RATE_VAL_BY_NAME
    (
    p_TRAIT_GROUP_NAME IN VARCHAR2,
    p_TRANSACTION_NAME IN VARCHAR2,
    p_TRAIT_NAME IN VARCHAR2,
    p_DATE IN DATE
    )RETURN NUMBER;

g_ON NUMBER(1) := 1;
g_NO_ENTITY_ID NUMBER(2) := -9;
g_MODULE_NAME VARCHAR(16) := 'SCHEDULING';
g_SECOND NUMBER(6,5) :=  .00001;
g_OFFER_INTERVAL VARCHAR2(8) := '<Offer>';
g_DATE_FORMAT	VARCHAR2(12) := 'YYYY-MM-DD';

-- Common Transaction Trait Groups
g_TG_OFFER_CURVE CONSTANT NUMBER(9) := 1;
	g_TI_OFFER_PRICE CONSTANT NUMBER(3) := 1;
	g_TI_OFFER_QUANTITY CONSTANT NUMBER(3) := 2;

g_TG_RAMP_CURVE CONSTANT NUMBER(9) := 2;
	g_TI_RAMP_QUANTITY CONSTANT NUMBER(3) := 1;
	g_TI_RAMP_UP CONSTANT NUMBER(3) := 2;
	g_TI_RAMP_DOWN CONSTANT NUMBER(3) := 3;

END TG;
/
CREATE OR REPLACE PACKAGE BODY TG AS

----------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
    RETURN '$Revision: 1.32 $';
END WHAT_VERSION;
----------------------------------------------------------------------------------------------------
PROCEDURE NULL_CURSOR
    (
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
		SELECT NULL FROM DUAL;

END NULL_CURSOR;
-------------------------------------------------------------------------------------------------
FUNCTION TO_CHAR_TRAIT_VAL
(
	p_TRAIT_VAL IN VARCHAR2,
	p_DATA_TYPE IN VARCHAR2
) RETURN VARCHAR2 AS
v_TRAIT_VAL IT_TRAIT_SCHEDULE.TRAIT_VAL%TYPE;
BEGIN
	v_TRAIT_VAL := p_TRAIT_VAL;
	IF v_TRAIT_VAL IS NOT NULL AND p_DATA_TYPE IS NOT NULL AND p_DATA_TYPE = 'Number' THEN
		BEGIN
			v_TRAIT_VAL := TO_CHAR(TO_NUMBER(p_TRAIT_VAL));
		EXCEPTION
			WHEN OTHERS THEN
				NULL; -- EAT IT
		END;
	END IF;
	RETURN v_TRAIT_VAL;
END TO_CHAR_TRAIT_VAL;
-------------------------------------------------------------------------------------------------
FUNCTION GET_TRAIT_GROUP_INTERVAL
    (
	p_TRAIT_GROUP IN TRANSACTION_TRAIT_GROUP%ROWTYPE,
	p_TRANSACTION_ID IN NUMBER
	) RETURN VARCHAR IS
--RETURNS THE INTERVAL ABBREVIATION ASSOCIATED WITH A TRANSACTION_TRAIT_GROUP
BEGIN
	IF p_TRAIT_GROUP.TRAIT_GROUP_INTERVAL = g_OFFER_INTERVAL THEN
		RETURN GET_INTERVAL_ABBREVIATION(MM.GET_BID_OFFER_INTERVAL(p_TRANSACTION_ID));
	ELSE
		RETURN GET_INTERVAL_ABBREVIATION(p_TRAIT_GROUP.TRAIT_GROUP_INTERVAL);
	END IF;

END GET_TRAIT_GROUP_INTERVAL;
---------------------------------------------------------------------------------------------------
FUNCTION GET_TRAIT_GROUP_INTERVAL
    (
	p_TRAIT_GROUP_ID IN NUMBER,
	p_TRANSACTION_ID IN NUMBER
	) RETURN VARCHAR IS
v_TRAIT_GROUP TRANSACTION_TRAIT_GROUP%ROWTYPE;
--RETURNS THE INTERVAL ABBREVIATION ASSOCIATED WITH A TRANSACTION_TRAIT_GROUP
BEGIN

	SELECT * INTO v_TRAIT_GROUP FROM TRANSACTION_TRAIT_GROUP WHERE TRAIT_GROUP_ID = p_TRAIT_GROUP_ID;

    RETURN GET_TRAIT_GROUP_INTERVAL(v_TRAIT_GROUP, p_TRANSACTION_ID);

END GET_TRAIT_GROUP_INTERVAL;
---------------------------------------------------------------------------------------------------
FUNCTION GET_TRANSACTION_INTERVAL
    (
	p_TRANSACTION_ID IN NUMBER
	) RETURN VARCHAR IS
v_INTERVAL VARCHAR2(16);
--RETURNS THE INTERVAL ABBREVIATION ASSOCIATED WITH A TRANSACTION.
BEGIN

	SELECT GET_INTERVAL_ABBREVIATION(TRANSACTION_INTERVAL)
	INTO v_INTERVAL
	FROM INTERCHANGE_TRANSACTION
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

    RETURN v_INTERVAL;

END GET_TRANSACTION_INTERVAL;
---------------------------------------------------------------------------------------------------
FUNCTION GET_SCHEDULING_DATE
    (
	p_DATA_INTERVAL IN VARCHAR2,
	p_SCHEDULE_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR
	) RETURN DATE IS
--RETURNS THE SAME DATE, SHIFTED ACCORDING TO TIME ZONE AND INTERVAL.

v_SCHEDULE_DATE DATE;
BEGIN

	IF INTERVAL_IS_ATLEAST_DAILY(p_DATA_INTERVAL) THEN
		v_SCHEDULE_DATE := TRUNC(p_SCHEDULE_DATE) + g_SECOND;
	ELSE
		v_SCHEDULE_DATE := TO_CUT(p_SCHEDULE_DATE, p_TIME_ZONE);
	END IF;


    RETURN v_SCHEDULE_DATE;

END GET_SCHEDULING_DATE;
---------------------------------------------------------------------------------------------------
FUNCTION GET_TRAIT_SCHEDULE_DATE
    (
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR
	) RETURN DATE IS
--RETURNS THE SAME DATE, SHIFTED ACCORDING TO TIME ZONE AND INTERVAL.

v_DATA_INTERVAL VARCHAR2(16) := MM.GET_BID_OFFER_INTERVAL(p_TRANSACTION_ID);
BEGIN

RETURN GET_SCHEDULING_DATE(v_DATA_INTERVAL, p_SCHEDULE_DATE, p_TIME_ZONE);

END GET_TRAIT_SCHEDULE_DATE;
---------------------------------------------------------------------------------------------------
PROCEDURE FIND_TRANSACTION_LIST
	(
	p_SEARCH_STRING IN VARCHAR,
	p_SEARCH_BY_ALIAS IN NUMBER,
	p_INCLUDE_INACTIVE IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_MODEL_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	)
	AS

-- Answer the given entities for the FIND DIALOG
v_IDs ID_TABLE;

BEGIN

--Make sure user has appropriate access.

v_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_TXN_SELECT, EC.ED_TRANSACTION);
p_STATUS := GA.SUCCESS;

IF p_SEARCH_STRING = '%' OR p_SEARCH_STRING IS NULL THEN

	OPEN p_CURSOR FOR
	SELECT
		TRANSACTION_NAME "ENTITY_NAME",
		TRANSACTION_ID "ENTITY_ID",
		TRANSACTION_ALIAS "ENTITY_ALIAS",
		'Active' "ENTITY_STATUS"
	FROM INTERCHANGE_TRANSACTION, TABLE(CAST(v_IDs AS ID_TABLE)) IDs
    WHERE TRANSACTION_ID > 0
        AND BEGIN_DATE <= p_END_DATE
        AND END_DATE >= p_BEGIN_DATE
        AND IS_BID_OFFER = 1
		AND (IDs.ID = SD.g_ALL_DATA_ENTITY_ID OR IDs.ID = TRANSACTION_ID)
	ORDER BY DECODE(p_SEARCH_BY_ALIAS, 0, TRANSACTION_NAME, TRANSACTION_ALIAS);

ELSE

	OPEN p_CURSOR FOR
	SELECT
		TRANSACTION_NAME "ENTITY_NAME",
		TRANSACTION_ID "ENTITY_ID",
		TRANSACTION_ALIAS "ENTITY_ALIAS",
		'Active' "ENTITY_STATUS"
	FROM INTERCHANGE_TRANSACTION, TABLE(CAST(v_IDs AS ID_TABLE)) IDs
	WHERE TRANSACTION_ID > 0
        AND BEGIN_DATE <= p_END_DATE
        AND END_DATE >= p_BEGIN_DATE
        AND IS_BID_OFFER = 1
        AND (p_SEARCH_BY_ALIAS = 1 OR TRANSACTION_NAME LIKE p_SEARCH_STRING)
		AND (p_SEARCH_BY_ALIAS = 0 OR TRANSACTION_ALIAS LIKE p_SEARCH_STRING)
		AND (IDs.ID = SD.g_ALL_DATA_ENTITY_ID OR IDs.ID = TRANSACTION_ID)
	ORDER BY DECODE(p_SEARCH_BY_ALIAS, 0, TRANSACTION_NAME, TRANSACTION_ALIAS);

END IF;


END FIND_TRANSACTION_LIST;
------------------------------------------------------------------------------------------------------------
PROCEDURE IT_TRAIT_STATUS_DETAIL
	(
	p_TRANSACTION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_CURSOR OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_DATA_INTERVAL VARCHAR2(16);

BEGIN

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_TXN_SELECT, p_TRANSACTION_ID, EC.ED_TRANSACTION);

	IF NVL(p_TRANSACTION_ID,0) <> 0 THEN
		BEGIN
	    v_DATA_INTERVAL := GET_INTERVAL_ABBREVIATION(MM.GET_BID_OFFER_INTERVAL(p_TRANSACTION_ID));
	    EXCEPTION
	      WHEN NO_DATA_FOUND THEN
	      NULL;
	    
  	END;
	END IF;

	UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_DATA_INTERVAL, v_BEGIN_DATE, v_END_DATE);

	OPEN p_CURSOR FOR
		SELECT A.TRANSACTION_NAME,
			FROM_CUT_AS_HED(B.SCHEDULE_DATE, p_TIME_ZONE, v_DATA_INTERVAL, GA.ELECTRIC_MODEL, GA.STANDARD, v_DATA_INTERVAL) "SCHEDULE_DATE",
			B.CREATE_DATE, B.REVIEW_STATUS, B.REVIEW_DATE, NVL(R.USER_DISPLAY_NAME, R.USER_NAME) AS REVIEWED_BY,
			B.SUBMIT_STATUS, B.SUBMIT_DATE, NVL(S.USER_DISPLAY_NAME, S.USER_NAME) AS SUBMITTED_BY,
			B.MARKET_STATUS, B.MARKET_STATUS_DATE,
			B.REASON_FOR_CHANGE, B.OTHER_REASON,
			B.PROCESS_MESSAGE,
			B.SCHEDULE_DATE "CUT_DATE_SCHEDULING",
			B.ENTRY_DATE
		FROM INTERCHANGE_TRANSACTION A, IT_TRAIT_SCHEDULE_STATUS B, APPLICATION_USER R, APPLICATION_USER S
		WHERE A.TRANSACTION_ID = p_TRANSACTION_ID
			AND A.BEGIN_DATE <= p_END_DATE AND A.END_DATE >= p_BEGIN_DATE
			AND A.IS_BID_OFFER = 1
			AND B.TRANSACTION_ID = A.TRANSACTION_ID
			AND B.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND S.USER_ID (+) = B.SUBMITTED_BY_ID
			AND R.USER_ID (+) = B.REVIEWED_BY_ID
		ORDER BY 1, 2;

END IT_TRAIT_STATUS_DETAIL;
----------------------------------------------------------------------------------------------------
PROCEDURE IT_TRAIT_STATUS_SUMMARY_TOP
	(
	p_SC_ID IN NUMBER,
	p_TRANSACTION_TYPE IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_CURSOR OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_IDs ID_TABLE;

BEGIN
	v_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_TXN_SELECT, EC.ED_TRANSACTION);
	UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	OPEN p_CURSOR FOR
		SELECT SCHEDULE_DATE, POD_ID, POD_NAME,
				CASE WHEN MAX(STATUS) = MIN(STATUS) THEN MAX(STATUS) ELSE 'various' END as STATUS
		FROM (SELECT A.SCHEDULE_DATE,
					A.POD_ID,
					A.POD_NAME,
					CASE WHEN STAT.REVIEW_STATUS IS NULL AND STAT.MARKET_STATUS IS NULL AND STAT.SUBMIT_STATUS IS NULL THEN
							'Missing'
						ELSE
							NVL2(STAT.MARKET_STATUS,STAT.SUBMIT_STATUS,'Not Submitted')
						END as STATUS
				FROM (SELECT TR.TRANSACTION_ID,
							SDT.CUT_DATE_SCHEDULING as CUT_DATE,
							CASE WHEN NVL(SP1.SERVICE_POINT_ID,0) > 0 THEN
									SP1.SERVICE_POINT_NAME
								ELSE
									NVL(SP2.SERVICE_POINT_NAME,'?')
								END as POD_NAME,
							CASE WHEN NVL(SP1.SERVICE_POINT_ID,0) > 0 THEN
									SP1.SERVICE_POINT_ID
								ELSE
									NVL(SP2.SERVICE_POINT_ID,0)
								END as POD_ID,
							SDT.LOCAL_DAY_TRUNC_DATE as SCHEDULE_DATE
						FROM TABLE(CAST(v_IDs AS ID_TABLE)) IDs,
							INTERCHANGE_TRANSACTION TR,
							SERVICE_POINT SP1, SERVICE_POINT SP2,
							SUPPLY_RESOURCE RES,
							SYSTEM_DATE_TIME SDT
						WHERE (IDs.ID = SD.g_ALL_DATA_ENTITY_ID OR TR.TRANSACTION_ID = IDs.ID)
							AND TR.SC_ID = p_SC_ID
							AND TR.BEGIN_DATE <= p_END_DATE AND TR.END_DATE >= p_BEGIN_DATE
							AND TR.IS_BID_OFFER = 1
							AND TR.TRANSACTION_TYPE = p_TRANSACTION_TYPE
							AND RES.RESOURCE_ID(+) = TR.RESOURCE_ID
							AND SP1.SERVICE_POINT_ID(+) = RES.SERVICE_POINT_ID
							AND SP2.SERVICE_POINT_ID(+) = TR.POD_ID
							AND SDT.TIME_ZONE = p_TIME_ZONE
							AND SDT.DATA_INTERVAL_TYPE = 1
							AND SDT.DAY_TYPE = '1'
							AND SDT.CUT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
							AND SDT.MINIMUM_INTERVAL_NUMBER >= GET_INTERVAL_NUMBER(MM.GET_BID_OFFER_INTERVAL(TR.TRANSACTION_ID))
						) A,
					IT_TRAIT_SCHEDULE_STATUS STAT
				WHERE STAT.TRANSACTION_ID(+) = A.TRANSACTION_ID
					AND STAT.SCHEDULE_DATE(+) = A.CUT_DATE)
		GROUP BY SCHEDULE_DATE, POD_NAME, POD_ID;

END IT_TRAIT_STATUS_SUMMARY_TOP;
----------------------------------------------------------------------------------------------------
PROCEDURE IT_TRAIT_STATUS_SUMMARY_LOW
	(
	p_SC_ID IN NUMBER,
	p_TRANSACTION_TYPE IN VARCHAR2,
	p_POD_ID IN NUMBER,
	p_SCHEDULE_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_IDs ID_TABLE;
BEGIN
	v_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_TXN_SELECT, EC.ED_TRANSACTION);
	UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_SCHEDULE_DATE, p_SCHEDULE_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	OPEN p_CURSOR FOR
		SELECT SCHEDULE_DATE, TRANSACTION_ID, TRANSACTION_NAME, COMMODITY_NAME,
				CASE WHEN MAX(STATUS) = MIN(STATUS) THEN MAX(STATUS) ELSE 'various' END as STATUS
		FROM (SELECT FROM_CUT_AS_HED(A.CUT_DATE,p_TIME_ZONE,'HH') as SCHEDULE_DATE,
					A.TRANSACTION_ID,
					A.TRANSACTION_NAME,
					A.COMMODITY_NAME,
					CASE WHEN STAT.REVIEW_STATUS IS NULL AND STAT.MARKET_STATUS IS NULL AND STAT.SUBMIT_STATUS IS NULL THEN
							'Missing'
						ELSE
							NVL2(STAT.MARKET_STATUS,STAT.SUBMIT_STATUS,'Not Submitted')
						END as STATUS
				FROM (SELECT TR.TRANSACTION_ID,
							TR.TRANSACTION_NAME,
							SDT.CUT_DATE_SCHEDULING as CUT_DATE,
							CASE WHEN NVL(SP1.SERVICE_POINT_ID,0) > 0 THEN
									SP1.SERVICE_POINT_ID
								ELSE
									NVL(SP2.SERVICE_POINT_ID,0)
								END as POD_ID,
							C.COMMODITY_NAME
						FROM TABLE(CAST(v_IDs AS ID_TABLE)) IDs,
							INTERCHANGE_TRANSACTION TR,
							SERVICE_POINT SP1, SERVICE_POINT SP2,
							SUPPLY_RESOURCE RES,
							IT_COMMODITY C,
							SYSTEM_DATE_TIME SDT
						WHERE (IDs.ID = SD.g_ALL_DATA_ENTITY_ID OR TR.TRANSACTION_ID = IDs.ID)
							AND TR.SC_ID = p_SC_ID
							AND TR.BEGIN_DATE <= p_SCHEDULE_DATE AND TR.END_DATE >= p_SCHEDULE_DATE
							AND TR.IS_BID_OFFER = 1
							AND TR.TRANSACTION_TYPE = p_TRANSACTION_TYPE
							AND RES.RESOURCE_ID(+) = TR.RESOURCE_ID
							AND SP1.SERVICE_POINT_ID(+) = RES.SERVICE_POINT_ID
							AND SP2.SERVICE_POINT_ID(+) = TR.POD_ID
							AND C.COMMODITY_ID = TR.COMMODITY_ID
							AND SDT.TIME_ZONE = p_TIME_ZONE
							AND SDT.DATA_INTERVAL_TYPE = 1
							AND SDT.DAY_TYPE = '1'
							AND SDT.CUT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
							AND SDT.MINIMUM_INTERVAL_NUMBER >= GET_INTERVAL_NUMBER('HH')
						) A,
					IT_TRAIT_SCHEDULE_STATUS STAT
				WHERE A.POD_ID = p_POD_ID
					AND STAT.TRANSACTION_ID(+) = A.TRANSACTION_ID
					AND STAT.SCHEDULE_DATE(+) = A.CUT_DATE)
		GROUP BY SCHEDULE_DATE, TRANSACTION_ID, TRANSACTION_NAME, COMMODITY_NAME;

END IT_TRAIT_STATUS_SUMMARY_LOW;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_IT_TRAIT_SCHED_TRAIT_RPT
    (
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_REPORT_TYPE IN VARCHAR2,
	p_TRAIT_GROUP_FILTER IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_DATE_OFFSET IN NUMBER DEFAULT 0,
	p_INTERVAL IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR,
	p_TRADING_DATE_OFFSET IN NUMBER DEFAULT NULL
	) AS

c_HYPHEN CONSTANT CHAR(3) := ' - ';

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_OFFSET NUMBER := NVL(p_DATE_OFFSET,0);
v_INTERVAL VARCHAR2(16);
v_DAY_INTERVAL_TYPE NUMBER(1);
v_FROM_CUT_INTERVAL VARCHAR2(4);
v_INTERVAL_NUMBER NUMBER;
v_WORK_ID NUMBER(9);
v_SCHEDULE_STATE NUMBER(1) := NVL(p_SCHEDULE_STATE, 1);
v_COLUMN_HEADER	VARCHAR2(512);
BEGIN

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_TXN_SELECT, p_TRANSACTION_ID, EC.ED_TRANSACTION);

    -- Return immediately if we don't have a TRANSACTION_ID
    IF p_TRANSACTION_ID IS NULL OR p_TRANSACTION_ID = g_NO_ENTITY_ID THEN
        NULL_CURSOR(p_CURSOR);
        RETURN;
    END IF;

	--Get the interval of data to display.
	IF p_INTERVAL = g_OFFER_INTERVAL THEN
		v_INTERVAL := MM.GET_BID_OFFER_INTERVAL(p_TRANSACTION_ID);
	ELSE
		v_INTERVAL := p_INTERVAL;
	END IF;
	v_INTERVAL_NUMBER := GET_INTERVAL_NUMBER(v_INTERVAL);

	-- Get the list of Trait Group IDS from the appropriate market.
	MM.GET_TRAITS_FOR_TRANSACTION(p_TRANSACTION_ID, p_REPORT_TYPE, NVL(p_TRAIT_GROUP_FILTER, '%'), p_INTERVAL, v_WORK_ID);

	IF INTERVAL_IS_ATLEAST_DAILY(v_INTERVAL) THEN
        v_DAY_INTERVAL_TYPE := 2;
		v_FROM_CUT_INTERVAL := 'DD';
    ELSE
        v_DAY_INTERVAL_TYPE := 1;
		v_FROM_CUT_INTERVAL := 'MI5';
    END IF;

    --Make sure we have data in the SYSTEM_DATE_TIME table.  Return an error if not.
	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, p_BEGIN_DATE, p_END_DATE);

    p_STATUS := GA.SUCCESS;

    UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	-- recompute offset - it may need to be one hour off of a multiple of 24 hours if looking
	-- back crosses a DST day
	v_OFFSET := v_BEGIN_DATE - (TO_CUT(TRUNC(p_BEGIN_DATE-v_OFFSET),p_TIME_ZONE)+1/86400);
	v_BEGIN_DATE := v_BEGIN_DATE-v_OFFSET;
	v_END_DATE := v_END_DATE-v_OFFSET;

	IF p_TRADING_DATE_OFFSET IS NOT NULL THEN
		v_BEGIN_DATE:= TO_CUT( TRUNC(p_BEGIN_DATE) + p_TRADING_DATE_OFFSET, p_TIME_ZONE ) + 1/86400;
		v_END_DATE	:= TO_CUT( TRUNC(p_END_DATE+1) + p_TRADING_DATE_OFFSET, p_TIME_ZONE );
		SELECT EI.GET_ENTITY_IDENTIFIER_EXTSYS(EC.ED_SERVICE_POINT, IT.POD_ID, EC.ES_SEM) || c_HYPHEN ||
			   IT.AGREEMENT_TYPE || c_HYPHEN ||
			   TO_CHAR(p_BEGIN_DATE, g_DATE_FORMAT)
		  INTO v_COLUMN_HEADER
		  FROM INTERCHANGE_TRANSACTION IT
		 WHERE IT.TRANSACTION_ID = p_TRANSACTION_ID;
	END IF;



    OPEN p_CURSOR FOR
        --8/3/2005 - PBM - Modified query, removed UNION and added a OUTER JOIN on System_Date_Time
        -- also ordered by DisplayOrder first so that the java anchored grid handles it properly
        -- (needs to be ordered by break column)
		-- The p_TRANSACTION_ID was added for F48.U17. The new Offer Management
		-- screen needs the TRANSACTION_ID param for the PUT procedure to work.
		SELECT v_COLUMN_HEADER	AS COLUMN_HEADER,
			FROM_CUT_AS_HED(CUT_DATE_SCHEDULING + v_OFFSET, p_TIME_ZONE, v_FROM_CUT_INTERVAL) "SCHEDULE_DATE_STR",
			p_TRANSACTION_ID AS TRANSACTION_ID,
			A.TRAIT_GROUP_ID,
			A.TRAIT_INDEX,
            COALESCE(A.GROUP_DISPLAY_NAME, A.TRAIT_GROUP_NAME, ' ') "TRAIT_GROUP_NAME",
            CASE WHEN A.IS_SERIES = 0 THEN A.DISPLAY_NAME ELSE A.DISPLAY_NAME||' '||NVL(B.SET_NUMBER,1) END "DISPLAY_NAME",
            TO_CHAR(NVL(B.SET_NUMBER, 1),'0000') "SET_NUMBER",
			A.DATA_TYPE, A.EDIT_MASK, A.COMBO_LIST, A.FORMAT, A.AFTER_EDIT,
			TO_CHAR_TRAIT_VAL(B.TRAIT_VAL,A.DATA_TYPE) AS TRAIT_VAL,
			TO_NUMBER(TO_CHAR(A.CUT_DATE_SCHEDULING,'HH24')) "ROWNUM",
			ROWNUM "REAL_ROWNUM",
			CUT_DATE_SCHEDULING + v_OFFSET "CUT_DATE_SCHEDULING",
			GROUP_ORDER, TRAIT_ORDER
		FROM (SELECT Z.CUT_DATE_SCHEDULING, X.TRAIT_GROUP_NAME,
					X.DISPLAY_NAME "GROUP_DISPLAY_NAME", X.DISPLAY_ORDER "GROUP_ORDER",
					X.TRAIT_GROUP_ID, X.IS_STATEMENT_TYPE_SPECIFIC, X.IS_SERIES,
					Y.TRAIT_INDEX, Y.DISPLAY_NAME, Y.DISPLAY_ORDER "TRAIT_ORDER",
					Y.DATA_TYPE, Y.EDIT_MASK, Y.COMBO_LIST, Y.FORMAT, Y.AFTER_EDIT
            FROM TRANSACTION_TRAIT_GROUP X, TRANSACTION_TRAIT_ATTRIBUTES Y, SYSTEM_DATE_TIME Z, RTO_WORK TR
			WHERE TR.WORK_ID = v_WORK_ID
    			AND X.TRAIT_GROUP_ID = TR.WORK_XID
    			AND X.TRAIT_GROUP_INTERVAL IN (v_INTERVAL, p_INTERVAL)
    			AND X.IS_SPARSE = 0
    			AND Y.TRAIT_GROUP_ID = X.TRAIT_GROUP_ID
    			AND Y.TRAIT_INDEX = TR.WORK_SEQ
                AND Z.TIME_ZONE = p_TIME_ZONE
                AND Z.DATA_INTERVAL_TYPE = v_DAY_INTERVAL_TYPE
                AND Z.DAY_TYPE = 1
                AND Z.CUT_DATE_SCHEDULING BETWEEN v_BEGIN_DATE AND v_END_DATE
    		    AND Z.MINIMUM_INTERVAL_NUMBER >= v_INTERVAL_NUMBER
            ) A,
			IT_TRAIT_SCHEDULE B
		WHERE B.TRANSACTION_ID(+) = p_TRANSACTION_ID
			AND B.SCHEDULE_STATE(+) = v_SCHEDULE_STATE
			AND B.SCHEDULE_DATE(+) = A.CUT_DATE_SCHEDULING
			AND B.TRAIT_GROUP_ID(+) = A.TRAIT_GROUP_ID
			AND B.TRAIT_INDEX(+) = A.TRAIT_INDEX
			AND B.STATEMENT_TYPE_ID(+) = CASE A.IS_STATEMENT_TYPE_SPECIFIC WHEN 0 THEN 0 ELSE p_SCHEDULE_TYPE END
		ORDER BY GROUP_ORDER, SET_NUMBER, TRAIT_ORDER, CUT_DATE_SCHEDULING;

		UT.PURGE_RTO_WORK(v_WORK_ID);
END GET_IT_TRAIT_SCHED_TRAIT_RPT;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_IT_TRAIT_SCHEDULE_AS_CUT
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_CUT_DATE_SCHEDULING IN DATE,
	p_TRAIT_GROUP_ID IN NUMBER,
	p_TRAIT_INDEX IN NUMBER,
	p_SET_NUMBER IN NUMBER,
	p_TRAIT_VAL IN VARCHAR
	) AS

-- Delete, Update or Insert to the BID_OFFER_TRAIT table.
v_TRAIT_GROUP TRANSACTION_TRAIT_GROUP%ROWTYPE;
v_SCHEDULE_DATE DATE;
v_STATEMENT_TYPE_ID NUMBER(9);
v_SCHEDULE_STATE NUMBER(1) := NVL(p_SCHEDULE_STATE, 1);
BEGIN

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_BAO_UPDATE, p_TRANSACTION_ID, EC.ED_TRANSACTION);

	IF p_TRAIT_GROUP_ID IS NULL THEN
		RETURN;
	END IF;

	IF LOGS.IS_DEBUG_ENABLED() THEN
		LOGS.LOG_DEBUG('TGIF.PUT_IT_TRAIT_SCHEDULE_AS_CUT');
		LOGS.LOG_DEBUG('p_TRANSACTION_ID=' || p_TRANSACTION_ID);
		LOGS.LOG_DEBUG('p_SCHEDULE_TYPE=' || p_SCHEDULE_TYPE);
		LOGS.LOG_DEBUG('p_SCHEDULE_DATE=' || UT.TRACE_DATE(p_CUT_DATE_SCHEDULING));
		LOGS.LOG_DEBUG('p_TRAIT_GROUP_ID=' || p_TRAIT_GROUP_ID);
		LOGS.LOG_DEBUG('p_TRAIT_INDEX=' || p_TRAIT_INDEX);
		LOGS.LOG_DEBUG('p_SET_NUMBER=' || p_SET_NUMBER);
		LOGS.LOG_DEBUG('p_TRAIT_VAL=' || p_TRAIT_VAL);
	END IF;

	SELECT * INTO v_TRAIT_GROUP FROM TRANSACTION_TRAIT_GROUP WHERE TRAIT_GROUP_ID = p_TRAIT_GROUP_ID;
	v_STATEMENT_TYPE_ID := CASE WHEN v_TRAIT_GROUP.IS_STATEMENT_TYPE_SPECIFIC = 0 THEN 0 ELSE p_SCHEDULE_TYPE END;

	--Scheduling shifts ahead a second for daily interval things.
	v_SCHEDULE_DATE := p_CUT_DATE_SCHEDULING; --GET_SCHEDULING_DATE(v_DATA_INTERVAL, p_SCHEDULE_DATE, p_TIME_ZONE);

	--If the value is null, then delete the record.
	IF p_TRAIT_VAL IS NULL THEN
		DELETE IT_TRAIT_SCHEDULE
		WHERE TRANSACTION_ID = p_TRANSACTION_ID
			AND SCHEDULE_STATE = v_SCHEDULE_STATE
			AND SCHEDULE_DATE = v_SCHEDULE_DATE
			AND TRAIT_GROUP_ID = p_TRAIT_GROUP_ID
			AND TRAIT_INDEX = p_TRAIT_INDEX
			AND SET_NUMBER = p_SET_NUMBER
			AND STATEMENT_TYPE_ID = v_STATEMENT_TYPE_ID;
	ELSE
		UPDATE IT_TRAIT_SCHEDULE SET
			TRAIT_VAL = p_TRAIT_VAL,
			ENTRY_DATE = SYSDATE
		WHERE TRANSACTION_ID = p_TRANSACTION_ID
			AND SCHEDULE_STATE = v_SCHEDULE_STATE
			AND SCHEDULE_DATE = v_SCHEDULE_DATE
			AND TRAIT_GROUP_ID = p_TRAIT_GROUP_ID
			AND TRAIT_INDEX = p_TRAIT_INDEX
			AND SET_NUMBER = p_SET_NUMBER
			AND STATEMENT_TYPE_ID = v_STATEMENT_TYPE_ID;

	-- IF THE PREVIOUS UPDATE DID NOT FIND A MATCH, THEN INSERT A NEW RECORD
		IF SQL%NOTFOUND THEN
			INSERT INTO IT_TRAIT_SCHEDULE (
				TRANSACTION_ID,
				SCHEDULE_STATE,
				SCHEDULE_DATE,
				TRAIT_GROUP_ID,
				TRAIT_INDEX,
				SET_NUMBER,
				STATEMENT_TYPE_ID,
				SCHEDULE_END_DATE,
				TRAIT_VAL,
				ENTRY_DATE)
			VALUES (
				p_TRANSACTION_ID,
				v_SCHEDULE_STATE,
				v_SCHEDULE_DATE,
				p_TRAIT_GROUP_ID,
				p_TRAIT_INDEX,
				p_SET_NUMBER,
				v_STATEMENT_TYPE_ID,
				NULL,
				p_TRAIT_VAL,
				SYSDATE);
		END IF;
	END IF;

END PUT_IT_TRAIT_SCHEDULE_AS_CUT;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_IT_TRAIT_SCHEDULE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_DATE IN DATE,
	p_TRAIT_GROUP_ID IN NUMBER,
	p_TRAIT_INDEX IN NUMBER,
	p_SET_NUMBER IN NUMBER,
	p_TRAIT_VAL IN VARCHAR,
	p_TIME_ZONE IN VARCHAR
	) AS

-- Delete, Update or Insert to the BID_OFFER_TRAIT table.
v_DATA_INTERVAL VARCHAR2(16);
v_SCHEDULE_DATE DATE;
BEGIN

	IF LOGS.IS_DEBUG_ENABLED() THEN
		LOGS.LOG_DEBUG('TGIF.PUT_IT_TRAIT_SCHEDULE');
		LOGS.LOG_DEBUG('p_TRANSACTION_ID=' || p_TRANSACTION_ID);
		LOGS.LOG_DEBUG('p_SCHEDULE_TYPE=' || p_SCHEDULE_TYPE);
		LOGS.LOG_DEBUG('p_SCHEDULE_DATE=' || UT.TRACE_DATE(p_SCHEDULE_DATE));
		LOGS.LOG_DEBUG('p_TRAIT_GROUP_ID=' || p_TRAIT_GROUP_ID);
		LOGS.LOG_DEBUG('p_TRAIT_INDEX=' || p_TRAIT_INDEX);
		LOGS.LOG_DEBUG('p_SET_NUMBER=' || p_SET_NUMBER);
		LOGS.LOG_DEBUG('p_TRAIT_VAL=' || p_TRAIT_VAL);
		LOGS.LOG_DEBUG('p_TIME_ZONE=' || p_TIME_ZONE);
	END IF;

	v_DATA_INTERVAL := GET_TRAIT_GROUP_INTERVAL(p_TRAIT_GROUP_ID, p_TRANSACTION_ID);
	--Scheduling shifts ahead a second for daily interval things.
	v_SCHEDULE_DATE := GET_SCHEDULING_DATE(v_DATA_INTERVAL, p_SCHEDULE_DATE, p_TIME_ZONE);
	PUT_IT_TRAIT_SCHEDULE_AS_CUT(p_TRANSACTION_ID, p_SCHEDULE_STATE, p_SCHEDULE_TYPE, v_SCHEDULE_DATE, p_TRAIT_GROUP_ID, p_TRAIT_INDEX, p_SET_NUMBER, p_TRAIT_VAL);

END PUT_IT_TRAIT_SCHEDULE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_IT_TRAIT_SCHED_SPARSE_RPT
    (
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_REPORT_TYPE IN VARCHAR2,
	p_TRAIT_GROUP_FILTER IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_DATE_OFFSET IN NUMBER DEFAULT 0,
	p_INTERVAL IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_OFFSET NUMBER := NVL(p_DATE_OFFSET,0);
v_INTERVAL VARCHAR2(4);
v_WORK_ID NUMBER(9);
v_SCHEDULE_STATE NUMBER(1) := NVL(p_SCHEDULE_STATE, 1);
v_BID_OFFER_INTERVAL VARCHAR2(16);
BEGIN

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_TXN_SELECT, p_TRANSACTION_ID, EC.ED_TRANSACTION);
    -- Return immediately if we don't have a TRANSACTION_ID
    IF p_TRANSACTION_ID IS NULL OR p_TRANSACTION_ID = g_NO_ENTITY_ID THEN
        NULL_CURSOR(p_CURSOR);
        RETURN;
    END IF;

	v_BID_OFFER_INTERVAL := MM.GET_BID_OFFER_INTERVAL(p_TRANSACTION_ID);
	IF p_INTERVAL = g_OFFER_INTERVAL THEN
		v_INTERVAL := GET_INTERVAL_ABBREVIATION(v_BID_OFFER_INTERVAL);
	ELSE
		v_INTERVAL := GET_INTERVAL_ABBREVIATION(p_INTERVAL);
	END IF;

	-- Get the list of Trait Group IDS from the appropriate market.
	MM.GET_TRAITS_FOR_TRANSACTION(p_TRANSACTION_ID, p_REPORT_TYPE, NVL(p_TRAIT_GROUP_FILTER, '%'), p_INTERVAL, v_WORK_ID);

    p_STATUS := GA.SUCCESS;

    UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	-- recompute offset - it may need to be one hour off of a multiple of 24 hours if looking
	-- back crosses a DST day
	v_OFFSET := v_BEGIN_DATE - (TO_CUT(TRUNC(p_BEGIN_DATE-v_OFFSET),p_TIME_ZONE)+1/86400);
	v_BEGIN_DATE := v_BEGIN_DATE-v_OFFSET;
	v_END_DATE := v_END_DATE-v_OFFSET;

    OPEN p_CURSOR FOR
		SELECT
			CASE WHEN B.SCHEDULE_DATE IS NULL THEN NULL ELSE TO_DATE(SUBSTR(FROM_CUT_AS_HED(B.SCHEDULE_DATE, p_TIME_ZONE, 'MI5'), 1, 10), 'YYYY-MM-DD') END "SCHEDULE_DATE",
			CASE WHEN A.TRAIT_GROUP_INTERVAL IN ('DAY','WEEK','MONTH','QUARTER','YEAR') THEN NULL ELSE SUBSTR(FROM_CUT_AS_HED(B.SCHEDULE_DATE, p_TIME_ZONE, 'MI5'), 12) END "SCHEDULE_TIME",
			CASE WHEN B.SCHEDULE_END_DATE IS NULL THEN NULL ELSE TO_DATE(SUBSTR(FROM_CUT_AS_HED(B.SCHEDULE_END_DATE, p_TIME_ZONE, 'MI5'), 1, 10), 'YYYY-MM-DD') END "SCHEDULE_END_DATE",
            CASE WHEN A.TRAIT_GROUP_INTERVAL IN ('DAY','WEEK','MONTH','QUARTER','YEAR') THEN NULL ELSE SUBSTR(FROM_CUT_AS_HED(B.SCHEDULE_END_DATE, p_TIME_ZONE, 'MI5'), 12) END "SCHEDULE_END_TIME",
			A.TRAIT_GROUP_ID * 1000 + A.TRAIT_INDEX "TRAIT_GROUP_INDEX_ID",
			NVL(B.SET_NUMBER, 1) "SET_NUMBER",
			A.DATA_TYPE, A.EDIT_MASK, A.COMBO_LIST, A.FORMAT, A.AFTER_EDIT,
			B.TRAIT_VAL,
			B.SCHEDULE_DATE "ORIG_SCHEDULE_DATE",
			ROWNUM
		FROM
			(SELECT X.TRAIT_GROUP_ID, Y.TRAIT_INDEX, X.DISPLAY_NAME "GROUP_DISPLAY_NAME", X.TRAIT_GROUP_NAME, X.DISPLAY_ORDER "GROUP_DISPLAY_ORDER",
				Y.DISPLAY_ORDER "TRAIT_DISPLAY_ORDER", Y.DISPLAY_NAME "TRAIT_DISPLAY_NAME", Y.DATA_TYPE, Y.EDIT_MASK, Y.COMBO_LIST, Y.FORMAT, Y.AFTER_EDIT, X.IS_STATEMENT_TYPE_SPECIFIC,
				CASE X.TRAIT_GROUP_INTERVAL WHEN g_OFFER_INTERVAL THEN UPPER(v_BID_OFFER_INTERVAL) ELSE UPPER(TRAIT_GROUP_INTERVAL) END "TRAIT_GROUP_INTERVAL"
			FROM TRANSACTION_TRAIT_GROUP X, TRANSACTION_TRAIT_ATTRIBUTES Y, RTO_WORK TR
			WHERE TR.WORK_ID = v_WORK_ID
			AND X.TRAIT_GROUP_ID = TR.WORK_XID
			AND X.IS_SPARSE = 1
			AND X.IS_SERIES = 0
			AND Y.TRAIT_GROUP_ID = X.TRAIT_GROUP_ID
			AND Y.TRAIT_INDEX = TR.WORK_SEQ
            ) A, IT_TRAIT_SCHEDULE B
		WHERE B.TRANSACTION_ID(+) = p_TRANSACTION_ID
			AND B.SCHEDULE_STATE(+) = v_SCHEDULE_STATE
			AND B.TRAIT_GROUP_ID(+) = A.TRAIT_GROUP_ID
			AND B.TRAIT_INDEX(+) = A.TRAIT_INDEX
			AND B.STATEMENT_TYPE_ID(+) = CASE A.IS_STATEMENT_TYPE_SPECIFIC WHEN 0 THEN 0 ELSE p_SCHEDULE_TYPE END
			AND B.SCHEDULE_DATE(+) <= v_END_DATE
			AND NVL(B.SCHEDULE_END_DATE(+),CONSTANTS.HIGH_DATE) >= v_BEGIN_DATE
		ORDER BY B.SCHEDULE_DATE, B.SCHEDULE_END_DATE, A.GROUP_DISPLAY_ORDER, SET_NUMBER, A.TRAIT_DISPLAY_ORDER;

		UT.PURGE_RTO_WORK(v_WORK_ID);

END GET_IT_TRAIT_SCHED_SPARSE_RPT;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_IT_TRAIT_SPARSE_SERIES_RPT
    (
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_REPORT_TYPE IN VARCHAR2,
	p_TRAIT_GROUP_FILTER IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_DATE_OFFSET IN NUMBER DEFAULT 0,
	p_INTERVAL IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_OFFSET NUMBER := NVL(p_DATE_OFFSET,0);
v_INTERVAL VARCHAR2(4);
v_WORK_ID NUMBER(9);
v_SCHEDULE_STATE NUMBER(1) := NVL(p_SCHEDULE_STATE, 1);
v_BID_OFFER_INTERVAL VARCHAR2(16);
BEGIN

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_TXN_SELECT, p_TRANSACTION_ID, EC.ED_TRANSACTION);
    -- Return immediately if we don't have a TRANSACTION_ID
    IF p_TRANSACTION_ID IS NULL OR p_TRANSACTION_ID = g_NO_ENTITY_ID THEN
        NULL_CURSOR(p_CURSOR);
        RETURN;
    END IF;

	v_BID_OFFER_INTERVAL := MM.GET_BID_OFFER_INTERVAL(p_TRANSACTION_ID);
	IF p_INTERVAL = g_OFFER_INTERVAL THEN
		v_INTERVAL := GET_INTERVAL_ABBREVIATION(v_BID_OFFER_INTERVAL);
	ELSE
		v_INTERVAL := GET_INTERVAL_ABBREVIATION(p_INTERVAL);
	END IF;

	-- Get the list of Trait Group IDS from the appropriate market.
	MM.GET_TRAITS_FOR_TRANSACTION(p_TRANSACTION_ID, p_REPORT_TYPE, NVL(p_TRAIT_GROUP_FILTER, '%'), p_INTERVAL, v_WORK_ID);

    p_STATUS := GA.SUCCESS;

    UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	-- recompute offset - it may need to be one hour off of a multiple of 24 hours if looking
	-- back crosses a DST day
	v_OFFSET := v_BEGIN_DATE - (TO_CUT(TRUNC(p_BEGIN_DATE-v_OFFSET),p_TIME_ZONE)+1/86400);
	v_BEGIN_DATE := v_BEGIN_DATE-v_OFFSET;
	v_END_DATE := v_END_DATE-v_OFFSET;

    OPEN p_CURSOR FOR

		SELECT
			TO_DATE(SUBSTR(FROM_CUT_AS_HED(B.SCHEDULE_DATE, p_TIME_ZONE, 'MI5'), 1, 10), 'YYYY-MM-DD') "SCHEDULE_DATE",
			CASE WHEN A.TRAIT_GROUP_INTERVAL IN ('DAY','WEEK','MONTH','QUARTER','YEAR') THEN NULL ELSE SUBSTR(FROM_CUT_AS_HED(B.SCHEDULE_DATE, p_TIME_ZONE, 'MI5'), 12) END "SCHEDULE_TIME",
			TO_DATE(SUBSTR(FROM_CUT_AS_HED(B.SCHEDULE_END_DATE, p_TIME_ZONE, 'MI5'), 1, 10), 'YYYY-MM-DD') "SCHEDULE_END_DATE",
			CASE WHEN A.TRAIT_GROUP_INTERVAL IN ('DAY','WEEK','MONTH','QUARTER','YEAR') THEN NULL ELSE SUBSTR(FROM_CUT_AS_HED(B.SCHEDULE_END_DATE, p_TIME_ZONE, 'MI5'), 12) END "SCHEDULE_END_TIME",
			A.TRAIT_GROUP_ID,
			NVL(A.GROUP_DISPLAY_NAME, A.TRAIT_GROUP_NAME) "TRAIT_GROUP_NAME",
			A.TRAIT_INDEX,
			A.TRAIT_DISPLAY_NAME "TRAIT_GROUP_INDEX_NAME",
			NVL(B.SET_NUMBER, 1) "SET_NUMBER",
			NVL(B.SET_NUMBER, 1) "SET_NUMBER_DATA",
			A.DATA_TYPE, A.EDIT_MASK, A.COMBO_LIST, A.FORMAT, A.AFTER_EDIT,
			B.TRAIT_VAL,
			B.SCHEDULE_DATE "ORIG_SCHEDULE_DATE",
			ROWNUM
		FROM
			(SELECT X.TRAIT_GROUP_ID, Y.TRAIT_INDEX, X.DISPLAY_NAME "GROUP_DISPLAY_NAME", X.TRAIT_GROUP_NAME, X.DISPLAY_ORDER "GROUP_DISPLAY_ORDER",
				Y.DISPLAY_ORDER "TRAIT_DISPLAY_ORDER", Y.DISPLAY_NAME "TRAIT_DISPLAY_NAME", Y.DATA_TYPE, Y.EDIT_MASK, Y.AFTER_EDIT, Y.COMBO_LIST, Y.FORMAT, X.IS_STATEMENT_TYPE_SPECIFIC,
				CASE X.TRAIT_GROUP_INTERVAL WHEN g_OFFER_INTERVAL THEN UPPER(v_BID_OFFER_INTERVAL) ELSE UPPER(TRAIT_GROUP_INTERVAL) END "TRAIT_GROUP_INTERVAL"
			FROM TRANSACTION_TRAIT_GROUP X, TRANSACTION_TRAIT_ATTRIBUTES Y, RTO_WORK TR
			WHERE TR.WORK_ID = v_WORK_ID
			AND X.TRAIT_GROUP_ID = TR.WORK_XID
			AND X.IS_SPARSE = 1
			AND X.IS_SERIES = 1
			AND Y.TRAIT_GROUP_ID = X.TRAIT_GROUP_ID
			AND Y.TRAIT_INDEX = TR.WORK_SEQ
            ) A, IT_TRAIT_SCHEDULE B
		WHERE B.TRANSACTION_ID(+) = p_TRANSACTION_ID
			AND B.SCHEDULE_STATE(+) = v_SCHEDULE_STATE
			AND B.TRAIT_GROUP_ID(+) = A.TRAIT_GROUP_ID
			AND B.TRAIT_INDEX(+) = A.TRAIT_INDEX
			AND B.STATEMENT_TYPE_ID(+) = CASE A.IS_STATEMENT_TYPE_SPECIFIC WHEN 0 THEN 0 ELSE p_SCHEDULE_TYPE END
			AND B.SCHEDULE_DATE(+) <= v_END_DATE
			AND NVL(B.SCHEDULE_END_DATE(+),CONSTANTS.HIGH_DATE) >= v_BEGIN_DATE
		ORDER BY B.SCHEDULE_DATE, B.SCHEDULE_END_DATE, A.GROUP_DISPLAY_ORDER, A.TRAIT_GROUP_ID, SET_NUMBER, A.TRAIT_DISPLAY_ORDER, A.TRAIT_INDEX;

		UT.PURGE_RTO_WORK(v_WORK_ID);

END GET_IT_TRAIT_SPARSE_SERIES_RPT;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_IT_TRAIT_SPARSE_COMMON
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_DATE IN DATE,
	p_SCHEDULE_END_DATE IN DATE,
	p_TRAIT_GROUP_ID IN NUMBER,
	p_TRAIT_INDEX IN NUMBER,
	p_SET_NUMBER IN NUMBER,
	p_TRAIT_VAL IN VARCHAR,
	p_OLD_SCHEDULE_DATE IN DATE,
	p_OLD_TRAIT_GROUP_ID IN NUMBER,
	p_OLD_TRAIT_INDEX IN NUMBER,
	p_OLD_SET_NUMBER IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS
	v_SCHEDULE_DATE DATE;
	v_SCHEDULE_END_DATE DATE;
	v_OLD_SCHEDULE_DATE DATE;
	v_STATEMENT_TYPE_ID NUMBER(9);
	v_DATA_INTERVAL VARCHAR2(16);
	v_TRAIT_GROUP TRANSACTION_TRAIT_GROUP%ROWTYPE;
BEGIN
	p_STATUS := GA.SUCCESS;

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_BAO_UPDATE, p_TRANSACTION_ID, EC.ED_TRANSACTION);

	IF p_TRAIT_GROUP_ID IS NULL THEN
		RETURN;
	END IF;

	SELECT * INTO v_TRAIT_GROUP FROM TRANSACTION_TRAIT_GROUP WHERE TRAIT_GROUP_ID = p_TRAIT_GROUP_ID;
	v_DATA_INTERVAL := GET_TRAIT_GROUP_INTERVAL(v_TRAIT_GROUP, p_TRANSACTION_ID);
	v_STATEMENT_TYPE_ID := CASE WHEN v_TRAIT_GROUP.IS_STATEMENT_TYPE_SPECIFIC = 0 THEN 0 ELSE p_SCHEDULE_TYPE END;

	--Scheduling shifts ahead a second for daily interval things.
	v_SCHEDULE_DATE := GET_SCHEDULING_DATE(v_DATA_INTERVAL, p_SCHEDULE_DATE, p_TIME_ZONE);
	v_SCHEDULE_END_DATE := GET_SCHEDULING_DATE(v_DATA_INTERVAL, p_SCHEDULE_END_DATE, p_TIME_ZONE);
	v_OLD_SCHEDULE_DATE := GET_SCHEDULING_DATE(v_DATA_INTERVAL, p_OLD_SCHEDULE_DATE, p_TIME_ZONE);

	UPDATE IT_TRAIT_SCHEDULE SET
		SCHEDULE_DATE = v_SCHEDULE_DATE,
		SCHEDULE_END_DATE = v_SCHEDULE_END_DATE,
		SET_NUMBER = p_SET_NUMBER,
		TRAIT_VAL = p_TRAIT_VAL,
		ENTRY_DATE = SYSDATE
	WHERE TRANSACTION_ID = p_TRANSACTION_ID
		AND SCHEDULE_STATE = p_SCHEDULE_STATE
		AND SCHEDULE_DATE = v_OLD_SCHEDULE_DATE
		AND TRAIT_GROUP_ID = p_OLD_TRAIT_GROUP_ID
		AND TRAIT_INDEX = p_OLD_TRAIT_INDEX
		AND SET_NUMBER = p_OLD_SET_NUMBER
		AND STATEMENT_TYPE_ID = v_STATEMENT_TYPE_ID;

	-- IF THE PREVIOUS UPDATE DID NOT FIND A MATCH, THEN INSERT A NEW RECORD
	IF SQL%NOTFOUND THEN
		INSERT INTO IT_TRAIT_SCHEDULE (
			TRANSACTION_ID,
			SCHEDULE_STATE,
			SCHEDULE_DATE,
			TRAIT_GROUP_ID,
			TRAIT_INDEX,
			SET_NUMBER,
			STATEMENT_TYPE_ID,
			SCHEDULE_END_DATE,
			TRAIT_VAL,
			ENTRY_DATE)
		VALUES (
			p_TRANSACTION_ID,
			p_SCHEDULE_STATE,
			v_SCHEDULE_DATE,
			p_TRAIT_GROUP_ID,
			p_TRAIT_INDEX,
			p_SET_NUMBER,
			v_STATEMENT_TYPE_ID,
			v_SCHEDULE_END_DATE,
			p_TRAIT_VAL,
			SYSDATE);
	END IF;


END PUT_IT_TRAIT_SPARSE_COMMON;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_IT_TRAIT_SCHED_SPARSE_RPT
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_DATE IN DATE,
	p_SCHEDULE_TIME IN VARCHAR2,
	p_SCHEDULE_END_DATE IN DATE,
	p_SCHEDULE_END_TIME IN VARCHAR2,
	p_TRAIT_GROUP_INDEX_ID IN NUMBER,
	p_SET_NUMBER IN NUMBER,
	p_TRAIT_VAL IN VARCHAR,
	p_ORIG_SCHEDULE_DATE IN DATE,
	p_OLD_TRAIT_GROUP_INDEX_ID IN NUMBER,
	p_OLD_SET_NUMBER IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

-- Delete, Update or Insert to the IT_TRAIT_SCHEDULE table for a sparse trait.
v_SCHEDULE_STATE NUMBER(1) := NVL(p_SCHEDULE_STATE, 1);
v_TRAIT_GROUP_ID NUMBER(9);
v_TRAIT_INDEX NUMBER(3);
v_OLD_TRAIT_GROUP_ID NUMBER(9);
v_OLD_TRAIT_INDEX NUMBER(3);
v_SCHEDULE_DATE DATE;
v_SCHEDULE_END_DATE DATE;
BEGIN

	p_STATUS := GA.SUCCESS;

	IF p_TRAIT_GROUP_INDEX_ID IS NULL THEN
		RETURN;
	END IF;

	--TRAIT_GROUP_INDEX_ID IS TRAIT_GROUP_ID * 1000 + TRAIT_INDEX.
	v_TRAIT_INDEX := MOD(p_TRAIT_GROUP_INDEX_ID, 1000);
	v_TRAIT_GROUP_ID := TRUNC(p_TRAIT_GROUP_INDEX_ID / 1000);
	v_OLD_TRAIT_INDEX := MOD(p_OLD_TRAIT_GROUP_INDEX_ID, 1000);
	v_OLD_TRAIT_GROUP_ID := TRUNC(p_OLD_TRAIT_GROUP_INDEX_ID / 1000);

	v_SCHEDULE_DATE := DATE_TIME_AS_CUT (TO_CHAR(p_SCHEDULE_DATE,'YYYY-MM-DD'), p_SCHEDULE_TIME, p_TIME_ZONE, 1);
	v_SCHEDULE_END_DATE := DATE_TIME_AS_CUT (TO_CHAR(p_SCHEDULE_END_DATE,'YYYY-MM-DD'), p_SCHEDULE_END_TIME, p_TIME_ZONE, 1);

	PUT_IT_TRAIT_SPARSE_COMMON(p_TRANSACTION_ID, v_SCHEDULE_STATE, p_SCHEDULE_TYPE, v_SCHEDULE_DATE, v_SCHEDULE_END_DATE,
		v_TRAIT_GROUP_ID, v_TRAIT_INDEX, NVL(p_SET_NUMBER,1), p_TRAIT_VAL, p_ORIG_SCHEDULE_DATE,
		v_OLD_TRAIT_GROUP_ID, v_OLD_TRAIT_INDEX, p_OLD_SET_NUMBER, CUT_TIME_ZONE, p_STATUS);

END PUT_IT_TRAIT_SCHED_SPARSE_RPT;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_IT_TRAIT_SCHEDULE_SPARSE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_DATE IN DATE,
	p_SCHEDULE_END_DATE IN DATE,
	p_TRAIT_GROUP_ID IN NUMBER,
	p_TRAIT_INDEX IN NUMBER,
	p_SET_NUMBER IN NUMBER,
	p_TRAIT_VAL IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS
BEGIN
	PUT_IT_TRAIT_SPARSE_COMMON(p_TRANSACTION_ID, p_SCHEDULE_STATE, p_SCHEDULE_TYPE, p_SCHEDULE_DATE, p_SCHEDULE_END_DATE,
		p_TRAIT_GROUP_ID, p_TRAIT_INDEX, p_SET_NUMBER, p_TRAIT_VAL,
		p_SCHEDULE_DATE, p_TRAIT_GROUP_ID, p_TRAIT_INDEX, p_SET_NUMBER, p_TIME_ZONE, p_STATUS);
END PUT_IT_TRAIT_SCHEDULE_SPARSE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_IT_TRAIT_SCHED_DETAIL_RPT
    (
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_REPORT_TYPE IN VARCHAR2,
	p_TRAIT_GROUP_FILTER IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_DATE_OFFSET IN NUMBER DEFAULT 0,
	p_INTERVAL IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_OFFSET NUMBER := NVL(p_DATE_OFFSET,0);
v_INTERVAL VARCHAR2(16);
v_DAY_INTERVAL_TYPE NUMBER(1);
v_INTERVAL_NUMBER NUMBER;
v_WORK_ID NUMBER(9);
v_SCHEDULE_STATE NUMBER(1) := NVL(p_SCHEDULE_STATE, 1);
v_FROM_CUT_INTERVAL VARCHAR2(4);

--INCLUDE ADDITIONAL "DETAIL" COLUMNS FOR THIS REPORT.
BEGIN

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_TXN_SELECT, p_TRANSACTION_ID, EC.ED_TRANSACTION);
    -- Return immediately if we don't have a TRANSACTION_ID
    IF p_TRANSACTION_ID IS NULL OR p_TRANSACTION_ID = g_NO_ENTITY_ID THEN
        NULL_CURSOR(p_CURSOR);
        RETURN;
    END IF;

	--Get the interval of data to display.
	IF p_INTERVAL = g_OFFER_INTERVAL THEN
		v_INTERVAL := MM.GET_BID_OFFER_INTERVAL(p_TRANSACTION_ID);
	ELSE
		v_INTERVAL := p_INTERVAL;
	END IF;
	v_INTERVAL_NUMBER := GET_INTERVAL_NUMBER(v_INTERVAL);

	-- Get the list of Trait Group IDS from the appropriate market.
	MM.GET_TRAITS_FOR_TRANSACTION(p_TRANSACTION_ID, p_REPORT_TYPE, NVL(p_TRAIT_GROUP_FILTER, '%'), p_INTERVAL, v_WORK_ID);

	IF INTERVAL_IS_ATLEAST_DAILY(v_INTERVAL) THEN
        v_DAY_INTERVAL_TYPE := 2;
		v_FROM_CUT_INTERVAL := 'DD';
    ELSE
        v_DAY_INTERVAL_TYPE := 1;
		v_FROM_CUT_INTERVAL := 'MI5';
    END IF;

    --Make sure we have data in the SYSTEM_DATE_TIME table.  Return an error if not.
	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, p_BEGIN_DATE, p_END_DATE);

    p_STATUS := GA.SUCCESS;

    UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	-- recompute offset - it may need to be one hour off of a multiple of 24 hours if looking
	-- back crosses a DST day
	v_OFFSET := v_BEGIN_DATE - (TO_CUT(TRUNC(p_BEGIN_DATE-v_OFFSET),p_TIME_ZONE)+1/86400);
	v_BEGIN_DATE := v_BEGIN_DATE-v_OFFSET;
	v_END_DATE := v_END_DATE-v_OFFSET;

    OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(TRAIT.CUT_DATE_SCHEDULING, p_TIME_ZONE, v_FROM_CUT_INTERVAL) "SCHEDULE_DATE_STR",
			TRAIT.CUT_DATE_SCHEDULING,
			TRAIT_GROUP_ID,
			TRAIT_INDEX,
			TRAIT_GROUP_NAME,
			DISPLAY_NAME,
			SET_NUMBER,
			DATA_TYPE,
			EDIT_MASK,
			COMBO_LIST,
			FORMAT,
      		AFTER_EDIT,
			TRAIT_VAL,
			SCHED.PRICE,
			SCHED.AMOUNT,
			STAT.REVIEW_STATUS,
			STAT.SUBMIT_STATUS,
			STAT.MARKET_STATUS,
			STAT.REASON_FOR_CHANGE,
			STAT.OTHER_REASON,
			STAT.PROCESS_MESSAGE,
			ROWNUM,
			GROUP_ORDER, TRAIT_ORDER
		FROM IT_SCHEDULE SCHED, IT_TRAIT_SCHEDULE_STATUS STAT,
			(SELECT A.CUT_DATE_SCHEDULING + v_OFFSET "CUT_DATE_SCHEDULING",
				A.TRAIT_GROUP_ID,
				A.TRAIT_INDEX,
				COALESCE(A.GROUP_DISPLAY_NAME, A.TRAIT_GROUP_NAME, ' ') "TRAIT_GROUP_NAME",
				CASE WHEN A.IS_SERIES = 0 THEN A.DISPLAY_NAME ELSE A.DISPLAY_NAME||' '||NVL(B.SET_NUMBER,1) END "DISPLAY_NAME",
				TO_CHAR(NVL(B.SET_NUMBER, 1),'0000') "SET_NUMBER",
				A.DATA_TYPE, A.EDIT_MASK, A.COMBO_LIST, A.FORMAT, A.AFTER_EDIT, B.TRAIT_VAL, TRAIT_ORDER, GROUP_ORDER
			FROM (SELECT Z.CUT_DATE_SCHEDULING, X.TRAIT_GROUP_NAME, X.DISPLAY_NAME "GROUP_DISPLAY_NAME",
						X.DISPLAY_ORDER "GROUP_ORDER", X.TRAIT_GROUP_ID, X.IS_STATEMENT_TYPE_SPECIFIC,
						X.IS_SERIES, Y.TRAIT_INDEX, Y.DISPLAY_NAME, Y.DISPLAY_ORDER "TRAIT_ORDER",
						Y.DATA_TYPE, Y.EDIT_MASK, Y.COMBO_LIST, Y.FORMAT, Y.AFTER_EDIT
    	            FROM TRANSACTION_TRAIT_GROUP X,
						TRANSACTION_TRAIT_ATTRIBUTES Y,
						SYSTEM_DATE_TIME Z,
						RTO_WORK TR
    				WHERE TR.WORK_ID = v_WORK_ID
        				AND X.TRAIT_GROUP_ID = TR.WORK_XID
						AND X.TRAIT_GROUP_INTERVAL IN (v_INTERVAL, p_INTERVAL)
						AND X.IS_SPARSE = 0
        				AND Y.TRAIT_GROUP_ID = X.TRAIT_GROUP_ID
        				AND Y.TRAIT_INDEX = TR.WORK_SEQ
        	            AND Z.TIME_ZONE = p_TIME_ZONE
        	            AND Z.DATA_INTERVAL_TYPE = v_DAY_INTERVAL_TYPE
        	            AND Z.DAY_TYPE = 1
        	            AND Z.CUT_DATE_SCHEDULING BETWEEN v_BEGIN_DATE AND v_END_DATE
        			    AND Z.MINIMUM_INTERVAL_NUMBER >= v_INTERVAL_NUMBER
    	            ) A,
				IT_TRAIT_SCHEDULE B
			WHERE B.TRANSACTION_ID(+) = p_TRANSACTION_ID
				AND B.SCHEDULE_STATE(+) = v_SCHEDULE_STATE
				AND B.SCHEDULE_DATE(+) = A.CUT_DATE_SCHEDULING
				AND B.TRAIT_GROUP_ID(+) = A.TRAIT_GROUP_ID
				AND B.TRAIT_INDEX(+) = A.TRAIT_INDEX
				AND B.STATEMENT_TYPE_ID(+) = CASE A.IS_STATEMENT_TYPE_SPECIFIC
												WHEN 0 THEN 0
												ELSE p_SCHEDULE_TYPE
												END
			) TRAIT
		WHERE STAT.TRANSACTION_ID(+) = p_TRANSACTION_ID
			AND STAT.SCHEDULE_DATE(+) = TRAIT.CUT_DATE_SCHEDULING
			AND SCHED.TRANSACTION_ID(+) = p_TRANSACTION_ID
			AND SCHED.SCHEDULE_TYPE(+) = p_SCHEDULE_TYPE
			AND SCHED.SCHEDULE_STATE(+) = v_SCHEDULE_STATE
			AND SCHED.SCHEDULE_DATE(+) = TRAIT.CUT_DATE_SCHEDULING
		ORDER BY GROUP_ORDER, SET_NUMBER, TRAIT_ORDER, TRAIT.CUT_DATE_SCHEDULING;

		UT.PURGE_RTO_WORK(v_WORK_ID);

END GET_IT_TRAIT_SCHED_DETAIL_RPT;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_IT_TRAIT_SCHED_DETAIL_RPT
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_CUT_DATE_SCHEDULING IN DATE,
	p_TRAIT_GROUP_ID IN NUMBER,
	p_TRAIT_INDEX IN NUMBER,
	p_SET_NUMBER IN NUMBER,
	p_TRAIT_VAL IN VARCHAR,
	p_REASON_FOR_CHANGE IN VARCHAR2,
	p_OTHER_REASON IN VARCHAR2,
	p_PROCESS_MESSAGE IN VARCHAR2
	) AS

-- Delete, Update or Insert to the BID_OFFER_TRAIT table.
BEGIN

	PUT_IT_TRAIT_SCHEDULE_AS_CUT(p_TRANSACTION_ID, p_SCHEDULE_STATE, p_SCHEDULE_TYPE, p_CUT_DATE_SCHEDULING,
								p_TRAIT_GROUP_ID, p_TRAIT_INDEX, p_SET_NUMBER, p_TRAIT_VAL);

	--UPDATE THE STATUS FIELDS.
	IF p_SET_NUMBER = 1 AND (p_REASON_FOR_CHANGE IS NOT NULL OR p_OTHER_REASON IS NOT NULL OR p_PROCESS_MESSAGE IS NOT NULL) THEN
		UPDATE IT_TRAIT_SCHEDULE_STATUS
		SET REASON_FOR_CHANGE = NVL(p_REASON_FOR_CHANGE, REASON_FOR_CHANGE),
			OTHER_REASON = NVL(p_OTHER_REASON, OTHER_REASON),
			PROCESS_MESSAGE = NVL(p_PROCESS_MESSAGE, PROCESS_MESSAGE)
		WHERE TRANSACTION_ID = p_TRANSACTION_ID
			AND SCHEDULE_DATE = p_CUT_DATE_SCHEDULING;

		IF SQL%NOTFOUND THEN
			INSERT INTO IT_TRAIT_SCHEDULE_STATUS
			(
			TRANSACTION_ID,
			SCHEDULE_DATE,
			CREATE_DATE,
			REVIEW_STATUS,
			REASON_FOR_CHANGE,
			OTHER_REASON,
			PROCESS_MESSAGE,
			ENTRY_DATE
			)
			VALUES
			(
			p_TRANSACTION_ID,
			p_CUT_DATE_SCHEDULING,
			SYSDATE,
			'Pending',
			p_REASON_FOR_CHANGE,
			p_OTHER_REASON,
			p_PROCESS_MESSAGE,
			SYSDATE
			);

		END IF;
	END IF;
END PUT_IT_TRAIT_SCHED_DETAIL_RPT;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_SUBMIT_HOURS
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ACTION IN VARCHAR,
	p_ENTITY_LIST IN VARCHAR2,
	p_ENTITY_LIST_DELIMITER IN CHAR,
	p_CURSOR IN OUT GA.REFCURSOR,
    p_STATUS OUT NUMBER
	) AS

v_SYSTIMESTAMP TIMESTAMP WITH TIME ZONE;
v_CUR_HOUR NUMBER(2);
v_TIME_ZONE VARCHAR(8);
v_BID_OFFER_HOURS_TYPE BID_OFFER_HOURS_TYPE;
v_BID_OFFER_HOURS_TABLE BID_OFFER_HOURS_TABLE := BID_OFFER_HOURS_TABLE();
v_TEST_DATE DATE;

BEGIN

  p_STATUS := GA.SUCCESS;

    -- Get TimeZone from the User_Preferences
    SP.GET_TIME_ZONE(v_TIME_ZONE);
	IF TRUNC(p_BEGIN_DATE) <> TRUNC(SYSDATE) OR TRUNC(p_BEGIN_DATE) <> TRUNC(p_END_DATE) THEN
		v_CUR_HOUR := -1;
	ELSE

	-- using the system timestamp
	-- if the tz region has been set on the system then the repeat hour will be handled correctly
	-- otherwise we don't know which 1-2 AM we are currently in so assume HOUR2D
	v_SYSTIMESTAMP := SYSTIMESTAMP;

	v_CUR_HOUR := TO_NUMBER(TO_CHAR(v_SYSTIMESTAMP, 'HH24')) + 1;  -- hour ending
	-- range of v_CUR_HOUR is now 1 through 24
	END IF;

    -- Setup the hours based on the current Hour
    -- Pre-select all hours after the current Hour
	-- the first hour is always 0
    -- in the last hour all are 0

	v_BID_OFFER_HOURS_TYPE := BID_OFFER_HOURS_TYPE(
        CASE WHEN v_CUR_HOUR > 0 THEN 0 ELSE 1 END,
        CASE WHEN v_CUR_HOUR > 1 THEN 0 ELSE 1 END,
        CASE WHEN v_CUR_HOUR > 1 THEN 0 ELSE 1 END, -- HOUR2D
        CASE WHEN v_CUR_HOUR > 2 THEN 0 ELSE 1 END,
        CASE WHEN v_CUR_HOUR > 3 THEN 0 ELSE 1 END,
        CASE WHEN v_CUR_HOUR > 4 THEN 0 ELSE 1 END,
        CASE WHEN v_CUR_HOUR > 5 THEN 0 ELSE 1 END,
        CASE WHEN v_CUR_HOUR > 6 THEN 0 ELSE 1 END,
        CASE WHEN v_CUR_HOUR > 7 THEN 0 ELSE 1 END,
        CASE WHEN v_CUR_HOUR > 8 THEN 0 ELSE 1 END,
        CASE WHEN v_CUR_HOUR > 9 THEN 0 ELSE 1 END,
        CASE WHEN v_CUR_HOUR > 10 THEN 0 ELSE 1 END,
        CASE WHEN v_CUR_HOUR > 11 THEN 0 ELSE 1 END,
        CASE WHEN v_CUR_HOUR > 12 THEN 0 ELSE 1 END,
        CASE WHEN v_CUR_HOUR > 13 THEN 0 ELSE 1 END,
        CASE WHEN v_CUR_HOUR > 14 THEN 0 ELSE 1 END,
        CASE WHEN v_CUR_HOUR > 15 THEN 0 ELSE 1 END,
        CASE WHEN v_CUR_HOUR > 16 THEN 0 ELSE 1 END,
        CASE WHEN v_CUR_HOUR > 17 THEN 0 ELSE 1 END,
        CASE WHEN v_CUR_HOUR > 18 THEN 0 ELSE 1 END,
        CASE WHEN v_CUR_HOUR > 19 THEN 0 ELSE 1 END,
        CASE WHEN v_CUR_HOUR > 20 THEN 0 ELSE 1 END,
        CASE WHEN v_CUR_HOUR > 21 THEN 0 ELSE 1 END,
        CASE WHEN v_CUR_HOUR > 22 THEN 0 ELSE 1 END,
        CASE WHEN v_CUR_HOUR > 23 THEN 0 ELSE 1 END
    );

	-- handle transition days if using daylight savings
	IF v_TIME_ZONE = DST_TIME_ZONE(v_TIME_ZONE) THEN
    	v_TEST_DATE  := TRUNC(p_BEGIN_DATE);
		-- if spring ahead day
    	IF v_TEST_DATE = TRUNC(DST_SPRING_AHEAD_DATE(p_BEGIN_DATE)) THEN
			-- disable repeat and skip hour checkboxes
        	v_BID_OFFER_HOURS_TYPE.HOUR2D := NULL;
        	v_BID_OFFER_HOURS_TYPE.HOUR3 := NULL;
		-- else if fall back day
    	ELSIF v_TEST_DATE = TRUNC(DST_FALL_BACK_DATE(p_BEGIN_DATE)) THEN
			-- check for first HE 2AM
			IF v_CUR_HOUR = 2 THEN
    			IF INSTR(EXTRACT(TIMEZONE_ABBR FROM v_SYSTIMESTAMP), 'DT') > 0 THEN
    				-- turn on second HE 2AM checkbox
					v_BID_OFFER_HOURS_TYPE.HOUR2D := 1;
    			END IF;
			END IF;
		-- this is a non transition day
		ELSE
			-- disable second HE 2AM checkbox
			v_BID_OFFER_HOURS_TYPE.HOUR2D := NULL;
    	END IF;
	END IF;

    v_BID_OFFER_HOURS_TABLE.EXTEND;
    v_BID_OFFER_HOURS_TABLE(1) := v_BID_OFFER_HOURS_TYPE;

    OPEN p_CURSOR FOR
        SELECT *
        FROM TABLE(CAST(v_BID_OFFER_HOURS_TABLE AS BID_OFFER_HOURS_TABLE));


END GET_SUBMIT_HOURS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_FILL_GRID_CONFIG_NAME
    (
     p_PARENT_OBJECT_ID IN NUMBER,
     p_TRANSACTION_ID IN NUMBER,
     p_TYPE IN VARCHAR,
	 p_OBJECT_NAME OUT VARCHAR,
     p_STATUS OUT NUMBER
     ) AS

BEGIN
-- Responsible for creating the system object name of the grid configuration
-- for the Bid Offer Fill Dialog grids
    p_STATUS := GA.SUCCESS;

    p_OBJECT_NAME := 'TRFILL_' || p_TYPE || '_GRID';

END GET_FILL_GRID_CONFIG_NAME;
---------------------------------------------------------------------------------------------------

PROCEDURE GET_FILL_GRID_CONFIG
    (
     p_PARENT_OBJECT_ID IN NUMBER,
     p_TRANSACTION_ID IN NUMBER,
     p_TYPE IN VARCHAR,
	 p_CURSOR IN OUT GA.REFCURSOR,
	 p_MESSAGE OUT VARCHAR,
     p_STATUS OUT NUMBER
     ) AS

     v_GRID_NAME VARCHAR(256);
     v_GRID_ID NUMBER;
     v_COL_ID NUMBER;
     v_COUNT NUMBER;
     v_ORDER NUMBER;
     v_NUMBER_OF_SETS NUMBER;
     v_TRAIT_GROUP_ID NUMBER(9);

CURSOR c_TRAITS IS
	SELECT A.TRAIT_INDEX, B.*
	FROM TRANSACTION_TRAIT A, SYSTEM_OBJECT B
	WHERE A.TRAIT_GROUP_ID = v_TRAIT_GROUP_ID
		AND B.OBJECT_ID = A.SYSTEM_OBJECT_ID
	ORDER BY B.OBJECT_ORDER;

BEGIN
-- Responsible for retrieving/creating the grid configuration for the Bid Offer Fill Dialog grids
-- There will be different grid configurations based on the Type of Grid.
-- It could be the Price Quantity Grid, Ramp Rate Grid, or the Traits Grid.
-- There may be different grid configurations based on the Transaction selected.

    p_STATUS := GA.SUCCESS;

    -- Given this transaction id, dynamically build the grid name
    GET_FILL_GRID_CONFIG_NAME(p_TRANSACTION_ID,p_PARENT_OBJECT_ID,p_TYPE,v_GRID_NAME,p_STATUS);
    IF p_STATUS <> GA.SUCCESS THEN RETURN; END IF;

    -- Check to see if we have a grid configuration with this name
    SO.ID_FOR_SYSTEM_OBJECT(p_PARENT_OBJECT_ID, v_GRID_NAME, 0, 'Grid', 'Default', FALSE, v_GRID_ID);

    IF v_GRID_ID <= 0 THEN
        -- We did not find a stored grid configuration, create a configuration dynamically

        CASE p_TYPE
            WHEN 'PQ' THEN
				v_TRAIT_GROUP_ID := g_TG_OFFER_CURVE;
			WHEN 'RR' THEN
				v_TRAIT_GROUP_ID := g_TG_RAMP_CURVE;
			ELSE
				BEGIN
					SELECT TRAIT_GROUP_ID
					INTO v_TRAIT_GROUP_ID
					FROM TRANSACTION_TRAIT_GROUP
					WHERE TRAIT_GROUP_NAME = p_TYPE;
				EXCEPTION
					WHEN OTHERS THEN
						ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
						v_TRAIT_GROUP_ID := 0;
        		        p_MESSAGE := 'Could not setup grid for grid type = ' || p_TYPE || '. This is an unknown type';
						RETURN;
				END;
		END CASE;

		-- First get the default settings for this transaction
		v_NUMBER_OF_SETS := MM.GET_DEFAULT_NUMBER_OF_SETS(p_TRANSACTION_ID, v_TRAIT_GROUP_ID);

		-- Create Grid
		SO.PUT_SYSTEM_OBJECT_FOR_SCRIPT(p_PARENT_OBJECT_ID, v_GRID_NAME, 'Grid', v_GRID_NAME, '', 0, 0, '305~1', v_GRID_ID);

		-- Create Hour Columns
		SO.PUT_SYSTEM_OBJECT_FOR_SCRIPT(v_GRID_ID, 'BEGIN_HOUR', 'Column', 'Begin Hour', '', 1, 0, '1~n (Numeric Edit)', v_COL_ID);
		SO.PUT_SYSTEM_OBJECT_FOR_SCRIPT(v_GRID_ID, 'END_HOUR', 'Column', 'End Hour', '', 2, 0, '1~n (Numeric Edit)', v_COL_ID);

		-- Create Trait Columns
		v_COUNT := 1;
		v_ORDER := 3;
		WHILE v_COUNT <= v_NUMBER_OF_SETS LOOP

			FOR v_TRAITS IN c_TRAITS LOOP
				SO.PUT_SYSTEM_OBJECT_FOR_SCRIPT(v_GRID_ID, v_TRAITS.OBJECT_NAME || '~' || TRIM(TO_CHAR(v_COUNT,'00')), 'Column', v_TRAITS.OBJECT_DISPLAY_NAME || v_COUNT, '', v_ORDER, 0, '', v_COL_ID);

				--Insert everything but "Data Type" since a Trait Data Type is not the same as a Column Data Type.
				INSERT INTO SYSTEM_OBJECT_ATTRIBUTE
					SELECT v_COL_ID, A.ATTRIBUTE_ID, A.ATTRIBUTE_VAL
					FROM SYSTEM_OBJECT_ATTRIBUTE A
					WHERE OBJECT_ID = v_TRAITS.OBJECT_ID
						AND NOT ATTRIBUTE_ID = 4;

				--Insert an Edit Type.
				BEGIN
					INSERT INTO SYSTEM_OBJECT_ATTRIBUTE
					SELECT v_COL_ID, 1, CASE A.ATTRIBUTE_VAL WHEN 'Number' THEN 'n (Numeric Edit)' ELSE 'e (Standard Edit)' END
					FROM SYSTEM_OBJECT_ATTRIBUTE A
					WHERE OBJECT_ID = v_TRAITS.OBJECT_ID
						AND ATTRIBUTE_ID = 4;
				EXCEPTION
					WHEN DUP_VAL_ON_INDEX THEN
						ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
						NULL;
				END;

				v_ORDER := v_ORDER + 1;
			END LOOP;
			v_COUNT := v_COUNT + 1;
		END LOOP;

		COMMIT;
    END IF;

    SO.GET_GRID_COL_HIERARCHY('',
                p_PARENT_OBJECT_ID,
                v_GRID_NAME,
                0,
                'Default',
                v_GRID_ID,
                p_STATUS,
                p_CURSOR);

END GET_FILL_GRID_CONFIG;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_TRAIT_FILL_TEMPLATE
    (
     p_TRANSACTION_ID IN NUMBER,
     p_TEMPLATE_NAME IN VARCHAR,
     p_TYPE IN VARCHAR,
	 p_CURSOR IN OUT GA.REFCURSOR,
	 p_MESSAGE OUT VARCHAR,
     p_STATUS OUT NUMBER
     ) AS

     v_TEMPLATE_EXISTS NUMBER := 0;
BEGIN
-- Responsible the Bid Offer Template data for the given Template and Grid Type
-- Examples of Grid Type are PQ = Price Quantity, RR = Ramp Rates, RT = Resource Traits.

    p_STATUS := GA.SUCCESS;

    SELECT A.COMMODITY_ID
        INTO v_TEMPLATE_EXISTS
        FROM TRANSACTION_TRAIT_TEMPLATE A, INTERCHANGE_TRANSACTION B
        WHERE B.TRANSACTION_ID = p_TRANSACTION_ID
        AND A.COMMODITY_ID = B.COMMODITY_ID
        AND A.TRAIT_TEMPLATE_NAME = TRIM(p_TEMPLATE_NAME)
        AND A.TEMPLATE_TYPE = TRIM(p_TYPE)
        AND ROWNUM = 1;

        IF v_TEMPLATE_EXISTS >= 0 THEN
            OPEN p_CURSOR FOR
              SELECT TEMPLATE_DATA "COL_DATA" -- Use special column name for MightyGrid
    		  FROM TRANSACTION_TRAIT_TEMPLATE A, INTERCHANGE_TRANSACTION B
    		  WHERE B.TRANSACTION_ID = p_TRANSACTION_ID
    				AND A.COMMODITY_ID = B.COMMODITY_ID
    				AND A.TRAIT_TEMPLATE_NAME = TRIM(p_TEMPLATE_NAME)
                    AND A.TEMPLATE_TYPE = TRIM(p_TYPE)
              ORDER BY A.ROW_NUMBER;
         END IF;

    EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
            OPEN p_CURSOR FOR
                SELECT NULL "BEGIN_HOUR", NULL "END_HOUR" FROM DUAL;

END GET_TRAIT_FILL_TEMPLATE;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_TRAIT_FILL_TEMPLATE
    (
     p_TRANSACTION_ID IN NUMBER,
     p_TEMPLATE_NAME IN VARCHAR,
     p_TYPE IN VARCHAR,
     p_ROW_NUMBER IN NUMBER,
     p_TEMPLATE_DATA IN VARCHAR,
     p_STATUS OUT NUMBER
     ) AS

v_COMMODITY_ID NUMBER(9);
BEGIN
-- Responsible the Bid Offer Template data for the given Template and Grid Type
-- Examples of Grid Type are PQ = Price Quantity, RR = Ramp Rates, RT = Resource Traits.

    p_STATUS := GA.SUCCESS;

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	SELECT COMMODITY_ID
	INTO v_COMMODITY_ID
	FROM INTERCHANGE_TRANSACTION
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

	--ATTEMPT AN UPDATE.
		UPDATE TRANSACTION_TRAIT_TEMPLATE SET
			TEMPLATE_DATA = LTRIM(p_TEMPLATE_DATA),
			ENTRY_DATE = SYSDATE
		WHERE COMMODITY_ID = v_COMMODITY_ID
			AND TRAIT_TEMPLATE_NAME = p_TEMPLATE_NAME
            AND ROW_NUMBER = p_ROW_NUMBER
            AND TEMPLATE_TYPE = p_TYPE;

-- IF THE PREVIOUS UPDATE DID NOT FIND A MATCH, THEN INSERT A NEW RECORD
	IF SQL%NOTFOUND THEN
		INSERT INTO TRANSACTION_TRAIT_TEMPLATE (
			COMMODITY_ID,
			TRAIT_TEMPLATE_NAME,
			TEMPLATE_DATA,
			ROW_NUMBER,
            TEMPLATE_TYPE,
			ENTRY_DATE)
		VALUES (
			v_COMMODITY_ID,
			p_TEMPLATE_NAME,
			TRIM(p_TEMPLATE_DATA),
			p_ROW_NUMBER,
            p_TYPE,
			SYSDATE);
	END IF;

END PUT_TRAIT_FILL_TEMPLATE;
---------------------------------------------------------------------------------------------------
PROCEDURE REMOVE_TRAIT_FILL_TEMPLATE
	(
	p_TRANSACTION_ID IN NUMBER,
    p_TEMPLATE_NAME IN VARCHAR,
    p_TYPE IN VARCHAR,
    p_STATUS OUT NUMBER
	)
	AS

v_COMMODITY_ID NUMBER(9);
BEGIN

	p_STATUS := GA.SUCCESS;

    SELECT COMMODITY_ID
	INTO v_COMMODITY_ID
	FROM INTERCHANGE_TRANSACTION
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

    DELETE FROM TRANSACTION_TRAIT_TEMPLATE T
	WHERE T.TRAIT_TEMPLATE_NAME = p_TEMPLATE_NAME
    AND T.COMMODITY_ID = v_COMMODITY_ID
    AND T.TEMPLATE_TYPE = p_TYPE;


END REMOVE_TRAIT_FILL_TEMPLATE;
---------------------------------------------------------------------------------------------------
PROCEDURE FILL_IT_TRAIT_SCHEDULE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
    p_BEGIN_HOUR IN NUMBER,
    p_END_HOUR IN NUMBER,
    p_INCLUDE_HOLIDAYS IN NUMBER,
	p_DAY_TEMPLATE IN VARCHAR,
	p_TRAIT_TEMPLATE IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

-- Fill the BID_OFFER_SET table for the given date range.
v_CUR_DATE DATE;
v_SCHEDULE_DATE DATE;

v_NAME_VALUE_PAIRS GA.STRING_TABLE;
v_NAME_VALUE_PAIR GA.STRING_TABLE;
v_NAME VARCHAR(256);
v_VALUE NUMBER;
v_INDEX BINARY_INTEGER;
v_TRAIT_GROUP_NAME VARCHAR2(128);
v_TRAIT_GROUP_ID NUMBER(9);
v_TRAIT_INDEX NUMBER(3);
v_SET_NUMBER NUMBER;
v_LOOP_COUNTER NUMBER := 0;
v_DATA_INTERVAL VARCHAR2(16);
v_BEGIN_HOUR NUMBER(2);
v_END_HOUR NUMBER(2);
v_TMP_TIME DATE;
v_END_TIME DATE;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_DATE_INCREMENT VARCHAR2(16);
v_SCHEDULE_STATE NUMBER(9) := 1; -- INTERNAL
v_SCHEDULE_TYPE NUMBER(9) := 0; -- ALL TYPES
v_TIME_ZONE VARCHAR(8);
v_INCLUDE_DAY BOOLEAN;
v_DAY CHAR(3);
v_ANY_DAY BOOLEAN;
v_WEEK_DAY BOOLEAN;
v_WEEK_END BOOLEAN;
v_MON BOOLEAN;
v_TUE BOOLEAN;
v_WED BOOLEAN;
v_THU BOOLEAN;
v_FRI BOOLEAN;
v_SAT BOOLEAN;
v_SUN BOOLEAN;
v_YES CHAR(1) := '1';
v_EDC_ID NUMBER := 0;

BEGIN

    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_BAO_UPDATE, p_TRANSACTION_ID, EC.ED_TRANSACTION);

	ASSERT(p_TRANSACTION_ID IS NOT NULL, 'You must specify a transaction');

    p_STATUS := GA.SUCCESS;

    v_DATA_INTERVAL := MM.GET_BID_OFFER_INTERVAL(p_TRANSACTION_ID);
    --DON'T LOOP OVER THE HOURS IF THIS IS DAILY DATA.
	--ADVANCE THE DATE BY EITHER DAY, OR A LARGER INTERVAL.
	IF INTERVAL_IS_ATLEAST_DAILY(v_DATA_INTERVAL) THEN
       v_BEGIN_HOUR := 0;
       v_END_HOUR := 0;
	   v_DATE_INCREMENT := v_DATA_INTERVAL;
	ELSE
	   v_BEGIN_HOUR := p_BEGIN_HOUR;
	   v_END_HOUR := p_END_HOUR;
	   v_DATE_INCREMENT := 'DD';
	END IF;

    SP.GET_TIME_ZONE( v_TIME_ZONE);

    UT.CUT_DAY_INTERVAL_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, v_TIME_ZONE, v_DATE_INCREMENT, v_BEGIN_DATE, v_END_DATE);

    SELECT NVL(EDC_ID,0) INTO v_EDC_ID FROM INTERCHANGE_TRANSACTION WHERE TRANSACTION_ID = p_TRANSACTION_ID;

    -- Decode the JAVA template
	v_ANY_DAY := SUBSTR(p_DAY_TEMPLATE,1,1) = v_YES;
	v_WEEK_DAY := SUBSTR(p_DAY_TEMPLATE,2,1) = v_YES;
	v_WEEK_END := SUBSTR(p_DAY_TEMPLATE,3,1) = v_YES;
	v_MON := SUBSTR(p_DAY_TEMPLATE,4,1) = v_YES;
	v_TUE := SUBSTR(p_DAY_TEMPLATE,5,1) = v_YES;
	v_WED := SUBSTR(p_DAY_TEMPLATE,6,1) = v_YES;
	v_THU := SUBSTR(p_DAY_TEMPLATE,7,1) = v_YES;
	v_FRI := SUBSTR(p_DAY_TEMPLATE,8,1) = v_YES;
	v_SAT := SUBSTR(p_DAY_TEMPLATE,9,1) = v_YES;
	v_SUN := SUBSTR(p_DAY_TEMPLATE,10,1) = v_YES;

-- 	--Do some special handling for the IMO Expiration date and daytype
-- 	SELECT BID_OFFER_IS_DEFAULT INTO v_BID_OFFER_IS_DEFAULT FROM BID_OFFER WHERE BID_OFFER_ID = v_BID_OFFER_ID;
-- 	IF v_BID_OFFER_IS_DEFAULT = 1 THEN
-- 		v_EXPIRATION_DATE_TRAIT_ID := ID.ID_FOR_RESOURCE_TRAIT('IMO Expiration Date');
-- 		v_DAY_TYPE_TRAIT_ID := ID.ID_FOR_RESOURCE_TRAIT('IMO Day Type');
-- 	END IF;

    -- Parse all the name/value pairs
	UT.TOKENS_FROM_STRING(p_TRAIT_TEMPLATE, ';', v_NAME_VALUE_PAIRS);

    -- LOOP over all the name value pairs until we find a price and a quantity value
	IF v_NAME_VALUE_PAIRS.EXISTS(1) THEN

        v_SET_NUMBER := 0;
        FOR v_INDEX IN v_NAME_VALUE_PAIRS.FIRST..v_NAME_VALUE_PAIRS.LAST LOOP

            -- Parse out the name and value strings from the name/value pair
            UT.TOKENS_FROM_STRING(v_NAME_VALUE_PAIRS(v_INDEX),'=',v_NAME_VALUE_PAIR);

			--BEGIN_HOUR=1.0;END_HOUR=24.0;Offer Curve.1~01=3;Offer Curve.2~01=4;Offer Curve.1~02=5;Offer Curve.2~02=6
			--Make sure this is a valid column (it has a set number in it).
			IF v_NAME_VALUE_PAIR.EXISTS(1) THEN
				v_NAME := v_NAME_VALUE_PAIR(1);
				v_VALUE := v_NAME_VALUE_PAIR(2);
				IF INSTR(v_NAME, '~') > 0 THEN
					v_SET_NUMBER := TO_NUMBER(SUBSTR(v_NAME,-2));
					v_TRAIT_GROUP_NAME := SUBSTR(v_NAME, 1, INSTR(v_NAME, '.') - 1);
					SELECT TRAIT_GROUP_ID INTO v_TRAIT_GROUP_ID FROM TRANSACTION_TRAIT_GROUP WHERE TRAIT_GROUP_NAME = v_TRAIT_GROUP_NAME;
					v_TRAIT_INDEX := SUBSTR(v_NAME, INSTR(v_NAME, '.') + 1, INSTR(v_NAME, '~') - INSTR(v_NAME, '.') - 1);
					v_CUR_DATE := v_BEGIN_DATE;

        			WHILE v_CUR_DATE <= v_END_DATE LOOP

                        v_DAY := SUBSTR(TO_CHAR(v_CUR_DATE, 'DAY'), 1, 3);

                        v_INCLUDE_DAY := TRUE;
                    	IF p_INCLUDE_HOLIDAYS = 0 THEN
                			IF IS_HOLIDAY(v_CUR_DATE, v_EDC_ID) THEN
                		    	v_INCLUDE_DAY := FALSE;
                			END IF;
                		END IF;

                        IF v_INCLUDE_DAY AND (v_ANY_DAY
                			OR (v_WEEK_DAY AND v_DAY IN ('MON','TUE','WED','THU','FRI'))
                			OR (v_WEEK_END AND v_DAY IN ('SAT','SUN'))
                			OR (v_MON AND v_DAY = 'MON')
                			OR (v_TUE AND v_DAY = 'TUE')
                			OR (v_WED AND v_DAY = 'WED')
                			OR (v_THU AND v_DAY = 'THU')
                			OR (v_FRI AND v_DAY = 'FRI')
                			OR (v_SAT AND v_DAY = 'SAT')
                			OR (v_SUN AND v_DAY = 'SUN')) THEN

-- THIS WAS FOR THE IMO MARKET (TRANSALTA).  WE NEED TO FIND A BETTER WAY.
--         					--PUT IN THE DAILY EXPIRATION DATE AND DAY TYPE.
--         					IF v_EXPIRATION_DATE_TRAIT_ID > 0 AND v_DAY_TYPE_TRAIT_ID > 0 THEN
--         						PUT_BID_OFFER_TRAIT(p_TRANSACTION_ID, v_BID_OFFER_ID, v_SCHEDULE_STATE, v_CUR_DATE, v_EXPIRATION_DATE_TRAIT_ID, p_EXPIRATION_DATE, v_TIME_ZONE, p_STATUS);
--         						PUT_BID_OFFER_TRAIT(p_TRANSACTION_ID, v_BID_OFFER_ID, v_SCHEDULE_STATE, v_CUR_DATE, v_DAY_TYPE_TRAIT_ID, v_DAY, v_TIME_ZONE, p_STATUS);
--         					END IF;
--
							v_TMP_TIME := TRUNC(v_CUR_DATE) + v_BEGIN_HOUR/24;
							v_SCHEDULE_DATE := TO_CUT(v_TMP_TIME, v_TIME_ZONE);
							-- this could happen if begin hour indicates HE 2 of the spring
							-- ahead date and v_TIME_ZONE observes DST
							IF FROM_CUT(v_SCHEDULE_DATE,v_TIME_ZONE) <> v_TMP_TIME THEN
								v_SCHEDULE_DATE := v_SCHEDULE_DATE+1/24;
							END IF;
							-- if sub-hourly, then we begin before specified hour ending
							-- (since the hour specified is the *end* of the hour)
							v_SCHEDULE_DATE := ADVANCE_DATE(v_SCHEDULE_DATE-1/24, v_DATA_INTERVAL);

							v_TMP_TIME := TRUNC(v_CUR_DATE) + v_END_HOUR/24 + 1/86400;
							-- add extra second - so if v_TIME_ZONE observes DST and end hour
							-- is HE 2, then this will cause v_END_TIME to go through the
							-- *second* HE 2
							v_END_TIME := TO_CUT(v_TMP_TIME, v_TIME_ZONE);

        				 	WHILE v_SCHEDULE_DATE <= v_END_TIME LOOP
								-- pass CUT_TIME_ZONE because we've already computed CUT time
        						PUT_IT_TRAIT_SCHEDULE(p_TRANSACTION_ID, v_SCHEDULE_STATE, v_SCHEDULE_TYPE, v_SCHEDULE_DATE, v_TRAIT_GROUP_ID, v_TRAIT_INDEX, v_SET_NUMBER, v_VALUE, CUT_TIME_ZONE);
								v_SCHEDULE_DATE := ADVANCE_DATE(v_SCHEDULE_DATE, v_DATA_INTERVAL);

        						--MAKE SURE WE AREN'T LOOPING FOREVER
        						v_LOOP_COUNTER := v_LOOP_COUNTER + 1;
        						IF v_LOOP_COUNTER > 10000000 THEN
        							ERRS.RAISE(MSGCODES.c_ERR_RUNAWAY_LOOP);
        						END IF;

        					END LOOP; -- OVER HOURS
        				END IF;
        				v_CUR_DATE := ADVANCE_DATE(v_CUR_DATE, v_DATE_INCREMENT);
        			END LOOP; -- OVER DAYS

				END IF; -- VALID NAME CHECK
	   		END IF; -- NAME NOT NULL CHECK
    	END LOOP; -- OVER NAMEVALUE PAIRS
    END IF;

END FILL_IT_TRAIT_SCHEDULE;
---------------------------------------------------------------------------------------------------
PROCEDURE IT_TRAIT_STATUS_ACCEPT
	(
	p_TRANSACTION_ID IN NUMBER,
	p_CUT_DATE_SCHEDULING IN DATE
	) AS
BEGIN
	UPDATE IT_TRAIT_SCHEDULE_STATUS
	SET REVIEW_STATUS = 'Accepted',
		REVIEW_DATE = SYSDATE,
		REVIEWED_BY_ID = SECURITY_CONTROLS.CURRENT_USER_ID,
		SUBMIT_STATUS = NULL,
		SUBMIT_DATE = NULL,
		MARKET_STATUS = NULL,
		MARKET_STATUS_DATE = NULL,
		PROCESS_MESSAGE = NULL
	WHERE TRANSACTION_ID = p_TRANSACTION_ID
		AND SCHEDULE_DATE = p_CUT_DATE_SCHEDULING
		AND UPPER(REVIEW_STATUS) IN ('PENDING', 'CHANGED', 'VALID', 'REJECTED', 'CANCELLED');
END IT_TRAIT_STATUS_ACCEPT;
---------------------------------------------------------------------------------------------------
PROCEDURE IT_TRAIT_STATUS_ACCEPT
	(
	p_TRANSACTION_ID IN NUMBER,
	p_CUT_DATE_SCHEDULING IN DATE_COLLECTION
	) AS

-- Set the status for the selected ID and dates.
v_INDEX BINARY_INTEGER;
v_DATE DATE;
BEGIN

    ASSERT(p_TRANSACTION_ID IS NOT NULL, 'You must specify a transaction');
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_BAO_UPDATE,p_TRANSACTION_ID,EC.ED_TRANSACTION);

	v_INDEX := p_CUT_DATE_SCHEDULING.FIRST;
	WHILE p_CUT_DATE_SCHEDULING.EXISTS(v_INDEX) LOOP
		v_DATE := p_CUT_DATE_SCHEDULING(v_INDEX);

		IT_TRAIT_STATUS_ACCEPT(p_TRANSACTION_ID, v_DATE);

		v_INDEX := p_CUT_DATE_SCHEDULING.NEXT(v_INDEX);
	END LOOP;

END IT_TRAIT_STATUS_ACCEPT;
---------------------------------------------------------------------------------------------------
PROCEDURE IT_TRAIT_STATUS_ACCEPT_TXNS
	(
	p_TRANSACTION_ID IN NUMBER_COLLECTION,
	p_SCHEDULE_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2
	) AS

-- Set the status for the selected IDs and date.
v_IDs NUMBER_COLLECTION;
v_INDEX BINARY_INTEGER;
v_ID NUMBER(9);
v_DATE DATE;
BEGIN

    ASSERT(p_TRANSACTION_ID IS NOT NULL, 'You must specify a transaction');
    ASSERT(p_TRANSACTION_ID.COUNT > 0, 'You must specify a transaction');

	v_IDs := SD.GET_ALLOWED_IDS_FROM_SELECTION(SD.g_ACTION_BAO_ACCEPT, EC.ED_TRANSACTION, p_TRANSACTION_ID);

	v_INDEX := v_IDs.FIRST;
	WHILE v_IDs.EXISTS(v_INDEX) LOOP
		v_ID := v_IDs(v_INDEX);
		v_DATE := GET_TRAIT_SCHEDULE_DATE(v_ID, p_SCHEDULE_DATE, p_TIME_ZONE);

		IT_TRAIT_STATUS_ACCEPT(v_ID, v_DATE);

		v_INDEX := v_IDs.NEXT(v_INDEX);
	END LOOP;

END IT_TRAIT_STATUS_ACCEPT_TXNS;
---------------------------------------------------------------------------------------------------
PROCEDURE IT_TRAIT_ACCEPT_EXTERNAL
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE
	) AS

v_TIME_ZONE VARCHAR(8);
v_BEGIN_DATE DATE;
v_END_DATE DATE;
BEGIN

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_BAO_ACCEPT_EXT, p_TRANSACTION_ID, EC.ED_TRANSACTION);

    ASSERT(p_TRANSACTION_ID IS NOT NULL, 'You must specify a transaction');

    SP.GET_TIME_ZONE(v_TIME_ZONE);

	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, v_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	--Copy Non-Sparse traits
	DELETE FROM IT_TRAIT_SCHEDULE
	WHERE TRANSACTION_ID = p_TRANSACTION_ID
		AND SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE
		AND SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND TRAIT_GROUP_ID IN (SELECT TRAIT_GROUP_ID FROM TRANSACTION_TRAIT_GROUP WHERE IS_SPARSE = 0);

	INSERT INTO IT_TRAIT_SCHEDULE (TRANSACTION_ID, SCHEDULE_STATE, SCHEDULE_DATE, TRAIT_GROUP_ID, TRAIT_INDEX, SET_NUMBER,
		STATEMENT_TYPE_ID, SCHEDULE_END_DATE, TRAIT_VAL, ENTRY_DATE)
	SELECT TRANSACTION_ID, CONSTANTS.INTERNAL_STATE, SCHEDULE_DATE, TRAIT_GROUP_ID, TRAIT_INDEX, SET_NUMBER,
		STATEMENT_TYPE_ID, SCHEDULE_END_DATE, TRAIT_VAL, SYSDATE
	FROM IT_TRAIT_SCHEDULE
	WHERE TRANSACTION_ID = p_TRANSACTION_ID
		AND SCHEDULE_STATE = CONSTANTS.EXTERNAL_STATE
		AND SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND TRAIT_GROUP_ID IN (SELECT TRAIT_GROUP_ID FROM TRANSACTION_TRAIT_GROUP WHERE IS_SPARSE = 0);

	--Copy Sparse traits
	DELETE FROM IT_TRAIT_SCHEDULE
	WHERE TRANSACTION_ID = p_TRANSACTION_ID
		AND SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE
		AND SCHEDULE_DATE <= v_END_DATE
		AND NVL(SCHEDULE_END_DATE, v_BEGIN_DATE) >= v_BEGIN_DATE
		AND TRAIT_GROUP_ID IN (SELECT TRAIT_GROUP_ID FROM TRANSACTION_TRAIT_GROUP WHERE IS_SPARSE = 1);

	INSERT INTO IT_TRAIT_SCHEDULE (TRANSACTION_ID, SCHEDULE_STATE, SCHEDULE_DATE, TRAIT_GROUP_ID, TRAIT_INDEX, SET_NUMBER,
		STATEMENT_TYPE_ID, SCHEDULE_END_DATE, TRAIT_VAL, ENTRY_DATE)
	SELECT TRANSACTION_ID, CONSTANTS.INTERNAL_STATE, SCHEDULE_DATE, TRAIT_GROUP_ID, TRAIT_INDEX, SET_NUMBER,
		STATEMENT_TYPE_ID, SCHEDULE_END_DATE, TRAIT_VAL, SYSDATE
	FROM IT_TRAIT_SCHEDULE
	WHERE TRANSACTION_ID = p_TRANSACTION_ID
		AND SCHEDULE_STATE = CONSTANTS.EXTERNAL_STATE
		AND SCHEDULE_DATE <= v_END_DATE
		AND NVL(SCHEDULE_END_DATE, v_BEGIN_DATE) >= v_BEGIN_DATE
		AND TRAIT_GROUP_ID IN (SELECT TRAIT_GROUP_ID FROM TRANSACTION_TRAIT_GROUP WHERE IS_SPARSE = 1);

	--UPDATE STATUS
	UPDATE IT_TRAIT_SCHEDULE_STATUS
	SET MARKET_STATUS = 'Accepted',
		MARKET_STATUS_DATE = SYSDATE,
		PROCESS_MESSAGE = NULL
	WHERE TRANSACTION_ID = p_TRANSACTION_ID
		AND SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE;

	--LOG MESSAGE
	LOGS.LOG_INFO('Accepted external bid data for ' || TEXT_UTIL.TO_CHAR_ENTITY(p_TRANSACTION_ID, EC.ED_TRANSACTION, TRUE) ||
                  ' (' || TEXT_UTIL.TO_CHAR_ENTITY(p_SCHEDULE_TYPE, EC.ED_STATEMENT_TYPE, TRUE) ||
				  ', ' || TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE) ||
				  ' -> ' || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE) ||
				  ' ' || v_TIME_ZONE || ')');

END IT_TRAIT_ACCEPT_EXTERNAL;
---------------------------------------------------------------------------
PROCEDURE UPSERT_TRAIT_GROUP
	(
	p_TRANSACTION_TRAIT_GROUP IN TRANSACTION_TRAIT_GROUP%ROWTYPE
	) AS
BEGIN
	INSERT INTO TRANSACTION_TRAIT_GROUP VALUES p_TRANSACTION_TRAIT_GROUP;
EXCEPTION
	WHEN DUP_VAL_ON_INDEX THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		UPDATE TRANSACTION_TRAIT_GROUP
		SET TRAIT_GROUP_NAME = p_TRANSACTION_TRAIT_GROUP.TRAIT_GROUP_NAME,
			TRAIT_GROUP_ALIAS = p_TRANSACTION_TRAIT_GROUP.TRAIT_GROUP_ALIAS,
			TRAIT_GROUP_DESC = p_TRANSACTION_TRAIT_GROUP.TRAIT_GROUP_DESC,
			TRAIT_GROUP_INTERVAL = p_TRANSACTION_TRAIT_GROUP.TRAIT_GROUP_INTERVAL,
			TRAIT_GROUP_TYPE = p_TRANSACTION_TRAIT_GROUP.TRAIT_GROUP_TYPE,
			SC_ID = p_TRANSACTION_TRAIT_GROUP.SC_ID,
			TRAIT_CATEGORY = p_TRANSACTION_TRAIT_GROUP.TRAIT_CATEGORY,
			DISPLAY_NAME = p_TRANSACTION_TRAIT_GROUP.DISPLAY_NAME,
			DISPLAY_ORDER = p_TRANSACTION_TRAIT_GROUP.DISPLAY_ORDER,
			IS_SPARSE = p_TRANSACTION_TRAIT_GROUP.IS_SPARSE,
			IS_SERIES = p_TRANSACTION_TRAIT_GROUP.IS_SERIES,
			IS_STATEMENT_TYPE_SPECIFIC = p_TRANSACTION_TRAIT_GROUP.IS_STATEMENT_TYPE_SPECIFIC,
			DEFAULT_NUMBER_OF_SETS = p_TRANSACTION_TRAIT_GROUP.DEFAULT_NUMBER_OF_SETS,
			ENTRY_DATE = SYSDATE
		WHERE TRAIT_GROUP_ID = p_TRANSACTION_TRAIT_GROUP.TRAIT_GROUP_ID;
END UPSERT_TRAIT_GROUP;
---------------------------------------------------------------------------
PROCEDURE COPY_IT_TRAIT_SCHEDULE
	(
	p_SRC_TRANSACTION_ID IN NUMBER,
	p_SRC_BEGIN_DATE IN DATE,
	p_SRC_END_DATE IN DATE,
	p_SRC_SCHEDULE_STATE IN NUMBER,
	p_TRG_TRANSACTION_ID IN NUMBER,
	p_TRG_BEGIN_DATE IN DATE,
	p_TRG_END_DATE IN DATE,
	p_TRG_SCHEDULE_STATE IN NUMBER,
	p_TRG_DELETE IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

v_FIRST BOOLEAN;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_TRG_DATE DATE;
v_SRC_TRG_DIFF NUMBER;
v_SRC_BEGIN_END_DIFF NUMBER;
v_LAST_DATE DATE := LOW_DATE;

CURSOR c_TRAITS IS
	SELECT SCHEDULE_DATE,
		TRAIT_GROUP_ID,
		TRAIT_INDEX,
		SET_NUMBER,
		STATEMENT_TYPE_ID,
		SCHEDULE_END_DATE,
		TRAIT_VAL
	FROM IT_TRAIT_SCHEDULE
	WHERE TRANSACTION_ID = p_SRC_TRANSACTION_ID
		AND SCHEDULE_STATE = p_SRC_SCHEDULE_STATE
		AND SCHEDULE_DATE BETWEEN p_SRC_BEGIN_DATE AND p_SRC_END_DATE
	ORDER BY SCHEDULE_DATE;
v_TRAITS c_TRAITS%ROWTYPE;

BEGIN
	SAVEPOINT BEFORE_COPY_TRAITS;

	p_STATUS := GA.SUCCESS;
	v_SRC_BEGIN_END_DIFF := p_SRC_END_DATE - p_SRC_BEGIN_DATE;
	v_TRG_DATE := p_TRG_BEGIN_DATE;
	v_BEGIN_DATE := p_TRG_BEGIN_DATE;
	v_END_DATE := p_TRG_BEGIN_DATE + v_SRC_BEGIN_END_DIFF;
	-- update target's begin and end dates to make sure they accomodate the new data
	UPDATE INTERCHANGE_TRANSACTION
	SET BEGIN_DATE = LEAST(BEGIN_DATE,TRUNC(p_TRG_BEGIN_DATE)),
		END_DATE = GREATEST(END_DATE,TRUNC(ADD_SECONDS_TO_DATE(p_TRG_END_DATE,-1)))
	WHERE TRANSACTION_ID = p_TRG_TRANSACTION_ID;
	-- loop through, auto-wrapping in case where target dates further apart than source dates
	WHILE v_BEGIN_DATE <= p_TRG_END_DATE LOOP
		-- update target/source delta for this iteration
		v_SRC_TRG_DIFF := v_BEGIN_DATE - p_SRC_BEGIN_DATE;
		v_FIRST := TRUE;
		OPEN c_TRAITS;
		LOOP
			IF v_FIRST THEN
				-- delete here, after cursor is opened, in case delete would wipe out
				-- entries we need for copy (in case of overlapping dates copied into
				-- the same schedule as source)
				IF p_TRG_DELETE = 1 THEN
					DECLARE
						v_TRG_END DATE;
					BEGIN
						SELECT LEAST(v_END_DATE,p_TRG_END_DATE) INTO v_TRG_END FROM DUAL;
						DELETE FROM IT_TRAIT_SCHEDULE
						WHERE TRANSACTION_ID = p_TRG_TRANSACTION_ID
							AND SCHEDULE_STATE = p_TRG_SCHEDULE_STATE
							AND SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_TRG_END;
					END;
				END IF;
				v_FIRST := FALSE;
			END IF;
			FETCH c_TRAITS INTO v_TRAITS;
			EXIT WHEN c_TRAITS%NOTFOUND;
			v_TRG_DATE := v_TRAITS.SCHEDULE_DATE + v_SRC_TRG_DIFF;
			EXIT WHEN v_TRG_DATE > p_TRG_END_DATE;
			IF v_TRG_DATE <> v_LAST_DATE AND p_TRG_DELETE = 0 THEN
				-- clear out all sets for this date if not done already
				DELETE FROM IT_TRAIT_SCHEDULE
				WHERE TRANSACTION_ID = p_TRG_TRANSACTION_ID
					AND SCHEDULE_STATE = p_TRG_SCHEDULE_STATE
					AND SCHEDULE_DATE = v_TRG_DATE
					AND TRAIT_GROUP_ID = v_TRAITS.TRAIT_GROUP_ID
					AND TRAIT_INDEX = v_TRAITS.TRAIT_INDEX;
				v_LAST_DATE := v_TRG_DATE;
			END IF;

			PUT_IT_TRAIT_SCHEDULE(p_TRG_TRANSACTION_ID, p_TRG_SCHEDULE_STATE, v_TRAITS.STATEMENT_TYPE_ID, v_TRG_DATE, v_TRAITS.TRAIT_GROUP_ID, v_TRAITS.TRAIT_INDEX, v_TRAITS.SET_NUMBER, v_TRAITS.TRAIT_VAL, CUT_TIME_ZONE);
		END LOOP;
		CLOSE c_TRAITS;
		-- set our dates for the next iteration/section
		v_BEGIN_DATE := ADD_SECONDS_TO_DATE(v_END_DATE,1);
		v_END_DATE := v_BEGIN_DATE + v_SRC_BEGIN_END_DIFF;
	END LOOP;

EXCEPTION
	WHEN OTHERS THEN
		-- CLOSE CURSOR
		BEGIN
			CLOSE c_TRAITS;
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE();
		END;
		ERRS.LOG_AND_RAISE(p_SAVEPOINT_NAME => 'BEFORE_COPY_TRAITS');
END COPY_IT_TRAIT_SCHEDULE;
---------------------------------------------------------------------------
PROCEDURE TRAIT_GROUP_INDEX_LIST_SPARSE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_TRAIT_GROUP_FILTER IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
	v_WORK_ID NUMBER(9);
BEGIN

	-- Get the list of Trait Group IDS from the appropriate market.
	MM.GET_TRAITS_FOR_TRANSACTION(p_TRANSACTION_ID, 'Sparse List', p_TRAIT_GROUP_FILTER, '%', v_WORK_ID);

	OPEN p_CURSOR FOR
		SELECT GRP.DISPLAY_NAME || '.' || TRT.DISPLAY_NAME "TRAIT_GROUP_INDEX_NAME",
			GRP.TRAIT_GROUP_ID * 1000 + TRT.TRAIT_INDEX "TRAIT_GROUP_INDEX_ID"
		FROM TRANSACTION_TRAIT_GROUP GRP, TRANSACTION_TRAIT_ATTRIBUTES TRT, RTO_WORK TR
		WHERE TR.WORK_ID = v_WORK_ID
		AND GRP.TRAIT_GROUP_ID = TR.WORK_XID
			AND GRP.IS_SPARSE = 1
			AND TRT.TRAIT_GROUP_ID = GRP.TRAIT_GROUP_ID
			AND TRT.TRAIT_INDEX = TR.WORK_SEQ
		ORDER BY GRP.DISPLAY_ORDER, TRT.DISPLAY_ORDER;

		UT.PURGE_RTO_WORK(v_WORK_ID);

END TRAIT_GROUP_INDEX_LIST_SPARSE;
---------------------------------------------------------------------------
PROCEDURE GET_BID_CURVE_EDITOR
	(
	p_TRANSACTION_ID IN NUMBER,
	p_TRAIT_GROUP_ID IN NUMBER,
	p_CUT_DATE_SCHEDULING IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
	v_WORK_ID NUMBER(9);
	v_MAX_SET_NUMBERS NUMBER(4) := 20;
	i BINARY_INTEGER;
BEGIN
	UT.GET_RTO_WORK_ID(v_WORK_ID);

	FOR i IN 1..v_MAX_SET_NUMBERS LOOP
		UT.POST_RTO_WORK(v_WORK_ID, i, i);
	END LOOP;

	OPEN p_CURSOR FOR
		SELECT X.DISPLAY_NAME, X.SET_NUMBER, A.TRAIT_VAL, X.FORMAT, X.DATA_TYPE, X.EDIT_MASK, X.COMBO_LIST, X.AFTER_EDIT,
			p_TRANSACTION_ID "TRANSACTION_ID", p_TRAIT_GROUP_ID "TRAIT_GROUP_ID", p_CUT_DATE_SCHEDULING "CUT_DATE_SCHEDULING",
			X.TRAIT_INDEX "TRAIT_INDEX"
		FROM IT_TRAIT_SCHEDULE A,
			(SELECT DISPLAY_NAME, FORMAT, DATA_TYPE, EDIT_MASK, COMBO_LIST, AFTER_EDIT, TRAIT_GROUP_ID, TRAIT_INDEX, WORK_SEQ "SET_NUMBER"
			FROM TRANSACTION_TRAIT_ATTRIBUTES B, RTO_WORK C
			WHERE B.TRAIT_GROUP_ID = p_TRAIT_GROUP_ID
				AND C.WORK_ID = v_WORK_ID) X
		WHERE A.TRANSACTION_ID(+) = p_TRANSACTION_ID
			AND A.SCHEDULE_STATE(+) = 1
			AND A.SCHEDULE_DATE(+) = p_CUT_DATE_SCHEDULING
			AND A.TRAIT_GROUP_ID(+) = X.TRAIT_GROUP_ID
			AND A.TRAIT_INDEX(+) = X.TRAIT_INDEX
			AND A.SET_NUMBER(+) = X.SET_NUMBER
		ORDER BY X.TRAIT_INDEX, X.SET_NUMBER;

END GET_BID_CURVE_EDITOR;
--------------------------------------------------------------------------------------------------
PROCEDURE PUT_BID_CURVE_EDITOR
	(
	p_TRANSACTION_ID IN NUMBER,
	p_CUT_DATE_SCHEDULING IN DATE,
	p_TRAIT_GROUP_ID IN NUMBER,
	p_TRAIT_INDEX IN NUMBER,
	p_SET_NUMBER IN NUMBER,
	p_TRAIT_VAL IN VARCHAR2,
	p_STATUS OUT NUMBER
	) AS
BEGIN
	PUT_IT_TRAIT_SCHEDULE(p_TRANSACTION_ID, 1, 0, p_CUT_DATE_SCHEDULING, p_TRAIT_GROUP_ID, p_TRAIT_INDEX, p_SET_NUMBER, p_TRAIT_VAL, CUT_TIME_ZONE);
END PUT_BID_CURVE_EDITOR;
--------------------------------------------------------------------------------------------------
PROCEDURE ROLL_FORWARD_TRAIT_SCHED_TXNS
	(
	p_FROM_DATE IN DATE,
	p_TO_DATE IN DATE,
    p_TRAIT_GROUP_ID IN NUMBER,
	p_TXN_IDS IN ID_TABLE,
	p_DELETE_EXISTING_DATA IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_MESSAGE OUT VARCHAR2
	) AS
	v_BEGIN_DATE_FROM DATE;
	v_END_DATE_FROM DATE;
	v_BEGIN_DATE_TO DATE;
	v_END_DATE_TO DATE;
	v_DATE_OFFSET_DAY NUMBER;
	v_SCHEDULE_STATE NUMBER(1) := GA.INTERNAL_STATE;
	v_ALL_TXNS NUMBER(1) := 0;
	v_ALLOWED_TXNS ID_TABLE := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_BAO_UPDATE);
    v_SRC_DST_TYPE NUMBER(1);
    v_TGT_DST_TYPE NUMBER(1);
    v_TG_INTERVAL TRANSACTION_TRAIT_GROUP.TRAIT_GROUP_INTERVAL%TYPE;
BEGIN

	IF TRUNC(p_FROM_DATE) = TRUNC(p_TO_DATE) THEN RETURN; END IF;

--ROLL FORWARD ONE DAY'S WORTH OF DATA TO ANOTHER DAY FOR A PARTICULAR TRAIT GROUP.
--THIS APPLIES TO ALL TXNS THAT HAVE THIS TRAIT GROUP THAT THE USER HAS DLS UPDATE TRAIT ACCESS TO.
	UT.CUT_DATE_RANGE(1, p_FROM_DATE, p_FROM_DATE, p_TIME_ZONE, v_BEGIN_DATE_FROM, v_END_DATE_FROM);
	UT.CUT_DATE_RANGE(1, p_TO_DATE, p_TO_DATE, p_TIME_ZONE, v_BEGIN_DATE_TO, v_END_DATE_TO);

	IF v_ALLOWED_TXNS(1).ID = SD.g_ALL_DATA_ENTITY_ID THEN v_ALL_TXNS := 1; END IF;

	IF p_DELETE_EXISTING_DATA = 1 THEN
		DELETE IT_TRAIT_SCHEDULE A
		WHERE (v_ALL_TXNS = 1 OR A.TRANSACTION_ID IN (SELECT IDS.ID FROM TABLE(CAST(v_ALLOWED_TXNS AS ID_TABLE)) IDS))
			AND A.SCHEDULE_STATE = v_SCHEDULE_STATE
			AND A.SCHEDULE_DATE BETWEEN v_BEGIN_DATE_TO AND v_END_DATE_TO
            AND A.TRAIT_GROUP_ID = p_TRAIT_GROUP_ID
			AND A.TRANSACTION_ID IN (SELECT TXNS.ID FROM TABLE(CAST(p_TXN_IDS AS ID_TABLE)) TXNS);
	END IF;

    -- Trait Group Interval
    SELECT TG.TRAIT_GROUP_INTERVAL
    INTO v_TG_INTERVAL
    FROM TRANSACTION_TRAIT_GROUP TG
    WHERE TG.TRAIT_GROUP_ID = p_TRAIT_GROUP_ID;

    -- Loop Over Each Transaction
    FOR c_TXNS IN (SELECT DISTINCT TXN.TRANSACTION_ID,
                        -- For Transaction with Offer Interval, use Schedule Coordinator's interval
                        CASE WHEN v_TG_INTERVAL = g_OFFER_INTERVAL THEN SC_SCHEDULE_INTERVAL ELSE v_TG_INTERVAL END AS INTERVAL
                    FROM TABLE(CAST(p_TXN_IDS AS ID_TABLE)) TG_TXN, INTERCHANGE_TRANSACTION TXN, SCHEDULE_COORDINATOR SC
                    WHERE (v_ALL_TXNS = 1 OR TG_TXN.ID IN (SELECT IDS.ID FROM TABLE(CAST(v_ALLOWED_TXNS AS ID_TABLE)) IDS))
                        AND TXN.TRANSACTION_ID = TG_TXN.ID
                        AND SC.SC_ID(+) = TXN.SC_ID)
    LOOP
        -- Sub-Daily
        IF DATE_UTIL.IS_SUB_DAILY(c_TXNS.INTERVAL) THEN
            -- Determine Source and Target DST Type
            SELECT DST_TYPE
            INTO v_SRC_DST_TYPE
            FROM DST_TYPE
            WHERE TRUNC(p_FROM_DATE) BETWEEN BEGIN_DATE AND END_DATE;

            SELECT DST_TYPE
            INTO v_TGT_DST_TYPE
            FROM DST_TYPE
            WHERE TRUNC(p_TO_DATE) BETWEEN BEGIN_DATE AND END_DATE;

            INSERT INTO IT_TRAIT_SCHEDULE(TRANSACTION_ID, SCHEDULE_STATE, SCHEDULE_DATE, TRAIT_GROUP_ID, TRAIT_INDEX, SET_NUMBER, STATEMENT_TYPE_ID, SCHEDULE_END_DATE, TRAIT_VAL, ENTRY_DATE)
            SELECT TRANSACTION_ID,
                SCHEDULE_STATE,
                LDI.CUT_BEGIN_DATE + DIM.TGT_INTERVAL AS SCHEDULE_DATE,
                TRAIT_GROUP_ID,
                TRAIT_INDEX,
                SET_NUMBER,
                STATEMENT_TYPE_ID,
                SCHEDULE_END_DATE,
                TRAIT_VAL,
                SYSDATE
            FROM IT_TRAIT_SCHEDULE A,
                SYSTEM_DAY_INFO LDI,
                DST_INTERVAL_MAP DIM
            WHERE A.TRANSACTION_ID = c_TXNS.TRANSACTION_ID
                AND A.SCHEDULE_STATE = v_SCHEDULE_STATE
                AND A.TRAIT_GROUP_ID = p_TRAIT_GROUP_ID
                AND LDI.LOCAL_DATE = p_TO_DATE
                AND LDI.TIME_ZONE = p_TIME_ZONE
                AND LDI.DST_TYPE = v_TGT_DST_TYPE
                AND DIM.INTERVAL = c_TXNS.INTERVAL
                AND DIM.TGT_DST_TYPE = LDI.DST_TYPE
                AND DIM.SRC_DST_TYPE = v_SRC_DST_TYPE
                AND DIM.SRC_INTERVAL = (A.SCHEDULE_DATE - (v_BEGIN_DATE_FROM-1/86400));
        -- Not Sub-Hourly
        ELSE
            v_DATE_OFFSET_DAY := TRUNC(p_TO_DATE) - TRUNC(p_FROM_DATE);
            INSERT INTO IT_TRAIT_SCHEDULE(TRANSACTION_ID, SCHEDULE_STATE, SCHEDULE_DATE, TRAIT_GROUP_ID, TRAIT_INDEX, SET_NUMBER, STATEMENT_TYPE_ID, SCHEDULE_END_DATE, TRAIT_VAL, ENTRY_DATE)
            SELECT TRANSACTION_ID,
                SCHEDULE_STATE,
                SCHEDULE_DATE + v_DATE_OFFSET_DAY,
                TRAIT_GROUP_ID,
                TRAIT_INDEX,
                SET_NUMBER,
                STATEMENT_TYPE_ID,
                SCHEDULE_END_DATE,
                TRAIT_VAL,
                SYSDATE
            FROM IT_TRAIT_SCHEDULE A
            WHERE A.TRANSACTION_ID = c_TXNS.TRANSACTION_ID
                AND A.SCHEDULE_STATE = v_SCHEDULE_STATE
		        AND A.SCHEDULE_DATE BETWEEN v_BEGIN_DATE_FROM AND v_END_DATE_FROM
                AND A.TRAIT_GROUP_ID = p_TRAIT_GROUP_ID;
        END IF;
    END LOOP;
EXCEPTION
	WHEN DUP_VAL_ON_INDEX THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		p_MESSAGE := 'Some data already existed on the date specified.  Data was not successfully rolled forward.';
END ROLL_FORWARD_TRAIT_SCHED_TXNS;
--------------------------------------------------------------------------------------------------
PROCEDURE ROLL_FORWARD_TRAIT_GROUPS
	(
	p_FROM_DATE IN DATE,
	p_TO_DATE IN DATE,
	p_TRAIT_GROUP_IDS IN ID_TABLE,
	p_DELETE_EXISTING_DATA IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_MESSAGE IN OUT VARCHAR2
	) AS
    v_TXN_IDS ID_TABLE := ID_TABLE();
BEGIN
    FOR c_TGS IN (SELECT ID AS TRAIT_GROUP_ID FROM TABLE(CAST(p_TRAIT_GROUP_IDS AS ID_TABLE)))
    LOOP
        -- Get All the Transaction belonging to the Trait Group
        SELECT ID_TYPE(TRANSACTION_ID)
        BULK COLLECT INTO v_TXN_IDS
        FROM (SELECT DISTINCT S.TRANSACTION_ID
            FROM TABLE(CAST(p_TRAIT_GROUP_IDS AS ID_TABLE)) TGS,
                IT_TRAIT_SCHEDULE S
            WHERE S.TRAIT_GROUP_ID = TGS.ID);

        ROLL_FORWARD_TRAIT_SCHED_TXNS(p_FROM_DATE,
                                     p_TO_DATE,
                                     c_TGS.TRAIT_GROUP_ID,
                                     v_TXN_IDS,
                                     p_DELETE_EXISTING_DATA,
                                     p_TIME_ZONE,
                                     p_MESSAGE);

    END LOOP;


END ROLL_FORWARD_TRAIT_GROUPS;
---------------------------------------------------------------------------
PROCEDURE PUT_STATUS_REASON
	(
	p_TRANSACTION_ID IN NUMBER,
	p_CUT_DATE_SCHEDULING IN DATE,
	p_REASON_FOR_CHANGE IN VARCHAR,
	p_OTHER_REASON IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

-- Update BID_OFFER_STATUS reasons.
BEGIN

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_BAO_UPDATE,p_TRANSACTION_ID,EC.ED_TRANSACTION);

	--ATTEMPT AN UPDATE.
		UPDATE IT_TRAIT_SCHEDULE_STATUS SET
			REASON_FOR_CHANGE = p_REASON_FOR_CHANGE,
			OTHER_REASON = p_OTHER_REASON,
			ENTRY_DATE = SYSDATE
		WHERE TRANSACTION_ID = p_TRANSACTION_ID
			AND SCHEDULE_DATE = p_CUT_DATE_SCHEDULING;

END PUT_STATUS_REASON;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_BID_OFFERS_TEMPLATES
    (
	p_TRANSACTION_ID IN NUMBER,
    p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN
    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT DISTINCT TEMPLATE_NAME,
				C.TEMPLATE_TYPE,
				DAY_OF_WEEK,
				INCLUDE_HOLIDAYS,
				START_HOUR_END,
				STOP_HOUR_END,
				INTERIOR_PERIOD,
				TEMPLATE_ORDER
		FROM BID_OFFER_TEMPLATE A, INTERCHANGE_TRANSACTION B, SCHEDULE_TEMPLATE C
		WHERE B.TRANSACTION_ID = p_TRANSACTION_ID
			AND A.COMMODITY_ID = B.COMMODITY_ID
			AND C.TEMPLATE_NAME = A.BID_OFFER_TEMPLATE_NAME
		ORDER BY TEMPLATE_NAME;
END GET_BID_OFFERS_TEMPLATES;
--------------------------------------------------------------------------------------------------
--Verifies that a trait group id exists.
PROCEDURE VALIDATE_TG_EXISTS
    (
    p_TRAIT_GROUP_ID IN NUMBER
    )
    AS
    v_EXISTS NUMBER := 0;
BEGIN

    SELECT COUNT(TRAIT_GROUP_ID)
    INTO v_EXISTS
    FROM TRANSACTION_TRAIT_GROUP
    WHERE TRAIT_GROUP_ID = p_TRAIT_GROUP_ID;

    IF v_EXISTS = 0 THEN
        ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY,
           'Transaction Trait Group "'|| p_TRAIT_GROUP_ID || '" does not exist.');
    END IF;
END VALIDATE_TG_EXISTS;
--------------------------------------------------------------------------------------------------
--Verifies that a transaction id exists.
PROCEDURE VALIDATE_TXN_EXISTS
    (
    p_TRANSACTION_ID IN NUMBER
    )
    AS
v_EXISTS NUMBER := 0;
BEGIN

    SELECT COUNT(TRANSACTION_ID)
    INTO v_EXISTS
    FROM INTERCHANGE_TRANSACTION
    WHERE TRANSACTION_ID = p_TRANSACTION_ID;

    IF v_EXISTS = 0 THEN
        ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY,
           'Transaction "'|| p_TRANSACTION_ID || '" does not exist.');
    END IF;
END VALIDATE_TXN_EXISTS;
--------------------------------------------------------------------------------------------------
FUNCTION STRING_TO_NUMBER
    (
    p_STRING  IN VARCHAR2
    )
    RETURN NUMBER
    AS
v_NUMBER NUMBER;
BEGIN
    v_NUMBER := TO_NUMBER(p_STRING);
    RETURN v_NUMBER;
EXCEPTION
    WHEN OTHERS THEN
        ERRS.RAISE(MSGCODES.c_ERR_INVALID_NUMBER,
           'The string "'|| p_STRING || '" cannot be converted into a number.');
END STRING_TO_NUMBER;
--------------------------------------------------------------------------------------------------
--Retrieves a trait's index using its display name and trait group id.
PROCEDURE GET_TRAIT_BY_NAME
    (
    p_TRAIT_GROUP_ID IN NUMBER,
    p_TRAIT_NAME IN VARCHAR2,
    p_TRAIT_INDEX OUT NUMBER
    )AS
v_TRAIT_PARENT_OBJECT_ID NUMBER;
c_TRAIT_OBJECT_INDEX     CONSTANT NUMBER := 0;
c_TRAIT_OBJECT_CATEGORY  CONSTANT VARCHAR2(32) := 'Column';
c_TRAIT_OBJECT_TYPE      CONSTANT VARCHAR2(64) := 'Default';
BEGIN
    SELECT SO.OBJECT_ID
    INTO v_TRAIT_PARENT_OBJECT_ID
    FROM SYSTEM_OBJECT SO
    WHERE UPPER(SO.OBJECT_NAME) = 'TRANSACTION TRAITS';

    SELECT T.TRAIT_INDEX
    INTO p_TRAIT_INDEX
    FROM TRANSACTION_TRAIT T, SYSTEM_OBJECT SO
    WHERE T.TRAIT_GROUP_ID = p_TRAIT_GROUP_ID AND
          SO.OBJECT_DISPLAY_NAME = p_TRAIT_NAME AND
          T.SYSTEM_OBJECT_ID = SO.OBJECT_ID AND
          SO.PARENT_OBJECT_ID = v_TRAIT_PARENT_OBJECT_ID AND
          SO.OBJECT_INDEX = c_TRAIT_OBJECT_INDEX AND
          SO.OBJECT_CATEGORY = c_TRAIT_OBJECT_CATEGORY AND
          SO.OBJECT_TYPE = c_TRAIT_OBJECT_TYPE;
EXCEPTION
    WHEN OTHERS THEN
        ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY,
                   'Trait "'|| p_TRAIT_NAME || '" does not exist.');
END GET_TRAIT_BY_NAME;
--------------------------------------------------------------------------------------------------
--Retrieves a rate at a specific date stored as a sparse trait using ids
--and the trait name.
FUNCTION GET_RATE_VAL
    (
    p_TRAIT_GROUP_ID IN NUMBER,
    p_TRANSACTION_ID IN NUMBER,
    p_TRAIT_NAME IN VARCHAR2,
    p_DATE IN DATE
    ) RETURN NUMBER AS
   v_RATE                    NUMBER;
   v_TRAIT_INDEX             NUMBER;
   v_RATE_STRING             VARCHAR2(128);
   c_RATE_SCHEDULE_STATE     CONSTANT NUMBER := 1;
   c_RATE_SET_NUMBER         CONSTANT NUMBER := 1;
   c_RATE_STATEMENT_TYPE_ID  CONSTANT NUMBER := 0;
BEGIN
    --Make sure that the trait group and transaction exist
    VALIDATE_TG_EXISTS(p_TRAIT_GROUP_ID);
    VALIDATE_TXN_EXISTS(p_TRANSACTION_ID);

    --Get the rate's trait index, if the trait exists
    GET_TRAIT_BY_NAME(p_TRAIT_GROUP_ID, p_TRAIT_NAME, v_TRAIT_INDEX);

    --Get the rate's string value
    SELECT TRAIT_VAL
    INTO v_RATE_STRING
    FROM IT_TRAIT_SCHEDULE
    WHERE TRAIT_GROUP_ID = p_TRAIT_GROUP_ID AND
          TRANSACTION_ID = p_TRANSACTION_ID AND
          TRAIT_INDEX = v_TRAIT_INDEX AND
          p_DATE BETWEEN SCHEDULE_DATE AND NVL(SCHEDULE_END_DATE, CONSTANTS.HIGH_DATE) AND
          SCHEDULE_STATE = c_RATE_SCHEDULE_STATE AND
          SET_NUMBER = c_RATE_SET_NUMBER AND
          STATEMENT_TYPE_ID = c_RATE_STATEMENT_TYPE_ID;
        
    --Convert the rate string into a number. If unable to convert, throw an error.
    v_RATE := STRING_TO_NUMBER(v_RATE_STRING);
    
    --Make sure that the rate is not null. If it is set it to 0
    IF v_RATE IS NULL THEN
        v_RATE := '0';
        LOGS.LOG_WARN('No trait value set for transaction ' ||
           EI.GET_ENTITY_NAME(EC.ED_TRANSACTION, p_TRANSACTION_ID) ||
           ' and trait ' || p_TRAIT_NAME || ' on ' || to_char(p_DATE, 'yyyy-mm-dd hh24:mi'));
     END IF;   
     
     RETURN v_RATE;
--Only catch the case when the trait does not exist for that date.
--All other exceptions should be allowed to pass through.
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        v_RATE := 0;
        --Log warning
        LOGS.LOG_WARN('No trait value set for transaction ' ||
           EI.GET_ENTITY_NAME(EC.ED_TRANSACTION, p_TRANSACTION_ID) ||
         ' and trait ' || p_TRAIT_NAME || ' on ' || to_char(p_DATE, 'yyyy-mm-dd hh24:mi'));
        RETURN v_RATE;

END GET_RATE_VAL;
--------------------------------------------------------------------------------------------------
--Retrieves a rate at a specific date stored as a sparse trait using names.
FUNCTION GET_RATE_VAL_BY_NAME
    (
    p_TRAIT_GROUP_NAME IN VARCHAR2,
    p_TRANSACTION_NAME IN VARCHAR2,
    p_TRAIT_NAME IN VARCHAR2,
    p_DATE IN DATE
    ) RETURN NUMBER AS
    v_RATE NUMBER;
    v_TRAIT_GROUP_ID NUMBER;
    v_TRANSACTION_ID NUMBER;
BEGIN
    --Retrieve the correct trait group id
    SELECT TRAIT_GROUP_ID
    INTO v_TRAIT_GROUP_ID
    FROM TRANSACTION_TRAIT_GROUP
    WHERE UPPER(TRAIT_GROUP_NAME) = UPPER(p_TRAIT_GROUP_NAME);

    --Retrieve the correct transaction id
    SELECT TRANSACTION_ID
    INTO v_TRANSACTION_ID
    FROM INTERCHANGE_TRANSACTION
    WHERE UPPER(TRANSACTION_NAME) = UPPER(p_TRANSACTION_NAME);

    --Get the rate using ids
    v_RATE := GET_RATE_VAL(v_TRAIT_GROUP_ID, v_TRANSACTION_ID, p_TRAIT_NAME, p_DATE);

    RETURN v_RATE;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        IF v_TRAIT_GROUP_ID IS NULL THEN
            ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY,
                      'Transaction Trait Group "'|| p_TRAIT_GROUP_NAME || '" does not exist.');
        ELSIF v_TRANSACTION_ID IS NULL THEN
            ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY,
                      'Transaction "'|| p_TRANSACTION_NAME || '" does not exist.');
        END IF;
END GET_RATE_VAL_BY_NAME;
--------------------------------------------------------------------------------------------------
END TG;
/
