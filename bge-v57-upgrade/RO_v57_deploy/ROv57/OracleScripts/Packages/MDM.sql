CREATE OR REPLACE PACKAGE MDM IS

    c_AGG_ACCT_DESC CONSTANT VARCHAR2(64) := 'Generated by MDR Aggregation Process';

    PROCEDURE RUN_XCAST
    (
        p_BEGIN_DATE IN DATE,
        p_END_DATE IN DATE,
        p_TIME_ZONE IN VARCHAR2,
        p_RUN_TYPE_ID IN INT,
        p_FILTER_MODEL_ID IN NUMBER,
        p_ACCEPT_INTO_SCHEDULES IN NUMBER,
        p_SCHEDULE_STATEMENT_TYPE_ID IN NUMBER,
        p_APPLY_USAGE_FACTOR IN NUMBER := 1,
        p_APPLY_UFE IN NUMBER := 1,
        p_TRACE_ON IN NUMBER := 0
    );

    PROCEDURE COMPUTE_MSE
    (
        p_BEGIN_DATE IN DATE,
        p_END_DATE IN DATE,
        p_TIME_ZONE IN VARCHAR2,
        p_SERVICE_CODE IN CHAR
    );

    PROCEDURE PUT_AGGREGATE_ACCOUNT
    (
        p_EXTERNAL_IDENTIFIER IN VARCHAR2,
        p_ACCOUNT_ID OUT NUMBER
    );

    PROCEDURE IMPORT_AGGREGATE_ACCOUNTS
    (
        p_AGGREGATE_ACCOUNTS IN CLOB,
        p_PROCESS_STATUS OUT NUMBER
    );

    PROCEDURE SYNC_WEATHER_DATA;

    PROCEDURE GET_WEATHER_DATA_XML
    (
        p_XML OUT XMLTYPE
    );

    PROCEDURE SYNC_SEASON_DAY_TYPE
    (
        p_PROCESS_STATUS OUT VARCHAR2
    );

    PROCEDURE GET_SEASON_DAY_TYPE_XML
    (
        p_XML OUT XMLTYPE
    );

    PROCEDURE CREATE_WRF_PROFILES
    (
        p_BEGIN_DATE IN DATE,
        p_END_DATE IN DATE,
        p_TIME_ZONE IN VARCHAR2,
        p_TEMPLATE_ID_COLL IN NUMBER_COLLECTION,
        p_ACCOUNT_ID_COLL IN NUMBER_COLLECTION
    );

    FUNCTION GET_MDR_BACKEND_SETTING RETURN VARCHAR2;

    $if $$UNIT_TEST_MODE = 1 $then

        PROCEDURE GET_CANDIDATE_DAY_XML
        (
            p_TIME_ZONE IN VARCHAR2,
            p_TIME_ZONE_OFFSET IN VARCHAR2,
            p_IS_DST_OBS NUMBER,
            p_RUN_TYPE IN VARCHAR2,
            p_SERVICE_CODE IN CHAR,
            p_XML OUT XMLTYPE
        );

        PROCEDURE STORE_AGG_RESULTS
        (
            p_XML_CLOB IN CLOB,
            p_SERVICE_CODE IN VARCHAR2,
            p_SCENARIO_ID IN NUMBER,
            p_TIME_ZONE IN VARCHAR2
        );

        PROCEDURE WAIT_FOR_MDR_PROCESS
        (
            p_PROCESS_ID IN VARCHAR2,
            p_PROCESS_STATUS OUT VARCHAR2
        );

        PROCEDURE GET_AGG_RESULTS
        (
            p_PROCESS_ID IN VARCHAR2,
            p_TIME_ZONE IN VARCHAR2,
            p_AGG_RESULTS OUT CLOB
        );

        PROCEDURE GET_WRF_XML
        (
            p_BEGIN_DATE IN DATE,
            p_END_DATE IN DATE,
            p_TIME_ZONE IN VARCHAR2,
            p_TEMPLATE_ID_COLL IN NUMBER_COLLECTION,
            p_ACCOUNT_ID_COLL IN NUMBER_COLLECTION,
            p_XML OUT XMLTYPE
        );

    $end

END MDM;
/
CREATE OR REPLACE PACKAGE BODY MDM IS
-- MDM = Meter Data Management
------------------------------------------------------------------------------------------
PROCEDURE COMPUTE_MSE
(
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_TIME_ZONE IN VARCHAR2,
    p_SERVICE_CODE IN CHAR
) AS
    v_CASE_ID CONSTANT NUMBER := GA.BASE_CASE_ID;
    v_SERVICE_DATE DATE;
    v_SVC_CUT_BEGIN_DATE DATE;
    v_SVC_CUT_END_DATE DATE;
    v_CD_CUT_BEGIN_DATE DATE;
    v_CD_CUT_END_DATE DATE;
    v_IS_SHORT_FD boolean;
    v_IS_LONG_FD boolean;
    v_IS_SHORT_PD boolean;
    v_IS_LONG_PD boolean;

BEGIN
    LOGS.LOG_DEBUG('Computing MSE and Candidate Days');
    DELETE FROM PDM_CANDIDATE_DAYS;
    -- Loop over the forecast time period
    v_SERVICE_DATE := p_BEGIN_DATE;
    WHILE v_SERVICE_DATE <= p_END_DATE LOOP
        UT.CUT_DATE_RANGE(v_SERVICE_DATE, v_SERVICE_DATE, p_TIME_ZONE, v_SVC_CUT_BEGIN_DATE, v_SVC_CUT_END_DATE);
        v_IS_LONG_FD := (TRUNC(DST_FALL_BACK_DATE(v_SERVICE_DATE))=v_SERVICE_DATE);
        v_IS_SHORT_FD := (TRUNC(DST_SPRING_AHEAD_DATE(v_SERVICE_DATE))=v_SERVICE_DATE);
        -- evaluate each candidate
        FOR v_CANDIDATE_DAY IN
           (
                SELECT PDM.*, COLUMN_VALUE AS CANDIDATE_DAY
                FROM (SELECT P.PROXY_DAY_METHOD_ID,
                        P.HOLIDAY_SET_ID,
                        P.TEMPLATE_ID,
                        P.STATION_ID,
                        P.PARAMETER_ID,
                        P.LOOKUP_TIME_HORIZON,
                        P.TIME_HORIZON_SHIFT
                    FROM PROXY_DAY_METHOD P
                    WHERE P.COMPARATIVE_VALUE = 'W') PDM,
                    TABLE(DATE_UTIL.DATES_IN_INTERVAL_RANGE(TRUNC(v_SERVICE_DATE) - PDM.LOOKUP_TIME_HORIZON,
                          TRUNC(v_SERVICE_DATE) - PDM.TIME_HORIZON_SHIFT, DATE_UTIL.C_ABBR_DAY))
                ORDER BY PROXY_DAY_METHOD_ID, CANDIDATE_DAY
           )
        LOOP
           UT.CUT_DATE_RANGE(v_CANDIDATE_DAY.CANDIDATE_DAY, v_CANDIDATE_DAY.CANDIDATE_DAY, p_TIME_ZONE, v_CD_CUT_BEGIN_DATE, v_CD_CUT_END_DATE);
           v_IS_LONG_PD := (TRUNC(DST_FALL_BACK_DATE(v_CANDIDATE_DAY.CANDIDATE_DAY))=v_CANDIDATE_DAY.CANDIDATE_DAY);
           v_IS_SHORT_PD := (TRUNC(DST_SPRING_AHEAD_DATE(v_CANDIDATE_DAY.CANDIDATE_DAY))=v_CANDIDATE_DAY.CANDIDATE_DAY);

           IF((NOT v_IS_SHORT_PD and NOT v_IS_LONG_PD) or (v_IS_LONG_PD and v_IS_LONG_FD) or (v_IS_SHORT_PD and v_IS_SHORT_FD)) THEN
             LOGS.LOG_INFO('Calculating deltas for proxy day forecast for forecast day:' || TEXT_UTIL.TO_CHAR_DATE(v_SERVICE_DATE) ||
                              ' candidate day:' || TEXT_UTIL.TO_CHAR_DATE(v_CANDIDATE_DAY.CANDIDATE_DAY) ||
                              ' Proxy Day Method:' || EI.GET_ENTITY_NAME(EC.ED_PROXY_DAY_METHOD, v_CANDIDATE_DAY.PROXY_DAY_METHOD_ID) ||
                              ' Weather Station:' || EI.GET_ENTITY_NAME(EC.ED_WEATHER_STATION, v_CANDIDATE_DAY.STATION_ID) ||
                              ' Weather Parameter:' || EI.GET_ENTITY_NAME(EC.ED_WEATHER_PARAMETER, v_CANDIDATE_DAY.PARAMETER_ID) ||
                              ' Cut Service Begin date:' || TEXT_UTIL.TO_CHAR_TIME(v_SVC_CUT_BEGIN_DATE) ||
                              ' Cut Service End date:' || TEXT_UTIL.TO_CHAR_TIME(v_SVC_CUT_END_DATE) ||
                              ' Cut Calendar Begin date:' || TEXT_UTIL.TO_CHAR_TIME(v_CD_CUT_BEGIN_DATE) ||
                              ' Cut Calendar Endn date:' || TEXT_UTIL.TO_CHAR_TIME(v_CD_CUT_END_DATE)
                              );
              INSERT INTO PDM_CANDIDATE_DAYS
              SELECT PD.PROXY_DAY_METHOD_ID,
                     v_SERVICE_DATE,
                     PD.CANDIDATE_DAY,
                     SQRT(AVG(POWER(AD.PARAMETER_VAL - PD.PARAMETER_VAL, 2))) AS MSE
              -- comparing base-case actual data from candidate day...
              FROM (SELECT PROXY_DAY_METHOD_ID,
                      HOLIDAY_SET_ID,
                      CANDIDATE_DAY,
                      PI.PARAMETER_VAL,
                      PI.PARAMETER_DATE,
                      ROWNUM as SEQ
                  FROM (SELECT S.PARAMETER_VAL,
                          S.PARAMETER_DATE,
                          v_CANDIDATE_DAY.PROXY_DAY_METHOD_ID,
                          v_CANDIDATE_DAY.HOLIDAY_SET_ID,
                          v_CANDIDATE_DAY.CANDIDATE_DAY
                      FROM STATION_PARAMETER_VALUE S
                      WHERE S.CASE_ID = v_CASE_ID
                          AND S.STATION_ID = v_CANDIDATE_DAY.STATION_ID
                          AND S.PARAMETER_ID = v_CANDIDATE_DAY.PARAMETER_ID
                          AND S.PARAMETER_CODE = 'A'
                          AND S.PARAMETER_DATE BETWEEN v_CD_CUT_BEGIN_DATE AND v_CD_CUT_END_DATE
                          AND S.PARAMETER_VAL IS NOT NULL
                  ORDER BY S.PARAMETER_DATE DESC) PI) PD,
              -- ... to data for forecast date
              (SELECT PROXY_DAY_METHOD_ID,
                      CANDIDATE_DAY,
                      AI.PARAMETER_VAL,
                      AI.PARAMETER_DATE,
                      ROWNUM as SEQ
                  FROM (SELECT S.PARAMETER_VAL,
                          S.PARAMETER_DATE,
                          v_CANDIDATE_DAY.PROXY_DAY_METHOD_ID,
                          v_CANDIDATE_DAY.CANDIDATE_DAY
                      FROM STATION_PARAMETER_VALUE S
                      WHERE S.CASE_ID = v_CASE_ID
                          AND S.STATION_ID = v_CANDIDATE_DAY.STATION_ID
                          AND S.PARAMETER_ID = v_CANDIDATE_DAY.PARAMETER_ID
                          AND S.PARAMETER_CODE = CASE
                                                 WHEN p_SERVICE_CODE = 'B' THEN
                                                     CASE
                                                     WHEN EXISTS (
                                                         SELECT 1
                                                         FROM STATION_PARAMETER_VALUE
                                                         WHERE CASE_ID = v_CASE_ID
                                                           AND STATION_ID = v_CANDIDATE_DAY.STATION_ID
                                                           AND PARAMETER_ID = v_CANDIDATE_DAY.PARAMETER_ID
                                                           AND PARAMETER_DATE BETWEEN v_SVC_CUT_BEGIN_DATE AND v_SVC_CUT_END_DATE
                                                           AND PARAMETER_CODE = 'A'
                                                           AND PARAMETER_VAL IS NOT NULL
                                                     ) THEN 'A' ELSE 'F' END
                                                   ELSE 'F'
                                                   END
                          AND S.PARAMETER_DATE BETWEEN v_SVC_CUT_BEGIN_DATE AND v_SVC_CUT_END_DATE
                          AND S.PARAMETER_VAL IS NOT NULL
                  ORDER BY S.PARAMETER_DATE DESC) AI) AD
              WHERE PD.SEQ = AD.SEQ
              GROUP BY v_SERVICE_DATE, PD.PROXY_DAY_METHOD_ID, HOLIDAY_SET_ID, PD.CANDIDATE_DAY;

               -- Ignore the candidate days that do not match target forecast day's day type.
              DELETE FROM PDM_CANDIDATE_DAYS F
              WHERE EXISTS
              (
                  WITH DAY_TYPE AS
                  (
                      -- Returns the local day and the associated day name/period id
                      SELECT TD.LOCAL_DATE, TDT.DAY_NAME,
                             DT.PERIOD_ID,
                             v_CANDIDATE_DAY.PROXY_DAY_METHOD_ID AS PDM_ID,
                             v_CANDIDATE_DAY.HOLIDAY_SET_ID AS HOLIDAY_SET_ID
                      FROM TEMPLATE_DATES TD,
                           TEMPLATE_DAY_TYPE TDT,
                           TEMPLATE_DAY_TYPE_PERIOD DT
                        WHERE TD.TIME_ZONE = p_TIME_ZONE
                          AND TD.HOLIDAY_SET_ID =  v_CANDIDATE_DAY.HOLIDAY_SET_ID
                          AND TD.TEMPLATE_ID =  v_CANDIDATE_DAY.TEMPLATE_ID
                          AND (TD.LOCAL_DATE BETWEEN (v_SERVICE_DATE - v_CANDIDATE_DAY.LOOKUP_TIME_HORIZON)
                                  AND (v_SERVICE_DATE -  v_CANDIDATE_DAY.TIME_HORIZON_SHIFT) OR TD.LOCAL_DATE = v_SERVICE_DATE)
                          AND TDT.DAY_TYPE_ID = TD.DAY_TYPE_ID
                          AND DT.DAY_TYPE_ID = TDT.DAY_TYPE_ID
                          AND DT.TIME_STAMP = CONSTANTS.DAY_TYPE_FIRST_INTERVAL
                  )
                  SELECT CD.FORECAST_DAY, FR.PDM_ID, FR.HOLIDAY_SET_ID, CD.CANDIDATE_DAY
                  FROM DAY_TYPE FR,
                       PDM_CANDIDATE_DAYS CD,
                       PROXY_DAY_METHOD PDM,
                       DAY_TYPE D2
                  WHERE FR.LOCAL_DATE = CD.FORECAST_DAY
                    AND FR.PDM_ID = CD.PROXY_DAY_METHOD_ID
                    AND PDM.HOLIDAY_SET_ID = FR.HOLIDAY_SET_ID
                    AND D2.LOCAL_DATE = CD.CANDIDATE_DAY
                    AND D2.PDM_ID = CD.PROXY_DAY_METHOD_ID
                    AND PDM.HOLIDAY_SET_ID = D2.HOLIDAY_SET_ID
                    AND D2.PERIOD_ID <> FR.PERIOD_ID
                    AND F.FORECAST_DAY = CD.FORECAST_DAY
                    AND F.PROXY_DAY_METHOD_ID = CD.PROXY_DAY_METHOD_ID
                    AND F.CANDIDATE_DAY = CD.CANDIDATE_DAY);
            END IF;
        END LOOP;
        v_SERVICE_DATE := v_SERVICE_DATE + 1;
  END LOOP;

    -- Filter the candidate days based on the candidate day limits
    DELETE FROM PDM_CANDIDATE_DAYS F
    WHERE EXISTS
    (SELECT C.FORECAST_DAY,
            C.PROXY_DAY_METHOD_ID,
            C.CANDIDATE_DAY
          FROM (-- Rank the days
                SELECT FORECAST_DAY,
                    PROXY_DAY_METHOD_ID,
                    CANDIDATE_DAY,
                    RANK() OVER (PARTITION BY FORECAST_DAY, PROXY_DAY_METHOD_ID
                                 ORDER BY FORECAST_DAY, PROXY_DAY_METHOD_ID, CANDIDATE_DELTA ASC) RANK
              FROM PDM_CANDIDATE_DAYS) C, PROXY_DAY_METHOD P
          WHERE P.PROXY_DAY_METHOD_ID = C.PROXY_DAY_METHOD_ID
                AND C.RANK > P.LOOKUP_CANDIDATE_LIMIT
                AND C.FORECAST_DAY = F.FORECAST_DAY
                AND C.PROXY_DAY_METHOD_ID = F.PROXY_DAY_METHOD_ID
                AND C.CANDIDATE_DAY = F.CANDIDATE_DAY);
END COMPUTE_MSE;
------------------------------------------------------------------------------------------
PROCEDURE GET_CANDIDATE_DAY_XML
    (
        p_TIME_ZONE IN VARCHAR2,
        p_TIME_ZONE_OFFSET IN VARCHAR2,
        p_IS_DST_OBS NUMBER,
        p_RUN_TYPE IN VARCHAR2,
        p_SERVICE_CODE IN CHAR,
        p_XML OUT XMLTYPE
    ) AS

v_XML XMLTYPE;

CURSOR c_XML IS
    SELECT (XMLELEMENT("PDMCandidateDays",
        XMLELEMENT("serviceCode", CASE WHEN p_SERVICE_CODE = 'B' THEN 'Backcast' WHEN p_SERVICE_CODE = 'A' THEN 'Actual' ELSE 'Forecast' END),
        XMLELEMENT("runType", p_RUN_TYPE),
        XMLELEMENT("timezone", p_TIME_ZONE),
        XMLELEMENT("proxyDayMethods",
            (SELECT XMLAgg(XMLELEMENT("proxyDayMethod",
                XMLELEMENT("name",a.PROXY_DAY_METHOD_NAME),
                XMLELEMENT("forecastDays",
                    (SELECT XMLAGG(XMLELEMENT("forecastDay",
                        XMLELEMENT("timeStamp",TO_CHAR(b.forecast_day + CASE WHEN (p_IS_DST_OBS = 1 and IS_IN_DST_TIME_PERIOD_CHAR(b.forecast_day)= 'FALSE') THEN 1/24 ELSE 0 END,'YYYY-MM-DD"T"HH24:MI:SS') || p_TIME_ZONE_OFFSET),
                        XMLELEMENT("candidateDays",
                            (SELECT XMLAGG(XMLELEMENT("candidateDay",
                                XMLELEMENT("timeStamp", TO_CHAR(c.candidate_day + CASE WHEN (p_IS_DST_OBS = 1 and IS_IN_DST_TIME_PERIOD_CHAR(c.candidate_day)= 'FALSE')  THEN 1/24 ELSE 0 END,'YYYY-MM-DD"T"HH24:MI:SS') || p_TIME_ZONE_OFFSET),
                                XMLELEMENT("rmse", c.candidate_delta)
                                ))
                            FROM (SELECT * from PDM_CANDIDATE_DAYS ORDER BY candidate_delta) c
                            WHERE c.proxy_day_method_id = b.proxy_day_method_id
                                AND c.forecast_day = b.forecast_day
                        ))))
                    FROM (select distinct proxy_day_method_id, forecast_day from PDM_CANDIDATE_DAYS ORDER BY forecast_day) b
                    WHERE a.proxy_day_method_id = b.proxy_day_method_id
                    ))))
            FROM (select distinct PDM.proxy_day_method_id, PDM.proxy_day_method_name
                FROM PDM_CANDIDATE_DAYS CD, PROXY_DAY_METHOD PDM
                WHERE CD.proxy_day_method_id = PDM.Proxy_Day_Method_Id
                ORDER BY PDM.PROXY_DAY_METHOD_ID) a
            )))) AS CANDIDATE_DAYS
    FROM DUAL;

  BEGIN
    p_XML := NULL;

    FOR v_XML IN c_XML LOOP
      SELECT XMLCONCAT(p_XML, v_XML.CANDIDATE_DAYS)
        INTO p_XML
        FROM DUAL;
    END LOOP;

END GET_CANDIDATE_DAY_XML;
------------------------------------------------------------------------------------------
PROCEDURE SUBMIT_XCAST_TO_MDR
(
    p_TIME_ZONE IN VARCHAR2,
    p_RUN_TYPE IN VARCHAR2,
    p_SERVICE_CODE IN CHAR,
    p_PROCESS_ID OUT VARCHAR2
) AS

    v_OFFSET VARCHAR2(6);
    v_IS_DST_OBS NUMBER;
    v_XML XMLTYPE;

    v_CRED     MEX_CREDENTIALS;
    v_LOGGER   MM_LOGGER_ADAPTER;
    v_REQUEST_CLOB CLOB := NULL;
    v_RESULT       MEX_RESULT;

    v_MESSAGE  VARCHAR2(4000);
    v_STATUS  NUMBER;

BEGIN
    -- get time zone offset using p_TIME_ZONE and SYSTEM_TIME_ZONE table
    SELECT STANDARD_TIME_ZONE_OFFSET, IS_DST_OBSERVANT INTO v_OFFSET, v_IS_DST_OBS
    FROM SYSTEM_TIME_ZONE
    WHERE p_TIME_ZONE = TIME_ZONE;

    -- construct xml
    GET_CANDIDATE_DAY_XML(p_TIME_ZONE,v_OFFSET, v_IS_DST_OBS, p_RUN_TYPE, p_SERVICE_CODE, v_XML);
    DBMS_LOB.CREATETEMPORARY(v_REQUEST_CLOB, TRUE);
    DBMS_LOB.OPEN(v_REQUEST_CLOB, DBMS_LOB.LOB_READWRITE);

    -- add this XML to the request CLOB
    DBMS_LOB.APPEND(v_REQUEST_CLOB, v_XML.GETCLOBVAL());
    DBMS_LOB.CLOSE(v_REQUEST_CLOB);

    -- invoke web service through MEX
    MEX_SWITCHBOARD.INIT_MEX(0, NULL, 'MDR', 'Submit XCast Request to MDR', null, 0, v_CRED, v_LOGGER);
    SECURITY_CONTROLS.SET_IS_INTERFACE(TRUE);
    v_LOGGER.LOG_START;
    v_RESULT := Mex_Switchboard.Invoke(p_Market => 'mdr',
                                       p_Action => 'submit',
                                       p_Logger => v_LOGGER,
                                       p_Cred => v_CRED,
                                       p_Request_ContentType => 'application/xml',
                                       p_Request => v_REQUEST_CLOB);

    IF v_RESULT.STATUS_CODE = MEX_SWITCHBOARD.c_STATUS_SUCCESS THEN
        p_PROCESS_ID := v_RESULT.RESPONSE;
    END IF;

    SECURITY_CONTROLS.SET_IS_INTERFACE(FALSE);
    v_LOGGER.LOG_STOP(v_STATUS, v_MESSAGE);
    v_MESSAGE := v_LOGGER.GET_END_MESSAGE;
EXCEPTION
    WHEN OTHERS THEN
        v_STATUS  := SQLCODE;
        v_MESSAGE := UT.GET_FULL_ERRM;
        SECURITY_CONTROLS.SET_IS_INTERFACE(FALSE);
        v_LOGGER.LOG_STOP(v_STATUS, v_MESSAGE);
        v_MESSAGE := v_LOGGER.GET_END_MESSAGE;

END SUBMIT_XCAST_TO_MDR;
------------------------------------------------------------------------------------------
PROCEDURE WAIT_FOR_MDR_PROCESS
(
    p_PROCESS_ID IN VARCHAR2,
    p_PROCESS_STATUS OUT VARCHAR2
) AS
    v_CRED     MEX_CREDENTIALS;
    v_LOGGER   MM_LOGGER_ADAPTER;
    v_RESULT   MEX_RESULT;
    v_MESSAGE  VARCHAR2(4000);
    v_STATUS   NUMBER;
    v_PARAMS   MEX_UTIL.PARAMETER_MAP;
    v_MAX_ATTEMPTS CONSTANT NUMBER := 360;
    v_SECONDS_BETWEEN_ATTEMPTS CONSTANT NUMBER := 5;
    v_CURR_ATTEMPT NUMBER := 1;
BEGIN

    MEX_SWITCHBOARD.INIT_MEX(0, NULL, 'MDR', 'Wait for MDR Process', null, 0, v_CRED, v_LOGGER);
    SECURITY_CONTROLS.SET_IS_INTERFACE(TRUE);
    v_LOGGER.LOG_START;
    v_PARAMS := MEX_SWITCHBOARD.C_EMPTY_PARAMETER_MAP;
    v_PARAMS('processId') := p_PROCESS_ID;

    WHILE v_CURR_ATTEMPT <= v_MAX_ATTEMPTS LOOP
        v_RESULT := MEX_SWITCHBOARD.INVOKE(p_MARKET => 'mdr',
                                           p_ACTION => 'queryProcess',
                                           p_LOGGER => v_LOGGER,
                                           p_CRED => v_CRED,
                                           p_PARMS => v_PARAMS);

        IF v_RESULT.STATUS_CODE = MEX_SWITCHBOARD.c_STATUS_SUCCESS THEN
            p_PROCESS_STATUS := v_RESULT.RESPONSE;
            IF p_PROCESS_STATUS = '2' THEN
                EXIT;
            ELSIF p_PROCESS_STATUS = '0' OR p_PROCESS_STATUS = '1' THEN
                MUTEX.SLEEP(v_SECONDS_BETWEEN_ATTEMPTS);
                v_CURR_ATTEMPT := v_CURR_ATTEMPT + 1;
            ELSE
                LOGS.LOG_ERROR('MDR process ended in error.  Please check MDR logs.');
                EXIT;
            END IF;
        ELSE
            p_PROCESS_STATUS := NULL;
            LOGS.LOG_ERROR('Error communicating with MEX to determine process status.');
            EXIT;
        END IF;

    END LOOP;

    SECURITY_CONTROLS.SET_IS_INTERFACE(FALSE);
    v_LOGGER.LOG_STOP(v_STATUS, v_MESSAGE);
    v_MESSAGE := v_LOGGER.GET_END_MESSAGE;

EXCEPTION
    WHEN OTHERS THEN
        v_STATUS  := SQLCODE;
        v_MESSAGE := UT.GET_FULL_ERRM;
        SECURITY_CONTROLS.SET_IS_INTERFACE(FALSE);
        v_LOGGER.LOG_STOP(v_STATUS, v_MESSAGE);
        v_MESSAGE := v_LOGGER.GET_END_MESSAGE;

END WAIT_FOR_MDR_PROCESS;
------------------------------------------------------------------------------------------
PROCEDURE GET_AGG_RESULTS
(
    p_PROCESS_ID IN VARCHAR2,
    p_TIME_ZONE IN VARCHAR2,
    p_AGG_RESULTS OUT CLOB
) AS
    v_CRED     MEX_CREDENTIALS;
    v_LOGGER   MM_LOGGER_ADAPTER;
    v_RESULT   MEX_RESULT;
    v_MESSAGE  VARCHAR2(4000);
    v_STATUS   NUMBER;
  v_PARAMS   MEX_UTIL.PARAMETER_MAP;
BEGIN

    MEX_SWITCHBOARD.INIT_MEX(0, NULL, 'MDR', 'Get Aggregated Results', null, 0, v_CRED, v_LOGGER);
    SECURITY_CONTROLS.SET_IS_INTERFACE(TRUE);
    v_LOGGER.LOG_START;
  v_PARAMS := MEX_SWITCHBOARD.C_EMPTY_PARAMETER_MAP;
  v_PARAMS('processId') := p_PROCESS_ID;
    v_PARAMS('timezoneZZZ') := p_TIME_ZONE;
    v_RESULT := MEX_SWITCHBOARD.INVOKE(p_MARKET => 'mdr',
                                       p_ACTION => 'getAggResults',
                                       p_LOGGER => v_LOGGER,
                                       p_CRED => v_CRED,
                                       p_PARMS => v_PARAMS);

    IF v_RESULT.STATUS_CODE = MEX_SWITCHBOARD.c_STATUS_SUCCESS THEN
        p_AGG_RESULTS := v_RESULT.RESPONSE;
    END IF;

    SECURITY_CONTROLS.SET_IS_INTERFACE(FALSE);
    v_LOGGER.LOG_STOP(v_STATUS, v_MESSAGE);
    v_MESSAGE := v_LOGGER.GET_END_MESSAGE;

EXCEPTION
    WHEN OTHERS THEN
        v_STATUS  := SQLCODE;
        v_MESSAGE := UT.GET_FULL_ERRM;
        SECURITY_CONTROLS.SET_IS_INTERFACE(FALSE);
        v_LOGGER.LOG_STOP(v_STATUS, v_MESSAGE);
        v_MESSAGE := v_LOGGER.GET_END_MESSAGE;

END GET_AGG_RESULTS;
------------------------------------------------------------------------------------------
PROCEDURE STORE_AGG_RESULTS
(
    p_XML_CLOB IN CLOB,
    p_SERVICE_CODE IN VARCHAR2,
    p_SCENARIO_ID IN NUMBER,
    p_TIME_ZONE IN VARCHAR2
) AS
    v_XML  XMLTYPE;
    v_AGG_RESULTS_TABLE AGG_RESULTS_TABLE := AGG_RESULTS_TABLE();
    v_CURR_AGG_RESULTS_TABLE AGG_RESULTS_TABLE;
    v_AS_OF_DATE CONSTANT DATE := CONSTANTS.LOW_DATE;
    v_METER_ID CONSTANT METER.METER_ID%TYPE := CONSTANTS.NOT_ASSIGNED;
    v_ACCOUNT_ID ACCOUNT.ACCOUNT_ID%TYPE;
    v_CURR_ACCT_NAME ACCOUNT.ACCOUNT_NAME%TYPE;
    v_STRING_TABLE PARSE_UTIL.STRING_TABLE;
    v_INTERVAL_TYPE VARCHAR2(4);
    v_SCHEDULE_GROUP_ID SCHEDULE_GROUP.SCHEDULE_GROUP_ID%TYPE;
    v_EDC_ID ENERGY_DISTRIBUTION_COMPANY.EDC_ID%TYPE;
    v_ESP_ID ENERGY_SERVICE_PROVIDER.ESP_ID%TYPE;
    v_POOL_ID POOL.POOL_ID%TYPE;
    v_SL_ID SERVICE_LOCATION.SERVICE_LOCATION_ID%TYPE;
    v_CURR_DATE DATE;
    v_USAGE_DATA GA.FLOAT_TABLE;
    v_USAGE_DATES GA.DATE_TABLE;
    v_SUCCESS BOOLEAN := TRUE;
    v_SERVICE_ID SERVICE.SERVICE_ID%TYPE;
    v_CURR_ROW NUMBER := 1;
    v_CURR_AGG_RESULTS_TYPE AGG_RESULTS_TYPE;
    v_CURR_AGG_RESULTS_ROW NUMBER;
    v_CURR_RANKING NUMBER;

BEGIN
    v_XML := PARSE_UTIL.CREATE_XML_SAFE(p_XML_CLOB);

    SELECT AGG_RESULTS_TYPE(
               RANKING,
               AGG_METER_NAME,
               TIME_PERIOD,
               VALUE
           )
    BULK COLLECT INTO v_AGG_RESULTS_TABLE
    FROM (
        SELECT DENSE_RANK() OVER (ORDER BY AGG_METER_NAME,TRUNC(FROM_CUT(TIME_PERIOD, p_TIME_ZONE)-1/1440)) AS RANKING,
               AGG_METER_NAME,
               TIME_PERIOD,
               VALUE
        FROM (
            SELECT EXTRACTVALUE(VALUE(T), '//aggResultsView/aggMeterName') AS AGG_METER_NAME,
                   DATE_UTIL.TO_CUT_DATE_FROM_ISO(EXTRACTVALUE(VALUE(T), '//aggResultsView/timePeriod')) AS TIME_PERIOD,
                   EXTRACTVALUE(VALUE(T), '//aggResultsView/value') AS VALUE
            FROM TABLE(XMLSEQUENCE(EXTRACT(v_XML, '/collection/aggResultsView'))) T
            ORDER BY AGG_METER_NAME,TIME_PERIOD
        )
    )
    ORDER BY RANKING,AGG_METER_NAME,TIME_PERIOD
    ;
    IF v_AGG_RESULTS_TABLE.COUNT = 0 THEN
        RETURN;
    END IF;

    WHILE v_CURR_ROW <= v_AGG_RESULTS_TABLE.COUNT LOOP

        v_CURR_AGG_RESULTS_TABLE := AGG_RESULTS_TABLE();
        v_CURR_AGG_RESULTS_TYPE := v_AGG_RESULTS_TABLE(v_CURR_ROW);
        v_CURR_AGG_RESULTS_ROW := 1;
        v_CURR_RANKING := v_CURR_AGG_RESULTS_TYPE.RANKING;
        WHILE v_CURR_AGG_RESULTS_TYPE IS NOT NULL AND v_CURR_AGG_RESULTS_TYPE.RANKING = v_CURR_RANKING LOOP
            v_CURR_AGG_RESULTS_TABLE.EXTEND();
            v_CURR_AGG_RESULTS_TABLE(v_CURR_AGG_RESULTS_ROW) := v_CURR_AGG_RESULTS_TYPE;

            v_CURR_ROW := v_CURR_ROW + 1;
            IF v_CURR_ROW <= v_AGG_RESULTS_TABLE.COUNT THEN
                v_CURR_AGG_RESULTS_TYPE := v_AGG_RESULTS_TABLE(v_CURR_ROW);
                v_CURR_AGG_RESULTS_ROW := v_CURR_AGG_RESULTS_ROW + 1;
            ELSE
                v_CURR_AGG_RESULTS_TYPE := NULL;
            END IF;
        END LOOP;

        v_CURR_ACCT_NAME := v_CURR_AGG_RESULTS_TABLE(1).AGG_METER_NAME;

        v_CURR_DATE := TRUNC(FROM_CUT(v_CURR_AGG_RESULTS_TABLE(1).TIME_PERIOD, p_TIME_ZONE) - 1/1440);

        PARSE_UTIL.PARSE_DELIMITED_STRING(v_CURR_ACCT_NAME, ':', v_STRING_TABLE);
        v_CURR_ACCT_NAME := v_STRING_TABLE(1) || ':' || v_STRING_TABLE(2) || ':' ||  v_STRING_TABLE(3) || ':' ||  v_STRING_TABLE(4) || ':' ||  v_STRING_TABLE(5) || ':' ||  v_STRING_TABLE(6) || ':' ||  v_STRING_TABLE(7);

        v_ACCOUNT_ID := EI.GET_ID_FROM_IDENTIFIER(v_CURR_ACCT_NAME, EC.ED_ACCOUNT, p_QUIET => 1 );
        IF v_ACCOUNT_ID IS NULL THEN
            LOGS.LOG_ERROR('Account with identifier ' || v_CURR_ACCT_NAME || ' could not be found.  This account''s results will not be imported.');
            LOGS.LOG_DEBUG('Account with identifier ' || v_CURR_ACCT_NAME || ' could not be found.  This account''s results will not be imported.');
            GOTO END_LOOP;
        END IF;
        v_INTERVAL_TYPE := v_STRING_TABLE(4);
        v_EDC_ID := EI.GET_ID_FROM_IDENTIFIER(v_STRING_TABLE(1), EC.ED_EDC, p_QUIET => 1 );
        IF v_EDC_ID IS NULL THEN
            LOGS.LOG_ERROR('EDC with identifier ' || v_STRING_TABLE(1) || ' could not be found.  This account''s results will not be imported.');
            LOGS.LOG_DEBUG('EDC with identifier ' || v_STRING_TABLE(1) || ' could not be found.  This account''s results will not be imported.');
            GOTO END_LOOP;
        END IF;
        v_SCHEDULE_GROUP_ID := EI.GET_ID_FROM_IDENTIFIER(v_STRING_TABLE(6), EC.ED_SCHEDULE_GROUP, p_QUIET => 1 );
        IF v_SCHEDULE_GROUP_ID IS NULL THEN
            LOGS.LOG_ERROR('SCHEDULE_GROUP with identifier ' || v_STRING_TABLE(6) || ' could not be found.  This account''s results will not be imported.');
            LOGS.LOG_DEBUG('SCHEDULE_GROUP with identifier ' || v_STRING_TABLE(6) || ' could not be found.  This account''s results will not be imported.');
            GOTO END_LOOP;
        END IF;
        v_ESP_ID := EI.GET_ID_FROM_IDENTIFIER(v_STRING_TABLE(9), EC.ED_ESP, p_QUIET => 1 );
        IF v_ESP_ID IS NULL THEN
            LOGS.LOG_ERROR('ESP with identifier ' || v_STRING_TABLE(9) || ' could not be found.  This account''s results will not be imported.');
            LOGS.LOG_DEBUG('ESP with identifier ' || v_STRING_TABLE(9) || ' could not be found.  This account''s results will not be imported.');
            GOTO END_LOOP;
        END IF;
        v_POOL_ID := EI.GET_ID_FROM_IDENTIFIER(v_STRING_TABLE(10), EC.ED_POOL, p_QUIET => 1 );
        IF v_POOL_ID IS NULL THEN
            LOGS.LOG_ERROR('POOL with identifier ' || v_STRING_TABLE(10) || ' could not be found.  This account''s results will not be imported.');
            LOGS.LOG_DEBUG('POOL with identifier ' || v_STRING_TABLE(10) || ' could not be found.  This account''s results will not be imported.');
            GOTO END_LOOP;
        END IF;

        BEGIN
            SELECT ASL.SERVICE_LOCATION_ID
            INTO v_SL_ID
            FROM ACCOUNT_SERVICE_LOCATION ASL
            WHERE ASL.ACCOUNT_ID = v_ACCOUNT_ID
              AND v_CURR_DATE BETWEEN ASL.BEGIN_DATE AND NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE);
        EXCEPTION WHEN NO_DATA_FOUND THEN
            LOGS.LOG_ERROR('Service Location not assigned to Account ' || v_CURR_ACCT_NAME || ' on ' || TO_CHAR(v_CURR_DATE, 'YYYY-MM-DD') || '.  This account''s results will not be imported.');
            LOGS.LOG_DEBUG('Service Location not assigned to Account ' || v_CURR_ACCT_NAME || ' on ' || TO_CHAR(v_CURR_DATE, 'YYYY-MM-DD') || '.  This account''s results will not be imported.');
            GOTO END_LOOP;
        END;

        SELECT TIME_PERIOD, VALUE
        BULK COLLECT INTO v_USAGE_DATES, v_USAGE_DATA
        FROM TABLE(CAST(v_CURR_AGG_RESULTS_TABLE AS AGG_RESULTS_TABLE));

        BEGIN
            SELECT S.SERVICE_ID
            INTO v_SERVICE_ID
            FROM SERVICE S,
                 PROVIDER_SERVICE PS,
                 ACCOUNT_SERVICE ASER,
                 ACCOUNT A,
                 SERVICE_DELIVERY SD,
                 SCHEDULE_GROUP SG,
                 PSE_ESP PE,
                 SERVICE_STATE SS
            WHERE S.MODEL_ID = A.MODEL_ID
              AND S.SCENARIO_ID = p_SCENARIO_ID
              AND S.AS_OF_DATE = CONSTANTS.LOW_DATE
              AND S.PROVIDER_SERVICE_ID = PS.PROVIDER_SERVICE_ID
              AND PS.ESP_ID = v_ESP_ID
              AND PS.EDC_ID = v_EDC_ID
              AND S.ACCOUNT_SERVICE_ID = ASER.ACCOUNT_SERVICE_ID
              AND A.ACCOUNT_ID = v_ACCOUNT_ID
              AND ASER.SERVICE_LOCATION_ID = v_SL_ID
              AND S.SERVICE_DELIVERY_ID = SD.SERVICE_DELIVERY_ID
              AND SD.POOL_ID = v_POOL_ID
              AND SG.SC_ID = SD.SC_ID
              AND SG.SCHEDULE_GROUP_ID = v_SCHEDULE_GROUP_ID
              AND SG.SERVICE_ZONE_ID= SD.SERVICE_ZONE_ID
              AND PE.ESP_ID = PS.ESP_ID
              AND PE.PSE_ID = PS.PSE_ID
              AND S.SERVICE_ID = SS.SERVICE_ID
              AND SS.SERVICE_CODE = p_SERVICE_CODE
              AND SS.SERVICE_DATE = v_CURR_DATE
            ;

            DELETE FROM SERVICE_LOAD SL
            WHERE SL.SERVICE_ID = v_SERVICE_ID
              AND SL.SERVICE_CODE = p_SERVICE_CODE
              AND TRUNC(FROM_CUT(SL.LOAD_DATE, p_TIME_ZONE)-1/1440) = v_CURR_DATE;

            DELETE FROM SERVICE_STATE SS
            WHERE SS.SERVICE_ID = v_SERVICE_ID
              AND SS.SERVICE_CODE = p_SERVICE_CODE
              AND SS.SERVICE_DATE = v_CURR_DATE;

        EXCEPTION
        WHEN NO_DATA_FOUND THEN
            NULL;
        END;

        MS.IMPORT_SERVICE_LOAD_DATA(p_ACCOUNT_ID => v_ACCOUNT_ID,
                                    p_SERVICE_LOCATION_ID => v_SL_ID,
                                    p_METER_ID => v_METER_ID,
                                    p_SERVICE_DATE => v_CURR_DATE,
                                    p_INTERVAL_ABBR => v_INTERVAL_TYPE,
                                    p_AS_OF_DATE => v_AS_OF_DATE,
                                    p_USAGE_DATA => v_USAGE_DATA,
                                    p_USAGE_DATES => v_USAGE_DATES,
                                    p_SUCCESS => v_SUCCESS,
                                    p_SCENARIO_ID => p_SCENARIO_ID,
                                    p_SERVICE_CODE => p_SERVICE_CODE,
                                    p_ESP_ID => v_ESP_ID,
                                    p_POOL_ID => v_POOL_ID);

    <<END_LOOP>>
    NULL;
    END LOOP;

END STORE_AGG_RESULTS;
------------------------------------------------------------------------------------------
PROCEDURE RUN_XCAST
(
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_TIME_ZONE IN VARCHAR2,
    p_RUN_TYPE_ID IN INT,
    p_FILTER_MODEL_ID IN NUMBER,
    p_ACCEPT_INTO_SCHEDULES IN NUMBER,
    p_SCHEDULE_STATEMENT_TYPE_ID IN NUMBER,
    p_APPLY_USAGE_FACTOR IN NUMBER := 1,
    p_APPLY_UFE IN NUMBER := 1,
    p_TRACE_ON IN NUMBER := 0
) AS
    v_MESSAGE  VARCHAR2(4000);
    v_STATUS  NUMBER;
    v_RUN_TYPE VARCHAR2(200);
    v_SERVICE_CODE SETTLEMENT_TYPE.SERVICE_CODE%TYPE;
    v_PROCESS_ID VARCHAR2(32);
    v_PROCESS_STATUS VARCHAR2(8);
    v_AGG_RESULTS CLOB;
    v_SCENARIO_ID SCENARIO.SCENARIO_ID%TYPE;
    v_CAST_PROCESS_ID VARCHAR2(32);
    v_CAST_PROCESS_STATUS VARCHAR2(8);
    v_MODEL_IDS NUMBER_COLLECTION;
    v_IDX NUMBER;

BEGIN
  SAVEPOINT BEGIN_RUN_XCAST;
    LOGS.START_PROCESS('Run XCast',p_BEGIN_DATE, p_END_DATE);
    LOGS.SET_PROCESS_TARGET_PARAMETER('Xcast Begin Date', TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE));
    LOGS.SET_PROCESS_TARGET_PARAMETER('Xcast End Date', TEXT_UTIL.TO_CHAR_DATE(p_END_DATE));

    IF p_RUN_TYPE_ID < 0 THEN
        SELECT ST.SERVICE_CODE, ST.SCENARIO_ID, ST.SETTLEMENT_TYPE_NAME
        INTO v_SERVICE_CODE, v_SCENARIO_ID, v_RUN_TYPE
        FROM SETTLEMENT_TYPE ST
        WHERE ST.SETTLEMENT_TYPE_ID = (p_RUN_TYPE_ID * -1);
    ELSE
        SELECT GA.FORECAST_SERVICE, p_RUN_TYPE_ID, S.SCENARIO_NAME
        INTO v_SERVICE_CODE, v_SCENARIO_ID, v_RUN_TYPE
        FROM SCENARIO S
        WHERE S.SCENARIO_ID = p_RUN_TYPE_ID;
    END IF;

    LOGS.SET_PROCESS_TARGET_PARAMETER('Run Type', v_RUN_TYPE);
    LOGS.SET_PROCESS_TARGET_PARAMETER('Service Code', v_SERVICE_CODE);

    LOGS.LOG_INFO('Computing MSE and Candidate Days');
    COMPUTE_MSE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_SERVICE_CODE);

    LOGS.LOG_INFO('Sending Candidate Day List to MDR');
    SUBMIT_XCAST_TO_MDR(p_TIME_ZONE, TRIM(v_RUN_TYPE), v_SERVICE_CODE, v_PROCESS_ID);

    IF v_PROCESS_ID IS NOT NULL THEN
        WAIT_FOR_MDR_PROCESS(v_PROCESS_ID, v_PROCESS_STATUS);
        IF v_PROCESS_STATUS IS NOT NULL AND v_PROCESS_STATUS = '2' THEN
            GET_AGG_RESULTS(v_PROCESS_ID, p_TIME_ZONE, v_AGG_RESULTS);
            MS.g_APPLY_UFE_CODE := p_APPLY_UFE;
            STORE_AGG_RESULTS(v_AGG_RESULTS, v_SERVICE_CODE, v_SCENARIO_ID, p_TIME_ZONE);
            MS.g_APPLY_UFE_CODE := 0;
            LOAD_MANAGEMENT_UI.RUN_CAST_SERVICE_REQUEST(p_FILTER_MODEL_ID,
                                            p_RUN_TYPE_ID,
                                            CONSTANTS.ALL_ID,
                                            NULL,
                                            p_BEGIN_DATE,
                                            p_END_DATE,
                                            p_ACCEPT_INTO_SCHEDULES,
                                            p_SCHEDULE_STATEMENT_TYPE_ID,
                                            p_APPLY_USAGE_FACTOR,
                                            p_APPLY_UFE,
                                            p_TRACE_ON,
                                            v_CAST_PROCESS_ID,
                                            v_CAST_PROCESS_STATUS,
                                            v_MESSAGE);
            IF p_FILTER_MODEL_ID = CONSTANTS.ALL_ID THEN
                v_MODEL_IDS := NUMBER_COLLECTION(GA.ELECTRIC_MODEL, GA.GAS_MODEL);
            ELSIF p_FILTER_MODEL_ID IS NULL THEN
                v_MODEL_IDS := NUMBER_COLLECTION(GA.DEFAULT_MODEL);
            ELSE
                v_MODEL_IDS := NUMBER_COLLECTION(p_FILTER_MODEL_ID);
            END IF;

            v_IDX := v_MODEL_IDS.FIRST;
            WHILE V_IDX IS NOT NULL
            LOOP
                FS.CAST_SERVICE_REQUEST(v_SERVICE_CODE, --p_REQUEST_TYPE
                                        GA.STANDARD_MODE, --p_REQUEST_MODE
                                        v_SCENARIO_ID, --p_SCENARIO_ID
                                        v_MODEL_IDS(v_IDX), --p_MODEL_ID
                                        v_CAST_PROCESS_ID, --p_PROCESS_ID
                                        CONSTANTS.ALL_ID, --p_EDC_ID
                                        CONSTANTS.ALL_ID, --p_ESP_ID
                                        -FS.g_SUMMARY_ONLY, --p_ACCOUNT_ID
                                        p_BEGIN_DATE, --p_BEGIN_DATE
                                        p_END_DATE, --p_END_DATE
                                        SYSDATE, --p_INPUT_AS_OF_DATE
                                        CONSTANTS.LOW_DATE, --p_OUTPUT_AS_OF_DATE
                                        p_BEGIN_DATE, --p_PROFILE_BEGIN_DATE
                                        CONSTANTS.LOW_DATE, --p_PROFILE_AS_OF_DATE
                                        p_APPLY_USAGE_FACTOR, --p_APPLY_USAGE_FACTOR
                                        p_APPLY_UFE, --p_APPLY_UFE
                                        0, --p_APPLY_UFE_OTHER
                                        0, --p_APPLY_EXTERNAL_FORECAST
                                        SECURITY_CONTROLS.CURRENT_USER, --p_REQUESTOR
                                        p_TRACE_ON, --p_TRACE_ON
                                        v_CAST_PROCESS_STATUS, --p_STATUS
                                        v_MESSAGE); --p_MESSAGE

            v_IDX := v_MODEL_IDS.NEXT(V_IDX);
            END LOOP;
        END IF;
    END IF;

    LOGS.STOP_PROCESS(v_MESSAGE, v_STATUS);
  COMMIT;

EXCEPTION
  WHEN OTHERS THEN
    ERRS.ABORT_PROCESS(p_SAVEPOINT_NAME => 'BEGIN_RUN_XCAST');
END RUN_XCAST;
------------------------------------------------------------------------------------------
PROCEDURE PUT_AGGREGATE_ACCOUNT
(
    p_EXTERNAL_IDENTIFIER IN VARCHAR2,
    p_ACCOUNT_ID OUT NUMBER
) AS
    v_OID NUMBER;
    v_SL_ID NUMBER;
    v_MESSAGE VARCHAR2(4000);
BEGIN

    p_ACCOUNT_ID := EI.GET_ID_FROM_IDENTIFIER(p_EXTERNAL_IDENTIFIER, EC.ED_ACCOUNT, p_QUIET => 1 );

    IF p_ACCOUNT_ID IS NULL THEN
        IO.PUT_ACCOUNT(o_OID => v_OID,
                       p_ACCOUNT_NAME => p_EXTERNAL_IDENTIFIER,
                       p_ACCOUNT_ALIAS => p_EXTERNAL_IDENTIFIER,
                       p_ACCOUNT_DESC => c_AGG_ACCT_DESC,
                       p_ACCOUNT_ID => p_ACCOUNT_ID,
                       p_ACCOUNT_DUNS_NUMBER => NULL,
                       p_ACCOUNT_EXTERNAL_IDENTIFIER => p_EXTERNAL_IDENTIFIER,
                       p_ACCOUNT_MODEL_OPTION => ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_AGGREGATE,
                       p_ACCOUNT_SIC_CODE => NULL,
                       p_ACCOUNT_METER_TYPE => ACCOUNTS_METERS.c_METER_TYPE_INTERVAL,
                       p_ACCOUNT_METER_EXT_IDENTIFIER => NULL,
                       p_ACCOUNT_DISPLAY_NAME => NULL,
                       p_ACCOUNT_BILL_OPTION => NULL,
                       p_ACCOUNT_ROLLUP_ID => NULL,
                       p_IS_EXTERNAL_INTERVAL_USAGE => NULL,
                       p_IS_EXTERNAL_BILLED_USAGE => NULL,
                       p_IS_AGGREGATE_ACCOUNT => 1,
                       p_IS_UFE_PARTICIPANT => 1,
                       p_IS_CREATE_SETTLEMENT_PROFILE => NULL,
                       p_IS_EXTERNAL_FORECAST => NULL,
                       p_IS_SUB_AGGREGATE => 0,
                       p_TX_SERVICE_TYPE_ID => NULL,
                       p_USE_TOU_USAGE_FACTOR => NULL,
                       p_MODEL_ID => CONSTANTS.ELECTRIC_MODEL);

        p_ACCOUNT_ID := v_OID;
    ELSE
        UPDATE ACCOUNT A
        SET A.ACCOUNT_NAME = p_EXTERNAL_IDENTIFIER,
            A.ACCOUNT_ALIAS = p_EXTERNAL_IDENTIFIER,
            A.ACCOUNT_DESC = MDM.c_AGG_ACCT_DESC,
            A.MODEL_ID = CONSTANTS.ELECTRIC_MODEL,
            A.ACCOUNT_MODEL_OPTION = ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_AGGREGATE,
            A.ACCOUNT_METER_TYPE = ACCOUNTS_METERS.c_METER_TYPE_INTERVAL,
            A.IS_UFE_PARTICIPANT = 1
        WHERE A.ACCOUNT_ID = p_ACCOUNT_ID;
    END IF;

    DELETE FROM ACCOUNT_STATUS WHERE ACCOUNT_ID = p_ACCOUNT_ID;
    ACCOUNTS_METERS.PUT_ACCOUNT_STATUS(p_ACCOUNT_ID => p_ACCOUNT_ID,
                                       p_BEGIN_DATE => CONSTANTS.LOW_DATE,
                                       p_END_DATE => CONSTANTS.HIGH_DATE,
                                       p_STATUS_NAME => 'Active',
                                       p_OLD_BEGIN_DATE => NULL);

    BEGIN
        SELECT ASL.SERVICE_LOCATION_ID
        INTO v_SL_ID
        FROM ACCOUNT_SERVICE_LOCATION ASL,
             SERVICE_LOCATION SL
        WHERE ASL.ACCOUNT_ID = p_ACCOUNT_ID
          AND ASL.SERVICE_LOCATION_ID = SL.SERVICE_LOCATION_ID
          AND SL.EXTERNAL_IDENTIFIER = p_EXTERNAL_IDENTIFIER;

        UPDATE SERVICE_LOCATION SL
        SET SL.SERVICE_LOCATION_NAME = p_EXTERNAL_IDENTIFIER,
            SL.SERVICE_LOCATION_ALIAS = p_EXTERNAL_IDENTIFIER,
            SL.SERVICE_LOCATION_DESC = MDM.c_AGG_ACCT_DESC
        WHERE SL.SERVICE_LOCATION_ID = v_SL_ID;

        UPDATE ACCOUNT_SERVICE_LOCATION ASL
        SET ASL.BEGIN_DATE = CONSTANTS.LOW_DATE,
            ASL.END_DATE = CONSTANTS.HIGH_DATE
        WHERE ASL.ACCOUNT_ID = p_ACCOUNT_ID
          AND ASL.SERVICE_LOCATION_ID = v_SL_ID;
    EXCEPTION WHEN NO_DATA_FOUND THEN
        ACCOUNTS_METERS.PUT_SERVICE_LOCATION(o_OID => v_OID,
                                             p_ACCOUNT_ID => p_ACCOUNT_ID,
                                             p_OLD_SL_BEGIN_DATE => NULL,
                                             p_SL_BEGIN_DATE => CONSTANTS.LOW_DATE,
                                             p_SL_END_DATE => CONSTANTS.HIGH_DATE,
                                             p_EDC_IDENTIFIER => NULL,
                                             p_ESP_IDENTIFIER => NULL,
                                             p_SERVICE_LOCATION_NAME => p_EXTERNAL_IDENTIFIER,
                                             p_SERVICE_LOCATION_ALIAS => p_EXTERNAL_IDENTIFIER,
                                             p_SERVICE_LOCATION_DESC => MDM.c_AGG_ACCT_DESC,
                                             p_SERVICE_LOCATION_ID => NULL,
                                             p_LATITUDE => NULL,
                                             p_LONGITUDE => NULL,
                                             p_TIME_ZONE => NULL,
                                             p_EXTERNAL_IDENTIFIER => p_EXTERNAL_IDENTIFIER,
                                             p_SERVICE_POINT_ID => NULL,
                                             p_WEATHER_STATION_ID => NULL,
                                             p_STREET => NULL,
                                             p_STREET2 => NULL,
                                             p_CITY => NULL,
                                             p_STATE_CODE => NULL,
                                             p_POSTAL_CODE => NULL,
                                             p_COUNTRY_CODE => NULL,
                                             p_SQUARE_FOOTAGE => NULL,
                                             p_ANNUAL_CONSUMPTION => NULL,
                                             p_SUMMER_CONSUMPTION => NULL,
                                             p_SERVICE_ZONE_ID => NULL,
                                             p_SUB_STATION_ID => NULL,
                                             p_FEEDER_ID => NULL,
                                             p_FEEDER_SEGMENT_ID => NULL,
                                             p_MESSAGE => v_MESSAGE);
    END;

END PUT_AGGREGATE_ACCOUNT;
------------------------------------------------------------------------------------------
PROCEDURE CLEAN_AGGREGATE_ACCOUNT_REL
(
    p_ACCOUNT_ID IN NUMBER,
    p_AGG_GROUP_ATTR_ID IN NUMBER
) AS
BEGIN

    DELETE FROM ACCOUNT_EDC AE
    WHERE AE.ACCOUNT_ID = p_ACCOUNT_ID;

    DELETE FROM ACCOUNT_CALENDAR AC
    WHERE AC.ACCOUNT_ID = p_ACCOUNT_ID;

    DELETE FROM ACCOUNT_LOSS_FACTOR ALF
    WHERE ALF.ACCOUNT_ID = p_ACCOUNT_ID;

    DELETE FROM ACCOUNT_SCHEDULE_GROUP ASG
    WHERE ASG.ACCOUNT_ID = p_ACCOUNT_ID;

    DELETE FROM TEMPORAL_ENTITY_ATTRIBUTE TEA
    WHERE TEA.OWNER_ENTITY_ID = p_ACCOUNT_ID
      AND TEA.ATTRIBUTE_ID = p_AGG_GROUP_ATTR_ID;

    DELETE FROM AGGREGATE_ACCOUNT_ESP AAE
    WHERE AAE.ACCOUNT_ID = p_ACCOUNT_ID;


END CLEAN_AGGREGATE_ACCOUNT_REL;
------------------------------------------------------------------------------------------
PROCEDURE IMPORT_AGGREGATE_ACCOUNTS
(
    p_AGGREGATE_ACCOUNTS IN CLOB,
    p_PROCESS_STATUS OUT NUMBER
) AS
  v_LINES PARSE_UTIL.BIG_STRING_TABLE_MP;
    v_LINE_NUMBER NUMBER := 1;
    v_LINE VARCHAR2(4000);
    v_STRING_TABLE PARSE_UTIL.STRING_TABLE;
    v_LAST_ACCT_EXT_ID ACCOUNT.ACCOUNT_EXTERNAL_IDENTIFIER%TYPE := ' ';
    v_CURR_ACCT_EXT_ID ACCOUNT.ACCOUNT_EXTERNAL_IDENTIFIER%TYPE;
    v_ACCOUNT_ID ACCOUNT.ACCOUNT_ID%TYPE;
    v_EDC_EXT_ID EDC.EDC_EXTERNAL_IDENTIFIER%TYPE;
    v_EDC_ID EDC.EDC_ID%TYPE;
    v_RC EDC_RATE_CLASS.RATE_CLASS%TYPE;
    v_CALENDAR CALENDAR.CALENDAR_ALIAS%TYPE;
    v_CALENDAR_ID CALENDAR.CALENDAR_ID%TYPE;
    v_PROCESS_FINISH_TEXT VARCHAR2(4000);
    v_LOSS_FACTOR LOSS_FACTOR.EXTERNAL_IDENTIFIER%TYPE;
    v_LOSS_FACTOR_ID LOSS_FACTOR.LOSS_FACTOR_ID%TYPE;
    v_SCHEDULE_GROUP SCHEDULE_GROUP.SCHEDULE_GROUP_ALIAS%TYPE;
    v_SCHEDULE_GROUP_ID SCHEDULE_GROUP.SCHEDULE_GROUP_ID%TYPE;
    v_AGGREGATION_GROUP TEMPORAL_ENTITY_ATTRIBUTE.ATTRIBUTE_VAL%TYPE;
    v_AGG_GROUP_ATTR_ID ENTITY_ATTRIBUTE.ATTRIBUTE_ID%TYPE;
    v_ESP ESP.ESP_EXTERNAL_IDENTIFIER%TYPE;
    v_ESP_ID ESP.ESP_ID%TYPE;
    v_POOL POOL.POOL_EXTERNAL_IDENTIFIER%TYPE;
    v_POOL_ID POOL.POOL_ID%TYPE;
BEGIN
    LOGS.START_PROCESS('MDR: Import Aggregate Accounts');
    p_PROCESS_STATUS := LOGS.c_LEVEL_SUCCESS;

    BEGIN
        SELECT EA.ATTRIBUTE_ID
        INTO v_AGG_GROUP_ATTR_ID
        FROM ENTITY_ATTRIBUTE EA
        WHERE EA.ENTITY_DOMAIN_ID = EC.ED_ACCOUNT
          AND EA.ATTRIBUTE_NAME = 'Aggregation Group';
    EXCEPTION WHEN NO_DATA_FOUND THEN
        LOGS.LOG_ERROR('Could not find Account custom attribute named Aggregation Group');
        p_PROCESS_STATUS := LOGS.c_LEVEL_ERROR;
    END;

    PARSE_UTIL.PARSE_CLOB_INTO_LINES(p_AGGREGATE_ACCOUNTS, v_LINES);
    WHILE v_LINES.EXISTS(v_LINE_NUMBER) AND v_LINES(v_LINE_NUMBER) IS NOT NULL LOOP
    v_LINE := v_LINES(v_LINE_NUMBER);

        PARSE_UTIL.PARSE_DELIMITED_STRING(v_LINE, ':', v_STRING_TABLE);

        v_CURR_ACCT_EXT_ID := v_STRING_TABLE(1) || ':' || v_STRING_TABLE(2) || ':' ||  v_STRING_TABLE(3) || ':' ||  v_STRING_TABLE(4) || ':' ||  v_STRING_TABLE(5) || ':' ||  v_STRING_TABLE(6) || ':' ||  v_STRING_TABLE(7);
        IF v_CURR_ACCT_EXT_ID <> v_LAST_ACCT_EXT_ID THEN
            PUT_AGGREGATE_ACCOUNT(v_CURR_ACCT_EXT_ID, v_ACCOUNT_ID);
            CLEAN_AGGREGATE_ACCOUNT_REL(v_ACCOUNT_ID, v_AGG_GROUP_ATTR_ID);
            v_LAST_ACCT_EXT_ID := v_CURR_ACCT_EXT_ID;

            v_EDC_EXT_ID := v_STRING_TABLE(1);
            v_EDC_ID := EI.GET_ID_FROM_IDENTIFIER(v_EDC_EXT_ID, EC.ED_EDC, p_QUIET => 1);
            IF v_EDC_ID IS NULL THEN
                LOGS.LOG_ERROR('EDC with identifier ' || v_EDC_EXT_ID || ' could not be found.');
                p_PROCESS_STATUS := LOGS.c_LEVEL_ERROR;
            ELSE
                v_RC := v_STRING_TABLE(2);

                ACCOUNTS_METERS.PUT_ACCOUNT_EDC(p_ACCOUNT_ID => v_ACCOUNT_ID,
                                                p_EDC_ID => v_EDC_ID,
                                                p_BEGIN_DATE => CONSTANTS.LOW_DATE,
                                                p_EDC_ACCOUNT_NUMBER => NULL,
                                                p_EDC_RATE_CLASS => v_RC,
                                                p_EDC_STRATA => NULL,
                                                p_END_DATE => CONSTANTS.HIGH_DATE,
                                                p_OLD_EDC_ID => NULL,
                                                p_OLD_BEGIN_DATE => NULL);
            END IF;

            v_CALENDAR := v_STRING_TABLE(3);
            v_CALENDAR_ID := EI.GET_ID_FROM_IDENTIFIER(v_CALENDAR, EC.ED_CALENDAR, p_QUIET => 1);
            IF v_CALENDAR_ID IS NULL THEN
                LOGS.LOG_ERROR('Calendar with identifier ' || v_CALENDAR || ' could not be found.');
                p_PROCESS_STATUS := LOGS.c_LEVEL_ERROR;
            ELSE
                ACCOUNTS_METERS.PUT_ACCOUNT_CALENDAR(p_ACCOUNT_ID => v_ACCOUNT_ID,
                                                     p_CASE_ID => NULL,
                                                     p_CALENDAR_TYPE => 'Forecast',
                                                     p_BEGIN_DATE => CONSTANTS.LOW_DATE,
                                                     p_END_DATE => CONSTANTS.HIGH_DATE,
                                                     p_CALENDAR_ID => v_CALENDAR_ID,
                                                     p_OLD_CASE_ID => NULL,
                                                     p_OLD_CALENDAR_TYPE => NULL,
                                                     p_OLD_BEGIN_DATE => NULL);
            END IF;

            v_LOSS_FACTOR := v_STRING_TABLE(5);
            v_LOSS_FACTOR_ID := EI.GET_ID_FROM_IDENTIFIER(v_LOSS_FACTOR, EC.ED_LOSS_FACTOR, p_QUIET => 1);
            IF v_LOSS_FACTOR_ID IS NULL THEN
                LOGS.LOG_ERROR('Loss Factor with identifier ' || v_LOSS_FACTOR || ' could not be found.');
                p_PROCESS_STATUS := LOGS.c_LEVEL_ERROR;
            ELSE
                ACCOUNTS_METERS.PUT_ACCOUNT_LOSS_FACTOR(p_ACCOUNT_ID => v_ACCOUNT_ID,
                                                        p_CASE_ID => NULL,
                                                        p_LOSS_FACTOR_ID => v_LOSS_FACTOR_ID,
                                                        p_BEGIN_DATE => CONSTANTS.LOW_DATE,
                                                        p_END_DATE => CONSTANTS.HIGH_DATE,
                                                        p_OLD_CASE_ID => NULL,
                                                        P_OLD_BEGIN_DATE => NULL);
            END IF;

            v_SCHEDULE_GROUP := v_STRING_TABLE(6);
            v_SCHEDULE_GROUP_ID := EI.GET_ID_FROM_IDENTIFIER(v_SCHEDULE_GROUP, EC.ED_SCHEDULE_GROUP, p_QUIET => 1);
            IF v_SCHEDULE_GROUP_ID IS NULL THEN
                LOGS.LOG_ERROR('Schedule Group with identifier ' || v_SCHEDULE_GROUP || ' could not be found.');
                p_PROCESS_STATUS := LOGS.c_LEVEL_ERROR;
            ELSE
                ACCOUNTS_METERS.PUT_ACCOUNT_SCHEDULE_GROUP(p_ACCOUNT_ID => v_ACCOUNT_ID,
                                                           p_SCHEDULE_GROUP_ID => v_SCHEDULE_GROUP_ID,
                                                           p_BEGIN_DATE => CONSTANTS.LOW_DATE,
                                                           p_END_DATE => CONSTANTS.HIGH_DATE,
                                                           p_OLD_BEGIN_DATE => NULL);
            END IF;

            IF v_AGG_GROUP_ATTR_ID IS NOT NULL THEN
                v_AGGREGATION_GROUP := v_STRING_TABLE(7);
                EM.PUT_ENTITY_ATTRIBUTE_VALUE(p_OWNER_ENTITY_DOMAIN_ID => EC.ED_ACCOUNT,
                                              p_OWNER_ENTITY_ID => v_ACCOUNT_ID,
                                              p_ATTRIBUTE_ID => v_AGG_GROUP_ATTR_ID,
                                              p_BEGIN_DATE => CONSTANTS.LOW_DATE,
                                              p_END_DATE => CONSTANTS.HIGH_DATE,
                                              p_ATTRIBUTE_VAL => v_AGGREGATION_GROUP,
                                              p_OLD_OWNER_ENTITY_ID => NULL,
                                              p_OLD_ATTRIBUTE_ID => NULL,
                                              p_OLD_BEGIN_DATE => NULL);
            END IF;
        END IF;

        v_ESP := v_STRING_TABLE(9);
        v_ESP_ID := EI.GET_ID_FROM_IDENTIFIER(v_ESP, EC.ED_ESP, p_QUIET => 1);
        v_POOL := v_STRING_TABLE(10);
        v_POOL_ID := EI.GET_ID_FROM_IDENTIFIER(v_POOL, EC.ED_POOL, p_QUIET => 1);
        IF v_ESP_ID IS NULL THEN
            LOGS.LOG_ERROR('ESP with identifier ' || v_ESP || ' could not be found.');
            p_PROCESS_STATUS := LOGS.c_LEVEL_ERROR;
        ELSIF v_POOL_ID IS NULL THEN
            LOGS.LOG_ERROR('Pool with identifier ' || v_POOL || ' could not be found.');
            p_PROCESS_STATUS := LOGS.c_LEVEL_ERROR;
        ELSE
            ACCOUNTS_METERS.PUT_AGGREGATE_ACCOUNT_ESP(p_ACCOUNT_ID => v_ACCOUNT_ID,
                                                      p_ESP_ID => v_ESP_ID,
                                                      p_POOL_ID => v_POOL_ID,
                                                      p_AGG_BEGIN_DATE => CONSTANTS.LOW_DATE,
                                                      p_AGG_END_DATE => CONSTANTS.HIGH_DATE,
                                                      p_OLD_ESP_ID => NULL,
                                                      p_OLD_POOL_ID => NULL,
                                                      p_OLD_AGG_BEGIN_DATE => NULL);
        END IF;

    <<END_LOOP>>
      v_LINE_NUMBER := v_LINES.NEXT(v_LINE_NUMBER);
    END LOOP;

    LOGS.STOP_PROCESS(v_PROCESS_FINISH_TEXT, p_PROCESS_STATUS);
END IMPORT_AGGREGATE_ACCOUNTS;
------------------------------------------------------------------------------------------
PROCEDURE SYNC_WEATHER_DATA
  AS

    v_MESSAGE      VARCHAR2(4000);
    v_STATUS       NUMBER;
    v_XML          XMLTYPE;

    v_CRED         MEX_CREDENTIALS;
    v_LOGGER       MM_LOGGER_ADAPTER;
    v_REQUEST_CLOB CLOB := NULL;
    v_RESULT       MEX_RESULT;
BEGIN
 SAVEPOINT BEGIN_SYNC_WEATHER_DATA;
    LOGS.START_PROCESS('Sync Weather Data with MDR');

    -- construct xml
    GET_WEATHER_DATA_XML(v_XML);
    DBMS_LOB.CREATETEMPORARY(v_REQUEST_CLOB, TRUE);
    DBMS_LOB.OPEN(v_REQUEST_CLOB, DBMS_LOB.LOB_READWRITE);

    -- add this XML to the request CLOB
    DBMS_LOB.APPEND(v_REQUEST_CLOB, v_XML.GETCLOBVAL());
    DBMS_LOB.CLOSE(v_REQUEST_CLOB);

    -- invoke web service through MEX
    MEX_SWITCHBOARD.INIT_MEX(0, NULL, 'MDR', 'Sync Weather Data', null, 0, v_CRED, v_LOGGER);
    SECURITY_CONTROLS.SET_IS_INTERFACE(TRUE);
    v_LOGGER.LOG_START;
    v_RESULT := Mex_Switchboard.Invoke(p_Market => 'mdr',
                                       p_Action => 'syncWeather',
                                       p_Logger => v_LOGGER,
                                       p_Cred => v_CRED,
                                       p_Request_ContentType => 'application/xml',
                                       p_Request => v_REQUEST_CLOB);

  SECURITY_CONTROLS.SET_IS_INTERFACE(FALSE);
  v_LOGGER.LOG_STOP(v_STATUS, v_MESSAGE);
  v_MESSAGE := v_LOGGER.GET_END_MESSAGE;
  LOGS.STOP_PROCESS(v_MESSAGE, v_STATUS);
  COMMIT;

EXCEPTION
  WHEN OTHERS THEN
    v_STATUS  := SQLCODE;
    v_MESSAGE := UT.GET_FULL_ERRM;
    SECURITY_CONTROLS.SET_IS_INTERFACE(FALSE);
    v_LOGGER.LOG_STOP(v_STATUS, v_MESSAGE);
    v_MESSAGE := v_LOGGER.GET_END_MESSAGE;
    ERRS.ABORT_PROCESS(p_SAVEPOINT_NAME => 'BEGIN_SYNC_WEATHER_DATA');
END SYNC_WEATHER_DATA;
------------------------------------------------------------------------------------------
PROCEDURE GET_WEATHER_DATA_XML
(
 p_XML OUT XMLTYPE
) AS

v_XML XMLTYPE;

CURSOR c_XML IS
  SELECT
    (XMLELEMENT("WeatherDataXML",
      XMLELEMENT("DataPoints",
        (SELECT(XMLAGG(XMLELEMENT("DataPoint",
          (XMLELEMENT("Station", S.STATION_NAME)),
           XMLELEMENT("Parameter", S.PARAMETER_NAME),
           XMLELEMENT("Code", S.PARAMETER_CODE),
           XMLELEMENT("Date", DATE_UTIL.TO_CHAR_ISO(S.PARAMETER_DATE)),
           XMLELEMENT("Value", S.PARAMETER_VAL ))))
         From (SELECT * FROM STATION_PARAMETER_VALUE_TEMP ORDER BY STATION_NAME, PARAMETER_NAME, PARAMETER_CODE, PARAMETER_DATE) S
         )))
    )AS WEATHER_DATA
  FROM DUAL;

BEGIN
  p_XML := NULL;

  FOR v_XML IN c_XML LOOP
    SELECT XMLCONCAT(p_XML, v_XML.WEATHER_DATA)
      INTO p_XML
      FROM DUAL;
  END LOOP;
END GET_WEATHER_DATA_XML;
------------------------------------------------------------------------------------------
PROCEDURE SYNC_SEASON_DAY_TYPE
(
    p_PROCESS_STATUS OUT VARCHAR2
)
AS
    v_MESSAGE      VARCHAR2(4000);
    v_STATUS       NUMBER;
    v_XML          XMLTYPE;

    v_CRED         MEX_CREDENTIALS;
    v_LOGGER       MM_LOGGER_ADAPTER;
    v_REQUEST_CLOB CLOB := NULL;
    v_RESULT       MEX_RESULT;
BEGIN
 SAVEPOINT BEGIN_SYNC_SEASON_DAY_TYPE;
    LOGS.START_PROCESS('Sync Season Day Type with MDR');

    -- construct xml
    GET_SEASON_DAY_TYPE_XML(v_XML);
    DBMS_LOB.CREATETEMPORARY(v_REQUEST_CLOB, TRUE);
    DBMS_LOB.OPEN(v_REQUEST_CLOB, DBMS_LOB.LOB_READWRITE);

    -- add this XML to the request CLOB
    DBMS_LOB.APPEND(v_REQUEST_CLOB, v_XML.GETCLOBVAL());
    DBMS_LOB.CLOSE(v_REQUEST_CLOB);

    -- invoke web service through MEX
    MEX_SWITCHBOARD.INIT_MEX(0, NULL, 'MDR', 'Sync Season Day Type', null, 0, v_CRED, v_LOGGER);
    SECURITY_CONTROLS.SET_IS_INTERFACE(TRUE);
    v_LOGGER.LOG_START;
    v_RESULT := Mex_Switchboard.Invoke(p_Market => 'mdr',
                                       p_Action => 'syncSeasonDayType',
                                       p_Logger => v_LOGGER,
                                       p_Cred => v_CRED,
                                       p_Request_ContentType => 'application/xml',
                                       p_Request => v_REQUEST_CLOB);

    IF v_RESULT.STATUS_CODE = MEX_SWITCHBOARD.c_STATUS_SUCCESS THEN
        p_PROCESS_STATUS := v_RESULT.RESPONSE;
    END IF;

    SECURITY_CONTROLS.SET_IS_INTERFACE(FALSE);
    v_LOGGER.LOG_STOP(v_STATUS, v_MESSAGE);
    v_MESSAGE := v_LOGGER.GET_END_MESSAGE;
    LOGS.STOP_PROCESS(v_MESSAGE, v_STATUS);

    COMMIT;

EXCEPTION
  WHEN OTHERS THEN
    v_STATUS  := SQLCODE;
    v_MESSAGE := UT.GET_FULL_ERRM;
    SECURITY_CONTROLS.SET_IS_INTERFACE(FALSE);
    v_LOGGER.LOG_STOP(v_STATUS, v_MESSAGE);
    v_MESSAGE := v_LOGGER.GET_END_MESSAGE;
    ERRS.ABORT_PROCESS(p_SAVEPOINT_NAME => 'BEGIN_SYNC_SEASON_DAY_TYPE');
END SYNC_SEASON_DAY_TYPE;
------------------------------------------------------------------------------------------
PROCEDURE GET_SEASON_DAY_TYPE_XML
(
 p_XML OUT XMLTYPE
) AS

v_XML XMLTYPE;

CURSOR c_XML IS
 SELECT
    (XMLELEMENT("DayTypeXML",
      XMLELEMENT("Seasons",
        (SELECT(XMLAGG(XMLELEMENT("Season",
          (XMLELEMENT("Name", S.SEASON_NAME)),
           XMLELEMENT("Begin", S.BEGIN_DATE),
           XMLELEMENT("End", S.END_DATE)
           )))
         From (SELECT * FROM SEASON ORDER BY SEASON_NAME) S
         )),
         XMLELEMENT("Holidays",
        (SELECT(XMLAGG(XMLELEMENT("Holiday",
          (XMLELEMENT("Name", S.Holiday_name)),
           XMLELEMENT("Year", S.holiday_year),
           XMLELEMENT("Date", S.Holiday_date)
           )))
         From (SELECT H.HOLIDAY_NAME, HO.HOLIDAY_YEAR, HO.HOLIDAY_DATE FROM Holiday H, Holiday_Observance HO where H.HOLIDAY_ID = HO.HOLIDAY_ID ORDER BY Holiday_name, Holiday_year) S
         )),
         XMLELEMENT("Types",
        (SELECT(XMLAGG(XMLELEMENT("Type",
          (XMLELEMENT("Name", S.TEMPLATE_NAME)),
           XMLELEMENT("Season", S.SEASON_NAME),
           XMLELEMENT("Day", S.DAY_NAME)
           )))
         From (SELECT T.TEMPLATE_NAME, S.SEASON_NAME, D.DAY_NAME FROM SEASON S, TEMPLATE T, TEMPLATE_SEASON_DAY_NAME D  WHERE T.TEMPLATE_ID = D.TEMPLATE_ID AND S.SEASON_ID = D.SEASON_ID ORDER BY TEMPLATE_NAME, SEASON_NAME, DAY_NAME) S
         )))
    )AS SEASON_DAY_TYPE
  FROM DUAL;


BEGIN
  p_XML := NULL;

  FOR v_XML IN c_XML LOOP
    SELECT XMLCONCAT(p_XML, v_XML.SEASON_DAY_TYPE)
      INTO p_XML
      FROM DUAL;
  END LOOP;
END GET_SEASON_DAY_TYPE_XML;
------------------------------------------------------------------------------------------
PROCEDURE GET_WRF_XML
(
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_TIME_ZONE IN VARCHAR2,
    p_TEMPLATE_ID_COLL IN NUMBER_COLLECTION,
    p_ACCOUNT_ID_COLL IN NUMBER_COLLECTION,
    p_XML OUT XMLTYPE
) AS
BEGIN

    SELECT XMLELEMENT("WRFXML", B, E, TZT, TY.TYPES, ACC.ACCS) INTO p_XML FROM
               (SELECT XMLELEMENT("Begin", TO_CHAR(p_BEGIN_DATE, 'YYYY-MM-DD')) AS B,
               XMLELEMENT("End", TO_CHAR(p_END_DATE, 'YYYY-MM-DD')) AS E,
               XMLELEMENT("Timezone", p_TIME_ZONE) AS TZT,
               XMLELEMENT("Types",
                   XMLAGG(
                       XMLELEMENT("Type",
                           XMLELEMENT("Day", TEMPLATE_NAME),
                           XMLELEMENT("Params",
                               XMLAGG(
                                   XMLELEMENT("Param", PARAMETER_NAME)
                                   ORDER BY VARIABLE_NBR
                               )
                           )
                       )
                       ORDER BY TEMPLATE_NAME
                   )
               ) AS TYPES
     FROM TABLE(CAST(p_TEMPLATE_ID_COLL AS NUMBER_COLLECTION)) TTR,
         TEMPLATE T,
         TEMPLATE_BREAKPOINT TB,
         WEATHER_PARAMETER WP
     WHERE TTR.COLUMN_VALUE = T.TEMPLATE_ID
      AND T.TEMPLATE_ID = TB.TEMPLATE_ID
      AND TB.PARAMETER_ID = WP.PARAMETER_ID
     GROUP BY TEMPLATE_NAME) TY,
     (SELECT XMLELEMENT("Accounts",
                   XMLAGG(
                             XMLELEMENT("Account", ACCOUNT_EXTERNAL_IDENTIFIER)
                             ORDER BY ACCOUNT_EXTERNAL_IDENTIFIER
                         )
                ) AS ACCS
               FROM ACCOUNT A,
                    TABLE(CAST(p_ACCOUNT_ID_COLL AS NUMBER_COLLECTION)) W
               WHERE W.COLUMN_VALUE = A.ACCOUNT_ID
                 AND A.ACCOUNT_METER_TYPE = 'Interval'
                 AND A.IS_AGGREGATE_ACCOUNT = 1
			     AND A.ACCOUNT_EXTERNAL_IDENTIFIER IS NOT NULL
     ) ACC;

END GET_WRF_XML;
------------------------------------------------------------------------------------------
PROCEDURE CREATE_WRF_PROFILES_MDR
(
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_TIME_ZONE IN VARCHAR2,
    p_TEMPLATE_ID_COLL IN NUMBER_COLLECTION,
    p_ACCOUNT_ID_COLL IN NUMBER_COLLECTION,
    p_PROCESS_STATUS OUT VARCHAR2
) AS
    v_XML          XMLTYPE;
    v_REQUEST_CLOB CLOB;
    v_CRED         MEX_CREDENTIALS;
    v_LOGGER       MM_LOGGER_ADAPTER;
    v_RESULT       MEX_RESULT;
    v_MESSAGE      VARCHAR2(4000);
    v_STATUS       NUMBER;
BEGIN
 SAVEPOINT BEGIN_CREATE_WRF_PROFILES_MDR;
    LOGS.START_PROCESS('Create WRF Profiles in MDR');

    -- construct xml
    GET_WRF_XML(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_TEMPLATE_ID_COLL, p_ACCOUNT_ID_COLL, v_XML);
    DBMS_LOB.CREATETEMPORARY(v_REQUEST_CLOB, TRUE);
    DBMS_LOB.OPEN(v_REQUEST_CLOB, DBMS_LOB.LOB_READWRITE);

    -- add this XML to the request CLOB
    DBMS_LOB.APPEND(v_REQUEST_CLOB, v_XML.GETCLOBVAL());
    DBMS_LOB.CLOSE(v_REQUEST_CLOB);

    -- invoke web service through MEX
    MEX_SWITCHBOARD.INIT_MEX(0, NULL, 'MDR', 'Create WRF Profiles', null, 0, v_CRED, v_LOGGER);
    SECURITY_CONTROLS.SET_IS_INTERFACE(TRUE);
    v_LOGGER.LOG_START;
    v_RESULT := Mex_Switchboard.Invoke(p_Market => 'mdr',
                                       p_Action => 'createWRFProfiles',
                                       p_Logger => v_LOGGER,
                                       p_Cred => v_CRED,
                                       p_Request_ContentType => 'application/xml',
                                       p_Request => v_REQUEST_CLOB);

    IF v_RESULT.STATUS_CODE = MEX_SWITCHBOARD.c_STATUS_SUCCESS THEN
        p_PROCESS_STATUS := v_RESULT.RESPONSE;
    END IF;

    SECURITY_CONTROLS.SET_IS_INTERFACE(FALSE);
    v_LOGGER.LOG_STOP(v_STATUS, v_MESSAGE);
    v_MESSAGE := v_LOGGER.GET_END_MESSAGE;
    LOGS.STOP_PROCESS(v_MESSAGE, v_STATUS);

    COMMIT;

EXCEPTION
  WHEN OTHERS THEN
    v_STATUS  := SQLCODE;
    v_MESSAGE := UT.GET_FULL_ERRM;
    SECURITY_CONTROLS.SET_IS_INTERFACE(FALSE);
    v_LOGGER.LOG_STOP(v_STATUS, v_MESSAGE);
    v_MESSAGE := v_LOGGER.GET_END_MESSAGE;
    ERRS.ABORT_PROCESS(p_SAVEPOINT_NAME => 'BEGIN_CREATE_WRF_PROFILES_MDR');
END CREATE_WRF_PROFILES_MDR;
------------------------------------------------------------------------------------------
PROCEDURE CREATE_WRF_PROFILES
(
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_TIME_ZONE IN VARCHAR2,
    p_TEMPLATE_ID_COLL IN NUMBER_COLLECTION,
    p_ACCOUNT_ID_COLL IN NUMBER_COLLECTION
) AS
    --v_PROCESS_ID VARCHAR2(32);
    v_PROCESS_STATUS VARCHAR2(8);
BEGIN
    SYNC_SEASON_DAY_TYPE(v_PROCESS_STATUS);

    --IF v_PROCESS_ID IS NOT NULL THEN
        --WAIT_FOR_MDR_PROCESS(v_PROCESS_ID, v_PROCESS_STATUS);
        --IF v_PROCESS_STATUS IS NOT NULL AND v_PROCESS_STATUS = '2' THEN
            --CREATE_WRF_PROFILES_MDR(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_TEMPLATE_ID_COLL, v_PROCESS_ID);
            --WAIT_FOR_MDR_PROCESS(v_PROCESS_ID, v_PROCESS_STATUS);
        --END IF;
    --END IF;

    IF v_PROCESS_STATUS IS NOT NULL AND v_PROCESS_STATUS = '1' THEN
        CREATE_WRF_PROFILES_MDR(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_TEMPLATE_ID_COLL, p_ACCOUNT_ID_COLL, v_PROCESS_STATUS);
    END IF;

END CREATE_WRF_PROFILES;
------------------------------------------------------------------------------------------
FUNCTION GET_MDR_BACKEND_SETTING RETURN VARCHAR2 AS
BEGIN
    RETURN UPPER(GET_DICTIONARY_VALUE('MDR Backend', 0, 'System', 'GA Settings', 'General'));
END GET_MDR_BACKEND_SETTING;
END MDM;
/
