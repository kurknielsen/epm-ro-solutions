CREATE OR REPLACE PACKAGE BODY SP AS
---------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
    RETURN '$Revision: 1.2 $';
END WHAT_VERSION;
----------------------------------------------------------------------------------------------------
PROCEDURE NULL_CURSOR
    (
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
		SELECT NULL FROM DUAL;

END NULL_CURSOR;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_HOLIDAY_OBSERVANCE
	(
	p_HOLIDAY_ID IN NUMBER,
	p_HOLIDAY_YEAR IN NUMBER,
	p_HOLIDAY_DATE OUT DATE
	) AS
-- ANSWER THE SINGLETON INSTANCE OF THE ENTITY IDENTIFIED BY THE SPECIFIED OID
-- ANSWER NULL VALUES IF THE ENTITY CANNOT BE FOUND
v_HOLIDAY_OBSERVANCE HOLIDAY_OBSERVANCE%ROWTYPE;
BEGIN

	IF NOT CAN_READ('Product') THEN
		ERRS.RAISE_NO_READ_MODULE('Product');
	END IF;

-- SELECT THE EXISTING RECORD
	SELECT *
	INTO v_HOLIDAY_OBSERVANCE
	FROM HOLIDAY_OBSERVANCE
	WHERE HOLIDAY_ID = p_HOLIDAY_ID
		AND HOLIDAY_YEAR = p_HOLIDAY_YEAR;
-- SET THE OUTPUT PARAMETERS OF THE PROCEDURE
	p_HOLIDAY_DATE := v_HOLIDAY_OBSERVANCE.HOLIDAY_DATE;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			p_HOLIDAY_DATE := SYSDATE;

END GET_HOLIDAY_OBSERVANCE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_HOLIDAY_OBSERVANCE
	(
	p_HOLIDAY_ID IN NUMBER,
	p_HOLIDAY_YEAR IN NUMBER,
	p_HOLIDAY_DATE IN DATE
	) AS
BEGIN

	IF NOT CAN_WRITE('Product') THEN
		ERRS.RAISE_NO_WRITE_MODULE('Product');
	END IF;

-- UPDATE AN EXISTING RECORD
	UPDATE HOLIDAY_OBSERVANCE SET
		HOLIDAY_DATE = TRUNC(p_HOLIDAY_DATE),
		ENTRY_DATE = SYSDATE
	WHERE HOLIDAY_ID = p_HOLIDAY_ID
		AND HOLIDAY_YEAR = p_HOLIDAY_YEAR;
-- IF THE PREVIOUS UPDATE DID NOT FIND A MATCH, THEN INSERT A NEW RECORD
	IF SQL%NOTFOUND THEN
		INSERT INTO HOLIDAY_OBSERVANCE (
			HOLIDAY_ID,
			HOLIDAY_YEAR,
			HOLIDAY_DATE,
			ENTRY_DATE)
		VALUES (
			p_HOLIDAY_ID,
			p_HOLIDAY_YEAR,
			TRUNC(p_HOLIDAY_DATE),
			SYSDATE);
	END IF;

END PUT_HOLIDAY_OBSERVANCE;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_PHONE_NUMBER
	(
	o_OID OUT NUMBER,
	p_CONTACT_ID IN NUMBER,
	p_PHONE_TYPE IN VARCHAR2,
	p_PHONE_NUMBER IN VARCHAR2,
	p_OLD_PHONE_TYPE IN VARCHAR2
	) AS
-- CREATE OR REPLACE AN ENTITY
-- ANSWER ITS OID, OR -1 IF THERE IS A DUPLICATE NAME
v_COUNT NUMBER;
BEGIN

	IF NOT CAN_WRITE('Data Setup') THEN
		ERRS.RAISE_NO_WRITE_MODULE('Data Setup');
	END IF;

-- UPDATE AN EXISTING RECORD
	UPDATE PHONE_NUMBER SET
		PHONE_TYPE = LTRIM(RTRIM(p_PHONE_TYPE)),
		PHONE_NUMBER = LTRIM(RTRIM(NVL(p_PHONE_NUMBER,GA.UNDEFINED_ATTRIBUTE))),
		ENTRY_DATE = SYSDATE
	WHERE CONTACT_ID = p_CONTACT_ID AND PHONE_TYPE = p_OLD_PHONE_TYPE;
	o_OID := p_CONTACT_ID;

-- IF THE PREVIOUS UPDATE DID NOT FIND A MATCH, THEN INSERT A NEW RECORD.
	IF SQL%NOTFOUND THEN
-- DETERMINE IF THE ENTITY ALREADY EXISTS
		SELECT COUNT(*)
		INTO v_COUNT
		FROM PHONE_NUMBER
		WHERE CONTACT_ID = p_CONTACT_ID
			AND PHONE_TYPE = p_OLD_PHONE_TYPE;
-- IF THE COUNT IS ZERO AN ENTITY WAS NOT FOUND, SO INSERT THE NEW ENTITY.
-- KEEP THE CURRENT CONTACT_ID FOR THE PHONE_NUMBER
		IF v_COUNT = 0 THEN
			INSERT INTO PHONE_NUMBER (
				CONTACT_ID,
				PHONE_TYPE,
				PHONE_NUMBER,
				ENTRY_DATE)
			VALUES (
				p_CONTACT_ID,
				LTRIM(RTRIM(NVL(p_PHONE_TYPE,GA.UNDEFINED_ATTRIBUTE))),
				LTRIM(RTRIM(NVL(p_PHONE_NUMBER,GA.UNDEFINED_ATTRIBUTE))),
				SYSDATE);
			o_OID := p_CONTACT_ID;
		ELSE
			o_OID := GA.DUPLICATE_ENTITY;
		END IF;
	END IF;
END PUT_PHONE_NUMBER;

----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ENTITY_ATTRIBUTE
	(
	o_OID OUT NUMBER,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ATTRIBUTE_NAME IN VARCHAR2,
	p_ATTRIBUTE_ID IN NUMBER,
	p_ATTRIBUTE_TYPE IN VARCHAR2,
	p_ATTRIBUTE_SHOW IN NUMBER
	) AS
-- CREATE OR REPLACE AN ENTITY
-- ANSWER ITS OID, OR -1 IF THERE IS A DUPLICATE NAME
v_COUNT NUMBER;
v_OID NUMBER;
BEGIN

	IF NOT CAN_WRITE('Public') THEN
		ERRS.RAISE_NO_WRITE_MODULE('Public');
	END IF;

-- UPDATE AN EXISTING RECORD THAT HAS AN ASSIGNED OID
	IF p_ATTRIBUTE_ID > 0 THEN
--DETERMINE IF THE SPECIFIED CASE-INSENSITIVE NAME IS CURRENTLY IN USE BY ANOTHER ENTITY
--SIGNAL A NAME COLLISION EXCEPTION WHEN THE NAME OF THE ENTITY IS CHANGED TO ONE IN USE
		SELECT COUNT(*)
		INTO v_COUNT
		FROM ENTITY_ATTRIBUTE
		WHERE UPPER(ATTRIBUTE_NAME) = UPPER(LTRIM(RTRIM(p_ATTRIBUTE_NAME)))
			AND ATTRIBUTE_ID <> p_ATTRIBUTE_ID
			AND ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID;
		IF v_COUNT = 0 THEN
			UPDATE ENTITY_ATTRIBUTE SET
				ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID,
				ATTRIBUTE_NAME = LTRIM(RTRIM(NVL(p_ATTRIBUTE_NAME,GA.UNDEFINED_ATTRIBUTE))),
				ATTRIBUTE_TYPE = LTRIM(RTRIM(NVL(p_ATTRIBUTE_TYPE,GA.UNDEFINED_ATTRIBUTE))),
				ATTRIBUTE_SHOW = NVL(p_ATTRIBUTE_SHOW,0),
				ENTRY_DATE = SYSDATE
			WHERE ATTRIBUTE_ID = p_ATTRIBUTE_ID;
			o_OID := p_ATTRIBUTE_ID;
		ELSE
			o_OID := GA.DUPLICATE_ENTITY;
			RETURN;
		END IF;
	END IF;
-- INSERT A NEW RECORD AND ASSIGN IT A UNIQUE OID.
	IF p_ATTRIBUTE_ID = 0 THEN
-- DETERMINE IF THE SPECIFIED CASE-INSENSITIVE NAME IS CURRENTLY IN USE BY ANOTHER ENTITY
-- SIGNAL A NAME COLLISION EXCEPTION WHEN THE SPECIFIED NAME OF THE ENTITY IS ONE IN USE
		SELECT COUNT(*)
		INTO v_COUNT
		FROM ENTITY_ATTRIBUTE
		WHERE UPPER(ATTRIBUTE_NAME) = UPPER(LTRIM(RTRIM(p_ATTRIBUTE_NAME)))
			AND ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID;
-- IF THE COUNT IS ZERO AN ENTITY WAS NOT FOUND, SO INSERT THE NEW ENTITY.
-- ASSIGN THE NEXT OBJECT IDENTIFICATION (OID) TO THE ENTITY
		IF v_COUNT = 0 THEN
			SELECT OID.NEXTVAL INTO v_OID FROM DUAL;
			INSERT INTO ENTITY_ATTRIBUTE (
				ENTITY_DOMAIN_ID,
				ATTRIBUTE_NAME,
				ATTRIBUTE_ID,
				ATTRIBUTE_TYPE,
				ATTRIBUTE_SHOW,
				ENTRY_DATE)
			VALUES (
				p_ENTITY_DOMAIN_ID,
				LTRIM(RTRIM(NVL(p_ATTRIBUTE_NAME,GA.UNDEFINED_ATTRIBUTE))),
				v_OID,
				LTRIM(RTRIM(NVL(p_ATTRIBUTE_TYPE,GA.UNDEFINED_ATTRIBUTE))),
				NVL(p_ATTRIBUTE_SHOW,0),
				SYSDATE);
			o_OID := v_OID;
		ELSE
			o_OID := GA.DUPLICATE_ENTITY;
		END IF;
	END IF;

END PUT_ENTITY_ATTRIBUTE;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_ENTITY_ATTRIBUTE
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ATTRIBUTE_NAME IN VARCHAR2,
	p_ATTRIBUTE_ID OUT NUMBER,
	p_ATTRIBUTE_TYPE OUT VARCHAR2,
	p_ATTRIBUTE_SHOW OUT NUMBER
	)
	AS
-- ANSWER THE SINGLETON INSTANCE OF THE ENTITY IDENTIFIED BY THE SPECIFIED OID
-- ANSWER NULL VALUES IF THE ENTITY CANNOT BE FOUND
v_RECORD ENTITY_ATTRIBUTE%ROWTYPE;
v_EMPTY_STRING VARCHAR(1) := ' ';
BEGIN

	IF NOT CAN_WRITE('Public') THEN
		ERRS.RAISE_NO_WRITE_MODULE('Public');
	END IF;

--SELECT THE EXISTING RECORD
	SELECT *
	INTO v_RECORD
	FROM ENTITY_ATTRIBUTE
	WHERE ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID
		AND UPPER(ATTRIBUTE_NAME) = LTRIM(RTRIM(UPPER(p_ATTRIBUTE_NAME)));
--SET THE OUTPUT PARAMETERS OF THE PROCEDURE
	p_ATTRIBUTE_ID := v_RECORD.ATTRIBUTE_ID;
	p_ATTRIBUTE_TYPE := v_RECORD.ATTRIBUTE_TYPE;
	p_ATTRIBUTE_SHOW := v_RECORD.ATTRIBUTE_SHOW;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			p_ATTRIBUTE_ID := 0;
			p_ATTRIBUTE_TYPE := v_EMPTY_STRING;
			p_ATTRIBUTE_SHOW := 0;

END GET_ENTITY_ATTRIBUTE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_TEMPORAL_ENTITY_ATTRIBUTE
	(
	p_OWNER_ENTITY_ID IN NUMBER,
	p_ATTRIBUTE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ATTRIBUTE_VAL IN VARCHAR,
	p_OLD_OWNER_ENTITY_ID IN NUMBER,
	p_OLD_ATTRIBUTE_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS
v_END_DATE DATE;
v_ENTITY_ATTRIBUTE_ROW ENTITY_ATTRIBUTE%ROWTYPE;
BEGIN

	IF NOT CAN_WRITE('Public') THEN
		ERRS.RAISE_NO_WRITE_MODULE('Public');
	END IF;

	v_END_DATE := NULL_DATE(p_END_DATE);
	p_STATUS := GA.SUCCESS;
-- FIRST TRY TO UPDATE AN EXISTING TEMPORAL ENTITY ATTRIBUTE FOR THE OWNING ENTITY
	UPDATE TEMPORAL_ENTITY_ATTRIBUTE SET
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		OWNER_ENTITY_ID = p_OWNER_ENTITY_ID,
		END_DATE = TRUNC(v_END_DATE),
		ATTRIBUTE_VAL = NVL(p_ATTRIBUTE_VAL,GA.UNDEFINED_ATTRIBUTE),
		ATTRIBUTE_ID = p_ATTRIBUTE_ID,
		ENTRY_DATE = SYSDATE
	WHERE OWNER_ENTITY_ID = p_OLD_OWNER_ENTITY_ID AND
		ATTRIBUTE_ID = p_OLD_ATTRIBUTE_ID AND
		BEGIN_DATE = p_OLD_BEGIN_DATE;
-- IF THE UPDATE FAILED TO FIND AN EXISTING TEMPORAL ENTITY THEN INSERT A NEW TEMPORAL ENTITY
	IF SQL%NOTFOUND THEN
        SELECT * INTO v_ENTITY_ATTRIBUTE_ROW
        FROM ENTITY_ATTRIBUTE
        WHERE ATTRIBUTE_ID = p_ATTRIBUTE_ID;

		INSERT INTO TEMPORAL_ENTITY_ATTRIBUTE (
			OWNER_ENTITY_ID,
			ATTRIBUTE_ID,
			BEGIN_DATE,
            ENTITY_DOMAIN_ID,
            ATTRIBUTE_NAME,
			END_DATE,
			ATTRIBUTE_VAL,
			ENTRY_DATE)
		VALUES (
			p_OWNER_ENTITY_ID,
			p_ATTRIBUTE_ID,
			TRUNC(p_BEGIN_DATE),
            v_ENTITY_ATTRIBUTE_ROW.ENTITY_DOMAIN_ID,
            v_ENTITY_ATTRIBUTE_ROW.ATTRIBUTE_NAME,
			TRUNC(v_END_DATE),
			NVL(p_ATTRIBUTE_VAL,0),
			SYSDATE);
	END IF;

END PUT_TEMPORAL_ENTITY_ATTRIBUTE;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SP_TIME_ZONE
	(
	p_SERVICE_POINT_ID IN NUMBER,
	p_TIME_ZONE OUT VARCHAR
	)
	AS
-- ANSWER THE SINGLETON INSTANCE OF THE ENTITY IDENTIFIED BY THE SPECIFIED OID
-- ANSWER NULL VALUES IF THE ENTITY CANNOT BE FOUND
v_EMPTY_STRING VARCHAR(1) := ' ';
BEGIN
--SELECT THE EXISTING RECORD
	SELECT TIME_ZONE
	INTO p_TIME_ZONE
	FROM SERVICE_POINT
	WHERE SERVICE_POINT_ID = p_SERVICE_POINT_ID;
--SET THE OUTPUT PARAMETERS OF THE PROCEDURE
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			p_TIME_ZONE := v_EMPTY_STRING;

END GET_SP_TIME_ZONE;
----------------------------------------------------------------------------------------------------
PROCEDURE CREATE_US_HOLIDAYS
	(
	p_FROM_YEAR IN NUMBER,
	p_TO_YEAR IN NUMBER
	) AS

-- BEGIN FC.CREATE_US_HOLIDAYS(1996,2004); END;

v_NEW_YEARS_ID NUMBER;
v_MEMORIAL_ID NUMBER;
v_INDEPENDENCE_ID NUMBER;
v_LABOR_ID NUMBER;
v_THANKSGIVING_ID NUMBER;
v_CHRISTMAS_ID NUMBER;
v_YEAR NUMBER(4);
v_YR CHAR(4);

BEGIN

	IF NOT CAN_WRITE('Product') THEN
		ERRS.RAISE_NO_WRITE_MODULE('Product');
	END IF;

	ID.ID_FOR_HOLIDAY('New Years Day', v_NEW_YEARS_ID);
	ID.ID_FOR_HOLIDAY('Memorial Day', v_MEMORIAL_ID);
	ID.ID_FOR_HOLIDAY('Independence Day', v_INDEPENDENCE_ID);
	ID.ID_FOR_HOLIDAY('Labor Day', v_LABOR_ID);
	ID.ID_FOR_HOLIDAY('Thanksgiving', v_THANKSGIVING_ID);
	ID.ID_FOR_HOLIDAY('Christmas', v_CHRISTMAS_ID);

	v_YEAR := p_FROM_YEAR;

	WHILE v_YEAR <= p_TO_YEAR LOOP
		v_YR := TO_CHAR(v_YEAR);
	    PUT_HOLIDAY_OBSERVANCE(v_NEW_YEARS_ID, v_YEAR, HOLIDAY_OBSERVANCE_DAY('US New Years Day', v_YR));
	    PUT_HOLIDAY_OBSERVANCE(v_MEMORIAL_ID, v_YEAR, HOLIDAY_OBSERVANCE_DAY('US Memorial',v_YR));
	    PUT_HOLIDAY_OBSERVANCE(v_INDEPENDENCE_ID, v_YEAR, HOLIDAY_OBSERVANCE_DAY('US Independence Day', v_YR));
	    PUT_HOLIDAY_OBSERVANCE(v_LABOR_ID, v_YEAR, HOLIDAY_OBSERVANCE_DAY('US Labor',v_YR));
	    PUT_HOLIDAY_OBSERVANCE(v_THANKSGIVING_ID, v_YEAR, HOLIDAY_OBSERVANCE_DAY('US Thanksgiving',v_YR));
	    PUT_HOLIDAY_OBSERVANCE(v_CHRISTMAS_ID, v_YEAR, HOLIDAY_OBSERVANCE_DAY('US Christmas',v_YR));
		v_YEAR := v_YEAR + 1;
	END LOOP;

END CREATE_US_HOLIDAYS;
----------------------------------------------------------------------------------------------------
PROCEDURE ENTITY_ATTRIBUTE_ASSIGNMENTS
	(
	p_ENTITY_DOMAIN_ALIAS IN VARCHAR,
	p_ATTRIBUTE_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- ANSWER A RECORDSET CONTAINING THE ENTITIES THAT CONTAIN THIS ATTRIBUTE, AND THEIR VALUES.
-- RIGHT NOW, ONLY DEFINED FOR ACCOUNT ENTITY DOMAIN.

BEGIN

	IF NOT CAN_READ('Public') THEN
		ERRS.RAISE_NO_READ_MODULE('Public');
	END IF;

	p_STATUS := GA.SUCCESS;

	IF UPPER(p_ENTITY_DOMAIN_ALIAS) = 'ACCOUNT' THEN
		OPEN p_CURSOR FOR
			SELECT A.ACCOUNT_NAME AS OWNER_ENTITY_NAME, B.OWNER_ENTITY_ID,
				B.BEGIN_DATE, B.END_DATE, B.ATTRIBUTE_VAL, B.ENTRY_DATE
			FROM ACCOUNT A, TEMPORAL_ENTITY_ATTRIBUTE B
			WHERE B.ATTRIBUTE_ID = p_ATTRIBUTE_ID AND A.ACCOUNT_ID = B.OWNER_ENTITY_ID;
	ELSE
		OPEN p_CURSOR FOR
			SELECT NULL FROM DUAL;
		p_STATUS := GA.NO_DATA_FOUND;
	END IF;

END ENTITY_ATTRIBUTE_ASSIGNMENTS;
----------------------------------------------------------------------------------------------------
PROCEDURE ENTITY_ATTRIBUTES_BY_DOMAIN
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- ANSWER A RECORDSET CONTAINING ATTRIBUTES FOR THE DOMAIN

BEGIN

	IF NOT CAN_READ('Public') THEN
		ERRS.RAISE_NO_READ_MODULE('Public');
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT ATTRIBUTE_NAME, ATTRIBUTE_ID
		FROM ENTITY_ATTRIBUTE A
		WHERE A.ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID
		ORDER BY 1;

END ENTITY_ATTRIBUTES_BY_DOMAIN;
----------------------------------------------------------------------------------------------------
PROCEDURE CLEAR_PATH_PROVIDER
        (
        p_PATH_ID IN NUMBER
        ) AS
BEGIN

	IF NOT CAN_DELETE('Scheduling') THEN
		ERRS.RAISE_NO_DELETE_MODULE('Scheduling');
	END IF;

        DELETE
        FROM PATH_PROVIDER
        WHERE PATH_ID = p_PATH_ID;
END CLEAR_PATH_PROVIDER;
----------------------------------------------------------------------------------------------------
PROCEDURE CLEAR_TRANSACTION_PATH
        (
        p_TRANSACTION_ID IN NUMBER
        ) AS
BEGIN

	IF NOT CAN_DELETE('Scheduling') THEN
		ERRS.RAISE_NO_DELETE_MODULE('Scheduling');
	END IF;

        DELETE
        FROM TRANSACTION_PATH
        WHERE TRANSACTION_ID = p_TRANSACTION_ID;
END CLEAR_TRANSACTION_PATH;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_PATH_PROVIDERS
        (
        p_PATH_ID IN NUMBER,
        p_STATUS OUT NUMBER,
        p_CURSOR IN OUT GA.REFCURSOR
        ) AS
-- ANSWER A RECORDSET CONTAINING THE LEGS FOR THE GIVEN PATH ID
BEGIN

	IF NOT CAN_READ('Scheduling') THEN
		ERRS.RAISE_NO_READ_MODULE('Scheduling');
	END IF;

        p_STATUS := GA.SUCCESS;

        OPEN p_CURSOR FOR
                SELECT *
                FROM PATH_PROVIDER
                WHERE PATH_ID = p_PATH_ID
                ORDER BY LEG_NBR;

END GET_PATH_PROVIDERS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_TRANSACTION_PATHS
        (
        p_TRANSACTION_ID IN NUMBER,
        p_STATUS OUT NUMBER,
        p_CURSOR IN OUT GA.REFCURSOR
        ) AS
-- ANSWER A RECORDSET CONTAINING THE LEGS FOR THE GIVEN TRANSACTION ID
BEGIN

	IF NOT CAN_READ('Scheduling') THEN
		ERRS.RAISE_NO_READ_MODULE('Scheduling');
	END IF;

        p_STATUS := GA.SUCCESS;

        OPEN p_CURSOR FOR
                SELECT *
                FROM TRANSACTION_PATH
                WHERE TRANSACTION_ID = p_TRANSACTION_ID
                ORDER BY LEG_NBR;

END GET_TRANSACTION_PATHS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_PATH_PROVIDER
	(
        p_PATH_ID IN NUMBER,
        p_LEG_NBR IN NUMBER,
        p_CA_ID IN NUMBER,
        p_TP_ID IN NUMBER,
        p_PSE_ID IN NUMBER,
        p_TP_PRODUCT_CODE IN VARCHAR2,
        p_TP_PATH_NAME IN VARCHAR2,
        p_TP_ASSIGNMENT_REF IN VARCHAR2,
        p_TP_PRODUCT_LEVEL IN VARCHAR2,
        p_MISC_INFO IN VARCHAR2,
        p_MISC_REF IN VARCHAR2
	) AS
-- CREATE OR UPDATE A TRANSACTION_PATH LEG FOR A TX_PATH
v_COUNT NUMBER;
BEGIN

	IF NOT CAN_WRITE('Scheduling') THEN
		ERRS.RAISE_NO_WRITE_MODULE('Scheduling');
	END IF;

        SELECT COUNT(*)
        INTO v_COUNT
        FROM PATH_PROVIDER
        WHERE PATH_ID = p_PATH_ID AND
              LEG_NBR = p_LEG_NBR;
-- UPDATE EXISTING RECORD
        IF v_COUNT > 0 THEN
                UPDATE PATH_PROVIDER SET
                        PATH_ID = p_PATH_ID,
                        LEG_NBR = p_LEG_NBR,
                        CA_ID = p_CA_ID,
                        TP_ID = p_TP_ID,
                        PSE_ID = p_PSE_ID,
                        TP_PRODUCT_CODE = p_TP_PRODUCT_CODE,
                        TP_PATH_NAME = p_TP_PATH_NAME,
                        TP_ASSIGNMENT_REF = p_TP_ASSIGNMENT_REF,
                        TP_PRODUCT_LEVEL = p_TP_PRODUCT_LEVEL,
                        MISC_INFO = p_MISC_INFO,
                        MISC_REF = p_MISC_REF
                WHERE PATH_ID = p_PATH_ID AND
                      LEG_NBR = p_LEG_NBR;
        ELSE
-- INSERT A NEW RECORD
                INSERT INTO PATH_PROVIDER (
                        PATH_ID,
                        LEG_NBR,
                        CA_ID,
                        TP_ID,
                        PSE_ID,
                        TP_PRODUCT_CODE,
                        TP_PATH_NAME,
                        TP_ASSIGNMENT_REF,
                        TP_PRODUCT_LEVEL,
                        MISC_INFO,
                        MISC_REF)
                VALUES (p_PATH_ID,
                        p_LEG_NBR,
                        p_CA_ID,
                        p_TP_ID,
                        p_PSE_ID,
                        p_TP_PRODUCT_CODE,
                        p_TP_PATH_NAME,
                        p_TP_ASSIGNMENT_REF,
                        p_TP_PRODUCT_LEVEL,
                        p_MISC_INFO,
                        p_MISC_REF);
	END IF;

END PUT_PATH_PROVIDER;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_TRANSACTION_PATH
	(
        p_TRANSACTION_ID IN NUMBER,
        p_LEG_NBR IN NUMBER,
        p_CA_ID IN NUMBER,
        p_TP_ID IN NUMBER,
        p_PSE_ID IN NUMBER,
        p_TP_PRODUCT_CODE IN VARCHAR2,
        p_TP_PATH_NAME IN VARCHAR2,
        p_TP_ASSIGNMENT_REF IN VARCHAR2,
        p_TP_PRODUCT_LEVEL IN VARCHAR2,
        p_MISC_INFO IN VARCHAR2,
        p_MISC_REF IN VARCHAR2
	) AS
-- CREATE OR UPDATE A TRANSACTION_PATH LEG FOR A TX_PATH
v_COUNT NUMBER;
BEGIN

	IF NOT CAN_WRITE('Scheduling') THEN
		ERRS.RAISE_NO_WRITE_MODULE('Scheduling');
	END IF;

        SELECT COUNT(*)
        INTO v_COUNT
        FROM TRANSACTION_PATH
        WHERE TRANSACTION_ID = p_TRANSACTION_ID AND
              LEG_NBR = p_LEG_NBR;
-- UPDATE EXISTING RECORD
        IF v_COUNT > 0 THEN
                UPDATE TRANSACTION_PATH SET
                        TRANSACTION_ID = p_TRANSACTION_ID,
                        LEG_NBR = p_LEG_NBR,
                        CA_ID = p_CA_ID,
                        TP_ID = p_TP_ID,
                        PSE_ID = p_PSE_ID,
                        TP_PRODUCT_CODE = p_TP_PRODUCT_CODE,
                        TP_PATH_NAME = p_TP_PATH_NAME,
                        TP_ASSIGNMENT_REF = p_TP_ASSIGNMENT_REF,
                        TP_PRODUCT_LEVEL = p_TP_PRODUCT_LEVEL,
                        MISC_INFO = p_MISC_INFO,
                        MISC_REF = p_MISC_REF
                WHERE TRANSACTION_ID = p_TRANSACTION_ID AND
                      LEG_NBR = p_LEG_NBR;
        ELSE
-- INSERT A NEW RECORD
                INSERT INTO TRANSACTION_PATH (
                        TRANSACTION_ID,
                        LEG_NBR,
                        CA_ID,
                        TP_ID,
                        PSE_ID,
                        TP_PRODUCT_CODE,
                        TP_PATH_NAME,
                        TP_ASSIGNMENT_REF,
                        TP_PRODUCT_LEVEL,
                        MISC_INFO,
                        MISC_REF)
                VALUES (p_TRANSACTION_ID,
                        p_LEG_NBR,
                        p_CA_ID,
                        p_TP_ID,
                        p_PSE_ID,
                        p_TP_PRODUCT_CODE,
                        p_TP_PATH_NAME,
                        p_TP_ASSIGNMENT_REF,
                        p_TP_PRODUCT_LEVEL,
                        p_MISC_INFO,
                        p_MISC_REF);
	END IF;

END PUT_TRANSACTION_PATH;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_VERSION_LIST
	(
	p_DOMAIN_NAME IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	IF NOT CAN_READ('Public') THEN
		ERRS.RAISE_NO_READ_MODULE('Public');
	END IF;

        p_STATUS := GA.SUCCESS;

        OPEN p_CURSOR FOR
			SELECT *
			FROM VERSION
			WHERE VERSION_DOMAIN = p_DOMAIN_NAME
			ORDER BY DECODE(VERSION_NAME, 'Base',HIGH_DATE,AS_OF_DATE) DESC;

END GET_VERSION_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_VERSION_STATUSES
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

     p_STATUS := GA.SUCCESS;

        OPEN p_CURSOR FOR
			SELECT DISTINCT VERSION.VERSION_STATUS
			FROM VERSION
			ORDER BY VERSION.VERSION_STATUS DESC;


END GET_VERSION_STATUSES;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_VERSION
	(
	o_OID OUT NUMBER,
	p_VERSION_DOMAIN IN VARCHAR2,
	p_VERSION_NAME IN VARCHAR2,
	p_VERSION_ALIAS IN VARCHAR2,
	p_VERSION_DESC IN VARCHAR2,
	p_VERSION_ID IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_UNTIL_DATE IN DATE,
	p_VERSION_STATUS IN VARCHAR2,
	p_VERSION_REQUESTOR IN VARCHAR2
	)
	AS


-- CREATE OR REPLACE AN ENTITY
-- ANSWER ITS OID, OR -1 IF THERE IS A DUPLICATE NAME

v_COUNT NUMBER := 0;
v_OID NUMBER;
v_INITIAL BOOLEAN;
v_UNTIL_DATE DATE;

CURSOR c_VERSION IS
    SELECT * FROM VERSION
	WHERE UPPER(VERSION_DOMAIN) = UPPER(LTRIM(RTRIM(p_VERSION_DOMAIN)))
	ORDER BY AS_OF_DATE DESC;

BEGIN

	IF NOT CAN_WRITE('Public') THEN
		ERRS.RAISE_NO_WRITE_MODULE('Public');
	END IF;

-- UPDATE AN EXISTING RECORD THAT HAS AN ASSIGNED OID

	IF p_VERSION_ID > 0 THEN

--DETERMINE IF THE SPECIFIED CASE-INSENSITIVE NAME IS CURRENTLY IN USE BY ANOTHER ENTITY
--SIGNAL A NAME COLLISION EXCEPTION WHEN THE NAME OF THE ENTITY IS CHANGED TO ONE IN USE

		SELECT COUNT(*)
		INTO v_COUNT
		FROM VERSION
		WHERE UPPER(VERSION_NAME) = UPPER(LTRIM(RTRIM(p_VERSION_NAME)))
			AND VERSION_ID <> p_VERSION_ID
			AND	UPPER(VERSION_DOMAIN) = UPPER(LTRIM(RTRIM(p_VERSION_DOMAIN)));
		IF v_COUNT = 0 THEN
			UPDATE VERSION SET
				VERSION_DOMAIN = LTRIM(RTRIM(p_VERSION_DOMAIN)),
				VERSION_NAME = LTRIM(RTRIM(NVL(p_VERSION_NAME,GA.UNDEFINED_ATTRIBUTE))),
				VERSION_ALIAS = LTRIM(RTRIM(NVL(p_VERSION_ALIAS,GA.UNDEFINED_ATTRIBUTE))),
				VERSION_DESC = LTRIM(RTRIM(NVL(p_VERSION_DESC,GA.UNDEFINED_ATTRIBUTE))),
				AS_OF_DATE = p_AS_OF_DATE,
				UNTIL_DATE = p_UNTIL_DATE,
				VERSION_STATUS = LTRIM(RTRIM(NVL(p_VERSION_STATUS,GA.UNDEFINED_ATTRIBUTE))),
				VERSION_REQUESTOR = LTRIM(RTRIM(NVL(p_VERSION_REQUESTOR,GA.UNDEFINED_ATTRIBUTE))),
				ENTRY_DATE = SYSDATE
			WHERE VERSION_ID = p_VERSION_ID;
			o_OID := p_VERSION_ID;
		ELSE
			o_OID := GA.DUPLICATE_ENTITY;
			RETURN;
		END IF;
	END IF;

-- INSERT A NEW RECORD AND ASSIGN IT A UNIQUE OID.

	IF p_VERSION_ID = 0 THEN

-- DETERMINE IF THE SPECIFIED CASE-INSENSITIVE NAME IS CURRENTLY IN USE BY ANOTHER ENTITY
-- SIGNAL A NAME COLLISION EXCEPTION WHEN THE SPECIFIED NAME OF THE ENTITY IS ONE IN USE


			SELECT COUNT(*)
			INTO v_COUNT
			FROM VERSION
			WHERE UPPER(VERSION_NAME) = UPPER(LTRIM(RTRIM(p_VERSION_NAME)))
			   AND UPPER(VERSION_DOMAIN) = UPPER(LTRIM(RTRIM(p_VERSION_DOMAIN)));


-- IF THE COUNT IS ZERO AN ENTITY WAS NOT FOUND, SO INSERT THE NEW ENTITY.
-- ASSIGN THE NEXT OBJECT IDENTIFICATION (OID) TO THE ENTITY

		IF v_COUNT = 0 THEN
			SELECT OID.NEXTVAL INTO v_OID FROM DUAL;
			INSERT INTO VERSION (
				VERSION_DOMAIN,
				VERSION_ID,
				VERSION_NAME,
				VERSION_ALIAS,
				VERSION_DESC,
				AS_OF_DATE,
				UNTIL_DATE,
				VERSION_STATUS,
				VERSION_REQUESTOR,
				ENTRY_DATE)
			VALUES (
				LTRIM(RTRIM(p_VERSION_DOMAIN)),
				v_OID,
				LTRIM(RTRIM(NVL(p_VERSION_NAME,GA.UNDEFINED_ATTRIBUTE))),
				LTRIM(RTRIM(NVL(p_VERSION_ALIAS,GA.UNDEFINED_ATTRIBUTE))),
				LTRIM(RTRIM(NVL(p_VERSION_DESC,GA.UNDEFINED_ATTRIBUTE))),
				p_AS_OF_DATE,
				p_UNTIL_DATE,
				LTRIM(RTRIM(NVL(p_VERSION_STATUS,GA.UNDEFINED_ATTRIBUTE))),
				LTRIM(RTRIM(NVL(p_VERSION_REQUESTOR,GA.UNDEFINED_ATTRIBUTE))),
				SYSDATE);
			o_OID := v_OID;
		ELSE
			o_OID := GA.DUPLICATE_ENTITY;
		END IF;
	END IF;

--Make sure all the versions are continuous.
	v_INITIAL := TRUE;
    FOR v_VERSION IN c_VERSION LOOP
		IF v_INITIAL THEN
			v_UNTIL_DATE := TO_DATE('12/31/9999','MM/DD/YYYY');
			v_INITIAL := FALSE;
		END IF;
		UPDATE VERSION
		SET UNTIL_DATE = GREATEST(v_UNTIL_DATE, v_VERSION.AS_OF_DATE)
		WHERE VERSION_ID = v_VERSION.VERSION_ID;
		v_UNTIL_DATE := ADD_SECONDS_TO_DATE(v_VERSION.AS_OF_DATE, -1);
	END LOOP;

END PUT_VERSION;

----------------------------------------------------------------------------------------------------
PROCEDURE VERSIONS
	(
	p_VERSION_DOMAIN IN VARCHAR2,
	p_FROM_DATE IN DATE,
	p_TO_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- ANSWER A RECORDSET CONTAINING THE VERSIONS FOR THE GIVEN DOMAIN IN THE GIVEN RANGE.

BEGIN

	IF NOT CAN_READ('Public') THEN
		ERRS.RAISE_NO_READ_MODULE('Public');
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		 SELECT * FROM VERSION
		 WHERE UPPER(VERSION_DOMAIN) = UPPER(LTRIM(RTRIM(p_VERSION_DOMAIN)))
		 	   AND AS_OF_DATE <= p_TO_DATE
			   AND (UNTIL_DATE >= p_FROM_DATE OR VERSION_ID < 0)
		 ORDER BY AS_OF_DATE;

END VERSIONS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_CURRENT_VERSION
    (
	p_VERSION_DOMAIN IN VARCHAR2,
	p_VERSION_NAME OUT VARCHAR2,
	p_VERSION_ID OUT NUMBER,
	p_AS_OF_DATE OUT DATE,
	p_STATUS OUT NUMBER
	) AS

-- ANSWER THE INFORMATION FOR THE VERSION AT THE CURRENT DATE

BEGIN

	IF NOT CAN_READ('Public') THEN
		ERRS.RAISE_NO_READ_MODULE('Public');
	END IF;

	p_STATUS := GA.SUCCESS;

	SELECT VERSION_NAME, VERSION_ID, AS_OF_DATE
	INTO p_VERSION_NAME, p_VERSION_ID, p_AS_OF_DATE
	FROM VERSION
	WHERE VERSION_DOMAIN = LTRIM(RTRIM(p_VERSION_DOMAIN))
		  AND AS_OF_DATE <= SYSDATE
		  AND UNTIL_DATE >= SYSDATE;

END GET_CURRENT_VERSION;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_VERSIONID_FROM_ASOFDATE
	(
	p_VERSION_DOMAIN IN VARCHAR2,
	p_AS_OF_DATE IN OUT DATE,
	p_UNTIL_DATE OUT DATE,
	p_VERSION_ID OUT NUMBER,
	p_STATUS OUT NUMBER
	) AS

-- ANSWER THE VERSION ID AT THE GIVEN DATE

v_AS_OF_DATE DATE;

BEGIN
	p_STATUS := GA.SUCCESS;

	SELECT VERSION_ID, AS_OF_DATE, UNTIL_DATE INTO p_VERSION_ID, v_AS_OF_DATE, p_UNTIL_DATE
      FROM VERSION
	WHERE VERSION_DOMAIN = LTRIM(RTRIM(p_VERSION_DOMAIN))
		  AND AS_OF_DATE <= p_AS_OF_DATE
		  AND UNTIL_DATE >= p_AS_OF_DATE;
	p_AS_OF_DATE := v_AS_OF_DATE;

END GET_VERSIONID_FROM_ASOFDATE;
----------------------------------------------------------------------------------------------------
PROCEDURE FIND_ACCOUNTS
	(
	p_SEARCH_COLUMN IN VARCHAR2,
	p_SEARCH_STRING IN VARCHAR2,
	p_MATCH_CASE IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS


BEGIN

	IF p_SEARCH_COLUMN = 'ACCOUNT_NAME' THEN
		OPEN p_CURSOR FOR
		SELECT ACCOUNT_ID, ACCOUNT_NAME, ACCOUNT_ALIAS, ACCOUNT_DISPLAY_NAME, ACCOUNT_EXTERNAL_IDENTIFIER, ACCOUNT_DUNS_NUMBER
		FROM ACCOUNT
		WHERE DECODE(p_MATCH_CASE,1,ACCOUNT_NAME,UPPER(ACCOUNT_NAME)) LIKE DECODE(p_MATCH_CASE,1,p_SEARCH_STRING,UPPER(p_SEARCH_STRING));
	ELSIF p_SEARCH_COLUMN = 'ACCOUNT_ALIAS' THEN
		OPEN p_CURSOR FOR
		SELECT ACCOUNT_ID, ACCOUNT_ALIAS, ACCOUNT_NAME, ACCOUNT_DISPLAY_NAME, ACCOUNT_EXTERNAL_IDENTIFIER, ACCOUNT_DUNS_NUMBER
		FROM ACCOUNT
		WHERE DECODE(p_MATCH_CASE,1,ACCOUNT_ALIAS,UPPER(ACCOUNT_ALIAS)) LIKE DECODE(p_MATCH_CASE,1,p_SEARCH_STRING,UPPER(p_SEARCH_STRING));
	ELSIF p_SEARCH_COLUMN = 'ACCOUNT_DISPLAY_NAME' THEN
		OPEN p_CURSOR FOR
		SELECT ACCOUNT_ID, ACCOUNT_DISPLAY_NAME, ACCOUNT_NAME, ACCOUNT_ALIAS, ACCOUNT_EXTERNAL_IDENTIFIER, ACCOUNT_DUNS_NUMBER
		FROM ACCOUNT
		WHERE DECODE(p_MATCH_CASE,1,ACCOUNT_DISPLAY_NAME,UPPER(ACCOUNT_DISPLAY_NAME)) LIKE DECODE(p_MATCH_CASE,1,p_SEARCH_STRING,UPPER(p_SEARCH_STRING));
	ELSIF p_SEARCH_COLUMN = 'ACCOUNT_EXTERNAL_IDENTIFIER' THEN
		OPEN p_CURSOR FOR
		SELECT ACCOUNT_ID, ACCOUNT_EXTERNAL_IDENTIFIER, ACCOUNT_NAME, ACCOUNT_ALIAS, ACCOUNT_DISPLAY_NAME, ACCOUNT_DUNS_NUMBER
		FROM ACCOUNT
		WHERE DECODE(p_MATCH_CASE,1,ACCOUNT_EXTERNAL_IDENTIFIER,UPPER(ACCOUNT_EXTERNAL_IDENTIFIER)) LIKE DECODE(p_MATCH_CASE,1,p_SEARCH_STRING,UPPER(p_SEARCH_STRING));
	ELSIF p_SEARCH_COLUMN = 'ACCOUNT_DUNS_NUMBER' THEN
		OPEN p_CURSOR FOR
		SELECT ACCOUNT_ID, ACCOUNT_DUNS_NUMBER, ACCOUNT_NAME, ACCOUNT_ALIAS, ACCOUNT_DISPLAY_NAME, ACCOUNT_EXTERNAL_IDENTIFIER
		FROM ACCOUNT
		WHERE DECODE(p_MATCH_CASE,1,ACCOUNT_DUNS_NUMBER,UPPER(ACCOUNT_DUNS_NUMBER)) LIKE DECODE(p_MATCH_CASE,1,p_SEARCH_STRING,UPPER(p_SEARCH_STRING));
	ELSIF p_SEARCH_COLUMN = 'EDC_ACCOUNT_NUMBER' THEN
		OPEN p_CURSOR FOR
		SELECT A.ACCOUNT_ID, B.EDC_ACCOUNT_NUMBER, A.ACCOUNT_NAME, A.ACCOUNT_ALIAS, A.ACCOUNT_DISPLAY_NAME, A.ACCOUNT_EXTERNAL_IDENTIFIER
		FROM ACCOUNT A, ACCOUNT_EDC B
		WHERE A.ACCOUNT_ID = B.ACCOUNT_ID
			AND DECODE(p_MATCH_CASE,1,B.EDC_ACCOUNT_NUMBER,UPPER(B.EDC_ACCOUNT_NUMBER)) LIKE DECODE(p_MATCH_CASE,1,p_SEARCH_STRING,UPPER(p_SEARCH_STRING));
	ELSIF p_SEARCH_COLUMN = 'ESP_ACCOUNT_NUMBER' THEN
		OPEN p_CURSOR FOR
		SELECT A.ACCOUNT_ID, B.ESP_ACCOUNT_NUMBER, A.ACCOUNT_NAME, A.ACCOUNT_ALIAS, A.ACCOUNT_DISPLAY_NAME, A.ACCOUNT_EXTERNAL_IDENTIFIER
		FROM ACCOUNT A, ACCOUNT_ESP B
		WHERE A.ACCOUNT_ID = B.ACCOUNT_ID
			AND DECODE(p_MATCH_CASE,1,B.ESP_ACCOUNT_NUMBER,UPPER(B.ESP_ACCOUNT_NUMBER)) LIKE DECODE(p_MATCH_CASE,1,p_SEARCH_STRING,UPPER(p_SEARCH_STRING));
	ELSIF p_SEARCH_COLUMN = 'ACCOUNT_GROUP' THEN
		OPEN p_CURSOR FOR
		SELECT A.ACCOUNT_ID, C.ACCOUNT_GROUP_NAME, B.ASSIGNMENT_CATEGORY, A.ACCOUNT_NAME, A.ACCOUNT_ALIAS, A.ACCOUNT_DISPLAY_NAME, A.ACCOUNT_EXTERNAL_IDENTIFIER
		FROM ACCOUNT A, ACCOUNT_GROUP_ASSIGNMENT B, ACCOUNT_GROUP C
		WHERE A.ACCOUNT_ID = B.ACCOUNT_ID
			AND B.ACCOUNT_GROUP_ID = C.ACCOUNT_GROUP_ID
			AND DECODE(p_MATCH_CASE,1,C.ACCOUNT_GROUP_NAME,UPPER(C.ACCOUNT_GROUP_NAME)) LIKE DECODE(p_MATCH_CASE,1,p_SEARCH_STRING,UPPER(p_SEARCH_STRING));
	END IF;




END FIND_ACCOUNTS;
----------------------------------------------------------------------------------------------------
PROCEDURE DATA_EXCHANGE_TYPES
	(
	p_MODULE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- ANSWER A RECORDSET CONTAINING THE DATA EXCHANGE TYPES DEFINED IN THE DATABASE.
-- 9/27/2004 - PBM - This proc is for use with the old VB only. The new java gui
-- uses the GET_DATA_EXCHANGE_TYPES proc

BEGIN

	IF NOT CAN_READ('Public') THEN
		ERRS.RAISE_NO_READ_MODULE('Public');
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		  SELECT DISTINCT VALUE, 0, 0 "USE_ASP"
		  FROM SYSTEM_DICTIONARY
		  WHERE UPPER(MODULE) = 'DATA EXCHANGE'
		      AND ( (UPPER(KEY1) = UPPER(p_MODULE))
			   		OR
					(KEY1 = '?' AND UPPER(SETTING_NAME) = UPPER(p_MODULE))
				  )
          UNION ALL
		  SELECT DISTINCT VALUE, 0, 1 "USE_ASP"
		  FROM SYSTEM_DICTIONARY
		  WHERE UPPER(MODULE) = 'DATA EXCHANGE ASP'
		      AND ( (UPPER(KEY1) = UPPER(p_MODULE))
			   		OR
					(KEY1 = '?' AND UPPER(SETTING_NAME) = UPPER(p_MODULE))
				  )
		  ORDER BY 1;

END DATA_EXCHANGE_TYPES;
----------------------------------------------------------------------------------------------------

PROCEDURE RTO_ROLLUPS
	(
	p_ROLLUP_CATEGORY IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- ANSWER A RECORDSET CONTAINING THE DATA EXCHANGE TYPES DEFINED IN THE DATABASE.

BEGIN

	IF NOT CAN_READ('Public') THEN
		ERRS.RAISE_NO_READ_MODULE('Public');
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		  SELECT ROLLUP_NAME, ROLLUP_ID
		  FROM RTO_ROLLUP
		  WHERE UPPER(ROLLUP_CATEGORY) = UPPER(p_ROLLUP_CATEGORY)
		      AND ROLLUP_ID > 0
				AND ROLLUP_CHILDREN = 0
		  ORDER BY 1;

END RTO_ROLLUPS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SYSTEM_DICTIONARY_VALUE
	(
	p_MODEL_ID IN NUMBER,
	p_MODULE IN VARCHAR2,
	p_KEY1 IN VARCHAR2,
	p_KEY2 IN VARCHAR2,
	p_KEY3 IN VARCHAR2,
	p_SETTING_NAME IN VARCHAR2,
	p_VALUE OUT VARCHAR2
	) AS

BEGIN

	p_VALUE := GET_DICTIONARY_VALUE(p_SETTING_NAME, p_MODEL_ID, p_MODULE, p_KEY1, p_KEY2, p_KEY3);

END GET_SYSTEM_DICTIONARY_VALUE;
----------------------------------------------------------------------------------------------------
PROCEDURE SYSTEM_DICTIONARY_VALUES
	(
	p_MODEL_ID IN NUMBER,
	p_KEY1 IN VARCHAR2,
	p_KEY2 IN VARCHAR2,
	p_KEY3 IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- ANSWER A RECORDSET CONTAINING WHAT'S IN THE SYSTEM DICTIONARY.

v_MODULE VARCHAR2(64);
v_KEY1 VARCHAR2(64);
v_KEY2 VARCHAR2(64);
v_KEY3 VARCHAR2(64);
v_SETTING_NAME VARCHAR2(64);
BEGIN

	IF NOT CAN_READ('Public') THEN
		ERRS.RAISE_NO_READ_MODULE('Public');
	END IF;

	p_STATUS := GA.SUCCESS;

	TRANSLATE_OLD_DICTIONARY_KEYS(p_KEY1,p_KEY2,p_KEY3,v_MODULE,v_KEY1,v_KEY2,v_KEY3,v_SETTING_NAME);

	OPEN p_CURSOR FOR
		  SELECT MODEL_ID,
		  	CASE WHEN MODULE='?' THEN SETTING_NAME
				 ELSE MODULE END "KEY1",
		  	CASE WHEN MODULE='?' THEN '?'
				 WHEN KEY1='?' THEN SETTING_NAME
				 ELSE KEY1 END "KEY2",
		  	CASE WHEN KEY1='?' THEN '?'
				 ELSE SETTING_NAME END "KEY3",
			VALUE
		  FROM SYSTEM_DICTIONARY
		  WHERE (p_MODEL_ID = -1 OR MODEL_ID = p_MODEL_ID)
		  	  AND MODULE LIKE v_MODULE
		  	  AND KEY1 LIKE v_KEY1
			  AND KEY2 LIKE v_KEY2
			  AND KEY3 LIKE v_KEY3
			  AND SETTING_NAME LIKE v_SETTING_NAME
		  ORDER BY 1,2,3,4;

END SYSTEM_DICTIONARY_VALUES;
----------------------------------------------------------------------------------------------------
PROCEDURE SYSTEM_DICTIONARY_VALUES_E
	(
	p_MODEL_ID IN NUMBER,
	p_MODULE IN VARCHAR2,
	p_KEY1 IN VARCHAR2,
	p_KEY2 IN VARCHAR2,
	p_KEY3 IN VARCHAR2,
	p_SETTING_NAME IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- ANSWER A RECORDSET CONTAINING WHAT'S IN THE SYSTEM DICTIONARY.

BEGIN

	IF NOT CAN_READ('Public') THEN
		ERRS.RAISE_NO_READ_MODULE('Public');
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		  SELECT MODEL_ID,
			  	MODULE,
				KEY1,
				KEY2,
				KEY3,
				SETTING_NAME,
				VALUE
		  FROM SYSTEM_DICTIONARY
		  WHERE (p_MODEL_ID = -1 OR MODEL_ID = p_MODEL_ID)
		  	  AND MODULE LIKE p_MODULE
		  	  AND KEY1 LIKE p_KEY1
			  AND KEY2 LIKE p_KEY2
			  AND KEY3 LIKE p_KEY3
			  AND SETTING_NAME LIKE p_SETTING_NAME
		  ORDER BY 1,2,3,4,5,6;

END SYSTEM_DICTIONARY_VALUES_E;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_SYSTEM_DICTIONARY_VALUE
	(
	p_MODEL_ID IN NUMBER,
	p_KEY1 IN VARCHAR,
	p_KEY2 IN VARCHAR,
	p_KEY3 IN VARCHAR,
	p_VALUE IN VARCHAR,
	p_STATUS OUT VARCHAR
	) AS

BEGIN
	PUT_MODEL_VALUE_AT_KEY(p_MODEL_ID,p_KEY1,p_KEY2,p_KEY3,p_VALUE);

END PUT_SYSTEM_DICTIONARY_VALUE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_SYSTEM_DICTIONARY_VALUE_E
	(
	p_MODEL_ID IN NUMBER,
	p_MODULE IN VARCHAR,
	p_KEY1 IN VARCHAR,
	p_KEY2 IN VARCHAR,
	p_KEY3 IN VARCHAR,
	p_SETTING_NAME IN VARCHAR,
	p_VALUE IN VARCHAR,
	p_STATUS OUT VARCHAR
	) AS

BEGIN
	PUT_DICTIONARY_VALUE(p_SETTING_NAME, p_VALUE, p_MODEL_ID, p_MODULE, p_KEY1, p_KEY2, p_KEY3);

END PUT_SYSTEM_DICTIONARY_VALUE_E;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_LINK
	(
	p_LINK_NAME IN VARCHAR,
	p_LINK_URL IN VARCHAR,
	p_OLD_LINK_NAME IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS
BEGIN

	IF NOT CAN_WRITE('Public') THEN
		ERRS.RAISE_NO_WRITE_MODULE('Public');
	END IF;

-- UPDATE AN EXISTING RECORD
	UPDATE SYSTEM_DICTIONARY SET
		VALUE = LTRIM(RTRIM(NVL(p_LINK_URL, GA.UNDEFINED_ATTRIBUTE))),
		SETTING_NAME = LTRIM(RTRIM(NVL(p_LINK_NAME, GA.UNDEFINED_ATTRIBUTE)))
	WHERE MODEL_ID = 0
		AND MODULE = 'System'
		AND KEY1 = 'Link'
		AND KEY2 = '?' AND KEY3 = '?'
		AND SETTING_NAME = LTRIM(RTRIM(p_OLD_LINK_NAME));

-- IF THE PREVIOUS UPDATE DID NOT FIND A MATCH, THEN INSERT A NEW RECORD
	IF SQL%NOTFOUND THEN
		INSERT INTO SYSTEM_DICTIONARY (
			MODEL_ID,
			MODULE,
			KEY1,
			KEY2,
			KEY3,
			SETTING_NAME,
			VALUE)
		VALUES (
			0,
			'System',
			'Link',
			'?',
			'?',
			LTRIM(RTRIM(NVL(p_LINK_NAME, GA.UNDEFINED_ATTRIBUTE))),
			LTRIM(RTRIM(NVL(p_LINK_URL, GA.UNDEFINED_ATTRIBUTE))));
	END IF;

END PUT_LINK;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_DST_OPTIONS
	(
	p_DST_SPRING_AHEAD_OPTION OUT VARCHAR,
	p_DST_FALL_BACK_OPTION OUT VARCHAR
	)
	AS

--DST_SPRING_AHEAD_OPTION CHAR(1) := 'A'; -- Conversion from a 24 hour pattern to a 23 hour pattern: A-Ignore hour 2:00 AM, B-Ignore hour 3:00 AM, C-Ignore hour 24:00 PM.
--DST_FALL_BACK_OPTION CHAR(1) := 'A'; -- Conversion from a 24 hour pattern to a 25 hour pattern: A-repeat hour 2:00 AM, B-Use first 24 hours and supply a zero for hour 25.
BEGIN

	p_DST_SPRING_AHEAD_OPTION := GA.DST_SPRING_AHEAD_OPTION;
	p_DST_FALL_BACK_OPTION := GA.DST_FALL_BACK_OPTION;


END GET_DST_OPTIONS;
----------------------------------------------------------------------------------------------------
PROCEDURE CASE_LABELS
	(
	p_CASE_CATEGORY IN VARCHAR2,
	p_INCLUDE_ALL IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

    CASE_LABELS_FILTERED(p_CASE_CATEGORY,
                p_INCLUDE_ALL,
                0,
                p_STATUS,
                p_CURSOR);

END CASE_LABELS;
----------------------------------------------------------------------------------------------------
PROCEDURE CASE_LABELS_FILTERED
	(
	p_CASE_CATEGORY IN VARCHAR2,
	p_INCLUDE_ALL IN NUMBER,
    p_HIDE_NOT_ASSIGNED IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the CASE LABELS for the given CATEGORY

BEGIN

	IF NOT CAN_READ('Public') THEN
		ERRS.RAISE_NO_READ_MODULE('Public');
	END IF;

-- Bugfix 6119 - ABG - Added the last column to make base the default option, and then sort
-- alphebetically after that.  Since this column isn't grabbed by the VB code, it is meaningless
-- to it.

    p_STATUS := GA.SUCCESS;
	OPEN p_CURSOR FOR
	    SELECT CASE_NAME, CASE_ID, CASE_ALIAS, CASE_DESC, ENTRY_DATE, DECODE(CASE_ID, 1, 0, 1)
		 FROM CASE_LABEL
		WHERE (UPPER(CASE_CATEGORY) = UPPER(LTRIM(RTRIM(p_CASE_CATEGORY)))
			OR UPPER(CASE_CATEGORY) = DECODE(p_INCLUDE_ALL, 1, 'ALL', '@'))
            AND (NVL(p_HIDE_NOT_ASSIGNED,0) = 0 OR CASE_ID <> CONSTANTS.NOT_ASSIGNED)
		ORDER BY 6, 1;

END CASE_LABELS_FILTERED;
---------------------------------------------------------------------------------------------------
PROCEDURE SCENARIOS
	(
	p_SCENARIO_CATEGORY IN VARCHAR2,
	p_INCLUDE_ALL IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the CASE LABELS for the given CATEGORY

BEGIN

	IF NOT CAN_READ('Public') THEN
		ERRS.RAISE_NO_READ_MODULE('Public');
	END IF;

    p_STATUS := GA.SUCCESS;
	OPEN p_CURSOR FOR
	    SELECT SCENARIO_NAME, SCENARIO_ID, SCENARIO_ALIAS, SCENARIO_DESC, ENTRY_DATE
		 FROM SCENARIO
		WHERE (UPPER(SCENARIO_CATEGORY) = UPPER(LTRIM(RTRIM(p_SCENARIO_CATEGORY)))
			OR UPPER(SCENARIO_CATEGORY) = DECODE(p_INCLUDE_ALL, 1, 'ALL', '@'))
		ORDER BY 1;

END SCENARIOS;
---------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNT_STATUSES
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the ACCOUNT_STATUSES

BEGIN

	IF NOT CAN_READ('Public') THEN
		ERRS.RAISE_NO_READ_MODULE('Public');
	END IF;

    p_STATUS := GA.SUCCESS;
	OPEN p_CURSOR FOR
	    SELECT STATUS_NAME, IS_ACTIVE
		 FROM ACCOUNT_STATUS_NAME
		ORDER BY 1;

END ACCOUNT_STATUSES;
---------------------------------------------------------------------------------------------------
-- While Load Forecast Scenarios are now associated with account_status_names via a link
-- table now, we used to use a comma delimited list. We continue to support this format in the
-- VB.  This function gets a comma delimited list of status names given a scenario id
FUNCTION GET_SCENARIO_STATUS_LIST
	(
	p_SCENARIO_ID IN NUMBER
	) RETURN VARCHAR2 IS

CURSOR curr_STATUS_NAMES IS
SELECT STATUS.STATUS_NAME
FROM LOAD_FORECAST_SCENARIO_STATUS STATUS
WHERE STATUS.SCENARIO_ID = p_SCENARIO_ID;

v_STATUS_ROW curr_STATUS_NAMES%ROWTYPE;

v_STATUS_LIST VARCHAR2(500) := NULL;

BEGIN

	FOR v_STATUS_ROW IN curr_STATUS_NAMES LOOP
		IF v_STATUS_LIST IS NULL THEN
			v_STATUS_LIST := v_STATUS_ROW.STATUS_NAME;
		ELSE
			v_STATUS_LIST := ',' || v_STATUS_ROW.STATUS_NAME;
		END IF;
	END LOOP;

	RETURN v_STATUS_LIST;

END GET_SCENARIO_STATUS_LIST;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_LOAD_FORECAST_SCENARIO
	(
	p_SCENARIO_ID IN NUMBER,
	p_WEATHER_CASE_ID OUT NUMBER,
	p_AREA_LOAD_CASE_ID OUT NUMBER,
	p_ENROLLMENT_CASE_ID OUT NUMBER,
	p_CALENDAR_CASE_ID OUT NUMBER,
	p_USAGE_FACTOR_CASE_ID OUT NUMBER,
	p_GROWTH_FACTOR_CASE_ID OUT NUMBER,
	p_LOSS_FACTOR_CASE_ID OUT NUMBER,
	p_RUN_MODE OUT NUMBER,
	p_SCENARIO_USE_DAY_TYPE OUT NUMBER,
	p_ACCOUNT_STATUS_LIST OUT VARCHAR,
	p_STATUS OUT NUMBER
	)
	AS

-- ANSWER THE SINGLETON INSTANCE OF THE ENTITY IDENTIFIED BY THE SPECIFIED OID
-- ANSWER NULL VALUES IF THE ENTITY CANNOT BE FOUND

v_RECORD LOAD_FORECAST_SCENARIO%ROWTYPE;
v_NONE_CASE_ID NUMBER(1) := 0;

BEGIN

--MAKE SURE USER HAS APPROPRIATE ACCESS

	IF NOT CAN_READ('Forecasting') THEN
		ERRS.RAISE_NO_READ_MODULE('Forecasting');
	END IF;

--SELECT THE EXISTING RECORD

	SELECT *
	INTO v_RECORD
	FROM LOAD_FORECAST_SCENARIO
	WHERE SCENARIO_ID = p_SCENARIO_ID;

--SET THE OUTPUT PARAMETERS OF THE PROCEDURE
	p_WEATHER_CASE_ID := v_RECORD.WEATHER_CASE_ID;
	p_AREA_LOAD_CASE_ID := v_RECORD.AREA_LOAD_CASE_ID;
	p_ENROLLMENT_CASE_ID := v_RECORD.ENROLLMENT_CASE_ID;
	p_CALENDAR_CASE_ID := v_RECORD.CALENDAR_CASE_ID;
	p_USAGE_FACTOR_CASE_ID := v_RECORD.USAGE_FACTOR_CASE_ID;
	p_GROWTH_FACTOR_CASE_ID := v_RECORD.GROWTH_FACTOR_CASE_ID;
	p_LOSS_FACTOR_CASE_ID := v_RECORD.LOSS_FACTOR_CASE_ID;
	p_RUN_MODE := v_RECORD.RUN_MODE;
	p_SCENARIO_USE_DAY_TYPE := v_RECORD.SCENARIO_USE_DAY_TYPE;
	p_ACCOUNT_STATUS_LIST := GET_SCENARIO_STATUS_LIST(p_SCENARIO_ID);


	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			p_WEATHER_CASE_ID := v_NONE_CASE_ID;
			p_AREA_LOAD_CASE_ID := v_NONE_CASE_ID;
			p_ENROLLMENT_CASE_ID := v_NONE_CASE_ID;
			p_CALENDAR_CASE_ID := v_NONE_CASE_ID;
			p_USAGE_FACTOR_CASE_ID := v_NONE_CASE_ID;
			p_GROWTH_FACTOR_CASE_ID := v_NONE_CASE_ID;
			p_LOSS_FACTOR_CASE_ID := v_NONE_CASE_ID;
			p_RUN_MODE := 0;
			p_SCENARIO_USE_DAY_TYPE := 0;
			p_ACCOUNT_STATUS_LIST := '';

END GET_LOAD_FORECAST_SCENARIO;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_LOAD_FORECAST_SCENARIO
	(
	p_SCENARIO_ID IN NUMBER,
	p_WEATHER_CASE_ID IN NUMBER,
	p_AREA_LOAD_CASE_ID IN NUMBER,
	p_ENROLLMENT_CASE_ID IN NUMBER,
	p_CALENDAR_CASE_ID IN NUMBER,
	p_USAGE_FACTOR_CASE_ID IN NUMBER,
	p_GROWTH_FACTOR_CASE_ID IN NUMBER,
	p_LOSS_FACTOR_CASE_ID IN NUMBER,
	p_RUN_MODE IN NUMBER,
	p_SCENARIO_USE_DAY_TYPE IN NUMBER,
	p_ACCOUNT_STATUS_LIST IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

	v_STATUS_NAMES STRING_COLLECTION;
	v_INDEX NUMBER(9) := 0;
	v_STATUS_NAME_EXISTS NUMBER(9);

BEGIN

	IF NOT CAN_WRITE('Forecasting') THEN
		ERRS.RAISE_NO_WRITE_MODULE('Forecasting');
	END IF;

-- UPDATE AN EXISTING RECORD
	UPDATE LOAD_FORECAST_SCENARIO SET
		WEATHER_CASE_ID = p_WEATHER_CASE_ID,
		AREA_LOAD_CASE_ID = p_AREA_LOAD_CASE_ID,
		ENROLLMENT_CASE_ID = p_ENROLLMENT_CASE_ID,
		CALENDAR_CASE_ID = p_CALENDAR_CASE_ID,
		USAGE_FACTOR_CASE_ID = p_USAGE_FACTOR_CASE_ID,
		GROWTH_FACTOR_CASE_ID = p_GROWTH_FACTOR_CASE_ID,
		LOSS_FACTOR_CASE_ID = p_LOSS_FACTOR_CASE_ID,
		RUN_MODE = p_RUN_MODE,
		SCENARIO_USE_DAY_TYPE = p_SCENARIO_USE_DAY_TYPE,
		ENTRY_DATE = SYSDATE
	WHERE SCENARIO_ID = p_SCENARIO_ID;

-- IF THE PREVIOUS UPDATE DID NOT FIND A MATCH, THEN INSERT A NEW RECORD
	IF SQL%NOTFOUND THEN
		INSERT INTO LOAD_FORECAST_SCENARIO (
			SCENARIO_ID,
			WEATHER_CASE_ID,
			AREA_LOAD_CASE_ID,
			ENROLLMENT_CASE_ID,
			CALENDAR_CASE_ID,
			USAGE_FACTOR_CASE_ID,
			LOSS_FACTOR_CASE_ID,
			GROWTH_FACTOR_CASE_ID,
			RUN_MODE,
			SCENARIO_USE_DAY_TYPE,
			ENTRY_DATE)
		VALUES (
			p_SCENARIO_ID,
			p_WEATHER_CASE_ID,
			p_AREA_LOAD_CASE_ID,
			p_ENROLLMENT_CASE_ID,
			p_CALENDAR_CASE_ID,
			p_USAGE_FACTOR_CASE_ID,
			p_LOSS_FACTOR_CASE_ID,
			p_GROWTH_FACTOR_CASE_ID,
			p_RUN_MODE,
			p_SCENARIO_USE_DAY_TYPE,
			SYSDATE);
	END IF;

	IF NVL(p_ACCOUNT_STATUS_LIST, '?') != SP.IGNORE_LIST THEN
		-- FIRST CLEAR OUT THE STATUSES
		DELETE FROM LOAD_FORECAST_SCENARIO_STATUS STATUS
		WHERE STATUS.SCENARIO_ID = p_SCENARIO_ID;

		IF p_ACCOUNT_STATUS_LIST != NULL THEN
			UT.STRING_COLLECTION_FROM_STRING(p_ACCOUNT_STATUS_LIST, ',', v_STATUS_NAMES);

			v_INDEX := v_STATUS_NAMES.FIRST;

			LOOP
			EXIT WHEN NOT v_STATUS_NAMES.EXISTS(v_INDEX);

				SELECT COUNT(1) INTO v_STATUS_NAME_EXISTS
				FROM ACCOUNT_STATUS_NAME NAMES
				WHERE NAMES.STATUS_NAME = v_STATUS_NAMES(v_INDEX);

				IF V_STATUS_NAME_EXISTS > 0 THEN
					INSERT INTO LOAD_FORECAST_SCENARIO_STATUS (SCENARIO_ID, STATUS_NAME)
					VALUES ( p_SCENARIO_ID, v_STATUS_NAMES(v_INDEX));
				ELSE
					ERRS.RAISE_BAD_ARGUMENT('p_ACCOUNT_STATUS_LIST', v_STATUS_NAMES(v_INDEX) || ' is not a valid account status name.');
				END IF;

				v_INDEX := v_STATUS_NAMES.NEXT(v_INDEX);
			END LOOP;
		END IF;

	END IF;

END PUT_LOAD_FORECAST_SCENARIO;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SYSTEM_LABELS
	(
	p_MODEL_ID IN NUMBER,
	p_MODULE IN VARCHAR,
	p_KEY1 IN VARCHAR,
	p_KEY2 IN VARCHAR,
	p_KEY3 IN VARCHAR,
	p_INCLUDE_HIDDEN IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

--c_Wildcard CHAR(1) := '%';

-- Answer a the values from the SYSTEM_LABEL tables matching the given keys or wildcards.

BEGIN

	IF NOT CAN_READ('Public') THEN
		ERRS.RAISE_NO_READ_MODULE('Public');
	END IF;

	p_STATUS := GA.SUCCESS;

    --Note: Make case-insensitive
	OPEN p_CURSOR FOR
		  SELECT MODEL_ID, MODULE, KEY1, KEY2, KEY3, VALUE, NVL(IS_DEFAULT,0) AS IS_DEFAULT, NVL(IS_HIDDEN,0) AS IS_HIDDEN, POSITION, CODE
		  FROM SYSTEM_LABEL
		  WHERE (p_MODEL_ID = -1 OR MODEL_ID = p_MODEL_ID OR MODEL_ID = 0)
			  AND (p_MODULE = '%' OR UPPER(MODULE) = UPPER(p_MODULE))
		  	  AND UPPER(KEY1) LIKE UPPER(NVL(p_KEY1,CONSTANTS.UNDEFINED_ATTRIBUTE))
			  AND UPPER(KEY2) LIKE UPPER(NVL(p_KEY2,CONSTANTS.UNDEFINED_ATTRIBUTE))
			  AND UPPER(KEY3) LIKE UPPER(NVL(p_KEY3,CONSTANTS.UNDEFINED_ATTRIBUTE))
			  AND (IS_HIDDEN = 0 OR IS_HIDDEN IS NULL OR p_INCLUDE_HIDDEN = 1)
		  ORDER BY MODEL_ID, MODULE, KEY1, KEY2, KEY3, POSITION ;

END GET_SYSTEM_LABELS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SYSTEM_LABEL_VALUES
	(
	p_MODEL_ID IN NUMBER,
	p_MODULE IN VARCHAR,
	p_KEY1 IN VARCHAR,
	p_KEY2 IN VARCHAR,
	p_KEY3 IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
   v_IGNORE_POSITION  NUMBER(1) := 0;
BEGIN
   GET_SYSTEM_LABEL_VALUES_EX (
      p_MODEL_ID,
      p_MODULE,
      p_KEY1,
      p_KEY2,
      p_KEY3,
      p_STATUS,
      p_CURSOR,
      v_IGNORE_POSITION);
END GET_SYSTEM_LABEL_VALUES;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SYSTEM_LABEL_VALUES_EX (
	p_MODEL_ID        IN NUMBER,
	p_MODULE          IN VARCHAR,
	p_KEY1            IN VARCHAR,
	p_KEY2            IN VARCHAR,
	p_KEY3            IN VARCHAR,
	p_STATUS             OUT NUMBER,
	p_CURSOR          IN OUT GA.REFCURSOR,
   p_IGNORE_POSITION IN NUMBER
	) AS

-- Answer: the values from the SYSTEM_LABEL tables matching the given keys.

BEGIN

	IF NOT CAN_READ('Public') THEN
		ERRS.RAISE_NO_READ_MODULE('Public');
	END IF;

	p_STATUS := GA.SUCCESS;

   -- Based on the parameter p_IGNORE_POSITION
   -- apply the appropriate ordering.
   -- 0 - use POSITION
   -- 1 - use VALUE
   CASE p_IGNORE_POSITION
      WHEN 0 THEN
         --Note: Make case-insensitive
         OPEN p_CURSOR FOR
              SELECT VALUE
              FROM SYSTEM_LABEL
              WHERE (p_MODEL_ID = -1 OR MODEL_ID = p_MODEL_ID OR MODEL_ID = 0)
                 AND UPPER(MODULE) = UPPER(p_MODULE)
                 AND UPPER(KEY1) = UPPER(NVL(p_KEY1,CONSTANTS.UNDEFINED_ATTRIBUTE))
                 AND UPPER(KEY2) = UPPER(NVL(p_KEY2,CONSTANTS.UNDEFINED_ATTRIBUTE))
                 AND UPPER(KEY3) = UPPER(NVL(p_KEY3,CONSTANTS.UNDEFINED_ATTRIBUTE))
                 AND NVL(IS_HIDDEN,0) = 0
              ORDER BY POSITION;
      ELSE
         OPEN p_CURSOR FOR
              SELECT VALUE
              FROM SYSTEM_LABEL
              WHERE (p_MODEL_ID = -1 OR MODEL_ID = p_MODEL_ID OR MODEL_ID = 0)
                 AND UPPER(MODULE) = UPPER(p_MODULE)
                 AND UPPER(KEY1) = UPPER(NVL(p_KEY1,CONSTANTS.UNDEFINED_ATTRIBUTE))
                 AND UPPER(KEY2) = UPPER(NVL(p_KEY2,CONSTANTS.UNDEFINED_ATTRIBUTE))
                 AND UPPER(KEY3) = UPPER(NVL(p_KEY3,CONSTANTS.UNDEFINED_ATTRIBUTE))
                 AND NVL(IS_HIDDEN,0) = 0
              ORDER BY VALUE;
   END CASE;

END GET_SYSTEM_LABEL_VALUES_EX;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SYSTEM_LABEL_VALUES_ALL
	(
	p_MODEL_ID IN NUMBER,
	p_MODULE IN VARCHAR,
	p_KEY1 IN VARCHAR,
	p_KEY2 IN VARCHAR,
	p_KEY3 IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a the values from the SYSTEM_LABEL tables matching the given keys.

BEGIN

	IF NOT CAN_READ('Public') THEN
		ERRS.RAISE_NO_READ_MODULE('Public');
	END IF;

	p_STATUS := GA.SUCCESS;

    --Note: Make case-insensitive
	OPEN p_CURSOR FOR
          SELECT g_ALL_STRING FROM DUAL
          UNION ALL
		  SELECT S.VALUE
		  FROM SYSTEM_LABEL S
          WHERE (p_MODEL_ID = -1 OR S.MODEL_ID = p_MODEL_ID OR S.MODEL_ID = 0)
			  AND UPPER(S.MODULE) = UPPER(p_MODULE)
		  	  AND UPPER(KEY1) = UPPER(NVL(p_KEY1,CONSTANTS.UNDEFINED_ATTRIBUTE))
			  AND UPPER(KEY2) = UPPER(NVL(p_KEY2,CONSTANTS.UNDEFINED_ATTRIBUTE))
			  AND UPPER(KEY3) = UPPER(NVL(p_KEY3,CONSTANTS.UNDEFINED_ATTRIBUTE))
			  AND NVL(S.IS_HIDDEN,0) = 0
		  ORDER BY 1;

END GET_SYSTEM_LABEL_VALUES_ALL;
------------------------------------------------------------------------------------
PROCEDURE PUT_SYSTEM_LABELS
	(
	p_MODEL_ID IN NUMBER,
	p_MODULE IN VARCHAR,
	p_KEY1 IN VARCHAR,
	p_KEY2 IN VARCHAR,
	p_KEY3 IN VARCHAR,
	p_VALUE IN VARCHAR,
	p_POSITION IN NUMBER,
	p_IS_DEFAULT IN NUMBER,
	p_IS_HIDDEN IN NUMBER,
	p_STATUS OUT VARCHAR
	) AS

BEGIN

	 PUT_SYSTEM_LABELS_WITH_CODE(p_MODEL_ID,p_MODULE,p_KEY1,p_KEY2,p_KEY3,p_VALUE,p_POSITION,p_IS_DEFAULT,
          p_IS_HIDDEN,'',p_STATUS);

END PUT_SYSTEM_LABELS;
---------------------------------------------------------------------------------------------------------------
PROCEDURE ENSURE_SYSTEM_LABELS
	(
	p_MODEL_ID IN NUMBER,
	p_MODULE IN VARCHAR,
	p_KEY1 IN VARCHAR,
	p_KEY2 IN VARCHAR,
	p_KEY3 IN VARCHAR,
	p_VALUE IN VARCHAR,
	p_POSITION IN NUMBER,
	p_IS_DEFAULT IN NUMBER,
	p_IS_HIDDEN IN NUMBER
	) AS

v_POSITION NUMBER;
v_COUNT NUMBER;
v_STATUS VARCHAR(1);
BEGIN

	v_POSITION := p_POSITION;

	IF SYSTEM_LABEL_CONTAINS(p_MODEL_ID,p_MODULE,p_KEY1,p_KEY2,p_KEY3,p_VALUE) THEN
		RETURN;
	END IF;

	 IF v_POSITION IS NULL THEN
	    SELECT NVL(MAX(POSITION),-1)+1
	    INTO v_POSITION
	    FROM SYSTEM_LABEL
	    WHERE MODEL_ID = p_MODEL_ID
		AND MODULE = p_MODULE
		AND KEY1 = p_KEY1
		AND KEY2 = p_KEY2
		AND KEY3 = p_KEY3;
	END IF;

	 PUT_SYSTEM_LABELS_WITH_CODE(p_MODEL_ID,p_MODULE,p_KEY1,p_KEY2,p_KEY3,p_VALUE,v_POSITION,p_IS_DEFAULT,
          p_IS_HIDDEN,'',v_STATUS);

END ENSURE_SYSTEM_LABELS;
---------------------------------------------------------------------------------------------------------------
PROCEDURE PUT_SYSTEM_LABELS_WITH_CODE
	(
	p_MODEL_ID IN NUMBER,
	p_MODULE IN VARCHAR,
	p_KEY1 IN VARCHAR,
	p_KEY2 IN VARCHAR,
	p_KEY3 IN VARCHAR,
	p_VALUE IN VARCHAR,
	p_POSITION IN NUMBER,
	p_IS_DEFAULT IN NUMBER,
	p_IS_HIDDEN IN NUMBER,
	p_CODE IN VARCHAR,
	p_STATUS OUT VARCHAR
	) AS

BEGIN

	IF NOT CAN_WRITE('Admin') THEN
		ERRS.RAISE_NO_WRITE_MODULE('Admin');
	END IF;

	p_STATUS := GA.SUCCESS;

    --Note: Make case-insensitive, but Update MODULE and KEYs to be able to change case
	UPDATE SYSTEM_LABEL
	SET VALUE = p_VALUE, POSITION = p_POSITION, MODULE = p_MODULE, KEY1 = p_KEY1, KEY2 = p_KEY2, KEY3 = p_KEY3, IS_DEFAULT = p_IS_DEFAULT, IS_HIDDEN = p_IS_HIDDEN, CODE = p_CODE
	WHERE MODEL_ID = p_MODEL_ID
		AND UPPER(MODULE) = UPPER(p_MODULE)
		AND UPPER(KEY1) LIKE UPPER(p_KEY1)
		AND UPPER(KEY2) LIKE UPPER(p_KEY2)
		AND UPPER(KEY3) LIKE UPPER(p_KEY3)
		AND POSITION = p_POSITION;


	IF SQL%NOTFOUND THEN

		INSERT INTO SYSTEM_LABEL(MODEL_ID,
			   					MODULE,
			   					KEY1,
								KEY2,
								KEY3,
								VALUE,
								POSITION,
								IS_DEFAULT,
								IS_HIDDEN,
								CODE)
						VALUES(p_MODEL_ID,
							   p_MODULE,
								p_KEY1,
								p_KEY2,
								p_KEY3,
								p_VALUE,
								p_POSITION,
								p_IS_DEFAULT,
								p_IS_HIDDEN,
								p_CODE);

	END IF;

END PUT_SYSTEM_LABELS_WITH_CODE;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_ENTITY_CONFIG_NODES
	(
	p_MODEL_ID IN NUMBER,
	p_MODULE IN VARCHAR,
	p_KEY1 IN VARCHAR,
	p_KEY2 IN VARCHAR,
	p_KEY3 IN VARCHAR,
	p_INCLUDE_HIDDEN IN NUMBER,
	p_OPTIONS IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a the values for keys to use as nodes for the ENTITY_CONFIG_DICTIONARY data, configured by the user.
-- For now, this will be the values from the SYSTEM_LABEL table matching the given keys or wildcards.

BEGIN

	IF NOT CAN_READ('Public') THEN
		ERRS.RAISE_NO_READ_MODULE('Public');
	END IF;

	p_STATUS := GA.SUCCESS;

    -- For now, just get the node keys from the SYSTEM_LABEL table
    GET_SYSTEM_LABELS
    	(
    	p_MODEL_ID,
    	p_MODULE,
    	p_KEY1,
    	p_KEY2,
    	p_KEY3,
    	p_INCLUDE_HIDDEN,
    	p_STATUS,
    	p_CURSOR
    	);

END GET_ENTITY_CONFIG_NODES;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_ENTITY_CONFIG_DICTIONARY
	(
	p_MODEL_ID IN NUMBER,
	p_MODULE IN VARCHAR,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_KEY1 IN VARCHAR,
	p_KEY2 IN VARCHAR,
	p_KEY3 IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

--c_Wildcard CHAR(1) := '%';

-- Answer a the values from the ENTITY_CONFIG_DICTIONARY tables matching the given keys or wildcards.

BEGIN

	IF NOT CAN_READ('Data Setup') THEN
		ERRS.RAISE_NO_READ_MODULE('Data Setup');
	END IF;

	p_STATUS := GA.SUCCESS;

    --Note: Make case-insensitive
	OPEN p_CURSOR FOR
		  SELECT MODEL_ID, MODULE, KEY1, KEY2, KEY3, VALUE
		  FROM ENTITY_CONFIG_DICTIONARY
		  WHERE (p_MODEL_ID = -1 OR MODEL_ID = p_MODEL_ID OR MODEL_ID = 0)
		  	  AND UPPER(KEY1) LIKE UPPER(p_KEY1)
			  AND UPPER(KEY2) LIKE UPPER(p_KEY2)
			  AND UPPER(KEY3) LIKE UPPER(p_KEY3)
			  AND (p_MODULE = '%' OR UPPER(MODULE) = UPPER(p_MODULE))
              AND (p_ENTITY_DOMAIN_ID = CONSTANTS.ALL_ID OR ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID)
              AND (p_ENTITY_ID = CONSTANTS.ALL_ID OR ENTITY_ID = p_ENTITY_ID)
		  ORDER BY MODEL_ID, MODULE, KEY1, KEY2, KEY3 ;

END GET_ENTITY_CONFIG_DICTIONARY;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ENTITY_CONFIG_DICTIONARY
	(
	p_MODEL_ID IN NUMBER,
	p_MODULE IN VARCHAR,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_KEY1 IN VARCHAR,
	p_KEY2 IN VARCHAR,
	p_KEY3 IN VARCHAR,
	p_VALUE IN VARCHAR,
	p_STATUS OUT VARCHAR
	) AS

BEGIN

	IF NOT CAN_WRITE('Data Setup') THEN
		ERRS.RAISE_NO_WRITE_MODULE('Data Setup');
	END IF;

	p_STATUS := GA.SUCCESS;

    --Note: Make case-insensitive, but Update MODULE and KEYs to be able to change case
	UPDATE ENTITY_CONFIG_DICTIONARY
	SET VALUE = p_VALUE,
        MODULE = p_MODULE,
        KEY1 = p_KEY1,
        KEY2 = p_KEY2,
        KEY3 = p_KEY3
	WHERE MODEL_ID = p_MODEL_ID
		AND ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID
		AND ENTITY_ID = p_ENTITY_ID
		AND UPPER(MODULE) = UPPER(p_MODULE)
		AND UPPER(KEY1) LIKE UPPER(p_KEY1)
		AND UPPER(KEY2) LIKE UPPER(p_KEY2)
		AND UPPER(KEY3) LIKE UPPER(p_KEY3);


	IF SQL%NOTFOUND THEN

		INSERT INTO ENTITY_CONFIG_DICTIONARY(MODEL_ID,
			   					MODULE,
								ENTITY_DOMAIN_ID,
								ENTITY_ID,
			   					KEY1,
								KEY2,
								KEY3,
								VALUE)
						VALUES(p_MODEL_ID,
							   p_MODULE,
								p_ENTITY_DOMAIN_ID,
								p_ENTITY_ID,
								p_KEY1,
								p_KEY2,
								p_KEY3,
								p_VALUE);

	END IF;

END PUT_ENTITY_CONFIG_DICTIONARY;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_PHONE_NUMBER
    (
	p_CONTACT_ID IN NUMBER,
	p_PHONE_TYPE IN VARCHAR,
	p_PHONE_NUMBER OUT VARCHAR
	) AS

BEGIN

	p_PHONE_NUMBER := '?';

	SELECT PHONE_NUMBER
	INTO p_PHONE_NUMBER
	FROM PHONE_NUMBER
	WHERE CONTACT_ID = p_CONTACT_ID
	  AND PHONE_TYPE = p_PHONE_TYPE ;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		p_PHONE_NUMBER := '?';

END GET_PHONE_NUMBER;
---------------------------------------------------------------------------------------------------
PROCEDURE  GET_MAX_COLUMN_WIDTH
	(
	p_TABLE_NAME IN VARCHAR,
	p_COLUMN_NAME IN VARCHAR,
    p_COLUMN_WIDTH OUT NUMBER,
	p_STATUS OUT NUMBER
	) AS

-- Answer the max data length of the given column in the given table.
-- This is not fast, so only use it to set variables, not in a loop or SQL statement.
-- Same as the function, MAX_DATA_LENGTH, but declared as a procedure so VB can use it.
BEGIN

	IF NOT CAN_READ('Public') THEN
		ERRS.RAISE_NO_READ_MODULE('Public');
	END IF;

	p_STATUS := GA.SUCCESS;

	SELECT DATA_LENGTH
	INTO p_COLUMN_WIDTH
	FROM USER_TAB_COLUMNS
	WHERE TABLE_NAME = p_TABLE_NAME
	  AND COLUMN_NAME = p_COLUMN_NAME;


END GET_MAX_COLUMN_WIDTH;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_CONTRACT_TEMPLATE
	(
    p_CONTRACT_ID IN NUMBER,
	p_PARAMETER_STRING OUT VARCHAR2,
    p_STATUS OUT NUMBER
    ) AS
    p_CONTRACT_NAME VARCHAR2(64);
    p_BEGIN_DATE DATE;
    p_END_DATE DATE;
    p_PURCHASER_ID NUMBER;
    p_PURCHASER_NAME VARCHAR2(64);
    p_SELLER_ID NUMBER;
    p_SELLER_NAME VARCHAR2(64);
    p_SC_ID NUMBER;
    p_SC_NAME VARCHAR2(64);
    p_POR_ID NUMBER;
    p_POR_NAME VARCHAR2(64);
    p_POD_ID NUMBER;
    p_POD_NAME VARCHAR2(64);
    p_SOURCE_ID NUMBER;
    p_SOURCE_NAME VARCHAR2(64);
    p_SINK_ID NUMBER;
    p_SINK_NAME VARCHAR2(64);
BEGIN
	-- get fields of the Interchange Contract object to be used as "template" for Interchange Transactions
    p_STATUS := GA.SUCCESS;
    SELECT CONTRACT_NAME, BEGIN_DATE, END_DATE,
    	PURCHASER_ID, B.PSE_NAME, SELLER_ID, C.PSE_NAME,
        A.SC_ID, SC_NAME, POR_ID, E.SERVICE_POINT_NAME, POD_ID, F.SERVICE_POINT_NAME,
        SOURCE_ID, G.SERVICE_POINT_NAME, SINK_ID, H.SERVICE_POINT_NAME
	INTO p_CONTRACT_NAME, p_BEGIN_DATE, p_END_DATE,
    	p_PURCHASER_ID, p_PURCHASER_NAME, p_SELLER_ID, p_SELLER_NAME,
        p_SC_ID, p_SC_NAME, p_POR_ID, p_POR_NAME, p_POD_ID, p_POD_NAME,
        p_SOURCE_ID, p_SOURCE_NAME, p_SINK_ID, p_SINK_NAME
    FROM INTERCHANGE_CONTRACT A,
    	PURCHASING_SELLING_ENTITY B,
    	PURCHASING_SELLING_ENTITY C,
    	SCHEDULE_COORDINATOR D,
        SERVICE_POINT E,
        SERVICE_POINT F,
        SERVICE_POINT G,
        SERVICE_POINT H
    WHERE A.CONTRACT_ID = p_CONTRACT_ID
    	AND B.PSE_ID(+) = PURCHASER_ID
    	AND C.PSE_ID(+) = SELLER_ID
    	AND D.SC_ID(+) = A.SC_ID
        AND E.SERVICE_POINT_ID(+) = POR_ID
        AND F.SERVICE_POINT_ID(+) = POD_ID
        AND G.SERVICE_POINT_ID(+) = SOURCE_ID
        AND H.SERVICE_POINT_ID(+) = SINK_ID;

	p_PARAMETER_STRING := 'CONTRACT_ID=' || p_CONTRACT_NAME || ',' || p_CONTRACT_ID || ';' || 'BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE, 'MM/DD/YYYY') || ';';
	p_PARAMETER_STRING := p_PARAMETER_STRING || 'END_DATE=' || TO_CHAR(p_END_DATE, 'MM/DD/YYYY') || ';' || 'PURCHASER_ID=' || p_PURCHASER_NAME || ',' || p_PURCHASER_ID || ';';
	p_PARAMETER_STRING := p_PARAMETER_STRING || 'SELLER_ID=' || p_SELLER_NAME || ',' || p_SELLER_ID || ';' || 'SC_ID=' || p_SC_NAME || ',' || p_SC_ID || ';';
	p_PARAMETER_STRING := p_PARAMETER_STRING || 'POR_ID=' || p_POR_NAME || ',' || p_POR_ID || ';' || 'POD_ID=' || p_POD_NAME || ',' || p_POD_ID || ';';
	p_PARAMETER_STRING := p_PARAMETER_STRING || 'SOURCE_ID=' || p_SOURCE_NAME || ',' || p_SOURCE_ID || ';' || 'SINK_ID=' || p_SINK_NAME || ',' || p_SINK_ID;


EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		p_PARAMETER_STRING := NULL;

END GET_CONTRACT_TEMPLATE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_DEFAULT_SYSTEM_LABEL
	(
	p_MODEL_ID IN NUMBER,
    p_MODULE IN VARCHAR2,
	p_KEY1 IN VARCHAR2,
	p_KEY2 IN VARCHAR2,
	p_KEY3 IN VARCHAR2,
	p_MATCH_CASE IN NUMBER := 0,
	p_VALUE OUT VARCHAR2
	) AS

--c	Answer the default value associated with the key.

BEGIN
	IF p_MATCH_CASE = 0 THEN
   		SELECT VALUE
	   	INTO p_VALUE
   		FROM SYSTEM_LABEL
	   	WHERE MODEL_ID = p_MODEL_ID
        	AND UPPER(MODULE) = UPPER(p_MODULE)
			AND UPPER(KEY1) = UPPER(p_KEY1)
	   		AND UPPER(KEY2) = UPPER(p_KEY2)
			AND UPPER(KEY3) = UPPER(p_KEY3)
            AND NVL(IS_DEFAULT,0) = 1
            AND NVL(IS_HIDDEN,0) = 0
            AND ROWNUM = 1
		ORDER BY POSITION;
	ELSE --Match Case
   		SELECT VALUE
    	INTO p_VALUE
   		FROM SYSTEM_LABEL
    	WHERE MODEL_ID = p_MODEL_ID
            AND MODULE = p_MODULE
			AND KEY1 = p_KEY1
			AND KEY2 = p_KEY2
			AND KEY3 = p_KEY3
            AND NVL(IS_DEFAULT,0) = 1
            AND NVL(IS_HIDDEN,0) = 0
            AND ROWNUM = 1
		ORDER BY POSITION;
	END IF;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
        	IF p_MODEL_ID <> 0 THEN
            	GET_DEFAULT_SYSTEM_LABEL(0, p_MODULE, p_KEY1, p_KEY2, p_KEY3, p_MATCH_CASE, p_VALUE);
            ELSE
				p_VALUE := NULL;
            END IF;

END GET_DEFAULT_SYSTEM_LABEL;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_DEFAULT_SYSTEM_LABEL_CODE
	(
	p_MODEL_ID IN NUMBER,
    p_MODULE IN VARCHAR2,
	p_KEY1 IN VARCHAR2,
	p_KEY2 IN VARCHAR2,
	p_KEY3 IN VARCHAR2,
	p_MATCH_CASE IN NUMBER := 0,
	p_CODE OUT VARCHAR2
	) AS

--c	Answer the default value associated with the key.

BEGIN
	IF p_MATCH_CASE = 0 THEN
   		SELECT CODE
	   	INTO p_CODE
   		FROM SYSTEM_LABEL
	   	WHERE MODEL_ID = p_MODEL_ID
        	AND UPPER(MODULE) = UPPER(p_MODULE)
			AND UPPER(KEY1) = UPPER(p_KEY1)
	   		AND UPPER(KEY2) = UPPER(p_KEY2)
			AND UPPER(KEY3) = UPPER(p_KEY3)
            AND NVL(IS_DEFAULT,0) = 1
            AND NVL(IS_HIDDEN,0) = 0
            AND ROWNUM = 1
		ORDER BY POSITION;
	ELSE --Match Case
   		SELECT CODE
    	INTO p_CODE
   		FROM SYSTEM_LABEL
    	WHERE MODEL_ID = p_MODEL_ID
            AND MODULE = p_MODULE
			AND KEY1 = p_KEY1
			AND KEY2 = p_KEY2
			AND KEY3 = p_KEY3
            AND NVL(IS_DEFAULT,0) = 1
            AND NVL(IS_HIDDEN,0) = 0
            AND ROWNUM = 1
		ORDER BY POSITION;
	END IF;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
        	IF p_MODEL_ID <> 0 THEN
            	GET_DEFAULT_SYSTEM_LABEL_CODE(0, p_MODULE, p_KEY1, p_KEY2, p_KEY3, p_MATCH_CASE, p_CODE);
            ELSE
				p_CODE := NULL;
            END IF;

END GET_DEFAULT_SYSTEM_LABEL_CODE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_SYSTEM_LABEL_VALUE_BY_CODE
	(
	p_MODEL_ID IN NUMBER,
    p_MODULE IN VARCHAR2,
	p_KEY1 IN VARCHAR2,
	p_KEY2 IN VARCHAR2,
	p_KEY3 IN VARCHAR2,
	p_CODE IN VARCHAR2,
	p_VALUE OUT VARCHAR2
	) AS
BEGIN
	SELECT MAX(VALUE)
	INTO p_VALUE
	FROM (SELECT VALUE
			FROM SYSTEM_LABEL
			WHERE MODEL_ID = p_MODEL_ID
				AND UPPER(MODULE) = UPPER(p_MODULE)
				AND UPPER(KEY1) = UPPER(p_KEY1)
				AND UPPER(KEY2) = UPPER(p_KEY2)
				AND UPPER(KEY3) = UPPER(p_KEY3)
				AND UPPER(CODE) = UPPER(p_CODE)
			ORDER BY POSITION)
	WHERE ROWNUM = 1;
END GET_SYSTEM_LABEL_VALUE_BY_CODE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_CRYSTAL_REPORT_LIST
	(
    p_MODEL_ID IN NUMBER,
    p_MODULE IN VARCHAR2,
    p_REPORT_TYPE IN VARCHAR2,
    p_STATUS OUT NUMBER,
    p_CURSOR IN OUT GA.REFCURSOR
    ) AS
v_MODULE_ID NUMBER;
BEGIN
	--DEPRECATED - ONLY FOR USE WITH THE VB
    p_STATUS := GA.SUCCESS;

    SO.ID_FOR_SYSTEM_OBJECT(0,p_MODULE,0,'Module','Default',TRUE,v_MODULE_ID);

    OPEN p_CURSOR FOR
    	SELECT A.OBJECT_DISPLAY_NAME "REPORT_NAME",
        	A.OBJECT_ID "REPORT_ID",
            DECODE(COUNT(B.ROW_NUMBER),0,0,1) "IS_CRYSTAL"
		FROM SYSTEM_OBJECT A,
        	CRYSTAL_REPORT_TEMPLATE B
        WHERE A.PARENT_OBJECT_ID = v_MODULE_ID
        	AND A.OBJECT_CATEGORY = 'Report'
            AND A.OBJECT_INDEX = p_MODEL_ID
            AND A.OBJECT_TYPE = p_REPORT_TYPE
            AND B.OBJECT_ID(+) = A.OBJECT_ID
        GROUP BY A.OBJECT_DISPLAY_NAME, A.OBJECT_ID, A.OBJECT_ORDER
		ORDER BY A.OBJECT_ORDER;

END GET_CRYSTAL_REPORT_LIST;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_CRYSTAL_RPT_LIST_BY_VIEW
	(
    p_SYSTEM_VIEW_ID IN NUMBER,
    p_STATUS OUT NUMBER,
    p_CURSOR IN OUT GA.REFCURSOR
    ) AS
v_WORK_ID NUMBER;
BEGIN
	-- NEW JAVA GUI Crystal Reports support
    p_STATUS := GA.SUCCESS;

	v_WORK_ID := SO.ENUMERATE_HIERARCHY(p_SYSTEM_VIEW_ID, 1, FALSE, p_INCLUDED_CATEGORIES => STRING_COLLECTION('Report'));

    OPEN p_CURSOR FOR
    	SELECT NVL(A.OBJECT_DISPLAY_NAME, A.OBJECT_NAME) as REPORT_NAME,
        	A.OBJECT_ID as REPORT_ID,
            CASE WHEN D.ATTRIBUTE_VAL IN ('Crystal Report','Billing Invoice') THEN 1 ELSE 0 END as IS_CRYSTAL,
            CASE WHEN COUNT(B.OBJECT_ID) > 0 THEN 1 ELSE 0 END as TEMPLATE_COUNT,
			C.ATTRIBUTE_VAL as TEMPLATE_TYPE_PROC
		FROM SYSTEM_OBJECT A,
			RTO_WORK W,
        	CRYSTAL_REPORT_FILES B,
			SYSTEM_OBJECT_ATTRIBUTE C,
			SYSTEM_OBJECT_ATTRIBUTE D
        WHERE A.PARENT_OBJECT_ID = p_SYSTEM_VIEW_ID
			-- join to work to restrict report list to those to which user has 'view' or higher access
			AND W.WORK_ID = v_WORK_ID
			AND W.WORK_XID = A.OBJECT_ID
            AND B.OBJECT_ID(+) = A.OBJECT_ID
			AND C.OBJECT_ID(+) = A.OBJECT_ID
			AND C.ATTRIBUTE_ID(+) = 412 -- Crystal Template Type List Proc
			AND D.OBJECT_ID(+) = A.OBJECT_ID
			AND D.ATTRIBUTE_ID(+) = 403 -- Data Panel Type
        GROUP BY NVL(A.OBJECT_DISPLAY_NAME, A.OBJECT_NAME), A.OBJECT_ID, A.OBJECT_ORDER,
			C.ATTRIBUTE_VAL, D.ATTRIBUTE_VAL
		ORDER BY A.OBJECT_ORDER, NVL(A.OBJECT_DISPLAY_NAME, A.OBJECT_NAME);

	UT.PURGE_RTO_WORK(v_WORK_ID);

END GET_CRYSTAL_RPT_LIST_BY_VIEW;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_CRYSTAL_TEMPLATE_TYPE_STAT
	(
    p_REPORT_ID IN NUMBER,
	p_TEMPLATE_TYPE IN VARCHAR2,
    p_EXISTS OUT NUMBER,
    p_STATUS OUT NUMBER
	) AS
v_TEMPLATE_TYPE VARCHAR2(2000) := NVL(p_TEMPLATE_TYPE,g_DEFAULT_TEMPLATE_TYPE);
BEGIN
	-- NEW JAVA GUI Crystal Reports support
    p_STATUS := GA.SUCCESS;

    SELECT DECODE(COUNT(*),0,0,1)
    INTO p_EXISTS
    FROM CRYSTAL_REPORT_FILES
    WHERE OBJECT_ID = p_REPORT_ID
		AND TEMPLATE_TYPE = v_TEMPLATE_TYPE;

END GET_CRYSTAL_TEMPLATE_TYPE_STAT;
---------------------------------------------------------------------------------------------------
PROCEDURE IS_CRYSTAL_REPORT
	(
    p_REPORT_ID IN NUMBER,
    p_IS_CRYSTAL OUT NUMBER
    ) AS
BEGIN
    --DEPRECATED - ONLY FOR USE WITH THE VB
	p_STATUS := GA.SUCCESS;

    SELECT DECODE(COUNT(*),0,0,1)
    INTO p_IS_CRYSTAL
    FROM CRYSTAL_REPORT_TEMPLATE
    WHERE OBJECT_ID = p_REPORT_ID;

END IS_CRYSTAL_REPORT;
---------------------------------------------------------------------------------------------------
PROCEDURE IS_CRYSTAL_REPORT_FILE
	(
    p_REPORT_ID IN NUMBER,
    p_IS_CRYSTAL OUT NUMBER
    ) AS
BEGIN
	-- NEW JAVA GUI Crystal Reports support
    p_STATUS := GA.SUCCESS;

    SELECT DECODE(COUNT(*),0,0,1)
    INTO p_IS_CRYSTAL
    FROM CRYSTAL_REPORT_FILES
    WHERE OBJECT_ID = p_REPORT_ID;

END IS_CRYSTAL_REPORT_FILE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_REPORT_TIMESTAMP
	(
    p_REPORT_ID IN VARCHAR2,
    p_TIMESTAMP OUT DATE,
    p_STATUS OUT NUMBER
    ) AS
BEGIN
	p_STATUS := GA.SUCCESS;

    SELECT MAX(ENTRY_DATE)
    INTO p_TIMESTAMP
    FROM CRYSTAL_REPORT_TEMPLATE
    WHERE OBJECT_ID = p_REPORT_ID;

END GET_REPORT_TIMESTAMP;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_REPORT_TEMPLATE
	(
    p_REPORT_ID IN VARCHAR2,
    p_STATUS OUT NUMBER,
    p_CURSOR IN OUT GA.REFCURSOR
    ) AS
BEGIN
	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
        SELECT REPORT_DATA
        FROM CRYSTAL_REPORT_TEMPLATE
        WHERE OBJECT_ID = p_REPORT_ID
        ORDER BY ROW_NUMBER;

END GET_REPORT_TEMPLATE;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_REPORT_TEMPLATE
	(
    p_REPORT_ID IN VARCHAR2,
    p_DELETE_FIRST IN NUMBER,
    p_DATA IN VARCHAR,
    p_STATUS OUT NUMBER
    ) AS
v_ROW_NUMBER NUMBER;
BEGIN
	--DEPRECATED - ONLY FOR USE WITH THE VB
    p_STATUS := GA.SUCCESS;
    IF NOT CAN_DELETE('Admin') THEN
		ERRS.RAISE_NO_DELETE_MODULE('Admin');
	END IF;

	-- caller should set this to 1 for first chunk and then to zero for
    -- all subsequent chunks until entire file is written
	IF p_DELETE_FIRST = 1 THEN
		DELETE CRYSTAL_REPORT_TEMPLATE
	    WHERE OBJECT_ID = p_REPORT_ID;
	END IF;

    SELECT NVL(MAX(ROW_NUMBER),-1) + 1
    INTO v_ROW_NUMBER
    FROM CRYSTAL_REPORT_TEMPLATE
    WHERE OBJECT_ID = p_REPORT_ID;

    INSERT INTO CRYSTAL_REPORT_TEMPLATE
    	(OBJECT_ID, ROW_NUMBER, REPORT_DATA, ENTRY_DATE)
    VALUES
    	(p_REPORT_ID, v_ROW_NUMBER, p_DATA, SYSDATE);

END PUT_REPORT_TEMPLATE;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_CRYSTAL_REPORT_FILE
	(
    p_REPORT_ID IN NUMBER,
	p_TEMPLATE_TYPE IN VARCHAR2,
    P_CRYSTAL_REPORT_FILE IN BLOB,
    p_STATUS OUT NUMBER
    ) AS
v_TEMPLATE_TYPE VARCHAR2(2000) := NVL(p_TEMPLATE_TYPE,g_DEFAULT_TEMPLATE_TYPE);
BEGIN
	-- NEW JAVA GUI Crystal Reports support
    p_STATUS := GA.SUCCESS;

	SO.CHECK_OBJECT_PRIVILEGE(p_REPORT_ID, SO.g_PRIV_EDIT);

    -- UPDATE AN EXISTING RECORD
	UPDATE CRYSTAL_REPORT_FILES SET
		REPORT_FILE = p_CRYSTAL_REPORT_FILE,
		ENTRY_DATE = SYSDATE
	WHERE OBJECT_ID = p_REPORT_ID
		AND TEMPLATE_TYPE = v_TEMPLATE_TYPE;

    -- IF THE PREVIOUS UPDATE DID NOT FIND A MATCH, THEN INSERT A NEW RECORD
	IF SQL%NOTFOUND THEN
		INSERT INTO CRYSTAL_REPORT_FILES (
			OBJECT_ID,
			TEMPLATE_TYPE,
			REPORT_FILE,
			ENTRY_DATE)
		VALUES (
			p_REPORT_ID,
			v_TEMPLATE_TYPE,
			p_CRYSTAL_REPORT_FILE,
			SYSDATE);
	END IF;

END PUT_CRYSTAL_REPORT_FILE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_CRYSTAL_REPORT_FILE
	(
    p_REPORT_ID IN NUMBER,
	p_TEMPLATE_TYPE IN VARCHAR2,
    p_GET_BLOB OUT BLOB,
    p_STATUS OUT NUMBER
    ) AS
v_TEMPLATE_TYPE VARCHAR2(2000) := NVL(p_TEMPLATE_TYPE,g_DEFAULT_TEMPLATE_TYPE);
BEGIN
	-- NEW JAVA GUI Crystal Reports support
    p_STATUS := GA.SUCCESS;

	BEGIN
        SELECT REPORT_FILE INTO p_GET_BLOB
        FROM CRYSTAL_REPORT_FILES
    	WHERE OBJECT_ID = p_REPORT_ID
    		AND TEMPLATE_TYPE = v_TEMPLATE_TYPE;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			IF v_TEMPLATE_TYPE <> g_DEFAULT_TEMPLATE_TYPE THEN
				-- if specified template type not found, try to get default
				GET_CRYSTAL_REPORT_FILE(p_REPORT_ID, g_DEFAULT_TEMPLATE_TYPE, p_GET_BLOB, p_STATUS);
			ELSE
				-- default specified but doesn't exist? then get the last
				-- template uploaded
                SELECT REPORT_FILE INTO p_GET_BLOB
                FROM CRYSTAL_REPORT_FILES
            	WHERE OBJECT_ID = p_REPORT_ID
            		AND ENTRY_DATE = (SELECT MAX(ENTRY_DATE)
    								  FROM CRYSTAL_REPORT_FILES
    								  WHERE OBJECT_ID = p_REPORT_ID);
			END IF;
	END;

END GET_CRYSTAL_REPORT_FILE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_CRYSTAL_REPORT_TIMESTAMP
	(
    p_REPORT_ID IN NUMBER,
	p_TEMPLATE_TYPE IN VARCHAR2,
    p_TIMESTAMP OUT DATE,
    p_STATUS OUT NUMBER
    ) AS
v_TEMPLATE_TYPE VARCHAR2(2000) := NVL(p_TEMPLATE_TYPE,g_DEFAULT_TEMPLATE_TYPE);
BEGIN
	-- NEW JAVA GUI Crystal Reports support
    p_STATUS := GA.SUCCESS;

	BEGIN
        SELECT ENTRY_DATE INTO p_TIMESTAMP
        FROM CRYSTAL_REPORT_FILES
    	WHERE OBJECT_ID = p_REPORT_ID
			AND TEMPLATE_TYPE = v_TEMPLATE_TYPE;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			IF v_TEMPLATE_TYPE <> g_DEFAULT_TEMPLATE_TYPE THEN
				-- if specified template type not found, try to get default
				GET_CRYSTAL_REPORT_TIMESTAMP(p_REPORT_ID, g_DEFAULT_TEMPLATE_TYPE, p_TIMESTAMP, p_STATUS);
			ELSE
				-- default specified but doesn't exist? then get the last
				-- template uploaded
                SELECT ENTRY_DATE INTO p_TIMESTAMP
                FROM CRYSTAL_REPORT_FILES
            	WHERE OBJECT_ID = p_REPORT_ID
            		AND ENTRY_DATE = (SELECT MAX(ENTRY_DATE)
    								  FROM CRYSTAL_REPORT_FILES
    								  WHERE OBJECT_ID = p_REPORT_ID);
			END IF;
	END;

END GET_CRYSTAL_REPORT_TIMESTAMP;
---------------------------------------------------------------------------------------------------
PROCEDURE REMOVE_REPORT_TEMPLATE
	(
    p_REPORT_ID IN VARCHAR2,
    p_STATUS OUT NUMBER
    ) AS
BEGIN
	--DEPRECATED - ONLY FOR USE WITH THE VB
    p_STATUS := GA.SUCCESS;
    IF NOT CAN_DELETE('Admin') THEN
		ERRS.RAISE_NO_DELETE_MODULE('Admin');
	END IF;

    DELETE CRYSTAL_REPORT_TEMPLATE
    WHERE OBJECT_ID = p_REPORT_ID;

END REMOVE_REPORT_TEMPLATE;
---------------------------------------------------------------------------------------------------
PROCEDURE REMOVE_CRYSTAL_REPORT_FILE
	(
    p_REPORT_ID IN NUMBER,
	p_TEMPLATE_TYPE IN VARCHAR2,
    p_STATUS OUT NUMBER
    ) AS
v_TEMPLATE_TYPE VARCHAR2(2000) := NVL(p_TEMPLATE_TYPE,g_DEFAULT_TEMPLATE_TYPE);
BEGIN
	-- NEW JAVA GUI Crystal Reports support
    p_STATUS := GA.SUCCESS;

	SO.CHECK_OBJECT_PRIVILEGE(p_REPORT_ID, SO.g_PRIV_EDIT);

    DELETE CRYSTAL_REPORT_FILES
    WHERE OBJECT_ID = p_REPORT_ID
		AND TEMPLATE_TYPE = v_TEMPLATE_TYPE;

END REMOVE_CRYSTAL_REPORT_FILE;
---------------------------------------------------------------------------------------------------
PROCEDURE CHECK_SYSTEM_DATE_TIME
	(
	p_TIME_ZONE IN VARCHAR2,
	p_BEGIN_DATE IN DATE := SYSDATE,
	p_END_DATE IN DATE := SYSDATE
	) AS

--DETERMINE WHETHER THE SYSTEM_DATE_TIME TABLE HAS BEEN POPULATED YET.
--RAISE AN EXCEPTION IF NOT

v_BEGIN_DATE DATE := TRUNC(p_BEGIN_DATE);
v_END_DATE DATE := TRUNC(p_END_DATE);
v_FOUND		PLS_INTEGER;
v_EXPECTED	PLS_INTEGER := v_END_DATE - v_BEGIN_DATE + 1;
BEGIN

	SELECT COUNT(1)
	INTO v_FOUND
	FROM SYSTEM_DATE_TIME
	WHERE TIME_ZONE = p_TIME_ZONE
		AND DATA_INTERVAL_TYPE = 2	-- just get daily records
		AND DAY_TYPE = '1' 			-- for normal day type
		AND CUT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE;

	IF v_FOUND <> v_EXPECTED THEN
		ERRS.RAISE(MSGCODES.c_ERR_MISSING_SYSTEM_DATE_TIME,
					'Time Zone = ' || p_TIME_ZONE ||
					'; Date Range = ' || TEXT_UTIL.TO_CHAR_DATE_RANGE(v_BEGIN_DATE, v_END_DATE));
	END IF;

END CHECK_SYSTEM_DATE_TIME;
---------------------------------------------------------------------------------------------------
PROCEDURE CHECK_TEMPLATE_DATES
	(
	p_TEMPLATE_ID IN NUMBER,
	p_HOLIDAY_SET_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	) AS

--DETERMINE WHETHER THE TEMPLATE_DATES TABLE HAS BEEN POPULATED YET.
--RAISE AN EXCEPTION IF NOT

	v_BEGIN_DATE DATE := TRUNC(p_BEGIN_DATE);
	v_END_DATE DATE := TRUNC(p_END_DATE);
	v_FOUND		PLS_INTEGER;
	v_EXPECTED	PLS_INTEGER := v_END_DATE - v_BEGIN_DATE + 1;

    v_DAY_TYPE_TEST NUMBER(1);

BEGIN

    SELECT T.IS_DAY_TYPE
    INTO v_DAY_TYPE_TEST
    FROM TEMPLATE T
    WHERE T.TEMPLATE_ID = p_TEMPLATE_ID;

    IF NVL(v_DAY_TYPE_TEST, 1) = 1 THEN
        ERRS.RAISE(MSGCODES.c_ERR_DAY_TYPE_TEMPLATE,
            'Template = ' || TEXT_UTIL.TO_CHAR_ENTITY(p_TEMPLATE_ID, EC.ED_TEMPLATE));
    END IF;

	SELECT COUNT(1)
	INTO v_FOUND
	FROM TEMPLATE_DATES TD
	WHERE TD.TIME_ZONE = p_TIME_ZONE
		AND TD.HOLIDAY_SET_ID = p_HOLIDAY_SET_ID
		AND TD.TEMPLATE_ID = p_TEMPLATE_ID
		AND TD.LOCAL_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE;

	IF v_FOUND <> v_EXPECTED THEN
		ERRS.RAISE(MSGCODES.c_ERR_MISSING_TEMPLATE_DATES,
					'Time Zone = ' || p_TIME_ZONE ||
					'; Date Range = ' || TEXT_UTIL.TO_CHAR_DATE_RANGE(v_BEGIN_DATE, v_END_DATE) ||
					'; Template = ' || TEXT_UTIL.TO_CHAR_ENTITY(p_TEMPLATE_ID, EC.ED_TEMPLATE) ||
					'; Holiday Set = ' || TEXT_UTIL.TO_CHAR_ENTITY(p_HOLIDAY_SET_ID, EC.ED_HOLIDAY_SET));
	END IF;

END CHECK_TEMPLATE_DATES;
---------------------------------------------------------------------------------------------------
PROCEDURE CHECK_TEMPLATE_DATES
	(
	p_TEMPLATE_ID IN NUMBER_COLLECTION,
	p_HOLIDAY_SET_ID IN NUMBER_COLLECTION,
	p_TIME_ZONE IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	) AS

BEGIN

	FOR v_REC IN (SELECT TEMP.COLUMN_VALUE AS TEMPLATE_ID,
						HS.COLUMN_VALUE AS HOLIDAY_SET_ID
					FROM TABLE(CAST(p_TEMPLATE_ID AS NUMBER_COLLECTION)) TEMP,
						TABLE(CAST(p_HOLIDAY_SET_ID AS NUMBER_COLLECTION)) HS) LOOP

		SP.CHECK_TEMPLATE_DATES(v_REC.TEMPLATE_ID,
								v_REC.HOLIDAY_SET_ID,
								p_TIME_ZONE,
								p_BEGIN_DATE,
								p_END_DATE);

	END LOOP;

END CHECK_TEMPLATE_DATES;
---------------------------------------------------------------------------------------------------
PROCEDURE SYSTEM_SETTINGS_TREE
	(
	p_CURSOR IN OUT GA.REFCURSOR,
	p_STATUS OUT NUMBER
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT MODEL_ID, MODULE, KEY1, KEY2, KEY3
		FROM SYSTEM_DICTIONARY
		UNION -- *NOT* UNION ALL because we want this to grab only the distinct items in the set
		SELECT MODEL_ID, MODULE, KEY1, KEY2, KEY3
		FROM SYSTEM_LABEL
		UNION -- at a minimum, make sure the model root nodes are present
		SELECT 0 "MODEL_ID", '?' "MODULE", '?' "KEY1", '?' "KEY2", '?' "KEY3"
		FROM DUAL
		UNION
		SELECT 1 "MODEL_ID", '?' "MODULE", '?' "KEY1", '?' "KEY2", '?' "KEY3"
		FROM DUAL
		UNION
		SELECT 2 "MODEL_ID", '?' "MODULE", '?' "KEY1", '?' "KEY2", '?' "KEY3"
		FROM DUAL
		ORDER BY 1, 2, 3, 4, 5;
END SYSTEM_SETTINGS_TREE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_ALL_DICTIONARY_SETTINGS
	(
	p_CURSOR IN OUT GA.REFCURSOR,
	p_STATUS OUT NUMBER
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT MODEL_ID, MODULE, KEY1, KEY2, KEY3, SETTING_NAME, VALUE
		FROM SYSTEM_DICTIONARY
		ORDER BY 1,2,3,4,5,6;
END GET_ALL_DICTIONARY_SETTINGS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_ALL_LABELS
	(
	p_CURSOR IN OUT GA.REFCURSOR,
	p_STATUS OUT NUMBER
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT MODEL_ID, MODULE, KEY1, KEY2, KEY3, POSITION, VALUE, CODE, IS_DEFAULT, IS_HIDDEN
		FROM SYSTEM_LABEL
		ORDER BY 1,2,3,4,5,6,7,8;
END GET_ALL_LABELS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_SYSTEM_DICTIONARY
	(
	p_MODEL_ID IN NUMBER,
	p_MODULE IN VARCHAR2,
	p_KEY1 IN VARCHAR2,
	p_KEY2 IN VARCHAR2,
	p_KEY3 IN VARCHAR2,
	p_SETTING_NAME IN VARCHAR2,
	p_VALUE IN VARCHAR2,
	p_OLD_MODULE IN VARCHAR2,
	p_OLD_KEY1 IN VARCHAR2,
	p_OLD_KEY2 IN VARCHAR2,
	p_OLD_KEY3 IN VARCHAR2,
	p_OLD_SETTING_NAME IN VARCHAR2,
	p_STATUS OUT NUMBER
	) AS
BEGIN
	IF NOT CAN_WRITE('Admin') THEN
		ERRS.RAISE_NO_WRITE_MODULE('Admin');
	END IF;

	p_STATUS := GA.SUCCESS;

	UPDATE SYSTEM_DICTIONARY SET
		MODULE = p_MODULE,
		KEY1 = p_KEY1,
		KEY2 = p_KEY2,
		KEY3 = p_KEY3,
		SETTING_NAME = p_SETTING_NAME,
		VALUE = p_VALUE
	WHERE MODEL_ID = p_MODEL_ID
		AND MODULE = p_OLD_MODULE
		AND KEY1 = p_OLD_KEY1
		AND KEY2 = p_OLD_KEY2
		AND KEY3 = p_OLD_KEY3
		AND SETTING_NAME = p_OLD_SETTING_NAME;

	IF SQL%NOTFOUND THEN
		INSERT INTO SYSTEM_DICTIONARY (
			MODEL_ID, MODULE, KEY1, KEY2, KEY3,
			SETTING_NAME, VALUE)
		VALUES (
			p_MODEL_ID, p_MODULE, p_KEY1, p_KEY2, p_KEY3,
			p_SETTING_NAME, p_VALUE);
	END IF;

END PUT_SYSTEM_DICTIONARY;
---------------------------------------------------------------------------------------------------
PROCEDURE REMOVE_SYSTEM_DICTIONARY
	(
	p_MODEL_ID IN NUMBER,
	p_MODULE IN VARCHAR2,
	p_KEY1 IN VARCHAR2,
	p_KEY2 IN VARCHAR2,
	p_KEY3 IN VARCHAR2,
	p_SETTING_NAME IN VARCHAR2,
	p_STATUS OUT NUMBER
	) AS
BEGIN
	IF NOT CAN_DELETE('Admin') THEN
		ERRS.RAISE_NO_DELETE_MODULE('Admin');
	END IF;

	p_STATUS := GA.SUCCESS;

	DELETE SYSTEM_DICTIONARY
	WHERE MODEL_ID = p_MODEL_ID
		AND MODULE = p_MODULE
		AND KEY1 = p_KEY1
		AND KEY2 = p_KEY2
		AND KEY3 = p_KEY3
		AND SETTING_NAME = p_SETTING_NAME;

END REMOVE_SYSTEM_DICTIONARY;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_SYSTEM_LABEL
	(
	p_MODEL_ID IN NUMBER,
	p_MODULE IN VARCHAR2,
	p_KEY1 IN VARCHAR2,
	p_KEY2 IN VARCHAR2,
	p_KEY3 IN VARCHAR2,
	p_POSITION IN NUMBER,
	p_VALUE IN VARCHAR2,
	p_CODE IN VARCHAR2,
	p_IS_DEFAULT IN NUMBER,
	p_IS_HIDDEN IN NUMBER,
	p_OLD_MODULE IN VARCHAR2,
	p_OLD_KEY1 IN VARCHAR2,
	p_OLD_KEY2 IN VARCHAR2,
	p_OLD_KEY3 IN VARCHAR2,
	p_OLD_POSITION IN NUMBER,
	p_STATUS OUT NUMBER
	) AS
BEGIN
	IF NOT CAN_WRITE('Admin') THEN
		ERRS.RAISE_NO_WRITE_MODULE('Admin');
	END IF;

	p_STATUS := GA.SUCCESS;

	UPDATE SYSTEM_LABEL SET
		MODULE = p_MODULE,
		KEY1 = p_KEY1,
		KEY2 = p_KEY2,
		KEY3 = p_KEY3,
		POSITION = p_POSITION,
		VALUE = p_VALUE,
		CODE = p_CODE,
		IS_DEFAULT = p_IS_DEFAULT,
		IS_HIDDEN = p_IS_HIDDEN
	WHERE MODEL_ID = p_MODEL_ID
		AND MODULE = p_OLD_MODULE
		AND KEY1 = p_OLD_KEY1
		AND KEY2 = p_OLD_KEY2
		AND KEY3 = p_OLD_KEY3
		AND POSITION = p_OLD_POSITION;

	IF SQL%NOTFOUND THEN
		INSERT INTO SYSTEM_LABEL (
			MODEL_ID, MODULE, KEY1, KEY2, KEY3,
			POSITION, VALUE, CODE, IS_DEFAULT, IS_HIDDEN)
		VALUES (
			p_MODEL_ID, p_MODULE, p_KEY1, p_KEY2, p_KEY3,
			p_POSITION, p_VALUE, p_CODE, p_IS_DEFAULT, p_IS_HIDDEN);
	END IF;

END PUT_SYSTEM_LABEL;
---------------------------------------------------------------------------------------------------
PROCEDURE REMOVE_SYSTEM_LABEL
	(
	p_MODEL_ID IN NUMBER,
	p_MODULE IN VARCHAR2,
	p_KEY1 IN VARCHAR2,
	p_KEY2 IN VARCHAR2,
	p_KEY3 IN VARCHAR2,
	p_POSITION IN VARCHAR2,
	p_STATUS OUT NUMBER
	) AS
BEGIN
	IF NOT CAN_DELETE('Admin') THEN
		ERRS.RAISE_NO_DELETE_MODULE('Admin');
	END IF;

	p_STATUS := GA.SUCCESS;

	DELETE SYSTEM_LABEL
	WHERE MODEL_ID = p_MODEL_ID
		AND MODULE = p_MODULE
		AND KEY1 = p_KEY1
		AND KEY2 = p_KEY2
		AND KEY3 = p_KEY3
		AND POSITION = p_POSITION;

END REMOVE_SYSTEM_LABEL;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_USER_PREFERENCE
	(
	p_MODULE IN VARCHAR2,
	p_KEY1 IN VARCHAR2,
	p_KEY2 IN VARCHAR2,
	p_KEY3 IN VARCHAR2,
	p_SETTING_NAME IN VARCHAR2,
	p_VALUE OUT VARCHAR2
	) AS

-- ANSWER A RECORDSET CONTAINING WHAT'S IN THE USER_PREFERENCES

BEGIN

    SELECT VALUE
	INTO p_VALUE
    FROM APPLICATION_USER_PREFERENCES
    WHERE USER_ID = SECURITY_CONTROLS.CURRENT_USER_ID
        AND MODULE = NVL(p_MODULE,'?')
        AND KEY1 = NVL(p_KEY1,'?')
        AND KEY2 = NVL(p_KEY2,'?')
        AND KEY3 = NVL(p_KEY3,'?')
        AND SETTING_NAME = p_SETTING_NAME;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			-- first look for global dictionary value
			GET_SYSTEM_DICTIONARY_VALUE(0,p_MODULE,p_KEY1,p_KEY2,p_KEY3,p_SETTING_NAME,p_VALUE);
			-- not there? try electric
			IF p_VALUE IS NULL THEN
				GET_SYSTEM_DICTIONARY_VALUE(1,p_MODULE,p_KEY1,p_KEY2,p_KEY3,p_SETTING_NAME,p_VALUE);
			END IF;
			-- finally try gas
			IF p_VALUE IS NULL THEN
				GET_SYSTEM_DICTIONARY_VALUE(2,p_MODULE,p_KEY1,p_KEY2,p_KEY3,p_SETTING_NAME,p_VALUE);
			END IF;
END GET_USER_PREFERENCE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_USER_PREFERENCES
	(
	p_MODULE IN VARCHAR2,
	p_KEY1 IN VARCHAR2,
	p_KEY2 IN VARCHAR2,
	p_KEY3 IN VARCHAR2,
	p_SETTING_NAME IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- ANSWER A RECORDSET CONTAINING WHAT'S IN THE USER_PREFERENCES

BEGIN

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		  SELECT USER_ID,
			  	MODULE,
				KEY1,
				KEY2,
				KEY3,
				SETTING_NAME,
				VALUE
		  FROM APPLICATION_USER_PREFERENCES
		  WHERE USER_ID = SECURITY_CONTROLS.CURRENT_USER_ID
		  	  AND MODULE LIKE p_MODULE
		  	  AND KEY1 LIKE p_KEY1
			  AND KEY2 LIKE p_KEY2
			  AND KEY3 LIKE p_KEY3
			  AND SETTING_NAME LIKE p_SETTING_NAME
		  ORDER BY 1,2,3,4,5,6;

END GET_USER_PREFERENCES;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_USER_PREFERENCE
	(
	p_MODULE IN VARCHAR2,
	p_KEY1 IN VARCHAR2,
	p_KEY2 IN VARCHAR2,
	p_KEY3 IN VARCHAR2,
	p_SETTING_NAME IN VARCHAR2,
	p_VALUE IN VARCHAR2,
	p_OLD_MODULE IN VARCHAR2,
	p_OLD_KEY1 IN VARCHAR2,
	p_OLD_KEY2 IN VARCHAR2,
	p_OLD_KEY3 IN VARCHAR2,
	p_OLD_SETTING_NAME IN VARCHAR2,
	p_STATUS OUT NUMBER
	) AS
BEGIN

	p_STATUS := GA.SUCCESS;

	UPDATE APPLICATION_USER_PREFERENCES SET
		MODULE = p_MODULE,
		KEY1 = p_KEY1,
		KEY2 = p_KEY2,
		KEY3 = p_KEY3,
		SETTING_NAME = p_SETTING_NAME,
		VALUE = p_VALUE
	WHERE USER_ID = SECURITY_CONTROLS.CURRENT_USER_ID
		AND MODULE = p_OLD_MODULE
		AND KEY1 = p_OLD_KEY1
		AND KEY2 = p_OLD_KEY2
		AND KEY3 = p_OLD_KEY3
		AND SETTING_NAME = p_OLD_SETTING_NAME;

	IF SQL%NOTFOUND THEN
		INSERT INTO APPLICATION_USER_PREFERENCES (
			USER_ID, MODULE, KEY1, KEY2, KEY3,
			SETTING_NAME, VALUE)
		VALUES (
			SECURITY_CONTROLS.CURRENT_USER_ID, p_MODULE, p_KEY1, p_KEY2, p_KEY3,
			p_SETTING_NAME, p_VALUE);
	END IF;

END PUT_USER_PREFERENCE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_USER_PREFERENCE_VALUE
	(
	p_MODULE IN VARCHAR2,
	p_KEY1 IN VARCHAR2,
	p_KEY2 IN VARCHAR2,
	p_KEY3 IN VARCHAR2,
	p_SETTING_NAME IN VARCHAR2,
	p_VALUE IN VARCHAR2,
	p_STATUS OUT NUMBER
	) AS
BEGIN

	p_STATUS := GA.SUCCESS;

	UPDATE APPLICATION_USER_PREFERENCES SET
		MODULE = p_MODULE,
		KEY1 = p_KEY1,
		KEY2 = p_KEY2,
		KEY3 = p_KEY3,
		SETTING_NAME = p_SETTING_NAME,
		VALUE = p_VALUE
	WHERE USER_ID = SECURITY_CONTROLS.CURRENT_USER_ID
		AND MODULE = p_MODULE
		AND KEY1 = p_KEY1
		AND KEY2 = p_KEY2
		AND KEY3 = p_KEY3
		AND SETTING_NAME = p_SETTING_NAME;

	IF SQL%NOTFOUND THEN
		INSERT INTO APPLICATION_USER_PREFERENCES (
			USER_ID, MODULE, KEY1, KEY2, KEY3,
			SETTING_NAME, VALUE)
		VALUES (
			SECURITY_CONTROLS.CURRENT_USER_ID, p_MODULE, p_KEY1, p_KEY2, p_KEY3,
			p_SETTING_NAME, p_VALUE);
	END IF;

END PUT_USER_PREFERENCE_VALUE;
---------------------------------------------------------------------------------------------------
PROCEDURE REMOVE_USER_PREFERENCE
	(
	p_MODULE IN VARCHAR2,
	p_KEY1 IN VARCHAR2,
	p_KEY2 IN VARCHAR2,
	p_KEY3 IN VARCHAR2,
	p_SETTING_NAME IN VARCHAR2,
	p_STATUS OUT NUMBER
	) AS
BEGIN

	p_STATUS := GA.SUCCESS;

	DELETE APPLICATION_USER_PREFERENCES
	WHERE  USER_ID = SECURITY_CONTROLS.CURRENT_USER_ID
		AND MODULE = p_MODULE
		AND KEY1 = p_KEY1
		AND KEY2 = p_KEY2
		AND KEY3 = p_KEY3
		AND SETTING_NAME = p_SETTING_NAME;

END REMOVE_USER_PREFERENCE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_FILTER_PRESET
	(
	p_MODULE IN VARCHAR2,
	p_KEY1 IN VARCHAR2,
	p_KEY2 IN VARCHAR2,
	p_VALUE IN VARCHAR2,
	p_OLD_MODULE IN VARCHAR2,
	p_OLD_KEY1 IN VARCHAR2,
	p_OLD_KEY2 IN VARCHAR2,
	p_OLD_VALUE IN VARCHAR2,
	p_STATUS OUT NUMBER
	) AS
BEGIN

	p_STATUS := GA.SUCCESS;

	-- KEY 3 = the name of the saved filter.  This allows us to
	-- have multiple filter setting names under the key set
	-- Module, Key1, Key2, %, FILTER_SETTINGS
	-- we therefore must update key 3 with the name of the new filter

	UPDATE APPLICATION_USER_PREFERENCES SET
		MODULE = p_MODULE,
		KEY1 = p_KEY1,
		KEY2 = p_KEY2,
		KEY3 = p_VALUE,
		VALUE = p_VALUE
	WHERE USER_ID = SECURITY_CONTROLS.CURRENT_USER_ID
		AND MODULE = p_OLD_MODULE
		AND KEY1 = p_OLD_KEY1
		AND KEY2 = p_OLD_KEY2
		AND KEY3 = p_OLD_VALUE
		AND VALUE = p_OLD_VALUE
		AND SETTING_NAME = 'FILTER_SETTINGS';

	UPDATE APPLICATION_USER_PREFERENCES SET
		MODULE = p_MODULE,
		KEY1 = p_KEY1,
		KEY2 = p_KEY2,
		KEY3 = p_VALUE
	WHERE USER_ID = SECURITY_CONTROLS.CURRENT_USER_ID
		AND MODULE = p_OLD_MODULE
		AND KEY1 = p_OLD_KEY1
		AND KEY2 = p_OLD_KEY2
		AND KEY3 = p_OLD_VALUE
		AND NOT SETTING_NAME = 'FILTER_SETTINGS';

END PUT_FILTER_PRESET;
---------------------------------------------------------------------------------------------------
PROCEDURE REMOVE_FILTER_PRESET
	(
	p_MODULE IN VARCHAR2,
	p_KEY1 IN VARCHAR2,
	p_KEY2 IN VARCHAR2,
	p_VALUE IN VARCHAR2,
	p_STATUS OUT NUMBER
	) AS
BEGIN

	p_STATUS := GA.SUCCESS;

	DELETE APPLICATION_USER_PREFERENCES
	WHERE USER_ID = SECURITY_CONTROLS.CURRENT_USER_ID
		AND MODULE = p_MODULE
		AND KEY1 = p_KEY1
		AND KEY2 = p_KEY2
		AND KEY3 = p_VALUE
		AND SETTING_NAME = 'FILTER_SETTINGS'
		AND VALUE = p_VALUE;

	DELETE APPLICATION_USER_PREFERENCES
	WHERE USER_ID = SECURITY_CONTROLS.CURRENT_USER_ID
		AND MODULE = p_MODULE
		AND KEY1 = p_KEY1
		AND KEY2 = p_KEY2
		AND NOT SETTING_NAME = 'FILTER_SETTINGS'
		AND KEY3 = p_VALUE;

END REMOVE_FILTER_PRESET;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_TIME_ZONE_LIST
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
Begin

	IF NOT CAN_READ('Public') THEN
		ERRS.RAISE_NO_READ_MODULE('Public');
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		  SELECT TIME_ZONE, TIME_ZONE_DESC
		  FROM SYSTEM_TIME_ZONE
          WHERE NVL(ENABLED,0) <> 0
		  ORDER BY 1;

END GET_TIME_ZONE_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_TIME_ZONE
	(
    p_TIME_ZONE OUT VARCHAR2
	) AS

v_STATUS NUMBER;
BEGIN

  GET_USER_PREFERENCE('?','?','?','?',g_TIME_ZONE_PREFERENCE_SETTING, p_TIME_ZONE);

  IF p_TIME_ZONE IS NULL THEN
    GET_DEFAULT_TIME_ZONE(p_TIME_ZONE);
    PUT_USER_PREFERENCE('?','?','?','?',g_TIME_ZONE_PREFERENCE_SETTING,p_TIME_ZONE,'?','?','?','?',g_TIME_ZONE_PREFERENCE_SETTING,v_STATUS);
  END IF;

EXCEPTION
    WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
	    p_TIME_ZONE := NULL;

END GET_TIME_ZONE;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_DEFAULT_TIME_ZONE
	(
	p_TIME_ZONE OUT VARCHAR2
	) AS
BEGIN
	p_Time_Zone := LOCAL_TIME_ZONE;
END GET_DEFAULT_TIME_ZONE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_TIME_ZONE
	(
    p_TIME_ZONE IN VARCHAR2,
	p_STATUS OUT NUMBER
	) AS

BEGIN
	p_STATUS := GA.SUCCESS;

    PUT_USER_PREFERENCE('?','?','?','?',g_TIME_ZONE_PREFERENCE_SETTING,p_TIME_ZONE,'?','?','?','?',g_TIME_ZONE_PREFERENCE_SETTING,p_STATUS);

END PUT_TIME_ZONE;
----------------------------------------------------------------------------------------------------
PROCEDURE RESOLVE_INTERVAL
  (
  p_INTERVAL_NAME_GUESS IN VARCHAR2,
  p_INTERVAL_NAME OUT VARCHAR2,
  p_INTERVAL_NUM OUT NUMBER
  ) AS -- THIS FUNCTION RESOLVES THE TRUE INTERAVL NAME AND NUMBER GIVEN A GUESS E.G. HH, HR, H, ETC
       -- INTERVAL NUMBER REPRESENTS HOW MANY INTERVALS CAN FIT IN A DAY (E.G. 24 HOURS, 48 30 MIN, ETC)
BEGIN

    p_INTERVAL_NAME := GET_INTERVAL_ABBREVIATION(p_INTERVAL_NAME_GUESS);

    IF p_INTERVAL_NAME IS NULL THEN -- IT RETURNS NULL FOR HOUR
      p_INTERVAL_NAME := 'HH';
    END IF;

    p_INTERVAL_NUM := CASE  UPPER(p_INTERVAL_NAME)
      WHEN 'HH' THEN 24
      WHEN 'MI15' THEN 96
      WHEN 'MI10' THEN 144
      WHEN 'MI5' THEN 288
      WHEN 'MI30' THEN 48
      ELSE 24
    END;

END RESOLVE_INTERVAL;
----------------------------------------------------------------------------------------------------
PROCEDURE FALL_BACK_DATE
(
 p_DATE IN DATE,
 p_FALL_BACK_DATE OUT DATE
) AS -- JUST A WRAPPER AROUND THE DST_FALL_BACK_DATE FUNCTION

BEGIN

     p_FALL_BACK_DATE := dst_fall_back_date(p_DATE);

END FALL_BACK_DATE;
----------------------------------------------------------------------------------------------------
PROCEDURE SPRING_AHEAD_DATE
(
 p_DATE IN DATE,
 p_SPRING_AHEAD_DATE OUT DATE
) AS

BEGIN

     p_SPRING_AHEAD_DATE := DST_SPRING_AHEAD_DATE(p_DATE);

END SPRING_AHEAD_DATE;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_DATABROWSER_DST_CONFIG
(
   p_INTERVAL IN VARCHAR2,
   p_INTERVAL_NAME OUT VARCHAR2,
   p_INTERVAL_NUM OUT NUMBER,
   p_CONFIG_NAME OUT VARCHAR2,
   p_FALL_BACK_HOUR OUT NUMBER,
   p_SPRING_AHEAD_HOUR OUT NUMBER
) AS

v_FALL_BACK_OPTION VARCHAR2(1);
v_DST_SPRING_AHEAD_OPTION VARCHAR2(1);

BEGIN

    GET_DST_OPTIONS(v_DST_SPRING_AHEAD_OPTION, v_FALL_BACK_OPTION);

    IF v_DST_SPRING_AHEAD_OPTION = 'A' THEN
       p_SPRING_AHEAD_HOUR := 2;
    END IF;

    IF v_DST_SPRING_AHEAD_OPTION = 'B' THEN
       p_SPRING_AHEAD_HOUR := 3;
    END IF;

    IF v_DST_SPRING_AHEAD_OPTION = 'C' THEN
       p_SPRING_AHEAD_HOUR := 24;
    END IF;

    IF v_FALL_BACK_OPTION = 'A' THEN
       p_FALL_BACK_HOUR := 2;
    END IF;

    IF v_FALL_BACK_OPTION = 'B' THEN
       p_FALL_BACK_HOUR := 25;
    END IF;

    RESOLVE_INTERVAL( p_INTERVAL, p_INTERVAL_NAME, p_INTERVAL_NUM);

    p_CONFIG_NAME := 'DATA_BROWSER_GRID_' || UPPER(TRIM(p_INTERVAL_NAME));

END GET_DATABROWSER_DST_CONFIG;
----------------------------------------------------------------------------------------------------
-- This procedure dictates whether the Data Browser is DST observant, it currently only
-- uses the Time Zone string, but it can be changed to use any report parameter also.
PROCEDURE IS_DST
(
  p_TIME_ZONE IN VARCHAR2,
  p_IS_DST OUT NUMBER,
  p_STATUS OUT NUMBER
) AS

BEGIN

  SELECT Z.IS_DST_OBSERVANT INTO p_IS_DST
  FROM SYSTEM_TIME_ZONE Z
  WHERE UPPER(Z.TIME_ZONE) = UPPER(p_TIME_ZONE);

  p_STATUS := GA.SUCCESS;

END IS_DST;
----------------------------------------------------------------------------------------------------
-- Retrieve all message definitions
PROCEDURE GET_MESSAGE_DEFINITIONS
	(
	p_MESSAGE_TYPE IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT MESSAGE_ID,
			MESSAGE_TYPE,
			MESSAGE_NUMBER,
			MESSAGE_TEXT,
			MESSAGE_DESC,
			MESSAGE_SOLUTION,
			MESSAGE_IDENT
		FROM MESSAGE_DEFINITION
		WHERE p_MESSAGE_TYPE IN (CONSTANTS.ALL_STRING, MESSAGE_TYPE)
		ORDER BY 2,3;
END GET_MESSAGE_DEFINITIONS;
----------------------------------------------------------------------------------------------------
-- Retrieve the list of all message types currently in use
PROCEDURE LIST_MESSAGE_TYPES
	(
	p_INCLUDE_ALL IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT CONSTANTS.ALL_STRING as MESSAGE_TYPE
		FROM DUAL
		WHERE p_INCLUDE_ALL = 1
		UNION ALL
		SELECT MESSAGE_TYPE
		FROM (SELECT DISTINCT MESSAGE_TYPE
			FROM MESSAGE_DEFINITION
			ORDER BY 1);
END LIST_MESSAGE_TYPES;
----------------------------------------------------------------------------------------------------
FUNCTION GET_NEW_MESSAGE_NUMBER
	(
	p_MESSAGE_TYPE IN VARCHAR2
	) RETURN NUMBER IS
v_MAX_NUM  NUMBER := CASE WHEN p_MESSAGE_TYPE = 'ORA' THEN 20999 ELSE 99999 END;
v_LAST_NUM NUMBER;
CURSOR cur_MSGCODES IS
	SELECT MESSAGE_NUMBER
	FROM MESSAGE_DEFINITION
	WHERE MESSAGE_TYPE = p_MESSAGE_TYPE
	ORDER BY 1 DESC;
BEGIN
	FOR v_MSGCODE IN cur_MSGCODES LOOP
		-- message numbers start at the top of the range and counts down
		IF v_LAST_NUM IS NULL THEN
			-- first one? return the top of the range
			IF v_MSGCODE.MESSAGE_NUMBER < v_MAX_NUM THEN
				RETURN v_MAX_NUM;
			END IF;
		ELSE
			-- found a gap? return the largest number available
			IF v_MSGCODE.MESSAGE_NUMBER < v_LAST_NUM-1 THEN
				RETURN v_LAST_NUM-1;
			END IF;
		END IF;
		v_LAST_NUM := v_MSGCODE.MESSAGE_NUMBER;
	END LOOP;

	-- return the next smallest number (or the top of the range if there were no numbers)
	RETURN NVL(v_LAST_NUM-1, v_MAX_NUM);
END GET_NEW_MESSAGE_NUMBER;
----------------------------------------------------------------------------------------------------
-- Save a message definition. If p_MESSAGE_NUMBER is NULL, then add a new message.
PROCEDURE PUT_MESSAGE_DEFINITION
	(
	p_MESSAGE_TYPE IN VARCHAR2,
	p_MESSAGE_NUMBER IN NUMBER,
	p_MESSAGE_IDENT	IN VARCHAR2,
	p_MESSAGE_TEXT IN VARCHAR2,
	p_MESSAGE_DESC IN VARCHAR2,
	p_MESSAGE_SOLUTION IN VARCHAR2
	) AS
v_MESSAGE_NUMBER 	MESSAGE_DEFINITION.MESSAGE_NUMBER%TYPE;
v_MESSAGE_ID 		MESSAGE_DEFINITION.MESSAGE_ID%TYPE;
BEGIN
	IF NOT SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_MANAGE_MSGCODES, SD.g_ALL_DATA_ENTITY_ID, CONSTANTS.NOT_ASSIGNED) THEN
		ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_MANAGE_MSGCODES);
	END IF;

	UPDATE MESSAGE_DEFINITION
		SET MESSAGE_TEXT = p_MESSAGE_TEXT,
			MESSAGE_DESC = p_MESSAGE_DESC,
			MESSAGE_SOLUTION = p_MESSAGE_SOLUTION,
			MESSAGE_IDENT = UPPER(p_MESSAGE_IDENT)
	WHERE MESSAGE_TYPE = UPPER(p_MESSAGE_TYPE)
		AND MESSAGE_NUMBER = p_MESSAGE_NUMBER;

	IF SQL%NOTFOUND THEN
		-- get new message number
		v_MESSAGE_NUMBER := GET_NEW_MESSAGE_NUMBER(UPPER(p_MESSAGE_TYPE));

		SELECT OID.NEXTVAL INTO v_MESSAGE_ID
		FROM DUAL;

		INSERT INTO MESSAGE_DEFINITION (
			MESSAGE_ID,
			MESSAGE_TYPE,
			MESSAGE_NUMBER,
			MESSAGE_TEXT,
			MESSAGE_DESC,
			MESSAGE_SOLUTION,
			MESSAGE_IDENT)
		VALUES (
			v_MESSAGE_ID,
			UPPER(p_MESSAGE_TYPE),
			v_MESSAGE_NUMBER,
			p_MESSAGE_TEXT,
			p_MESSAGE_DESC,
			p_MESSAGE_SOLUTION,
			UPPER(p_MESSAGE_IDENT));
	END IF;

END PUT_MESSAGE_DEFINITION;
----------------------------------------------------------------------------------------------------
-- Delete a message definition.
PROCEDURE REMOVE_MESSAGE_DEFINITION
	(
	p_MESSAGE_ID IN NUMBER
	) AS
BEGIN
	IF NOT SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_MANAGE_MSGCODES, SD.g_ALL_DATA_ENTITY_ID, CONSTANTS.NOT_ASSIGNED) THEN
		ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_MANAGE_MSGCODES);
	END IF;

	DELETE MESSAGE_DEFINITION WHERE MESSAGE_ID = p_MESSAGE_ID;
END REMOVE_MESSAGE_DEFINITION;
----------------------------------------------------------------------------------------------------
FUNCTION GET_CURRENT_USER_EMAIL_ADDR RETURN VARCHAR2 IS
	v_USER_NAME APPLICATION_USER.USER_NAME%TYPE;
	v_EMAIL_ADDR APPLICATION_USER.EMAIL_ADDR%TYPE;
BEGIN
	v_USER_NAME := SECURITY_INFO.CURRENT_USER;

	SELECT EMAIL_ADDR
	INTO v_EMAIL_ADDR
	FROM APPLICATION_USER
	WHERE USER_NAME = v_USER_NAME;

	RETURN v_EMAIL_ADDR;

END GET_CURRENT_USER_EMAIL_ADDR;
----------------------------------------------------------------------------------------------------
-- This functions takes the Schedule Fill inputs (Begin Date, End Date, TimeZone, Template String,
-- Begin Hour, End Hour and Include Holidays) and Interval String (5 Minute,10 Minute,15 Minute,30 Minute,
-- Hour,Day,Week,Month,Quarter,Year), and returns the collection of Schedule Date for these parameters.
FUNCTION GET_SCHEDULE_DATES
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_TEMPLATE IN VARCHAR,
	p_BEGIN_HOUR IN NUMBER,
	p_END_HOUR IN NUMBER,
	p_INCLUDE_HOLIDAYS IN NUMBER,
	p_INTERVAL IN VARCHAR2, -- 5 Minute,10 Minute,15 Minute,30 Minute,Hour,Day,Week,Month,Quarter,Year
	p_USE_SCHEDULING_DATES IN NUMBER := 1,
	p_EDC_ID IN NUMBER := NULL -- used for determining which holiday set to use
	)
RETURN DATE_COLLECTION PIPELINED AS

	v_SCHEDULE_DATE DATE;
	v_SCHEDULE_END_DATE DATE;
	v_DAY CHAR(3);
	v_HOUR NUMBER;
	v_ANY_DAY BOOLEAN;
	v_WEEK_DAY BOOLEAN;
	v_WEEK_END BOOLEAN;
	v_MON BOOLEAN;
	v_TUE BOOLEAN;
	v_WED BOOLEAN;
	v_THU BOOLEAN;
	v_FRI BOOLEAN;
	v_SAT BOOLEAN;
	v_SUN BOOLEAN;
	v_ALL BOOLEAN;
	v_ON BOOLEAN;
	v_OFF BOOLEAN;
	v_ON_PEAK BOOLEAN;
	v_OFF_PEAK BOOLEAN;
	v_YES CHAR(1) := '1';
	v_DAY_SCHEDULE BOOLEAN;
	v_DATE DATE;
	v_IS_HOLIDAY BOOLEAN;
	v_IS_ON_PEAK NUMBER;
	v_ADD_SCHEDULE_DATE BOOLEAN := FALSE;
	v_DAY_INTERVAL_TYPE NUMBER(1);
	v_TRUNC_INTERVAL VARCHAR2(8) := NVL(GET_INTERVAL_ABBREVIATION(p_INTERVAL), 'HH');

BEGIN
	v_SCHEDULE_DATE := p_BEGIN_DATE;
	v_SCHEDULE_END_DATE := p_END_DATE;

	IF INTERVAL_IS_ATLEAST_DAILY(p_INTERVAL) THEN
		v_DAY_SCHEDULE := TRUE;
		v_DAY_INTERVAL_TYPE := 2;
		v_SCHEDULE_DATE := ADD_SECONDS_TO_DATE(TRUNC(p_BEGIN_DATE,v_TRUNC_INTERVAL), 1);
		v_SCHEDULE_END_DATE := ADD_SECONDS_TO_DATE(TRUNC(p_END_DATE,v_TRUNC_INTERVAL), 1);
	ELSE
		v_DAY_SCHEDULE := FALSE;
		v_DAY_INTERVAL_TYPE := 1;
		UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_SCHEDULE_DATE, v_SCHEDULE_END_DATE);
		-- advance to the first interval of the day
		v_SCHEDULE_DATE := ADVANCE_DATE(TRUNC(v_SCHEDULE_DATE,'HH'), p_INTERVAL);
	END IF;

	-- Decode the Template String
	v_ANY_DAY := SUBSTR(p_TEMPLATE,1,1) = v_YES;
	v_WEEK_DAY := SUBSTR(p_TEMPLATE,2,1) = v_YES;
	v_WEEK_END := SUBSTR(p_TEMPLATE,3,1) = v_YES;
	v_MON := SUBSTR(p_TEMPLATE,4,1) = v_YES;
	v_TUE := SUBSTR(p_TEMPLATE,5,1) = v_YES;
	v_WED := SUBSTR(p_TEMPLATE,6,1) = v_YES;
	v_THU := SUBSTR(p_TEMPLATE,7,1) = v_YES;
	v_FRI := SUBSTR(p_TEMPLATE,8,1) = v_YES;
	v_SAT := SUBSTR(p_TEMPLATE,9,1) = v_YES;
	v_SUN := SUBSTR(p_TEMPLATE,10,1) = v_YES;
	v_ALL := SUBSTR(p_TEMPLATE,11,1) = v_YES;
	v_ON := SUBSTR(p_TEMPLATE,12,1) = v_YES;
	v_OFF := SUBSTR(p_TEMPLATE,13,1) = v_YES;
	v_ON_PEAK := SUBSTR(p_TEMPLATE,15,1) = v_YES;
	v_OFF_PEAK := SUBSTR(p_TEMPLATE,16,1) = v_YES;

	-- Handle On-Peak and Off-Peak schedule using SYSTEM_DATE_TIME table
	IF v_ON_PEAK OR v_OFF_PEAK THEN
		SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, v_SCHEDULE_DATE, v_SCHEDULE_END_DATE);
		IF v_ON_PEAK THEN
			v_IS_ON_PEAK := 1;
		ELSE
			v_IS_ON_PEAK := 0;
		END IF;

		FOR v_DATES IN (SELECT SDT.CUT_DATE, SDT.CUT_DATE_SCHEDULING
						FROM SYSTEM_DATE_TIME SDT
						WHERE SDT.TIME_ZONE = p_TIME_ZONE
							AND SDT.DATA_INTERVAL_TYPE = v_DAY_INTERVAL_TYPE
							AND SDT.DAY_TYPE = '1'
							AND SDT.CUT_DATE_SCHEDULING BETWEEN v_SCHEDULE_DATE AND v_SCHEDULE_END_DATE
							AND SDT.IS_ON_PEAK = v_IS_ON_PEAK
							AND SDT.MINIMUM_INTERVAL_NUMBER >= GET_INTERVAL_NUMBER(p_INTERVAL))
		LOOP
			PIPE ROW (CASE WHEN p_USE_SCHEDULING_DATES=1 THEN v_DATES.CUT_DATE_SCHEDULING ELSE v_DATES.CUT_DATE END);
		END LOOP;
	ELSE
		-- Loop over the intervals of the specified time period.
		WHILE v_SCHEDULE_DATE <= v_SCHEDULE_END_DATE LOOP
			v_ADD_SCHEDULE_DATE := FALSE;

			IF v_DAY_SCHEDULE THEN
				v_DATE := v_SCHEDULE_DATE;
			ELSE
				v_DATE := FROM_CUT(v_SCHEDULE_DATE, p_TIME_ZONE);
			END IF;

			v_DAY := SUBSTR(TO_CHAR(v_DATE-1/86400, 'DAY'), 1, 3);
			-- add 59 minutes to make sure we get hour as hour-ending
			v_HOUR := TO_NUMBER(TO_CHAR(v_DATE+59/(24*60), 'HH24'));
			IF v_HOUR = 0 THEN
			   v_HOUR := 24;
			END IF;

			-- Determine if the schedule date is a holiday and whether to include.
			v_IS_HOLIDAY := IS_HOLIDAY(TRUNC(v_DATE-1/86400), p_EDC_ID);

			IF v_DAY_SCHEDULE THEN
				IF v_TRUNC_INTERVAL = 'DD' THEN
					IF (v_ANY_DAY
						OR (v_WEEK_DAY AND v_DAY IN ('MON','TUE','WED','THU','FRI'))
						OR (v_WEEK_END AND v_DAY IN ('SAT','SUN'))
						OR (v_MON AND v_DAY = 'MON')
						OR (v_TUE AND v_DAY = 'TUE')
						OR (v_WED AND v_DAY = 'WED')
						OR (v_THU AND v_DAY = 'THU')
						OR (v_FRI AND v_DAY = 'FRI')
						OR (v_SAT AND v_DAY = 'SAT')
						OR (v_SUN AND v_DAY = 'SUN')
						OR (p_INCLUDE_HOLIDAYS <> 0 AND v_IS_HOLIDAY)) THEN
						v_ADD_SCHEDULE_DATE := TRUE;
					END IF;
				ELSE
					v_ADD_SCHEDULE_DATE := TRUE;
				END IF;
			ELSIF (v_ANY_DAY
				OR (v_WEEK_DAY AND v_DAY IN ('MON','TUE','WED','THU','FRI'))
				OR (v_WEEK_END AND v_DAY IN ('SAT','SUN'))
				OR (v_MON AND v_DAY = 'MON')
				OR (v_TUE AND v_DAY = 'TUE')
				OR (v_WED AND v_DAY = 'WED')
				OR (v_THU AND v_DAY = 'THU')
				OR (v_FRI AND v_DAY = 'FRI')
				OR (v_SAT AND v_DAY = 'SAT')
				OR (v_SUN AND v_DAY = 'SUN')
				OR (p_INCLUDE_HOLIDAYS <> 0 AND v_IS_HOLIDAY)) THEN
					IF v_ALL
						OR (v_ON AND v_HOUR BETWEEN p_BEGIN_HOUR AND p_END_HOUR)
						OR (v_OFF AND v_HOUR NOT BETWEEN p_BEGIN_HOUR AND p_END_HOUR) THEN
						v_ADD_SCHEDULE_DATE := TRUE;
					END IF;
			END IF;

			-- Add schedule date to the collection
			IF (v_ADD_SCHEDULE_DATE) THEN
				-- not "scheduling" dates? then trunc to minute (only scheduling dates feature day+ intervals
				-- as 1-second-past-midnight)
				PIPE ROW (CASE WHEN p_USE_SCHEDULING_DATES=1 THEN v_SCHEDULE_DATE ELSE TRUNC(v_SCHEDULE_DATE,'MI') END);
			END IF;
			v_SCHEDULE_DATE := ADVANCE_DATE(v_SCHEDULE_DATE, p_INTERVAL);
		END LOOP;
	END IF;

	RETURN;
END;
----------------------------------------------------------------------------------------------------
FUNCTION SYSTEM_LABEL_CONTAINS
	(
	p_MODEL_ID IN NUMBER,
	p_MODULE IN VARCHAR,
	p_KEY1 IN VARCHAR,
	p_KEY2 IN VARCHAR,
	p_KEY3 IN VARCHAR,
	p_LABEL_VALUE IN VARCHAR2,
	p_IGNORE_CASE IN BOOLEAN := FALSE
	) RETURN BOOLEAN IS

	v_CURSOR GA.REFCURSOR;
	v_STATUS NUMBER(9);

	v_STR_TABLE STRING_COLLECTION;

BEGIN

	SP.GET_SYSTEM_LABEL_VALUES(p_MODEL_ID, p_MODULE, p_KEY1,
				p_KEY2, p_KEY3, v_STATUS, v_CURSOR);

	FETCH v_CURSOR BULK COLLECT INTO v_STR_TABLE;

	RETURN UT.STRING_COLLECTION_CONTAINS(v_STR_TABLE, p_LABEL_VALUE, NOT p_IGNORE_CASE);
END SYSTEM_LABEL_CONTAINS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SCHEDULE_TEMPLATES
    (
    p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the a list of all the schedule templates and their attributes.

BEGIN
    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT CASE WHEN TEMPLATE_TYPE = 0 THEN '<html><b>' || TEMPLATE_NAME || '</b><html>'ELSE TEMPLATE_NAME END AS TEMPLATE_NAME,
			TEMPLATE_TYPE,
			DAY_OF_WEEK,
			INCLUDE_HOLIDAYS,
			START_HOUR_END,
			STOP_HOUR_END,
			INTERIOR_PERIOD,
			TEMPLATE_ORDER
		FROM SCHEDULE_TEMPLATE
		ORDER BY TEMPLATE_TYPE, TEMPLATE_ORDER, TEMPLATE_NAME;

END GET_SCHEDULE_TEMPLATES;
----------------------------------------------------------------------------------------------------
END SP;
/
