CREATE OR REPLACE PACKAGE DER_CAPACITY_ENGINE IS
--Revision $Revision: 1.7 $

-- Engine package for the DER Capacity Forecast/Backcast Engine

FUNCTION WHAT_VERSION RETURN VARCHAR;

PROCEDURE CALC_VPP_RESULT_FROM_SEGMENT
	(
	p_IS_EXTERNAL IN NUMBER,
	p_SERVICE_CODE IN CHAR,
	p_SCENARIO_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ENTITY_DOMAIN_ID IN NUMBER := CONSTANTS.ALL_ID,
	p_ENTITY_IDS IN NUMBER_COLLECTION := NULL,
	p_DATES_ARE_CUT IN BOOLEAN := TRUE
	);

PROCEDURE CALC_VPP_RESULT_FROM_SEGMENT
	(
	p_IS_EXTERNAL IN NUMBER,
	p_SERVICE_CODE IN CHAR,
	p_SCENARIO_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PROGRAM_ZONE_PAIRS IN ID_SET_COLLECTION,
	p_DATES_ARE_CUT IN BOOLEAN := TRUE
	);

PROCEDURE CALC_SEGMENT_RESULT_FROM_DER
	(
	p_SERVICE_CODE IN CHAR,
	p_SCENARIO_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ENTITY_DOMAIN_ID IN NUMBER := CONSTANTS.ALL_ID,
	p_ENTITY_IDS IN NUMBER_COLLECTION := NULL,
	p_IS_EXTERNAL IN NUMBER := 0,
	p_THEN_ROLL_UP_TO_VPP IN BOOLEAN := TRUE
	);

PROCEDURE PUT_SEGMENT_EXTERNAL_RESULT
	(
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_FEEDER_SEGMENT_ID IN NUMBER,
	p_PROGRAM_ID IN NUMBER,
	p_DATES IN DATE_COLLECTION,
	p_AVAILABILITY IN NUMBER_COLLECTION,
	p_CAPABILITY IN NUMBER_COLLECTION,
	p_DER_COUNT IN NUMBER_COLLECTION,
	p_SERVICE_CODE IN CHAR := CONSTANTS.CODE_FORECAST,
	p_SCENARIO_ID IN NUMBER := GA.BASE_SCENARIO_ID
	);

PROCEDURE PROCESS_EVENT_SCHEDULE
	(
	p_EVENT_ID IN NUMBER,
	p_CUT_BEGIN IN DATE,
	p_CUT_END IN DATE,
	p_MESSAGE OUT VARCHAR2
	);

FUNCTION GET_SEGMENT_RESULT_ID
	(
	p_FEEDER_SEGMENT_ID IN NUMBER,
	p_FEEDER_ID IN NUMBER,
	p_SUB_STATION_ID IN NUMBER,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_PROGRAM_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_SERVICE_CODE IN CHAR,
	p_IS_EXTERNAL IN NUMBER,
	p_CREATE_IF_NOT_FOUND IN BOOLEAN := FALSE
	)RETURN NUMBER;

-- Internal parallel function (public to allow SQL access)
FUNCTION PIPE_LOAD_RESULT_CALENDAR_DATA
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_IN_CURSOR IN SYS_REFCURSOR
	) RETURN LOAD_RESULT_DATA_TABLE
PIPELINED
PARALLEL_ENABLE (PARTITION p_IN_CURSOR BY ANY);

-- Internal parallel function (public to allow SQL access)
FUNCTION PIPE_LOAD_RESULT_LOSS_DATA
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_IN_CURSOR IN SYS_REFCURSOR
	) RETURN LOAD_RESULT_DATA_TABLE
PIPELINED
PARALLEL_ENABLE (PARTITION p_IN_CURSOR BY ANY);

-- Internal parallel function (public to allow SQL access)
FUNCTION STORE_LOAD_RESULT_HITS_DATA
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_IN_CURSOR IN SYS_REFCURSOR
	) RETURN LOAD_RESULT_DATA_TABLE
PIPELINED
PARALLEL_ENABLE (PARTITION p_IN_CURSOR BY ANY);

-- Main entry point for running a DER Forecast/Backcast
PROCEDURE RUN_DER_FORECAST
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ENTITY_IDs IN NUMBER_COLLECTION,
	p_SERVICE_CODE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PROCESS_ID OUT NUMBER,
	p_PROCESS_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR2,
	p_CALCULATE_FULL_SUMMARY IN NUMBER := 1,
	p_SCENARIO_ID IN NUMBER := GA.BASE_SCENARIO_ID,
	p_TRACE_ON IN NUMBER := 0,
	p_DISABLE_PARALLEL_EXECUTION IN NUMBER := NULL
	);

-- This gets called before a large set of external results are stored.
PROCEDURE BEFORE_STORE_EXT_DER_RESULTS;

--Stores DER-Level External Results into the
--  DER_DAILY_RESULT and Load Result tables.
PROCEDURE STORE_EXTERNAL_DER_RESULTS
	(
	p_DER_ID IN NUMBER,
	p_SERVICE_CODE IN CHAR,
	p_RESULT_INTERVAL IN VARCHAR2,
	p_LOAD_DATES IN DATE_COLLECTION,
	p_LOAD_SHAPE IN NUMBER_COLLECTION
	);

-- This gets called after a large set of external results are stored.
--   It initiates a re-calc of any loss factors that were referenced.
PROCEDURE AFTER_STORE_EXT_DER_RESULTS;



--This profile interval can be set to an interval to use a generated test profile for unit testing.
--  If we are in production mode, it should be set to NULL.
--  Note that it will only work if you disable parallel execution.
g_TEST_PROFILE_INTERVAL VARCHAR2(32) := NULL;


PROCEDURE RESOLVE_DER_SEG_RESULT_DEFAULT
(
	p_FEEDER_SEGMENT_ID IN NUMBER,
	p_PROGRAM_ID IN NUMBER,
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_DATES IN DATE_COLLECTION
);

FUNCTION GET_TIME_ZONE_FOR_ZONE
	(
	p_SERVICE_ZONE_ID IN NUMBER
	) RETURN VARCHAR2;
	
FUNCTION GET_HOLIDAY_SET_FOR_SERV_LOC
	(
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_DATE IN DATE
	) RETURN NUMBER;

END DER_CAPACITY_ENGINE;
/
CREATE OR REPLACE PACKAGE BODY DER_CAPACITY_ENGINE IS

c_SYSDICT_MODULE CONSTANT VARCHAR2(24) := 'DER Capacity Forecast';

--Temp Table Names
c_TEMP_TABLE_CAL CONSTANT VARCHAR2(30) := 'TEMP_LOAD_RESULT_CAL_LIST';
c_TEMP_TABLE_LOSS CONSTANT VARCHAR2(30) := 'TEMP_LOAD_RESULT_LOSS_LIST';
c_TEMP_TABLE_HITS CONSTANT VARCHAR2(30) := 'TEMP_LOAD_RESULT_HITS_LIST';

--Load Result Entity Data Types
c_DATA_TYPE_DER_AVAILABILITY CONSTANT VARCHAR2(16) := 'DER Availability';
c_DATA_TYPE_DER_EXTERNAL CONSTANT VARCHAR2(16) := 'DER External';

--Loss Factor Types
c_LOSS_TYPE_TX CONSTANT VARCHAR2(16) := 'Transmission';
c_LOSS_TYPE_DX CONSTANT VARCHAR2(16) := 'Distribution';

--Load Result types
c_LOAD_RESULT_TYPE_ENTITY CONSTANT VARCHAR2(16) := 'Entity';
c_LOAD_RESULT_TYPE_CALENDAR CONSTANT VARCHAR2(16) := 'Calendar';
c_LOAD_RESULT_TYPE_LOSS CONSTANT VARCHAR2(16) := 'Loss Factor';

TYPE rec_RESULT_DATA IS RECORD (RESULT_DATE DATE, RESULT_VAL NUMBER);
TYPE t_RESULT_DATA_CURSOR IS REF CURSOR RETURN rec_RESULT_DATA;

TYPE rec_CANDIDATE IS RECORD (DER_ID NUMBER);
TYPE t_CANDIDATE_CURSOR IS REF CURSOR RETURN rec_CANDIDATE;

--Date Range of External DER Results
g_MIN_DER_RESULT_DATE DATE := NULL;
g_MAX_DER_RESULT_DATE DATE := NULL;


----------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
	RETURN '$Revision: 1.7 $';
END WHAT_VERSION;
----------------------------------------------------------------------------------------------------
FUNCTION IS_PARALLEL_EXECUTION_DISABLED RETURN BOOLEAN IS
BEGIN
	RETURN UT.BOOLEAN_FROM_STRING(NVL(GET_DICTIONARY_VALUE('Disable Parallel Excecution', 0, c_SYSDICT_MODULE),'N'));
END IS_PARALLEL_EXECUTION_DISABLED;
----------------------------------------------------------------------------------------------------
-- Return a multiplier that can be used to convert data to the appropriate unit (MWh vs. MW)
-- If Act_On_Internal_Data is set, then the multiplier is being applied to *internal* data to convert it to the new format for exporting.
--   Otherwise, the multiplier is being applied to *External* data to convert it into our internal data format (always MWh or KWh).
FUNCTION GET_UNIT_MULTIPLIER
	(
	p_SERVICE_CODE IN CHAR,
	p_ACT_ON_INTERNAL_DATA IN BOOLEAN,
	p_DATA_INTERVAL IN VARCHAR2
	) RETURN NUMBER IS
	v_AS_MW BOOLEAN;
	v_MULTIPLIER NUMBER;
BEGIN

	IF p_SERVICE_CODE = CONSTANTS.CODE_FORECAST THEN
		v_AS_MW := UT.BOOLEAN_FROM_STRING(NVL(GET_DICTIONARY_VALUE('External Forecast as MW', 0, 'Load Management', 'Demand Response'),'Y'));
	ELSE
		v_AS_MW := UT.BOOLEAN_FROM_STRING(NVL(GET_DICTIONARY_VALUE('External Results as MW', 0, 'Load Management', 'Demand Response'),'Y'));
	END IF;

	-- Our results are always stored in MWh/KWh, so if the flag is false, then no conversion is necessary
	IF NOT v_AS_MW THEN
		v_MULTIPLIER := 1;
	ELSE
		IF p_ACT_ON_INTERNAL_DATA THEN
			v_MULTIPLIER := DATE_UTIL.GET_INTERVAL_DIVISOR('', p_DATA_INTERVAL);
		ELSE
			v_MULTIPLIER := DATE_UTIL.GET_INTERVAL_DIVISOR(p_DATA_INTERVAL, '');
		END IF;
	END IF;

	RETURN v_MULTIPLIER;

END GET_UNIT_MULTIPLIER;
----------------------------------------------------------------------------------------------------
FUNCTION GET_EDC_ID_FOR_SERVICE_LOC(p_SERVICE_LOCATION_ID IN NUMBER, p_DAY IN DATE) RETURN NUMBER IS
	v_EDC_ID NUMBER(9);
BEGIN
	SELECT NVL(AE.EDC_ID, 0)
	INTO v_EDC_ID
	FROM ACCOUNT_SERVICE_LOCATION ASL, ACCOUNT_EDC AE
	WHERE ASL.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
		AND p_DAY BETWEEN ASL.BEGIN_DATE AND NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE)
		AND AE.ACCOUNT_ID(+) = ASL.ACCOUNT_ID
		AND p_DAY BETWEEN AE.BEGIN_DATE(+) AND NVL(AE.END_DATE(+), CONSTANTS.HIGH_DATE);

	RETURN v_EDC_ID;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE('Could not EDC ID for '||TEXT_UTIL.TO_CHAR_ENTITY(p_SERVICE_LOCATION_ID, EC.ED_SERVICE_LOCATION, TRUE));
		RETURN 0;
END GET_EDC_ID_FOR_SERVICE_LOC;
----------------------------------------------------------------------------------------------------
FUNCTION GET_TIME_ZONE_FOR_DER(p_DER_ID IN NUMBER) RETURN VARCHAR2 IS
	v_TZ VARCHAR2(16);
BEGIN
	SELECT NVL(Z.TIME_ZONE, LOCAL_TIME_ZONE)
	INTO v_TZ
	FROM DISTRIBUTED_ENERGY_RESOURCE D, SERVICE_LOCATION SL, SERVICE_ZONE Z
	WHERE D.DER_ID = p_DER_ID
		AND SL.SERVICE_LOCATION_ID = D.SERVICE_LOCATION_ID
		AND Z.SERVICE_ZONE_ID = SL.SERVICE_ZONE_ID;

	IF v_TZ = CONSTANTS.UNDEFINED_ATTRIBUTE THEN
		v_TZ := LOCAL_TIME_ZONE;
	END IF;

	RETURN v_TZ;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE('Could not Retrieve Time Zone for '||TEXT_UTIL.TO_CHAR_ENTITY(p_DER_ID, EC.ED_DER, TRUE));
		RETURN LOCAL_TIME_ZONE;
END GET_TIME_ZONE_FOR_DER;
----------------------------------------------------------------------------------------------------
FUNCTION GET_TIME_ZONE_FOR_ZONE
	(
	p_SERVICE_ZONE_ID IN NUMBER
	) RETURN VARCHAR2 IS
	v_TZ VARCHAR2(16);
BEGIN

	SELECT NVL(SZ.TIME_ZONE, LOCAL_TIME_ZONE)
	INTO v_TZ
	FROM SERVICE_ZONE SZ
	WHERE  SZ.SERVICE_ZONE_ID = p_SERVICE_ZONE_ID;

	IF v_TZ = CONSTANTS.UNDEFINED_ATTRIBUTE THEN
		v_TZ := LOCAL_TIME_ZONE;
	END IF;

	RETURN v_TZ;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE('Could not Retrieve Time Zone for '||
			TEXT_UTIL.TO_CHAR_ENTITY(p_SERVICE_ZONE_ID, EC.ED_SERVICE_ZONE, TRUE));
		RETURN LOCAL_TIME_ZONE;
END GET_TIME_ZONE_FOR_ZONE;
----------------------------------------------------------------------------------------------------
FUNCTION GET_TIME_ZONE_FOR_VPP
	(
	p_VPP_ID IN NUMBER
	) RETURN VARCHAR2 IS
	v_TZ VARCHAR2(16);
BEGIN

	SELECT NVL(SZ.TIME_ZONE, LOCAL_TIME_ZONE)
	INTO v_TZ
	FROM VIRTUAL_POWER_PLANT V, SERVICE_ZONE SZ
	WHERE V.VPP_ID = p_VPP_ID
		AND SZ.SERVICE_ZONE_ID = V.SERVICE_ZONE_ID;

	IF v_TZ = CONSTANTS.UNDEFINED_ATTRIBUTE THEN
		v_TZ := LOCAL_TIME_ZONE;
	END IF;

	RETURN v_TZ;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE('Could not Retrieve Time Zone for '||TEXT_UTIL.TO_CHAR_ENTITY(p_VPP_ID, EC.ED_VPP, TRUE));
		RETURN LOCAL_TIME_ZONE;
END GET_TIME_ZONE_FOR_VPP;
--------------------------------------------------------------------------
PROCEDURE GET_LOSS_PATTERNS_FOR_SEGMENT
	(
	p_DAY IN DATE,
	p_FEEDER_SEGMENT_ID IN NUMBER,
	p_TX_PATTERN_ID OUT NUMBER,
	p_DX_PATTERN_ID OUT NUMBER
	) AS
BEGIN
	SELECT MAX(TX.PATTERN_ID), MAX(DX.PATTERN_ID)
	INTO p_TX_PATTERN_ID, p_DX_PATTERN_ID
	FROM TX_FEEDER_SEGMENT_LOSS_FACTOR T, LOSS_FACTOR_MODEL TX, LOSS_FACTOR_MODEL DX
	WHERE T.FEEDER_SEGMENT_ID = p_FEEDER_SEGMENT_ID
		AND p_DAY BETWEEN T.BEGIN_DATE AND NVL(T.END_DATE, CONSTANTS.HIGH_DATE)
		AND TX.LOSS_FACTOR_ID(+) = T.LOSS_FACTOR_ID
		AND TX.LOSS_TYPE(+) = c_LOSS_TYPE_TX
		AND p_DAY BETWEEN TX.BEGIN_DATE(+) AND NVL(TX.END_DATE(+), CONSTANTS.HIGH_DATE)
		AND DX.LOSS_FACTOR_ID(+) = T.LOSS_FACTOR_ID
		AND DX.LOSS_TYPE(+) = c_LOSS_TYPE_DX
		AND p_DAY BETWEEN DX.BEGIN_DATE(+) AND NVL(DX.END_DATE(+), CONSTANTS.HIGH_DATE);
END GET_LOSS_PATTERNS_FOR_SEGMENT;
--------------------------------------------------------------------------
PROCEDURE GET_STATIC_DER_ASSIGNMENTS
	(
	p_DER_ID IN NUMBER,
	p_DER_TYPE_ID OUT NUMBER,
	p_EXTERNAL_SYSTEM_ID OUT NUMBER,
	p_SERVICE_ZONE_ID OUT NUMBER,
	p_SUB_STATION_ID OUT NUMBER,
	p_FEEDER_ID OUT NUMBER,
	p_FEEDER_SEGMENT_ID OUT NUMBER,
	p_SERVICE_LOCATION_ID OUT NUMBER,
	p_WEATHER_STATION_ID OUT NUMBER
	) AS
	v_EXTRA_MESSAGE VARCHAR2(256);
BEGIN

	-- TODO -- THESE SHOULD PROBABLY BE CACHED RATHER THAN REQUERIED EVERY DAY.

	-- Get the easy attributes of the DER and SL
	v_EXTRA_MESSAGE := 'finding DER and Service Location attributes';
	SELECT R.DER_TYPE_ID,
		NVL(R.EXTERNAL_SYSTEM_ID,CONSTANTS.NOT_ASSIGNED),
		NVL(SL.SERVICE_ZONE_ID,CONSTANTS.NOT_ASSIGNED),
		NVL(SL.SUB_STATION_ID, CONSTANTS.NOT_ASSIGNED),
		NVL(SL.FEEDER_ID,CONSTANTS.NOT_ASSIGNED),
		NVL(SL.FEEDER_SEGMENT_ID,CONSTANTS.NOT_ASSIGNED),
		NVL(SL.SERVICE_LOCATION_ID,CONSTANTS.NOT_ASSIGNED),
		NVL(SL.WEATHER_STATION_ID,CONSTANTS.NOT_ASSIGNED)
	INTO p_DER_TYPE_ID,
		p_EXTERNAL_SYSTEM_ID,
		p_SERVICE_ZONE_ID,
		p_SUB_STATION_ID,
		p_FEEDER_ID,
		p_FEEDER_SEGMENT_ID,
		p_SERVICE_LOCATION_ID,
		p_WEATHER_STATION_ID
	FROM DISTRIBUTED_ENERGY_RESOURCE R, SERVICE_LOCATION SL
	WHERE R.DER_ID = p_DER_ID
		AND R.SERVICE_LOCATION_ID = SL.SERVICE_LOCATION_ID;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_RAISE('Error while '||v_EXTRA_MESSAGE||' for '||TEXT_UTIL.TO_CHAR_ENTITY(p_DER_ID, EC.ED_DER, TRUE));

END GET_STATIC_DER_ASSIGNMENTS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_TEMPORAL_DER_ASSIGNMENTS
	(
	p_DER_ID IN NUMBER,
	p_DAY IN DATE,
	p_DER_IS_ACTIVE OUT NUMBER,
	p_PROGRAM_ID OUT NUMBER,
	p_ACCOUNT_ID OUT NUMBER,
	p_EDC_ID OUT NUMBER,
	p_CALENDAR_ID OUT NUMBER,
	p_RESULT_INTERVAL OUT VARCHAR2
	) AS
	v_SERVICE_LOCATION_ID NUMBER(9);
BEGIN

	-- TODO -- THESE SHOULD PROBABLY BE CACHED RATHER THAN REQUERIED EVERY DAY.

	-- Get the Account and EDC attributes
	BEGIN
		SELECT ASL.ACCOUNT_ID, NVL(AE.EDC_ID, 0), D.SERVICE_LOCATION_ID,
			--A DER is active when its Account is Active, its Date Range includes the current day, and it has no DER Status Record.
			CASE WHEN p_DAY BETWEEN D.BEGIN_DATE AND NVL(D.END_DATE, CONSTANTS.HIGH_DATE) AND ASTATN.IS_ACTIVE = 1 AND DSTAT.STATUS_NAME IS NULL THEN 1 ELSE 0 END
		INTO p_ACCOUNT_ID, p_EDC_ID, v_SERVICE_LOCATION_ID, p_DER_IS_ACTIVE
		FROM DISTRIBUTED_ENERGY_RESOURCE D, DER_STATUS DSTAT, ACCOUNT_SERVICE_LOCATION ASL, ACCOUNT_EDC AE, ACCOUNT_STATUS ASTAT, ACCOUNT_STATUS_NAME ASTATN
		WHERE D.DER_ID = p_DER_ID
			AND ASL.SERVICE_LOCATION_ID = D.SERVICE_LOCATION_ID
			AND p_DAY BETWEEN ASL.BEGIN_DATE AND NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE)
			AND AE.ACCOUNT_ID(+) = ASL.ACCOUNT_ID
			AND p_DAY BETWEEN AE.BEGIN_DATE(+) AND NVL(AE.END_DATE(+), CONSTANTS.HIGH_DATE)
			AND DSTAT.DER_ID(+) = D.DER_ID
			AND p_DAY BETWEEN DSTAT.BEGIN_DATE(+) AND NVL(DSTAT.END_DATE(+), CONSTANTS.HIGH_DATE)
			AND ASTAT.ACCOUNT_ID(+) = ASL.ACCOUNT_ID
			AND p_DAY BETWEEN ASTAT.BEGIN_DATE(+) AND NVL(ASTAT.END_DATE(+), CONSTANTS.HIGH_DATE)
			AND ASTATN.STATUS_NAME(+) = ASTAT.STATUS_NAME;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_DER_IS_ACTIVE := 0;
			ERRS.LOG_AND_CONTINUE(TEXT_UTIL.TO_CHAR_ENTITY(p_DER_ID, EC.ED_DER, TRUE)||' has no valid Account/EDC/Status Assignment on '||TEXT_UTIL.TO_CHAR_DATE(p_DAY));
			RETURN;
		WHEN TOO_MANY_ROWS THEN
			ERRS.LOG_AND_RAISE(TEXT_UTIL.TO_CHAR_ENTITY(p_DER_ID, EC.ED_DER, TRUE)||' has an invalid Account/EDC/Status assignment on '||TEXT_UTIL.TO_CHAR_DATE(p_DAY));
	END;

	-- Get the Program attributes
	SELECT NVL(MAX(DP.PROGRAM_ID),0), MAX(P.PROGRAM_INTERVAL)
	INTO p_PROGRAM_ID, p_RESULT_INTERVAL
	FROM DER_PROGRAM DP, SERVICE_LOCATION SL, PROGRAM P
	WHERE DP.DER_ID = p_DER_ID
		AND p_DAY BETWEEN DP.BEGIN_DATE AND NVL(DP.END_DATE, CONSTANTS.HIGH_DATE)
		AND P.PROGRAM_ID = DP.PROGRAM_ID
		AND SL.SERVICE_LOCATION_ID = v_SERVICE_LOCATION_ID;

	--Get the Calendar of the DER, or fall back to the DER Type if there is not one for DER.
	SELECT MAX(CALENDAR_ID)
	INTO p_CALENDAR_ID
	FROM DER_CALENDAR
	WHERE DER_ID = p_DER_ID
		AND CASE_ID = GA.BASE_CASE_ID
		AND p_DAY BETWEEN BEGIN_DATE AND NVL(END_DATE, CONSTANTS.HIGH_DATE);

	IF p_CALENDAR_ID IS NULL THEN
		SELECT NVL(MAX(CALENDAR_ID),0)
		INTO p_CALENDAR_ID
		FROM DER_TYPE_CALENDAR C, DISTRIBUTED_ENERGY_RESOURCE R
		WHERE R.DER_ID = p_DER_ID
			AND C.DER_TYPE_ID = R.DER_TYPE_ID
			AND C.CASE_ID = GA.BASE_CASE_ID
			AND p_DAY BETWEEN C.BEGIN_DATE AND NVL(C.END_DATE, CONSTANTS.HIGH_DATE);
	END IF;

	--Get the Interval of the Calendar if there was not one for the Program.
	IF p_RESULT_INTERVAL IS NULL THEN
		p_RESULT_INTERVAL := FP.GET_INTERVAL_FOR_CALENDAR(p_CALENDAR_ID, p_DAY);
	END IF;

	--If still null, default to Hour.
	IF p_RESULT_INTERVAL IS NULL THEN
		p_RESULT_INTERVAL := 'Hour';
	END IF;

END GET_TEMPORAL_DER_ASSIGNMENTS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_DER_FACTORS
	(
	p_DER_ID IN NUMBER,
	p_PROGRAM_ID IN NUMBER,
	p_DAY IN DATE,
	p_SERVICE_CODE IN CHAR,
	p_SCALE_FACTOR OUT NUMBER,
	p_FAILURE_RATE OUT NUMBER,
	p_OPT_OUT_RATE OUT NUMBER,
	p_OVERRIDE_RATE OUT NUMBER
	) AS
	v_EXTRA_MESSAGE VARCHAR2(256);
	v_DER_COUNT NUMBER;
	v_USE_DEFAULT NUMBER(1);
	v_DER_TYPE_ID NUMBER(9);
	v_DEFAULT_PCT1 DER_TYPE.DEFAULT_FAILURE_PCT%TYPE;
	v_DEFAULT_PCT2 DER_TYPE.DEFAULT_FAILURE_PCT%TYPE;
BEGIN
	-- TODO -- THESE SHOULD PROBABLY BE CACHED RATHER THAN REQUERIED EVERY DAY.

	-- Get the Scale Factor
	v_EXTRA_MESSAGE := 'finding the DER Scale Factor';
	SELECT NVL(MAX(SCALE_FACTOR),1)
	INTO p_SCALE_FACTOR
	FROM DER_SCALE_FACTOR D
	WHERE D.DER_ID = p_DER_ID
		AND D.CASE_ID = GA.BASE_CASE_ID
		AND p_DAY BETWEEN D.BEGIN_DATE AND NVL(D.END_DATE, CONSTANTS.HIGH_DATE);

	-- Multiply by the DER Count
	SELECT NVL(MAX(COUNT),1)
	INTO v_DER_COUNT
	FROM DER_PROGRAM
	WHERE DER_ID = p_DER_ID
		AND PROGRAM_ID = p_PROGRAM_ID
		AND p_DAY BETWEEN BEGIN_DATE AND NVL(END_DATE, CONSTANTS.HIGH_DATE);
	p_SCALE_FACTOR := p_SCALE_FACTOR * v_DER_COUNT;

	IF p_SERVICE_CODE = CONSTANTS.CODE_BACKCAST THEN
		p_FAILURE_RATE := 0;
		p_OPT_OUT_RATE := 0;
		p_OVERRIDE_RATE := 0;
	ELSE

		-- Get the Failure Rate
		v_EXTRA_MESSAGE := 'finding the DER Failure Rate';
		SELECT DT.DER_TYPE_ID, DT.USE_DEFAULT_FAIL_PCT, NVL(DT.DEFAULT_FAILURE_PCT,0)
		INTO v_DER_TYPE_ID, v_USE_DEFAULT, v_DEFAULT_PCT1
		FROM DISTRIBUTED_ENERGY_RESOURCE D, DER_TYPE DT
		WHERE D.DER_ID = p_DER_ID
			AND DT.DER_TYPE_ID = D.DER_TYPE_ID;

		IF UT.BOOLEAN_FROM_NUMBER(v_USE_DEFAULT) THEN
			p_FAILURE_RATE := v_DEFAULT_PCT1/100;
		ELSE
			SELECT CASE WHEN SUM(HIST.TOTAL_SIGNALED) = 0 THEN 0 ELSE NVL(SUM(HIST.TOTAL_FAILED)/SUM(HIST.TOTAL_SIGNALED),0) END
			INTO p_FAILURE_RATE
			FROM DER_TYPE_HISTORY HIST
			WHERE HIST.DER_TYPE_ID = v_DER_TYPE_ID;
		END IF;

		-- Get the Opt-Out and Override Rates
		v_EXTRA_MESSAGE := 'finding Opt-Out and Override Rates';
		IF p_PROGRAM_ID = CONSTANTS.NOT_ASSIGNED THEN
			p_OPT_OUT_RATE := 0;
			p_OVERRIDE_RATE := 0;
		ELSE
			SELECT P.USE_DEFAULT_OPT_OUT_OVERRIDE, NVL(P.DEFAULT_OPT_OUT_PCT,0), NVL(P.DEFAULT_OVERRIDE_PCT,0)
			INTO v_USE_DEFAULT, v_DEFAULT_PCT1, v_DEFAULT_PCT2
			FROM PROGRAM P
			WHERE P.PROGRAM_ID = p_PROGRAM_ID;

			IF UT.BOOLEAN_FROM_NUMBER(v_USE_DEFAULT) THEN
				p_OPT_OUT_RATE := v_DEFAULT_PCT1/100;
				p_OVERRIDE_RATE := v_DEFAULT_PCT2/100;
			ELSE
				SELECT CASE WHEN SUM(HIST.TOTAL_SIGNALED) = 0 THEN 0 ELSE NVL(SUM(HIST.TOTAL_OPT_OUTS)/SUM(HIST.TOTAL_SIGNALED),0) END,
					CASE WHEN SUM(HIST.TOTAL_SIGNALED) = 0 THEN 0 ELSE NVL(SUM(HIST.TOTAL_OVERRIDES)/SUM(HIST.TOTAL_SIGNALED),0) END
				INTO p_OPT_OUT_RATE, p_OVERRIDE_RATE
				FROM PROGRAM_EVENT_HISTORY HIST
				WHERE HIST.PROGRAM_ID = p_PROGRAM_ID;
			END IF;
		END IF;
	END IF;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_RAISE('Error while '||v_EXTRA_MESSAGE||' for '||TEXT_UTIL.TO_CHAR_ENTITY(p_DER_ID, EC.ED_DER, TRUE));

END GET_DER_FACTORS;
----------------------------------------------------------------------------------------------------
FUNCTION GET_LOAD_RESULT_ENTITY_ID
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_SERVICE_CODE IN CHAR,
	p_SCENARIO_ID IN NUMBER,
	p_SOURCE_TIME_ZONE IN VARCHAR2,
	p_DATA_TYPE IN VARCHAR2,
	p_RESULT_INTERVAL IN VARCHAR2
	) RETURN NUMBER IS

	PRAGMA AUTONOMOUS_TRANSACTION;
	v_LOAD_RESULT_ID NUMBER(9);

	FUNCTION GET_ID RETURN NUMBER IS
		v_ID NUMBER;
	BEGIN
		SELECT LOAD_RESULT_ID
		INTO v_ID
		FROM LOAD_RESULT_ENTITY
		WHERE ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID
			AND ENTITY_ID = p_ENTITY_ID
			AND SERVICE_CODE = p_SERVICE_CODE
			AND SCENARIO_ID = p_SCENARIO_ID
			AND SOURCE_TIME_ZONE = p_SOURCE_TIME_ZONE
			AND DATA_TYPE = p_DATA_TYPE
			AND RESULT_INTERVAL = p_RESULT_INTERVAL;
		RETURN v_ID;
	END GET_ID;
BEGIN

	BEGIN
		v_LOAD_RESULT_ID := GET_ID;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			--Create it if it did not exist.
			SELECT DER_RESULT_ID.NEXTVAL INTO v_LOAD_RESULT_ID FROM DUAL;
			INSERT INTO LOAD_RESULT(LOAD_RESULT_ID, LOAD_RESULT_TYPE, ENTRY_DATE)
				VALUES (v_LOAD_RESULT_ID, c_LOAD_RESULT_TYPE_ENTITY, SYSDATE);
			BEGIN
				INSERT INTO LOAD_RESULT_ENTITY(ENTITY_DOMAIN_ID, ENTITY_ID, SERVICE_CODE, SCENARIO_ID, SOURCE_TIME_ZONE, DATA_TYPE, RESULT_INTERVAL, LOAD_RESULT_ID, ENTRY_DATE)
					VALUES (p_ENTITY_DOMAIN_ID, p_ENTITY_ID, p_SERVICE_CODE, p_SCENARIO_ID, p_SOURCE_TIME_ZONE, p_DATA_TYPE, p_RESULT_INTERVAL, v_LOAD_RESULT_ID, SYSDATE);
				COMMIT;
			EXCEPTION
				WHEN DUP_VAL_ON_INDEX THEN
					ERRS.LOG_AND_CONTINUE('Unable to create Load Result.  Querying again.', LOGS.c_LEVEL_DEBUG);
					ROLLBACK;
					v_LOAD_RESULT_ID := GET_ID;  --Let it raise the error if it happens again.
			END;
	END;

	RETURN v_LOAD_RESULT_ID;

EXCEPTION
	WHEN OTHERS THEN
		ROLLBACK;
		ERRS.LOG_AND_RAISE;

END GET_LOAD_RESULT_ENTITY_ID;
----------------------------------------------------------------------------------------------------
FUNCTION GET_LOAD_RESULT_LOSS_ID
	(
	p_LOSS_FACTOR_PATTERN_ID IN NUMBER,
	p_SERVICE_CODE IN CHAR,
	p_SCENARIO_ID IN NUMBER,
	p_SOURCE_TIME_ZONE IN VARCHAR2,
	p_RESULT_INTERVAL IN VARCHAR2,
	p_ADD_TO_TEMP_TABLE IN BOOLEAN
	) RETURN NUMBER IS

	PRAGMA AUTONOMOUS_TRANSACTION;
	v_LOAD_RESULT_ID NUMBER(9);

	FUNCTION GET_ID RETURN NUMBER IS
		v_ID NUMBER;
	BEGIN
		SELECT LOAD_RESULT_ID
		INTO v_ID
		FROM LOAD_RESULT_LOSS_FACTOR
		WHERE LOSS_FACTOR_PATTERN_ID = p_LOSS_FACTOR_PATTERN_ID
			AND SERVICE_CODE = p_SERVICE_CODE
			AND SCENARIO_ID = p_SCENARIO_ID
			AND SOURCE_TIME_ZONE = p_SOURCE_TIME_ZONE
			AND RESULT_INTERVAL = p_RESULT_INTERVAL;
		RETURN v_ID;
	END GET_ID;
BEGIN

	IF p_LOSS_FACTOR_PATTERN_ID IS NULL THEN
		RETURN NULL;
	END IF;

	BEGIN
		v_LOAD_RESULT_ID := GET_ID;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			--Create it if it did not exist.
			SELECT DER_RESULT_ID.NEXTVAL INTO v_LOAD_RESULT_ID FROM DUAL;
			INSERT INTO LOAD_RESULT(LOAD_RESULT_ID, LOAD_RESULT_TYPE, ENTRY_DATE)
				VALUES (v_LOAD_RESULT_ID, c_LOAD_RESULT_TYPE_LOSS, SYSDATE);
			BEGIN
				INSERT INTO LOAD_RESULT_LOSS_FACTOR(LOSS_FACTOR_PATTERN_ID, SERVICE_CODE, SCENARIO_ID, SOURCE_TIME_ZONE, RESULT_INTERVAL, LOAD_RESULT_ID, ENTRY_DATE)
					VALUES (p_LOSS_FACTOR_PATTERN_ID, p_SERVICE_CODE, p_SCENARIO_ID, p_SOURCE_TIME_ZONE, p_RESULT_INTERVAL, v_LOAD_RESULT_ID, SYSDATE);
				COMMIT;
			EXCEPTION
				WHEN DUP_VAL_ON_INDEX THEN
					ERRS.LOG_AND_CONTINUE('Unable to create Load Result.  Querying again.', LOGS.c_LEVEL_DEBUG);
					ROLLBACK;
					v_LOAD_RESULT_ID := GET_ID;  --Let it raise the error if it happens again.
			END;
	END;

	IF p_ADD_TO_TEMP_TABLE THEN
		INSERT INTO TEMP_LOAD_RESULT_LOSS_LIST (LOAD_RESULT_ID) VALUES (v_LOAD_RESULT_ID);
	END IF;
	COMMIT;

	RETURN v_LOAD_RESULT_ID;

EXCEPTION
	WHEN OTHERS THEN
		ROLLBACK;
		ERRS.LOG_AND_RAISE;
END GET_LOAD_RESULT_LOSS_ID;
----------------------------------------------------------------------------------------------------
FUNCTION GET_LOAD_RESULT_CALENDAR_ID
	(
	p_CALENDAR_ID IN NUMBER,
	p_SERVICE_CODE IN CHAR,
	p_SCENARIO_ID IN NUMBER,
	p_WEATHER_STATION_ID IN NUMBER,
	p_SOURCE_TIME_ZONE IN VARCHAR2,
	p_RESULT_INTERVAL IN VARCHAR2
	) RETURN NUMBER IS

	PRAGMA AUTONOMOUS_TRANSACTION;
	v_LOAD_RESULT_ID NUMBER(9);

	FUNCTION GET_ID RETURN NUMBER IS
		v_ID NUMBER;
	BEGIN
		SELECT LOAD_RESULT_ID
		INTO v_ID
		FROM LOAD_RESULT_CALENDAR
		WHERE CALENDAR_ID = p_CALENDAR_ID
			AND SERVICE_CODE = p_SERVICE_CODE
			AND SCENARIO_ID = p_SCENARIO_ID
			AND WEATHER_STATION_ID = p_WEATHER_STATION_ID
			AND SOURCE_TIME_ZONE = p_SOURCE_TIME_ZONE
			AND RESULT_INTERVAL = p_RESULT_INTERVAL;
		RETURN v_ID;
	END GET_ID;

BEGIN

	BEGIN
		v_LOAD_RESULT_ID := GET_ID;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			--Create it if it did not exist.
			SELECT DER_RESULT_ID.NEXTVAL INTO v_LOAD_RESULT_ID FROM DUAL;
			INSERT INTO LOAD_RESULT(LOAD_RESULT_ID, LOAD_RESULT_TYPE, ENTRY_DATE)
				VALUES (v_LOAD_RESULT_ID, c_LOAD_RESULT_TYPE_CALENDAR, SYSDATE);
			BEGIN
				INSERT INTO LOAD_RESULT_CALENDAR(CALENDAR_ID, SERVICE_CODE, SCENARIO_ID, WEATHER_STATION_ID, SOURCE_TIME_ZONE, RESULT_INTERVAL, LOAD_RESULT_ID, ENTRY_DATE)
					VALUES (p_CALENDAR_ID, p_SERVICE_CODE, p_SCENARIO_ID, p_WEATHER_STATION_ID, p_SOURCE_TIME_ZONE, p_RESULT_INTERVAL, v_LOAD_RESULT_ID, SYSDATE);
				COMMIT;
			EXCEPTION
				WHEN DUP_VAL_ON_INDEX THEN
					ERRS.LOG_AND_CONTINUE('Unable to create Load Result.  Querying again.', LOGS.c_LEVEL_DEBUG);
					ROLLBACK;
					v_LOAD_RESULT_ID := GET_ID;  --Let it raise the error if it happens again.
			END;
	END;

	RETURN v_LOAD_RESULT_ID;

EXCEPTION
	WHEN OTHERS THEN
		ROLLBACK;
		ERRS.LOG_AND_RAISE;

END GET_LOAD_RESULT_CALENDAR_ID;
----------------------------------------------------------------------------------------------------
FUNCTION GET_VPP_RESULT_ID
	(
	p_PROGRAM_ID IN NUMBER,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_SERVICE_CODE IN CHAR,
	p_IS_EXTERNAL IN NUMBER,
	p_SCENARIO_ID IN NUMBER := GA.BASE_SCENARIO_ID,
	p_CREATE IN BOOLEAN := FALSE
	) RETURN NUMBER IS

	v_WORK_ID NUMBER(9);

BEGIN

	SELECT MAX(RST.DER_VPP_RESULT_ID) INTO v_WORK_ID
	FROM DER_VPP_RESULT RST
	WHERE RST.PROGRAM_ID = p_PROGRAM_ID
		AND RST.SERVICE_ZONE_ID = p_SERVICE_ZONE_ID
		AND RST.IS_EXTERNAL = p_IS_EXTERNAL
		AND RST.SERVICE_CODE = p_SERVICE_CODE
		AND RST.SCENARIO_ID = p_SCENARIO_ID;

	IF p_CREATE AND v_WORK_ID IS NULL THEN
		SELECT DER_RESULT_ID.NEXTVAL
		INTO v_WORK_ID
		FROM DUAL;

		INSERT INTO DER_VPP_RESULT (DER_VPP_RESULT_ID, PROGRAM_ID, SERVICE_ZONE_ID, IS_EXTERNAL, SERVICE_CODE,
			SCENARIO_ID)
		VALUES (v_WORK_ID, p_PROGRAM_ID, p_SERVICE_ZONE_ID, p_IS_EXTERNAL, p_SERVICE_CODE, p_SCENARIO_ID);
	END IF;

	RETURN v_WORK_ID;

END GET_VPP_RESULT_ID;
--------------------------------------------------------------------------
FUNCTION GET_PROGRAM_ZONE_PAIRS
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ENTITY_IDS IN NUMBER_COLLECTION
	) RETURN ID_SET_COLLECTION IS

	v_PROG_SZ_IDS ID_SET_COLLECTION;

BEGIN

	IF p_ENTITY_DOMAIN_ID = CONSTANTS.ALL_ID OR (p_ENTITY_IDS IS NULL AND p_ENTITY_DOMAIN_ID = EC.ED_PROGRAM) THEN

			SELECT ID_SET(P.PROGRAM_ID, SZ.SERVICE_ZONE_ID)
			BULK COLLECT INTO v_PROG_SZ_IDS
			FROM PROGRAM P,
				SERVICE_ZONE SZ;

		ELSIF p_ENTITY_DOMAIN_ID = EC.ED_VPP THEN

			-- WE HAVE TO HANDLE NULL VPP COLLECTION SEPERATELY SINCE THEN
			-- WE ONLY WANT TO GET ACTUAL VPPS, NOT ALL PROGRAM / SERVICE ZONE COMBOS
			IF p_ENTITY_IDS IS NULL THEN

				SELECT ID_SET(VPP.PROGRAM_ID, VPP.SERVICE_ZONE_ID)
				BULK COLLECT INTO v_PROG_SZ_IDS
				FROM VIRTUAL_POWER_PLANT VPP;

			ELSE

				SELECT ID_SET(VPP.PROGRAM_ID, VPP.SERVICE_ZONE_ID)
				BULK COLLECT INTO v_PROG_SZ_IDS
				FROM VIRTUAL_POWER_PLANT VPP,
					TABLE(CAST(p_ENTITY_IDS AS NUMBER_COLLECTION)) x
				WHERE x.COLUMN_VALUE = VPP.VPP_ID;

			END IF;

		ELSE -- EC.ED_PROGRAM

			SELECT ID_SET(P.PROGRAM_ID, SZ.SERVICE_ZONE_ID)
			BULK COLLECT INTO v_PROG_SZ_IDS
			FROM PROGRAM P,
				SERVICE_ZONE SZ,
				TABLE(CAST(p_ENTITY_IDS AS NUMBER_COLLECTION)) x
			WHERE P.PROGRAM_ID = x.COLUMN_VALUE;

	END IF;

	RETURN v_PROG_SZ_IDS;

END GET_PROGRAM_ZONE_PAIRS;
--------------------------------------------------------------------------
PROCEDURE CALC_VPP_RESULT_FROM_SEGMENT
	(
	p_IS_EXTERNAL IN NUMBER,
	p_SERVICE_CODE IN CHAR,
	p_SCENARIO_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PROGRAM_ZONE_PAIRS IN ID_SET_COLLECTION,
	p_DATES_ARE_CUT IN BOOLEAN := TRUE
	) AS

	v_VPP_WORK_ID NUMBER(9);
	v_CUT_BEGIN_DATE DATE;
	v_CUT_END_DATE DATE;
	v_IDX BINARY_INTEGER;

BEGIN

	IF p_DATES_ARE_CUT THEN
		v_CUT_BEGIN_DATE := p_BEGIN_DATE;
		v_CUT_END_DATE := p_END_DATE;
	END IF;

	v_IDX := p_PROGRAM_ZONE_PAIRS.FIRST;
	WHILE p_PROGRAM_ZONE_PAIRS.EXISTS(v_IDX) LOOP
		v_VPP_WORK_ID := GET_VPP_RESULT_ID(p_PROGRAM_ZONE_PAIRS(v_IDX).ID1, p_PROGRAM_ZONE_PAIRS(v_IDX).ID2, p_SERVICE_CODE, p_IS_EXTERNAL, p_SCENARIO_ID, TRUE);
		IF NOT p_DATES_ARE_CUT THEN
			UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, GET_TIME_ZONE_FOR_ZONE(p_PROGRAM_ZONE_PAIRS(v_IDX).ID2), v_CUT_BEGIN_DATE, v_CUT_END_DATE);
		END IF;

		DELETE FROM DER_VPP_RESULT_DATA DT
		WHERE DT.DER_VPP_RESULT_ID = v_VPP_WORK_ID
			AND DT.RESULT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE;

		IF p_SERVICE_CODE = CONSTANTS.CODE_FORECAST AND p_IS_EXTERNAL = 0 THEN

		-- IF SERVICE_CODE = FORECAST AND IS INTERNAL, THEN WE USE THE MIX OF INTERNAL AND EXTERNAL FORECAST DATA
		-- DETERMINED BY DER_SEG_RESULT_IS_EXT (VIA DER_SEGMENT_FORECAST_DATA)
			INSERT INTO DER_VPP_RESULT_DATA (DER_VPP_RESULT_ID, RESULT_DATE, LOAD_VAL, FAILURE_VAL, OPT_OUT_VAL,
				OVERRIDE_VAL, TX_LOSS_VAL, DX_LOSS_VAL, DER_COUNT, UNCONSTRAINED_LOAD_VAL, UNCONSTRAINED_TX_LOSS_VAL, UNCONSTRAINED_DX_LOSS_VAL)
			SELECT v_VPP_WORK_ID, DATA.RESULT_DATE, SUM(DATA.LOAD_VAL), SUM(DATA.FAILURE_VAL),
				SUM(DATA.OPT_OUT_VAL), SUM(DATA.OVERRIDE_VAL), SUM(DATA.TX_LOSS_VAL),
				SUM(DATA.DX_LOSS_VAL), SUM(DATA.DER_COUNT), SUM(DATA.UNCONSTRAINED_LOAD_VAL),
				SUM(DATA.UNCONSTRAINED_TX_LOSS_VAL), SUM(DATA.UNCONSTRAINED_DX_LOSS_VAL)
			FROM DER_SEGMENT_FORECAST_DATA DATA
			WHERE DATA.SCENARIO_ID = p_SCENARIO_ID
				AND DATA.PROGRAM_ID = p_PROGRAM_ZONE_PAIRS(v_IDX).ID1
				AND DATA.SERVICE_ZONE_ID = p_PROGRAM_ZONE_PAIRS(v_IDX).ID2
				AND DATA.RESULT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
				AND DATA.LOAD_VAL IS NOT NULL -- THE SEGMENT IS SPECIFIED AS EXTERNAL / INTERNAL,
											-- BUT THERE IS NO CORRESPONDING DATA
			GROUP BY v_VPP_WORK_ID, RESULT_DATE;

		ELSE

			INSERT INTO DER_VPP_RESULT_DATA (DER_VPP_RESULT_ID, RESULT_DATE, LOAD_VAL, FAILURE_VAL, OPT_OUT_VAL,
				OVERRIDE_VAL, TX_LOSS_VAL, DX_LOSS_VAL, DER_COUNT, UNCONSTRAINED_LOAD_VAL, UNCONSTRAINED_TX_LOSS_VAL, UNCONSTRAINED_DX_LOSS_VAL)
			SELECT v_VPP_WORK_ID, DATA.RESULT_DATE, SUM(DATA.LOAD_VAL), SUM(DATA.FAILURE_VAL), SUM(DATA.OPT_OUT_VAL),
				SUM(DATA.OVERRIDE_VAL), SUM(DATA.TX_LOSS_VAL), SUM(DATA.DX_LOSS_VAL),
				SUM(DATA.DER_COUNT),
				SUM(DATA.UNCONSTRAINED_LOAD_VAL),
				SUM(DATA.UNCONSTRAINED_TX_LOSS_VAL),
				SUM(DATA.UNCONSTRAINED_DX_LOSS_VAL)
			FROM DER_SEGMENT_RESULT RST, DER_SEGMENT_RESULT_DATA DATA
			WHERE RST.IS_EXTERNAL = p_IS_EXTERNAL
				AND RST.SERVICE_CODE = p_SERVICE_CODE
				AND RST.SCENARIO_ID = p_SCENARIO_ID
				AND RST.PROGRAM_ID = p_PROGRAM_ZONE_PAIRS(v_IDX).ID1
				AND RST.SERVICE_ZONE_ID = p_PROGRAM_ZONE_PAIRS(v_IDX).ID2
				AND DATA.DER_SEGMENT_RESULT_ID = RST.DER_SEGMENT_RESULT_ID
				AND DATA.RESULT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
			GROUP BY v_VPP_WORK_ID, RESULT_DATE;

		END IF;
		v_IDX := p_PROGRAM_ZONE_PAIRS.NEXT(v_IDX);
	END LOOP;

END CALC_VPP_RESULT_FROM_SEGMENT;
--------------------------------------------------------------------------
PROCEDURE CALC_VPP_RESULT_FROM_SEGMENT
	(
	p_IS_EXTERNAL IN NUMBER,
	p_SERVICE_CODE IN CHAR,
	p_SCENARIO_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ENTITY_DOMAIN_ID IN NUMBER := CONSTANTS.ALL_ID,
	p_ENTITY_IDS IN NUMBER_COLLECTION := NULL,
	p_DATES_ARE_CUT IN BOOLEAN := TRUE
	) AS

	v_PROG_SZ_IDS ID_SET_COLLECTION;

BEGIN

	v_PROG_SZ_IDS := GET_PROGRAM_ZONE_PAIRS(p_ENTITY_DOMAIN_ID, p_ENTITY_IDS);

	CALC_VPP_RESULT_FROM_SEGMENT(p_IS_EXTERNAL, p_SERVICE_CODE, p_SCENARIO_ID,
		p_BEGIN_DATE, p_END_DATE, v_PROG_SZ_IDS, p_DATES_ARE_CUT);

END CALC_VPP_RESULT_FROM_SEGMENT;
--------------------------------------------------------------------------
PROCEDURE CALC_SEGMENT_RESULT_FROM_DER
	(
	p_SERVICE_CODE IN CHAR,
	p_SCENARIO_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PROGRAM_ZONE_PAIR_IDS IN ID_SET_COLLECTION,
	p_IS_EXTERNAL IN NUMBER := 0,
	p_THEN_ROLL_UP_TO_VPP IN BOOLEAN := TRUE
	) AS

	v_CUT_BEGIN_DATE DATE;
	v_CUT_END_DATE DATE;
	v_DER_SEGMENT_RESULT_ID NUMBER(9);
	v_USE_REP NUMBER(1);
	v_IDX BINARY_INTEGER;

BEGIN

	--Only take "Reported" data into account when we are running a Backcast.
	IF p_SERVICE_CODE = CONSTANTS.CODE_BACKCAST AND p_IS_EXTERNAL = 0 THEN
		v_USE_REP := 1;
	ELSE
		v_USE_REP := 0;
	END IF;

	v_IDX := p_PROGRAM_ZONE_PAIR_IDS.FIRST;
	WHILE p_PROGRAM_ZONE_PAIR_IDS.EXISTS(v_IDX) LOOP

		--Delete the data by PROGRAM / SERVICE ZONE COMBO
		UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, GET_TIME_ZONE_FOR_ZONE(p_PROGRAM_ZONE_PAIR_IDS(v_IDX).ID2), v_CUT_BEGIN_DATE, v_CUT_END_DATE);
		DELETE FROM DER_SEGMENT_RESULT_DATA
		WHERE DER_SEGMENT_RESULT_ID IN (SELECT DER_SEGMENT_RESULT_ID
										FROM DER_SEGMENT_RESULT
										WHERE PROGRAM_ID = p_PROGRAM_ZONE_PAIR_IDS(v_IDX).ID1
											AND SERVICE_ZONE_ID = p_PROGRAM_ZONE_PAIR_IDS(v_IDX).ID2
											AND IS_EXTERNAL = 0
											AND SERVICE_CODE = p_SERVICE_CODE
											AND SCENARIO_ID = p_SCENARIO_ID)
			AND RESULT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE;

		--Make sure the IDs exist.
		FOR v_ROW IN
		(SELECT DISTINCT R.PROGRAM_ID, R.FEEDER_SEGMENT_ID, R.EXTERNAL_SYSTEM_ID, R.SERVICE_ZONE_ID,
			R.FEEDER_ID, R.SUB_STATION_ID
		FROM DER_DAILY_RESULT R
		WHERE R.PROGRAM_ID = p_PROGRAM_ZONE_PAIR_IDS(v_IDX).ID1
			AND R.SERVICE_ZONE_ID = p_PROGRAM_ZONE_PAIR_IDS(v_IDX).ID2
			AND R.IS_EXTERNAL = p_IS_EXTERNAL
			AND R.SERVICE_CODE = p_SERVICE_CODE
			AND R.SCENARIO_ID = p_SCENARIO_ID
			AND R.RESULT_DAY BETWEEN p_BEGIN_DATE AND p_END_DATE
			AND NOT EXISTS
				(SELECT 1 FROM DER_SEGMENT_RESULT DSR
				WHERE DSR.PROGRAM_ID = R.PROGRAM_ID
					AND DSR.FEEDER_SEGMENT_ID = R.FEEDER_SEGMENT_ID
					AND DSR.SERVICE_ZONE_ID = R.SERVICE_ZONE_ID
					AND DSR.FEEDER_ID = R.FEEDER_ID
					AND DSR.SUB_STATION_ID = R.SUB_STATION_ID
					AND DSR.EXTERNAL_SYSTEM_ID = R.EXTERNAL_SYSTEM_ID
					AND DSR.IS_EXTERNAL = R.IS_EXTERNAL
					AND DSR.SERVICE_CODE = R.SERVICE_CODE
					AND DSR.SCENARIO_ID = R.SCENARIO_ID))
		LOOP
			v_DER_SEGMENT_RESULT_ID := GET_SEGMENT_RESULT_ID(v_ROW.FEEDER_SEGMENT_ID, v_ROW.FEEDER_ID, v_ROW.SUB_STATION_ID, v_ROW.SERVICE_ZONE_ID,
				v_ROW.EXTERNAL_SYSTEM_ID, v_ROW.PROGRAM_ID, p_SCENARIO_ID, p_SERVICE_CODE, p_IS_EXTERNAL, TRUE);
		END LOOP;

		--Insert the data
		INSERT INTO DER_SEGMENT_RESULT_DATA (DER_SEGMENT_RESULT_ID, RESULT_DATE, LOAD_VAL, FAILURE_VAL, OPT_OUT_VAL, OVERRIDE_VAL, TX_LOSS_VAL, DX_LOSS_VAL, DER_COUNT, UNCONSTRAINED_LOAD_VAL, UNCONSTRAINED_TX_LOSS_VAL, UNCONSTRAINED_DX_LOSS_VAL)
		SELECT D.DER_SEGMENT_RESULT_ID,
			D.RESULT_DATE,
			SUM(D.RESULT_VAL*SCALE_FACTOR*CASE WHEN HITS.RESULT_VAL <= 0 THEN 0 ELSE 1 END*CASE WHEN v_USE_REP = 1 AND NVL(REPORTED.RESULT_VAL,0) = 0 THEN 0 ELSE 1 END)/1000,
			-SUM(D.RESULT_VAL*SCALE_FACTOR*FAILURE_RATE*CASE WHEN HITS.RESULT_VAL <= 0 THEN 0 ELSE 1 END*CASE WHEN v_USE_REP = 1 AND NVL(REPORTED.RESULT_VAL,0) = 0 THEN 0 ELSE 1 END)/1000,
			-SUM(D.RESULT_VAL*SCALE_FACTOR*OPT_OUT_RATE*CASE WHEN HITS.RESULT_VAL <= 0 THEN 0 ELSE 1 END*CASE WHEN v_USE_REP = 1 AND NVL(REPORTED.RESULT_VAL,0) = 0 THEN 0 ELSE 1 END)/1000,
			-SUM(D.RESULT_VAL*SCALE_FACTOR*OVERRIDE_RATE*CASE WHEN HITS.RESULT_VAL <= 0 THEN 0 ELSE 1 END*CASE WHEN v_USE_REP = 1 AND NVL(REPORTED.RESULT_VAL,0) = 0 THEN 0 ELSE 1 END)/1000,
			SUM(D.RESULT_VAL*SCALE_FACTOR*(1-FAILURE_RATE-OPT_OUT_RATE-OVERRIDE_RATE)*NVL(TXLF.RESULT_VAL,0)*(1+NVL(DXLF.RESULT_VAL,0))*CASE WHEN HITS.RESULT_VAL <= 0 THEN 0 ELSE 1 END*CASE WHEN v_USE_REP = 1 AND NVL(REPORTED.RESULT_VAL,0) = 0 THEN 0 ELSE 1 END)/1000,
			SUM(D.RESULT_VAL*SCALE_FACTOR*(1-FAILURE_RATE-OPT_OUT_RATE-OVERRIDE_RATE)*NVL(DXLF.RESULT_VAL,0)*CASE WHEN HITS.RESULT_VAL <= 0 THEN 0 ELSE 1 END*CASE WHEN v_USE_REP = 1 AND NVL(REPORTED.RESULT_VAL,0) = 0 THEN 0 ELSE 1 END)/1000,
			SUM(CASE WHEN D.RESULT_VAL > 0 THEN 1 ELSE 0 END*CASE WHEN v_USE_REP = 1 AND NVL(REPORTED.RESULT_VAL,0) = 0 THEN 0 ELSE 1 END),
			SUM(D.RESULT_VAL*SCALE_FACTOR*(1-FAILURE_RATE-OPT_OUT_RATE-OVERRIDE_RATE)*CASE WHEN v_USE_REP = 1 AND NVL(REPORTED.RESULT_VAL,0) = 0 THEN 0 ELSE 1 END)/1000,
			SUM(D.RESULT_VAL*SCALE_FACTOR*(1-FAILURE_RATE-OPT_OUT_RATE-OVERRIDE_RATE)*NVL(TXLF.RESULT_VAL,0)*(1+NVL(DXLF.RESULT_VAL,0))*CASE WHEN v_USE_REP = 1 AND NVL(REPORTED.RESULT_VAL,0) = 0 THEN 0 ELSE 1 END)/1000,
			SUM(D.RESULT_VAL*SCALE_FACTOR*(1-FAILURE_RATE-OPT_OUT_RATE-OVERRIDE_RATE)*NVL(DXLF.RESULT_VAL,0)*CASE WHEN v_USE_REP = 1 AND NVL(REPORTED.RESULT_VAL,0) = 0 THEN 0 ELSE 1 END)/1000
		FROM (SELECT DSR.DER_SEGMENT_RESULT_ID,
					DD.TX_LOSS_FACTOR_RESULT_ID,
					DD.DX_LOSS_FACTOR_RESULT_ID,
					DD.HITS_REMAINING_RESULT_ID,
					DD.SCALE_FACTOR,
					DD.FAILURE_RATE,
					DD.OPT_OUT_RATE,
					DD.OVERRIDE_RATE,
					LS.RESULT_DATE,
					LS.RESULT_VAL,
					D_REPORTED.LOAD_SHAPE_RESULT_ID AS REPORTED_RESULT_ID
				FROM DER_SEGMENT_RESULT DSR,
					DER_DAILY_RESULT DD,
					DER_DAILY_RESULT D_REPORTED,
					LOAD_RESULT_DATA LS
				WHERE DSR.PROGRAM_ID = p_PROGRAM_ZONE_PAIR_IDS(v_IDX).ID1
					AND DSR.SERVICE_ZONE_ID = p_PROGRAM_ZONE_PAIR_IDS(v_IDX).ID2
					AND DSR.IS_EXTERNAL = p_IS_EXTERNAL
					AND DSR.SERVICE_CODE = p_SERVICE_CODE
					AND DSR.SCENARIO_ID = p_SCENARIO_ID
					AND DD.FEEDER_SEGMENT_ID = DSR.FEEDER_SEGMENT_ID
					AND DD.FEEDER_ID = DSR.FEEDER_ID
					AND DD.SUB_STATION_ID = DSR.SUB_STATION_ID
					AND DD.SERVICE_ZONE_ID = DSR.SERVICE_ZONE_ID
					AND DD.PROGRAM_ID = DSR.PROGRAM_ID
					AND DD.EXTERNAL_SYSTEM_ID = DSR.EXTERNAL_SYSTEM_ID
					AND DD.IS_EXTERNAL = DSR.IS_EXTERNAL
					AND DD.SERVICE_CODE = DSR.SERVICE_CODE
					AND DD.SCENARIO_ID = DSR.SCENARIO_ID
					AND DD.RESULT_DAY BETWEEN p_BEGIN_DATE AND p_END_DATE
					AND D_REPORTED.DER_ID(+) = DD.DER_ID
					AND D_REPORTED.IS_EXTERNAL(+) = 1
					AND D_REPORTED.SERVICE_CODE(+) = CONSTANTS.CODE_BACKCAST
					AND D_REPORTED.SCENARIO_ID(+) = GA.BASE_SCENARIO_ID
					AND D_REPORTED.RESULT_DAY(+) = DD.RESULT_DAY
					AND LS.LOAD_RESULT_ID = DD.LOAD_SHAPE_RESULT_ID
					AND LS.RESULT_DATE BETWEEN DD.CUT_BEGIN_DATE AND DD.CUT_END_DATE
				)D,
			LOAD_RESULT_DATA TXLF,
			LOAD_RESULT_DATA DXLF,
			LOAD_RESULT_DATA HITS,
			LOAD_RESULT_DATA REPORTED
		WHERE TXLF.LOAD_RESULT_ID(+) = D.TX_LOSS_FACTOR_RESULT_ID
			AND TXLF.RESULT_DATE(+) = D.RESULT_DATE
			AND DXLF.LOAD_RESULT_ID(+) = D.DX_LOSS_FACTOR_RESULT_ID
			AND DXLF.RESULT_DATE(+) = D.RESULT_DATE
			AND HITS.LOAD_RESULT_ID(+) = D.HITS_REMAINING_RESULT_ID
			AND HITS.RESULT_DATE(+) = D.RESULT_DATE
			AND REPORTED.LOAD_RESULT_ID(+) = D.REPORTED_RESULT_ID
			AND REPORTED.RESULT_DATE(+) = D.RESULT_DATE
		GROUP BY D.DER_SEGMENT_RESULT_ID, D.RESULT_DATE;

		v_IDX := p_PROGRAM_ZONE_PAIR_IDS.NEXT(v_IDX);

	END LOOP;

	IF p_THEN_ROLL_UP_TO_VPP THEN
		CALC_VPP_RESULT_FROM_SEGMENT(p_IS_EXTERNAL, p_SERVICE_CODE, p_SCENARIO_ID, p_BEGIN_DATE, p_END_DATE,
			p_PROGRAM_ZONE_PAIR_IDS, FALSE);
	END IF;

END CALC_SEGMENT_RESULT_FROM_DER;
--------------------------------------------------------------------------
PROCEDURE CALC_SEGMENT_RESULT_FROM_DER
	(
	p_SERVICE_CODE IN CHAR,
	p_SCENARIO_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ENTITY_DOMAIN_ID IN NUMBER := CONSTANTS.ALL_ID,
	p_ENTITY_IDS IN NUMBER_COLLECTION := NULL,
	p_IS_EXTERNAL IN NUMBER := 0,
	p_THEN_ROLL_UP_TO_VPP IN BOOLEAN := TRUE
	) AS

	v_PROG_SZ_IDS ID_SET_COLLECTION;

BEGIN

	v_PROG_SZ_IDS := GET_PROGRAM_ZONE_PAIRS(p_ENTITY_DOMAIN_ID, p_ENTITY_IDS);

	CALC_SEGMENT_RESULT_FROM_DER(p_SERVICE_CODE, p_SCENARIO_ID, p_BEGIN_DATE,
		p_END_DATE, v_PROG_SZ_IDS, p_IS_EXTERNAL, p_THEN_ROLL_UP_TO_VPP);

END CALC_SEGMENT_RESULT_FROM_DER;
----------------------------------------------------------------------------------------------------
FUNCTION GET_SEGMENT_ZONE_ID
(
	p_FEEDER_SEGMENT_ID IN NUMBER
) RETURN NUMBER IS

	v_SZ_ID NUMBER(9);

BEGIN

	SELECT SZ.SERVICE_ZONE_ID
	INTO v_SZ_ID
	FROM SERVICE_ZONE SZ, TX_SUB_STATION SS, TX_FEEDER F, TX_FEEDER_SEGMENT FS
	WHERE FS.FEEDER_SEGMENT_ID = p_FEEDER_SEGMENT_ID
		AND F.FEEDER_ID = FS.FEEDER_ID
		AND SS.SUB_STATION_ID = F.SUB_STATION_ID
		AND SZ.SERVICE_ZONE_ID = SS.SERVICE_ZONE_ID;

	RETURN v_SZ_ID;
END GET_SEGMENT_ZONE_ID;
--------------------------------------------------------------------------
FUNCTION GET_FS_TIME_ZONE
(
	p_FEEDER_SEGMENT_ID IN NUMBER
) RETURN VARCHAR2 IS

	v_RST VARCHAR2(6);
	v_SZ_ID NUMBER(9) := GET_SEGMENT_ZONE_ID(p_FEEDER_SEGMENT_ID);

BEGIN

	SELECT SZ.TIME_ZONE
	INTO v_RST
	FROM SERVICE_ZONE SZ
	WHERE SZ.SERVICE_ZONE_ID = v_SZ_ID;

	RETURN v_RST;

END GET_FS_TIME_ZONE;
--------------------------------------------------------------------------
FUNCTION GET_SEGMENT_RESULT_ID
(
	p_FEEDER_SEGMENT_ID IN NUMBER,
	p_FEEDER_ID IN NUMBER,
	p_SUB_STATION_ID IN NUMBER,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_PROGRAM_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_SERVICE_CODE IN CHAR,
	p_IS_EXTERNAL IN NUMBER,
	p_CREATE_IF_NOT_FOUND IN BOOLEAN := FALSE
) RETURN NUMBER IS

	v_RESULT_ID NUMBER(9);

BEGIN

	SELECT MAX(RST.DER_SEGMENT_RESULT_ID)
	INTO v_RESULT_ID
	FROM DER_SEGMENT_RESULT RST
	WHERE RST.PROGRAM_ID = p_PROGRAM_ID
		AND RST.FEEDER_SEGMENT_ID = p_FEEDER_SEGMENT_ID
		AND RST.FEEDER_ID = p_FEEDER_ID
		AND RST.SUB_STATION_ID = p_SUB_STATION_ID
		AND RST.SERVICE_ZONE_ID = p_SERVICE_ZONE_ID
		AND RST.IS_EXTERNAL = p_IS_EXTERNAL
		AND RST.SERVICE_CODE = p_SERVICE_CODE
		AND RST.SCENARIO_ID = p_SCENARIO_ID
		AND RST.EXTERNAL_SYSTEM_ID = p_EXTERNAL_SYSTEM_ID;

	IF v_RESULT_ID IS NULL AND p_CREATE_IF_NOT_FOUND THEN

		SELECT DER_RESULT_ID.NEXTVAL
		INTO v_RESULT_ID
		FROM DUAL;

		INSERT INTO DER_SEGMENT_RESULT (DER_SEGMENT_RESULT_ID, PROGRAM_ID, FEEDER_SEGMENT_ID,
			FEEDER_ID, SUB_STATION_ID, SERVICE_ZONE_ID, EXTERNAL_SYSTEM_ID,
			IS_EXTERNAL, SERVICE_CODE, SCENARIO_ID, ENTRY_DATE)
		VALUES (v_RESULT_ID, p_PROGRAM_ID, p_FEEDER_SEGMENT_ID, p_FEEDER_ID,
			p_SUB_STATION_ID, p_SERVICE_ZONE_ID, p_EXTERNAL_SYSTEM_ID, p_IS_EXTERNAL,
			p_SERVICE_CODE, p_SCENARIO_ID, SYSDATE);
	END IF;

	RETURN v_RESULT_ID;

END GET_SEGMENT_RESULT_ID;
--------------------------------------------------------------------------
PROCEDURE CLEANUP_DER_TEMP_TABLES AS
BEGIN
	EXECUTE IMMEDIATE 'TRUNCATE TABLE '||c_TEMP_TABLE_CAL;
	EXECUTE IMMEDIATE 'TRUNCATE TABLE '||c_TEMP_TABLE_LOSS;
	EXECUTE IMMEDIATE 'TRUNCATE TABLE '||c_TEMP_TABLE_HITS;
EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE;
END CLEANUP_DER_TEMP_TABLES;
----------------------------------------------------------------------------------------------------
-- This procedures handles chunking the date range into blocks if a Periodic Commit is specified.
-- The actual logic is then performed in the the Procedure named by p_RESULT_PROC_NAME.
PROCEDURE PROCESS_RESULTS
	(
	p_RESULT_PROC_NAME IN VARCHAR2,
	p_RESULT_SYSDICT_NAME IN VARCHAR2,
	p_TEMP_TABLE_NAME IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_DISABLE_PARALLEL_EXECUTION IN NUMBER,
	p_ALLOW_COMMITS IN BOOLEAN
	) AS
	v_MAX_DAY_BLOCK_SIZE NUMBER := 0;
	v_BLOCK_BEGIN_DATE DATE := p_BEGIN_DATE;
	v_BLOCK_END_DATE DATE := p_END_DATE;
	v_HINT VARCHAR2(64) := '';
	v_SQL VARCHAR2(4000);
BEGIN
	IF NOT UT.BOOLEAN_FROM_NUMBER(p_DISABLE_PARALLEL_EXECUTION) THEN
		v_HINT := '/*+ PARALLEL('||p_TEMP_TABLE_NAME||') */';
	END IF;

	--We only chunk up the code if commits are allowed in the first place.
	IF p_ALLOW_COMMITS THEN
		v_MAX_DAY_BLOCK_SIZE := NVL(GET_DICTIONARY_VALUE(p_RESULT_SYSDICT_NAME, 0, c_SYSDICT_MODULE, 'Periodic Commit'),'0');
		IF v_MAX_DAY_BLOCK_SIZE > 0 THEN
			v_BLOCK_END_DATE := LEAST(p_END_DATE, v_BLOCK_BEGIN_DATE + v_MAX_DAY_BLOCK_SIZE - 1);
		END IF;
	END IF;

	LOOP
		v_SQL :=
		'MERGE INTO LOAD_RESULT_DATA R
		USING (SELECT *
			FROM TABLE(
				DER_CAPACITY_ENGINE.'||p_RESULT_PROC_NAME||'(
					:begin,
					:end,
					CURSOR(SELECT '||v_HINT||' DISTINCT * FROM '||p_TEMP_TABLE_NAME||')))) A
		ON (A.LOAD_RESULT_ID = R.LOAD_RESULT_ID AND A.RESULT_DATE = R.RESULT_DATE)
		WHEN MATCHED THEN
			UPDATE SET R.RESULT_VAL = A.RESULT_VAL
		WHEN NOT MATCHED THEN
			INSERT (LOAD_RESULT_ID, RESULT_DATE, RESULT_VAL)
			VALUES (A.LOAD_RESULT_ID, A.RESULT_DATE, A.RESULT_VAL)';
		LOGS.LOG_DEBUG('Merge SQL:'||v_SQL);
		EXECUTE IMMEDIATE v_SQL USING v_BLOCK_BEGIN_DATE, v_BLOCK_END_DATE;

		--Commit the block
		IF p_ALLOW_COMMITS AND v_MAX_DAY_BLOCK_SIZE > 0 THEN
			COMMIT; SAVEPOINT BEFORE_RUN_DER_FORECAST;
		END IF;

		EXIT WHEN v_MAX_DAY_BLOCK_SIZE <= 0 OR v_BLOCK_END_DATE >= p_END_DATE;
		v_BLOCK_BEGIN_DATE := v_BLOCK_END_DATE + 1;
		v_BLOCK_END_DATE := LEAST(p_END_DATE, v_BLOCK_BEGIN_DATE + v_MAX_DAY_BLOCK_SIZE - 1);
	END LOOP;
END PROCESS_RESULTS;
----------------------------------------------------------------------------------------------------
PROCEDURE PROCESS_CALENDAR_RESULTS
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_DISABLE_PARALLEL_EXECUTION IN NUMBER := 1,
	p_ALLOW_COMMITS IN BOOLEAN := FALSE
	) AS
BEGIN
	PROCESS_RESULTS('PIPE_LOAD_RESULT_CALENDAR_DATA', 'Load Shape Result Days', c_TEMP_TABLE_CAL, p_BEGIN_DATE, p_END_DATE, p_DISABLE_PARALLEL_EXECUTION, p_ALLOW_COMMITS);
END PROCESS_CALENDAR_RESULTS;
----------------------------------------------------------------------------------------------------
PROCEDURE PROCESS_LOSS_FACTOR_RESULTS
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_DISABLE_PARALLEL_EXECUTION IN NUMBER := 1,
	p_ALLOW_COMMITS IN BOOLEAN := FALSE
	) AS
BEGIN
	PROCESS_RESULTS('PIPE_LOAD_RESULT_LOSS_DATA', 'Loss Factor Result Days', c_TEMP_TABLE_LOSS, p_BEGIN_DATE, p_END_DATE, p_DISABLE_PARALLEL_EXECUTION, p_ALLOW_COMMITS);
END PROCESS_LOSS_FACTOR_RESULTS;
----------------------------------------------------------------------------------------------------
-- This procedure calculates and stores the number of hits remaining.
--   It is different from the Calendar Results and Loss Factor Results since it is expected that
--   there is little calculation to be done, and perhaps little data to actually stored.
--   Because of this, we are doing a DELETE and INSERT inside the parallel processes.
PROCEDURE PROCESS_HITS_RESULTS
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_DISABLE_PARALLEL_EXECUTION IN NUMBER := 1,
	p_ALLOW_COMMITS IN BOOLEAN := FALSE
	) AS
	v_WORK_ID NUMBER := 0;
	v_MAX_DAY_BLOCK_SIZE NUMBER := 0;
	v_BLOCK_BEGIN_DATE DATE := p_BEGIN_DATE;
	v_BLOCK_END_DATE DATE := p_END_DATE;
BEGIN

	--We only chunk up the code if commits are allowed in the first place.
	IF p_ALLOW_COMMITS THEN
		v_MAX_DAY_BLOCK_SIZE := NVL(GET_DICTIONARY_VALUE('Hits Remaining Result Days', 0, c_SYSDICT_MODULE, 'Periodic Commit'),'0');
		IF v_MAX_DAY_BLOCK_SIZE > 0 THEN
			v_BLOCK_END_DATE := LEAST(p_END_DATE, v_BLOCK_BEGIN_DATE + v_MAX_DAY_BLOCK_SIZE - 1);
		END IF;
	END IF;

	LOOP
		IF UT.BOOLEAN_FROM_NUMBER(p_DISABLE_PARALLEL_EXECUTION) THEN
			INSERT INTO RTO_WORK(WORK_ID, WORK_XID)
			SELECT v_WORK_ID, A.LOAD_RESULT_ID FROM TABLE(
			DER_CAPACITY_ENGINE.STORE_LOAD_RESULT_HITS_DATA(
				v_BLOCK_BEGIN_DATE,
				v_BLOCK_END_DATE,
				CURSOR(SELECT DISTINCT * FROM TEMP_LOAD_RESULT_HITS_LIST))) A;
		ELSE
			INSERT INTO RTO_WORK(WORK_ID, WORK_XID)
			SELECT v_WORK_ID, A.LOAD_RESULT_ID FROM TABLE(
			DER_CAPACITY_ENGINE.STORE_LOAD_RESULT_HITS_DATA(
				v_BLOCK_BEGIN_DATE,
				v_BLOCK_END_DATE,
				CURSOR(SELECT /*+ PARALLEL(TEMP_LOAD_RESULT_HITS_LIST) */ DISTINCT * FROM TEMP_LOAD_RESULT_HITS_LIST))) A;
		END IF;

		--No need to do a commit here since the called procedure does one automatically in an autonomous transaction.

		EXIT WHEN v_MAX_DAY_BLOCK_SIZE <= 0 OR v_BLOCK_END_DATE >= p_END_DATE;
		v_BLOCK_BEGIN_DATE := v_BLOCK_END_DATE + 1;
		v_BLOCK_END_DATE := LEAST(p_END_DATE, v_BLOCK_BEGIN_DATE + v_MAX_DAY_BLOCK_SIZE - 1);
	END LOOP;
END PROCESS_HITS_RESULTS;
----------------------------------------------------------------------------------------------------
PROCEDURE RESOLVE_DER_SEG_RESULT_DEFAULT
(
	p_FEEDER_SEGMENT_ID IN NUMBER,
	p_PROGRAM_ID IN NUMBER,
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_DATES IN DATE_COLLECTION
) AS

	v_SZ_ID NUMBER(9);
	v_SZ_TZ SERVICE_ZONE.TIME_ZONE%TYPE;
	v_IS_EXT NUMBER(1);

BEGIN

	v_SZ_ID := GET_SEGMENT_ZONE_ID(p_FEEDER_SEGMENT_ID);
	v_SZ_TZ := GET_FS_TIME_ZONE(p_FEEDER_SEGMENT_ID);

	SELECT NVL(MAX(1),0)
	INTO v_IS_EXT
	FROM DER_SEG_RESULT_DEFAULT_EXT EXT
	WHERE EXT.PROGRAM_ID = p_PROGRAM_ID
		AND EXT.SERVICE_ZONE_ID = v_SZ_ID
		AND EXT.EXTERNAL_SYSTEM_ID = p_EXTERNAL_SYSTEM_ID;


	MERGE INTO DER_SEG_RESULT_IS_EXTERNAL IS_EXT
	USING (SELECT TRUNC(FROM_CUT(DTS.COLUMN_VALUE, v_SZ_TZ)) AS RESULT_DAY,
				p_PROGRAM_ID AS PROGRAM_ID,
				v_SZ_ID AS SERVICE_ZONE_ID,
				p_EXTERNAL_SYSTEM_ID AS EXTERNAL_SYSTEM_ID,
				v_IS_EXT AS IS_EXTERNAL,
				GA.BASE_SCENARIO_ID AS SCENARIO_ID
			FROM TABLE(CAST(p_DATES AS DATE_COLLECTION)) DTS
			GROUP BY TRUNC(FROM_CUT(DTS.COLUMN_VALUE, v_SZ_TZ)),
					p_PROGRAM_ID, v_SZ_ID, p_EXTERNAL_SYSTEM_ID, v_IS_EXT) DEF
	ON (DEF.PROGRAM_ID = IS_EXT.PROGRAM_ID
		AND DEF.SERVICE_ZONE_ID = IS_EXT.SERVICE_ZONE_ID
		AND DEF.EXTERNAL_SYSTEM_ID = IS_EXT.EXTERNAL_SYSTEM_ID
		AND DEF.RESULT_DAY = IS_EXT.RESULT_DAY
		AND DEF.SCENARIO_ID = IS_EXT.SCENARIO_ID)
	WHEN NOT MATCHED THEN
		INSERT VALUES (DEF.RESULT_DAY, DEF.PROGRAM_ID, DEF.SERVICE_ZONE_ID, DEF.EXTERNAL_SYSTEM_ID,
				DEF.SCENARIO_ID, ADD_SECONDS_TO_DATE(TO_CUT(TRUNC(DEF.RESULT_DAY), v_SZ_TZ), 1),
				TO_CUT(TRUNC(DEF.RESULT_DAY) + 1, v_SZ_TZ),
				DEF.IS_EXTERNAL);

END RESOLVE_DER_SEG_RESULT_DEFAULT;
----------------------------------------------------------------------------------------------------
PROCEDURE DELETE_INVALID_SEGMENT_DATA
(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_FEEEDER_SEGMENT_ID IN NUMBER,
	p_FEEDER_ID IN NUMBER,
	p_SUB_STATION_ID IN NUMBER,
	p_SERVICE_ZONE_ID IN NUMBER
) AS

BEGIN

	DELETE FROM DER_SEGMENT_RESULT_DATA D
	WHERE D.RESULT_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
		AND EXISTS (SELECT R.DER_SEGMENT_RESULT_ID
										FROM DER_SEGMENT_RESULT R
											WHERE R.DER_SEGMENT_RESULT_ID = D.DER_SEGMENT_RESULT_ID
												AND R.FEEDER_SEGMENT_ID = p_FEEEDER_SEGMENT_ID
												AND (R.FEEDER_ID <> p_FEEDER_ID OR
													R.SUB_STATION_ID <> p_SUB_STATION_ID OR
													R.SERVICE_ZONE_ID <> p_SERVICE_ZONE_ID));

END DELETE_INVALID_SEGMENT_DATA;
----------------------------------------------------------------------------------------------------
-- The Aggregator
PROCEDURE PUT_SEGMENT_EXTERNAL_RESULT
(
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_FEEDER_SEGMENT_ID IN NUMBER,
	p_PROGRAM_ID IN NUMBER,
	p_DATES IN DATE_COLLECTION,
	p_AVAILABILITY IN NUMBER_COLLECTION,
	p_CAPABILITY IN NUMBER_COLLECTION,
	p_DER_COUNT IN NUMBER_COLLECTION,
	p_SERVICE_CODE IN CHAR := CONSTANTS.CODE_FORECAST,
	p_SCENARIO_ID IN NUMBER := GA.BASE_SCENARIO_ID
) AS

	v_INT_MULT NUMBER;
	v_TIME_ZONE VARCHAR2(6) := GET_FS_TIME_ZONE(p_FEEDER_SEGMENT_ID);
	v_SUB_STATION_ID TX_SUB_STATION.SUB_STATION_ID%TYPE;
	v_FEEDER_ID TX_FEEDER.FEEDER_ID%TYPE;
	v_SERVICE_ZONE_ID SERVICE_ZONE.SERVICE_ZONE_ID%TYPE;
	v_PROGRAM_INTERVAL VARCHAR2(32);
	v_REC DER_SEGMENT_RESULT_DATA%ROWTYPE;
	v_TX_PATTERN_ID NUMBER(9);
	v_DX_PATTERN_ID NUMBER(9);
	v_TX_LOSS_FACTOR_RESULT_ID NUMBER(9);
	v_DX_LOSS_FACTOR_RESULT_ID NUMBER(9);
	v_TX_LOSS_FACTOR LOSS_FACTOR_PATTERN.EXPANSION_VAL%TYPE;
	v_DX_LOSS_FACTOR LOSS_FACTOR_PATTERN.EXPANSION_VAL%TYPE;
	v_DAY DATE;
	v_PREV_DAY DATE := LOW_DATE;

	v_MIN_DATE DATE;
	v_MAX_DATE DATE;

BEGIN

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_EXT_DER_RST, p_EXTERNAL_SYSTEM_ID,
		EC.ED_EXTERNAL_SYSTEM);

	ASSERT(p_DATES IS NOT NULL AND p_AVAILABILITY IS NOT NULL, 'The Dates and Availability collections cannot be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_DATES.COUNT = p_AVAILABILITY.COUNT, 'The Dates and Availability collections must be of the same size.', MSGCODES.c_ERR_ARGUMENT);

	-- DER_COUNT and CAPABILITY collections will not come in with a backcast.  But if they are present,
	--   then be sure they are the right size.
	IF p_CAPABILITY IS NOT NULL THEN
		ASSERT(p_DATES.COUNT = p_CAPABILITY.COUNT, 'The Dates and Capability collections must be of the same size.', MSGCODES.c_ERR_ARGUMENT);
	END IF;
	IF p_DER_COUNT IS NOT NULL THEN
		ASSERT(p_DATES.COUNT = p_DER_COUNT.COUNT, 'The Dates and DER Count collections must be of the same size.', MSGCODES.c_ERR_ARGUMENT);
	END IF;

	SELECT NVL(GET_INTERVAL_ABBREVIATION(P.PROGRAM_INTERVAL),DATE_UTIL.c_ABBR_HOUR)
	INTO v_PROGRAM_INTERVAL
	FROM PROGRAM P
	WHERE P.PROGRAM_ID = p_PROGRAM_ID;

	SELECT F.FEEDER_ID,
		SS.SUB_STATION_ID,
		SS.SERVICE_ZONE_ID
	INTO v_FEEDER_ID,
		v_SUB_STATION_ID,
		v_SERVICE_ZONE_ID
	FROM TX_FEEDER_SEGMENT FS,
		TX_FEEDER F,
		TX_SUB_STATION SS
	WHERE FS.FEEDER_SEGMENT_ID = p_FEEDER_SEGMENT_ID
		AND F.FEEDER_ID = FS.FEEDER_ID
		AND SS.SUB_STATION_ID = F.SUB_STATION_ID;

	UT.GET_DATE_COLLECTION_MIN_MAX(p_DATES, v_MIN_DATE, v_MAX_DATE);

	DELETE_INVALID_SEGMENT_DATA(TO_CUT(v_MIN_DATE, v_TIME_ZONE),
								TO_CUT(v_MAX_DATE, v_TIME_ZONE),
								p_FEEDER_SEGMENT_ID,
								v_FEEDER_ID,
								v_SUB_STATION_ID,
								v_SERVICE_ZONE_ID);

	v_REC.DER_SEGMENT_RESULT_ID := GET_SEGMENT_RESULT_ID(p_FEEDER_SEGMENT_ID, v_FEEDER_ID, v_SUB_STATION_ID,
		v_SERVICE_ZONE_ID, p_EXTERNAL_SYSTEM_ID, p_PROGRAM_ID, p_SCENARIO_ID, p_SERVICE_CODE, 1, TRUE);
	v_REC.FAILURE_VAL := 0;
	v_REC.OPT_OUT_VAL := 0;
	v_REC.OVERRIDE_VAL := 0;

	v_INT_MULT := GET_UNIT_MULTIPLIER(p_SERVICE_CODE, FALSE, v_PROGRAM_INTERVAL);

	FOR v_IDX IN p_DATES.FIRST .. p_DATES.LAST LOOP
		v_DAY := TRUNC(FROM_CUT(p_DATES(v_IDX), v_TIME_ZONE)-1/86400);
		v_REC.RESULT_DATE := p_DATES(v_IDX);
		-- Only set up certain data when the day changes.
		IF v_DAY <> v_PREV_DAY THEN
			GET_LOSS_PATTERNS_FOR_SEGMENT(v_DAY, p_FEEDER_SEGMENT_ID, v_TX_PATTERN_ID, v_DX_PATTERN_ID);
			--Populate Loss Factor Result data with information from our loss factors.
			v_TX_LOSS_FACTOR_RESULT_ID := GET_LOAD_RESULT_LOSS_ID(v_TX_PATTERN_ID, p_SERVICE_CODE, p_SCENARIO_ID, v_TIME_ZONE, v_PROGRAM_INTERVAL, TRUE);
			v_DX_LOSS_FACTOR_RESULT_ID := GET_LOAD_RESULT_LOSS_ID(v_DX_PATTERN_ID, p_SERVICE_CODE, p_SCENARIO_ID, v_TIME_ZONE, v_PROGRAM_INTERVAL, TRUE);
			PROCESS_LOSS_FACTOR_RESULTS(v_DAY, v_DAY, 1);
			CLEANUP_DER_TEMP_TABLES;
		END IF;

		--Look up the Loss Factor Values
		SELECT NVL(MAX(RESULT_VAL),0) INTO v_TX_LOSS_FACTOR
		FROM LOAD_RESULT_DATA L
		WHERE L.LOAD_RESULT_ID = v_TX_LOSS_FACTOR_RESULT_ID
			AND L.RESULT_DATE = v_REC.RESULT_DATE;

		SELECT NVL(MAX(RESULT_VAL),0) INTO v_DX_LOSS_FACTOR
		FROM LOAD_RESULT_DATA L
		WHERE L.LOAD_RESULT_ID = v_DX_LOSS_FACTOR_RESULT_ID
			AND L.RESULT_DATE = v_REC.RESULT_DATE;

		v_REC.LOAD_VAL := p_AVAILABILITY(v_IDX)*v_INT_MULT;
		v_REC.UNCONSTRAINED_LOAD_VAL := CASE WHEN p_CAPABILITY IS NULL THEN NULL ELSE p_CAPABILITY(v_IDX)*v_INT_MULT END;
		v_REC.DER_COUNT := CASE WHEN p_DER_COUNT IS NULL THEN NULL ELSE p_DER_COUNT(v_IDX) END;
		v_REC.TX_LOSS_VAL := v_REC.LOAD_VAL*v_TX_LOSS_FACTOR*(1+v_DX_LOSS_FACTOR);
		v_REC.DX_LOSS_VAL := v_REC.LOAD_VAL*v_DX_LOSS_FACTOR;
		v_REC.UNCONSTRAINED_TX_LOSS_VAL := CASE WHEN v_REC.UNCONSTRAINED_LOAD_VAL IS NULL THEN NULL ELSE p_CAPABILITY(v_IDX)*v_INT_MULT*v_TX_LOSS_FACTOR*(1+v_DX_LOSS_FACTOR) END;
		v_REC.UNCONSTRAINED_DX_LOSS_VAL := CASE WHEN v_REC.UNCONSTRAINED_LOAD_VAL IS NULL THEN NULL ELSE p_CAPABILITY(v_IDX)*v_INT_MULT*v_DX_LOSS_FACTOR END;

		MERGE INTO DER_SEGMENT_RESULT_DATA T
		USING (SELECT v_REC.DER_SEGMENT_RESULT_ID AS DER_SEGMENT_RESULT_ID,
					  v_REC.RESULT_DATE AS RESULT_DATE,
					  v_REC.LOAD_VAL AS LOAD_VAL,
					  v_REC.FAILURE_VAL AS FAILURE_VAL,
					  v_REC.OPT_OUT_VAL AS OPT_OUT_VAL,
					  v_REC.OVERRIDE_VAL AS OVERRIDE_VAL,
					  v_REC.TX_LOSS_VAL AS TX_LOSS_VAL,
					  v_REC.DX_LOSS_VAL AS DX_LOSS_VAL,
					  v_REC.DER_COUNT AS DER_COUNT,
					  v_REC.UNCONSTRAINED_LOAD_VAL AS UNCONSTRAINED_LOAD_VAL,
					  v_REC.UNCONSTRAINED_TX_LOSS_VAL AS UNCONSTRAINED_TX_LOSS_VAL,
					  v_REC.UNCONSTRAINED_DX_LOSS_VAL AS UNCONSTRAINED_DX_LOSS_VAL FROM DUAL) S
		ON (T.DER_SEGMENT_RESULT_ID = S.DER_SEGMENT_RESULT_ID AND T.RESULT_DATE = S.RESULT_DATE)
		WHEN MATCHED THEN
		UPDATE SET T.LOAD_VAL = S.LOAD_VAL,
				   T.FAILURE_VAL = S.FAILURE_VAL,
				   T.OPT_OUT_VAL = S.OPT_OUT_VAL,
				   T.OVERRIDE_VAL = S.OVERRIDE_VAL,
				   T.TX_LOSS_VAL = S.TX_LOSS_VAL,
				   T.DX_LOSS_VAL = S.DX_LOSS_VAL,
				   T.DER_COUNT = S.DER_COUNT,
				   T.UNCONSTRAINED_LOAD_VAL = S.UNCONSTRAINED_LOAD_VAL,
				   T.UNCONSTRAINED_TX_LOSS_VAL = S.UNCONSTRAINED_TX_LOSS_VAL,
				   T.UNCONSTRAINED_DX_LOSS_VAL = S.UNCONSTRAINED_DX_LOSS_VAL
		WHEN NOT MATCHED THEN
		INSERT
			(T.DER_SEGMENT_RESULT_ID,
			 T.RESULT_DATE,
			 T.LOAD_VAL,
			 T.FAILURE_VAL,
			 T.OPT_OUT_VAL,
			 T.OVERRIDE_VAL,
			 T.TX_LOSS_VAL,
			 T.DX_LOSS_VAL,
			 T.DER_COUNT,
			 T.UNCONSTRAINED_LOAD_VAL,
			 T.UNCONSTRAINED_TX_LOSS_VAL,
			 T.UNCONSTRAINED_DX_LOSS_VAL)
		VALUES
			(S.DER_SEGMENT_RESULT_ID,
			 S.RESULT_DATE,
			 S.LOAD_VAL,
			 S.FAILURE_VAL,
			 S.OPT_OUT_VAL,
			 S.OVERRIDE_VAL,
			 S.TX_LOSS_VAL,
			 S.DX_LOSS_VAL,
			 S.DER_COUNT,
			 S.UNCONSTRAINED_LOAD_VAL,
			 S.UNCONSTRAINED_TX_LOSS_VAL,
			 S.UNCONSTRAINED_DX_LOSS_VAL);

		v_PREV_DAY := v_DAY;
	END LOOP;

	RESOLVE_DER_SEG_RESULT_DEFAULT(p_FEEDER_SEGMENT_ID,
									p_PROGRAM_ID,
									p_EXTERNAL_SYSTEM_ID,
									p_DATES);

END PUT_SEGMENT_EXTERNAL_RESULT;
--------------------------------------------------------------------------
-- The Disaggregator
PROCEDURE PROCESS_EVENT_SCHEDULE
(
	p_EVENT_ID IN NUMBER,
	p_CUT_BEGIN IN DATE,
	p_CUT_END IN DATE,
	p_MESSAGE OUT VARCHAR2
) AS

	CURSOR cur_PRIORITIES IS
	SELECT DISTINCT FS.PRIORITY
	FROM (SELECT DISTINCT RST.FEEDER_SEGMENT_ID
		FROM DR_EVENT EV,
			DER_SEGMENT_RESULT RST,
			VIRTUAL_POWER_PLANT VPP
		WHERE EV.EVENT_ID = p_EVENT_ID
			AND VPP.VPP_ID = EV.VPP_ID
			AND RST.PROGRAM_ID = VPP.PROGRAM_ID
			AND RST.SERVICE_ZONE_ID = VPP.SERVICE_ZONE_ID
			AND RST.FEEDER_SEGMENT_ID <> CONSTANTS.NOT_ASSIGNED) SEGS,
		TX_FEEDER_SEGMENT FS
	WHERE FS.FEEDER_SEGMENT_ID = SEGS.FEEDER_SEGMENT_ID
	ORDER BY FS.PRIORITY DESC NULLS LAST;

	v_PROGRAM_TYPE VARCHAR2(128);

	v_PROG_ID NUMBER(9);
	v_SZ_ID NUMBER(9);
	v_PRORATE NUMBER;

	v_GROSS_AVAIL NUMBER;
	v_DISP_REMAIN NUMBER;

	v_FS_IDS NUMBER_COLLECTION;

BEGIN

	SELECT P.PROGRAM_TYPE, p.PROGRAM_ID, VPP.SERVICE_ZONE_ID
	INTO v_PROGRAM_TYPE, v_PROG_ID, v_SZ_ID
	FROM PROGRAM P, DR_EVENT EV, VIRTUAL_POWER_PLANT VPP
	WHERE EV.EVENT_ID = p_EVENT_ID
		AND VPP.VPP_ID = EV.VPP_ID
		AND P.PROGRAM_ID = VPP.PROGRAM_ID;

	IF v_PROGRAM_TYPE <> DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_DLC THEN
		p_MESSAGE := 'Only Direct Load Control programs can be disaggregated.';
		RETURN;
	END IF;

 	-- DELETE ALL DISPATCH SCHEDULE DATA FOR THIS DATE RANGE
	DELETE FROM DER_SEGMENT_RESULT_DATA DT
	WHERE DT.RESULT_DATE > p_CUT_BEGIN
		AND DT.RESULT_DATE <= p_CUT_END
		AND DT.DER_SEGMENT_RESULT_ID IN
			(SELECT RST.DER_SEGMENT_RESULT_ID
			FROM DER_SEGMENT_RESULT RST
			WHERE RST.SERVICE_ZONE_ID = v_SZ_ID
				AND RST.PROGRAM_ID = v_PROG_ID
				AND RST.IS_EXTERNAL = 0
				AND RST.SERVICE_CODE = CONSTANTS.CODE_DISPATCH
				AND RST.SCENARIO_ID = GA.BASE_SCENARIO_ID);

	-- FIRST BRING OVER ANY DER_SEGMENT_RESULT DISPATCH RECORDS WE MIGHT NEED
	-- I.E. ANY FEEDER SEGMENT RESULTS BELONGING TO THE CURRENT VPP
	-- WITH FORECAST DATA IN THE GIVEN DATE RANGE
	MERGE INTO DER_SEGMENT_RESULT TGT
	USING (SELECT DISTINCT RST.PROGRAM_ID, RST.FEEDER_SEGMENT_ID,
				RST.EXTERNAL_SYSTEM_ID, RST.SERVICE_ZONE_ID, RST.SUB_STATION_ID,
				RST.FEEDER_ID, RST.SCENARIO_ID
			FROM DER_SEGMENT_RESULT RST
			WHERE RST.PROGRAM_ID = v_PROG_ID
				AND RST.SERVICE_ZONE_ID = v_SZ_ID
				AND RST.FEEDER_SEGMENT_ID <> CONSTANTS.NOT_ASSIGNED
				AND RST.SERVICE_CODE = CONSTANTS.CODE_FORECAST
				AND RST.SCENARIO_ID = GA.BASE_SCENARIO_ID
				AND EXISTS (SELECT 1
							FROM DER_SEGMENT_RESULT_DATA DT
							WHERE DT.DER_SEGMENT_RESULT_ID =
										RST.DER_SEGMENT_RESULT_ID
								AND DT.RESULT_DATE > p_CUT_BEGIN
									AND DT.RESULT_DATE <= p_CUT_END)) SRC
	ON (TGT.PROGRAM_ID = SRC.PROGRAM_ID AND TGT.FEEDER_SEGMENT_ID = SRC.FEEDER_SEGMENT_ID
		AND TGT.FEEDER_ID = SRC.FEEDER_ID AND TGT.SUB_STATION_ID = SRC.SUB_STATION_ID
		AND TGT.SERVICE_ZONE_ID = SRC.SERVICE_ZONE_ID
		AND TGT.EXTERNAL_SYSTEM_ID = SRC.EXTERNAL_SYSTEM_ID AND TGT.IS_EXTERNAL = 0
		AND TGT.SERVICE_CODE = CONSTANTS.CODE_DISPATCH AND TGT.SCENARIO_ID = SRC.SCENARIO_ID)
	WHEN NOT MATCHED THEN
		INSERT (TGT.DER_SEGMENT_RESULT_ID, TGT.PROGRAM_ID, TGT.SERVICE_ZONE_ID,
			TGT.SUB_STATION_ID, TGT.FEEDER_ID, TGT.FEEDER_SEGMENT_ID, TGT.EXTERNAL_SYSTEM_ID,
			TGT.IS_EXTERNAL, TGT.SERVICE_CODE, TGT.SCENARIO_ID, TGT.ENTRY_DATE)
		VALUES (DER_RESULT_ID.NEXTVAL, SRC.PROGRAM_ID, SRC.SERVICE_ZONE_ID, SRC.SUB_STATION_ID,
			SRC.FEEDER_ID, SRC.FEEDER_SEGMENT_ID, SRC.EXTERNAL_SYSTEM_ID, 0,
			CONSTANTS.CODE_DISPATCH, SRC.SCENARIO_ID, SYSDATE);

	FOR v_DISP_REC IN (SELECT * FROM DR_EVENT_SCHEDULE DR
						WHERE DR.EVENT_ID = p_EVENT_ID
							AND DR.SCHEDULE_DATE BETWEEN p_CUT_BEGIN AND p_CUT_END
						ORDER BY DR.SCHEDULE_DATE) LOOP
		v_DISP_REMAIN := v_DISP_REC.AMOUNT;
		FOR v_PRIORITY_REC IN cur_PRIORITIES LOOP
			EXIT WHEN v_DISP_REMAIN <= 0;

			SELECT FS.FEEDER_SEGMENT_ID
			BULK COLLECT INTO v_FS_IDS
			FROM (SELECT DISTINCT RST.FEEDER_SEGMENT_ID
				  FROM DER_SEGMENT_RESULT RST
				  WHERE RST.PROGRAM_ID = v_PROG_ID
				  	AND RST.SERVICE_ZONE_ID = v_SZ_ID
					AND RST.FEEDER_SEGMENT_ID <> CONSTANTS.NOT_ASSIGNED) SEGS,
				 TX_FEEDER_SEGMENT FS
			WHERE FS.FEEDER_SEGMENT_ID = SEGS.FEEDER_SEGMENT_ID
				AND ((v_PRIORITY_REC.PRIORITY IS NOT NULL AND FS.PRIORITY = v_PRIORITY_REC.PRIORITY)
					OR (v_PRIORITY_REC.PRIORITY IS NULL AND FS.PRIORITY IS NULL));

			SELECT NVL(SUM(DATA.LOAD_VAL + DATA.FAILURE_VAL + DATA.OPT_OUT_VAL + DATA.OVERRIDE_VAL
				+ DATA.DX_LOSS_VAL + DATA.TX_LOSS_VAL),0)
			INTO v_GROSS_AVAIL
			FROM DER_SEGMENT_FORECAST_DATA DATA,
				TABLE(CAST(v_FS_IDS AS NUMBER_COLLECTION)) X
			WHERE DATA.PROGRAM_ID = v_PROG_ID
				AND DATA.SERVICE_ZONE_ID = v_SZ_ID
				AND DATA.FEEDER_SEGMENT_ID = X.COLUMN_VALUE
				AND DATA.SCENARIO_ID = GA.BASE_SCENARIO_ID
				AND DATA.RESULT_DATE = v_DISP_REC.SCHEDULE_DATE;

			-- IF NO DISPATCH AVAILABLE, SKIP IT
			IF v_GROSS_AVAIL > 0 THEN

				IF v_DISP_REMAIN > v_GROSS_AVAIL THEN
					v_PRORATE := 1;
					v_DISP_REMAIN := v_DISP_REMAIN - v_GROSS_AVAIL;
				ELSE
					v_PRORATE := v_DISP_REMAIN / v_GROSS_AVAIL;
					v_DISP_REMAIN := 0;
				END IF;

				-- BRING OVER ALL DERMS (WE CAN DO INSERTS SINCE WE'VE ALREADY
				-- DELETED ALL THE DISPATCH DATA)
				INSERT INTO DER_SEGMENT_RESULT_DATA (DER_SEGMENT_RESULT_ID,
					RESULT_DATE, LOAD_VAL, FAILURE_VAL, OPT_OUT_VAL, OVERRIDE_VAL,
					TX_LOSS_VAL, DX_LOSS_VAL, DER_COUNT, UNCONSTRAINED_LOAD_VAL,
					UNCONSTRAINED_TX_LOSS_VAL, UNCONSTRAINED_DX_LOSS_VAL)
				SELECT TGT_RST.DER_SEGMENT_RESULT_ID, v_DISP_REC.SCHEDULE_DATE,
					v_PRORATE * FCAST.LOAD_VAL, v_PRORATE * FCAST.FAILURE_VAL,
					v_PRORATE * FCAST.OPT_OUT_VAL, v_PRORATE * FCAST.OVERRIDE_VAL,
					v_PRORATE * FCAST.TX_LOSS_VAL, v_PRORATE * FCAST.DX_LOSS_VAL,
					CEIL(v_PRORATE * FCAST.DER_COUNT),
					v_PRORATE * FCAST.UNCONSTRAINED_LOAD_VAL,
					v_PRORATE * FCAST.UNCONSTRAINED_TX_LOSS_VAL,
					v_PRORATE * FCAST.UNCONSTRAINED_DX_LOSS_VAL
				FROM DER_SEGMENT_RESULT TGT_RST,
					DER_SEGMENT_FORECAST_DATA FCAST,
					TABLE(CAST(v_FS_IDS AS NUMBER_COLLECTION)) X
				WHERE FCAST.PROGRAM_ID = v_PROG_ID
					AND FCAST.SERVICE_ZONE_ID = v_SZ_ID
					AND FCAST.FEEDER_SEGMENT_ID = X.COLUMN_VALUE
					AND FCAST.SCENARIO_ID = GA.BASE_SCENARIO_ID
					AND TGT_RST.PROGRAM_ID = FCAST.PROGRAM_ID
					AND TGT_RST.FEEDER_SEGMENT_ID = FCAST.FEEDER_SEGMENT_ID
					AND TGT_RST.FEEDER_ID = FCAST.FEEDER_ID
					AND TGT_RST.SUB_STATION_ID = FCAST.SUB_STATION_ID
					AND TGT_RST.SERVICE_ZONE_ID = FCAST.SERVICE_ZONE_ID
					AND TGT_RST.IS_EXTERNAL = 0
					AND TGT_RST.SERVICE_CODE = CONSTANTS.CODE_DISPATCH
					AND TGT_RST.SCENARIO_ID = FCAST.SCENARIO_ID
					AND TGT_RST.EXTERNAL_SYSTEM_ID = FCAST.EXTERNAL_SYSTEM_ID
					AND FCAST.RESULT_DATE = v_DISP_REC.SCHEDULE_DATE;
			END IF;
		END LOOP;

		IF v_DISP_REMAIN > 0 THEN
			LOGS.LOG_WARN('The feeder segment capacity on '
				|| TEXT_UTIL.TO_CHAR_TIME(v_DISP_REC.SCHEDULE_DATE)
				|| ' was insufficient to meet the dispatch amount for '
				|| TEXT_UTIL.TO_CHAR_ENTITY(v_DISP_REC.EVENT_ID, EC.ED_DR_EVENT, TRUE) );
		END IF;

	END LOOP;

END PROCESS_EVENT_SCHEDULE;
--------------------------------------------------------------------------
PROCEDURE PUT_DER_DAILY_RESULT
	(
	p_DAILY IN DER_DAILY_RESULT%ROWTYPE
	) AS
BEGIN

	--TODO: The Profiler shows that inserting each record separately takes up a lot of time.
	--  It could improve performance to collect, say, 100,000 DER Daily Results into a PL/SQL collection,
	--  and then merge them all at once, using FORALL.
	--  http://www.dba-oracle.com/oracle_news/news_plsql_forall_performance_insert.htm

	--  But we need to use SQL collections if we're going to do the MERGE instead of the INSERT:
	--  http://www.oracle-developer.net/display.php?id=410

	MERGE INTO DER_DAILY_RESULT R
	USING (SELECT NULL FROM DUAL) SRC
	ON (R.DER_ID = p_DAILY.DER_ID
		AND R.IS_EXTERNAL = p_DAILY.IS_EXTERNAL
		AND R.SERVICE_CODE = p_DAILY.SERVICE_CODE
		AND R.SCENARIO_ID = p_DAILY.SCENARIO_ID
		AND R.RESULT_DAY = p_DAILY.RESULT_DAY)
	WHEN MATCHED THEN UPDATE SET
		R.SOURCE_TIME_ZONE = p_DAILY.SOURCE_TIME_ZONE,
		R.CUT_BEGIN_DATE = p_DAILY.CUT_BEGIN_DATE,
		R.CUT_END_DATE = p_DAILY.CUT_END_DATE,
		R.RESULT_INTERVAL = p_DAILY.RESULT_INTERVAL,
		R.LOAD_SHAPE_RESULT_ID = p_DAILY.LOAD_SHAPE_RESULT_ID,
		R.TX_LOSS_FACTOR_RESULT_ID = p_DAILY.TX_LOSS_FACTOR_RESULT_ID,
		R.DX_LOSS_FACTOR_RESULT_ID = p_DAILY.DX_LOSS_FACTOR_RESULT_ID,
		R.HITS_REMAINING_RESULT_ID = p_DAILY.HITS_REMAINING_RESULT_ID,
		R.SCALE_FACTOR = p_DAILY.SCALE_FACTOR,
		R.FAILURE_RATE = p_DAILY.FAILURE_RATE,
		R.OPT_OUT_RATE = p_DAILY.OPT_OUT_RATE,
		R.OVERRIDE_RATE = p_DAILY.OVERRIDE_RATE,
		R.DER_TYPE_ID = p_DAILY.DER_TYPE_ID,
		R.EXTERNAL_SYSTEM_ID = p_DAILY.EXTERNAL_SYSTEM_ID,
		R.PROGRAM_ID = p_DAILY.PROGRAM_ID,
		R.SERVICE_ZONE_ID = p_DAILY.SERVICE_ZONE_ID,
		R.SUB_STATION_ID = p_DAILY.SUB_STATION_ID,
		R.FEEDER_ID = p_DAILY.FEEDER_ID,
		R.FEEDER_SEGMENT_ID = p_DAILY.FEEDER_SEGMENT_ID,
		R.ACCOUNT_ID = p_DAILY.ACCOUNT_ID,
		R.SERVICE_LOCATION_ID = p_DAILY.SERVICE_LOCATION_ID,
		R.EDC_ID = p_DAILY.EDC_ID,
		R.ENTRY_DATE = p_DAILY.ENTRY_DATE
	WHEN NOT MATCHED THEN INSERT VALUES p_DAILY;

END PUT_DER_DAILY_RESULT;
----------------------------------------------------------------------------------------------------
PROCEDURE DELETE_DER_DAILY_RESULT
	(
	p_DAILY IN DER_DAILY_RESULT%ROWTYPE
	) AS
BEGIN

	DELETE DER_DAILY_RESULT R
	WHERE R.DER_ID = p_DAILY.DER_ID
		AND R.IS_EXTERNAL = p_DAILY.IS_EXTERNAL
		AND R.SERVICE_CODE = p_DAILY.SERVICE_CODE
		AND R.SCENARIO_ID = p_DAILY.SCENARIO_ID
		AND R.RESULT_DAY = p_DAILY.RESULT_DAY;

END DELETE_DER_DAILY_RESULT;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_DER_CANDIDATES
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ENTITY_IDS IN NUMBER_COLLECTION,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CANDIDATE_CURSOR OUT t_CANDIDATE_CURSOR
	) AS
BEGIN

	IF p_ENTITY_DOMAIN_ID = CONSTANTS.ALL_ID THEN
		OPEN p_CANDIDATE_CURSOR FOR
			SELECT DER_ID
			FROM DISTRIBUTED_ENERGY_RESOURCE
			WHERE BEGIN_DATE <= p_END_DATE
				AND NVL(END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			UNION
			SELECT DER_ID
			FROM DER_DAILY_RESULT DDR, TABLE(CAST(p_ENTITY_IDS AS NUMBER_COLLECTION)) X
			WHERE DDR.RESULT_DAY BETWEEN p_BEGIN_DATE AND p_END_DATE
				AND DDR.DER_ID = X.COLUMN_VALUE;
	ELSIF p_ENTITY_DOMAIN_ID = EC.ED_SERVICE_LOCATION THEN
		OPEN p_CANDIDATE_CURSOR FOR
			SELECT DER_ID
			FROM DISTRIBUTED_ENERGY_RESOURCE D, TABLE(CAST(p_ENTITY_IDS AS NUMBER_COLLECTION)) X
			WHERE D.SERVICE_LOCATION_ID = X.COLUMN_VALUE
				AND p_BEGIN_DATE <= NVL(D.END_DATE, CONSTANTS.HIGH_DATE)
				AND p_END_DATE >= D.BEGIN_DATE
			UNION
			SELECT DER_ID
			FROM DER_DAILY_RESULT DDR, TABLE(CAST(p_ENTITY_IDS AS NUMBER_COLLECTION)) X
			WHERE DDR.RESULT_DAY BETWEEN p_BEGIN_DATE AND p_END_DATE
				AND DDR.SERVICE_LOCATION_ID = X.COLUMN_VALUE;
	ELSIF p_ENTITY_DOMAIN_ID = EC.ED_ACCOUNT THEN
		OPEN p_CANDIDATE_CURSOR FOR
			SELECT D.DER_ID
			FROM ACCOUNT_SERVICE_LOCATION A, DISTRIBUTED_ENERGY_RESOURCE D, TABLE(CAST(p_ENTITY_IDS AS NUMBER_COLLECTION)) X
			WHERE A.ACCOUNT_ID = X.COLUMN_VALUE
				AND D.SERVICE_LOCATION_ID = A.SERVICE_LOCATION_ID
				AND p_BEGIN_DATE <= NVL(A.END_DATE, CONSTANTS.HIGH_DATE)
				AND p_END_DATE >= A.BEGIN_DATE
				AND p_BEGIN_DATE <= NVL(D.END_DATE, CONSTANTS.HIGH_DATE)
				AND p_END_DATE >= D.BEGIN_DATE
			UNION
			SELECT DER_ID
			FROM DER_DAILY_RESULT DDR, TABLE(CAST(p_ENTITY_IDS AS NUMBER_COLLECTION)) X
			WHERE DDR.RESULT_DAY BETWEEN p_BEGIN_DATE AND p_END_DATE
				AND DDR.ACCOUNT_ID = X.COLUMN_VALUE;
	ELSIF p_ENTITY_DOMAIN_ID = EC.ED_TX_FEEDER_SEGMENT THEN
		OPEN p_CANDIDATE_CURSOR FOR
			SELECT D.DER_ID
			FROM SERVICE_LOCATION S, DISTRIBUTED_ENERGY_RESOURCE D, TABLE(CAST(p_ENTITY_IDS AS NUMBER_COLLECTION)) X
			WHERE S.FEEDER_SEGMENT_ID = X.COLUMN_VALUE
				AND D.SERVICE_LOCATION_ID = S.SERVICE_LOCATION_ID
				AND p_BEGIN_DATE <= NVL(D.END_DATE, CONSTANTS.HIGH_DATE)
				AND p_END_DATE >= D.BEGIN_DATE
			UNION
			SELECT DER_ID
			FROM DER_DAILY_RESULT DDR, TABLE(CAST(p_ENTITY_IDS AS NUMBER_COLLECTION)) X
			WHERE DDR.RESULT_DAY BETWEEN p_BEGIN_DATE AND p_END_DATE
				AND DDR.FEEDER_SEGMENT_ID = X.COLUMN_VALUE;
	ELSIF p_ENTITY_DOMAIN_ID = EC.ED_PROGRAM THEN
		OPEN p_CANDIDATE_CURSOR FOR
			SELECT D.DER_ID
			FROM DER_PROGRAM S, DISTRIBUTED_ENERGY_RESOURCE D, TABLE(CAST(p_ENTITY_IDS AS NUMBER_COLLECTION)) X
			WHERE S.PROGRAM_ID = X.COLUMN_VALUE
				AND D.DER_ID = S.DER_ID
				AND p_BEGIN_DATE <= NVL(D.END_DATE, CONSTANTS.HIGH_DATE)
				AND p_END_DATE >= D.BEGIN_DATE
			UNION
			SELECT DER_ID
			FROM DER_DAILY_RESULT DDR, TABLE(CAST(p_ENTITY_IDS AS NUMBER_COLLECTION)) X
			WHERE DDR.RESULT_DAY BETWEEN p_BEGIN_DATE AND p_END_DATE
				AND DDR.PROGRAM_ID = X.COLUMN_VALUE;
	ELSIF p_ENTITY_DOMAIN_ID = EC.ED_VPP THEN
		OPEN p_CANDIDATE_CURSOR FOR
			SELECT D.DER_ID
			FROM VIRTUAL_POWER_PLANT V, DER_PROGRAM DP, DISTRIBUTED_ENERGY_RESOURCE D, SERVICE_LOCATION SL, TABLE(CAST(p_ENTITY_IDS AS NUMBER_COLLECTION)) X
			WHERE V.VPP_ID = X.COLUMN_VALUE
				AND DP.PROGRAM_ID = V.PROGRAM_ID
				AND D.DER_ID = DP.DER_ID
				AND p_BEGIN_DATE <= NVL(D.END_DATE, CONSTANTS.HIGH_DATE)
				AND p_END_DATE >= D.BEGIN_DATE
				AND p_BEGIN_DATE <= NVL(DP.END_DATE, CONSTANTS.HIGH_DATE)
				AND p_END_DATE >= DP.BEGIN_DATE
				AND SL.SERVICE_LOCATION_ID = D.SERVICE_LOCATION_ID
				AND SL.SERVICE_ZONE_ID = V.SERVICE_ZONE_ID;
	END IF;

END GET_DER_CANDIDATES;
----------------------------------------------------------------------------------------------------
PROCEDURE PROCESS_DER_DAILY_RESULTS
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ENTITY_IDs IN NUMBER_COLLECTION,
	p_SERVICE_CODE IN CHAR,
	p_SCENARIO_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	) AS
	v_DEVICE_DAY_COUNT BINARY_INTEGER := 0;
	v_DEVICE_DAY_COMMIT_SIZE NUMBER;
	v_DAY DATE;
	v_DAILY DER_DAILY_RESULT%ROWTYPE;
	v_DX_LOSS_PATTERN_ID NUMBER(9);
	v_TX_LOSS_PATTERN_ID NUMBER(9);
	v_DER_ID NUMBER(9);
	v_CALENDAR_ID NUMBER(9);
	v_WEATHER_STATION_ID NUMBER(9);
	v_CANDIDATES t_CANDIDATE_CURSOR;
	v_DER_IS_ACTIVE NUMBER;
	v_DERS_WITHOUT_LOSS_FACTORS ID_TABLE := ID_TABLE();
	v_COUNT NUMBER;
BEGIN
	v_DEVICE_DAY_COMMIT_SIZE := NVL(GET_DICTIONARY_VALUE('DER Daily Result Records', 0, c_SYSDICT_MODULE, 'Periodic Commit'),'0');

	v_DAILY.IS_EXTERNAL := 0;
	v_DAILY.SERVICE_CODE := p_SERVICE_CODE;
	v_DAILY.SCENARIO_ID := p_SCENARIO_ID;
	v_DAILY.HITS_REMAINING_RESULT_ID := NULL;

	--Determine the DER Candidates
	GET_DER_CANDIDATES(p_ENTITY_DOMAIN_ID, p_ENTITY_IDS, p_BEGIN_DATE, p_END_DATE, v_CANDIDATES);

	--For each candidate
	LOOP
		FETCH v_CANDIDATES INTO v_DER_ID;
		EXIT WHEN v_CANDIDATES%NOTFOUND;

		v_DAILY.DER_ID := v_DER_ID;
		v_DAILY.SOURCE_TIME_ZONE := GET_TIME_ZONE_FOR_DER(v_DER_ID);
		GET_STATIC_DER_ASSIGNMENTS(v_DER_ID, v_DAILY.DER_TYPE_ID, v_DAILY.EXTERNAL_SYSTEM_ID, v_DAILY.SERVICE_ZONE_ID, v_DAILY.SUB_STATION_ID, v_DAILY.FEEDER_ID, v_DAILY.FEEDER_SEGMENT_ID, v_DAILY.SERVICE_LOCATION_ID, v_WEATHER_STATION_ID);
		v_DAILY.ENTRY_DATE := SYSDATE;

		--For each day
		v_DAY := p_BEGIN_DATE;
		WHILE v_DAY <= p_END_DATE LOOP
			v_DAILY.RESULT_DAY := v_DAY;
			UT.CUT_DATE_RANGE(1, v_DAY, v_DAY, v_DAILY.SOURCE_TIME_ZONE, v_DAILY.CUT_BEGIN_DATE, v_DAILY.CUT_END_DATE);

			--Get the DER data
			GET_TEMPORAL_DER_ASSIGNMENTS(v_DER_ID, v_DAY, v_DER_IS_ACTIVE, v_DAILY.PROGRAM_ID, v_DAILY.ACCOUNT_ID, v_DAILY.EDC_ID, v_CALENDAR_ID, v_DAILY.RESULT_INTERVAL);
			GET_LOSS_PATTERNS_FOR_SEGMENT(v_DAY, v_DAILY.FEEDER_SEGMENT_ID, v_TX_LOSS_PATTERN_ID, v_DX_LOSS_PATTERN_ID);

			--If the DER is active, process it.  Otherwise, delete its data.
			IF UT.BOOLEAN_FROM_NUMBER(v_DER_IS_ACTIVE) THEN

				--Get the DER Scale and Exception factors.
				GET_DER_FACTORS(v_DER_ID, v_DAILY.PROGRAM_ID, v_DAY, p_SERVICE_CODE, v_DAILY.SCALE_FACTOR, v_DAILY.FAILURE_RATE, v_DAILY.OPT_OUT_RATE, v_DAILY.OVERRIDE_RATE);

				--Get the Calendar Result ID and queue it up for processing
				IF NVL(v_CALENDAR_ID,0) = CONSTANTS.NOT_ASSIGNED THEN
					LOGS.LOG_ERROR('No Calendar Assignment for '||TEXT_UTIL.TO_CHAR_ENTITY(v_DER_ID, EC.ED_DER, TRUE));

				ELSE
				-- ONLY CONTINUE TRYING TO CREATE DER_DAILY_RESULT IF WE CAN FIND A CALENDAR ASSIGNMENT

					v_DAILY.LOAD_SHAPE_RESULT_ID := GET_LOAD_RESULT_CALENDAR_ID(v_CALENDAR_ID, p_SERVICE_CODE, p_SCENARIO_ID, v_WEATHER_STATION_ID, v_DAILY.SOURCE_TIME_ZONE, v_DAILY.RESULT_INTERVAL);
					INSERT INTO TEMP_LOAD_RESULT_CAL_LIST(LOAD_RESULT_ID) VALUES (v_DAILY.LOAD_SHAPE_RESULT_ID);

					--Get the Loss Result IDs and queue them up for processing
					v_DAILY.TX_LOSS_FACTOR_RESULT_ID := GET_LOAD_RESULT_LOSS_ID(v_TX_LOSS_PATTERN_ID, p_SERVICE_CODE, p_SCENARIO_ID, v_DAILY.SOURCE_TIME_ZONE, v_DAILY.RESULT_INTERVAL, TRUE);
					v_DAILY.DX_LOSS_FACTOR_RESULT_ID := GET_LOAD_RESULT_LOSS_ID(v_DX_LOSS_PATTERN_ID, p_SERVICE_CODE, p_SCENARIO_ID, v_DAILY.SOURCE_TIME_ZONE, v_DAILY.RESULT_INTERVAL, TRUE);
					IF v_DAILY.TX_LOSS_FACTOR_RESULT_ID IS NULL OR v_DAILY.DX_LOSS_FACTOR_RESULT_ID IS NULL THEN
						IF v_DERS_WITHOUT_LOSS_FACTORS.COUNT = 0 OR v_DERS_WITHOUT_LOSS_FACTORS(v_DERS_WITHOUT_LOSS_FACTORS.LAST).ID <> v_DAILY.DER_ID THEN
							v_DERS_WITHOUT_LOSS_FACTORS.EXTEND();
							v_DERS_WITHOUT_LOSS_FACTORS(v_DERS_WITHOUT_LOSS_FACTORS.LAST) := ID_TYPE(v_DAILY.DER_ID);
						END IF;
					END IF;

					--Get the Hits Remaining Result ID and queue it up for processing
					IF p_SERVICE_CODE = CONSTANTS.CODE_FORECAST OR p_SCENARIO_ID <> GA.BASE_SCENARIO_ID THEN
						v_DAILY.HITS_REMAINING_RESULT_ID := GET_LOAD_RESULT_ENTITY_ID(EC.ED_SERVICE_LOCATION, v_DAILY.SERVICE_LOCATION_ID, p_SERVICE_CODE, p_SCENARIO_ID, v_DAILY.SOURCE_TIME_ZONE, c_DATA_TYPE_DER_AVAILABILITY, v_DAILY.RESULT_INTERVAL);
						INSERT INTO TEMP_LOAD_RESULT_HITS_LIST(LOAD_RESULT_ID) VALUES (v_DAILY.HITS_REMAINING_RESULT_ID);
					END IF;

					--Store the record to DER_DAILY_RESULT
					PUT_DER_DAILY_RESULT(v_DAILY);

				END IF;
			ELSE
				--Delete this record if it was an invalid DER.
				DELETE_DER_DAILY_RESULT(v_DAILY);
			END IF;

			v_DAY := v_DAY + 1;

			v_DEVICE_DAY_COUNT := v_DEVICE_DAY_COUNT + 1;
			IF v_DEVICE_DAY_COMMIT_SIZE > 0 AND v_DEVICE_DAY_COUNT >= v_DEVICE_DAY_COMMIT_SIZE THEN
				COMMIT; SAVEPOINT BEFORE_RUN_DER_FORECAST;
				v_DEVICE_DAY_COUNT := 0;
			END IF;
		END LOOP;
	END LOOP;
	CLOSE v_CANDIDATES;

	--Log some warnings.
	v_COUNT := v_DERS_WITHOUT_LOSS_FACTORS.COUNT;
	IF v_COUNT > 0 THEN
		IF v_COUNT < 11 THEN
			LOGS.LOG_WARN('No Loss Factor Assignment for '||v_COUNT||' '||TEXT_UTIL.TO_CHAR_ENTITY_LIST(v_DERS_WITHOUT_LOSS_FACTORS, EC.ED_DER, TRUE));
		ELSE
			LOGS.LOG_WARN('No Loss Factor Assignment for '||v_COUNT||' Distributed Energy Resources.  View Attachment for full Resource list.');
			LOGS.POST_EVENT_DETAILS('Entities', CONSTANTS.MIME_TYPE_TEXT, TEXT_UTIL.TO_CLOB_ENTITY_LIST(v_DERS_WITHOUT_LOSS_FACTORS, EC.ED_DER, p_INITIAL_TEXT => 'No Loss Factor Assignment for '||v_COUNT||' Resources:'));
		END IF;
	END IF;


EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			IF v_CANDIDATES%ISOPEN THEN CLOSE v_CANDIDATES; END IF;
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE('Exception attempting to close v_CANDIDATES');
		END;
		ERRS.LOG_AND_RAISE;
END PROCESS_DER_DAILY_RESULTS;
----------------------------------------------------------------------------------------------------
--Takes in a standard calendar or loss profile and adjusts it to the specified
--  interval, for the specified day, taking DST into account as well.
FUNCTION COERCE_PROFILE
	(
	p_PROFILE IN NUMBER_COLLECTION,
	p_DAY IN DATE,
	p_RESULT_INTERVAL IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_USE_AVERAGE IN BOOLEAN,
	p_ENTITY_DOMAIN_ID IN NUMBER, --For error messages
	p_ENTITY_ID IN NUMBER         --For error messages
	) RETURN LOAD_RESULT_DATA_TABLE IS

	v_RTN LOAD_RESULT_DATA_TABLE := LOAD_RESULT_DATA_TABLE();
	v_PROFILE_INTERVAL VARCHAR2(16);
	v_PROFILE_NUM NUMBER;
	v_RESULT_INTERVAL VARCHAR2(16) := NVL(GET_INTERVAL_ABBREVIATION(p_RESULT_INTERVAL),DATE_UTIL.c_ABBR_HOUR);
	v_RESULT_NUM NUMBER := GET_INTERVAL_NUMBER(v_RESULT_INTERVAL);
	v_INTERVAL_BEGIN DATE;
	v_INTERVAL_END DATE;
	v_SPRING_AHEAD BOOLEAN := FALSE;
	v_FALL_BACK BOOLEAN := FALSE;
	v_SKIP BOOLEAN := FALSE;
	v_INDEX BINARY_INTEGER;
	v_RESULT_DATE DATE;
	v_RESULT_VAL NUMBER := 0;
	v_PROFILE_COUNT BINARY_INTEGER;
	v_REPEAT BINARY_INTEGER := 0;
	v_AGGREGATE BINARY_INTEGER := 1;
	v_AGG_COUNT BINARY_INTEGER := 0;

	PROCEDURE APPEND(p_DATE DATE, p_VAL NUMBER, p_AGG_COUNT IN BINARY_INTEGER) IS BEGIN
		v_RTN.EXTEND;
		IF p_USE_AVERAGE THEN
			v_RTN(v_RTN.LAST) := LOAD_RESULT_DATA_TYPE(NULL, p_DATE, p_VAL/(CASE p_AGG_COUNT WHEN 0 THEN 1 ELSE p_AGG_COUNT END));
		ELSE
			v_RTN(v_RTN.LAST) := LOAD_RESULT_DATA_TYPE(NULL, p_DATE, p_VAL);
		END IF;
	END APPEND;

BEGIN
	UT.CUT_DAY_INTERVAL_RANGE(1, p_DAY, p_DAY, p_TIME_ZONE, v_RESULT_INTERVAL, v_INTERVAL_BEGIN, v_INTERVAL_END);

	v_RESULT_DATE := v_INTERVAL_BEGIN;
	v_PROFILE_COUNT := p_PROFILE.COUNT;
	IF v_PROFILE_COUNT NOT IN (1, 24, 48, 96) THEN
		ERRS.RAISE_BUSINESS_RULE_ERROR(p_BUSINESS_RULE => 'Invalid Number of Items ('||v_PROFILE_COUNT|| ') was encountered in the profile for '||TEXT_UTIL.TO_CHAR_ENTITY(p_ENTITY_ID, p_ENTITY_DOMAIN_ID, TRUE)||'.');
	END IF;
	v_PROFILE_INTERVAL := NVL(GET_INTERVAL_ABBREVIATION(CASE v_PROFILE_COUNT WHEN 1 THEN 'Day' WHEN 24 THEN 'Hour' WHEN 48 THEN '30 Minute' WHEN 96 THEN '15 Minute' ELSE NULL END),DATE_UTIL.c_ABBR_HOUR);
	v_PROFILE_NUM := GET_INTERVAL_NUMBER(v_PROFILE_INTERVAL);

	v_SPRING_AHEAD := p_DAY = TRUNC(DST_SPRING_AHEAD_DATE(p_DAY)) AND NOT (INTERVAL_IS_ATLEAST_DAILY(v_PROFILE_INTERVAL) AND INTERVAL_IS_ATLEAST_DAILY(v_RESULT_INTERVAL));
	v_FALL_BACK := p_DAY = TRUNC(DST_FALL_BACK_DATE(p_DAY)) AND NOT (INTERVAL_IS_ATLEAST_DAILY(v_PROFILE_INTERVAL)AND INTERVAL_IS_ATLEAST_DAILY(v_RESULT_INTERVAL));

	--Determine number of times to repeat each profile value if we are spreading a profile
	--   out into a smaller result num
	IF v_PROFILE_NUM > v_RESULT_NUM THEN
		v_REPEAT := DATE_UTIL.GET_INTERVAL_DIVISOR(v_PROFILE_INTERVAL, v_RESULT_INTERVAL) - 1;
	--Otherwise, find the number of intervals we aggregate (average) together into a single value.
	ELSIF v_RESULT_NUM > v_PROFILE_NUM THEN
		v_AGGREGATE := DATE_UTIL.GET_INTERVAL_DIVISOR(v_RESULT_INTERVAL, v_PROFILE_INTERVAL);
	END IF;

	FOR v_INDEX IN p_PROFILE.FIRST .. p_PROFILE.LAST LOOP

		--On the Spring Ahead Date, skip the second hour
		IF v_SPRING_AHEAD THEN
			IF CEIL(v_INDEX / DATE_UTIL.GET_INTERVAL_DIVISOR('', v_PROFILE_INTERVAL)) = CAST(to_char(DST_SPRING_AHEAD_DATE(v_RESULT_DATE), 'HH24')AS NUMBER) THEN
				v_SKIP := TRUE;
			END IF;
		END IF;

		IF NOT v_SKIP THEN
			IF v_AGGREGATE > 1 THEN
				--Handle aggregation for multiple profile intervals summing into fewer result intervals.
				v_RESULT_VAL := v_RESULT_VAL + p_PROFILE(v_INDEX);
				v_AGG_COUNT := v_AGG_COUNT + 1;
				IF MOD(v_INDEX, v_AGGREGATE) > 0 THEN
					v_SKIP := TRUE;
				END IF;

				--Handle adding the extra hour into daily results
				IF v_FALL_BACK AND INTERVAL_IS_ATLEAST_DAILY(v_RESULT_INTERVAL) AND CEIL(v_INDEX / DATE_UTIL.GET_INTERVAL_DIVISOR('', v_PROFILE_INTERVAL)) = CAST(to_char(DST_FALL_BACK_DATE(v_RESULT_DATE), 'HH24')AS NUMBER)  THEN
					v_RESULT_VAL := v_RESULT_VAL + p_PROFILE(v_INDEX);
					v_AGG_COUNT := v_AGG_COUNT + 1;
				END IF;
			ELSE
				v_RESULT_VAL := p_PROFILE(v_INDEX);
			END IF;
		END IF;

		--Pipe out the row
		FOR v_REPEAT_IDX IN 0 .. v_REPEAT LOOP
			IF (NOT v_SKIP) AND (v_RESULT_DATE <= v_INTERVAL_END) THEN --Don't go past the end of the short day.
				APPEND(v_RESULT_DATE, v_RESULT_VAL, v_AGG_COUNT);

				--On the Fall Back Date, duplicate everything in the second hour into the next hour.
				IF v_FALL_BACK THEN
					IF CEIL(v_INDEX / DATE_UTIL.GET_INTERVAL_DIVISOR('', v_PROFILE_INTERVAL)) = CAST(to_char(DST_FALL_BACK_DATE(v_RESULT_DATE), 'HH24')AS NUMBER) OR (INTERVAL_IS_ATLEAST_DAILY(v_PROFILE_INTERVAL) AND TO_CHAR(v_RESULT_DATE,'HH24MISS') BETWEEN '000001' AND '010000') THEN
						APPEND(v_RESULT_DATE + 1/24, v_RESULT_VAL, v_AGG_COUNT);
					END IF;
					--Advance the date an hour if this is the last fallback interval.
					IF DST_FALL_BACK_DATE(v_RESULT_DATE) = v_RESULT_DATE + 1/24 AND (v_REPEAT_IDX = v_REPEAT OR INTERVAL_IS_ATLEAST_DAILY(v_PROFILE_INTERVAL)) THEN
						v_RESULT_DATE := v_RESULT_DATE + 1/24;
					END IF;
				END IF;

				IF v_REPEAT = 0 THEN
					v_RESULT_VAL := 0;
					v_AGG_COUNT := 0;
				END IF;
				v_RESULT_DATE := ADVANCE_DATE(v_RESULT_DATE, v_RESULT_INTERVAL);

			END IF;
		END LOOP;

		v_SKIP := FALSE;
	END LOOP;

	RETURN v_RTN;

END COERCE_PROFILE;
--------------------------------------------------------------------------
--Return a test profile of the specified interval
PROCEDURE GET_TEST_PROFILE
	(
	p_INTERVAL IN VARCHAR2,
	p_PROFILE OUT GA.NUMBER_TABLE
	) AS
	v_COUNT BINARY_INTEGER;
	i BINARY_INTEGER;
BEGIN
	LOGS.LOG_WARN('A Test Profile was generated rather than using an actual profile.');
	v_COUNT := 24*60 / DATE_UTIL.GET_NUMBER_OF_MINUTES(p_INTERVAL);

	FOR i IN 1 .. v_COUNT LOOP
		p_PROFILE(i) := i;
	END LOOP;

END GET_TEST_PROFILE;
--------------------------------------------------------------------------
FUNCTION PIPE_LOAD_RESULT_CALENDAR_DATA
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_IN_CURSOR IN SYS_REFCURSOR
	) RETURN LOAD_RESULT_DATA_TABLE
PIPELINED
PARALLEL_ENABLE (PARTITION p_IN_CURSOR BY ANY) IS

	v_RESULT_ROW LOAD_RESULT_CALENDAR%ROWTYPE;
	v_ROW TEMP_LOAD_RESULT_CAL_LIST%ROWTYPE;
	v_DAY DATE := TRUNC(p_BEGIN_DATE);
	v_TRACE_ON BOOLEAN := LOGS.IS_DEBUG_ENABLED;
	v_TMP_PROFILE GA.NUMBER_TABLE;
	v_PROFILE NUMBER_COLLECTION := NUMBER_COLLECTION();
	v_INDEX BINARY_INTEGER;
	v_PARAMETER_CODE CHAR(1);
	v_RESULT_DATA LOAD_RESULT_DATA_TABLE;

BEGIN
	SECURITY_CONTROLS.INIT_PARALLEL_SESSION;

	--Loop over each Calendar Result
	LOOP
		FETCH p_IN_CURSOR INTO v_ROW;
		EXIT WHEN p_IN_CURSOR%NOTFOUND;

		SELECT * INTO v_RESULT_ROW FROM LOAD_RESULT_CALENDAR WHERE LOAD_RESULT_ID = v_ROW.LOAD_RESULT_ID;
		LOGS.LOG_DEBUG('Processing Calendar Load Result Id='||v_ROW.LOAD_RESULT_ID);
		v_PARAMETER_CODE := CASE v_RESULT_ROW.SERVICE_CODE WHEN CONSTANTS.CODE_FORECAST THEN 'F' ELSE 'A' END;

		--Loop over each day in the date range
		v_DAY := TRUNC(p_BEGIN_DATE);
		WHILE v_DAY <= p_END_DATE LOOP

			IF g_TEST_PROFILE_INTERVAL IS NOT NULL THEN
				GET_TEST_PROFILE(g_TEST_PROFILE_INTERVAL, v_TMP_PROFILE);
			ELSE
				FS.COMPOSITE_PROFILE_FOR_CALENDAR(v_RESULT_ROW.WEATHER_STATION_ID, v_RESULT_ROW.CALENDAR_ID, 0, v_DAY, v_TMP_PROFILE, v_TRACE_ON, v_PARAMETER_CODE);
			END IF;

			--Turn the GA.NUMBER_TABLE into a NUMBER_COLLECTION so we can use the same code to coerce it.
			--  This is a bit wasteful, but the hope is that the FS call above will eventually be rewritten
			--  to hand us a NUMBER_COLLECTION in the first place.
			v_PROFILE.DELETE;
			FOR v_INDEX IN v_TMP_PROFILE.FIRST .. v_TMP_PROFILE.LAST LOOP
				v_PROFILE.EXTEND();
				v_PROFILE(v_PROFILE.LAST) := v_TMP_PROFILE(v_INDEX);
			END LOOP;

			--Adjust the profile for time zones, disparate intervals, and DST, then pipe it out.
			v_RESULT_DATA := COERCE_PROFILE(v_PROFILE, v_DAY, v_RESULT_ROW.RESULT_INTERVAL, v_RESULT_ROW.SOURCE_TIME_ZONE, FALSE, EC.ED_CALENDAR, v_RESULT_ROW.CALENDAR_ID);
			FOR v_INDEX IN v_RESULT_DATA.FIRST .. v_RESULT_DATA.LAST LOOP
				PIPE ROW(LOAD_RESULT_DATA_TYPE(v_RESULT_ROW.LOAD_RESULT_ID, v_RESULT_DATA(v_INDEX).RESULT_DATE, v_RESULT_DATA(v_INDEX).RESULT_VAL));
			END LOOP;

			v_DAY := v_DAY + 1;
		END LOOP; -- over days
	END LOOP;
	CLOSE p_IN_CURSOR;

	SECURITY_CONTROLS.FINISH_PARALLEL_SESSION;
	RETURN;

EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			IF p_IN_CURSOR%ISOPEN THEN CLOSE p_IN_CURSOR; END IF;
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE('Exception attempting to close p_IN_CURSOR');
		END;
		ERRS.LOG_AND_RAISE;
END PIPE_LOAD_RESULT_CALENDAR_DATA;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_LOSS_FACTOR_SCHED_CURSOR
	(
	p_BEGIN_DAY IN DATE,
	p_END_DAY IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_LOSS_FACTOR_INTERVAL IN VARCHAR2,
	p_RESULT_INTERVAL IN VARCHAR2,
	p_PATTERN_ID IN NUMBER,
	p_RESULT_DATA_CURSOR OUT t_RESULT_DATA_CURSOR
	) AS

	v_LF_ABBR VARCHAR2(16) := NVL(GET_INTERVAL_ABBREVIATION(p_LOSS_FACTOR_INTERVAL),DATE_UTIL.c_ABBR_HOUR);
	v_LF_NUM NUMBER := GET_INTERVAL_NUMBER(v_LF_ABBR);
	v_RES_ABBR VARCHAR2(16) := NVL(GET_INTERVAL_ABBREVIATION(p_RESULT_INTERVAL),DATE_UTIL.c_ABBR_HOUR);
	v_RES_NUM NUMBER := GET_INTERVAL_NUMBER(v_RES_ABBR);
	v_CUT_BEGIN_DATE DATE;
	v_CUT_END_DATE DATE;
BEGIN
	UT.CUT_DATE_RANGE(p_BEGIN_DAY, p_END_DAY, p_TIME_ZONE, v_CUT_BEGIN_DATE, v_CUT_END_DATE);

	-- Get a cursor of loss factor dates and values for "Schedule" type Loss Factors.
	IF v_LF_NUM = v_RES_NUM THEN
		--Cursor for a Schedule Loss Factor whose Interval == our Result Interval
		OPEN p_RESULT_DATA_CURSOR FOR
			SELECT PATTERN_DATE, EXPANSION_VAL
			FROM LOSS_FACTOR_PATTERN
			WHERE PATTERN_ID = p_PATTERN_ID
				AND PATTERN_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE;

	ELSIF v_LF_NUM > v_RES_NUM THEN
		--Cursor for a Schedule Loss Factor whose Interval > our Result Interval
		OPEN p_RESULT_DATA_CURSOR FOR
			SELECT SDT.CUT_DATE, EXPANSION_VAL
			FROM LOSS_FACTOR_PATTERN P, SYSTEM_DATE_TIME SDT
			WHERE SDT.TIME_ZONE = p_TIME_ZONE
				AND SDT.DATA_INTERVAL_TYPE = 1
				AND SDT.DAY_TYPE = '1'
				AND SDT.CUT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
				AND SDT.MINIMUM_INTERVAL_NUMBER >= v_RES_NUM
				AND P.PATTERN_ID = p_PATTERN_ID
				AND P.PATTERN_DATE = CASE v_LF_ABBR
					WHEN 'DD' THEN SDT.LOCAL_DAY_TRUNC_DATE
					ELSE DATE_UTIL.HED_TRUNC(SDT.CUT_DATE, v_LF_ABBR) END;

	ELSE
		--Cursor for a Schedule Loss Factor whose Interval < our Result Interval
		OPEN p_RESULT_DATA_CURSOR FOR
			SELECT CASE v_RES_ABBR WHEN 'DD' THEN SDT.LOCAL_DAY_TRUNC_DATE ELSE DATE_UTIL.HED_TRUNC(PATTERN_DATE, v_RES_ABBR) END, AVG(EXPANSION_VAL)
			FROM LOSS_FACTOR_PATTERN P, SYSTEM_DATE_TIME SDT
			WHERE SDT.TIME_ZONE = p_TIME_ZONE
				AND SDT.DATA_INTERVAL_TYPE = 1
				AND SDT.DAY_TYPE = '1'
				AND SDT.CUT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
				AND SDT.MINIMUM_INTERVAL_NUMBER >= v_LF_NUM
				AND P.PATTERN_ID = p_PATTERN_ID
				AND P.PATTERN_DATE = SDT.CUT_DATE
			GROUP BY CASE v_RES_ABBR WHEN 'DD' THEN SDT.LOCAL_DAY_TRUNC_DATE ELSE DATE_UTIL.HED_TRUNC(PATTERN_DATE, v_RES_ABBR) END;

	END IF;

END GET_LOSS_FACTOR_SCHED_CURSOR;
--------------------------------------------------------------------------
FUNCTION PIPE_LOAD_RESULT_LOSS_DATA
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_IN_CURSOR IN SYS_REFCURSOR
	) RETURN LOAD_RESULT_DATA_TABLE
PIPELINED
PARALLEL_ENABLE (PARTITION p_IN_CURSOR BY ANY) IS

	v_RESULT_ROW LOAD_RESULT_LOSS_FACTOR%ROWTYPE;
	v_ROW TEMP_LOAD_RESULT_LOSS_LIST%ROWTYPE;
	v_MODEL LOSS_FACTOR_MODEL%ROWTYPE;
	v_DAY DATE := TRUNC(p_BEGIN_DATE);
	v_LF_CURSOR t_RESULT_DATA_CURSOR;
	v_LF_ROW rec_RESULT_DATA;
	v_PROFILE NUMBER_COLLECTION := NUMBER_COLLECTION();
	v_INDEX BINARY_INTEGER;
	v_RESULT_DATA LOAD_RESULT_DATA_TABLE;
	v_COUNT BINARY_INTEGER;
BEGIN
	SECURITY_CONTROLS.INIT_PARALLEL_SESSION;

	--Loop over each Loss Factor Result
	LOOP
		FETCH p_IN_CURSOR INTO v_ROW;
		EXIT WHEN p_IN_CURSOR%NOTFOUND;

		SELECT * INTO v_RESULT_ROW FROM LOAD_RESULT_LOSS_FACTOR WHERE LOAD_RESULT_ID = v_ROW.LOAD_RESULT_ID;
		LOGS.LOG_DEBUG('Processing Loss Factor Load Result Id='||v_ROW.LOAD_RESULT_ID);

		SELECT * INTO v_MODEL FROM LOSS_FACTOR_MODEL
		WHERE PATTERN_ID = v_RESULT_ROW.LOSS_FACTOR_PATTERN_ID;

		--Log a warning if the Loss Factor has any types other than Transmission and Distribution.
		SELECT COUNT(1) INTO v_COUNT
		FROM LOSS_FACTOR_MODEL
		WHERE LOSS_FACTOR_ID = v_MODEL.LOSS_FACTOR_ID
			AND p_BEGIN_DATE <= NVL(END_DATE, CONSTANTS.HIGH_DATE)
			AND p_END_DATE >= BEGIN_DATE
			AND LOSS_TYPE NOT IN (c_LOSS_TYPE_TX, c_LOSS_TYPE_DX);

		IF v_COUNT > 0 THEN
			LOGS.LOG_WARN(TEXT_UTIL.TO_CHAR_ENTITY(v_MODEL.LOSS_FACTOR_ID, EC.ED_LOSS_FACTOR, TRUE)||
				' has Model Types other than Transmission and Distribution.  These losses will be ignored.');
		END IF;

		IF GET_INTERVAL_NUMBER(v_MODEL.INTERVAL) < GET_INTERVAL_NUMBER(v_RESULT_ROW.RESULT_INTERVAL) THEN
			LOGS.LOG_WARN('Loss Factor Interval is less than Result Interval.  Loss Factors were averaged together for '||TEXT_UTIL.TO_CHAR_ENTITY(v_MODEL.LOSS_FACTOR_ID, EC.ED_LOSS_FACTOR, TRUE));
		END IF;

		--Get a cursor with the results if this is a schedule type loss factor and pipe out the results.
		IF v_MODEL.MODEL_TYPE = CONSTANTS.LOSS_FACTOR_MODEL_SCHEDULE THEN
			GET_LOSS_FACTOR_SCHED_CURSOR(TRUNC(p_BEGIN_DATE), TRUNC(p_END_DATE), v_RESULT_ROW.SOURCE_TIME_ZONE, v_MODEL.INTERVAL, v_RESULT_ROW.RESULT_INTERVAL, v_MODEL.PATTERN_ID, v_LF_CURSOR);
			LOOP
				FETCH v_LF_CURSOR INTO v_LF_ROW;
				EXIT WHEN v_LF_CURSOR%NOTFOUND;
				PIPE ROW(LOAD_RESULT_DATA_TYPE(v_RESULT_ROW.LOAD_RESULT_ID, v_LF_ROW.RESULT_DATE, v_LF_ROW.RESULT_VAL));
			END LOOP;
			CLOSE v_LF_CURSOR;
		--Or if this is a "Pattern" type loss factor, get a number collection to loop through for more processing.
		ELSE
			SELECT P.EXPANSION_VAL BULK COLLECT INTO v_PROFILE
			FROM LOSS_FACTOR_PATTERN P WHERE P.PATTERN_ID = v_MODEL.PATTERN_ID ORDER BY P.PATTERN_DATE;

			--Loop over each day in the date range
			v_DAY := TRUNC(p_BEGIN_DATE);
			WHILE v_DAY <= p_END_DATE LOOP
				--Adjust the loss profile for time zones, disparate intervals, and DST, then pipe it out.
				v_RESULT_DATA := COERCE_PROFILE(v_PROFILE, v_DAY, v_RESULT_ROW.RESULT_INTERVAL, v_RESULT_ROW.SOURCE_TIME_ZONE, TRUE, EC.ED_LOSS_FACTOR, v_MODEL.LOSS_FACTOR_ID);
				FOR v_INDEX IN v_RESULT_DATA.FIRST .. v_RESULT_DATA.LAST LOOP
					PIPE ROW(LOAD_RESULT_DATA_TYPE(v_RESULT_ROW.LOAD_RESULT_ID, v_RESULT_DATA(v_INDEX).RESULT_DATE, v_RESULT_DATA(v_INDEX).RESULT_VAL));
				END LOOP;
				v_DAY := v_DAY + 1;
			END LOOP; -- over days
		END IF;
	END LOOP;
	CLOSE p_IN_CURSOR;

	SECURITY_CONTROLS.FINISH_PARALLEL_SESSION;
	RETURN;

EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			IF p_IN_CURSOR%ISOPEN THEN CLOSE p_IN_CURSOR; END IF;
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE('Exception attempting to close p_IN_CURSOR');
		END;
		BEGIN
			IF v_LF_CURSOR%ISOPEN THEN CLOSE v_LF_CURSOR; END IF;
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE('Exception attempting to close v_LF_CURSOR');
		END;
		ERRS.LOG_AND_RAISE;
END PIPE_LOAD_RESULT_LOSS_DATA;
----------------------------------------------------------------------------------------------------
-- This function has been replaced with the STORE_LOAD_RESULT_HITS_DATA,
--   but I wanted to keep it around for one commit in order to commit some
--   minor fixes I made for it, just incase we wind up reverting back to this
--   approach in the future.
/*FUNCTION PIPE_LOAD_RESULT_HITS_DATA
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_IN_CURSOR IN SYS_REFCURSOR
	) RETURN LOAD_RESULT_DATA_TABLE
PIPELINED
PARALLEL_ENABLE (PARTITION p_IN_CURSOR BY ANY) IS

	v_RESULT_ROW LOAD_RESULT_ENTITY%ROWTYPE;
	v_ROW TEMP_LOAD_RESULT_HITS_LIST%ROWTYPE;
	v_DAY DATE := TRUNC(p_BEGIN_DATE);
	v_RESULT_INTERVAL VARCHAR2(16);
	v_RESULT_NUM NUMBER;
	v_SERVICE_LOCATION_ID NUMBER(9);
	v_EDC_ID NUMBER(9);
	v_DAY_NAME CHAR(3);
	v_CUT_BEGIN_DATE DATE;
	v_CUT_END_DATE DATE;
BEGIN
	SECURITY_CONTROLS.INIT_PARALLEL_SESSION;

	--Loop over each Hits Remaining Result we need to process
	LOOP
		FETCH p_IN_CURSOR INTO v_ROW;
		EXIT WHEN p_IN_CURSOR%NOTFOUND;

		SELECT * INTO v_RESULT_ROW FROM LOAD_RESULT_ENTITY WHERE LOAD_RESULT_ID = v_ROW.LOAD_RESULT_ID;
		v_RESULT_INTERVAL := GET_INTERVAL_ABBREVIATION(v_RESULT_ROW.RESULT_INTERVAL);
		v_RESULT_NUM := GET_INTERVAL_NUMBER(v_RESULT_INTERVAL);
		LOGS.LOG_DEBUG('Processing Hits Available Load Result Id='||v_ROW.LOAD_RESULT_ID);

		--Get the Service Location ID we are processing.
		IF v_RESULT_ROW.ENTITY_DOMAIN_ID <> EC.ED_SERVICE_LOCATION THEN
			ERRS.RAISE_BUSINESS_RULE_ERROR(p_BUSINESS_RULE => 'DER Availability can only be calculated for a Service Location.');
		END IF;
		v_SERVICE_LOCATION_ID := v_RESULT_ROW.ENTITY_ID;

		--Loop over each day in the date range
		v_DAY := TRUNC(p_BEGIN_DATE);
		WHILE v_DAY <= p_END_DATE LOOP
			v_EDC_ID := GET_EDC_ID_FOR_SERVICE_LOC(v_SERVICE_LOCATION_ID, v_DAY);
			v_DAY_NAME := CASE WHEN IS_HOLIDAY(v_DAY, v_EDC_ID) THEN 'Hol' ELSE TO_CHAR(v_DAY, 'Dy') END;
			UT.CUT_DATE_RANGE(1, v_DAY, v_DAY, v_RESULT_ROW.SOURCE_TIME_ZONE, v_CUT_BEGIN_DATE, v_CUT_END_DATE);

			FOR v_HITS_ROW IN
			(SELECT SDT.CUT_DATE AS RESULT_DATE,
				MIN(P.MAX_LIMIT -
					(SELECT NVL(SUM(U.HITS_USED),0)
					FROM PROGRAM_LIMIT_HITS_USED U, DR_EVENT E
					WHERE U.PROGRAM_LIMIT_ID = P.PROGRAM_LIMIT_ID
						AND U.SERVICE_LOCATION_ID = v_SERVICE_LOCATION_ID
						AND SDT.CUT_DATE BETWEEN U.PERIOD_START_DATE AND U.PERIOD_STOP_DATE
						AND E.EVENT_ID = U.EVENT_ID
						AND SDT.CUT_DATE > E.STOP_TIME
						)) HITS_REMAINING
			FROM SYSTEM_DATE_TIME SDT, SEASON_DATES SD, SEASON_TEMPLATE ST, PROGRAM_LIMIT P
			WHERE SDT.TIME_ZONE = v_RESULT_ROW.SOURCE_TIME_ZONE
				AND SDT.DATA_INTERVAL_TYPE = 1
				AND SDT.DAY_TYPE = '1'
				AND SDT.CUT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
				AND SDT.LOCAL_DAY_TRUNC_DATE BETWEEN SD.BEGIN_DATE AND SD.END_DATE
				AND SDT.MINIMUM_INTERVAL_NUMBER >= v_RESULT_NUM
				AND ST.SEASON_ID = SD.SEASON_ID
				AND ST.DAY_NAME = v_DAY_NAME
				AND TO_NUMBER(SUBSTR(SDT.HOUR_YYYY_MM_DD,12,2)) BETWEEN ST.BEGIN_HOUR AND ST.END_HOUR
				AND P.LIMIT_TYPE = DEMAND_RESPONSE_UTIL.c_LIMIT_TYPE_EXECUTION
				AND P.TEMPLATE_ID = ST.TEMPLATE_ID
				AND P.PERIOD_ID = ST.PERIOD_ID
			GROUP BY CUT_DATE) LOOP
				PIPE ROW(LOAD_RESULT_DATA_TYPE(v_RESULT_ROW.LOAD_RESULT_ID, v_HITS_ROW.RESULT_DATE, v_HITS_ROW.HITS_REMAINING));
			END LOOP;

			v_DAY := v_DAY + 1;
		END LOOP; -- over days
	END LOOP;
	CLOSE p_IN_CURSOR;

	SECURITY_CONTROLS.FINISH_PARALLEL_SESSION;
	RETURN;

EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			IF p_IN_CURSOR%ISOPEN THEN CLOSE p_IN_CURSOR; END IF;
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE('Exception attempting to close p_IN_CURSOR');
		END;
		ERRS.LOG_AND_RAISE;
END PIPE_LOAD_RESULT_HITS_DATA;
*/
----------------------------------------------------------------------------------------------------
FUNCTION STORE_LOAD_RESULT_HITS_DATA
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_IN_CURSOR IN SYS_REFCURSOR
	) RETURN LOAD_RESULT_DATA_TABLE
PIPELINED
PARALLEL_ENABLE (PARTITION p_IN_CURSOR BY ANY)
IS
	PRAGMA AUTONOMOUS_TRANSACTION;

	v_RESULT_ROW LOAD_RESULT_ENTITY%ROWTYPE;
	v_ROW TEMP_LOAD_RESULT_HITS_LIST%ROWTYPE;
	v_RESULT_INTERVAL VARCHAR2(16);
	v_RESULT_NUM NUMBER;
	v_SERVICE_LOCATION_ID NUMBER(9);
	v_CUT_BEGIN_DATE DATE;
	v_CUT_END_DATE DATE;
	
	v_TEMPLATES NUMBER_COLLECTION;
	v_HOLIDAY_SETS NUMBER_COLLECTION;
BEGIN
	SECURITY_CONTROLS.INIT_PARALLEL_SESSION;

	--Loop over each Hits Remaining Result we need to process
	LOOP
		FETCH p_IN_CURSOR INTO v_ROW;
		EXIT WHEN p_IN_CURSOR%NOTFOUND;

		SELECT * INTO v_RESULT_ROW FROM LOAD_RESULT_ENTITY WHERE LOAD_RESULT_ID = v_ROW.LOAD_RESULT_ID;
		v_RESULT_INTERVAL := NVL(GET_INTERVAL_ABBREVIATION(v_RESULT_ROW.RESULT_INTERVAL),DATE_UTIL.c_ABBR_HOUR);
		v_RESULT_NUM := GET_INTERVAL_NUMBER(v_RESULT_INTERVAL);
		LOGS.LOG_DEBUG('Processing Hits Available Load Result Id='||v_ROW.LOAD_RESULT_ID);

		--Get the Service Location ID we are processing.
		IF v_RESULT_ROW.ENTITY_DOMAIN_ID <> EC.ED_SERVICE_LOCATION THEN
			ERRS.RAISE_BUSINESS_RULE_ERROR(p_BUSINESS_RULE => 'DER Availability can only be calculated for a Service Location.');
		END IF;
		v_SERVICE_LOCATION_ID := v_RESULT_ROW.ENTITY_ID;

		--The assumption is that it is actually a relatively rare occurrence for us to exceed the available hits.
		--  therefore, we are deleting out the data beforehand, and inserting only the intervals in which hits
		--  have been exceeded.
		UT.CUT_DATE_RANGE(1, p_BEGIN_DATE, p_END_DATE, v_RESULT_ROW.SOURCE_TIME_ZONE, v_CUT_BEGIN_DATE, v_CUT_END_DATE);
		DELETE LOAD_RESULT_DATA
		WHERE LOAD_RESULT_ID = v_ROW.LOAD_RESULT_ID
			AND RESULT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE;
			
		SELECT DISTINCT PL.TEMPLATE_ID
		BULK COLLECT INTO v_TEMPLATES
		FROM PROGRAM_LIMIT PL;
		
		SELECT DISTINCT HOLIDAY_SET_ID
		BULK COLLECT INTO v_HOLIDAY_SETS
		FROM (SELECT DISTINCT EDC.EDC_HOLIDAY_SET_ID AS HOLIDAY_SET_ID
				FROM ACCOUNT_SERVICE_LOCATION ASL,
					ACCOUNT_EDC AEDC,
					ENERGY_DISTRIBUTION_COMPANY EDC
				WHERE ASL.SERVICE_LOCATION_ID = v_SERVICE_LOCATION_ID
					AND ASL.BEGIN_DATE <= p_END_DATE
					AND ASL.END_DATE >= p_BEGIN_DATE
					AND AEDC.ACCOUNT_ID = ASL.ACCOUNT_ID
					AND AEDC.BEGIN_DATE <= LEAST(ASL.END_DATE, p_END_DATE)
					AND AEDC.END_DATE >= GREATEST(ASL.BEGIN_DATE, p_BEGIN_DATE)
					AND EDC.EDC_ID = AEDC.EDC_ID
					AND EDC.EDC_HOLIDAY_SET_ID IS NOT NULL
				UNION ALL
				SELECT CONSTANTS.ALL_HOLIDAYS_HOLIDAY_SET AS HOLIDAY_SET_ID
				FROM DUAL);
				
		SP.CHECK_TEMPLATE_DATES(v_TEMPLATES,
								v_HOLIDAY_SETS,
								v_RESULT_ROW.SOURCE_TIME_ZONE,
								p_BEGIN_DATE,
								p_END_DATE);

		INSERT INTO LOAD_RESULT_DATA(LOAD_RESULT_ID, RESULT_DATE, RESULT_VAL)
		SELECT * FROM 
			(SELECT v_ROW.LOAD_RESULT_ID AS LOAD_RESULT_ID,
					TD.CUT_BEGIN_DATE + DT.TIME_STAMP AS RESULT_DATE,
					MIN(PL.MAX_LIMIT - 
							(SELECT NVL(SUM(U.HITS_USED),0)
								FROM PROGRAM_LIMIT_HITS_USED U, DR_EVENT E
								WHERE U.PROGRAM_LIMIT_ID = PL.PROGRAM_LIMIT_ID
								  AND U.SERVICE_LOCATION_ID = v_SERVICE_LOCATION_ID
								  AND DT.TIME_STAMP + TD.CUT_BEGIN_DATE 
								  		BETWEEN U.PERIOD_START_DATE AND U.PERIOD_STOP_DATE
								  AND E.EVENT_ID = U.EVENT_ID
								  AND (DT.TIME_STAMP + TD.CUT_BEGIN_DATE) > E.STOP_TIME)) AS RESULT_VAL
					FROM PROGRAM_LIMIT PL,
						(SELECT T.*, ASL.ACCOUNT_ID
							FROM TEMPLATE_DATES T,
								ACCOUNT_SERVICE_LOCATION ASL
							WHERE ASL.SERVICE_LOCATION_ID = v_SERVICE_LOCATION_ID
								AND T.LOCAL_DATE BETWEEN ASL.BEGIN_DATE AND NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE)) TD,
						TEMPLATE_DAY_TYPE_PERIOD DT,
						(SELECT EDC.EDC_HOLIDAY_SET_ID, AEDC.ACCOUNT_ID,
								AEDC.BEGIN_DATE, AEDC.END_DATE
							FROM ACCOUNT_EDC AEDC,
								ENERGY_DISTRIBUTION_COMPANY EDC
							WHERE AEDC.EDC_ID = EDC.EDC_ID) ACCT_HS
					WHERE TD.TIME_ZONE = v_RESULT_ROW.SOURCE_TIME_ZONE
						AND TD.TEMPLATE_ID = PL.TEMPLATE_ID
						AND v_CUT_BEGIN_DATE <= TD.CUT_END_DATE
						AND v_CUT_END_DATE > TD.CUT_BEGIN_DATE
						AND ACCT_HS.ACCOUNT_ID (+) = TD.ACCOUNT_ID
						AND TD.LOCAL_DATE BETWEEN ACCT_HS.BEGIN_DATE (+) AND NVL(ACCT_HS.END_DATE (+), CONSTANTS.HIGH_DATE)
						AND TD.HOLIDAY_SET_ID = NVL(ACCT_HS.EDC_HOLIDAY_SET_ID, CONSTANTS.ALL_HOLIDAYS_HOLIDAY_SET)
						AND DT.DAY_TYPE_ID = TD.DAY_TYPE_ID
						AND DT.MINIMUM_INTERVAL_NUMBER >= v_RESULT_NUM
						AND DT.TIME_STAMP BETWEEN (v_CUT_BEGIN_DATE - TD.CUT_BEGIN_DATE)
												AND (v_CUT_END_DATE - TD.CUT_BEGIN_DATE)
						AND DT.PERIOD_ID = PL.PERIOD_ID
						AND PL.LIMIT_TYPE = DEMAND_RESPONSE_UTIL.c_LIMIT_TYPE_EXECUTION
					GROUP BY (TD.CUT_BEGIN_DATE + DT.TIME_STAMP))
		WHERE RESULT_VAL <= 0;
		
	END LOOP;
	CLOSE p_IN_CURSOR;

    -- The COMMIT has to come before the PIPE, or else we get an error about an autonomous transaction
    --   that has not been committed.
	COMMIT;
	PIPE ROW(LOAD_RESULT_DATA_TYPE(NULL, NULL, NULL));
	SECURITY_CONTROLS.FINISH_PARALLEL_SESSION;

	-- The RETURN here just avoids a compiler warning.
	RETURN;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE;
		BEGIN
			IF p_IN_CURSOR%ISOPEN THEN CLOSE p_IN_CURSOR; END IF;
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE('Exception attempting to close p_IN_CURSOR');
		END;
		ERRS.LOG_AND_RAISE;
END STORE_LOAD_RESULT_HITS_DATA;
----------------------------------------------------------------------------------------------------
PROCEDURE PROCESS_DER_RESULT_SUMMARY
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ENTITY_IDs IN NUMBER_COLLECTION,
	p_SERVICE_CODE IN CHAR,
	p_SCENARIO_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CALCULATE_FULL_SUMMARY IN NUMBER
	) AS

BEGIN

	--We only calculate the summary if the flag is set, or if the entity domain is VPP, Program, or All.
	IF p_ENTITY_DOMAIN_ID IN (CONSTANTS.ALL_ID, EC.ED_VPP, EC.ED_PROGRAM) OR UT.BOOLEAN_FROM_NUMBER(p_CALCULATE_FULL_SUMMARY) THEN
		CALC_SEGMENT_RESULT_FROM_DER(p_SERVICE_CODE, p_SCENARIO_ID, p_BEGIN_DATE, p_END_DATE,
			CASE WHEN UT.BOOLEAN_FROM_NUMBER(p_CALCULATE_FULL_SUMMARY) THEN CONSTANTS.ALL_ID ELSE p_ENTITY_DOMAIN_ID END,
			p_ENTITY_IDs, 0, TRUE);
	END IF;

END PROCESS_DER_RESULT_SUMMARY;
----------------------------------------------------------------------------------------------------
PROCEDURE RUN_DER_FORECAST
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ENTITY_IDs IN NUMBER_COLLECTION,
	p_SERVICE_CODE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PROCESS_ID OUT NUMBER,
	p_PROCESS_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR2,
	p_CALCULATE_FULL_SUMMARY IN NUMBER := 1,
	p_SCENARIO_ID IN NUMBER := GA.BASE_SCENARIO_ID,
	p_TRACE_ON IN NUMBER := 0,
	p_DISABLE_PARALLEL_EXECUTION IN NUMBER := NULL
	) AS
	v_DISABLE_PARALLEL_EXECUTION NUMBER(1);

	PROCEDURE INIT_STEP(p_DESC IN VARCHAR2) AS BEGIN
		LOGS.INCREMENT_PROCESS_PROGRESS(p_PROGRESS_DESCRIPTION => p_DESC);
	END INIT_STEP;

BEGIN
	SAVEPOINT BEFORE_RUN_DER_FORECAST;

	LOGS.START_PROCESS(CASE p_SERVICE_CODE WHEN 'B' THEN 'DER Capacity Estimation' ELSE 'DER Capacity Forecast' END,
		p_BEGIN_DATE, p_END_DATE,
		-- use trace flag to decide appropriate log level
		p_EVENT_LEVEL => LEAST(LOGS.CURRENT_LOG_LEVEL,
								CASE p_TRACE_ON
									WHEN 2 THEN LOGS.c_LEVEL_DEBUG_DETAIL
									WHEN 1 THEN LOGS.c_LEVEL_DEBUG
									ELSE LOGS.c_LEVEL_FATAL
									END));
	p_PROCESS_ID := LOGS.CURRENT_PROCESS_ID;

	LOGS.SET_PROCESS_TARGET_PARAMETER('ENTITY_IDs', TEXT_UTIL.TO_CHAR_ENTITY_LIST(p_ENTITY_IDS, p_ENTITY_DOMAIN_ID, TRUE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('SERVICE_CODE', p_SERVICE_CODE);
	LOGS.SET_PROCESS_TARGET_PARAMETER('CALCULATE_FULL_SUMMARY', p_CALCULATE_FULL_SUMMARY);
	LOGS.SET_PROCESS_TARGET_PARAMETER('SCENARIO', TEXT_UTIL.TO_CHAR_ENTITY(p_SCENARIO_ID, EC.ED_SCENARIO));

	v_DISABLE_PARALLEL_EXECUTION := NVL(p_DISABLE_PARALLEL_EXECUTION, UT.NUMBER_FROM_BOOLEAN(IS_PARALLEL_EXECUTION_DISABLED()));
	LOGS.SET_PROCESS_TARGET_PARAMETER('DISABLE_PARALLEL_EXECUTION', v_DISABLE_PARALLEL_EXECUTION);

	LOGS.INIT_PROCESS_PROGRESS('Initializing', 6, 'Steps', TRUE);
	SD.VERIFY_ACTION_IS_ALLOWED(p_ACTION_NAME => SD.g_ACTION_RUN_DER_FORECAST);

	--Note that this SAVEPOINT is also used inside PROCESS_RESULTS.
	COMMIT; SAVEPOINT BEFORE_RUN_DER_FORECAST;

	--Daily DER Results
	INIT_STEP('Resolving Daily DER Relationships');
	PROCESS_DER_DAILY_RESULTS(p_ENTITY_DOMAIN_ID, p_ENTITY_IDs, p_SERVICE_CODE, p_SCENARIO_ID, p_BEGIN_DATE, p_END_DATE);
	COMMIT; SAVEPOINT BEFORE_RUN_DER_FORECAST;

	--Load Shapes
	INIT_STEP('Calculating Calendar Load Shapes');
	PROCESS_CALENDAR_RESULTS(p_BEGIN_DATE, p_END_DATE, v_DISABLE_PARALLEL_EXECUTION, TRUE);
	COMMIT; SAVEPOINT BEFORE_RUN_DER_FORECAST;

	--Loss Factors
	INIT_STEP('Calculating Loss Factors');
	PROCESS_LOSS_FACTOR_RESULTS(p_BEGIN_DATE, p_END_DATE, v_DISABLE_PARALLEL_EXECUTION, TRUE);
	COMMIT; SAVEPOINT BEFORE_RUN_DER_FORECAST;

	--Hits Remaining
	INIT_STEP('Calculating Hits Remaining');
	PROCESS_HITS_RESULTS(p_BEGIN_DATE, p_END_DATE, v_DISABLE_PARALLEL_EXECUTION, TRUE);
	COMMIT; SAVEPOINT BEFORE_RUN_DER_FORECAST;

	--Summarization
	INIT_STEP('Summarizing Results');
	PROCESS_DER_RESULT_SUMMARY(p_ENTITY_DOMAIN_ID, p_ENTITY_IDs, p_SERVICE_CODE, p_SCENARIO_ID, p_BEGIN_DATE, p_END_DATE, p_CALCULATE_FULL_SUMMARY);
	COMMIT; SAVEPOINT BEFORE_RUN_DER_FORECAST;

	--Finish up
	CLEANUP_DER_TEMP_TABLES;
	LOGS.STOP_PROCESS(p_MESSAGE, p_PROCESS_STATUS);
	COMMIT;

EXCEPTION
	WHEN OTHERS THEN
		CLEANUP_DER_TEMP_TABLES;
		ERRS.ABORT_PROCESS(p_SAVEPOINT_NAME => 'BEFORE_RUN_DER_FORECAST');
END;
----------------------------------------------------------------------------------------------------
-- This gets called before a large set of external results are stored.
PROCEDURE BEFORE_STORE_EXT_DER_RESULTS AS
BEGIN
	CLEANUP_DER_TEMP_TABLES;
	g_MIN_DER_RESULT_DATE := NULL;
	g_MAX_DER_RESULT_DATE := NULL;
END BEFORE_STORE_EXT_DER_RESULTS;
----------------------------------------------------------------------------------------------------
PROCEDURE STORE_EXTERNAL_DER_RESULTS
	(
	p_DER_ID IN NUMBER,
	p_SERVICE_CODE IN CHAR,
	p_RESULT_INTERVAL IN VARCHAR2,
	p_LOAD_DATES IN DATE_COLLECTION,
	p_LOAD_SHAPE IN NUMBER_COLLECTION
	) AS
	v_INDEX BINARY_INTEGER;
	v_DAY DATE;
	v_PREV_DAY DATE := LOW_DATE;
	v_DAILY DER_DAILY_RESULT%ROWTYPE;
	v_SCENARIO_ID NUMBER(9) := GA.BASE_SCENARIO_ID;
	v_TX_LOSS_PATTERN_ID NUMBER(9);
	v_DX_LOSS_PATTERN_ID NUMBER(9);
	DUMMY NUMBER;
	DUMMY_STR VARCHAR2(256);
	v_MULT NUMBER;
	v_DER_IS_ACTIVE NUMBER;
BEGIN
	ASSERT(p_LOAD_DATES.COUNT = p_LOAD_SHAPE.COUNT, 'Load Dates and Load Shape Collections must contain the same number of elements.');
	v_DAILY.DER_ID := p_DER_ID;
	v_DAILY.IS_EXTERNAL := 1;
	v_DAILY.SERVICE_CODE := p_SERVICE_CODE;
	v_DAILY.SCENARIO_ID := GA.BASE_SCENARIO_ID;
	v_DAILY.SOURCE_TIME_ZONE := GET_TIME_ZONE_FOR_DER(p_DER_ID);
	v_DAILY.RESULT_INTERVAL := p_RESULT_INTERVAL;
	v_DAILY.HITS_REMAINING_RESULT_ID := NULL;
	v_DAILY.SCALE_FACTOR := 1;
	v_DAILY.FAILURE_RATE := 0;
	v_DAILY.OPT_OUT_RATE := 0;
	v_DAILY.OVERRIDE_RATE := 0;
	v_DAILY.ENTRY_DATE := SYSDATE;
	GET_STATIC_DER_ASSIGNMENTS(p_DER_ID, v_DAILY.DER_TYPE_ID, v_DAILY.EXTERNAL_SYSTEM_ID, v_DAILY.SERVICE_ZONE_ID, v_DAILY.SUB_STATION_ID, v_DAILY.FEEDER_ID, v_DAILY.FEEDER_SEGMENT_ID, v_DAILY.SERVICE_LOCATION_ID, DUMMY);

	--Get the multiplier to convert from KWh, if needed.
	v_MULT := GET_UNIT_MULTIPLIER(p_SERVICE_CODE, FALSE, p_RESULT_INTERVAL);

	FOR v_INDEX IN p_LOAD_DATES.FIRST .. p_LOAD_DATES.LAST LOOP
		v_DAY := TRUNC(FROM_CUT(p_LOAD_DATES(v_INDEX), v_DAILY.SOURCE_TIME_ZONE) - 1/86400);

		--Get the daily DER record whenever the day changes
		IF v_DAY <> v_PREV_DAY THEN
			v_DAILY.RESULT_DAY := v_DAY;
			UT.CUT_DATE_RANGE(1, v_DAY, v_DAY, v_DAILY.SOURCE_TIME_ZONE, v_DAILY.CUT_BEGIN_DATE, v_DAILY.CUT_END_DATE);
			GET_TEMPORAL_DER_ASSIGNMENTS(p_DER_ID, v_DAY, v_DER_IS_ACTIVE, v_DAILY.PROGRAM_ID, v_DAILY.ACCOUNT_ID, v_DAILY.EDC_ID, DUMMY, DUMMY_STR);
			GET_LOSS_PATTERNS_FOR_SEGMENT(v_DAY, v_DAILY.FEEDER_SEGMENT_ID, v_TX_LOSS_PATTERN_ID, v_DX_LOSS_PATTERN_ID);
			v_DAILY.LOAD_SHAPE_RESULT_ID := GET_LOAD_RESULT_ENTITY_ID(EC.ED_DER, p_DER_ID, p_SERVICE_CODE, v_SCENARIO_ID, v_DAILY.SOURCE_TIME_ZONE, c_DATA_TYPE_DER_EXTERNAL, p_RESULT_INTERVAL);
			v_DAILY.TX_LOSS_FACTOR_RESULT_ID := GET_LOAD_RESULT_LOSS_ID(v_TX_LOSS_PATTERN_ID, p_SERVICE_CODE, v_SCENARIO_ID, v_DAILY.SOURCE_TIME_ZONE, v_DAILY.RESULT_INTERVAL, TRUE);
			v_DAILY.DX_LOSS_FACTOR_RESULT_ID := GET_LOAD_RESULT_LOSS_ID(v_DX_LOSS_PATTERN_ID, p_SERVICE_CODE, v_SCENARIO_ID, v_DAILY.SOURCE_TIME_ZONE, v_DAILY.RESULT_INTERVAL, TRUE);
			PUT_DER_DAILY_RESULT(v_DAILY);

			--Update the date range over which we will need to recalc loss factors, and add the Loss Factors to the list.
			g_MIN_DER_RESULT_DATE := LEAST(NVL(g_MIN_DER_RESULT_DATE, v_DAY), v_DAY);
			g_MAX_DER_RESULT_DATE := GREATEST(NVL(g_MAX_DER_RESULT_DATE, v_DAY), v_DAY);
		END IF;

		--Merge this interval's data into the Load Shape Result
		MERGE INTO LOAD_RESULT_DATA R
		USING (SELECT v_DAILY.LOAD_SHAPE_RESULT_ID AS LOAD_RESULT_ID,
				p_LOAD_DATES(v_INDEX) AS RESULT_DATE,
				v_MULT*p_LOAD_SHAPE(v_INDEX) AS RESULT_VAL FROM DUAL) SRC
		ON (R.LOAD_RESULT_ID = SRC.LOAD_RESULT_ID AND R.RESULT_DATE = SRC.RESULT_DATE)
		WHEN MATCHED THEN UPDATE SET R.RESULT_VAL = SRC.RESULT_VAL
		WHEN NOT MATCHED THEN INSERT (R.LOAD_RESULT_ID, R.RESULT_DATE, R.RESULT_VAL)
			VALUES (SRC.LOAD_RESULT_ID, SRC.RESULT_DATE, SRC.RESULT_VAL);

		v_PREV_DAY := v_DAY;
	END LOOP;

END STORE_EXTERNAL_DER_RESULTS;
----------------------------------------------------------------------------------------------------
-- This gets called after a large set of external results are stored.
--   It initiates a re-calc of any loss factors that were referenced.
PROCEDURE AFTER_STORE_EXT_DER_RESULTS AS
BEGIN
	IF g_MIN_DER_RESULT_DATE IS NOT NULL AND g_MAX_DER_RESULT_DATE IS NOT NULL THEN
		PROCESS_LOSS_FACTOR_RESULTS(g_MIN_DER_RESULT_DATE, g_MAX_DER_RESULT_DATE, 1);
	END IF;
	CLEANUP_DER_TEMP_TABLES;
END AFTER_STORE_EXT_DER_RESULTS;
----------------------------------------------------------------------------------------------------
FUNCTION GET_HOLIDAY_SET_FOR_SERV_LOC
	(
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_DATE IN DATE
	) RETURN NUMBER IS
	
	v_RESULT NUMBER(9);
	
BEGIN
	
	SELECT NVL(MIN(EDC.EDC_HOLIDAY_SET_ID), CONSTANTS.ALL_HOLIDAYS_HOLIDAY_SET)
	INTO v_RESULT
	FROM ACCOUNT_SERVICE_LOCATION ASL,
		ACCOUNT_EDC AEDC,
		ENERGY_DISTRIBUTION_COMPANY EDC
	WHERE ASL.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
		AND p_DATE BETWEEN ASL.BEGIN_DATE AND NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE)
		AND AEDC.ACCOUNT_ID = ASL.ACCOUNT_ID
		AND p_DATE BETWEEN AEDC.BEGIN_DATE AND NVL(AEDC.END_DATE, CONSTANTS.HIGH_DATE)
		AND EDC.EDC_ID = AEDC.EDC_ID;
		
	RETURN v_RESULT;

END GET_HOLIDAY_SET_FOR_SERV_LOC;
----------------------------------------------------------------------------------------------------
END DER_CAPACITY_ENGINE;
/
