CREATE OR REPLACE PACKAGE REACTOR_UI AS
--Revision $Revision: 1.5 $

-- User Interface package for the Reactor

FUNCTION WHAT_VERSION RETURN VARCHAR;

-- Action procedure for resetting all the parameters
-- for a procedure
PROCEDURE REBUILD_PROC_PARAMETERS
	(
	p_REACTOR_PROCEDURE_ID IN NUMBER
	);

-- SQL Helper function
FUNCTION SUMMARIZE_PROC_PARAMETERS
	(
	p_REACTOR_PROCEDURE_ID IN NUMBER
	) RETURN VARCHAR2;

------------------------------------------------
-- Reactor Report Master Grid Procedures
------------------------------------------------

-- Gets the distinct list of Procedure Names that have been used
-- in the REACTOR_PROCEDURE table.
PROCEDURE GET_DISTINCT_PROCEDURE_LIST
	(
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_REACTOR_PROC_SUMMARY
	(
	p_CLIENT_CLOCK IN DATE,
	p_FILTER_ENTITY_DOMAIN_ID IN NUMBER,
	p_FILTER_ENTITY_TYPE_AND_ID IN NUMBER,
	p_CURRENT_STATE OUT VARCHAR2,
	p_LAST_COMPLETED_RUN OUT DATE,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE PUT_REACTOR_PROC_SUMMARY
	(
	p_REACTOR_PROCEDURE_ID IN NUMBER,
	p_REACTOR_PROCEDURE_NAME IN VARCHAR2,
	p_REACTOR_PROCEDURE_DESC IN VARCHAR2,
	p_TABLE_ID IN NUMBER,
	p_PROCEDURE_NAME IN VARCHAR2,
	p_JOB_THREAD_ID IN NUMBER,
	p_JOB_COMMENTS IN VARCHAR2,
	p_IS_IMMEDIATE IN NUMBER,
	p_IS_ENABLED IN NUMBER,
	p_CALL_ORDER IN NUMBER,
	p_SKIP_WHEN_FORMULA IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2
	);

------------------------------------------------
-- Reactor Report Entities Grid Procedures
------------------------------------------------

PROCEDURE GET_REACTOR_PROC_INPUTS
	(
	p_REACTOR_PROCEDURE_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_DOMAIN_FOR_TABLE_LIST
	(
	p_TABLE_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_FILTER_DOMAIN_LIST
	(
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_ENTITY_TYPE_AND_ID_LIST
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_SYSTEM_TABLE_LIST
	(
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE PUT_REACTOR_PROC_INPUT
	(
	p_REACTOR_PROCEDURE_ID IN NUMBER,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ENTITY_TYPE_AND_ID IN NUMBER,
	p_INPUT_BEGIN_DATE IN DATE,
	p_INPUT_END_DATE IN DATE,
	p_OLD_ENTITY_DOMAIN_ID IN NUMBER,
	p_OLD_ENTITY_TYPE_AND_ID IN NUMBER,
	p_OLD_INPUT_BEGIN_DATE IN DATE
	);

PROCEDURE DEL_REACTOR_PROC_INPUT
	(
	p_REACTOR_PROCEDURE_ID IN NUMBER,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ENTITY_TYPE_AND_ID IN NUMBER,
	p_INPUT_BEGIN_DATE IN DATE
	);

------------------------------------------------
-- Reactor Report Parameters Procedures
------------------------------------------------

PROCEDURE GET_REACTOR_PROC_PARAMS
	(
	p_REACTOR_PROCEDURE_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE PUT_REACTOR_PROC_PARAM
	(
	p_REACTOR_PROCEDURE_ID IN NUMBER,
	p_PARAMETER_NAME IN VARCHAR2,
	p_PARAMETER_TYPE IN VARCHAR2,
	p_PARAMETER_FORMULA IN VARCHAR2,
	p_PARAMETER_ORDER IN NUMBER,
	p_OLD_PARAMETER_NAME IN VARCHAR2
	);

PROCEDURE DEL_REACTOR_PROC_PARAM
	(
	p_REACTOR_PROCEDURE_ID IN NUMBER,
	p_PARAMETER_NAME IN VARCHAR2
	);

------------------------------------------------
-- Reactor Report Entity Ref Procedures
------------------------------------------------

PROCEDURE GET_ENTITY_FOR_REF_LIST
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_REACTOR_PROC_ENTITY_REFS
    (
	p_REACTOR_PROCEDURE_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    );

PROCEDURE PUT_REACTOR_PROC_ENTITY_REF
    (
    p_REACTOR_PROCEDURE_ID IN NUMBER,
    p_REFERENCE_NAME IN VARCHAR2,
    p_ENTITY_DOMAIN_ID IN NUMBER,
    p_ENTITY_ID IN NUMBER,
    p_OLD_REFERENCE_NAME IN VARCHAR2
    );

PROCEDURE DEL_REACTOR_PROC_ENTITY_REF
	(
	p_REACTOR_PROCEDURE_ID IN NUMBER,
	p_REFERENCE_NAME IN VARCHAR2
	);

------------------------------------------------
-- Other Reactor UI procedures
------------------------------------------------

-- Get the list of Calc Processes for the Entity List of the
-- Data Exchange to generate calc engine procs.
PROCEDURE GET_CALC_PROCESS_LIST
	(
	p_CURSOR OUT GA.REFCURSOR
	);

-- Automatically generates a set of Reactor Procs based on the
-- Calc Processes that are specified.
PROCEDURE GENERATE_CALC_ENGINE_PROCS
	(
	p_ENTITY_ID_COLLECTION IN NUMBER_COLLECTION,
	p_BEGIN_DATE IN DATE,
	p_MESSAGE OUT VARCHAR2
	);

END REACTOR_UI;
/
CREATE OR REPLACE PACKAGE BODY REACTOR_UI AS
----------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
	RETURN '$Revision: 1.5 $';
END WHAT_VERSION;
----------------------------------------------------------------------------------------------------
PROCEDURE REBUILD_PROC_PARAMETERS
	(
	p_REACTOR_PROCEDURE_ID IN NUMBER
	) AS
	v_PARAMS STORED_PROC_PARAMETER_TABLE;
	v_PROC_NAME REACTOR_PROCEDURE.PROCEDURE_NAME%TYPE;
	v_ILLEGAL_PARAM_COUNT BINARY_INTEGER;
BEGIN

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_REACTOR_PROCEDURE_ID, EC.ED_REACTOR_PROCEDURE);

	-- Get the list of Params according to the current DB Source.
	SELECT PROCEDURE_NAME INTO v_PROC_NAME FROM REACTOR_PROCEDURE WHERE REACTOR_PROCEDURE_ID = p_REACTOR_PROCEDURE_ID;
	UT.GET_STORED_PROC_PARAMETERS(v_PROC_NAME, 0, v_PARAMS);

	-- Raise an exception if we encounter anything other than IN parameters.
	SELECT COUNT(1)
	INTO v_ILLEGAL_PARAM_COUNT
	FROM TABLE(CAST(v_PARAMS AS STORED_PROC_PARAMETER_TABLE)) X
	WHERE PARAMETER_DIRECTION <> 'IN';

	IF v_ILLEGAL_PARAM_COUNT > 0 THEN
		ERRS.RAISE(MSGCODES.c_ERR_INVALID_REACTOR_PROC, TEXT_UTIL.TO_CHAR_ENTITY(p_REACTOR_PROCEDURE_ID,EC.ED_REACTOR_PROCEDURE)
			||' is invalid. The Stored Procedure may not contain "OUT" or "IN OUT" parameters.');
	END IF;

	-- Delete any parameters we have that aren't there according to the DB Source.
	DELETE REACTOR_PROCEDURE_PARAMETER R
	WHERE R.REACTOR_PROCEDURE_ID = p_REACTOR_PROCEDURE_ID
		AND R.PARAMETER_NAME NOT IN
			(SELECT X.PARAMETER_NAME FROM TABLE(CAST(v_PARAMS AS STORED_PROC_PARAMETER_TABLE)) X);

	-- Insert any parameters that are in the DB Source that we don't have yet.
	INSERT INTO REACTOR_PROCEDURE_PARAMETER(REACTOR_PROCEDURE_ID, PARAMETER_NAME, PARAMETER_TYPE, PARAMETER_FORMULA, PARAMETER_ORDER)
		SELECT p_REACTOR_PROCEDURE_ID, X.PARAMETER_NAME, 'Key', NULL, X.POSITION
		FROM TABLE(CAST(v_PARAMS AS STORED_PROC_PARAMETER_TABLE)) X
		WHERE X.PARAMETER_NAME NOT IN
			(SELECT PARAMETER_NAME FROM REACTOR_PROCEDURE_PARAMETER
			WHERE REACTOR_PROCEDURE_ID = p_REACTOR_PROCEDURE_ID);

END REBUILD_PROC_PARAMETERS;
----------------------------------------------------------------------------------------------------
FUNCTION SUMMARIZE_PROC_PARAMETERS
	(
	p_REACTOR_PROCEDURE_ID IN NUMBER
	) RETURN VARCHAR2 IS
v_RET VARCHAR2(8000);
CURSOR c_PARAMS IS
	SELECT PARAMETER_NAME||' = '||PARAMETER_FORMULA AS VAL
	FROM REACTOR_PROCEDURE_PARAMETER
	WHERE REACTOR_PROCEDURE_ID = p_REACTOR_PROCEDURE_ID
	ORDER BY PARAMETER_ORDER;
BEGIN
	FOR v_PARAM IN c_PARAMS LOOP
		IF v_RET IS NOT NULL THEN
			v_RET := v_RET||'; ';
		END IF;
		v_RET := v_RET||v_PARAM.VAL;
		IF LENGTH(v_RET) >= 4000 THEN
			-- we've hit the length limit, so clip and return
			RETURN SUBSTR(v_RET,1,3997)||'...';
		END IF;
	END LOOP;

		RETURN v_RET;
END SUMMARIZE_PROC_PARAMETERS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_DISTINCT_PROCEDURE_LIST
	(
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT DISTINCT PROCEDURE_NAME
		FROM REACTOR_PROCEDURE
		ORDER BY 1;
END GET_DISTINCT_PROCEDURE_LIST;
----------------------------------------------------------------------------------------------------
-- Get the list of Reactor Procedure IDs that could be affected
-- by the specified Entity.
FUNCTION GET_REACTOR_PROCEDURE_IDS
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_ALLOWED_IDS IN ID_TABLE
	) RETURN ID_TABLE AS

	v_IDS ID_TABLE := ID_TABLE();

	CURSOR c_REACTOR_PROCS IS
		SELECT R.*
		FROM REACTOR_PROCEDURE R, SYSTEM_TABLE T, TABLE(CAST(p_ALLOWED_IDS AS ID_TABLE)) X
		WHERE T.ENTITY_DOMAIN_ID = CASE WHEN p_ENTITY_DOMAIN_ID IN (EC.ED_SUB_STATION, EC.ED_SUB_STATION_METER) THEN EC.ED_SUB_STATION_METER_POINT ELSE p_ENTITY_DOMAIN_ID END
			AND R.TABLE_ID = T.TABLE_ID
			AND X.ID IN (R.REACTOR_PROCEDURE_ID, SD.g_ALL_DATA_ENTITY_ID);
BEGIN

	--Loop through each Reactor Proc, and add it to the list if it contains this entity.
	FOR v_PROC IN c_REACTOR_PROCS LOOP
		IF REACTOR.IS_ENTITY_FOR_REACTOR_PROC(v_PROC, p_ENTITY_DOMAIN_ID, p_ENTITY_ID) THEN
			v_IDS.EXTEND;
			v_IDS(v_IDS.LAST) := ID_TYPE(v_PROC.REACTOR_PROCEDURE_ID);
		END IF;
	END LOOP;
	RETURN v_IDS;

END GET_REACTOR_PROCEDURE_IDS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_REACTOR_PROC_SUMMARY
	(
	p_CLIENT_CLOCK IN DATE,
	p_FILTER_ENTITY_DOMAIN_ID IN NUMBER,
	p_FILTER_ENTITY_TYPE_AND_ID IN NUMBER,
	p_CURRENT_STATE OUT VARCHAR2,
	p_LAST_COMPLETED_RUN OUT DATE,
	p_CURSOR OUT GA.REFCURSOR
	) AS
	v_ENTITY_ID REACTOR_PROCEDURE_INPUT.ENTITY_ID%TYPE;
	v_ENTITY_TYPE REACTOR_PROCEDURE_INPUT.ENTITY_TYPE%TYPE;
	v_ENTITY_DOMAIN_ID NUMBER(9) := NVL(p_FILTER_ENTITY_DOMAIN_ID, CONSTANTS.ALL_ID);
	v_IDs ID_TABLE;
BEGIN
	v_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_SELECT_ENT, EC.ED_REACTOR_PROCEDURE);

	IF v_ENTITY_DOMAIN_ID <> CONSTANTS.ALL_ID THEN
		PR.GET_ENTITY_ID_AND_TYPE_FROM_UI(p_FILTER_ENTITY_TYPE_AND_ID, TRUE, v_ENTITY_ID, v_ENTITY_TYPE);
	ELSE
		v_ENTITY_ID := CONSTANTS.ALL_ID;
	END IF;

	p_CURRENT_STATE := REACTOR.GET_STATE;
	p_LAST_COMPLETED_RUN := REACTOR.GET_LAST_RUN_DATE_GMT + (p_CLIENT_CLOCK - SYS_EXTRACT_UTC(SYSTIMESTAMP));


	IF v_ENTITY_DOMAIN_ID = CONSTANTS.ALL_ID OR v_ENTITY_TYPE = 'E' THEN
		-- If we are getting the procedures for a single entity, limit the list to include procedures
		-- for the entity and its groups and realms.
		IF v_ENTITY_TYPE = 'E' AND v_ENTITY_DOMAIN_ID <> CONSTANTS.ALL_ID THEN
			v_IDS := GET_REACTOR_PROCEDURE_IDS(p_FILTER_ENTITY_DOMAIN_ID, v_ENTITY_ID, v_IDS);
		END IF;
		OPEN p_CURSOR FOR
			SELECT R.REACTOR_PROCEDURE_NAME,
				R.REACTOR_PROCEDURE_DESC,
				R.TABLE_ID,
				T.TABLE_NAME,
				R.PROCEDURE_NAME,
				R.JOB_THREAD_ID,
				JT.JOB_THREAD_NAME,
				R.JOB_COMMENTS,
				R.IS_IMMEDIATE,
				R.IS_ENABLED,
				R.CALL_ORDER,
				R.SKIP_WHEN_FORMULA,
				R.TIME_ZONE,
				SUMMARIZE_PROC_PARAMETERS(R.REACTOR_PROCEDURE_ID) AS PROC_PARAMETERS,
				R.REACTOR_PROCEDURE_ID,
				R.ENTRY_DATE
			FROM REACTOR_PROCEDURE R, SYSTEM_TABLE T, JOB_THREAD JT, TABLE(CAST(v_IDs AS ID_TABLE)) X
			WHERE X.ID IN (R.REACTOR_PROCEDURE_ID, SD.g_ALL_DATA_ENTITY_ID)
				AND T.TABLE_ID = R.TABLE_ID
				AND JT.JOB_THREAD_ID(+) = R.JOB_THREAD_ID
			ORDER BY CALL_ORDER, REACTOR_PROCEDURE_NAME;
	ELSE
		-- If we are getting the procedures for a group or realm, just return the list of procedures
		-- that apply to that particular group or realm.
		OPEN p_CURSOR FOR
			SELECT R.REACTOR_PROCEDURE_NAME,
				R.REACTOR_PROCEDURE_DESC,
				R.TABLE_ID,
				T.TABLE_NAME,
				R.PROCEDURE_NAME,
				R.JOB_THREAD_ID,
				JT.JOB_THREAD_NAME,
				R.JOB_COMMENTS,
				R.IS_IMMEDIATE,
				R.IS_ENABLED,
				R.CALL_ORDER,
				R.SKIP_WHEN_FORMULA,
				R.TIME_ZONE,
				SUMMARIZE_PROC_PARAMETERS(R.REACTOR_PROCEDURE_ID) AS PROC_PARAMETERS,
				R.REACTOR_PROCEDURE_ID,
				R.ENTRY_DATE
			FROM REACTOR_PROCEDURE R, SYSTEM_TABLE T, JOB_THREAD JT, REACTOR_PROCEDURE_INPUT I, TABLE(CAST(v_IDs AS ID_TABLE)) X
			WHERE X.ID IN (R.REACTOR_PROCEDURE_ID, SD.g_ALL_DATA_ENTITY_ID)
				AND T.TABLE_ID = R.TABLE_ID
				AND JT.JOB_THREAD_ID(+) = R.JOB_THREAD_ID
				AND I.REACTOR_PROCEDURE_ID = R.REACTOR_PROCEDURE_ID
				AND I.ENTITY_DOMAIN_ID = v_ENTITY_DOMAIN_ID
				AND I.ENTITY_TYPE = v_ENTITY_TYPE
				AND I.ENTITY_ID = v_ENTITY_ID
			ORDER BY CALL_ORDER, REACTOR_PROCEDURE_NAME;
	END IF;

END GET_REACTOR_PROC_SUMMARY;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_REACTOR_PROC_SUMMARY
	(
	p_REACTOR_PROCEDURE_ID IN NUMBER,
	p_REACTOR_PROCEDURE_NAME IN VARCHAR2,
	p_REACTOR_PROCEDURE_DESC IN VARCHAR2,
	p_TABLE_ID IN NUMBER,
	p_PROCEDURE_NAME IN VARCHAR2,
	p_JOB_THREAD_ID IN NUMBER,
	p_JOB_COMMENTS IN VARCHAR2,
	p_IS_IMMEDIATE IN NUMBER,
	p_IS_ENABLED IN NUMBER,
	p_CALL_ORDER IN NUMBER,
	p_SKIP_WHEN_FORMULA IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2
	) AS
	v_IS_NEW BOOLEAN;
	v_ID REACTOR_PROCEDURE.REACTOR_PROCEDURE_ID%TYPE := NVL(p_REACTOR_PROCEDURE_ID,0);
BEGIN

	v_IS_NEW := v_ID <= 0;

	--Note: DLS is handled in here.
	IO.PUT_REACTOR_PROCEDURE(v_ID,
		p_REACTOR_PROCEDURE_NAME,
		NULL,  -- ALIAS
		p_REACTOR_PROCEDURE_DESC,
		v_ID,
		p_TABLE_ID,
		p_PROCEDURE_NAME,
		CASE WHEN p_JOB_THREAD_ID = 0 THEN NULL ELSE p_JOB_THREAD_ID END,
		p_JOB_COMMENTS,
		p_CALL_ORDER,
		p_SKIP_WHEN_FORMULA,
		p_TIME_ZONE,
	  	p_IS_IMMEDIATE,
		p_IS_ENABLED);

	--Generate the parameters if we are creating a new reactor procedure.
	IF v_IS_NEW THEN
		REBUILD_PROC_PARAMETERS(v_ID);
	END IF;

END PUT_REACTOR_PROC_SUMMARY;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_REACTOR_PROC_INPUTS
	(
	p_REACTOR_PROCEDURE_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_REACTOR_PROCEDURE_ID, EC.ED_REACTOR_PROCEDURE);

	OPEN p_CURSOR FOR
		SELECT BEGIN_DATE AS INPUT_BEGIN_DATE,
			END_DATE AS INPUT_END_DATE,
			ENTITY_DOMAIN_ID,
			SIGN(ENTITY_ID) * (ABS(ENTITY_ID)*10 +
				CASE ENTITY_TYPE
					WHEN 'G' THEN PR.c_FML_ID_IS_GROUP
					WHEN 'R' THEN PR.c_FML_ID_IS_REALM
					ELSE PR.c_FML_ID_IS_ENTITY
				END) AS ENTITY_TYPE_AND_ID
		FROM REACTOR_PROCEDURE_INPUT
		WHERE REACTOR_PROCEDURE_ID = p_REACTOR_PROCEDURE_ID
		ORDER BY 1;

END GET_REACTOR_PROC_INPUTS;
----------------------------------------------------------------------------------------------------
-- Get the list of Entity Domains that are supported as
--  Inputs for the specified System Table.
PROCEDURE GET_DOMAIN_FOR_TABLE_LIST
	(
	p_TABLE_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
	v_ENTITY_DOMAIN_ID NUMBER(9);
BEGIN
	SELECT ENTITY_DOMAIN_ID INTO v_ENTITY_DOMAIN_ID FROM SYSTEM_TABLE WHERE TABLE_ID = p_TABLE_ID;
	IF v_ENTITY_DOMAIN_ID = EC.ED_SUB_STATION_METER_POINT THEN
		--If this is a Sub Station Meter Point table, we also support specifying an
		--  input by the Meter or Sub Station Level.
		OPEN p_CURSOR FOR
			SELECT ENTITY_DOMAIN_NAME, ENTITY_DOMAIN_ID
			FROM ENTITY_DOMAIN
			WHERE ENTITY_DOMAIN_ID IN (EC.ED_SUB_STATION_METER_POINT, EC.ED_SUB_STATION_METER, EC.ED_SUB_STATION);
	ELSE
		--For other tables, we only support the Entity Domain of the System Table.
		OPEN p_CURSOR FOR
			SELECT ENTITY_DOMAIN_NAME, ENTITY_DOMAIN_ID
			FROM ENTITY_DOMAIN
			WHERE ENTITY_DOMAIN_ID = v_ENTITY_DOMAIN_ID;
	END IF;

END GET_DOMAIN_FOR_TABLE_LIST;
----------------------------------------------------------------------------------------------------
-- Get all the Entity Domains that are associated with any System Table.
PROCEDURE GET_FILTER_DOMAIN_LIST
	(
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT DISTINCT A.ENTITY_DOMAIN_NAME AS FILTER_ENTITY_DOMAIN_NAME, A.ENTITY_DOMAIN_ID AS FILTER_ENTITY_DOMAIN_ID
		FROM ENTITY_DOMAIN A, SYSTEM_TABLE T
		WHERE T.ENTITY_DOMAIN_ID = A.ENTITY_DOMAIN_ID
			OR A.ENTITY_DOMAIN_ID IN (EC.ED_SUB_STATION_METER, EC.ED_SUB_STATION)
		ORDER BY 1;

END GET_FILTER_DOMAIN_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_ENTITY_TYPE_AND_ID_LIST
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
	v_STATUS NUMBER;
BEGIN
	IF p_ENTITY_DOMAIN_ID = CONSTANTS.ALL_ID THEN
		OPEN p_CURSOR FOR
			SELECT CONSTANTS.ALL_STRING AS ENTITY_NAME, CONSTANTS.ALL_ID AS ENTITY_ID FROM DUAL;
	ELSE
		PR.ENTITIES_FOR_FML_DOMAIN(0, NULL, p_ENTITY_DOMAIN_ID, 2, 1, v_STATUS, p_CURSOR);
	END IF;
END GET_ENTITY_TYPE_AND_ID_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SYSTEM_TABLE_LIST
	(
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT TABLE_NAME, TABLE_ID
		FROM SYSTEM_TABLE
		WHERE IS_REACTIVE = 1
		ORDER BY 1;

END GET_SYSTEM_TABLE_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_REACTOR_PROC_INPUT
	(
	p_REACTOR_PROCEDURE_ID IN NUMBER,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ENTITY_TYPE_AND_ID IN NUMBER,
	p_INPUT_BEGIN_DATE IN DATE,
	p_INPUT_END_DATE IN DATE,
	p_OLD_ENTITY_DOMAIN_ID IN NUMBER,
	p_OLD_ENTITY_TYPE_AND_ID IN NUMBER,
	p_OLD_INPUT_BEGIN_DATE IN DATE
	) AS
	v_ENTITY_ID REACTOR_PROCEDURE_INPUT.ENTITY_ID%TYPE;
	v_ENTITY_TYPE REACTOR_PROCEDURE_INPUT.ENTITY_TYPE%TYPE;
	v_OLD_ENTITY_ID REACTOR_PROCEDURE_INPUT.ENTITY_ID%TYPE;
	v_OLD_ENTITY_TYPE REACTOR_PROCEDURE_INPUT.ENTITY_TYPE%TYPE;
BEGIN

	PR.GET_ENTITY_ID_AND_TYPE_FROM_UI(p_ENTITY_TYPE_AND_ID, TRUE, v_ENTITY_ID, v_ENTITY_TYPE);
	PR.GET_ENTITY_ID_AND_TYPE_FROM_UI(p_OLD_ENTITY_TYPE_AND_ID, TRUE, v_OLD_ENTITY_ID, v_OLD_ENTITY_TYPE);

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_REACTOR_PROCEDURE_ID, EC.ED_REACTOR_PROCEDURE);

	UT.PUT_TEMPORAL_DATA_UI('REACTOR_PROCEDURE_INPUT',
		p_INPUT_BEGIN_DATE,
		p_INPUT_END_DATE,
		p_OLD_INPUT_BEGIN_DATE,
		FALSE,
		'REACTOR_PROCEDURE_ID',
		UT.GET_LITERAL_FOR_NUMBER(p_REACTOR_PROCEDURE_ID),
		UT.GET_LITERAL_FOR_NUMBER(p_REACTOR_PROCEDURE_ID),
		TRUE,
		'ENTITY_DOMAIN_ID',
		UT.GET_LITERAL_FOR_NUMBER(p_ENTITY_DOMAIN_ID),
		UT.GET_LITERAL_FOR_NUMBER(p_OLD_ENTITY_DOMAIN_ID),
		TRUE,
		'ENTITY_TYPE',
		UT.GET_LITERAL_FOR_STRING(v_ENTITY_TYPE),
		UT.GET_LITERAL_FOR_STRING(v_OLD_ENTITY_TYPE),
		TRUE,
		'ENTITY_ID',
		UT.GET_LITERAL_FOR_NUMBER(v_ENTITY_ID),
		UT.GET_LITERAL_FOR_STRING(v_OLD_ENTITY_ID),
		TRUE);

END PUT_REACTOR_PROC_INPUT;
----------------------------------------------------------------------------------------------------
PROCEDURE DEL_REACTOR_PROC_INPUT
	(
	p_REACTOR_PROCEDURE_ID IN NUMBER,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ENTITY_TYPE_AND_ID IN NUMBER,
	p_INPUT_BEGIN_DATE IN DATE
	) AS
	v_ENTITY_ID REACTOR_PROCEDURE_INPUT.ENTITY_ID%TYPE;
	v_ENTITY_TYPE REACTOR_PROCEDURE_INPUT.ENTITY_TYPE%TYPE;
BEGIN
	PR.GET_ENTITY_ID_AND_TYPE_FROM_UI(p_ENTITY_TYPE_AND_ID, TRUE, v_ENTITY_ID, v_ENTITY_TYPE);

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_REACTOR_PROCEDURE_ID, EC.ED_REACTOR_PROCEDURE);

	DELETE REACTOR_PROCEDURE_INPUT
	WHERE REACTOR_PROCEDURE_ID = p_REACTOR_PROCEDURE_ID
		AND ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID
		AND ENTITY_TYPE = v_ENTITY_TYPE
		AND ENTITY_ID = v_ENTITY_ID
		AND BEGIN_DATE = p_INPUT_BEGIN_DATE;

END DEL_REACTOR_PROC_INPUT;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_REACTOR_PROC_PARAMS
	(
	p_REACTOR_PROCEDURE_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_REACTOR_PROCEDURE_ID, EC.ED_REACTOR_PROCEDURE);

	OPEN p_CURSOR FOR
		SELECT PARAMETER_NAME,
			PARAMETER_TYPE,
			PARAMETER_FORMULA,
			PARAMETER_ORDER
		FROM REACTOR_PROCEDURE_PARAMETER
		WHERE REACTOR_PROCEDURE_ID = p_REACTOR_PROCEDURE_ID
		ORDER BY PARAMETER_ORDER;

END GET_REACTOR_PROC_PARAMS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_REACTOR_PROC_PARAM
	(
	p_REACTOR_PROCEDURE_ID IN NUMBER,
	p_PARAMETER_NAME IN VARCHAR2,
	p_PARAMETER_TYPE IN VARCHAR2,
	p_PARAMETER_FORMULA IN VARCHAR2,
	p_PARAMETER_ORDER IN NUMBER,
	p_OLD_PARAMETER_NAME IN VARCHAR2
	) AS
BEGIN
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_REACTOR_PROCEDURE_ID, EC.ED_REACTOR_PROCEDURE);

	UPDATE REACTOR_PROCEDURE_PARAMETER
	SET PARAMETER_NAME = p_PARAMETER_NAME,
		PARAMETER_TYPE = p_PARAMETER_TYPE,
		PARAMETER_FORMULA = p_PARAMETER_FORMULA,
		PARAMETER_ORDER = p_PARAMETER_ORDER
	WHERE REACTOR_PROCEDURE_ID = p_REACTOR_PROCEDURE_ID
		AND PARAMETER_NAME = p_OLD_PARAMETER_NAME;

	IF SQL%NOTFOUND THEN
		INSERT INTO REACTOR_PROCEDURE_PARAMETER (
			REACTOR_PROCEDURE_ID,
			PARAMETER_NAME,
			PARAMETER_TYPE,
			PARAMETER_FORMULA,
			PARAMETER_ORDER
			)
		VALUES (
			p_REACTOR_PROCEDURE_ID,
			p_PARAMETER_NAME,
			p_PARAMETER_TYPE,
			p_PARAMETER_FORMULA,
			p_PARAMETER_ORDER
			);
	END IF;
END PUT_REACTOR_PROC_PARAM;
----------------------------------------------------------------------------------------------------
PROCEDURE DEL_REACTOR_PROC_PARAM
	(
	p_REACTOR_PROCEDURE_ID IN NUMBER,
	p_PARAMETER_NAME IN VARCHAR2
	) AS
BEGIN

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_REACTOR_PROCEDURE_ID, EC.ED_REACTOR_PROCEDURE);

	DELETE REACTOR_PROCEDURE_PARAMETER
	WHERE REACTOR_PROCEDURE_ID = p_REACTOR_PROCEDURE_ID
		AND PARAMETER_NAME = p_PARAMETER_NAME;

END DEL_REACTOR_PROC_PARAM;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_ENTITY_FOR_REF_LIST
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_WORK_ID RTO_WORK.WORK_ID%TYPE;
BEGIN
	SD.ENUMERATE_ENTITIES(SD.g_ACTION_SELECT_ENT, p_ENTITY_DOMAIN_ID, v_WORK_ID);

	OPEN p_CURSOR FOR
		SELECT WORK_DATA as ENTITY_NAME, WORK_XID as ENTITY_ID
		FROM RTO_WORK
		WHERE WORK_ID = v_WORK_ID
		ORDER BY 1;

END GET_ENTITY_FOR_REF_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_REACTOR_PROC_ENTITY_REFS
    (
	p_REACTOR_PROCEDURE_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_REACTOR_PROCEDURE_ID, EC.ED_REACTOR_PROCEDURE);

    OPEN p_CURSOR FOR
        SELECT REFERENCE_NAME,
            ENTITY_DOMAIN_ID,
            ENTITY_ID,
            ENTRY_DATE
        FROM REACTOR_PROCEDURE_ENTITY_REF
        WHERE REACTOR_PROCEDURE_ID = p_REACTOR_PROCEDURE_ID
        ORDER BY REFERENCE_NAME;

END GET_REACTOR_PROC_ENTITY_REFS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_REACTOR_PROC_ENTITY_REF
    (
    p_REACTOR_PROCEDURE_ID IN NUMBER,
    p_REFERENCE_NAME IN VARCHAR2,
    p_ENTITY_DOMAIN_ID IN NUMBER,
    p_ENTITY_ID IN NUMBER,
    p_OLD_REFERENCE_NAME IN VARCHAR2
    ) AS
BEGIN
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_REACTOR_PROCEDURE_ID, EC.ED_REACTOR_PROCEDURE);

    UPDATE REACTOR_PROCEDURE_ENTITY_REF SET
        REFERENCE_NAME = p_REFERENCE_NAME,
        ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID,
        ENTITY_ID = p_ENTITY_ID,
        ENTRY_DATE = SYSDATE
    WHERE REACTOR_PROCEDURE_ID = p_REACTOR_PROCEDURE_ID
        AND REFERENCE_NAME = p_OLD_REFERENCE_NAME;

    IF SQL%NOTFOUND THEN
        INSERT INTO REACTOR_PROCEDURE_ENTITY_REF (
            REACTOR_PROCEDURE_ID,
            REFERENCE_NAME,
            ENTITY_DOMAIN_ID,
            ENTITY_ID,
            ENTRY_DATE)
        VALUES (
            p_REACTOR_PROCEDURE_ID,
            p_REFERENCE_NAME,
            p_ENTITY_DOMAIN_ID,
            p_ENTITY_ID,
            SYSDATE);
    END IF;

END PUT_REACTOR_PROC_ENTITY_REF;
----------------------------------------------------------------------------------------------------
PROCEDURE DEL_REACTOR_PROC_ENTITY_REF
	(
	p_REACTOR_PROCEDURE_ID IN NUMBER,
	p_REFERENCE_NAME IN VARCHAR2
	) AS
BEGIN

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_REACTOR_PROCEDURE_ID, EC.ED_REACTOR_PROCEDURE);

	DELETE REACTOR_PROCEDURE_ENTITY_REF
	WHERE REACTOR_PROCEDURE_ID = p_REACTOR_PROCEDURE_ID
		AND REFERENCE_NAME = p_REFERENCE_NAME;

END DEL_REACTOR_PROC_ENTITY_REF;
----------------------------------------------------------------------------------------------------
-- Get the list of Calc Processes for the Entity List of the
-- Data Exchange to generate calc engine procs.
PROCEDURE GET_CALC_PROCESS_LIST
	(
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT CALC_PROCESS_NAME, CALC_PROCESS_ID
		FROM CALCULATION_PROCESS
		ORDER BY 1;

END GET_CALC_PROCESS_LIST;
----------------------------------------------------------------------------------------------------
-- Automatically generates a set of Reactor Procs based on the
-- Calc Processes that are specified.
PROCEDURE GENERATE_CALC_ENGINE_PROCS
	(
	p_ENTITY_ID_COLLECTION IN NUMBER_COLLECTION,
	p_BEGIN_DATE IN DATE,
	p_MESSAGE OUT VARCHAR2
	) AS

v_DATE DATE := p_BEGIN_DATE;
v_FOUND BOOLEAN := FALSE;
v_WARNINGS BOOLEAN := FALSE;
CURSOR c_INPUTS IS
	SELECT DISTINCT X.*, T.TABLE_ID, T.TABLE_NAME
	FROM
		(SELECT P.CALC_PROCESS_NAME,
			P.CALC_PROCESS_ID,
			P.IS_STATEMENT_TYPE_SPECIFIC,
			P.PROCESS_INTERVAL,
			P.WEEK_BEGIN,
			P.TIME_ZONE,
			I.ENTITY_DOMAIN_ID,
			I.ENTITY_TYPE,
			I.ENTITY_ID,
			I.WHAT_FIELD,
			CASE WHEN I.ENTITY_DOMAIN_ID = EC.ED_TRANSACTION AND I.WHAT_FIELD LIKE 'TRAIT_VAL%' THEN 'IT_TRAIT_SCHEDULE'
				WHEN I.ENTITY_DOMAIN_ID = EC.ED_TRANSACTION THEN 'IT_SCHEDULE'
				WHEN I.ENTITY_DOMAIN_ID = EC.ED_MARKET_PRICE THEN 'MARKET_PRICE_VALUE'
				WHEN I.ENTITY_DOMAIN_ID IN (EC.ED_SUB_STATION, EC.ED_SUB_STATION_METER, EC.ED_SUB_STATION_METER_POINT) THEN 'TX_SUB_STATION_METER_PT_VALUE'
				ELSE NULL
			END AS DB_TABLE_NAME
		FROM CALCULATION_PROCESS P,
			TABLE(CAST(p_ENTITY_ID_COLLECTION AS NUMBER_COLLECTION)) X,
			CALCULATION_PROCESS_STEP S,
			COMPONENT_FORMULA_INPUT I
		WHERE P.CALC_PROCESS_ID = X.COLUMN_VALUE
			AND S.CALC_PROCESS_ID = P.CALC_PROCESS_ID
			AND v_DATE BETWEEN S.BEGIN_DATE AND NVL(S.END_DATE, CONSTANTS.HIGH_DATE)
			AND I.COMPONENT_ID = S.COMPONENT_ID
			AND v_DATE BETWEEN I.BEGIN_DATE AND NVL(I.END_DATE, CONSTANTS.HIGH_DATE)
			AND NOT (I.ENTITY_TYPE = 'R' AND EXISTS (SELECT 1 FROM SYSTEM_REALM WHERE REALM_ID = I.ENTITY_ID AND REALM_CALC_TYPE <> 0))
		) X, SYSTEM_TABLE T
	WHERE T.DB_TABLE_NAME = X.DB_TABLE_NAME
	ORDER BY X.CALC_PROCESS_NAME, T.TABLE_NAME;

	v_PREV_TABLE_ID SYSTEM_TABLE.TABLE_ID%TYPE := -1;
	v_PREV_PROCESS_NAME CALCULATION_PROCESS.CALC_PROCESS_NAME%TYPE := '~~INIT~~';
	v_PROC_ID REACTOR_PROCEDURE.REACTOR_PROCEDURE_ID%TYPE;
	v_PARAM_ORDER BINARY_INTEGER := 1;
	v_PROC_NAME_PREFIX REACTOR_PROCEDURE.REACTOR_PROCEDURE_NAME%TYPE;
	v_PROC_NAME REACTOR_PROCEDURE.REACTOR_PROCEDURE_NAME%TYPE;
	v_MAX_NUMBER BINARY_INTEGER := NULL;
	v_FML REACTOR_PROCEDURE_PARAMETER.PARAMETER_FORMULA%TYPE;
	v_DATA_INTERVAL VARCHAR2(256);
	v_DATE_COLUMN_NAME VARCHAR2(32);
	v_SCHEDULING_DATES VARCHAR2(8);

	PROCEDURE ADD_PARAM
		(
		p_PARAMETER_NAME IN VARCHAR2,
		p_PARAMETER_TYPE IN VARCHAR2,
		p_PARAMETER_FORMULA IN VARCHAR2
		) AS
	BEGIN
		INSERT INTO REACTOR_PROCEDURE_PARAMETER(REACTOR_PROCEDURE_ID, PARAMETER_NAME, PARAMETER_TYPE, PARAMETER_FORMULA, PARAMETER_ORDER)
		VALUES(v_PROC_ID, p_PARAMETER_NAME, p_PARAMETER_TYPE, p_PARAMETER_FORMULA, v_PARAM_ORDER);

		v_PARAM_ORDER := v_PARAM_ORDER + 1;
	END ADD_PARAM;

BEGIN

	--For each Input in the list
	FOR v_INPUT IN c_INPUTS LOOP
		--If this is a new input/process combo, create a new Reactor Procedure.
		IF v_INPUT.TABLE_ID <> v_PREV_TABLE_ID OR v_INPUT.CALC_PROCESS_NAME <> v_PREV_PROCESS_NAME THEN
			v_PREV_TABLE_ID := v_INPUT.TABLE_ID;
			v_PREV_PROCESS_NAME := v_INPUT.CALC_PROCESS_NAME;
			v_PROC_NAME_PREFIX := 'Calc:'||v_INPUT.CALC_PROCESS_NAME||':'||v_INPUT.TABLE_NAME||':';

			SELECT TO_NUMBER(MAX(SUBSTR(R.REACTOR_PROCEDURE_NAME,-2)))
			INTO v_MAX_NUMBER
			FROM REACTOR_PROCEDURE R
			WHERE REGEXP_LIKE(R.REACTOR_PROCEDURE_NAME, '^'||v_PROC_NAME_PREFIX||'\d\d$');

			IF v_MAX_NUMBER IS NULL THEN
				v_PROC_NAME := v_PROC_NAME_PREFIX||'01';
			ELSE
				v_PROC_NAME := v_PROC_NAME_PREFIX||TRIM(TO_CHAR(v_MAX_NUMBER+1,'00'));
				LOGS.LOG_WARN('A Reactor Procedure starting with "'||v_PROC_NAME_PREFIX||'" already existed.  A new Procedure is being added, named "'||v_PROC_NAME||'".  The existing Reactor Procedures should be deleted once the settings on the new Procedures are checked.');
				v_WARNINGS := TRUE;
			END IF;

			IO.PUT_REACTOR_PROCEDURE(v_PROC_ID,
				v_PROC_NAME,
				NULL,
				'Created via automatic generation on '||TEXT_UTIL.TO_CHAR_TIME(SYSDATE),
				0,
				v_INPUT.TABLE_ID,
				'CALC_ENGINE.CALC_REQUEST',
				NULL, --JOB THREAD ID
				NULL, --JOB COMMENTS
				10, --CALL ORDER
				NULL, -- SKIP WHEN FORMULA
				v_INPUT.TIME_ZONE,
				0,
				1); -- ENABLED

			--Add Calc Process Id parameter using an Entity Ref.
			INSERT INTO REACTOR_PROCEDURE_ENTITY_REF(REACTOR_PROCEDURE_ID, REFERENCE_NAME, ENTITY_DOMAIN_ID, ENTITY_ID, ENTRY_DATE)
			VALUES (v_PROC_ID, 'CalcProcessId', EC.ED_CALC_PROCESS, v_INPUT.CALC_PROCESS_ID, SYSDATE);

			ADD_PARAM('P_CALC_PROCESS_ID', REACTOR.c_TYPE_KEY, 'CalcProcessId');

			--Add Entity IDs parameter as a Number Collection.
			ADD_PARAM('P_ENTITY_IDS', REACTOR.c_TYPE_KEY, 'NUMBER_COLLECTION(-1)');

			--Add Statement Type parameter
			IF v_INPUT.IS_STATEMENT_TYPE_SPECIFIC = 1 THEN
				v_FML := CASE v_INPUT.DB_TABLE_NAME
							WHEN 'IT_SCHEDULE' THEN 'SCHEDULE_TYPE'
							WHEN 'IT_TRAIT_SCHEDULE' THEN 'STATEMENT_TYPE_ID'
							ELSE '1' END;
			ELSE
				v_FML := '0';
			END IF;
			ADD_PARAM('P_STATEMENT_TYPE_ID', REACTOR.c_TYPE_KEY, v_FML);

			--Add Date range parameters
			IF v_INPUT.DB_TABLE_NAME IN ('IT_SCHEDULE', 'IT_TRAIT_SCHEDULE') THEN
				v_DATA_INTERVAL := 'DATE_UTIL.GET_INTERVAL_FOR_TRANSACTION(TRANSACTION_ID)';
				v_DATE_COLUMN_NAME := 'SCHEDULE_DATE';
				v_SCHEDULING_DATES := 'TRUE';
			ELSIF v_INPUT.DB_TABLE_NAME = 'MARKET_PRICE_VALUE' THEN
				v_DATA_INTERVAL := 'DATE_UTIL.GET_INTERVAL_FOR_MARKET_PRICE(MARKET_PRICE_ID)';
				v_DATE_COLUMN_NAME := 'PRICE_DATE';
				v_SCHEDULING_DATES := 'FALSE';
			ELSIF v_INPUT.DB_TABLE_NAME = 'TX_SUB_STATION_METER_PT_VALUE' THEN
				v_DATA_INTERVAL := '''Hour''';
				v_DATE_COLUMN_NAME := 'METER_DATE';
				v_SCHEDULING_DATES := 'TRUE';
			END IF;

			v_FML := '('||v_DATA_INTERVAL||','''||v_INPUT.PROCESS_INTERVAL||''','||v_DATE_COLUMN_NAME||','''||v_INPUT.TIME_ZONE||''','||v_SCHEDULING_DATES||','''||v_INPUT.WEEK_BEGIN||''')';
			ADD_PARAM('P_CUT_BEGIN_DATE_TIME', REACTOR.c_TYPE_BEGIN_DATE, 'DATE_UTIL.GET_PROCESS_BEGIN_DATE'||v_FML);
			ADD_PARAM('P_CUT_END_DATE_TIME', REACTOR.c_TYPE_END_DATE, 'DATE_UTIL.GET_PROCESS_END_DATE'||v_FML);
			ADD_PARAM('P_AS_OF_DATE', REACTOR.c_TYPE_NON_KEY, 'SYSDATE');
		END IF;

		--Add the information for this input.
		INSERT INTO REACTOR_PROCEDURE_INPUT (REACTOR_PROCEDURE_ID, ENTITY_DOMAIN_ID, ENTITY_TYPE, ENTITY_ID, BEGIN_DATE, END_DATE)
		VALUES (v_PROC_ID, v_INPUT.ENTITY_DOMAIN_ID, v_INPUT.ENTITY_TYPE, v_INPUT.ENTITY_ID, TRUNC(SYSDATE), NULL);

		v_FOUND := TRUE;
	END LOOP;

	--Return a message for certain cases.
	IF NOT v_FOUND THEN
		p_MESSAGE := 'No Reactor Procedures could be generated for the selected Calculation Processes.';
	ELSIF v_WARNINGS THEN
		p_MESSAGE := 'Duplicate Reactor Procedures may now exist.  Please delete any duplicates after verifying the settings of the new procedures.  See the Process Log for details.';
	END IF;

END GENERATE_CALC_ENGINE_PROCS;
----------------------------------------------------------------------------------------------------
END REACTOR_UI;
/
