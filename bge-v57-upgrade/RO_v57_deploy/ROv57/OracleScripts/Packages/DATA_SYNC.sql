CREATE OR REPLACE PACKAGE DATA_SYNC IS

-- Author:   PMANNING
-- Created:  11/18/2010 10:06:12 AM
-- Revision: $Revision: 1.18 $
-- Purpose:  This package can be used to synchronize data with the RO/MO data model.
--           We currently support: Non-Interval Data (Service Consumption),
--                                 Interval Data (Service Load)

FUNCTION WHAT_VERSION RETURN VARCHAR;

PROCEDURE PURGE_SERV_CONSUMPTION_STAGING;
PROCEDURE PURGE_SERVICE_LOAD_STAGING;

PROCEDURE PROCESS_SERVICE_CONS_STAGING
	(
	p_MESSAGE OUT VARCHAR2,
	p_PROCESS_ID OUT VARCHAR2,
    p_PROCESS_STATUS OUT NUMBER,
	p_TRACE_ON IN NUMBER := 0
	);

PROCEDURE PROCESS_SERVICE_LOAD_SYNC
	(
	p_MESSAGE OUT VARCHAR2,
    p_PROCESS_ID OUT VARCHAR2,
    p_PROCESS_STATUS OUT NUMBER,
    p_TRACE_ON IN NUMBER := 0
	);

FUNCTION GET_MESSAGE_LIST
    RETURN VARCHAR2;

PROCEDURE GET_MESSAGE_LIST_CLOB
	(
	p_EVENT_TEXT PROCESS_LOG_EVENT.EVENT_TEXT%TYPE,
	p_TEXT IN OUT NOCOPY CLOB
	);

$if $$UNIT_TEST_MODE = 1 $then

PROCEDURE VALIDATE_SERVICE_LOAD_RECORD
    (
    p_REC IN SERVICE_LOAD_STAGING%ROWTYPE,
    p_VALUES OUT NUMBER_COLLECTION,
    p_SUCCESS OUT BOOLEAN
    );

$end

END DATA_SYNC;
/
CREATE OR REPLACE PACKAGE BODY DATA_SYNC IS
--------------------------------------------------------------------------------------------------
c_ATTACHMENT_LIST CONSTANT VARCHAR2(30) := 'see attachment for list';
c_TRUE CONSTANT PLS_INTEGER := 1;
c_FALSE CONSTANT PLS_INTEGER := 0;
c_CLOB_CODE_THRESHOLD_COUNT CONSTANT PLS_INTEGER := 100;
c_CLOB_ENTITY_THRESHOLD_COUNT CONSTANT PLS_INTEGER := 20;
c_UOM_ELC_MW CONSTANT VARCHAR2(32) := 'mw';
c_UOM_ELC_MWH CONSTANT VARCHAR2(32) := 'mwh';
c_UOM_ELC_KW CONSTANT VARCHAR2(32) := 'kw';
c_UOM_ELC_KWH CONSTANT VARCHAR2(32) := 'kwh';
c_UOM_GAS_THM CONSTANT VARCHAR2(32) := 'thm';
c_UOM_GAS_DTH CONSTANT VARCHAR2(32) := 'dth';

g_NUM_ERRORS     PLS_INTEGER := 0;
--------------------------------------------------------------------------------------------------
CURSOR cur_SERVICE_CONS_STAGING IS
  SELECT A.*, A.ROWID
    FROM SERVICE_CONSUMPTION_STAGING A
	WHERE ERROR_FLAG = c_FALSE
	ORDER BY A.ACCOUNT_IDENT, A.BEGIN_DATE;
-------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
  RETURN '$Revision: 1.18 $';
END WHAT_VERSION;
--------------------------------------------------------------------------------------------------
PROCEDURE PURGE_SERV_CONSUMPTION_STAGING AS
BEGIN
    EXECUTE IMMEDIATE 'TRUNCATE TABLE SERVICE_CONSUMPTION_STAGING';
END PURGE_SERV_CONSUMPTION_STAGING;
-----------------------------------------------------------------------------------------------
PROCEDURE PURGE_SERVICE_LOAD_STAGING AS
BEGIN
    EXECUTE IMMEDIATE 'TRUNCATE TABLE SERVICE_LOAD_STAGING';
END PURGE_SERVICE_LOAD_STAGING;

------------------------------------------------------------------------------------------
PROCEDURE RESET_STEP_ERROR_FLAG (p_COUNT PLS_INTEGER) IS
BEGIN
	IF p_COUNT > 0 THEN
		g_NUM_ERRORS := g_NUM_ERRORS + p_COUNT;
		UPDATE SERVICE_CONSUMPTION_STAGING
			SET STEP_ERROR_FLAG = c_FALSE,
				ERROR_LIST_ITEM = NULL
		WHERE STEP_ERROR_FLAG = c_TRUE;
	END IF;
END RESET_STEP_ERROR_FLAG;

-----------------------------------------------------------------------------------------------
FUNCTION GET_MESSAGE_LIST
    RETURN VARCHAR2
IS
	v_TEXT  VARCHAR2(32767) := UTL_TCP.CRLF;
	
BEGIN
	FOR cur_REC IN (SELECT DISTINCT ERROR_LIST_ITEM
					FROM SERVICE_CONSUMPTION_STAGING
					WHERE STEP_ERROR_FLAG = c_TRUE
					ORDER BY 1) LOOP
		v_TEXT := v_TEXT || UTL_TCP.CRLF || cur_REC.ERROR_LIST_ITEM ||',';
	END LOOP;
	RETURN RTRIM(v_TEXT,',');
END GET_MESSAGE_LIST;

-----------------------------------------------------------------------------------------------
PROCEDURE GET_MESSAGE_LIST_CLOB
	(
	p_EVENT_TEXT PROCESS_LOG_EVENT.EVENT_TEXT%TYPE,
	p_TEXT IN OUT NOCOPY CLOB
	) IS
  v_ERROR_LIST_ITEM VARCHAR2(200) := NULL;
BEGIN
	DBMS_LOB.WRITEAPPEND(p_TEXT, LENGTH(p_EVENT_TEXT), p_EVENT_TEXT);
	DBMS_LOB.WRITEAPPEND(p_TEXT, LENGTH(UTL_TCP.CRLF), UTL_TCP.CRLF);
	FOR cur_REC IN (SELECT DISTINCT ERROR_LIST_ITEM
					FROM SERVICE_CONSUMPTION_STAGING
					WHERE STEP_ERROR_FLAG = c_TRUE
					ORDER BY 1) LOOP

		v_ERROR_LIST_ITEM := cur_REC.ERROR_LIST_ITEM || UTL_TCP.CRLF;
		DBMS_LOB.WRITEAPPEND(p_TEXT, LENGTH(v_ERROR_LIST_ITEM), v_ERROR_LIST_ITEM);

	END LOOP;
END GET_MESSAGE_LIST_CLOB;

-----------------------------------------------------------------------------------------------
PROCEDURE GET_ERROR_LIST_COUNT
	(
	p_COUNT OUT PLS_INTEGER,
	p_ERROR_LIST_ITEM OUT SERVICE_CONSUMPTION_STAGING.ERROR_LIST_ITEM%TYPE
	) IS
BEGIN
	SELECT COUNT(DISTINCT ERROR_LIST_ITEM), MAX(ERROR_LIST_ITEM)
	INTO p_COUNT, p_ERROR_LIST_ITEM
	FROM SERVICE_CONSUMPTION_STAGING SCS
	WHERE STEP_ERROR_FLAG = c_TRUE;
END GET_ERROR_LIST_COUNT;

-----------------------------------------------------------------------------------------------
PROCEDURE LOG_ERROR_LIST
	(
	p_SINGULAR_MSG IN PROCESS_LOG_EVENT.EVENT_TEXT%TYPE,
	p_PLURAL_MSG IN PROCESS_LOG_EVENT.EVENT_TEXT%TYPE,
	P_THRESHOLD_COUNT IN PLS_INTEGER
	) IS
	v_COUNT PLS_INTEGER;
	v_TEXT  CLOB := NULL;
	v_ERROR_LIST_ITEM SERVICE_CONSUMPTION_STAGING.ERROR_LIST_ITEM%TYPE;
BEGIN
	GET_ERROR_LIST_COUNT(v_COUNT, v_ERROR_LIST_ITEM);
	IF v_COUNT = 1 THEN
		LOGS.LOG_ERROR(p_SINGULAR_MSG || v_ERROR_LIST_ITEM );
	ELSIF v_COUNT > 1 AND v_COUNT <= P_THRESHOLD_COUNT THEN
		LOGS.LOG_ERROR(p_PLURAL_MSG || GET_MESSAGE_LIST);
	ELSIF v_COUNT > P_THRESHOLD_COUNT THEN
		DBMS_LOB.CREATETEMPORARY(v_TEXT, true);
		GET_MESSAGE_LIST_CLOB(p_PLURAL_MSG, v_TEXT);
		LOGS.LOG_ERROR_CLOB(p_PLURAL_MSG || c_ATTACHMENT_LIST, v_TEXT);
		DBMS_LOB.FREETEMPORARY(v_TEXT);
	END IF;
	RESET_STEP_ERROR_FLAG(v_COUNT);
END LOG_ERROR_LIST;

-----------------------------------------------------------------------------------------------
PROCEDURE GET_ACCOUNT IS
	v_SINGULAR_MSG PROCESS_LOG_EVENT.EVENT_TEXT%TYPE := 'Account not found: ';
	v_PLURAL_MSG PROCESS_LOG_EVENT.EVENT_TEXT%TYPE := 'Accounts not found: ';
BEGIN

	MERGE INTO SERVICE_CONSUMPTION_STAGING SCS
	USING (SELECT ACCOUNT_ID,
					NVL(ACCOUNT_EXTERNAL_IDENTIFIER, ACCOUNT_ALIAS) ACCOUNT_NAME,
					ACCOUNT_METER_TYPE,
					ACCOUNT_MODEL_OPTION
			FROM ACCOUNT A) A
	ON (SCS.ACCOUNT_IDENT = A.ACCOUNT_NAME)
	WHEN MATCHED THEN
		UPDATE SET SCS.ACCOUNT_ID = A.ACCOUNT_ID,
					SCS.ACCOUNT_MODEL_OPTION = A.ACCOUNT_MODEL_OPTION,
					SCS.ACCOUNT_METER_TYPE = A.ACCOUNT_METER_TYPE;

	-- Account is required
	UPDATE SERVICE_CONSUMPTION_STAGING SCS
	SET SCS.ERROR_MESSAGE = v_SINGULAR_MSG || SCS.ACCOUNT_IDENT,
		ERROR_LIST_ITEM = SCS.ACCOUNT_IDENT,
		ERROR_FLAG = c_TRUE,
		STEP_ERROR_FLAG = c_TRUE
	WHERE ACCOUNT_ID IS NULL;
	
	LOG_ERROR_LIST(v_SINGULAR_MSG, v_PLURAL_MSG, c_CLOB_ENTITY_THRESHOLD_COUNT);
	
END GET_ACCOUNT;
-----------------------------------------------------------------------------------------------
PROCEDURE GET_ESP IS
	v_SINGULAR_MSG PROCESS_LOG_EVENT.EVENT_TEXT%TYPE := 'Energy Service Provider not found: ';
	v_PLURAL_MSG PROCESS_LOG_EVENT.EVENT_TEXT%TYPE := 'Energy Service Providers not found: ';
BEGIN

	MERGE INTO SERVICE_CONSUMPTION_STAGING SCS
	USING (SELECT ESP_ID, NVL(ESP_EXTERNAL_IDENTIFIER, ESP_ALIAS) ESP_NAME FROM ENERGY_SERVICE_PROVIDER A) A
	ON (SCS.ESP_IDENT = A.ESP_NAME)
	WHEN MATCHED THEN
		UPDATE SET SCS.ESP_ID = A.ESP_ID;

	UPDATE SERVICE_CONSUMPTION_STAGING SCS
	SET SCS.ERROR_MESSAGE = v_SINGULAR_MSG || SCS.ESP_IDENT,
		ERROR_LIST_ITEM = SCS.ESP_IDENT,
		ERROR_FLAG = c_TRUE,
		STEP_ERROR_FLAG = c_TRUE
	WHERE ESP_ID IS NULL AND SCS.ESP_IDENT IS NOT NULL;

	UPDATE SERVICE_CONSUMPTION_STAGING SCS
	SET ESP_ID = CONSTANTS.NOT_ASSIGNED
	WHERE ESP_IDENT IS NULL AND ESP_ID IS NULL;

	LOG_ERROR_LIST(v_SINGULAR_MSG, v_PLURAL_MSG, c_CLOB_ENTITY_THRESHOLD_COUNT);

END GET_ESP;
-----------------------------------------------------------------------------------------------
PROCEDURE GET_METER IS
	v_SINGULAR_MSG PROCESS_LOG_EVENT.EVENT_TEXT%TYPE := 'Meter not found: ';
	v_PLURAL_MSG PROCESS_LOG_EVENT.EVENT_TEXT%TYPE := 'Meters not found: ';
BEGIN

	MERGE INTO SERVICE_CONSUMPTION_STAGING SCS
	USING (SELECT METER_ID,
					NVL(METER_EXTERNAL_IDENTIFIER, METER_ALIAS) METER_IDENT,
					METER_NAME,
					METER_TYPE
			FROM METER A) A
	ON (SCS.METER_IDENT = A.METER_IDENT)
	WHEN MATCHED THEN
		UPDATE SET SCS.METER_ID = A.METER_ID,
					SCS.METER_NAME = A.METER_NAME,
					SCS.METER_TYPE = A.METER_TYPE;

	UPDATE SERVICE_CONSUMPTION_STAGING SCS
	SET SCS.ERROR_MESSAGE = v_SINGULAR_MSG || SCS.METER_IDENT || '.',
		ERROR_LIST_ITEM = SCS.METER_IDENT,
		ERROR_FLAG = c_TRUE,
		STEP_ERROR_FLAG = c_TRUE
	WHERE METER_ID IS NULL AND METER_IDENT IS NOT NULL;

   -- meter_id is not required, default
	UPDATE SERVICE_CONSUMPTION_STAGING
	SET METER_ID = CONSTANTS.NOT_ASSIGNED
	WHERE METER_ID IS NULL AND METER_IDENT IS NULL;

	LOG_ERROR_LIST(v_SINGULAR_MSG, v_PLURAL_MSG, c_CLOB_ENTITY_THRESHOLD_COUNT);

END GET_METER;
-----------------------------------------------------------------------------------------------
PROCEDURE GET_POOL IS
	v_SINGULAR_MSG PROCESS_LOG_EVENT.EVENT_TEXT%TYPE := 'Pool not found: ';
	v_PLURAL_MSG PROCESS_LOG_EVENT.EVENT_TEXT%TYPE := 'Pools not found: ';
BEGIN

	MERGE INTO SERVICE_CONSUMPTION_STAGING SCS
	USING (SELECT POOL_ID, NVL(POOL_EXTERNAL_IDENTIFIER, POOL_ALIAS) POOL_NAME FROM POOL A) A
	ON (SCS.POOL_IDENT = A.POOL_NAME)
	WHEN MATCHED THEN
		UPDATE SET SCS.POOL_ID = A.POOL_ID;

	UPDATE SERVICE_CONSUMPTION_STAGING SCS
	SET SCS.ERROR_MESSAGE = v_SINGULAR_MSG || SCS.POOL_IDENT,
		ERROR_LIST_ITEM = SCS.POOL_IDENT,
		ERROR_FLAG = c_TRUE,
		STEP_ERROR_FLAG = c_TRUE
	WHERE POOL_ID IS NULL AND SCS.POOL_IDENT IS NOT NULL;

	UPDATE SERVICE_CONSUMPTION_STAGING SCS
	SET POOL_ID = CONSTANTS.NOT_ASSIGNED
	WHERE POOL_IDENT IS NULL AND POOL_ID IS NULL;

	LOG_ERROR_LIST(v_SINGULAR_MSG, v_PLURAL_MSG, c_CLOB_ENTITY_THRESHOLD_COUNT);
END GET_POOL;
-----------------------------------------------------------------------------------------------
PROCEDURE GET_SERVICE_LOCATION IS
BEGIN

	UPDATE SERVICE_CONSUMPTION_STAGING SCS
	SET SERVICE_LOCATION_ID =
		(SELECT MAX(ASL.SERVICE_LOCATION_ID)
		 FROM ACCOUNT_SERVICE_LOCATION ASL, SERVICE_LOCATION_METER SLM
		 WHERE
		 -- slm to asl
		  SLM.SERVICE_LOCATION_ID = ASL.SERVICE_LOCATION_ID
		  -- scs to slm
		  AND SCS.METER_ID = SLM.METER_ID
		  AND SCS.BEGIN_DATE BETWEEN SLM.BEGIN_DATE AND NVL(SLM.END_DATE, CONSTANTS.HIGH_DATE)
		  AND SCS.END_DATE BETWEEN SLM.BEGIN_DATE AND NVL(SLM.END_DATE, CONSTANTS.HIGH_DATE)
		  -- scs to asl
		  AND SCS.BEGIN_DATE BETWEEN ASL.BEGIN_DATE AND NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE)
		  AND SCS.END_DATE BETWEEN ASL.BEGIN_DATE AND NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE));

	UPDATE SERVICE_CONSUMPTION_STAGING SCS
	SET SERVICE_LOCATION_ID = CONSTANTS.NOT_ASSIGNED
	WHERE SERVICE_LOCATION_ID IS NULL;
END GET_SERVICE_LOCATION;

-----------------------------------------------------------------------------------------------
PROCEDURE VALIDATE_BILL_CODE IS
	v_COUNT PLS_INTEGER;
	v_TEXT  CLOB := NULL;
	v_ERROR_LIST_ITEM SERVICE_CONSUMPTION_STAGING.ERROR_LIST_ITEM%TYPE;
BEGIN

  UPDATE SERVICE_CONSUMPTION_STAGING SCS SET SCS.STEP_ERROR_FLAG = c_FALSE;

  UPDATE SERVICE_CONSUMPTION_STAGING SCS
	SET ERROR_FLAG      = c_TRUE,
        STEP_ERROR_FLAG = c_TRUE,
		ERROR_LIST_ITEM = SCS.BILL_CODE,
        ERROR_MESSAGE   = 'Invalid bill code: '||SCS.BILL_CODE||' (only '||GA.BILL_CONSUMPTION||' / '||GA.CANCEL_CONSUMPTION||' allowed)'
   WHERE SCS.BILL_CODE NOT IN (GA.BILL_CONSUMPTION, GA.CANCEL_CONSUMPTION)
     AND SCS.BILL_CODE IS NOT NULL;

	GET_ERROR_LIST_COUNT(v_COUNT, v_ERROR_LIST_ITEM);

   IF v_COUNT = 1 THEN
     LOGS.LOG_ERROR('Invalid bill code: '||v_ERROR_LIST_ITEM||' (only '||GA.BILL_CONSUMPTION||' / '||GA.CANCEL_CONSUMPTION||' allowed)');
   ELSIF v_COUNT > 1 AND v_COUNT <= c_CLOB_CODE_THRESHOLD_COUNT THEN
     LOGS.LOG_ERROR('Invalid bill codes (only '||GA.BILL_CONSUMPTION||' / '||GA.CANCEL_CONSUMPTION||' allowed): '|| GET_MESSAGE_LIST);
   ELSIF v_COUNT > c_CLOB_CODE_THRESHOLD_COUNT THEN
		DBMS_LOB.CREATETEMPORARY(v_TEXT, true);
		GET_MESSAGE_LIST_CLOB('Invalid bill codes (only '||GA.BILL_CONSUMPTION||' / '||GA.CANCEL_CONSUMPTION||' allowed): ', v_TEXT);
		LOGS.LOG_ERROR_CLOB('Invalid bill codes (only '||GA.BILL_CONSUMPTION||' / '||GA.CANCEL_CONSUMPTION||' allowed): see attachment for list',v_TEXT);
		DBMS_LOB.FREETEMPORARY(v_TEXT);
   END IF;
   RESET_STEP_ERROR_FLAG(v_COUNT);
END VALIDATE_BILL_CODE;

-----------------------------------------------------------------------------------------------
PROCEDURE VALIDATE_CONSUMPTION_CODE IS
	v_COUNT PLS_INTEGER;
	v_TEXT  CLOB := NULL;
	v_ERROR_LIST_ITEM SERVICE_CONSUMPTION_STAGING.ERROR_LIST_ITEM%TYPE;
BEGIN
  UPDATE SERVICE_CONSUMPTION_STAGING SCS
	SET ERROR_FLAG      = C_TRUE,
		STEP_ERROR_FLAG = C_TRUE,
		ERROR_LIST_ITEM = SCS.CONSUMPTION_CODE,
		ERROR_MESSAGE   = 'Invalid consumption code: '||SCS.CONSUMPTION_CODE||' (only '||GA.ACTUAL_CONSUMPTION||' / '||GA.HISTORICAL_CONSUMPTION||' allowed)'
   WHERE CONSUMPTION_CODE NOT IN (GA.ACTUAL_CONSUMPTION, GA.HISTORICAL_CONSUMPTION)
     AND CONSUMPTION_CODE IS NOT NULL;

	GET_ERROR_LIST_COUNT(v_COUNT, v_ERROR_LIST_ITEM);

   IF v_COUNT = 1 THEN
     LOGS.LOG_ERROR('Invalid consumption code: '||v_ERROR_LIST_ITEM||' (only '||GA.ACTUAL_CONSUMPTION||' / '||GA.HISTORICAL_CONSUMPTION||' allowed)');
   ELSIF v_COUNT > 1 AND v_COUNT <= c_CLOB_CODE_THRESHOLD_COUNT THEN
     LOGS.LOG_ERROR('Invalid consumption codes (only '||GA.ACTUAL_CONSUMPTION||' / '||GA.HISTORICAL_CONSUMPTION||' allowed): '|| GET_MESSAGE_LIST);
   ELSIF v_COUNT > c_CLOB_CODE_THRESHOLD_COUNT THEN
		DBMS_LOB.CREATETEMPORARY(v_TEXT, true);
		GET_MESSAGE_LIST_CLOB('Invalid consmption codes: ', v_TEXT);
		LOGS.LOG_ERROR_CLOB('Invalid consumption codes (only '||GA.ACTUAL_CONSUMPTION||' / '||GA.HISTORICAL_CONSUMPTION||' allowed): see attachment for list',v_TEXT);
		DBMS_LOB.FREETEMPORARY(v_TEXT);
   END IF;
   RESET_STEP_ERROR_FLAG(v_COUNT);
END VALIDATE_CONSUMPTION_CODE;

-----------------------------------------------------------------------------------------------
PROCEDURE VALIDATE_TEMPLATE_PERIOD IS
	v_SINGULAR_MSG PROCESS_LOG_EVENT.EVENT_TEXT%TYPE;
	v_PLURAL_MSG PROCESS_LOG_EVENT.EVENT_TEXT%TYPE;
BEGIN

	-- Template without a period
	v_SINGULAR_MSG := 'Account missing period: ';
	v_PLURAL_MSG := 'Accounts missing periods: ';
	UPDATE SERVICE_CONSUMPTION_STAGING SCS
	SET ERROR_FLAG      = C_TRUE,
		STEP_ERROR_FLAG = C_TRUE,
		ERROR_LIST_ITEM = ACCOUNT_IDENT,
		ERROR_MESSAGE   = v_SINGULAR_MSG || SCS.ACCOUNT_IDENT
	WHERE SCS.TEMPLATE_IDENT IS NOT NULL AND SCS.PERIOD_IDENT IS NULL;
	LOG_ERROR_LIST(v_SINGULAR_MSG, v_PLURAL_MSG, c_CLOB_ENTITY_THRESHOLD_COUNT);

	-- Period without a template
	v_SINGULAR_MSG := 'Account missing template: ';
	v_PLURAL_MSG := 'Accounts missing templates: ';
	UPDATE SERVICE_CONSUMPTION_STAGING SCS
	SET ERROR_FLAG      = C_TRUE,
		STEP_ERROR_FLAG = C_TRUE,
		ERROR_LIST_ITEM = ACCOUNT_IDENT,
		ERROR_MESSAGE   = 'Account missing template: ' || SCS.ACCOUNT_IDENT
	WHERE SCS.PERIOD_IDENT IS NOT NULL AND SCS.TEMPLATE_IDENT IS NULL;
	LOG_ERROR_LIST(v_SINGULAR_MSG, v_PLURAL_MSG, c_CLOB_ENTITY_THRESHOLD_COUNT);

	-- Is Template valid
	v_SINGULAR_MSG := 'Template not found: ';
	v_PLURAL_MSG := 'Templates not found: ';
	MERGE INTO SERVICE_CONSUMPTION_STAGING SCS
	USING (SELECT TEMPLATE_ID, NVL(TEMPLATE_NAME, TEMPLATE_ALIAS) TEMPLATE_NAME FROM TEMPLATE A) A
		ON (SCS.TEMPLATE_IDENT = A.TEMPLATE_NAME)
	WHEN MATCHED THEN
		UPDATE SET SCS.TEMPLATE_ID = A.TEMPLATE_ID;

	UPDATE SERVICE_CONSUMPTION_STAGING SCS
	SET ERROR_FLAG      = C_TRUE,
		STEP_ERROR_FLAG = C_TRUE,
		ERROR_LIST_ITEM = TEMPLATE_IDENT,
		SCS.ERROR_MESSAGE = v_SINGULAR_MSG || SCS.TEMPLATE_IDENT
	WHERE TEMPLATE_ID IS NULL AND SCS.TEMPLATE_IDENT IS NOT NULL;
	LOG_ERROR_LIST(v_SINGULAR_MSG, v_PLURAL_MSG, c_CLOB_ENTITY_THRESHOLD_COUNT);

	-- Is Period valid
	v_SINGULAR_MSG := 'Period not found: ';
	v_PLURAL_MSG := 'Periods not found: ';
	MERGE INTO SERVICE_CONSUMPTION_STAGING SCS
	USING (SELECT PERIOD_ID, NVL(PERIOD_NAME, PERIOD_ALIAS) PERIOD_NAME FROM PERIOD A) A
	ON (SCS.PERIOD_IDENT = A.PERIOD_NAME)
	WHEN MATCHED THEN
		UPDATE SET SCS.PERIOD_ID = A.PERIOD_ID;

	UPDATE SERVICE_CONSUMPTION_STAGING SCS
	SET ERROR_FLAG      = C_TRUE,
		STEP_ERROR_FLAG = C_TRUE,
		ERROR_LIST_ITEM = PERIOD_IDENT,
		SCS.ERROR_MESSAGE = v_SINGULAR_MSG || SCS.PERIOD_IDENT
	WHERE PERIOD_ID IS NULL AND PERIOD_IDENT IS NOT NULL;
	LOG_ERROR_LIST(v_SINGULAR_MSG, v_PLURAL_MSG, c_CLOB_ENTITY_THRESHOLD_COUNT);

	-- default period and template when both null
	UPDATE SERVICE_CONSUMPTION_STAGING SCS
	SET SCS.TEMPLATE_ID = CONSTANTS.ANYTIME_TOU_TEMPLATE_ID,
		SCS.PERIOD_ID   = CONSTANTS.ANYTIME_PERIOD_ID
	WHERE SCS.TEMPLATE_IDENT IS NULL
		  AND SCS.PERIOD_IDENT IS NULL;

END VALIDATE_TEMPLATE_PERIOD;

-----------------------------------------------------------------------------------------------
PROCEDURE VALIDATE_METER_TYPE IS
	v_COUNT PLS_INTEGER;
	v_TEXT  CLOB := NULL;
	v_ERROR_LIST_ITEM SERVICE_CONSUMPTION_STAGING.ERROR_LIST_ITEM%TYPE;
    
    c_METER_TYPE_ERR VARCHAR(64) := 'meter type must be Period: ';
    c_ACCOUNT_METER_TYPE_ERR VARCHAR2(128) := 'Account''s ' ||  c_METER_TYPE_ERR;
    c_METER_METER_TYPE_ERR VARCHAR2(128) := 'Meter''s ' ||  c_METER_TYPE_ERR;
BEGIN

	-- • If the Account is “Account” modeled,
	--		the Account’s Meter_Type must be ‘Period’ in order to insert SERVICE_CONSUMPTION.
	UPDATE SERVICE_CONSUMPTION_STAGING SCS
	SET ERROR_FLAG      = C_TRUE,
		STEP_ERROR_FLAG = C_TRUE,
		ERROR_LIST_ITEM = ACCOUNT_IDENT,
		ERROR_MESSAGE   = c_ACCOUNT_METER_TYPE_ERR || SCS.ACCOUNT_IDENT
	WHERE ACCOUNT_MODEL_OPTION = ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_ACCOUNT
	  AND SCS.ACCOUNT_METER_TYPE != ACCOUNTS_METERS.c_METER_TYPE_PERIOD
	  AND SCS.METER_ID IS NOT NULL
	  AND SCS.aCCOUNT_ID IS NOT NULL;

	GET_ERROR_LIST_COUNT(v_COUNT, v_ERROR_LIST_ITEM);

   IF v_COUNT = 1 THEN
        LOGS.LOG_ERROR(c_ACCOUNT_METER_TYPE_ERR || v_ERROR_LIST_ITEM );
   ELSIF v_COUNT > 1 AND v_COUNT <= c_CLOB_ENTITY_THRESHOLD_COUNT THEN
        LOGS.LOG_ERROR(c_ACCOUNT_METER_TYPE_ERR || GET_MESSAGE_LIST);
   ELSIF v_COUNT > c_CLOB_ENTITY_THRESHOLD_COUNT THEN
		DBMS_LOB.CREATETEMPORARY(v_TEXT, true);
		GET_MESSAGE_LIST_CLOB(c_ACCOUNT_METER_TYPE_ERR, v_TEXT);
		LOGS.LOG_ERROR_CLOB(c_ACCOUNT_METER_TYPE_ERR || c_ATTACHMENT_LIST,v_TEXT);
		DBMS_LOB.FREETEMPORARY(v_TEXT);
   END IF;
   RESET_STEP_ERROR_FLAG(v_COUNT);

	-- • If the Account is “Meter” modeled,
	--		the Meter’s Meter_Type  must be ‘Period’ in order to insert SERVICE_CONSUMPTION.
	UPDATE SERVICE_CONSUMPTION_STAGING SCS
	SET ERROR_FLAG      = C_TRUE,
		STEP_ERROR_FLAG = C_TRUE,
		ERROR_LIST_ITEM = ACCOUNT_IDENT,
		ERROR_MESSAGE   = c_METER_METER_TYPE_ERR || SCS.ACCOUNT_IDENT
	WHERE ACCOUNT_MODEL_OPTION = ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_METER
	  AND SCS.METER_TYPE != ACCOUNTS_METERS.c_METER_TYPE_PERIOD
	  AND SCS.METER_ID IS NOT NULL
	  AND SCS.aCCOUNT_ID IS NOT NULL
	  AND ERROR_FLAG = c_FALSE;

	GET_ERROR_LIST_COUNT(v_COUNT, v_ERROR_LIST_ITEM);

   IF v_COUNT = 1 THEN
        LOGS.LOG_ERROR(c_METER_METER_TYPE_ERR || v_ERROR_LIST_ITEM );
   ELSIF v_COUNT > 1 AND v_COUNT <= c_CLOB_ENTITY_THRESHOLD_COUNT THEN
        LOGS.LOG_ERROR(c_METER_METER_TYPE_ERR || GET_MESSAGE_LIST);
   ELSIF v_COUNT > c_CLOB_ENTITY_THRESHOLD_COUNT THEN
		DBMS_LOB.CREATETEMPORARY(v_TEXT, true);
		GET_MESSAGE_LIST_CLOB(c_METER_METER_TYPE_ERR, v_TEXT);
		LOGS.LOG_ERROR_CLOB(c_METER_METER_TYPE_ERR || c_ATTACHMENT_LIST,v_TEXT);
		DBMS_LOB.FREETEMPORARY(v_TEXT);
   END IF;
   RESET_STEP_ERROR_FLAG(v_COUNT);

END VALIDATE_METER_TYPE;
-----------------------------------------------------------------------------------------------
PROCEDURE VALIDATE_MODEL_OPTION IS
	v_COUNT PLS_INTEGER;
	v_TEXT  CLOB := NULL;
	v_ERROR_LIST_ITEM SERVICE_CONSUMPTION_STAGING.ERROR_LIST_ITEM%TYPE;
	v_SINGULAR_MSG PROCESS_LOG_EVENT.EVENT_TEXT%TYPE;
	v_PLURAL_MSG PROCESS_LOG_EVENT.EVENT_TEXT%TYPE;
BEGIN

	-- Model Option must be Account or Meter
	v_SINGULAR_MSG := 'Invalid Model Option for Account: ';
	v_PLURAL_MSG := 'Invalid Model Options (only Account/Meter allowed):';
	UPDATE SERVICE_CONSUMPTION_STAGING SCS
	SET ERROR_FLAG      = C_TRUE,
		STEP_ERROR_FLAG = C_TRUE,
		ERROR_LIST_ITEM = ACCOUNT_IDENT,
		ERROR_MESSAGE   = 'Invalid Model Option for Account: ' || SCS.ACCOUNT_IDENT ||' (Only Account/Meter allowed)'
	WHERE ACCOUNT_MODEL_OPTION NOT IN (ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_METER,ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_ACCOUNT )
	  AND SCS.ACCOUNT_ID IS NOT NULL;

	GET_ERROR_LIST_COUNT(v_COUNT, v_ERROR_LIST_ITEM);

   IF v_COUNT = 1 THEN
     LOGS.LOG_ERROR(v_SINGULAR_MSG || v_ERROR_LIST_ITEM ||' (Only Account/Meter allowed)');
   ELSIF v_COUNT > 1 AND v_COUNT <= c_CLOB_ENTITY_THRESHOLD_COUNT THEN
     LOGS.LOG_ERROR(v_PLURAL_MSG || GET_MESSAGE_LIST);
   ELSIF v_COUNT > c_CLOB_ENTITY_THRESHOLD_COUNT THEN
		DBMS_LOB.CREATETEMPORARY(v_TEXT, true);
		GET_MESSAGE_LIST_CLOB(v_PLURAL_MSG, v_TEXT);
		LOGS.LOG_ERROR_CLOB(v_PLURAL_MSG || c_ATTACHMENT_LIST,v_TEXT);
		DBMS_LOB.FREETEMPORARY(v_TEXT);
   END IF;
   RESET_STEP_ERROR_FLAG(v_COUNT);

	-- Model Option meter must have a meter
	v_SINGULAR_MSG := 'Meter-modeled Account has no meter: ';
	v_PLURAL_MSG := 'Meter-modeled Accounts having no meter:';
	UPDATE SERVICE_CONSUMPTION_STAGING SCS
	SET ERROR_FLAG      = C_TRUE,
		STEP_ERROR_FLAG = C_TRUE,
		ERROR_LIST_ITEM = ACCOUNT_IDENT,
		ERROR_MESSAGE   = v_SINGULAR_MSG || SCS.ACCOUNT_IDENT
	WHERE ACCOUNT_MODEL_OPTION = ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_METER
	  AND SCS.METER_IDENT IS NULL
	  AND SCS.ACCOUNT_ID IS NOT NULL;
	LOG_ERROR_LIST(v_SINGULAR_MSG, v_PLURAL_MSG, c_CLOB_ENTITY_THRESHOLD_COUNT);

	-- Model Option Account must NOT have a meter
	v_SINGULAR_MSG := 'Account-modeled Account cannot have a meter: ';
	v_PLURAL_MSG := 'Account-modeled Accounts cannot have a meter:';
	UPDATE SERVICE_CONSUMPTION_STAGING SCS
	SET ERROR_FLAG      = C_TRUE,
		STEP_ERROR_FLAG = C_TRUE,
		ERROR_LIST_ITEM = ACCOUNT_IDENT,
		ERROR_MESSAGE   = v_SINGULAR_MSG || SCS.ACCOUNT_IDENT
	WHERE ACCOUNT_MODEL_OPTION = ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_ACCOUNT
	  AND SCS.METER_IDENT IS NOT NULL
	  AND SCS.ACCOUNT_ID IS NOT NULL;
	LOG_ERROR_LIST(v_SINGULAR_MSG, v_PLURAL_MSG, c_CLOB_ENTITY_THRESHOLD_COUNT);

END VALIDATE_MODEL_OPTION;

-----------------------------------------------------------------------------------------------
PROCEDURE VALIDATE_UOM IS
	v_COUNT PLS_INTEGER;
	v_TEXT  CLOB := NULL;
	v_ERROR_LIST_ITEM SERVICE_CONSUMPTION_STAGING.ERROR_LIST_ITEM%TYPE;
BEGIN

	UPDATE SERVICE_CONSUMPTION_STAGING SCS
	SET ERROR_FLAG      = C_TRUE,
		STEP_ERROR_FLAG = C_TRUE,
		ERROR_LIST_ITEM = SCS.UOM,
		ERROR_MESSAGE   = 'Invalid UoM: ' || SCS.UOM
	WHERE UPPER(TRIM(SCS.UOM)) NOT IN (SELECT UPPER(TRIM(VALUE))
						  FROM SYSTEM_LABEL
						  WHERE MODULE = 'Entity Manager'
								AND KEY1 = 'Meter Units')
		  AND SCS.UOM IS NOT NULL;

	GET_ERROR_LIST_COUNT(v_COUNT, v_ERROR_LIST_ITEM);

   IF v_COUNT = 1 THEN
     LOGS.LOG_ERROR('Invalid UoM: '||v_ERROR_LIST_ITEM||' (see System Settings -> Global -> Entity Manager -> Meter Units for valid values');
   ELSIF v_COUNT > 1 AND v_COUNT <= c_CLOB_CODE_THRESHOLD_COUNT THEN
     LOGS.LOG_ERROR('Invalid UoMs (see System Settings -> Global -> Entity Manager -> Meter Units for valid values):'|| GET_MESSAGE_LIST);
   ELSIF v_COUNT > c_CLOB_CODE_THRESHOLD_COUNT THEN
		DBMS_LOB.CREATETEMPORARY(v_TEXT, true);
		GET_MESSAGE_LIST_CLOB('Invalid UoMs: ', v_TEXT);
		LOGS.LOG_ERROR_CLOB('Invalid UoMs (see System Settings -> Global -> Entity Manager -> Meter Units for valid values): see attachment for list',v_TEXT);
		DBMS_LOB.FREETEMPORARY(v_TEXT);
   END IF;

   RESET_STEP_ERROR_FLAG(v_COUNT);

END VALIDATE_UOM;
--------------------------------------------------------------------------------------------------
PROCEDURE PROCESS_SERVICE_CONS_STAGING
	(
	p_MESSAGE OUT VARCHAR2,
	p_PROCESS_ID OUT VARCHAR2,
	p_PROCESS_STATUS OUT NUMBER,
	p_TRACE_ON IN NUMBER := 0
	) AS

	v_STAGING_REC cur_SERVICE_CONS_STAGING%ROWTYPE;
	v_RECORD_COUNT			NUMBER;
	v_PROGRESS_RANGE		NUMBER;
	v_SUCCESS_COUNT			NUMBER := 0;
	v_ERROR_MSG				VARCHAR2(4000);
	v_SYNC_STATUS			VARCHAR2(16);
	v_SUCCESS				BOOLEAN;
	v_CONSUMPTION_ID		NUMBER;

	-- For Periodic Commits of Service Consumption Records
	v_COMMIT_EVERY_N_ROWS	PLS_INTEGER;
	v_CURRENT_ROWCOUNT		PLS_INTEGER := 0;
BEGIN
	-- Set the Transaction SETPOINT
	SAVEPOINT SP_SERVICE_CONSUMPTION;

	LOGS.START_PROCESS('Non-Interval Metered Data Sync', p_TRACE_ON => p_TRACE_ON);
	g_NUM_ERRORS := 0;

	-- Get System Setting Value
	BEGIN
	v_COMMIT_EVERY_N_ROWS := NVL(GET_DICTIONARY_VALUE('Usage Factor Calc Commit Every N Rows',
							CONSTANTS.GLOBAL_MODEL,
							'Load Management', 'Usage Factors'), 0);

	EXCEPTION
		WHEN VALUE_ERROR THEN
			ERRS.LOG_AND_RAISE(p_EXTRA_MESSAGE => '"Usage Factor Calc Commit Every N Rows" System Setting ' ||
													'under Global->Load Management->Usage Factors is having invalid value');
	END;

	SELECT COUNT(1)
		INTO v_RECORD_COUNT
	FROM SERVICE_CONSUMPTION_STAGING;

	IF v_RECORD_COUNT > 0 THEN

		UPDATE SERVICE_CONSUMPTION_STAGING SET ERROR_FLAG = c_FALSE, STEP_ERROR_FLAG = c_FALSE;

		GET_ACCOUNT;
		GET_ESP;
		GET_METER;
		GET_POOL;
		GET_SERVICE_LOCATION;
		VALIDATE_BILL_CODE;
		VALIDATE_CONSUMPTION_CODE;
		VALIDATE_MODEL_OPTION;
		VALIDATE_TEMPLATE_PERIOD;
		VALIDATE_UOM;
		VALIDATE_METER_TYPE;
		v_PROGRESS_RANGE := LOGS.PUSH_PROGRESS_RANGE(v_RECORD_COUNT);

		MS.PURGE_CALENDAR_PROFILE_VALUE; -- F6.U24 related

		OPEN cur_SERVICE_CONS_STAGING;
		BEGIN
			LOOP
				FETCH cur_SERVICE_CONS_STAGING into v_STAGING_REC;
			EXIT WHEN cur_SERVICE_CONS_STAGING%NOTFOUND;
			BEGIN
				-- Increment rowcount
				v_CURRENT_ROWCOUNT := v_CURRENT_ROWCOUNT + 1;

				ASSERT(v_STAGING_REC.END_DATE >= v_STAGING_REC.BEGIN_DATE,
					'End Date must be greater than or equal to Begin Date.',
					MSGCODES.c_ERR_DATE_RANGE);

				v_SUCCESS := TRUE;

				MS.IMPORT_SERVICE_CONS_DATA(
				v_STAGING_REC.ACCOUNT_ID,
				v_STAGING_REC.SERVICE_LOCATION_ID, -- SERVICE_LOCATION_ID
				v_STAGING_REC.METER_ID,
				CONSTANTS.LOW_DATE, --AS_OF_DATE
				v_STAGING_REC.BEGIN_DATE,
				v_STAGING_REC.END_DATE,
				NVL(v_STAGING_REC.BILLED_USAGE, 0), -- BILLED_USAGE, Default to 0
				NVL(v_STAGING_REC.BILLED_DEMAND, 0), -- BILLED_DEMAND, Default to 0
				COALESCE(v_STAGING_REC.METERED_USAGE,v_STAGING_REC.BILLED_USAGE, 0), -- METERED_USAGE, Default to BILLED or 0 if null
				COALESCE(v_STAGING_REC.METERED_DEMAND,v_STAGING_REC.BILLED_DEMAND, 0), -- METERED_DEMAND, Default to BILLED or 0 if null
				NVL(v_STAGING_REC.METERS_READ,1), --METERS_READ, Default to 1
				v_STAGING_REC.METER_READING,
				CONSTANTS.LOW_DATE, --RECEIVED_DATE
				0, --IGNORE_CONSUMPTION
				v_SUCCESS,   --OUT
				v_CONSUMPTION_ID, --OUT
				v_STAGING_REC.TEMPLATE_ID,
				v_STAGING_REC.PERIOD_ID,
				NVL(v_STAGING_REC.BILL_CODE, GA.BILL_CONSUMPTION), --BILL_CODE, Default to B
				NVL(v_STAGING_REC.CONSUMPTION_CODE, GA.ACTUAL_CONSUMPTION), --CONSUMPTION_CODE, Default to A
				v_STAGING_REC.UOM, --p_UNIT_OF_MEASURE IN VARCHAR2 := GA.DEFAULT_UNIT_OF_MEASUREMENT
				GA.BASE_SCENARIO_ID, -- SCENARIO_ID
				CONSTANTS.NOT_ASSIGNED, --p_EDC_ID IN NUMBER := NULL [TODO - ?]
				v_STAGING_REC.ESP_ID,
				CONSTANTS.NOT_ASSIGNED, --PSE_ID
				v_STAGING_REC.POOL_ID,
				v_STAGING_REC.BEGIN_DATE, --READ_BEGIN_DATE, Default to Consumption Begin Date
				v_STAGING_REC.END_DATE, --READ_END_DATE, Default to Consumption End Date
				v_STAGING_REC.CONVERSION_FACTOR,
				NULL, --BILL_CYCLE_MONTH, handled by trigger
				v_STAGING_REC.BILL_PROCESSED_DATE);

				IF v_SUCCESS THEN
					v_SUCCESS_COUNT := v_SUCCESS_COUNT + 1;
					v_SYNC_STATUS := CONSTANTS.SYNC_STATUS_SUCCESS;
					v_ERROR_MSG := NULL;
				ELSE
					g_NUM_ERRORS := g_NUM_ERRORS + 1;
					v_SYNC_STATUS := CONSTANTS.SYNC_STATUS_ERROR;
					v_ERROR_MSG := 'Service Consumption record was not created. See the Process Log for details.';
				END IF;
			EXCEPTION
				WHEN OTHERS THEN
					ERRS.LOG_AND_CONTINUE();
					g_NUM_ERRORS := g_NUM_ERRORS + 1;
					v_SYNC_STATUS := CONSTANTS.SYNC_STATUS_ERROR;
					v_ERROR_MSG := SQLERRM;
			END;

			--Update the status and message of the row
            -- Use ROWID instead of "CURRENT OF cur_SERVICE_CONS_STAGING" to avoid issues with periodic commits.
			UPDATE SERVICE_CONSUMPTION_STAGING A
			SET A.SYNC_STATUS = v_SYNC_STATUS,
				A.ERROR_MESSAGE = v_ERROR_MSG
            WHERE A.ROWID = v_STAGING_REC.ROWID;

			LOGS.INCREMENT_PROCESS_PROGRESS (p_RANGE_INDEX => v_PROGRESS_RANGE);

			-- Check if Periodic Commit is required based on System Setting and redefine Savepoint immediately
			IF v_COMMIT_EVERY_N_ROWS <> 0 AND MOD(v_CURRENT_ROWCOUNT, v_COMMIT_EVERY_N_ROWS) = 0 THEN
				COMMIT WORK;
				SAVEPOINT SP_SERVICE_CONSUMPTION;
				LOGS.LOG_DEBUG('Processed ' || v_CURRENT_ROWCOUNT || ' rows out of ' || v_RECORD_COUNT || ' rows');
			END IF;
		END LOOP;

		CLOSE cur_SERVICE_CONS_STAGING;

		EXCEPTION
		WHEN OTHERS THEN
			BEGIN
				CLOSE cur_SERVICE_CONS_STAGING;
			EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE();
			END;
			ERRS.LOG_AND_RAISE(p_SAVEPOINT_NAME => 'SP_SERVICE_CONSUMPTION');
		END;

		LOGS.POP_PROGRESS_RANGE(v_PROGRESS_RANGE);

	END IF;

	-- Log this debug message only if it is committed ONCE for entire process
	-- or final commit for periodic-commit cycle, if it was not committed within the LOOP previously
	IF v_COMMIT_EVERY_N_ROWS = 0 OR ((v_COMMIT_EVERY_N_ROWS <> 0) AND MOD(v_CURRENT_ROWCOUNT, v_COMMIT_EVERY_N_ROWS) <> 0) THEN
		LOGS.LOG_DEBUG('Processed ' || v_CURRENT_ROWCOUNT || ' rows out of ' || v_RECORD_COUNT || ' rows');
		COMMIT;
	END IF;

	p_MESSAGE := 'Process completed with ' || v_SUCCESS_COUNT || ' successful entries and ' || g_NUM_ERRORS || ' errors.';
	p_PROCESS_ID := LOGS.CURRENT_PROCESS_ID;
	LOGS.STOP_PROCESS(p_MESSAGE, p_PROCESS_STATUS);

EXCEPTION
	WHEN OTHERS THEN
		p_PROCESS_ID := LOGS.CURRENT_PROCESS_ID;
		LOGS.STOP_PROCESS(p_MESSAGE, p_PROCESS_STATUS);
		ERRS.LOG_AND_RAISE;
END PROCESS_SERVICE_CONS_STAGING;
--------------------------------------------------------------------------------------------------
PROCEDURE VALIDATE_STATEMENT
    (
    p_CONDITION IN BOOLEAN,
    p_ERROR_MSG IN VARCHAR2,
    p_SUCCESS IN OUT BOOLEAN
    ) AS

BEGIN

    IF NOT p_CONDITION THEN
        p_SUCCESS := FALSE;

        LOGS.LOG_ERROR('Validation failed: ' || p_ERROR_MSG);
    END IF;

END VALIDATE_STATEMENT;
------------------------------------------------------------------------------------------------
FUNCTION VALIDATE_ENTITY
    (
    p_ENTITY_IDENTIFIER IN VARCHAR2,
    p_ENTITY_DOMAIN_ID IN NUMBER,
    p_SUCCESS IN OUT BOOLEAN
    ) RETURN NUMBER AS

    v_ID NUMBER(9);

BEGIN

    v_ID := EI.GET_ID_FROM_IDENTIFIER(p_ENTITY_IDENTIFIER, p_ENTITY_DOMAIN_ID);

    RETURN v_ID;

EXCEPTION
    WHEN MSGCODES.e_ERR_TOO_MANY_ENTRIES THEN
        LOGS.LOG_ERROR('Validation failed: More than one entity with the identifier ' || p_ENTITY_IDENTIFIER
            || ' was found for Entity Domain ' || TEXT_UTIL.TO_CHAR_ENTITY(p_ENTITY_DOMAIN_ID, EC.ED_ENTITY_DOMAIN) || '.');

        p_SUCCESS := FALSE;
        RETURN NULL;
    WHEN MSGCODES.e_ERR_NO_SUCH_ENTRY THEN
        LOGS.LOG_ERROR('Validation failed: No entities with the identifier ' || p_ENTITY_IDENTIFIER
            || ' were found for Entity Domain ' || TEXT_UTIL.TO_CHAR_ENTITY(p_ENTITY_DOMAIN_ID, EC.ED_ENTITY_DOMAIN) || '.');

        p_SUCCESS := FALSE;
        RETURN NULL;
END VALIDATE_ENTITY;
------------------------------------------------------------------------------------------------
PROCEDURE GET_VALUES
    (
    p_REC IN SERVICE_LOAD_STAGING%ROWTYPE,
    p_VALUES OUT NUMBER_COLLECTION,
    p_SUCCESS IN OUT BOOLEAN
    ) AS

    v_NULLS_FOUND BOOLEAN := FALSE;
    v_HOLES_FOUNDS BOOLEAN := FALSE;

    v_LAST NUMBER(3) := 0;

BEGIN

    p_VALUES := NUMBER_COLLECTION(p_REC.VAL1, p_REC.VAL2, p_REC.VAL3, p_REC.VAL4, p_REC.VAL5, p_REC.VAL6, p_REC.VAL7,
        p_REC.VAL8, p_REC.VAL9, p_REC.VAL10, p_REC.VAL11, p_REC.VAL12, p_REC.VAL13, p_REC.VAL14, p_REC.VAL15, p_REC.VAL16,
        p_REC.VAL17, p_REC.VAL18, p_REC.VAL19, p_REC.VAL20, p_REC.VAL21, p_REC.VAL22, p_REC.VAL23, p_REC.VAL24, p_REC.VAL25,
        p_REC.VAL26, p_REC.VAL27, p_REC.VAL28, p_REC.VAL29, p_REC.VAL30, p_REC.VAL31, p_REC.VAL32, p_REC.VAL33, p_REC.VAL34,
        p_REC.VAL35, p_REC.VAL36, p_REC.VAL37, p_REC.VAL38, p_REC.VAL39, p_REC.VAL40, p_REC.VAL41, p_REC.VAL42, p_REC.VAL43,
        p_REC.VAL44, p_REC.VAL45, p_REC.VAL46, p_REC.VAL47, p_REC.VAL48, p_REC.VAL49, p_REC.VAL50, p_REC.VAL51, p_REC.VAL52,
        p_REC.VAL53, p_REC.VAL54, p_REC.VAL55, p_REC.VAL56, p_REC.VAL57, p_REC.VAL58, p_REC.VAL59, p_REC.VAL60, p_REC.VAL61,
        p_REC.VAL62, p_REC.VAL63, p_REC.VAL64, p_REC.VAL65, p_REC.VAL66, p_REC.VAL67, p_REC.VAL68, p_REC.VAL69, p_REC.VAL70,
        p_REC.VAL71, p_REC.VAL72, p_REC.VAL73, p_REC.VAL74, p_REC.VAL75, p_REC.VAL76, p_REC.VAL77, p_REC.VAL78, p_REC.VAL79,
        p_REC.VAL80, p_REC.VAL81, p_REC.VAL82, p_REC.VAL83, p_REC.VAL84, p_REC.VAL85, p_REC.VAL86, p_REC.VAL87, p_REC.VAL88,
        p_REC.VAL89, p_REC.VAL90, p_REC.VAL91, p_REC.VAL92, p_REC.VAL93, p_REC.VAL94, p_REC.VAL95, p_REC.VAL96, p_REC.VAL97,
        p_REC.VAL98, p_REC.VAL99, p_REC.VAL100);

   FOR v_INT IN p_VALUES.FIRST .. p_VALUES.LAST LOOP
        IF p_VALUES(v_INT) IS NULL THEN
            v_NULLS_FOUND := TRUE;
        ELSE
            -- NON-NULL VALUES FOUND AFTER NULL VALUES FOUND, THIS DATA HAS HOLES IN IT
            v_LAST := v_INT;
            IF v_NULLS_FOUND THEN
                v_HOLES_FOUNDS := TRUE;
            END IF;
        END IF;
   END LOOP;

   -- TRIM THE COLLECTION TO THE LAST NON-NULL RECORD
   IF v_LAST < 100 THEN
        p_VALUES.TRIM(100-v_LAST);
   END IF;

   IF v_HOLES_FOUNDS THEN
        LOGS.LOG_ERROR('Validation failed: Account ' || p_REC.ACCOUNT_IDENT || ' on date ' || TEXT_UTIL.TO_CHAR_DATE(p_REC.SERVICE_DATE)
            || ' is missing interval data.');
        p_SUCCESS := FALSE;
   END IF;
END GET_VALUES;
------------------------------------------------------------------------------------------------
PROCEDURE VALIDATE_SERVICE_LOAD_RECORD
    (
    p_REC IN SERVICE_LOAD_STAGING%ROWTYPE,
    p_VALUES OUT NUMBER_COLLECTION,
    p_SUCCESS OUT BOOLEAN
    ) AS

    v_ACCT_MODEL ACCOUNT.ACCOUNT_MODEL_OPTION%TYPE;
    v_IS_SA ACCOUNT.IS_SUB_AGGREGATE%TYPE;
    v_MODEL_ID ACCOUNT.MODEL_ID%TYPE;
    v_IS_LONG BOOLEAN := FALSE;
    v_IS_SHORT BOOLEAN := FALSE;
    v_ID NUMBER(9);
    v_MTR_ID NUMBER(9);
    v_VALID_UOMS_GAS STRING_COLLECTION := STRING_COLLECTION(c_UOM_GAS_DTH, c_UOM_GAS_THM,LOWER(GA.GAS_UNIT_OF_MEASURMENT));
    v_VALID_UOMS_ELC STRING_COLLECTION := STRING_COLLECTION(c_UOM_ELC_KW, c_UOM_ELC_KWH, c_UOM_ELC_MW, c_UOM_ELC_MWH,
                                                        LOWER(GA.ELECTRIC_UNIT_OF_MEASURMENT));

BEGIN

    UT.CREATE_DISTINCT_STRING_COLL(v_VALID_UOMS_GAS, v_VALID_UOMS_GAS);
    UT.CREATE_DISTINCT_STRING_COLL(v_VALID_UOMS_ELC, v_VALID_UOMS_ELC);

    p_SUCCESS := TRUE;

    VALIDATE_STATEMENT(p_REC.ACCOUNT_IDENT IS NOT NULL, 'Account Identifier is required.',p_SUCCESS);
    IF p_REC.ACCOUNT_IDENT IS NOT NULL THEN
        v_ID := VALIDATE_ENTITY(p_REC.ACCOUNT_IDENT, EC.ED_ACCOUNT, p_SUCCESS);
    END IF;

    IF v_ID IS NOT NULL THEN
        SELECT A.ACCOUNT_MODEL_OPTION, A.IS_SUB_AGGREGATE, NVL(A.MODEL_ID, GA.DEFAULT_MODEL)
        INTO v_ACCT_MODEL, v_IS_SA, v_MODEL_ID
        FROM ACCOUNT A
        WHERE A.ACCOUNT_ID = v_ID;

        VALIDATE_STATEMENT(NVL(v_ACCT_MODEL,'NULL') IN (ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_METER, ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_ACCOUNT),
            'The specified Account''s Model must be either ''' || ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_METER || ''' or '''
             || ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_ACCOUNT || '''.', p_SUCCESS);

        VALIDATE_STATEMENT(v_IS_SA = 0, 'Account ' || p_REC.ACCOUNT_IDENT || ' is sub-aggregate.  Sub-aggregate accounts are not supported.', p_SUCCESS);

        IF v_ACCT_MODEL = ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_METER THEN
            VALIDATE_STATEMENT(p_REC.METER_IDENT IS NOT NULL, 'Meter Identifier is required for Meter-modeled Accounts.', p_SUCCESS);

            IF p_REC.METER_IDENT IS NOT NULL THEN
                v_MTR_ID := VALIDATE_ENTITY(p_REC.METER_IDENT, EC.ED_METER, p_SUCCESS);
            END IF;
        ELSE
            VALIDATE_STATEMENT(p_REC.METER_IDENT IS NULL, 'Account ' || p_REC.ACCOUNT_IDENT || ' is Account-Modeled, but has a meter identifier '''
                || p_REC.METER_IDENT || '''.', p_SUCCESS);
        END IF;
    END IF;

    IF p_REC.ESP_IDENT IS NOT NULL THEN
        v_ID := VALIDATE_ENTITY(p_REC.ESP_IDENT,EC.ED_ESP,p_SUCCESS);
    END IF;

    IF p_REC.POOL_IDENT IS NOT NULL THEN
        v_ID := VALIDATE_ENTITY(p_REC.POOL_IDENT,EC.ED_POOL,p_SUCCESS);
    END IF;

    IF p_REC.SERVICE_CODE IS NOT NULL THEN
        VALIDATE_STATEMENT(p_REC.SERVICE_CODE IN (GA.ACTUAL_SERVICE,GA.HISTORICAL_SERVICE), 'Service Code must be either ' || GA.ACTUAL_SERVICE
            || ' or ' || GA.HISTORICAL_SERVICE ||', specified value = ' || p_REC.SERVICE_CODE || '.', p_SUCCESS);
    END IF;

    VALIDATE_STATEMENT(p_REC.INTERVAL IN (CONSTANTS.INTERVAL_15_MINUTE, CONSTANTS.INTERVAL_30_MINUTE, CONSTANTS.INTERVAL_HOUR, CONSTANTS.INTERVAL_DAY),
        'Interval must be ''' || CONSTANTS.INTERVAL_15_MINUTE || ''', ''' || CONSTANTS.INTERVAL_30_MINUTE || ''', ''' ||
        CONSTANTS.INTERVAL_HOUR || ''' or ''' || CONSTANTS.INTERVAL_DAY || '''.  Specified value was ''' || p_REC.INTERVAL || '''.',
        p_SUCCESS);

    IF p_REC.UOM IS NOT NULL THEN
        IF v_MODEL_ID = GA.ELECTRIC_MODEL THEN
            VALIDATE_STATEMENT(UT.STRING_COLLECTION_CONTAINS(v_VALID_UOMS_ELC, LOWER(p_REC.UOM)),
                'UOM must be one of the following units of measure for electric accounts: ' || TEXT_UTIL.TO_CHAR_STRING_LIST(v_VALID_UOMS_ELC)
                || '   Specified UOM was ' || p_REC.UOM || '.', p_SUCCESS);

            IF UT.STRING_COLLECTION_CONTAINS(v_VALID_UOMS_ELC, LOWER(p_REC.UOM)) THEN
                VALIDATE_STATEMENT(UT.CAN_CONVERT(NVL(p_REC.UOM,GA.ELECTRIC_UNIT_OF_MEASURMENT),GA.ELECTRIC_UNIT_OF_MEASURMENT),
                    'The UOM for Account ' || p_REC.ACCOUNT_IDENT || ' on ' || TEXT_UTIL.TO_CHAR_DATE(p_REC.SERVICE_DATE) ||
                     ' is ' || p_REC.UOM || ' which cannot be converted to ' || GA.ELECTRIC_UNIT_OF_MEASURMENT, p_SUCCESS);
            END IF;
        ELSE
            VALIDATE_STATEMENT(UT.STRING_COLLECTION_CONTAINS(v_VALID_UOMS_GAS, LOWER(p_REC.UOM)),
                 'UOM must be one of the following units of measure for gas accounts: ' || TEXT_UTIL.TO_CHAR_STRING_LIST(v_VALID_UOMS_GAS)
                || '   Specified UOM was ' || p_REC.UOM || '.', p_SUCCESS);

            IF UT.STRING_COLLECTION_CONTAINS(v_VALID_UOMS_GAS, LOWER(p_REC.UOM)) THEN
                VALIDATE_STATEMENT(UT.CAN_CONVERT(NVL(p_REC.UOM,GA.GAS_UNIT_OF_MEASURMENT),GA.GAS_UNIT_OF_MEASURMENT),
                    'The UOM for Account ' || p_REC.ACCOUNT_IDENT || ' on ' || TEXT_UTIL.TO_CHAR_DATE(p_REC.SERVICE_DATE) ||
                     ' is ' || p_REC.UOM || ' which cannot be converted to ' || GA.GAS_UNIT_OF_MEASURMENT, p_SUCCESS);
            END IF;
        END IF;
    END IF;

    GET_VALUES(p_REC, p_VALUES, p_SUCCESS);

    v_IS_LONG := (DST_TIME_ZONE(GA.LOCAL_TIME_ZONE) = GA.LOCAL_TIME_ZONE) AND
        (TRUNC(p_REC.SERVICE_DATE) = TRUNC(DST_FALL_BACK_DATE(p_REC.SERVICE_DATE)));
    v_IS_SHORT := (DST_TIME_ZONE(GA.LOCAL_TIME_ZONE) = GA.LOCAL_TIME_ZONE) AND
        (TRUNC(p_REC.SERVICE_DATE) = TRUNC(DST_SPRING_AHEAD_DATE(p_REC.SERVICE_DATE)));

    IF p_REC.INTERVAL = CONSTANTS.INTERVAL_15_MINUTE THEN
        IF v_IS_LONG THEN
            VALIDATE_STATEMENT(p_VALUES.COUNT = 100, 'For the 15-Minute Interval on the DST-long day, 100 values are expected.  ' ||
                p_VALUES.COUNT || ' are present.', p_SUCCESS);
        ELSIF v_IS_SHORT THEN
            VALIDATE_STATEMENT(p_VALUES.COUNT = 92, 'For the 15-Minute Interval on the DST-short day, 92 values are expected.  ' ||
                p_VALUES.COUNT || ' are present.', p_SUCCESS);
        ELSE
            VALIDATE_STATEMENT(p_VALUES.COUNT = 96, 'For the 15-Minute Interval on a normal day, 96 values are expected.  ' ||
                p_VALUES.COUNT || ' are present.', p_SUCCESS);
        END IF;
    ELSIF p_REC.INTERVAL = CONSTANTS.INTERVAL_30_MINUTE THEN
        IF v_IS_LONG THEN
            VALIDATE_STATEMENT(p_VALUES.COUNT = 50, 'For the 30-Minute Interval on the DST-long day, 50 values are expected.  ' ||
                p_VALUES.COUNT || ' are present.', p_SUCCESS);
        ELSIF v_IS_SHORT THEN
            VALIDATE_STATEMENT(p_VALUES.COUNT = 46, 'For the 30-Minute Interval on the DST-short day, 46 values are expected.  ' ||
                p_VALUES.COUNT || ' are present.', p_SUCCESS);
        ELSE
            VALIDATE_STATEMENT(p_VALUES.COUNT = 48, 'For the 30-Minute Interval on a normal day, 48 values are expected.  ' ||
                p_VALUES.COUNT || ' are present.', p_SUCCESS);
        END IF;
    ELSIF p_REC.INTERVAL = CONSTANTS.INTERVAL_HOUR THEN
        IF v_IS_LONG THEN
            VALIDATE_STATEMENT(p_VALUES.COUNT = 25, 'For the Hour Interval on the DST-long day, 25 values are expected.  ' ||
                p_VALUES.COUNT || ' are present.', p_SUCCESS);
        ELSIF v_IS_SHORT THEN
            VALIDATE_STATEMENT(p_VALUES.COUNT = 23, 'For the Hour Interval on the DST-short day, 23 values are expected.  ' ||
                p_VALUES.COUNT || ' are present.', p_SUCCESS);
        ELSE
            VALIDATE_STATEMENT(p_VALUES.COUNT = 24, 'For the Hour Interval on a normal day, 24 values are expected.  ' ||
                p_VALUES.COUNT || ' are present.', p_SUCCESS);
        END IF;
    ELSIF p_REC.INTERVAL = CONSTANTS.INTERVAL_DAY THEN
        VALIDATE_STATEMENT(p_VALUES.COUNT = 1, 'For the Day Interval, only 1 value is expected. ' || p_VALUES.COUNT || ' are present.', p_SUCCESS);
    END IF;

END VALIDATE_SERVICE_LOAD_RECORD;
------------------------------------------------------------------------------------------------
PROCEDURE PROCESS_SERVICE_LOAD
    (
    p_REC IN SERVICE_LOAD_STAGING%ROWTYPE,
    p_VALUES IN NUMBER_COLLECTION,
    p_SUCCESS IN OUT BOOLEAN
    ) AS

    v_ACCT_ID NUMBER(9);
    v_SL_ID NUMBER(9);
    v_METER_ID NUMBER(9) := CONSTANTS.NOT_ASSIGNED;

    v_ESP_ID NUMBER(9) := NULL;
    v_POOL_ID NUMBER(9) := NULL;
    v_MODEL_ID ACCOUNT.MODEL_ID%TYPE;
    v_SERVICE_DATE DATE := TRUNC(p_REC.SERVICE_DATE);
    v_CUT_BASE DATE := TO_CUT(v_SERVICE_DATE,GA.LOCAL_TIME_ZONE);
    v_SERVICE_CODE CHAR(1) := NVL(p_REC.SERVICE_CODE,CONSTANTS.CODE_ACTUAL);
    v_CONVERSION_FACTOR NUMBER;
    v_INTERVAL_DIVISOR NUMBER := DATE_UTIL.GET_INTERVAL_DIVISOR(CONSTANTS.INTERVAL_DAY,p_REC.INTERVAL);

    v_USAGE_VALS GA.FLOAT_TABLE;
    v_USAGE_DATES GA.DATE_TABLE;

BEGIN

    v_ACCT_ID := EI.GET_ID_FROM_IDENTIFIER(p_REC.ACCOUNT_IDENT,EC.ED_ACCOUNT);
    SELECT NVL(A.MODEL_ID, GA.DEFAULT_MODEL)
    INTO v_MODEL_ID
    FROM ACCOUNT A
    WHERE A.ACCOUNT_ID = v_ACCT_ID;

    IF v_MODEL_ID = GA.GAS_MODEL THEN
        v_CONVERSION_FACTOR := UT.GET_CONVERSION_FACTOR(NVL(p_REC.UOM,GA.GAS_UNIT_OF_MEASURMENT),GA.GAS_UNIT_OF_MEASURMENT,p_REC.INTERVAL);
    ELSE
        v_CONVERSION_FACTOR := UT.GET_CONVERSION_FACTOR(NVL(p_REC.UOM,GA.ELECTRIC_UNIT_OF_MEASURMENT),GA.ELECTRIC_UNIT_OF_MEASURMENT,p_REC.INTERVAL);
    END IF;

    IF p_REC.METER_IDENT IS NOT NULL THEN
        v_METER_ID := EI.GET_ID_FROM_IDENTIFIER(p_REC.METER_IDENT,EC.ED_METER);
    END IF;

    IF v_METER_ID = CONSTANTS.NOT_ASSIGNED THEN
        v_SL_ID := CS.GET_SERVICE_LOCATION_ID(v_ACCT_ID,v_SERVICE_DATE);
    ELSE
        v_SL_ID := MS.GET_METER_OWNER(v_METER_ID,v_SERVICE_DATE);
    END IF;

    IF p_REC.ESP_IDENT IS NOT NULL THEN
        v_ESP_ID := EI.GET_ID_FROM_IDENTIFIER(p_REC.ESP_IDENT,EC.ED_ESP);
    END IF;

    IF p_REC.POOL_IDENT IS NOT NULL THEN
        v_POOL_ID := EI.GET_ID_FROM_IDENTIFIER(p_REC.POOL_IDENT,EC.ED_POOL);
    END IF;

    -- BUILD OUR USAGE VALS / DATES COLLECTIONS
    FOR v_IDX IN p_VALUES.FIRST..p_VALUES.LAST LOOP
        v_USAGE_VALS(v_IDX) := p_VALUES(v_IDX)*v_CONVERSION_FACTOR;
        IF p_REC.INTERVAL <> CONSTANTS.INTERVAL_DAY THEN
            v_USAGE_DATES(v_IDX) :=  v_CUT_BASE+ v_IDX/v_INTERVAL_DIVISOR;
        ELSE
            v_USAGE_DATES(v_IDX) := v_SERVICE_DATE;
        END IF;
    END LOOP;

    MS.IMPORT_SERVICE_LOAD_DATA(v_ACCT_ID, v_SL_ID, v_METER_ID, v_SERVICE_DATE, GET_INTERVAL_ABBREVIATION(p_REC.INTERVAL), CONSTANTS.LOW_DATE,
        v_USAGE_VALS, v_USAGE_DATES, p_SUCCESS, p_SERVICE_CODE => v_SERVICE_CODE, p_ESP_ID => v_ESP_ID, p_POOL_ID => v_POOL_ID);

END PROCESS_SERVICE_LOAD;
------------------------------------------------------------------------------------------------
PROCEDURE PROCESS_SERVICE_LOAD_SYNC
  (
  p_MESSAGE OUT VARCHAR2,
    p_PROCESS_ID OUT VARCHAR2,
    p_PROCESS_STATUS OUT NUMBER,
    p_TRACE_ON IN NUMBER := 0
  ) AS

  v_RECORD_COUNT  NUMBER := 0;
    v_SUCCESS BOOLEAN;
    v_VALUES NUMBER_COLLECTION;
  v_SUCCESS_COUNT NUMBER := 0;
  v_ERROR_COUNT   NUMBER := 0;
  v_ERROR_MSG VARCHAR2(4000);

  CURSOR cur_SERVICE_LOAD_STAGING IS
    SELECT * FROM SERVICE_LOAD_STAGING S ORDER BY S.SYNC_ORDER FOR UPDATE;

  v_SERVICE_LOAD_STAGING_REC SERVICE_LOAD_STAGING%ROWTYPE;
BEGIN

    LOGS.START_PROCESS('Process Service Load Staging Table',
                        p_TRACE_ON => p_TRACE_ON);

  SELECT COUNT(1)
  INTO v_RECORD_COUNT
  FROM SERVICE_LOAD_STAGING;

    LOGS.INIT_PROCESS_PROGRESS(p_TOTAL_WORK => v_RECORD_COUNT);

  IF v_RECORD_COUNT > 0 THEN
        OPEN cur_SERVICE_LOAD_STAGING;
        LOOP
            FETCH cur_SERVICE_LOAD_STAGING INTO v_SERVICE_LOAD_STAGING_REC;
            EXIT WHEN cur_SERVICE_LOAD_STAGING%NOTFOUND;
            BEGIN
                VALIDATE_SERVICE_LOAD_RECORD(v_SERVICE_LOAD_STAGING_REC, v_VALUES, v_SUCCESS);
                IF v_SUCCESS THEN
                    PROCESS_SERVICE_LOAD(v_SERVICE_LOAD_STAGING_REC,v_VALUES,v_SUCCESS);
                END IF;

                IF NOT v_SUCCESS THEN
                    v_ERROR_COUNT := v_ERROR_COUNT + 1;
                    UPDATE SERVICE_LOAD_STAGING S
                    SET S.SYNC_STATUS = CONSTANTS.SYNC_STATUS_ERROR
                    WHERE CURRENT OF cur_SERVICE_LOAD_STAGING;
                ELSE
                    v_SUCCESS_COUNT := v_SUCCESS_COUNT + 1;
                    UPDATE SERVICE_LOAD_STAGING S
                    SET S.SYNC_STATUS = CONSTANTS.SYNC_STATUS_SUCCESS
                    WHERE CURRENT OF cur_SERVICE_LOAD_STAGING;
                END IF;
            EXCEPTION
                WHEN OTHERS THEN
                    ERRS.LOG_AND_CONTINUE();
                    v_ERROR_COUNT := v_ERROR_COUNT + 1;

                    -- Grab error message
                    v_ERROR_MSG := SQLERRM;

                    --Update the status and message of the row
                    UPDATE SERVICE_LOAD_STAGING S
                    SET S.SYNC_STATUS = CONSTANTS.SYNC_STATUS_ERROR,
                        S.ERROR_MESSAGE = v_ERROR_MSG
                    WHERE CURRENT OF cur_SERVICE_LOAD_STAGING;
            END;
           LOGS.INCREMENT_PROCESS_PROGRESS;
        END LOOP;

        CLOSE cur_SERVICE_LOAD_STAGING;
        p_MESSAGE := 'Process completed with ' || v_SUCCESS_COUNT || ' successful entries and ' || v_ERROR_COUNT || ' errors.';
    ELSE
        LOGS.LOG_ERROR('There are no Interval Usage records to process.');
        p_MESSAGE := 'No interval usage records were found.  The sync process was not run.';
    END IF;

    p_PROCESS_ID := LOGS.CURRENT_PROCESS_ID;
    -- REPLACE THE MESSAGE WITH OUR OWN
    LOGS.STOP_PROCESS(p_MESSAGE, p_PROCESS_STATUS);

EXCEPTION
    WHEN OTHERS THEN
        IF cur_SERVICE_LOAD_STAGING%ISOPEN THEN
            CLOSE cur_SERVICE_LOAD_STAGING;
        END IF;
        p_PROCESS_ID := LOGS.CURRENT_PROCESS_ID;
        LOGS.STOP_PROCESS(p_MESSAGE, p_PROCESS_STATUS);
        ERRS.LOG_AND_RAISE;
END PROCESS_SERVICE_LOAD_SYNC;
------------------------------------------------------------------------------------------
END DATA_SYNC;
/
