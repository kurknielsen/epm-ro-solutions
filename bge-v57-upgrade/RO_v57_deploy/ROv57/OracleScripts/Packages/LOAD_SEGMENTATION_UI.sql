CREATE OR REPLACE PACKAGE LOAD_SEGMENTATION_UI IS
-- $Revision: 1.20 $

c_ACCOUNT	CONSTANT VARCHAR2(25) := 'Account';
c_CRLF		CONSTANT VARCHAR2(4)  := UTL_TCP.CRLF;

FUNCTION WHAT_VERSION RETURN VARCHAR2;

FUNCTION GET_ACCOUNT_ATT_ID RETURN NUMBER;

PROCEDURE GET_FILTER_SELECTIONS
	(
	p_ORIGINAL_FILTER_SELECTION IN VARCHAR2,
	p_CURSOR                    OUT GA.REFCURSOR
	);

PROCEDURE GET_LOAD_SEGMENTATION_DEF(p_CURSOR OUT GA.REFCURSOR);

PROCEDURE PUT_LOAD_SEGMENTATION_DEF
	(
	p_LOAD_SEGMENTATION_REPORT_ID IN NUMBER,
	p_REPORT_NAME                 IN VARCHAR2
	);

PROCEDURE DELETE_LOAD_SEGMENTATION_DEF(p_LOAD_SEGMENTATION_REPORT_ID IN NUMBER);

PROCEDURE GET_LOAD_SEGMENTATION_DEF_DTLS
	(
    p_LOAD_SEGMENTATION_REPORT_ID IN NUMBER,
	p_CURSOR                      OUT GA.REFCURSOR
	);

PROCEDURE PUT_LOAD_SEGMENTATION_DEF_DTLS
	(
	p_LOAD_SEGMENTATION_REPORT_ID IN NUMBER,
	p_LOAD_SEG_ATTRIBUTE_ID       IN NUMBER,
	p_FILTER_SELECTION            IN VARCHAR2,
	p_SEGMENT_BY                  IN NUMBER
	);

PROCEDURE PUT_ATTRIBUTE_VALUE_LIST
	(
	p_LOAD_SEGMENTATION_REPORT_ID IN LOAD_SEG_DEF_DTLS_ATTR_VALUES.REPORT_ID%TYPE,
	p_LOAD_SEG_ATTRIBUTE_ID       IN LOAD_SEG_DEF_DTLS_ATTR_VALUES.ATTRIBUTE_ID%TYPE,
	p_ATTRIBUTE_VALUE             IN LOAD_SEG_DEF_DTLS_ATTR_VALUES.ATTRIBUTE_VALUE%TYPE,
	p_SELECTED                    IN NUMBER,
	p_ATTRIBUTE_VAL_ID            IN NUMBER DEFAULT NULL,
	p_ATTRIBUTE_VALUE_EXT         IN LOAD_SEG_DEF_DTLS_ATTR_VALUES.ATTRIBUTE_VALUE%TYPE
	);

PROCEDURE DELETE_ATTRIBUTE_VALUE_LIST
	(
	p_LOAD_SEGMENTATION_REPORT_ID IN LOAD_SEG_DEF_DTLS_ATTR_VALUES.REPORT_ID%TYPE,
	p_LOAD_SEG_ATTRIBUTE_ID       IN LOAD_SEG_DEF_DTLS_ATTR_VALUES.ATTRIBUTE_ID%TYPE
	);

PROCEDURE SEARCH_ACCOUNTS
	(
	p_LOAD_SEGMENTATION_REPORT_ID IN LOAD_SEG_DEF_DTLS_ATTR_VALUES.REPORT_ID%TYPE,
	p_NAME_FLAG                   IN NUMBER,
	p_SEARCH_STRING               IN VARCHAR2,
	p_CURSOR                      OUT GA.REFCURSOR
	);

PROCEDURE SEARCH_ATTRIBUTE_VALUES
	(
	p_LOAD_SEGMENTATION_REPORT_ID IN LOAD_SEG_DEF_DTLS_ATTR_VALUES.REPORT_ID%TYPE,
	p_LOAD_SEG_ATTRIBUTE_ID       IN LOAD_SEG_DEF_DTLS_ATTR_VALUES.ATTRIBUTE_ID%TYPE,
	p_SEARCH_STRING               IN VARCHAR2,
	p_CURSOR                      OUT GA.REFCURSOR
	);

-------------------------------------------------------------------------------
-- PROCEDURE RUN_LOAD_SEGMENTATION_REPORT
--
-- Wrapper routine that will handle the processing of the following based on
-- the parameter flag settings. When the flags are set to 1 processing of that step
-- will occur, when set to 0 the processing will be skipped.
--     p_STAGE_DATA_FLG = 1, Gather the report data into the outbound staging tables.
--     p_EXPORT_FILE_FLG = 1, Export each report in the outbound staging tables.
--     p_CLEANUP_DATA_FLG = 1, Delete each report in the outbound staging tables.
PROCEDURE RUN_LOAD_SEGMENTATION_REPORT (
   p_BEGIN_DATE        IN DATE,
   p_END_DATE          IN DATE,
   p_TIME_ZONE         IN VARCHAR2,
   p_RUN_TYPE_ID       IN NUMBER,
   p_INTERVAL          IN VARCHAR2,
   p_REPORT_IDS        IN NUMBER_COLLECTION,
   p_PROCESS_ID       OUT VARCHAR2,
   p_PROCESS_STATUS   OUT NUMBER,
   p_MESSAGE          OUT VARCHAR2,
   p_STAGE_DATA_FLG    IN NUMBER DEFAULT 1,
   p_EXPORT_FILE_FLG   IN NUMBER DEFAULT 1,
   p_CLEANUP_DATA_FLG  IN NUMBER DEFAULT 1
   );

PROCEDURE EXPORT_LOAD_SEG_REPORT
	(
	p_PROCESS_ID				  IN NUMBER,
	p_LOAD_SEGMENTATION_REPORT_ID IN NUMBER,
	p_PROCESS_STATUS			  OUT NUMBER,
	p_MESSAGE					  OUT VARCHAR2
	);

PROCEDURE CLEAN_LOAD_SEG_REPORT
	(
	p_PROCESS_ID					IN NUMBER,
	p_LOAD_SEGMENTATION_REPORT_ID	IN NUMBER,
	p_PROCESS_STATUS				OUT NUMBER,
	p_MESSAGE						OUT VARCHAR2
	);

FUNCTION DETERMINE_SDT_ROLLUP_COLUMN(p_INTERVAL IN VARCHAR2) RETURN VARCHAR2 DETERMINISTIC;

FUNCTION REPORT_DATA_ATTRIB_STMT
	(
	p_SEG_BY_LIST 			IN NUMBER_COLLECTION,
	p_PREFIX 				IN VARCHAR2 DEFAULT NULL,
	p_REMOVE_LAST_COMMA 	IN BOOLEAN DEFAULT FALSE,
	p_SET_COLUMN_ALIAS		IN BOOLEAN DEFAULT FALSE
    ) RETURN VARCHAR2;

FUNCTION REPORT_DATA_INSERT_STMT
	(
	p_SEG_BY_LIST 		IN NUMBER_COLLECTION,
	p_PREFIX			IN VARCHAR2 DEFAULT NULL
	) RETURN VARCHAR2;

FUNCTION REPORT_DATA_SELECT_STMT
	(
	p_SEG_BY_LIST 	 		IN NUMBER_COLLECTION,
	p_PREFIX		 		IN VARCHAR2,
	p_SET_COLUMN_ALIAS		IN BOOLEAN DEFAULT FALSE
	) RETURN VARCHAR2;

FUNCTION INSERT_REPORT_DATA_INSERT_STMT
	(
	p_SEG_BY_LIST	 IN NUMBER_COLLECTION
	) RETURN VARCHAR2;

FUNCTION INSERT_REPORT_DATA_WITH_STMT
    (
    p_SEG_BY_LIST         IN NUMBER_COLLECTION
    ) RETURN VARCHAR2;

FUNCTION INSERT_REPORT_DATA_FROM_STMT
	(
    p_INTERVAL IN VARCHAR2,
	p_SEG_BY_LIST IN NUMBER_COLLECTION
	) RETURN VARCHAR2;

FUNCTION SUB_AGG_REPORT_DATA_NDS
	(
    p_INTERVAL IN VARCHAR2,
    p_LSRRH_REC IN LOAD_SEG_REPORT_RUN_HEADER%ROWTYPE
    ) RETURN VARCHAR2;

PROCEDURE STAGE_SUB_AGG_REPORT_DATA
	(
	p_PROCESS_ID     IN VARCHAR2,
	p_REPORT_ID      IN NUMBER,
	p_INTERVAL       IN VARCHAR2,
	p_TIME_ZONE      IN VARCHAR2,
	p_SERVICE_CODE   IN CHAR,
	p_LSRRH_REC      IN LOAD_SEG_REPORT_RUN_HEADER%ROWTYPE
	);

FUNCTION NON_AGG_REPORT_DATA_SEL_STMT
	(
    p_INTERVAL IN VARCHAR2,
	p_SEG_BY_LIST IN NUMBER_COLLECTION
	) RETURN VARCHAR2;

FUNCTION MERGE_REPORT_DATA_ON_STMT
	(
    p_SEG_BY_LIST IN NUMBER_COLLECTION
	) RETURN VARCHAR2;

FUNCTION MERGE_REPORT_DATA_MATCH_STMT RETURN VARCHAR2;

FUNCTION MERGE_REPORT_DATA_NOMATCH_STMT
	(
	p_SEG_BY_LIST	 IN NUMBER_COLLECTION
	) RETURN VARCHAR2;

FUNCTION NON_AGG_REPORT_DATA_NDS
	(
    p_INTERVAL  IN VARCHAR2,
    p_LSRRH_REC IN LOAD_SEG_REPORT_RUN_HEADER%ROWTYPE,
	p_MERGE		IN BOOLEAN
    ) RETURN VARCHAR2;

PROCEDURE STAGE_NON_AGG_REPORT_DATA
	(
	p_PROCESS_ID     IN VARCHAR2,
	p_REPORT_ID      IN NUMBER,
	p_INTERVAL       IN VARCHAR2,
	p_TIME_ZONE      IN VARCHAR2,
	p_SERVICE_CODE   IN CHAR,
	p_SCENARIO_ID	 IN NUMBER,
	p_LSRRH_REC      IN LOAD_SEG_REPORT_RUN_HEADER%ROWTYPE
	);

$if $$UNIT_TEST_MODE = 1 $then
FUNCTION RLSR_GET_NDS_ACCT_TMP_SEL_STMT
(
	p_PROCESS_ID 		IN NUMBER,
	p_REPORT_ID 		IN NUMBER,
	p_WITH_CNT 			IN PLS_INTEGER,
	p_USE_ACCOUNT_NAMES IN VARCHAR2,
	p_ACCOUNT_FILTER_SEL		IN VARCHAR2,
	p_ATTRIBUTE_ID_SUB_AGG_ACCT IN NUMBER

) RETURN VARCHAR2;

PROCEDURE EXPORT_LOAD_SEG_REPORT_IMPL
	(
	p_PROCESS_ID					IN NUMBER,
	p_LOAD_SEGMENTATION_REPORT_ID	IN NUMBER
	);

PROCEDURE CLEAN_LOAD_SEG_REPORT_IMPL
	(
	p_PROCESS_ID					IN NUMBER,
	p_LOAD_SEGMENTATION_REPORT_ID	IN NUMBER
	);
$end

END LOAD_SEGMENTATION_UI;
/
CREATE OR REPLACE PACKAGE BODY LOAD_SEGMENTATION_UI IS
c_PACKAGE_NAME        CONSTANT VARCHAR2(30) := 'LOAD_SEGMENTATION_UI';
c_ACCOUNT_SYNC_OPTION CONSTANT VARCHAR2(64) := 'Account Sync';
c_CUSTOM_ATTRIBUTES   CONSTANT VARCHAR2(18) := 'Custom Attributes';
c_LOAD_MANAGEMENT_MOD CONSTANT VARCHAR2(16) := 'Load Management';
c_SELECTIONS_MADE     CONSTANT VARCHAR2(18) := '<Selections Made>';
c_VAL_FORMAT 		  CONSTANT VARCHAR2(24) := 'FM999999999999990.9999';
g_ENTITY_ATTR_ACCOUNT NUMBER(9);
c_TRUE_FLG            CONSTANT PLS_INTEGER := 1;
TYPE t_NUMBER_TBL IS TABLE OF NUMBER;
TYPE t_STR_TBL IS TABLE OF VARCHAR2(32);

--------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR2 IS
BEGIN
    RETURN '$Revision: 1.20 $';
END WHAT_VERSION;
---------------------------------------------------------------------------------------------------
FUNCTION GET_ACCOUNT_ATT_ID RETURN NUMBER AS
	v_ATTRIBUTE_ID NUMBER;
BEGIN
	ID.ID_FOR_ENTITY_ATTRIBUTE(c_ACCOUNT, EC.ED_ACCOUNT, 'String', v_ATTRIBUTE_ID);

	RETURN v_ATTRIBUTE_ID;
END GET_ACCOUNT_ATT_ID;
--------------------------------------------------------------------------------
FUNCTION GET_REPORT_NAME(p_LOAD_SEGMENTATION_REPORT_ID IN NUMBER) RETURN VARCHAR2 AS
	v_REPORT_NAME LOAD_SEGMENTATION_DEF.REPORT_NAME%TYPE;
BEGIN
	SELECT REPORT_NAME
	INTO v_REPORT_NAME
	FROM LOAD_SEGMENTATION_DEF LSD
	WHERE LSD.REPORT_ID = p_LOAD_SEGMENTATION_REPORT_ID;

	RETURN v_REPORT_NAME;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
		RETURN NULL;
END GET_REPORT_NAME;
--------------------------------------------------------------------------------
FUNCTION GET_LOAD_SEG_DEF_ATT_EXISTS
(
	p_LOAD_SEGMENTATION_REPORT_ID 	IN NUMBER,
	p_LOAD_SEG_ATTRIBUTE_ID 		IN NUMBER
) RETURN NUMBER AS
	v_ATT_EXISTS NUMBER(1);
BEGIN
	SELECT COUNT(1)
	INTO v_ATT_EXISTS
	FROM LOAD_SEGMENTATION_DEF_DETAILS
	WHERE REPORT_ID = p_LOAD_SEGMENTATION_REPORT_ID
	AND ATTRIBUTE_ID = p_LOAD_SEG_ATTRIBUTE_ID;

	RETURN v_ATT_EXISTS;
END GET_LOAD_SEG_DEF_ATT_EXISTS;
--------------------------------------------------------------------------------
PROCEDURE GET_FILTER_SELECTIONS
	(
	p_ORIGINAL_FILTER_SELECTION IN VARCHAR2,
	p_CURSOR                    OUT GA.REFCURSOR
	) AS
BEGIN
	IF p_ORIGINAL_FILTER_SELECTION = c_SELECTIONS_MADE THEN
		OPEN p_CURSOR FOR
			SELECT CONSTANTS.ALL_STRING FROM DUAL
			UNION ALL
			SELECT c_SELECTIONS_MADE FROM DUAL;
	ELSE
		OPEN p_CURSOR FOR
			SELECT CONSTANTS.ALL_STRING FROM DUAL;
	END IF;
END GET_FILTER_SELECTIONS;
--------------------------------------------------------------------------------
PROCEDURE GET_LOAD_SEGMENTATION_DEF(p_CURSOR OUT GA.REFCURSOR) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT LSD.REPORT_ID AS LOAD_SEGMENTATION_REPORT_ID,
 			    LSD.REPORT_NAME,
			    LSD.CREATE_USER_NAME,
			    LSD.CREATE_DATE,
			    LSD.MODIFY_USER_NAME,
			    LSD.MODIFY_DATE,
             	P.PROCESS_START_TIME LAST_RUN_DATE
		  FROM LOAD_SEGMENTATION_DEF LSD, PROCESS_LOG P
		  WHERE LSD.PROCESS_ID = P.PROCESS_ID (+)
		 ORDER BY LSD.REPORT_NAME;
END GET_LOAD_SEGMENTATION_DEF;
--------------------------------------------------------------------------------
PROCEDURE PUT_LOAD_SEGMENTATION_DEF
	(
	p_LOAD_SEGMENTATION_REPORT_ID IN NUMBER,
	p_REPORT_NAME                 IN VARCHAR2
	) AS
	v_OID                LOAD_SEGMENTATION_DEF.REPORT_ID%TYPE;
	v_USER_ID            APPLICATION_USER.USER_ID%TYPE;
	v_USER_NAME          APPLICATION_USER.USER_NAME%TYPE;
	v_REPORT_NAME_EXISTS NUMBER(1);
BEGIN
	ASSERT(p_REPORT_NAME IS NOT NULL, 'Report Name cannot not be null.', MSGCODES.c_ERR_ARGUMENT);

	v_USER_ID := SECURITY_CONTROLS.CURRENT_USER_ID;

	SELECT NVL(AU.USER_DISPLAY_NAME, AU.USER_NAME)
	INTO v_USER_NAME
	FROM APPLICATION_USER AU
	WHERE AU.USER_ID = v_USER_ID;

	IF p_LOAD_SEGMENTATION_REPORT_ID > 0 THEN
		SELECT COUNT(1)
		INTO v_REPORT_NAME_EXISTS
		FROM LOAD_SEGMENTATION_DEF LSD
		WHERE LSD.REPORT_NAME = p_REPORT_NAME
		      AND LSD.REPORT_ID <> p_LOAD_SEGMENTATION_REPORT_ID;

		IF v_REPORT_NAME_EXISTS = 1 THEN
			ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, 'A report already exists with the name: ' || p_REPORT_NAME);
		END IF;

		UPDATE LOAD_SEGMENTATION_DEF
		SET REPORT_NAME 	 = p_REPORT_NAME,
			MODIFY_USER_NAME = v_USER_NAME,
			MODIFY_DATE 	 = SYSDATE
		WHERE REPORT_ID 	 = p_LOAD_SEGMENTATION_REPORT_ID;
	ELSE
		SELECT COUNT(1)
		INTO v_REPORT_NAME_EXISTS
		FROM LOAD_SEGMENTATION_DEF LSD
		WHERE LSD.REPORT_NAME = p_REPORT_NAME;

		IF v_REPORT_NAME_EXISTS = 1 THEN
			ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, 'A report already exists with the name: ' || p_REPORT_NAME);
		END IF;

		SELECT OID.NEXTVAL INTO v_OID FROM DUAL;

		INSERT INTO LOAD_SEGMENTATION_DEF
			(REPORT_ID, REPORT_NAME, CREATE_USER_NAME, CREATE_DATE, MODIFY_USER_NAME, MODIFY_DATE)
		VALUES
			(v_OID, p_REPORT_NAME, v_USER_NAME, SYSDATE, v_USER_NAME, SYSDATE);
	END IF;
END PUT_LOAD_SEGMENTATION_DEF;
--------------------------------------------------------------------------------
PROCEDURE DELETE_LOAD_SEGMENTATION_DEF(p_LOAD_SEGMENTATION_REPORT_ID IN NUMBER) AS
BEGIN
	DELETE FROM LOAD_SEGMENTATION_DEF WHERE REPORT_ID = p_LOAD_SEGMENTATION_REPORT_ID;
END DELETE_LOAD_SEGMENTATION_DEF;
--------------------------------------------------------------------------------
PROCEDURE GET_LOAD_SEGMENTATION_DEF_DTLS
	(
	p_LOAD_SEGMENTATION_REPORT_ID IN NUMBER,
	p_CURSOR                      OUT GA.REFCURSOR
	) AS
BEGIN
	IF p_LOAD_SEGMENTATION_REPORT_ID IS NULL THEN
		OPEN p_CURSOR FOR
			SELECT NULL FROM DUAL;
		RETURN;
	END IF;

	OPEN p_CURSOR FOR
		SELECT ATT.ATTRIBUTE_NAME 			AS ATTRIBUTE_NAME,
			   ATT.ATTRIBUTE_ORDER_NAME		AS ATTRIBUTE_ORDER_NAME,
			   ATT.ATTRIBUTE_ID 			AS LOAD_SEG_ATTRIBUTE_ID,
			   CASE
				   WHEN EXISTS (SELECT 1
						 		  FROM LOAD_SEG_DEF_DTLS_ATTR_VALUES LSDDAV
						 		 WHERE LSDDAV.REPORT_ID = p_LOAD_SEGMENTATION_REPORT_ID
							   	   AND LSDDAV.ATTRIBUTE_ID = ATT.ATTRIBUTE_ID) THEN
					c_SELECTIONS_MADE
				   ELSE
					CONSTANTS.ALL_STRING
			   END 							AS ORIGINAL_FILTER_SELECTION,
			   CASE
				   WHEN EXISTS (SELECT 1
						 		  FROM LOAD_SEG_DEF_DTLS_ATTR_VALUES LSDDAV
						 		 WHERE LSDDAV.REPORT_ID = p_LOAD_SEGMENTATION_REPORT_ID
							   	   AND LSDDAV.ATTRIBUTE_ID = ATT.ATTRIBUTE_ID) THEN
					c_SELECTIONS_MADE
				   ELSE
					CONSTANTS.ALL_STRING
			   END 							AS FILTER_SELECTION,
			   NVL(LSDD.SEGMENT_BY, 0) 		AS SEGMENT_BY
		FROM (SELECT 'Attribute 0' 	AS SETTING_NAME,
					 ATTRIBUTE_NAME,
					 ATTRIBUTE_NAME AS ATTRIBUTE_ORDER_NAME,
					 ATTRIBUTE_ID
			  FROM ENTITY_ATTRIBUTE
			  WHERE ENTITY_DOMAIN_ID   = EC.ED_ACCOUNT
					AND ATTRIBUTE_NAME = c_ACCOUNT
			  UNION ALL
			  SELECT SETTING_NAME,
					 VALUE 			AS ATTRIBUTE_NAME,
					 'Z' || VALUE 	AS ATTRIBUTE_ORDER_NAME,
					 EA.ATTRIBUTE_ID
			  FROM SYSTEM_DICTIONARY SD, ENTITY_ATTRIBUTE EA
			  WHERE SD.MODEL_ID   = CONSTANTS.GLOBAL_MODEL
					AND SD.MODULE = c_LOAD_MANAGEMENT_MOD
					AND SD.KEY1   = c_ACCOUNT_SYNC_OPTION
					AND SD.KEY2   = c_CUSTOM_ATTRIBUTES
					AND SD.VALUE  = EA.ATTRIBUTE_NAME) ATT,
			 LOAD_SEGMENTATION_DEF_DETAILS LSDD
		WHERE LSDD.REPORT_ID(+)        = p_LOAD_SEGMENTATION_REPORT_ID
			  AND LSDD.ATTRIBUTE_ID(+) = ATT.ATTRIBUTE_ID
		ORDER BY ATT.ATTRIBUTE_ORDER_NAME;
END GET_LOAD_SEGMENTATION_DEF_DTLS;
--------------------------------------------------------------------------------
PROCEDURE PUT_LOAD_SEGMENTATION_DEF_DTLS
	(
	p_LOAD_SEGMENTATION_REPORT_ID IN NUMBER,
	p_LOAD_SEG_ATTRIBUTE_ID       IN NUMBER,
	p_FILTER_SELECTION            IN VARCHAR2,
	p_SEGMENT_BY                  IN NUMBER
	) AS
BEGIN
	ASSERT(p_LOAD_SEGMENTATION_REPORT_ID IS NOT NULL, 'Report ID cannot be null.');
	ASSERT(p_LOAD_SEGMENTATION_REPORT_ID > 0, 'Report ID cannot be less than zero.');

	IF (GET_LOAD_SEG_DEF_ATT_EXISTS(p_LOAD_SEGMENTATION_REPORT_ID, p_LOAD_SEG_ATTRIBUTE_ID) = 1) THEN
		UPDATE LOAD_SEGMENTATION_DEF_DETAILS LSDD
		SET SEGMENT_BY 		  = p_SEGMENT_BY
		WHERE LSDD.REPORT_ID  = p_LOAD_SEGMENTATION_REPORT_ID
		AND LSDD.ATTRIBUTE_ID = p_LOAD_SEG_ATTRIBUTE_ID;
	ELSE
		INSERT INTO LOAD_SEGMENTATION_DEF_DETAILS
			(REPORT_ID, ATTRIBUTE_ID, SEGMENT_BY)
		VALUES
			(p_LOAD_SEGMENTATION_REPORT_ID, p_LOAD_SEG_ATTRIBUTE_ID, p_SEGMENT_BY);
	END IF;

	IF p_FILTER_SELECTION = CONSTANTS.ALL_STRING THEN
		DELETE_ATTRIBUTE_VALUE_LIST(p_LOAD_SEGMENTATION_REPORT_ID, p_LOAD_SEG_ATTRIBUTE_ID);
	END IF;

	PUT_LOAD_SEGMENTATION_DEF(p_LOAD_SEGMENTATION_REPORT_ID, GET_REPORT_NAME(p_LOAD_SEGMENTATION_REPORT_ID));
END PUT_LOAD_SEGMENTATION_DEF_DTLS;
--------------------------------------------------------------------------------
PROCEDURE PUT_ATTRIBUTE_VALUE_LIST
	(
	p_LOAD_SEGMENTATION_REPORT_ID IN LOAD_SEG_DEF_DTLS_ATTR_VALUES.REPORT_ID%TYPE,
	p_LOAD_SEG_ATTRIBUTE_ID       IN LOAD_SEG_DEF_DTLS_ATTR_VALUES.ATTRIBUTE_ID%TYPE,
	p_ATTRIBUTE_VALUE             IN LOAD_SEG_DEF_DTLS_ATTR_VALUES.ATTRIBUTE_VALUE%TYPE,
	p_SELECTED                    IN NUMBER,
	p_ATTRIBUTE_VAL_ID            IN NUMBER DEFAULT NULL,
	p_ATTRIBUTE_VALUE_EXT         IN LOAD_SEG_DEF_DTLS_ATTR_VALUES.ATTRIBUTE_VALUE%TYPE
	) AS
	v_ATTRIBUTE_VALUE       LOAD_SEG_DEF_DTLS_ATTR_VALUES.ATTRIBUTE_VALUE%TYPE;
	v_UNIQUE_NAMES          NUMBER(1);
	v_SEGMENT_BY            NUMBER(1);
BEGIN
	ASSERT(p_LOAD_SEGMENTATION_REPORT_ID IS NOT NULL, 'Report ID cannot be null.');
	ASSERT(p_LOAD_SEGMENTATION_REPORT_ID > 0, 'Report ID cannot be less than zero.');

	IF GA.ENFORCE_UNIQUE_NAMES THEN
		v_UNIQUE_NAMES := 1;
	ELSE
		v_UNIQUE_NAMES := 0;
	END IF;

	IF p_LOAD_SEG_ATTRIBUTE_ID = g_ENTITY_ATTR_ACCOUNT THEN
		BEGIN
			SELECT CASE
					   WHEN v_UNIQUE_NAMES = 1 THEN
							A.ACCOUNT_NAME
					   ELSE
							A.ACCOUNT_EXTERNAL_IDENTIFIER
				   END
			INTO v_ATTRIBUTE_VALUE
			FROM ACCOUNT A
			WHERE A.ACCOUNT_ID = p_ATTRIBUTE_VAL_ID;
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				v_ATTRIBUTE_VALUE := CASE
										 WHEN v_UNIQUE_NAMES = 1 THEN
											p_ATTRIBUTE_VALUE
										 ELSE
											p_ATTRIBUTE_VALUE_EXT
									 END;
		END;
	ELSE
		v_ATTRIBUTE_VALUE := p_ATTRIBUTE_VALUE;
	END IF;

	DELETE FROM LOAD_SEG_DEF_DTLS_ATTR_VALUES
	WHERE REPORT_ID 	  = p_LOAD_SEGMENTATION_REPORT_ID
	  AND ATTRIBUTE_ID    = p_LOAD_SEG_ATTRIBUTE_ID
	  AND ATTRIBUTE_VALUE = v_ATTRIBUTE_VALUE;

	IF (GET_LOAD_SEG_DEF_ATT_EXISTS(p_LOAD_SEGMENTATION_REPORT_ID, p_LOAD_SEG_ATTRIBUTE_ID) = 1) THEN
		SELECT SEGMENT_BY
		INTO v_SEGMENT_BY
		FROM LOAD_SEGMENTATION_DEF_DETAILS LSDD
		WHERE LSDD.REPORT_ID  = p_LOAD_SEGMENTATION_REPORT_ID
		AND LSDD.ATTRIBUTE_ID = p_LOAD_SEG_ATTRIBUTE_ID;
	ELSE
		v_SEGMENT_BY := 0;
	END IF;

	/* Make a call to PUT_LOAD_SEGMENTATION_DEF_DTLS as we need to insert the parent table
	   LOAD_SEGMENTATION_DEF_DETAILS if record does not exist. */
	PUT_LOAD_SEGMENTATION_DEF_DTLS(p_LOAD_SEGMENTATION_REPORT_ID,
								   p_LOAD_SEG_ATTRIBUTE_ID,
								   c_SELECTIONS_MADE, /* Using CONSTANTS.ALL_STRING would delete all. Hence use c_SELECTIONS_MADE. */
								   v_SEGMENT_BY);

	IF p_SELECTED = 1 THEN
		INSERT INTO LOAD_SEG_DEF_DTLS_ATTR_VALUES
			(REPORT_ID, ATTRIBUTE_ID, ATTRIBUTE_VALUE)
		VALUES
			(p_LOAD_SEGMENTATION_REPORT_ID, p_LOAD_SEG_ATTRIBUTE_ID, v_ATTRIBUTE_VALUE);
	END IF;
END PUT_ATTRIBUTE_VALUE_LIST;
--------------------------------------------------------------------------------
PROCEDURE DELETE_ATTRIBUTE_VALUE_LIST
	(
	p_LOAD_SEGMENTATION_REPORT_ID IN LOAD_SEG_DEF_DTLS_ATTR_VALUES.REPORT_ID%TYPE,
	p_LOAD_SEG_ATTRIBUTE_ID       IN LOAD_SEG_DEF_DTLS_ATTR_VALUES.ATTRIBUTE_ID%TYPE
	) AS
BEGIN
	DELETE FROM LOAD_SEG_DEF_DTLS_ATTR_VALUES
	WHERE REPORT_ID  = p_LOAD_SEGMENTATION_REPORT_ID
	AND ATTRIBUTE_ID = p_LOAD_SEG_ATTRIBUTE_ID;
END DELETE_ATTRIBUTE_VALUE_LIST;
--------------------------------------------------------------------------------
PROCEDURE SEARCH_ACCOUNTS
	(
	p_LOAD_SEGMENTATION_REPORT_ID IN LOAD_SEG_DEF_DTLS_ATTR_VALUES.REPORT_ID%TYPE,
	p_NAME_FLAG                   IN NUMBER,
	p_SEARCH_STRING               IN VARCHAR2,
	p_CURSOR                      OUT GA.REFCURSOR
	) AS
	v_UNIQUE_NAMES  NUMBER(1);
	v_SEARCH_STRING VARCHAR2(256);
BEGIN
	IF p_SEARCH_STRING IS NULL THEN
		OPEN p_CURSOR FOR
			SELECT NULL FROM DUAL;
		RETURN;
	END IF;

	v_SEARCH_STRING := GUI_UTIL.FIX_SEARCH_STRING(p_SEARCH_STRING);

	IF GA.ENFORCE_UNIQUE_NAMES THEN
		v_UNIQUE_NAMES := 1;
	ELSE
		v_UNIQUE_NAMES := 0;
	END IF;

	OPEN p_CURSOR FOR
		/* Query to return Sub-Aggregate Accounts that have not been selected yet. */
		SELECT 0 									AS SELECTED,
			   T.ACCOUNT_NAME						AS ATTRIBUTE_VALUE,
			   T.ACCOUNT_EXTERNAL_IDENTIFIER		AS ATTRIBUTE_VALUE_EXT,
			   T.ACCOUNT_ID 						AS ATTRIBUTE_VAL_ID,
			   0 									AS DEPRECATED,
			   g_ENTITY_ATTR_ACCOUNT 				AS LOAD_SEG_ATTRIBUTE_ID,
			   T.ATTRIBUTE_VALUE					AS ORDER_ATTRIBUTE_VALUE
		FROM (SELECT A.ACCOUNT_NAME,
					 A.ACCOUNT_EXTERNAL_IDENTIFIER,
					 A.ACCOUNT_ID,
					 CASE
						 WHEN v_UNIQUE_NAMES = 1 THEN
						  A.ACCOUNT_NAME
						 ELSE
						  A.ACCOUNT_EXTERNAL_IDENTIFIER
					 END 						AS ATTRIBUTE_VALUE
			  FROM ACCOUNT A
			  WHERE A.ACCOUNT_MODEL_OPTION IN (ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_ACCOUNT,
			  								   ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_METER)
					AND A.MODEL_ID = GA.DEFAULT_MODEL
					AND ((p_NAME_FLAG = 0 AND UPPER(A.ACCOUNT_NAME) LIKE UPPER(v_SEARCH_STRING)) OR
						 (p_NAME_FLAG = 1 AND UPPER(A.ACCOUNT_EXTERNAL_IDENTIFIER) LIKE UPPER(v_SEARCH_STRING)))) T
		WHERE NOT EXISTS (SELECT 1
						  FROM LOAD_SEG_DEF_DTLS_ATTR_VALUES LSDDAV
						  WHERE LSDDAV.REPORT_ID        = p_LOAD_SEGMENTATION_REPORT_ID
						  		AND LSDDAV.ATTRIBUTE_ID       = g_ENTITY_ATTR_ACCOUNT
						  		AND LSDDAV.ATTRIBUTE_VALUE    = T.ATTRIBUTE_VALUE)
		UNION
		/* Query to return Sub-Aggregate Accounts that had been selected, but do not exist anymore. */
		SELECT 1 								AS SELECTED,
			   CASE
			   	   WHEN v_UNIQUE_NAMES = 1 THEN
			   		LSDDAV.ATTRIBUTE_VALUE
				   ELSE
				    NULL
				   END							AS ATTRIBUTE_VALUE,
			   CASE
				   WHEN v_UNIQUE_NAMES = 1 THEN
			   		NULL
				   ELSE
				    LSDDAV.ATTRIBUTE_VALUE
				   END							AS ATTRIBUTE_VALUE_EXT,
			   NULL 							AS ATTRIBUTE_VAL_ID,
			   1								AS DEPRECATED,
			   g_ENTITY_ATTR_ACCOUNT 			AS LOAD_SEG_ATTRIBUTE_ID,
			   LSDDAV.ATTRIBUTE_VALUE			AS ORDER_ATTRIBUTE_VALUE
		FROM LOAD_SEG_DEF_DTLS_ATTR_VALUES LSDDAV
		WHERE LSDDAV.REPORT_ID        = p_LOAD_SEGMENTATION_REPORT_ID
			  AND LSDDAV.ATTRIBUTE_ID = g_ENTITY_ATTR_ACCOUNT
			  AND NOT EXISTS (SELECT 1
							  FROM ACCOUNT A
							  WHERE ((v_UNIQUE_NAMES = 1 AND A.ACCOUNT_NAME = LSDDAV.ATTRIBUTE_VALUE) OR
								     (v_UNIQUE_NAMES = 0 AND A.ACCOUNT_EXTERNAL_IDENTIFIER = LSDDAV.ATTRIBUTE_VALUE)))
		UNION
		/* Query to return Sub-Aggregate Accounts that had been selected, and Account Name/ Account Ext Identifier exists in table. */
		SELECT 1 								AS SELECTED,
			   A.ACCOUNT_NAME					AS ATTRIBUTE_VALUE,
			   A.ACCOUNT_EXTERNAL_IDENTIFIER	AS ATTRIBUTE_VALUE_EXT,
			   A.ACCOUNT_ID 					AS ATTRIBUTE_VAL_ID,
			   0								AS DEPRECATED,
			   g_ENTITY_ATTR_ACCOUNT 			AS LOAD_SEG_ATTRIBUTE_ID,
			   CASE
				   WHEN v_UNIQUE_NAMES = 1 THEN
				    A.ACCOUNT_NAME
				   ELSE
				    A.ACCOUNT_EXTERNAL_IDENTIFIER
			   END 								AS ORDER_ATTRIBUTE_VALUE
		FROM LOAD_SEG_DEF_DTLS_ATTR_VALUES LSDDAV,
			 ACCOUNT A
		WHERE LSDDAV.REPORT_ID        = p_LOAD_SEGMENTATION_REPORT_ID
			  AND LSDDAV.ATTRIBUTE_ID = g_ENTITY_ATTR_ACCOUNT
			  AND ((v_UNIQUE_NAMES = 1 AND A.ACCOUNT_NAME = LSDDAV.ATTRIBUTE_VALUE) OR
				   (v_UNIQUE_NAMES = 0 AND A.ACCOUNT_EXTERNAL_IDENTIFIER = LSDDAV.ATTRIBUTE_VALUE))
		ORDER BY SELECTED DESC, ORDER_ATTRIBUTE_VALUE;
END SEARCH_ACCOUNTS;
--------------------------------------------------------------------------------
PROCEDURE SEARCH_ATTRIBUTE_VALUES
	(
	p_LOAD_SEGMENTATION_REPORT_ID IN LOAD_SEG_DEF_DTLS_ATTR_VALUES.REPORT_ID%TYPE,
	p_LOAD_SEG_ATTRIBUTE_ID       IN LOAD_SEG_DEF_DTLS_ATTR_VALUES.ATTRIBUTE_ID%TYPE,
	p_SEARCH_STRING               IN VARCHAR2,
	p_CURSOR                      OUT GA.REFCURSOR
	) AS
	v_SEARCH_STRING VARCHAR2(256);
BEGIN
	IF p_SEARCH_STRING IS NULL THEN
		OPEN p_CURSOR FOR
			SELECT NULL FROM DUAL;
		RETURN;
	END IF;

	v_SEARCH_STRING := GUI_UTIL.FIX_SEARCH_STRING(p_SEARCH_STRING);

	OPEN p_CURSOR FOR
		/* Query to return values that have not been selected  */
		SELECT 0 						AS SELECTED,
			   TEA.ATTRIBUTE_VAL 		AS ATTRIBUTE_VALUE,
			   NULL						AS ATTRIBUTE_VAL_ID,
			   0 						AS DEPRECATED,
			   p_LOAD_SEG_ATTRIBUTE_ID 	AS LOAD_SEG_ATTRIBUTE_ID
		FROM TEMPORAL_ENTITY_ATTRIBUTE TEA
		WHERE TEA.ATTRIBUTE_ID         = p_LOAD_SEG_ATTRIBUTE_ID
			AND TEA.ENTITY_DOMAIN_ID = EC.ED_ACCOUNT
			AND UPPER(TEA.ATTRIBUTE_VAL) LIKE UPPER(v_SEARCH_STRING)
			AND NOT EXISTS (SELECT 1
							FROM LOAD_SEG_DEF_DTLS_ATTR_VALUES LSDDAV
							WHERE LSDDAV.REPORT_ID         		= p_LOAD_SEGMENTATION_REPORT_ID
								  AND LSDDAV.ATTRIBUTE_ID       = p_LOAD_SEG_ATTRIBUTE_ID
								  AND LSDDAV.ATTRIBUTE_VALUE    = TEA.ATTRIBUTE_VAL)
		UNION
		/* Query to return values that had been selected, but does not exist in TEMPORAL_ENTITY_ATTRIBUTE */
		SELECT 1 						AS SELECTED,
			   LSDDAV.ATTRIBUTE_VALUE 	AS ATTRIBUTE_VALUE,
			   NULL						AS ATTRIBUTE_VAL_ID,
			   1 						AS DEPRECATED,
			   p_LOAD_SEG_ATTRIBUTE_ID 	AS LOAD_SEG_ATTRIBUTE_ID
		FROM LOAD_SEG_DEF_DTLS_ATTR_VALUES LSDDAV
		WHERE LSDDAV.REPORT_ID        = p_LOAD_SEGMENTATION_REPORT_ID
			AND LSDDAV.ATTRIBUTE_ID = p_LOAD_SEG_ATTRIBUTE_ID
			AND NOT EXISTS (SELECT 1
							FROM TEMPORAL_ENTITY_ATTRIBUTE TEA
							WHERE TEA.ATTRIBUTE_ID        	= p_LOAD_SEG_ATTRIBUTE_ID
								  AND TEA.ENTITY_DOMAIN_ID 	= EC.ED_ACCOUNT
								  AND TEA.ATTRIBUTE_VAL    	= LSDDAV.ATTRIBUTE_VALUE)
		UNION
 		/* Query to return values that had been selected, and exist in TEMPORAL_ENTITY_ATTRIBUTE */
		SELECT 1 						AS SELECTED,
			   LSDDAV.ATTRIBUTE_VALUE 	AS ATTRIBUTE_VALUE,
			   NULL						AS ATTRIBUTE_VAL_ID,
			   0 						AS DEPRECATED,
			   p_LOAD_SEG_ATTRIBUTE_ID 	AS LOAD_SEG_ATTRIBUTE_ID
		FROM LOAD_SEG_DEF_DTLS_ATTR_VALUES LSDDAV,
		   TEMPORAL_ENTITY_ATTRIBUTE TEA
		WHERE LSDDAV.REPORT_ID        	= p_LOAD_SEGMENTATION_REPORT_ID
			AND LSDDAV.ATTRIBUTE_ID 	= p_LOAD_SEG_ATTRIBUTE_ID
			AND TEA.ATTRIBUTE_ID    	= LSDDAV.ATTRIBUTE_ID
			AND TEA.ENTITY_DOMAIN_ID 	= EC.ED_ACCOUNT
			AND TEA.ATTRIBUTE_VAL    	= LSDDAV.ATTRIBUTE_VALUE
		ORDER BY SELECTED DESC, ATTRIBUTE_VALUE;
END SEARCH_ATTRIBUTE_VALUES;
-------------------------------------------------------------------------------
/*FUNCTION RLSR_GET_NDS_ATTR_NAME_VAL
(
	p_COL_COUNT IN INTEGER
)RETURN VARCHAR2
IS
	v_STR VARCHAR2(4000);
BEGIN
	-- Get the columns ATTR_NAME_01, ATTR_VAL_01 etc.
	FOR I IN 1..p_COL_COUNT LOOP
		v_STR := v_STR ||  'ATTR_NAME_'|| LPAD(I, 2, '0') || ', ATTR_VAL_' || LPAD(I, 2, '0') ||
				 CASE WHEN I < p_COL_COUNT THEN ',' ELSE ')' END || c_CRLF;
	END LOOP;

	RETURN v_STR;
END RLSR_GET_NDS_ATTR_NAME_VAL;*/
FUNCTION RLSR_GET_NDS_ATTR_NAME_VAL
(
	p_ATTR_ORDINAL_INDEXES IN t_NUMBER_TBL
)RETURN VARCHAR2
IS
	v_STR VARCHAR2(4000);
BEGIN
	-- Get the columns ATTR_NAME_01, ATTR_VAL_01 etc.
	FOR I IN 1..p_ATTR_ORDINAL_INDEXES.COUNT LOOP
		v_STR := v_STR ||  'ATTR_NAME_'|| LPAD(p_ATTR_ORDINAL_INDEXES(I)-1, 2, '0') || ', ATTR_VAL_' ||
				  LPAD(p_ATTR_ORDINAL_INDEXES(I)-1, 2, '0') ||
				 CASE WHEN I < p_ATTR_ORDINAL_INDEXES.COUNT THEN ',' ELSE ')' END || c_CRLF;
	END LOOP;

	RETURN v_STR;
END RLSR_GET_NDS_ATTR_NAME_VAL;
-------------------------------------------------------------------------------
FUNCTION RLSR_GET_NDS_ACCT_TMP_SEL_STMT
(
	p_PROCESS_ID 				IN NUMBER,
	p_REPORT_ID 				IN NUMBER,
	p_WITH_CNT 					IN PLS_INTEGER,
	p_USE_ACCOUNT_NAMES 		IN VARCHAR2,
	p_ACCOUNT_FILTER_SEL		IN VARCHAR2,
	p_ATTRIBUTE_ID_SUB_AGG_ACCT IN NUMBER
) RETURN VARCHAR2
IS
	v_SELECT_STMT  VARCHAR2(32767) := '';
	v_SQL_STMT	   VARCHAR2(8000) := '';
	b_ACCOUNT_FILTER_SEL BOOLEAN  := CASE WHEN p_ACCOUNT_FILTER_SEL = c_SELECTIONS_MADE THEN TRUE ELSE FALSE END;

	v_STR_ADJ_BEGIN_DATE VARCHAR2(128) :=  ':BEGIN_DATE';
	v_STR_ADJ_END_DATE VARCHAR2(128)   :=  ':END_DATE';
	v_STR_HIGH_DATE VARCHAR2(128)  	   :=  ':HIGH_DATE';
	------------------------------------------------------------------------
	FUNCTION I_GET_ITER_JOIN_STR(p_MAX_IDX IN INTEGER)
	RETURN VARCHAR2
	IS
		v_SQL_STR  VARCHAR2(8000);
		---------------------------------------------------------------------
		FUNCTION II_GET_ITER_JOIN_STR(p_CURR_IDX IN INTEGER)
		RETURN VARCHAR2
		IS
			v_SQL_STR2 VARCHAR2(4000) := ' AND ATTR_'|| LPAD(p_CURR_IDX, 2, '0') || '.BEGIN_DATE <= LEAST('||v_STR_ADJ_END_DATE|| c_CRLF;
		BEGIN
			-- "LEAST" join
			FOR v_IDX IN 2..p_CURR_IDX LOOP
				v_SQL_STR2 := v_SQL_STR2 || CASE WHEN v_IDX < p_CURR_IDX THEN ', ATTR_'|| LPAD(v_IDX - 1, 2, '0') || '.END_DATE'|| c_CRLF
												 ELSE ', ATTR_'|| LPAD(v_IDX - 1, 2, '0') || '.END_DATE)'|| c_CRLF
											END;
			END LOOP;

			-- "GREATEST" join
			v_SQL_STR2 := v_SQL_STR2 || ' AND ATTR_'|| LPAD(p_CURR_IDX, 2, '0') || '.END_DATE   >= GREATEST('||v_STR_ADJ_BEGIN_DATE||c_CRLF;
			FOR v_IDX IN 2..p_CURR_IDX LOOP
				v_SQL_STR2 := v_SQL_STR2 || CASE WHEN v_IDX < p_CURR_IDX THEN ', ATTR_'|| LPAD(v_IDX - 1, 2, '0') || '.BEGIN_DATE'|| c_CRLF
												 ELSE ', ATTR_'|| LPAD(v_IDX - 1, 2, '0') || '.BEGIN_DATE)'|| c_CRLF
											END;
			END LOOP;

			RETURN v_SQL_STR2;
		END II_GET_ITER_JOIN_STR;
	BEGIN
		FOR J IN 2..p_MAX_IDX LOOP
			v_SQL_STR := v_SQL_STR || ' AND ATTR_' || LPAD(J, 2, '0') || '.ACCOUNT_ID  = ATTR_' || LPAD(J -1, 2, '0')||
						 '.ACCOUNT_ID'||c_CRLF;
		END LOOP;

		FOR J IN 2..p_MAX_IDX LOOP
			v_SQL_STR := v_SQL_STR || II_GET_ITER_JOIN_STR(J);
		END LOOP;


		RETURN v_SQL_STR;
	END I_GET_ITER_JOIN_STR;
BEGIN
	-- "SELECT" prologue
	v_SELECT_STMT := v_SELECT_STMT || ' SELECT '||TO_CHAR(p_PROCESS_ID)||' AS PROCESS_ID, '||c_CRLF||
                                        '        '||TO_CHAR(p_REPORT_ID)||' AS REPORT_ID, '||c_CRLF||
                                        '        A.ACCOUNT_ID AS ACCOUNT_ID, '||c_CRLF||
                                        '        A.ACCOUNT_MODEL_OPTION AS ACCOUNT_MODEL_OPTION, '||c_CRLF||
                                        (CASE p_USE_ACCOUNT_NAMES
                                              WHEN 'TRUE' THEN
                                        '        A.ACCOUNT_NAME AS ACCOUNT_IDENT, '||c_CRLF
                                              ELSE
                                        '        A.ACCOUNT_EXTERNAL_IDENTIFIER AS ACCOUNT_IDENT, '||c_CRLF
                                        END)||
                                        '        A.IS_SUB_AGGREGATE AS IS_SUB_AGGREGATE,'||c_CRLF;

	-- Still in "SELECT" prologue with CARTESIAN FILTER join on the dates for GREATEST
	IF p_WITH_CNT = 0 THEN
		v_SELECT_STMT := v_SELECT_STMT || '        ' || v_STR_ADJ_BEGIN_DATE || ' AS BEGIN_DATE, ' || c_CRLF;
	ELSE
		v_SELECT_STMT := v_SELECT_STMT || '        GREATEST(' || v_STR_ADJ_BEGIN_DATE || ', ' || c_CRLF;
	END IF;

	FOR I IN 1..p_WITH_CNT LOOP
		v_SQL_STMT :=  v_SQL_STMT || '                 ATTR_' || LPAD(I, 2, '0') || '.BEGIN_DATE ' ||
					  CASE WHEN I < p_WITH_CNT THEN ',' || c_CRLF  ELSE ')  AS BEGIN_DATE, ' || c_CRLF END;
	END LOOP;

	-- Still in "SELECT" prologue with CARTESIAN FILTER join on the dates for LEAST
	IF p_WITH_CNT = 0 THEN
		v_SELECT_STMT := v_SELECT_STMT || v_SQL_STMT || '        ' || v_STR_ADJ_END_DATE || ' AS END_DATE ' || c_CRLF;
	ELSE
		v_SELECT_STMT := v_SELECT_STMT || v_SQL_STMT || '        LEAST(NVL(' || v_STR_ADJ_END_DATE || ',' || v_STR_HIGH_DATE ||
					  	'), ' || c_CRLF;
	END IF;

	v_SQL_STMT := '';
	FOR I IN 1..p_WITH_CNT LOOP
		v_SQL_STMT :=  v_SQL_STMT || '                 ATTR_' || LPAD(I, 2, '0') || '.END_DATE ' ||
					  CASE WHEN I < p_WITH_CNT THEN ',' || c_CRLF  ELSE ') AS END_DATE, ' || c_CRLF END;
	END LOOP;

	-- Still in "SELECT" prologue with other columns from ATTR_01...ATTR_nn
	v_SELECT_STMT := v_SELECT_STMT || v_SQL_STMT;
	v_SQL_STMT := '';
	FOR I IN 1..p_WITH_CNT LOOP
		v_SQL_STMT :=  v_SQL_STMT || '        ATTR_'|| LPAD(I, 2, '0') ||'.ATTRIBUTE_NAME AS ATTR_NAME_'|| LPAD(I, 2, '0') ||', ' || c_CRLF ||
					  '        ATTR_'|| LPAD(I, 2, '0') ||'.ATTRIBUTE_VAL AS ATTR_VAL_'|| LPAD(I, 2, '0') ||
					  CASE WHEN I < p_WITH_CNT THEN ',' || c_CRLF  ELSE c_CRLF END;
	END LOOP;

	v_SELECT_STMT := v_SELECT_STMT || v_SQL_STMT;

	-- Now to the "FROM" clause for the "SELECT" -- SET 2 -- CASE STATEMENT
	v_SQL_STMT := '' || '   FROM ACCOUNT A' || CASE WHEN b_ACCOUNT_FILTER_SEL OR p_WITH_CNT > 0   THEN ',' ELSE '' END ||c_CRLF;
	IF b_ACCOUNT_FILTER_SEL THEN
		v_SQL_STMT :=  v_SQL_STMT || '        LOAD_SEG_DEF_DTLS_ATTR_VALUES B' ||
				  	   CASE WHEN p_WITH_CNT > 0 THEN ',' ELSE '' END ||c_CRLF;
	END IF;

	FOR I IN 1..p_WITH_CNT LOOP
		v_SQL_STMT :=  v_SQL_STMT || '        ATTR_'|| LPAD(I, 2, '0') || CASE WHEN I < p_WITH_CNT THEN ',' || c_CRLF  ELSE c_CRLF END;
	END LOOP;

	v_SELECT_STMT := v_SELECT_STMT || v_SQL_STMT;

	-- Now to the "WHERE" clause after the "FROM" clause for the "SELECT" statement
	v_SQL_STMT := ' WHERE A.ACCOUNT_MODEL_OPTION IN ('''||ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_ACCOUNT||''','||c_CRLF||
				  '                                '''||ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_METER||''') '||c_CRLF ||
				  '   AND A.MODEL_ID = ' || GA.DEFAULT_MODEL || c_CRLF ||
				  CASE WHEN b_ACCOUNT_FILTER_SEL THEN
					  ' AND 	B.ATTRIBUTE_ID = ' || p_ATTRIBUTE_ID_SUB_AGG_ACCT || c_CRLF ||
					  ' AND	  	B.REPORT_ID = ' || p_REPORT_ID || c_CRLF ||
					  ' AND		B.ATTRIBUTE_VALUE = ' || CASE p_USE_ACCOUNT_NAMES
																WHEN 'TRUE' THEN
																	'A.ACCOUNT_NAME'||c_CRLF
														 ELSE
																	'A.ACCOUNT_EXTERNAL_IDENTIFIER'||c_CRLF
														 END
				  END ||
				  CASE WHEN p_WITH_CNT > 0 THEN ' AND A.ACCOUNT_ID = ATTR_01.ACCOUNT_ID'||c_CRLF
				       ELSE '' END;

	v_SQL_STMT :=  v_SQL_STMT || CASE WHEN p_WITH_CNT = 1 THEN ' AND A.ACCOUNT_ID = ATTR_01.ACCOUNT_ID'||c_CRLF ||
															   ' AND ATTR_01.BEGIN_DATE <= '|| v_STR_ADJ_END_DATE ||c_CRLF||
															   ' AND ATTR_01.END_DATE   >= '|| v_STR_ADJ_BEGIN_DATE || c_CRLF
									  WHEN p_WITH_CNT > 1 THEN I_GET_ITER_JOIN_STR(p_WITH_CNT)
								 END;


	v_SELECT_STMT := v_SELECT_STMT || v_SQL_STMT;

	RETURN v_SELECT_STMT;
END RLSR_GET_NDS_ACCT_TMP_SEL_STMT;
-------------------------------------------------------------------------------
PROCEDURE RLSR_RAISE_WARN_FOR_ACCTS
(
	p_REPORT_ID 		IN NUMBER,
	p_USE_ACCOUNT_NAMES IN VARCHAR2)
IS
	v_WARN_MSG                  VARCHAR2(2000) := NULL;
	c_PROCEDURE_NAME CONSTANT VARCHAR2(30) := 'RLSR_RAISE_WARN_FOR_ACCTS';
	c_PROC_NAME	CONSTANT VARCHAR2(61) := c_PACKAGE_NAME || '.' || c_PROCEDURE_NAME;
BEGIN
	FOR cREC IN (SELECT LSDDAV.ATTRIBUTE_VALUE AS ATTRIBUTE_VALUE,
					    EA.ATTRIBUTE_NAME      AS ATTRIBUTE_NAME
				  FROM LOAD_SEG_DEF_DTLS_ATTR_VALUES LSDDAV,
					   ENTITY_ATTRIBUTE EA
				 WHERE LSDDAV.REPORT_ID = p_REPORT_ID
				   AND LSDDAV.ATTRIBUTE_ID <> g_ENTITY_ATTR_ACCOUNT -- Don't check Account Attribute
				AND EA.ENTITY_DOMAIN_ID = EC.ED_ACCOUNT
				AND EA.ATTRIBUTE_ID = LSDDAV.ATTRIBUTE_ID
				AND NOT EXISTS (SELECT NULL
								  FROM TEMPORAL_ENTITY_ATTRIBUTE TEA
								 WHERE TEA.ATTRIBUTE_ID     = LSDDAV.ATTRIBUTE_ID
								   AND TEA.ENTITY_DOMAIN_ID = EC.ED_ACCOUNT
								   AND TEA.ATTRIBUTE_VAL    = LSDDAV.ATTRIBUTE_VALUE)
			  ) LOOP
	v_WARN_MSG := cREC.ATTRIBUTE_VALUE||' is selected for '||cREC.ATTRIBUTE_NAME||' but has no associated accounts.';
	LOGS.LOG_WARN(p_EVENT_TEXT => v_WARN_MSG,
				p_PROCEDURE_NAME => c_PROC_NAME,
				p_STEP_NAME => '(2)');
	END LOOP;

	LOGS.LOG_DEBUG_DETAIL(p_EVENT_TEXT => 'Check for sub-aggregate attributes that have been selected, but the values no longer exist.',
					  p_PROCEDURE_NAME => c_PROC_NAME,
					  p_STEP_NAME => '(3)');

	FOR cREC IN (SELECT LSDDAV.ATTRIBUTE_VALUE AS ATTRIBUTE_VALUE,
					EA.ATTRIBUTE_NAME      AS ATTRIBUTE_NAME
			   FROM LOAD_SEG_DEF_DTLS_ATTR_VALUES LSDDAV,
					ENTITY_ATTRIBUTE EA
			  WHERE LSDDAV.REPORT_ID = p_REPORT_ID
				AND LSDDAV.ATTRIBUTE_ID = g_ENTITY_ATTR_ACCOUNT
				AND EA.ENTITY_DOMAIN_ID = EC.ED_ACCOUNT
				AND EA.ATTRIBUTE_ID = LSDDAV.ATTRIBUTE_ID
				AND NOT EXISTS (SELECT NULL
								  FROM ACCOUNT        A
								 WHERE CASE p_USE_ACCOUNT_NAMES
										  WHEN 'TRUE' THEN
											 A.ACCOUNT_NAME
										  ELSE
											 A.ACCOUNT_EXTERNAL_IDENTIFIER
									   END = LSDDAV.ATTRIBUTE_VALUE)
			  ) LOOP
	v_WARN_MSG := cREC.ATTRIBUTE_VALUE||' is selected for '||cREC.ATTRIBUTE_NAME||' but is not an active account.';
	LOGS.LOG_WARN(p_EVENT_TEXT => v_WARN_MSG,
				p_PROCEDURE_NAME => c_PROC_NAME,
				p_STEP_NAME => '(4)');
	END LOOP;
END RLSR_RAISE_WARN_FOR_ACCTS;
-------------------------------------------------------------------------------
PROCEDURE RLSR_RAISE_WARN_FOR_ATTS (p_REPORT_ID IN NUMBER) AS
BEGIN
	FOR cREC IN (SELECT EA.ATTRIBUTE_NAME AS ATTRIBUTE_NAME
				   FROM ENTITY_ATTRIBUTE EA,
					    LOAD_SEGMENTATION_DEF_DETAILS LSDD
				  WHERE LSDD.REPORT_ID = p_REPORT_ID
					AND LSDD.ATTRIBUTE_ID = EA.ATTRIBUTE_ID
					AND EA.ATTRIBUTE_NAME <> c_ACCOUNT
					AND EA.ENTITY_DOMAIN_ID = EC.ED_ACCOUNT
				    AND (LSDD.SEGMENT_BY = 1 OR EXISTS(SELECT 1
														 FROM LOAD_SEG_DEF_DTLS_ATTR_VALUES LSDDAV
														WHERE LSDDAV.REPORT_ID = LSDD.REPORT_ID
														  AND LSDDAV.ATTRIBUTE_ID = LSDD.ATTRIBUTE_ID))
					AND NOT EXISTS(SELECT 1
									 FROM SYSTEM_DICTIONARY SD
									WHERE SD.MODEL_ID = CONSTANTS.GLOBAL_MODEL
									  AND SD.MODULE = c_LOAD_MANAGEMENT_MOD
									  AND SD.KEY1   = c_ACCOUNT_SYNC_OPTION
									  AND SD.KEY2   = c_CUSTOM_ATTRIBUTES
									  AND SD.VALUE  = EA.ATTRIBUTE_NAME)
				 ) LOOP
		LOGS.LOG_WARN(cREC.ATTRIBUTE_NAME||' was included in the configuration but is not defined in the system and will be ignored.');
	END LOOP;
END RLSR_RAISE_WARN_FOR_ATTS;
-------------------------------------------------------------------------------
-- This function will populate the staging table LOAD_SEG_ACCOUNTS_TMP with the
-- list of ACCOUNTs that meet the load segmentation report criteria.
-------------------------------------------------------------------------------
PROCEDURE FIND_ACCOUNTS_FOR_REPORT (
  p_PROCESS_ID  IN NUMBER,
  p_REPORT_ID   IN NUMBER,
  p_ADJ_BEGIN_DATE  IN DATE,
  p_ADJ_END_DATE    IN DATE,
  p_LSRRH_REC   	IN OUT NOCOPY LOAD_SEG_REPORT_RUN_HEADER%ROWTYPE
  )
AS
   -- Get a record type for the REF CURSOR
   v_SEG_DTLS_ATT_NAMES 		t_STR_TBL := t_STR_TBL();
   v_SEG_DTLS_ATT_ORDER_NAMES 	t_STR_TBL := t_STR_TBL();
   v_SEG_DTLS_ATTRIBUTE_IDS		t_NUMBER_TBL := t_NUMBER_TBL();
   v_SEG_DTLS_ORIG_FILTER_SELS 	t_STR_TBL := t_STR_TBL();
   v_SEG_DTLS_FILTER_SELS 		t_STR_TBL := t_STR_TBL();
   v_SEG_DTLS_SEG_BYS 			t_NUMBER_TBL := t_NUMBER_TBL();

   v_SEG_BYS_RESULT				t_NUMBER_TBL := t_NUMBER_TBL();
   v_FILTER_SELS_RESULT			t_STR_TBL := t_STR_TBL();

   v_SEG_DTLS_SEG_BYS_MASK		t_NUMBER_TBL := t_NUMBER_TBL(1);
   v_SEG_DTLS_FILTER_SELS_MASK	t_STR_TBL	 := t_STR_TBL(c_SELECTIONS_MADE);

    v_SEG_BY_FILTER_BY_INDEXES	t_NUMBER_TBL := t_NUMBER_TBL();

   c_PROCEDURE_NAME   CONSTANT VARCHAR2(30) := 'FIND_ACCOUNTS_FOR_REPORT';
   v_WITH_CNT                  PLS_INTEGER  := 0;
   v_ATTR_CNT                  PLS_INTEGER  := 0;

   b_IS_SEGMENT_BY            BOOLEAN  := FALSE;
   b_IS_FILTER_SELECTION      BOOLEAN  := FALSE;

   v_INS_STMT                  VARCHAR2(32000) := NULL;
   v_WITH_STMT                 VARCHAR2(32000) := NULL;
   v_SELECT_STMT               VARCHAR2(32000) := NULL;

   v_USE_ACCOUNT_NAMES         VARCHAR2(5) := NULL;

   v_CLOB_CONTENTS             CLOB := EMPTY_CLOB();
   v_CURSOR					   GA.REFCURSOR;

   v_NDS_LOAD_SEG_HEADER	   VARCHAR2(4000);
   c_PROC_NAME	CONSTANT VARCHAR2(61) := c_PACKAGE_NAME || '.' || c_PROCEDURE_NAME;

   v_STR_ADJ_BEGIN_DATE VARCHAR2(128) :=  ':BEGIN_DATE';
   v_STR_ADJ_END_DATE VARCHAR2(128)   :=  ':END_DATE';
   v_STR_HIGH_DATE VARCHAR2(128)  	  :=  ':HIGH_DATE';

   ---------------------------------------------------------------------------------------------------------------------
   FUNCTION GET_NDS_LOAD_SEG_HEADER
   (
   		p_NAMES		t_STR_TBL,
		p_SEG_BYS 	t_NUMBER_TBL
	)RETURN VARCHAR2
	IS
		 v_STR VARCHAR2(1000);
	BEGIN
		v_STR := 'UPDATE LOAD_SEG_REPORT_RUN_HEADER LSRRH ' || c_CRLF || 'SET ';
		FOR I IN 1..p_NAMES.COUNT LOOP
		 IF I = 1 THEN
			v_STR := v_STR || 'LSRRH.ACCOUNT_IDENT_ATTR  =  ''' || p_NAMES(I) ||
					 -- || SUBSTR(p_NAMES(I), INSTR(p_NAMES(I), 'Account', 1))||
					 ''', ' ||
				  ' LSRRH.ACCOUNT_IDENT_SEG_BY = ' || p_SEG_BYS(I) || CASE WHEN I < p_NAMES.COUNT THEN ',' ELSE NULL END
				  || c_CRLF;
		 ELSE
			v_STR := v_STR || 'LSRRH.ATTR_NAME_' || LPAD(I-1, 2, '0') ||'  =  ''' || p_NAMES(I) || ''', ' ||
				  ' LSRRH.ATTR_'|| LPAD(I-1, 2, '0') ||'_SEG_BY = ' || p_SEG_BYS(I) ||
				  CASE WHEN I < p_NAMES.COUNT THEN ',' ELSE NULL END || c_CRLF;
		 END IF;
		END LOOP;

		v_STR := v_STR ||'WHERE LSRRH.PROCESS_ID = :p_PROCESS_ID ' || c_CRLF || 'AND LSRRH.REPORT_ID  = :p_REPORT_ID';

		RETURN v_STR;
	END GET_NDS_LOAD_SEG_HEADER;
	--------------------------------------------------------------------------------------------------------------------
BEGIN
   LOGS.LOG_DEBUG_DETAIL(c_PROC_NAME||' BEGIN...',
                         p_STEP_NAME => '(0)');

   -- If the report configuration has Segment By checked for Account,
   -- the key field value depends on the System Setting for
   -- Global -> System -> GA Settings -> General -> Ensure Unique Names:
   --    ** If the flag is set to TRUE, then the key field value is the account name.
   --    ** If the flag is set to FALSE, the key field value is the account external identifier.
   -- Booleans is not a valid SQL type and therefore it is unable to be used in that form.
   -- Converting the boolean to a string representation will allow the value to be translated as per
   -- coding constructs for the product while still being able to be used in the code.
   v_USE_ACCOUNT_NAMES := TEXT_UTIL.TO_CHAR_BOOLEAN(p_BOOLEAN =>
                                                    UT.BOOLEAN_FROM_STRING(p_STRING =>
                                                                           UPPER(GET_DICTIONARY_VALUE('Enforce Unique Names',
                                                                                                      GA.DEFAULT_MODEL,
                                                                                                      'System',
                                                                                                      'GA Settings',
                                                                                                      'General',
                                                                                                      '?',
                                                                                                      0)--GET_DICTIONARY_VALUE
                                                                                 )--UPPER
                                                                             )--UT.BOOLEAN_FROM_STRING
                                                      );--TEXT_UTIL.TO_CHAR_BOOLEAN

   -- Refactored proc
   LOGS.LOG_DEBUG_DETAIL(p_EVENT_TEXT => 'Check for attributes that have been selected, but the values no longer exist.',
                         p_PROCEDURE_NAME => c_PROC_NAME,
                         p_STEP_NAME => '(1)');
   RLSR_RAISE_WARN_FOR_ACCTS(p_REPORT_ID, v_USE_ACCOUNT_NAMES);

   RLSR_RAISE_WARN_FOR_ATTS(p_REPORT_ID);

   -- Get the Attribute Def Details screen output
   GET_LOAD_SEGMENTATION_DEF_DTLS(p_REPORT_ID, v_CURSOR);
   FETCH v_CURSOR
   BULK COLLECT INTO v_SEG_DTLS_ATT_NAMES, v_SEG_DTLS_ATT_ORDER_NAMES, v_SEG_DTLS_ATTRIBUTE_IDS,
   					 v_SEG_DTLS_ORIG_FILTER_SELS, v_SEG_DTLS_FILTER_SELS, v_SEG_DTLS_SEG_BYS;
   CLOSE v_CURSOR;

   -- Capture the filtered-by and segment-by
   v_SEG_BYS_RESULT 	:= v_SEG_DTLS_SEG_BYS_MASK MULTISET INTERSECT v_SEG_DTLS_SEG_BYS;
   v_FILTER_SELS_RESULT := v_SEG_DTLS_FILTER_SELS_MASK MULTISET INTERSECT v_SEG_DTLS_FILTER_SELS;
   b_IS_SEGMENT_BY := CASE WHEN v_SEG_BYS_RESULT.COUNT > 0 THEN TRUE ELSE FALSE END;
   b_IS_FILTER_SELECTION := CASE WHEN v_FILTER_SELS_RESULT.COUNT > 0 THEN TRUE ELSE FALSE END;

   -- If NO filter-by and NO segment-by
   IF (NOT b_IS_SEGMENT_BY)  AND (NOT b_IS_FILTER_SELECTION) THEN
      LOGS.LOG_DEBUG_DETAIL(p_EVENT_TEXT => 'Getting all accounts, no segment by and no filter selection made.',
                            p_PROCEDURE_NAME => c_PROC_NAME,
                            p_STEP_NAME => '(5)');

      INSERT INTO LOAD_SEG_ACCOUNTS_TMP (PROCESS_ID,
                                         REPORT_ID,
                                         ACCOUNT_ID,
                                         ACCOUNT_MODEL_OPTION,
                                         ACCOUNT_IDENT,
                                         IS_SUB_AGGREGATE,
                                         BEGIN_DATE,
                                         END_DATE)
        -- Account Modeled Sub-Aggregate accounts and
        -- Meter Modeled Sub-Aggregate accounts ----------------
        SELECT p_PROCESS_ID                  AS PROCESS_ID,
               p_REPORT_ID                   AS REPORT_ID,
               A.ACCOUNT_ID                  AS ACCOUNT_ID,
               A.ACCOUNT_MODEL_OPTION        AS ACCOUNT_MODEL_OPTION,
               (CASE v_USE_ACCOUNT_NAMES
                   WHEN 'TRUE' THEN
                     A.ACCOUNT_NAME
                   ELSE
                     A.ACCOUNT_EXTERNAL_IDENTIFIER
               END)                          AS ACCOUNT_IDENT,
               A.IS_SUB_AGGREGATE            AS IS_SUB_AGGREGATE,
               p_ADJ_BEGIN_DATE            	 AS BEGIN_DATE,
               p_ADJ_END_DATE			 	 AS END_DATE
          FROM ACCOUNT         A
         WHERE A.ACCOUNT_MODEL_OPTION IN (ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_ACCOUNT,
                                          ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_METER)
		   AND A.MODEL_ID = GA.DEFAULT_MODEL;
   ELSE -- IF b_IS_SEGMENT_BY IS TRUE

     LOGS.LOG_DEBUG_DETAIL(p_EVENT_TEXT => 'Getting accounts based on segment by and filter selection made.',
                           p_PROCEDURE_NAME => c_PROC_NAME,
                           p_STEP_NAME => '(6)');

     -- Find the max count of segment/filter attributes since those affect the dynamic sql statement
     -- Also update the report head with the attributes and if there is grouping or not.
	 -- No FOR LOOP is required. So removing it.
	FOR I IN 2..v_SEG_DTLS_SEG_BYS.COUNT LOOP -- SET 2
		IF v_SEG_DTLS_SEG_BYS(i) = 1 OR v_SEG_DTLS_FILTER_SELS(I) = c_SELECTIONS_MADE THEN
			v_WITH_CNT := v_WITH_CNT + 1;
			v_SEG_BY_FILTER_BY_INDEXES.EXTEND(1);
			-- This is the index ordinal position "lexically" where either filter-by or segement-by is in vogue
			v_SEG_BY_FILTER_BY_INDEXES(v_SEG_BY_FILTER_BY_INDEXES.COUNT) := I;
		END IF;
	END LOOP;

	-- Replaced the UPDATE statement to LOAD_SEG_REPORT_RUN_HEADER with a NDS call
	v_NDS_LOAD_SEG_HEADER := GET_NDS_LOAD_SEG_HEADER(v_SEG_DTLS_ATT_NAMES, v_SEG_DTLS_SEG_BYS);
	LOGS.LOG_DEBUG('NDS: for UPDATE to LOAD_SEG_REPORT_RUN_HEADER: ' || v_NDS_LOAD_SEG_HEADER, c_PROC_NAME);
	EXECUTE IMMEDIATE v_NDS_LOAD_SEG_HEADER
    USING p_PROCESS_ID, p_REPORT_ID;

	SELECT A.*
	INTO p_LSRRH_REC
	FROM LOAD_SEG_REPORT_RUN_HEADER A
	WHERE A.PROCESS_ID = p_PROCESS_ID
	AND   A.REPORT_ID  = p_REPORT_ID;



    v_INS_STMT := 'INSERT INTO LOAD_SEG_ACCOUNTS_TMP(PROCESS_ID '||c_CRLF
                                                  ||',REPORT_ID '||c_CRLF
                                                  ||',ACCOUNT_ID '||c_CRLF
                                                  ||',ACCOUNT_MODEL_OPTION '||c_CRLF
                                                  ||',ACCOUNT_IDENT '||c_CRLF
                                                  ||',IS_SUB_AGGREGATE '||c_CRLF
                                                  ||',BEGIN_DATE '||c_CRLF
                                                  ||',END_DATE'|| CASE WHEN v_WITH_CNT > 0 THEN ',' ELSE '' END || c_CRLF||
                                                  RLSR_GET_NDS_ATTR_NAME_VAL(v_SEG_BY_FILTER_BY_INDEXES); -- replace

	v_CLOB_CONTENTS := v_INS_STMT;
	LOGS.LOG_INFO_MORE_DETAIL(p_EVENT_TEXT => 'Posting Dynamic SQL Statement as CLOB…',
							  p_PROCEDURE_NAME => c_PROC_NAME,
							  p_STEP_NAME => '(7) Dynamic SQL v_INS_STMT.');
	LOGS.POST_EVENT_DETAILS(p_DETAIL_TYPE => 'Dynamic SQL v_INS_STMT',
							p_CONTENT_TYPE => CONSTANTS.MIME_TYPE_TEXT,
							p_CONTENTS => v_CLOB_CONTENTS);


	-- Completely refactored the SELECT statement -- Also pass if "Sub-Aggregation Account" has filtered by
	v_SELECT_STMT := RLSR_GET_NDS_ACCT_TMP_SEL_STMT(p_PROCESS_ID, p_REPORT_ID,
												    v_WITH_CNT,v_USE_ACCOUNT_NAMES, v_SEG_DTLS_FILTER_SELS(1),
												    v_SEG_DTLS_ATTRIBUTE_IDS(1));

     IF LOGS.IS_DEBUG_ENABLED THEN
        v_CLOB_CONTENTS := v_SELECT_STMT;
        LOGS.LOG_INFO_MORE_DETAIL(p_EVENT_TEXT => 'Posting Dynamic SQL Statement as CLOB…',
                                  p_PROCEDURE_NAME => c_PROC_NAME,
                                  p_STEP_NAME => '(8) Dynamic SQL v_SELECT_STMT.');
        LOGS.POST_EVENT_DETAILS(p_DETAIL_TYPE => 'Dynamic SQL v_SELECT_STMT',
                                p_CONTENT_TYPE => CONSTANTS.MIME_TYPE_TEXT,
                                p_CONTENTS => v_CLOB_CONTENTS);
     END IF;

	 -- Completely replace v_ATTR_LIST_TBL structure with parallel collections using F36.U01 API
     LOGS.LOG_INFO(p_EVENT_TEXT => 'Generation of the v_WITH_STMT clause. LOAD_SEG_DEF_DTLS.COUNT =' || v_SEG_DTLS_ATTRIBUTE_IDS.COUNT,
                    p_PROCEDURE_NAME => c_PROC_NAME,
                    p_STEP_NAME => '(9)');

     v_WITH_STMT := '';
     v_ATTR_CNT  := 0;
     FOR j IN 2..v_SEG_DTLS_ATTRIBUTE_IDS.COUNT  LOOP  -- SET 2
	 	-- Replaced with c_SELECTIONS_MADE
       IF v_SEG_DTLS_SEG_BYS(j) = c_TRUE_FLG OR v_SEG_DTLS_FILTER_SELS(J) = c_SELECTIONS_MADE THEN
         LOGS.LOG_DEBUG_MORE_DETAIL(p_EVENT_TEXT => 'ATTRIBUTE_NAME = '|| v_SEG_DTLS_ATT_NAMES(J) || c_CRLF ||
                                                    'ATTRIBUTE_ID = '|| v_SEG_DTLS_ATTRIBUTE_IDS(J) || c_CRLF||
                                                    'FILTER_SELECTION = '|| v_SEG_DTLS_FILTER_SELS(J)|| c_CRLF||
                                                    'SEGMENT_BY = '|| v_SEG_DTLS_SEG_BYS(j) || c_CRLF,
                                    p_PROCEDURE_NAME => c_PROC_NAME,
                                    p_STEP_NAME => '(10) LOAD_SEG_DEF_DTLS LOOP COUNTER = '|| J );

        -- For the sub-aggregate custom attribute the values come directly from a query against
        -- ACCOUNT and ACCOUNT_STATUS.  While all the other custom attributes values are contained
        -- within the TEMPORAL_ENTITY_ATTRIBUTE table. Therefore the each has its own query set.
	  ---------------------------------------------------------------------------------------------------------
	  -- Section for all other custom attributes exception sub-aggregate account attribute.
	  ---------------------------------------------------------------------------------------------------------
	  LOGS.LOG_DEBUG_MORE_DETAIL(p_EVENT_TEXT => 'Section for all other custom attributes exception sub-aggregate account attribute.',
								 p_PROCEDURE_NAME => c_PROC_NAME,
								 p_STEP_NAME => '(10-6)');

		  -- With no selections made and segmenting by on the same attribute, an outer join has to be done to get all
		  -- the accounts that do not have the attribute defined within the TEMPORAL_ENTITY_ATTRIBUTE table. Otherwise
		  -- its a simple query.
		  CASE
			  WHEN v_SEG_DTLS_FILTER_SELS(J) = CONSTANTS.ALL_STRING AND v_SEG_DTLS_SEG_BYS(J) = c_TRUE_FLG THEN
				-- 1: No Selections Made and Yes Segment By
				 LOGS.LOG_DEBUG_MORE_DETAIL(p_EVENT_TEXT => '1: No Selections Made and Yes Segment By'||c_CRLF||
												'v_ATTR_LIST_TBL('||TO_CHAR(j)||').FILTER_SELECTION = '||TO_CHAR(v_SEG_DTLS_FILTER_SELS(J))||c_CRLF||
												'v_ATTR_LIST_TBL('||TO_CHAR(j)||').SEGMENT_BY = '||TO_CHAR(v_SEG_DTLS_SEG_BYS(J))||c_CRLF,
											p_PROCEDURE_NAME => c_PROC_NAME,
											p_STEP_NAME => '(10-7)');

				v_ATTR_CNT := v_ATTR_CNT + 1;
				IF v_ATTR_CNT = 1 THEN
				  -- FIRST ATTRIBUTE, this is the only one that needs the WITH prefix
				  -- Fixed the mysterious comma bug that kept NDS fail fatally
					v_WITH_STMT := v_WITH_STMT || 'WITH ATTR_';
				ELSE
					v_WITH_STMT := v_WITH_STMT || '),' || c_CRLF || ' ATTR_';
				END IF;--IF v_ATTR_CNT = 1 THEN
				v_WITH_STMT := v_WITH_STMT ||LPAD(TO_CHAR(v_ATTR_CNT),2,'0')||' AS ('||c_CRLF||
								 ' SELECT ATL.ACCOUNT_ID,'||c_CRLF||
										 ' ATL.ATTRIBUTE_ID,'||c_CRLF||
										 ' ATL.ENTITY_DOMAIN_ID,'||c_CRLF||
										 ' ATL.ATTRIBUTE_NAME,'||c_CRLF||
										 ' MAX(ATL.ATTRIBUTE_VAL) AS ATTRIBUTE_VAL,'||c_CRLF||
										 ' ATL.BEGIN_DATE AS BEGIN_DATE,'||c_CRLF||
										 ' NVL(ATL.END_DATE, '||v_STR_HIGH_DATE||')  AS END_DATE'||c_CRLF||
								 ' FROM  '||c_CRLF||
								 ' ( '||c_CRLF||
								 ' SELECT B.ACCOUNT_ID, SQ.ATTRIBUTE_ID, NVL(SQ.ENTITY_DOMAIN_ID, ' || EC.ED_ACCOUNT ||
								 '        ) ENTITY_DOMAIN_ID, NVL(SQ.ATTRIBUTE_NAME, ''' || v_SEG_DTLS_ATT_NAMES(J) ||
								 ''') ATTRIBUTE_NAME, SQ.ATTRIBUTE_VAL, NVL(BEGIN_DATE, ' || v_STR_ADJ_BEGIN_DATE ||
								 ') BEGIN_DATE, NVL(END_DATE, ' || v_STR_ADJ_END_DATE || ') END_DATE' || c_CRLF||
								 'FROM ' || c_CRLF ||
								 ' ( ' || c_CRLF ||
								 '    SELECT A.* FROM ' || c_CRLF ||
								 '     ( ' || c_CRLF ||
								 ' 		SELECT DISTINCT TEA.OWNER_ENTITY_ID									AS ACCOUNT_ID,'||c_CRLF||
								 '        (CASE WHEN C.SWTCH = 0 THEN TEA.ATTRIBUTE_ID ELSE NULL END)      	AS ATTRIBUTE_ID,'||c_CRLF||
								 '        TEA.ENTITY_DOMAIN_ID  											AS ENTITY_DOMAIN_ID,'||c_CRLF||
								 '        (CASE WHEN C.SWTCH = 0 THEN TEA.ATTRIBUTE_NAME ELSE NULL END) 	AS ATTRIBUTE_NAME,'||c_CRLF||
								 '        (CASE WHEN C.SWTCH = 0 THEN TEA.ATTRIBUTE_VAL ELSE NULL END)    	AS ATTRIBUTE_VAL,'||c_CRLF||
								 '        NVL((CASE WHEN C.SWTCH = -1 THEN LAG(CASE WHEN END_DATE = ' || v_STR_HIGH_DATE || ' THEN NULL ELSE END_DATE + 1 END, 1, NULL) ' || c_CRLF ||
								 '										   OVER (PARTITION BY TEA.OWNER_ENTITY_ID ORDER BY TEA.OWNER_ENTITY_ID, BEGIN_DATE, END_DATE, C.SWTCH)' || c_CRLF ||
								 '					WHEN C.SWTCH = 0 THEN BEGIN_DATE  /* SWITCH = 0, THE ACTUAL ASSIGNMENT ROW */ ' || c_CRLF ||
								 '					ELSE NVL(LEAST(END_DATE, ' || v_STR_HIGH_DATE || ' - 1), ' || v_STR_ADJ_END_DATE ||') + 1 END), ' || v_STR_ADJ_BEGIN_DATE || ')   AS BEGIN_DATE,'||c_CRLF||
								 '        NVL((CASE WHEN C.SWTCH = -1 THEN BEGIN_DATE-1 ' || c_CRLF ||
								 '					WHEN C.SWTCH = 0  THEN LEAST(END_DATE, ' || v_STR_ADJ_END_DATE || ')' || c_CRLF ||
								 '		  			ELSE LEAD(BEGIN_DATE-1, 1, NULL)  ' || c_CRLF ||
								 '						 OVER (PARTITION BY TEA.OWNER_ENTITY_ID ORDER BY TEA.OWNER_ENTITY_ID, BEGIN_DATE, END_DATE, C.SWTCH)' || c_CRLF ||
								 '			   END),' || v_STR_ADJ_END_DATE || ') AS END_DATE'||c_CRLF||
								 '   FROM TEMPORAL_ENTITY_ATTRIBUTE     TEA,'||c_CRLF||
								 '   	  ( SELECT -1 AS SWTCH FROM DUAL ' || c_CRLF ||
								 '			UNION ALL SELECT 0 AS SWTCH FROM DUAL ' || c_CRLF ||
								 '			UNION ALL SELECT 1 AS SWTCH FROM DUAL) C' || c_CRLF ||
								 '   WHERE TEA.ATTRIBUTE_ID = '||TO_CHAR(v_SEG_DTLS_ATTRIBUTE_IDS(J))||c_CRLF||
								 '    AND TEA.ENTITY_DOMAIN_ID = '||TO_CHAR(EC.ED_ACCOUNT)||c_CRLF||
								 '    AND TEA.BEGIN_DATE(+) <= '||v_STR_ADJ_END_DATE||c_CRLF||
								 '    AND NVL(TEA.END_DATE(+), '||v_STR_HIGH_DATE ||') >= '||v_STR_ADJ_BEGIN_DATE||c_CRLF||
								 ' 	) A ' || c_CRLF ||
								 'WHERE A.BEGIN_DATE <= A.END_DATE' || c_CRLF ||
								 ') SQ, ACCOUNT B ' || c_CRLF ||
								 'WHERE B.ACCOUNT_ID = SQ.ACCOUNT_ID (+) ' || c_CRLF ||
								') ATL '||c_CRLF||
								' GROUP BY ATL.ACCOUNT_ID, '||c_CRLF||
								'          ATL.ATTRIBUTE_ID, '||c_CRLF||
								'          ATL.ENTITY_DOMAIN_ID, '||c_CRLF||
								'          ATL.ATTRIBUTE_NAME, '||c_CRLF||
								'          ATL.BEGIN_DATE, '||c_CRLF||
								'          ATL.END_DATE '||c_CRLF;

				 LOGS.LOG_DEBUG_MORE_DETAIL(p_EVENT_TEXT => 'With STMT: ('||TO_CHAR(j)||')' ||c_CRLF||v_WITH_STMT,
											p_PROCEDURE_NAME => c_PROC_NAME,
											p_STEP_NAME => '(10-8) Step-'||TO_CHAR(j)||': '||v_SEG_DTLS_ATT_NAMES(J));

			  ELSE -- CASE
				-- 2: Yes Selections Made and No  Segment By
				-- 3: Yes Selections Made and Yes Segment By
				-- 4: No  Selections Made and No  Segment By
				 LOGS.LOG_DEBUG_MORE_DETAIL(p_EVENT_TEXT => ' NON-SUB AGGREGATION ACCOUNT CASE:' || c_CRLF ||
												'2: Yes Selections Made and No  Segment By'||c_CRLF||
												'3: Yes Selections Made and Yes Segment By'||c_CRLF||
												'4: No  Selections Made and No  Segment By'||c_CRLF||
												'v_ATTR_LIST_TBL('||TO_CHAR(j)||').FILTER_SELECTION = '||TO_CHAR(v_SEG_DTLS_FILTER_SELS(J))||c_CRLF||
												'v_ATTR_LIST_TBL('||TO_CHAR(j)||').SEGMENT_BY = '||TO_CHAR(v_SEG_DTLS_SEG_BYS(J))||c_CRLF,
								  p_PROCEDURE_NAME => c_PROC_NAME,
								  p_STEP_NAME => '(10-9)');

				v_ATTR_CNT := v_ATTR_CNT + 1;

				IF v_ATTR_CNT = 1 THEN
				  -- FIRST ATTRIBUTE, this is the only one that needs the WITH prefix
				  -- Fixed the mysterious comma bug that kept NDS fail fatally
					v_WITH_STMT := v_WITH_STMT || 'WITH ATTR_';
				ELSE
					v_WITH_STMT := v_WITH_STMT || '),' || c_CRLF || ' ATTR_';
				END IF;--IF v_ATTR_CNT = 1 THEN
				 LOGS.LOG_DEBUG_MORE_DETAIL(p_EVENT_TEXT => '--RSA -- 2011-09-20 -- PAST IF..ELSE..CLAUSE..');
				v_WITH_STMT := v_WITH_STMT ||LPAD(TO_CHAR(v_ATTR_CNT),2,'0')||' AS ('||c_CRLF||
								 ' SELECT TEA.OWNER_ENTITY_ID   AS ACCOUNT_ID,'||c_CRLF||
								 '        TEA.ATTRIBUTE_ID      AS ATTRIBUTE_ID,'||c_CRLF||
								 '        TEA.ENTITY_DOMAIN_ID  AS ENTITY_DOMAIN_ID,'||c_CRLF||
								 '        TEA.ATTRIBUTE_NAME    AS ATTRIBUTE_NAME,'||c_CRLF||
								 '        TEA.ATTRIBUTE_VAL     AS ATTRIBUTE_VAL,'||c_CRLF||
								 '        TEA.BEGIN_DATE        AS BEGIN_DATE,'||c_CRLF||
								 '        NVL(TEA.END_DATE, '||v_STR_HIGH_DATE||')  AS END_DATE'||c_CRLF||
								 '   FROM TEMPORAL_ENTITY_ATTRIBUTE     TEA,'||c_CRLF||
								 '        LOAD_SEG_DEF_DTLS_ATTR_VALUES LSDDAV'||c_CRLF||
								 '  WHERE TEA.ATTRIBUTE_ID = '||TO_CHAR(v_SEG_DTLS_ATTRIBUTE_IDS(J))||c_CRLF||
								 '    AND TEA.BEGIN_DATE <= '||v_STR_ADJ_END_DATE||c_CRLF||
								 '    AND TEA.ENTITY_DOMAIN_ID = '||TO_CHAR(EC.ED_ACCOUNT)||c_CRLF||
								 '    AND NVL(TEA.END_DATE, '||v_STR_HIGH_DATE
																		  ||') >= '||v_STR_ADJ_BEGIN_DATE||c_CRLF||
								 '    AND LSDDAV.REPORT_ID(+) = '||TO_CHAR(p_REPORT_ID)||c_CRLF||
								 '    AND LSDDAV.ATTRIBUTE_ID(+) = TEA.ATTRIBUTE_ID'||c_CRLF||
								 -- modify the block below
								 ( CASE
										 WHEN v_SEG_DTLS_FILTER_SELS(J) <> CONSTANTS.ALL_STRING THEN
											'    AND TEA.ATTRIBUTE_ID  = LSDDAV.ATTRIBUTE_ID'||c_CRLF||
											'    AND TEA.ATTRIBUTE_VAL = LSDDAV.ATTRIBUTE_VALUE'||c_CRLF
									 END);

				 LOGS.LOG_DEBUG_MORE_DETAIL(p_EVENT_TEXT => 'With STMT: ('||TO_CHAR(j)||')' ||c_CRLF||v_WITH_STMT,
											p_PROCEDURE_NAME => c_PROC_NAME,
											p_STEP_NAME => '(10-10) Step-'||TO_CHAR(j)||': '||v_SEG_DTLS_ATT_NAMES(J));
		  END CASE;



      END IF;--IF v_SEG_DTLS_SEG_BYS(J) = 1 OR v_SEG_DTLS_FILTER_SELS(J) = 1 THEN

     END LOOP;-- cREC

	-- Add the missing parenthesis
	v_WITH_STMT := CONCAT(v_WITH_STMT, ')' || c_CRLF);


	v_CLOB_CONTENTS := v_WITH_STMT;
	LOGS.LOG_INFO_MORE_DETAIL(p_EVENT_TEXT => 'Posting Dynamic SQL Statement as CLOB…',
							  p_PROCEDURE_NAME => c_PROC_NAME,
							  p_STEP_NAME => '(11) Dynamic SQL v_WITH_STMT.');
	LOGS.POST_EVENT_DETAILS(p_DETAIL_TYPE => 'Dynamic SQL v_WITH_STMT',
							p_CONTENT_TYPE => CONSTANTS.MIME_TYPE_TEXT,
							p_CONTENTS => v_CLOB_CONTENTS);


	v_CLOB_CONTENTS := 'DECLARE v_H DATE := ' || v_STR_HIGH_DATE || ';'    ||
							' v_B DATE := ' || v_STR_ADJ_BEGIN_DATE || ';' ||
							' v_E DATE := ' || v_STR_ADJ_END_DATE   || ';' ||
							'BEGIN   ' || v_INS_STMT ||v_WITH_STMT ||v_SELECT_STMT || ';' || ' END;';

	LOGS.LOG_INFO_MORE_DETAIL(p_EVENT_TEXT => 'Posting Dynamic SQL Statement as CLOB…',
							  p_PROCEDURE_NAME => c_PROC_NAME,
							  p_STEP_NAME => '(12) Before Execution of NDS.');

	LOGS.POST_EVENT_DETAILS(p_DETAIL_TYPE => 'Dynamic SQL Statement size = ' || (LENGTH(v_INS_STMT) + LENGTH(v_WITH_STMT) +
											  LENGTH(v_SELECT_STMT)),
							p_CONTENT_TYPE => CONSTANTS.MIME_TYPE_TEXT,
							p_CONTENTS => v_CLOB_CONTENTS);


     BEGIN

		EXECUTE IMMEDIATE ('DECLARE v_H DATE := ' || v_STR_HIGH_DATE || ';' ||
							' v_B DATE := ' || v_STR_ADJ_BEGIN_DATE || ';' ||
							' v_E DATE := ' || v_STR_ADJ_END_DATE   || ';' ||
							'BEGIN   ' || v_INS_STMT ||v_WITH_STMT ||v_SELECT_STMT || ';' || ' END;')
		USING CONSTANTS.HIGH_DATE, p_ADJ_BEGIN_DATE, p_ADJ_END_DATE;

     EXCEPTION
         WHEN OTHERS THEN
            ERRS.LOG_AND_RAISE(p_EXTRA_MESSAGE => 'Error during parsing or execution of dynamic SQL statement.',
                               p_PROCEDURE_NAME => c_PROC_NAME,
                               p_STEP_NAME => '(13) Exception handler of dynamic SQL execution.');
     END;

   END IF;--IF v_MAX_SEGMENT_BY = c_TRUE_FLG

   LOGS.LOG_DEBUG_DETAIL(c_PROC_NAME||'...END');
END FIND_ACCOUNTS_FOR_REPORT;
-------------------------------------------------------------------------------
-- This function will populate the staging table LOAD_SEG_AGG_ACCOUNTS_TMP with
-- the list of AGGREGATEs for the accounts already selected.
-------------------------------------------------------------------------------
PROCEDURE FIND_AGGREGATES_FOR_REPORT (
   p_PROCESS_ID     IN NUMBER,
   p_REPORT_ID      IN NUMBER,
   p_BEGIN_DATE     IN DATE,
   p_END_DATE       IN DATE,
   p_CUT_BEGIN_DATE IN DATE,
   p_CUT_END_DATE   IN DATE,
   p_TIME_ZONE      IN VARCHAR2,
   p_SERVICE_CODE   IN CHAR,
   p_SCENARIO_ID    IN NUMBER
  )
AS
   c_PROCEDURE_NAME   	CONSTANT VARCHAR2(30) := 'FIND_AGGREGATES_FOR_REPORT';
   c_PROC_NAME			CONSTANT VARCHAR2(61) := c_PACKAGE_NAME || '.' || c_PROCEDURE_NAME;
   v_AGG_ACCOUNT_IDS           NUMBER_COLLECTION := NUMBER_COLLECTION();
BEGIN
   LOGS.LOG_DEBUG_DETAIL(c_PROC_NAME||' BEGIN...',
                         p_PROCEDURE_NAME => c_PROC_NAME);

   LOGS.LOG_DEBUG_DETAIL(p_EVENT_TEXT => 'p_PROCESS_ID = '||to_char(p_PROCESS_ID)||c_CRLF||
                                         'p_REPORT_ID = '||to_char(p_REPORT_ID)||c_CRLF||
                                          'p_BEGIN_DATE = '||TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE)||c_CRLF||
                                          'p_END_DATE = '||TEXT_UTIL.TO_CHAR_DATE(p_END_DATE)||c_CRLF||
                                          'p_CUT_BEGIN_DATE = '||TEXT_UTIL.TO_CHAR_DATE(p_CUT_BEGIN_DATE)||c_CRLF||
                                          'p_CUT_END_DATE = '||TEXT_UTIL.TO_CHAR_DATE(p_CUT_END_DATE)||c_CRLF||
                                          'p_TIME_ZONE = '||p_TIME_ZONE||c_CRLF||
                                          'p_SERVICE_CODE = '||p_SERVICE_CODE||c_CRLF||
                                          'p_SCENARIO_ID = '||to_char(p_SCENARIO_ID)||c_CRLF,
                          p_PROCEDURE_NAME => c_PROC_NAME);


   LOGS.LOG_DEBUG_DETAIL(p_EVENT_TEXT => 'Getting aggregate accounts for the accounts already selected for the report.',
                         p_PROCEDURE_NAME => c_PROC_NAME);

   INSERT INTO LOAD_SEG_AGG_ACCOUNTS_TMP (PROCESS_ID,
                                          REPORT_ID,
                                          AGG_ACCOUNT_ID,
                                          ACCOUNT_ID,
                                          AGGREGATE_ID,
                                          AVG_USAGE_FACTOR,
                                          SUB_AGG_USAGE_FACTOR,
                                          MODEL_ID,
                                          SERVICE_ID,
                                          SERVICE_DATE,
                                          SERVICE_ACCOUNTS)
    -- Account Modeled Sub-Aggregate accounts ------------------------
	SELECT LSAT.PROCESS_ID      AS PROCESS_ID,
		   LSAT.REPORT_ID       AS REPORT_ID,
		   ASVR.ACCOUNT_ID      AS AGG_ACCOUNT_ID,
		   LSAT.ACCOUNT_ID      AS ACCOUNT_ID,
		   ASAA.AGGREGATE_ID    AS AGGREGATE_ID,
		   SS.USAGE_FACTOR      AS AVG_USAGE_FACTOR,
		   (SELECT AUF.FACTOR_VAL
		    FROM ACCOUNT_USAGE_FACTOR AUF
			WHERE AUF.ACCOUNT_ID = LSAT.ACCOUNT_ID
			  AND AUF.CASE_ID = GA.BASE_CASE_ID
			  AND SS.SERVICE_DATE BETWEEN AUF.BEGIN_DATE AND NVL(AUF.END_DATE, CONSTANTS.HIGH_DATE)
		   ) AS SUB_AGG_USAGE_FACTOR,
		   S.MODEL_ID           AS MODEL_ID,
		   S.SERVICE_ID         AS SERVICE_ID,
		   SS.SERVICE_DATE      AS SERVICE_DATE,
		   SS.SERVICE_ACCOUNTS  AS SERVICE_ACCOUNTS
	FROM  LOAD_SEG_ACCOUNTS_TMP       LSAT,
		  ACCOUNT_SERVICE             ASVR,
		  ACCOUNT_SUB_AGG_AGGREGATION ASAA,
		  SERVICE                     S,
		  SERVICE_STATE               SS
	WHERE LSAT.PROCESS_ID = p_PROCESS_ID
	  AND LSAT.REPORT_ID = p_REPORT_ID
	  AND LSAT.ACCOUNT_MODEL_OPTION = ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_ACCOUNT -- changed to ACCOUNT
	  AND LSAT.IS_SUB_AGGREGATE = 1
	  AND ASVR.AGGREGATE_ID = ASAA.AGGREGATE_ID
	  AND ASAA.ACCOUNT_ID = LSAT.ACCOUNT_ID
	  AND ASAA.BEGIN_DATE <= LSAT.END_DATE
	  AND NVL(ASAA.END_DATE, CONSTANTS.HIGH_DATE) >= LSAT.BEGIN_DATE
	  AND ASVR.ACCOUNT_SERVICE_ID = S.ACCOUNT_SERVICE_ID
	  AND S.AS_OF_DATE = CONSTANTS.LOW_DATE
	  AND S.SCENARIO_ID = p_SCENARIO_ID
	  AND S.MODEL_ID = GA.DEFAULT_MODEL
	  AND S.SERVICE_ID = SS.SERVICE_ID
	  AND SS.SERVICE_DATE BETWEEN GREATEST(LSAT.BEGIN_DATE, ASAA.BEGIN_DATE, p_BEGIN_DATE) AND LEAST (LSAT.END_DATE, ASAA.END_DATE, CONSTANTS.HIGH_DATE, p_END_DATE)
	  AND SS.SERVICE_CODE = p_SERVICE_CODE
    UNION
    -- Meter Modeled Sub-Aggregate accounts -------------------------
    SELECT LSAT.PROCESS_ID      AS PROCESS_ID,
		   LSAT.REPORT_ID       AS REPORT_ID,
		   ASVR.ACCOUNT_ID      AS AGG_ACCOUNT_ID,
		   LSAT.ACCOUNT_ID      AS ACCOUNT_ID,
		   MSAA.AGGREGATE_ID    AS AGGREGATE_ID,
		   SS.USAGE_FACTOR      AS AVG_USAGE_FACTOR,
		   (SELECT MUF.FACTOR_VAL
		    FROM METER_USAGE_FACTOR MUF
			WHERE MUF.METER_ID = SLM.METER_ID
			  AND MUF.CASE_ID = GA.BASE_CASE_ID
			  AND SS.SERVICE_DATE BETWEEN MUF.BEGIN_DATE AND NVL(MUF.END_DATE, CONSTANTS.HIGH_DATE)
		   ) AS SUB_AGG_USAGE_FACTOR,
		   S.MODEL_ID           AS MODEL_ID,
		   S.SERVICE_ID         AS SERVICE_ID,
		   SS.SERVICE_DATE      AS SERVICE_DATE,
		   SS.SERVICE_ACCOUNTS  AS SERVICE_ACCOUNTS
	FROM  LOAD_SEG_ACCOUNTS_TMP       LSAT,
		  ACCOUNT_SERVICE             ASVR,
		  METER_SUB_AGG_AGGREGATION   MSAA,
		  SERVICE_LOCATION_METER      SLM,
		  ACCOUNT_SERVICE_LOCATION    ASL,
		  SERVICE                     S,
		  SERVICE_STATE               SS
	WHERE LSAT.PROCESS_ID = p_PROCESS_ID
	  AND LSAT.REPORT_ID = p_REPORT_ID
	  AND LSAT.ACCOUNT_MODEL_OPTION = ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_METER
	  AND LSAT.IS_SUB_AGGREGATE = 1
	  AND ASVR.AGGREGATE_ID = MSAA.AGGREGATE_ID
	  AND MSAA.BEGIN_DATE <= LSAT.END_DATE
	  AND NVL(MSAA.END_DATE, CONSTANTS.HIGH_DATE) >= LSAT.BEGIN_DATE
	  AND MSAA.METER_ID = SLM.METER_ID
	  AND SLM.BEGIN_DATE <= LSAT.END_DATE
	  AND NVL(SLM.END_DATE, CONSTANTS.HIGH_DATE) >= LSAT.BEGIN_DATE
	  AND SLM.SERVICE_LOCATION_ID = ASL.SERVICE_LOCATION_ID
	  AND ASL.BEGIN_DATE <= LSAT.END_DATE
	  AND NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE) >= LSAT.BEGIN_DATE
	  AND ASL.ACCOUNT_ID = LSAT.ACCOUNT_ID
	  AND ASL.BEGIN_DATE <= LSAT.END_DATE
	  AND NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE) >= LSAT.BEGIN_DATE
	  AND ASVR.ACCOUNT_SERVICE_ID = S.ACCOUNT_SERVICE_ID
	  AND S.AS_OF_DATE = CONSTANTS.LOW_DATE
	  AND S.SCENARIO_ID = p_SCENARIO_ID
	  AND S.MODEL_ID = GA.DEFAULT_MODEL
	  AND S.SERVICE_ID = SS.SERVICE_ID
	  AND SS.SERVICE_DATE BETWEEN GREATEST(LSAT.BEGIN_DATE, MSAA.BEGIN_DATE, p_BEGIN_DATE) AND LEAST (LSAT.END_DATE,  MSAA.END_DATE, CONSTANTS.HIGH_DATE, p_END_DATE)
	  AND SS.SERVICE_CODE = p_SERVICE_CODE;

    LOGS.LOG_DEBUG_DETAIL(p_EVENT_TEXT => 'Call ENSURE_SERVICE_DETAILS for each AGGREGATE ID .',
                          p_PROCEDURE_NAME => c_PROC_NAME);

    SELECT DISTINCT LSAAT.AGG_ACCOUNT_ID
      BULK COLLECT INTO v_AGG_ACCOUNT_IDS
      FROM LOAD_SEG_AGG_ACCOUNTS_TMP LSAAT
     WHERE LSAAT.PROCESS_ID = p_PROCESS_ID
       AND LSAAT.REPORT_ID = p_REPORT_ID;

    FS.ENSURE_SERVICE_DETAILS(p_SERVICE_CODE,
                              GA.DEFAULT_MODEL,
                              p_SCENARIO_ID,
                              CONSTANTS.ALL_ID,
                              CONSTANTS.ALL_ID,
                              v_AGG_ACCOUNT_IDS,
                              p_CUT_BEGIN_DATE,
                              p_CUT_END_DATE,
                              CONSTANTS.LOW_DATE);

   LOGS.LOG_DEBUG_DETAIL(c_PROC_NAME||'...END');

END FIND_AGGREGATES_FOR_REPORT;
-----------------------------------------------------------------
FUNCTION DETERMINE_SDT_ROLLUP_COLUMN(p_INTERVAL IN VARCHAR2) RETURN VARCHAR2 DETERMINISTIC AS
v_SDT_ROLLUP_COLUMN  VARCHAR2(30);
BEGIN
 	-- Determine which SDT Date column to use for Rollup
    CASE p_INTERVAL
        WHEN CONSTANTS.INTERVAL_WEEK THEN
            v_SDT_ROLLUP_COLUMN := 'LOCAL_WEEK_TRUNC_DATE';
        WHEN CONSTANTS.INTERVAL_MONTH THEN
            v_SDT_ROLLUP_COLUMN := 'LOCAL_MONTH_TRUNC_DATE';
        WHEN CONSTANTS.INTERVAL_QUARTER THEN
            v_SDT_ROLLUP_COLUMN := 'LOCAL_QUARTER_TRUNC_DATE';
        WHEN CONSTANTS.INTERVAL_YEAR THEN
            v_SDT_ROLLUP_COLUMN := 'LOCAL_YEAR_TRUNC_DATE';
        ELSE
            v_SDT_ROLLUP_COLUMN := 'LOCAL_DAY_TRUNC_DATE';
    END CASE;

	RETURN v_SDT_ROLLUP_COLUMN;
END DETERMINE_SDT_ROLLUP_COLUMN;
-----------------------------------------------------------------
-- Returns a list of column names based on the 2 input parameters
-- p_SEG_BY_LIST - A collection of numbers, 1 or 0. The first slot contains flag if segmented by Account or not.
--                 We include an ATTR_VAL_## for each element = 1 in the collection.
-- p_PREFIX - An optional parameter, if we need a prefix before an item in the list. ie. prefix = 'TAB.', result = TAB.ATTR_VAL_01
-- p_REMOVE_LAST_COMMA - An optional parameter that specifies whether the last comma
-- p_SET_COLUMN_ALIAS - If Column alias should be set or not. Example(If flag is TRUE): ACCOUNT_IDENT AS ACCOUNT_IDENT
-----------------------------------------------------------------
FUNCTION REPORT_DATA_ATTRIB_STMT
	(
	p_SEG_BY_LIST 			IN NUMBER_COLLECTION,
	p_PREFIX 				IN VARCHAR2 DEFAULT NULL,
	p_REMOVE_LAST_COMMA 	IN BOOLEAN DEFAULT FALSE,
	p_SET_COLUMN_ALIAS		IN BOOLEAN DEFAULT FALSE
	) RETURN VARCHAR2 AS
v_ATTRIBUTE_LIST_STR VARCHAR2(1024);
v_STOP_POS NUMBER;
BEGIN
	IF p_SEG_BY_LIST(1) = 1 THEN -- Check if segmented by Account
		v_ATTRIBUTE_LIST_STR := p_PREFIX || 'ACCOUNT_IDENT';

		IF p_SET_COLUMN_ALIAS THEN
			v_ATTRIBUTE_LIST_STR := v_ATTRIBUTE_LIST_STR || '   AS ACCOUNT_IDENT';
		END IF;

		 v_ATTRIBUTE_LIST_STR := v_ATTRIBUTE_LIST_STR || ', ' || c_CRLF;
	END IF;

	FOR v_IDX IN 2..p_SEG_BY_LIST.COUNT LOOP
		IF p_SEG_BY_LIST(v_IDX) = 1 THEN
			v_ATTRIBUTE_LIST_STR := v_ATTRIBUTE_LIST_STR || p_PREFIX || 'ATTR_VAL_' || TO_CHAR(v_IDX - 1, 'FM00');

			IF p_SET_COLUMN_ALIAS THEN
				v_ATTRIBUTE_LIST_STR := v_ATTRIBUTE_LIST_STR || ' AS ATTR_VAL_' || TO_CHAR(v_IDX - 1, 'FM00');
			END IF;

			 v_ATTRIBUTE_LIST_STR := v_ATTRIBUTE_LIST_STR || ', ' || c_CRLF;
		END IF;
	END LOOP;

	IF p_REMOVE_LAST_COMMA THEN
		IF v_ATTRIBUTE_LIST_STR IS NOT NULL THEN
			v_STOP_POS := INSTR(v_ATTRIBUTE_LIST_STR, ',', -1, 1) - 1;
			v_ATTRIBUTE_LIST_STR := SUBSTR(v_ATTRIBUTE_LIST_STR, 1, v_STOP_POS) || c_CRLF ;
		END IF;
	END IF;

	RETURN v_ATTRIBUTE_LIST_STR;
END REPORT_DATA_ATTRIB_STMT;
-----------------------------------------------------------------
-- Returns Column Names of INSERT statement.
-- Example: (PROCESS_ID, REPORT_ID,...,ATTR_VAL_01,...,VAL_001...VAL_100
-- Does not contain INSERT INTO or INSERT part in the beginning.
-- p_SEG_BY_LIST - A collection of numbers, 1 or 0. The first slot contains flag if segmented by Account or not.
--                 We include an ATTR_VAL_## for each element = 1 in the collection.
-- p_PREFIX - An optional parameter, if we need a prefix before an item in the list. ie. prefix = 'TAB.', result = TAB.ATTR_VAL_01
-----------------------------------------------------------------
FUNCTION REPORT_DATA_INSERT_STMT
	(
	p_SEG_BY_LIST 		IN NUMBER_COLLECTION,
	p_PREFIX			IN VARCHAR2 DEFAULT NULL
	) RETURN VARCHAR2 AS
v_INS_STMT VARCHAR2(4000);
v_ATTRIBUTE_LIST_STR VARCHAR2(1024);
BEGIN
	v_INS_STMT := v_INS_STMT || '(' || p_PREFIX || 'PROCESS_ID, ';
	v_INS_STMT := v_INS_STMT || p_PREFIX || 'REPORT_ID, ';
	v_INS_STMT := v_INS_STMT || p_PREFIX || 'REPORT_FILE_NAME, ';
	v_INS_STMT := v_INS_STMT || p_PREFIX || 'EFFECTIVE_DATE,' || c_CRLF;

	v_ATTRIBUTE_LIST_STR := REPORT_DATA_ATTRIB_STMT(p_SEG_BY_LIST, '       ' || p_PREFIX, FALSE);

	v_INS_STMT := v_INS_STMT || v_ATTRIBUTE_LIST_STR;

	FOR v_IDX IN 1 .. 99 LOOP
		-- Indent the first column of each line
        IF MOD(v_IDX, 10) = 1 THEN
			v_INS_STMT := v_INS_STMT || '       ';
        END IF;
        v_INS_STMT := v_INS_STMT || p_PREFIX || 'VAL_' || TO_CHAR(v_IDX, 'FM000') || ', ';
        -- Line Wrap every 10 columns
        IF MOD(v_IDX, 10) = 0 THEN
			v_INS_STMT := v_INS_STMT || c_CRLF;
        END IF;
	END LOOP;

	v_INS_STMT := v_INS_STMT || p_PREFIX || 'VAL_100) ' || c_CRLF;

	RETURN v_INS_STMT;
END REPORT_DATA_INSERT_STMT;
-----------------------------------------------------------------
-- SELECT part of the insert statement.
-- p_SEG_BY_LIST - A collection of numbers, 1 or 0. The first slot contains flag if segmented by Account or not.
--                 We include an ATTR_VAL_## for each element = 1 in the collection.
-- p_PREFIX - Prefix before an item in the list. ie. prefix = 'TAB.', result = TAB.ATTR_VAL_01
-- p_SET_COLUMN_ALIAS - If Column alias should be set or not. Example(If flag is TRUE): X.VALS.VAL_001 AS VAL_001,...
-----------------------------------------------------------------
FUNCTION REPORT_DATA_SELECT_STMT
	(
	p_SEG_BY_LIST 	 		IN NUMBER_COLLECTION,
	p_PREFIX		 		IN VARCHAR2,
	p_SET_COLUMN_ALIAS		IN BOOLEAN DEFAULT FALSE
	) RETURN VARCHAR2 AS
v_SEL_STMT           VARCHAR2(32000);
v_SELECT             VARCHAR2(1024);
BEGIN
    -- Begin building the SELECT statment
	v_SEL_STMT := NULL;
    v_SEL_STMT := v_SEL_STMT || 'SELECT :PROCESS_ID       AS PROCESS_ID,' || c_CRLF;
 	v_SEL_STMT := v_SEL_STMT || '       :REPORT_ID        AS REPORT_ID,' || c_CRLF;
 	v_SEL_STMT := v_SEL_STMT || '       ''X''               AS REPORT_FILE_NAME,' || c_CRLF;
 	v_SEL_STMT := v_SEL_STMT || '       ' || p_PREFIX || 'EFFECTIVE_DATE  AS EFFECTIVE_DATE,' || c_CRLF;

    -- Loop over SEGMENT BY Attributes to complete the SELECT portion of this subquery
	v_SELECT := REPORT_DATA_ATTRIB_STMT(p_SEG_BY_LIST, '       ' || p_PREFIX, FALSE, p_SET_COLUMN_ALIAS);
	v_SEL_STMT := v_SEL_STMT || v_SELECT;

    FOR v_IDX IN 1 .. 99 LOOP
		-- Indent the first column of each line
        IF MOD(v_IDX, 10) = 1 THEN
			v_SEL_STMT := v_SEL_STMT || '       ';
        END IF;
        v_SEL_STMT := v_SEL_STMT || p_PREFIX || 'VALS.TIME_SLOT_' || TO_CHAR(v_IDX, 'FM000');

		IF p_SET_COLUMN_ALIAS THEN
			v_SEL_STMT := v_SEL_STMT || ' AS VAL_' || TO_CHAR(v_IDX, 'FM000');
		END IF;

		v_SEL_STMT := v_SEL_STMT || ', ';
        -- Line Wrap every 10 columns
        IF MOD(v_IDX, 10) = 0 THEN
			v_SEL_STMT := v_SEL_STMT || c_CRLF;
        END IF;
	END LOOP;

	v_SEL_STMT := v_SEL_STMT || p_PREFIX || 'VALS.TIME_SLOT_100';

	IF p_SET_COLUMN_ALIAS THEN
		v_SEL_STMT := v_SEL_STMT || ' AS VAL_100';
	END IF;

	v_SEL_STMT := v_SEL_STMT || c_CRLF;

	RETURN v_SEL_STMT;
END REPORT_DATA_SELECT_STMT;
-----------------------------------------------------------------
-- Returns the Insert portion of the Dynamic SQL Statement used when inserting data into the LOAD_SEGMENTATION_REPORT table.
-----------------------------------------------------------------
FUNCTION INSERT_REPORT_DATA_INSERT_STMT
	(
	p_SEG_BY_LIST	 IN NUMBER_COLLECTION
	) RETURN VARCHAR2 AS
BEGIN
	RETURN 'INSERT INTO LOAD_SEGMENTATION_REPORT ' || REPORT_DATA_INSERT_STMT(p_SEG_BY_LIST);
END INSERT_REPORT_DATA_INSERT_STMT;
-----------------------------------------------------------------
FUNCTION INSERT_REPORT_DATA_WITH_STMT
	(
	p_SEG_BY_LIST 		IN NUMBER_COLLECTION
	) RETURN VARCHAR2 AS
v_WITH_STMT 			VARCHAR2(4000);
v_GROUP_BY 				VARCHAR2(1024);
v_SELECT				VARCHAR2(1024);
BEGIN
 	v_WITH_STMT := v_WITH_STMT || 'WITH ACCOUNTS AS ' || c_CRLF;
	v_WITH_STMT := v_WITH_STMT || '(SELECT AGG.AGG_ACCOUNT_ID     AS AGG_ACCOUNT_ID,' || c_CRLF;
	v_WITH_STMT := v_WITH_STMT || '        AGG.SERVICE_ID         AS SERVICE_ID,' || c_CRLF;
	v_WITH_STMT := v_WITH_STMT || '        AGG.SERVICE_DATE       AS SERVICE_DATE,' || c_CRLF;
	v_WITH_STMT := v_WITH_STMT || '        SUM(CASE ' || c_CRLF;
	v_WITH_STMT := v_WITH_STMT || '                WHEN NVL(AGG.AVG_USAGE_FACTOR,0) = 0 OR NVL(AGG.SERVICE_ACCOUNTS,0) = 0 THEN' || c_CRLF;
	v_WITH_STMT := v_WITH_STMT || '                    0' || c_CRLF;
	v_WITH_STMT := v_WITH_STMT || '                ELSE' || c_CRLF;
	v_WITH_STMT := v_WITH_STMT || '                    NVL(AGG.SUB_AGG_USAGE_FACTOR,AGG.AVG_USAGE_FACTOR)/(AGG.AVG_USAGE_FACTOR * AGG.SERVICE_ACCOUNTS)' || c_CRLF;
	v_WITH_STMT := v_WITH_STMT || '            END) AS USAGE_FACTOR';

	-- Loop over SEGMENT BY Attributes to complete the SELECT portion of this subquery
	v_SELECT := REPORT_DATA_ATTRIB_STMT(p_SEG_BY_LIST, '	   SUB_AGG.', TRUE);

    IF v_SELECT IS NOT NULL THEN
		v_WITH_STMT := v_WITH_STMT || ',' || c_CRLF;
    END IF;

	v_WITH_STMT := v_WITH_STMT || v_SELECT;

	v_WITH_STMT := v_WITH_STMT || '  FROM LOAD_SEG_ACCOUNTS_TMP     SUB_AGG,' || c_CRLF;
	v_WITH_STMT := v_WITH_STMT || '       LOAD_SEG_AGG_ACCOUNTS_TMP AGG' || c_CRLF;
	v_WITH_STMT := v_WITH_STMT || ' WHERE AGG.PROCESS_ID = :PROCESS_ID' || c_CRLF;
	v_WITH_STMT := v_WITH_STMT || '   AND AGG.REPORT_ID = :REPORT_ID' || c_CRLF;
	v_WITH_STMT := v_WITH_STMT || '   AND SUB_AGG.PROCESS_ID = :PROCESS_ID' || c_CRLF;
	v_WITH_STMT := v_WITH_STMT || '   AND SUB_AGG.REPORT_ID = :REPORT_ID' || c_CRLF;
	v_WITH_STMT := v_WITH_STMT || '   AND AGG.ACCOUNT_ID = SUB_AGG.ACCOUNT_ID' || c_CRLF;
	v_WITH_STMT := v_WITH_STMT || '   AND AGG.SERVICE_DATE BETWEEN SUB_AGG.BEGIN_DATE AND SUB_AGG.END_DATE' || c_CRLF;
	v_WITH_STMT := v_WITH_STMT || ' GROUP BY AGG.AGG_ACCOUNT_ID,' || c_CRLF;
	v_WITH_STMT := v_WITH_STMT || '       AGG.SERVICE_ID,' || c_CRLF;
	v_WITH_STMT := v_WITH_STMT || '       AGG.SERVICE_DATE';

	-- Loop over SEGMENT BY Attributes to complete the GROUP BY portion of this subquery
	v_GROUP_BY := REPORT_DATA_ATTRIB_STMT(p_SEG_BY_LIST, '       SUB_AGG.', TRUE);

    IF v_GROUP_BY IS NOT NULL THEN
		v_WITH_STMT := v_WITH_STMT || ',' || c_CRLF;
    END IF;

    v_WITH_STMT := v_WITH_STMT || v_GROUP_BY;

	v_WITH_STMT := TRIM(v_WITH_STMT) || '  )' || c_CRLF;

	RETURN v_WITH_STMT;
END INSERT_REPORT_DATA_WITH_STMT;
-----------------------------------------------------------------
FUNCTION INSERT_REPORT_DATA_FROM_STMT
	(
    p_INTERVAL IN VARCHAR2,
	p_SEG_BY_LIST IN NUMBER_COLLECTION
	) RETURN VARCHAR2 AS
v_SEL_FROM_STMT      VARCHAR2(32000);
v_SELECT             VARCHAR2(1024);
v_GROUP_BY           VARCHAR2(1024);
v_SDT_ROLLUP_COLUMN  VARCHAR2(30);
BEGIN
 	-- Determine which SDT Date column to use for Rollup
	v_SDT_ROLLUP_COLUMN := DETERMINE_SDT_ROLLUP_COLUMN(p_INTERVAL);

	v_SEL_FROM_STMT:= REPORT_DATA_SELECT_STMT(p_SEG_BY_LIST, 'X.');

    v_SEL_FROM_STMT:= v_SEL_FROM_STMT|| 'FROM (SELECT SDT.' || v_SDT_ROLLUP_COLUMN || ' AS EFFECTIVE_DATE,' || c_CRLF;

    -- Loop over SEGMENT BY Attributes to complete the SELECT portion of this subquery
    v_SELECT := REPORT_DATA_ATTRIB_STMT(p_SEG_BY_LIST, '             ACCOUNTS.');
	v_SEL_FROM_STMT:= v_SEL_FROM_STMT|| v_SELECT;

    -- If interval is >= DAY then just do a sum
 	v_SEL_FROM_STMT:= v_SEL_FROM_STMT|| '             GET_TRANSPOSED_VALUES(TIME_SERIES_TYPE(SDT.LOCAL_DATE, (NVL(L.LOAD_VAL,0) + NVL(L.TX_LOSS_VAL,0) + NVL(L.DX_LOSS_VAL,0) + NVL(L.UE_LOSS_VAL,0)) * ACCOUNTS.USAGE_FACTOR, :INTERVAL)) AS VALS' || c_CRLF;

    v_SEL_FROM_STMT:= v_SEL_FROM_STMT|| '      FROM ACCOUNTS,' || c_CRLF;
 	v_SEL_FROM_STMT:= v_SEL_FROM_STMT|| '           SERVICE_LOAD L,' || c_CRLF;
 	v_SEL_FROM_STMT:= v_SEL_FROM_STMT|| '           SYSTEM_DATE_TIME SDT' || c_CRLF;
 	v_SEL_FROM_STMT:= v_SEL_FROM_STMT|| '      WHERE ACCOUNTS.SERVICE_DATE = SDT.LOCAL_DAY_TRUNC_DATE' || c_CRLF;
 	v_SEL_FROM_STMT:= v_SEL_FROM_STMT|| '        AND SDT.TIME_ZONE = :TIME_ZONE' || c_CRLF;
 	v_SEL_FROM_STMT:= v_SEL_FROM_STMT|| '        AND SDT.DAY_TYPE = 1' || c_CRLF;
 	v_SEL_FROM_STMT:= v_SEL_FROM_STMT|| '        AND SDT.DATA_INTERVAL_TYPE = 1' || c_CRLF;
 	v_SEL_FROM_STMT:= v_SEL_FROM_STMT|| '        AND L.SERVICE_ID = ACCOUNTS.SERVICE_ID' || c_CRLF;
 	v_SEL_FROM_STMT:= v_SEL_FROM_STMT|| '        AND L.LOAD_DATE = SDT.CUT_DATE' || c_CRLF;
 	v_SEL_FROM_STMT:= v_SEL_FROM_STMT|| '        AND L.LOAD_CODE = 1' || c_CRLF;
 	v_SEL_FROM_STMT:= v_SEL_FROM_STMT|| '        AND L.SERVICE_CODE = :SERVICE_CODE' || c_CRLF;

    -- Update the GROUP BY clause with the appropriate SDT rollup column based on interval
    v_SEL_FROM_STMT:= v_SEL_FROM_STMT|| '      GROUP BY SDT.' || v_SDT_ROLLUP_COLUMN;

    -- Loop over SEGMENT BY Attributes to complete the GROUP BY portion of this SELECT statement
	v_GROUP_BY := REPORT_DATA_ATTRIB_STMT(p_SEG_BY_LIST, '               ACCOUNTS.', TRUE);

    IF v_GROUP_BY IS NOT NULL THEN
		v_SEL_FROM_STMT:= v_SEL_FROM_STMT|| ',' || c_CRLF;
    END IF;

    v_SEL_FROM_STMT:= v_SEL_FROM_STMT|| v_GROUP_BY;

    v_SEL_FROM_STMT:= v_SEL_FROM_STMT|| ') X';

	RETURN v_SEL_FROM_STMT;
END INSERT_REPORT_DATA_FROM_STMT;
-----------------------------------------------------------------
FUNCTION SUB_AGG_REPORT_DATA_NDS
	(
    p_INTERVAL IN VARCHAR2,
    p_LSRRH_REC IN LOAD_SEG_REPORT_RUN_HEADER%ROWTYPE
    ) RETURN VARCHAR2 AS
v_DYN_SQL VARCHAR2(32000);
v_INS_STMT VARCHAR2(8000);
v_WITH_STMT VARCHAR2(8000);
v_SELECT_STMT VARCHAR2(8000);
v_SEG_BY_LIST NUMBER_COLLECTION;
BEGIN

	v_SEG_BY_LIST := NUMBER_COLLECTION(p_LSRRH_REC.ACCOUNT_IDENT_SEG_BY,
									   p_LSRRH_REC.ATTR_01_SEG_BY,p_LSRRH_REC.ATTR_02_SEG_BY,p_LSRRH_REC.ATTR_03_SEG_BY,
									   p_LSRRH_REC.ATTR_04_SEG_BY,p_LSRRH_REC.ATTR_05_SEG_BY,p_LSRRH_REC.ATTR_06_SEG_BY,
									   p_LSRRH_REC.ATTR_07_SEG_BY,p_LSRRH_REC.ATTR_08_SEG_BY,p_LSRRH_REC.ATTR_09_SEG_BY,
									   p_LSRRH_REC.ATTR_10_SEG_BY);

	v_INS_STMT := INSERT_REPORT_DATA_INSERT_STMT(v_SEG_BY_LIST);

	v_WITH_STMT := INSERT_REPORT_DATA_WITH_STMT(v_SEG_BY_LIST);

	v_SELECT_STMT := INSERT_REPORT_DATA_FROM_STMT(p_INTERVAL, v_SEG_BY_LIST);

	v_DYN_SQL := v_INS_STMT || v_WITH_STMT || v_SELECT_STMT;

	RETURN v_DYN_SQL;

END SUB_AGG_REPORT_DATA_NDS;
-----------------------------------------------------------------
PROCEDURE STAGE_SUB_AGG_REPORT_DATA
	(
	p_PROCESS_ID     IN VARCHAR2,
	p_REPORT_ID      IN NUMBER,
	p_INTERVAL       IN VARCHAR2,
	p_TIME_ZONE      IN VARCHAR2,
	p_SERVICE_CODE   IN CHAR,
	p_LSRRH_REC      IN LOAD_SEG_REPORT_RUN_HEADER%ROWTYPE
	) IS
v_DYN_SQL VARCHAR2(32000);
BEGIN
    v_DYN_SQL := SUB_AGG_REPORT_DATA_NDS(p_INTERVAL, p_LSRRH_REC);

    IF LOGS.IS_INFO_MORE_DETAIL_ENABLED THEN
		LOGS.LOG_INFO_MORE_DETAIL('Posting Dynamic SQL Statement(Sub-Aggregate) as CLOB…');
        LOGS.POST_EVENT_DETAILS('Dynamic SQL Statement', CONSTANTS.MIME_TYPE_TEXT, v_DYN_SQL);
    END IF;

    -- Wrap DYN SQL in PLSQL block to re-use bind variables
    v_DYN_SQL := 'BEGIN ' || v_DYN_SQL || '; END;';

	BEGIN
		EXECUTE IMMEDIATE v_DYN_SQL USING p_PROCESS_ID, p_REPORT_ID, p_INTERVAL, p_TIME_ZONE, p_SERVICE_CODE;
	EXCEPTION
		WHEN OTHERS THEN
			ERRS.LOG_AND_RAISE('Error during parsing or execution of dynamic sql statement(Sub-Aggregate).');
	END;
END STAGE_SUB_AGG_REPORT_DATA;
-----------------------------------------------------------------
-- SELECT statement that retrieves Non-Aggregate Account Load data.
-----------------------------------------------------------------
FUNCTION NON_AGG_REPORT_DATA_SEL_STMT
	(
    p_INTERVAL IN VARCHAR2,
	p_SEG_BY_LIST IN NUMBER_COLLECTION
	) RETURN VARCHAR2 AS
v_SEL_STMT         	 VARCHAR2(32000);
v_SELECT             VARCHAR2(1024);
v_GROUP_BY           VARCHAR2(1024);
v_SDT_ROLLUP_COLUMN  VARCHAR2(30);
BEGIN
 	-- Determine which SDT Date column to use for Rollup
	v_SDT_ROLLUP_COLUMN := DETERMINE_SDT_ROLLUP_COLUMN(p_INTERVAL);

	v_SEL_STMT := v_SEL_STMT || REPORT_DATA_SELECT_STMT(p_SEG_BY_LIST, 'L.', TRUE);

	v_SEL_STMT := v_SEL_STMT || 'FROM' || c_CRLF;
	v_SEL_STMT := v_SEL_STMT || '(SELECT SDT.' || v_SDT_ROLLUP_COLUMN || ' AS EFFECTIVE_DATE,' || c_CRLF;

    v_SELECT := REPORT_DATA_ATTRIB_STMT(p_SEG_BY_LIST, '        LSAT.', FALSE, TRUE);
	v_SEL_STMT := v_SEL_STMT || v_SELECT;

	v_SEL_STMT := v_SEL_STMT || '        GET_TRANSPOSED_VALUES(TIME_SERIES_TYPE(SDT.LOCAL_DATE, NVL(SL.LOAD_VAL,0) + NVL(SL.TX_LOSS_VAL,0) + NVL(SL.DX_LOSS_VAL,0) + NVL(SL.UE_LOSS_VAL,0), :INTERVAL)) AS VALS' || c_CRLF;
	v_SEL_STMT := v_SEL_STMT || '   FROM ACCOUNT A,' || c_CRLF;
	v_SEL_STMT := v_SEL_STMT || '        ACCOUNT_SERVICE ASRV,' || c_CRLF;
	v_SEL_STMT := v_SEL_STMT || '        SERVICE S,' || c_CRLF;
	v_SEL_STMT := v_SEL_STMT || '        SERVICE_LOAD SL,' || c_CRLF;
	v_SEL_STMT := v_SEL_STMT || '        LOAD_SEG_ACCOUNTS_TMP LSAT,' || c_CRLF;
	v_SEL_STMT := v_SEL_STMT || '        SYSTEM_DATE_TIME SDT' || c_CRLF;
	v_SEL_STMT := v_SEL_STMT || '  WHERE LSAT.PROCESS_ID = :PROCESS_ID' || c_CRLF;
	v_SEL_STMT := v_SEL_STMT || '    AND LSAT.REPORT_ID = :REPORT_ID' || c_CRLF;
	v_SEL_STMT := v_SEL_STMT || '    AND LSAT.IS_SUB_AGGREGATE = 0' || c_CRLF;
	v_SEL_STMT := v_SEL_STMT || '    AND A.ACCOUNT_ID = LSAT.ACCOUNT_ID' || c_CRLF;
	v_SEL_STMT := v_SEL_STMT || '    AND ASRV.ACCOUNT_ID = A.ACCOUNT_ID' || c_CRLF;
	v_SEL_STMT := v_SEL_STMT || '    AND S.ACCOUNT_SERVICE_ID = ASRV.ACCOUNT_SERVICE_ID' || c_CRLF;
	v_SEL_STMT := v_SEL_STMT || '    AND S.AS_OF_DATE = :LOW_DATE' || c_CRLF;
	v_SEL_STMT := v_SEL_STMT || '    AND S.MODEL_ID = A.MODEL_ID' || c_CRLF;
	v_SEL_STMT := v_SEL_STMT || '    AND S.SCENARIO_ID = :SCENARIO_ID' || c_CRLF;
	v_SEL_STMT := v_SEL_STMT || '    AND SL.SERVICE_ID = S.SERVICE_ID' || c_CRLF;
	v_SEL_STMT := v_SEL_STMT || '    AND SL.SERVICE_CODE = :SERVICE_CODE' || c_CRLF;
	v_SEL_STMT := v_SEL_STMT || '    AND SL.LOAD_CODE = 1' || c_CRLF;
	v_SEL_STMT := v_SEL_STMT || '    AND SL.LOAD_DATE = SDT.CUT_DATE' || c_CRLF;
	v_SEL_STMT := v_SEL_STMT || '    AND SDT.DAY_TYPE = 1' || c_CRLF;
	v_SEL_STMT := v_SEL_STMT || '    AND SDT.DATA_INTERVAL_TYPE = 1' || c_CRLF;
	v_SEL_STMT := v_SEL_STMT || '    AND SDT.TIME_ZONE = :TIME_ZONE' || c_CRLF;
	v_SEL_STMT := v_SEL_STMT || '    AND SDT.LOCAL_DATE BETWEEN LSAT.BEGIN_DATE + 1/86400 AND LSAT.END_DATE + 1' || c_CRLF;
	v_SEL_STMT := v_SEL_STMT || ' GROUP BY SDT.' || v_SDT_ROLLUP_COLUMN;

    v_GROUP_BY := REPORT_DATA_ATTRIB_STMT(p_SEG_BY_LIST, '          LSAT.', TRUE);

    IF v_GROUP_BY IS NOT NULL THEN
		v_SEL_STMT := v_SEL_STMT || ',' || c_CRLF;
    END IF;

	v_SEL_STMT := v_SEL_STMT || v_GROUP_BY;

    v_SEL_STMT := v_SEL_STMT || ') L';

	RETURN v_SEL_STMT;
END NON_AGG_REPORT_DATA_SEL_STMT;
-----------------------------------------------------------------
-- USING part of the MERGE statement.
-----------------------------------------------------------------
FUNCTION MERGE_REPORT_DATA_USING_STMT
	(
    p_INTERVAL IN VARCHAR2,
	p_SEG_BY_LIST IN NUMBER_COLLECTION
	) RETURN VARCHAR2 AS
BEGIN
	RETURN 'USING(' || c_CRLF || NON_AGG_REPORT_DATA_SEL_STMT(p_INTERVAL, p_SEG_BY_LIST) || ') X' || c_CRLF;
END MERGE_REPORT_DATA_USING_STMT;
-----------------------------------------------------------------
-- ON part of the MERGE statement.
-----------------------------------------------------------------
FUNCTION MERGE_REPORT_DATA_ON_STMT
	(
    p_SEG_BY_LIST IN NUMBER_COLLECTION
	) RETURN VARCHAR2 AS
v_ON_STMT         VARCHAR2(32000);
BEGIN
	v_ON_STMT := v_ON_STMT || 'ON(    LSR.PROCESS_ID = X.PROCESS_ID' || c_CRLF;
	v_ON_STMT := v_ON_STMT || '   AND LSR.REPORT_ID = X.REPORT_ID' || c_CRLF;
	v_ON_STMT := v_ON_STMT || '   AND LSR.REPORT_FILE_NAME = X.REPORT_FILE_NAME' || c_CRLF;
	v_ON_STMT := v_ON_STMT || '   AND LSR.EFFECTIVE_DATE = X.EFFECTIVE_DATE' || c_CRLF;

	-- If segmented by Account, it is a direct INSERT statement, hence not being checked here.

	-- p_SEG_BY_LIST(1) specifies if Account is Segmented By or not. So we start from 2.
	FOR v_IDX IN 2..p_SEG_BY_LIST.COUNT LOOP
		IF p_SEG_BY_LIST(v_IDX) = 1 THEN
			v_ON_STMT := v_ON_STMT || '   AND ((LSR.ATTR_VAL_' || LPAD(v_IDX - 1, 2, 0) || ' = ' || 'X.ATTR_VAL_' || LPAD(v_IDX - 1, 2, 0);
			v_ON_STMT := v_ON_STMT || ') OR (LSR.ATTR_VAL_' || LPAD(v_IDX - 1, 2, 0) || ' IS NULL AND X.ATTR_VAL_' || LPAD(v_IDX - 1, 2, 0) || ' IS NULL))' ||c_CRLF;
		END IF;
	END LOOP;

	v_ON_STMT := v_ON_STMT || '  )' || c_CRLF;

	RETURN v_ON_STMT;
END MERGE_REPORT_DATA_ON_STMT;
-----------------------------------------------------------------
-- MATCHED part of the MERGE statement.
-----------------------------------------------------------------
FUNCTION MERGE_REPORT_DATA_MATCH_STMT RETURN VARCHAR2 AS
v_MATCH_STMT         VARCHAR2(32000);
BEGIN
	v_MATCH_STMT := v_MATCH_STMT || 'WHEN MATCHED THEN' || c_CRLF;
	v_MATCH_STMT := v_MATCH_STMT || '    UPDATE SET' || c_CRLF || '      ';

	-- The columns and the values they should be updated with. NVL wrapped as some intervals could have NULL values.
	FOR v_IDX IN 1..99 LOOP
		v_MATCH_STMT := v_MATCH_STMT || ' LSR.VAL_' || LPAD(v_IDX, 3, 0) || ' = NVL(LSR.VAL_' || LPAD(v_IDX, 3, 0) || ', 0) + NVL(X.VAL_' || LPAD(v_IDX, 3, 0) || ', 0),';

        IF MOD(v_IDX, 10) = 0 THEN
			v_MATCH_STMT := v_MATCH_STMT || c_CRLF || '      ';
        END IF;
	END LOOP;

	v_MATCH_STMT := v_MATCH_STMT || ' LSR.VAL_100 = NVL(LSR.VAL_100, 0) + NVL(X.VAL_100, 0)' || c_CRLF;

	RETURN v_MATCH_STMT;
END MERGE_REPORT_DATA_MATCH_STMT;
-----------------------------------------------------------------
-- NOT MATCHED part of the MERGE statement.
-----------------------------------------------------------------
FUNCTION MERGE_REPORT_DATA_NOMATCH_STMT
	(
	p_SEG_BY_LIST	 IN NUMBER_COLLECTION
	) RETURN VARCHAR2 AS

BEGIN
	RETURN 'WHEN NOT MATCHED THEN' || c_CRLF ||
		   'INSERT' || REPORT_DATA_INSERT_STMT(p_SEG_BY_LIST, 'LSR.') ||
		   'VALUES' || REPORT_DATA_INSERT_STMT(p_SEG_BY_LIST, 'X.');
END MERGE_REPORT_DATA_NOMATCH_STMT;
-----------------------------------------------------------------
FUNCTION NON_AGG_REPORT_DATA_NDS
	(
    p_INTERVAL  IN VARCHAR2,
    p_LSRRH_REC IN LOAD_SEG_REPORT_RUN_HEADER%ROWTYPE,
	p_MERGE		IN BOOLEAN
    ) RETURN VARCHAR2 AS
v_DYN_SQL 			VARCHAR2(32000);
v_INSERT_STMT 		VARCHAR2(8000);
v_SEL_STMT 			VARCHAR2(8000);
v_MERGE_STMT 		VARCHAR2(50);
v_USING_STMT 		VARCHAR2(8000);
v_ON_STMT 			VARCHAR2(8000);
v_MATCH_STMT 		VARCHAR2(8000);
v_NOMATCH_STMT 		VARCHAR2(8000);
v_SEG_BY_LIST 		NUMBER_COLLECTION;
BEGIN

	v_SEG_BY_LIST := NUMBER_COLLECTION(p_LSRRH_REC.ACCOUNT_IDENT_SEG_BY,
									   p_LSRRH_REC.ATTR_01_SEG_BY,p_LSRRH_REC.ATTR_02_SEG_BY,p_LSRRH_REC.ATTR_03_SEG_BY,
									   p_LSRRH_REC.ATTR_04_SEG_BY,p_LSRRH_REC.ATTR_05_SEG_BY,p_LSRRH_REC.ATTR_06_SEG_BY,
									   p_LSRRH_REC.ATTR_07_SEG_BY,p_LSRRH_REC.ATTR_08_SEG_BY,p_LSRRH_REC.ATTR_09_SEG_BY,
									   p_LSRRH_REC.ATTR_10_SEG_BY);

	-- p_MERGE flag informs us if the statement should be a direct INSERT or MERGE.
	-- If TRUE, then MERGE. Else, direct INSERT.
	IF p_MERGE THEN
		v_MERGE_STMT := 'MERGE INTO LOAD_SEGMENTATION_REPORT LSR' || c_CRLF;

		v_USING_STMT := MERGE_REPORT_DATA_USING_STMT(p_INTERVAL, v_SEG_BY_LIST);

		v_ON_STMT := MERGE_REPORT_DATA_ON_STMT(v_SEG_BY_LIST);

		v_MATCH_STMT := MERGE_REPORT_DATA_MATCH_STMT;

		v_NOMATCH_STMT := MERGE_REPORT_DATA_NOMATCH_STMT(v_SEG_BY_LIST);

		v_DYN_SQL := v_MERGE_STMT || v_USING_STMT || v_ON_STMT || v_MATCH_STMT || v_NOMATCH_STMT;
	ELSE
		v_INSERT_STMT := INSERT_REPORT_DATA_INSERT_STMT(v_SEG_BY_LIST);

		v_SEL_STMT := NON_AGG_REPORT_DATA_SEL_STMT(p_INTERVAL, v_SEG_BY_LIST);

		v_DYN_SQL := v_INSERT_STMT || v_SEL_STMT;
	END IF;

	RETURN v_DYN_SQL;

END NON_AGG_REPORT_DATA_NDS;
-----------------------------------------------------------------
PROCEDURE STAGE_NON_AGG_REPORT_DATA
	(
	p_PROCESS_ID     IN VARCHAR2,
	p_REPORT_ID      IN NUMBER,
	p_INTERVAL       IN VARCHAR2,
	p_TIME_ZONE      IN VARCHAR2,
	p_SERVICE_CODE   IN CHAR,
	p_SCENARIO_ID	 IN NUMBER,
	p_LSRRH_REC      IN LOAD_SEG_REPORT_RUN_HEADER%ROWTYPE
	) IS
v_DYN_SQL 			VARCHAR2(32000);
v_RECORDS_EXIST		NUMBER(1);
v_MERGE				BOOLEAN;
BEGIN
	SELECT NVL(MIN(1),0)
	INTO v_RECORDS_EXIST
	FROM DUAL
	WHERE EXISTS (SELECT 1
				    FROM LOAD_SEGMENTATION_REPORT LSR
				   WHERE LSR.PROCESS_ID = p_PROCESS_ID
					 AND LSR.REPORT_ID = p_REPORT_ID);

	-- If the report is NOT segmented by Account or records exist in LOAD_SEGMENTATION_REPORT at this stage,
	-- then do a MERGE. Else, INSERT.
	v_MERGE := NOT((v_RECORDS_EXIST = 0) OR (p_LSRRH_REC.ACCOUNT_IDENT_SEG_BY = 1));

    v_DYN_SQL := NON_AGG_REPORT_DATA_NDS(p_INTERVAL, p_LSRRH_REC, v_MERGE);

    IF LOGS.IS_INFO_MORE_DETAIL_ENABLED THEN
		LOGS.LOG_INFO_MORE_DETAIL('Posting Dynamic SQL Statement(Non-Aggregate) as CLOB…');
        LOGS.POST_EVENT_DETAILS('Dynamic SQL Statement', CONSTANTS.MIME_TYPE_TEXT, v_DYN_SQL);
    END IF;

    -- Wrap DYN SQL in PLSQL block to re-use bind variables
    v_DYN_SQL := 'BEGIN ' || v_DYN_SQL || '; END;';

	BEGIN
		EXECUTE IMMEDIATE v_DYN_SQL USING p_PROCESS_ID, p_REPORT_ID, p_INTERVAL, CONSTANTS.LOW_DATE,
										  p_SCENARIO_ID, p_SERVICE_CODE, p_TIME_ZONE;
	EXCEPTION
		WHEN OTHERS THEN
			ERRS.LOG_AND_RAISE('Error during parsing or execution of dynamic sql statement(Non-Aggregate).');
	END;
END STAGE_NON_AGG_REPORT_DATA;
-----------------------------------------------------------------
PROCEDURE STAGE_REPORT_DATA (
   p_PROCESS_ID     IN VARCHAR2,
   p_REPORT_ID      IN NUMBER,
   p_ADJ_BEGIN_DATE IN DATE, -- This is calendar DATE adjusted for WEEK, MONTH, QUARTER, YEAR interval
   p_ADJ_END_DATE   IN DATE, -- This is calendar DATE adjusted for WEEK, MONTH, QUARTER, YEAR interval
   p_CUT_BEGIN_DATE IN DATE,
   p_CUT_END_DATE   IN DATE,
   p_INTERVAL       IN VARCHAR2,
   p_TIME_ZONE      IN VARCHAR2,
   p_SERVICE_CODE   IN CHAR,
   p_SCENARIO_ID    IN NUMBER,
   p_LSRRH_REC   	IN OUT NOCOPY LOAD_SEG_REPORT_RUN_HEADER%ROWTYPE
   )
AS
	-- Minor mods
	c_PROCEDURE_NAME	CONSTANT VARCHAR2(30) := 'STAGE_REPORT_DATA';
	c_PROC_NAME			CONSTANT VARCHAR2(61) := c_PACKAGE_NAME || '.' || c_PROCEDURE_NAME;
	v_ACCOUNT_EXISTS	NUMBER(1);
   	v_ACCOUNT_IDS       NUMBER_COLLECTION := NUMBER_COLLECTION();
BEGIN
	LOGS.LOG_DEBUG('Calling  FIND_ACCOUNTS_FOR_REPORT...');

	-- Find Accounts
	FIND_ACCOUNTS_FOR_REPORT(
	   p_PROCESS_ID,
	   p_REPORT_ID,
	   p_ADJ_BEGIN_DATE,
	   p_ADJ_END_DATE,
	   p_LSRRH_REC
	   );

	-- Search if any Sub-Aggregate Accounts Exist.
	SELECT NVL(MIN(1),0)
	INTO v_ACCOUNT_EXISTS
	FROM DUAL
	WHERE EXISTS (SELECT 1
				    FROM LOAD_SEG_ACCOUNTS_TMP LSAT
				   WHERE LSAT.PROCESS_ID = p_PROCESS_ID
					 AND LSAT.REPORT_ID = p_REPORT_ID
					 AND LSAT.IS_SUB_AGGREGATE = 1);

	-- Process Sub-Aggregates only if at least one Sub-Aggregate meets the Configuration Details criteria
	IF v_ACCOUNT_EXISTS = 1 THEN
		LOGS.LOG_DEBUG('Calling  FIND_AGGREGATES_FOR_REPORT...');

		-- Find aggregate accounts
		FIND_AGGREGATES_FOR_REPORT (
		   p_PROCESS_ID,
		   p_REPORT_ID,
		   p_ADJ_BEGIN_DATE,
		   p_ADJ_END_DATE,
		   p_CUT_BEGIN_DATE,
		   p_CUT_END_DATE,
		   p_TIME_ZONE,
		   p_SERVICE_CODE,
		   p_SCENARIO_ID
		   );

		LOGS.LOG_DEBUG('Get the report header to determine the columns and groupings needed for the report.');

		STAGE_SUB_AGG_REPORT_DATA(p_PROCESS_ID, p_REPORT_ID, p_INTERVAL, p_TIME_ZONE, p_SERVICE_CODE, p_LSRRH_REC);
	END IF;

	-- Search if any Non-Aggregate Accounts Exist.
	SELECT NVL(MIN(1),0)
	INTO v_ACCOUNT_EXISTS
	FROM DUAL
	WHERE EXISTS (SELECT 1
				    FROM LOAD_SEG_ACCOUNTS_TMP LSAT
				   WHERE LSAT.PROCESS_ID = p_PROCESS_ID
					 AND LSAT.REPORT_ID = p_REPORT_ID
					 AND LSAT.IS_SUB_AGGREGATE = 0);

	-- Process Non-Aggregates only if at least one Non-Aggregate meets the Configuration Details criteria
	IF v_ACCOUNT_EXISTS = 1 THEN
		LOGS.LOG_DEBUG_DETAIL(p_EVENT_TEXT => 'Call ENSURE_SERVICE_DETAILS for each NON-AGGREGATE ID .',
							  p_PROCEDURE_NAME => c_PROC_NAME);

		SELECT DISTINCT LSAT.ACCOUNT_ID
		  BULK COLLECT INTO v_ACCOUNT_IDS
		  FROM LOAD_SEG_ACCOUNTS_TMP LSAT
		 WHERE LSAT.PROCESS_ID = p_PROCESS_ID
		   AND LSAT.REPORT_ID = p_REPORT_ID
		   AND LSAT.IS_SUB_AGGREGATE = 0;

		FS.ENSURE_SERVICE_DETAILS (
			p_SERVICE_CODE,
			GA.DEFAULT_MODEL,
			p_SCENARIO_ID,
			CONSTANTS.ALL_ID,
			CONSTANTS.ALL_ID,
			v_ACCOUNT_IDS,
			p_CUT_BEGIN_DATE,
			p_CUT_END_DATE,
			CONSTANTS.LOW_DATE
			);

		STAGE_NON_AGG_REPORT_DATA (
		   p_PROCESS_ID,
		   p_REPORT_ID,
		   p_INTERVAL,
		   p_TIME_ZONE,
		   p_SERVICE_CODE,
		   p_SCENARIO_ID,
		   p_LSRRH_REC
		   );
	END IF;

   	LOGS.LOG_DEBUG(c_PROC_NAME||'...END');
END STAGE_REPORT_DATA;
-----------------------------------------------------------------
PROCEDURE RLSR_START_PROCESS_LOG
(
	p_BEGIN_DATE 	IN DATE,
	p_END_DATE 		IN DATE,
	p_TIME_ZONE 	IN VARCHAR2,
	p_RUN_TYPE_ID 	IN NUMBER,
	p_INTERVAL 		IN VARCHAR2,
	p_PROCESS_NAME 	IN VARCHAR2) is
BEGIN
	LOGS.START_PROCESS(p_PROCESS_NAME => p_PROCESS_NAME);
	LOGS.SET_PROCESS_TARGET_PARAMETER('BEGIN_DATE', TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('END_DATE', TEXT_UTIL.TO_CHAR_DATE(p_END_DATE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('TIME_ZONE', p_TIME_ZONE);
	LOGS.SET_PROCESS_TARGET_PARAMETER('RUN_TYPE_ID', p_RUN_TYPE_ID);
	LOGS.SET_PROCESS_TARGET_PARAMETER('INTERVAL', p_INTERVAL);
END RLSR_START_PROCESS_LOG;
-----------------------------------------------------------------
PROCEDURE RLSR_VALIDATE_DATA
(
	p_BEGIN_DATE 	IN DATE,
	p_END_DATE 		IN DATE,
	p_TIME_ZONE 	IN VARCHAR2,
	p_RUN_TYPE_ID 	IN NUMBER,
	p_INTERVAL 		IN VARCHAR2,
	p_REPORT_ID 	IN NUMBER
) IS
BEGIN
	ASSERT(p_BEGIN_DATE IS NOT NULL, 'Begin Date cannot be empty.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_END_DATE IS NOT NULL, 'End Date cannot be empty.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_TIME_ZONE IS NOT NULL, 'Timezone cannot be empty.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_RUN_TYPE_ID IS NOT NULL, 'Run Type cannot be empty.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_INTERVAL IS NOT NULL, 'Interval cannot be empty.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_REPORT_ID IS NOT NULL, 'Report ID cannot be empty.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_BEGIN_DATE <= p_END_DATE, 'Begin Date cannot be greater than End Date', MSGCODES.c_ERR_ARGUMENT);
END RLSR_VALIDATE_DATA;
-----------------------------------------------------------------
PROCEDURE RLSR_GET_DATE_RANGE
(
	p_BEGIN_DATE 	IN DATE,
	p_END_DATE 	IN DATE,
	p_TIME_ZONE			IN VARCHAR2,
	p_INTERVAL 			IN VARCHAR2,
	p_ADJ_BEGIN_DATE	IN OUT DATE,
	p_ADJ_END_DATE		IN OUT DATE,
	p_CUT_BEGIN_DATE 	IN OUT DATE,
	p_CUT_END_DATE 		IN OUT DATE
) IS
BEGIN
	-- Adjust the dates based on the p_INTERVAL to adjust the boundary line for WEEK, QUARTER, etc.
	CASE
	WHEN p_INTERVAL NOT IN (CONSTANTS.INTERVAL_15_MINUTE, CONSTANTS.INTERVAL_30_MINUTE,
							CONSTANTS.INTERVAL_HOUR, CONSTANTS.INTERVAL_DAY) THEN
		p_ADJ_BEGIN_DATE := DATE_UTIL.BEGIN_DATE_FOR_INTERVAL(p_BEGIN_DATE, p_INTERVAL);
		p_ADJ_END_DATE	 := DATE_UTIL.END_DATE_FOR_INTERVAL(p_END_DATE, p_INTERVAL);
	ELSE
		p_ADJ_BEGIN_DATE := p_BEGIN_DATE;
		p_ADJ_END_DATE	 := p_END_DATE;
	END CASE;

	-- Date-range for week/month/quarter etc. can have diff begin/end date
	UT.CUT_DATE_RANGE(	GA.DEFAULT_MODEL,
					  	p_ADJ_BEGIN_DATE,
						p_ADJ_END_DATE,
						p_TIME_ZONE,
						p_CUT_BEGIN_DATE,
						p_CUT_END_DATE
					 );
END RLSR_GET_DATE_RANGE;
--------------------------------------------------------------------------------
PROCEDURE PUT_LOAD_SEG_REPORT_RUN_HEADER
(
	p_BEGIN_DATE 			IN DATE,
	p_END_DATE 				IN DATE,
	p_RUN_TYPE_ID 			IN NUMBER,
	p_INTERVAL 				IN VARCHAR2,
	p_REPORT_ID 			IN NUMBER,
	p_PROCESS_ID 			IN VARCHAR2,
	p_LOAD_SEG_HEADER_REC 	IN OUT NOCOPY LOAD_SEG_REPORT_RUN_HEADER%ROWTYPE
) IS
BEGIN
	INSERT INTO LOAD_SEG_REPORT_RUN_HEADER(	PROCESS_ID,
											REPORT_ID,
											BEGIN_DATE,
											END_DATE,
											INTERVAL,
											RUN_TYPE_ID
										  )
	VALUES (p_PROCESS_ID,
			p_REPORT_ID,
			p_BEGIN_DATE,
			p_END_DATE,
			p_INTERVAL,
			p_RUN_TYPE_ID
			)
	RETURNING PROCESS_ID, REPORT_ID, BEGIN_DATE, END_DATE, INTERVAL, RUN_TYPE_ID, ACCOUNT_IDENT_ATTR, ACCOUNT_IDENT_SEG_BY,
			  ATTR_NAME_01, ATTR_01_SEG_BY, ATTR_NAME_02, ATTR_02_SEG_BY, ATTR_NAME_03, ATTR_03_SEG_BY, ATTR_NAME_04,
			  ATTR_04_SEG_BY, ATTR_NAME_05, ATTR_05_SEG_BY, ATTR_NAME_06, ATTR_06_SEG_BY, ATTR_NAME_07, ATTR_07_SEG_BY,
			  ATTR_NAME_08, ATTR_08_SEG_BY, ATTR_NAME_09, ATTR_09_SEG_BY, ATTR_NAME_10, ATTR_10_SEG_BY
	INTO	  p_LOAD_SEG_HEADER_REC;
END PUT_LOAD_SEG_REPORT_RUN_HEADER;
--------------------------------------------------------------------------------
PROCEDURE OPEN_FILE
	(
	p_RETAIL_OPS_CSV_DIR_OBJ  IN  VARCHAR2,
	p_REPORT_FILE_NAME		  IN  VARCHAR2,
	p_FILE_OUT_LOAD_SEG		  OUT UTL_FILE.FILE_TYPE
	) AS
BEGIN
	$if $$UNIT_TEST_MODE = 1 $then
		RETURN;
	$end

	p_FILE_OUT_LOAD_SEG := UTL_FILE.FOPEN(p_RETAIL_OPS_CSV_DIR_OBJ, p_REPORT_FILE_NAME, 'W', 32767);
END OPEN_FILE;
--------------------------------------------------------------------------
PROCEDURE CLOSE_FILE(p_FILE_OUT_LOAD_SEG IN OUT	UTL_FILE.FILE_TYPE) AS
BEGIN
	$if $$UNIT_TEST_MODE = 1 $then
		RETURN;
	$end

	UTL_FILE.FCLOSE(p_FILE_OUT_LOAD_SEG);
END CLOSE_FILE;
--------------------------------------------------------------------------
PROCEDURE WRITE_LINE
	(
	p_FILE_OUT_LOAD_SEG	IN UTL_FILE.FILE_TYPE,
	p_LINE 				IN VARCHAR2
	) AS
BEGIN
	$if $$UNIT_TEST_MODE = 1 $then
		LOGS.LOG_INFO(p_LINE);
		RETURN;
	$end

	UTL_FILE.PUT_LINE(p_FILE_OUT_LOAD_SEG, p_LINE, FALSE);
END WRITE_LINE;
--------------------------------------------------------------------------------
FUNCTION CORRECT_SEG_BY_COLUMN_VALUES
	(
	p_PROCESS_ID				  IN NUMBER,
	p_LOAD_SEGMENTATION_REPORT_ID IN NUMBER
	) RETURN LOAD_SEG_REPORT_RUN_HEADER%ROWTYPE AS
	v_LOAD_SEG_REPORT_RUN_HEADER	LOAD_SEG_REPORT_RUN_HEADER%ROWTYPE;
BEGIN
	/* Fetch Column names and Segment By Values.*/
  	SELECT *
	INTO v_LOAD_SEG_REPORT_RUN_HEADER
	FROM LOAD_SEG_REPORT_RUN_HEADER LSRRH
	WHERE LSRRH.PROCESS_ID = p_PROCESS_ID
	  AND LSRRH.REPORT_ID = p_LOAD_SEGMENTATION_REPORT_ID;

	/* If Segmented by an Attribute and there are no Non-NULL Attribute Values,
	   Segment By should be set to 0. */
	IF v_LOAD_SEG_REPORT_RUN_HEADER.ACCOUNT_IDENT_SEG_BY = 1 THEN
		BEGIN
			SELECT 1
			INTO v_LOAD_SEG_REPORT_RUN_HEADER.ACCOUNT_IDENT_SEG_BY
			FROM DUAL
			WHERE EXISTS (SELECT LSR.ACCOUNT_IDENT
							FROM LOAD_SEGMENTATION_REPORT LSR
						   WHERE LSR.PROCESS_ID = p_PROCESS_ID
							 AND LSR.REPORT_ID = p_LOAD_SEGMENTATION_REPORT_ID
							 AND LSR.ACCOUNT_IDENT IS NOT NULL);
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				v_LOAD_SEG_REPORT_RUN_HEADER.ACCOUNT_IDENT_SEG_BY := 0;
		END;
	END IF;

	IF v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_01_SEG_BY = 1 THEN
		BEGIN
			SELECT 1
			INTO v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_01_SEG_BY
			FROM DUAL
			WHERE EXISTS (SELECT LSR.ATTR_VAL_01
							FROM LOAD_SEGMENTATION_REPORT LSR
						   WHERE LSR.PROCESS_ID = p_PROCESS_ID
							 AND LSR.REPORT_ID = p_LOAD_SEGMENTATION_REPORT_ID
							 AND LSR.ATTR_VAL_01 IS NOT NULL);
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_01_SEG_BY := 0;
		END;
	END IF;

	IF v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_02_SEG_BY = 1 THEN
		BEGIN
			SELECT 1
			INTO v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_02_SEG_BY
			FROM DUAL
			WHERE EXISTS (SELECT LSR.ATTR_VAL_02
							FROM LOAD_SEGMENTATION_REPORT LSR
						   WHERE LSR.PROCESS_ID = p_PROCESS_ID
							 AND LSR.REPORT_ID = p_LOAD_SEGMENTATION_REPORT_ID
							 AND LSR.ATTR_VAL_02 IS NOT NULL);
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_02_SEG_BY := 0;
		END;
	END IF;

	IF v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_03_SEG_BY = 1 THEN
		BEGIN
			SELECT 1
			INTO v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_03_SEG_BY
			FROM DUAL
			WHERE EXISTS (SELECT LSR.ATTR_VAL_03
							FROM LOAD_SEGMENTATION_REPORT LSR
						   WHERE LSR.PROCESS_ID = p_PROCESS_ID
							 AND LSR.REPORT_ID = p_LOAD_SEGMENTATION_REPORT_ID
							 AND LSR.ATTR_VAL_03 IS NOT NULL);
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_03_SEG_BY := 0;
		END;
	END IF;

	IF v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_04_SEG_BY = 1 THEN
		BEGIN
			SELECT 1
			INTO v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_04_SEG_BY
			FROM DUAL
			WHERE EXISTS (SELECT LSR.ATTR_VAL_04
							FROM LOAD_SEGMENTATION_REPORT LSR
						   WHERE LSR.PROCESS_ID = p_PROCESS_ID
							 AND LSR.REPORT_ID = p_LOAD_SEGMENTATION_REPORT_ID
							 AND LSR.ATTR_VAL_04 IS NOT NULL);
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_04_SEG_BY := 0;
		END;
	END IF;

	IF v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_05_SEG_BY = 1 THEN
		BEGIN
			SELECT 1
			INTO v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_05_SEG_BY
			FROM DUAL
			WHERE EXISTS (SELECT LSR.ATTR_VAL_05
							FROM LOAD_SEGMENTATION_REPORT LSR
						   WHERE LSR.PROCESS_ID = p_PROCESS_ID
							 AND LSR.REPORT_ID = p_LOAD_SEGMENTATION_REPORT_ID
							 AND LSR.ATTR_VAL_05 IS NOT NULL);
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_05_SEG_BY := 0;
		END;
	END IF;

	IF v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_06_SEG_BY = 1 THEN
		BEGIN
			SELECT 1
			INTO v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_06_SEG_BY
			FROM DUAL
			WHERE EXISTS (SELECT LSR.ATTR_VAL_06
							FROM LOAD_SEGMENTATION_REPORT LSR
						   WHERE LSR.PROCESS_ID = p_PROCESS_ID
							 AND LSR.REPORT_ID = p_LOAD_SEGMENTATION_REPORT_ID
							 AND LSR.ATTR_VAL_06 IS NOT NULL);
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_06_SEG_BY := 0;
		END;
	END IF;

	IF v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_07_SEG_BY = 1 THEN
		BEGIN
			SELECT 1
			INTO v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_07_SEG_BY
			FROM DUAL
			WHERE EXISTS (SELECT LSR.ATTR_VAL_07
							FROM LOAD_SEGMENTATION_REPORT LSR
						   WHERE LSR.PROCESS_ID = p_PROCESS_ID
							 AND LSR.REPORT_ID = p_LOAD_SEGMENTATION_REPORT_ID
							 AND LSR.ATTR_VAL_07 IS NOT NULL);
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_07_SEG_BY := 0;
		END;
	END IF;

	IF v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_08_SEG_BY = 1 THEN
		BEGIN
			SELECT 1
			INTO v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_08_SEG_BY
			FROM DUAL
			WHERE EXISTS (SELECT LSR.ATTR_VAL_08
							FROM LOAD_SEGMENTATION_REPORT LSR
						   WHERE LSR.PROCESS_ID = p_PROCESS_ID
							 AND LSR.REPORT_ID = p_LOAD_SEGMENTATION_REPORT_ID
							 AND LSR.ATTR_VAL_08 IS NOT NULL);
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_08_SEG_BY := 0;
		END;
	END IF;

	IF v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_09_SEG_BY = 1 THEN
		BEGIN
			SELECT 1
			INTO v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_09_SEG_BY
			FROM DUAL
			WHERE EXISTS (SELECT LSR.ATTR_VAL_09
							FROM LOAD_SEGMENTATION_REPORT LSR
						   WHERE LSR.PROCESS_ID = p_PROCESS_ID
							 AND LSR.REPORT_ID = p_LOAD_SEGMENTATION_REPORT_ID
							 AND LSR.ATTR_VAL_09 IS NOT NULL);
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_09_SEG_BY := 0;
		END;
	END IF;

	IF v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_10_SEG_BY = 1 THEN
		BEGIN
			SELECT 1
			INTO v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_10_SEG_BY
			FROM DUAL
			WHERE EXISTS (SELECT LSR.ATTR_VAL_10
							FROM LOAD_SEGMENTATION_REPORT LSR
						   WHERE LSR.PROCESS_ID = p_PROCESS_ID
							 AND LSR.REPORT_ID = p_LOAD_SEGMENTATION_REPORT_ID
							 AND LSR.ATTR_VAL_10 IS NOT NULL);
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_10_SEG_BY := 0;
		END;
	END IF;

	RETURN v_LOAD_SEG_REPORT_RUN_HEADER;
END CORRECT_SEG_BY_COLUMN_VALUES;
--------------------------------------------------------------------------------
FUNCTION GET_HEADER_LINE
	(
	p_PROCESS_ID				  IN NUMBER,
	p_LOAD_SEGMENTATION_REPORT_ID IN NUMBER,
	p_DELIMITER                   IN VARCHAR2,
	p_LOAD_SEG_REPORT_RUN_HEADER  IN OUT LOAD_SEG_REPORT_RUN_HEADER%ROWTYPE
	) RETURN VARCHAR2 AS
	v_TOTAL_NO_OF_INTERVALS			NUMBER(2);
	v_LINE 							VARCHAR2(32767);
	c_PROCEDURE_NAME   				CONSTANT VARCHAR2(30) := 'GET_HEADER_LINE';
	c_PROC_NAME						VARCHAR2(61) := c_PACKAGE_NAME || '.' || c_PROCEDURE_NAME;
BEGIN
	/* Build Column Header and return it */
	LOGS.LOG_DEBUG(c_PROC_NAME || ' BEGIN...');

	v_LINE := NULL;

	p_LOAD_SEG_REPORT_RUN_HEADER := CORRECT_SEG_BY_COLUMN_VALUES(p_PROCESS_ID, p_LOAD_SEGMENTATION_REPORT_ID);

	/* Total Number of Intervals for different Interval Types.
	   For Fall Back Day, Intervals will be averaged out and hence fixed.
	   For Spring Ahead Day, Intervals will be assigned 0. */
	IF p_LOAD_SEG_REPORT_RUN_HEADER.INTERVAL = CONSTANTS.INTERVAL_15_MINUTE THEN
		v_TOTAL_NO_OF_INTERVALS := 96;
	ELSIF p_LOAD_SEG_REPORT_RUN_HEADER.INTERVAL = CONSTANTS.INTERVAL_30_MINUTE THEN
		v_TOTAL_NO_OF_INTERVALS := 48;
	ELSIF p_LOAD_SEG_REPORT_RUN_HEADER.INTERVAL = CONSTANTS.INTERVAL_HOUR THEN
		v_TOTAL_NO_OF_INTERVALS := 24;
	ELSE
		v_TOTAL_NO_OF_INTERVALS := 1;
	END IF;

	/* Check if Attributes are segmented by and id so append to v_LINE */
	IF p_LOAD_SEG_REPORT_RUN_HEADER.ATTR_01_SEG_BY = 1 THEN
		v_LINE := v_LINE || TEXT_UTIL.FIX_STRING_FOR_CSV(p_LOAD_SEG_REPORT_RUN_HEADER.ATTR_NAME_01) || p_DELIMITER;
	END IF;
	IF p_LOAD_SEG_REPORT_RUN_HEADER.ATTR_02_SEG_BY = 1 THEN
		v_LINE := v_LINE || TEXT_UTIL.FIX_STRING_FOR_CSV(p_LOAD_SEG_REPORT_RUN_HEADER.ATTR_NAME_02) || p_DELIMITER;
	END IF;
	IF p_LOAD_SEG_REPORT_RUN_HEADER.ATTR_03_SEG_BY = 1 THEN
		v_LINE := v_LINE || TEXT_UTIL.FIX_STRING_FOR_CSV(p_LOAD_SEG_REPORT_RUN_HEADER.ATTR_NAME_03) || p_DELIMITER;
	END IF;
	IF p_LOAD_SEG_REPORT_RUN_HEADER.ATTR_04_SEG_BY = 1 THEN
		v_LINE := v_LINE || TEXT_UTIL.FIX_STRING_FOR_CSV(p_LOAD_SEG_REPORT_RUN_HEADER.ATTR_NAME_04) || p_DELIMITER;
	END IF;
	IF p_LOAD_SEG_REPORT_RUN_HEADER.ATTR_05_SEG_BY = 1 THEN
		v_LINE := v_LINE || TEXT_UTIL.FIX_STRING_FOR_CSV(p_LOAD_SEG_REPORT_RUN_HEADER.ATTR_NAME_05) || p_DELIMITER;
	END IF;
	IF p_LOAD_SEG_REPORT_RUN_HEADER.ATTR_06_SEG_BY = 1 THEN
		v_LINE := v_LINE || TEXT_UTIL.FIX_STRING_FOR_CSV(p_LOAD_SEG_REPORT_RUN_HEADER.ATTR_NAME_06) || p_DELIMITER;
	END IF;
	IF p_LOAD_SEG_REPORT_RUN_HEADER.ATTR_07_SEG_BY = 1 THEN
		v_LINE := v_LINE || TEXT_UTIL.FIX_STRING_FOR_CSV(p_LOAD_SEG_REPORT_RUN_HEADER.ATTR_NAME_07) || p_DELIMITER;
	END IF;
	IF p_LOAD_SEG_REPORT_RUN_HEADER.ATTR_08_SEG_BY = 1 THEN
		v_LINE := v_LINE || TEXT_UTIL.FIX_STRING_FOR_CSV(p_LOAD_SEG_REPORT_RUN_HEADER.ATTR_NAME_08) || p_DELIMITER;
	END IF;
	IF p_LOAD_SEG_REPORT_RUN_HEADER.ATTR_09_SEG_BY = 1 THEN
		v_LINE := v_LINE || TEXT_UTIL.FIX_STRING_FOR_CSV(p_LOAD_SEG_REPORT_RUN_HEADER.ATTR_NAME_09) || p_DELIMITER;
	END IF;
	IF p_LOAD_SEG_REPORT_RUN_HEADER.ATTR_10_SEG_BY = 1 THEN
		v_LINE := v_LINE || TEXT_UTIL.FIX_STRING_FOR_CSV(p_LOAD_SEG_REPORT_RUN_HEADER.ATTR_NAME_10) || p_DELIMITER;
	END IF;
	IF p_LOAD_SEG_REPORT_RUN_HEADER.ACCOUNT_IDENT_SEG_BY = 1 THEN
		v_LINE := v_LINE || TEXT_UTIL.FIX_STRING_FOR_CSV(SUBSTR(p_LOAD_SEG_REPORT_RUN_HEADER.ACCOUNT_IDENT_ATTR, INSTR(p_LOAD_SEG_REPORT_RUN_HEADER.ACCOUNT_IDENT_ATTR, 'Account'))) || p_DELIMITER;
	END IF;

	v_LINE := v_LINE || 'Date';

  	/* Append to v_LINE the interval numbers. 1 to Total Intervals. */
	FOR v_INTERVAL_NO IN 1..v_TOTAL_NO_OF_INTERVALS
	LOOP
		v_LINE := v_LINE || p_DELIMITER || v_INTERVAL_NO;
	END LOOP;

	LOGS.LOG_DEBUG(c_PROC_NAME || ' END...');

	RETURN v_LINE;
END GET_HEADER_LINE;
--------------------------------------------------------------------------------
PROCEDURE EXPORT_LOAD_SEG_REPORT_IMPL
	(
	p_PROCESS_ID				  IN NUMBER,
	p_LOAD_SEGMENTATION_REPORT_ID IN NUMBER
	) AS
	v_PROGRESS_STACK_RANGE			NUMBER(3);
	v_DELIMITER						VARCHAR2(1);
	v_RETAIL_OPS_CSV_DIR_OBJ		VARCHAR2(30);
	v_RECORD_COUNT					NUMBER(7) := 0;
	v_LINE							VARCHAR2(10000) := NULL;
	v_FILE_OUT_LOAD_SEG				UTL_FILE.FILE_TYPE := NULL;
	v_SYSTEM_DATE_FORMAT			SYSTEM_DICTIONARY.VALUE%TYPE;
	v_LOAD_SEG_REPORT_RUN_HEADER	LOAD_SEG_REPORT_RUN_HEADER%ROWTYPE;
	v_REPORT_NAME					LOAD_SEGMENTATION_DEF.REPORT_NAME%TYPE;
	v_REPORT_FILE_NAME				LOAD_SEGMENTATION_REPORT.REPORT_FILE_NAME%TYPE;
	c_PROCEDURE_NAME   				CONSTANT VARCHAR2(30) := 'EXPORT_LOAD_SEG_REPORT_IMPL';
	c_PROC_NAME						VARCHAR2(61) := c_PACKAGE_NAME || '.' || c_PROCEDURE_NAME;
BEGIN
	LOGS.LOG_DEBUG(p_EVENT_TEXT => c_PROC_NAME || ' BEGIN...');

	v_REPORT_NAME := GET_REPORT_NAME(p_LOAD_SEGMENTATION_REPORT_ID);

	SELECT COUNT(1)
	INTO v_RECORD_COUNT
	FROM LOAD_SEGMENTATION_REPORT LSR
	WHERE LSR.PROCESS_ID = p_PROCESS_ID
	  AND LSR.REPORT_ID = p_LOAD_SEGMENTATION_REPORT_ID;

	/* Generate Report File Name */
	$if $$UNIT_TEST_MODE = 1 $then
		v_REPORT_FILE_NAME := v_REPORT_NAME || '_' ||TO_CHAR(CONSTANTS.LOW_DATE, 'YYYYMMDDHH24MISS') || '.csv';
	$else
		v_REPORT_FILE_NAME := v_REPORT_NAME || '_' ||TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS') || '.csv';
	$end

	LOGS.SET_PROCESS_TARGET_PARAMETER('Export Load Segmentation Report', '<' || v_REPORT_FILE_NAME || '>');

	/* Update LOAD_SEGMENTATION_REPORT with Report File Name */
	UPDATE LOAD_SEGMENTATION_REPORT
	SET REPORT_FILE_NAME = v_REPORT_FILE_NAME
	WHERE PROCESS_ID = p_PROCESS_ID
	  AND REPORT_ID = p_LOAD_SEGMENTATION_REPORT_ID;

	/* Fetch Oracle Directoy Object Name from System Dictionary */
	v_RETAIL_OPS_CSV_DIR_OBJ := GET_DICTIONARY_VALUE(p_SETTING_NAME => 'Load Segmentation Output',
													p_MODULE => 'Export'
													);

	/* Fetch delimiter from System Dictionary */
	v_DELIMITER := GET_DICTIONARY_VALUE(p_SETTING_NAME => 'COMMA',
									    p_MODULE => 'Export',
									    p_KEY1 => 'DELIMITER'
									   );

	/* Fetch System Date Format from System Dictionary */
	v_SYSTEM_DATE_FORMAT := GET_DICTIONARY_VALUE(p_SETTING_NAME => 'Custom Format - Date',
												 p_MODULE => 'System',
												 p_KEY1 => 'System-Date-Time'
												);

	/* ----- Open CSV File ----- */
	OPEN_FILE(v_RETAIL_OPS_CSV_DIR_OBJ, v_REPORT_FILE_NAME, v_FILE_OUT_LOAD_SEG);

	/* ----- Write Header Row to File ----- */
	v_LINE := GET_HEADER_LINE(p_PROCESS_ID,
							  p_LOAD_SEGMENTATION_REPORT_ID,
							  v_DELIMITER,
							  v_LOAD_SEG_REPORT_RUN_HEADER);

	/* Total := Records in LOAD_SEGMENTATION_REPORT + One Header Row to track progress */
	v_PROGRESS_STACK_RANGE := LOGS.PUSH_PROGRESS_RANGE(v_RECORD_COUNT + 1);

	WRITE_LINE(v_FILE_OUT_LOAD_SEG, v_LINE);

	LOGS.INCREMENT_PROCESS_PROGRESS(p_RANGE_INDEX => v_PROGRESS_STACK_RANGE);

	IF v_RECORD_COUNT > 0 THEN
		/* ----- Start Fetching Report Data ----- */
		FOR v_CURSOR IN
			(SELECT CASE
						WHEN v_LOAD_SEG_REPORT_RUN_HEADER.INTERVAL = CONSTANTS.INTERVAL_HOUR
						 AND DATE_UTIL.IS_FALL_BACK_DATE(LSR.EFFECTIVE_DATE) = 1 THEN
							 (NVL(VAL_002, 0) + NVL(VAL_025, 0))/2
						WHEN v_LOAD_SEG_REPORT_RUN_HEADER.INTERVAL = CONSTANTS.INTERVAL_HOUR
						 AND DATE_UTIL.IS_SPRING_AHEAD_DATE(LSR.EFFECTIVE_DATE) = 1 THEN
							 CONSTANTS.NOT_ASSIGNED
						ELSE
							 NVL(VAL_002, 0)
						END AS RECALC_VAL_002,
					CASE
						WHEN v_LOAD_SEG_REPORT_RUN_HEADER.INTERVAL =  CONSTANTS.INTERVAL_30_MINUTE
						 AND DATE_UTIL.IS_FALL_BACK_DATE(LSR.EFFECTIVE_DATE) = 1 THEN
							 (NVL(VAL_003, 0) + NVL(VAL_049, 0))/2
						WHEN v_LOAD_SEG_REPORT_RUN_HEADER.INTERVAL =  CONSTANTS.INTERVAL_30_MINUTE
						 AND DATE_UTIL.IS_SPRING_AHEAD_DATE(LSR.EFFECTIVE_DATE) = 1 THEN
							 CONSTANTS.NOT_ASSIGNED
						ELSE
							 NVL(VAL_003, 0)
						END AS RECALC_VAL_003,
					CASE
						WHEN v_LOAD_SEG_REPORT_RUN_HEADER.INTERVAL =  CONSTANTS.INTERVAL_30_MINUTE
						 AND DATE_UTIL.IS_FALL_BACK_DATE(LSR.EFFECTIVE_DATE) = 1 THEN
							 (NVL(VAL_004, 0) + NVL(VAL_050, 0))/2
						WHEN v_LOAD_SEG_REPORT_RUN_HEADER.INTERVAL =  CONSTANTS.INTERVAL_30_MINUTE
						 AND DATE_UTIL.IS_SPRING_AHEAD_DATE(LSR.EFFECTIVE_DATE) = 1 THEN
							 CONSTANTS.NOT_ASSIGNED
						ELSE
							 NVL(VAL_004, 0)
						END AS RECALC_VAL_004,
					CASE
						WHEN v_LOAD_SEG_REPORT_RUN_HEADER.INTERVAL =  CONSTANTS.INTERVAL_15_MINUTE
						 AND DATE_UTIL.IS_FALL_BACK_DATE(LSR.EFFECTIVE_DATE) = 1 THEN
							 (NVL(VAL_005, 0) + NVL(VAL_097, 0))/2
						WHEN v_LOAD_SEG_REPORT_RUN_HEADER.INTERVAL =  CONSTANTS.INTERVAL_15_MINUTE
						 AND DATE_UTIL.IS_SPRING_AHEAD_DATE(LSR.EFFECTIVE_DATE) = 1 THEN
							 CONSTANTS.NOT_ASSIGNED
						ELSE
							 NVL(VAL_005, 0)
						END AS RECALC_VAL_005,
					CASE
						WHEN v_LOAD_SEG_REPORT_RUN_HEADER.INTERVAL =  CONSTANTS.INTERVAL_15_MINUTE
						 AND DATE_UTIL.IS_FALL_BACK_DATE(LSR.EFFECTIVE_DATE) = 1 THEN
							 (NVL(VAL_006, 0) + NVL(VAL_098, 0))/2
						WHEN v_LOAD_SEG_REPORT_RUN_HEADER.INTERVAL =  CONSTANTS.INTERVAL_15_MINUTE
						 AND DATE_UTIL.IS_SPRING_AHEAD_DATE(LSR.EFFECTIVE_DATE) = 1 THEN
							 CONSTANTS.NOT_ASSIGNED
						ELSE
							 NVL(VAL_006, 0)
						END AS RECALC_VAL_006,
					CASE
						WHEN v_LOAD_SEG_REPORT_RUN_HEADER.INTERVAL =  CONSTANTS.INTERVAL_15_MINUTE
						 AND DATE_UTIL.IS_FALL_BACK_DATE(LSR.EFFECTIVE_DATE) = 1 THEN
							 (NVL(VAL_007, 0) + NVL(VAL_099, 0))/2
						WHEN v_LOAD_SEG_REPORT_RUN_HEADER.INTERVAL =  CONSTANTS.INTERVAL_15_MINUTE
						 AND DATE_UTIL.IS_SPRING_AHEAD_DATE(LSR.EFFECTIVE_DATE) = 1 THEN
							 CONSTANTS.NOT_ASSIGNED
						ELSE
							 NVL(VAL_007, 0)
						END AS RECALC_VAL_007,
					CASE
						WHEN v_LOAD_SEG_REPORT_RUN_HEADER.INTERVAL =  CONSTANTS.INTERVAL_15_MINUTE
						 AND (DATE_UTIL.IS_FALL_BACK_DATE(LSR.EFFECTIVE_DATE) = 1)
						 THEN
							 (NVL(VAL_008, 0) + NVL(VAL_100, 0))/2
						WHEN v_LOAD_SEG_REPORT_RUN_HEADER.INTERVAL =  CONSTANTS.INTERVAL_15_MINUTE
						 AND DATE_UTIL.IS_SPRING_AHEAD_DATE(LSR.EFFECTIVE_DATE) = 1
						 THEN
							 CONSTANTS.NOT_ASSIGNED
						ELSE
							 NVL(VAL_008, 0)
						END AS RECALC_VAL_008,
				LSR.*
			FROM
				LOAD_SEGMENTATION_REPORT LSR
			WHERE LSR.PROCESS_ID = p_PROCESS_ID
			  AND LSR.REPORT_ID = p_LOAD_SEGMENTATION_REPORT_ID
			ORDER BY EFFECTIVE_DATE NULLS LAST, ATTR_VAL_01 NULLS LAST, ATTR_VAL_02 NULLS LAST, ATTR_VAL_03 NULLS LAST,
					 ATTR_VAL_04 NULLS LAST, ATTR_VAL_05 NULLS LAST, ATTR_VAL_06 NULLS LAST, ATTR_VAL_07 NULLS LAST,
					 ATTR_VAL_08 NULLS LAST, ATTR_VAL_09 NULLS LAST, ATTR_VAL_10 NULLS LAST, ACCOUNT_IDENT NULLS LAST)
		LOOP
			v_LINE := NULL;

			/* Check if Attributes are segmented by. If yes append Attribute Values to v_LINE */
			IF v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_01_SEG_BY = 1 THEN
			   v_LINE := v_LINE || TEXT_UTIL.FIX_STRING_FOR_CSV(v_CURSOR.ATTR_VAL_01) || v_DELIMITER;
			END IF;
			IF v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_02_SEG_BY = 1 THEN
			   v_LINE := v_LINE || TEXT_UTIL.FIX_STRING_FOR_CSV(v_CURSOR.ATTR_VAL_02) || v_DELIMITER;
			END IF;
			IF v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_03_SEG_BY = 1 THEN
			   v_LINE := v_LINE || TEXT_UTIL.FIX_STRING_FOR_CSV(v_CURSOR.ATTR_VAL_03) || v_DELIMITER;
			END IF;
			IF v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_04_SEG_BY = 1 THEN
			   v_LINE := v_LINE || TEXT_UTIL.FIX_STRING_FOR_CSV(v_CURSOR.ATTR_VAL_04) || v_DELIMITER;
			END IF;
			IF v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_05_SEG_BY = 1 THEN
			   v_LINE := v_LINE || TEXT_UTIL.FIX_STRING_FOR_CSV(v_CURSOR.ATTR_VAL_05) || v_DELIMITER;
			END IF;
			IF v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_06_SEG_BY = 1 THEN
			   v_LINE := v_LINE || TEXT_UTIL.FIX_STRING_FOR_CSV(v_CURSOR.ATTR_VAL_06) || v_DELIMITER;
			END IF;
			IF v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_07_SEG_BY = 1 THEN
			   v_LINE := v_LINE || TEXT_UTIL.FIX_STRING_FOR_CSV(v_CURSOR.ATTR_VAL_07) || v_DELIMITER;
			END IF;
			IF v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_08_SEG_BY = 1 THEN
			   v_LINE := v_LINE || TEXT_UTIL.FIX_STRING_FOR_CSV(v_CURSOR.ATTR_VAL_08) || v_DELIMITER;
			END IF;
			IF v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_09_SEG_BY = 1 THEN
			   v_LINE := v_LINE || TEXT_UTIL.FIX_STRING_FOR_CSV(v_CURSOR.ATTR_VAL_09) || v_DELIMITER;
			END IF;
			IF v_LOAD_SEG_REPORT_RUN_HEADER.ATTR_10_SEG_BY = 1 THEN
			   v_LINE := v_LINE || TEXT_UTIL.FIX_STRING_FOR_CSV(v_CURSOR.ATTR_VAL_10) || v_DELIMITER;
			END IF;
			IF v_LOAD_SEG_REPORT_RUN_HEADER.ACCOUNT_IDENT_SEG_BY = 1 THEN
			   v_LINE := v_LINE || TEXT_UTIL.FIX_STRING_FOR_CSV(v_CURSOR.ACCOUNT_IDENT) || v_DELIMITER;
			END IF;

			/* Append DATE to v_LINE */
			v_LINE := v_LINE || TO_CHAR(v_CURSOR.EFFECTIVE_DATE, v_SYSTEM_DATE_FORMAT);

			/* Append Interval Data to v_LINE */
			v_LINE := v_LINE || v_DELIMITER || TO_CHAR(NVL(v_CURSOR.VAL_001, 0), c_VAL_FORMAT);

			IF v_LOAD_SEG_REPORT_RUN_HEADER.INTERVAL IN (CONSTANTS.INTERVAL_HOUR, CONSTANTS.INTERVAL_30_MINUTE, CONSTANTS.INTERVAL_15_MINUTE) THEN
				v_LINE := v_LINE || v_DELIMITER ||
									TO_CHAR(v_CURSOR.RECALC_VAL_002, c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(v_CURSOR.RECALC_VAL_003, c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(v_CURSOR.RECALC_VAL_004, c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(v_CURSOR.RECALC_VAL_005, c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(v_CURSOR.RECALC_VAL_006, c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(v_CURSOR.RECALC_VAL_007, c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(v_CURSOR.RECALC_VAL_008, c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_009, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_010, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_011, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_012, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_013, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_014, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_015, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_016, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_017, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_018, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_019, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_020, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_021, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_022, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_023, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_024, 0), c_VAL_FORMAT);
			END IF;

			IF v_LOAD_SEG_REPORT_RUN_HEADER.INTERVAL IN (CONSTANTS.INTERVAL_30_MINUTE, CONSTANTS.INTERVAL_15_MINUTE) THEN
				v_LINE := v_LINE || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_025, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_026, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_027, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_028, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_029, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_030, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_031, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_032, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_033, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_034, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_035, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_036, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_037, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_038, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_039, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_040, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_041, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_042, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_043, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_044, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_045, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_046, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_047, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_048, 0), c_VAL_FORMAT);
			END IF;

			IF v_LOAD_SEG_REPORT_RUN_HEADER.INTERVAL IN (CONSTANTS.INTERVAL_15_MINUTE) THEN
				v_LINE := v_LINE || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_049, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_050, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_051, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_052, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_053, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_054, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_055, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_056, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_057, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_058, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_059, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_060, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_061, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_062, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_063, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_064, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_065, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_066, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_067, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_068, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_069, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_070, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_071, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_072, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_073, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_074, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_075, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_076, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_077, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_078, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_079, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_080, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_081, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_082, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_083, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_084, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_085, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_086, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_087, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_088, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_089, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_090, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_091, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_092, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_093, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_094, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_095, 0), c_VAL_FORMAT) || v_DELIMITER ||
									TO_CHAR(NVL(v_CURSOR.VAL_096, 0), c_VAL_FORMAT);
			END IF;

			WRITE_LINE(v_FILE_OUT_LOAD_SEG, v_LINE);

			LOGS.INCREMENT_PROCESS_PROGRESS(p_RANGE_INDEX => v_PROGRESS_STACK_RANGE);
		END LOOP;
		/* ----- End Fetching Report Data ----- */
	END IF;

	LOGS.POP_PROGRESS_RANGE(v_PROGRESS_STACK_RANGE);

	/* ----- Close File ----- */
	CLOSE_FILE(v_FILE_OUT_LOAD_SEG);

	LOGS.LOG_INFO(p_EVENT_TEXT => 'Success writing <' || v_REPORT_FILE_NAME || '>',
				  p_PROCEDURE_NAME => c_PROC_NAME,
				  p_STEP_NAME => 'Export');

	LOGS.LOG_DEBUG(p_EVENT_TEXT => c_PROC_NAME || '...END');

EXCEPTION
	WHEN OTHERS THEN
		IF UTL_FILE.IS_OPEN(v_FILE_OUT_LOAD_SEG) THEN
			CLOSE_FILE(v_FILE_OUT_LOAD_SEG);
		END IF;

		ERRS.LOG_AND_RAISE(p_EXTRA_MESSAGE => 'Failure writing <' || v_REPORT_FILE_NAME || '>',
						   p_LOG_LEVEL => LOGS.c_LEVEL_FATAL
						  );
END EXPORT_LOAD_SEG_REPORT_IMPL;
--------------------------------------------------------------------------------
PROCEDURE CLEAN_LOAD_SEG_REPORT_IMPL
	(
	p_PROCESS_ID				  IN NUMBER,
	p_LOAD_SEGMENTATION_REPORT_ID IN NUMBER
	) AS
	v_REPORT_NAME 		LOAD_SEGMENTATION_DEF.REPORT_NAME%TYPE;
	c_PROCEDURE_NAME   	CONSTANT VARCHAR2(30) := 'CLEAN_LOAD_SEG_REPORT_IMPL';
	c_PROC_NAME			VARCHAR2(61) := c_PACKAGE_NAME || '.' || c_PROCEDURE_NAME;
BEGIN

	LOGS.LOG_DEBUG(p_EVENT_TEXT => c_PROC_NAME || 'BEGIN...');

	v_REPORT_NAME := GET_REPORT_NAME(p_LOAD_SEGMENTATION_REPORT_ID);

	SAVEPOINT DELETE_LOAD_SEG_REPORT_DATA;

	DELETE FROM LOAD_SEG_REPORT_RUN_HEADER
	WHERE PROCESS_ID = p_PROCESS_ID
	  AND REPORT_ID = p_LOAD_SEGMENTATION_REPORT_ID;

	LOGS.LOG_INFO(p_EVENT_TEXT => 'Successful in cleaning up Load Segmentation data for report <' || v_REPORT_NAME || '>',
				  p_PROCEDURE_NAME => c_PROC_NAME,
				  p_STEP_NAME => 'Cleanup');

	LOGS.LOG_DEBUG(p_EVENT_TEXT => c_PROC_NAME || '...END');

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_RAISE(p_EXTRA_MESSAGE => 'Failure in cleaning up Load Segmentation data.'
				  						   || ' Report Name <' || v_REPORT_NAME || '>',
						   p_SAVEPOINT_NAME => 'DELETE_LOAD_SEG_REPORT_DATA');
END CLEAN_LOAD_SEG_REPORT_IMPL;
--------------------------------------------------------------------------------
PROCEDURE EXPORT_LOAD_SEG_REPORT
	(
	p_PROCESS_ID				  IN NUMBER,
	p_LOAD_SEGMENTATION_REPORT_ID IN NUMBER,
	p_PROCESS_STATUS			  OUT NUMBER,
	p_MESSAGE					  OUT VARCHAR2
	) AS
BEGIN
	LOGS.START_PROCESS(p_PROCESS_NAME => 'Export Load Segmentation Report',
					   p_EVENT_LEVEL => LOGS.c_LEVEL_ALL);

	EXPORT_LOAD_SEG_REPORT_IMPL(p_PROCESS_ID, p_LOAD_SEGMENTATION_REPORT_ID);

	p_MESSAGE := 'Load Segmentation Export Completed Successfully.';

	LOGS.STOP_PROCESS(p_MESSAGE, p_PROCESS_STATUS);
	COMMIT;
EXCEPTION
	WHEN OTHERS THEN
		ERRS.ABORT_PROCESS(p_EXTRA_MESSAGE => 'Failure in exporting Load Segmentation data.'
				  						   || ' Report Name <' || GET_REPORT_NAME(p_LOAD_SEGMENTATION_REPORT_ID) || '>');
END EXPORT_LOAD_SEG_REPORT;
--------------------------------------------------------------------------------
PROCEDURE CLEAN_LOAD_SEG_REPORT
	(
	p_PROCESS_ID				  IN NUMBER,
	p_LOAD_SEGMENTATION_REPORT_ID IN NUMBER,
	p_PROCESS_STATUS			  OUT NUMBER,
	p_MESSAGE					  OUT VARCHAR2
	) AS
BEGIN
	LOGS.START_PROCESS(p_PROCESS_NAME => 'Cleanup Load Segmentation Report Staging Tables',
					   p_EVENT_LEVEL => LOGS.c_LEVEL_ALL);

	CLEAN_LOAD_SEG_REPORT_IMPL(p_PROCESS_ID, p_LOAD_SEGMENTATION_REPORT_ID);

	p_MESSAGE := 'Load Segmentation Cleanup Completed Successfully.';

	LOGS.STOP_PROCESS(p_MESSAGE, p_PROCESS_STATUS);
	COMMIT;
EXCEPTION
	WHEN OTHERS THEN
		ERRS.ABORT_PROCESS(p_EXTRA_MESSAGE => 'Failure in cleaning up Load Segmentation data.'
				  						   || ' Report Name <' || GET_REPORT_NAME(p_LOAD_SEGMENTATION_REPORT_ID) || '>');
END CLEAN_LOAD_SEG_REPORT;
--------------------------------------------------------------------------------
PROCEDURE RLSR_PROCESS_REPORTS
(
	p_BEGIN_DATE 		IN DATE,
	p_END_DATE 			IN DATE,
	p_TIME_ZONE 		IN VARCHAR2,
	p_RUN_TYPE_ID 		IN NUMBER,
	p_INTERVAL 			IN VARCHAR2,
	p_REPORT_IDS 		IN NUMBER_COLLECTION,
	p_PROCESS_ID 		OUT VARCHAR2,
	p_PROCESS_STATUS 	OUT NUMBER,
	p_MESSAGE 			OUT VARCHAR2,
	p_STAGE_DATA_FLG 	IN NUMBER,
	p_EXPORT_FILE_FLG 	IN NUMBER,
	p_CLEANUP_DATA_FLG 	IN NUMBER,
	p_PROCESS_NAME 		IN VARCHAR2,
	p_ADJ_BEGIN_DATE	IN DATE,
	p_ADJ_END_DATE		IN DATE,
	p_CUT_BEGIN_DATE 	IN DATE,
	p_CUT_END_DATE 		IN DATE,
	p_SERVICE_CODE 		IN VARCHAR2,
	p_SCENARIO_ID 		IN NUMBER)
IS
	v_REPORT_NAME               LOAD_SEGMENTATION_DEF.REPORT_NAME%TYPE;
	v_STEP_CNT                  PLS_INTEGER := 0;
	c_PROCEDURE_NAME CONSTANT	VARCHAR2(30) := 'RLSR_PROCESS_REPORTS';
	v_LOAD_SEG_HEADER_REC LOAD_SEG_REPORT_RUN_HEADER%ROWTYPE;  -- a new recordtype
	c_PROC_NAME		 CONSTANT	VARCHAR2(61) := c_PACKAGE_NAME || '.' || c_PROCEDURE_NAME;
	v_IS_STAGE_SUCCESSFUL		BOOLEAN := FALSE;
	v_IS_EXPORT_SUCCESSFUL		BOOLEAN := FALSE;
	v_IS_CLEANUP_SUCCESSFUL		BOOLEAN := FALSE;
BEGIN
	-- Establish the SAVEPOINT
	SAVEPOINT RLSR;

	-- Loop the reports, one by one
	FOR I IN 1..p_REPORT_IDS.COUNT LOOP
		-- Do not start a fresh process for 1st iteration alone as RUN_LOAD_SEGMENTATION_REPORT
		-- would have started it. For subsequent iterations, do.
		IF I > 1 THEN
			RLSR_START_PROCESS_LOG(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_RUN_TYPE_ID, p_INTERVAL, p_PROCESS_NAME);
		END IF;

		-- Set the additional paramter -- REPORT_ID
        LOGS.SET_PROCESS_TARGET_PARAMETER('REPORT_ID', p_REPORT_IDS(I));
		LOGS.LOG_DEBUG('Processing Report ' || I || ': ' || p_REPORT_IDS(I));

		-- The tables below are work tables for the staging process, and need to be clean out after each report.
		-- Modified from DELETE to TRUNCATE
		EXECUTE IMMEDIATE 'TRUNCATE TABLE LOAD_SEG_ACCOUNTS_TMP';
		EXECUTE IMMEDIATE 'TRUNCATE TABLE LOAD_SEG_AGG_ACCOUNTS_TMP';
		LOGS.LOG_DEBUG('LOAD_SEG_* Temp tables truncated', c_PROC_NAME);

		p_PROCESS_ID := TO_CHAR(LOGS.CURRENT_PROCESS_ID);
		v_STEP_CNT := LOGS.PUSH_PROGRESS_RANGE(p_MAX_VALUE => 3);

		-- Refactored Header
		PUT_LOAD_SEG_REPORT_RUN_HEADER( p_BEGIN_DATE, p_END_DATE, p_RUN_TYPE_ID, p_INTERVAL, p_REPORT_IDS(I), p_PROCESS_ID,
										v_LOAD_SEG_HEADER_REC);
		LOGS.LOG_DEBUG('LOAD_SEG_REPORT_RUN_HEADER table updated for report  "'|| v_REPORT_NAME ||'"; for PROCESS_ID = ' ||
						p_REPORT_IDS(I));

		IF p_STAGE_DATA_FLG = 1 THEN
			BEGIN
				LOGS.LOG_DEBUG( p_EVENT_TEXT	 => 'Invoking STAGE_REPORT_DATA for report: '||v_REPORT_NAME);

				-- Stage the report
				STAGE_REPORT_DATA(p_PROCESS_ID,
								  p_REPORT_IDS(I),
								  p_ADJ_BEGIN_DATE,
								  p_ADJ_END_DATE,
								  p_CUT_BEGIN_DATE,
								  p_CUT_END_DATE,
								  p_INTERVAL,
								  p_TIME_ZONE,
								  p_SERVICE_CODE,
								  p_SCENARIO_ID,
								  v_LOAD_SEG_HEADER_REC); -- Added this rowtype param to avoid requery


				v_IS_STAGE_SUCCESSFUL := TRUE;
			EXCEPTION
				WHEN OTHERS THEN
					v_IS_STAGE_SUCCESSFUL := FALSE;
			END;
		END IF; -- Stage Data

		IF p_EXPORT_FILE_FLG = 1 AND v_IS_STAGE_SUCCESSFUL THEN
			BEGIN
				LOGS.LOG_DEBUG( p_EVENT_TEXT	 => 'Export File for report: '||v_REPORT_NAME);

				EXPORT_LOAD_SEG_REPORT_IMPL(p_PROCESS_ID, p_REPORT_IDS(I));

				v_IS_EXPORT_SUCCESSFUL := TRUE;
			EXCEPTION
				WHEN OTHERS THEN
					v_IS_EXPORT_SUCCESSFUL := FALSE;
			END;
		END IF; -- Export File

		IF p_CLEANUP_DATA_FLG = 1 THEN
			BEGIN
				LOGS.LOG_DEBUG(' Clean-up segmentation report data for report:  '||v_REPORT_NAME);

				CLEAN_LOAD_SEG_REPORT_IMPL(p_PROCESS_ID, p_REPORT_IDS(I));

				v_IS_CLEANUP_SUCCESSFUL := TRUE;
			EXCEPTION
				WHEN OTHERS THEN
					v_IS_CLEANUP_SUCCESSFUL := FALSE;
			END;
		END IF; -- Cleanup Data

		-- Set the LAST_RUN_DATE for the report
		-- Remove the LAST_RUN_DATE from LSD table and make the GUI query it instead.
		-- Integrate UPDATE and the SELECT into one query
		UPDATE LOAD_SEGMENTATION_DEF LSD
		SET   LSD.PROCESS_ID    = p_PROCESS_ID
		WHERE LSD.REPORT_ID = p_REPORT_IDS(i)
		RETURNING LSD.REPORT_NAME INTO v_REPORT_NAME;

		COMMIT; 		-- After each report has completed, then commit the data in the staging table.
		SAVEPOINT RLSR; -- Reestablish the savepoint after each commit.

		LOGS.LOG_DEBUG('LOAD_SEGMENTATION_DEF table updated for report "'|| v_REPORT_NAME ||'"; PROCESS_ID = ' ||
						p_REPORT_IDS(I));

		IF v_IS_STAGE_SUCCESSFUL AND v_IS_EXPORT_SUCCESSFUL AND v_IS_CLEANUP_SUCCESSFUL THEN
			p_MESSAGE := p_PROCESS_NAME || ' Completed Successfully.';
		ELSE
			p_MESSAGE := p_PROCESS_NAME || ' Completed With Errors.';
		END IF;

		LOGS.STOP_PROCESS(p_PROCESS_STATUS => p_PROCESS_STATUS,
						  p_FINISH_TEXT    => p_MESSAGE);
    END LOOP;-- Reports LOOP

END RLSR_PROCESS_REPORTS;
-----------------------------------------------------------------
PROCEDURE RUN_LOAD_SEGMENTATION_REPORT (
   p_BEGIN_DATE        IN DATE,
   p_END_DATE          IN DATE,
   p_TIME_ZONE         IN VARCHAR2,
   p_RUN_TYPE_ID       IN NUMBER,
   p_INTERVAL          IN VARCHAR2,
   p_REPORT_IDS        IN NUMBER_COLLECTION,
   p_PROCESS_ID       OUT VARCHAR2,
   p_PROCESS_STATUS   OUT NUMBER,
   p_MESSAGE          OUT VARCHAR2,
   p_STAGE_DATA_FLG    IN NUMBER DEFAULT 1,
   p_EXPORT_FILE_FLG   IN NUMBER DEFAULT 1,
   p_CLEANUP_DATA_FLG  IN NUMBER DEFAULT 1
   )
AS
	c_PROCEDURE_NAME CONSTANT 	VARCHAR2(30) := 'RUN_LOAD_SEGMENTATION_REPORT';
	c_PROCESS_NAME	CONSTANT 	PROCESS_LOG.PROCESS_NAME%TYPE := 'Load Segmentation Reporting';
	v_ADJ_BEGIN_DATE			DATE;
	v_ADJ_END_DATE				DATE;
	v_CUT_BEGIN_DATE            DATE;
	v_CUT_END_DATE              DATE;
	v_SERVICE_CODE              VARCHAR2(1);
	v_SCENARIO_ID               NUMBER(9);
	c_PROC_NAME					VARCHAR2(61) := c_PACKAGE_NAME || '.' || c_PROCEDURE_NAME;
BEGIN
	-- Initialize the process
	RLSR_START_PROCESS_LOG(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_RUN_TYPE_ID, p_INTERVAL, c_PROCESS_NAME);

	-- Validate the inputs
	RLSR_VALIDATE_DATA(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_RUN_TYPE_ID, p_INTERVAL, p_REPORT_IDS(1));
	LOGS.LOG_DEBUG('Successfully validated input data', c_PROC_NAME);

	-- Get CUT_DATE_RANGE
	RLSR_GET_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_ADJ_BEGIN_DATE,
						v_ADJ_END_DATE, v_CUT_BEGIN_DATE, v_CUT_END_DATE);
	LOGS.LOG_DEBUG(p_EVENT_TEXT => 'After RLSR_GET_DATE_RANGE: CUT_BEGIN_DATE = ' ||
									TEXT_UTIL.TO_CHAR_TIME(v_CUT_BEGIN_DATE) || '; CUT_END_DATE = ' ||
									TEXT_UTIL.TO_CHAR_TIME(v_CUT_END_DATE) || '; ADJ_BEGIN_DATE = ' ||
									TEXT_UTIL.TO_CHAR_DATE(v_ADJ_BEGIN_DATE) || '; ADJ_END_DATE = ' ||
									TEXT_UTIL.TO_CHAR_DATE(v_ADJ_END_DATE),
				   p_PROCEDURE_NAME => c_PROC_NAME
				   );

	-- Verify if Data Exists in SDT. It raises errors that are GUI ready. So no handling reqd.
	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, p_BEGIN_DATE, p_END_DATE);
	LOGS.LOG_DEBUG(p_EVENT_TEXT => 'System Date Time populated for date-range.', p_PROCEDURE_NAME => c_PROC_NAME);

	-- Validate the run type to get SERVICE_CODE and SCENARIO_ID
	LOAD_MANAGEMENT_UI.INTERPRET_RUN_TYPE(p_RUN_TYPE_ID, v_SERVICE_CODE, v_SCENARIO_ID);
	LOGS.LOG_DEBUG(p_EVENT_TEXT 	=> 'SERVICE_CODE = ' || v_SERVICE_CODE || '; SCENARIO_ID = ' || v_SCENARIO_ID,
				   p_PROCEDURE_NAME => c_PROC_NAME);

	-- Process reports one by one
	LOGS.LOG_INFO(p_EVENT_TEXT => 'Preliminary checks completed. Individual reports to be processed in a loop',
				  p_PROCEDURE_NAME => c_PROC_NAME);
	RLSR_PROCESS_REPORTS(	p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_RUN_TYPE_ID, p_INTERVAL, p_REPORT_IDS, p_PROCESS_ID,
							p_PROCESS_STATUS, p_MESSAGE, p_STAGE_DATA_FLG, p_EXPORT_FILE_FLG, p_CLEANUP_DATA_FLG,
							c_PROCESS_NAME, v_ADJ_BEGIN_DATE, v_ADJ_END_DATE, v_CUT_BEGIN_DATE, v_CUT_END_DATE,
							v_SERVICE_CODE, v_SCENARIO_ID
						);

EXCEPTION
	WHEN OTHERS THEN
		p_MESSAGE := 'Errors occurred at process: ' || c_PROCESS_NAME || '. Check Process Log for details';
END RUN_LOAD_SEGMENTATION_REPORT;
--------------------------------------------------------------------------------
BEGIN
	g_ENTITY_ATTR_ACCOUNT := GET_ACCOUNT_ATT_ID();
END LOAD_SEGMENTATION_UI;
/
