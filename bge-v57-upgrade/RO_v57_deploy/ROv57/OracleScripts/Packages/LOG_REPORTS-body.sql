CREATE OR REPLACE PACKAGE LOG_REPORTS IS
-- $Revision: 1.1 $

-- Author  : AHUSSAIN
-- Created : 1/28/2008 2:41:33 PM
-- Purpose : Process Log report

FUNCTION WHAT_VERSION RETURN VARCHAR2;

-- Query for distinct process names where process start/stop date overlap the specified
-- begin and end dates.
PROCEDURE GET_PROCESS_NAMES
	(
	p_BEGIN_DATE        IN DATE,
	p_END_DATE          IN DATE,
	p_INCLUDE_SESSIONS  IN NUMBER,
	p_PROCESS_NAME_TEXT IN VARCHAR2,
	p_CURSOR            OUT GA.REFCURSOR
	);

-- Gather list of user-names, including an <ALL> entry. If current user does not have
-- permission to view processes for all users, then the list will contain only a single
-- entry representing the current user only.
PROCEDURE GET_USER_LIST(p_CURSOR OUT GA.REFCURSOR);

-- Get summary grid of processes. If the current user does not have permission to view
-- session information (last few fields in the PROCESSES table) then those columns in the
-- cursor will be null. This routine must further validate the p_PROCESS_OWNER input to
-- make sure that, even if another user or <ALL> is specified, that the only the user's
-- processes are returned in the event that the current user does not have permission to
-- view all processes.
PROCEDURE GET_PROCESSES
	(
	p_BEGIN_DATE          IN DATE,
	p_END_DATE            IN DATE,
	p_INCLUDE_SESSIONS    IN NUMBER,
	p_PROCESS_NAME_FILTER IN VARCHAR2,
	p_PROCESS_OWNER_ID    IN NUMBER,
	p_PROCESS_STATE       IN VARCHAR2,
	p_CURSOR              OUT GA.REFCURSOR
	);

FUNCTION GET_SOURCE_STRING
	(
	p_SOURCE_NAME		IN PROCESS_LOG_EVENT.SOURCE_NAME%TYPE,
	p_SOURCE_DOMAIN_ID	IN PROCESS_LOG_EVENT.SOURCE_DOMAIN_ID%TYPE,
	p_SOURCE_ENTITY_ID	IN PROCESS_LOG_EVENT.SOURCE_ENTITY_ID%TYPE,
	p_SOURCE_DATE		IN PROCESS_LOG_EVENT.SOURCE_DATE%TYPE
	) RETURN VARCHAR2;

-- Get detail grid with process events. This grid must validate the p_PROCESS_ID input
-- if it indicates a process owner by another user, but the current user does not have
-- permission to view all processes, then return an empty cursor.
-- This table will need to do a UNION ALL from PROCESS_EVENTS, PROCESS_TRACE and
-- PROCESS_TEMP_TRACE to get all data and then it will need to order by
-- EVENT_TIMESTAMP and EVENT_ID to interleave records from these three sources correctly.
-- The routine should fetch all records where EVENT_LEVEL >= p_LOG_LEVEL
PROCEDURE GET_PROCESS_EVENTS
	(
	p_PROCESS_ID   IN VARCHAR2,
	p_LOG_LEVEL_ID IN NUMBER,
	p_CURSOR       OUT GA.REFCURSOR
	);

PROCEDURE GET_PROCESS_DEBUG_EVENTS
	(
	p_PROCESS_ID IN VARCHAR2,
	p_MESSAGE    OUT VARCHAR2,
	p_CONTENTS	 OUT CLOB
	);

-- Gets the list of details associated with a log event. The p_EVENT_ID input will need
-- to be validated to make sure it belongs to a process to which the current user has
-- access.
PROCEDURE GET_EVENT_DETAILS
	(
	p_EVENT_ID IN VARCHAR2,
	p_CURSOR   OUT GA.REFCURSOR
	);

-- Gets the contents for an event attachment. The p_EVENT_ID input will need to be
-- validated to make sure it belongs to a process to which the current user has access.
PROCEDURE GET_EVENT_DETAIL_CONTENTS
	(
	p_EVENT_ID           IN VARCHAR2,
	p_DETAIL_TYPE        IN VARCHAR2,
	p_CONTENTS           OUT CLOB,
	p_CONTENTS_EXTENSION OUT VARCHAR2
	);

FUNCTION GET_EXTENSION_FOR_CONTENTTYPE(p_CONTENTTYPE IN VARCHAR2) RETURN VARCHAR2;

-- Gets the message details for a particular pre-defined message. The cursor should
-- return a ¿transposed¿ one-row grid for the message. This means it will have two
-- columns: the field name and its value. This way the message will be readable in a grid
-- (instead of having only one row that requires substantial horizontal real estate).
PROCEDURE GET_MESSAGE_DETAILS
	(
	p_MESSAGE_ID IN NUMBER,
	p_CURSOR     OUT GA.REFCURSOR
	);

-- Tuncates the real table (PROCESS_TRACE). Throw an exception if the current user does
-- not have permission to truncate persistent trace data.
PROCEDURE TRUNCATE_TRACE;

-- Truncates the global temporary table for this session (PROCESS_TEMP_TRACE)
PROCEDURE TRUNCATE_TEMP_TRACE;

-- User must own the specified process or have admin privileges. If process cannot be
-- terminated or user has insufficient privileges, an exception will be raised.
PROCEDURE TERMINATE_PROCESS(p_PROCESS_ID IN VARCHAR2);

-- Gets the list of Log Levels
PROCEDURE GET_LOG_LEVELS(p_CURSOR OUT GA.REFCURSOR);
-- Gets the list of Status Levels
PROCEDURE GET_STATUS_LEVELS(p_CURSOR OUT GA.REFCURSOR);
-- Gets the value of a target parameter named BEGIN_DATE for the specified process
FUNCTION GET_TARGET_BEGIN_DATE(p_PROCESS_ID IN NUMBER) RETURN VARCHAR2;

-- Gets the value of a target parameter named END_DATE for the specified process
FUNCTION GET_TARGET_END_DATE(p_PROCESS_ID IN NUMBER) RETURN VARCHAR2;

-- Gets the values of all target parameters other than BEGIN_DATE and END_DATE -
-- for the specified process and combines them into a semi-colon-separated string of
-- name=value pairs
FUNCTION GET_OTHER_TARGET_PARAMETERS(p_PROCESS_ID IN NUMBER) RETURN VARCHAR2;

-- Wrapper Functions/Procedures used by the UI Logging Dialog since we cannot access Boolean types via jdbc
FUNCTION CURRENT_LOG_LEVEL_UI RETURN PLS_INTEGER;
FUNCTION KEEPING_EVENT_DETAILS_UI RETURN NUMBER;
FUNCTION PERSISTING_TRACE_UI RETURN NUMBER;
PROCEDURE SET_CURRENT_LOG_LEVEL_UI(p_LEVEL IN PLS_INTEGER);
PROCEDURE SET_KEEPING_EVENT_DETAILS_UI(p_KEEP_THEM IN NUMBER);
PROCEDURE SET_PERSISTING_TRACE_UI(p_PERSIST IN NUMBER);

-- Returns a string label for the associated LOGS level
FUNCTION GET_LOG_LEVEL_STRING(p_LOG_LEVEL NUMBER) RETURN VARCHAR2;
-- Returns a string label for the associated STATUS level
FUNCTION GET_STATUS_LEVEL_STRING(p_STATUS_LEVEL NUMBER, p_WAS_TERMINATED IN NUMBER) RETURN VARCHAR2;
FUNCTION GET_STATUS_LEVEL_STRING(p_STATUS_LEVEL NUMBER) RETURN VARCHAR2;

-- Get the process finish message and possibly error message
PROCEDURE GET_PROCESS_STATUS
	(
	p_PROCESS_CID IN VARCHAR2,
	p_CONTENTS OUT VARCHAR2
	);

PROCEDURE GET_PROCESSES_BY_IDS
	(
	p_PROCESS_IDS		  IN NUMBER_COLLECTION,
	p_CURSOR              OUT GA.REFCURSOR
	);

END LOG_REPORTS;
/
CREATE OR REPLACE PACKAGE BODY LOG_REPORTS IS

-- Process State String Literals
c_PROCESS_STATE_ALL      CONSTANT VARCHAR2(8) := 'All';
c_PROCESS_STATE_RUNNING  CONSTANT VARCHAR2(8) := 'Running';
c_PROCESS_STATE_FINISHED CONSTANT VARCHAR2(8) := 'Finished';

-- Log Level String Literals
g_LEVEL_STRING_FATAL     VARCHAR2(10);
g_LEVEL_STRING_ERROR     VARCHAR2(10);
g_LEVEL_STRING_WARN      VARCHAR2(10);
g_LEVEL_STRING_NOTICE    VARCHAR2(10);
g_LEVEL_STRING_INFO      VARCHAR2(10);
g_LEVEL_STRING_MO_INFO   VARCHAR2(10);
g_LEVEL_STRING_MAX_INFO  VARCHAR2(10);
g_LEVEL_STRING_DEBUG     VARCHAR2(10);
g_LEVEL_STRING_MO_DEBUG  VARCHAR2(10);
g_LEVEL_STRING_MAX_DEBUG VARCHAR2(10);

-- 'Terminated' String to use when the WAS_TERMINATED column = 1
c_LEVEL_STRING_TERMINATED CONSTANT VARCHAR2(10) := 'Terminated';

-- 'Success' String to use when there are no messages >= Notice
c_LEVEL_STRING_SUCCESS CONSTANT VARCHAR2(10) := 'Success';

----------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR2 IS
BEGIN
    RETURN '$Revision: 1.1 $';
END WHAT_VERSION;
---------------------------------------------------------------------------------------------------
FUNCTION GET_LOG_LEVEL_STRING(p_LOG_LEVEL NUMBER) RETURN VARCHAR2 AS
v_LEVEL_STRING VARCHAR2(10);
BEGIN
	CASE
	   WHEN p_LOG_LEVEL = LOGS.c_LEVEL_FATAL THEN
		v_LEVEL_STRING := g_LEVEL_STRING_FATAL;
	   WHEN p_LOG_LEVEL >= LOGS.c_LEVEL_ERROR THEN
		v_LEVEL_STRING := g_LEVEL_STRING_ERROR;
	   WHEN p_LOG_LEVEL >= LOGS.c_LEVEL_WARN THEN
		v_LEVEL_STRING := g_LEVEL_STRING_WARN;
	   WHEN p_LOG_LEVEL >= LOGS.c_LEVEL_NOTICE THEN
		v_LEVEL_STRING := g_LEVEL_STRING_NOTICE;
	   WHEN p_LOG_LEVEL >= LOGS.c_LEVEL_INFO THEN
		v_LEVEL_STRING := g_LEVEL_STRING_INFO;
	   WHEN p_LOG_LEVEL >= LOGS.c_LEVEL_INFO_DETAIL THEN
		v_LEVEL_STRING := g_LEVEL_STRING_MO_INFO;
	   WHEN p_LOG_LEVEL >= LOGS.c_LEVEL_INFO_MORE_DETAIL THEN
		v_LEVEL_STRING := g_LEVEL_STRING_MAX_INFO;
	   WHEN p_LOG_LEVEL >= LOGS.c_LEVEL_DEBUG THEN
		v_LEVEL_STRING := g_LEVEL_STRING_DEBUG;
	   WHEN p_LOG_LEVEL >= LOGS.c_LEVEL_DEBUG_DETAIL THEN
		v_LEVEL_STRING := g_LEVEL_STRING_MO_DEBUG;
	   WHEN p_LOG_LEVEL < LOGS.c_LEVEL_DEBUG_DETAIL THEN
		v_LEVEL_STRING := g_LEVEL_STRING_MAX_DEBUG;
	   ELSE
	    v_LEVEL_STRING := TO_CHAR(p_LOG_LEVEL);
	END CASE;

	RETURN v_LEVEL_STRING;
END GET_LOG_LEVEL_STRING;
----------------------------------------------------------------------------------------------------
FUNCTION GET_STATUS_LEVEL_STRING(p_STATUS_LEVEL NUMBER, p_WAS_TERMINATED IN NUMBER) RETURN VARCHAR2 AS
BEGIN
	IF p_STATUS_LEVEL IS NOT NULL THEN
		RETURN GET_STATUS_LEVEL_STRING(p_STATUS_LEVEL);
	ELSIF p_STATUS_LEVEL IS NULL AND p_WAS_TERMINATED=1 THEN
		RETURN c_LEVEL_STRING_TERMINATED;
	ELSE
		RETURN NULL;
	END IF;
END GET_STATUS_LEVEL_STRING;
----------------------------------------------------------------------------------------------------
FUNCTION GET_STATUS_LEVEL_STRING(p_STATUS_LEVEL NUMBER) RETURN VARCHAR2 AS
v_LEVEL_STRING VARCHAR2(10);
BEGIN
	CASE
	   WHEN p_STATUS_LEVEL = LOGS.c_LEVEL_FATAL THEN
		v_LEVEL_STRING := g_LEVEL_STRING_FATAL;
	   WHEN p_STATUS_LEVEL >= LOGS.c_LEVEL_ERROR THEN
		v_LEVEL_STRING := g_LEVEL_STRING_ERROR;
	   WHEN p_STATUS_LEVEL >= LOGS.c_LEVEL_WARN THEN
		v_LEVEL_STRING := g_LEVEL_STRING_WARN;
	   WHEN p_STATUS_LEVEL >= LOGS.c_LEVEL_NOTICE THEN
		v_LEVEL_STRING := g_LEVEL_STRING_NOTICE;
	   WHEN p_STATUS_LEVEL < LOGS.c_LEVEL_NOTICE THEN
		v_LEVEL_STRING := c_LEVEL_STRING_SUCCESS;
	   ELSE
	    v_LEVEL_STRING := TO_CHAR(p_STATUS_LEVEL);
	END CASE;

	RETURN v_LEVEL_STRING;
END GET_STATUS_LEVEL_STRING;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_LOG_LEVELS(p_CURSOR OUT GA.REFCURSOR) IS
BEGIN
	OPEN p_CURSOR FOR
		SELECT L.VALUE AS LOG_LEVEL_NAME, L.CODE AS LOG_LEVEL_ID
		FROM SYSTEM_LABEL L
		WHERE L.MODEL_ID = 0
		  AND L.MODULE = 'System'
		  AND L.KEY1 = 'Logging'
		  AND L.KEY2 = 'Log Levels'
		  AND L.KEY3 = 'Values'
		ORDER BY L.POSITION;

END GET_LOG_LEVELS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_STATUS_LEVELS(p_CURSOR OUT GA.REFCURSOR) IS
BEGIN
	OPEN p_CURSOR FOR
		SELECT STATUS_LEVEL_NAME, STATUS_LEVEL_ID
		FROM (SELECT c_LEVEL_STRING_SUCCESS AS STATUS_LEVEL_NAME,
		  		UT.GET_LITERAL_FOR_NUMBER(LOGS.c_LEVEL_SUCCESS) AS STATUS_LEVEL_ID,
		  		5 AS POSITION
			  FROM DUAL
			  UNION ALL
			  SELECT L.VALUE AS STATUS_LEVEL_NAME, L.CODE AS STATUS_LEVEL_ID, L.POSITION
			  FROM SYSTEM_LABEL L
			  WHERE L.MODEL_ID = 0
			    AND L.MODULE = 'System'
		  		AND L.KEY1 = 'Logging'
		  		AND L.KEY2 = 'Log Levels'
		  		AND L.KEY3 = 'Values'
		  		AND L.CODE > LOGS.c_LEVEL_INFO
			  ORDER BY POSITION);

END GET_STATUS_LEVELS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_PROCESS_NAMES
	(
	p_BEGIN_DATE        IN DATE,
	p_END_DATE          IN DATE,
	p_INCLUDE_SESSIONS  IN NUMBER,
	p_PROCESS_NAME_TEXT IN VARCHAR2,
	p_CURSOR            OUT GA.REFCURSOR
	) IS
v_USER_ID PROCESS_LOG.USER_ID%TYPE;
BEGIN

	IF SD.GET_ACTION_IS_ALLOWED(SD.g_ACTION_SELECT_ALL_PROCESSES) THEN
		v_USER_ID := CONSTANTS.ALL_ID;
	ELSE
		v_USER_ID := SECURITY_CONTROLS.CURRENT_USER_ID;
	END IF;

	OPEN p_CURSOR FOR
		SELECT CONSTANTS.ALL_STRING AS PROCESS_NAME
		FROM DUAL
		UNION ALL
		SELECT PROCESS_NAME
		FROM ( 	-- break this up into two queries that can properly use
				-- index and then union results together
			SELECT P.PROCESS_NAME
			FROM PROCESS_LOG P
			WHERE P.PROCESS_START_TIME < p_END_DATE + 1
				  AND P.PROCESS_STOP_TIME >= p_BEGIN_DATE
				  AND v_USER_ID IN (P.USER_ID, CONSTANTS.ALL_ID)
				  AND (p_INCLUDE_SESSIONS = 1
				  	   OR P.PROCESS_TYPE NOT IN (LOGS.c_PROCESS_TYPE_USER_SESSION, LOGS.c_PROCESS_TYPE_BACKGROUND_JOB))
				  AND UPPER(P.PROCESS_NAME) LIKE UPPER(NVL(p_PROCESS_NAME_TEXT, '%'))
			UNION
			SELECT P.PROCESS_NAME
			FROM PROCESS_LOG P
			WHERE P.PROCESS_START_TIME < p_END_DATE + 1
				  AND P.PROCESS_STOP_TIME IS NULL
				  AND v_USER_ID IN (P.USER_ID, CONSTANTS.ALL_ID)
				  AND (p_INCLUDE_SESSIONS = 1
				  	   OR P.PROCESS_TYPE NOT IN (LOGS.c_PROCESS_TYPE_USER_SESSION, LOGS.c_PROCESS_TYPE_BACKGROUND_JOB))
				  AND UPPER(P.PROCESS_NAME) LIKE UPPER(NVL(p_PROCESS_NAME_TEXT, '%'))
			ORDER BY PROCESS_NAME);
END GET_PROCESS_NAMES;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_PROCESSES_WORK
	(
	p_WORK_ID 	 IN NUMBER,
	p_CURSOR 	 OUT GA.REFCURSOR
	) AS

	v_ALLOWED_TO_VIEW_SESSION   NUMBER;

BEGIN

	v_ALLOWED_TO_VIEW_SESSION := UT.NUMBER_FROM_BOOLEAN(
									SD.GET_ACTION_IS_ALLOWED(SD.g_ACTION_SELECT_SESSIONS)
								 );

	OPEN p_CURSOR FOR
	SELECT TO_CHAR(P.PROCESS_ID) PROCESS_ID,
		   P.PROCESS_NAME,
		   P.PROCESS_TYPE,
		   NVL2(U.USER_DISPLAY_NAME, U.USER_NAME, '<html><i>Unauthenticated</i></html>') AS OWNER,
		   P.PROCESS_START_TIME,
		   P.PROCESS_STOP_TIME,
		   GET_STATUS_LEVEL_STRING(P.PROCESS_STATUS, P.WAS_TERMINATED) as PROCESS_STATUS,
		   P.PROCESS_CODE,
		   P.PROCESS_ERRM,
		   P.PROCESS_FINISH_TEXT,
		   GET_TARGET_BEGIN_DATE(P.PROCESS_ID) AS TARGET_BEGIN_DATE,
		   GET_TARGET_END_DATE(P.PROCESS_ID) AS TARGET_END_DATE,
		   GET_OTHER_TARGET_PARAMETERS(P.PROCESS_ID) AS TARGET_PARAMETERS,
		   P.NUM_INFOS AS INFOS,
		   P.NUM_NOTICES AS NOTICES,
		   P.NUM_WARNINGS AS WARNINGS,
		   P.NUM_ERRORS AS ERRORS,
		   P.NUM_FATALS AS FATALS,
		   CASE WHEN EXISTS (SELECT 1
							 FROM PROCESS_LOG_TRACE T
							 WHERE T.PROCESS_ID = P.PROCESS_ID
								 AND ROWNUM = 1)
				OR EXISTS (SELECT 1
						   FROM PROCESS_LOG_TEMP_TRACE T
						   WHERE T.PROCESS_ID = P.PROCESS_ID
							   AND ROWNUM = 1)
				THEN 1
				ELSE 0
		   END as HAS_TRACE,
		   CASE P.PROGRESS_TOTALWORK WHEN 0 THEN NULL ELSE P.PROGRESS_SOFAR / P.PROGRESS_TOTALWORK END AS PROGRESS,
		   P.PROGRESS_DESCRIPTION,
		   CASE P.PROGRESS_SOFAR WHEN 0 THEN NULL ELSE ((P.PROGRESS_TOTALWORK * (P.PROGRESS_LAST_UPDATE - P.PROCESS_START_TIME)) / P.PROGRESS_SOFAR) +
		   P.PROCESS_START_TIME END AS EXPECTED_COMPLETION,
		   -- These last 6 colums are hidden if user has restricted privileges
		   CASE
			   WHEN v_ALLOWED_TO_VIEW_SESSION = 1 THEN
				P.SESSION_SID
			   ELSE
				NULL
		   END AS SID,
		   CASE
			   WHEN v_ALLOWED_TO_VIEW_SESSION = 1 THEN
				P.SESSION_SERIALNUM
			   ELSE
				NULL
		   END AS SERIAL#,
		   CASE
			   WHEN v_ALLOWED_TO_VIEW_SESSION = 1 THEN
				P.SCHEMA_NAME
			   ELSE
				NULL
		   END AS SCHEMA,
		   CASE
			   WHEN v_ALLOWED_TO_VIEW_SESSION = 1 THEN
				P.SESSION_OSUSER
			   ELSE
				NULL
		   END AS OS_USER,
		   CASE
			   WHEN v_ALLOWED_TO_VIEW_SESSION = 1 THEN
				P.SESSION_MACHINE
			   ELSE
				NULL
		   END AS TERMINAL,
		   CASE
			   WHEN v_ALLOWED_TO_VIEW_SESSION = 1 THEN
				P.SESSION_PROGRAM
			   ELSE
				NULL
		   END AS PROGRAM,
		   -- Hidden Column used by Session Management System Action
		   UT.IS_SESSION_ALIVE(P.UNIQUE_SESSION_CID) IS_SESSION_ALIVE,
		   -- Hidden Column used by the Terminate Process System Action
		   CASE
			   WHEN NVL(P.WAS_TERMINATED, 0) = 0 AND NVL(P.CAN_TERMINATE, 0) = 1 AND P.PROCESS_STOP_TIME IS NULL THEN
				1
			   ELSE
				0
		   END CAN_TERMINATE,
		   NVL(T.USER_DISPLAY_NAME, T.USER_NAME) AS TERMINATED_BY
	FROM RTO_WORK W, PROCESS_LOG P, APPLICATION_USER U, APPLICATION_USER T
	WHERE W.WORK_ID = p_WORK_ID
		AND P.PROCESS_ID = TO_NUMBER(W.WORK_DATA)
		AND U.USER_ID(+) = P.USER_ID
		AND T.USER_ID(+) = P.TERMINATED_BY_USER_ID
	ORDER BY P.PROCESS_START_TIME DESC, P.PROCESS_ID DESC;


END GET_PROCESSES_WORK;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_PROCESSES
	(
	p_BEGIN_DATE          IN DATE,
	p_END_DATE            IN DATE,
	p_INCLUDE_SESSIONS    IN NUMBER,
	p_PROCESS_NAME_FILTER IN VARCHAR2,
	p_PROCESS_OWNER_ID    IN NUMBER,
	p_PROCESS_STATE       IN VARCHAR2,
	p_CURSOR              OUT GA.REFCURSOR
	) IS

	v_PROCESS_NAME_TABLE        STRING_COLLECTION;
	v_USER_ID			PROCESS_LOG.USER_ID%TYPE;
	v_WORK_ID					NUMBER(9);
BEGIN
	UT.GET_RTO_WORK_ID(v_WORK_ID);

	IF SD.GET_ACTION_IS_ALLOWED(SD.g_ACTION_SELECT_ALL_PROCESSES) THEN
		v_USER_ID := CONSTANTS.ALL_ID;
	ELSE
		v_USER_ID := SECURITY_CONTROLS.CURRENT_USER_ID;
	END IF;

	IF (p_PROCESS_NAME_FILTER IS NOT NULL) AND REGEXP_INSTR(p_PROCESS_NAME_FILTER, '(,|^)'||CONSTANTS.ALL_STRING||'(,|$)') = 0 THEN
		UT.STRING_COLLECTION_FROM_STRING(p_PROCESS_NAME_FILTER, ',', v_PROCESS_NAME_TABLE);
		-- get list of process IDs that match the specified names
		INSERT INTO RTO_WORK (WORK_ID, WORK_DATA)
		-- to get better use of indexes on PROCESS_LOG, break query up into two
		SELECT v_WORK_ID, PROCESS_ID
		FROM TABLE(CAST(v_PROCESS_NAME_TABLE AS STRING_COLLECTION)) PROCESS_NAMES,
			PROCESS_LOG P
		WHERE P.PROCESS_NAME = PROCESS_NAMES.COLUMN_VALUE
			AND P.PROCESS_START_TIME <= p_END_DATE + 1
			AND P.PROCESS_STOP_TIME >= p_BEGIN_DATE -- where stop time is NOT null
			AND p_PROCESS_OWNER_ID IN (P.USER_ID, CONSTANTS.ALL_ID)
			AND v_USER_ID IN (P.USER_ID, CONSTANTS.ALL_ID)
			AND (p_INCLUDE_SESSIONS = 1 OR
				 P.PROCESS_TYPE NOT IN (LOGS.c_PROCESS_TYPE_USER_SESSION, LOGS.c_PROCESS_TYPE_BACKGROUND_JOB))
			AND (p_PROCESS_STATE = c_PROCESS_STATE_ALL OR
			  	   (p_PROCESS_STATE = c_PROCESS_STATE_RUNNING
				   	AND P.PROCESS_STOP_TIME IS NULL
					AND UT.IS_SESSION_ALIVE(P.UNIQUE_SESSION_CID) = 1) OR
			  	   (p_PROCESS_STATE = c_PROCESS_STATE_FINISHED
				   	AND P.PROCESS_STOP_TIME IS NOT NULL))
		UNION ALL
		SELECT v_WORK_ID, PROCESS_ID
		FROM TABLE(CAST(v_PROCESS_NAME_TABLE AS STRING_COLLECTION)) PROCESS_NAMES,
			PROCESS_LOG P
		WHERE P.PROCESS_NAME = PROCESS_NAMES.COLUMN_VALUE
			AND P.PROCESS_START_TIME <= p_END_DATE + 1
			AND P.PROCESS_STOP_TIME IS NULL -- where stop time IS null
			AND p_PROCESS_OWNER_ID IN (P.USER_ID, CONSTANTS.ALL_ID)
			AND v_USER_ID IN (P.USER_ID, CONSTANTS.ALL_ID)
			AND (p_INCLUDE_SESSIONS = 1 OR
				 P.PROCESS_TYPE NOT IN (LOGS.c_PROCESS_TYPE_USER_SESSION, LOGS.c_PROCESS_TYPE_BACKGROUND_JOB))
			AND (p_PROCESS_STATE = c_PROCESS_STATE_ALL OR
			  	   (p_PROCESS_STATE = c_PROCESS_STATE_RUNNING
				   	AND P.PROCESS_STOP_TIME IS NULL
					AND UT.IS_SESSION_ALIVE(P.UNIQUE_SESSION_CID) = 1) OR
			  	   (p_PROCESS_STATE = c_PROCESS_STATE_FINISHED
				   	AND P.PROCESS_STOP_TIME IS NOT NULL));
	ELSE
		-- ASSUMPTION: No processes selected indicates ALL

		-- get list of process IDs that match the specified names
		INSERT INTO RTO_WORK (WORK_ID, WORK_DATA)
		-- to get better use of indexes on PROCESS_LOG, break query up into two
		SELECT v_WORK_ID, PROCESS_ID
		FROM PROCESS_LOG P
		WHERE P.PROCESS_START_TIME <= p_END_DATE + 1
			AND P.PROCESS_STOP_TIME >= p_BEGIN_DATE -- where stop time is NOT null
			AND p_PROCESS_OWNER_ID IN (P.USER_ID, CONSTANTS.ALL_ID)
			AND v_USER_ID IN (P.USER_ID, CONSTANTS.ALL_ID)
			AND (p_INCLUDE_SESSIONS = 1 OR
				 P.PROCESS_TYPE NOT IN (LOGS.c_PROCESS_TYPE_USER_SESSION, LOGS.c_PROCESS_TYPE_BACKGROUND_JOB))
			AND (p_PROCESS_STATE = c_PROCESS_STATE_ALL OR
			  	   (p_PROCESS_STATE = c_PROCESS_STATE_RUNNING
				   	AND P.PROCESS_STOP_TIME IS NULL
					AND UT.IS_SESSION_ALIVE(P.UNIQUE_SESSION_CID) = 1) OR
			  	   (p_PROCESS_STATE = c_PROCESS_STATE_FINISHED
				   	AND P.PROCESS_STOP_TIME IS NOT NULL))
		UNION ALL
		SELECT v_WORK_ID, PROCESS_ID
		FROM PROCESS_LOG P
		WHERE P.PROCESS_START_TIME <= p_END_DATE + 1
			AND P.PROCESS_STOP_TIME IS NULL -- where stop time IS null
			AND p_PROCESS_OWNER_ID IN (P.USER_ID, CONSTANTS.ALL_ID)
			AND v_USER_ID IN (P.USER_ID, CONSTANTS.ALL_ID)
			AND (p_INCLUDE_SESSIONS = 1 OR
				 P.PROCESS_TYPE NOT IN (LOGS.c_PROCESS_TYPE_USER_SESSION, LOGS.c_PROCESS_TYPE_BACKGROUND_JOB))
			AND (p_PROCESS_STATE = c_PROCESS_STATE_ALL OR
			  	   (p_PROCESS_STATE = c_PROCESS_STATE_RUNNING
				   	AND P.PROCESS_STOP_TIME IS NULL
					AND UT.IS_SESSION_ALIVE(P.UNIQUE_SESSION_CID) = 1) OR
			  	   (p_PROCESS_STATE = c_PROCESS_STATE_FINISHED
				   	AND P.PROCESS_STOP_TIME IS NOT NULL));
	END IF;

	GET_PROCESSES_WORK(v_WORK_ID, p_CURSOR);

	UT.PURGE_RTO_WORK(v_WORK_ID);
EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			UT.PURGE_RTO_WORK(v_WORK_ID);
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE;
		END;
		ERRS.LOG_AND_RAISE;
END GET_PROCESSES;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_PROCESSES_BY_IDS
	(
	p_PROCESS_IDS		  IN NUMBER_COLLECTION,
	p_CURSOR              OUT GA.REFCURSOR
	) AS

	v_WORK_ID NUMBER(9);
	v_USER_ID PROCESS_LOG.USER_ID%TYPE;

BEGIN

	IF SD.GET_ACTION_IS_ALLOWED(SD.g_ACTION_SELECT_ALL_PROCESSES) THEN
		v_USER_ID := CONSTANTS.ALL_ID;
	ELSE
		v_USER_ID := SECURITY_CONTROLS.CURRENT_USER_ID;
	END IF;

	UT.GET_RTO_WORK_ID(v_WORK_ID);

	INSERT INTO RTO_WORK (WORK_ID, WORK_DATA)
	SELECT DISTINCT v_WORK_ID, PLOG.PROCESS_ID
	FROM TABLE(CAST(p_PROCESS_IDS AS NUMBER_COLLECTION)) PROCS,
		PROCESS_LOG PLOG
	WHERE v_USER_ID IN (PLOG.USER_ID, CONSTANTS.ALL_ID)
	START WITH PLOG.PROCESS_ID = PROCS.COLUMN_VALUE
	CONNECT BY PLOG.PARENT_PROCESS_ID = PRIOR PLOG.PROCESS_ID;

	GET_PROCESSES_WORK(v_WORK_ID, p_CURSOR);

	UT.PURGE_RTO_WORK(v_WORK_ID);

EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			UT.PURGE_RTO_WORK(v_WORK_ID);
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE;
		END;
		ERRS.LOG_AND_RAISE;
END GET_PROCESSES_BY_IDS;
----------------------------------------------------------------------------------------------------
FUNCTION GET_SOURCE_STRING
	(
	p_SOURCE_NAME		IN PROCESS_LOG_EVENT.SOURCE_NAME%TYPE,
	p_SOURCE_DOMAIN_ID	IN PROCESS_LOG_EVENT.SOURCE_DOMAIN_ID%TYPE,
	p_SOURCE_ENTITY_ID	IN PROCESS_LOG_EVENT.SOURCE_ENTITY_ID%TYPE,
	p_SOURCE_DATE		IN PROCESS_LOG_EVENT.SOURCE_DATE%TYPE
	) RETURN VARCHAR2 IS
v_RET VARCHAR2(6000);
BEGIN
	v_RET := p_SOURCE_NAME;

	IF p_SOURCE_DOMAIN_ID IS NOT NULL AND p_SOURCE_ENTITY_ID IS NOT NULL THEN
		IF v_RET IS NOT NULL THEN
			v_RET := v_RET||'; ';
		END IF;
		v_RET := v_RET||TEXT_UTIL.TO_CHAR_ENTITY(p_SOURCE_ENTITY_ID, p_SOURCE_DOMAIN_ID, TRUE);
	END IF;

	IF p_SOURCE_DATE IS NOT NULL THEN
		IF v_RET IS NOT NULL THEN
			v_RET := v_RET||'; ';
		END IF;
		v_RET := v_RET||TEXT_UTIL.TO_CHAR_TIME(p_SOURCE_DATE)||' '||GA.CUT_TIME_ZONE;
	END IF;

	IF LENGTH(v_RET) > 4000 THEN
		RETURN SUBSTR(v_RET,1,3997)||'...';
	ELSE
		RETURN v_RET;
	END IF;
END GET_SOURCE_STRING;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_PROCESS_EVENTS
	(
	p_PROCESS_ID   IN VARCHAR2,
	p_LOG_LEVEL_ID IN NUMBER,
	p_CURSOR       OUT GA.REFCURSOR
	) IS
	v_ALLOWED_TO_VIEW_ALL_USERS NUMBER(1) := 0;
	v_PROCESS_ID                PROCESS_LOG.PROCESS_ID%TYPE;
BEGIN

	v_ALLOWED_TO_VIEW_ALL_USERS := UT.NUMBER_FROM_BOOLEAN(SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ALL_PROCESSES,
																				   SD.g_ALL_DATA_ENTITY_ID,
																				   CONSTANTS.NOT_ASSIGNED));

	SELECT MAX(P.PROCESS_ID)
	INTO v_PROCESS_ID
	FROM PROCESS_LOG P
	WHERE P.PROCESS_ID = TO_NUMBER(p_PROCESS_ID)
	  AND (P.USER_ID = SECURITY_CONTROLS.CURRENT_USER_ID OR v_ALLOWED_TO_VIEW_ALL_USERS = 1);

	IF v_PROCESS_ID IS NULL THEN
		OPEN p_CURSOR FOR SELECT NULL FROM DUAL WHERE 0=1;
	ELSE

		OPEN p_CURSOR FOR
			SELECT TO_CHAR(E.EVENT_ID) AS EVENT_ID,
				   (SELECT (CASE
							   WHEN COUNT(1) > 0 THEN
								'*'
							   ELSE
								''
						   END)
					FROM PROCESS_LOG_EVENT_DETAIL
					WHERE EVENT_ID = E.EVENT_ID) AS ATTACHMENT_DETAILS_AVAL,
				   CASE
					   WHEN E.MESSAGE_ID IS NULL THEN
						''
					   ELSE
						'->'
				   END AS MESSAGE_DETAILS_AVAL,
				   GET_LOG_LEVEL_STRING(E.EVENT_LEVEL) AS "LEVEL",
				   E.EVENT_TIMESTAMP AS TIME,
				   E.PROCEDURE_NAME AS "PROCEDURE",
				   E.STEP_NAME AS STEP,
				   GET_SOURCE_STRING(E.SOURCE_NAME,E.SOURCE_DOMAIN_ID,E.SOURCE_ENTITY_ID,E.SOURCE_DATE) AS "SOURCE",
				   E.EVENT_TEXT AS MESSAGE,
				   E.EVENT_ERRM AS ERROR,
				   E.MESSAGE_ID
			FROM PROCESS_LOG_EVENT E
			WHERE E.PROCESS_ID = v_PROCESS_ID
			AND E.EVENT_LEVEL >= NVL(p_LOG_LEVEL_ID, 0)
			ORDER BY E.EVENT_TIMESTAMP, E.EVENT_ID;
	END IF;
END GET_PROCESS_EVENTS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_PROCESS_DEBUG_EVENTS
	(
	p_PROCESS_ID IN VARCHAR2,
	p_MESSAGE    OUT VARCHAR2,
	p_CONTENTS	 OUT CLOB
	) IS
	v_ALLOWED_TO_VIEW_ALL_USERS NUMBER(1) := 0;
	v_PROCESS_ID                PROCESS_LOG.PROCESS_ID%TYPE;
	v_STR VARCHAR2(4128);
	v_MAX_SIZE_SETTING VARCHAR2(32);
	v_MAX_SIZE NUMBER(12);
	v_CLOB_LENGTH NUMBER(9);
	v_TEMP_CLOB CLOB;

	CURSOR c_CONTENTS IS
				SELECT E.*
				FROM (SELECT P.EVENT_ID,
							 P.EVENT_TIMESTAMP,
							 P.EVENT_LEVEL,
							 0 IS_TEMP,
							 P.PROCEDURE_NAME,
							 P.STEP_NAME,
							 P.EVENT_TEXT
				  FROM PROCESS_LOG_EVENT P
				  WHERE P.PROCESS_ID = v_PROCESS_ID
				  UNION ALL
				  SELECT P.EVENT_ID,
							 P.EVENT_TIMESTAMP,
							 P.EVENT_LEVEL,
							 0 IS_TEMP,
							 P.PROCEDURE_NAME,
							 P.STEP_NAME,
							 P.EVENT_TEXT
				  FROM PROCESS_LOG_TRACE P
				  WHERE P.PROCESS_ID = v_PROCESS_ID
				  UNION ALL
				  SELECT P.EVENT_ID,
				  		 P.EVENT_TIMESTAMP,
						 P.EVENT_LEVEL,
						 1 IS_TEMP,
						 P.PROCEDURE_NAME,
						 P.STEP_NAME,
						 P.EVENT_TEXT
				  FROM PROCESS_LOG_TEMP_TRACE P
				  WHERE P.PROCESS_ID = v_PROCESS_ID) E
				ORDER BY E.EVENT_TIMESTAMP, E.EVENT_ID;
BEGIN

	v_ALLOWED_TO_VIEW_ALL_USERS := UT.NUMBER_FROM_BOOLEAN(SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ALL_PROCESSES,
																				   SD.g_ALL_DATA_ENTITY_ID,
																				   CONSTANTS.NOT_ASSIGNED));

	-- Make sure that this user is allowed to view the Process Trace Details
	SELECT MAX(P.PROCESS_ID)
	INTO v_PROCESS_ID
	FROM PROCESS_LOG P
	WHERE P.PROCESS_ID = TO_NUMBER(p_PROCESS_ID)
	  AND (P.USER_ID = SECURITY_CONTROLS.CURRENT_USER_ID OR v_ALLOWED_TO_VIEW_ALL_USERS = 1);

	IF v_PROCESS_ID IS NULL THEN
		ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_SELECT_ALL_PROCESSES);
	END IF;

	BEGIN
		-- Get the System Setting for the Maximum Trace Clob Size
		v_MAX_SIZE_SETTING := GET_DICTIONARY_VALUE('Maximum Trace Size', CONSTANTS.GLOBAL_MODEL, 'System', 'Logging');
		v_MAX_SIZE := NVL(TO_NUMBER(v_MAX_SIZE_SETTING), 1024*1024*4);

		DBMS_LOB.CREATETEMPORARY(p_CONTENTS, TRUE);
		DBMS_LOB.OPEN(p_CONTENTS, DBMS_LOB.LOB_READWRITE);

		-- Loop over all Trace records and fill the Clob
		FOR v_ROW IN c_CONTENTS LOOP
			v_STR := TO_CHAR(v_ROW.EVENT_TIMESTAMP, 'DD-MM-YY HH24:MI:SS.FF3') || CASE WHEN v_ROW.IS_TEMP = 1 THEN ' - [T]' ELSE '' END || ' - [' || GET_LOG_LEVEL_STRING(v_ROW.EVENT_LEVEL) || '] - ' || v_ROW.EVENT_TEXT || UTL_TCP.CRLF;
			DBMS_LOB.WRITEAPPEND(p_CONTENTS, LENGTH(v_STR), v_STR);
		END LOOP;

		DBMS_LOB.CLOSE(p_CONTENTS);

		-- Check to see if the Trace data exceeds the maximum size.
		v_CLOB_LENGTH := DBMS_LOB.GETLENGTH(p_CONTENTS);

		IF v_CLOB_LENGTH > v_MAX_SIZE AND v_MAX_SIZE <> -1 THEN
			p_MESSAGE := '<html>The Trace data is longer than the maximum size allowed (' || v_MAX_SIZE || ').<br>' ||
				'The Trace dialog will only display the last ' || v_MAX_SIZE || ' characters.<br><br>' ||
				'<b>Note:</b> The maximum Trace data size is a System Setting that can be changed.<br> See ''System -> Logging -> Maximum Trace Size'' in the System Settings dialog</html>';

			-- Return the last chunk of Trace data that fits in the maximum size.
			DBMS_LOB.CREATETEMPORARY(v_TEMP_CLOB, TRUE);
			DBMS_LOB.OPEN(v_TEMP_CLOB, DBMS_LOB.LOB_READWRITE);
			DBMS_LOB.COPY(v_TEMP_CLOB, p_CONTENTS, v_MAX_SIZE, 1, v_CLOB_LENGTH - v_MAX_SIZE);
			DBMS_LOB.CLOSE(v_TEMP_CLOB);
			DBMS_LOB.FREETEMPORARY(p_CONTENTS);
			p_CONTENTS := v_TEMP_CLOB;

		END IF;

	EXCEPTION
		WHEN OTHERS THEN
			BEGIN
				IF p_CONTENTS IS NOT NULL AND DBMS_LOB.ISOPEN(p_CONTENTS) = 1 THEN
					DBMS_LOB.CLOSE(p_CONTENTS);
				END IF;
			EXCEPTION
				WHEN OTHERS THEN
					ERRS.LOG_AND_CONTINUE();
			END;

			BEGIN
				IF p_CONTENTS IS NOT NULL AND DBMS_LOB.ISTEMPORARY(p_CONTENTS) = 1 THEN
					DBMS_LOB.FREETEMPORARY(p_CONTENTS);
				END IF;
			EXCEPTION
				WHEN OTHERS THEN
					ERRS.LOG_AND_CONTINUE();
			END;

			BEGIN
				IF v_TEMP_CLOB IS NOT NULL AND DBMS_LOB.ISOPEN(v_TEMP_CLOB) = 1 THEN
					DBMS_LOB.CLOSE(v_TEMP_CLOB);
				END IF;
			EXCEPTION
				WHEN OTHERS THEN
					ERRS.LOG_AND_CONTINUE();
			END;

			BEGIN
				IF v_TEMP_CLOB IS NOT NULL AND DBMS_LOB.ISTEMPORARY(v_TEMP_CLOB) = 1 THEN
					DBMS_LOB.FREETEMPORARY(v_TEMP_CLOB);
				END IF;
			EXCEPTION
				WHEN OTHERS THEN
					ERRS.LOG_AND_CONTINUE();
			END;
			ERRS.LOG_AND_RAISE();
	END;

END GET_PROCESS_DEBUG_EVENTS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_USER_LIST(p_CURSOR OUT GA.REFCURSOR) IS
	v_ALLOWED_TO_VIEW_ALL_USERS NUMBER(1) := 0;
BEGIN
	v_ALLOWED_TO_VIEW_ALL_USERS := UT.NUMBER_FROM_BOOLEAN(SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ALL_PROCESSES,
																				   SD.g_ALL_DATA_ENTITY_ID,
																				   CONSTANTS.NOT_ASSIGNED));

	OPEN p_CURSOR FOR
		SELECT SECURITY_CONTROLS.CURRENT_USER USER_NAME, SECURITY_CONTROLS.CURRENT_USER_ID USER_ID
		FROM DUAL
		UNION
		SELECT CONSTANTS.ALL_STRING USER_NAME, CONSTANTS.ALL_ID USER_ID
		FROM DUAL
		WHERE v_ALLOWED_TO_VIEW_ALL_USERS = 1
		UNION
		SELECT DISTINCT U.USER_NAME, U.USER_ID
		FROM PROCESS_LOG P, APPLICATION_USER U
		WHERE U.USER_ID = P.USER_ID
			  AND v_ALLOWED_TO_VIEW_ALL_USERS = 1
		ORDER BY USER_NAME;

END GET_USER_LIST;
----------------------------------------------------------------------------------------------------
FUNCTION GET_TARGET_BEGIN_DATE(p_PROCESS_ID IN NUMBER) RETURN VARCHAR2 IS
	v_PARAM_VALUE PROCESS_LOG_TARGET_PARAMETER.PARAMETER_VAL%TYPE;
BEGIN
	SELECT NVL(T.PARAMETER_VAL, '')
	INTO v_PARAM_VALUE
	FROM PROCESS_LOG_TARGET_PARAMETER T
	WHERE UPPER(T.PARAMETER_NAME) = 'BEGIN_DATE'
		  AND T.PROCESS_ID = p_PROCESS_ID;
	RETURN v_PARAM_VALUE;
END GET_TARGET_BEGIN_DATE;
----------------------------------------------------------------------------------------------------
FUNCTION GET_TARGET_END_DATE(p_PROCESS_ID IN NUMBER) RETURN VARCHAR2 IS
	v_PARAM_VALUE PROCESS_LOG_TARGET_PARAMETER.PARAMETER_VAL%TYPE;
BEGIN
	SELECT NVL(T.PARAMETER_VAL, '')
	INTO v_PARAM_VALUE
	FROM PROCESS_LOG_TARGET_PARAMETER T
	WHERE UPPER(T.PARAMETER_NAME) = 'END_DATE'
		  AND T.PROCESS_ID = p_PROCESS_ID;
	RETURN v_PARAM_VALUE;
END GET_TARGET_END_DATE;
----------------------------------------------------------------------------------------------------
FUNCTION GET_OTHER_TARGET_PARAMETERS(p_PROCESS_ID IN NUMBER) RETURN VARCHAR2 IS
	v_PARAM_VALUE VARCHAR2(32000);
BEGIN
	FOR v_PARAMS IN (SELECT T.PARAMETER_NAME, T.PARAMETER_VAL
					 FROM PROCESS_LOG_TARGET_PARAMETER T
					 WHERE T.PROCESS_ID = p_PROCESS_ID
						   AND T.PARAMETER_NAME NOT IN ('BEGIN_DATE', 'END_DATE')) LOOP
		v_PARAM_VALUE := v_PARAM_VALUE || v_PARAMS.PARAMETER_NAME || '=' || v_PARAMS.PARAMETER_VAL || UTL_TCP.CRLF;
	END LOOP;

	RETURN v_PARAM_VALUE;
END GET_OTHER_TARGET_PARAMETERS;
----------------------------------------------------------------------------------------------------
PROCEDURE TRUNCATE_TEMP_TRACE AS
BEGIN
	EXECUTE IMMEDIATE 'TRUNCATE TABLE PROCESS_LOG_TEMP_TRACE';
EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_RAISE();
END TRUNCATE_TEMP_TRACE;
----------------------------------------------------------------------------------------------------
PROCEDURE TRUNCATE_TRACE AS
BEGIN
	-- Check security
	SD.VERIFY_ACTION_IS_ALLOWED(SD.g_ACTION_TRUNCATE_TRACE);

	BEGIN
		EXECUTE IMMEDIATE 'TRUNCATE TABLE PROCESS_LOG_TRACE';
	EXCEPTION
		WHEN OTHERS THEN
			ERRS.LOG_AND_RAISE();
	END;
END TRUNCATE_TRACE;
----------------------------------------------------------------------------------------------------
PROCEDURE VALIDATE_EVENT_PRIVILEGES(p_EVENT_ID NUMBER) AS
	v_USER_ID                PROCESS_LOG.USER_ID%TYPE;
BEGIN
	-- get the user that "owns" this event
	SELECT MAX(B.USER_ID)
	INTO v_USER_ID
	FROM (SELECT PROCESS_ID FROM PROCESS_LOG_EVENT WHERE EVENT_ID = p_EVENT_ID
		  UNION ALL
		  SELECT PROCESS_ID FROM PROCESS_LOG_TRACE WHERE EVENT_ID = p_EVENT_ID
		  UNION ALL
		  SELECT PROCESS_ID FROM PROCESS_LOG_TEMP_TRACE WHERE EVENT_ID = p_EVENT_ID) A,
		 PROCESS_LOG B
	WHERE B.PROCESS_ID = A.PROCESS_ID;

	IF v_USER_ID <> SECURITY_CONTROLS.CURRENT_USER_ID THEN
		-- if current user does not own the event, then they require
		-- privilege in order to view it
		SD.VERIFY_ACTION_IS_ALLOWED(SD.g_ACTION_SELECT_ALL_PROCESSES);
	END IF;
END VALIDATE_EVENT_PRIVILEGES;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_EVENT_DETAILS
	(
	p_EVENT_ID IN VARCHAR2,
	p_CURSOR   OUT GA.REFCURSOR
	) AS
	v_EVENT_ID PROCESS_LOG_EVENT.EVENT_ID%TYPE;
BEGIN
	v_EVENT_ID := TO_NUMBER(p_EVENT_ID);

	VALIDATE_EVENT_PRIVILEGES(v_EVENT_ID);

	OPEN p_CURSOR FOR
		SELECT TO_CHAR(D.EVENT_ID) EVENT_ID, D.DETAIL_TYPE, D.CONTENT_TYPE
		FROM PROCESS_LOG_EVENT_DETAIL D
		WHERE D.EVENT_ID = v_EVENT_ID;
END GET_EVENT_DETAILS;
----------------------------------------------------------------------------------------------------
FUNCTION GET_EXTENSION_FOR_CONTENTTYPE(p_CONTENTTYPE IN VARCHAR2) RETURN VARCHAR2 IS
	v_TOKENS GA.STRING_TABLE;
BEGIN
	IF TRIM(p_CONTENTTYPE) IS NULL THEN
		RETURN 'txt';
	END IF;

	UT.TOKENS_FROM_STRING(p_CONTENTTYPE, ' ', v_TOKENS);
	-- now tokenize by semicolon in case content type includes optional char-set info after semicolon
	UT.TOKENS_FROM_STRING(v_TOKENS(v_TOKENS.FIRST), ';', v_TOKENS);

	RETURN CASE UPPER(v_TOKENS(v_TOKENS.FIRST))
			WHEN 'TEXT/HTML' THEN
				'html'
			WHEN 'TEXT/XML' THEN
				'xml'
			ELSE -- anything else will be viewed as plain text...
				'txt'
			END;
END GET_EXTENSION_FOR_CONTENTTYPE;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_EVENT_DETAIL_CONTENTS
	(
	p_EVENT_ID           IN VARCHAR2,
	p_DETAIL_TYPE        IN VARCHAR2,
	p_CONTENTS           OUT CLOB,
	p_CONTENTS_EXTENSION OUT VARCHAR2
	) AS
	v_EVENT_ID PROCESS_LOG_EVENT.EVENT_ID%TYPE;
BEGIN
	v_EVENT_ID := TO_NUMBER(p_EVENT_ID);

	VALIDATE_EVENT_PRIVILEGES(v_EVENT_ID);

	SELECT D.CONTENTS, GET_EXTENSION_FOR_CONTENTTYPE(D.CONTENT_TYPE)
	INTO p_CONTENTS, p_CONTENTS_EXTENSION
	FROM PROCESS_LOG_EVENT_DETAIL D
	WHERE D.EVENT_ID = v_EVENT_ID
		  AND D.DETAIL_TYPE = p_DETAIL_TYPE;
END GET_EVENT_DETAIL_CONTENTS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_MESSAGE_DETAILS
	(
	p_MESSAGE_ID IN NUMBER,
	p_CURSOR     OUT GA.REFCURSOR
	) AS
BEGIN

	OPEN p_CURSOR FOR
		SELECT 'Message Code' AS MESSAGE_DETAIL_ITEM,
			   D.MESSAGE_TYPE || '-' || TO_CHAR(D.MESSAGE_NUMBER, 'FM99999') AS MESSAGE_DETAIL_VALUE
		FROM MESSAGE_DEFINITION D
		WHERE D.MESSAGE_ID = p_MESSAGE_ID
		UNION ALL
		SELECT 'Message Text' AS MESSAGE_DETAIL_ITEM, D.MESSAGE_TEXT AS MESSAGE_DETAIL_VALUE
		FROM MESSAGE_DEFINITION D
		WHERE D.MESSAGE_ID = p_MESSAGE_ID
		UNION ALL
		SELECT 'Message Description' AS MESSAGE_DETAIL_ITEM, D.MESSAGE_DESC AS MESSAGE_DETAIL_VALUE
		FROM MESSAGE_DEFINITION D
		WHERE D.MESSAGE_ID = p_MESSAGE_ID
		UNION ALL
		SELECT 'Message Solution' AS MESSAGE_DETAIL_ITEM, D.MESSAGE_SOLUTION AS MESSAGE_DETAIL_VALUE
		FROM MESSAGE_DEFINITION D
		WHERE D.MESSAGE_ID = p_MESSAGE_ID;

END GET_MESSAGE_DETAILS;
----------------------------------------------------------------------------------------------------
PROCEDURE TERMINATE_PROCESS(p_PROCESS_ID IN VARCHAR2) AS
	v_USER_ID 					   PROCESS_LOG.USER_ID%TYPE;
	v_PROCESS_ID                   PROCESS_LOG.PROCESS_ID%TYPE;
	v_STOP_TIME                    PROCESS_LOG.PROCESS_STOP_TIME%TYPE;
	v_WAS_TERMINATED               PROCESS_LOG.WAS_TERMINATED%TYPE;
	v_CAN_TERMINATE                PROCESS_LOG.CAN_TERMINATE%TYPE;
	v_PROCESS_EXISTS               NUMBER(1);
BEGIN

	v_PROCESS_ID := TO_NUMBER(p_PROCESS_ID);

	-- Make sure this process is eligible for termination
	SELECT COUNT(1), MAX(P.CAN_TERMINATE), MAX(P.WAS_TERMINATED), MAX(P.PROCESS_STOP_TIME), MAX(P.USER_ID)
	INTO v_PROCESS_EXISTS, v_CAN_TERMINATE, v_WAS_TERMINATED, v_STOP_TIME, v_USER_ID
	FROM PROCESS_LOG P
	WHERE P.PROCESS_ID = v_PROCESS_ID;

	ASSERT(v_PROCESS_EXISTS > 0, 'The specified process does not exist.');
	ASSERT(NVL(v_WAS_TERMINATED, 0) = 0, 'The specified process has already been terminated.');
	ASSERT(v_STOP_TIME IS NULL, 'The specified process has already finished.');
	ASSERT(NVL(v_CAN_TERMINATE, 0) = 1, 'The specified process cannot be terminated.');

	-- Process is eligible for termination, now check security
	IF v_USER_ID <> SECURITY_CONTROLS.CURRENT_USER_ID THEN
		-- if current user does not own process, then they require special
		-- privilege to terminate it
		SD.VERIFY_ACTION_IS_ALLOWED(SD.g_ACTION_TERMINATE_ANY);
	END IF;

	UPDATE PROCESS_LOG P SET P.WAS_TERMINATED = 1, P.TERMINATED_BY_USER_ID = SECURITY_CONTROLS.CURRENT_USER_ID WHERE P.PROCESS_ID = v_PROCESS_ID;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_RAISE();
END TERMINATE_PROCESS;
----------------------------------------------------------------------------------------------------
FUNCTION CURRENT_LOG_LEVEL_UI RETURN PLS_INTEGER IS
BEGIN
	RETURN LOGS.CURRENT_LOG_LEVEL();
END CURRENT_LOG_LEVEL_UI;
----------------------------------------------------------------------------------------------------
PROCEDURE SET_CURRENT_LOG_LEVEL_UI(p_LEVEL IN PLS_INTEGER) IS
BEGIN
	LOGS.SET_CURRENT_LOG_LEVEL(p_LEVEL);
END SET_CURRENT_LOG_LEVEL_UI;
----------------------------------------------------------------------------------------------------
FUNCTION KEEPING_EVENT_DETAILS_UI RETURN NUMBER IS
BEGIN
	RETURN UT.NUMBER_FROM_BOOLEAN(LOGS.KEEPING_EVENT_DETAILS());
END KEEPING_EVENT_DETAILS_UI;
----------------------------------------------------------------------------------------------------
FUNCTION PERSISTING_TRACE_UI RETURN NUMBER IS
BEGIN
	RETURN UT.NUMBER_FROM_BOOLEAN(LOGS.PERSISTING_TRACE());
END PERSISTING_TRACE_UI;
----------------------------------------------------------------------------------------------------
PROCEDURE SET_KEEPING_EVENT_DETAILS_UI(p_KEEP_THEM IN NUMBER) IS
BEGIN
	LOGS.SET_KEEPING_EVENT_DETAILS(UT.BOOLEAN_FROM_NUMBER(p_KEEP_THEM));
END SET_KEEPING_EVENT_DETAILS_UI;
----------------------------------------------------------------------------------------------------
PROCEDURE SET_PERSISTING_TRACE_UI(p_PERSIST IN NUMBER) IS
BEGIN
	LOGS.SET_PERSISTING_TRACE(UT.BOOLEAN_FROM_NUMBER(p_PERSIST));
END SET_PERSISTING_TRACE_UI;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_PROCESS_STATUS
	(
	p_PROCESS_CID IN VARCHAR2,
	p_CONTENTS OUT VARCHAR2
	) AS
BEGIN
	SELECT PROCESS_FINISH_TEXT||UTL_TCP.CRLF||PROCESS_ERRM
	INTO p_CONTENTS
	FROM PROCESS_LOG
	wHERE PROCESS_ID = p_PROCESS_CID;
END GET_PROCESS_STATUS;
----------------------------------------------------------------------------------------------------
BEGIN
	SP.GET_SYSTEM_LABEL_VALUE_BY_CODE(0,'System','Logging','Log Levels','Values',TO_CHAR(LOGS.c_LEVEL_FATAL),g_LEVEL_STRING_FATAL);
	SP.GET_SYSTEM_LABEL_VALUE_BY_CODE(0,'System','Logging','Log Levels','Values',TO_CHAR(LOGS.c_LEVEL_ERROR),g_LEVEL_STRING_ERROR);
	SP.GET_SYSTEM_LABEL_VALUE_BY_CODE(0,'System','Logging','Log Levels','Values',TO_CHAR(LOGS.c_LEVEL_WARN),g_LEVEL_STRING_WARN);
	SP.GET_SYSTEM_LABEL_VALUE_BY_CODE(0,'System','Logging','Log Levels','Values',TO_CHAR(LOGS.c_LEVEL_NOTICE),g_LEVEL_STRING_NOTICE);
	SP.GET_SYSTEM_LABEL_VALUE_BY_CODE(0,'System','Logging','Log Levels','Values',TO_CHAR(LOGS.c_LEVEL_INFO),g_LEVEL_STRING_INFO);
	SP.GET_SYSTEM_LABEL_VALUE_BY_CODE(0,'System','Logging','Log Levels','Values',TO_CHAR(LOGS.c_LEVEL_INFO_DETAIL),g_LEVEL_STRING_MO_INFO);
	SP.GET_SYSTEM_LABEL_VALUE_BY_CODE(0,'System','Logging','Log Levels','Values',TO_CHAR(LOGS.c_LEVEL_INFO_MORE_DETAIL),g_LEVEL_STRING_MAX_INFO);
	SP.GET_SYSTEM_LABEL_VALUE_BY_CODE(0,'System','Logging','Log Levels','Values',TO_CHAR(LOGS.c_LEVEL_DEBUG),g_LEVEL_STRING_DEBUG);
	SP.GET_SYSTEM_LABEL_VALUE_BY_CODE(0,'System','Logging','Log Levels','Values',TO_CHAR(LOGS.c_LEVEL_DEBUG_DETAIL),g_LEVEL_STRING_MO_DEBUG);
	SP.GET_SYSTEM_LABEL_VALUE_BY_CODE(0,'System','Logging','Log Levels','Values',TO_CHAR(LOGS.c_LEVEL_DEBUG_MORE_DETAIL),g_LEVEL_STRING_MAX_DEBUG);

	-- defaults
	g_LEVEL_STRING_FATAL := NVL(g_LEVEL_STRING_FATAL,'Fatal');
	g_LEVEL_STRING_ERROR := NVL(g_LEVEL_STRING_ERROR,'Error');
	g_LEVEL_STRING_WARN := NVL(g_LEVEL_STRING_WARN,'Warning');
	g_LEVEL_STRING_NOTICE := NVL(g_LEVEL_STRING_NOTICE,'Notice');
	g_LEVEL_STRING_INFO := NVL(g_LEVEL_STRING_INFO,'Info');
	g_LEVEL_STRING_MO_INFO := NVL(g_LEVEL_STRING_MO_INFO,'More Info');
	g_LEVEL_STRING_MAX_DEBUG := NVL(g_LEVEL_STRING_MAX_DEBUG,'Max Info');
	g_LEVEL_STRING_DEBUG := NVL(g_LEVEL_STRING_DEBUG,'Debug');
	g_LEVEL_STRING_MO_DEBUG := NVL(g_LEVEL_STRING_MO_DEBUG,'More Debug');
	g_LEVEL_STRING_MAX_DEBUG := NVL(g_LEVEL_STRING_MAX_DEBUG,'Max Debug');

END LOG_REPORTS;
/
