CREATE OR REPLACE PACKAGE EX AS
--Revision $Revision: 1.42 $
--  EXPORT PACKAGE

FUNCTION WHAT_VERSION RETURN VARCHAR;


PROCEDURE GET_EXPORT_FORECAST
    (
	p_FORMAT_ALIAS IN VARCHAR,
	p_EXPORT_TYPE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_ACCOUNT_SUMMARY IN NUMBER,
	p_USE_DETAIL_UNITS IN NUMBER,
	p_TIME_AGGREGATE IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE GET_SYSTEM_LABELS
	(
	p_MODEL_ID IN NUMBER := 0,
	p_MODULE IN VARCHAR,
	p_KEY1 IN VARCHAR,
	p_KEY2 IN VARCHAR,
	p_KEY3 IN VARCHAR,
	p_MATCH_CASE IN NUMBER := 0,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE GET_LABELS_USE_DICTIONARY
	(
	p_MODEL_ID IN NUMBER := 0,
	p_MODULE IN VARCHAR,
	p_KEY1 IN VARCHAR,
	p_KEY2 IN VARCHAR,
	p_KEY3 IN VARCHAR,
	p_MATCH_CASE IN NUMBER := 0,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE GET_SYSTEM_TYPE_OF_POWER
	(
	p_VALUE OUT VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_EXPORT_UNITS
	(
	p_MODEL_ID IN NUMBER := 0,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE GET_INTERVALS
	(
	p_MODEL_ID IN NUMBER := 0,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE GET_EXPORT_TYPE_NAMES
	(
	p_MODEL_ID IN NUMBER := 0,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE GET_EXPORT_NAMES
	(
	p_EXPORT_GROUP IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE GET_EXPORT_GROUPS
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE GET_GROUP_EXPORT
	(
	p_EXPORT_NAME IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PUT_GROUP_EXPORT
    (
	p_EXPORT_NAME IN VARCHAR,
	p_EXPORT_GROUP IN VARCHAR,
	p_EXPORT_FORMAT IN VARCHAR,
	p_EXPORT_TYPE IN CHAR,
	p_BEGIN_DATE_OFFSET IN NUMBER,
	p_END_DATE_OFFSET IN VARCHAR,
	p_EXPORT_INTERVAL IN VARCHAR,
	p_EXPORT_UNITS IN VARCHAR,
	p_EXPORT_ACCOUNT_OPTION IN VARCHAR,
	p_EXPORT_DELIMITER IN VARCHAR,
	p_EXPORT_DIRECTORY IN VARCHAR,
	p_EXPORT_DISPOSITION IN VARCHAR,
	p_FILE_PREFIX IN VARCHAR,
	p_FILE_DATE_FORMAT IN VARCHAR,
	p_FILE_SUFFIX IN VARCHAR,
	p_FILE_AUTOINCR_SUFFIX IN VARCHAR,
	p_FILE_EXTENSION IN VARCHAR,
	p_PRINT_COLUMN_HEADERS IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE REMOVE_GROUP_EXPORT
	(
	p_EXPORT_NAME IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_FORMATS_AND_DELIMITERS
	(
	p_EXPORT_TYPE_NAME IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

g_MODULE_NAME VARCHAR(16) := 'PUBLIC';
g_ALL_STRING VARCHAR(5) := '<ALL>';
g_Wildcard CHAR(2) := '??';

 END EX ;
/
CREATE OR REPLACE PACKAGE BODY EX  AS
-----------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
    RETURN '$Revision: 1.42 $';
END WHAT_VERSION;
----------------------------------------------------------------------------------------------------
FUNCTION SERVICE_IS_VERSIONED
	(
	p_REQUEST_TYPE IN CHAR
	)  RETURN BOOLEAN IS

-- Answer True if the Service is versioned for the specified request type; otherwise answer False.

BEGIN

	RETURN ((p_REQUEST_TYPE = GA.FORECAST_SERVICE AND GA.VERSION_FORECAST)
		OR (p_REQUEST_TYPE = GA.BACKCAST_SERVICE AND GA.VERSION_BACKCAST)
		OR (p_REQUEST_TYPE = GA.ACTUAL_SERVICE AND GA.VERSION_ACTUAL));

END SERVICE_IS_VERSIONED;
---------------------------------------------------------------------------------------------------
FUNCTION IS_VERSIONED_REQUEST
	(
	p_REQUEST_TYPE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE
	)  RETURN BOOLEAN IS

-- Answer True if the request is for versioned data; otherwise answer False.

BEGIN

	RETURN (SERVICE_IS_VERSIONED(p_REQUEST_TYPE) AND p_AS_OF_DATE = CURRENT_VERSION_DATE AND NOT TRUNC(p_BEGIN_DATE) = TRUNC(p_END_DATE));

END IS_VERSIONED_REQUEST;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_PPL_EXPORT
    (
	p_EXPORT_TYPE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_ACCOUNT_SUMMARY IN NUMBER,
	p_USE_DETAIL_UNITS IN NUMBER,
	p_TIME_AGGREGATE IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_TIME_AGGREGATE VARCHAR(2);
v_SCALE_FACTOR NUMBER;
BEGIN

		UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	   SELECT DECODE(SUBSTR(p_TIME_AGGREGATE,1,1),'Y','YY','Q','Q','M','MM','D','DD','HH') INTO v_TIME_AGGREGATE FROM DUAL;
	   SELECT DECODE(p_USE_DETAIL_UNITS,1,1,0,.001,1) INTO v_SCALE_FACTOR FROM DUAL;  --data is in KWH in FORECAST

	   IF p_ACCOUNT_SUMMARY = 0 THEN
			IF IS_VERSIONED_REQUEST(p_EXPORT_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) THEN
		      OPEN p_CURSOR FOR -- VERSIONED DETAIL
			  	   SELECT E.EDC_ACCOUNT_NUMBER
				   		  ,TO_CHAR(TRUNC(FROM_CUT(D.LOAD_DATE-.00001, p_TIME_ZONE),v_TIME_AGGREGATE),'fmMm/Dd/YYYY') "Forecast Date"
				   		  ,SUBSTR(FROM_CUT_AS_HED(D.LOAD_DATE, p_TIME_ZONE),12,2) "Hour"
				   		  ,SUM(D.LOAD_VAL)*v_SCALE_FACTOR "Forecast Val"
						  ,FROM_CUT(D.LOAD_DATE, p_TIME_ZONE) "DST_HOUR_HIDDENFIELD"
				   FROM ACCOUNT_SERVICE A, PROVIDER_SERVICE B, SERVICE C, SERVICE_LOAD D, ACCOUNT_EDC E
	            	  WHERE B.ESP_ID = DECODE(p_ESP_ID, -1, B.ESP_ID, p_ESP_ID)
				   	  AND B.EDC_ID = DECODE(p_EDC_ID, -1, B.EDC_ID, p_EDC_ID)
						  AND C.MODEL_ID = CONSTANTS.ELECTRIC_MODEL
						  AND C.SCENARIO_ID = 1
						  AND C.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
						  AND C.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
						  AND C.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
						  AND C.AS_OF_DATE =
								(SELECT MAX(AS_OF_DATE)
								FROM SERVICE
								WHERE MODEL_ID = C.MODEL_ID
									AND SCENARIO_ID = 1
									AND ACCOUNT_SERVICE_ID = C.ACCOUNT_SERVICE_ID
									AND PROVIDER_SERVICE_ID = C.PROVIDER_SERVICE_ID
									AND SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
									AND AS_OF_DATE <= p_AS_OF_DATE)
						  AND D.SERVICE_CODE = p_EXPORT_TYPE
						  AND D.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
						  AND D.LOAD_CODE = GA.STANDARD
						  AND D.SERVICE_ID = C.SERVICE_ID
						  AND E.BEGIN_DATE <= D.LOAD_DATE
						  AND (E.END_DATE >= D.LOAD_DATE OR E.END_DATE IS NULL)
						  AND E.ACCOUNT_ID = A.ACCOUNT_ID
						  AND E.EDC_ID = B.EDC_ID
				 		  AND A.AGGREGATE_ID = 0
				   GROUP BY E.EDC_ACCOUNT_NUMBER
				   		  ,TO_CHAR(TRUNC(FROM_CUT(D.LOAD_DATE-.00001, p_TIME_ZONE),v_TIME_AGGREGATE),'fmMm/Dd/YYYY')
				   		  ,SUBSTR(FROM_CUT_AS_HED(D.LOAD_DATE, p_TIME_ZONE),12,2)
						  ,FROM_CUT(D.LOAD_DATE, p_TIME_ZONE)
				   ORDER BY TRUNC(FROM_CUT(D.LOAD_DATE, p_TIME_ZONE) - .00001),
				   		  E.EDC_ACCOUNT_NUMBER,
				   		  SUBSTR(FROM_CUT_AS_HED(D.LOAD_DATE, p_TIME_ZONE),12,2);
				ELSE -- UNVERSIONED DETAIL
		      OPEN p_CURSOR FOR -- VERSIONED DETAIL
			  	   SELECT E.EDC_ACCOUNT_NUMBER
				   		  ,TO_CHAR(TRUNC(FROM_CUT(D.LOAD_DATE-.00001, p_TIME_ZONE),v_TIME_AGGREGATE),'fmMm/Dd/YYYY') "Forecast Date"
				   		  ,SUBSTR(FROM_CUT_AS_HED(D.LOAD_DATE, p_TIME_ZONE),12,2) "Hour"
				   		  ,SUM(D.LOAD_VAL)*v_SCALE_FACTOR "Forecast Val"
						  ,FROM_CUT(D.LOAD_DATE, p_TIME_ZONE) "DST_HOUR_HIDDENFIELD"
				   FROM ACCOUNT_SERVICE A, PROVIDER_SERVICE B, SERVICE C, SERVICE_LOAD D, ACCOUNT_EDC E
	            	  WHERE B.ESP_ID = DECODE(p_ESP_ID, -1, B.ESP_ID, p_ESP_ID)
				   	  AND B.EDC_ID = DECODE(p_EDC_ID, -1, B.EDC_ID, p_EDC_ID)
						  AND C.MODEL_ID = CONSTANTS.ELECTRIC_MODEL
						  AND C.SCENARIO_ID = 1
						  AND C.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
						  AND C.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
						  AND C.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
						  AND C.AS_OF_DATE = LOW_DATE
						  AND D.SERVICE_CODE = p_EXPORT_TYPE
						  AND D.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
						  AND D.LOAD_CODE = GA.STANDARD
						  AND D.SERVICE_ID = C.SERVICE_ID
						  AND E.BEGIN_DATE <= D.LOAD_DATE
						  AND (E.END_DATE >= D.LOAD_DATE OR E.END_DATE IS NULL)
						  AND E.ACCOUNT_ID = A.ACCOUNT_ID
						  AND E.EDC_ID = B.EDC_ID
				 		  AND A.AGGREGATE_ID = 0
				   GROUP BY E.EDC_ACCOUNT_NUMBER
				   		  ,TO_CHAR(TRUNC(FROM_CUT(D.LOAD_DATE-.00001, p_TIME_ZONE),v_TIME_AGGREGATE),'fmMm/Dd/YYYY')
				   		  ,SUBSTR(FROM_CUT_AS_HED(D.LOAD_DATE, p_TIME_ZONE),12,2)
						  ,FROM_CUT(D.LOAD_DATE, p_TIME_ZONE)
				   ORDER BY TRUNC(FROM_CUT(D.LOAD_DATE, p_TIME_ZONE) - .00001),
				   		  E.EDC_ACCOUNT_NUMBER,
				   		  SUBSTR(FROM_CUT_AS_HED(D.LOAD_DATE, p_TIME_ZONE),12,2);
				END IF;
		ELSE  --Summary
			IF IS_VERSIONED_REQUEST(p_EXPORT_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) THEN
		      OPEN p_CURSOR FOR
			  	   SELECT TO_CHAR(TRUNC(FROM_CUT(D.LOAD_DATE-.00001, p_TIME_ZONE),v_TIME_AGGREGATE),'fmMm/Dd/YYYY') "Forecast Date"
				   		  ,SUBSTR(FROM_CUT_AS_HED(D.LOAD_DATE, p_TIME_ZONE),12,2) "Hour"
				   		  ,SUM(D.LOAD_VAL)*v_SCALE_FACTOR "Forecast Val"
						  ,FROM_CUT(D.LOAD_DATE, p_TIME_ZONE) "DST_HOUR_HIDDENFIELD"
					FROM ACCOUNT_SERVICE A, PROVIDER_SERVICE B, SERVICE C, SERVICE_LOAD D, ACCOUNT_EDC E
	            WHERE B.ESP_ID = DECODE(p_ESP_ID, -1, B.ESP_ID, p_ESP_ID)
				  		AND B.EDC_ID = DECODE(p_EDC_ID, -1, B.EDC_ID, p_EDC_ID)
						AND C.MODEL_ID = CONSTANTS.ELECTRIC_MODEL
						AND C.SCENARIO_ID = 1
						AND C.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
						AND C.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
						AND C.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
					  	AND C.AS_OF_DATE =
							(SELECT MAX(AS_OF_DATE)
							FROM SERVICE
							WHERE MODEL_ID = C.MODEL_ID
								AND SCENARIO_ID = 1
								AND ACCOUNT_SERVICE_ID = C.ACCOUNT_SERVICE_ID
								AND PROVIDER_SERVICE_ID = C.PROVIDER_SERVICE_ID
								AND SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
								AND AS_OF_DATE <= p_AS_OF_DATE)
						AND D.SERVICE_CODE = p_EXPORT_TYPE
						AND D.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
						AND D.LOAD_CODE = GA.STANDARD
						AND D.SERVICE_ID = C.SERVICE_ID
						AND E.BEGIN_DATE <= D.LOAD_DATE
						AND (E.END_DATE >= D.LOAD_DATE OR E.END_DATE IS NULL)
						AND E.ACCOUNT_ID = A.ACCOUNT_ID
						AND E.EDC_ID = B.EDC_ID
				   GROUP BY TO_CHAR(TRUNC(FROM_CUT(D.LOAD_DATE-.00001, p_TIME_ZONE),v_TIME_AGGREGATE),'fmMm/Dd/YYYY')
				   		  ,SUBSTR(FROM_CUT_AS_HED(D.LOAD_DATE, p_TIME_ZONE),12,2)
						  ,FROM_CUT(D.LOAD_DATE, p_TIME_ZONE)
				   ORDER BY FROM_CUT(D.LOAD_DATE, p_TIME_ZONE);
			ELSE --NON-VERSIONED SUMMARY
		      OPEN p_CURSOR FOR
			  	   SELECT TO_CHAR(TRUNC(FROM_CUT(D.LOAD_DATE-.00001, p_TIME_ZONE),v_TIME_AGGREGATE),'fmMm/Dd/YYYY') "Forecast Date"
				   		  ,SUBSTR(FROM_CUT_AS_HED(D.LOAD_DATE, p_TIME_ZONE),12,2) "Hour"
				   		  ,SUM(D.LOAD_VAL)*v_SCALE_FACTOR "Forecast Val"
						  ,FROM_CUT(D.LOAD_DATE, p_TIME_ZONE) "DST_HOUR_HIDDENFIELD"
					FROM ACCOUNT_SERVICE A, PROVIDER_SERVICE B, SERVICE C, SERVICE_LOAD D, ACCOUNT_EDC E
	            WHERE B.ESP_ID = DECODE(p_ESP_ID, -1, B.ESP_ID, p_ESP_ID)
				  		AND B.EDC_ID = DECODE(p_EDC_ID, -1, B.EDC_ID, p_EDC_ID)
						AND C.MODEL_ID = CONSTANTS.ELECTRIC_MODEL
						AND C.SCENARIO_ID = 1
						AND C.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
						AND C.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
						AND C.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
					  	AND C.AS_OF_DATE = LOW_DATE
						AND D.SERVICE_CODE = p_EXPORT_TYPE
						AND D.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
						AND D.LOAD_CODE = GA.STANDARD
						AND D.SERVICE_ID = C.SERVICE_ID
						AND E.BEGIN_DATE <= D.LOAD_DATE
						AND (E.END_DATE >= D.LOAD_DATE OR E.END_DATE IS NULL)
						AND E.ACCOUNT_ID = A.ACCOUNT_ID
						AND E.EDC_ID = B.EDC_ID
				   GROUP BY TO_CHAR(TRUNC(FROM_CUT(D.LOAD_DATE-.00001, p_TIME_ZONE),v_TIME_AGGREGATE),'fmMm/Dd/YYYY')
				   		  ,SUBSTR(FROM_CUT_AS_HED(D.LOAD_DATE, p_TIME_ZONE),12,2)
						  ,FROM_CUT(D.LOAD_DATE, p_TIME_ZONE)
				   ORDER BY FROM_CUT(D.LOAD_DATE, p_TIME_ZONE);
			END IF;
		END IF;

    EXCEPTION
        WHEN OTHERS THEN
			ERRS.LOG_AND_RAISE();

END GET_PPL_EXPORT;
-----------------------------------------------------------------------------------------------

PROCEDURE GET_MEC_EXPORT
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_ACCOUNT_SUMMARY IN NUMBER,
	p_SCALE_FACTOR IN NUMBER,
	p_TIME_AGGREGATE IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_TIME_AGGREGATE VARCHAR(2);
g_NA_TABLE NUMBER(2) := 0;
v_SCALE_FACTOR NUMBER(9);

BEGIN

--  note, in v1.05 vb was passing in 1 for KW and ?? zero for MW units, so a decode statement has been added
--  this will need to be migrated in v1.06 to look at table units values

		UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	   SELECT DECODE(SUBSTR(p_TIME_AGGREGATE,1,1),'Y','YY','Q','Q','M','MM','D','DD','HH') INTO v_TIME_AGGREGATE FROM DUAL;

	   IF p_ACCOUNT_SUMMARY = 0 THEN
			IF IS_VERSIONED_REQUEST(GA.FORECAST_SERVICE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) THEN

				OPEN p_CURSOR FOR
					SELECT E.EDC_ACCOUNT_NUMBER
				   		,FROM_CUT_AS_HED(D.LOAD_DATE, p_TIME_ZONE) "Forecast Date"
				   		,SUM(D.LOAD_VAL)* (DECODE(p_SCALE_FACTOR, 1, p_SCALE_FACTOR, .001)) "Forecast Val"
					FROM ACCOUNT_SERVICE A, PROVIDER_SERVICE B, SERVICE C, SERVICE_LOAD D, ACCOUNT_EDC E
					WHERE B.ESP_ID = DECODE(p_ESP_ID, -1, B.ESP_ID, p_ESP_ID)
						AND B.EDC_ID = DECODE(p_EDC_ID, -1, B.EDC_ID, p_EDC_ID)
						AND C.MODEL_ID = CONSTANTS.ELECTRIC_MODEL
						AND C.SCENARIO_ID = 1
						AND C.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
						AND C.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
						AND C.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
						AND C.AS_OF_DATE =
							(SELECT MAX(AS_OF_DATE)
							FROM SERVICE
							WHERE MODEL_ID = C.MODEL_ID
								AND SCENARIO_ID = 1
								AND ACCOUNT_SERVICE_ID = C.ACCOUNT_SERVICE_ID
								AND PROVIDER_SERVICE_ID = C.PROVIDER_SERVICE_ID
								AND SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
								AND AS_OF_DATE <= p_AS_OF_DATE)
						AND D.SERVICE_CODE = GA.FORECAST_SERVICE
						AND D.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
						AND D.LOAD_CODE = GA.STANDARD
						AND D.SERVICE_ID = C.SERVICE_ID
						AND E.BEGIN_DATE <= D.LOAD_DATE
						AND (E.END_DATE >= D.LOAD_DATE OR E.END_DATE IS NULL)
						AND E.ACCOUNT_ID = A.ACCOUNT_ID
					 	AND E.EDC_ID = B.EDC_ID
				   GROUP BY E.EDC_ACCOUNT_NUMBER
				   		  ,FROM_CUT_AS_HED(D.LOAD_DATE, p_TIME_ZONE)
				   ORDER BY 1, 2;
			ELSE -- NON-VERSIONED DETAIL
				 OPEN p_CURSOR FOR
					SELECT E.EDC_ACCOUNT_NUMBER
				   		,FROM_CUT_AS_HED(D.LOAD_DATE, p_TIME_ZONE) "Forecast Date"
				   		,SUM(D.LOAD_VAL)* (DECODE(p_SCALE_FACTOR, 1, p_SCALE_FACTOR, .001)) "Forecast Val"
					FROM ACCOUNT_SERVICE A, PROVIDER_SERVICE B, SERVICE C, SERVICE_LOAD D, ACCOUNT_EDC E
					WHERE B.ESP_ID = DECODE(p_ESP_ID, -1, B.ESP_ID, p_ESP_ID)
						AND B.EDC_ID = DECODE(p_EDC_ID, -1, B.EDC_ID, p_EDC_ID)
						AND C.MODEL_ID = CONSTANTS.ELECTRIC_MODEL
						AND C.SCENARIO_ID = 1
						AND C.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
						AND C.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
						AND C.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
						AND C.AS_OF_DATE = LOW_DATE
						AND D.SERVICE_CODE = GA.FORECAST_SERVICE
						AND D.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
						AND D.LOAD_CODE = GA.STANDARD
						AND D.SERVICE_ID = C.SERVICE_ID
						AND E.BEGIN_DATE <= D.LOAD_DATE
						AND (E.END_DATE >= D.LOAD_DATE OR E.END_DATE IS NULL)
						AND E.ACCOUNT_ID = A.ACCOUNT_ID
					 	AND E.EDC_ID = B.EDC_ID
				   GROUP BY E.EDC_ACCOUNT_NUMBER
				   		  ,FROM_CUT_AS_HED(D.LOAD_DATE, p_TIME_ZONE)
				   ORDER BY 1, 2;
			END IF;
		ELSE  --Summary
			IF IS_VERSIONED_REQUEST(GA.FORECAST_SERVICE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) THEN
		      OPEN p_CURSOR FOR
			  	   SELECT FROM_CUT_AS_HED(C.LOAD_DATE, p_TIME_ZONE) "Forecast Date"
				   		  ,SUM(C.LOAD_VAL)* (DECODE(p_SCALE_FACTOR, 1, 1000, 1))"Forecast Val"
				   FROM PROVIDER_SERVICE A, SERVICE_OBLIGATION B, SERVICE_OBLIGATION_LOAD C
					WHERE A.EDC_ID = DECODE(p_EDC_ID, CONSTANTS.ALL_ID, DECODE(A.EDC_ID, g_NA_TABLE, NULL, A.EDC_ID), p_EDC_ID)
						AND A.ESP_ID = DECODE(p_ESP_ID, CONSTANTS.ALL_ID, A.ESP_ID, p_ESP_ID)
						AND B.MODEL_ID = CONSTANTS.ELECTRIC_MODEL
						AND B.SCENARIO_ID = 1
						AND B.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
						AND B.SERVICE_DELIVERY_ID = B.SERVICE_DELIVERY_ID
						AND B.AS_OF_DATE =
							(SELECT MAX(AS_OF_DATE)
							FROM SERVICE_OBLIGATION
							WHERE MODEL_ID = B.MODEL_ID
								AND SCENARIO_ID = 1
								AND PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
								AND SERVICE_DELIVERY_ID = B.SERVICE_DELIVERY_ID
								AND AS_OF_DATE <= p_AS_OF_DATE)
						AND C.SERVICE_CODE = GA.FORECAST_SERVICE
						AND C.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
						AND C.LOAD_CODE = GA.STANDARD
				   GROUP BY FROM_CUT_AS_HED(C.LOAD_DATE, p_TIME_ZONE)
				   ORDER BY 1;
			ELSE
		      OPEN p_CURSOR FOR
			  	   SELECT FROM_CUT_AS_HED(C.LOAD_DATE, p_TIME_ZONE) "Forecast Date"
				   		  ,SUM(C.LOAD_VAL)* (DECODE(p_SCALE_FACTOR, 1, 1000, 1))"Forecast Val"
				   FROM PROVIDER_SERVICE A, SERVICE_OBLIGATION B, SERVICE_OBLIGATION_LOAD C
					WHERE A.EDC_ID = DECODE(p_EDC_ID, CONSTANTS.ALL_ID, DECODE(A.EDC_ID, g_NA_TABLE, NULL, A.EDC_ID), p_EDC_ID)
						AND A.ESP_ID = DECODE(p_ESP_ID, CONSTANTS.ALL_ID, A.ESP_ID, p_ESP_ID)
						AND B.MODEL_ID = CONSTANTS.ELECTRIC_MODEL
						AND B.SCENARIO_ID = 1
						AND B.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
						AND B.SERVICE_DELIVERY_ID = B.SERVICE_DELIVERY_ID
						AND B.AS_OF_DATE = LOW_DATE
						AND C.SERVICE_CODE = GA.FORECAST_SERVICE
						AND C.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
						AND C.LOAD_CODE = GA.STANDARD
				   GROUP BY FROM_CUT_AS_HED(C.LOAD_DATE, p_TIME_ZONE)
				   ORDER BY 1;
			END IF;
		END IF;

    EXCEPTION
        WHEN OTHERS THEN
			ERRS.LOG_AND_RAISE();

END GET_MEC_EXPORT;
-----------------------------------------------------------------------------------------------
PROCEDURE GET_PECO_EXPORT
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_ACCOUNT_SUMMARY IN NUMBER,
	p_SCALE_FACTOR IN NUMBER,
	p_TIME_AGGREGATE IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

	DBMS_OUTPUT.PUT_LINE('GET_PECO_EXPORT');
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	IF IS_VERSIONED_REQUEST(GA.FORECAST_SERVICE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) THEN
		OPEN p_CURSOR FOR
			SELECT E.VALUE "PECO_SUCCESS_NAME",
					 TO_HED(A.FORECAST_DATE) "FORECAST_DATE_HIDDENFIELD",
					 TRUNC(A.FORECAST_DATE - .0001) "ORDERBY_HIDDENFIELD",
			    	 TO_CHAR(TRUNC(A.FORECAST_DATE - .0001),'DD-Mon-YYYY') "FORECAST_DATE",
					 B.ACCOUNT_NAME, D.EDC_ACCOUNT_NUMBER, A.FORECAST_VAL
			FROM (SELECT A.EDC_ID, A.ESP_ID, B.ACCOUNT_ID,
				  		FROM_CUT(D.LOAD_DATE, p_TIME_ZONE) "FORECAST_DATE", D.LOAD_VAL*p_SCALE_FACTOR "FORECAST_VAL"
				  FROM PROVIDER_SERVICE A, ACCOUNT_SERVICE B, SERVICE C, SERVICE_LOAD D, SERVICE_STATE E
				  WHERE (p_EDC_ID = CONSTANTS.ALL_ID OR A.EDC_ID = p_EDC_ID)
					AND (p_ESP_ID = CONSTANTS.ALL_ID OR A.ESP_ID = p_ESP_ID)
					AND B.AGGREGATE_ID = CONSTANTS.NOT_ASSIGNED
					AND C.MODEL_ID = CONSTANTS.ELECTRIC_MODEL
					AND C.SCENARIO_ID = 1
					AND C.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
					AND C.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
					AND C.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
					AND C.AS_OF_DATE =
						(SELECT MAX(AS_OF_DATE)
						FROM SERVICE
						WHERE MODEL_ID = C.MODEL_ID
							AND SCENARIO_ID = 1
							AND PROVIDER_SERVICE_ID = C.PROVIDER_SERVICE_ID
							AND ACCOUNT_SERVICE_ID = C.ACCOUNT_SERVICE_ID
							AND SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
							AND AS_OF_DATE <= p_AS_OF_DATE)
					AND D.SERVICE_CODE = GA.FORECAST_SERVICE
					AND D.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
					AND D.LOAD_CODE = GA.STANDARD
					AND D.SERVICE_ID = C.SERVICE_ID
					AND E.SERVICE_CODE = GA.FORECAST_SERVICE
					AND E.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
					AND E.METER_TYPE = 'I'
					AND E.SERVICE_ID = C.SERVICE_ID) A,
				ACCOUNT B,
				ENERGY_SERVICE_PROVIDER C,
				ACCOUNT_EDC D,
				SYSTEM_DICTIONARY E
			WHERE B.ACCOUNT_ID = A.ACCOUNT_ID
				AND C.ESP_ID = A.ESP_ID
				AND D.ACCOUNT_ID = A.ACCOUNT_ID
				AND D.EDC_ID = A.EDC_ID
				AND D.BEGIN_DATE <= v_END_DATE
				AND NVL(D.END_DATE, v_BEGIN_DATE) >= v_BEGIN_DATE
				AND E.MODEL_ID = 0
				AND E.MODULE = '?'
				AND E.KEY1 = '?'
				AND E.KEY2 = '?'
				AND E.KEY3 = '?'
				AND E.SETTING_NAME = 'PECO_SUCCESS_' || C.ESP_NAME
			ORDER BY 3,1,5,6,2;
	ELSE
		OPEN p_CURSOR FOR
			SELECT E.VALUE "PECO_SUCCESS_NAME",
					 TO_HED(A.FORECAST_DATE) "FORECAST_DATE_HIDDENFIELD",
					 TRUNC(A.FORECAST_DATE - .0001) "ORDERBY_HIDDENFIELD",
			    	 TO_CHAR(TRUNC(A.FORECAST_DATE - .0001),'DD-Mon-YYYY') "FORECAST_DATE",
					 B.ACCOUNT_NAME, D.EDC_ACCOUNT_NUMBER, A.FORECAST_VAL
			FROM (SELECT A.EDC_ID, A.ESP_ID, B.ACCOUNT_ID,
				  		FROM_CUT(D.LOAD_DATE, p_TIME_ZONE) "FORECAST_DATE", D.LOAD_VAL*p_SCALE_FACTOR "FORECAST_VAL"
				  FROM PROVIDER_SERVICE A, ACCOUNT_SERVICE B, SERVICE C, SERVICE_LOAD D, SERVICE_STATE E
				  WHERE (p_EDC_ID = CONSTANTS.ALL_ID OR A.EDC_ID = p_EDC_ID)
					AND (p_ESP_ID = CONSTANTS.ALL_ID OR A.ESP_ID = p_ESP_ID)
					AND B.AGGREGATE_ID = CONSTANTS.NOT_ASSIGNED
					AND C.MODEL_ID = CONSTANTS.ELECTRIC_MODEL
					AND C.SCENARIO_ID = 1
					AND C.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
					AND C.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
					AND C.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
					AND C.AS_OF_DATE = LOW_DATE
					AND D.SERVICE_CODE = GA.FORECAST_SERVICE
					AND D.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
					AND D.LOAD_CODE = GA.STANDARD
					AND D.SERVICE_ID = C.SERVICE_ID
					AND E.SERVICE_CODE = GA.FORECAST_SERVICE
					AND E.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
					AND E.METER_TYPE = 'I'
					AND E.SERVICE_ID = C.SERVICE_ID) A,
				ACCOUNT B,
				ENERGY_SERVICE_PROVIDER C,
				ACCOUNT_EDC D,
				SYSTEM_DICTIONARY E
			WHERE B.ACCOUNT_ID = A.ACCOUNT_ID
				AND C.ESP_ID = A.ESP_ID
				AND D.ACCOUNT_ID = A.ACCOUNT_ID
				AND D.EDC_ID = A.EDC_ID
				AND D.BEGIN_DATE <= v_END_DATE
				AND NVL(D.END_DATE, v_BEGIN_DATE) >= v_BEGIN_DATE
				AND E.MODEL_ID = 0
				AND E.MODULE = '?'
				AND E.KEY1 = '?'
				AND E.KEY2 = '?'
				AND E.KEY3 = '?'
				AND E.SETTING_NAME = 'PECO_SUCCESS_' || C.ESP_NAME
			ORDER BY 3,1,5,6,2;
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_RAISE();

END GET_PECO_EXPORT;
-----------------------------------------------------------------------------------------------
PROCEDURE GET_CIN_GENCO_EXPORT
    (
	p_EXPORT_TYPE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_ACCOUNT_SUMMARY IN NUMBER,
	p_SCALE_FACTOR IN NUMBER,
	p_TIME_AGGREGATE IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_SCALE_FACTOR NUMBER;

BEGIN

		UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	    --Note scale factor NOT IMPLEMENTED YET here, but should convert from MW data in this format
		v_SCALE_FACTOR := 1000*p_SCALE_FACTOR;
		OPEN p_CURSOR FOR
			 SELECT
    	   	 	--TO_CHAR(TRUNC(FROM_CUT(THE_DATE-.00001, 'EST'),'mm'),'Mm/Dd/YYYY') "Load_Date"
		   	 	SUBSTR(FROM_CUT_AS_HED(THE_DATE, p_TIME_ZONE),1,16) "Load_Date",
					STANDARD_OFFER "STANDARD_OFFER (MWH)",
					DEFAULT_SUPPLY "DEFAULT_SUPPLY (MWH)",
					BUG "BUG (MWH)"
			 FROM EXPORT_FORECAST_CIN_GENCO
			 WHERE THE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			    AND THE_AS_OF_DATE =
			      (SELECT MAX(AS_OF_DATE)
			 	   	FROM SERVICE_OBLIGATION A, SERVICE_OBLIGATION_LOAD B
				   	WHERE MODEL_ID = CONSTANTS.ELECTRIC_MODEL
						AND SCENARIO_ID = 1
						AND B.SERVICE_CODE = 'F'
						AND B.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
						AND B.LOAD_CODE = '1'
						AND B.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
				   	AND AS_OF_DATE <= p_AS_OF_DATE)
			 ORDER BY THE_DATE;

    EXCEPTION
        WHEN OTHERS THEN
			ERRS.LOG_AND_RAISE();

END GET_CIN_GENCO_EXPORT;
-----------------------------------------------------------------------------------------------

PROCEDURE GET_CIN_CGEOHIO_EXPORT
    (
	p_EXPORT_TYPE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_ACCOUNT_SUMMARY IN NUMBER,
	p_SCALE_FACTOR IN NUMBER,
	p_TIME_AGGREGATE IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

		UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

		OPEN p_CURSOR FOR
			 SELECT
	             SUBSTR(FROM_CUT_AS_HED(B.LOAD_DATE, p_TIME_ZONE),1,16) "Date",
			     SUM(B.LOAD_VAL * DECODE(A.OPERATION_CODE,'A',1.0,'S',-1.0,1.0)) "CGE OHIO Forecast (MWH)"
		     FROM SYSTEM_LOAD_AREA A,
			     AREA_LOAD B,
			     SYSTEM_LOAD C
		     WHERE A.AREA_ID = B.AREA_ID
			   AND A.SYSTEM_LOAD_ID = C.SYSTEM_LOAD_ID
			   AND C.SYSTEM_LOAD_NAME = 'CGE OHIO'
			   AND B.LOAD_CODE = p_EXPORT_TYPE  --'F'
			   AND B.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			   AND B.AS_OF_DATE = AREA_LOAD_AS_OF_DATE(B.AREA_ID, B.LOAD_CODE, B.LOAD_DATE, p_AS_OF_DATE)
		     GROUP BY SUBSTR(FROM_CUT_AS_HED(B.LOAD_DATE, p_TIME_ZONE),1,16)
		     ORDER BY 1;

    EXCEPTION
        WHEN OTHERS THEN
			ERRS.LOG_AND_RAISE();

END GET_CIN_CGEOHIO_EXPORT;
-----------------------------------------------------------------------------------------------

PROCEDURE GET_PECO_NO_VRSN_EXPORT
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_ACCOUNT_SUMMARY IN NUMBER,
	p_SCALE_FACTOR IN NUMBER,
	p_TIME_AGGREGATE IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	OPEN p_CURSOR FOR
		SELECT E.VALUE "PECO_SUCCESS_NAME",
				 TO_HED(A.FORECAST_DATE) "FORECAST_DATE_HIDDENFIELD",
				 TRUNC(A.FORECAST_DATE - .0001) "ORDERBY_HIDDENFIELD",
		    	 TO_CHAR(TRUNC(A.FORECAST_DATE - .0001),'DD-Mon-YYYY') "FORECAST_DATE",
				 B.ACCOUNT_NAME, D.EDC_ACCOUNT_NUMBER, A.FORECAST_VAL
		FROM (SELECT A.EDC_ID, A.ESP_ID, B.ACCOUNT_ID,
			  		FROM_CUT(D.LOAD_DATE, p_TIME_ZONE) "FORECAST_DATE", D.LOAD_VAL*p_SCALE_FACTOR "FORECAST_VAL"
			  FROM PROVIDER_SERVICE A, ACCOUNT_SERVICE B, SERVICE C, SERVICE_LOAD D, SERVICE_STATE E
			  WHERE (p_EDC_ID = CONSTANTS.ALL_ID OR A.EDC_ID = p_EDC_ID)
				AND (p_ESP_ID = CONSTANTS.ALL_ID OR A.ESP_ID = p_ESP_ID)
				AND A.PSE_ID = A.PSE_ID
				AND B.AGGREGATE_ID = CONSTANTS.NOT_ASSIGNED
				AND C.MODEL_ID = CONSTANTS.ELECTRIC_MODEL
				AND C.SCENARIO_ID = 1
				AND C.AS_OF_DATE = LOW_DATE
				AND C.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
				AND C.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
				AND C.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
				AND D.SERVICE_CODE = GA.FORECAST_SERVICE
				AND D.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND D.LOAD_CODE = GA.STANDARD
				AND D.SERVICE_ID = C.SERVICE_ID
				AND E.SERVICE_CODE = GA.FORECAST_SERVICE
				AND E.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
				AND E.METER_TYPE = 'I'
				AND E.SERVICE_ID = C.SERVICE_ID)A,
			ACCOUNT B,
			ENERGY_SERVICE_PROVIDER C,
			ACCOUNT_EDC D,
			SYSTEM_DICTIONARY E
		WHERE B.ACCOUNT_ID = A.ACCOUNT_ID
			AND C.ESP_ID = A.ESP_ID
			AND D.ACCOUNT_ID = A.ACCOUNT_ID
			AND D.EDC_ID = A.EDC_ID
			AND D.BEGIN_DATE <= v_END_DATE
			AND NVL(D.END_DATE, v_BEGIN_DATE) >= v_BEGIN_DATE
            AND E.MODEL_ID = 0
            AND E.MODULE = '?'
            AND E.KEY1 = '?'
            AND E.KEY2 = '?'
            AND E.KEY3 = '?'
            AND E.SETTING_NAME = 'PECO_SUCCESS_' || C.ESP_NAME
		ORDER BY 3,1,5,6,2;

    EXCEPTION
        WHEN OTHERS THEN
			ERRS.LOG_AND_RAISE();

END GET_PECO_NO_VRSN_EXPORT;
-----------------------------------------------------------------------------------------------

PROCEDURE GET_EXPORT_FORECAST
    (
	p_FORMAT_ALIAS IN VARCHAR,
	p_EXPORT_TYPE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_ACCOUNT_SUMMARY IN NUMBER,
	p_USE_DETAIL_UNITS IN NUMBER,
	p_TIME_AGGREGATE IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

p_SCALE_FACTOR NUMBER;
v_ELAPSED NUMBER;

BEGIN

	v_ELAPSED := DBMS_UTILITY.GET_TIME;

	IF (p_USE_DETAIL_UNITS = 1) THEN
	    p_SCALE_FACTOR := 1;  --
	ELSE
	    p_SCALE_FACTOR := .001;  --
	END IF;

	IF UPPER(p_FORMAT_ALIAS) = 'PPL' THEN
		GET_PPL_EXPORT(p_EXPORT_TYPE,p_BEGIN_DATE,p_END_DATE,p_AS_OF_DATE,p_EDC_ID,p_ESP_ID,
			p_ACCOUNT_SUMMARY,p_USE_DETAIL_UNITS,p_TIME_AGGREGATE,p_TIME_ZONE,p_CURSOR);

	ELSIF UPPER(p_FORMAT_ALIAS) = 'MEC' THEN
		GET_MEC_EXPORT(p_BEGIN_DATE,p_END_DATE,p_AS_OF_DATE,p_EDC_ID,p_ESP_ID,
			p_ACCOUNT_SUMMARY,p_SCALE_FACTOR,p_TIME_AGGREGATE,p_TIME_ZONE,p_CURSOR);

	ELSIF UPPER(p_FORMAT_ALIAS) = 'PECO' THEN
		GET_PECO_EXPORT(p_BEGIN_DATE,p_END_DATE,p_AS_OF_DATE,p_EDC_ID,p_ESP_ID,
			p_ACCOUNT_SUMMARY,p_SCALE_FACTOR,p_TIME_AGGREGATE,p_TIME_ZONE,p_CURSOR);

	ELSIF UPPER(p_FORMAT_ALIAS) = 'CIN_GENCO' THEN
		GET_CIN_GENCO_EXPORT(p_EXPORT_TYPE,p_BEGIN_DATE,p_END_DATE,p_AS_OF_DATE,p_EDC_ID,p_ESP_ID,
			p_ACCOUNT_SUMMARY,p_SCALE_FACTOR,p_TIME_AGGREGATE,p_TIME_ZONE,p_CURSOR);

	ELSIF UPPER(p_FORMAT_ALIAS) = 'CIN_CGEOHIO' THEN
		GET_CIN_CGEOHIO_EXPORT(p_EXPORT_TYPE,p_BEGIN_DATE,p_END_DATE,p_AS_OF_DATE,p_EDC_ID,p_ESP_ID,
			p_ACCOUNT_SUMMARY,p_SCALE_FACTOR,p_TIME_AGGREGATE,p_TIME_ZONE,p_CURSOR);

	ELSIF UPPER(p_FORMAT_ALIAS) = 'PECO_NO_VRSN' THEN
		GET_PECO_NO_VRSN_EXPORT(p_BEGIN_DATE,p_END_DATE,p_AS_OF_DATE,p_EDC_ID,p_ESP_ID,
			p_ACCOUNT_SUMMARY,p_SCALE_FACTOR,p_TIME_AGGREGATE,p_TIME_ZONE,p_CURSOR);

	ELSIF UPPER(p_FORMAT_ALIAS) = 'PJM ECAPACITY' THEN
		AN.PJM_ECAPACITY_EXPORT(p_BEGIN_DATE,p_END_DATE,p_AS_OF_DATE,p_EDC_ID,p_ESP_ID,p_CURSOR);

	ELSIF UPPER(p_FORMAT_ALIAS) = 'PJM ECAPACITY-XML' THEN
		AN.PJM_ECAPACITY_EXPORT_XML(p_BEGIN_DATE,p_END_DATE,p_AS_OF_DATE,p_EDC_ID,p_ESP_ID,p_CURSOR);


	ELSE
		OPEN p_CURSOR FOR
			SELECT NULL FROM DUAL;
	END IF;

	p_STATUS := GA.SUCCESS;
	DBMS_OUTPUT.PUT_LINE('GET_EXPORT_FORECAST ELAPSED TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED));

   EXCEPTION
        WHEN OTHERS THEN
            ERRS.LOG_AND_RAISE();
END GET_EXPORT_FORECAST;
-----------------------------------------------------------------------------------------------
PROCEDURE GET_SYSTEM_LABELS
	(
	p_MODEL_ID IN NUMBER := 0,
	p_MODULE IN VARCHAR,
	p_KEY1 IN VARCHAR,
	p_KEY2 IN VARCHAR,
	p_KEY3 IN VARCHAR,
	p_MATCH_CASE IN NUMBER := 0,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the SYSTEM_LABEL records matching the criteria
BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

    IF p_MATCH_CASE = 0 THEN
       OPEN p_CURSOR FOR
    		SELECT *
    		FROM SYSTEM_LABEL
        	WHERE UPPER(MODULE) = UPPER(p_MODULE)
        	  AND UPPER(KEY1) = UPPER(DECODE(p_KEY1,g_Wildcard,KEY1,p_KEY1))
        	  AND UPPER(KEY2) = UPPER(DECODE(p_KEY2,g_Wildcard,KEY2,p_KEY2))
        	  AND UPPER(KEY3) = UPPER(DECODE(p_KEY3,g_Wildcard,KEY3,p_KEY3))
    		  AND (IS_HIDDEN = 0 or IS_HIDDEN is NULL)
    		ORDER BY POSITION;
    ELSE 	  --Match Case
       OPEN p_CURSOR FOR
    		SELECT *
    		FROM SYSTEM_LABEL
        	WHERE MODULE = p_MODULE
        	  AND KEY1 = DECODE(p_KEY1,g_Wildcard,KEY1,p_KEY1)
        	  AND KEY2 = DECODE(p_KEY2,g_Wildcard,KEY2,p_KEY2)
        	  AND KEY3 = DECODE(p_KEY3,g_Wildcard,KEY3,p_KEY3)
    		  AND (IS_HIDDEN = 0 or IS_HIDDEN is NULL)
    		ORDER BY POSITION;
    END IF;

END GET_SYSTEM_LABELS;
-----------------------------------------------------------------------------------------------
PROCEDURE GET_LABELS_USE_DICTIONARY
	(
	p_MODEL_ID IN NUMBER := 0,
	p_MODULE IN VARCHAR,
	p_KEY1 IN VARCHAR,
	p_KEY2 IN VARCHAR,
	p_KEY3 IN VARCHAR,
	p_MATCH_CASE IN NUMBER := 0,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the SYSTEM_DICTIONARY.Value/SYSTEM_LABEL records matching the criteria
--   using SYSTEM_LABEL.Value as KEY3 to lookup SYSTEM_DICTIONARY.Value
BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

    IF p_MATCH_CASE = 0 THEN
       OPEN p_CURSOR FOR
    		SELECT D.VALUE, L.*
    		FROM SYSTEM_LABEL L, SYSTEM_DICTIONARY D
        	WHERE UPPER(L.MODULE) = UPPER(p_MODULE)
        	  AND UPPER(L.KEY1) = UPPER(DECODE(p_KEY1,g_Wildcard,L.KEY1,p_KEY1))
        	  AND UPPER(L.KEY2) = UPPER(DECODE(p_KEY2,g_Wildcard,L.KEY2,p_KEY2))
        	  AND UPPER(L.KEY3) = UPPER(DECODE(p_KEY3,g_Wildcard,L.KEY3,p_KEY3))
			  AND L.MODEL_ID IN (0,p_MODEL_ID)
			  AND D.MODEL_ID IN (0,p_MODEL_ID)
			  AND UPPER(D.MODULE) = UPPER(L.KEY1)
			  AND UPPER(D.KEY1) = UPPER(L.KEY2)
			  AND D.KEY2 = '?' AND D.KEY3 = '?'
			  AND UPPER(D.SETTING_NAME) = UPPER(L.VALUE)  --Note: L.VALUE is used here as Key3 to lookup D.VALUE
    		  AND NVL(IS_HIDDEN,0) = 0
    		ORDER BY POSITION;
    ELSE 	  --Match Case
       OPEN p_CURSOR FOR
    		SELECT D.VALUE, L.*
    		FROM SYSTEM_LABEL L, SYSTEM_DICTIONARY D
        	WHERE L.MODULE = p_MODULE
        	  AND L.KEY1 = DECODE(p_KEY1,g_Wildcard,L.KEY1,p_KEY1)
        	  AND L.KEY2 = DECODE(p_KEY2,g_Wildcard,L.KEY2,p_KEY2)
        	  AND L.KEY3 = DECODE(p_KEY3,g_Wildcard,L.KEY3,p_KEY3)
			  AND L.MODEL_ID IN (0,p_MODEL_ID)
			  AND D.MODEL_ID IN (0,p_MODEL_ID)
			  AND D.MODULE = L.KEY1
			  AND D.KEY1 = L.KEY2
			  AND D.KEY2 = '?' AND D.KEY3 = '?'
			  AND D.SETTING_NAME = L.VALUE  --Note: L.VALUE is used here as Key3 to lookup D.VALUE
    		  AND NVL(IS_HIDDEN,0) = 0
    		ORDER BY POSITION;
    END IF;

END GET_LABELS_USE_DICTIONARY;
-----------------------------------------------------------------------------------------------
FUNCTION SYSTEM_TYPE_OF_POWER
	RETURN VARCHAR IS

--Answer the type of power for this system ('Electric', 'Gas').

v_VALUE SYSTEM_DICTIONARY.VALUE%TYPE;

BEGIN
	v_VALUE := VALUE_AT_KEY_3('SYSTEM', 'TYPE_OF_POWER', '?');

	RETURN v_VALUE;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN NULL;

END SYSTEM_TYPE_OF_POWER;
-----------------------------------------------------------------------------------------------
PROCEDURE GET_SYSTEM_TYPE_OF_POWER
	(
	p_VALUE OUT VARCHAR,
	p_STATUS OUT NUMBER
	) AS

-- Answer the SYSTEM_LABEL records matching the criteria
BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	p_VALUE := SYSTEM_TYPE_OF_POWER();

END GET_SYSTEM_TYPE_OF_POWER;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_EXPORT_UNITS
	(
	p_MODEL_ID IN NUMBER := 0,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the SYSTEM_LABEL records for Units of Measure
BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	GET_LABELS_USE_DICTIONARY(p_MODEL_ID,'Export','System', 'Unit', 'FROM_SYSTEM_DICTIONARY', 0, p_STATUS, p_CURSOR);

END GET_EXPORT_UNITS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_INTERVALS
	(
	p_MODEL_ID IN NUMBER := 0,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS


-- Answer the SYSTEM_LABEL records for time intervals
BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	GET_SYSTEM_LABELS(p_MODEL_ID,'Export','Interval', '?', '?', 0, p_STATUS, p_CURSOR);

END GET_INTERVALS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_EXPORT_TYPE_NAMES
	(
	p_MODEL_ID IN NUMBER := 0,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS


-- Answer the SYSTEM_LABEL records for Export Type names
BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	GET_SYSTEM_LABELS(p_MODEL_ID,'Export','Type', '?', '?', 0, p_STATUS, p_CURSOR);

END GET_EXPORT_TYPE_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_EXPORT_NAMES
	(
	p_EXPORT_GROUP IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the EXPORT_NAMEs matching the EXPORT_GROUP (or ALL)
BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    OPEN p_CURSOR FOR
 		SELECT EXPORT_NAME
 		FROM GROUP_EXPORT
     	WHERE UPPER(EXPORT_GROUP) = DECODE(p_EXPORT_GROUP, g_ALL_STRING, UPPER(EXPORT_GROUP), UPPER(p_EXPORT_GROUP))
		ORDER BY 1;

END GET_EXPORT_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_EXPORT_GROUPS
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the unique EXPORT_GROUP names in the GROUP_EXPORT table
BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    OPEN p_CURSOR FOR
 		SELECT DISTINCT EXPORT_GROUP
 		FROM GROUP_EXPORT
		ORDER BY 1;

END GET_EXPORT_GROUPS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_GROUP_EXPORT
	(
	p_EXPORT_NAME IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the GROUP_EXPORT records matching the EXPORT_NAME
BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    OPEN p_CURSOR FOR
 		SELECT *
 		FROM GROUP_EXPORT
     	WHERE UPPER(EXPORT_NAME) = UPPER(p_EXPORT_NAME)
		ORDER BY 1;

END GET_GROUP_EXPORT;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_GROUP_EXPORT
    (
	p_EXPORT_NAME IN VARCHAR,
	p_EXPORT_GROUP IN VARCHAR,
	p_EXPORT_FORMAT IN VARCHAR,
	p_EXPORT_TYPE IN CHAR,
	p_BEGIN_DATE_OFFSET IN NUMBER,
	p_END_DATE_OFFSET IN VARCHAR,
	p_EXPORT_INTERVAL IN VARCHAR,
	p_EXPORT_UNITS IN VARCHAR,
	p_EXPORT_ACCOUNT_OPTION IN VARCHAR,
	p_EXPORT_DELIMITER IN VARCHAR,
	p_EXPORT_DIRECTORY IN VARCHAR,
	p_EXPORT_DISPOSITION IN VARCHAR,
	p_FILE_PREFIX IN VARCHAR,
	p_FILE_DATE_FORMAT IN VARCHAR,
	p_FILE_SUFFIX IN VARCHAR,
	p_FILE_AUTOINCR_SUFFIX IN VARCHAR,
	p_FILE_EXTENSION IN VARCHAR,
	p_PRINT_COLUMN_HEADERS IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

    UPDATE GROUP_EXPORT SET
			EXPORT_NAME = p_EXPORT_NAME,
			EXPORT_GROUP = DECODE(p_EXPORT_GROUP, g_ALL_STRING, EXPORT_GROUP, p_EXPORT_GROUP),
			EXPORT_FORMAT = p_EXPORT_FORMAT,
			EXPORT_TYPE = p_EXPORT_TYPE,
			BEGIN_DATE_OFFSET = p_BEGIN_DATE_OFFSET,
			END_DATE_OFFSET = p_END_DATE_OFFSET,
			EXPORT_INTERVAL = p_EXPORT_INTERVAL,
			EXPORT_UNITS = p_EXPORT_UNITS,
			EXPORT_ACCOUNT_OPTION = p_EXPORT_ACCOUNT_OPTION,
			EXPORT_DELIMITER = p_EXPORT_DELIMITER,
			EXPORT_DIRECTORY = p_EXPORT_DIRECTORY,
			EXPORT_DISPOSITION = p_EXPORT_DISPOSITION,
			FILE_PREFIX = p_FILE_PREFIX,
			FILE_DATE_FORMAT = p_FILE_DATE_FORMAT,
			FILE_SUFFIX = p_FILE_SUFFIX,
			FILE_AUTOINCR_SUFFIX = p_FILE_AUTOINCR_SUFFIX,
			FILE_EXTENSION = p_FILE_EXTENSION,
			PRINT_COLUMN_HEADERS = p_PRINT_COLUMN_HEADERS,
			EDC_ID = p_EDC_ID,
			ESP_ID = p_ESP_ID,
			ENTRY_DATE = SYSDATE
	WHERE UPPER(EXPORT_NAME) = UPPER(p_EXPORT_NAME);

	IF SQL%NOTFOUND THEN
		INSERT INTO GROUP_EXPORT (
 			EXPORT_NAME,
			EXPORT_GROUP,
			EXPORT_FORMAT,
			EXPORT_TYPE,
			BEGIN_DATE_OFFSET,
			END_DATE_OFFSET,
			EXPORT_INTERVAL,
			EXPORT_UNITS,
			EXPORT_ACCOUNT_OPTION,
			EXPORT_DELIMITER,
			EXPORT_DIRECTORY,
			EXPORT_DISPOSITION,
			FILE_PREFIX,
			FILE_DATE_FORMAT,
			FILE_SUFFIX,
			FILE_AUTOINCR_SUFFIX,
			FILE_EXTENSION,
			PRINT_COLUMN_HEADERS,
			EDC_ID,
			ESP_ID ,
			ENTRY_DATE)
		VALUES (
 			p_EXPORT_NAME,
			DECODE(p_EXPORT_GROUP, g_ALL_STRING, '', p_EXPORT_GROUP),
			p_EXPORT_FORMAT,
			p_EXPORT_TYPE,
			p_BEGIN_DATE_OFFSET,
			p_END_DATE_OFFSET,
			p_EXPORT_INTERVAL,
			p_EXPORT_UNITS,
			p_EXPORT_ACCOUNT_OPTION,
			p_EXPORT_DELIMITER,
			p_EXPORT_DIRECTORY,
			p_EXPORT_DISPOSITION,
			p_FILE_PREFIX,
			p_FILE_DATE_FORMAT,
			p_FILE_SUFFIX,
			p_FILE_AUTOINCR_SUFFIX,
			p_FILE_EXTENSION,
			p_PRINT_COLUMN_HEADERS,
			p_EDC_ID,
			p_ESP_ID ,
			SYSDATE);
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END PUT_GROUP_EXPORT;
---------------------------------------------------------------------------------------------------
PROCEDURE REMOVE_GROUP_EXPORT
	(
	p_EXPORT_NAME IN VARCHAR,
	p_STATUS OUT NUMBER
	)
	AS
-- REMOVE THE RECORD SPECIFIED BY THE INPUTS
BEGIN

	IF NOT CAN_DELETE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_DELETE_MODULE(g_MODULE_NAME);
	END IF;

	DELETE FROM GROUP_EXPORT
	WHERE UPPER(EXPORT_NAME) = UPPER(p_EXPORT_NAME);
	p_STATUS := GA.SUCCESS;
	EXCEPTION
		WHEN OTHERS THEN
			ERRS.LOG_AND_RAISE();
END REMOVE_GROUP_EXPORT;
----------------------------------------------------------------------------------------------------

PROCEDURE GET_FORMATS_AND_DELIMITERS
	(
	p_EXPORT_TYPE_NAME IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the FORMATS_AND_DELIMITERS matching the EXPORT_TYPE_NAME
BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    OPEN p_CURSOR FOR
		SELECT L.MODULE,
			   L.VALUE Format_Name,
			   L.POSITION Format_Position,
			   L2.VALUE Delim_Name ,
			   D2.VALUE Delim,
			   ASCII(D2.VALUE),
			   L.IS_DEFAULT Is_Default_Format,
			   D.VALUE Print_ColHdr ,
			   L2.IS_DEFAULT Is_Default_Delim
		FROM SYSTEM_LABEL L, SYSTEM_DICTIONARY D, SYSTEM_LABEL L2, SYSTEM_DICTIONARY D2
		WHERE
		  UPPER(L.MODULE) = 'EXPORT'
		  AND UPPER(L.KEY1) = 'FORMAT'
		  AND UPPER(L.KEY2) = UPPER(p_EXPORT_TYPE_NAME)  --'Forecast', 'Backcast', 'Usage'
		  AND L.KEY3 = '?'
		  AND UPPER(D.MODULE(+)) = UPPER(L.MODULE)   --'Export'
		  AND UPPER(D.KEY1(+)) = 'COLHEADER'
		  AND D.KEY2(+) = '?' AND D.KEY3(+) = '?'
		  AND UPPER(D.SETTING_NAME(+)) = UPPER(L.VALUE)   --'PPL', etc
		  AND UPPER(L2.MODULE(+)) = 'EXPORT'
		  AND UPPER(L2.KEY1(+)) = 'DELIMITER'
		  AND UPPER(L2.KEY2(+)) = UPPER(L.VALUE)   --'PPL', etc
		  AND L2.KEY3(+) = '?'
		  AND UPPER(D2.MODULE(+)) = UPPER(L2.MODULE)   --'Export'
		  AND UPPER(D2.KEY1(+)) = UPPER(L2.KEY1)   --'Delimiter'
		  AND D2.KEY2(+) = '?' AND D2.KEY3(+) = '?'
		  AND UPPER(D2.SETTING_NAME(+)) = UPPER(L2.VALUE)  --'TAB', etc
		  AND NVL(L.IS_HIDDEN,0) = 0
		ORDER BY L.POSITION,Delim_Name;

END GET_FORMATS_AND_DELIMITERS;
----------------------------------------------------------------------------------------------------
END EX;
/
