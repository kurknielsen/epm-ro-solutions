CREATE OR REPLACE PACKAGE RETAIL_SETTLEMENT IS
-- $Revision: 1.18 $

TYPE RETAIL_SETTLEMENT_INPUT IS RECORD(
	ACCOUNT_ID          NUMBER(9),
	METER_ID            NUMBER(9),
	SERVICE_POINT_ID    NUMBER(9),
	METER_TYPE          VARCHAR2(64),
	BEGIN_DATE          DATE,
	END_DATE            DATE,
	PRODUCT_ID          NUMBER(9),
	COMPONENT_ID        NUMBER(9),
	PERIOD_ID           NUMBER(9),
	CHARGE_STATE        NUMBER(1),
	INTERNAL_QUANTITY   NUMBER,
	INTERNAL_RATE       NUMBER,
	INTERNAL_AMOUNT     NUMBER,
	EXTERNAL_QUANTITY   NUMBER,
	EXTERNAL_RATE       NUMBER,
	EXTERNAL_AMOUNT     NUMBER,
 	CREDIT_REFERENCE_ID NUMBER(12),
    ESP_ID              NUMBER
);

TYPE RETAIL_SETTLEMENT_INPUT_CURSOR IS REF CURSOR RETURN RETAIL_SETTLEMENT_INPUT;

-- RECORD type to hold key and other data associated with
-- a Retail Invoice Line Component and dispute
TYPE t_RETAIL_INVOICE_DISPUTE_DATA IS RECORD
(
    INVOICE_DATE                   RETAIL_INVOICE.INVOICE_DATE%TYPE,
    INVOICE_NUMBER                 RETAIL_INVOICE.INVOICE_NUMBER%TYPE,
    RETAIL_INVOICE_ID              RETAIL_INVOICE.RETAIL_INVOICE_ID%TYPE,
    ACCOUNT_ID                     RETAIL_INVOICE_LINE.ACCOUNT_ID%TYPE,
    METER_ID                       RETAIL_INVOICE_LINE.METER_ID%TYPE,
    SERVICE_POINT_ID               RETAIL_INVOICE_LINE.SERVICE_POINT_ID%TYPE,
    PRODUCT_ID                     RETAIL_INVOICE_LINE_COMPONENT.PRODUCT_ID%TYPE,
    COMPONENT_ID                   RETAIL_INVOICE_LINE_COMPONENT.COMPONENT_ID%TYPE,
    PERIOD_ID                      RETAIL_INVOICE_LINE_COMPONENT.PERIOD_ID%TYPE,
    BEGIN_DATE                     RETAIL_INVOICE_LINE_COMPONENT.BEGIN_DATE%TYPE,
    END_DATE                       RETAIL_INVOICE_LINE_COMPONENT.END_DATE%TYPE,
    INTERNAL_QUANTITY              RETAIL_INVOICE_LINE_COMPONENT.INTERNAL_QUANTITY%TYPE,
    INTERNAL_AMOUNT                RETAIL_INVOICE_LINE_COMPONENT.INTERNAL_AMOUNT%TYPE,
    EXTERNAL_QUANTITY              RETAIL_INVOICE_LINE_COMPONENT.EXTERNAL_QUANTITY%TYPE,
    EXTERNAL_AMOUNT                RETAIL_INVOICE_LINE_COMPONENT.EXTERNAL_AMOUNT%TYPE,
	SETTLEMENT_RUN_ON              PROCESS_LOG.PROCESS_START_TIME%TYPE
);

FUNCTION WHAT_VERSION RETURN VARCHAR2;

FUNCTION NEW_RETAIL_INVOICE
	(
	p_SENDER_PSE_ID     IN NUMBER,
	p_RECIPIENT_PSE_ID  IN NUMBER,
	p_INVOICE_NUMBER    IN VARCHAR2,
	p_INVOICE_DATE      IN DATE,
    p_PERIOD_BEGIN_DATE IN DATE := NULL,
    p_PERIOD_END_DATE   IN DATE := NULL,
    p_SERVICE_CODE      IN VARCHAR2 := NULL,
    p_TIME_ZONE         IN VARCHAR2 := NULL
	) RETURN RETAIL_INVOICE%ROWTYPE;

PROCEDURE UPD_RETAIL_INVOICE_COMPONENT
  (
	p_RETAIL_INVOICE_ID				IN RETAIL_INVOICE.RETAIL_INVOICE_ID%TYPE
  );

PROCEDURE RUN_RETAIL_SETTLEMENT
	(
	p_RETAIL_INVOICE_ID        IN NUMBER,
	p_RETAIL_SETTLEMENT_INPUTS IN RETAIL_SETTLEMENT_INPUT_CURSOR,
	p_STATEMENT_TYPE_ID        IN NUMBER,
	p_TIME_ZONE                IN VARCHAR2,
	p_SERVICE_CODE             IN CHAR,
	p_OTHER_PARAMS             IN UT.STRING_MAP := UT.c_EMPTY_MAP,
	p_INPUT_COUNT              IN NUMBER := NULL,
	p_ALLOW_NO_ACCOUNTS_SPS    IN BOOLEAN := FALSE,
	p_MARK_CONSUMPTION         IN BOOLEAN := TRUE,
	p_RETAIN_INVOICE_LINES     IN BOOLEAN := FALSE
	);


-- Collect data for a Retail Invoice Dispute from the various
-- Retail Invoice tables.
-- %param p_RETAIL_INVOICE_LINE_COMP_ID IN NUMBER The ID of the invoice/line/product/component
-- %return t_RETAIL_INVOICE_DISPUTE_DATA record
FUNCTION GET_RI_DISPUTE_DATA
(
    p_RETAIL_INVOICE_LINE_COMP_ID IN RETAIL_INVOICE_LINE_COMPONENT.RETAIL_INVOICE_LINE_COMP_ID%TYPE
) RETURN t_RETAIL_INVOICE_DISPUTE_DATA;

$IF $$UNIT_TEST_MODE = 1 $THEN
PROCEDURE GENERATE_DUPLICATE_DISPUTES
(
    p_RETAIL_INVOICE_ID IN RETAIL_INVOICE.RETAIL_INVOICE_ID%TYPE
);
PROCEDURE GENERATE_OOT_DISPUTES
(
    p_RETAIL_INVOICE_ID IN RETAIL_INVOICE.RETAIL_INVOICE_ID%TYPE
);
$END

c_CHARGE_STATE_NORMAL       CONSTANT NUMBER(1) := 0;
c_CHARGE_STATE_ADJUSTMENT   CONSTANT NUMBER(1) := 1;
c_CHARGE_STATE_CANCELLATION CONSTANT NUMBER(1) := 2;
c_CHARGE_STATE_MANUAL       CONSTANT NUMBER(1) := 3;
c_CHARGE_STATE_REBILL          CONSTANT NUMBER(1) := 4; 	-- New Charge State for F57.U15 
c_CHARGE_STATE_CANCEL_MANUAL CONSTANT NUMBER(1) := 7;
c_CHARGE_STATE_CANCELLED_TAX 	CONSTANT NUMBER(1) := 8;
c_CHARGE_STATE_TAX          CONSTANT NUMBER(1) := 9;

c_DISPUTE_TYPE_MANUAL CONSTANT NUMBER := 0;
c_DISPUTE_TYPE_DUPLICATE CONSTANT NUMBER := 1;
c_DISPUTE_TYPE_OOT CONSTANT NUMBER := 2;

c_DISPUTE_STATUS_WITHDRAWN CONSTANT VARCHAR2(16) := 'Withdrawn';
c_DISPUTE_STATUS_CLOSED CONSTANT VARCHAR2(16) := 'Closed';
c_DISPUTE_STATUS_OPEN CONSTANT VARCHAR2(16) := 'Open';

c_DISPUTE_CATEGORY_DUPLICATE CONSTANT VARCHAR2(16) := 'Duplicate';
c_DISPUTE_CATEGORY_OOT CONSTANT VARCHAR2(16) := 'Out-of-Tolerance';

END RETAIL_SETTLEMENT;
/
CREATE OR REPLACE PACKAGE BODY RETAIL_SETTLEMENT IS
----------------------------------------------------------------------------------------------------
TYPE t_DUPLICATE_ID_RECORD IS RECORD
(
    DUPLICATE_RILC_ID    RETAIL_INVOICE_LINE_COMPONENT.RETAIL_INVOICE_LINE_COMP_ID%TYPE,
	DUPLICATE_OF_RILC_ID RETAIL_INVOICE_LINE_COMPONENT.RETAIL_INVOICE_LINE_COMP_ID%TYPE
);
TYPE t_DUPLICATE_ID_TABLE IS TABLE OF t_DUPLICATE_ID_RECORD;
c_CHARGE_TYPE_EXT_ID_TYPE CONSTANT VARCHAR2(16) := 'Charge Type';
----------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR2 IS
BEGIN
    RETURN '$Revision: 1.18 $';
END WHAT_VERSION;
---------------------------------------------------------------------------------------------------
FUNCTION NEW_RETAIL_INVOICE
	(
	p_SENDER_PSE_ID     IN NUMBER,
	p_RECIPIENT_PSE_ID  IN NUMBER,
	p_INVOICE_NUMBER    IN VARCHAR2,
	p_INVOICE_DATE      IN DATE,
    p_PERIOD_BEGIN_DATE IN DATE := NULL,
    p_PERIOD_END_DATE   IN DATE := NULL,
    p_SERVICE_CODE      IN VARCHAR2 := NULL,
    p_TIME_ZONE         IN VARCHAR2 := NULL
	) RETURN RETAIL_INVOICE%ROWTYPE AS
	v_RETAIL_INVOICE RETAIL_INVOICE%ROWTYPE;
	v_COUNT          NUMBER(1);
BEGIN
	ASSERT(p_SENDER_PSE_ID IS NOT NULL, 'Sender PSE Id must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_RECIPIENT_PSE_ID IS NOT NULL, 'Recipient PSE Id must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_INVOICE_NUMBER IS NOT NULL, 'Invoice Number must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_INVOICE_DATE IS NOT NULL, 'Invoice Date must not be null.', MSGCODES.c_ERR_ARGUMENT);

    IF p_PERIOD_BEGIN_DATE IS NOT NULL AND p_PERIOD_END_DATE IS NOT NULL THEN
        -- DON'T CHECK THE PERIOD FOR VALIDITY UNLESS IT'S ACTUALLY SPECIFIED
        ASSERT(p_PERIOD_BEGIN_DATE <= p_PERIOD_END_DATE, 'The invoice begin date must be on or before the end date.',
            MSGCODES.c_ERR_ARGUMENT);
    END IF;

	SELECT COUNT(1)
	INTO v_COUNT
	FROM RETAIL_INVOICE R
	WHERE R.RECIPIENT_PSE_ID = p_RECIPIENT_PSE_ID
		  AND R.SENDER_PSE_ID = p_SENDER_PSE_ID
		  AND R.INVOICE_NUMBER = p_INVOICE_NUMBER;

	IF v_COUNT > 0 THEN
		ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY,
				   'An entry already exists with: SENDER_PSE_ID=' || p_SENDER_PSE_ID || ',RECIPIENT_PSE_ID=' ||
				   p_RECIPIENT_PSE_ID || ',INVOICE_NUMBER=' || p_INVOICE_NUMBER || '.');
	END IF;

	SELECT RETAIL_INVOICE_ID.NEXTVAL INTO v_RETAIL_INVOICE.RETAIL_INVOICE_ID FROM DUAL;

	v_RETAIL_INVOICE.RECIPIENT_PSE_ID := p_RECIPIENT_PSE_ID;
	v_RETAIL_INVOICE.SENDER_PSE_ID := p_SENDER_PSE_ID;
	v_RETAIL_INVOICE.INVOICE_NUMBER := p_INVOICE_NUMBER;
	v_RETAIL_INVOICE.INVOICE_DATE := p_INVOICE_DATE;
	v_RETAIL_INVOICE.PROCESS_ID := LOGS.CURRENT_PROCESS_ID;
	v_RETAIL_INVOICE.TIME_ZONE := p_TIME_ZONE;
	v_RETAIL_INVOICE.SERVICE_CODE := p_SERVICE_CODE;
	v_RETAIL_INVOICE.STATEMENT_TYPE_ID := NULL;
    v_RETAIL_INVOICE.PERIOD_BEGIN_DATE := p_PERIOD_BEGIN_DATE;
    v_RETAIL_INVOICE.PERIOD_END_DATE := p_PERIOD_END_DATE;

	INSERT INTO RETAIL_INVOICE VALUES v_RETAIL_INVOICE;

	RETURN v_RETAIL_INVOICE;

END NEW_RETAIL_INVOICE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_BILL_PROCESSED_DATE
	(
	p_INVOICE_DATE IN DATE,
	p_DATE_RANGES IN DATE_RANGE_TABLE,
	p_SERVICE_CODE IN CHAR,
	p_SERVICE_IDS IN NUMBER_COLLECTION
	) AS
v_DATE_RANGE DATE_RANGE;
BEGIN
	LOGS.LOG_DEBUG('Updating the Bill Processed Date for Service Consumption');

	IF p_DATE_RANGES IS NULL OR p_DATE_RANGES.COUNT = 0 THEN
		LOGS.LOG_WARN('No Dates found in the DATE_RANGES collection');
		RETURN;
	END IF;

	IF p_SERVICE_IDS IS NULL OR p_SERVICE_IDS.COUNT = 0 THEN
		LOGS.LOG_DEBUG('No Service Ids found in the SERVICE_IDS collection');
		RETURN;
	END IF;

	FOR i IN p_DATE_RANGES.FIRST..p_DATE_RANGES.LAST LOOP
		v_DATE_RANGE := p_DATE_RANGES(i);

		-- We want to update those SERVICE_CONSUMPTION records
		-- which will be pulled in the RETAIL_DETERMINANTS.POPULATE_PERIOD_CACHE procedure
		FORALL j IN p_SERVICE_IDS.FIRST .. p_SERVICE_IDS.LAST
			UPDATE SERVICE_CONSUMPTION C
			SET C.BILL_PROCESSED_DATE = p_INVOICE_DATE
			WHERE C.SERVICE_ID = p_SERVICE_IDS(j)
			  AND C.BEGIN_DATE < v_DATE_RANGE.END_DATE
			  AND C.END_DATE > v_DATE_RANGE.BEGIN_DATE
			  AND C.CONSUMPTION_CODE = p_SERVICE_CODE;
	END LOOP;

END PUT_BILL_PROCESSED_DATE;
----------------------------------------------------------------------------------------------------
FUNCTION GET_RETAIL_INVOICE_LINE
	(
	p_RETAIL_INVOICE_ID IN NUMBER,
	p_INPUT          	IN RETAIL_SETTLEMENT_INPUT
	) RETURN RETAIL_INVOICE_LINE%ROWTYPE AS
v_RESULT RETAIL_INVOICE_LINE%ROWTYPE;
BEGIN
	BEGIN
		SELECT *
		INTO v_RESULT
		FROM RETAIL_INVOICE_LINE L
		WHERE L.RETAIL_INVOICE_ID = p_RETAIL_INVOICE_ID
		  AND p_INPUT.ACCOUNT_ID = L.ACCOUNT_ID
		  AND p_INPUT.METER_ID = L.METER_ID
		  AND p_INPUT.SERVICE_POINT_ID = L.SERVICE_POINT_ID
		  AND (p_INPUT.SERVICE_POINT_ID = CONSTANTS.NOT_ASSIGNED OR p_INPUT.METER_TYPE = L.METER_TYPE);
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			LOGS.LOG_DEBUG('Creating a new RETAIL_INVOICE_LINE record for: ACCOUNT_ID=' || p_INPUT.ACCOUNT_ID
				|| ',METER_ID=' || p_INPUT.METER_ID
				|| ',SERVICE_POINT_ID=' || p_INPUT.SERVICE_POINT_ID
				|| ',METER_TYPE=' || p_INPUT.METER_TYPE);
			SELECT RETAIL_INVOICE_ID.NEXTVAL INTO v_RESULT.RETAIL_INVOICE_LINE_ID FROM DUAL;
			v_RESULT.RETAIL_INVOICE_ID := p_RETAIL_INVOICE_ID;
			v_RESULT.ACCOUNT_ID := p_INPUT.ACCOUNT_ID;
			v_RESULT.METER_ID := p_INPUT.METER_ID;
			v_RESULT.SERVICE_POINT_ID := p_INPUT.SERVICE_POINT_ID;

			IF p_INPUT.SERVICE_POINT_ID <> CONSTANTS.NOT_ASSIGNED THEN
				v_RESULT.METER_TYPE := p_INPUT.METER_TYPE;
			END IF;

			INSERT INTO RETAIL_INVOICE_LINE	VALUES v_RESULT;
	END;
	RETURN v_RESULT;
END GET_RETAIL_INVOICE_LINE;
----------------------------------------------------------------------------------------------------
PROCEDURE UPD_RETAIL_INVOICE_COMPONENT
(
	p_RETAIL_INVOICE_ID				IN RETAIL_INVOICE.RETAIL_INVOICE_ID%TYPE
) AS
BEGIN
	MERGE INTO RETAIL_INVOICE_COMPONENT RIC
	USING (SELECT RI.RETAIL_INVOICE_ID,
				  RILC.PRODUCT_ID,
				  RILC.COMPONENT_ID,
				  RILC.PERIOD_ID,
				  SUM(RILC.INTERNAL_QUANTITY)	AS QUANTITY,
				  SUM(RILC.INTERNAL_AMOUNT)		AS AMOUNT
			 FROM RETAIL_INVOICE				  RI,
				  RETAIL_INVOICE_LINE			  RIL,
				  RETAIL_INVOICE_LINE_COMPONENT	  RILC
			WHERE RI.RETAIL_INVOICE_ID		= p_RETAIL_INVOICE_ID
			  AND RIL.RETAIL_INVOICE_ID		= RI.RETAIL_INVOICE_ID
			  AND RILC.RETAIL_INVOICE_LINE_ID	= RIL.RETAIL_INVOICE_LINE_ID
		   GROUP BY RI.RETAIL_INVOICE_ID, RILC.PRODUCT_ID, RILC.COMPONENT_ID, RILC.PERIOD_ID) X
		ON (	RIC.RETAIL_INVOICE_ID = X.RETAIL_INVOICE_ID
			AND RIC.PRODUCT_ID		  = X.PRODUCT_ID
			AND RIC.COMPONENT_ID 	  = X.COMPONENT_ID
			AND ((RIC.PERIOD_ID		  = X.PERIOD_ID) OR (RIC.PERIOD_ID IS NULL AND X.PERIOD_ID IS NULL))
		   )
	WHEN MATCHED THEN
		UPDATE SET RIC.TOTAL_INTERNAL_QUANTITY	= X.QUANTITY,
				   RIC.TOTAL_INTERNAL_AMOUNT	= X.AMOUNT
	WHEN NOT MATCHED THEN
		INSERT(RETAIL_INVOICE_ID,
			   PRODUCT_ID,
			   COMPONENT_ID,
			   PERIOD_ID,
			   TOTAL_INTERNAL_QUANTITY,
			   TOTAL_INTERNAL_AMOUNT
			  )
		VALUES(X.RETAIL_INVOICE_ID,
			   X.PRODUCT_ID,
			   X.COMPONENT_ID,
			   X.PERIOD_ID,
			   X.QUANTITY,
			   X.AMOUNT
			  );

	DELETE FROM RETAIL_INVOICE_COMPONENT RIC
	 WHERE RIC.RETAIL_INVOICE_ID		= p_RETAIL_INVOICE_ID
	   AND NOT EXISTS (SELECT 1
	 					 FROM RETAIL_INVOICE				  RI,
							  RETAIL_INVOICE_LINE			  RIL,
							  RETAIL_INVOICE_LINE_COMPONENT	  RILC
						WHERE RI.RETAIL_INVOICE_ID		= p_RETAIL_INVOICE_ID
			  			  AND RIL.RETAIL_INVOICE_ID		= RI.RETAIL_INVOICE_ID
			 			  AND RILC.RETAIL_INVOICE_LINE_ID	= RIL.RETAIL_INVOICE_LINE_ID
						  AND RIC.RETAIL_INVOICE_ID		= RI.RETAIL_INVOICE_ID
						  AND RIC.PRODUCT_ID		= RILC.PRODUCT_ID
						  AND RIC.COMPONENT_ID		= RILC.COMPONENT_ID
						  AND ((RIC.PERIOD_ID = RILC.PERIOD_ID) OR (RIC.PERIOD_ID IS NULL AND RILC.PERIOD_ID IS NULL))
					   );
END UPD_RETAIL_INVOICE_COMPONENT;
--------------------------------------------------------------------------------
-- Identify duplicate Retail Invoice Line Component IDs for a specified invoice.
-- %param p_RETAIL_INVOICE_ID IN NUMBER The invoice id for which to identify duplicates
-- %return t_DUPLICATE_ID_TABLE ID of duplicate line and ID of line that is duplicated
FUNCTION IDENTIFY_DUPLICATE_RILC_IDS
(
    p_RETAIL_INVOICE_ID IN RETAIL_INVOICE.RETAIL_INVOICE_ID%TYPE
)
RETURN t_DUPLICATE_ID_TABLE AS
    v_DUPLICATE_ID_TABLE t_DUPLICATE_ID_TABLE;
BEGIN
    -- R.I.L.C.E. = Retail Invoice Line Component External (Identifier)
	-- subquery that can be used in following blocks that gives you a join
	-- of RETAIL_INVOICE_LINE, RETAIL_INVOICE_LINE_COMPONENT, and EXTERNAL_SYSTEM_IDENTIFIER tables
	-- pulling out the Charge Type external identifier only
    WITH RILCE AS
    (
        SELECT RIL.RETAIL_INVOICE_ID,
               ACCOUNT_ID,
               METER_ID,
               SERVICE_POINT_ID,
               RETAIL_INVOICE_LINE_COMP_ID,
               PRODUCT_ID,
               COMPONENT_ID,
               PERIOD_ID,
               BEGIN_DATE,
               END_DATE,
               CHARGE_STATE,
               EXTERNAL_IDENTIFIER,
			   INVOICE_DATE
        FROM RETAIL_INVOICE RI,
		     RETAIL_INVOICE_LINE RIL,
             RETAIL_INVOICE_LINE_COMPONENT RILC,
             EXTERNAL_SYSTEM_IDENTIFIER ESI
        WHERE RI.RETAIL_INVOICE_ID = RIL.RETAIL_INVOICE_ID
		  AND RIL.RETAIL_INVOICE_LINE_ID = RILC.RETAIL_INVOICE_LINE_ID
          AND RILC.COMPONENT_ID = ESI.ENTITY_ID
          AND ESI.EXTERNAL_SYSTEM_ID = EC.ES_TDIE
          AND ESI.ENTITY_DOMAIN_ID = EC.ED_COMPONENT
          AND ESI.IDENTIFIER_TYPE = c_CHARGE_TYPE_EXT_ID_TYPE
    )
	SELECT R.RETAIL_INVOICE_LINE_COMP_ID,
	       MIN(S.RETAIL_INVOICE_LINE_COMP_ID)
	BULK COLLECT INTO v_DUPLICATE_ID_TABLE
	FROM RILCE R,
		 RILCE S
	WHERE R.RETAIL_INVOICE_ID = p_RETAIL_INVOICE_ID
	  AND R.ACCOUNT_ID = S.ACCOUNT_ID
	  AND R.METER_ID = S.METER_ID
	  AND R.SERVICE_POINT_ID = S.SERVICE_POINT_ID
	  AND R.CHARGE_STATE = S.CHARGE_STATE
	  AND R.EXTERNAL_IDENTIFIER = S.EXTERNAL_IDENTIFIER
	  AND NVL(R.PERIOD_ID, CONSTANTS.NOT_ASSIGNED) = NVL(S.PERIOD_ID, CONSTANTS.NOT_ASSIGNED)
	  AND R.BEGIN_DATE <= S.END_DATE
	  AND R.END_DATE >= S.BEGIN_DATE
	  AND R.RETAIL_INVOICE_LINE_COMP_ID <> S.RETAIL_INVOICE_LINE_COMP_ID
	  AND R.INVOICE_DATE >= S.INVOICE_DATE
	GROUP BY R.RETAIL_INVOICE_LINE_COMP_ID,
			 R.ACCOUNT_ID,
			 R.METER_ID,
			 R.SERVICE_POINT_ID,
			 R.CHARGE_STATE,
			 R.EXTERNAL_IDENTIFIER,
			 R.PERIOD_ID;

	RETURN v_DUPLICATE_ID_TABLE;

END IDENTIFY_DUPLICATE_RILC_IDS;
--------------------------------------------------------------------------------
-- Collect data for a Retail Invoice Dispute from the various
-- Retail Invoice tables.
-- %param p_RETAIL_INVOICE_LINE_COMP_ID IN NUMBER The ID of the invoice/line/product/component
-- %return t_RETAIL_INVOICE_DISPUTE_DATA record
FUNCTION GET_RI_DISPUTE_DATA
(
    p_RETAIL_INVOICE_LINE_COMP_ID IN RETAIL_INVOICE_LINE_COMPONENT.RETAIL_INVOICE_LINE_COMP_ID%TYPE
) RETURN t_RETAIL_INVOICE_DISPUTE_DATA AS
    v_RETAIL_INVOICE_DISPUTE_DATA t_RETAIL_INVOICE_DISPUTE_DATA;
BEGIN
    SELECT RI.INVOICE_DATE,
	       RI.INVOICE_NUMBER,
		   RI.RETAIL_INVOICE_ID,
		   RIL.ACCOUNT_ID,
		   RIL.METER_ID,
		   RIL.SERVICE_POINT_ID,
		   RILC.PRODUCT_ID,
		   RILC.COMPONENT_ID,
		   RILC.PERIOD_ID,
		   RILC.BEGIN_DATE,
		   RILC.END_DATE,
		   RILC.INTERNAL_QUANTITY,
		   RILC.INTERNAL_AMOUNT,
		   RILC.EXTERNAL_QUANTITY,
		   RILC.EXTERNAL_AMOUNT,
		   PL.PROCESS_START_TIME -- the Settlement Run On on the Settlement Results comes from the process start time
	INTO v_RETAIL_INVOICE_DISPUTE_DATA.INVOICE_DATE,
	     v_RETAIL_INVOICE_DISPUTE_DATA.INVOICE_NUMBER,
	     v_RETAIL_INVOICE_DISPUTE_DATA.RETAIL_INVOICE_ID,
	     v_RETAIL_INVOICE_DISPUTE_DATA.ACCOUNT_ID,
	     v_RETAIL_INVOICE_DISPUTE_DATA.METER_ID,
	     v_RETAIL_INVOICE_DISPUTE_DATA.SERVICE_POINT_ID,
	     v_RETAIL_INVOICE_DISPUTE_DATA.PRODUCT_ID,
	     v_RETAIL_INVOICE_DISPUTE_DATA.COMPONENT_ID,
	     v_RETAIL_INVOICE_DISPUTE_DATA.PERIOD_ID,
	     v_RETAIL_INVOICE_DISPUTE_DATA.BEGIN_DATE,
	     v_RETAIL_INVOICE_DISPUTE_DATA.END_DATE,
		 v_RETAIL_INVOICE_DISPUTE_DATA.INTERNAL_QUANTITY,
		 v_RETAIL_INVOICE_DISPUTE_DATA.INTERNAL_AMOUNT,
		 v_RETAIL_INVOICE_DISPUTE_DATA.EXTERNAL_QUANTITY,
		 v_RETAIL_INVOICE_DISPUTE_DATA.EXTERNAL_AMOUNT,
		 v_RETAIL_INVOICE_DISPUTE_DATA.SETTLEMENT_RUN_ON
	FROM RETAIL_INVOICE_LINE_COMPONENT RILC,
	     RETAIL_INVOICE_LINE RIL,
		 RETAIL_INVOICE RI,
		 PROCESS_LOG PL
    WHERE RILC.RETAIL_INVOICE_LINE_COMP_ID = p_RETAIL_INVOICE_LINE_COMP_ID
	  AND RILC.RETAIL_INVOICE_LINE_ID = RIL.RETAIL_INVOICE_LINE_ID
	  AND RIL.RETAIL_INVOICE_ID = RI.RETAIL_INVOICE_ID
	  AND RI.PROCESS_ID = PL.PROCESS_ID(+); -- outer join in case there is no process log

	RETURN v_RETAIL_INVOICE_DISPUTE_DATA;
END GET_RI_DISPUTE_DATA;
----------------------------------------------------------------------
-- Insert a new duplicate dispute into the RETAIL_INVOICE_DISPUTE table.
-- %param p_DUPLICATE_DISPUTE_DATA    t_RETAIL_INVOICE_DISPUTE_DATA Data that is being disputed as a duplicate
-- %param p_DUPLICATE_OF_DISPUTE_DATA t_RETAIL_INVOICE_DISPUTE_DATA Data for the duplicated line
PROCEDURE PUT_DUPLICATE_DISPUTE
(
    p_DUPLICATE_DISPUTE_DATA t_RETAIL_INVOICE_DISPUTE_DATA,
    p_DUPLICATE_OF_DISPUTE_DATA t_RETAIL_INVOICE_DISPUTE_DATA
) AS
BEGIN
 INSERT INTO RETAIL_INVOICE_DISPUTE
	(
		DISPUTE_ID,
		DISPUTE_TYPE,
		RETAIL_INVOICE_ID,
		ACCOUNT_ID,
		METER_ID,
		SERVICE_POINT_ID,
		PRODUCT_ID,
		COMPONENT_ID,
		PERIOD_ID,
		BEGIN_DATE,
		END_DATE,
		EXTERNAL_QUANTITY,
		EXTERNAL_AMOUNT,
		ORIGINAL_RETAIL_INVOICE_ID,
		ORIGINAL_PRODUCT_ID,
		ORIGINAL_COMPONENT_ID,
		ORIGINAL_EXT_QUANTITY,
		ORIGINAL_EXT_AMOUNT,
		SETTLEMENT_RUN_ON,
		DISPUTE_STATUS,
		DISPUTE_CATEGORY,
		UPDATED_BY,
		UPDATED_DATE
	)
	VALUES
	(
		DISPUTE_ID.NEXTVAL,
		RETAIL_SETTLEMENT.c_DISPUTE_TYPE_DUPLICATE,
		p_DUPLICATE_DISPUTE_DATA.RETAIL_INVOICE_ID,
		p_DUPLICATE_DISPUTE_DATA.ACCOUNT_ID,
		p_DUPLICATE_DISPUTE_DATA.METER_ID,
		p_DUPLICATE_DISPUTE_DATA.SERVICE_POINT_ID,
		p_DUPLICATE_DISPUTE_DATA.PRODUCT_ID,
		p_DUPLICATE_DISPUTE_DATA.COMPONENT_ID,
		p_DUPLICATE_DISPUTE_DATA.PERIOD_ID,
		p_DUPLICATE_DISPUTE_DATA.BEGIN_DATE,
		p_DUPLICATE_DISPUTE_DATA.END_DATE,
		p_DUPLICATE_DISPUTE_DATA.EXTERNAL_QUANTITY,
		p_DUPLICATE_DISPUTE_DATA.EXTERNAL_AMOUNT,
		p_DUPLICATE_OF_DISPUTE_DATA.RETAIL_INVOICE_ID,
		p_DUPLICATE_OF_DISPUTE_DATA.PRODUCT_ID,
		p_DUPLICATE_OF_DISPUTE_DATA.COMPONENT_ID,
		p_DUPLICATE_OF_DISPUTE_DATA.EXTERNAL_QUANTITY,
		p_DUPLICATE_OF_DISPUTE_DATA.EXTERNAL_AMOUNT,
		p_DUPLICATE_DISPUTE_DATA.SETTLEMENT_RUN_ON,
		RETAIL_SETTLEMENT.c_DISPUTE_STATUS_OPEN,
		RETAIL_SETTLEMENT.c_DISPUTE_CATEGORY_DUPLICATE,
		SECURITY_CONTROLS.GET_CURRENT_USER_DISPLAY_NAME,
		p_DUPLICATE_DISPUTE_DATA.SETTLEMENT_RUN_ON
	);
END PUT_DUPLICATE_DISPUTE;
----------------------------------------------------------------------
-- Utility procedure to update existing duplicate disputes for an invoice.
-- This procedure obtains the Settlement Run On timestamp from the
-- process log for the specified invoice (or NULL if for some reason
-- the process log is not present) and updates the timestamp columns on
-- the disputes table for open disputes for the specified invoice.
PROCEDURE UPD_DUPLICATE_DISPUTES
(
    p_RETAIL_INVOICE_ID IN RETAIL_INVOICE.RETAIL_INVOICE_ID%TYPE
) AS
    v_SETTLEMENT_RUN_ON DATE;
BEGIN
    SELECT PL.PROCESS_START_TIME
	INTO v_SETTLEMENT_RUN_ON
	FROM RETAIL_INVOICE RI,
	     PROCESS_LOG PL
	WHERE RI.RETAIL_INVOICE_ID = p_RETAIL_INVOICE_ID
	  AND RI.PROCESS_ID = PL.PROCESS_ID(+);

 UPDATE RETAIL_INVOICE_DISPUTE
	SET SETTLEMENT_RUN_ON = v_SETTLEMENT_RUN_ON,
		UPDATED_BY = SECURITY_CONTROLS.GET_CURRENT_USER_DISPLAY_NAME,
		UPDATED_DATE = v_SETTLEMENT_RUN_ON
	WHERE DISPUTE_TYPE = c_DISPUTE_TYPE_DUPLICATE
	  AND RETAIL_INVOICE_ID = p_RETAIL_INVOICE_ID
	  AND DISPUTE_STATUS <> c_DISPUTE_STATUS_WITHDRAWN AND DISPUTE_STATUS <> c_DISPUTE_STATUS_CLOSED;
END UPD_DUPLICATE_DISPUTES;
----------------------------------------------------------------------
-- The main entry point for identifying and generating duplicate disputes for a specified invoice.
-- %param p_RETAIL_INVOICE_ID IN NUMBER The invoice id for which to generate duplicate disputes
PROCEDURE GENERATE_DUPLICATE_DISPUTES
(
    p_RETAIL_INVOICE_ID IN RETAIL_INVOICE.RETAIL_INVOICE_ID%TYPE
) AS
    v_DUPLICATE_ID_TABLE t_DUPLICATE_ID_TABLE;
	v_DUPLICATE_ID_RECORD t_DUPLICATE_ID_RECORD;
	v_DUPLICATE_DISPUTE_DATA t_RETAIL_INVOICE_DISPUTE_DATA;
	v_DUPLICATE_OF_DISPUTE_DATA t_RETAIL_INVOICE_DISPUTE_DATA;
	v_DUPLICATE_COUNT NUMBER;
BEGIN
    -- make the assumption that an invoice structure will not change
	-- so just check if duplicate disputes exist for this invoice
    SELECT COUNT(*)
	INTO v_DUPLICATE_COUNT
	FROM RETAIL_INVOICE_DISPUTE
	WHERE DISPUTE_TYPE = c_DISPUTE_TYPE_DUPLICATE
      AND RETAIL_INVOICE_ID = p_RETAIL_INVOICE_ID;

	IF v_DUPLICATE_COUNT > 0 THEN
	    -- if duplicate disputes exist for this invoice, just update
	    UPD_DUPLICATE_DISPUTES(p_RETAIL_INVOICE_ID);
	ELSE
	    -- duplicate disputes do not exist, so we must determine duplicates and generate disputes for them
     v_DUPLICATE_ID_TABLE := IDENTIFY_DUPLICATE_RILC_IDS(p_RETAIL_INVOICE_ID);
	    FOR I IN 1..v_DUPLICATE_ID_TABLE.COUNT LOOP
      v_DUPLICATE_ID_RECORD := v_DUPLICATE_ID_TABLE(I);
			   -- get the data for the disputed line and the duplicated line
		    v_DUPLICATE_DISPUTE_DATA := GET_RI_DISPUTE_DATA(v_DUPLICATE_ID_RECORD.DUPLICATE_RILC_ID);
		    v_DUPLICATE_OF_DISPUTE_DATA := GET_RI_DISPUTE_DATA(v_DUPLICATE_ID_RECORD.DUPLICATE_OF_RILC_ID);

		    PUT_DUPLICATE_DISPUTE(v_DUPLICATE_DISPUTE_DATA, v_DUPLICATE_OF_DISPUTE_DATA);
	    END LOOP;
	END IF;

END GENERATE_DUPLICATE_DISPUTES;
--------------------------------------------------------------------------------
-- The main entry point for identifying and generating out of tolerance disputes for a specified invoice.
-- %param p_RETAIL_INVOICE_ID IN NUMBER The invoice id for which to generate duplicate disputes
PROCEDURE GENERATE_OOT_DISPUTES
(
    p_RETAIL_INVOICE_ID IN RETAIL_INVOICE.RETAIL_INVOICE_ID%TYPE
) AS
    UNSTABLE_ROWSET EXCEPTION;
    PRAGMA EXCEPTION_INIT(UNSTABLE_ROWSET, -30926);
BEGIN
    MERGE INTO RETAIL_INVOICE_DISPUTE RID
	USING
	(
	    -- The USING subquery identifies retail invoice line component rows
		-- which are out of tolerance.  The columns selected will both be used
		-- to identify if an existing out of tolerance dispute exists as well
		-- as returning data to record a new dispute
	    SELECT RILC.RETAIL_INVOICE_LINE_COMP_ID,
		       RI.RETAIL_INVOICE_ID,
			   RIL.ACCOUNT_ID,
			   RIL.METER_ID,
			   RIL.SERVICE_POINT_ID,
			   RILC.PRODUCT_ID,
			   RILC.COMPONENT_ID,
			   RILC.PERIOD_ID,
			   RILC.BEGIN_DATE,
			   RILC.END_DATE,
			   PL.PROCESS_START_TIME,
			   CT.VOLUME_AMOUNT_THRESH,
			   CT.VOLUME_PERCENT_THRESH,
			   CT.CHARGE_AMOUNT_THRESH,
			   CT.CHARGE_PERCENT_THRESH,
			   RILC.INTERNAL_QUANTITY,
			   RILC.INTERNAL_AMOUNT,
			   RILC.EXTERNAL_QUANTITY,
			   RILC.EXTERNAL_AMOUNT
		FROM
		(
		    WITH CRILC AS
			(
			    SELECT RILC.RETAIL_INVOICE_LINE_COMP_ID,
				       RILC.EXTERNAL_QUANTITY,
					   RILC.EXTERNAL_AMOUNT,
					   RILC.INTERNAL_QUANTITY,
					   RILC.INTERNAL_AMOUNT,
				       CT.VOLUME_AMOUNT_THRESH,
					   CT.CHARGE_AMOUNT_THRESH,
					   CT.VOLUME_PERCENT_THRESH,
					   CT.CHARGE_PERCENT_THRESH
				FROM COMPONENT_TOLERANCES CT,
					 RETAIL_INVOICE_LINE_COMPONENT RILC,
					 RETAIL_INVOICE_LINE RIL
				WHERE CT.COMPONENT_ID = RILC.COMPONENT_ID
				  AND RILC.RETAIL_INVOICE_LINE_ID = RIL.RETAIL_INVOICE_LINE_ID
				  AND RIL.RETAIL_INVOICE_ID = p_RETAIL_INVOICE_ID
			)

			SELECT RETAIL_INVOICE_LINE_COMP_ID
			FROM CRILC
			WHERE VOLUME_AMOUNT_THRESH IS NOT NULL
			  AND EXTERNAL_QUANTITY IS NOT NULL
			  AND INTERNAL_QUANTITY IS NOT NULL
			  AND ABS(EXTERNAL_QUANTITY-INTERNAL_QUANTITY) > VOLUME_AMOUNT_THRESH

			UNION

			SELECT RETAIL_INVOICE_LINE_COMP_ID
			FROM CRILC
			WHERE CHARGE_AMOUNT_THRESH IS NOT NULL AND
				  EXTERNAL_AMOUNT IS NOT NULL AND
				  INTERNAL_AMOUNT IS NOT NULL AND
				  ABS(EXTERNAL_AMOUNT-INTERNAL_AMOUNT) > CHARGE_AMOUNT_THRESH

			UNION

			SELECT RETAIL_INVOICE_LINE_COMP_ID
			FROM CRILC
			WHERE VOLUME_PERCENT_THRESH IS NOT NULL AND
				  EXTERNAL_QUANTITY IS NOT NULL AND
				  INTERNAL_QUANTITY IS NOT NULL AND
				  EXTERNAL_QUANTITY <> 0 AND
				  ABS(EXTERNAL_QUANTITY-INTERNAL_QUANTITY)/EXTERNAL_QUANTITY > VOLUME_PERCENT_THRESH

			UNION

			SELECT RETAIL_INVOICE_LINE_COMP_ID
			FROM CRILC
			WHERE CHARGE_PERCENT_THRESH IS NOT NULL AND
				  EXTERNAL_AMOUNT IS NOT NULL AND
				  INTERNAL_AMOUNT IS NOT NULL AND
				  EXTERNAL_AMOUNT <> 0 AND
				  ABS(EXTERNAL_AMOUNT-INTERNAL_AMOUNT)/EXTERNAL_AMOUNT > CHARGE_PERCENT_THRESH

			UNION

			SELECT RETAIL_INVOICE_LINE_COMP_ID
			FROM CRILC
			WHERE EXTERNAL_QUANTITY = 0
			  AND VOLUME_PERCENT_THRESH IS NOT NULL
			  AND INTERNAL_QUANTITY<>0

			UNION

			SELECT RETAIL_INVOICE_LINE_COMP_ID
			FROM CRILC
			WHERE EXTERNAL_AMOUNT = 0
			  AND CHARGE_PERCENT_THRESH IS NOT NULL
			  AND INTERNAL_AMOUNT<>0
		) OOT_RILC_IDS,
		  RETAIL_INVOICE_LINE_COMPONENT RILC,
		  RETAIL_INVOICE_LINE RIL,
		  RETAIL_INVOICE RI,
		  PROCESS_LOG PL,
		  COMPONENT_TOLERANCES CT
		WHERE OOT_RILC_IDS.RETAIL_INVOICE_LINE_COMP_ID = RILC.RETAIL_INVOICE_LINE_COMP_ID
		  AND RILC.RETAIL_INVOICE_LINE_ID = RIL.RETAIL_INVOICE_LINE_ID
		  AND RIL.RETAIL_INVOICE_ID = RI.RETAIL_INVOICE_ID
		  AND RI.PROCESS_ID = PL.PROCESS_ID(+)
		  AND RILC.COMPONENT_ID = CT.COMPONENT_ID
	) CRITERIA
	ON
	(
	    RID.DISPUTE_TYPE = RETAIL_SETTLEMENT.c_DISPUTE_TYPE_OOT AND
		CRITERIA.RETAIL_INVOICE_ID = RID.RETAIL_INVOICE_ID AND
		CRITERIA.ACCOUNT_ID = RID.ACCOUNT_ID AND
		CRITERIA.METER_ID = RID.METER_ID AND
		CRITERIA.SERVICE_POINT_ID = RID.SERVICE_POINT_ID AND
		CRITERIA.PRODUCT_ID = RID.PRODUCT_ID AND
		CRITERIA.COMPONENT_ID = RID.COMPONENT_ID AND
		NVL(CRITERIA.PERIOD_ID,CONSTANTS.NOT_ASSIGNED) = NVL(RID.PERIOD_ID,CONSTANTS.NOT_ASSIGNED) AND
		CRITERIA.BEGIN_DATE = RID.BEGIN_DATE AND
		CRITERIA.END_DATE = RID.END_DATE
	)
	WHEN MATCHED THEN
	    UPDATE
		SET RID.SETTLEMENT_RUN_ON = CRITERIA.PROCESS_START_TIME,
			RID.OOT_VOLUME_AMOUNT_THRESH = CRITERIA.VOLUME_AMOUNT_THRESH,
			RID.OOT_VOLUME_PERCENT_THRESH = CRITERIA.VOLUME_PERCENT_THRESH,
			RID.OOT_CHARGE_AMOUNT_THRESH = CRITERIA.CHARGE_AMOUNT_THRESH,
			RID.OOT_CHARGE_PERCENT_THRESH = CRITERIA.CHARGE_PERCENT_THRESH,
			RID.UPDATED_BY = SECURITY_CONTROLS.GET_CURRENT_USER_DISPLAY_NAME,
			RID.UPDATED_DATE = CRITERIA.PROCESS_START_TIME
		WHERE RID.DISPUTE_STATUS <> RETAIL_SETTLEMENT.c_DISPUTE_STATUS_WITHDRAWN
		  AND RID.DISPUTE_STATUS <> RETAIL_SETTLEMENT.c_DISPUTE_STATUS_CLOSED
	WHEN NOT MATCHED THEN
	    INSERT
		(
			DISPUTE_ID,
			DISPUTE_TYPE,
			RETAIL_INVOICE_ID,
			ACCOUNT_ID,
			METER_ID,
			SERVICE_POINT_ID,
			PRODUCT_ID,
			COMPONENT_ID,
			PERIOD_ID,
			BEGIN_DATE,
			END_DATE,
			INTERNAL_QUANTITY,
			INTERNAL_AMOUNT,
			EXTERNAL_QUANTITY,
			EXTERNAL_AMOUNT,
			OOT_VOLUME_AMOUNT_THRESH,
			OOT_VOLUME_PERCENT_THRESH,
			OOT_CHARGE_AMOUNT_THRESH,
			OOT_CHARGE_PERCENT_THRESH,
			SETTLEMENT_RUN_ON,
			DISPUTE_STATUS,
			DISPUTE_CATEGORY,
			UPDATED_BY,
			UPDATED_DATE
		)
		VALUES
		(
			DISPUTE_ID.NEXTVAL,
			RETAIL_SETTLEMENT.c_DISPUTE_TYPE_OOT,
			CRITERIA.RETAIL_INVOICE_ID,
			CRITERIA.ACCOUNT_ID,
			CRITERIA.METER_ID,
			CRITERIA.SERVICE_POINT_ID,
			CRITERIA.PRODUCT_ID,
			CRITERIA.COMPONENT_ID,
			CRITERIA.PERIOD_ID,
			CRITERIA.BEGIN_DATE,
			CRITERIA.END_DATE,
			CRITERIA.INTERNAL_QUANTITY,
			CRITERIA.INTERNAL_AMOUNT,
			CRITERIA.EXTERNAL_QUANTITY,
			CRITERIA.EXTERNAL_AMOUNT,
			CRITERIA.VOLUME_AMOUNT_THRESH,
			CRITERIA.VOLUME_PERCENT_THRESH,
			CRITERIA.CHARGE_AMOUNT_THRESH,
			CRITERIA.CHARGE_PERCENT_THRESH,
			CRITERIA.PROCESS_START_TIME,
			RETAIL_SETTLEMENT.c_DISPUTE_STATUS_OPEN,
			RETAIL_SETTLEMENT.c_DISPUTE_CATEGORY_OOT,
			SECURITY_CONTROLS.GET_CURRENT_USER_DISPLAY_NAME,
			CRITERIA.PROCESS_START_TIME
		);
EXCEPTION
   WHEN UNSTABLE_ROWSET THEN
      NULL;
END GENERATE_OOT_DISPUTES;
--------------------------------------------------------------------------------
-- The main entry point for identifying and generating disputes for a specified invoice.
-- This will include duplicate disputes and out-of-tolerance disputes.
-- %param p_RETAIL_INVOICE_ID IN NUMBER The invoice id for which to generate disputes
PROCEDURE GENERATE_DISPUTES
(
    p_RETAIL_INVOICE_ID IN RETAIL_INVOICE.RETAIL_INVOICE_ID%TYPE
) AS
BEGIN
    -- generate duplicate disputes if the dictionary setting is turned on
    IF NVL(GET_DICTIONARY_VALUE('Generate Duplicate Disputes', 0, 'Financial Settlements', 'Dispute Management'),'N') = 'Y' THEN
	    GENERATE_DUPLICATE_DISPUTES(p_RETAIL_INVOICE_ID);
	END IF;

    -- generate out of tolerance disputes if the dictionary setting is turned on
    IF NVL(GET_DICTIONARY_VALUE('Generate Out of Tolerance Disputes', 0, 'Financial Settlements', 'Dispute Management'),'N') = 'Y' THEN
	    GENERATE_OOT_DISPUTES(p_RETAIL_INVOICE_ID);
	END IF;
END GENERATE_DISPUTES;
--------------------------------------------------------------------------------
-- Runs the Retail Settlement Engine, evaluates the selected Components and
-- stores the results in the RETAIL_INVOICE_LINE, RETAIL_INVOICE_COMPONENT,
-- and RETAIL_INVOICE_LINE_COMPONENT tables.
--
-- NOTE: Ordering of the Inputs cursor is important. It must be ordered:
-- ACCOUNT_ID ASC, SERVICE_POINT_ID ASC, CHARGE_STATE ASC
-- This will help with performance of the determinant caches and will also
-- ensure that all dependent components are evaluated prior to the Tax charges
-- calculation.
--
-- %param p_RETAIL_INVOICE_ID         The internal ID from RETAIL_INVOICE.
-- %param p_RETAIL_SETTLEMENT_INPUTS  Cursor of RETAIL_SETTLEMENT_INPUT
--                                    records. This is the list of
--                                    Components to be evaluated by the
--                                    Retail Settlement Engine.
-- %param p_STATEMENT_TYPE_ID         The Statement Type used during Component evaluation.
-- %param p_TIME_ZONE         		  The Time Zone used during Component evaluation.
-- %param p_SERVICE_CODE			  The Service Code used during Component evaluation when looking up determinants.
-- %param p_OTHER_PARAMS              Optional parameter values that can be
--                                    evaluated by a Formula charge
-- %param p_INPUT_COUNT               Optional count for monitoring progress.

PROCEDURE RUN_RETAIL_SETTLEMENT
	(
	p_RETAIL_INVOICE_ID        IN NUMBER,
	p_RETAIL_SETTLEMENT_INPUTS IN RETAIL_SETTLEMENT_INPUT_CURSOR,
	p_STATEMENT_TYPE_ID        IN NUMBER,
	p_TIME_ZONE                IN VARCHAR2,
	p_SERVICE_CODE             IN CHAR,
	p_OTHER_PARAMS             IN UT.STRING_MAP := UT.c_EMPTY_MAP,
	p_INPUT_COUNT              IN NUMBER := NULL,
	p_ALLOW_NO_ACCOUNTS_SPS    IN BOOLEAN := FALSE,
	p_MARK_CONSUMPTION         IN BOOLEAN := TRUE,
	p_RETAIN_INVOICE_LINES     IN BOOLEAN := FALSE
	) AS
v_RETAIL_INVOICE			RETAIL_INVOICE%ROWTYPE;
v_INPUT   					RETAIL_SETTLEMENT_INPUT;
v_LAST_ACCOUNT_ID           NUMBER(9) := CONSTANTS.NOT_ASSIGNED;
v_LAST_METER_ID				NUMBER(9) := CONSTANTS.NOT_ASSIGNED;
v_LAST_SERVICE_POINT_ID     NUMBER(9) := CONSTANTS.NOT_ASSIGNED;
v_CURRENT_ACCESSOR			DETERMINANT_ACCESSOR;
v_ACCT_ACCESSOR				ACCOUNT_DETERMINANT_ACCESSOR;
v_POD_ACCESSOR				POD_DETERMINANT_ACCESSOR;
v_TAX_ACCESSOR              TAX_DETERMINANT_ACCESSOR;
v_LAST_DETERMINANT_ACCESSOR VARCHAR2(1);
v_PROGRESS_IDX				NUMBER(9);
v_PARAMS					UT.STRING_MAP;
v_ACCOUNT_DATE_RANGES		DATE_RANGE_TABLE := DATE_RANGE_TABLE();
v_MIN_BEGIN_DATE			DATE := CONSTANTS.LOW_DATE;
v_MAX_END_DATE				DATE := CONSTANTS.HIGH_DATE;
p_SERVICE_IDS				NUMBER_COLLECTION;
v_CURRENT_INVOICE_LINE		RETAIL_INVOICE_LINE%ROWTYPE;
v_LAST_INVOICE_LINE			RETAIL_INVOICE_LINE%ROWTYPE;
v_PRICING_RESULT_TABLE		PRICING_RESULT_TABLE;
v_INVOICE_LINE_COMPONENT	RETAIL_INVOICE_LINE_COMPONENT%ROWTYPE;
v_SERVICE_IDS				NUMBER_COLLECTION;
v_IDX						NUMBER(9);
v_LAST_BEGIN_DATE           DATE := CONSTANTS.HIGH_DATE;

v_TEMPLATE_ID				NUMBER(9);

TYPE t_RETAIL_INVOICE_COMPONENT_TAB IS TABLE OF RETAIL_INVOICE_COMPONENT%ROWTYPE INDEX BY VARCHAR2(4000);
v_INVOICE_COMPONENT_DATA 	t_RETAIL_INVOICE_COMPONENT_TAB;
v_INVOICE_COMPONENT_DATA_IDX VARCHAR2(4000);

	PROCEDURE INS_RETAIL_INVOICE_LINE_COMP(v_ROW IN RETAIL_INVOICE_LINE_COMPONENT%ROWTYPE) AS
	BEGIN
		LOGS.LOG_DEBUG('Inserting RETAIL_INVOICE_LINE_COMPONENT for: ' ||
				'RETAIL_INVOICE_LINE_COMP_ID=' || v_ROW.RETAIL_INVOICE_LINE_COMP_ID || ',' ||
				'RETAIL_INVOICE_LINE_ID=' || v_ROW.RETAIL_INVOICE_LINE_ID || ',' ||
				'PRODUCT_ID=' || v_ROW.PRODUCT_ID || ',' ||
				'PRODUCT=' || TEXT_UTIL.TO_CHAR_ENTITY(v_ROW.PRODUCT_ID,EC.ED_PRODUCT) || ',' ||
				'COMPONENT_ID=' || v_ROW.COMPONENT_ID || ',' ||
				'COMPONENT=' || TEXT_UTIL.TO_CHAR_ENTITY(v_ROW.COMPONENT_ID,EC.ED_COMPONENT) || ',' ||
				'PERIOD_ID=' || v_ROW.PERIOD_ID || ',' ||
				'PERIOD=' || TEXT_UTIL.TO_CHAR_ENTITY(v_ROW.PERIOD_ID,EC.ED_PERIOD) || ',' ||
				'BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_ROW.BEGIN_DATE) || ',' ||
				'END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_ROW.END_DATE) || ',' ||
				'CHARGE_STATE=' || v_ROW.CHARGE_STATE || ',' ||
				'INTERNAL_QUANTITY=' || v_ROW.INTERNAL_QUANTITY || ',' ||
				'INTERNAL_RATE=' || v_ROW.INTERNAL_RATE || ',' ||
				'INTERNAL_AMOUNT=' || v_ROW.INTERNAL_AMOUNT || ',' ||
				'EXTERNAL_QUANTITY=' || v_ROW.EXTERNAL_QUANTITY || ',' ||
				'EXTERNAL_RATE=' || v_ROW.EXTERNAL_RATE || ',' ||
				'EXTERNAL_AMOUNT=' || v_ROW.EXTERNAL_AMOUNT || ',' ||
				'DETERMINANT_STATUS=' || v_ROW.DETERMINANT_STATUS);
		INSERT INTO RETAIL_INVOICE_LINE_COMPONENT VALUES v_ROW;
	END;

BEGIN
	LOGS.LOG_INFO('Begin RUN_RETAIL_SETTLEMENT for Invoice:' || p_RETAIL_INVOICE_ID || ' with ' || p_INPUT_COUNT || ' records.');

	SD.VERIFY_ACTION_IS_ALLOWED(SD.g_ACTION_RUN_ANY_FIN_SETTLEMNT);

	IF p_INPUT_COUNT IS NOT NULL AND p_INPUT_COUNT > 0 THEN
		v_PROGRESS_IDX := LOGS.PUSH_PROGRESS_RANGE(p_INPUT_COUNT);
	END IF;

	-- Fetch the RETAIL_INVOICE record
	Select *
	INTO v_RETAIL_INVOICE
	FROM RETAIL_INVOICE R
	WHERE R.RETAIL_INVOICE_ID = p_RETAIL_INVOICE_ID;

	-- Update the RETAIL_INVOICE record
	UPDATE RETAIL_INVOICE R
	SET R.TIME_ZONE = p_TIME_ZONE, R.SERVICE_CODE = p_SERVICE_CODE, R.STATEMENT_TYPE_ID = p_STATEMENT_TYPE_ID
	WHERE R.RETAIL_INVOICE_ID = p_RETAIL_INVOICE_ID;

	-- Handle the p_OTHER_PARAMS
	v_PARAMS := p_OTHER_PARAMS;
	v_PARAMS(':invoice_id') := UT.GET_LITERAL_FOR_NUMBER(p_RETAIL_INVOICE_ID);
	v_PARAMS(':invoice_number') := UT.GET_LITERAL_FOR_STRING(v_RETAIL_INVOICE.INVOICE_NUMBER);
	v_PARAMS(':invoice_date') := UT.GET_LITERAL_FOR_DATE(v_RETAIL_INVOICE.INVOICE_DATE);
	v_PARAMS(':sender') := UT.GET_LITERAL_FOR_NUMBER(v_RETAIL_INVOICE.SENDER_PSE_ID);
	v_PARAMS(':recipient') := UT.GET_LITERAL_FOR_NUMBER(v_RETAIL_INVOICE.RECIPIENT_PSE_ID);

	-- Initialize the Formula Charge context
	RETAIL_PRICING.INIT_FORMULA_CONTEXT(p_SERVICE_CODE, p_TIME_ZONE, NULL, p_STATEMENT_TYPE_ID, v_PARAMS);

	-- Delete all existing records
	IF p_RETAIN_INVOICE_LINES = FALSE THEN
	    DELETE FROM RETAIL_INVOICE_LINE L WHERE L.RETAIL_INVOICE_ID = p_RETAIL_INVOICE_ID;
        DELETE FROM RETAIL_INVOICE_COMPONENT C WHERE C.RETAIL_INVOICE_ID = p_RETAIL_INVOICE_ID;
    END IF;

	LOOP
		FETCH p_RETAIL_SETTLEMENT_INPUTS
			INTO v_INPUT;
		EXIT WHEN p_RETAIL_SETTLEMENT_INPUTS%NOTFOUND;

		LOGS.LOG_DEBUG('-------------------------------------------');

		LOGS.LOG_DEBUG('Processing input: '
					|| 'ACCOUNT=' || TEXT_UTIL.TO_CHAR_ENTITY(v_INPUT.ACCOUNT_ID,EC.ED_ACCOUNT)
					|| ',METER=' || TEXT_UTIL.TO_CHAR_ENTITY(v_INPUT.METER_ID,EC.ED_METER)
					|| ',SERVICE_POINT=' || TEXT_UTIL.TO_CHAR_ENTITY(v_INPUT.SERVICE_POINT_ID,EC.ED_SERVICE_POINT)
					|| ',PRODUCT=' || TEXT_UTIL.TO_CHAR_ENTITY(v_INPUT.PRODUCT_ID,EC.ED_PRODUCT)
					|| ',COMPONENT=' || TEXT_UTIL.TO_CHAR_ENTITY(v_INPUT.COMPONENT_ID,EC.ED_COMPONENT)
					|| ',PERIOD=' || TEXT_UTIL.TO_CHAR_ENTITY(v_INPUT.PERIOD_ID,EC.ED_PERIOD)
					|| ',BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_INPUT.BEGIN_DATE)
					|| ',END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_INPUT.END_DATE));

		-- Validate the record
		ASSERT(v_INPUT.ACCOUNT_ID IS NOT NULL, 'ACCOUNT_ID must be not null.', MSGCODES.c_ERR_ARGUMENT);
		ASSERT(v_INPUT.SERVICE_POINT_ID IS NOT NULL, 'SERVICE_POINT_ID must be not null.', MSGCODES.c_ERR_ARGUMENT);
		ASSERT(v_INPUT.METER_ID IS NOT NULL, 'METER_ID must be not null.', MSGCODES.c_ERR_ARGUMENT);
		ASSERT(v_INPUT.ACCOUNT_ID <> CONSTANTS.NOT_ASSIGNED OR v_INPUT.SERVICE_POINT_ID <> CONSTANTS.NOT_ASSIGNED OR p_ALLOW_NO_ACCOUNTS_SPS, 'Either the ACCOUNT_ID or the SERVICE_POINT_ID must be set.', MSGCODES.c_ERR_ARGUMENT);
		ASSERT(v_INPUT.PRODUCT_ID IS NOT NULL, 'PRODUCT_ID must be not null.', MSGCODES.c_ERR_ARGUMENT);
		ASSERT(v_INPUT.COMPONENT_ID IS NOT NULL, 'COMPONENT_ID must be not null.', MSGCODES.c_ERR_ARGUMENT);
		ASSERT(v_INPUT.CHARGE_STATE IS NOT NULL
			AND v_INPUT.CHARGE_STATE IN (c_CHARGE_STATE_NORMAL,c_CHARGE_STATE_ADJUSTMENT,c_CHARGE_STATE_CANCELLATION,c_CHARGE_STATE_MANUAL,c_CHARGE_STATE_CANCEL_MANUAL,c_CHARGE_STATE_CANCELLED_TAX,c_CHARGE_STATE_TAX,c_CHARGE_STATE_REBILL),
			'CHARGE_STATE must be either ' || c_CHARGE_STATE_NORMAL || ',' || c_CHARGE_STATE_ADJUSTMENT || ',' ||
			c_CHARGE_STATE_CANCELLATION || ',' || c_CHARGE_STATE_MANUAL || ',' || c_CHARGE_STATE_CANCEL_MANUAL || ',' || c_CHARGE_STATE_CANCELLED_TAX || ',' || c_CHARGE_STATE_TAX || ',' || c_CHARGE_STATE_REBILL ||'.', MSGCODES.c_ERR_ARGUMENT);

		SELECT NVL(C.TEMPLATE_ID, CONSTANTS.NOT_ASSIGNED)
		INTO v_TEMPLATE_ID
		FROM COMPONENT C
		WHERE C.COMPONENT_ID = V_INPUT.COMPONENT_ID;

		IF v_TEMPLATE_ID <> CONSTANTS.NOT_ASSIGNED THEN
			-- CHECK TEMPLATE DATES FOR THIS LINE
			SP.CHECK_TEMPLATE_DATES(v_TEMPLATE_ID,
									CONSTANTS.ALL_HOLIDAYS_HOLIDAY_SET,
									p_TIME_ZONE,
									v_INPUT.BEGIN_DATE,
									v_INPUT.END_DATE);
		END IF;


		-- Determine if we are processing a Account or Service Point
		-- and perform the proper initialization
		IF v_INPUT.SERVICE_POINT_ID <> CONSTANTS.NOT_ASSIGNED THEN

			-- Account Cleanup
			IF v_ACCOUNT_DATE_RANGES IS NOT NULL AND v_ACCOUNT_DATE_RANGES.COUNT() > 0 THEN
				v_ACCOUNT_DATE_RANGES := DATE_RANGE_TABLE();
			END IF;
			v_ACCT_ACCESSOR := NULL;
			v_SERVICE_IDS := NULL;
			v_LAST_ACCOUNT_ID := CONSTANTS.NOT_ASSIGNED;
			v_LAST_METER_ID := CONSTANTS.NOT_ASSIGNED;
			v_MIN_BEGIN_DATE := NULL;
			v_MAX_END_DATE := NULL;

			-- Handle Service Point
			IF v_INPUT.SERVICE_POINT_ID <> v_LAST_SERVICE_POINT_ID THEN
				v_POD_ACCESSOR := RETAIL_DETERMINANTS.GET_POD_DETERMINANT_ACCESSOR(v_INPUT.SERVICE_POINT_ID,
					v_RETAIL_INVOICE.RECIPIENT_PSE_ID,
					v_INPUT.METER_TYPE,
					p_STATEMENT_TYPE_ID,
					p_TIME_ZONE);
				v_CURRENT_ACCESSOR := v_POD_ACCESSOR;
			END IF;

		ELSIF v_INPUT.ACCOUNT_ID <> CONSTANTS.NOT_ASSIGNED THEN
			-- Service Point Cleanup
			v_POD_ACCESSOR := NULL;

			-- Handle new Account ID or Meter ID
			IF v_INPUT.ACCOUNT_ID <> v_LAST_ACCOUNT_ID OR v_INPUT.METER_ID <> v_LAST_METER_ID THEN
				LOGS.LOG_DEBUG('New Account/Meter found. (ACCOUNT_ID=' || v_INPUT.ACCOUNT_ID || ',METER_ID=' || v_INPUT.METER_ID || ')');

				-- Handle the SERVICE_CONSUMPTION records for the last Account
				IF v_ACCT_ACCESSOR IS NOT NULL THEN
					LOGS.LOG_DEBUG('Update SERVICE_CONSUMPTION for ' || TEXT_UTIL.TO_CHAR_DATE_RANGE(v_MIN_BEGIN_DATE,v_MAX_END_DATE));
					BEGIN
						v_SERVICE_IDS := v_ACCT_ACCESSOR.GET_ACTIVE_SERVICES(v_MIN_BEGIN_DATE,v_MAX_END_DATE);
						LOGS.LOG_DEBUG('Found ' || v_SERVICE_IDS.COUNT() || ' Service IDs.');

                        IF p_MARK_CONSUMPTION THEN
                             PUT_BILL_PROCESSED_DATE(v_RETAIL_INVOICE.INVOICE_DATE,v_ACCOUNT_DATE_RANGES,p_SERVICE_CODE,v_SERVICE_IDS);
                        END IF;
					EXCEPTION
						WHEN OTHERS THEN
							ERRS.LOG_AND_CONTINUE('Could not update SERVICE_CONSUMPTION records for: ACCOUNT_ID=' || v_INPUT.ACCOUNT_ID || ',METER_ID=' || v_INPUT.METER_ID);
					END;
				END IF;

				-- Get a new DETERMINANT_ACCESSOR for this account
				v_ACCT_ACCESSOR := RETAIL_DETERMINANTS.GET_ACCT_DETERMINANT_ACCESSOR(v_INPUT.ACCOUNT_ID,
					CONSTANTS.NOT_ASSIGNED,
					v_INPUT.METER_ID,
					CONSTANTS.NOT_ASSIGNED,
					p_SERVICE_CODE,
					GA.BASE_SCENARIO_ID,
					p_TIME_ZONE,
                    v_INPUT.ESP_ID);

				v_CURRENT_ACCESSOR := v_ACCT_ACCESSOR;

				-- Initialize
				v_ACCOUNT_DATE_RANGES := DATE_RANGE_TABLE();
				v_MIN_BEGIN_DATE := NULL;
				v_MAX_END_DATE := NULL;

			END IF;

			-- Update the list of Date Ranges
			v_ACCOUNT_DATE_RANGES.EXTEND();
			v_ACCOUNT_DATE_RANGES(v_ACCOUNT_DATE_RANGES.LAST()) := DATE_RANGE(v_INPUT.BEGIN_DATE, v_INPUT.END_DATE);
			v_MIN_BEGIN_DATE := LEAST(NVL(v_MIN_BEGIN_DATE,CONSTANTS.HIGH_DATE),v_INPUT.BEGIN_DATE);
			v_MAX_END_DATE := GREATEST(NVL(v_MAX_END_DATE,CONSTANTS.LOW_DATE),v_INPUT.END_DATE);
        ELSE
            -- ONE TAX ACCESSOR APPLIES FOR THE ENTIRE RUN, SINCE THERE IS
            -- NO ACCOUNT / SERVICE POINT CONTEXT TO WORRY ABOUT
            -- IF ACCOUNT OR POD ACCESSOR IS NOT NULL THEN SOME ROW WITH ACCOUNTS / SERVICE POINTS WAS
            -- PRESENT, WE NEED TO RESET THE CURRENT ACCESSOR
            IF v_TAX_ACCESSOR IS NULL OR (v_ACCT_ACCESSOR IS NOT NULL OR v_POD_ACCESSOR IS NOT NULL) THEN
                v_TAX_ACCESSOR := RETAIL_DETERMINANTS.GET_TAX_DETERMINANT_ACCESSOR(p_TIME_ZONE);
                v_CURRENT_ACCESSOR := v_TAX_ACCESSOR;
            END IF;

            -- cleanup for both account and sevice point
            v_ACCT_ACCESSOR := NULL;
			v_SERVICE_IDS := NULL;
			v_LAST_ACCOUNT_ID := CONSTANTS.NOT_ASSIGNED;
			v_LAST_METER_ID := CONSTANTS.NOT_ASSIGNED;
			v_MIN_BEGIN_DATE := NULL;
			v_MAX_END_DATE := NULL;
            v_LAST_SERVICE_POINT_ID := CONSTANTS.NOT_ASSIGNED;

            IF v_ACCOUNT_DATE_RANGES IS NOT NULL AND v_ACCOUNT_DATE_RANGES.COUNT() > 0 THEN
				v_ACCOUNT_DATE_RANGES := DATE_RANGE_TABLE();
			END IF;
            v_POD_ACCESSOR := NULL;
		END IF;

		v_CURRENT_INVOICE_LINE := GET_RETAIL_INVOICE_LINE(p_RETAIL_INVOICE_ID, v_INPUT);

		LOGS.LOG_DEBUG('Retail Invoice Line Id = ' || v_CURRENT_INVOICE_LINE.RETAIL_INVOICE_LINE_ID);

		-- Get the new RETAIL_INVOICE_LINE_COMP_ID
		SELECT RETAIL_INVOICE_ID.NEXTVAL INTO v_INVOICE_LINE_COMPONENT.RETAIL_INVOICE_LINE_COMP_ID FROM DUAL;

		-- Process the record
		IF v_INPUT.CHARGE_STATE = c_CHARGE_STATE_CANCELLATION
			OR v_INPUT.CHARGE_STATE = c_CHARGE_STATE_CANCELLED_TAX
			OR v_INPUT.CHARGE_STATE = c_CHARGE_STATE_ADJUSTMENT
			OR v_INPUT.CHARGE_STATE = c_CHARGE_STATE_CANCEL_MANUAL THEN

		   -- Process Cancellations and Adjustments as a pass thru. No internal calculation.
			LOGS.LOG_DEBUG('Inserting a pass-thru record. CHARGE_STATE=' || v_INPUT.CHARGE_STATE || '.');
            v_INVOICE_LINE_COMPONENT.RETAIL_INVOICE_LINE_ID := v_CURRENT_INVOICE_LINE.RETAIL_INVOICE_LINE_ID;
            v_INVOICE_LINE_COMPONENT.PRODUCT_ID := v_INPUT.PRODUCT_ID;
            v_INVOICE_LINE_COMPONENT.COMPONENT_ID := v_INPUT.COMPONENT_ID;
            v_INVOICE_LINE_COMPONENT.PERIOD_ID := v_INPUT.PERIOD_ID;
            v_INVOICE_LINE_COMPONENT.BEGIN_DATE := v_INPUT.BEGIN_DATE;
            v_INVOICE_LINE_COMPONENT.END_DATE := v_INPUT.END_DATE;
            v_INVOICE_LINE_COMPONENT.CHARGE_STATE := v_INPUT.CHARGE_STATE;
            v_INVOICE_LINE_COMPONENT.INTERNAL_QUANTITY := NVL(v_INPUT.INTERNAL_QUANTITY,0);
            v_INVOICE_LINE_COMPONENT.INTERNAL_RATE := NVL(v_INPUT.INTERNAL_RATE,0);
            v_INVOICE_LINE_COMPONENT.INTERNAL_AMOUNT := NVL(v_INPUT.INTERNAL_AMOUNT,0);
            v_INVOICE_LINE_COMPONENT.EXTERNAL_QUANTITY := NVL(v_INPUT.EXTERNAL_QUANTITY,0);
            v_INVOICE_LINE_COMPONENT.EXTERNAL_RATE := NVL(v_INPUT.EXTERNAL_RATE,0);
            v_INVOICE_LINE_COMPONENT.EXTERNAL_AMOUNT := NVL(v_INPUT.EXTERNAL_AMOUNT,0);
            v_INVOICE_LINE_COMPONENT.DETERMINANT_STATUS := RETAIL_DETERMINANTS.c_STATUS_OK;
			v_INVOICE_LINE_COMPONENT.CREDIT_REFERENCE_ID:= v_INPUT.CREDIT_REFERENCE_ID;

			INS_RETAIL_INVOICE_LINE_COMP(v_INVOICE_LINE_COMPONENT);
		ELSE
			LOGS.LOG_DEBUG('Begin evaluating the component.');

			 /* Fix for BZ29396. This clears the taxable charges in the current accesor so that the tax calculation
				for the current billing periods would not include tax charges from previous billing periods. */
            IF v_INPUT.BEGIN_DATE != v_LAST_BEGIN_DATE AND v_INPUT.ACCOUNT_ID = v_LAST_ACCOUNT_ID THEN
                v_CURRENT_ACCESSOR.CLEAR_TAXABLE_CHARGES;
            END IF;

			v_PRICING_RESULT_TABLE := RETAIL_PRICING.EVALUATE_COMPONENT(
				v_CURRENT_ACCESSOR,
				v_INPUT.BEGIN_DATE,
				v_INPUT.END_DATE,
				v_INPUT.COMPONENT_ID,
				v_INPUT.PRODUCT_ID,
				v_INPUT.PERIOD_ID,
				TRUE);
			LOGS.LOG_DEBUG('End evaluating the component.');

			LOGS.LOG_DEBUG('Number of Pricing Results: ' || v_PRICING_RESULT_TABLE.COUNT);

			IF LOGS.IS_DEBUG_MORE_DETAIL_ENABLED THEN
    			v_IDX := v_PRICING_RESULT_TABLE.FIRST;
        		LOGS.LOG_DEBUG_MORE_DETAIL('Listing Results: ' || v_PRICING_RESULT_TABLE.COUNT);
				WHILE v_PRICING_RESULT_TABLE.EXISTS(v_IDX) LOOP
        			LOGS.LOG_DEBUG_MORE_DETAIL('PRODUCT_ID: ' || v_PRICING_RESULT_TABLE(v_IDX).PRODUCT_ID ||
                    	',COMPONENT_ID: ' || v_PRICING_RESULT_TABLE(v_IDX).COMPONENT_ID ||
                    	',TAXED_PRODUCT_ID: ' || v_PRICING_RESULT_TABLE(v_IDX).TAXED_PRODUCT_ID ||
                    	',TAXED_COMPONENT_ID: ' || v_PRICING_RESULT_TABLE(v_IDX).TAXED_COMPONENT_ID ||
                    	',CHILD_COMPONENT_ID: ' || v_PRICING_RESULT_TABLE(v_IDX).CHILD_COMPONENT_ID ||
                    	',PERIOD_ID: ' || v_PRICING_RESULT_TABLE(v_IDX).PERIOD_ID ||
                    	',BAND_TIER_NUMBER: ' || v_PRICING_RESULT_TABLE(v_IDX).BAND_TIER_NUMBER ||
                    	',BEGIN_DATE: ' || v_PRICING_RESULT_TABLE(v_IDX).BEGIN_DATE ||
                    	',END_DATE: ' || v_PRICING_RESULT_TABLE(v_IDX).END_DATE ||
                    	',DATES_ARE_CUT: ' || v_PRICING_RESULT_TABLE(v_IDX).DATES_ARE_CUT ||
                    	',NUMBER_OF_INTERVALS: ' || v_PRICING_RESULT_TABLE(v_IDX).NUMBER_OF_INTERVALS ||
                    	',BASE_QUANTITY: ' || v_PRICING_RESULT_TABLE(v_IDX).BASE_QUANTITY ||
                    	',FACTOR: ' || v_PRICING_RESULT_TABLE(v_IDX).FACTOR ||
                    	',QUANTITY: ' || v_PRICING_RESULT_TABLE(v_IDX).QUANTITY ||
                    	',RATE: ' || v_PRICING_RESULT_TABLE(v_IDX).RATE ||
                    	',AMOUNT: ' || v_PRICING_RESULT_TABLE(v_IDX).AMOUNT ||
                    	',FML_CHARGE_ID: ' || v_PRICING_RESULT_TABLE(v_IDX).FML_CHARGE_ID ||
                    	',DETERMINANT_STATUS: ' || v_PRICING_RESULT_TABLE(v_IDX).DETERMINANT_STATUS);
        			v_IDX := v_PRICING_RESULT_TABLE.NEXT(v_IDX);
        		END LOOP;
			END IF;

			-- Set known values
			v_INVOICE_LINE_COMPONENT.RETAIL_INVOICE_LINE_ID := v_CURRENT_INVOICE_LINE.RETAIL_INVOICE_LINE_ID;
			v_INVOICE_LINE_COMPONENT.PRODUCT_ID := v_INPUT.PRODUCT_ID;
			v_INVOICE_LINE_COMPONENT.COMPONENT_ID := v_INPUT.COMPONENT_ID;
			v_INVOICE_LINE_COMPONENT.PERIOD_ID := v_INPUT.PERIOD_ID;
			v_INVOICE_LINE_COMPONENT.BEGIN_DATE := v_INPUT.BEGIN_DATE;
			v_INVOICE_LINE_COMPONENT.END_DATE := v_INPUT.END_DATE;
			v_INVOICE_LINE_COMPONENT.CHARGE_STATE := v_INPUT.CHARGE_STATE;
			v_INVOICE_LINE_COMPONENT.EXTERNAL_QUANTITY := v_INPUT.EXTERNAL_QUANTITY;
			v_INVOICE_LINE_COMPONENT.EXTERNAL_RATE := v_INPUT.EXTERNAL_RATE;
			v_INVOICE_LINE_COMPONENT.EXTERNAL_AMOUNT := v_INPUT.EXTERNAL_AMOUNT;
   			v_INVOICE_LINE_COMPONENT.CREDIT_REFERENCE_ID:= v_INPUT.CREDIT_REFERENCE_ID;


			IF v_PRICING_RESULT_TABLE IS NOT NULL AND v_PRICING_RESULT_TABLE.COUNT() > 0 THEN
				-- Rollup and set the Quantity, Rate, Amount and Determinant Status
				SELECT SUM(A.QUANTITY) AS INTERNAL_QUANTITY,
					   CASE WHEN SUM(A.QUANTITY) = 0 THEN AVG(A.RATE*FACTOR) ELSE SUM(A.AMOUNT)/SUM(A.QUANTITY) END AS INTERNAL_RATE,
					   SUM(A.AMOUNT) AS INTERNAL_AMOUNT,
					   CASE
					   	WHEN MIN(A.DETERMINANT_STATUS) IS NULL THEN
							NULL
					   	WHEN MIN(A.DETERMINANT_STATUS) = MAX(A.DETERMINANT_STATUS) THEN
							MIN(A.DETERMINANT_STATUS)
						ELSE
							RETAIL_DETERMINANTS.c_STATUS_PARTIAL
					   END AS DETERMINANT_STATUS
				INTO v_INVOICE_LINE_COMPONENT.INTERNAL_QUANTITY,
					 v_INVOICE_LINE_COMPONENT.INTERNAL_RATE,
					 v_INVOICE_LINE_COMPONENT.INTERNAL_AMOUNT,
					 v_INVOICE_LINE_COMPONENT.DETERMINANT_STATUS
				FROM TABLE(CAST(v_PRICING_RESULT_TABLE AS PRICING_RESULT_TABLE)) A
				GROUP BY A.PRODUCT_ID, A.COMPONENT_ID;

			ELSE
				v_INVOICE_LINE_COMPONENT.INTERNAL_QUANTITY := 0;
				v_INVOICE_LINE_COMPONENT.INTERNAL_RATE := 0;
				v_INVOICE_LINE_COMPONENT.INTERNAL_AMOUNT := 0;
				v_INVOICE_LINE_COMPONENT.DETERMINANT_STATUS	:= RETAIL_DETERMINANTS.c_STATUS_MISSING;

				LOGS.LOG_DEBUG('No Results found for: '
					|| 'ACCOUNT=' || TEXT_UTIL.TO_CHAR_ENTITY(v_INPUT.ACCOUNT_ID,EC.ED_ACCOUNT)
					|| ',METER=' || TEXT_UTIL.TO_CHAR_ENTITY(v_INPUT.METER_ID,EC.ED_METER)
					|| ',SERVICE_POINT=' || TEXT_UTIL.TO_CHAR_ENTITY(v_INPUT.SERVICE_POINT_ID,EC.ED_SERVICE_POINT)
					|| ',PRODUCT=' || TEXT_UTIL.TO_CHAR_ENTITY(v_INPUT.PRODUCT_ID,EC.ED_PRODUCT)
					|| ',COMPONENT=' || TEXT_UTIL.TO_CHAR_ENTITY(v_INPUT.COMPONENT_ID,EC.ED_COMPONENT)
					|| ',PERIOD=' || TEXT_UTIL.TO_CHAR_ENTITY(v_INPUT.PERIOD_ID,EC.ED_PERIOD)
					|| ',BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_INPUT.BEGIN_DATE)
					|| ',END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_INPUT.END_DATE));
			END IF;

			INS_RETAIL_INVOICE_LINE_COMP(v_INVOICE_LINE_COMPONENT);

			-- Insert child results into the RETAIL_INVOICE_PRICING_RESULT table
			INSERT INTO RETAIL_INVOICE_PRICING_RESULT
				(RETAIL_INVOICE_LINE_COMP_ID,
				TAXED_PRODUCT_ID,
				TAXED_COMPONENT_ID,
				CHILD_COMPONENT_ID,
				PERIOD_ID,
				BAND_TIER_NUMBER,
				BEGIN_DATE,
				END_DATE,
				DATES_ARE_CUT,
				NUMBER_OF_INTERVALS,
				BASE_QUANTITY,
				FACTOR,
				QUANTITY,
				RATE,
				AMOUNT,
				FML_CHARGE_ID,
				DETERMINANT_STATUS)
			SELECT v_INVOICE_LINE_COMPONENT.RETAIL_INVOICE_LINE_COMP_ID,
				X.TAXED_PRODUCT_ID,
				X.TAXED_COMPONENT_ID,
				X.CHILD_COMPONENT_ID,
				X.PERIOD_ID,
				X.BAND_TIER_NUMBER,
				X.BEGIN_DATE,
				X.END_DATE,
				X.DATES_ARE_CUT,
				X.NUMBER_OF_INTERVALS,
				X.BASE_QUANTITY,
				X.FACTOR,
				X.QUANTITY,
				X.RATE,
				X.AMOUNT,
				X.FML_CHARGE_ID,
				X.DETERMINANT_STATUS
			FROM TABLE(CAST(v_PRICING_RESULT_TABLE AS PRICING_RESULT_TABLE)) X;

		END IF;

		-- Append result data to the collection
        v_INVOICE_COMPONENT_DATA_IDX := v_INPUT.PRODUCT_ID || '|' || v_INPUT.COMPONENT_ID || '|' || v_INPUT.PERIOD_ID;
        v_INVOICE_COMPONENT_DATA(v_INVOICE_COMPONENT_DATA_IDX).RETAIL_INVOICE_ID := p_RETAIL_INVOICE_ID;
        v_INVOICE_COMPONENT_DATA(v_INVOICE_COMPONENT_DATA_IDX).PRODUCT_ID := v_INPUT.PRODUCT_ID;
        v_INVOICE_COMPONENT_DATA(v_INVOICE_COMPONENT_DATA_IDX).COMPONENT_ID := v_INPUT.COMPONENT_ID;
        v_INVOICE_COMPONENT_DATA(v_INVOICE_COMPONENT_DATA_IDX).PERIOD_ID := v_INPUT.PERIOD_ID;
        v_INVOICE_COMPONENT_DATA(v_INVOICE_COMPONENT_DATA_IDX).TOTAL_INTERNAL_QUANTITY :=
        NVL(v_INVOICE_COMPONENT_DATA(v_INVOICE_COMPONENT_DATA_IDX).TOTAL_INTERNAL_QUANTITY,0)
        	+ v_INVOICE_LINE_COMPONENT.INTERNAL_QUANTITY;
        v_INVOICE_COMPONENT_DATA(v_INVOICE_COMPONENT_DATA_IDX).TOTAL_INTERNAL_AMOUNT :=
        NVL(v_INVOICE_COMPONENT_DATA(v_INVOICE_COMPONENT_DATA_IDX).TOTAL_INTERNAL_AMOUNT,0)
        	+ v_INVOICE_LINE_COMPONENT.INTERNAL_AMOUNT;
        v_INVOICE_COMPONENT_DATA(v_INVOICE_COMPONENT_DATA_IDX).TOTAL_EXTERNAL_QUANTITY :=
        NVL(v_INVOICE_COMPONENT_DATA(v_INVOICE_COMPONENT_DATA_IDX).TOTAL_EXTERNAL_QUANTITY,0)
        	+ v_INVOICE_LINE_COMPONENT.EXTERNAL_QUANTITY;
        v_INVOICE_COMPONENT_DATA(v_INVOICE_COMPONENT_DATA_IDX).TOTAL_EXTERNAL_AMOUNT :=
        NVL(v_INVOICE_COMPONENT_DATA(v_INVOICE_COMPONENT_DATA_IDX).TOTAL_EXTERNAL_AMOUNT,0)
        	+ v_INVOICE_LINE_COMPONENT.EXTERNAL_AMOUNT;

		v_LAST_ACCOUNT_ID := NVL(v_INPUT.ACCOUNT_ID,CONSTANTS.NOT_ASSIGNED);
		v_LAST_METER_ID := NVL(v_INPUT.METER_ID,CONSTANTS.NOT_ASSIGNED);
		v_LAST_SERVICE_POINT_ID := NVL(v_INPUT.SERVICE_POINT_ID,CONSTANTS.NOT_ASSIGNED);

        -- DON'T INCREMENT THE PROGRESS UNLESS WE HAVE OUR OWN RANGE
        IF p_INPUT_COUNT IS NOT NULL AND p_INPUT_COUNT > 0 THEN
		    LOGS.INCREMENT_PROCESS_PROGRESS();
        END IF;

        v_LAST_BEGIN_DATE := v_INPUT.BEGIN_DATE;

	END LOOP;

	-- Handle the SERVICE_CONSUMPTION records for the last Account
    IF v_LAST_ACCOUNT_ID <> CONSTANTS.NOT_ASSIGNED AND v_ACCT_ACCESSOR IS NOT NULL THEN
    	LOGS.LOG_DEBUG('Update SERVICE_CONSUMPTION for ' || TEXT_UTIL.TO_CHAR_DATE_RANGE(v_MIN_BEGIN_DATE,v_MAX_END_DATE));
    	BEGIN
    		v_SERVICE_IDS := v_ACCT_ACCESSOR.GET_ACTIVE_SERVICES(v_MIN_BEGIN_DATE,v_MAX_END_DATE);
    		LOGS.LOG_DEBUG('Found ' || v_SERVICE_IDS.COUNT() || ' Service IDs.');

            IF p_MARK_CONSUMPTION THEN
    		    PUT_BILL_PROCESSED_DATE(v_RETAIL_INVOICE.INVOICE_DATE,v_ACCOUNT_DATE_RANGES,p_SERVICE_CODE,v_SERVICE_IDS);
            END IF;
    	EXCEPTION
    		WHEN OTHERS THEN
    			ERRS.LOG_AND_CONTINUE('Could not update SERVICE_CONSUMPTION records for: ACCOUNT_ID=' || v_INPUT.ACCOUNT_ID || ',METER_ID=' || v_INPUT.METER_ID);
    	END;
    END IF;

	-- Insert rollup data into the RETAIL_INVOICE_COMPONENT table.
	IF p_RETAIN_INVOICE_LINES = FALSE THEN
        v_INVOICE_COMPONENT_DATA_IDX := v_INVOICE_COMPONENT_DATA.FIRST();
        WHILE v_INVOICE_COMPONENT_DATA.EXISTS(v_INVOICE_COMPONENT_DATA_IDX) LOOP
            INSERT INTO RETAIL_INVOICE_COMPONENT VALUES v_INVOICE_COMPONENT_DATA(v_INVOICE_COMPONENT_DATA_IDX);
            v_INVOICE_COMPONENT_DATA_IDX := v_INVOICE_COMPONENT_DATA.NEXT(v_INVOICE_COMPONENT_DATA_IDX);
        END LOOP;
    END IF;

    -- DON'T POP THE PROGRESS RANGE UNLESS INPUT_COUNT IS NOT NULL AND > 0 (I.E. WE'VE PUSHED OUR OWN
    -- PROGRESS RANGE)
    IF p_INPUT_COUNT IS NOT NULL AND p_INPUT_COUNT > 0 THEN
	    LOGS.POP_PROGRESS_RANGE();
    END IF;

	CLOSE p_RETAIL_SETTLEMENT_INPUTS;

    IF p_RETAIN_INVOICE_LINES = TRUE THEN
        UPD_RETAIL_INVOICE_COMPONENT(p_RETAIL_INVOICE_ID);
    END IF;

	GENERATE_DISPUTES(p_RETAIL_INVOICE_ID);

	LOGS.LOG_INFO('End RUN_RETAIL_SETTLEMENT for Invoice:' || p_RETAIL_INVOICE_ID);

EXCEPTION
	WHEN OTHERS THEN
		-- Handle cursor exceptions
		BEGIN
			IF p_RETAIL_SETTLEMENT_INPUTS%ISOPEN THEN CLOSE p_RETAIL_SETTLEMENT_INPUTS; END IF;
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE('Exception attempting to close p_RETAIL_SETTLEMENT_INPUTS');
		END;
		ERRS.LOG_AND_RAISE;
END RUN_RETAIL_SETTLEMENT;
----------------------------------------------------------------------------------------------------
END RETAIL_SETTLEMENT;
/
