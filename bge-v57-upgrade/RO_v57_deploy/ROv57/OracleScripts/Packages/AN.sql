CREATE OR REPLACE PACKAGE AN AS
--Revision $Revision: 1.47 $

-- Ancillary Services package.

FUNCTION WHAT_VERSION RETURN VARCHAR;

PROCEDURE ANCILLARY_SERVICE_NAMES
    (
	p_REQUEST_TYPE IN CHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE ANCILLARY_SERVICE_SUMMARY
    (
	p_REQUEST_TYPE IN CHAR,
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_DISPLAY_MODE IN VARCHAR,
	p_INCLUDE_STANDARD_OFFER IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);
--
PROCEDURE ANCILLARY_SERVICE_DETAIL
	(
	p_REQUEST_TYPE IN CHAR,
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_AGGREGATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_DISPLAY_MODE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE PJM_ECAPACITY_EXPORT
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PJM_ECAPACITY_EXPORT_XML
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE AGGREGATE_ANC_SVC_SCHEDULE
	(
	p_MODEL_ID IN NUMBER,
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TRACE_ON IN NUMBER
	);

PROCEDURE ANCILLARY_SVC_AREA_PEAKS
    (
	 p_REQUEST_TYPE IN VARCHAR,
	 p_ANCILLARY_SERVICE_ID IN NUMBER,
	 p_BEGIN_DATE IN DATE,
	 p_END_DATE IN DATE,
	 p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PUT_ANC_SERVICE_AREA_PEAK
	(
	p_REQUEST_TYPE IN VARCHAR,
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_AREA_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PEAK_DATE IN DATE,
	p_PEAK_TIME IN VARCHAR,
	p_PEAK_VAL IN NUMBER,
	p_OLD_AREA_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_OLD_PEAK_DATE IN DATE,
	p_OLD_PEAK_TIME IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE ANCILLARY_SVC_ALLOCATIONS
    (
	 p_REQUEST_TYPE IN VARCHAR,
	 p_ANCILLARY_SERVICE_ID IN NUMBER,
	 p_BEGIN_DATE IN DATE,
	 p_ALLOCATION_TOTAL OUT NUMBER,
	 p_STATUS OUT NUMBER,
	 p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE ALLOCATION_BEGIN_DATES
    (
	 p_STATUS OUT NUMBER,
	 p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PUT_ANC_SERVICE_ALLOCATION
	(
	p_REQUEST_TYPE IN VARCHAR,
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_ALLOCATION_NAME IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ALLOCATION_VAL IN NUMBER,
	p_DEFAULT_VAL IN NUMBER,
	p_OLD_ALLOCATION_NAME IN VARCHAR,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

g_TOTAL NUMBER(1) := -2;
g_BY_EDC NUMBER(1) := 1;
g_BY_ESP NUMBER(1) := 2;
g_BY_AGG NUMBER(1) := 3;
g_BY_PSE NUMBER(1) := 4;
g_BY_ACC NUMBER(1) := 5;
g_BY_SER NUMBER(1) := 6;
g_BY_MET NUMBER(1) := 7;
g_BY_POOL NUMBER(1) := 8;

g_AGGREGATE_TOTAL_ID NUMBER(9) := -100;
g_NON_AGGREGATE_TOTAL_ID NUMBER(9) := -101;

END AN;
/
CREATE OR REPLACE PACKAGE BODY AN AS
---------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
    RETURN '$Revision: 1.47 $';
END WHAT_VERSION;
----------------------------------------------------------------------------------------------------
FUNCTION MODULE_FOR_REQUEST_TYPE
	(
	p_REQUEST_TYPE IN CHAR
	)  RETURN VARCHAR IS

v_MODULE_NAME VARCHAR(16);

BEGIN

	SELECT DECODE(UPPER(SUBSTR(p_REQUEST_TYPE,1,1)),'F','FORECASTING',
			'B','SETTLEMENT',
			'U','SETTLEMENT',
			'FORECASTING') INTO v_MODULE_NAME FROM DUAL;

	RETURN v_MODULE_NAME;

END MODULE_FOR_REQUEST_TYPE;
---------------------------------------------------------------------------------------------------
PROCEDURE NULL_CURSOR
    (
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
		SELECT NULL FROM DUAL;

END NULL_CURSOR;
----------------------------------------------------------------------------------------------------
PROCEDURE ANCILLARY_SERVICE_NAMES
    (
	p_REQUEST_TYPE IN CHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of system loads defined in the database.

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT ANCILLARY_SERVICE_NAME, ANCILLARY_SERVICE_ID
		FROM ANCILLARY_SERVICE
		ORDER BY ANCILLARY_SERVICE_NAME;

END ANCILLARY_SERVICE_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE NON_AGGREGATE_ANC_SVC
	(
	p_MODE IN NUMBER,
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INCLUDE_STANDARD_OFFER IN NUMBER,
	p_SERVICE_TABLE IN OUT ANCILLARY_WORK_TABLE
	) AS

v_CUR_DATE DATE;

CURSOR c_NON_AGGREGATE IS
		SELECT TO_NUMBER(DECODE(p_MODE, g_BY_PSE, E.PSE_ID, g_BY_EDC, B.EDC_ID, g_BY_ESP, C.ESP_ID, g_BY_POOL, C.POOL_ID, g_NON_AGGREGATE_TOTAL_ID)) AS ENTITY_ID,
			v_CUR_DATE AS SERVICE_DATE,
			SUM(A.SERVICE_VAL) AS SERVICE_VAL
		FROM ACCOUNT_ANCILLARY_SERVICE A,
			ACCOUNT ACC,
			ACCOUNT_EDC B,
			ACCOUNT_ESP C,
			ENERGY_SERVICE_PROVIDER D,
			PSE_ESP E
		WHERE A.ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID
			AND A.BEGIN_DATE <= v_CUR_DATE
			AND NVL(A.END_DATE, v_CUR_DATE) >= v_CUR_DATE
			AND ACC.ACCOUNT_ID = A.ACCOUNT_ID
			AND ACC.IS_SUB_AGGREGATE = 0
			AND B.ACCOUNT_ID = A.ACCOUNT_ID
			AND B.EDC_ID = DECODE(p_EDC_ID, CONSTANTS.ALL_ID, B.EDC_ID, p_EDC_ID)
			AND B.BEGIN_DATE <= v_CUR_DATE
			AND NVL(B.END_DATE, v_CUR_DATE) >= v_CUR_DATE
			AND C.ACCOUNT_ID = A.ACCOUNT_ID
			AND (p_ESP_ID = CONSTANTS.ALL_ID OR C.ESP_ID = p_ESP_ID)
			AND (p_POOL_ID = CONSTANTS.ALL_ID OR C.POOL_ID = p_POOL_ID)
			AND C.BEGIN_DATE <= v_CUR_DATE
			AND NVL(C.END_DATE, v_CUR_DATE) >= v_CUR_DATE
			AND D.ESP_ID = C.ESP_ID
			AND NOT UPPER(SUBSTR(D.ESP_TYPE,1,1)) = DECODE(p_INCLUDE_STANDARD_OFFER,0,'S','@')
			AND E.ESP_ID = C.ESP_ID
			AND E.PSE_ID = DECODE(p_PSE_ID, CONSTANTS.ALL_ID, E.PSE_ID, p_PSE_ID)
			AND E.BEGIN_DATE <= v_CUR_DATE
			AND NVL(E.END_DATE, v_CUR_DATE) >= v_CUR_DATE
		GROUP BY DECODE(p_MODE, g_BY_PSE, E.PSE_ID, g_BY_EDC, B.EDC_ID, g_BY_ESP, C.ESP_ID, g_BY_POOL, C.POOL_ID, g_NON_AGGREGATE_TOTAL_ID), v_CUR_DATE

		UNION

		SELECT TO_NUMBER(DECODE(p_MODE, g_BY_PSE, G.PSE_ID, g_BY_EDC, D.EDC_ID, g_BY_ESP, E.ESP_ID, g_BY_POOL, E.POOL_ID, g_NON_AGGREGATE_TOTAL_ID)) AS ENTITY_ID,
			v_CUR_DATE AS SERVICE_DATE,
			SUM(A.SERVICE_VAL) AS SERVICE_VAL
		FROM METER_ANCILLARY_SERVICE A,
			SERVICE_LOCATION_METER B,
			ACCOUNT_SERVICE_LOCATION C,
			ACCOUNT ACC,
			ACCOUNT_EDC D,
			ACCOUNT_ESP E,
			ENERGY_SERVICE_PROVIDER F,
			PSE_ESP G
		WHERE A.ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID
			AND A.BEGIN_DATE <= v_CUR_DATE
			AND NVL(A.END_DATE, v_CUR_DATE) >= v_CUR_DATE
			AND B.METER_ID = A.METER_ID
			AND B.BEGIN_DATE <= v_CUR_DATE
			AND NVL(B.END_DATE, v_CUR_DATE) >= v_CUR_DATE
			AND C.SERVICE_LOCATION_ID = B.SERVICE_LOCATION_ID
			AND C.BEGIN_DATE <= v_CUR_DATE
			AND NVL(C.END_DATE, v_CUR_DATE) >= v_CUR_DATE
			AND ACC.ACCOUNT_ID = C.ACCOUNT_ID
			AND ACC.IS_SUB_AGGREGATE = 0
			AND D.ACCOUNT_ID = C.ACCOUNT_ID
			AND D.EDC_ID = DECODE(p_EDC_ID, CONSTANTS.ALL_ID, D.EDC_ID, p_EDC_ID)
			AND D.BEGIN_DATE <= v_CUR_DATE
			AND NVL(D.END_DATE, v_CUR_DATE) >= v_CUR_DATE
			AND E.ACCOUNT_ID = C.ACCOUNT_ID
			AND (p_ESP_ID = CONSTANTS.ALL_ID OR E.ESP_ID = p_ESP_ID)
			AND (p_POOL_ID = CONSTANTS.ALL_ID OR E.POOL_ID = p_POOL_ID)
			AND E.BEGIN_DATE <= v_CUR_DATE
			AND NVL(E.END_DATE, v_CUR_DATE) >= v_CUR_DATE
			AND F.ESP_ID = E.ESP_ID
			AND NOT UPPER(SUBSTR(F.ESP_TYPE,1,1)) = DECODE(p_INCLUDE_STANDARD_OFFER,0,'S','@')
			AND G.ESP_ID = E.ESP_ID
			AND G.PSE_ID = DECODE(p_PSE_ID, CONSTANTS.ALL_ID, G.PSE_ID, p_PSE_ID)
			AND G.BEGIN_DATE <= v_CUR_DATE
			AND NVL(G.END_DATE, v_CUR_DATE) >= v_CUR_DATE
		GROUP BY DECODE(p_MODE, g_BY_PSE, G.PSE_ID, g_BY_EDC, D.EDC_ID, g_BY_ESP, E.ESP_ID, g_BY_POOL, E.POOL_ID, g_NON_AGGREGATE_TOTAL_ID), v_CUR_DATE;

BEGIN

	v_CUR_DATE := TRUNC(p_BEGIN_DATE);
	WHILE v_CUR_DATE <= TRUNC(p_END_DATE) LOOP
		FOR v_NON_AGGREGATE IN c_NON_AGGREGATE LOOP
			p_SERVICE_TABLE.EXTEND;
			p_SERVICE_TABLE(p_SERVICE_TABLE.LAST) := ANCILLARY_WORK_TYPE(v_NON_AGGREGATE.ENTITY_ID, v_NON_AGGREGATE.SERVICE_DATE, v_NON_AGGREGATE.SERVICE_VAL, NULL);
		END LOOP;
		v_CUR_DATE := v_CUR_DATE + 1;
	END LOOP;

END NON_AGGREGATE_ANC_SVC;
---------------------------------------------------------------------------------------------------
PROCEDURE AGGREGATE_ANC_SVC
	(
	p_MODE IN NUMBER,
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_INCLUDE_STANDARD_OFFER IN NUMBER,
	p_SERVICE_TABLE IN OUT ANCILLARY_WORK_TABLE
	) AS

v_LOW_DATE DATE := LOW_DATE;

CURSOR c_VERSION_AGGREGATE IS
	SELECT DECODE(p_MODE, g_BY_PSE, E.PSE_ID, g_BY_EDC, C.EDC_ID, g_BY_ESP, A.ESP_ID, g_BY_POOL, A.POOL_ID, g_BY_AGG, A.ACCOUNT_ID, g_AGGREGATE_TOTAL_ID) AS ENTITY_ID,
		B.SERVICE_DATE AS SERVICE_DATE,
		SUM(B.SERVICE_VAL) AS SERVICE_VAL
	FROM AGGREGATE_ACCOUNT_ESP A,
		AGGREGATE_ANCILLARY_SERVICE B,
		ACCOUNT_EDC C,
		ENERGY_SERVICE_PROVIDER D,
		PSE_ESP E
	WHERE (p_ESP_ID = CONSTANTS.ALL_ID OR A.ESP_ID = p_ESP_ID)
		AND (p_POOL_ID = CONSTANTS.ALL_ID OR A.POOL_ID = p_POOL_ID)
		AND A.BEGIN_DATE <= p_END_DATE
		AND NVL(A.END_DATE, p_END_DATE) >= p_BEGIN_DATE
		AND B.AGGREGATE_ID = A.AGGREGATE_ID
		AND B.ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID
		AND B.SERVICE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
		AND B.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM AGGREGATE_ANCILLARY_SERVICE
			WHERE AGGREGATE_ID = B.AGGREGATE_ID
				AND ANCILLARY_SERVICE_ID = B.ANCILLARY_SERVICE_ID
				AND SERVICE_DATE = B.SERVICE_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE)
		AND C.ACCOUNT_ID = A.ACCOUNT_ID
		AND C.EDC_ID = DECODE(p_EDC_ID, CONSTANTS.ALL_ID, C.EDC_ID, p_EDC_ID)
		AND C.BEGIN_DATE <= p_END_DATE
		AND NVL(C.END_DATE, p_END_DATE) >= p_BEGIN_DATE
		AND D.ESP_ID = A.ESP_ID
		AND NOT UPPER(SUBSTR(D.ESP_TYPE,1,1)) = DECODE(p_INCLUDE_STANDARD_OFFER,0,'S','@')
		AND E.ESP_ID = A.ESP_ID
		AND E.PSE_ID = DECODE(p_PSE_ID, CONSTANTS.ALL_ID, E.PSE_ID, p_PSE_ID)
		AND E.BEGIN_DATE <= p_END_DATE
		AND NVL(E.END_DATE, p_END_DATE) >= p_BEGIN_DATE
	GROUP BY DECODE(p_MODE, g_BY_PSE, E.PSE_ID, g_BY_EDC, C.EDC_ID, g_BY_ESP, A.ESP_ID, g_BY_POOL, A.POOL_ID, g_BY_AGG, A.ACCOUNT_ID, g_AGGREGATE_TOTAL_ID), B.SERVICE_DATE;

CURSOR c_NON_VERSION_AGGREGATE IS
	SELECT DECODE(p_MODE, g_BY_PSE, E.PSE_ID, g_BY_EDC, C.EDC_ID, g_BY_ESP, A.ESP_ID, g_BY_POOL, A.POOL_ID, g_BY_AGG, A.ACCOUNT_ID, g_AGGREGATE_TOTAL_ID) AS ENTITY_ID,
		B.SERVICE_DATE AS SERVICE_DATE,
		SUM(B.SERVICE_VAL) AS SERVICE_VAL
	FROM AGGREGATE_ACCOUNT_ESP A,
		AGGREGATE_ANCILLARY_SERVICE B,
		ACCOUNT_EDC C,
		ENERGY_SERVICE_PROVIDER D,
		PSE_ESP E
	WHERE (p_ESP_ID = CONSTANTS.ALL_ID OR A.ESP_ID = p_ESP_ID)
		AND (p_POOL_ID = CONSTANTS.ALL_ID OR A.POOL_ID = p_POOL_ID)
		AND A.BEGIN_DATE <= p_END_DATE
		AND NVL(A.END_DATE, p_END_DATE) >= p_BEGIN_DATE
		AND B.AGGREGATE_ID = A.AGGREGATE_ID
		AND B.ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID
		AND B.SERVICE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
		AND B.AS_OF_DATE = v_LOW_DATE
		AND C.ACCOUNT_ID = A.ACCOUNT_ID
		AND C.EDC_ID = DECODE(p_EDC_ID, CONSTANTS.ALL_ID, C.EDC_ID, p_EDC_ID)
		AND C.BEGIN_DATE <= p_END_DATE
		AND NVL(C.END_DATE, p_END_DATE) >= p_BEGIN_DATE
		AND D.ESP_ID = A.ESP_ID
		AND NOT UPPER(SUBSTR(D.ESP_TYPE,1,1)) = DECODE(p_INCLUDE_STANDARD_OFFER,0,'S','@')
		AND E.ESP_ID = A.ESP_ID
		AND E.PSE_ID = DECODE(p_PSE_ID, CONSTANTS.ALL_ID, E.PSE_ID, p_PSE_ID)
		AND E.BEGIN_DATE <= p_END_DATE
		AND NVL(E.END_DATE, p_END_DATE) >= p_BEGIN_DATE
	GROUP BY DECODE(p_MODE, g_BY_PSE, E.PSE_ID, g_BY_EDC, C.EDC_ID, g_BY_ESP, A.ESP_ID, g_BY_POOL, A.POOL_ID, g_BY_AGG, A.ACCOUNT_ID, g_AGGREGATE_TOTAL_ID), B.SERVICE_DATE;

BEGIN

	IF GA.VERSION_AGGREGATE_ANCILARY_SVC THEN
		FOR v_AGGREGATE IN c_VERSION_AGGREGATE LOOP
			p_SERVICE_TABLE.EXTEND;
			p_SERVICE_TABLE(p_SERVICE_TABLE.LAST) := ANCILLARY_WORK_TYPE(v_AGGREGATE.ENTITY_ID, v_AGGREGATE.SERVICE_DATE, v_AGGREGATE.SERVICE_VAL, NULL);
		END LOOP;
	ELSE
		FOR v_AGGREGATE IN c_NON_VERSION_AGGREGATE LOOP
			p_SERVICE_TABLE.EXTEND;
			p_SERVICE_TABLE(p_SERVICE_TABLE.LAST) := ANCILLARY_WORK_TYPE(v_AGGREGATE.ENTITY_ID, v_AGGREGATE.SERVICE_DATE, v_AGGREGATE.SERVICE_VAL, NULL);
		END LOOP;
	END IF;

END AGGREGATE_ANC_SVC;
---------------------------------------------------------------------------------------------------
PROCEDURE ANCILLARY_SERVICE_SUMMARY
	(
	p_REQUEST_TYPE IN CHAR,
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_DISPLAY_MODE IN VARCHAR,
	p_INCLUDE_STANDARD_OFFER IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a record set string containing ANCILLARY SERVICE
-- account service counts by day over the specified time
-- interval and EDC/PSE/ESP relationship.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_ENTITY_MODE NUMBER(1);
v_SERVICE_TABLE ANCILLARY_WORK_TABLE := ANCILLARY_WORK_TABLE();

BEGIN


	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

   p_STATUS := GA.SUCCESS;
	v_BEGIN_DATE := TRUNC(p_BEGIN_DATE);
	v_END_DATE := GREATEST(TRUNC(p_END_DATE), v_BEGIN_DATE);
	SELECT DECODE(UPPER(SUBSTR(p_DISPLAY_MODE,1,3)), 'EDC', g_BY_EDC, 'ESP', g_BY_ESP, 'AGG', g_BY_AGG, 0) INTO v_ENTITY_MODE FROM DUAL;

-- GET EVERYTHING POSTED TO THE WORK TABLE.
-- Total non-aggregate ancillary service for all Entity.
	NON_AGGREGATE_ANC_SVC(g_TOTAL, p_ANCILLARY_SERVICE_ID, p_EDC_ID, CONSTANTS.ALL_ID, p_ESP_ID, CONSTANTS.ALL_ID, v_BEGIN_DATE, v_END_DATE, p_INCLUDE_STANDARD_OFFER, v_SERVICE_TABLE);

-- Total aggregate ancillary service for all Entity.
	AGGREGATE_ANC_SVC(g_TOTAL, p_ANCILLARY_SERVICE_ID, p_EDC_ID, CONSTANTS.ALL_ID, p_ESP_ID, CONSTANTS.ALL_ID, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, p_INCLUDE_STANDARD_OFFER, v_SERVICE_TABLE);

-- Total aggregate and non-aggregate ancillary services for each Entity.
	AGGREGATE_ANC_SVC(v_ENTITY_MODE, p_ANCILLARY_SERVICE_ID, p_EDC_ID, CONSTANTS.ALL_ID, p_ESP_ID, CONSTANTS.ALL_ID, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, p_INCLUDE_STANDARD_OFFER, v_SERVICE_TABLE);
	IF NOT v_ENTITY_MODE = g_BY_AGG THEN
		NON_AGGREGATE_ANC_SVC(v_ENTITY_MODE, p_ANCILLARY_SERVICE_ID, p_EDC_ID, CONSTANTS.ALL_ID, p_ESP_ID, CONSTANTS.ALL_ID, v_BEGIN_DATE, v_END_DATE, p_INCLUDE_STANDARD_OFFER, v_SERVICE_TABLE);
	END IF;


--RETURN THE VALUES NAME, ID, DATE, VALUE.
	IF v_ENTITY_MODE = g_BY_EDC THEN
		OPEN p_CURSOR FOR
			 SELECT DECODE(A.ENTITY_ID, g_NON_AGGREGATE_TOTAL_ID, 'Non-Aggregate Accounts', 'Aggregate Accounts') AS ENTITY_NAME,
			 		  A.ENTITY_ID AS ENTITY_ID,
					  FROM_CUT_AS_HED(A.SERVICE_DATE, LOCAL_TIME_ZONE, 'DD', 2) AS SERVICE_DATE,
					  SUM(A.SERVICE_VAL) AS SERVICE_VAL,
					  0 AS IS_NOT_HEADER
			 FROM TABLE(CAST(v_SERVICE_TABLE AS ANCILLARY_WORK_TABLE)) A
			 WHERE A.ENTITY_ID IN(g_NON_AGGREGATE_TOTAL_ID, g_AGGREGATE_TOTAL_ID)
			 GROUP BY DECODE(A.ENTITY_ID, g_NON_AGGREGATE_TOTAL_ID, 'Non-Aggregate Accounts', 'Aggregate Accounts'),
			 		 A.ENTITY_ID,
			 		 FROM_CUT_AS_HED(A.SERVICE_DATE, LOCAL_TIME_ZONE, 'DD', 2)

		 UNION
			 SELECT B.EDC_NAME AS ENTITY_NAME,
			 		  A.ENTITY_ID AS ENTITY_ID,
			 		  FROM_CUT_AS_HED(A.SERVICE_DATE, LOCAL_TIME_ZONE, 'DD', 2) AS SERVICE_DATE,
					  SUM(A.SERVICE_VAL) AS SERVICE_VAL,
					  1 AS IS_NOT_HEADER
			 FROM TABLE(CAST(v_SERVICE_TABLE AS ANCILLARY_WORK_TABLE)) A,
			 		ENERGY_DISTRIBUTION_COMPANY B
			 WHERE B.EDC_ID = A.ENTITY_ID
			 GROUP BY B.EDC_NAME,
			 		  A.ENTITY_ID,
			 		  FROM_CUT_AS_HED(A.SERVICE_DATE, LOCAL_TIME_ZONE, 'DD', 2)

			 ORDER BY 5,1,2,3;

	 ELSIF v_ENTITY_MODE = g_BY_ESP THEN
		OPEN p_CURSOR FOR
			 SELECT DECODE(A.ENTITY_ID, g_NON_AGGREGATE_TOTAL_ID, 'Non-Aggregate Accounts', 'Aggregate Accounts') AS ENTITY_NAME,
			 		  A.ENTITY_ID AS ENTITY_ID,
					  FROM_CUT_AS_HED(A.SERVICE_DATE, LOCAL_TIME_ZONE, 'DD', 2) AS SERVICE_DATE,
					  SUM(A.SERVICE_VAL) AS SERVICE_VAL,
					  0 AS IS_NOT_HEADER
			 FROM TABLE(CAST(v_SERVICE_TABLE AS ANCILLARY_WORK_TABLE)) A
			 WHERE A.ENTITY_ID IN(g_NON_AGGREGATE_TOTAL_ID, g_AGGREGATE_TOTAL_ID)
			 GROUP BY DECODE(A.ENTITY_ID, g_NON_AGGREGATE_TOTAL_ID, 'Non-Aggregate Accounts', 'Aggregate Accounts'),
			 		 A.ENTITY_ID,
			 		 FROM_CUT_AS_HED(A.SERVICE_DATE, LOCAL_TIME_ZONE, 'DD', 2)

		 UNION
			 SELECT B.ESP_NAME AS ENTITY_NAME,
			 		  A.ENTITY_ID AS ENTITY_ID,
			 		  FROM_CUT_AS_HED(A.SERVICE_DATE, LOCAL_TIME_ZONE, 'DD', 2) AS SERVICE_DATE,
					  SUM(A.SERVICE_VAL) AS SERVICE_VAL,
					  1 AS IS_NOT_HEADER
			 FROM TABLE(CAST(v_SERVICE_TABLE AS ANCILLARY_WORK_TABLE)) A,
			 		ENERGY_SERVICE_PROVIDER B
			 WHERE B.ESP_ID = A.ENTITY_ID
			 GROUP BY B.ESP_NAME,
			 		  A.ENTITY_ID,
			 		  FROM_CUT_AS_HED(A.SERVICE_DATE, LOCAL_TIME_ZONE, 'DD', 2)

			 ORDER BY 5,1,2,3;

	 ELSIF v_ENTITY_MODE = g_BY_AGG THEN
		OPEN p_CURSOR FOR
			 SELECT DECODE(A.ENTITY_ID, g_NON_AGGREGATE_TOTAL_ID, 'Non-Aggregate Accounts', 'Aggregate Accounts') AS ENTITY_NAME,
			 		  A.ENTITY_ID AS ENTITY_ID,
					  FROM_CUT_AS_HED(A.SERVICE_DATE, LOCAL_TIME_ZONE, 'DD', 2) AS SERVICE_DATE,
					  SUM(A.SERVICE_VAL) AS SERVICE_VAL,
					  0 AS IS_NOT_HEADER
			 FROM TABLE(CAST(v_SERVICE_TABLE AS ANCILLARY_WORK_TABLE)) A
			 WHERE A.ENTITY_ID IN(g_NON_AGGREGATE_TOTAL_ID, g_AGGREGATE_TOTAL_ID)
			 GROUP BY DECODE(A.ENTITY_ID, g_NON_AGGREGATE_TOTAL_ID, 'Non-Aggregate Accounts', 'Aggregate Accounts'),
			 		 A.ENTITY_ID,
			 		 FROM_CUT_AS_HED(A.SERVICE_DATE, LOCAL_TIME_ZONE, 'DD', 2)

		 UNION
			 SELECT B.ACCOUNT_NAME AS ENTITY_NAME,
			 		  A.ENTITY_ID AS ENTITY_ID,
			 		  FROM_CUT_AS_HED(A.SERVICE_DATE, LOCAL_TIME_ZONE, 'DD', 2) AS SERVICE_DATE,
					  SUM(A.SERVICE_VAL) AS SERVICE_VAL,
					  1 AS IS_NOT_HEADER
			 FROM TABLE(CAST(v_SERVICE_TABLE AS ANCILLARY_WORK_TABLE)) A,
			 		ACCOUNT B
			 WHERE B.ACCOUNT_ID = A.ENTITY_ID
			 GROUP BY B.ACCOUNT_NAME,
			 		  A.ENTITY_ID,
			 		  FROM_CUT_AS_HED(A.SERVICE_DATE, LOCAL_TIME_ZONE, 'DD', 2)

			 ORDER BY 5,1,2,3;
	  END IF;

END ANCILLARY_SERVICE_SUMMARY;
---------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNT_ANC_SVC
	(
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_AGGREGATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SERVICE_TABLE IN OUT ANCILLARY_WORK_TABLE
	) AS

v_CUR_DATE DATE;
CURSOR c_ACCOUNT IS
	SELECT v_CUR_DATE AS SERVICE_DATE,
		SERVICE_VAL
	FROM ACCOUNT_ANCILLARY_SERVICE AAS,
		ACCOUNT ACC
	WHERE AAS.ACCOUNT_ID = p_ACCOUNT_ID
		AND AAS.ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID
	   AND AAS.BEGIN_DATE <= v_CUR_DATE
		AND NVL(AAS.END_DATE, v_CUR_DATE) >= v_CUR_DATE
		AND ACC.ACCOUNT_ID = AAS.ACCOUNT_ID
		AND ACC.IS_SUB_AGGREGATE = 0;

CURSOR c_AGGREGATE IS
	SELECT SERVICE_DATE, SERVICE_VAL
	FROM AGGREGATE_ANCILLARY_SERVICE A
	WHERE A.AGGREGATE_ID = p_AGGREGATE_ID
		AND A.ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID
		AND A.SERVICE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
		AND A.AS_OF_DATE =
			(SELECT MAX(X.AS_OF_DATE)
			FROM AGGREGATE_ANCILLARY_SERVICE X
			WHERE X.AGGREGATE_ID = A.AGGREGATE_ID
				AND X.ANCILLARY_SERVICE_ID = A.ANCILLARY_SERVICE_ID
				AND X.SERVICE_DATE = A.SERVICE_DATE
				AND X.AS_OF_DATE <= p_AS_OF_DATE);

BEGIN

	IF p_AGGREGATE_ID > 0 THEN
		FOR v_AGGREGATE IN c_AGGREGATE LOOP
			 p_SERVICE_TABLE.EXTEND;
			 p_SERVICE_TABLE(p_SERVICE_TABLE.LAST) := ANCILLARY_WORK_TYPE(0, v_AGGREGATE.SERVICE_DATE, v_AGGREGATE.SERVICE_VAL, NULL);
		END LOOP;
	ELSE
		v_CUR_DATE := TRUNC(p_BEGIN_DATE);
		WHILE v_CUR_DATE <= TRUNC(p_END_DATE) LOOP
			FOR v_ACCOUNT IN c_ACCOUNT LOOP
				 p_SERVICE_TABLE.EXTEND;
				 p_SERVICE_TABLE(p_SERVICE_TABLE.LAST) := ANCILLARY_WORK_TYPE(0, v_ACCOUNT.SERVICE_DATE, v_ACCOUNT.SERVICE_VAL, NULL);
			END LOOP;
			v_CUR_DATE := v_CUR_DATE + 1;
		END LOOP;
	END IF;

	EXCEPTION
	    WHEN OTHERS THEN
		    ERRS.LOG_AND_RAISE();

END ACCOUNT_ANC_SVC;
---------------------------------------------------------------------------------------------------
PROCEDURE METER_ANC_SVC
	(
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SERVICE_TABLE IN OUT ANCILLARY_WORK_TABLE
	) AS

v_CUR_DATE DATE;
CURSOR c_METER IS
	SELECT v_CUR_DATE AS SERVICE_DATE,
		SERVICE_VAL
	FROM METER_ANCILLARY_SERVICE A,
		SERVICE_LOCATION_METER B,
		ACCOUNT_SERVICE_LOCATION C,
		ACCOUNT ACC
	WHERE A.METER_ID = p_METER_ID
		AND A.ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID
	    AND A.BEGIN_DATE <= v_CUR_DATE
		AND NVL(A.END_DATE, v_CUR_DATE) >= v_CUR_DATE
		AND B.METER_ID = A.METER_ID
		AND B.BEGIN_DATE <= v_CUR_DATE
		AND NVL(B.END_DATE, v_CUR_DATE) >= v_CUR_DATE
		AND C.SERVICE_LOCATION_ID = B.SERVICE_LOCATION_ID
		AND C.BEGIN_DATE <= v_CUR_DATE
		AND NVL(C.END_DATE, v_CUR_DATE) >= v_CUR_DATE
		AND ACC.ACCOUNT_ID = C.ACCOUNT_ID
		AND ACC.IS_SUB_AGGREGATE = 0;


BEGIN

	v_CUR_DATE := TRUNC(p_BEGIN_DATE);
	WHILE v_CUR_DATE <= TRUNC(p_END_DATE) LOOP
		FOR v_METER IN c_METER LOOP
			 p_SERVICE_TABLE.EXTEND;
			 p_SERVICE_TABLE(p_SERVICE_TABLE.LAST) := ANCILLARY_WORK_TYPE(0, v_METER.SERVICE_DATE, v_METER.SERVICE_VAL, NULL);
		END LOOP;
		v_CUR_DATE := v_CUR_DATE + 1;
	END LOOP;

	EXCEPTION
	    WHEN OTHERS THEN
		    ERRS.LOG_AND_RAISE();

END METER_ANC_SVC;
---------------------------------------------------------------------------------------------------
PROCEDURE SERVICE_LOCATION_ANC_SVC
	(
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SERVICE_TABLE IN OUT ANCILLARY_WORK_TABLE
	) AS

v_CUR_DATE DATE;
CURSOR c_SL IS
	SELECT v_CUR_DATE AS SERVICE_DATE,
		SUM(SERVICE_VAL) AS SERVICE_VAL
	FROM METER_ANCILLARY_SERVICE A,
		  SERVICE_LOCATION_METER B,
		  ACCOUNT_SERVICE_LOCATION C,
		ACCOUNT ACC
	WHERE B.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
		AND B.BEGIN_DATE <= v_CUR_DATE
		AND NVL(B.END_DATE, v_CUR_DATE) >= v_CUR_DATE
		AND A.METER_ID = B.METER_ID
		AND A.ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID
		AND A.BEGIN_DATE <= v_CUR_DATE
		AND NVL(A.END_DATE, v_CUR_DATE) >= v_CUR_DATE
		AND C.SERVICE_LOCATION_ID = B.SERVICE_LOCATION_ID
		AND C.BEGIN_DATE <= v_CUR_DATE
		AND NVL(C.END_DATE, v_CUR_DATE) >= v_CUR_DATE
		AND ACC.ACCOUNT_ID = C.ACCOUNT_ID
		AND ACC.IS_SUB_AGGREGATE = 0
	GROUP BY v_CUR_DATE;

BEGIN

	v_CUR_DATE := TRUNC(p_BEGIN_DATE);
	WHILE v_CUR_DATE <= TRUNC(p_END_DATE) LOOP
		FOR v_SL IN c_SL LOOP
			 p_SERVICE_TABLE.EXTEND;
			 p_SERVICE_TABLE(p_SERVICE_TABLE.LAST) := ANCILLARY_WORK_TYPE(0, v_SL.SERVICE_DATE, v_SL.SERVICE_VAL, NULL);
		END LOOP;
		v_CUR_DATE := v_CUR_DATE + 1;
	END LOOP;

	EXCEPTION
	    WHEN OTHERS THEN
		    ERRS.LOG_AND_RAISE();

END SERVICE_LOCATION_ANC_SVC;
---------------------------------------------------------------------------------------------------
PROCEDURE ANCILLARY_SERVICE_DETAIL
	(
	p_REQUEST_TYPE IN CHAR,
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_AGGREGATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_DISPLAY_MODE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE := TRUNC(p_BEGIN_DATE);
v_END_DATE DATE := TRUNC(p_END_DATE);
v_ENTITY_MODE NUMBER(1);
v_SERVICE_TABLE ANCILLARY_WORK_TABLE := ANCILLARY_WORK_TABLE();

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
   END IF;

    p_STATUS := GA.SUCCESS;


	SELECT DECODE(UPPER(SUBSTR(p_DISPLAY_MODE,1,3)), 'EDC', g_BY_EDC, 'ESP', g_BY_ESP, 'PSE', g_BY_PSE, 'POO', g_BY_POOL,
			 'AGG', g_BY_AGG, 'ACC', g_BY_ACC, 'SER', g_BY_SER, 'MET', g_BY_MET, 0) INTO v_ENTITY_MODE FROM DUAL;

	IF v_ENTITY_MODE IN (g_BY_EDC, g_BY_PSE, g_BY_ESP, g_BY_POOL) THEN
		AGGREGATE_ANC_SVC(v_ENTITY_MODE, p_ANCILLARY_SERVICE_ID, p_EDC_ID, p_PSE_ID, p_ESP_ID, p_POOL_ID, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, 1, v_SERVICE_TABLE);
		NON_AGGREGATE_ANC_SVC(v_ENTITY_MODE, p_ANCILLARY_SERVICE_ID, p_EDC_ID, p_PSE_ID, p_ESP_ID, p_POOL_ID, v_BEGIN_DATE, v_END_DATE, 1, v_SERVICE_TABLE);

	ELSIF v_ENTITY_MODE = g_BY_MET THEN
		METER_ANC_SVC(p_ANCILLARY_SERVICE_ID, p_METER_ID, v_BEGIN_DATE, v_END_DATE, v_SERVICE_TABLE);

	ELSIF v_ENTITY_MODE = g_BY_SER THEN
		SERVICE_LOCATION_ANC_SVC(p_ANCILLARY_SERVICE_ID, p_SERVICE_LOCATION_ID, v_BEGIN_DATE, v_END_DATE, v_SERVICE_TABLE);

	ELSIF v_ENTITY_MODE = g_BY_ACC THEN
		ACCOUNT_ANC_SVC(p_ANCILLARY_SERVICE_ID, p_ACCOUNT_ID, p_AGGREGATE_ID, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, v_SERVICE_TABLE);
	END IF;

	OPEN p_CURSOR FOR
		  SELECT FROM_CUT_AS_HED(A.SERVICE_DATE, LOCAL_TIME_ZONE, 'DD',2) AS SERVICE_DATE, SUM(A.SERVICE_VAL) AS SERVICE_VAL
		  FROM TABLE(CAST(v_SERVICE_TABLE AS ANCILLARY_WORK_TABLE)) A
		  GROUP BY FROM_CUT_AS_HED(A.SERVICE_DATE, LOCAL_TIME_ZONE, 'DD',2)
		  ORDER BY 1;

END ANCILLARY_SERVICE_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE PJM_ECAPACITY_EXPORT
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	)
	AS

	v_BEGIN_DATE DATE;
	v_END_DATE DATE;
	v_ICAP_ID NUMBER(9);
	v_TX_LOAD_ID NUMBER(9);
	v_WORK_ID NUMBER;
	v_ICAP_TABLE ANCILLARY_WORK_TABLE := ANCILLARY_WORK_TABLE();
	v_TX_LOAD_TABLE ANCILLARY_WORK_TABLE := ANCILLARY_WORK_TABLE();
	v_INCLUDE_STANDARD_OFFER NUMBER(1) := 0;
	v_PREV_PSE_ID NUMBER(9) := -1;
	v_EDC_NAME VARCHAR(32);
	v_IDX BINARY_INTEGER := 1;

	CURSOR c_ECAPACITY IS
		SELECT D.CONTRACT_NAME, A.ENTITY_ID AS PSE_ID,
		 	A.SERVICE_DATE AS SERVICE_DATE,
			SUM(A.SERVICE_VAL) AS ICAP_VAL,
			SUM(B.SERVICE_VAL) AS TX_LOAD_VAL
		FROM (SELECT ENTITY_ID, SERVICE_DATE, SUM(SERVICE_VAL) AS SERVICE_VAL
			  FROM TABLE(CAST(v_ICAP_TABLE AS ANCILLARY_WORK_TABLE))
			  GROUP BY ENTITY_ID, SERVICE_DATE) A,

			(SELECT ENTITY_ID, SERVICE_DATE, SUM(SERVICE_VAL) AS SERVICE_VAL
			FROM TABLE(CAST(v_TX_LOAD_TABLE AS ANCILLARY_WORK_TABLE))
			GROUP BY ENTITY_ID, SERVICE_DATE) B,

		   INTERCHANGE_CONTRACT C,
			TP_CONTRACT_NUMBER D
		WHERE A.SERVICE_DATE = B.SERVICE_DATE
			AND A.ENTITY_ID = B.ENTITY_ID
			AND C.BILLING_ENTITY_ID = A.ENTITY_ID
			AND C.BEGIN_DATE <= A.SERVICE_DATE
			AND NVL(C.END_DATE, HIGH_DATE) >= A.SERVICE_DATE
			AND D.CONTRACT_ID = C.CONTRACT_ID
			AND D.BEGIN_DATE <= A.SERVICE_DATE
			AND NVL(D.END_DATE, HIGH_DATE) >= A.SERVICE_DATE
			AND NOT UPPER(D.CONTRACT_NAME) = '<INACTIVE>'
		GROUP BY D.CONTRACT_NAME, A.ENTITY_ID, A.SERVICE_DATE
		ORDER BY 1,3;

	BEGIN

		  v_BEGIN_DATE := TRUNC(p_BEGIN_DATE);
		  v_END_DATE := GREATEST(TRUNC(p_END_DATE),v_BEGIN_DATE);
		  UT.GET_RTO_WORK_ID(v_WORK_ID);

		  SELECT EDC_NAME
		  INTO v_EDC_NAME
		  FROM ENERGY_DISTRIBUTION_COMPANY
		  WHERE EDC_ID = p_EDC_ID;

		  --GET ICAP AND TX ID'S HERE.
		  v_ICAP_ID := TO_NUMBER(VALUE_AT_KEY('ICAP_Ancillary_Service_Id'));
		  v_TX_LOAD_ID := TO_NUMBER(VALUE_AT_KEY('TX_LOAD_Ancillary_Service_Id'));

		  --GET TOTALS FOR EACH ENTITY.
		  NON_AGGREGATE_ANC_SVC(g_BY_PSE,v_ICAP_ID,p_EDC_ID,CONSTANTS.ALL_ID,p_ESP_ID,CONSTANTS.ALL_ID,v_BEGIN_DATE,v_END_DATE,0,v_ICAP_TABLE);
		  AGGREGATE_ANC_SVC(g_BY_PSE,v_ICAP_ID,p_EDC_ID,CONSTANTS.ALL_ID,p_ESP_ID,CONSTANTS.ALL_ID,v_BEGIN_DATE,v_END_DATE,p_AS_OF_DATE,0,v_ICAP_TABLE);

		  NON_AGGREGATE_ANC_SVC(g_BY_PSE,v_TX_LOAD_ID,p_EDC_ID,CONSTANTS.ALL_ID,p_ESP_ID,CONSTANTS.ALL_ID,v_BEGIN_DATE,v_END_DATE,0,v_TX_LOAD_TABLE);
		  AGGREGATE_ANC_SVC(g_BY_PSE,v_TX_LOAD_ID,p_EDC_ID,CONSTANTS.ALL_ID,p_ESP_ID,CONSTANTS.ALL_ID,v_BEGIN_DATE,v_END_DATE,p_AS_OF_DATE,0,v_TX_LOAD_TABLE);

		  --ORDER EVERYTHING INTO THE FORMAT ESP,DATE,ICAP TOTAL,TX LOAD TOTAL IN THE WORK TABLE.
		  FOR v_ECAPACITY IN c_ECAPACITY LOOP
		     IF v_PREV_PSE_ID <> v_ECAPACITY.PSE_ID THEN
		  	     UT.POST_RTO_WORK(v_WORK_ID, v_IDX, '*PEAKLD*');
			     UT.POST_RTO_WORK(v_WORK_ID, v_IDX + 1, v_EDC_NAME);
			     UT.POST_RTO_WORK(v_WORK_ID, v_IDX + 2, v_ECAPACITY.CONTRACT_NAME);
			     UT.POST_RTO_WORK(v_WORK_ID, v_IDX + 3, 'ZONE');
				  v_PREV_PSE_ID := v_ECAPACITY.PSE_ID;
			     v_IDX := v_IDX + 4;
			  END IF;
			  UT.POST_RTO_WORK(v_WORK_ID, v_IDX, TO_CHAR(v_ECAPACITY.SERVICE_DATE,'FMMM/DD/YYYY'));
			  UT.POST_RTO_WORK(v_WORK_ID, v_IDX + 1, LTRIM(TO_CHAR(ROUND((v_ECAPACITY.ICAP_VAL / 1000) + .04999,1),'999990.0')));
			  UT.POST_RTO_WORK(v_WORK_ID, v_IDX + 2, LTRIM(TO_CHAR(ROUND((v_ECAPACITY.TX_LOAD_VAL / 1000) + .04999,1),'999990.0')));
			  UT.POST_RTO_WORK(v_WORK_ID, v_IDX + 3, '-');
			  v_IDX := v_IDX + 4;
		  END LOOP;

		  --RETRIEVE VALUES FROM THE WORK TABLE
		  OPEN p_CURSOR FOR
		  		 SELECT WORK_DATA
				 FROM RTO_WORK
				 WHERE WORK_ID = v_WORK_ID
				 ORDER BY WORK_SEQ;

		  UT.PURGE_RTO_WORK(v_WORK_ID);

	EXCEPTION
	    WHEN OTHERS THEN
 	 	  	UT.PURGE_RTO_WORK(v_WORK_ID);
		    ERRS.LOG_AND_RAISE();

END PJM_ECAPACITY_EXPORT;
---------------------------------------------------------------------------------------------
PROCEDURE PJM_ECAPACITY_EXPORT_XML_FILL
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PSE_ID IN NUMBER,
	p_EDC_ALIAS IN VARCHAR,
	p_WORK_ID IN NUMBER,
	p_IDX IN OUT BINARY_INTEGER
	)
	AS

--FILLS GAPS BETWEEN DAYS WITH ZEROES IN THE XML IMPORT
	v_SERVICE_DATE DATE;
	v_CONTRACT_NAME VARCHAR(32);
	BEGIN


		  --ORDER EVERYTHING INTO THE XML FORMAT IN THE WORK TABLE.
		  v_SERVICE_DATE := p_BEGIN_DATE;
		  WHILE v_SERVICE_DATE <= p_END_DATE LOOP
		  	--FIND THE CURRENT CONTRACT NAME.
				SELECT D.CONTRACT_NAME
				INTO v_CONTRACT_NAME
				FROM INTERCHANGE_CONTRACT C,
					  TP_CONTRACT_NUMBER D
				WHERE C.BILLING_ENTITY_ID = p_PSE_ID
					AND C.BEGIN_DATE <= v_SERVICE_DATE
					AND NVL(C.END_DATE, HIGH_DATE) >= v_SERVICE_DATE
					AND D.CONTRACT_ID = C.CONTRACT_ID
					AND D.BEGIN_DATE <= v_SERVICE_DATE
					AND NVL(D.END_DATE, HIGH_DATE) >= v_SERVICE_DATE
					AND NOT UPPER(D.CONTRACT_NAME) = '<INACTIVE>';

		     UT.POST_RTO_WORK(p_WORK_ID, p_IDX, '     <load_contribution>');
			  UT.POST_RTO_WORK(p_WORK_ID, p_IDX + 1, '          <load_type>Peak Load</load_type>');
			  UT.POST_RTO_WORK(p_WORK_ID, p_IDX + 2, '          <zone>' || p_EDC_ALIAS || '</zone>');
			  UT.POST_RTO_WORK(p_WORK_ID, p_IDX + 3, '          <area>' || p_EDC_ALIAS || '</area>');
			  UT.POST_RTO_WORK(p_WORK_ID, p_IDX + 4, '          <lse>'  || v_CONTRACT_NAME  || '</lse>');
			  UT.POST_RTO_WORK(p_WORK_ID, p_IDX + 5, '          <mw_amount>0.0</mw_amount>');
			  UT.POST_RTO_WORK(p_WORK_ID, p_IDX + 6, '          <effective_date>'  || TO_CHAR(v_SERVICE_DATE,'FMMM/DD/YYYY')  || '</effective_date>');
		     UT.POST_RTO_WORK(p_WORK_ID, p_IDX + 7, '     </load_contribution>');
			  p_IDX := p_IDX + 8;

		     UT.POST_RTO_WORK(p_WORK_ID, p_IDX, '     <load_contribution>');
			  UT.POST_RTO_WORK(p_WORK_ID, p_IDX + 1, '          <load_type>Network Service</load_type>');
			  UT.POST_RTO_WORK(p_WORK_ID, p_IDX + 2, '          <zone>' || p_EDC_ALIAS || '</zone>');
			  UT.POST_RTO_WORK(p_WORK_ID, p_IDX + 3, '          <area>' || p_EDC_ALIAS || '</area>');
			  UT.POST_RTO_WORK(p_WORK_ID, p_IDX + 4, '          <lse>'  || v_CONTRACT_NAME  || '</lse>');
			  UT.POST_RTO_WORK(p_WORK_ID, p_IDX + 5, '          <mw_amount>0.0</mw_amount>');
			  UT.POST_RTO_WORK(p_WORK_ID, p_IDX + 6, '          <effective_date>'  || TO_CHAR(v_SERVICE_DATE,'FMMM/DD/YYYY')  || '</effective_date>');
		     UT.POST_RTO_WORK(p_WORK_ID, p_IDX + 7, '     </load_contribution>');
			  p_IDX := p_IDX + 8;
			  v_SERVICE_DATE := v_SERVICE_DATE + 1;
		  END LOOP;

END PJM_ECAPACITY_EXPORT_XML_FILL;
---------------------------------------------------------------------------------------------
PROCEDURE PJM_ECAPACITY_EXPORT_XML
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	)
	AS

	v_BEGIN_DATE DATE;
	v_END_DATE DATE;
	v_ICAP_ID NUMBER(9);
	v_TX_LOAD_ID NUMBER(9);
	v_WORK_ID NUMBER;
	v_ICAP_TABLE ANCILLARY_WORK_TABLE := ANCILLARY_WORK_TABLE();
	v_TX_LOAD_TABLE ANCILLARY_WORK_TABLE := ANCILLARY_WORK_TABLE();
	v_INCLUDE_STANDARD_OFFER NUMBER(1) := 1;
	v_PREV_PSE_ID NUMBER(9) := -1;
	v_EDC_ALIAS VARCHAR(32);
	v_IDX BINARY_INTEGER := 1;
	v_PREV_DATE DATE;

	CURSOR c_ECAPACITY IS
		SELECT D.CONTRACT_NAME, A.ENTITY_ID AS PSE_ID,
		 	A.SERVICE_DATE AS SERVICE_DATE,
			SUM(A.SERVICE_VAL) AS ICAP_VAL,
			SUM(B.SERVICE_VAL) AS TX_LOAD_VAL
		FROM (SELECT ENTITY_ID, SERVICE_DATE, SUM(SERVICE_VAL) AS SERVICE_VAL
			  FROM TABLE(CAST(v_ICAP_TABLE AS ANCILLARY_WORK_TABLE))
			  GROUP BY ENTITY_ID, SERVICE_DATE) A,

			(SELECT ENTITY_ID, SERVICE_DATE, SUM(SERVICE_VAL) AS SERVICE_VAL
			FROM TABLE(CAST(v_TX_LOAD_TABLE AS ANCILLARY_WORK_TABLE))
			GROUP BY ENTITY_ID, SERVICE_DATE) B,

		   INTERCHANGE_CONTRACT C,
			TP_CONTRACT_NUMBER D
		WHERE A.SERVICE_DATE = B.SERVICE_DATE
			AND A.ENTITY_ID = B.ENTITY_ID
			AND C.BILLING_ENTITY_ID = A.ENTITY_ID
			AND C.BEGIN_DATE <= A.SERVICE_DATE
			AND NVL(C.END_DATE, HIGH_DATE) >= A.SERVICE_DATE
			AND D.CONTRACT_ID = C.CONTRACT_ID
			AND D.BEGIN_DATE <= A.SERVICE_DATE
			AND NVL(D.END_DATE, HIGH_DATE) >= A.SERVICE_DATE
			AND NOT UPPER(D.CONTRACT_NAME) = '<INACTIVE>'
		GROUP BY D.CONTRACT_NAME, A.ENTITY_ID, A.SERVICE_DATE
		ORDER BY A.ENTITY_ID, A.SERVICE_DATE;

	BEGIN
		  v_BEGIN_DATE := TRUNC(p_BEGIN_DATE);
		  v_END_DATE := GREATEST(TRUNC(p_END_DATE),v_BEGIN_DATE);
		  UT.GET_RTO_WORK_ID(v_WORK_ID);

		  SELECT EDC_ALIAS
		  INTO v_EDC_ALIAS
		  FROM ENERGY_DISTRIBUTION_COMPANY
		  WHERE EDC_ID = p_EDC_ID;

		  --GET ICAP AND TX ID'S HERE.
		  v_ICAP_ID := TO_NUMBER(VALUE_AT_KEY('ICAP_Ancillary_Service_Id'));
		  v_TX_LOAD_ID := TO_NUMBER(VALUE_AT_KEY('TX_LOAD_Ancillary_Service_Id'));

		  --GET TOTALS FOR EACH ENTITY.
		  NON_AGGREGATE_ANC_SVC(g_BY_PSE,v_ICAP_ID,p_EDC_ID,CONSTANTS.ALL_ID,p_ESP_ID,CONSTANTS.ALL_ID,v_BEGIN_DATE,v_END_DATE,v_INCLUDE_STANDARD_OFFER,v_ICAP_TABLE);
		  AGGREGATE_ANC_SVC(g_BY_PSE,v_ICAP_ID,p_EDC_ID,CONSTANTS.ALL_ID,p_ESP_ID,CONSTANTS.ALL_ID,v_BEGIN_DATE,v_END_DATE,p_AS_OF_DATE,v_INCLUDE_STANDARD_OFFER,v_ICAP_TABLE);

		  NON_AGGREGATE_ANC_SVC(g_BY_PSE,v_TX_LOAD_ID,p_EDC_ID,CONSTANTS.ALL_ID,p_ESP_ID,CONSTANTS.ALL_ID,v_BEGIN_DATE,v_END_DATE,v_INCLUDE_STANDARD_OFFER,v_TX_LOAD_TABLE);
		  AGGREGATE_ANC_SVC(g_BY_PSE,v_TX_LOAD_ID,p_EDC_ID,CONSTANTS.ALL_ID,p_ESP_ID,CONSTANTS.ALL_ID,v_BEGIN_DATE,v_END_DATE,p_AS_OF_DATE,v_INCLUDE_STANDARD_OFFER,v_TX_LOAD_TABLE);

		  --ORDER EVERYTHING INTO THE XML FORMAT IN THE WORK TABLE.
		  UT.POST_RTO_WORK(v_WORK_ID, v_IDX, '<?xml version="1.0"?>');
		  UT.POST_RTO_WORK(v_WORK_ID, v_IDX + 1, '<!DOCTYPE ecapacity SYSTEM "ecapacity.dtd">');
		  UT.POST_RTO_WORK(v_WORK_ID, v_IDX + 2, '<ecapacity xmlns="http://www.pjm.com/ecapacity">');
		  v_IDX := v_IDX + 3;
		  FOR v_ECAPACITY IN c_ECAPACITY LOOP
		  	  --FILL IN ZEROES FOR MISSING DAYS
		  	  IF (v_PREV_PSE_ID = v_ECAPACITY.PSE_ID) AND (v_PREV_DATE < v_ECAPACITY.SERVICE_DATE - 1) THEN
			  	  PJM_ECAPACITY_EXPORT_XML_FILL(v_PREV_DATE + 1, v_ECAPACITY.SERVICE_DATE - 1, v_PREV_PSE_ID, v_EDC_ALIAS, v_WORK_ID, v_IDX);
			  ELSIF (NOT v_PREV_PSE_ID = v_ECAPACITY.PSE_ID) THEN
			  	  --FILL IN AT END OF PREVIOUS PSE_ID.
			  	  IF v_PREV_DATE < v_END_DATE THEN
				  	  PJM_ECAPACITY_EXPORT_XML_FILL(v_PREV_DATE + 1, v_END_DATE, v_PREV_PSE_ID, v_EDC_ALIAS, v_WORK_ID, v_IDX);
				  END IF;
   			  --FILL IN AT BEGINNING OF NEW PSE_ID.
				  IF v_ECAPACITY.SERVICE_DATE > v_BEGIN_DATE THEN
				  	  PJM_ECAPACITY_EXPORT_XML_FILL(v_BEGIN_DATE, v_ECAPACITY.SERVICE_DATE - 1, v_ECAPACITY.PSE_ID, v_EDC_ALIAS, v_WORK_ID, v_IDX);
				  END IF;
			  END IF;

			  v_PREV_PSE_ID := v_ECAPACITY.PSE_ID;
			  v_PREV_DATE := v_ECAPACITY.SERVICE_DATE;
		     UT.POST_RTO_WORK(v_WORK_ID, v_IDX, '     <load_contribution>');
			  UT.POST_RTO_WORK(v_WORK_ID, v_IDX + 1, '          <load_type>Peak Load</load_type>');
			  UT.POST_RTO_WORK(v_WORK_ID, v_IDX + 2, '          <zone>' || v_EDC_ALIAS || '</zone>');
			  UT.POST_RTO_WORK(v_WORK_ID, v_IDX + 3, '          <area>' || v_EDC_ALIAS || '</area>');
			  UT.POST_RTO_WORK(v_WORK_ID, v_IDX + 4, '          <lse>'  || v_ECAPACITY.CONTRACT_NAME  || '</lse>');
			  UT.POST_RTO_WORK(v_WORK_ID, v_IDX + 5, '          <mw_amount>'  || LTRIM(TO_CHAR(ROUND((v_ECAPACITY.ICAP_VAL / 1000) + .04999,1),'999990.0'))  || '</mw_amount>');
			  UT.POST_RTO_WORK(v_WORK_ID, v_IDX + 6, '          <effective_date>'  || TO_CHAR(v_ECAPACITY.SERVICE_DATE,'FMMM/DD/YYYY')  || '</effective_date>');
		     UT.POST_RTO_WORK(v_WORK_ID, v_IDX + 7, '     </load_contribution>');
			  v_IDX := v_IDX + 8;

		     UT.POST_RTO_WORK(v_WORK_ID, v_IDX, '     <load_contribution>');
			  UT.POST_RTO_WORK(v_WORK_ID, v_IDX + 1, '          <load_type>Network Service</load_type>');
			  UT.POST_RTO_WORK(v_WORK_ID, v_IDX + 2, '          <zone>' || v_EDC_ALIAS || '</zone>');
			  UT.POST_RTO_WORK(v_WORK_ID, v_IDX + 3, '          <area>' || v_EDC_ALIAS || '</area>');
			  UT.POST_RTO_WORK(v_WORK_ID, v_IDX + 4, '          <lse>'  || v_ECAPACITY.CONTRACT_NAME  || '</lse>');
			  UT.POST_RTO_WORK(v_WORK_ID, v_IDX + 5, '          <mw_amount>'  || LTRIM(TO_CHAR(ROUND((v_ECAPACITY.TX_LOAD_VAL / 1000) + .04999,1),'999990.0'))  || '</mw_amount>');
			  UT.POST_RTO_WORK(v_WORK_ID, v_IDX + 6, '          <effective_date>'  || TO_CHAR(v_ECAPACITY.SERVICE_DATE,'FMMM/DD/YYYY')  || '</effective_date>');
		     UT.POST_RTO_WORK(v_WORK_ID, v_IDX + 7, '     </load_contribution>');
			  v_IDX := v_IDX + 8;
		  END LOOP;

		  --FILL IN AT END OF FILE
		  IF v_PREV_DATE < v_END_DATE THEN
			  	  PJM_ECAPACITY_EXPORT_XML_FILL(v_PREV_DATE + 1, v_END_DATE, v_PREV_PSE_ID, v_EDC_ALIAS, v_WORK_ID, v_IDX);
		  END IF;

		  --FINISH UP
		  UT.POST_RTO_WORK(v_WORK_ID, v_IDX, '</ecapacity>');

		  --RETRIEVE VALUES FROM THE WORK TABLE
		  OPEN p_CURSOR FOR
		  		 SELECT WORK_DATA
				 FROM RTO_WORK
				 WHERE WORK_ID = v_WORK_ID
				 ORDER BY WORK_SEQ;

		  UT.PURGE_RTO_WORK(v_WORK_ID);

	EXCEPTION
	    WHEN OTHERS THEN
       		UT.PURGE_RTO_WORK(v_WORK_ID);
		    ERRS.LOG_AND_RAISE();

END PJM_ECAPACITY_EXPORT_XML;
---------------------------------------------------------------------------------------------
FUNCTION GET_TRANSACTION_NAME
	(
	p_ACCOUNT_SERVICE_ID IN NUMBER,
	p_SUFFIX IN VARCHAR
	) RETURN VARCHAR IS

-- Answer the Load Obligation Name

v_TRANSACTION_NAME VARCHAR(128) := '';

BEGIN

	SELECT ACCOUNT_NAME || ' ' || p_SUFFIX
	INTO v_TRANSACTION_NAME
	FROM ACCOUNT_SERVICE A, ACCOUNT B
	WHERE A.ACCOUNT_SERVICE_ID = p_ACCOUNT_SERVICE_ID
		AND B.ACCOUNT_ID = A.ACCOUNT_ID;

	RETURN SUBSTR(v_TRANSACTION_NAME, 1, LEAST(LENGTH(v_TRANSACTION_NAME), 64));

END GET_TRANSACTION_NAME;
----------------------------------------------------------------------------------------------------
FUNCTION GET_TRANSACTION_ID
    (
	p_MODEL_ID IN NUMBER,
	p_TRANSACTION_NAME IN VARCHAR,
	p_TRANSACTION_TYPE IN VARCHAR,
	p_ACCOUNT_SERVICE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	) RETURN NUMBER IS

-- Answer the transaction Id for the specified transaction.

v_COMMODITY_NAME VARCHAR(32);
v_COMMODITY_TYPE VARCHAR(16);
v_COMMODITY_UNIT VARCHAR(16);
v_COMMODITY_ID NUMBER(9);
v_TRANSACTION_INTERVAL VARCHAR(16);
v_TRANSACTION_ID NUMBER(9);
v_PROVIDER_SERVICE_ID NUMBER(9);
v_POOL_ID NUMBER(9);
v_SCHEDULE_GROUP_ID NUMBER(9);
v_SERVICE_POINT_ID NUMBER(9);
v_SERVICE_ZONE_ID NUMBER(9);
v_SC_ID NUMBER(9);
v_ACCOUNT_SERVICE ACCOUNT_SERVICE%ROWTYPE;
v_PROVIDER_SERVICE PROVIDER_SERVICE%ROWTYPE;

BEGIN

	ID.ID_FOR_TRANSACTION(p_TRANSACTION_NAME, p_TRANSACTION_TYPE, FALSE, v_TRANSACTION_ID);

	IF v_TRANSACTION_ID = GA.NO_DATA_FOUND THEN

	    ID.ID_FOR_TRANSACTION(p_TRANSACTION_NAME, p_TRANSACTION_TYPE, TRUE, v_TRANSACTION_ID);

		ID.ID_FOR_COMMODITY(v_COMMODITY_NAME, FALSE, v_COMMODITY_ID);

		IF v_COMMODITY_ID = GA.NO_DATA_FOUND THEN
			SELECT DECODE(p_MODEL_ID, GA.GAS_MODEL, 'Gas', 'Retail Load') INTO v_COMMODITY_NAME FROM DUAL;
			SELECT DECODE(p_MODEL_ID, GA.GAS_MODEL, 'Gas', 'Energy') INTO v_COMMODITY_TYPE FROM DUAL;
			SELECT DECODE(p_MODEL_ID, GA.GAS_MODEL, 'DT', 'MWH') INTO v_COMMODITY_UNIT FROM DUAL;
		    ID.ID_FOR_COMMODITY(v_COMMODITY_NAME, TRUE, v_COMMODITY_ID);
			UPDATE IT_COMMODITY SET
				COMMODITY_TYPE = v_COMMODITY_TYPE,
				COMMODITY_UNIT = v_COMMODITY_UNIT
			WHERE COMMODITY_ID = v_COMMODITY_ID;
		END IF;

		SELECT DECODE(p_MODEL_ID, GA.GAS_MODEL, 'Day', 'Hour') INTO v_TRANSACTION_INTERVAL FROM DUAL;

		v_ACCOUNT_SERVICE := CS.GET_ACCOUNT_SERVICE(p_ACCOUNT_SERVICE_ID);
		CS.GET_PROVIDER_SERVICE_ID(v_ACCOUNT_SERVICE.ACCOUNT_ID, v_ACCOUNT_SERVICE.AGGREGATE_ID, p_BEGIN_DATE, v_PROVIDER_SERVICE_ID);
		v_PROVIDER_SERVICE := CS.GET_PROVIDER_SERVICE(v_PROVIDER_SERVICE_ID);
		v_POOL_ID := CS.GET_POOL_OF_RECORD(v_ACCOUNT_SERVICE.ACCOUNT_ID, v_PROVIDER_SERVICE.ESP_ID, p_BEGIN_DATE, v_ACCOUNT_SERVICE.AGGREGATE_ID > 0);
		v_SCHEDULE_GROUP_ID := CS.GET_SCHEDULE_GROUP_ID(v_ACCOUNT_SERVICE.ACCOUNT_ID, v_ACCOUNT_SERVICE.METER_ID, p_BEGIN_DATE);
		v_SC_ID := CS.GET_EDC_SC_OF_RECORD(v_PROVIDER_SERVICE.EDC_ID);
		v_SERVICE_POINT_ID := CS.GET_SERVICE_POINT_ID(v_ACCOUNT_SERVICE.ACCOUNT_ID, v_ACCOUNT_SERVICE.SERVICE_LOCATION_ID, p_BEGIN_DATE);
		v_SERVICE_ZONE_ID := CS.GET_SERVICE_ZONE_ID(v_SERVICE_POINT_ID);

		UPDATE INTERCHANGE_TRANSACTION SET
		    BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		    END_DATE = TRUNC(p_END_DATE),
			TRANSACTION_INTERVAL = v_TRANSACTION_INTERVAL,
			CONTRACT_ID = CONSTANTS.NOT_ASSIGNED,
			COMMODITY_ID = v_COMMODITY_ID,
			PURCHASER_ID = v_PROVIDER_SERVICE.PSE_ID,
			SELLER_ID = v_PROVIDER_SERVICE.PSE_ID,
			POR_ID = v_SERVICE_POINT_ID,
			POD_ID = v_SERVICE_POINT_ID,
			ZOR_ID = v_SERVICE_ZONE_ID,
			ZOD_ID = v_SERVICE_ZONE_ID,
			SC_ID = v_SC_ID,
			PSE_ID = v_PROVIDER_SERVICE.PSE_ID,
			ESP_ID = v_PROVIDER_SERVICE.ESP_ID,
			POOL_ID = v_POOL_ID,
			IS_EXPORT_SCHEDULE = 1,
			SCHEDULE_GROUP_ID = v_SCHEDULE_GROUP_ID,
			ENTRY_DATE = SYSDATE
		WHERE TRANSACTION_ID = v_TRANSACTION_ID;
	ELSE
		UPDATE INTERCHANGE_TRANSACTION SET
		    BEGIN_DATE = TRUNC(p_BEGIN_DATE),
			ENTRY_DATE = SYSDATE
		WHERE TRANSACTION_ID = v_TRANSACTION_ID
		    AND TRUNC(p_BEGIN_DATE) < BEGIN_DATE;
		UPDATE INTERCHANGE_TRANSACTION SET
		    END_DATE = TRUNC(p_END_DATE),
			ENTRY_DATE = SYSDATE
		WHERE TRANSACTION_ID = v_TRANSACTION_ID
		    AND TRUNC(p_END_DATE) > END_DATE;
	END IF;

	RETURN v_TRANSACTION_ID;

END GET_TRANSACTION_ID;
----------------------------------------------------------------------------------------------------
PROCEDURE SAVE_IT_SCHEDULE
	(
	p_MODEL_ID IN NUMBER,
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE DATE,
	p_AS_OF_DATE IN DATE,
	p_SCHEDULE_DATE IN GA.DATE_TABLE,
	p_SCHEDULE_QTY IN GA.FLOAT_TABLE
	) AS

-- Note: p_BEGIN_DATE and p_END_DATE are CUT Dates.

v_INDEX BINARY_INTEGER;

BEGIN

	DELETE IT_SCHEDULE
	WHERE TRANSACTION_ID = p_TRANSACTION_ID
		AND SCHEDULE_TYPE = p_SCHEDULE_TYPE
		AND SCHEDULE_STATE = p_SCHEDULE_STATE
		AND SCHEDULE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
		AND AS_OF_DATE = p_AS_OF_DATE;

	FORALL v_INDEX IN 1..p_SCHEDULE_DATE.COUNT
		INSERT INTO IT_SCHEDULE (TRANSACTION_ID, SCHEDULE_TYPE, SCHEDULE_STATE, SCHEDULE_DATE, AS_OF_DATE, AMOUNT)
		VALUES (p_TRANSACTION_ID, p_SCHEDULE_TYPE, p_SCHEDULE_STATE, p_SCHEDULE_DATE(v_INDEX), p_AS_OF_DATE, p_SCHEDULE_QTY(v_INDEX));

END SAVE_IT_SCHEDULE;
----------------------------------------------------------------------------------------------------
PROCEDURE STORE_TRANSACTION_SCHEDULE
	(
	p_MODEL_ID IN NUMBER,
	p_ACCOUNT_SERVICE_ID IN NUMBER,
	p_ANCILLARY_WORK IN ANCILLARY_WORK_TABLE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	) AS

v_TRANSACTION_NAME VARCHAR(64) := GET_TRANSACTION_NAME(p_ACCOUNT_SERVICE_ID, '(Nom)');
v_TRANSACTION_TYPE VARCHAR(16) := 'Nomination';
v_TRANSACTION_ID NUMBER(9);
v_INDEX BINARY_INTEGER;
v_SCHEDULE_DATE GA.DATE_TABLE;
v_SCHEDULE_QTY GA.FLOAT_TABLE;

BEGIN

	v_TRANSACTION_ID := GET_TRANSACTION_ID(p_MODEL_ID, v_TRANSACTION_NAME, v_TRANSACTION_TYPE, p_ACCOUNT_SERVICE_ID, p_BEGIN_DATE, p_END_DATE);

	IF p_ANCILLARY_WORK.COUNT > 0 THEN
		v_INDEX := p_ANCILLARY_WORK.FIRST;
		WHILE v_INDEX <= p_ANCILLARY_WORK.LAST LOOP
			v_SCHEDULE_DATE(v_SCHEDULE_DATE.COUNT + 1) := p_ANCILLARY_WORK(v_INDEX).SERVICE_DATE;
			v_SCHEDULE_QTY(v_SCHEDULE_QTY.COUNT + 1) := p_ANCILLARY_WORK(v_INDEX).SERVICE_VAL * p_ANCILLARY_WORK(v_INDEX).SERVICE_ACCOUNTS;
			v_INDEX := p_ANCILLARY_WORK.NEXT(v_INDEX);
		END LOOP;
	END IF;

END STORE_TRANSACTION_SCHEDULE;
----------------------------------------------------------------------------------------------------
PROCEDURE TRACE_ANCILLARY_WORK
	(
	p_ANCILLARY_WORK IN ANCILLARY_WORK_TABLE
	) AS

v_INDEX BINARY_INTEGER;

BEGIN

	LOGS.LOG_DEBUG('TRACE_ANCILLARY_WORK');

	IF p_ANCILLARY_WORK.COUNT > 0 THEN
		v_INDEX := p_ANCILLARY_WORK.FIRST;
		WHILE v_INDEX <= p_ANCILLARY_WORK.LAST LOOP
			LOGS.LOG_DEBUG(TO_CHAR(p_ANCILLARY_WORK(v_INDEX).ENTITY_ID) || ',' || p_ANCILLARY_WORK(v_INDEX).SERVICE_DATE || ',' || p_ANCILLARY_WORK(v_INDEX).SERVICE_VAL || ',' || p_ANCILLARY_WORK(v_INDEX).SERVICE_ACCOUNTS || '@' || TO_CHAR(v_INDEX));
			v_INDEX := p_ANCILLARY_WORK.NEXT(v_INDEX);
		END LOOP;
	END IF;

END TRACE_ANCILLARY_WORK;
----------------------------------------------------------------------------------------------------
FUNCTION GET_ACCOUNT_SERVICE_IDS
	(
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	) RETURN ACCOUNT_SERVICE_TABLE IS

v_ACCOUNT_SERVICE_IDS ACCOUNT_SERVICE_TABLE := ACCOUNT_SERVICE_TABLE();

BEGIN

	SELECT ACCOUNT_SERVICE_TYPE(X.ACCOUNT_ID, X.SERVICE_LOCATION_ID, X.METER_ID, X.AGGREGATE_ID, X.ACCOUNT_SERVICE_ID)
	BULK COLLECT INTO v_ACCOUNT_SERVICE_IDS
	FROM
		(SELECT DISTINCT E.ACCOUNT_SERVICE_ID, E.ACCOUNT_ID, E.SERVICE_LOCATION_ID, E.METER_ID, E.AGGREGATE_ID
		FROM ACCOUNT A, ACCOUNT_STATUS B, ACCOUNT_STATUS_NAME STATUS_NAME, ENERGY_SERVICE_PROVIDER C, AGGREGATE_ACCOUNT_ESP D, ACCOUNT_SERVICE E
		WHERE UPPER(SUBSTR(A.ACCOUNT_MODEL_OPTION,1,2)) = 'AG'
			AND B.ACCOUNT_ID = A.ACCOUNT_ID
			AND B.BEGIN_DATE <= p_END_DATE
			AND NVL(B.END_DATE, p_END_DATE) >= p_BEGIN_DATE
			AND STATUS_NAME.STATUS_NAME = B.STATUS_NAME
			AND STATUS_NAME.IS_ACTIVE = 1
			AND UPPER(C.ESP_STATUS) = 'ACTIVE'
			AND D.ACCOUNT_ID = A.ACCOUNT_ID
			AND D.ESP_ID = C.ESP_ID
			AND D.BEGIN_DATE <= p_END_DATE
			AND NVL(D.END_DATE, p_END_DATE) >= p_BEGIN_DATE
			AND E.ACCOUNT_ID = A.ACCOUNT_ID
			AND E.AGGREGATE_ID = D.AGGREGATE_ID) X;

	RETURN v_ACCOUNT_SERVICE_IDS;

END GET_ACCOUNT_SERVICE_IDS;
---------------------------------------------------------------------------------------------------
FUNCTION GET_AGGREGATE_ANC_SVC
	(
	p_AGGREGATE_ID IN NUMBER,
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	) RETURN ANCILLARY_WORK_TABLE IS

v_AS_OF_DATE DATE;
v_ANCILLARY ANCILLARY_WORK_TABLE := ANCILLARY_WORK_TABLE();

BEGIN

	IF GA.VERSION_AGGREGATE_ANCILARY_SVC THEN
		v_AS_OF_DATE := SYSDATE;
		SELECT ANCILLARY_WORK_TYPE(A.AGGREGATE_ID, A.SERVICE_DATE, A.SERVICE_VAL, NULL)
		BULK COLLECT INTO v_ANCILLARY
		FROM AGGREGATE_ANCILLARY_SERVICE A
		WHERE A.AGGREGATE_ID = p_AGGREGATE_ID
			AND A.ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID
			AND A.SERVICE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
			AND A.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM AGGREGATE_ANCILLARY_SERVICE
				WHERE AGGREGATE_ID = A.AGGREGATE_ID
					AND ANCILLARY_SERVICE_ID = A.ANCILLARY_SERVICE_ID
					AND SERVICE_DATE = A.SERVICE_DATE
					AND AS_OF_DATE <= v_AS_OF_DATE)
		ORDER BY A.AGGREGATE_ID, A.SERVICE_DATE;
	ELSE
		v_AS_OF_DATE := LOW_DATE;
		SELECT ANCILLARY_WORK_TYPE(A.AGGREGATE_ID, A.SERVICE_DATE, A.SERVICE_VAL, NULL)
		BULK COLLECT INTO v_ANCILLARY
		FROM AGGREGATE_ANCILLARY_SERVICE A
		WHERE A.AGGREGATE_ID = p_AGGREGATE_ID
			AND A.ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID
			AND A.SERVICE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
			AND A.AS_OF_DATE = v_AS_OF_DATE
		ORDER BY A.AGGREGATE_ID, A.SERVICE_DATE;
	END IF;

	RETURN v_ANCILLARY;

END GET_AGGREGATE_ANC_SVC;
---------------------------------------------------------------------------------------------------
PROCEDURE AGGREGATE_ANC_SVC_SCHEDULE
	(
	p_MODEL_ID IN NUMBER,
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TRACE_ON IN NUMBER
	) AS

v_BEGIN_DATE DATE := TRUNC(p_BEGIN_DATE);
v_END_DATE DATE := TRUNC(p_END_DATE);
v_SCHEDULE_DATE DATE := v_BEGIN_DATE;
v_SERVICE_ACCOUNTS NUMBER(12);
v_INDEX BINARY_INTEGER;
v_SCHEDULE_INDEX BINARY_INTEGER;
v_ANCILLARY_INDEX BINARY_INTEGER;
v_ACCOUNT_SERVICE_IDS ACCOUNT_SERVICE_TABLE := ACCOUNT_SERVICE_TABLE();
v_ANCILLARY ANCILLARY_WORK_TABLE := ANCILLARY_WORK_TABLE();
v_SCHEDULE ANCILLARY_WORK_TABLE := ANCILLARY_WORK_TABLE();

BEGIN

	CX.CACHE_SERVICE_ACCOUNTS(p_BEGIN_DATE, p_END_DATE);

	v_ACCOUNT_SERVICE_IDS := GET_ACCOUNT_SERVICE_IDS(p_ANCILLARY_SERVICE_ID, v_BEGIN_DATE, v_END_DATE);

	IF v_ACCOUNT_SERVICE_IDS.COUNT > 0 THEN
		v_INDEX := v_ACCOUNT_SERVICE_IDS.FIRST;
		WHILE v_INDEX <= v_ACCOUNT_SERVICE_IDS.LAST LOOP
			v_ANCILLARY := GET_AGGREGATE_ANC_SVC(v_ACCOUNT_SERVICE_IDS(v_INDEX).AGGREGATE_ID, p_ANCILLARY_SERVICE_ID, v_BEGIN_DATE, v_END_DATE);

-- Initialize the Schedule  over the time period.
			v_SCHEDULE.DELETE;
			v_SCHEDULE.EXTEND(v_END_DATE - v_BEGIN_DATE + 1);
			v_SCHEDULE_INDEX := v_SCHEDULE.FIRST;
			WHILE v_SCHEDULE_INDEX <= v_SCHEDULE.LAST LOOP
				v_SCHEDULE(v_SCHEDULE_INDEX) := ANCILLARY_WORK_TYPE(v_ACCOUNT_SERVICE_IDS(v_INDEX).AGGREGATE_ID, v_SCHEDULE_DATE, NULL, NULL);
				v_SCHEDULE_DATE := v_SCHEDULE_DATE + 1;
				v_SCHEDULE_INDEX := v_SCHEDULE.NEXT(v_SCHEDULE_INDEX);
			END LOOP;

-- Assign the Ancillary Service value over the time period.
			v_ANCILLARY_INDEX := v_ANCILLARY.FIRST;
			WHILE v_ANCILLARY_INDEX <= v_ANCILLARY.LAST LOOP
				v_SCHEDULE_INDEX := v_ANCILLARY(v_ANCILLARY_INDEX).SERVICE_DATE - v_BEGIN_DATE + 1;
				WHILE v_SCHEDULE_INDEX <= v_SCHEDULE.LAST LOOP
					v_SCHEDULE(v_SCHEDULE_INDEX).SERVICE_VAL := v_ANCILLARY(v_ANCILLARY_INDEX).SERVICE_VAL;
					v_SCHEDULE_INDEX := v_SCHEDULE.NEXT(v_SCHEDULE_INDEX);
				END LOOP;
				v_ANCILLARY_INDEX := v_ANCILLARY.NEXT(v_ANCILLARY_INDEX);
			END LOOP;

-- Assign the Service Accounts over the time period.
			v_SCHEDULE_INDEX := v_SCHEDULE.FIRST;
			WHILE v_SCHEDULE_INDEX <= v_SCHEDULE.LAST LOOP
				v_SERVICE_ACCOUNTS := CX.GET_AGGREGATE_SERVICE_ACCOUNTS(v_ACCOUNT_SERVICE_IDS(v_INDEX).ACCOUNT_SERVICE_ID, v_SCHEDULE(v_SCHEDULE_INDEX).SERVICE_DATE, v_SERVICE_ACCOUNTS, GA.DAY_MODE, 'B');
				v_SCHEDULE(v_SCHEDULE_INDEX).SERVICE_ACCOUNTS := v_SERVICE_ACCOUNTS;
				v_SCHEDULE_INDEX := v_SCHEDULE.NEXT(v_SCHEDULE_INDEX);
			END LOOP;

-- Store the results as a Transaction.

			v_INDEX := v_ACCOUNT_SERVICE_IDS.NEXT(v_INDEX);
		END LOOP;
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		TRACE_ANCILLARY_WORK(v_SCHEDULE);
	END IF;
END AGGREGATE_ANC_SVC_SCHEDULE;
---------------------------------------------------------------------------------------------------
PROCEDURE ANCILLARY_SVC_AREA_PEAKS
    (
	 p_REQUEST_TYPE IN VARCHAR,
	 p_ANCILLARY_SERVICE_ID IN NUMBER,
	 p_BEGIN_DATE IN DATE,
	 p_END_DATE IN DATE,
	 p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of system loads defined in the database.

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT ANCILLARY_SERVICE_ID, AREA_ID, BEGIN_DATE, END_DATE,
		 		  SUBSTR(FROM_CUT_AS_HED(PEAK_DATE,p_TIME_ZONE),1,10) "PEAK_DATE",
		 		  LTRIM(RTRIM(SUBSTR(FROM_CUT_AS_HED(PEAK_DATE,p_TIME_ZONE),11,15))) "PEAK_TIME",
				  PEAK_VAL
		FROM ANCILLARY_SERVICE_AREA_PEAK A
		WHERE ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID
		ORDER BY BEGIN_DATE;

END ANCILLARY_SVC_AREA_PEAKS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_ANC_SERVICE_AREA_PEAK
	(
	p_REQUEST_TYPE IN VARCHAR,
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_AREA_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PEAK_DATE IN DATE,
	p_PEAK_TIME IN VARCHAR,
	p_PEAK_VAL IN NUMBER,
	p_OLD_AREA_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_OLD_PEAK_DATE IN DATE,
	p_OLD_PEAK_TIME IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER
	)
	AS

v_END_DATE DATE;
v_PEAK_DATE DATE;
v_OLD_PEAK_DATE DATE;
BEGIN

	IF NOT CAN_WRITE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_WRITE_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);
	v_PEAK_DATE := DATE_TIME_AS_CUT(TO_CHAR(p_PEAK_DATE,'YYYY-MM-DD'),p_PEAK_TIME,p_TIME_ZONE);
	v_OLD_PEAK_DATE := DATE_TIME_AS_CUT(TO_CHAR(p_OLD_PEAK_DATE,'YYYY-MM-DD'),p_OLD_PEAK_TIME,p_TIME_ZONE);

-- UPDATE THE CURRENT ASSIGNMENT IF ONE EXISTS

	UPDATE ANCILLARY_SERVICE_AREA_PEAK SET
		AREA_ID = p_AREA_ID,
		BEGIN_DATE = p_BEGIN_DATE,
		END_DATE = v_END_DATE,
		PEAK_DATE = v_PEAK_DATE,
		PEAK_VAL = p_PEAK_VAL
	WHERE ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID
		AND AREA_ID = p_OLD_AREA_ID
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE)
		AND PEAK_DATE = v_OLD_PEAK_DATE;

-- NO ASSIGNMENT UPDATE FOR THIS COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO ANCILLARY_SERVICE_AREA_PEAK
			(
			ANCILLARY_SERVICE_ID,
			AREA_ID,
			BEGIN_DATE,
			END_DATE,
			PEAK_DATE,
			PEAK_VAL
			)
		VALUES
			(
			p_ANCILLARY_SERVICE_ID,
			p_AREA_ID,
			p_BEGIN_DATE,
			v_END_DATE,
			v_PEAK_DATE,
			p_PEAK_VAL
			);
	END IF;

	EXCEPTION
		WHEN OTHERS THEN
			ERRS.LOG_AND_RAISE();

END PUT_ANC_SERVICE_AREA_PEAK;
----------------------------------------------------------------------------------------------------
PROCEDURE ALLOCATION_BEGIN_DATES
    (
	 p_STATUS OUT NUMBER,
	 p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of system loads defined in the database.

BEGIN

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	   SELECT DISTINCT TO_CHAR(BEGIN_DATE,'MM/DD/YYYY')
		FROM ANCILLARY_SERVICE_ALLOCATION
		ORDER BY 1 DESC;

END ALLOCATION_BEGIN_DATES;
---------------------------------------------------------------------------------------------------

PROCEDURE ANCILLARY_SVC_ALLOCATIONS
    (
	 p_REQUEST_TYPE IN VARCHAR,
	 p_ANCILLARY_SERVICE_ID IN NUMBER,
	 p_BEGIN_DATE IN DATE,
	 p_ALLOCATION_TOTAL OUT NUMBER,
	 p_STATUS OUT NUMBER,
	 p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of system loads defined in the database.

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;

	 p_ALLOCATION_TOTAL := XS.GET_ANC_SVC_TOTAL_ALLOCATION(p_ANCILLARY_SERVICE_ID,p_BEGIN_DATE);

	OPEN p_CURSOR FOR
	    SELECT ANCILLARY_SERVICE_ID, ALLOCATION_NAME, BEGIN_DATE, END_DATE, ALLOCATION_VAL,
		 		  ALLOCATION_VAL/DECODE(p_ALLOCATION_TOTAL,0,NULL,p_ALLOCATION_TOTAL) "ALLOCATION_PCT",
				  DEFAULT_VAL
		FROM ANCILLARY_SERVICE_ALLOCATION
		WHERE ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID
			AND BEGIN_DATE = TRUNC(p_BEGIN_DATE)
		ORDER BY 2;

END ANCILLARY_SVC_ALLOCATIONS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_ANC_SERVICE_ALLOCATION
	(
	p_REQUEST_TYPE IN VARCHAR,
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_ALLOCATION_NAME IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ALLOCATION_VAL IN NUMBER,
	p_DEFAULT_VAL IN NUMBER,
	p_OLD_ALLOCATION_NAME IN VARCHAR,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	)
	AS

v_END_DATE DATE;
BEGIN

	IF NOT CAN_WRITE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_WRITE_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- UPDATE THE CURRENT ASSIGNMENT IF ONE EXISTS

	UPDATE ANCILLARY_SERVICE_ALLOCATION SET
		ALLOCATION_NAME = p_ALLOCATION_NAME,
		BEGIN_DATE = p_BEGIN_DATE,
		END_DATE = p_END_DATE,
		ALLOCATION_VAL = p_ALLOCATION_VAL,
		DEFAULT_VAL = p_DEFAULT_VAL
	WHERE ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID
		AND ALLOCATION_NAME = p_OLD_ALLOCATION_NAME
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO ANCILLARY_SERVICE_ALLOCATION
			(
			ANCILLARY_SERVICE_ID,
			ALLOCATION_NAME,
			BEGIN_DATE,
			END_DATE,
			ALLOCATION_VAL,
			DEFAULT_VAL
			)
		VALUES
			(
			p_ANCILLARY_SERVICE_ID,
			p_ALLOCATION_NAME,
			p_BEGIN_DATE,
			v_END_DATE,
			p_ALLOCATION_VAL,
			p_DEFAULT_VAL
			);
	END IF;

	EXCEPTION
		WHEN OTHERS THEN
			ERRS.LOG_AND_RAISE();

END PUT_ANC_SERVICE_ALLOCATION;
----------------------------------------------------------------------------------------------------


END AN;
/
