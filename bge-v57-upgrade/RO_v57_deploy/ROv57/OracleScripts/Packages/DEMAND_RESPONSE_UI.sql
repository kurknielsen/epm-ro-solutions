CREATE OR REPLACE PACKAGE DEMAND_RESPONSE_UI IS
-- $Revision: 1.7 $

FUNCTION WHAT_VERSION RETURN VARCHAR2;

FUNCTION GET_PROGRAM_NAME_FOR_VPP
	(
	p_VPP_ID IN NUMBER
	) RETURN VARCHAR2;

PROCEDURE VPP_SUBSTATION_LIST
	(
	p_VPP_ID IN NUMBER,
	p_EFFECTIVE_DATE IN DATE,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE VPP_DER_SUMMARY
	(
	p_EFFECTIVE_DATE IN DATE,
	p_VPP_ID IN NUMBER,
	p_SUB_STATION_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE VPP_DER_DETAILS
	(
	p_EFFECTIVE_DATE IN DATE,
	p_VIRTUAL_POWER_PLANT_ID IN NUMBER,
	p_SS_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE SEGMENT_DATA_COMPARE_VPP_SUMM
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_VPP_ID IN NUMBER,
	p_PROGRAM_ID IN NUMBER,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_SHOW_WITH_LOSSES IN NUMBER,
	p_SHOW_UNCONSTRAINED IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR,
	p_SERVICE_CODE IN CHAR := CONSTANTS.CODE_FORECAST,
	p_SCENARIO_ID IN NUMBER := GA.BASE_SCENARIO_ID
	);

PROCEDURE SEGMENT_DATA_COMPARE_VPP_DETL
	(
	p_RESULT_DAY IN DATE,
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_PROGRAM_ID IN NUMBER,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_SHOW_WITH_LOSSES IN NUMBER,
	p_SHOW_UNCONSTRAINED IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR,
	p_SERVICE_CODE IN CHAR := CONSTANTS.CODE_FORECAST,
	p_SCENARIO_ID IN NUMBER := GA.BASE_SCENARIO_ID
	);

PROCEDURE DERMS_EXTERNAL_SYSTEM_LIST
	(
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE SEGMENT_DATA_SEGMENT_LIST
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_VPP_ID IN NUMBER,
	p_PROGRAM_ID IN NUMBER,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_SEARCH_STRING IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR,
	p_SERVICE_CODE IN CHAR,
	p_SCENARIO_ID IN NUMBER
	);

PROCEDURE SEGMENT_DATA_COMPARE_SEGMENT
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_FEEDER_SEGMENT_ID IN NUMBER,
	p_PROGRAM_ID IN NUMBER,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_VPP_ID IN NUMBER,
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_SHOW_WITH_LOSSES IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR,
	p_SERVICE_CODE IN CHAR := CONSTANTS.CODE_FORECAST,
	p_SCENARIO_ID IN NUMBER := GA.BASE_SCENARIO_ID
	);

PROCEDURE SEGMENT_DATA_VPP_LIST
	(
	p_PROGRAM_ID IN NUMBER,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE SERVICE_ZONE_LIST
	(
	p_SEARCH_STRING      	IN VARCHAR,
	p_SEARCH_OPTION      	IN VARCHAR,
	p_SEARCH_TYPE       	IN NUMBER,
	p_FIND_SERVICE_ZONE_ID  IN NUMBER,
	p_SEARCH_OPTION_NAME 	OUT VARCHAR2,
	p_CURSOR     			IN OUT GA.REFCURSOR
	);

PROCEDURE SUB_STATION_LIST
	(
	p_SERVICE_ZONE_ID 		IN NUMBER,
	p_BEGIN_DATE 			IN DATE,
	p_END_DATE   			IN DATE,
	p_SEARCH_STRING      	IN VARCHAR,
	p_SEARCH_OPTION      	IN VARCHAR,
	p_SEARCH_TYPE       	IN NUMBER,
	p_FIND_SUB_STATION_ID  	IN NUMBER,
	p_SEARCH_OPTION_NAME 	OUT VARCHAR2,
	p_CURSOR     			IN OUT GA.REFCURSOR
	);

PROCEDURE SUB_STATION_METER_LIST
	(
	p_SERVICE_ZONE_ID 		IN NUMBER,
	p_SUB_STATION_ID		IN NUMBER,
	p_BEGIN_DATE 			IN DATE,
	p_END_DATE   			IN DATE,
	p_SEARCH_STRING      	IN VARCHAR,
	p_SEARCH_OPTION      	IN VARCHAR,
	p_SEARCH_TYPE       	IN NUMBER,
	p_FIND_SUB_STATION_METER_ID 	IN NUMBER,
	p_SEARCH_OPTION_NAME 	OUT VARCHAR2,
	p_CURSOR     			IN OUT GA.REFCURSOR
	);

PROCEDURE METER_POINT_LIST
	(
	p_SERVICE_ZONE_ID 		IN NUMBER,
	p_SUB_STATION_ID		IN NUMBER,
	p_SUB_STATION_METER_ID	IN NUMBER,
	p_BEGIN_DATE 			IN DATE,
	p_END_DATE   			IN DATE,
	p_SEARCH_STRING      	IN VARCHAR,
	p_SEARCH_OPTION      	IN VARCHAR,
	p_SEARCH_TYPE       	IN NUMBER,
	p_FIND_METER_POINT_ID  	IN NUMBER,
	p_SEARCH_OPTION_NAME 	OUT VARCHAR2,
	p_CURSOR     			IN OUT GA.REFCURSOR
	);

PROCEDURE FEEDER_LIST
	(
	p_SERVICE_ZONE_ID 	IN NUMBER,
	p_SUB_STATION_ID	IN NUMBER,
	p_BEGIN_DATE 		IN DATE,
	p_END_DATE   		IN DATE,
	p_SEARCH_STRING     IN VARCHAR,
	p_SEARCH_OPTION     IN VARCHAR,
	p_SEARCH_TYPE       IN NUMBER,
	p_FIND_FEEDER_ID    IN NUMBER,
	p_SEARCH_OPTION_NAME 	OUT VARCHAR2,
	p_CURSOR     		IN OUT GA.REFCURSOR
	);

PROCEDURE FEEDER_SEGMENT_LIST
	(
	p_SERVICE_ZONE_ID 	IN NUMBER,
	p_SUB_STATION_ID	IN NUMBER,
	p_FEEDER_ID			IN NUMBER,
	p_BEGIN_DATE 		IN DATE,
	p_END_DATE   		IN DATE,
	p_SEARCH_STRING     IN VARCHAR,
	p_SEARCH_OPTION     IN VARCHAR,
	p_SEARCH_TYPE       IN NUMBER,
	p_FIND_FEEDER_SEGMENT_ID IN NUMBER,
	p_SEARCH_OPTION_NAME 	OUT VARCHAR2,
	p_CURSOR     		IN OUT GA.REFCURSOR
	);

PROCEDURE DELETE_TRANS_NETWORK_ENTITY
	(
	p_ENTITY_TYPE IN VARCHAR2,
	p_ENTITY_ID IN NUMBER
	);

PROCEDURE PASTE_TX_ENTITY
	(
	p_ENTITY_ID IN NUMBER,
	p_ENTITY_TYPE IN VARCHAR2,
	p_NEW_PARENT_ENTITY_ID IN NUMBER,
	p_IS_CUT IN NUMBER,
	p_NEW_ENTITY_ID OUT NUMBER
	);

PROCEDURE GET_PATH_FOR_SUB_STATION
	(
	p_SERVICE_ZONE_ID IN OUT NUMBER,
	p_SUB_STATION_ID IN NUMBER
	);

PROCEDURE GET_PATH_FOR_SUB_STATION_METER
	(
	p_SERVICE_ZONE_ID IN OUT NUMBER,
	p_SUB_STATION_ID IN OUT NUMBER,
	p_SUB_STATION_METER_ID IN NUMBER
	);

PROCEDURE GET_PATH_FOR_METER_POINT
	(
	p_SERVICE_ZONE_ID IN OUT NUMBER,
	p_SUB_STATION_ID OUT NUMBER,
	p_SUB_STATION_METER_ID IN OUT NUMBER,
	p_METER_POINT_ID IN OUT NUMBER
	);

PROCEDURE GET_PATH_FOR_FEEDER
	(
	p_SERVICE_ZONE_ID IN OUT NUMBER,
	p_SUB_STATION_ID IN OUT NUMBER,
	p_FEEDER_ID IN OUT NUMBER
	);

PROCEDURE GET_PATH_FOR_FEEDER_SEGMENT
	(
	p_SERVICE_ZONE_ID IN OUT NUMBER,
	p_SUB_STATION_ID IN OUT NUMBER,
	P_FEEDER_ID IN OUT NUMBER,
	p_FEEDER_SEGMENT_ID IN OUT NUMBER
	);

PROCEDURE SEARCH
	(
	p_BEGIN_DATE         IN DATE,
	p_END_DATE           IN DATE,
	p_SEARCH_STRING      IN VARCHAR,
	p_SEARCH_OPTION      IN VARCHAR,
	p_SEARCH_OPTION_NAME OUT VARCHAR,
	p_CURSOR             IN OUT GA.REFCURSOR
	);

PROCEDURE EVENTS_SUMMARY
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_VPP_ID IN NUMBER,
	P_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PUT_EVENT
	(
	p_EVENT_ID IN OUT NUMBER,
	p_EVENT_NAME IN VARCHAR2,
	p_VPP_ID IN NUMBER,
	p_EVENT_STATUS IN VARCHAR2,
	p_START_TIME IN DATE,
	p_STOP_TIME IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_EVENT_TYPE IN VARCHAR2,
	p_EVENT_ALIAS IN VARCHAR2,
	p_EVENT_DESC IN VARCHAR2
	);

PROCEDURE EVENT_DETAILS
	(
	p_EVENT_ID IN NUMBER,
	p_VPP_ID IN NUMBER,
	p_DETAIL_TYPE IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SEARCH_STRING IN VARCHAR2, -- Required for Participants report only
	p_SEARCH_OPTION IN VARCHAR2, -- Required for Participants report only
	p_SEARCH_OPTION_NAME OUT VARCHAR2, -- Required for Participants report only
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PUT_EVENT_INTERVAL_DATA
	(
	p_EVENT_ID IN NUMBER,
	p_CUT_DATE IN DATE,
	p_DISPATCH_SCHED IN NUMBER,
	p_PRICE IN NUMBER
	);

FUNCTION GET_ENV_SIGNAL_NAME
	(
	p_PROGRAM_ID IN NUMBER,
	p_AMOUNT IN NUMBER
	) RETURN VARCHAR2;

PROCEDURE CALC_DOMAIN_ENTITIES
	(
	p_SEARCH_STRING IN VARCHAR2,
	p_SEARCH_OPTION IN VARCHAR2,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ENTITY_DOMAIN_NAME OUT VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE RUN_DER_FORECAST
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ENTITY_IDS IN NUMBER_COLLECTION,
	p_SERVICE_CODE IN VARCHAR2,
	p_DATE_RANGE_BEGIN IN DATE,
	p_DATE_RANGE_END IN DATE,
	p_PROCESS_ID OUT VARCHAR2,
	p_PROCESS_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR2,
	p_CALCULATE_FULL_SUMMARY IN NUMBER := 1,
	p_TRACE_ON IN NUMBER := 0
	);

PROCEDURE LIST_WEATHER_CASES
	(
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE RUN_DER_VPP_PEAK_DAY
	(
	p_VPP_ID IN NUMBER,
	p_DESIGN_DAY IN DATE,
	p_WEATHER_CASE_ID IN NUMBER,
	p_PROCESS_STATUS OUT NUMBER,
	p_PROCESS_ID OUT VARCHAR2,
	p_MESSAGE OUT VARCHAR2,
	p_TRACE_ON IN NUMBER := 0
	);

PROCEDURE VPP_CAPACITY_RESULTS
	(
	p_VPP_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_FORECAST_DAY OUT VARCHAR2,
	p_WEATHER_CASE_NAME OUT VARCHAR2,
	p_LAST_RUN_WHEN OUT VARCHAR2,
	p_LAST_RUN_BY OUT VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE ENTITY_LIST_FOR_DER_SUMMARY
	(
	p_SUMMARY_TYPE in VARCHAR2,
	p_ENTITY_DOMAIN_ID in NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE FEEDER_SEGMENT_BY_SERVICE_ZONE
	(
	p_SERVICE_ZONE_ID IN NUMBER,
	p_SEARCH_STRING IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE LOAD_REDUCTION_DETAILS
(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SUMMARY_TYPE IN VARCHAR2,
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_INTERVAL IN VARCHAR2,
	p_ENTITY_TYPES IN VARCHAR2,
	p_SCENARIO_ID IN NUMBER,
	p_PEAK_PROGRAM OUT VARCHAR2,
	p_CURSOR IN OUT GA.REFCURSOR
);

PROCEDURE LOAD_REDUCTION_SUMMARY
(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SUMMARY_TYPE IN VARCHAR2,
	p_ENTITY_DOMAIN_ID IN VARCHAR2,
	p_ENTITY_ID IN NUMBER_COLLECTION,
	p_INTERVAL IN VARCHAR2,
	p_SCENARIO_ID IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
);

PROCEDURE LOAD_REDUCTION_BY_RESRC_TYPE
(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SUMMARY_TYPE IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_INTERVAL IN VARCHAR2,
	p_SCENARIO_ID IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
);

PROCEDURE LOAD_REDUCTION_BY_SEGMENT
(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SUMMARY_TYPE IN VARCHAR2,
	p_PROGRAM_ID IN NUMBER,
	p_INTERVAL IN VARCHAR2,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_FEEDER_SEGMENT_ID IN NUMBER_COLLECTION,
	p_SCENARIO_ID IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
);

-- Queries for candidate schedules for specified VPPs. This simply represents
-- the aggregated VPP data which can be accepted into a schedule.
-- %param p_VPP_IDs		The set of VPPs to query. Can include the value
--				CONSTANTS.ALL_ID to indicate querying for all VPPs.
-- %param p_BEGIN_DATE	The first day of the date range to query.
-- %param p_END_DATE	The last day of the date range to query.
-- %param p_TIME_ZONE	The time zone to use when querying interval data.
-- %param p_SCHEDULE_UNIT	The reported units ¿ either MW or MWh
-- %param p_CURSOR		The results.
-- %param p_SERVICE_CODE	The Service Code of data to query.
-- %param p_IS_EXTERNAL	The state of the Is External flag to be queried.
PROCEDURE VPP_SCHEDULES
	(
	p_VPP_IDs IN NUMBER_COLLECTION,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SCHEDULE_UNIT OUT VARCHAR2,
	p_CURSOR OUT DEMAND_RESPONSE.t_cur_VPP_SCHEDULE,
	p_SERVICE_CODE IN CHAR := 'F',
	p_IS_EXTERNAL IN NUMBER := 0
	);

-- Accepts VPP data into schedules. This will clear out previously accepted
-- schedule data, create transactions if necessary, and then copy the
-- aggregated data into IT_SCHEDULE.
-- %param p_BEGIN_DATE	The first day of the date range to query.
-- %param p_END_DATE	The last day of the date range to query.
-- %param p_TIME_ZONE	The time zone to use when querying interval data.
-- %param p_SERVICE_CODE	The Service Code of data to copy to schedule.
-- %param p_IS_EXTERNAL	The state of the Is External flag to be copied to
--				schedule.
-- %param p_VPP_IDs		The set of VPPs to query. Can include the value
--				CONSTANTS.ALL_ID to indicate accepting all VPPs.
PROCEDURE ACCEPT_VPPS_INTO_SCHEDULES
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SERVICE_CODE IN CHAR := 'F',
	p_IS_EXTERNAL IN NUMBER := 0,
	p_VPP_IDs IN NUMBER_COLLECTION := NUMBER_COLLECTION(-1)
	);

PROCEDURE SUBMIT_EVENT
	(
	p_EVENT_ID IN NUMBER,
	p_MESSAGE OUT VARCHAR2
	);

PROCEDURE ACCOUNT_METERED_DATA
	(
	p_ACCOUNT_ID IN NUMBER_COLLECTION,
	p_SERVICE_LOCATION_ID IN NUMBER_COLLECTION,
	p_METER_ID IN NUMBER_COLLECTION,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_INTERVAL IN VARCHAR2,
	p_METER_CODE IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	);

-- Queries for account-level economic impact figures. Includes account benefits
-- (aka direct expenses), which are payments and rebates given to the customer
-- for their participation in SmartGrid programs, and avoided costs, which are
-- costs of producing energy that was not actually produced due to demand
-- reduction.
-- %param p_ACCOUNT_ID	The account whose economic impact is reported
-- %param p_SERVICE_CODE	This is the service code to query when getting
--				resource reduction volumes.
-- %param p_IS_EXTERNAL	This is the state to query when getting resource
--				reduction volumes.
-- %param p_BEGIN_DATE	Start of date range on which to report.
-- %param p_END_DATE	End of date range on which to report.
-- %param p_TIME_ZONE	The Time Zone in which to see the results.
-- %param p_INTERVAL	The roll-up interval for reporting. This can be
--				15-minute, 30-minute, Hour, Day, Month, or Event
-- %param p_CURSOR		The results.
PROCEDURE ECONOMIC_IMPACT_BY_ACCOUNT
	(
	p_ACCOUNT_ID	IN NUMBER,
	p_SERVICE_CODE	IN VARCHAR2,
	p_IS_EXTERNAL	IN NUMBER,
	p_BEGIN_DATE	IN DATE,
	p_END_DATE		IN DATE,
	p_TIME_ZONE		IN VARCHAR2,
	p_INTERVAL		IN VARCHAR2,
	p_CURSOR		OUT GA.REFCURSOR
	);

-- Queries for summary economic impact figures. Includes direct expenses,
-- which are payments and rebates given to the customer for their participation
-- in SmartGrid programs, and avoided costs, which are costs of producing
-- energy that was not actually produced due to demand reduction.
-- %param p_ENTITY_DOMAIN_ID The domain of entities at which to summarize
--				  economic impact.
-- %param p_ENTITY_IDs	Collection of entities to report.
-- %param p_SERVICE_CODE	This is the service code to query when getting
--				resource reduction volumes.
-- %param p_IS_EXTERNAL	This is the state to query when getting resource
--				reduction volumes.
-- %param p_BEGIN_DATE	Start of date range on which to report.
-- %param p_END_DATE	End of date range on which to report.
-- %param p_TIME_ZONE	The Time Zone in which to see the results.
-- %param p_INTERVAL	The roll-up interval for reporting. This can be
--				15-minute, 30-minute, Hour, Day, Month, or Event
-- %param p_CURSOR		The results.
PROCEDURE ECONOMIC_IMPACT_SUMMARY
	(
	p_ENTITY_DOMAIN_ID	IN NUMBER,
	p_ECO_ENV_IMPACT_ENTITY_IDS		IN NUMBER_COLLECTION,
	p_SERVICE_CODE		IN VARCHAR2,
	p_IS_EXTERNAL		IN NUMBER,
	p_BEGIN_DATE		IN DATE,
	p_END_DATE			IN DATE,
	p_TIME_ZONE			IN VARCHAR2,
	p_INTERVAL			IN VARCHAR2,
	p_CURSOR			OUT GA.REFCURSOR
	);

-- Queries for account-level environmental impact figures.
-- %param p_ACCOUNT_ID	The account whose environmental impact is reported
-- %param p_SERVICE_CODE	This is the service code to query when getting
--				resource reduction volumes.
-- %param p_IS_EXTERNAL	This is the state to query when getting resource
--				reduction volumes.
-- %param p_BEGIN_DATE	Start of date range on which to report.
-- %param p_END_DATE	End of date range on which to report.
-- %param p_TIME_ZONE	The Time Zone in which to see the results.
-- %param p_INTERVAL	The roll-up interval for reporting. This can be
--				15-minute, 30-minute, Hour, Day, Month, or Event
-- %param p_CURSOR		The results.
PROCEDURE ENVRONMENTAL_IMPACT_BY_ACCOUNT
	(
	p_ACCOUNT_ID	IN NUMBER,
	p_SERVICE_CODE	IN VARCHAR2,
	p_IS_EXTERNAL	IN NUMBER,
	p_BEGIN_DATE	IN DATE,
	p_END_DATE		IN DATE,
	p_TIME_ZONE		IN VARCHAR2,
	p_INTERVAL		IN VARCHAR2,
	p_CURSOR		OUT GA.REFCURSOR
	);

-- Queries for summary of environmental impact figures.
-- %param p_ENTITY_DOMAIN_ID The domain of entities at which to summarize
--				  environmental impact.
-- %param p_ENTITY_IDs	Collection of entities to report.
-- %param p_SERVICE_CODE	This is the service code to query when getting
--				resource reduction volumes.
-- %param p_IS_EXTERNAL	This is the state to query when getting resource
--				reduction volumes.
-- %param p_BEGIN_DATE	Start of date range on which to report.
-- %param p_END_DATE	End of date range on which to report.
-- %param p_TIME_ZONE	The Time Zone in which to see the results.
-- %param p_INTERVAL	The roll-up interval for reporting. This can be
--				15-minute, 30-minute, Hour, Day, Month, or Event
-- %param p_CURSOR		The results.
PROCEDURE ENVIRONMENTAL_IMPACT_SUMMARY
	(
	p_ENTITY_DOMAIN_ID	IN NUMBER,
	p_ECO_ENV_IMPACT_ENTITY_IDS		IN NUMBER_COLLECTION,
	p_SERVICE_CODE	IN VARCHAR2,
	p_IS_EXTERNAL		IN NUMBER,
	p_BEGIN_DATE		IN DATE,
	p_END_DATE		IN DATE,
	p_TIME_ZONE		IN VARCHAR2,
	p_INTERVAL		IN VARCHAR2,
	p_CURSOR		OUT GA.REFCURSOR
	);

FUNCTION GET_ENTITY_SERVICE_LOCATIONS(p_ENTITY_DOMAIN_ID NUMBER, p_ENTITY_IDS number_collection)
RETURN ENTITY_SERVICE_LOCATION_TABLE PIPELINED;

PROCEDURE PUT_SEGMENT_DATA_USE_EXTERNAL
	(
	p_PROGRAM_ID IN NUMBER,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_RESULT_DAY IN DATE,
	p_USE_EXTERNAL IN NUMBER,
	p_SCENARIO_ID IN NUMBER := GA.BASE_SCENARIO_ID
	);

PROCEDURE ROLLUP_ACCEPTED_SEGMENTS
	(
	p_RESULT_DAY IN DATE_COLLECTION,
	p_PROGRAM_ID IN NUMBER_COLLECTION,
	p_SERVICE_ZONE_ID IN NUMBER_COLLECTION,
	p_SERVICE_CODE IN CHAR := CONSTANTS.CODE_FORECAST,
	p_SCENARIO_ID IN NUMBER := GA.BASE_SCENARIO_ID
	);

PROCEDURE PUT_SEG_USE_EXTERNAL_DEFAULT
	(
	p_PROGRAM_ID IN NUMBER,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_USE_EXTERNAL IN NUMBER
	);

PROCEDURE DER_SEG_USE_EXTERNAL_DEFAULTS
	(
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE ROLLUP_RECALC_OPTIONS
	(
	p_CURSOR OUT GA.REFCURSOR,
	p_SHOW_EXTERNAL_FORECAST IN NUMBER := 0
	);

PROCEDURE RECALCULATE_ROLLUPS
	(
	p_SERVICE_CODE IN STRING_COLLECTION,
	p_IS_EXTERNAL IN NUMBER_COLLECTION,
	p_DATE_RANGE_BEGIN IN DATE,
	p_DATE_RANGE_END IN DATE,
	p_SCENARIO_ID IN NUMBER := GA.BASE_SCENARIO_ID,
	p_MESSAGE OUT VARCHAR2,
	p_PROCESS_STATUS OUT NUMBER,
	p_PROCESS_ID OUT VARCHAR2
	);

PROCEDURE ENVIRONMENTAL_TRANSACTION_LIST
	(
	p_PROGRAM_INTERVAL IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	);

END DEMAND_RESPONSE_UI;
/
CREATE OR REPLACE PACKAGE BODY DEMAND_RESPONSE_UI IS

SUMMARY_TYPE_ALL_DETAILS		CONSTANT VARCHAR2(32) := 'All Details';
SUMMARY_TYPE_DAY_OF_WEEk		CONSTANT VARCHAR2(32) := 'Day of Week';
SUMMARY_TYPE_TOU				CONSTANT VARCHAR2(32) := 'Time of Use';
SUMMARY_TYPE_CPP 				CONSTANT VARCHAR2(32) := 'Critical Peak Periods';
-------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR2 IS
BEGIN
    RETURN '$Revision: 1.7 $';
END WHAT_VERSION;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_PROGRAM_SERVICE_ZONE_SET
	(
		p_ENTITY_DOMAIN_ID IN NUMBER,
		p_ENTITY_ID IN NUMBER_COLLECTION,
		p_ID_SET OUT ID_SET_COLLECTION,
		p_ALLOWED_PROGRAM_IDS IN ID_TABLE := NULL
	) AS

	v_TEMP_IDS ID_TABLE;

BEGIN

	IF p_ALLOWED_PROGRAM_IDS IS NULL THEN
		v_TEMP_IDS := ID_TABLE(ID_TYPE(SD.g_ALL_DATA_ENTITY_ID));
	ELSE
		v_TEMP_IDS := p_ALLOWED_PROGRAM_IDS;
	END IF;

	IF p_ENTITY_DOMAIN_ID = CONSTANTS.ALL_ID THEN

		SELECT ID_SET(P.PROGRAM_ID, SZ.SERVICE_ZONE_ID)
		BULK COLLECT INTO p_ID_SET
		FROM PROGRAM P,
			SERVICE_ZONE SZ,
			TABLE(CAST(v_TEMP_IDs AS ID_TABLE)) X
		WHERE X.ID IN (P.PROGRAM_ID, SD.g_ALL_DATA_ENTITY_ID);

	ELSIF p_ENTITY_DOMAIN_ID = EC.ED_PROGRAM THEN

		SELECT ID_SET(P.PROGRAM_ID, SZ.SERVICE_ZONE_ID)
		BULK COLLECT INTO p_ID_SET
		FROM PROGRAM P, SERVICE_ZONE SZ,
			TABLE(CAST(p_ENTITY_ID AS NUMBER_COLLECTION)) IDs,
			TABLE(CAST(v_TEMP_IDs AS ID_TABLE)) X
		WHERE P.PROGRAM_ID = IDs.COLUMN_VALUE
			AND X.ID IN (P.PROGRAM_ID, SD.g_ALL_DATA_ENTITY_ID);

	ELSIF p_ENTITY_DOMAIN_ID = EC.ED_SERVICE_ZONE THEN

		SELECT ID_SET(P.PROGRAM_ID, SZ.SERVICE_ZONE_ID)
		BULK COLLECT INTO p_ID_SET
		FROM PROGRAM P, SERVICE_ZONE SZ,
			TABLE(CAST(p_ENTITY_ID AS NUMBER_COLLECTION)) IDs,
			TABLE(CAST(v_TEMP_IDs AS ID_TABLE)) X
		WHERE SZ.SERVICE_ZONE_ID = IDs.COLUMN_VALUE
			AND X.ID IN (P.PROGRAM_ID, SD.g_ALL_DATA_ENTITY_ID);

	ELSE

		-- p_ENTITY_DOMAIN_ID = VPP
		SELECT ID_SET(VPP.PROGRAM_ID, VPP.SERVICE_ZONE_ID)
		BULK COLLECT INTO p_ID_SET
		FROM VIRTUAL_POWER_PLANT VPP,
			TABLE(CAST(p_ENTITY_ID AS NUMBER_COLLECTION)) IDs,
			TABLE(CAST(v_TEMP_IDs AS ID_TABLE)) X
		WHERE VPP.VPP_ID = IDs.COLUMN_VALUE
			AND X.ID IN (VPP.PROGRAM_ID, SD.g_ALL_DATA_ENTITY_ID);

	END IF;

END GET_PROGRAM_SERVICE_ZONE_SET;
-------------------------------------------------------------------------
FUNCTION GET_TIME_ZONE_FOR_VPP
	(
	p_VPP_ID IN NUMBER
	) RETURN VARCHAR2 IS

	v_RESULT SERVICE_ZONE.TIME_ZONE%TYPE;

	BEGIN

	SELECT SZ.TIME_ZONE
	INTO v_RESULT
	FROM VIRTUAL_POWER_PLANT VPP,
		SERVICE_ZONE SZ
	WHERE VPP.VPP_ID = p_VPP_ID
		AND SZ.SERVICE_ZONE_ID = VPP.SERVICE_ZONE_ID;

	RETURN v_RESULT;

END GET_TIME_ZONE_FOR_VPP;
-------------------------------------------------------------------------
FUNCTION GET_PROGRAM_NAME_FOR_VPP
	(
	p_VPP_ID IN NUMBER
	) RETURN VARCHAR2 IS
v_RESULT PROGRAM.PROGRAM_NAME%TYPE;
BEGIN
	SELECT MAX(P.PROGRAM_NAME)
	INTO v_RESULT
	FROM VIRTUAL_POWER_PLANT V,
		PROGRAM P
	WHERE V.VPP_ID = p_VPP_ID
		AND V.PROGRAM_ID = P.PROGRAM_ID;

	RETURN v_RESULT;
END GET_PROGRAM_NAME_FOR_VPP;
-------------------------------------------------------------------------
PROCEDURE VPP_SUBSTATION_LIST
	(
	p_VPP_ID IN NUMBER,
	p_EFFECTIVE_DATE IN DATE,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
		OPEN p_CURSOR FOR
			SELECT S.SUB_STATION_NAME, S.SUB_STATION_ID
			FROM VPP,
				TX_SUB_STATION S
			WHERE VPP.VPP_ID = p_VPP_ID
				AND VPP.STATUS_NAME = 'Active'
				AND S.SERVICE_ZONE_ID = VPP.SERVICE_ZONE_ID
			AND p_EFFECTIVE_DATE BETWEEN S.BEGIN_DATE AND NVL(S.END_DATE, CONSTANTS.HIGH_DATE);
END VPP_SUBSTATION_LIST;
--------------------------------------------------------------------------
PROCEDURE VPP_DER_SUMMARY
	(
	p_EFFECTIVE_DATE IN DATE,
	p_VPP_ID IN NUMBER,
	p_SUB_STATION_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
	BEGIN
		OPEN p_CURSOR FOR
		SELECT p_VPP_ID AS VIRTUAL_POWER_PLANT_ID,
			NVL(SS.SUB_STATION_ID, CONSTANTS.NOT_ASSIGNED) AS SS_ID,
			NVL(SUB_STATION_NAME, CONSTANTS.NOT_ASSIGNED_STRING) AS SUB_STATION_NAME,
			NVL(DER_TYPE_FUNCTION, CONSTANTS.UNDEFINED_ATTRIBUTE) AS DER_TYPE_FUNCTION,
				DER_TYPE_NAME,
				SUM(NVL(DP.COUNT,1)) AS DER_COUNT
		FROM SERVICE_LOCATION SL,
			TX_SUB_STATION SS,
			VPP,
			DISTRIBUTED_ENERGY_RESOURCE DER,
				DER_TYPE T,
			DER_PROGRAM DP
		WHERE -- Service Location
			(NVL(SL.SUB_STATION_ID,CONSTANTS.NOT_ASSIGNED) = p_SUB_STATION_ID OR CONSTANTS.ALL_ID = p_SUB_STATION_ID) -- All or selected SubStation)
			-- Sub Station
			AND SS.SUB_STATION_ID(+) = SL.SUB_STATION_ID
			AND p_EFFECTIVE_DATE BETWEEN SS.BEGIN_DATE(+) AND NVL(SS.END_DATE(+),CONSTANTS.HIGH_DATE)
			-- VPP
			AND VPP.VPP_ID = p_VPP_ID
			AND VPP.SERVICE_ZONE_ID = SL.SERVICE_ZONE_ID
			-- DER
			AND p_EFFECTIVE_DATE BETWEEN DER.BEGIN_DATE AND NVL(DER.END_DATE, CONSTANTS.HIGH_DATE)
			AND DER.SERVICE_LOCATION_ID = SL.SERVICE_LOCATION_ID
			-- DER Type
				AND T.DER_TYPE_ID = DER.DER_TYPE_ID
			-- DER Program
				AND DP.DER_ID = DER.DER_ID
			AND p_EFFECTIVE_DATE BETWEEN DP.BEGIN_DATE AND NVL(DP.END_DATE, CONSTANTS.HIGH_DATE)
			GROUP BY SS.SUB_STATION_ID,
				SS.SUB_STATION_NAME,
				DER_TYPE_FUNCTION,
				DER_TYPE_NAME;
END VPP_DER_SUMMARY;
--------------------------------------------------------------------------
PROCEDURE VPP_DER_DETAILS
	(
	p_EFFECTIVE_DATE IN DATE,
	p_VIRTUAL_POWER_PLANT_ID IN NUMBER,
	p_SS_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
	BEGIN
		OPEN p_CURSOR FOR
			SELECT
				F.FEEDER_NAME,
				FS.FEEDER_SEGMENT_NAME,
				DER.DER_NAME,
				DP.COUNT AS DER_COUNT,
				A.ACCOUNT_NAME,
				A.ACCOUNT_DISPLAY_NAME,
				A.ACCOUNT_EXTERNAL_IDENTIFIER,
				SL.SERVICE_LOCATION_NAME
			FROM DISTRIBUTED_ENERGY_RESOURCE DER,
				SERVICE_LOCATION SL,
				VPP,
				DER_PROGRAM DP,
				ACCOUNT_SERVICE_LOCATION ASL,
				ACCOUNT A,
				TX_FEEDER F,
				TX_FEEDER_SEGMENT FS
			WHERE p_EFFECTIVE_DATE BETWEEN NVL(DER.BEGIN_DATE, CONSTANTS.LOW_DATE) AND NVL(DER.END_DATE, CONSTANTS.HIGH_DATE)
				AND p_EFFECTIVE_DATE BETWEEN DP.BEGIN_DATE AND NVL(DP.END_DATE, CONSTANTS.HIGH_DATE)
				AND p_EFFECTIVE_DATE BETWEEN ASL.BEGIN_DATE AND NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE)
				AND SL.SERVICE_LOCATION_ID = DER.SERVICE_LOCATION_ID
				AND NVL(SL.SUB_STATION_ID, CONSTANTS.NOT_ASSIGNED) = p_SS_ID -- Selected SubStation
				AND VPP.VPP_ID = p_VIRTUAL_POWER_PLANT_ID
				AND VPP.SERVICE_ZONE_ID = SL.SERVICE_ZONE_ID
				AND DP.DER_ID = DER.DER_ID
				AND ASL.SERVICE_LOCATION_ID = SL.SERVICE_LOCATION_ID
				AND A.ACCOUNT_ID = ASL.ACCOUNT_ID
				AND F.FEEDER_ID(+) = SL.FEEDER_ID
				AND FS.FEEDER_SEGMENT_ID(+) = SL.FEEDER_SEGMENT_ID
			ORDER BY DER.DER_NAME,
				A.ACCOUNT_NAME,
				A.ACCOUNT_DISPLAY_NAME,
				A.ACCOUNT_EXTERNAL_IDENTIFIER,
				SL.SERVICE_LOCATION_NAME;
END VPP_DER_DETAILS;
--------------------------------------------------------------------------
PROCEDURE ROLLUP_ACCEPTED_SEGMENTS
(
	p_RESULT_DAY IN DATE_COLLECTION,
	p_PROGRAM_ID IN NUMBER_COLLECTION,
	p_SERVICE_ZONE_ID IN NUMBER_COLLECTION,
	p_SERVICE_CODE IN CHAR := CONSTANTS.CODE_FORECAST,
	p_SCENARIO_ID IN NUMBER := GA.BASE_SCENARIO_ID
) AS

	v_BEGIN DATE;
	v_END DATE;

	v_PROG_ZONE_PAIR_IDS ID_SET_COLLECTION := ID_SET_COLLECTION();

BEGIN

	IF p_PROGRAM_ID.COUNT <> p_SERVICE_ZONE_ID.COUNT THEN
		ERRS.RAISE_BAD_ARGUMENT('SERVICE_ZONE/PROGRAM', NULL,
			'An equal number of service zones and programs must be rolled-up.');
	END IF;

	FOR v_IDX IN 1..p_PROGRAM_ID.COUNT LOOP
		v_PROG_ZONE_PAIR_IDS.EXTEND();
		v_PROG_ZONE_PAIR_IDS(v_IDX) := ID_SET(p_PROGRAM_ID(v_IDX), p_SERVICE_ZONE_ID(v_IDX));
	END LOOP;

	UT.GET_DATE_COLLECTION_MIN_MAX(p_RESULT_DAY, v_BEGIN, v_END);

	-- RECALC VPP ROLLUPS
	DER_CAPACITY_ENGINE.CALC_VPP_RESULT_FROM_SEGMENT(0, p_SERVICE_CODE,
		p_SCENARIO_ID, v_BEGIN, v_END, v_PROG_ZONE_PAIR_IDS, FALSE);

END ROLLUP_ACCEPTED_SEGMENTS;
--------------------------------------------------------------------------
PROCEDURE DER_SEG_USE_EXTERNAL_DEFAULTS
	(
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
	SELECT LIST.EXTERNAL_SYSTEM_NAME,
		LIST.EXTERNAL_SYSTEM_ID,
		LIST.PROGRAM_ID,
		LIST.PROGRAM_NAME,
		LIST.SERVICE_ZONE_ID,
		LIST.SERVICE_ZONE_NAME,
		VPP.VPP_NAME,
		VPP.VPP_ID,
		CASE WHEN DEF.PROGRAM_ID IS NULL THEN 0 ELSE 1 END USE_EXTERNAL
	FROM (SELECT ES.EXTERNAL_SYSTEM_ID,
				ES.EXTERNAL_SYSTEM_NAME,
				P.PROGRAM_ID,
				P.PROGRAM_NAME,
				SZ.SERVICE_ZONE_ID,
				SZ.SERVICE_ZONE_NAME
		 FROM EXTERNAL_SYSTEM ES,
			PROGRAM P,
			SERVICE_ZONE SZ
		 WHERE SZ.SERVICE_ZONE_ID <> CONSTANTS.NOT_ASSIGNED
		 	AND P.PROGRAM_ID <> CONSTANTS.NOT_ASSIGNED
			AND ES.EXTERNAL_SYSTEM_TYPE = 'DERMS') LIST,
		VIRTUAL_POWER_PLANT VPP,
		DER_SEG_RESULT_DEFAULT_EXT DEF
	WHERE DEF.EXTERNAL_SYSTEM_ID (+) = LIST.EXTERNAL_SYSTEM_ID
		AND DEF.PROGRAM_ID (+) = LIST.PROGRAM_ID
		AND DEF.SERVICE_ZONE_ID (+) = LIST.SERVICE_ZONE_ID
		AND VPP.PROGRAM_ID (+) = LIST.PROGRAM_ID
		AND VPP.SERVICE_ZONE_ID (+) = LIST.SERVICE_ZONE_ID
	ORDER BY LIST.EXTERNAL_SYSTEM_NAME, LIST.PROGRAM_NAME, LIST.SERVICE_ZONE_NAME, VPP.VPP_NAME;

END DER_SEG_USE_EXTERNAL_DEFAULTS;
--------------------------------------------------------------------------
PROCEDURE PUT_SEG_USE_EXTERNAL_DEFAULT
	(
	p_PROGRAM_ID IN NUMBER,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_USE_EXTERNAL IN NUMBER
	) AS

BEGIN

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_ACCEPT_EXT_DER_RST,
		p_PROGRAM_ID, EC.ED_PROGRAM);

	IF p_USE_EXTERNAL = 0 THEN
		DELETE FROM DER_SEG_RESULT_DEFAULT_EXT EXT
		WHERE EXT.PROGRAM_ID = p_PROGRAM_ID
			AND EXT.SERVICE_ZONE_ID = p_SERVICE_ZONE_ID
			AND EXT.EXTERNAL_SYSTEM_ID = p_EXTERNAL_SYSTEM_ID;
	ELSE
		BEGIN
			INSERT INTO DER_SEG_RESULT_DEFAULT_EXT (PROGRAM_ID, SERVICE_ZONE_ID, EXTERNAL_SYSTEM_ID)
			VALUES (p_PROGRAM_ID, p_SERVICE_ZONE_ID, p_EXTERNAL_SYSTEM_ID);
		EXCEPTION WHEN DUP_VAL_ON_INDEX THEN
			NULL; -- IGNORE, EXPECTED
		END;
	END IF;

END PUT_SEG_USE_EXTERNAL_DEFAULT;
--------------------------------------------------------------------------
PROCEDURE SEGMENT_DATA_COMPARE_VPP_SUMM
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_VPP_ID IN NUMBER,
	p_PROGRAM_ID IN NUMBER,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_SHOW_WITH_LOSSES IN NUMBER,
	p_SHOW_UNCONSTRAINED IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR,
	p_SERVICE_CODE IN CHAR := CONSTANTS.CODE_FORECAST,
	p_SCENARIO_ID IN NUMBER := GA.BASE_SCENARIO_ID
	) AS

	v_IDS ID_TABLE;

BEGIN

	v_IDS := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_SELECT_DER_RESULTS, EC.ED_PROGRAM);

	OPEN p_CURSOR FOR
	SELECT ES.EXTERNAL_SYSTEM_ID, ES.EXTERNAL_SYSTEM_NAME AS DERMS_NAME,
		VPP.VPP_ID, VPP.VPP_NAME,
		SZ.SERVICE_ZONE_ID, SZ.SERVICE_ZONE_NAME,
		P.PROGRAM_ID, P.PROGRAM_NAME,
		LOAD.LOCAL_DAY AS RESULT_DAY,
		MAX(CASE WHEN p_SERVICE_CODE = CONSTANTS.CODE_FORECAST THEN
			(SELECT NVL(SUM(IS_EXT.IS_EXTERNAL), 0)
				FROM DER_SEG_RESULT_IS_EXTERNAL IS_EXT
				WHERE IS_EXT.RESULT_DAY = LOAD.LOCAL_DAY
					AND IS_EXT.PROGRAM_ID = LOAD.PROGRAM_ID
					AND IS_EXT.SERVICE_ZONE_ID = LOAD.SERVICE_ZONE_ID
					AND IS_EXT.EXTERNAL_SYSTEM_ID = ES.EXTERNAL_SYSTEM_ID
					AND IS_EXT.SCENARIO_ID = p_SCENARIO_ID)
		ELSE
			NULL
		END) USE_EXTERNAL,
		p_SCENARIO_ID AS SCENARIO_ID,
		SUM(LOAD.INTERNAL_DATA) AS INTERN_TOTAL,
		MAX(LOAD.INTERNAL_DATA) AS INTERN_MAX,
		SUM(LOAD.EXTERNAL_DATA) AS EXTERN_TOTAL,
		MAX(LOAD.EXTERNAL_DATA) AS EXTERN_MAX,
		MAX(LOAD.MAX_DIFF) AS MAX_DIFF,
		MAX( CASE WHEN LOAD.INTERNAL_DATA = 0
			THEN 100
				ELSE
					100*(ABS(LOAD.INTERNAL_DATA - LOAD.EXTERNAL_DATA) / LOAD.INTERNAL_DATA) END) AS MAX_PERT,
		SUM(LOAD.INTERNAL_DATA - LOAD.EXTERNAL_DATA) AS TOTAL_DIFF
	FROM
		-- THIS QUERY GETS US THE BIGGEST ABSOLUTE DIFFERENCE BETWEEN INTERNAL AND EXTERNAL
		-- DATA, BUT PRESERVES THE SIGN OF THE DIFFERENCE
		(SELECT EXTERNAL_SYSTEM_ID, PROGRAM_ID, SERVICE_ZONE_ID, VPP_ID, RESULT_DATE,
			INTERNAL_DATA, EXTERNAL_DATA, LOCAL_DAY,
			FIRST_VALUE(INTERNAL_DATA - EXTERNAL_DATA)
				OVER (PARTITION BY VPP_ID, EXTERNAL_SYSTEM_ID, LOCAL_DAY ORDER BY
					ABS(INTERNAL_DATA - EXTERNAL_DATA) DESC) AS MAX_DIFF
		FROM (
		-- THIS QUERY GETS US THE EXTERNAL AND THE INTERNAL DATA IN ONE RECORD
		 -- FOR EACH DERMS, VPP AND LOAD DATE
		SELECT RST.EXTERNAL_SYSTEM_ID, RST.PROGRAM_ID, RST.SERVICE_ZONE_ID, VPP.VPP_ID, DATA.RESULT_DATE,
			MAX(TRUNC(FROM_CUT(RESULT_DATE, NVL(SZ.TIME_ZONE, GA.LOCAL_TIME_ZONE))-1/86400)) AS LOCAL_DAY,
			SUM(CASE WHEN IS_EXTERNAL = 0 THEN
					CASE WHEN p_SHOW_WITH_LOSSES = 1 THEN
						CASE WHEN NVL(p_SHOW_UNCONSTRAINED,0) = 1 THEN
							DATA.UNCONSTRAINED_LOAD_VAL + NVL(DATA.UNCONSTRAINED_TX_LOSS_VAL, 0) +
								NVL(DATA.UNCONSTRAINED_DX_LOSS_VAL, 0)
						ELSE
						 	DATA.LOAD_VAL + DATA.FAILURE_VAL + DATA.OPT_OUT_VAL + DATA.OVERRIDE_VAL
								+ DATA.TX_LOSS_VAL + DATA.DX_LOSS_VAL
						END
					ELSE
						CASE WHEN NVL(p_SHOW_UNCONSTRAINED,0) = 1 THEN
							DATA.UNCONSTRAINED_LOAD_VAL
						ELSE
							DATA.LOAD_VAL + DATA.FAILURE_VAL + DATA.OPT_OUT_VAL + DATA.OVERRIDE_VAL
						END
					END
				ELSE
					0
				END) AS INTERNAL_DATA,
			SUM(CASE WHEN IS_EXTERNAL = 1 THEN
					CASE WHEN p_SHOW_WITH_LOSSES = 1 THEN
						CASE WHEN NVL(p_SHOW_UNCONSTRAINED,0) = 1 THEN
							DATA.UNCONSTRAINED_LOAD_VAL + NVL(DATA.UNCONSTRAINED_TX_LOSS_VAL, 0) +
								NVL(DATA.UNCONSTRAINED_DX_LOSS_VAL, 0)
						ELSE
						 	DATA.LOAD_VAL + DATA.FAILURE_VAL + DATA.OPT_OUT_VAL + DATA.OVERRIDE_VAL
								+ DATA.TX_LOSS_VAL + DATA.DX_LOSS_VAL
						END
					ELSE
						CASE WHEN NVL(p_SHOW_UNCONSTRAINED,0) = 1 THEN
							DATA.UNCONSTRAINED_LOAD_VAL
						ELSE
							DATA.LOAD_VAL + DATA.FAILURE_VAL + DATA.OPT_OUT_VAL + DATA.OVERRIDE_VAL
						END
					END
				ELSE
					0
				END) AS EXTERNAL_DATA
		FROM DER_SEGMENT_RESULT RST, DER_SEGMENT_RESULT_DATA DATA, TABLE(CAST(v_IDS AS ID_TABLE)) X,
			VIRTUAL_POWER_PLANT VPP, SERVICE_ZONE SZ
		WHERE (RST.EXTERNAL_SYSTEM_ID = p_EXTERNAL_SYSTEM_ID
					OR p_EXTERNAL_SYSTEM_ID = CONSTANTS.ALL_ID)
			AND (RST.PROGRAM_ID = p_PROGRAM_ID OR p_PROGRAM_ID = CONSTANTS.ALL_ID)
			AND (RST.SERVICE_ZONE_ID = p_SERVICE_ZONE_ID OR p_SERVICE_ZONE_ID = CONSTANTS.ALL_ID)
			AND (RST.PROGRAM_ID = X.ID OR X.ID = SD.g_ALL_DATA_ENTITY_ID)
			AND RST.SERVICE_CODE = p_SERVICE_CODE
			AND RST.SCENARIO_ID = p_SCENARIO_ID
			AND VPP.PROGRAM_ID (+) = RST.PROGRAM_ID
			AND VPP.SERVICE_ZONE_ID (+) = RST.SERVICE_ZONE_ID
			AND (VPP.VPP_ID = p_VPP_ID OR p_VPP_ID = CONSTANTS.ALL_ID)
				-- SHOW RECORDS W/ NO CORRESPONDING VPP ONLY IF 'ALL' VPPS ARE SELECTED
			AND SZ.SERVICE_ZONE_ID = RST.SERVICE_ZONE_ID
			AND DATA.DER_SEGMENT_RESULT_ID = RST.DER_SEGMENT_RESULT_ID
			AND RESULT_DATE BETWEEN TO_CUT(p_BEGIN_DATE, NVL(SZ.TIME_ZONE, GA.LOCAL_TIME_ZONE)) + 1/86400
				AND (TO_CUT(p_END_DATE, NVL(SZ.TIME_ZONE, GA.LOCAL_TIME_ZONE)) + 1)
		GROUP BY EXTERNAL_SYSTEM_ID, RST.PROGRAM_ID, RST.SERVICE_ZONE_ID, VPP.VPP_ID, RESULT_DATE)) LOAD,
		EXTERNAL_SYSTEM ES, VIRTUAL_POWER_PLANT VPP,
		SERVICE_ZONE SZ, PROGRAM P
	WHERE VPP.VPP_ID (+) = LOAD.VPP_ID
		AND SZ.SERVICE_ZONE_ID = LOAD.SERVICE_ZONE_ID
		AND P.PROGRAM_ID = LOAD.PROGRAM_ID
		AND ES.EXTERNAL_SYSTEM_ID = LOAD.EXTERNAL_SYSTEM_ID
	GROUP BY P.PROGRAM_ID, P.PROGRAM_NAME,
			SZ.SERVICE_ZONE_ID, SZ.SERVICE_ZONE_NAME,
			VPP.VPP_ID, VPP.VPP_NAME,
			ES.EXTERNAL_SYSTEM_ID, ES.EXTERNAL_SYSTEM_NAME, LOCAL_DAY, p_SCENARIO_ID
	ORDER BY LOCAL_DAY, EXTERNAL_SYSTEM_NAME, VPP_NAME;

END SEGMENT_DATA_COMPARE_VPP_SUMM;
--------------------------------------------------------------------------
PROCEDURE PUT_SEGMENT_DATA_USE_EXTERNAL
(
	p_PROGRAM_ID IN NUMBER,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_RESULT_DAY IN DATE,
	p_USE_EXTERNAL IN NUMBER,
	p_SCENARIO_ID IN NUMBER := GA.BASE_SCENARIO_ID
) AS

	v_BEGIN DATE;
	v_END DATE;

BEGIN

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_ACCEPT_EXT_DER_RST,
		p_PROGRAM_ID, EC.ED_PROGRAM);

	UT.CUT_DATE_RANGE(CONSTANTS.ELECTRIC_MODEL,
		p_RESULT_DAY, p_RESULT_DAY, DER_CAPACITY_ENGINE.GET_TIME_ZONE_FOR_ZONE(p_SERVICE_ZONE_ID),
		v_BEGIN, v_END);

	MERGE INTO DER_SEG_RESULT_IS_EXTERNAL IS_EXT
	USING (SELECT p_PROGRAM_ID PROGRAM_ID,
				p_SERVICE_ZONE_ID SERVICE_ZONE_ID,
				p_EXTERNAL_SYSTEM_ID EXTERNAL_SYSTEM_ID,
				p_SCENARIO_ID SCENARIO_ID,
				p_RESULT_DAY RESULT_DAY,
				v_BEGIN CUT_BEGIN,
				v_END CUT_END
			FROM DUAL) MERG
	ON (IS_EXT.RESULT_DAY = MERG.RESULT_DAY
		AND IS_EXT.PROGRAM_ID = MERG.PROGRAM_ID
		AND IS_EXT.SERVICE_ZONE_ID = MERG.SERVICE_ZONE_ID
		AND IS_EXT.EXTERNAL_SYSTEM_ID = MERG.EXTERNAL_SYSTEM_ID
		AND IS_EXT.SCENARIO_ID = MERG.SCENARIO_ID)
	WHEN MATCHED THEN
		UPDATE SET IS_EXT.IS_EXTERNAL = p_USE_EXTERNAL
	WHEN NOT MATCHED THEN
		INSERT VALUES (MERG.RESULT_DAY, MERG.PROGRAM_ID, MERG.SERVICE_ZONE_ID, MERG.EXTERNAL_SYSTEM_ID,
			MERG.SCENARIO_ID, MERG.CUT_BEGIN, MERG.CUT_END, p_USE_EXTERNAL);

END PUT_SEGMENT_DATA_USE_EXTERNAL;
--------------------------------------------------------------------------
FUNCTION GET_PROGRAM_INTERVAL
(
	p_PROGRAM_ID IN NUMBER
) RETURN VARCHAR2 IS

	v_RESULT VARCHAR2(64);

BEGIN

	SELECT NVL(GET_INTERVAL_ABBREVIATION(P.PROGRAM_INTERVAL),DATE_UTIL.c_ABBR_HOUR)
	INTO v_RESULT
	FROM PROGRAM P
	WHERE P.PROGRAM_ID = p_PROGRAM_ID;

	RETURN v_RESULT;

END GET_PROGRAM_INTERVAL;
--------------------------------------------------------------------------
FUNCTION GET_VPP_INTERVAL
(
	p_VPP_ID IN NUMBER
) RETURN VARCHAR2 IS

	v_RESULT VARCHAR2(64);

BEGIN

	SELECT NVL(GET_INTERVAL_ABBREVIATION(P.PROGRAM_INTERVAL),DATE_UTIL.c_ABBR_HOUR)
	INTO v_RESULT
	FROM PROGRAM P, VIRTUAL_POWER_PLANT VPP
	WHERE VPP.VPP_ID = p_VPP_ID
		AND P.PROGRAM_ID = VPP.PROGRAM_ID;

	RETURN v_RESULT;

END GET_VPP_INTERVAL;
--------------------------------------------------------------------------
PROCEDURE SEGMENT_DATA_COMPARE_VPP_DETL
(
	p_RESULT_DAY IN DATE,
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_PROGRAM_ID IN NUMBER,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_SHOW_WITH_LOSSES IN NUMBER,
	p_SHOW_UNCONSTRAINED IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR,
	p_SERVICE_CODE IN CHAR := CONSTANTS.CODE_FORECAST,
	p_SCENARIO_ID IN NUMBER := GA.BASE_SCENARIO_ID
) AS

	v_BEGIN_DATE DATE;
	v_END_DATE DATE;

	v_INTERVAL VARCHAR2(64) := GET_PROGRAM_INTERVAL(p_PROGRAM_ID);
	v_INTERVAL_NUM NUMBER(9) := GET_INTERVAL_NUMBER(v_INTERVAL);

	v_TIME_ZONE SERVICE_ZONE.TIME_ZONE%TYPE := DER_CAPACITY_ENGINE.GET_TIME_ZONE_FOR_ZONE(p_SERVICE_ZONE_ID);

BEGIN

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_DER_RESULTS, p_PROGRAM_ID, EC.ED_PROGRAM);

	SP.CHECK_SYSTEM_DATE_TIME(v_TIME_ZONE, p_RESULT_DAY, p_RESULT_DAY);

	UT.CUT_DATE_RANGE(CONSTANTS.ELECTRIC_MODEL, p_RESULT_DAY, p_RESULT_DAY,
		v_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	OPEN p_CURSOR FOR
		SELECT SUBSTR(FROM_CUT_AS_HED(SDT.CUT_DATE, v_TIME_ZONE, v_INTERVAL),1,10) SCHED_DATE,
			TRIM(SUBSTR(FROM_CUT_AS_HED(SDT.CUT_DATE, v_TIME_ZONE, v_INTERVAL),11)) SCHED_TIME,
			SDT.CUT_DATE, LOAD.INTERNAL_DATA, LOAD.EXTERNAL_DATA,
			NVL(LOAD.INTERNAL_DATA,0) - NVL(LOAD.EXTERNAL_DATA,0) AS DIFF,
			CASE WHEN LOAD.INTERNAL_DATA = 0 AND LOAD.EXTERNAL_DATA <> 0 THEN
				  100
				 WHEN LOAD.INTERNAL_DATA = 0 AND LOAD.EXTERNAL_DATA = 0 THEN
				  0
				 ELSE
				  100*(ABS(LOAD.INTERNAL_DATA - LOAD.EXTERNAL_DATA) / LOAD.INTERNAL_DATA)
			END AS PCT_DIFF
		FROM (SELECT DATA.RESULT_DATE,
					SUM(CASE WHEN DATA.LOAD_VAL IS NULL THEN
						NULL
					WHEN IS_EXTERNAL = 0 THEN
						CASE WHEN p_SHOW_WITH_LOSSES = 1 THEN
							CASE WHEN NVL(p_SHOW_UNCONSTRAINED,0) = 1 THEN
								DATA.UNCONSTRAINED_LOAD_VAL + NVL(DATA.UNCONSTRAINED_TX_LOSS_VAL, 0) +
									NVL(DATA.UNCONSTRAINED_DX_LOSS_VAL, 0)
							ELSE
								DATA.LOAD_VAL + DATA.FAILURE_VAL + DATA.OPT_OUT_VAL + DATA.OVERRIDE_VAL
									+ DATA.TX_LOSS_VAL + DATA.DX_LOSS_VAL
							END
						ELSE
							CASE WHEN NVL(p_SHOW_UNCONSTRAINED,0) = 1 THEN
								DATA.UNCONSTRAINED_LOAD_VAL
							ELSE
								DATA.LOAD_VAL + DATA.FAILURE_VAL + DATA.OPT_OUT_VAL + DATA.OVERRIDE_VAL
							END
						END
					ELSE
						0
					END) AS INTERNAL_DATA,
				SUM(CASE WHEN DATA.LOAD_VAL IS NULL THEN
						NULL
					WHEN IS_EXTERNAL = 1 THEN
						CASE WHEN p_SHOW_WITH_LOSSES = 1 THEN
							CASE WHEN NVL(p_SHOW_UNCONSTRAINED,0) = 1 THEN
								DATA.UNCONSTRAINED_LOAD_VAL + NVL(DATA.UNCONSTRAINED_TX_LOSS_VAL, 0) +
									NVL(DATA.UNCONSTRAINED_DX_LOSS_VAL, 0)
							ELSE
								DATA.LOAD_VAL + DATA.FAILURE_VAL + DATA.OPT_OUT_VAL + DATA.OVERRIDE_VAL
									+ DATA.TX_LOSS_VAL + DATA.DX_LOSS_VAL
							END
						ELSE
							CASE WHEN NVL(p_SHOW_UNCONSTRAINED,0) = 1 THEN
								DATA.UNCONSTRAINED_LOAD_VAL
							ELSE
								DATA.LOAD_VAL + DATA.FAILURE_VAL + DATA.OPT_OUT_VAL + DATA.OVERRIDE_VAL
							END
						END
					ELSE
						0
					END) AS EXTERNAL_DATA
			FROM DER_SEGMENT_RESULT RST, DER_SEGMENT_RESULT_DATA DATA
			WHERE RST.EXTERNAL_SYSTEM_ID = p_EXTERNAL_SYSTEM_ID
				AND RST.PROGRAM_ID = p_PROGRAM_ID
				AND RST.SERVICE_ZONE_ID = p_SERVICE_ZONE_ID
				AND RST.SERVICE_CODE = p_SERVICE_CODE
				AND RST.SCENARIO_ID = p_SCENARIO_ID
				AND DATA.DER_SEGMENT_RESULT_ID = RST.DER_SEGMENT_RESULT_ID
				AND DATA.RESULT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			GROUP BY DATA.RESULT_DATE) LOAD,
			SYSTEM_DATE_TIME SDT
		WHERE SDT.TIME_ZONE = v_TIME_ZONE
			AND SDT.DATA_INTERVAL_TYPE = 1
			AND SDT.DAY_TYPE = '1'
			AND LOAD.RESULT_DATE (+) = SDT.CUT_DATE
			AND SDT.CUT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND SDT.MINIMUM_INTERVAL_NUMBER >= v_INTERVAL_NUM
		ORDER BY CUT_DATE;

END SEGMENT_DATA_COMPARE_VPP_DETL;
--------------------------------------------------------------------------
PROCEDURE DERMS_EXTERNAL_SYSTEM_LIST
	(
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
	SELECT ES.EXTERNAL_SYSTEM_ID, ES.EXTERNAL_SYSTEM_NAME
	FROM EXTERNAL_SYSTEM ES
	WHERE ES.EXTERNAL_SYSTEM_TYPE = 'DERMS'
		ORDER BY ES.EXTERNAL_SYSTEM_NAME;

END DERMS_EXTERNAL_SYSTEM_LIST;
--------------------------------------------------------------------------
FUNCTION GET_MIN_INTERVAL_FOR_SEGMENT
(
	p_CUT_BEGIN IN DATE,
	p_CUT_END IN DATE,
	p_FEEDER_SEGMENT_ID IN NUMBER,
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_VPP_ID IN NUMBER,
	p_PROGRAM_ID IN NUMBER,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER := GA.BASE_SCENARIO_ID,
	p_SERVICE_CODE IN VARCHAR2 := CONSTANTS.CODE_FORECAST
) RETURN VARCHAR2 IS

	v_RESULT VARCHAR2(32);

	v_IDS ID_TABLE;

BEGIN

	v_IDS := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_SELECT_DER_RESULTS, EC.ED_PROGRAM);

	SELECT MAX(ABBR)
	INTO v_RESULT
	FROM (SELECT NVL(GET_INTERVAL_ABBREVIATION(PROG.PROGRAM_INTERVAL),'HH') ABBR,
			GET_INTERVAL_NUMBER(PROG.PROGRAM_INTERVAL) NUM
		FROM DER_SEGMENT_RESULT RST, PROGRAM PROG, TABLE(CAST(v_IDS AS ID_TABLE)) X,
			VIRTUAL_POWER_PLANT VPP
		WHERE RST.FEEDER_SEGMENT_ID = p_FEEDER_SEGMENT_ID
			AND (RST.EXTERNAL_SYSTEM_ID = p_EXTERNAL_SYSTEM_ID OR
				p_EXTERNAL_SYSTEM_ID = CONSTANTS.ALL_ID)
			AND (RST.PROGRAM_ID = p_PROGRAM_ID OR
				p_PROGRAM_ID = CONSTANTS.ALL_ID)
			AND (RST.SERVICE_ZONE_ID = p_SERVICE_ZONE_ID OR
				p_SERVICE_ZONE_ID = CONSTANTS.ALL_ID)
			AND (RST.PROGRAM_ID = X.ID OR
				X.ID = SD.g_ALL_DATA_ENTITY_ID)
			AND VPP.SERVICE_ZONE_ID (+) = RST.SERVICE_ZONE_ID
			AND VPP.PROGRAM_ID (+) = RST.PROGRAM_ID
			AND (VPP.VPP_ID = p_VPP_ID OR p_VPP_ID = CONSTANTS.ALL_ID)
			AND RST.SERVICE_CODE = p_SERVICE_CODE
			AND RST.SCENARIO_ID = p_SCENARIO_ID
			AND PROG.PROGRAM_ID = RST.PROGRAM_ID
			AND EXISTS (SELECT 1
						FROM DER_SEGMENT_RESULT_DATA DATA
						WHERE DATA.DER_SEGMENT_RESULT_ID = RST.DER_SEGMENT_RESULT_ID
							AND DATA.RESULT_DATE BETWEEN p_CUT_BEGIN AND p_CUT_END)
		ORDER BY NUM ASC)
	WHERE ROWNUM = 1;

	RETURN v_RESULT;

END GET_MIN_INTERVAL_FOR_SEGMENT;
--------------------------------------------------------------------------
PROCEDURE SEGMENT_DATA_COMPARE_SEGMENT
(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_FEEDER_SEGMENT_ID IN NUMBER,
	p_PROGRAM_ID IN NUMBER,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_VPP_ID IN NUMBER,
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_SHOW_WITH_LOSSES IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR,
	p_SERVICE_CODE IN CHAR := CONSTANTS.CODE_FORECAST,
	p_SCENARIO_ID IN NUMBER := GA.BASE_SCENARIO_ID
) AS

	v_BEGIN_DATE DATE;
	v_END_DATE DATE;

	v_INTERVAL VARCHAR2(64);
	v_INTERVAL_NUM NUMBER(9);

	v_IDS ID_TABLE;

BEGIN

	-- WAIT FOR THEM TO SELECT A FEEDER SEGMENT
	IF p_FEEDER_SEGMENT_ID IS NULL THEN
		OPEN p_CURSOR FOR SELECT NULL FROM DUAL;
		RETURN;
	END IF;

	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, p_BEGIN_DATE, p_END_DATE);

	UT.CUT_DATE_RANGE(CONSTANTS.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE,
		v_END_DATE);

	v_INTERVAL := GET_MIN_INTERVAL_FOR_SEGMENT(v_BEGIN_DATE, v_END_DATE, p_FEEDER_SEGMENT_ID,
					p_EXTERNAL_SYSTEM_ID, p_VPP_ID, p_PROGRAM_ID, p_SERVICE_ZONE_ID, p_SCENARIO_ID, p_SERVICE_CODE);

	v_INTERVAL_NUM := GET_INTERVAL_NUMBER(v_INTERVAL);

	v_IDS := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_SELECT_DER_RESULTS, EC.ED_PROGRAM);

	IF p_EXTERNAL_SYSTEM_ID = CONSTANTS.ALL_ID OR ((p_PROGRAM_ID = CONSTANTS.ALL_ID OR
		p_SERVICE_ZONE_ID = CONSTANTS.ALL_ID) AND p_VPP_ID = CONSTANTS.ALL_ID) THEN

		OPEN p_CURSOR FOR
		SELECT SUBSTR(FROM_CUT_AS_HED(LOAD.CUT_DATE, p_TIME_ZONE, v_INTERVAL),1,10) SCHED_DATE,
			TRIM(SUBSTR(FROM_CUT_AS_HED(LOAD.CUT_DATE, p_TIME_ZONE, v_INTERVAL),11)) SCHED_TIME,
			LOAD.CUT_DATE,
			SUM(LOAD.INTERNAL_DATA) INTERNAL_DATA,
			SUM(LOAD.EXTERNAL_DATA) EXTERNAL_DATA,
			SUM(LOAD.INTERNAL_UNCONSTRAINED_DATA) INTERNAL_UNCONSTRAINED_DATA,
			SUM(LOAD.EXTERNAL_UNCONSTRAINED_DATA) EXTERNAL_UNCONSTRAINED_DATA,
			SUM(LOAD.INTERNAL_DATA - LOAD.EXTERNAL_DATA) LOAD_DIFF,
			SUM(LOAD.INTERNAL_UNCONSTRAINED_DATA
				- LOAD.EXTERNAL_UNCONSTRAINED_DATA) UNCON_LOAD_DIFF,
			SUM(CASE WHEN LOAD.INTERNAL_DATA = 0 AND LOAD.EXTERNAL_DATA <> 0 THEN
				  100
				 WHEN LOAD.INTERNAL_DATA = 0 AND LOAD.EXTERNAL_DATA = 0 THEN
				  0
				 ELSE
				  100*(ABS(LOAD.INTERNAL_DATA - LOAD.EXTERNAL_DATA) / LOAD.INTERNAL_DATA)
			END) AS PCT_DIFF,
			SUM(CASE WHEN LOAD.INTERNAL_UNCONSTRAINED_DATA = 0 AND LOAD.EXTERNAL_UNCONSTRAINED_DATA <> 0 THEN
				  100
				 WHEN LOAD.INTERNAL_UNCONSTRAINED_DATA = 0 AND LOAD.EXTERNAL_UNCONSTRAINED_DATA = 0 THEN
				  0
				 ELSE
				  100*(ABS(LOAD.INTERNAL_UNCONSTRAINED_DATA - LOAD.EXTERNAL_UNCONSTRAINED_DATA) / LOAD.INTERNAL_UNCONSTRAINED_DATA)
			END) AS UNCON_PCT_DIFF,
			SUM(CASE WHEN MIX.LOAD_VAL IS NULL OR p_SERVICE_CODE = CONSTANTS.CODE_BACKCAST THEN
				NULL
			WHEN p_SHOW_WITH_LOSSES = 1 THEN
				 MIX.LOAD_VAL + MIX.FAILURE_VAL + MIX.OPT_OUT_VAL + MIX.OVERRIDE_VAL
					+ MIX.TX_LOSS_VAL + MIX.DX_LOSS_VAL
			ELSE
				MIX.LOAD_VAL + MIX.FAILURE_VAL + MIX.OPT_OUT_VAL + MIX.OVERRIDE_VAL
			END) AS CURRENT_DATA,
			SUM(CASE WHEN p_SERVICE_CODE = CONSTANTS.CODE_BACKCAST OR
								MIX.UNCONSTRAINED_LOAD_VAL IS NULL THEN
							NULL
			WHEN p_SHOW_WITH_LOSSES = 1 THEN
					 MIX.UNCONSTRAINED_LOAD_VAL + NVL(MIX.UNCONSTRAINED_TX_LOSS_VAL, 0) +
						NVL(MIX.UNCONSTRAINED_DX_LOSS_VAL, 0)
			ELSE
					MIX.UNCONSTRAINED_LOAD_VAL
			END) AS CURRENT_UNCONSTRAINED_DATA
		FROM (SELECT SDT.CUT_DATE,
						L.INTERNAL_DATA,
						L.EXTERNAL_DATA,
						L.INTERNAL_UNCONSTRAINED_DATA,
						L.EXTERNAL_UNCONSTRAINED_DATA,
						L.EXTERNAL_SYSTEM_ID,
						L.PROGRAM_ID,
						L.SERVICE_ZONE_ID,
						L.SUB_STATION_ID,
						L.FEEDER_ID,
						L.FEEDER_SEGMENT_ID
					FROM (SELECT DATA.RESULT_DATE,
						SUM(CASE WHEN DATA.LOAD_VAL IS NULL THEN
									NULL
								WHEN IS_EXTERNAL = 0 THEN
									CASE WHEN p_SHOW_WITH_LOSSES = 1 THEN
										 DATA.LOAD_VAL + DATA.FAILURE_VAL + DATA.OPT_OUT_VAL + DATA.OVERRIDE_VAL
											+ DATA.TX_LOSS_VAL + DATA.DX_LOSS_VAL
									ELSE
										DATA.LOAD_VAL + DATA.FAILURE_VAL + DATA.OPT_OUT_VAL + DATA.OVERRIDE_VAL
									END
								ELSE
									0
								END) AS INTERNAL_DATA,
						SUM(CASE WHEN DATA.LOAD_VAL IS NULL THEN
									NULL
								WHEN IS_EXTERNAL = 1 THEN
									CASE WHEN p_SHOW_WITH_LOSSES = 1 THEN
										 DATA.LOAD_VAL + DATA.FAILURE_VAL + DATA.OPT_OUT_VAL + DATA.OVERRIDE_VAL
											+ DATA.TX_LOSS_VAL + DATA.DX_LOSS_VAL
									ELSE
										DATA.LOAD_VAL + DATA.FAILURE_VAL + DATA.OPT_OUT_VAL + DATA.OVERRIDE_VAL
									END
								ELSE
									0
								END) AS EXTERNAL_DATA,
						SUM(CASE WHEN p_SERVICE_CODE = CONSTANTS.CODE_BACKCAST OR
										 DATA.UNCONSTRAINED_LOAD_VAL IS NULL THEN
									NULL
								WHEN IS_EXTERNAL = 0 THEN
									CASE WHEN p_SHOW_WITH_LOSSES = 1 THEN
										 DATA.UNCONSTRAINED_LOAD_VAL + NVL(DATA.UNCONSTRAINED_TX_LOSS_VAL, 0) +
											NVL(DATA.UNCONSTRAINED_DX_LOSS_VAL, 0)
									ELSE
										DATA.UNCONSTRAINED_LOAD_VAL
									END
								ELSE
									0
								END) AS INTERNAL_UNCONSTRAINED_DATA,
						SUM(CASE WHEN p_SERVICE_CODE = CONSTANTS.CODE_BACKCAST OR
										 DATA.UNCONSTRAINED_LOAD_VAL IS NULL THEN
									NULL
								WHEN IS_EXTERNAL = 1 THEN
									CASE WHEN p_SHOW_WITH_LOSSES = 1 THEN
										 DATA.UNCONSTRAINED_LOAD_VAL + NVL(DATA.UNCONSTRAINED_TX_LOSS_VAL, 0) +
											NVL(DATA.UNCONSTRAINED_DX_LOSS_VAL, 0)
									ELSE
										DATA.UNCONSTRAINED_LOAD_VAL
									END
								ELSE
									0
								END) AS EXTERNAL_UNCONSTRAINED_DATA,
						RST.EXTERNAL_SYSTEM_ID,
						RST.PROGRAM_ID,
						RST.SERVICE_ZONE_ID,
						RST.SUB_STATION_ID,
						RST.FEEDER_ID,
						RST.FEEDER_SEGMENT_ID
				FROM DER_SEGMENT_RESULT RST, DER_SEGMENT_RESULT_DATA DATA,
					TABLE(CAST(v_IDS AS ID_TABLE)) X, VIRTUAL_POWER_PLANT VPP
				WHERE  DATA.RESULT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
					AND RST.FEEDER_SEGMENT_ID = p_FEEDER_SEGMENT_ID
					AND (RST.PROGRAM_ID = p_PROGRAM_ID OR p_PROGRAM_ID = CONSTANTS.ALL_ID)
					AND (RST.EXTERNAL_SYSTEM_ID = p_EXTERNAL_SYSTEM_ID
						OR p_EXTERNAL_SYSTEM_ID = CONSTANTS.ALL_ID)
					AND (RST.PROGRAM_ID = X.ID OR X.ID = SD.g_ALL_DATA_ENTITY_ID)
					AND (RST.SERVICE_ZONE_ID = p_SERVICE_ZONE_ID OR p_SERVICE_ZONE_ID = CONSTANTS.ALL_ID)
					AND (VPP.PROGRAM_ID (+) = RST.PROGRAM_ID)
					AND (VPP.SERVICE_ZONE_ID (+) = RST.SERVICE_ZONE_ID)
					AND (VPP.VPP_ID = p_VPP_ID OR p_VPP_ID = CONSTANTS.ALL_ID)
					AND RST.SERVICE_CODE = p_SERVICE_CODE
					AND RST.SCENARIO_ID = p_SCENARIO_ID
					AND DATA.DER_SEGMENT_RESULT_ID = RST.DER_SEGMENT_RESULT_ID
				GROUP BY DATA.RESULT_DATE, RST.EXTERNAL_SYSTEM_ID, RST.PROGRAM_ID, RST.SERVICE_ZONE_ID,
					RST.SUB_STATION_ID, RST.FEEDER_ID, RST.FEEDER_SEGMENT_ID
				ORDER BY DATA.RESULT_DATE) L,
				SYSTEM_DATE_TIME SDT
			WHERE SDT.TIME_ZONE = p_TIME_ZONE
				AND SDT.DATA_INTERVAL_TYPE = 1
				AND SDT.DAY_TYPE = '1'
				AND SDT.CUT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND SDT.MINIMUM_INTERVAL_NUMBER >= v_INTERVAL_NUM
				AND L.RESULT_DATE (+) = SDT.CUT_DATE) LOAD,
			DER_SEGMENT_FORECAST_DATA MIX
		WHERE MIX.FEEDER_SEGMENT_ID (+) = LOAD.FEEDER_SEGMENT_ID
			AND MIX.SUB_STATION_ID (+) = LOAD.SUB_STATION_ID
			AND MIX.FEEDER_ID (+) = LOAD.FEEDER_ID
			AND MIX.SCENARIO_ID (+) = p_SCENARIO_ID
			AND MIX.RESULT_DATE (+) = LOAD.CUT_DATE
			AND MIX.EXTERNAL_SYSTEM_ID (+) = LOAD.EXTERNAL_SYSTEM_ID
			AND MIX.PROGRAM_ID (+) = LOAD.PROGRAM_ID
			AND MIX.SERVICE_ZONE_ID (+) = LOAD.SERVICE_ZONE_ID
		GROUP BY LOAD.CUT_DATE,
			SUBSTR(FROM_CUT_AS_HED(LOAD.CUT_DATE, p_TIME_ZONE, v_INTERVAL),1,10),
			SUBSTR(FROM_CUT_AS_HED(LOAD.CUT_DATE, p_TIME_ZONE, v_INTERVAL),11)
		ORDER BY LOAD.CUT_DATE;

	ELSE

		OPEN p_CURSOR FOR
		SELECT SUBSTR(FROM_CUT_AS_HED(LOAD.CUT_DATE, p_TIME_ZONE, v_INTERVAL),1,10) SCHED_DATE,
			TRIM(SUBSTR(FROM_CUT_AS_HED(LOAD.CUT_DATE, p_TIME_ZONE, v_INTERVAL),11)) SCHED_TIME,
			NVL(IS_EXT.IS_EXTERNAL, 0) AS USE_EXTERNAL,
			LOAD.INTERNAL_DATA,
			LOAD.EXTERNAL_DATA,
			LOAD.INTERNAL_UNCONSTRAINED_DATA,
			LOAD.EXTERNAL_UNCONSTRAINED_DATA,
			LOAD.INTERNAL_DATA - LOAD.EXTERNAL_DATA LOAD_DIFF,
			LOAD.INTERNAL_UNCONSTRAINED_DATA - LOAD.EXTERNAL_UNCONSTRAINED_DATA UNCON_LOAD_DIFF,
			CASE WHEN LOAD.INTERNAL_DATA = 0 AND LOAD.EXTERNAL_DATA <> 0 THEN
				  100
				 WHEN LOAD.INTERNAL_DATA = 0 AND LOAD.EXTERNAL_DATA = 0 THEN
				  0
				 ELSE
				  100*(ABS(LOAD.INTERNAL_DATA - LOAD.EXTERNAL_DATA) / LOAD.INTERNAL_DATA)
			END AS PCT_DIFF,
			CASE WHEN LOAD.INTERNAL_UNCONSTRAINED_DATA = 0 AND LOAD.EXTERNAL_UNCONSTRAINED_DATA <> 0 THEN
				  100
				 WHEN LOAD.INTERNAL_UNCONSTRAINED_DATA = 0 AND LOAD.EXTERNAL_UNCONSTRAINED_DATA = 0 THEN
				  0
				 ELSE
				  100*(ABS(LOAD.INTERNAL_UNCONSTRAINED_DATA - LOAD.EXTERNAL_UNCONSTRAINED_DATA) / LOAD.INTERNAL_UNCONSTRAINED_DATA)
			END AS UNCON_PCT_DIFF
			FROM (SELECT L.INTERNAL_DATA,
					L.EXTERNAL_DATA,
					L.INTERNAL_UNCONSTRAINED_DATA,
					L.EXTERNAL_UNCONSTRAINED_DATA,
					SDT.CUT_DATE,
					L.PROGRAM_ID,
					L.SERVICE_ZONE_ID,
					L.EXTERNAL_SYSTEM_ID
					FROM (SELECT DATA.RESULT_DATE,
						SUM(CASE WHEN DATA.LOAD_VAL IS NULL THEN
									NULL
								WHEN IS_EXTERNAL = 0 THEN
									CASE WHEN p_SHOW_WITH_LOSSES = 1 THEN
										 DATA.LOAD_VAL + DATA.FAILURE_VAL + DATA.OPT_OUT_VAL + DATA.OVERRIDE_VAL
											+ DATA.TX_LOSS_VAL + DATA.DX_LOSS_VAL
									ELSE
										DATA.LOAD_VAL + DATA.FAILURE_VAL + DATA.OPT_OUT_VAL + DATA.OVERRIDE_VAL
									END
								ELSE
									0
								END) AS INTERNAL_DATA,
						SUM(CASE WHEN DATA.LOAD_VAL IS NULL THEN
									NULL
								WHEN IS_EXTERNAL = 1 THEN
									CASE WHEN p_SHOW_WITH_LOSSES = 1 THEN
										 DATA.LOAD_VAL + DATA.FAILURE_VAL + DATA.OPT_OUT_VAL + DATA.OVERRIDE_VAL
											+ DATA.TX_LOSS_VAL + DATA.DX_LOSS_VAL
									ELSE
										DATA.LOAD_VAL + DATA.FAILURE_VAL + DATA.OPT_OUT_VAL + DATA.OVERRIDE_VAL
									END
								ELSE
									0
								END) AS EXTERNAL_DATA,
						SUM(CASE WHEN p_SERVICE_CODE = CONSTANTS.CODE_BACKCAST OR
										 DATA.UNCONSTRAINED_LOAD_VAL IS NULL THEN
									NULL
								WHEN IS_EXTERNAL = 0 THEN
									CASE WHEN p_SHOW_WITH_LOSSES = 1 THEN
										 DATA.UNCONSTRAINED_LOAD_VAL + NVL(DATA.UNCONSTRAINED_TX_LOSS_VAL, 0) +
											NVL(DATA.UNCONSTRAINED_DX_LOSS_VAL, 0)
									ELSE
										DATA.UNCONSTRAINED_LOAD_VAL
									END
								ELSE
									0
								END) AS INTERNAL_UNCONSTRAINED_DATA,
						SUM(CASE WHEN p_SERVICE_CODE = CONSTANTS.CODE_BACKCAST OR
										 DATA.UNCONSTRAINED_LOAD_VAL IS NULL THEN
									NULL
								WHEN IS_EXTERNAL = 1 THEN
									CASE WHEN p_SHOW_WITH_LOSSES = 1 THEN
										 DATA.UNCONSTRAINED_LOAD_VAL + NVL(DATA.UNCONSTRAINED_TX_LOSS_VAL, 0) +
											NVL(DATA.UNCONSTRAINED_DX_LOSS_VAL, 0)
									ELSE
										DATA.UNCONSTRAINED_LOAD_VAL
									END
								ELSE
									0
								END) AS EXTERNAL_UNCONSTRAINED_DATA,
						RST.PROGRAM_ID,
						RST.SERVICE_ZONE_ID,
						RST.EXTERNAL_SYSTEM_ID
						FROM DER_SEGMENT_RESULT RST, DER_SEGMENT_RESULT_DATA DATA,
							TABLE(CAST(v_IDS AS ID_TABLE)) X, VIRTUAL_POWER_PLANT VPP
						WHERE RST.FEEDER_SEGMENT_ID = p_FEEDER_SEGMENT_ID
							AND RST.EXTERNAL_SYSTEM_ID = p_EXTERNAL_SYSTEM_ID
							AND (RST.PROGRAM_ID = p_PROGRAM_ID OR p_PROGRAM_ID = CONSTANTS.ALL_ID)
							AND (RST.SERVICE_ZONE_ID = p_SERVICE_ZONE_ID OR p_SERVICE_ZONE_ID = CONSTANTS.ALL_ID)
							AND VPP.PROGRAM_ID (+) = RST.PROGRAM_ID
							AND VPP.SERVICE_ZONE_ID (+) = RST.SERVICE_ZONE_ID
							AND (VPP.VPP_ID = p_VPP_ID OR p_VPP_ID = CONSTANTS.ALL_ID)
							AND (RST.PROGRAM_ID = X.ID OR X.ID = SD.g_ALL_DATA_ENTITY_ID)
							AND RST.SERVICE_CODE = p_SERVICE_CODE
							AND RST.SCENARIO_ID = p_SCENARIO_ID
							AND DATA.DER_SEGMENT_RESULT_ID = RST.DER_SEGMENT_RESULT_ID
							AND DATA.RESULT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
						GROUP BY DATA.RESULT_DATE, RST.PROGRAM_ID, RST.SERVICE_ZONE_ID, RST.EXTERNAL_SYSTEM_ID
						ORDER BY DATA.RESULT_DATE) L,
						SYSTEM_DATE_TIME SDT
					WHERE SDT.TIME_ZONE = p_TIME_ZONE
					AND SDT.DATA_INTERVAL_TYPE = 1
					AND SDT.DAY_TYPE = '1'
					AND L.RESULT_DATE (+) = SDT.CUT_DATE
					AND SDT.CUT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
					AND SDT.MINIMUM_INTERVAL_NUMBER >= v_INTERVAL_NUM) LOAD,
				DER_SEG_RESULT_IS_EXTERNAL IS_EXT
			WHERE IS_EXT.PROGRAM_ID (+) = LOAD.PROGRAM_ID
				AND IS_EXT.SERVICE_ZONE_ID (+) = LOAD.SERVICE_ZONE_ID
				AND IS_EXT.EXTERNAL_SYSTEM_ID (+) = LOAD.EXTERNAL_SYSTEM_ID
				AND IS_EXT.SCENARIO_ID (+) = p_SCENARIO_ID
				AND LOAD.CUT_DATE BETWEEN IS_EXT.CUT_BEGIN_DATE (+) AND
										IS_EXT.CUT_END_DATE (+)
			ORDER BY LOAD.CUT_DATE;
	END IF;



END SEGMENT_DATA_COMPARE_SEGMENT;
--------------------------------------------------------------------------
PROCEDURE SEGMENT_DATA_SEGMENT_LIST
(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_VPP_ID IN NUMBER,
	p_PROGRAM_ID IN NUMBER,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_SEARCH_STRING IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR,
	p_SERVICE_CODE IN CHAR,
	p_SCENARIO_ID IN NUMBER
) AS

	v_BEGIN_DATE DATE;
	v_END_DATE DATE;

	v_IDS ID_TABLE;

BEGIN

	UT.CUT_DATE_RANGE(CONSTANTS.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE,
		v_BEGIN_DATE, v_END_DATE);

	v_IDS := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_SELECT_DER_RESULTS, EC.ED_PROGRAM);

	-- WE GRAY OUT FEEDER SEGMENTS WITHOUT ANY DATA IN THE GIVEN DATE RANGE
	OPEN p_CURSOR FOR
	SELECT SEG.FEEDER_SEGMENT_ID,
		CASE WHEN EXISTS
				(SELECT 1
				FROM DER_SEGMENT_RESULT RST,
					DER_SEGMENT_RESULT_DATA DATA,
					VIRTUAL_POWER_PLANT VPP,
					TABLE(CAST( v_IDS AS ID_TABLE)) X
				WHERE RST.FEEDER_SEGMENT_ID = SEG.FEEDER_SEGMENT_ID
					AND (RST.EXTERNAL_SYSTEM_ID = p_EXTERNAL_SYSTEM_ID
						OR p_EXTERNAL_SYSTEM_ID = CONSTANTS.ALL_ID)
					AND (RST.PROGRAM_ID = p_PROGRAM_ID OR p_PROGRAM_ID = CONSTANTS.ALL_ID)
					AND (RST.PROGRAM_ID = X.ID OR X.ID = SD.g_ALL_DATA_ENTITY_ID)
					AND (RST.SERVICE_ZONE_ID = p_SERVICE_ZONE_ID OR p_SERVICE_ZONE_ID = CONSTANTS.ALL_ID)
					AND (VPP.PROGRAM_ID (+) = RST.PROGRAM_ID)
					AND (VPP.SERVICE_ZONE_ID (+) = RST.SERVICE_ZONE_ID)
					AND (VPP.VPP_ID = p_VPP_ID OR p_VPP_ID = CONSTANTS.ALL_ID)
					AND RST.SCENARIO_ID = p_SCENARIO_ID
					AND RST.SERVICE_CODE = p_SERVICE_CODE
					AND DATA.DER_SEGMENT_RESULT_ID = RST.DER_SEGMENT_RESULT_ID
					AND DATA.RESULT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE) THEN
			SEG.FEEDER_SEGMENT_NAME
		ELSE
			'<HTML><font color="gray"><i>' || SEG.FEEDER_SEGMENT_NAME || '</i></font></html'
		END
	FROM (SELECT DISTINCT FS.FEEDER_SEGMENT_ID, FS.FEEDER_SEGMENT_NAME
		FROM VIRTUAL_POWER_PLANT VPP, SERVICE_ZONE SZ, TX_SUB_STATION SS,
			TX_FEEDER F, TX_FEEDER_SEGMENT FS
		WHERE (VPP.VPP_ID = p_VPP_ID OR p_VPP_ID = CONSTANTS.ALL_ID)
			AND VPP.SERVICE_ZONE_ID (+) = SZ.SERVICE_ZONE_ID
			AND (SZ.SERVICE_ZONE_ID = p_SERVICE_ZONE_ID OR p_SERVICE_ZONE_ID = CONSTANTS.ALL_ID)
			AND SS.SERVICE_ZONE_ID = SZ.SERVICE_ZONE_ID
			AND SS.BEGIN_DATE <= p_END_DATE
			AND NVL(SS.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND F.SUB_STATION_ID = SS.SUB_STATION_ID
			AND F.BEGIN_DATE <= p_END_DATE
			AND NVL(F.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND FS.FEEDER_ID = F.FEEDER_ID
			AND FS.BEGIN_DATE <= p_END_DATE
			AND NVL(FS.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND FS.FEEDER_SEGMENT_NAME LIKE p_SEARCH_STRING
		UNION ALL
		SELECT FS.FEEDER_SEGMENT_ID, FS.FEEDER_SEGMENT_NAME
		FROM TX_FEEDER_SEGMENT FS
		WHERE FS.FEEDER_SEGMENT_ID = CONSTANTS.NOT_ASSIGNED
			AND FS.FEEDER_SEGMENT_NAME LIKE p_SEARCH_STRING
			AND p_SERVICE_ZONE_ID <> CONSTANTS.ALL_ID
		ORDER BY FEEDER_SEGMENT_NAME) SEG;

END SEGMENT_DATA_SEGMENT_LIST;
--------------------------------------------------------------------------
PROCEDURE SEGMENT_DATA_VPP_LIST
(
	p_PROGRAM_ID IN NUMBER,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
) AS

	v_IDS ID_TABLE;

BEGIN

	v_IDS := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_SELECT_DER_RESULTS, EC.ED_PROGRAM);

	OPEN p_CURSOR FOR
	SELECT VPP.VPP_ID, VPP.VPP_NAME
	FROM VIRTUAL_POWER_PLANT VPP, TABLE(CAST(v_IDS AS ID_TABLE)) X
	WHERE (VPP.PROGRAM_ID = p_PROGRAM_ID OR p_PROGRAM_ID = CONSTANTS.ALL_ID)
		AND (VPP.SERVICE_ZONE_ID = p_SERVICE_ZONE_ID OR p_SERVICE_ZONE_ID = CONSTANTS.ALL_ID)
		AND (VPP.PROGRAM_ID = X.ID OR X.ID = SD.g_ALL_DATA_ENTITY_ID);

END SEGMENT_DATA_VPP_LIST;
--------------------------------------------------------------------------
PROCEDURE SERVICE_ZONE_LIST
	(
	p_SEARCH_STRING      	IN VARCHAR,
	p_SEARCH_OPTION      	IN VARCHAR,
	p_SEARCH_TYPE       	IN NUMBER,
	p_FIND_SERVICE_ZONE_ID  IN NUMBER,
	p_SEARCH_OPTION_NAME 	OUT VARCHAR2,
	p_CURSOR     			IN OUT GA.REFCURSOR
	) AS
	v_IDS ID_TABLE;
	v_IS_ALLOWED BOOLEAN;
BEGIN
	-- This procedure supports the following search options:
	--      By Name
	--      By Alias
	--      By External Identifier

	-- Data Level Security
	v_IDS := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_SELECT_ENT, EC.ED_SERVICE_ZONE);

	-- Set the Search Option Name which is used in the Colummn Display Formula of
	-- the SEARCH_NAME column in the Numerous Find results grid.
	CASE p_SEARCH_OPTION
		WHEN 'By Alias' THEN
			p_SEARCH_OPTION_NAME := 'Alias';
		WHEN 'By External Identifier' THEN
			p_SEARCH_OPTION_NAME := 'External Identifier';
		ELSE
			p_SEARCH_OPTION_NAME := 'Name';
	END CASE;

	-- Normal Search
	IF p_SEARCH_TYPE IS NULL OR p_SEARCH_TYPE = CONSTANTS.SEARCH_TYPE_NORMAL THEN
		-- Return all records (no LIKE clause)
		-- We still return the SEARCH_NAME column in case this is a '%' in the Find Dialog.
		IF p_SEARCH_STRING = '%' OR p_SEARCH_STRING IS NULL THEN
			IF p_SEARCH_OPTION IS NULL OR p_SEARCH_OPTION = 'By Name' OR p_SEARCH_OPTION = 'By Alias' OR p_SEARCH_OPTION = 'By External Identifier' THEN
				OPEN p_CURSOR FOR
					SELECT CASE p_SEARCH_OPTION
							   WHEN 'By Alias' THEN
									S.SERVICE_ZONE_ALIAS
							   WHEN 'By External Identifier' THEN
									S.EXTERNAL_IDENTIFIER
							   ELSE
								NULL
						   END AS SEARCH_NAME,
						   S.SERVICE_ZONE_ID,
						   S.SERVICE_ZONE_NAME
					FROM SERVICE_ZONE S, TABLE(CAST(v_IDS AS ID_TABLE)) X
					WHERE X.ID IN (S.SERVICE_ZONE_ID, SD.g_ALL_DATA_ENTITY_ID)
						AND SERVICE_ZONE_ID > 0
					ORDER BY SEARCH_NAME, SERVICE_ZONE_NAME;
			END IF;
		ELSE
			IF p_SEARCH_OPTION IS NULL OR p_SEARCH_OPTION = 'By Name' OR p_SEARCH_OPTION = 'By Alias' OR p_SEARCH_OPTION = 'By Display Name' OR
			   p_SEARCH_OPTION = 'By External Identifier' THEN
				OPEN p_CURSOR FOR
					SELECT CASE p_SEARCH_OPTION
							   WHEN 'By Alias' THEN
								S.SERVICE_ZONE_ALIAS
							   WHEN 'By External Identifier' THEN
								S.EXTERNAL_IDENTIFIER
							   ELSE
								NULL
						   END AS SEARCH_NAME,
						   S.SERVICE_ZONE_ID,
						   S.SERVICE_ZONE_NAME
					FROM SERVICE_ZONE S, TABLE(CAST(v_IDS AS ID_TABLE)) X
					WHERE X.ID IN (S.SERVICE_ZONE_ID, SD.g_ALL_DATA_ENTITY_ID)
						  AND ((p_SEARCH_OPTION = 'By Name' AND S.SERVICE_ZONE_NAME LIKE p_SEARCH_STRING) OR
						  (p_SEARCH_OPTION = 'By Alias' AND S.SERVICE_ZONE_ALIAS LIKE p_SEARCH_STRING) OR
						  (p_SEARCH_OPTION = 'By External Identifier' AND
						  S.EXTERNAL_IDENTIFIER LIKE p_SEARCH_STRING))
						  AND SERVICE_ZONE_ID > 0
					ORDER BY SEARCH_NAME DESC;
			END IF;
		END IF;
	-- Specific Value
	ELSIF p_SEARCH_TYPE = CONSTANTS.SEARCH_TYPE_BY_VAL THEN
		v_IS_ALLOWED := SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_FIND_SERVICE_ZONE_ID, EC.ED_SERVICE_ZONE);
		IF v_IS_ALLOWED THEN
			OPEN p_CURSOR FOR
				SELECT S.SERVICE_ZONE_ID,S.SERVICE_ZONE_NAME
				FROM SERVICE_ZONE S
				WHERE S.SERVICE_ZONE_ID = p_FIND_SERVICE_ZONE_ID
					AND SERVICE_ZONE_ID > 0;
		ELSE
			OPEN p_CURSOR FOR
				SELECT NULL FROM DUAL;
		END IF;
	END IF;
END;
--------------------------------------------------------------------------
PROCEDURE SUB_STATION_LIST
	(
	p_SERVICE_ZONE_ID 		IN NUMBER,
	p_BEGIN_DATE 			IN DATE,
	p_END_DATE   			IN DATE,
	p_SEARCH_STRING      	IN VARCHAR,
	p_SEARCH_OPTION      	IN VARCHAR,
	p_SEARCH_TYPE       	IN NUMBER,
	p_FIND_SUB_STATION_ID  	IN NUMBER,
	p_SEARCH_OPTION_NAME 	OUT VARCHAR2,
	p_CURSOR     			IN OUT GA.REFCURSOR
	) AS
BEGIN
	-- This procedure supports the following search options:
	--      By Name
	--      By Alias
	--      By External Identifier

	-- Data Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_SERVICE_ZONE_ID, EC.ED_SERVICE_ZONE);

	-- Set the Search Option Name which is used in the Colummn Display Formula of
	-- the SEARCH_NAME column in the Numerous Find results grid.
	CASE p_SEARCH_OPTION
		WHEN 'By Alias' THEN
			p_SEARCH_OPTION_NAME := 'Alias';
		WHEN 'By External Identifier' THEN
			p_SEARCH_OPTION_NAME := 'External Identifier';
		ELSE
			p_SEARCH_OPTION_NAME := 'Name';
	END CASE;

	-- Normal Search
	IF p_SEARCH_TYPE IS NULL OR p_SEARCH_TYPE = CONSTANTS.SEARCH_TYPE_NORMAL THEN
		-- Return all records (no LIKE clause)
		-- We still return the SEARCH_NAME column in case this is a '%' in the Find Dialog.
		IF p_SEARCH_STRING = '%' OR p_SEARCH_STRING IS NULL THEN
			OPEN p_CURSOR FOR
				SELECT SS.SUB_STATION_ID,
					SS.SUB_STATION_NAME,
					CASE p_SEARCH_OPTION
						WHEN 'By Alias' THEN
					SS.SUB_STATION_ALIAS
						WHEN 'By External Identifier' THEN
					SS.EXTERNAL_IDENTIFIER
					ELSE
						NULL
					END AS SEARCH_NAME
				FROM SERVICE_ZONE SZ, TX_SUB_STATION SS
				WHERE SZ.SERVICE_ZONE_ID = p_SERVICE_ZONE_ID
					AND SS.SERVICE_ZONE_ID = SZ.SERVICE_ZONE_ID
					AND NVL(SS.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND SS.BEGIN_DATE <= p_END_DATE
				ORDER BY 2;
		ELSE
			OPEN p_CURSOR FOR
				SELECT SS.SUB_STATION_ID,
					SS.SUB_STATION_NAME,
					CASE p_SEARCH_OPTION
						WHEN 'By Alias' THEN
					SS.SUB_STATION_ALIAS
						WHEN 'By External Identifier' THEN
					SS.EXTERNAL_IDENTIFIER
					ELSE
						NULL
					END AS SEARCH_NAME
				FROM SERVICE_ZONE SZ, TX_SUB_STATION SS
				WHERE SZ.SERVICE_ZONE_ID = p_SERVICE_ZONE_ID
					AND SS.SERVICE_ZONE_ID = SZ.SERVICE_ZONE_ID
					AND NVL(SS.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND SS.BEGIN_DATE <= p_END_DATE
					AND ((p_SEARCH_OPTION = 'By Name' AND SS.SUB_STATION_NAME LIKE p_SEARCH_STRING) OR
					(p_SEARCH_OPTION = 'By Alias' AND SS.SUB_STATION_ALIAS LIKE p_SEARCH_STRING) OR
					(p_SEARCH_OPTION = 'By External Identifier' AND SS.EXTERNAL_IDENTIFIER LIKE p_SEARCH_STRING))
				ORDER BY 2;
		END IF;
	-- Specific Value
	ELSIF p_SEARCH_TYPE = CONSTANTS.SEARCH_TYPE_BY_VAL THEN
		OPEN p_CURSOR FOR
			SELECT SS.SUB_STATION_ID,
					SS.SUB_STATION_NAME
			FROM SERVICE_ZONE SZ, TX_SUB_STATION SS
			WHERE SS.SERVICE_ZONE_ID = SZ.SERVICE_ZONE_ID
				AND SS.SUB_STATION_ID = p_FIND_SUB_STATION_ID
			ORDER BY 2;
	END IF;
END;
--------------------------------------------------------------------------
PROCEDURE SUB_STATION_METER_LIST
	(
	p_SERVICE_ZONE_ID 		IN NUMBER,
	p_SUB_STATION_ID		IN NUMBER,
	p_BEGIN_DATE 			IN DATE,
	p_END_DATE   			IN DATE,
	p_SEARCH_STRING      	IN VARCHAR,
	p_SEARCH_OPTION      	IN VARCHAR,
	p_SEARCH_TYPE       	IN NUMBER,
	p_FIND_SUB_STATION_METER_ID 	IN NUMBER,
	p_SEARCH_OPTION_NAME 	OUT VARCHAR2,
	p_CURSOR     			IN OUT GA.REFCURSOR
	) AS
BEGIN
	-- This procedure supports the following search options:
	--      By Name
	--      By Alias
	--      By External Identifier

	-- Data Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_SERVICE_ZONE_ID, EC.ED_SERVICE_ZONE);
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_SUB_STATION_ID, EC.ED_SUB_STATION);

	-- Set the Search Option Name which is used in the Colummn Display Formula of
	-- the SEARCH_NAME column in the Numerous Find results grid.
	CASE p_SEARCH_OPTION
		WHEN 'By Alias' THEN
			p_SEARCH_OPTION_NAME := 'Alias';
		WHEN 'By External Identifier' THEN
			p_SEARCH_OPTION_NAME := 'External Identifier';
		ELSE
			p_SEARCH_OPTION_NAME := 'Name';
	END CASE;

	-- Normal Search
	IF p_SEARCH_TYPE IS NULL OR p_SEARCH_TYPE = CONSTANTS.SEARCH_TYPE_NORMAL THEN
		-- Return all records (no LIKE clause)
		-- We still return the SEARCH_NAME column in case this is a '%' in the Find Dialog.
		IF p_SEARCH_STRING = '%' OR p_SEARCH_STRING IS NULL THEN
			OPEN p_CURSOR FOR
				SELECT SM.METER_ID AS SUB_STATION_METER_ID,
					   SM.METER_NAME AS SUB_STATION_METER_NAME,
					   CASE p_SEARCH_OPTION
						   WHEN 'By Alias' THEN
							SM.METER_ALIAS
						   WHEN 'By External Identifier' THEN
							SM.EXTERNAL_IDENTIFIER
						   ELSE
							NULL
					   END AS SEARCH_NAME
				FROM SERVICE_ZONE SZ, TX_SUB_STATION SS, TX_SUB_STATION_METER SM
				WHERE SZ.SERVICE_ZONE_ID = p_SERVICE_ZONE_ID
					AND SS.SERVICE_ZONE_ID = SZ.SERVICE_ZONE_ID
					AND NVL(SS.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND SS.BEGIN_DATE <= p_END_DATE
					AND SS.SUB_STATION_ID = p_SUB_STATION_ID
					AND SM.SUB_STATION_ID = SS.SUB_STATION_ID
					AND NVL(SM.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND SM.BEGIN_DATE <= p_END_DATE
				ORDER BY 2;
		ELSE
			OPEN p_CURSOR FOR
				SELECT SM.METER_ID AS SUB_STATION_METER_ID,
					   SM.METER_NAME AS SUB_STATION_METER_NAME,
					CASE p_SEARCH_OPTION
						   WHEN 'By Alias' THEN
							SM.METER_ALIAS
						   WHEN 'By External Identifier' THEN
							SM.EXTERNAL_IDENTIFIER
						   ELSE
							NULL
					   END AS SEARCH_NAME
				FROM SERVICE_ZONE SZ, TX_SUB_STATION SS, TX_SUB_STATION_METER SM
				WHERE SZ.SERVICE_ZONE_ID = p_SERVICE_ZONE_ID
					AND SS.SERVICE_ZONE_ID = SZ.SERVICE_ZONE_ID
					AND NVL(SS.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND SS.BEGIN_DATE <= p_END_DATE
					AND SS.SUB_STATION_ID = p_SUB_STATION_ID
					AND SM.SUB_STATION_ID = SS.SUB_STATION_ID
					AND SM.SUB_STATION_ID = SS.SUB_STATION_ID
					AND NVL(SM.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND ((p_SEARCH_OPTION = 'By Name' AND SM.METER_NAME LIKE p_SEARCH_STRING) OR
					(p_SEARCH_OPTION = 'By Alias' AND SM.METER_ALIAS LIKE p_SEARCH_STRING) OR
					(p_SEARCH_OPTION = 'By External Identifier' AND SM.EXTERNAL_IDENTIFIER LIKE p_SEARCH_STRING))
				ORDER BY 2;
		END IF;
	-- Specific Value
	ELSIF p_SEARCH_TYPE = CONSTANTS.SEARCH_TYPE_BY_VAL THEN
		OPEN p_CURSOR FOR
			SELECT SM.METER_ID AS SUB_STATION_METER_ID,
					SM.METER_NAME AS SUB_STATION_METER_NAME
			FROM SERVICE_ZONE SZ, TX_SUB_STATION SS, TX_SUB_STATION_METER SM
			WHERE SS.SERVICE_ZONE_ID = SZ.SERVICE_ZONE_ID
				  AND SM.SUB_STATION_ID = SS.SUB_STATION_ID
				  AND SM.METER_ID = p_FIND_SUB_STATION_METER_ID
			ORDER BY 2;
	END IF;
END;
--------------------------------------------------------------------------
PROCEDURE METER_POINT_LIST
	(
	p_SERVICE_ZONE_ID 		IN NUMBER,
	p_SUB_STATION_ID		IN NUMBER,
	p_SUB_STATION_METER_ID	IN NUMBER,
	p_BEGIN_DATE 			IN DATE,
	p_END_DATE   			IN DATE,
	p_SEARCH_STRING      	IN VARCHAR,
	p_SEARCH_OPTION      	IN VARCHAR,
	p_SEARCH_TYPE       	IN NUMBER,
	p_FIND_METER_POINT_ID  	IN NUMBER,
	p_SEARCH_OPTION_NAME 	OUT VARCHAR2,
	p_CURSOR     			IN OUT GA.REFCURSOR
	) AS
BEGIN
	-- This procedure supports the following search options:
	--      By Name
	--      By Alias
	--      By External Identifier

	-- Data Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_SERVICE_ZONE_ID, EC.ED_SERVICE_ZONE);
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_SUB_STATION_ID, EC.ED_SUB_STATION);
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_SUB_STATION_METER_ID, EC.ED_SUB_STATION_METER);

	-- Set the Search Option Name which is used in the Colummn Display Formula of
	-- the SEARCH_NAME column in the Numerous Find results grid.
	CASE p_SEARCH_OPTION
		WHEN 'By Alias' THEN
			p_SEARCH_OPTION_NAME := 'Alias';
		WHEN 'By External Identifier' THEN
			p_SEARCH_OPTION_NAME := 'External Identifier';
		ELSE
			p_SEARCH_OPTION_NAME := 'Name';
	END CASE;

	-- Normal Search
	IF p_SEARCH_TYPE IS NULL OR p_SEARCH_TYPE = CONSTANTS.SEARCH_TYPE_NORMAL THEN
		-- Return all records (no LIKE clause)
		-- We still return the SEARCH_NAME column in case this is a '%' in the Find Dialog.
		IF p_SEARCH_STRING = '%' OR p_SEARCH_STRING IS NULL THEN
			OPEN p_CURSOR FOR
				SELECT MP.METER_POINT_ID,
					   MP.METER_POINT_NAME,
					   CASE p_SEARCH_OPTION
						   WHEN 'By Alias' THEN
							SM.METER_ALIAS
						   WHEN 'By External Identifier' THEN
							SM.EXTERNAL_IDENTIFIER
						   ELSE
							NULL
					   END AS SEARCH_NAME
				FROM SERVICE_ZONE SZ, TX_SUB_STATION SS,
					TX_SUB_STATION_METER SM, TX_SUB_STATION_METER_POINT MP
				WHERE SZ.SERVICE_ZONE_ID = p_SERVICE_ZONE_ID
					AND SS.SERVICE_ZONE_ID = SZ.SERVICE_ZONE_ID
					AND NVL(SS.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND SS.BEGIN_DATE <= p_END_DATE
					AND SS.SUB_STATION_ID = p_SUB_STATION_ID
					AND NVL(SM.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND SM.BEGIN_DATE <= p_END_DATE
					AND SM.SUB_STATION_ID = SS.SUB_STATION_ID
					AND SM.METER_ID = p_SUB_STATION_METER_ID
					AND MP.SUB_STATION_METER_ID = SM.METER_ID
					AND NVL(MP.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND MP.BEGIN_DATE <= p_END_DATE
				ORDER BY 2;
		ELSE
			OPEN p_CURSOR FOR
				SELECT MP.METER_POINT_ID,
					   MP.METER_POINT_NAME,
					CASE p_SEARCH_OPTION
						   WHEN 'By Alias' THEN
							SM.METER_ALIAS
						   WHEN 'By External Identifier' THEN
							SM.EXTERNAL_IDENTIFIER
						   ELSE
							NULL
					   END AS SEARCH_NAME
				FROM SERVICE_ZONE SZ, TX_SUB_STATION SS,
					TX_SUB_STATION_METER SM, TX_SUB_STATION_METER_POINT MP
				WHERE SZ.SERVICE_ZONE_ID = p_SERVICE_ZONE_ID
					AND SS.SERVICE_ZONE_ID = SZ.SERVICE_ZONE_ID
					AND NVL(SS.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND SS.BEGIN_DATE <= p_END_DATE
					AND SS.SUB_STATION_ID = p_SUB_STATION_ID
					AND SM.SUB_STATION_ID = SS.SUB_STATION_ID
					AND NVL(SM.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND SM.BEGIN_DATE <= p_END_DATE
					AND MP.SUB_STATION_METER_ID = SM.METER_ID
					AND NVL(MP.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND MP.BEGIN_DATE <= p_END_DATE
					  AND ((p_SEARCH_OPTION = 'By Name' AND MP.METER_POINT_NAME LIKE p_SEARCH_STRING) OR
					  (p_SEARCH_OPTION = 'By Alias' AND MP.METER_POINT_ALIAS LIKE p_SEARCH_STRING) OR
					  (p_SEARCH_OPTION = 'By External Identifier' AND MP.EXTERNAL_IDENTIFIER LIKE p_SEARCH_STRING))
				ORDER BY 2;
		END IF;
	-- Specific Value
	ELSIF p_SEARCH_TYPE = CONSTANTS.SEARCH_TYPE_BY_VAL THEN
		OPEN p_CURSOR FOR
			SELECT SM.METER_ID AS SUB_STATION_METER_ID,
					SM.METER_NAME AS SUB_STATION_METER_NAME
			FROM SERVICE_ZONE SZ, TX_SUB_STATION SS,
				TX_SUB_STATION_METER SM, TX_SUB_STATION_METER_POINT MP
			WHERE SS.SERVICE_ZONE_ID = SZ.SERVICE_ZONE_ID
				  AND SM.SUB_STATION_ID = SS.SUB_STATION_ID
				  AND SM.METER_ID = MP.SUB_STATION_METER_ID
				  AND MP.METER_POINT_ID = p_FIND_METER_POINT_ID
			ORDER BY 2;
	END IF;
END;
--------------------------------------------------------------------------
PROCEDURE FEEDER_LIST
	(
	p_SERVICE_ZONE_ID 	IN NUMBER,
	p_SUB_STATION_ID	IN NUMBER,
	p_BEGIN_DATE 		IN DATE,
	p_END_DATE   		IN DATE,
	p_SEARCH_STRING     IN VARCHAR,
	p_SEARCH_OPTION     IN VARCHAR,
	p_SEARCH_TYPE       IN NUMBER,
	p_FIND_FEEDER_ID    IN NUMBER,
	p_SEARCH_OPTION_NAME 	OUT VARCHAR2,
	p_CURSOR     		IN OUT GA.REFCURSOR
	) AS
BEGIN
	-- This procedure supports the following search options:
	--      By Name
	--      By Alias
	--      By External Identifier

	-- Data Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_SERVICE_ZONE_ID, EC.ED_SERVICE_ZONE);
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_SUB_STATION_ID, EC.ED_SUB_STATION);

	-- Set the Search Option Name which is used in the Colummn Display Formula of
	-- the SEARCH_NAME column in the Numerous Find results grid.
	CASE p_SEARCH_OPTION
		WHEN 'By Alias' THEN
			p_SEARCH_OPTION_NAME := 'Alias';
		WHEN 'By External Identifier' THEN
			p_SEARCH_OPTION_NAME := 'External Identifier';
		ELSE
			p_SEARCH_OPTION_NAME := 'Name';
	END CASE;

	-- Normal Search
	IF p_SEARCH_TYPE IS NULL OR p_SEARCH_TYPE = CONSTANTS.SEARCH_TYPE_NORMAL THEN
		-- Return all records (no LIKE clause)
		-- We still return the SEARCH_NAME column in case this is a '%' in the Find Dialog.
		IF p_SEARCH_STRING = '%' OR p_SEARCH_STRING IS NULL THEN
			OPEN p_CURSOR FOR
				SELECT F.FEEDER_ID,
					   F.FEEDER_NAME,
					   CASE p_SEARCH_OPTION
						   WHEN 'By Alias' THEN
							F.FEEDER_ALIAS
						   WHEN 'By External Identifier' THEN
							F.EXTERNAL_IDENTIFIER
						   ELSE
							NULL
					   END AS SEARCH_NAME
				FROM SERVICE_ZONE SZ, TX_SUB_STATION SS, TX_FEEDER F
				WHERE SZ.SERVICE_ZONE_ID = p_SERVICE_ZONE_ID
					AND SS.SERVICE_ZONE_ID = SZ.SERVICE_ZONE_ID
					AND NVL(SS.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND SS.BEGIN_DATE <= p_END_DATE
					AND SS.SUB_STATION_ID = p_SUB_STATION_ID
					AND F.SUB_STATION_ID = SS.SUB_STATION_ID
					AND NVL(F.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND F.BEGIN_DATE <= p_END_DATE
				ORDER BY 2;
		ELSE
			OPEN p_CURSOR FOR
				SELECT F.FEEDER_ID,
					F.FEEDER_NAME,
					CASE p_SEARCH_OPTION
						   WHEN 'By Alias' THEN
							F.FEEDER_ALIAS
						   WHEN 'By External Identifier' THEN
							F.EXTERNAL_IDENTIFIER
						   ELSE
							NULL
					   END AS SEARCH_NAME
				FROM SERVICE_ZONE SZ, TX_SUB_STATION SS, TX_FEEDER F
				WHERE SZ.SERVICE_ZONE_ID = p_SERVICE_ZONE_ID
					AND SS.SERVICE_ZONE_ID = SZ.SERVICE_ZONE_ID
					AND NVL(SS.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND SS.BEGIN_DATE <= p_END_DATE
					AND SS.SUB_STATION_ID = p_SUB_STATION_ID
					AND F.SUB_STATION_ID = SS.SUB_STATION_ID
					AND NVL(F.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND F.BEGIN_DATE <= p_END_DATE
					  AND ((p_SEARCH_OPTION = 'By Name' AND F.FEEDER_NAME LIKE p_SEARCH_STRING) OR
					  (p_SEARCH_OPTION = 'By Alias' AND F.FEEDER_ALIAS LIKE p_SEARCH_STRING) OR
					  (p_SEARCH_OPTION = 'By External Identifier' AND F.EXTERNAL_IDENTIFIER LIKE p_SEARCH_STRING))
				ORDER BY 2;
		END IF;
	-- Specific Value
	ELSIF p_SEARCH_TYPE = CONSTANTS.SEARCH_TYPE_BY_VAL THEN
		OPEN p_CURSOR FOR
			SELECT F.FEEDER_ID,
				F.FEEDER_NAME
			FROM SERVICE_ZONE SZ, TX_SUB_STATION SS, TX_FEEDER F
			WHERE SS.SERVICE_ZONE_ID = SZ.SERVICE_ZONE_ID
				  AND F.SUB_STATION_ID = SS.SUB_STATION_ID
				  AND F.FEEDER_ID = p_FIND_FEEDER_ID
			ORDER BY 2;
	END IF;
END;
--------------------------------------------------------------------------
PROCEDURE FEEDER_SEGMENT_LIST
	(
	p_SERVICE_ZONE_ID 	IN NUMBER,
	p_SUB_STATION_ID	IN NUMBER,
	p_FEEDER_ID			IN NUMBER,
	p_BEGIN_DATE 		IN DATE,
	p_END_DATE   		IN DATE,
	p_SEARCH_STRING     IN VARCHAR,
	p_SEARCH_OPTION     IN VARCHAR,
	p_SEARCH_TYPE       IN NUMBER,
	p_FIND_FEEDER_SEGMENT_ID IN NUMBER,
	p_SEARCH_OPTION_NAME 	OUT VARCHAR2,
	p_CURSOR     		IN OUT GA.REFCURSOR
	) AS
BEGIN
	-- This procedure supports the following search options:
	--      By Name
	--      By Alias
	--      By External Identifier

	-- Data Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_SERVICE_ZONE_ID, EC.ED_SERVICE_ZONE);
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_SUB_STATION_ID, EC.ED_SUB_STATION);
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_FEEDER_ID, EC.ED_TX_FEEDER);

	-- Set the Search Option Name which is used in the Colummn Display Formula of
	-- the SEARCH_NAME column in the Numerous Find results grid.
	CASE p_SEARCH_OPTION
		WHEN 'By Alias' THEN
			p_SEARCH_OPTION_NAME := 'Alias';
		WHEN 'By External Identifier' THEN
			p_SEARCH_OPTION_NAME := 'External Identifier';
		ELSE
			p_SEARCH_OPTION_NAME := 'Name';
	END CASE;

	-- Normal Search
	IF p_SEARCH_TYPE IS NULL OR p_SEARCH_TYPE = CONSTANTS.SEARCH_TYPE_NORMAL THEN
		-- Return all records (no LIKE clause)
		-- We still return the SEARCH_NAME column in case this is a '%' in the Find Dialog.
		IF p_SEARCH_STRING = '%' OR p_SEARCH_STRING IS NULL THEN
			OPEN p_CURSOR FOR
				SELECT FS.FEEDER_SEGMENT_ID,
					   FS.FEEDER_SEGMENT_NAME,
					   CASE p_SEARCH_OPTION
						   WHEN 'By Alias' THEN
							FS.FEEDER_SEGMENT_ALIAS
						   WHEN 'By External Identifier' THEN
							FS.EXTERNAL_IDENTIFIER
						   ELSE
							NULL
					   END AS SEARCH_NAME
				FROM SERVICE_ZONE SZ, TX_SUB_STATION SS,
					TX_FEEDER F, TX_FEEDER_SEGMENT FS
				WHERE SZ.SERVICE_ZONE_ID = p_SERVICE_ZONE_ID
					AND SS.SERVICE_ZONE_ID = SZ.SERVICE_ZONE_ID
					AND NVL(SS.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND SS.BEGIN_DATE <= p_END_DATE
					AND SS.SUB_STATION_ID = p_SUB_STATION_ID
					AND F.SUB_STATION_ID = SS.SUB_STATION_ID
					AND NVL(F.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND F.BEGIN_DATE <= p_END_DATE
					AND F.FEEDER_ID = p_FEEDER_ID
					AND FS.FEEDER_ID = F.FEEDER_ID
					AND NVL(FS.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND FS.BEGIN_DATE <= p_END_DATE
				ORDER BY 2;
		ELSE
			OPEN p_CURSOR FOR
				SELECT FS.FEEDER_SEGMENT_ID,
					FS.FEEDER_SEGMENT_NAME,
					CASE p_SEARCH_OPTION
						   WHEN 'By Alias' THEN
							FS.FEEDER_SEGMENT_ALIAS
						   WHEN 'By External Identifier' THEN
							FS.EXTERNAL_IDENTIFIER
						   ELSE
							NULL
					   END AS SEARCH_NAME
				FROM SERVICE_ZONE SZ, TX_SUB_STATION SS,
					TX_FEEDER F, TX_FEEDER_SEGMENT FS
				WHERE SZ.SERVICE_ZONE_ID = p_SERVICE_ZONE_ID
					AND SS.SERVICE_ZONE_ID = SZ.SERVICE_ZONE_ID
					AND NVL(SS.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND SS.BEGIN_DATE <= p_END_DATE
					AND SS.SUB_STATION_ID = p_SUB_STATION_ID
					AND F.SUB_STATION_ID = SS.SUB_STATION_ID
					AND NVL(F.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND F.BEGIN_DATE <= p_END_DATE
					AND FS.FEEDER_ID = F.FEEDER_ID
					AND NVL(FS.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND FS.BEGIN_DATE <= p_END_DATE
					  AND ((p_SEARCH_OPTION = 'By Name' AND FS.FEEDER_SEGMENT_NAME LIKE p_SEARCH_STRING) OR
					  (p_SEARCH_OPTION = 'By Alias' AND FS.FEEDER_SEGMENT_ALIAS LIKE p_SEARCH_STRING)
					  OR (p_SEARCH_OPTION = 'By External Identifier' AND FS.EXTERNAL_IDENTIFIER LIKE p_SEARCH_STRING))
				ORDER BY 2;
		END IF;
	-- Specific Value
	ELSIF p_SEARCH_TYPE = CONSTANTS.SEARCH_TYPE_BY_VAL THEN
		OPEN p_CURSOR FOR
			SELECT FS.FEEDER_SEGMENT_ID,
				FS.FEEDER_SEGMENT_NAME
			FROM SERVICE_ZONE SZ, TX_SUB_STATION SS,
				TX_FEEDER F, TX_FEEDER_SEGMENT FS
			WHERE SS.SERVICE_ZONE_ID = SZ.SERVICE_ZONE_ID
				  AND F.SUB_STATION_ID = SS.SUB_STATION_ID
				  AND F.FEEDER_ID = FS.FEEDER_ID
				  AND FS.FEEDER_SEGMENT_ID = p_FIND_FEEDER_SEGMENT_ID
			ORDER BY 2;
	END IF;
END;
--------------------------------------------------------------------------------
PROCEDURE DELETE_TRANS_NETWORK_ENTITY
	(
	p_ENTITY_TYPE IN VARCHAR2,
	p_ENTITY_ID IN NUMBER
	) AS
v_STATUS NUMBER(9);
BEGIN
	IF p_ENTITY_TYPE = 'SERVICE_ZONE' THEN
		DE.DEL_SERVICE_ZONE(p_ENTITY_ID, v_STATUS);
		ERRS.VALIDATE_STATUS('DE.DEL_SERVICE_ZONE', v_STATUS);
	ELSIF p_ENTITY_TYPE = 'SUB_STATION' THEN
		DE.DEL_SUB_STATION(p_ENTITY_ID, v_STATUS);
		ERRS.VALIDATE_STATUS('DE.DEL_SUB_STATION', v_STATUS);
	ELSIF p_ENTITY_TYPE = 'SUB_STATION_METER' THEN
		DE.DEL_SUB_STATION_METER(p_ENTITY_ID, v_STATUS);
		ERRS.VALIDATE_STATUS('DE.DEL_SUB_STATION_METER', v_STATUS);
	ELSIF p_ENTITY_TYPE = 'TX_FEEDER' THEN
		DE.DEL_TX_FEEDER(p_ENTITY_ID, v_STATUS);
		ERRS.VALIDATE_STATUS('DE.DEL_TX_FEEDER', v_STATUS);
	ELSIF p_ENTITY_TYPE = 'SUB_STATION_METER_POINT' THEN
		DE.DEL_SUB_STATION_METER_POINT(p_ENTITY_ID, v_STATUS);
		ERRS.VALIDATE_STATUS('DE.DEL_SUB_STATION_METER_POINT', v_STATUS);
	ELSIF p_ENTITY_TYPE = 'TX_FEEDER_SEGMENT' THEN
		DE.DEL_TX_FEEDER_SEGMENT(p_ENTITY_ID, v_STATUS);
		ERRS.VALIDATE_STATUS('DE.DEL_TX_FEEDER_SEGMENT', v_STATUS);
	END IF;
END DELETE_TRANS_NETWORK_ENTITY;
--------------------------------------------------------------------------------
PROCEDURE PASTE_TX_ENTITY
	(
	p_ENTITY_ID IN NUMBER,
	p_ENTITY_TYPE IN VARCHAR2,
	p_NEW_PARENT_ENTITY_ID IN NUMBER,
	p_IS_CUT IN NUMBER,
	p_NEW_ENTITY_ID OUT NUMBER
	) AS

v_NEW_ENTITY_NAME VARCHAR2(64);

BEGIN

	IF p_IS_CUT = 0 THEN
		-- Copy/Paste
		ENTITY_UTIL.COPY_ENTITY(p_ENTITY_ID, p_ENTITY_TYPE, p_NEW_ENTITY_ID, v_NEW_ENTITY_NAME);
	ELSE
		-- Cut/Paste
		p_NEW_ENTITY_ID := p_ENTITY_ID;
	END IF;

	-- Update the parent
	IF (p_ENTITY_TYPE = 'SUB_STATION') THEN
		UPDATE TX_SUB_STATION SS
		SET SS.SERVICE_ZONE_ID = p_NEW_PARENT_ENTITY_ID
		WHERE SS.SUB_STATION_ID = p_NEW_ENTITY_ID;
	ELSIF (p_ENTITY_TYPE = 'SUB_STATION_METER') THEN
		UPDATE TX_SUB_STATION_METER SM
		SET SM.SUB_STATION_ID = p_NEW_PARENT_ENTITY_ID
		WHERE SM.METER_ID = p_NEW_ENTITY_ID;
	ELSIF (p_ENTITY_TYPE = 'SUB_STATION_METER_POINT') THEN
		UPDATE TX_SUB_STATION_METER_POINT MP
		SET MP.SUB_STATION_METER_ID = p_NEW_PARENT_ENTITY_ID
		WHERE MP.METER_POINT_ID = p_NEW_ENTITY_ID;
	ELSIF (p_ENTITY_TYPE = 'TX_FEEDER') THEN
		UPDATE TX_FEEDER F
		SET F.SUB_STATION_ID = p_NEW_PARENT_ENTITY_ID
		WHERE F.FEEDER_ID = p_NEW_ENTITY_ID;
	ELSIF (p_ENTITY_TYPE = 'TX_FEEDER_SEGMENT') THEN
		UPDATE TX_FEEDER_SEGMENT FS
		SET FS.FEEDER_ID = p_NEW_PARENT_ENTITY_ID
		WHERE FS.FEEDER_SEGMENT_ID = p_NEW_ENTITY_ID;
	END IF;

END PASTE_TX_ENTITY;
--------------------------------------------------------------------------------
PROCEDURE GET_PATH_FOR_SUB_STATION
	(
	p_SERVICE_ZONE_ID IN OUT NUMBER,
	p_SUB_STATION_ID IN NUMBER
	) AS

BEGIN
	IF NVL(p_SUB_STATION_ID, -9) = -9 THEN
		IF p_SERVICE_ZONE_ID IS NULL THEN
			ERRS.RAISE(MSGCODES.c_ERR_GENERAL, 'If a new substation is specified, then you must specify a parent service zone.');
		END IF;
	ELSE
		SELECT SZ.SERVICE_ZONE_ID INTO p_SERVICE_ZONE_ID
		FROM SERVICE_ZONE SZ,
			TX_SUB_STATION SS
		WHERE SS.SERVICE_ZONE_ID = SZ.SERVICE_ZONE_ID
			AND SS.SUB_STATION_ID = p_SUB_STATION_ID;
	END IF;
END GET_PATH_FOR_SUB_STATION;
--------------------------------------------------------------------------------
PROCEDURE GET_PATH_FOR_SUB_STATION_METER
	(
	p_SERVICE_ZONE_ID IN OUT NUMBER,
	p_SUB_STATION_ID IN OUT NUMBER,
	p_SUB_STATION_METER_ID IN NUMBER
	) AS
BEGIN
	IF NVL(p_SUB_STATION_METER_ID, -9) = -9 THEN
		IF p_SUB_STATION_ID IS NULL THEN
			ERRS.RAISE(MSGCODES.c_ERR_GENERAL, 'If a new substation meter is specified, then you must specify a parent substation.');
		END IF;
		GET_PATH_FOR_SUB_STATION(p_SERVICE_ZONE_ID, p_SUB_STATION_ID);
	ELSE
		SELECT SZ.SERVICE_ZONE_ID,
			SS.SUB_STATION_ID
		INTO p_SERVICE_ZONE_ID,
			p_SUB_STATION_ID
		FROM SERVICE_ZONE SZ,
			TX_SUB_STATION SS,
			TX_SUB_STATION_METER SM
		WHERE SS.SERVICE_ZONE_ID = SZ.SERVICE_ZONE_ID
			AND SS.SUB_STATION_ID = SM.SUB_STATION_ID
			AND SM.METER_ID = p_SUB_STATION_METER_ID;
	END IF;
END GET_PATH_FOR_SUB_STATION_METER;
--------------------------------------------------------------------------------
PROCEDURE GET_PATH_FOR_METER_POINT
	(
	p_SERVICE_ZONE_ID IN OUT NUMBER,
	p_SUB_STATION_ID OUT NUMBER,
	p_SUB_STATION_METER_ID IN OUT NUMBER,
	p_METER_POINT_ID IN OUT NUMBER
	) AS
BEGIN
	IF NVL(p_METER_POINT_ID, -9) = -9 THEN
		IF p_SUB_STATION_METER_ID IS NULL THEN
			ERRS.RAISE(MSGCODES.c_ERR_GENERAL, 'If a new substation meter point is specified, then you must specify a parent substation meter.');
		END IF;
		GET_PATH_FOR_SUB_STATION_METER(p_SERVICE_ZONE_ID, p_SUB_STATION_ID, p_SUB_STATION_METER_ID);
	ELSE
		SELECT SZ.SERVICE_ZONE_ID,
			SS.SUB_STATION_ID,
			SM.METER_ID
		INTO p_SERVICE_ZONE_ID,
			p_SUB_STATION_ID,
			p_SUB_STATION_METER_ID
		FROM SERVICE_ZONE SZ,
			TX_SUB_STATION SS,
			TX_SUB_STATION_METER SM,
			TX_SUB_STATION_METER_POINT MP
		WHERE SS.SERVICE_ZONE_ID = SZ.SERVICE_ZONE_ID
			AND SS.SUB_STATION_ID = SM.SUB_STATION_ID
			AND SM.METER_ID = MP.SUB_STATION_METER_ID
			AND MP.METER_POINT_ID = p_METER_POINT_ID;
	END IF;
END GET_PATH_FOR_METER_POINT;
--------------------------------------------------------------------------------
PROCEDURE GET_PATH_FOR_FEEDER
	(
	p_SERVICE_ZONE_ID IN OUT NUMBER,
	p_SUB_STATION_ID IN OUT NUMBER,
	p_FEEDER_ID IN OUT NUMBER
	) AS
BEGIN
	IF NVL(p_FEEDER_ID, -9) = -9 THEN
		IF p_SUB_STATION_ID IS NULL THEN
			ERRS.RAISE(MSGCODES.c_ERR_GENERAL, 'If a new feeder is specified, then you must specify a parent substation.');
		END IF;
		GET_PATH_FOR_SUB_STATION(p_SERVICE_ZONE_ID, p_SUB_STATION_ID);
	ELSE
		SELECT SZ.SERVICE_ZONE_ID,
			SS.SUB_STATION_ID
		INTO p_SERVICE_ZONE_ID,
			p_SUB_STATION_ID
		FROM SERVICE_ZONE SZ,
			TX_SUB_STATION SS,
			TX_FEEDER F
		WHERE SS.SERVICE_ZONE_ID = SZ.SERVICE_ZONE_ID
			AND SS.SUB_STATION_ID = F.SUB_STATION_ID
			AND F.FEEDER_ID = p_FEEDER_ID;
	END IF;
END GET_PATH_FOR_FEEDER;
--------------------------------------------------------------------------------
PROCEDURE GET_PATH_FOR_FEEDER_SEGMENT
	(
	p_SERVICE_ZONE_ID IN OUT NUMBER,
	p_SUB_STATION_ID IN OUT NUMBER,
	P_FEEDER_ID IN OUT NUMBER,
	p_FEEDER_SEGMENT_ID IN OUT NUMBER
	) AS
BEGIN
	IF NVL(p_FEEDER_SEGMENT_ID, -9) = -9 THEN
		IF P_FEEDER_ID IS NULL THEN
			ERRS.RAISE(MSGCODES.c_ERR_GENERAL, 'If a new feeder segment is specified, then you must specify a parent feeder.');
		END IF;
		GET_PATH_FOR_FEEDER(p_SERVICE_ZONE_ID, p_SUB_STATION_ID, p_FEEDER_ID);
	ELSE
		SELECT SZ.SERVICE_ZONE_ID,
			SS.SUB_STATION_ID,
			F.FEEDER_ID
		INTO p_SERVICE_ZONE_ID,
			p_SUB_STATION_ID,
			p_FEEDER_ID
		FROM SERVICE_ZONE SZ,
			TX_SUB_STATION SS,
			TX_FEEDER F,
			TX_FEEDER_SEGMENT FS
		WHERE SS.SERVICE_ZONE_ID = SZ.SERVICE_ZONE_ID
			AND SS.SUB_STATION_ID = F.SUB_STATION_ID
			AND F.FEEDER_ID = FS.FEEDER_ID
			AND FS.FEEDER_SEGMENT_ID = p_FEEDER_SEGMENT_ID;
	END IF;
END GET_PATH_FOR_FEEDER_SEGMENT;
--------------------------------------------------------------------------
PROCEDURE SEARCH
	(
	p_BEGIN_DATE         IN DATE,
	p_END_DATE           IN DATE,
	p_SEARCH_STRING      IN VARCHAR,
	p_SEARCH_OPTION      IN VARCHAR,
	p_SEARCH_OPTION_NAME OUT VARCHAR,
	p_CURSOR             IN OUT GA.REFCURSOR
	) AS
v_IDS             ID_TABLE;
BEGIN
	NULL;
	-- This procedure supports the following search types:
	-- Service Zone - By Name
	-- Service Zone - By Alias
	-- Service Zone - By External Identifier
	-- Sub-Station - By Name
	-- Sub-Station - By Alias
	-- Sub-Station - By External Identifier
	-- Meter - By Name
	-- Meter - By Alias
	-- Meter - By External Identifier
	-- Feeder - By Name
	-- Feeder - By Alias
	-- Feeder - By External Identifier
	-- Meter Data Point - By Name
	-- Meter Data Point - By Alias
	-- Meter Data Point - By External Identifier
	-- Feeder Segment - By Name
	-- Feeder Segment - By Alias
	-- Feeder Segment - By External Identifier

	----------------------------------------------------------------
	---- Service Zone
	----------------------------------------------------------------
	IF REGEXP_INSTR(p_SEARCH_OPTION, '^Service Zone[[:space:]]{1}-[[:space:]]{1}') > 0 THEN
		SERVICE_ZONE_LIST(p_SEARCH_STRING,
					 REGEXP_REPLACE(p_SEARCH_OPTION,'^Service Zone[[:space:]]{1}-[[:space:]]{1}',''),
					 CONSTANTS.SEARCH_TYPE_NORMAL,
					 NULL,
					 p_SEARCH_OPTION_NAME,
					 p_CURSOR);
	----------------------------------------------------------------
	---- Substation
	----------------------------------------------------------------
	ELSIF REGEXP_INSTR(p_SEARCH_OPTION, '^Substation[[:space:]]{1}-[[:space:]]{1}') > 0 THEN
		-- Set the Search Option Name which is used in the Colummn Display Formula of
		-- the SEARCH_NAME column in the Numerous Find results grid.
		CASE p_SEARCH_OPTION
			WHEN 'Substation - By Alias' THEN
				p_SEARCH_OPTION_NAME := 'Alias';
			WHEN 'Substation - By External Identifier' THEN
				p_SEARCH_OPTION_NAME := 'External Identifier';
			ELSE
				p_SEARCH_OPTION_NAME := 'Name';
		END CASE;

		-- Data Level Security
		v_IDS := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_SELECT_ENT, EC.ED_SERVICE_ZONE);

		IF p_SEARCH_STRING = '%' OR p_SEARCH_STRING IS NULL THEN
			OPEN p_CURSOR FOR
				SELECT
					SZ.SERVICE_ZONE_ID,
					SZ.SERVICE_ZONE_NAME,
					SS.SUB_STATION_ID,
					SS.SUB_STATION_NAME,
					CASE p_SEARCH_OPTION
						WHEN 'Substation - By Alias' THEN
							SS.SUB_STATION_ALIAS
						WHEN 'Substation - By External Identifier' THEN
							SS.EXTERNAL_IDENTIFIER
					ELSE
						NULL
					END AS SEARCH_NAME
				FROM TABLE(CAST(v_IDS AS ID_TABLE)) X, SERVICE_ZONE SZ, TX_SUB_STATION SS
				WHERE X.ID IN (SZ.SERVICE_ZONE_ID, SD.g_ALL_DATA_ENTITY_ID)
					AND SS.SERVICE_ZONE_ID = SZ.SERVICE_ZONE_ID
					AND NVL(SS.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND SS.BEGIN_DATE <= p_END_DATE
				ORDER BY SEARCH_NAME, SS.SUB_STATION_NAME, SZ.SERVICE_ZONE_NAME;
		ELSE
			OPEN p_CURSOR FOR
				SELECT
					SZ.SERVICE_ZONE_ID,
					SZ.SERVICE_ZONE_NAME,
					SS.SUB_STATION_ID,
					SS.SUB_STATION_NAME,
					CASE p_SEARCH_OPTION
						WHEN 'Substation - By Alias' THEN
							SS.SUB_STATION_ALIAS
						WHEN 'Substation - By External Identifier' THEN
							SS.EXTERNAL_IDENTIFIER
					ELSE
						NULL
					END AS SEARCH_NAME
				FROM TABLE(CAST(v_IDS AS ID_TABLE)) X, SERVICE_ZONE SZ, TX_SUB_STATION SS
				WHERE X.ID IN (SZ.SERVICE_ZONE_ID, SD.g_ALL_DATA_ENTITY_ID)
					AND SS.SERVICE_ZONE_ID = SZ.SERVICE_ZONE_ID
					AND NVL(SS.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND SS.BEGIN_DATE <= p_END_DATE
					AND ((p_SEARCH_OPTION = 'Substation - By Name' AND SS.SUB_STATION_NAME LIKE p_SEARCH_STRING) OR
					(p_SEARCH_OPTION = 'Substation - By Alias' AND SS.SUB_STATION_ALIAS LIKE p_SEARCH_STRING) OR
					(p_SEARCH_OPTION = 'Substation - By External Identifier' AND SS.EXTERNAL_IDENTIFIER LIKE p_SEARCH_STRING))
				ORDER BY SEARCH_NAME, SS.SUB_STATION_NAME, SZ.SERVICE_ZONE_NAME;
		END IF;
	----------------------------------------------------------------
	---- Substation Meter
	----------------------------------------------------------------
	ELSIF REGEXP_INSTR(p_SEARCH_OPTION, '^Meter[[:space:]]{1}-[[:space:]]{1}') > 0 THEN
		-- Set the Search Option Name which is used in the Colummn Display Formula of
		-- the SEARCH_NAME column in the Numerous Find results grid.
		CASE p_SEARCH_OPTION
			WHEN 'Meter - By Alias' THEN
				p_SEARCH_OPTION_NAME := 'Alias';
			WHEN 'Meter - By External Identifier' THEN
				p_SEARCH_OPTION_NAME := 'External Identifier';
			ELSE
				p_SEARCH_OPTION_NAME := 'Name';
		END CASE;

		-- Data Level Security
		v_IDS := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_SELECT_ENT, EC.ED_SERVICE_ZONE);

		IF p_SEARCH_STRING = '%' OR p_SEARCH_STRING IS NULL THEN
			OPEN p_CURSOR FOR
				SELECT SZ.SERVICE_ZONE_ID,
					SZ.SERVICE_ZONE_NAME,
					SS.SUB_STATION_ID,
					SS.SUB_STATION_NAME,
					SM.METER_ID AS SUB_STATION_METER_ID,
					SM.METER_NAME AS SUB_STATION_METER_NAME,
					CASE p_SEARCH_OPTION
						WHEN 'Meter - By Alias' THEN
							SM.METER_ALIAS
						WHEN 'Meter - By External Identifier' THEN
							SM.EXTERNAL_IDENTIFIER
						ELSE
							NULL
					END AS SEARCH_NAME
				FROM TABLE(CAST(v_IDS AS ID_TABLE)) X, SERVICE_ZONE SZ, TX_SUB_STATION SS, TX_SUB_STATION_METER SM
				WHERE X.ID IN (SZ.SERVICE_ZONE_ID, SD.g_ALL_DATA_ENTITY_ID)
					AND SS.SERVICE_ZONE_ID = SZ.SERVICE_ZONE_ID
					AND NVL(SS.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND SS.BEGIN_DATE <= p_END_DATE
					AND SM.SUB_STATION_ID = SS.SUB_STATION_ID
					AND NVL(SM.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND SM.BEGIN_DATE <= p_END_DATE
				ORDER BY SEARCH_NAME, SM.METER_NAME, SZ.SERVICE_ZONE_NAME, SS.SUB_STATION_NAME;
		ELSE
			OPEN p_CURSOR FOR
				SELECT SZ.SERVICE_ZONE_ID,
					SZ.SERVICE_ZONE_NAME,
					SS.SUB_STATION_ID,
					SS.SUB_STATION_NAME,
					SM.METER_ID AS SUB_STATION_METER_ID,
					SM.METER_NAME AS SUB_STATION_METER_NAME,
					CASE p_SEARCH_OPTION
						WHEN 'Meter - By Alias' THEN
							SM.METER_ALIAS
						WHEN 'Meter - By External Identifier' THEN
							SM.EXTERNAL_IDENTIFIER
						ELSE
							NULL
					END AS SEARCH_NAME
				FROM TABLE(CAST(v_IDS AS ID_TABLE)) X, SERVICE_ZONE SZ, TX_SUB_STATION SS, TX_SUB_STATION_METER SM
				WHERE X.ID IN (SZ.SERVICE_ZONE_ID, SD.g_ALL_DATA_ENTITY_ID)
					AND SS.SERVICE_ZONE_ID = SZ.SERVICE_ZONE_ID
					AND NVL(SS.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND SS.BEGIN_DATE <= p_END_DATE
					AND SM.SUB_STATION_ID = SS.SUB_STATION_ID
					AND NVL(SM.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND SM.BEGIN_DATE <= p_END_DATE
					AND ((p_SEARCH_OPTION = 'Meter - By Name' AND SM.METER_NAME LIKE p_SEARCH_STRING) OR
					(p_SEARCH_OPTION = 'Meter - By Alias' AND SM.METER_ALIAS LIKE p_SEARCH_STRING) OR
					(p_SEARCH_OPTION = 'Meter - By External Identifier' AND SM.EXTERNAL_IDENTIFIER LIKE p_SEARCH_STRING))
				ORDER BY SEARCH_NAME, SM.METER_NAME, SZ.SERVICE_ZONE_NAME, SS.SUB_STATION_NAME;
		END IF;
	----------------------------------------------------------------
	---- Feeder
	----------------------------------------------------------------
	ELSIF REGEXP_INSTR(p_SEARCH_OPTION, '^Feeder[[:space:]]{1}-[[:space:]]{1}') > 0 THEN
		-- Set the Search Option Name which is used in the Colummn Display Formula of
		-- the SEARCH_NAME column in the Numerous Find results grid.
		CASE p_SEARCH_OPTION
			WHEN 'Feeder - By Alias' THEN
				p_SEARCH_OPTION_NAME := 'Alias';
			WHEN 'Feeder - By External Identifier' THEN
				p_SEARCH_OPTION_NAME := 'External Identifier';
			ELSE
				p_SEARCH_OPTION_NAME := 'Name';
		END CASE;

		-- Data Level Security
		v_IDS := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_SELECT_ENT, EC.ED_SERVICE_ZONE);

		IF p_SEARCH_STRING = '%' OR p_SEARCH_STRING IS NULL THEN
			OPEN p_CURSOR FOR
				SELECT SZ.SERVICE_ZONE_ID,
					SZ.SERVICE_ZONE_NAME,
					SS.SUB_STATION_ID,
					SS.SUB_STATION_NAME,
					F.FEEDER_ID,
					F.FEEDER_NAME,
					CASE p_SEARCH_OPTION
						WHEN 'Feeder - By Alias' THEN
							F.FEEDER_ALIAS
						WHEN 'Feeder - By External Identifier' THEN
							F.EXTERNAL_IDENTIFIER
						ELSE
							NULL
					END AS SEARCH_NAME
				FROM TABLE(CAST(v_IDS AS ID_TABLE)) X, SERVICE_ZONE SZ, TX_SUB_STATION SS, TX_FEEDER F
				WHERE X.ID IN (SZ.SERVICE_ZONE_ID, SD.g_ALL_DATA_ENTITY_ID)
					AND SS.SERVICE_ZONE_ID = SZ.SERVICE_ZONE_ID
					AND NVL(SS.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND SS.BEGIN_DATE <= p_END_DATE
					AND F.SUB_STATION_ID = SS.SUB_STATION_ID
					AND NVL(F.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND F.BEGIN_DATE <= p_END_DATE
				ORDER BY SEARCH_NAME, F.FEEDER_NAME, SZ.SERVICE_ZONE_NAME, SS.SUB_STATION_NAME;
		ELSE
			OPEN p_CURSOR FOR
				SELECT SZ.SERVICE_ZONE_ID,
					SZ.SERVICE_ZONE_NAME,
					SS.SUB_STATION_ID,
					SS.SUB_STATION_NAME,
					F.FEEDER_ID,
					F.FEEDER_NAME,
					CASE p_SEARCH_OPTION
						WHEN 'Feeder - By Alias' THEN
							F.FEEDER_ALIAS
						WHEN 'Feeder - By External Identifier' THEN
							F.EXTERNAL_IDENTIFIER
						ELSE
							NULL
					END AS SEARCH_NAME
				FROM TABLE(CAST(v_IDS AS ID_TABLE)) X, SERVICE_ZONE SZ, TX_SUB_STATION SS, TX_FEEDER F
				WHERE X.ID IN (SZ.SERVICE_ZONE_ID, SD.g_ALL_DATA_ENTITY_ID)
					AND SS.SERVICE_ZONE_ID = SZ.SERVICE_ZONE_ID
					AND NVL(SS.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND SS.BEGIN_DATE <= p_END_DATE
					AND F.SUB_STATION_ID = SS.SUB_STATION_ID
					AND NVL(F.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND F.BEGIN_DATE <= p_END_DATE
					AND ((p_SEARCH_OPTION = 'Feeder - By Name' AND F.FEEDER_NAME LIKE p_SEARCH_STRING) OR
					(p_SEARCH_OPTION = 'Feeder - By Alias' AND F.FEEDER_ALIAS LIKE p_SEARCH_STRING) OR
					(p_SEARCH_OPTION = 'Feeder - By External Identifier' AND F.EXTERNAL_IDENTIFIER LIKE p_SEARCH_STRING))
				ORDER BY SEARCH_NAME, F.FEEDER_NAME, SZ.SERVICE_ZONE_NAME, SS.SUB_STATION_NAME;
		END IF;
	----------------------------------------------------------------
	---- Meter Data Point
	----------------------------------------------------------------
	ELSIF REGEXP_INSTR(p_SEARCH_OPTION, '^Meter Data Point[[:space:]]{1}-[[:space:]]{1}') > 0 THEN
		-- Set the Search Option Name which is used in the Colummn Display Formula of
		-- the SEARCH_NAME column in the Numerous Find results grid.
		CASE p_SEARCH_OPTION
			WHEN 'Meter Data Point - By Alias' THEN
				p_SEARCH_OPTION_NAME := 'Alias';
			WHEN 'Meter Data Point - By External Identifier' THEN
				p_SEARCH_OPTION_NAME := 'External Identifier';
			ELSE
				p_SEARCH_OPTION_NAME := 'Name';
		END CASE;

		-- Data Level Security
		v_IDS := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_SELECT_ENT, EC.ED_SERVICE_ZONE);

		IF p_SEARCH_STRING = '%' OR p_SEARCH_STRING IS NULL THEN
			OPEN p_CURSOR FOR
				SELECT SZ.SERVICE_ZONE_ID,
					SZ.SERVICE_ZONE_NAME,
					SS.SUB_STATION_ID,
					SS.SUB_STATION_NAME,
					SM.METER_ID AS SUB_STATION_METER_ID,
					SM.METER_NAME AS SUB_STATION_METER_NAME,
					MP.METER_POINT_ID,
					MP.METER_POINT_NAME,
					CASE p_SEARCH_OPTION
						WHEN 'Meter Data Point - By Alias' THEN
							MP.METER_POINT_ALIAS
						WHEN 'Meter Data Point - By External Identifier' THEN
							MP.EXTERNAL_IDENTIFIER
						ELSE
							NULL
					END AS SEARCH_NAME
				FROM TABLE(CAST(v_IDS AS ID_TABLE)) X, SERVICE_ZONE SZ, TX_SUB_STATION SS,
					TX_SUB_STATION_METER SM, TX_SUB_STATION_METER_POINT MP
				WHERE X.ID IN (SZ.SERVICE_ZONE_ID, SD.g_ALL_DATA_ENTITY_ID)
					AND SS.SERVICE_ZONE_ID = SZ.SERVICE_ZONE_ID
					AND NVL(SS.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND SS.BEGIN_DATE <= p_END_DATE
					AND SM.SUB_STATION_ID = SS.SUB_STATION_ID
					AND NVL(SM.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND SM.BEGIN_DATE <= p_END_DATE
					AND MP.SUB_STATION_METER_ID = SM.METER_ID
					AND NVL(MP.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND MP.BEGIN_DATE <= p_END_DATE
				ORDER BY SEARCH_NAME, MP.METER_POINT_NAME, SZ.SERVICE_ZONE_NAME, SS.SUB_STATION_NAME, SM.METER_NAME;
		ELSE
			OPEN p_CURSOR FOR
				SELECT SZ.SERVICE_ZONE_ID,
					SZ.SERVICE_ZONE_NAME,
					SS.SUB_STATION_ID,
					SS.SUB_STATION_NAME,
					SM.METER_ID AS SUB_STATION_METER_ID,
					SM.METER_NAME AS SUB_STATION_METER_NAME,
					MP.METER_POINT_ID,
					MP.METER_POINT_NAME,
					CASE p_SEARCH_OPTION
						WHEN 'Meter Data Point - By Alias' THEN
							MP.METER_POINT_ALIAS
						WHEN 'Meter Data Point - By External Identifier' THEN
							MP.EXTERNAL_IDENTIFIER
						ELSE
							NULL
					END AS SEARCH_NAME
				FROM TABLE(CAST(v_IDS AS ID_TABLE)) X, SERVICE_ZONE SZ, TX_SUB_STATION SS,
					TX_SUB_STATION_METER SM, TX_SUB_STATION_METER_POINT MP
				WHERE X.ID IN (SZ.SERVICE_ZONE_ID, SD.g_ALL_DATA_ENTITY_ID)
					AND SS.SERVICE_ZONE_ID = SZ.SERVICE_ZONE_ID
					AND NVL(SS.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND SS.BEGIN_DATE <= p_END_DATE
					AND SM.SUB_STATION_ID = SS.SUB_STATION_ID
					AND NVL(SM.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND SM.BEGIN_DATE <= p_END_DATE
					AND MP.SUB_STATION_METER_ID = SM.METER_ID
					AND NVL(MP.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND MP.BEGIN_DATE <= p_END_DATE
					AND ((p_SEARCH_OPTION = 'Meter Data Point - By Name' AND MP.METER_POINT_NAME LIKE p_SEARCH_STRING) OR
					(p_SEARCH_OPTION = 'Meter Data Point - By Alias' AND MP.METER_POINT_ALIAS LIKE p_SEARCH_STRING) OR
					(p_SEARCH_OPTION = 'Meter Data Point - By External Identifier' AND MP.EXTERNAL_IDENTIFIER LIKE p_SEARCH_STRING)
					)
				ORDER BY SEARCH_NAME, MP.METER_POINT_NAME, SZ.SERVICE_ZONE_NAME, SS.SUB_STATION_NAME, SM.METER_NAME;
		END IF;
	----------------------------------------------------------------
	---- Feeder Segment
	----------------------------------------------------------------
	ELSIF REGEXP_INSTR(p_SEARCH_OPTION, '^Feeder Segment[[:space:]]{1}-[[:space:]]{1}') > 0 THEN
		-- Set the Search Option Name which is used in the Colummn Display Formula of
		-- the SEARCH_NAME column in the Numerous Find results grid.
		CASE p_SEARCH_OPTION
			WHEN 'Feeder Segment - By Alias' THEN
				p_SEARCH_OPTION_NAME := 'Alias';
			WHEN 'Feeder Segment - By External Identifier' THEN
				p_SEARCH_OPTION_NAME := 'External Identifier';
			ELSE
				p_SEARCH_OPTION_NAME := 'Name';
		END CASE;

		-- Data Level Security
		v_IDS := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_SELECT_ENT, EC.ED_SERVICE_ZONE);

		IF p_SEARCH_STRING = '%' OR p_SEARCH_STRING IS NULL THEN
			OPEN p_CURSOR FOR
				SELECT SZ.SERVICE_ZONE_ID,
					SZ.SERVICE_ZONE_NAME,
					SS.SUB_STATION_ID,
					SS.SUB_STATION_NAME,
					F.FEEDER_ID,
					F.FEEDER_NAME,
					FS.FEEDER_SEGMENT_ID,
					FS.FEEDER_SEGMENT_NAME,
					CASE p_SEARCH_OPTION
						WHEN 'Feeder Segment - By Alias' THEN
							FS.FEEDER_SEGMENT_ALIAS
						WHEN 'Feeder Segment - By External Identifier' THEN
							FS.EXTERNAL_IDENTIFIER
						ELSE
							NULL
					END AS SEARCH_NAME
				FROM TABLE(CAST(v_IDS AS ID_TABLE)) X, SERVICE_ZONE SZ, TX_SUB_STATION SS,
					TX_FEEDER F, TX_FEEDER_SEGMENT FS
				WHERE X.ID IN (SZ.SERVICE_ZONE_ID, SD.g_ALL_DATA_ENTITY_ID)
					AND SS.SERVICE_ZONE_ID = SZ.SERVICE_ZONE_ID
					AND NVL(SS.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND SS.BEGIN_DATE <= p_END_DATE
					AND F.SUB_STATION_ID = SS.SUB_STATION_ID
					AND NVL(F.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND F.BEGIN_DATE <= p_END_DATE
					AND FS.FEEDER_ID = F.FEEDER_ID
					AND NVL(FS.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND FS.BEGIN_DATE <= p_END_DATE
				ORDER BY SEARCH_NAME, FS.FEEDER_SEGMENT_NAME, SZ.SERVICE_ZONE_NAME, SS.SUB_STATION_NAME, F.FEEDER_NAME;
		ELSE
			OPEN p_CURSOR FOR
				SELECT SZ.SERVICE_ZONE_ID,
					SZ.SERVICE_ZONE_NAME,
					SS.SUB_STATION_ID,
					SS.SUB_STATION_NAME,
					F.FEEDER_ID,
					F.FEEDER_NAME,
					FS.FEEDER_SEGMENT_ID,
					FS.FEEDER_SEGMENT_NAME,
					CASE p_SEARCH_OPTION
						WHEN 'Feeder Segment - By Alias' THEN
							FS.FEEDER_SEGMENT_ALIAS
						WHEN 'Feeder Segment - By External Identifier' THEN
							FS.EXTERNAL_IDENTIFIER
						ELSE
							NULL
					END AS SEARCH_NAME
				FROM TABLE(CAST(v_IDS AS ID_TABLE)) X, SERVICE_ZONE SZ, TX_SUB_STATION SS,
					TX_FEEDER F, TX_FEEDER_SEGMENT FS
				WHERE X.ID IN (SZ.SERVICE_ZONE_ID, SD.g_ALL_DATA_ENTITY_ID)
					AND SS.SERVICE_ZONE_ID = SZ.SERVICE_ZONE_ID
					AND NVL(SS.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND SS.BEGIN_DATE <= p_END_DATE
					AND F.SUB_STATION_ID = SS.SUB_STATION_ID
					AND NVL(F.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND F.BEGIN_DATE <= p_END_DATE
					AND FS.FEEDER_ID = F.FEEDER_ID
					AND NVL(FS.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND FS.BEGIN_DATE <= p_END_DATE
					AND ((p_SEARCH_OPTION = 'Feeder Segment - By Name' AND FS.FEEDER_SEGMENT_NAME LIKE p_SEARCH_STRING) OR
					(p_SEARCH_OPTION = 'Feeder Segment - By Alias' AND FS.FEEDER_SEGMENT_ALIAS LIKE p_SEARCH_STRING) OR
					(p_SEARCH_OPTION = 'Feeder Segment - By External Identifier' AND FS.EXTERNAL_IDENTIFIER LIKE p_SEARCH_STRING))
				ORDER BY SEARCH_NAME, FS.FEEDER_SEGMENT_NAME, SZ.SERVICE_ZONE_NAME, SS.SUB_STATION_NAME, F.FEEDER_NAME;
		END IF;

	END IF;
END SEARCH;
----------------------------------------------------------------------------------------------------
PROCEDURE EVENTS_SUMMARY
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_VPP_ID IN NUMBER,
	P_CURSOR IN OUT GA.REFCURSOR
	) AS

v_IDS ID_TABLE;
v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

	v_IDS := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_SELECT_ENT, EC.ED_DR_EVENT);
	UT.CUT_DATE_RANGE(CONSTANTS.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE,
		v_BEGIN_DATE, v_END_DATE);

	-- INNER QUERIES GET DEVICE PARTICIPATION INFO AND SCHED AND ACTUAL SUMMARY INFO
	-- OUT QUERIES GET PROGRAM, EVENT AND VPP INFO
	OPEN p_CURSOR FOR
	SELECT EV.EVENT_ID,
		EV.EVENT_NAME,
		VPP.VPP_ID,
		VPP.VPP_NAME,
		EV.EVENT_STATUS,
		FROM_CUT(EV.START_TIME, p_TIME_ZONE) AS START_TIME,
		FROM_CUT(EV.STOP_TIME, p_TIME_ZONE) AS STOP_TIME,
		EV.EVENT_TYPE,
		RESOURCE_INFO.TOTAL_OPT,
		RESOURCE_INFO.TOTAL_FAIL,
		(SELECT COUNT(1)
		 FROM (SELECT DER_ID, EVENT_ID FROM DR_EVENT_PARTICIPATION
				UNION SELECT DER_ID, EVENT_ID FROM DR_EVENT_EXCEPTION)
		 WHERE EVENT_ID = EV.EVENT_ID) AS TOTAL_TARGETED_PART,
		RESOURCE_INFO.TOTAL_OVER,
		NVL(ACTUAL_INFO.ACTUAL_TOTAL, SCHED_INFO.SCHED_TOTAL) TOTAL_ENERGY,
		NVL(ACTUAL_INFO.ACTUAL_MAX, SCHED_INFO.SCHED_MAX) PEAK_CAPACITY,
		EV.EVENT_DESC
	FROM (SELECT EVT.EVENT_ID,
		  	SUM(CASE WHEN EXCEPTION_TYPE = DEMAND_RESPONSE_UTIL.c_EXCEPTION_TYPE_FAILURE THEN 1 ELSE 0 END) TOTAL_FAIL,
			SUM(CASE WHEN EXCEPTION_TYPE = DEMAND_RESPONSE_UTIL.c_EXCEPTION_TYPE_OPTOUT THEN 1 ELSE 0 END) TOTAL_OPT,
			SUM(CASE WHEN EXCEPTION_TYPE = DEMAND_RESPONSE_UTIL.c_EXCEPTION_TYPE_OVERRIDE THEN 1 ELSE 0 END) TOTAL_OVER
		   FROM DR_EVENT EVT, DR_EVENT_EXCEPTION EX, TABLE(CAST(v_IDS AS ID_TABLE)) X
		   WHERE (EVT.VPP_ID = p_VPP_ID OR p_VPP_ID = CONSTANTS.ALL_ID)
			  	AND X.ID IN (EVT.EVENT_ID, SD.g_ALL_DATA_ENTITY_ID)
				AND NVL(EVT.START_TIME, CONSTANTS.LOW_DATE) < v_END_DATE
					AND NVL(EVT.STOP_TIME, CONSTANTS.HIGH_DATE) >= v_BEGIN_DATE
				AND EX.EVENT_ID (+) = EVT.EVENT_ID
			GROUP BY EVT.EVENT_ID) RESOURCE_INFO,
		  -- GET THE PARTICIPATION INFO FOR THE RESOURCES

		  (SELECT EVT.EVENT_ID, SUM(SCHED.AMOUNT) SCHED_TOTAL, MAX(SCHED.AMOUNT) SCHED_MAX
		   FROM DR_EVENT EVT, DR_EVENT_SCHEDULE SCHED, TABLE(CAST(v_IDS AS ID_TABLE)) X
		   WHERE (EVT.VPP_ID = p_VPP_ID OR p_VPP_ID = CONSTANTS.ALL_ID)
			AND X.ID IN (EVT.EVENT_ID, SD.g_ALL_DATA_ENTITY_ID)
			AND NVL(EVT.START_TIME, CONSTANTS.LOW_DATE) < v_END_DATE
				AND NVL(EVT.STOP_TIME, CONSTANTS.HIGH_DATE) >= v_BEGIN_DATE
		   	AND SCHED.EVENT_ID = EVT.EVENT_ID
		   	AND SCHED.SCHEDULE_DATE (+) BETWEEN NVL(EVT.START_TIME, CONSTANTS.LOW_DATE)
							AND NVL(EVT.STOP_TIME, CONSTANTS.HIGH_DATE)
		   GROUP BY EVT.EVENT_ID) SCHED_INFO,
		  -- GET THE SUMMARY INFO FOR THE SCHEDULE AMOUNTS

		  (SELECT EVT.EVENT_ID, SUM(DATA.LOAD_VAL + DATA.OPT_OUT_VAL + DATA.FAILURE_VAL
		  							+ DATA.OVERRIDE_VAL + DATA.DX_LOSS_VAL + DATA.TX_LOSS_VAL) ACTUAL_TOTAL,
		 		 MAX(DATA.LOAD_VAL + DATA.OPT_OUT_VAL + DATA.FAILURE_VAL + DATA.OVERRIDE_VAL
				 					+ DATA.DX_LOSS_VAL + DATA.TX_LOSS_VAL) ACTUAL_MAX
		   FROM DR_EVENT EVT, DER_VPP_RESULT RST, DER_VPP_RESULT_DATA DATA, TABLE(CAST(v_IDS AS ID_TABLE)) X,
		   		VIRTUAL_POWER_PLANT VPP
		   WHERE (EVT.VPP_ID = p_VPP_ID OR p_VPP_ID = CONSTANTS.ALL_ID)
		   	AND X.ID IN (EVT.EVENT_ID, SD.g_ALL_DATA_ENTITY_ID)
			AND NVL(EVT.START_TIME, CONSTANTS.LOW_DATE) < v_END_DATE
				AND NVL(EVT.STOP_TIME, CONSTANTS.HIGH_DATE) >= v_BEGIN_DATE
			AND RST.IS_EXTERNAL = 1
			AND RST.SERVICE_CODE = CONSTANTS.CODE_BACKCAST
			AND VPP.VPP_ID = EVT.VPP_ID
			AND RST.PROGRAM_ID = VPP.PROGRAM_ID
			AND RST.SERVICE_ZONE_ID = VPP.SERVICE_ZONE_ID
		   	AND DATA.DER_VPP_RESULT_ID = RST.DER_VPP_RESULT_ID
			AND DATA.RESULT_DATE > NVL(EVT.START_TIME, CONSTANTS.LOW_DATE)
			AND DATA.RESULT_DATE <= NVL(EVT.STOP_TIME, CONSTANTS.HIGH_DATE)
			GROUP BY EVT.EVENT_ID) ACTUAL_INFO,
		   -- GET THE SUMMARY INFO FOR THE REPORTED AMOUNTS

			DR_EVENT EV, VIRTUAL_POWER_PLANT VPP, PROGRAM PROG   -- GET DR_EVENT AGAIN TO AVOID HAVING
			-- TO PULL A BUNCH OF EXTRA COLUMNS IN ONE OF THE INNER QUERIES
		  WHERE RESOURCE_INFO.EVENT_ID = EV.EVENT_ID
			AND VPP.VPP_ID = EV.VPP_ID
			AND PROG.PROGRAM_ID = VPP.PROGRAM_ID
			AND SCHED_INFO.EVENT_ID (+) = EV.EVENT_ID
			AND ACTUAL_INFO.EVENT_ID (+) = EV.EVENT_ID
		  ORDER BY EV.EVENT_NAME;


END EVENTS_SUMMARY;
--------------------------------------------------------------------------------
PROCEDURE PUT_EVENT
(
	p_EVENT_ID IN OUT NUMBER,
	p_EVENT_NAME IN VARCHAR2,
	p_VPP_ID IN NUMBER,
	p_EVENT_STATUS IN VARCHAR2,
	p_START_TIME IN DATE,
	p_STOP_TIME IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_EVENT_TYPE IN VARCHAR2,
	p_EVENT_ALIAS IN VARCHAR2,
	p_EVENT_DESC IN VARCHAR2
) AS

v_START_TIME DATE;
v_STOP_TIME DATE;

v_OLD_STATUS DR_EVENT.EVENT_STATUS%TYPE;
v_OLD_START DATE;
v_OLD_STOP DATE;
v_OLD_TYPE DR_EVENT.EVENT_TYPE%TYPE;

BEGIN

	v_START_TIME := TO_CUT(p_START_TIME, p_TIME_ZONE);
	v_STOP_TIME := TO_CUT(p_STOP_TIME, p_TIME_ZONE);

	IF p_EVENT_ID > 0 THEN
		SELECT EVT.EVENT_STATUS, EVT.START_TIME, EVT.STOP_TIME, EVT.EVENT_TYPE
		INTO v_OLD_STATUS, v_OLD_START, v_OLD_STOP, v_OLD_TYPE
		FROM DR_EVENT EVT
		WHERE EVT.EVENT_ID = p_EVENT_ID;

		IF v_OLD_STATUS = p_EVENT_STATUS AND
			p_EVENT_STATUS IN (DEMAND_RESPONSE_UTIL.c_EVENT_STATUS_STARTED,
  							DEMAND_RESPONSE_UTIL.c_EVENT_STATUS_SYSTEM_OVERRIDE,
							DEMAND_RESPONSE_UTIL.c_EVENT_STATUS_RESUMED,
							DEMAND_RESPONSE_UTIL.c_EVENT_STATUS_ENDED) THEN

			ASSERT(NVL(v_START_TIME, CONSTANTS.LOW_DATE) = NVL(v_OLD_START, CONSTANTS.LOW_DATE)
				AND NVL(v_STOP_TIME, CONSTANTS.LOW_DATE) = NVL(v_OLD_STOP, CONSTANTS.LOW_DATE)
				AND NVL(p_EVENT_TYPE, CONSTANTS.UNDEFINED_ATTRIBUTE) = NVL(v_OLD_TYPE, CONSTANTS.UNDEFINED_ATTRIBUTE),
							'The start time, stop time and event type cannot be changed for events that have a status of '
							 || ' started, system override, resumed or ended.');

		END IF;

	END IF;

	DEMAND_RESPONSE.PUT_EVENT(p_EVENT_ID,p_EVENT_NAME,p_VPP_ID,p_EVENT_STATUS,v_START_TIME,v_STOP_TIME,p_EVENT_TYPE,p_EVENT_ALIAS,p_EVENT_DESC);

END PUT_EVENT;
--------------------------------------------------------------------------------
FUNCTION GET_VPP_RESULT_ID
(
	p_VPP_ID IN NUMBER,
	p_SERVICE_CODE IN CHAR,
	p_IS_EXTERNAL IN NUMBER,
	p_SCENARIO_ID IN NUMBER := GA.BASE_SCENARIO_ID
) RETURN NUMBER IS

	v_WORK_ID NUMBER(9);

BEGIN

	SELECT MAX(RST.DER_VPP_RESULT_ID) INTO v_WORK_ID
	FROM DER_VPP_RESULT RST, VIRTUAL_POWER_PLANT VPP
	WHERE VPP.VPP_ID = p_VPP_ID
		AND RST.SERVICE_ZONE_ID = VPP.SERVICE_ZONE_ID
		AND RST.PROGRAM_ID = VPP.PROGRAM_ID
		AND RST.IS_EXTERNAL = p_IS_EXTERNAL
		AND RST.SERVICE_CODE = p_SERVICE_CODE
		AND RST.SCENARIO_ID = p_SCENARIO_ID;

	RETURN v_WORK_ID;

END GET_VPP_RESULT_ID;
--------------------------------------------------------------------------------

PROCEDURE GET_DER_RESULT_IDS
(
	p_DER_ID IN NUMBER,
	p_IS_EXTERNAL IN NUMBER,
	p_SERVICE_CODE IN CHAR,
	p_RESULT_DAY IN DATE,
	p_LOAD_SHARE_RESULT_ID OUT NUMBER,
	p_HITS_REMAINING_RESULT_ID OUT NUMBER
) AS

BEGIN
	SELECT MAX(DAILY.LOAD_SHAPE_RESULT_ID),
		MAX(DAILY.HITS_REMAINING_RESULT_ID)
	INTO p_LOAD_SHARE_RESULT_ID, p_HITS_REMAINING_RESULT_ID
	FROM DER_DAILY_RESULT DAILY
	WHERE DAILY.DER_ID = p_DER_ID
		AND DAILY.IS_EXTERNAL = p_IS_EXTERNAL
		AND DAILY.SERVICE_CODE = p_SERVICE_CODE
		AND DAILY.SCENARIO_ID = GA.BASE_SCENARIO_ID
		AND DAILY.RESULT_DAY = p_RESULT_DAY;

END GET_DER_RESULT_IDS;
--------------------------------------------------------------------------------
PROCEDURE EVENT_DETAILS_INTERVAL_DATA
(
	p_EVENT_ID IN NUMBER,
	p_VPP_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_CURSOR IN OUT GA.REFCURSOR
) AS

	v_FORECAST_RESULT_ID NUMBER(9) := GET_VPP_RESULT_ID(p_VPP_ID,
														CONSTANTS.CODE_FORECAST, 0);
	v_ESTIMATED_RESULT_ID NUMBER(9) := GET_VPP_RESULT_ID(p_VPP_ID,
														CONSTANTS.CODE_BACKCAST, 0);
	v_REPORTED_RESULT_ID NUMBER(9) := GET_VPP_RESULT_ID(p_VPP_ID,
														CONSTANTS.CODE_BACKCAST, 1);

	v_EVENT_BEGIN DATE;
	v_EVENT_END DATE;

	v_BEGIN_DATE DATE;
	v_END_DATE DATE;

	v_FILTER_BEGIN DATE;
	v_FILTER_END DATE;

	v_PROGRAM_INTERVAL VARCHAR2(32);
	v_INTERVAL_NUM NUMBER(9);

BEGIN

	SELECT NVL(EVT.START_TIME, CONSTANTS.LOW_DATE), NVL(EVT.STOP_TIME, CONSTANTS.HIGH_DATE)
	INTO v_EVENT_BEGIN, v_EVENT_END
	FROM DR_EVENT EVT
	WHERE EVT.EVENT_ID = p_EVENT_ID;

	UT.CUT_DATE_RANGE(CONSTANTS.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE,
		v_BEGIN_DATE, v_END_DATE);

	SELECT PROG.PROGRAM_INTERVAL
	INTO v_PROGRAM_INTERVAL
	FROM VIRTUAL_POWER_PLANT VPP, PROGRAM PROG
	WHERE VPP.VPP_ID = p_VPP_ID
		AND PROG.PROGRAM_ID = VPP.PROGRAM_ID;

	ASSERT(NVL(v_PROGRAM_INTERVAL, CONSTANTS.UNDEFINED_ATTRIBUTE) <> CONSTANTS.UNDEFINED_ATTRIBUTE,
		 'The Program associated with VPP ' || TEXT_UTIL.TO_CHAR_ENTITY(p_VPP_ID, EC.ED_VPP)
		  || ' does not have an interval.', MSGCODES.c_ERR_ARGUMENT);

	v_INTERVAL_NUM := GET_INTERVAL_NUMBER(v_PROGRAM_INTERVAL);

	-- FILTER BASED ON GREATEST AND LEAST BEGIN AND END DATES
	v_FILTER_BEGIN := GREATEST(v_BEGIN_DATE, v_EVENT_BEGIN + 1/86400);
	v_FILTER_END := LEAST(v_END_DATE, v_EVENT_END);

	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, v_FILTER_BEGIN, v_FILTER_END);

	OPEN p_CURSOR FOR
	SELECT SUBSTR(FROM_CUT_AS_HED(SDT.CUT_DATE, p_TIME_ZONE, GET_INTERVAL_ABBREVIATION(v_PROGRAM_INTERVAL)),1,10) SCHED_DATE,
		SUBSTR(FROM_CUT_AS_HED(SDT.CUT_DATE, p_TIME_ZONE, GET_INTERVAL_ABBREVIATION(v_PROGRAM_INTERVAL)),11) SCHED_TIME, SDT.CUT_DATE,
		(FCAST.LOAD_VAL + NVL(FCAST.OPT_OUT_VAL,0) + NVL(FCAST.FAILURE_VAL,0) + NVL(FCAST.OVERRIDE_VAL,0)
				+ NVL(FCAST.TX_LOSS_VAL,0) + NVL(FCAST.DX_LOSS_VAL,0)) FORECAST_REDUCTION,
		SCHED.AMOUNT DISPATCH_SCHED, SCHED.PRICE,
		(EST.LOAD_VAL + NVL(EST.OPT_OUT_VAL,0) + NVL(EST.FAILURE_VAL,0) + NVL(EST.OVERRIDE_VAL,0)
				+ NVL(EST.TX_LOSS_VAL,0) + NVL(EST.DX_LOSS_VAL,0)) ESTIMATED_REDUCTION,
		(RPT.LOAD_VAL + NVL(RPT.FAILURE_VAL,0) + NVL(RPT.OPT_OUT_VAL,0) + NVL(EST.OVERRIDE_VAL,0)
				+ NVL(RPT.TX_LOSS_VAL,0) + NVL(RPT.DX_LOSS_VAL,0)) REPORTED_REDUCTION
	FROM SYSTEM_DATE_TIME SDT, DR_EVENT_SCHEDULE SCHED, DER_VPP_RESULT_DATA FCAST,
		DER_VPP_RESULT_DATA EST, DER_VPP_RESULT_DATA RPT
	WHERE SDT.TIME_ZONE = p_TIME_ZONE
		AND SDT.DATA_INTERVAL_TYPE = 1
		AND SDT.DAY_TYPE = '1'
		AND SDT.CUT_DATE BETWEEN v_FILTER_BEGIN AND v_FILTER_END
		AND SDT.MINIMUM_INTERVAL_NUMBER >= v_INTERVAL_NUM
		AND SCHED.EVENT_ID (+) = p_EVENT_ID
		AND SCHED.SCHEDULE_DATE (+) = SDT.CUT_DATE
		AND FCAST.DER_VPP_RESULT_ID (+) = v_FORECAST_RESULT_ID
		AND FCAST.RESULT_DATE (+) = SDT.CUT_DATE
		AND EST.DER_VPP_RESULT_ID (+) = v_ESTIMATED_RESULT_ID
		AND EST.RESULT_DATE (+) = SDT.CUT_DATE
		AND RPT.DER_VPP_RESULT_ID (+) = v_REPORTED_RESULT_ID
		AND RPT.RESULT_DATE (+) = SDT.CUT_DATE
	ORDER BY SDT.CUT_DATE;

END EVENT_DETAILS_INTERVAL_DATA;
--------------------------------------------------------------------------------
PROCEDURE EVENT_DETAILS_EXCEPTION
(
	p_EVENT_ID IN NUMBER,
	p_EXCEPTION_TYPE IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_CURSOR IN OUT GA.REFCURSOR
) AS

BEGIN

	OPEN p_CURSOR FOR
	SELECT
	(SELECT MAX(A.ACCOUNT_NAME)
	 FROM ACCOUNT_SERVICE_LOCATION ASL, ACCOUNT A
	 WHERE ASL.SERVICE_LOCATION_ID = DER.SERVICE_LOCATION_ID
		AND ASL.ACCOUNT_ID = A.ACCOUNT_ID
		AND ASL.BEGIN_DATE <= EV.STOP_TIME
		AND  NVL(ASL.END_DATE,CONSTANTS.HIGH_DATE) >= EV.START_TIME) AS ACCOUNT_NAME,
		DER.DER_NAME, FROM_CUT(EXCPT.EXCEPTION_DATE, p_TIME_ZONE) AS EXCEPTION_DATE,
		-- THE PRIOR_TO_EVENT COLUMN IS ONLY SHOWN FOR FAILURE EXCEPTIONS, OTHERWISE IT'S HIDDEN WHEN NULL
		CASE WHEN p_EXCEPTION_TYPE = DEMAND_RESPONSE_UTIL.c_EXCEPTION_TYPE_FAILURE
				AND EXCPT.EXCEPTION_DATE < NVL(EV.START_TIME, CONSTANTS.LOW_DATE) THEN 'Y'
			 WHEN p_EXCEPTION_TYPE = DEMAND_RESPONSE_UTIL.c_EXCEPTION_TYPE_FAILURE
				AND EXCPT.EXCEPTION_DATE >= NVL(EV.START_TIME, CONSTANTS.LOW_DATE) THEN 'N'
			 ELSE NULL END PRIOR_TO_EVENT
	FROM DR_EVENT_EXCEPTION EXCPT, DISTRIBUTED_ENERGY_RESOURCE DER, DR_EVENT EV
	WHERE EV.EVENT_ID = p_EVENT_ID
		AND EXCPT.EVENT_ID = EV.EVENT_ID
		AND EXCPT.EXCEPTION_TYPE = p_EXCEPTION_TYPE
		AND DER.DER_ID = EXCPT.DER_ID;

END EVENT_DETAILS_EXCEPTION;
--------------------------------------------------------------------------------
PROCEDURE EVENT_DETAILS_PARTICIPANTS
(
	p_EVENT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SEARCH_STRING IN VARCHAR2,
	p_SEARCH_OPTION IN VARCHAR,
	p_SEARCH_OPTION_NAME OUT VARCHAR2,
	p_CURSOR IN OUT GA.REFCURSOR
) AS

	v_BEGIN_DATE DATE;
	v_END_DATE DATE;

BEGIN
	UT.CUT_DATE_RANGE(CONSTANTS.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	-- If the search is by 'Account'
	IF REGEXP_INSTR(p_SEARCH_OPTION, '^Account[[:space:]]{1}-[[:space:]]{1}') > 0 THEN

		IF p_SEARCH_OPTION = 'Account - By Alias' THEN
			p_SEARCH_OPTION_NAME := 'Account Alias';
		ELSIF p_SEARCH_OPTION = 'Account - By External Identifier' THEN
			p_SEARCH_OPTION_NAME := 'Account External Identifier';
		ELSE
			p_SEARCH_OPTION_NAME := NULL;
		END IF;

		OPEN p_CURSOR FOR
		SELECT CASE p_SEARCH_OPTION
						WHEN 'Account - By Alias' THEN
							A.ACCOUNT_ALIAS
						WHEN 'Account - By External Identifier' THEN
							A.ACCOUNT_EXTERNAL_IDENTIFIER
						ELSE
							NULL
				END AS SEARCH_FIELD,
				A.ACCOUNT_NAME, SL.SERVICE_LOCATION_NAME, DER.DER_NAME, P.ENTRY_DATE
			FROM DR_EVENT_PARTICIPATION P,
				DISTRIBUTED_ENERGY_RESOURCE DER,
				ACCOUNT_SERVICE_LOCATION ASL,
				SERVICE_LOCATION SL,
				ACCOUNT A
			WHERE P.EVENT_ID = p_EVENT_ID
				AND DER.DER_ID = P.DER_ID
				AND ASL.SERVICE_LOCATION_ID = DER.SERVICE_LOCATION_ID
				AND ASL.BEGIN_DATE <= v_END_DATE
				AND NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE) >= v_BEGIN_DATE
				AND SL.SERVICE_LOCATION_ID = ASL.SERVICE_LOCATION_ID
				AND A.ACCOUNT_ID = ASL.ACCOUNT_ID
				AND ((p_SEARCH_OPTION = 'Account - By Name' AND A.ACCOUNT_NAME LIKE p_SEARCH_STRING) OR
					  (p_SEARCH_OPTION = 'Account - By Alias' AND A.ACCOUNT_ALIAS LIKE p_SEARCH_STRING) OR
					  (p_SEARCH_OPTION = 'Account - By External Identifier' AND A.ACCOUNT_EXTERNAL_IDENTIFIER LIKE p_SEARCH_STRING) OR
					  (p_SEARCH_STRING IS NULL OR p_SEARCH_STRING = '%'))
			ORDER BY A.ACCOUNT_NAME, SL.SERVICE_LOCATION_NAME, DER.DER_NAME;

	-- If the search is by 'Service Location'
	ELSIF REGEXP_INSTR(p_SEARCH_OPTION, '^Service Location[[:space:]]{1}-[[:space:]]{1}') > 0 THEN

		IF p_SEARCH_OPTION = 'Service Location - By Alias' THEN
			p_SEARCH_OPTION_NAME := 'Service Location Alias';
		ELSIF p_SEARCH_OPTION = 'Service Location - By External Identifier' THEN
			p_SEARCH_OPTION_NAME := 'Service Location External Identifier';
		ELSIF p_SEARCH_OPTION = 'Service Location - By Address' THEN
			p_SEARCH_OPTION_NAME := 'Service Location Address';
		ELSE
			p_SEARCH_OPTION_NAME := NULL;
		END IF;

		OPEN p_CURSOR FOR
		SELECT CASE p_SEARCH_OPTION
					WHEN 'Service Location - By Alias' THEN
						SL.SERVICE_LOCATION_ALIAS
					WHEN 'Service Location - By External Identifier' THEN
						SL.EXTERNAL_IDENTIFIER
					WHEN 'Service Location - By Address' THEN
						AI.STREET
					ELSE
						NULL
			END AS SEARCH_FIELD,
			A.ACCOUNT_NAME, SL.SERVICE_LOCATION_NAME, DER.DER_NAME, P.ENTRY_DATE
			FROM DR_EVENT_PARTICIPATION P,
				DISTRIBUTED_ENERGY_RESOURCE DER,
				ACCOUNT_SERVICE_LOCATION ASL,
				SERVICE_LOCATION SL,
				ACCOUNT A,
			ADDRESS_INFO AI
			WHERE P.EVENT_ID = p_EVENT_ID
				AND DER.DER_ID = P.DER_ID
				AND ASL.SERVICE_LOCATION_ID = DER.SERVICE_LOCATION_ID
				AND ASL.BEGIN_DATE <= v_END_DATE
				AND NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE) >= v_BEGIN_DATE
				AND SL.SERVICE_LOCATION_ID = ASL.SERVICE_LOCATION_ID
				AND A.ACCOUNT_ID = ASL.ACCOUNT_ID
			AND AI.ENTITY_DOMAIN_ID (+) = EC.ED_SERVICE_LOCATION
			AND AI.OWNER_ENTITY_ID (+) = SL.SERVICE_LOCATION_ID
			AND AI.CATEGORY_ID (+) = ACCOUNTS_METERS.c_LOCALE_CATEGORY
			AND ((p_SEARCH_OPTION = 'Service Location - By Name' AND SL.SERVICE_LOCATION_NAME LIKE p_SEARCH_STRING) OR
				  (p_SEARCH_OPTION = 'Service Location - By Alias' AND SL.SERVICE_LOCATION_ALIAS LIKE p_SEARCH_STRING) OR
				  (p_SEARCH_OPTION = 'Service Location - By Address' AND AI.STREET LIKE p_SEARCH_STRING) OR
				  (p_SEARCH_OPTION = 'Service Location - By External Identifier' AND SL.EXTERNAL_IDENTIFIER LIKE p_SEARCH_STRING) OR
				  (p_SEARCH_STRING IS NULL OR p_SEARCH_STRING = '%'))
			ORDER BY A.ACCOUNT_NAME, SL.SERVICE_LOCATION_NAME, DER.DER_NAME;


	-- If the search is by 'DER Type'
	ELSIF REGEXP_INSTR(p_SEARCH_OPTION, '^DER Type[[:space:]]{1}-[[:space:]]{1}') > 0 THEN

		IF p_SEARCH_OPTION = 'DER Type - By Alias' THEN
			p_SEARCH_OPTION_NAME := 'DER Type Alias';
		ELSIF p_SEARCH_OPTION = 'DER Type - By Name' THEN
			p_SEARCH_OPTION_NAME := 'DER Type Name';
		ELSIF p_SEARCH_OPTION = 'DER Type - By External Identifier' THEN
			p_SEARCH_OPTION_NAME := 'DER Type External Identifier';
		END IF;

		OPEN p_CURSOR FOR
		SELECT CASE p_SEARCH_OPTION
			WHEN 'DER Type - By Alias' THEN
				DT.DER_TYPE_ALIAS
			WHEN 'DER Type - By Name' THEN
				DT.DER_TYPE_NAME
			WHEN 'DER Type - By External Identifier' THEN
				DT.EXTERNAL_IDENTIFIER
			END AS SEARCH_FIELD,
			A.ACCOUNT_NAME, SL.SERVICE_LOCATION_NAME, DER.DER_NAME, P.ENTRY_DATE
			FROM DR_EVENT_PARTICIPATION P,
				DISTRIBUTED_ENERGY_RESOURCE DER,
				ACCOUNT_SERVICE_LOCATION ASL,
				SERVICE_LOCATION SL,
				ACCOUNT A,
			DER_TYPE DT
			WHERE P.EVENT_ID = p_EVENT_ID
				AND DER.DER_ID = P.DER_ID
				AND ASL.SERVICE_LOCATION_ID = DER.SERVICE_LOCATION_ID
				AND ASL.BEGIN_DATE <= v_END_DATE
				AND NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE) >= v_BEGIN_DATE
				AND SL.SERVICE_LOCATION_ID = ASL.SERVICE_LOCATION_ID
				AND A.ACCOUNT_ID = ASL.ACCOUNT_ID
			AND DER.DER_TYPE_ID = DT.DER_TYPE_ID
			AND ((p_SEARCH_OPTION = 'DER Type - By Alias' AND DT.DER_TYPE_ALIAS LIKE p_SEARCH_STRING) OR
				  (p_SEARCH_OPTION = 'DER Type - By Name' AND DT.DER_TYPE_NAME LIKE p_SEARCH_STRING) OR
				  (p_SEARCH_OPTION = 'DER Type - By External Identifier' AND DT.EXTERNAL_IDENTIFIER LIKE p_SEARCH_STRING) OR
				  (p_SEARCH_STRING IS NULL OR p_SEARCH_STRING = '%'))
		ORDER BY CASE p_SEARCH_OPTION
			WHEN 'DER Type - By Alias' THEN
				DT.DER_TYPE_ALIAS
			WHEN 'DER Type - By Name' THEN
				DT.DER_TYPE_NAME
			WHEN 'DER Type - By External Identifier' THEN
				DT.EXTERNAL_IDENTIFIER
			END, A.ACCOUNT_NAME, SL.SERVICE_LOCATION_NAME, DER.DER_NAME;

	END IF;

END EVENT_DETAILS_PARTICIPANTS;
--------------------------------------------------------------------------------
PROCEDURE EVENT_DETAILS
(
	p_EVENT_ID IN NUMBER,
	p_VPP_ID IN NUMBER,
	p_DETAIL_TYPE IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SEARCH_STRING IN VARCHAR2, -- Required for Participants report only
	p_SEARCH_OPTION IN VARCHAR2, -- Required for Participants report only
	p_SEARCH_OPTION_NAME OUT VARCHAR2, -- Required for Participants report only
	p_CURSOR IN OUT GA.REFCURSOR
) AS

BEGIN

	IF p_EVENT_ID IS NULL THEN -- NEW EVENT BEING CREATED, JUST RETURN NULL
		OPEN p_CURSOR FOR
		SELECT NULL
		FROM DUAL;

		RETURN;
	END IF;

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_EVENT_ID, EC.ED_DR_EVENT);

	IF p_DETAIL_TYPE = 'Interval Data' THEN
		EVENT_DETAILS_INTERVAL_DATA(p_EVENT_ID, p_VPP_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_CURSOR);
	ELSIF p_DETAIL_TYPE = 'Participants' THEN
		EVENT_DETAILS_PARTICIPANTS(p_EVENT_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, NVL(p_SEARCH_STRING, '%'), p_SEARCH_OPTION, p_SEARCH_OPTION_NAME, p_CURSOR);
	ELSIF p_DETAIL_TYPE = 'Failures' THEN
		EVENT_DETAILS_EXCEPTION(p_EVENT_ID, DEMAND_RESPONSE_UTIL.c_EXCEPTION_TYPE_FAILURE, p_TIME_ZONE, p_CURSOR);
	ELSIF p_DETAIL_TYPE = 'Opt-Outs' THEN
		EVENT_DETAILS_EXCEPTION(p_EVENT_ID, DEMAND_RESPONSE_UTIL.c_EXCEPTION_TYPE_OPTOUT, p_TIME_ZONE, p_CURSOR);
	ELSIF p_DETAIL_TYPE = 'Overrides' THEN
		EVENT_DETAILS_EXCEPTION(p_EVENT_ID, DEMAND_RESPONSE_UTIL.c_EXCEPTION_TYPE_OVERRIDE, p_TIME_ZONE, p_CURSOR);
	ELSIF p_DETAIL_TYPE = 'Event History' THEN
		AUDIT_TRAIL.GET_ENTITY_RECORDS(EC.ED_DR_EVENT, p_EVENT_ID, NULL, NULL, p_CURSOR);
	END IF;

END EVENT_DETAILS;
--------------------------------------------------------------------------------
PROCEDURE PUT_EVENT_INTERVAL_DATA
(
	p_EVENT_ID IN NUMBER,
	p_CUT_DATE IN DATE,
	p_DISPATCH_SCHED IN NUMBER,
	p_PRICE IN NUMBER
) AS

BEGIN

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_EVENT_ID, EC.ED_DR_EVENT);

	UPDATE DR_EVENT_SCHEDULE
	SET AMOUNT = NVL(p_DISPATCH_SCHED, AMOUNT),
		PRICE = NVL(p_PRICE, PRICE)
	WHERE EVENT_ID = p_EVENT_ID
		AND SCHEDULE_DATE = p_CUT_DATE;

	IF SQL%NOTFOUND THEN
		INSERT INTO DR_EVENT_SCHEDULE (EVENT_ID, SCHEDULE_DATE, AMOUNT, PRICE)
		VALUES (p_EVENT_ID, p_CUT_DATE, p_DISPATCH_SCHED, p_PRICE);
	END IF;

END PUT_EVENT_INTERVAL_DATA;
---------------------------------------------------------------------------------------------------
FUNCTION GET_ENV_SIGNAL_NAME
	(
	p_PROGRAM_ID IN NUMBER,
	p_AMOUNT IN NUMBER
	) RETURN VARCHAR2 IS
	v_THRESHOLD_NAME PROGRAM_THRESHOLD.THRESHOLD_NAME%TYPE;
BEGIN
	-- Get the first range of MIN/MAX values
	SELECT THRESHOLD_NAME INTO  v_THRESHOLD_NAME
    FROM (SELECT T.THRESHOLD_NAME
			FROM PROGRAM_THRESHOLD T
			WHERE T.PROGRAM_ID = p_PROGRAM_ID
			AND p_AMOUNT BETWEEN T.MIN_VALUE AND NVL(T.MAX_VALUE, p_AMOUNT)
 			ORDER BY MIN_VALUE)
	WHERE ROWNUM = 1;

	RETURN v_THRESHOLD_NAME;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
		RETURN NULL;
END GET_ENV_SIGNAL_NAME;
-------------------------------------------------------------------------------
PROCEDURE ENTITY_LIST_FOR_DER_SUMMARY
(
	p_SUMMARY_TYPE in VARCHAR2,
	p_ENTITY_DOMAIN_ID in NUMBER,
	p_CURSOR OUT GA.REFCURSOR
) AS

v_IDs ID_TABLE;

BEGIN
	IF p_ENTITY_DOMAIN_ID IN (EC.ED_PROGRAM, EC.ED_VPP) THEN
		v_IDS := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_SELECT_DER_RESULTS, EC.ED_PROGRAM);
	END IF;

	IF p_SUMMARY_TYPE = SUMMARY_TYPE_CPP THEN
		OPEN p_CURSOR FOR
			SELECT VPP.VPP_NAME ENTITY_NAME,
				VPP.VPP_ID ENTITY_ID
			FROM VIRTUAL_POWER_PLANT VPP, PROGRAM P, TABLE(CAST(v_IDS AS ID_TABLE)) X
			WHERE X.ID IN (SD.g_ALL_DATA_ENTITY_ID, P.PROGRAM_ID)
				AND VPP.PROGRAM_ID = P.PROGRAM_ID AND
				(P.PROGRAM_TYPE = DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_CRIT_PRICING OR
				 P.PROGRAM_TYPE = DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_PK_TIME_REBATE);
	ELSE
		IF p_ENTITY_DOMAIN_ID = EC.ED_PROGRAM THEN
			OPEN p_CURSOR FOR
				SELECT P.PROGRAM_NAME ENTITY_NAME,
					P.PROGRAM_ID ENTITY_ID
				FROM PROGRAM P, TABLE(CAST(v_IDS AS ID_TABLE)) X
			WHERE X.ID IN (SD.g_ALL_DATA_ENTITY_ID, P.PROGRAM_ID);
		ELSIF p_ENTITY_DOMAIN_ID = EC.ED_VPP THEN
			OPEN p_CURSOR FOR
				SELECT VPP.VPP_NAME ENTITY_NAME,
					VPP.VPP_ID ENTITY_ID
				FROM VIRTUAL_POWER_PLANT VPP, TABLE(CAST(v_IDS AS ID_TABLE)) X
				WHERE X.ID IN (VPP.PROGRAM_ID,SD.g_ALL_DATA_ENTITY_ID);
		ELSE
			OPEN p_CURSOR FOR
				SELECT SZ.SERVICE_ZONE_NAME ENTITY_NAME,
					SZ.SERVICE_ZONE_ID ENTITY_ID
				FROM SERVICE_ZONE SZ;
		END IF;
	END IF;

END ENTITY_LIST_FOR_DER_SUMMARY;
--------------------------------------------------------------------------------
PROCEDURE FEEDER_SEGMENT_BY_SERVICE_ZONE
	(
	p_SERVICE_ZONE_ID IN NUMBER,
	p_SEARCH_STRING IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN

	IF p_SEARCH_STRING = '%' OR p_SEARCH_STRING IS NULL THEN
		OPEN p_CURSOR FOR
			SELECT FS.FEEDER_SEGMENT_ID,
				   FS.FEEDER_SEGMENT_NAME
			FROM SERVICE_ZONE SZ, TX_SUB_STATION SS, TX_FEEDER F, TX_FEEDER_SEGMENT FS
			WHERE SZ.SERVICE_ZONE_ID = p_SERVICE_ZONE_ID
				AND SS.SERVICE_ZONE_ID = SZ.SERVICE_ZONE_ID
				AND NVL(SS.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
				AND SS.BEGIN_DATE <= p_END_DATE
				AND F.SUB_STATION_ID = SS.SUB_STATION_ID
				AND NVL(F.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
				AND F.BEGIN_DATE <= p_END_DATE
				AND (FS.FEEDER_ID = F.FEEDER_ID OR FS.FEEDER_SEGMENT_ID = CONSTANTS.NOT_ASSIGNED)
				AND NVL(FS.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
				AND FS.BEGIN_DATE <= p_END_DATE
			ORDER BY 2;
	ELSE
		OPEN p_CURSOR FOR
			SELECT FS.FEEDER_SEGMENT_ID,
				   FS.FEEDER_SEGMENT_NAME
			FROM SERVICE_ZONE SZ, TX_SUB_STATION SS, TX_FEEDER F, TX_FEEDER_SEGMENT FS
			WHERE SZ.SERVICE_ZONE_ID = p_SERVICE_ZONE_ID
				AND SS.SERVICE_ZONE_ID = SZ.SERVICE_ZONE_ID
				AND NVL(SS.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
				AND SS.BEGIN_DATE <= p_END_DATE
				AND F.SUB_STATION_ID = SS.SUB_STATION_ID
				AND NVL(F.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
				AND F.BEGIN_DATE <= p_END_DATE
				AND (FS.FEEDER_ID = F.FEEDER_ID OR FS.FEEDER_SEGMENT_ID = CONSTANTS.NOT_ASSIGNED)
				AND NVL(FS.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
				AND FS.BEGIN_DATE <= p_END_DATE
				AND FS.FEEDER_SEGMENT_NAME LIKE '%' || p_SEARCH_STRING || '%'
			ORDER BY 2;
	END IF;

END FEEDER_SEGMENT_BY_SERVICE_ZONE;
-------------------------------------------------------------------------------------------
PROCEDURE CALC_DER_RESULT_SL
(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INTERVAL IN VARCHAR2,
	p_TIME_ZONE in VARCHAR2,
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_ENTITY_TYPES IN VARCHAR2,
	p_RESULTS OUT CAPACITY_REPORT_TEMP_TABLE
) AS

v_CUT_BEGIN_DATE DATE;
v_CUT_END_DATE DATE;

v_INTERVAL_ABBR VARCHAR(4) := GET_INTERVAL_ABBREVIATION(p_INTERVAL);

BEGIN
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_CUT_BEGIN_DATE, v_CUT_END_DATE);

	SELECT CAPACITY_REPORT_TEMP_TYPE
		(SDT.CUT_DATE,
		CASE v_INTERVAL_ABBR
				WHEN 'DD' THEN TRIM(SDT.DAY_YYYY_MM_DD)
				WHEN 'MM' THEN TRIM(SDT.MONTH_YYYY_MM_DD)
				WHEN 'MI30' THEN TRIM(SDT.MI30_YYYY_MM_DD)
				WHEN 'MI15' THEN TRIM(SDT.MI15_YYYY_MM_DD)
				ELSE TRIM(SDT.HOUR_YYYY_MM_DD)
		END,
		DATE_DAY_NAME(SDT.CUT_DATE,DETAIL.EDC_ID),
		DETAIL.ENTITY_ID,
		DETAIL.ENTITY_NAME,
		DETAIL.F_DATA*CASE WHEN DETAIL.H_DATA <= 0 THEN 0 ELSE 1 END, -- FORECAST
		DETAIL.F_DATA, -- unconstrained val
		DETAIL.R_DATA, -- REPORTED reduction
		DETAIL.E_DATA*CASE WHEN NVL(DETAIL.R_DATA,0) = 0 THEN 0 ELSE 1 END,
		SDT.IS_ON_PEAK,
		0,
		-1,
		-1,
		-1)
	BULK COLLECT INTO p_RESULTS
	FROM -- We can't outer-join more than one table at a time, so we
			-- put all the queries for load values into a sub query.
			-- We query for all DER_DAILY_RESULTS regardless of Service Code
			-- and IS_EXTERNAL, and then use SUMs with Case statements to put them all into
			-- the correct inner query column
		(SELECT DT.RESULT_DATE,
				DAILY.EDC_ID,
				CASE WHEN p_ENTITY_TYPES = 'Resource' THEN DAILY.DER_ID
					WHEN p_ENTITY_TYPES = 'Resource Type' THEN DAILY.DER_TYPE_ID
					WHEN p_ENTITY_TYPES = 'Program' THEN DAILY.PROGRAM_ID
				END AS ENTITY_ID,
				CASE WHEN p_ENTITY_TYPES = 'Resource' THEN DER.DER_NAME
					WHEN p_ENTITY_TYPES = 'Resource Type' THEN DER_T.DER_TYPE_NAME
					WHEN p_ENTITY_TYPES = 'Program' THEN P.PROGRAM_NAME
				END AS ENTITY_NAME,
				SUM(CASE WHEN DAILY.SERVICE_CODE = CONSTANTS.CODE_FORECAST AND
						DAILY.IS_EXTERNAL = 0 THEN
					DT.RESULT_VAL*DAILY.SCALE_FACTOR
				ELSE
					NULL
				END) AS F_DATA,
				SUM(CASE WHEN DAILY.SERVICE_CODE = CONSTANTS.CODE_BACKCAST AND
						DAILY.IS_EXTERNAL = 0 THEN
					DT.RESULT_VAL*DAILY.SCALE_FACTOR
				ELSE
					NULL
				END) AS E_DATA,
				SUM(CASE WHEN DAILY.SERVICE_CODE = CONSTANTS.CODE_BACKCAST AND
						DAILY.IS_EXTERNAL = 1 THEN
					DT.RESULT_VAL*DAILY.SCALE_FACTOR
				ELSE
					NULL
				END) AS R_DATA,
				-- only forecast data has hits data
				SUM(CASE WHEN DAILY.SERVICE_CODE = CONSTANTS.CODE_FORECAST AND
						DAILY.IS_EXTERNAL = 0 THEN
					HITS.RESULT_VAL
				ELSE
					NULL
				END) AS H_DATA
			FROM DER_DAILY_RESULT DAILY,
				LOAD_RESULT_DATA DT,
				LOAD_RESULT_DATA HITS,
				DER_TYPE DER_T,
				DISTRIBUTED_ENERGY_RESOURCE DER,
				PROGRAM P
			WHERE DAILY.SCENARIO_ID = p_SCENARIO_ID
				AND DAILY.RESULT_DAY BETWEEN p_BEGIN_DATE AND p_END_DATE
				AND DAILY.ACCOUNT_ID = p_ACCOUNT_ID
				AND DAILY.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
				AND DT.LOAD_RESULT_ID = DAILY.LOAD_SHAPE_RESULT_ID
				AND DT.RESULT_DATE BETWEEN DAILY.CUT_BEGIN_DATE AND DAILY.CUT_END_DATE
				AND HITS.LOAD_RESULT_ID (+) = DAILY.HITS_REMAINING_RESULT_ID
				AND HITS.RESULT_DATE (+) BETWEEN DAILY.CUT_BEGIN_DATE AND DAILY.CUT_END_DATE
				AND (DT.RESULT_DATE = HITS.RESULT_DATE OR HITS.LOAD_RESULT_ID IS NULL)
				AND DER_T.DER_TYPE_ID = DAILY.DER_TYPE_ID
				AND DER.DER_ID = DAILY.DER_ID
				AND P.PROGRAM_ID = DAILY.PROGRAM_ID
			GROUP BY DT.RESULT_DATE, DAILY.EDC_ID,
				 CASE WHEN p_ENTITY_TYPES = 'Resource' THEN DAILY.DER_ID
					WHEN p_ENTITY_TYPES = 'Resource Type' THEN DAILY.DER_TYPE_ID
					WHEN p_ENTITY_TYPES = 'Program' THEN DAILY.PROGRAM_ID
				END,
				CASE WHEN p_ENTITY_TYPES = 'Resource' THEN DER.DER_NAME
					WHEN p_ENTITY_TYPES = 'Resource Type' THEN DER_T.DER_TYPE_NAME
					WHEN p_ENTITY_TYPES = 'Program' THEN P.PROGRAM_NAME
				END) DETAIL,
			SYSTEM_DATE_TIME SDT
		WHERE SDT.TIME_ZONE = p_TIME_ZONE
			AND SDT.DATA_INTERVAL_TYPE = 1
			AND SDT.DAY_TYPE = '1'
			AND SDT.CUT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
			AND DETAIL.RESULT_DATE (+) = SDT.CUT_DATE;

END	CALC_DER_RESULT_SL;
--------------------------------------------------------------------------------

PROCEDURE CALC_DER_RESULT_ACC_TEMP
(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INTERVAL IN VARCHAR2,
	p_TIME_ZONE in VARCHAR2,
	p_ACCOUNT_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_RESULTS OUT CAPACITY_REPORT_TEMP_TABLE
) AS

v_CUT_BEGIN_DATE DATE;
v_CUT_END_DATE DATE;

v_INTERVAL_ABBR VARCHAR(4) := GET_INTERVAL_ABBREVIATION(p_INTERVAL);

BEGIN
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_CUT_BEGIN_DATE, v_CUT_END_DATE);

	SELECT CAPACITY_REPORT_TEMP_TYPE
		(SDT.CUT_DATE,
		CASE v_INTERVAL_ABBR
			WHEN 'DD' THEN TRIM(SDT.DAY_YYYY_MM_DD)
			WHEN 'MM' THEN TRIM(SDT.MONTH_YYYY_MM_DD)
			WHEN 'MI30' THEN TRIM(SDT.MI30_YYYY_MM_DD)
			WHEN 'MI15' THEN TRIM(SDT.MI15_YYYY_MM_DD)
			ELSE TRIM(SDT.HOUR_YYYY_MM_DD)
		END,
		DATE_DAY_NAME(SDT.CUT_DATE,DETAIL.EDC_ID),
		DETAIL.DER_ID,
		DETAIL.DER_NAME,
		DETAIL.F_DATA*CASE WHEN DETAIL.H_DATA <= 0 THEN 0 ELSE 1 END, -- FORECAST
		DETAIL.F_DATA, -- unconstrained val
		DETAIL.R_DATA, -- REPORTED reduction
		DETAIL.E_DATA*CASE WHEN NVL(DETAIL.R_DATA,0) = 0 THEN 0 ELSE 1 END,
		SDT.IS_ON_PEAK,
		CASE WHEN EXISTS
			(SELECT 1 FROM (SELECT E.START_TIME, E.STOP_TIME
				FROM (SELECT DISTINCT SLP.PROGRAM_ID
						FROM SERVICE_LOCATION_PROGRAM SLP,
							ACCOUNT_SERVICE_LOCATION ASL,
							PROGRAM P
						WHERE ASL.ACCOUNT_ID = p_ACCOUNT_ID
							AND ASL.BEGIN_DATE <= p_END_DATE
							AND NVL(ASL.END_DATE,CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE

							AND SLP.SERVICE_LOCATION_ID = ASL.SERVICE_LOCATION_ID
							AND SLP.BEGIN_DATE <= ASL.END_DATE
							AND NVL(SLP.END_DATE,CONSTANTS.HIGH_DATE) >= ASL.BEGIN_DATE

						AND P.PROGRAM_ID = SLP.PROGRAM_ID
							AND P.PROGRAM_TYPE IN (DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_PK_TIME_REBATE,
							DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_CRIT_PRICING)) TEST, --TODO CHECK THIS
						DR_EVENT E,
						VIRTUAL_POWER_PLANT VPP
					WHERE VPP.PROGRAM_ID = TEST.PROGRAM_ID
						AND E.VPP_ID = VPP.VPP_ID) CRITICAL_EVENT_DATES
				WHERE SDT.CUT_DATE > CRITICAL_EVENT_DATES.START_TIME
					AND SDT.CUT_DATE <= CRITICAL_EVENT_DATES.STOP_TIME)
			THEN 1 ELSE 0
		END,
		SERVICE_LOAD_DATA.BASELINE_LOAD,
		SERVICE_LOAD_DATA.METERED_LOAD,
		SERVICE_LOAD_DATA.OBSERVED_REDUCTION
		)
	BULK COLLECT INTO p_RESULTS
	FROM -- We can't outer-join more than one table at a time, so we
			-- put all the queries for load values into a sub query.
			-- We query for all DER_DAILY_RESULTS regardless of Service Code
			-- and IS_EXTERNAL, and then use SUMs with Case statements to put them all into
			-- the correct inner query column

		-- each type (forecast, estimated, etc) can have its own scale factor, which is why
		-- that logic is in the inner query
		(SELECT DT.RESULT_DATE,
				DAILY.EDC_ID,
				DAILY.DER_ID,
				DER.DER_NAME,
				SUM(CASE WHEN DAILY.SERVICE_CODE = CONSTANTS.CODE_FORECAST AND
						DAILY.IS_EXTERNAL = 0 THEN
					DT.RESULT_VAL*DAILY.SCALE_FACTOR
				ELSE
					NULL
				END) AS F_DATA,
				SUM(CASE WHEN DAILY.SERVICE_CODE = CONSTANTS.CODE_BACKCAST AND
						DAILY.IS_EXTERNAL = 0 THEN
					DT.RESULT_VAL*DAILY.SCALE_FACTOR
				ELSE
					NULL
				END) AS E_DATA,
				SUM(CASE WHEN DAILY.SERVICE_CODE = CONSTANTS.CODE_BACKCAST AND
						DAILY.IS_EXTERNAL = 1 THEN
					DT.RESULT_VAL*DAILY.SCALE_FACTOR
				ELSE
					NULL
				END) AS R_DATA,
				-- hits data is only for forecast
				SUM(CASE WHEN DAILY.SERVICE_CODE = CONSTANTS.CODE_FORECAST AND
						DAILY.IS_EXTERNAL = 0 THEN
					HITS.RESULT_VAL
				ELSE
					NULL
				END) AS H_DATA
			FROM DER_DAILY_RESULT DAILY,
				LOAD_RESULT_DATA DT,
				LOAD_RESULT_DATA HITS,
				DISTRIBUTED_ENERGY_RESOURCE DER
			WHERE DAILY.SCENARIO_ID = p_SCENARIO_ID
				AND DAILY.RESULT_DAY BETWEEN p_BEGIN_DATE AND p_END_DATE
				AND DAILY.ACCOUNT_ID = p_ACCOUNT_ID
				AND DT.LOAD_RESULT_ID = DAILY.LOAD_SHAPE_RESULT_ID
				AND DT.RESULT_DATE BETWEEN DAILY.CUT_BEGIN_DATE AND DAILY.CUT_END_DATE
				AND HITS.LOAD_RESULT_ID (+) = DAILY.HITS_REMAINING_RESULT_ID
				AND HITS.RESULT_DATE (+) BETWEEN DAILY.CUT_BEGIN_DATE AND DAILY.CUT_END_DATE
				AND (DT.RESULT_DATE = HITS.RESULT_DATE OR HITS.LOAD_RESULT_ID IS NULL)
				AND DER.DER_ID = DAILY.DER_ID
			GROUP BY DT.RESULT_DATE, DAILY.EDC_ID, DAILY.SCALE_FACTOR,
				 DAILY.DER_ID, DER.DER_NAME) DETAIL,
			-- Calc baseline_load, metered_load and observed reduction for date range
			(SELECT SL.LOAD_DATE,
				SUM(SL.LOAD_VAL + SL.TX_LOSS_VAL + SL.DX_LOSS_VAL + SL.UE_LOSS_VAL) BASELINE_LOAD,
				SUM(SL_METERED.LOAD_VAL + SL_METERED.TX_LOSS_VAL + SL_METERED.DX_LOSS_VAL
					+ SL_METERED.UE_LOSS_VAL) METERED_LOAD,
				SUM(SL.LOAD_VAL - SL_METERED.LOAD_VAL) OBSERVED_REDUCTION
			FROM ACCOUNT_SERVICE A,
						SERVICE B,
						SERVICE_LOAD SL,
						SERVICE_LOAD SL_METERED
			WHERE A.ACCOUNT_ID = p_ACCOUNT_ID
						AND B.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
						AND B.SCENARIO_ID = p_SCENARIO_ID
						AND SL.SERVICE_ID = B.SERVICE_ID
						AND SL.SERVICE_CODE = CONSTANTS.CODE_FORECAST
						AND SL.LOAD_CODE = 1
						AND SL.LOAD_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
						AND SL_METERED.SERVICE_ID(+) = SL.SERVICE_ID
						AND SL_METERED.SERVICE_CODE(+) = CONSTANTS.CODE_ACTUAL
						AND SL_METERED.LOAD_CODE(+) = 1
						AND SL_METERED.LOAD_DATE(+) = SL.LOAD_DATE
			GROUP BY SL.LOAD_DATE) SERVICE_LOAD_DATA,
			SYSTEM_DATE_TIME SDT
		WHERE SDT.TIME_ZONE = p_TIME_ZONE
			AND SDT.DATA_INTERVAL_TYPE = 1
			AND SDT.DAY_TYPE = '1'
			AND SDT.CUT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE

			AND DETAIL.RESULT_DATE (+) = SDT.CUT_DATE
			AND SERVICE_LOAD_DATA.LOAD_DATE(+) = SDT.CUT_DATE;

	END	CALC_DER_RESULT_ACC_TEMP;
------------------------------------------------------------------------------------------------
PROCEDURE RESULT_SUMMARY
(
	p_SUMMARY_TYPE IN VARCHAR2,
	p_RESULTS IN CAPACITY_REPORT_TEMP_TABLE,
	p_CURSOR OUT GA.REFCURSOR
) AS

BEGIN
	IF p_SUMMARY_TYPE = SUMMARY_TYPE_ALL_DETAILS THEN
		OPEN p_CURSOR FOR
			SELECT SUBSTR(TEMP.ROLLUP_DATE,0,10)AS SCHEDULE_DATE,
				SUBSTR(TEMP.ROLLUP_DATE,12) AS SCHEDULE_TIME,
				TEMP.ENTITY_NAME ENTITY_NAME,
				SUM(TEMP.FORECAST_CAPABILITY) FORECAST_CAPABILITY,
				SUM(TEMP.UNCONSTRAINED_VAL) UNCONSTRAINED_VAL,
				SUM(TEMP.REPORTED_REDUCTION) REPORTED_REDUCTION,
				SUM(TEMP.ESTIMATED_REDUCTION) ESTIMATED_REDUCTION
			FROM TABLE(CAST(p_RESULTS AS CAPACITY_REPORT_TEMP_TABLE)) TEMP
			GROUP BY SUBSTR(TEMP.ROLLUP_DATE,0,10),
					SUBSTR(TEMP.ROLLUP_DATE,12),
					TEMP.ENTITY_NAME
				ORDER BY 1,2;

	ELSIF p_SUMMARY_TYPE = SUMMARY_TYPE_DAY_OF_WEEK THEN
		OPEN p_CURSOR FOR
			SELECT TEMP.DATE_DAY_NAME AS SCHEDULE_DATE,
				SUBSTR(TEMP.ROLLUP_DATE,12) AS SCHEDULE_TIME,
				TEMP.ENTITY_NAME ENTITY_NAME,
				SUM(TEMP.FORECAST_CAPABILITY) FORECAST_CAPABILITY,
				SUM(TEMP.UNCONSTRAINED_VAL) UNCONSTRAINED_VAL,
				SUM(TEMP.REPORTED_REDUCTION) REPORTED_REDUCTION,
				SUM(TEMP.ESTIMATED_REDUCTION) ESTIMATED_REDUCTION
			FROM TABLE(CAST(p_RESULTS AS CAPACITY_REPORT_TEMP_TABLE)) TEMP
			GROUP BY TEMP.DATE_DAY_NAME,
					SUBSTR(TEMP.ROLLUP_DATE,12),
					TEMP.ENTITY_NAME
				ORDER BY 1,2;

	ELSIF p_SUMMARY_TYPE = SUMMARY_TYPE_TOU THEN
		OPEN p_CURSOR FOR
			SELECT DECODE(GROUPING(TEMP.ROLLUP_DATE),1,' ',TEMP.ROLLUP_DATE) AS SCHEDULE_DATE,
				DECODE(GROUPING(TEMP.IS_ON_PEAK),1,'Total',
							DECODE(GROUPING(TEMP.ROLLUP_DATE),1,
								DECODE(TEMP.IS_ON_PEAK,1, 'Total On-Peak','Total Off-Peak'),
									DECODE(TEMP.IS_ON_PEAK,0,'Off-Peak','On-Peak'))) TOU,
				TEMP.ENTITY_NAME ENTITY_NAME,
				SUM(TEMP.FORECAST_CAPABILITY) FORECAST_CAPABILITY,
				SUM(TEMP.UNCONSTRAINED_VAL) UNCONSTRAINED_VAL,
				SUM(TEMP.REPORTED_REDUCTION) REPORTED_REDUCTION,
				SUM(TEMP.ESTIMATED_REDUCTION) ESTIMATED_REDUCTION
			FROM TABLE(CAST(p_RESULTS AS CAPACITY_REPORT_TEMP_TABLE)) TEMP
			GROUP BY GROUPING SETS ((TEMP.ROLLUP_DATE,
							TEMP.IS_ON_PEAK,TEMP.ENTITY_NAME),
							(TEMP.IS_ON_PEAK,TEMP.ENTITY_NAME),
							(TEMP.ENTITY_NAME))
			ORDER BY GROUPING(TEMP.ROLLUP_DATE) DESC,1,2;
	ELSE
		ERRS.RAISE_BAD_ARGUMENT('SUMMARY_TYPE',p_SUMMARY_TYPE);
	END IF;

END RESULT_SUMMARY;
------------------------------------------------------------------------------------------------
PROCEDURE LOAD_REDUCTION_DETAILS
(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SUMMARY_TYPE IN VARCHAR2,
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_INTERVAL IN VARCHAR2,
	p_ENTITY_TYPES IN VARCHAR2,
	p_SCENARIO_ID IN NUMBER,
	p_PEAK_PROGRAM OUT VARCHAR2,
	p_CURSOR IN OUT GA.REFCURSOR
) AS

v_SCENARIO_ID NUMBER(1);
v_RESULTS CAPACITY_REPORT_TEMP_TABLE := CAPACITY_REPORT_TEMP_TABLE();

BEGIN
	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE,p_BEGIN_DATE,p_END_DATE);
	SD.VERIFY_ACTION_IS_ALLOWED(SD.g_ACTION_SELECT_DER_RST_DET);

	IF p_SCENARIO_ID IS NULL THEN
		v_SCENARIO_ID := GA.BASE_SCENARIO_ID;
	ELSE
		v_SCENARIO_ID := p_SCENARIO_ID;
	END IF;

	IF p_ACCOUNT_ID IS NULL THEN
		OPEN p_CURSOR FOR
			SELECT NULL FROM DUAL;
	ELSIF p_SERVICE_LOCATION_ID IS NOT NULL THEN

		CALC_DER_RESULT_SL(p_BEGIN_DATE,p_END_DATE,p_INTERVAL,p_TIME_ZONE,p_ACCOUNT_ID,p_SERVICE_LOCATION_ID,v_SCENARIO_ID,p_ENTITY_TYPES,v_RESULTS);
		RESULT_SUMMARY(p_SUMMARY_TYPE,v_RESULTS,p_CURSOR);

	ELSE
		CALC_DER_RESULT_ACC_TEMP(p_BEGIN_DATE,p_END_DATE,p_INTERVAL,p_TIME_ZONE,p_ACCOUNT_ID,v_SCENARIO_ID,v_RESULTS);
		p_PEAK_PROGRAM := NULL;

		-- Get Peak Program for Account
		BEGIN
			SELECT P.PROGRAM_NAME
			INTO p_PEAK_PROGRAM
			FROM SERVICE_LOCATION_PROGRAM SLP,
				ACCOUNT_SERVICE_LOCATION ASL,
				PROGRAM P
			WHERE ASL.ACCOUNT_ID = p_ACCOUNT_ID
				AND ASL.BEGIN_DATE <= p_END_DATE
				AND NVL(ASL.END_DATE,CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE

				AND SLP.SERVICE_LOCATION_ID = ASL.SERVICE_LOCATION_ID
				AND SLP.BEGIN_DATE <= ASL.END_DATE
				AND NVL(SLP.END_DATE,CONSTANTS.HIGH_DATE) >= ASL.BEGIN_DATE

				AND P.PROGRAM_ID = SLP.PROGRAM_ID
				AND P.PROGRAM_TYPE IN (DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_CRIT_PRICING, DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_PK_TIME_REBATE)
				AND ROWNUM = 1;
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				p_PEAK_PROGRAM := NULL;
		END;

		IF p_SUMMARY_TYPE = SUMMARY_TYPE_ALL_DETAILS THEN
			OPEN p_CURSOR FOR
					SELECT
					SUBSTR(TEMP.ROLLUP_DATE,0,10)AS SCHEDULE_DATE,
					SUBSTR(TEMP.ROLLUP_DATE,12) AS SCHEDULE_TIME,
					MAX(TEMP.BASELINE_LOAD) BASELINE_LOAD,
					MAX(TEMP.METERED_LOAD) METERED_LOAD,
					MAX(TEMP.OBSERVED_REDUCTION) OBSERVED_REDUCTION,
					SUM(TEMP.FORECAST_CAPABILITY) FORECAST_CAPABILITY,
					SUM(TEMP.UNCONSTRAINED_VAL) UNCONSTRAINED_VAL,
					SUM(TEMP.REPORTED_REDUCTION) REPORTED_REDUCTION,
					SUM(TEMP.ESTIMATED_REDUCTION) ESTIMATED_REDUCTION,
					MAX(IS_CRIT_PEAK) IS_CRITICAL_PEAK
				FROM TABLE(CAST(v_RESULTS AS CAPACITY_REPORT_TEMP_TABLE)) TEMP
				GROUP BY SUBSTR(TEMP.ROLLUP_DATE,0,10),
						SUBSTR(TEMP.ROLLUP_DATE,12)
				ORDER BY 1,2;
		ELSIF p_SUMMARY_TYPE = SUMMARY_TYPE_DAY_OF_WEEK THEN
				OPEN p_CURSOR FOR
					SELECT TEMP.DATE_DAY_NAME AS SCHEDULE_DATE,
					SUBSTR(TEMP.ROLLUP_DATE,12) AS SCHEDULE_TIME,
					MAX(TEMP.BASELINE_LOAD) BASELINE_LOAD,
					MAX(TEMP.METERED_LOAD) METERED_LOAD,
					MAX(TEMP.OBSERVED_REDUCTION) OBSERVED_REDUCTION,
					SUM(TEMP.FORECAST_CAPABILITY) FORECAST_CAPABILITY,
					SUM(TEMP.UNCONSTRAINED_VAL) UNCONSTRAINED_VAL,
					SUM(TEMP.REPORTED_REDUCTION) REPORTED_REDUCTION,
					SUM(TEMP.ESTIMATED_REDUCTION) ESTIMATED_REDUCTION
				FROM TABLE(CAST(v_RESULTS AS CAPACITY_REPORT_TEMP_TABLE)) TEMP
				GROUP BY TEMP.DATE_DAY_NAME,
						SUBSTR(TEMP.ROLLUP_DATE,12)
				ORDER BY 1,2;
		ELSIF p_SUMMARY_TYPE = SUMMARY_TYPE_TOU THEN
			OPEN p_CURSOR FOR
				SELECT DECODE(GROUPING(TEMP.ROLLUP_DATE),1,' ',TEMP.ROLLUP_DATE) AS SCHEDULE_DATE,
					DECODE(GROUPING(TEMP.IS_ON_PEAK),1,'Total',
								DECODE(GROUPING(TEMP.ROLLUP_DATE),1,
									DECODE(TEMP.IS_ON_PEAK,1, 'Total On-Peak','Total Off-Peak'),
										DECODE(TEMP.IS_ON_PEAK,0,'Off-Peak','On-Peak'))) TOU,
					MAX(TEMP.BASELINE_LOAD) BASELINE_LOAD,
					MAX(TEMP.METERED_LOAD) METERED_LOAD,
					MAX(TEMP.OBSERVED_REDUCTION) OBSERVED_REDUCTION,
					SUM(TEMP.FORECAST_CAPABILITY) FORECAST_CAPABILITY,
					SUM(TEMP.UNCONSTRAINED_VAL) UNCONSTRAINED_VAL,
					SUM(TEMP.REPORTED_REDUCTION) REPORTED_REDUCTION,
					SUM(TEMP.ESTIMATED_REDUCTION) ESTIMATED_REDUCTION
				FROM TABLE(CAST(v_RESULTS AS CAPACITY_REPORT_TEMP_TABLE)) TEMP
				GROUP BY GROUPING SETS ((TEMP.ROLLUP_DATE,
								TEMP.IS_ON_PEAK),
								(TEMP.IS_ON_PEAK),
								())
				ORDER BY GROUPING(TEMP.ROLLUP_DATE) DESC,1,2;
		ELSE
			OPEN p_CURSOR FOR
				SELECT
					DECODE(GROUPING(TEMP.ROLLUP_DATE),1,' ',TEMP.ROLLUP_DATE) AS SCHEDULE_DATE,
					DECODE(GROUPING(CASE WHEN TEMP.IS_CRIT_PEAK = 1 THEN 'Critical Peak'
								WHEN (TEMP.IS_CRIT_PEAK = 0 AND TEMP.IS_ON_PEAK = 1) THEN 'On-Peak Non-Critical'
								WHEN (TEMP.IS_CRIT_PEAK = 0 AND TEMP.IS_ON_PEAK = 0) THEN 'Off-Peak Non-Critical'
								END),1,'Total',
								DECODE(GROUPING(TEMP.ROLLUP_DATE),1,'Total ' ||
									CASE WHEN TEMP.IS_CRIT_PEAK = 1 THEN 'Critical Peak'
									WHEN (TEMP.IS_CRIT_PEAK = 0 AND TEMP.IS_ON_PEAK = 1) THEN 'On-Peak Non-Critical'
									WHEN (TEMP.IS_CRIT_PEAK = 0 AND TEMP.IS_ON_PEAK = 0) THEN 'Off-Peak Non-Critical'
									END,CASE WHEN TEMP.IS_CRIT_PEAK = 1 THEN 'Critical Peak'
								WHEN (TEMP.IS_CRIT_PEAK = 0 AND TEMP.IS_ON_PEAK = 1) THEN 'On-Peak Non-Critical'
								WHEN (TEMP.IS_CRIT_PEAK = 0 AND TEMP.IS_ON_PEAK = 0) THEN 'Off-Peak Non-Critical'
								END)) TOU,
					MAX(TEMP.BASELINE_LOAD) BASELINE_LOAD,
					MAX(TEMP.METERED_LOAD) METERED_LOAD,
					MAX(TEMP.OBSERVED_REDUCTION) OBSERVED_REDUCTION,
					SUM(TEMP.FORECAST_CAPABILITY) FORECAST_CAPABILITY,
					SUM(TEMP.UNCONSTRAINED_VAL) UNCONSTRAINED_VAL,
					SUM(TEMP.REPORTED_REDUCTION) REPORTED_REDUCTION,
					SUM(TEMP.ESTIMATED_REDUCTION) ESTIMATED_REDUCTION
				FROM TABLE(CAST(v_RESULTS AS CAPACITY_REPORT_TEMP_TABLE)) TEMP
				GROUP BY GROUPING SETS((TEMP.ROLLUP_DATE,
					CASE WHEN TEMP.IS_CRIT_PEAK = 1 THEN 'Critical Peak'
						WHEN (TEMP.IS_CRIT_PEAK = 0 AND TEMP.IS_ON_PEAK = 1) THEN 'On-Peak Non-Critical'
						WHEN (TEMP.IS_CRIT_PEAK = 0 AND TEMP.IS_ON_PEAK = 0) THEN 'Off-Peak Non-Critical'
					END), (CASE WHEN TEMP.IS_CRIT_PEAK = 1 THEN 'Critical Peak'
						WHEN (TEMP.IS_CRIT_PEAK = 0 AND TEMP.IS_ON_PEAK = 1) THEN 'On-Peak Non-Critical'
						WHEN (TEMP.IS_CRIT_PEAK = 0 AND TEMP.IS_ON_PEAK = 0) THEN 'Off-Peak Non-Critical'
					END),())

				ORDER BY 1,2;
		END IF;
	END IF;

END LOAD_REDUCTION_DETAILS;
-------------------------------------------------------------------------------------------
PROCEDURE LOAD_REDUCTION_SUMMARY
(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SUMMARY_TYPE IN VARCHAR2,
	p_ENTITY_DOMAIN_ID IN VARCHAR2,
	p_ENTITY_ID IN NUMBER_COLLECTION,
	p_INTERVAL IN VARCHAR2,
	p_SCENARIO_ID IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
) AS

v_CUT_BEGIN_DATE DATE;
v_CUT_END_DATE DATE;

v_INTERVAL_ABBR VARCHAR(16) := GET_INTERVAL_ABBREVIATION(p_INTERVAL);

v_RESULTS CAPACITY_REPORT_TEMP_TABLE := CAPACITY_REPORT_TEMP_TABLE();
v_P_SZ_IDS ID_SET_COLLECTION;
v_SCENARIO_ID NUMBER(1);

v_TEMP_IDs ID_TABLE;

v_SHOW_ALL NUMBER(1) := 1;

BEGIN
	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE,p_BEGIN_DATE,p_END_DATE);
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_CUT_BEGIN_DATE, v_CUT_END_DATE);

	IF p_SCENARIO_ID IS NULL THEN
		v_SCENARIO_ID := GA.BASE_SCENARIO_ID;
	ELSE
		v_SCENARIO_ID := p_SCENARIO_ID;
	END IF;

	-- Get all allowed PROGRAM Ids
	v_TEMP_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_SELECT_DER_RESULTS, EC.ED_PROGRAM);

	GET_PROGRAM_SERVICE_ZONE_SET(p_ENTITY_DOMAIN_ID,
								p_ENTITY_ID,
								v_P_SZ_IDS,
								v_TEMP_IDS);

	IF p_ENTITY_DOMAIN_ID = CONSTANTS.ALL_ID THEN
		v_SHOW_ALL := 0;
	END IF;

	SELECT CAPACITY_REPORT_TEMP_TYPE(
		    SDT.CUT_DATE,
			CASE v_INTERVAL_ABBR
				WHEN 'DD' THEN TRIM(SDT.DAY_YYYY_MM_DD)
				WHEN 'MM' THEN TRIM(SDT.MONTH_YYYY_MM_DD)
				WHEN 'MI30' THEN TRIM(SDT.MI30_YYYY_MM_DD)
				WHEN 'MI15' THEN TRIM(SDT.MI15_YYYY_MM_DD)
				ELSE TRIM(SDT.HOUR_YYYY_MM_DD)
			END,
			DATE_DAY_NAME(SDT.CUT_DATE,0),
			CASE WHEN p_ENTITY_DOMAIN_ID = EC.ED_PROGRAM OR p_ENTITY_DOMAIN_ID = CONSTANTS.ALL_ID THEN P.PROGRAM_ID
				WHEN p_ENTITY_DOMAIN_ID = EC.ED_SERVICE_ZONE THEN SZ.SERVICE_ZONE_ID
				ELSE VPP.VPP_ID
			END,
			CASE WHEN p_ENTITY_DOMAIN_ID = EC.ED_PROGRAM OR p_ENTITY_DOMAIN_ID = CONSTANTS.ALL_ID THEN P.PROGRAM_NAME
				WHEN p_ENTITY_DOMAIN_ID = EC.ED_SERVICE_ZONE THEN SZ.SERVICE_ZONE_NAME
				ELSE VPP.VPP_NAME
			END,
			DT.FORECAST_VALUE, -- FORECAST
			DT.UNCONSTRAINED_VALUE, -- UNCONSTRAINED
			DT.REPORTED_VALUE, -- REPORTED
			DT.ESTIMATED_VALUE, --ESTIMATED
			SDT.IS_ON_PEAK,
			CASE WHEN EXISTS
				(SELECT 1
					FROM DR_EVENT E
					WHERE P.PROGRAM_TYPE IN
						(DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_PK_TIME_REBATE, DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_CRIT_PRICING)
						AND E.VPP_ID = VPP.VPP_ID
						AND SDT.CUT_DATE > E.START_TIME
						AND SDT.CUT_DATE <= E.STOP_TIME) -- check iF the result date is in the time and vpp is correct
				THEN 1 ELSE 0
			END,
			-1,
			-1,
			-1
	)
	BULK COLLECT INTO v_RESULTS
	FROM -- We can't outer-join more than one table at a time, so we
			-- put all the queries for load values into a sub query.
			-- We query for all DER_VPP_RESULT regardless of Service Code
			-- and IS_EXTERNAL, and then use SUMs with Case statements to put them all into
			-- the correct inner query column
	( SELECT RST.PROGRAM_ID,
				RST.SERVICE_ZONE_ID,
				DATA.RESULT_DATE,
				SUM(CASE WHEN RST.IS_EXTERNAL = 0 AND RST.SERVICE_CODE = CONSTANTS.CODE_FORECAST THEN
					DATA.LOAD_VAL + DATA.OPT_OUT_VAL + DATA.OVERRIDE_VAL +
					DATA.FAILURE_VAL + DATA.TX_LOSS_VAL + DATA.DX_LOSS_VAL
				ELSE
					NULL
				END) AS FORECAST_VALUE,
				SUM(CASE WHEN RST.IS_EXTERNAL = 0 AND RST.SERVICE_CODE = CONSTANTS.CODE_FORECAST THEN
					DATA.UNCONSTRAINED_LOAD_VAL + NVL(DATA.UNCONSTRAINED_TX_LOSS_VAL,0) +
					NVL(DATA.UNCONSTRAINED_DX_LOSS_VAL,0)
				ELSE
					NULL
				END) AS UNCONSTRAINED_VALUE,
				SUM(CASE WHEN RST.IS_EXTERNAL = 0 AND RST.SERVICE_CODE = CONSTANTS.CODE_BACKCAST THEN
					DATA.LOAD_VAL + DATA.OPT_OUT_VAL + DATA.OVERRIDE_VAL + DATA.FAILURE_VAL +
						DATA.TX_LOSS_VAL + DATA.DX_LOSS_VAL
				ELSE
					NULL
				END)AS ESTIMATED_VALUE,
				SUM(CASE WHEN RST.IS_EXTERNAL = 1 AND RST.SERVICE_CODE = CONSTANTS.CODE_BACKCAST THEN
					DATA.LOAD_VAL + DATA.OPT_OUT_VAL + DATA.OVERRIDE_VAL + DATA.FAILURE_VAL +
						DATA.TX_LOSS_VAL + DATA.DX_LOSS_VAL
				ELSE
					NULL
				END) AS REPORTED_VALUE
			FROM DER_VPP_RESULT RST,
				TABLE(CAST(v_P_SZ_IDS AS ID_SET_COLLECTION)) v_IDs,
				DER_VPP_RESULT_DATA DATA
			WHERE RST.PROGRAM_ID = v_IDs.ID1
					AND RST.SERVICE_ZONE_ID = v_IDs.ID2
					AND RST.SCENARIO_ID = v_SCENARIO_ID
					AND DATA.DER_VPP_RESULT_ID = RST.DER_VPP_RESULT_ID
					AND DATA.RESULT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
			GROUP BY RST.PROGRAM_ID, RST.SERVICE_ZONE_ID, DATA.RESULT_DATE) DT,
				VIRTUAL_POWER_PLANT VPP,
				PROGRAM P,
				SERVICE_ZONE SZ,
				SYSTEM_DATE_TIME SDT,
				TABLE(CAST(v_P_SZ_IDS AS ID_SET_COLLECTION)) v_IDs
	WHERE SDT.TIME_ZONE = p_TIME_ZONE
				AND SDT.DATA_INTERVAL_TYPE = 1
				AND SDT.DAY_TYPE = '1'
				AND SDT.CUT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
				AND DT.RESULT_DATE (+) = SDT.CUT_DATE
				AND P.PROGRAM_ID = v_IDS.ID1
				AND SZ.SERVICE_ZONE_ID = v_IDS.ID2
				-- WE SHOW ALL SELECTED PROGRAMS / SERVICE ZONES, BUT IF THE USER SELECTED
				-- 'ALL' WE ONLY SHOW THOSE FOR WHICH WE HAVE DATA (v_SHOW_ALL = 0)
				AND ((P.PROGRAM_ID = DT.PROGRAM_ID AND SZ.SERVICE_ZONE_ID = DT.SERVICE_ZONE_ID)
						OR (DT.PROGRAM_ID IS NULL AND v_SHOW_ALL = 1))
				AND VPP.PROGRAM_ID (+) = v_IDS.ID1
				AND VPP.SERVICE_ZONE_ID (+) = v_IDS.ID2;

	IF p_SUMMARY_TYPE = SUMMARY_TYPE_ALL_DETAILS THEN
		OPEN p_CURSOR FOR
			SELECT SUBSTR(TEMP.ROLLUP_DATE,0,10)AS SCHEDULE_DATE,
				SUBSTR(TEMP.ROLLUP_DATE,12) AS SCHEDULE_TIME,
				TEMP.ENTITY_NAME ENTITY_NAME,
				SUM(TEMP.FORECAST_CAPABILITY) FORECAST_CAPABILITY,
				SUM(TEMP.UNCONSTRAINED_VAL) UNCONSTRAINED_VAL,
				SUM(TEMP.REPORTED_REDUCTION) REPORTED_REDUCTION,
				SUM(TEMP.ESTIMATED_REDUCTION) ESTIMATED_REDUCTION,
				MAX(TEMP.IS_CRIT_PEAK) IS_CRITICAL_PEAK
			FROM TABLE(CAST(v_RESULTS AS CAPACITY_REPORT_TEMP_TABLE)) TEMP
			GROUP BY SUBSTR(TEMP.ROLLUP_DATE,0,10),
					SUBSTR(TEMP.ROLLUP_DATE,12),
					TEMP.ENTITY_NAME
				ORDER BY 1,2;

	ELSIF p_SUMMARY_TYPE = SUMMARY_TYPE_DAY_OF_WEEK THEN
		OPEN p_CURSOR FOR
			SELECT TEMP.DATE_DAY_NAME AS SCHEDULE_DATE,
				SUBSTR(TEMP.ROLLUP_DATE,12) AS SCHEDULE_TIME,
				TEMP.ENTITY_NAME ENTITY_NAME,
				SUM(TEMP.FORECAST_CAPABILITY) FORECAST_CAPABILITY,
				SUM(TEMP.UNCONSTRAINED_VAL) UNCONSTRAINED_VAL,
				SUM(TEMP.REPORTED_REDUCTION) REPORTED_REDUCTION,
				SUM(TEMP.ESTIMATED_REDUCTION) ESTIMATED_REDUCTION
			FROM TABLE(CAST(v_RESULTS AS CAPACITY_REPORT_TEMP_TABLE)) TEMP
			GROUP BY TEMP.DATE_DAY_NAME,
					SUBSTR(TEMP.ROLLUP_DATE,12),
					TEMP.ENTITY_NAME
				ORDER BY 1,2;

	ELSIF p_SUMMARY_TYPE = SUMMARY_TYPE_TOU THEN
		OPEN p_CURSOR FOR
			SELECT DECODE(GROUPING(TEMP.ROLLUP_DATE),1,' ',TEMP.ROLLUP_DATE) AS SCHEDULE_DATE,
				DECODE(GROUPING(TEMP.IS_ON_PEAK),1,'Total',
							DECODE(GROUPING(TEMP.ROLLUP_DATE),1,
								DECODE(TEMP.IS_ON_PEAK,1, 'Total On-Peak','Total Off-Peak'),
									DECODE(TEMP.IS_ON_PEAK,0,'Off-Peak','On-Peak'))) TOU,
				TEMP.ENTITY_NAME ENTITY_NAME,
				SUM(TEMP.FORECAST_CAPABILITY) FORECAST_CAPABILITY,
				SUM(TEMP.UNCONSTRAINED_VAL) UNCONSTRAINED_VAL,
				SUM(TEMP.REPORTED_REDUCTION) REPORTED_REDUCTION,
				SUM(TEMP.ESTIMATED_REDUCTION) ESTIMATED_REDUCTION
			FROM TABLE(CAST(v_RESULTS AS CAPACITY_REPORT_TEMP_TABLE)) TEMP
			GROUP BY GROUPING SETS ((TEMP.ROLLUP_DATE,
							TEMP.IS_ON_PEAK,TEMP.ENTITY_NAME),
							(TEMP.IS_ON_PEAK,TEMP.ENTITY_NAME),
							(TEMP.ENTITY_NAME))
			ORDER BY GROUPING(TEMP.ROLLUP_DATE) DESC,1,2;
		ELSE
			OPEN p_CURSOR FOR
				SELECT DECODE(GROUPING(TEMP.ROLLUP_DATE),1,' ',TEMP.ROLLUP_DATE) AS SCHEDULE_DATE,
					DECODE(GROUPING(CASE WHEN TEMP.IS_CRIT_PEAK = 1 THEN 'Critical Peak'
								WHEN (TEMP.IS_CRIT_PEAK = 0 AND TEMP.IS_ON_PEAK = 1) THEN 'On-Peak Non-Critical'
								WHEN (TEMP.IS_CRIT_PEAK = 0 AND TEMP.IS_ON_PEAK = 0) THEN 'Off-Peak Non-Critical'
								END),1,'Total',
								DECODE(GROUPING(TEMP.ROLLUP_DATE),1,'Total ' ||
									CASE WHEN TEMP.IS_CRIT_PEAK = 1 THEN 'Critical Peak'
									WHEN (TEMP.IS_CRIT_PEAK = 0 AND TEMP.IS_ON_PEAK = 1) THEN 'On-Peak Non-Critical'
									WHEN (TEMP.IS_CRIT_PEAK = 0 AND TEMP.IS_ON_PEAK = 0) THEN 'Off-Peak Non-Critical'
									END,CASE WHEN TEMP.IS_CRIT_PEAK = 1 THEN 'Critical Peak'
								WHEN (TEMP.IS_CRIT_PEAK = 0 AND TEMP.IS_ON_PEAK = 1) THEN 'On-Peak Non-Critical'
								WHEN (TEMP.IS_CRIT_PEAK = 0 AND TEMP.IS_ON_PEAK = 0) THEN 'Off-Peak Non-Critical'
								END)) TOU,
					TEMP.ENTITY_NAME,
					SUM(TEMP.FORECAST_CAPABILITY) FORECAST_CAPABILITY,
					SUM(TEMP.UNCONSTRAINED_VAL) UNCONSTRAINED_VAL,
					SUM(TEMP.REPORTED_REDUCTION) REPORTED_REDUCTION,
					SUM(TEMP.ESTIMATED_REDUCTION) ESTIMATED_REDUCTION
				FROM TABLE(CAST(v_RESULTS AS CAPACITY_REPORT_TEMP_TABLE)) TEMP
				GROUP BY GROUPING SETS((TEMP.ROLLUP_DATE,
					CASE WHEN TEMP.IS_CRIT_PEAK = 1 THEN 'Critical Peak'
						WHEN (TEMP.IS_CRIT_PEAK = 0 AND TEMP.IS_ON_PEAK = 1) THEN 'On-Peak Non-Critical'
						WHEN (TEMP.IS_CRIT_PEAK = 0 AND TEMP.IS_ON_PEAK = 0) THEN 'Off-Peak Non-Critical'
					END,TEMP.ENTITY_NAME), (CASE WHEN TEMP.IS_CRIT_PEAK = 1 THEN 'Critical Peak'
						WHEN (TEMP.IS_CRIT_PEAK = 0 AND TEMP.IS_ON_PEAK = 1) THEN 'On-Peak Non-Critical'
						WHEN (TEMP.IS_CRIT_PEAK = 0 AND TEMP.IS_ON_PEAK = 0) THEN 'Off-Peak Non-Critical'
					END,TEMP.ENTITY_NAME),(TEMP.ENTITY_NAME))
				ORDER BY 1,2;
		END IF;

END LOAD_REDUCTION_SUMMARY;
--------------------------------------------------------------------------------
PROCEDURE LOAD_REDUCTION_BY_RESRC_TYPE
(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SUMMARY_TYPE IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_INTERVAL IN VARCHAR2,
	p_SCENARIO_ID IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
) AS

v_CUT_BEGIN_DATE DATE;
v_CUT_END_DATE DATE;

v_INTERVAL_ABBR VARCHAR(16) := GET_INTERVAL_ABBREVIATION(p_INTERVAL);

v_RESULTS CAPACITY_REPORT_TEMP_TABLE := CAPACITY_REPORT_TEMP_TABLE();
v_SCENARIO_ID NUMBER(1);

v_PROG_ID NUMBER(9) := CONSTANTS.ALL_ID;
v_SZ_ID NUMBER(9) := CONSTANTS.ALL_ID;
BEGIN

	IF p_ENTITY_DOMAIN_ID = EC.ED_VPP THEN
		SELECT MAX(VPP.SERVICE_ZONE_ID), MAX(VPP.PROGRAM_ID)
		INTO v_SZ_ID, v_PROG_ID
		FROM VIRTUAL_POWER_PLANT VPP
		WHERE VPP.VPP_ID = p_ENTITY_ID;

		IF v_SZ_ID IS NULL THEN
			ERRS.RAISE_BAD_ARGUMENT('VPP_ID', p_ENTITY_ID, 'A VPP corresponding to the given ID could not be found.');
		END IF;
	ELSIF p_ENTITY_DOMAIN_ID = EC.ED_PROGRAM THEN
		v_PROG_ID := p_ENTITY_ID;
	ELSIF p_ENTITY_DOMAIN_ID = EC.ED_SERVICE_ZONE THEN
		v_SZ_ID := p_ENTITY_ID;
	END IF;

	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE,p_BEGIN_DATE,p_END_DATE);
	SD.VERIFY_ACTION_IS_ALLOWED(SD.g_ACTION_SELECT_DER_RST_DET);
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_CUT_BEGIN_DATE, v_CUT_END_DATE);

	IF p_SCENARIO_ID IS NULL THEN
		v_SCENARIO_ID := GA.BASE_SCENARIO_ID;
	ELSE
		v_SCENARIO_ID := p_SCENARIO_ID;
	END IF;

	SELECT CAPACITY_REPORT_TEMP_TYPE(
				SDT.CUT_DATE,
				CASE v_INTERVAL_ABBR
					WHEN 'DD' THEN TRIM(SDT.DAY_YYYY_MM_DD)
					WHEN 'MM' THEN TRIM(SDT.MONTH_YYYY_MM_DD)
					WHEN 'MI30' THEN TRIM(SDT.MI30_YYYY_MM_DD)
					WHEN 'MI15' THEN TRIM(SDT.MI15_YYYY_MM_DD)
					ELSE TRIM(SDT.HOUR_YYYY_MM_DD)
				END,
				DATE_DAY_NAME(SDT.CUT_DATE,DETAIL.EDC_ID),
				DETAIL.DER_TYPE_ID,
				DETAIL.DER_TYPE_NAME,
				(DETAIL.F_DATA*CASE WHEN DETAIL.H_DATA <= 0 THEN 0 ELSE 1 END)/1000, -- FORECAST
				(DETAIL.F_DATA/1000), -- unconstrained val
				(DETAIL.R_DATA/1000), -- REPORTED reduction
				((DETAIL.E_DATA*CASE WHEN NVL(DETAIL.R_DATA,0) <= 0 THEN 0 ELSE 1 END)/1000),
				SDT.IS_ON_PEAK,
				0,
				-1,
				-1,
				-1
				)
			BULK COLLECT INTO v_RESULTS
			FROM -- We can't outer-join more than one table at a time, so we
			-- put all the queries for load values into a sub query.
			-- We query for all DER_DAILY_RESULT regardless of Service Code
			-- and IS_EXTERNAL, and then use SUMs with Case statements to put them all into
			-- the correct inner query column
			(SELECT DT.RESULT_DATE,
						DAILY.EDC_ID,
						DAILY.DER_TYPE_ID,
						DER_T.DER_TYPE_NAME,
						-- DX_LOSS and TX_LOSS will always match the result type (fcast, etc) of DT
						SUM(CASE WHEN DAILY.SERVICE_CODE = CONSTANTS.CODE_FORECAST AND
								DAILY.IS_EXTERNAL = 0 THEN
							DT.RESULT_VAL*(1+NVL(DX_LOSS.RESULT_VAL,0))*(1+NVL(TX_LOSS.RESULT_VAL,0))
								*DAILY.SCALE_FACTOR*(1-DAILY.FAILURE_RATE-DAILY.OPT_OUT_RATE-DAILY.OVERRIDE_RATE)
						ELSE
							NULL
						END) AS F_DATA,
						SUM(CASE WHEN DAILY.SERVICE_CODE = CONSTANTS.CODE_BACKCAST AND
								DAILY.IS_EXTERNAL = 0 THEN
							DT.RESULT_VAL*(1+NVL(DX_LOSS.RESULT_VAL,0))*(1+NVL(TX_LOSS.RESULT_VAL,0))
								*DAILY.SCALE_FACTOR*(1-DAILY.FAILURE_RATE-DAILY.OPT_OUT_RATE-DAILY.OVERRIDE_RATE)
						ELSE
							NULL
						END) AS E_DATA,
						SUM(CASE WHEN DAILY.SERVICE_CODE = CONSTANTS.CODE_BACKCAST AND
								DAILY.IS_EXTERNAL = 1 THEN
							DT.RESULT_VAL*(1+NVL(DX_LOSS.RESULT_VAL,0))*(1+NVL(TX_LOSS.RESULT_VAL,0))
								*DAILY.SCALE_FACTOR*(1-DAILY.FAILURE_RATE-DAILY.OPT_OUT_RATE-DAILY.OVERRIDE_RATE)
						ELSE
							NULL
						END) AS R_DATA,
						-- Hits only applies to forecast data
						SUM(CASE WHEN DAILY.SERVICE_CODE = CONSTANTS.CODE_FORECAST AND
								DAILY.IS_EXTERNAL = 0 THEN
							HITS.RESULT_VAL
						ELSE
							NULL
						END) AS H_DATA
					FROM DER_DAILY_RESULT DAILY,
						LOAD_RESULT_DATA DT,
						LOAD_RESULT_DATA HITS,
						LOAD_RESULT_DATA DX_LOSS,
						LOAD_RESULT_DATA TX_LOSS,
						DER_TYPE DER_T
					WHERE DAILY.SCENARIO_ID = v_SCENARIO_ID
						AND DAILY.RESULT_DAY BETWEEN p_BEGIN_DATE AND p_END_DATE
						AND (DAILY.PROGRAM_ID = v_PROG_ID OR v_PROG_ID = CONSTANTS.ALL_ID)
						AND (DAILY.SERVICE_ZONE_ID = v_SZ_ID OR v_SZ_ID = CONSTANTS.ALL_ID)
						AND DT.LOAD_RESULT_ID = DAILY.LOAD_SHAPE_RESULT_ID
						AND DT.RESULT_DATE BETWEEN DAILY.CUT_BEGIN_DATE AND DAILY.CUT_END_DATE
						AND HITS.LOAD_RESULT_ID (+) = DAILY.HITS_REMAINING_RESULT_ID
						AND HITS.RESULT_DATE (+) BETWEEN DAILY.CUT_BEGIN_DATE AND DAILY.CUT_END_DATE
						AND (DT.RESULT_DATE = HITS.RESULT_DATE OR HITS.LOAD_RESULT_ID IS NULL)

						AND DX_LOSS.LOAD_RESULT_ID (+) = DAILY.DX_LOSS_FACTOR_RESULT_ID
						AND DX_LOSS.RESULT_DATE (+) BETWEEN DAILY.CUT_BEGIN_DATE AND DAILY.CUT_END_DATE
						AND (DT.RESULT_DATE = DX_LOSS.RESULT_DATE OR DX_LOSS.LOAD_RESULT_ID IS NULL)

						AND TX_LOSS.LOAD_RESULT_ID (+) = DAILY.TX_LOSS_FACTOR_RESULT_ID
						AND TX_LOSS.RESULT_DATE (+) BETWEEN DAILY.CUT_BEGIN_DATE AND DAILY.CUT_END_DATE
						AND (DT.RESULT_DATE = TX_LOSS.RESULT_DATE OR TX_LOSS.LOAD_RESULT_ID IS NULL)

						AND DER_T.DER_TYPE_ID = DAILY.DER_TYPE_ID
					GROUP BY DT.RESULT_DATE, DAILY.EDC_ID,
						 DAILY.DER_TYPE_ID, DER_T.DER_TYPE_NAME) DETAIL,
					SYSTEM_DATE_TIME SDT
				WHERE SDT.TIME_ZONE = p_TIME_ZONE
					AND SDT.DATA_INTERVAL_TYPE = 1
					AND SDT.DAY_TYPE = '1'
					AND SDT.CUT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
					AND DETAIL.RESULT_DATE (+) = SDT.CUT_DATE;

		RESULT_SUMMARY(p_SUMMARY_TYPE,v_RESULTS,p_CURSOR);

END LOAD_REDUCTION_BY_RESRC_TYPE;
--------------------------------------------------------------------------------
PROCEDURE LOAD_REDUCTION_BY_SEGMENT
(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SUMMARY_TYPE IN VARCHAR2,
	p_PROGRAM_ID IN NUMBER,
	p_INTERVAL IN VARCHAR2,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_FEEDER_SEGMENT_ID IN NUMBER_COLLECTION,
	p_SCENARIO_ID IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
) AS

v_CUT_BEGIN_DATE DATE;
v_CUT_END_DATE DATE;

v_INTERVAL_ABBR VARCHAR(16) := GET_INTERVAL_ABBREVIATION(p_INTERVAL);

v_RESULTS CAPACITY_REPORT_TEMP_TABLE := CAPACITY_REPORT_TEMP_TABLE();
v_SCENARIO_ID NUMBER;
BEGIN

	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE,p_BEGIN_DATE,p_END_DATE);
	SD.VERIFY_ACTION_IS_ALLOWED(SD.g_ACTION_SELECT_DER_RST_DET);
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_CUT_BEGIN_DATE, v_CUT_END_DATE);

	IF p_SCENARIO_ID IS NULL THEN
		v_SCENARIO_ID := GA.BASE_SCENARIO_ID;
	ELSE
		v_SCENARIO_ID := p_SCENARIO_ID;
	END IF;

	SELECT CAPACITY_REPORT_TEMP_TYPE(
		SDT.CUT_DATE,
		CASE v_INTERVAL_ABBR
			WHEN 'DD' THEN TRIM(SDT.DAY_YYYY_MM_DD)
			WHEN 'MM' THEN TRIM(SDT.MONTH_YYYY_MM_DD)
			WHEN 'MI30' THEN TRIM(SDT.MI30_YYYY_MM_DD)
			WHEN 'MI15' THEN TRIM(SDT.MI15_YYYY_MM_DD)
			ELSE TRIM(SDT.HOUR_YYYY_MM_DD)
		END,
		DATE_DAY_NAME(SDT.CUT_DATE,0),
		NVL(DAILY.FEEDER_SEGMENT_ID, FCAST.FEEDER_SEGMENT_ID),
		NVL(DAILY.FEEDER_SEGMENT_NAME, FCAST.FEEDER_SEGMENT_NAME),
		FCAST.CAPACITY,
		FCAST.UNCONSTRAINED,
		DAILY.RESULTS_REP,
		DAILY.RESULTS_EST,
		SDT.IS_ON_PEAK,
		0,
		-1,
		-1,
		-1)
	BULK COLLECT INTO v_RESULTS
	FROM -- estimated and reported results can still come from one source result_id, so they can stay in
		-- this inner query, which gets all estimated and reported results and puts them into the right
		-- inner query column based on service code / is_external.
		(SELECT SR.FEEDER_SEGMENT_ID,
				 RESULTS.RESULT_DATE,
				 TFS.FEEDER_SEGMENT_NAME,
				SUM(CASE WHEN SR.SERVICE_CODE = CONSTANTS.CODE_BACKCAST AND SR.IS_EXTERNAL = 0 THEN
						RESULTS.LOAD_VAL+RESULTS.OPT_OUT_VAL+RESULTS.OVERRIDE_VAL
						+RESULTS.FAILURE_VAL+RESULTS.TX_LOSS_VAL+RESULTS.DX_LOSS_VAL
					ELSE NULL END) as RESULTS_EST,
				SUM(CASE WHEN SR.SERVICE_CODE = CONSTANTS.CODE_BACKCAST AND SR.IS_EXTERNAL = 1 THEN
						RESULTS.LOAD_VAL+RESULTS.OPT_OUT_VAL+RESULTS.OVERRIDE_VAL
						+RESULTS.FAILURE_VAL+RESULTS.TX_LOSS_VAL+RESULTS.DX_LOSS_VAL
					ELSE NULL END) as RESULTS_REP
		FROM DER_SEGMENT_RESULT SR,
			DER_SEGMENT_RESULT_DATA RESULTS,
			TABLE(CAST(p_FEEDER_SEGMENT_ID AS NUMBER_COLLECTION)) IDs,
			TX_FEEDER_SEGMENT TFS
		WHERE SR.FEEDER_SEGMENT_ID = IDs.COLUMN_VALUE
			AND SR.SERVICE_ZONE_ID = p_SERVICE_ZONE_ID
			AND TFS.FEEDER_SEGMENT_ID = SR.FEEDER_SEGMENT_ID
			AND (SR.PROGRAM_ID = p_PROGRAM_ID OR p_PROGRAM_ID = CONSTANTS.ALL_ID)
			AND SR.SERVICE_CODE = CONSTANTS.CODE_BACKCAST
			AND SR.SCENARIO_ID = v_SCENARIO_ID
			AND RESULTS.DER_SEGMENT_RESULT_ID = SR.DER_SEGMENT_RESULT_ID
			AND	RESULTS.RESULT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
		GROUP BY SR.FEEDER_SEGMENT_ID, TFS.FEEDER_SEGMENT_NAME, RESULTS.RESULT_DATE) DAILY,
		-- the internal / external forecast mix comes from its own view now, so that resides in a
		-- different query
		(SELECT MIX.FEEDER_SEGMENT_ID,
				TFS.FEEDER_SEGMENT_NAME,
				MIX.RESULT_DATE,
				SUM(MIX.LOAD_VAL+MIX.OPT_OUT_VAL+MIX.OVERRIDE_VAL
						+MIX.FAILURE_VAL+MIX.TX_LOSS_VAL+MIX.DX_LOSS_VAL) AS CAPACITY,
				SUM(MIX.UNCONSTRAINED_LOAD_VAL+NVL(MIX.UNCONSTRAINED_TX_LOSS_VAL,0)
						+NVL(MIX.UNCONSTRAINED_DX_LOSS_VAL,0)) AS UNCONSTRAINED
		FROM DER_SEGMENT_FORECAST_DATA MIX,
				TX_FEEDER_SEGMENT TFS,
			TABLE(CAST(p_FEEDER_SEGMENT_ID AS NUMBER_COLLECTION)) IDs
		WHERE MIX.FEEDER_SEGMENT_ID = IDs.COLUMN_VALUE
			AND MIX.SERVICE_ZONE_ID = p_SERVICE_ZONE_ID
			AND (MIX.PROGRAM_ID = p_PROGRAM_ID OR p_PROGRAM_ID = CONSTANTS.ALL_ID)
			AND MIX.SCENARIO_ID = v_SCENARIO_ID
			AND	MIX.RESULT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
			AND MIX.FEEDER_SEGMENT_ID = TFS.FEEDER_SEGMENT_ID
		GROUP BY MIX.FEEDER_SEGMENT_ID, MIX.RESULT_DATE, TFS.FEEDER_SEGMENT_NAME) FCAST,
		SYSTEM_DATE_TIME SDT
	WHERE SDT.TIME_ZONE = p_TIME_ZONE
		AND SDT.DATA_INTERVAL_TYPE = 1
		AND SDT.DAY_TYPE = '1'
		AND SDT.CUT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
		AND DAILY.RESULT_DATE(+) = SDT.CUT_DATE
		AND FCAST.RESULT_DATE(+) = SDT.CUT_DATE
		AND (FCAST.FEEDER_SEGMENT_ID = DAILY.FEEDER_SEGMENT_ID OR
			DAILY.FEEDER_SEGMENT_ID IS NULL OR
			FCAST.FEEDER_SEGMENT_ID IS NULL);

	RESULT_SUMMARY(p_SUMMARY_TYPE,v_RESULTS,p_CURSOR);

END LOAD_REDUCTION_BY_SEGMENT;
-------------------------------------------------------------------------------

PROCEDURE CALC_DOMAIN_ENTITIES
	(
	p_SEARCH_STRING IN VARCHAR2,
	p_SEARCH_OPTION IN VARCHAR2,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ENTITY_DOMAIN_NAME OUT VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	) AS

	v_STATUS NUMBER(9);

BEGIN

	IF p_ENTITY_DOMAIN_ID = CONSTANTS.ALL_ID THEN
		OPEN p_CURSOR FOR SELECT NULL FROM DUAL;
	ELSE
		p_ENTITY_DOMAIN_NAME := EI.GET_ENTITY_NAME(EC.ED_ENTITY_DOMAIN, p_ENTITY_DOMAIN_ID);

		GUI_UTIL.ENTITY_LIST(p_ENTITY_DOMAIN_ID, NVL(p_SEARCH_STRING, '%'), p_SEARCH_OPTION,
			CONSTANTS.SEARCH_TYPE_NORMAL, NULL, 1, 1, v_STATUS, p_CURSOR);
	END IF;

END CALC_DOMAIN_ENTITIES;
--------------------------------------------------------------------------------
PROCEDURE RUN_DER_FORECAST
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ENTITY_IDS IN NUMBER_COLLECTION,
	p_SERVICE_CODE IN VARCHAR2,
	p_DATE_RANGE_BEGIN IN DATE,
	p_DATE_RANGE_END IN DATE,
	p_PROCESS_ID OUT VARCHAR2,
	p_PROCESS_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR2,
	p_CALCULATE_FULL_SUMMARY IN NUMBER := 1,
	p_TRACE_ON IN NUMBER := 0
	) AS

BEGIN

	DER_CAPACITY_ENGINE.RUN_DER_FORECAST(p_ENTITY_DOMAIN_ID,
										p_ENTITY_IDS,
										SUBSTR(p_SERVICE_CODE,0,1),
										p_DATE_RANGE_BEGIN,
										p_DATE_RANGE_END,
										p_PROCESS_ID,
										p_PROCESS_STATUS,
										p_MESSAGE,
										p_CALCULATE_FULL_SUMMARY => p_CALCULATE_FULL_SUMMARY,
										p_TRACE_ON => p_TRACE_ON);

END RUN_DER_FORECAST;
--------------------------------------------------------------------------------
PROCEDURE RUN_DER_VPP_PEAK_DAY
	(
	p_VPP_ID IN NUMBER,
	p_DESIGN_DAY IN DATE,
	p_WEATHER_CASE_ID IN NUMBER,
	p_PROCESS_STATUS OUT NUMBER,
	p_PROCESS_ID OUT VARCHAR2,
	p_MESSAGE OUT VARCHAR2,
	p_TRACE_ON IN NUMBER := 0
	) AS

	v_SCENARIO_ID NUMBER(9);
	v_SCENARIO_NAME VARCHAR2(32);

	v_PROCESS_ID NUMBER;

	v_SZ_TIME_ZONE VARCHAR2(32);

	v_CUT_BEGIN DATE;
	v_CUT_END DATE;

BEGIN

	SELECT MAX(S.SCENARIO_ID)
	INTO v_SCENARIO_ID
	FROM SCENARIO S, LOAD_FORECAST_SCENARIO LFS
	WHERE S.SCENARIO_CATEGORY = CONSTANTS.SCENARIO_LOAD_FORECAST
		AND LFS.SCENARIO_ID = S.SCENARIO_ID
		AND LFS.WEATHER_CASE_ID = p_WEATHER_CASE_ID
		AND LFS.AREA_LOAD_CASE_ID = GA.BASE_CASE_ID
		AND LFS.ENROLLMENT_CASE_ID = GA.BASE_CASE_ID
		AND LFS.CALENDAR_CASE_ID = GA.BASE_CASE_ID
		AND LFS.USAGE_FACTOR_CASE_ID = GA.BASE_CASE_ID
		AND LFS.LOSS_FACTOR_CASE_ID = GA.BASE_CASE_ID
		AND LFS.GROWTH_FACTOR_CASE_ID = GA.BASE_CASE_ID;

	SELECT SZ.TIME_ZONE
	INTO v_SZ_TIME_ZONE
	FROM VIRTUAL_POWER_PLANT VPP, SERVICE_ZONE SZ
	WHERE VPP.VPP_ID = p_VPP_ID
		AND SZ.SERVICE_ZONE_ID = VPP.SERVICE_ZONE_ID;

	IF NVL(v_SZ_TIME_ZONE, CONSTANTS.UNDEFINED_ATTRIBUTE) = CONSTANTS.UNDEFINED_ATTRIBUTE THEN
		ERRS.RAISE_BAD_ARGUMENT('VPP', TEXT_UTIL.TO_CHAR_ENTITY(p_VPP_ID, EC.ED_VPP),
			'The given VPP''s service zone does not have a time zone.');
	END IF;

	IF v_SCENARIO_ID IS NULL THEN
		-- COULDN'T FIND THE SCENARIO WE NEEDED, CREATE IT
		v_SCENARIO_NAME := 'VPP Peak: ' || SUBSTR(EI.GET_ENTITY_NAME(EC.ED_CASE_LABEL, p_WEATHER_CASE_ID), 1, 22);

		v_SCENARIO_NAME := ENTITY_UTIL.RESOLVE_ENTITY_NAME_CONFLICT(v_SCENARIO_NAME,
																		EC.ED_SCENARIO);

		EM.PUT_SCENARIO(v_SCENARIO_ID,
						v_SCENARIO_NAME,
						v_SCENARIO_NAME,
						'Generated automatically by DEMAND_RESPONSE_UI.RUN_DER_VPP_PEAK_DAY',
						0,
						CONSTANTS.SCENARIO_LOAD_FORECAST,
						p_WEATHER_CASE_ID,
						GA.BASE_CASE_ID,
						GA.BASE_CASE_ID,
						GA.BASE_CASE_ID,
						GA.BASE_CASE_ID,
						GA.BASE_CASE_ID,
						GA.BASE_CASE_ID,
						0,
						NULL);

	END IF;

	DER_CAPACITY_ENGINE.RUN_DER_FORECAST(EC.ED_VPP,
										NUMBER_COLLECTION (p_VPP_ID),
										CONSTANTS.CODE_FORECAST,
										p_DESIGN_DAY,
										p_DESIGN_DAY,
										v_PROCESS_ID,
										p_PROCESS_STATUS,
										p_MESSAGE,
										0,
										v_SCENARIO_ID,
										p_TRACE_ON);

	p_PROCESS_ID := v_PROCESS_ID;

	IF p_PROCESS_STATUS < LOGS.c_LEVEL_FATAL THEN
		UT.CUT_DATE_RANGE(CONSTANTS.ELECTRIC_MODEL, p_DESIGN_DAY, p_DESIGN_DAY,
			v_SZ_TIME_ZONE, v_CUT_BEGIN, v_CUT_END);

		MERGE INTO VPP_PEAK_CAPACITY_DESIGN DSGN
		USING ( SELECT p_VPP_ID AS VPP_ID
				FROM DUAL ) VPP
		ON (VPP.VPP_ID = DSGN.VPP_ID)
		WHEN MATCHED THEN
			UPDATE SET DSGN.DESIGN_DAY = p_DESIGN_DAY,
					DSGN.SCENARIO_ID = v_SCENARIO_ID,
					DSGN.PROCESS_ID = v_PROCESS_ID,
					DSGN.CUT_BEGIN_DATE = v_CUT_BEGIN,
					DSGN.CUT_END_DATE = v_CUT_END
		WHEN NOT MATCHED THEN
			INSERT VALUES ( p_VPP_ID, p_DESIGN_DAY, v_CUT_BEGIN, v_CUT_END,
				v_SCENARIO_ID, v_PROCESS_ID);
	END IF;

END RUN_DER_VPP_PEAK_DAY;
--------------------------------------------------------------------------------
PROCEDURE LIST_WEATHER_CASES
	(
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
	SELECT L.CASE_ID, L.CASE_NAME
	FROM CASE_LABEL L
	WHERE UPPER(L.CASE_CATEGORY) IN ('WEATHER', 'ALL')
		AND L.CASE_ID <> CONSTANTS.NOT_ASSIGNED;

END LIST_WEATHER_CASES;
--------------------------------------------------------------------------------
PROCEDURE VPP_CAPACITY_RESULTS
	(
	p_VPP_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_FORECAST_DAY OUT VARCHAR2,
	p_WEATHER_CASE_NAME OUT VARCHAR2,
	p_LAST_RUN_WHEN OUT VARCHAR2,
	p_LAST_RUN_BY OUT VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	) AS

	v_SCENARIO_ID NUMBER := NULL;

	v_BEGIN DATE;
	v_END DATE;

	v_INTVL VARCHAR2(10) := GET_VPP_INTERVAL(p_VPP_ID);
	v_INTERVAL_NUM NUMBER(9) := get_interval_number(v_INTVL);

	v_RESULT_ID NUMBER(9);

BEGIN

	SELECT MAX(TEXT_UTIL.TO_CHAR_DATE(VD.DESIGN_DAY)),
		MAX(VD.CUT_BEGIN_DATE),
		MAX(VD.CUT_END_DATE),
		MAX(VD.SCENARIO_ID),
		MAX(CL.CASE_NAME),
		MAX(TEXT_UTIL.TO_CHAR_TIME(PL.PROCESS_STOP_TIME)),
		MAX(NVL(U.USER_DISPLAY_NAME, U.USER_NAME))
	INTO p_FORECAST_DAY, v_BEGIN, v_END, v_SCENARIO_ID, p_WEATHER_CASE_NAME,
		p_LAST_RUN_WHEN, p_LAST_RUN_BY
	FROM VPP_PEAK_CAPACITY_DESIGN VD,
		PROCESS_LOG PL,
		APPLICATION_USER U,
		LOAD_FORECAST_SCENARIO LF,
		CASE_LABEL CL
	WHERE VD.VPP_ID = p_VPP_ID
		AND PL.PROCESS_ID = VD.PROCESS_ID
		AND U.USER_ID = PL.USER_ID
		AND LF.SCENARIO_ID = VD.SCENARIO_ID
		AND CL.CASE_ID = LF.WEATHER_CASE_ID;

	IF v_SCENARIO_ID IS NOT NULL THEN

		v_RESULT_ID := GET_VPP_RESULT_ID(p_VPP_ID, CONSTANTS.CODE_FORECAST,
			0, v_SCENARIO_ID);

		SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, v_BEGIN, v_END);

		OPEN p_CURSOR FOR
		SELECT SUBSTR(FROM_CUT_AS_HED(SDT.CUT_DATE, p_TIME_ZONE, v_INTVL),1,10) SCHED_DATE,
			SUBSTR(FROM_CUT_AS_HED(SDT.CUT_DATE, p_TIME_ZONE, v_INTVL),11) SCHED_TIME,
			SDT.CUT_DATE,
			(DT.LOAD_VAL + DT.OPT_OUT_VAL + DT.FAILURE_VAL + DT.OVERRIDE_VAL
					+ DT.TX_LOSS_VAL + DT.DX_LOSS_VAL) AS PEAK_CAPABILITY
		FROM SYSTEM_DATE_TIME SDT, DER_VPP_RESULT_DATA DT
		WHERE SDT.TIME_ZONE = p_TIME_ZONE
			AND SDT.DATA_INTERVAL_TYPE = 1
			AND SDT.DAY_TYPE = '1'
			AND SDT.CUT_DATE BETWEEN v_BEGIN AND v_END
			AND SDT.MINIMUM_INTERVAL_NUMBER >= v_INTERVAL_NUM
			AND DT.DER_VPP_RESULT_ID (+) = v_RESULT_ID
			AND DT.RESULT_DATE (+) = SDT.CUT_DATE
		ORDER BY SDT.CUT_DATE;

	ELSE

		OPEN p_CURSOR FOR
		SELECT NULL
		FROM DUAL;

	END IF;

END VPP_CAPACITY_RESULTS;
--------------------------------------------------------------------------------
PROCEDURE VPP_SCHEDULES
	(
	p_VPP_IDs IN NUMBER_COLLECTION,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SCHEDULE_UNIT OUT VARCHAR2,
	p_CURSOR OUT DEMAND_RESPONSE.t_cur_VPP_SCHEDULE,
	p_SERVICE_CODE IN CHAR := 'F',
	p_IS_EXTERNAL IN NUMBER := 0
	) AS
v_CUT_BEGIN_DATE DATE;
v_CUT_END_DATE DATE;
BEGIN
	UT.CUT_DATE_RANGE(CONSTANTS.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE,
						v_CUT_BEGIN_DATE, v_CUT_END_DATE);
	DEMAND_RESPONSE.VPP_SCHEDULES(p_VPP_IDs, v_CUT_BEGIN_DATE, v_CUT_END_DATE, p_TIME_ZONE, p_SCHEDULE_UNIT, p_CURSOR, p_SERVICE_CODE, p_IS_EXTERNAL);
END VPP_SCHEDULES;
--------------------------------------------------------------------------------
PROCEDURE ACCEPT_VPPS_INTO_SCHEDULES
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SERVICE_CODE IN CHAR := 'F',
	p_IS_EXTERNAL IN NUMBER := 0,
	p_VPP_IDs IN NUMBER_COLLECTION := NUMBER_COLLECTION(-1)
	) AS
v_CUT_BEGIN_DATE DATE;
v_CUT_END_DATE DATE;
v_INCLUDE_ALL_VPPs NUMBER(1) := 0;
c_ENT_ATT_VPP_CAPABILITY_SCHED CONSTANT ENTITY_ATTRIBUTE.ATTRIBUTE_NAME%TYPE := 'Accepted VPP Capability Schedule';
c_ENT_ATT_VPP_RESULTS_SCHED CONSTANT ENTITY_ATTRIBUTE.ATTRIBUTE_NAME%TYPE := 'Accepted VPP Results Schedule';
v_DEL_BEGIN DATE;
v_DEL_END DATE;
BEGIN
	-- Check if the VPP_IDs collection includes 'All' VPPs
	SELECT CASE WHEN COUNT(1) > 0 THEN 1 ELSE 0 END INTO v_INCLUDE_ALL_VPPs
	FROM TABLE(CAST(p_VPP_IDs AS NUMBER_COLLECTION)) X
	WHERE X.COLUMN_VALUE = CONSTANTS.ALL_ID;

	UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_CUT_BEGIN_DATE, v_CUT_END_DATE);

	DEMAND_RESPONSE.CHECK_VPP_ALIASES(p_VPP_IDs, v_INCLUDE_ALL_VPPs);

	-- Delete schedule data during the specified data range for transactions
	-- that have a value of 'true' for an Entity Attribute name 'Accepted VPP Capability Schedule'
	-- when p_SERVICE_CODE = 'F' or 'Accepted VPP Results Schedule' otherwise
	IF v_INCLUDE_ALL_VPPs = 1 THEN
		FOR v_REC IN (SELECT T.OWNER_ENTITY_ID,
							GREATEST(p_BEGIN_DATE, T.BEGIN_DATE) AS BEGIN_DATE,
							LEAST(p_END_DATE, NVL(T.END_DATE, CONSTANTS.HIGH_DATE)) AS END_DATE
						FROM TEMPORAL_ENTITY_ATTRIBUTE T
						WHERE T.ENTITY_DOMAIN_ID = EC.ED_TRANSACTION
							AND T.ATTRIBUTE_NAME = CASE WHEN p_SERVICE_CODE = 'F' THEN c_ENT_ATT_VPP_CAPABILITY_SCHED ELSE c_ENT_ATT_VPP_RESULTS_SCHED END
							AND T.ATTRIBUTE_VAL = '1'
							AND T.BEGIN_DATE <= p_END_DATE
							AND NVL(T.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE) LOOP

			UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, v_REC.BEGIN_DATE, v_REC.END_DATE, p_TIME_ZONE, v_DEL_BEGIN, v_DEL_END);

			DELETE FROM IT_SCHEDULE S
			WHERE S.TRANSACTION_ID = v_REC.OWNER_ENTITY_ID
				AND S.SCHEDULE_DATE BETWEEN v_DEL_BEGIN AND v_DEL_END;

		END LOOP;
	END IF;

	DEMAND_RESPONSE.ACCEPT_VPPS_INTO_SCHEDULES(v_CUT_BEGIN_DATE,v_CUT_END_DATE,p_TIME_ZONE,p_SERVICE_CODE,p_IS_EXTERNAL,p_VPP_IDs);

END ACCEPT_VPPS_INTO_SCHEDULES;
--------------------------------------------------------------------------------
PROCEDURE SUBMIT_EVENT
	(
	p_EVENT_ID IN NUMBER,
	p_MESSAGE OUT VARCHAR2
	) AS

v_SUCCESS_COUNT BINARY_INTEGER;
v_FAIL_COUNT BINARY_INTEGER;

BEGIN

	DEMAND_RESPONSE.SUBMIT_EVENT(p_EVENT_ID, p_MESSAGE, v_SUCCESS_COUNT, v_FAIL_COUNT);

END SUBMIT_EVENT;
--------------------------------------------------------------------------------
PROCEDURE ACCOUNT_METERED_DATA
	(
	p_ACCOUNT_ID IN NUMBER_COLLECTION,
	p_SERVICE_LOCATION_ID IN NUMBER_COLLECTION,
	p_METER_ID IN NUMBER_COLLECTION,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_INTERVAL IN VARCHAR2,
	p_METER_CODE IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	) AS

	v_CUT_BEGIN DATE;
	v_CUT_END DATE;

	v_ACCT1 NUMBER(9);
	v_SL1 NUMBER(9);

	v_CODE CHAR(1) := SUBSTR(p_METER_CODE, 1, 1);

	v_INTVL_ABBR VARCHAR2(10) := NVL(GET_INTERVAL_ABBREVIATION(p_INTERVAL), 'HH');
	v_INTVL_NUM NUMBER(9) := GET_INTERVAL_NUMBER(p_INTERVAL);

BEGIN

	IF p_METER_ID IS NULL OR p_ACCOUNT_ID IS NULL OR p_SERVICE_LOCATION_ID IS NULL THEN
		-- NO METER SELECTED, JUST RETURN NULL
		OPEN p_CURSOR FOR SELECT NULL FROM DUAL;
		RETURN;
	END IF;

	v_ACCT1 := p_ACCOUNT_ID(1);
	v_SL1 := p_SERVICE_LOCATION_ID(1);

	FOR v_IDX IN 1..p_ACCOUNT_ID.COUNT LOOP
		IF v_ACCT1 <> p_ACCOUNT_ID(v_IDX) THEN
			ERRS.RAISE(MSGCODES.c_ERR_ARGUMENT, 'You may only select meters belonging to one service location / account');
		END IF;
	END LOOP;

	FOR v_IDX IN 1..p_SERVICE_LOCATION_ID.COUNT LOOP
		IF v_SL1 <> p_SERVICE_LOCATION_ID(v_IDX) THEN
			ERRS.RAISE(MSGCODES.c_ERR_ARGUMENT, 'You may only select meters belonging to one service location / account');
		END IF;
	END LOOP;

	UT.CUT_DATE_RANGE(CONSTANTS.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE,
		v_CUT_BEGIN, v_CUT_END);

	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, p_BEGIN_DATE, p_END_DATE);

	OPEN p_CURSOR FOR
	SELECT SUBSTR(CASE v_INTVL_ABBR
						WHEN 'DD' THEN TRIM(SDT.DAY_YYYY_MM_DD)
						WHEN 'HH' THEN TRIM(SDT.HOUR_YYYY_MM_DD)
						WHEN 'MM' THEN TRIM(SDT.MONTH_YYYY_MM_DD)
						WHEN 'MI30' THEN TRIM(SDT.MI30_YYYY_MM_DD)
						WHEN 'MI15' THEN TRIM(SDT.MI15_YYYY_MM_DD)
					END,1,10) SCHED_DATE,
		SUBSTR(CASE v_INTVL_ABBR
						WHEN 'DD' THEN TRIM(SDT.DAY_YYYY_MM_DD)
						WHEN 'HH' THEN TRIM(SDT.HOUR_YYYY_MM_DD)
						WHEN 'MM' THEN TRIM(SDT.MONTH_YYYY_MM_DD)
						WHEN 'MI30' THEN TRIM(SDT.MI30_YYYY_MM_DD)
						WHEN 'MI15' THEN TRIM(SDT.MI15_YYYY_MM_DD)
					END,11) SCHED_TIME,
		M.METER_NAME,
		PT.METER_POINT_NAME || ' (' || PT.UOM || ')' AS CHANNEL_NAME,
		PT.OPERATION_CODE AS OP_CODE,
		'B' AS SORT_COL,
		NULL AS NET_VAL,
		SUM(VAL.METER_VAL * (CASE WHEN PT.OPERATION_CODE = 'S' THEN -1 ELSE 1 END)) AS LOAD_VAL
	FROM METER M,
		TX_SUB_STATION_METER_POINT PT,
		TX_SUB_STATION_METER_PT_VALUE VAL,
		SYSTEM_DATE_TIME SDT,
		TABLE(CAST(p_METER_ID AS NUMBER_COLLECTION)) X
	WHERE M.METER_ID = X.COLUMN_VALUE
		AND PT.RETAIL_METER_ID = M.METER_ID
		AND GET_INTERVAL_NUMBER(PT.METER_POINT_INTERVAL ) <= v_INTVL_NUM
		AND PT.BEGIN_DATE <= p_END_DATE
		AND NVL(PT.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
		AND VAL.METER_POINT_ID = PT.METER_POINT_ID
		AND VAL.METER_DATE = SDT.CUT_DATE
		AND VAL.METER_CODE = v_CODE
		AND VAL.MEASUREMENT_SOURCE_ID = CONSTANTS.NOT_ASSIGNED
		AND SDT.TIME_ZONE = p_TIME_ZONE
		AND SDT.DATA_INTERVAL_TYPE = 1
		AND SDT.DAY_TYPE = '1'
		AND SDT.CUT_DATE BETWEEN v_CUT_BEGIN AND v_CUT_END
	GROUP BY (CASE v_INTVL_ABBR
			WHEN 'DD' THEN TRIM(SDT.DAY_YYYY_MM_DD)
			WHEN 'HH' THEN TRIM(SDT.HOUR_YYYY_MM_DD)
			WHEN 'MM' THEN TRIM(SDT.MONTH_YYYY_MM_DD)
			WHEN 'MI30' THEN TRIM(SDT.MI30_YYYY_MM_DD)
			WHEN 'MI15' THEN TRIM(SDT.MI15_YYYY_MM_DD)
		END), M.METER_NAME, PT.METER_POINT_NAME, PT.UOM, PT.OPERATION_CODE

	UNION ALL

		SELECT SUBSTR(CASE v_INTVL_ABBR
						WHEN 'DD' THEN TRIM(SDT.DAY_YYYY_MM_DD)
						WHEN 'HH' THEN TRIM(SDT.HOUR_YYYY_MM_DD)
						WHEN 'MM' THEN TRIM(SDT.MONTH_YYYY_MM_DD)
						WHEN 'MI30' THEN TRIM(SDT.MI30_YYYY_MM_DD)
						WHEN 'MI15' THEN TRIM(SDT.MI15_YYYY_MM_DD)
					END,1,10) SCHED_DATE,
		SUBSTR(CASE v_INTVL_ABBR
						WHEN 'DD' THEN TRIM(SDT.DAY_YYYY_MM_DD)
						WHEN 'HH' THEN TRIM(SDT.HOUR_YYYY_MM_DD)
						WHEN 'MM' THEN TRIM(SDT.MONTH_YYYY_MM_DD)
						WHEN 'MI30' THEN TRIM(SDT.MI30_YYYY_MM_DD)
						WHEN 'MI15' THEN TRIM(SDT.MI15_YYYY_MM_DD)
					END,11) SCHED_TIME,
		M.METER_NAME,
		NULL AS CHANNEL_NAME,
		NULL AS OP_CODE,
		'A' AS SORT_COL,
		SUM(SL.LOAD_VAL) AS NET_VAL,
		NULL AS LOAD_VAL
	FROM METER M,
		ACCOUNT_SERVICE ACCT_SERV,
		SERVICE S,
		SERVICE_LOAD SL,
		SYSTEM_DATE_TIME SDT,
		TABLE(CAST(p_METER_ID AS NUMBER_COLLECTION)) X
	WHERE M.METER_ID = X.COLUMN_VALUE
		AND ACCT_SERV.ACCOUNT_ID (+) = v_ACCT1
		AND ACCT_SERV.SERVICE_LOCATION_ID (+) = v_SL1
		AND ACCT_SERV.METER_ID (+) = X.COLUMN_VALUE
		AND S.ACCOUNT_SERVICE_ID (+) = ACCT_SERV.ACCOUNT_SERVICE_ID
		AND S.MODEL_ID (+) = CONSTANTS.ELECTRIC_MODEL
		AND S.SCENARIO_ID (+) = GA.BASE_SCENARIO_ID
		AND SL.SERVICE_ID (+) = S.SERVICE_ID
		AND (SL.LOAD_DATE = SDT.CUT_DATE OR SL.LOAD_DATE IS NULL)
		AND SL.SERVICE_CODE (+) = v_CODE
		AND SDT.TIME_ZONE = p_TIME_ZONE
		AND SDT.DATA_INTERVAL_TYPE = 1
		AND SDT.DAY_TYPE = '1'
		AND SDT.CUT_DATE BETWEEN v_CUT_BEGIN AND v_CUT_END
	GROUP BY (CASE v_INTVL_ABBR
			WHEN 'DD' THEN TRIM(SDT.DAY_YYYY_MM_DD)
			WHEN 'HH' THEN TRIM(SDT.HOUR_YYYY_MM_DD)
			WHEN 'MM' THEN TRIM(SDT.MONTH_YYYY_MM_DD)
			WHEN 'MI30' THEN TRIM(SDT.MI30_YYYY_MM_DD)
			WHEN 'MI15' THEN TRIM(SDT.MI15_YYYY_MM_DD)
		END), M.METER_NAME;

END ACCOUNT_METERED_DATA;
----------------------------------------------------------------------------
FUNCTION GET_ENTITY_SERVICE_LOCATIONS(p_ENTITY_DOMAIN_ID NUMBER, p_ENTITY_IDS number_collection)
RETURN ENTITY_SERVICE_LOCATION_TABLE PIPELINED IS
BEGIN

	IF p_ENTITY_DOMAIN_ID = EC.ED_PROGRAM THEN
		FOR cur_SERV_LOC IN
			(SELECT DISTINCT X.COLUMN_VALUE AS ENTITY_ID , -1 AS SERVICE_LOCATION_ID, P.PROGRAM_NAME
			 FROM TABLE(CAST(p_ENTITY_IDS AS NUMBER_COLLECTION)) X,
			 		PROGRAM P
				WHERE P.PROGRAM_ID = X.COLUMN_VALUE)
		LOOP
			-- WE NEED THE PROGRAM ID ONLY FOR PROGRAM AND VPP
			PIPE ROW(ENTITY_SERVICE_LOCATION(cur_SERV_LOC.ENTITY_ID,
							cur_SERV_LOC.PROGRAM_NAME,
							cur_SERV_LOC.ENTITY_ID,
							cur_SERV_LOC.SERVICE_LOCATION_ID));
		END LOOP;

	ELSIF p_ENTITY_DOMAIN_ID = EC.ED_VPP THEN

		FOR cur_SERV_LOC IN
			-- WE NEED THE PROGRAM ID ONLY FOR PROGRAM AND VPP
			(SELECT DISTINCT VPP.VPP_ID AS ENTITY_ID, SL.SERVICE_LOCATION_ID,
				VPP.PROGRAM_ID, VPP.VPP_NAME
			 FROM TABLE(CAST(p_ENTITY_IDS AS NUMBER_COLLECTION)) X,
			 	VIRTUAL_POWER_PLANT VPP,
				SERVICE_LOCATION SL
			WHERE VPP.VPP_ID = X.COLUMN_VALUE
				AND SL.SERVICE_ZONE_ID = VPP.SERVICE_ZONE_ID)
		LOOP
			PIPE ROW(ENTITY_SERVICE_LOCATION(cur_SERV_LOC.ENTITY_ID,
							cur_SERV_LOC.VPP_NAME,
							cur_SERV_LOC.PROGRAM_ID,
							cur_SERV_LOC.SERVICE_LOCATION_ID));
		END LOOP;

	ELSIF p_ENTITY_DOMAIN_ID = EC.ED_SERVICE_ZONE THEN
		FOR cur_SERV_LOC IN
			(SELECT DISTINCT X.COLUMN_VALUE AS ENTITY_ID , SL.SERVICE_LOCATION_ID, SZ.SERVICE_ZONE_NAME
			 FROM SERVICE_LOCATION SL, TABLE(CAST(p_ENTITY_IDS AS NUMBER_COLLECTION)) X,
			 	SERVICE_ZONE SZ
				WHERE X.COLUMN_VALUE = SL.SERVICE_ZONE_ID
					AND SZ.SERVICE_ZONE_ID = X.COLUMN_VALUE)
		LOOP
			PIPE ROW(ENTITY_SERVICE_LOCATION(cur_SERV_LOC.ENTITY_ID,
							cur_SERV_LOC.SERVICE_ZONE_NAME,
							CONSTANTS.ALL_ID,
							cur_SERV_LOC.SERVICE_LOCATION_ID));
		END LOOP;
	ELSIF p_ENTITY_DOMAIN_ID = EC.ED_SUB_STATION THEN
		FOR cur_SERV_LOC IN
			(SELECT DISTINCT X.COLUMN_VALUE AS ENTITY_ID, SL.SERVICE_LOCATION_ID,
				SS.SUB_STATION_NAME
			 FROM SERVICE_LOCATION SL, TABLE(CAST(p_ENTITY_IDS AS NUMBER_COLLECTION)) X,
			 	TX_SUB_STATION SS
				WHERE X.COLUMN_VALUE = SL.SUB_STATION_ID
					AND SS.SUB_STATION_ID = X.COLUMN_VALUE)
		LOOP
			PIPE ROW(ENTITY_SERVICE_LOCATION(cur_SERV_LOC.ENTITY_ID,
							cur_SERV_LOC.SUB_STATION_NAME,
							CONSTANTS.ALL_ID,
							cur_SERV_LOC.SERVICE_LOCATION_ID));
		END LOOP;
	ELSIF p_ENTITY_DOMAIN_ID = EC.ED_TX_FEEDER THEN
		FOR cur_SERV_LOC IN
			(SELECT DISTINCT X.COLUMN_VALUE AS ENTITY_ID, SL.SERVICE_LOCATION_ID,
				F.FEEDER_NAME
			 FROM SERVICE_LOCATION SL, TABLE(CAST(p_ENTITY_IDS AS NUMBER_COLLECTION)) X,
			 	TX_FEEDER F
				WHERE X.COLUMN_VALUE = SL.FEEDER_ID
					AND F.FEEDER_ID = SL.FEEDER_ID)
		LOOP
			PIPE ROW(ENTITY_SERVICE_LOCATION(cur_SERV_LOC.ENTITY_ID,
							cur_SERV_LOC.FEEDER_NAME,
							CONSTANTS.ALL_ID,
							cur_SERV_LOC.SERVICE_LOCATION_ID));
		END LOOP;
	ELSIF p_ENTITY_DOMAIN_ID = EC.ED_TX_FEEDER_SEGMENT THEN
		FOR cur_SERV_LOC IN
			(SELECT DISTINCT X.COLUMN_VALUE AS ENTITY_ID, SL.SERVICE_LOCATION_ID, FS.FEEDER_SEGMENT_NAME
			 FROM SERVICE_LOCATION SL, TABLE(CAST(p_ENTITY_IDS AS NUMBER_COLLECTION)) X,
			 	TX_FEEDER_SEGMENT FS
				WHERE X.COLUMN_VALUE = SL.FEEDER_SEGMENT_ID
					AND FS.FEEDER_SEGMENT_ID = SL.FEEDER_SEGMENT_ID)
		LOOP
			PIPE ROW(ENTITY_SERVICE_LOCATION(cur_SERV_LOC.ENTITY_ID,
						cur_SERV_LOC.FEEDER_SEGMENT_NAME,
						CONSTANTS.ALL_ID,
						cur_SERV_LOC.SERVICE_LOCATION_ID));
		END LOOP;
	END IF;

  RETURN;
END GET_ENTITY_SERVICE_LOCATIONS;
----------------------------------------------------------------------------
PROCEDURE ECONOMIC_IMPACT_BY_ACCOUNT
	(
	p_ACCOUNT_ID	IN NUMBER,
	p_SERVICE_CODE	IN VARCHAR2,
	p_IS_EXTERNAL	IN NUMBER,
	p_BEGIN_DATE	IN DATE,
	p_END_DATE		IN DATE,
	p_TIME_ZONE		IN VARCHAR2,
	p_INTERVAL		IN VARCHAR2,
	p_CURSOR		OUT GA.REFCURSOR
	) AS
v_CUT_BEGIN_DATE DATE;
v_CUT_END_DATE DATE;
BEGIN
	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE,p_BEGIN_DATE,p_END_DATE);
	UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_CUT_BEGIN_DATE, v_CUT_END_DATE);

	OPEN p_CURSOR FOR
		SELECT CASE p_INTERVAL
				WHEN '15 Minute' THEN TRIM(SDT.MI15_YYYY_MM_DD)
				WHEN '30 Minute' THEN TRIM(SDT.MI30_YYYY_MM_DD)
				WHEN 'Day' THEN TRIM(SDT.DAY_YYYY_MM_DD)
				WHEN 'Hour' THEN TRIM(SDT.HOUR_YYYY_MM_DD)
				WHEN 'Month' THEN TRIM(SDT.MONTH_YYYY_MM_DD)
				WHEN 'Event' THEN NULL
			END AS LOAD_DATE,
			CASE WHEN p_INTERVAL = 'Event' THEN E.EVENT_NAME ELSE NULL END EVENT_NAME,
			CASE WHEN p_INTERVAL = 'Event' THEN FROM_CUT_AS_HED(E.START_TIME, p_TIME_ZONE, 'MI5') ELSE NULL END EVENT_START_TIME,
			CASE WHEN p_INTERVAL = 'Event' THEN FROM_CUT_AS_HED(E.STOP_TIME, p_TIME_ZONE, 'MI5') ELSE NULL END EVENT_STOP_TIME,
			E.PROGRAM_NAME,
			E.PROGRAM_ID,
			E.AMOUNT_TYPE,
			NVL(DER.DER_NAME, '-') AS RESOURCE_NAME,
			DER.DER_ID AS RESOURCE_ID,
			SUM(E.AMOUNT) AS AMOUNT
		FROM SYSTEM_DATE_TIME SDT,
			DISTRIBUTED_ENERGY_RESOURCE DER,
			----------------------------------------------------------------------------------------
			-- Account Benefits By Account is obtained from the Program Billing Determinant tables
			----------------------------------------------------------------------------------------
			(SELECT CASE WHEN NVL(BD.HAS_SUB_DAILY_DETAILS,0) = 0
					THEN TO_CUT(DATE_UTIL.GET_START_DATE(BDD.DETERMINANT_DATE, DATE_UTIL.c_ABBR_15MIN), p_TIME_ZONE)
					ELSE BDD.DETERMINANT_DATE END AS RESULT_DATE,
				P.PROGRAM_NAME,
				BS.PROGRAM_ID,
				'Account Benefits' AS AMOUNT_TYPE,
				BDD.DER_ID AS RESOURCE_ID,
				NVL(BDD.BILL_AMOUNT,0) AS AMOUNT,
				BDD.EVENT_ID,
				EVNT.EVENT_NAME,
				EVNT.START_TIME,
				EVNT.STOP_TIME
			FROM PROGRAM_BILL_RESULT BR,
				PROGRAM_BILL_SUMMARY BS,
				PROGRAM_BILL_DETERMINANT_DTL BDD,
				PROGRAM_BILL_DETERMINANT BD,
				DR_EVENT EVNT,
				PROGRAM P
			WHERE -- Billing Result
				BR.ACCOUNT_ID = p_ACCOUNT_ID
				-- Billing Summary
				AND BS.BILL_SUMMARY_ID = BR.BILL_SUMMARY_ID
				AND BS.BEGIN_DATE <= v_CUT_END_DATE
				AND NVL(BS.END_DATE, CONSTANTS.HIGH_DATE) >= v_CUT_BEGIN_DATE
				-- Billing Determinant Data
				AND BD.BILL_RESULT_ID = BR.BILL_RESULT_ID
				AND BDD.BILL_DETERMINANT_ID = BD.BILL_DETERMINANT_ID
				AND BDD.DETERMINANT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
				AND BD.BILL_DETERMINANT_ID = BDD.BILL_DETERMINANT_ID
				AND EVNT.EVENT_ID(+) = BDD.EVENT_ID
				-- Program
				AND P.PROGRAM_ID = BS.PROGRAM_ID
			UNION ALL
			----------------------------------------------------------------------------------------
			-- Avoided Cost by Account for Peak Time Rebate is obtained from the Service Load Table
			----------------------------------------------------------------------------------------
			-- Previously, we were out-joining to DR_EVENT and DR_EVENT_SCHEDULE, but since there
			-- is no reduction to be considered outside of an event this is now unnecessary
			SELECT LOAD.LOAD_DATE AS RESULT_DATE,
					SLP.PROGRAM_NAME,
					SLP.PROGRAM_ID,
					'Avoided Costs' AS AMOUNT_TYPE,
					NULL AS RESOURCE_ID,
					((BASE_VAL - MTR_VAL)/1000) * NVL(ES.PRICE, 0) AS AMOUNT,
					E.EVENT_ID,
					E.EVENT_NAME,
					E.START_TIME,
					E.STOP_TIME
				FROM -- Get the Distinct Service Location and Program
					 -- for the given dates and the account
					(SELECT DISTINCT S1.SERVICE_LOCATION_ID, S1.PROGRAM_ID, P.PROGRAM_NAME,
						SL.SERVICE_ZONE_ID
					  FROM SERVICE_LOCATION_PROGRAM S1,
						ACCOUNT_SERVICE_LOCATION ASL,
						SERVICE_LOCATION SL,
						PROGRAM P
					  WHERE ASL.ACCOUNT_ID = p_ACCOUNT_ID
						AND ASL.BEGIN_DATE <= p_END_DATE
						AND NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
						AND S1.SERVICE_LOCATION_ID = ASL.SERVICE_LOCATION_ID
						AND SL.SERVICE_LOCATION_ID = S1.SERVICE_LOCATION_ID
						AND S1.BEGIN_DATE <= p_END_DATE
						AND NVL(S1.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
						AND P.PROGRAM_ID = S1.PROGRAM_ID
						AND P.PROGRAM_TYPE = DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_PK_TIME_REBATE) SLP,
					(SELECT ACCT_SVC.SERVICE_LOCATION_ID, LD.LOAD_DATE,
							SUM( CASE WHEN LD.SERVICE_CODE = CONSTANTS.CODE_FORECAST THEN
									NVL(LD.LOAD_VAL,0) + NVL(LD.TX_LOSS_VAL,0) + NVL(LD.DX_LOSS_VAL,0) + NVL(LD.UE_LOSS_VAL,0)
								ELSE
									NULL END) AS BASE_VAL,
							SUM( CASE WHEN LD.SERVICE_CODE = CONSTANTS.CODE_ACTUAL THEN
									NVL(LD.LOAD_VAL,0) + NVL(LD.TX_LOSS_VAL,0) + NVL(LD.DX_LOSS_VAL,0) + NVL(LD.UE_LOSS_VAL,0)
								ELSE
									NULL END) AS MTR_VAL
						FROM SERVICE SVC, ACCOUNT_SERVICE ACCT_SVC, SERVICE_LOAD LD
						WHERE ACCT_SVC.ACCOUNT_ID = p_ACCOUNT_ID
							AND SVC.SCENARIO_ID = GA.BASE_SCENARIO_ID
							AND SVC.ACCOUNT_SERVICE_ID = ACCT_SVC.ACCOUNT_SERVICE_ID
							AND LD.SERVICE_ID = SVC.SERVICE_ID
							AND (LD.SERVICE_CODE = CONSTANTS.CODE_FORECAST
									OR LD.SERVICE_CODE = CONSTANTS.CODE_ACTUAL)
							AND LD.LOAD_CODE = '1'
						GROUP BY ACCT_SVC.SERVICE_LOCATION_ID, LD.LOAD_DATE) LOAD,
					DR_EVENT_PROG_SZ E,
					DR_EVENT_SCHEDULE ES
				WHERE LOAD.SERVICE_LOCATION_ID = SLP.SERVICE_LOCATION_ID
					-- EVENT / VPP
					AND E.PROGRAM_ID = SLP.PROGRAM_ID
					AND E.SERVICE_ZONE_ID = SLP.SERVICE_ZONE_ID
					AND ES.EVENT_ID = E.EVENT_ID
					AND ES.SCHEDULE_DATE = LOAD.LOAD_DATE
					AND ES.SCHEDULE_DATE > E.START_TIME
					AND ES.SCHEDULE_DATE <= E.STOP_TIME
			UNION ALL
			---------------------------------------------------------------------------------
			-- Avoided Cost by Account for DLC program is obtained from the DER Daily Result
			---------------------------------------------------------------------------------
			SELECT DDR.RESULT_DATE,
				DDR.PROGRAM_NAME,
				DDR.PROGRAM_ID,
				'Avoided Costs' AS AMOUNT_TYPE,
				DDR.RESOURCE_ID,
				SUM(NVL(ES.PRICE,0) * (DDR.RESULT_VAL*(1+NVL(TX_LOSS.RESULT_VAL,0))*(1+NVL(DX_LOSS.RESULT_VAL,0))
					* DDR.SCALE_FACTOR*(1- DDR.FAILURE_RATE- DDR.OPT_OUT_RATE- DDR.OVERRIDE_RATE)
					 * CASE WHEN HITS.RESULT_VAL <= 0 THEN 0 ELSE 1 END)/1000) AS AMOUNT,
				DDR.EVENT_ID,
				DDR.EVENT_NAME,
				DDR.START_TIME,
				DDR.STOP_TIME
			FROM (SELECT LOAD.RESULT_DATE,
					P.PROGRAM_NAME,
					P.PROGRAM_ID,
					R.DER_ID AS RESOURCE_ID,
					LOAD.RESULT_VAL,
					R.SCALE_FACTOR,
					R.FAILURE_RATE,
					R.OPT_OUT_RATE,
					R.OVERRIDE_RATE,
					R.TX_LOSS_FACTOR_RESULT_ID,
					R.DX_LOSS_FACTOR_RESULT_ID,
					R.HITS_REMAINING_RESULT_ID,
					E.EVENT_ID,
					E.EVENT_NAME,
					E.START_TIME,
					E.STOP_TIME
				FROM DER_DAILY_RESULT R,
					LOAD_RESULT_DATA LOAD,
					PROGRAM P,
					DR_EVENT_PROG_SZ E
				WHERE -- DER Daily Result
					R.ACCOUNT_ID = p_ACCOUNT_ID
					AND R.IS_EXTERNAL = p_IS_EXTERNAL
					AND R.SERVICE_CODE = p_SERVICE_CODE
					AND R.SCENARIO_ID = GA.BASE_SCENARIO_ID
					AND R.CUT_BEGIN_DATE <= v_CUT_END_DATE
					AND R.CUT_END_DATE >= v_CUT_BEGIN_DATE
					-- Unscaled Load Result
					AND LOAD.LOAD_RESULT_ID = R.LOAD_SHAPE_RESULT_ID
					AND LOAD.RESULT_DATE BETWEEN R.CUT_BEGIN_DATE AND R.CUT_END_DATE
					-- Program
					AND P.PROGRAM_ID = R.PROGRAM_ID
					AND P.PROGRAM_TYPE = DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_DLC
					-- Event
					AND E.PROGRAM_ID (+) = R.PROGRAM_ID
					AND E.SERVICE_ZONE_ID (+) = R.SERVICE_ZONE_ID) DDR,
				DR_EVENT_SCHEDULE ES,
				LOAD_RESULT_DATA TX_LOSS,
				LOAD_RESULT_DATA DX_LOSS,
				LOAD_RESULT_DATA HITS
			WHERE -- Event Schedule
				ES.EVENT_ID(+) = DDR.EVENT_ID
				AND ES.SCHEDULE_DATE(+) = DDR.RESULT_DATE
				AND ES.SCHEDULE_DATE(+) > DDR.START_TIME
				AND ES.SCHEDULE_DATE(+) <= DDR.STOP_TIME
				-- TX Losses
				AND TX_LOSS.LOAD_RESULT_ID(+) = DDR.TX_LOSS_FACTOR_RESULT_ID
				AND TX_LOSS.RESULT_DATE(+) = DDR.RESULT_DATE
				-- DX Losses
				AND DX_LOSS.LOAD_RESULT_ID(+) = DDR.DX_LOSS_FACTOR_RESULT_ID
				AND DX_LOSS.RESULT_DATE(+) = DDR.RESULT_DATE
				-- Hits
				AND HITS.LOAD_RESULT_ID(+) = DDR.HITS_REMAINING_RESULT_ID
				AND HITS.RESULT_DATE(+) = DDR.RESULT_DATE
			GROUP BY DDR.RESULT_DATE,
				DDR.PROGRAM_NAME,
				DDR.PROGRAM_ID,
				DDR.RESOURCE_ID,
				DDR.EVENT_ID,
				DDR.EVENT_NAME,
				DDR.START_TIME,
				DDR.STOP_TIME,
				ES.PRICE) E
		WHERE SDT.TIME_ZONE = p_TIME_ZONE
			AND SDT.DATA_INTERVAL_TYPE = 1
			AND SDT.DAY_TYPE = '1'
			AND SDT.CUT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
			AND E.RESULT_DATE(+) = SDT.CUT_DATE
			AND (p_INTERVAL <> 'Event' OR E.EVENT_ID IS NOT NULL)
			AND DER.DER_ID(+) = E.RESOURCE_ID
		GROUP BY
			CASE p_INTERVAL
				WHEN '15 Minute' THEN TRIM(SDT.MI15_YYYY_MM_DD)
				WHEN '30 Minute' THEN TRIM(SDT.MI30_YYYY_MM_DD)
				WHEN 'Day' THEN TRIM(SDT.DAY_YYYY_MM_DD)
				WHEN 'Hour' THEN TRIM(SDT.HOUR_YYYY_MM_DD)
				WHEN 'Month' THEN TRIM(SDT.MONTH_YYYY_MM_DD)
				WHEN 'Event' THEN NULL END,
			CASE WHEN p_INTERVAL = 'Event' THEN E.EVENT_NAME ELSE NULL END,
			CASE WHEN p_INTERVAL = 'Event' THEN FROM_CUT_AS_HED(E.START_TIME, p_TIME_ZONE, 'MI5') ELSE NULL END,
			CASE WHEN p_INTERVAL = 'Event' THEN FROM_CUT_AS_HED(E.STOP_TIME, p_TIME_ZONE, 'MI5') ELSE NULL END,
			E.PROGRAM_NAME,
			E.PROGRAM_ID,
			AMOUNT_TYPE,
			DER.DER_NAME,
			DER.DER_ID
		ORDER BY LOAD_DATE,
			PROGRAM_NAME,
			AMOUNT_TYPE,
			RESOURCE_NAME;
END ECONOMIC_IMPACT_BY_ACCOUNT;
----------------------------------------------------------------------------
PROCEDURE ECONOMIC_IMPACT_SUMMARY
	(
	p_ENTITY_DOMAIN_ID			IN NUMBER,
	p_ECO_ENV_IMPACT_ENTITY_IDS	IN NUMBER_COLLECTION,
	p_SERVICE_CODE				IN VARCHAR2,
	p_IS_EXTERNAL				IN NUMBER,
	p_BEGIN_DATE				IN DATE,
	p_END_DATE					IN DATE,
	p_TIME_ZONE					IN VARCHAR2,
	p_INTERVAL					IN VARCHAR2,
	p_CURSOR					OUT GA.REFCURSOR
	) AS
v_CUT_BEGIN_DATE DATE;
v_CUT_END_DATE DATE;

v_P_SZ_IDS ID_SET_COLLECTION;

BEGIN

	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE,p_BEGIN_DATE,p_END_DATE);
	UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_CUT_BEGIN_DATE, v_CUT_END_DATE);


	IF p_ENTITY_DOMAIN_ID IN (EC.ED_VPP, EC.ED_PROGRAM, EC.ED_SERVICE_ZONE) THEN

		-- CONVERT TO A PROGRAM / SERVICE_ZONE PAIR COLLECTION
		GET_PROGRAM_SERVICE_ZONE_SET(p_ENTITY_DOMAIN_ID,
								p_ECO_ENV_IMPACT_ENTITY_IDS,
								v_P_SZ_IDS);

		--------------------------------------------------------------------------
		-- VPP, Programs and Service Zone
		---------------------------------------------------------------------------
		OPEN p_CURSOR FOR
			SELECT CASE p_INTERVAL
					WHEN '15 Minute' THEN TRIM(SDT.MI15_YYYY_MM_DD)
					WHEN '30 Minute' THEN TRIM(SDT.MI30_YYYY_MM_DD)
					WHEN 'Day' THEN TRIM(SDT.DAY_YYYY_MM_DD)
					WHEN 'Hour' THEN TRIM(SDT.HOUR_YYYY_MM_DD)
					WHEN 'Month' THEN TRIM(SDT.MONTH_YYYY_MM_DD)
					WHEN 'Event' THEN NULL
				END AS LOAD_DATE,
				CASE WHEN p_INTERVAL = 'Event' THEN E.EVENT_NAME ELSE NULL END EVENT_NAME,
				CASE WHEN p_INTERVAL = 'Event' THEN FROM_CUT_AS_HED(E.START_TIME, p_TIME_ZONE, 'MI5') ELSE NULL END EVENT_START_TIME,
				CASE WHEN p_INTERVAL = 'Event' THEN FROM_CUT_AS_HED(E.STOP_TIME, p_TIME_ZONE, 'MI5') ELSE NULL END EVENT_STOP_TIME,
				E.ENTITY_NAME,
				E.ENTITY_ID,
				E.AMOUNT_TYPE,
				SUM(E.AMOUNT) AS AMOUNT
			FROM SYSTEM_DATE_TIME SDT,
				------------------------------------------------------------------------------------
				-- Direct Expenses Summary is obtained from the Program Billing Determinant tables.
				-- We use the GET_ENTITY_SERVICE_LOCATIONS function to get list of Service Locations
				-- for the selected Entity Domain and Entity Domain Ids
				------------------------------------------------------------------------------------
				(SELECT CASE WHEN NVL(BD.HAS_SUB_DAILY_DETAILS,0) = 0
							THEN TO_CUT(DATE_UTIL.GET_START_DATE(BDD.DETERMINANT_DATE, DATE_UTIL.c_ABBR_15MIN/*GET_INTERVAL_ABBREVIATION(v_INTERVAL)*/), p_TIME_ZONE)
							ELSE BDD.DETERMINANT_DATE END AS RESULT_DATE,
					BDD.EVENT_ID,
					SL.ENTITY_NAME,
					SL.ENTITY_ID,
					'Direct Expenses' AS AMOUNT_TYPE,
					NVL(BDD.BILL_AMOUNT,0) AS AMOUNT,
					E.EVENT_NAME,
					E.START_TIME,
					E.STOP_TIME
				FROM TABLE(GET_ENTITY_SERVICE_LOCATIONS(p_ENTITY_DOMAIN_ID, p_ECO_ENV_IMPACT_ENTITY_IDS)) SL,
					PROGRAM_BILL_RESULT BR,
					PROGRAM_BILL_SUMMARY BS,
					PROGRAM_BILL_DETERMINANT_DTL BDD,
					PROGRAM_BILL_DETERMINANT BD,
					PROGRAM P,
					DR_EVENT_PROG_SZ E
				WHERE -- Billing Result
					(BR.SERVICE_LOCATION_ID = SL.SERVICE_LOCATION_ID OR CONSTANTS.ALL_ID = SL.SERVICE_LOCATION_ID)
					-- Billing Summary
					-- ENTITY_ID = PROGRAM_ID FOR ENTITY_DOMAIN = VPP OR PROGRAM, OTHERWISE ALL PROGRAMS
					AND (BS.PROGRAM_ID = SL.PROGRAM_ID OR SL.PROGRAM_ID = CONSTANTS.ALL_ID)
					AND BS.BILL_SUMMARY_ID = BR.BILL_SUMMARY_ID
					AND BS.BEGIN_DATE <= v_CUT_END_DATE
					AND NVL(BS.END_DATE, CONSTANTS.HIGH_DATE) >= v_CUT_BEGIN_DATE
					-- Billing Determinant Data
					AND BD.BILL_RESULT_ID = BR.BILL_RESULT_ID
					AND BDD.BILL_DETERMINANT_ID = BD.BILL_DETERMINANT_ID
					AND BDD.DETERMINANT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
					AND BD.BILL_DETERMINANT_ID = BDD.BILL_DETERMINANT_ID
					-- Program
					AND P.PROGRAM_ID = BS.PROGRAM_ID
					-- Event
					AND E.EVENT_ID(+) = BDD.EVENT_ID

				----------------------------------------------------------------------------------------------
				-- Avoided Cost for Peak Time Rebate program Summary is obtained from the Service Load tables.
				-- We use the GET_ENTITY_SERVICE_LOCATIONS function to get list of Service Locations
				-- for the selected Entity Domain and Entity Domain Ids
				----------------------------------------------------------------------------------------------
				UNION ALL
				SELECT LOAD.LOAD_DATE AS RESULT_DATE,
					LOAD.EVENT_ID,
					LOAD.ENTITY_NAME,
					LOAD.ENTITY_ID,
					'Avoided Costs' AS AMOUNT_TYPE,
					(BASE_VAL - MTR_VAL)/1000 * NVL(ES.PRICE,0) AS AMOUNT,
					LOAD.EVENT_NAME,
					LOAD.START_TIME,
					LOAD.STOP_TIME
				FROM (SELECT S.ENTITY_ID, S.ENTITY_NAME, S.VPP_ID, E.EVENT_ID, E.EVENT_NAME, E.START_TIME, E.STOP_TIME, LD.LOAD_DATE,
						SUM( CASE WHEN LD.SERVICE_CODE = CONSTANTS.CODE_FORECAST THEN
								NVL(LD.LOAD_VAL,0) + NVL(LD.TX_LOSS_VAL,0) + NVL(LD.DX_LOSS_VAL,0) + NVL(LD.UE_LOSS_VAL,0)
							ELSE
								NULL END) AS BASE_VAL,
						SUM( CASE WHEN LD.SERVICE_CODE = CONSTANTS.CODE_ACTUAL THEN
								NVL(LD.LOAD_VAL,0) + NVL(LD.TX_LOSS_VAL,0) + NVL(LD.DX_LOSS_VAL,0) + NVL(LD.UE_LOSS_VAL,0)
							ELSE
								NULL END) AS MTR_VAL
					FROM (SELECT DISTINCT ESL.ENTITY_ID, ESL.ENTITY_NAME, SP.SERVICE_LOCATION_ID, SP.PROGRAM_ID, P.PROGRAM_NAME, VPP.VPP_ID
						FROM  TABLE(DEMAND_RESPONSE_UI.GET_ENTITY_SERVICE_LOCATIONS(p_ENTITY_DOMAIN_ID, p_ECO_ENV_IMPACT_ENTITY_IDS)) ESL,
							ACCOUNT_SERVICE_LOCATION ASL,
							SERVICE_LOCATION_PROGRAM SP,
							SERVICE_LOCATION SL,
							PROGRAM P,
							VPP
						WHERE -- Account Service Location
							(ASL.SERVICE_LOCATION_ID = ESL.SERVICE_LOCATION_ID OR -1 = ESL.SERVICE_LOCATION_ID)
							AND ASL.BEGIN_DATE <= p_END_DATE
							AND NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
							AND SL.SERVICE_LOCATION_ID = ASL.SERVICE_LOCATION_ID
							-- Service Program
							AND SP.SERVICE_LOCATION_ID = ASL.SERVICE_LOCATION_ID
							AND SP.BEGIN_DATE <= p_END_DATE
							AND NVL(SP.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
							AND P.PROGRAM_ID = SP.PROGRAM_ID
							AND (SP.PROGRAM_ID = ESL.PROGRAM_ID OR ESL.PROGRAM_ID = CONSTANTS.ALL_ID)
							AND P.PROGRAM_TYPE = DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_PK_TIME_REBATE
							-- VPP
							AND (VPP.PROGRAM_ID = ESL.PROGRAM_ID OR ESL.PROGRAM_ID = CONSTANTS.ALL_ID)
							AND VPP.SERVICE_ZONE_ID = SL.SERVICE_ZONE_ID
							AND (p_ENTITY_DOMAIN_ID <> EC.ED_VPP OR VPP.VPP_ID = ESL.ENTITY_ID)
							AND (p_ENTITY_DOMAIN_ID <> EC.ED_SERVICE_ZONE OR VPP.SERVICE_ZONE_ID = ESL.ENTITY_ID)) S,
						ACCOUNT_SERVICE ACCT_SVC,
						SERVICE SVC,
						SERVICE_LOAD LD,
						-- Event
						DR_EVENT E
					WHERE ACCT_SVC.SERVICE_LOCATION_ID = S.SERVICE_LOCATION_ID
						AND SVC.SCENARIO_ID = GA.BASE_SCENARIO_ID
						AND SVC.ACCOUNT_SERVICE_ID = ACCT_SVC.ACCOUNT_SERVICE_ID
						AND LD.SERVICE_ID = SVC.SERVICE_ID
						AND (LD.SERVICE_CODE = CONSTANTS.CODE_FORECAST
								OR LD.SERVICE_CODE = CONSTANTS.CODE_ACTUAL)
						AND LD.LOAD_CODE = '1'
						AND E.VPP_ID (+) = S.VPP_ID
					GROUP BY S.ENTITY_ID, S.ENTITY_NAME, S.VPP_ID, E.EVENT_ID, E.EVENT_NAME, E.START_TIME, E.STOP_TIME, LD.LOAD_DATE) LOAD,
					DR_EVENT_SCHEDULE ES
				WHERE ES.EVENT_ID(+) = LOAD.EVENT_ID
					AND ES.SCHEDULE_DATE(+) = LOAD.LOAD_DATE
					AND ES.SCHEDULE_DATE(+) > NVL(LOAD.START_TIME, CONSTANTS.LOW_DATE)
					AND ES.SCHEDULE_DATE(+) <= NVL(LOAD.STOP_TIME, CONSTANTS.HIGH_DATE)
				UNION ALL
				----------------------------------------------------------------------------------------------
				-- Avoided Cost Summary for DLC program is obtained from the DER VPP Result table
				----------------------------------------------------------------------------------------------
				SELECT R.RESULT_DATE,
					R.EVENT_ID,
					R.ENTITY_NAME,
					R.ENTITY_ID,
					'Avoided Costs' AS AMOUNT_TYPE,
					R.REDUCTION * NVL(ES.PRICE,0) AS AMOUNT,
					R.EVENT_NAME,
					R.START_TIME,
					R.STOP_TIME
				FROM (SELECT VRD.RESULT_DATE,
						CASE p_ENTITY_DOMAIN_ID
							WHEN EC.ED_PROGRAM THEN VRD.PROGRAM_ID
							WHEN EC.ED_VPP THEN VPP.VPP_ID
							ELSE VRD.SERVICE_ZONE_ID END AS ENTITY_ID,
						CASE p_ENTITY_DOMAIN_ID
							WHEN EC.ED_PROGRAM THEN P.PROGRAM_NAME
							WHEN EC.ED_VPP THEN VPP.VPP_NAME
							ELSE SZ.SERVICE_ZONE_NAME END AS ENTITY_NAME,
						VRD.REDUCTION,
						E.EVENT_ID,
						E.EVENT_NAME,
						E.START_TIME,
						E.STOP_TIME
					FROM
						(SELECT R.PROGRAM_ID, R.SERVICE_ZONE_ID,
								D.RESULT_DATE,
								(NVL(D.LOAD_VAL,0) + NVL(D.FAILURE_VAL,0) + NVL(D.OPT_OUT_VAL,0) + NVL(D.OVERRIDE_VAL,0) + NVL(D.TX_LOSS_VAL,0) + D.DX_LOSS_VAL) AS REDUCTION
							FROM DER_VPP_RESULT R,
								DER_VPP_RESULT_DATA D,
								TABLE(CAST(v_P_SZ_IDS AS ID_SET_COLLECTION)) X
							WHERE R.SERVICE_ZONE_ID = X.ID2
								AND R.PROGRAM_ID = X.ID1
								AND R.IS_EXTERNAL = p_IS_EXTERNAL
								AND R.SERVICE_CODE = p_SERVICE_CODE
								AND R.SCENARIO_ID = GA.BASE_SCENARIO_ID
								-- DER VPP Result Data
								AND D.DER_VPP_RESULT_ID = R.DER_VPP_RESULT_ID
								AND D.RESULT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE) VRD,
						PROGRAM P,
						SERVICE_ZONE SZ,
						DR_EVENT_PROG_SZ E,
						VIRTUAL_POWER_PLANT VPP
					WHERE -- Event
						E.PROGRAM_ID (+) = VRD.PROGRAM_ID
						AND E.SERVICE_ZONE_ID (+) = VRD.SERVICE_ZONE_ID
						AND NVL(E.START_TIME (+), CONSTANTS.LOW_DATE) < VRD.RESULT_DATE
						AND NVL(E.STOP_TIME (+), CONSTANTS.HIGH_DATE) >= VRD.RESULT_DATE
						-- Program
						AND P.PROGRAM_ID = VRD.PROGRAM_ID
						AND P.PROGRAM_TYPE = DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_DLC
						-- VPP (FOR ENTITY_ID)
						AND VPP.PROGRAM_ID (+) = VRD.PROGRAM_ID
						AND VPP.SERVICE_ZONE_ID (+) = VRD.SERVICE_ZONE_ID
						-- Service Zone (for name)
						AND SZ.SERVICE_ZONE_ID = VRD.SERVICE_ZONE_ID) R,
					DR_EVENT_SCHEDULE ES
				WHERE ES.EVENT_ID(+) = R.EVENT_ID
					AND ES.SCHEDULE_DATE(+) = R.RESULT_DATE) E
			WHERE SDT.TIME_ZONE = p_TIME_ZONE
				AND SDT.DATA_INTERVAL_TYPE = 1
				AND SDT.DAY_TYPE = '1'
				AND SDT.CUT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
				AND E.RESULT_DATE(+) = SDT.CUT_DATE
				AND (p_INTERVAL <> 'Event' OR E.EVENT_ID IS NOT NULL)
			GROUP BY
				CASE p_INTERVAL
					WHEN '15 Minute' THEN TRIM(SDT.MI15_YYYY_MM_DD)
					WHEN '30 Minute' THEN TRIM(SDT.MI30_YYYY_MM_DD)
					WHEN 'Day' THEN TRIM(SDT.DAY_YYYY_MM_DD)
					WHEN 'Hour' THEN TRIM(SDT.HOUR_YYYY_MM_DD)
					WHEN 'Month' THEN TRIM(SDT.MONTH_YYYY_MM_DD)
					WHEN 'Event' THEN NULL
				END,
				CASE WHEN p_INTERVAL = 'Event' THEN E.EVENT_NAME ELSE NULL END,
				CASE WHEN p_INTERVAL = 'Event' THEN FROM_CUT_AS_HED(E.START_TIME, p_TIME_ZONE, 'MI5') ELSE NULL END,
				CASE WHEN p_INTERVAL = 'Event' THEN FROM_CUT_AS_HED(E.STOP_TIME, p_TIME_ZONE, 'MI5') ELSE NULL END,
				E.ENTITY_NAME,
				E.ENTITY_ID,
				E.AMOUNT_TYPE
			ORDER BY LOAD_DATE,
				CASE WHEN p_INTERVAL = 'Event' THEN E.EVENT_NAME ELSE NULL END,
				CASE WHEN p_INTERVAL = 'Event' THEN FROM_CUT_AS_HED(E.START_TIME, p_TIME_ZONE, 'MI5') ELSE NULL END,
				CASE WHEN p_INTERVAL = 'Event' THEN FROM_CUT_AS_HED(E.STOP_TIME, p_TIME_ZONE, 'MI5') ELSE NULL END,
				ENTITY_NAME,
				AMOUNT_TYPE;
	ELSE
		-----------------------------------------
		-- SubStation, Feeder and Feeder Segment
		-----------------------------------------
		OPEN p_CURSOR FOR
			SELECT CASE p_INTERVAL
					WHEN '15 Minute' THEN TRIM(SDT.MI15_YYYY_MM_DD)
					WHEN '30 Minute' THEN TRIM(SDT.MI30_YYYY_MM_DD)
					WHEN 'Day' THEN TRIM(SDT.DAY_YYYY_MM_DD)
					WHEN 'Hour' THEN TRIM(SDT.HOUR_YYYY_MM_DD)
					WHEN 'Month' THEN TRIM(SDT.MONTH_YYYY_MM_DD)
					WHEN 'Event' THEN NULL
				END AS LOAD_DATE,
				CASE WHEN p_INTERVAL = 'Event' THEN E.EVENT_NAME ELSE NULL END EVENT_NAME,
				CASE WHEN p_INTERVAL = 'Event' THEN FROM_CUT_AS_HED(E.START_TIME, p_TIME_ZONE, 'MI5') ELSE NULL END EVENT_START_TIME,
				CASE WHEN p_INTERVAL = 'Event' THEN FROM_CUT_AS_HED(E.STOP_TIME, p_TIME_ZONE, 'MI5') ELSE NULL END EVENT_STOP_TIME,
				E.ENTITY_NAME,
				E.ENTITY_ID,
				E.AMOUNT_TYPE,
				NVL(SUM(E.AMOUNT),0) AS AMOUNT
			FROM SYSTEM_DATE_TIME SDT,
				------------------------------------------------------------------------------------
				-- Direct Expenses Summary is obtained from the Program Billing Determinant tables.
				-- We use the GET_ENTITY_SERVICE_LOCATIONS function to get list of Service Locations
				-- for the selected Entity Domain and Entity Domain Ids
				------------------------------------------------------------------------------------
				(SELECT CASE WHEN NVL(BD.HAS_SUB_DAILY_DETAILS,0) = 0
							THEN TO_CUT(DATE_UTIL.GET_START_DATE(BDD.DETERMINANT_DATE, DATE_UTIL.c_ABBR_15MIN/*GET_INTERVAL_ABBREVIATION(v_INTERVAL)*/), p_TIME_ZONE)
							ELSE BDD.DETERMINANT_DATE END AS RESULT_DATE,
					BDD.EVENT_ID,
					SL.ENTITY_NAME,
					SL.ENTITY_ID AS ENTITY_ID,
					'Direct Expenses' AS AMOUNT_TYPE,
					NVL(BDD.BILL_AMOUNT,0) AS AMOUNT,
					E.EVENT_NAME,
					E.START_TIME,
					E.STOP_TIME
				FROM TABLE(GET_ENTITY_SERVICE_LOCATIONS(p_ENTITY_DOMAIN_ID, p_ECO_ENV_IMPACT_ENTITY_IDS)) SL,
					PROGRAM_BILL_RESULT BR,
					PROGRAM_BILL_SUMMARY BS,
					PROGRAM_BILL_DETERMINANT_DTL BDD,
					PROGRAM_BILL_DETERMINANT BD,
					PROGRAM P,
					DR_EVENT E
				WHERE -- Billing Result
					(BR.SERVICE_LOCATION_ID = SL.SERVICE_LOCATION_ID OR CONSTANTS.ALL_ID = SL.SERVICE_LOCATION_ID)
					-- Billing Summary
					AND BS.BILL_SUMMARY_ID = BR.BILL_SUMMARY_ID
					AND BS.BEGIN_DATE <= v_CUT_END_DATE
					AND NVL(BS.END_DATE, CONSTANTS.HIGH_DATE) >= v_CUT_BEGIN_DATE
					-- Billing Determinant Data
					AND BD.BILL_RESULT_ID = BR.BILL_RESULT_ID
					AND BDD.BILL_DETERMINANT_ID = BD.BILL_DETERMINANT_ID
					AND BDD.DETERMINANT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
					AND BD.BILL_DETERMINANT_ID = BDD.BILL_DETERMINANT_ID
					-- Program
					AND P.PROGRAM_ID = BS.PROGRAM_ID
					-- Event
					AND E.EVENT_ID(+) = BDD.EVENT_ID
				----------------------------------------------------------------------------------------------
				-- Avoided Cost for Peak Time Rebate program Summary is obtained from the Service Load tables.
				-- We use the GET_ENTITY_SERVICE_LOCATIONS function to get list of Service Locations
				-- for the selected Entity Domain and Entity Domain Ids
				----------------------------------------------------------------------------------------------
				UNION ALL
				SELECT LOAD.LOAD_DATE AS RESULT_DATE,
					LOAD.EVENT_ID,
					LOAD.ENTITY_NAME,
					LOAD.ENTITY_ID,
					'Avoided Costs' AS AMOUNT_TYPE,
					(BASE_VAL - MTR_VAL)/1000 * NVL(ES.PRICE,0) AS AMOUNT,
					LOAD.EVENT_NAME,
					LOAD.START_TIME,
					LOAD.STOP_TIME
				FROM (SELECT S.ENTITY_ID, S.ENTITY_NAME, S.VPP_ID, E.EVENT_ID, E.EVENT_NAME, E.START_TIME, E.STOP_TIME, LD.LOAD_DATE,
						SUM( CASE WHEN LD.SERVICE_CODE = CONSTANTS.CODE_FORECAST THEN
								NVL(LD.LOAD_VAL,0) + NVL(LD.TX_LOSS_VAL,0) + NVL(LD.DX_LOSS_VAL,0) + NVL(LD.UE_LOSS_VAL,0)
							ELSE
								NULL END) AS BASE_VAL,
						SUM( CASE WHEN LD.SERVICE_CODE = CONSTANTS.CODE_ACTUAL THEN
								NVL(LD.LOAD_VAL,0) + NVL(LD.TX_LOSS_VAL,0) + NVL(LD.DX_LOSS_VAL,0) + NVL(LD.UE_LOSS_VAL,0)
							ELSE
								NULL END) AS MTR_VAL
					FROM (SELECT DISTINCT ESL.ENTITY_ID, ESL.ENTITY_NAME, SP.SERVICE_LOCATION_ID, SP.PROGRAM_ID, P.PROGRAM_NAME, VPP.VPP_ID
						FROM  TABLE(DEMAND_RESPONSE_UI.GET_ENTITY_SERVICE_LOCATIONS(p_ENTITY_DOMAIN_ID, p_ECO_ENV_IMPACT_ENTITY_IDS)) ESL,
							ACCOUNT_SERVICE_LOCATION ASL,
							SERVICE_LOCATION_PROGRAM SP,
							PROGRAM P,
							VPP
						WHERE -- Account Service Location
							(ASL.SERVICE_LOCATION_ID = ESL.SERVICE_LOCATION_ID OR -1 = ESL.SERVICE_LOCATION_ID)
							AND ASL.BEGIN_DATE <= p_END_DATE
							AND NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
							-- Service Program
							AND SP.SERVICE_LOCATION_ID = ASL.SERVICE_LOCATION_ID
							AND SP.BEGIN_DATE <= p_END_DATE
							AND NVL(SP.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
							AND P.PROGRAM_ID = SP.PROGRAM_ID
							AND P.PROGRAM_TYPE = DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_PK_TIME_REBATE
							-- VPP
							AND VPP.PROGRAM_ID = P.PROGRAM_ID) S,
						ACCOUNT_SERVICE ACCT_SVC,
						SERVICE SVC,
						SERVICE_LOAD LD,
						-- Event
						DR_EVENT E
					WHERE ACCT_SVC.SERVICE_LOCATION_ID = S.SERVICE_LOCATION_ID
						AND SVC.SCENARIO_ID = GA.BASE_SCENARIO_ID
						AND SVC.ACCOUNT_SERVICE_ID = ACCT_SVC.ACCOUNT_SERVICE_ID
						AND LD.SERVICE_ID = SVC.SERVICE_ID
						AND (LD.SERVICE_CODE = CONSTANTS.CODE_FORECAST
								OR LD.SERVICE_CODE = CONSTANTS.CODE_ACTUAL)
						AND LD.LOAD_CODE = '1'
						AND E.VPP_ID (+) = S.VPP_ID
					GROUP BY S.ENTITY_ID, S.ENTITY_NAME, S.VPP_ID, E.EVENT_ID, E.EVENT_NAME, E.START_TIME, E.STOP_TIME, LD.LOAD_DATE) LOAD,
					DR_EVENT_SCHEDULE ES
				WHERE ES.EVENT_ID(+) = LOAD.EVENT_ID
					AND ES.SCHEDULE_DATE(+) = LOAD.LOAD_DATE
					AND ES.SCHEDULE_DATE(+) > LOAD.START_TIME
					AND ES.SCHEDULE_DATE(+) <= LOAD.STOP_TIME
				UNION ALL
				----------------------------------------------------------------------------------------------
				-- Avoided Cost Summary for DLC program is obtained from the DER Segment Result table
				-- We use the GET_ENTITY_FEEDER_SEGMENTS function to get list of Feeder Segments
				-- for the selected Entity Domain and Entity Domain Ids
				----------------------------------------------------------------------------------------------
				SELECT R.RESULT_DATE,
					R.EVENT_ID,
					R.ENTITY_NAME,
					R.ENTITY_ID,
					'Avoided Costs' AS AMOUNT_TYPE,
					R.REDUCTION * NVL(ES.PRICE,0) AS AMOUNT,
					R.EVENT_NAME,
					R.START_TIME,
					R.STOP_TIME
				FROM (SELECT SRD.RESULT_DATE,
						SRD.ENTITY_NAME,
						SRD.ENTITY_ID,
						SRD.REDUCTION,
						E.EVENT_ID,
						E.EVENT_NAME,
						E.START_TIME,
						E.STOP_TIME
					FROM (SELECT CASE p_ENTITY_DOMAIN_ID WHEN EC.ED_TX_FEEDER_SEGMENT THEN FS.FEEDER_SEGMENT_NAME
											WHEN EC.ED_TX_FEEDER THEN F.FEEDER_NAME
											ELSE SS.SUB_STATION_NAME END AS ENTITY_NAME,
							D.RESULT_DATE, R.PROGRAM_ID, R.SERVICE_ZONE_ID,
							X.COLUMN_VALUE AS ENTITY_ID,
							(NVL(D.LOAD_VAL,0) + NVL(D.FAILURE_VAL,0) + NVL(D.OPT_OUT_VAL,0)
								 + NVL(D.OVERRIDE_VAL,0) + NVL(D.TX_LOSS_VAL,0) + D.DX_LOSS_VAL) AS REDUCTION
						FROM DER_SEGMENT_RESULT R,
							DER_SEGMENT_RESULT_DATA D,
							TABLE(CAST(p_ECO_ENV_IMPACT_ENTITY_IDS AS NUMBER_COLLECTION)) X,
							TX_SUB_STATION SS,
							TX_FEEDER F,
							TX_FEEDER_SEGMENT FS
						WHERE -- Segment Result
							p_SERVICE_CODE <> CONSTANTS.CODE_FORECAST
							AND (R.FEEDER_SEGMENT_ID = X.COLUMN_VALUE OR p_ENTITY_DOMAIN_ID <> EC.ED_TX_FEEDER_SEGMENT)
							AND (R.FEEDER_ID = X.COLUMN_VALUE OR p_ENTITY_DOMAIN_ID <> EC.ED_TX_FEEDER)
							AND (R.SUB_STATION_ID = X.COLUMN_VALUE OR p_ENTITY_DOMAIN_ID <> EC.ED_SUB_STATION)
							AND R.IS_EXTERNAL = p_IS_EXTERNAL
							AND R.SERVICE_CODE = p_SERVICE_CODE
							AND R.SCENARIO_ID = GA.BASE_SCENARIO_ID
							-- Segment Result Data
							AND D.DER_SEGMENT_RESULT_ID = R.DER_SEGMENT_RESULT_ID
							AND D.RESULT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
							-- Sub Station, Feeder and Feeder Segment are joined in to get the name
							AND SS.SUB_STATION_ID = R.SUB_STATION_ID
							AND FS.FEEDER_SEGMENT_ID = R.FEEDER_SEGMENT_ID
							AND F.FEEDER_ID = R.FEEDER_ID) SRD,
						DR_EVENT_PROG_SZ E,
						PROGRAM P
					WHERE -- Event
						E.PROGRAM_ID (+) = SRD.PROGRAM_ID
						AND E.SERVICE_ZONE_ID (+) = SRD.SERVICE_ZONE_ID
						AND NVL(E.START_TIME (+), CONSTANTS.LOW_DATE) < SRD.RESULT_DATE
						AND NVL(E.STOP_TIME (+), CONSTANTS.HIGH_DATE) >= SRD.RESULT_DATE
						-- Program
						AND P.PROGRAM_ID = SRD.PROGRAM_ID
						AND P.PROGRAM_TYPE = DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_DLC) R,
					DR_EVENT_SCHEDULE ES
				WHERE ES.EVENT_ID (+) = R.EVENT_ID
					AND ES.SCHEDULE_DATE(+) = R.RESULT_DATE

		UNION ALL

				-- GET FROM DER_SEGMENT_FORECAST_DATA WHEN QUERYING INTERNAL FORECAST DATA
				SELECT R.RESULT_DATE,
					R.EVENT_ID,
					R.ENTITY_NAME,
					R.ENTITY_ID,
					'Avoided Costs' AS AMOUNT_TYPE,
					R.REDUCTION * NVL(ES.PRICE,0) AS AMOUNT,
					R.EVENT_NAME,
					R.START_TIME,
					R.STOP_TIME
				FROM (SELECT DT.RESULT_DATE,
						CASE p_ENTITY_DOMAIN_ID WHEN EC.ED_TX_FEEDER_SEGMENT THEN FS.FEEDER_SEGMENT_NAME
							WHEN EC.ED_TX_FEEDER THEN F.FEEDER_NAME
							ELSE SS.SUB_STATION_NAME END AS ENTITY_NAME,
						X.COLUMN_VALUE AS ENTITY_ID,
						(NVL(DT.LOAD_VAL,0) + NVL(DT.FAILURE_VAL,0) + NVL(DT.OPT_OUT_VAL,0) + NVL(DT.OVERRIDE_VAL,0) + NVL(DT.TX_LOSS_VAL,0) + DT.DX_LOSS_VAL) AS REDUCTION,
						E.EVENT_ID,
						E.EVENT_NAME,
						E.START_TIME,
						E.STOP_TIME
					FROM TABLE(CAST(p_ECO_ENV_IMPACT_ENTITY_IDS AS NUMBER_COLLECTION)) X,
						DER_SEGMENT_FORECAST_DATA DT,
						DR_EVENT_PROG_SZ E,
						PROGRAM P,
						TX_SUB_STATION SS,
						TX_FEEDER F,
						TX_FEEDER_SEGMENT FS
					WHERE -- Segment Result
						(DT.FEEDER_SEGMENT_ID = X.COLUMN_VALUE OR p_ENTITY_DOMAIN_ID <> EC.ED_TX_FEEDER_SEGMENT)
						AND (DT.FEEDER_ID = X.COLUMN_VALUE OR p_ENTITY_DOMAIN_ID <> EC.ED_TX_FEEDER)
						AND (DT.SUB_STATION_ID = X.COLUMN_VALUE OR p_ENTITY_DOMAIN_ID <> EC.ED_SUB_STATION)
						AND p_IS_EXTERNAL = 0
						AND p_SERVICE_CODE = CONSTANTS.CODE_FORECAST
						AND DT.SCENARIO_ID = GA.BASE_SCENARIO_ID
						-- Segment Result Data
						AND DT.RESULT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
						-- Event
						AND E.PROGRAM_ID (+) = DT.PROGRAM_ID
						AND E.SERVICE_ZONE_ID (+) = DT.SERVICE_ZONE_ID
						AND NVL(E.START_TIME (+), CONSTANTS.LOW_DATE) < DT.RESULT_DATE
						AND NVL(E.STOP_TIME (+), CONSTANTS.LOW_DATE) >= DT.RESULT_DATE
						-- Program
						AND P.PROGRAM_ID = DT.PROGRAM_ID
						AND P.PROGRAM_TYPE = DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_DLC
						-- Sub Station, Feeder and Feeder Segment are joined in to get the name
						AND SS.SUB_STATION_ID = DT.SUB_STATION_ID
						AND FS.FEEDER_SEGMENT_ID = DT.FEEDER_SEGMENT_ID
						AND F.FEEDER_ID = DT.FEEDER_ID) R,
					DR_EVENT_SCHEDULE ES
				WHERE ES.EVENT_ID (+) = R.EVENT_ID
					AND ES.SCHEDULE_DATE(+) = R.RESULT_DATE) E
			WHERE SDT.TIME_ZONE = p_TIME_ZONE
				AND SDT.DATA_INTERVAL_TYPE = 1
				AND SDT.DAY_TYPE = '1'
				AND SDT.CUT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
				AND E.RESULT_DATE(+) = SDT.CUT_DATE
				AND (p_INTERVAL <> 'Event' OR E.EVENT_ID IS NOT NULL)
			GROUP BY
				CASE p_INTERVAL
					WHEN '15 Minute' THEN TRIM(SDT.MI15_YYYY_MM_DD)
					WHEN '30 Minute' THEN TRIM(SDT.MI30_YYYY_MM_DD)
					WHEN 'Day' THEN TRIM(SDT.DAY_YYYY_MM_DD)
					WHEN 'Hour' THEN TRIM(SDT.HOUR_YYYY_MM_DD)
					WHEN 'Month' THEN TRIM(SDT.MONTH_YYYY_MM_DD)
					WHEN 'Event' THEN NULL
				END,
				CASE WHEN p_INTERVAL = 'Event' THEN E.EVENT_NAME ELSE NULL END,
				CASE WHEN p_INTERVAL = 'Event' THEN FROM_CUT_AS_HED(E.START_TIME, p_TIME_ZONE, 'MI5') ELSE NULL END,
				CASE WHEN p_INTERVAL = 'Event' THEN FROM_CUT_AS_HED(E.STOP_TIME, p_TIME_ZONE, 'MI5') ELSE NULL END,
				ENTITY_NAME,
				ENTITY_ID,
				AMOUNT_TYPE
			ORDER BY LOAD_DATE,
				CASE WHEN p_INTERVAL = 'Event' THEN E.EVENT_NAME ELSE NULL END,
				CASE WHEN p_INTERVAL = 'Event' THEN FROM_CUT_AS_HED(E.START_TIME, p_TIME_ZONE, 'MI5') ELSE NULL END,
				CASE WHEN p_INTERVAL = 'Event' THEN FROM_CUT_AS_HED(E.STOP_TIME, p_TIME_ZONE, 'MI5') ELSE NULL END,
				ENTITY_NAME,
				AMOUNT_TYPE;
	END IF;

END ECONOMIC_IMPACT_SUMMARY;
----------------------------------------------------------------------------
PROCEDURE ENVRONMENTAL_IMPACT_BY_ACCOUNT
	(
	p_ACCOUNT_ID	IN NUMBER,
	p_SERVICE_CODE	IN VARCHAR2,
	p_IS_EXTERNAL	IN NUMBER,
	p_BEGIN_DATE	IN DATE,
	p_END_DATE		IN DATE,
	p_TIME_ZONE		IN VARCHAR2,
	p_INTERVAL		IN VARCHAR2,
	p_CURSOR		OUT GA.REFCURSOR
	) AS
v_CUT_BEGIN_DATE DATE;
v_CUT_END_DATE DATE;
BEGIN
	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE,p_BEGIN_DATE,p_END_DATE);
	UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_CUT_BEGIN_DATE, v_CUT_END_DATE);

	OPEN p_CURSOR FOR
		SELECT CASE p_INTERVAL
				WHEN '15 Minute' THEN TRIM(SDT.MI15_YYYY_MM_DD)
				WHEN '30 Minute' THEN TRIM(SDT.MI30_YYYY_MM_DD)
				WHEN 'Day' THEN TRIM(SDT.DAY_YYYY_MM_DD)
				WHEN 'Hour' THEN TRIM(SDT.HOUR_YYYY_MM_DD)
				WHEN 'Month' THEN TRIM(SDT.MONTH_YYYY_MM_DD)
				WHEN 'Event' THEN TO_CHAR(E.START_TIME, 'YYYY-MM-DD')
			END AS LOAD_DATE,
			CASE WHEN p_INTERVAL = 'Event' THEN E.EVENT_NAME ELSE NULL END EVENT_NAME,
			CASE WHEN p_INTERVAL = 'Event' THEN FROM_CUT_AS_HED(E.START_TIME, p_TIME_ZONE, 'MI5') ELSE NULL END EVENT_START_TIME,
			CASE WHEN p_INTERVAL = 'Event' THEN FROM_CUT_AS_HED(E.STOP_TIME, p_TIME_ZONE, 'MI5') ELSE NULL END EVENT_STOP_TIME,
			E.PROGRAM_NAME,
			E.PROGRAM_ID,
			NVL(DER.DER_NAME, '-') AS RESOURCE_NAME,
			DER.DER_ID AS RESOURCE_ID,
			C.COMMODITY_NAME,
			C.COMMODITY_ID,
			SUM(RESULT_VAL * NVL(S.AMOUNT,0)) AS AMOUNT,
			SUM(RESULT_VAL * NVL(S.AMOUNT, 0) * NVL(S.PRICE, 0)) AS COST
		FROM SYSTEM_DATE_TIME SDT,
			DISTRIBUTED_ENERGY_RESOURCE DER,
			IT_COMMODITY C,
			INTERCHANGE_TRANSACTION IT,
			IT_SCHEDULE S,
			------------------------------------------------------------------------------------------------
			-- Environmental Impact by Account for Peak Time Rebate is obtained from the Service Load Table
			-------------------------------------------------------------------------------------------------
			-- Previously, we were out-joining to DR_EVENT and DR_EVENT_SCHEDULE, but since there
			-- is no reduction to be considered outside of an event this is now unnecessary
			(SELECT SL.LOAD_DATE AS RESULT_DATE,
					SLP.PROGRAM_NAME,
					SLP.PROGRAM_ID,
					NULL AS RESOURCE_ID,
					(BASE_VAL - MTR_VAL)/1000 AS RESULT_VAL,
					E.EVENT_ID,
					E.EVENT_NAME,
					E.START_TIME,
					E.STOP_TIME
				FROM -- Get the Distinct Service Location and Program
					 -- for the given dates and the account
					(SELECT DISTINCT S1.SERVICE_LOCATION_ID, S1.PROGRAM_ID, P.PROGRAM_NAME,
						SL.SERVICE_ZONE_ID
					  FROM SERVICE_LOCATION_PROGRAM S1,
						ACCOUNT_SERVICE_LOCATION ASL,
						PROGRAM P,
						SERVICE_LOCATION SL
					  WHERE ASL.ACCOUNT_ID = p_ACCOUNT_ID
						AND ASL.BEGIN_DATE <= p_END_DATE
						AND NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
						AND S1.SERVICE_LOCATION_ID = ASL.SERVICE_LOCATION_ID
						AND SL.SERVICE_LOCATION_ID = S1.SERVICE_LOCATION_ID
						AND S1.BEGIN_DATE <= p_END_DATE
						AND NVL(S1.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
						AND P.PROGRAM_ID = S1.PROGRAM_ID
						AND P.PROGRAM_TYPE = DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_PK_TIME_REBATE) SLP,
					-- Metered and Baseline Usage
					(SELECT ACCT_SVC.SERVICE_LOCATION_ID, LD.LOAD_DATE,
							SUM( CASE WHEN LD.SERVICE_CODE = CONSTANTS.CODE_FORECAST THEN
									NVL(LD.LOAD_VAL,0) + NVL(LD.TX_LOSS_VAL,0) + NVL(LD.DX_LOSS_VAL,0) + NVL(LD.UE_LOSS_VAL,0)
								ELSE
									NULL END) AS BASE_VAL,
							SUM( CASE WHEN LD.SERVICE_CODE = CONSTANTS.CODE_ACTUAL THEN
									NVL(LD.LOAD_VAL,0) + NVL(LD.TX_LOSS_VAL,0) + NVL(LD.DX_LOSS_VAL,0) + NVL(LD.UE_LOSS_VAL,0)
								ELSE
									NULL END) AS MTR_VAL
						FROM SERVICE SVC, ACCOUNT_SERVICE ACCT_SVC, SERVICE_LOAD LD
						WHERE ACCT_SVC.ACCOUNT_ID = p_ACCOUNT_ID
							AND SVC.SCENARIO_ID = GA.BASE_SCENARIO_ID
							AND SVC.ACCOUNT_SERVICE_ID = ACCT_SVC.ACCOUNT_SERVICE_ID
							AND LD.SERVICE_ID = SVC.SERVICE_ID
							AND (LD.SERVICE_CODE = CONSTANTS.CODE_FORECAST
									OR LD.SERVICE_CODE = CONSTANTS.CODE_ACTUAL)
							AND LD.LOAD_CODE = '1'
						GROUP BY ACCT_SVC.SERVICE_LOCATION_ID, LD.LOAD_DATE) SL,
					VPP,
					DR_EVENT E
				WHERE SL.SERVICE_LOCATION_ID = SLP.SERVICE_LOCATION_ID
					-- VPP
					AND VPP.PROGRAM_ID = SLP.PROGRAM_ID
					AND VPP.SERVICE_ZONE_ID = SLP.SERVICE_ZONE_ID
					-- Event
					AND E.VPP_ID = VPP.VPP_ID
			UNION ALL
			------------------------------------------------------------------------------------------
			-- Environmental Impact by Account for DLC program is obtained from the DER Daily Result
			------------------------------------------------------------------------------------------
			SELECT DDR.RESULT_DATE,
				DDR.PROGRAM_NAME,
				DDR.PROGRAM_ID,
				DDR.RESOURCE_ID,
				SUM((DDR.RESULT_VAL*(1+NVL(TX_LOSS.RESULT_VAL,0))*(1+NVL(DX_LOSS.RESULT_VAL,0))
					* DDR.SCALE_FACTOR*(1- DDR.FAILURE_RATE- DDR.OPT_OUT_RATE- DDR.OVERRIDE_RATE)
					 * CASE WHEN HITS.RESULT_VAL <= 0 THEN 0 ELSE 1 END)/1000) AS RESULT_VAL,
				DDR.EVENT_ID,
				DDR.EVENT_NAME,
				DDR.START_TIME,
				DDR.STOP_TIME
			FROM (SELECT LOAD.RESULT_DATE,
					P.PROGRAM_NAME,
					P.PROGRAM_ID,
					R.DER_ID AS RESOURCE_ID,
					LOAD.RESULT_VAL,
					R.SCALE_FACTOR,
					R.FAILURE_RATE,
					R.OPT_OUT_RATE,
					R.OVERRIDE_RATE,
					R.TX_LOSS_FACTOR_RESULT_ID,
					R.DX_LOSS_FACTOR_RESULT_ID,
					R.HITS_REMAINING_RESULT_ID,
					E.EVENT_ID,
					E.EVENT_NAME,
					E.START_TIME,
					E.STOP_TIME
				FROM DER_DAILY_RESULT R,
					LOAD_RESULT_DATA LOAD,
					PROGRAM P,
					DR_EVENT_PROG_SZ E
				WHERE -- DER Daily Result
					R.ACCOUNT_ID = p_ACCOUNT_ID
					AND R.IS_EXTERNAL = p_IS_EXTERNAL
					AND R.SERVICE_CODE = p_SERVICE_CODE
					AND R.SCENARIO_ID = GA.BASE_SCENARIO_ID
					AND R.CUT_BEGIN_DATE <= v_CUT_END_DATE
					AND R.CUT_END_DATE >= v_CUT_BEGIN_DATE
					-- Unscaled Load Result
					AND LOAD.LOAD_RESULT_ID = R.LOAD_SHAPE_RESULT_ID
					AND LOAD.RESULT_DATE BETWEEN R.CUT_BEGIN_DATE AND R.CUT_END_DATE
					-- Program and VPP
					AND P.PROGRAM_ID = R.PROGRAM_ID
					AND P.PROGRAM_TYPE = DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_DLC
					-- Event
					AND E.PROGRAM_ID = R.PROGRAM_ID
					AND E.SERVICE_ZONE_ID = R.SERVICE_ZONE_ID
					AND LOAD.RESULT_DATE > NVL(E.START_TIME, CONSTANTS.LOW_DATE)
					AND LOAD.RESULT_DATE <= NVL(E.STOP_TIME, CONSTANTS.HIGH_DATE)) DDR,
				LOAD_RESULT_DATA TX_LOSS,
				LOAD_RESULT_DATA DX_LOSS,
				LOAD_RESULT_DATA HITS
			WHERE -- TX Losses
				TX_LOSS.LOAD_RESULT_ID(+) = DDR.TX_LOSS_FACTOR_RESULT_ID
				AND TX_LOSS.RESULT_DATE(+) = DDR.RESULT_DATE
				-- DX Losses
				AND DX_LOSS.LOAD_RESULT_ID(+) = DDR.DX_LOSS_FACTOR_RESULT_ID
				AND DX_LOSS.RESULT_DATE(+) = DDR.RESULT_DATE
				-- Hits
				AND HITS.LOAD_RESULT_ID(+) = DDR.HITS_REMAINING_RESULT_ID
				AND HITS.RESULT_DATE(+) = DDR.RESULT_DATE
			GROUP BY DDR.RESULT_DATE,
				DDR.PROGRAM_NAME,
				DDR.PROGRAM_ID,
				DDR.RESOURCE_ID,
				DDR.EVENT_ID,
				DDR.EVENT_NAME,
				DDR.START_TIME,
				DDR.STOP_TIME) E
		WHERE -- System Date Time
			SDT.TIME_ZONE = p_TIME_ZONE
			AND SDT.DATA_INTERVAL_TYPE = 1
			AND SDT.DAY_TYPE = '1'
			AND SDT.CUT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
			AND E.RESULT_DATE(+) = SDT.CUT_DATE
			AND (p_INTERVAL <> 'Event' OR E.EVENT_ID IS NOT NULL)
			-- DER
			AND DER.DER_ID(+) = E.RESOURCE_ID
			-- Transaction and IT Schedule
			AND C.COMMODITY_TYPE = 'Emission'
			AND IT.COMMODITY_ID = C.COMMODITY_ID
			AND (S.TRANSACTION_ID = IT.TRANSACTION_ID OR S.TRANSACTION_ID IS NULL)
			AND S.SCHEDULE_DATE(+) = E.RESULT_DATE
		GROUP BY
			CASE p_INTERVAL
				WHEN '15 Minute' THEN TRIM(SDT.MI15_YYYY_MM_DD)
				WHEN '30 Minute' THEN TRIM(SDT.MI30_YYYY_MM_DD)
				WHEN 'Day' THEN TRIM(SDT.DAY_YYYY_MM_DD)
				WHEN 'Hour' THEN TRIM(SDT.HOUR_YYYY_MM_DD)
				WHEN 'Month' THEN TRIM(SDT.MONTH_YYYY_MM_DD)
				WHEN 'Event' THEN TO_CHAR(E.START_TIME, 'YYYY-MM-DD') END,
			CASE WHEN p_INTERVAL = 'Event' THEN E.EVENT_NAME ELSE NULL END,
			CASE WHEN p_INTERVAL = 'Event' THEN FROM_CUT_AS_HED(E.START_TIME, p_TIME_ZONE, 'MI5') ELSE NULL END,
			CASE WHEN p_INTERVAL = 'Event' THEN FROM_CUT_AS_HED(E.STOP_TIME, p_TIME_ZONE, 'MI5') ELSE NULL END,
			PROGRAM_NAME,
			PROGRAM_ID,
			DER.DER_NAME,
			DER.DER_ID,
			C.COMMODITY_NAME,
			C.COMMODITY_ID
		ORDER BY LOAD_DATE,
			PROGRAM_NAME,
			RESOURCE_NAME,
			COMMODITY_NAME;
END ENVRONMENTAL_IMPACT_BY_ACCOUNT;
----------------------------------------------------------------------------
PROCEDURE ENVIRONMENTAL_IMPACT_SUMMARY
	(
	p_ENTITY_DOMAIN_ID			IN NUMBER,
	p_ECO_ENV_IMPACT_ENTITY_IDS	IN NUMBER_COLLECTION,
	p_SERVICE_CODE				IN VARCHAR2,
	p_IS_EXTERNAL				IN NUMBER,
	p_BEGIN_DATE				IN DATE,
	p_END_DATE					IN DATE,
	p_TIME_ZONE					IN VARCHAR2,
	p_INTERVAL					IN VARCHAR2,
	p_CURSOR					OUT GA.REFCURSOR
	) AS
v_CUT_BEGIN_DATE DATE;
v_CUT_END_DATE DATE;
v_P_SZ_IDS ID_SET_COLLECTION;

BEGIN

	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE,p_BEGIN_DATE,p_END_DATE);
	UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_CUT_BEGIN_DATE, v_CUT_END_DATE);

	IF p_ENTITY_DOMAIN_ID IN (EC.ED_VPP, EC.ED_PROGRAM, EC.ED_SERVICE_ZONE) THEN
		-----------------------------------
		-- VPP, Programs and Service Zone
		-----------------------------------

		-- CONVERT TO A PROGRAM / SERVICE_ZONE PAIR COLLECTION
		GET_PROGRAM_SERVICE_ZONE_SET(p_ENTITY_DOMAIN_ID,
								p_ECO_ENV_IMPACT_ENTITY_IDS,
								v_P_SZ_IDS);

		OPEN p_CURSOR FOR
			SELECT CASE p_INTERVAL
					WHEN '15 Minute' THEN TRIM(SDT.MI15_YYYY_MM_DD)
					WHEN '30 Minute' THEN TRIM(SDT.MI30_YYYY_MM_DD)
					WHEN 'Day' THEN TRIM(SDT.DAY_YYYY_MM_DD)
					WHEN 'Hour' THEN TRIM(SDT.HOUR_YYYY_MM_DD)
					WHEN 'Month' THEN TRIM(SDT.MONTH_YYYY_MM_DD)
					WHEN 'Event' THEN NULL
				END AS LOAD_DATE,
				CASE WHEN p_INTERVAL = 'Event' THEN E.EVENT_NAME ELSE NULL END EVENT_NAME,
				CASE WHEN p_INTERVAL = 'Event' THEN FROM_CUT_AS_HED(E.START_TIME, p_TIME_ZONE, 'MI5') ELSE NULL END EVENT_START_TIME,
				CASE WHEN p_INTERVAL = 'Event' THEN FROM_CUT_AS_HED(E.STOP_TIME, p_TIME_ZONE, 'MI5') ELSE NULL END EVENT_STOP_TIME,
				E.ENTITY_NAME,
				E.ENTITY_ID,
				C.COMMODITY_NAME,
				C.COMMODITY_ID,
				SUM(RESULT_VAL * NVL(S.AMOUNT,0)) AS AMOUNT,
				SUM(RESULT_VAL * NVL(S.AMOUNT, 0) * NVL(S.PRICE, 0)) AS COST
			FROM SYSTEM_DATE_TIME SDT,
				IT_COMMODITY C,
				INTERCHANGE_TRANSACTION IT,
				IT_SCHEDULE S,
				----------------------------------------------------------------------------------------------
				-- Environmental Impact Summary for Peak Time Rebate program Summary is obtained from the Service Load tables.
				-- We use the GET_ENTITY_SERVICE_LOCATIONS function to get list of Service Locations
				-- for the selected Entity Domain and Entity Domain Ids
				----------------------------------------------------------------------------------------------
				(SELECT LD.LOAD_DATE AS RESULT_DATE,
						S.ENTITY_NAME,
						S.ENTITY_ID,
						(SUM( CASE WHEN LD.SERVICE_CODE = CONSTANTS.CODE_FORECAST THEN
								NVL(LD.LOAD_VAL,0) + NVL(LD.TX_LOSS_VAL,0) + NVL(LD.DX_LOSS_VAL,0) + NVL(LD.UE_LOSS_VAL,0)
							ELSE NULL END) -
						SUM( CASE WHEN LD.SERVICE_CODE = CONSTANTS.CODE_ACTUAL THEN
								NVL(LD.LOAD_VAL,0) + NVL(LD.TX_LOSS_VAL,0) + NVL(LD.DX_LOSS_VAL,0) + NVL(LD.UE_LOSS_VAL,0)
							ELSE NULL END))/1000 AS RESULT_VAL,
						E.EVENT_ID,
						E.EVENT_NAME,
						E.START_TIME,
						E.STOP_TIME
				FROM (SELECT DISTINCT ESL.ENTITY_ID, ESL.ENTITY_NAME, SP.SERVICE_LOCATION_ID, SP.PROGRAM_ID, P.PROGRAM_NAME, VPP.VPP_ID
					FROM  TABLE(DEMAND_RESPONSE_UI.GET_ENTITY_SERVICE_LOCATIONS(p_ENTITY_DOMAIN_ID, p_ECO_ENV_IMPACT_ENTITY_IDS)) ESL,
						ACCOUNT_SERVICE_LOCATION ASL,
						SERVICE_LOCATION_PROGRAM SP,
						PROGRAM P,
						VPP
					WHERE -- Account Service Location
						(ASL.SERVICE_LOCATION_ID = ESL.SERVICE_LOCATION_ID OR CONSTANTS.ALL_ID = ESL.SERVICE_LOCATION_ID)
						AND ASL.BEGIN_DATE <= p_END_DATE
						AND NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
						-- Service Program
						AND SP.SERVICE_LOCATION_ID = ASL.SERVICE_LOCATION_ID
						AND SP.BEGIN_DATE <= p_END_DATE
						AND NVL(SP.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
						AND P.PROGRAM_ID = SP.PROGRAM_ID
						AND P.PROGRAM_TYPE = DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_PK_TIME_REBATE
						-- VPP
						AND VPP.PROGRAM_ID = P.PROGRAM_ID
						AND (p_ENTITY_DOMAIN_ID <> EC.ED_VPP OR VPP.VPP_ID = ESL.ENTITY_ID)
						AND (p_ENTITY_DOMAIN_ID <> EC.ED_PROGRAM OR VPP.PROGRAM_ID = ESL.ENTITY_ID)
						AND (p_ENTITY_DOMAIN_ID <> EC.ED_SERVICE_ZONE OR VPP.SERVICE_ZONE_ID = ESL.ENTITY_ID)) S,
					ACCOUNT_SERVICE ACCT_SVC,
					SERVICE SVC,
					SERVICE_LOAD LD,
					-- Event
					DR_EVENT E
				WHERE ACCT_SVC.SERVICE_LOCATION_ID = S.SERVICE_LOCATION_ID
					AND SVC.SCENARIO_ID = GA.BASE_SCENARIO_ID
					AND SVC.ACCOUNT_SERVICE_ID = ACCT_SVC.ACCOUNT_SERVICE_ID
					AND LD.SERVICE_ID = SVC.SERVICE_ID
					AND (LD.SERVICE_CODE = CONSTANTS.CODE_FORECAST
							OR LD.SERVICE_CODE = CONSTANTS.CODE_ACTUAL)
					AND LD.LOAD_CODE = '1'
					AND E.VPP_ID = S.VPP_ID
				GROUP BY S.ENTITY_ID, S.ENTITY_NAME, S.VPP_ID, E.EVENT_ID, E.EVENT_NAME, E.START_TIME, E.STOP_TIME, LD.LOAD_DATE
				UNION ALL
				----------------------------------------------------------------------------------------------
				-- Environmental Impact Summary for DLC program is obtained from the DER VPP Result table
				----------------------------------------------------------------------------------------------
				SELECT VRD.RESULT_DATE,
					CASE p_ENTITY_DOMAIN_ID WHEN EC.ED_PROGRAM THEN P.PROGRAM_NAME
						WHEN EC.ED_SERVICE_ZONE THEN SZ.SERVICE_ZONE_NAME
						WHEN EC.ED_VPP THEN VPP.VPP_NAME END AS ENTITY_NAME,
					CASE p_ENTITY_DOMAIN_ID WHEN EC.ED_PROGRAM THEN VRD.PROGRAM_ID
						WHEN EC.ED_SERVICE_ZONE THEN VRD.SERVICE_ZONE_ID
						WHEN EC.ED_VPP THEN VPP.VPP_ID END AS ENTITY_ID,
					VRD.RESULT_VAL,
					E.EVENT_ID,
					E.EVENT_NAME,
					E.START_TIME,
					E.STOP_TIME
				FROM (SELECT (NVL(D.LOAD_VAL,0) + NVL(D.FAILURE_VAL,0) + NVL(D.OPT_OUT_VAL,0)
						+ NVL(D.OVERRIDE_VAL,0) + NVL(D.TX_LOSS_VAL,0) + D.DX_LOSS_VAL) AS RESULT_VAL,
							R.PROGRAM_ID,
							R.SERVICE_ZONE_ID,
							D.RESULT_DATE
						FROM TABLE(CAST(v_P_SZ_IDS AS ID_SET_COLLECTION)) X,
							DER_VPP_RESULT R,
							DER_VPP_RESULT_DATA D
						WHERE -- DER VPP Result
							R.PROGRAM_ID = X.ID1
							AND R.SERVICE_ZONE_ID = X.ID2
							AND R.IS_EXTERNAL = p_IS_EXTERNAL
							AND R.SERVICE_CODE = p_SERVICE_CODE
							AND R.SCENARIO_ID = GA.BASE_SCENARIO_ID
							AND D.DER_VPP_RESULT_ID = R.DER_VPP_RESULT_ID
							AND D.RESULT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE) VRD,
					PROGRAM P,
					DR_EVENT_PROG_SZ E,
					-- TO GET THE VPP NAME
					VIRTUAL_POWER_PLANT VPP,
					-- TO GET THE SERVICE ZONE NAME
					SERVICE_ZONE SZ
				WHERE -- Event
					E.PROGRAM_ID = VRD.PROGRAM_ID
					AND E.SERVICE_ZONE_ID = VRD.SERVICE_ZONE_ID
					AND NVL(E.START_TIME, CONSTANTS.LOW_DATE) < VRD.RESULT_DATE
					AND NVL(E.STOP_TIME, CONSTANTS.HIGH_DATE) >= VRD.RESULT_DATE
					-- Program
					AND P.PROGRAM_ID = VRD.PROGRAM_ID
					AND P.PROGRAM_TYPE = DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_DLC
					-- VPP (JUST TO GET NAME)
					AND VPP.PROGRAM_ID (+) = VRD.PROGRAM_ID
					AND VPP.SERVICE_ZONE_ID (+) = VRD.SERVICE_ZONE_ID
					-- SERVICE ZONE
					AND SZ.SERVICE_ZONE_ID = VRD.SERVICE_ZONE_ID) E

			WHERE -- System Date Time
				SDT.TIME_ZONE = p_TIME_ZONE
				AND SDT.DATA_INTERVAL_TYPE = 1
				AND SDT.DAY_TYPE = '1'
				AND SDT.CUT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
				AND E.RESULT_DATE(+) = SDT.CUT_DATE
				-- Transaction and IT Schedule
				AND C.COMMODITY_TYPE = 'Emission'
				AND IT.COMMODITY_ID = C.COMMODITY_ID
				AND (S.TRANSACTION_ID = IT.TRANSACTION_ID OR S.TRANSACTION_ID IS NULL)
				AND S.SCHEDULE_DATE(+) = E.RESULT_DATE
			GROUP BY
				CASE p_INTERVAL
					WHEN '15 Minute' THEN TRIM(SDT.MI15_YYYY_MM_DD)
					WHEN '30 Minute' THEN TRIM(SDT.MI30_YYYY_MM_DD)
					WHEN 'Day' THEN TRIM(SDT.DAY_YYYY_MM_DD)
					WHEN 'Hour' THEN TRIM(SDT.HOUR_YYYY_MM_DD)
					WHEN 'Month' THEN TRIM(SDT.MONTH_YYYY_MM_DD)
					WHEN 'Event' THEN NULL
				END,
				EVENT_NAME,
				START_TIME,
				STOP_TIME,
				ENTITY_NAME,
				ENTITY_ID,
				C.COMMODITY_NAME,
				C.COMMODITY_ID
			ORDER BY LOAD_DATE,
				EVENT_NAME,
				START_TIME,
				STOP_TIME,
				ENTITY_NAME,
				COMMODITY_NAME;
		ELSE
			-----------------------------------------
			-- SubStation, Feeder and Feeder Segment
			-----------------------------------------
			OPEN p_CURSOR FOR
				SELECT CASE p_INTERVAL
						WHEN '15 Minute' THEN TRIM(SDT.MI15_YYYY_MM_DD)
						WHEN '30 Minute' THEN TRIM(SDT.MI30_YYYY_MM_DD)
						WHEN 'Day' THEN TRIM(SDT.DAY_YYYY_MM_DD)
						WHEN 'Hour' THEN TRIM(SDT.HOUR_YYYY_MM_DD)
						WHEN 'Month' THEN TRIM(SDT.MONTH_YYYY_MM_DD)
						WHEN 'Event' THEN NULL
					END AS LOAD_DATE,
					CASE WHEN p_INTERVAL = 'Event' THEN E.EVENT_NAME ELSE NULL END EVENT_NAME,
					CASE WHEN p_INTERVAL = 'Event' THEN FROM_CUT_AS_HED(E.START_TIME, p_TIME_ZONE, 'MI5') ELSE NULL END EVENT_START_TIME,
					CASE WHEN p_INTERVAL = 'Event' THEN FROM_CUT_AS_HED(E.STOP_TIME, p_TIME_ZONE, 'MI5') ELSE NULL END EVENT_STOP_TIME,
					E.ENTITY_NAME,
					E.ENTITY_ID,
					C.COMMODITY_NAME,
					C.COMMODITY_ID,
					SUM(RESULT_VAL * NVL(S.AMOUNT,0)) AS AMOUNT,
					SUM(RESULT_VAL * NVL(S.AMOUNT, 0) * NVL(S.PRICE, 0)) AS COST
				FROM SYSTEM_DATE_TIME SDT,
					IT_COMMODITY C,
					INTERCHANGE_TRANSACTION IT,
					IT_SCHEDULE S,
					----------------------------------------------------------------------------------------------
					-- Environmental Impact Summary for Peak Time Rebate program Summary is obtained from the Service Load tables.
					-- We use the GET_ENTITY_SERVICE_LOCATIONS function to get list of Service Locations
					-- for the selected Entity Domain and Entity Domain Ids
					----------------------------------------------------------------------------------------------
					(SELECT LD.LOAD_DATE AS RESULT_DATE,
						S.ENTITY_NAME,
						S.ENTITY_ID,
						(SUM( CASE WHEN LD.SERVICE_CODE = CONSTANTS.CODE_FORECAST THEN
								NVL(LD.LOAD_VAL,0) + NVL(LD.TX_LOSS_VAL,0) + NVL(LD.DX_LOSS_VAL,0) + NVL(LD.UE_LOSS_VAL,0)
							ELSE NULL END) -
						SUM( CASE WHEN LD.SERVICE_CODE = CONSTANTS.CODE_ACTUAL THEN
								NVL(LD.LOAD_VAL,0) + NVL(LD.TX_LOSS_VAL,0) + NVL(LD.DX_LOSS_VAL,0) + NVL(LD.UE_LOSS_VAL,0)
							ELSE NULL END))/1000 AS RESULT_VAL,
						E.EVENT_ID,
						E.EVENT_NAME,
						E.START_TIME,
						E.STOP_TIME
					FROM (SELECT DISTINCT ESL.ENTITY_ID, ESL.ENTITY_NAME, SP.SERVICE_LOCATION_ID, SP.PROGRAM_ID, P.PROGRAM_NAME, VPP.VPP_ID
						FROM  TABLE(DEMAND_RESPONSE_UI.GET_ENTITY_SERVICE_LOCATIONS(p_ENTITY_DOMAIN_ID, p_ECO_ENV_IMPACT_ENTITY_IDS)) ESL,
							ACCOUNT_SERVICE_LOCATION ASL,
							SERVICE_LOCATION_PROGRAM SP,
							PROGRAM P,
							VPP
						WHERE -- Account Service Location
							(ASL.SERVICE_LOCATION_ID = ESL.SERVICE_LOCATION_ID OR -1 = ESL.SERVICE_LOCATION_ID)
							AND ASL.BEGIN_DATE <= p_END_DATE
							AND NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
							-- Service Program
							AND SP.SERVICE_LOCATION_ID = ASL.SERVICE_LOCATION_ID
							AND SP.BEGIN_DATE <= p_END_DATE
							AND NVL(SP.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
							AND P.PROGRAM_ID = SP.PROGRAM_ID
							AND P.PROGRAM_TYPE = DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_PK_TIME_REBATE
							-- VPP
							AND VPP.PROGRAM_ID = P.PROGRAM_ID) S,
						ACCOUNT_SERVICE ACCT_SVC,
						SERVICE SVC,
						SERVICE_LOAD LD,
						-- Event
						DR_EVENT E
					WHERE ACCT_SVC.SERVICE_LOCATION_ID = S.SERVICE_LOCATION_ID
						AND SVC.SCENARIO_ID = GA.BASE_SCENARIO_ID
						AND SVC.ACCOUNT_SERVICE_ID = ACCT_SVC.ACCOUNT_SERVICE_ID
						AND LD.SERVICE_ID = SVC.SERVICE_ID
						AND (LD.SERVICE_CODE = CONSTANTS.CODE_FORECAST
								OR LD.SERVICE_CODE = CONSTANTS.CODE_ACTUAL)
						AND LD.LOAD_CODE = '1'
						AND E.VPP_ID = S.VPP_ID
					GROUP BY S.ENTITY_ID, S.ENTITY_NAME, S.VPP_ID, E.EVENT_ID, E.EVENT_NAME, E.START_TIME, E.STOP_TIME, LD.LOAD_DATE
				UNION ALL
				----------------------------------------------------------------------------------------------
				-- Environmental Impact Summary for DLC program is obtained from the DER Segment Result table
				----------------------------------------------------------------------------------------------
					SELECT D.RESULT_DATE,
						D.ENTITY_NAME AS ENTITY_NAME,
						D.ENTITY_ID AS ENTITY_ID,
						D.RESULT_VAL,
						E.EVENT_ID,
						E.EVENT_NAME,
						E.START_TIME,
						E.STOP_TIME
					FROM (SELECT (NVL(SRD.LOAD_VAL,0) + NVL(SRD.FAILURE_VAL,0) + NVL(SRD.OPT_OUT_VAL,0) + NVL(SRD.OVERRIDE_VAL,0) + NVL(SRD.TX_LOSS_VAL,0) + SRD.DX_LOSS_VAL) AS RESULT_VAL,
								X.COLUMN_VALUE AS ENTITY_ID,
								CASE p_ENTITY_DOMAIN_ID WHEN EC.ED_TX_FEEDER_SEGMENT THEN FS.FEEDER_SEGMENT_NAME
									WHEN EC.ED_TX_FEEDER THEN F.FEEDER_NAME
									ELSE SS.SUB_STATION_NAME END AS ENTITY_NAME,
								SRD.RESULT_DATE,
								SR.PROGRAM_ID,
								SR.SERVICE_ZONE_ID
							FROM DER_SEGMENT_RESULT SR,
								DER_SEGMENT_RESULT_DATA SRD,
								TX_FEEDER F,
								TX_FEEDER_SEGMENT FS,
								TX_SUB_STATION SS,
								PROGRAM P,
								TABLE(CAST(p_ECO_ENV_IMPACT_ENTITY_IDS AS NUMBER_COLLECTION)) X
							WHERE (SR.FEEDER_SEGMENT_ID = X.COLUMN_VALUE OR p_ENTITY_DOMAIN_ID <> EC.ED_TX_FEEDER_SEGMENT)
								AND (SR.FEEDER_ID = X.COLUMN_VALUE OR p_ENTITY_DOMAIN_ID <> EC.ED_TX_FEEDER)
								AND (SR.SUB_STATION_ID = X.COLUMN_VALUE OR p_ENTITY_DOMAIN_ID <> EC.ED_SUB_STATION)
								AND p_SERVICE_CODE <> CONSTANTS.CODE_FORECAST
								AND SR.IS_EXTERNAL = p_IS_EXTERNAL
								AND SR.SERVICE_CODE = p_SERVICE_CODE
								AND SR.SCENARIO_ID = GA.BASE_SCENARIO_ID
								-- Segment Result Data
								AND SRD.DER_SEGMENT_RESULT_ID = SR.DER_SEGMENT_RESULT_ID
								AND SRD.RESULT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
								AND P.PROGRAM_ID = SR.PROGRAM_ID
								AND P.PROGRAM_TYPE = DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_DLC
								-- NAMES OF THE ENTITIES
								AND FS.FEEDER_SEGMENT_ID = SR.FEEDER_SEGMENT_ID
								AND F.FEEDER_ID = SR.FEEDER_ID
								AND SS.SUB_STATION_ID = SR.SUB_STATION_ID) D,
						DR_EVENT_PROG_SZ E
					WHERE -- Event
						E.PROGRAM_ID = D.PROGRAM_ID
						AND E.SERVICE_ZONE_ID = D.SERVICE_ZONE_ID
						AND D.RESULT_DATE > NVL(E.START_TIME, CONSTANTS.LOW_DATE)
						AND D.RESULT_DATE <= NVL(E.STOP_TIME, CONSTANTS.HIGH_DATE)

				UNION ALL

					SELECT DT.RESULT_DATE,
						CASE p_ENTITY_DOMAIN_ID WHEN EC.ED_TX_FEEDER_SEGMENT THEN FS.FEEDER_SEGMENT_NAME
							WHEN EC.ED_TX_FEEDER THEN F.FEEDER_NAME
							ELSE SS.SUB_STATION_NAME END AS ENTITY_NAME,
						X.COLUMN_VALUE AS ENTITY_ID,
						(NVL(DT.LOAD_VAL,0) + NVL(DT.FAILURE_VAL,0) + NVL(DT.OPT_OUT_VAL,0) + NVL(DT.OVERRIDE_VAL,0) + NVL(DT.TX_LOSS_VAL,0) + DT.DX_LOSS_VAL) AS RESULT_VAL,
						E.EVENT_ID,
						E.EVENT_NAME,
						E.START_TIME,
						E.STOP_TIME
					FROM TABLE(CAST(p_ECO_ENV_IMPACT_ENTITY_IDS AS NUMBER_COLLECTION)) X,
						DER_SEGMENT_FORECAST_DATA DT,
						DR_EVENT_PROG_SZ E,
						PROGRAM P,
						TX_FEEDER F,
						TX_FEEDER_SEGMENT FS,
						TX_SUB_STATION SS
					WHERE -- Segment Result
						(DT.FEEDER_SEGMENT_ID = X.COLUMN_VALUE OR p_ENTITY_DOMAIN_ID <> EC.ED_TX_FEEDER_SEGMENT)
						AND (DT.FEEDER_ID = X.COLUMN_VALUE OR p_ENTITY_DOMAIN_ID <> EC.ED_TX_FEEDER)
						AND (DT.SUB_STATION_ID = X.COLUMN_VALUE OR p_ENTITY_DOMAIN_ID <> EC.ED_SUB_STATION)
						AND p_SERVICE_CODE = CONSTANTS.CODE_FORECAST
						AND p_IS_EXTERNAL = 0
						AND DT.SCENARIO_ID = GA.BASE_SCENARIO_ID
						-- Segment Result Data
						AND DT.RESULT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
						-- Event
						AND E.PROGRAM_ID = DT.PROGRAM_ID
						AND E.SERVICE_ZONE_ID = DT.SERVICE_ZONE_ID
						AND DT.RESULT_DATE > NVL(E.START_TIME, CONSTANTS.LOW_DATE)
						AND DT.RESULT_DATE <= NVL(E.STOP_TIME, CONSTANTS.HIGH_DATE)
						-- Program
						AND P.PROGRAM_ID = DT.PROGRAM_ID
						AND P.PROGRAM_TYPE = DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_DLC
						-- NAMES OF THE ENTITIES
						AND FS.FEEDER_SEGMENT_ID = DT.FEEDER_SEGMENT_ID
						AND F.FEEDER_ID = DT.FEEDER_ID
						AND SS.SUB_STATION_ID = DT.SUB_STATION_ID) E
				WHERE -- System Date Time
					SDT.TIME_ZONE = p_TIME_ZONE
					AND SDT.DATA_INTERVAL_TYPE = 1
					AND SDT.DAY_TYPE = '1'
					AND SDT.CUT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
					AND E.RESULT_DATE(+) = SDT.CUT_DATE
					AND (p_INTERVAL <> 'Event' OR E.EVENT_ID IS NOT NULL)
					-- Transaction and IT Schedule
					AND C.COMMODITY_TYPE = 'Emission'
					AND IT.COMMODITY_ID = C.COMMODITY_ID
					AND (S.TRANSACTION_ID = IT.TRANSACTION_ID OR S.TRANSACTION_ID IS NULL)
					AND S.SCHEDULE_DATE(+) = E.RESULT_DATE
				GROUP BY
					CASE p_INTERVAL
						WHEN '15 Minute' THEN TRIM(SDT.MI15_YYYY_MM_DD)
						WHEN '30 Minute' THEN TRIM(SDT.MI30_YYYY_MM_DD)
						WHEN 'Day' THEN TRIM(SDT.DAY_YYYY_MM_DD)
						WHEN 'Hour' THEN TRIM(SDT.HOUR_YYYY_MM_DD)
						WHEN 'Month' THEN TRIM(SDT.MONTH_YYYY_MM_DD)
						WHEN 'Event' THEN NULL
					END,
					CASE WHEN p_INTERVAL = 'Event' THEN E.EVENT_NAME ELSE NULL END,
					CASE WHEN p_INTERVAL = 'Event' THEN FROM_CUT_AS_HED(E.START_TIME, p_TIME_ZONE, 'MI5') ELSE NULL END,
					CASE WHEN p_INTERVAL = 'Event' THEN FROM_CUT_AS_HED(E.STOP_TIME, p_TIME_ZONE, 'MI5') ELSE NULL END,
					ENTITY_NAME,
					ENTITY_ID,
					C.COMMODITY_NAME,
					C.COMMODITY_ID
				ORDER BY LOAD_DATE,
					CASE WHEN p_INTERVAL = 'Event' THEN E.EVENT_NAME ELSE NULL END,
					CASE WHEN p_INTERVAL = 'Event' THEN FROM_CUT_AS_HED(E.START_TIME, p_TIME_ZONE, 'MI5') ELSE NULL END,
					CASE WHEN p_INTERVAL = 'Event' THEN FROM_CUT_AS_HED(E.STOP_TIME, p_TIME_ZONE, 'MI5') ELSE NULL END,
					ENTITY_NAME,
					COMMODITY_NAME;
	END IF;
END ENVIRONMENTAL_IMPACT_SUMMARY;
--------------------------------------------------------------------------------
PROCEDURE RECALCULATE_ROLLUPS
(
	p_SERVICE_CODE IN STRING_COLLECTION,
	p_IS_EXTERNAL IN NUMBER_COLLECTION,
	p_DATE_RANGE_BEGIN IN DATE,
	p_DATE_RANGE_END IN DATE,
	p_SCENARIO_ID IN NUMBER := GA.BASE_SCENARIO_ID,
	p_MESSAGE OUT VARCHAR2,
	p_PROCESS_STATUS OUT NUMBER,
	p_PROCESS_ID OUT VARCHAR2
) AS

	v_IDX PLS_INTEGER;

BEGIN


	LOGS.START_PROCESS('Recalculate Rollups', p_DATE_RANGE_BEGIN, p_DATE_RANGE_END);

	LOGS.SET_PROCESS_TARGET_PARAMETER('SERVICE_CODE', TEXT_UTIL.TO_CHAR_STRING_LIST(p_SERVICE_CODE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('IS_EXTERNAL', TEXT_UTIL.TO_CHAR_NUMBER_LIST(p_IS_EXTERNAL));
	LOGS.SET_PROCESS_TARGET_PARAMETER('SCENARIO', TEXT_UTIL.TO_CHAR_ENTITY(p_SCENARIO_ID, EC.ED_SCENARIO));

	FOR v_IDX IN 1..p_SERVICE_CODE.COUNT LOOP
		IF p_IS_EXTERNAL(v_IDX) = 0 THEN
			DER_CAPACITY_ENGINE.CALC_SEGMENT_RESULT_FROM_DER(p_SERVICE_CODE(v_IDX),
															NVL(p_SCENARIO_ID, GA.BASE_SCENARIO_ID),
															p_DATE_RANGE_BEGIN,
															p_DATE_RANGE_END,
															CONSTANTS.ALL_ID,
															NULL,
															p_IS_EXTERNAL(v_IDX),
															TRUE);
		ELSE
			DER_CAPACITY_ENGINE.CALC_VPP_RESULT_FROM_SEGMENT(p_IS_EXTERNAL(v_IDX),
															p_SERVICE_CODE(v_IDX),
															NVL(p_SCENARIO_ID, GA.BASE_SCENARIO_ID),
															p_DATE_RANGE_BEGIN,
															p_DATE_RANGE_END,
															CONSTANTS.ALL_ID,
															NULL,
															FALSE);
		END IF;
	END LOOP;

	LOGS.STOP_PROCESS(p_MESSAGE, p_PROCESS_STATUS);
	p_PROCESS_ID := LOGS.CURRENT_PROCESS_ID;
	COMMIT;
EXCEPTION
	WHEN OTHERS THEN
		ERRS.ABORT_PROCESS;

END RECALCULATE_ROLLUPS;
--------------------------------------------------------------------------------
PROCEDURE ROLLUP_RECALC_OPTIONS
(
	p_CURSOR OUT GA.REFCURSOR,
	p_SHOW_EXTERNAL_FORECAST IN NUMBER := 0
) AS

BEGIN

	OPEN p_CURSOR FOR
	SELECT 'Forecast Capability' AS RESULT_TYPE,
		CONSTANTS.CODE_FORECAST AS SERVICE_CODE,
		0 AS IS_EXTERNAL
	FROM DUAL
	UNION ALL
	SELECT 'External Forecast Capability' AS RESULT_TYPE,
		CONSTANTS.CODE_FORECAST AS SERVICE_CODE,
		1 AS IS_EXTERNAL
	FROM DUAL
	WHERE NVL(p_SHOW_EXTERNAL_FORECAST, 0) = 1
	UNION ALL
	SELECT 'Estimated Reduction' AS RESULT_TYPE,
		CONSTANTS.CODE_BACKCAST AS SERVICE_CODE,
		0 AS IS_EXTERNAL
	FROM DUAL
	UNION ALL
	SELECT 'Reported Reduction' AS RESULT_TYPE,
		CONSTANTS.CODE_BACKCAST AS SERVICE_CODE,
		1 AS IS_EXTERNAL
	FROM DUAL;

END ROLLUP_RECALC_OPTIONS;
--------------------------------------------------------------------------------
PROCEDURE ENVIRONMENTAL_TRANSACTION_LIST
	(
	p_PROGRAM_INTERVAL IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	)AS

BEGIN
	OPEN p_CURSOR FOR
	SELECT IT.TRANSACTION_NAME, IT.TRANSACTION_ID FROM INTERCHANGE_TRANSACTION IT,
		SYSTEM_LABEL SL
	WHERE IT.TRANSACTION_INTERVAL = p_PROGRAM_INTERVAL
		AND SL.MODEL_ID = CONSTANTS.GLOBAL_MODEL
		AND SL.MODULE = 'Load Management'
		AND SL.KEY1 = 'Demand Response'
		AND SL.KEY2 = 'Environmental Signal Transaction'
		AND SL.KEY3 = '?'
		AND IT.TRANSACTION_TYPE = SL.VALUE
	ORDER BY 1;
END ENVIRONMENTAL_TRANSACTION_LIST;

END DEMAND_RESPONSE_UI;
/
