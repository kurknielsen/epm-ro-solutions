CREATE OR REPLACE PACKAGE BODY BSJ AS
----------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
    RETURN '$Revision: 1.2 $';
END WHAT_VERSION;
----------------------------------------------------------------------------------------------------
PROCEDURE NULL_CURSOR
    (
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
		SELECT NULL FROM DUAL;

END NULL_CURSOR;
----------------------------------------------------------------------------------------------------
FUNCTION GET_END_DAY
	(
    p_DATE IN DATE,
    p_INTERVAL IN VARCHAR
    ) RETURN DATE IS
v_BEGIN_DATE DATE := TRUNC(p_DATE,DATE_UTIL.GET_ORA_TRUNC_INTERVAL(p_INTERVAL));
v_INTERVAL VARCHAR2(2) := UPPER(SUBSTR(p_INTERVAL,1,2));
BEGIN
	IF v_INTERVAL = 'YE' THEN
    	RETURN ADD_MONTHS(v_BEGIN_DATE,12)-1;
    ELSIF v_INTERVAL = 'QU' THEN
    	RETURN ADD_MONTHS(v_BEGIN_DATE,3)-1;
    ELSIF v_INTERVAL = 'MO' THEN
    	RETURN ADD_MONTHS(v_BEGIN_DATE,1)-1;
    ELSIF v_INTERVAL = 'WE' THEN
    	RETURN v_BEGIN_DATE+6;
    ELSE -- v_INTERVAL = 'DA' THEN
    	RETURN v_BEGIN_DATE;
    END IF;
END GET_END_DAY;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_END_DAY
	(
    p_DATE IN DATE,
    p_INTERVAL IN VARCHAR,
    p_RESULT OUT DATE
    ) AS
BEGIN
	p_RESULT := GET_END_DAY(p_DATE,p_INTERVAL);
END GET_END_DAY;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SUMMARY_RECORDS
	(
    p_CALLING_MODULE IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
    p_INTERVAL IN VARCHAR,
    p_SHOW_INTERVAL IN NUMBER,
	p_ENTITY_IDs IN VARCHAR,
    p_SHOW_ENTITY_DETAIL IN NUMBER,
    p_PRODUCTS_COMPONENTS IN VARCHAR,
    p_SHOW_PRODUCT_ID IN NUMBER,
    p_SHOW_COMPONENT_ID IN NUMBER,
    p_SHOW_BILL_AMOUNT IN NUMBER,
    p_SHOW_CHARGE_AMOUNT IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_OUT_BEGIN_DATE OUT DATE,
	p_OUT_END_DATE OUT DATE,
    p_RESULTS IN OUT NOCOPY BILLING_SUMMARY_RECORD_TABLE
    ) AS
v_NUMBER_TABLE GA.ID_TABLE;
v_STRING_TABLE GA.STRING_TABLE;
v_WORK_ID1 NUMBER;
v_WORK_ID2 NUMBER;
v_INDEX BINARY_INTEGER;
v_COUNT BINARY_INTEGER;
v_ID NUMBER;
v_BEGIN_DATE DATE := TRUNC(p_BEGIN_DATE,DATE_UTIL.GET_ORA_TRUNC_INTERVAL(p_INTERVAL));
v_END_DATE DATE := GET_END_DAY(p_END_DATE,p_INTERVAL);
v_SHOW_END_DATE NUMBER := 0;
v_WEEK_BEGIN PSE.WEEK_BEGIN%TYPE;

BEGIN
	-- retrieve IDs into table
	UT.IDS_FROM_STRING(p_ENTITY_IDs,',',v_NUMBER_TABLE);
	UT.GET_RTO_WORK_ID(v_WORK_ID1);
    v_INDEX := v_NUMBER_TABLE.FIRST;
	v_COUNT := 0;
    WHILE v_NUMBER_TABLE.EXISTS(v_INDEX) LOOP
		v_ID := v_NUMBER_TABLE(v_INDEX);
		INSERT INTO RTO_WORK (WORK_ID, WORK_XID)
		  	VALUES (v_WORK_ID1, v_ID);
		v_COUNT := v_COUNT+1;
    	v_INDEX := v_NUMBER_TABLE.NEXT(v_INDEX);
    END LOOP;

    IF v_COUNT = 1 THEN
    	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING THEN
    		-- get the week-begin for this PSE
    		SELECT PSE.WEEK_BEGIN INTO v_WEEK_BEGIN FROM PSE
    			WHERE PSE_ID = (SELECT WORK_XID FROM RTO_WORK WHERE WORK_ID = v_WORK_ID1);
	    	-- if there is only one PSE and its statement interval is the same
	        -- as the roll-up interval, don't do TRUNC on statement date - also
            -- show the statement's end date
            DECLARE
            	v_INTERVAL VARCHAR2(16);
            BEGIN
            	SELECT STATEMENT_INTERVAL INTO v_INTERVAL
                FROM PURCHASING_SELLING_ENTITY
                WHERE PSE_ID = v_ID;
                IF UPPER(SUBSTR(v_INTERVAL,1,2)) = UPPER(SUBSTR(p_INTERVAL,1,2)) THEN
                    v_SHOW_END_DATE := p_SHOW_INTERVAL;
				END IF;
          	EXCEPTION
            	WHEN OTHERS THEN
                	NULL; -- ignore error
            END;
        END IF;
	ELSE
        -- if all selected PSEs have the same week_begin, then use the common week_begin.
		-- Otherwise, use the default (which we choose here to be Friday).
		BEGIN
			SELECT DISTINCT WEEK_BEGIN
			INTO v_WEEK_BEGIN
			FROM PURCHASING_SELLING_ENTITY PSE
			WHERE PSE.PSE_ID IN (SELECT WORK_XID FROM RTO_WORK WHERE WORK_ID = v_WORK_ID1);
		EXCEPTION
			WHEN TOO_MANY_ROWS THEN
				v_WEEK_BEGIN := NULL;
		END;
    END IF;

    v_BEGIN_DATE := DATE_UTIL.BEGIN_DATE_FOR_INTERVAL(p_BEGIN_DATE, p_INTERVAL, v_WEEK_BEGIN);
	-- to get proper end date, first get begin date for the last interval in date range
    v_END_DATE := DATE_UTIL.BEGIN_DATE_FOR_INTERVAL(p_END_DATE, p_INTERVAL, v_WEEK_BEGIN);
	-- then get that interval's end date
    v_END_DATE := DATE_UTIL.END_DATE_FOR_INTERVAL(v_END_DATE, p_INTERVAL, v_WEEK_BEGIN);

	p_OUT_BEGIN_DATE := v_BEGIN_DATE;
	p_OUT_END_DATE := v_END_DATE;

	UT.TOKENS_FROM_STRING(p_PRODUCTS_COMPONENTS,';',v_STRING_TABLE);
	UT.GET_RTO_WORK_ID(v_WORK_ID2);
    v_INDEX := v_STRING_TABLE.FIRST;
    WHILE v_STRING_TABLE.EXISTS(v_INDEX) LOOP
		UT.IDS_FROM_STRING(v_STRING_TABLE(v_INDEX),',',v_NUMBER_TABLE);
		INSERT INTO RTO_WORK (WORK_ID, WORK_XID, WORK_DATA)
		  	VALUES (v_WORK_ID2, v_NUMBER_TABLE(1), v_NUMBER_TABLE(2));
    	v_INDEX := v_STRING_TABLE.NEXT(v_INDEX);
    END LOOP;

    -- The values in the selected respectively into
	-- STATEMENT_DATE, STATEMENT_END_DATE, ENTITY_ID, ENTITY_NAME, ENTITY_INTERVAL,PRODUCT_ID
    -- PRODUCT_NAME, COMPONENT_ID, COMPONENT_NAME, IN_DISPUTE, BILL_AMOUNT, CHARGE_AMOUNT

	-- VALUES FOR DRILL DOWN --
    	-- STATEMENT_INTERVAL
    	-- ORIGINAL_DATE
    	-- ORIGINAL_END_DATE
    -- These statements are to know if the right click action should show Billing Details or
		-- charge details. Charge details are shown if every column is shown in the grid
		-- and we are already at the lowest level of drill down
        -- SHOW_BILLING_CHARGES
        -- SHOW_CHARGE_DETAILS
    -- The following few lines is the logic for drill down. The hierarchy for columns shown  through drill down is
        -- 1. Show interval (which is always shown in the first level of drill down)
        -- 2. Then (IF the entity_interval != roll-up interval), then break the drill down by entity_interval
        -- 3. entity
        -- 4. product
        -- 5. component
        -- 6. CHARGE_DETAILS View

        -- SHOW_INTERVAL - We are always showing the interval
        -- SHOW_ENTITY_DETAIL
        -- SHOW_PRODUCT_ID
        -- SHOW_COMPONENT
        -- SHOW_BILL_AMOUNT
        -- SHOW_CHARGE_AMOUNT
   	SELECT BILLING_SUMMARY_RECORD_TYPE(
		CASE
			WHEN p_SHOW_INTERVAL=0 THEN NULL
			ELSE PC.BEGIN_DATE_FOR_INTERVAL(A.STATEMENT_DATE, p_INTERVAL, A.ENTITY_ID, v_WEEK_BEGIN)
			END, /* STATEMENT_DATE */
    	CASE
        	WHEN (v_SHOW_END_DATE = 0 AND p_SHOW_INTERVAL = 1) THEN PC.END_DATE_FOR_INTERVAL(PC.BEGIN_DATE_FOR_INTERVAL(A.STATEMENT_DATE, p_INTERVAL, A.ENTITY_ID, v_WEEK_BEGIN), p_INTERVAL, A.ENTITY_ID, v_WEEK_BEGIN)
        	ELSE NULL
	        END, /* STATEMENT_END_DATE */
		CASE
			WHEN p_SHOW_ENTITY_DETAIL = 1 THEN TO_CHAR(A.ENTITY_ID)
			ELSE p_ENTITY_IDs
			END, /* ENTITY_ID */
        CASE
			WHEN p_SHOW_ENTITY_DETAIL = 1 THEN B.ENTITY_NAME
			ELSE NULL
			END, /* ENTITY_NAME */
        CASE
			WHEN p_SHOW_PRODUCT_ID = 0 AND C.PRODUCT_ID = CONSTANTS.ALL_ID THEN CONSTANTS.ALL_ID
			ELSE A.PRODUCT_ID
			END, /* PRODUCT_ID */
        CASE
			WHEN p_SHOW_PRODUCT_ID = 0 THEN NULL
			ELSE D.PRODUCT_NAME
			END, /* PRODUCT_NAME */
        CASE
			WHEN p_SHOW_COMPONENT_ID = 0 AND C.COMPONENT_ID = CONSTANTS.ALL_ID THEN CONSTANTS.ALL_ID
			ELSE A.COMPONENT_ID
			END, /* COMPONENT_ID */
        CASE
			WHEN p_SHOW_COMPONENT_ID = 0 THEN NULL
			ELSE E.COMPONENT_NAME
			END, /* COMPONENT_NAME */
        MAX(A.IN_DISPUTE), /* IN_DISPUTE */
		SUM(A.BILL_AMOUNT), /* BILL_AMOUNT */
		SUM(A.CHARGE_AMOUNT), /* CHARGE_AMOUNT */
        CASE
        	WHEN p_SHOW_INTERVAL = 0 OR p_SHOW_ENTITY_DETAIL = 0 THEN p_INTERVAL ELSE B.ENTITY_INTERVAL
        	END, /* STATEMENT_INTERVAL */
 		CASE
			WHEN p_SHOW_INTERVAL = 1 THEN
				CASE
					WHEN p_SHOW_ENTITY_DETAIL = 1 AND B.ENTITY_INTERVAL = p_INTERVAL THEN A.STATEMENT_DATE
					ELSE PC.BEGIN_DATE_FOR_INTERVAL(A.STATEMENT_DATE, p_INTERVAL, A.ENTITY_ID, v_WEEK_BEGIN)
					END
			ELSE v_BEGIN_DATE
			END, /* ORIGINAL_DATE */
 		CASE
			WHEN p_SHOW_INTERVAL = 1 THEN
				CASE
					WHEN p_SHOW_ENTITY_DETAIL = 1 AND B.ENTITY_INTERVAL = p_INTERVAL THEN A.STATEMENT_END_DATE
					ELSE PC.END_DATE_FOR_INTERVAL(PC.BEGIN_DATE_FOR_INTERVAL(A.STATEMENT_DATE, p_INTERVAL, A.ENTITY_ID, v_WEEK_BEGIN), p_INTERVAL, A.ENTITY_ID, v_WEEK_BEGIN)
					END
			ELSE v_END_DATE
			END, /* ORIGINAL_END_DATE */
        CASE
        	WHEN (p_SHOW_INTERVAL = 1 AND B.ENTITY_INTERVAL = p_INTERVAL AND p_SHOW_ENTITY_DETAIL = 1 AND p_SHOW_PRODUCT_ID = 1 AND p_SHOW_COMPONENT_ID = 1)
            THEN 1 ELSE 0
        	END, /* SHOW_CHARGE_DETAILS */
      	1, /* SHOW_INTERVAL */
        CASE
        	WHEN (p_SHOW_INTERVAL = 1 AND p_SHOW_ENTITY_DETAIL = 0) THEN 1
			ELSE p_SHOW_ENTITY_DETAIL
        	END, /* SHOW_ENTITY_DETAIL */
        CASE
        	WHEN (p_SHOW_INTERVAL = 1 AND B.ENTITY_INTERVAL = p_INTERVAL AND p_SHOW_ENTITY_DETAIL = 1 AND p_SHOW_PRODUCT_ID = 0) THEN 1
			ELSE p_SHOW_PRODUCT_ID
        	END, /* SHOW_PRODUCT_ID */
        CASE
        	WHEN (p_SHOW_INTERVAL = 1 AND B.ENTITY_INTERVAL = p_INTERVAL AND p_SHOW_ENTITY_DETAIL = 1 AND p_SHOW_PRODUCT_ID = 1 AND p_SHOW_COMPONENT_ID = 0) THEN 1
			ELSE p_SHOW_COMPONENT_ID
        	END) --SHOW_COMPONENT_ID
	BULK COLLECT INTO p_RESULTS
	FROM BILLING_STATEMENT A,
    	(SELECT PSE_ID "ENTITY_ID",
         		PSE_NAME "ENTITY_NAME",
	        	NVL(STATEMENT_INTERVAL,'Month') "ENTITY_INTERVAL"
			FROM RTO_WORK, PURCHASING_SELLING_ENTITY
            WHERE UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING
				AND WORK_ID = v_WORK_ID1
             	AND PSE_ID = WORK_XID
			UNION ALL
            SELECT POOL_ID "ENTITY_ID",
             	POOL_NAME "ENTITY_NAME",
	        	'Month' "ENTITY_INTERVAL"
			FROM RTO_WORK, POOL
            WHERE UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_GAS_DELIVERY
				AND WORK_ID = v_WORK_ID1
             	AND POOL_ID = WORK_XID
			UNION ALL
            SELECT BILL_PARTY_ID "ENTITY_ID",
             	BILL_PARTY_NAME "ENTITY_NAME",
	        	'Month' "ENTITY_INTERVAL"
			FROM RTO_WORK, BILL_PARTY
            WHERE UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_POSITION_AND_BILLING
				AND WORK_ID = v_WORK_ID1
             	AND BILL_PARTY_ID = WORK_XID) B,
		(SELECT WORK_XID "PRODUCT_ID", TO_NUMBER(WORK_DATA) "COMPONENT_ID"
        	FROM RTO_WORK
            WHERE WORK_ID = v_WORK_ID2) C,
        PRODUCT D,
        COMPONENT E
	WHERE (D.PRODUCT_ID = C.PRODUCT_ID OR C.PRODUCT_ID = CONSTANTS.ALL_ID)
    	AND (E.COMPONENT_ID = C.COMPONENT_ID OR C.COMPONENT_ID = CONSTANTS.ALL_ID)
    	AND A.ENTITY_ID = B.ENTITY_ID
        AND A.PRODUCT_ID = D.PRODUCT_ID
        AND A.COMPONENT_ID = E.COMPONENT_ID
        AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
        AND A.STATEMENT_STATE = p_STATEMENT_STATE
        AND A.STATEMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
        AND A.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
         					FROM BILLING_STATEMENT
                             WHERE ENTITY_ID = A.ENTITY_ID
                             	AND PRODUCT_ID = A.PRODUCT_ID
                                 AND COMPONENT_ID = A.COMPONENT_ID
                                 AND STATEMENT_TYPE = A.STATEMENT_TYPE
                                 AND STATEMENT_STATE = A.STATEMENT_STATE
                                 AND STATEMENT_DATE = A.STATEMENT_DATE
                                 AND AS_OF_DATE <= p_AS_OF_DATE)
	GROUP BY
		CASE
			WHEN p_SHOW_INTERVAL = 0 THEN NULL
			ELSE PC.BEGIN_DATE_FOR_INTERVAL(A.STATEMENT_DATE, p_INTERVAL, A.ENTITY_ID, v_WEEK_BEGIN)
			END, /* STATEMENT_DATE */
    	CASE
        	WHEN (v_SHOW_END_DATE = 0 AND p_SHOW_INTERVAL = 1) THEN PC.END_DATE_FOR_INTERVAL(PC.BEGIN_DATE_FOR_INTERVAL(A.STATEMENT_DATE, p_INTERVAL, A.ENTITY_ID, v_WEEK_BEGIN), p_INTERVAL, A.ENTITY_ID, v_WEEK_BEGIN)
        	ELSE NULL
	        END, /* STATEMENT_END_DATE */
		CASE
			WHEN p_SHOW_ENTITY_DETAIL = 1 THEN TO_CHAR(A.ENTITY_ID)
			ELSE p_ENTITY_IDs
			END, /* ENTITY_ID */
        CASE
			WHEN p_SHOW_ENTITY_DETAIL = 1 THEN B.ENTITY_NAME
			ELSE NULL
			END, /* ENTITY_NAME */
        CASE
			WHEN p_SHOW_PRODUCT_ID = 0 AND C.PRODUCT_ID = CONSTANTS.ALL_ID THEN CONSTANTS.ALL_ID
			ELSE A.PRODUCT_ID
			END, /* PRODUCT_ID */
        CASE
			WHEN p_SHOW_PRODUCT_ID = 0 THEN NULL
			ELSE D.PRODUCT_NAME
			END, /* PRODUCT_NAME */
        CASE
			WHEN p_SHOW_COMPONENT_ID = 0 AND C.COMPONENT_ID = CONSTANTS.ALL_ID THEN CONSTANTS.ALL_ID
			ELSE A.COMPONENT_ID
			END, /* COMPONENT_ID */
        CASE
			WHEN p_SHOW_COMPONENT_ID = 0 THEN NULL
			ELSE E.COMPONENT_NAME
			END, /* COMPONENT_NAME */
        CASE
        	WHEN p_SHOW_INTERVAL = 0 OR p_SHOW_ENTITY_DETAIL = 0 THEN p_INTERVAL ELSE B.ENTITY_INTERVAL
        	END, /* STATEMENT_INTERVAL */
 		CASE
			WHEN p_SHOW_INTERVAL = 1 THEN
				CASE
					WHEN p_SHOW_ENTITY_DETAIL = 1 AND B.ENTITY_INTERVAL = p_INTERVAL THEN A.STATEMENT_DATE
					ELSE PC.BEGIN_DATE_FOR_INTERVAL(A.STATEMENT_DATE, p_INTERVAL, A.ENTITY_ID, v_WEEK_BEGIN)
					END
			ELSE v_BEGIN_DATE
			END, /* ORIGINAL_DATE */
 		CASE
			WHEN p_SHOW_INTERVAL = 1 THEN
				CASE
					WHEN p_SHOW_ENTITY_DETAIL = 1 AND B.ENTITY_INTERVAL = p_INTERVAL THEN A.STATEMENT_END_DATE
					ELSE PC.END_DATE_FOR_INTERVAL(PC.BEGIN_DATE_FOR_INTERVAL(A.STATEMENT_DATE, p_INTERVAL, A.ENTITY_ID, v_WEEK_BEGIN), p_INTERVAL, A.ENTITY_ID, v_WEEK_BEGIN)
					END
			ELSE v_END_DATE
			END, /* ORIGINAL_END_DATE */
        CASE
        	WHEN (p_SHOW_INTERVAL = 1 AND B.ENTITY_INTERVAL = p_INTERVAL AND p_SHOW_ENTITY_DETAIL = 1 AND p_SHOW_PRODUCT_ID = 1 AND p_SHOW_COMPONENT_ID = 1)
            THEN 1 ELSE 0
        	END, /* SHOW_CHARGE_DETAILS */
      	1, /* SHOW_INTERVAL */
        CASE
        	WHEN (p_SHOW_INTERVAL = 1 AND p_SHOW_ENTITY_DETAIL = 0) THEN 1
			ELSE p_SHOW_ENTITY_DETAIL
        	END, /* SHOW_ENTITY_DETAIL */
        CASE
        	WHEN (p_SHOW_INTERVAL = 1 AND B.ENTITY_INTERVAL = p_INTERVAL AND p_SHOW_ENTITY_DETAIL = 1 AND p_SHOW_PRODUCT_ID = 0) THEN 1
			ELSE p_SHOW_PRODUCT_ID
        	END, /* SHOW_PRODUCT_ID */
        CASE
        	WHEN (p_SHOW_INTERVAL = 1 AND B.ENTITY_INTERVAL = p_INTERVAL AND p_SHOW_ENTITY_DETAIL = 1 AND p_SHOW_PRODUCT_ID = 1 AND p_SHOW_COMPONENT_ID = 0) THEN 1
			ELSE p_SHOW_COMPONENT_ID  --SHOW_COMPONENT_ID
        	END;

	UT.PURGE_RTO_WORK(v_WORK_ID1);
	UT.PURGE_RTO_WORK(v_WORK_ID2);
EXCEPTION
		 WHEN OTHERS THEN
		 	  UT.PURGE_RTO_WORK(v_WORK_ID1);
		 	  UT.PURGE_RTO_WORK(v_WORK_ID2);
			  RAISE;
END GET_SUMMARY_RECORDS;
----------------------------------------------------------------------------------------------------
FUNCTION GET_LAST_UPDATE
	(
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_ENTITY_IDs IN VARCHAR,
    p_PRODUCTS_COMPONENTS IN VARCHAR,
    p_STATEMENT_TYPE IN NUMBER,
    p_STATEMENT_STATE IN NUMBER,
    p_AS_OF_DATE IN DATE
    ) RETURN DATE IS
v_RET DATE;
v_COUNT BINARY_INTEGER;
v_INDEX BINARY_INTEGER;
v_STRING_TABLE GA.STRING_TABLE;
v_NUMBER_TABLE GA.ID_TABLE;
v_SQL VARCHAR2(4000);
BEGIN
	v_SQL := 'SELECT MAX(ENTRY_DATE)'||
			' FROM BILLING_STATEMENT A,'||
		    '   (';
	v_COUNT := 0;
    UT.TOKENS_FROM_STRING(p_PRODUCTS_COMPONENTS,';',v_STRING_TABLE);
    v_INDEX := v_STRING_TABLE.FIRST;
    WHILE v_STRING_TABLE.EXISTS(v_INDEX) LOOP
    	UT.IDS_FROM_STRING(v_STRING_TABLE(v_INDEX),',',v_NUMBER_TABLE);
		IF v_COUNT > 0 THEN
			v_SQL := v_SQL||' UNION ALL ';
		END IF;
       	v_SQL := v_SQL||' SELECT '||v_NUMBER_TABLE(1)||' "PRODUCT_ID",'||
           				'   '||v_NUMBER_TABLE(2)||' "COMPONENT_ID"'||
                        ' FROM DUAL';
		v_COUNT := v_COUNT+1;
    	v_INDEX := v_STRING_TABLE.NEXT(v_INDEX);
    END LOOP;
	v_SQL := v_SQL||' ) B'||
		    ' WHERE ENTITY_ID IN ('||p_ENTITY_IDs||')'||
		    '  AND (B.PRODUCT_ID = :G OR A.PRODUCT_ID = B.PRODUCT_ID)'||
		    '  AND (B.COMPONENT_ID = :G OR A.COMPONENT_ID = B.COMPONENT_ID)'||
		    '  AND STATEMENT_TYPE = :3'||
		    '  AND STATEMENT_STATE = :4'||
		    '  AND STATEMENT_DATE BETWEEN :5 AND :6'||
		    '  AND AS_OF_DATE = (SELECT MAX(AS_OF_DATE)'||
		    '                    FROM BILLING_STATEMENT'||
		    '                    WHERE ENTITY_ID = A.ENTITY_ID'||
		    '                     AND PRODUCT_ID = A.PRODUCT_ID'||
		    '                     AND COMPONENT_ID = A.COMPONENT_ID'||
		    '                     AND STATEMENT_TYPE = A.STATEMENT_TYPE'||
		    '                     AND STATEMENT_STATE = A.STATEMENT_STATE'||
		    '                     AND STATEMENT_DATE = A.STATEMENT_DATE'||
		    '                     AND AS_OF_DATE <= :7)';
	EXECUTE IMMEDIATE v_SQL
    INTO v_RET
    USING CONSTANTS.ALL_ID, CONSTANTS.ALL_ID, p_STATEMENT_TYPE, p_STATEMENT_STATE,
	      p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE;

	RETURN v_RET;
END GET_LAST_UPDATE;
----------------------------------------------------------------------------------------------------
PROCEDURE BILLING_SUMMARY
	(
    p_CALLING_MODULE IN VARCHAR,
    p_MODEL_ID IN NUMBER,
    p_STATEMENT_DATE IN DATE,
    p_STATEMENT_END_DATE IN DATE,
    p_INTERVAL IN VARCHAR,
    p_SHOW_INTERVAL IN NUMBER,
	p_ENTITY_ID IN VARCHAR,
    p_SHOW_ENTITY_DETAIL IN NUMBER,
    p_PRODUCTS_COMPONENTS IN VARCHAR,
    p_PRODUCT_ID IN VARCHAR,
    p_COMPONENT_ID IN VARCHAR,
    p_SHOW_PRODUCT_ID IN NUMBER,
    p_SHOW_COMPONENT_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
    p_SHOW_BILL_AMOUNT IN NUMBER,
    p_SHOW_CHARGE_AMOUNT IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
    p_BILLING_PERIOD OUT VARCHAR,
    p_LAST_UPDATE OUT VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
    ) AS
v_RESULTS BILLING_SUMMARY_RECORD_TABLE := BILLING_SUMMARY_RECORD_TABLE();
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_PRODUCTS_COMPONENTS VARCHAR(30) := p_PRODUCTS_COMPONENTS;
v_LAST_UPDATE DATE;
BEGIN
	p_STATUS := GA.SUCCESS;
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    IF v_PRODUCTS_COMPONENTS IS NULL THEN
       v_PRODUCTS_COMPONENTS := p_PRODUCT_ID || ',' || p_COMPONENT_ID;
    END IF;

	GET_SUMMARY_RECORDS(p_CALLING_MODULE,p_STATEMENT_DATE,p_STATEMENT_END_DATE,
    			p_INTERVAL,p_SHOW_INTERVAL,p_ENTITY_ID,p_SHOW_ENTITY_DETAIL,
                v_PRODUCTS_COMPONENTS,p_SHOW_PRODUCT_ID,p_SHOW_COMPONENT_ID,
                p_SHOW_BILL_AMOUNT,p_SHOW_CHARGE_AMOUNT,
                p_STATEMENT_TYPE,p_STATEMENT_STATE,p_TIME_ZONE,p_AS_OF_DATE,
				v_BEGIN_DATE, v_END_DATE, v_RESULTS);

    -- This is the output parameter for the label to be displayed with the Billing Period
    p_BILLING_PERIOD := TO_CHAR(v_BEGIN_DATE, g_SHORT_DATE_FORMAT) || ' -> ' ||
                TO_CHAR(v_END_DATE, g_SHORT_DATE_FORMAT);

    -- Again, output paramter for label
	v_LAST_UPDATE := GET_LAST_UPDATE(v_BEGIN_DATE,v_END_DATE,p_ENTITY_ID,
    							v_PRODUCTS_COMPONENTS,p_STATEMENT_TYPE,
                                p_STATEMENT_STATE,p_AS_OF_DATE);
	IF v_LAST_UPDATE IS NULL THEN
		p_LAST_UPDATE := '';
	ELSE
		p_LAST_UPDATE := TO_CHAR(v_LAST_UPDATE, g_LONG_DATE_FORMAT);
	END IF;

    -- The following params are for drill down
    -- SHOW_INTERVAL is for the drill down and interval is always going to be
    -- shown whether the first or last level of drill down.
    -- SHOW_PRODUCT_ID
    -- SHOW_COMPONENT_ID
    -- SHOW_CHARGE_AMOUNT
    -- SHOW_BILL_AMOUNT
    -- STATEMENT_INTERVAL
    -- ORIGINAL_DATE
    -- ORIGINAL_END_DATE
    -- ORIGINAL_END_DATE
    -- SHOW_BILLING_CHARGES
    -- SHOW_CHARGE_DETAILS

	OPEN p_CURSOR FOR
    	SELECT
            STATEMENT_DATE,
        	STATEMENT_END_DATE,
        	ENTITY_ID,
            ENTITY_NAME,
            PRODUCT_ID,
            PRODUCT_NAME,
            COMPONENT_ID,
            COMPONENT_NAME,
            IN_DISPUTE,
            BILL_AMOUNT,
            CHARGE_AMOUNT,
            SHOW_ENTITY_DETAIL,
            SHOW_INTERVAL,
            SHOW_PRODUCT_ID,
            SHOW_COMPONENT_ID,
            STATEMENT_INTERVAL "INTERVAL",
            ORIGINAL_DATE,
            ORIGINAL_END_DATE,
            SHOW_CHARGE_DETAILS,
            p_SHOW_CHARGE_AMOUNT SHOW_CHARGE_AMOUNT,
            p_SHOW_BILL_AMOUNT SHOW_BILL_AMOUNT,
			GET_INVOICE_DATE_RANGE(ENTITY_ID, STATEMENT_DATE, p_INTERVAL, p_STATEMENT_TYPE, p_STATEMENT_STATE) "INVOICE_DATE"
        FROM TABLE(CAST(v_RESULTS AS BILLING_SUMMARY_RECORD_TABLE)) X
		ORDER BY STATEMENT_DATE, ENTITY_NAME, PRODUCT_NAME, COMPONENT_NAME;
EXCEPTION
	WHEN OTHERS THEN
    	NULL_CURSOR(p_CURSOR);
    	p_STATUS := SQLCODE;
END BILLING_SUMMARY;
----------------------------------------------------------------------------------------------------
PROCEDURE BILLING_COMPARISON
	(
    p_CALLING_MODULE IN VARCHAR,
    p_MODEL_ID IN NUMBER,
	p_STATEMENT_DATE IN DATE,
	p_STATEMENT_END_DATE IN DATE,
    p_INTERVAL IN VARCHAR,
    p_SHOW_INTERVAL IN NUMBER,
	p_ENTITY_ID IN VARCHAR,
    p_SHOW_ENTITY_DETAIL IN NUMBER,
    p_PRODUCTS_COMPONENTS IN VARCHAR DEFAULT NULL,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
    p_SHOW_PRODUCT_ID IN NUMBER,
    p_SHOW_COMPONENT_ID IN NUMBER,
	p_STATEMENT_TYPE1 IN NUMBER,
	p_STATEMENT_STATE1 IN NUMBER,
	p_STATEMENT_TYPE2 IN NUMBER,
	p_STATEMENT_STATE2 IN NUMBER,
    p_SHOW_BILL_AMOUNT IN NUMBER,
    p_SHOW_CHARGE_AMOUNT IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
    p_PERIOD_DATE_STRING OUT VARCHAR,
    p_LAST_UPDATE OUT VARCHAR,
	p_MESSAGE OUT VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
    ) AS
v_RESULTS1 BILLING_SUMMARY_RECORD_TABLE := BILLING_SUMMARY_RECORD_TABLE();
v_RESULTS2 BILLING_SUMMARY_RECORD_TABLE := BILLING_SUMMARY_RECORD_TABLE();
v_BEGIN_DATE DATE := p_STATEMENT_DATE;
v_END_DATE DATE := p_STATEMENT_END_DATE;
v_LAST_UPDATE1 DATE;
v_LAST_UPDATE2 DATE;
v_PRODUCTS_COMPONENTS VARCHAR(30) := p_PRODUCTS_COMPONENTS;

BEGIN
	p_STATUS := GA.SUCCESS;
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    IF v_PRODUCTS_COMPONENTS IS null OR (p_PRODUCT_ID IS NOT NULL AND p_COMPONENT_ID IS NOT NULL) THEN
       v_PRODUCTS_COMPONENTS := p_PRODUCT_ID || ',' || p_COMPONENT_ID;
    END IF;

	GET_SUMMARY_RECORDS(p_CALLING_MODULE,p_STATEMENT_DATE,p_STATEMENT_END_DATE,
    			p_INTERVAL,p_SHOW_INTERVAL,p_ENTITY_ID,p_SHOW_ENTITY_DETAIL,
                v_PRODUCTS_COMPONENTS,p_SHOW_PRODUCT_ID,p_SHOW_COMPONENT_ID,p_SHOW_BILL_AMOUNT,
                p_SHOW_CHARGE_AMOUNT,p_STATEMENT_TYPE1,p_STATEMENT_STATE1,p_TIME_ZONE,p_AS_OF_DATE,
                v_BEGIN_DATE, v_END_DATE, v_RESULTS1);
	GET_SUMMARY_RECORDS(p_CALLING_MODULE,p_STATEMENT_DATE,p_STATEMENT_END_DATE,
    			p_INTERVAL,p_SHOW_INTERVAL,p_ENTITY_ID,p_SHOW_ENTITY_DETAIL,
                v_PRODUCTS_COMPONENTS,p_SHOW_PRODUCT_ID,p_SHOW_COMPONENT_ID,p_SHOW_BILL_AMOUNT,
                p_SHOW_CHARGE_AMOUNT,p_STATEMENT_TYPE2,p_STATEMENT_STATE2,p_TIME_ZONE,p_AS_OF_DATE,
                v_BEGIN_DATE, v_END_DATE, v_RESULTS2);

    p_PERIOD_DATE_STRING := to_char(v_BEGIN_DATE,g_SHORT_DATE_FORMAT) || ' -> ' || to_char(v_END_DATE,g_SHORT_DATE_FORMAT);

    v_LAST_UPDATE1 := GET_LAST_UPDATE(v_BEGIN_DATE,v_END_DATE,p_ENTITY_ID,
    							v_PRODUCTS_COMPONENTS,p_STATEMENT_TYPE1,
                                p_STATEMENT_STATE1,p_AS_OF_DATE);
    v_LAST_UPDATE2 := GET_LAST_UPDATE(v_BEGIN_DATE,v_END_DATE,p_ENTITY_ID,
    							v_PRODUCTS_COMPONENTS,p_STATEMENT_TYPE2,
                                p_STATEMENT_STATE2,p_AS_OF_DATE);
	IF v_LAST_UPDATE1 IS NULL AND v_LAST_UPDATE2 IS NULL THEN
		p_LAST_UPDATE := '';
	ELSE
		p_LAST_UPDATE := TO_CHAR(GREATEST(NVL(v_LAST_UPDATE1,LOW_DATE), NVL(v_LAST_UPDATE2,LOW_DATE)), g_LONG_DATE_FORMAT);
	END IF;

	-- The following params are for drill down
    -- A.SHOW_INTERVAL is for the drill down and interval is always going to be
    -- shown whether the first or last level of drill down.
    -- A.SHOW_PRODUCT_ID
    -- A.SHOW_COMPONENT_ID
    -- A.SHOW_CHARGE_AMOUNT
    -- A.SHOW_BILL_AMOUNT
    -- A.STATEMENT_INTERVAL
    -- A.ORIGINAL_DATE
    -- A.ORIGINAL_END_DATE
    -- A.ORIGINAL_END_DATE
    -- A.SHOW_BILLING_CHARGES
    -- A.SHOW_CHARGE_DETAILS
	OPEN p_CURSOR FOR
    	SELECT A.STATEMENT_DATE,
        	NVL(B.STATEMENT_END_DATE,C.STATEMENT_END_DATE) "STATEMENT_END_DATE",
        	A.ENTITY_ID,
            A.ENTITY_NAME,
            A.PRODUCT_ID,
            A.PRODUCT_NAME,
            A.COMPONENT_ID,
            A.COMPONENT_NAME,
			GREATEST(NVL(B.IN_DISPUTE,0),NVL(C.IN_DISPUTE,0)) "IN_DISPUTE",
            B.CHARGE_AMOUNT "CHARGE_AMOUNT1",
            C.CHARGE_AMOUNT "CHARGE_AMOUNT2",
            B.BILL_AMOUNT "BILL_AMOUNT1",
            C.BILL_AMOUNT "BILL_AMOUNT2",
            A.SHOW_ENTITY_DETAIL,
            A.SHOW_INTERVAL,
            A.SHOW_PRODUCT_ID,
            A.SHOW_COMPONENT_ID,
            A.STATEMENT_INTERVAL "INTERVAL",
            A.ORIGINAL_DATE,
            A.ORIGINAL_END_DATE,
            A.SHOW_CHARGE_DETAILS,
            p_SHOW_CHARGE_AMOUNT SHOW_CHARGE_AMOUNT,
            p_SHOW_BILL_AMOUNT SHOW_BILL_AMOUNT,
			GET_INVOICE_DATE_RANGE(A.ENTITY_ID, A.STATEMENT_DATE, p_INTERVAL, p_STATEMENT_TYPE1, p_STATEMENT_STATE1) "INVOICE_DATE"
        FROM (SELECT DISTINCT STATEMENT_DATE, ENTITY_ID, ENTITY_NAME,
        				PRODUCT_ID, PRODUCT_NAME,
                        COMPONENT_ID, COMPONENT_NAME,SHOW_ENTITY_DETAIL,SHOW_INTERVAL,
                        SHOW_PRODUCT_ID,SHOW_COMPONENT_ID,
                        STATEMENT_INTERVAL,ORIGINAL_DATE,ORIGINAL_END_DATE,
                        SHOW_CHARGE_DETAILS
				FROM TABLE(CAST(v_RESULTS1 AS BILLING_SUMMARY_RECORD_TABLE)) X
  	            UNION
				SELECT DISTINCT STATEMENT_DATE, ENTITY_ID, ENTITY_NAME,
        				PRODUCT_ID, PRODUCT_NAME,
                        COMPONENT_ID, COMPONENT_NAME,SHOW_ENTITY_DETAIL,SHOW_INTERVAL,
                        SHOW_PRODUCT_ID,SHOW_COMPONENT_ID,
                        STATEMENT_INTERVAL,ORIGINAL_DATE,ORIGINAL_END_DATE,
                        SHOW_CHARGE_DETAILS
				FROM TABLE(CAST(v_RESULTS2 AS BILLING_SUMMARY_RECORD_TABLE)) Y) A,
        	TABLE(CAST(v_RESULTS1 AS BILLING_SUMMARY_RECORD_TABLE)) B,
        	TABLE(CAST(v_RESULTS2 AS BILLING_SUMMARY_RECORD_TABLE)) C
		WHERE B.ORIGINAL_DATE(+) = A.ORIGINAL_DATE
        	AND B.ENTITY_ID(+) = A.ENTITY_ID
            AND B.PRODUCT_ID(+) = A.PRODUCT_ID
            AND B.COMPONENT_ID(+) = A.COMPONENT_ID
			AND C.ORIGINAL_DATE(+) = A.ORIGINAL_DATE
        	AND C.ENTITY_ID(+) = A.ENTITY_ID
            AND C.PRODUCT_ID(+) = A.PRODUCT_ID
            AND C.COMPONENT_ID(+) = A.COMPONENT_ID
            AND B.STATEMENT_INTERVAL(+) = A.STATEMENT_INTERVAL
            AND C.STATEMENT_INTERVAL(+) = A.STATEMENT_INTERVAL
		ORDER BY A.STATEMENT_DATE, A.ENTITY_NAME, A.PRODUCT_NAME, A.COMPONENT_NAME;
EXCEPTION
	WHEN OTHERS THEN
    	NULL_CURSOR(p_CURSOR);
    	p_STATUS := SQLCODE;
		p_MESSAGE := SQLERRM;

END BILLING_COMPARISON;
----------------------------------------------------------------------------------------------------
FUNCTION GET_INVOICE
	(
	p_INVOICE_ID IN NUMBER
	) RETURN INVOICE%ROWTYPE IS

v_INVOICE INVOICE%ROWTYPE;

BEGIN

	 SELECT *
	 INTO v_INVOICE
	 FROM INVOICE
	 WHERE INVOICE_ID = p_INVOICE_ID;

	RETURN v_INVOICE;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		RETURN v_INVOICE;
	WHEN OTHERS THEN
		RAISE;
END GET_INVOICE;
---------------------------------------------------------------------------------------------------
FUNCTION GET_BILL_PARTY_NAME
	(
	p_BILL_PARTY_ID IN NUMBER
	) RETURN VARCHAR IS

v_BILL_PARTY_NAME VARCHAR(32);

BEGIN

	 SELECT BILL_PARTY_NAME
	 INTO v_BILL_PARTY_NAME
	 FROM BILL_PARTY
	 WHERE BILL_PARTY_ID = p_BILL_PARTY_ID;

	RETURN v_BILL_PARTY_NAME;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		RETURN '?';
	WHEN OTHERS THEN
		RAISE;
END GET_BILL_PARTY_NAME;
---------------------------------------------------------------------------------------------------
PROCEDURE DELETE_INVOICE_USER_LINE_ITEM
	(
    p_INVOICE_USER_LINE_ITEM IN INVOICE_USER_LINE_ITEM%ROWTYPE
    ) AS
BEGIN
	DELETE INVOICE_USER_LINE_ITEM
    WHERE ENTITY_ID = p_INVOICE_USER_LINE_ITEM.ENTITY_ID
    	AND STATEMENT_TYPE = p_INVOICE_USER_LINE_ITEM.STATEMENT_TYPE
        AND STATEMENT_STATE = p_INVOICE_USER_LINE_ITEM.STATEMENT_STATE
        AND BEGIN_DATE = p_INVOICE_USER_LINE_ITEM.BEGIN_DATE
        AND LINE_ITEM_NAME = p_INVOICE_USER_LINE_ITEM.LINE_ITEM_NAME;
END DELETE_INVOICE_USER_LINE_ITEM;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_TAX_USER_LINE_ITEM
	(
    p_INVOICE_USER_LINE_ITEM IN INVOICE_USER_LINE_ITEM%ROWTYPE,
    p_TAX_USER_LINE_ITEM OUT INVOICE_USER_LINE_ITEM%ROWTYPE
    ) AS
BEGIN
	SELECT * INTO p_TAX_USER_LINE_ITEM
    FROM INVOICE_USER_LINE_ITEM
    WHERE ENTITY_ID = p_INVOICE_USER_LINE_ITEM.ENTITY_ID
    	AND STATEMENT_TYPE = p_INVOICE_USER_LINE_ITEM.STATEMENT_TYPE
        AND STATEMENT_STATE = p_INVOICE_USER_LINE_ITEM.STATEMENT_STATE
        AND BEGIN_DATE = p_INVOICE_USER_LINE_ITEM.BEGIN_DATE
        AND LINE_ITEM_TYPE = 'X'
        AND NVL(TAX_COMPONENT_ID,0) = p_INVOICE_USER_LINE_ITEM.TAX_COMPONENT_ID;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
    	p_TAX_USER_LINE_ITEM.ENTITY_ID := p_INVOICE_USER_LINE_ITEM.ENTITY_ID;
        p_TAX_USER_LINE_ITEM.STATEMENT_TYPE := p_INVOICE_USER_LINE_ITEM.STATEMENT_TYPE;
        p_TAX_USER_LINE_ITEM.STATEMENT_STATE := p_INVOICE_USER_LINE_ITEM.STATEMENT_STATE;
        p_TAX_USER_LINE_ITEM.BEGIN_DATE := p_INVOICE_USER_LINE_ITEM.BEGIN_DATE;
        SELECT 'Manual Line Item Tax - '||COMPONENT_NAME
        INTO p_TAX_USER_LINE_ITEM.LINE_ITEM_NAME
        FROM COMPONENT
        WHERE COMPONENT_ID = p_INVOICE_USER_LINE_ITEM.TAX_COMPONENT_ID;
        p_TAX_USER_LINE_ITEM.LINE_ITEM_CATEGORY := p_INVOICE_USER_LINE_ITEM.LINE_ITEM_CATEGORY;
        p_TAX_USER_LINE_ITEM.LINE_ITEM_TYPE := 'X';
        p_TAX_USER_LINE_ITEM.LINE_ITEM_QUANTITY := 0;
        p_TAX_USER_LINE_ITEM.LINE_ITEM_RATE := NULL;
        p_TAX_USER_LINE_ITEM.LINE_ITEM_AMOUNT := 0;
        p_TAX_USER_LINE_ITEM.LINE_ITEM_BILL_AMOUNT := 0;
        p_TAX_USER_LINE_ITEM.LINE_ITEM_POSTED_DATE := SYSDATE;
        p_TAX_USER_LINE_ITEM.IS_TAXED := 0;
        p_TAX_USER_LINE_ITEM.TAX_COMPONENT_ID := p_INVOICE_USER_LINE_ITEM.TAX_COMPONENT_ID;
        p_TAX_USER_LINE_ITEM.TAX_GEOGRAPHY_ID := NULL;
END GET_TAX_USER_LINE_ITEM;
---------------------------------------------------------------------------------------------------
FUNCTION COMPUTE_TAXES
	(
    p_AMOUNT IN NUMBER,
    p_DATE IN DATE,
    p_TAX_COMPONENT_ID IN NUMBER,
    p_GEOGRAPHY_ID IN NUMBER,
    p_STATEMENT_TYPE IN NUMBER
    ) RETURN NUMBER IS
v_TAX_AMOUNT NUMBER := 0;
v_CUR_TAX_AMOUNT NUMBER := 0;
v_COMPONENT COMPONENT%ROWTYPE;
CURSOR c_TAX_AREAS IS
	SELECT GEOGRAPHY_ID
	    FROM GEOGRAPHY
	    START WITH GEOGRAPHY_ID = p_GEOGRAPHY_ID
	    CONNECT BY PRIOR PARENT_GEOGRAPHY_ID = GEOGRAPHY_ID;
BEGIN
	--get component details
	SELECT * INTO v_COMPONENT
    FROM COMPONENT
    WHERE COMPONENT_ID = p_TAX_COMPONENT_ID;
    --loop through
    FOR v_TAX_AREA IN c_TAX_AREAS LOOP
		BEGIN
        	IF UPPER(v_COMPONENT.RATE_STRUCTURE) = 'FLAT' THEN
        		SELECT GREATEST(CHARGE_MIN, p_AMOUNT*RATE)
        		INTO v_CUR_TAX_AMOUNT
        		FROM COMPONENT_FLAT_RATE
        		WHERE COMPONENT_ID = p_TAX_COMPONENT_ID
                    AND SUB_COMPONENT_TYPE = 'GEOGRAPHY'
                    AND SUB_COMPONENT_ID = v_TAX_AREA.GEOGRAPHY_ID
                    AND p_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE,HIGH_DATE);
        	ELSIF UPPER(v_COMPONENT.RATE_STRUCTURE) = 'MARKET' THEN
        		SELECT p_AMOUNT*(B.PRICE*NVL(A.RATE_MULTIPLIER,1)+NVL(A.RATE_ADDER,0))
        		INTO v_CUR_TAX_AMOUNT
        		FROM COMPONENT_MARKET_PRICE A,
        			MARKET_PRICE_VALUE B
        		WHERE A.COMPONENT_ID(+) = p_TAX_COMPONENT_ID
                    AND A.SUB_COMPONENT_TYPE(+) = 'GEOGRAPHY'
                    AND A.SUB_COMPONENT_ID(+) = v_TAX_AREA.GEOGRAPHY_ID
        			AND p_DATE(+) BETWEEN A.BEGIN_DATE AND NVL(A.END_DATE,HIGH_DATE)
        			AND B.MARKET_PRICE_ID = v_COMPONENT.MARKET_PRICE_ID
        			AND B.PRICE_CODE = DECODE(p_STATEMENT_TYPE,1,'F',2,'P','A')
        			AND B.PRICE_DATE = p_DATE
        			AND B.AS_OF_DATE =
        				(SELECT MAX(AS_OF_DATE)
        				FROM MARKET_PRICE_VALUE
        				WHERE MARKET_PRICE_ID = B.MARKET_PRICE_ID
        					AND PRICE_CODE = B.PRICE_CODE
        					AND PRICE_DATE = B.PRICE_DATE
        					AND AS_OF_DATE <= SYSDATE);
        	ELSIF UPPER(v_COMPONENT.RATE_STRUCTURE) = 'BLOCK' THEN
        		SELECT GREATEST(A.CHARGE_MIN, A.RATE*p_AMOUNT)
        		INTO v_CUR_TAX_AMOUNT
        		FROM COMPONENT_BLOCK_RATE A
        		WHERE A.COMPONENT_ID = p_TAX_COMPONENT_ID
                    AND A.SUB_COMPONENT_TYPE = 'GEOGRAPHY'
                    AND A.SUB_COMPONENT_ID = v_TAX_AREA.GEOGRAPHY_ID
        			AND p_DATE BETWEEN A.BEGIN_DATE AND NVL(A.END_DATE,HIGH_DATE)
        			AND p_AMOUNT > A.BLOCK_MIN-1
        			AND p_AMOUNT <= NVL(A.BLOCK_MAX,p_AMOUNT);
        	ELSIF UPPER(v_COMPONENT.RATE_STRUCTURE) = 'TIERED' THEN
        		SELECT SUM(GREATEST(A.CHARGE_MIN, A.RATE*(LEAST(NVL(A.BLOCK_MAX,p_AMOUNT), p_AMOUNT)-DECODE(A.BLOCK_MIN,0,0,A.BLOCK_MIN-1))))
        		INTO v_CUR_TAX_AMOUNT
        		FROM COMPONENT_BLOCK_RATE A
        		WHERE A.COMPONENT_ID = p_TAX_COMPONENT_ID
                    AND A.SUB_COMPONENT_TYPE = 'GEOGRAPHY'
                    AND A.SUB_COMPONENT_ID = v_TAX_AREA.GEOGRAPHY_ID
        			AND p_DATE BETWEEN A.BEGIN_DATE AND NVL(A.END_DATE,HIGH_DATE)
        			AND p_AMOUNT > A.BLOCK_MIN-1;
    		ELSE
    			v_CUR_TAX_AMOUNT := 0;
        	END IF;
		EXCEPTION
			WHEN NO_DATA_FOUND OR TOO_MANY_ROWS THEN
				v_CUR_TAX_AMOUNT := 0;
		END;
		v_TAX_AMOUNT := NVL(v_TAX_AMOUNT,0)+NVL(v_CUR_TAX_AMOUNT,0);
    END LOOP;
    RETURN v_TAX_AMOUNT;
END COMPUTE_TAXES;
---------------------------------------------------------------------------------------------------
PROCEDURE UPDATE_TAX_FOR_USER_LINE_ITEM
	(
    p_OLD_LINE_ITEM IN INVOICE_USER_LINE_ITEM%ROWTYPE,
    p_NEW_LINE_ITEM IN INVOICE_USER_LINE_ITEM%ROWTYPE,
    p_INSERTING IN BOOLEAN,
    p_UPDATING IN BOOLEAN,
    p_DELETING IN BOOLEAN
    ) AS
v_CHARGE_TAX NUMBER;
v_BILL_TAX NUMBER;
v_REMOVING_OLD BOOLEAN := FALSE;
v_ADDING_NEW BOOLEAN := FALSE;
v_TAX_LINE_ITEM INVOICE_USER_LINE_ITEM%ROWTYPE;
BEGIN
	-- don't bother w/ taxing taxes
	IF p_NEW_LINE_ITEM.LINE_ITEM_TYPE = 'X' AND p_OLD_LINE_ITEM.LINE_ITEM_TYPE = 'X' THEN
    	RETURN;
    END IF;

	IF (p_INSERTING AND p_NEW_LINE_ITEM.IS_TAXED <> 0) OR
       (p_UPDATING AND p_OLD_LINE_ITEM.IS_TAXED = 0 AND p_NEW_LINE_ITEM.IS_TAXED <> 0) THEN
    	-- add new taxes
        v_ADDING_NEW := TRUE;
    ELSIF (p_DELETING AND p_OLD_LINE_ITEM.IS_TAXED <> 0) OR
    	  (p_UPDATING AND p_OLD_LINE_ITEM.IS_TAXED <> 0 AND p_NEW_LINE_ITEM.IS_TAXED = 0) THEN
        v_REMOVING_OLD := TRUE;
    ELSIF p_UPDATING AND p_NEW_LINE_ITEM.IS_TAXED <> 0 THEN
    	v_REMOVING_OLD := TRUE;
        v_ADDING_NEW := TRUE;
	END IF;

    IF v_REMOVING_OLD AND p_OLD_LINE_ITEM.TAX_COMPONENT_ID > 0 THEN
       	v_CHARGE_TAX := COMPUTE_TAXES(p_OLD_LINE_ITEM.LINE_ITEM_AMOUNT, p_OLD_LINE_ITEM.BEGIN_DATE, p_OLD_LINE_ITEM.TAX_COMPONENT_ID, p_OLD_LINE_ITEM.TAX_GEOGRAPHY_ID, p_OLD_LINE_ITEM.STATEMENT_TYPE);
       	v_BILL_TAX := COMPUTE_TAXES(p_OLD_LINE_ITEM.LINE_ITEM_BILL_AMOUNT, p_OLD_LINE_ITEM.BEGIN_DATE, p_OLD_LINE_ITEM.TAX_COMPONENT_ID, p_OLD_LINE_ITEM.TAX_GEOGRAPHY_ID, p_OLD_LINE_ITEM.STATEMENT_TYPE);
        GET_TAX_USER_LINE_ITEM (p_OLD_LINE_ITEM, v_TAX_LINE_ITEM);
        v_TAX_LINE_ITEM.LINE_ITEM_QUANTITY := v_TAX_LINE_ITEM.LINE_ITEM_QUANTITY-p_OLD_LINE_ITEM.LINE_ITEM_AMOUNT;
        v_TAX_LINE_ITEM.LINE_ITEM_AMOUNT := v_TAX_LINE_ITEM.LINE_ITEM_AMOUNT-v_CHARGE_TAX;
        v_TAX_LINE_ITEM.LINE_ITEM_BILL_AMOUNT := v_TAX_LINE_ITEM.LINE_ITEM_BILL_AMOUNT-v_BILL_TAX;
        IF v_TAX_LINE_ITEM.LINE_ITEM_QUANTITY = 0 THEN
        	v_TAX_LINE_ITEM.LINE_ITEM_RATE := NULL;
		ELSE
        	v_TAX_LINE_ITEM.LINE_ITEM_RATE := v_TAX_LINE_ITEM.LINE_ITEM_AMOUNT / v_TAX_LINE_ITEM.LINE_ITEM_QUANTITY;
        END IF;
        IF v_TAX_LINE_ITEM.LINE_ITEM_AMOUNT = 0 AND v_TAX_LINE_ITEM.LINE_ITEM_BILL_AMOUNT = 0 THEN
        	-- if tax amount goes to zero, remove tax entry
            DELETE_INVOICE_USER_LINE_ITEM (v_TAX_LINE_ITEM);
        ELSE
	        PUT_INVOICE_USER_LINE_ITEM (v_TAX_LINE_ITEM);
		END IF;
    END IF;
    IF v_ADDING_NEW AND p_NEW_LINE_ITEM.TAX_COMPONENT_ID > 0 THEN
       	v_CHARGE_TAX := COMPUTE_TAXES(p_NEW_LINE_ITEM.LINE_ITEM_AMOUNT, p_NEW_LINE_ITEM.BEGIN_DATE, p_NEW_LINE_ITEM.TAX_COMPONENT_ID, p_NEW_LINE_ITEM.TAX_GEOGRAPHY_ID, p_NEW_LINE_ITEM.STATEMENT_TYPE);
       	v_BILL_TAX := COMPUTE_TAXES(p_NEW_LINE_ITEM.LINE_ITEM_BILL_AMOUNT, p_NEW_LINE_ITEM.BEGIN_DATE, p_NEW_LINE_ITEM.TAX_COMPONENT_ID, p_NEW_LINE_ITEM.TAX_GEOGRAPHY_ID, p_NEW_LINE_ITEM.STATEMENT_TYPE);
        GET_TAX_USER_LINE_ITEM (p_NEW_LINE_ITEM, v_TAX_LINE_ITEM);
        v_TAX_LINE_ITEM.LINE_ITEM_QUANTITY := v_TAX_LINE_ITEM.LINE_ITEM_QUANTITY+p_NEW_LINE_ITEM.LINE_ITEM_AMOUNT;
        v_TAX_LINE_ITEM.LINE_ITEM_AMOUNT := v_TAX_LINE_ITEM.LINE_ITEM_AMOUNT+v_CHARGE_TAX;
        v_TAX_LINE_ITEM.LINE_ITEM_BILL_AMOUNT := v_TAX_LINE_ITEM.LINE_ITEM_BILL_AMOUNT+v_BILL_TAX;
        IF v_TAX_LINE_ITEM.LINE_ITEM_QUANTITY = 0 THEN
        	v_TAX_LINE_ITEM.LINE_ITEM_RATE := NULL;
		ELSE
        	v_TAX_LINE_ITEM.LINE_ITEM_RATE := v_TAX_LINE_ITEM.LINE_ITEM_AMOUNT / v_TAX_LINE_ITEM.LINE_ITEM_QUANTITY;
        END IF;
        IF v_TAX_LINE_ITEM.LINE_ITEM_AMOUNT = 0 AND v_TAX_LINE_ITEM.LINE_ITEM_BILL_AMOUNT = 0 THEN
        	-- if tax amount goes to zero, remove tax entry
            DELETE_INVOICE_USER_LINE_ITEM (v_TAX_LINE_ITEM);
        ELSE
	        PUT_INVOICE_USER_LINE_ITEM (v_TAX_LINE_ITEM);
		END IF;
    END IF;
END UPDATE_TAX_FOR_USER_LINE_ITEM;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_INVOICE_LINE_ITEM
    (
	p_INVOICE_LINE_ITEM IN INVOICE_LINE_ITEM%ROWTYPE,
    p_OLD_LINE_ITEM_NAME IN VARCHAR
	) AS

-- Can only update and delete of RTO generated line items.

BEGIN

	UPDATE INVOICE_LINE_ITEM SET
    	LINE_ITEM_NAME = p_INVOICE_LINE_ITEM.LINE_ITEM_NAME,
        LINE_ITEM_CATEGORY = p_INVOICE_LINE_ITEM.LINE_ITEM_CATEGORY,
		LINE_ITEM_QUANTITY = p_INVOICE_LINE_ITEM.LINE_ITEM_QUANTITY,
		LINE_ITEM_RATE = p_INVOICE_LINE_ITEM.LINE_ITEM_RATE,
		LINE_ITEM_AMOUNT = p_INVOICE_LINE_ITEM.LINE_ITEM_AMOUNT,
		LINE_ITEM_BILL_AMOUNT = p_INVOICE_LINE_ITEM.LINE_ITEM_BILL_AMOUNT,
        DEFAULT_DISPLAY = p_INVOICE_LINE_ITEM.DEFAULT_DISPLAY,
		ENTRY_DATE = SYSDATE
	WHERE INVOICE_ID = p_INVOICE_LINE_ITEM.INVOICE_ID
		AND LINE_ITEM_NAME = p_OLD_LINE_ITEM_NAME;

END PUT_INVOICE_LINE_ITEM;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_INVOICE_USER_LINE_ITEM
    (
	p_INVOICE_USER_LINE_ITEM IN OUT INVOICE_USER_LINE_ITEM%ROWTYPE,
    p_OLD_LINE_ITEM_NAME IN VARCHAR
	) AS
v_OLD_INVOICE_USER_LINE_ITEM INVOICE_USER_LINE_ITEM%ROWTYPE;
BEGIN

	BEGIN
    	SELECT * INTO v_OLD_INVOICE_USER_LINE_ITEM
        FROM INVOICE_USER_LINE_ITEM
		WHERE ENTITY_ID = p_INVOICE_USER_LINE_ITEM.ENTITY_ID
			AND STATEMENT_TYPE = p_INVOICE_USER_LINE_ITEM.STATEMENT_TYPE
			AND STATEMENT_STATE = p_INVOICE_USER_LINE_ITEM.STATEMENT_STATE
			AND BEGIN_DATE = p_INVOICE_USER_LINE_ITEM.BEGIN_DATE
		    AND LINE_ITEM_NAME = p_OLD_LINE_ITEM_NAME;
    EXCEPTION
    	WHEN NO_DATA_FOUND THEN
			NULL;
    END;
    -- make sure not to lose component ID info on updates of auto-tax lines
    IF v_OLD_INVOICE_USER_LINE_ITEM.LINE_ITEM_TYPE = 'X' AND
        p_INVOICE_USER_LINE_ITEM.LINE_ITEM_TYPE = 'X' THEN
		p_INVOICE_USER_LINE_ITEM.IS_TAXED := 0;
        p_INVOICE_USER_LINE_ITEM.TAX_COMPONENT_ID := v_OLD_INVOICE_USER_LINE_ITEM.TAX_COMPONENT_ID;
		p_INVOICE_USER_LINE_ITEM.TAX_GEOGRAPHY_ID := NULL;
	END IF;

	UPDATE INVOICE_USER_LINE_ITEM SET
    	LINE_ITEM_NAME = p_INVOICE_USER_LINE_ITEM.LINE_ITEM_NAME,
        LINE_ITEM_CATEGORY = p_INVOICE_USER_LINE_ITEM.LINE_ITEM_CATEGORY,
		LINE_ITEM_TYPE = p_INVOICE_USER_LINE_ITEM.LINE_ITEM_TYPE,
		LINE_ITEM_QUANTITY = p_INVOICE_USER_LINE_ITEM.LINE_ITEM_QUANTITY,
		LINE_ITEM_RATE = p_INVOICE_USER_LINE_ITEM.LINE_ITEM_RATE,
		LINE_ITEM_AMOUNT = p_INVOICE_USER_LINE_ITEM.LINE_ITEM_AMOUNT,
		LINE_ITEM_BILL_AMOUNT = p_INVOICE_USER_LINE_ITEM.LINE_ITEM_BILL_AMOUNT,
        DEFAULT_DISPLAY = p_INVOICE_USER_LINE_ITEM.DEFAULT_DISPLAY,
		LINE_ITEM_POSTED_DATE = p_INVOICE_USER_LINE_ITEM.LINE_ITEM_POSTED_DATE,
        INVOICE_GROUP_ID = p_INVOICE_USER_LINE_ITEM.INVOICE_GROUP_ID,
        INVOICE_GROUP_ORDER = p_INVOICE_USER_LINE_ITEM.INVOICE_GROUP_ORDER,
        EXCLUDE_FROM_INVOICE_TOTAL = p_INVOICE_USER_LINE_ITEM.EXCLUDE_FROM_INVOICE_TOTAL,
        IS_TAXED = p_INVOICE_USER_LINE_ITEM.IS_TAXED,
        TAX_COMPONENT_ID = p_INVOICE_USER_LINE_ITEM.TAX_COMPONENT_ID,
        TAX_GEOGRAPHY_ID = p_INVOICE_USER_LINE_ITEM.TAX_GEOGRAPHY_ID,
		ENTRY_DATE = SYSDATE
	WHERE ENTITY_ID = p_INVOICE_USER_LINE_ITEM.ENTITY_ID
		AND STATEMENT_TYPE = p_INVOICE_USER_LINE_ITEM.STATEMENT_TYPE
		AND STATEMENT_STATE = p_INVOICE_USER_LINE_ITEM.STATEMENT_STATE
		AND BEGIN_DATE = p_INVOICE_USER_LINE_ITEM.BEGIN_DATE
	    AND LINE_ITEM_NAME = p_OLD_LINE_ITEM_NAME;

	IF SQL%NOTFOUND THEN
	    INSERT INTO INVOICE_USER_LINE_ITEM (
			ENTITY_ID,
			STATEMENT_TYPE,
			STATEMENT_STATE,
			BEGIN_DATE,
			LINE_ITEM_TYPE,
			LINE_ITEM_NAME,
            LINE_ITEM_CATEGORY,
			LINE_ITEM_QUANTITY,
			LINE_ITEM_RATE,
			LINE_ITEM_AMOUNT,
			LINE_ITEM_BILL_AMOUNT,
            DEFAULT_DISPLAY,
			LINE_ITEM_POSTED_DATE,
            INVOICE_GROUP_ID,
            INVOICE_GROUP_ORDER,
            EXCLUDE_FROM_INVOICE_TOTAL,
            IS_TAXED,
            TAX_COMPONENT_ID,
            TAX_GEOGRAPHY_ID,
			ENTRY_DATE)
		VALUES (
			p_INVOICE_USER_LINE_ITEM.ENTITY_ID,
			p_INVOICE_USER_LINE_ITEM.STATEMENT_TYPE,
			p_INVOICE_USER_LINE_ITEM.STATEMENT_STATE,
			p_INVOICE_USER_LINE_ITEM.BEGIN_DATE,
			p_INVOICE_USER_LINE_ITEM.LINE_ITEM_TYPE,
			p_INVOICE_USER_LINE_ITEM.LINE_ITEM_NAME,
            p_INVOICE_USER_LINE_ITEM.LINE_ITEM_CATEGORY,
			p_INVOICE_USER_LINE_ITEM.LINE_ITEM_QUANTITY,
			p_INVOICE_USER_LINE_ITEM.LINE_ITEM_RATE,
			p_INVOICE_USER_LINE_ITEM.LINE_ITEM_AMOUNT,
			p_INVOICE_USER_LINE_ITEM.LINE_ITEM_BILL_AMOUNT,
            p_INVOICE_USER_LINE_ITEM.DEFAULT_DISPLAY,
			p_INVOICE_USER_LINE_ITEM.LINE_ITEM_POSTED_DATE,
            p_INVOICE_USER_LINE_ITEM.INVOICE_GROUP_ID,
            p_INVOICE_USER_LINE_ITEM.INVOICE_GROUP_ORDER,
            p_INVOICE_USER_LINE_ITEM.EXCLUDE_FROM_INVOICE_TOTAL,
            p_INVOICE_USER_LINE_ITEM.IS_TAXED,
            p_INVOICE_USER_LINE_ITEM.TAX_COMPONENT_ID,
            p_INVOICE_USER_LINE_ITEM.TAX_GEOGRAPHY_ID,
			SYSDATE);
		-- inserting
		UPDATE_TAX_FOR_USER_LINE_ITEM (v_OLD_INVOICE_USER_LINE_ITEM, p_INVOICE_USER_LINE_ITEM, TRUE, FALSE, FALSE);
	ELSE
    	-- updating
		UPDATE_TAX_FOR_USER_LINE_ITEM (v_OLD_INVOICE_USER_LINE_ITEM, p_INVOICE_USER_LINE_ITEM, FALSE, TRUE, FALSE);
	END IF;

END PUT_INVOICE_USER_LINE_ITEM;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_INVOICE_USER_LINE_ITEM
    (
	p_INVOICE_USER_LINE_ITEM IN OUT INVOICE_USER_LINE_ITEM%ROWTYPE
	) AS
BEGIN
	PUT_INVOICE_USER_LINE_ITEM (p_INVOICE_USER_LINE_ITEM, p_INVOICE_USER_LINE_ITEM.LINE_ITEM_NAME);
END PUT_INVOICE_USER_LINE_ITEM;
---------------------------------------------------------------------------------------------------
PROCEDURE DAILY_IMBALANCE_SUMMARY
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ENTITY_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_STATEMENT_BEGIN_DATE DATE;
v_STATEMENT_END_DATE DATE;
v_VALID_IDs ID_TABLE;
BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	v_STATEMENT_BEGIN_DATE := PC.GET_CORRECT_STATEMENT_DATE(p_CALLING_MODULE,p_ENTITY_ID,p_BEGIN_DATE-1);
	v_STATEMENT_END_DATE := TRUNC(p_END_DATE)+1;

	IF  UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_GAS_DELIVERY THEN
	    OPEN p_CURSOR FOR
			SELECT B.POOL_NAME "ENTITY_NAME",
				A.ENTITY_ID,
				D.SERVICE_POINT_ID,
				D.SERVICE_POINT_NAME,
				SUM(E.SUPPLY - E.DEMAND) SUM_DIFFERENCE,
				SUM(E.ENERGY_IMBALANCE_AMOUNT) SUM_TOTAL
			FROM BILLING_STATEMENT A, POOL B, COMPONENT C, SERVICE_POINT D, IMBALANCE_CHARGE E
			WHERE (p_ENTITY_ID = CONSTANTS.ALL_ID OR A.ENTITY_ID = p_ENTITY_ID)
				AND A.COMPONENT_ID IN (SELECT DISTINCT COMPONENT_ID FROM BILLING_STATEMENT WHERE UPPER(CHARGE_VIEW_TYPE) = 'IMBALANCE2' AND UPPER(CHARGE_INTERVAL) = 'DAY')
				AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
				AND A.STATEMENT_STATE = CONSTANTS.INTERNAL_STATE
				AND A.STATEMENT_DATE BETWEEN v_STATEMENT_BEGIN_DATE AND v_STATEMENT_END_DATE
				AND A.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
					FROM BILLING_STATEMENT
					WHERE ENTITY_ID = A.ENTITY_ID
						AND PRODUCT_ID = A.PRODUCT_ID
						AND COMPONENT_ID = A.COMPONENT_ID
						AND STATEMENT_TYPE = A.STATEMENT_TYPE
						AND STATEMENT_STATE = A.STATEMENT_STATE
						AND STATEMENT_DATE = A.STATEMENT_DATE
						AND AS_OF_DATE <= p_AS_OF_DATE)
				AND B.POOL_ID = A.ENTITY_ID
				AND C.COMPONENT_ID = A.COMPONENT_ID
				AND D.SERVICE_POINT_ID = C.SERVICE_POINT_ID
				AND E.CHARGE_ID = A.CHARGE_ID
	  			AND E.CHARGE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			GROUP BY B.POOL_NAME, A.ENTITY_ID, D.SERVICE_POINT_ID, D.SERVICE_POINT_NAME
			ORDER BY 1, 4;
	ELSE
    	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING AND p_ENTITY_ID = CONSTANTS.ALL_ID THEN
    		v_VALID_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_PSE_BILL_SELECT);
    	ELSE
    		v_VALID_IDs := ID_TABLE();
    		v_VALID_IDs.EXTEND();
    		v_VALID_IDs(v_VALID_IDs.LAST) := ID_TYPE(p_ENTITY_ID);
    	END IF;

		OPEN p_CURSOR FOR
			SELECT C.PSE_NAME "ENTITY_NAME",
		   		A.ENTITY_ID,
				DECODE(UPPER(SUBSTR(D.IMBALANCE_TYPE,1,1)),'N',0,D.SERVICE_POINT_ID) SERVICE_POINT_ID,
				E.SERVICE_POINT_NAME,
			   	SUM(B.SUPPLY - B.DEMAND) SUM_DIFFERENCE,
		    	SUM(B.ENERGY_IMBALANCE_AMOUNT) SUM_TOTAL
			FROM BILLING_STATEMENT A, IMBALANCE_CHARGE B, PURCHASING_SELLING_ENTITY C, COMPONENT D, SERVICE_POINT E,
				TABLE(CAST(v_VALID_IDs AS ID_TABLE)) F
			WHERE F.ID IN (CONSTANTS.ALL_ID, SD.g_ALL_DATA_ENTITY_ID, A.ENTITY_ID)
				AND A.COMPONENT_ID IN (SELECT DISTINCT COMPONENT_ID FROM COMPONENT WHERE UPPER(RATE_STRUCTURE) = 'IMBALANCE')
				AND E.SERVICE_POINT_ID = D.SERVICE_POINT_ID
				AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
				AND A.STATEMENT_STATE = CONSTANTS.INTERNAL_STATE
				AND A.STATEMENT_DATE BETWEEN v_STATEMENT_BEGIN_DATE AND v_STATEMENT_END_DATE
				AND A.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM BILLING_STATEMENT
					WHERE ENTITY_ID = A.ENTITY_ID
						AND PRODUCT_ID = A.PRODUCT_ID
						AND COMPONENT_ID = A.COMPONENT_ID
						AND STATEMENT_TYPE = A.STATEMENT_TYPE
						AND STATEMENT_STATE = A.STATEMENT_STATE
						AND STATEMENT_DATE = A.STATEMENT_DATE
						AND AS_OF_DATE <= p_AS_OF_DATE)
				AND B.CHARGE_ID = A.CHARGE_ID
		  		AND B.CHARGE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND C.PSE_ID = A.ENTITY_ID
				AND UPPER(SUBSTR(D.IMBALANCE_TYPE,1,1)) IN ('N','S')
			GROUP BY C.PSE_NAME, A.ENTITY_ID, DECODE(UPPER(SUBSTR(D.IMBALANCE_TYPE,1,1)),'N',0,D.SERVICE_POINT_ID), E.SERVICE_POINT_NAME
			ORDER BY 1, 4;
	END IF;

END DAILY_IMBALANCE_SUMMARY;
---------------------------------------------------------------------------------------------------
PROCEDURE DAILY_IMBALANCE
    (
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ENTITY_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_STATEMENT_BEGIN_DATE DATE;
v_STATEMENT_END_DATE DATE;

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	v_STATEMENT_BEGIN_DATE := PC.GET_CORRECT_STATEMENT_DATE(p_CALLING_MODULE,p_ENTITY_ID,p_BEGIN_DATE-1);
	v_STATEMENT_END_DATE := TRUNC(p_END_DATE)+1;

	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_GAS_DELIVERY THEN
		OPEN p_CURSOR FOR
			SELECT B.CHARGE_DATE,
            	A.CHARGE_ID,
	            (B.SUPPLY - B.DEMAND) "DIFFERENCE",
				B.DEMAND,
				B.SUPPLY,
				B.NET_SYSTEM_IMBALANCE,
				C.BAND_NUMBER,
				C.ENERGY_IMBALANCE_QUANTITY "BAND_QUANTITY",
				C.ENERGY_IMBALANCE_RATE "BAND_RATE",
				C.ENERGY_IMBALANCE_AMOUNT "BAND_AMOUNT",
				B.ENERGY_IMBALANCE_AMOUNT "TOTAL_AMOUNT"
			FROM BILLING_STATEMENT A, IMBALANCE_CHARGE B, IMBALANCE_CHARGE_BAND C
			WHERE A.ENTITY_ID = p_ENTITY_ID
				AND A.COMPONENT_ID IN (SELECT DISTINCT COMPONENT_ID FROM BILLING_STATEMENT WHERE UPPER(CHARGE_VIEW_TYPE) = 'IMBALANCE2' AND UPPER(CHARGE_INTERVAL) = 'DAY')
				AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
				AND A.STATEMENT_STATE = CONSTANTS.INTERNAL_STATE
				AND A.STATEMENT_DATE BETWEEN v_STATEMENT_BEGIN_DATE AND v_STATEMENT_END_DATE
				AND B.CHARGE_ID = A.CHARGE_ID
				AND B.CHARGE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND C.CHARGE_ID = B.CHARGE_ID
				AND C.CHARGE_DATE = B.CHARGE_DATE
				AND A.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM BILLING_STATEMENT
					WHERE ENTITY_ID = A.ENTITY_ID
						AND PRODUCT_ID = A.PRODUCT_ID
						AND COMPONENT_ID = A.COMPONENT_ID
						AND STATEMENT_TYPE = A.STATEMENT_TYPE
						AND STATEMENT_STATE = A.STATEMENT_STATE
						AND STATEMENT_DATE = A.STATEMENT_DATE
						AND AS_OF_DATE <= p_AS_OF_DATE)
			ORDER BY B.CHARGE_DATE, A.CHARGE_ID, C.BAND_NUMBER;
	ELSE
		OPEN p_CURSOR FOR
			SELECT FROM_CUT_AS_HED(B.CHARGE_DATE, p_TIME_ZONE) "CHARGE_DATE",
            	A.CHARGE_ID,
	            (B.SUPPLY - B.DEMAND) "DIFFERENCE",
				B.DEMAND,
				B.SUPPLY,
				B.NET_SYSTEM_IMBALANCE,
				C.BAND_NUMBER,
				C.ENERGY_IMBALANCE_QUANTITY "BAND_QUANTITY",
				C.ENERGY_IMBALANCE_RATE "BAND_RATE",
				C.ENERGY_IMBALANCE_AMOUNT "BAND_AMOUNT",
				B.ENERGY_IMBALANCE_AMOUNT "TOTAL_AMOUNT"
		FROM BILLING_STATEMENT A, IMBALANCE_CHARGE B, IMBALANCE_CHARGE_BAND C, COMPONENT D
		WHERE A.ENTITY_ID = p_ENTITY_ID
			AND A.COMPONENT_ID = D.COMPONENT_ID
			AND ((p_SERVICE_POINT_ID = 0 AND
				  UPPER(A.CHARGE_VIEW_TYPE) = 'IMBALANCE1' AND
				  UPPER(SUBSTR(D.IMBALANCE_TYPE,1,1)) = 'N')
	  		  OR (p_SERVICE_POINT_ID <> 0 AND
  			  	  UPPER(A.CHARGE_VIEW_TYPE) = 'IMBALANCE3' AND
  			  	  UPPER(SUBSTR(D.IMBALANCE_TYPE,1,1)) = 'S' AND
  		  		  D.SERVICE_POINT_ID = p_SERVICE_POINT_ID))
			AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
			AND A.STATEMENT_STATE = CONSTANTS.INTERNAL_STATE
			AND A.STATEMENT_DATE BETWEEN v_STATEMENT_BEGIN_DATE AND v_STATEMENT_END_DATE
			AND B.CHARGE_ID = A.CHARGE_ID
	  		AND B.CHARGE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND C.CHARGE_ID = B.CHARGE_ID
			AND C.CHARGE_DATE = B.CHARGE_DATE
			AND A.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM BILLING_STATEMENT
				WHERE ENTITY_ID = A.ENTITY_ID
					AND PRODUCT_ID = A.PRODUCT_ID
					AND COMPONENT_ID = A.COMPONENT_ID
					AND STATEMENT_TYPE = A.STATEMENT_TYPE
					AND STATEMENT_STATE = A.STATEMENT_STATE
					AND STATEMENT_DATE = A.STATEMENT_DATE
					AND AS_OF_DATE <= p_AS_OF_DATE)
		ORDER BY B.CHARGE_DATE, A.CHARGE_ID, C.BAND_NUMBER;
        END IF;

END DAILY_IMBALANCE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_INVOICE_REPORT_RECORDS
	(
    p_CALLING_MODULE IN VARCHAR,
    p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_INVOICE_DATE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
    p_INVOICE_CATEGORY IN VARCHAR,
    p_INVOICE_ID OUT NUMBER,
	p_ENTITY_NAME OUT VARCHAR2,
	p_INVOICE_TITLE OUT VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
    ) AS

v_INVOICE_BEGIN_DATE DATE;
v_ENTITY_ID NUMBER;

BEGIN

    IF p_INVOICE_DATE IS NULL THEN
		v_INVOICE_BEGIN_DATE := NULL;
	ELSE
		v_INVOICE_BEGIN_DATE := TO_DATE(SUBSTR(p_INVOICE_DATE,1,10), g_SHORT_DATE_FORMAT);
	END IF;

    -- PBM - 4/18/2006 - Removed code that was trying to get the InvoiceDate for the
    -- selected InvoiceId. It wouldn't have worked anyway since this procedure does
    -- not allow you to pass in the InvoiceId. Added code to fetch the InvoiceId based
    -- on the InvoiceDate that has been passed in.
    -- Begin Fix
    SELECT NVL(MAX(INVOICE_ID),-1) INTO p_INVOICE_ID
    FROM INVOICE A
    WHERE A.ENTITY_ID = p_ENTITY_ID
		AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
		AND A.STATEMENT_STATE = p_STATEMENT_STATE
		AND A.BEGIN_DATE <= v_INVOICE_BEGIN_DATE
		AND A.END_DATE >= v_INVOICE_BEGIN_DATE
		AND A.AS_OF_DATE = (SELECT MAX(AS_OF_DATE) FROM INVOICE
	                       	WHERE ENTITY_ID = A.ENTITY_ID
	                           	AND STATEMENT_TYPE = A.STATEMENT_TYPE
	                           	AND STATEMENT_STATE = A.STATEMENT_STATE
	                        	AND BEGIN_DATE = A.BEGIN_DATE
	                            AND AS_OF_DATE <= p_AS_OF_DATE);
    -- End Fix
	GET_INVOICE_RPT_RECS_BY_ID(p_INVOICE_CATEGORY, p_INVOICE_ID, p_STATUS, p_CURSOR);

	SELECT I.ENTITY_ID
	INTO v_ENTITY_ID
	FROM INVOICE I
	WHERE I.INVOICE_ID = p_INVOICE_ID;

	p_ENTITY_NAME := EI.GET_ENTITY_NAME(EC.ED_PSE, v_ENTITY_ID);

	SP.GET_SYSTEM_DICTIONARY_VALUE(GA.DEFAULT_MODEL, 'Billing', 'Invoice',
		CONSTANTS.UNDEFINED_ATTRIBUTE, CONSTANTS.UNDEFINED_ATTRIBUTE, 'Title',
		p_INVOICE_TITLE);

END GET_INVOICE_REPORT_RECORDS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_INVOICE_LINE_ITEMS_REPORT
    (
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
    p_STATEMENT_STATE IN NUMBER,
	p_INVOICE_DATE IN VARCHAR,
    p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_INVOICE_ID NUMBER;
v_INVOICE_BEGIN_DATE DATE;
BEGIN

    IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

    IF p_INVOICE_DATE IS NULL THEN
		v_INVOICE_BEGIN_DATE := NULL;
	ELSE
		v_INVOICE_BEGIN_DATE := TO_DATE(SUBSTR(p_INVOICE_DATE,1,10), g_SHORT_DATE_FORMAT);
	END IF;

	SELECT NVL(MAX(INVOICE_ID),-1) INTO v_INVOICE_ID
    FROM INVOICE A
    WHERE A.ENTITY_ID = p_ENTITY_ID
		AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
		AND A.STATEMENT_STATE = p_STATEMENT_STATE
		AND A.BEGIN_DATE <= v_INVOICE_BEGIN_DATE
		AND A.END_DATE >= v_INVOICE_BEGIN_DATE
		AND A.AS_OF_DATE = (SELECT MAX(AS_OF_DATE) FROM INVOICE
	                       	WHERE ENTITY_ID = A.ENTITY_ID
	                           	AND STATEMENT_TYPE = A.STATEMENT_TYPE
	                           	AND STATEMENT_STATE = A.STATEMENT_STATE
	                        	AND BEGIN_DATE = A.BEGIN_DATE
	                            AND AS_OF_DATE <= p_AS_OF_DATE);

	OPEN p_CURSOR FOR
		SELECT X.INVOICE_ID ,X.LINE_ITEM_NAME, X.LINE_ITEM_CATEGORY, X.LINE_ITEM_QUANTITY, X.LINE_ITEM_RATE,
        	X.LINE_ITEM_AMOUNT, X.LINE_ITEM_BILL_AMOUNT, X.DEFAULT_DISPLAY, X.LINE_ITEM_TYPE,
            X.INVOICE_GROUP_ID, X.INVOICE_GROUP_ORDER, X.EXCLUDE_FROM_INVOICE_TOTAL,
            X.IS_TAXED, X.TAX_COMPONENT_ID, X.TAX_GEOGRAPHY_ID,
            X.IS_MANUAL_LINE_ITEM, X.STATEMENT_TYPE AS LINE_ITEM_STATEMENT_TYPE_ID,
			X.BEGIN_DATE, X.END_DATE
		FROM
			(SELECT A.INVOICE_ID, A.LINE_ITEM_NAME, A.LINE_ITEM_CATEGORY, A.LINE_ITEM_QUANTITY, A.LINE_ITEM_RATE,
            		A.LINE_ITEM_AMOUNT, A.LINE_ITEM_BILL_AMOUNT, A.DEFAULT_DISPLAY,
                    DECODE(UPPER(B.CHARGE_TYPE), 'TAX', 'Tax', 'Current') "LINE_ITEM_TYPE",
                    B.INVOICE_GROUP_ID, B.INVOICE_GROUP_ORDER, B.EXCLUDE_FROM_INVOICE_TOTAL,
                    B.IS_TAXED, 0 "TAX_COMPONENT_ID", NULL "TAX_GEOGRAPHY_ID",
                    0 "IS_MANUAL_LINE_ITEM", A.STATEMENT_TYPE, A.BEGIN_DATE, A.END_DATE
			FROM INVOICE_LINE_ITEM A, COMPONENT B
			WHERE A.INVOICE_ID	 = v_INVOICE_ID
				AND B.COMPONENT_ID(+) = A.COMPONENT_ID
			UNION ALL
            SELECT NULL AS INVOICE_ID,A.LINE_ITEM_NAME, A.LINE_ITEM_CATEGORY, A.LINE_ITEM_QUANTITY, A.LINE_ITEM_RATE,
            		A.LINE_ITEM_AMOUNT, A.LINE_ITEM_BILL_AMOUNT, A.DEFAULT_DISPLAY,
					DECODE(A.LINE_ITEM_TYPE, 'P', 'Payment', 'F', 'Finance Charge', 'A', 'Adjustment', 'B', 'Balance', 'M', 'Miscellaneous', 'X', 'Manual Line Item Tax') "LINE_ITEM_TYPE",
                    A.INVOICE_GROUP_ID, A.INVOICE_GROUP_ORDER, A.EXCLUDE_FROM_INVOICE_TOTAL,
                    A.IS_TAXED, A.TAX_COMPONENT_ID, A.TAX_GEOGRAPHY_ID,
                    1 "IS_MANUAL_LINE_ITEM", A.STATEMENT_TYPE, A.BEGIN_DATE, A.BEGIN_DATE "END_DATE"
			FROM INVOICE_USER_LINE_ITEM A
			WHERE A.ENTITY_ID = p_ENTITY_ID
				AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
                AND A.STATEMENT_STATE = p_STATEMENT_STATE
				AND A.BEGIN_DATE = v_INVOICE_BEGIN_DATE) X;

END GET_INVOICE_LINE_ITEMS_REPORT;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_INVOICE_LINE_ITEM_TYPES
    (
	p_IS_MANUAL_LINE_ITEM IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
BEGIN

	p_STATUS := GA.SUCCESS;

    IF p_IS_MANUAL_LINE_ITEM IS NULL OR TO_NUMBER(p_IS_MANUAL_LINE_ITEM) = 1 THEN
        SP.GET_SYSTEM_LABEL_VALUES(0, 'Billing', 'User Line Item Type', 'Values', '?', p_STATUS, p_CURSOR);
    ELSE
        SP.GET_SYSTEM_LABEL_VALUES(0, 'Billing', 'Line Item Type', 'Values', '?', p_STATUS, p_CURSOR);
    END IF;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END GET_INVOICE_LINE_ITEM_TYPES;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_INVOICE_LINE_ITEM
    (
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
    p_STATEMENT_STATE IN NUMBER,
	p_INVOICE_DATE IN DATE,
	p_INVOICE_ID IN NUMBER,
	p_LINE_ITEM_NAME IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
v_INVOICE_DATE DATE;
BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	BEGIN
	    SELECT BEGIN_DATE INTO v_INVOICE_DATE
	    FROM INVOICE
	    WHERE INVOICE_ID = p_INVOICE_ID;
	EXCEPTION
    	WHEN NO_DATA_FOUND THEN
        	v_INVOICE_DATE := p_INVOICE_DATE;
	END;

	OPEN p_CURSOR FOR
		SELECT X.LINE_ITEM_NAME, X.LINE_ITEM_CATEGORY, X.LINE_ITEM_QUANTITY, X.LINE_ITEM_RATE,
        	X.LINE_ITEM_AMOUNT, X.LINE_ITEM_BILL_AMOUNT, X.DEFAULT_DISPLAY, X.LINE_ITEM_TYPE,
            X.INVOICE_GROUP_ID, X.INVOICE_GROUP_ORDER, X.EXCLUDE_FROM_INVOICE_TOTAL,
            X.IS_TAXED, X.TAX_COMPONENT_ID, X.TAX_GEOGRAPHY_ID,
            X.IS_MANUAL_LINE_ITEM, X.STATEMENT_TYPE, X.BEGIN_DATE, X.END_DATE
		FROM
			(SELECT A.LINE_ITEM_NAME, A.LINE_ITEM_CATEGORY, A.LINE_ITEM_QUANTITY, A.LINE_ITEM_RATE,
            		A.LINE_ITEM_AMOUNT, A.LINE_ITEM_BILL_AMOUNT, A.DEFAULT_DISPLAY,
                    DECODE(UPPER(B.CHARGE_TYPE), 'TAX', 'Tax', 'Current') "LINE_ITEM_TYPE",
                    B.INVOICE_GROUP_ID, B.INVOICE_GROUP_ORDER, B.EXCLUDE_FROM_INVOICE_TOTAL,
                    B.IS_TAXED, 0 "TAX_COMPONENT_ID", NULL "TAX_GEOGRAPHY_ID",
                    0 "IS_MANUAL_LINE_ITEM", A.STATEMENT_TYPE, A.BEGIN_DATE, A.END_DATE
			FROM INVOICE_LINE_ITEM A, COMPONENT B
			WHERE A.INVOICE_ID	 = p_INVOICE_ID
				AND LINE_ITEM_NAME = p_LINE_ITEM_NAME
				AND B.COMPONENT_ID(+) = A.COMPONENT_ID
			UNION ALL
            SELECT A.LINE_ITEM_NAME, A.LINE_ITEM_CATEGORY, A.LINE_ITEM_QUANTITY, A.LINE_ITEM_RATE,
            		A.LINE_ITEM_AMOUNT, A.LINE_ITEM_BILL_AMOUNT, A.DEFAULT_DISPLAY,
					DECODE(A.LINE_ITEM_TYPE, 'P', 'Payment', 'F', 'Finance Charge', 'A', 'Adjustment', 'B', 'Balance', 'M', 'Miscellaneous', 'X', 'Manual Line Item Tax') "LINE_ITEM_TYPE",
                    A.INVOICE_GROUP_ID, A.INVOICE_GROUP_ORDER, A.EXCLUDE_FROM_INVOICE_TOTAL,
                    A.IS_TAXED, A.TAX_COMPONENT_ID, A.TAX_GEOGRAPHY_ID,
                    1 "IS_MANUAL_LINE_ITEM", A.STATEMENT_TYPE, A.BEGIN_DATE, A.BEGIN_DATE "END_DATE"
			FROM INVOICE_USER_LINE_ITEM A
			WHERE A.ENTITY_ID = p_ENTITY_ID
				AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
                AND A.STATEMENT_STATE = p_STATEMENT_STATE
				AND A.BEGIN_DATE = v_INVOICE_DATE
				AND LINE_ITEM_NAME = p_LINE_ITEM_NAME) X;

END GET_INVOICE_LINE_ITEM;
---------------------------------------------------------------------------------------------------
PROCEDURE TRANSMISSION_CHARGE_DETAIL
	(
	p_WORK_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
    p_SHOW_BILL_AMOUNT IN NUMBER,
    p_SHOW_CHARGE_AMOUNT IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
		SELECT A.RESERVATION,
			A.TRANSACTION_ID,
			A.CHARGE_INTERVAL,
			FROM_CUT_AS_HED(A.CHARGE_DATE, p_TIME_ZONE, DECODE(TO_CHAR(A.CHARGE_DATE,'SS'),'01','DD','MI5'), GA.ELECTRIC_MODEL) "CHARGE_DATE",
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CAPACITY_RESERVED END "CAPACITY_RESERVED",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_CAPACITY_RESERVED END "BILL_CAPACITY_RESERVED",
			A.CHARGE_RATE,
			A.CHARGE_FACTOR,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_AMOUNT END "CHARGE_AMOUNT",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_AMOUNT END "BILL_AMOUNT",
			B.DISPUTE_STATUS
		FROM (SELECT B.TRANSACTION_NAME "RESERVATION",
				B.TRANSACTION_ID,
				B.CHARGE_INTERVAL,
				B.CHARGE_DATE,
				B.CAPACITY_RESERVED,
				B.BILL_CAPACITY_RESERVED,
				B.CHARGE_RATE,
				B.CHARGE_FACTOR,
				B.CHARGE_AMOUNT,
				B.BILL_AMOUNT,
				A.ENTITY_ID,
				A.STATEMENT_TYPE,
				A.STATEMENT_STATE,
                A.STATEMENT_DATE,
				A.PRODUCT_ID,
				A.COMPONENT_ID
			FROM BILLING_STATEMENT A,
				TRANSMISSION_CHARGE B,
				COMPONENT C,
				RTO_WORK X
			WHERE X.WORK_ID = p_WORK_ID
				AND B.CHARGE_ID = X.WORK_XID
				AND A.CHARGE_ID(+) = B.CHARGE_ID
				AND C.COMPONENT_ID = A.COMPONENT_ID) A,
			BILLING_CHARGE_DISPUTE B
		WHERE B.ENTITY_ID (+)= A.ENTITY_ID
			AND B.PRODUCT_ID (+)= A.PRODUCT_ID
			AND B.COMPONENT_ID (+)= A.COMPONENT_ID
			AND B.STATEMENT_TYPE (+)= A.STATEMENT_TYPE
			AND B.STATEMENT_STATE (+)= A.STATEMENT_STATE
            AND B.STATEMENT_DATE (+)= A.STATEMENT_DATE
			AND B.DISPUTE_DATE (+)= A.CHARGE_DATE
		ORDER BY A.CHARGE_DATE, A.RESERVATION;

END TRANSMISSION_CHARGE_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE ENTITY_ATTRIBUTE_CHARGE_DETAIL
    (
	p_WORK_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
    p_SHOW_BILL_AMOUNT IN NUMBER,
    p_SHOW_CHARGE_AMOUNT IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
		SELECT A.FACILITY,
			FROM_CUT_AS_HED(A.CHARGE_DATE, p_TIME_ZONE, DECODE(TO_CHAR(A.CHARGE_DATE,'SS'),'01','DD','MI5'), GA.ELECTRIC_MODEL) "CHARGE_DATE",
			FROM_CUT_AS_HED(A.PEAK_DATE, p_TIME_ZONE, 'MI5') "PEAK_DATE",
			A.PEAK_QUANTITY,
			A.CHARGE_RATE,
			A.CHARGE_FACTOR,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_AMOUNT END "CHARGE_AMOUNT",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_AMOUNT END "BILL_AMOUNT",
			B.DISPUTE_STATUS
		FROM (SELECT D.ACCOUNT_NAME "FACILITY",
				C.CHARGE_DATE,
				C.PEAK_DATE,
				C.PEAK_QUANTITY,
				C.CHARGE_RATE,
				C.CHARGE_FACTOR,
				C.CHARGE_AMOUNT,
				C.BILL_AMOUNT,
				A.ENTITY_ID,
				A.STATEMENT_TYPE,
				A.STATEMENT_STATE,
                A.STATEMENT_DATE,
				A.PRODUCT_ID,
				A.COMPONENT_ID
			FROM BILLING_STATEMENT A,
				COMPONENT_ENTITY_ATTRIBUTE B,
				ENTITY_ATTRIBUTE_CHARGE C,
				ACCOUNT D,
				RTO_WORK X
			WHERE X.WORK_ID = p_WORK_ID
				AND C.CHARGE_ID = X.WORK_XID
				AND A.CHARGE_ID(+) = C.CHARGE_ID
				AND C.ENTITY_DOMAIN_ID = B.ENTITY_DOMAIN_ID
				AND C.ATTRIBUTE_ID = B.ENTITY_ATTRIBUTE_ID
				AND D.ACCOUNT_ID = C.ENTITY_ID) A,
			BILLING_CHARGE_DISPUTE B
		WHERE B.ENTITY_ID (+)= A.ENTITY_ID
			AND B.PRODUCT_ID (+)= A.PRODUCT_ID
			AND B.COMPONENT_ID (+)= A.COMPONENT_ID
			AND B.STATEMENT_TYPE (+)= A.STATEMENT_TYPE
			AND B.STATEMENT_STATE (+)= A.STATEMENT_STATE
            AND B.STATEMENT_DATE (+)= A.STATEMENT_DATE
			AND B.DISPUTE_DATE (+)= A.CHARGE_DATE
		ORDER BY 1,2;

END ENTITY_ATTRIBUTE_CHARGE_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE BILLING_CHARGE_DETAIL
    (
	p_WORK_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
    p_SHOW_BILL_AMOUNT IN NUMBER,
    p_SHOW_CHARGE_AMOUNT IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(A.CHARGE_DATE, p_TIME_ZONE, DECODE(TO_CHAR(A.CHARGE_DATE,'SS'),'01','DD','MI5'), GA.ELECTRIC_MODEL) "CHARGE_DATE",
			A.SERVICE_POINT,
			FROM_CUT_AS_HED(A.PEAK_DATE, p_TIME_ZONE, 'MI5') "PEAK_DATE",
			A.PEAK_QUANTITY,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_QUANTITY END "CHARGE_QUANTITY",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_QUANTITY END "BILL_QUANTITY",
			A.CHARGE_RATE,
			A.CHARGE_FACTOR,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_AMOUNT END "CHARGE_AMOUNT",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_AMOUNT END "BILL_AMOUNT",
			B.DISPUTE_STATUS
		FROM (SELECT B.CHARGE_DATE,
				SERVICE_POINT_NAME "SERVICE_POINT",
				B.PEAK_DATE,
				PEAK_QUANTITY,
				B.CHARGE_QUANTITY,
				B.BILL_QUANTITY,
				B.CHARGE_RATE,
				B.CHARGE_FACTOR,
				B.CHARGE_AMOUNT,
				B.BILL_AMOUNT,
				A.ENTITY_ID,
				A.STATEMENT_TYPE,
				A.STATEMENT_STATE,
                A.STATEMENT_DATE,
				A.PRODUCT_ID,
				A.COMPONENT_ID
			FROM BILLING_STATEMENT A,
				BILLING_CHARGE B,
				SERVICE_POINT C,
				RTO_WORK X
			WHERE X.WORK_ID = p_WORK_ID
				AND B.CHARGE_ID = X.WORK_XID
				AND A.CHARGE_ID(+) = B.CHARGE_ID
				AND C.SERVICE_POINT_ID = NVL(B.SERVICE_POINT_ID,0)) A,
			BILLING_CHARGE_DISPUTE B
		WHERE B.ENTITY_ID (+)= A.ENTITY_ID
			AND B.PRODUCT_ID (+)= A.PRODUCT_ID
			AND B.COMPONENT_ID (+)= A.COMPONENT_ID
			AND B.STATEMENT_TYPE (+)= A.STATEMENT_TYPE
			AND B.STATEMENT_STATE (+)= A.STATEMENT_STATE
            AND B.STATEMENT_DATE (+)= A.STATEMENT_DATE
			AND B.DISPUTE_DATE (+)= A.CHARGE_DATE
		ORDER BY 1;

END BILLING_CHARGE_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE IMBALANCE_CHARGE_DETAIL
	(
	p_WORK_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
    p_SHOW_BILL_AMOUNT IN NUMBER,
    p_SHOW_CHARGE_AMOUNT IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(A.CHARGE_DATE, p_TIME_ZONE, DECODE(TO_CHAR(A.CHARGE_DATE,'SS'),'01','DD','MI5'), GA.ELECTRIC_MODEL) "CHARGE_DATE",
			A.NET_SYSTEM_IMBALANCE,
			A.BILL_NET_SYSTEM_IMBALANCE,
			A.DEMAND,
			A.SUPPLY,
			A.DIFFERENCE,
			A.BAND_NUMBER,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.BAND_QUANTITY END "BAND_QUANTITY",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_BAND_QUANTITY END "BILL_BAND_QUANTITY",
			A.BAND_RATE,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.BAND_AMOUNT END "BAND_AMOUNT",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_BAND_AMOUNT END "BILL_BAND_AMOUNT",
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.TOTAL_AMOUNT END "CHARGE_AMOUNT",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_TOTAL_AMOUNT END "BILL_AMOUNT",
			B.DISPUTE_STATUS
		FROM (SELECT B.CHARGE_DATE,
				B.NET_SYSTEM_IMBALANCE,
				B.BILL_NET_SYSTEM_IMBALANCE,
				B.DEMAND,
				B.SUPPLY,
				(B.SUPPLY - B.DEMAND) "DIFFERENCE",
				C.BAND_NUMBER,
				C.ENERGY_IMBALANCE_QUANTITY "BAND_QUANTITY",
				C.BILL_ENERGY_IMBALANCE_QUANTITY "BILL_BAND_QUANTITY",
				C.ENERGY_IMBALANCE_RATE "BAND_RATE",
				C.ENERGY_IMBALANCE_AMOUNT "BAND_AMOUNT",
				C.BILL_ENERGY_IMBALANCE_AMOUNT "BILL_BAND_AMOUNT",
				B.ENERGY_IMBALANCE_AMOUNT "TOTAL_AMOUNT",
				B.BILL_ENERGY_IMBALANCE_AMOUNT "BILL_TOTAL_AMOUNT",
				A.ENTITY_ID,
				A.STATEMENT_TYPE,
				A.STATEMENT_STATE,
                A.STATEMENT_DATE,
				A.PRODUCT_ID,
				A.COMPONENT_ID
			FROM BILLING_STATEMENT A, IMBALANCE_CHARGE B, IMBALANCE_CHARGE_BAND C, RTO_WORK X
			WHERE X.WORK_ID = p_WORK_ID
				AND B.CHARGE_ID = X.WORK_XID
				AND A.CHARGE_ID(+) = B.CHARGE_ID
				AND C.CHARGE_ID(+) = B.CHARGE_ID
				AND C.CHARGE_DATE(+) = B.CHARGE_DATE) A,
			BILLING_CHARGE_DISPUTE B
		WHERE B.ENTITY_ID (+)= A.ENTITY_ID
			AND B.PRODUCT_ID (+)= A.PRODUCT_ID
			AND B.COMPONENT_ID (+)= A.COMPONENT_ID
			AND B.STATEMENT_TYPE (+)= A.STATEMENT_TYPE
			AND B.STATEMENT_STATE (+)= A.STATEMENT_STATE
            AND B.STATEMENT_DATE (+)= A.STATEMENT_DATE
			AND B.DISPUTE_DATE (+)= A.CHARGE_DATE
		ORDER BY A.CHARGE_DATE;

END IMBALANCE_CHARGE_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE OPER_PROFIT_CHARGE_DETAIL
    (
	p_WORK_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
    p_SHOW_BILL_AMOUNT IN NUMBER,
    p_SHOW_CHARGE_AMOUNT IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(A.CHARGE_DATE, p_TIME_ZONE, DECODE(TO_CHAR(A.CHARGE_DATE,'SS'),'01','DD','MI5'), GA.ELECTRIC_MODEL) "CHARGE_DATE",
			A.SERVICE_POINT_NAME,
			A.MARKET_QUANTITY,
			A.MARKET_OPER_PROFIT,
			A.DISPATCH_QUANTITY,
			A.DISPATCH_OPER_PROFIT,
			A.ACTUAL_QUANTITY,
			A.ACTUAL_OPER_PROFIT,
			A.CHARGE_RATE,
			A.CHARGE_FACTOR,
			A.SET_NUMBER,
			A.SET_QUANTITY,
			A.SET_PRICE,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_AMOUNT END "CHARGE_AMOUNT",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_AMOUNT END "BILL_AMOUNT",
			B.DISPUTE_STATUS
		FROM (SELECT B.CHARGE_DATE,
				D.SERVICE_POINT_NAME,
				B.MARKET_QUANTITY,
				B.MARKET_OPER_PROFIT,
				B.DISPATCH_QUANTITY,
				B.DISPATCH_OPER_PROFIT,
				B.ACTUAL_QUANTITY,
				B.ACTUAL_OPER_PROFIT,
				B.CHARGE_RATE,
				B.CHARGE_FACTOR,
				C.SET_NUMBER,
				C.QUANTITY "SET_QUANTITY",
				C.PRICE "SET_PRICE",
				B.CHARGE_AMOUNT,
				B.BILL_AMOUNT,
				A.ENTITY_ID,
				A.STATEMENT_TYPE,
				A.STATEMENT_STATE,
                A.STATEMENT_DATE,
				A.PRODUCT_ID,
				A.COMPONENT_ID
			FROM BILLING_STATEMENT A, OPER_PROFIT_CHARGE B, OPER_PROFIT_CHARGE_SET C, SERVICE_POINT D, RTO_WORK X
			WHERE X.WORK_ID = p_WORK_ID
				AND B.CHARGE_ID = X.WORK_XID
				AND A.CHARGE_ID(+) = B.CHARGE_ID
				AND C.CHARGE_ID(+) = B.CHARGE_ID
				AND C.CHARGE_DATE(+) = B.CHARGE_DATE
                AND D.SERVICE_POINT_ID = NVL(B.SERVICE_POINT_ID,0)) A,
			BILLING_CHARGE_DISPUTE B
		WHERE B.ENTITY_ID (+)= A.ENTITY_ID
			AND B.PRODUCT_ID (+)= A.PRODUCT_ID
			AND B.COMPONENT_ID (+)= A.COMPONENT_ID
			AND B.STATEMENT_TYPE (+)= A.STATEMENT_TYPE
			AND B.STATEMENT_STATE (+)= A.STATEMENT_STATE
            AND B.STATEMENT_DATE (+)= A.STATEMENT_DATE
			AND B.DISPUTE_DATE (+)= A.CHARGE_DATE
		ORDER BY A.CHARGE_DATE;

END OPER_PROFIT_CHARGE_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNT_SERVICE_CHARGE_DETAIL
	(
	p_WORK_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
    p_SHOW_BILL_AMOUNT IN NUMBER,
    p_SHOW_CHARGE_AMOUNT IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
		SELECT A.ACCOUNT,
			A.SERVICE_LOCATION,
			A.METER,
			A.CHARGE_BEGIN_DATE,
			A.CHARGE_END_DATE,
			A.BILL_CODE,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_QUANTITY END "CHARGE_QUANTITY",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_QUANTITY END "BILL_QUANTITY",
			A.CHARGE_RATE,
			A.CHARGE_FACTOR,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_AMOUNT END "CHARGE_AMOUNT",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_AMOUNT END "BILL_AMOUNT",
			B.DISPUTE_STATUS
		FROM (SELECT D.ACCOUNT_DISPLAY_NAME "ACCOUNT",
				E.SERVICE_LOCATION_NAME "SERVICE_LOCATION",
				F.METER_NAME "METER",
				A.CHARGE_BEGIN_DATE,
				A.CHARGE_END_DATE,
				DECODE(A.BILL_CODE,'B','Bill','C','Cancel','R','Rebill','T','Total') "BILL_CODE",
				A.CHARGE_QUANTITY,
				A.BILL_QUANTITY,
				A.CHARGE_RATE,
				A.CHARGE_FACTOR,
				A.CHARGE_AMOUNT,
				A.BILL_AMOUNT,
				C.ENTITY_ID,
				C.STATEMENT_TYPE,
				C.STATEMENT_STATE,
                C.STATEMENT_DATE,
				C.PRODUCT_ID,
				C.COMPONENT_ID
			FROM ACCOUNT_SERVICE_CHARGE A, ACCOUNT_SERVICE B, BILLING_STATEMENT C, ACCOUNT D, SERVICE_LOCATION E, METER F, RTO_WORK X
			WHERE X.WORK_ID = p_WORK_ID
				AND A.CHARGE_ID = X.WORK_XID
				AND C.CHARGE_ID(+) = A.CHARGE_ID
				AND A.BAND_NUMBER = CONSTANTS.NOT_ASSIGNED
				AND B.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
				AND B.ACCOUNT_ID = D.ACCOUNT_ID
				AND B.SERVICE_LOCATION_ID = E.SERVICE_LOCATION_ID
				AND B.METER_ID = F.METER_ID) A,
			BILLING_CHARGE_DISPUTE B
		WHERE B.ENTITY_ID (+)= A.ENTITY_ID
			AND B.PRODUCT_ID (+)= A.PRODUCT_ID
			AND B.COMPONENT_ID (+)= A.COMPONENT_ID
			AND B.STATEMENT_TYPE (+)= A.STATEMENT_TYPE
			AND B.STATEMENT_STATE (+)= A.STATEMENT_STATE
            AND B.STATEMENT_DATE (+)= A.STATEMENT_DATE
			AND B.DISPUTE_DATE (+)= A.CHARGE_BEGIN_DATE
		ORDER BY 1,2,3,4,5,6;

END ACCOUNT_SERVICE_CHARGE_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE CONVERSION_CHARGE_DETAIL
	(
	p_WORK_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
    p_SHOW_BILL_AMOUNT IN NUMBER,
    p_SHOW_CHARGE_AMOUNT IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
		SELECT A.SCHEDULE_GROUP,
			FROM_CUT_AS_HED(A.CHARGE_DATE, p_TIME_ZONE, DECODE(TO_CHAR(A.CHARGE_DATE,'SS'),'01','DD','MI5'), GA.ELECTRIC_MODEL) "CHARGE_DATE",
			FROM_CUT_AS_HED(A.PEAK_DATE, p_TIME_ZONE, 'MI5', GA.ELECTRIC_MODEL) "PEAK_DATE",
			A.PEAK_DEMAND,
			A.SCHEDULED_AMOUNT,
			A.CONVERSION_FORMULA,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_QUANTITY END "CHARGE_QUANTITY",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_QUANTITY END "BILL_QUANTITY",
			A.CHARGE_RATE,
			A.CHARGE_FACTOR,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_AMOUNT END "CHARGE_AMOUNT",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_AMOUNT END "BILL_AMOUNT",
			B.DISPUTE_STATUS
		FROM (SELECT D.SCHEDULE_GROUP_NAME "SCHEDULE_GROUP",
				B.CHARGE_DATE,
				B.PEAK_DATE,
				B.PEAK_DEMAND,
				B.SCHEDULED_AMOUNT,
				NVL(B.COEFF_X3,0)||'*x^3 + '||NVL(B.COEFF_X2,0)||'*x^2 + '||NVL(B.COEFF_X1,0)||'*x + '||NVL(CONST_K,0) "CONVERSION_FORMULA",
				B.CHARGE_QUANTITY,
				B.CHARGE_RATE,
				B.CHARGE_FACTOR,
				B.CHARGE_AMOUNT,
				B.BILL_QUANTITY,
				B.BILL_AMOUNT,
				A.ENTITY_ID,
				A.STATEMENT_TYPE,
				A.STATEMENT_STATE,
                A.STATEMENT_DATE,
				A.PRODUCT_ID,
				A.COMPONENT_ID
			FROM BILLING_STATEMENT A, CONVERSION_CHARGE B, COMPONENT C, SCHEDULE_GROUP D, RTO_WORK X
			WHERE X.WORK_ID = p_WORK_ID
				AND B.CHARGE_ID = X.WORK_XID
				AND A.CHARGE_ID(+) = B.CHARGE_ID
				AND C.COMPONENT_ID = A.COMPONENT_ID
				AND D.SCHEDULE_GROUP_ID = B.SCHEDULE_GROUP_ID) A,
			BILLING_CHARGE_DISPUTE B
		WHERE B.ENTITY_ID (+)= A.ENTITY_ID
			AND B.PRODUCT_ID (+)= A.PRODUCT_ID
			AND B.COMPONENT_ID (+)= A.COMPONENT_ID
			AND B.STATEMENT_TYPE (+)= A.STATEMENT_TYPE
			AND B.STATEMENT_STATE (+)= A.STATEMENT_STATE
            AND B.STATEMENT_DATE (+)= A.STATEMENT_DATE
			AND B.DISPUTE_DATE (+)= A.CHARGE_DATE
		ORDER BY A.SCHEDULE_GROUP, A.CHARGE_DATE;

END CONVERSION_CHARGE_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE LMP_CHARGE_DETAIL
    (
	p_WORK_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
    p_SHOW_BILL_AMOUNT IN NUMBER,
    p_SHOW_CHARGE_AMOUNT IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
		SELECT A.SOURCE_NAME,
			A.SOURCE_ID,
            A.DELIVERY_POINT_NAME,
            A.DELIVERY_POINT_ID,
            A.SINK_NAME,
            A.SINK_ID,
            FROM_CUT_AS_HED(A.CHARGE_DATE, p_TIME_ZONE, DECODE(TO_CHAR(A.CHARGE_DATE,'SS'),'01','DD','MI5'), GA.ELECTRIC_MODEL) "CHARGE_DATE",
            A.DA_PURCHASES,
            A.RT_PURCHASES,
            A.DA_SALES,
            A.RT_SALES,
            A.DA_LOAD,
            A.RT_LOAD,
            A.DA_GENERATION,
            A.RT_GENERATION,
            A.PRICE1,
            A.PRICE2,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_QUANTITY END "CHARGE_QUANTITY",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_QUANTITY END "BILL_QUANTITY",
			A.CHARGE_RATE,
			A.CHARGE_FACTOR,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_AMOUNT END "CHARGE_AMOUNT",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_AMOUNT END "BILL_AMOUNT",
			B.DISPUTE_STATUS
		FROM (SELECT B.CHARGE_DATE,
        		B.SOURCE_ID,
                C.SERVICE_POINT_NAME "SOURCE_NAME",
        		B.DELIVERY_POINT_ID,
                D.SERVICE_POINT_NAME "DELIVERY_POINT_NAME",
        		B.SINK_ID,
                E.SERVICE_POINT_NAME "SINK_NAME",
                B.DA_PURCHASES,
                B.RT_PURCHASES,
                B.DA_SALES,
                B.RT_SALES,
                B.DA_LOAD,
                B.RT_LOAD,
                B.DA_GENERATION,
                B.RT_GENERATION,
                B.PRICE1,
                B.PRICE2,
				B.CHARGE_QUANTITY,
				B.BILL_QUANTITY,
				B.CHARGE_RATE,
				B.CHARGE_FACTOR,
				B.CHARGE_AMOUNT,
				B.BILL_AMOUNT,
				A.ENTITY_ID,
				A.STATEMENT_TYPE,
				A.STATEMENT_STATE,
                A.STATEMENT_DATE,
				A.PRODUCT_ID,
				A.COMPONENT_ID
			FROM BILLING_STATEMENT A,
				LMP_CHARGE B,
				SERVICE_POINT C,
				SERVICE_POINT D,
				SERVICE_POINT E,
				RTO_WORK X
			WHERE X.WORK_ID = p_WORK_ID
				AND B.CHARGE_ID = X.WORK_XID
				AND A.CHARGE_ID(+) = B.CHARGE_ID
				AND C.SERVICE_POINT_ID = NVL(B.SOURCE_ID,0)
				AND D.SERVICE_POINT_ID = NVL(B.DELIVERY_POINT_ID,0)
				AND E.SERVICE_POINT_ID = NVL(B.SINK_ID,0)) A,
			BILLING_CHARGE_DISPUTE B
		WHERE B.ENTITY_ID (+)= A.ENTITY_ID
			AND B.PRODUCT_ID (+)= A.PRODUCT_ID
			AND B.COMPONENT_ID (+)= A.COMPONENT_ID
			AND B.STATEMENT_TYPE (+)= A.STATEMENT_TYPE
			AND B.STATEMENT_STATE (+)= A.STATEMENT_STATE
            AND B.STATEMENT_DATE (+)= A.STATEMENT_DATE
			AND B.DISPUTE_DATE (+)= A.CHARGE_DATE
		ORDER BY A.CHARGE_DATE, A.SOURCE_NAME, A.DELIVERY_POINT_NAME, A.SINK_NAME;

END LMP_CHARGE_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE FTR_CHARGE_DETAIL
    (
	p_WORK_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
    p_SHOW_BILL_AMOUNT IN NUMBER,
    p_SHOW_CHARGE_AMOUNT IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN
	OPEN p_CURSOR FOR
		SELECT A.SOURCE_NAME,
			A.SOURCE_ID,
            A.DELIVERY_POINT_NAME,
            A.DELIVERY_POINT_ID,
            A.SINK_NAME,
            A.SINK_ID,
            A.FTR_TYPE,
            FROM_CUT_AS_HED(A.CHARGE_DATE, p_TIME_ZONE, DECODE(TO_CHAR(A.CHARGE_DATE,'SS'),'01','DD','MI5'), GA.ELECTRIC_MODEL) "CHARGE_DATE",
            A.ALLOC_FACTOR,
            A.PURCHASES,
            A.SALES,
            A.PRICE1,
            A.PRICE2,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_QUANTITY END "CHARGE_QUANTITY",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_QUANTITY END "BILL_QUANTITY",
			A.CHARGE_RATE,
			A.CHARGE_FACTOR,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_AMOUNT END "CHARGE_AMOUNT",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_AMOUNT END "BILL_AMOUNT",
			B.DISPUTE_STATUS
		FROM (SELECT B.CHARGE_DATE,
        		B.SOURCE_ID,
                C.SERVICE_POINT_NAME "SOURCE_NAME",
        		B.DELIVERY_POINT_ID,
                D.SERVICE_POINT_NAME "DELIVERY_POINT_NAME",
        		B.SINK_ID,
                E.SERVICE_POINT_NAME "SINK_NAME",
                B.FTR_TYPE,
                B.ALLOC_FACTOR,
                B.PURCHASES,
                B.SALES,
                B.PRICE1,
                B.PRICE2,
				B.CHARGE_QUANTITY,
				B.BILL_QUANTITY,
				B.CHARGE_RATE,
				B.CHARGE_FACTOR,
				B.CHARGE_AMOUNT,
				B.BILL_AMOUNT,
				A.ENTITY_ID,
				A.STATEMENT_TYPE,
				A.STATEMENT_STATE,
                A.STATEMENT_DATE,
				A.PRODUCT_ID,
				A.COMPONENT_ID
			FROM BILLING_STATEMENT A,
				FTR_CHARGE B,
				SERVICE_POINT C,
				SERVICE_POINT D,
				SERVICE_POINT E,
				RTO_WORK X
			WHERE X.WORK_ID = p_WORK_ID
				AND B.CHARGE_ID = X.WORK_XID
				AND A.CHARGE_ID(+) = B.CHARGE_ID
				AND C.SERVICE_POINT_ID = NVL(B.SOURCE_ID,0)
				AND D.SERVICE_POINT_ID = NVL(B.DELIVERY_POINT_ID,0)
				AND E.SERVICE_POINT_ID = NVL(B.SINK_ID,0)) A,
			BILLING_CHARGE_DISPUTE B
		WHERE B.ENTITY_ID (+)= A.ENTITY_ID
			AND B.PRODUCT_ID (+)= A.PRODUCT_ID
			AND B.COMPONENT_ID (+)= A.COMPONENT_ID
			AND B.STATEMENT_TYPE (+)= A.STATEMENT_TYPE
			AND B.STATEMENT_STATE (+)= A.STATEMENT_STATE
            AND B.STATEMENT_DATE (+)= A.STATEMENT_DATE
			AND B.DISPUTE_DATE (+)= A.CHARGE_DATE
		ORDER BY A.CHARGE_DATE, A.FTR_TYPE, A.SOURCE_NAME, A.DELIVERY_POINT_NAME, A.SINK_NAME;

END FTR_CHARGE_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE COMBINATION_CHARGE_DETAIL
    (
	p_WORK_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
    p_SHOW_BILL_AMOUNT IN NUMBER,
    p_SHOW_CHARGE_AMOUNT IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(A.CHARGE_DATE, p_TIME_ZONE, 'DD') "CHARGE_DATE",
			FROM_CUT_AS_HED(A.CHARGE_END_DATE, p_TIME_ZONE, 'DD') "CHARGE_END_DATE",
			A.COMBINED_COMPONENT_ID "COMPONENT_ID",
			A.CHARGE_ID,
            A.COMBINED_CHARGE_ID,
            A.CHARGE_VIEW_TYPE CHARGE_VIEW_TYPE_COMB,
			A.COMPONENT_NAME,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_QUANTITY END "CHARGE_QUANTITY",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_QUANTITY END "BILL_QUANTITY",
			A.CHARGE_RATE,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.COMPONENT_AMOUNT END "COMPONENT_AMOUNT",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_COMPONENT_AMOUNT END "BILL_COMPONENT_AMOUNT",
            A.COEFFICIENT,
			A.CHARGE_FACTOR,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_AMOUNT END "CHARGE_AMOUNT",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_AMOUNT END "BILL_AMOUNT",
			B.DISPUTE_STATUS
		FROM (SELECT B.CHARGE_ID,
				B.BEGIN_DATE+1/86400 "CHARGE_DATE",
				B.END_DATE+1/86400 "CHARGE_END_DATE",
				B.COMPONENT_ID "COMBINED_COMPONENT_ID",
				B.COMBINED_CHARGE_ID,
				B.CHARGE_VIEW_TYPE,
				COMPONENT_NAME,
				B.CHARGE_QUANTITY,
				B.BILL_QUANTITY,
				B.CHARGE_RATE,
				B.COMPONENT_AMOUNT,
				B.BILL_COMPONENT_AMOUNT,
				B.COEFFICIENT,
				B.CHARGE_FACTOR,
				B.CHARGE_AMOUNT,
				B.BILL_AMOUNT,
				A.ENTITY_ID,
				A.STATEMENT_TYPE,
				A.STATEMENT_STATE,
                A.STATEMENT_DATE,
				A.PRODUCT_ID,
				A.COMPONENT_ID
			FROM BILLING_STATEMENT A,
				COMBINATION_CHARGE B,
				COMPONENT C,
				RTO_WORK X
			WHERE X.WORK_ID = p_WORK_ID
				AND B.CHARGE_ID = X.WORK_XID
				AND A.CHARGE_ID(+) = B.CHARGE_ID
				AND C.COMPONENT_ID(+) = NVL(B.COMPONENT_ID,0)) A,
			BILLING_CHARGE_DISPUTE B
		WHERE B.ENTITY_ID (+)= A.ENTITY_ID
			AND B.PRODUCT_ID (+)= A.PRODUCT_ID
			AND B.COMPONENT_ID (+)= A.COMPONENT_ID
			AND B.STATEMENT_TYPE (+)= A.STATEMENT_TYPE
			AND B.STATEMENT_STATE (+)= A.STATEMENT_STATE
            AND B.STATEMENT_DATE (+)= A.STATEMENT_DATE
			AND B.DISPUTE_DATE (+)= A.CHARGE_DATE
		ORDER BY 1, 2, 7;

END COMBINATION_CHARGE_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE TAX_CHARGE_DETAIL
    (
	p_WORK_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
    p_SHOW_BILL_AMOUNT IN NUMBER,
    p_SHOW_CHARGE_AMOUNT IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN
	OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(A.CHARGE_DATE, p_TIME_ZONE, DECODE(TO_CHAR(A.CHARGE_DATE,'SS'),'01','DD','MI5'), GA.ELECTRIC_MODEL) "CHARGE_DATE",
			A.TAX_AREA_TYPE,
			A.TAX_AREA_NAME,
			A.PRODUCT_ID,
			A.PRODUCT_NAME,
			A.COMPONENT_ID,
			A.COMPONENT_NAME,
			A.SERVICE_POINT_NAME,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_QUANTITY END "CHARGE_QUANTITY",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_QUANTITY END "BILL_QUANTITY",
			A.CHARGE_RATE,
			A.CHARGE_FACTOR,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_AMOUNT END "CHARGE_AMOUNT",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_AMOUNT END "BILL_AMOUNT",
			B.DISPUTE_STATUS
		FROM (SELECT B.CHARGE_DATE,
				F.GEOGRAPHY_TYPE "TAX_AREA_TYPE",
				NVL(F.DISPLAY_NAME,F.GEOGRAPHY_NAME) "TAX_AREA_NAME",
				B.PRODUCT_ID,
				C.PRODUCT_NAME,
				B.COMPONENT_ID,
				D.COMPONENT_NAME,
				E.SERVICE_POINT_NAME,
				B.CHARGE_QUANTITY,
				B.BILL_QUANTITY,
				B.CHARGE_RATE,
				B.CHARGE_FACTOR,
				B.CHARGE_AMOUNT,
				B.BILL_AMOUNT,
				A.ENTITY_ID,
				A.STATEMENT_TYPE,
				A.STATEMENT_STATE,
                A.STATEMENT_DATE,
				A.PRODUCT_ID "BS_PRODUCT_ID",
				A.COMPONENT_ID "BS_COMPONENT_ID"
			FROM BILLING_STATEMENT A, TAX_CHARGE B, PRODUCT C, COMPONENT D, SERVICE_POINT E, GEOGRAPHY F, RTO_WORK X
			WHERE X.WORK_ID = p_WORK_ID
				AND B.CHARGE_ID = X.WORK_XID
				AND A.CHARGE_ID(+) = B.CHARGE_ID
				AND C.PRODUCT_ID = B.PRODUCT_ID
				AND D.COMPONENT_ID = B.COMPONENT_ID
				AND E.SERVICE_POINT_ID = NVL(B.SERVICE_POINT_ID,0)
                AND F.GEOGRAPHY_ID = B.GEOGRAPHY_ID) A,
			BILLING_CHARGE_DISPUTE B
		WHERE B.ENTITY_ID (+)= A.ENTITY_ID
			AND B.PRODUCT_ID (+)= A.BS_PRODUCT_ID
			AND B.COMPONENT_ID (+)= A.BS_COMPONENT_ID
			AND B.STATEMENT_TYPE (+)= A.STATEMENT_TYPE
			AND B.STATEMENT_STATE (+)= A.STATEMENT_STATE
            AND B.STATEMENT_DATE (+)= A.STATEMENT_DATE
			AND B.DISPUTE_DATE (+)= A.CHARGE_DATE
		ORDER BY A.CHARGE_DATE, A.TAX_AREA_TYPE, A.PRODUCT_NAME, A.COMPONENT_NAME;

END TAX_CHARGE_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE PIPELINE_CHARGE_DETAIL
    (
	p_WORK_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
    p_SHOW_BILL_AMOUNT IN NUMBER,
    p_SHOW_CHARGE_AMOUNT IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(A.CHARGE_DATE, p_TIME_ZONE, DECODE(TO_CHAR(A.CHARGE_DATE,'SS'),'01','DD','MI5'), GA.ELECTRIC_MODEL) "CHARGE_DATE",
			A.DELIVERY_ID,
			A.DELIVERY_NAME,
			A.SEGMENT_NUMBER,
			A.POR_ID,
			A.POR_NAME,
			A.POD_ID,
			A.POD_NAME,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_QUANTITY END "CHARGE_QUANTITY",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_QUANTITY END "BILL_QUANTITY",
			A.CHARGE_RATE,
			A.CHARGE_FACTOR,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_AMOUNT END "CHARGE_AMOUNT",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_AMOUNT END "BILL_AMOUNT",
			B.DISPUTE_STATUS
		FROM (SELECT B.CHARGE_DATE,
				B.DELIVERY_ID,
				IT.TRANSACTION_NAME "DELIVERY_NAME",
				B.SEGMENT_NUMBER,
				B.POR_ID,
				POR.SERVICE_POINT_NAME "POR_NAME",
				B.POD_ID,
				POD.SERVICE_POINT_NAME "POD_NAME",
				B.CHARGE_QUANTITY,
				B.BILL_QUANTITY,
				B.CHARGE_RATE,
				B.CHARGE_FACTOR,
				B.CHARGE_AMOUNT,
				B.BILL_AMOUNT,
				A.ENTITY_ID,
				A.STATEMENT_TYPE,
				A.STATEMENT_STATE,
                A.STATEMENT_DATE,
				A.PRODUCT_ID "PRODUCT_ID",
				A.COMPONENT_ID "COMPONENT_ID"
			FROM BILLING_STATEMENT A, PIPELINE_CHARGE B,
				INTERCHANGE_TRANSACTION IT,
				SERVICE_POINT POR, SERVICE_POINT POD,
				RTO_WORK X
			WHERE X.WORK_ID = p_WORK_ID
				AND B.CHARGE_ID = X.WORK_XID
				AND A.CHARGE_ID(+) = B.CHARGE_ID
				AND IT.TRANSACTION_ID = B.DELIVERY_ID
				AND POR.SERVICE_POINT_ID = B.POR_ID
				AND POD.SERVICE_POINT_ID = B.POD_ID) A,
			BILLING_CHARGE_DISPUTE B
		WHERE B.ENTITY_ID (+)= A.ENTITY_ID
			AND B.PRODUCT_ID (+)= A.PRODUCT_ID
			AND B.COMPONENT_ID (+)= A.COMPONENT_ID
			AND B.STATEMENT_TYPE (+)= A.STATEMENT_TYPE
			AND B.STATEMENT_STATE (+)= A.STATEMENT_STATE
            AND B.STATEMENT_DATE (+)= A.STATEMENT_DATE
			AND B.DISPUTE_DATE (+)= A.CHARGE_DATE
		ORDER BY A.CHARGE_DATE, A.DELIVERY_NAME, A.SEGMENT_NUMBER, A.POR_NAME, A.POD_NAME;

END PIPELINE_CHARGE_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE FORMULA_CHARGE_DETAIL
    (
	p_WORK_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
    p_SHOW_BILL_AMOUNT IN NUMBER,
    p_SHOW_CHARGE_AMOUNT IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	CALC_ENGINE_UI.FORMULA_CHARGE_DETAIL(p_WORK_ID,p_SHOW_BILL_AMOUNT,p_SHOW_CHARGE_AMOUNT);

	OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(RECORD_DATE, p_TIME_ZONE, DECODE(TO_CHAR(RECORD_DATE,'SS'),'01','DD','MI5'), GA.ELECTRIC_MODEL) as CHARGE_DATE,
			ITERATOR1_NAME, ITERATOR1_VAL ITERATOR1, ITERATOR2_NAME, ITERATOR2_VAL ITERATOR2,
			ITERATOR3_NAME, ITERATOR3_VAL ITERATOR3, ITERATOR4_NAME, ITERATOR4_VAL ITERATOR4,
			ITERATOR5_NAME, ITERATOR5_VAL ITERATOR5, ITERATOR6_NAME, ITERATOR6_VAL ITERATOR6,
			ITERATOR7_NAME, ITERATOR7_VAL ITERATOR7, ITERATOR8_NAME, ITERATOR8_VAL ITERATOR8,
			ITERATOR9_NAME, ITERATOR9_VAL ITERATOR9, ITERATOR10_NAME, ITERATOR10_VAL ITERATOR10,
			VARIABLE_NAME, VARIABLE_VALUE,
			CALC_ORDER, VIEW_ORDER,
			CHARGE_QUANTITY, BILL_QUANTITY,
			CHARGE_RATE, CHARGE_FACTOR,
			CHARGE_AMOUNT, BILL_AMOUNT,
			DISPUTE_STATUS
		FROM FORMULA_CHARGE_DRILL_DOWN_TEMP;

	DELETE FROM FORMULA_CHARGE_DRILL_DOWN_TEMP;

EXCEPTION
	WHEN OTHERS THEN
		DELETE FROM FORMULA_CHARGE_DRILL_DOWN_TEMP;
		ERRS.LOG_AND_RAISE;
END FORMULA_CHARGE_DETAIL;
---------------------------------------------------------------------------------------------------
FUNCTION GET_COMBINED_CHARGE_ID
	(
	p_CHARGE_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_AS_OF_DATE IN DATE
	) RETURN NUMBER IS
v_CHARGE_ID NUMBER := p_CHARGE_ID;
v_COMPONENT_ID NUMBER;
v_BEGIN_DATE DATE;
v_BILLING_STATEMENT BILLING_STATEMENT%ROWTYPE;
BEGIN
	-- make sure v_CHARGE_ID has correct charge ID - sor correct it to make
	-- sure it corresponds to a charge w/ same STATEMENT_TYPE and STATEMENT_STATE
	BEGIN
        SELECT * INTO v_BILLING_STATEMENT
        FROM BILLING_STATEMENT WHERE CHARGE_ID = v_CHARGE_ID;

		-- if wrong statement type/state, fetch corrected one
        IF v_BILLING_STATEMENT.STATEMENT_TYPE <> p_STATEMENT_TYPE OR
		   v_BILLING_STATEMENT.STATEMENT_STATE <> p_STATEMENT_STATE THEN
			SELECT CHARGE_ID INTO v_CHARGE_ID
			FROM BILLING_STATEMENT A
            WHERE A.ENTITY_ID = v_BILLING_STATEMENT.ENTITY_ID
            	AND A.PRODUCT_ID = v_BILLING_STATEMENT.PRODUCT_ID
            	AND A.COMPONENT_ID = v_BILLING_STATEMENT.COMPONENT_ID
            	AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
            	AND A.STATEMENT_STATE = p_STATEMENT_STATE
            	AND A.STATEMENT_DATE = v_BILLING_STATEMENT.STATEMENT_DATE
            	AND A.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
            						FROM BILLING_STATEMENT
            						WHERE ENTITY_ID = A.ENTITY_ID
            							AND PRODUCT_ID = A.PRODUCT_ID
            							AND COMPONENT_ID = A.COMPONENT_ID
            							AND STATEMENT_TYPE = A.STATEMENT_TYPE
            							AND STATEMENT_STATE = A.STATEMENT_STATE
            							AND STATEMENT_DATE = A.STATEMENT_DATE
            							AND AS_OF_DATE <= p_AS_OF_DATE);
		END IF;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			-- not found in billing_statement? then it is a nested combination charge.
			-- so first fetch parent's charge ID
			SELECT COMPONENT_ID, CHARGE_ID, BEGIN_DATE
			INTO v_COMPONENT_ID, v_CHARGE_ID, v_BEGIN_DATE
			FROM COMBINATION_CHARGE
			WHERE COMBINED_CHARGE_ID = v_CHARGE_ID;
			-- then use that to recursively get this charge's corrected charge ID
			v_CHARGE_ID := GET_COMBINED_CHARGE_ID(v_CHARGE_ID,v_COMPONENT_ID,v_BEGIN_DATE,p_STATEMENT_TYPE,p_STATEMENT_STATE,p_AS_OF_DATE);
	END;

	-- now that we know we have the correct parent charge ID, query the child's charge ID
    SELECT COMBINED_CHARGE_ID
    INTO v_CHARGE_ID
    FROM COMBINATION_CHARGE
    WHERE CHARGE_ID = v_CHARGE_ID
    	AND COMPONENT_ID = p_COMPONENT_ID
	    AND BEGIN_DATE = p_BEGIN_DATE;

	RETURN v_CHARGE_ID;

EXCEPTION
	WHEN OTHERS THEN
		RETURN 0; -- return zero ID on failure
END GET_COMBINED_CHARGE_ID;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_CHARGE_DETAILS
	(
	p_CALLING_MODULE IN VARCHAR2,
	p_MODEL_ID IN NUMBER,
	p_STATEMENT_DATE IN DATE,
	p_STATEMENT_END_DATE IN DATE,
	p_ENTITY_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_AS_OF_DATE IN DATE,
    p_SHOW_BILL_AMOUNT IN NUMBER,
    p_SHOW_CHARGE_AMOUNT IN NUMBER,
	p_CHARGE_VIEW_TYPE IN VARCHAR2,
	p_ENTITY_NAME OUT VARCHAR2,
	p_PRODUCT_NAME OUT VARCHAR2,
	p_COMPONENT_NAME OUT VARCHAR2,
	p_STATEMENT_TYPE_NAME OUT VARCHAR2,
	p_STATEMENT_DATE_RANGE OUT VARCHAR2,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
v_BEGIN_DATE DATE := PC.GET_CORRECT_STATEMENT_DATE(p_CALLING_MODULE,p_ENTITY_ID,p_STATEMENT_DATE);
v_END_DATE DATE := NVL(TRUNC(p_STATEMENT_END_DATE), v_BEGIN_DATE);
v_WORK_ID NUMBER;
v_COMBO_CHARGE_ID NUMBER;
v_BAND_KEYWORD VARCHAR2(30);
v_HAS_SUBTOTALS NUMBER;

v_CHARGE_VIEW_TYPE VARCHAR2(30);
v_KEY_COLUMNS VARCHAR2(4000);
v_STATUS NUMBER;

BEGIN
	UT.GET_RTO_WORK_ID(v_WORK_ID);

	-- Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_PSE_BILL_SELECT, p_ENTITY_ID, EC.ED_PSE);

	-- first collect all applicable charge IDs
	IF p_PRODUCT_ID < 0 THEN
		-- negative Product ID indicates the Charge ID of a Combination Charge
		v_COMBO_CHARGE_ID := GET_COMBINED_CHARGE_ID(-p_PRODUCT_ID,p_COMPONENT_ID,p_STATEMENT_DATE,p_STATEMENT_TYPE,p_STATEMENT_STATE,p_AS_OF_DATE);
		INSERT INTO RTO_WORK(WORK_ID, WORK_XID)
			VALUES (v_WORK_ID, v_COMBO_CHARGE_ID);
	ELSE
		INSERT INTO RTO_WORK(WORK_ID, WORK_XID)
    	SELECT v_WORK_ID, CHARGE_ID
    	FROM BILLING_STATEMENT A
        WHERE A.ENTITY_ID = p_ENTITY_ID
    	    AND A.PRODUCT_ID = p_PRODUCT_ID
    	    AND A.COMPONENT_ID = p_COMPONENT_ID
    	    AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
    	    AND A.STATEMENT_STATE = p_STATEMENT_STATE
    	    AND A.STATEMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
    	    AND A.AS_OF_DATE =
    	    	(SELECT MAX(AS_OF_DATE)
    	    	FROM BILLING_STATEMENT
    	    	WHERE ENTITY_ID = A.ENTITY_ID
    	    		AND PRODUCT_ID = A.PRODUCT_ID
    	    		AND COMPONENT_ID = A.COMPONENT_ID
    	    		AND STATEMENT_TYPE = A.STATEMENT_TYPE
    	    		AND STATEMENT_STATE = A.STATEMENT_STATE
    	    		AND STATEMENT_DATE = A.STATEMENT_DATE
    	    		AND AS_OF_DATE <= p_AS_OF_DATE);
		p_STATEMENT_DATE_RANGE := TO_CHAR(v_BEGIN_DATE, g_SHORT_DATE_FORMAT);
	END IF;

	-- now get out-bound strings (will be showed in labels on the report)
	SELECT MAX(PSE_NAME)
	INTO p_ENTITY_NAME
	FROM PURCHASING_SELLING_ENTITY
	WHERE PSE_ID = p_ENTITY_ID;

	SELECT MAX(PRODUCT_NAME)
	INTO p_PRODUCT_NAME
	FROM PRODUCT
	WHERE PRODUCT_ID = p_PRODUCT_ID;

	SELECT MAX(COMPONENT_NAME)
	INTO p_COMPONENT_NAME
	FROM COMPONENT
	WHERE COMPONENT_ID = p_COMPONENT_ID;

	SELECT MAX(STATEMENT_TYPE_NAME)||CASE WHEN p_STATEMENT_STATE = 1 THEN '' ELSE ' External' END
	INTO p_STATEMENT_TYPE_NAME
	FROM STATEMENT_TYPE
	WHERE STATEMENT_TYPE_ID = p_STATEMENT_TYPE;

	GET_CHARGE_VIEW_TYPE(p_CALLING_MODULE,p_MODEL_ID,p_ENTITY_ID,p_PRODUCT_ID,p_COMPONENT_ID,p_STATEMENT_TYPE,
		p_STATEMENT_STATE,p_STATEMENT_DATE,p_AS_OF_DATE,p_CHARGE_VIEW_TYPE,v_CHARGE_VIEW_TYPE,v_KEY_COLUMNS,v_STATUS);

	IF UPPER(v_CHARGE_VIEW_TYPE) = 'ACCOUNT SERVICE' THEN
		ACCOUNT_SERVICE_CHARGE_DETAIL(v_WORK_ID,p_TIME_ZONE,p_AS_OF_DATE,p_SHOW_BILL_AMOUNT,p_SHOW_CHARGE_AMOUNT,p_CURSOR);
	ELSIF UPPER(v_CHARGE_VIEW_TYPE) = 'BILLING CHARGE' OR
	      UPPER(v_CHARGE_VIEW_TYPE) = 'COINCIDENT PEAK' THEN
		BILLING_CHARGE_DETAIL(v_WORK_ID,p_TIME_ZONE,p_AS_OF_DATE,p_SHOW_BILL_AMOUNT,p_SHOW_CHARGE_AMOUNT,p_CURSOR);
	ELSIF UPPER(v_CHARGE_VIEW_TYPE) = 'ENTITY ATTRIBUTE' THEN
		ENTITY_ATTRIBUTE_CHARGE_DETAIL(v_WORK_ID,p_TIME_ZONE,p_AS_OF_DATE,p_SHOW_BILL_AMOUNT,p_SHOW_CHARGE_AMOUNT,p_CURSOR);
	ELSIF SUBSTR(UPPER(v_CHARGE_VIEW_TYPE),1,9) = 'IMBALANCE' THEN
		IMBALANCE_CHARGE_DETAIL(v_WORK_ID,p_TIME_ZONE,p_AS_OF_DATE,p_SHOW_BILL_AMOUNT,p_SHOW_CHARGE_AMOUNT,p_CURSOR);
	ELSIF UPPER(v_CHARGE_VIEW_TYPE) = 'TRANSMISSION' THEN
		TRANSMISSION_CHARGE_DETAIL(v_WORK_ID,p_TIME_ZONE,p_AS_OF_DATE,p_SHOW_BILL_AMOUNT,p_SHOW_CHARGE_AMOUNT,p_CURSOR);
	ELSIF UPPER(v_CHARGE_VIEW_TYPE) = 'OP PROFIT' THEN
		OPER_PROFIT_CHARGE_DETAIL(v_WORK_ID,p_TIME_ZONE,p_AS_OF_DATE,p_SHOW_BILL_AMOUNT,p_SHOW_CHARGE_AMOUNT,p_CURSOR);
	ELSIF UPPER(v_CHARGE_VIEW_TYPE) = 'CONVERSION' THEN
		CONVERSION_CHARGE_DETAIL(v_WORK_ID,p_TIME_ZONE,p_AS_OF_DATE,p_SHOW_BILL_AMOUNT,p_SHOW_CHARGE_AMOUNT,p_CURSOR);
	ELSIF UPPER(v_CHARGE_VIEW_TYPE) = 'FORMULA' THEN
		FORMULA_CHARGE_DETAIL(v_WORK_ID,p_TIME_ZONE,p_SHOW_BILL_AMOUNT,p_SHOW_CHARGE_AMOUNT,p_CURSOR);
	ELSIF SUBSTR(UPPER(v_CHARGE_VIEW_TYPE),1,3) = 'LMP' THEN
		LMP_CHARGE_DETAIL(v_WORK_ID,p_TIME_ZONE,p_AS_OF_DATE,p_SHOW_BILL_AMOUNT,p_SHOW_CHARGE_AMOUNT,p_CURSOR);
	ELSIF SUBSTR(UPPER(v_CHARGE_VIEW_TYPE),1,3) = 'FTR' THEN
		FTR_CHARGE_DETAIL(v_WORK_ID,p_TIME_ZONE,p_AS_OF_DATE,p_SHOW_BILL_AMOUNT,p_SHOW_CHARGE_AMOUNT,p_CURSOR);
	ELSIF UPPER(v_CHARGE_VIEW_TYPE) = 'COMBINATION' THEN
		COMBINATION_CHARGE_DETAIL(v_WORK_ID,p_TIME_ZONE,p_AS_OF_DATE,p_SHOW_BILL_AMOUNT,p_SHOW_CHARGE_AMOUNT,p_CURSOR);
	ELSIF UPPER(v_CHARGE_VIEW_TYPE) = 'TAX CHARGE' THEN
		TAX_CHARGE_DETAIL(v_WORK_ID,p_TIME_ZONE,p_AS_OF_DATE,p_SHOW_BILL_AMOUNT,p_SHOW_CHARGE_AMOUNT,p_CURSOR);
	ELSIF UPPER(v_CHARGE_VIEW_TYPE) = 'PIPELINE' THEN
		PIPELINE_CHARGE_DETAIL(v_WORK_ID,p_TIME_ZONE,p_AS_OF_DATE,p_SHOW_BILL_AMOUNT,p_SHOW_CHARGE_AMOUNT,p_CURSOR);
	ELSE -- IF UPPER(p_CHARGE_VIEW_TYPE) = 'EXTERNAL' THEN
		DECLARE
			v_STATUS NUMBER;
		BEGIN
			XS.GET_CHARGE_DETAIL(p_CALLING_MODULE,p_MODEL_ID,v_CHARGE_VIEW_TYPE,p_ENTITY_ID,p_COMPONENT_ID,v_WORK_ID,p_TIME_ZONE,p_AS_OF_DATE,v_BAND_KEYWORD,v_HAS_SUBTOTALS,p_SHOW_BILL_AMOUNT,p_SHOW_CHARGE_AMOUNT,v_STATUS,p_CURSOR);
			ERRS.VALIDATE_STATUS('XS.GET_CHARGE_DETAIL', v_STATUS);
		END;
	END IF;

	UT.PURGE_RTO_WORK(v_WORK_ID);

EXCEPTION
	WHEN OTHERS THEN
		UT.PURGE_RTO_WORK(v_WORK_ID);
		ERRS.LOG_AND_RAISE;

END GET_CHARGE_DETAILS;
---------------------------------------------------------------------------------------------------
PROCEDURE SCHEDULE_BY_TRANSMISSION
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_TRANSACTION_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_STATEMENT_BEGIN_DATE DATE;
v_STATEMENT_END_DATE DATE;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_TIME_ZONE VARCHAR2(16);

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

    SELECT MIN(STATEMENT_DATE),
    	NVL(MAX(STATEMENT_END_DATE),TRUNC(p_END_DATE))
    INTO v_STATEMENT_BEGIN_DATE, v_STATEMENT_END_DATE
    FROM BILLING_STATEMENT A
    WHERE A.ENTITY_ID = p_ENTITY_ID
    	AND A.PRODUCT_ID = p_PRODUCT_ID
        AND A.COMPONENT_ID = p_COMPONENT_ID
        AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
        AND A.STATEMENT_STATE = p_STATEMENT_STATE
        AND A.STATEMENT_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
        AND A.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
        					FROM BILLING_STATEMENT
                            WHERE ENTITY_ID = A.ENTITY_ID
                            	AND PRODUCT_ID = A.PRODUCT_ID
                                AND COMPONENT_ID = A.COMPONENT_ID
                                AND STATEMENT_TYPE = A.STATEMENT_TYPE
                                AND STATEMENT_STATE = A.STATEMENT_STATE
                                AND STATEMENT_DATE = A.STATEMENT_DATE
                                AND AS_OF_DATE <= p_AS_OF_DATE);
	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING THEN
    	SELECT NVL(TIME_ZONE,LOCAL_TIME_ZONE)
        INTO v_TIME_ZONE
        FROM PURCHASING_SELLING_ENTITY
        WHERE PSE_ID = p_ENTITY_ID;
    ELSE
    	v_TIME_ZONE := LOCAL_TIME_ZONE;
    END IF;
    UT.CUT_DATE_RANGE(v_STATEMENT_BEGIN_DATE, v_STATEMENT_END_DATE, v_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(B.SCHEDULE_DATE, p_TIME_ZONE, GET_FORMAT_FROM_INTERVAL(A.TRANSACTION_INTERVAL)) "SCHEDULE_DATE",
        	B.TRANSACTION_ID,
        	A.TRANSACTION_NAME,
        	B.AMOUNT "TRANSACTION_AMOUNT",
			B.PRICE "TRANSACTION_PRICE"
		FROM INTERCHANGE_TRANSACTION A,
			IT_SCHEDULE B,
			BILLING_STATEMENT C
		WHERE C.ENTITY_ID = p_ENTITY_ID
			AND C.PRODUCT_ID = p_PRODUCT_ID
			AND C.COMPONENT_ID = p_COMPONENT_ID
			AND C.STATEMENT_TYPE = p_STATEMENT_TYPE
			AND C.STATEMENT_STATE = p_STATEMENT_STATE
			AND C.STATEMENT_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
			AND C.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM BILLING_STATEMENT
				WHERE ENTITY_ID = C.ENTITY_ID
					AND PRODUCT_ID = C.PRODUCT_ID
					AND COMPONENT_ID = C.COMPONENT_ID
					AND STATEMENT_TYPE = C.STATEMENT_TYPE
					AND STATEMENT_STATE = C.STATEMENT_STATE
					AND STATEMENT_DATE = C.STATEMENT_DATE
					AND AS_OF_DATE <= p_AS_OF_DATE)
			AND A.TX_TRANSACTION_ID = p_TRANSACTION_ID
			AND B.TRANSACTION_ID = A.TRANSACTION_ID
			AND B.SCHEDULE_TYPE = p_STATEMENT_TYPE
			AND B.SCHEDULE_STATE = p_STATEMENT_STATE
			AND B.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND B.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM IT_SCHEDULE
				WHERE TRANSACTION_ID = B.TRANSACTION_ID
					AND SCHEDULE_TYPE = B.SCHEDULE_TYPE
					AND SCHEDULE_STATE = B.SCHEDULE_STATE
					AND SCHEDULE_DATE = B.SCHEDULE_DATE
					AND AS_OF_DATE <= C.BASIS_AS_OF_DATE)
		ORDER BY B.SCHEDULE_DATE, B.TRANSACTION_ID;

END SCHEDULE_BY_TRANSMISSION;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_INVOICE_LINE_ITEM
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
    p_STATEMENT_STATE IN NUMBER,
	p_INVOICE_DATE IN DATE,
    p_INVOICE_DATE_STRING IN VARCHAR,
	p_INVOICE_ID IN NUMBER,
	p_OLD_LINE_ITEM_NAME IN VARCHAR,
	p_LINE_ITEM_NAME IN VARCHAR,
    p_LINE_ITEM_CATEGORY IN VARCHAR,
	p_LINE_ITEM_TYPE IN CHAR,
	p_LINE_ITEM_QUANTITY IN NUMBER,
	p_LINE_ITEM_RATE IN NUMBER,
	p_LINE_ITEM_AMOUNT IN NUMBER,
	p_LINE_ITEM_BILL_AMOUNT IN NUMBER,
    p_DEFAULT_DISPLAY IN VARCHAR,
    p_INVOICE_GROUP_ID IN NUMBER,
    p_INVOICE_GROUP_ORDER IN NUMBER,
    p_EXCLUDE_FROM_INVOICE_TOTAL IN NUMBER,
    p_IS_TAXED IN NUMBER,
    p_TAX_COMPONENT_ID IN NUMBER,
    p_TAX_GEOGRAPHY_ID IN NUMBER,
	p_STATUS OUT NUMBER
	) AS
v_INVOICE_LINE_ITEM INVOICE_LINE_ITEM%ROWTYPE;
v_INVOICE_USER_LINE_ITEM INVOICE_USER_LINE_ITEM%ROWTYPE;
v_INVOICE_DATE DATE;

-- PBM - 4/18/2006 - New variable to get the first character of the LINE_ITEM_TYPE
v_LINE_ITEM_TYPE_CODE VARCHAR(2);
BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;
	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING THEN
		SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_PSE_INVOICE_LINE_ITEM, p_ENTITY_ID, EC.ED_PSE);
	END IF;

	p_STATUS := GA.SUCCESS;

    BEGIN
	    SELECT BEGIN_DATE INTO v_INVOICE_DATE
	    FROM INVOICE
	    WHERE INVOICE_ID = p_INVOICE_ID;
	EXCEPTION
    	WHEN NO_DATA_FOUND THEN
        	 IF p_INVOICE_DATE IS NULL AND p_INVOICE_DATE_STRING IS NULL THEN
		        v_INVOICE_DATE := NULL;
	         ELSIF NOT p_INVOICE_DATE_STRING IS NULL THEN
		        v_INVOICE_DATE := TO_DATE(SUBSTR(p_INVOICE_DATE_STRING,1,10), g_SHORT_DATE_FORMAT);
	         END IF;
	END;

    -- PBM - 4/18/2006 - Determine v_LINE_ITEM_TYPE_CODE
    CASE UPPER(p_LINE_ITEM_TYPE)
        WHEN 'PAYMENT' THEN
            v_LINE_ITEM_TYPE_CODE := 'P';
        WHEN 'FINANCE CHARGE' THEN
            v_LINE_ITEM_TYPE_CODE := 'F';
        WHEN 'ADJUSTMENT' THEN
            v_LINE_ITEM_TYPE_CODE := 'A';
        WHEN 'BALANCE' THEN
            v_LINE_ITEM_TYPE_CODE := 'B';
        WHEN 'MISCELLANEOUS' THEN
            v_LINE_ITEM_TYPE_CODE := 'M';
        WHEN 'MANUAL LINE ITEM TAX' THEN
            v_LINE_ITEM_TYPE_CODE := 'X';
        WHEN 'CURRENT' THEN
            v_LINE_ITEM_TYPE_CODE := 'C';
        WHEN 'TAX' THEN
            v_LINE_ITEM_TYPE_CODE := 'T';
        ELSE
            IF p_INVOICE_ID IS NULL THEN
                -- Use Manual - Miscellaneous as Default
                v_LINE_ITEM_TYPE_CODE := 'M';
            ELSE
                -- Use Current as Default
                v_LINE_ITEM_TYPE_CODE := 'C';
            END IF;
    END CASE;

    IF v_LINE_ITEM_TYPE_CODE = 'C' OR v_LINE_ITEM_TYPE_CODE = 'T' THEN
        v_INVOICE_LINE_ITEM.INVOICE_ID := p_INVOICE_ID;
		v_INVOICE_LINE_ITEM.LINE_ITEM_NAME := p_LINE_ITEM_NAME;
        v_INVOICE_LINE_ITEM.LINE_ITEM_CATEGORY := p_LINE_ITEM_CATEGORY;
		v_INVOICE_LINE_ITEM.LINE_ITEM_QUANTITY := p_LINE_ITEM_QUANTITY;
		v_INVOICE_LINE_ITEM.LINE_ITEM_RATE := p_LINE_ITEM_RATE;
		v_INVOICE_LINE_ITEM.LINE_ITEM_AMOUNT := p_LINE_ITEM_AMOUNT;
		v_INVOICE_LINE_ITEM.LINE_ITEM_BILL_AMOUNT := p_LINE_ITEM_BILL_AMOUNT;
        v_INVOICE_LINE_ITEM.DEFAULT_DISPLAY := p_DEFAULT_DISPLAY;
		PUT_INVOICE_LINE_ITEM(v_INVOICE_LINE_ITEM, p_OLD_LINE_ITEM_NAME);
    ELSE
		v_INVOICE_USER_LINE_ITEM.ENTITY_ID := p_ENTITY_ID;
		v_INVOICE_USER_LINE_ITEM.STATEMENT_TYPE := p_STATEMENT_TYPE;
		v_INVOICE_USER_LINE_ITEM.STATEMENT_STATE := p_STATEMENT_STATE;
		v_INVOICE_USER_LINE_ITEM.BEGIN_DATE := v_INVOICE_DATE;
		v_INVOICE_USER_LINE_ITEM.LINE_ITEM_TYPE := v_LINE_ITEM_TYPE_CODE;
		v_INVOICE_USER_LINE_ITEM.LINE_ITEM_NAME := p_LINE_ITEM_NAME;
        v_INVOICE_USER_LINE_ITEM.LINE_ITEM_CATEGORY := p_LINE_ITEM_CATEGORY;
		v_INVOICE_USER_LINE_ITEM.LINE_ITEM_QUANTITY := p_LINE_ITEM_QUANTITY;
		v_INVOICE_USER_LINE_ITEM.LINE_ITEM_RATE := p_LINE_ITEM_RATE;
		v_INVOICE_USER_LINE_ITEM.LINE_ITEM_AMOUNT := p_LINE_ITEM_AMOUNT;
		v_INVOICE_USER_LINE_ITEM.LINE_ITEM_BILL_AMOUNT := p_LINE_ITEM_BILL_AMOUNT;
        v_INVOICE_USER_LINE_ITEM.DEFAULT_DISPLAY := p_DEFAULT_DISPLAY;
		v_INVOICE_USER_LINE_ITEM.LINE_ITEM_POSTED_DATE := SYSDATE;
        v_INVOICE_USER_LINE_ITEM.INVOICE_GROUP_ID := p_INVOICE_GROUP_ID;
        v_INVOICE_USER_LINE_ITEM.INVOICE_GROUP_ORDER := p_INVOICE_GROUP_ORDER;
        v_INVOICE_USER_LINE_ITEM.EXCLUDE_FROM_INVOICE_TOTAL := p_EXCLUDE_FROM_INVOICE_TOTAL;
        v_INVOICE_USER_LINE_ITEM.IS_TAXED := p_IS_TAXED;
        v_INVOICE_USER_LINE_ITEM.TAX_COMPONENT_ID := p_TAX_COMPONENT_ID;
        v_INVOICE_USER_LINE_ITEM.TAX_GEOGRAPHY_ID := p_TAX_GEOGRAPHY_ID;
		PUT_INVOICE_USER_LINE_ITEM(v_INVOICE_USER_LINE_ITEM, p_OLD_LINE_ITEM_NAME);
	END IF;

END PUT_INVOICE_LINE_ITEM;
---------------------------------------------------------------------------------------------------
PROCEDURE DELETE_INVOICE_LINE_ITEM
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_INVOICE_DATE IN DATE,
	p_INVOICE_DATE_STRING IN VARCHAR,
	p_INVOICE_ID IN NUMBER,
	p_LINE_ITEM_NAME IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS
v_INVOICE_USER_LINE_ITEM INVOICE_USER_LINE_ITEM%ROWTYPE;
v_INVOICE_DATE DATE;
BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;
	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING THEN
		SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_PSE_INVOICE_LINE_ITEM, p_ENTITY_ID, EC.ED_PSE);
	END IF;

	p_STATUS := GA.SUCCESS;
	BEGIN
	    SELECT BEGIN_DATE INTO v_INVOICE_DATE
	    FROM INVOICE
	    WHERE INVOICE_ID = p_INVOICE_ID;
	EXCEPTION
    	WHEN NO_DATA_FOUND THEN
        	 IF p_INVOICE_DATE IS NULL AND p_INVOICE_DATE_STRING IS NULL THEN
		        v_INVOICE_DATE := NULL;
	         ELSIF NOT p_INVOICE_DATE_STRING IS NULL THEN
		        v_INVOICE_DATE := TO_DATE(SUBSTR(p_INVOICE_DATE_STRING,1,10), g_SHORT_DATE_FORMAT);
	         END IF;
	END;

	DELETE INVOICE_LINE_ITEM
	WHERE INVOICE_ID = p_INVOICE_ID
		AND LINE_ITEM_NAME = p_LINE_ITEM_NAME;

    -- save user line item before deletion so we can correctly do tax info
	BEGIN
    	SELECT * INTO v_INVOICE_USER_LINE_ITEM
        FROM INVOICE_USER_LINE_ITEM
		WHERE ENTITY_ID = p_ENTITY_ID
			AND STATEMENT_TYPE = p_STATEMENT_TYPE
	        AND STATEMENT_STATE = p_STATEMENT_STATE
			AND BEGIN_DATE = v_INVOICE_DATE
			AND LINE_ITEM_NAME = p_LINE_ITEM_NAME;
    EXCEPTION
    	WHEN NO_DATA_FOUND THEN
        	NULL;
    END;
	DELETE INVOICE_USER_LINE_ITEM
	WHERE ENTITY_ID = p_ENTITY_ID
		AND STATEMENT_TYPE = p_STATEMENT_TYPE
        AND STATEMENT_STATE = p_STATEMENT_STATE
		AND BEGIN_DATE = v_INVOICE_DATE
		AND LINE_ITEM_NAME = p_LINE_ITEM_NAME;
	IF SQL%ROWCOUNT > 0 AND NVL(v_INVOICE_USER_LINE_ITEM.IS_TAXED,0) <> 0 THEN
    	-- deleted a taxed line item? then update taxes
        UPDATE_TAX_FOR_USER_LINE_ITEM (v_INVOICE_USER_LINE_ITEM, v_INVOICE_USER_LINE_ITEM, FALSE, FALSE, TRUE);
    END IF;

END DELETE_INVOICE_LINE_ITEM;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_INVOICE_DATA
	(
	p_CALLING_MODULE IN VARCHAR,
    p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_INVOICE_DATE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
    p_INVOICE_CATEGORY IN VARCHAR,
    p_INVOICE_ID OUT NUMBER,
    p_INVOICE_STATUS OUT VARCHAR,
    p_INVOICE_APPROVAL_STATUS OUT VARCHAR,
    p_INVOICE_DUE_DATE OUT DATE,
	p_STATUS OUT NUMBER
    ) AS

v_INVOICE_APPROVED_BY VARCHAR(256);
v_INVOICE_APPROVED_WHEN DATE;
v_INVOICE_BEGIN_DATE DATE;
BEGIN

    IF p_INVOICE_DATE IS NULL THEN
		v_INVOICE_BEGIN_DATE := NULL;
	ELSE
		v_INVOICE_BEGIN_DATE := TO_DATE(SUBSTR(p_INVOICE_DATE,1,10), g_SHORT_DATE_FORMAT);
	END IF;

    SELECT A.INVOICE_ID, A.INVOICE_STATUS, A.PAYMENT_DUE_DATE, NVL(U.USER_DISPLAY_NAME, U.USER_NAME) AS APPROVED_BY, A.APPROVED_WHEN
    INTO p_INVOICE_ID, p_INVOICE_STATUS, P_INVOICE_DUE_DATE, v_INVOICE_APPROVED_BY, v_INVOICE_APPROVED_WHEN
    FROM INVOICE A, APPLICATION_USER U
    WHERE A.ENTITY_ID = p_ENTITY_ID
    AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
    AND A.STATEMENT_STATE = p_STATEMENT_STATE
    AND A.BEGIN_DATE = v_INVOICE_BEGIN_DATE
    AND A.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
                        FROM INVOICE
                        WHERE ENTITY_ID = A.ENTITY_ID
                    	AND STATEMENT_TYPE = A.STATEMENT_TYPE
                    	AND STATEMENT_STATE = A.STATEMENT_STATE
                 	    AND BEGIN_DATE = A.BEGIN_DATE
                        AND AS_OF_DATE <= p_AS_OF_DATE)
	AND U.USER_ID (+) = A.APPROVED_BY_ID;

   IF v_INVOICE_APPROVED_BY IS NULL AND v_INVOICE_APPROVED_WHEN IS NULL THEN
        p_INVOICE_APPROVAL_STATUS := 'Invoice not approved';
   ELSIF v_INVOICE_APPROVED_BY IS NULL THEN
        p_INVOICE_APPROVAL_STATUS := 'Invoice needs approval because of changes from ' || TO_CHAR(v_INVOICE_APPROVED_WHEN, g_LONG_DATE_FORMAT);
   ELSE
        p_INVOICE_APPROVAL_STATUS := 'Invoice approved by ' || v_INVOICE_APPROVED_BY || ' at ' || TO_CHAR(v_INVOICE_APPROVED_WHEN, g_LONG_DATE_FORMAT);
   END IF;

END GET_INVOICE_DATA;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_INVOICE_DATA
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_INVOICE_ID IN NUMBER,
    p_DUE_DATE IN DATE,
	p_INVOICE_STATUS IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	PUT_INVOICE_STATUS(p_CALLING_MODULE,p_MODEL_ID,p_INVOICE_ID,p_INVOICE_STATUS,p_STATUS);

    PUT_INVOICE_DUE_DATE(p_CALLING_MODULE,p_MODEL_ID,p_INVOICE_ID,p_DUE_DATE,p_STATUS);

END PUT_INVOICE_DATA;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_INVOICE_STATUS
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_INVOICE_ID IN NUMBER,
	p_INVOICE_STATUS IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	p_STATUS := GA.SUCCESS;

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING THEN
		DECLARE
			v_ENTITY_ID NUMBER(9);
		BEGIN
			SELECT ENTITY_ID INTO v_ENTITY_ID
			FROM INVOICE WHERE INVOICE_ID = p_INVOICE_ID;

			SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_PSE_INVOICE_STATUS, v_ENTITY_ID, EC.ED_PSE);
		END;
	END IF;

	UPDATE INVOICE
	SET	INVOICE_STATUS = p_INVOICE_STATUS
	WHERE INVOICE_ID = p_INVOICE_ID;

END PUT_INVOICE_STATUS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_INVOICE_DUE_DATE
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_INVOICE_ID IN NUMBER,
	p_DUE_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	p_STATUS := GA.SUCCESS;

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING THEN
		DECLARE
			v_ENTITY_ID NUMBER(9);
		BEGIN
			SELECT ENTITY_ID INTO v_ENTITY_ID
			FROM INVOICE WHERE INVOICE_ID = p_INVOICE_ID;

			SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_PSE_INVOICE_DUE_DATE, v_ENTITY_ID, EC.ED_PSE);
		END;
	END IF;

	UPDATE INVOICE
	SET	PAYMENT_DUE_DATE = p_DUE_DATE
	WHERE INVOICE_ID = p_INVOICE_ID;

END PUT_INVOICE_DUE_DATE;
---------------------------------------------------------------------------------------------------
PROCEDURE EXPORT_BILLING
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATEMENT_TYPE IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	p_STATUS := GA.SUCCESS;

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	XS.EXPORT_BILLING(p_BEGIN_DATE, p_END_DATE, p_STATEMENT_TYPE, p_AS_OF_DATE, p_STATUS);

END EXPORT_BILLING;
---------------------------------------------------------------------------------------------------
PROCEDURE EDC_IMBALANCE
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATEMENT_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE := TRUNC(p_BEGIN_DATE);
v_END_DATE DATE := TRUNC(p_END_DATE);

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(CHARGE_DATE, p_TIME_ZONE),
			   SYSTEM_OVER_SUPPLY,
			   SYSTEM_UNDER_SUPPLY,
			   SYSTEM_NET_POSITION,
			   OVER_SUPPLY_RATE,
			   UNDER_SUPPLY_RATE,
			   OSF_AMOUNT,
			   OSF_RATE,
			   REVENUE_AMOUNT,
			   BENEFIT_AMOUNT
		FROM NET_RETAIL_PROFIT_LOSS
		WHERE  STATEMENT_TYPE = p_STATEMENT_TYPE
		AND STATEMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND AS_OF_DATE = EDC_IMBALANCE_AS_OF_DATE(STATEMENT_TYPE, STATEMENT_DATE, p_AS_OF_DATE);

END EDC_IMBALANCE;
---------------------------------------------------------------------------------------------------
PROCEDURE SERVICE_POINT_FOR_COMPONENT
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_SERVICE_POINT_ID OUT NUMBER,
	p_SERVICE_POINT_NAME OUT VARCHAR2,
	p_STATUS OUT NUMBER
	) AS

  v_IMBALANCE_TYPE COMPONENT.IMBALANCE_TYPE%TYPE;

BEGIN

	p_STATUS := GA.SUCCESS;

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	SELECT IMBALANCE_TYPE, SERVICE_POINT_ID INTO v_IMBALANCE_TYPE, p_SERVICE_POINT_ID
	FROM COMPONENT
	WHERE COMPONENT_ID = p_COMPONENT_ID;

	IF UPPER(SUBSTR(v_IMBALANCE_TYPE,1,1)) <> 'S' AND UPPER(SUBSTR(v_IMBALANCE_TYPE,1,1)) <> 'A' THEN
		p_SERVICE_POINT_ID := 0;
	END IF;
	IF p_SERVICE_POINT_ID <> 0 THEN
		SELECT SERVICE_POINT_NAME INTO p_SERVICE_POINT_NAME
		FROM SERVICE_POINT
		WHERE SERVICE_POINT_ID = p_SERVICE_POINT_ID;
	END IF;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_SERVICE_POINT_ID := 0;
			ERRS.LOG_AND_RAISE();
		WHEN OTHERS THEN
			ERRS.LOG_AND_RAISE();

END SERVICE_POINT_FOR_COMPONENT;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_NAMES_FOR_ACTION
    (
   	p_ACTION_NAME IN VARCHAR2,
	p_INCL_ALL IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
v_VALID_IDs ID_TABLE;
BEGIN
    v_VALID_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(p_ACTION_NAME);

	p_STATUS := GA.SUCCESS;

    OPEN p_CURSOR FOR
		SELECT '<All>' as PSE_NAME, -1 as PSE_ID
		FROM DUAL
		WHERE p_INCL_ALL = 1
		UNION ALL
    	SELECT PSE_NAME, PSE_ID
	    FROM PURCHASING_SELLING_ENTITY A,
	    	TABLE(CAST(v_VALID_IDs AS ID_TABLE)) B
		WHERE B.ID IN (SD.g_ALL_DATA_ENTITY_ID, A.PSE_ID)
	    	AND NVL(A.IS_BILLING_ENTITY,0) = 1
		ORDER BY 1;

END PSE_NAMES_FOR_ACTION;
--------------------------------------------------------------------------------------------------------------------
PROCEDURE BILL_ENTITY_NAMES
    (
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_INCL_ALL IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_POSITION_AND_BILLING THEN
		OPEN p_CURSOR FOR
			  SELECT BILL_PARTY_NAME, BILL_PARTY_ID
			  FROM BILL_PARTY
			  WHERE BILL_PARTY_ID > 0
			  ORDER BY 1;
	ELSIF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_GAS_DELIVERY THEN
		 OPEN p_CURSOR FOR
		 		SELECT POOL_NAME, POOL_ID
				FROM POOL
				WHERE POOL_ID > 0
				ORDER BY 1;
	ELSIF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING THEN
		PSE_NAMES_FOR_ACTION(SD.g_ACTION_PSE_BILL_SELECT, p_INCL_ALL, p_STATUS, p_CURSOR);
	END IF;

END BILL_ENTITY_NAMES;
--------------------------------------------------------------------------------------------------------------------
PROCEDURE BILL_ENTITY_NAMES_INCL_ALL
   	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
BEGIN
	BILL_ENTITY_NAMES(p_CALLING_MODULE, p_MODEL_ID, 1, p_STATUS, p_CURSOR);
END BILL_ENTITY_NAMES_INCL_ALL;
--------------------------------------------------------------------------------------------------------------------
PROCEDURE BILL_ENTITY_NAMES
    (
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
BEGIN
	BILL_ENTITY_NAMES(p_CALLING_MODULE, p_MODEL_ID, 0, p_STATUS, p_CURSOR);
END BILL_ENTITY_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE INVOICE_ENTITY_NAMES
    (
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
v_VALID_IDs ID_TABLE;
BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	v_VALID_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_PSE_BILL_SELECT);

	 OPEN p_CURSOR FOR
	 		SELECT PSE_NAME, PSE_ID
			FROM PURCHASING_SELLING_ENTITY A,
				TABLE(CAST(v_VALID_IDs AS ID_TABLE)) B
			WHERE B.ID IN (SD.g_ALL_DATA_ENTITY_ID, A.PSE_ID)
            	AND NVL(A.IS_BILLING_ENTITY,0) = 1
			ORDER BY 1;

END INVOICE_ENTITY_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE BILL_ENTITY_NAMES_TO_CALC
    (
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_LABEL OUT VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_POSITION_AND_BILLING OR
    	UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_GAS_DELIVERY THEN
		p_ENTITY_LABEL := 'Billing Entities';
    	 BILL_ENTITY_NAMES(p_CALLING_MODULE,p_MODEL_ID,p_STATUS,p_CURSOR);
	ELSE
		p_ENTITY_LABEL := 'PSE Billing Entities';
		PSE_NAMES_FOR_ACTION(SD.g_ACTION_PSE_BILL_CALCULATE, 0, p_STATUS, p_CURSOR);
	END IF;

END BILL_ENTITY_NAMES_TO_CALC;
---------------------------------------------------------------------------------------------------
PROCEDURE BILL_ENTITY_NAMES_BY_INTERVAL
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
    p_INTERVAL IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
BEGIN
	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_POSITION_AND_BILLING OR
    	UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_GAS_DELIVERY THEN
    	 BILL_ENTITY_NAMES(p_CALLING_MODULE,p_MODEL_ID,p_STATUS,p_CURSOR);
	ELSE
		DECLARE
			v_VALID_IDs ID_TABLE;
		BEGIN
	    	p_STATUS := GA.SUCCESS;
			v_VALID_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_PSE_BILL_SELECT);
	        OPEN p_CURSOR FOR
	        	SELECT PSE_NAME, PSE_ID
	            FROM PURCHASING_SELLING_ENTITY A,
					TABLE(CAST(v_VALID_IDs AS ID_TABLE)) B
				WHERE B.ID IN (SD.g_ALL_DATA_ENTITY_ID, A.PSE_ID)
	            	AND NVL(A.IS_BILLING_ENTITY,0) = 1
	            	AND DECODE(UPPER(SUBSTR(NVL(A.STATEMENT_INTERVAL,'Month'),1,2)),'DA',1,'WE',2,'MO',3,'QU',4,'YE',5) <=
	                		DECODE(UPPER(SUBSTR(p_INTERVAL,1,2)),'DA',1,'WE',2,'MO',3,'QU',4,'YE',5)
				ORDER BY A.PSE_NAME;
		END;
    END IF;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END BILL_ENTITY_NAMES_BY_INTERVAL;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_NAMES
    (
	 p_STATUS OUT NUMBER,
	 p_CURSOR IN OUT GA.REFCURSOR
	) AS
v_VALID_IDs ID_TABLE;
BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	v_VALID_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_PSE_BILL_SELECT);

	 OPEN p_CURSOR FOR
	 		SELECT PSE_NAME, PSE_ID
			FROM PURCHASING_SELLING_ENTITY A,
				TABLE(CAST(v_VALID_IDs AS ID_TABLE)) B
			WHERE B.ID IN (SD.g_ALL_DATA_ENTITY_ID, A.PSE_ID)
            	AND NVL(A.IS_BILLING_ENTITY,0) = 1
			ORDER BY 1;

END PSE_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE BILL_PARTY_NAMES
    (
	 p_STATUS OUT NUMBER,
	 p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	 OPEN p_CURSOR FOR
	 		SELECT BILL_PARTY_NAME, BILL_PARTY_ID
			FROM BILL_PARTY
			WHERE BILL_PARTY_ID > 0
			ORDER BY 1;

END BILL_PARTY_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE BILL_CYCLE_NAMES
    (
	 p_STATUS OUT NUMBER,
	 p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	 OPEN p_CURSOR FOR
	 		SELECT BILL_CYCLE_NAME, BILL_CYCLE_ID
			FROM BILL_CYCLE
			WHERE BILL_CYCLE_ID > 0
			ORDER BY 1;

END BILL_CYCLE_NAMES;
---------------------------------------------------------------------------------------------------
FUNCTION GET_CHARGE_ID
	(
	p_ENTITY_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_STATEMENT_DATE IN DATE,
	p_AS_OF_DATE IN DATE
	) RETURN NUMBER IS
v_CHARGE_ID NUMBER;
BEGIN
	SELECT CHARGE_ID INTO v_CHARGE_ID
	FROM BILLING_STATEMENT A
	WHERE ENTITY_ID = p_ENTITY_ID
		AND PRODUCT_ID = p_PRODUCT_ID
		AND COMPONENT_ID = p_COMPONENT_ID
		AND STATEMENT_TYPE = p_STATEMENT_TYPE
		AND STATEMENT_STATE = p_STATEMENT_STATE
		AND STATEMENT_DATE = p_STATEMENT_DATE
		AND AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM BILLING_STATEMENT
			WHERE ENTITY_ID = A.ENTITY_ID
				AND PRODUCT_ID = A.PRODUCT_ID
				AND COMPONENT_ID = A.COMPONENT_ID
				AND STATEMENT_TYPE = A.STATEMENT_TYPE
				AND STATEMENT_STATE = A.STATEMENT_STATE
				AND STATEMENT_DATE = A.STATEMENT_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE);
	RETURN v_CHARGE_ID;
END GET_CHARGE_ID;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_CHARGE_VIEW_TYPE
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_STATEMENT_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_CHARGE_VIEW_TYPE IN VARCHAR,
	p_NEW_CHARGE_VIEW_TYPE OUT VARCHAR,
	p_KEY_COLUMNS OUT VARCHAR,
	p_STATUS OUT NUMBER
	) AS
v_CHARGE_ID NUMBER;
BEGIN

	p_STATUS := GA.SUCCESS;

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	p_NEW_CHARGE_VIEW_TYPE := p_CHARGE_VIEW_TYPE;
	-- if product ID is negative and charge view type is provided,
	-- then stick with the specified charge view type - it came from
	-- a combination charge - just trust it
	-- otherwise, query for the charge view type (don't trust
	-- specified value)
	IF p_NEW_CHARGE_VIEW_TYPE IS NULL OR p_PRODUCT_ID > 0 THEN
        BEGIN
    		-- get charge ID
    		v_CHARGE_ID := GET_CHARGE_ID(p_ENTITY_ID, p_PRODUCT_ID, p_COMPONENT_ID, p_STATEMENT_TYPE, p_STATEMENT_STATE, p_STATEMENT_DATE, p_AS_OF_DATE);
    		-- get charge view type
    		SELECT CHARGE_VIEW_TYPE INTO p_NEW_CHARGE_VIEW_TYPE
    		FROM BILLING_STATEMENT
    		WHERE CHARGE_ID = v_CHARGE_ID;
    	EXCEPTION
        	WHEN NO_DATA_FOUND THEN
            	-- try different period's or different statement type/state
    			-- to get charge view type for same charge
                SELECT CHARGE_VIEW_TYPE INTO p_NEW_CHARGE_VIEW_TYPE
				FROM (SELECT CHARGE_VIEW_TYPE
						FROM BILLING_STATEMENT BS, STATEMENT_TYPE ST1, STATEMENT_TYPE ST2
						WHERE BS.ENTITY_ID = p_ENTITY_ID
							AND BS.PRODUCT_ID = p_PRODUCT_ID
							AND BS.COMPONENT_ID = p_COMPONENT_ID
							AND ST1.STATEMENT_TYPE_ID(+) = BS.STATEMENT_TYPE
							AND ST2.STATEMENT_TYPE_ID(+) = p_STATEMENT_TYPE
						-- order by will try to get the "closest" entry to the specified
						-- statement type, state, and date
						ORDER BY ABS(ST1.STATEMENT_TYPE_ORDER - ST2.STATEMENT_TYPE_ORDER)
								+ ABS(BS.STATEMENT_STATE - p_STATEMENT_STATE)
								+ ABS(BS.STATEMENT_DATE - p_STATEMENT_DATE))
    			WHERE ROWNUM=1;
        END;
	END IF;

	p_KEY_COLUMNS := 'CHARGE_DATE';
	IF UPPER(p_NEW_CHARGE_VIEW_TYPE) = 'ACCOUNT SERVICE' THEN
		p_KEY_COLUMNS := 'ACCOUNT,SERVICE_LOCATION,METER,CHARGE_BEGIN_DATE';
	ELSIF UPPER(p_NEW_CHARGE_VIEW_TYPE) = 'ENTITY ATTRIBUTE' THEN
		p_KEY_COLUMNS := 'FACILITY,CHARGE_DATE';
	ELSIF UPPER(p_NEW_CHARGE_VIEW_TYPE) = 'TRANSMISSION' THEN
		p_KEY_COLUMNS := 'TRANSACTION_ID,CHARGE_DATE';
	ELSIF UPPER(p_NEW_CHARGE_VIEW_TYPE) = 'CONVERSION' THEN
		p_KEY_COLUMNS := 'SCHEDULE_GROUP,CHARGE_DATE';
	ELSIF UPPER(p_NEW_CHARGE_VIEW_TYPE) = 'FORMULA' THEN
		p_KEY_COLUMNS := 'ITERATOR10,ITERATOR9,ITERATOR8,ITERATOR7,ITERATOR6,ITERATOR5,ITERATOR4,ITERATOR3,ITERATOR2,ITERATOR1,CHARGE_DATE';
	ELSIF SUBSTR(UPPER(p_NEW_CHARGE_VIEW_TYPE),1,3) = 'LMP' THEN
		p_KEY_COLUMNS := 'SOURCE_ID,DELIVERY_POINT_ID,SINK_ID,CHARGE_DATE';
	ELSIF SUBSTR(UPPER(p_NEW_CHARGE_VIEW_TYPE),1,3) = 'FTR' THEN
		p_KEY_COLUMNS := 'SOURCE_ID,DELIVERY_POINT_ID,SINK_ID,FTR_TYPE,CHARGE_DATE';
	ELSIF UPPER(p_NEW_CHARGE_VIEW_TYPE) = 'COMBINATION' THEN
		p_KEY_COLUMNS := 'COMPONENT_ID,CHARGE_DATE';
	ELSIF UPPER(p_NEW_CHARGE_VIEW_TYPE) = 'TAX CHARGE' THEN
		p_KEY_COLUMNS := 'PRODUCT_ID,COMPONENT_ID,TAX_AREA_TYPE,CHARGE_DATE';
	ELSIF UPPER(p_NEW_CHARGE_VIEW_TYPE) = 'PIPELINE' THEN
		p_KEY_COLUMNS := 'DELIVERY_ID|POR_ID|POD_ID|CHARGE_DATE';
	ELSE -- IF UPPER(p_CHARGE_VIEW_TYPE) = 'EXTERNAL' THEN
		XS.GET_CHARGE_KEY_COLUMNS(p_CALLING_MODULE,p_MODEL_ID,p_NEW_CHARGE_VIEW_TYPE,p_ENTITY_ID,p_COMPONENT_ID,p_KEY_COLUMNS,p_STATUS);
	END IF;

END GET_CHARGE_VIEW_TYPE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_BILLING_CHARGE_DISPUTES
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_STATEMENT_DATE IN DATE,
	p_DISPUTE_DATES IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_TABLE GA.STRING_TABLE;
v_WORK_ID NUMBER;
v_DISP_DATE_STR VARCHAR(16);
v_DISP_TIME_STR VARCHAR(16);
v_DISPUTE_DATE DATE;

BEGIN
	UT.GET_RTO_WORK_ID(v_WORK_ID);
	UT.TOKENS_FROM_STRING(p_DISPUTE_DATES, '|', v_TABLE);

	-- gather the dates into RTO_WORK
	FOR v_INDEX IN v_TABLE.FIRST..v_TABLE.LAST LOOP
		SELECT SUBSTR(LTRIM(RTRIM(v_TABLE(v_INDEX))),1,10) INTO v_DISP_DATE_STR FROM DUAL;
		SELECT SUBSTR(LTRIM(RTRIM(v_TABLE(v_INDEX))),12) INTO v_DISP_TIME_STR FROM DUAL;
	    v_DISPUTE_DATE := DATE_TIME_AS_CUT(v_DISP_DATE_STR,v_DISP_TIME_STR,p_TIME_ZONE,1);
		UT.POST_RTO_WORK (v_WORK_ID, 0, v_DISPUTE_DATE);
	END LOOP;
	v_TABLE.DELETE;

	-- then fetch them all
	OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(A.DISPUTE_DATE,p_TIME_ZONE,DECODE(TO_CHAR(A.DISPUTE_DATE,'SS'),'01','DD','MI5')) "DISPUTE_DATE",
			A.OLD_BILL_AMOUNT "BILLED_AMOUNT",
			A.NEW_BILL_AMOUNT "CORRECTED_AMOUNT",
			A.DISPUTE_STATUS,
			A.DISPUTE_DESC "DESCRIPTION"
		FROM BILLING_CHARGE_DISPUTE A,
			RTO_WORK B
		WHERE B.WORK_ID = v_WORK_ID
			AND A.ENTITY_ID = p_ENTITY_ID
			AND A.PRODUCT_ID = p_PRODUCT_ID
			AND A.COMPONENT_ID = p_COMPONENT_ID
			AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
			AND A.STATEMENT_STATE = p_STATEMENT_STATE
            AND A.STATEMENT_DATE = p_STATEMENT_DATE
			AND A.DISPUTE_DATE = B.WORK_DATE
		ORDER BY 1;

	UT.PURGE_RTO_WORK(v_WORK_ID);

EXCEPTION
	WHEN OTHERS THEN
		  UT.PURGE_RTO_WORK(v_WORK_ID);
		ERRS.LOG_AND_RAISE;

END GET_BILLING_CHARGE_DISPUTES;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_DISPUTE_AMOUNT
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_STATEMENT_DATE IN DATE,
	p_STATEMENT_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
    p_SHOW_CHARGE_AMOUNT IN NUMBER,
	p_DISPUTE_DATE IN DATE,
	p_ITERATOR1	VARCHAR2,
  	p_ITERATOR2 VARCHAR2,
  	p_ITERATOR3 VARCHAR2,
  	p_ITERATOR4 VARCHAR2,
  	p_ITERATOR5 VARCHAR2,
  	p_ITERATOR6 VARCHAR2,
  	p_ITERATOR7 VARCHAR2,
 	p_ITERATOR8 VARCHAR2,
  	p_ITERATOR9 VARCHAR2,
  	p_ITERATOR10 VARCHAR2,
	p_AMOUNT OUT NUMBER,
	p_QUANTITY OUT NUMBER
	)
AS
v_CHARGE_VIEW_TYPE VARCHAR2(32);
v_KEY_COLUMNS VARCHAR2(512);
v_STATUS NUMBER;
v_CHARGE_AMOUNT NUMBER;
v_BILL_AMOUNT NUMBER;
v_CHARGE_QUANTITY NUMBER;
v_BILL_QUANTITY NUMBER;
BEGIN
	BEGIN
		GET_CHARGE_VIEW_TYPE(p_CALLING_MODULE, p_MODEL_ID, p_ENTITY_ID, p_PRODUCT_ID, p_COMPONENT_ID,
						p_STATEMENT_TYPE, p_STATEMENT_STATE, p_STATEMENT_DATE, p_AS_OF_DATE, NULL,
						v_CHARGE_VIEW_TYPE, v_KEY_COLUMNS, v_STATUS);
		IF v_STATUS < 0 OR v_CHARGE_VIEW_TYPE IS NULL THEN
			p_AMOUNT := NULL;
			p_QUANTITY := NULL;
		END IF;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_AMOUNT := NULL; -- no matching BILLING_STATEMENT record? return NULL amount
			p_QUANTITY := NULL;
	END;

	IF UPPER(v_CHARGE_VIEW_TYPE) = 'ACCOUNT SERVICE' THEN
		SELECT SUM(A.CHARGE_AMOUNT), SUM(A.BILL_AMOUNT),  SUM(A.CHARGE_QUANTITY),SUM(A.BILL_QUANTITY)
		INTO v_CHARGE_AMOUNT, v_BILL_AMOUNT, v_CHARGE_QUANTITY, v_BILL_QUANTITY
		FROM ACCOUNT_SERVICE_CHARGE A, BILLING_STATEMENT B
		WHERE B.ENTITY_ID = p_ENTITY_ID
			AND B.PRODUCT_ID = p_PRODUCT_ID
			AND B.COMPONENT_ID = p_COMPONENT_ID
			AND B.STATEMENT_TYPE = p_STATEMENT_TYPE
			AND B.STATEMENT_STATE = p_STATEMENT_STATE
			AND B.STATEMENT_DATE BETWEEN p_STATEMENT_DATE AND p_STATEMENT_END_DATE
			AND B.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
								FROM BILLING_STATEMENT
								WHERE ENTITY_ID = B.ENTITY_ID
									AND PRODUCT_ID = B.PRODUCT_ID
									AND COMPONENT_ID = B.COMPONENT_ID
									AND STATEMENT_TYPE = B.STATEMENT_TYPE
									AND STATEMENT_STATE = B.STATEMENT_STATE
									AND STATEMENT_DATE = B.STATEMENT_DATE
									AND AS_OF_DATE <= p_AS_OF_DATE)
			AND A.CHARGE_ID = B.CHARGE_ID
			AND A.CHARGE_BEGIN_DATE = p_DISPUTE_DATE;
	ELSIF UPPER(v_CHARGE_VIEW_TYPE) = 'BILLING CHARGE' OR
	      UPPER(v_CHARGE_VIEW_TYPE) = 'COINCIDENT PEAK' THEN
		SELECT SUM(A.CHARGE_AMOUNT), SUM(A.BILL_AMOUNT), SUM(A.CHARGE_QUANTITY),SUM(A.BILL_QUANTITY)
		INTO v_CHARGE_AMOUNT, v_BILL_AMOUNT, v_CHARGE_QUANTITY, v_BILL_QUANTITY
		FROM BILLING_CHARGE A, BILLING_STATEMENT B
		WHERE B.ENTITY_ID = p_ENTITY_ID
			AND B.PRODUCT_ID = p_PRODUCT_ID
			AND B.COMPONENT_ID = p_COMPONENT_ID
			AND B.STATEMENT_TYPE = p_STATEMENT_TYPE
			AND B.STATEMENT_STATE = p_STATEMENT_STATE
			AND B.STATEMENT_DATE BETWEEN p_STATEMENT_DATE AND p_STATEMENT_END_DATE
			AND B.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
								FROM BILLING_STATEMENT
								WHERE ENTITY_ID = B.ENTITY_ID
									AND PRODUCT_ID = B.PRODUCT_ID
									AND COMPONENT_ID = B.COMPONENT_ID
									AND STATEMENT_TYPE = B.STATEMENT_TYPE
									AND STATEMENT_STATE = B.STATEMENT_STATE
									AND STATEMENT_DATE = B.STATEMENT_DATE
									AND AS_OF_DATE <= p_AS_OF_DATE)
			AND A.CHARGE_ID = B.CHARGE_ID
			AND A.CHARGE_DATE = p_DISPUTE_DATE;
	ELSIF UPPER(v_CHARGE_VIEW_TYPE) = 'ENTITY ATTRIBUTE' THEN
		SELECT SUM(A.CHARGE_AMOUNT), SUM(A.BILL_AMOUNT), SUM(A.CHARGE_QUANTITY),SUM(A.BILL_QUANTITY)
		INTO v_CHARGE_AMOUNT, v_BILL_AMOUNT, v_CHARGE_QUANTITY, v_BILL_QUANTITY
		FROM ENTITY_ATTRIBUTE_CHARGE A, BILLING_STATEMENT B
		WHERE B.ENTITY_ID = p_ENTITY_ID
			AND B.PRODUCT_ID = p_PRODUCT_ID
			AND B.COMPONENT_ID = p_COMPONENT_ID
			AND B.STATEMENT_TYPE = p_STATEMENT_TYPE
			AND B.STATEMENT_STATE = p_STATEMENT_STATE
			AND B.STATEMENT_DATE BETWEEN p_STATEMENT_DATE AND p_STATEMENT_END_DATE
			AND B.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
								FROM BILLING_STATEMENT
								WHERE ENTITY_ID = B.ENTITY_ID
									AND PRODUCT_ID = B.PRODUCT_ID
									AND COMPONENT_ID = B.COMPONENT_ID
									AND STATEMENT_TYPE = B.STATEMENT_TYPE
									AND STATEMENT_STATE = B.STATEMENT_STATE
									AND STATEMENT_DATE = B.STATEMENT_DATE
									AND AS_OF_DATE <= p_AS_OF_DATE)
			AND A.CHARGE_ID = B.CHARGE_ID
			AND A.CHARGE_DATE = p_DISPUTE_DATE;
	ELSIF SUBSTR(UPPER(v_CHARGE_VIEW_TYPE),1,9) = 'IMBALANCE' THEN
		SELECT SUM(C.ENERGY_IMBALANCE_AMOUNT), SUM(C.BILL_ENERGY_IMBALANCE_AMOUNT),
			SUM(C.ENERGY_IMBALANCE_QUANTITY),SUM(C.BILL_ENERGY_IMBALANCE_QUANTITY)
		INTO v_CHARGE_AMOUNT, v_BILL_AMOUNT, v_CHARGE_QUANTITY, v_BILL_QUANTITY
		FROM IMBALANCE_CHARGE A, IMBALANCE_CHARGE_BAND C, BILLING_STATEMENT B
		WHERE B.ENTITY_ID = p_ENTITY_ID
			AND B.PRODUCT_ID = p_PRODUCT_ID
			AND B.COMPONENT_ID = p_COMPONENT_ID
			AND B.STATEMENT_TYPE = p_STATEMENT_TYPE
			AND B.STATEMENT_STATE = p_STATEMENT_STATE
			AND B.STATEMENT_DATE BETWEEN p_STATEMENT_DATE AND p_STATEMENT_END_DATE
			AND B.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
								FROM BILLING_STATEMENT
								WHERE ENTITY_ID = B.ENTITY_ID
									AND PRODUCT_ID = B.PRODUCT_ID
									AND COMPONENT_ID = B.COMPONENT_ID
									AND STATEMENT_TYPE = B.STATEMENT_TYPE
									AND STATEMENT_STATE = B.STATEMENT_STATE
									AND STATEMENT_DATE = B.STATEMENT_DATE
									AND AS_OF_DATE <= p_AS_OF_DATE)
			AND A.CHARGE_ID = B.CHARGE_ID
			AND A.CHARGE_DATE = p_DISPUTE_DATE
			AND C.CHARGE_ID = A.CHARGE_ID
			AND C.CHARGE_DATE = A.CHARGE_DATE;
	ELSIF UPPER(v_CHARGE_VIEW_TYPE) = 'TRANSMISSION' THEN
		SELECT SUM(A.CHARGE_AMOUNT), SUM(A.BILL_AMOUNT)
		INTO v_CHARGE_AMOUNT, v_BILL_AMOUNT
		FROM TRANSMISSION_CHARGE A, BILLING_STATEMENT B
		WHERE B.ENTITY_ID = p_ENTITY_ID
			AND B.PRODUCT_ID = p_PRODUCT_ID
			AND B.COMPONENT_ID = p_COMPONENT_ID
			AND B.STATEMENT_TYPE = p_STATEMENT_TYPE
			AND B.STATEMENT_STATE = p_STATEMENT_STATE
			AND B.STATEMENT_DATE BETWEEN p_STATEMENT_DATE AND p_STATEMENT_END_DATE
			AND B.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
								FROM BILLING_STATEMENT
								WHERE ENTITY_ID = B.ENTITY_ID
									AND PRODUCT_ID = B.PRODUCT_ID
									AND COMPONENT_ID = B.COMPONENT_ID
									AND STATEMENT_TYPE = B.STATEMENT_TYPE
									AND STATEMENT_STATE = B.STATEMENT_STATE
									AND STATEMENT_DATE = B.STATEMENT_DATE
									AND AS_OF_DATE <= p_AS_OF_DATE)
			AND A.CHARGE_ID = B.CHARGE_ID
			AND A.CHARGE_DATE = p_DISPUTE_DATE;
	ELSIF UPPER(v_CHARGE_VIEW_TYPE) = 'OP PROFIT' THEN
		SELECT SUM(A.CHARGE_AMOUNT), SUM(A.BILL_AMOUNT)
		INTO v_CHARGE_AMOUNT, v_BILL_AMOUNT
		FROM OPER_PROFIT_CHARGE A, BILLING_STATEMENT B
		WHERE B.ENTITY_ID = p_ENTITY_ID
			AND B.PRODUCT_ID = p_PRODUCT_ID
			AND B.COMPONENT_ID = p_COMPONENT_ID
			AND B.STATEMENT_TYPE = p_STATEMENT_TYPE
			AND B.STATEMENT_STATE = p_STATEMENT_STATE
			AND B.STATEMENT_DATE BETWEEN p_STATEMENT_DATE AND p_STATEMENT_END_DATE
			AND B.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
								FROM BILLING_STATEMENT
								WHERE ENTITY_ID = B.ENTITY_ID
									AND PRODUCT_ID = B.PRODUCT_ID
									AND COMPONENT_ID = B.COMPONENT_ID
									AND STATEMENT_TYPE = B.STATEMENT_TYPE
									AND STATEMENT_STATE = B.STATEMENT_STATE
									AND STATEMENT_DATE = B.STATEMENT_DATE
									AND AS_OF_DATE <= p_AS_OF_DATE)
			AND A.CHARGE_ID = B.CHARGE_ID
			AND A.CHARGE_DATE = p_DISPUTE_DATE;
	ELSIF UPPER(v_CHARGE_VIEW_TYPE) = 'CONVERSION' THEN
		SELECT SUM(A.CHARGE_AMOUNT), SUM(A.BILL_AMOUNT),SUM(A.CHARGE_QUANTITY),SUM(A.BILL_QUANTITY)
		INTO v_CHARGE_AMOUNT, v_BILL_AMOUNT, v_CHARGE_QUANTITY, v_BILL_QUANTITY
		FROM CONVERSION_CHARGE A, BILLING_STATEMENT B
		WHERE B.ENTITY_ID = p_ENTITY_ID
			AND B.PRODUCT_ID = p_PRODUCT_ID
			AND B.COMPONENT_ID = p_COMPONENT_ID
			AND B.STATEMENT_TYPE = p_STATEMENT_TYPE
			AND B.STATEMENT_STATE = p_STATEMENT_STATE
			AND B.STATEMENT_DATE BETWEEN p_STATEMENT_DATE AND p_STATEMENT_END_DATE
			AND B.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
								FROM BILLING_STATEMENT
								WHERE ENTITY_ID = B.ENTITY_ID
									AND PRODUCT_ID = B.PRODUCT_ID
									AND COMPONENT_ID = B.COMPONENT_ID
									AND STATEMENT_TYPE = B.STATEMENT_TYPE
									AND STATEMENT_STATE = B.STATEMENT_STATE
									AND STATEMENT_DATE = B.STATEMENT_DATE
									AND AS_OF_DATE <= p_AS_OF_DATE)
			AND A.CHARGE_ID = B.CHARGE_ID
			AND A.CHARGE_DATE = p_DISPUTE_DATE;
	ELSIF UPPER(v_CHARGE_VIEW_TYPE) = 'FORMULA' THEN
		SELECT SUM(A.CHARGE_AMOUNT), SUM(A.BILL_AMOUNT),SUM(A.CHARGE_QUANTITY),SUM(A.BILL_QUANTITY)
		INTO v_CHARGE_AMOUNT, v_BILL_AMOUNT, v_CHARGE_QUANTITY, v_BILL_QUANTITY
		FROM FORMULA_CHARGE A, BILLING_STATEMENT B, FORMULA_CHARGE_ITERATOR FCI
		WHERE B.ENTITY_ID = p_ENTITY_ID
			AND B.PRODUCT_ID = p_PRODUCT_ID
			AND B.COMPONENT_ID = p_COMPONENT_ID
			AND B.STATEMENT_TYPE = p_STATEMENT_TYPE
			AND B.STATEMENT_STATE = p_STATEMENT_STATE
			AND B.STATEMENT_DATE BETWEEN p_STATEMENT_DATE AND p_STATEMENT_END_DATE
			AND FCI.CHARGE_ID = B.CHARGE_ID
			AND (FCI.ITERATOR1 = p_ITERATOR1 OR p_ITERATOR1 IS NULL)
			AND (FCI.ITERATOR2 = p_ITERATOR2 OR p_ITERATOR2 IS NULL)
			AND (FCI.ITERATOR3 = p_ITERATOR3 OR p_ITERATOR3 IS NULL)
			AND (FCI.ITERATOR4 = p_ITERATOR4 OR p_ITERATOR4 IS NULL)
			AND (FCI.ITERATOR5 = p_ITERATOR5 OR p_ITERATOR5 IS NULL)
			AND (FCI.ITERATOR6 = p_ITERATOR6 OR p_ITERATOR6 IS NULL)
			AND (FCI.ITERATOR7 = p_ITERATOR7 OR p_ITERATOR7 IS NULL)
			AND (FCI.ITERATOR8 = p_ITERATOR8 OR p_ITERATOR8 IS NULL)
			AND (FCI.ITERATOR9 = p_ITERATOR9 OR p_ITERATOR9 IS NULL)
			AND (FCI.ITERATOR10 = p_ITERATOR10 OR p_ITERATOR10 IS NULL)
			AND B.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
								FROM BILLING_STATEMENT
								WHERE ENTITY_ID = B.ENTITY_ID
									AND PRODUCT_ID = B.PRODUCT_ID
									AND COMPONENT_ID = B.COMPONENT_ID
									AND STATEMENT_TYPE = B.STATEMENT_TYPE
									AND STATEMENT_STATE = B.STATEMENT_STATE
									AND STATEMENT_DATE = B.STATEMENT_DATE
									AND AS_OF_DATE <= p_AS_OF_DATE)
			AND A.CHARGE_ID = B.CHARGE_ID
			AND A.ITERATOR_ID = FCI.ITERATOR_ID
			AND A.CHARGE_DATE = p_DISPUTE_DATE;
	ELSIF SUBSTR(UPPER(v_CHARGE_VIEW_TYPE),1,3) = 'LMP' THEN
		SELECT SUM(A.CHARGE_AMOUNT), SUM(A.BILL_AMOUNT),SUM(A.CHARGE_QUANTITY),SUM(A.BILL_QUANTITY)
		INTO v_CHARGE_AMOUNT, v_BILL_AMOUNT, v_CHARGE_QUANTITY, v_BILL_QUANTITY
		FROM LMP_CHARGE A, BILLING_STATEMENT B
		WHERE B.ENTITY_ID = p_ENTITY_ID
			AND B.PRODUCT_ID = p_PRODUCT_ID
			AND B.COMPONENT_ID = p_COMPONENT_ID
			AND B.STATEMENT_TYPE = p_STATEMENT_TYPE
			AND B.STATEMENT_STATE = p_STATEMENT_STATE
			AND B.STATEMENT_DATE BETWEEN p_STATEMENT_DATE AND p_STATEMENT_END_DATE
			AND B.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
								FROM BILLING_STATEMENT
								WHERE ENTITY_ID = B.ENTITY_ID
									AND PRODUCT_ID = B.PRODUCT_ID
									AND COMPONENT_ID = B.COMPONENT_ID
									AND STATEMENT_TYPE = B.STATEMENT_TYPE
									AND STATEMENT_STATE = B.STATEMENT_STATE
									AND STATEMENT_DATE = B.STATEMENT_DATE
									AND AS_OF_DATE <= p_AS_OF_DATE)
			AND A.CHARGE_ID = B.CHARGE_ID
			AND A.CHARGE_DATE = p_DISPUTE_DATE;
	ELSIF SUBSTR(UPPER(v_CHARGE_VIEW_TYPE),1,3) = 'FTR' THEN
		SELECT SUM(A.CHARGE_AMOUNT), SUM(A.BILL_AMOUNT),SUM(A.CHARGE_QUANTITY),SUM(A.BILL_QUANTITY)
		INTO v_CHARGE_AMOUNT, v_BILL_AMOUNT, v_CHARGE_QUANTITY, v_BILL_QUANTITY
		FROM FTR_CHARGE A, BILLING_STATEMENT B
		WHERE B.ENTITY_ID = p_ENTITY_ID
			AND B.PRODUCT_ID = p_PRODUCT_ID
			AND B.COMPONENT_ID = p_COMPONENT_ID
			AND B.STATEMENT_TYPE = p_STATEMENT_TYPE
			AND B.STATEMENT_STATE = p_STATEMENT_STATE
			AND B.STATEMENT_DATE BETWEEN p_STATEMENT_DATE AND p_STATEMENT_END_DATE
			AND B.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
								FROM BILLING_STATEMENT
								WHERE ENTITY_ID = B.ENTITY_ID
									AND PRODUCT_ID = B.PRODUCT_ID
									AND COMPONENT_ID = B.COMPONENT_ID
									AND STATEMENT_TYPE = B.STATEMENT_TYPE
									AND STATEMENT_STATE = B.STATEMENT_STATE
									AND STATEMENT_DATE = B.STATEMENT_DATE
									AND AS_OF_DATE <= p_AS_OF_DATE)
			AND A.CHARGE_ID = B.CHARGE_ID
			AND A.CHARGE_DATE = p_DISPUTE_DATE;
	ELSIF UPPER(v_CHARGE_VIEW_TYPE) = 'COMBINATION' THEN
		SELECT SUM(A.CHARGE_AMOUNT), SUM(A.BILL_AMOUNT),SUM(A.CHARGE_QUANTITY),SUM(A.BILL_QUANTITY)
		INTO v_CHARGE_AMOUNT, v_BILL_AMOUNT, v_CHARGE_QUANTITY, v_BILL_QUANTITY
		FROM COMBINATION_CHARGE A, BILLING_STATEMENT B
		WHERE B.ENTITY_ID = p_ENTITY_ID
			AND B.PRODUCT_ID = p_PRODUCT_ID
			AND B.COMPONENT_ID = p_COMPONENT_ID
			AND B.STATEMENT_TYPE = p_STATEMENT_TYPE
			AND B.STATEMENT_STATE = p_STATEMENT_STATE
			AND B.STATEMENT_DATE BETWEEN p_STATEMENT_DATE AND p_STATEMENT_END_DATE
			AND B.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
								FROM BILLING_STATEMENT
								WHERE ENTITY_ID = B.ENTITY_ID
									AND PRODUCT_ID = B.PRODUCT_ID
									AND COMPONENT_ID = B.COMPONENT_ID
									AND STATEMENT_TYPE = B.STATEMENT_TYPE
									AND STATEMENT_STATE = B.STATEMENT_STATE
									AND STATEMENT_DATE = B.STATEMENT_DATE
									AND AS_OF_DATE <= p_AS_OF_DATE)
			AND A.CHARGE_ID = B.CHARGE_ID
			AND A.BEGIN_DATE = p_DISPUTE_DATE;
	ELSIF UPPER(v_CHARGE_VIEW_TYPE) = 'TAX CHARGE' THEN
		SELECT SUM(A.CHARGE_AMOUNT), SUM(A.BILL_AMOUNT),SUM(A.CHARGE_QUANTITY),SUM(A.BILL_QUANTITY)
		INTO v_CHARGE_AMOUNT, v_BILL_AMOUNT, v_CHARGE_QUANTITY, v_BILL_QUANTITY
		FROM TAX_CHARGE A, BILLING_STATEMENT B
		WHERE B.ENTITY_ID = p_ENTITY_ID
			AND B.PRODUCT_ID = p_PRODUCT_ID
			AND B.COMPONENT_ID = p_COMPONENT_ID
			AND B.STATEMENT_TYPE = p_STATEMENT_TYPE
			AND B.STATEMENT_STATE = p_STATEMENT_STATE
			AND B.STATEMENT_DATE BETWEEN p_STATEMENT_DATE AND p_STATEMENT_END_DATE
			AND B.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
								FROM BILLING_STATEMENT
								WHERE ENTITY_ID = B.ENTITY_ID
									AND PRODUCT_ID = B.PRODUCT_ID
									AND COMPONENT_ID = B.COMPONENT_ID
									AND STATEMENT_TYPE = B.STATEMENT_TYPE
									AND STATEMENT_STATE = B.STATEMENT_STATE
									AND STATEMENT_DATE = B.STATEMENT_DATE
									AND AS_OF_DATE <= p_AS_OF_DATE)
			AND A.CHARGE_ID = B.CHARGE_ID
			AND A.CHARGE_DATE = p_DISPUTE_DATE;
	ELSIF UPPER(v_CHARGE_VIEW_TYPE) = 'PIPELINE' THEN
		SELECT SUM(A.CHARGE_AMOUNT), SUM(A.BILL_AMOUNT),SUM(A.CHARGE_QUANTITY),SUM(A.BILL_QUANTITY)
		INTO v_CHARGE_AMOUNT, v_BILL_AMOUNT, v_CHARGE_QUANTITY, v_BILL_QUANTITY
		FROM PIPELINE_CHARGE A, BILLING_STATEMENT B
		WHERE B.ENTITY_ID = p_ENTITY_ID
			AND B.PRODUCT_ID = p_PRODUCT_ID
			AND B.COMPONENT_ID = p_COMPONENT_ID
			AND B.STATEMENT_TYPE = p_STATEMENT_TYPE
			AND B.STATEMENT_STATE = p_STATEMENT_STATE
			AND B.STATEMENT_DATE BETWEEN p_STATEMENT_DATE AND p_STATEMENT_END_DATE
			AND B.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
								FROM BILLING_STATEMENT
								WHERE ENTITY_ID = B.ENTITY_ID
									AND PRODUCT_ID = B.PRODUCT_ID
									AND COMPONENT_ID = B.COMPONENT_ID
									AND STATEMENT_TYPE = B.STATEMENT_TYPE
									AND STATEMENT_STATE = B.STATEMENT_STATE
									AND STATEMENT_DATE = B.STATEMENT_DATE
									AND AS_OF_DATE <= p_AS_OF_DATE)
			AND A.CHARGE_ID = B.CHARGE_ID
			AND A.CHARGE_DATE = p_DISPUTE_DATE;
	ELSE -- IF UPPER(p_CHARGE_VIEW_TYPE) = 'EXTERNAL' THEN
		XS.GET_DISPUTE_AMOUNT(p_CALLING_MODULE,p_MODEL_ID,v_CHARGE_VIEW_TYPE,p_ENTITY_ID,p_PRODUCT_ID,p_COMPONENT_ID,p_STATEMENT_TYPE,p_STATEMENT_STATE,
								p_STATEMENT_DATE,p_STATEMENT_END_DATE,p_DISPUTE_DATE,p_AS_OF_DATE,v_CHARGE_AMOUNT,v_BILL_AMOUNT);
	END IF;

	IF NVL(p_SHOW_CHARGE_AMOUNT,0) <> 0 THEN
		p_AMOUNT := v_CHARGE_AMOUNT;
		p_QUANTITY := v_CHARGE_QUANTITY;
	ELSE
		p_AMOUNT := v_BILL_AMOUNT;
		p_QUANTITY := v_BILL_QUANTITY;
	END IF;

END GET_DISPUTE_AMOUNT;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_CHARGE_DISPUTE_DETAILS
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_STATEMENT_TYPE1 IN NUMBER,
	p_STATEMENT_STATE1 IN NUMBER,
	p_STATEMENT_TYPE2 IN NUMBER,
	p_STATEMENT_STATE2 IN NUMBER,
	p_STATEMENT_DATE IN DATE,
	p_STATEMENT_END_DATE IN DATE,
	p_CHARGE_DATE IN STRING_COLLECTION,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
    p_SHOW_CHARGE_AMOUNT IN NUMBER,
	p_ITERATOR1	IN STRING_COLLECTION,
  	p_ITERATOR2 IN STRING_COLLECTION,
  	p_ITERATOR3 IN STRING_COLLECTION,
  	p_ITERATOR4 IN STRING_COLLECTION,
  	p_ITERATOR5 IN STRING_COLLECTION,
  	p_ITERATOR6 IN STRING_COLLECTION,
  	p_ITERATOR7 IN STRING_COLLECTION,
 	p_ITERATOR8 IN STRING_COLLECTION,
  	p_ITERATOR9 IN STRING_COLLECTION,
  	p_ITERATOR10 IN STRING_COLLECTION,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
v_IDX BINARY_INTEGER;
v_DATE DATE;
v_ITERATOR1	VARCHAR2(246);
v_ITERATOR2 VARCHAR2(246);
v_ITERATOR3 VARCHAR2(246);
v_ITERATOR4 VARCHAR2(246);
v_ITERATOR5 VARCHAR2(246);
v_ITERATOR6 VARCHAR2(246);
v_ITERATOR7 VARCHAR2(246);
v_ITERATOR8 VARCHAR2(246);
v_ITERATOR9 VARCHAR2(246);
v_ITERATOR10 VARCHAR2(246);
v_DISPUTE_DETAILS DISPUTE_DETAIL_TABLE := DISPUTE_DETAIL_TABLE();
v_DISPUTE_DETAIL_REC DISPUTE_DETAIL_TYPE;
v_BILLING_CHARGE_DISPUTE BILLING_CHARGE_DISPUTE%ROWTYPE;
BEGIN
	-- build table of data - combine data for existing disputes plus
	-- query data for new disputes to initiate
	v_IDX := p_CHARGE_DATE.FIRST;
	WHILE p_CHARGE_DATE.EXISTS(v_IDX) LOOP
		v_DATE := DATE_TIME_AS_CUT(TRIM(SUBSTR(p_CHARGE_DATE(v_IDX),1,10)),
								   TRIM(SUBSTR(p_CHARGE_DATE(v_IDX),12)),
								   p_TIME_ZONE, 1);
		IF p_ITERATOR1.EXISTS(v_IDX) THEN v_ITERATOR1 := p_ITERATOR1(v_IDX); END IF;
		IF p_ITERATOR2.EXISTS(v_IDX) THEN v_ITERATOR2 := p_ITERATOR2(v_IDX); END IF;
		IF p_ITERATOR3.EXISTS(v_IDX) THEN v_ITERATOR3 := p_ITERATOR3(v_IDX); END IF;
		IF p_ITERATOR4.EXISTS(v_IDX) THEN v_ITERATOR4 := p_ITERATOR4(v_IDX); END IF;
		IF p_ITERATOR5.EXISTS(v_IDX) THEN v_ITERATOR5 := p_ITERATOR5(v_IDX); END IF;
		IF p_ITERATOR6.EXISTS(v_IDX) THEN v_ITERATOR6 := p_ITERATOR6(v_IDX); END IF;
		IF p_ITERATOR7.EXISTS(v_IDX) THEN v_ITERATOR7 := p_ITERATOR7(v_IDX); END IF;
		IF p_ITERATOR8.EXISTS(v_IDX) THEN v_ITERATOR8 := p_ITERATOR8(v_IDX); END IF;
		IF p_ITERATOR9.EXISTS(v_IDX) THEN v_ITERATOR9 := p_ITERATOR9(v_IDX); END IF;
		IF p_ITERATOR10.EXISTS(v_IDX) THEN v_ITERATOR10 := p_ITERATOR10(v_IDX); END IF;

		BEGIN
			-- existing dispute record? then load data for it
			SELECT *
			INTO v_BILLING_CHARGE_DISPUTE
			FROM BILLING_CHARGE_DISPUTE
			WHERE ENTITY_ID = p_ENTITY_ID
				AND PRODUCT_ID = p_PRODUCT_ID
				AND COMPONENT_ID = p_COMPONENT_ID
				AND STATEMENT_TYPE = p_STATEMENT_TYPE1
				AND STATEMENT_STATE = p_STATEMENT_STATE1
				AND STATEMENT_DATE BETWEEN p_STATEMENT_DATE AND p_STATEMENT_END_DATE
				AND DISPUTE_DATE = v_DATE
				AND (ITERATOR1 = v_ITERATOR1 OR v_ITERATOR1 IS NULL)
				AND (ITERATOR2 = v_ITERATOR2 OR v_ITERATOR2 IS NULL)
				AND (ITERATOR3 = v_ITERATOR3 OR v_ITERATOR3 IS NULL)
				AND (ITERATOR4 = v_ITERATOR4 OR v_ITERATOR4 IS NULL)
				AND (ITERATOR5 = v_ITERATOR5 OR v_ITERATOR5 IS NULL)
				AND (ITERATOR6 = v_ITERATOR6 OR v_ITERATOR6 IS NULL)
				AND (ITERATOR7 = v_ITERATOR7 OR v_ITERATOR7 IS NULL)
				AND (ITERATOR8 = v_ITERATOR8 OR v_ITERATOR8 IS NULL)
				AND (ITERATOR9 = v_ITERATOR9 OR v_ITERATOR9 IS NULL)
				AND (ITERATOR10 = v_ITERATOR10 OR v_ITERATOR10 IS NULL);
			v_DISPUTE_DETAIL_REC := DISPUTE_DETAIL_TYPE(
					v_DATE,
					v_BILLING_CHARGE_DISPUTE.ITERATOR1,
					v_BILLING_CHARGE_DISPUTE.ITERATOR2,
					v_BILLING_CHARGE_DISPUTE.ITERATOR3,
					v_BILLING_CHARGE_DISPUTE.ITERATOR4,
					v_BILLING_CHARGE_DISPUTE.ITERATOR5,
					v_BILLING_CHARGE_DISPUTE.ITERATOR6,
					v_BILLING_CHARGE_DISPUTE.ITERATOR7,
					v_BILLING_CHARGE_DISPUTE.ITERATOR8,
					v_BILLING_CHARGE_DISPUTE.ITERATOR9,
					v_BILLING_CHARGE_DISPUTE.ITERATOR10,
					0,
					v_BILLING_CHARGE_DISPUTE.DISPUTE_STATUS,
					v_BILLING_CHARGE_DISPUTE.SUBMIT_STATUS,
					v_BILLING_CHARGE_DISPUTE.MARKET_STATUS,
					v_BILLING_CHARGE_DISPUTE.OLD_BILL_AMOUNT,
					v_BILLING_CHARGE_DISPUTE.NEW_BILL_AMOUNT,
					v_BILLING_CHARGE_DISPUTE.OLD_BILL_QUANTITY,
					v_BILLING_CHARGE_DISPUTE.NEW_BILL_QUANTITY,
					v_BILLING_CHARGE_DISPUTE.DISPUTE_DESC,
					v_BILLING_CHARGE_DISPUTE.ENTRY_DATE
					);
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				-- no existing dispute record? then create one
    			v_DISPUTE_DETAIL_REC := DISPUTE_DETAIL_TYPE(
    					v_DATE,
						v_ITERATOR1,
  						v_ITERATOR2,
						v_ITERATOR3,
						v_ITERATOR4,
						v_ITERATOR5,
						v_ITERATOR6,
						v_ITERATOR7,
						v_ITERATOR8,
						v_ITERATOR9,
						v_ITERATOR10,
						1,
    					'Pending',
    					NULL,
    					NULL,
    					0,
    					0,
						0,
						0,
    					NULL,
    					NULL
    					);
				-- populate amounts
				GET_DISPUTE_AMOUNT(p_CALLING_MODULE, p_MODEL_ID,
									p_ENTITY_ID, p_PRODUCT_ID, p_COMPONENT_ID,
									p_STATEMENT_TYPE1, p_STATEMENT_STATE1,
									p_STATEMENT_DATE, p_STATEMENT_END_DATE,
									p_AS_OF_DATE, p_SHOW_CHARGE_AMOUNT, v_DATE,
									v_ITERATOR1,
									v_ITERATOR2,
									v_ITERATOR3,
									v_ITERATOR4,
									v_ITERATOR5,
									v_ITERATOR6,
									v_ITERATOR7,
									v_ITERATOR8,
									v_ITERATOR9,
									v_ITERATOR10,
									v_DISPUTE_DETAIL_REC.NEW_BILL_AMOUNT,
									v_DISPUTE_DETAIL_REC.NEW_BILL_QUANTITY);
				GET_DISPUTE_AMOUNT(p_CALLING_MODULE, p_MODEL_ID,
									p_ENTITY_ID, p_PRODUCT_ID, p_COMPONENT_ID,
									p_STATEMENT_TYPE2, p_STATEMENT_STATE2,
									p_STATEMENT_DATE, p_STATEMENT_END_DATE,
									p_AS_OF_DATE, p_SHOW_CHARGE_AMOUNT, v_DATE,
									v_ITERATOR1,
									v_ITERATOR2,
									v_ITERATOR3,
									v_ITERATOR4,
									v_ITERATOR5,
									v_ITERATOR6,
									v_ITERATOR7,
									v_ITERATOR8,
									v_ITERATOR9,
									v_ITERATOR10,
									v_DISPUTE_DETAIL_REC.OLD_BILL_AMOUNT,
									v_DISPUTE_DETAIL_REC.OLD_BILL_QUANTITY);
		END;
		v_DISPUTE_DETAILS.EXTEND;
		v_DISPUTE_DETAILS(v_DISPUTE_DETAILS.LAST) := v_DISPUTE_DETAIL_REC;
		v_IDX := p_CHARGE_DATE.NEXT(v_IDX);
	END LOOP;

	-- give columns names so that we can use PUT_BILLING_CHARGE_DISPUTE to save
	OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(X.DISPUTE_DATE, p_TIME_ZONE, DECODE(TO_CHAR(X.DISPUTE_DATE,'SS'),'01','DD','MI5')) "DISPUTE_DATE",
				p_STATEMENT_TYPE1 "STATEMENT_TYPE",
				p_STATEMENT_STATE1 "STATEMENT_STATE",
				X.INITIATE,
				X.OLD_BILL_AMOUNT "BILLED_AMOUNT",
				X.NEW_BILL_AMOUNT "CORRECT_AMOUNT",
				X.OLD_BILL_QUANTITY "BILLED_QUANTITY",
				X.NEW_BILL_QUANTITY "CORRECT_QUANTITY",
				X.DISPUTE_STATUS,
				X.MARKET_STATUS,
				X.SUBMIT_STATUS,
				X.DISPUTE_DESC "DESCR",
				X.ITERATOR1,
				X.ITERATOR2,
				X.ITERATOR3,
				X.ITERATOR4,
				X.ITERATOR5,
				X.ITERATOR6,
				X.ITERATOR7,
				X.ITERATOR8,
				X.ITERATOR9,
				X.ITERATOR10,
				X.ENTRY_DATE
		FROM TABLE(CAST(v_DISPUTE_DETAILS AS DISPUTE_DETAIL_TABLE)) X
		ORDER BY 1;

END GET_CHARGE_DISPUTE_DETAILS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_BILLING_CHARGE_DISPUTE
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_STATEMENT_DATE IN DATE,
	p_DISPUTE_DATE IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_DISPUTE_STATUS IN VARCHAR,
	p_MARKET_STATUS IN VARCHAR,
	p_SUBMIT_STATUS IN VARCHAR,
	p_BILLED_AMOUNT IN NUMBER,
	p_CORRECT_AMOUNT IN NUMBER,
	p_BILLED_QUANTITY IN NUMBER,
	p_CORRECT_QUANTITY IN NUMBER,
	p_DESCR IN VARCHAR,
	p_ITERATOR1	IN VARCHAR2,
  	p_ITERATOR2 IN VARCHAR2,
  	p_ITERATOR3 IN VARCHAR2,
  	p_ITERATOR4 IN VARCHAR2,
  	p_ITERATOR5 IN VARCHAR2,
  	p_ITERATOR6 IN VARCHAR2,
  	p_ITERATOR7 IN VARCHAR2,
 	p_ITERATOR8 IN VARCHAR2,
  	p_ITERATOR9 IN VARCHAR2,
  	p_ITERATOR10 IN VARCHAR2,
	p_STATUS OUT NUMBER
	) AS
v_DISP_DATE_STR VARCHAR(16);
v_DISP_TIME_STR VARCHAR(16);
v_DISPUTE_DATE DATE;
BEGIN
	p_STATUS := GA.SUCCESS;

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING THEN
		IF p_STATEMENT_STATE = CONSTANTS.INTERNAL_STATE THEN
	   		SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_PSE_BILL_DISPUTES_INT, p_ENTITY_ID, EC.ED_PSE);
		ELSE
			SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_PSE_BILL_DISPUTES_EXT, p_ENTITY_ID, EC.ED_PSE);
		END IF;
	END IF;

	SELECT SUBSTR(LTRIM(RTRIM(p_DISPUTE_DATE)),1,10) INTO v_DISP_DATE_STR FROM DUAL;
	SELECT SUBSTR(LTRIM(RTRIM(p_DISPUTE_DATE)),12) INTO v_DISP_TIME_STR FROM DUAL;
    v_DISPUTE_DATE := DATE_TIME_AS_CUT(v_DISP_DATE_STR,v_DISP_TIME_STR,p_TIME_ZONE,1);

	UPDATE BILLING_CHARGE_DISPUTE
	SET DISPUTE_STATUS = NVL(p_DISPUTE_STATUS,DISPUTE_STATUS),
    	MARKET_STATUS = NVL(p_MARKET_STATUS,MARKET_STATUS),
        SUBMIT_STATUS = NVL(p_SUBMIT_STATUS,SUBMIT_STATUS),
		OLD_BILL_AMOUNT = NVL(p_BILLED_AMOUNT,OLD_BILL_AMOUNT),
		NEW_BILL_AMOUNT = NVL(p_CORRECT_AMOUNT,NEW_BILL_AMOUNT),
		OLD_BILL_QUANTITY = NVL(p_BILLED_QUANTITY,OLD_BILL_QUANTITY),
		NEW_BILL_QUANTITY = NVL(p_CORRECT_QUANTITY,NEW_BILL_QUANTITY),
		DISPUTE_DESC = NVL(p_DESCR,DISPUTE_DESC)
	WHERE ENTITY_ID = p_ENTITY_ID
		AND PRODUCT_ID = p_PRODUCT_ID
		AND COMPONENT_ID = p_COMPONENT_ID
		AND STATEMENT_TYPE = p_STATEMENT_TYPE
		AND STATEMENT_STATE = p_STATEMENT_STATE
        AND STATEMENT_DATE = p_STATEMENT_DATE
		AND DISPUTE_DATE = v_DISPUTE_DATE
		AND (ITERATOR1 = p_ITERATOR1 OR p_ITERATOR1 IS NULL)
		AND (ITERATOR2 = p_ITERATOR2 OR p_ITERATOR2 IS NULL)
		AND (ITERATOR3 = p_ITERATOR3 OR p_ITERATOR3 IS NULL)
		AND (ITERATOR4 = p_ITERATOR4 OR p_ITERATOR4 IS NULL)
		AND (ITERATOR5 = p_ITERATOR5 OR p_ITERATOR5 IS NULL)
		AND (ITERATOR6 = p_ITERATOR6 OR p_ITERATOR6 IS NULL)
		AND (ITERATOR7 = p_ITERATOR7 OR p_ITERATOR7 IS NULL)
		AND (ITERATOR8 = p_ITERATOR8 OR p_ITERATOR8 IS NULL)
		AND (ITERATOR9 = p_ITERATOR9 OR p_ITERATOR9 IS NULL)
		AND (ITERATOR10 = p_ITERATOR10 OR p_ITERATOR10 IS NULL);

	IF SQL%NOTFOUND THEN
		INSERT INTO BILLING_CHARGE_DISPUTE (
			ENTITY_ID,
			PRODUCT_ID,
			COMPONENT_ID,
			STATEMENT_TYPE,
			STATEMENT_STATE,
            STATEMENT_DATE,
			DISPUTE_DATE,
			DISPUTE_STATUS,
            MARKET_STATUS,
            SUBMIT_STATUS,
			OLD_BILL_AMOUNT,
			NEW_BILL_AMOUNT,
			OLD_BILL_QUANTITY,
			NEW_BILL_QUANTITY,
			DISPUTE_DESC,
			ITERATOR1,
			ITERATOR2,
			ITERATOR3,
			ITERATOR4,
			ITERATOR5,
			ITERATOR6,
			ITERATOR7,
			ITERATOR8,
			ITERATOR9,
			ITERATOR10,
			ENTRY_DATE
		) VALUES (
			p_ENTITY_ID,
			p_PRODUCT_ID,
			p_COMPONENT_ID,
			p_STATEMENT_TYPE,
			p_STATEMENT_STATE,
            p_STATEMENT_DATE,
			v_DISPUTE_DATE,
			p_DISPUTE_STATUS,
            p_MARKET_STATUS,
            p_SUBMIT_STATUS,
			p_BILLED_AMOUNT,
			p_CORRECT_AMOUNT,
			p_BILLED_QUANTITY,
			p_CORRECT_QUANTITY,
			p_DESCR,
			p_ITERATOR1,
			p_ITERATOR2,
			p_ITERATOR3,
			p_ITERATOR4,
			p_ITERATOR5,
			p_ITERATOR6,
			p_ITERATOR7,
			p_ITERATOR8,
			p_ITERATOR9,
			p_ITERATOR10,
			SYSDATE
		);
	END IF;

END PUT_BILLING_CHARGE_DISPUTE;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_STATEMENT_STATUS
	(
    p_CALLING_MODULE IN VARCHAR,
    p_MODEL_ID IN NUMBER,
    p_ENTITY_ID IN NUMBER,
    p_STATEMENT_DATE IN DATE,
    p_STATEMENT_TYPE IN NUMBER,
    p_STATEMENT_STATE IN NUMBER,
    p_AS_OF_DATE IN DATE,
    p_REVIEW_STATUS IN VARCHAR,
    p_NOTES IN VARCHAR,
    p_STATUS OUT NUMBER
    ) AS
BEGIN
	p_STATUS := GA.SUCCESS;
	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING THEN
	   SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_PSE_BILL_STATUS, p_ENTITY_ID, EC.ED_PSE);
	END IF;

    UPDATE BILLING_STATEMENT_STATUS
    SET REVIEW_STATUS = p_REVIEW_STATUS,
    	NOTES = p_NOTES
	WHERE ENTITY_ID = p_ENTITY_ID
    	AND STATEMENT_TYPE = p_STATEMENT_TYPE
        AND STATEMENT_STATE = p_STATEMENT_STATE
        AND STATEMENT_DATE = p_STATEMENT_DATE
        AND AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
	        			FROM BILLING_STATEMENT_STATUS
	                    WHERE ENTITY_ID = p_ENTITY_ID
                        	AND STATEMENT_TYPE = p_STATEMENT_TYPE
                            AND STATEMENT_STATE = p_STATEMENT_STATE
                            AND STATEMENT_DATE = p_STATEMENT_DATE
                        	AND AS_OF_DATE <= p_AS_OF_DATE);

END PUT_STATEMENT_STATUS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_STATEMENT_STATUS_DETAILS
	(
    p_CALLING_MODULE IN VARCHAR,
    p_MODEL_ID IN NUMBER,
    p_ENTITY_ID IN NUMBER,
    p_STATEMENT_DATE IN DATE,
    p_STATEMENT_TYPE IN NUMBER,
    p_STATEMENT_STATE IN NUMBER,
    p_AS_OF_DATE IN DATE,
    p_CURSOR IN OUT GA.REFCURSOR,
    p_STATUS OUT NUMBER
    ) AS
BEGIN
	p_STATUS := GA.SUCCESS;
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    OPEN p_CURSOR FOR
	SELECT A.REVIEW_STATUS "REVIEW_STATUS",
		A.NOTES "NOTES",
		B.BEGIN_DATE "INVOICE_BEGIN_DATE",
		B.END_DATE "INVOICE_END_DATE",
		B.INVOICE_DATE "INVOICE_ENTRY_DATE",
		A.ENTRY_DATE "STATEMENT_ENTRY_DATE",
		CASE WHEN B.BEGIN_DATE IS NULL THEN NULL ELSE TO_CHAR(B.BEGIN_DATE, g_SHORT_DATE_FORMAT) || ' -> ' || TO_CHAR(B.END_DATE, g_SHORT_DATE_FORMAT) END "INVOICE_PERIOD",
		A.ENTITY_ID,
		A.STATEMENT_TYPE,
		A.STATEMENT_STATE,
		A.STATEMENT_DATE,
		A.AS_OF_DATE
	FROM BILLING_STATEMENT_STATUS A,
		INVOICE B
	WHERE A.ENTITY_ID = p_ENTITY_ID
		AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
		AND A.STATEMENT_STATE = p_STATEMENT_STATE
		AND A.STATEMENT_DATE = TRUNC(p_STATEMENT_DATE)
		AND A.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM BILLING_STATEMENT_STATUS
			WHERE ENTITY_ID = A.ENTITY_ID
				AND STATEMENT_TYPE = A.STATEMENT_TYPE
				AND STATEMENT_STATE = A.STATEMENT_STATE
				AND STATEMENT_DATE = A.STATEMENT_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE)
	    AND B.ENTITY_ID(+) = A.ENTITY_ID
		AND B.STATEMENT_TYPE(+) = A.STATEMENT_TYPE
		AND B.STATEMENT_STATE(+) = A.STATEMENT_STATE
		AND B.BEGIN_DATE(+) <= A.STATEMENT_DATE
		AND B.END_DATE(+) >= A.STATEMENT_DATE
		AND B.AS_OF_DATE(+) = INVOICE_AS_OF_DATE(A.ENTITY_ID,A.STATEMENT_TYPE,A.STATEMENT_STATE,A.STATEMENT_DATE,p_AS_OF_DATE)
		AND ROWNUM = 1; -- just in case we somehow have more then one row

END GET_STATEMENT_STATUS_DETAILS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_STATEMENT_STATUS
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
v_NUMBER_TABLE ID_TABLE;
v_WORK_ID NUMBER;
v_INDEX BINARY_INTEGER;
v_COUNT BINARY_INTEGER;
v_ID NUMBER;
BEGIN

	p_STATUS := GA.SUCCESS;

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	IF p_ENTITY_ID = CONSTANTS.ALL_ID THEN
		v_NUMBER_TABLE := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_PSE_BILL_SELECT);
	ELSE
		v_NUMBER_TABLE := ID_TABLE();
		v_NUMBER_TABLE.EXTEND;
		v_NUMBER_TABLE(v_NUMBER_TABLE.LAST) := ID_TYPE(p_ENTITY_ID);
	END IF;

    -- retrieve multiple or one entity-IDs into a table
	UT.GET_RTO_WORK_ID(v_WORK_ID);
    v_INDEX := v_NUMBER_TABLE.FIRST;
	v_COUNT := 0;
    WHILE v_NUMBER_TABLE.EXISTS(v_INDEX) LOOP
		v_ID := v_NUMBER_TABLE(v_INDEX).ID;
		INSERT INTO RTO_WORK (WORK_ID, WORK_XID)
		  	VALUES (v_WORK_ID, v_ID);
		v_COUNT := v_COUNT+1;
    	v_INDEX := v_NUMBER_TABLE.NEXT(v_INDEX);
    END LOOP;

	v_NUMBER_TABLE.DELETE;

	OPEN p_CURSOR FOR
		SELECT A.ENTITY_ID "ENTITY_ID",
            PSE.PSE_NAME "ENTITY_NAME",
			A.STATEMENT_TYPE,
			A.STATEMENT_STATE,
			A.STATEMENT_DATE,
            A.AS_OF_DATE,
            A.REVIEW_STATUS,
			B.INVOICE_DATE "INVOICE_ENTRY_DATE",
			A.ENTRY_DATE "STATEMENT_ENTRY_DATE",
            G.STATEMENT_TYPE_NAME,
			G.STATEMENT_TYPE_ORDER,
            -- This is for column name in the anchored master grid.
            (CASE A.STATEMENT_STATE
                              when 1 then 'Internal'
                              when 2 then 'External'
                              else 'Unknown'
                              End) AS STATEMENT_STATE_NAME,
            -- Checking if INVOICE IS available or not
            (CASE
                              when B.INVOICE_DATE IS NULL then 0
                              else 1
                              End) AS INVOICE_AVAILABLE,
            -- Checking if statement is available or not
            (CASE
                              when A.ENTRY_DATE IS NULL then 0
                              else 1
                              End) AS STATEMENT_AVAILABLE
		FROM BILLING_STATEMENT_STATUS A,
			PURCHASING_SELLING_ENTITY PSE,
			RTO_WORK X,
			INVOICE B,
            STATEMENT_TYPE G
		WHERE X.WORK_ID = v_WORK_ID
            AND (PSE.PSE_ID = X.WORK_XID OR X.WORK_XID = SD.g_ALL_DATA_ENTITY_ID)
            AND A.ENTITY_ID = PSE.PSE_ID
			AND A.STATEMENT_TYPE > 0
			AND A.STATEMENT_STATE IN (CONSTANTS.INTERNAL_STATE,CONSTANTS.EXTERNAL_STATE)
			AND A.STATEMENT_DATE BETWEEN PC.GET_CORRECT_STATEMENT_DATE(p_CALLING_MODULE,A.ENTITY_ID,p_BEGIN_DATE) AND PC.GET_CORRECT_STATEMENT_DATE(p_CALLING_MODULE,A.ENTITY_ID,p_END_DATE)
			AND A.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM BILLING_STATEMENT_STATUS
				WHERE ENTITY_ID = A.ENTITY_ID
					AND STATEMENT_TYPE = A.STATEMENT_TYPE
					AND STATEMENT_STATE = A.STATEMENT_STATE
					AND STATEMENT_DATE = A.STATEMENT_DATE
					AND AS_OF_DATE <= p_AS_OF_DATE)
			AND B.STATEMENT_TYPE(+) = A.STATEMENT_TYPE
			AND B.STATEMENT_STATE(+) = A.STATEMENT_STATE
			AND B.BEGIN_DATE(+) <= A.STATEMENT_DATE
			AND B.END_DATE(+) >= A.STATEMENT_DATE
			AND B.AS_OF_DATE(+) = INVOICE_AS_OF_DATE(A.ENTITY_ID,A.STATEMENT_TYPE,A.STATEMENT_STATE,A.STATEMENT_DATE,p_AS_OF_DATE)
            AND B.ENTITY_ID(+) = A.ENTITY_ID
            AND G.STATEMENT_TYPE_ID = A.STATEMENT_TYPE;

    UT.PURGE_RTO_WORK(v_WORK_ID);
EXCEPTION
		 WHEN OTHERS THEN
		 	  UT.PURGE_RTO_WORK(v_WORK_ID);
              ERRS.LOG_AND_RAISE();

END GET_STATEMENT_STATUS;
---------------------------------------------------------------------------------------------------------------------------------------
PROCEDURE GET_PSE_DISPUTE_STATUS
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_STATUS_FILTER IN VARCHAR,
	p_STATEMENT_TYPE IN NUMBER,
    p_STATEMENT_INTERVAL IN DATE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_VALID_IDs ID_TABLE;
v_STATUS_FILTER VARCHAR2(64);
BEGIN

	p_STATUS := GA.SUCCESS;

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	IF p_ENTITY_ID = CONSTANTS.ALL_ID THEN
		v_VALID_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_PSE_BILL_SELECT);
	ELSE
		v_VALID_IDs := ID_TABLE();
		v_VALID_IDs.EXTEND();
		v_VALID_IDs(v_VALID_IDs.LAST) := ID_TYPE(p_ENTITY_ID);
	END IF;

	IF NVL(p_STATUS_FILTER,g_ALL_STRING) = g_ALL_STRING THEN
		v_STATUS_FILTER := '%';
	ELSE
		v_STATUS_FILTER := p_STATUS_FILTER;
	END IF;

	UT.CUT_DATE_RANGE(TRUNC(p_BEGIN_DATE), TRUNC(p_END_DATE), p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	OPEN p_CURSOR FOR
		SELECT B.PSE_NAME "BILL_ENTITY",
			C.PRODUCT_NAME "PRODUCT",
			D.COMPONENT_NAME "COMPONENT",
            A.STATEMENT_DATE,
            A.STATEMENT_DATE "STATEMENT_END_DATE",
			FROM_CUT_AS_HED(A.DISPUTE_DATE,p_TIME_ZONE,DECODE(TO_CHAR(A.DISPUTE_DATE,'SS'),'01','DD','MI5')) "DISPUTE_DATE",
			A.DISPUTE_STATUS,
			A.MARKET_STATUS,
			A.SUBMIT_STATUS,
			A.OLD_BILL_AMOUNT "BILLED_AMOUNT",
			A.NEW_BILL_AMOUNT "CORRECT_AMOUNT",
			A.DISPUTE_DESC "DESCR",
			A.ENTRY_DATE,
			A.ENTITY_ID,
			A.PRODUCT_ID,
			A.COMPONENT_ID,
			A.STATEMENT_TYPE,
			A.STATEMENT_STATE
		FROM BILLING_CHARGE_DISPUTE A,
			PURCHASING_SELLING_ENTITY B,
			PRODUCT C,
			COMPONENT D,
			TABLE(CAST(v_VALID_IDs AS ID_TABLE)) E
		WHERE E.ID IN (SD.g_ALL_DATA_ENTITY_ID, A.ENTITY_ID)
			AND (p_PRODUCT_ID = CONSTANTS.ALL_ID OR A.PRODUCT_ID = p_PRODUCT_ID)
			AND (p_COMPONENT_ID = CONSTANTS.ALL_ID OR A.COMPONENT_ID = p_COMPONENT_ID)
			AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
            AND A.STATEMENT_DATE = p_STATEMENT_INTERVAL
			AND A.DISPUTE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND A.DISPUTE_STATUS LIKE v_STATUS_FILTER
			AND B.PSE_ID = A.ENTITY_ID
			AND C.PRODUCT_ID = A.PRODUCT_ID
			AND D.COMPONENT_ID = A.COMPONENT_ID
		ORDER BY 1,2,3,4;

END GET_PSE_DISPUTE_STATUS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_POOL_DISPUTE_STATUS
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_STATUS_FILTER IN VARCHAR,
	p_STATEMENT_TYPE IN NUMBER,
    p_STATEMENT_INTERVAL IN DATE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
v_BEGIN_DATE DATE;
v_END_DATE DATE;
BEGIN

	p_STATUS := GA.SUCCESS;

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;
	UT.CUT_DATE_RANGE(TRUNC(p_BEGIN_DATE), TRUNC(p_END_DATE), p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	OPEN p_CURSOR FOR
		SELECT B.POOL_NAME "BILL_ENTITY",
			C.PRODUCT_NAME "PRODUCT",
			D.COMPONENT_NAME "COMPONENT",
            A.STATEMENT_DATE,
			FROM_CUT_AS_HED(A.DISPUTE_DATE,p_TIME_ZONE,DECODE(TO_CHAR(A.DISPUTE_DATE,'SS'),'01','DD','MI5')) "DISPUTE_DATE",
			A.DISPUTE_STATUS,
			A.MARKET_STATUS,
			A.SUBMIT_STATUS,
			A.OLD_BILL_AMOUNT "BILLED_AMOUNT",
			A.NEW_BILL_AMOUNT "CORRECT_AMOUNT",
			A.OLD_BILL_AMOUNT-A.NEW_BILL_AMOUNT "DIFFERENCE",
			A.DISPUTE_DESC "DESCR",
			A.ENTRY_DATE,
			A.ENTITY_ID,
			A.PRODUCT_ID,
			A.COMPONENT_ID,
			A.STATEMENT_TYPE,
			A.STATEMENT_STATE
		FROM BILLING_CHARGE_DISPUTE A,
			POOL B,
			PRODUCT C,
			COMPONENT D
		WHERE (p_ENTITY_ID = CONSTANTS.ALL_ID OR A.ENTITY_ID = p_ENTITY_ID)
			AND (p_PRODUCT_ID = CONSTANTS.ALL_ID OR A.PRODUCT_ID = p_PRODUCT_ID)
			AND (p_COMPONENT_ID = CONSTANTS.ALL_ID OR A.COMPONENT_ID = p_COMPONENT_ID)
			AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
            AND A.STATEMENT_DATE = p_STATEMENT_INTERVAL
			AND A.DISPUTE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND (UPPER(p_STATUS_FILTER) = g_ALL_STRING OR UPPER(A.DISPUTE_STATUS) = UPPER(p_STATUS_FILTER))
			AND B.POOL_ID = A.ENTITY_ID
			AND C.PRODUCT_ID = A.PRODUCT_ID
			AND D.COMPONENT_ID = A.COMPONENT_ID
		ORDER BY 1,2,3,4;

END GET_POOL_DISPUTE_STATUS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_BP_DISPUTE_STATUS
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_STATUS_FILTER IN VARCHAR,
	p_STATEMENT_TYPE IN NUMBER,
    p_STATEMENT_INTERVAL IN DATE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
v_BEGIN_DATE DATE;
v_END_DATE DATE;
BEGIN

	p_STATUS := GA.SUCCESS;

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;
	UT.CUT_DATE_RANGE(TRUNC(p_BEGIN_DATE), TRUNC(p_END_DATE), p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	OPEN p_CURSOR FOR
		SELECT B.BILL_PARTY_NAME "BILL_ENTITY",
			C.PRODUCT_NAME "PRODUCT",
			D.COMPONENT_NAME "COMPONENT",
            A.STATEMENT_DATE,
			FROM_CUT_AS_HED(A.DISPUTE_DATE,p_TIME_ZONE,DECODE(TO_CHAR(A.DISPUTE_DATE,'SS'),'01','DD','MI5')) "DISPUTE_DATE",
			A.DISPUTE_STATUS,
			A.MARKET_STATUS,
			A.SUBMIT_STATUS,
			A.OLD_BILL_AMOUNT "BILLED_AMOUNT",
			A.NEW_BILL_AMOUNT "CORRECT_AMOUNT",
			A.OLD_BILL_AMOUNT-A.NEW_BILL_AMOUNT "DIFFERENCE",
			A.DISPUTE_DESC "DESCR",
			A.ENTRY_DATE,
			A.ENTITY_ID,
			A.PRODUCT_ID,
			A.COMPONENT_ID,
			A.STATEMENT_TYPE,
			A.STATEMENT_STATE
		FROM BILLING_CHARGE_DISPUTE A,
			BILL_PARTY B,
			PRODUCT C,
			COMPONENT D
		WHERE (p_ENTITY_ID = CONSTANTS.ALL_ID OR A.ENTITY_ID = p_ENTITY_ID)
			AND (p_PRODUCT_ID = CONSTANTS.ALL_ID OR A.PRODUCT_ID = p_PRODUCT_ID)
			AND (p_COMPONENT_ID = CONSTANTS.ALL_ID OR A.COMPONENT_ID = p_COMPONENT_ID)
			AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
            and A.STATEMENT_DATE = p_STATEMENT_INTERVAL
			AND A.DISPUTE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND (UPPER(p_STATUS_FILTER) = g_ALL_STRING OR UPPER(A.DISPUTE_STATUS) = UPPER(p_STATUS_FILTER))
			AND B.BILL_PARTY_ID = A.ENTITY_ID
			AND C.PRODUCT_ID = A.PRODUCT_ID
			AND D.COMPONENT_ID = A.COMPONENT_ID
		ORDER BY 1,2,3,4;

END GET_BP_DISPUTE_STATUS;

------------------------------------------------------------------------------------------------------------------------------------------------
PROCEDURE GET_DISPUTE_STATUS_MASTER
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_STATUS_FILTER IN VARCHAR,
	p_STATEMENT_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
    v_BEGIN_DATE DATE;
    v_END_DATE DATE;
    v_VALID_IDs ID_TABLE;

    BEGIN

	p_STATUS := GA.SUCCESS;

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    UT.CUT_DATE_RANGE(TRUNC(p_BEGIN_DATE), TRUNC(p_END_DATE), p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

    IF p_ENTITY_ID = CONSTANTS.ALL_ID THEN
		v_VALID_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_PSE_BILL_SELECT);
	ELSE
		v_VALID_IDs := ID_TABLE();
		v_VALID_IDs.EXTEND();
		v_VALID_IDs(v_VALID_IDs.LAST) := ID_TYPE(p_ENTITY_ID);
	END IF;

    OPEN p_CURSOR FOR
         SELECT B.PSE_NAME "ENTITY_NAME",
            A.ENTITY_ID "ENTITY_ID",
            A.STATEMENT_DATE "STATEMENT_DATE",
            SUM(CASE WHEN A.DISPUTE_STATUS = 'Cancelled' OR A.DISPUTE_STATUS = 'Resolved' THEN 1 ELSE 0 END) "CLOSED_DISPUTES",
            SUM(CASE WHEN A.DISPUTE_STATUS = 'Pending' OR A.DISPUTE_STATUS = 'Submitted' THEN 1 ELSE 0 END) "OPEN_DISPUTES",
            SUM(CASE WHEN A.DISPUTE_STATUS = 'Rejected' THEN 1 ELSE 0 END) "REJECTED_DISPUTES"
              FROM BILLING_CHARGE_DISPUTE A,
                     PURCHASING_SELLING_ENTITY B,
                     TABLE(CAST(v_VALID_IDs AS ID_TABLE)) E
              WHERE E.ID IN (SD.g_ALL_DATA_ENTITY_ID, A.ENTITY_ID)
                     AND (p_PRODUCT_ID = CONSTANTS.ALL_ID OR A.PRODUCT_ID = p_PRODUCT_ID)
                     AND (p_COMPONENT_ID = CONSTANTS.ALL_ID OR A.COMPONENT_ID = p_COMPONENT_ID)
                     AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
                     AND A.DISPUTE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
            --  PBM - I am not sure that you want to filter this query by status type.
            --  I am leaving this code here for now. We can remove later.
            --       AND (UPPER(p_STATUS_FILTER) = g_ALL_STRING OR UPPER(A.DISPUTE_STATUS) = UPPER(p_STATUS_FILTER))
                     AND B.PSE_ID = A.ENTITY_ID
              GROUP BY B.PSE_NAME, A.ENTITY_ID, A.STATEMENT_DATE
        ORDER BY 1,2,3;

END GET_DISPUTE_STATUS_MASTER;

----------------------------------------------------------------------------------------------------------------------------------------------

PROCEDURE GET_DISPUTE_STATUS_DETAIL
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_STATUS_FILTER IN VARCHAR,
	p_STATEMENT_TYPE IN NUMBER,
    p_STATEMENT_DATE IN DATE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

    BEGIN

	p_STATUS := GA.SUCCESS;
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_POSITION_AND_BILLING THEN
		GET_BP_DISPUTE_STATUS(p_CALLING_MODULE, p_MODEL_ID, p_ENTITY_ID, p_PRODUCT_ID, p_COMPONENT_ID, p_STATUS_FILTER, p_STATEMENT_TYPE,p_STATEMENT_DATE, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_STATUS, p_CURSOR);
	ELSIF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING THEN
		GET_PSE_DISPUTE_STATUS(p_CALLING_MODULE, p_MODEL_ID, p_ENTITY_ID, p_PRODUCT_ID, p_COMPONENT_ID, p_STATUS_FILTER, p_STATEMENT_TYPE,p_STATEMENT_DATE, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_STATUS, p_CURSOR);
	ELSIF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_GAS_DELIVERY THEN
		GET_POOL_DISPUTE_STATUS(p_CALLING_MODULE, p_MODEL_ID, p_ENTITY_ID, p_PRODUCT_ID, p_COMPONENT_ID, p_STATUS_FILTER, p_STATEMENT_TYPE,p_STATEMENT_DATE, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_STATUS, p_CURSOR);
	END IF;

END GET_DISPUTE_STATUS_DETAIL;
------------------------------------------------------------------------------------------------------------------------------------------------
PROCEDURE PRODUCT_NAMES
	(
	p_STATEMENT_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
BEGIN

	p_STATUS := GA.SUCCESS;
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	OPEN p_CURSOR FOR
		SELECT g_ALL_STRING, CONSTANTS.ALL_ID FROM DUAL
        UNION ALL
        SELECT DISTINCT B.PRODUCT_NAME, A.PRODUCT_ID
		FROM BILLING_STATEMENT A,
			PRODUCT B
		WHERE STATEMENT_TYPE = p_STATEMENT_TYPE
			AND STATEMENT_STATE = CONSTANTS.INTERNAL_STATE
			--AND STATEMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND A.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM BILLING_STATEMENT
				WHERE ENTITY_ID = A.ENTITY_ID
					AND PRODUCT_ID = A.PRODUCT_ID
					AND COMPONENT_ID = A.COMPONENT_ID
					AND STATEMENT_TYPE = A.STATEMENT_TYPE
					AND STATEMENT_STATE = A.STATEMENT_STATE
					AND STATEMENT_DATE = A.STATEMENT_DATE
					AND AS_OF_DATE <= p_AS_OF_DATE)
			AND B.PRODUCT_ID = A.PRODUCT_ID
		ORDER BY 1;

END PRODUCT_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE COMPONENT_CATEGORIES
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
BEGIN

    p_STATUS := GA.SUCCESS;
    OPEN p_CURSOR FOR
        SELECT DISTINCT A.COMPONENT_CATEGORY
        FROM COMPONENT A;

END COMPONENT_CATEGORIES;
---------------------------------------------------------------------------------------------------
PROCEDURE COMPONENT_NAMES
	(
	p_STATEMENT_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
BEGIN

	p_STATUS := GA.SUCCESS;
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	OPEN p_CURSOR FOR
        SELECT g_ALL_STRING, CONSTANTS.ALL_ID FROM DUAL
        UNION ALL
		SELECT DISTINCT B.COMPONENT_NAME, A.COMPONENT_ID
		FROM BILLING_STATEMENT A,
			COMPONENT B
		WHERE STATEMENT_TYPE = p_STATEMENT_TYPE
			AND STATEMENT_STATE = CONSTANTS.INTERNAL_STATE
--			AND STATEMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND A.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM BILLING_STATEMENT
				WHERE ENTITY_ID = A.ENTITY_ID
					AND PRODUCT_ID = A.PRODUCT_ID
					AND COMPONENT_ID = A.COMPONENT_ID
					AND STATEMENT_TYPE = A.STATEMENT_TYPE
					AND STATEMENT_STATE = A.STATEMENT_STATE
					AND STATEMENT_DATE = A.STATEMENT_DATE
					AND AS_OF_DATE <= p_AS_OF_DATE)
			AND B.COMPONENT_ID = A.COMPONENT_ID
		ORDER BY 1;

END COMPONENT_NAMES;
--------------------------------------------------------------------------------------------------------------------------------
PROCEDURE GET_INVOICE_COMPARISON
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_INVOICE_DATE IN VARCHAR2,
	p_AS_OF_DATE IN DATE,
    p_INVOICE_CATEGORY IN VARCHAR,
    p_COMPARISON_STATES_ID IN VARCHAR,
    p_DISPLAY_OPTION IN NUMBER,
    p_BILLING_PERIOD OUT VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
v_INVOICE_BEGIN_DATE DATE;
v_INVOICE_CATEGORY VARCHAR2(32);
v_STATEMENT_TYPES VARCHAR2(4000) := ','||p_COMPARISON_STATES_ID||',';
BEGIN
	p_STATUS := GA.SUCCESS;
	IF p_INVOICE_DATE IS NULL THEN
		v_INVOICE_BEGIN_DATE := NULL;
	ELSE
		v_INVOICE_BEGIN_DATE := TO_DATE(SUBSTR(p_INVOICE_DATE,1,10), g_SHORT_DATE_FORMAT);
	END IF;

   -- This is the output parameter for the label to be displayed with the Billing Period
    p_BILLING_PERIOD:= p_INVOICE_DATE;

    IF p_INVOICE_CATEGORY = '<ALL>' THEN
    	v_INVOICE_CATEGORY := '%';
	ELSE
    	v_INVOICE_CATEGORY := p_INVOICE_CATEGORY;
	END IF;

    -- the p_DISPLAY_OPTION parameter has the following possible values:
    --	1=default, 2=Charge, 3=Bill, 4=Charge and Bill

	OPEN p_CURSOR FOR
		-- to get all selected statement types for all possible invoice line item names, we will
		-- have to use an outer join of data to a cartesian merge of all line item names to all
		-- statement types/states
		SELECT A.LINE_ITEM_NAME,
			A.STATEMENT_STATE,
			A.STATEMENT_TYPE,
        	A.LINE_ITEM_TYPE,
        	B.LINE_ITEM_DEFAULT_AMOUNT,
        	B.LINE_ITEM_AMOUNT,
        	B.LINE_ITEM_BILL_AMOUNT,
        	A.STATEMENT_TYPE_NAME,
			A.STATEMENT_TYPE_ORDER,
        	A.STATEMENT_STATE_NAME
		FROM
			-- so first get the cartesian merge (because we can only outer join to a single table)
			(SELECT *
             -- first table in merge is the list of all statement types/states that were selected
             FROM (SELECT 1 "STATEMENT_STATE",
                        STATEMENT_TYPE_ID "STATEMENT_TYPE",
                        'Internal' "STATEMENT_STATE_NAME",
                        STATEMENT_TYPE_NAME,
						STATEMENT_TYPE_ORDER
		            FROM STATEMENT_TYPE
        		    WHERE v_STATEMENT_TYPES LIKE '%,'||STATEMENT_TYPE_ID||'1,%'
		            UNION ALL
		            SELECT 2 "STATEMENT_STATE",
			            STATEMENT_TYPE_ID "STATEMENT_TYPE",
			            'External' "STATEMENT_STATE_NAME",
                        STATEMENT_TYPE_NAME,
						STATEMENT_TYPE_ORDER
		            FROM STATEMENT_TYPE
		            WHERE v_STATEMENT_TYPES LIKE '%,'||STATEMENT_TYPE_ID||'2,%'),
	              -- second table in merge is distinct list of all line items
           	 	  (SELECT B.LINE_ITEM_NAME,
		            	DECODE(UPPER(C.CHARGE_TYPE), 'TAX', 'Tax', 'Current') "LINE_ITEM_TYPE"
            		FROM INVOICE A,
			            INVOICE_LINE_ITEM B,
						COMPONENT C
			        WHERE A.ENTITY_ID = p_ENTITY_ID
                        AND A.STATEMENT_TYPE > 0
                        AND A.STATEMENT_STATE IN (CONSTANTS.INTERNAL_STATE, CONSTANTS.EXTERNAL_STATE)
                        AND A.BEGIN_DATE = v_INVOICE_BEGIN_DATE
                        AND A.AS_OF_DATE =
                            (SELECT MAX(AS_OF_DATE) FROM INVOICE
                                WHERE ENTITY_ID = A.ENTITY_ID
                                AND STATEMENT_TYPE = A.STATEMENT_TYPE
                                AND STATEMENT_STATE = A.STATEMENT_STATE
                                AND BEGIN_DATE = A.BEGIN_DATE
                                AND AS_OF_DATE <= p_AS_OF_DATE)
			            AND B.INVOICE_ID = A.INVOICE_ID
            			AND NVL(B.LINE_ITEM_CATEGORY,' ') LIKE v_INVOICE_CATEGORY
						AND C.COMPONENT_ID(+) = B.COMPONENT_ID
		            UNION
        		    SELECT A.LINE_ITEM_NAME,
			            DECODE(A.LINE_ITEM_TYPE, 'P', 'Payment', 'F', 'Finance Charge', 'A', 'Adjustment', 'B', 'Balance', 'M', 'Miscellaneous', 'X', 'Manual Line Item Tax', '?') "LINE_ITEM_TYPE"
            		FROM INVOICE_USER_LINE_ITEM A
		            WHERE A.ENTITY_ID = p_ENTITY_ID
                        AND A.STATEMENT_TYPE > 0
                        AND A.STATEMENT_STATE IN (CONSTANTS.INTERNAL_STATE, CONSTANTS.EXTERNAL_STATE)
                        AND A.BEGIN_DATE = v_INVOICE_BEGIN_DATE
                        AND NVL(A.LINE_ITEM_CATEGORY,' ') LIKE v_INVOICE_CATEGORY)) A,
			-- next get the union of all line items (normal and manual-entry line items)
			(SELECT B.LINE_ITEM_NAME,
        			A.STATEMENT_STATE,
        			A.STATEMENT_TYPE,
        			DECODE(UPPER(C.CHARGE_TYPE), 'TAX', 'Tax', 'Current') "LINE_ITEM_TYPE",
                    DECODE(p_DISPLAY_OPTION,1,(DECODE(UPPER(NVL(B.DEFAULT_DISPLAY,'CHARGE')),'BILL',B.LINE_ITEM_BILL_AMOUNT,B.LINE_ITEM_AMOUNT)),NULL) "LINE_ITEM_DEFAULT_AMOUNT",
        			DECODE(p_DISPLAY_OPTION,2,B.LINE_ITEM_AMOUNT,4,B.LINE_ITEM_AMOUNT,NULL) "LINE_ITEM_AMOUNT",
        			DECODE(p_DISPLAY_OPTION,3,B.LINE_ITEM_BILL_AMOUNT,4,B.LINE_ITEM_BILL_AMOUNT,NULL) "LINE_ITEM_BILL_AMOUNT"
        		FROM INVOICE A,
        			INVOICE_LINE_ITEM B,
        			COMPONENT C,
					STATEMENT_TYPE D
            	WHERE A.ENTITY_ID = p_ENTITY_ID
                    AND A.STATEMENT_TYPE = D.STATEMENT_TYPE_ID
                    AND ((v_STATEMENT_TYPES LIKE '%,'||D.STATEMENT_TYPE_ID||'1,%'
                       		AND A.STATEMENT_STATE = CONSTANTS.INTERNAL_STATE)
                    	  OR (v_STATEMENT_TYPES LIKE '%,'||D.STATEMENT_TYPE_ID||'2,%'
                       		AND A.STATEMENT_STATE = CONSTANTS.EXTERNAL_STATE)
                          )
            		AND A.BEGIN_DATE = v_INVOICE_BEGIN_DATE
					AND A.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
										FROM INVOICE
										WHERE ENTITY_ID = A.ENTITY_ID
											AND STATEMENT_TYPE = A.STATEMENT_TYPE
											AND STATEMENT_STATE = A.STATEMENT_STATE
											AND BEGIN_DATE = A.BEGIN_DATE
											AND AS_OF_DATE <= p_AS_OF_DATE)
           			AND B.INVOICE_ID = A.INVOICE_ID
        			AND NVL(B.LINE_ITEM_CATEGORY,' ') LIKE v_INVOICE_CATEGORY
           			AND C.COMPONENT_ID(+) = B.COMPONENT_ID
				UNION ALL
                SELECT A.LINE_ITEM_NAME,
            		A.STATEMENT_STATE,
            		A.STATEMENT_TYPE,
            		DECODE(A.LINE_ITEM_TYPE, 'P', 'Payment', 'F', 'Finance Charge', 'A', 'Adjustment', 'B', 'Balance', 'M', 'Miscellaneous', 'X', 'Manual Line Item Tax', '?') "LINE_ITEM_TYPE",
                    DECODE(p_DISPLAY_OPTION,1,(DECODE(UPPER(NVL(A.DEFAULT_DISPLAY,'CHARGE')),'BILL',A.LINE_ITEM_BILL_AMOUNT,A.LINE_ITEM_AMOUNT)),NULL) "LINE_ITEM_DEFAULT_AMOUNT",
            		DECODE(p_DISPLAY_OPTION,2,A.LINE_ITEM_AMOUNT,4,A.LINE_ITEM_AMOUNT,NULL) "LINE_ITEM_AMOUNT",
            		DECODE(p_DISPLAY_OPTION,3,A.LINE_ITEM_BILL_AMOUNT,4,A.LINE_ITEM_BILL_AMOUNT,NULL) "LINE_ITEM_BILL_AMOUNT"
            	FROM INVOICE_USER_LINE_ITEM A,
                	STATEMENT_TYPE B
            	WHERE A.ENTITY_ID = p_ENTITY_ID
                    AND A.STATEMENT_TYPE = B.STATEMENT_TYPE_ID
                    AND ((v_STATEMENT_TYPES LIKE '%,'||B.STATEMENT_TYPE_ID||'1,%'
                    		AND A.STATEMENT_STATE = CONSTANTS.INTERNAL_STATE)
                         OR (v_STATEMENT_TYPES LIKE '%,'||B.STATEMENT_TYPE_ID||'2,%'
                    		AND A.STATEMENT_STATE = CONSTANTS.EXTERNAL_STATE)
                         )
        			AND A.BEGIN_DATE = v_INVOICE_BEGIN_DATE
                    AND NVL(A.LINE_ITEM_CATEGORY,' ') LIKE v_INVOICE_CATEGORY) B
		-- finally, outer-join the two views above
		WHERE B.STATEMENT_STATE(+) = A.STATEMENT_STATE
			AND B.STATEMENT_TYPE(+) = A.STATEMENT_TYPE
			AND B.LINE_ITEM_NAME(+) = A.LINE_ITEM_NAME
			AND B.LINE_ITEM_TYPE(+) = A.LINE_ITEM_TYPE;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;
END GET_INVOICE_COMPARISON;
----------------------------------------------------------------------------------------------------------------------
FUNCTION GET_INVOICE_OPTION
	(
    p_CALLING_MODULE IN VARCHAR2,
    p_ENTITY_ID IN NUMBER
    ) RETURN CHAR IS
BEGIN
	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING THEN
    	DECLARE
        	v_OPTION CHAR(1);
        BEGIN
        	SELECT DECODE(UPPER(INVOICE_LINE_ITEM_OPTION),'BY PRODUCT','1',
        				'BY PRODUCT-COMPONENT','2','BY ACCOUNT SERVICE','3',
                        'BY COMPONENT','4','EXTERNAL','X','2')
            INTO v_OPTION
            FROM PURCHASING_SELLING_ENTITY
            WHERE PSE_ID = p_ENTITY_ID;
            RETURN NVL(v_OPTION,'2'); -- 2 is the default option
		EXCEPTION
        	WHEN OTHERS THEN
	            RETURN '2'; -- 2 is the default option
        END;
    ELSE
    	RETURN GA.INVOICE_LINE_ITEM_OPTION;
    END IF;
END GET_INVOICE_OPTION;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_STATEMENT_SUM_FOR_PAIRS
	(
    p_ENTITY_ID IN NUMBER,
    p_PRODUCTS_COMPONENTS IN VARCHAR2,
    p_STATEMENT_TYPE IN NUMBER,
    p_STATEMENT_STATE IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_AS_OF_DATE IN DATE,
    p_CHARGE_AMOUNT OUT NUMBER,
    p_BILL_AMOUNT OUT NUMBER,
    p_IN_DISPUTE OUT NUMBER
    ) AS
v_NUMBER_TABLE GA.ID_TABLE;
v_STRING_TABLE GA.STRING_TABLE;
v_WORK_ID NUMBER;
v_INDEX BINARY_INTEGER;
BEGIN
	UT.TOKENS_FROM_STRING(p_PRODUCTS_COMPONENTS,';',v_STRING_TABLE);
	UT.GET_RTO_WORK_ID(v_WORK_ID);
    v_INDEX := v_STRING_TABLE.FIRST;
    WHILE v_STRING_TABLE.EXISTS(v_INDEX) LOOP
		UT.IDS_FROM_STRING(v_STRING_TABLE(v_INDEX),',',v_NUMBER_TABLE);
		INSERT INTO RTO_WORK (WORK_ID, WORK_XID, WORK_DATA)
		  	VALUES (v_WORK_ID, v_NUMBER_TABLE(1), v_NUMBER_TABLE(2));
    	v_INDEX := v_STRING_TABLE.NEXT(v_INDEX);
    END LOOP;

	SELECT MAX(A.IN_DISPUTE),
        SUM(A.BILL_AMOUNT),
        SUM(A.CHARGE_AMOUNT)
	INTO p_IN_DISPUTE,
    	p_BILL_AMOUNT,
        p_CHARGE_AMOUNT
	FROM BILLING_STATEMENT A,
		(SELECT WORK_XID "PRODUCT_ID", TO_NUMBER(WORK_DATA) "COMPONENT_ID"
        	FROM RTO_WORK
            WHERE WORK_ID = v_WORK_ID) B
    WHERE A.ENTITY_ID = p_ENTITY_ID
    	AND A.PRODUCT_ID > 0
        AND A.COMPONENT_ID > 0
        AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
        AND A.STATEMENT_STATE = p_STATEMENT_STATE
        AND A.STATEMENT_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
        AND A.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
         					FROM BILLING_STATEMENT
                             WHERE ENTITY_ID = A.ENTITY_ID
                             	AND PRODUCT_ID = A.PRODUCT_ID
                                 AND COMPONENT_ID = A.COMPONENT_ID
                                 AND STATEMENT_TYPE = A.STATEMENT_TYPE
                                 AND STATEMENT_STATE = A.STATEMENT_STATE
                                 AND STATEMENT_DATE = A.STATEMENT_DATE
                                 AND AS_OF_DATE <= p_AS_OF_DATE)
		AND (A.PRODUCT_ID = B.PRODUCT_ID OR B.PRODUCT_ID = CONSTANTS.ALL_ID)
    	AND (A.COMPONENT_ID = B.COMPONENT_ID OR B.COMPONENT_ID = CONSTANTS.ALL_ID);

	UT.PURGE_RTO_WORK(v_WORK_ID);
EXCEPTION
	WHEN OTHERS THEN
    	UT.PURGE_RTO_WORK(v_WORK_ID);
        ERRS.LOG_AND_RAISE();
END GET_STATEMENT_SUM_FOR_PAIRS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_STATEMENTS_FOR_LINE_ITEM(
	p_CALLING_MODULE IN VARCHAR2,
    p_ENTITY_ID IN NUMBER,
    p_INVOICE_LINE_ITEM IN INVOICE_LINE_ITEM%ROWTYPE,
    p_RECORD IN OUT NOCOPY INVOICE_VALID_RECORD_TYPE,
    p_AS_OF_DATE IN DATE
    ) AS
v_LINE_ITEM_OPTION VARCHAR2(32) := UPPER(p_INVOICE_LINE_ITEM.LINE_ITEM_OPTION);
v_ENTITY_TYPE VARCHAR2(16);
BEGIN
	-- make sure we know the invoice roll-up option
    IF v_LINE_ITEM_OPTION IS NULL THEN
        SELECT DECODE(GA.INVOICE_LINE_ITEM_OPTION,'1','BY PRODUCT','2','BY PRODUCT-COMPONENT',
        			'3','BY ACCOUNT SERVICE','4','BY COMPONENT',
                    'X','EXTERNAL','BY PRODUCT-COMPONENT')
		INTO v_LINE_ITEM_OPTION
        FROM DUAL;
    END IF;

    IF v_LINE_ITEM_OPTION = 'BY PRODUCT' THEN
    	p_RECORD.PRODUCT_COMPONENT_PAIRS := p_INVOICE_LINE_ITEM.PRODUCT_ID||',-1';
    ELSIF v_LINE_ITEM_OPTION = 'BY PRODUCT-COMPONENT' THEN
    	p_RECORD.PRODUCT_COMPONENT_PAIRS := p_INVOICE_LINE_ITEM.PRODUCT_ID||','||p_INVOICE_LINE_ITEM.COMPONENT_ID;
    ELSIF v_LINE_ITEM_OPTION = 'BY ACCOUNT SERVICE' THEN
    	-- do nothing - this invoice option isn't supported for
        -- invoice validation
    	p_RECORD.PRODUCT_COMPONENT_PAIRS := NULL;
    ELSIF v_LINE_ITEM_OPTION = 'BY COMPONENT' THEN
    	p_RECORD.PRODUCT_COMPONENT_PAIRS := '-1,'||p_INVOICE_LINE_ITEM.COMPONENT_ID;
    ELSE -- unknown options indicate external roll-up option
    	-- determine entity type
        SELECT DECODE(UPPER(SUBSTR(p_CALLING_MODULE,1,1)),g_SCHEDULING,g_PSE,
        												  g_GAS_DELIVERY,g_POOL,
                                                          g_POSITION_AND_BILLING,g_BILL_PARTY)
		INTO v_ENTITY_TYPE FROM DUAL;
    	XS.UNROLL_INVOICE_LINE_ITEM(p_ENTITY_ID,v_ENTITY_TYPE,p_AS_OF_DATE,p_INVOICE_LINE_ITEM,p_RECORD.PRODUCT_COMPONENT_PAIRS);
    END IF;

    IF p_RECORD.PRODUCT_COMPONENT_PAIRS IS NOT NULL THEN
    	-- get sum and dispute status for products/components
        GET_STATEMENT_SUM_FOR_PAIRS (p_RECORD.ENTITY_ID,p_RECORD.PRODUCT_COMPONENT_PAIRS,
			        	p_RECORD.STATEMENT_TYPE,p_RECORD.STATEMENT_STATE,
                        p_RECORD.BEGIN_DATE,p_RECORD.END_DATE,p_AS_OF_DATE,
			        	p_RECORD.STATEMENT_CHARGE_AMOUNT,p_RECORD.STATEMENT_BILL_AMOUNT,p_RECORD.IN_DISPUTE);
        IF p_RECORD.DEFAULT_DISPLAY = 'BILL' THEN
         	p_RECORD.STATEMENT_DEFAULT_AMOUNT := p_RECORD.STATEMENT_BILL_AMOUNT;
		ELSE
        	p_RECORD.STATEMENT_DEFAULT_AMOUNT := p_RECORD.STATEMENT_CHARGE_AMOUNT;
        END IF;
		-- flip signs if necessary so they compare properly to the invoice
		IF GA.ENABLE_REVERSE_SIGN_INVOICES THEN
			p_RECORD.STATEMENT_DEFAULT_AMOUNT := -p_RECORD.STATEMENT_DEFAULT_AMOUNT;
			p_RECORD.STATEMENT_CHARGE_AMOUNT := -p_RECORD.STATEMENT_CHARGE_AMOUNT;
			p_RECORD.STATEMENT_BILL_AMOUNT := -p_RECORD.STATEMENT_BILL_AMOUNT;
		END IF;
		-- compute the deltas
        p_RECORD.DEFAULT_DIFFERENCE := NVL(p_RECORD.LINE_ITEM_DEFAULT_AMOUNT,0)-NVL(p_RECORD.STATEMENT_DEFAULT_AMOUNT,0);
        p_RECORD.CHARGE_DIFFERENCE := NVL(p_RECORD.LINE_ITEM_AMOUNT,0)-NVL(p_RECORD.STATEMENT_CHARGE_AMOUNT,0);
        p_RECORD.BILL_DIFFERENCE := NVL(p_RECORD.LINE_ITEM_BILL_AMOUNT,0)-NVL(p_RECORD.STATEMENT_BILL_AMOUNT,0);
    END IF;
END GET_STATEMENTS_FOR_LINE_ITEM;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_INVOICE_VALIDATION
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_INVOICE_DATE IN VARCHAR2,
	p_AS_OF_DATE IN DATE,
    p_INVOICE_CATEGORY IN VARCHAR,
    p_STATEMENT_TYPE IN NUMBER,
    p_STATEMENT_STATE IN NUMBER,
	p_DISPLAY_OPTION IN NUMBER,
    p_PERIOD_DATE_STRING OUT VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
v_INVOICE_BEGIN_DATE DATE;
v_INVOICE_CATEGORY VARCHAR2(32);
v_RECORDS INVOICE_VALID_RECORD_TABLE;
v_INDEX BINARY_INTEGER;
v_INVOICE_OPTION CHAR(1);
v_INVOICE_LINE_ITEM INVOICE_LINE_ITEM%ROWTYPE;
BEGIN
	p_STATUS := GA.SUCCESS;

	IF p_INVOICE_DATE IS NULL THEN
		v_INVOICE_BEGIN_DATE := NULL;
	ELSE
		v_INVOICE_BEGIN_DATE := TO_DATE(SUBSTR(p_INVOICE_DATE,1,10), g_SHORT_DATE_FORMAT);
	END IF;

	p_PERIOD_DATE_STRING := p_INVOICE_DATE;

    IF p_INVOICE_CATEGORY = '<ALL>' THEN
    	v_INVOICE_CATEGORY := '%';
	ELSE
    	v_INVOICE_CATEGORY := p_INVOICE_CATEGORY;
	END IF;

    -- fetch invoice data
	SELECT INVOICE_VALID_RECORD_TYPE(
    	INVOICE_ID, LINE_ITEM_NAME, LINE_ITEM_TYPE, IS_MANUAL,
        LINE_ITEM_DEFAULT_AMOUNT, LINE_ITEM_AMOUNT, LINE_ITEM_BILL_AMOUNT,
        DEFAULT_DISPLAY, STATEMENT_TYPE, STATEMENT_STATE,
        BEGIN_DATE, END_DATE, ENTITY_ID, ENTITY_INTERVAL,
        NULL, NULL, NULL, 0, NULL, NULL, NULL, NULL
	    )
    BULK COLLECT INTO v_RECORDS
    FROM
	(SELECT A.INVOICE_ID,
    	B.LINE_ITEM_NAME,
		DECODE(UPPER(C.CHARGE_TYPE), 'TAX', 'Tax', 'Current') "LINE_ITEM_TYPE",
        DECODE(UPPER(NVL(B.DEFAULT_DISPLAY,'CHARGE')),'BILL',B.LINE_ITEM_BILL_AMOUNT,B.LINE_ITEM_AMOUNT) "LINE_ITEM_DEFAULT_AMOUNT",
		B.LINE_ITEM_AMOUNT,
		B.LINE_ITEM_BILL_AMOUNT,
        B.DEFAULT_DISPLAY,
		B.STATEMENT_TYPE,
		A.STATEMENT_STATE,
        B.BEGIN_DATE,
        B.END_DATE,
        A.ENTITY_ID,
        D.STATEMENT_INTERVAL "ENTITY_INTERVAL",
        0 "IS_MANUAL"
	FROM INVOICE A,
		INVOICE_LINE_ITEM B,
		COMPONENT C,
        PURCHASING_SELLING_ENTITY D
	WHERE A.ENTITY_ID = p_ENTITY_ID
		AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
		AND A.STATEMENT_STATE = p_STATEMENT_STATE
		AND A.BEGIN_DATE = v_INVOICE_BEGIN_DATE
		AND A.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE) FROM INVOICE
				WHERE ENTITY_ID = A.ENTITY_ID
					AND STATEMENT_TYPE = A.STATEMENT_TYPE
					AND STATEMENT_STATE = A.STATEMENT_STATE
					AND BEGIN_DATE = A.BEGIN_DATE
					AND AS_OF_DATE <= p_AS_OF_DATE)
		AND B.INVOICE_ID = A.INVOICE_ID
        AND NVL(B.LINE_ITEM_CATEGORY,' ') LIKE v_INVOICE_CATEGORY
		AND C.COMPONENT_ID(+) = B.COMPONENT_ID
        AND D.PSE_ID = A.ENTITY_ID
	UNION ALL
    SELECT 0 "INVOICE_ID",
    	LINE_ITEM_NAME,
		DECODE(LINE_ITEM_TYPE, 'P', 'Payment', 'F', 'Finance Charge', 'A', 'Adjustment', 'B', 'Balance', 'M', 'Miscellaneous', 'X', 'Manual Line Item Tax', '?') "LINE_ITEM_TYPE",
        DECODE(UPPER(NVL(DEFAULT_DISPLAY,'CHARGE')),'BILL',LINE_ITEM_BILL_AMOUNT,LINE_ITEM_AMOUNT) "LINE_ITEM_DEFAULT_AMOUNT",
		LINE_ITEM_AMOUNT,
		LINE_ITEM_BILL_AMOUNT,
        DEFAULT_DISPLAY,
        STATEMENT_TYPE,
        STATEMENT_STATE,
        BEGIN_DATE,
        NULL "END_DATE",
        ENTITY_ID,
        NULL "ENTITY_INTERVAL",
        1 "IS_MANUAL"
	FROM INVOICE_USER_LINE_ITEM
	WHERE ENTITY_ID = p_ENTITY_ID
		AND STATEMENT_TYPE = p_STATEMENT_TYPE
		AND STATEMENT_STATE = p_STATEMENT_STATE
		AND BEGIN_DATE = v_INVOICE_BEGIN_DATE
        AND NVL(LINE_ITEM_CATEGORY,' ') LIKE v_INVOICE_CATEGORY);

    -- then loop through and populate statement data
    v_INDEX := v_RECORDS.FIRST;
    WHILE v_RECORDS.EXISTS(v_INDEX) LOOP
    	IF v_RECORDS(v_INDEX).IS_MANUAL = 0 THEN
        	-- query the billing statement numbers for this row
            v_INVOICE_OPTION := GET_INVOICE_OPTION(p_CALLING_MODULE,p_ENTITY_ID);
            SELECT * INTO v_INVOICE_LINE_ITEM
            	FROM INVOICE_LINE_ITEM
                WHERE INVOICE_ID = v_RECORDS(v_INDEX).INVOICE_ID
               	AND LINE_ITEM_NAME = v_RECORDS(v_INDEX).LINE_ITEM_NAME;
			GET_STATEMENTS_FOR_LINE_ITEM(p_CALLING_MODULE, p_ENTITY_ID, v_INVOICE_LINE_ITEM, v_RECORDS(v_INDEX), p_AS_OF_DATE);
        END IF;
    	v_INDEX := v_RECORDS.NEXT(v_INDEX);
    END LOOP;

    -- finally, return it all
	-- the p_DISPLAY_OPTION parameter has the following possible values:
	--	1=default, 2=Charge, 3=Bill, 4=Charge and Bill
    OPEN p_CURSOR FOR
    	SELECT LINE_ITEM_NAME,
			LINE_ITEM_TYPE,
	        DECODE(p_DISPLAY_OPTION,1,LINE_ITEM_DEFAULT_AMOUNT,NULL) LINE_ITEM_DEFAULT_AMOUNT,
			DECODE(p_DISPLAY_OPTION,2,LINE_ITEM_AMOUNT,4,LINE_ITEM_AMOUNT,NULL) LINE_ITEM_AMOUNT,
			DECODE(p_DISPLAY_OPTION,3,LINE_ITEM_BILL_AMOUNT,4,LINE_ITEM_BILL_AMOUNT,NULL) LINE_ITEM_BILL_AMOUNT,
	        DEFAULT_DISPLAY,
			STATEMENT_TYPE,
			STATEMENT_TYPE_NAME,
            STATEMENT_STATE,
			BEGIN_DATE "INVOICE_BEGIN_DATE",
			END_DATE "INVOICE_END_DATE",
			ENTITY_ID,
			ENTITY_INTERVAL,
	        DECODE(p_DISPLAY_OPTION,1,STATEMENT_DEFAULT_AMOUNT,NULL) STATEMENT_DEFAULT_AMOUNT,
			DECODE(p_DISPLAY_OPTION,2,STATEMENT_CHARGE_AMOUNT,4,STATEMENT_CHARGE_AMOUNT,NULL) STATEMENT_CHARGE_AMOUNT,
			DECODE(p_DISPLAY_OPTION,3,STATEMENT_BILL_AMOUNT,4,STATEMENT_BILL_AMOUNT,NULL) STATEMENT_BILL_AMOUNT,
	        IN_DISPUTE,
			PRODUCT_COMPONENT_PAIRS,
	        DECODE(p_DISPLAY_OPTION,1,DEFAULT_DIFFERENCE,NULL) DEFAULT_DIFFERENCE,
			DECODE(p_DISPLAY_OPTION,2,CHARGE_DIFFERENCE,4,CHARGE_DIFFERENCE,NULL) CHARGE_DIFFERENCE,
			DECODE(p_DISPLAY_OPTION,3,BILL_DIFFERENCE,4,BILL_DIFFERENCE,NULL) BILL_DIFFERENCE
    	FROM TABLE(CAST(v_RECORDS AS INVOICE_VALID_RECORD_TABLE)) A,
        	STATEMENT_TYPE B
		WHERE STATEMENT_TYPE_ID = STATEMENT_TYPE
        ORDER BY 2,1;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;
END GET_INVOICE_VALIDATION;
---------------------------------------------------------------------------------------------------
FUNCTION GET_FORMAT_FROM_INTERVAL
	(
	p_INTERVAL IN VARCHAR
	) RETURN VARCHAR IS
v_TRUNC VARCHAR(8);
BEGIN
--	SELECT DECODE(UPPER(SUBSTR(p_INTERVAL,1,2)),'5 ','MI5','10','MI10','15','MI15','20','MI20','30','MI30','HO','HH','DA','DD','WE','DY','MO','MM','QU','Q','YE','YY')
--	INTO v_TRUNC FROM DUAL;
	SELECT DECODE(UPPER(SUBSTR(p_INTERVAL,1,2)),'5 ','MI5','10','MI5','15','MI5','20','MI5','30','MI5','HO','HH','DA','DD','WE','DD','MO','DD','QU','DD','YE','DD')
	INTO v_TRUNC FROM DUAL;

	RETURN v_TRUNC;
END GET_FORMAT_FROM_INTERVAL;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_EXPORT_ENTITIES
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
    p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_AS_OF_DATE IN DATE,
	p_LABEL OUT VARCHAR2,
    p_STATUS OUT NUMBER,
    p_MESSAGE OUT VARCHAR,
	p_CURSOR IN OUT GA.REFCURSOR
    ) AS
	v_VALID_IDS ID_TABLE;
BEGIN
	p_LABEL := 'Billing Entities';

	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_POSITION_AND_BILLING THEN
    	OPEN p_CURSOR FOR
    		SELECT DISTINCT ENTITY_ID, BILL_PARTY_NAME
            FROM BILLING_STATEMENT A, BILL_PARTY B
            WHERE STATEMENT_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
    	        AND STATEMENT_TYPE = p_STATEMENT_TYPE
                AND STATEMENT_STATE = p_STATEMENT_STATE
                AND AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
                					FROM BILLING_STATEMENT
                                    WHERE ENTITY_ID = A.ENTITY_ID
                                    	AND PRODUCT_ID = A.PRODUCT_ID
                                        AND COMPONENT_ID = A.COMPONENT_ID
                                        AND STATEMENT_DATE = A.STATEMENT_DATE
                                        AND STATEMENT_TYPE = A.STATEMENT_TYPE
                                        AND STATEMENT_STATE = A.STATEMENT_STATE
                                        AND AS_OF_DATE <= p_AS_OF_DATE)
				AND BILL_PARTY_ID = ENTITY_ID
			ORDER BY BILL_PARTY_NAME;
	ELSIF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING THEN

		p_LABEL := 'PSE Billing Entities';
   		v_VALID_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_PSE_BILL_SELECT);

    	OPEN p_CURSOR FOR
    		SELECT DISTINCT PSE_NAME, ENTITY_ID
            FROM BILLING_STATEMENT A, PURCHASING_SELLING_ENTITY B,
				TABLE(CAST(v_VALID_IDs AS ID_TABLE)) F
			WHERE F.ID IN (CONSTANTS.ALL_ID, SD.g_ALL_DATA_ENTITY_ID, A.ENTITY_ID)
				AND STATEMENT_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
    	        AND STATEMENT_TYPE = p_STATEMENT_TYPE
                AND STATEMENT_STATE = p_STATEMENT_STATE
                AND AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
                					FROM BILLING_STATEMENT
                                    WHERE ENTITY_ID = A.ENTITY_ID
                                    	AND PRODUCT_ID = A.PRODUCT_ID
                                        AND COMPONENT_ID = A.COMPONENT_ID
                                        AND STATEMENT_DATE = A.STATEMENT_DATE
                                        AND STATEMENT_TYPE = A.STATEMENT_TYPE
                                        AND STATEMENT_STATE = A.STATEMENT_STATE
                                        AND AS_OF_DATE <= p_AS_OF_DATE)
				AND PSE_ID = ENTITY_ID
			ORDER BY PSE_NAME;
	ELSIF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_GAS_DELIVERY THEN
    	OPEN p_CURSOR FOR
    		SELECT DISTINCT ENTITY_ID, POOL_NAME
            FROM BILLING_STATEMENT A, POOL B
            WHERE STATEMENT_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
    	        AND STATEMENT_TYPE = p_STATEMENT_TYPE
                AND STATEMENT_STATE = p_STATEMENT_STATE
                AND AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
                					FROM BILLING_STATEMENT
                                    WHERE ENTITY_ID = A.ENTITY_ID
                                    	AND PRODUCT_ID = A.PRODUCT_ID
                                        AND COMPONENT_ID = A.COMPONENT_ID
                                        AND STATEMENT_DATE = A.STATEMENT_DATE
                                        AND STATEMENT_TYPE = A.STATEMENT_TYPE
                                        AND STATEMENT_STATE = A.STATEMENT_STATE
                                        AND AS_OF_DATE <= p_AS_OF_DATE)
				AND POOL_ID = ENTITY_ID
			ORDER BY POOL_NAME;
	END IF;
EXCEPTION
	WHEN OTHERS THEN
    	p_STATUS := SQLCODE;
        p_MESSAGE := SQLERRM;
END GET_EXPORT_ENTITIES;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_EXPORT_INVOICE_SUMMARY
	(
    p_MODEL_ID IN NUMBER,
    p_INVOICE_ID IN NUMBER,
    p_WORK_ID IN NUMBER
    ) AS
v_SEQ NUMBER := 0;
v_DATE_FMT VARCHAR2(32) := NVL(MODEL_VALUE_AT_KEY(p_MODEL_ID,'BILLING','INVOICE','DATE FORMAT',0),g_SHORT_DATE_FORMAT);
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_INVOICE_DATE DATE;
v_INVOICE_NUMBER VARCHAR2(16);
v_INVOICE_SUB_LEDGER_NUMBER VARCHAR2(16);
v_INVOICE_STATUS VARCHAR2(32);
v_INVOICE_COUNTER_PARTY VARCHAR(4000);
v_LAST_INVOICE_GROUP VARCHAR2(32) := ' ';
v_LAST_EMIT_SUBTOTAL NUMBER := 0;
v_SUB_TOTAL NUMBER := 0;
v_GRAND_TOTAL NUMBER := 0;
v_LINE_ITEM_PREFIX VARCHAR2(2);
CURSOR c_LINE_ITEMS IS
	SELECT B.LINE_ITEM_NAME,
 		DECODE(UPPER(C.CHARGE_TYPE), 'TAX', 'T', 'C') AS LINE_ITEM_TYPE,
 		DECODE(UPPER(C.CHARGE_TYPE), 'TAX', 6, 5) AS LINE_ITEM_GROUP_ORDER,
        D.INVOICE_GROUP_NAME,
        NVL(C.INVOICE_GROUP_ORDER,0) AS INVOICE_GROUP_ORDER,
 		B.LINE_ITEM_QUANTITY,
        B.LINE_ITEM_RATE,
        B.LINE_ITEM_AMOUNT,
 		NVL(C.EXCLUDE_FROM_INVOICE_TOTAL,0) AS EXCLUDE_FROM_INVOICE_TOTAL,
 		NVL(D.SHOW_TITLE_ON_INVOICE,0) AS SHOW_TITLE_ON_INVOICE,
 		NVL(D.SHOW_SUBTOTAL_ON_INVOICE,0) AS SHOW_SUBTOTAL_ON_INVOICE,
        NVL(D.DISPLAY_ORDER,0) AS INVOICE_GROUP_DISPLAY_ORDER
	FROM INVOICE A,
		INVOICE_LINE_ITEM B,
 		COMPONENT C,
 		INVOICE_GROUP D
	WHERE A.INVOICE_ID = p_INVOICE_ID
		AND B.INVOICE_ID = A.INVOICE_ID
		AND B.COMPONENT_ID = C.COMPONENT_ID (+)
		AND (C.EXCLUDE_FROM_BILLING_EXPORT <> 1 OR C.EXCLUDE_FROM_BILLING_EXPORT IS NULL)
		AND D.INVOICE_GROUP_ID(+) = C.INVOICE_GROUP_ID
	UNION ALL
	SELECT B.LINE_ITEM_NAME,
		B.LINE_ITEM_TYPE,
		DECODE(B.LINE_ITEM_TYPE, 'B', 1, 'P', 2, 'A', 3, 'F', 4, 'M', 7, 'X', 8, 99)  AS LINE_ITEM_GROUP_ORDER,
        C.INVOICE_GROUP_NAME,
        NVL(B.INVOICE_GROUP_ORDER,0) AS INVOICE_GROUP_ORDER,
		B.LINE_ITEM_QUANTITY,
        B.LINE_ITEM_RATE,
        B.LINE_ITEM_AMOUNT,
		NVL(B.EXCLUDE_FROM_INVOICE_TOTAL,0) AS EXCLUDE_FROM_INVOICE_TOTAL,
 		NVL(C.SHOW_TITLE_ON_INVOICE,0) AS SHOW_TITLE_ON_INVOICE,
 		NVL(C.SHOW_SUBTOTAL_ON_INVOICE,0) AS SHOW_SUBTOTAL_ON_INVOICE,
        NVL(C.DISPLAY_ORDER,0) AS INVOICE_GROUP_DISPLAY_ORDER
	FROM INVOICE A,
		INVOICE_USER_LINE_ITEM B,
	    INVOICE_GROUP C
	WHERE A.INVOICE_ID = p_INVOICE_ID
		AND B.ENTITY_ID = A.ENTITY_ID
		AND B.STATEMENT_TYPE = A.STATEMENT_TYPE
 		AND B.STATEMENT_STATE = A.STATEMENT_STATE
 		AND B.BEGIN_DATE = A.BEGIN_DATE
		AND C.INVOICE_GROUP_ID(+) = B.INVOICE_GROUP_ID
	ORDER BY INVOICE_GROUP_DISPLAY_ORDER ASC,
 		INVOICE_GROUP_NAME ASC,
 		INVOICE_GROUP_ORDER ASC,
      	LINE_ITEM_GROUP_ORDER ASC,
 		LINE_ITEM_NAME ASC;

	-- Add a line to RTO_WORK, NO NULLS ALLOWED
	PROCEDURE ADD_LINE(p_LINE IN VARCHAR2 := ' ') AS
	BEGIN
		INSERT INTO RTO_WORK (WORK_ID, WORK_SEQ, WORK_DATA)
		VALUES (p_WORK_ID, v_SEQ, p_LINE);
		v_SEQ := v_SEQ + 1;
	END ADD_LINE;

BEGIN
	SELECT BEGIN_DATE, END_DATE, INVOICE_DATE, INVOICE_NUMBER, INVOICE_SUB_LEDGER_NUMBER, INVOICE_STATUS, TEXT_UTIL.TO_CHAR_ENTITY(ENTITY_ID,EC.ED_PSE)
    INTO v_BEGIN_DATE, v_END_DATE, v_INVOICE_DATE, v_INVOICE_NUMBER, v_INVOICE_SUB_LEDGER_NUMBER, v_INVOICE_STATUS, v_INVOICE_COUNTER_PARTY
    FROM INVOICE
    WHERE INVOICE_ID = p_INVOICE_ID;

	IF NOT v_INVOICE_SUB_LEDGER_NUMBER IS NULL THEN
    	v_INVOICE_NUMBER := v_INVOICE_NUMBER||'-'||v_INVOICE_SUB_LEDGER_NUMBER;
    END IF;

	-- start building invoice into RTO_WORK - header info first
	ADD_LINE(GET_DICTIONARY_VALUE('Title', p_MODEL_ID, 'Billing', 'Invoice'));
	ADD_LINE('Invoice Counter-Party: ' || v_INVOICE_COUNTER_PARTY);
	ADD_LINE('Invoice Date: '||TO_CHAR(v_INVOICE_DATE,v_DATE_FMT));
    ADD_LINE('Invoice Number: '||v_INVOICE_NUMBER);
    ADD_LINE('Invoice Status: '||v_INVOICE_STATUS);
    ADD_LINE('Invoice Period: '||TO_CHAR(v_BEGIN_DATE,v_DATE_FMT)||' - '||TO_CHAR(v_END_DATE,v_DATE_FMT));
    ADD_LINE();
	ADD_LINE('||Quantity|Rate|Amount');

	-- then export all the line items
    FOR v_LINE_ITEM IN c_LINE_ITEMS LOOP
    	-- pad with space so we don't have to worry about NULLs throwing off boolean test
    	IF v_LINE_ITEM.INVOICE_GROUP_NAME||' ' <> v_LAST_INVOICE_GROUP THEN
        	-- reset for new group
            IF v_LAST_EMIT_SUBTOTAL = 1 THEN
            	ADD_LINE('Sub-Total||||'||TRIM(TO_CHAR(v_SUB_TOTAL,'9999999999999.99')));
            END IF;
        	v_SUB_TOTAL := 0;
        	ADD_LINE();
            IF v_LINE_ITEM.SHOW_TITLE_ON_INVOICE = 1 THEN
            	ADD_LINE(v_LINE_ITEM.INVOICE_GROUP_NAME);
            END IF;
            v_LAST_INVOICE_GROUP := v_LINE_ITEM.INVOICE_GROUP_NAME||' ';
            v_LAST_EMIT_SUBTOTAL := v_LINE_ITEM.SHOW_SUBTOTAL_ON_INVOICE;
        END IF;
        -- write the line items
        IF v_LINE_ITEM.EXCLUDE_FROM_INVOICE_TOTAL = 1 THEN
        	v_LINE_ITEM_PREFIX := '*';
        ELSE
        	v_LINE_ITEM_PREFIX := ' ';
            v_SUB_TOTAL := v_SUB_TOTAL + v_LINE_ITEM.LINE_ITEM_AMOUNT;
            v_GRAND_TOTAL := v_GRAND_TOTAL + v_LINE_ITEM.LINE_ITEM_AMOUNT;
        END IF;
    	ADD_LINE(v_LINE_ITEM_PREFIX||'|'||v_LINE_ITEM.LINE_ITEM_NAME||
            					'|'||TRIM(TO_CHAR(v_LINE_ITEM.LINE_ITEM_QUANTITY,'9999999999999.99'))||
                                '|'||TRIM(TO_CHAR(v_LINE_ITEM.LINE_ITEM_RATE,'9999999999999.999999'))||
                                '|'||TRIM(TO_CHAR(v_LINE_ITEM.LINE_ITEM_AMOUNT,'9999999999999.99')));
    END LOOP;

	-- make sure to catch last subtotal if necessary
    IF v_LAST_EMIT_SUBTOTAL = 1 THEN
    	ADD_LINE('Sub-Total||||'||TRIM(TO_CHAR(v_SUB_TOTAL,'9999999999999.99')));
    END IF;
	ADD_LINE();

	-- now emit the grand total
	ADD_LINE('Grand Total||||'||TRIM(TO_CHAR(v_GRAND_TOTAL,'9999999999999.99')));

END GET_EXPORT_INVOICE_SUMMARY;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_EXPORT_SUMMARY_UI
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
    p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_AS_OF_DATE IN DATE,
    p_ID_PAIRS OUT STRING_COLLECTION,
	p_BEGIN_DATE_OUT OUT DATE,
	p_END_DATE_OUT OUT DATE,
    p_STATUS OUT NUMBER,
    p_MESSAGE OUT VARCHAR,
	p_CURSOR IN OUT GA.REFCURSOR
    ) AS

	v_BEGIN_DATE DATE := p_BEGIN_DATE;
    v_END_DATE DATE := p_END_DATE;

    BEGIN

    GET_EXPORT_SUMMARY(p_CALLING_MODULE, p_MODEL_ID, p_ENTITY_ID, p_STATEMENT_TYPE, p_STATEMENT_STATE,
    v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, p_ID_PAIRS, p_STATUS, p_MESSAGE, p_CURSOR);

	p_BEGIN_DATE_OUT := v_BEGIN_DATE;
	p_END_DATE_OUT := v_END_DATE;

END GET_EXPORT_SUMMARY_UI;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_EXPORT_SUMMARY
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
    p_STATEMENT_TYPE IN NUMBER,
    p_STATEMENT_STATE IN NUMBER,
    p_BEGIN_DATE IN OUT DATE,
    p_END_DATE IN OUT DATE,
    p_AS_OF_DATE IN DATE,
    p_ID_PAIRS OUT STRING_COLLECTION,
    p_STATUS OUT NUMBER,
    p_MESSAGE OUT VARCHAR,
	p_CURSOR IN OUT GA.REFCURSOR
    ) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_WORK_ID NUMBER;
v_SEQ NUMBER := 0;
v_GRAND_TOTAL NUMBER := 0;
v_MANUAL_COUNT NUMBER;
v_MANUAL_TOTAL NUMBER;
v_DO_MANUAL NUMBER := 0;
v_EXPORT_INVOICE NUMBER;
v_INVOICE_ID NUMBER;
v_ENTITY_NAME VARCHAR2(256);
v_STATEMENT_TYPE_NAME STATEMENT_TYPE.STATEMENT_TYPE_NAME%TYPE;

CURSOR c_PRODUCTS IS
	SELECT A.PRODUCT_ID, PRODUCT_NAME, SUM(CHARGE_AMOUNT) "CHARGE_AMOUNT"
	FROM BILLING_STATEMENT A,
    	PRODUCT B,
		COMPONENT C
    WHERE ENTITY_ID = p_ENTITY_ID
    	AND STATEMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
    	AND STATEMENT_TYPE = p_STATEMENT_TYPE
        AND STATEMENT_STATE = p_STATEMENT_STATE
		AND AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			 	FROM BILLING_STATEMENT
				WHERE ENTITY_ID = A.ENTITY_ID
					AND PRODUCT_ID = A.PRODUCT_ID
					AND COMPONENT_ID = A.COMPONENT_ID
					AND STATEMENT_TYPE = A.STATEMENT_TYPE
					AND STATEMENT_STATE = A.STATEMENT_STATE
					AND STATEMENT_DATE = A.STATEMENT_DATE
					AND AS_OF_DATE <= p_AS_OF_DATE)
		AND B.PRODUCT_ID = A.PRODUCT_ID
		AND A.COMPONENT_ID = C.COMPONENT_ID
		AND NVL(C.EXCLUDE_FROM_BILLING_EXPORT, 0) = 0
    GROUP BY A.PRODUCT_ID, PRODUCT_NAME
	ORDER BY PRODUCT_NAME;

CURSOR c_COMPONENTS(p_PRODUCT_ID IN NUMBER) IS
	SELECT A.COMPONENT_ID, COMPONENT_NAME, SUM(CHARGE_AMOUNT) "CHARGE_AMOUNT"
	FROM BILLING_STATEMENT A,
    	COMPONENT B
    WHERE ENTITY_ID = p_ENTITY_ID
    	AND PRODUCT_ID = p_PRODUCT_ID
    	AND STATEMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
    	AND STATEMENT_TYPE = p_STATEMENT_TYPE
        AND STATEMENT_STATE = p_STATEMENT_STATE
		AND AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			 	FROM BILLING_STATEMENT
				WHERE ENTITY_ID = A.ENTITY_ID
					AND PRODUCT_ID = A.PRODUCT_ID
					AND COMPONENT_ID = A.COMPONENT_ID
					AND STATEMENT_TYPE = A.STATEMENT_TYPE
					AND STATEMENT_STATE = A.STATEMENT_STATE
					AND STATEMENT_DATE = A.STATEMENT_DATE
					AND AS_OF_DATE <= p_AS_OF_DATE)
		AND B.COMPONENT_ID = A.COMPONENT_ID
        -- exclude transmission charges
        AND NOT (UPPER(CHARGE_VIEW_TYPE) = 'TRANSMISSION' OR
        		 (UPPER(CHARGE_VIEW_TYPE) = 'EXTERNAL' AND XS.COMPONENT_IS_TX_CHARGE(p_CALLING_MODULE,p_MODEL_ID,A.COMPONENT_ID)=1))
    	AND NVL(B.EXCLUDE_FROM_BILLING_EXPORT, 0) = 0
	GROUP BY A.COMPONENT_ID, COMPONENT_NAME
	ORDER BY COMPONENT_NAME;

CURSOR c_TX_CHARGES(p_PRODUCT_ID IN NUMBER) IS
	SELECT 0 "COMPONENT_ID",
    	DECODE(UPPER(SUBSTR(A.CHARGE_VIEW_TYPE,1,3)),'EXT',XS.GET_TX_SERVICE_TYPE(p_CALLING_MODULE,p_MODEL_ID,A.COMPONENT_ID),
				        		DECODE(UPPER(B.RATE_STRUCTURE),'INTERNAL','None',B.COMPONENT_REFERENCE)) "COMPONENT_NAME",
        SUM(CHARGE_AMOUNT) "CHARGE_AMOUNT"
	FROM BILLING_STATEMENT A,
    	COMPONENT B
    WHERE ENTITY_ID = p_ENTITY_ID
    	AND PRODUCT_ID = p_PRODUCT_ID
    	AND STATEMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
    	AND STATEMENT_TYPE = p_STATEMENT_TYPE
        AND STATEMENT_STATE = p_STATEMENT_STATE
		AND AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			 	FROM BILLING_STATEMENT
				WHERE ENTITY_ID = A.ENTITY_ID
					AND PRODUCT_ID = A.PRODUCT_ID
					AND COMPONENT_ID = A.COMPONENT_ID
					AND STATEMENT_TYPE = A.STATEMENT_TYPE
					AND STATEMENT_STATE = A.STATEMENT_STATE
					AND STATEMENT_DATE = A.STATEMENT_DATE
					AND AS_OF_DATE <= p_AS_OF_DATE)
		AND B.COMPONENT_ID = A.COMPONENT_ID
        -- include transmission charges only
        AND (UPPER(CHARGE_VIEW_TYPE) = 'TRANSMISSION' OR
        		 (UPPER(CHARGE_VIEW_TYPE) = 'EXTERNAL' AND XS.COMPONENT_IS_TX_CHARGE(p_CALLING_MODULE,p_MODEL_ID,A.COMPONENT_ID)=1))
    	AND NVL(B.EXCLUDE_FROM_BILLING_EXPORT, 0) = 0
	GROUP BY 0, DECODE(UPPER(SUBSTR(A.CHARGE_VIEW_TYPE,1,3)),'EXT',XS.GET_TX_SERVICE_TYPE(p_CALLING_MODULE,p_MODEL_ID,A.COMPONENT_ID),
									        		DECODE(UPPER(B.RATE_STRUCTURE),'INTERNAL','None',B.COMPONENT_REFERENCE))
	ORDER BY COMPONENT_NAME;

CURSOR c_MANUAL_INVOICE_LINES IS
	SELECT DISTINCT B.LINE_ITEM_NAME, B.LINE_ITEM_AMOUNT
    FROM INVOICE A, INVOICE_USER_LINE_ITEM B
    WHERE A.ENTITY_ID = p_ENTITY_ID
    	AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
        AND A.STATEMENT_STATE = p_STATEMENT_STATE
    	AND A.BEGIN_DATE <= v_END_DATE
        AND A.AS_OF_DATE =
        	(SELECT MAX(AS_OF_DATE)
            	FROM INVOICE
                WHERE ENTITY_ID = A.ENTITY_ID
                	AND STATEMENT_TYPE = A.STATEMENT_TYPE
                    AND STATEMENT_STATE = A.STATEMENT_STATE
                    AND BEGIN_DATE = A.BEGIN_DATE
                    AND AS_OF_DATE <= p_AS_OF_DATE)
        AND A.END_DATE >= v_BEGIN_DATE
        AND B.ENTITY_ID = A.ENTITY_ID
        AND B.STATEMENT_TYPE = A.STATEMENT_TYPE
        AND B.STATEMENT_STATE = A.STATEMENT_STATE
        AND B.BEGIN_DATE = A.BEGIN_DATE;

CURSOR c_ID_PAIRS IS
	SELECT DISTINCT TO_CHAR(A.PRODUCT_ID||'|'||A.COMPONENT_ID) "VAL",
		B.PRODUCT_NAME, C.COMPONENT_NAME
	FROM BILLING_STATEMENT A,
    	PRODUCT B,
    	COMPONENT C
    WHERE ENTITY_ID = p_ENTITY_ID
    	AND STATEMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
    	AND STATEMENT_TYPE = p_STATEMENT_TYPE
        AND STATEMENT_STATE = p_STATEMENT_STATE
		AND AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			 	FROM BILLING_STATEMENT
				WHERE ENTITY_ID = A.ENTITY_ID
					AND PRODUCT_ID = A.PRODUCT_ID
					AND COMPONENT_ID = A.COMPONENT_ID
					AND STATEMENT_TYPE = A.STATEMENT_TYPE
					AND STATEMENT_STATE = A.STATEMENT_STATE
					AND STATEMENT_DATE = A.STATEMENT_DATE
					AND AS_OF_DATE <= p_AS_OF_DATE)
		AND B.PRODUCT_ID = A.PRODUCT_ID
		AND C.COMPONENT_ID = A.COMPONENT_ID
		AND NVL(C.EXCLUDE_FROM_BILLING_EXPORT, 0) = 0
    ORDER BY PRODUCT_NAME, COMPONENT_NAME;

		PROCEDURE ADD_LINE
			(
			p_LINE IN VARCHAR2
			) AS
		BEGIN
			INSERT INTO RTO_WORK (WORK_ID, WORK_SEQ, WORK_DATA)
			VALUES (v_WORK_ID, v_SEQ, p_LINE);
			v_SEQ := v_SEQ + 1;
		END ADD_LINE;
BEGIN

	p_STATUS := GA.SUCCESS;
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	UT.GET_RTO_WORK_ID(v_WORK_ID);

    v_EXPORT_INVOICE := NVL(TO_NUMBER(MODEL_VALUE_AT_KEY(p_MODEL_ID,'Billing Export','Options', 'Use Invoice For Summary', 0)),0);

    IF v_EXPORT_INVOICE = 1 THEN

		BEGIN
        	SELECT TRUNC(BEGIN_DATE), ADD_SECONDS_TO_DATE(TRUNC(END_DATE)+1,-1), INVOICE_ID
            INTO v_BEGIN_DATE, v_END_DATE, v_INVOICE_ID
            FROM INVOICE A
            WHERE ENTITY_ID = p_ENTITY_ID
		    	AND STATEMENT_TYPE = p_STATEMENT_TYPE
		        AND STATEMENT_STATE = p_STATEMENT_STATE
                AND BEGIN_DATE <= p_BEGIN_DATE
                AND AS_OF_DATE =
		        	(SELECT MAX(AS_OF_DATE)
		            	FROM INVOICE
		                WHERE ENTITY_ID = A.ENTITY_ID
		                	AND STATEMENT_TYPE = A.STATEMENT_TYPE
		                    AND STATEMENT_STATE = A.STATEMENT_STATE
		                    AND BEGIN_DATE = A.BEGIN_DATE
		                    AND AS_OF_DATE <= p_AS_OF_DATE)
				AND END_DATE >= p_BEGIN_DATE;
        EXCEPTION
        	WHEN NO_DATA_FOUND THEN
            	-- return no data
            	p_ID_PAIRS := STRING_COLLECTION();
                NULL_CURSOR(p_CURSOR);
                RETURN;
        END;

		GET_EXPORT_INVOICE_SUMMARY (p_MODEL_ID, v_INVOICE_ID, v_WORK_ID);
    ELSE
        v_BEGIN_DATE := PC.GET_CORRECT_STATEMENT_DATE(p_CALLING_MODULE,p_ENTITY_ID,p_BEGIN_DATE);
        v_END_DATE := PC.GET_CORRECT_STATEMENT_DATE(p_CALLING_MODULE,p_ENTITY_ID,p_END_DATE);
        v_END_DATE := PC.GET_CORRECT_STATEMENT_END_DATE(p_CALLING_MODULE,p_ENTITY_ID,v_END_DATE);
        IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING THEN
        	-- for PSE Billing, only export manual line items if the invoice and
            -- statement intervals are the same
            SELECT DECODE(UPPER(SUBSTR(STATEMENT_INTERVAL,1,2)),UPPER(SUBSTR(INVOICE_INTERVAL,1,2)),1,0)
            INTO v_DO_MANUAL
            FROM PURCHASING_SELLING_ENTITY
            WHERE PSE_ID = p_ENTITY_ID;
        ELSE
        	-- non-PSE Billing? then invoice and statement intervals are always
            -- the same: Month
        	v_DO_MANUAL := 1;
        END IF;

		p_BEGIN_DATE := TRUNC(v_BEGIN_DATE);
		p_END_DATE := TRUNC(v_END_DATE);

		SELECT STATEMENT_TYPE_NAME INTO v_STATEMENT_TYPE_NAME FROM STATEMENT_TYPE WHERE STATEMENT_TYPE_ID = p_STATEMENT_TYPE;

		-- get entity name
		IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_POSITION_AND_BILLING THEN
			SELECT BILL_PARTY_NAME INTO v_ENTITY_NAME
			FROM BILL_PARTY
			WHERE BILL_PARTY_ID = p_ENTITY_ID;
		ELSIF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING THEN
			SELECT PSE_NAME INTO v_ENTITY_NAME
			FROM PURCHASING_SELLING_ENTITY
			WHERE PSE_ID = p_ENTITY_ID;
		ELSIF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_GAS_DELIVERY THEN
			SELECT POOL_NAME INTO v_ENTITY_NAME
			FROM POOL
			WHERE POOL_ID = p_ENTITY_ID;
		END IF;

		--Add some summary rows.
		ADD_LINE('Counter-Party: ' || v_ENTITY_NAME);
		ADD_LINE('Billing Period: ' || TO_CHAR(p_BEGIN_DATE, g_SHORT_DATE_FORMAT) || ' -> ' || TO_CHAR(p_END_DATE, g_SHORT_DATE_FORMAT));
		ADD_LINE(v_STATEMENT_TYPE_NAME);
		ADD_LINE(' ');

		-- build the output into RTO_WORK
        FOR v_PRODUCT IN c_PRODUCTS LOOP
        	v_GRAND_TOTAL := v_GRAND_TOTAL + v_PRODUCT.CHARGE_AMOUNT;
			ADD_LINE(v_PRODUCT.PRODUCT_NAME||'|||$'||ROUND(v_PRODUCT.CHARGE_AMOUNT,2));

        	FOR v_TX_CHARGE IN c_TX_CHARGES(v_PRODUCT.PRODUCT_ID) LOOP
				ADD_LINE('|'||EXPORT_TX_TITLE(v_TX_CHARGE.COMPONENT_NAME)||'|||$'||ROUND(v_TX_CHARGE.CHARGE_AMOUNT,2));
            END LOOP;

            FOR v_COMPONENT IN c_COMPONENTS(v_PRODUCT.PRODUCT_ID) LOOP
				ADD_LINE('|'||v_COMPONENT.COMPONENT_NAME||'|||$'||ROUND(v_COMPONENT.CHARGE_AMOUNT,2));
            END LOOP;
        END LOOP;

        IF v_DO_MANUAL = 1 THEN
        	-- monthly billing? then also put manual invoice line items
    		SELECT COUNT(*), SUM(B.LINE_ITEM_AMOUNT) INTO v_MANUAL_COUNT, v_MANUAL_TOTAL
    	    FROM INVOICE A, INVOICE_USER_LINE_ITEM B
            WHERE A.ENTITY_ID = p_ENTITY_ID
            	AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
                AND A.STATEMENT_STATE = p_STATEMENT_STATE
            	AND A.BEGIN_DATE <= v_END_DATE
                AND A.END_DATE >= v_BEGIN_DATE
                AND B.ENTITY_ID = A.ENTITY_ID
                AND B.STATEMENT_TYPE = A.STATEMENT_TYPE
                AND B.STATEMENT_STATE = A.STATEMENT_STATE
                AND B.BEGIN_DATE = A.BEGIN_DATE;

            IF v_MANUAL_COUNT > 0 THEN
    			v_GRAND_TOTAL := v_GRAND_TOTAL + v_MANUAL_TOTAL;
				ADD_LINE('Manual Line Items|||$'||ROUND(v_MANUAL_TOTAL,2));

    			FOR v_MANUAL_LINE IN c_MANUAL_INVOICE_LINES LOOP
					ADD_LINE('|'||v_MANUAL_LINE.LINE_ITEM_NAME||'|||$'||ROUND(v_MANUAL_LINE.LINE_ITEM_AMOUNT,2));
    	        END LOOP;

    		END IF;
        END IF;

		ADD_LINE(' ');
		ADD_LINE('Grand Total|||$'||ROUND(v_GRAND_TOTAL,2));
		ADD_LINE(' ');

	END IF;

    -- select output into cursor
    OPEN p_CURSOR FOR
    	SELECT WORK_DATA
        FROM RTO_WORK
        WHERE WORK_ID = v_WORK_ID
        ORDER BY WORK_SEQ;

    -- get list of products/components
	p_ID_PAIRS := STRING_COLLECTION();
	FOR v_ID_PAIRS IN c_ID_PAIRS LOOP
		p_ID_PAIRS.EXTEND();
		p_ID_PAIRS(p_ID_PAIRS.LAST) := v_ID_PAIRS.VAL;
	END LOOP;

    -- cleanup and then done
	UT.PURGE_RTO_WORK(v_WORK_ID);

EXCEPTION
	WHEN OTHERS THEN
    	UT.PURGE_RTO_WORK(v_WORK_ID);
        ERRS.LOG_AND_RAISE();

END GET_EXPORT_SUMMARY;
---------------------------------------------------------------------------------------------------
PROCEDURE WRITE_TX_CHARGE_LINE
	(
    p_TRANSACTION_NAME IN VARCHAR,
    p_TRANSACTION_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_INTERVAL IN VARCHAR,
    p_CAPACITY_RESERVED IN NUMBER,
    p_TRANS_RATE IN NUMBER, p_TRANS_AMOUNT IN NUMBER,
    p_AS1_RATE IN NUMBER, p_AS1_AMOUNT IN NUMBER,
    p_AS2_RATE IN NUMBER, p_AS2_AMOUNT IN NUMBER,
    p_AS3_RATE IN NUMBER, p_AS3_AMOUNT IN NUMBER,
    p_AS4_RATE IN NUMBER, p_AS4_AMOUNT IN NUMBER,
    p_AS5_RATE IN NUMBER, p_AS5_AMOUNT IN NUMBER,
    p_AS6_RATE IN NUMBER, p_AS6_AMOUNT IN NUMBER,
    p_WORK_ID IN NUMBER,
    p_OUT_WORK_ID IN NUMBER,
    p_TIME_ZONE IN VARCHAR,
    p_SEQ IN OUT NUMBER
    ) AS
v_ROW_TOTAL NUMBER;
v_ROW_NOTES VARCHAR2(32);
v_FMT_BEGIN_DATE VARCHAR2(32);
v_OFFSET NUMBER;
v_TIMEZ_OFFSET VARCHAR2(8);
CURSOR c_NOTES IS
	SELECT DISTINCT A.CHARGE_INTERVAL "NOTE"
   	FROM TRANSMISSION_CHARGE A, RTO_WORK B
    WHERE TRANSACTION_NAME = p_TRANSACTION_NAME
    	AND TRANSACTION_ID = p_TRANSACTION_ID
        AND CHARGE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
        AND CHARGE_ID < 0
        AND WORK_XID = CHARGE_ID
        AND WORK_ID = p_WORK_ID
        AND NOT (CHARGE_INTERVAL IS NULL)
	ORDER BY 1;
BEGIN
    v_ROW_TOTAL := p_TRANS_AMOUNT+p_AS1_AMOUNT+p_AS2_AMOUNT+
            	p_AS3_AMOUNT+p_AS4_AMOUNT+p_AS5_AMOUNT+p_AS6_AMOUNT;
    -- gather notes for this row
    v_ROW_NOTES := '';
    FOR v_NOTE IN c_NOTES LOOP
    	v_ROW_NOTES := v_ROW_NOTES||' '||v_NOTE.NOTE;
    END LOOP;
    -- format begin date - not hour-ending
    SELECT DECODE(UPPER(SUBSTR(p_INTERVAL,1,2)),'5 ',5,'10',10,'15',15,'20',20,'30',30,'HO',60,'DA',0,'WE',0,'MO',0,'QU',0,'YE',0)
    INTO v_OFFSET FROM DUAL;
    IF v_OFFSET <= 0 THEN
    	v_FMT_BEGIN_DATE := FROM_CUT_AS_HED(p_BEGIN_DATE,p_TIME_ZONE,GET_FORMAT_FROM_INTERVAL(p_INTERVAL));
    ELSE
      SELECT Z.STANDARD_TIME_ZONE_OFFSET INTO v_TIMEZ_OFFSET
      FROM SYSTEM_TIME_ZONE Z
      WHERE TIME_ZONE = p_TIME_ZONE;
      v_FMT_BEGIN_DATE := TO_CHAR(FROM_TZ(CAST(ADD_MINUTES_TO_DATE(p_BEGIN_DATE,-v_OFFSET) AS TIMESTAMP), TZ_OFFSET(CUT_TIME_ZONE)) AT TIME ZONE v_TIMEZ_OFFSET ,g_LONG_DATE_FORMAT);
     END IF;
    -- put into to output work table
    INSERT INTO RTO_WORK (WORK_ID, WORK_SEQ, WORK_DATA)
    	VALUES (p_OUT_WORK_ID, p_SEQ, p_TRANSACTION_NAME||'|'||
                                      ''''||v_FMT_BEGIN_DATE||'|'||
                                      ''''||FROM_CUT_AS_HED(p_END_DATE,p_TIME_ZONE,GET_FORMAT_FROM_INTERVAL(p_INTERVAL))||'|'||
                                      p_CAPACITY_RESERVED||'|'||
                                      ROUND(p_TRANS_RATE,2)||'|'||ROUND(p_TRANS_AMOUNT,2)||'|'||
                                      ROUND(p_AS1_RATE,2)||'|'||ROUND(p_AS1_AMOUNT,2)||'|'||
                                      ROUND(p_AS2_RATE,2)||'|'||ROUND(p_AS2_AMOUNT,2)||'|'||
                                      ROUND(p_AS3_RATE,2)||'|'||ROUND(p_AS3_AMOUNT,2)||'|'||
                                      ROUND(p_AS4_RATE,2)||'|'||ROUND(p_AS4_AMOUNT,2)||'|'||
                                      ROUND(p_AS5_RATE,2)||'|'||ROUND(p_AS5_AMOUNT,2)||'|'||
                                      ROUND(p_AS6_RATE,2)||'|'||ROUND(p_AS6_AMOUNT,2)||'|'||
                                      ROUND(v_ROW_TOTAL,2)||'|'||v_ROW_NOTES);
    p_SEQ := p_SEQ+1;
END WRITE_TX_CHARGE_LINE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_TX_CHARGE_EXPORT_DETAIL
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
    p_PRODUCT_ID IN NUMBER,
	p_PRODUCT_NAME IN VARCHAR2,
	p_COMPONENT_NAME IN VARCHAR2,
    p_STATEMENT_TYPE IN NUMBER,
    p_STATEMENT_STATE IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_AS_OF_DATE IN DATE,
    p_TIME_ZONE IN VARCHAR,
	p_CURSOR IN OUT GA.REFCURSOR
    ) AS
v_WORK_ID NUMBER;
v_CHARGE_ID NUMBER;
v_OUT_WORK_ID NUMBER;
v_SEQ NUMBER := 0;
v_LAST_TX_ID NUMBER := -1;
v_INTERVAL VARCHAR2(16);
CURSOR c_EXT IS
	SELECT COMPONENT_ID
	FROM BILLING_STATEMENT A
    WHERE ENTITY_ID = p_ENTITY_ID
    	AND PRODUCT_ID = p_PRODUCT_ID
    	AND STATEMENT_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
    	AND STATEMENT_TYPE = p_STATEMENT_TYPE
        AND STATEMENT_STATE = p_STATEMENT_STATE
		AND AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			 	FROM BILLING_STATEMENT
				WHERE ENTITY_ID = A.ENTITY_ID
					AND PRODUCT_ID = A.PRODUCT_ID
					AND COMPONENT_ID = A.COMPONENT_ID
					AND STATEMENT_TYPE = A.STATEMENT_TYPE
					AND STATEMENT_STATE = A.STATEMENT_STATE
					AND STATEMENT_DATE = A.STATEMENT_DATE
					AND AS_OF_DATE <= p_AS_OF_DATE)
        -- external transmission charges
		AND (UPPER(CHARGE_VIEW_TYPE) = 'EXTERNAL' AND XS.COMPONENT_IS_TX_CHARGE(p_CALLING_MODULE,p_MODEL_ID,A.COMPONENT_ID)=1);
CURSOR c_LINES IS
	SELECT TRANSACTION_NAME,
    	TRANSACTION_ID,
        CAPACITY_RESERVED,
        CHARGE_DATE,
        AVG(DECODE(UPPER(SERVICE_TYPE),'NONE',CHARGE_RATE,NULL)) "TRANS_RATE",
        SUM(DECODE(UPPER(SERVICE_TYPE),'NONE',CHARGE_AMOUNT,0)) "TRANS_AMOUNT",
        AVG(DECODE(UPPER(SERVICE_TYPE),'SCHEDULE 1',CHARGE_RATE,NULL)) "AS1_RATE",
        SUM(DECODE(UPPER(SERVICE_TYPE),'SCHEDULE 1',CHARGE_AMOUNT,0)) "AS1_AMOUNT",
        AVG(DECODE(UPPER(SERVICE_TYPE),'SCHEDULE 2',CHARGE_RATE,NULL)) "AS2_RATE",
        SUM(DECODE(UPPER(SERVICE_TYPE),'SCHEDULE 2',CHARGE_AMOUNT,0)) "AS2_AMOUNT",
        AVG(DECODE(UPPER(SERVICE_TYPE),'SCHEDULE 3',CHARGE_RATE,NULL)) "AS3_RATE",
        SUM(DECODE(UPPER(SERVICE_TYPE),'SCHEDULE 3',CHARGE_AMOUNT,0)) "AS3_AMOUNT",
        AVG(DECODE(UPPER(SERVICE_TYPE),'SCHEDULE 4',CHARGE_RATE,NULL)) "AS4_RATE",
        SUM(DECODE(UPPER(SERVICE_TYPE),'SCHEDULE 4',CHARGE_AMOUNT,0)) "AS4_AMOUNT",
        AVG(DECODE(UPPER(SERVICE_TYPE),'SCHEDULE 5',CHARGE_RATE,NULL)) "AS5_RATE",
        SUM(DECODE(UPPER(SERVICE_TYPE),'SCHEDULE 5',CHARGE_AMOUNT,0)) "AS5_AMOUNT",
        AVG(DECODE(UPPER(SERVICE_TYPE),'SCHEDULE 6',CHARGE_RATE,NULL)) "AS6_RATE",
        SUM(DECODE(UPPER(SERVICE_TYPE),'SCHEDULE 6',CHARGE_AMOUNT,0)) "AS6_AMOUNT"
    FROM
    	-- bullt-in transmission charges
    (SELECT A.TRANSACTION_NAME,
    	A.TRANSACTION_ID,
        A.CAPACITY_RESERVED,
        A.CHARGE_DATE,
        DECODE(A.CAPACITY_RESERVED,0,A.CHARGE_RATE,A.CHARGE_AMOUNT/A.CAPACITY_RESERVED) "CHARGE_RATE",
        A.CHARGE_AMOUNT,
        DECODE(UPPER(C.RATE_STRUCTURE),'INTERNAL','None',C.COMPONENT_REFERENCE) "SERVICE_TYPE"
	FROM TRANSMISSION_CHARGE A,
    	BILLING_STATEMENT B,
        COMPONENT C
	WHERE B.ENTITY_ID = p_ENTITY_ID
    	AND B.PRODUCT_ID = p_PRODUCT_ID
    	AND B.STATEMENT_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
    	AND B.STATEMENT_TYPE = p_STATEMENT_TYPE
        AND B.STATEMENT_STATE = p_STATEMENT_STATE
		AND B.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			 	FROM BILLING_STATEMENT
				WHERE ENTITY_ID = B.ENTITY_ID
					AND PRODUCT_ID = B.PRODUCT_ID
					AND COMPONENT_ID = B.COMPONENT_ID
					AND STATEMENT_TYPE = B.STATEMENT_TYPE
					AND STATEMENT_STATE = B.STATEMENT_STATE
					AND STATEMENT_DATE = B.STATEMENT_DATE
					AND AS_OF_DATE <= p_AS_OF_DATE)
        AND A.CHARGE_ID = B.CHARGE_ID
        AND A.CHARGE_ID > 0
        AND A.CHARGE_AMOUNT <> 0
        AND C.COMPONENT_ID = B.COMPONENT_ID
    UNION ALL
    	-- external transmission charges
	SELECT A.TRANSACTION_NAME,
    	A.TRANSACTION_ID,
        A.CAPACITY_RESERVED,
        A.CHARGE_DATE,
        DECODE(A.CAPACITY_RESERVED,0,A.CHARGE_RATE,A.CHARGE_AMOUNT/A.CAPACITY_RESERVED) "CHARGE_RATE",
        A.CHARGE_AMOUNT,
        B.WORK_DATA "SERVICE_TYPE"
	FROM TRANSMISSION_CHARGE A,
    	RTO_WORK B
	WHERE A.CHARGE_ID < 0
        AND A.CHARGE_AMOUNT <> 0
    	AND B.WORK_ID = v_WORK_ID
        AND B.WORK_XID = A.CHARGE_ID)
    GROUP BY TRANSACTION_NAME, TRANSACTION_ID, CAPACITY_RESERVED, CHARGE_DATE
	ORDER BY TRANSACTION_NAME, TRANSACTION_ID, CHARGE_DATE;
v_TOTALS c_LINES%ROWTYPE;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
BEGIN
	UT.GET_RTO_WORK_ID(v_WORK_ID);
	UT.GET_RTO_WORK_ID(v_OUT_WORK_ID);

	--add the header rows
	INSERT INTO RTO_WORK(WORK_ID, WORK_SEQ, WORK_DATA)
	VALUES(v_OUT_WORK_ID, v_SEQ, 'Product: ' || p_PRODUCT_NAME);
	v_SEQ := v_SEQ + 1;
	INSERT INTO RTO_WORK(WORK_ID, WORK_SEQ, WORK_DATA)
	VALUES(v_OUT_WORK_ID, v_SEQ, 'Component: ' || p_COMPONENT_NAME);
	v_SEQ := v_SEQ + 1;

    FOR v_EXT IN c_EXT LOOP
		UT.GET_RTO_WORK_ID(v_CHARGE_ID); -- get temp charge ID
        v_CHARGE_ID := -v_CHARGE_ID; -- negative to make sure it won't interfere w/ existing valid charge IDs
        INSERT INTO RTO_WORK (WORK_ID, WORK_XID) VALUES (v_WORK_ID, v_CHARGE_ID);
        XS.GET_TX_CHARGES_FOR_REPORT(p_CALLING_MODULE, p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_ENTITY_ID, p_PRODUCT_ID, v_EXT.COMPONENT_ID, p_STATEMENT_TYPE, p_TIME_ZONE, p_AS_OF_DATE, v_CHARGE_ID);
        -- add oasis service type to work table
        UPDATE RTO_WORK SET WORK_DATA = XS.GET_TX_SERVICE_TYPE(p_CALLING_MODULE, p_MODEL_ID, v_EXT.COMPONENT_ID)
        	WHERE WORK_ID = v_WORK_ID AND WORK_XID = v_CHARGE_ID;
    END LOOP;

    -- use output work table for creating report view
    	-- headers first
    INSERT INTO RTO_WORK (WORK_ID, WORK_SEQ, WORK_DATA)
    	VALUES (v_OUT_WORK_ID, v_SEQ, '||||'||EXPORT_TX_LABEL('None')||'|'||EXPORT_TX_LABEL('None')||'|'
        								||EXPORT_TX_LABEL('Schedule 1')||'|'||EXPORT_TX_LABEL('Schedule 1')||'|'
        								||EXPORT_TX_LABEL('Schedule 2')||'|'||EXPORT_TX_LABEL('Schedule 2')||'|'
        								||EXPORT_TX_LABEL('Schedule 3')||'|'||EXPORT_TX_LABEL('Schedule 3')||'|'
        								||EXPORT_TX_LABEL('Schedule 4')||'|'||EXPORT_TX_LABEL('Schedule 4')||'|'
        								||EXPORT_TX_LABEL('Schedule 5')||'|'||EXPORT_TX_LABEL('Schedule 5')||'|'
        								||EXPORT_TX_LABEL('Schedule 6')||'|'||EXPORT_TX_LABEL('Schedule 6')||'||');
	v_SEQ := v_SEQ + 1;
    INSERT INTO RTO_WORK (WORK_ID, WORK_SEQ, WORK_DATA)
    	VALUES (v_OUT_WORK_ID, v_SEQ, 'Reservation|Begin Date|End Date|Quant.Reserved|Rate|Amount|Rate|Amount|Rate|Amount|Rate|Amount|Rate|Amount|Rate|Amount|Rate|Amount|Total|Notes');
	v_SEQ := v_SEQ + 1;
    v_TOTALS.TRANSACTION_ID := -1;

    FOR v_LINE IN c_LINES LOOP
    	-- compact the line items - instead of one row per charge date, one row per common rates/capacities with
        -- begin and end date
        IF v_TOTALS.TRANSACTION_ID <> v_LINE.TRANSACTION_ID OR v_TOTALS.CAPACITY_RESERVED <> v_LINE.CAPACITY_RESERVED
        	OR v_TOTALS.TRANS_RATE <> v_LINE.TRANS_RATE
            OR v_TOTALS.AS1_RATE <> v_LINE.AS1_RATE OR v_TOTALS.AS2_RATE <> v_LINE.AS2_RATE
            OR v_TOTALS.AS3_RATE <> v_LINE.AS3_RATE OR v_TOTALS.AS4_RATE <> v_LINE.AS4_RATE
            OR v_TOTALS.AS5_RATE <> v_LINE.AS5_RATE OR v_TOTALS.AS6_RATE <> v_LINE.AS6_RATE THEN
        	-- only write to RTO_WORK when something changes
        	IF v_TOTALS.TRANSACTION_ID <> -1 THEN
                IF v_TOTALS.TRANSACTION_ID <> v_LAST_TX_ID THEN
                	v_LAST_TX_ID := v_TOTALS.TRANSACTION_ID;
                    BEGIN
        	            SELECT TRANSACTION_INTERVAL INTO v_INTERVAL
                        FROM INTERCHANGE_TRANSACTION WHERE TRANSACTION_ID = v_TOTALS.TRANSACTION_ID;
                    EXCEPTION
                    	WHEN OTHERS THEN
                        	v_INTERVAL := '';
                    END;
                END IF;
            	WRITE_TX_CHARGE_LINE (
                	v_TOTALS.TRANSACTION_NAME,
                    v_TOTALS.TRANSACTION_ID,
                    v_BEGIN_DATE,
                    v_END_DATE,
                    v_INTERVAL,
                    v_TOTALS.CAPACITY_RESERVED,
                    v_TOTALS.TRANS_RATE, v_TOTALS.TRANS_AMOUNT,
                    v_TOTALS.AS1_RATE, v_TOTALS.AS1_AMOUNT,
                    v_TOTALS.AS2_RATE, v_TOTALS.AS2_AMOUNT,
                    v_TOTALS.AS3_RATE, v_TOTALS.AS3_AMOUNT,
                    v_TOTALS.AS4_RATE, v_TOTALS.AS4_AMOUNT,
                    v_TOTALS.AS5_RATE, v_TOTALS.AS5_AMOUNT,
                    v_TOTALS.AS6_RATE, v_TOTALS.AS6_AMOUNT,
                    v_WORK_ID,
                    v_OUT_WORK_ID,
                    p_TIME_ZONE,
                    v_SEQ
                );
			END IF;
            -- re-initialize totals from current line
            v_TOTALS := v_LINE;
            v_BEGIN_DATE := v_LINE.CHARGE_DATE;
		ELSE
        	-- not a new line? then just accumulate the numbers
            v_TOTALS.TRANS_AMOUNT := v_TOTALS.TRANS_AMOUNT + v_LINE.TRANS_AMOUNT;
            v_TOTALS.AS1_AMOUNT := v_TOTALS.AS1_AMOUNT + v_LINE.AS1_AMOUNT;
            v_TOTALS.AS2_AMOUNT := v_TOTALS.AS2_AMOUNT + v_LINE.AS2_AMOUNT;
            v_TOTALS.AS3_AMOUNT := v_TOTALS.AS3_AMOUNT + v_LINE.AS3_AMOUNT;
            v_TOTALS.AS4_AMOUNT := v_TOTALS.AS4_AMOUNT + v_LINE.AS4_AMOUNT;
            v_TOTALS.AS5_AMOUNT := v_TOTALS.AS5_AMOUNT + v_LINE.AS5_AMOUNT;
            v_TOTALS.AS6_AMOUNT := v_TOTALS.AS6_AMOUNT + v_LINE.AS6_AMOUNT;
		END IF;
        -- keep pushing out end date
        v_END_DATE := v_LINE.CHARGE_DATE;
    END LOOP;
    -- write final line
	IF v_TOTALS.TRANSACTION_ID <> -1 THEN
        IF v_TOTALS.TRANSACTION_ID <> v_LAST_TX_ID THEN
            BEGIN
             SELECT TRANSACTION_INTERVAL INTO v_INTERVAL
                FROM INTERCHANGE_TRANSACTION WHERE TRANSACTION_ID = v_TOTALS.TRANSACTION_ID;
            EXCEPTION
            	WHEN OTHERS THEN
                	v_INTERVAL := '';
            END;
        END IF;
    	WRITE_TX_CHARGE_LINE (
        	v_TOTALS.TRANSACTION_NAME,
            v_TOTALS.TRANSACTION_ID,
            v_BEGIN_DATE,
            v_END_DATE,
            v_INTERVAL,
            v_TOTALS.CAPACITY_RESERVED,
            v_TOTALS.TRANS_RATE, v_TOTALS.TRANS_AMOUNT,
            v_TOTALS.AS1_RATE, v_TOTALS.AS1_AMOUNT,
            v_TOTALS.AS2_RATE, v_TOTALS.AS2_AMOUNT,
            v_TOTALS.AS3_RATE, v_TOTALS.AS3_AMOUNT,
            v_TOTALS.AS4_RATE, v_TOTALS.AS4_AMOUNT,
            v_TOTALS.AS5_RATE, v_TOTALS.AS5_AMOUNT,
            v_TOTALS.AS6_RATE, v_TOTALS.AS6_AMOUNT,
            v_WORK_ID,
            v_OUT_WORK_ID,
            p_TIME_ZONE,
            v_SEQ
        );
	END IF;

    -- select all this output into cursor
    OPEN p_CURSOR FOR
    	SELECT WORK_DATA
        FROM RTO_WORK
        WHERE WORK_ID = v_OUT_WORK_ID
        ORDER BY WORK_SEQ;

    -- cleanup and then done
    DELETE TRANSMISSION_CHARGE WHERE CHARGE_ID IN
    	(SELECT WORK_XID FROM RTO_WORK WHERE WORK_ID = v_WORK_ID);
	UT.PURGE_RTO_WORK(v_WORK_ID);
	UT.PURGE_RTO_WORK(v_OUT_WORK_ID);

EXCEPTION
	WHEN OTHERS THEN
	    DELETE TRANSMISSION_CHARGE WHERE CHARGE_ID IN
	    	(SELECT WORK_XID FROM RTO_WORK WHERE WORK_ID = v_WORK_ID);
    	UT.PURGE_RTO_WORK(v_WORK_ID);
		UT.PURGE_RTO_WORK(v_OUT_WORK_ID);
        RAISE;

END GET_TX_CHARGE_EXPORT_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_EXPORT_DETAIL
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
    p_STATEMENT_TYPE IN NUMBER,
    p_STATEMENT_STATE IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_AS_OF_DATE IN DATE,
    p_TIME_ZONE IN VARCHAR,
    p_ID_PAIRS IN OUT STRING_COLLECTION,
    p_USE_NORMAL_DETAIL OUT NUMBER,
    p_PRODUCT_ID OUT NUMBER,
    p_COMPONENT_ID OUT NUMBER,
    p_HEADER_ROWS OUT NUMBER,
    p_STATUS OUT NUMBER,
    p_MESSAGE OUT VARCHAR,
	p_CURSOR IN OUT GA.REFCURSOR
    ) AS

v_WORK_ID NUMBER;
v_ID_TABLE GA.ID_TABLE;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_RATE_STRUCTURE VARCHAR2(32);
v_EXCLUDE_FROM_BILLING_EXPORT COMPONENT.EXCLUDE_FROM_BILLING_EXPORT%TYPE;
v_NAME VARCHAR2(32);
v_EXCLUDE_DETAILS NUMBER;
v_COMPONENT_NAME COMPONENT.COMPONENT_NAME%TYPE;
v_PRODUCT_NAME PRODUCT.PRODUCT_NAME%TYPE;

CURSOR c_ID_PAIRS IS
	SELECT DISTINCT WORK_XID||'|'||WORK_DATA "VAL",
    	PRODUCT_NAME, COMPONENT_NAME
	FROM RTO_WORK A,
    	PRODUCT B,
    	COMPONENT C
    WHERE WORK_ID = v_WORK_ID
		AND B.PRODUCT_ID = WORK_XID
		AND C.COMPONENT_ID = WORK_DATA
    ORDER BY PRODUCT_NAME, COMPONENT_NAME;

BEGIN

	p_STATUS := GA.SUCCESS;
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    v_EXCLUDE_DETAILS := NVL(TO_NUMBER(MODEL_VALUE_AT_KEY(p_MODEL_ID,'Billing Export','Options', 'Exclude Details', 0)),0);
    IF v_EXCLUDE_DETAILS = 1 THEN
    	p_ID_PAIRS := STRING_COLLECTION();
        p_USE_NORMAL_DETAIL := 0;
        -- empty recordset
        OPEN p_CURSOR FOR
        	SELECT NULL FROM DUAL WHERE 0=1;
    END IF;

	v_BEGIN_DATE := TRUNC(p_BEGIN_DATE);
	v_END_DATE := ADD_SECONDS_TO_DATE(TRUNC(p_END_DATE)+1,-1);
	UT.GET_RTO_WORK_ID(v_WORK_ID);

	FOR v_INDEX IN p_ID_PAIRS.FIRST..p_ID_PAIRS.LAST LOOP
    	IF NOT (p_ID_PAIRS(v_INDEX) IS NULL) THEN
			UT.IDS_FROM_STRING(p_ID_PAIRS(v_INDEX), '|', v_ID_TABLE);
	    	INSERT INTO RTO_WORK (WORK_ID, WORK_XID, WORK_DATA, WORK_SEQ)
	        	VALUES (v_WORK_ID, v_ID_TABLE(1), v_ID_TABLE(2), v_INDEX);
        END IF;
    END LOOP;

    -- get next product
    SELECT WORK_XID, PRODUCT_NAME INTO p_PRODUCT_ID, v_PRODUCT_NAME
    FROM (SELECT WORK_XID, PRODUCT_NAME
    	FROM RTO_WORK, PRODUCT
        WHERE WORK_ID = v_WORK_ID
        	AND PRODUCT_ID = WORK_XID
        ORDER BY WORK_SEQ)
    WHERE ROWNUM = 1;

    -- remove from list of components those that are tx charges
    DELETE RTO_WORK
    WHERE WORK_ID = v_WORK_ID
    	AND WORK_XID = p_PRODUCT_ID
        AND WORK_DATA IN (SELECT DISTINCT TO_CHAR(COMPONENT_ID)
        				FROM BILLING_STATEMENT
						WHERE (UPPER(CHARGE_VIEW_TYPE) = 'TRANSMISSION' OR
							(UPPER(CHARGE_VIEW_TYPE) = 'EXTERNAL' AND XS.COMPONENT_IS_TX_CHARGE(p_CALLING_MODULE,p_MODEL_ID,COMPONENT_ID)=1)));

    IF SQL%ROWCOUNT > 0 THEN
    	-- rowcount > 0 means that there were some transmission charges - so
        -- compute those
    	p_COMPONENT_ID := 0;
        v_COMPONENT_NAME := 'Transmission Charges';
        p_HEADER_ROWS := 2;
        p_USE_NORMAL_DETAIL := 0;
        GET_TX_CHARGE_EXPORT_DETAIL (p_CALLING_MODULE, p_MODEL_ID, p_ENTITY_ID, p_PRODUCT_ID, v_PRODUCT_NAME, v_COMPONENT_NAME,
			p_STATEMENT_TYPE, p_STATEMENT_STATE, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, p_TIME_ZONE, p_CURSOR);
    ELSE
    	-- otherwise, process normal components
    	-- get component
        SELECT WORK_DATA, COMPONENT_NAME, RATE_STRUCTURE, EXCLUDE_FROM_BILLING_EXPORT
        INTO p_COMPONENT_ID, v_COMPONENT_NAME, v_RATE_STRUCTURE, v_EXCLUDE_FROM_BILLING_EXPORT
        FROM (SELECT WORK_DATA, COMPONENT_NAME, RATE_STRUCTURE, EXCLUDE_FROM_BILLING_EXPORT
        	FROM RTO_WORK, COMPONENT
            WHERE WORK_ID = v_WORK_ID
            	AND COMPONENT_ID = WORK_DATA
            ORDER BY WORK_SEQ)
        WHERE ROWNUM = 1;

		-- remove this one from the list
        DELETE RTO_WORK WHERE WORK_ID = v_WORK_ID AND WORK_XID = p_PRODUCT_ID
        	AND WORK_DATA = TO_CHAR(p_COMPONENT_ID);

		IF NVL(v_EXCLUDE_FROM_BILLING_EXPORT, 0) = 0 THEN
		    -- give external charges a chance to customize output
			IF UPPER(v_RATE_STRUCTURE) = 'EXTERNAL' THEN
				XS.GET_CHARGES_FOR_REPORT(p_CALLING_MODULE,p_MODEL_ID,v_BEGIN_DATE,v_END_DATE,p_ENTITY_ID,p_PRODUCT_ID,p_COMPONENT_ID,p_STATEMENT_TYPE,p_STATEMENT_STATE,p_TIME_ZONE,p_AS_OF_DATE,v_NAME,p_USE_NORMAL_DETAIL,p_HEADER_ROWS,p_CURSOR);
				IF NOT (v_NAME IS NULL) THEN
					v_COMPONENT_NAME := v_NAME;
				END IF;
			ELSE
				p_USE_NORMAL_DETAIL := 1;
			END IF;
			--Java will use the standard drilldown, but it will print the contents of the recordset first, as header rows.
			IF p_USE_NORMAL_DETAIL = 1 THEN
				OPEN p_CURSOR FOR
					SELECT 'Product: ' || v_PRODUCT_NAME
					FROM DUAL
					UNION ALL
					SELECT 'Component: ' || v_COMPONENT_NAME
					FROM DUAL
					UNION ALL
					SELECT ' '
					FROM DUAL;
			END IF;
		ELSE
			LOGS.LOG_WARN('COMPONENT',v_COMPONENT_NAME,'The Component cannot be exported when the EXCLUDE_FROM_BILLING_EXPORT flag is set.');
		END IF;
    END IF;

    -- re-build list of ID pairs
	p_ID_PAIRS := STRING_COLLECTION();
    FOR v_PAIR IN c_ID_PAIRS LOOP
		p_ID_PAIRS.EXTEND();
		p_ID_PAIRS(p_ID_PAIRS.LAST) := v_PAIR.VAL;
    END LOOP;

    -- cleanup and then done
	UT.PURGE_RTO_WORK(v_WORK_ID);

EXCEPTION
	WHEN OTHERS THEN
    	UT.PURGE_RTO_WORK(v_WORK_ID);
		ERRS.LOG_AND_RAISE();

END GET_EXPORT_DETAIL;
---------------------------------------------------------------------------------------------------
FUNCTION EXPORT_TX_TITLE
	(p_TX_SERVICE_TYPE IN VARCHAR) RETURN VARCHAR IS
BEGIN
	RETURN NVL(GET_DICTIONARY_VALUE(p_TX_SERVICE_TYPE, 1, 'BILLING EXPORT', 'TX SERVICE TYPE TITLE'),p_TX_SERVICE_TYPE);
END EXPORT_TX_TITLE;
---------------------------------------------------------------------------------------------------
FUNCTION EXPORT_TX_LABEL
	(p_TX_SERVICE_TYPE IN VARCHAR) RETURN VARCHAR IS
BEGIN
	RETURN NVL(GET_DICTIONARY_VALUE(p_TX_SERVICE_TYPE, 1, 'BILLING EXPORT', 'TX SERVICE TYPE LABEL'),p_TX_SERVICE_TYPE);
END EXPORT_TX_LABEL;
---------------------------------------------------------------------------------------------------
PROCEDURE TAX_COMPONENTS
	(
    p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
    ) AS
BEGIN
	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
    	SELECT DISTINCT COMPONENT_NAME "ENTITY_NAME", COMPONENT_ID "ENTITY_ID"
        FROM COMPONENT
        WHERE UPPER(CHARGE_TYPE) = 'TAX';

EXCEPTION
	WHEN OTHERS THEN
    	p_STATUS := SQLCODE;
END TAX_COMPONENTS;
---------------------------------------------------------------------------------------------------
FUNCTION GET_DOMAIN_ID
	(
    p_CALLING_MODULE IN VARCHAR
    ) RETURN NUMBER IS
v_DOMAIN_ALIAS VARCHAR2(32);
v_DOMAIN_ID NUMBER;
BEGIN
	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = 'S' THEN
    	v_DOMAIN_ALIAS := g_PSE;
	ELSIF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = 'G' THEN
    	v_DOMAIN_ALIAS := g_POOL;
	ELSE --IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = 'P' THEN
    	v_DOMAIN_ALIAS := g_BILL_PARTY;
    END IF;

    ID.ID_FOR_ENTITY_DOMAIN_ALIAS(v_DOMAIN_ALIAS, v_DOMAIN_ID);

    RETURN v_DOMAIN_ID;
END GET_DOMAIN_ID;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_ENTITY_TIME_ZONE
	(
    p_CALLING_MODULE IN VARCHAR,
    p_MODEL_ID IN NUMBER,
    p_ENTITY_ID IN NUMBER,
    p_TIME_ZONE OUT VARCHAR2,
    p_STATUS OUT NUMBER
    ) AS
BEGIN
	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING THEN
		SELECT TIME_ZONE INTO p_TIME_ZONE
	    FROM PURCHASING_SELLING_ENTITY
        WHERE PSE_ID = p_ENTITY_ID;
	ELSE
    	p_TIME_ZONE := LOCAL_TIME_ZONE;
	END IF;

EXCEPTION
	WHEN OTHERS THEN
    	p_TIME_ZONE := NULL;
        p_STATUS := SQLCODE;

END GET_ENTITY_TIME_ZONE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_INVOICE_CATEGORIES
	(
    p_ENTITY_ID IN NUMBER,
    p_INVOICE_DATE IN VARCHAR2,
    p_USING_ALL IN NUMBER,
    p_STATUS OUT NUMBER,
    p_CURSOR IN OUT GA.REFCURSOR
    ) AS
v_INVOICE_DATE DATE;
BEGIN
	IF p_INVOICE_DATE IS NULL THEN
		v_INVOICE_DATE := NULL;
	ELSE
		v_INVOICE_DATE := TO_DATE(SUBSTR(p_INVOICE_DATE,1,10), g_SHORT_DATE_FORMAT);
	END IF;

	p_STATUS := GA.SUCCESS;

	-- return all categories for the given date if the entity is set to all
    OPEN p_CURSOR FOR
		SELECT g_ALL_STRING FROM DUAL
		WHERE p_USING_ALL = 1
        UNION ALL
    	SELECT DISTINCT LINE_ITEM_CATEGORY
        FROM INVOICE A,
        	INVOICE_LINE_ITEM B
		WHERE A.ENTITY_ID = p_ENTITY_ID
        	AND A.STATEMENT_TYPE > 0
            AND A.STATEMENT_STATE BETWEEN 1 AND 2
            AND A.BEGIN_DATE = v_INVOICE_DATE
			AND B.INVOICE_ID = A.INVOICE_ID
            AND NOT (B.LINE_ITEM_CATEGORY IS NULL);

	p_STATUS := GA.SUCCESS;
EXCEPTION
	WHEN OTHERS THEN
        p_STATUS := SQLCODE;
END GET_INVOICE_CATEGORIES;
---------------------------------------------------------------------------------------------------
PROCEDURE APPROVE_INVOICE
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_INVOICE_ID IN NUMBER,
	p_STATUS OUT NUMBER
	) AS
BEGIN

	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING THEN
		DECLARE
			v_ENTITY_ID NUMBER(9);
		BEGIN
			SELECT ENTITY_ID INTO v_ENTITY_ID
			FROM INVOICE WHERE INVOICE_ID = p_INVOICE_ID;

			SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_PSE_INVOICE_APPROVE, v_ENTITY_ID, EC.ED_PSE);
		END;
	END IF;

	UPDATE INVOICE SET
		APPROVED_BY_ID = SECURITY_CONTROLS.CURRENT_USER_ID,
		APPROVED_WHEN = SYSDATE
	WHERE INVOICE_ID = p_INVOICE_ID
		AND APPROVED_BY_ID IS NULL;

	p_STATUS := GA.SUCCESS;

END APPROVE_INVOICE;
---------------------------------------------------------------------------------------------------
FUNCTION GET_SENT_STATUS
	(
	p_MODEL_ID IN NUMBER,
	p_OLD_STATUS IN VARCHAR2
	) RETURN VARCHAR2 IS
v_NEW_STATUS VARCHAR2(128);
BEGIN

	IF UPPER(p_OLD_STATUS) LIKE '%SENT%' THEN
		RETURN p_OLD_STATUS;
	END IF;

	SELECT VALUE INTO v_NEW_STATUS
	FROM SYSTEM_LABEL
	WHERE MODEL_ID = p_MODEL_ID
		AND UPPER(MODULE) = 'BILLING'
		AND UPPER(KEY1) = 'INVOICE'
		AND UPPER(KEY2) = 'STATUS'
		AND UPPER(KEY3) = '?'
		AND UPPER(VALUE) LIKE UPPER(p_OLD_STATUS)||'%SENT%'
		AND ROWNUM = 1;

	RETURN v_NEW_STATUS;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		-- try global model ID
		IF NVL(p_MODEL_ID,0) <> 0 THEN
			RETURN GET_SENT_STATUS (0, p_OLD_STATUS);
		ELSE
			RETURN p_OLD_STATUS || ' - Sent';
		END IF;

END GET_SENT_STATUS;
---------------------------------------------------------------------------------------------------
PROCEDURE UPDATE_INVOICE_STATUS_SENT
	(
	p_INVOICE_ID IN NUMBER
	) AS
v_OLD_STATUS VARCHAR2(128);
v_NEW_STATUS VARCHAR2(128);
BEGIN
	SELECT A.INVOICE_STATUS INTO v_OLD_STATUS
	FROM INVOICE A
	WHERE INVOICE_ID = p_INVOICE_ID;

	v_NEW_STATUS := GET_SENT_STATUS(CONSTANTS.GLOBAL_MODEL, v_OLD_STATUS);

	IF v_NEW_STATUS IS NULL THEN
		RETURN;
	ELSE
		UPDATE INVOICE SET INVOICE_STATUS = v_NEW_STATUS
		WHERE INVOICE_ID = p_INVOICE_ID;
	END IF;

END UPDATE_INVOICE_STATUS_SENT;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_INVOICE_DATES
	(
	p_ENTITY_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_STATUS OUT NUMBER,
    p_CURSOR IN OUT GA.REFCURSOR
	) AS
BEGIN
	--return all invoice dates for the given billing entity between begin date and end date
	OPEN p_CURSOR FOR
		SELECT DISTINCT TO_CHAR(BEGIN_DATE,g_SHORT_DATE_FORMAT)||' -> '||TO_CHAR(END_DATE,g_SHORT_DATE_FORMAT) INVOICE_DATE
		FROM INVOICE
		WHERE ENTITY_ID = p_ENTITY_ID
			AND p_STATEMENT_TYPE IN (CONSTANTS.ALL_ID,STATEMENT_TYPE)
			AND p_STATEMENT_STATE IN (CONSTANTS.ALL_ID,STATEMENT_STATE)
        	AND BEGIN_DATE <= p_END_DATE
			AND END_DATE >= p_BEGIN_DATE
		ORDER BY 1;

	p_STATUS := GA.SUCCESS;
EXCEPTION
	WHEN OTHERS THEN
        p_STATUS := SQLCODE;
END GET_INVOICE_DATES;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_INV_COMP_STATEMENT_TYPES
    (
	p_STATUS OUT NUMBER,
    p_CURSOR IN OUT GA.REFCURSOR
    ) AS

v_AVAILABLE_IDS ID_TABLE := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_STATEMENT_TYPE_LIST);

BEGIN
     p_STATUS := GA.SUCCESS;
     OPEN p_CURSOR FOR
          SELECT STATEMENT_TYPE_NAME||CASE WHEN STATE = 1 THEN '' ELSE ' External' END
                                           STATEMENT_TYPE_NAME,
                 STATEMENT_TYPE_ID*10 + STATE STATEMENT_TYPE_ID
          FROM (SELECT 1 STATE FROM DUAL
                UNION ALL
                SELECT 2 STATE FROM DUAL) A,
                STATEMENT_TYPE B,
				TABLE(CAST(v_AVAILABLE_IDS AS ID_TABLE)) X
		  WHERE (X.ID = SD.g_ALL_DATA_ENTITY_ID OR B.STATEMENT_TYPE_ID = X.ID)
		  	AND B.STATEMENT_TYPE_ID > 0
          ORDER BY STATE, STATEMENT_TYPE_ORDER;

END GET_INV_COMP_STATEMENT_TYPES;
---------------------------------------------------------------------------------------------------
FUNCTION GET_INVOICE_DATE_RANGE
	(
	p_ENTITY_ID IN VARCHAR2,
	p_STATEMENT_DATE IN DATE,
	p_INTERVAL IN VARCHAR2,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER
	) RETURN VARCHAR2 AS
v_RET VARCHAR2(64);
BEGIN

	SELECT TO_CHAR(BEGIN_DATE,g_SHORT_DATE_FORMAT)||' -> '||TO_CHAR(END_DATE,g_SHORT_DATE_FORMAT)
	INTO v_RET
	FROM INVOICE A, PURCHASING_SELLING_ENTITY B
	WHERE ENTITY_ID = p_ENTITY_ID
		AND p_STATEMENT_DATE BETWEEN BEGIN_DATE AND END_DATE
		AND STATEMENT_TYPE = p_STATEMENT_TYPE
		AND STATEMENT_STATE = p_STATEMENT_STATE
		AND PSE_ID = ENTITY_ID
		AND GET_INTERVAL_NUMBER(p_INTERVAL) <= GET_INTERVAL_NUMBER(NVL(B.INVOICE_INTERVAL,'Month'));

	RETURN v_RET;

EXCEPTION
	WHEN OTHERS THEN
		RETURN NULL;
END GET_INVOICE_DATE_RANGE;
---------------------------------------------------------------------------------------------------
/*
Builds recipient list for given invoice
*/
FUNCTION RECIPIENT_LIST
	(
	p_INVOICE_ID IN NUMBER,
	p_REC_TYPE IN VARCHAR2 := CONSTANTS.ALL_STRING
	) RETURN STRING_COLLECTION IS

v_RECIPIENT_LIST STRING_COLLECTION := STRING_COLLECTION();
v_WORK_ID NUMBER;
v_CONTACT_GROUP_ID NUMBER_COLLECTION := NUMBER_COLLECTION();
v_CONTACT_IDs NUMBER_COLLECTION := NUMBER_COLLECTION();

v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN
	-- First get all the contact groups
	SELECT PI.CONTACT_GROUP_ID
	BULK COLLECT INTO v_CONTACT_GROUP_ID
	FROM INVOICE I,
		PSE_INVOICE_RECIPIENT PI
	WHERE I.INVOICE_ID = p_INVOICE_ID
		AND PI.PSE_ID = I.ENTITY_ID
		AND PI.CONTACT_GROUP_ID IS NOT NULL
		AND (p_REC_TYPE = CONSTANTS.ALL_STRING OR PI.EMAIL_REC_TYPE = p_REC_TYPE);

	SELECT I.BEGIN_DATE, I.END_DATE
	INTO v_BEGIN_DATE, v_END_DATE
	FROM INVOICE I
	WHERE I.INVOICE_ID = p_INVOICE_ID;

	SELECT PI.CONTACT_ID
	BULK COLLECT INTO v_CONTACT_IDs
	FROM INVOICE I,
		PSE_INVOICE_RECIPIENT PI
		WHERE I.INVOICE_ID = p_INVOICE_ID
			AND PI.PSE_ID = I.ENTITY_ID
			AND PI.CONTACT_ID IS NOT NULL
			AND (p_REC_TYPE = CONSTANTS.ALL_STRING OR PI.EMAIL_REC_TYPE = p_REC_TYPE);

	SD.ENUMERATE_UNION_OF_ENTITIES(v_CONTACT_GROUP_ID, NULL, v_CONTACT_IDs, EC.ED_CONTACT, v_WORK_ID, v_BEGIN_DATE, v_END_DATE);

	SELECT DISTINCT C.EMAIL_ADDRESS
	BULK COLLECT INTO v_RECIPIENT_LIST
	FROM RTO_WORK WRK, CONTACT C
	WHERE WRK.WORK_ID = v_WORK_ID
		AND C.CONTACT_ID = WRK.WORK_XID
		AND NVL(C.EMAIL_ADDRESS, CONSTANTS.UNDEFINED_ATTRIBUTE) <> CONSTANTS.UNDEFINED_ATTRIBUTE;

	RETURN v_RECIPIENT_LIST;

END RECIPIENT_LIST;
---------------------------------------------------------------------------------------------------
FUNCTION PARSE_FILE_NAME_FROM_PATH
	(
	p_FILE_PATH IN VARCHAR2
	) RETURN VARCHAR2 IS

v_FILE_NAME VARCHAR2(256);
v_DOT_POS NUMBER(9);

BEGIN

	v_FILE_NAME := TRIM(REGEXP_SUBSTR(p_FILE_PATH, '([[:alnum:]]|[^\/:*?"<>|])+[.][[:alnum:]]+$'));

	RETURN v_FILE_NAME;

END PARSE_FILE_NAME_FROM_PATH;
---------------------------------------------------------------------------------------------------
/*
This function takes in an invoice id and evaluates the formula given to it
*/
FUNCTION FORMAT_DYNAMIC_INVOICE_TEXT
	(
	p_INVOICE_ID IN NUMBER,
	p_FORMULA 	 IN VARCHAR2,
	p_FILE_EXT   IN VARCHAR2,
	p_ATTACH_NUM IN NUMBER
	) RETURN VARCHAR2 IS

v_STATEMENT_TYPE_ID NUMBER;
v_STATEMENT_TYPE_NAME VARCHAR2(32);
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_INVOICE_NUMBER NUMBER;
v_INVOICE_AMOUNT NUMBER;
v_CUSTOM_BEGIN_DATE VARCHAR2(256);
v_CUSTOM_END_DATE VARCHAR2(256);

v_ENTITY_NAME VARCHAR2(64);
v_RECIPIENTS VARCHAR2(4000);

v_VARIABLE_CACHE UT.STRING_MAP;
v_FORMAT VARCHAR2(512);
v_NON_CUSTOM_DATE_FORMAT VARCHAR2(512);
BEGIN

	SELECT I.STATEMENT_TYPE, S.STATEMENT_TYPE_NAME, I.BEGIN_DATE, I.END_DATE, I.INVOICE_NUMBER, PSE.PSE_NAME
	INTO v_STATEMENT_TYPE_ID, v_STATEMENT_TYPE_NAME, v_BEGIN_DATE, v_END_DATE, v_INVOICE_NUMBER, v_ENTITY_NAME
	FROM INVOICE I,
		PURCHASING_SELLING_ENTITY PSE,
		STATEMENT_TYPE S
	WHERE I.INVOICE_ID = p_INVOICE_ID
		AND PSE.PSE_ID = I.ENTITY_ID
		AND S.STATEMENT_TYPE_ID = I.STATEMENT_TYPE;

	-- Calculate Invoice Amount
	SELECT SUM(CASE WHEN DEFAULT_DISPLAY = 'BILL' THEN LINE_ITEM_BILL_AMOUNT ELSE LINE_ITEM_AMOUNT END)
	INTO v_INVOICE_AMOUNT
	FROM (SELECT ILI.DEFAULT_DISPLAY, ILI.LINE_ITEM_BILL_AMOUNT, ILI.LINE_ITEM_AMOUNT
	FROM INVOICE_LINE_ITEM ILI
	WHERE ILI.INVOICE_ID = p_INVOICE_ID
	UNION ALL
	SELECT IULI.DEFAULT_DISPLAY, IULI.LINE_ITEM_AMOUNT, IULI.LINE_ITEM_BILL_AMOUNT
	FROM INVOICE_USER_LINE_ITEM IULI, INVOICE I
	WHERE I.INVOICE_ID = p_INVOICE_ID
		AND IULI.ENTITY_ID = I.ENTITY_ID
		AND IULI.STATEMENT_TYPE = I.STATEMENT_TYPE
		AND IULI.STATEMENT_STATE = I.STATEMENT_STATE
		AND IULI.BEGIN_DATE = I.BEGIN_DATE) ;

	v_NON_CUSTOM_DATE_FORMAT := GET_DICTIONARY_VALUE('Date Format', 0, 'Billing','Invoice');
	v_VARIABLE_CACHE('begin_date') := TO_CHAR(v_BEGIN_DATE, v_NON_CUSTOM_DATE_FORMAT);
	v_VARIABLE_CACHE('end_date') := TO_CHAR(v_END_DATE, v_NON_CUSTOM_DATE_FORMAT);
	v_VARIABLE_CACHE('statement_type') := v_STATEMENT_TYPE_NAME;
	v_VARIABLE_CACHE('invoice_number') := v_INVOICE_NUMBER;
	v_VARIABLE_CACHE('entity_name') := v_ENTITY_NAME;
	v_VARIABLE_CACHE('invoice_amount') := v_INVOICE_AMOUNT;
	v_VARIABLE_CACHE('recipients') := TEXT_UTIL.TO_CHAR_STRING_LIST(RECIPIENT_LIST(p_INVOICE_ID, CONSTANTS.ALL_STRING));
	v_VARIABLE_CACHE('ext') := p_FILE_EXT;
	v_VARIABLE_CACHE('number') := p_ATTACH_NUM;

	v_CUSTOM_BEGIN_DATE := REGEXP_SUBSTR(p_FORMULA, '\${begin_date:(.+?)}');
	v_CUSTOM_END_DATE := REGEXP_SUBSTR(p_FORMULA, '\${end_date:(.+?)}');

	IF v_CUSTOM_BEGIN_DATE IS NOT NULL THEN
		v_CUSTOM_BEGIN_DATE := SUBSTR(v_CUSTOM_BEGIN_DATE, 3);
		v_CUSTOM_BEGIN_DATE := TRIM(TRAILING '}' FROM v_CUSTOM_BEGIN_DATE); -- begin_date:mm/dd/yyyy
		v_FORMAT := REGEXP_SUBSTR(v_CUSTOM_BEGIN_DATE, ':(.+)'); -- Result will look like ':mm/dd/yyyy'
		v_FORMAT := TRIM(LEADING ':' FROM v_FORMAT); -- remove ':'
		v_VARIABLE_CACHE(v_CUSTOM_BEGIN_DATE) := TO_CHAR(v_BEGIN_DATE, v_FORMAT);
	END IF;

	IF v_CUSTOM_END_DATE IS NOT NULL THEN
		v_CUSTOM_END_DATE := SUBSTR(v_CUSTOM_END_DATE, 3);
		v_CUSTOM_END_DATE := TRIM(TRAILING '}' FROM v_CUSTOM_END_DATE); -- end_date:mm/dd/yyyy
		v_FORMAT := REGEXP_SUBSTR(v_CUSTOM_END_DATE, ':(.+)'); -- Result will look like ':mm/dd/yyyy'
		v_FORMAT := TRIM(LEADING ':' FROM v_FORMAT); -- remove ':'
		v_VARIABLE_CACHE(v_CUSTOM_END_DATE) := TO_CHAR(v_END_DATE, v_FORMAT);
	END IF;

	RETURN FML_UTIL.REBUILD_FORMULA(p_FORMULA, v_VARIABLE_CACHE);

END FORMAT_DYNAMIC_INVOICE_TEXT;
---------------------------------------------------------------------------------------------------
/*
This function returns the crystal template files from
the table CRYSTEL_REPORT_FILES which stores the
report templates for a particular system object
*/

FUNCTION GET_INVOICE_CRYSTAL_TEMPLATE(
	p_INVOICE_ID IN NUMBER
	) RETURN BLOB IS

v_RPT BLOB;
v_PSE_NAME VARCHAR2(64);
v_OBJECT_ID NUMBER;
BEGIN
	-- Get the PSE ID for the particular invoice
	SELECT PSE.PSE_NAME
	INTO v_PSE_NAME
	FROM INVOICE I,
		PURCHASING_SELLING_ENTITY PSE
	WHERE I.INVOICE_ID = p_INVOICE_ID
		AND PSE.PSE_ID = I.ENTITY_ID;

	-- Try and get the custom template
	-- Parent Object Category|Parent Object Name/Object Category|Object Name
	v_OBJECT_ID := SO.GET_OBJECT_ID_FOR_PATH('Module|Billing/System View|Billing.Invoice/Report|BILLING_INVOICE_REPORT');

	BEGIN
		SELECT CRF.REPORT_FILE
		INTO v_RPT
		FROM CRYSTAL_REPORT_FILES CRF
		WHERE CRF.OBJECT_ID = v_OBJECT_ID
			AND CRF.TEMPLATE_TYPE = v_PSE_NAME;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			-- If we do not get the custom template, then
			-- get the default one
			SELECT CRF.REPORT_FILE
			INTO v_RPT
			FROM CRYSTAL_REPORT_FILES CRF
			WHERE CRF.OBJECT_ID = v_OBJECT_ID
				AND CRF.TEMPLATE_TYPE = '<Default>';
	END;

	RETURN v_RPT;

END GET_INVOICE_CRYSTAL_TEMPLATE;
---------------------------------------------------------------------------------------------------

-- Produce files for a single invoice. It creates a list of file names and a
-- corresponding list of BLOBs that contain the file contents.
-- %param p_INVOICE_ID	The invoice whose files are generated and retrieved. The
--				first file will be the generated invoice. Additional files
--				include any other attachments for the invoice.
-- %param p_EXPORT_FMT	The report format in which to generate the main invoice
--				file. This should be one of the constants defined in the
--				header of the CRYSTAL_REPORTS package.
-- %param p_IS_EMAIL Are we getting the invoice files for an email or for export
-- %param p_FILE_NAMES	The list of names for the files retrieved. If it is an
-- 				email then the first file will be named 'invoice<number>.<ext>'
--				where <number> comes from the invoice number defined in the invoice and <ext> is
--				derived from the export format. If it not an email, then the
-- 				the first file name will be build using the formula specified in
-- 				system_dictionary under 'Billing', 'Invoice', 'Batch Export Invoice Name'.
--				The attachments will get its name from the attachment table for emails and from
--				the formula specified in system_dictionary ('Billing', 'Invoice', 'Batch Export Attachment Name')
--				for export.
-- %param p_MIME_TYPES The list of MIME types for each file
-- %param p_FILE_CONTENTS	The list of BLOBs containing the file contents.
PROCEDURE GET_INVOICE_FILES
	(
	p_INVOICE_ID		IN NUMBER,
	p_EXPORT_FMT		IN NUMBER,
	p_IS_EMAIL			IN BOOLEAN,
	p_FILE_NAMES		OUT STRING_COLLECTION,
	p_MIME_TYPES		OUT STRING_COLLECTION,
	p_FILE_CONTENTS		OUT BLOB_COLLECTION
	) AS

v_PSE_ID NUMBER;
v_INVOICE_NUM NUMBER;
v_ENTITY_TYPE INVOICE.ENTITY_TYPE%TYPE;

v_RPT BLOB;
v_RESULT BLOB;
v_ROWCOUNT NUMBER;
v_QUERY VARCHAR2(4000);
v_PARMS UT.STRING_MAP;

v_ENTITY_NAME VARCHAR2(32);
v_INVOICE_TITLE SYSTEM_DICTIONARY.VALUE%TYPE;
v_COUNT NUMBER(9);
v_DOT_POS NUMBER(9);
v_FILE_EXT VARCHAR2(16);
v_EXPORT_PATH VARCHAR2(256);
v_POS NUMBER(9);
v_NAME VARCHAR2(256);
BEGIN

	SELECT I.INVOICE_NUMBER, I.ENTITY_ID, I.ENTITY_TYPE
	INTO v_INVOICE_NUM, v_PSE_ID, v_ENTITY_TYPE
	FROM INVOICE I
	WHERE I.INVOICE_ID = p_INVOICE_ID;

	IF v_ENTITY_TYPE = g_PSE THEN
		v_ENTITY_NAME := EI.GET_ENTITY_NAME(EC.ED_PSE, v_PSE_ID);
	ELSIF v_ENTITY_TYPE = g_POOL THEN
		v_ENTITY_NAME := EI.GET_ENTITY_NAME(EC.ED_POOL, v_PSE_ID);
	ELSIF v_ENTITY_TYPE = g_BILL_PARTY THEN
		v_ENTITY_NAME := EI.GET_ENTITY_NAME(EC.ED_BILL_PARTY, v_PSE_ID);
	END IF;

	SP.GET_SYSTEM_DICTIONARY_VALUE(GA.DEFAULT_MODEL, 'Billing', 'Invoice',
		CONSTANTS.UNDEFINED_ATTRIBUTE, CONSTANTS.UNDEFINED_ATTRIBUTE, 'Title',
		v_INVOICE_TITLE);

	v_PARMS('p_INVOICE_TITLE') := v_INVOICE_TITLE;
	v_PARMS('p_ENTITY_NAME') := v_ENTITY_NAME;

	p_FILE_NAMES := STRING_COLLECTION();
	p_FILE_NAMES.EXTEND;

	v_FILE_EXT := CRYSTAL_REPORTS.GET_FILE_EXTENSION(p_EXPORT_FMT);
	IF p_IS_EMAIL THEN
		p_FILE_NAMES(p_FILE_NAMES.LAST) := 'invoice' || v_INVOICE_NUM || '.' || v_FILE_EXT;
	ELSE
		v_EXPORT_PATH := FORMAT_DYNAMIC_INVOICE_TEXT(p_INVOICE_ID,
			NVL(GET_DICTIONARY_VALUE('Batch Export Invoice Name',0,'Billing','Invoice'),CONSTANTS.MIME_TYPE_UNKNOWN), v_FILE_EXT, -1);
		-- Get position of last '.'
		v_POS := INSTR(v_EXPORT_PATH, '.', -1, 1);
		IF v_POS = 0 THEN v_POS := 1; END IF;
		-- Remove all spaces after last '.'
		v_EXPORT_PATH := REGEXP_REPLACE(v_EXPORT_PATH,' ',null, v_POS);
		p_FILE_NAMES(p_FILE_NAMES.LAST) := v_EXPORT_PATH;
	END IF;

	v_RPT := GET_INVOICE_CRYSTAL_TEMPLATE(p_INVOICE_ID);

	v_QUERY := 'DECLARE v_STATUS NUMBER(9); BEGIN BSJ.GET_INVOICE_RPT_RECS_BY_ID(' || UT.GET_LITERAL_FOR_STRING('<ALL>') ||
		',' || UT.GET_LITERAL_FOR_NUMBER(p_INVOICE_ID) || ',v_STATUS,?); END;';

	CRYSTAL_REPORTS.FORMAT_REPORT(v_RPT, v_QUERY, p_EXPORT_FMT, v_RESULT, v_ROWCOUNT, v_PARMS);

	-- Invoice Contents
	p_FILE_CONTENTS := BLOB_COLLECTION();
	p_FILE_CONTENTS.EXTEND;
	p_FILE_CONTENTS(1) := v_RESULT;

	-- Invoice mime type
	p_MIME_TYPES := STRING_COLLECTION();
	p_MIME_TYPES.EXTEND;
	p_MIME_TYPES(1) := 	NVL(GET_DICTIONARY_VALUE(v_FILE_EXT, CONSTANTS.GLOBAL_MODEL, 'System', 'MIME Types'),CONSTANTS.MIME_TYPE_UNKNOWN);

	v_COUNT := 1;
	FOR v_REC IN (SELECT IA.FILE_NAME, IA.FILE_CONTENTS, IA.FILE_MIME_TYPE
			FROM INVOICE_ATTACHMENT IA
			WHERE IA.INVOICE_ID = p_INVOICE_ID) LOOP
		p_FILE_NAMES.EXTEND;
		IF p_IS_EMAIL THEN
			p_FILE_NAMES(p_FILE_NAMES.LAST) := v_REC.FILE_NAME;
		ELSE
			v_DOT_POS := INSTR(v_REC.FILE_NAME, '.');
			v_FILE_EXT := SUBSTR(v_REC.FILE_NAME, v_DOT_POS + 1);

			v_EXPORT_PATH := FORMAT_DYNAMIC_INVOICE_TEXT(p_INVOICE_ID,
				NVL(GET_DICTIONARY_VALUE('Batch Export Attachment Name', 0, 'Billing','Invoice'), CONSTANTS.MIME_TYPE_UNKNOWN),
				v_FILE_EXT, v_COUNT);
			-- Get position of last '.'
			v_POS := INSTR(v_EXPORT_PATH, '.', -1, 1);
			IF v_POS = 0 THEN v_POS := 1; END IF;
			-- Remove all spaces after last '.'
			v_EXPORT_PATH := REGEXP_REPLACE(v_EXPORT_PATH,' ', NULL, v_POS);
			p_FILE_NAMES(p_FILE_NAMES.LAST) := v_EXPORT_PATH;

			v_COUNT := v_COUNT + 1;
		END IF;

		p_FILE_CONTENTS.EXTEND;
		p_FILE_CONTENTS(p_FILE_CONTENTS.LAST) := v_REC.FILE_CONTENTS;

		p_MIME_TYPES.EXTEND;
		p_MIME_TYPES(p_MIME_TYPES.LAST) := v_REC.FILE_MIME_TYPE;

	END LOOP;

END GET_INVOICE_FILES;
---------------------------------------------------------------------------------------------------
-- Bulk exports invoices. The cursor will have two columns: FILE_NAME (a VARCHAR2) and
-- FILE_CONTENTS (a BLOB). The file names are generated based on the invoice details
-- using the patterns defined in the System Dictionary:
--   Global -> Billing -> Invoice -> Batch Export Invoice Name
--	Default: ${entity_name}/${statement_type}-${begin_date}-Invoice.${ext}
--   Global -> Billing -> Invoice -> Batch Export Attachment Name
-- 	Default: ${entity_name}/${statement_type}-${begin_date}-Attachment${num}.${ext}
-- In addition to being called from the UI, this procedure can be used from scheduled
-- tasks to perform batch exports.
-- %param p_INVOICE_IDs	The list of invoices to export.
-- %param p_EXPORT_FMT	The report format in which to generate the main invoice
--				file. This should be one of the constants defined in the
--				header of the CRYSTAL_REPORTS package.
-- %param p_CURSOR		The set of results. The cursor will have one or more row
--				for each invoice ID specified, and the cursor will return
--				results in the same order as IDs are found in
--				p_INVOICE_IDs.
PROCEDURE EXPORT_INVOICES
	(
	p_INVOICE_IDs	IN NUMBER_COLLECTION,
	p_EXPORT_FMT	IN NUMBER,
	p_CURSOR		IN OUT GA.REFCURSOR
	) AS

v_FILE_NAMES STRING_COLLECTION := STRING_COLLECTION();
v_MIME_TYPES STRING_COLLECTION := STRING_COLLECTION();
v_FILE_CONTENTS BLOB_COLLECTION := BLOB_COLLECTION();

v_ALL_FILE_NAMES STRING_COLLECTION := STRING_COLLECTION();
v_ALL_MIME_TYPES STRING_COLLECTION := STRING_COLLECTION();
v_ALL_FILE_CONTENTS BLOB_COLLECTION := BLOB_COLLECTION();

v_COUNT NUMBER(9);
BEGIN
	FOR	v_INDEX IN p_INVOICE_IDs.FIRST..p_INVOICE_IDs.LAST LOOP
		GET_INVOICE_FILES(p_INVOICE_IDs(v_INDEX), p_EXPORT_FMT, FALSE, v_FILE_NAMES, v_MIME_TYPES, v_FILE_CONTENTS);
		v_COUNT := v_ALL_FILE_NAMES.COUNT;
		v_ALL_FILE_NAMES.EXTEND(v_FILE_NAMES.COUNT);
		v_ALL_MIME_TYPES.EXTEND(v_MIME_TYPES.COUNT);
		v_ALL_FILE_CONTENTS.EXTEND(v_FILE_CONTENTS.COUNT);
		FOR v_IDX IN v_FILE_NAMES.FIRST..v_FILE_NAMES.LAST LOOP
			v_ALL_FILE_NAMES(v_COUNT + v_IDX) := v_FILE_NAMES(v_IDX);
			v_ALL_MIME_TYPES(v_COUNT + v_IDX) := v_MIME_TYPES(v_IDX);
			v_ALL_FILE_CONTENTS(v_COUNT + v_IDX) := v_FILE_CONTENTS(v_IDX);
		END LOOP;
	END LOOP;

	OPEN p_CURSOR FOR
		SELECT FILE_NAMES.COLUMN_VALUE FILE_NAME, FILE_CONTENTS.COLUMN_VALUE CONTENTS
		FROM (SELECT ROWNUM AS IDX, COLUMN_VALUE FROM TABLE(CAST(v_ALL_FILE_NAMES AS STRING_COLLECTION))) FILE_NAMES,
			(SELECT ROWNUM AS IDX, COLUMN_VALUE FROM TABLE(CAST(v_ALL_FILE_CONTENTS AS BLOB_COLLECTION))) FILE_CONTENTS
		WHERE FILE_NAMES.IDX = FILE_CONTENTS.IDX;

END EXPORT_INVOICES;
---------------------------------------------------------------------------------------------------
-- Sends an invoice via e-mail. This will generate a recipient list, subject, and
-- message body, then produce invoice files, then put everything together in a single
-- e-mail message and send it, and finally set the invoice's status to 'Invoiced'.
-- %param p_INVOICE_ID	The invoice to e-mail.
-- %param p_EXPORT_FMT	The report format in which to generate the main invoice
--				file. This should be one of the constants defined in the
--				header of the CRYSTAL_REPORTS package.
-- %raise 	An exception is raised if the specified invoice is not approved or if the
-- 		current user does not have permission to send the invoice.
PROCEDURE EMAIL_INVOICE
	(
	p_INVOICE_ID	IN NUMBER,
	p_EXPORT_FMT	IN NUMBER,
	p_EMAIL_SENDER  IN VARCHAR2
	) AS

v_FILE_NAMES STRING_COLLECTION;
v_MIME_TYPES STRING_COLLECTION;
v_FILE_CONTENTS BLOB_COLLECTION;

v_EMAIL_SUBJECT VARCHAR2(512);
v_EMAIL_PRIORITY NUMBER(1);
v_EMAIL_BODY VARCHAR2(4000);
v_EMAIL_BODY_MIME_TYPE VARCHAR2(64);
v_PSE_ID NUMBER;
v_APPROVED_BY_ID NUMBER;
v_RECIPIENTS NUMBER_COLLECTION;

v_TO_LIST   STRING_COLLECTION := STRING_COLLECTION();
v_CC_LIST   STRING_COLLECTION := STRING_COLLECTION();
v_BCC_LIST  STRING_COLLECTION := STRING_COLLECTION();

EMAIL ML.EMAIL_REC;

BEGIN
	-- Check Permission for INvoice
	SELECT I.ENTITY_ID, I.APPROVED_BY_ID
	INTO v_PSE_ID, v_APPROVED_BY_ID
	FROM INVOICE I
	WHERE I.INVOICE_ID = p_INVOICE_ID;

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_PSE_INVOICE_SEND, v_PSE_ID, EC.ED_PSE);
	ASSERT(v_APPROVED_BY_ID IS NOT NULL, 'Invoice is not approved' );

	-- Get the invoice files
	GET_INVOICE_FILES(p_INVOICE_ID, p_EXPORT_FMT, TRUE, v_FILE_NAMES, v_MIME_TYPES, v_FILE_CONTENTS);

	-- Get the email recipient list, subject, and message body using PSE_ID
	SELECT PSE.INVOICE_EMAIL_SUBJECT, PSE.INVOICE_EMAIL_PRIORITY, PSE.INVOICE_EMAIL_BODY, PSE.INVOICE_EMAIL_BODY_MIME_TYPE
	INTO v_EMAIL_SUBJECT, v_EMAIL_PRIORITY, v_EMAIL_BODY, v_EMAIL_BODY_MIME_TYPE
	FROM PURCHASING_SELLING_ENTITY PSE,
		INVOICE I
	WHERE I.INVOICE_ID = p_INVOICE_ID
		AND PSE.PSE_ID = I.ENTITY_ID;

	-- If special billing tags are used in the subject or body, convert them to the appropriate value
	v_EMAIL_SUBJECT := FORMAT_DYNAMIC_INVOICE_TEXT(p_INVOICE_ID, v_EMAIL_SUBJECT, '', 0);
	v_EMAIL_BODY := FORMAT_DYNAMIC_INVOICE_TEXT(p_INVOICE_ID, v_EMAIL_BODY, '', 0);

	-- Get recipients
	v_TO_LIST := RECIPIENT_LIST(p_INVOICE_ID, 'TO');
	v_CC_LIST := RECIPIENT_LIST(p_INVOICE_ID, 'CC');
	v_BCC_LIST := RECIPIENT_LIST(p_INVOICE_ID, 'BCC');

	-- Assert that recipients are set
	ASSERT((v_TO_LIST.COUNT + v_CC_LIST.COUNT + v_BCC_LIST.COUNT) != 0,
				'PSE ' || ENTITY_NAME_FROM_IDS(EC.ED_PSE, v_PSE_ID) || ' has no invoice email addresses defined',
				MSGCODES.c_ERR_NO_RECIPIENTS);

	-- Send Email
	EMAIL := ML.BEGIN_MAIL('Billing Invoice', p_EMAIL_SENDER, v_EMAIL_SUBJECT, v_EMAIL_PRIORITY);

	FOR v_IDX IN 1..v_TO_LIST.COUNT LOOP
		ML.ADD_RECIPIENT(EMAIL, v_TO_LIST(v_IDX));
	END LOOP;

	FOR v_IDX IN 1..v_CC_LIST.COUNT LOOP
		ML.ADD_CC_RECIPIENT(EMAIL, v_CC_LIST(v_IDX));
	END LOOP;

	FOR v_IDX IN 1..v_BCC_LIST.COUNT LOOP
		ML.ADD_BCC_RECIPIENT(EMAIL, v_BCC_LIST(v_IDX));
	END LOOP;

	ML.ATTACH_TEXT(EMAIL, v_EMAIL_BODY);

	FOR v_IDX IN 1..v_FILE_NAMES.COUNT LOOP
		ML.ATTACH_BLOB(EMAIL, v_FILE_CONTENTS(v_IDX), v_MIME_TYPES(v_IDX), FALSE, v_FILE_NAMES(v_IDX));
	END LOOP;

	ML.END_MAIL(EMAIL, SYSDATE);

	-- Set Invoice States to 'Sent'
	UPDATE_INVOICE_STATUS_SENT(p_INVOICE_ID);
	-- Update Last Sent BY
	UPDATE INVOICE
	SET	LAST_SENT_BY_ID = SECURITY_CONTROLS.CURRENT_USER_ID,
		LAST_SENT_WHEN = SYSDATE
	WHERE INVOICE_ID = p_INVOICE_ID;

END EMAIL_INVOICE;
---------------------------------------------------------------------------------------------------
-- Sends invoices via e-mail. This sends all specified invoice IDs via e-mail. This
-- procedure starts a process and commits the current transaction.
-- %param p_INVOICE_IDs	The list of invoices to send
-- %param p_EXPORT_FMT	The report format in which to generate the main invoice
--				file. This should be one of the constants defined in the
--				header of the CRYSTAL_REPORTS package.
-- %param p_PROCESS_STATUS	The status of the process. This will be one of the
--				constants defined in the LOGS package.
-- %param p_MESSAGE		The finish message of the process.
PROCEDURE EMAIL_INVOICES
	(
	p_INVOICE_IDs		IN NUMBER_COLLECTION,
	p_EXPORT_FMT		IN NUMBER,
	p_PROCESS_STATUS	OUT NUMBER,
	p_MESSAGE			OUT VARCHAR2
	) AS

v_EMAIL_SENDER VARCHAR2(512);

BEGIN
	ASSERT(p_INVOICE_IDs IS NOT NULL OR p_INVOICE_IDs.COUNT != 0, 'No Invoices selected.', MSGCODES.c_ERR_ARGUMENT);

	v_EMAIL_SENDER := GET_DICTIONARY_VALUE('%',0,'Billing','Invoice','E-mail Sender','?',0);
	-- Assert that Global > Billing > Invoice > E-mail Sender is set
	ASSERT(v_EMAIL_SENDER IS NOT NULL, 'E-mail Sender in System Settings cannot be null.', MSGCODES.c_ERR_NO_SENDER);

	BEGIN
		LOGS.START_PROCESS('Email Invoice');

		FOR v_IDX IN 1..p_INVOICE_IDs.COUNT LOOP
			BEGIN
				EMAIL_INVOICE(p_INVOICE_IDs(v_IDX), p_EXPORT_FMT, v_EMAIL_SENDER);
			EXCEPTION
				WHEN MSGCODES.e_ERR_ASSERT THEN
					ERRS.LOG_AND_CONTINUE();
				WHEN MSGCODES.e_ERR_PRIVILEGES THEN
					ERRS.LOG_AND_CONTINUE();
				WHEN MSGCODES.e_ERR_NO_RECIPIENTS THEN
					ERRS.LOG_AND_CONTINUE();
			END;
		END LOOP;

		LOGS.STOP_PROCESS(p_MESSAGE, p_PROCESS_STATUS);

		COMMIT;
	EXCEPTION
		WHEN OTHERS THEN
			ERRS.ABORT_PROCESS;
	END;

END EMAIL_INVOICES;
---------------------------------------------------------------------------------------------------

-- Sends all approved invoices via e-mail. This procedure invokes EMAIL_INVOICES which
-- means that it starts a process and commits the current transaction. This will
-- exclude approved invoices that have already been sent (i.e. INVOICE_STATUS like
-- `%SENT%').
-- %param p_EXPORT_FMT	The report format in which to generate the main invoice
--				file. This should be one of the constants defined in the
--				header of the CRYSTAL_REPORTS package.
-- %param p_PROCESS_STATUS	The status of the process. This will be one of the
--				constants defined in the LOGS package.
-- %param p_MESSAGE		The finish message of the process.
PROCEDURE EMAIL_ALL_APPROVED_INVOICES
	(
	p_EXPORT_FMT		IN PLS_INTEGER,
	p_PROCESS_STATUS	OUT NUMBER,
	p_MESSAGE		OUT VARCHAR2
	) AS
v_INVOICE_IDS NUMBER_COLLECTION := NUMBER_COLLECTION();
BEGIN

	SELECT I.INVOICE_ID
	BULK COLLECT INTO v_INVOICE_IDS
	FROM INVOICE I
	WHERE UPPER(I.INVOICE_STATUS) != '%SENT%' AND I.APPROVED_BY_ID IS NOT NULL;

	EMAIL_INVOICES(v_INVOICE_IDS, p_EXPORT_FMT, p_PROCESS_STATUS, p_MESSAGE);

END EMAIL_ALL_APPROVED_INVOICES;
---------------------------------------------------------------------------------------------------
-- Retrieves a list of invoices that can be exported or e-mailed. This finds all
-- invoices that match specified criteria and for PSEs to which the current user has
-- Select PSE Billing privilege.
-- %param p_STATEMENT_TYPE		The statement type of invoices to return.
-- %param p_STATEMENT_STATE	The statement state of invoices to return.
-- %param p_BEGIN_DATE		Begin date of the date range. Invoices returned will
--					overlap the specified date range.
-- %param p_END_DATE		End date of the date range. Invoices returned will
--					overlap the specified date range.
-- %param p_CURSOR			The results, which will include the following
-- 					columns: INVOICE_ID, PSE_NAME (based on ENTITY_ID),
--					INVOICE_PERIOD (based on BEGIN_DATE and END_DATE),
--					APPROVAL_TEXT (based on APPROVED_BY and
--					APPROVED_WHEN), ATTACHMENT_COUNT (count of associated
--					records in INVOICE_ATTACHMENT table).
PROCEDURE GET_INVOICES_TO_SEND
	(
	p_STATEMENT_TYPE	IN NUMBER,
	p_STATEMENT_STATE	IN NUMBER,
	p_BEGIN_DATE		IN DATE,
	p_END_DATE		IN DATE,
	p_CURSOR		OUT GA.REFCURSOR
	) AS

v_AVAILABLE_IDS ID_TABLE := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_PSE_BILL_SELECT);
BEGIN

	OPEN p_CURSOR FOR
		SELECT I.INVOICE_ID,
			P.PSE_ID as entity_id,
			P.PSE_NAME,
			I.INVOICE_NUMBER,
			TO_CHAR(I.BEGIN_DATE,g_SHORT_DATE_FORMAT)||' -> '||TO_CHAR(I.END_DATE,g_SHORT_DATE_FORMAT) as invoice_date,
			I.INVOICE_STATUS,
			NVL((SELECT sum(CASE WHEN ILI.DEFAULT_DISPLAY = 'BILL' THEN ILI.LINE_ITEM_BILL_AMOUNT ELSE ILI.LINE_ITEM_AMOUNT END) LINE_AMT
				FROM INVOICE_LINE_ITEM ILI
				WHERE ILI.INVOICE_ID  = I.INVOICE_ID),0) +
			NVL((SELECT sum(CASE WHEN IULI.DEFAULT_DISPLAY = 'BILL' THEN IULI.LINE_ITEM_BILL_AMOUNT ELSE IULI.LINE_ITEM_AMOUNT END) USER_AMT
				FROM INVOICE_USER_LINE_ITEM IULI
				WHERE IULI.ENTITY_ID = I.ENTITY_ID
					AND IULI.STATEMENT_TYPE  = I.STATEMENT_TYPE
					AND IULI.STATEMENT_STATE = I.STATEMENT_STATE
					AND IULI.BEGIN_DATE = I.BEGIN_DATE),0) as invoice_amount,
			CASE WHEN I.APPROVED_WHEN IS NOT NULL
						THEN (APPROVED_BY.USER_NAME || ' @ ' || TO_CHAR(I.APPROVED_WHEN, 'YYYY/MM/DD hh24:mi'))
					ELSE NULL
					END as approval_text,
			CASE WHEN I.LAST_SENT_WHEN IS NOT NULL
						THEN (LAST_SENT_BY.USER_NAME || ' @ ' || TO_CHAR(I.LAST_SENT_WHEN, 'YYYY/MM/DD hh24:mi'))
					ELSE NULL
					END as last_sent_by_text,
			(SELECT COUNT(IA.FILE_NAME) FROM  INVOICE_ATTACHMENT IA WHERE IA.INVOICE_ID (+) = I.INVOICE_ID) as attachment_count,
			(SELECT COUNT(PIR.PSE_ID) FROM PSE_INVOICE_RECIPIENT PIR WHERE PIR.PSE_ID (+) = I.ENTITY_ID) as recipient_count
		FROM TABLE(CAST(v_AVAILABLE_IDS AS ID_TABLE)) X,
			INVOICE I,
			PURCHASING_SELLING_ENTITY P,
			APPLICATION_USER APPROVED_BY,
			APPLICATION_USER LAST_SENT_BY
		WHERE (X.ID = SD.g_ALL_DATA_ENTITY_ID OR I.ENTITY_ID = X.ID)
				AND I.STATEMENT_TYPE = p_STATEMENT_TYPE
				AND I.STATEMENT_STATE = p_STATEMENT_STATE
				AND I.BEGIN_DATE <= p_END_DATE
				AND NVL(I.END_DATE,CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
				AND P.PSE_ID = I.ENTITY_ID
				AND APPROVED_BY.USER_ID (+) = I.APPROVED_BY_ID
				AND LAST_SENT_BY.USER_ID (+) = I.LAST_SENT_BY_ID
		ORDER BY I.INVOICE_ID;

END GET_INVOICES_TO_SEND;
---------------------------------------------------------------------------------------------------
-- Retrieves records for invoice Crystal Report template. The logic in
-- GET_INVOICE_REPORT_RECORDS will be moved into here. That method will simply look-up - an INVOICE_ID and then call this new method.
-- %param p_INVOICE_ID	The ID of the invoice to retrieve
-- %param p_CURSOR		The invoice data
-- %raise	An exception will be raised if the current user does not have 'Select PSE
-- 		Billing privileges for the invoice's entity.
PROCEDURE GET_INVOICE_RPT_RECS_BY_ID
	(
    p_INVOICE_CATEGORY IN VARCHAR,
    p_INVOICE_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
v_INVOICE_DATE DATE;
v_SOMETHING_DONE BOOLEAN := FALSE;
v_DATE_FMT VARCHAR2(32) := NVL(GET_DICTIONARY_VALUE('DATE FORMAT', 0, 'BILLING', 'INVOICE'), g_SHORT_DATE_FORMAT);
v_INVOICE_CATEGORY VARCHAR2(32);
v_INVOICE_BEGIN_DATE DATE;
BEGIN

    IF p_INVOICE_CATEGORY = '<ALL>' THEN
    	v_INVOICE_CATEGORY := '%';
	ELSE
    	v_INVOICE_CATEGORY := p_INVOICE_CATEGORY;
	END IF;

	XS.GET_INVOICE_REPORT_RECORDS (v_INVOICE_CATEGORY, p_INVOICE_ID, p_STATUS, v_SOMETHING_DONE, p_CURSOR);

	IF NOT v_SOMETHING_DONE THEN
    	-- default data set
		OPEN p_CURSOR FOR
			SELECT TO_CHAR(A.BEGIN_DATE, v_DATE_FMT)||' - '||TO_CHAR(A.END_DATE, v_DATE_FMT) AS INVOICE_MONTH,
				TO_CHAR(TRUNC(A.INVOICE_DATE), v_DATE_FMT) AS INVOICE_DATE,
	    		A.INVOICE_NUMBER, A.INVOICE_SUB_LEDGER_NUMBER,
	    		A.BILLING_CONTACT, A.BILLING_PHONE, A.BILLING_FAX, A.BILLING_STREET, A.BILLING_CITY, A.BILLING_STATE_CODE, A.BILLING_POSTAL_CODE, A.BILLING_COUNTRY_CODE,
	    		A.INVOICE_TERMS, A.INVOICE_PRIMARY_CONTACT, A.INVOICE_PRIMARY_PHONE, A.INVOICE_SECONDARY_CONTACT, A.INVOICE_SECONDARY_PHONE,
	    		A.PAY_CHECK_CONTACT, A.PAY_CHECK_STREET, A.PAY_CHECK_CITY, A.PAY_CHECK_STATE_CODE, A.PAY_CHECK_POSTAL_CODE, A.PAY_CHECK_COUNTRY_CODE,
	    		A.PAY_ELECTRONIC_DEBIT_NAME, A.PAY_ELECTRONIC_DEBIT_NBR, A.PAY_ELECTRONIC_CREDIT_NAME, A.PAY_ELECTRONIC_CREDIT_NBR,
	    		A.INVOICE_STATUS,
	    		TO_CHAR(TRUNC(A.PAYMENT_DUE_DATE), v_DATE_FMT) AS PAYMENT_DUE_DATE,
				A.PAYMENT_DUE_DATE AS PAYMENT_DUE_DATE_DT,
	    		B.LINE_ITEM_NAME,
	    		DECODE(UPPER(C.CHARGE_TYPE), 'TAX', 'T', 'C') AS LINE_ITEM_TYPE,
	    		DECODE(UPPER(C.CHARGE_TYPE), 'TAX', 6, 5) AS LINE_ITEM_GROUP_ORDER, D.INVOICE_GROUP_NAME,
                NVL(C.INVOICE_GROUP_ORDER,0) AS INVOICE_GROUP_ORDER,
	    		TO_CHAR(B.LINE_ITEM_QUANTITY) AS LINE_ITEM_QUANTITY, TO_CHAR(B.LINE_ITEM_RATE) AS LINE_ITEM_RATE,
                TO_CHAR(DECODE(UPPER(NVL(B.DEFAULT_DISPLAY,'CHARGE')),'BILL',B.LINE_ITEM_BILL_AMOUNT,B.LINE_ITEM_AMOUNT)) AS LINE_ITEM_AMOUNT,
	    		TO_CHAR(NVL(C.EXCLUDE_FROM_INVOICE_TOTAL,0)) AS EXCLUDE_FROM_INVOICE_TOTAL,
	    		TO_CHAR(NVL(D.SHOW_TITLE_ON_INVOICE,0)) AS SHOW_TITLE_ON_INVOICE,
	    		TO_CHAR(NVL(D.SHOW_SUBTOTAL_ON_INVOICE,0)) AS SHOW_SUBTOTAL_ON_INVOICE,
                NVL(D.DISPLAY_ORDER,0) AS INVOICE_GROUP_DISPLAY_ORDER,
				NVL(U.USER_DISPLAY_NAME, U.USER_NAME) AS APPROVED_BY,
	    		TO_CHAR(TRUNC(A.APPROVED_WHEN), v_DATE_FMT) AS APPROVED_WHEN,
				A.APPROVED_WHEN AS APPROVED_WHEN_DT
			FROM INVOICE A,
				INVOICE_LINE_ITEM B,
	    		COMPONENT C,
	    		INVOICE_GROUP D,
				APPLICATION_USER U
			WHERE A.INVOICE_ID = p_INVOICE_ID
				AND B.INVOICE_ID = A.INVOICE_ID
                AND NVL(B.LINE_ITEM_CATEGORY,' ') LIKE v_INVOICE_CATEGORY
				AND C.COMPONENT_ID(+) = B.COMPONENT_ID
				AND D.INVOICE_GROUP_ID(+) = C.INVOICE_GROUP_ID
				AND U.USER_ID (+) = A.APPROVED_BY_ID
			UNION ALL
			SELECT TO_CHAR(A.BEGIN_DATE, v_DATE_FMT)||' - '||TO_CHAR(A.END_DATE, v_DATE_FMT) AS INVOICE_MONTH,
				TO_CHAR(TRUNC(A.INVOICE_DATE), v_DATE_FMT) AS INVOICE_DATE,
	    		A.INVOICE_NUMBER, A.INVOICE_SUB_LEDGER_NUMBER,
				A.BILLING_CONTACT, A.BILLING_PHONE, A.BILLING_FAX, A.BILLING_STREET, A.BILLING_CITY, A.BILLING_STATE_CODE, A.BILLING_POSTAL_CODE, A.BILLING_COUNTRY_CODE,
				A.INVOICE_TERMS, A.INVOICE_PRIMARY_CONTACT, A.INVOICE_PRIMARY_PHONE, A.INVOICE_SECONDARY_CONTACT, A.INVOICE_SECONDARY_PHONE,
				A.PAY_CHECK_CONTACT, A.PAY_CHECK_STREET, A.PAY_CHECK_CITY, A.PAY_CHECK_STATE_CODE, A.PAY_CHECK_POSTAL_CODE, A.PAY_CHECK_COUNTRY_CODE,
				A.PAY_ELECTRONIC_DEBIT_NAME, A.PAY_ELECTRONIC_DEBIT_NBR, A.PAY_ELECTRONIC_CREDIT_NAME, A.PAY_ELECTRONIC_CREDIT_NBR,
				A.INVOICE_STATUS,
				TO_CHAR(TRUNC(A.PAYMENT_DUE_DATE), v_DATE_FMT) AS PAYMENT_DUE_DATE,
				A.PAYMENT_DUE_DATE AS PAYMENT_DUE_DATE_DT,
				B.LINE_ITEM_NAME,
				B.LINE_ITEM_TYPE,
				DECODE(B.LINE_ITEM_TYPE, 'B', 1, 'P', 2, 'A', 3, 'F', 4, 'M', 7, 'X', 8, 99)  AS LINE_ITEM_GROUP_ORDER, C.INVOICE_GROUP_NAME,
                NVL(B.INVOICE_GROUP_ORDER,0) AS INVOICE_GROUP_ORDER,
				TO_CHAR(B.LINE_ITEM_QUANTITY) AS LINE_ITEM_QUANTITY, TO_CHAR(B.LINE_ITEM_RATE) AS LINE_ITEM_RATE,
                TO_CHAR(DECODE(UPPER(NVL(B.DEFAULT_DISPLAY,'CHARGE')),'BILL',B.LINE_ITEM_BILL_AMOUNT,B.LINE_ITEM_AMOUNT)) AS LINE_ITEM_AMOUNT,
				TO_CHAR(NVL(B.EXCLUDE_FROM_INVOICE_TOTAL,0)) AS EXCLUDE_FROM_INVOICE_TOTAL,
	    		TO_CHAR(NVL(C.SHOW_TITLE_ON_INVOICE,0)) AS SHOW_TITLE_ON_INVOICE,
	    		TO_CHAR(NVL(C.SHOW_SUBTOTAL_ON_INVOICE,0)) AS SHOW_SUBTOTAL_ON_INVOICE,
                NVL(C.DISPLAY_ORDER,0) AS INVOICE_GROUP_DISPLAY_ORDER,
				NVL(U.USER_DISPLAY_NAME, U.USER_NAME) AS APPROVED_BY,
	    		TO_CHAR(TRUNC(A.APPROVED_WHEN), v_DATE_FMT) AS APPROVED_WHEN,
				A.APPROVED_WHEN AS APPROVED_WHEN_DT
			FROM INVOICE A,
				INVOICE_USER_LINE_ITEM B,
                INVOICE_GROUP C,
				APPLICATION_USER U
			WHERE A.INVOICE_ID = p_INVOICE_ID
				AND B.ENTITY_ID = A.ENTITY_ID
				AND B.STATEMENT_TYPE = A.STATEMENT_TYPE
	    		AND B.STATEMENT_STATE = A.STATEMENT_STATE
	    		AND B.BEGIN_DATE = A.BEGIN_DATE
                AND NVL(B.LINE_ITEM_CATEGORY,' ') LIKE v_INVOICE_CATEGORY
				AND C.INVOICE_GROUP_ID(+) = B.INVOICE_GROUP_ID
				AND A.APPROVED_BY_ID = U.USER_ID (+)
			ORDER BY INVOICE_GROUP_DISPLAY_ORDER ASC,
	    		INVOICE_GROUP_NAME ASC,
	    		INVOICE_GROUP_ORDER ASC,
            	LINE_ITEM_GROUP_ORDER ASC,
	    		LINE_ITEM_NAME ASC;
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END GET_INVOICE_RPT_RECS_BY_ID;
---------------------------------------------------------------------------------------------------
-- Approves multiple invoices.
-- %param p_INVOICE_IDs	The list of invoice IDs to approve
-- %param p_MESSAGE		A message that will indicate which invoices could not be
--				approved due to insufficient privileges.
PROCEDURE APPROVE_INVOICES
	(
	p_INVOICE_ID	IN NUMBER_COLLECTION,
	p_MESSAGE		OUT VARCHAR2
	) AS

v_AVAILABLE_PSE_IDS ID_TABLE := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_PSE_BILL_SELECT);
v_AVAIL_INVOICE_IDS NUMBER_COLLECTION := NUMBER_COLLECTION();
v_UNAVAIL_INVOICE_IDS NUMBER_COLLECTION := NUMBER_COLLECTION();

BEGIN

	SELECT I.INVOICE_ID
	BULK COLLECT INTO v_AVAIL_INVOICE_IDS
	FROM INVOICE I,
		TABLE(CAST(v_AVAILABLE_PSE_IDS AS ID_TABLE)) PSE,
		TABLE(CAST(p_INVOICE_ID AS NUMBER_COLLECTION)) ALL_INV
	WHERE (PSE.ID = SD.g_ALL_DATA_ENTITY_ID OR I.ENTITY_ID = PSE.ID)
		AND (I.INVOICE_ID = ALL_INV.COLUMN_VALUE);

	UPDATE INVOICE I
	SET I.APPROVED_BY_ID = SECURITY_CONTROLS.CURRENT_USER_ID,
		I.APPROVED_WHEN = SYSDATE
	WHERE I.INVOICE_ID IN (SELECT X.COLUMN_VALUE FROM TABLE(CAST(v_AVAIL_INVOICE_IDS AS NUMBER_COLLECTION)) X)
		AND NVL(I.APPROVED_BY_ID, -1) <> SECURITY_CONTROLS.CURRENT_USER_ID;

	SELECT ALL_INV.COLUMN_VALUE
	BULK COLLECT INTO v_UNAVAIL_INVOICE_IDS
	FROM TABLE(CAST(p_INVOICE_ID AS NUMBER_COLLECTION)) ALL_INV
	MINUS
	SELECT AVAIL_INV.COLUMN_VALUE
	FROM TABLE(CAST(v_AVAIL_INVOICE_IDS AS NUMBER_COLLECTION)) AVAIL_INV;

	IF v_UNAVAIL_INVOICE_IDS.COUNT > 0 THEN
		p_MESSAGE := 'Invoices: ' || TEXT_UTIL.TO_CHAR_NUMBER_LIST(v_UNAVAIL_INVOICE_IDS, FALSE) || 'could not be approved due to insufficient privileges';
	END IF;

END APPROVE_INVOICES;
---------------------------------------------------------------------------------------------------

-- Retrieve attachment details for an invoice.
-- %param p_INVOICE_ID	The ID of the invoice whose attachments will be viewed.
-- %param p_CURSOR		The list of attachments, which will include the following
--	columns: FILE_NAME, FILE_MIME_TYPE, USER_NAME (based on
--	USER_ID), FILE_SIZE (based on FILE_CONTENTS), and
--	ENTRY_DATE
-- %raise	An exception will be raised if the current user does not have `Select PSE
-- 		Billing privileges for the invoice's entity.
PROCEDURE GET_INVOICE_ATTACHMENTS
	(
	p_INVOICE_ID	IN NUMBER,
	p_CURSOR	OUT GA.REFCURSOR
	) AS

v_ENTITY_ID NUMBER;

BEGIN

	SELECT I.ENTITY_ID
	INTO v_ENTITY_ID
	FROM INVOICE I
	WHERE I.INVOICE_ID = p_INVOICE_ID;

	IF NOT SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_PSE_BILL_SELECT, v_ENTITY_ID, EC.ED_PSE) THEN
		ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_PSE_BILL_SELECT, v_ENTITY_ID, EC.ED_PSE);
	END IF;

	OPEN p_CURSOR FOR
		SELECT IA.INVOICE_ID,
			IA.FILE_NAME,
			IA.FILE_MIME_TYPE,
			U.USER_ID,
			U.USER_NAME,
			DBMS_LOB.GETLENGTH(IA.FILE_CONTENTS) FILE_SIZE,
			IA.ENTRY_DATE
		FROM INVOICE_ATTACHMENT IA,
			APPLICATION_USER U
		WHERE IA.INVOICE_ID = p_INVOICE_ID
			AND U.USER_ID = IA.USER_ID;

END GET_INVOICE_ATTACHMENTS;
---------------------------------------------------------------------------------------------------

-- Upload an attachment for an invoice. The mime type of the attachment will be
-- determined based on the extension in the file name.
-- %param p_INVOICE_ID	The ID of the invoice for which to upload an attachment.
-- %param p_FILE_NAME	The name of the file being attached.
-- %param p_FILE_CONTENTS	The contents of the file being attached.
-- %raise	An exception will be raised if the current user does not have both
--		`Select PSE Billing and `Update Invoice Attachments privileges for the
--		invoice's entity.
PROCEDURE ADD_INVOICE_ATTACHMENT
	(
	p_INVOICE_ID		IN NUMBER,
	p_FILE_NAME			IN VARCHAR2,
	p_FILE_CONTENTS		IN BLOB,
	p_MIME_TYPE			IN VARCHAR2 := NULL
	) AS

v_FILE_EXT VARCHAR2(5);
v_MIME_TYPE VARCHAR2(64);
v_ENTITY_ID NUMBER;
v_FILE_NAME VARCHAR2(256);
BEGIN

	SELECT I.ENTITY_ID
	INTO v_ENTITY_ID
	FROM INVOICE I
	WHERE I.INVOICE_ID = p_INVOICE_ID;

	-- Check privilege for the pse
	IF NOT SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_PSE_INVOICE_ATTCH, v_ENTITY_ID, EC.ED_PSE) THEN
		ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_PSE_INVOICE_ATTCH, v_ENTITY_ID, EC.ED_PSE);
	END IF;

	-- Determine attachment namee
	v_FILE_NAME := PARSE_FILE_NAME_FROM_PATH(p_FILE_NAME);
	-- Get file extension
	v_FILE_EXT := SUBSTR(v_FILE_NAME, INSTR(v_FILE_NAME, '.') + 1);

	IF p_MIME_TYPE IS NULL THEN
		-- Get the mime type from the system dictionary
		v_MIME_TYPE := 	NVL(GET_DICTIONARY_VALUE(v_FILE_EXT, CONSTANTS.GLOBAL_MODEL, 'System', 'MIME Types'), CONSTANTS.MIME_TYPE_UNKNOWN);
	ELSE
		v_MIME_TYPE := p_MIME_TYPE;
	END IF;

	-- First try and update the invoice_attachment table
	UPDATE INVOICE_ATTACHMENT I
	SET I.FILE_CONTENTS = p_FILE_CONTENTS
	WHERE I.INVOICE_ID = p_INVOICE_ID
		AND I.FILE_NAME = v_FILE_NAME;

	-- If not, insert new values
	IF SQL%NOTFOUND THEN
		INSERT INTO INVOICE_ATTACHMENT
			(
			INVOICE_ID,
			FILE_NAME,
			FILE_MIME_TYPE,
			FILE_CONTENTS,
			USER_ID,
			ENTRY_DATE
			)
		VALUES
			(
			p_INVOICE_ID,
			v_FILE_NAME,
			v_MIME_TYPE,
			p_FILE_CONTENTS,
			SECURITY_CONTROLS.CURRENT_USER_ID,
			SYSDATE
			);
	END IF;

END ADD_INVOICE_ATTACHMENT;
---------------------------------------------------------------------------------------------------
-- Retrieve an attachment for an invoice.
-- %param p_INVOICE_ID	The ID of the invoice containing the attachment.
-- %param p_FILE_NAME	The name of the attached file.
-- %param p_FILE_CONTENTS	The contents of the attached file.
PROCEDURE DOWNLOAD_INVOICE_ATTACHMENT
	(
	p_INVOICE_ID		IN NUMBER,
	p_FILE_NAME			IN VARCHAR2,
	p_FILE				OUT BLOB
	) AS
v_ENTITY_ID NUMBER;
BEGIN

	SELECT I.ENTITY_ID
	INTO v_ENTITY_ID
	FROM INVOICE I
	WHERE I.INVOICE_ID = p_INVOICE_ID;
	-- Check privilege
	IF NOT SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_PSE_BILL_SELECT, v_ENTITY_ID, EC.ED_PSE) THEN
		ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_PSE_BILL_SELECT, v_ENTITY_ID, EC.ED_PSE);
	END IF;
	-- Get the file contents
	SELECT IA.FILE_CONTENTS
	INTO p_FILE
	FROM INVOICE_ATTACHMENT IA
	WHERE IA.INVOICE_ID = p_INVOICE_ID
		AND IA.FILE_NAME = p_FILE_NAME;

END DOWNLOAD_INVOICE_ATTACHMENT;
---------------------------------------------------------------------------------------------------
-- Removes an attachment from an invoice.
-- %param p_INVOICE_ID	The ID of the invoice containing the attachment.
-- %param p_FILE_NAME	The name of the attached file.
-- %raise	An exception will be raised if the current user does not have both
--		`Select PSE Billing and `Update Invoice Attachments privileges for the
--		invoices entity.
PROCEDURE REMOVE_INVOICE_ATTACHMENT
	(
	p_INVOICE_ID	IN NUMBER,
	p_FILE_NAME	IN VARCHAR2
	) AS

v_ENTITY_ID NUMBER;
BEGIN

	SELECT I.ENTITY_ID
	INTO v_ENTITY_ID
	FROM INVOICE I
	WHERE I.INVOICE_ID = p_INVOICE_ID;

	IF NOT SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_PSE_BILL_SELECT, v_ENTITY_ID, EC.ED_PSE) THEN
		ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_PSE_BILL_SELECT, v_ENTITY_ID, EC.ED_PSE);
	END IF;

	IF NOT SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_PSE_INVOICE_ATTCH, v_ENTITY_ID, EC.ED_PSE) THEN
		ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_PSE_INVOICE_ATTCH, v_ENTITY_ID, EC.ED_PSE);
	END IF;

	DELETE FROM INVOICE_ATTACHMENT IA
	WHERE IA.INVOICE_ID = p_INVOICE_ID
		AND IA.FILE_NAME = p_FILE_NAME;

END REMOVE_INVOICE_ATTACHMENT;
---------------------------------------------------------------------------------------------------
-- A warning procedure. It will return a message that details insufficient privilege too attach
-- the specified file to the specified invoices.
-- %param p_INVOICE_IDs		The list of invoice IDs to which the file will be
-- 					attached.
-- %param p_WARNING_MESSAGE	The message that will be shown to the user. This will
--					be NULL if there are no warnings to convey
PROCEDURE ADD_ATTACHMENT_PRIV_WARNING
	(
	p_INVOICE_ID		IN NUMBER_COLLECTION,
	p_WARNING_MESSAGE	OUT VARCHAR2
	) AS
v_AVAILABLE_IDS ID_TABLE := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_PSE_BILL_SELECT);
v_AVAILABLE_INV_IDS ID_TABLE := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_PSE_INVOICE_ATTCH);
v_ALLOWED_INV_IDS NUMBER_COLLECTION := NUMBER_COLLECTION();

v_WORK_ID NUMBER;
v_PSE_IDS NUMBER_COLLECTION := NUMBER_COLLECTION();

BEGIN
	UT.GET_RTO_WORK_ID(v_WORK_ID);
	-- Finds the invoice ids that are allowed
	SELECT INV.COLUMN_VALUE
	BULK COLLECT INTO v_ALLOWED_INV_IDS
	FROM TABLE(CAST(p_INVOICE_ID AS NUMBER_COLLECTION)) INV,
		TABLE(CAST(v_AVAILABLE_IDS AS ID_TABLE)) X,
		TABLE(CAST(v_AVAILABLE_INV_IDS AS ID_TABLE)) X2,
		INVOICE I
	WHERE I.INVOICE_ID = INV.COLUMN_VALUE
		AND (X.ID = SD.g_ALL_DATA_ENTITY_ID OR I.ENTITY_ID = X.ID)
		AND	(X2.ID = SD.g_ALL_DATA_ENTITY_ID OR I.ENTITY_ID = X2.ID);

	-- If there are ones that are not allowed, add them to a work table
	IF v_ALLOWED_INV_IDS.COUNT != p_INVOICE_ID.COUNT THEN
		INSERT INTO RTO_WORK(WORK_ID, WORK_XID)
		SELECT v_WORK_ID, X.COLUMN_VALUE
		FROM TABLE(CAST(p_INVOICE_ID AS NUMBER_COLLECTION)) X
		MINUS
		SELECT v_WORK_ID, X1.COLUMN_VALUE
		FROM TABLE(CAST(v_ALLOWED_INV_IDS AS NUMBER_COLLECTION)) X1;
	END IF;

	-- Now we have a list of invoices that have insufficient privilege
	SELECT DISTINCT I.ENTITY_ID
	BULK COLLECT INTO v_PSE_IDS
	FROM RTO_WORK WRK,
		INVOICE I
	WHERE WRK.WORK_ID = v_WORK_ID
		AND I.INVOICE_ID = WRK.WORK_XID;

	IF v_PSE_IDS.COUNT > 0 THEN
		p_WARNING_MESSAGE := 'You do not have sufficient privilege to update attachments for the following PSEs: ' || UTL_TCP.CRLF;
		-- Create a warning message with the information
		FOR v_IDX IN 1..v_PSE_IDS.COUNT LOOP
			p_WARNING_MESSAGE := p_WARNING_MESSAGE || 'PSE-' || ENTITY_NAME_FROM_IDS(EC.ED_PSE, v_PSE_IDS(v_IDX)) || ', '  ;
		END LOOP;

		p_WARNING_MESSAGE := SUBSTR(p_WARNING_MESSAGE, 1,  LENGTH(p_WARNING_MESSAGE) - 2);
	END IF;

	UT.PURGE_RTO_WORK(v_WORK_ID);

END ADD_ATTACHMENT_PRIV_WARNING;
---------------------------------------------------------------------------------------------------
-- A warning procedure. It will return a message that details possible overwriting of
-- existing attachments for attaching
-- the specified file to the specified invoices.
-- %param p_INVOICE_IDs		The list of invoice IDs to which the file will be
-- 					attached.
-- %param p_FILE_NAME		The name of the file to attach.
-- %param p_WARNING_MESSAGE	The message that will be shown to the user. This will
--					be NULL if there are no warnings to convey (i.e.
--					none of the specified invoices have
--					already have an attachment with the specified name)
PROCEDURE ADD_ATTACHMENT_OVR_WARNING
	(
	p_INVOICE_ID		IN NUMBER_COLLECTION,
	p_FILE_NAME			IN VARCHAR2,
	p_WARNING_MESSAGE	OUT VARCHAR2
	) AS

v_EXISTED_IDs NUMBER_COLLECTION := NUMBER_COLLECTION();
v_WORK_ID NUMBER;

v_FILE_NAME VARCHAR2(256);
v_INVOICE_IDS NUMBER_COLLECTION := NUMBER_COLLECTION();
v_WARNINGS STRING_COLLECTION := STRING_COLLECTION();
v_PSE_IDS NUMBER_COLLECTION := NUMBER_COLLECTION();
BEGIN

	UT.GET_RTO_WORK_ID(v_WORK_ID);

	v_FILE_NAME := PARSE_FILE_NAME_FROM_PATH(p_FILE_NAME);

	-- look to see if any of the invoices already have attachments
	SELECT IA.INVOICE_ID
	BULK COLLECT INTO v_EXISTED_IDs
	FROM INVOICE_ATTACHMENT IA,
		TABLE(CAST(p_INVOICE_ID AS NUMBER_COLLECTION)) INV
	WHERE IA.INVOICE_ID = INV.COLUMN_VALUE
		AND IA.FILE_NAME = v_FILE_NAME;

	-- If there are invoices with attachments, add them to a work table
	IF v_EXISTED_IDs.COUNT != 0 THEN
		INSERT INTO RTO_WORK(WORK_ID, WORK_XID)
		SELECT v_WORK_ID, X.COLUMN_VALUE
		FROM TABLE(CAST(v_EXISTED_IDs AS NUMBER_COLLECTION)) X;
	END IF;

	-- Now we have a list of invoices that will be overwritten
	SELECT WRK.WORK_XID, I.ENTITY_ID
	BULK COLLECT INTO v_INVOICE_IDS, v_PSE_IDS
	FROM RTO_WORK WRK,
		INVOICE I
	WHERE WRK.WORK_ID = v_WORK_ID
		AND I.INVOICE_ID = WRK.WORK_XID;

	IF v_INVOICE_IDS.COUNT > 0 THEN
		p_WARNING_MESSAGE := 'Some selected invoices already include an attachment named ' || v_FILE_NAME || UTL_TCP.CRLF;
		-- Create a warning message with the information
		FOR v_IDX IN 1..v_INVOICE_IDS.COUNT LOOP
			p_WARNING_MESSAGE := p_WARNING_MESSAGE  || 'PSE ' || ENTITY_NAME_FROM_IDS(EC.ED_PSE, v_PSE_IDS(v_IDX)) || ': Invoice ' || v_INVOICE_IDS(v_IDX) || ', ';
		END LOOP;
		p_WARNING_MESSAGE := SUBSTR(p_WARNING_MESSAGE, 1,  LENGTH(p_WARNING_MESSAGE) - 2);
	END IF;

	UT.PURGE_RTO_WORK(v_WORK_ID);

END ADD_ATTACHMENT_OVR_WARNING;
---------------------------------------------------------------------------------------------------
-- Attaches a file to multiple invoices. If any of the specified invoices already have
-- a file with the same name attached, the attachment will be overwritten. If the user
-- does not have sufficient privileges to attach a file to an invoice, that invoice
-- will be skipped.
-- %param p_INVOICE_ID	The list of invoice IDs to which to attach the file.
-- %param p_FILE_NAME	The name of the file being attached to the invoices.
-- %param p_IMPORT_FILE	The contents of the attached file.
-- %raise	An exception will be raised if an attachment with the specified name
--		already exists.
PROCEDURE ADD_ATTACHMENT_TO_INVOICES
	(
	p_FILE_NAME 	IN VARCHAR2,
	p_FILE_CONTENTS	IN BLOB,
	p_INVOICE_ID	IN NUMBER_COLLECTION
	) AS

v_AVAILABLE_IDS ID_TABLE := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_PSE_INVOICE_ATTCH);
v_ALLOWED_INV_IDS NUMBER_COLLECTION;

BEGIN

	SELECT INV.COLUMN_VALUE
	BULK COLLECT INTO v_ALLOWED_INV_IDS
	FROM TABLE(CAST(p_INVOICE_ID AS NUMBER_COLLECTION)) INV,
		TABLE(CAST(v_AVAILABLE_IDS AS ID_TABLE)) X,
		INVOICE I
	WHERE I.INVOICE_ID = INV.COLUMN_VALUE
		AND (X.ID = SD.g_ALL_DATA_ENTITY_ID OR I.ENTITY_ID = X.ID);

	FOR v_IDX IN 1..v_ALLOWED_INV_IDS.COUNT LOOP
		ADD_INVOICE_ATTACHMENT(v_ALLOWED_INV_IDS(v_IDX), p_FILE_NAME, p_FILE_CONTENTS);
	END LOOP;

END ADD_ATTACHMENT_TO_INVOICES;
---------------------------------------------------------------------------------------------------
-- Enumerates recipient e-mail addresses for an invoice.
-- %param p_INVOICE_ID	The ID of the invoice for which to retrieve the list of
--				recipients.
-- %param p_CURSOR		The list of recipient e-mail addresses.
-- %raise	An exception will be raised if the current user does not permission to
-- 		send the specified invoice.
PROCEDURE RECIPIENT_EMAIL_ADDRESSES
	(
	p_INVOICE_ID	IN NUMBER,
	p_CURSOR		IN OUT GA.REFCURSOR
	) AS
v_TO_EMAIL_ADDRESS STRING_COLLECTION;
v_CC_EMAIL_ADDRESS STRING_COLLECTION;
v_BCC_EMAIL_ADDRESS STRING_COLLECTION;
v_PSE_ID NUMBER;
BEGIN
	-- Verify Privilege
	SELECT I.ENTITY_ID
	INTO v_PSE_ID
	FROM INVOICE I
	WHERE I.INVOICE_ID = p_INVOICE_ID;

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_PSE_INVOICE_SEND, v_PSE_ID, EC.ED_PSE);

	v_TO_EMAIL_ADDRESS := RECIPIENT_LIST(p_INVOICE_ID, 'TO');
	v_CC_EMAIL_ADDRESS := RECIPIENT_LIST(p_INVOICE_ID, 'CC');
	v_BCC_EMAIL_ADDRESS := RECIPIENT_LIST(p_INVOICE_ID, 'BCC');

	OPEN p_CURSOR FOR
		SELECT 'TO' EMAIL_REC_TYPE, X.COLUMN_VALUE RECIPIENT_EMAIL FROM TABLE(CAST(v_TO_EMAIL_ADDRESS AS STRING_COLLECTION)) X
		UNION ALL
		SELECT 'CC' EMAIL_REC_TYPE, X.COLUMN_VALUE RECIPIENT_EMAIL FROM TABLE(CAST(v_CC_EMAIL_ADDRESS AS STRING_COLLECTION)) X
		UNION ALL
		SELECT 'BCC' EMAIL_REC_TYPE, X.COLUMN_VALUE RECIPIENT_EMAIL FROM TABLE(CAST(v_BCC_EMAIL_ADDRESS AS STRING_COLLECTION)) X;

END RECIPIENT_EMAIL_ADDRESSES;
---------------------------------------------------------------------------------------------------
-- A warning procedure. It will return a message that details which of the specified
-- invoices cannot be sent due to either the invoice not being approved or due to the
-- current user not having permission to send the invoice.
-- %param p_INVOICE_IDs		The list of invoices that will be sent.
-- %param p_WARNING_MESSAGE	The message that will be shown to the user. This will
-- 					be NULL if all specified invoices are approved and
--					current user has permission to send all specified
--					invoices.
PROCEDURE SEND_INVOICES_APPROV_WARNING
	(
	p_INVOICE_ID		IN NUMBER_COLLECTION,
	p_WARNING_MESSAGE	OUT VARCHAR2
	) AS

v_NOT_APPROV_INV NUMBER_COLLECTION := NUMBER_COLLECTION();
v_PSE_IDS NUMBER_COLLECTION := NUMBER_COLLECTION();

v_IDs ID_TABLE;
BEGIN
	v_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_PSE_INVOICE_SEND, EC.ED_PSE);

	-- Get the Invoices that are not approved
	SELECT I.INVOICE_ID, I.ENTITY_ID
	BULK COLLECT INTO v_NOT_APPROV_INV, v_PSE_IDS
	FROM INVOICE I,
		TABLE(CAST(p_INVOICE_ID AS NUMBER_COLLECTION)) X
	WHERE I.INVOICE_ID = X.COLUMN_VALUE
		AND I.APPROVED_BY_ID IS NULL;

	IF v_NOT_APPROV_INV.COUNT > 0 THEN
		p_WARNING_MESSAGE := 'The following invoices will not be sent because they are not approved: ' || UTL_TCP.CRLF;
		-- Create a warning message with the information
		FOR v_IDX IN 1..v_NOT_APPROV_INV.COUNT LOOP
			p_WARNING_MESSAGE := p_WARNING_MESSAGE || 'PSE ' || ENTITY_NAME_FROM_IDS(EC.ED_PSE, v_PSE_IDS(v_IDX)) || ': Invoice ' || v_NOT_APPROV_INV(v_IDX) || ', ';
		END LOOP;
		p_WARNING_MESSAGE := SUBSTR(p_WARNING_MESSAGE, 1,  LENGTH(p_WARNING_MESSAGE) - 2);
	END IF;

END SEND_INVOICES_APPROV_WARNING;
---------------------------------------------------------------------------------------------------
-- A warning procedure. It will return a message that details which of the specified
-- invoices cannot be sent due to the
-- current user not having permission to send the invoice.
-- %param p_INVOICE_IDs		The list of invoices that will be sent.
-- %param p_WARNING_MESSAGE	The message that will be shown to the user. This will
-- 					be NULL if all specified invoices are approved and
--					current user has permission to send all specified
--					invoices.
PROCEDURE SEND_INVOICES_PRIV_WARNING
	(
	p_INVOICE_ID		IN NUMBER_COLLECTION,
	p_WARNING_MESSAGE	OUT VARCHAR2
	) AS

v_ALLOW_INV	NUMBER_COLLECTION := NUMBER_COLLECTION();
v_NOT_ALLOW_INV	NUMBER_COLLECTION := NUMBER_COLLECTION();
v_PSE_IDS NUMBER_COLLECTION := NUMBER_COLLECTION();

v_IDs ID_TABLE;
BEGIN
	v_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_PSE_INVOICE_SEND, EC.ED_PSE);

	-- Get the entities that are not allowed
	SELECT I.INVOICE_ID
	BULK COLLECT INTO v_ALLOW_INV
	FROM INVOICE I,
		TABLE(CAST(p_INVOICE_ID AS NUMBER_COLLECTION)) X, -- incoming invoice id
		TABLE(CAST(v_IDs as ID_TABLE)) IDs -- All allowed entities
	WHERE I.INVOICE_ID = X.COLUMN_VALUE
		AND IDS.ID IN (I.ENTITY_ID, SD.g_ALL_DATA_ENTITY_ID);

	SELECT X.COLUMN_VALUE
	BULK COLLECT INTO v_NOT_ALLOW_INV
	FROM TABLE(CAST(p_INVOICE_ID AS NUMBER_COLLECTION)) X
	MINUS
	SELECT X1.COLUMN_VALUE FROM TABLE(CAST(v_ALLOW_INV AS NUMBER_COLLECTION)) X1;

	SELECT I.ENTITY_ID
	BULK COLLECT INTO v_PSE_IDS
	FROM INVOICE I,
		TABLE(CAST(v_NOT_ALLOW_INV AS NUMBER_COLLECTION)) X
	WHERE I.INVOICE_ID = X.COLUMN_VALUE;

	IF v_PSE_IDS.COUNT > 0 THEN
		p_WARNING_MESSAGE := 'You do not have sufficient privilege to send invoices for the following PSEs: ' || UTL_TCP.CRLF;
		-- Create a warning message with the information
		FOR v_IDX IN 1..v_PSE_IDS.COUNT LOOP
			p_WARNING_MESSAGE := p_WARNING_MESSAGE || 'PSE-' || ENTITY_NAME_FROM_IDS(EC.ED_PSE, v_PSE_IDS(v_IDX)) || ', '  ;
		END LOOP;

		p_WARNING_MESSAGE := SUBSTR(p_WARNING_MESSAGE, 1,  LENGTH(p_WARNING_MESSAGE) - 2);
	END IF;

END SEND_INVOICES_PRIV_WARNING;
---------------------------------------------------------------------------------------------------
-- Returns export formats for the UI
PROCEDURE EXPORT_FORMATS
	(
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN
	OPEN p_CURSOR FOR
		SELECT CRYSTAL_REPORTS.c_EXPORT_CRYSTAL as export_fmt_id, 'Crystal' as export_fmt FROM DUAL
		UNION ALL
		SELECT CRYSTAL_REPORTS.c_EXPORT_MSWORD as export_fmt_id, 'MS Word' as export_fmt FROM DUAL
		UNION ALL
		SELECT CRYSTAL_REPORTS.c_EXPORT_MSEXCEL as export_fmt_id, 'Excel' as export_fmt FROM DUAL
		UNION ALL
		SELECT CRYSTAL_REPORTS.c_EXPORT_PDF as export_fmt_id, 'PDF' as export_fmt FROM DUAL
		UNION ALL
		SELECT CRYSTAL_REPORTS.c_EXPORT_RTF as export_fmt_id, 'RTF' as export_fmt FROM DUAL;

END EXPORT_FORMATS;
---------------------------------------------------------------------------------------------------

END BSJ;
/
