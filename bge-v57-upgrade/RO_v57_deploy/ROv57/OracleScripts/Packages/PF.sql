CREATE OR REPLACE PACKAGE PF AS
--Revision $Revision: 1.193 $

-- Profiling Package --

FUNCTION WHAT_VERSION RETURN VARCHAR;

FUNCTION PRODUCT_FROM_STRING
	(
	p_VALS IN VARCHAR2,
	p_DELIM IN CHAR := ','
	) RETURN NUMBER;

PROCEDURE PUT_LOAD_PROFILE_POINTS
	(
	p_PROFILE_ID IN NUMBER,
	p_POINT_INDEX IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_POINT_VALUES IN VARCHAR,
	p_PROFILE_INTERVAL IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_LOAD_PROFILE_POINTS_TBL
	(
	p_PROFILE_ID IN NUMBER,
	p_POINT_INDEX IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_POINT_VALUES IN OUT NOCOPY GA.NUMBER_TABLE,
	p_PROFILE_INTERVAL IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_PROFILE_NAME_FROM_ID
	(
	p_PROFILE_ID IN NUMBER,
	p_PROFILE_NAME OUT VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_LOAD_PROFILE_STATISTICS
	(
	p_PROFILE_ID IN NUMBER,
	p_VERSION_ID IN NUMBER,
	p_FROM_DATE OUT DATE,
	p_TO_DATE OUT DATE,
	p_PROFILE_COUNT OUT NUMBER,
	p_PROFILE_LOAD_FACTOR OUT NUMBER,
	p_PROFILE_MIN OUT NUMBER,
	p_PROFILE_NZ_MIN OUT NUMBER,
	p_PROFILE_MAX OUT NUMBER,
	p_PROFILE_SUM OUT NUMBER,
	p_PROFILE_MEAN_APE OUT NUMBER,
	p_PROFILE_AVG_DEV_APE OUT NUMBER,
	p_PROFILE_TOTAL_ERROR_PCT OUT NUMBER,
	p_R_SQUARED_MIN OUT NUMBER,
	p_R_SQUARED_MAX OUT NUMBER,
	p_R_SQUARED_FAIL_PCT OUT NUMBER,
	p_T_STAT_TEMP_FAIL_PCT OUT NUMBER,
	p_T_STAT_HUMID_FAIL_PCT OUT NUMBER,
	p_T_STAT_WIND_FAIL_PCT OUT NUMBER,
	p_PROFILE_STATUS OUT VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_LOAD_PROFILE_STATISTICS
	(
	p_PROFILE_ID IN NUMBER,
	p_VERSION_ID IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_FROM_DATE IN DATE,
	p_TO_DATE IN DATE,
	p_PROFILE_COUNT IN NUMBER,
	p_PROFILE_LOAD_FACTOR IN NUMBER,
	p_PROFILE_MIN IN NUMBER,
	p_PROFILE_NZ_MIN IN NUMBER,
	p_PROFILE_MAX IN NUMBER,
	p_PROFILE_SUM IN NUMBER,
	p_PROFILE_MEAN_APE IN NUMBER,
	p_PROFILE_AVG_DEV_APE IN NUMBER,
	p_PROFILE_TOTAL_ERROR_PCT IN NUMBER,
	p_R_SQUARED_MIN IN NUMBER,
	p_R_SQUARED_MAX IN NUMBER,
	p_R_SQUARED_FAIL_PCT IN NUMBER,
	p_T_STAT_TEMP_FAIL_PCT IN NUMBER,
	p_T_STAT_HUMID_FAIL_PCT IN NUMBER,
	p_T_STAT_WIND_FAIL_PCT IN NUMBER,
	p_PROFILE_STATUS IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_LOAD_PROFILE_WRF
	(
	p_PROFILE_ID IN NUMBER,
	p_WRF_LINE_NBR IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_SEGMENT_MIN IN NUMBER,
	p_SEGMENT_MAX IN NUMBER,
	p_WRF_ID OUT NUMBER
	);

PROCEDURE PUT_LOAD_PROFILE_WRF_DATA
	(
	p_PROFILE_ID IN NUMBER,
	p_WRF_SEGMENT_NBR IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_WRF_SEGMENT_VALUES IN VARCHAR,
	p_WRF_MIN IN NUMBER,
	p_WRF_MAX IN NUMBER,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_LOAD_PROFILE_WRF_SEGMENT
	(
	p_PROFILE_ID IN NUMBER,
	p_WRF_LINE_NBR IN NUMBER,
	P_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_WRF_TEMP_MIN IN NUMBER,
	p_WRF_TEMP_MAX IN NUMBER,
	p_WRF_LINE_VALUES IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_WEATHER_PARAMETERS
	(
	p_PROFILE_ID IN NUMBER,
	p_VARIABLE_NBR IN NUMBER,
	p_PARAMETER_ID IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_HISTORICAL_PROFILE_STATS
	(
	p_PROFILE_ID IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE APPEND_TO_HISTORICAL_PROFILE
	(
	p_PROFILE_LIBRARY_NAME IN VARCHAR,
	p_PROFILE_NAME IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_VERSION_ID IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_POINT_VALUES IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE ASSIGN_LIBRARY_TO_CALENDAR
	(
	p_PROFILE_LIBRARY_NAME IN VARCHAR,
	p_CALENDAR_NAME IN VARCHAR,
	p_ACCOUNT_ID IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE ACCOUNT_FORECAST
	(
	p_MODEL_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE EXPORT_TYPICAL_DAY
	(
	p_LIBRARY_ID IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE GET_SAMPLE_INTERVAL_USAGE
	(
	p_SAMPLE_NAME IN VARCHAR,
	p_METER_NUMBER IN VARCHAR,
	p_ACCOUNT_NUMBER IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PUT_EXTERNAL_METER_DATA
	(
	p_METER_IDENTIFIER IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_MACHINE_NAME IN VARCHAR,
	p_USER_NAME IN VARCHAR,
	p_METER_VALUES IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE PROFILE_MONITOR_REQUEST
	(
	p_REQUEST_TYPE IN VARCHAR,
	p_ACCOUNT_IDS IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PROFILE_AS_OF_DATE IN DATE,
	p_USAGE_AS_OF_DATE IN DATE,
	p_MONDAY IN NUMBER,
	p_TUESDAY IN NUMBER,
	p_WEDNESDAY IN NUMBER,
	p_THURSDAY IN NUMBER,
	p_FRIDAY IN NUMBER,
	p_SATURDAY IN NUMBER,
	p_SUNDAY IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE GET_LOAD_PROFILE_BY_LIBRARY
	(
	p_LIBRARY_ID IN NUMBER,
	p_VERSION_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PUT_SEASON_BREAKPOINT
	(
	p_SEASON_ID IN NUMBER,
	p_PARAMETER_ID IN NUMBER,
	p_BREAKPOINT_ID IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_USAGE_WRF
	(
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_USAGE_WRF_TEMPLATE_NAMES
	(
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_CUSTOMER_USAGE_WRF
	(
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_FILTER_STRING IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_ENTITY_USAGE_WRF
	(
	p_ENTITY_TYPE IN VARCHAR,
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_FILTER_STRING IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_ENTITY_CONSUMPTION
	(
	p_ENTITY_ID IN NUMBER,
	p_ENTITY_TYPE IN VARCHAR,
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_PROFILE_AS_OF_DATE
	(
	p_PROFILE_ID IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_PROFILE_AS_OF_DATE OUT DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE USAGE_WRF_REQUEST
	(
	p_PROCESS_ID IN NUMBER,
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_REQUESTOR IN VARCHAR,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	);

PROCEDURE USAGE_WRF_REQUEST
	(
	p_PROCESS_ID IN NUMBER,
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_REQUESTOR IN VARCHAR,
	p_TRACE_ON IN NUMBER
	);

PROCEDURE RUN_USAGE_WRF_REQUEST
	(
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_SCHEDULE_RUN IN NUMBER,
	p_RUN_AT IN DATE,
	p_REQUESTOR IN VARCHAR,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	);

PROCEDURE GET_ENTITY_USAGE_WRF_POINTS
	(
	p_ENTITY_ID IN NUMBER,
	p_ENTITY_TYPE IN VARCHAR,
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_STATION_ID IN NUMBER,
	p_PARAMETER_ID IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE UPDATE_USAGE_WRF_STATUS
	(
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_LAST_RUN_STATUS IN VARCHAR,
	p_STATUS OUT NUMBER
	);
PROCEDURE DELETE_USAGE_WRF_STATISTICS
	(
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_HISTORICAL_PROFILE
	(
	p_PROFILE_LIBRARY_NAME IN VARCHAR,
	p_PROFILE_NAME IN VARCHAR,
	p_PROFILE_POINT_VALUES IN VARCHAR,
	p_PROFILE_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_LOAD_PROFILE_COMPLETE
	(
	o_OID OUT NUMBER,
	p_PROFILE_NAME IN VARCHAR,
	p_PROFILE_LIBRARY_NAME IN VARCHAR,
	p_PROFILE_TYPE IN VARCHAR,
	p_PROFILE_POINT_VALUES IN VARCHAR,
	p_PROFILE_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_PROFILE_TEMPLATE_ID IN NUMBER,
	p_PROFILE_SEASON IN VARCHAR,
	p_SOURCE_BEGIN_DATE IN DATE,
	p_SOURCE_END_DATE IN DATE,
	p_SOURCE_PROFILE_ID IN NUMBER,
	p_PROFILE_INTERVAL IN NUMBER,
	p_APP_LOG_DOMAIN_NAME IN VARCHAR DEFAULT 'Profiling',
	p_APP_LOG_APP_NAME IN VARCHAR DEFAULT 'PF',
	p_APP_LOG_EVENT_NAME IN VARCHAR DEFAULT 'PUT_LOAD_PROFILE_COMPLETE',
	p_APP_LOG_EVENT_USER_NAME IN VARCHAR DEFAULT 'UNKNOWN',
	p_LOG_START_STOP IN NUMBER DEFAULT 0,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	);

PROCEDURE PUT_LOAD_PROFILE_POINT
	(
	p_PROFILE_ID IN NUMBER,
	p_POINT_INDEX IN NUMBER,
	p_POINT_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_POINT_VAL IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE PROFILE_WRF_PROFILES
	(
	p_PROFILE_ID IN NUMBER,
	p_BREAKPOINT_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_PARAMETER_LIST IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_R2_THRESHOLD IN NUMBER,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE ACCOUNT_WRF_PROFILES
	(
	p_ACCOUNT_ID IN NUMBER,
	p_TEMPLATE_LIST IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_R2_THRESHOLD IN NUMBER,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE ACCOUNT_GROUP_WRF_PROFILES
	(
	p_ACCOUNT_GROUP_ID IN NUMBER,
	p_TEMPLATE_LIST IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_R2_THRESHOLD IN NUMBER,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER
	);

-- launches background job which execute BATCH_WRF_PROCESS using
-- template and account IDs in WRF_*_TO_RUN_TEMP temporary tables
PROCEDURE RUN_BATCH_WRF
	(
	p_RUN_MODE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
    p_TIME_ZONE IN VARCHAR2,
	p_R2_THRESHOLD IN NUMBER,
	p_MIN_SEGMENTS IN NUMBER,
	p_MAX_SEGMENTS IN NUMBER,
	p_AUTO_APPLY IN NUMBER,
	p_TRACE_ON IN NUMBER,
	p_MESSAGE OUT VARCHAR2
	);

-- calculate WRFs for the specified day-types and accounts
PROCEDURE BATCH_WRF_PROCESS
	(
	p_TEMPLATE_IDs IN NUMBER_COLLECTION,
	p_ACCOUNT_IDs IN NUMBER_COLLECTION,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
    p_TIME_ZONE IN VARCHAR2,
	p_R2_THRESHOLD IN NUMBER,
	p_MIN_SEGMENTS IN NUMBER,
	p_MAX_SEGMENTS IN NUMBER,
	p_AUTO_APPLY IN NUMBER,
	p_TRACE_ON IN NUMBER,
	p_PROCESS_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR2
	);

PROCEDURE CHOOSE_CANDIDATE
	(
	p_FCM_ID IN NUMBER,
	p_NUM_SEGMENTS IN NUMBER
	);

PROCEDURE USAGE_WRF_REQUEST_BASE
	(
	p_PROCESS_ID IN NUMBER,
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_BASE_LOAD_TEMPLATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_REQUESTOR IN VARCHAR,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	);

PROCEDURE USAGE_WRF_REQUEST_BASE
	(
	p_PROCESS_ID IN NUMBER,
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_BASE_LOAD_TEMPLATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_REQUESTOR IN VARCHAR,
	p_TRACE_ON IN NUMBER
	);

PROCEDURE RUN_USAGE_WRF_REQUEST_BASE
	(
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_BASE_LOAD_TEMPLATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_SCHEDULE_RUN IN NUMBER,
	p_RUN_AT IN DATE,
	p_REQUESTOR IN VARCHAR,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	);

PROCEDURE USAGE_WRF_REQUEST_ENTITY
	(
	p_MODEL_ID IN NUMBER,
	p_ENTITY_TYPE IN VARCHAR,
	p_PROCESS_ID IN NUMBER,
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_BASE_LOAD_TEMPLATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_REQUESTOR IN VARCHAR,
	p_ACCT_CALENDAR_BEGIN_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	);

PROCEDURE USAGE_WRF_REQUEST_ENTITY
	(
	p_MODEL_ID IN NUMBER,
	p_ENTITY_TYPE IN VARCHAR,
	p_PROCESS_ID IN NUMBER,
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_BASE_LOAD_TEMPLATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_REQUESTOR IN VARCHAR,
	p_ACCT_CALENDAR_BEGIN_DATE IN DATE,
	p_TRACE_ON IN NUMBER
	);

PROCEDURE RUN_USAGE_WRF_REQUEST_ENTITY
	(
	p_MODEL_ID IN NUMBER,
	p_ENTITY_TYPE IN VARCHAR,
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_BASE_LOAD_TEMPLATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_SCHEDULE_RUN IN NUMBER,
	p_RUN_AT IN DATE,
	p_REQUESTOR IN VARCHAR,
	p_ACCT_CALENDAR_BEGIN_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	);

PROCEDURE GET_TEMPLATE_LIST
	(
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE UPDATE_CUSTOMER_USAGE_WRF_BASE
	(
	p_CUSTOMER_ID IN NUMBER,
	p_WRF_ID IN NUMBER,
	p_STATION_ID IN NUMBER,
	p_PARAMETER_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_BASE_LOAD_TEMPLATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_DEFAULT_ALPHA IN NUMBER,
	p_DEFAULT_BETA IN NUMBER
	);

PROCEDURE UPDATE_ACCOUNT_USAGE_WRF_BASE
	(
	p_MODEL_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_WRF_ID IN NUMBER,
	p_STATION_ID IN NUMBER,
	p_PARAMETER_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_BASE_LOAD_TEMPLATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_DEFAULT_ALPHA IN NUMBER,
	p_DEFAULT_BETA IN NUMBER
	);

PROCEDURE GET_PROFILING_REPORT
	(
	p_MODEL_ID IN NUMBER,
	p_REPORT_NAME IN VARCHAR,
	p_OPTIONAL_PARAMETER IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_PROFILE_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE GET_PROFILE_FROM_TO_DATES
	(
	p_PROFILE_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_FROM_DATE OUT DATE,
	p_TO_DATE OUT DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_LOAD_PROFILE_POINTS
	(
	p_PROFILE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ALL_DATES IN NUMBER := 0,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_POINT_INDEX IN NUMBER := 1,
	p_ALL_INDEXES IN NUMBER := 0,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE GET_ACCOUNT_MODEL_OPTION
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ACCOUNT_MODEL_OPTION OUT VARCHAR2,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_ACCOUNT_SERV_LOC_METERS
	(
	p_ACCOUNT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

FUNCTION GET_METER_NAME
	(
	p_METER_ID IN NUMBER
	) RETURN VARCHAR;

FUNCTION GET_METER_IDS_FOR_ACCOUNT
	(
	p_ACCOUNT_ID IN NUMBER
	) RETURN GA.ID_TABLE;

FUNCTION GET_PROFILE_ID_FROM_METER_REF
	(
	p_METER_ID IN NUMBER
	) RETURN NUMBER;

FUNCTION GET_PROFILE_ID
	(
	p_ACCOUNT_ID IN NUMBER
	) RETURN NUMBER;

PROCEDURE CREATE_TYPICAL_DAY_FOR_PROF
	(
	p_MODEL_ID IN NUMBER,
    p_PROFILE_ID IN NUMBER,
    p_ACCOUNT_ID IN NUMBER,
    p_METER_ID IN NUMBER,
    p_PREFIX_NAME IN VARCHAR2,
    p_TEMPLATE_ID IN NUMBER,
	p_SEASON_ID IN NUMBER,
    p_DAY_TYPE_TEXT IN VARCHAR2,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_AS_OF_DATE IN DATE,
    p_TRACE_ON IN NUMBER,
    p_NEW_PROFILE_ID OUT NUMBER,
    p_NEW_LIBRARY_ID OUT NUMBER,
    p_STATUS OUT NUMBER
    );

PROCEDURE PUT_HISTORICAL_PROFILE_TBL
	(
	p_PROFILE_LIBRARY_NAME IN VARCHAR,
	p_PROFILE_NAME IN VARCHAR,
	p_PROFILE_POINT_VALUES IN OUT NOCOPY GA.NUMBER_TABLE,
	p_PROFILE_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN NUMBER,
	p_STATUS OUT NUMBER,
    p_LOG_ONLY_ERRORS IN CHAR DEFAULT 'N',
    p_INTERVAL_IS_NUM_MIN IN BOOLEAN := TRUE
	);

FUNCTION GET_ACCOUNT_STATION
	(
	p_ACCOUNT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	) RETURN NUMBER;

g_DOMAIN_NAME VARCHAR(16) := 'Profiling';
g_APP_NAME VARCHAR(16) := 'RetailOffice';
g_DEFAULT_SEGMENT NUMBER(1) := 1;
g_DEFAULT_INDEX NUMBER(1) := 1;
g_DEFAULT_POINT_INDEX NUMBER(1) := 1;
g_TAB CHAR(1) := CHR(9);
g_ACCOUNT_USAGE_WRF_MIN_POINTS NUMBER(2) := 5;
g_SECOND NUMBER(6,5) := 1/86400;
g_ACCT_CALENDAR_BEGIN_DATE DATE := NULL;
g_DELIMITER VARCHAR2(1) := ',';
g_ALLOW_COMMIT_ROLLBACK BOOLEAN := TRUE;

c_ENTITY_TYPE_CUSTOMER CONSTANT VARCHAR2(1) := 'C';

c_BATCH_RUN_MODE_ALL CONSTANT NUMBER(9) := -1;
c_BATCH_RUN_MODE_AGGREGATE CONSTANT NUMBER(9) := -2;
c_BATCH_RUN_MODE_PERIOD_MTR CONSTANT NUMBER(9) := -3;
c_BATCH_RUN_MODE_INTERVAL_MTR CONSTANT NUMBER(9) := -4;
c_BATCH_RUN_MODE_SELECTED CONSTANT NUMBER(9) := -5;

END;
/
CREATE OR REPLACE PACKAGE BODY PF AS
---------------------------------------------------------------------------------------------------
g_BATCH_WEATHER_STATION_ID	NUMBER(9);
g_BATCH_WEATHER_TEMPLATE_ID	NUMBER(9);
g_BATCH_WEATHER_PARAMETERS	GA.ID_TABLE;
g_BATCH_WEATHER_BEGIN_DATE	DATE;
g_BATCH_WEATHER_END_DATE	DATE;
g_BATCH_WEATHER_TIMESTAMP	TIMESTAMP;

-- Accumulate statistics information during WRF profile calculations
TYPE WRF_STAT_STRUCT IS RECORD (
	ALL_ZEROES	BOOLEAN,
	P_MAX		NUMBER,
	P_MIN		NUMBER,
	P_NZMIN		NUMBER,
	P_SUM		NUMBER,
	P_COUNT		PLS_INTEGER,
	P_ERR_SUM	NUMBER,
	TOT_ERR_PCT NUMBER,
	APE			GA.NUMBER_TABLE,
	MAPE		NUMBER,
	STDAPE		NUMBER,
	R2COUNT		PLS_INTEGER,
	R2MAX		NUMBER,
	R2MIN		NUMBER,
	R2THRESHOLD	NUMBER,
	R2FAIL		PLS_INTEGER,
	T_TEMP		PLS_INTEGER,
	T_HUMID		PLS_INTEGER,
	T_WIND		PLS_INTEGER,
	-- parameter index - input to calculate the above three values
	TEMP_IDX	PLS_INTEGER,
	HUMID_IDX	PLS_INTEGER,
	WIND_IDX	PLS_INTEGER
);

-- points and matrices used by FCM algorithm for auto-determining WRF
-- breakpoints
TYPE POINT IS RECORD ( X NUMBER, Y NUMBER);
TYPE POINT_TABLE IS TABLE OF POINT INDEX BY BINARY_INTEGER;
TYPE MATRIX IS TABLE OF GA.NUMBER_TABLE INDEX BY BINARY_INTEGER;
---------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
    RETURN '$Revision: 1.193 $';
END WHAT_VERSION;
----------------------------------------------------------------------------------------------------
PROCEDURE NULL_CURSOR
	(
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT NULL FROM DUAL;
END NULL_CURSOR;
----------------------------------------------------------------------------------------------------
-- Take a string of delimited numbers and return their product
FUNCTION PRODUCT_FROM_STRING
	(
	p_VALS IN VARCHAR2,
	p_DELIM IN CHAR := ','
	) RETURN NUMBER IS

  v_RET NUMBER;
  v_TBL GA.NUMBER_TABLE;
  v_IDX BINARY_INTEGER;

BEGIN

	UT.TOKENS_FROM_STRING_TO_NUMBERS(p_VALS, p_DELIM, v_TBL);

	v_IDX := v_TBL.FIRST;
	WHILE v_TBL.EXISTS(v_IDX) LOOP
		v_RET := NVL(v_RET,1.0)*NVL(v_TBL(v_IDX),0.0);
		v_IDX := V_TBL.NEXT(v_IDX);
	END LOOP;

	RETURN v_RET;
END PRODUCT_FROM_STRING;
----------------------------------------------------------------------------------------------------
FUNCTION INTERVAL_BEGIN_MINUTES
	(
	p_INTERVAL IN NUMBER
	)  RETURN NUMBER IS

v_MINUTES NUMBER;

BEGIN

	SELECT DECODE(p_INTERVAL,1,0,24,60,48,30,96,15,0) INTO v_MINUTES FROM DUAL;
	RETURN v_MINUTES;

END INTERVAL_BEGIN_MINUTES;
---------------------------------------------------------------------------------------------------
FUNCTION GET_PROFILE_NAME
	(
	p_PROFILE_ID IN NUMBER
	) RETURN VARCHAR IS

v_PROFILE_NAME VARCHAR(128);

BEGIN

	SELECT PROFILE_NAME
	INTO v_PROFILE_NAME
	FROM LOAD_PROFILE
	WHERE PROFILE_ID = p_PROFILE_ID;

	RETURN v_PROFILE_NAME;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN '?';

END GET_PROFILE_NAME;
----------------------------------------------------------------------------------------------------
FUNCTION GET_METER_NAME
	(
	p_METER_ID IN NUMBER
	) RETURN VARCHAR IS

v_METER_NAME METER.METER_NAME%TYPE;

BEGIN

	SELECT METER_NAME
	INTO v_METER_NAME
	FROM METER
	WHERE METER_ID = p_METER_ID;

	RETURN v_METER_NAME;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN '?';

END GET_METER_NAME;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_PROFILE_NAME_FROM_ID
	(
	p_PROFILE_ID IN NUMBER,
	p_PROFILE_NAME OUT VARCHAR,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	p_PROFILE_NAME := '';

    IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	SELECT PROFILE_NAME
	INTO p_PROFILE_NAME
	FROM LOAD_PROFILE
	WHERE PROFILE_ID = p_PROFILE_ID;


END GET_PROFILE_NAME_FROM_ID;
----------------------------------------------------------------------------------------------------
FUNCTION GET_PROFILE_ID
	(
	p_ACCOUNT_ID IN NUMBER
	) RETURN NUMBER IS

-- Answer the Profile Associated with the Account; if the Account Id is Negative the Id Is already a Profile Id.

v_PROFILE_ID NUMBER(9);

BEGIN

	IF p_ACCOUNT_ID > 0 THEN
		SELECT PROFILE_ID INTO v_PROFILE_ID
		FROM (
        	SELECT PROFILE_ID
        	FROM LOAD_PROFILE
			WHERE PROFILE_ACCOUNT_REF = TO_CHAR(p_ACCOUNT_ID)
	        	AND UPPER(PROFILE_TYPE) = 'HISTORICAL'
			)
        WHERE ROWNUM = 1;

		RETURN v_PROFILE_ID;
	ELSE
		RETURN ABS(p_ACCOUNT_ID);
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN CONSTANTS.NOT_ASSIGNED;

END GET_PROFILE_ID;
----------------------------------------------------------------------------------------------------
FUNCTION GET_PROFILE_VERSION_ID
	(
	p_AS_OF_DATE IN DATE
	) RETURN NUMBER IS

v_VERSION_ID NUMBER;

BEGIN

	SELECT VERSION_ID
	INTO v_VERSION_ID
	FROM VERSION
	WHERE UPPER(VERSION_DOMAIN) = 'PROFILING'
		AND AS_OF_DATE = p_AS_OF_DATE;

	RETURN v_VERSION_ID;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN CONSTANTS.NOT_ASSIGNED;

END GET_PROFILE_VERSION_ID;
----------------------------------------------------------------------------------------------------
FUNCTION GET_SERVICE_LOCATION_ID
	(
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_DATE IN DATE
	) RETURN NUMBER IS

-- Answer the account service location id assignment for the specified day
-- Answer CONSTANTS.NOT_ASSIGNED when there is not an assigned service location

v_SERVICE_LOCATION_ID NUMBER;

BEGIN

	SELECT SERVICE_LOCATION_ID
	INTO v_SERVICE_LOCATION_ID
	FROM ACCOUNT_SERVICE_LOCATION
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND p_SERVICE_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE)
		AND ROWNUM = 1;

	RETURN v_SERVICE_LOCATION_ID;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN  CONSTANTS.NOT_ASSIGNED;

END GET_SERVICE_LOCATION_ID;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_LOAD_PROFILE_LIBRARY
	(
	p_PROFILE_LIBRARY_NAME IN VARCHAR,
	p_PROFILE_LIBRARY_ID OUT NUMBER
	) AS

BEGIN

	SELECT PROFILE_LIBRARY_ID
	INTO p_PROFILE_LIBRARY_ID
	FROM LOAD_PROFILE_LIBRARY
	WHERE UPPER(PROFILE_LIBRARY_NAME) = UPPER(LTRIM(RTRIM(p_PROFILE_LIBRARY_NAME)));

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		SELECT OID.NEXTVAL INTO p_PROFILE_LIBRARY_ID FROM DUAL;
		INSERT INTO LOAD_PROFILE_LIBRARY(
			PROFILE_LIBRARY_ID,
			PROFILE_LIBRARY_NAME,
			PROFILE_LIBRARY_ALIAS,
			PROFILE_LIBRARY_DESC,
			ENTRY_DATE)
		VALUES(
			p_PROFILE_LIBRARY_ID,
			p_PROFILE_LIBRARY_NAME,
			SUBSTR(p_PROFILE_LIBRARY_NAME,1,32),
			'RetailOffice Created WRF Profile Library',
			SYSDATE);
END PUT_LOAD_PROFILE_LIBRARY;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_LOAD_PROFILE
	(
	p_PROFILE_NAME IN VARCHAR,
	p_PROFILE_LIBRARY_ID IN NUMBER,
	p_PROFILE_TYPE IN VARCHAR,
	p_ACCOUNT_REF IN VARCHAR,
	p_METER_REF IN VARCHAR,
	p_SOURCE_ID IN NUMBER,
	p_SOURCE_BEGIN_DATE IN DATE,
	p_SOURCE_END_DATE IN DATE,
	p_SOURCE_VERSION IN DATE,
	p_TEMPLATE_ID IN NUMBER,
	p_STATION_ID IN NUMBER,
	p_SEASON IN VARCHAR,
	p_INTERVALS_PER_DAY IN NUMBER,
	p_PROFILE_ID OUT NUMBER
	) AS

BEGIN

	SELECT PROFILE_ID
	INTO p_PROFILE_ID
	FROM LOAD_PROFILE
	WHERE UPPER(PROFILE_NAME) = UPPER(LTRIM(RTRIM(p_PROFILE_NAME)));

	UPDATE LOAD_PROFILE
	SET
        PROFILE_LIBRARY_ID =  p_PROFILE_LIBRARY_ID,
        PROFILE_ALIAS =  SUBSTR(p_PROFILE_NAME,1,32), -- Alias;
        PROFILE_DESC =  'RetailOffice Created WRF Profile', -- Desc;
        PROFILE_TYPE =  NVL(p_PROFILE_TYPE,GA.UNDEFINED_ATTRIBUTE),  --Added param for use with 'UsageWRF' as well as 'WRF' - wjc, -- Type;
        PROFILE_OPERATION =  'Add', -- Operation;
        PROFILE_ORIGIN =  g_APP_NAME,  --'RetailOffice' -- Origin
        PROFILE_ACCOUNT_REF =  NVL(p_ACCOUNT_REF,GA.UNDEFINED_ATTRIBUTE),
        PROFILE_METER_REF =  NVL(p_METER_REF,GA.UNDEFINED_ATTRIBUTE),
        PROFILE_SEASON =  p_SEASON,
        PROFILE_STATION_ID =  p_STATION_ID,
        PROFILE_TEMPLATE_ID =  p_TEMPLATE_ID,
        PROFILE_SOURCE_BEGIN_DATE =  p_SOURCE_BEGIN_DATE,
        PROFILE_SOURCE_END_DATE =  p_SOURCE_END_DATE,
        PROFILE_SOURCE_ID =  p_SOURCE_ID,
        PROFILE_INTERVAL =  p_INTERVALS_PER_DAY, -- Added param for use with 'UsageWRF' - was hardcoded to 24;
        PROFILE_SOURCE_VERSION =  p_SOURCE_VERSION,
		ENTRY_DATE = SYSDATE
	WHERE PROFILE_ID = p_PROFILE_ID;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		SELECT OID.NEXTVAL INTO p_PROFILE_ID FROM DUAL;
		INSERT INTO LOAD_PROFILE(
			PROFILE_LIBRARY_ID,
			PROFILE_ID,
			PROFILE_NAME,
			PROFILE_ALIAS,
			PROFILE_DESC,
			PROFILE_TYPE,
			PROFILE_OPERATION,
			PROFILE_ORIGIN,
			PROFILE_RATE_CLASS,
			PROFILE_DAY_TYPE,
			PROFILE_ACCOUNT_REF,
			PROFILE_METER_REF,
			PROFILE_SIC_CODE,
			PROFILE_SEASON,
			PROFILE_SYSTEM_LOAD,
			PROFILE_ADJUSTMENT_OPTION,
			PROFILE_STATION_ID,
			PROFILE_TEMPLATE_ID,
			PROFILE_SOURCE_BEGIN_DATE,
			PROFILE_SOURCE_END_DATE,
			PROFILE_SOURCE_ID,
			PROFILE_INTERVAL,
			PROFILE_SOURCE_VERSION,
			ENTRY_DATE)
		VALUES(
			p_PROFILE_LIBRARY_ID,
			p_PROFILE_ID,
			p_PROFILE_NAME,
			SUBSTR(p_PROFILE_NAME,1,32), -- Alias;
			'RetailOffice Created WRF Profile', -- Desc;
			NVL(p_PROFILE_TYPE,GA.UNDEFINED_ATTRIBUTE),  --Added param for use with 'UsageWRF' as well as 'WRF' - wjc, -- Type;
			'Add', -- Operation;
			g_APP_NAME,  --''RetailOffice', -- Origin
			GA.UNDEFINED_ATTRIBUTE, -- Rate Class;
			GA.UNDEFINED_ATTRIBUTE, -- Day Type;
			NVL(p_ACCOUNT_REF,GA.UNDEFINED_ATTRIBUTE),
			NVL(p_METER_REF,GA.UNDEFINED_ATTRIBUTE),
			GA.UNDEFINED_ATTRIBUTE, -- Sic Code;
			p_SEASON,
			GA.UNDEFINED_ATTRIBUTE, -- System Load;
			'None', -- Adjustment Option;
			p_STATION_ID,
			p_TEMPLATE_ID,
			p_SOURCE_BEGIN_DATE,
			p_SOURCE_END_DATE,
			p_SOURCE_ID,
			p_INTERVALS_PER_DAY, -- Added param for use with 'UsageWRF' - was hardcoded to 24;
			p_SOURCE_VERSION,
			SYSDATE);
END PUT_LOAD_PROFILE;
----------------------------------------------------------------------------------------------------
PROCEDURE RESET_WRF_PROFILE
	(
	p_PROFILE_ID IN NUMBER
	) AS

BEGIN

	-- remove WRF info - it will get re-generated by new regression calculations
	DELETE LOAD_PROFILE_WRF WHERE PROFILE_ID = p_PROFILE_ID;

END RESET_WRF_PROFILE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_BREAKPOINT_INTERVAL
	(
	p_PROFILE_ID IN NUMBER,
	p_BREAKPOINT_INTERVAL IN VARCHAR
	) AS

BEGIN

	UPDATE LOAD_PROFILE
	SET PROFILE_BREAKPOINT_INTERVAL = p_BREAKPOINT_INTERVAL
	WHERE PROFILE_ID = p_PROFILE_ID;

END PUT_BREAKPOINT_INTERVAL;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_LOAD_PROFILE_POINT
	(
	p_PROFILE_ID IN NUMBER,
	p_POINT_INDEX IN NUMBER,
	p_POINT_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_POINT_VAL IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

-- INSERT OR UPDATE A NON-VERSIONED LOAD PROFILE POINT

v_OLD_POINT_VAL NUMBER;
v_AS_OF_DATE DATE;

BEGIN

	p_STATUS := GA.SUCCESS;
	IF NOT GA.VERSION_PROFILE THEN
		v_AS_OF_DATE := LOW_DATE;
	ELSE
		v_AS_OF_DATE := p_AS_OF_DATE;
	END IF;

-- Determine if an entry exists for this request and whether the data has changed.
	SELECT POINT_VAL
	INTO v_OLD_POINT_VAL
	FROM LOAD_PROFILE_POINT
	WHERE PROFILE_ID = p_PROFILE_ID
		AND POINT_INDEX = p_POINT_INDEX
		AND POINT_DATE = p_POINT_DATE
		AND AS_OF_DATE = v_AS_OF_DATE;

-- If there is a change to the point then update the existing record.
-- Make sure to also compare to NULL.  --wjc 12/08/03
	IF (v_OLD_POINT_VAL IS NULL) OR (v_OLD_POINT_VAL != p_POINT_VAL) THEN
		UPDATE LOAD_PROFILE_POINT
		SET POINT_VAL = p_POINT_VAL
		WHERE PROFILE_ID = p_PROFILE_ID
			AND POINT_INDEX = p_POINT_INDEX
			AND POINT_DATE = p_POINT_DATE
			AND AS_OF_DATE = v_AS_OF_DATE;
	END IF;

-- Trap the exception and insert a new record when a load profile point does not exist.
EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		INSERT INTO LOAD_PROFILE_POINT
			(PROFILE_ID,
			POINT_INDEX,
			AS_OF_DATE,
			POINT_DATE,
			POINT_VAL)
		VALUES(
			p_PROFILE_ID,
			p_POINT_INDEX,
			v_AS_OF_DATE,
			p_POINT_DATE,
			p_POINT_VAL);

END PUT_LOAD_PROFILE_POINT;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_LOAD_PROFILE_POINTS_TBL
	(
	p_PROFILE_ID IN NUMBER,
	p_POINT_INDEX IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_POINT_VALUES IN OUT NOCOPY GA.NUMBER_TABLE,
	p_PROFILE_INTERVAL IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

v_POINT_DATE DATE;
v_POINT_VAL LOAD_PROFILE_POINT.POINT_VAL%TYPE;
v_INDEX BINARY_INTEGER;
v_PROFILE_TYPE CHAR(1);

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	v_INDEX := p_POINT_VALUES.FIRST;

	SELECT UPPER(SUBSTR(PROFILE_TYPE,1,1))
	INTO  v_PROFILE_TYPE
	FROM LOAD_PROFILE
	WHERE PROFILE_ID = p_PROFILE_ID;

	IF v_PROFILE_TYPE = 'H' THEN
		v_POINT_DATE := BEGIN_HOUR_ENDING_CUT_DAY(p_BEGIN_DATE, STD_TIME_ZONE(p_TIME_ZONE), INTERVAL_BEGIN_MINUTES(p_PROFILE_INTERVAL));
	ELSIF v_PROFILE_TYPE = 'T' THEN
		v_POINT_DATE := BEGIN_HOUR_ENDING_CUT_DAY(LOW_DATE, STD_TIME_ZONE(p_TIME_ZONE), INTERVAL_BEGIN_MINUTES(p_PROFILE_INTERVAL));
	ELSE
		v_POINT_DATE := BEGIN_HOUR_ENDING_CUT_DAY(LOW_DATE, STD_TIME_ZONE(p_TIME_ZONE));
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PUT_LOAD_PROFILE_POINTS_TBL');
		LOGS.LOG_DEBUG('PROFILE_TYPE=' || v_PROFILE_TYPE);
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_TIME(p_BEGIN_DATE)); -- (SP)(BZ24960) changed the date format to show time
		LOGS.LOG_DEBUG('POINT_DATE=' || TEXT_UTIL.TO_CHAR_TIME(v_POINT_DATE)); -- (SP)(BZ24960) changed the date format to show time
		LOGS.LOG_DEBUG('PROFILE_INTERVAL=' || TO_CHAR(p_PROFILE_INTERVAL));
		LOGS.LOG_DEBUG('<date>,<value>');
	END IF;

	LOOP
        -- PROFILING DOESN'T LIKE NULLS --
		v_POINT_VAL := NVL(p_POINT_VALUES(v_INDEX),0.0);
		PUT_LOAD_PROFILE_POINT(
			p_PROFILE_ID,
			p_POINT_INDEX,
			v_POINT_DATE,
			p_AS_OF_DATE,
			v_POINT_VAL,
			p_STATUS);

		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG(TEXT_UTIL.TO_CHAR_TIME(v_POINT_DATE) || ',' || TO_CHAR(v_POINT_VAL)); -- (SP)(BZ24960) changed the date format to show time
		END IF;

		IF p_STATUS < GA.SUCCESS THEN
			IF g_ALLOW_COMMIT_ROLLBACK THEN ROLLBACK; END IF;
			RETURN;
		END IF;

		EXIT WHEN v_INDEX = p_POINT_VALUES.LAST;
		v_INDEX := p_POINT_VALUES.NEXT(v_INDEX);
		v_POINT_DATE := ADD_MINUTES_TO_DATE(v_POINT_DATE, (1440 / p_PROFILE_INTERVAL));

	END LOOP;

	IF g_ALLOW_COMMIT_ROLLBACK THEN COMMIT; END IF;

END PUT_LOAD_PROFILE_POINTS_TBL;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_LOAD_PROFILE_POINTS
	(
	p_PROFILE_ID IN NUMBER,
	p_POINT_INDEX IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_POINT_VALUES IN VARCHAR,
	p_PROFILE_INTERVAL IN NUMBER,
	p_STATUS OUT NUMBER
	) AS
	v_TABLE GA.NUMBER_TABLE;
BEGIN
	UT.TOKENS_FROM_STRING_TO_NUMBERS(p_POINT_VALUES,g_DELIMITER, v_TABLE);
	PUT_LOAD_PROFILE_POINTS_TBL(p_PROFILE_ID, p_POINT_INDEX, p_BEGIN_DATE, p_AS_OF_DATE, p_TIME_ZONE, v_TABLE, p_PROFILE_INTERVAL, p_STATUS);
END PUT_LOAD_PROFILE_POINTS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_LOAD_PROFILE_STATISTICS
	(
	p_PROFILE_ID IN NUMBER,
	p_VERSION_ID IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_FROM_DATE IN DATE,
	p_TO_DATE IN DATE,
	p_PROFILE_COUNT IN NUMBER,
	p_PROFILE_LOAD_FACTOR IN NUMBER,
	p_PROFILE_MIN IN NUMBER,
	p_PROFILE_NZ_MIN IN NUMBER,
	p_PROFILE_MAX IN NUMBER,
	p_PROFILE_SUM IN NUMBER,
	p_PROFILE_MEAN_APE IN NUMBER,
	p_PROFILE_AVG_DEV_APE IN NUMBER,
	p_PROFILE_TOTAL_ERROR_PCT IN NUMBER,
	p_R_SQUARED_MIN IN NUMBER,
	p_R_SQUARED_MAX IN NUMBER,
	p_R_SQUARED_FAIL_PCT IN NUMBER,
	p_T_STAT_TEMP_FAIL_PCT IN NUMBER,
	p_T_STAT_HUMID_FAIL_PCT IN NUMBER,
	p_T_STAT_WIND_FAIL_PCT IN NUMBER,
	p_PROFILE_STATUS IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

BEGIN

 	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

-- Update an existing record.
	UPDATE LOAD_PROFILE_STATISTICS SET
		FROM_DATE = p_FROM_DATE,
		TO_DATE = p_TO_DATE,
		PROFILE_COUNT = p_PROFILE_COUNT,
		PROFILE_LOAD_FACTOR = p_PROFILE_LOAD_FACTOR,
		PROFILE_MIN = p_PROFILE_MIN,
		PROFILE_NZ_MIN = p_PROFILE_NZ_MIN,
		PROFILE_MAX = p_PROFILE_MAX,
		PROFILE_SUM = p_PROFILE_SUM,
		PROFILE_MEAN_APE = p_PROFILE_MEAN_APE,
		PROFILE_AVG_DEV_APE = p_PROFILE_AVG_DEV_APE,
		PROFILE_TOTAL_ERROR_PCT = p_PROFILE_TOTAL_ERROR_PCT,
		R_SQUARED_MIN = p_R_SQUARED_MIN,
		R_SQUARED_MAX = p_R_SQUARED_MAX,
		R_SQUARED_FAIL_PCT = p_R_SQUARED_FAIL_PCT,
		T_STAT_TEMP_FAIL_PCT = p_T_STAT_TEMP_FAIL_PCT,
		T_STAT_HUMID_FAIL_PCT = p_T_STAT_HUMID_FAIL_PCT,
		T_STAT_WIND_FAIL_PCT = p_T_STAT_WIND_FAIL_PCT,
		PROFILE_STATUS = p_PROFILE_STATUS,
		ENTRY_DATE = SYSDATE
	WHERE PROFILE_ID = p_PROFILE_ID
		AND AS_OF_DATE = p_AS_OF_DATE;

-- INSERT A NEW RECORD IF THE UPDATE DID NOT FIND AN EXISTING RECORD
	IF SQL%NOTFOUND THEN
		INSERT INTO LOAD_PROFILE_STATISTICS (
			PROFILE_ID,
			VERSION_ID,
			AS_OF_DATE,
			FROM_DATE,
			TO_DATE,
			PROFILE_COUNT,
			PROFILE_LOAD_FACTOR,
			PROFILE_MIN,
			PROFILE_NZ_MIN,
			PROFILE_MAX,
			PROFILE_SUM,
			PROFILE_MEAN_APE,
			PROFILE_AVG_DEV_APE,
            PROFILE_TOTAL_ERROR_PCT,
			R_SQUARED_MIN,
			R_SQUARED_MAX,
			R_SQUARED_FAIL_PCT,
			T_STAT_TEMP_FAIL_PCT,
			T_STAT_HUMID_FAIL_PCT,
			T_STAT_WIND_FAIL_PCT,
			PROFILE_STATUS,
			ENTRY_DATE)
		VALUES (
			p_PROFILE_ID,
			p_VERSION_ID,
			p_AS_OF_DATE,
			p_FROM_DATE,
			p_TO_DATE,
			p_PROFILE_COUNT,
			p_PROFILE_LOAD_FACTOR,
			p_PROFILE_MIN,
			p_PROFILE_NZ_MIN,
			p_PROFILE_MAX,
			p_PROFILE_SUM,
			p_PROFILE_MEAN_APE,
			p_PROFILE_AVG_DEV_APE,
            p_PROFILE_TOTAL_ERROR_PCT,
			p_R_SQUARED_MIN,
			p_R_SQUARED_MAX,
			p_R_SQUARED_FAIL_PCT,
			p_T_STAT_TEMP_FAIL_PCT,
			p_T_STAT_HUMID_FAIL_PCT,
			p_T_STAT_WIND_FAIL_PCT,
			p_PROFILE_STATUS,
			SYSDATE);
	END IF;

	p_STATUS := GA.SUCCESS;

END PUT_LOAD_PROFILE_STATISTICS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_LOAD_PROFILE_STATISTICS
	(
	p_PROFILE_ID IN NUMBER,
	p_VERSION_ID IN NUMBER,
	p_FROM_DATE OUT DATE,
	p_TO_DATE OUT DATE,
	p_PROFILE_COUNT OUT NUMBER,
	p_PROFILE_LOAD_FACTOR OUT NUMBER,
	p_PROFILE_MIN OUT NUMBER,
	p_PROFILE_NZ_MIN OUT NUMBER,
	p_PROFILE_MAX OUT NUMBER,
	p_PROFILE_SUM OUT NUMBER,
	p_PROFILE_MEAN_APE OUT NUMBER,
	p_PROFILE_AVG_DEV_APE OUT NUMBER,
	p_PROFILE_TOTAL_ERROR_PCT OUT NUMBER,
	p_R_SQUARED_MIN OUT NUMBER,
	p_R_SQUARED_MAX OUT NUMBER,
	p_R_SQUARED_FAIL_PCT OUT NUMBER,
	p_T_STAT_TEMP_FAIL_PCT OUT NUMBER,
	p_T_STAT_HUMID_FAIL_PCT OUT NUMBER,
	p_T_STAT_WIND_FAIL_PCT OUT NUMBER,
	p_PROFILE_STATUS OUT VARCHAR,
	p_STATUS OUT NUMBER
	) AS

-- ANSWER THE SINGLETON INSTANCE OF THE ENTITY IDENTIFIED BY THE SPECIFIED OID
-- ANSWER NULL VALUES IF THE ENTITY CANNOT BE FOUND

v_RECORD LOAD_PROFILE_STATISTICS%ROWTYPE;

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

--SELECT THE EXISTING RECORD
	SELECT *
	INTO v_RECORD
	FROM LOAD_PROFILE_STATISTICS
	WHERE PROFILE_ID = p_PROFILE_ID
		AND VERSION_ID = p_VERSION_ID;

--SET THE OUTPUT PARAMETERS OF THE PROCEDURE
	p_FROM_DATE := v_RECORD.FROM_DATE;
	p_TO_DATE := v_RECORD.TO_DATE;
	p_PROFILE_COUNT := v_RECORD.PROFILE_COUNT;
	p_PROFILE_LOAD_FACTOR := v_RECORD.PROFILE_LOAD_FACTOR;
	p_PROFILE_MIN := v_RECORD.PROFILE_MIN;
	p_PROFILE_NZ_MIN := v_RECORD.PROFILE_NZ_MIN;
	p_PROFILE_MAX := v_RECORD.PROFILE_MAX;
	p_PROFILE_SUM := v_RECORD.PROFILE_SUM;
	p_PROFILE_MEAN_APE := v_RECORD.PROFILE_MEAN_APE;
	p_PROFILE_AVG_DEV_APE := v_RECORD.PROFILE_AVG_DEV_APE;
	p_PROFILE_TOTAL_ERROR_PCT := v_RECORD.PROFILE_TOTAL_ERROR_PCT;
	p_R_SQUARED_MIN := v_RECORD.R_SQUARED_MIN;
	p_R_SQUARED_MAX := v_RECORD.R_SQUARED_MAX;
	p_R_SQUARED_FAIL_PCT := v_RECORD.R_SQUARED_FAIL_PCT;
	p_T_STAT_TEMP_FAIL_PCT := v_RECORD.T_STAT_TEMP_FAIL_PCT;
	p_T_STAT_HUMID_FAIL_PCT := v_RECORD.T_STAT_HUMID_FAIL_PCT;
	p_T_STAT_WIND_FAIL_PCT := v_RECORD.T_STAT_WIND_FAIL_PCT;
	p_PROFILE_STATUS := v_RECORD.PROFILE_STATUS;
	p_STATUS := GA.SUCCESS;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		p_FROM_DATE := SYSDATE;
		p_TO_DATE := SYSDATE;
		p_PROFILE_COUNT := 0;
		p_PROFILE_LOAD_FACTOR := 0;
		p_PROFILE_MIN := 0;
		p_PROFILE_NZ_MIN := 0;
		p_PROFILE_MAX := 0;
		p_PROFILE_SUM := 0;
		p_PROFILE_MEAN_APE := 0;
		p_PROFILE_AVG_DEV_APE := 0;
		p_PROFILE_TOTAL_ERROR_PCT := 0;
		p_R_SQUARED_MIN := 0;
		p_R_SQUARED_MAX := 0;
		p_R_SQUARED_FAIL_PCT := 0;
		p_T_STAT_TEMP_FAIL_PCT := 0;
		p_T_STAT_HUMID_FAIL_PCT := 0;
		p_T_STAT_WIND_FAIL_PCT := 0;
		P_PROFILE_STATUS := GA.EMPTY_STRING;
		p_STATUS := GA.NO_DATA_FOUND;
END GET_LOAD_PROFILE_STATISTICS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_LOAD_PROFILE_WRF_WEATHER
	(
	p_PROFILE_ID IN NUMBER,
	p_PARAMETERS IN GA.ID_TABLE
	) AS

v_INDEX BINARY_INTEGER;
v_VAR_NBR NUMBER := 0;

BEGIN

	DELETE LOAD_PROFILE_WRF_WEATHER
	WHERE PROFILE_ID = p_PROFILE_ID;

	v_INDEX := 	p_PARAMETERS.FIRST;
	WHILE v_INDEX <= p_PARAMETERS.LAST LOOP
		INSERT INTO LOAD_PROFILE_WRF_WEATHER(PROFILE_ID, VARIABLE_NBR, PARAMETER_ID)
		VALUES(p_PROFILE_ID, v_VAR_NBR, p_PARAMETERS(v_INDEX));
		v_INDEX := p_PARAMETERS.NEXT(v_INDEX);
        v_VAR_NBR := v_VAR_NBR+1;
	END LOOP;

END PUT_LOAD_PROFILE_WRF_WEATHER;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_LOAD_PROFILE_WRF
	(
	p_PROFILE_ID IN NUMBER,
	p_WRF_LINE_NBR IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_SEGMENT_MIN IN NUMBER,
	p_SEGMENT_MAX IN NUMBER,
	p_WRF_ID OUT NUMBER
	) AS

BEGIN

	SELECT WRF_ID
	INTO p_WRF_ID
	FROM LOAD_PROFILE_WRF
	WHERE PROFILE_ID = p_PROFILE_ID
		AND WRF_LINE_NBR = p_WRF_LINE_NBR
		AND	AS_OF_DATE = p_AS_OF_DATE;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		SELECT OID.NEXTVAL INTO p_WRF_ID FROM DUAL;
		INSERT INTO LOAD_PROFILE_WRF(
			PROFILE_ID,
			WRF_LINE_NBR,
			AS_OF_DATE,
			SEGMENT_MIN,
			SEGMENT_MAX,
			WRF_ID)
		VALUES(
			p_PROFILE_ID,
			p_WRF_LINE_NBR,
			p_AS_OF_DATE,
			p_SEGMENT_MIN,
			p_SEGMENT_MAX,
			p_WRF_ID);

END PUT_LOAD_PROFILE_WRF;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_LOAD_PROFILE_WRF_LINE
	(
	p_WRF_ID IN NUMBER,
	p_WRF_HOUR IN NUMBER,
	p_COEFF_0 IN NUMBER,
	p_COEFF_1 IN NUMBER,
	p_COEFF_2 IN NUMBER,
	p_R_SQUARED IN NUMBER,
	p_TSTAT_0 IN NUMBER,
	p_TSTAT_1 IN NUMBER,
	p_TSTAT_2 IN NUMBER,
	p_TSTAT_CRITICAL IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	p_STATUS := GA.SUCCESS;

	UPDATE LOAD_PROFILE_WRF_LINE
	SET COEFF_0 = p_COEFF_0,
		COEFF_1 = p_COEFF_1,
		COEFF_2 = p_COEFF_2,
		R_SQUARED = p_R_SQUARED,
		TSTAT_0 = p_TSTAT_0,
		TSTAT_1 = p_TSTAT_1,
		TSTAT_2 = p_TSTAT_2,
		TSTAT_CRITICAL = p_TSTAT_CRITICAL
	WHERE WRF_ID = p_WRF_ID
		AND WRF_HOUR = p_WRF_HOUR;

	IF SQL%NOTFOUND THEN
		INSERT INTO LOAD_PROFILE_WRF_LINE(
			WRF_ID,
			WRF_HOUR,
			COEFF_0,
			COEFF_1,
			COEFF_2,
			R_SQUARED,
			TSTAT_0,
			TSTAT_1,
			TSTAT_2,
			TSTAT_CRITICAL)
		VALUES(
			p_WRF_ID,
			p_WRF_HOUR,
			p_COEFF_0,
			p_COEFF_1,
			p_COEFF_2,
			p_R_SQUARED,
			p_TSTAT_0,
			p_TSTAT_1,
			p_TSTAT_2,
			p_TSTAT_CRITICAL
			);
	END IF;

END PUT_LOAD_PROFILE_WRF_LINE;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_LOAD_PROFILE_WRF_LINE
	(
	p_LOAD_PROFILE_WRF_LINE IN LOAD_PROFILE_WRF_LINE%ROWTYPE
	) AS

BEGIN

	IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
		LOGS.LOG_DEBUG_DETAIL('PUT_LOAD_PROFILE_WRF_LINE');
		LOGS.LOG_DEBUG_DETAIL('WRF_ID=' || TO_CHAR(p_LOAD_PROFILE_WRF_LINE.WRF_ID));
		LOGS.LOG_DEBUG_DETAIL('WRF_HOUR=' || TO_CHAR(p_LOAD_PROFILE_WRF_LINE.WRF_HOUR));
		LOGS.LOG_DEBUG_DETAIL('COEFF_0=' || TO_CHAR(p_LOAD_PROFILE_WRF_LINE.COEFF_0));
		LOGS.LOG_DEBUG_DETAIL('COEFF_1=' || TO_CHAR(p_LOAD_PROFILE_WRF_LINE.COEFF_1));
		LOGS.LOG_DEBUG_DETAIL('COEFF_2=' || TO_CHAR(p_LOAD_PROFILE_WRF_LINE.COEFF_2));
		LOGS.LOG_DEBUG_DETAIL('COEFF_3=' || TO_CHAR(p_LOAD_PROFILE_WRF_LINE.COEFF_3));
		LOGS.LOG_DEBUG_DETAIL('COEFF_4=' || TO_CHAR(p_LOAD_PROFILE_WRF_LINE.COEFF_4));
		LOGS.LOG_DEBUG_DETAIL('COEFF_5=' || TO_CHAR(p_LOAD_PROFILE_WRF_LINE.COEFF_5));
		LOGS.LOG_DEBUG_DETAIL('TSTAT_0=' || TO_CHAR(p_LOAD_PROFILE_WRF_LINE.TSTAT_0));
		LOGS.LOG_DEBUG_DETAIL('TSTAT_1=' || TO_CHAR(p_LOAD_PROFILE_WRF_LINE.TSTAT_1));
		LOGS.LOG_DEBUG_DETAIL('TSTAT_2=' || TO_CHAR(p_LOAD_PROFILE_WRF_LINE.TSTAT_2));
		LOGS.LOG_DEBUG_DETAIL('TSTAT_3=' || TO_CHAR(p_LOAD_PROFILE_WRF_LINE.TSTAT_3));
		LOGS.LOG_DEBUG_DETAIL('TSTAT_4=' || TO_CHAR(p_LOAD_PROFILE_WRF_LINE.TSTAT_4));
		LOGS.LOG_DEBUG_DETAIL('TSTAT_5=' || TO_CHAR(p_LOAD_PROFILE_WRF_LINE.TSTAT_5));
		LOGS.LOG_DEBUG_DETAIL('NUM_VARS=' || TO_CHAR(p_LOAD_PROFILE_WRF_LINE.NUM_VARS));
		LOGS.LOG_DEBUG_DETAIL('R_SQUARED=' || TO_CHAR(p_LOAD_PROFILE_WRF_LINE.R_SQUARED));
		LOGS.LOG_DEBUG_DETAIL('TSTAT_CRITICAL=' || TO_CHAR(p_LOAD_PROFILE_WRF_LINE.TSTAT_CRITICAL));
		LOGS.LOG_DEBUG_DETAIL('SEGMENT_MIN=' || TO_CHAR(p_LOAD_PROFILE_WRF_LINE.SEGMENT_MIN));
		LOGS.LOG_DEBUG_DETAIL('SEGMENT_MAX=' || TO_CHAR(p_LOAD_PROFILE_WRF_LINE.SEGMENT_MAX));
	END IF;

	UPDATE LOAD_PROFILE_WRF_LINE
	SET COEFF_0 = p_LOAD_PROFILE_WRF_LINE.COEFF_0,
		COEFF_1 = p_LOAD_PROFILE_WRF_LINE.COEFF_1,
		COEFF_2 = p_LOAD_PROFILE_WRF_LINE.COEFF_2,
		COEFF_3 = p_LOAD_PROFILE_WRF_LINE.COEFF_3,
		COEFF_4 = p_LOAD_PROFILE_WRF_LINE.COEFF_4,
		COEFF_5 = p_LOAD_PROFILE_WRF_LINE.COEFF_5,
		TSTAT_0 = p_LOAD_PROFILE_WRF_LINE.TSTAT_0,
		TSTAT_1 = p_LOAD_PROFILE_WRF_LINE.TSTAT_1,
		TSTAT_2 = p_LOAD_PROFILE_WRF_LINE.TSTAT_2,
		TSTAT_3 = p_LOAD_PROFILE_WRF_LINE.TSTAT_3,
		TSTAT_4 = p_LOAD_PROFILE_WRF_LINE.TSTAT_4,
		TSTAT_5 = p_LOAD_PROFILE_WRF_LINE.TSTAT_5,
		NUM_VARS = p_LOAD_PROFILE_WRF_LINE.NUM_VARS,
		R_SQUARED = p_LOAD_PROFILE_WRF_LINE.R_SQUARED,
		TSTAT_CRITICAL = p_LOAD_PROFILE_WRF_LINE.TSTAT_CRITICAL,
		SEGMENT_MIN = p_LOAD_PROFILE_WRF_LINE.SEGMENT_MIN,
		SEGMENT_MAX = p_LOAD_PROFILE_WRF_LINE.SEGMENT_MAX
	WHERE WRF_ID = p_LOAD_PROFILE_WRF_LINE.WRF_ID
		AND WRF_HOUR = p_LOAD_PROFILE_WRF_LINE.WRF_HOUR;

	IF SQL%NOTFOUND THEN
		INSERT INTO LOAD_PROFILE_WRF_LINE(
			WRF_ID,
			WRF_HOUR,
			COEFF_0,
			COEFF_1,
			COEFF_2,
			COEFF_3,
			COEFF_4,
			COEFF_5,
			TSTAT_0,
			TSTAT_1,
			TSTAT_2,
			TSTAT_3,
			TSTAT_4,
			TSTAT_5,
			NUM_VARS,
			R_SQUARED,
			TSTAT_CRITICAL,
			SEGMENT_MIN,
			SEGMENT_MAX)
		VALUES (
			p_LOAD_PROFILE_WRF_LINE.WRF_ID,
			p_LOAD_PROFILE_WRF_LINE.WRF_HOUR,
			p_LOAD_PROFILE_WRF_LINE.COEFF_0,
			p_LOAD_PROFILE_WRF_LINE.COEFF_1,
			p_LOAD_PROFILE_WRF_LINE.COEFF_2,
			p_LOAD_PROFILE_WRF_LINE.COEFF_3,
			p_LOAD_PROFILE_WRF_LINE.COEFF_4,
			p_LOAD_PROFILE_WRF_LINE.COEFF_5,
			p_LOAD_PROFILE_WRF_LINE.TSTAT_0,
			p_LOAD_PROFILE_WRF_LINE.TSTAT_1,
			p_LOAD_PROFILE_WRF_LINE.TSTAT_2,
			p_LOAD_PROFILE_WRF_LINE.TSTAT_3,
			p_LOAD_PROFILE_WRF_LINE.TSTAT_4,
			p_LOAD_PROFILE_WRF_LINE.TSTAT_5,
			p_LOAD_PROFILE_WRF_LINE.NUM_VARS,
			p_LOAD_PROFILE_WRF_LINE.R_SQUARED,
			p_LOAD_PROFILE_WRF_LINE.TSTAT_CRITICAL,
			p_LOAD_PROFILE_WRF_LINE.SEGMENT_MIN,
			p_LOAD_PROFILE_WRF_LINE.SEGMENT_MAX);
	END IF;

END PUT_LOAD_PROFILE_WRF_LINE;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_LOAD_PROFILE_WRF_DATA
	(
	p_PROFILE_ID IN NUMBER,
	p_WRF_SEGMENT_NBR IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_WRF_SEGMENT_VALUES IN VARCHAR,
	p_WRF_MIN IN NUMBER,
	p_WRF_MAX IN NUMBER,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

--Save WRF data from GUI Regression

v_HOUR_TABLE GA.STRING_TABLE;
v_ITEM_TABLE GA.STRING_TABLE;
v_PARAM_TABLE GA.STRING_TABLE;
v_COEFF_TSTAT_TABLE GA.STRING_TABLE;
v_WRF_ID NUMBER;
v_HOUR_INDEX BINARY_INTEGER;
v_PARAM_INDEX BINARY_INTEGER;
v_LOAD_PROFILE_WRF_LINE  LOAD_PROFILE_WRF_LINE%ROWTYPE;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	--Parse p_WRF_SEGMENT_VALUES as "Wrf_Hour:R2:TCrit:coeff0~tstat0,coeff1~tstat1,coeff2~tstat2,coeff3~tstat3,coeff4~tstat4,coeff5~tstat5 | ... repeat ..."
	UT.TOKENS_FROM_STRING(p_WRF_SEGMENT_VALUES,'|', v_HOUR_TABLE);
	v_HOUR_INDEX := v_HOUR_TABLE.FIRST;

	PUT_LOAD_PROFILE_WRF(p_PROFILE_ID, p_WRF_SEGMENT_NBR, p_AS_OF_DATE, p_WRF_MIN, p_WRF_MAX, v_WRF_ID);

	LOOP
		UT.TOKENS_FROM_STRING(v_HOUR_TABLE(v_HOUR_INDEX),':', v_ITEM_TABLE);
		v_LOAD_PROFILE_WRF_LINE.WRF_ID := v_WRF_ID;
		v_LOAD_PROFILE_WRF_LINE.WRF_HOUR := TO_NUMBER(v_ITEM_TABLE(1)); -- WRF_HOUR.
		v_LOAD_PROFILE_WRF_LINE.R_SQUARED := TO_NUMBER(v_ITEM_TABLE(2)); -- R_SQUARED.
		v_LOAD_PROFILE_WRF_LINE.TSTAT_CRITICAL := TO_NUMBER(v_ITEM_TABLE(3)); -- TSTAT_CRITICAL.
        v_LOAD_PROFILE_WRF_LINE.SEGMENT_MIN := p_WRF_MIN;  -- This is daily breakpoint, but needed in LOAD_PROFILE_WRF_LINE for support of hourly breakpoints
        v_LOAD_PROFILE_WRF_LINE.SEGMENT_MAX := p_WRF_MAX;  -- This is daily breakpoint, but needed in LOAD_PROFILE_WRF_LINE for support of hourly breakpoints

		UT.TOKENS_FROM_STRING(v_ITEM_TABLE(4),',', v_PARAM_TABLE); -- PARAM table.
		v_PARAM_INDEX := v_PARAM_TABLE.FIRST;
		LOOP
			UT.TOKENS_FROM_STRING(v_PARAM_TABLE(v_PARAM_INDEX),'~', v_COEFF_TSTAT_TABLE); -- COEFF,TSTAT table.
			IF v_PARAM_INDEX = 1 THEN
				v_LOAD_PROFILE_WRF_LINE.COEFF_0 := TO_NUMBER(v_COEFF_TSTAT_TABLE(1)); -- COEFF.
				v_LOAD_PROFILE_WRF_LINE.TSTAT_0 := TO_NUMBER(v_COEFF_TSTAT_TABLE(2)); -- TSTAT.
			ELSIF v_PARAM_INDEX = 2 THEN
				v_LOAD_PROFILE_WRF_LINE.COEFF_1 := TO_NUMBER(v_COEFF_TSTAT_TABLE(1)); -- COEFF.
				v_LOAD_PROFILE_WRF_LINE.TSTAT_1 := TO_NUMBER(v_COEFF_TSTAT_TABLE(2)); -- TSTAT.
			ELSIF v_PARAM_INDEX = 3 THEN
				v_LOAD_PROFILE_WRF_LINE.COEFF_2 := TO_NUMBER(v_COEFF_TSTAT_TABLE(1)); -- COEFF.
				v_LOAD_PROFILE_WRF_LINE.TSTAT_2 := TO_NUMBER(v_COEFF_TSTAT_TABLE(2)); -- TSTAT.
			ELSIF v_PARAM_INDEX = 4 THEN
				v_LOAD_PROFILE_WRF_LINE.COEFF_3 := TO_NUMBER(v_COEFF_TSTAT_TABLE(1)); -- COEFF.
				v_LOAD_PROFILE_WRF_LINE.TSTAT_3 := TO_NUMBER(v_COEFF_TSTAT_TABLE(2)); -- TSTAT.
			ELSIF v_PARAM_INDEX = 5 THEN
				v_LOAD_PROFILE_WRF_LINE.COEFF_4 := TO_NUMBER(v_COEFF_TSTAT_TABLE(1)); -- COEFF.
				v_LOAD_PROFILE_WRF_LINE.TSTAT_4 := TO_NUMBER(v_COEFF_TSTAT_TABLE(2)); -- TSTAT.
			ELSIF v_PARAM_INDEX = 6 THEN
				v_LOAD_PROFILE_WRF_LINE.COEFF_5 := TO_NUMBER(v_COEFF_TSTAT_TABLE(1)); -- COEFF.
				v_LOAD_PROFILE_WRF_LINE.TSTAT_5 := TO_NUMBER(v_COEFF_TSTAT_TABLE(2)); -- TSTAT.
			END IF;
			EXIT WHEN v_PARAM_INDEX = v_PARAM_TABLE.LAST;
			v_PARAM_INDEX := v_PARAM_TABLE.NEXT(v_PARAM_INDEX);
		END LOOP;

		PUT_LOAD_PROFILE_WRF_LINE(v_LOAD_PROFILE_WRF_LINE);

		IF p_STATUS < GA.SUCCESS THEN
			IF g_ALLOW_COMMIT_ROLLBACK THEN ROLLBACK; END IF;
			RETURN;
		END IF;

		EXIT WHEN v_HOUR_INDEX = v_HOUR_TABLE.LAST;
		v_HOUR_INDEX := v_HOUR_TABLE.NEXT(v_HOUR_INDEX);
	END LOOP;

	IF g_ALLOW_COMMIT_ROLLBACK THEN COMMIT; END IF;

END PUT_LOAD_PROFILE_WRF_DATA;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_LOAD_PROFILE_WRF_SEGMENT
	(
	p_PROFILE_ID IN NUMBER,
	p_WRF_LINE_NBR IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_WRF_TEMP_MIN IN NUMBER,
	p_WRF_TEMP_MAX IN NUMBER,
	p_WRF_LINE_VALUES IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_STRING_TABLE GA.STRING_TABLE;
v_LINE_TABLE GA.STRING_TABLE;
v_WRF_ID NUMBER;
v_INDEX BINARY_INTEGER;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	UT.TOKENS_FROM_STRING(p_WRF_LINE_VALUES,';', v_STRING_TABLE);
	v_INDEX := v_STRING_TABLE.FIRST;

	PUT_LOAD_PROFILE_WRF(p_PROFILE_ID, p_WRF_LINE_NBR, p_AS_OF_DATE, p_WRF_TEMP_MIN, p_WRF_TEMP_MAX, v_WRF_ID);

	LOOP
		UT.TOKENS_FROM_STRING(v_STRING_TABLE(v_INDEX),',', v_LINE_TABLE);
		PUT_LOAD_PROFILE_WRF_LINE(
			v_WRF_ID,
			TO_NUMBER(v_LINE_TABLE(1)), -- WRF_HOUR.
			TO_NUMBER(v_LINE_TABLE(2)), -- COEFF_0.
			TO_NUMBER(v_LINE_TABLE(3)), -- COEFF_1.
			TO_NUMBER(v_LINE_TABLE(4)), -- COEFF_2.
			TO_NUMBER(v_LINE_TABLE(5)), -- R_SQUARED.
			TO_NUMBER(v_LINE_TABLE(6)), -- TSTAT_0.
			TO_NUMBER(v_LINE_TABLE(7)), -- TSTAT_1.
			TO_NUMBER(v_LINE_TABLE(8)), -- TSTAT_2.
			TO_NUMBER(v_LINE_TABLE(9)), -- TSTAT_CRITICAL.
			p_STATUS);

		IF p_STATUS < GA.SUCCESS THEN
			IF g_ALLOW_COMMIT_ROLLBACK THEN ROLLBACK; END IF;
			RETURN;
		END IF;

		EXIT WHEN v_INDEX = v_STRING_TABLE.LAST;
		v_INDEX := v_STRING_TABLE.NEXT(v_INDEX);
	END LOOP;

	IF g_ALLOW_COMMIT_ROLLBACK THEN COMMIT; END IF;

END PUT_LOAD_PROFILE_WRF_SEGMENT;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_WEATHER_PARAMETERS
	(
	p_PROFILE_ID IN NUMBER,
	p_VARIABLE_NBR IN NUMBER,
	p_PARAMETER_ID IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	p_STATUS := GA.SUCCESS;

		INSERT INTO LOAD_PROFILE_WRF_WEATHER(
			PROFILE_ID,
			VARIABLE_NBR,
			PARAMETER_ID)
		VALUES(
			p_PROFILE_ID,
			p_VARIABLE_NBR,
			p_PARAMETER_ID);

END PUT_WEATHER_PARAMETERS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_HISTORICAL_PROFILE_STATS
	(
	p_PROFILE_ID IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS

v_FROM_DATE DATE;
v_TO_DATE DATE;
v_PROFILE_MIN NUMBER;
v_PROFILE_MAX NUMBER;
v_PROFILE_SUM NUMBER;
v_PROFILE_COUNT NUMBER;
v_VERSION_ID NUMBER;
v_PROFILE_NZ_MIN NUMBER := 999999999;
v_INTERVALS_PER_DAY NUMBER;
v_PROFILE_TYPE LOAD_PROFILE.PROFILE_TYPE%TYPE;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	SELECT PROFILE_INTERVAL, PROFILE_TYPE
	INTO v_INTERVALS_PER_DAY, v_PROFILE_TYPE
	FROM LOAD_PROFILE
	WHERE PROFILE_ID = p_PROFILE_ID;

	-- FROM and TO dates should be TRUNC'd to the day from CUT STD-time dates, aligned to get midnite into the proper day
	SELECT TRUNC(FROM_CUT(ALIGN_DATE_BY_INTERVAL(MIN(POINT_DATE),v_INTERVALS_PER_DAY),STD_TIME_ZONE(LOCAL_TIME_ZONE))),
		TRUNC(FROM_CUT(ALIGN_DATE_BY_INTERVAL(MAX(POINT_DATE),v_INTERVALS_PER_DAY),STD_TIME_ZONE(LOCAL_TIME_ZONE))),
		MIN(POINT_VAL),
		MIN(CASE WHEN POINT_VAL = 0 THEN NULL ELSE POINT_VAL END),
		MAX(POINT_VAL),
		SUM(POINT_VAL),
		COUNT(1)
	INTO v_FROM_DATE, v_TO_DATE, v_PROFILE_MIN, v_PROFILE_NZ_MIN, v_PROFILE_MAX, v_PROFILE_SUM, v_PROFILE_COUNT
	FROM LOAD_PROFILE_POINT
	WHERE PROFILE_ID = p_PROFILE_ID
		AND POINT_INDEX = 1
		AND POINT_DATE = POINT_DATE
		AND AS_OF_DATE = p_AS_OF_DATE;

	IF UPPER(v_PROFILE_TYPE) = 'HISTORICAL' THEN
		-- in addition to setting info on statistics table, set source begin and end dates to match actual data present
		UPDATE LOAD_PROFILE
		SET PROFILE_SOURCE_BEGIN_DATE = v_FROM_DATE,
			PROFILE_SOURCE_END_DATE = v_TO_DATE
		WHERE PROFILE_ID = p_PROFILE_ID;
	END IF;

	UPDATE LOAD_PROFILE_STATISTICS SET
		FROM_DATE = v_FROM_DATE,
		TO_DATE = v_TO_DATE,
		PROFILE_COUNT = v_PROFILE_COUNT,
		PROFILE_MIN = v_PROFILE_MIN,
		PROFILE_NZ_MIN = DECODE(v_PROFILE_NZ_MIN,999999999,0,v_PROFILE_NZ_MIN),
		PROFILE_MAX = v_PROFILE_MAX,
		PROFILE_SUM = v_PROFILE_SUM,
		ENTRY_DATE = SYSDATE
	WHERE PROFILE_ID = p_PROFILE_ID
		AND AS_OF_DATE = p_AS_OF_DATE;

	IF SQL%NOTFOUND THEN
		v_VERSION_ID := GET_PROFILE_VERSION_ID(p_AS_OF_DATE);
		INSERT INTO LOAD_PROFILE_STATISTICS (
			PROFILE_ID,
			AS_OF_DATE,
	   		FROM_DATE,
			TO_DATE,
			PROFILE_COUNT,
			PROFILE_LOAD_FACTOR,
			PROFILE_MIN,
			PROFILE_NZ_MIN,
			PROFILE_MAX,
			PROFILE_SUM,
			PROFILE_MEAN_APE,
			PROFILE_AVG_DEV_APE,
			PROFILE_TOTAL_ERROR_PCT,
			R_SQUARED_MIN,
			R_SQUARED_MAX,
			R_SQUARED_FAIL_PCT,
			T_STAT_TEMP_FAIL_PCT,
			T_STAT_HUMID_FAIL_PCT,
			T_STAT_WIND_FAIL_PCT,
			PROFILE_STATUS,
			VERSION_ID,
			ENTRY_DATE)
		VALUES (
			p_PROFILE_ID,
			p_AS_OF_DATE,
   			v_FROM_DATE,
			v_TO_DATE,
			v_PROFILE_COUNT,
			0, -- PROFILE_LOAD_FACTOR,
			v_PROFILE_MIN,
			DECODE(v_PROFILE_NZ_MIN,999999999,0,v_PROFILE_NZ_MIN), -- PROFILE_NZ_MIN,
			v_PROFILE_MAX,
			v_PROFILE_SUM,
			0, -- PROFILE_MEAN_APE,
			0, -- PROFILE_AVG_DEV_APE,
			0, -- PROFILE_TOTAL_ERROR_PCT,
			0, -- R_SQUARED_MIN,
			0, -- R_SQUARED_MAX,
			0, -- R_SQUARED_FAIL_PCT,
			0, -- T_STAT_TEMP_FAIL_PCT,
			0, -- T_STAT_HUMID_FAIL_PCT,
			0, -- T_STAT_WIND_FAIL_PCT,
			'Pending', -- PROFILE_STATUS
			v_VERSION_ID,
			SYSDATE);
		END IF;


END PUT_HISTORICAL_PROFILE_STATS;
----------------------------------------------------------------------------------------------------
PROCEDURE APPEND_TO_HISTORICAL_PROFILE
	(
	p_PROFILE_LIBRARY_NAME IN VARCHAR,
	p_PROFILE_NAME IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_VERSION_ID IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_POINT_VALUES IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_POINT_DATE DATE;
v_POINT_VAL LOAD_PROFILE_POINT.POINT_VAL%TYPE;
v_STRING_TABLE GA.STRING_TABLE;
v_INDEX BINARY_INTEGER;
v_PROFILE_TYPE CHAR(1);
v_PROFILE_ID NUMBER;
v_POINT_INDEX NUMBER := 1;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	ID.ID_FOR_LOAD_PROFILE(p_PROFILE_LIBRARY_NAME, p_PROFILE_NAME, FALSE, v_PROFILE_ID);
	IF v_PROFILE_ID < 0 THEN
		p_STATUS := -100;
		RETURN;
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.TOKENS_FROM_STRING(p_POINT_VALUES, g_DELIMITER, v_STRING_TABLE);
	v_INDEX := v_STRING_TABLE.FIRST;

	SELECT  UPPER(SUBSTR(PROFILE_TYPE,1,1))
	INTO  v_PROFILE_TYPE
	FROM LOAD_PROFILE
	WHERE PROFILE_ID = v_PROFILE_ID;
	IF v_PROFILE_TYPE = 'H' THEN
		v_POINT_DATE := BEGIN_HOUR_ENDING_CUT_DAY(p_BEGIN_DATE, STD_TIME_ZONE(p_TIME_ZONE));
	ELSE
		p_STATUS := -110;
		RETURN;
	END IF;

	LOOP
 		v_POINT_VAL := TO_NUMBER(v_STRING_TABLE(v_INDEX));
		PUT_LOAD_PROFILE_POINT(
			v_PROFILE_ID,
			v_POINT_INDEX,
			v_POINT_DATE,
			p_AS_OF_DATE,
			v_POINT_VAL,
			p_STATUS);
		IF NOT p_STATUS = GA.SUCCESS THEN
			IF g_ALLOW_COMMIT_ROLLBACK THEN ROLLBACK; END IF;
			RETURN;
		END IF;

		EXIT WHEN v_INDEX = v_STRING_TABLE.LAST;
		v_INDEX := v_STRING_TABLE.NEXT(v_INDEX);
		v_POINT_DATE := ADD_MINUTES_TO_DATE(v_POINT_DATE, 60);

	END LOOP;

	PUT_HISTORICAL_PROFILE_STATS(v_PROFILE_ID, p_AS_OF_DATE, p_STATUS);

END APPEND_TO_HISTORICAL_PROFILE;
----------------------------------------------------------------------------------------------------
FUNCTION MAKE_DATE
	(
	p_MONTH_AND_DAY_DATE IN DATE,
	p_YEAR_DATE IN DATE
	) RETURN DATE IS

v_DATE DATE;

BEGIN

	BEGIN
		v_DATE := TO_DATE(TO_CHAR(p_MONTH_AND_DAY_DATE,'MMDD') || TO_CHAR(p_YEAR_DATE, 'YYYY'), 'MMDDYYYY');
	EXCEPTION
		WHEN ERRS.e_INVALID_DATE THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			v_DATE := TO_DATE(TO_CHAR(p_MONTH_AND_DAY_DATE - 1,'MMDD') || TO_CHAR(p_YEAR_DATE, 'YYYY'), 'MMDDYYYY');
			END;

	RETURN v_DATE;

END MAKE_DATE;
----------------------------------------------------------------------------------------------------
FUNCTION PROFILE_LIBRARY_FIRST_ASSIGN
	(
	p_PROFILE_LIBRARY_ID IN NUMBER
	) RETURN DATE IS

v_SYSDATE DATE := SYSDATE;
v_SEASON_DATE DATE;
v_ASSIGN_DATE DATE := HIGH_DATE;

CURSOR c_ASSIGN IS
	SELECT DISTINCT C.BEGIN_DATE "BEGIN_DATE"
	FROM LOAD_PROFILE A,
		TEMPLATE_SEASON_DAY_NAME TSDN,
		SEASON C
	WHERE A.PROFILE_LIBRARY_ID = p_PROFILE_LIBRARY_ID
		AND TSDN.TEMPLATE_ID = A.PROFILE_TEMPLATE_ID
		AND C.SEASON_ID = TSDN.SEASON_ID
	ORDER BY BEGIN_DATE;

BEGIN

	FOR v_ASSIGN IN c_ASSIGN LOOP
		v_SEASON_DATE := MAKE_DATE(v_ASSIGN.BEGIN_DATE, v_SYSDATE);
		IF v_SEASON_DATE < v_SYSDATE THEN
			v_SEASON_DATE := MAKE_DATE(v_ASSIGN.BEGIN_DATE, ADD_MONTHS(v_SYSDATE, 12));
		END IF;
		IF v_SEASON_DATE < v_ASSIGN_DATE THEN
			v_ASSIGN_DATE := v_SEASON_DATE;
		END IF;
	END LOOP;

	IF v_ASSIGN_DATE = HIGH_DATE THEN
		v_ASSIGN_DATE := LOW_DATE;
	END IF;

	RETURN v_ASSIGN_DATE;

END PROFILE_LIBRARY_FIRST_ASSIGN;
----------------------------------------------------------------------------------------------------
FUNCTION PROFILE_LIBRARY_CHECK_SUM
	(
	p_PROFILE_LIBRARY_ID IN NUMBER
	) RETURN NUMBER IS

-- Check the wrf profiles in a library for the existence of zero coefficients.

v_SYSDATE DATE := SYSDATE;
v_CHECK_SUM NUMBER := 0;
v_CHECK_COUNT NUMBER := 0;

CURSOR c_WRF_CHECK IS
	SELECT COUNT(*) "CHECK_COUNT",
		SUM(COEFF_0 + COEFF_1 + COEFF_2) "CHECK_SUM"
	FROM LOAD_PROFILE A, LOAD_PROFILE_WRF B, LOAD_PROFILE_WRF_LINE C
	WHERE A.PROFILE_LIBRARY_ID = p_PROFILE_LIBRARY_ID
		AND B.PROFILE_ID = A.PROFILE_ID
		AND B.WRF_LINE_NBR = B.WRF_LINE_NBR
		AND B.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM LOAD_PROFILE_WRF
			WHERE PROFILE_ID = B.PROFILE_ID
				AND WRF_LINE_NBR = B.WRF_LINE_NBR
				AND AS_OF_DATE <= v_SYSDATE)
		AND C.WRF_ID = B.WRF_ID;

CURSOR c_POINT_CHECK IS
	SELECT SUM(POINT_VAL) "CHECK_SUM"
	FROM LOAD_PROFILE A, LOAD_PROFILE_POINT B
	WHERE A.PROFILE_LIBRARY_ID = p_PROFILE_LIBRARY_ID
		AND B.PROFILE_ID = A.PROFILE_ID
		AND B.POINT_INDEX = B.POINT_INDEX
		AND B.POINT_DATE = B.POINT_DATE
		AND B.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM LOAD_PROFILE_POINT
			WHERE PROFILE_ID = B.PROFILE_ID
				AND POINT_INDEX = B.POINT_INDEX
				AND POINT_DATE = B.POINT_DATE
				AND AS_OF_DATE <= v_SYSDATE);

BEGIN

	FOR v_WRF_CHECK IN c_WRF_CHECK LOOP
		v_CHECK_COUNT := v_WRF_CHECK.CHECK_COUNT;
		v_CHECK_SUM := v_WRF_CHECK.CHECK_SUM;
	END LOOP;

	IF v_CHECK_COUNT = 0 THEN
		FOR v_POINT_CHECK IN c_POINT_CHECK LOOP
			v_CHECK_SUM := v_POINT_CHECK.CHECK_SUM;
		END LOOP;
	END IF;

	RETURN 	v_CHECK_SUM;

END PROFILE_LIBRARY_CHECK_SUM;
----------------------------------------------------------------------------------------------------
FUNCTION ALLOW_USAGE_FACTOR_TERMINATION RETURN BOOLEAN IS
BEGIN
	RETURN UT.BOOLEAN_FROM_STRING(NVL(GET_DICTIONARY_VALUE('Enable Usage Factor Termination',0,'Profiling','General'),'1'));
END ALLOW_USAGE_FACTOR_TERMINATION;
----------------------------------------------------------------------------------------------------
PROCEDURE ASSIGN_METER_CALENDAR
	(
	p_PROFILE_LIBRARY_ID IN NUMBER,
	p_CALENDAR_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_TERMINATE_USAGE_FACTOR IN BOOLEAN
	) AS

-- Create the METER assignment to a calendar.
-- If the METER id is not null; assign the METER to the calendar.

v_BEGIN_DATE DATE;
v_FACTOR_END_DATE DATE;

BEGIN

	IF p_METER_ID IS NOT NULL THEN
		v_BEGIN_DATE := PROFILE_LIBRARY_FIRST_ASSIGN(p_PROFILE_LIBRARY_ID);

		UT.PUT_TEMPORAL_DATA('METER_CALENDAR',
			v_BEGIN_DATE,
			NULL,
			TRUE,
			TRUE,
			'CASE_ID',
			UT.GET_LITERAL_FOR_NUMBER(GA.BASE_CASE_ID),
			TRUE,
			'METER_ID',
			UT.GET_LITERAL_FOR_NUMBER(p_METER_ID),
			TRUE,
			'CALENDAR_TYPE',
			UT.GET_LITERAL_FOR_STRING('Forecast'),
			TRUE,
			'CALENDAR_ID',
			UT.GET_LITERAL_FOR_NUMBER(p_CALENDAR_ID),
			FALSE);

		IF p_TERMINATE_USAGE_FACTOR AND ALLOW_USAGE_FACTOR_TERMINATION() THEN
			v_FACTOR_END_DATE := CASE v_BEGIN_DATE WHEN CONSTANTS.LOW_DATE THEN v_BEGIN_DATE ELSE v_BEGIN_DATE - 1 END;
			ENTITY_UTIL.TERMINATE_USAGE_FACTOR(EC.ED_METER, p_METER_ID, v_FACTOR_END_DATE);
		END IF;
	END IF;

END ASSIGN_METER_CALENDAR;
----------------------------------------------------------------------------------------------------
PROCEDURE ASSIGN_ACCOUNT_CALENDAR
	(
	p_PROFILE_LIBRARY_ID IN NUMBER,
	p_CALENDAR_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_TERMINATE_USAGE_FACTOR IN BOOLEAN
	) AS

-- Create the account assignment to a calendar.
-- If the account id is not null; assign the account to the calendar.

v_BEGIN_DATE DATE;
v_FACTOR_END_DATE DATE;
BEGIN

	IF p_ACCOUNT_ID IS NOT NULL THEN
		IF g_ACCT_CALENDAR_BEGIN_DATE IS NOT NULL THEN
            v_BEGIN_DATE := g_ACCT_CALENDAR_BEGIN_DATE;
        ELSE
    		v_BEGIN_DATE := PROFILE_LIBRARY_FIRST_ASSIGN(p_PROFILE_LIBRARY_ID);
		END IF;

		UT.PUT_TEMPORAL_DATA('ACCOUNT_CALENDAR',
				v_BEGIN_DATE,
				NULL,
				TRUE,
				TRUE,
				'CASE_ID',
				UT.GET_LITERAL_FOR_NUMBER(GA.BASE_CASE_ID),
				TRUE,
				'ACCOUNT_ID',
				UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
				TRUE,
				'CALENDAR_TYPE',
				UT.GET_LITERAL_FOR_STRING('Forecast'),
				TRUE,
				'CALENDAR_ID',
				UT.GET_LITERAL_FOR_NUMBER(p_CALENDAR_ID),
				FALSE);

		IF p_TERMINATE_USAGE_FACTOR AND ALLOW_USAGE_FACTOR_TERMINATION() THEN
			v_FACTOR_END_DATE := CASE v_BEGIN_DATE WHEN CONSTANTS.LOW_DATE THEN v_BEGIN_DATE ELSE v_BEGIN_DATE - 1 END;
			ENTITY_UTIL.TERMINATE_USAGE_FACTOR(EC.ED_ACCOUNT, p_ACCOUNT_ID, v_FACTOR_END_DATE);
		END IF;
	END IF;

END ASSIGN_ACCOUNT_CALENDAR;
----------------------------------------------------------------------------------------------------
PROCEDURE ASSIGN_LIBRARY_TO_CALENDAR
	(
	p_PROFILE_LIBRARY_NAME IN VARCHAR,
	p_CALENDAR_NAME IN VARCHAR,
	p_ACCOUNT_ID IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

-- Create the load profile library assignment to a calendar.
-- If the account id is not null; assign the account to the calendar.

v_PROFILE_LIBRARY_ID NUMBER;
v_CALENDAR_ID NUMBER;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	ID.ID_FOR_LOAD_PROFILE_LIBRARY(p_PROFILE_LIBRARY_NAME, TRUE, v_PROFILE_LIBRARY_ID);
	IF v_PROFILE_LIBRARY_ID < 0 THEN
		p_STATUS := -100;
		RETURN;
	END IF;

	IF PROFILE_LIBRARY_CHECK_SUM(v_PROFILE_LIBRARY_ID) = 0 THEN
		p_STATUS := -105;
		RETURN;
	END IF;

	ID.ID_FOR_CALENDAR(p_CALENDAR_NAME, v_CALENDAR_ID);
	IF v_PROFILE_LIBRARY_ID < 0 THEN
		p_STATUS := -110;
		RETURN;
	END IF;

	p_STATUS := GA.SUCCESS;
	CA.PUT_CALENDAR_PROFILE_LIBRARY(
		v_CALENDAR_ID,
		v_PROFILE_LIBRARY_ID,
		LOW_DATE,
		NULL,
		v_PROFILE_LIBRARY_ID,
		LOW_DATE,
		p_STATUS);

	IF p_STATUS < 0 THEN
			IF g_ALLOW_COMMIT_ROLLBACK THEN ROLLBACK; END IF;
		RETURN;
	END IF;

	IF p_ACCOUNT_ID IS NOT NULL THEN
		ASSIGN_ACCOUNT_CALENDAR(v_PROFILE_LIBRARY_ID,v_CALENDAR_ID,p_ACCOUNT_ID,FALSE);
	END IF;

END ASSIGN_LIBRARY_TO_CALENDAR;
----------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNT_FORECAST
	(
	p_MODEL_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the energy forecast for the specified
-- account over the time interval.

v_SERVICE_LOCATION_ID NUMBER;
v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	v_SERVICE_LOCATION_ID := GET_SERVICE_LOCATION_ID(p_ACCOUNT_ID,	p_BEGIN_DATE);

	OPEN p_CURSOR FOR
		SELECT FROM_CUT(C.LOAD_DATE, p_TIME_ZONE), C.LOAD_VAL + C.TX_LOSS_VAL + C.DX_LOSS_VAL + C.UE_LOSS_VAL
		FROM ACCOUNT_SERVICE A,
			SERVICE B,
			SERVICE_LOAD C
		WHERE A.ACCOUNT_ID = p_ACCOUNT_ID
			AND A.SERVICE_LOCATION_ID = v_SERVICE_LOCATION_ID
			AND A.METER_ID = 0
			AND A.AGGREGATE_ID = 0
			AND B.MODEL_ID = p_MODEL_ID
			AND B.SCENARIO_ID = GA.BASE_SCENARIO_ID
			AND B.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM SERVICE
				WHERE MODEL_ID = B.MODEL_ID
					AND SCENARIO_ID = B.SCENARIO_ID
					AND AS_OF_DATE <= p_AS_OF_DATE
					AND PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
					AND ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
					AND SERVICE_DELIVERY_ID = B.SERVICE_DELIVERY_ID)
			AND B.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
			AND C.SERVICE_ID = C.SERVICE_ID
			AND C.SERVICE_CODE = GA.FORECAST_SERVICE
			AND C.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND C.LOAD_CODE = GA.STANDARD
		ORDER BY 1;


END ACCOUNT_FORECAST;
---------------------------------------------------------------------------------------------------
PROCEDURE EXPORT_TYPICAL_DAY
	(
	p_LIBRARY_ID IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Create recordset for Exporting Typical Day Profiles.

BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	OPEN p_CURSOR FOR
	   SELECT lpl.PROFILE_LIBRARY_NAME "Library", lp.PROFILE_SEASON "Season DayType",
	   		  SUBSTR(TO_HED(FROM_CUT(lpp.POINT_DATE,p_TIME_ZONE)),12,2) "Hour",
			  lpp.POINT_VAL "Value"
	   FROM LOAD_PROFILE lp,
	   		LOAD_PROFILE_POINT lpp,
			LOAD_PROFILE_LIBRARY lpl
	   WHERE lp.PROFILE_ID = lpp.PROFILE_ID
		AND lp.PROFILE_LIBRARY_ID =lpl.PROFILE_LIBRARY_ID
		AND lpl.PROFILE_LIBRARY_ID  = p_LIBRARY_ID
		AND lpp.AS_OF_DATE = PROFILE_POINT_AS_OF_DATE(lpp.PROFILE_ID, lpp.POINT_INDEX, lpp.POINT_DATE, p_AS_OF_DATE);
	p_STATUS := GA.Success;


END EXPORT_TYPICAL_DAY;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_SAMPLE_INTERVAL_USAGE
	(
	p_SAMPLE_NAME IN VARCHAR,
	p_METER_NUMBER IN VARCHAR,
	p_ACCOUNT_NUMBER IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer interval usage for the specified sample over the specified time interval.

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	XS.GET_SAMPLE_INTERVAL_USAGE(p_SAMPLE_NAME, p_METER_NUMBER, p_ACCOUNT_NUMBER,
		p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE, p_INTERVAL, p_STATUS, p_CURSOR);

END GET_SAMPLE_INTERVAL_USAGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PROFILE_MONITOR_REQUEST
	(
	p_REQUEST_TYPE IN VARCHAR,
	p_ACCOUNT_IDS IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PROFILE_AS_OF_DATE IN DATE,
	p_USAGE_AS_OF_DATE IN DATE,
	p_MONDAY IN NUMBER,
	p_TUESDAY IN NUMBER,
	p_WEDNESDAY IN NUMBER,
	p_THURSDAY IN NUMBER,
	p_FRIDAY IN NUMBER,
	p_SATURDAY IN NUMBER,
	p_SUNDAY IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer interval usage for the specified sample over the specified time interval.

v_DAY_SELECTION CHAR(7);
v_CALENDAR_TYPE CHAR(1);

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	SELECT DECODE(p_MONDAY,1,'1','0') || DECODE(p_TUESDAY,1,'2','0') || DECODE(p_WEDNESDAY,1,'3','0') || DECODE(p_THURSDAY,1,'4','0') ||
		DECODE(p_FRIDAY,1,'5','0') || DECODE(p_SATURDAY,1,'6','0') || DECODE(p_SUNDAY,1,'7','0') INTO v_DAY_SELECTION FROM DUAL;
	IF UPPER(SUBSTR(p_REQUEST_TYPE,1,1)) = 'S' THEN
		OPEN p_CURSOR FOR
			SELECT B.ACCOUNT_NAME,
				A.ACCOUNT_ID "ACCOUNT_ID_NO_SHOW",
				MIN(A.MONITOR_MAPE) "MINIMUM_MAPE",
				MAX(A.MONITOR_MAPE) "MAXIMUM_MAPE",
				AVG(A.MONITOR_MAPE) "AVERAGE_MAPE"
			FROM PROFILE_MONITOR A,
				ACCOUNT B
			WHERE A.ACCOUNT_ID = IN_CANDIDATE_LIST(A.ACCOUNT_ID, p_ACCOUNT_IDS)
				AND A.METER_ID = 0
				AND A.MONITOR_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
				AND INSTR(v_DAY_SELECTION, TO_CHAR(A.MONITOR_DATE, 'D')) > 0
				AND B.ACCOUNT_ID = A.ACCOUNT_ID
			GROUP BY B.ACCOUNT_NAME, A.ACCOUNT_ID
			ORDER BY 1;
	ELSE
		SELECT DECODE(UPPER(SUBSTR(p_REQUEST_TYPE,1,1)),'F','S','A','M','?') INTO v_CALENDAR_TYPE FROM DUAL;
		FS.MONITOR_PROFILE_REQUEST(v_CALENDAR_TYPE, TO_NUMBER(p_ACCOUNT_IDS), 0, p_BEGIN_DATE, p_END_DATE, p_PROFILE_AS_OF_DATE, p_USAGE_AS_OF_DATE, v_DAY_SELECTION, p_STATUS, p_CURSOR);
	END IF;


END PROFILE_MONITOR_REQUEST;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_LOAD_PROFILE_BY_LIBRARY
	(
	p_LIBRARY_ID IN NUMBER,
	p_VERSION_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

--Modified 7/26/04 wjc - Add MAPE and Total Error % columns to cursor.
           -- 7/27/04 wjc - Total Error % gets its own col at 3.0

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	   SELECT A.PROFILE_NAME,
	   		  A.PROFILE_TYPE,
	   		  A.PROFILE_ID,
	   		  B.FROM_DATE PROFILE_SOURCE_BEGIN_DATE,
	   		  B.TO_DATE PROFILE_SOURCE_END_DATE,
	   		  A.PROFILE_ALIAS,
	   		  A.PROFILE_DESC,
	   		  B.PROFILE_STATUS,
	   		  C.VERSION_NAME,
  			  C.AS_OF_DATE,
  			  C.VERSION_ID,
	   		  B.FROM_DATE,
	   		  B.TO_DATE,
	   		  B.PROFILE_SUM,
	   		  B.PROFILE_MAX,
	   		  B.PROFILE_NZ_MIN,
	   		  B.PROFILE_MIN,
	   		  B.R_SQUARED_FAIL_PCT,
	   		  B.R_SQUARED_MAX,
	   		  B.R_SQUARED_MIN,
	   		  B.T_STAT_TEMP_FAIL_PCT,
	   		  B.T_STAT_HUMID_FAIL_PCT,
	   		  B.T_STAT_WIND_FAIL_PCT,
	   		  B.PROFILE_MEAN_APE,
	   		  B.PROFILE_TOTAL_ERROR_PCT,  --Total Error % gets its own col at 3.0
	   		  B.ENTRY_DATE
	   FROM LOAD_PROFILE A,
	   		LOAD_PROFILE_STATISTICS B,
	   		VERSION C
	   WHERE A.PROFILE_ID = B.PROFILE_ID
	   	 AND A.PROFILE_LIBRARY_ID = p_LIBRARY_ID
	   	 AND B.VERSION_ID = C.VERSION_ID
	   	 AND B.VERSION_ID = p_VERSION_ID
	   ORDER BY A.PROFILE_NAME;
	p_STATUS := GA.Success;


END GET_LOAD_PROFILE_BY_LIBRARY;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_SEASON_BREAKPOINT
	(
	p_SEASON_ID IN NUMBER,
	p_PARAMETER_ID IN NUMBER,
	p_BREAKPOINT_ID IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

-- Needed by interface code (MG) as long as SEASON_BREAKPOINT table in use by WRF code

BEGIN

	UPDATE SEASON_BREAKPOINT
	SET BREAKPOINT_ID = p_BREAKPOINT_ID,
		ENTRY_DATE = SYSDATE
	WHERE SEASON_ID = p_SEASON_ID
		AND PARAMETER_ID = p_PARAMETER_ID;

	IF SQL%NOTFOUND THEN
		INSERT INTO SEASON_BREAKPOINT (
			SEASON_ID,
			PARAMETER_ID,
			BREAKPOINT_ID,
			ENTRY_DATE)
		VALUES (
			p_SEASON_ID,
			p_PARAMETER_ID,
			p_BREAKPOINT_ID,
			SYSDATE);
	END IF;

	p_STATUS := GA.SUCCESS;

END PUT_SEASON_BREAKPOINT;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_USAGE_WRF
	(
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;


	OPEN P_CURSOR FOR
		SELECT  B.WRF_NAME,
				C.TEMPLATE_NAME,
  				A.OBSERVATIONS,
  				A.AVG_ALPHA,
  				A.AVG_BETA,
  				A.STD_ALPHA,
  				A.STD_BETA,
  				A.DEFAULT_ASSIGNMENTS,
  				A.STD_ALPHA_N_1,
  				A.STD_BETA_N_1,
  				A.STD_ALPHA_N_2,
  				A.STD_BETA_N_2,
  				A.STD_ALPHA_N_3,
  				A.STD_BETA_N_3,
  				A.LAST_RUN_STATUS,
  				A.LAST_RUN_DATE,
  				B.STATION_ID,
  				B.PARAMETER_ID,
				A.WRF_ID,
				C.TEMPLATE_ID
		FROM USAGE_WRF_STATISTICS A,
			 USAGE_WRF B,
			 TEMPLATE C
		WHERE A.WRF_ID = B.WRF_ID
		  AND A.TEMPLATE_ID = C.TEMPLATE_ID
		  AND A.AS_OF_DATE = p_AS_OF_DATE
		ORDER BY 1,2;

	p_STATUS := GA.SUCCESS;


END GET_USAGE_WRF;

---------------------------------------------------------------------------------------------------
PROCEDURE GET_USAGE_WRF_TEMPLATE_NAMES
	(
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;


	OPEN P_CURSOR FOR
		SELECT  B.WRF_NAME,
				C.TEMPLATE_NAME,
				B.WRF_ID,
				C.TEMPLATE_ID
		FROM USAGE_WRF_TEMPLATE A,
			 USAGE_WRF B,
			 TEMPLATE C
		WHERE A.WRF_ID = B.WRF_ID
		  AND A.TEMPLATE_ID = C.TEMPLATE_ID
		  AND C.TEMPLATE_ID > 0;

	p_STATUS := GA.SUCCESS;


END GET_USAGE_WRF_TEMPLATE_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_CUSTOMER_USAGE_WRF
	(
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_FILTER_STRING IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

v_STRING_TABLE GA.STRING_TABLE;

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	UT.TOKENS_FROM_STRING(p_FILTER_STRING,',', v_STRING_TABLE);

	OPEN P_CURSOR FOR
		SELECT A.CUSTOMER_IDENTIFIER,
			   B.ALPHA,
			   B.BETA,
			   B.N,
			   B.R2,
			   B.X_MIN,
			   B.X_MAX,
			   B.Y_MIN,
			   B.Y_MAX,
			   B.Y_TYPE,
			   B.CUSTOMER_ID
		FROM CUSTOMER A,
			 CUSTOMER_USAGE_WRF_LINE B
		WHERE A.CUSTOMER_ID = B.CUSTOMER_ID
		  AND B.WRF_ID = p_WRF_ID
		  AND B.TEMPLATE_ID = p_TEMPLATE_ID
		  AND B.AS_OF_DATE = p_AS_OF_DATE
		  AND ((v_STRING_TABLE(1) = 0) OR (A.CUSTOMER_IDENTIFIER LIKE v_STRING_TABLE(8)))
		  AND ((v_STRING_TABLE(2) = 0) OR (B.ALPHA >= TO_NUMBER(v_STRING_TABLE(9)) AND B.ALPHA <= TO_NUMBER(v_STRING_TABLE(10))))
		  AND ((v_STRING_TABLE(3) = 0) OR (B.N >= TO_NUMBER(v_STRING_TABLE(11)) AND B.N <= TO_NUMBER(v_STRING_TABLE(12))))
		  AND ((v_STRING_TABLE(4) = 0) OR (B.R2 >= TO_NUMBER(v_STRING_TABLE(13)) AND B.R2 <= TO_NUMBER(v_STRING_TABLE(14))))
		  AND ((v_STRING_TABLE(5) = 0) OR (B.X_MIN >= TO_NUMBER(v_STRING_TABLE(15)) AND B.X_MIN <= TO_NUMBER(v_STRING_TABLE(16))))
		  AND ((v_STRING_TABLE(6) = 0) OR (B.X_MAX >= TO_NUMBER(v_STRING_TABLE(17)) AND B.X_MAX <= TO_NUMBER(v_STRING_TABLE(18))))
		  AND ((v_STRING_TABLE(7) = 0) OR (UPPER(B.Y_TYPE) ='D'));

	p_STATUS := GA.SUCCESS;


END GET_CUSTOMER_USAGE_WRF;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_ENTITY_USAGE_WRF
	(
	p_ENTITY_TYPE IN VARCHAR,
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_FILTER_STRING IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

v_STRING_TABLE GA.STRING_TABLE;

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	UT.TOKENS_FROM_STRING(p_FILTER_STRING,',', v_STRING_TABLE);

	IF UPPER(SUBSTR(p_ENTITY_TYPE,1,1)) = 'C' THEN	--Customer
		OPEN P_CURSOR FOR
    		SELECT A.CUSTOMER_IDENTIFIER,
    			   B.ALPHA,
    			   B.BETA,
    			   B.N,
    			   B.R2,
    			   B.X_MIN,
    			   B.X_MAX,
    			   B.Y_MIN,
    			   B.Y_MAX,
    			   B.Y_TYPE,
    			   B.CUSTOMER_ID
    		FROM CUSTOMER A,
    			 CUSTOMER_USAGE_WRF_LINE B
    		WHERE A.CUSTOMER_ID = B.CUSTOMER_ID
    		  AND B.WRF_ID = p_WRF_ID
    		  AND B.TEMPLATE_ID = p_TEMPLATE_ID
    		  AND B.AS_OF_DATE = p_AS_OF_DATE
    		  AND ((v_STRING_TABLE(1) = 0) OR (A.CUSTOMER_IDENTIFIER LIKE v_STRING_TABLE(8)))
    		  AND ((v_STRING_TABLE(2) = 0) OR (B.ALPHA >= TO_NUMBER(v_STRING_TABLE(9)) AND B.ALPHA <= TO_NUMBER(v_STRING_TABLE(10))))
    		  AND ((v_STRING_TABLE(3) = 0) OR (B.N >= TO_NUMBER(v_STRING_TABLE(11)) AND B.N <= TO_NUMBER(v_STRING_TABLE(12))))
    		  AND ((v_STRING_TABLE(4) = 0) OR (B.R2 >= TO_NUMBER(v_STRING_TABLE(13)) AND B.R2 <= TO_NUMBER(v_STRING_TABLE(14))))
    		  AND ((v_STRING_TABLE(5) = 0) OR (B.X_MIN >= TO_NUMBER(v_STRING_TABLE(15)) AND B.X_MIN <= TO_NUMBER(v_STRING_TABLE(16))))
    		  AND ((v_STRING_TABLE(6) = 0) OR (B.X_MAX >= TO_NUMBER(v_STRING_TABLE(17)) AND B.X_MAX <= TO_NUMBER(v_STRING_TABLE(18))))
    		  AND ((v_STRING_TABLE(7) = 0) OR (UPPER(B.Y_TYPE) ='D'));

    ELSE      -- UPPER(SUBSTR(p_ENTITY_TYPE,1,1)) = 'A' THEN	--Account
		OPEN P_CURSOR FOR
    		SELECT A.ACCOUNT_EXTERNAL_IDENTIFIER,
                   B.ALPHA,
    			   B.BETA,
    			   B.N,
    			   B.R2,
    			   B.X_MIN,
    			   B.X_MAX,
    			   B.Y_MIN,
    			   B.Y_MAX,
    			   B.Y_TYPE,
    			   B.ACCOUNT_ID
    		FROM ACCOUNT A,
    			 ACCOUNT_USAGE_WRF_LINE B
    		WHERE A.ACCOUNT_ID = B.ACCOUNT_ID
              AND B.WRF_ID = p_WRF_ID
    		  AND B.TEMPLATE_ID = p_TEMPLATE_ID
    		  AND B.AS_OF_DATE = p_AS_OF_DATE
    		  AND ((v_STRING_TABLE(1) = 0) OR (A.ACCOUNT_EXTERNAL_IDENTIFIER LIKE v_STRING_TABLE(8)))
    		  AND ((v_STRING_TABLE(2) = 0) OR (B.ALPHA >= TO_NUMBER(v_STRING_TABLE(9)) AND B.ALPHA <= TO_NUMBER(v_STRING_TABLE(10))))
    		  AND ((v_STRING_TABLE(3) = 0) OR (B.N >= TO_NUMBER(v_STRING_TABLE(11)) AND B.N <= TO_NUMBER(v_STRING_TABLE(12))))
    		  AND ((v_STRING_TABLE(4) = 0) OR (B.R2 >= TO_NUMBER(v_STRING_TABLE(13)) AND B.R2 <= TO_NUMBER(v_STRING_TABLE(14))))
    		  AND ((v_STRING_TABLE(5) = 0) OR (B.X_MIN >= TO_NUMBER(v_STRING_TABLE(15)) AND B.X_MIN <= TO_NUMBER(v_STRING_TABLE(16))))
    		  AND ((v_STRING_TABLE(6) = 0) OR (B.X_MAX >= TO_NUMBER(v_STRING_TABLE(17)) AND B.X_MAX <= TO_NUMBER(v_STRING_TABLE(18))))
    		  AND ((v_STRING_TABLE(7) = 0) OR (UPPER(B.Y_TYPE) ='D'));
    END IF;

	p_STATUS := GA.SUCCESS;


END GET_ENTITY_USAGE_WRF;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_ENTITY_CONSUMPTION
	(
	p_ENTITY_ID IN NUMBER,
	p_ENTITY_TYPE IN VARCHAR,
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

 	IF UPPER(SUBSTR(p_ENTITY_TYPE,1,1)) = 'C' THEN	--Customer
       	OPEN P_CURSOR FOR
    		SELECT DISTINCT /*+ ORDERED */ C.BEGIN_DATE, C.END_DATE, (C.END_DATE - C.BEGIN_DATE) + 1 "DAYS", 'NONE', C.BILLED_USAGE
    		FROM USAGE_WRF_STATISTICS A,
                 CUSTOMER_USAGE_WRF B,
                 CUSTOMER_CONSUMPTION C,
                 USAGE_WRF_SEASON D,
                 SEASON_DATES I
    		WHERE A.WRF_ID = p_WRF_ID
                AND B.WRF_ID = p_WRF_ID  --specify for speed
                AND D.WRF_ID = p_WRF_ID  --specify for speed
    			AND B.CUSTOMER_ID = p_ENTITY_ID
    			AND C.CUSTOMER_ID = p_ENTITY_ID  --specify for speed
    			AND A.TEMPLATE_ID = p_TEMPLATE_ID
    			AND A.SEGMENT_NBR = 1
    			AND A.AS_OF_DATE = p_AS_OF_DATE
    			AND B.CUSTOMER_ID = p_ENTITY_ID
    			AND B.WRF_ID = A.WRF_ID  --join
    			AND B.BEGIN_DATE <= A.END_DATE
    			AND NVL(B.END_DATE, A.END_DATE) >= A.BEGIN_DATE
    			AND C.CUSTOMER_ID = B.CUSTOMER_ID  --join
    			AND C.BEGIN_DATE <= A.END_DATE  -- Meter read TOUCHES date range.
    			AND C.END_DATE >= A.BEGIN_DATE  -- Meter read TOUCHES date range.
    			AND D.WRF_ID = B.WRF_ID  --join
    			AND D.TEMPLATE_ID = p_TEMPLATE_ID
    			AND D.AS_OF_DATE = p_AS_OF_DATE
        		AND I.SEASON_ID = D.SEASON_ID
                AND C.BEGIN_DATE  <= I.END_DATE  --Replace SEASON_INTERSECTS_SEASON fxn
        		AND C.END_DATE    >= I.BEGIN_DATE  --Replace SEASON_INTERSECTS_SEASON fxn
    		ORDER BY 1,2;

 	ELSE      -- UPPER(SUBSTR(p_ENTITY_TYPE,1,1)) = 'A' THEN	--Account
       	OPEN P_CURSOR FOR
    		SELECT DISTINCT /*+ ORDERED */ C.BEGIN_DATE, C.END_DATE, (C.END_DATE - C.BEGIN_DATE) + 1 "DAYS",
					(SELECT MAX(E.BILL_CYCLE_NAME)
					 FROM ACCOUNT_BILL_CYCLE F, BILL_CYCLE E
					 WHERE F.ACCOUNT_ID = B.ACCOUNT_ID
						AND C.END_DATE BETWEEN F.BEGIN_DATE AND NVL(F.END_DATE,C.END_DATE)
						AND E.BILL_CYCLE_ID = F.BILL_CYCLE_ID) as BILL_CYCLE_NAME,
					C.BILLED_USAGE
    		FROM USAGE_WRF_STATISTICS A,
                 ACCOUNT_USAGE_WRF B,
                 SERVICE H,
                 ACCOUNT_SERVICE G,
                 SERVICE_CONSUMPTION C,
                 USAGE_WRF_SEASON D,
                 SEASON_DATES I
    		WHERE A.WRF_ID = p_WRF_ID
                AND B.WRF_ID = p_WRF_ID  --specify for speed
                AND D.WRF_ID = p_WRF_ID  --specify for speed
    			AND B.ACCOUNT_ID = p_ENTITY_ID
    			AND G.ACCOUNT_ID = p_ENTITY_ID  --specify for speed
    			AND A.TEMPLATE_ID = p_TEMPLATE_ID
    			AND A.SEGMENT_NBR = 1
    			AND A.AS_OF_DATE = p_AS_OF_DATE
    			AND B.WRF_ID = A.WRF_ID  --join
    			AND B.BEGIN_DATE <= A.END_DATE
    			AND NVL(B.END_DATE, A.END_DATE) >= A.BEGIN_DATE
    			AND G.ACCOUNT_ID = B.ACCOUNT_ID  --join
    			AND H.ACCOUNT_SERVICE_ID = G.ACCOUNT_SERVICE_ID
    			AND C.SERVICE_ID = H.SERVICE_ID
    			AND C.BEGIN_DATE <= A.END_DATE  -- Meter read TOUCHES date range.
    			AND C.END_DATE >= A.BEGIN_DATE  -- Meter read TOUCHES date range.
    			AND D.WRF_ID = B.WRF_ID  --join
    			AND D.TEMPLATE_ID = p_TEMPLATE_ID
    			AND D.AS_OF_DATE = p_AS_OF_DATE
        		AND I.SEASON_ID = D.SEASON_ID
                AND C.BEGIN_DATE  <= I.END_DATE  --Replace SEASON_INTERSECTS_SEASON fxn
        		AND C.END_DATE    >= I.BEGIN_DATE  --Replace SEASON_INTERSECTS_SEASON fxn
				AND C.UNIT_OF_MEASUREMENT = GA.DEFAULT_UNIT_OF_MEASUREMENT
    		ORDER BY 1,2;

    END IF;

	p_STATUS := GA.SUCCESS;

END GET_ENTITY_CONSUMPTION;
---------------------------------------------------------------------------------------------------
PROCEDURE NEW_LOAD_PROFILE_VERSION
	(
	p_AS_OF_DATE IN DATE,
	p_VERSION_ID OUT NUMBER,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;


END NEW_LOAD_PROFILE_VERSION;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_PROFILE_AS_OF_DATE
	(
	p_PROFILE_ID IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_PROFILE_AS_OF_DATE OUT DATE,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	SELECT MAX(AS_OF_DATE)
	INTO p_PROFILE_AS_OF_DATE
	FROM LOAD_PROFILE_STATISTICS
	WHERE AS_OF_DATE <= p_AS_OF_DATE;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		p_PROFILE_AS_OF_DATE := LOW_DATE;

END GET_PROFILE_AS_OF_DATE;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_STATION_PARAMETER
	(
	p_STATION_ID IN NUMBER,
	p_PARAMETER_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PARAMETER_AVG OUT NUMBER
	) AS

v_PARMS GA.ID_TABLE;

BEGIN

	v_PARMS(1) := p_PARAMETER_ID;

	WR.CACHE_COMPOSITE_HIERARCHY(p_STATION_ID, v_PARMS);

	-- calculate average parameter for the specified date range
	SELECT ROUND(AVG(VAL),3)
	INTO p_PARAMETER_AVG
		-- inner query computes the parameter value in case either the
		-- station or parameter is a composite - if not, the work tables will have
		-- only a single entry with the station or parameter ID and a coefficient
		-- of 1.0
	FROM (SELECT SUM(SPV.PARAMETER_VAL * WS.COEFFICIENT * WP.COEFFICIENT) as VAL
			FROM STATION_PARAMETER_VALUE SPV,
				COMPOSITE_WEATHER_WORK WS,
				COMPOSITE_WEATHER_WORK WP
			WHERE WS.ENTITY_INDEX = 0 -- station hierarchy
				AND WP.ENTITY_INDEX = 1 -- parameter 1 hierarchy
				AND	SPV.CASE_ID = GA.BASE_CASE_ID
				AND SPV.STATION_ID = WS.ENTITY_ID
				AND SPV.PARAMETER_ID = WP.ENTITY_ID
				AND SPV.PARAMETER_CODE = 'A'
				AND SPV.PARAMETER_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
			GROUP BY SPV.PARAMETER_DATE);

END GET_STATION_PARAMETER;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_CUSTOMER_USAGE_WRF_LINE
	(
	p_CUSTOMER_USAGE_WRF_LINE IN CUSTOMER_USAGE_WRF_LINE%ROWTYPE
	) AS

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG(
			TO_CHAR(p_CUSTOMER_USAGE_WRF_LINE.CUSTOMER_ID) || ',' ||
			TO_CHAR(p_CUSTOMER_USAGE_WRF_LINE.WRF_ID) || ',' ||
			TO_CHAR(p_CUSTOMER_USAGE_WRF_LINE.TEMPLATE_ID) || ',' ||
			TO_CHAR(p_CUSTOMER_USAGE_WRF_LINE.SEGMENT_NBR) || ',' ||
			TO_CHAR(p_CUSTOMER_USAGE_WRF_LINE.AS_OF_DATE) || ',' ||
			TO_CHAR(p_CUSTOMER_USAGE_WRF_LINE.ALPHA) || ',' ||
			TO_CHAR(p_CUSTOMER_USAGE_WRF_LINE.BETA) || ',' ||
			TO_CHAR(p_CUSTOMER_USAGE_WRF_LINE.R2) || ',' ||
			TO_CHAR(p_CUSTOMER_USAGE_WRF_LINE.N) || ',' ||
			TO_CHAR(p_CUSTOMER_USAGE_WRF_LINE.X_MIN) || ',' ||
			TO_CHAR(p_CUSTOMER_USAGE_WRF_LINE.X_MAX) || ',' ||
			TO_CHAR(p_CUSTOMER_USAGE_WRF_LINE.Y_MIN) || ',' ||
			TO_CHAR(p_CUSTOMER_USAGE_WRF_LINE.Y_MAX) || ',' ||
			TO_CHAR(p_CUSTOMER_USAGE_WRF_LINE.X_ZERO) || ',' ||
			TO_CHAR(p_CUSTOMER_USAGE_WRF_LINE.Y_ZERO));
	END IF;

	UPDATE CUSTOMER_USAGE_WRF_LINE
	SET ALPHA = p_CUSTOMER_USAGE_WRF_LINE.ALPHA,
		BETA = p_CUSTOMER_USAGE_WRF_LINE.BETA,
		R2 = p_CUSTOMER_USAGE_WRF_LINE.R2,
		N = p_CUSTOMER_USAGE_WRF_LINE.N,
		X_MIN = p_CUSTOMER_USAGE_WRF_LINE.X_MIN,
		X_MAX = p_CUSTOMER_USAGE_WRF_LINE.X_MAX,
		Y_MIN = p_CUSTOMER_USAGE_WRF_LINE.Y_MIN,
		Y_MAX = p_CUSTOMER_USAGE_WRF_LINE.Y_MAX,
		X_ZERO = p_CUSTOMER_USAGE_WRF_LINE.X_ZERO,
		Y_ZERO = p_CUSTOMER_USAGE_WRF_LINE.Y_ZERO
	WHERE CUSTOMER_ID = p_CUSTOMER_USAGE_WRF_LINE.CUSTOMER_ID
		AND WRF_ID = p_CUSTOMER_USAGE_WRF_LINE.WRF_ID
		AND TEMPLATE_ID = p_CUSTOMER_USAGE_WRF_LINE.TEMPLATE_ID
		AND SEGMENT_NBR = p_CUSTOMER_USAGE_WRF_LINE.SEGMENT_NBR
		AND AS_OF_DATE = p_CUSTOMER_USAGE_WRF_LINE.AS_OF_DATE;

	IF SQL%NOTFOUND THEN
		INSERT INTO CUSTOMER_USAGE_WRF_LINE(
			CUSTOMER_ID,
			WRF_ID,
			TEMPLATE_ID,
			SEGMENT_NBR,
			AS_OF_DATE,
			ALPHA,
			BETA,
			R2,
			N,
			X_MIN,
			X_MAX,
			Y_MIN,
			Y_MAX,
			X_ZERO,
			Y_ZERO)
		VALUES(
			p_CUSTOMER_USAGE_WRF_LINE.CUSTOMER_ID,
			p_CUSTOMER_USAGE_WRF_LINE.WRF_ID,
			p_CUSTOMER_USAGE_WRF_LINE.TEMPLATE_ID,
			p_CUSTOMER_USAGE_WRF_LINE.SEGMENT_NBR,
			p_CUSTOMER_USAGE_WRF_LINE.AS_OF_DATE,
			p_CUSTOMER_USAGE_WRF_LINE.ALPHA,
			p_CUSTOMER_USAGE_WRF_LINE.BETA,
			p_CUSTOMER_USAGE_WRF_LINE.R2,
			p_CUSTOMER_USAGE_WRF_LINE.N,
			p_CUSTOMER_USAGE_WRF_LINE.X_MIN,
			p_CUSTOMER_USAGE_WRF_LINE.X_MAX,
			p_CUSTOMER_USAGE_WRF_LINE.Y_MIN,
			p_CUSTOMER_USAGE_WRF_LINE.Y_MAX,
			p_CUSTOMER_USAGE_WRF_LINE.X_ZERO,
			p_CUSTOMER_USAGE_WRF_LINE.Y_ZERO);
	END IF;

END PUT_CUSTOMER_USAGE_WRF_LINE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_USAGE_WRF_LINE
	(
	p_ACCOUNT_USAGE_WRF_LINE IN ACCOUNT_USAGE_WRF_LINE%ROWTYPE
	) AS

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG(
			TO_CHAR(p_ACCOUNT_USAGE_WRF_LINE.ACCOUNT_ID) || ',' ||
			TO_CHAR(p_ACCOUNT_USAGE_WRF_LINE.WRF_ID) || ',' ||
			TO_CHAR(p_ACCOUNT_USAGE_WRF_LINE.TEMPLATE_ID) || ',' ||
			TO_CHAR(p_ACCOUNT_USAGE_WRF_LINE.SEGMENT_NBR) || ',' ||
			TO_CHAR(p_ACCOUNT_USAGE_WRF_LINE.AS_OF_DATE) || ',' ||
			TO_CHAR(p_ACCOUNT_USAGE_WRF_LINE.ALPHA) || ',' ||
			TO_CHAR(p_ACCOUNT_USAGE_WRF_LINE.BETA) || ',' ||
			TO_CHAR(p_ACCOUNT_USAGE_WRF_LINE.R2) || ',' ||
			TO_CHAR(p_ACCOUNT_USAGE_WRF_LINE.N) || ',' ||
			TO_CHAR(p_ACCOUNT_USAGE_WRF_LINE.X_MIN) || ',' ||
			TO_CHAR(p_ACCOUNT_USAGE_WRF_LINE.X_MAX) || ',' ||
			TO_CHAR(p_ACCOUNT_USAGE_WRF_LINE.Y_MIN) || ',' ||
			TO_CHAR(p_ACCOUNT_USAGE_WRF_LINE.Y_MAX) || ',' ||
			TO_CHAR(p_ACCOUNT_USAGE_WRF_LINE.X_ZERO) || ',' ||
			TO_CHAR(p_ACCOUNT_USAGE_WRF_LINE.Y_ZERO));
	END IF;

	UPDATE ACCOUNT_USAGE_WRF_LINE
	SET ALPHA = p_ACCOUNT_USAGE_WRF_LINE.ALPHA,
		BETA = p_ACCOUNT_USAGE_WRF_LINE.BETA,
		R2 = p_ACCOUNT_USAGE_WRF_LINE.R2,
		N = p_ACCOUNT_USAGE_WRF_LINE.N,
		X_MIN = p_ACCOUNT_USAGE_WRF_LINE.X_MIN,
		X_MAX = p_ACCOUNT_USAGE_WRF_LINE.X_MAX,
		Y_MIN = p_ACCOUNT_USAGE_WRF_LINE.Y_MIN,
		Y_MAX = p_ACCOUNT_USAGE_WRF_LINE.Y_MAX,
		X_ZERO = p_ACCOUNT_USAGE_WRF_LINE.X_ZERO,
		Y_ZERO = p_ACCOUNT_USAGE_WRF_LINE.Y_ZERO
	WHERE ACCOUNT_ID = p_ACCOUNT_USAGE_WRF_LINE.ACCOUNT_ID
		AND WRF_ID = p_ACCOUNT_USAGE_WRF_LINE.WRF_ID
		AND TEMPLATE_ID = p_ACCOUNT_USAGE_WRF_LINE.TEMPLATE_ID
		AND SEGMENT_NBR = p_ACCOUNT_USAGE_WRF_LINE.SEGMENT_NBR
		AND AS_OF_DATE = p_ACCOUNT_USAGE_WRF_LINE.AS_OF_DATE;

	IF SQL%NOTFOUND THEN
		INSERT INTO ACCOUNT_USAGE_WRF_LINE(
			ACCOUNT_ID,
			WRF_ID,
			TEMPLATE_ID,
			SEGMENT_NBR,
			AS_OF_DATE,
			ALPHA,
			BETA,
			R2,
			N,
			X_MIN,
			X_MAX,
			Y_MIN,
			Y_MAX,
			X_ZERO,
			Y_ZERO)
		VALUES(
			p_ACCOUNT_USAGE_WRF_LINE.ACCOUNT_ID,
			p_ACCOUNT_USAGE_WRF_LINE.WRF_ID,
			p_ACCOUNT_USAGE_WRF_LINE.TEMPLATE_ID,
			p_ACCOUNT_USAGE_WRF_LINE.SEGMENT_NBR,
			p_ACCOUNT_USAGE_WRF_LINE.AS_OF_DATE,
			p_ACCOUNT_USAGE_WRF_LINE.ALPHA,
			p_ACCOUNT_USAGE_WRF_LINE.BETA,
			p_ACCOUNT_USAGE_WRF_LINE.R2,
			p_ACCOUNT_USAGE_WRF_LINE.N,
			p_ACCOUNT_USAGE_WRF_LINE.X_MIN,
			p_ACCOUNT_USAGE_WRF_LINE.X_MAX,
			p_ACCOUNT_USAGE_WRF_LINE.Y_MIN,
			p_ACCOUNT_USAGE_WRF_LINE.Y_MAX,
			p_ACCOUNT_USAGE_WRF_LINE.X_ZERO,
			p_ACCOUNT_USAGE_WRF_LINE.Y_ZERO);
	END IF;

END PUT_ACCOUNT_USAGE_WRF_LINE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_USAGE_WRF_STATISTICS
	(
	p_USAGE_WRF_STATISTICS IN USAGE_WRF_STATISTICS%ROWTYPE
	) AS

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG(
			TO_CHAR(p_USAGE_WRF_STATISTICS.WRF_ID) || ',' ||
			TO_CHAR(p_USAGE_WRF_STATISTICS.TEMPLATE_ID) || ',' ||
			TO_CHAR(p_USAGE_WRF_STATISTICS.SEGMENT_NBR) || ',' ||
			TO_CHAR(p_USAGE_WRF_STATISTICS.AS_OF_DATE) || ',' ||
			TO_CHAR(p_USAGE_WRF_STATISTICS.OBSERVATIONS) || ',' ||
			TO_CHAR(p_USAGE_WRF_STATISTICS.DEFAULT_ASSIGNMENTS) || ',' ||
			TO_CHAR(p_USAGE_WRF_STATISTICS.AVG_ALPHA) || ',' ||
			TO_CHAR(p_USAGE_WRF_STATISTICS.AVG_BETA) || ',' ||
			TO_CHAR(p_USAGE_WRF_STATISTICS.STD_ALPHA) || ',' ||
			TO_CHAR(p_USAGE_WRF_STATISTICS.STD_BETA) || ',' ||
			TO_CHAR(p_USAGE_WRF_STATISTICS.STD_ALPHA_N_1) || ',' ||
			TO_CHAR(p_USAGE_WRF_STATISTICS.STD_BETA_N_1) || ',' ||
			TO_CHAR(p_USAGE_WRF_STATISTICS.STD_ALPHA_N_2) || ',' ||
			TO_CHAR(p_USAGE_WRF_STATISTICS.STD_BETA_N_2) || ',' ||
			TO_CHAR(p_USAGE_WRF_STATISTICS.STD_ALPHA_N_3) || ',' ||
			TO_CHAR(p_USAGE_WRF_STATISTICS.STD_BETA_N_3) || ',' ||
			TO_CHAR(p_USAGE_WRF_STATISTICS.WRF_MIN) || ',' ||
			TO_CHAR(p_USAGE_WRF_STATISTICS.WRF_MAX) || ',' ||
			TO_CHAR(p_USAGE_WRF_STATISTICS.R2_MIN) || ',' ||
			TO_CHAR(p_USAGE_WRF_STATISTICS.R2_MAX) || ',' ||
			TO_CHAR(p_USAGE_WRF_STATISTICS.AVG_Y_MIN) || ',' ||-- msg added 06/13/2002 change control 23
			TO_CHAR(p_USAGE_WRF_STATISTICS.AVG_Y_MAX) || ',' ||-- msg added 06/13/2002 change control 23
			TO_CHAR(p_USAGE_WRF_STATISTICS.AVG_Y_LOW_WARNING) || ',' ||-- msg added 06/13/2002 change control 23
			TO_CHAR(p_USAGE_WRF_STATISTICS.AVG_Y_HIGH_WARNING) || ',' ||-- msg added 06/13/2002 change control 23
			TEXT_UTIL.TO_CHAR_DATE(p_USAGE_WRF_STATISTICS.BEGIN_DATE) || ',' ||
			TEXT_UTIL.TO_CHAR_DATE(p_USAGE_WRF_STATISTICS.END_DATE) || ',' ||
			p_USAGE_WRF_STATISTICS.LAST_RUN_STATUS || ',' ||
			TEXT_UTIL.TO_CHAR_DATE(p_USAGE_WRF_STATISTICS.LAST_RUN_DATE));
	END IF;

	UPDATE USAGE_WRF_STATISTICS
	SET OBSERVATIONS = p_USAGE_WRF_STATISTICS.OBSERVATIONS,
		DEFAULT_ASSIGNMENTS = p_USAGE_WRF_STATISTICS.DEFAULT_ASSIGNMENTS,
		AVG_ALPHA = p_USAGE_WRF_STATISTICS.AVG_ALPHA,
		AVG_BETA = p_USAGE_WRF_STATISTICS.AVG_BETA,
		STD_ALPHA = p_USAGE_WRF_STATISTICS.STD_ALPHA,
		STD_BETA = p_USAGE_WRF_STATISTICS.STD_BETA,
		STD_ALPHA_N_1 = p_USAGE_WRF_STATISTICS.STD_ALPHA_N_1,
		STD_BETA_N_1 = p_USAGE_WRF_STATISTICS.STD_BETA_N_1,
		STD_ALPHA_N_2 = p_USAGE_WRF_STATISTICS.STD_ALPHA_N_2,
		STD_BETA_N_2 = p_USAGE_WRF_STATISTICS.STD_BETA_N_2,
		STD_ALPHA_N_3 = p_USAGE_WRF_STATISTICS.STD_ALPHA_N_3,
		STD_BETA_N_3 = p_USAGE_WRF_STATISTICS.STD_BETA_N_3,
		WRF_MIN = p_USAGE_WRF_STATISTICS.WRF_MIN,
		WRF_MAX = p_USAGE_WRF_STATISTICS.WRF_MAX,
		R2_MIN = p_USAGE_WRF_STATISTICS.R2_MIN,
		R2_MAX = p_USAGE_WRF_STATISTICS.R2_MAX,
		AVG_Y_MIN = p_USAGE_WRF_STATISTICS.AVG_Y_MIN,-- msg added 06/13/2002 change control 23
		AVG_Y_MAX = p_USAGE_WRF_STATISTICS.AVG_Y_MAX,-- msg added 06/13/2002 change control 23
		AVG_Y_LOW_WARNING = p_USAGE_WRF_STATISTICS.AVG_Y_LOW_WARNING,-- msg added 06/13/2002 change control 23
		AVG_Y_HIGH_WARNING = p_USAGE_WRF_STATISTICS.AVG_Y_HIGH_WARNING,-- msg added 06/13/2002 change control 23
		BEGIN_DATE =  p_USAGE_WRF_STATISTICS.BEGIN_DATE,
		END_DATE =  p_USAGE_WRF_STATISTICS.END_DATE,
		LAST_RUN_STATUS = p_USAGE_WRF_STATISTICS.LAST_RUN_STATUS,
		LAST_RUN_DATE = p_USAGE_WRF_STATISTICS.LAST_RUN_DATE
	WHERE WRF_ID = p_USAGE_WRF_STATISTICS.WRF_ID
		AND TEMPLATE_ID = p_USAGE_WRF_STATISTICS.TEMPLATE_ID
		AND SEGMENT_NBR = p_USAGE_WRF_STATISTICS.SEGMENT_NBR
		AND AS_OF_DATE = p_USAGE_WRF_STATISTICS.AS_OF_DATE;

	IF SQL%NOTFOUND THEN
		INSERT INTO USAGE_WRF_STATISTICS(
			WRF_ID,
			TEMPLATE_ID,
			SEGMENT_NBR,
			AS_OF_DATE,
			OBSERVATIONS,
			DEFAULT_ASSIGNMENTS,
			AVG_ALPHA,
			AVG_BETA,
			STD_ALPHA,
			STD_BETA,
			STD_ALPHA_N_1,
			STD_BETA_N_1,
			STD_ALPHA_N_2,
			STD_BETA_N_2,
			STD_ALPHA_N_3,
			STD_BETA_N_3,
			WRF_MIN,
			WRF_MAX,
			R2_MIN,
			R2_MAX,
			AVG_Y_MIN,-- msg added 06/13/2002 change control 23
			AVG_Y_MAX,-- msg added 06/13/2002 change control 23
			AVG_Y_LOW_WARNING,-- msg added 06/13/2002 change control 23
			AVG_Y_HIGH_WARNING,-- msg added 06/13/2002 change control 23
			BEGIN_DATE,
			END_DATE,
			LAST_RUN_STATUS,
			LAST_RUN_DATE)
		VALUES(
			p_USAGE_WRF_STATISTICS.WRF_ID,
			p_USAGE_WRF_STATISTICS.TEMPLATE_ID,
			p_USAGE_WRF_STATISTICS.SEGMENT_NBR,
			p_USAGE_WRF_STATISTICS.AS_OF_DATE,
			p_USAGE_WRF_STATISTICS.OBSERVATIONS,
			p_USAGE_WRF_STATISTICS.DEFAULT_ASSIGNMENTS,
			p_USAGE_WRF_STATISTICS.AVG_ALPHA,
			p_USAGE_WRF_STATISTICS.AVG_BETA,
			p_USAGE_WRF_STATISTICS.STD_ALPHA,
			p_USAGE_WRF_STATISTICS.STD_BETA,
			p_USAGE_WRF_STATISTICS.STD_ALPHA_N_1,
			p_USAGE_WRF_STATISTICS.STD_BETA_N_1,
			p_USAGE_WRF_STATISTICS.STD_ALPHA_N_2,
			p_USAGE_WRF_STATISTICS.STD_BETA_N_2,
			p_USAGE_WRF_STATISTICS.STD_ALPHA_N_3,
			p_USAGE_WRF_STATISTICS.STD_BETA_N_3,
			p_USAGE_WRF_STATISTICS.WRF_MIN,
			p_USAGE_WRF_STATISTICS.WRF_MAX,
			p_USAGE_WRF_STATISTICS.R2_MIN,
			p_USAGE_WRF_STATISTICS.R2_MAX,
			p_USAGE_WRF_STATISTICS.AVG_Y_MIN,-- msg added 06/13/2002 change control 23
			p_USAGE_WRF_STATISTICS.AVG_Y_MAX,-- msg added 06/13/2002 change control 23
			p_USAGE_WRF_STATISTICS.AVG_Y_LOW_WARNING,-- msg added 06/13/2002 change control 23
			p_USAGE_WRF_STATISTICS.AVG_Y_HIGH_WARNING,-- msg added 06/13/2002 change control 23
			p_USAGE_WRF_STATISTICS.BEGIN_DATE,
			p_USAGE_WRF_STATISTICS.END_DATE,
			p_USAGE_WRF_STATISTICS.LAST_RUN_STATUS,
			p_USAGE_WRF_STATISTICS.LAST_RUN_DATE);
	END IF;

END PUT_USAGE_WRF_STATISTICS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_USAGE_WRF_SEASON
	(
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_AS_OF_DATE IN DATE
	) AS

v_COUNT NUMBER(4);

BEGIN

	DELETE USAGE_WRF_SEASON
	WHERE WRF_ID = p_WRF_ID
		AND  TEMPLATE_ID = p_TEMPLATE_ID
		AND AS_OF_DATE = p_AS_OF_DATE;

	INSERT INTO USAGE_WRF_SEASON (WRF_ID, TEMPLATE_ID, SEASON_ID, AS_OF_DATE, BEGIN_DATE, END_DATE)
		SELECT DISTINCT p_WRF_ID, p_TEMPLATE_ID, C.SEASON_ID, p_AS_OF_DATE, C.BEGIN_DATE, C.END_DATE
		FROM USAGE_WRF_TEMPLATE A,
			TEMPLATE_SEASON_DAY_NAME TSDN,
			SEASON C
		WHERE A.WRF_ID = p_WRF_ID
			AND A.TEMPLATE_ID = p_TEMPLATE_ID
			AND TSDN.TEMPLATE_ID = A.TEMPLATE_ID
			AND C.SEASON_ID = TSDN.SEASON_ID;

	SELECT COUNT(*)
	INTO v_COUNT
	FROM USAGE_WRF_SEASON A
	WHERE WRF_ID = p_WRF_ID
		AND AS_OF_DATE = p_AS_OF_DATE
		AND EXISTS
			(SELECT 1
			FROM USAGE_WRF_SEASON X, SEASON_DATES Y
			WHERE WRF_ID = A.WRF_ID
				AND Y.SEASON_ID = X.SEASON_ID
				AND AS_OF_DATE = p_AS_OF_DATE
				AND X.ROWID <> A.ROWID
                AND Y.BEGIN_DATE <= A.END_DATE  --Replace SEASON_INTERSECTS_SEASON fxn
                AND Y.END_DATE >=  A.BEGIN_DATE);  --Replace SEASON_INTERSECTS_SEASON fxn

	IF v_COUNT > 1 THEN
		ERRS.RAISE(MSGCODES.c_ERR_DATES_OVERLAP, 'Overlapping Customer Usage WRF Season Assignments In Effect.');
	END IF;

END PUT_USAGE_WRF_SEASON;
----------------------------------------------------------------------------------------------------
PROCEDURE COMPUTE_USAGE_WRF_STATISTICS
	(
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_SEGMENT_NBR IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_DEFAULT_ASSIGNMENTS IN NUMBER,
	p_WRF_MIN IN NUMBER,
	p_WRF_MAX IN NUMBER,
	p_R2_MIN IN NUMBER,
	p_R2_MAX IN NUMBER,
	p_ALPHA IN GA.NUMBER_TABLE,
	p_BETA IN GA.NUMBER_TABLE
	) AS

v_USAGE_WRF_STATISTICS USAGE_WRF_STATISTICS%ROWTYPE;
v_EVENT_TEXT PROCESS_LOG_EVENT.EVENT_TEXT%TYPE;
v_PARAMETER_MIN USAGE_WRF_TEMPLATE.PARAMETER_MIN%TYPE;
v_PARAMETER_MAX USAGE_WRF_TEMPLATE.PARAMETER_MAX%TYPE;
v_PARAMETER_MIN_TOLERANCE USAGE_WRF_TEMPLATE.PARAMETER_MIN_TOLERANCE%TYPE;
v_PARAMETER_MAX_TOLERANCE USAGE_WRF_TEMPLATE.PARAMETER_MAX_TOLERANCE%TYPE;

BEGIN

	UT.STD_DEV(p_ALPHA,
		v_USAGE_WRF_STATISTICS.OBSERVATIONS,
		v_USAGE_WRF_STATISTICS.AVG_ALPHA,
		v_USAGE_WRF_STATISTICS.STD_ALPHA,
		v_USAGE_WRF_STATISTICS.STD_ALPHA_N_1,
		v_USAGE_WRF_STATISTICS.STD_ALPHA_N_2,
		v_USAGE_WRF_STATISTICS.STD_ALPHA_N_3);

	UT.STD_DEV(p_BETA,
		v_USAGE_WRF_STATISTICS.OBSERVATIONS,
		v_USAGE_WRF_STATISTICS.AVG_BETA,
		v_USAGE_WRF_STATISTICS.STD_BETA,
		v_USAGE_WRF_STATISTICS.STD_BETA_N_1,
		v_USAGE_WRF_STATISTICS.STD_BETA_N_2,
		v_USAGE_WRF_STATISTICS.STD_BETA_N_3);

	v_USAGE_WRF_STATISTICS.WRF_ID := p_WRF_ID;
	v_USAGE_WRF_STATISTICS.TEMPLATE_ID := p_TEMPLATE_ID;
	v_USAGE_WRF_STATISTICS.SEGMENT_NBR := p_SEGMENT_NBR;
	v_USAGE_WRF_STATISTICS.AS_OF_DATE := p_AS_OF_DATE;
	v_USAGE_WRF_STATISTICS.BEGIN_DATE := p_BEGIN_DATE;
	v_USAGE_WRF_STATISTICS.END_DATE := p_END_DATE;
	v_USAGE_WRF_STATISTICS.LAST_RUN_STATUS := 'PENDING';
	v_USAGE_WRF_STATISTICS.LAST_RUN_DATE := SYSDATE;

	v_USAGE_WRF_STATISTICS.DEFAULT_ASSIGNMENTS := p_DEFAULT_ASSIGNMENTS;
	v_USAGE_WRF_STATISTICS.WRF_MIN := p_WRF_MIN;
	v_USAGE_WRF_STATISTICS.WRF_MAX := p_WRF_MAX;
	v_USAGE_WRF_STATISTICS.R2_MIN := p_R2_MIN;
	v_USAGE_WRF_STATISTICS.R2_MAX := p_R2_MAX;

	--msg code added for change order 23 06/13/2002
	--retrieve user defined degree day parameter AND tolerance limits
	BEGIN
	 SELECT PARAMETER_MIN, PARAMETER_MAX, PARAMETER_MIN_TOLERANCE, PARAMETER_MAX_TOLERANCE
		 INTO v_PARAMETER_MIN, v_PARAMETER_MAX, v_PARAMETER_MIN_TOLERANCE, v_PARAMETER_MAX_TOLERANCE
		 FROM USAGE_WRF_TEMPLATE
		 WHERE WRF_ID =  v_USAGE_WRF_STATISTICS.WRF_ID
		 AND TEMPLATE_ID = v_USAGE_WRF_STATISTICS.TEMPLATE_ID;
		 EXCEPTION
		 	WHEN NO_DATA_FOUND THEN
				v_EVENT_TEXT := 'No reasonableness criteria found - using defaults for wrf_id '||v_USAGE_WRF_STATISTICS.WRF_ID||' ,template_id '||v_USAGE_WRF_STATISTICS.TEMPLATE_ID;
			  	ERRS.LOG_AND_CONTINUE(v_EVENT_TEXT, LOGS.c_LEVEL_WARN);
			  	v_PARAMETER_MIN := TO_NUMBER(MODEL_VALUE_AT_KEY(0, 'Profiling_Usage', 'Default_Value', 'PARAMETER_MIN')); --0;
				v_PARAMETER_MAX := TO_NUMBER(MODEL_VALUE_AT_KEY(0, 'Profiling_Usage', 'Default_Value', 'PARAMETER_MAX')); --70;
				v_PARAMETER_MIN_TOLERANCE := TO_NUMBER(MODEL_VALUE_AT_KEY(0, 'Profiling_Usage', 'Default_Value', 'PARAMETER_MIN_TOLERANCE')); --.25;
				v_PARAMETER_MAX_TOLERANCE := TO_NUMBER(MODEL_VALUE_AT_KEY(0, 'Profiling_Usage', 'Default_Value', 'PARAMETER_MAX_TOLERANCE')); --.25;
		 	  WHEN OTHERS THEN
				v_EVENT_TEXT := 'Error Occurred - WRF_ID = '||v_USAGE_WRF_STATISTICS.WRF_ID||' , TEMPLATE = '||TEXT_UTIL.TO_CHAR_ENTITY(v_USAGE_WRF_STATISTICS.TEMPLATE_ID, EC.ED_TEMPLATE);
				ERRS.LOG_AND_RAISE(v_EVENT_TEXT);
	END;

	v_USAGE_WRF_STATISTICS.AVG_Y_LOW_WARNING := GREATEST(ROUND((v_USAGE_WRF_STATISTICS.AVG_ALPHA + (v_PARAMETER_MIN*v_USAGE_WRF_STATISTICS.AVG_BETA)),2),0);
	v_USAGE_WRF_STATISTICS.AVG_Y_HIGH_WARNING := GREATEST(ROUND((v_USAGE_WRF_STATISTICS.AVG_ALPHA + (v_PARAMETER_MAX*v_USAGE_WRF_STATISTICS.AVG_BETA)),2),0);
	v_USAGE_WRF_STATISTICS.AVG_Y_MIN := (1-v_PARAMETER_MIN_TOLERANCE)*v_USAGE_WRF_STATISTICS.AVG_Y_LOW_WARNING;
	v_USAGE_WRF_STATISTICS.AVG_Y_MAX := (1+v_PARAMETER_MAX_TOLERANCE)*v_USAGE_WRF_STATISTICS.AVG_Y_LOW_WARNING;
	--end msg code added for change order 23 06/13/2002


	PUT_USAGE_WRF_STATISTICS(v_USAGE_WRF_STATISTICS);

END COMPUTE_USAGE_WRF_STATISTICS;
----------------------------------------------------------------------------------------------------
PROCEDURE ALIGN_BILL_PERIOD_TO_SEASON
	(
	p_SEASON_BEGIN_DATE IN DATE,
	p_SEASON_END_DATE IN DATE,
	p_BILL_PERIOD_BEGIN_DATE IN DATE,
	p_BILL_PERIOD_END_DATE IN DATE,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE
	) AS

BEGIN

	IF DATE_IS_WITHIN_SEASON(p_BILL_PERIOD_BEGIN_DATE, p_SEASON_BEGIN_DATE, p_SEASON_END_DATE) = 'Y' THEN
		p_BEGIN_DATE := p_BILL_PERIOD_BEGIN_DATE;
		IF DATE_IS_WITHIN_SEASON(p_BILL_PERIOD_END_DATE, p_SEASON_BEGIN_DATE, p_SEASON_END_DATE) = 'Y' THEN
			p_END_DATE := p_BILL_PERIOD_END_DATE;
		ELSE
			p_END_DATE := TO_DATE(TO_CHAR(p_SEASON_END_DATE,'MMDD') || TO_CHAR(p_BEGIN_DATE,'YYYY'),'MMDDYYYY');
		END IF;
	ELSE
		IF DATE_IS_WITHIN_SEASON(p_BILL_PERIOD_END_DATE, p_SEASON_BEGIN_DATE, p_SEASON_END_DATE) = 'Y' THEN
			p_END_DATE := p_BILL_PERIOD_END_DATE;
		ELSE
			p_END_DATE := TO_DATE(TO_CHAR(p_SEASON_END_DATE,'MMDD') || TO_CHAR(p_BILL_PERIOD_END_DATE,'YYYY'),'MMDDYYYY');
			IF p_END_DATE > p_BILL_PERIOD_END_DATE THEN
			   p_END_DATE := TO_DATE(TO_CHAR(p_SEASON_END_DATE,'MMDD') || TO_CHAR(p_BILL_PERIOD_BEGIN_DATE,'YYYY'),'MMDDYYYY');
			END IF;
		END IF;
		p_BEGIN_DATE := TO_DATE(TO_CHAR(p_SEASON_BEGIN_DATE,'MMDD') || TO_CHAR(p_END_DATE,'YYYY'),'MMDDYYYY');
        IF p_BEGIN_DATE > p_END_DATE THEN  --Season spans years
           p_BEGIN_DATE := ADD_MONTHS(p_BEGIN_DATE,-12);   --Back up 1 year
		END IF;
	END IF;

END ALIGN_BILL_PERIOD_TO_SEASON;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_PARAM_FOR_USAGE_TEMPLATE
	(
	p_TEMPLATE_ID IN NUMBER,
	p_PARAMETERS IN OUT NOCOPY GA.ID_TABLE
	) AS

v_INDEX PLS_INTEGER := 1;

CURSOR c_PARMS IS
	SELECT PARAMETER_ID
	FROM TEMPLATE_BREAKPOINT
	WHERE TEMPLATE_ID = p_TEMPLATE_ID
       	AND PARAMETER_ID <> CONSTANTS.NOT_ASSIGNED
	ORDER BY VARIABLE_NBR;

BEGIN
	p_PARAMETERS.DELETE;
	FOR v_PARM IN c_PARMS LOOP
        p_PARAMETERS(v_INDEX) := v_PARM.PARAMETER_ID;
    	v_INDEX := v_INDEX+1;
    END LOOP;

END GET_PARAM_FOR_USAGE_TEMPLATE;
---------------------------------------------------------------------------------------------------
PROCEDURE CREATE_USAGE_WRF_PROFILE
	(
    p_ACCOUNT_ID IN NUMBER,
	p_STATION_ID IN NUMBER,
	p_PARAMETER_ID IN NUMBER,
    p_TEMPLATE_ID IN NUMBER,
	p_WRF_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_OUTPUT_AS_OF_DATE IN DATE,
    p_PROFILE_ID OUT NUMBER,
    p_STATUS OUT NUMBER
    ) AS

v_PARAMETERS GA.ID_TABLE;
v_PROFILE_SOURCE_ID NUMBER;
v_PROFILE_LIBRARY_ID NUMBER;
v_ACCOUNT_NAME VARCHAR(64);
v_CALENDAR_NAME VARCHAR(64);
v_PROFILE_NAME VARCHAR(128);
v_LIBRARY_NAME VARCHAR(128);
v_TEMPLATE_NAME VARCHAR(32);
v_INTERVALS_PER_DAY NUMBER := 1;  -- GAS Model ONLY FOR now

BEGIN

	p_STATUS := GA.SUCCESS;

    SELECT TEMPLATE_NAME INTO v_TEMPLATE_NAME
    FROM TEMPLATE WHERE TEMPLATE_ID = p_TEMPLATE_ID;

	v_PROFILE_SOURCE_ID := p_WRF_ID;

    v_ACCOUNT_NAME := CS.GET_ACCOUNT_NAME(p_ACCOUNT_ID);

    v_PARAMETERS.DELETE;
    v_PARAMETERS(1) := p_PARAMETER_ID;

    -- get existing or create new library and profile
	v_LIBRARY_NAME := v_ACCOUNT_NAME || '_UsageLibrary';
	PUT_LOAD_PROFILE_LIBRARY(v_LIBRARY_NAME, v_PROFILE_LIBRARY_ID);

    v_PROFILE_NAME := v_ACCOUNT_NAME || '_' || v_TEMPLATE_NAME || '_Usage';
	PUT_LOAD_PROFILE(v_PROFILE_NAME, v_PROFILE_LIBRARY_ID, 'UsageWRF', p_ACCOUNT_ID, CONSTANTS.NOT_ASSIGNED, v_PROFILE_SOURCE_ID, p_BEGIN_DATE, p_END_DATE , p_OUTPUT_AS_OF_DATE, p_TEMPLATE_ID, p_STATION_ID, v_TEMPLATE_NAME, v_INTERVALS_PER_DAY, p_PROFILE_ID);

	v_CALENDAR_NAME := v_ACCOUNT_NAME;  --Should probably expand Calendar_Name to size of  Library_Name and use that
    ASSIGN_LIBRARY_TO_CALENDAR(v_LIBRARY_NAME, v_CALENDAR_NAME, p_ACCOUNT_ID, p_STATUS);

    PUT_LOAD_PROFILE_WRF_WEATHER(p_PROFILE_ID, v_PARAMETERS);

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_RAISE();

END CREATE_USAGE_WRF_PROFILE;
---------------------------------------------------------------------------------------------------
PROCEDURE APPLY_ACCOUNT_USAGE_WRF
	(
	p_MODEL_ID IN NUMBER,
	p_WRF_ID IN NUMBER,
	p_STATION_ID IN NUMBER,
	p_PARAMETER_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_DEFAULT_ALPHA IN NUMBER,
	p_DEFAULT_BETA IN NUMBER
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_PARAMETER_VAL NUMBER;
v_USAGE_VAL NUMBER;
v_DAYS NUMBER;
v_POINTS UT.POINTS;
v_INITIAL BOOLEAN := TRUE;
v_ACCOUNT_ID NUMBER := CONSTANTS.NOT_ASSIGNED;
v_ACCOUNT_USAGE_WRF_LINE ACCOUNT_USAGE_WRF_LINE%ROWTYPE;
v_COUNT PLS_INTEGER := 0;
v_DEFAULT_ASSIGNMENTS NUMBER := 0;
v_WRF_MIN NUMBER := 999999999;
v_WRF_MAX NUMBER := -999999999;
v_R2_MIN NUMBER := 999999999;
v_R2_MAX NUMBER := -999999999;
v_ALPHA GA.NUMBER_TABLE;
v_BETA GA.NUMBER_TABLE;
v_ACCOUNT_COUNT PLS_INTEGER := 0;
v_EVENT_TEXT PROCESS_LOG_EVENT.EVENT_TEXT%TYPE;
v_STATUS NUMBER;
v_PROFILE_ID NUMBER;
v_ACCOUNT_USAGE_WRF_COUNT NUMBER(9);
v_PROGRESS_RANGE_IDX PLS_INTEGER;

CURSOR c_ACCOUNT IS
	SELECT /*+ ORDERED */ A.ACCOUNT_ID, B.BEGIN_DATE, B.END_DATE, B.BILLED_USAGE, C.BEGIN_DATE "SEASON_BEGIN_DATE", C.END_DATE "SEASON_END_DATE"
	FROM ACCOUNT_USAGE_WRF A,
         ACCOUNT_SERVICE D,
         SERVICE E,
         SERVICE_CONSUMPTION B,
         USAGE_WRF_SEASON C,
		 SEASON_DATES F
	WHERE A.WRF_ID = p_WRF_ID
		AND A.BEGIN_DATE <= p_END_DATE
		AND NVL(A.END_DATE, p_END_DATE) >= p_BEGIN_DATE
        AND D.ACCOUNT_ID = A.ACCOUNT_ID    --Get service_consumption records for the account thru account_service
        AND E.MODEL_ID = p_MODEL_ID
        AND E.ACCOUNT_SERVICE_ID = D.ACCOUNT_SERVICE_ID
		AND B.SERVICE_ID = E.SERVICE_ID
		AND B.BEGIN_DATE <= p_END_DATE  -- Meter read TOUCHES date range.
		AND B.END_DATE >= p_BEGIN_DATE  -- Meter read TOUCHES date range.
		AND C.WRF_ID = A.WRF_ID  --join
		AND C.WRF_ID = p_WRF_ID  --specify for speed
		AND C.TEMPLATE_ID = p_TEMPLATE_ID
		AND C.AS_OF_DATE = p_OUTPUT_AS_OF_DATE
		AND F.SEASON_ID = C.SEASON_ID
        AND B.BEGIN_DATE  <= F.END_DATE
		AND B.END_DATE    >= F.BEGIN_DATE
		AND B.UNIT_OF_MEASUREMENT = GA.DEFAULT_UNIT_OF_MEASUREMENT

UNION ALL
	SELECT 9999999, LOW_DATE, LOW_DATE, 0, LOW_DATE, LOW_DATE FROM DUAL
	ORDER BY 1;

BEGIN
	-- clear out old entries first
	DELETE ACCOUNT_USAGE_WRF_LINE
	WHERE WRF_ID = p_WRF_ID
		AND TEMPLATE_ID = p_TEMPLATE_ID;

	v_ACCOUNT_USAGE_WRF_LINE.WRF_ID := p_WRF_ID;
	v_ACCOUNT_USAGE_WRF_LINE.TEMPLATE_ID := p_TEMPLATE_ID;
	v_ACCOUNT_USAGE_WRF_LINE.SEGMENT_NBR := g_DEFAULT_SEGMENT;
	v_ACCOUNT_USAGE_WRF_LINE.AS_OF_DATE := p_OUTPUT_AS_OF_DATE;

	PUT_USAGE_WRF_SEASON(p_WRF_ID, p_TEMPLATE_ID, p_OUTPUT_AS_OF_DATE);

	-- Get Progress count for the loop
	SELECT /*+ ORDERED */ COUNT(1) + 1
	INTO v_ACCOUNT_USAGE_WRF_COUNT
	FROM ACCOUNT_USAGE_WRF A,
         ACCOUNT_SERVICE D,
         SERVICE E,
         SERVICE_CONSUMPTION B,
         USAGE_WRF_SEASON C,
		 SEASON_DATES F
	WHERE A.WRF_ID = p_WRF_ID
		AND A.BEGIN_DATE <= p_END_DATE
		AND NVL(A.END_DATE, p_END_DATE) >= p_BEGIN_DATE
        AND D.ACCOUNT_ID = A.ACCOUNT_ID    --Get service_consumption records for the account thru account_service
        AND E.MODEL_ID = p_MODEL_ID
        AND E.ACCOUNT_SERVICE_ID = D.ACCOUNT_SERVICE_ID
		AND B.SERVICE_ID = E.SERVICE_ID
		AND B.BEGIN_DATE <= p_END_DATE  -- Meter read TOUCHES date range.
		AND B.END_DATE >= p_BEGIN_DATE  -- Meter read TOUCHES date range.
		AND C.WRF_ID = A.WRF_ID  --join
		AND C.WRF_ID = p_WRF_ID  --specify for speed
		AND C.TEMPLATE_ID = p_TEMPLATE_ID
		AND C.AS_OF_DATE = p_OUTPUT_AS_OF_DATE
		AND F.SEASON_ID = C.SEASON_ID
        AND B.BEGIN_DATE  <= F.END_DATE
		AND B.END_DATE    >= F.BEGIN_DATE
		AND B.UNIT_OF_MEASUREMENT = GA.DEFAULT_UNIT_OF_MEASUREMENT;

	-- Update the Progress with a new range
	v_PROGRESS_RANGE_IDX := LOGS.PUSH_PROGRESS_RANGE(v_ACCOUNT_USAGE_WRF_COUNT);

	FOR v_ACCOUNT IN c_ACCOUNT LOOP

		IF v_INITIAL THEN
			v_ACCOUNT_ID := v_ACCOUNT.ACCOUNT_ID;
			v_ACCOUNT_COUNT := 1;
			v_EVENT_TEXT := 'Begin Calculation for WRF_ID=' || TO_CHAR(p_WRF_ID) || ', TEMPLATE_ID=' || TO_CHAR(p_TEMPLATE_ID);
			LOGS.LOG_DEBUG(v_EVENT_TEXT);
			v_INITIAL := FALSE;
		END IF;

		IF NOT v_ACCOUNT_ID = v_ACCOUNT.ACCOUNT_ID THEN
			v_ACCOUNT_USAGE_WRF_LINE.ACCOUNT_ID := v_ACCOUNT_ID;
			UT.LIN_REG(v_POINTS,
				v_ACCOUNT_USAGE_WRF_LINE.ALPHA, v_ACCOUNT_USAGE_WRF_LINE.BETA,
				v_ACCOUNT_USAGE_WRF_LINE.N, v_ACCOUNT_USAGE_WRF_LINE.R2,
				v_ACCOUNT_USAGE_WRF_LINE.X_MIN, v_ACCOUNT_USAGE_WRF_LINE.X_MAX,
				v_ACCOUNT_USAGE_WRF_LINE.Y_MIN, v_ACCOUNT_USAGE_WRF_LINE.Y_MAX,
				v_ACCOUNT_USAGE_WRF_LINE.X_ZERO, v_ACCOUNT_USAGE_WRF_LINE.Y_ZERO);
			IF v_POINTS.COUNT < g_ACCOUNT_USAGE_WRF_MIN_POINTS THEN
				v_ACCOUNT_USAGE_WRF_LINE.ALPHA := p_DEFAULT_ALPHA;
				v_ACCOUNT_USAGE_WRF_LINE.BETA := p_DEFAULT_BETA;
				v_ACCOUNT_USAGE_WRF_LINE.R2 := v_ACCOUNT_USAGE_WRF_LINE.N * -1; -- Flag the use of the Default WRF.
			END IF;
			v_POINTS.DELETE;

            --Put the USAGE_WRF_LINE
			PUT_ACCOUNT_USAGE_WRF_LINE(v_ACCOUNT_USAGE_WRF_LINE);

			--Create Usage WRF Profile and Library, assign Lib and Acct to Calendar, return v_PROFILE_ID
		    CREATE_USAGE_WRF_PROFILE(v_ACCOUNT_ID, p_STATION_ID, p_PARAMETER_ID, p_TEMPLATE_ID, p_WRF_ID, p_BEGIN_DATE, p_END_DATE, p_OUTPUT_AS_OF_DATE, v_PROFILE_ID, v_STATUS);

			--IF R2 LESS THAN 0 IT HAS BEEN ASSIGNED DEFAULT VALUE AND SHOULD NOT BE INCLUDED IN AVERAGE
			IF v_ACCOUNT_USAGE_WRF_LINE.R2 >= 0 THEN
				v_WRF_MIN := LEAST(v_ACCOUNT_USAGE_WRF_LINE.ALPHA + v_ACCOUNT_USAGE_WRF_LINE.BETA * v_ACCOUNT_USAGE_WRF_LINE.X_MIN, v_WRF_MIN);
				v_WRF_MAX := GREATEST(v_ACCOUNT_USAGE_WRF_LINE.ALPHA + v_ACCOUNT_USAGE_WRF_LINE.BETA * v_ACCOUNT_USAGE_WRF_LINE.X_MAX, v_WRF_MAX);
				v_R2_MIN := LEAST(v_ACCOUNT_USAGE_WRF_LINE.R2, v_R2_MIN);
				v_R2_MAX := GREATEST(v_ACCOUNT_USAGE_WRF_LINE.R2, v_R2_MAX);
				v_ALPHA(v_ALPHA.COUNT+1) := v_ACCOUNT_USAGE_WRF_LINE.ALPHA;
				v_BETA(v_BETA.COUNT+1) := v_ACCOUNT_USAGE_WRF_LINE.BETA;
				v_COUNT := v_COUNT + 1;
			END IF;

            --Put Statistics
        	PUT_LOAD_PROFILE_STATISTICS (v_PROFILE_ID, GET_PROFILE_VERSION_ID(p_OUTPUT_AS_OF_DATE),
            	p_OUTPUT_AS_OF_DATE, p_BEGIN_DATE, p_END_DATE, v_COUNT, 0.0,
                --v_p_MIN, v_P_NZMIN, v_P_MAX, v_P_SUM, v_MAPE, v_STDAPE, v_TOT_ERROR_PCT, v_R2MIN, v_R2MAX, v_R2FAIL,
                v_WRF_MIN, v_WRF_MIN, v_WRF_MAX, 0, 0, 0, 0, 0, 0, 0,
                --v_T_TEMP, v_T_HUMID, v_T_WIND, 'Pending', p_STATUS);
                0, 0, 0, 'Pending', v_STATUS);

			IF v_ACCOUNT.ACCOUNT_ID = 9999999 THEN
				EXIT;
			END IF;
		END IF;

        v_BEGIN_DATE := v_ACCOUNT.BEGIN_DATE;
		v_END_DATE   := v_ACCOUNT.END_DATE;

		GET_STATION_PARAMETER(p_STATION_ID, p_PARAMETER_ID, v_BEGIN_DATE, v_END_DATE, v_PARAMETER_VAL);

		v_DAYS := (v_ACCOUNT.END_DATE - v_ACCOUNT.BEGIN_DATE) + 1;

		IF v_DAYS > 0 THEN
			v_USAGE_VAL := ROUND(v_ACCOUNT.BILLED_USAGE / v_DAYS, 4);
		ELSE
			v_USAGE_VAL := 0;
		END IF;

		v_POINTS(v_POINTS.COUNT + 1).Y := v_USAGE_VAL;
		v_POINTS(v_POINTS.COUNT).X := NVL(v_PARAMETER_VAL,0);
 		IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
 			LOGS.LOG_DEBUG_DETAIL(TO_CHAR(v_ACCOUNT.BEGIN_DATE) || ',' || TO_CHAR(v_ACCOUNT.END_DATE) || ',' || TO_CHAR(v_ACCOUNT.BILLED_USAGE) || ',' || TO_CHAR(NVL(v_PARAMETER_VAL,0)) || ',' || TO_CHAR(v_DAYS) || ',' || TO_CHAR(v_POINTS(v_POINTS.COUNT).Y));
			LOGS.LOG_DEBUG_DETAIL(TO_CHAR(v_ACCOUNT.ACCOUNT_ID) || '-' || TO_CHAR(p_WRF_ID) || '-' || TO_CHAR(p_TEMPLATE_ID) || g_TAB  || TO_CHAR(v_POINTS(v_POINTS.COUNT).X) || g_TAB || TO_CHAR(v_POINTS(v_POINTS.COUNT).Y));
 		END IF;
		v_ACCOUNT_ID := v_ACCOUNT.ACCOUNT_ID;

		LOGS.INCREMENT_PROCESS_PROGRESS(p_RANGE_INDEX => v_PROGRESS_RANGE_IDX);
	END LOOP;
	LOGS.POP_PROGRESS_RANGE(v_PROGRESS_RANGE_IDX);

	v_EVENT_TEXT := 'Total Account Usage WRF Profiles Calculated:  ' || TO_CHAR(v_ACCOUNT_COUNT);
	LOGS.LOG_DEBUG(v_EVENT_TEXT);

	IF v_COUNT > 0 THEN
		COMPUTE_USAGE_WRF_STATISTICS(p_WRF_ID, p_TEMPLATE_ID, g_DEFAULT_SEGMENT, p_BEGIN_DATE, p_END_DATE, p_OUTPUT_AS_OF_DATE,
			v_DEFAULT_ASSIGNMENTS, v_WRF_MIN, v_WRF_MAX, v_R2_MIN, v_R2_MAX, v_ALPHA, v_BETA);
		IF g_ALLOW_COMMIT_ROLLBACK THEN COMMIT; END IF;
	END IF;

	v_EVENT_TEXT := 'Usage WRF Statistics Calculated for WRF_ID=' || TO_CHAR(p_WRF_ID) || ', TEMPLATE_ID=' || TO_CHAR(p_TEMPLATE_ID);
	LOGS.LOG_DEBUG(v_EVENT_TEXT);

END APPLY_ACCOUNT_USAGE_WRF;
---------------------------------------------------------------------------------------------------
PROCEDURE APPLY_CUSTOMER_USAGE_WRF
	(
	p_WRF_ID IN NUMBER,
	p_STATION_ID IN NUMBER,
	p_PARAMETER_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_DEFAULT_ALPHA IN NUMBER,
	p_DEFAULT_BETA IN NUMBER
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_PARAMETER_VAL NUMBER;
v_USAGE_VAL NUMBER;
v_DAYS NUMBER;
v_POINTS UT.POINTS;
v_INITIAL BOOLEAN := TRUE;
v_CUSTOMER_ID NUMBER := CONSTANTS.NOT_ASSIGNED;
v_CUSTOMER_USAGE_WRF_LINE CUSTOMER_USAGE_WRF_LINE%ROWTYPE;
v_COUNT PLS_INTEGER := 0;
v_DEFAULT_ASSIGNMENTS NUMBER := 0;
v_WRF_MIN NUMBER := 999999999;
v_WRF_MAX NUMBER := -999999999;
v_R2_MIN NUMBER := 999999999;
v_R2_MAX NUMBER := -999999999;
v_ALPHA GA.NUMBER_TABLE;
v_BETA GA.NUMBER_TABLE;
v_CUSTOMER_COUNT PLS_INTEGER := 0;
v_EVENT_TEXT PROCESS_LOG_EVENT.EVENT_TEXT%TYPE;
v_CUSTOMER_USAGE_WRF_COUNT NUMBER(9);
v_PROGRESS_RANGE_IDX PLS_INTEGER;

CURSOR c_CUSTOMER IS
	SELECT A.CUSTOMER_ID, B.BEGIN_DATE, B.END_DATE, B.BILLED_USAGE, C.BEGIN_DATE "SEASON_BEGIN_DATE", C.END_DATE "SEASON_END_DATE"
	FROM CUSTOMER_USAGE_WRF A, CUSTOMER_CONSUMPTION B, USAGE_WRF_SEASON C, SEASON_DATES F
	WHERE A.WRF_ID = p_WRF_ID
		AND A.BEGIN_DATE <= p_END_DATE
		AND NVL(A.END_DATE, p_END_DATE) >= p_BEGIN_DATE
		AND B.CUSTOMER_ID = A.CUSTOMER_ID
		AND B.BEGIN_DATE <= p_END_DATE  -- Meter read TOUCHES date range.
		AND B.END_DATE >= p_BEGIN_DATE  -- Meter read TOUCHES date range.
		AND C.WRF_ID = A.WRF_ID  --join
		AND C.WRF_ID = p_WRF_ID  --specify for speed
		AND C.TEMPLATE_ID = p_TEMPLATE_ID
		AND C.AS_OF_DATE = p_OUTPUT_AS_OF_DATE
		AND F.SEASON_ID = C.SEASON_ID
        AND B.BEGIN_DATE  <= F.END_DATE
		AND B.END_DATE    >= F.BEGIN_DATE
UNION ALL
	SELECT 9999999, LOW_DATE, LOW_DATE, 0, LOW_DATE, LOW_DATE FROM DUAL
	ORDER BY 1;

BEGIN

	-- clear out old entries first
	DELETE CUSTOMER_USAGE_WRF_LINE
	WHERE WRF_ID = p_WRF_ID
		AND TEMPLATE_ID = p_TEMPLATE_ID;

	v_CUSTOMER_USAGE_WRF_LINE.WRF_ID := p_WRF_ID;
	v_CUSTOMER_USAGE_WRF_LINE.TEMPLATE_ID := p_TEMPLATE_ID;
	v_CUSTOMER_USAGE_WRF_LINE.SEGMENT_NBR := g_DEFAULT_SEGMENT;
	v_CUSTOMER_USAGE_WRF_LINE.AS_OF_DATE := p_OUTPUT_AS_OF_DATE;

	PUT_USAGE_WRF_SEASON(p_WRF_ID, p_TEMPLATE_ID, p_OUTPUT_AS_OF_DATE);

	-- Get the Progress count for the loop
	SELECT COUNT(1) + 1
	INTO v_CUSTOMER_USAGE_WRF_COUNT
	FROM CUSTOMER_USAGE_WRF A, CUSTOMER_CONSUMPTION B, USAGE_WRF_SEASON C, SEASON_DATES F
	WHERE A.WRF_ID = p_WRF_ID
		AND A.BEGIN_DATE <= p_END_DATE
		AND NVL(A.END_DATE, p_END_DATE) >= p_BEGIN_DATE
		AND B.CUSTOMER_ID = A.CUSTOMER_ID
		AND B.BEGIN_DATE <= p_END_DATE  -- Meter read TOUCHES date range.
		AND B.END_DATE >= p_BEGIN_DATE  -- Meter read TOUCHES date range.
		AND C.WRF_ID = A.WRF_ID  --join
		AND C.WRF_ID = p_WRF_ID  --specify for speed
		AND C.TEMPLATE_ID = p_TEMPLATE_ID
		AND C.AS_OF_DATE = p_OUTPUT_AS_OF_DATE
		AND F.SEASON_ID = C.SEASON_ID
        AND B.BEGIN_DATE  <= F.END_DATE
		AND B.END_DATE    >= F.BEGIN_DATE;

	-- Update the Progress with a new range
	v_PROGRESS_RANGE_IDX := LOGS.PUSH_PROGRESS_RANGE(v_CUSTOMER_USAGE_WRF_COUNT);

	FOR v_CUSTOMER IN c_CUSTOMER LOOP

		IF v_INITIAL THEN
			v_CUSTOMER_ID := v_CUSTOMER.CUSTOMER_ID;
			v_CUSTOMER_COUNT := 1;
			v_EVENT_TEXT := 'Begin Calculation for WRF_ID=' || TO_CHAR(p_WRF_ID) || ', TEMPLATE_ID=' || TO_CHAR(p_TEMPLATE_ID);
			LOGS.LOG_DEBUG(v_EVENT_TEXT);
			v_INITIAL := FALSE;
		END IF;

		IF NOT v_CUSTOMER_ID = v_CUSTOMER.CUSTOMER_ID THEN
			v_CUSTOMER_USAGE_WRF_LINE.CUSTOMER_ID := v_CUSTOMER_ID;
			UT.LIN_REG(v_POINTS,
				v_CUSTOMER_USAGE_WRF_LINE.ALPHA, v_CUSTOMER_USAGE_WRF_LINE.BETA,
				v_CUSTOMER_USAGE_WRF_LINE.N, v_CUSTOMER_USAGE_WRF_LINE.R2,
				v_CUSTOMER_USAGE_WRF_LINE.X_MIN, v_CUSTOMER_USAGE_WRF_LINE.X_MAX,
				v_CUSTOMER_USAGE_WRF_LINE.Y_MIN, v_CUSTOMER_USAGE_WRF_LINE.Y_MAX,
				v_CUSTOMER_USAGE_WRF_LINE.X_ZERO, v_CUSTOMER_USAGE_WRF_LINE.Y_ZERO);
			IF v_POINTS.COUNT < GA.CUSTOMER_USAGE_WRF_MIN_POINTS THEN
				v_CUSTOMER_USAGE_WRF_LINE.ALPHA := p_DEFAULT_ALPHA;
				v_CUSTOMER_USAGE_WRF_LINE.BETA := p_DEFAULT_BETA;
				v_CUSTOMER_USAGE_WRF_LINE.R2 := v_CUSTOMER_USAGE_WRF_LINE.N * -1; -- Flag the use of the Default WRF.
			END IF;
			v_POINTS.DELETE;
			PUT_CUSTOMER_USAGE_WRF_LINE(v_CUSTOMER_USAGE_WRF_LINE);

			--IF R2 LESS THAN 0 IT HAS BEEN ASSIGNED DEFAULT VALUE AND SHOULD NOT BE INCLUDED IN AVERAGE
            IF v_CUSTOMER_USAGE_WRF_LINE.R2 >= 0 THEN
    			v_WRF_MIN := LEAST(v_CUSTOMER_USAGE_WRF_LINE.ALPHA + v_CUSTOMER_USAGE_WRF_LINE.BETA * v_CUSTOMER_USAGE_WRF_LINE.X_MIN, v_WRF_MIN);
    			v_WRF_MAX := GREATEST(v_CUSTOMER_USAGE_WRF_LINE.ALPHA + v_CUSTOMER_USAGE_WRF_LINE.BETA * v_CUSTOMER_USAGE_WRF_LINE.X_MAX, v_WRF_MAX);
    			v_R2_MIN := LEAST(v_CUSTOMER_USAGE_WRF_LINE.R2, v_R2_MIN);
    			v_R2_MAX := GREATEST(v_CUSTOMER_USAGE_WRF_LINE.R2, v_R2_MAX);
    			v_ALPHA(v_ALPHA.COUNT+1) := v_CUSTOMER_USAGE_WRF_LINE.ALPHA;
    			v_BETA(v_BETA.COUNT+1) := v_CUSTOMER_USAGE_WRF_LINE.BETA;
    			v_COUNT := v_COUNT + 1;
			END IF;

			IF v_CUSTOMER.CUSTOMER_ID = 9999999 THEN
				EXIT;
			END IF;
		END IF;

        v_BEGIN_DATE := v_CUSTOMER.BEGIN_DATE;
		v_END_DATE   := v_CUSTOMER.END_DATE;
		GET_STATION_PARAMETER(p_STATION_ID, p_PARAMETER_ID, v_BEGIN_DATE, v_END_DATE, v_PARAMETER_VAL);
		v_DAYS := (v_CUSTOMER.END_DATE - v_CUSTOMER.BEGIN_DATE) + 1;

		IF v_DAYS > 0 THEN
			v_USAGE_VAL := ROUND(v_CUSTOMER.BILLED_USAGE / v_DAYS, 4);
		ELSE
			v_USAGE_VAL := 0;
		END IF;

		v_POINTS(v_POINTS.COUNT + 1).Y := v_USAGE_VAL;
		v_POINTS(v_POINTS.COUNT).X := NVL(v_PARAMETER_VAL,0);
		IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
			LOGS.LOG_DEBUG_DETAIL(TO_CHAR(v_CUSTOMER.BEGIN_DATE) || ',' || TO_CHAR(v_CUSTOMER.END_DATE) || ',' || TO_CHAR(v_CUSTOMER.BILLED_USAGE) || ',' || TO_CHAR(NVL(v_PARAMETER_VAL,0)) || ',' || TO_CHAR(v_DAYS) || ',' || TO_CHAR(v_POINTS(v_POINTS.COUNT).Y));
			LOGS.LOG_DEBUG_DETAIL(TO_CHAR(v_CUSTOMER.CUSTOMER_ID) || '-' || TO_CHAR(p_WRF_ID) || '-' || TO_CHAR(p_TEMPLATE_ID) || g_TAB  || TO_CHAR(v_POINTS(v_POINTS.COUNT).X) || g_TAB || TO_CHAR(v_POINTS(v_POINTS.COUNT).Y));
 		END IF;
		v_CUSTOMER_ID := v_CUSTOMER.CUSTOMER_ID;

		LOGS.INCREMENT_PROCESS_PROGRESS(p_RANGE_INDEX => v_PROGRESS_RANGE_IDX);
	END LOOP;
	LOGS.POP_PROGRESS_RANGE(v_PROGRESS_RANGE_IDX);

	v_EVENT_TEXT := 'Total Customer Usage WRF Profiles Calculated:  ' || TO_CHAR(v_CUSTOMER_COUNT);
	LOGS.LOG_DEBUG(v_EVENT_TEXT);

	IF v_COUNT > 0 THEN
		COMPUTE_USAGE_WRF_STATISTICS(p_WRF_ID, p_TEMPLATE_ID, g_DEFAULT_SEGMENT, p_BEGIN_DATE, p_END_DATE, p_OUTPUT_AS_OF_DATE,
			v_DEFAULT_ASSIGNMENTS, v_WRF_MIN, v_WRF_MAX, v_R2_MIN, v_R2_MAX, v_ALPHA, v_BETA);
		IF g_ALLOW_COMMIT_ROLLBACK THEN COMMIT; END IF;
	END IF;

	v_EVENT_TEXT := 'Usage WRF Statistics Calculated for WRF_ID=' || TO_CHAR(p_WRF_ID) || ', TEMPLATE_ID=' || TO_CHAR(p_TEMPLATE_ID);
	LOGS.LOG_DEBUG(v_EVENT_TEXT);

END APPLY_CUSTOMER_USAGE_WRF;
---------------------------------------------------------------------------------------------------
PROCEDURE USAGE_WRF_REQUEST
	(
	p_MODEL_ID IN NUMBER,
	p_ENTITY_TYPE IN VARCHAR,
	p_PROCESS_ID IN NUMBER,
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_REQUESTOR IN VARCHAR,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

v_PROGRESS_COUNT NUMBER(9);
v_AS_OF_DATE DATE;

CURSOR c_WRF IS
	SELECT A.WRF_ID, A.STATION_ID, A.PARAMETER_ID, B.TEMPLATE_ID, B.ALPHA, B.BETA
	FROM USAGE_WRF A, USAGE_WRF_TEMPLATE B
	WHERE A.WRF_ID = DECODE(p_WRF_ID, CONSTANTS.ALL_ID, A.WRF_ID, p_WRF_ID)
		AND B.WRF_ID = A.WRF_ID
		AND B.TEMPLATE_ID = DECODE(p_TEMPLATE_ID, CONSTANTS.ALL_ID, B.TEMPLATE_ID, p_TEMPLATE_ID);

BEGIN

	LOGS.START_PROCESS('Calculate Usage WRFs',
					   p_BEGIN_DATE,
					   p_END_DATE,
					   p_EVENT_LEVEL => CASE WHEN p_TRACE_ON > 0 THEN LOGS.c_LEVEL_DEBUG_MORE_DETAIL ELSE NULL END);

	LOGS.SET_PROCESS_TARGET_PARAMETER('WRF_ID',TO_CHAR(p_WRF_ID));
	LOGS.SET_PROCESS_TARGET_PARAMETER('TEMPLATE_ID',TO_CHAR(p_TEMPLATE_ID));
	LOGS.SET_PROCESS_TARGET_PARAMETER('INPUT_AS_OF_DATE',TEXT_UTIL.TO_CHAR_DATE(p_INPUT_AS_OF_DATE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('OUTPUT_AS_OF_DATE',TEXT_UTIL.TO_CHAR_DATE(p_OUTPUT_AS_OF_DATE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('REQUESTOR',TO_CHAR(p_REQUESTOR));

	IF GA.VERSION_PROFILE THEN
		v_AS_OF_DATE := p_OUTPUT_AS_OF_DATE;
	ELSE
		v_AS_OF_DATE := LOW_DATE;
	END IF;

	-- Get Progress Count
	SELECT COUNT(1)
	INTO v_PROGRESS_COUNT
	FROM USAGE_WRF A, USAGE_WRF_TEMPLATE B
	WHERE A.WRF_ID = DECODE(p_WRF_ID, CONSTANTS.ALL_ID, A.WRF_ID, p_WRF_ID)
		AND B.WRF_ID = A.WRF_ID
		AND B.TEMPLATE_ID = DECODE(p_TEMPLATE_ID, CONSTANTS.ALL_ID, B.TEMPLATE_ID, p_TEMPLATE_ID);

	LOGS.INIT_PROCESS_PROGRESS(p_TOTAL_WORK => v_PROGRESS_COUNT, p_CAN_TERMINATE => TRUE);

	FOR v_WRF IN c_WRF LOOP

		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG('WRF_ID=' || TO_CHAR(v_WRF.WRF_ID));
			LOGS.LOG_DEBUG('STATION_ID=' || TO_CHAR(v_WRF.STATION_ID));
			LOGS.LOG_DEBUG('PARAMETER_ID=' || TO_CHAR(v_WRF.PARAMETER_ID));
			LOGS.LOG_DEBUG('TEMPLATE_ID=' || TO_CHAR(v_WRF.TEMPLATE_ID));
			LOGS.LOG_DEBUG('DEFAULT ALPHA=' || TO_CHAR(v_WRF.ALPHA));
			LOGS.LOG_DEBUG('DEFAULT BETA=' || TO_CHAR(v_WRF.BETA));
			LOGS.LOG_DEBUG('<customer id>,<wrf id>,<season id>,<segment nbr>,<as of>,<alpha>,<beta>,<r2>,<n>,<x min>,<x max>,<y min>,<y max>,<x zero>,<y zero>');
		END IF;

    	IF UPPER(SUBSTR(p_ENTITY_TYPE,1,1)) = c_ENTITY_TYPE_CUSTOMER THEN	--Customer
    		APPLY_CUSTOMER_USAGE_WRF(v_WRF.WRF_ID, v_WRF.STATION_ID, v_WRF.PARAMETER_ID, v_WRF.TEMPLATE_ID, p_BEGIN_DATE, p_END_DATE, v_AS_OF_DATE, v_WRF.ALPHA, v_WRF.BETA);
        ELSE      -- UPPER(SUBSTR(p_ENTITY_TYPE,1,1)) = 'A' THEN	--Account
    		APPLY_ACCOUNT_USAGE_WRF(p_MODEL_ID, v_WRF.WRF_ID, v_WRF.STATION_ID, v_WRF.PARAMETER_ID, v_WRF.TEMPLATE_ID, p_BEGIN_DATE, p_END_DATE, v_AS_OF_DATE, v_WRF.ALPHA, v_WRF.BETA);
        END IF;

		LOGS.INCREMENT_PROCESS_PROGRESS();
	END LOOP;

	LOGS.STOP_PROCESS(p_MESSAGE, p_STATUS);
	COMMIT;

EXCEPTION
	WHEN OTHERS THEN
    	ERRS.ABORT_PROCESS;

END USAGE_WRF_REQUEST;
---------------------------------------------------------------------------------------------------
PROCEDURE USAGE_WRF_REQUEST
	(
	p_PROCESS_ID IN NUMBER,
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_REQUESTOR IN VARCHAR,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS
BEGIN

	USAGE_WRF_REQUEST(NULL, -- MODEL_ID
	 				  c_ENTITY_TYPE_CUSTOMER,
					  p_PROCESS_ID,
					  p_WRF_ID,
					  p_TEMPLATE_ID,
					  p_BEGIN_DATE,
					  p_END_DATE,
					  p_INPUT_AS_OF_DATE,
					  p_OUTPUT_AS_OF_DATE,
					  p_REQUESTOR,
					  p_TRACE_ON,
					  p_STATUS,
					  p_MESSAGE);

END USAGE_WRF_REQUEST;
---------------------------------------------------------------------------------------------------
PROCEDURE USAGE_WRF_REQUEST
	(
	p_PROCESS_ID IN NUMBER,
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_REQUESTOR IN VARCHAR,
	p_TRACE_ON IN NUMBER
	) AS

v_STATUS NUMBER;
v_MESSAGE VARCHAR(128);

BEGIN

	USAGE_WRF_REQUEST(p_PROCESS_ID, p_WRF_ID, p_TEMPLATE_ID, p_BEGIN_DATE, p_END_DATE, p_INPUT_AS_OF_DATE, p_OUTPUT_AS_OF_DATE, p_REQUESTOR, p_TRACE_ON, v_STATUS, v_MESSAGE);

END USAGE_WRF_REQUEST;
---------------------------------------------------------------------------------------------------
PROCEDURE RUN_USAGE_WRF_REQUEST
	(
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_SCHEDULE_RUN IN NUMBER,
	p_RUN_AT IN DATE,
	p_REQUESTOR IN VARCHAR,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

-- Run a Usage WRF Request.

v_JOB_NAME VARCHAR2(64);
v_WHAT VARCHAR(512);

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK';

	IF p_SCHEDULE_RUN = 1 THEN

		v_WHAT := 'PF.USAGE_WRF_REQUEST( NULL,'
			|| TO_CHAR(p_WRF_ID) || ','
			|| TO_CHAR(p_TEMPLATE_ID) || ','
			|| 'TO_DATE(''' || TO_CHAR(p_BEGIN_DATE, 'DD-MON-YYYY') || ''',''DD-MON-YYYY''),'
			|| 'TO_DATE(''' || TO_CHAR(p_END_DATE, 'DD-MON-YYYY') || ''',''DD-MON-YYYY''),'
			|| 'TO_DATE(''' || TO_CHAR(p_INPUT_AS_OF_DATE, 'DD-MON-YYYY HH24:MI:SS') || ''',''DD-MON-YYYY HH24:MI:SS''),'
			|| 'TO_DATE(''' || TO_CHAR(p_OUTPUT_AS_OF_DATE, 'DD-MON-YYYY HH24:MI:SS') || ''',''DD-MON-YYYY HH24:MI:SS''),'
			|| '''' || p_REQUESTOR || ''',' || TO_CHAR(p_TRACE_ON) || ');' ;
		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG('SCHEDULE WRF_USAGE_REQUEST TO RUN AT= ' || TEXT_UTIL.TO_CHAR_DATE(p_RUN_AT));
			LOGS.LOG_DEBUG('WHAT=' || v_WHAT);
		END IF;
		v_JOB_NAME := START_BACKGROUND_JOB(v_WHAT, p_RUN_AT);
	ELSE
		USAGE_WRF_REQUEST(NULL, p_WRF_ID, p_TEMPLATE_ID, p_BEGIN_DATE, p_END_DATE, p_INPUT_AS_OF_DATE, p_OUTPUT_AS_OF_DATE, p_REQUESTOR, p_TRACE_ON, p_STATUS, p_MESSAGE);
	END IF;

END RUN_USAGE_WRF_REQUEST;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_ENTITY_USAGE_WRF_POINTS
	(
	p_ENTITY_ID IN NUMBER,
	p_ENTITY_TYPE IN VARCHAR,
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_STATION_ID IN NUMBER,
	p_PARAMETER_ID IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

--Replaces GET_CUSTOMER_USAGE_WRF_POINTS at v2.3.0 - wjc 05/27/03
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_PARAMETER_VAL NUMBER;
v_USAGE_VAL NUMBER;
v_DAYS NUMBER;
v_WORK_ID NUMBER;

CURSOR c_CUSTOMER_CONSUMPTION IS
	SELECT /*+ ORDERED */ C.BEGIN_DATE, C.END_DATE, C.BILLED_USAGE, D.BEGIN_DATE "SEASON_BEGIN_DATE", D.END_DATE "SEASON_END_DATE"
	--FROM USAGE_WRF_STATISTICS A, CUSTOMER_USAGE_WRF B, CUSTOMER_CONSUMPTION C, USAGE_WRF_SEASON D
	FROM USAGE_WRF_STATISTICS A,
         CUSTOMER_USAGE_WRF B,
         CUSTOMER_CONSUMPTION C,
         USAGE_WRF_SEASON D,
         SEASON_DATES I
	WHERE A.WRF_ID = p_WRF_ID
        AND B.WRF_ID = p_WRF_ID  --specify for speed
        AND D.WRF_ID = p_WRF_ID  --specify for speed
		AND A.TEMPLATE_ID = p_TEMPLATE_ID
		AND A.SEGMENT_NBR = 1
		AND A.AS_OF_DATE = p_AS_OF_DATE
		AND B.CUSTOMER_ID = p_ENTITY_ID
		AND B.WRF_ID = A.WRF_ID
		AND B.BEGIN_DATE <= A.END_DATE
		AND NVL(B.END_DATE, A.END_DATE) >= A.BEGIN_DATE
		AND C.CUSTOMER_ID = B.CUSTOMER_ID
        AND C.CUSTOMER_ID = p_ENTITY_ID  --specify for speed
        AND C.BEGIN_DATE <= A.END_DATE  -- Meter read TOUCHES date range.
        AND C.END_DATE >= A.BEGIN_DATE  -- Meter read TOUCHES date range.
		AND D.WRF_ID = B.WRF_ID
		AND D.TEMPLATE_ID = p_TEMPLATE_ID
		AND D.AS_OF_DATE = p_AS_OF_DATE
		AND I.SEASON_ID = D.SEASON_ID
        AND C.BEGIN_DATE  <= I.END_DATE  --Replace SEASON_INTERSECTS_SEASON fxn
		AND C.END_DATE    >= I.BEGIN_DATE  --Replace SEASON_INTERSECTS_SEASON fxn
	ORDER BY 1,2;

CURSOR c_ACCOUNT_CONSUMPTION IS
	SELECT /*+ ORDERED */ C.BEGIN_DATE, C.END_DATE, C.BILLED_USAGE, D.BEGIN_DATE "SEASON_BEGIN_DATE", D.END_DATE "SEASON_END_DATE"
	FROM USAGE_WRF_STATISTICS A,
         ACCOUNT_USAGE_WRF B,
         ACCOUNT_SERVICE E,
         SERVICE F,
         SERVICE_CONSUMPTION C,
         USAGE_WRF_SEASON D,
         SEASON_DATES I
	WHERE A.WRF_ID = p_WRF_ID
        AND B.WRF_ID = p_WRF_ID  --specify for speed
        AND D.WRF_ID = p_WRF_ID  --specify for speed
		AND E.ACCOUNT_ID = p_ENTITY_ID  --specify for speed
		AND A.TEMPLATE_ID = p_TEMPLATE_ID
		AND A.SEGMENT_NBR = 1
		AND A.AS_OF_DATE = p_AS_OF_DATE
		AND B.ACCOUNT_ID = p_ENTITY_ID
		AND B.WRF_ID = A.WRF_ID
		AND B.BEGIN_DATE <= A.END_DATE
		AND NVL(B.END_DATE, A.END_DATE) >= A.BEGIN_DATE
        AND E.ACCOUNT_ID = B.ACCOUNT_ID    --Get service_consumption records for the account thru account_service
        AND F.ACCOUNT_SERVICE_ID = E.ACCOUNT_SERVICE_ID
		AND C.SERVICE_ID = F.SERVICE_ID
        AND C.BEGIN_DATE <= A.END_DATE  -- Meter read TOUCHES date range.
        AND C.END_DATE >= A.BEGIN_DATE  -- Meter read TOUCHES date range.
		AND D.WRF_ID = B.WRF_ID
		AND D.TEMPLATE_ID = p_TEMPLATE_ID
		AND D.AS_OF_DATE = p_AS_OF_DATE
		AND I.SEASON_ID = D.SEASON_ID
        AND C.BEGIN_DATE  <= I.END_DATE  --Replace SEASON_INTERSECTS_SEASON fxn
		AND C.END_DATE    >= I.BEGIN_DATE  --Replace SEASON_INTERSECTS_SEASON fxn
	    AND C.UNIT_OF_MEASUREMENT = GA.DEFAULT_UNIT_OF_MEASUREMENT
	ORDER BY 1,2;

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.GET_RTO_WORK_ID(v_WORK_ID);

    --Collect Consumption parameter_val and usage_val into rto_work
  	IF UPPER(SUBSTR(p_ENTITY_TYPE,1,1)) = 'C' THEN	--Customer
  	   FOR v_CONSUMPTION IN c_CUSTOMER_CONSUMPTION LOOP

            v_BEGIN_DATE := v_CONSUMPTION.BEGIN_DATE;
			v_END_DATE   := v_CONSUMPTION.END_DATE;
    		GET_STATION_PARAMETER(p_STATION_ID, p_PARAMETER_ID, v_BEGIN_DATE, v_END_DATE, v_PARAMETER_VAL);

    		v_DAYS := (v_CONSUMPTION.END_DATE - v_CONSUMPTION.BEGIN_DATE) + 1;

    		IF v_DAYS > 0 THEN
    			v_USAGE_VAL := ROUND((v_CONSUMPTION.BILLED_USAGE / v_DAYS),3);
    		ELSE
    			v_USAGE_VAL := 0;
    		END IF;

    		UT.POST_RTO_WORK(v_WORK_ID, 0, TO_CHAR(v_PARAMETER_VAL) || ',' || TO_CHAR(v_USAGE_VAL));
    	END LOOP;

	ELSE
	--Same loop, different cursor
  	   FOR v_CONSUMPTION IN c_ACCOUNT_CONSUMPTION LOOP

            v_BEGIN_DATE := v_CONSUMPTION.BEGIN_DATE;
			v_END_DATE   := v_CONSUMPTION.END_DATE;

    		GET_STATION_PARAMETER(p_STATION_ID, p_PARAMETER_ID, v_BEGIN_DATE, v_END_DATE, v_PARAMETER_VAL);

    		v_DAYS := (v_CONSUMPTION.END_DATE - v_CONSUMPTION.BEGIN_DATE) + 1;

    		IF v_DAYS > 0 THEN
    			v_USAGE_VAL := ROUND((v_CONSUMPTION.BILLED_USAGE / v_DAYS),3);
    		ELSE
    			v_USAGE_VAL := 0;
    		END IF;

    		UT.POST_RTO_WORK(v_WORK_ID, 0, TO_CHAR(v_PARAMETER_VAL) || ',' || TO_CHAR(v_USAGE_VAL));
    	END LOOP;

    END IF;

    --Return the cursor from rto_work
	OPEN P_CURSOR FOR
		SELECT WORK_DATA
		FROM RTO_WORK
		WHERE WORK_ID = v_WORK_ID;

	UT.PURGE_RTO_WORK(v_WORK_ID);

EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			UT.PURGE_RTO_WORK(v_WORK_ID);
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE();
		END;
		ERRS.LOG_AND_RAISE();

END GET_ENTITY_USAGE_WRF_POINTS;
---------------------------------------------------------------------------------------------------
PROCEDURE UPDATE_USAGE_WRF_STATUS
	(
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_LAST_RUN_STATUS IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_STAT_SUBSTR VARCHAR(2);

CURSOR c_PROFILE_STATUS IS
    SELECT E.PROFILE_ID,F.PROFILE_STATUS
    FROM USAGE_WRF_STATISTICS A, ACCOUNT_USAGE_WRF B,ACCOUNT_CALENDAR C,
             CALENDAR_PROFILE_LIBRARY D, LOAD_PROFILE E, LOAD_PROFILE_STATISTICS F
    WHERE A.WRF_ID = p_WRF_ID
        AND A.TEMPLATE_ID = p_TEMPLATE_ID
        AND B.WRF_ID = A.WRF_ID
        AND C.ACCOUNT_ID = B.ACCOUNT_ID
        AND C.CASE_ID >= GA.BASE_CASE_ID       --Any Case
        AND D.CALENDAR_ID = C.CALENDAR_ID
        AND E.PROFILE_LIBRARY_ID = D.PROFILE_LIBRARY_ID
        AND E.PROFILE_TEMPLATE_ID = A.TEMPLATE_ID
        AND F.PROFILE_ID = E.PROFILE_ID;

	BEGIN

	UPDATE USAGE_WRF_STATISTICS
	SET LAST_RUN_STATUS = p_LAST_RUN_STATUS
	WHERE WRF_ID = p_WRF_ID
	  AND TEMPLATE_ID = p_TEMPLATE_ID;

    --Update associated PROFILE_STATUS
    v_STAT_SUBSTR := UPPER(SUBSTR(p_LAST_RUN_STATUS,1,2));

    FOR v_PROFILE_REC IN c_PROFILE_STATUS LOOP
        IF UPPER(SUBSTR(v_PROFILE_REC.PROFILE_STATUS,1,2)) <> v_STAT_SUBSTR THEN
           UPDATE LOAD_PROFILE_STATISTICS
           SET PROFILE_STATUS = p_LAST_RUN_STATUS
           WHERE PROFILE_ID = v_PROFILE_REC.PROFILE_ID;
        END IF;
    END LOOP;

END UPDATE_USAGE_WRF_STATUS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_EXTERNAL_METER_DATA
	(
	p_METER_IDENTIFIER IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_MACHINE_NAME IN VARCHAR,
	p_USER_NAME IN VARCHAR,
	p_METER_VALUES IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	XS.PUT_EXTERNAL_METER_DATA(p_METER_IDENTIFIER, p_AS_OF_DATE, p_MACHINE_NAME, p_USER_NAME, p_METER_VALUES, p_STATUS);


END PUT_EXTERNAL_METER_DATA;
---------------------------------------------------------------------------------------------------
PROCEDURE DELETE_USAGE_WRF_STATISTICS
	(
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_STATUS OUT NUMBER
	) AS
BEGIN

	DELETE
	FROM USAGE_WRF_STATISTICS
	WHERE WRF_ID = p_WRF_ID
	  AND TEMPLATE_ID = p_TEMPLATE_ID;
	DELETE
	FROM USAGE_WRF_SEASON
	WHERE WRF_ID = p_WRF_ID
	  AND TEMPLATE_ID = p_TEMPLATE_ID;
	DELETE
	FROM CUSTOMER_USAGE_WRF_LINE
	WHERE WRF_ID = p_WRF_ID
	  AND TEMPLATE_ID = p_TEMPLATE_ID;

END DELETE_USAGE_WRF_STATISTICS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_HISTORICAL_PROFILE_TBL
	(
	p_PROFILE_LIBRARY_NAME IN VARCHAR,
	p_PROFILE_NAME IN VARCHAR,
	p_PROFILE_POINT_VALUES IN OUT NOCOPY GA.NUMBER_TABLE,
	p_PROFILE_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN NUMBER,
	p_STATUS OUT NUMBER,
    p_LOG_ONLY_ERRORS IN CHAR DEFAULT 'N',
    p_INTERVAL_IS_NUM_MIN IN BOOLEAN := TRUE
	) AS

v_PROFILE_ID LOAD_PROFILE.PROFILE_ID%TYPE;
v_PROFILE_LIBRARY_ID LOAD_PROFILE_LIBRARY.PROFILE_LIBRARY_ID%TYPE;
v_AS_OF_DATE DATE;
v_PROFILE_AS_OF_DATE DATE;
v_VERSION_ID VERSION.VERSION_ID%TYPE;
v_LOAD_PROFILE_NAME LOAD_PROFILE.PROFILE_NAME%TYPE;
v_LOAD_PROFILE_LIBRARY_NAME LOAD_PROFILE_LIBRARY.PROFILE_LIBRARY_NAME%TYPE;
v_PROFILE_INTERVAL NUMBER;

v_EVENT_TEXT PROCESS_LOG_EVENT.EVENT_TEXT%TYPE;
v_EVENT_TEXT_DETAILS  PROCESS_LOG_EVENT.EVENT_TEXT%TYPE;
BEGIN

	v_EVENT_TEXT_DETAILS := ' Library=' || p_PROFILE_LIBRARY_NAME || ' Profile=' || p_PROFILE_NAME || ' Count=' || p_PROFILE_POINT_VALUES.COUNT || ' Started ' || TEXT_UTIL.TO_CHAR_DATE(SYSDATE);
    IF p_LOG_ONLY_ERRORS = 'N' THEN
		v_EVENT_TEXT := 'Start putting historical profile' || v_EVENT_TEXT_DETAILS;
		LOGS.LOG_DEBUG(v_EVENT_TEXT);
    END IF;

	p_STATUS := GA.SUCCESS;

	IF GA.VERSION_PROFILE THEN
		v_AS_OF_DATE := CORRECTED_AS_OF_DATE(SYSDATE,  g_DOMAIN_NAME);
	ELSE
		v_AS_OF_DATE := LOW_DATE;
	END IF;

	v_VERSION_ID := GET_PROFILE_VERSION_ID(v_AS_OF_DATE);
	IF v_VERSION_ID = CONSTANTS.NOT_ASSIGNED THEN
		LOGS.LOG_ERROR('Invalid Profile Version ID for as of date=' || TEXT_UTIL.TO_CHAR_DATE(v_AS_OF_DATE) || v_EVENT_TEXT_DETAILS);
		RETURN;
	END IF;

    IF p_LOG_ONLY_ERRORS = 'N' THEN
   	   LOGS.LOG_DEBUG('Start Insert/Update of Profile Points' || v_EVENT_TEXT_DETAILS);
    END IF;

	v_LOAD_PROFILE_NAME := RTRIM(LTRIM(p_PROFILE_NAME));
	v_LOAD_PROFILE_LIBRARY_NAME := RTRIM(LTRIM(p_PROFILE_LIBRARY_NAME));

	ID.ID_FOR_LOAD_PROFILE_LIBRARY (v_LOAD_PROFILE_LIBRARY_NAME, v_PROFILE_LIBRARY_ID);
	ID.ID_FOR_LOAD_PROFILE (v_LOAD_PROFILE_LIBRARY_NAME, v_LOAD_PROFILE_NAME, v_PROFILE_ID);

    -- 10/5/09 - BZ 21532 - p_INTERVAL_IS_NUM_MIN parameter added to indicate when p_INTERVAL
	-- is in terms of minutes or the number of intervals per day.
	IF p_INTERVAL_IS_NUM_MIN THEN
	    v_PROFILE_INTERVAL := 24 * (60 / p_INTERVAL);
    ELSE
        v_PROFILE_INTERVAL := p_INTERVAL;
    END IF;

	UPDATE LOAD_PROFILE SET PROFILE_TYPE = 'Historical' WHERE PROFILE_ID = v_PROFILE_ID ;
	UPDATE LOAD_PROFILE SET PROFILE_INTERVAL = v_PROFILE_INTERVAL WHERE PROFILE_ID = v_PROFILE_ID;
	PF.GET_PROFILE_AS_OF_DATE(v_PROFILE_ID, v_AS_OF_DATE, v_PROFILE_AS_OF_DATE, p_STATUS);

	IF v_PROFILE_AS_OF_DATE > v_AS_OF_DATE THEN
		v_AS_OF_DATE := v_PROFILE_AS_OF_DATE ;
	END IF;

	PF.PUT_LOAD_PROFILE_POINTS_TBL(
		v_PROFILE_ID,
		1,
		p_PROFILE_DATE,
		v_AS_OF_DATE,
		p_TIME_ZONE,
		p_PROFILE_POINT_VALUES,
		p_INTERVAL,
		p_STATUS);

	PF.PUT_HISTORICAL_PROFILE_STATS(v_PROFILE_ID, v_AS_OF_DATE, p_STATUS);
	IF g_ALLOW_COMMIT_ROLLBACK THEN COMMIT; END IF;

    IF p_LOG_ONLY_ERRORS = 'N' THEN
	   LOGS.LOG_DEBUG('End PUT_HISTORICAL_PROFILE' || v_EVENT_TEXT_DETAILS);
    END IF;

END PUT_HISTORICAL_PROFILE_TBL;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_HISTORICAL_PROFILE
	(
	p_PROFILE_LIBRARY_NAME IN VARCHAR,
	p_PROFILE_NAME IN VARCHAR,
	p_PROFILE_POINT_VALUES IN VARCHAR,
	p_PROFILE_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN NUMBER,
	p_STATUS OUT NUMBER
	) AS
	v_TABLE GA.NUMBER_TABLE;
BEGIN

	UT.TOKENS_FROM_STRING_TO_NUMBERS(p_PROFILE_POINT_VALUES,g_DELIMITER, v_TABLE);
	PUT_HISTORICAL_PROFILE_TBL(p_PROFILE_LIBRARY_NAME, p_PROFILE_NAME, v_TABLE, p_PROFILE_DATE, p_TIME_ZONE, p_INTERVAL, p_STATUS);

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_RAISE();

END PUT_HISTORICAL_PROFILE;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_LOAD_PROFILE_COMPLETE
	(
	o_OID OUT NUMBER,
	p_PROFILE_NAME IN VARCHAR,
	p_PROFILE_LIBRARY_NAME IN VARCHAR,
	p_PROFILE_TYPE IN VARCHAR,
	p_PROFILE_POINT_VALUES IN VARCHAR,
	p_PROFILE_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_PROFILE_TEMPLATE_ID IN NUMBER,
	p_PROFILE_SEASON IN VARCHAR,
	p_SOURCE_BEGIN_DATE IN DATE,
	p_SOURCE_END_DATE IN DATE,
	p_SOURCE_PROFILE_ID IN NUMBER,
	p_PROFILE_INTERVAL IN NUMBER,
	p_APP_LOG_DOMAIN_NAME IN VARCHAR DEFAULT 'Profiling',
	p_APP_LOG_APP_NAME IN VARCHAR DEFAULT 'PF',
	p_APP_LOG_EVENT_NAME IN VARCHAR DEFAULT 'PUT_LOAD_PROFILE_COMPLETE',
	p_APP_LOG_EVENT_USER_NAME IN VARCHAR DEFAULT 'UNKNOWN',
	p_LOG_START_STOP IN NUMBER DEFAULT 0,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

v_PROFILE_ID LOAD_PROFILE.PROFILE_ID%TYPE;
v_PROFILE_LIBRARY_ID LOAD_PROFILE_LIBRARY.PROFILE_LIBRARY_ID%TYPE;
v_AS_OF_DATE DATE;
v_PROFILE_AS_OF_DATE DATE;
v_VERSION_ID VERSION.VERSION_ID%TYPE;
v_LOAD_PROFILE_NAME LOAD_PROFILE.PROFILE_NAME%TYPE;
v_LOAD_PROFILE_LIBRARY_NAME LOAD_PROFILE_LIBRARY.PROFILE_LIBRARY_NAME%TYPE;
v_PROFILE_INTERVAL NUMBER;

v_TABLE GA.NUMBER_TABLE;
v_EVENT_TEXT_DETAILS  PROCESS_LOG_EVENT.EVENT_TEXT%TYPE;
BEGIN

	v_EVENT_TEXT_DETAILS := ' Library=' || p_PROFILE_LIBRARY_NAME || ' Profile=' || p_PROFILE_NAME ||  ' Started ' || TEXT_UTIL.TO_CHAR_DATE(SYSDATE);
	p_MESSAGE := TO_CHAR(MAX_DATA_LENGTH('APP_EVENT_LOG','EVENT_OBJECT_NAME'));

	IF p_LOG_START_STOP <> 0 THEN
	    LOGS.LOG_DEBUG('Start PF.PUT_LOAD_PROFILE_COMPLETE' || v_EVENT_TEXT_DETAILS);
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK';

	IF GA.VERSION_PROFILE THEN
		v_AS_OF_DATE := CORRECTED_AS_OF_DATE(SYSDATE,  g_DOMAIN_NAME);
	ELSE
		v_AS_OF_DATE := LOW_DATE;
	END IF;

	v_VERSION_ID := GET_PROFILE_VERSION_ID(v_AS_OF_DATE);
	IF v_VERSION_ID = CONSTANTS.NOT_ASSIGNED THEN
		LOGS.LOG_ERROR('Invalid Profile Version ID for As Of Date=' || TEXT_UTIL.TO_CHAR_DATE(v_AS_OF_DATE) || v_EVENT_TEXT_DETAILS);
		RETURN;
	END IF;

	IF p_LOG_START_STOP <> 0 THEN
		LOGS.LOG_DEBUG('Start Insert/Update of Profile Points' || v_EVENT_TEXT_DETAILS);
	END IF;

	v_LOAD_PROFILE_NAME := RTRIM(LTRIM(p_PROFILE_NAME));
	v_LOAD_PROFILE_LIBRARY_NAME := RTRIM(LTRIM(p_PROFILE_LIBRARY_NAME));

	ID.ID_FOR_LOAD_PROFILE_LIBRARY (v_LOAD_PROFILE_LIBRARY_NAME, v_PROFILE_LIBRARY_ID);
	ID.ID_FOR_LOAD_PROFILE (v_LOAD_PROFILE_LIBRARY_NAME, v_LOAD_PROFILE_NAME, v_PROFILE_ID);
	o_OID := v_PROFILE_ID;

	v_PROFILE_INTERVAL := p_PROFILE_INTERVAL;  --24 * (60 / p_INTERVAL);

	--UPDATE LOAD_PROFILE SET PROFILE_TYPE = p_PROFILE_TYPE WHERE PROFILE_ID = v_PROFILE_ID ;
	--UPDATE LOAD_PROFILE SET PROFILE_INTERVAL = v_PROFILE_INTERVAL WHERE PROFILE_ID = v_PROFILE_ID;
	UPDATE LOAD_PROFILE
	SET PROFILE_TYPE = p_PROFILE_TYPE,
		PROFILE_INTERVAL = v_PROFILE_INTERVAL,
		PROFILE_TEMPLATE_ID = p_PROFILE_TEMPLATE_ID,
		PROFILE_SEASON = p_PROFILE_SEASON,
		PROFILE_SOURCE_BEGIN_DATE = p_SOURCE_BEGIN_DATE,
		PROFILE_SOURCE_END_DATE = p_SOURCE_END_DATE,
		PROFILE_SOURCE_ID = p_SOURCE_PROFILE_ID,
		ENTRY_DATE = SYSDATE
	WHERE PROFILE_ID = v_PROFILE_ID;

	PF.GET_PROFILE_AS_OF_DATE(v_PROFILE_ID, v_AS_OF_DATE, v_PROFILE_AS_OF_DATE, p_STATUS);

	IF v_PROFILE_AS_OF_DATE > v_AS_OF_DATE THEN
		v_AS_OF_DATE := v_PROFILE_AS_OF_DATE ;
	END IF;

	UT.TOKENS_FROM_STRING_TO_NUMBERS(p_PROFILE_POINT_VALUES,g_DELIMITER, v_TABLE);
	PF.PUT_LOAD_PROFILE_POINTS_TBL(
		v_PROFILE_ID,
		1,
		p_PROFILE_DATE,
		v_AS_OF_DATE,
		p_TIME_ZONE,
		v_TABLE,
		v_PROFILE_INTERVAL,
		p_STATUS);

	PF.PUT_HISTORICAL_PROFILE_STATS(v_PROFILE_ID, v_AS_OF_DATE, p_STATUS);
	IF g_ALLOW_COMMIT_ROLLBACK THEN COMMIT; END IF;

	IF p_LOG_START_STOP <> 0 THEN
		LOGS.LOG_DEBUG('End PF.PUT_LOAD_PROFILE_COMPLETE' || v_EVENT_TEXT_DETAILS);
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_RAISE(v_EVENT_TEXT_DETAILS);

END PUT_LOAD_PROFILE_COMPLETE;
---------------------------------------------------------------------------------------------------
PROCEDURE TRACE_WRF_OBSERVATIONS
	(
	p_WRF_OBSERVATIONS IN OUT NOCOPY WRF_OBSERVATION_TABLE
	) AS

v_INDEX BINARY_INTEGER;

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('TRACE_WRF_OBSERVATIONS');

		IF p_WRF_OBSERVATIONS.COUNT > 0 THEN
			LOGS.LOG_DEBUG('<date>,<hour>,<load>,<parameter 1>,<parameter 2>,<parameter 3>,<parameter 4>,<parameter 5>,<parameter nbr>');
			v_INDEX := p_WRF_OBSERVATIONS.FIRST;
			WHILE v_INDEX <= p_WRF_OBSERVATIONS.LAST LOOP
				LOGS.LOG_DEBUG(TEXT_UTIL.TO_CHAR_DATE(p_WRF_OBSERVATIONS(v_INDEX).LOAD_DATE) || ',' ||
					TO_CHAR(p_WRF_OBSERVATIONS(v_INDEX).LOAD_HOUR) || ',' ||
					TO_CHAR(p_WRF_OBSERVATIONS(v_INDEX).LOAD_VAL) || ',' ||
					TO_CHAR(p_WRF_OBSERVATIONS(v_INDEX).PARAMETER_1) || ',' ||
					TO_CHAR(p_WRF_OBSERVATIONS(v_INDEX).PARAMETER_2) || ',' ||
					TO_CHAR(p_WRF_OBSERVATIONS(v_INDEX).PARAMETER_3) || ',' ||
					TO_CHAR(p_WRF_OBSERVATIONS(v_INDEX).PARAMETER_4) || ',' ||
					TO_CHAR(p_WRF_OBSERVATIONS(v_INDEX).PARAMETER_5) || ',' ||
					TO_CHAR(p_WRF_OBSERVATIONS(v_INDEX).PARAMETERS));
				v_INDEX := p_WRF_OBSERVATIONS.NEXT(v_INDEX);
			END LOOP;
		END IF;
	END IF;

END TRACE_WRF_OBSERVATIONS;
---------------------------------------------------------------------------------------------------
PROCEDURE TRACE_WRF_SEASON_BREAKPOINTS
	(
	p_WRF_SEASON_BREAKPOINTS IN OUT NOCOPY WRF_SEASON_BREAKPOINT_TABLE
	) AS

v_INDEX BINARY_INTEGER;

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('TRACE_WRF_SEASON_BREAKPOINTS');

		IF p_WRF_SEASON_BREAKPOINTS.COUNT > 0 THEN
			LOGS.LOG_DEBUG('<template name>,<template id>,<begin>,<end>,<hour>,<breakpoint 1>,<breakpoint 2>,<breakpoint 3>,<breakpoint 4>,<line segments>');
			v_INDEX := p_WRF_SEASON_BREAKPOINTS.FIRST;
			WHILE v_INDEX <= p_WRF_SEASON_BREAKPOINTS.LAST LOOP
				LOGS.LOG_DEBUG(p_WRF_SEASON_BREAKPOINTS(v_INDEX).TEMPLATE_NAME || ',' ||
					TO_CHAR(p_WRF_SEASON_BREAKPOINTS(v_INDEX).TEMPLATE_ID) || ',' ||
					TO_CHAR(p_WRF_SEASON_BREAKPOINTS(v_INDEX).SEASON_BEGIN_DATE) || ',' ||
					TO_CHAR(p_WRF_SEASON_BREAKPOINTS(v_INDEX).SEASON_END_DATE) || ',' ||
					TO_CHAR(p_WRF_SEASON_BREAKPOINTS(v_INDEX).BREAKPOINT_HOUR) || ',' ||
					TO_CHAR(p_WRF_SEASON_BREAKPOINTS(v_INDEX).BREAKPOINT_1) || ',' ||
					TO_CHAR(p_WRF_SEASON_BREAKPOINTS(v_INDEX).BREAKPOINT_2) || ',' ||
					TO_CHAR(p_WRF_SEASON_BREAKPOINTS(v_INDEX).BREAKPOINT_3) || ',' ||
					TO_CHAR(p_WRF_SEASON_BREAKPOINTS(v_INDEX).BREAKPOINT_4) || ',' ||
					TO_CHAR(p_WRF_SEASON_BREAKPOINTS(v_INDEX).LINE_SEGMENTS));
				v_INDEX := p_WRF_SEASON_BREAKPOINTS.NEXT(v_INDEX);
			END LOOP;
		END IF;
	END IF;

END TRACE_WRF_SEASON_BREAKPOINTS;
---------------------------------------------------------------------------------------------------
PROCEDURE TRACE_WRF_XY_VARIABLES
	(
	p_X IN GA.NUMBER_TABLE,
	p_Y IN GA.NUMBER_TABLE
	) AS

v_INDEX BINARY_INTEGER;

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('TRACE_WRF_XY_VARIABLES');

		LOGS.LOG_DEBUG('X VARIABLE');
		IF p_X.COUNT > 0 THEN
			v_INDEX := p_X.FIRST;
			WHILE v_INDEX <= p_X.LAST LOOP
				LOGS.LOG_DEBUG(TO_CHAR(v_INDEX) || ',' || TO_CHAR(p_X(v_INDEX)));
				v_INDEX := p_X.NEXT(v_INDEX);
			END LOOP;
		END IF;

		LOGS.LOG_DEBUG('Y VARIABLE');
		IF p_Y.COUNT > 0 THEN
			v_INDEX := p_Y.FIRST;
			WHILE v_INDEX <= p_Y.LAST LOOP
				LOGS.LOG_DEBUG(TO_CHAR(v_INDEX) || ',' || TO_CHAR(p_Y(v_INDEX)));
				v_INDEX := p_Y.NEXT(v_INDEX);
			END LOOP;
		END IF;
	END IF;

END TRACE_WRF_XY_VARIABLES;
---------------------------------------------------------------------------------------------------
PROCEDURE ASSIGN_STATION_PARAMETER
	(
	p_STATION_PARAMETER IN STATION_PARAMETER_TYPE,
	p_TEMPLATE_PARAMETER IN TEMPLATE_PARAMETER_TYPE,
	p_WRF_OBSERVATION IN OUT NOCOPY WRF_OBSERVATION_TYPE
	) AS

BEGIN

	IF p_STATION_PARAMETER.PARAMETER_ID = p_TEMPLATE_PARAMETER.PARAMETER_ID_1 THEN
		p_WRF_OBSERVATION.PARAMETER_1 := p_STATION_PARAMETER.PARAMETER_VAL;
		p_WRF_OBSERVATION.PARAMETERS := GREATEST(p_WRF_OBSERVATION.PARAMETERS, 1);
	ELSIF p_STATION_PARAMETER.PARAMETER_ID = p_TEMPLATE_PARAMETER.PARAMETER_ID_2 THEN
		p_WRF_OBSERVATION.PARAMETER_2 := p_STATION_PARAMETER.PARAMETER_VAL;
		p_WRF_OBSERVATION.PARAMETERS := GREATEST(p_WRF_OBSERVATION.PARAMETERS, 2);
	ELSIF p_STATION_PARAMETER.PARAMETER_ID = p_TEMPLATE_PARAMETER.PARAMETER_ID_3 THEN
		p_WRF_OBSERVATION.PARAMETER_3 := p_STATION_PARAMETER.PARAMETER_VAL;
		p_WRF_OBSERVATION.PARAMETERS := GREATEST(p_WRF_OBSERVATION.PARAMETERS, 3);
	ELSIF p_STATION_PARAMETER.PARAMETER_ID = p_TEMPLATE_PARAMETER.PARAMETER_ID_4 THEN
		p_WRF_OBSERVATION.PARAMETER_4 := p_STATION_PARAMETER.PARAMETER_VAL;
		p_WRF_OBSERVATION.PARAMETERS := GREATEST(p_WRF_OBSERVATION.PARAMETERS, 4);
	ELSIF p_STATION_PARAMETER.PARAMETER_ID = p_TEMPLATE_PARAMETER.PARAMETER_ID_5 THEN
		p_WRF_OBSERVATION.PARAMETER_5 := p_STATION_PARAMETER.PARAMETER_VAL;
		p_WRF_OBSERVATION.PARAMETERS := GREATEST(p_WRF_OBSERVATION.PARAMETERS, 5);
	END IF;

END ASSIGN_STATION_PARAMETER;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_PARAMETERS_FOR_TEMPLATE
	(
	p_TEMPLATE_ID IN NUMBER,
	p_PARAMETERS IN OUT NOCOPY GA.ID_TABLE,
	p_BREAKPOINT_ID OUT NUMBER
	) AS

v_INDEX PLS_INTEGER := 1;

CURSOR c_PARMS IS
	SELECT PARAMETER_ID, BREAKPOINT_ID
	FROM TEMPLATE_BREAKPOINT
	WHERE TEMPLATE_ID = p_TEMPLATE_ID
       	AND PARAMETER_ID <> CONSTANTS.NOT_ASSIGNED
	ORDER BY VARIABLE_NBR;

BEGIN
	p_PARAMETERS.DELETE;
	FOR v_PARM IN c_PARMS LOOP
		IF v_INDEX = 1 THEN
			p_BREAKPOINT_ID := v_PARM.BREAKPOINT_ID;
		END IF;
        p_PARAMETERS(v_INDEX) := v_PARM.PARAMETER_ID;
    	v_INDEX := v_INDEX+1;
    END LOOP;

END GET_PARAMETERS_FOR_TEMPLATE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_IDENTS
	(
	p_ID_LIST IN VARCHAR,
	p_IDS IN OUT NOCOPY ID_TABLE
	) AS

v_INDEX BINARY_INTEGER;
v_ARGUMENTS GA.STRING_TABLE;

BEGIN

	UT.TOKENS_FROM_STRING(p_ID_LIST, ';', v_ARGUMENTS);

	IF v_ARGUMENTS.COUNT > 0 THEN
		p_IDS.EXTEND(v_ARGUMENTS.COUNT);

		FOR v_INDEX IN v_ARGUMENTS.FIRST..v_ARGUMENTS.LAST LOOP
			IF LENGTH(v_ARGUMENTS(v_INDEX)) > 0 THEN
				p_IDS(v_INDEX) := ID_TYPE(v_ARGUMENTS(v_INDEX));
			END IF;
		END LOOP;
	END IF;

END GET_IDENTS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_ACCOUNTS
	(
	p_ACCOUNT_GROUP_ID IN NUMBER,
	p_ACCOUNTS IN OUT NOCOPY ID_TABLE
	) AS

BEGIN

	SELECT ID_TYPE(ACCOUNT_ID)
	BULK COLLECT INTO p_ACCOUNTS
	FROM ACCOUNT_GROUP_ASSIGNMENT A
	WHERE A.ACCOUNT_GROUP_ID = p_ACCOUNT_GROUP_ID
		AND UPPER(A.ASSIGNMENT_CATEGORY) = 'WRF';

END GET_ACCOUNTS;
---------------------------------------------------------------------------------------------------
FUNCTION GET_ACCOUNT_STATION
	(
	p_ACCOUNT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	) RETURN NUMBER IS

v_STATION_ID NUMBER(9);

BEGIN

	SELECT B.WEATHER_STATION_ID
	INTO v_STATION_ID
	FROM ACCOUNT_SERVICE_LOCATION A, SERVICE_LOCATION B
	WHERE A.ACCOUNT_ID = p_ACCOUNT_ID
		AND A.BEGIN_DATE <= p_END_DATE
		AND NVL(A.END_DATE, p_END_DATE) >= p_BEGIN_DATE
		AND B.SERVICE_LOCATION_ID = A.SERVICE_LOCATION_ID
		AND ROWNUM = 1;

	RETURN v_STATION_ID;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN CONSTANTS.NOT_ASSIGNED;

END GET_ACCOUNT_STATION;
---------------------------------------------------------------------------------------------------
PROCEDURE SET_LOAD_PROFILE_WRF_LINE
	(
	p_WRF_ID IN NUMBER,
	p_HOUR IN NUMBER,
	p_COEFF IN GA.NUMBER_TABLE,
	p_TSTAT IN GA.NUMBER_TABLE,
	p_R_SQUARED IN NUMBER,
	p_TSTAT_CRITICAL IN NUMBER,
	p_SEGMENT_MIN IN NUMBER,
	p_SEGMENT_MAX IN NUMBER,
	p_LOAD_PROFILE_WRF_LINE IN OUT NOCOPY LOAD_PROFILE_WRF_LINE%ROWTYPE
	) AS


BEGIN

	p_LOAD_PROFILE_WRF_LINE.WRF_ID := p_WRF_ID;
	p_LOAD_PROFILE_WRF_LINE.WRF_HOUR := p_HOUR;
	p_LOAD_PROFILE_WRF_LINE.R_SQUARED := p_R_SQUARED;
	p_LOAD_PROFILE_WRF_LINE.TSTAT_CRITICAL := p_TSTAT_CRITICAL;
	p_LOAD_PROFILE_WRF_LINE.SEGMENT_MIN := p_SEGMENT_MIN;
	p_LOAD_PROFILE_WRF_LINE.SEGMENT_MAX := p_SEGMENT_MAX;
	p_LOAD_PROFILE_WRF_LINE.NUM_VARS := LEAST(p_COEFF.COUNT, 6);

	p_LOAD_PROFILE_WRF_LINE.COEFF_0 := p_COEFF(1);
	p_LOAD_PROFILE_WRF_LINE.TSTAT_0 := p_TSTAT(1);
	IF p_COEFF.COUNT > 1 THEN
		p_LOAD_PROFILE_WRF_LINE.COEFF_1 := p_COEFF(2);
		p_LOAD_PROFILE_WRF_LINE.TSTAT_1 := p_TSTAT(2);
		IF p_COEFF.COUNT > 2 THEN
			p_LOAD_PROFILE_WRF_LINE.COEFF_2 := p_COEFF(3);
			p_LOAD_PROFILE_WRF_LINE.TSTAT_2 := p_TSTAT(3);
			IF p_COEFF.COUNT > 3 THEN
				p_LOAD_PROFILE_WRF_LINE.COEFF_3 := p_COEFF(4);
				p_LOAD_PROFILE_WRF_LINE.TSTAT_3 := p_TSTAT(4);
				IF p_COEFF.COUNT > 4 THEN
					p_LOAD_PROFILE_WRF_LINE.COEFF_4 := p_COEFF(5);
					p_LOAD_PROFILE_WRF_LINE.TSTAT_4 := p_TSTAT(5);
					IF p_COEFF.COUNT > 5 THEN
						p_LOAD_PROFILE_WRF_LINE.COEFF_5 := p_COEFF(6);
						p_LOAD_PROFILE_WRF_LINE.TSTAT_5 := p_TSTAT(6);
					END IF;
				END IF;
			END IF;
		END IF;
	END IF;

END SET_LOAD_PROFILE_WRF_LINE;
---------------------------------------------------------------------------------------------------
PROCEDURE NEW_WRF_FCM
	(
	p_PROFILE_ID IN NUMBER
	) AS
BEGIN
	DELETE WRF_FCM WHERE PROFILE_ID = p_PROFILE_ID;
END NEW_WRF_FCM;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_WRF_FCM
	(
	p_FCM IN OUT NOCOPY WRF_FCM%ROWTYPE
	) AS
BEGIN
	UPDATE WRF_FCM SET ROW = p_FCM
	WHERE FCM_ID = p_FCM.FCM_ID;

	IF SQL%NOTFOUND THEN
		SELECT OID.NEXTVAL INTO p_FCM.FCM_ID FROM DUAL;
		INSERT INTO WRF_FCM VALUES p_FCM;
	END IF;
END PUT_WRF_FCM;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_WRF_FCM_OBSERVATIONS
	(
	p_FCM_ID IN NUMBER,
	p_PARAMETER_COUNT IN BINARY_INTEGER,
	p_X IN GA.NUMBER_TABLE,
	p_Y IN GA.NUMBER_TABLE
	) AS
v_OBS	WRF_FCM_OBSERVATION%ROWTYPE;
v_JDX	BINARY_INTEGER;
BEGIN
	v_OBS.FCM_ID := p_FCM_ID;
	v_JDX := 2; -- index into p_X of first weather parameter value for first observation

	FOR v_IDX IN p_Y.FIRST..p_Y.LAST LOOP

		v_OBS.OBSERVATION_NUM := v_IDX;
		v_OBS.OBSERVATION_Y := p_Y(v_IDX);
		v_OBS.OBSERVATION_X := p_X(v_JDX);
		IF p_PARAMETER_COUNT > 1 THEN
			v_OBS.OBSERVATION_P2 := p_X(v_JDX+1);
			IF p_PARAMETER_COUNT > 2 THEN
				v_OBS.OBSERVATION_P3 := p_X(v_JDX+2);
				IF p_PARAMETER_COUNT > 3 THEN
					v_OBS.OBSERVATION_P4 := p_X(v_JDX+3);
					IF p_PARAMETER_COUNT > 4 THEN
						v_OBS.OBSERVATION_P5 := p_X(v_JDX+4);
					END IF;
				END IF;
			END IF;
		END IF;

		-- now insert the record
		INSERT INTO WRF_FCM_OBSERVATION VALUES v_OBS;

		v_JDX := v_JDX+(p_PARAMETER_COUNT+1);
	END LOOP;
END PUT_WRF_FCM_OBSERVATIONS;
---------------------------------------------------------------------------------------------------
PROCEDURE INIT_WRF_FCM_CANDIDATE
	(
	p_FCM_ID IN NUMBER,
	p_NUM_SEGMENTS IN NUMBER,
	p_CANDIDATE OUT WRF_FCM_CANDIDATE%ROWTYPE
	) AS
v_ROW WRF_FCM_CANDIDATE%ROWTYPE;
BEGIN
	v_ROW.FCM_ID := p_FCM_ID;
	v_ROW.NUM_SEGMENTS := p_NUM_SEGMENTS;
	INSERT INTO WRF_FCM_CANDIDATE VALUES v_ROW;

	p_CANDIDATE := v_ROW;
END INIT_WRF_FCM_CANDIDATE;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_WRF_FCM_CANDIDATE
	(
	p_CANDIDATE IN WRF_FCM_CANDIDATE%ROWTYPE
	) AS
BEGIN
	UPDATE WRF_FCM_CANDIDATE SET ROW = p_CANDIDATE
	WHERE FCM_ID = p_CANDIDATE.FCM_ID
		AND NUM_SEGMENTS = p_CANDIDATE.NUM_SEGMENTS;

	IF SQL%NOTFOUND THEN
		INSERT INTO WRF_FCM_CANDIDATE VALUES p_CANDIDATE;
	END IF;
END PUT_WRF_FCM_CANDIDATE;
---------------------------------------------------------------------------------------------------
PROCEDURE REMOVE_WRF_FCM_CANDIDATE
	(
	p_FCM_ID IN NUMBER,
	p_NUM_SEGMENTS IN NUMBER
	) AS
BEGIN
	DELETE WRF_FCM_CANDIDATE
	WHERE FCM_ID = p_FCM_ID
		AND NUM_SEGMENTS = p_NUM_SEGMENTS;
END REMOVE_WRF_FCM_CANDIDATE;
---------------------------------------------------------------------------------------------------
FUNCTION HAVE_SAME_PARAMETER_IDs
	(
	p_LIST1 IN GA.ID_TABLE,
	p_LIST2 IN GA.ID_TABLE
	) RETURN BOOLEAN IS
v_IDX BINARY_INTEGER;
BEGIN
	IF p_LIST1.COUNT <> p_LIST2.COUNT THEN
		RETURN FALSE;
	END IF;

	v_IDX := p_LIST1.FIRST;
	WHILE p_LIST1.EXISTS(v_IDX) LOOP
		IF NVL(p_LIST1(v_IDX),0) <> NVL(p_LIST2(v_IDX),0) THEN
			RETURN FALSE;
		END IF;
		v_IDX := p_LIST1.NEXT(v_IDX);
	END LOOP;

	RETURN TRUE;
END HAVE_SAME_PARAMETER_IDs;
---------------------------------------------------------------------------------------------------
PROCEDURE CACHE_BATCH_WRF_WEATHER
	(
	p_STATION_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
    p_PARAMETERS IN GA.ID_TABLE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_BATCH_TIMESTAMP IN TIMESTAMP := NULL
	) AS

-- Build work table containing all weather parameter values needed for this wrf

v_COUNT NUMBER(3);
v_LOCAL_TZ VARCHAR2(3) := LOCAL_TIME_ZONE;
v_MODEL_ID NUMBER(1) := GA.DEFAULT_MODEL;
v_CUT_BEGIN_DATE DATE;
v_CUT_END_DATE DATE;

BEGIN

	IF g_BATCH_WEATHER_STATION_ID = p_STATION_ID AND g_BATCH_WEATHER_TEMPLATE_ID = p_TEMPLATE_ID AND
		HAVE_SAME_PARAMETER_IDS(g_BATCH_WEATHER_PARAMETERS, p_PARAMETERS) AND
		g_BATCH_WEATHER_BEGIN_DATE = p_BEGIN_DATE AND g_BATCH_WEATHER_END_DATE = p_END_DATE AND
		g_BATCH_WEATHER_TIMESTAMP = p_BATCH_TIMESTAMP THEN

		RETURN; -- we already have the right data

	ELSE
		-- we must rebuild cache - first step is to wipe anything already in there
		DELETE WRF_BATCH_RUN_WEATHER;
		g_BATCH_WEATHER_STATION_ID := NULL; -- set a global to null so that we won't try to
											-- re-use data since there is nothing in there
											-- at this point
	END IF;

	-- first verify that system date time is populated - otherwise queries below will generate
	-- empty results and no WRFs will be computed
	SP.CHECK_SYSTEM_DATE_TIME(v_LOCAL_TZ, p_BEGIN_DATE, p_END_DATE);

	UT.CUT_DATE_RANGE(v_MODEL_ID, p_BEGIN_DATE, p_END_DATE, v_LOCAL_TZ, v_CUT_BEGIN_DATE, v_CUT_END_DATE);

    v_COUNT := p_PARAMETERS.COUNT;

	WR.CACHE_COMPOSITE_HIERARCHY(p_STATION_ID, p_PARAMETERS);

    IF v_COUNT = 1 THEN
        --Insert 1 parameter
        INSERT INTO WRF_BATCH_RUN_WEATHER (PARAMETER_DATE, HOUR, PARAMETER_1)
            SELECT SDT.LOCAL_DATE, REPLACE(TO_CHAR(SDT.LOCAL_DATE,'HH24'),'00','24'),
                   SUM(P.PARAMETER_VAL*WS.COEFFICIENT*WP.COEFFICIENT) "PARAMETER_1"
            FROM TEMPLATE_SEASON_DAY_NAME TSDN,
                SEASON E,
                HOLIDAY_OBSERVANCE F,
                SYSTEM_DATE_TIME SDT,
                STATION_PARAMETER_VALUE P,
				COMPOSITE_WEATHER_WORK WS,
				COMPOSITE_WEATHER_WORK WP
			WHERE WS.ENTITY_INDEX = 0 -- station hierarchy
				AND WP.ENTITY_INDEX = 1 -- parameter 1 hierarchy
            	AND P.CASE_ID = GA.BASE_CASE_ID
                AND P.STATION_ID = WS.ENTITY_ID
                AND P.PARAMETER_ID = WP.ENTITY_ID
                AND P.PARAMETER_CODE = GA.ACTUAL_SERVICE
				AND P.PARAMETER_DATE = SDT.CUT_DATE
				AND SDT.TIME_ZONE = v_LOCAL_TZ
				AND SDT.DATA_INTERVAL_TYPE = v_MODEL_ID
				AND SDT.DAY_TYPE = 1
                AND SDT.CUT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
				AND SDT.IS_DST_FALL_BACK_HOUR = 0
                AND TSDN.TEMPLATE_ID = p_TEMPLATE_ID
                AND E.SEASON_ID = TSDN.SEASON_ID
                AND TRUNC(F.HOLIDAY_DATE(+)) = SDT.LOCAL_DAY_TRUNC_DATE --TRUNC(SDT.LOCAL_DATE-.00001) --NEW_TIME(P.PARAMETER_DATE,'EST','EDT')-0.00001)
                AND ((F.HOLIDAY_DATE IS NOT NULL AND TSDN.DAY_NAME = 'Hol')
                   OR (F.HOLIDAY_DATE IS NULL AND UPPER(TO_CHAR(SDT.LOCAL_DAY_TRUNC_DATE,'DY')) = UPPER(TSDN.DAY_NAME)))
				-- begin/end dates don't wrap new year (i.e. begin <= end)?
				-- then check that date is between the two
        		AND ( ((E.END_DATE-TRUNC(E.END_DATE,'YY')) >= (E.BEGIN_DATE-TRUNC(E.BEGIN_DATE,'YY'))
						AND TO_CHAR(SDT.LOCAL_DAY_TRUNC_DATE,'MM-DD') BETWEEN TO_CHAR(E.BEGIN_DATE,'MM-DD') AND TO_CHAR(E.END_DATE,'MM-DD'))
				-- since "between" only works when begin date <= end date
				-- we need to use >= and <= operations to figure out the inverse
        			OR ((E.BEGIN_DATE-TRUNC(E.BEGIN_DATE,'YY')) > (E.END_DATE-TRUNC(E.END_DATE,'YY'))
						AND (TO_CHAR(SDT.LOCAL_DAY_TRUNC_DATE,'MM-DD') <= TO_CHAR(E.BEGIN_DATE,'MM-DD')
						  OR TO_CHAR(SDT.LOCAL_DAY_TRUNC_DATE,'MM-DD') >= TO_CHAR(E.END_DATE,'MM-DD'))) )
			GROUP BY SDT.LOCAL_DATE;

    ELSIF v_COUNT = 2 THEN
        --Insert 2 parameters
         INSERT INTO WRF_BATCH_RUN_WEATHER (PARAMETER_DATE, HOUR, PARAMETER_1, PARAMETER_2)
            SELECT SDT.LOCAL_DATE, REPLACE(TO_CHAR(SDT.LOCAL_DATE,'HH24'),'00','24'),
                   SUM(P1.PARAMETER_VAL*WS.COEFFICIENT*WP1.COEFFICIENT) "PARAMETER_1",
                   SUM(P2.PARAMETER_VAL*WS.COEFFICIENT*WP2.COEFFICIENT) "PARAMETER_2"
            FROM TEMPLATE_SEASON_DAY_NAME TSDN,
                SEASON E,
                HOLIDAY_OBSERVANCE F,
                SYSTEM_DATE_TIME SDT,
                STATION_PARAMETER_VALUE P1,
                STATION_PARAMETER_VALUE P2,
				COMPOSITE_WEATHER_WORK WS,
				COMPOSITE_WEATHER_WORK WP1,
				COMPOSITE_WEATHER_WORK WP2
			WHERE WS.ENTITY_INDEX = 0 -- station hierarchy
				AND WP1.ENTITY_INDEX = 1 -- parameter 1 hierarchy
				AND WP2.ENTITY_INDEX = 2 -- parameter 2 hierarchy
            	AND P1.CASE_ID = GA.BASE_CASE_ID
                AND P1.STATION_ID = WS.ENTITY_ID
                AND P1.PARAMETER_ID = WP1.ENTITY_ID
                AND P1.PARAMETER_CODE = GA.ACTUAL_SERVICE
                AND P1.PARAMETER_DATE  = SDT.CUT_DATE
                AND P2.CASE_ID = P1.CASE_ID
                AND P2.STATION_ID = P1.STATION_ID
                AND P2.PARAMETER_ID = WP2.ENTITY_ID
                AND P2.PARAMETER_CODE = P1.PARAMETER_CODE
                AND P2.PARAMETER_DATE = P1.PARAMETER_DATE
				and SDT.TIME_ZONE = v_LOCAL_TZ
				AND SDT.DATA_INTERVAL_TYPE = v_MODEL_ID
				AND SDT.DAY_TYPE = 1
                AND SDT.CUT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
				AND SDT.IS_DST_FALL_BACK_HOUR = 0
                AND TSDN.TEMPLATE_ID = p_TEMPLATE_ID
                AND E.SEASON_ID = TSDN.SEASON_ID
                AND TRUNC(F.HOLIDAY_DATE(+)) = SDT.LOCAL_DAY_TRUNC_DATE --TRUNC(SDT.LOCAL_DATE-.00001) --NEW_TIME(P.PARAMETER_DATE,'EST','EDT')-0.00001)
                AND ((F.HOLIDAY_DATE IS NOT NULL AND TSDN.DAY_NAME = 'Hol')
                   OR (F.HOLIDAY_DATE IS NULL AND UPPER(TO_CHAR(SDT.LOCAL_DAY_TRUNC_DATE,'DY')) = UPPER(TSDN.DAY_NAME)))
				-- begin/end dates don't wrap new year (i.e. begin <= end)?
				-- then check that date is between the two
        		AND ( ((E.END_DATE-TRUNC(E.END_DATE,'YY')) >= (E.BEGIN_DATE-TRUNC(E.BEGIN_DATE,'YY'))
						AND TO_CHAR(SDT.LOCAL_DAY_TRUNC_DATE,'MM-DD') BETWEEN TO_CHAR(E.BEGIN_DATE,'MM-DD') AND TO_CHAR(E.END_DATE,'MM-DD'))
				-- since "between" only works when begin date <= end date
				-- we need to use >= and <= operations to figure out the inverse
        			OR ((E.BEGIN_DATE-TRUNC(E.BEGIN_DATE,'YY')) > (E.END_DATE-TRUNC(E.END_DATE,'YY'))
						AND (TO_CHAR(SDT.LOCAL_DAY_TRUNC_DATE,'MM-DD') <= TO_CHAR(E.BEGIN_DATE,'MM-DD')
						  OR TO_CHAR(SDT.LOCAL_DAY_TRUNC_DATE,'MM-DD') >= TO_CHAR(E.END_DATE,'MM-DD'))) )
			GROUP BY SDT.LOCAL_DATE;

    ELSIF v_COUNT = 3 THEN
        --Insert 3 parameters
        INSERT INTO WRF_BATCH_RUN_WEATHER (PARAMETER_DATE, HOUR, PARAMETER_1, PARAMETER_2, PARAMETER_3)
            SELECT SDT.LOCAL_DATE, REPLACE(TO_CHAR(SDT.LOCAL_DATE,'HH24'),'00','24'),
                   SUM(P1.PARAMETER_VAL*WS.COEFFICIENT*WP1.COEFFICIENT) "PARAMETER_1",
                   SUM(P2.PARAMETER_VAL*WS.COEFFICIENT*WP2.COEFFICIENT) "PARAMETER_2",
                   SUM(P3.PARAMETER_VAL*WS.COEFFICIENT*WP3.COEFFICIENT) "PARAMETER_3"
            FROM TEMPLATE_SEASON_DAY_NAME TSDN,
                SEASON E,
                HOLIDAY_OBSERVANCE F,
                SYSTEM_DATE_TIME SDT,
                STATION_PARAMETER_VALUE P1,
                STATION_PARAMETER_VALUE P2,
                STATION_PARAMETER_VALUE P3,
				COMPOSITE_WEATHER_WORK WS,
				COMPOSITE_WEATHER_WORK WP1,
				COMPOSITE_WEATHER_WORK WP2,
				COMPOSITE_WEATHER_WORK WP3
			WHERE WS.ENTITY_INDEX = 0 -- station hierarchy
				AND WP1.ENTITY_INDEX = 1 -- parameter 1 hierarchy
				AND WP2.ENTITY_INDEX = 2 -- parameter 2 hierarchy
				AND WP3.ENTITY_INDEX = 3 -- parameter 3 hierarchy
                AND P1.CASE_ID = GA.BASE_CASE_ID
				AND P1.STATION_ID = WS.ENTITY_ID
                AND P1.PARAMETER_ID = WP1.ENTITY_ID
                AND P1.PARAMETER_CODE = GA.ACTUAL_SERVICE
                AND P1.PARAMETER_DATE  = SDT.CUT_DATE
                AND P2.CASE_ID = P1.CASE_ID
                AND P2.STATION_ID = P1.STATION_ID
                AND P2.PARAMETER_ID = WP2.ENTITY_ID
                AND P2.PARAMETER_CODE = P1.PARAMETER_CODE
                AND P2.PARAMETER_DATE = P1.PARAMETER_DATE
                AND P3.CASE_ID = P1.CASE_ID
                AND P3.STATION_ID = P1.STATION_ID
                AND P3.PARAMETER_ID = WP3.ENTITY_ID
                AND P3.PARAMETER_CODE = P1.PARAMETER_CODE
                AND P3.PARAMETER_DATE = P1.PARAMETER_DATE
				and SDT.TIME_ZONE = v_LOCAL_TZ
				AND SDT.DATA_INTERVAL_TYPE = v_MODEL_ID
				AND SDT.DAY_TYPE = 1
                AND SDT.CUT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
				AND SDT.IS_DST_FALL_BACK_HOUR = 0
                AND TSDN.TEMPLATE_ID = p_TEMPLATE_ID
                AND E.SEASON_ID = TSDN.SEASON_ID
                AND TRUNC(F.HOLIDAY_DATE(+)) = SDT.LOCAL_DAY_TRUNC_DATE --TRUNC(SDT.LOCAL_DATE-.00001) --NEW_TIME(P.PARAMETER_DATE,'EST','EDT')-0.00001)
                AND ((F.HOLIDAY_DATE IS NOT NULL AND TSDN.DAY_NAME = 'Hol')
                   OR (F.HOLIDAY_DATE IS NULL AND UPPER(TO_CHAR(SDT.LOCAL_DAY_TRUNC_DATE,'DY')) = UPPER(TSDN.DAY_NAME)))
				-- begin/end dates don't wrap new year (i.e. begin <= end)?
				-- then check that date is between the two
        		AND ( ((E.END_DATE-TRUNC(E.END_DATE,'YY')) >= (E.BEGIN_DATE-TRUNC(E.BEGIN_DATE,'YY'))
						AND TO_CHAR(SDT.LOCAL_DAY_TRUNC_DATE,'MM-DD') BETWEEN TO_CHAR(E.BEGIN_DATE,'MM-DD') AND TO_CHAR(E.END_DATE,'MM-DD'))
				-- since "between" only works when begin date <= end date
				-- we need to use >= and <= operations to figure out the inverse
        			OR ((E.BEGIN_DATE-TRUNC(E.BEGIN_DATE,'YY')) > (E.END_DATE-TRUNC(E.END_DATE,'YY'))
						AND (TO_CHAR(SDT.LOCAL_DAY_TRUNC_DATE,'MM-DD') <= TO_CHAR(E.BEGIN_DATE,'MM-DD')
						  OR TO_CHAR(SDT.LOCAL_DAY_TRUNC_DATE,'MM-DD') >= TO_CHAR(E.END_DATE,'MM-DD'))) )
			GROUP BY SDT.LOCAL_DATE;

    ELSIF v_COUNT = 4 THEN
        --Insert 4 parameters
        INSERT INTO WRF_BATCH_RUN_WEATHER (PARAMETER_DATE, HOUR, PARAMETER_1, PARAMETER_2, PARAMETER_3, PARAMETER_4)
            SELECT SDT.LOCAL_DATE, REPLACE(TO_CHAR(SDT.LOCAL_DATE,'HH24'),'00','24'),
                   SUM(P1.PARAMETER_VAL*WS.COEFFICIENT*WP1.COEFFICIENT) "PARAMETER_1",
                   SUM(P2.PARAMETER_VAL*WS.COEFFICIENT*WP2.COEFFICIENT) "PARAMETER_2",
                   SUM(P3.PARAMETER_VAL*WS.COEFFICIENT*WP3.COEFFICIENT) "PARAMETER_3",
                   SUM(P4.PARAMETER_VAL*WS.COEFFICIENT*WP4.COEFFICIENT) "PARAMETER_4"
            FROM TEMPLATE_SEASON_DAY_NAME TSDN,
                SEASON E,
                HOLIDAY_OBSERVANCE F,
                SYSTEM_DATE_TIME SDT,
                STATION_PARAMETER_VALUE P1,
                STATION_PARAMETER_VALUE P2,
                STATION_PARAMETER_VALUE P3,
                STATION_PARAMETER_VALUE P4,
				COMPOSITE_WEATHER_WORK WS,
				COMPOSITE_WEATHER_WORK WP1,
				COMPOSITE_WEATHER_WORK WP2,
				COMPOSITE_WEATHER_WORK WP3,
				COMPOSITE_WEATHER_WORK WP4
			WHERE WS.ENTITY_INDEX = 0 -- station hierarchy
				AND WP1.ENTITY_INDEX = 1 -- parameter 1 hierarchy
				AND WP2.ENTITY_INDEX = 2 -- parameter 2 hierarchy
				AND WP3.ENTITY_INDEX = 3 -- parameter 3 hierarchy
				AND WP4.ENTITY_INDEX = 4 -- parameter 4 hierarchy
                AND P1.CASE_ID = GA.BASE_CASE_ID
				AND P1.STATION_ID = WS.ENTITY_ID
                AND P1.PARAMETER_ID = WP1.ENTITY_ID
                AND P1.PARAMETER_CODE = GA.ACTUAL_SERVICE
                AND P1.PARAMETER_DATE  = SDT.CUT_DATE
                AND P2.CASE_ID = P1.CASE_ID
                AND P2.STATION_ID = P1.STATION_ID
                AND P2.PARAMETER_ID = WP2.ENTITY_ID
                AND P2.PARAMETER_CODE = P1.PARAMETER_CODE
                AND P2.PARAMETER_DATE = P1.PARAMETER_DATE
                AND P3.CASE_ID = P1.CASE_ID
                AND P3.STATION_ID = P1.STATION_ID
                AND P3.PARAMETER_ID = WP3.ENTITY_ID
                AND P3.PARAMETER_CODE = P1.PARAMETER_CODE
                AND P3.PARAMETER_DATE = P1.PARAMETER_DATE
                AND P4.CASE_ID = P1.CASE_ID
                AND P4.STATION_ID = P1.STATION_ID
                AND P4.PARAMETER_ID = WP4.ENTITY_ID
                AND P4.PARAMETER_CODE = P1.PARAMETER_CODE
                AND P4.PARAMETER_DATE = P1.PARAMETER_DATE
				and SDT.TIME_ZONE = v_LOCAL_TZ
				AND SDT.DATA_INTERVAL_TYPE = v_MODEL_ID
				AND SDT.DAY_TYPE = 1
                AND SDT.CUT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
				AND SDT.IS_DST_FALL_BACK_HOUR = 0
                AND TSDN.TEMPLATE_ID = p_TEMPLATE_ID
                AND E.SEASON_ID = TSDN.SEASON_ID
                AND TRUNC(F.HOLIDAY_DATE(+)) = SDT.LOCAL_DAY_TRUNC_DATE --TRUNC(SDT.LOCAL_DATE-.00001) --NEW_TIME(P.PARAMETER_DATE,'EST','EDT')-0.00001)
                AND ((F.HOLIDAY_DATE IS NOT NULL AND TSDN.DAY_NAME = 'Hol')
                   OR (F.HOLIDAY_DATE IS NULL AND UPPER(TO_CHAR(SDT.LOCAL_DAY_TRUNC_DATE,'DY')) = UPPER(TSDN.DAY_NAME)))
				-- begin/end dates don't wrap new year (i.e. begin <= end)?
				-- then check that date is between the two
        		AND ( ((E.END_DATE-TRUNC(E.END_DATE,'YY')) >= (E.BEGIN_DATE-TRUNC(E.BEGIN_DATE,'YY'))
						AND TO_CHAR(SDT.LOCAL_DAY_TRUNC_DATE,'MM-DD') BETWEEN TO_CHAR(E.BEGIN_DATE,'MM-DD') AND TO_CHAR(E.END_DATE,'MM-DD'))
				-- since "between" only works when begin date <= end date
				-- we need to use >= and <= operations to figure out the inverse
        			OR ((E.BEGIN_DATE-TRUNC(E.BEGIN_DATE,'YY')) > (E.END_DATE-TRUNC(E.END_DATE,'YY'))
						AND (TO_CHAR(SDT.LOCAL_DAY_TRUNC_DATE,'MM-DD') <= TO_CHAR(E.BEGIN_DATE,'MM-DD')
						  OR TO_CHAR(SDT.LOCAL_DAY_TRUNC_DATE,'MM-DD') >= TO_CHAR(E.END_DATE,'MM-DD'))) )
			GROUP BY SDT.LOCAL_DATE;

    ELSIF v_COUNT = 5 THEN
        --Insert 5 parameters
        INSERT INTO WRF_BATCH_RUN_WEATHER (PARAMETER_DATE, HOUR, PARAMETER_1, PARAMETER_2, PARAMETER_3, PARAMETER_4, PARAMETER_5)
            SELECT SDT.LOCAL_DATE, REPLACE(TO_CHAR(SDT.LOCAL_DATE,'HH24'),'00','24'),
                   SUM(P1.PARAMETER_VAL*WS.COEFFICIENT*WP1.COEFFICIENT) "PARAMETER_1",
                   SUM(P2.PARAMETER_VAL*WS.COEFFICIENT*WP2.COEFFICIENT) "PARAMETER_2",
                   SUM(P3.PARAMETER_VAL*WS.COEFFICIENT*WP3.COEFFICIENT) "PARAMETER_3",
                   SUM(P4.PARAMETER_VAL*WS.COEFFICIENT*WP4.COEFFICIENT) "PARAMETER_4",
                   SUM(P5.PARAMETER_VAL*WS.COEFFICIENT*WP5.COEFFICIENT) "PARAMETER_5"
            FROM TEMPLATE_SEASON_DAY_NAME TSDN,
                SEASON E,
                HOLIDAY_OBSERVANCE F,
                SYSTEM_DATE_TIME SDT,
                STATION_PARAMETER_VALUE P1,
                STATION_PARAMETER_VALUE P2,
                STATION_PARAMETER_VALUE P3,
                STATION_PARAMETER_VALUE P4,
                STATION_PARAMETER_VALUE P5,
				COMPOSITE_WEATHER_WORK WS,
				COMPOSITE_WEATHER_WORK WP1,
				COMPOSITE_WEATHER_WORK WP2,
				COMPOSITE_WEATHER_WORK WP3,
				COMPOSITE_WEATHER_WORK WP4,
				COMPOSITE_WEATHER_WORK WP5
			WHERE WS.ENTITY_INDEX = 0 -- station hierarchy
				AND WP1.ENTITY_INDEX = 1 -- parameter 1 hierarchy
				AND WP2.ENTITY_INDEX = 2 -- parameter 2 hierarchy
				AND WP3.ENTITY_INDEX = 3 -- parameter 3 hierarchy
				AND WP4.ENTITY_INDEX = 4 -- parameter 4 hierarchy
				AND WP4.ENTITY_INDEX = 5 -- parameter 5 hierarchy
                AND P1.CASE_ID = GA.BASE_CASE_ID
				AND P1.STATION_ID = WS.ENTITY_ID
                AND P1.PARAMETER_ID = WP1.ENTITY_ID
                AND P1.PARAMETER_CODE = GA.ACTUAL_SERVICE
                AND P1.PARAMETER_DATE  = SDT.CUT_DATE
                AND P2.CASE_ID = P1.CASE_ID
                AND P2.STATION_ID = P1.STATION_ID
                AND P2.PARAMETER_ID = WP2.ENTITY_ID
                AND P2.PARAMETER_CODE = P1.PARAMETER_CODE
                AND P2.PARAMETER_DATE = P1.PARAMETER_DATE
                AND P3.CASE_ID = P1.CASE_ID
                AND P3.STATION_ID = P1.STATION_ID
                AND P3.PARAMETER_ID = WP3.ENTITY_ID
                AND P3.PARAMETER_CODE = P1.PARAMETER_CODE
                AND P3.PARAMETER_DATE = P1.PARAMETER_DATE
                AND P4.CASE_ID = P1.CASE_ID
                AND P4.STATION_ID = P1.STATION_ID
                AND P4.PARAMETER_ID = WP4.ENTITY_ID
                AND P4.PARAMETER_CODE = P1.PARAMETER_CODE
                AND P4.PARAMETER_DATE = P1.PARAMETER_DATE
                AND P5.CASE_ID = P1.CASE_ID
                AND P5.STATION_ID = P1.STATION_ID
                AND P5.PARAMETER_ID = WP5.ENTITY_ID
                AND P5.PARAMETER_CODE = P1.PARAMETER_CODE
                AND P5.PARAMETER_DATE = P1.PARAMETER_DATE
				and SDT.TIME_ZONE = v_LOCAL_TZ
				AND SDT.DATA_INTERVAL_TYPE = v_MODEL_ID
				AND SDT.DAY_TYPE = 1
                AND SDT.CUT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
				AND SDT.IS_DST_FALL_BACK_HOUR = 0
                AND TSDN.TEMPLATE_ID = p_TEMPLATE_ID
                AND E.SEASON_ID = TSDN.SEASON_ID
                AND TRUNC(F.HOLIDAY_DATE(+)) = SDT.LOCAL_DAY_TRUNC_DATE --TRUNC(SDT.LOCAL_DATE-.00001) --NEW_TIME(P.PARAMETER_DATE,'EST','EDT')-0.00001)
                AND ((F.HOLIDAY_DATE IS NOT NULL AND TSDN.DAY_NAME = 'Hol')
                   OR (F.HOLIDAY_DATE IS NULL AND UPPER(TO_CHAR(SDT.LOCAL_DAY_TRUNC_DATE,'DY')) = UPPER(TSDN.DAY_NAME)))
				-- begin/end dates don't wrap new year (i.e. begin <= end)?
				-- then check that date is between the two
        		AND ( ((E.END_DATE-TRUNC(E.END_DATE,'YY')) >= (E.BEGIN_DATE-TRUNC(E.BEGIN_DATE,'YY'))
						AND TO_CHAR(SDT.LOCAL_DAY_TRUNC_DATE,'MM-DD') BETWEEN TO_CHAR(E.BEGIN_DATE,'MM-DD') AND TO_CHAR(E.END_DATE,'MM-DD'))
				-- since "between" only works when begin date <= end date
				-- we need to use >= and <= operations to figure out the inverse
        			OR ((E.BEGIN_DATE-TRUNC(E.BEGIN_DATE,'YY')) > (E.END_DATE-TRUNC(E.END_DATE,'YY'))
						AND (TO_CHAR(SDT.LOCAL_DAY_TRUNC_DATE,'MM-DD') <= TO_CHAR(E.BEGIN_DATE,'MM-DD')
						  OR TO_CHAR(SDT.LOCAL_DAY_TRUNC_DATE,'MM-DD') >= TO_CHAR(E.END_DATE,'MM-DD'))) )
			GROUP BY SDT.LOCAL_DATE;

    END IF;

	-- now that we have the data, set globals so that we can re-use the cached values
	-- if appropriate
	g_BATCH_WEATHER_STATION_ID := p_STATION_ID;
	g_BATCH_WEATHER_TEMPLATE_ID := p_TEMPLATE_ID;
	g_BATCH_WEATHER_PARAMETERS := p_PARAMETERS;
	g_BATCH_WEATHER_BEGIN_DATE := p_BEGIN_DATE;
	g_BATCH_WEATHER_END_DATE := p_END_DATE;
	g_BATCH_WEATHER_TIMESTAMP := p_BATCH_TIMESTAMP;

END CACHE_BATCH_WRF_WEATHER;
---------------------------------------------------------------------------------------------------
PROCEDURE GATHER_WRF_OBSERVATIONS
	(
	p_SRC_PROFILE_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
    p_PARAMETER_COUNT IN BINARY_INTEGER,
	p_HOUR IN NUMBER,
    p_SEGMENT_MIN IN NUMBER,
    p_SEGMENT_MAX IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_INPUT_AS_OF_DATE IN DATE,
	p_STATS IN OUT NOCOPY WRF_STAT_STRUCT,
	p_X IN OUT NOCOPY GA.NUMBER_TABLE,
	p_Y IN OUT NOCOPY GA.NUMBER_TABLE
    ) AS

v_STATUS NUMBER;
v_LOW_DATE DATE := LOW_DATE;
v_VERSIONED NUMBER;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_IS_EXTERNAL_INTERVAL_USAGE NUMBER(1);
v_USAGE USAGE_TABLE;
v_SEGMENT_MIN NUMBER := NVL(p_SEGMENT_MIN,-999999999999);
v_SEGMENT_MAX NUMBER := NVL(p_SEGMENT_MAX,999999999999);

CURSOR c_OBSERVATIONS IS
	SELECT A.POINT_DATE "LOAD_DATE",
    	A.POINT_VAL "LOAD_VAL",
        W.PARAMETER_1,W.PARAMETER_2, W.PARAMETER_3, W.PARAMETER_4, W.PARAMETER_5
    FROM WRF_BATCH_RUN_WEATHER W,
        LOAD_PROFILE_POINT A
	WHERE W.HOUR = p_HOUR
        AND A.PROFILE_ID = p_SRC_PROFILE_ID
    	AND A.POINT_INDEX = g_DEFAULT_INDEX
        AND A.POINT_DATE = W.PARAMETER_DATE
        AND A.AS_OF_DATE = v_LOW_DATE
        AND W.PARAMETER_1 > v_SEGMENT_MIN    --Limit to observations with primary parameter within segment limits
        AND W.PARAMETER_1 <= v_SEGMENT_MAX;

CURSOR c_OBSERVATIONS_VERSIONED IS
	SELECT A.POINT_DATE "LOAD_DATE",
    	A.POINT_VAL "LOAD_VAL",
        W.PARAMETER_1,W.PARAMETER_2, W.PARAMETER_3, W.PARAMETER_4, W.PARAMETER_5
    FROM WRF_BATCH_RUN_WEATHER W,
        LOAD_PROFILE_POINT A
	WHERE W.HOUR = p_HOUR
        AND A.PROFILE_ID = p_SRC_PROFILE_ID
    	AND A.POINT_INDEX = g_DEFAULT_INDEX
        AND A.POINT_DATE = W.PARAMETER_DATE
        AND A.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
					        					FROM LOAD_PROFILE_POINT
					                            WHERE PROFILE_ID = A.PROFILE_ID
					                            	AND POINT_INDEX = A.POINT_INDEX
					                                AND POINT_DATE = A.POINT_DATE
					                                AND AS_OF_DATE <= p_INPUT_AS_OF_DATE)
        AND W.PARAMETER_1 > v_SEGMENT_MIN    --Limit to observations with primary parameter within segment limits
        AND W.PARAMETER_1 <= v_SEGMENT_MAX;

CURSOR c_EXT_OBSERVATIONS RETURN c_OBSERVATIONS%ROWTYPE IS
	SELECT A.POINT_DATE "LOAD_DATE",
    	A.POINT_VAL "LOAD_VAL",
        W.PARAMETER_1,W.PARAMETER_2, W.PARAMETER_3, W.PARAMETER_4, W.PARAMETER_5
    FROM WRF_BATCH_RUN_WEATHER W,
        (SELECT X.USAGE_DATE "POINT_DATE", X.USAGE_VAL "POINT_VAL"
    		FROM TABLE(CAST(v_USAGE AS USAGE_TABLE)) X) A
	WHERE W.HOUR = p_HOUR
        AND A.POINT_DATE = W.PARAMETER_DATE
        AND W.PARAMETER_1 > v_SEGMENT_MIN    --Limit to observations with primary parameter within segment limits
        AND W.PARAMETER_1 <= v_SEGMENT_MAX;

v_OBSERVATION c_OBSERVATIONS%ROWTYPE;

BEGIN
    IF GA.VERSION_PROFILE THEN
    	v_VERSIONED := 1;
	ELSE
    	v_VERSIONED := 0;
	END IF;
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
    -- account uses external usage?
	BEGIN
		SELECT IS_EXTERNAL_INTERVAL_USAGE INTO v_IS_EXTERNAL_INTERVAL_USAGE
		FROM ACCOUNT WHERE ACCOUNT_ID = p_ACCOUNT_ID;
	EXCEPTION
    	WHEN OTHERS THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
    		v_IS_EXTERNAL_INTERVAL_USAGE := CONSTANTS.NOT_ASSIGNED;
	END;
	IF v_IS_EXTERNAL_INTERVAL_USAGE <> CONSTANTS.NOT_ASSIGNED THEN
		XS.GET_SAMPLE_INTERVAL_USAGE(CONSTANTS.NOT_ASSIGNED, CONSTANTS.NOT_ASSIGNED, p_ACCOUNT_ID, p_BEGIN_DATE, p_END_DATE, p_INPUT_AS_OF_DATE, LOCAL_TIME_ZONE, NULL, v_STATUS, v_USAGE);
		ERRS.VALIDATE_STATUS('XS.GET_SAMPLE_INTERVAL_USAGE', v_STATUS);
	END IF;

    p_X.DELETE;
    p_Y.DELETE;

    -- collect observations, and record statistic info on them also
	IF v_IS_EXTERNAL_INTERVAL_USAGE = CONSTANTS.NOT_ASSIGNED AND v_VERSIONED = 0 THEN
    	OPEN c_OBSERVATIONS;
    ELSIF v_IS_EXTERNAL_INTERVAL_USAGE = CONSTANTS.NOT_ASSIGNED THEN
    	OPEN c_OBSERVATIONS_VERSIONED;
    ELSE
    	OPEN c_EXT_OBSERVATIONS;
    END IF;

    LOOP
    	IF v_IS_EXTERNAL_INTERVAL_USAGE = CONSTANTS.NOT_ASSIGNED AND v_VERSIONED = 0 THEN
			FETCH c_OBSERVATIONS INTO v_OBSERVATION;
            EXIT WHEN c_OBSERVATIONS%NOTFOUND;
        ELSIF v_IS_EXTERNAL_INTERVAL_USAGE = CONSTANTS.NOT_ASSIGNED THEN
			FETCH c_OBSERVATIONS_VERSIONED INTO v_OBSERVATION;
            EXIT WHEN c_OBSERVATIONS_VERSIONED%NOTFOUND;
        ELSE
        	FETCH c_EXT_OBSERVATIONS INTO v_OBSERVATION;
            EXIT WHEN c_EXT_OBSERVATIONS%NOTFOUND;
        END IF;

		p_STATS.P_COUNT := NVL(p_STATS.P_COUNT,0)+1;
		p_STATS.P_SUM := NVL(p_STATS.P_SUM,0)+v_OBSERVATION.LOAD_VAL;
		IF v_OBSERVATION.LOAD_VAL > p_STATS.P_MAX OR p_STATS.P_MAX IS NULL THEN
			p_STATS.P_MAX := v_OBSERVATION.LOAD_VAL;
		END IF;
		IF v_OBSERVATION.LOAD_VAL < p_STATS.P_MIN OR p_STATS.P_MIN IS NULL THEN
			p_STATS.P_MIN := v_OBSERVATION.LOAD_VAL;
		END IF;
		IF (v_OBSERVATION.LOAD_VAL < p_STATS.P_NZMIN OR p_STATS.P_NZMIN IS NULL) AND v_OBSERVATION.LOAD_VAL <> 0 THEN
			p_STATS.P_NZMIN := v_OBSERVATION.LOAD_VAL;
		END IF;
		p_Y(p_Y.COUNT+1) := v_OBSERVATION.LOAD_VAL;
		p_X(p_X.COUNT+1) := 1; -- Constant
		p_X(p_X.COUNT+1) := v_OBSERVATION.PARAMETER_1;
		IF p_PARAMETER_COUNT > 1 THEN
			p_X(p_X.COUNT+1) := v_OBSERVATION.PARAMETER_2;
			IF p_PARAMETER_COUNT > 2 THEN
				p_X(p_X.COUNT+1) := v_OBSERVATION.PARAMETER_3;
				IF p_PARAMETER_COUNT > 3 THEN
					p_X(p_X.COUNT+1) := v_OBSERVATION.PARAMETER_4;
					IF p_PARAMETER_COUNT > 4 THEN
						p_X(p_X.COUNT+1) := v_OBSERVATION.PARAMETER_5;
					END IF;
				END IF;
			END IF;
		END IF;
	END LOOP;
	IF v_IS_EXTERNAL_INTERVAL_USAGE = CONSTANTS.NOT_ASSIGNED AND v_VERSIONED = 0 THEN
    	CLOSE c_OBSERVATIONS;
    ELSIF v_IS_EXTERNAL_INTERVAL_USAGE = CONSTANTS.NOT_ASSIGNED THEN
    	CLOSE c_OBSERVATIONS_VERSIONED;
    ELSE
    	CLOSE c_EXT_OBSERVATIONS;
    END IF;

	TRACE_WRF_XY_VARIABLES(p_X, p_Y);

END GATHER_WRF_OBSERVATIONS;
---------------------------------------------------------------------------------------------------
PROCEDURE CALCULATE_WRF_PROFILE_SEGMENT
	(
	p_PARAMETER_COUNT IN BINARY_INTEGER,
	p_X IN OUT NOCOPY GA.NUMBER_TABLE,
	p_Y IN OUT NOCOPY GA.NUMBER_TABLE,
	p_COEFF IN OUT NOCOPY GA.NUMBER_TABLE,
	p_TSTATS IN OUT NOCOPY GA.NUMBER_TABLE,
	p_R2 OUT NUMBER,
	p_TSTAT_CRITICAL OUT NUMBER,
	p_STATS IN OUT NOCOPY WRF_STAT_STRUCT,
	p_COEFF_ALL_ZEROES OUT BOOLEAN,
	p_CALC_ERR IN BOOLEAN := TRUE
    ) AS
v_N NUMBER; -- Number Of Observations
v_M NUMBER; -- Number Of Independent Varaibles
v_MVAR_ELAPSED_TIME PLS_INTEGER;
v_ELAPSED_TIME PLS_INTEGER := DBMS_UTILITY.GET_TIME;
v_INDEX BINARY_INTEGER;
v_FCAST NUMBER(24,8);
v_ACTUAL NUMBER(24,8);
v_APE NUMBER;
v_ERR NUMBER(24,8);
v_TRACE_LIST VARCHAR2(4000);
BEGIN
	v_N := p_Y.COUNT;
    v_M := p_PARAMETER_COUNT+1;

    -- do the regression
    IF v_N >= 4 THEN
	    UT.MVAR_REG(v_N, v_M, p_X, p_Y, p_COEFF, p_TSTATS, p_R2, p_TSTAT_CRITICAL, v_MVAR_ELAPSED_TIME);
		-- all zeroes?
		FOR v_INDEX IN 1..v_M LOOP
			p_STATS.ALL_ZEROES := p_STATS.ALL_ZEROES AND (p_COEFF(v_INDEX) = 0);
		END LOOP;
	ELSE
    	-- too few data points - store flat line
    	p_COEFF.DELETE;
        p_TSTATS.DELETE;
        p_R2 := 0;
        FOR v_INDEX IN 1..v_M LOOP
        	p_COEFF(v_INDEX) := 0;
            p_TSTATS(v_INDEX) := 0;
        END LOOP;
		p_COEFF_ALL_ZEROES := TRUE;
    END IF;

	-- calculate error and APE (absolute percent error) for each observation and add info to p_STATS
	IF p_CALC_ERR THEN
	    -- get APE for each observation
		IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
			LOGS.LOG_DEBUG_DETAIL('Observations=' || TO_CHAR(v_N));
			LOGS.LOG_DEBUG_DETAIL('SEG_APE, ACTUAL, FCAST, Constant, PARAM1, Coeff1, PARAM2, Coeff2, PARAM3, Coeff3, PARAM4, Coeff4, PARAM5, Coeff5');
		END IF;
		IF v_N > 0 THEN
			v_APE := 0;
			FOR v_INDEX IN 1..v_N LOOP
				v_ACTUAL := p_Y(v_INDEX);
				v_FCAST := p_COEFF(1); -- constant
				v_FCAST := v_FCAST + p_X((v_INDEX-1)*v_M + 2) * p_COEFF(2); -- plus param1*coeff1
				IF p_PARAMETER_COUNT > 1 THEN
					v_FCAST := v_FCAST + p_X((v_INDEX-1)*v_M + 3) * p_COEFF(3);
					IF p_PARAMETER_COUNT > 2 THEN
						v_FCAST := v_FCAST + p_X((v_INDEX-1)*v_M + 4) * p_COEFF(4);
						IF p_PARAMETER_COUNT > 3 THEN
							v_FCAST := v_FCAST + p_X((v_INDEX-1)*v_M + 5) * p_COEFF(5);
							IF p_PARAMETER_COUNT > 4 THEN
								v_FCAST := v_FCAST + p_X((v_INDEX-1)*v_M + 6) * p_COEFF(6);
							END IF;
						END IF;
					END IF;
				END IF;

				v_ERR := GREATEST(v_FCAST,0) - v_ACTUAL;

				p_STATS.P_ERR_SUM := NVL(p_STATS.P_ERR_SUM,0) + v_ERR; -- Don't use ABS error, let +/- offset - cf
				IF v_ACTUAL <> 0 THEN
					p_STATS.APE(p_STATS.APE.COUNT+1) := 100 * ABS(v_ERR/v_ACTUAL);
					IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
						v_TRACE_LIST := '';
						IF p_PARAMETER_COUNT > 1 THEN
							v_TRACE_LIST := v_TRACE_LIST  || ', ' || TO_CHAR(ROUND(p_X((v_INDEX-1)*v_M + 3),5)) || ', ' || TO_CHAR(ROUND(p_COEFF(3),7));
							IF p_PARAMETER_COUNT > 2 THEN
								v_TRACE_LIST := v_TRACE_LIST || ', ' || TO_CHAR(ROUND(p_X((v_INDEX-1)*v_M + 4),5)) || ', ' || TO_CHAR(ROUND(p_COEFF(4),7));
								IF p_PARAMETER_COUNT > 3 THEN
									v_TRACE_LIST := v_TRACE_LIST || ', ' || TO_CHAR(ROUND(p_X((v_INDEX-1)*v_M + 5),5)) || ', ' || TO_CHAR(ROUND(p_COEFF(5),7));
									IF p_PARAMETER_COUNT > 4 THEN
										v_TRACE_LIST := v_TRACE_LIST || ', ' || TO_CHAR(ROUND(p_X((v_INDEX-1)*v_M + 6),5)) || ', ' || TO_CHAR(ROUND(p_COEFF(6),7));
									END IF;
								END IF;
							END IF;
						END IF;
						LOGS.LOG_DEBUG_DETAIL(TO_CHAR(ROUND(p_STATS.APE(p_STATS.APE.COUNT),8)) || ', ' || TO_CHAR(ROUND(v_ACTUAL,8)) || ', ' || TO_CHAR(ROUND(v_FCAST,5)) || ', ' || TO_CHAR(ROUND(p_COEFF(1),6)) || ', ' || TO_CHAR(ROUND(p_X((v_INDEX-1)*v_M + 2),5)) || ', ' || TO_CHAR(ROUND(p_COEFF(2),7)) || v_TRACE_LIST);
					END IF;
					v_APE := v_APE + p_STATS.APE(p_STATS.APE.COUNT);  --running total APE
				END IF;
			END LOOP;
		END IF;

		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG('SEGMENT Total Load = ' || TO_CHAR(ROUND(p_STATS.P_SUM, 8)));
			LOGS.LOG_DEBUG('SEGMENT Total Error = ' || TO_CHAR(ROUND(p_STATS.P_ERR_SUM, 8)));
			IF p_STATS.P_SUM <> 0 THEN
				LOGS.LOG_DEBUG('SEGMENT Total Error % = ' || TO_CHAR(ROUND((100 * p_STATS.P_ERR_SUM / p_STATS.P_SUM), 8)));
			END IF;
			IF p_STATS.APE.COUNT > 0 THEN
				 v_APE := v_APE / p_STATS.APE.COUNT;
				 LOGS.LOG_DEBUG('MAPE = ' || TO_CHAR(ROUND(v_APE,8)));
			END IF;
			LOGS.LOG_DEBUG('CREATE_WRF_PROFILE_SEGMENT ELAPSED TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED_TIME) || ', MVAR_REG ELAPSED TIME=' || TO_CHAR(v_MVAR_ELAPSED_TIME));
		END IF;
	END IF;

	-- more statistics info
	IF p_R2 <> 0 THEN
		p_STATS.R2COUNT := p_STATS.R2COUNT + 1;

		IF p_R2 > p_STATS.R2MAX OR p_STATS.R2MAX IS NULL THEN
			p_STATS.R2MAX := p_R2;
		END IF;

		IF p_R2 < p_STATS.R2MIN OR p_STATS.R2MIN IS NULL THEN
			p_STATS.R2MIN := p_R2;
		END IF;

		IF ABS(p_R2) < p_STATS.R2THRESHOLD THEN
			p_STATS.R2FAIL := p_STATS.R2FAIL + 1;
		END IF;
	END IF;

	IF p_STATS.TEMP_IDX >= 0 THEN
		IF ABS(p_TSTATS(p_STATS.TEMP_IDX)) < p_TSTAT_CRITICAL THEN
			p_STATS.T_TEMP := p_STATS.T_TEMP + 1;
		END IF;
	END IF;

	IF p_STATS.HUMID_IDX >= 0 THEN
		IF ABS(p_TSTATS(p_STATS.HUMID_IDX)) < p_TSTAT_CRITICAL THEN
			p_STATS.T_HUMID := p_STATS.T_HUMID + 1;
		END IF;
	END IF;

	IF p_STATS.WIND_IDX >= 0 THEN
		IF ABS(p_TSTATS(p_STATS.WIND_IDX)) < p_TSTAT_CRITICAL THEN
			p_STATS.T_WIND := p_STATS.T_WIND + 1;
		END IF;
	END IF;

END CALCULATE_WRF_PROFILE_SEGMENT;
---------------------------------------------------------------------------------------------------
PROCEDURE FINALIZE_STATS
	(
	p_STATS IN OUT NOCOPY WRF_STAT_STRUCT
	) AS
v_DUMMY NUMBER;
BEGIN
	-- wrap up stat calcs
	IF p_STATS.R2COUNT = 0 THEN
		p_STATS.R2FAIL := 100;
	ELSE
		p_STATS.R2FAIL := 100*(p_STATS.R2FAIL/p_STATS.R2COUNT);
	END IF;
	p_STATS.T_TEMP := 100*(p_STATS.T_TEMP/72);
	p_STATS.T_HUMID := 100*(p_STATS.T_HUMID/72);
	p_STATS.T_WIND := 100*(p_STATS.T_WIND/72);
	IF p_STATS.APE.COUNT > 0 THEN
		UT.STD_DEV(p_STATS.APE,v_DUMMY,p_STATS.MAPE,p_STATS.STDAPE,v_DUMMY,v_DUMMY,v_DUMMY);
	ELSE
		p_STATS.MAPE := NULL;
		p_STATS.STDAPE := NULL;
	END IF;

	IF p_STATS.P_SUM <> 0 THEN
	   p_STATS.TOT_ERR_PCT := 100 * p_STATS.P_ERR_SUM / p_STATS.P_SUM;
	ELSE
	   p_STATS.TOT_ERR_PCT := 0;
	END IF;
END FINALIZE_STATS;
---------------------------------------------------------------------------------------------------
FUNCTION FCM_CALCULATE_CLUSTER_ITER
	(
	p_M IN NUMBER,
	p_MEMBERSHIP IN OUT NOCOPY MATRIX,
	p_CLUSTERS IN OUT NOCOPY POINT_TABLE,
	p_OBSERVATIONS IN POINT_TABLE
	) RETURN NUMBER IS

-- will store distances between observations and cluster centers
v_DISTANCES			MATRIX;
-- needed to compute delta return value
v_ORIG_MEMBERSHIP	MATRIX := p_MEMBERSHIP;
v_RET				NUMBER;

v_IDX				BINARY_INTEGER;
v_JDX				BINARY_INTEGER;
v_KDX				BINARY_INTEGER;
v_WEIGHT			NUMBER;
v_MEMBERSHIP_M		NUMBER;
v_DELTA_X			NUMBER;
v_DELTA_Y			NUMBER;
v_DELTA				NUMBER;
v_DIVISOR			NUMBER;
BEGIN
	-- compute cluster centers
	v_JDX := p_CLUSTERS.FIRST;
	WHILE p_CLUSTERS.EXISTS(v_JDX) LOOP
		v_WEIGHT := 0;
		p_CLUSTERS(v_JDX).X := 0;
		p_CLUSTERS(v_JDX).Y := 0;

		v_IDX := p_OBSERVATIONS.FIRST;
		WHILE p_OBSERVATIONS.EXISTS(v_IDX) LOOP
			v_MEMBERSHIP_M := POWER(p_MEMBERSHIP(v_IDX)(v_JDX), p_M);
			v_WEIGHT := v_WEIGHT + v_MEMBERSHIP_M;

			P_CLUSTERS(v_JDX).X := P_CLUSTERS(v_JDX).X +
								v_MEMBERSHIP_M * p_OBSERVATIONS(v_IDX).X;
			P_CLUSTERS(v_JDX).Y := P_CLUSTERS(v_JDX).Y +
								v_MEMBERSHIP_M * p_OBSERVATIONS(v_IDX).Y;

			v_IDX := p_OBSERVATIONS.NEXT(v_IDX);
		END LOOP;

		-- Avoid divide by zero
		IF v_WEIGHT = 0 THEN
		   p_CLUSTERS(v_JDX).X := 0;
		   p_CLUSTERS(v_JDX).Y := 0;
		ELSE
		   p_CLUSTERS(v_JDX).X := p_CLUSTERS(v_JDX).X / V_WEIGHT;
		   p_CLUSTERS(v_JDX).Y := p_CLUSTERS(v_JDX).Y / V_WEIGHT;
		END IF;
		v_JDX := p_CLUSTERS.NEXT(v_JDX);
	END LOOP;

	-- compute distance matrix
	v_IDX := p_OBSERVATIONS.FIRST;
	WHILE p_OBSERVATIONS.EXISTS(v_IDX) LOOP
		v_JDX := p_CLUSTERS.FIRST;
		WHILE p_CLUSTERS.EXISTS(v_JDX) LOOP
			v_DELTA_X := p_OBSERVATIONS(v_IDX).X - p_CLUSTERS(v_JDX).X;
			v_DELTA_Y := p_OBSERVATIONS(v_IDX).Y - p_CLUSTERS(v_JDX).Y;

			v_DISTANCES(v_IDX)(v_JDX) := SQRT(v_DELTA_X*v_DELTA_X +
											  v_DELTA_Y*v_DELTA_Y);

			v_JDX := p_CLUSTERS.NEXT(v_JDX);
		END LOOP;
		v_IDX := p_OBSERVATIONS.NEXT(v_IDX);
	END LOOP;

	-- compute membership matrix
	v_RET := 0;
	v_IDX := p_OBSERVATIONS.FIRST;
	WHILE p_OBSERVATIONS.EXISTS(v_IDX) LOOP
		v_JDX := p_CLUSTERS.FIRST;
		WHILE p_CLUSTERS.EXISTS(v_JDX) LOOP
			v_DIVISOR := 0;

			v_KDX := p_CLUSTERS.FIRST;
			WHILE p_CLUSTERS.EXISTS(v_KDX) LOOP
				IF v_DISTANCES(v_IDX)(v_KDX) = 0 THEN
					v_DIVISOR := 0;
					EXIT;
				END IF;

				v_DIVISOR := v_DIVISOR +
							 POWER(
								v_DISTANCES(v_IDX)(v_JDX)/v_DISTANCES(v_IDX)(v_KDX),
								2 / (p_M - 1)
								);

				v_KDX := p_CLUSTERS.NEXT(v_KDX);
			END LOOP;

			IF v_DIVISOR = 0 THEN
				p_MEMBERSHIP(v_IDX)(v_JDX) := 999999999;
			ELSE
				p_MEMBERSHIP(v_IDX)(v_JDX) := 1 / v_DIVISOR;
			END IF;

			v_DELTA := ABS ( p_MEMBERSHIP(v_IDX)(v_JDX) - v_ORIG_MEMBERSHIP(v_IDX)(v_JDX) );
			IF v_DELTA > v_RET THEN
				v_RET := v_DELTA;
			END IF;

			v_JDX := p_CLUSTERS.NEXT(v_JDX);
		END LOOP;

		v_IDX := p_OBSERVATIONS.NEXT(v_IDX);
	END LOOP;

	-- return the maximum delta in membership matrix for this iteration. computed in previous step
	RETURN v_RET;
END FCM_CALCULATE_CLUSTER_ITER;
---------------------------------------------------------------------------------------------------
PROCEDURE FCM_CALCULATE_CLUSTERS
	(
	p_CANDIDATE IN OUT NOCOPY WRF_FCM_CANDIDATE%ROWTYPE,
	p_M IN NUMBER,
	p_TERMINATION IN NUMBER,
	p_MAX_ITER IN NUMBER
	) AS

v_OBSERVATIONS POINT_TABLE;
v_CLUSTERS POINT_TABLE;
v_MEMBERSHIP MATRIX;
v_ASSIGNMENT GA.NUMBER_TABLE;
v_CUR_ITER NUMBER;
v_DELTA NUMBER;
v_DONE BOOLEAN;
v_ROWNUM BINARY_INTEGER;
v_IDX BINARY_INTEGER;
v_JDX BINARY_INTEGER;
v_MIN NUMBER;
v_MAX NUMBER;
v_X_LO NUMBER;
v_X_HI NUMBER;
v_Y_LO NUMBER;
v_Y_HI NUMBER;
v_Y2X_RATIO NUMBER;
v_SEGMENT_LIMITS POINT_TABLE; -- X is segment Max, Y is Segment Min

v_PROFILE_ID LOAD_PROFILE.PROFILE_ID%TYPE;
v_HOUR_NUM WRF_FCM.HOUR_NUM%TYPE;
v_NUM_OF_CLUSTERS NUMBER(1);

CURSOR cur_OBSERVATIONS IS
	SELECT OBSERVATION_X,
		OBSERVATION_Y,
		OBSERVATION_NUM,
		COUNT(1) OVER (PARTITION BY 1) as TOTAL_COUNT
	FROM WRF_FCM_OBSERVATION
	WHERE FCM_ID = p_CANDIDATE.FCM_ID
	ORDER BY OBSERVATION_X; -- order by X so we can default membership
							-- matrix to partition observations along X axis into clusters

BEGIN

	--	Initialize v_CLUSTERS collection with p_CANDIDATE.NUM_SEGMENTS entries,
	--	Each initialized to the origin (0,0)
	FOR v_IDX IN 1..p_CANDIDATE.NUM_SEGMENTS LOOP
		v_CLUSTERS(v_IDX).X := 0;
		v_CLUSTERS(v_IDX).Y := 0;
	END LOOP;

	-- ratio used to scale/normalize values so that pythagorean distance
	-- calculations in cluster identification algorithm make sense.
	v_Y2X_RATIO := GET_DICTIONARY_VALUE('Load/Weather Ratio', CONSTANTS.GLOBAL_MODEL, 'Profiling', 'WRF', 'FCM');
	IF v_Y2X_RATIO <= 0 THEN
		v_Y2X_RATIO := NULL; -- null indicates "auto" ratio
	END IF;

	-- Query observations from WRF_FCM_OBSERVATIONS
	-- and store into v_OBSERVATIONS. Also initialize v_MEMBERSHIP
	-- matrix with 1's and 0's spread evenly across
	v_ROWNUM := 0;
	FOR v_OBSERVATION IN cur_OBSERVATIONS LOOP
		v_OBSERVATIONS(v_OBSERVATION.OBSERVATION_NUM).X := v_OBSERVATION.OBSERVATION_X;
		v_OBSERVATIONS(v_OBSERVATION.OBSERVATION_NUM).Y := v_OBSERVATION.OBSERVATION_Y;
		-- determine to which cluster this observation belongs by default:
		v_JDX := FLOOR((v_ROWNUM)/v_OBSERVATION.TOTAL_COUNT*p_CANDIDATE.NUM_SEGMENTS)+1;
		-- init membership matrix for this observation
		FOR v_IDX IN 1..p_CANDIDATE.NUM_SEGMENTS LOOP
			v_MEMBERSHIP(v_OBSERVATION.OBSERVATION_NUM)(v_IDX) := CASE WHEN v_IDX = v_JDX THEN 1 ELSE 0 END;
		END LOOP;
		v_ROWNUM := v_ROWNUM+1;
		-- track min/max load and weather values to compute "auto" ratio
		IF v_Y2X_RATIO IS NULL THEN
			-- get min/max X axis values
			IF v_X_LO IS NULL OR v_OBSERVATION.OBSERVATION_X < v_X_LO THEN
				v_X_LO := v_OBSERVATION.OBSERVATION_X;
			END IF;
			IF v_X_HI IS NULL OR v_OBSERVATION.OBSERVATION_X > v_X_HI THEN
				v_X_HI := v_OBSERVATION.OBSERVATION_X;
			END IF;
			-- get min/max Y axis values
			IF v_Y_LO IS NULL OR v_OBSERVATION.OBSERVATION_Y < v_Y_LO THEN
				v_Y_LO := v_OBSERVATION.OBSERVATION_Y;
			END IF;
			IF v_Y_HI IS NULL OR v_OBSERVATION.OBSERVATION_Y > v_Y_HI THEN
				v_Y_HI := v_OBSERVATION.OBSERVATION_Y;
			END IF;
		END IF;
	END LOOP;
	-- compute "auto" ratio if needed
	IF v_Y2X_RATIO IS NULL THEN
		IF (v_X_HI - v_X_LO) = 0 THEN
			v_Y2X_RATIO := 1.0; -- avoid divide by zero
		ELSE
			v_Y2X_RATIO := (v_Y_HI - v_Y_LO) / (v_X_HI - v_X_LO);
		END IF;
	END IF;
	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('Load/Weather Ratio = '||v_Y2X_RATIO);
	END IF;

	-- if the ratio is 1.0 then there is nothing to do.
	-- if the ratio is 0.0 then don't do anything either (avoid divide by zero)
	IF NVL(v_Y2X_RATIO, 1.0) <> 1.0 AND NVL(v_Y2X_RATIO, 1.0) <> 0.0 THEN
		-- scale Y values by dividing them by the ratio
		v_IDX := v_OBSERVATIONS.FIRST;
		WHILE v_OBSERVATIONS.EXISTS(v_IDX) LOOP
			v_OBSERVATIONS(v_IDX).Y := v_OBSERVATIONS(v_IDX).Y / v_Y2X_RATIO;
			v_IDX := v_OBSERVATIONS.NEXT(v_IDX);
		END LOOP;
	END IF;

	-- perform the FCM algorithm to compute cluster centers
	v_DONE := FALSE;
	v_CUR_ITER := 0;
	WHILE NOT v_DONE LOOP
		v_CUR_ITER := v_CUR_ITER+1;
		v_DELTA := FCM_CALCULATE_CLUSTER_ITER(p_M, v_MEMBERSHIP, v_CLUSTERS, v_OBSERVATIONS);

		IF v_CUR_ITER >= p_MAX_ITER OR v_DELTA < p_TERMINATION THEN
			v_DONE := TRUE;
		END IF;
	END LOOP;

	-- Store cluster details and membership matrix to
	-- WRF_FCM_CLUSTER and WRF_FCM_CLUSTER_MEMBERSHIP tables
	v_JDX := v_CLUSTERS.FIRST;
	WHILE v_CLUSTERS.EXISTS(v_JDX) LOOP
		-- store cluster
		INSERT INTO WRF_FCM_CLUSTER (FCM_ID, NUM_SEGMENTS, CLUSTER_NUM, CENTER_X, CENTER_Y)
			VALUES (p_CANDIDATE.FCM_ID, p_CANDIDATE.NUM_SEGMENTS, v_JDX, v_CLUSTERS(v_JDX).X, v_CLUSTERS(v_JDX).Y);

		v_IDX := v_OBSERVATIONS.FIRST;
		WHILE v_OBSERVATIONS.EXISTS(v_IDX) LOOP
			-- store membership
			INSERT INTO WRF_FCM_CLUSTER_MEMBERSHIP (FCM_ID, NUM_SEGMENTS, CLUSTER_NUM, OBSERVATION_NUM, MEMBERSHIP)
				VALUES (p_CANDIDATE.FCM_ID, p_CANDIDATE.NUM_SEGMENTS, v_JDX, v_IDX, v_MEMBERSHIP(v_IDX)(v_JDX));
			-- track current assignment (i.e. max(membership) so far) in v_ASSIGNMENT
			IF v_ASSIGNMENT.EXISTS(v_IDX) THEN
				-- current membership value greater than current assignment?
				IF v_MEMBERSHIP(v_IDX)(v_JDX) > v_MEMBERSHIP(v_IDX)(v_ASSIGNMENT(v_IDX)) THEN
					-- then this is the new assignment
					v_ASSIGNMENT(v_IDX) := v_JDX;
				END IF;
			ELSE
				v_ASSIGNMENT(v_IDX) := v_JDX;
			END IF;
			-- on to the next observation...
			v_IDX := v_OBSERVATIONS.NEXT(v_IDX);
		END LOOP;

		v_JDX := v_CLUSTERS.NEXT(v_JDX);
	END LOOP;

	-- Store cluster assignments to WRF_FCM_CLUSTER_ASSIGNMENT
	v_IDX := v_ASSIGNMENT.FIRST;
	WHILE v_ASSIGNMENT.EXISTS(v_IDX) LOOP
		INSERT INTO WRF_FCM_CLUSTER_ASSIGNMENT (FCM_ID, NUM_SEGMENTS, OBSERVATION_NUM, CLUSTER_NUM)
			VALUES (p_CANDIDATE.FCM_ID, p_CANDIDATE.NUM_SEGMENTS, v_IDX, v_ASSIGNMENT(v_IDX));
		v_IDX := v_ASSIGNMENT.NEXT(v_IDX);
	END LOOP;

	-- Compute segment boundaries for each cluster
	SELECT MIN(OBSERVATION_X), MAX(OBSERVATION_X)
	INTO v_MIN, v_MAX
	FROM WRF_FCM_OBSERVATION
	WHERE FCM_ID = p_CANDIDATE.FCM_ID;

	SELECT COUNT(DISTINCT WCA.CLUSTER_NUM)
	INTO v_NUM_OF_CLUSTERS
	FROM WRF_FCM_CLUSTER_ASSIGNMENT WCA
	WHERE WCA.FCM_ID = p_CANDIDATE.FCM_ID
		AND WCA.NUM_SEGMENTS = p_CANDIDATE.NUM_SEGMENTS;

	IF v_NUM_OF_CLUSTERS <> p_CANDIDATE.NUM_SEGMENTS THEN
		SELECT WF.PROFILE_ID, WF.HOUR_NUM
		INTO v_PROFILE_ID, v_HOUR_NUM
		FROM WRF_FCM WF
		WHERE WF.FCM_ID = p_CANDIDATE.FCM_ID;

		LOGS.LOG_WARN('Unable to break down observations into required number of segments.'
			|| ' Not enough variation in the primary weather parameter (Minimum value: '
			|| v_MIN || ' Maximum Value: ' || v_MAX
			|| ') for Profile: ' || GET_PROFILE_NAME(v_PROFILE_ID)
			||', Candidate: ' || p_CANDIDATE.NUM_SEGMENTS
			|| ' at Hour: ' || v_HOUR_NUM || '.');

	END IF;

	FOR v_IDX IN 1..p_CANDIDATE.NUM_SEGMENTS LOOP
		-- find min and max values for this cluster
		SELECT MIN(O.OBSERVATION_X), MAX(O.OBSERVATION_X)
		INTO v_SEGMENT_LIMITS(v_IDX).Y, v_SEGMENT_LIMITS(v_IDX).X
		FROM WRF_FCM_CLUSTER_ASSIGNMENT A,
			WRF_FCM_OBSERVATION O
		WHERE A.FCM_ID = p_CANDIDATE.FCM_ID
			AND A.NUM_SEGMENTS = p_CANDIDATE.NUM_SEGMENTS
			AND A.CLUSTER_NUM = v_IDX
			AND O.FCM_ID = p_CANDIDATE.FCM_ID
			AND O.OBSERVATION_NUM = A.OBSERVATION_NUM;

		IF v_IDX = v_CLUSTERS.FIRST THEN
			v_SEGMENT_LIMITS(v_IDX).Y := v_MIN; -- set to absolute min of all observations
		ELSE
			-- find midpoint between this cluster's min and previous cluster's max
			v_SEGMENT_LIMITS(v_IDX).Y := (v_SEGMENT_LIMITS(v_IDX).Y + v_SEGMENT_LIMITS(v_IDX-1).X) / 2;

			-- now we can store previous cluster
			UPDATE WRF_FCM_CLUSTER SET
				SEGMENT_MIN = v_SEGMENT_LIMITS(v_IDX-1).Y,
				SEGMENT_MAX = v_SEGMENT_LIMITS(v_IDX).Y
			WHERE FCM_ID = p_CANDIDATE.FCM_ID
				AND NUM_SEGMENTS = p_CANDIDATE.NUM_SEGMENTS
				AND CLUSTER_NUM = v_IDX-1;
		END IF;

		-- is this the last cluster? then we can save this one, too
		IF v_IDX = v_CLUSTERS.LAST THEN
			UPDATE WRF_FCM_CLUSTER SET
				SEGMENT_MIN = v_SEGMENT_LIMITS(v_IDX).Y,
				SEGMENT_MAX = v_MAX -- set to absolute max of all observations
			WHERE FCM_ID = p_CANDIDATE.FCM_ID
				AND NUM_SEGMENTS = p_CANDIDATE.NUM_SEGMENTS
				AND CLUSTER_NUM = v_IDX;
		END IF;
	END LOOP;

	-- set outbound number of iterations required to converge
	p_CANDIDATE.NUM_ITERATIONS := v_CUR_ITER;

END FCM_CALCULATE_CLUSTERS;
---------------------------------------------------------------------------------------------------
PROCEDURE GATHER_FCM_OBSERVATIONS
	(
	p_FCM_ID IN NUMBER,
	p_NUM_SEGMENTS IN NUMBER,
	p_CLUSTER_NUM IN NUMBER,
	p_PARAMETER_COUNT IN BINARY_INTEGER,
	p_X IN OUT NOCOPY GA.NUMBER_TABLE,
	p_Y IN OUT NOCOPY GA.NUMBER_TABLE
	) AS
CURSOR cur_OBSERVATIONS IS
	SELECT O.*
	FROM WRF_FCM_OBSERVATION O,
		WRF_FCM_CLUSTER C
	WHERE C.FCM_ID = p_FCM_ID
		AND C.NUM_SEGMENTS = p_NUM_SEGMENTS
		AND C.CLUSTER_NUM = p_CLUSTER_NUM
		AND O.FCM_ID = C.FCM_ID
		AND (O.OBSERVATION_X > C.SEGMENT_MIN OR C.CLUSTER_NUM = 1)
		AND O.OBSERVATION_X <= C.SEGMENT_MAX
	ORDER BY O.OBSERVATION_NUM; -- order the set so we can update each later
							  -- with its corresponding APE value after the
							  -- regression is calculated
BEGIN
	p_X.DELETE;
	p_Y.DELETE;
	-- load observations for specified cluster into p_X and p_Y
	FOR v_OBSERVATION IN cur_OBSERVATIONS LOOP
		p_Y(p_Y.COUNT+1) := v_OBSERVATION.OBSERVATION_Y;
		p_X(p_X.COUNT+1) := 1; -- Constant
		p_X(p_X.COUNT+1) := v_OBSERVATION.OBSERVATION_X;
		IF p_PARAMETER_COUNT > 1 THEN
			p_X(p_X.COUNT+1) := v_OBSERVATION.OBSERVATION_P2;
			IF p_PARAMETER_COUNT > 2 THEN
				p_X(p_X.COUNT+1) := v_OBSERVATION.OBSERVATION_P3;
				IF p_PARAMETER_COUNT > 3 THEN
					p_X(p_X.COUNT+1) := v_OBSERVATION.OBSERVATION_P4;
					IF p_PARAMETER_COUNT > 4 THEN
						p_X(p_X.COUNT+1) := v_OBSERVATION.OBSERVATION_P5;
					END IF;
				END IF;
			END IF;
		END IF;
	END LOOP;
END GATHER_FCM_OBSERVATIONS;
---------------------------------------------------------------------------------------------------
PROCEDURE STORE_FCM_CLUSTER_COEFF
	(
	p_FCM_ID IN NUMBER,
	p_NUM_SEGMENTS IN NUMBER,
	p_CLUSTER_NUM IN NUMBER,
	p_COEFF IN GA.NUMBER_TABLE,
	p_TSTAT IN GA.NUMBER_TABLE,
	p_R2 IN NUMBER,
	p_TSTAT_CRITICAL IN NUMBER
	) AS
v_REC	WRF_FCM_CLUSTER%ROWTYPE;
BEGIN
	-- get existing data in the table
	SELECT * INTO v_REC
	FROM WRF_FCM_CLUSTER
	wHERE FCM_ID = p_FCM_ID
		AND NUM_SEGMENTS = p_NUM_SEGMENTS
		AND CLUSTER_NUM = p_CLUSTER_NUM;

	-- set the coefficients and t-stats
	v_REC.R_SQUARED := p_R2;
	v_REC.TSTAT_CRITICAL := p_TSTAT_CRITICAL;
	v_REC.COEFF_0 := p_COEFF(1);
	v_REC.TSTAT_0 := p_TSTAT(1);

	IF p_COEFF.COUNT > 1 THEN
		v_REC.COEFF_1 := p_COEFF(2);
		v_REC.TSTAT_1 := p_TSTAT(2);
		IF p_COEFF.COUNT > 2 THEN
			v_REC.COEFF_2 := p_COEFF(3);
			v_REC.TSTAT_2 := p_TSTAT(3);
			IF p_COEFF.COUNT > 3 THEN
				v_REC.COEFF_3 := p_COEFF(4);
				v_REC.TSTAT_3 := p_TSTAT(4);
				IF p_COEFF.COUNT > 4 THEN
					v_REC.COEFF_4 := p_COEFF(5);
					v_REC.TSTAT_4 := p_TSTAT(5);
					IF p_COEFF.COUNT > 5 THEN
						v_REC.COEFF_5 := p_COEFF(6);
						v_REC.TSTAT_5 := p_TSTAT(6);
					END IF;
				END IF;
			END IF;
		END IF;
	END IF;

	-- now do the update
	UPDATE WRF_FCM_CLUSTER SET ROW = v_REC
	wHERE FCM_ID = p_FCM_ID
		AND NUM_SEGMENTS = p_NUM_SEGMENTS
		AND CLUSTER_NUM = p_CLUSTER_NUM;

END STORE_FCM_CLUSTER_COEFF;
---------------------------------------------------------------------------------------------------
PROCEDURE FINALIZE_CANDIDATE_STATS
	(
	p_CANDIDATE IN OUT NOCOPY WRF_FCM_CANDIDATE%ROWTYPE,
	p_STATS IN OUT NOCOPY WRF_STAT_STRUCT
	) AS
v_ERR			NUMBER;
v_APE_SUM		NUMBER := 0;
v_APE_COUNT		PLS_INTEGER := 0;
-- compute forecast - but use segment boundaries defined in WRF_FCM_CLUSTER, not the actual cluster
-- assignment in WRF_FCM_CLUSTER_ASSIGNMENT - because these boundaries is what actual forecast engine
-- will use, which won't match cluster assignment in cases where clusters overlap along X axis
CURSOR cur_FORECAST IS
	SELECT O.OBSERVATION_NUM, O.OBSERVATION_Y as ACTUAL,
			-- use stored coefficients and observations to compute forecast
			NVL(C.COEFF_0,0) + NVL(C.COEFF_1,0)*NVL(O.OBSERVATION_X,0) + NVL(C.COEFF_2,0)*NVL(O.OBSERVATION_P2,0) +
				NVL(C.COEFF_3,0)*NVL(O.OBSERVATION_P3,0) + NVL(C.COEFF_4,0)*NVL(O.OBSERVATION_P4,0) + NVL(C.COEFF_5,0)*NVL(O.OBSERVATION_P5,0) as FORECAST
	FROM WRF_FCM_OBSERVATION O,
		WRF_FCM_CLUSTER C
	WHERE O.FCM_ID = p_CANDIDATE.FCM_ID
		AND C.FCM_ID = p_CANDIDATE.FCM_ID
		AND C.NUM_SEGMENTS = p_CANDIDATE.NUM_SEGMENTS
	 	AND ((C.CLUSTER_NUM = 1 AND C.SEGMENT_MIN <= O.OBSERVATION_X) OR (C.SEGMENT_MIN < O.OBSERVATION_X))
		AND C.SEGMENT_MAX >= O.OBSERVATION_X;
BEGIN
	-- compute error and APE for this candidate
	p_STATS.APE.DELETE;
	FOR v_FORECAST IN cur_FORECAST LOOP
		v_ERR := GREATEST(v_FORECAST.FORECAST,0) - v_FORECAST.ACTUAL;
		p_STATS.P_ERR_SUM := NVL(p_STATS.P_ERR_SUM,0) + v_ERR;
		-- now compute absolute percent error (APE)
		IF v_FORECAST.ACTUAL<> 0 THEN -- percent error is undefined when actual value is zero
			v_ERR := 100 * ABS(v_ERR/v_FORECAST.ACTUAL);
			-- update these fields - which we'll use to compute MAPE
			v_APE_SUM := v_APE_SUM + v_ERR;
			v_APE_COUNT := v_APE_COUNT + 1;
			-- and update table
			UPDATE WRF_FCM_CLUSTER_ASSIGNMENT SET APE = v_ERR
			WHERE FCM_ID = p_CANDIDATE.FCM_ID
				AND NUM_SEGMENTS = p_CANDIDATE.NUM_SEGMENTS
				AND OBSERVATION_NUM = v_FORECAST.OBSERVATION_NUM;
		END IF;
	END LOOP;

	-- now set row with all of the statistics info
	p_CANDIDATE.MAPE := CASE WHEN v_APE_COUNT = 0 THEN NULL ELSE v_APE_SUM / v_APE_COUNT END;
	p_CANDIDATE.P_MAX := p_STATS.P_MAX;
	p_CANDIDATE.P_MIN := p_STATS.P_MIN;
	p_CANDIDATE.P_NZMIN := p_STATS.P_NZMIN;
	p_CANDIDATE.P_SUM := p_STATS.P_SUM;
	p_CANDIDATE.P_COUNT := p_STATS.P_COUNT;
	p_CANDIDATE.P_ERR_SUM := p_STATS.P_ERR_SUM;
	p_CANDIDATE.R2MAX := p_STATS.R2MAX;
	p_CANDIDATE.R2MIN := p_STATS.R2MIN;
	p_CANDIDATE.R2TOTAL_COUNT := p_STATS.R2COUNT;
	p_CANDIDATE.R2FAIL_COUNT := p_STATS.R2FAIL;
	p_CANDIDATE.T_TEMP_COUNT := p_STATS.T_TEMP;
	p_CANDIDATE.T_HUMID_COUNT := p_STATS.T_HUMID;
	p_CANDIDATE.T_WIND_COUNT := p_STATS.T_WIND;

END FINALIZE_CANDIDATE_STATS;
---------------------------------------------------------------------------------------------------
PROCEDURE UPDATE_STATS_FOR_CANDIDATE
	(
	p_FCM_ID IN NUMBER,
	p_NUM_SEGMENTS IN NUMBER,
	p_STATS IN OUT NOCOPY WRF_STAT_STRUCT
	) AS
CURSOR cur_APE IS
	SELECT APE
	FROM WRF_FCM_CLUSTER_ASSIGNMENT
	WHERE FCM_ID = p_FCM_ID
		AND NUM_SEGMENTS = p_NUM_SEGMENTS
		AND APE IS NOT NULL; -- exclude NULL APE - can happen when ACTUAL = 0 so APE
							 -- is undefined (calc of APE would result in DIV/0)
BEGIN
	-- now get candidate statistics and apply to p_STATS
	SELECT GREATEST(P_MAX, NVL(p_STATS.P_MAX, P_MAX)),
		LEAST(P_MIN, NVL(p_STATS.P_MIN, P_MIN)),
		LEAST(P_NZMIN, NVL(p_STATS.P_NZMIN, P_NZMIN)),
		P_SUM + NVL(p_STATS.P_SUM,0),
		P_COUNT + NVL(p_STATS.P_COUNT,0),
		P_ERR_SUM + NVL(p_STATS.P_ERR_SUM,0),
		GREATEST(R2MAX, NVL(p_STATS.R2MAX, R2MAX)),
		LEAST(R2MIN, NVL(p_STATS.R2MIN, R2MIN)),
		R2TOTAL_COUNT + NVL(p_STATS.R2COUNT,0),
		R2FAIL_COUNT + NVL(p_STATS.R2FAIL,0),
		T_TEMP_COUNT + NVL(p_STATS.T_TEMP,0),
		T_HUMID_COUNT + NVL(p_STATS.T_HUMID,0),
		T_WIND_COUNT + NVL(p_STATS.T_WIND,0)
	INTO p_STATS.P_MAX, p_STATS.P_MIN, p_STATS.P_NZMIN,
		p_STATS.P_sUM, p_STATS.P_COUNT, p_STATS.P_ERR_SUM,
		p_STATS.R2MAX, p_STATS.R2MIN, p_STATS.R2COUNT, p_STATS.R2FAIL,
		p_STATS.T_TEMP, p_STATS.T_HUMID, p_STATS.T_WIND
	FROM WRF_FCM_CANDIDATE
	WHERE FCM_ID = p_FCM_ID
		AND NUM_SEGMENTS = p_NUM_SEGMENTS;

	-- and get APE values for observations and append to p_STATS.APE collection
	FOR v_APE IN cur_APE LOOP
		p_STATS.APE(p_STATS.APE.COUNT+1) := v_APE.APE;
	END LOOP;

END UPDATE_STATS_FOR_CANDIDATE;
---------------------------------------------------------------------------------------------------
PROCEDURE CHOOSE_FCM_CANDIDATE
	(
	p_PROFILE_ID IN NUMBER,
	p_HOUR IN NUMBER,
	p_INTERVALS_PER_DAY IN NUMBER,
    p_OUTPUT_AS_OF_DATE IN DATE,
	p_PARAMETER_COUNT IN BINARY_INTEGER,
	p_FCM_ID IN NUMBER,
	p_NUM_SEGMENTS IN NUMBER,
	p_STATS IN OUT NOCOPY WRF_STAT_STRUCT
	) AS
v_NUM_SEGMENTS	NUMBER;
v_WRF_LINE		LOAD_PROFILE_WRF_LINE%ROWTYPE;
v_HOUR			NUMBER := p_HOUR;
CURSOR cur_CLUSTERS IS
	SELECT *
	FROM WRF_FCM_CLUSTER
	WHERE FCM_ID = p_FCM_ID
		AND NUM_SEGMENTS = v_NUM_SEGMENTS
	ORDER BY CLUSTER_NUM;
BEGIN
	IF p_NUM_SEGMENTS IS NULL THEN
		BEGIN
			SELECT NUM_SEGMENTS
			INTO v_NUM_SEGMENTS
			FROM (SELECT NUM_SEGMENTS
				  FROM WRF_FCM_CANDIDATE
				  WHERE FCM_ID = p_FCM_ID
				  ORDER BY MAPE, NUM_SEGMENTS -- use lowest MAPE - two with same MAPE?
				)  								-- use one with fewer segments
			WHERE ROWNUM=1;
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				-- no available candidates? then return all zeroes
				p_STATS.ALL_ZEROES := TRUE;
				RETURN;
		END;
	ELSE
		v_NUM_SEGMENTS := p_NUM_SEGMENTS;
	END IF;

	p_STATS.ALL_ZEROES := FALSE; -- indicate that the profile is not all zeroes

	-- now store the segment
	IF p_INTERVALS_PER_DAY = 1 THEN
		-- Gas WRFs should be stored w/ HOUR = 1, even though
		-- p_HOUR = 24 (corresponding to midnight, since that is
		-- how daily weather and load profile points are stored)
		v_HOUR := 1;
	END IF;

	-- now use the specified candidate - copy info to LOAD_PROFILE_WRF_LINE
	-- and copy statistics into p_STATS
	FOR v_CLUSTER IN cur_CLUSTERS LOOP
		PUT_LOAD_PROFILE_WRF(p_PROFILE_ID, v_CLUSTER.CLUSTER_NUM, p_OUTPUT_AS_OF_DATE, v_CLUSTER.SEGMENT_MIN, v_CLUSTER.SEGMENT_MAX, v_WRF_LINE.WRF_ID);
		v_WRF_LINE.WRF_HOUR := v_HOUR;
		v_WRF_LINE.SEGMENT_MIN := v_CLUSTER.SEGMENT_MIN;
		v_WRF_LINE.SEGMENT_MAX := v_CLUSTER.SEGMENT_MAX;
		v_WRF_LINE.R_SQUARED := v_CLUSTER.R_SQUARED;
		v_WRF_LINE.TSTAT_CRITICAL := v_CLUSTER.TSTAT_CRITICAL;
		v_WRF_LINE.NUM_VARS := p_PARAMETER_COUNT+1;
		v_WRF_LINE.COEFF_0 := v_CLUSTER.COEFF_0;
		v_WRF_LINE.COEFF_1 := v_CLUSTER.COEFF_1;
		v_WRF_LINE.COEFF_2 := v_CLUSTER.COEFF_2;
		v_WRF_LINE.COEFF_3 := v_CLUSTER.COEFF_3;
		v_WRF_LINE.COEFF_4 := v_CLUSTER.COEFF_4;
		v_WRF_LINE.COEFF_5 := v_CLUSTER.COEFF_5;
		v_WRF_LINE.TSTAT_0 := v_CLUSTER.TSTAT_0;
		v_WRF_LINE.TSTAT_1 := v_CLUSTER.TSTAT_1;
		v_WRF_LINE.TSTAT_2 := v_CLUSTER.TSTAT_2;
		v_WRF_LINE.TSTAT_3 := v_CLUSTER.TSTAT_3;
		v_WRF_LINE.TSTAT_4 := v_CLUSTER.TSTAT_4;
		v_WRF_LINE.TSTAT_5 := v_CLUSTER.TSTAT_5;
		-- save it!
		PUT_LOAD_PROFILE_WRF_LINE(v_WRF_LINE);
	END LOOP;

	UPDATE_STATS_FOR_CANDIDATE(p_FCM_ID, v_NUM_SEGMENTS, p_STATS);

END CHOOSE_FCM_CANDIDATE;
---------------------------------------------------------------------------------------------------
PROCEDURE CREATE_WRF_FCM_PROFILE
	(
	p_PROFILE_ID IN NUMBER,
	p_SRC_PROFILE_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_MIN_SEGMENTS IN BINARY_INTEGER,
	p_MAX_SEGMENTS IN BINARY_INTEGER,
	p_PARAMETER_COUNT IN BINARY_INTEGER,
	p_HOUR IN NUMBER,
	p_INTERVALS_PER_DAY IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_INPUT_AS_OF_DATE IN DATE,
    p_OUTPUT_AS_OF_DATE IN DATE,
	p_M IN NUMBER,
	p_TERMINATION IN NUMBER,
	p_MAX_ITER IN NUMBER,
	p_STATS IN OUT NOCOPY WRF_STAT_STRUCT
	) AS
v_FCM				WRF_FCM%ROWTYPE;
v_CANDIDATE			WRF_FCM_CANDIDATE%ROWTYPE;
v_CANDIDATE_STATS	WRF_STAT_STRUCT;
v_BASE_STATS		WRF_STAT_STRUCT;
v_X					GA.NUMBER_TABLE;
v_Y					GA.NUMBER_TABLE;
v_COEFF				GA.NUMBER_TABLE;
v_TSTATS			GA.NUMBER_TABLE;
v_R2				NUMBER;
v_TSTAT_CRITICAL	NUMBER;
v_COEFF_ALL_ZEROES  BOOLEAN;

BEGIN
	v_FCM.PROFILE_ID := p_PROFILE_ID;
	v_FCM.HOUR_NUM := p_HOUR;
	v_FCM.START_DATE := SYSDATE;
	v_FCM.NUM_VARS := p_PARAMETER_COUNT;

	-- create entry in WRF_FCM - leave v_FCM.FCM_ID NULL to indicate
	-- that we need to generate a new ID
	PUT_WRF_FCM(v_FCM);

	-- gather observations  all observations, so specify NULL for
	-- SEGMENT_MIN and SEGMENT_MAX
	GATHER_WRF_OBSERVATIONS(p_SRC_PROFILE_ID, p_ACCOUNT_ID, p_PARAMETER_COUNT, p_HOUR,
							NULL, NULL, p_BEGIN_DATE, p_END_DATE, p_INPUT_AS_OF_DATE,
							v_BASE_STATS, v_X, v_Y);
	IF v_Y.COUNT = 0 THEN
		-- log that there were no observations
		LOGS.LOG_WARN('No observations found for HE '||p_HOUR||'between '
						||TO_CHAR(p_BEGIN_DATE,'YYYY-MM-DD')
						||' and '||TO_CHAR(p_END_DATE,'YYYY-MM-DD')
						||' for WRF '||GET_PROFILE_NAME(p_PROFILE_ID)
						||' (Account = '||CS.GET_ACCOUNT_NAME(p_ACCOUNT_ID)
						||', Source Profile = '||GET_PROFILE_NAME(p_SRC_PROFILE_ID)||')'
						);
		RETURN;
	END IF;

	-- initialize some other fields in the base stats - used as the starting
	-- point for 4 stats
	v_BASE_STATS.R2THRESHOLD := p_STATS.R2THRESHOLD;
	v_BASE_STATS.TEMP_IDX := p_STATS.TEMP_IDX;
	v_BASE_STATS.HUMID_IDX := p_STATS.HUMID_IDX;
	v_BASE_STATS.WIND_IDX := p_STATS.WIND_IDX;
	v_BASE_STATS.R2COUNT := 0; -- initialize counts to zero
	v_BASE_STATS.R2FAIL := 0;
	v_BASE_STATS.T_TEMP := 0;
	v_BASE_STATS.T_HUMID := 0;
	v_BASE_STATS.T_WIND := 0;

	-- store observations in WRF_FCM_OBSERVATIONS
	PUT_WRF_FCM_OBSERVATIONS (v_FCM.FCM_ID, p_PARAMETER_COUNT, v_X, v_Y);
	-- free up memory since we don't need these anymore
	v_X.DELETE;
	v_Y.DELETE;

	-- now evaluate each candidate
	FOR v_NUM_SEGMENTS IN p_MIN_SEGMENTS..p_MAX_SEGMENTS LOOP
		-- store row for this candidate
		INIT_WRF_FCM_CANDIDATE(v_FCM.FCM_ID, v_NUM_SEGMENTS, v_CANDIDATE);
		v_CANDIDATE_STATS := v_BASE_STATS; -- reset for this candidate

		-- compute clusters via iterative FCM algorithm
		-- and compute segment boundaries - this also populates the
		-- NUM_ITERATIONS field of v_CANDIDATE
		FCM_CALCULATE_CLUSTERS(v_CANDIDATE, p_M, p_TERMINATION, p_MAX_ITER);

		-- now run linear regressions
		FOR v_CLUSTER IN 1..v_NUM_SEGMENTS LOOP
			-- gather observations for this cluster
			GATHER_FCM_OBSERVATIONS(v_CANDIDATE.FCM_ID, v_CANDIDATE.NUM_SEGMENTS,
									v_CLUSTER, p_PARAMETER_COUNT, v_X, v_Y);

			-- compute regression
			CALCULATE_WRF_PROFILE_SEGMENT(p_PARAMETER_COUNT, v_X, v_Y,
										v_COEFF, v_TSTATS, v_R2, v_TSTAT_CRITICAL,
										v_CANDIDATE_STATS, v_COEFF_ALL_ZEROES, FALSE);

			IF v_COEFF_ALL_ZEROES = TRUE THEN

				LOGS.LOG_WARN(p_EVENT_TEXT => 'Too few observations(' || v_Y.COUNT
							|| ') for Profile = ' || GET_PROFILE_NAME(p_PROFILE_ID)
							|| ', Candidate = ' || v_NUM_SEGMENTS
							|| ', Segment = #' || v_CLUSTER
							|| ' at Hour = ' || p_HOUR
							|| '. The segment was stored as a flat line (constant and coefficient(s) were set to zero)');
			END IF;

			-- store regression results (coefficients, statistics)
			STORE_FCM_CLUSTER_COEFF (v_CANDIDATE.FCM_ID, v_CANDIDATE.NUM_SEGMENTS, v_CLUSTER,
									 v_COEFF, v_TSTATS, v_R2, v_TSTAT_CRITICAL);
		END LOOP;

		IF v_CANDIDATE_STATS.ALL_ZEROES THEN
			-- log message warning
			LOGS.LOG_WARN('Candidate profile (WRF = '||GET_PROFILE_NAME(p_PROFILE_ID)
							||', Hour = '||p_HOUR||', Num.Segments = '||v_NUM_SEGMENTS||')'
							||' was generated as all zeros. Candidate will be discarded.'
							);

			REMOVE_WRF_FCM_CANDIDATE(v_CANDIDATE.FCM_ID, v_CANDIDATE.NUM_SEGMENTS);
		ELSE
			FINALIZE_CANDIDATE_STATS(v_CANDIDATE, v_CANDIDATE_STATS);
			PUT_WRF_FCM_CANDIDATE(v_CANDIDATE);
		END IF;

	END LOOP;

	-- choose candidate with lowest MAPE and copy data to LOAD_PROFILE tables.
	-- NULL parameter value for NUM_SEGMENTS indicates to use the one with lowest
	-- MAPE
	CHOOSE_FCM_CANDIDATE (p_PROFILE_ID, p_HOUR, p_INTERVALS_PER_DAY, p_OUTPUT_AS_OF_DATE,
						  p_PARAMETER_COUNT, v_FCM.FCM_ID, NULL, p_STATS);

	-- update entry in WRF_FCM with STOP_DATE
	v_FCM.STOP_DATE := SYSDATE;
	PUT_WRF_FCM(v_FCM);

END CREATE_WRF_FCM_PROFILE;
---------------------------------------------------------------------------------------------------
PROCEDURE CREATE_WRF_PROFILE_SEGMENT
	(
	p_PROFILE_ID IN NUMBER,
	p_SRC_PROFILE_ID IN NUMBER,
    p_ACCOUNT_ID IN NUMBER,
    p_PARAMETER_COUNT IN BINARY_INTEGER,
    p_SEGMENT_NBR IN NUMBER,
    p_SEGMENT_MIN IN NUMBER,
    p_SEGMENT_MAX IN NUMBER,
	p_HOUR IN NUMBER,
	p_INTERVALS_PER_DAY IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_INPUT_AS_OF_DATE IN DATE,
    p_OUTPUT_AS_OF_DATE IN DATE,
	p_STATS IN OUT NOCOPY WRF_STAT_STRUCT
    ) AS
v_HOUR					NUMBER := p_HOUR;
v_X						GA.NUMBER_TABLE;
v_Y						GA.NUMBER_TABLE;
v_COEFF					GA.NUMBER_TABLE;
v_TSTAT 				GA.NUMBER_TABLE;
v_R2						NUMBER;
v_TSTAT_CRITICAL		NUMBER;
v_WRF_ID				NUMBER(9);
v_LOAD_PROFILE_WRF_LINE	LOAD_PROFILE_WRF_LINE%ROWTYPE;
v_COEFF_ALL_ZEROES		BOOLEAN;
BEGIN
	-- gather input data into matrices v_X and v_Y
	GATHER_WRF_OBSERVATIONS(p_SRC_PROFILE_ID, p_ACCOUNT_ID, p_PARAMETER_COUNT, v_HOUR,
							p_SEGMENT_MIN, p_SEGMENT_MAX, p_BEGIN_DATE, p_END_DATE, p_INPUT_AS_OF_DATE,
							p_STATS, v_X, v_Y);
	-- perform regression calculations and update statistics structure
	CALCULATE_WRF_PROFILE_SEGMENT(p_PARAMETER_COUNT, v_X, v_Y, v_COEFF, v_TSTAT,
							v_R2, v_TSTAT_CRITICAL, p_STATS, v_COEFF_ALL_ZEROES);

	IF v_COEFF_ALL_ZEROES = TRUE THEN

		LOGS.LOG_WARN(p_EVENT_TEXT => 'Too few observations(' || v_Y.COUNT
							|| ') for Profile = ' || GET_PROFILE_NAME(p_PROFILE_ID)
							|| ', Segment = #' || p_SEGMENT_NBR
							|| ' at Hour = ' || p_HOUR
							|| '. The segment was stored as a flat line (constant and coefficient(s) were set to zero)');
	END IF;


	-- now store the segment
	IF p_INTERVALS_PER_DAY = 1 THEN
		-- Gas WRFs should be stored w/ HOUR = 1, even though
		-- p_HOUR = 24 (corresponding to midnight, since that is
		-- how daily weather and load profile points are stored)
		v_HOUR := 1;
	END IF;
	PUT_LOAD_PROFILE_WRF(p_PROFILE_ID, p_SEGMENT_NBR, p_OUTPUT_AS_OF_DATE, p_SEGMENT_MIN, p_SEGMENT_MAX, v_WRF_ID);
	SET_LOAD_PROFILE_WRF_LINE(v_WRF_ID, v_HOUR, v_COEFF, v_TSTAT, v_R2, v_TSTAT_CRITICAL, p_SEGMENT_MIN, p_SEGMENT_MAX, v_LOAD_PROFILE_WRF_LINE);
	PUT_LOAD_PROFILE_WRF_LINE(v_LOAD_PROFILE_WRF_LINE);

END CREATE_WRF_PROFILE_SEGMENT;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_PARAM_INDICES
	(
    p_PARAMETERS IN GA.ID_TABLE,
    p_TEMP_IDX OUT NUMBER,
    p_HUMID_IDX OUT NUMBER,
    p_WIND_IDX OUT NUMBER
    ) AS
v_PARM_NAME VARCHAR2(32);
v_INDEX BINARY_INTEGER;
BEGIN
	-- store index into p_PARAMETERS for the three major
    -- parameter types: temperature, humidity, and weather
    -- (used for calculating statistics)
	p_TEMP_IDX := -1;
    p_HUMID_IDX := -1;
    p_WIND_IDX := -1;
    v_INDEX := p_PARAMETERS.FIRST;
	WHILE p_PARAMETERS.EXISTS(v_INDEX) LOOP
    	SELECT PARAMETER_NAME INTO v_PARM_NAME
        FROM WEATHER_PARAMETER WHERE PARAMETER_ID = p_PARAMETERS(v_INDEX);

		IF UPPER(v_PARM_NAME) LIKE '%TEMP%' THEN
			p_TEMP_IDX := v_INDEX;
		ELSIF UPPER(v_PARM_NAME) LIKE '%HUMIDITY%' THEN
			p_HUMID_IDX := v_INDEX;
		ELSIF UPPER(v_PARM_NAME) LIKE '%WIND%' THEN
			p_WIND_IDX := v_INDEX;
		END IF;

        v_INDEX := p_PARAMETERS.NEXT(v_INDEX);
    END LOOP;

END GET_PARAM_INDICES;
---------------------------------------------------------------------------------------------------
PROCEDURE CREATE_WRF_PROFILES_FOR_PROF
	(
    p_PROFILE_ID IN NUMBER,
    p_ACCOUNT_ID IN NUMBER,
    p_METER_ID IN NUMBER,
    p_PREFIX_NAME IN VARCHAR,
    p_TEMPLATE_ID IN NUMBER,
    p_PARAMETERS IN GA.ID_TABLE,
    p_BREAKPOINT_ID IN NUMBER,
    p_STATION_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_INPUT_AS_OF_DATE IN DATE,
    p_OUTPUT_AS_OF_DATE IN DATE,
    p_R2_THRESHOLD IN NUMBER,
    p_WRF_PROFILE_ID OUT NUMBER,
    p_WRF_LIBRARY_ID OUT NUMBER,
	p_MIN_SEGMENTS IN NUMBER := NULL,
	p_MAX_SEGMENTS IN NUMBER := NULL,
	p_AUTO_APPLY IN NUMBER := NULL,
	p_BATCH_TIMESTAMP IN TIMESTAMP := NULL
    ) AS

v_STATUS NUMBER;
v_BREAKPOINT_ID NUMBER(9);
v_PARAMETERS GA.ID_TABLE;
v_TEMPLATE_NAME VARCHAR(64);
v_PROFILE_NAME VARCHAR(128);
v_PROFILE_LIBRARY_ID NUMBER(9);
v_PROFILE_ID NUMBER(9);
v_HOUR NUMBER(2);
v_LINE_SEGMENT NUMBER(2);
v_BREAKPOINT_INTERVAL VARCHAR(4);
v_ELAPSED_TIME PLS_INTEGER := DBMS_UTILITY.GET_TIME;
v_BREAKPOINTS GA.NUMBER_TABLE;
v_FOUND_HOUR BOOLEAN := FALSE;
CURSOR c_BREAKPOINT_HOURS IS
	SELECT BREAKPOINT_HOUR "HOUR",
    	SUM(DECODE(BREAKPOINT_NBR,1,BREAKPOINT_VAL,0)) "V1",
    	SUM(DECODE(BREAKPOINT_NBR,2,BREAKPOINT_VAL,0)) "V2",
    	SUM(DECODE(BREAKPOINT_NBR,3,BREAKPOINT_VAL,0)) "V3",
    	SUM(DECODE(BREAKPOINT_NBR,4,BREAKPOINT_VAL,0)) "V4",
        (MAX(BREAKPOINT_NBR)-1) "LINE_SEGMENTS"
	FROM BREAKPOINT_VALUE
    WHERE BREAKPOINT_ID = v_BREAKPOINT_ID
    GROUP BY BREAKPOINT_HOUR
    ORDER BY BREAKPOINT_HOUR DESC;
v_STATS WRF_STAT_STRUCT;
v_INTERVALS_PER_DAY NUMBER;
v_START_HOUR NUMBER;
v_END_HOUR NUMBER;
v_CALENDAR_ID NUMBER(9);
v_CALC_TYPE VARCHAR2(128);
v_MIN_SEGMENTS NUMBER;
v_MAX_SEGMENTS NUMBER;
v_M NUMBER;
v_TERMINATION NUMBER;
v_MAX_ITER NUMBER;
v_BREAK_POINT_COUNT NUMBER(9);
v_PROGRESS_IDX_BP PLS_INTEGER;
v_PROGRESS_IDX_LS PLS_INTEGER;
v_PROGRESS_IDX_I PLS_INTEGER;
BEGIN
	SAVEPOINT BEFORE_WRF_PROFILES_FOR_PROF;

	-- get weather parameters and breakpoint info associated with this template
	IF p_BREAKPOINT_ID IS NULL OR p_PARAMETERS.COUNT = 0 THEN
	    GET_PARAMETERS_FOR_TEMPLATE(p_TEMPLATE_ID, v_PARAMETERS, v_BREAKPOINT_ID);
	END IF;

	IF p_BREAKPOINT_ID IS NOT NULL THEN
		v_BREAKPOINT_ID := p_BREAKPOINT_ID;
	END IF;
	IF p_PARAMETERS.COUNT > 0 THEN
		v_PARAMETERS := p_PARAMETERS;
	END IF;

	-- no parameters?
	IF v_PARAMETERS.COUNT = 0 THEN
		ERRS.RAISE(MSGCODES.c_ERR_NO_WEATHER_PARMS, TEXT_UTIL.TO_CHAR_ENTITY(p_TEMPLATE_ID,EC.ED_DAY_TYPE_TEMPLATE,TRUE));
	END IF;

	-- cache weather data if necessary
	CACHE_BATCH_WRF_WEATHER(p_STATION_ID, p_TEMPLATE_ID, v_PARAMETERS, p_BEGIN_DATE, p_END_DATE, p_BATCH_TIMESTAMP);

    SELECT TEMPLATE_NAME INTO v_TEMPLATE_NAME
    FROM TEMPLATE WHERE TEMPLATE_ID = p_TEMPLATE_ID;

    --Support Gas model as well as Electric - wjc - 10/1/2003
    --Set Default Interval
    IF GA.DEFAULT_MODEL = GA.GAS_MODEL THEN
         --Gas
         v_INTERVALS_PER_DAY := 1;
    ELSE   --Electric
         v_INTERVALS_PER_DAY := 24;
    END IF;

    --Get v_INTERVALS_PER_DAY from profile
    SELECT NVL(PROFILE_INTERVAL, v_INTERVALS_PER_DAY) INTO v_INTERVALS_PER_DAY
    FROM LOAD_PROFILE WHERE PROFILE_ID = p_PROFILE_ID;

    IF v_INTERVALS_PER_DAY = 1 THEN
         --Gas
         v_START_HOUR := 24;  --Data for GAS model in hour 24 (midnight)
    ELSE   --Electric
         v_START_HOUR := 1;
    END IF;

    v_END_HOUR := 24;  --Midnight is always the last breakpoint hour, even for Gas

	-- initialize stats struct
    GET_PARAM_INDICES(v_PARAMETERS,v_STATS.TEMP_IDX,v_STATS.HUMID_IDX,v_STATS.WIND_IDX);
    v_STATS.APE.DELETE;
	v_STATS.ALL_ZEROES := TRUE;
	v_STATS.P_COUNT := 0;
	v_STATS.R2COUNT := 0;
	v_STATS.R2FAIL := 0;
	v_STATS.R2THRESHOLD := p_R2_THRESHOLD;
	v_STATS.T_TEMP := 0;
	v_STATS.T_HUMID := 0;
	v_STATS.T_WIND := 0;

    -- get existing or create new library and profile
	PUT_LOAD_PROFILE_LIBRARY(p_PREFIX_NAME || '_Library', v_PROFILE_LIBRARY_ID);
	v_PROFILE_NAME := p_PREFIX_NAME || '_' || v_TEMPLATE_NAME;
	PUT_LOAD_PROFILE(v_PROFILE_NAME, v_PROFILE_LIBRARY_ID, 'WRF', p_ACCOUNT_ID, p_METER_ID, p_PROFILE_ID, p_BEGIN_DATE, p_END_DATE , p_INPUT_AS_OF_DATE, p_TEMPLATE_ID, p_STATION_ID, v_TEMPLATE_NAME, v_INTERVALS_PER_DAY, v_PROFILE_ID);

	-- delete existing info for this profile so we can rebuild
	RESET_WRF_PROFILE(v_PROFILE_ID);

	-- save weather parameters
    PUT_LOAD_PROFILE_WRF_WEATHER(v_PROFILE_ID,v_PARAMETERS);
    p_WRF_PROFILE_ID := v_PROFILE_ID;
    p_WRF_LIBRARY_ID := v_PROFILE_LIBRARY_ID;

	-- get/create calendar
	ID.ID_FOR_CALENDAR(p_PREFIX_NAME || '_Library', v_CALENDAR_ID);
	CA.PUT_CALENDAR_PROFILE_LIBRARY(v_CALENDAR_ID,v_PROFILE_LIBRARY_ID,LOW_DATE,NULL,v_PROFILE_LIBRARY_ID,LOW_DATE,v_STATUS);
	ERRS.VALIDATE_STATUS('CA.PUT_CALENDAR_PROFILE_LIBRARY', v_STATUS);

    --Assign Calendar to either Meter or Account
    IF NVL(TO_CHAR(p_AUTO_APPLY),NVL(GET_DICTIONARY_VALUE('Automatic Calendar Assignment',0,'Profiling','WRF'),'1')) = '1' THEN
        IF p_METER_ID IS NOT NULL THEN
            ASSIGN_METER_CALENDAR(v_PROFILE_LIBRARY_ID,v_CALENDAR_ID,p_METER_ID, TRUE);
        ELSIF p_ACCOUNT_ID IS NOT NULL THEN
            ASSIGN_ACCOUNT_CALENDAR(v_PROFILE_LIBRARY_ID,v_CALENDAR_ID,p_ACCOUNT_ID, TRUE);
        END IF;
    END IF;

	v_CALC_TYPE := GET_DICTIONARY_VALUE('Breakpoint Source',0,'Profiling','WRF');
	IF v_CALC_TYPE = 'FCM' THEN
		-- FCM algorithm
		v_BREAKPOINT_INTERVAL := CASE WHEN v_INTERVALS_PER_DAY = 1 THEN 'Day' ELSE 'Hour' END;

		-- get settings from system dictionary
		v_MIN_SEGMENTS := NvL(p_MIN_SEGMENTS,NVL(GET_DICTIONARY_VALUE('Min Segments', 0, 'Profiling', 'WRF', 'FCM'),2));
		v_MAX_SEGMENTS := NvL(p_MAX_SEGMENTS,NVL(GET_DICTIONARY_VALUE('Max Segments', 0, 'Profiling', 'WRF', 'FCM'),5));
		v_M := NVL(GET_DICTIONARY_VALUE('m', 0, 'Profiling', 'WRF', 'FCM'),3);
		v_TERMINATION := NVL(GET_DICTIONARY_VALUE('Termination Threshold', 0, 'Profiling', 'WRF', 'FCM'),0.01);
		v_MAX_ITER := NVL(GET_DICTIONARY_VALUE('Max Iterations', 0, 'Profiling', 'WRF', 'FCM'),30);

		IF v_M <= 1.0 THEN
			-- log warning
			LOGS.LOG_WARN('FCM exponent ''m'' defined as '||v_M
							||' but should be greater than 1.0. A value of 1.01 will be used instead.'
							);
			v_M := 1.01;
		END IF;
		-- clear out data from previous evaluation
		NEW_WRF_FCM(v_PROFILE_ID);

		-- create profiles
		FOR v_HOUR IN v_START_HOUR..v_END_HOUR LOOP
			CREATE_WRF_FCM_PROFILE(v_PROFILE_ID, p_PROFILE_ID, p_ACCOUNT_ID, v_MIN_SEGMENTS, v_MAX_SEGMENTS,
							v_PARAMETERS.COUNT, v_HOUR, v_INTERVALS_PER_DAY, p_BEGIN_DATE, p_END_DATE,
							p_INPUT_AS_OF_DATE, p_OUTPUT_AS_OF_DATE, v_M, v_TERMINATION,
							v_MAX_ITER, v_STATS);
		END LOOP;

	ELSE -- traditional, user-specified breakpoints
		-- no parameters?
		IF NVL(v_BREAKPOINT_ID,0) = 0 THEN
			ERRS.RAISE(MSGCODES.c_ERR_NO_BREAKPOINT, TEXT_UTIL.TO_CHAR_ENTITY(p_TEMPLATE_ID,EC.ED_DAY_TYPE_TEMPLATE,TRUE));
		END IF;

		SELECT COUNT(1)
		INTO v_BREAK_POINT_COUNT
		FROM (SELECT 1
			FROM BREAKPOINT_VALUE
			WHERE BREAKPOINT_ID = p_BREAKPOINT_ID
			GROUP BY BREAKPOINT_HOUR) A;

		v_PROGRESS_IDX_BP := LOGS.PUSH_PROGRESS_RANGE(v_BREAK_POINT_COUNT);

		-- if we are doing daily breakpoints, the cursor will have only one row.
		-- otherwise it will have 24 rows for hourly breakpoints
		FOR v_BREAKPOINT_HOUR IN c_BREAKPOINT_HOURS LOOP
			v_BREAKPOINT_INTERVAL := 'Hour';
			-- store breakpoint values into table for convenient access below
			v_BREAKPOINTS.DELETE;
			v_BREAKPOINTS(1) := v_BREAKPOINT_HOUR.V1;
			v_BREAKPOINTS(2) := v_BREAKPOINT_HOUR.V2;
			v_BREAKPOINTS(3) := v_BREAKPOINT_HOUR.V3;
			v_BREAKPOINTS(4) := v_BREAKPOINT_HOUR.V4;

			v_PROGRESS_IDX_LS := LOGS.PUSH_PROGRESS_RANGE(v_BREAKPOINT_HOUR.LINE_SEGMENTS);

			-- loop over the segments (typically three)
			FOR v_LINE_SEGMENT IN 1..v_BREAKPOINT_HOUR.LINE_SEGMENTS LOOP
				-- if we've already processed hourly breakpoints, then
				-- skip hour zero (which is daily indicator)
				IF v_BREAKPOINT_HOUR.HOUR = 0 AND NOT v_FOUND_HOUR THEN
					-- hour = 0 indicates normal (daily) breakpoint - so use these
					-- breakpoints for all 24 hours
					v_BREAKPOINT_INTERVAL := 'Day';

					v_PROGRESS_IDX_I := LOGS.PUSH_PROGRESS_RANGE(v_END_HOUR - v_START_HOUR + 1);

					FOR v_HOUR IN v_START_HOUR..v_END_HOUR LOOP
						CREATE_WRF_PROFILE_SEGMENT(v_PROFILE_ID,
							p_PROFILE_ID,p_ACCOUNT_ID,v_PARAMETERS.COUNT,
							v_LINE_SEGMENT,v_BREAKPOINTS(v_LINE_SEGMENT),v_BREAKPOINTS(v_LINE_SEGMENT+1),
							v_HOUR,v_INTERVALS_PER_DAY,p_BEGIN_DATE,p_END_DATE,p_INPUT_AS_OF_DATE,
							p_OUTPUT_AS_OF_DATE,v_STATS);

						LOGS.INCREMENT_PROCESS_PROGRESS(p_RANGE_INDEX => v_PROGRESS_IDX_I);
					END LOOP; -- Hour
					LOGS.POP_PROGRESS_RANGE(v_PROGRESS_IDX_I);
				ELSIF v_BREAKPOINT_HOUR.HOUR > 0 THEN
					-- non-zero hour indicates hourly breakpoint for specific hour.
					-- create segment for that hour (other 23 hours will be other
					-- rows in this cursor)
					v_FOUND_HOUR := TRUE;
					v_HOUR := v_BREAKPOINT_HOUR.HOUR;
					CREATE_WRF_PROFILE_SEGMENT(v_PROFILE_ID,
						p_PROFILE_ID,p_ACCOUNT_ID,v_PARAMETERS.COUNT,
						v_LINE_SEGMENT,v_BREAKPOINTS(v_LINE_SEGMENT),v_BREAKPOINTS(v_LINE_SEGMENT+1),
						v_HOUR,v_INTERVALS_PER_DAY,p_BEGIN_DATE,p_END_DATE,p_INPUT_AS_OF_DATE,
						p_OUTPUT_AS_OF_DATE,v_STATS);
				END IF;
				LOGS.INCREMENT_PROCESS_PROGRESS(p_RANGE_INDEX => v_PROGRESS_IDX_LS);
			END LOOP;
			LOGS.POP_PROGRESS_RANGE(v_PROGRESS_IDX_LS);
			LOGS.INCREMENT_PROCESS_PROGRESS(p_RANGE_INDEX => v_PROGRESS_IDX_BP);
		END LOOP;
		LOGS.POP_PROGRESS_RANGE(v_PROGRESS_IDX_BP);
	END IF;

    -- finally, store statistics
	IF v_STATS.ALL_ZEROES THEN
		ERRS.ROLLBACK_TO('BEFORE_WRF_PROFILES_FOR_PROF');
		LOGS.LOG_WARN('WRF Profile '||v_PROFILE_NAME||' was computed as all zeros. This profile has been removed.');
    ELSE
		PUT_BREAKPOINT_INTERVAL(v_PROFILE_ID, v_BREAKPOINT_INTERVAL);

		FINALIZE_STATS(v_STATS); -- wrap up some final calculations
		PUT_LOAD_PROFILE_STATISTICS (v_PROFILE_ID, GET_PROFILE_VERSION_ID(p_OUTPUT_AS_OF_DATE),
			p_OUTPUT_AS_OF_DATE, p_BEGIN_DATE, p_END_DATE, v_STATS.P_COUNT, 0.0, v_STATS.p_MIN, v_STATS.P_NZMIN,
			v_STATS.P_MAX, v_STATS.P_SUM, v_STATS.MAPE, v_STATS.STDAPE, v_STATS.TOT_ERR_PCT, v_STATS.R2MIN, v_STATS.R2MAX, v_STATS.R2FAIL,
			v_STATS.T_TEMP, v_STATS.T_HUMID, v_STATS.T_WIND, 'Pending', v_STATUS);
		ERRS.VALIDATE_STATUS('PF.PUT_LOAD_PROFILE_STATISTICS', v_STATUS);

		IF g_ALLOW_COMMIT_ROLLBACK THEN COMMIT; END IF;
        IF LOGS.IS_DEBUG_ENABLED THEN
        	LOGS.LOG_DEBUG('ProfileMAPE= ' || v_STATS.MAPE);
			LOGS.LOG_DEBUG('Total ACTUAL = ' || TO_CHAR(v_STATS.P_SUM));
			LOGS.LOG_DEBUG('Total ERROR = ' || TO_CHAR(v_STATS.P_ERR_SUM));
			LOGS.LOG_DEBUG('Total Error % = ' || TO_CHAR(v_STATS.TOT_ERR_PCT));
		END IF;
    END IF;

	LOGS.LOG_DEBUG('CREATE_WRF_PROFILES_FOR_PROF - FINISHED AT ' || TEXT_UTIL.TO_CHAR_DATE(SYSDATE) || ' ELAPSED TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED_TIME));

EXCEPTION
	WHEN OTHERS THEN
    	ERRS.LOG_AND_RAISE(p_SAVEPOINT_NAME => 'BEFORE_WRF_PROFILES_FOR_PROF');
END CREATE_WRF_PROFILES_FOR_PROF;
---------------------------------------------------------------------------------------------------
FUNCTION GET_PROFILE_ID_FROM_METER_REF
	(
	p_METER_ID IN NUMBER
	) RETURN NUMBER IS

-- Answer the Profile Associated with the METER.

v_PROFILE_ID NUMBER(9);

BEGIN

	IF p_METER_ID > 0 THEN
		SELECT PROFILE_ID INTO v_PROFILE_ID
		FROM (
        	SELECT PROFILE_ID
        	FROM LOAD_PROFILE
			WHERE PROFILE_METER_REF = TO_CHAR(p_METER_ID)
	        	AND UPPER(PROFILE_TYPE) = 'HISTORICAL'
			)
        WHERE ROWNUM = 1;

		RETURN v_PROFILE_ID;
	ELSE
		RETURN ABS(p_METER_ID);
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN CONSTANTS.NOT_ASSIGNED;

END GET_PROFILE_ID_FROM_METER_REF;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_ACCOUNT_MODEL_OPTION
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ACCOUNT_MODEL_OPTION OUT VARCHAR2,
	p_STATUS OUT NUMBER
	) AS

-- Answer the meters for the given account.
BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;
    p_ACCOUNT_MODEL_OPTION := '?';

    SELECT ACCOUNT_MODEL_OPTION
    INTO p_ACCOUNT_MODEL_OPTION
    FROM ACCOUNT
    WHERE ACCOUNT_ID = p_ACCOUNT_ID;

	EXCEPTION
	    WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		    p_ACCOUNT_MODEL_OPTION := '?';
END GET_ACCOUNT_MODEL_OPTION;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_ACCOUNT_SERV_LOC_METERS
	(
	p_ACCOUNT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the meters for the given account.
BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT C.METER_NAME, B.METER_ID
		FROM ACCOUNT_SERVICE_LOCATION A, SERVICE_LOCATION_METER B, METER C
		WHERE B.SERVICE_LOCATION_ID = A.SERVICE_LOCATION_ID
        AND A.ACCOUNT_ID = p_ACCOUNT_ID
        AND C.METER_ID = B.METER_ID
        ORDER BY 1;

END GET_ACCOUNT_SERV_LOC_METERS;
---------------------------------------------------------------------------------------------------
FUNCTION GET_METER_IDS_FOR_ACCOUNT
	(
	p_ACCOUNT_ID IN NUMBER
	) RETURN GA.ID_TABLE IS

-- Return the meters for the given account in an ID_TABLE.

v_METER_IDS GA.ID_TABLE;

BEGIN
    --Loop over meters cursor, load table
    SELECT B.METER_ID
	BULK COLLECT INTO v_METER_IDs
    FROM ACCOUNT_SERVICE_LOCATION A, SERVICE_LOCATION_METER B
    WHERE B.SERVICE_LOCATION_ID = A.SERVICE_LOCATION_ID
    AND A.ACCOUNT_ID = p_ACCOUNT_ID
    ORDER BY 1;

    RETURN v_METER_IDS;

END GET_METER_IDS_FOR_ACCOUNT;
---------------------------------------------------------------------------------------------------
PROCEDURE CREATE_WRF_PROFILES_FOR_ACCT
	(
    p_ACCOUNT_ID IN NUMBER,
    p_TEMPLATE_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_INPUT_AS_OF_DATE IN DATE,
    p_OUTPUT_AS_OF_DATE IN DATE,
    p_R2_THRESHOLD IN NUMBER,
	p_MIN_SEGMENTS IN NUMBER := NULL,
	p_MAX_SEGMENTS IN NUMBER := NULL,
	p_AUTO_APPLY IN NUMBER := NULL,
	p_BATCH_TIMESTAMP IN TIMESTAMP := NULL
    ) AS

v_PROFILE_ID NUMBER;
v_STATION_ID NUMBER;
v_PREFIX_NAME VARCHAR2(64);
v_IS_METER_MODELED NUMBER;
v_METER_IS_ALLOWED NUMBER(1);
v_METER_TYPE ACCOUNT.ACCOUNT_METER_TYPE%TYPE;
v_METER_IDS GA.ID_TABLE;
v_METER_ID NUMBER;
v_METER_NAME METER.METER_NAME%TYPE;
v_ACCOUNT_NAME VARCHAR2(64);
v_INDEX NUMBER;
v_ERR_MSG VARCHAR2(265);
v_ERR_ACCT VARCHAR2(128);
v_WRF_PROFILE_ID NUMBER;
v_WRF_LIBRARY_ID NUMBER;
v_PROGRESS_IDX_M PLS_INTEGER;
v_PARAMETERS GA.ID_TABLE;
v_BREAKPOINT_ID NUMBER;

BEGIN

    v_ACCOUNT_NAME := CS.GET_ACCOUNT_NAME(p_ACCOUNT_ID);
    v_ERR_ACCT := 'Error in WRF for Account '||v_ACCOUNT_NAME;
    v_ERR_MSG := v_ERR_ACCT;

    v_STATION_ID := GET_ACCOUNT_STATION(p_ACCOUNT_ID,p_BEGIN_DATE,p_END_DATE);

    GET_PARAMETERS_FOR_TEMPLATE(p_TEMPLATE_ID, v_PARAMETERS, v_BREAKPOINT_ID);

	--Determine if this Account is Meter-Modeled
	SELECT DECODE(SUBSTR(A.ACCOUNT_MODEL_OPTION,1,1),'M', 1, 0)
	INTO v_IS_METER_MODELED
	FROM ACCOUNT A
	WHERE ACCOUNT_ID = p_ACCOUNT_ID;

    IF UT.BOOLEAN_FROM_NUMBER(v_IS_METER_MODELED) THEN
    	--Determine if Meter-Modeled WRFs are allowed
	    v_METER_IS_ALLOWED := TO_NUMBER(MODEL_VALUE_AT_KEY(GA.DEFAULT_MODEL, g_DOMAIN_NAME, 'Batch', 'AllowMeterModeledWRFs'));
		IF NOT UT.BOOLEAN_FROM_NUMBER(v_METER_IS_ALLOWED) THEN
			LOGS.LOG_ERROR(v_ERR_MSG||': Meter Modeled Accounts in WRFs are currently disabled.  Set the AllowMeterModeledWRFs System Setting flag to enable them.');
		ELSE
			v_METER_IDS := GET_METER_IDS_FOR_ACCOUNT(p_ACCOUNT_ID);

			v_PROGRESS_IDX_M := LOGS.PUSH_PROGRESS_RANGE(v_METER_IDS.COUNT);

			--Create one profile for each meter assigned to this account
			FOR v_INDEX IN v_METER_IDS.FIRST..v_METER_IDS.LAST LOOP
				v_METER_ID := v_METER_IDS(v_INDEX);
				v_METER_NAME := GET_METER_NAME(v_METER_ID);
				v_ERR_MSG := v_ERR_ACCT || ', Meter: '||v_METER_NAME;

				v_PROFILE_ID := GET_PROFILE_ID_FROM_METER_REF(v_METER_ID);

				IF v_PROFILE_ID > 0 THEN
					v_PREFIX_NAME := v_METER_NAME || '_METER';

					CREATE_WRF_PROFILES_FOR_PROF(v_PROFILE_ID,p_ACCOUNT_ID,v_METER_ID,v_PREFIX_NAME,p_TEMPLATE_ID,v_PARAMETERS,v_BREAKPOINT_ID,
							v_STATION_ID,p_BEGIN_DATE,p_END_DATE,p_INPUT_AS_OF_DATE,p_OUTPUT_AS_OF_DATE,p_R2_THRESHOLD,v_WRF_PROFILE_ID,v_WRF_LIBRARY_ID,
							p_MIN_SEGMENTS,p_MAX_SEGMENTS,p_AUTO_APPLY,p_BATCH_TIMESTAMP);
				ELSE
					LOGS.LOG_ERROR(v_ERR_MSG || ' - No Profile assigned (METER_ID: ' || TO_CHAR(v_METER_ID) || ')');
				END IF;
				LOGS.INCREMENT_PROCESS_PROGRESS(1,
												'Processed Account: ' || v_ACCOUNT_NAME || ', Meter: '||v_METER_NAME,
												v_PROGRESS_IDX_M);
			END LOOP;
			LOGS.POP_PROGRESS_RANGE(v_PROGRESS_IDX_M);
		END IF;
    ELSE  --ACCOUNT MODELED
    	v_PROFILE_ID := GET_PROFILE_ID(p_ACCOUNT_ID);

		SELECT ACCOUNT_METER_TYPE
		INTO v_METER_TYPE
		FROM ACCOUNT
		WHERE ACCOUNT_ID = p_ACCOUNT_ID;

		-- for period-meter accounts, profile is likely used for multiple
		-- accounts so name the WRF after the historical profile, not the account
		IF UPPER(SUBSTR(v_METER_TYPE,1,1)) = 'P' THEN
			v_PREFIX_NAME := GET_PROFILE_NAME(v_PROFILE_ID);
		ELSE
	        v_PREFIX_NAME := v_ACCOUNT_NAME;
		END IF;

        CREATE_WRF_PROFILES_FOR_PROF(v_PROFILE_ID,p_ACCOUNT_ID,NULL,v_PREFIX_NAME,p_TEMPLATE_ID,v_PARAMETERS,v_BREAKPOINT_ID,
    			v_STATION_ID,p_BEGIN_DATE,p_END_DATE,p_INPUT_AS_OF_DATE,p_OUTPUT_AS_OF_DATE,p_R2_THRESHOLD,v_WRF_PROFILE_ID,v_WRF_LIBRARY_ID,
				p_MIN_SEGMENTS,p_MAX_SEGMENTS,p_AUTO_APPLY,p_BATCH_TIMESTAMP);
    END IF;

END CREATE_WRF_PROFILES_FOR_ACCT;
---------------------------------------------------------------------------------------------------
PROCEDURE PROFILE_WRF_PROFILES
	(
	p_PROFILE_ID IN NUMBER,
	p_BREAKPOINT_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_PARAMETER_LIST IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_R2_THRESHOLD IN NUMBER,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

v_PARAMETERS GA.ID_TABLE;
v_PREFIX_NAME VARCHAR(64);
v_STATION_ID NUMBER;
v_WRF_PROFILE_ID NUMBER;
v_WRF_LIBRARY_ID NUMBER;
v_MESSAGE		VARCHAR2(4000);

BEGIN
	LOGS.START_PROCESS('Calculate WRF for Load Profile',
					   p_BEGIN_DATE,
					   p_END_DATE,
					   p_EVENT_LEVEL => CASE WHEN p_TRACE_ON > 0 THEN LOGS.c_LEVEL_DEBUG_MORE_DETAIL ELSE NULL END);

	LOGS.SET_PROCESS_TARGET_PARAMETER('PROFILE_ID', TO_CHAR(p_PROFILE_ID));
	LOGS.SET_PROCESS_TARGET_PARAMETER('BREAKPOINT_ID', TO_CHAR(p_BREAKPOINT_ID));
	LOGS.SET_PROCESS_TARGET_PARAMETER('TEMPLATE_ID', TO_CHAR(p_TEMPLATE_ID));
	LOGS.SET_PROCESS_TARGET_PARAMETER('PARAMETER_LIST', SUBSTR(p_PARAMETER_LIST,1,256));
	LOGS.SET_PROCESS_TARGET_PARAMETER('INPUT_AS_OF_DATE', TEXT_UTIL.TO_CHAR_DATE(p_INPUT_AS_OF_DATE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('OUTPUT_AS_OF_DATE', TEXT_UTIL.TO_CHAR_DATE(p_OUTPUT_AS_OF_DATE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('R2_THRESHOLD', TO_CHAR(p_R2_THRESHOLD));

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	LOGS.INIT_PROCESS_PROGRESS(p_TOTAL_WORK => 1, p_WORK_UNITS => 'Profiles');

	UT.IDS_FROM_STRING(p_PARAMETER_LIST, ';', v_PARAMETERS);

	v_PREFIX_NAME := GET_PROFILE_NAME(p_PROFILE_ID);

	SELECT PROFILE_STATION_ID INTO v_STATION_ID
	FROM LOAD_PROFILE
	WHERE PROFILE_ID = p_PROFILE_ID;

	CREATE_WRF_PROFILES_FOR_PROF(p_PROFILE_ID, NULL, NULL, v_PREFIX_NAME, p_TEMPLATE_ID, v_PARAMETERS, p_BREAKPOINT_ID, v_STATION_ID, p_BEGIN_DATE, p_END_DATE, p_INPUT_AS_OF_DATE, p_OUTPUT_AS_OF_DATE, p_R2_THRESHOLD, v_WRF_PROFILE_ID,v_WRF_LIBRARY_ID);

	LOGS.STOP_PROCESS(v_MESSAGE, p_STATUS);
	COMMIT;

EXCEPTION
	WHEN OTHERS THEN
    	ERRS.ABORT_PROCESS;

END PROFILE_WRF_PROFILES;
---------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNT_WRF_PROFILES
	(
	p_ACCOUNT_ID IN NUMBER,
	p_TEMPLATE_LIST IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_R2_THRESHOLD IN NUMBER,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

v_TEMP_INDEX BINARY_INTEGER;
v_TEMPLATES ID_TABLE := ID_TABLE();
v_MESSAGE		VARCHAR2(4000);

BEGIN
	LOGS.START_PROCESS('Calculate WRF for Account',
					   p_BEGIN_DATE,
					   p_END_DATE,
					   p_EVENT_LEVEL => CASE WHEN p_TRACE_ON > 0 THEN LOGS.c_LEVEL_DEBUG_MORE_DETAIL ELSE NULL END);

	LOGS.SET_PROCESS_TARGET_PARAMETER('ACCOUNT_ID', TO_CHAR(p_ACCOUNT_ID));
	LOGS.SET_PROCESS_TARGET_PARAMETER('TEMPLATE_LIST', SUBSTR(p_TEMPLATE_LIST,1,256));
	LOGS.SET_PROCESS_TARGET_PARAMETER('INPUT_AS_OF_DATE', TEXT_UTIL.TO_CHAR_DATE(p_INPUT_AS_OF_DATE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('OUTPUT_AS_OF_DATE', TEXT_UTIL.TO_CHAR_DATE(p_OUTPUT_AS_OF_DATE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('R2_THRESHOLD', TO_CHAR(p_R2_THRESHOLD));

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	GET_IDENTS(p_TEMPLATE_LIST, v_TEMPLATES);

	LOGS.INIT_PROCESS_PROGRESS(p_TOTAL_WORK => v_TEMPLATES.COUNT);

	v_TEMP_INDEX := v_TEMPLATES.FIRST;
	WHILE v_TEMP_INDEX <= v_TEMPLATES.LAST LOOP
		BEGIN
			CREATE_WRF_PROFILES_FOR_ACCT(p_ACCOUNT_ID, v_TEMPLATES(v_TEMP_INDEX).ID, p_BEGIN_DATE, p_END_DATE, p_INPUT_AS_OF_DATE, p_OUTPUT_AS_OF_DATE, p_R2_THRESHOLD);
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE;
		END;

        LOGS.INCREMENT_PROCESS_PROGRESS();
		v_TEMP_INDEX := v_TEMPLATES.NEXT(v_TEMP_INDEX);
    END LOOP;

	LOGS.STOP_PROCESS(v_MESSAGE, p_STATUS);
	COMMIT;

EXCEPTION
	WHEN OTHERS THEN
    	ERRS.ABORT_PROCESS;

END ACCOUNT_WRF_PROFILES;
---------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNT_GROUP_WRF_PROFILES
	(
	p_ACCOUNT_GROUP_ID IN NUMBER,
	p_TEMPLATE_LIST IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_R2_THRESHOLD IN NUMBER,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

v_ACCT_INDEX BINARY_INTEGER;
v_TEMP_INDEX BINARY_INTEGER;
v_ACCOUNTS ID_TABLE := ID_TABLE();
v_TEMPLATES ID_TABLE := ID_TABLE();
v_MESSAGE		VARCHAR2(4000);

BEGIN
	LOGS.START_PROCESS('Calculate WRF for Account Group',
					   p_BEGIN_DATE,
					   p_END_DATE,
					   p_EVENT_LEVEL => CASE WHEN p_TRACE_ON > 0 THEN LOGS.c_LEVEL_DEBUG_MORE_DETAIL ELSE NULL END);

	LOGS.SET_PROCESS_TARGET_PARAMETER('ACCOUNT_GROUP_ID', TO_CHAR(p_ACCOUNT_GROUP_ID));
	LOGS.SET_PROCESS_TARGET_PARAMETER('TEMPLATE_LIST', SUBSTR(p_TEMPLATE_LIST,1,256));
	LOGS.SET_PROCESS_TARGET_PARAMETER('INPUT_AS_OF_DATE', TEXT_UTIL.TO_CHAR_DATE(p_INPUT_AS_OF_DATE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('OUTPUT_AS_OF_DATE', TEXT_UTIL.TO_CHAR_DATE(p_OUTPUT_AS_OF_DATE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('R2_THRESHOLD', TO_CHAR(p_R2_THRESHOLD));

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	GET_ACCOUNTS(p_ACCOUNT_GROUP_ID, v_ACCOUNTS);
	GET_IDENTS(p_TEMPLATE_LIST, v_TEMPLATES);

	LOGS.INIT_PROCESS_PROGRESS(p_TOTAL_WORK =>  v_TEMPLATES.COUNT * v_ACCOUNTS.COUNT);

	v_ACCT_INDEX := v_ACCOUNTS.FIRST;
	WHILE v_ACCT_INDEX <= v_ACCOUNTS.LAST LOOP
    	v_TEMP_INDEX := v_TEMPLATES.FIRST;
    	WHILE v_TEMP_INDEX <= v_TEMPLATES.LAST LOOP
			CREATE_WRF_PROFILES_FOR_ACCT(v_ACCOUNTS(v_ACCT_INDEX).ID, v_TEMPLATES(v_TEMP_INDEX).ID, p_BEGIN_DATE, p_END_DATE, p_INPUT_AS_OF_DATE, p_OUTPUT_AS_OF_DATE, p_R2_THRESHOLD);

            LOGS.INCREMENT_PROCESS_PROGRESS();
			v_TEMP_INDEX := v_TEMPLATES.NEXT(v_TEMP_INDEX);
        END LOOP;
		v_ACCT_INDEX := v_ACCOUNTS.NEXT(v_ACCT_INDEX);
	END LOOP;

	LOGS.STOP_PROCESS(v_MESSAGE, p_STATUS);
	COMMIT;

EXCEPTION
	WHEN OTHERS THEN
    	ERRS.ABORT_PROCESS;

END ACCOUNT_GROUP_WRF_PROFILES;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_CUSTOMER_BASE_LOAD_LINE
	(
	p_CUSTOMER_ID IN NUMBER,
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_BASE_LOAD_TEMPLATE_ID IN NUMBER,
	p_BASE_LOAD IN NUMBER,
	p_OBSERVATIONS IN NUMBER,
	p_COEFFICIENT IN NUMBER,
	p_X_MIN IN NUMBER,
	p_X_MAX IN NUMBER,
	p_Y_MIN IN NUMBER,
	p_Y_MAX IN NUMBER,
	p_X_ZERO IN NUMBER,
	p_Y_ZERO IN NUMBER,
	p_OUTPUT_AS_OF_DATE IN DATE
	) AS

v_Y_TYPE CHAR(1);

BEGIN
	IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
		LOGS.LOG_DEBUG_DETAIL(
			TO_CHAR(p_CUSTOMER_ID) || ',' ||
			TO_CHAR(p_WRF_ID) || ',' ||
			TO_CHAR(p_TEMPLATE_ID) || ',' ||
			TO_CHAR(1) || ',' ||
			TO_CHAR(p_OUTPUT_AS_OF_DATE) || ',' ||
			TO_CHAR(p_BASE_LOAD) || ',' ||
			TO_CHAR(p_COEFFICIENT) || ',' ||
			TO_CHAR(0) || ',' ||
			TO_CHAR(p_OBSERVATIONS) || ',' ||
			TO_CHAR(p_X_MIN) || ',' ||
			TO_CHAR(p_X_MAX) || ',' ||
			TO_CHAR(p_Y_MIN) || ',' ||
			TO_CHAR(p_Y_MAX) || ',' ||
			TO_CHAR(p_X_ZERO) || ',' ||
			TO_CHAR(p_Y_ZERO));
	END IF;
	IF p_OBSERVATIONS< GA.CUSTOMER_USAGE_WRF_MIN_POINTS THEN
		v_Y_TYPE := 'D';
	ELSE
		v_Y_TYPE := 'C';
	END IF;

	UPDATE CUSTOMER_USAGE_WRF_LINE
	SET ALPHA = p_BASE_LOAD,
		BETA = p_COEFFICIENT,
		R2 = 0,
		N = p_OBSERVATIONS,
		X_MIN = p_X_MIN,
		X_MAX = p_X_MAX,
		Y_MIN = p_Y_MIN,
		Y_MAX = p_Y_MAX,
		X_ZERO = p_X_ZERO,
		Y_ZERO = p_Y_ZERO,
		BASE_LOAD_TEMPLATE_ID = p_BASE_LOAD_TEMPLATE_ID,
		Y_TYPE = v_Y_TYPE
	WHERE CUSTOMER_ID = p_CUSTOMER_ID
		AND WRF_ID = p_WRF_ID
		AND TEMPLATE_ID = p_TEMPLATE_ID
		AND SEGMENT_NBR = 1
		AND AS_OF_DATE = p_OUTPUT_AS_OF_DATE;

	IF SQL%NOTFOUND THEN
		INSERT INTO CUSTOMER_USAGE_WRF_LINE(
			CUSTOMER_ID,
			WRF_ID,
			TEMPLATE_ID,
			SEGMENT_NBR,
			AS_OF_DATE,
			ALPHA,
			BETA,
			R2,
			N,
			X_MIN,
			X_MAX,
			Y_MIN,
			Y_MAX,
			X_ZERO,
			Y_ZERO,
			BASE_LOAD_TEMPLATE_ID,
			Y_TYPE)
		VALUES(
			p_CUSTOMER_ID,
			p_WRF_ID,
			p_TEMPLATE_ID,
			1,
			p_OUTPUT_AS_OF_DATE,
			p_BASE_LOAD,
			p_COEFFICIENT,
			0,
			p_OBSERVATIONS,
			p_X_MIN,
			p_X_MAX,
			p_Y_MIN,
			p_Y_MAX,
			p_X_ZERO,
			p_Y_ZERO,
			p_BASE_LOAD_TEMPLATE_ID,
			v_Y_TYPE);
	END IF;
EXCEPTION
	WHEN OTHERS THEN
    	ERRS.LOG_AND_RAISE();
END PUT_CUSTOMER_BASE_LOAD_LINE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_BASE_LOAD_LINE
	(
	p_ACCOUNT_ID IN NUMBER,
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_BASE_LOAD_TEMPLATE_ID IN NUMBER,
	p_BASE_LOAD IN NUMBER,
	p_OBSERVATIONS IN NUMBER,
	p_COEFFICIENT IN NUMBER,
	p_X_MIN IN NUMBER,
	p_X_MAX IN NUMBER,
	p_Y_MIN IN NUMBER,
	p_Y_MAX IN NUMBER,
	p_X_ZERO IN NUMBER,
	p_Y_ZERO IN NUMBER,
	p_OUTPUT_AS_OF_DATE IN DATE
	) AS

v_Y_TYPE CHAR(1);

BEGIN
	IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
		LOGS.LOG_DEBUG_DETAIL(
			TO_CHAR(p_ACCOUNT_ID) || ',' ||
			TO_CHAR(p_WRF_ID) || ',' ||
			TO_CHAR(p_TEMPLATE_ID) || ',' ||
			TO_CHAR(1) || ',' ||
			TO_CHAR(p_OUTPUT_AS_OF_DATE) || ',' ||
			TO_CHAR(p_BASE_LOAD) || ',' ||
			TO_CHAR(p_COEFFICIENT) || ',' ||
			TO_CHAR(0) || ',' ||
			TO_CHAR(p_OBSERVATIONS) || ',' ||
			TO_CHAR(p_X_MIN) || ',' ||
			TO_CHAR(p_X_MAX) || ',' ||
			TO_CHAR(p_Y_MIN) || ',' ||
			TO_CHAR(p_Y_MAX) || ',' ||
			TO_CHAR(p_X_ZERO) || ',' ||
			TO_CHAR(p_Y_ZERO));
	END IF;

	IF p_OBSERVATIONS< g_ACCOUNT_USAGE_WRF_MIN_POINTS THEN
		v_Y_TYPE := 'D';
	ELSE
		v_Y_TYPE := 'C';
	END IF;

	UPDATE ACCOUNT_USAGE_WRF_LINE
	SET ALPHA = p_BASE_LOAD,
		BETA = p_COEFFICIENT,
		R2 = 0,
		N = p_OBSERVATIONS,
		X_MIN = p_X_MIN,
		X_MAX = p_X_MAX,
		Y_MIN = p_Y_MIN,
		Y_MAX = p_Y_MAX,
		X_ZERO = p_X_ZERO,
		Y_ZERO = p_Y_ZERO,
		BASE_LOAD_TEMPLATE_ID = p_BASE_LOAD_TEMPLATE_ID,
		Y_TYPE = v_Y_TYPE
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND WRF_ID = p_WRF_ID
		AND TEMPLATE_ID = p_TEMPLATE_ID
		AND SEGMENT_NBR = 1
		AND AS_OF_DATE = p_OUTPUT_AS_OF_DATE;

	IF SQL%NOTFOUND THEN
		INSERT INTO ACCOUNT_USAGE_WRF_LINE(
			ACCOUNT_ID,
			WRF_ID,
			TEMPLATE_ID,
			SEGMENT_NBR,
			AS_OF_DATE,
			ALPHA,
			BETA,
			R2,
			N,
			X_MIN,
			X_MAX,
			Y_MIN,
			Y_MAX,
			X_ZERO,
			Y_ZERO,
			BASE_LOAD_TEMPLATE_ID,
			Y_TYPE)
		VALUES(
			p_ACCOUNT_ID,
			p_WRF_ID,
			p_TEMPLATE_ID,
			1,
			p_OUTPUT_AS_OF_DATE,
			p_BASE_LOAD,
			p_COEFFICIENT,
			0,
			p_OBSERVATIONS,
			p_X_MIN,
			p_X_MAX,
			p_Y_MIN,
			p_Y_MAX,
			p_X_ZERO,
			p_Y_ZERO,
			p_BASE_LOAD_TEMPLATE_ID,
			v_Y_TYPE);
	END IF;
EXCEPTION
	WHEN OTHERS THEN
    	ERRS.LOG_AND_RAISE();
END PUT_ACCOUNT_BASE_LOAD_LINE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_USAGE_WRF_SEASON
	(
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_BASE_LOAD_TEMPLATE_ID IN NUMBER,
	p_AS_OF_DATE IN DATE
	) AS

v_COUNT NUMBER(4);

BEGIN

	DELETE USAGE_WRF_SEASON
	WHERE WRF_ID = p_WRF_ID
		AND  TEMPLATE_ID = p_TEMPLATE_ID
		--AND NVL(BASE_LOAD_TEMPLATE_ID, p_BASE_LOAD_TEMPLATE_ID) = p_BASE_LOAD_TEMPLATE_ID  --Don't use in where unless BASE_LOAD_TEMPLATE_ID added to PK
		AND AS_OF_DATE = p_AS_OF_DATE;

	INSERT INTO USAGE_WRF_SEASON (WRF_ID, TEMPLATE_ID, BASE_LOAD_TEMPLATE_ID, SEASON_ID,BASE_LOAD_SEASON_ID, AS_OF_DATE, BEGIN_DATE, END_DATE,BASE_LOAD_BEGIN_DATE, BASE_LOAD_END_DATE)
		SELECT DISTINCT p_WRF_ID, p_TEMPLATE_ID,p_BASE_LOAD_TEMPLATE_ID, C.SEASON_ID, D.SEASON_ID, p_AS_OF_DATE, C.BEGIN_DATE, C.END_DATE, D.BEGIN_DATE, D.END_DATE
		FROM USAGE_WRF_TEMPLATE A,
			TEMPLATE_SEASON_DAY_NAME B,
			SEASON C,
			SEASON D,
			TEMPLATE_SEASON_DAY_NAME E
		WHERE A.WRF_ID = p_WRF_ID
			AND A.TEMPLATE_ID = p_TEMPLATE_ID
			AND A.BASE_LOAD_TEMPLATE_ID = p_BASE_LOAD_TEMPLATE_ID
			AND B.TEMPLATE_ID = A.TEMPLATE_ID
			AND C.SEASON_ID = B.SEASON_ID
			AND E.TEMPLATE_ID = A.BASE_LOAD_TEMPLATE_ID
			AND D.SEASON_ID = E.SEASON_ID;

	SELECT COUNT(1)
	INTO v_COUNT
	FROM USAGE_WRF_SEASON A
	WHERE WRF_ID = p_WRF_ID
		AND AS_OF_DATE = p_AS_OF_DATE
		AND EXISTS
			(SELECT 1
			FROM USAGE_WRF_SEASON X, SEASON_DATES Y
			WHERE WRF_ID = A.WRF_ID
				AND Y.SEASON_ID = X.SEASON_ID
				AND AS_OF_DATE = p_AS_OF_DATE
				AND X.ROWID <> A.ROWID
                AND Y.BEGIN_DATE <= A.END_DATE  --Replace SEASON_INTERSECTS_SEASON fxn
                AND Y.END_DATE >=  A.BEGIN_DATE);  --Replace SEASON_INTERSECTS_SEASON fxn

	IF v_COUNT > 1 THEN
		ERRS.RAISE(MSGCODES.c_ERR_DATES_OVERLAP, 'Overlapping Customer Usage WRF Season Assignments In Effect.');
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_RAISE();
END PUT_USAGE_WRF_SEASON;
----------------------------------------------------------------------------------------------------
PROCEDURE CALCULATE_COEFFICIENT
	(
	p_DAILY_BASE_LOAD IN NUMBER,
	p_CUSTOMER_ID IN NUMBER,
	p_WRF_ID IN NUMBER,
	p_STATION_ID IN NUMBER,
	p_PARAMETER_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_BASE_LOAD_TEMPLATE_ID IN NUMBER,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_COEFFICIENT OUT NUMBER,
	p_READ_COUNT OUT NUMBER,
	p_X_MIN OUT NUMBER,
	p_X_MAX OUT NUMBER,
	p_Y_MIN OUT NUMBER,
	p_Y_MAX OUT NUMBER,
	p_X_ZERO OUT NUMBER,
	p_Y_ZERO OUT NUMBER
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_PARAMETER_VAL NUMBER;
v_USAGE_VAL NUMBER;
v_DAYS NUMBER;
v_READ_COUNT NUMBER := 0;
g_MIN_PARAMETER_VAL NUMBER(4,1):= 999;
v_AVG_PARAMETER_VAL GA.NUMBER_TABLE;
v_DAILY_SEASON_LOAD GA.NUMBER_TABLE;
v_SEASON_DAYS GA.NUMBER_TABLE;
v_TOTAL_SEASON_DAYS NUMBER(10) := 0;
v_CONSUMPTION_CODE CHAR(1) := NVL(MODEL_VALUE_AT_KEY(0,'Position and Billing','Consumption Code','Final',0),'A');

CURSOR c_CUSTOMER IS
	SELECT A.CUSTOMER_ID, B.BEGIN_DATE, B.END_DATE, B.BILLED_USAGE, C.BEGIN_DATE "SEASON_BEGIN_DATE", C.END_DATE "SEASON_END_DATE",D.ALPHA,D.BETA
	FROM CUSTOMER_USAGE_WRF A,
         CUSTOMER_CONSUMPTION B,
         USAGE_WRF_SEASON C,
         USAGE_WRF_TEMPLATE D,
         SEASON_DATES I
	WHERE A.WRF_ID = p_WRF_ID
        AND C.WRF_ID = p_WRF_ID  --specify for speed
        AND D.WRF_ID = p_WRF_ID  --specify for speed
		AND D.TEMPLATE_ID = p_TEMPLATE_ID  --specify for speed
		AND A.CUSTOMER_ID = p_CUSTOMER_ID
		AND A.BEGIN_DATE <= p_END_DATE
		AND NVL(A.END_DATE, p_END_DATE) >= p_BEGIN_DATE
		AND B.CUSTOMER_ID = A.CUSTOMER_ID
        AND B.CUSTOMER_ID = p_CUSTOMER_ID  --specify for speed
		AND B.BILL_CODE = 'B'
		AND B.CONSUMPTION_CODE IN (v_CONSUMPTION_CODE,'H')
        AND B.BEGIN_DATE <= p_END_DATE  -- Meter read TOUCHES date range.
        AND B.END_DATE >= p_BEGIN_DATE  -- Meter read TOUCHES date range.
		AND C.WRF_ID = A.WRF_ID
		AND C.TEMPLATE_ID = p_TEMPLATE_ID
		AND C.BASE_LOAD_TEMPLATE_ID = p_BASE_LOAD_TEMPLATE_ID
		AND C.AS_OF_DATE = p_OUTPUT_AS_OF_DATE
		AND C.WRF_ID = D.WRF_ID
		AND C.TEMPLATE_ID = D.TEMPLATE_ID
		AND I.SEASON_ID = C.SEASON_ID
        AND B.BEGIN_DATE  <= I.END_DATE  --Replace SEASON_INTERSECTS_SEASON fxn
		AND B.END_DATE    >= I.BEGIN_DATE  --Replace SEASON_INTERSECTS_SEASON fxn
	ORDER BY 1;

BEGIN
	p_X_MIN := 999999;
	p_X_MAX := -999999;
	p_Y_MIN := 999999;
	p_Y_MAX := -999999;
	p_X_ZERO := 0;
	p_Y_ZERO := 0;

	FOR v_CUSTOMER IN c_CUSTOMER LOOP

		v_READ_COUNT := v_READ_COUNT+1;
 	    v_BEGIN_DATE := v_CUSTOMER.BEGIN_DATE;
		v_END_DATE   := v_CUSTOMER.END_DATE;
		v_SEASON_DAYS(v_READ_COUNT) := GREATEST((v_END_DATE-v_BEGIN_DATE)+1,1);
		v_TOTAL_SEASON_DAYS := v_TOTAL_SEASON_DAYS+v_SEASON_DAYS(v_READ_COUNT);
		GET_STATION_PARAMETER(p_STATION_ID, p_PARAMETER_ID, v_BEGIN_DATE, v_END_DATE, v_PARAMETER_VAL);

		IF (v_PARAMETER_VAL IS NULL OR v_PARAMETER_VAL < 1) THEN
			v_AVG_PARAMETER_VAL(v_READ_COUNT) := g_MIN_PARAMETER_VAL;
		ELSE
			v_AVG_PARAMETER_VAL(v_READ_COUNT) := v_PARAMETER_VAL;
		END IF;

		v_DAYS := GREATEST((v_CUSTOMER.END_DATE - v_CUSTOMER.BEGIN_DATE) + 1,1);

		IF v_DAYS > 0 THEN
			v_USAGE_VAL := ROUND(v_CUSTOMER.BILLED_USAGE / v_DAYS, 4);
		ELSE
			v_USAGE_VAL := 0;
		END IF;
		v_DAILY_SEASON_LOAD(v_READ_COUNT) := v_USAGE_VAL - p_DAILY_BASE_LOAD;
		p_X_MIN := LEAST(p_X_MIN, v_PARAMETER_VAL);
		p_X_MAX := GREATEST(p_X_MAX,v_PARAMETER_VAL);
		p_Y_MIN := LEAST(p_Y_MIN, v_USAGE_VAL);
		p_Y_MAX := GREATEST(p_Y_MAX,v_USAGE_VAL);
		p_READ_COUNT := v_READ_COUNT;
		IF v_PARAMETER_VAL = 0 THEN p_X_ZERO := p_X_ZERO+1; END IF;
		IF v_USAGE_VAL = 0 THEN p_Y_ZERO := p_Y_ZERO+1; END IF;
		IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
			LOGS.LOG_DEBUG_DETAIL(TO_CHAR(v_CUSTOMER.BEGIN_DATE) || ',' || TO_CHAR(v_CUSTOMER.END_DATE) || ',' || TO_CHAR(v_CUSTOMER.BILLED_USAGE) || ',' || TO_CHAR(NVL(v_PARAMETER_VAL,0)) || ',' || TO_CHAR(v_DAYS));
			LOGS.LOG_DEBUG_DETAIL('AVERAGE PARAMETER VAL = '||TO_CHAR(v_AVG_PARAMETER_VAL(v_READ_COUNT)));
			LOGS.LOG_DEBUG_DETAIL('DAILY BASE LOAD = '||TO_CHAR(p_DAILY_BASE_LOAD));
			LOGS.LOG_DEBUG_DETAIL('AVERAGE LOAD = '||TO_CHAR(v_USAGE_VAL));
			LOGS.LOG_DEBUG_DETAIL('SEASON_DAYS = '||TO_CHAR(v_SEASON_DAYS(v_READ_COUNT)));
			LOGS.LOG_DEBUG_DETAIL('NON BASE USAGE = '||TO_CHAR(v_DAILY_SEASON_LOAD(v_READ_COUNT)));
		END IF;
	END LOOP;
	p_COEFFICIENT := 0;
	FOR i IN 1..v_READ_COUNT LOOP
		p_COEFFICIENT := p_COEFFICIENT+(v_DAILY_SEASON_LOAD(i)/NVL(v_AVG_PARAMETER_VAL(i),g_MIN_PARAMETER_VAL))*(v_SEASON_DAYS(i)/v_TOTAL_SEASON_DAYS);
	END LOOP;

EXCEPTION
	WHEN OTHERS THEN
    	ERRS.LOG_AND_RAISE();
END CALCULATE_COEFFICIENT;
---------------------------------------------------------------------------------------------------
PROCEDURE CALCULATE_ACCOUNT_COEFFICIENT
	(
	p_MODEL_ID IN NUMBER,
	p_DAILY_BASE_LOAD IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_WRF_ID IN NUMBER,
	p_STATION_ID IN NUMBER,
	p_PARAMETER_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_BASE_LOAD_TEMPLATE_ID IN NUMBER,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_COEFFICIENT OUT NUMBER,
	p_READ_COUNT OUT NUMBER,
	p_X_MIN OUT NUMBER,
	p_X_MAX OUT NUMBER,
	p_Y_MIN OUT NUMBER,
	p_Y_MAX OUT NUMBER,
	p_X_ZERO OUT NUMBER,
	p_Y_ZERO OUT NUMBER
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_PARAMETER_VAL NUMBER;
v_USAGE_VAL NUMBER;
v_DAYS NUMBER;
v_READ_COUNT NUMBER := 0;
g_MIN_PARAMETER_VAL NUMBER(4,1):= 999;
v_AVG_PARAMETER_VAL GA.NUMBER_TABLE;
v_DAILY_SEASON_LOAD GA.NUMBER_TABLE;
v_SEASON_DAYS GA.NUMBER_TABLE;
v_TOTAL_SEASON_DAYS NUMBER(10) := 0;
v_CONSUMPTION_CODE CHAR(1) := NVL(MODEL_VALUE_AT_KEY(0,'Position and Billing','Consumption Code','Final',0),'A');

CURSOR c_ACCOUNT IS
	SELECT A.ACCOUNT_ID, B.BEGIN_DATE, B.END_DATE, B.BILLED_USAGE, C.BEGIN_DATE "SEASON_BEGIN_DATE", C.END_DATE "SEASON_END_DATE",D.ALPHA,D.BETA
	FROM ACCOUNT_USAGE_WRF A,
         SERVICE_CONSUMPTION B,
         USAGE_WRF_SEASON C,
         USAGE_WRF_TEMPLATE D,
         ACCOUNT_SERVICE E,
         SERVICE F,
         SEASON_DATES I
	WHERE A.WRF_ID = p_WRF_ID
		AND C.WRF_ID = p_WRF_ID  --specify for speed
		AND D.WRF_ID = p_WRF_ID  --specify for speed
		AND D.TEMPLATE_ID = p_TEMPLATE_ID  --specify for speed
		AND A.ACCOUNT_ID = p_ACCOUNT_ID
		AND A.BEGIN_DATE <= p_END_DATE
		AND NVL(A.END_DATE, p_END_DATE) >= p_BEGIN_DATE
        AND E.ACCOUNT_ID = A.ACCOUNT_ID    --Get service_consumption records for the account thru account_service
        AND F.ACCOUNT_SERVICE_ID = E.ACCOUNT_SERVICE_ID
		AND B.SERVICE_ID = F.SERVICE_ID
		AND B.BILL_CODE = 'B'
		AND B.CONSUMPTION_CODE IN (v_CONSUMPTION_CODE,'H')
        AND B.BEGIN_DATE  <= p_END_DATE  -- Meter read TOUCHES date range.
		AND B.END_DATE   >= p_BEGIN_DATE  -- Meter read TOUCHES date range.
		AND C.WRF_ID = A.WRF_ID
		AND C.TEMPLATE_ID = p_TEMPLATE_ID
		AND C.BASE_LOAD_TEMPLATE_ID = p_BASE_LOAD_TEMPLATE_ID
		AND C.AS_OF_DATE = p_OUTPUT_AS_OF_DATE
		AND D.WRF_ID = C.WRF_ID
		AND D.TEMPLATE_ID = C.TEMPLATE_ID
		AND I.SEASON_ID = C.SEASON_ID
        AND B.BEGIN_DATE  <= I.END_DATE  --Replace SEASON_INTERSECTS_SEASON fxn
		AND B.END_DATE    >= I.BEGIN_DATE  --Replace SEASON_INTERSECTS_SEASON fxn
		AND B.UNIT_OF_MEASUREMENT = GA.DEFAULT_UNIT_OF_MEASUREMENT
	ORDER BY 1;

BEGIN
-- Check to see if the process has an external signal to terminate.
	p_X_MIN := 999999;
	p_X_MAX := -999999;
	p_Y_MIN := 999999;
	p_Y_MAX := -999999;
	p_X_ZERO := 0;
	p_Y_ZERO := 0;

	FOR v_ACCOUNT IN c_ACCOUNT LOOP

		v_READ_COUNT := v_READ_COUNT+1;
        v_BEGIN_DATE := v_ACCOUNT.BEGIN_DATE;
		v_END_DATE   := v_ACCOUNT.END_DATE;
		v_SEASON_DAYS(v_READ_COUNT) := GREATEST((v_END_DATE-v_BEGIN_DATE)+1,1);
		v_TOTAL_SEASON_DAYS := v_TOTAL_SEASON_DAYS+v_SEASON_DAYS(v_READ_COUNT);
		GET_STATION_PARAMETER(p_STATION_ID, p_PARAMETER_ID, v_BEGIN_DATE, v_END_DATE, v_PARAMETER_VAL);

		IF (v_PARAMETER_VAL IS NULL OR v_PARAMETER_VAL < 1) THEN
		   v_AVG_PARAMETER_VAL(v_READ_COUNT) := g_MIN_PARAMETER_VAL;
		ELSE
		   v_AVG_PARAMETER_VAL(v_READ_COUNT) := v_PARAMETER_VAL;
		END IF;

		v_DAYS := GREATEST((v_ACCOUNT.END_DATE - v_ACCOUNT.BEGIN_DATE) + 1,1);

		IF v_DAYS > 0 THEN
			v_USAGE_VAL := ROUND(v_ACCOUNT.BILLED_USAGE / v_DAYS, 4);
		ELSE
			v_USAGE_VAL := 0;
		END IF;
		v_DAILY_SEASON_LOAD(v_READ_COUNT) := v_USAGE_VAL - p_DAILY_BASE_LOAD;
		p_X_MIN := LEAST(p_X_MIN, v_PARAMETER_VAL);
		p_X_MAX := GREATEST(p_X_MAX,v_PARAMETER_VAL);
		p_Y_MIN := LEAST(p_Y_MIN, v_USAGE_VAL);
		p_Y_MAX := GREATEST(p_Y_MAX,v_USAGE_VAL);
		p_READ_COUNT := v_READ_COUNT;
		IF v_PARAMETER_VAL = 0 THEN p_X_ZERO := p_X_ZERO+1; END IF;
		IF v_USAGE_VAL = 0 THEN p_Y_ZERO := p_Y_ZERO+1; END IF;
		IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
			LOGS.LOG_DEBUG_DETAIL(TO_CHAR(v_ACCOUNT.BEGIN_DATE) || ',' || TO_CHAR(v_ACCOUNT.END_DATE) || ',' || TO_CHAR(v_ACCOUNT.BILLED_USAGE) || ',' || TO_CHAR(NVL(v_PARAMETER_VAL,0)) || ',' || TO_CHAR(v_DAYS));
			LOGS.LOG_DEBUG_DETAIL('AVERAGE PARAMETER VAL = '||TO_CHAR(v_AVG_PARAMETER_VAL(v_READ_COUNT)));
			LOGS.LOG_DEBUG_DETAIL('DAILY BASE LOAD = '||TO_CHAR(p_DAILY_BASE_LOAD));
			LOGS.LOG_DEBUG_DETAIL('AVERAGE LOAD = '||TO_CHAR(v_USAGE_VAL));
			LOGS.LOG_DEBUG_DETAIL('SEASON_DAYS = '||TO_CHAR(v_SEASON_DAYS(v_READ_COUNT)));
			LOGS.LOG_DEBUG_DETAIL('NON BASE USAGE = '||TO_CHAR(v_DAILY_SEASON_LOAD(v_READ_COUNT)));
		END IF;
	END LOOP;
	p_COEFFICIENT := 0;
	FOR i IN 1..v_READ_COUNT LOOP
		p_COEFFICIENT := p_COEFFICIENT+(v_DAILY_SEASON_LOAD(i)/NVL(v_AVG_PARAMETER_VAL(i),g_MIN_PARAMETER_VAL))*(v_SEASON_DAYS(i)/v_TOTAL_SEASON_DAYS);
	END LOOP;

EXCEPTION
	WHEN OTHERS THEN
    	ERRS.LOG_AND_RAISE();
END CALCULATE_ACCOUNT_COEFFICIENT;
---------------------------------------------------------------------------------------------------
PROCEDURE APPLY_CUSTOMER_USAGE_WRF_BASE
	(
	p_WRF_ID IN NUMBER,
	p_STATION_ID IN NUMBER,
	p_PARAMETER_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_BASE_LOAD_TEMPLATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_DEFAULT_ALPHA IN NUMBER,
	p_DEFAULT_BETA IN NUMBER
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_DAYS NUMBER;
v_COEFFICIENT  NUMBER := 0;
v_OBSERVATIONS NUMBER := 0;
v_INITIAL BOOLEAN := TRUE;
v_CUSTOMER_ID NUMBER := CONSTANTS.NOT_ASSIGNED;
v_CUSTOMER_COUNT NUMBER := 0;
v_READ_COUNT NUMBER := 0;
v_VALID_READ_DAYS PLS_INTEGER := 0;
v_TOTAL_VALID_READ_DAYS NUMBER := 0;
v_EVENT_TEXT PROCESS_LOG_EVENT.EVENT_TEXT%TYPE;
v_VALID_BASE_LOAD NUMBER := 0;
v_TOTAL_BASE_LOAD NUMBER := 0;
v_AVERAGE_DAILY_USAGE NUMBER := 0;
v_DAILY_BASE_LOAD NUMBER := 0;
v_X_MIN NUMBER := 0;
v_X_MAX NUMBER := 0;
v_Y_MIN NUMBER := 0;
v_Y_MAX NUMBER := 0;
v_X_ZERO NUMBER := 0;
v_Y_ZERO NUMBER := 0;
v_COUNT PLS_INTEGER := 0;
v_DEFAULT_ASSIGNMENTS NUMBER := 0;
v_WRF_MIN NUMBER := 999999;
v_WRF_MAX NUMBER := -999999;
v_ALPHA GA.NUMBER_TABLE;
v_BETA GA.NUMBER_TABLE;
v_CONSUMPTION_CODE CHAR(1) := NVL(MODEL_VALUE_AT_KEY(0,'Position and Billing','Consumption Code','Final',0),'A');
v_CUSTOMER_USAGE_WRF_COUNT NUMBER(9);
v_PROGRESS_RANGE_IDX PLS_INTEGER;

CURSOR c_CUSTOMER_BASE_LOAD IS
	SELECT A.CUSTOMER_ID, B.BEGIN_DATE, B.END_DATE, B.BILLED_USAGE, C.BASE_LOAD_BEGIN_DATE "BASE_LOAD_BEGIN_DATE", C.BASE_LOAD_END_DATE "BASE_LOAD_END_DATE"
	FROM CUSTOMER_USAGE_WRF A,
         CUSTOMER_CONSUMPTION B,
         USAGE_WRF_SEASON C,
         SEASON_DATES F
	WHERE A.WRF_ID = p_WRF_ID
		AND A.BEGIN_DATE <= p_END_DATE
		AND NVL(A.END_DATE, p_END_DATE) >= p_BEGIN_DATE
		AND B.CUSTOMER_ID = A.CUSTOMER_ID
		AND B.BILL_CODE = 'B'
		AND B.CONSUMPTION_CODE IN (v_CONSUMPTION_CODE,'H')
		AND B.BEGIN_DATE <= p_END_DATE  -- Meter read TOUCHES date range.
		AND B.END_DATE >= p_BEGIN_DATE  -- Meter read TOUCHES date range.
		AND C.WRF_ID = A.WRF_ID  --join
		AND C.WRF_ID = p_WRF_ID  --specify for speed
		AND C.TEMPLATE_ID = p_TEMPLATE_ID
		AND C.BASE_LOAD_TEMPLATE_ID = p_BASE_LOAD_TEMPLATE_ID
		AND C.AS_OF_DATE = p_OUTPUT_AS_OF_DATE
		--Replace fxn: AND SEASON_INTERSECTS_SEASON(B.BEGIN_DATE, B.END_DATE, C.BASE_LOAD_BEGIN_DATE, C.BASE_LOAD_END_DATE) = 'Y'
		AND F.SEASON_ID = C.BASE_LOAD_SEASON_ID
        AND B.BEGIN_DATE  <= F.END_DATE
		AND B.END_DATE    >= F.BEGIN_DATE
UNION
	SELECT 9999999, LOW_DATE, LOW_DATE, 0, LOW_DATE, LOW_DATE FROM DUAL
	ORDER BY 1;

BEGIN
	-- clear out old entries first
	DELETE CUSTOMER_USAGE_WRF_LINE
	WHERE WRF_ID = p_WRF_ID
		AND TEMPLATE_ID = p_TEMPLATE_ID;

	PUT_USAGE_WRF_SEASON(p_WRF_ID, p_TEMPLATE_ID,p_BASE_LOAD_TEMPLATE_ID, p_OUTPUT_AS_OF_DATE);

	-- Get the Progress Count for the loop
	SELECT COUNT(1) + 1
	INTO v_CUSTOMER_USAGE_WRF_COUNT
	FROM CUSTOMER_USAGE_WRF A,
         CUSTOMER_CONSUMPTION B,
         USAGE_WRF_SEASON C,
         SEASON_DATES F
	WHERE A.WRF_ID = p_WRF_ID
		AND A.BEGIN_DATE <= p_END_DATE
		AND NVL(A.END_DATE, p_END_DATE) >= p_BEGIN_DATE
		AND B.CUSTOMER_ID = A.CUSTOMER_ID
		AND B.BILL_CODE = 'B'
		AND B.CONSUMPTION_CODE IN (v_CONSUMPTION_CODE,'H')
		AND B.BEGIN_DATE <= p_END_DATE  -- Meter read TOUCHES date range.
		AND B.END_DATE >= p_BEGIN_DATE  -- Meter read TOUCHES date range.
		AND C.WRF_ID = A.WRF_ID  --join
		AND C.WRF_ID = p_WRF_ID  --specify for speed
		AND C.TEMPLATE_ID = p_TEMPLATE_ID
		AND C.BASE_LOAD_TEMPLATE_ID = p_BASE_LOAD_TEMPLATE_ID
		AND C.AS_OF_DATE = p_OUTPUT_AS_OF_DATE
		--Replace fxn: AND SEASON_INTERSECTS_SEASON(B.BEGIN_DATE, B.END_DATE, C.BASE_LOAD_BEGIN_DATE, C.BASE_LOAD_END_DATE) = 'Y'
		AND F.SEASON_ID = C.BASE_LOAD_SEASON_ID
        AND B.BEGIN_DATE  <= F.END_DATE
		AND B.END_DATE    >= F.BEGIN_DATE;

	-- Update the Progress with a new range
	v_PROGRESS_RANGE_IDX := LOGS.PUSH_PROGRESS_RANGE(v_CUSTOMER_USAGE_WRF_COUNT);

	FOR v_CUSTOMER_BASE_LOAD IN c_CUSTOMER_BASE_LOAD LOOP

		IF v_INITIAL THEN
			v_CUSTOMER_ID := v_CUSTOMER_BASE_LOAD.CUSTOMER_ID;
			v_EVENT_TEXT := 'Begin Calculation for WRF_ID=' || TO_CHAR(p_WRF_ID) || ', TEMPLATE_ID=' || TO_CHAR(p_TEMPLATE_ID);
			LOGS.LOG_DEBUG(v_EVENT_TEXT);
			v_INITIAL := FALSE;
		END IF;

		IF v_CUSTOMER_ID <> v_CUSTOMER_BASE_LOAD.CUSTOMER_ID THEN
			v_DAILY_BASE_LOAD := ROUND(v_TOTAL_BASE_LOAD/v_TOTAL_VALID_READ_DAYS,4);
			IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
				LOGS.LOG_DEBUG_DETAIL('CUSTOMER_ID =' || TO_CHAR(v_CUSTOMER_ID));
				LOGS.LOG_DEBUG_DETAIL('NUMBER OF BASE LOAD READS = ' || TO_CHAR(v_READ_COUNT));
				LOGS.LOG_DEBUG_DETAIL('ACTUAL DAILY BASE LOAD =' || TO_CHAR(v_DAILY_BASE_LOAD));
				LOGS.LOG_DEBUG_DETAIL('TOTAL VALID READ DAYS =' || TO_CHAR(v_TOTAL_VALID_READ_DAYS));
			END IF;
			IF p_TEMPLATE_ID = p_BASE_LOAD_TEMPLATE_ID THEN
				v_COEFFICIENT := 0;
				v_OBSERVATIONS := v_READ_COUNT;
				IF v_READ_COUNT < GA.CUSTOMER_USAGE_WRF_MIN_POINTS THEN
					v_DAILY_BASE_LOAD := p_DEFAULT_ALPHA;
					v_DEFAULT_ASSIGNMENTS := v_DEFAULT_ASSIGNMENTS+1;
				END IF;
			ELSE
				CALCULATE_COEFFICIENT(v_DAILY_BASE_LOAD,v_CUSTOMER_ID,p_WRF_ID,p_STATION_ID,p_PARAMETER_ID,p_TEMPLATE_ID,
					p_BEGIN_DATE,p_END_DATE,p_BASE_LOAD_TEMPLATE_ID,p_OUTPUT_AS_OF_DATE,v_COEFFICIENT,v_OBSERVATIONS,
					v_X_MIN,v_X_MAX,v_Y_MIN,v_Y_MAX,v_X_ZERO,v_Y_ZERO);
				IF v_OBSERVATIONS < GA.CUSTOMER_USAGE_WRF_MIN_POINTS THEN
					v_COEFFICIENT := p_DEFAULT_BETA;
					v_DEFAULT_ASSIGNMENTS := v_DEFAULT_ASSIGNMENTS+1;
				END IF;
			END IF;
			IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
				LOGS.LOG_DEBUG_DETAIL('NUMBER OF OBSERVATIONS = ' || TO_CHAR(v_OBSERVATIONS));
				LOGS.LOG_DEBUG_DETAIL('POSTED DAILY BASE LOAD =' || TO_CHAR(v_DAILY_BASE_LOAD));
				LOGS.LOG_DEBUG_DETAIL('POSTED COEFFICIENT =' || TO_CHAR(v_COEFFICIENT));
			END IF;
			PUT_CUSTOMER_BASE_LOAD_LINE(v_CUSTOMER_ID,p_WRF_ID, p_TEMPLATE_ID, p_BASE_LOAD_TEMPLATE_ID, NVL(v_DAILY_BASE_LOAD,0),NVL(v_OBSERVATIONS,0),NVL(v_COEFFICIENT,0),
					v_X_MIN,v_X_MAX,v_Y_MIN,v_Y_MAX,v_X_ZERO,v_Y_ZERO,p_OUTPUT_AS_OF_DATE);
			--Set the nulls to zero and include them in the calculation - 03/31/03
            v_WRF_MIN := LEAST(NVL(v_DAILY_BASE_LOAD, 0) + NVL(v_COEFFICIENT,0) * NVL(v_X_MIN, 0), NVL(v_WRF_MIN, 0));
            v_WRF_MAX := GREATEST(NVL(v_DAILY_BASE_LOAD, 0) + NVL(v_COEFFICIENT,0) * NVL(v_X_MAX, 0), NVL(v_WRF_MAX, 0));

            v_ALPHA(v_ALPHA.COUNT+1) := v_DAILY_BASE_LOAD;
			v_BETA(v_BETA.COUNT+1) := NVL(v_COEFFICIENT,0);
			v_COUNT := v_COUNT+1;
			v_OBSERVATIONS := 0;
			v_READ_COUNT := 0;
			v_CUSTOMER_COUNT := v_CUSTOMER_COUNT + 1;
			v_DAILY_BASE_LOAD:= 0;
			v_TOTAL_BASE_LOAD := 0;
			v_AVERAGE_DAILY_USAGE := 0;
			v_TOTAL_VALID_READ_DAYS := 0;
			v_VALID_BASE_LOAD := 0;
			v_VALID_READ_DAYS := 0;
			v_X_MIN := 0;
			--v_Y_MIN := 0;
			--v_X_MAX := 0;
			v_Y_MAX := 0;
			v_X_ZERO := 0;
			v_Y_ZERO := 0;

			IF v_CUSTOMER_BASE_LOAD.CUSTOMER_ID = 9999999 THEN
				EXIT;
			END IF;
		END IF;

 		ALIGN_BILL_PERIOD_TO_SEASON
 			(
 			v_CUSTOMER_BASE_LOAD.BASE_LOAD_BEGIN_DATE,
 			v_CUSTOMER_BASE_LOAD.BASE_LOAD_END_DATE,
 			v_CUSTOMER_BASE_LOAD.BEGIN_DATE,
 			v_CUSTOMER_BASE_LOAD.END_DATE,
 			v_BEGIN_DATE,
 			v_END_DATE
 			);

		--determine the number of read days in the base load season
		v_VALID_READ_DAYS := GREATEST(v_END_DATE-v_BEGIN_DATE+1,1);
		--get average daily usage value for read period
		v_DAYS := GREATEST((v_CUSTOMER_BASE_LOAD.END_DATE - v_CUSTOMER_BASE_LOAD.BEGIN_DATE) + 1,1);
		IF v_DAYS > 0 THEN
			v_AVERAGE_DAILY_USAGE := ROUND(v_CUSTOMER_BASE_LOAD.BILLED_USAGE / v_DAYS, 4);
		ELSE
			v_AVERAGE_DAILY_USAGE := 0;
		END IF;

		--calculate base load contribution
		v_VALID_BASE_LOAD := v_AVERAGE_DAILY_USAGE*v_VALID_READ_DAYS;

		--accumulate the valid read days, average usage combination
		v_TOTAL_BASE_LOAD := v_TOTAL_BASE_LOAD+v_VALID_BASE_LOAD;
		v_TOTAL_VALID_READ_DAYS := v_TOTAL_VALID_READ_DAYS + v_VALID_READ_DAYS;

		v_CUSTOMER_ID := v_CUSTOMER_BASE_LOAD.CUSTOMER_ID;
		v_READ_COUNT := v_READ_COUNT+1;

		LOGS.INCREMENT_PROCESS_PROGRESS(p_RANGE_INDEX => v_PROGRESS_RANGE_IDX);
	END LOOP;
	LOGS.POP_PROGRESS_RANGE(v_PROGRESS_RANGE_IDX);
	IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
		LOGS.LOG_DEBUG_DETAIL('DEFAULT ASSIGNMENTS = '|| TO_CHAR(v_DEFAULT_ASSIGNMENTS));
		LOGS.LOG_DEBUG_DETAIL('WRF MIN =' || TO_CHAR(v_WRF_MIN));
		LOGS.LOG_DEBUG_DETAIL('WRF MAX =' || TO_CHAR(v_WRF_MAX));
	END IF;

	IF v_COUNT > 0 THEN
		COMPUTE_USAGE_WRF_STATISTICS(p_WRF_ID, p_TEMPLATE_ID, g_DEFAULT_SEGMENT, p_BEGIN_DATE, p_END_DATE, p_OUTPUT_AS_OF_DATE,
			v_DEFAULT_ASSIGNMENTS, v_WRF_MIN, v_WRF_MAX, 0, 0, v_ALPHA, v_BETA);
		IF g_ALLOW_COMMIT_ROLLBACK THEN COMMIT; END IF;
	END IF;

	v_EVENT_TEXT := 'Usage WRF Statistics Calculated for WRF_ID=' || TO_CHAR(p_WRF_ID) || ', TEMPLATE_ID=' || TO_CHAR(p_TEMPLATE_ID);
	LOGS.LOG_DEBUG(v_EVENT_TEXT);

	v_EVENT_TEXT := 'Total Customer Usage WRF Profiles Calculated:  ' || TO_CHAR(v_CUSTOMER_COUNT);
	LOGS.LOG_DEBUG(v_EVENT_TEXT);

END APPLY_CUSTOMER_USAGE_WRF_BASE;
----------------------------------------------------------------------------------------------------
PROCEDURE APPLY_ACCOUNT_USAGE_WRF_BASE
	(
	p_MODEL_ID IN NUMBER,
	p_WRF_ID IN NUMBER,
	p_STATION_ID IN NUMBER,
	p_PARAMETER_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_BASE_LOAD_TEMPLATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_DEFAULT_ALPHA IN NUMBER,
	p_DEFAULT_BETA IN NUMBER
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_DAYS NUMBER;
v_COEFFICIENT  NUMBER := 0;
v_OBSERVATIONS NUMBER := 0;
v_INITIAL BOOLEAN := TRUE;
v_ACCOUNT_ID NUMBER := CONSTANTS.NOT_ASSIGNED;
v_ACCOUNT_COUNT NUMBER := 0;
v_READ_COUNT NUMBER := 0;
v_VALID_READ_DAYS PLS_INTEGER := 0;
v_TOTAL_VALID_READ_DAYS NUMBER := 0;
v_EVENT_TEXT PROCESS_LOG_EVENT.EVENT_TEXT%TYPE;
v_VALID_BASE_LOAD NUMBER := 0;
v_TOTAL_BASE_LOAD NUMBER := 0;
v_AVERAGE_DAILY_USAGE NUMBER := 0;
v_DAILY_BASE_LOAD NUMBER := 0;
v_X_MIN NUMBER := 0;
v_X_MAX NUMBER := 0;
v_Y_MIN NUMBER := 0;
v_Y_MAX NUMBER := 0;
v_X_ZERO NUMBER := 0;
v_Y_ZERO NUMBER := 0;
v_COUNT PLS_INTEGER := 0;
v_DEFAULT_ASSIGNMENTS NUMBER := 0;
v_WRF_MIN NUMBER := 999999;
v_WRF_MAX NUMBER := -999999;
v_ALPHA GA.NUMBER_TABLE;
v_BETA GA.NUMBER_TABLE;
v_CONSUMPTION_CODE CHAR(1) := NVL(MODEL_VALUE_AT_KEY(0,'Position and Billing','Consumption Code','Final',0),'A');
v_STATUS NUMBER;
v_PROFILE_ID NUMBER;
v_ACCOUNT_USAGE_WRF_COUNT NUMBER(9);
v_PROGRESS_RANGE_IDX PLS_INTEGER;

CURSOR /*+ ORDERED */ c_ACCOUNT_BASE_LOAD IS
	SELECT A.ACCOUNT_ID, B.BEGIN_DATE, B.END_DATE, B.BILLED_USAGE, C.BASE_LOAD_BEGIN_DATE "BASE_LOAD_BEGIN_DATE", C.BASE_LOAD_END_DATE "BASE_LOAD_END_DATE"
	FROM ACCOUNT_USAGE_WRF A,
         ACCOUNT_SERVICE D,
         SERVICE E,
         SERVICE_CONSUMPTION B,
         USAGE_WRF_SEASON C,
		 SEASON_DATES F
	WHERE A.WRF_ID = p_WRF_ID
		AND A.BEGIN_DATE <= p_END_DATE
		AND NVL(A.END_DATE, p_END_DATE) >= p_BEGIN_DATE
        AND D.ACCOUNT_ID = A.ACCOUNT_ID    --Get service_consumption records for the account thru account_service
        AND E.MODEL_ID = p_MODEL_ID
        AND E.ACCOUNT_SERVICE_ID = D.ACCOUNT_SERVICE_ID
		AND B.SERVICE_ID = E.SERVICE_ID
		AND B.BILL_CODE = 'B'
		AND B.CONSUMPTION_CODE IN (v_CONSUMPTION_CODE,'H')
		AND B.BEGIN_DATE <= p_END_DATE  -- Meter read TOUCHES date range.
		AND B.END_DATE >= p_BEGIN_DATE  -- Meter read TOUCHES date range.
		AND C.WRF_ID = A.WRF_ID  --join
		AND C.WRF_ID = p_WRF_ID  --specify for speed
		AND C.TEMPLATE_ID = p_TEMPLATE_ID
		AND C.BASE_LOAD_TEMPLATE_ID = p_BASE_LOAD_TEMPLATE_ID
		AND C.AS_OF_DATE = p_OUTPUT_AS_OF_DATE
		--Replace fxn: AND SEASON_INTERSECTS_SEASON(B.BEGIN_DATE, B.END_DATE, C.BASE_LOAD_BEGIN_DATE, C.BASE_LOAD_END_DATE) = 'Y'
		AND F.SEASON_ID = C.BASE_LOAD_SEASON_ID
        AND B.BEGIN_DATE  <= F.END_DATE
		AND B.END_DATE    >= F.BEGIN_DATE
		AND B.UNIT_OF_MEASUREMENT = GA.DEFAULT_UNIT_OF_MEASUREMENT
UNION ALL
	SELECT 9999999, LOW_DATE, LOW_DATE, 0, LOW_DATE, LOW_DATE FROM DUAL
	ORDER BY 1;

BEGIN
	-- clear out old entries first
	DELETE ACCOUNT_USAGE_WRF_LINE
	WHERE WRF_ID = p_WRF_ID
		AND TEMPLATE_ID = p_TEMPLATE_ID;

	PUT_USAGE_WRF_SEASON(p_WRF_ID, p_TEMPLATE_ID,p_BASE_LOAD_TEMPLATE_ID, p_OUTPUT_AS_OF_DATE);

	-- Get Progress count for the loop
	SELECT /*+ ORDERED */ COUNT(1) + 1
	INTO v_ACCOUNT_USAGE_WRF_COUNT
	FROM ACCOUNT_USAGE_WRF A,
         ACCOUNT_SERVICE D,
         SERVICE E,
         SERVICE_CONSUMPTION B,
         USAGE_WRF_SEASON C,
		 SEASON_DATES F
	WHERE A.WRF_ID = p_WRF_ID
		AND A.BEGIN_DATE <= p_END_DATE
		AND NVL(A.END_DATE, p_END_DATE) >= p_BEGIN_DATE
        AND D.ACCOUNT_ID = A.ACCOUNT_ID    --Get service_consumption records for the account thru account_service
        AND E.MODEL_ID = p_MODEL_ID
        AND E.ACCOUNT_SERVICE_ID = D.ACCOUNT_SERVICE_ID
		AND B.SERVICE_ID = E.SERVICE_ID
		AND B.BILL_CODE = 'B'
		AND B.CONSUMPTION_CODE IN (v_CONSUMPTION_CODE,'H')
		AND B.BEGIN_DATE <= p_END_DATE  -- Meter read TOUCHES date range.
		AND B.END_DATE >= p_BEGIN_DATE  -- Meter read TOUCHES date range.
		AND C.WRF_ID = A.WRF_ID  --join
		AND C.WRF_ID = p_WRF_ID  --specify for speed
		AND C.TEMPLATE_ID = p_TEMPLATE_ID
		AND C.BASE_LOAD_TEMPLATE_ID = p_BASE_LOAD_TEMPLATE_ID
		AND C.AS_OF_DATE = p_OUTPUT_AS_OF_DATE
		--Replace fxn: AND SEASON_INTERSECTS_SEASON(B.BEGIN_DATE, B.END_DATE, C.BASE_LOAD_BEGIN_DATE, C.BASE_LOAD_END_DATE) = 'Y'
		AND F.SEASON_ID = C.BASE_LOAD_SEASON_ID
        AND B.BEGIN_DATE  <= F.END_DATE
		AND B.END_DATE    >= F.BEGIN_DATE
		AND B.UNIT_OF_MEASUREMENT = GA.DEFAULT_UNIT_OF_MEASUREMENT;

	-- Update the Progress with a new range
	v_PROGRESS_RANGE_IDX := LOGS.PUSH_PROGRESS_RANGE(v_ACCOUNT_USAGE_WRF_COUNT);

	--Loop over Consumption records
	FOR v_ACCOUNT_BASE_LOAD IN c_ACCOUNT_BASE_LOAD LOOP

		IF v_INITIAL THEN
			v_ACCOUNT_ID := v_ACCOUNT_BASE_LOAD.ACCOUNT_ID;
			v_EVENT_TEXT := 'Begin Calculation for WRF_ID=' || TO_CHAR(p_WRF_ID) || ', TEMPLATE_ID=' || TO_CHAR(p_TEMPLATE_ID);
			LOGS.LOG_DEBUG(v_EVENT_TEXT);
			v_INITIAL := FALSE;
		END IF;

		IF v_ACCOUNT_ID <> v_ACCOUNT_BASE_LOAD.ACCOUNT_ID THEN
			--Account changed, or hit last record (9999999 in v_ACCOUNT_BASE_LOAD.ACCOUNT_ID )
            v_DAILY_BASE_LOAD := ROUND(v_TOTAL_BASE_LOAD/v_TOTAL_VALID_READ_DAYS,4);
			IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
				LOGS.LOG_DEBUG_DETAIL('ACCOUNT_ID =' || TO_CHAR(v_ACCOUNT_ID));
				LOGS.LOG_DEBUG_DETAIL('NUMBER OF BASE LOAD READS = ' || TO_CHAR(v_READ_COUNT));
				LOGS.LOG_DEBUG_DETAIL('ACTUAL DAILY BASE LOAD =' || TO_CHAR(v_DAILY_BASE_LOAD));
				LOGS.LOG_DEBUG_DETAIL('TOTAL VALID READ DAYS =' || TO_CHAR(v_TOTAL_VALID_READ_DAYS));
			END IF;

            IF p_TEMPLATE_ID = p_BASE_LOAD_TEMPLATE_ID THEN
				--Same Template as Base_Load
                v_COEFFICIENT := 0;
				v_OBSERVATIONS := v_READ_COUNT;
				IF v_READ_COUNT < g_ACCOUNT_USAGE_WRF_MIN_POINTS THEN
					v_DAILY_BASE_LOAD := p_DEFAULT_ALPHA;
					v_DEFAULT_ASSIGNMENTS := v_DEFAULT_ASSIGNMENTS+1;
				END IF;
			ELSE
				CALCULATE_ACCOUNT_COEFFICIENT(p_MODEL_ID,v_DAILY_BASE_LOAD,v_ACCOUNT_ID,p_WRF_ID,p_STATION_ID,p_PARAMETER_ID,p_TEMPLATE_ID,
					p_BEGIN_DATE,p_END_DATE,p_BASE_LOAD_TEMPLATE_ID,p_OUTPUT_AS_OF_DATE,v_COEFFICIENT,v_OBSERVATIONS,
					v_X_MIN,v_X_MAX,v_Y_MIN,v_Y_MAX,v_X_ZERO,v_Y_ZERO);
				IF v_OBSERVATIONS < g_ACCOUNT_USAGE_WRF_MIN_POINTS THEN
					--v_DAILY_BASE_LOAD := p_DEFAULT_ALPHA;
					v_COEFFICIENT := p_DEFAULT_BETA;
					v_DEFAULT_ASSIGNMENTS := v_DEFAULT_ASSIGNMENTS+1;
				END IF;
			END IF;

            IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
				LOGS.LOG_DEBUG_DETAIL('NUMBER OF OBSERVATIONS = ' || TO_CHAR(v_OBSERVATIONS));
				LOGS.LOG_DEBUG_DETAIL('POSTED DAILY BASE LOAD =' || TO_CHAR(v_DAILY_BASE_LOAD));
				LOGS.LOG_DEBUG_DETAIL('POSTED COEFFICIENT =' || TO_CHAR(v_COEFFICIENT));
			END IF;

            --Put the USAGE_WRF_LINE
            PUT_ACCOUNT_BASE_LOAD_LINE(v_ACCOUNT_ID,p_WRF_ID, p_TEMPLATE_ID, p_BASE_LOAD_TEMPLATE_ID, NVL(v_DAILY_BASE_LOAD,0),NVL(v_OBSERVATIONS,0),NVL(v_COEFFICIENT,0),
					v_X_MIN,v_X_MAX,v_Y_MIN,v_Y_MAX,v_X_ZERO,v_Y_ZERO,p_OUTPUT_AS_OF_DATE);

			--Create Usage WRF Profile and Library, assign Lib and Acct to Calendar, return v_PROFILE_ID
            CREATE_USAGE_WRF_PROFILE(v_ACCOUNT_ID, p_STATION_ID, p_PARAMETER_ID, p_TEMPLATE_ID, p_WRF_ID, p_BEGIN_DATE, p_END_DATE, p_OUTPUT_AS_OF_DATE, v_PROFILE_ID, v_STATUS);

            --Set the nulls to zero and include them in the calculation - 03/31/03
            v_WRF_MIN := LEAST(NVL(v_DAILY_BASE_LOAD, 0) + NVL(v_COEFFICIENT,0) * NVL(v_X_MIN, 0), NVL(v_WRF_MIN, 0));
            v_WRF_MAX := GREATEST(NVL(v_DAILY_BASE_LOAD, 0) + NVL(v_COEFFICIENT,0) * NVL(v_X_MAX, 0), NVL(v_WRF_MAX, 0));

            v_ALPHA(v_ALPHA.COUNT+1) := v_DAILY_BASE_LOAD;
			v_BETA(v_BETA.COUNT+1) := NVL(v_COEFFICIENT,0);
			v_COUNT := v_COUNT+1;
			v_ACCOUNT_COUNT := v_ACCOUNT_COUNT + 1;

            --Put Statistics
        	PUT_LOAD_PROFILE_STATISTICS (v_PROFILE_ID, GET_PROFILE_VERSION_ID(p_OUTPUT_AS_OF_DATE),
            	p_OUTPUT_AS_OF_DATE, p_BEGIN_DATE, p_END_DATE, v_COUNT, 0.0,
                v_WRF_MIN, v_WRF_MIN, v_WRF_MAX, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 'Pending', v_STATUS);

			v_OBSERVATIONS := 0;
			v_READ_COUNT := 0;
			v_DAILY_BASE_LOAD:= 0;
			v_TOTAL_BASE_LOAD := 0;
			v_AVERAGE_DAILY_USAGE := 0;
			v_TOTAL_VALID_READ_DAYS := 0;
			v_VALID_BASE_LOAD := 0;
			v_VALID_READ_DAYS := 0;
			v_X_MIN := 0;
			--v_Y_MIN := 0;
			--v_X_MAX := 0;
			v_Y_MAX := 0;
			v_X_ZERO := 0;
			v_Y_ZERO := 0;

			IF v_ACCOUNT_BASE_LOAD.ACCOUNT_ID = 9999999 THEN
				EXIT;
			END IF;
		END IF;

 		ALIGN_BILL_PERIOD_TO_SEASON
 			(
 			v_ACCOUNT_BASE_LOAD.BASE_LOAD_BEGIN_DATE,
 			v_ACCOUNT_BASE_LOAD.BASE_LOAD_END_DATE,
 			v_ACCOUNT_BASE_LOAD.BEGIN_DATE,
 			v_ACCOUNT_BASE_LOAD.END_DATE,
 			v_BEGIN_DATE,
 			v_END_DATE
 			);

		--determine the number of read days in the base load season
		v_VALID_READ_DAYS := GREATEST(v_END_DATE-v_BEGIN_DATE+1,1);
		--get average daily usage value for read period
		v_DAYS := GREATEST((v_ACCOUNT_BASE_LOAD.END_DATE - v_ACCOUNT_BASE_LOAD.BEGIN_DATE) + 1,1);
		IF v_DAYS > 0 THEN
			v_AVERAGE_DAILY_USAGE := ROUND(v_ACCOUNT_BASE_LOAD.BILLED_USAGE / v_DAYS, 4);
		ELSE
			v_AVERAGE_DAILY_USAGE := 0;
		END IF;

		--calculate base load contribution
		v_VALID_BASE_LOAD := v_AVERAGE_DAILY_USAGE*v_VALID_READ_DAYS;

		--accumulate the valid read days, average usage combination
		v_TOTAL_BASE_LOAD := v_TOTAL_BASE_LOAD+v_VALID_BASE_LOAD;
		v_TOTAL_VALID_READ_DAYS := v_TOTAL_VALID_READ_DAYS + v_VALID_READ_DAYS;

		v_ACCOUNT_ID := v_ACCOUNT_BASE_LOAD.ACCOUNT_ID;
		v_READ_COUNT := v_READ_COUNT+1;

		LOGS.INCREMENT_PROCESS_PROGRESS(p_RANGE_INDEX => v_PROGRESS_RANGE_IDX);
	END LOOP;
	LOGS.POP_PROGRESS_RANGE(v_PROGRESS_RANGE_IDX);

    IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
		LOGS.LOG_DEBUG_DETAIL('DEFAULT ASSIGNMENTS = '|| TO_CHAR(v_DEFAULT_ASSIGNMENTS));
		LOGS.LOG_DEBUG_DETAIL('WRF MIN =' || TO_CHAR(v_WRF_MIN));
		LOGS.LOG_DEBUG_DETAIL('WRF MAX =' || TO_CHAR(v_WRF_MAX));
	END IF;
	IF v_COUNT > 0 THEN
		COMPUTE_USAGE_WRF_STATISTICS(p_WRF_ID, p_TEMPLATE_ID, g_DEFAULT_SEGMENT, p_BEGIN_DATE, p_END_DATE, p_OUTPUT_AS_OF_DATE,
			v_DEFAULT_ASSIGNMENTS, v_WRF_MIN, v_WRF_MAX, 0, 0, v_ALPHA, v_BETA);
		IF g_ALLOW_COMMIT_ROLLBACK THEN COMMIT; END IF;
	END IF;

	v_EVENT_TEXT := 'Usage WRF Statistics Calculated for WRF_ID=' || TO_CHAR(p_WRF_ID) || ', TEMPLATE_ID=' || TO_CHAR(p_TEMPLATE_ID);
	LOGS.LOG_DEBUG(v_EVENT_TEXT);

	v_EVENT_TEXT := 'Total ACCOUNT Usage WRF Profiles Calculated:  ' || TO_CHAR(v_ACCOUNT_COUNT);
	LOGS.LOG_DEBUG(v_EVENT_TEXT);

END APPLY_ACCOUNT_USAGE_WRF_BASE;
----------------------------------------------------------------------------------------------------
PROCEDURE USAGE_WRF_REQUEST_BASE
	(
	p_PROCESS_ID IN NUMBER,
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_BASE_LOAD_TEMPLATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_REQUESTOR IN VARCHAR,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS
BEGIN
	USAGE_WRF_REQUEST_ENTITY(NULL, -- MODEL_ID
							 c_ENTITY_TYPE_CUSTOMER,
							 p_PROCESS_ID,
							 p_WRF_ID,
							 p_TEMPLATE_ID,
							 p_BASE_LOAD_TEMPLATE_ID,
							 p_BEGIN_DATE,
							 p_END_DATE,
							 p_INPUT_AS_OF_DATE,
							 p_OUTPUT_AS_OF_DATE,
							 p_REQUESTOR,
							 NULL, -- ACCT_CALENDAR_BEGIN_DATE
							 p_TRACE_ON,
							 p_STATUS,
							 p_MESSAGE);
END USAGE_WRF_REQUEST_BASE;
---------------------------------------------------------------------------------------------------
PROCEDURE USAGE_WRF_REQUEST_BASE
	(
	p_PROCESS_ID IN NUMBER,
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_BASE_LOAD_TEMPLATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_REQUESTOR IN VARCHAR,
	p_TRACE_ON IN NUMBER
	) AS

v_STATUS NUMBER;
v_MESSAGE VARCHAR(128);

BEGIN

	USAGE_WRF_REQUEST_BASE(p_PROCESS_ID, p_WRF_ID, p_TEMPLATE_ID,p_BASE_LOAD_TEMPLATE_ID, p_BEGIN_DATE, p_END_DATE, p_INPUT_AS_OF_DATE, p_OUTPUT_AS_OF_DATE, p_REQUESTOR, p_TRACE_ON, v_STATUS, v_MESSAGE);

END USAGE_WRF_REQUEST_BASE;
---------------------------------------------------------------------------------------------------
PROCEDURE RUN_USAGE_WRF_REQUEST_BASE
	(
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_BASE_LOAD_TEMPLATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_SCHEDULE_RUN IN NUMBER,
	p_RUN_AT IN DATE,
	p_REQUESTOR IN VARCHAR,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

-- Run a Usage WRF Request.  Supercedes RUN_USAGE_WRF_REQUEST at Version 2.1, to include Base Load Template.

v_JOB_NAME VARCHAR2(64);
v_WHAT VARCHAR(512);

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK';

	IF p_SCHEDULE_RUN = 1 THEN

		v_WHAT := 'PF.USAGE_WRF_REQUEST_BASE( NULL,'
			|| TO_CHAR(p_WRF_ID) || ','
			|| TO_CHAR(p_TEMPLATE_ID) || ','
			|| TO_CHAR(p_BASE_LOAD_TEMPLATE_ID) || ','
			|| 'TO_DATE(''' || TO_CHAR(p_BEGIN_DATE, 'DD-MON-YYYY') || ''',''DD-MON-YYYY''),'
			|| 'TO_DATE(''' || TO_CHAR(p_END_DATE, 'DD-MON-YYYY') || ''',''DD-MON-YYYY''),'
			|| 'TO_DATE(''' || TO_CHAR(p_INPUT_AS_OF_DATE, 'DD-MON-YYYY HH24:MI:SS') || ''',''DD-MON-YYYY HH24:MI:SS''),'
			|| 'TO_DATE(''' || TO_CHAR(p_OUTPUT_AS_OF_DATE, 'DD-MON-YYYY HH24:MI:SS') || ''',''DD-MON-YYYY HH24:MI:SS''),'
			|| '''' || p_REQUESTOR || ''',' || TO_CHAR(p_TRACE_ON) || ');' ;
		IF LOGS.IS_DEBUG_ENABLED THEN
    		LOGS.LOG_DEBUG('SCHEDULE WRF_USAGE_REQUEST_BASE TO RUN AT= ' || TEXT_UTIL.TO_CHAR_DATE(p_RUN_AT));
    		LOGS.LOG_DEBUG('WHAT=' || v_WHAT);
		END IF;
		v_JOB_NAME := START_BACKGROUND_JOB(v_WHAT, p_RUN_AT);
	ELSE
		USAGE_WRF_REQUEST_BASE(NULL, p_WRF_ID, p_TEMPLATE_ID,p_BASE_LOAD_TEMPLATE_ID, p_BEGIN_DATE, p_END_DATE, p_INPUT_AS_OF_DATE, p_OUTPUT_AS_OF_DATE, p_REQUESTOR, p_TRACE_ON, p_STATUS, p_MESSAGE);
	END IF;

END RUN_USAGE_WRF_REQUEST_BASE;
---------------------------------------------------------------------------------------------------
PROCEDURE USAGE_WRF_REQUEST_ENTITY
	(
	p_MODEL_ID IN NUMBER,
	p_ENTITY_TYPE IN VARCHAR,
	p_PROCESS_ID IN NUMBER,
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_BASE_LOAD_TEMPLATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_REQUESTOR IN VARCHAR,
	p_ACCT_CALENDAR_BEGIN_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

-- Run a Usage WRF Request.  Supercedes USAGE_WRF_REQUEST_BASE at Version 2.3, to include Accounts as well as Customers.

v_PROGRESS_COUNT NUMBER(9);
v_AS_OF_DATE DATE;

CURSOR c_WRF IS
	SELECT A.WRF_ID, A.STATION_ID, A.PARAMETER_ID, B.TEMPLATE_ID, B.BASE_LOAD_TEMPLATE_ID,B.ALPHA, B.BETA
	FROM USAGE_WRF A, USAGE_WRF_TEMPLATE B
	WHERE A.WRF_ID = DECODE(p_WRF_ID, CONSTANTS.ALL_ID, A.WRF_ID, p_WRF_ID)
		AND B.WRF_ID = A.WRF_ID
		AND B.TEMPLATE_ID = DECODE(p_TEMPLATE_ID, CONSTANTS.ALL_ID, B.TEMPLATE_ID, p_TEMPLATE_ID)
		AND B.BASE_LOAD_TEMPLATE_ID = DECODE(p_BASE_LOAD_TEMPLATE_ID, CONSTANTS.ALL_ID, B.BASE_LOAD_TEMPLATE_ID, p_BASE_LOAD_TEMPLATE_ID);

BEGIN

	-- Setup global so that account calendar is assigned correctly
	IF UPPER(SUBSTR(p_ENTITY_TYPE,1,1)) = c_ENTITY_TYPE_CUSTOMER THEN
		g_ACCT_CALENDAR_BEGIN_DATE := NULL;
	ELSE      -- UPPER(SUBSTR(p_ENTITY_TYPE,1,1)) = 'A'
		g_ACCT_CALENDAR_BEGIN_DATE := p_ACCT_CALENDAR_BEGIN_DATE;
	END IF;

	-- Now calculate the WRFs
	IF p_BASE_LOAD_TEMPLATE_ID IS NULL OR p_BASE_LOAD_TEMPLATE_ID = 0 THEN
		USAGE_WRF_REQUEST(p_MODEL_ID, p_ENTITY_TYPE, p_PROCESS_ID, p_WRF_ID, p_TEMPLATE_ID, p_BEGIN_DATE, p_END_DATE, p_INPUT_AS_OF_DATE, p_OUTPUT_AS_OF_DATE, p_REQUESTOR, p_TRACE_ON, p_STATUS, p_MESSAGE);
	ELSE
		BEGIN
			LOGS.START_PROCESS('Calculate Base Load Usage WRFs',
							   p_BEGIN_DATE,
							   p_END_DATE,
							   p_EVENT_LEVEL => CASE WHEN p_TRACE_ON > 0 THEN LOGS.c_LEVEL_DEBUG_MORE_DETAIL ELSE NULL END);

			LOGS.SET_PROCESS_TARGET_PARAMETER('WRF_ID', TO_CHAR(p_WRF_ID));
			LOGS.SET_PROCESS_TARGET_PARAMETER('TEMPLATE_ID', TO_CHAR(p_TEMPLATE_ID));
			LOGS.SET_PROCESS_TARGET_PARAMETER('BASE_LOAD_TEMPLATE_ID', TO_CHAR(p_BASE_LOAD_TEMPLATE_ID));
			LOGS.SET_PROCESS_TARGET_PARAMETER('INPUT_AS_OF_DATE', TEXT_UTIL.TO_CHAR_DATE(p_INPUT_AS_OF_DATE));
			LOGS.SET_PROCESS_TARGET_PARAMETER('OUTPUT_AS_OF_DATE', TEXT_UTIL.TO_CHAR_DATE(p_OUTPUT_AS_OF_DATE));
			LOGS.SET_PROCESS_TARGET_PARAMETER('REQUESTOR', TO_CHAR(p_REQUESTOR));
			LOGS.SET_PROCESS_TARGET_PARAMETER('ACCT_CALENDAR_BEGIN_DATE', TEXT_UTIL.TO_CHAR_DATE(p_ACCT_CALENDAR_BEGIN_DATE));

			UPDATE USAGE_WRF_TEMPLATE
			SET
				BASE_LOAD_TEMPLATE_ID = p_BASE_LOAD_TEMPLATE_ID,
				ENTRY_DATE = SYSDATE
			WHERE
				WRF_ID = DECODE(p_WRF_ID, CONSTANTS.ALL_ID, WRF_ID, p_WRF_ID) AND
				TEMPLATE_ID = DECODE(p_TEMPLATE_ID, CONSTANTS.ALL_ID, TEMPLATE_ID, p_TEMPLATE_ID);

			IF GA.VERSION_PROFILE THEN
				v_AS_OF_DATE := p_OUTPUT_AS_OF_DATE;
			ELSE
				v_AS_OF_DATE := LOW_DATE;
			END IF;

			SELECT COUNT(1)
			INTO v_PROGRESS_COUNT
			FROM USAGE_WRF A, USAGE_WRF_TEMPLATE B
			WHERE A.WRF_ID = DECODE(p_WRF_ID, CONSTANTS.ALL_ID, A.WRF_ID, p_WRF_ID)
				AND B.WRF_ID = A.WRF_ID
				AND B.TEMPLATE_ID = DECODE(p_TEMPLATE_ID, CONSTANTS.ALL_ID, B.TEMPLATE_ID, p_TEMPLATE_ID)
				AND B.BASE_LOAD_TEMPLATE_ID = DECODE(p_BASE_LOAD_TEMPLATE_ID, CONSTANTS.ALL_ID, B.BASE_LOAD_TEMPLATE_ID, p_BASE_LOAD_TEMPLATE_ID);

			LOGS.INIT_PROCESS_PROGRESS(p_TOTAL_WORK => v_PROGRESS_COUNT, p_CAN_TERMINATE => TRUE);

			FOR v_WRF IN c_WRF LOOP

				IF LOGS.IS_DEBUG_ENABLED THEN
					LOGS.LOG_DEBUG('WRF_ID=' || TO_CHAR(v_WRF.WRF_ID));
					LOGS.LOG_DEBUG('STATION_ID=' || TO_CHAR(v_WRF.STATION_ID));
					LOGS.LOG_DEBUG('PARAMETER_ID=' || TO_CHAR(v_WRF.PARAMETER_ID));
					LOGS.LOG_DEBUG('TEMPLATE_ID=' || TO_CHAR(v_WRF.TEMPLATE_ID));
					LOGS.LOG_DEBUG('BASE_LOAD_TEMPLATE_ID=' || TO_CHAR(v_WRF.BASE_LOAD_TEMPLATE_ID));
					LOGS.LOG_DEBUG('DEFAULT ALPHA=' || TO_CHAR(v_WRF.ALPHA));
					LOGS.LOG_DEBUG('DEFAULT BETA=' || TO_CHAR(v_WRF.BETA));
					LOGS.LOG_DEBUG('<customer id>,<wrf id>,<season id>,<segment nbr>,<as of>,<alpha>,<beta>,<r2>,<n>,<x min>,<x max>,<y min>,<y max>,<x zero>,<y zero>');
				END IF;

				IF UPPER(SUBSTR(p_ENTITY_TYPE,1,1)) = c_ENTITY_TYPE_CUSTOMER THEN	--Customer
					APPLY_CUSTOMER_USAGE_WRF_BASE(v_WRF.WRF_ID, v_WRF.STATION_ID, v_WRF.PARAMETER_ID, v_WRF.TEMPLATE_ID,v_WRF.BASE_LOAD_TEMPLATE_ID, p_BEGIN_DATE, p_END_DATE, v_AS_OF_DATE, v_WRF.ALPHA, v_WRF.BETA);
				ELSE      -- UPPER(SUBSTR(p_ENTITY_TYPE,1,1)) = 'A' THEN	--Account
					APPLY_ACCOUNT_USAGE_WRF_BASE(p_MODEL_ID, v_WRF.WRF_ID, v_WRF.STATION_ID, v_WRF.PARAMETER_ID, v_WRF.TEMPLATE_ID,v_WRF.BASE_LOAD_TEMPLATE_ID, p_BEGIN_DATE, p_END_DATE, v_AS_OF_DATE, v_WRF.ALPHA, v_WRF.BETA);
				END IF;

				LOGS.INCREMENT_PROCESS_PROGRESS();

			END LOOP;

			LOGS.STOP_PROCESS(p_MESSAGE, p_STATUS);
			COMMIT;

		EXCEPTION
			WHEN OTHERS THEN
				g_ACCT_CALENDAR_BEGIN_DATE := NULL; -- don't forget to clean this up
				ERRS.ABORT_PROCESS;
		END;
	END IF;

	-- done, so reset this global since it should only apply to the request that just completed
	g_ACCT_CALENDAR_BEGIN_DATE := NULL;

END USAGE_WRF_REQUEST_ENTITY;
---------------------------------------------------------------------------------------------------
PROCEDURE USAGE_WRF_REQUEST_ENTITY
	(
	p_MODEL_ID IN NUMBER,
	p_ENTITY_TYPE IN VARCHAR,
	p_PROCESS_ID IN NUMBER,
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_BASE_LOAD_TEMPLATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_REQUESTOR IN VARCHAR,
	p_ACCT_CALENDAR_BEGIN_DATE IN DATE,
	p_TRACE_ON IN NUMBER
	) AS

-- Run a Usage WRF Request from DBMS_JOB.SUBMIT without p_STATUS or p_MESSAGE output params.


v_STATUS NUMBER;
v_MESSAGE VARCHAR(256);

BEGIN

	USAGE_WRF_REQUEST_ENTITY(p_MODEL_ID, p_ENTITY_TYPE, p_PROCESS_ID, p_WRF_ID, p_TEMPLATE_ID,p_BASE_LOAD_TEMPLATE_ID, p_BEGIN_DATE, p_END_DATE, p_INPUT_AS_OF_DATE, p_OUTPUT_AS_OF_DATE, p_REQUESTOR, p_ACCT_CALENDAR_BEGIN_DATE, p_TRACE_ON, v_STATUS, v_MESSAGE);

END USAGE_WRF_REQUEST_ENTITY;
---------------------------------------------------------------------------------------------------
PROCEDURE RUN_USAGE_WRF_REQUEST_ENTITY
	(
	p_MODEL_ID IN NUMBER,
	p_ENTITY_TYPE IN VARCHAR,
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_BASE_LOAD_TEMPLATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_SCHEDULE_RUN IN NUMBER,
	p_RUN_AT IN DATE,
	p_REQUESTOR IN VARCHAR,
	p_ACCT_CALENDAR_BEGIN_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

-- Run a Usage WRF Request.  Supercedes RUN_USAGE_WRF_REQUEST_BASE at Version 2.3, to include Accounts as well as Customers.

v_JOB_NAME VARCHAR2(64);
v_WHAT VARCHAR(512);
v_MIN_POINTS_STRING VARCHAR(4);

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK';

	GET_MODEL_VALUE_AT_KEY(p_MODEL_ID, 'Profiling_Usage', 'Account Usage WRF', 'Minimum_Points', 0, v_MIN_POINTS_STRING);
    --Set Min Points global from SYSTEM_DICTIONARY, use default if not found
    g_ACCOUNT_USAGE_WRF_MIN_POINTS := TO_NUMBER( NVL( v_MIN_POINTS_STRING, g_ACCOUNT_USAGE_WRF_MIN_POINTS));

	IF p_SCHEDULE_RUN = 1 THEN

		v_WHAT := 'PF.USAGE_WRF_REQUEST_ENTITY(' || TO_CHAR(p_MODEL_ID) || ','
			|| '''' || p_ENTITY_TYPE || ''','
			|| 'NULL,'
			|| TO_CHAR(p_WRF_ID) || ','
			|| TO_CHAR(p_TEMPLATE_ID) || ','
			|| TO_CHAR(p_BASE_LOAD_TEMPLATE_ID) || ','
			|| 'TO_DATE(''' || TO_CHAR(p_BEGIN_DATE, 'DD-MON-YYYY') || ''',''DD-MON-YYYY''),'
			|| 'TO_DATE(''' || TO_CHAR(p_END_DATE, 'DD-MON-YYYY') || ''',''DD-MON-YYYY''),'
			|| 'TO_DATE(''' || TO_CHAR(p_INPUT_AS_OF_DATE, 'DD-MON-YYYY HH24:MI:SS') || ''',''DD-MON-YYYY HH24:MI:SS''),'
			|| 'TO_DATE(''' || TO_CHAR(p_OUTPUT_AS_OF_DATE, 'DD-MON-YYYY HH24:MI:SS') || ''',''DD-MON-YYYY HH24:MI:SS''),'
			|| '''' || p_REQUESTOR || ''','
			|| 'TO_DATE(''' || TO_CHAR(p_ACCT_CALENDAR_BEGIN_DATE, 'DD-MON-YYYY') || ''',''DD-MON-YYYY''),'
            || TO_CHAR(p_TRACE_ON) || ');' ;
		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG('SCHEDULE WRF_USAGE_REQUEST_ENTITY TO RUN AT= ' || TEXT_UTIL.TO_CHAR_DATE(p_RUN_AT));
    		LOGS.LOG_DEBUG('WHAT=' || v_WHAT);
		END IF;
		v_JOB_NAME := START_BACKGROUND_JOB(v_WHAT, p_RUN_AT);

	ELSE
		USAGE_WRF_REQUEST_ENTITY(p_MODEL_ID, p_ENTITY_TYPE, NULL, p_WRF_ID, p_TEMPLATE_ID,p_BASE_LOAD_TEMPLATE_ID, p_BEGIN_DATE, p_END_DATE, p_INPUT_AS_OF_DATE, p_OUTPUT_AS_OF_DATE, p_REQUESTOR, p_ACCT_CALENDAR_BEGIN_DATE, p_TRACE_ON, p_STATUS, p_MESSAGE);
	END IF;

END RUN_USAGE_WRF_REQUEST_ENTITY;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_TEMPLATE_LIST
	(
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	OPEN p_CURSOR FOR
	SELECT
		TEMPLATE_NAME "ENTITY_NAME",
		TEMPLATE_ID "ENTITY_ID"
	FROM TEMPLATE;


END GET_TEMPLATE_LIST;
-----------------------------------------------------------------------------------
PROCEDURE UPDATE_CUSTOMER_USAGE_WRF_BASE
	(
	p_CUSTOMER_ID IN NUMBER,
	p_WRF_ID IN NUMBER,
	p_STATION_ID IN NUMBER,
	p_PARAMETER_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_BASE_LOAD_TEMPLATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_DEFAULT_ALPHA IN NUMBER,
	p_DEFAULT_BETA IN NUMBER
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_DAYS NUMBER;
v_COEFFICIENT  NUMBER := 0;
v_OBSERVATIONS NUMBER := 0;
v_INITIAL BOOLEAN := TRUE;
v_CUSTOMER_ID NUMBER := CONSTANTS.NOT_ASSIGNED;
v_CUSTOMER_COUNT NUMBER := 0;
v_READ_COUNT NUMBER := 0;
v_VALID_READ_DAYS PLS_INTEGER := 0;
v_TOTAL_VALID_READ_DAYS NUMBER := 0;
v_EVENT_TEXT PROCESS_LOG_EVENT.EVENT_TEXT%TYPE;
v_VALID_BASE_LOAD NUMBER := 0;
v_TOTAL_BASE_LOAD NUMBER := 0;
v_AVERAGE_DAILY_USAGE NUMBER := 0;
v_DAILY_BASE_LOAD NUMBER := 0;
v_X_MIN NUMBER := 0;
v_X_MAX NUMBER := 0;
v_Y_MIN NUMBER := 0;
v_Y_MAX NUMBER := 0;
v_X_ZERO NUMBER := 0;
v_Y_ZERO NUMBER := 0;
v_COUNT PLS_INTEGER := 0;
v_DEFAULT_ASSIGNMENTS NUMBER := 0;
v_WRF_MIN NUMBER := 999999;
v_WRF_MAX NUMBER := -999999;
v_ALPHA GA.NUMBER_TABLE;
v_BETA GA.NUMBER_TABLE;
v_CONSUMPTION_CODE CHAR(1) := NVL(MODEL_VALUE_AT_KEY(0,'Position and Billing','Consumption Code','Final',0),'A');

CURSOR c_CUSTOMER_BASE_LOAD IS
	SELECT A.CUSTOMER_ID, B.BEGIN_DATE, B.END_DATE, B.BILLED_USAGE, C.BASE_LOAD_BEGIN_DATE "BASE_LOAD_BEGIN_DATE", C.BASE_LOAD_END_DATE "BASE_LOAD_END_DATE"
	FROM CUSTOMER_USAGE_WRF A, CUSTOMER_CONSUMPTION B, USAGE_WRF_SEASON C, SEASON_DATES F
	WHERE A.CUSTOMER_ID = p_CUSTOMER_ID
		AND A.WRF_ID = p_WRF_ID
		AND A.BEGIN_DATE <= p_END_DATE
		AND NVL(A.END_DATE, p_END_DATE) >= p_BEGIN_DATE
		AND B.CUSTOMER_ID = A.CUSTOMER_ID
		AND B.BILL_CODE = 'B'
		AND B.CONSUMPTION_CODE = v_CONSUMPTION_CODE
		AND B.BEGIN_DATE <= p_END_DATE  -- Meter read TOUCHES date range.
		AND B.END_DATE >= p_BEGIN_DATE  -- Meter read TOUCHES date range.
		AND C.WRF_ID = A.WRF_ID  --join
		AND C.WRF_ID = p_WRF_ID  --specify for speed
		AND C.TEMPLATE_ID = p_TEMPLATE_ID
		AND C.BASE_LOAD_TEMPLATE_ID = p_BASE_LOAD_TEMPLATE_ID
		AND C.AS_OF_DATE = p_OUTPUT_AS_OF_DATE
		AND F.SEASON_ID = C.BASE_LOAD_SEASON_ID
        AND B.BEGIN_DATE  <= F.END_DATE
		AND B.END_DATE    >= F.BEGIN_DATE
UNION ALL
	SELECT 9999999, LOW_DATE, LOW_DATE, 0, LOW_DATE, LOW_DATE FROM DUAL
	ORDER BY 1;

BEGIN

	LOGS.LOG_DEBUG_DETAIL('BEGIN UPDATE_CUSTOMER_USAGE_WRF_BASE');

	PUT_USAGE_WRF_SEASON(p_WRF_ID, p_TEMPLATE_ID,p_BASE_LOAD_TEMPLATE_ID, p_OUTPUT_AS_OF_DATE);

	FOR v_CUSTOMER_BASE_LOAD IN c_CUSTOMER_BASE_LOAD LOOP

		IF v_INITIAL THEN
			v_CUSTOMER_ID := v_CUSTOMER_BASE_LOAD.CUSTOMER_ID;
			v_EVENT_TEXT := 'Begin Calculation for WRF_ID=' || TO_CHAR(p_WRF_ID) || ', TEMPLATE_ID=' || TO_CHAR(p_TEMPLATE_ID);
			LOGS.LOG_DEBUG(v_EVENT_TEXT);
			v_INITIAL := FALSE;
		END IF;

		IF v_CUSTOMER_ID <> v_CUSTOMER_BASE_LOAD.CUSTOMER_ID THEN
			v_DAILY_BASE_LOAD := ROUND(v_TOTAL_BASE_LOAD/v_TOTAL_VALID_READ_DAYS,4);
			IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
				LOGS.LOG_DEBUG_DETAIL('CUSTOMER_ID =' || TO_CHAR(v_CUSTOMER_ID));
				LOGS.LOG_DEBUG_DETAIL('NUMBER OF BASE LOAD READS = ' || TO_CHAR(v_READ_COUNT));
				LOGS.LOG_DEBUG_DETAIL('ACTUAL DAILY BASE LOAD =' || TO_CHAR(v_DAILY_BASE_LOAD));
				LOGS.LOG_DEBUG_DETAIL('TOTAL VALID READ DAYS =' || TO_CHAR(v_TOTAL_VALID_READ_DAYS));
			END IF;
			IF p_TEMPLATE_ID = p_BASE_LOAD_TEMPLATE_ID THEN
				v_COEFFICIENT := 0;
				v_OBSERVATIONS := v_READ_COUNT;
				IF v_READ_COUNT < GA.CUSTOMER_USAGE_WRF_MIN_POINTS THEN
					v_DAILY_BASE_LOAD := p_DEFAULT_ALPHA;
					v_DEFAULT_ASSIGNMENTS := v_DEFAULT_ASSIGNMENTS+1;
				END IF;
			ELSE
				CALCULATE_COEFFICIENT(v_DAILY_BASE_LOAD,v_CUSTOMER_ID,p_WRF_ID,p_STATION_ID,p_PARAMETER_ID,p_TEMPLATE_ID,
					p_BEGIN_DATE,p_END_DATE,p_BASE_LOAD_TEMPLATE_ID,p_OUTPUT_AS_OF_DATE,v_COEFFICIENT,v_OBSERVATIONS,
					v_X_MIN,v_X_MAX,v_Y_MIN,v_Y_MAX,v_X_ZERO,v_Y_ZERO);
				IF v_OBSERVATIONS < GA.CUSTOMER_USAGE_WRF_MIN_POINTS THEN
					--v_DAILY_BASE_LOAD := p_DEFAULT_ALPHA;
					v_COEFFICIENT := p_DEFAULT_BETA;
					v_DEFAULT_ASSIGNMENTS := v_DEFAULT_ASSIGNMENTS+1;
				END IF;
			END IF;
			IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
				LOGS.LOG_DEBUG_DETAIL('NUMBER OF OBSERVATIONS = ' || TO_CHAR(v_OBSERVATIONS));
				LOGS.LOG_DEBUG_DETAIL('POSTED DAILY BASE LOAD =' || TO_CHAR(v_DAILY_BASE_LOAD));
				LOGS.LOG_DEBUG_DETAIL('POSTED COEFFICIENT =' || TO_CHAR(v_COEFFICIENT));
			END IF;
			PUT_CUSTOMER_BASE_LOAD_LINE(v_CUSTOMER_ID,p_WRF_ID, p_TEMPLATE_ID, p_BASE_LOAD_TEMPLATE_ID, NVL(v_DAILY_BASE_LOAD,0),NVL(v_OBSERVATIONS,0),NVL(v_COEFFICIENT,0),
					v_X_MIN,v_X_MAX,v_Y_MIN,v_Y_MAX,v_X_ZERO,v_Y_ZERO,p_OUTPUT_AS_OF_DATE);
			--Set the nulls to zero and include them in the calculation - 03/31/03
            v_WRF_MIN := LEAST(NVL(v_DAILY_BASE_LOAD, 0) + NVL(v_COEFFICIENT,0) * NVL(v_X_MIN, 0), NVL(v_WRF_MIN, 0));
            v_WRF_MAX := GREATEST(NVL(v_DAILY_BASE_LOAD, 0) + NVL(v_COEFFICIENT,0) * NVL(v_X_MAX, 0), NVL(v_WRF_MAX, 0));

			v_ALPHA(v_ALPHA.COUNT+1) := v_DAILY_BASE_LOAD;
			v_BETA(v_BETA.COUNT+1) := v_COEFFICIENT;
			v_COUNT := v_COUNT+1;
			v_OBSERVATIONS := 0;
			v_READ_COUNT := 0;
			v_CUSTOMER_COUNT := v_CUSTOMER_COUNT + 1;
			v_DAILY_BASE_LOAD:= 0;
			v_TOTAL_BASE_LOAD := 0;
			v_AVERAGE_DAILY_USAGE := 0;
			v_TOTAL_VALID_READ_DAYS := 0;
			v_VALID_BASE_LOAD := 0;
			v_VALID_READ_DAYS := 0;
			v_X_MIN := 0;
			--v_Y_MIN := 0;
			--v_X_MAX := 0;
			v_Y_MAX := 0;
			v_X_ZERO := 0;
			v_Y_ZERO := 0;

			IF v_CUSTOMER_BASE_LOAD.CUSTOMER_ID = 9999999 THEN
				EXIT;
			END IF;
		END IF;

        v_BEGIN_DATE := v_CUSTOMER_BASE_LOAD.BEGIN_DATE;
        v_END_DATE   := v_CUSTOMER_BASE_LOAD.END_DATE;
		--determine the number of read days in the base load season
		v_VALID_READ_DAYS := GREATEST(v_END_DATE-v_BEGIN_DATE+1,1);
		--get average daily usage value for read period
		v_DAYS := (v_CUSTOMER_BASE_LOAD.END_DATE - v_CUSTOMER_BASE_LOAD.BEGIN_DATE) + 1;
		IF v_DAYS > 0 THEN
			v_AVERAGE_DAILY_USAGE := ROUND(v_CUSTOMER_BASE_LOAD.BILLED_USAGE / v_DAYS, 4);
		ELSE
			v_AVERAGE_DAILY_USAGE := 0;
		END IF;

		--calculate base load contribution
		v_VALID_BASE_LOAD := v_AVERAGE_DAILY_USAGE*v_VALID_READ_DAYS;

		--accumulate the valid read days, average usage combination
		v_TOTAL_BASE_LOAD := v_TOTAL_BASE_LOAD+v_VALID_BASE_LOAD;
		v_TOTAL_VALID_READ_DAYS := v_TOTAL_VALID_READ_DAYS + v_VALID_READ_DAYS;

		v_CUSTOMER_ID := v_CUSTOMER_BASE_LOAD.CUSTOMER_ID;
		v_READ_COUNT := v_READ_COUNT+1;

	END LOOP;
	IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
		LOGS.LOG_DEBUG_DETAIL('DEFAULT ASSIGNMENTS = '|| TO_CHAR(v_DEFAULT_ASSIGNMENTS));
		LOGS.LOG_DEBUG_DETAIL('WRF MIN =' || TO_CHAR(v_WRF_MIN));
		LOGS.LOG_DEBUG_DETAIL('WRF MAX =' || TO_CHAR(v_WRF_MAX));
	END IF;
	IF v_COUNT > 0 THEN
		COMPUTE_USAGE_WRF_STATISTICS(p_WRF_ID, p_TEMPLATE_ID, g_DEFAULT_SEGMENT, p_BEGIN_DATE, p_END_DATE, p_OUTPUT_AS_OF_DATE,
			v_DEFAULT_ASSIGNMENTS, v_WRF_MIN, v_WRF_MAX, 0, 0, v_ALPHA, v_BETA);
		IF g_ALLOW_COMMIT_ROLLBACK THEN COMMIT; END IF;
	END IF;

	v_EVENT_TEXT := 'Usage WRF Statistics Calculated for WRF_ID=' || TO_CHAR(p_WRF_ID) || ', TEMPLATE_ID=' || TO_CHAR(p_TEMPLATE_ID);
	LOGS.LOG_DEBUG(v_EVENT_TEXT);

	v_EVENT_TEXT := 'Total Customer Usage WRF Profiles Calculated:  ' || TO_CHAR(v_CUSTOMER_COUNT);
	LOGS.LOG_DEBUG(v_EVENT_TEXT);
	LOGS.LOG_DEBUG_DETAIL('END UPDATE_CUSTOMER_USAGE_WRF_BASE');

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_RAISE();
END UPDATE_CUSTOMER_USAGE_WRF_BASE;
-----------------------------------------------------------------------------------
PROCEDURE UPDATE_ACCOUNT_USAGE_WRF_BASE
	(
	p_MODEL_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_WRF_ID IN NUMBER,
	p_STATION_ID IN NUMBER,
	p_PARAMETER_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_BASE_LOAD_TEMPLATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_DEFAULT_ALPHA IN NUMBER,
	p_DEFAULT_BETA IN NUMBER
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_DAYS NUMBER;
v_COEFFICIENT  NUMBER := 0;
v_OBSERVATIONS NUMBER := 0;
v_INITIAL BOOLEAN := TRUE;
v_ACCOUNT_ID NUMBER := CONSTANTS.NOT_ASSIGNED;
v_ACCOUNT_COUNT NUMBER := 0;
v_READ_COUNT NUMBER := 0;
v_VALID_READ_DAYS PLS_INTEGER := 0;
v_TOTAL_VALID_READ_DAYS NUMBER := 0;
v_EVENT_TEXT PROCESS_LOG_EVENT.EVENT_TEXT%TYPE;
v_VALID_BASE_LOAD NUMBER := 0;
v_TOTAL_BASE_LOAD NUMBER := 0;
v_AVERAGE_DAILY_USAGE NUMBER := 0;
v_DAILY_BASE_LOAD NUMBER := 0;
v_X_MIN NUMBER := 0;
v_X_MAX NUMBER := 0;
v_Y_MIN NUMBER := 0;
v_Y_MAX NUMBER := 0;
v_X_ZERO NUMBER := 0;
v_Y_ZERO NUMBER := 0;
v_COUNT PLS_INTEGER := 0;
v_DEFAULT_ASSIGNMENTS NUMBER := 0;
v_WRF_MIN NUMBER := 999999;
v_WRF_MAX NUMBER := -999999;
v_ALPHA GA.NUMBER_TABLE;
v_BETA GA.NUMBER_TABLE;
v_CONSUMPTION_CODE CHAR(1) := NVL(MODEL_VALUE_AT_KEY(0,'Position and Billing','Consumption Code','Final',0),'A');

CURSOR c_ACCOUNT_BASE_LOAD IS
	SELECT /*+ ORDERED */ A.ACCOUNT_ID, B.BEGIN_DATE, B.END_DATE, B.BILLED_USAGE, C.BASE_LOAD_BEGIN_DATE "BASE_LOAD_BEGIN_DATE", C.BASE_LOAD_END_DATE "BASE_LOAD_END_DATE"
	FROM ACCOUNT_USAGE_WRF A,
         ACCOUNT_SERVICE D,
         SERVICE E,
         SERVICE_CONSUMPTION B,
         USAGE_WRF_SEASON C,
		 SEASON_DATES F
	WHERE A.ACCOUNT_ID = p_ACCOUNT_ID
		AND A.WRF_ID = p_WRF_ID
		AND A.BEGIN_DATE <= p_END_DATE
		AND NVL(A.END_DATE, p_END_DATE) >= p_BEGIN_DATE
        AND D.ACCOUNT_ID = A.ACCOUNT_ID    --Get service_consumption records for the account thru account_service
        AND E.MODEL_ID = p_MODEL_ID
        AND E.ACCOUNT_SERVICE_ID = D.ACCOUNT_SERVICE_ID
		AND B.SERVICE_ID = E.SERVICE_ID
		AND B.BILL_CODE = 'B'
		AND B.CONSUMPTION_CODE = v_CONSUMPTION_CODE
		AND B.BEGIN_DATE <= p_END_DATE  -- Meter read TOUCHES date range.
		AND B.END_DATE >= p_BEGIN_DATE  -- Meter read TOUCHES date range.
		AND C.WRF_ID = A.WRF_ID  --join
		AND C.WRF_ID = p_WRF_ID  --specify for speed
		AND C.TEMPLATE_ID = p_TEMPLATE_ID
		AND C.BASE_LOAD_TEMPLATE_ID = p_BASE_LOAD_TEMPLATE_ID
		AND C.AS_OF_DATE = p_OUTPUT_AS_OF_DATE
		AND F.SEASON_ID = C.BASE_LOAD_SEASON_ID
        AND B.BEGIN_DATE  <= F.END_DATE
		AND B.END_DATE    >= F.BEGIN_DATE
		AND B.UNIT_OF_MEASUREMENT = GA.DEFAULT_UNIT_OF_MEASUREMENT
UNION ALL
	SELECT 9999999, LOW_DATE, LOW_DATE, 0, LOW_DATE, LOW_DATE FROM DUAL
	ORDER BY 1;

BEGIN

	LOGS.LOG_DEBUG_DETAIL('BEGIN UPDATE_ACCOUNT_USAGE_WRF_BASE');

	PUT_USAGE_WRF_SEASON(p_WRF_ID, p_TEMPLATE_ID,p_BASE_LOAD_TEMPLATE_ID, p_OUTPUT_AS_OF_DATE);

	FOR v_ACCOUNT_BASE_LOAD IN c_ACCOUNT_BASE_LOAD LOOP

		IF v_INITIAL THEN
			v_ACCOUNT_ID := v_ACCOUNT_BASE_LOAD.ACCOUNT_ID;
			v_EVENT_TEXT := 'Begin Calculation for WRF_ID=' || TO_CHAR(p_WRF_ID) || ', TEMPLATE_ID=' || TO_CHAR(p_TEMPLATE_ID);
			LOGS.LOG_DEBUG(v_EVENT_TEXT);
			v_INITIAL := FALSE;
		END IF;

		IF v_ACCOUNT_ID <> v_ACCOUNT_BASE_LOAD.ACCOUNT_ID THEN
			v_DAILY_BASE_LOAD := ROUND(v_TOTAL_BASE_LOAD/v_TOTAL_VALID_READ_DAYS,4);
			IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
				LOGS.LOG_DEBUG_DETAIL('ACCOUNT_ID =' || TO_CHAR(v_ACCOUNT_ID));
				LOGS.LOG_DEBUG_DETAIL('NUMBER OF BASE LOAD READS = ' || TO_CHAR(v_READ_COUNT));
				LOGS.LOG_DEBUG_DETAIL('ACTUAL DAILY BASE LOAD =' || TO_CHAR(v_DAILY_BASE_LOAD));
				LOGS.LOG_DEBUG_DETAIL('TOTAL VALID READ DAYS =' || TO_CHAR(v_TOTAL_VALID_READ_DAYS));
			END IF;
			IF p_TEMPLATE_ID = p_BASE_LOAD_TEMPLATE_ID THEN
				v_COEFFICIENT := 0;
				v_OBSERVATIONS := v_READ_COUNT;
				IF v_READ_COUNT < g_ACCOUNT_USAGE_WRF_MIN_POINTS THEN
					v_DAILY_BASE_LOAD := p_DEFAULT_ALPHA;
					v_DEFAULT_ASSIGNMENTS := v_DEFAULT_ASSIGNMENTS+1;
				END IF;
			ELSE
				CALCULATE_ACCOUNT_COEFFICIENT(p_MODEL_ID,v_DAILY_BASE_LOAD,v_ACCOUNT_ID,p_WRF_ID,p_STATION_ID,p_PARAMETER_ID,p_TEMPLATE_ID,
					p_BEGIN_DATE,p_END_DATE,p_BASE_LOAD_TEMPLATE_ID,p_OUTPUT_AS_OF_DATE,v_COEFFICIENT,v_OBSERVATIONS,
					v_X_MIN,v_X_MAX,v_Y_MIN,v_Y_MAX,v_X_ZERO,v_Y_ZERO);
				IF v_OBSERVATIONS < g_ACCOUNT_USAGE_WRF_MIN_POINTS THEN
					--v_DAILY_BASE_LOAD := p_DEFAULT_ALPHA;
					v_COEFFICIENT := p_DEFAULT_BETA;
					v_DEFAULT_ASSIGNMENTS := v_DEFAULT_ASSIGNMENTS+1;
				END IF;
			END IF;
			IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
				LOGS.LOG_DEBUG_DETAIL('NUMBER OF OBSERVATIONS = ' || TO_CHAR(v_OBSERVATIONS));
				LOGS.LOG_DEBUG_DETAIL('POSTED DAILY BASE LOAD =' || TO_CHAR(v_DAILY_BASE_LOAD));
				LOGS.LOG_DEBUG_DETAIL('POSTED COEFFICIENT =' || TO_CHAR(v_COEFFICIENT));
			END IF;
			PUT_ACCOUNT_BASE_LOAD_LINE(v_ACCOUNT_ID,p_WRF_ID, p_TEMPLATE_ID, p_BASE_LOAD_TEMPLATE_ID, NVL(v_DAILY_BASE_LOAD,0),NVL(v_OBSERVATIONS,0),NVL(v_COEFFICIENT,0),
					v_X_MIN,v_X_MAX,v_Y_MIN,v_Y_MAX,v_X_ZERO,v_Y_ZERO,p_OUTPUT_AS_OF_DATE);
			--Set the nulls to zero and include them in the calculation - 03/31/03
            v_WRF_MIN := LEAST(NVL(v_DAILY_BASE_LOAD, 0) + NVL(v_COEFFICIENT,0) * NVL(v_X_MIN, 0), NVL(v_WRF_MIN, 0));
            v_WRF_MAX := GREATEST(NVL(v_DAILY_BASE_LOAD, 0) + NVL(v_COEFFICIENT,0) * NVL(v_X_MAX, 0), NVL(v_WRF_MAX, 0));

			v_ALPHA(v_ALPHA.COUNT+1) := v_DAILY_BASE_LOAD;
			v_BETA(v_BETA.COUNT+1) := v_COEFFICIENT;
			v_COUNT := v_COUNT+1;
			v_OBSERVATIONS := 0;
			v_READ_COUNT := 0;
			v_ACCOUNT_COUNT := v_ACCOUNT_COUNT + 1;
			v_DAILY_BASE_LOAD:= 0;
			v_TOTAL_BASE_LOAD := 0;
			v_AVERAGE_DAILY_USAGE := 0;
			v_TOTAL_VALID_READ_DAYS := 0;
			v_VALID_BASE_LOAD := 0;
			v_VALID_READ_DAYS := 0;
			v_X_MIN := 0;
			--v_Y_MIN := 0;
			--v_X_MAX := 0;
			v_Y_MAX := 0;
			v_X_ZERO := 0;
			v_Y_ZERO := 0;

			IF v_ACCOUNT_BASE_LOAD.ACCOUNT_ID = 9999999 THEN
				EXIT;
			END IF;
		END IF;

        v_BEGIN_DATE := v_ACCOUNT_BASE_LOAD.BEGIN_DATE;
        v_END_DATE   := v_ACCOUNT_BASE_LOAD.END_DATE;
		--determine the number of read days in the base load season
		v_VALID_READ_DAYS := GREATEST(v_END_DATE-v_BEGIN_DATE+1,1);
		--get average daily usage value for read period
		v_DAYS := (v_ACCOUNT_BASE_LOAD.END_DATE - v_ACCOUNT_BASE_LOAD.BEGIN_DATE) + 1;
		IF v_DAYS > 0 THEN
			v_AVERAGE_DAILY_USAGE := ROUND(v_ACCOUNT_BASE_LOAD.BILLED_USAGE / v_DAYS, 4);
		ELSE
			v_AVERAGE_DAILY_USAGE := 0;
		END IF;

		--calculate base load contribution
		v_VALID_BASE_LOAD := v_AVERAGE_DAILY_USAGE*v_VALID_READ_DAYS;

		--accumulate the valid read days, average usage combination
		v_TOTAL_BASE_LOAD := v_TOTAL_BASE_LOAD+v_VALID_BASE_LOAD;
		v_TOTAL_VALID_READ_DAYS := v_TOTAL_VALID_READ_DAYS + v_VALID_READ_DAYS;

		v_ACCOUNT_ID := v_ACCOUNT_BASE_LOAD.ACCOUNT_ID;
		v_READ_COUNT := v_READ_COUNT+1;

	END LOOP;
	IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
		LOGS.LOG_DEBUG_DETAIL('DEFAULT ASSIGNMENTS = '|| TO_CHAR(v_DEFAULT_ASSIGNMENTS));
		LOGS.LOG_DEBUG_DETAIL('WRF MIN =' || TO_CHAR(v_WRF_MIN));
		LOGS.LOG_DEBUG_DETAIL('WRF MAX =' || TO_CHAR(v_WRF_MAX));
	END IF;
	IF v_COUNT > 0 THEN
		COMPUTE_USAGE_WRF_STATISTICS(p_WRF_ID, p_TEMPLATE_ID, g_DEFAULT_SEGMENT, p_BEGIN_DATE, p_END_DATE, p_OUTPUT_AS_OF_DATE,
			v_DEFAULT_ASSIGNMENTS, v_WRF_MIN, v_WRF_MAX, 0, 0, v_ALPHA, v_BETA);
		IF g_ALLOW_COMMIT_ROLLBACK THEN COMMIT; END IF;
	END IF;

	v_EVENT_TEXT := 'Usage WRF Statistics Calculated for WRF_ID=' || TO_CHAR(p_WRF_ID) || ', TEMPLATE_ID=' || TO_CHAR(p_TEMPLATE_ID);
	LOGS.LOG_DEBUG(v_EVENT_TEXT);

	v_EVENT_TEXT := 'Total ACCOUNT Usage WRF Profiles Calculated:  ' || TO_CHAR(v_ACCOUNT_COUNT);
	LOGS.LOG_DEBUG(v_EVENT_TEXT);
	LOGS.LOG_DEBUG_DETAIL('END UPDATE_ACCOUNT_USAGE_WRF_BASE');

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_RAISE();
END UPDATE_ACCOUNT_USAGE_WRF_BASE;
-----------------------------------------------------------------------------------
PROCEDURE GET_PROFILING_REPORT
	(
	p_MODEL_ID IN NUMBER,
	p_REPORT_NAME IN VARCHAR,
	p_OPTIONAL_PARAMETER IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_PROFILE_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

--Answer a cursor to display on the Reports tab
--in LoadProfiling.
BEGIN

    p_STATUS := GA.SUCCESS;

    --Call XS package
    XS.GET_PROFILING_REPORT
    	(
    	p_MODEL_ID,
    	p_REPORT_NAME,
    	p_OPTIONAL_PARAMETER,
    	p_BEGIN_DATE,
    	p_END_DATE,
    	p_AS_OF_DATE,
    	p_TIME_ZONE,
    	p_INTERVAL,
    	p_PROFILE_ID,
    	p_TEMPLATE_ID,
    	p_STATUS,
    	p_CURSOR
    	);


END GET_PROFILING_REPORT;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_PROFILE_FROM_TO_DATES
	(
	p_PROFILE_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_FROM_DATE OUT DATE,
	p_TO_DATE OUT DATE,
	p_STATUS OUT NUMBER
	) AS

v_IS_EXTERNAL_PROFILE NUMBER := 0;
v_INTERVALS_PER_DAY NUMBER := 0;
v_ADJUST NUMBER(6,5) := 1/86400;	--Hourly default: 1 sec Adjustment to get midnite into proper HED day (for Hourly profiles)
v_STD_TIME_ZONE VARCHAR2(8);

-- Answer the BEGIN and END dates for the specified Profile, Internal or External

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
    p_FROM_DATE := LOW_DATE;
    p_TO_DATE := LOW_DATE+1;

    -- Check if Profile is External
	SELECT  NVL(IS_EXTERNAL_PROFILE,0), NVL(PROFILE_INTERVAL,1)
	INTO v_IS_EXTERNAL_PROFILE, v_INTERVALS_PER_DAY
    FROM LOAD_PROFILE
	WHERE PROFILE_ID = p_PROFILE_ID;

	IF v_INTERVALS_PER_DAY <= 1 THEN    --Daily profile, no date adjustment
		v_ADJUST := 0;	--1 sec Adjustment to get midnite into proper HED day
	END IF;

    v_STD_TIME_ZONE := STD_TIME_ZONE(p_TIME_ZONE);

    IF v_IS_EXTERNAL_PROFILE = 0 THEN  --Internal
    	SELECT  FROM_CUT(MIN(POINT_DATE- v_ADJUST), v_STD_TIME_ZONE),   --Profile dates should always be referenced to StandardTimeZone to avoid problems with DST periods
                FROM_CUT(MAX(POINT_DATE - v_ADJUST), v_STD_TIME_ZONE)   --For hourly, report midnight last entry as 23:59:59 for Profiling GUI
    	INTO p_FROM_DATE, p_TO_DATE
        FROM LOAD_PROFILE_POINT
    	WHERE PROFILE_ID = p_PROFILE_ID
    		AND AS_OF_DATE = p_AS_OF_DATE;

    ELSE    --External
        BEGIN
            XS.GET_PROFILE_FROM_TO_DATES
            	(
            	p_PROFILE_ID,
            	p_TIME_ZONE,
            	p_AS_OF_DATE,
            	p_FROM_DATE,
            	p_TO_DATE,
            	p_STATUS
            	);
                END;
    END IF;
END GET_PROFILE_FROM_TO_DATES;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_LOAD_PROFILE_POINTS
	(
	p_PROFILE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ALL_DATES IN NUMBER := 0,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_POINT_INDEX IN NUMBER := 1,
	p_ALL_INDEXES IN NUMBER := 0,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the PROFILE_POINTS for the specified Profile, Internal or External

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

       FP.GET_LOAD_PROFILE_POINTS
            	(
            	p_PROFILE_ID,
            	p_BEGIN_DATE,
            	p_END_DATE,
            	p_ALL_DATES,
            	p_TIME_ZONE,
            	p_AS_OF_DATE,
            	p_POINT_INDEX,
            	p_ALL_INDEXES,
                '',  -- don't use p_DAY_SELECTION
            	p_STATUS,
            	p_CURSOR
            	);

END GET_LOAD_PROFILE_POINTS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_TYPICAL_DAY_FROM_PROFILE
	(
	p_MODEL_ID IN NUMBER,
	p_PROFILE_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_SEASON_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_ADJUST NUMBER(6,5);
v_ADD_INTERVAL NUMBER;
v_VERSIONED NUMBER;

-- Answer cursor with Typical Day values based on season template dates and day_names.

BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	UT.CUT_DATE_RANGE(p_MODEL_ID,p_BEGIN_DATE, p_END_DATE, LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PF.GET_TYPICAL_DAY_FROM_PROFILE');
		LOGS.LOG_DEBUG(' p_MODEL_ID = '||p_MODEL_ID);
		LOGS.LOG_DEBUG(' p_PROFILE_ID = '||p_PROFILE_ID);
		LOGS.LOG_DEBUG(' p_TEMPLATE_ID = '||p_TEMPLATE_ID);
		LOGS.LOG_DEBUG(' p_SEASON_ID = '||p_SEASON_ID);
		LOGS.LOG_DEBUG(' v_BEGIN_DATE = '||TO_CHAR(v_BEGIN_DATE,'mm/dd/yyyy hh24:mi:ss'));
		LOGS.LOG_DEBUG(' v_END_DATE = '||TO_CHAR(v_END_DATE,'mm/dd/yyyy hh24:mi:ss'));
		LOGS.LOG_DEBUG(' p_AS_OF_DATE = '||tO_CHAR(v_BEGIN_DATE,'mm/dd/yyyy hh24:mi:ss'));
	END IF;

	IF p_MODEL_ID = GA.GAS_MODEL THEN
		v_ADJUST := 0;
		v_ADD_INTERVAL := 0;
	ELSE
		v_ADJUST := g_SECOND;	--Adjustment to get midnite into proper HED day
		v_ADD_INTERVAL := 1;	--
	END IF;

	IF GA.VERSION_PROFILE THEN
		v_VERSIONED := 1;
	ELSE
		v_VERSIONED := 0;
	END IF;

	OPEN p_CURSOR FOR
		SELECT
		  --Add seconds of POINT_DATE to TRUNC(LOW_DATE) to get same intervals in Typical Day dates
		  TRUNC(LOW_DATE) + ((TO_NUMBER(TO_CHAR(D.POINT_DATE - v_ADJUST, 'SSSSS')))/86400 + v_ADJUST) "TYPICAL_DAY_DATE",
		  AVG(D.POINT_VAL) "TYPICAL_DAY_VALUE"
		FROM
		  (SELECT DISTINCT TEMPLATE_ID, SEASON_ID, UPPER(DAY_NAME) "DAY_NAME"
		  		FROM  TEMPLATE_SEASON_DAY_NAME
				WHERE TEMPLATE_ID = p_TEMPLATE_ID
					AND (p_SEASON_ID = CONSTANTS.ALL_ID OR SEASON_ID = p_SEASON_ID)) A,
		  SEASON_DATES C,
		  LOAD_PROFILE_POINT D
		WHERE D.PROFILE_ID = p_PROFILE_ID
		  AND C.SEASON_ID = A.SEASON_ID
		  AND D.POINT_INDEX = 1
		  AND D.POINT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		  AND (v_VERSIONED = 0 OR D.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
		  											FROM LOAD_PROFILE_POINT
													WHERE PROFILE_ID = D.PROFILE_ID
														AND POINT_INDEX = D.POINT_INDEX
														AND POINT_DATE = D.POINT_DATE
														AND AS_OF_DATE <= p_AS_OF_DATE))
		  	--Adjust season dates to desired year - ADD_MONTHS adjusts for Feb 29 in leap year!
		  	--Add months to season begin AND end dates based on difference between BEGIN year and season BEGIN year!
		   AND D.POINT_DATE BETWEEN (C.CUT_BEGIN_DATE+v_ADJUST) AND (C.CUT_END_DATE+v_ADD_INTERVAL)
			--Get points that match day_names
			-- and Handle Holidays
		  AND ( (TO_CHAR(D.POINT_DATE - v_ADJUST, 'DY') = A.DAY_NAME
		  		 AND TRUNC(D.POINT_DATE - v_ADJUST) NOT IN (SELECT HOLIDAY_DATE FROM HOLIDAY_OBSERVANCE))
				OR
				(A.DAY_NAME = 'HOL'
		  		 AND TRUNC(D.POINT_DATE - v_ADJUST) IN (SELECT HOLIDAY_DATE FROM HOLIDAY_OBSERVANCE) )
			  )
		GROUP BY
		  TRUNC(LOW_DATE) + ((TO_NUMBER(TO_CHAR(D.POINT_DATE - v_ADJUST, 'SSSSS')))/86400 + v_ADJUST)
		ORDER BY 1;


END GET_TYPICAL_DAY_FROM_PROFILE;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_TYPICAL_DAY_PROFILE
	(
	o_OID OUT NUMBER,
	p_PROFILE_NAME IN VARCHAR2,
	p_PROFILE_LIBRARY_NAME IN VARCHAR2,
	p_PROFILE_POINT_VALUES IN VARCHAR2,
	p_PROFILE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_PROFILE_TEMPLATE_ID IN NUMBER,
	p_PROFILE_SEASON IN VARCHAR2,
	p_SOURCE_BEGIN_DATE IN DATE,
	p_SOURCE_END_DATE IN DATE,
	p_SOURCE_PROFILE_ID IN NUMBER,
	p_PROFILE_INTERVAL IN NUMBER,
	p_APP_LOG_DOMAIN_NAME IN VARCHAR2,
	p_APP_LOG_APP_NAME IN VARCHAR2,
	p_APP_LOG_EVENT_NAME IN VARCHAR2,
	p_APP_LOG_EVENT_USER_NAME IN VARCHAR2,
	p_LOG_START_STOP IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR2
	) AS

v_PROFILE_RATE_CLASS LOAD_PROFILE.PROFILE_RATE_CLASS%TYPE;
v_PROFILE_STATION_ID LOAD_PROFILE.PROFILE_STATION_ID%TYPE;

BEGIN

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK';

	-- Get some fields from original source profile
	SELECT PROFILE_RATE_CLASS,
		   PROFILE_STATION_ID
	INTO v_PROFILE_RATE_CLASS,
		 v_PROFILE_STATION_ID
	FROM LOAD_PROFILE
	WHERE PROFILE_ID = p_SOURCE_PROFILE_ID;

	PUT_LOAD_PROFILE_COMPLETE
		(
		o_OID,
		p_PROFILE_NAME,
		p_PROFILE_LIBRARY_NAME,
		'Typical Day',  	   	-- p_PROFILE_TYPE
		p_PROFILE_POINT_VALUES,
		p_PROFILE_DATE,
		STD_TIME_ZONE(LOCAL_TIME_ZONE),
		p_AS_OF_DATE,
		p_PROFILE_TEMPLATE_ID,
		p_PROFILE_SEASON,
		p_SOURCE_BEGIN_DATE,
		p_SOURCE_END_DATE,
		p_SOURCE_PROFILE_ID,
		p_PROFILE_INTERVAL,
		p_APP_LOG_DOMAIN_NAME,
		p_APP_LOG_APP_NAME,
		p_APP_LOG_EVENT_NAME,
		p_APP_LOG_EVENT_USER_NAME,
		p_LOG_START_STOP,
		p_STATUS,
		p_MESSAGE
		);

END PUT_TYPICAL_DAY_PROFILE;
---------------------------------------------------------------------------------------------------
PROCEDURE CREATE_TYPICAL_DAY_FOR_PROF
	(
	p_MODEL_ID IN NUMBER,
    p_PROFILE_ID IN NUMBER,
    p_ACCOUNT_ID IN NUMBER,
    p_METER_ID IN NUMBER,
    p_PREFIX_NAME IN VARCHAR2,
    p_TEMPLATE_ID IN NUMBER,
	p_SEASON_ID IN NUMBER,
    p_DAY_TYPE_TEXT IN VARCHAR2,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_AS_OF_DATE IN DATE,
    p_TRACE_ON IN NUMBER,
    p_NEW_PROFILE_ID OUT NUMBER,
    p_NEW_LIBRARY_ID OUT NUMBER,
    p_STATUS OUT NUMBER
    ) AS

-- Create Typical Day Profile based on account or Meter.

v_TEMPLATE_NAME VARCHAR2(64);
v_PROFILE_NAME VARCHAR2(128);
v_LIBRARY_NAME VARCHAR2(128);
v_PROFILE_LIBRARY_ID NUMBER(9);
v_CALENDAR_ID NUMBER(9);
v_NEW_PROFILE_ID NUMBER(9);
v_INTERVALS_PER_DAY NUMBER;
c_TYPICAL_DAY_POINTS GA.REFCURSOR;
v_TYPICAL_DAY_DATE DATE;
v_TYPICAL_DAY_VALUE  LOAD_PROFILE_POINT.POINT_VAL%TYPE;
v_POINTS_LIST VARCHAR2(4000);
v_NOT_FIRST BOOLEAN;
v_MSG VARCHAR2(1000);

BEGIN

    SELECT TEMPLATE_NAME INTO v_TEMPLATE_NAME
    FROM TEMPLATE WHERE TEMPLATE_ID = p_TEMPLATE_ID;

    --Set Default Interval
    IF p_MODEL_ID = GA.GAS_MODEL THEN
         --Gas
         v_INTERVALS_PER_DAY := 1;
    ELSE   --Electric
         v_INTERVALS_PER_DAY := 24;
    END IF;

    --Get v_INTERVALS_PER_DAY from profile
    SELECT NVL(PROFILE_INTERVAL, v_INTERVALS_PER_DAY) INTO v_INTERVALS_PER_DAY
    FROM LOAD_PROFILE WHERE PROFILE_ID = p_PROFILE_ID;

    -- begin new transaction
	IF g_ALLOW_COMMIT_ROLLBACK THEN COMMIT; END IF;

    -- get existing or create new library and profile
    v_LIBRARY_NAME := p_PREFIX_NAME || '_Library';
	PUT_LOAD_PROFILE_LIBRARY(v_LIBRARY_NAME, v_PROFILE_LIBRARY_ID);
	v_PROFILE_NAME := p_PREFIX_NAME || '_' || v_TEMPLATE_NAME;
	PUT_LOAD_PROFILE(v_PROFILE_NAME, v_PROFILE_LIBRARY_ID, 'Typical Day', p_ACCOUNT_ID, p_METER_ID, p_PROFILE_ID, p_BEGIN_DATE, p_END_DATE , p_AS_OF_DATE, p_TEMPLATE_ID, 0, v_TEMPLATE_NAME, v_INTERVALS_PER_DAY, v_NEW_PROFILE_ID);
    p_NEW_PROFILE_ID := v_NEW_PROFILE_ID;
    p_NEW_LIBRARY_ID := v_PROFILE_LIBRARY_ID;

	ID.ID_FOR_CALENDAR(v_LIBRARY_NAME, v_CALENDAR_ID);
	CA.PUT_CALENDAR_PROFILE_LIBRARY(v_CALENDAR_ID,v_PROFILE_LIBRARY_ID,LOW_DATE,NULL,v_PROFILE_LIBRARY_ID,LOW_DATE,p_STATUS);
    --Assign Calendar to either Meter or Account
    IF p_METER_ID IS NOT NULL THEN
        ASSIGN_METER_CALENDAR(v_PROFILE_LIBRARY_ID,v_CALENDAR_ID,p_METER_ID,TRUE);
    ELSIF p_ACCOUNT_ID IS NOT NULL THEN
        ASSIGN_ACCOUNT_CALENDAR(v_PROFILE_LIBRARY_ID,v_CALENDAR_ID,p_ACCOUNT_ID,TRUE);
    END IF;

    --Get Typical Day point values
    GET_TYPICAL_DAY_FROM_PROFILE(p_MODEL_ID,p_PROFILE_ID,p_TEMPLATE_ID,p_SEASON_ID,p_BEGIN_DATE,p_END_DATE,p_AS_OF_DATE,p_TRACE_ON,p_STATUS,c_TYPICAL_DAY_POINTS);

    IF p_STATUS = 0 THEN
        v_NOT_FIRST := FALSE;

        LOGS.LOG_DEBUG('CREATE_TYPICAL_DAY_FOR_PROF');

        LOOP
        	FETCH c_TYPICAL_DAY_POINTS INTO v_TYPICAL_DAY_DATE, v_TYPICAL_DAY_VALUE;
            EXIT WHEN c_TYPICAL_DAY_POINTS%NOTFOUND;

			IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
				LOGS.LOG_DEBUG(' TYPICAL_DAY_DATE = '||TO_CHAR(v_TYPICAL_DAY_DATE,'mm/dd/yyyy hh24:mi:ss'));
				LOGS.LOG_DEBUG(' TYPICAL_DAY_VALUE = '||v_TYPICAL_DAY_VALUE);
			END IF;

            IF v_NOT_FIRST THEN
                v_POINTS_LIST := v_POINTS_LIST || ',' || v_TYPICAL_DAY_VALUE;
            ELSE
                v_POINTS_LIST := v_TYPICAL_DAY_VALUE;
                v_NOT_FIRST := TRUE;
            END IF;

        END LOOP;

        IF v_POINTS_LIST IS NULL OR v_TYPICAL_DAY_DATE IS NULL OR v_TYPICAL_DAY_VALUE  IS NULL THEN
			IF g_ALLOW_COMMIT_ROLLBACK THEN ROLLBACK; END IF;
        ELSE
            PUT_TYPICAL_DAY_PROFILE(
                    p_NEW_PROFILE_ID, v_PROFILE_NAME, v_LIBRARY_NAME,
                    v_POINTS_LIST, v_TYPICAL_DAY_DATE, p_AS_OF_DATE,
                    p_TEMPLATE_ID, p_DAY_TYPE_TEXT, p_BEGIN_DATE,
                    p_END_DATE, p_NEW_PROFILE_ID, v_INTERVALS_PER_DAY,
                    NULL, NULL,	'TYPICAL_BATCH_RUN',
                    NULL, 0, p_STATUS, v_MSG
                    );

			IF g_ALLOW_COMMIT_ROLLBACK THEN COMMIT; END IF;
        END IF;
	    CLOSE c_TYPICAL_DAY_POINTS;
    ELSE
		IF g_ALLOW_COMMIT_ROLLBACK THEN ROLLBACK; END IF;

    END IF;
EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_RAISE();
END CREATE_TYPICAL_DAY_FOR_PROF;
---------------------------------------------------------------------------------------------------
-- launches background job which execute BATCH_WRF_PROCESS using
-- template and account IDs in WRF_*_TO_RUN_TEMP temporary tables
PROCEDURE RUN_BATCH_WRF
	(
	p_RUN_MODE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
    p_TIME_ZONE IN VARCHAR2,
	p_R2_THRESHOLD IN NUMBER,
	p_MIN_SEGMENTS IN NUMBER,
	p_MAX_SEGMENTS IN NUMBER,
	p_AUTO_APPLY IN NUMBER,
	p_TRACE_ON IN NUMBER,
	p_MESSAGE OUT VARCHAR2
	) AS
v_JOB_NAME VARCHAR2(512);
v_PLSQL VARCHAR2(32767);
v_TEMPLATES VARCHAR2(32767);
v_ACCOUNTS VARCHAR2(32767);
v_FIRST BOOLEAN;
CURSOR cur_TEMPLATES IS
	SELECT TEMPLATE_ID
	FROM WRF_TEMPLATES_TO_RUN_TEMP;
CURSOR cur_ACCOUNTS IS
	SELECT ACCOUNT_ID
	FROM WRF_ACCOUNTS_TO_RUN_TEMP;
BEGIN
	-- get lists of IDs
	v_TEMPLATES := 'NUMBER_COLLECTION(';
	v_FIRST := TRUE;
	FOR rec IN cur_TEMPLATES LOOP
		IF v_FIRST THEN
			v_FIRST := FALSE;
		ELSE
			v_TEMPLATES := v_TEMPLATES||',';
		END IF;
		v_TEMPLATES := v_TEMPLATES||NVL(TO_CHAR(rec.TEMPLATE_ID), 'NULL');
	END LOOP;
	v_TEMPLATES := v_TEMPLATES||')';

	-- check run mode to see how to specify account IDs
	v_ACCOUNTS := 'NUMBER_COLLECTION(';
	v_FIRST := TRUE;
	IF p_RUN_MODE_ID = c_BATCH_RUN_MODE_SELECTED THEN
		-- include selected accounts in the list
		FOR rec IN cur_ACCOUNTS LOOP
			IF v_FIRST THEN
				v_FIRST := FALSE;
			ELSE
				v_ACCOUNTS := v_ACCOUNTS||',';
			END IF;
			v_ACCOUNTS := v_ACCOUNTS||NVL(TO_CHAR(rec.ACCOUNT_ID), 'NULL');
		END LOOP;
	ELSE
		-- use the run mode ID as shorthand
		v_ACCOUNTS := v_ACCOUNTS||NVL(TO_CHAR(p_RUN_MODE_ID), 'NULL');
	END IF;
	v_ACCOUNTS := v_ACCOUNTS||')';

	v_PLSQL := '
DECLARE
	v_PROC_STAT NUMBER(9);
	v_MSG VARCHAR2(32767);
	v_TEMPLATES NUMBER_COLLECTION := '||v_TEMPLATES||';
	v_ACCOUNTS NUMBER_COLLECTION := '||v_ACCOUNTS||';
BEGIN
	PF.BATCH_WRF_PROCESS(v_TEMPLATES, v_ACCOUNTS,
					DATE '''||TO_CHAR(p_BEGIN_DATE,'YYYY-MM-DD')||''',
					DATE '''||TO_CHAR(p_END_DATE,'YYYY-MM-DD')||''',
                    '''||p_TIME_ZONE||''',
					'||NVL(TO_CHAR(p_R2_THRESHOLD),'NULL')||',
					'||NVL(TO_CHAR(p_MIN_SEGMENTS),'NULL')||',
					'||NVL(TO_CHAR(p_MAX_SEGMENTS),'NULL')||',
					'||NVL(TO_CHAR(p_AUTO_APPLY),'NULL')||',
					'||NVL(TO_CHAR(p_TRACE_ON),'NULL')||',
					v_PROC_STAT,
					v_MSG);
END;
';

	v_JOB_NAME := START_BACKGROUND_JOB(v_PLSQL, p_COMMENTS => 'Calculate WRF Profiles');

	p_MESSAGE := 'Job has been started. See the process log for details.';
END RUN_BATCH_WRF;
---------------------------------------------------------------------------------------------------
-- calculate WRFs for the specified day-types and accounts
PROCEDURE BATCH_WRF_PROCESS
	(
	p_TEMPLATE_IDs IN NUMBER_COLLECTION,
	p_ACCOUNT_IDs IN NUMBER_COLLECTION,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
    p_TIME_ZONE IN VARCHAR2,
	p_R2_THRESHOLD IN NUMBER,
	p_MIN_SEGMENTS IN NUMBER,
	p_MAX_SEGMENTS IN NUMBER,
	p_AUTO_APPLY IN NUMBER,
	p_TRACE_ON IN NUMBER,
	p_PROCESS_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR2
	) AS
v_TEMPLATE_IDX	PLS_INTEGER;
v_ACCOUNT_IDs	NUMBER_COLLECTION;
v_ACCOUNT_IDX	PLS_INTEGER;
v_COUNT			PLS_INTEGER;
v_FIRST_ACCOUNT	NUMBER;
v_BATCH_TIMESTAMP TIMESTAMP := SYSTIMESTAMP;
v_MDR_BACKEND_SETTING SYSTEM_DICTIONARY.VALUE%TYPE;
v_RUN_MODE_SELECTED BOOLEAN := FALSE;
v_MDR_ACC_COUNT NUMBER := 0;
BEGIN
	IF p_TEMPLATE_IDs IS NULL THEN
		p_MESSAGE := 'No Season Day Types specified. Nothing to do.';
		RETURN;
	ELSIF p_TEMPLATE_IDs.COUNT = 0 THEN
		p_MESSAGE := 'No Season Day Types specified. Nothing to do.';
		RETURN;
	ELSIF p_ACCOUNT_IDs IS NULL THEN
		p_MESSAGE := 'No Accounts specified. Nothing to do.';
		RETURN;
	ELSIF p_ACCOUNT_IDs.COUNT = 0 THEN
		p_MESSAGE := 'No Accounts specified. Nothing to do.';
		RETURN;
	END IF;

	BEGIN
		LOGS.START_PROCESS('Calculate WRF Profiles',
						  p_BEGIN_DATE,
						  p_END_DATE,
						  p_EVENT_LEVEL => CASE WHEN p_TRACE_ON > 1 THEN LOGS.c_LEVEL_DEBUG_MORE_DETAIL
						  						WHEN p_TRACE_ON > 0 THEN LOGS.c_LEVEL_DEBUG
												ELSE NULL END
						  );
		LOGS.SET_PROCESS_TARGET_PARAMETER('TEMPLATE_IDs', TEXT_UTIL.TO_CHAR_ENTITY_LIST(p_TEMPLATE_IDs, EC.ED_DAY_TYPE_TEMPLATE));

		v_FIRST_ACCOUNT := p_ACCOUNT_IDs(p_ACCOUNT_IDs.FIRST);
		IF v_FIRST_ACCOUNT = c_BATCH_RUN_MODE_ALL THEN
			LOGS.SET_PROCESS_TARGET_PARAMETER('ACCOUNT_IDs', '<All Accounts>');
		ELSIF v_FIRST_ACCOUNT = c_BATCH_RUN_MODE_AGGREGATE THEN
			LOGS.SET_PROCESS_TARGET_PARAMETER('ACCOUNT_IDs', '<All Aggregate Accounts>');
		ELSIF v_FIRST_ACCOUNT = c_BATCH_RUN_MODE_PERIOD_MTR THEN
			LOGS.SET_PROCESS_TARGET_PARAMETER('ACCOUNT_IDs', '<All Period Metered Accounts>');
		ELSIF v_FIRST_ACCOUNT = c_BATCH_RUN_MODE_INTERVAL_MTR THEN
			LOGS.SET_PROCESS_TARGET_PARAMETER('ACCOUNT_IDs', '<All Interval Metered Accounts>');
		ELSE
			LOGS.SET_PROCESS_TARGET_PARAMETER('ACCOUNT_IDs', TEXT_UTIL.TO_CHAR_ENTITY_LIST(p_ACCOUNT_IDs, EC.ED_ACCOUNT));
		END IF;

		LOGS.SET_PROCESS_TARGET_PARAMETER('R2_THRESHOLD', p_R2_THRESHOLD);
		LOGS.SET_PROCESS_TARGET_PARAMETER('MIN_SEGMENTS', p_MIN_SEGMENTS);
		LOGS.SET_PROCESS_TARGET_PARAMETER('MAX_SEGMENTS', p_MAX_SEGMENTS);
		LOGS.SET_PROCESS_TARGET_PARAMETER('AUTO_APPLY', p_AUTO_APPLY);

        v_MDR_BACKEND_SETTING := NVL(MDM.GET_MDR_BACKEND_SETTING(), 'FALSE');

		-- resolve set of account IDs
		CASE p_ACCOUNT_IDs(p_ACCOUNT_IDs.FIRST)
		WHEN c_BATCH_RUN_MODE_ALL THEN
			-- get all account IDs that have referencing profiles
			SELECT DISTINCT A.ACCOUNT_ID
			BULK COLLECT INTO v_ACCOUNT_IDs
			FROM LOAD_PROFILE LP, ACCOUNT A
			WHERE A.ACCOUNT_ID = CASE LP.PROFILE_ACCOUNT_REF WHEN '?' THEN NULL ELSE TO_NUMBER(LP.PROFILE_ACCOUNT_REF) END
              AND (v_MDR_BACKEND_SETTING = 'FALSE' OR (v_MDR_BACKEND_SETTING = 'TRUE' AND NOT(A.ACCOUNT_MODEL_OPTION = ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_AGGREGATE AND A.ACCOUNT_METER_TYPE = ACCOUNTS_METERS.c_METER_TYPE_INTERVAL)))
			ORDER BY GET_ACCOUNT_STATION(A.ACCOUNT_ID, p_BEGIN_DATE, p_END_DATE);

		WHEN c_BATCH_RUN_MODE_AGGREGATE THEN
			-- get all aggregate account IDs that have referencing profiles
			SELECT DISTINCT A.ACCOUNT_ID
			BULK COLLECT INTO v_ACCOUNT_IDs
			FROM LOAD_PROFILE LP, ACCOUNT A
			WHERE A.ACCOUNT_ID = CASE LP.PROFILE_ACCOUNT_REF WHEN '?' THEN NULL ELSE TO_NUMBER(LP.PROFILE_ACCOUNT_REF) END
		      AND A.ACCOUNT_MODEL_OPTION = 'Aggregate'
              AND (v_MDR_BACKEND_SETTING = 'FALSE' OR (v_MDR_BACKEND_SETTING = 'TRUE' AND NOT(A.ACCOUNT_MODEL_OPTION = ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_AGGREGATE AND A.ACCOUNT_METER_TYPE = ACCOUNTS_METERS.c_METER_TYPE_INTERVAL)))
			ORDER BY GET_ACCOUNT_STATION(A.ACCOUNT_ID, p_BEGIN_DATE, p_END_DATE);

		WHEN c_BATCH_RUN_MODE_PERIOD_MTR THEN
			-- get all period-metered account IDs that have referencing profiles
			SELECT DISTINCT A.ACCOUNT_ID
			BULK COLLECT INTO v_ACCOUNT_IDs
			FROM LOAD_PROFILE LP, ACCOUNT A
			WHERE A.ACCOUNT_ID = CASE LP.PROFILE_ACCOUNT_REF WHEN '?' THEN NULL ELSE TO_NUMBER(LP.PROFILE_ACCOUNT_REF) END
				AND A.ACCOUNT_METER_TYPE = 'Period'
			ORDER BY GET_ACCOUNT_STATION(A.ACCOUNT_ID, p_BEGIN_DATE, p_END_DATE);

		WHEN c_BATCH_RUN_MODE_INTERVAL_MTR THEN
			-- get all interval-metered account IDs that have referencing profiles
			SELECT DISTINCT A.ACCOUNT_ID
			BULK COLLECT INTO v_ACCOUNT_IDs
			FROM LOAD_PROFILE LP, ACCOUNT A
			WHERE A.ACCOUNT_ID = CASE LP.PROFILE_ACCOUNT_REF WHEN '?' THEN NULL ELSE TO_NUMBER(LP.PROFILE_ACCOUNT_REF) END -- handle non-numeric account ref values
		      AND A.ACCOUNT_METER_TYPE = 'Interval'
			  AND LP.PROFILE_TYPE = 'Historical'
              AND (v_MDR_BACKEND_SETTING = 'FALSE' OR (v_MDR_BACKEND_SETTING = 'TRUE' AND NOT(A.ACCOUNT_MODEL_OPTION = ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_AGGREGATE AND A.ACCOUNT_METER_TYPE = ACCOUNTS_METERS.c_METER_TYPE_INTERVAL)))
			ORDER BY GET_ACCOUNT_STATION(A.ACCOUNT_ID, p_BEGIN_DATE, p_END_DATE);
		ELSE
			v_RUN_MODE_SELECTED := TRUE;
			-- just use specified IDs - make sure there are no duplicates and that all
			-- specified accounts have profile references
			SELECT DISTINCT A.ACCOUNT_ID
			BULK COLLECT INTO v_ACCOUNT_IDs
			FROM TABLE(CAST(p_ACCOUNT_IDs as NUMBER_COLLECTION)) IDs,
				ACCOUNT A, LOAD_PROFILE LP
			WHERE A.ACCOUNT_ID = IDs.COLUMN_VALUE
			  AND (
                  (A.ACCOUNT_MODEL_OPTION = ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_AGGREGATE AND A.ACCOUNT_METER_TYPE = ACCOUNTS_METERS.c_METER_TYPE_INTERVAL)
                  OR
                  (LP.PROFILE_ACCOUNT_REF = TO_CHAR(A.ACCOUNT_ID))
                  )
			ORDER BY GET_ACCOUNT_STATION(A.ACCOUNT_ID, p_BEGIN_DATE, p_END_DATE);

			-- now we check for invalid IDs - those that didn't match above joins
			SELECT COUNT(1)
			INTO v_COUNT
			FROM TABLE(CAST(p_ACCOUNT_IDs as NUMBER_COLLECTION)) IDs
			WHERE NOT EXISTS (SELECT 1 FROM ACCOUNT A WHERE A.ACCOUNT_ID = IDs.COLUMN_VALUE)
				OR (NOT EXISTS (SELECT 1 FROM LOAD_PROFILE LP WHERE LP.PROFILE_ACCOUNT_REF = TO_CHAR(IDs.COLUMN_VALUE))
                AND NOT EXISTS (SELECT 1 FROM ACCOUNT A WHERE A.ACCOUNT_ID = IDs.COLUMN_VALUE AND 
                                                         A.ACCOUNT_MODEL_OPTION = ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_AGGREGATE AND 
														 A.ACCOUNT_METER_TYPE = ACCOUNTS_METERS.c_METER_TYPE_INTERVAL));

			IF v_COUNT > 0 THEN
				LOGS.LOG_WARN('Specified account IDs include '||v_COUNT||' invalid selections');
			END IF;
		END CASE;

		-- update progress tracking info
		LOGS.INIT_PROCESS_PROGRESS(p_TOTAL_WORK => p_TEMPLATE_IDs.COUNT * v_ACCOUNT_IDs.COUNT);

		-- now do the work!

		-- We use template as the outer-loop and have ordered set of accounts by weather
		-- station ID to get max re-use out of caching weather data. That way we only query the
		-- weather data for the first account for that station and re-use it for all other
		-- accounts assigned to the same station

		v_TEMPLATE_IDX := p_TEMPLATE_IDs.FIRST;
		WHILE p_TEMPLATE_IDs.EXISTS(v_TEMPLATE_IDX) LOOP

			v_ACCOUNT_IDX := v_ACCOUNT_IDs.FIRST;
			WHILE v_ACCOUNT_IDs.EXISTS(v_ACCOUNT_IDX) LOOP
            
                SELECT COUNT(1)
                INTO v_COUNT
                FROM ACCOUNT A
                WHERE A.ACCOUNT_ID = v_ACCOUNT_IDs(v_ACCOUNT_IDX)
                  AND NOT(A.ACCOUNT_MODEL_OPTION = ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_AGGREGATE AND A.ACCOUNT_METER_TYPE = ACCOUNTS_METERS.c_METER_TYPE_INTERVAL);

				IF v_COUNT > 0 THEN
                    CREATE_WRF_PROFILES_FOR_ACCT(v_ACCOUNT_IDs(v_ACCOUNT_IDX), p_TEMPLATE_IDs(v_TEMPLATE_IDX),
                                                 p_BEGIN_DATE, p_END_DATE, HIGH_DATE, LOW_DATE,
                                                 p_R2_THRESHOLD,
                                                 p_MIN_SEGMENTS, p_MAX_SEGMENTS, p_AUTO_APPLY,
                                                 v_BATCH_TIMESTAMP);
                END IF;

				-- increment progress
				LOGS.INCREMENT_PROCESS_PROGRESS;

				v_ACCOUNT_IDX := v_ACCOUNT_IDs.NEXT(v_ACCOUNT_IDX);
			END LOOP;

			v_TEMPLATE_IDX := p_TEMPLATE_IDs.NEXT(v_TEMPLATE_IDX);
		END LOOP;

        -- get the count of MDR Accounts
		SELECT COUNT(*) INTO v_MDR_ACC_COUNT
		FROM ACCOUNT A, TABLE(CAST(p_ACCOUNT_IDs as NUMBER_COLLECTION)) IDs
		WHERE IDs.COLUMN_VALUE = A.ACCOUNT_ID
		AND A.ACCOUNT_MODEL_OPTION = ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_AGGREGATE
		AND A.ACCOUNT_METER_TYPE = ACCOUNTS_METERS.c_METER_TYPE_INTERVAL;

        IF v_MDR_BACKEND_SETTING = 'TRUE' AND NOT(v_RUN_MODE_SELECTED = TRUE AND v_MDR_ACC_COUNT = 0) THEN
				MDM.CREATE_WRF_PROFILES(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_TEMPLATE_IDs, v_ACCOUNT_IDs);
        END IF;

		-- done!
		LOGS.STOP_PROCESS(p_MESSAGE, p_PROCESS_STATUS);
		COMMIT;

	EXCEPTION
		WHEN OTHERS THEN
			ERRS.ABORT_PROCESS;
	END;

END BATCH_WRF_PROCESS;
------------------------------------------------------------------------------------------------
PROCEDURE CHOOSE_CANDIDATE
	(
	p_FCM_ID IN NUMBER,
	p_NUM_SEGMENTS IN NUMBER
	) AS
v_PROFILE_ID		NUMBER(9);
v_HOUR				NUMBER(2);
v_INTERVALS_PER_DAY	NUMBER(2);
v_PARM_COUNT		BINARY_INTEGER;
v_STATS				WRF_STAT_STRUCT;
v_STATUS			NUMBER;
v_FROM_DATE			DATE;
v_TO_DATE			DATE;

CURSOR cur_CANDIDATES IS
	SELECT C.FCM_ID, C.NUM_SEGMENTS
	FROM WRF_FCM W,
		WRF_FCM_CANDIDATE C
	WHERE W.PROFILE_ID = v_PROFILE_ID
		AND W.HOUR_NUM <> v_HOUR -- get all other hours
		AND C.FCM_ID = W.FCM_ID
		AND C.NUM_SEGMENTS = (SELECT COUNT(1) -- get candidate that is currently in use
							  FROM LOAD_PROFILE_WRF WRF,
								LOAD_PROFILE_WRF_LINE WRFL
							  WHERE WRF.PROFILE_ID = v_PROFILE_ID
								AND WRFL.WRF_ID = WRF.WRF_ID
								AND WRFL.WRF_HOUR = W.HOUR_NUM);

BEGIN
	-- gather values needed by CHOOSE_FCM_CANDIDATE procedure
	-- above:
	-- profile ID and which hour
	SELECT PROFILE_ID, HOUR_NUM
	INTO v_PROFILE_ID, v_HOUR
	FROM WRF_FCM
	WHERE FCM_ID = p_FCM_ID;
	-- number of intervals per day
	IF GA.DEFAULT_MODEL = GA.GAS_MODEL THEN
		v_INTERVALS_PER_DAY := 1;
	ELSE
		v_INTERVALS_PER_DAY := 24;
	END IF;
	-- how many weather parameters used
	SELECT COUNT(1)
	INTO v_PARM_COUNT
	FROM LOAD_PROFILE_WRF_WEATHER
	WHERE PROFILE_ID = v_PROFILE_ID;
	-- date range of the profile
	SELECT FROM_DATE, TO_DATE
	INTO v_FROM_DATE, v_TO_DATE
	FROM LOAD_PROFILE_STATISTICS
	WHERE PROFILE_ID = v_PROFILE_ID
		AND AS_OF_DATE = LOW_DATE;

	-- Now clear out existing WRF data
	DELETE LOAD_PROFILE_WRF_LINE L
	WHERE EXISTS (SELECT 1 FROM LOAD_PROFILE_WRF W
					WHERE W.WRF_ID = L.WRF_ID
						AND W.PROFILE_ID = v_PROFILE_ID)
		AND L.WRF_HOUR = CASE WHEN v_INTERVALS_PER_DAY = 1 THEN 1 ELSE v_HOUR END;

	-- And invoke this procedure - which will use WRF data for selected candidate
	CHOOSE_FCM_CANDIDATE(v_PROFILE_ID, v_HOUR, v_INTERVALS_PER_DAY, LOW_DATE,
						 v_PARM_COUNT, p_FCM_ID, p_NUM_SEGMENTS, v_STATS);

	-- Add to v_STATS the statistics info for other hours
	FOR v_CANDIDATE IN cur_CANDIDATES LOOP
		UPDATE_STATS_FOR_CANDIDATE(v_CANDIDATE.FCM_ID, v_CANDIDATE.NUM_SEGMENTS, v_STATS);
	END LOOP;

	-- and re-generate profile statistics
	FINALIZE_STATS(v_STATS);
	PUT_LOAD_PROFILE_STATISTICS (v_PROFILE_ID, GET_PROFILE_VERSION_ID(LOW_DATE),
		LOW_DATE, v_FROM_DATE, v_TO_DATE, v_STATS.P_COUNT, 0.0, v_STATS.p_MIN, v_STATS.P_NZMIN,
		v_STATS.P_MAX, v_STATS.P_SUM, v_STATS.MAPE, v_STATS.STDAPE, v_STATS.TOT_ERR_PCT, v_STATS.R2MIN, v_STATS.R2MAX, v_STATS.R2FAIL,
		v_STATS.T_TEMP, v_STATS.T_HUMID, v_STATS.T_WIND, 'Pending', v_STATUS);
	ERRS.VALIDATE_STATUS('PF.PUT_LOAD_PROFILE_STATISTICS', v_STATUS);

END CHOOSE_CANDIDATE;
---------------------------------------------------------------------------------------------------
END PF;
/
