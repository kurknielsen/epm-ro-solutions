CREATE OR REPLACE PACKAGE BS AS
--Revision $Revision: 1.147 $

-- Billing Statement Package

FUNCTION WHAT_VERSION RETURN VARCHAR;


PROCEDURE BILLING_SUMMARY
	(
    p_CALLING_MODULE IN VARCHAR,
    p_MODEL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
    p_INTERVAL IN VARCHAR,
    p_INTERVAL_DETAIL IN NUMBER,
	p_ENTITY_IDs IN VARCHAR,
    p_AGGREGATE_ENTITIES IN NUMBER,
    p_PRODUCTS_COMPONENTS IN VARCHAR,
    p_SHOW_PRODUCT IN NUMBER,
    p_SHOW_COMPONENT IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
    p_PERIOD_BEGIN OUT DATE,
    p_PERIOD_END OUT DATE,
    p_LAST_UPDATE OUT DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
    );

PROCEDURE BILLING_COMPARISON
	(
    p_CALLING_MODULE IN VARCHAR,
    p_MODEL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
    p_INTERVAL IN VARCHAR,
    p_INTERVAL_DETAIL IN NUMBER,
	p_ENTITY_IDs IN VARCHAR,
    p_AGGREGATE_ENTITIES IN NUMBER,
    p_PRODUCTS_COMPONENTS IN VARCHAR,
    p_SHOW_PRODUCT IN NUMBER,
    p_SHOW_COMPONENT IN NUMBER,
	p_STATEMENT_TYPE1 IN NUMBER,
	p_STATEMENT_STATE1 IN NUMBER,
	p_STATEMENT_TYPE2 IN NUMBER,
	p_STATEMENT_STATE2 IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
    p_PERIOD_BEGIN OUT DATE,
    p_PERIOD_END OUT DATE,
    p_LAST_UPDATE OUT DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
    );

PROCEDURE CHARGE_COMPONENT_DETAIL
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_BEGIN_DATE IN OUT DATE,
	p_END_DATE IN DATE,
	p_ENTITY_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_CHARGE_VIEW_TYPE IN VARCHAR,
	p_BAND_KEYWORD OUT VARCHAR,
	p_HAS_SUBTOTALS OUT NUMBER,
	p_KEY_COLUMNS OUT VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE SCHEDULE_BY_TRANSMISSION
    (
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_TRANSACTION_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE DAILY_IMBALANCE_SUMMARY
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ENTITY_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE DAILY_IMBALANCE
    (
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ENTITY_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE GET_INVOICE_REPORT_RECORDS
	(
    p_CALLING_MODULE IN VARCHAR,
    p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_INVOICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
    p_INVOICE_CATEGORY IN VARCHAR,
    p_INVOICE_ID OUT NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
    );

PROCEDURE GET_INVOICE_LINE_ITEMS
    (
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_INVOICE_DATE IN DATE,
	p_INVOICE_ID IN NUMBER,
	p_IS_INVOICE_DETAIL OUT NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE GET_INVOICE_LINE_ITEM
    (
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
    p_STATEMENT_STATE IN NUMBER,
	p_INVOICE_DATE IN DATE,
	p_INVOICE_ID IN NUMBER,
	p_LINE_ITEM_NAME IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PUT_INVOICE_LINE_ITEM
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
    p_STATEMENT_STATE IN NUMBER,
	p_INVOICE_DATE IN DATE,
	p_INVOICE_ID IN NUMBER,
	p_OLD_LINE_ITEM_NAME IN VARCHAR,
	p_LINE_ITEM_NAME IN VARCHAR,
    p_LINE_ITEM_CATEGORY IN VARCHAR,
	p_LINE_ITEM_TYPE IN CHAR,
	p_LINE_ITEM_QUANTITY IN NUMBER,
	p_LINE_ITEM_RATE IN NUMBER,
	p_LINE_ITEM_AMOUNT IN NUMBER,
	p_LINE_ITEM_BILL_AMOUNT IN NUMBER,
    p_DEFAULT_DISPLAY IN VARCHAR,
    p_INVOICE_GROUP_ID IN NUMBER,
    p_INVOICE_GROUP_ORDER IN NUMBER,
    p_EXCLUDE_FROM_INVOICE_TOTAL IN NUMBER,
    p_IS_TAXED IN NUMBER,
    p_TAX_COMPONENT_ID IN NUMBER,
    p_TAX_GEOGRAPHY_ID IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_INVOICE_USER_LINE_ITEM
	(
	p_INVOICE_USER_LINE_ITEM IN OUT INVOICE_USER_LINE_ITEM%ROWTYPE
	);

PROCEDURE DELETE_INVOICE_LINE_ITEM
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_INVOICE_DATE IN DATE,
	p_INVOICE_ID IN NUMBER,
	p_LINE_ITEM_NAME IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_INVOICE_STATUS
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_INVOICE_ID IN NUMBER,
	p_INVOICE_STATUS IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_INVOICE_DUE_DATE
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_INVOICE_ID IN NUMBER,
	p_DUE_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE EXPORT_BILLING
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATEMENT_TYPE IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE EDC_IMBALANCE
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATEMENT_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE SERVICE_POINT_FOR_COMPONENT
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_SERVICE_POINT_ID OUT NUMBER,
	p_SERVICE_POINT_NAME OUT VARCHAR2,
	p_STATUS OUT NUMBER
	);

PROCEDURE BILL_ENTITY_NAMES
   (
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE BILL_ENTITY_NAMES_TO_CALC
   (
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE BILL_ENTITY_NAMES_BY_INTERVAL
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
    p_INTERVAL IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PSE_NAMES
    (
	 p_STATUS OUT NUMBER,
	 p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE BILL_PARTY_NAMES
    (
	 p_STATUS OUT NUMBER,
	 p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE BILL_CYCLE_NAMES
    	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE GET_CHARGE_VIEW_TYPE
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_STATEMENT_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_CHARGE_VIEW_TYPE OUT VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_BILLING_CHARGE_DISPUTES
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_STATEMENT_DATE IN DATE,
	p_DISPUTE_DATES IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PUT_BILLING_CHARGE_DISPUTE
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_STATEMENT_DATE IN DATE,
	p_DISPUTE_DATE IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_DISPUTE_STATUS IN VARCHAR,
	p_MARKET_STATUS IN VARCHAR,
	p_SUBMIT_STATUS IN VARCHAR,
	p_BILLED_AMOUNT IN NUMBER,
	p_CORRECT_AMOUNT IN NUMBER,
	p_DESCR IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_STATEMENT_STATUS
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE GET_STATEMENT_STATUS_DETAILS
	(
    p_CALLING_MODULE IN VARCHAR,
    p_MODEL_ID IN NUMBER,
    p_ENTITY_ID IN NUMBER,
    p_STATEMENT_DATE IN DATE,
    p_STATEMENT_TYPE IN NUMBER,
    p_STATEMENT_STATE IN NUMBER,
    p_AS_OF_DATE IN DATE,
	p_REVIEW_STATUS OUT VARCHAR,
    p_NOTES OUT VARCHAR,
    p_INVOICE_BEGIN_DATE OUT DATE,
    p_INVOICE_END_DATE OUT DATE,
    p_INVOICE_ENTRY_DATE OUT DATE,
    p_STATEMENT_ENTRY_DATE OUT DATE,
    p_STATUS OUT NUMBER
    );

PROCEDURE PUT_STATEMENT_STATUS
	(
    p_CALLING_MODULE IN VARCHAR,
    p_MODEL_ID IN NUMBER,
    p_ENTITY_ID IN NUMBER,
    p_STATEMENT_DATE IN DATE,
    p_STATEMENT_TYPE IN NUMBER,
    p_STATEMENT_STATE IN NUMBER,
    p_AS_OF_DATE IN DATE,
    p_REVIEW_STATUS IN VARCHAR,
    p_NOTES IN VARCHAR,
    p_STATUS OUT NUMBER
    );

PROCEDURE GET_DISPUTE_STATUS
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_STATUS_FILTER IN VARCHAR,
	p_STATEMENT_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PRODUCT_NAMES
	(
	p_STATEMENT_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE COMPONENT_NAMES
	(
	p_STATEMENT_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE GET_INVOICE_COMPARISON
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_INVOICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
    p_INVOICE_CATEGORY IN VARCHAR,
    p_PERIOD_BEGIN OUT DATE,
    p_PERIOD_END OUT DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE GET_INVOICE_VALIDATION
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_INVOICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
    p_INVOICE_CATEGORY IN VARCHAR,
    p_STATEMENT_TYPE IN NUMBER,
    p_STATEMENT_STATE IN NUMBER,
    p_PERIOD_BEGIN OUT DATE,
    p_PERIOD_END OUT DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

FUNCTION GET_FORMAT_FROM_INTERVAL
	(
	p_INTERVAL IN VARCHAR
	) RETURN VARCHAR;

FUNCTION GET_FORMAT_FROM_COMPONENT
	(
	p_COMPONENT_ID IN NUMBER
	) RETURN VARCHAR;

PROCEDURE GET_EXPORT_SUMMARY
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
    p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
    p_BEGIN_DATE IN OUT DATE,
    p_END_DATE IN OUT DATE,
    p_AS_OF_DATE IN DATE,
    p_ID_PAIRS OUT VARCHAR,
    p_ENTITY_NAME OUT VARCHAR,
    p_STATUS OUT NUMBER,
    p_MESSAGE OUT VARCHAR,
	p_CURSOR IN OUT GA.REFCURSOR
    );

PROCEDURE GET_EXPORT_DETAIL
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
    p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_AS_OF_DATE IN DATE,
    p_TIME_ZONE IN VARCHAR,
    p_ID_PAIRS IN OUT VARCHAR,
    p_USE_NORMAL_DETAIL OUT NUMBER,
    p_PRODUCT_NAME OUT VARCHAR,
    p_PRODUCT_ID OUT NUMBER,
    p_COMPONENT_NAME OUT VARCHAR,
    p_COMPONENT_ID OUT NUMBER,
    p_HEADER_ROWS OUT NUMBER,
    p_STATUS OUT NUMBER,
    p_MESSAGE OUT VARCHAR,
	p_CURSOR IN OUT GA.REFCURSOR
    );

PROCEDURE GET_EXPORT_ENTITIES
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
    p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_AS_OF_DATE IN DATE,
    p_STATUS OUT NUMBER,
    p_MESSAGE OUT VARCHAR,
	p_CURSOR IN OUT GA.REFCURSOR
    );

PROCEDURE TAX_COMPONENTS
	(
    p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
    );

PROCEDURE GET_ENTITY_TIME_ZONE
	(
    p_CALLING_MODULE IN VARCHAR,
    p_MODEL_ID IN NUMBER,
    p_ENTITY_ID IN NUMBER,
    p_TIME_ZONE OUT VARCHAR2,
    p_STATUS OUT NUMBER
    );

PROCEDURE GET_END_DAY
	(
    p_DATE IN DATE,
    p_INTERVAL IN VARCHAR,
    p_RESULT OUT DATE
    );

PROCEDURE GET_INVOICE_CATEGORIES
	(
    p_ENTITY_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_AS_OF_DATE IN DATE,
    p_STATUS OUT NUMBER,
    p_CURSOR IN OUT GA.REFCURSOR
    );

PROCEDURE APPROVE_INVOICE
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_INVOICE_ID IN NUMBER,
	p_STATUS OUT NUMBER
	);

FUNCTION EXPORT_TX_TITLE
	(
	p_TX_SERVICE_TYPE IN VARCHAR
	) RETURN VARCHAR;

FUNCTION EXPORT_TX_LABEL
	(
	p_TX_SERVICE_TYPE IN VARCHAR
	) RETURN VARCHAR;

PROCEDURE UPLOAD_EMAIL_FILE
	(
	p_CALLING_MODULE IN VARCHAR2,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_WORK_ID IN OUT NUMBER,
	p_DATA IN VARCHAR2
	);

PROCEDURE SEND_EMAILS
	(
	p_CALLING_MODULE IN VARCHAR2,
	p_MODEL_ID IN NUMBER,
	p_WORK_ID IN NUMBER
	);

PROCEDURE UPDATE_INVOICE_STATUS_SENT
	(
	p_CALLING_MODULE IN VARCHAR2,
	p_MODEL_ID IN NUMBER,
	p_INVOICE_ID IN NUMBER
	);

g_ALL NUMBER(2) := -1;
g_ALL_STRING VARCHAR(16) := '<ALL>';
g_NOT_ASSIGNED NUMBER(1) := 0;
g_TRACE_ON BOOLEAN := FALSE;
g_DOMAIN_NAME VARCHAR(16) := 'BILLING';
g_APP_NAME VARCHAR(16) := 'RetailOffice';
g_INTERNAL_STATE NUMBER(1) := 1;
g_EXTERNAL_STATE NUMBER(1) := 2;
g_EVENT_TEXT VARCHAR(128);

g_PSE CHAR(3) := 'PSE';
g_POOL CHAR(4) := 'POOL';
g_BILL_PARTY CHAR(10) := 'BILL_PARTY';

-- Calling Modules.
g_POSITION_AND_BILLING CHAR(1) := 'P';
g_SCHEDULING CHAR(1) := 'S';
g_GAS_DELIVERY CHAR(1) := 'G';

INSUFFICIENT_PRIVILEGES EXCEPTION;
PRAGMA EXCEPTION_INIT(INSUFFICIENT_PRIVILEGES, -1031);

END BS;
/
CREATE OR REPLACE PACKAGE BODY BS AS
----------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
    RETURN '$Revision: 1.147 $';
END WHAT_VERSION;
----------------------------------------------------------------------------------------------------
PROCEDURE NULL_CURSOR
    (
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
		SELECT NULL FROM DUAL;

END NULL_CURSOR;
----------------------------------------------------------------------------------------------------
FUNCTION GET_END_DAY
	(
    p_DATE IN DATE,
    p_INTERVAL IN VARCHAR
    ) RETURN DATE IS
v_BEGIN_DATE DATE := TRUNC(p_DATE,PC.GET_ORA_TRUNC_INTERVAL(p_INTERVAL));
v_INTERVAL VARCHAR2(2) := UPPER(SUBSTR(p_INTERVAL,1,2));
BEGIN
	IF v_INTERVAL = 'YE' THEN
    	RETURN ADD_MONTHS(v_BEGIN_DATE,12)-1;
    ELSIF v_INTERVAL = 'QU' THEN
    	RETURN ADD_MONTHS(v_BEGIN_DATE,3)-1;
    ELSIF v_INTERVAL = 'MO' THEN
    	RETURN ADD_MONTHS(v_BEGIN_DATE,1)-1;
    ELSIF v_INTERVAL = 'WE' THEN
    	RETURN v_BEGIN_DATE+6;
    ELSE -- v_INTERVAL = 'DA' THEN
    	RETURN v_BEGIN_DATE;
    END IF;
END GET_END_DAY;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_END_DAY
	(
    p_DATE IN DATE,
    p_INTERVAL IN VARCHAR,
    p_RESULT OUT DATE
    ) AS
BEGIN
	p_RESULT := GET_END_DAY(p_DATE,p_INTERVAL);
END GET_END_DAY;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SUMMARY_RECORDS
	(
    p_CALLING_MODULE IN VARCHAR,
	p_BEGIN_DATE IN OUT DATE,
	p_END_DATE IN OUT DATE,
    p_INTERVAL IN VARCHAR,
    p_INTERVAL_DETAIL IN NUMBER,
	p_ENTITY_IDs IN VARCHAR,
    p_AGGREGATE_ENTITIES IN NUMBER,
    p_PRODUCTS_COMPONENTS IN VARCHAR,
    p_SHOW_PRODUCT IN NUMBER,
    p_SHOW_COMPONENT IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
    p_RESULTS IN OUT NOCOPY BILLING_SUMMARY_RECORD_TABLE
    ) AS
v_TRUNC_INTERVAL VARCHAR2(16) := PC.GET_ORA_TRUNC_INTERVAL(p_INTERVAL);
v_NUMBER_TABLE GA.ID_TABLE;
v_STRING_TABLE GA.STRING_TABLE;
v_WORK_ID1 NUMBER;
v_WORK_ID2 NUMBER;
v_INDEX BINARY_INTEGER;
v_COUNT BINARY_INTEGER;
v_ID NUMBER;
v_BEGIN_DATE DATE := TRUNC(p_BEGIN_DATE,PC.GET_ORA_TRUNC_INTERVAL(p_INTERVAL));
v_END_DATE DATE := GET_END_DAY(p_END_DATE,p_INTERVAL);
v_SHOW_END_DATE NUMBER := 0;
v_WEEK_BEGIN PSE.WEEK_BEGIN%TYPE;
BEGIN
	-- retrieve IDs into table
	UT.IDS_FROM_STRING(p_ENTITY_IDs,',',v_NUMBER_TABLE);
	UT.GET_RTO_WORK_ID(v_WORK_ID1);
    v_INDEX := v_NUMBER_TABLE.FIRST;
	v_COUNT := 0;
    WHILE v_NUMBER_TABLE.EXISTS(v_INDEX) LOOP
		v_ID := v_NUMBER_TABLE(v_INDEX);
		INSERT INTO RTO_WORK (WORK_ID, WORK_XID)
		  	VALUES (v_WORK_ID1, v_ID);
		v_COUNT := v_COUNT+1;
    	v_INDEX := v_NUMBER_TABLE.NEXT(v_INDEX);
    END LOOP;

    IF v_COUNT = 1 THEN
    	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING THEN
    		-- get the week-begin for this PSE
    		SELECT PSE.WEEK_BEGIN INTO v_WEEK_BEGIN FROM PSE
    			WHERE PSE_ID = (SELECT WORK_XID FROM RTO_WORK WHERE WORK_ID = v_WORK_ID1);
	    	-- if there is only one PSE and its statement interval is the same
	        -- as the roll-up interval, don't do TRUNC on statement date - also
            -- show the statement's end date
            DECLARE
            	v_INTERVAL VARCHAR2(16);
            BEGIN
            	SELECT STATEMENT_INTERVAL INTO v_INTERVAL
                FROM PURCHASING_SELLING_ENTITY
                WHERE PSE_ID = v_ID;
                IF UPPER(SUBSTR(v_INTERVAL,1,2)) = UPPER(SUBSTR(p_INTERVAL,1,2)) THEN
                	v_TRUNC_INTERVAL := 'DD';
                    v_SHOW_END_DATE := p_INTERVAL_DETAIL;
				END IF;
          	EXCEPTION
            	WHEN OTHERS THEN
                	NULL; -- ignore error
            END;
        END IF;
	ELSE
        -- if all selected PSEs have the same week_begin, then use the common week_begin.
		-- Otherwise, use the default (which we choose here to be Friday).
		BEGIN
			SELECT DISTINCT WEEK_BEGIN
			INTO v_WEEK_BEGIN
			FROM PURCHASING_SELLING_ENTITY PSE
			WHERE PSE.PSE_ID IN (SELECT WORK_XID FROM RTO_WORK WHERE WORK_ID = v_WORK_ID1);
		EXCEPTION
			WHEN TOO_MANY_ROWS THEN
				v_WEEK_BEGIN := 'Sunday';
		END;
    END IF;

    v_BEGIN_DATE := PC.BEGIN_DATE_FOR_INTERVAL(p_BEGIN_DATE, p_INTERVAL, v_WEEK_BEGIN);
	-- to get proper end date, first get begin date for the last interval in date range
    v_END_DATE := PC.BEGIN_DATE_FOR_INTERVAL(p_END_DATE, p_INTERVAL, v_WEEK_BEGIN);
	-- then get that interval's end date
    v_END_DATE := PC.END_DATE_FOR_INTERVAL(v_END_DATE, p_INTERVAL);

	UT.TOKENS_FROM_STRING(p_PRODUCTS_COMPONENTS,';',v_STRING_TABLE);
	UT.GET_RTO_WORK_ID(v_WORK_ID2);
    v_INDEX := v_STRING_TABLE.FIRST;
    WHILE v_STRING_TABLE.EXISTS(v_INDEX) LOOP
		UT.IDS_FROM_STRING(v_STRING_TABLE(v_INDEX),',',v_NUMBER_TABLE);
		INSERT INTO RTO_WORK (WORK_ID, WORK_XID, WORK_DATA)
		  	VALUES (v_WORK_ID2, v_NUMBER_TABLE(1), v_NUMBER_TABLE(2));
    	v_INDEX := v_STRING_TABLE.NEXT(v_INDEX);
    END LOOP;

    p_BEGIN_DATE := v_BEGIN_DATE;
    p_END_DATE := v_END_DATE;

   	SELECT BILLING_SUMMARY_RECORD_TYPE(
    	DECODE(p_INTERVAL_DETAIL,0,LOW_DATE,PC.BEGIN_DATE_FOR_INTERVAL(A.STATEMENT_DATE, p_INTERVAL, v_WEEK_BEGIN, A.ENTITY_ID)),
    	DECODE(v_SHOW_END_DATE,0,PC.END_DATE_FOR_INTERVAL(PC.BEGIN_DATE_FOR_INTERVAL(A.STATEMENT_DATE, p_INTERVAL, v_WEEK_BEGIN, A.ENTITY_ID), p_INTERVAL, A.ENTITY_ID),A.STATEMENT_END_DATE),
   		DECODE(p_AGGREGATE_ENTITIES,0,A.ENTITY_ID,-1),
        DECODE(p_AGGREGATE_ENTITIES,0,B.ENTITY_NAME,'All'),
        DECODE(p_SHOW_PRODUCT,0,DECODE(C.PRODUCT_ID,g_ALL,-1,A.PRODUCT_ID),A.PRODUCT_ID),
        DECODE(p_SHOW_PRODUCT,0,DECODE(C.PRODUCT_ID,g_ALL,'All',D.PRODUCT_NAME),D.PRODUCT_NAME),
        DECODE(p_SHOW_COMPONENT,0,DECODE(C.COMPONENT_ID,g_ALL,-1,A.COMPONENT_ID),A.COMPONENT_ID),
        DECODE(p_SHOW_COMPONENT,0,DECODE(C.COMPONENT_ID,g_ALL,'All',E.COMPONENT_NAME),E.COMPONENT_NAME),
        MAX(A.IN_DISPUTE),
        SUM(A.BILL_AMOUNT),
        SUM(A.CHARGE_AMOUNT),
        DECODE(p_AGGREGATE_ENTITIES,0,B.ENTITY_INTERVAL,NULL),
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL
        )
	BULK COLLECT INTO p_RESULTS
	FROM BILLING_STATEMENT A,
    	(SELECT PSE_ID "ENTITY_ID",
         		PSE_NAME "ENTITY_NAME",
	        	NVL(STATEMENT_INTERVAL,'Month') "ENTITY_INTERVAL"
			FROM RTO_WORK, PURCHASING_SELLING_ENTITY
            WHERE UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING
				AND WORK_ID = v_WORK_ID1
             	AND PSE_ID = WORK_XID
			UNION ALL
            SELECT POOL_ID "ENTITY_ID",
             	POOL_NAME "ENTITY_NAME",
	        	'Month' "ENTITY_INTERVAL"
			FROM RTO_WORK, POOL
            WHERE UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_GAS_DELIVERY
				AND WORK_ID = v_WORK_ID1
             	AND POOL_ID = WORK_XID
			UNION ALL
            SELECT BILL_PARTY_ID "ENTITY_ID",
             	BILL_PARTY_NAME "ENTITY_NAME",
	        	'Month' "ENTITY_INTERVAL"
			FROM RTO_WORK, BILL_PARTY
            WHERE UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_POSITION_AND_BILLING
				AND WORK_ID = v_WORK_ID1
             	AND BILL_PARTY_ID = WORK_XID) B,
		(SELECT WORK_XID "PRODUCT_ID", TO_NUMBER(WORK_DATA) "COMPONENT_ID"
        	FROM RTO_WORK
            WHERE WORK_ID = v_WORK_ID2) C,
        PRODUCT D,
        COMPONENT E
	WHERE (D.PRODUCT_ID = C.PRODUCT_ID OR C.PRODUCT_ID = g_ALL)
    	AND (E.COMPONENT_ID = C.COMPONENT_ID OR C.COMPONENT_ID = g_ALL)
    	AND A.ENTITY_ID = B.ENTITY_ID
        AND A.PRODUCT_ID = D.PRODUCT_ID
        AND A.COMPONENT_ID = E.COMPONENT_ID
        AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
        AND A.STATEMENT_STATE = p_STATEMENT_STATE
        AND A.STATEMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
        AND A.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
         					FROM BILLING_STATEMENT
                             WHERE ENTITY_ID = A.ENTITY_ID
                             	AND PRODUCT_ID = A.PRODUCT_ID
                                 AND COMPONENT_ID = A.COMPONENT_ID
                                 AND STATEMENT_TYPE = A.STATEMENT_TYPE
                                 AND STATEMENT_STATE = A.STATEMENT_STATE
                                 AND STATEMENT_DATE = A.STATEMENT_DATE
                                 AND AS_OF_DATE <= p_AS_OF_DATE)
    GROUP BY DECODE(p_INTERVAL_DETAIL,0,LOW_DATE,PC.BEGIN_DATE_FOR_INTERVAL(A.STATEMENT_DATE, p_INTERVAL, v_WEEK_BEGIN, A.ENTITY_ID)),
		DECODE(v_SHOW_END_DATE,0,PC.END_DATE_FOR_INTERVAL(PC.BEGIN_DATE_FOR_INTERVAL(A.STATEMENT_DATE, p_INTERVAL, v_WEEK_BEGIN, A.ENTITY_ID), p_INTERVAL, A.ENTITY_ID),A.STATEMENT_END_DATE),
		DECODE(p_AGGREGATE_ENTITIES,0,A.ENTITY_ID,-1),
        DECODE(p_AGGREGATE_ENTITIES,0,B.ENTITY_NAME,'All'),
        DECODE(p_AGGREGATE_ENTITIES,0,B.ENTITY_INTERVAL,NULL),
        DECODE(p_SHOW_PRODUCT,0,DECODE(C.PRODUCT_ID,g_ALL,-1,A.PRODUCT_ID),A.PRODUCT_ID),
        DECODE(p_SHOW_PRODUCT,0,DECODE(C.PRODUCT_ID,g_ALL,'All',D.PRODUCT_NAME),D.PRODUCT_NAME),
        DECODE(p_SHOW_COMPONENT,0,DECODE(C.COMPONENT_ID,g_ALL,-1,A.COMPONENT_ID),A.COMPONENT_ID),
        DECODE(p_SHOW_COMPONENT,0,DECODE(C.COMPONENT_ID,g_ALL,'All',E.COMPONENT_NAME),E.COMPONENT_NAME)
    ORDER BY DECODE(p_INTERVAL_DETAIL,0,LOW_DATE,PC.BEGIN_DATE_FOR_INTERVAL(A.STATEMENT_DATE, p_INTERVAL, v_WEEK_BEGIN, A.ENTITY_ID)),
		DECODE(p_AGGREGATE_ENTITIES,0,B.ENTITY_NAME,'All'),
        DECODE(p_SHOW_PRODUCT,0,DECODE(C.PRODUCT_ID,g_ALL,'All',D.PRODUCT_NAME),D.PRODUCT_NAME),
        DECODE(p_SHOW_COMPONENT,0,DECODE(C.COMPONENT_ID,g_ALL,'All',E.COMPONENT_NAME),E.COMPONENT_NAME);

	UT.PURGE_RTO_WORK(v_WORK_ID1);
	UT.PURGE_RTO_WORK(v_WORK_ID2);
EXCEPTION
		 WHEN OTHERS THEN
		 	  UT.PURGE_RTO_WORK(v_WORK_ID1);
		 	  UT.PURGE_RTO_WORK(v_WORK_ID2);
			  RAISE;
END GET_SUMMARY_RECORDS;
----------------------------------------------------------------------------------------------------
FUNCTION GET_LAST_UPDATE
	(
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_ENTITY_IDs IN VARCHAR,
    p_PRODUCTS_COMPONENTS IN VARCHAR,
    p_STATEMENT_TYPE IN NUMBER,
    p_STATEMENT_STATE IN NUMBER,
    p_AS_OF_DATE IN DATE
    ) RETURN DATE IS
v_RET DATE;
v_COUNT BINARY_INTEGER;
v_INDEX BINARY_INTEGER;
v_STRING_TABLE GA.STRING_TABLE;
v_NUMBER_TABLE GA.ID_TABLE;
v_SQL VARCHAR2(4000);
BEGIN
	v_SQL := 'SELECT MAX(ENTRY_DATE)'||
			' FROM BILLING_STATEMENT A,'||
		    '   (';
	v_COUNT := 0;
    UT.TOKENS_FROM_STRING(p_PRODUCTS_COMPONENTS,';',v_STRING_TABLE);
    v_INDEX := v_STRING_TABLE.FIRST;
    WHILE v_STRING_TABLE.EXISTS(v_INDEX) LOOP
    	UT.IDS_FROM_STRING(v_STRING_TABLE(v_INDEX),',',v_NUMBER_TABLE);
		IF v_COUNT > 0 THEN
			v_SQL := v_SQL||' UNION ALL ';
		END IF;
       	v_SQL := v_SQL||' SELECT '||v_NUMBER_TABLE(1)||' "PRODUCT_ID",'||
           				'   '||v_NUMBER_TABLE(2)||' "COMPONENT_ID"'||
                        ' FROM DUAL';
		v_COUNT := v_COUNT+1;
    	v_INDEX := v_STRING_TABLE.NEXT(v_INDEX);
    END LOOP;
	v_SQL := v_SQL||' ) B'||
		    ' WHERE ENTITY_ID IN ('||p_ENTITY_IDs||')'||
		    '  AND (B.PRODUCT_ID = :G OR A.PRODUCT_ID = B.PRODUCT_ID)'||
		    '  AND (B.COMPONENT_ID = :G OR A.COMPONENT_ID = B.COMPONENT_ID)'||
		    '  AND STATEMENT_TYPE = :3'||
		    '  AND STATEMENT_STATE = :4'||
		    '  AND STATEMENT_DATE BETWEEN :5 AND :6'||
		    '  AND AS_OF_DATE = (SELECT MAX(AS_OF_DATE)'||
		    '                    FROM BILLING_STATEMENT'||
		    '                    WHERE ENTITY_ID = A.ENTITY_ID'||
		    '                     AND PRODUCT_ID = A.PRODUCT_ID'||
		    '                     AND COMPONENT_ID = A.COMPONENT_ID'||
		    '                     AND STATEMENT_TYPE = A.STATEMENT_TYPE'||
		    '                     AND STATEMENT_STATE = A.STATEMENT_STATE'||
		    '                     AND STATEMENT_DATE = A.STATEMENT_DATE'||
		    '                     AND AS_OF_DATE <= :7)';
	EXECUTE IMMEDIATE v_SQL
    INTO v_RET
    USING g_ALL, g_ALL, p_STATEMENT_TYPE, p_STATEMENT_STATE,
	      p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE;

	RETURN v_RET;
END GET_LAST_UPDATE;
----------------------------------------------------------------------------------------------------
PROCEDURE BILLING_SUMMARY
	(
    p_CALLING_MODULE IN VARCHAR,
    p_MODEL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
    p_INTERVAL IN VARCHAR,
    p_INTERVAL_DETAIL IN NUMBER,
	p_ENTITY_IDs IN VARCHAR,
    p_AGGREGATE_ENTITIES IN NUMBER,
    p_PRODUCTS_COMPONENTS IN VARCHAR,
    p_SHOW_PRODUCT IN NUMBER,
    p_SHOW_COMPONENT IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
    p_PERIOD_BEGIN OUT DATE,
    p_PERIOD_END OUT DATE,
    p_LAST_UPDATE OUT DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
    ) AS
v_RESULTS BILLING_SUMMARY_RECORD_TABLE := BILLING_SUMMARY_RECORD_TABLE();
v_BEGIN_DATE DATE := p_BEGIN_DATE;
v_END_DATE DATE := p_END_DATE;
BEGIN
	p_STATUS := GA.SUCCESS;
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	GET_SUMMARY_RECORDS(p_CALLING_MODULE,v_BEGIN_DATE,v_END_DATE,
    			p_INTERVAL,p_INTERVAL_DETAIL,p_ENTITY_IDs,p_AGGREGATE_ENTITIES,
                p_PRODUCTS_COMPONENTS,p_SHOW_PRODUCT,p_SHOW_COMPONENT,
                p_STATEMENT_TYPE,p_STATEMENT_STATE,p_TIME_ZONE,p_AS_OF_DATE,
                v_RESULTS);

    p_PERIOD_BEGIN := v_BEGIN_DATE;
	p_PERIOD_END := v_END_DATE;

	p_LAST_UPDATE := GET_LAST_UPDATE(v_BEGIN_DATE,v_END_DATE,p_ENTITY_IDs,
    							p_PRODUCTS_COMPONENTS,p_STATEMENT_TYPE,
                                p_STATEMENT_STATE,p_AS_OF_DATE);

	OPEN p_CURSOR FOR
    	SELECT STATEMENT_DATE,
        	STATEMENT_END_DATE,
        	ENTITY_ID,
            ENTITY_NAME,
            STATEMENT_INTERVAL "ENTITY_INTERVAL",
            PRODUCT_ID,
            PRODUCT_NAME,
            COMPONENT_ID,
            COMPONENT_NAME,
            IN_DISPUTE,
            CHARGE_AMOUNT,
            BILL_AMOUNT
        FROM TABLE(CAST(v_RESULTS AS BILLING_SUMMARY_RECORD_TABLE)) X;

EXCEPTION
	WHEN OTHERS THEN
    	NULL_CURSOR(p_CURSOR);
    	p_STATUS := SQLCODE;

END BILLING_SUMMARY;
----------------------------------------------------------------------------------------------------
PROCEDURE BILLING_COMPARISON
	(
    p_CALLING_MODULE IN VARCHAR,
    p_MODEL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
    p_INTERVAL IN VARCHAR,
    p_INTERVAL_DETAIL IN NUMBER,
	p_ENTITY_IDs IN VARCHAR,
    p_AGGREGATE_ENTITIES IN NUMBER,
    p_PRODUCTS_COMPONENTS IN VARCHAR,
    p_SHOW_PRODUCT IN NUMBER,
    p_SHOW_COMPONENT IN NUMBER,
	p_STATEMENT_TYPE1 IN NUMBER,
	p_STATEMENT_STATE1 IN NUMBER,
	p_STATEMENT_TYPE2 IN NUMBER,
	p_STATEMENT_STATE2 IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
    p_PERIOD_BEGIN OUT DATE,
    p_PERIOD_END OUT DATE,
    p_LAST_UPDATE OUT DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
    ) AS
v_RESULTS1 BILLING_SUMMARY_RECORD_TABLE := BILLING_SUMMARY_RECORD_TABLE();
v_RESULTS2 BILLING_SUMMARY_RECORD_TABLE := BILLING_SUMMARY_RECORD_TABLE();
v_BEGIN_DATE DATE := p_BEGIN_DATE;
v_END_DATE DATE := p_END_DATE;
v_LAST_UPDATE1 DATE;
v_LAST_UPDATE2 DATE;
BEGIN
	p_STATUS := GA.SUCCESS;
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	GET_SUMMARY_RECORDS(p_CALLING_MODULE,v_BEGIN_DATE,v_END_DATE,
    			p_INTERVAL,p_INTERVAL_DETAIL,p_ENTITY_IDs,p_AGGREGATE_ENTITIES,
                p_PRODUCTS_COMPONENTS,p_SHOW_PRODUCT,p_SHOW_COMPONENT,
                p_STATEMENT_TYPE1,p_STATEMENT_STATE1,p_TIME_ZONE,p_AS_OF_DATE,
                v_RESULTS1);
	GET_SUMMARY_RECORDS(p_CALLING_MODULE,v_BEGIN_DATE,v_END_DATE,
    			p_INTERVAL,p_INTERVAL_DETAIL,p_ENTITY_IDs,p_AGGREGATE_ENTITIES,
                p_PRODUCTS_COMPONENTS,p_SHOW_PRODUCT,p_SHOW_COMPONENT,
                p_STATEMENT_TYPE2,p_STATEMENT_STATE2,p_TIME_ZONE,p_AS_OF_DATE,
                v_RESULTS2);

    p_PERIOD_BEGIN := v_BEGIN_DATE;
	p_PERIOD_END := v_END_DATE;
    v_LAST_UPDATE1 := GET_LAST_UPDATE(v_BEGIN_DATE,v_END_DATE,p_ENTITY_IDs,
    							p_PRODUCTS_COMPONENTS,p_STATEMENT_TYPE1,
                                p_STATEMENT_STATE1,p_AS_OF_DATE);
    v_LAST_UPDATE2 := GET_LAST_UPDATE(v_BEGIN_DATE,v_END_DATE,p_ENTITY_IDs,
    							p_PRODUCTS_COMPONENTS,p_STATEMENT_TYPE2,
                                p_STATEMENT_STATE2,p_AS_OF_DATE);
	IF NVL(v_LAST_UPDATE1,LOW_DATE) > NVL(v_LAST_UPDATE2,LOW_DATE) THEN
    	p_LAST_UPDATE := v_LAST_UPDATE1;
	ELSE
    	p_LAST_UPDATE := v_LAST_UPDATE2;
	END IF;

	OPEN p_CURSOR FOR
    	SELECT A.STATEMENT_DATE,
        	NVL(B.STATEMENT_END_DATE,C.STATEMENT_END_DATE) "STATEMENT_END_DATE",
        	A.ENTITY_ID,
            A.ENTITY_NAME,
            A.STATEMENT_INTERVAL "ENTITY_INTERVAL",
            A.PRODUCT_ID,
            A.PRODUCT_NAME,
            A.COMPONENT_ID,
            A.COMPONENT_NAME,
            NVL(B.IN_DISPUTE,0) "IN_DISPUTE",
            B.CHARGE_AMOUNT "CHARGE_AMOUNT1",
            C.CHARGE_AMOUNT "CHARGE_AMOUNT2",
            NVL(C.CHARGE_AMOUNT,0)-NVL(B.CHARGE_AMOUNT,0) "CHARGE_DIFFERENCE",
            B.BILL_AMOUNT "BILL_AMOUNT1",
            C.BILL_AMOUNT "BILL_AMOUNT2",
            NVL(C.BILL_AMOUNT,0)-NVL(B.BILL_AMOUNT,0) "BILL_DIFFERENCE"
        FROM (SELECT DISTINCT STATEMENT_DATE, ENTITY_ID, ENTITY_NAME,
        				STATEMENT_INTERVAL, PRODUCT_ID, PRODUCT_NAME,
                        COMPONENT_ID, COMPONENT_NAME
				FROM TABLE(CAST(v_RESULTS1 AS BILLING_SUMMARY_RECORD_TABLE)) X
  	            UNION
				SELECT DISTINCT STATEMENT_DATE, ENTITY_ID, ENTITY_NAME,
        				STATEMENT_INTERVAL, PRODUCT_ID, PRODUCT_NAME,
                        COMPONENT_ID, COMPONENT_NAME
				FROM TABLE(CAST(v_RESULTS2 AS BILLING_SUMMARY_RECORD_TABLE)) Y) A,
        	TABLE(CAST(v_RESULTS1 AS BILLING_SUMMARY_RECORD_TABLE)) B,
        	TABLE(CAST(v_RESULTS2 AS BILLING_SUMMARY_RECORD_TABLE)) C
		WHERE B.STATEMENT_DATE(+) = A.STATEMENT_DATE
        	AND B.ENTITY_ID(+) = A.ENTITY_ID
            AND B.PRODUCT_ID(+) = A.PRODUCT_ID
            AND B.COMPONENT_ID(+) = A.COMPONENT_ID
            AND C.STATEMENT_DATE(+) = A.STATEMENT_DATE
        	AND C.ENTITY_ID(+) = A.ENTITY_ID
            AND C.PRODUCT_ID(+) = A.PRODUCT_ID
            AND C.COMPONENT_ID(+) = A.COMPONENT_ID;

EXCEPTION
	WHEN OTHERS THEN
    	NULL_CURSOR(p_CURSOR);
    	p_STATUS := SQLCODE;

END BILLING_COMPARISON;
----------------------------------------------------------------------------------------------------
FUNCTION BILL_PARTY_IS_INVOICE_DETAIL
	(
	p_BILL_PARTY_ID IN NUMBER
	) RETURN NUMBER IS

v_IS_INVOICE_DETAIL NUMBER(1);

BEGIN
    SELECT NVL(IS_INVOICE_DETAIL,0)
	INTO v_IS_INVOICE_DETAIL
	FROM BILL_PARTY
	WHERE BILL_PARTY_ID = p_BILL_PARTY_ID;

	RETURN v_IS_INVOICE_DETAIL;

EXCEPTION
	WHEN OTHERS THEN
		RETURN g_NOT_ASSIGNED;

END BILL_PARTY_IS_INVOICE_DETAIL;
----------------------------------------------------------------------------------------------------
FUNCTION PSE_IS_INVOICE_DETAIL
	(
	p_ENTITY_ID IN NUMBER
	) RETURN NUMBER IS

v_IS_INVOICE_DETAIL NUMBER(1);

BEGIN
	IF GA.ENABLE_PSE_DETAILED_INVOICES THEN
		v_IS_INVOICE_DETAIL := 1;
	ELSE
		v_IS_INVOICE_DETAIL := 0;
	END IF;

	RETURN v_IS_INVOICE_DETAIL;

EXCEPTION
	WHEN OTHERS THEN
		RETURN g_NOT_ASSIGNED;

END PSE_IS_INVOICE_DETAIL;
----------------------------------------------------------------------------------------------------
FUNCTION ENTITY_IS_INVOICE_DETAIL
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER
	) RETURN NUMBER IS

v_IS_INVOICE_DETAIL NUMBER(1);

BEGIN

	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_POSITION_AND_BILLING THEN
		RETURN BILL_PARTY_IS_INVOICE_DETAIL(p_ENTITY_ID);
	ELSIF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) IN (g_SCHEDULING, g_GAS_DELIVERY) THEN
		RETURN PSE_IS_INVOICE_DETAIL(p_ENTITY_ID);
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		RETURN g_NOT_ASSIGNED;

END ENTITY_IS_INVOICE_DETAIL;
----------------------------------------------------------------------------------------------------
FUNCTION GET_INVOICE
	(
	p_INVOICE_ID IN NUMBER
	) RETURN INVOICE%ROWTYPE IS

v_INVOICE INVOICE%ROWTYPE;

BEGIN

	 SELECT *
	 INTO v_INVOICE
	 FROM INVOICE
	 WHERE INVOICE_ID = p_INVOICE_ID;

	RETURN v_INVOICE;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		RETURN v_INVOICE;
	WHEN OTHERS THEN
		RAISE;
END GET_INVOICE;
---------------------------------------------------------------------------------------------------
FUNCTION GET_BILL_PARTY_NAME
	(
	p_BILL_PARTY_ID IN NUMBER
	) RETURN VARCHAR IS

v_BILL_PARTY_NAME VARCHAR(32);

BEGIN

	 SELECT BILL_PARTY_NAME
	 INTO v_BILL_PARTY_NAME
	 FROM BILL_PARTY
	 WHERE BILL_PARTY_ID = p_BILL_PARTY_ID;

	RETURN v_BILL_PARTY_NAME;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		RETURN '?';
	WHEN OTHERS THEN
		RAISE;
END GET_BILL_PARTY_NAME;
---------------------------------------------------------------------------------------------------
PROCEDURE ROLLBACK_SERVICE_CONSUMPTION
	(
	p_ENTITY_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_MONTH IN DATE
	) AS

v_BILL_PARTY_NAME VARCHAR(32) := GET_BILL_PARTY_NAME(p_ENTITY_ID);
v_COUNT PLS_INTEGER;
v_SYSDATE DATE := SYSDATE;
v_USER VARCHAR(32) := USER;

BEGIN

	UPDATE SERVICE_CONSUMPTION
	SET BILL_PROCESSED_DATE = NULL
	WHERE CONSUMPTION_ID IN
		(SELECT CONSUMPTION_ID FROM SERVICE_CONSUMPTION_ROLLBACK
		WHERE STATEMENT_TYPE = p_STATEMENT_TYPE
			AND STATEMENT_MONTH = p_STATEMENT_MONTH
			AND ENTITY_ID = p_ENTITY_ID);

	v_COUNT := SQL%ROWCOUNT;

	INSERT INTO ENTITY_AUDIT_TRAIL(ENTITY_DOMAIN_ID, ENTITY_ID, KEY_DATE_1, KEY_DATE_2, KEY_STRING, ALPHA_KEY_ID, BETA_KEY_ID, WHAT_TABLE, WHAT_ATTRIBUTE, WHEN_CHANGED, WHO_CHANGED, WHY_CHANGED, ATTRIBUTE_TYPE, OLD_VALUE, NEW_VALUE)
	SELECT -280, CONSUMPTION_ID, STATEMENT_MONTH, LOW_DATE, '?', ENTITY_ID, g_NOT_ASSIGNED, 'SERVICE_CONSUMPTION_ROLLBACK', 'BILL_PROCESSED_DATE', v_SYSDATE, v_USER, 'ROLLBACK', 'DATE', 'VOID', 'NULL'
	FROM SERVICE_CONSUMPTION_ROLLBACK
	WHERE STATEMENT_TYPE = p_STATEMENT_TYPE
		AND STATEMENT_MONTH = p_STATEMENT_MONTH
		AND ENTITY_ID = p_ENTITY_ID;

	UPDATE SERVICE_CONSUMPTION_ROLLBACK
	SET BILL_PROCESSED_DATE = NULL
	WHERE STATEMENT_TYPE = p_STATEMENT_TYPE
		AND STATEMENT_MONTH = p_STATEMENT_MONTH
		AND ENTITY_ID = p_ENTITY_ID;

	g_EVENT_TEXT := v_BILL_PARTY_NAME || ', STATEMENT_TYPE=' || TO_CHAR(p_STATEMENT_TYPE) || ', STATEMENT_MONTH=' || TO_CHAR(p_STATEMENT_MONTH) || ', ' || TO_CHAR(v_COUNT) || ' Records Processed.';
	POST_TO_APP_EVENT_LOG (g_DOMAIN_NAME, g_APP_NAME, 'Rollback Service Consumption', 'NOTICE', 'LOG', v_BILL_PARTY_NAME, TO_CHAR(p_ENTITY_ID), g_EVENT_TEXT);

EXCEPTION
	WHEN OTHERS THEN
		g_EVENT_TEXT := 'Exception: ' || SQLERRM || ' (' || TO_CHAR(SQLCODE) || ')';
		POST_TO_APP_EVENT_LOG (g_DOMAIN_NAME, g_APP_NAME, 'Rollback Service Consumption', 'ERROR', 'LOG', v_BILL_PARTY_NAME, TO_CHAR(p_ENTITY_ID), g_EVENT_TEXT);

END ROLLBACK_SERVICE_CONSUMPTION;
---------------------------------------------------------------------------------------------------
PROCEDURE DELETE_INVOICE_USER_LINE_ITEM
	(
    p_INVOICE_USER_LINE_ITEM IN INVOICE_USER_LINE_ITEM%ROWTYPE
    ) AS
BEGIN
	DELETE INVOICE_USER_LINE_ITEM
    WHERE ENTITY_ID = p_INVOICE_USER_LINE_ITEM.ENTITY_ID
    	AND STATEMENT_TYPE = p_INVOICE_USER_LINE_ITEM.STATEMENT_TYPE
        AND STATEMENT_STATE = p_INVOICE_USER_LINE_ITEM.STATEMENT_STATE
        AND BEGIN_DATE = p_INVOICE_USER_LINE_ITEM.BEGIN_DATE
        AND LINE_ITEM_NAME = p_INVOICE_USER_LINE_ITEM.LINE_ITEM_NAME;
END DELETE_INVOICE_USER_LINE_ITEM;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_TAX_USER_LINE_ITEM
	(
    p_INVOICE_USER_LINE_ITEM IN INVOICE_USER_LINE_ITEM%ROWTYPE,
    p_TAX_USER_LINE_ITEM OUT INVOICE_USER_LINE_ITEM%ROWTYPE
    ) AS
v_LINE_ITEM_NAME VARCHAR2(32);
BEGIN
	SELECT * INTO p_TAX_USER_LINE_ITEM
    FROM INVOICE_USER_LINE_ITEM
    WHERE ENTITY_ID = p_INVOICE_USER_LINE_ITEM.ENTITY_ID
    	AND STATEMENT_TYPE = p_INVOICE_USER_LINE_ITEM.STATEMENT_TYPE
        AND STATEMENT_STATE = p_INVOICE_USER_LINE_ITEM.STATEMENT_STATE
        AND BEGIN_DATE = p_INVOICE_USER_LINE_ITEM.BEGIN_DATE
        AND LINE_ITEM_TYPE = 'X'
        AND NVL(TAX_COMPONENT_ID,0) = p_INVOICE_USER_LINE_ITEM.TAX_COMPONENT_ID;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
    	p_TAX_USER_LINE_ITEM.ENTITY_ID := p_INVOICE_USER_LINE_ITEM.ENTITY_ID;
        p_TAX_USER_LINE_ITEM.STATEMENT_TYPE := p_INVOICE_USER_LINE_ITEM.STATEMENT_TYPE;
        p_TAX_USER_LINE_ITEM.STATEMENT_STATE := p_INVOICE_USER_LINE_ITEM.STATEMENT_STATE;
        p_TAX_USER_LINE_ITEM.BEGIN_DATE := p_INVOICE_USER_LINE_ITEM.BEGIN_DATE;
        SELECT 'Manual Line Item Tax - '||COMPONENT_NAME
        INTO p_TAX_USER_LINE_ITEM.LINE_ITEM_NAME
        FROM COMPONENT
        WHERE COMPONENT_ID = p_INVOICE_USER_LINE_ITEM.TAX_COMPONENT_ID;
        p_TAX_USER_LINE_ITEM.LINE_ITEM_CATEGORY := p_INVOICE_USER_LINE_ITEM.LINE_ITEM_CATEGORY;
        p_TAX_USER_LINE_ITEM.LINE_ITEM_TYPE := 'X';
        p_TAX_USER_LINE_ITEM.LINE_ITEM_QUANTITY := 0;
        p_TAX_USER_LINE_ITEM.LINE_ITEM_RATE := NULL;
        p_TAX_USER_LINE_ITEM.LINE_ITEM_AMOUNT := 0;
        p_TAX_USER_LINE_ITEM.LINE_ITEM_BILL_AMOUNT := 0;
        p_TAX_USER_LINE_ITEM.LINE_ITEM_POSTED_DATE := SYSDATE;
        p_TAX_USER_LINE_ITEM.IS_TAXED := 0;
        p_TAX_USER_LINE_ITEM.TAX_COMPONENT_ID := p_INVOICE_USER_LINE_ITEM.TAX_COMPONENT_ID;
        p_TAX_USER_LINE_ITEM.TAX_GEOGRAPHY_ID := NULL;
END GET_TAX_USER_LINE_ITEM;
---------------------------------------------------------------------------------------------------
FUNCTION COMPUTE_TAXES
	(
    p_AMOUNT IN NUMBER,
    p_DATE IN DATE,
    p_TAX_COMPONENT_ID IN NUMBER,
    p_GEOGRAPHY_ID IN NUMBER,
    p_STATEMENT_TYPE IN NUMBER
    ) RETURN NUMBER IS
v_TAX_AMOUNT NUMBER := 0;
v_CUR_TAX_AMOUNT NUMBER := 0;
v_COMPONENT COMPONENT%ROWTYPE;
CURSOR c_TAX_AREAS IS
	SELECT GEOGRAPHY_ID
	    FROM GEOGRAPHY
	    START WITH GEOGRAPHY_ID = p_GEOGRAPHY_ID
	    CONNECT BY PRIOR PARENT_GEOGRAPHY_ID = GEOGRAPHY_ID;
BEGIN
	--get component details
	SELECT * INTO v_COMPONENT
    FROM COMPONENT
    WHERE COMPONENT_ID = p_TAX_COMPONENT_ID;
    --loop through
    FOR v_TAX_AREA IN c_TAX_AREAS LOOP
		BEGIN
        	IF UPPER(v_COMPONENT.RATE_STRUCTURE) = 'FLAT' THEN
        		SELECT GREATEST(CHARGE_MIN, p_AMOUNT*RATE)
        		INTO v_CUR_TAX_AMOUNT
        		FROM COMPONENT_FLAT_RATE
        		WHERE COMPONENT_ID = p_TAX_COMPONENT_ID
                    AND SUB_COMPONENT_TYPE = 'GEOGRAPHY'
                    AND SUB_COMPONENT_ID = v_TAX_AREA.GEOGRAPHY_ID
                    AND p_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE,HIGH_DATE);
        	ELSIF UPPER(v_COMPONENT.RATE_STRUCTURE) = 'MARKET' THEN
        		SELECT p_AMOUNT*(B.PRICE*NVL(A.RATE_MULTIPLIER,1)+NVL(A.RATE_ADDER,0))
        		INTO v_CUR_TAX_AMOUNT
        		FROM COMPONENT_MARKET_PRICE A,
        			MARKET_PRICE_VALUE B
        		WHERE A.COMPONENT_ID(+) = p_TAX_COMPONENT_ID
                    AND A.SUB_COMPONENT_TYPE(+) = 'GEOGRAPHY'
                    AND A.SUB_COMPONENT_ID(+) = v_TAX_AREA.GEOGRAPHY_ID
        			AND p_DATE(+) BETWEEN A.BEGIN_DATE AND NVL(A.END_DATE,HIGH_DATE)
        			AND B.MARKET_PRICE_ID = v_COMPONENT.MARKET_PRICE_ID
        			AND B.PRICE_CODE = DECODE(p_STATEMENT_TYPE,1,'F',2,'P','A')
        			AND B.PRICE_DATE = p_DATE
        			AND B.AS_OF_DATE =
        				(SELECT MAX(AS_OF_DATE)
        				FROM MARKET_PRICE_VALUE
        				WHERE MARKET_PRICE_ID = B.MARKET_PRICE_ID
        					AND PRICE_CODE = B.PRICE_CODE
        					AND PRICE_DATE = B.PRICE_DATE
        					AND AS_OF_DATE <= SYSDATE);
        	ELSIF UPPER(v_COMPONENT.RATE_STRUCTURE) = 'BLOCK' THEN
        		SELECT GREATEST(A.CHARGE_MIN, A.RATE*p_AMOUNT)
        		INTO v_CUR_TAX_AMOUNT
        		FROM COMPONENT_BLOCK_RATE A
        		WHERE A.COMPONENT_ID = p_TAX_COMPONENT_ID
                    AND A.SUB_COMPONENT_TYPE = 'GEOGRAPHY'
                    AND A.SUB_COMPONENT_ID = v_TAX_AREA.GEOGRAPHY_ID
        			AND p_DATE BETWEEN A.BEGIN_DATE AND NVL(A.END_DATE,HIGH_DATE)
        			AND p_AMOUNT > A.BLOCK_MIN-1
        			AND p_AMOUNT <= NVL(A.BLOCK_MAX,p_AMOUNT);
        	ELSIF UPPER(v_COMPONENT.RATE_STRUCTURE) = 'TIERED' THEN
        		SELECT SUM(GREATEST(A.CHARGE_MIN, A.RATE*(LEAST(NVL(A.BLOCK_MAX,p_AMOUNT), p_AMOUNT)-DECODE(A.BLOCK_MIN,0,0,A.BLOCK_MIN-1))))
        		INTO v_CUR_TAX_AMOUNT
        		FROM COMPONENT_BLOCK_RATE A
        		WHERE A.COMPONENT_ID = p_TAX_COMPONENT_ID
                    AND A.SUB_COMPONENT_TYPE = 'GEOGRAPHY'
                    AND A.SUB_COMPONENT_ID = v_TAX_AREA.GEOGRAPHY_ID
        			AND p_DATE BETWEEN A.BEGIN_DATE AND NVL(A.END_DATE,HIGH_DATE)
        			AND p_AMOUNT > A.BLOCK_MIN-1;
    		ELSE
    			v_CUR_TAX_AMOUNT := 0;
        	END IF;
		EXCEPTION
			WHEN NO_DATA_FOUND OR TOO_MANY_ROWS THEN
				v_CUR_TAX_AMOUNT := 0;
		END;
		v_TAX_AMOUNT := NVL(v_TAX_AMOUNT,0)+NVL(v_CUR_TAX_AMOUNT,0);
    END LOOP;
    RETURN v_TAX_AMOUNT;
END COMPUTE_TAXES;
---------------------------------------------------------------------------------------------------
PROCEDURE UPDATE_TAX_FOR_USER_LINE_ITEM
	(
    p_OLD_LINE_ITEM IN INVOICE_USER_LINE_ITEM%ROWTYPE,
    p_NEW_LINE_ITEM IN INVOICE_USER_LINE_ITEM%ROWTYPE,
    p_INSERTING IN BOOLEAN,
    p_UPDATING IN BOOLEAN,
    p_DELETING IN BOOLEAN
    ) AS
v_CHARGE_TAX NUMBER;
v_BILL_TAX NUMBER;
v_REMOVING_OLD BOOLEAN := FALSE;
v_ADDING_NEW BOOLEAN := FALSE;
v_TAX_LINE_ITEM INVOICE_USER_LINE_ITEM%ROWTYPE;
BEGIN
	-- don't bother w/ taxing taxes
	IF p_NEW_LINE_ITEM.LINE_ITEM_TYPE = 'X' AND p_OLD_LINE_ITEM.LINE_ITEM_TYPE = 'X' THEN
    	RETURN;
    END IF;

	IF (p_INSERTING AND p_NEW_LINE_ITEM.IS_TAXED <> 0) OR
       (p_UPDATING AND p_OLD_LINE_ITEM.IS_TAXED = 0 AND p_NEW_LINE_ITEM.IS_TAXED <> 0) THEN
    	-- add new taxes
        v_ADDING_NEW := TRUE;
    ELSIF (p_DELETING AND p_OLD_LINE_ITEM.IS_TAXED <> 0) OR
    	  (p_UPDATING AND p_OLD_LINE_ITEM.IS_TAXED <> 0 AND p_NEW_LINE_ITEM.IS_TAXED = 0) THEN
        v_REMOVING_OLD := TRUE;
    ELSIF p_UPDATING AND p_NEW_LINE_ITEM.IS_TAXED <> 0 THEN
    	v_REMOVING_OLD := TRUE;
        v_ADDING_NEW := TRUE;
	END IF;

    IF v_REMOVING_OLD AND p_OLD_LINE_ITEM.TAX_COMPONENT_ID > 0 THEN
       	v_CHARGE_TAX := COMPUTE_TAXES(p_OLD_LINE_ITEM.LINE_ITEM_AMOUNT, p_OLD_LINE_ITEM.BEGIN_DATE, p_OLD_LINE_ITEM.TAX_COMPONENT_ID, p_OLD_LINE_ITEM.TAX_GEOGRAPHY_ID, p_OLD_LINE_ITEM.STATEMENT_TYPE);
       	v_BILL_TAX := COMPUTE_TAXES(p_OLD_LINE_ITEM.LINE_ITEM_BILL_AMOUNT, p_OLD_LINE_ITEM.BEGIN_DATE, p_OLD_LINE_ITEM.TAX_COMPONENT_ID, p_OLD_LINE_ITEM.TAX_GEOGRAPHY_ID, p_OLD_LINE_ITEM.STATEMENT_TYPE);
        GET_TAX_USER_LINE_ITEM (p_OLD_LINE_ITEM, v_TAX_LINE_ITEM);
        v_TAX_LINE_ITEM.LINE_ITEM_QUANTITY := v_TAX_LINE_ITEM.LINE_ITEM_QUANTITY-p_OLD_LINE_ITEM.LINE_ITEM_AMOUNT;
        v_TAX_LINE_ITEM.LINE_ITEM_AMOUNT := v_TAX_LINE_ITEM.LINE_ITEM_AMOUNT-v_CHARGE_TAX;
        v_TAX_LINE_ITEM.LINE_ITEM_BILL_AMOUNT := v_TAX_LINE_ITEM.LINE_ITEM_BILL_AMOUNT-v_BILL_TAX;
        IF v_TAX_LINE_ITEM.LINE_ITEM_QUANTITY = 0 THEN
        	v_TAX_LINE_ITEM.LINE_ITEM_RATE := NULL;
		ELSE
        	v_TAX_LINE_ITEM.LINE_ITEM_RATE := v_TAX_LINE_ITEM.LINE_ITEM_AMOUNT / v_TAX_LINE_ITEM.LINE_ITEM_QUANTITY;
        END IF;
        IF v_TAX_LINE_ITEM.LINE_ITEM_AMOUNT = 0 AND v_TAX_LINE_ITEM.LINE_ITEM_BILL_AMOUNT = 0 THEN
        	-- if tax amount goes to zero, remove tax entry
            DELETE_INVOICE_USER_LINE_ITEM (v_TAX_LINE_ITEM);
        ELSE
	        PUT_INVOICE_USER_LINE_ITEM (v_TAX_LINE_ITEM);
		END IF;
    END IF;
    IF v_ADDING_NEW AND p_NEW_LINE_ITEM.TAX_COMPONENT_ID > 0 THEN
       	v_CHARGE_TAX := COMPUTE_TAXES(p_NEW_LINE_ITEM.LINE_ITEM_AMOUNT, p_NEW_LINE_ITEM.BEGIN_DATE, p_NEW_LINE_ITEM.TAX_COMPONENT_ID, p_NEW_LINE_ITEM.TAX_GEOGRAPHY_ID, p_NEW_LINE_ITEM.STATEMENT_TYPE);
       	v_BILL_TAX := COMPUTE_TAXES(p_NEW_LINE_ITEM.LINE_ITEM_BILL_AMOUNT, p_NEW_LINE_ITEM.BEGIN_DATE, p_NEW_LINE_ITEM.TAX_COMPONENT_ID, p_NEW_LINE_ITEM.TAX_GEOGRAPHY_ID, p_NEW_LINE_ITEM.STATEMENT_TYPE);
        GET_TAX_USER_LINE_ITEM (p_NEW_LINE_ITEM, v_TAX_LINE_ITEM);
        v_TAX_LINE_ITEM.LINE_ITEM_QUANTITY := v_TAX_LINE_ITEM.LINE_ITEM_QUANTITY+p_NEW_LINE_ITEM.LINE_ITEM_AMOUNT;
        v_TAX_LINE_ITEM.LINE_ITEM_AMOUNT := v_TAX_LINE_ITEM.LINE_ITEM_AMOUNT+v_CHARGE_TAX;
        v_TAX_LINE_ITEM.LINE_ITEM_BILL_AMOUNT := v_TAX_LINE_ITEM.LINE_ITEM_BILL_AMOUNT+v_BILL_TAX;
        IF v_TAX_LINE_ITEM.LINE_ITEM_QUANTITY = 0 THEN
        	v_TAX_LINE_ITEM.LINE_ITEM_RATE := NULL;
		ELSE
        	v_TAX_LINE_ITEM.LINE_ITEM_RATE := v_TAX_LINE_ITEM.LINE_ITEM_AMOUNT / v_TAX_LINE_ITEM.LINE_ITEM_QUANTITY;
        END IF;
        IF v_TAX_LINE_ITEM.LINE_ITEM_AMOUNT = 0 AND v_TAX_LINE_ITEM.LINE_ITEM_BILL_AMOUNT = 0 THEN
        	-- if tax amount goes to zero, remove tax entry
            DELETE_INVOICE_USER_LINE_ITEM (v_TAX_LINE_ITEM);
        ELSE
	        PUT_INVOICE_USER_LINE_ITEM (v_TAX_LINE_ITEM);
		END IF;
    END IF;
END UPDATE_TAX_FOR_USER_LINE_ITEM;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_INVOICE_LINE_ITEM
    (
	p_INVOICE_LINE_ITEM IN INVOICE_LINE_ITEM%ROWTYPE,
    p_OLD_LINE_ITEM_NAME IN VARCHAR
	) AS

-- Can only update and delete of RTO generated line items.

BEGIN

	UPDATE INVOICE_LINE_ITEM SET
    	LINE_ITEM_NAME = p_INVOICE_LINE_ITEM.LINE_ITEM_NAME,
        LINE_ITEM_CATEGORY = p_INVOICE_LINE_ITEM.LINE_ITEM_CATEGORY,
		LINE_ITEM_QUANTITY = p_INVOICE_LINE_ITEM.LINE_ITEM_QUANTITY,
		LINE_ITEM_RATE = p_INVOICE_LINE_ITEM.LINE_ITEM_RATE,
		LINE_ITEM_AMOUNT = p_INVOICE_LINE_ITEM.LINE_ITEM_AMOUNT,
		LINE_ITEM_BILL_AMOUNT = p_INVOICE_LINE_ITEM.LINE_ITEM_BILL_AMOUNT,
        DEFAULT_DISPLAY = p_INVOICE_LINE_ITEM.DEFAULT_DISPLAY,
		ENTRY_DATE = SYSDATE
	WHERE INVOICE_ID = p_INVOICE_LINE_ITEM.INVOICE_ID
		AND LINE_ITEM_NAME = p_OLD_LINE_ITEM_NAME;

END PUT_INVOICE_LINE_ITEM;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_INVOICE_USER_LINE_ITEM
    (
	p_INVOICE_USER_LINE_ITEM IN OUT INVOICE_USER_LINE_ITEM%ROWTYPE,
    p_OLD_LINE_ITEM_NAME IN VARCHAR
	) AS
v_OLD_INVOICE_USER_LINE_ITEM INVOICE_USER_LINE_ITEM%ROWTYPE;
BEGIN

	BEGIN
    	SELECT * INTO v_OLD_INVOICE_USER_LINE_ITEM
        FROM INVOICE_USER_LINE_ITEM
		WHERE ENTITY_ID = p_INVOICE_USER_LINE_ITEM.ENTITY_ID
			AND STATEMENT_TYPE = p_INVOICE_USER_LINE_ITEM.STATEMENT_TYPE
			AND STATEMENT_STATE = p_INVOICE_USER_LINE_ITEM.STATEMENT_STATE
			AND BEGIN_DATE = p_INVOICE_USER_LINE_ITEM.BEGIN_DATE
		    AND LINE_ITEM_NAME = p_OLD_LINE_ITEM_NAME;
    EXCEPTION
    	WHEN NO_DATA_FOUND THEN
			NULL;
    END;
    -- make sure not to lose component ID info on updates of auto-tax lines
    IF v_OLD_INVOICE_USER_LINE_ITEM.LINE_ITEM_TYPE = 'X' AND
        p_INVOICE_USER_LINE_ITEM.LINE_ITEM_TYPE = 'X' THEN
		p_INVOICE_USER_LINE_ITEM.IS_TAXED := 0;
        p_INVOICE_USER_LINE_ITEM.TAX_COMPONENT_ID := v_OLD_INVOICE_USER_LINE_ITEM.TAX_COMPONENT_ID;
		p_INVOICE_USER_LINE_ITEM.TAX_GEOGRAPHY_ID := NULL;
	END IF;

	UPDATE INVOICE_USER_LINE_ITEM SET
    	LINE_ITEM_NAME = p_INVOICE_USER_LINE_ITEM.LINE_ITEM_NAME,
        LINE_ITEM_CATEGORY = p_INVOICE_USER_LINE_ITEM.LINE_ITEM_CATEGORY,
		LINE_ITEM_TYPE = p_INVOICE_USER_LINE_ITEM.LINE_ITEM_TYPE,
		LINE_ITEM_QUANTITY = p_INVOICE_USER_LINE_ITEM.LINE_ITEM_QUANTITY,
		LINE_ITEM_RATE = p_INVOICE_USER_LINE_ITEM.LINE_ITEM_RATE,
		LINE_ITEM_AMOUNT = p_INVOICE_USER_LINE_ITEM.LINE_ITEM_AMOUNT,
		LINE_ITEM_BILL_AMOUNT = p_INVOICE_USER_LINE_ITEM.LINE_ITEM_BILL_AMOUNT,
        DEFAULT_DISPLAY = p_INVOICE_USER_LINE_ITEM.DEFAULT_DISPLAY,
		LINE_ITEM_POSTED_DATE = p_INVOICE_USER_LINE_ITEM.LINE_ITEM_POSTED_DATE,
        INVOICE_GROUP_ID = p_INVOICE_USER_LINE_ITEM.INVOICE_GROUP_ID,
        INVOICE_GROUP_ORDER = p_INVOICE_USER_LINE_ITEM.INVOICE_GROUP_ORDER,
        EXCLUDE_FROM_INVOICE_TOTAL = p_INVOICE_USER_LINE_ITEM.EXCLUDE_FROM_INVOICE_TOTAL,
        IS_TAXED = p_INVOICE_USER_LINE_ITEM.IS_TAXED,
        TAX_COMPONENT_ID = p_INVOICE_USER_LINE_ITEM.TAX_COMPONENT_ID,
        TAX_GEOGRAPHY_ID = p_INVOICE_USER_LINE_ITEM.TAX_GEOGRAPHY_ID,
		ENTRY_DATE = SYSDATE
	WHERE ENTITY_ID = p_INVOICE_USER_LINE_ITEM.ENTITY_ID
		AND STATEMENT_TYPE = p_INVOICE_USER_LINE_ITEM.STATEMENT_TYPE
		AND STATEMENT_STATE = p_INVOICE_USER_LINE_ITEM.STATEMENT_STATE
		AND BEGIN_DATE = p_INVOICE_USER_LINE_ITEM.BEGIN_DATE
	    AND LINE_ITEM_NAME = p_OLD_LINE_ITEM_NAME;

	IF SQL%NOTFOUND THEN
	    INSERT INTO INVOICE_USER_LINE_ITEM (
			ENTITY_ID,
			STATEMENT_TYPE,
			STATEMENT_STATE,
			BEGIN_DATE,
			LINE_ITEM_TYPE,
			LINE_ITEM_NAME,
            LINE_ITEM_CATEGORY,
			LINE_ITEM_QUANTITY,
			LINE_ITEM_RATE,
			LINE_ITEM_AMOUNT,
			LINE_ITEM_BILL_AMOUNT,
            DEFAULT_DISPLAY,
			LINE_ITEM_POSTED_DATE,
            INVOICE_GROUP_ID,
            INVOICE_GROUP_ORDER,
            EXCLUDE_FROM_INVOICE_TOTAL,
            IS_TAXED,
            TAX_COMPONENT_ID,
            TAX_GEOGRAPHY_ID,
			ENTRY_DATE)
		VALUES (
			p_INVOICE_USER_LINE_ITEM.ENTITY_ID,
			p_INVOICE_USER_LINE_ITEM.STATEMENT_TYPE,
			p_INVOICE_USER_LINE_ITEM.STATEMENT_STATE,
			p_INVOICE_USER_LINE_ITEM.BEGIN_DATE,
			p_INVOICE_USER_LINE_ITEM.LINE_ITEM_TYPE,
			p_INVOICE_USER_LINE_ITEM.LINE_ITEM_NAME,
            p_INVOICE_USER_LINE_ITEM.LINE_ITEM_CATEGORY,
			p_INVOICE_USER_LINE_ITEM.LINE_ITEM_QUANTITY,
			p_INVOICE_USER_LINE_ITEM.LINE_ITEM_RATE,
			p_INVOICE_USER_LINE_ITEM.LINE_ITEM_AMOUNT,
			p_INVOICE_USER_LINE_ITEM.LINE_ITEM_BILL_AMOUNT,
            p_INVOICE_USER_LINE_ITEM.DEFAULT_DISPLAY,
			p_INVOICE_USER_LINE_ITEM.LINE_ITEM_POSTED_DATE,
            p_INVOICE_USER_LINE_ITEM.INVOICE_GROUP_ID,
            p_INVOICE_USER_LINE_ITEM.INVOICE_GROUP_ORDER,
            p_INVOICE_USER_LINE_ITEM.EXCLUDE_FROM_INVOICE_TOTAL,
            p_INVOICE_USER_LINE_ITEM.IS_TAXED,
            p_INVOICE_USER_LINE_ITEM.TAX_COMPONENT_ID,
            p_INVOICE_USER_LINE_ITEM.TAX_GEOGRAPHY_ID,
			SYSDATE);
		-- inserting
		UPDATE_TAX_FOR_USER_LINE_ITEM (v_OLD_INVOICE_USER_LINE_ITEM, p_INVOICE_USER_LINE_ITEM, TRUE, FALSE, FALSE);
	ELSE
    	-- updating
		UPDATE_TAX_FOR_USER_LINE_ITEM (v_OLD_INVOICE_USER_LINE_ITEM, p_INVOICE_USER_LINE_ITEM, FALSE, TRUE, FALSE);
	END IF;

END PUT_INVOICE_USER_LINE_ITEM;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_INVOICE_USER_LINE_ITEM
    (
	p_INVOICE_USER_LINE_ITEM IN OUT INVOICE_USER_LINE_ITEM%ROWTYPE
	) AS
BEGIN
	PUT_INVOICE_USER_LINE_ITEM (p_INVOICE_USER_LINE_ITEM, p_INVOICE_USER_LINE_ITEM.LINE_ITEM_NAME);
END PUT_INVOICE_USER_LINE_ITEM;
---------------------------------------------------------------------------------------------------
PROCEDURE DAILY_IMBALANCE_SUMMARY
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ENTITY_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_STATEMENT_BEGIN_DATE DATE;
v_STATEMENT_END_DATE DATE;
v_VALID_IDs ID_TABLE;
BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	v_STATEMENT_BEGIN_DATE := PC.GET_CORRECT_STATEMENT_DATE(p_CALLING_MODULE,p_ENTITY_ID,p_BEGIN_DATE-1);
	v_STATEMENT_END_DATE := TRUNC(p_END_DATE)+1;

	IF  UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_GAS_DELIVERY THEN
	    OPEN p_CURSOR FOR
			SELECT B.POOL_NAME "ENTITY_NAME",
				A.ENTITY_ID,
				D.SERVICE_POINT_ID,
				D.SERVICE_POINT_NAME,
				SUM(E.SUPPLY - E.DEMAND) SUM_DIFFERENCE,
				SUM(E.ENERGY_IMBALANCE_AMOUNT) SUM_TOTAL
			FROM BILLING_STATEMENT A, POOL B, COMPONENT C, SERVICE_POINT D, IMBALANCE_CHARGE E
			WHERE (p_ENTITY_ID = g_ALL OR A.ENTITY_ID = p_ENTITY_ID)
				AND A.COMPONENT_ID IN (SELECT DISTINCT COMPONENT_ID FROM BILLING_STATEMENT WHERE UPPER(CHARGE_VIEW_TYPE) = 'IMBALANCE2' AND UPPER(CHARGE_INTERVAL) = 'DAY')
				AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
				AND A.STATEMENT_STATE = g_INTERNAL_STATE
				AND A.STATEMENT_DATE BETWEEN v_STATEMENT_BEGIN_DATE AND v_STATEMENT_END_DATE
				AND A.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
					FROM BILLING_STATEMENT
					WHERE ENTITY_ID = A.ENTITY_ID
						AND PRODUCT_ID = A.PRODUCT_ID
						AND COMPONENT_ID = A.COMPONENT_ID
						AND STATEMENT_TYPE = A.STATEMENT_TYPE
						AND STATEMENT_STATE = A.STATEMENT_STATE
						AND STATEMENT_DATE = A.STATEMENT_DATE
						AND AS_OF_DATE <= p_AS_OF_DATE)
				AND B.POOL_ID = A.ENTITY_ID
				AND C.COMPONENT_ID = A.COMPONENT_ID
				AND D.SERVICE_POINT_ID = C.SERVICE_POINT_ID
				AND E.CHARGE_ID = A.CHARGE_ID
	  			AND E.CHARGE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			GROUP BY B.POOL_NAME, A.ENTITY_ID, D.SERVICE_POINT_ID, D.SERVICE_POINT_NAME
			ORDER BY 1, 4;
	ELSE
    	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING AND p_ENTITY_ID = g_ALL THEN
    		v_VALID_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_PSE_BILL_SELECT);
    	ELSE
    		v_VALID_IDs := ID_TABLE();
    		v_VALID_IDs.EXTEND();
    		v_VALID_IDs(v_VALID_IDs.LAST) := ID_TYPE(p_ENTITY_ID);
    	END IF;

		OPEN p_CURSOR FOR
			SELECT C.PSE_NAME "ENTITY_NAME",
		   		A.ENTITY_ID,
				DECODE(UPPER(SUBSTR(D.IMBALANCE_TYPE,1,1)),'N',0,D.SERVICE_POINT_ID) SERVICE_POINT_ID,
				E.SERVICE_POINT_NAME,
			   	SUM(B.SUPPLY - B.DEMAND) SUM_DIFFERENCE,
		    	SUM(B.ENERGY_IMBALANCE_AMOUNT) SUM_TOTAL
			FROM BILLING_STATEMENT A, IMBALANCE_CHARGE B, PURCHASING_SELLING_ENTITY C, COMPONENT D, SERVICE_POINT E,
				TABLE(CAST(v_VALID_IDs AS ID_TABLE)) F
			WHERE F.ID IN (g_ALL, SD.g_ALL_DATA_ENTITY_ID, A.ENTITY_ID)
				AND A.COMPONENT_ID IN (SELECT DISTINCT COMPONENT_ID FROM COMPONENT WHERE UPPER(RATE_STRUCTURE) = 'IMBALANCE')
				AND E.SERVICE_POINT_ID = D.SERVICE_POINT_ID
				AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
				AND A.STATEMENT_STATE = g_INTERNAL_STATE
				AND A.STATEMENT_DATE BETWEEN v_STATEMENT_BEGIN_DATE AND v_STATEMENT_END_DATE
				AND A.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM BILLING_STATEMENT
					WHERE ENTITY_ID = A.ENTITY_ID
						AND PRODUCT_ID = A.PRODUCT_ID
						AND COMPONENT_ID = A.COMPONENT_ID
						AND STATEMENT_TYPE = A.STATEMENT_TYPE
						AND STATEMENT_STATE = A.STATEMENT_STATE
						AND STATEMENT_DATE = A.STATEMENT_DATE
						AND AS_OF_DATE <= p_AS_OF_DATE)
				AND B.CHARGE_ID = A.CHARGE_ID
		  		AND B.CHARGE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND C.PSE_ID = A.ENTITY_ID
				AND UPPER(SUBSTR(D.IMBALANCE_TYPE,1,1)) IN ('N','S')
			GROUP BY C.PSE_NAME, A.ENTITY_ID, DECODE(UPPER(SUBSTR(D.IMBALANCE_TYPE,1,1)),'N',0,D.SERVICE_POINT_ID), E.SERVICE_POINT_NAME
			ORDER BY 1, 4;
	END IF;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END DAILY_IMBALANCE_SUMMARY;
---------------------------------------------------------------------------------------------------
PROCEDURE DAILY_IMBALANCE
    (
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ENTITY_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_STATEMENT_BEGIN_DATE DATE;
v_STATEMENT_END_DATE DATE;

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	v_STATEMENT_BEGIN_DATE := PC.GET_CORRECT_STATEMENT_DATE(p_CALLING_MODULE,p_ENTITY_ID,p_BEGIN_DATE-1);
	v_STATEMENT_END_DATE := TRUNC(p_END_DATE)+1;

	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_GAS_DELIVERY THEN
		OPEN p_CURSOR FOR
			SELECT B.CHARGE_DATE,
            	A.CHARGE_ID,
	            (B.SUPPLY - B.DEMAND) "DIFFERENCE",
				B.DEMAND,
				B.SUPPLY,
				B.NET_SYSTEM_IMBALANCE,
				C.BAND_NUMBER,
				C.ENERGY_IMBALANCE_QUANTITY "BAND_QUANTITY",
				C.ENERGY_IMBALANCE_RATE "BAND_RATE",
				C.ENERGY_IMBALANCE_AMOUNT "BAND_AMOUNT",
				B.ENERGY_IMBALANCE_AMOUNT "TOTAL_AMOUNT"
			FROM BILLING_STATEMENT A, IMBALANCE_CHARGE B, IMBALANCE_CHARGE_BAND C
			WHERE A.ENTITY_ID = p_ENTITY_ID
				AND A.COMPONENT_ID IN (SELECT DISTINCT COMPONENT_ID FROM BILLING_STATEMENT WHERE UPPER(CHARGE_VIEW_TYPE) = 'IMBALANCE2' AND UPPER(CHARGE_INTERVAL) = 'DAY')
				AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
				AND A.STATEMENT_STATE = g_INTERNAL_STATE
				AND A.STATEMENT_DATE BETWEEN v_STATEMENT_BEGIN_DATE AND v_STATEMENT_END_DATE
				AND B.CHARGE_ID = A.CHARGE_ID
				AND B.CHARGE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND C.CHARGE_ID = B.CHARGE_ID
				AND C.CHARGE_DATE = B.CHARGE_DATE
				AND A.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM BILLING_STATEMENT
					WHERE ENTITY_ID = A.ENTITY_ID
						AND PRODUCT_ID = A.PRODUCT_ID
						AND COMPONENT_ID = A.COMPONENT_ID
						AND STATEMENT_TYPE = A.STATEMENT_TYPE
						AND STATEMENT_STATE = A.STATEMENT_STATE
						AND STATEMENT_DATE = A.STATEMENT_DATE
						AND AS_OF_DATE <= p_AS_OF_DATE)
			ORDER BY B.CHARGE_DATE, A.CHARGE_ID, C.BAND_NUMBER;
	ELSE
		OPEN p_CURSOR FOR
			SELECT FROM_CUT_AS_HED(B.CHARGE_DATE, p_TIME_ZONE) "CHARGE_DATE",
            	A.CHARGE_ID,
	            (B.SUPPLY - B.DEMAND) "DIFFERENCE",
				B.DEMAND,
				B.SUPPLY,
				B.NET_SYSTEM_IMBALANCE,
				C.BAND_NUMBER,
				C.ENERGY_IMBALANCE_QUANTITY "BAND_QUANTITY",
				C.ENERGY_IMBALANCE_RATE "BAND_RATE",
				C.ENERGY_IMBALANCE_AMOUNT "BAND_AMOUNT",
				B.ENERGY_IMBALANCE_AMOUNT "TOTAL_AMOUNT"
		FROM BILLING_STATEMENT A, IMBALANCE_CHARGE B, IMBALANCE_CHARGE_BAND C, COMPONENT D
		WHERE A.ENTITY_ID = p_ENTITY_ID
			AND A.COMPONENT_ID = D.COMPONENT_ID
			AND ((p_SERVICE_POINT_ID = 0 AND
				  UPPER(A.CHARGE_VIEW_TYPE) = 'IMBALANCE1' AND
				  UPPER(SUBSTR(D.IMBALANCE_TYPE,1,1)) = 'N')
	  		  OR (p_SERVICE_POINT_ID <> 0 AND
  			  	  UPPER(A.CHARGE_VIEW_TYPE) = 'IMBALANCE3' AND
  			  	  UPPER(SUBSTR(D.IMBALANCE_TYPE,1,1)) = 'S' AND
  		  		  D.SERVICE_POINT_ID = p_SERVICE_POINT_ID))
			AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
			AND A.STATEMENT_STATE = g_INTERNAL_STATE
			AND A.STATEMENT_DATE BETWEEN v_STATEMENT_BEGIN_DATE AND v_STATEMENT_END_DATE
			AND B.CHARGE_ID = A.CHARGE_ID
	  		AND B.CHARGE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND C.CHARGE_ID = B.CHARGE_ID
			AND C.CHARGE_DATE = B.CHARGE_DATE
			AND A.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM BILLING_STATEMENT
				WHERE ENTITY_ID = A.ENTITY_ID
					AND PRODUCT_ID = A.PRODUCT_ID
					AND COMPONENT_ID = A.COMPONENT_ID
					AND STATEMENT_TYPE = A.STATEMENT_TYPE
					AND STATEMENT_STATE = A.STATEMENT_STATE
					AND STATEMENT_DATE = A.STATEMENT_DATE
					AND AS_OF_DATE <= p_AS_OF_DATE)
		ORDER BY B.CHARGE_DATE, A.CHARGE_ID, C.BAND_NUMBER;
        END IF;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END DAILY_IMBALANCE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_INVOICE_LINE_ITEMS
    (
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_INVOICE_DATE IN DATE,
	p_INVOICE_ID IN NUMBER,
	p_IS_INVOICE_DETAIL OUT NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_ALPHA INVOICE_LINE_ITEM_FORMAT_TABLE := INVOICE_LINE_ITEM_FORMAT_TABLE();
v_BETA INVOICE_LINE_ITEM_FORMAT_TABLE := INVOICE_LINE_ITEM_FORMAT_TABLE();
v_INVOICE_DATE DATE;

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	p_IS_INVOICE_DETAIL := ENTITY_IS_INVOICE_DETAIL(p_CALLING_MODULE, p_MODEL_ID, p_ENTITY_ID);
	BEGIN
	    SELECT BEGIN_DATE INTO v_INVOICE_DATE
	    FROM INVOICE
	    WHERE INVOICE_ID = p_INVOICE_ID;
	EXCEPTION
    	WHEN NO_DATA_FOUND THEN
        	v_INVOICE_DATE := p_INVOICE_DATE;
	END;

	SELECT INVOICE_LINE_ITEM_FORMAT_TYPE(A.LINE_ITEM_NAME, A.LINE_ITEM_CATEGORY, A.LINE_ITEM_QUANTITY, A.LINE_ITEM_RATE, A.LINE_ITEM_AMOUNT, A.LINE_ITEM_BILL_AMOUNT, A.LINE_ITEM_TYPE, DECODE(A.LINE_ITEM_TYPE, 'B', 1, 'P', 2, 'A', 3, 'F', 4, 'M', 7, 'X', 8, 99), B.INVOICE_GROUP_NAME, A.INVOICE_GROUP_ORDER, 1)
	BULK COLLECT INTO v_ALPHA
	FROM INVOICE_USER_LINE_ITEM A, INVOICE_GROUP B
	WHERE A.ENTITY_ID = p_ENTITY_ID
		AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
		AND A.STATEMENT_STATE = p_STATEMENT_STATE
		AND A.BEGIN_DATE = v_INVOICE_DATE
        AND B.INVOICE_GROUP_ID(+) = A.INVOICE_GROUP_ID;

	SELECT INVOICE_LINE_ITEM_FORMAT_TYPE(A.LINE_ITEM_NAME, A.LINE_ITEM_CATEGORY, A.LINE_ITEM_QUANTITY, A.LINE_ITEM_RATE, A.LINE_ITEM_AMOUNT, A.LINE_ITEM_BILL_AMOUNT, DECODE(UPPER(B.CHARGE_TYPE), 'TAX', 'T', 'C'), DECODE(UPPER(B.CHARGE_TYPE), 'TAX', 6, 5), C.INVOICE_GROUP_NAME, B.INVOICE_GROUP_ORDER, 0)
	BULK COLLECT INTO v_BETA
	FROM INVOICE_LINE_ITEM A, COMPONENT B, INVOICE_GROUP C
	WHERE A.INVOICE_ID = p_INVOICE_ID
		AND B.COMPONENT_ID(+) = A.COMPONENT_ID
        AND C.INVOICE_GROUP_ID(+) = B.INVOICE_GROUP_ID;

	OPEN p_CURSOR FOR
		SELECT A.LINE_ITEM_NAME, A.LINE_ITEM_CATEGORY,
        	A.LINE_ITEM_QUANTITY, A.LINE_ITEM_RATE,
            A.LINE_ITEM_AMOUNT, A.LINE_ITEM_BILL_AMOUNT,
            A.LINE_ITEM_TYPE, A.LINE_ITEM_IS_USER, A.LINE_ITEM_BLOCK,
            A.LINE_ITEM_BILLING_GROUP, A.LINE_ITEM_BILLING_GROUP_ORDER
		FROM
			(SELECT X.LINE_ITEM_NAME, X.LINE_ITEM_CATEGORY,
            	X.LINE_ITEM_QUANTITY, X.LINE_ITEM_RATE,
                X.LINE_ITEM_AMOUNT, X.LINE_ITEM_BILL_AMOUNT,
                X.LINE_ITEM_TYPE, X.LINE_ITEM_IS_USER, X.LINE_ITEM_BLOCK,
                X.LINE_ITEM_BILLING_GROUP, X.LINE_ITEM_BILLING_GROUP_ORDER
			FROM TABLE(CAST(v_ALPHA AS INVOICE_LINE_ITEM_FORMAT_TABLE)) X
			UNION SELECT X.LINE_ITEM_NAME, X.LINE_ITEM_CATEGORY,
            	X.LINE_ITEM_QUANTITY, X.LINE_ITEM_RATE,
                X.LINE_ITEM_AMOUNT, X.LINE_ITEM_BILL_AMOUNT,
                X.LINE_ITEM_TYPE, X.LINE_ITEM_IS_USER, X.LINE_ITEM_BLOCK,
                X.LINE_ITEM_BILLING_GROUP, X.LINE_ITEM_BILLING_GROUP_ORDER
			FROM TABLE(CAST(v_BETA AS INVOICE_LINE_ITEM_FORMAT_TABLE)) X) A
		ORDER BY A.LINE_ITEM_BLOCK, A.LINE_ITEM_BILLING_GROUP, A.LINE_ITEM_BILLING_GROUP_ORDER, A.LINE_ITEM_NAME;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END GET_INVOICE_LINE_ITEMS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_INVOICE_REPORT_RECORDS
	(
    p_CALLING_MODULE IN VARCHAR,
    p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_INVOICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
    p_INVOICE_CATEGORY IN VARCHAR,
    p_INVOICE_ID OUT NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
    ) AS
v_INVOICE_DATE DATE;
v_SOMETHING_DONE BOOLEAN := FALSE;
v_DATE_FMT VARCHAR2(32) := NVL(MODEL_VALUE_AT_KEY(p_MODEL_ID,'BILLING','INVOICE','DATE FORMAT',0),'YYYY/MM/DD');
v_INVOICE_CATEGORY VARCHAR2(32);
BEGIN
	SELECT NVL(MAX(INVOICE_ID),-1) INTO p_INVOICE_ID
    FROM INVOICE A
    WHERE A.ENTITY_ID = p_ENTITY_ID
		AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
		AND A.STATEMENT_STATE = p_STATEMENT_STATE
		AND A.BEGIN_DATE <= p_INVOICE_DATE
		AND A.END_DATE >= p_INVOICE_DATE
		AND A.AS_OF_DATE = (SELECT AS_OF_DATE FROM INVOICE
	                       	WHERE ENTITY_ID = A.ENTITY_ID
	                           	AND STATEMENT_TYPE = A.STATEMENT_TYPE
	                           	AND STATEMENT_STATE = A.STATEMENT_STATE
	                        	AND BEGIN_DATE = A.BEGIN_DATE
	                            AND AS_OF_DATE <= p_AS_OF_DATE);
	BEGIN
	    SELECT BEGIN_DATE INTO v_INVOICE_DATE
	    FROM INVOICE
	    WHERE INVOICE_ID = p_INVOICE_ID;
	EXCEPTION
    	WHEN NO_DATA_FOUND THEN
        	v_INVOICE_DATE := p_INVOICE_DATE;
	END;
    IF p_INVOICE_CATEGORY = '<ALL>' THEN
    	v_INVOICE_CATEGORY := '%';
	ELSE
    	v_INVOICE_CATEGORY := p_INVOICE_CATEGORY;
	END IF;

	XS.GET_INVOICE_REPORT_RECORDS (p_CALLING_MODULE, p_MODEL_ID, p_ENTITY_ID, p_STATEMENT_TYPE, p_STATEMENT_STATE, v_INVOICE_DATE, p_AS_OF_DATE, v_INVOICE_CATEGORY, p_INVOICE_ID, p_STATUS, v_SOMETHING_DONE, p_CURSOR);

	IF NOT v_SOMETHING_DONE THEN
    	-- default data set
		OPEN p_CURSOR FOR
			SELECT TO_CHAR(A.BEGIN_DATE, v_DATE_FMT)||' - '||TO_CHAR(A.END_DATE, v_DATE_FMT) AS INVOICE_MONTH,
				TO_CHAR(TRUNC(A.INVOICE_DATE), v_DATE_FMT) AS INVOICE_DATE,
	    		A.INVOICE_NUMBER, A.INVOICE_SUB_LEDGER_NUMBER,
	    		A.BILLING_CONTACT, A.BILLING_PHONE, A.BILLING_FAX, A.BILLING_STREET, A.BILLING_CITY, A.BILLING_STATE_CODE, A.BILLING_POSTAL_CODE, A.BILLING_COUNTRY_CODE,
	    		A.INVOICE_TERMS, A.INVOICE_PRIMARY_CONTACT, A.INVOICE_PRIMARY_PHONE, A.INVOICE_SECONDARY_CONTACT, A.INVOICE_SECONDARY_PHONE,
	    		A.PAY_CHECK_CONTACT, A.PAY_CHECK_STREET, A.PAY_CHECK_CITY, A.PAY_CHECK_STATE_CODE, A.PAY_CHECK_POSTAL_CODE, A.PAY_CHECK_COUNTRY_CODE,
	    		A.PAY_ELECTRONIC_DEBIT_NAME, A.PAY_ELECTRONIC_DEBIT_NBR, A.PAY_ELECTRONIC_CREDIT_NAME, A.PAY_ELECTRONIC_CREDIT_NBR,
	    		A.INVOICE_STATUS,
	    		TO_CHAR(TRUNC(A.PAYMENT_DUE_DATE), v_DATE_FMT) AS PAYMENT_DUE_DATE,
				A.PAYMENT_DUE_DATE AS PAYMENT_DUE_DATE_DT,
	    		B.LINE_ITEM_NAME,
	    		DECODE(UPPER(C.CHARGE_TYPE), 'TAX', 'T', 'C') AS LINE_ITEM_TYPE,
	    		DECODE(UPPER(C.CHARGE_TYPE), 'TAX', 6, 5) AS LINE_ITEM_GROUP_ORDER, D.INVOICE_GROUP_NAME,
                NVL(C.INVOICE_GROUP_ORDER,0) AS INVOICE_GROUP_ORDER,
	    		TO_CHAR(B.LINE_ITEM_QUANTITY) AS LINE_ITEM_QUANTITY, TO_CHAR(B.LINE_ITEM_RATE) AS LINE_ITEM_RATE,
                TO_CHAR(DECODE(UPPER(NVL(B.DEFAULT_DISPLAY,'CHARGE')),'BILL',B.LINE_ITEM_BILL_AMOUNT,B.LINE_ITEM_AMOUNT)) AS LINE_ITEM_AMOUNT,
	    		TO_CHAR(NVL(C.EXCLUDE_FROM_INVOICE_TOTAL,0)) AS EXCLUDE_FROM_INVOICE_TOTAL,
	    		TO_CHAR(NVL(D.SHOW_TITLE_ON_INVOICE,0)) AS SHOW_TITLE_ON_INVOICE,
	    		TO_CHAR(NVL(D.SHOW_SUBTOTAL_ON_INVOICE,0)) AS SHOW_SUBTOTAL_ON_INVOICE,
                NVL(D.DISPLAY_ORDER,0) AS INVOICE_GROUP_DISPLAY_ORDER,
				A.APPROVED_BY,
	    		TO_CHAR(TRUNC(A.APPROVED_WHEN), v_DATE_FMT) AS APPROVED_WHEN,
				A.APPROVED_WHEN AS APPROVED_WHEN_DT
			FROM INVOICE A,
				INVOICE_LINE_ITEM B,
	    		COMPONENT C,
	    		INVOICE_GROUP D
			WHERE A.INVOICE_ID = p_INVOICE_ID
				AND B.INVOICE_ID = A.INVOICE_ID
                AND NVL(B.LINE_ITEM_CATEGORY,' ') LIKE v_INVOICE_CATEGORY
				AND C.COMPONENT_ID(+) = B.COMPONENT_ID
				AND D.INVOICE_GROUP_ID(+) = C.INVOICE_GROUP_ID
			UNION ALL
			SELECT TO_CHAR(A.BEGIN_DATE, v_DATE_FMT)||' - '||TO_CHAR(A.END_DATE, v_DATE_FMT) AS INVOICE_MONTH,
				TO_CHAR(TRUNC(A.INVOICE_DATE), v_DATE_FMT) AS INVOICE_DATE,
	    		A.INVOICE_NUMBER, A.INVOICE_SUB_LEDGER_NUMBER,
				A.BILLING_CONTACT, A.BILLING_PHONE, A.BILLING_FAX, A.BILLING_STREET, A.BILLING_CITY, A.BILLING_STATE_CODE, A.BILLING_POSTAL_CODE, A.BILLING_COUNTRY_CODE,
				A.INVOICE_TERMS, A.INVOICE_PRIMARY_CONTACT, A.INVOICE_PRIMARY_PHONE, A.INVOICE_SECONDARY_CONTACT, A.INVOICE_SECONDARY_PHONE,
				A.PAY_CHECK_CONTACT, A.PAY_CHECK_STREET, A.PAY_CHECK_CITY, A.PAY_CHECK_STATE_CODE, A.PAY_CHECK_POSTAL_CODE, A.PAY_CHECK_COUNTRY_CODE,
				A.PAY_ELECTRONIC_DEBIT_NAME, A.PAY_ELECTRONIC_DEBIT_NBR, A.PAY_ELECTRONIC_CREDIT_NAME, A.PAY_ELECTRONIC_CREDIT_NBR,
				A.INVOICE_STATUS,
				TO_CHAR(TRUNC(A.PAYMENT_DUE_DATE), v_DATE_FMT) AS PAYMENT_DUE_DATE,
				A.PAYMENT_DUE_DATE AS PAYMENT_DUE_DATE_DT,
				B.LINE_ITEM_NAME,
				B.LINE_ITEM_TYPE,
				DECODE(B.LINE_ITEM_TYPE, 'B', 1, 'P', 2, 'A', 3, 'F', 4, 'M', 7, 'X', 8, 99)  AS LINE_ITEM_GROUP_ORDER, C.INVOICE_GROUP_NAME,
                NVL(B.INVOICE_GROUP_ORDER,0) AS INVOICE_GROUP_ORDER,
				TO_CHAR(B.LINE_ITEM_QUANTITY) AS LINE_ITEM_QUANTITY, TO_CHAR(B.LINE_ITEM_RATE) AS LINE_ITEM_RATE,
                TO_CHAR(DECODE(UPPER(NVL(B.DEFAULT_DISPLAY,'CHARGE')),'BILL',B.LINE_ITEM_BILL_AMOUNT,B.LINE_ITEM_AMOUNT)) AS LINE_ITEM_AMOUNT,
				TO_CHAR(NVL(B.EXCLUDE_FROM_INVOICE_TOTAL,0)) AS EXCLUDE_FROM_INVOICE_TOTAL,
	    		TO_CHAR(NVL(C.SHOW_TITLE_ON_INVOICE,0)) AS SHOW_TITLE_ON_INVOICE,
	    		TO_CHAR(NVL(C.SHOW_SUBTOTAL_ON_INVOICE,0)) AS SHOW_SUBTOTAL_ON_INVOICE,
                NVL(C.DISPLAY_ORDER,0) AS INVOICE_GROUP_DISPLAY_ORDER,
				A.APPROVED_BY,
	    		TO_CHAR(TRUNC(A.APPROVED_WHEN), v_DATE_FMT) AS APPROVED_WHEN,
				A.APPROVED_WHEN AS APPROVED_WHEN_DT
			FROM INVOICE A,
				INVOICE_USER_LINE_ITEM B,
                INVOICE_GROUP C
			WHERE A.INVOICE_ID = p_INVOICE_ID
				AND B.ENTITY_ID = A.ENTITY_ID
				AND B.STATEMENT_TYPE = A.STATEMENT_TYPE
	    		AND B.STATEMENT_STATE = A.STATEMENT_STATE
	    		AND B.BEGIN_DATE = A.BEGIN_DATE
                AND NVL(B.LINE_ITEM_CATEGORY,' ') LIKE v_INVOICE_CATEGORY
				AND C.INVOICE_GROUP_ID(+) = B.INVOICE_GROUP_ID
			ORDER BY INVOICE_GROUP_DISPLAY_ORDER ASC,
	    		INVOICE_GROUP_NAME ASC,
	    		INVOICE_GROUP_ORDER ASC,
            	LINE_ITEM_GROUP_ORDER ASC,
	    		LINE_ITEM_NAME ASC;
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END GET_INVOICE_REPORT_RECORDS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_INVOICE_LINE_ITEM
    (
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
    p_STATEMENT_STATE IN NUMBER,
	p_INVOICE_DATE IN DATE,
	p_INVOICE_ID IN NUMBER,
	p_LINE_ITEM_NAME IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
v_INVOICE_DATE DATE;
BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;
	BEGIN
	    SELECT BEGIN_DATE INTO v_INVOICE_DATE
	    FROM INVOICE
	    WHERE INVOICE_ID = p_INVOICE_ID;
	EXCEPTION
    	WHEN NO_DATA_FOUND THEN
        	v_INVOICE_DATE := p_INVOICE_DATE;
	END;

	OPEN p_CURSOR FOR
		SELECT X.LINE_ITEM_NAME, X.LINE_ITEM_CATEGORY, X.LINE_ITEM_QUANTITY, X.LINE_ITEM_RATE,
        	X.LINE_ITEM_AMOUNT, X.LINE_ITEM_BILL_AMOUNT, X.DEFAULT_DISPLAY, X.LINE_ITEM_TYPE,
            X.INVOICE_GROUP_ID, X.INVOICE_GROUP_ORDER, X.EXCLUDE_FROM_INVOICE_TOTAL,
            X.IS_TAXED, X.TAX_COMPONENT_ID, X.TAX_GEOGRAPHY_ID,
            X.IS_MANUAL_LINE_ITEM, X.STATEMENT_TYPE, X.BEGIN_DATE, X.END_DATE
		FROM
			(SELECT A.LINE_ITEM_NAME, A.LINE_ITEM_CATEGORY, A.LINE_ITEM_QUANTITY, A.LINE_ITEM_RATE,
            		A.LINE_ITEM_AMOUNT, A.LINE_ITEM_BILL_AMOUNT, A.DEFAULT_DISPLAY,
                    DECODE(UPPER(B.CHARGE_TYPE), 'TAX', 'Tax', 'Current') "LINE_ITEM_TYPE",
                    B.INVOICE_GROUP_ID, B.INVOICE_GROUP_ORDER, B.EXCLUDE_FROM_INVOICE_TOTAL,
                    B.IS_TAXED, 0 "TAX_COMPONENT_ID", NULL "TAX_GEOGRAPHY_ID",
                    0 "IS_MANUAL_LINE_ITEM", A.STATEMENT_TYPE, A.BEGIN_DATE, A.END_DATE
			FROM INVOICE_LINE_ITEM A, COMPONENT B
			WHERE A.INVOICE_ID	 = p_INVOICE_ID
				AND LINE_ITEM_NAME = p_LINE_ITEM_NAME
				AND B.COMPONENT_ID(+) = A.COMPONENT_ID
			UNION ALL
            SELECT A.LINE_ITEM_NAME, A.LINE_ITEM_CATEGORY, A.LINE_ITEM_QUANTITY, A.LINE_ITEM_RATE,
            		A.LINE_ITEM_AMOUNT, A.LINE_ITEM_BILL_AMOUNT, A.DEFAULT_DISPLAY,
					DECODE(A.LINE_ITEM_TYPE, 'P', 'Payment', 'F', 'Finance Charge', 'A', 'Adjustment', 'B', 'Balance', 'M', 'Miscellaneous', 'X', 'Manual Line Item Tax') "LINE_ITEM_TYPE",
                    A.INVOICE_GROUP_ID, A.INVOICE_GROUP_ORDER, A.EXCLUDE_FROM_INVOICE_TOTAL,
                    A.IS_TAXED, A.TAX_COMPONENT_ID, A.TAX_GEOGRAPHY_ID,
                    1 "IS_MANUAL_LINE_ITEM", A.STATEMENT_TYPE, A.BEGIN_DATE, A.BEGIN_DATE "END_DATE"
			FROM INVOICE_USER_LINE_ITEM A
			WHERE A.ENTITY_ID = p_ENTITY_ID
				AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
                AND A.STATEMENT_STATE = p_STATEMENT_STATE
				AND A.BEGIN_DATE = v_INVOICE_DATE
				AND LINE_ITEM_NAME = p_LINE_ITEM_NAME) X;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END GET_INVOICE_LINE_ITEM;
---------------------------------------------------------------------------------------------------
PROCEDURE TRANSMISSION_CHARGE_DETAIL
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_WORK_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
    p_SHOW_BILL_AMOUNT IN NUMBER,
    p_SHOW_CHARGE_AMOUNT IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT A.RESERVATION,
			A.TRANSACTION_ID,
			A.CHARGE_INTERVAL,
			FROM_CUT_AS_HED(A.CHARGE_DATE, p_TIME_ZONE, GET_FORMAT_FROM_COMPONENT(A.COMPONENT_ID)) "CHARGE_DATE",
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CAPACITY_RESERVED END "CAPACITY_RESERVED",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_CAPACITY_RESERVED END "BILL_CAPACITY_RESERVED",
			A.CHARGE_RATE,
			A.CHARGE_FACTOR,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_AMOUNT END "CHARGE_AMOUNT",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_AMOUNT END "BILL_AMOUNT",
			B.DISPUTE_STATUS
		FROM (SELECT B.TRANSACTION_NAME "RESERVATION",
				B.TRANSACTION_ID,
				B.CHARGE_INTERVAL,
				B.CHARGE_DATE,
				B.CAPACITY_RESERVED,
				B.BILL_CAPACITY_RESERVED,
				B.CHARGE_RATE,
				B.CHARGE_FACTOR,
				B.CHARGE_AMOUNT,
				B.BILL_AMOUNT,
				A.ENTITY_ID,
				A.STATEMENT_TYPE,
				A.STATEMENT_STATE,
                A.STATEMENT_DATE,
				A.PRODUCT_ID,
				A.COMPONENT_ID
			FROM BILLING_STATEMENT A,
				TRANSMISSION_CHARGE B,
				COMPONENT C,
				RTO_WORK X
			WHERE X.WORK_ID = p_WORK_ID
				AND B.CHARGE_ID = X.WORK_XID
				AND A.CHARGE_ID(+) = B.CHARGE_ID
				AND C.COMPONENT_ID = A.COMPONENT_ID) A,
			BILLING_CHARGE_DISPUTE B
		WHERE B.ENTITY_ID (+)= A.ENTITY_ID
			AND B.PRODUCT_ID (+)= A.PRODUCT_ID
			AND B.COMPONENT_ID (+)= A.COMPONENT_ID
			AND B.STATEMENT_TYPE (+)= A.STATEMENT_TYPE
			AND B.STATEMENT_STATE (+)= A.STATEMENT_STATE
            AND B.STATEMENT_DATE (+)= A.STATEMENT_DATE
			AND B.DISPUTE_DATE (+)= A.CHARGE_DATE
		ORDER BY A.CHARGE_DATE, A.RESERVATION;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END TRANSMISSION_CHARGE_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE ENTITY_ATTRIBUTE_CHARGE_DETAIL
    (
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_WORK_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
    p_SHOW_BILL_AMOUNT IN NUMBER,
    p_SHOW_CHARGE_AMOUNT IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT A.FACILITY,
			FROM_CUT_AS_HED(A.CHARGE_DATE, p_TIME_ZONE, GET_FORMAT_FROM_COMPONENT(A.COMPONENT_ID)) "CHARGE_DATE",
			FROM_CUT_AS_HED(A.PEAK_DATE, p_TIME_ZONE, 'MI5') "PEAK_DATE",
			A.PEAK_QUANTITY,
			A.CHARGE_RATE,
			A.CHARGE_FACTOR,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_AMOUNT END "CHARGE_AMOUNT",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_AMOUNT END "BILL_AMOUNT",
			B.DISPUTE_STATUS
		FROM (SELECT D.ACCOUNT_NAME "FACILITY",
				C.CHARGE_DATE,
				C.PEAK_DATE,
				C.PEAK_QUANTITY,
				C.CHARGE_RATE,
				C.CHARGE_FACTOR,
				C.CHARGE_AMOUNT,
				C.BILL_AMOUNT,
				A.ENTITY_ID,
				A.STATEMENT_TYPE,
				A.STATEMENT_STATE,
                A.STATEMENT_DATE,
				A.PRODUCT_ID,
				A.COMPONENT_ID
			FROM BILLING_STATEMENT A,
				COMPONENT_ENTITY_ATTRIBUTE B,
				ENTITY_ATTRIBUTE_CHARGE C,
				ACCOUNT D,
				RTO_WORK X
			WHERE X.WORK_ID = p_WORK_ID
				AND C.CHARGE_ID = X.WORK_XID
				AND A.CHARGE_ID(+) = C.CHARGE_ID
				AND C.ENTITY_DOMAIN_ID = B.ENTITY_DOMAIN_ID
				AND C.ATTRIBUTE_ID = B.ENTITY_ATTRIBUTE_ID
				AND D.ACCOUNT_ID = C.ENTITY_ID) A,
			BILLING_CHARGE_DISPUTE B
		WHERE B.ENTITY_ID (+)= A.ENTITY_ID
			AND B.PRODUCT_ID (+)= A.PRODUCT_ID
			AND B.COMPONENT_ID (+)= A.COMPONENT_ID
			AND B.STATEMENT_TYPE (+)= A.STATEMENT_TYPE
			AND B.STATEMENT_STATE (+)= A.STATEMENT_STATE
            AND B.STATEMENT_DATE (+)= A.STATEMENT_DATE
			AND B.DISPUTE_DATE (+)= A.CHARGE_DATE
		ORDER BY 1,2;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END ENTITY_ATTRIBUTE_CHARGE_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE BILLING_CHARGE_DETAIL
    (
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_WORK_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
    p_SHOW_BILL_AMOUNT IN NUMBER,
    p_SHOW_CHARGE_AMOUNT IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(A.CHARGE_DATE, p_TIME_ZONE, GET_FORMAT_FROM_COMPONENT(A.COMPONENT_ID)) "CHARGE_DATE",
			A.SERVICE_POINT,
			FROM_CUT_AS_HED(A.PEAK_DATE, p_TIME_ZONE, 'MI5') "PEAK_DATE",
			A.PEAK_QUANTITY,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_QUANTITY END "CHARGE_QUANTITY",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_QUANTITY END "BILL_QUANTITY",
			A.CHARGE_RATE,
			A.CHARGE_FACTOR,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_AMOUNT END "CHARGE_AMOUNT",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_AMOUNT END "BILL_AMOUNT",
			B.DISPUTE_STATUS
		FROM (SELECT B.CHARGE_DATE,
				SERVICE_POINT_NAME "SERVICE_POINT",
				B.PEAK_DATE,
				PEAK_QUANTITY,
				B.CHARGE_QUANTITY,
				B.BILL_QUANTITY,
				B.CHARGE_RATE,
				B.CHARGE_FACTOR,
				B.CHARGE_AMOUNT,
				B.BILL_AMOUNT,
				A.ENTITY_ID,
				A.STATEMENT_TYPE,
				A.STATEMENT_STATE,
                A.STATEMENT_DATE,
				A.PRODUCT_ID,
				A.COMPONENT_ID
			FROM BILLING_STATEMENT A,
				BILLING_CHARGE B,
				SERVICE_POINT C,
				RTO_WORK X
			WHERE X.WORK_ID = p_WORK_ID
				AND B.CHARGE_ID = X.WORK_XID
				AND A.CHARGE_ID(+) = B.CHARGE_ID
				AND C.SERVICE_POINT_ID = NVL(B.SERVICE_POINT_ID,0)) A,
			BILLING_CHARGE_DISPUTE B
		WHERE B.ENTITY_ID (+)= A.ENTITY_ID
			AND B.PRODUCT_ID (+)= A.PRODUCT_ID
			AND B.COMPONENT_ID (+)= A.COMPONENT_ID
			AND B.STATEMENT_TYPE (+)= A.STATEMENT_TYPE
			AND B.STATEMENT_STATE (+)= A.STATEMENT_STATE
            AND B.STATEMENT_DATE (+)= A.STATEMENT_DATE
			AND B.DISPUTE_DATE (+)= A.CHARGE_DATE
		ORDER BY 1;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END BILLING_CHARGE_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE IMBALANCE_CHARGE_DETAIL
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_WORK_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
    p_SHOW_BILL_AMOUNT IN NUMBER,
    p_SHOW_CHARGE_AMOUNT IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(A.CHARGE_DATE, p_TIME_ZONE, GET_FORMAT_FROM_COMPONENT(A.COMPONENT_ID), p_MODEL_ID) "CHARGE_DATE",
			A.NET_SYSTEM_IMBALANCE,
			A.BILL_NET_SYSTEM_IMBALANCE,
			A.DEMAND,
			A.SUPPLY,
			A.DIFFERENCE,
			A.BAND_NUMBER,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.BAND_QUANTITY END "BAND_QUANTITY",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_BAND_QUANTITY END "BILL_BAND_QUANTITY",
			A.BAND_RATE,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.BAND_AMOUNT END "BAND_AMOUNT",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_BAND_AMOUNT END "BILL_BAND_AMOUNT",
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.TOTAL_AMOUNT END "CHARGE_AMOUNT",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_TOTAL_AMOUNT END "BILL_AMOUNT",
			B.DISPUTE_STATUS
		FROM (SELECT B.CHARGE_DATE,
				B.NET_SYSTEM_IMBALANCE,
				B.BILL_NET_SYSTEM_IMBALANCE,
				B.DEMAND,
				B.SUPPLY,
				(B.SUPPLY - B.DEMAND) "DIFFERENCE",
				C.BAND_NUMBER,
				C.ENERGY_IMBALANCE_QUANTITY "BAND_QUANTITY",
				C.BILL_ENERGY_IMBALANCE_QUANTITY "BILL_BAND_QUANTITY",
				C.ENERGY_IMBALANCE_RATE "BAND_RATE",
				C.ENERGY_IMBALANCE_AMOUNT "BAND_AMOUNT",
				C.BILL_ENERGY_IMBALANCE_AMOUNT "BILL_BAND_AMOUNT",
				B.ENERGY_IMBALANCE_AMOUNT "TOTAL_AMOUNT",
				B.BILL_ENERGY_IMBALANCE_AMOUNT "BILL_TOTAL_AMOUNT",
				A.ENTITY_ID,
				A.STATEMENT_TYPE,
				A.STATEMENT_STATE,
                A.STATEMENT_DATE,
				A.PRODUCT_ID,
				A.COMPONENT_ID
			FROM BILLING_STATEMENT A, IMBALANCE_CHARGE B, IMBALANCE_CHARGE_BAND C, RTO_WORK X
			WHERE X.WORK_ID = p_WORK_ID
				AND B.CHARGE_ID = X.WORK_XID
				AND A.CHARGE_ID(+) = B.CHARGE_ID
				AND C.CHARGE_ID(+) = B.CHARGE_ID
				AND C.CHARGE_DATE(+) = B.CHARGE_DATE) A,
			BILLING_CHARGE_DISPUTE B
		WHERE B.ENTITY_ID (+)= A.ENTITY_ID
			AND B.PRODUCT_ID (+)= A.PRODUCT_ID
			AND B.COMPONENT_ID (+)= A.COMPONENT_ID
			AND B.STATEMENT_TYPE (+)= A.STATEMENT_TYPE
			AND B.STATEMENT_STATE (+)= A.STATEMENT_STATE
            AND B.STATEMENT_DATE (+)= A.STATEMENT_DATE
			AND B.DISPUTE_DATE (+)= A.CHARGE_DATE
		ORDER BY A.CHARGE_DATE;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END IMBALANCE_CHARGE_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE OPER_PROFIT_CHARGE_DETAIL
    (
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_WORK_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
    p_SHOW_BILL_AMOUNT IN NUMBER,
    p_SHOW_CHARGE_AMOUNT IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(A.CHARGE_DATE, p_TIME_ZONE, GET_FORMAT_FROM_COMPONENT(A.COMPONENT_ID), p_MODEL_ID) "CHARGE_DATE",
			A.SERVICE_POINT_NAME,
			A.MARKET_QUANTITY,
			A.MARKET_OPER_PROFIT,
			A.DISPATCH_QUANTITY,
			A.DISPATCH_OPER_PROFIT,
			A.ACTUAL_QUANTITY,
			A.ACTUAL_OPER_PROFIT,
			A.CHARGE_RATE,
			A.CHARGE_FACTOR,
			A.SET_NUMBER,
			A.SET_QUANTITY,
			A.SET_PRICE,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_AMOUNT END "CHARGE_AMOUNT",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_AMOUNT END "BILL_AMOUNT",
			B.DISPUTE_STATUS
		FROM (SELECT B.CHARGE_DATE,
				D.SERVICE_POINT_NAME,
				B.MARKET_QUANTITY,
				B.MARKET_OPER_PROFIT,
				B.DISPATCH_QUANTITY,
				B.DISPATCH_OPER_PROFIT,
				B.ACTUAL_QUANTITY,
				B.ACTUAL_OPER_PROFIT,
				B.CHARGE_RATE,
				B.CHARGE_FACTOR,
				C.SET_NUMBER,
				C.QUANTITY "SET_QUANTITY",
				C.PRICE "SET_PRICE",
				B.CHARGE_AMOUNT,
				B.BILL_AMOUNT,
				A.ENTITY_ID,
				A.STATEMENT_TYPE,
				A.STATEMENT_STATE,
                A.STATEMENT_DATE,
				A.PRODUCT_ID,
				A.COMPONENT_ID
			FROM BILLING_STATEMENT A, OPER_PROFIT_CHARGE B, OPER_PROFIT_CHARGE_SET C, SERVICE_POINT D, RTO_WORK X
			WHERE X.WORK_ID = p_WORK_ID
				AND B.CHARGE_ID = X.WORK_XID
				AND A.CHARGE_ID(+) = B.CHARGE_ID
				AND C.CHARGE_ID(+) = B.CHARGE_ID
				AND C.CHARGE_DATE(+) = B.CHARGE_DATE
                AND D.SERVICE_POINT_ID = NVL(B.SERVICE_POINT_ID,0)) A,
			BILLING_CHARGE_DISPUTE B
		WHERE B.ENTITY_ID (+)= A.ENTITY_ID
			AND B.PRODUCT_ID (+)= A.PRODUCT_ID
			AND B.COMPONENT_ID (+)= A.COMPONENT_ID
			AND B.STATEMENT_TYPE (+)= A.STATEMENT_TYPE
			AND B.STATEMENT_STATE (+)= A.STATEMENT_STATE
            AND B.STATEMENT_DATE (+)= A.STATEMENT_DATE
			AND B.DISPUTE_DATE (+)= A.CHARGE_DATE
		ORDER BY A.CHARGE_DATE;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END OPER_PROFIT_CHARGE_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNT_SERVICE_CHARGE_DETAIL
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_WORK_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
    p_SHOW_BILL_AMOUNT IN NUMBER,
    p_SHOW_CHARGE_AMOUNT IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT A.ACCOUNT,
			A.SERVICE_LOCATION,
			A.METER,
			A.CHARGE_BEGIN_DATE,
			A.CHARGE_END_DATE,
			A.BILL_CODE,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_QUANTITY END "CHARGE_QUANTITY",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_QUANTITY END "BILL_QUANTITY",
			A.CHARGE_RATE,
			A.CHARGE_FACTOR,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_AMOUNT END "CHARGE_AMOUNT",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_AMOUNT END "BILL_AMOUNT",
			B.DISPUTE_STATUS
		FROM (SELECT D.ACCOUNT_DISPLAY_NAME "ACCOUNT",
				E.SERVICE_LOCATION_NAME "SERVICE_LOCATION",
				F.METER_NAME "METER",
				A.CHARGE_BEGIN_DATE,
				A.CHARGE_END_DATE,
				DECODE(A.BILL_CODE,'B','Bill','C','Cancel','R','Rebill','T','Total') "BILL_CODE",
				A.CHARGE_QUANTITY,
				A.BILL_QUANTITY,
				A.CHARGE_RATE,
				A.CHARGE_FACTOR,
				A.CHARGE_AMOUNT,
				A.BILL_AMOUNT,
				C.ENTITY_ID,
				C.STATEMENT_TYPE,
				C.STATEMENT_STATE,
                C.STATEMENT_DATE,
				C.PRODUCT_ID,
				C.COMPONENT_ID
			FROM ACCOUNT_SERVICE_CHARGE A, ACCOUNT_SERVICE B, BILLING_STATEMENT C, ACCOUNT D, SERVICE_LOCATION E, METER F, RTO_WORK X
			WHERE X.WORK_ID = p_WORK_ID
				AND A.CHARGE_ID = X.WORK_XID
				AND C.CHARGE_ID(+) = A.CHARGE_ID
				AND A.BAND_NUMBER = g_NOT_ASSIGNED
				AND B.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
				AND B.ACCOUNT_ID = D.ACCOUNT_ID
				AND B.SERVICE_LOCATION_ID = E.SERVICE_LOCATION_ID
				AND B.METER_ID = F.METER_ID) A,
			BILLING_CHARGE_DISPUTE B
		WHERE B.ENTITY_ID (+)= A.ENTITY_ID
			AND B.PRODUCT_ID (+)= A.PRODUCT_ID
			AND B.COMPONENT_ID (+)= A.COMPONENT_ID
			AND B.STATEMENT_TYPE (+)= A.STATEMENT_TYPE
			AND B.STATEMENT_STATE (+)= A.STATEMENT_STATE
            AND B.STATEMENT_DATE (+)= A.STATEMENT_DATE
			AND B.DISPUTE_DATE (+)= A.CHARGE_BEGIN_DATE
		ORDER BY 1,2,3,4,5,6;

	EXCEPTION
		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END ACCOUNT_SERVICE_CHARGE_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE CONVERSION_CHARGE_DETAIL
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_WORK_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
    p_SHOW_BILL_AMOUNT IN NUMBER,
    p_SHOW_CHARGE_AMOUNT IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT A.SCHEDULE_GROUP,
			FROM_CUT_AS_HED(A.CHARGE_DATE, p_TIME_ZONE, GET_FORMAT_FROM_COMPONENT(A.COMPONENT_ID), p_MODEL_ID) "CHARGE_DATE",
			FROM_CUT_AS_HED(A.PEAK_DATE, p_TIME_ZONE, 'MI5', p_MODEL_ID) "PEAK_DATE",
			A.PEAK_DEMAND,
			A.SCHEDULED_AMOUNT,
			A.CONVERSION_FORMULA,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_QUANTITY END "CHARGE_QUANTITY",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_QUANTITY END "BILL_QUANTITY",
			A.CHARGE_RATE,
			A.CHARGE_FACTOR,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_AMOUNT END "CHARGE_AMOUNT",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_AMOUNT END "BILL_AMOUNT",
			B.DISPUTE_STATUS
		FROM (SELECT D.SCHEDULE_GROUP_NAME "SCHEDULE_GROUP",
				B.CHARGE_DATE,
				B.PEAK_DATE,
				B.PEAK_DEMAND,
				B.SCHEDULED_AMOUNT,
				NVL(B.COEFF_X3,0)||'*x^3 + '||NVL(B.COEFF_X2,0)||'*x^2 + '||NVL(B.COEFF_X1,0)||'*x + '||NVL(CONST_K,0) "CONVERSION_FORMULA",
				B.CHARGE_QUANTITY,
				B.CHARGE_RATE,
				B.CHARGE_FACTOR,
				B.CHARGE_AMOUNT,
				B.BILL_QUANTITY,
				B.BILL_AMOUNT,
				A.ENTITY_ID,
				A.STATEMENT_TYPE,
				A.STATEMENT_STATE,
                A.STATEMENT_DATE,
				A.PRODUCT_ID,
				A.COMPONENT_ID
			FROM BILLING_STATEMENT A, CONVERSION_CHARGE B, COMPONENT C, SCHEDULE_GROUP D, RTO_WORK X
			WHERE X.WORK_ID = p_WORK_ID
				AND B.CHARGE_ID = X.WORK_XID
				AND A.CHARGE_ID(+) = B.CHARGE_ID
				AND C.COMPONENT_ID = A.COMPONENT_ID
				AND D.SCHEDULE_GROUP_ID = B.SCHEDULE_GROUP_ID) A,
			BILLING_CHARGE_DISPUTE B
		WHERE B.ENTITY_ID (+)= A.ENTITY_ID
			AND B.PRODUCT_ID (+)= A.PRODUCT_ID
			AND B.COMPONENT_ID (+)= A.COMPONENT_ID
			AND B.STATEMENT_TYPE (+)= A.STATEMENT_TYPE
			AND B.STATEMENT_STATE (+)= A.STATEMENT_STATE
            AND B.STATEMENT_DATE (+)= A.STATEMENT_DATE
			AND B.DISPUTE_DATE (+)= A.CHARGE_DATE
		ORDER BY A.SCHEDULE_GROUP, A.CHARGE_DATE;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END CONVERSION_CHARGE_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE FORMULA_CHARGE_DETAIL
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_WORK_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
    p_SHOW_BILL_AMOUNT IN NUMBER,
    p_SHOW_CHARGE_AMOUNT IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(A.CHARGE_DATE, p_TIME_ZONE, GET_FORMAT_FROM_COMPONENT(A.COMPONENT_ID), p_MODEL_ID) "CHARGE_DATE",
            A.ITERATOR1_NAME,
            A.ITERATOR1_VAL,
            A.ITERATOR2_NAME,
            A.ITERATOR2_VAL,
            A.ITERATOR3_NAME,
            A.ITERATOR3_VAL,
            A.ITERATOR4_NAME,
            A.ITERATOR4_VAL,
            A.ITERATOR5_NAME,
            A.ITERATOR5_VAL,
            A.VARIABLE_NAME,
            A.VARIABLE_VALUE,
            CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_QUANTITY END "CHARGE_QUANTITY",
            CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_QUANTITY END "BILL_QUANTITY",
            A.CHARGE_RATE,
            A.CHARGE_FACTOR,
            CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_AMOUNT END "CHARGE_AMOUNT",
            CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_AMOUNT END "BILL_AMOUNT",
			B.DISPUTE_STATUS
		FROM (SELECT B.CHARGE_DATE,
				E.ITERATOR_NAME1 "ITERATOR1_NAME",
				D.ITERATOR1 "ITERATOR1_VAL",
				E.ITERATOR_NAME2 "ITERATOR2_NAME",
				D.ITERATOR2 "ITERATOR2_VAL",
				E.ITERATOR_NAME3 "ITERATOR3_NAME",
				D.ITERATOR3 "ITERATOR3_VAL",
				E.ITERATOR_NAME4 "ITERATOR4_NAME",
				D.ITERATOR4 "ITERATOR4_VAL",
				E.ITERATOR_NAME5 "ITERATOR5_NAME",
				D.ITERATOR5 "ITERATOR5_VAL",
                C.VARIABLE_NAME,
                C.VARIABLE_VAL "VARIABLE_VALUE",
				B.CHARGE_QUANTITY,
				B.BILL_QUANTITY,
				B.CHARGE_RATE,
				B.CHARGE_FACTOR,
				B.CHARGE_AMOUNT,
				B.BILL_AMOUNT,
				A.ENTITY_ID,
				A.STATEMENT_TYPE,
				A.STATEMENT_STATE,
                A.STATEMENT_DATE,
				A.PRODUCT_ID,
				A.COMPONENT_ID
			FROM BILLING_STATEMENT A, FORMULA_CHARGE B, FORMULA_CHARGE_VARIABLE C, FORMULA_CHARGE_ITERATOR D, FORMULA_CHARGE_ITERATOR_NAME E, RTO_WORK X
			WHERE X.WORK_ID = p_WORK_ID
				AND B.CHARGE_ID = X.WORK_XID
				AND A.CHARGE_ID(+) = B.CHARGE_ID
				AND C.CHARGE_ID(+) = B.CHARGE_ID
				AND C.CHARGE_DATE(+) = B.CHARGE_DATE
				AND C.ITERATOR_ID(+) = B.ITERATOR_ID
				AND D.CHARGE_ID(+) = B.CHARGE_ID
				AND D.ITERATOR_ID(+) = B.ITERATOR_ID
				AND E.CHARGE_ID(+) = B.CHARGE_ID
				) A,
			BILLING_CHARGE_DISPUTE B
		WHERE B.ENTITY_ID (+)= A.ENTITY_ID
			AND B.PRODUCT_ID (+)= A.PRODUCT_ID
			AND B.COMPONENT_ID (+)= A.COMPONENT_ID
			AND B.STATEMENT_TYPE (+)= A.STATEMENT_TYPE
			AND B.STATEMENT_STATE (+)= A.STATEMENT_STATE
            AND B.STATEMENT_DATE (+)= A.STATEMENT_DATE
			AND B.DISPUTE_DATE (+)= A.CHARGE_DATE
              ORDER BY A.CHARGE_DATE,
                     A.ITERATOR1_NAME, A.ITERATOR1_VAL,
                     A.ITERATOR2_NAME, A.ITERATOR2_VAL,
                     A.ITERATOR3_NAME, A.ITERATOR3_VAL,
                     A.ITERATOR4_NAME, A.ITERATOR4_VAL,
                     A.ITERATOR5_NAME, A.ITERATOR5_VAL,
                     A.VARIABLE_NAME;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END FORMULA_CHARGE_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE LMP_CHARGE_DETAIL
    (
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_WORK_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
    p_SHOW_BILL_AMOUNT IN NUMBER,
    p_SHOW_CHARGE_AMOUNT IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT A.SOURCE_NAME,
			A.SOURCE_ID,
            A.DELIVERY_POINT_NAME,
            A.DELIVERY_POINT_ID,
            A.SINK_NAME,
            A.SINK_ID,
            FROM_CUT_AS_HED(A.CHARGE_DATE, p_TIME_ZONE, GET_FORMAT_FROM_COMPONENT(A.COMPONENT_ID)) "CHARGE_DATE",
            A.DA_PURCHASES,
            A.RT_PURCHASES,
            A.DA_SALES,
            A.RT_SALES,
            A.DA_LOAD,
            A.RT_LOAD,
            A.DA_GENERATION,
            A.RT_GENERATION,
            A.PRICE1,
            A.PRICE2,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_QUANTITY END "CHARGE_QUANTITY",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_QUANTITY END "BILL_QUANTITY",
			A.CHARGE_RATE,
			A.CHARGE_FACTOR,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_AMOUNT END "CHARGE_AMOUNT",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_AMOUNT END "BILL_AMOUNT",
			B.DISPUTE_STATUS
		FROM (SELECT B.CHARGE_DATE,
        		B.SOURCE_ID,
                C.SERVICE_POINT_NAME "SOURCE_NAME",
        		B.DELIVERY_POINT_ID,
                D.SERVICE_POINT_NAME "DELIVERY_POINT_NAME",
        		B.SINK_ID,
                E.SERVICE_POINT_NAME "SINK_NAME",
                B.DA_PURCHASES,
                B.RT_PURCHASES,
                B.DA_SALES,
                B.RT_SALES,
                B.DA_LOAD,
                B.RT_LOAD,
                B.DA_GENERATION,
                B.RT_GENERATION,
                B.PRICE1,
                B.PRICE2,
				B.CHARGE_QUANTITY,
				B.BILL_QUANTITY,
				B.CHARGE_RATE,
				B.CHARGE_FACTOR,
				B.CHARGE_AMOUNT,
				B.BILL_AMOUNT,
				A.ENTITY_ID,
				A.STATEMENT_TYPE,
				A.STATEMENT_STATE,
                A.STATEMENT_DATE,
				A.PRODUCT_ID,
				A.COMPONENT_ID
			FROM BILLING_STATEMENT A,
				LMP_CHARGE B,
				SERVICE_POINT C,
				SERVICE_POINT D,
				SERVICE_POINT E,
				RTO_WORK X
			WHERE X.WORK_ID = p_WORK_ID
				AND B.CHARGE_ID = X.WORK_XID
				AND A.CHARGE_ID(+) = B.CHARGE_ID
				AND C.SERVICE_POINT_ID = NVL(B.SOURCE_ID,0)
				AND D.SERVICE_POINT_ID = NVL(B.DELIVERY_POINT_ID,0)
				AND E.SERVICE_POINT_ID = NVL(B.SINK_ID,0)) A,
			BILLING_CHARGE_DISPUTE B
		WHERE B.ENTITY_ID (+)= A.ENTITY_ID
			AND B.PRODUCT_ID (+)= A.PRODUCT_ID
			AND B.COMPONENT_ID (+)= A.COMPONENT_ID
			AND B.STATEMENT_TYPE (+)= A.STATEMENT_TYPE
			AND B.STATEMENT_STATE (+)= A.STATEMENT_STATE
            AND B.STATEMENT_DATE (+)= A.STATEMENT_DATE
			AND B.DISPUTE_DATE (+)= A.CHARGE_DATE
		ORDER BY A.CHARGE_DATE, A.SOURCE_NAME, A.DELIVERY_POINT_NAME, A.SINK_NAME;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END LMP_CHARGE_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE FTR_CHARGE_DETAIL
    (
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_WORK_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
    p_SHOW_BILL_AMOUNT IN NUMBER,
    p_SHOW_CHARGE_AMOUNT IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT A.SOURCE_NAME,
			A.SOURCE_ID,
            A.DELIVERY_POINT_NAME,
            A.DELIVERY_POINT_ID,
            A.SINK_NAME,
            A.SINK_ID,
            A.FTR_TYPE,
            FROM_CUT_AS_HED(A.CHARGE_DATE, p_TIME_ZONE, GET_FORMAT_FROM_COMPONENT(A.COMPONENT_ID)) "CHARGE_DATE",
            A.ALLOC_FACTOR,
            A.PURCHASES,
            A.SALES,
            A.PRICE1,
            A.PRICE2,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_QUANTITY END "CHARGE_QUANTITY",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_QUANTITY END "BILL_QUANTITY",
			A.CHARGE_RATE,
			A.CHARGE_FACTOR,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_AMOUNT END "CHARGE_AMOUNT",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_AMOUNT END "BILL_AMOUNT",
			B.DISPUTE_STATUS
		FROM (SELECT B.CHARGE_DATE,
        		B.SOURCE_ID,
                C.SERVICE_POINT_NAME "SOURCE_NAME",
        		B.DELIVERY_POINT_ID,
                D.SERVICE_POINT_NAME "DELIVERY_POINT_NAME",
        		B.SINK_ID,
                E.SERVICE_POINT_NAME "SINK_NAME",
                B.FTR_TYPE,
                B.ALLOC_FACTOR,
                B.PURCHASES,
                B.SALES,
                B.PRICE1,
                B.PRICE2,
				B.CHARGE_QUANTITY,
				B.BILL_QUANTITY,
				B.CHARGE_RATE,
				B.CHARGE_FACTOR,
				B.CHARGE_AMOUNT,
				B.BILL_AMOUNT,
				A.ENTITY_ID,
				A.STATEMENT_TYPE,
				A.STATEMENT_STATE,
                A.STATEMENT_DATE,
				A.PRODUCT_ID,
				A.COMPONENT_ID
			FROM BILLING_STATEMENT A,
				FTR_CHARGE B,
				SERVICE_POINT C,
				SERVICE_POINT D,
				SERVICE_POINT E,
				RTO_WORK X
			WHERE X.WORK_ID = p_WORK_ID
				AND B.CHARGE_ID = X.WORK_XID
				AND A.CHARGE_ID(+) = B.CHARGE_ID
				AND C.SERVICE_POINT_ID = NVL(B.SOURCE_ID,0)
				AND D.SERVICE_POINT_ID = NVL(B.DELIVERY_POINT_ID,0)
				AND E.SERVICE_POINT_ID = NVL(B.SINK_ID,0)) A,
			BILLING_CHARGE_DISPUTE B
		WHERE B.ENTITY_ID (+)= A.ENTITY_ID
			AND B.PRODUCT_ID (+)= A.PRODUCT_ID
			AND B.COMPONENT_ID (+)= A.COMPONENT_ID
			AND B.STATEMENT_TYPE (+)= A.STATEMENT_TYPE
			AND B.STATEMENT_STATE (+)= A.STATEMENT_STATE
            AND B.STATEMENT_DATE (+)= A.STATEMENT_DATE
			AND B.DISPUTE_DATE (+)= A.CHARGE_DATE
		ORDER BY A.CHARGE_DATE, A.FTR_TYPE, A.SOURCE_NAME, A.DELIVERY_POINT_NAME, A.SINK_NAME;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END FTR_CHARGE_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE COMBINATION_CHARGE_DETAIL
    (
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_WORK_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
    p_SHOW_BILL_AMOUNT IN NUMBER,
    p_SHOW_CHARGE_AMOUNT IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(A.CHARGE_DATE, p_TIME_ZONE, 'DD') "CHARGE_DATE",
			FROM_CUT_AS_HED(A.CHARGE_END_DATE, p_TIME_ZONE, 'DD') "CHARGE_END_DATE",
			A.COMBINED_COMPONENT_ID "COMPONENT_ID",
			A.CHARGE_ID,
            A.COMBINED_CHARGE_ID,
            A.CHARGE_VIEW_TYPE,
			A.COMPONENT_NAME,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_QUANTITY END "CHARGE_QUANTITY",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_QUANTITY END "BILL_QUANTITY",
			A.CHARGE_RATE,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.COMPONENT_AMOUNT END "COMPONENT_AMOUNT",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_COMPONENT_AMOUNT END "BILL_COMPONENT_AMOUNT",
            A.COEFFICIENT,
			A.CHARGE_FACTOR,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_AMOUNT END "CHARGE_AMOUNT",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_AMOUNT END "BILL_AMOUNT",
			B.DISPUTE_STATUS
		FROM (SELECT B.CHARGE_ID,
				B.BEGIN_DATE+1/86400 "CHARGE_DATE",
				B.END_DATE+1/86400 "CHARGE_END_DATE",
				B.COMPONENT_ID "COMBINED_COMPONENT_ID",
				B.COMBINED_CHARGE_ID,
				B.CHARGE_VIEW_TYPE,
				COMPONENT_NAME,
				B.CHARGE_QUANTITY,
				B.BILL_QUANTITY,
				B.CHARGE_RATE,
				B.COMPONENT_AMOUNT,
				B.BILL_COMPONENT_AMOUNT,
				B.COEFFICIENT,
				B.CHARGE_FACTOR,
				B.CHARGE_AMOUNT,
				B.BILL_AMOUNT,
				A.ENTITY_ID,
				A.STATEMENT_TYPE,
				A.STATEMENT_STATE,
                A.STATEMENT_DATE,
				A.PRODUCT_ID,
				A.COMPONENT_ID
			FROM BILLING_STATEMENT A,
				COMBINATION_CHARGE B,
				COMPONENT C,
				RTO_WORK X
			WHERE X.WORK_ID = p_WORK_ID
				AND B.CHARGE_ID = X.WORK_XID
				AND A.CHARGE_ID(+) = B.CHARGE_ID
				AND C.COMPONENT_ID(+) = NVL(B.COMPONENT_ID,0)) A,
			BILLING_CHARGE_DISPUTE B
		WHERE B.ENTITY_ID (+)= A.ENTITY_ID
			AND B.PRODUCT_ID (+)= A.PRODUCT_ID
			AND B.COMPONENT_ID (+)= A.COMPONENT_ID
			AND B.STATEMENT_TYPE (+)= A.STATEMENT_TYPE
			AND B.STATEMENT_STATE (+)= A.STATEMENT_STATE
            AND B.STATEMENT_DATE (+)= A.STATEMENT_DATE
			AND B.DISPUTE_DATE (+)= A.CHARGE_DATE
		ORDER BY 1, 2, 7;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END COMBINATION_CHARGE_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE TAX_CHARGE_DETAIL
    (
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_WORK_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
    p_SHOW_BILL_AMOUNT IN NUMBER,
    p_SHOW_CHARGE_AMOUNT IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(A.CHARGE_DATE, p_TIME_ZONE, GET_FORMAT_FROM_COMPONENT(A.COMPONENT_ID), p_MODEL_ID) "CHARGE_DATE",
			A.TAX_AREA_TYPE,
			A.TAX_AREA_NAME,
			A.PRODUCT_ID,
			A.PRODUCT_NAME,
			A.COMPONENT_ID,
			A.COMPONENT_NAME,
			A.SERVICE_POINT_NAME,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_QUANTITY END "CHARGE_QUANTITY",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_QUANTITY END "BILL_QUANTITY",
			A.CHARGE_RATE,
			A.CHARGE_FACTOR,
			CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE A.CHARGE_AMOUNT END "CHARGE_AMOUNT",
			CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE A.BILL_AMOUNT END "BILL_AMOUNT",
			B.DISPUTE_STATUS
		FROM (SELECT B.CHARGE_DATE,
				F.GEOGRAPHY_TYPE "TAX_AREA_TYPE",
				NVL(F.DISPLAY_NAME,F.GEOGRAPHY_NAME) "TAX_AREA_NAME",
				B.PRODUCT_ID,
				C.PRODUCT_NAME,
				B.COMPONENT_ID,
				D.COMPONENT_NAME,
				E.SERVICE_POINT_NAME,
				B.CHARGE_QUANTITY,
				B.BILL_QUANTITY,
				B.CHARGE_RATE,
				B.CHARGE_FACTOR,
				B.CHARGE_AMOUNT,
				B.BILL_AMOUNT,
				A.ENTITY_ID,
				A.STATEMENT_TYPE,
				A.STATEMENT_STATE,
                A.STATEMENT_DATE,
				A.PRODUCT_ID "BS_PRODUCT_ID",
				A.COMPONENT_ID "BS_COMPONENT_ID"
			FROM BILLING_STATEMENT A, TAX_CHARGE B, PRODUCT C, COMPONENT D, SERVICE_POINT E, GEOGRAPHY F, RTO_WORK X
			WHERE X.WORK_ID = p_WORK_ID
				AND B.CHARGE_ID = X.WORK_XID
				AND A.CHARGE_ID(+) = B.CHARGE_ID
				AND C.PRODUCT_ID = B.PRODUCT_ID
				AND D.COMPONENT_ID = B.COMPONENT_ID
				AND E.SERVICE_POINT_ID = NVL(B.SERVICE_POINT_ID,0)
                AND F.GEOGRAPHY_ID = B.GEOGRAPHY_ID) A,
			BILLING_CHARGE_DISPUTE B
		WHERE B.ENTITY_ID (+)= A.ENTITY_ID
			AND B.PRODUCT_ID (+)= A.BS_PRODUCT_ID
			AND B.COMPONENT_ID (+)= A.BS_COMPONENT_ID
			AND B.STATEMENT_TYPE (+)= A.STATEMENT_TYPE
			AND B.STATEMENT_STATE (+)= A.STATEMENT_STATE
            AND B.STATEMENT_DATE (+)= A.STATEMENT_DATE
			AND B.DISPUTE_DATE (+)= A.CHARGE_DATE
		ORDER BY A.CHARGE_DATE, A.TAX_AREA_TYPE, A.PRODUCT_NAME, A.COMPONENT_NAME;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END TAX_CHARGE_DETAIL;
---------------------------------------------------------------------------------------------------
FUNCTION GET_COMBINED_CHARGE_ID
	(
	p_CHARGE_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_AS_OF_DATE IN DATE
	) RETURN NUMBER IS
v_CHARGE_ID NUMBER := p_CHARGE_ID;
v_COMPONENT_ID NUMBER;
v_BEGIN_DATE DATE;
v_BILLING_STATEMENT BILLING_STATEMENT%ROWTYPE;
BEGIN
	-- make sure v_CHARGE_ID has correct charge ID - sor correct it to make
	-- sure it corresponds to a charge w/ same STATEMENT_TYPE and STATEMENT_STATE
	BEGIN
        SELECT * INTO v_BILLING_STATEMENT
        FROM BILLING_STATEMENT WHERE CHARGE_ID = v_CHARGE_ID;

		-- if wrong statement type/state, fetch corrected one
        IF v_BILLING_STATEMENT.STATEMENT_TYPE <> p_STATEMENT_TYPE OR
		   v_BILLING_STATEMENT.STATEMENT_STATE <> p_STATEMENT_STATE THEN
			SELECT CHARGE_ID INTO v_CHARGE_ID
			FROM BILLING_STATEMENT A
            WHERE A.ENTITY_ID = v_BILLING_STATEMENT.ENTITY_ID
            	AND A.PRODUCT_ID = v_BILLING_STATEMENT.PRODUCT_ID
            	AND A.COMPONENT_ID = v_BILLING_STATEMENT.COMPONENT_ID
            	AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
            	AND A.STATEMENT_STATE = p_STATEMENT_STATE
            	AND A.STATEMENT_DATE = v_BILLING_STATEMENT.STATEMENT_DATE
            	AND A.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
            						FROM BILLING_STATEMENT
            						WHERE ENTITY_ID = A.ENTITY_ID
            							AND PRODUCT_ID = A.PRODUCT_ID
            							AND COMPONENT_ID = A.COMPONENT_ID
            							AND STATEMENT_TYPE = A.STATEMENT_TYPE
            							AND STATEMENT_STATE = A.STATEMENT_STATE
            							AND STATEMENT_DATE = A.STATEMENT_DATE
            							AND AS_OF_DATE <= p_AS_OF_DATE);
		END IF;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			-- not found in billing_statement? then it is a nested combination charge.
			-- so first fetch parent's charge ID
			SELECT COMPONENT_ID, CHARGE_ID, BEGIN_DATE
			INTO v_COMPONENT_ID, v_CHARGE_ID, v_BEGIN_DATE
			FROM COMBINATION_CHARGE
			WHERE COMBINED_CHARGE_ID = v_CHARGE_ID;
			-- then use that to recursively get this charge's corrected charge ID
			v_CHARGE_ID := GET_COMBINED_CHARGE_ID(v_CHARGE_ID,v_COMPONENT_ID,v_BEGIN_DATE,p_STATEMENT_TYPE,p_STATEMENT_STATE,p_AS_OF_DATE);
	END;

	-- now that we know we have the correct parent charge ID, query the child's charge ID
    SELECT COMBINED_CHARGE_ID
    INTO v_CHARGE_ID
    FROM COMBINATION_CHARGE
    WHERE CHARGE_ID = v_CHARGE_ID
    	AND COMPONENT_ID = p_COMPONENT_ID
	    AND BEGIN_DATE = p_BEGIN_DATE;

	RETURN v_CHARGE_ID;

EXCEPTION
	WHEN OTHERS THEN
		RETURN 0; -- return zero ID on failure
END GET_COMBINED_CHARGE_ID;
---------------------------------------------------------------------------------------------------
PROCEDURE CHARGE_COMPONENT_DETAIL
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_BEGIN_DATE IN OUT DATE,
	p_END_DATE IN DATE,
	p_ENTITY_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_CHARGE_VIEW_TYPE IN VARCHAR,
	p_BAND_KEYWORD OUT VARCHAR,
	p_HAS_SUBTOTALS OUT NUMBER,
	p_KEY_COLUMNS OUT VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
v_BEGIN_DATE DATE := PC.GET_CORRECT_STATEMENT_DATE(p_CALLING_MODULE,p_ENTITY_ID,p_BEGIN_DATE);
v_END_DATE DATE := TRUNC(p_END_DATE);
v_WORK_ID NUMBER;
v_COMBO_CHARGE_ID NUMBER;
BEGIN
	UT.GET_RTO_WORK_ID(v_WORK_ID);

	-- first collect all applicable charge IDs
	IF p_PRODUCT_ID < 0 THEN
		-- negative Product ID indicates the Charge ID of a Combination Charge
		v_COMBO_CHARGE_ID := GET_COMBINED_CHARGE_ID(-p_PRODUCT_ID,p_COMPONENT_ID,p_BEGIN_DATE,p_STATEMENT_TYPE,p_STATEMENT_STATE,p_AS_OF_DATE);
		INSERT INTO RTO_WORK(WORK_ID, WORK_XID)
			VALUES (v_WORK_ID, v_COMBO_CHARGE_ID);
	ELSE
		INSERT INTO RTO_WORK(WORK_ID, WORK_XID)
    	SELECT v_WORK_ID, CHARGE_ID
    	FROM BILLING_STATEMENT A
        WHERE A.ENTITY_ID = p_ENTITY_ID
    	    AND A.PRODUCT_ID = p_PRODUCT_ID
    	    AND A.COMPONENT_ID = p_COMPONENT_ID
    	    AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
    	    AND A.STATEMENT_STATE = p_STATEMENT_STATE
    	    AND A.STATEMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
    	    AND A.AS_OF_DATE =
    	    	(SELECT MAX(AS_OF_DATE)
    	    	FROM BILLING_STATEMENT
    	    	WHERE ENTITY_ID = A.ENTITY_ID
    	    		AND PRODUCT_ID = A.PRODUCT_ID
    	    		AND COMPONENT_ID = A.COMPONENT_ID
    	    		AND STATEMENT_TYPE = A.STATEMENT_TYPE
    	    		AND STATEMENT_STATE = A.STATEMENT_STATE
    	    		AND STATEMENT_DATE = A.STATEMENT_DATE
    	    		AND AS_OF_DATE <= p_AS_OF_DATE);

	    p_BEGIN_DATE := v_BEGIN_DATE;
	END IF;

	p_BAND_KEYWORD := '';
	p_HAS_SUBTOTALS := 0;
	p_KEY_COLUMNS := 'CHARGE_DATE';
	IF UPPER(p_CHARGE_VIEW_TYPE) = 'ACCOUNT SERVICE' THEN
		ACCOUNT_SERVICE_CHARGE_DETAIL(p_CALLING_MODULE,p_MODEL_ID,v_WORK_ID,p_TIME_ZONE,p_AS_OF_DATE,1,1,p_STATUS,p_CURSOR);
		p_KEY_COLUMNS := 'ACCOUNT|SERVICE_LOCATION|METER|CHARGE_BEGIN_DATE';
	ELSIF UPPER(p_CHARGE_VIEW_TYPE) = 'BILLING CHARGE' OR
	      UPPER(p_CHARGE_VIEW_TYPE) = 'COINCIDENT PEAK' THEN
		BILLING_CHARGE_DETAIL(p_CALLING_MODULE,p_MODEL_ID,v_WORK_ID,p_TIME_ZONE,p_AS_OF_DATE,1,1,p_STATUS,p_CURSOR);
	ELSIF UPPER(p_CHARGE_VIEW_TYPE) = 'ENTITY ATTRIBUTE' THEN
		ENTITY_ATTRIBUTE_CHARGE_DETAIL(p_CALLING_MODULE,p_MODEL_ID,v_WORK_ID,p_TIME_ZONE,p_AS_OF_DATE,1,1,p_STATUS,p_CURSOR);
		p_HAS_SUBTOTALS := 1;
		p_KEY_COLUMNS := 'FACILITY|CHARGE_DATE';
	ELSIF SUBSTR(UPPER(p_CHARGE_VIEW_TYPE),1,9) = 'IMBALANCE' THEN
		IMBALANCE_CHARGE_DETAIL(p_CALLING_MODULE,p_MODEL_ID,v_WORK_ID,p_TIME_ZONE,p_AS_OF_DATE,1,1,p_STATUS,p_CURSOR);
		p_BAND_KEYWORD := 'BAND';
	ELSIF UPPER(p_CHARGE_VIEW_TYPE) = 'TRANSMISSION' THEN
		TRANSMISSION_CHARGE_DETAIL(p_CALLING_MODULE,p_MODEL_ID,v_WORK_ID,p_TIME_ZONE,p_AS_OF_DATE,1,1,p_STATUS,p_CURSOR);
		p_HAS_SUBTOTALS := 1;
		p_KEY_COLUMNS := 'TRANSACTION_ID|CHARGE_DATE';
	ELSIF UPPER(p_CHARGE_VIEW_TYPE) = 'OP PROFIT' THEN
		OPER_PROFIT_CHARGE_DETAIL(p_CALLING_MODULE,p_MODEL_ID,v_WORK_ID,p_TIME_ZONE,p_AS_OF_DATE,1,1,p_STATUS,p_CURSOR);
		p_BAND_KEYWORD := 'SET';
	ELSIF UPPER(p_CHARGE_VIEW_TYPE) = 'CONVERSION' THEN
		CONVERSION_CHARGE_DETAIL(p_CALLING_MODULE,p_MODEL_ID,v_WORK_ID,p_TIME_ZONE,p_AS_OF_DATE,1,1,p_STATUS,p_CURSOR);
		p_HAS_SUBTOTALS := 1;
		p_KEY_COLUMNS := 'SCHEDULE_GROUP|CHARGE_DATE';
	ELSIF UPPER(p_CHARGE_VIEW_TYPE) = 'FORMULA' THEN
		FORMULA_CHARGE_DETAIL(p_CALLING_MODULE,p_MODEL_ID,v_WORK_ID,p_TIME_ZONE,p_AS_OF_DATE,1,1,p_STATUS,p_CURSOR);
		p_BAND_KEYWORD := 'VARIABLE';
		p_KEY_COLUMNS := 'ITERATOR5_VAL|ITERATOR4_VAL|ITERATOR3_VAL|ITERATOR2_VAL|ITERATOR1_VAL|CHARGE_DATE';
	ELSIF SUBSTR(UPPER(p_CHARGE_VIEW_TYPE),1,3) = 'LMP' THEN
		LMP_CHARGE_DETAIL(p_CALLING_MODULE,p_MODEL_ID,v_WORK_ID,p_TIME_ZONE,p_AS_OF_DATE,1,1,p_STATUS,p_CURSOR);
		p_HAS_SUBTOTALS := 1;
		p_KEY_COLUMNS := 'SOURCE_ID|DELIVERY_POINT_ID|SINK_ID|CHARGE_DATE';
	ELSIF SUBSTR(UPPER(p_CHARGE_VIEW_TYPE),1,3) = 'FTR' THEN
		FTR_CHARGE_DETAIL(p_CALLING_MODULE,p_MODEL_ID,v_WORK_ID,p_TIME_ZONE,p_AS_OF_DATE,1,1,p_STATUS,p_CURSOR);
		p_HAS_SUBTOTALS := 1;
		p_KEY_COLUMNS := 'SOURCE_ID|DELIVERY_POINT_ID|SINK_ID|FTR_TYPE|CHARGE_DATE';
	ELSIF UPPER(p_CHARGE_VIEW_TYPE) = 'COMBINATION' THEN
		COMBINATION_CHARGE_DETAIL(p_CALLING_MODULE,p_MODEL_ID,v_WORK_ID,p_TIME_ZONE,p_AS_OF_DATE,1,1,p_STATUS,p_CURSOR);
		p_HAS_SUBTOTALS := 1;
		p_KEY_COLUMNS := 'COMPONENT_ID|CHARGE_DATE';
	ELSIF UPPER(p_CHARGE_VIEW_TYPE) = 'TAX CHARGE' THEN
		TAX_CHARGE_DETAIL(p_CALLING_MODULE,p_MODEL_ID,v_WORK_ID,p_TIME_ZONE,p_AS_OF_DATE,1,1,p_STATUS,p_CURSOR);
		p_HAS_SUBTOTALS := 1;
		p_KEY_COLUMNS := 'PRODUCT_ID|COMPONENT_ID|TAX_AREA_TYPE|CHARGE_DATE';
	ELSE -- IF UPPER(p_CHARGE_VIEW_TYPE) = 'EXTERNAL' THEN
		XS.GET_CHARGE_DETAIL(p_CALLING_MODULE,p_MODEL_ID,p_CHARGE_VIEW_TYPE,p_ENTITY_ID,p_COMPONENT_ID,v_WORK_ID,p_TIME_ZONE,p_AS_OF_DATE,p_BAND_KEYWORD,p_HAS_SUBTOTALS,1,1,p_STATUS,p_CURSOR);
		XS.GET_CHARGE_KEY_COLUMNS(p_CALLING_MODULE,p_MODEL_ID,p_CHARGE_VIEW_TYPE,p_ENTITY_ID,p_COMPONENT_ID,p_KEY_COLUMNS,p_STATUS);
		p_KEY_COLUMNS := REPLACE(p_KEY_COLUMNS,',','|');
	END IF;

	UT.PURGE_RTO_WORK(v_WORK_ID);

EXCEPTION
	WHEN OTHERS THEN
		UT.PURGE_RTO_WORK(v_WORK_ID);
		p_STATUS := SQLCODE;
END CHARGE_COMPONENT_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE SCHEDULE_BY_TRANSMISSION
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_TRANSACTION_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_STATEMENT_BEGIN_DATE DATE;
v_STATEMENT_END_DATE DATE;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_TIME_ZONE VARCHAR2(16);

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

    SELECT MIN(STATEMENT_DATE),
    	NVL(MAX(STATEMENT_END_DATE),TRUNC(p_END_DATE))
    INTO v_STATEMENT_BEGIN_DATE, v_STATEMENT_END_DATE
    FROM BILLING_STATEMENT A
    WHERE A.ENTITY_ID = p_ENTITY_ID
    	AND A.PRODUCT_ID = p_PRODUCT_ID
        AND A.COMPONENT_ID = p_COMPONENT_ID
        AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
        AND A.STATEMENT_STATE = p_STATEMENT_STATE
        AND A.STATEMENT_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
        AND A.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
        					FROM BILLING_STATEMENT
                            WHERE ENTITY_ID = A.ENTITY_ID
                            	AND PRODUCT_ID = A.PRODUCT_ID
                                AND COMPONENT_ID = A.COMPONENT_ID
                                AND STATEMENT_TYPE = A.STATEMENT_TYPE
                                AND STATEMENT_STATE = A.STATEMENT_STATE
                                AND STATEMENT_DATE = A.STATEMENT_DATE
                                AND AS_OF_DATE <= p_AS_OF_DATE);
	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING THEN
    	SELECT NVL(TIME_ZONE,LOCAL_TIME_ZONE)
        INTO v_TIME_ZONE
        FROM PURCHASING_SELLING_ENTITY
        WHERE PSE_ID = p_ENTITY_ID;
    ELSE
    	v_TIME_ZONE := LOCAL_TIME_ZONE;
    END IF;
    UT.CUT_DATE_RANGE(v_STATEMENT_BEGIN_DATE, v_STATEMENT_END_DATE, v_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(B.SCHEDULE_DATE, p_TIME_ZONE, GET_FORMAT_FROM_INTERVAL(A.TRANSACTION_INTERVAL)) "SCHEDULE_DATE",
        	B.TRANSACTION_ID,
        	A.TRANSACTION_NAME,
        	B.AMOUNT "TRANSACTION_AMOUNT",
			B.PRICE "TRANSACTION_PRICE"
		FROM INTERCHANGE_TRANSACTION A,
			IT_SCHEDULE B,
			BILLING_STATEMENT C
		WHERE C.ENTITY_ID = p_ENTITY_ID
			AND C.PRODUCT_ID = p_PRODUCT_ID
			AND C.COMPONENT_ID = p_COMPONENT_ID
			AND C.STATEMENT_TYPE = p_STATEMENT_TYPE
			AND C.STATEMENT_STATE = p_STATEMENT_STATE
			AND C.STATEMENT_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
			AND C.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM BILLING_STATEMENT
				WHERE ENTITY_ID = C.ENTITY_ID
					AND PRODUCT_ID = C.PRODUCT_ID
					AND COMPONENT_ID = C.COMPONENT_ID
					AND STATEMENT_TYPE = C.STATEMENT_TYPE
					AND STATEMENT_STATE = C.STATEMENT_STATE
					AND STATEMENT_DATE = C.STATEMENT_DATE
					AND AS_OF_DATE <= p_AS_OF_DATE)
			AND A.TX_TRANSACTION_ID = p_TRANSACTION_ID
			AND B.TRANSACTION_ID = A.TRANSACTION_ID
			AND B.SCHEDULE_TYPE = p_STATEMENT_TYPE
			AND B.SCHEDULE_STATE = p_STATEMENT_STATE
			AND B.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND B.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM IT_SCHEDULE
				WHERE TRANSACTION_ID = B.TRANSACTION_ID
					AND SCHEDULE_TYPE = B.SCHEDULE_TYPE
					AND SCHEDULE_STATE = B.SCHEDULE_STATE
					AND SCHEDULE_DATE = B.SCHEDULE_DATE
					AND AS_OF_DATE <= C.BASIS_AS_OF_DATE)
		ORDER BY B.SCHEDULE_DATE, B.TRANSACTION_ID;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END SCHEDULE_BY_TRANSMISSION;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_INVOICE_LINE_ITEM
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
    p_STATEMENT_STATE IN NUMBER,
	p_INVOICE_DATE IN DATE,
	p_INVOICE_ID IN NUMBER,
	p_OLD_LINE_ITEM_NAME IN VARCHAR,
	p_LINE_ITEM_NAME IN VARCHAR,
    p_LINE_ITEM_CATEGORY IN VARCHAR,
	p_LINE_ITEM_TYPE IN CHAR,
	p_LINE_ITEM_QUANTITY IN NUMBER,
	p_LINE_ITEM_RATE IN NUMBER,
	p_LINE_ITEM_AMOUNT IN NUMBER,
	p_LINE_ITEM_BILL_AMOUNT IN NUMBER,
    p_DEFAULT_DISPLAY IN VARCHAR,
    p_INVOICE_GROUP_ID IN NUMBER,
    p_INVOICE_GROUP_ORDER IN NUMBER,
    p_EXCLUDE_FROM_INVOICE_TOTAL IN NUMBER,
    p_IS_TAXED IN NUMBER,
    p_TAX_COMPONENT_ID IN NUMBER,
    p_TAX_GEOGRAPHY_ID IN NUMBER,
	p_STATUS OUT NUMBER
	) AS
v_INVOICE_LINE_ITEM INVOICE_LINE_ITEM%ROWTYPE;
v_INVOICE_USER_LINE_ITEM INVOICE_USER_LINE_ITEM%ROWTYPE;
v_INVOICE_DATE DATE;
BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING AND
	   NOT SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_PSE_INVOICE_LINE_ITEM, p_ENTITY_ID) THEN
	   		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;
	BEGIN
	    SELECT BEGIN_DATE INTO v_INVOICE_DATE
	    FROM INVOICE
	    WHERE INVOICE_ID = p_INVOICE_ID;
	EXCEPTION
    	WHEN NO_DATA_FOUND THEN
        	v_INVOICE_DATE := p_INVOICE_DATE;
	END;

	IF p_LINE_ITEM_TYPE = 'C' OR p_LINE_ITEM_TYPE = 'T' THEN
		v_INVOICE_LINE_ITEM.INVOICE_ID := p_INVOICE_ID;
		v_INVOICE_LINE_ITEM.LINE_ITEM_NAME := p_LINE_ITEM_NAME;
        v_INVOICE_LINE_ITEM.LINE_ITEM_CATEGORY := p_LINE_ITEM_CATEGORY;
		v_INVOICE_LINE_ITEM.LINE_ITEM_QUANTITY := p_LINE_ITEM_QUANTITY;
		v_INVOICE_LINE_ITEM.LINE_ITEM_RATE := p_LINE_ITEM_RATE;
		v_INVOICE_LINE_ITEM.LINE_ITEM_AMOUNT := p_LINE_ITEM_AMOUNT;
		v_INVOICE_LINE_ITEM.LINE_ITEM_BILL_AMOUNT := p_LINE_ITEM_BILL_AMOUNT;
        v_INVOICE_LINE_ITEM.DEFAULT_DISPLAY := p_DEFAULT_DISPLAY;
		PUT_INVOICE_LINE_ITEM(v_INVOICE_LINE_ITEM, p_OLD_LINE_ITEM_NAME);
	ELSE
		v_INVOICE_USER_LINE_ITEM.ENTITY_ID := p_ENTITY_ID;
		v_INVOICE_USER_LINE_ITEM.STATEMENT_TYPE := p_STATEMENT_TYPE;
		v_INVOICE_USER_LINE_ITEM.STATEMENT_STATE := p_STATEMENT_STATE;
		v_INVOICE_USER_LINE_ITEM.BEGIN_DATE := v_INVOICE_DATE;
		v_INVOICE_USER_LINE_ITEM.LINE_ITEM_TYPE := p_LINE_ITEM_TYPE;
		v_INVOICE_USER_LINE_ITEM.LINE_ITEM_NAME := p_LINE_ITEM_NAME;
        v_INVOICE_USER_LINE_ITEM.LINE_ITEM_CATEGORY := p_LINE_ITEM_CATEGORY;
		v_INVOICE_USER_LINE_ITEM.LINE_ITEM_QUANTITY := p_LINE_ITEM_QUANTITY;
		v_INVOICE_USER_LINE_ITEM.LINE_ITEM_RATE := p_LINE_ITEM_RATE;
		v_INVOICE_USER_LINE_ITEM.LINE_ITEM_AMOUNT := p_LINE_ITEM_AMOUNT;
		v_INVOICE_USER_LINE_ITEM.LINE_ITEM_BILL_AMOUNT := p_LINE_ITEM_BILL_AMOUNT;
        v_INVOICE_USER_LINE_ITEM.DEFAULT_DISPLAY := p_DEFAULT_DISPLAY;
		v_INVOICE_USER_LINE_ITEM.LINE_ITEM_POSTED_DATE := SYSDATE;
        v_INVOICE_USER_LINE_ITEM.INVOICE_GROUP_ID := p_INVOICE_GROUP_ID;
        v_INVOICE_USER_LINE_ITEM.INVOICE_GROUP_ORDER := p_INVOICE_GROUP_ORDER;
        v_INVOICE_USER_LINE_ITEM.EXCLUDE_FROM_INVOICE_TOTAL := p_EXCLUDE_FROM_INVOICE_TOTAL;
        v_INVOICE_USER_LINE_ITEM.IS_TAXED := p_IS_TAXED;
        v_INVOICE_USER_LINE_ITEM.TAX_COMPONENT_ID := p_TAX_COMPONENT_ID;
        v_INVOICE_USER_LINE_ITEM.TAX_GEOGRAPHY_ID := p_TAX_GEOGRAPHY_ID;
		PUT_INVOICE_USER_LINE_ITEM(v_INVOICE_USER_LINE_ITEM, p_OLD_LINE_ITEM_NAME);
	END IF;
EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END PUT_INVOICE_LINE_ITEM;
---------------------------------------------------------------------------------------------------
PROCEDURE DELETE_INVOICE_LINE_ITEM
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_INVOICE_DATE IN DATE,
	p_INVOICE_ID IN NUMBER,
	p_LINE_ITEM_NAME IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS
v_INVOICE_USER_LINE_ITEM INVOICE_USER_LINE_ITEM%ROWTYPE;
v_INVOICE_DATE DATE;
BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING AND
	   NOT SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_PSE_INVOICE_LINE_ITEM, p_ENTITY_ID) THEN
	   		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;
	BEGIN
	    SELECT BEGIN_DATE INTO v_INVOICE_DATE
	    FROM INVOICE
	    WHERE INVOICE_ID = p_INVOICE_ID;
	EXCEPTION
    	WHEN NO_DATA_FOUND THEN
        	v_INVOICE_DATE := p_INVOICE_DATE;
	END;

	DELETE INVOICE_LINE_ITEM
	WHERE INVOICE_ID = p_INVOICE_ID
		AND LINE_ITEM_NAME = p_LINE_ITEM_NAME;

    -- save user line item before deletion so we can correctly do tax info
	BEGIN
    	SELECT * INTO v_INVOICE_USER_LINE_ITEM
        FROM INVOICE_USER_LINE_ITEM
		WHERE ENTITY_ID = p_ENTITY_ID
			AND STATEMENT_TYPE = p_STATEMENT_TYPE
	        AND STATEMENT_STATE = p_STATEMENT_STATE
			AND BEGIN_DATE = v_INVOICE_DATE
			AND LINE_ITEM_NAME = p_LINE_ITEM_NAME;
    EXCEPTION
    	WHEN NO_DATA_FOUND THEN
        	NULL;
    END;
	DELETE INVOICE_USER_LINE_ITEM
	WHERE ENTITY_ID = p_ENTITY_ID
		AND STATEMENT_TYPE = p_STATEMENT_TYPE
        AND STATEMENT_STATE = p_STATEMENT_STATE
		AND BEGIN_DATE = v_INVOICE_DATE
		AND LINE_ITEM_NAME = p_LINE_ITEM_NAME;
	IF SQL%ROWCOUNT > 0 AND NVL(v_INVOICE_USER_LINE_ITEM.IS_TAXED,0) <> 0 THEN
    	-- deleted a taxed line item? then update taxes
        UPDATE_TAX_FOR_USER_LINE_ITEM (v_INVOICE_USER_LINE_ITEM, v_INVOICE_USER_LINE_ITEM, FALSE, FALSE, TRUE);
    END IF;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;
END DELETE_INVOICE_LINE_ITEM;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_INVOICE_STATUS
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_INVOICE_ID IN NUMBER,
	p_INVOICE_STATUS IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_INVOICE INVOICE%ROWTYPE;

BEGIN

	p_STATUS := GA.SUCCESS;

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING THEN
		DECLARE
			v_ENTITY_ID NUMBER(9);
		BEGIN
			SELECT ENTITY_ID INTO v_ENTITY_ID
			FROM INVOICE WHERE INVOICE_ID = p_INVOICE_ID;

			IF NOT SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_PSE_INVOICE_STATUS, v_ENTITY_ID) THEN
		   		RAISE INSUFFICIENT_PRIVILEGES;
			END IF;
		END;
	END IF;

	UPDATE INVOICE
	SET	INVOICE_STATUS = p_INVOICE_STATUS
	WHERE INVOICE_ID = p_INVOICE_ID;

	IF UPPER(SUBSTR(p_INVOICE_STATUS,1,4)) = 'VOID' THEN
		v_INVOICE := GET_INVOICE(p_INVOICE_ID);
		ROLLBACK_SERVICE_CONSUMPTION(v_INVOICE.ENTITY_ID, v_INVOICE.STATEMENT_TYPE, v_INVOICE.BEGIN_DATE);
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END PUT_INVOICE_STATUS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_INVOICE_DUE_DATE
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_INVOICE_ID IN NUMBER,
	p_DUE_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS

v_INVOICE INVOICE%ROWTYPE;

BEGIN

	p_STATUS := GA.SUCCESS;

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING THEN
		DECLARE
			v_ENTITY_ID NUMBER(9);
		BEGIN
			SELECT ENTITY_ID INTO v_ENTITY_ID
			FROM INVOICE WHERE INVOICE_ID = p_INVOICE_ID;

			IF NOT SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_PSE_INVOICE_DUE_DATE, v_ENTITY_ID) THEN
		   		RAISE INSUFFICIENT_PRIVILEGES;
			END IF;
		END;
	END IF;

	UPDATE INVOICE
	SET	PAYMENT_DUE_DATE = p_DUE_DATE
	WHERE INVOICE_ID = p_INVOICE_ID;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END PUT_INVOICE_DUE_DATE;
---------------------------------------------------------------------------------------------------
PROCEDURE EXPORT_BILLING
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATEMENT_TYPE IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	p_STATUS := GA.SUCCESS;

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	XS.EXPORT_BILLING(p_BEGIN_DATE, p_END_DATE, p_STATEMENT_TYPE, p_AS_OF_DATE, p_STATUS);

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END EXPORT_BILLING;
---------------------------------------------------------------------------------------------------
PROCEDURE EDC_IMBALANCE
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATEMENT_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE := TRUNC(p_BEGIN_DATE);
v_END_DATE DATE := TRUNC(p_END_DATE);

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(CHARGE_DATE, p_TIME_ZONE),
			   SYSTEM_OVER_SUPPLY,
			   SYSTEM_UNDER_SUPPLY,
			   SYSTEM_NET_POSITION,
			   OVER_SUPPLY_RATE,
			   UNDER_SUPPLY_RATE,
			   OSF_AMOUNT,
			   OSF_RATE,
			   REVENUE_AMOUNT,
			   BENEFIT_AMOUNT
		FROM NET_RETAIL_PROFIT_LOSS
		WHERE  STATEMENT_TYPE = p_STATEMENT_TYPE
		AND STATEMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND AS_OF_DATE = EDC_IMBALANCE_AS_OF_DATE(STATEMENT_TYPE, STATEMENT_DATE, p_AS_OF_DATE);

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END EDC_IMBALANCE;
---------------------------------------------------------------------------------------------------
PROCEDURE SERVICE_POINT_FOR_COMPONENT
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_SERVICE_POINT_ID OUT NUMBER,
	p_SERVICE_POINT_NAME OUT VARCHAR2,
	p_STATUS OUT NUMBER
	) AS

  v_IMBALANCE_TYPE COMPONENT.IMBALANCE_TYPE%TYPE;

BEGIN

	p_STATUS := GA.SUCCESS;

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	SELECT IMBALANCE_TYPE, SERVICE_POINT_ID INTO v_IMBALANCE_TYPE, p_SERVICE_POINT_ID
	FROM COMPONENT
	WHERE COMPONENT_ID = p_COMPONENT_ID;

	IF UPPER(SUBSTR(v_IMBALANCE_TYPE,1,1)) <> 'S' AND UPPER(SUBSTR(v_IMBALANCE_TYPE,1,1)) <> 'A' THEN
		p_SERVICE_POINT_ID := 0;
	END IF;
	IF p_SERVICE_POINT_ID <> 0 THEN
		SELECT SERVICE_POINT_NAME INTO p_SERVICE_POINT_NAME
		FROM SERVICE_POINT
		WHERE SERVICE_POINT_ID = p_SERVICE_POINT_ID;
	END IF;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_SERVICE_POINT_ID := 0;
		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END SERVICE_POINT_FOR_COMPONENT;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_NAMES_FOR_ACTION
    (
   	p_ACTION_NAME IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
v_VALID_IDs ID_TABLE;
BEGIN
    v_VALID_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(p_ACTION_NAME);

	p_STATUS := GA.SUCCESS;

    OPEN p_CURSOR FOR
    	SELECT PSE_NAME, PSE_ID
	    FROM PURCHASING_SELLING_ENTITY A,
	    	TABLE(CAST(v_VALID_IDs AS ID_TABLE)) B
		WHERE B.ID IN (SD.g_ALL_DATA_ENTITY_ID, A.PSE_ID)
	    	AND NVL(A.IS_BILLING_ENTITY,0) = 1
		ORDER BY 1;

END PSE_NAMES_FOR_ACTION;
---------------------------------------------------------------------------------------------------
PROCEDURE BILL_ENTITY_NAMES
    (
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_POSITION_AND_BILLING THEN
		OPEN p_CURSOR FOR
			  SELECT BILL_PARTY_NAME, BILL_PARTY_ID
			  FROM BILL_PARTY
			  WHERE BILL_PARTY_ID > 0
			  ORDER BY 1;
	ELSIF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_GAS_DELIVERY THEN
		 OPEN p_CURSOR FOR
		 		SELECT POOL_NAME, POOL_ID
				FROM POOL
				WHERE POOL_ID > 0
				ORDER BY 1;
	ELSIF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING THEN
		PSE_NAMES_FOR_ACTION(SD.g_ACTION_PSE_BILL_SELECT, p_STATUS, p_CURSOR);
	END IF;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END BILL_ENTITY_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE BILL_ENTITY_NAMES_TO_CALC
    (
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_POSITION_AND_BILLING OR
    	UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_GAS_DELIVERY THEN
    	 BILL_ENTITY_NAMES(p_CALLING_MODULE,p_MODEL_ID,p_STATUS,p_CURSOR);
	ELSE
		PSE_NAMES_FOR_ACTION(SD.g_ACTION_PSE_BILL_CALCULATE, p_STATUS, p_CURSOR);
	END IF;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END BILL_ENTITY_NAMES_TO_CALC;
---------------------------------------------------------------------------------------------------
PROCEDURE BILL_ENTITY_NAMES_BY_INTERVAL
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
    p_INTERVAL IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
BEGIN
	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_POSITION_AND_BILLING OR
    	UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_GAS_DELIVERY THEN
    	 BILL_ENTITY_NAMES(p_CALLING_MODULE,p_MODEL_ID,p_STATUS,p_CURSOR);
	ELSE
		DECLARE
			v_VALID_IDs ID_TABLE;
		BEGIN
	    	p_STATUS := GA.SUCCESS;
			v_VALID_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_PSE_BILL_SELECT);
	        OPEN p_CURSOR FOR
	        	SELECT PSE_NAME, PSE_ID
	            FROM PURCHASING_SELLING_ENTITY A,
					TABLE(CAST(v_VALID_IDs AS ID_TABLE)) B
				WHERE B.ID IN (SD.g_ALL_DATA_ENTITY_ID, A.PSE_ID)
	            	AND NVL(A.IS_BILLING_ENTITY,0) = 1
	            	AND DECODE(UPPER(SUBSTR(NVL(A.STATEMENT_INTERVAL,'Month'),1,2)),'DA',1,'WE',2,'MO',3,'QU',4,'YE',5) <=
	                		DECODE(UPPER(SUBSTR(p_INTERVAL,1,2)),'DA',1,'WE',2,'MO',3,'QU',4,'YE',5)
				ORDER BY A.PSE_NAME;
		END;
    END IF;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END BILL_ENTITY_NAMES_BY_INTERVAL;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_NAMES
    (
	 p_STATUS OUT NUMBER,
	 p_CURSOR IN OUT GA.REFCURSOR
	) AS
v_VALID_IDs ID_TABLE;
BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;
	v_VALID_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_PSE_BILL_SELECT);

	 OPEN p_CURSOR FOR
	 		SELECT PSE_NAME, PSE_ID
			FROM PURCHASING_SELLING_ENTITY A,
				TABLE(CAST(v_VALID_IDs AS ID_TABLE)) B
			WHERE B.ID IN (SD.g_ALL_DATA_ENTITY_ID, A.PSE_ID)
            	AND NVL(A.IS_BILLING_ENTITY,0) = 1
			ORDER BY 1;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END PSE_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE BILL_PARTY_NAMES
    (
	 p_STATUS OUT NUMBER,
	 p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	 OPEN p_CURSOR FOR
	 		SELECT BILL_PARTY_NAME, BILL_PARTY_ID
			FROM BILL_PARTY
			WHERE BILL_PARTY_ID > 0
			ORDER BY 1;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END BILL_PARTY_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE BILL_CYCLE_NAMES
    (
	 p_STATUS OUT NUMBER,
	 p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	 OPEN p_CURSOR FOR
	 		SELECT BILL_CYCLE_NAME, BILL_CYCLE_ID
			FROM BILL_CYCLE
			WHERE BILL_CYCLE_ID > 0
			ORDER BY 1;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END BILL_CYCLE_NAMES;
---------------------------------------------------------------------------------------------------
FUNCTION GET_CHARGE_ID
	(
	p_ENTITY_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_STATEMENT_DATE IN DATE,
	p_AS_OF_DATE IN DATE
	) RETURN NUMBER IS
v_CHARGE_ID NUMBER;
BEGIN
	SELECT CHARGE_ID INTO v_CHARGE_ID
	FROM BILLING_STATEMENT A
	WHERE ENTITY_ID = p_ENTITY_ID
		AND PRODUCT_ID = p_PRODUCT_ID
		AND COMPONENT_ID = p_COMPONENT_ID
		AND STATEMENT_TYPE = p_STATEMENT_TYPE
		AND STATEMENT_STATE = p_STATEMENT_STATE
		AND STATEMENT_DATE = p_STATEMENT_DATE
		AND AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM BILLING_STATEMENT
			WHERE ENTITY_ID = A.ENTITY_ID
				AND PRODUCT_ID = A.PRODUCT_ID
				AND COMPONENT_ID = A.COMPONENT_ID
				AND STATEMENT_TYPE = A.STATEMENT_TYPE
				AND STATEMENT_STATE = A.STATEMENT_STATE
				AND STATEMENT_DATE = A.STATEMENT_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE);
	RETURN v_CHARGE_ID;
END GET_CHARGE_ID;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_CHARGE_VIEW_TYPE
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_STATEMENT_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_CHARGE_VIEW_TYPE OUT VARCHAR,
	p_STATUS OUT NUMBER
	) AS
v_CHARGE_ID NUMBER;
BEGIN

	p_STATUS := GA.SUCCESS;

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    BEGIN
		-- get charge ID
		v_CHARGE_ID := GET_CHARGE_ID(p_ENTITY_ID, p_PRODUCT_ID, p_COMPONENT_ID, p_STATEMENT_TYPE, p_STATEMENT_STATE, p_STATEMENT_DATE, p_AS_OF_DATE);
		-- get charge view type
		SELECT CHARGE_VIEW_TYPE INTO p_CHARGE_VIEW_TYPE
		FROM BILLING_STATEMENT
		WHERE CHARGE_ID = v_CHARGE_ID;
	EXCEPTION
    	WHEN NO_DATA_FOUND THEN
        	-- try different period's charge view type for same charge
            SELECT CHARGE_VIEW_TYPE INTO p_CHARGE_VIEW_TYPE
            FROM (SELECT ABS(STATEMENT_DATE-p_STATEMENT_DATE) "DISTANCE",
            			CHARGE_VIEW_TYPE
	            FROM BILLING_STATEMENT
	            WHERE ENTITY_ID = p_ENTITY_ID
	            	AND PRODUCT_ID = p_PRODUCT_ID
	                AND COMPONENT_ID = p_COMPONENT_ID
                    AND STATEMENT_TYPE = p_STATEMENT_TYPE
                    AND STATEMENT_STATE = p_STATEMENT_STATE
				ORDER BY 1 ASC)
			WHERE ROWNUM=1;
    END;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END GET_CHARGE_VIEW_TYPE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_BILLING_CHARGE_DISPUTES
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_STATEMENT_DATE IN DATE,
	p_DISPUTE_DATES IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_TABLE GA.STRING_TABLE;
v_WORK_ID NUMBER;
v_DISP_DATE_STR VARCHAR(16);
v_DISP_TIME_STR VARCHAR(16);
v_DISPUTE_DATE DATE;

BEGIN
	UT.GET_RTO_WORK_ID(v_WORK_ID);
	UT.TOKENS_FROM_STRING(p_DISPUTE_DATES, '|', v_TABLE);

	-- gather the dates into RTO_WORK
	FOR v_INDEX IN v_TABLE.FIRST..v_TABLE.LAST LOOP
		SELECT SUBSTR(LTRIM(RTRIM(v_TABLE(v_INDEX))),1,10) INTO v_DISP_DATE_STR FROM DUAL;
		SELECT SUBSTR(LTRIM(RTRIM(v_TABLE(v_INDEX))),12) INTO v_DISP_TIME_STR FROM DUAL;
	    v_DISPUTE_DATE := DATE_TIME_AS_CUT(v_DISP_DATE_STR,v_DISP_TIME_STR,p_TIME_ZONE,1);
		UT.POST_RTO_WORK (v_WORK_ID, 0, v_DISPUTE_DATE);
	END LOOP;
	v_TABLE.DELETE;

	-- then fetch them all
	OPEN p_CURSOR FOR
		SELECT 	-- we can't use GET_FORMAT_FROM_COMPONENT because that would
			-- mess up tax charges (tax charge interval isn't used)
			-- assume that 1-second offset indicates day...
			FROM_CUT_AS_HED(A.DISPUTE_DATE,p_TIME_ZONE,DECODE(TO_CHAR(A.DISPUTE_DATE,'SS'),'01','DD','MI5')) "DISPUTE_DATE",
			A.OLD_BILL_AMOUNT "BILLED_AMOUNT",
			A.NEW_BILL_AMOUNT "CORRECTED_AMOUNT",
			A.DISPUTE_STATUS,
			A.DISPUTE_DESC "DESCRIPTION"
		FROM BILLING_CHARGE_DISPUTE A,
			RTO_WORK B
		WHERE B.WORK_ID = v_WORK_ID
			AND A.ENTITY_ID = p_ENTITY_ID
			AND A.PRODUCT_ID = p_PRODUCT_ID
			AND A.COMPONENT_ID = p_COMPONENT_ID
			AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
			AND A.STATEMENT_STATE = p_STATEMENT_STATE
            AND A.STATEMENT_DATE = p_STATEMENT_DATE
			AND A.DISPUTE_DATE = B.WORK_DATE
		ORDER BY 1;

	UT.PURGE_RTO_WORK(v_WORK_ID);

EXCEPTION
	WHEN OTHERS THEN
		  UT.PURGE_RTO_WORK(v_WORK_ID);
		  p_STATUS := SQLCODE;

END GET_BILLING_CHARGE_DISPUTES;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_BILLING_CHARGE_DISPUTE
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_STATEMENT_DATE IN DATE,
	p_DISPUTE_DATE IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_DISPUTE_STATUS IN VARCHAR,
	p_MARKET_STATUS IN VARCHAR,
	p_SUBMIT_STATUS IN VARCHAR,
	p_BILLED_AMOUNT IN NUMBER,
	p_CORRECT_AMOUNT IN NUMBER,
	p_DESCR IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS
v_DISP_DATE_STR VARCHAR(16);
v_DISP_TIME_STR VARCHAR(16);
v_DISPUTE_DATE DATE;
BEGIN
	p_STATUS := GA.SUCCESS;

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING AND
	   NOT SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_PSE_BILL_DISPUTES, p_ENTITY_ID) THEN
	   		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	SELECT SUBSTR(LTRIM(RTRIM(p_DISPUTE_DATE)),1,10) INTO v_DISP_DATE_STR FROM DUAL;
	SELECT SUBSTR(LTRIM(RTRIM(p_DISPUTE_DATE)),12) INTO v_DISP_TIME_STR FROM DUAL;
    v_DISPUTE_DATE := DATE_TIME_AS_CUT(v_DISP_DATE_STR,v_DISP_TIME_STR,p_TIME_ZONE,1);

	UPDATE BILLING_CHARGE_DISPUTE
	SET DISPUTE_STATUS = NVL(p_DISPUTE_STATUS,DISPUTE_STATUS),
    	MARKET_STATUS = NVL(p_MARKET_STATUS,MARKET_STATUS),
        SUBMIT_STATUS = NVL(p_SUBMIT_STATUS,SUBMIT_STATUS),
		OLD_BILL_AMOUNT = NVL(p_BILLED_AMOUNT,OLD_BILL_AMOUNT),
		NEW_BILL_AMOUNT = NVL(p_CORRECT_AMOUNT,NEW_BILL_AMOUNT),
		DISPUTE_DESC = NVL(p_DESCR,DISPUTE_DESC)
	WHERE ENTITY_ID = p_ENTITY_ID
		AND PRODUCT_ID = p_PRODUCT_ID
		AND COMPONENT_ID = p_COMPONENT_ID
		AND STATEMENT_TYPE = p_STATEMENT_TYPE
		AND STATEMENT_STATE = p_STATEMENT_STATE
        AND STATEMENT_DATE = p_STATEMENT_DATE
		AND DISPUTE_DATE = v_DISPUTE_DATE;

	IF SQL%NOTFOUND THEN
		INSERT INTO BILLING_CHARGE_DISPUTE (
			ENTITY_ID,
			PRODUCT_ID,
			COMPONENT_ID,
			STATEMENT_TYPE,
			STATEMENT_STATE,
            STATEMENT_DATE,
			DISPUTE_DATE,
			DISPUTE_STATUS,
            MARKET_STATUS,
            SUBMIT_STATUS,
			OLD_BILL_AMOUNT,
			NEW_BILL_AMOUNT,
			DISPUTE_DESC,
			ENTRY_DATE
		) VALUES (
			p_ENTITY_ID,
			p_PRODUCT_ID,
			p_COMPONENT_ID,
			p_STATEMENT_TYPE,
			p_STATEMENT_STATE,
            p_STATEMENT_DATE,
			v_DISPUTE_DATE,
			p_DISPUTE_STATUS,
            p_MARKET_STATUS,
            p_SUBMIT_STATUS,
			p_BILLED_AMOUNT,
			p_CORRECT_AMOUNT,
			p_DESCR,
			SYSDATE
		);
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END PUT_BILLING_CHARGE_DISPUTE;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_STATEMENT_STATUS
	(
    p_CALLING_MODULE IN VARCHAR,
    p_MODEL_ID IN NUMBER,
    p_ENTITY_ID IN NUMBER,
    p_STATEMENT_DATE IN DATE,
    p_STATEMENT_TYPE IN NUMBER,
    p_STATEMENT_STATE IN NUMBER,
    p_AS_OF_DATE IN DATE,
    p_REVIEW_STATUS IN VARCHAR,
    p_NOTES IN VARCHAR,
    p_STATUS OUT NUMBER
    ) AS
BEGIN
	p_STATUS := GA.SUCCESS;
	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING AND
	   NOT SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_PSE_BILL_STATUS, p_ENTITY_ID) THEN
	   		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    UPDATE BILLING_STATEMENT_STATUS
    SET REVIEW_STATUS = p_REVIEW_STATUS,
    	NOTES = p_NOTES
	WHERE ENTITY_ID = p_ENTITY_ID
    	AND STATEMENT_TYPE = p_STATEMENT_TYPE
        AND STATEMENT_STATE = p_STATEMENT_STATE
        AND STATEMENT_DATE = p_STATEMENT_DATE
        AND AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
	        			FROM BILLING_STATEMENT_STATUS
	                    WHERE ENTITY_ID = p_ENTITY_ID
                        	AND STATEMENT_TYPE = p_STATEMENT_TYPE
                            AND STATEMENT_STATE = p_STATEMENT_STATE
                            AND STATEMENT_DATE = p_STATEMENT_DATE
                        	AND AS_OF_DATE <= p_AS_OF_DATE);

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END PUT_STATEMENT_STATUS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_STATEMENT_STATUS_DETAILS
	(
    p_CALLING_MODULE IN VARCHAR,
    p_MODEL_ID IN NUMBER,
    p_ENTITY_ID IN NUMBER,
    p_STATEMENT_DATE IN DATE,
    p_STATEMENT_TYPE IN NUMBER,
    p_STATEMENT_STATE IN NUMBER,
    p_AS_OF_DATE IN DATE,
	p_REVIEW_STATUS OUT VARCHAR,
    p_NOTES OUT VARCHAR,
    p_INVOICE_BEGIN_DATE OUT DATE,
    p_INVOICE_END_DATE OUT DATE,
    p_INVOICE_ENTRY_DATE OUT DATE,
    p_STATEMENT_ENTRY_DATE OUT DATE,
    p_STATUS OUT NUMBER
    ) AS
BEGIN
	p_STATUS := GA.SUCCESS;
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	SELECT A.REVIEW_STATUS,
		A.NOTES,
		B.BEGIN_DATE "INVOICE_BEGIN_DATE",
		B.END_DATE "INVOICE_END_DATE",
		B.INVOICE_DATE "INVOICE_ENTRY_DATE",
		A.ENTRY_DATE "STATEMENT_ENTRY_DATE"
	INTO p_REVIEW_STATUS,
    	p_NOTES,
        p_INVOICE_BEGIN_DATE,
        p_INVOICE_END_DATE,
        p_INVOICE_ENTRY_DATE,
        p_STATEMENT_ENTRY_DATE
	FROM BILLING_STATEMENT_STATUS A,
		INVOICE B
	WHERE A.ENTITY_ID = p_ENTITY_ID
		AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
		AND A.STATEMENT_STATE = p_STATEMENT_STATE
		AND A.STATEMENT_DATE = TRUNC(p_STATEMENT_DATE)
		AND A.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM BILLING_STATEMENT_STATUS
			WHERE ENTITY_ID = A.ENTITY_ID
				AND STATEMENT_TYPE = A.STATEMENT_TYPE
				AND STATEMENT_STATE = A.STATEMENT_STATE
				AND STATEMENT_DATE = A.STATEMENT_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE)
		AND B.ENTITY_ID(+) = A.ENTITY_ID
		AND B.STATEMENT_TYPE(+) = A.STATEMENT_TYPE
		AND B.STATEMENT_STATE(+) = A.STATEMENT_STATE
		AND B.BEGIN_DATE(+) <= A.STATEMENT_DATE
		AND B.END_DATE(+) >= A.STATEMENT_DATE
		AND B.AS_OF_DATE(+) = INVOICE_AS_OF_DATE(A.ENTITY_ID,A.STATEMENT_TYPE,A.STATEMENT_STATE,A.STATEMENT_DATE,p_AS_OF_DATE)
		AND ROWNUM = 1; -- just in case we somehow have more then one row

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END GET_STATEMENT_STATUS_DETAILS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_STATEMENT_STATUS
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
v_BEGIN_DATE DATE := PC.GET_CORRECT_STATEMENT_DATE(p_CALLING_MODULE,p_ENTITY_ID,p_BEGIN_DATE);
v_END_DATE DATE := TRUNC(p_END_DATE);
v_VALID_IDs ID_TABLE;
BEGIN

	p_STATUS := GA.SUCCESS;

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING AND p_ENTITY_ID = g_ALL THEN
		v_VALID_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_PSE_BILL_SELECT);
	ELSE
		v_VALID_IDs := ID_TABLE();
		v_VALID_IDs.EXTEND();
		v_VALID_IDs(v_VALID_IDs.LAST) := ID_TYPE(p_ENTITY_ID);
	END IF;

	OPEN p_CURSOR FOR
		SELECT A.ENTITY_ID "PSE_ID",
			DECODE(UPPER(SUBSTR(p_CALLING_MODULE,1,1)),
            	g_POSITION_AND_BILLING, C.BILL_PARTY_NAME,
                g_SCHEDULING, D.PSE_NAME,
                g_GAS_DELIVERY, E.POOL_NAME, NULL) "PSE_NAME",
			A.STATEMENT_TYPE,
			A.STATEMENT_STATE,
			A.STATEMENT_DATE,
            A.AS_OF_DATE,
            A.REVIEW_STATUS,
			B.INVOICE_DATE "INVOICE_ENTRY_DATE",
			A.ENTRY_DATE "STATEMENT_ENTRY_DATE"
		FROM BILLING_STATEMENT_STATUS A,
			INVOICE B,
			BILL_PARTY C,
            PURCHASING_SELLING_ENTITY D,
            POOL E,
			TABLE(CAST(v_VALID_IDs AS ID_TABLE)) F
		WHERE F.ID IN (g_ALL, SD.g_ALL_DATA_ENTITY_ID, A.ENTITY_ID)
			AND A.STATEMENT_TYPE > 0
			AND A.STATEMENT_STATE IN (g_INTERNAL_STATE,g_EXTERNAL_STATE)
			AND A.STATEMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND A.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM BILLING_STATEMENT_STATUS
				WHERE ENTITY_ID = A.ENTITY_ID
					AND STATEMENT_TYPE = A.STATEMENT_TYPE
					AND STATEMENT_STATE = A.STATEMENT_STATE
					AND STATEMENT_DATE = A.STATEMENT_DATE
					AND AS_OF_DATE <= p_AS_OF_DATE)
			AND B.ENTITY_ID(+) = A.ENTITY_ID
			AND B.STATEMENT_TYPE(+) = A.STATEMENT_TYPE
			AND B.STATEMENT_STATE(+) = A.STATEMENT_STATE
			AND B.BEGIN_DATE(+) <= A.STATEMENT_DATE
			AND B.END_DATE(+) >= A.STATEMENT_DATE
			AND B.AS_OF_DATE(+) = INVOICE_AS_OF_DATE(A.ENTITY_ID,A.STATEMENT_TYPE,A.STATEMENT_STATE,A.STATEMENT_DATE,p_AS_OF_DATE)
			AND C.BILL_PARTY_ID(+) = A.ENTITY_ID
            AND D.PSE_ID(+) = A.ENTITY_ID
            AND E.POOL_ID(+) = A.ENTITY_ID
		ORDER BY 5, 2, 3, 4;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END GET_STATEMENT_STATUS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_PSE_DISPUTE_STATUS
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_STATUS_FILTER IN VARCHAR,
	p_STATEMENT_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_VALID_IDs ID_TABLE;
BEGIN

	p_STATUS := GA.SUCCESS;

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	IF p_ENTITY_ID = g_ALL THEN
		v_VALID_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_PSE_BILL_SELECT);
	ELSE
		v_VALID_IDs := ID_TABLE();
		v_VALID_IDs.EXTEND();
		v_VALID_IDs(v_VALID_IDs.LAST) := ID_TYPE(p_ENTITY_ID);
	END IF;

	UT.CUT_DATE_RANGE(TRUNC(p_BEGIN_DATE), TRUNC(p_END_DATE), p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	OPEN p_CURSOR FOR
		SELECT B.PSE_NAME "BILL_ENTITY",
			C.PRODUCT_NAME "PRODUCT",
			D.COMPONENT_NAME "COMPONENT",
            A.STATEMENT_DATE,
			-- we can't use GET_FORMAT_FROM_COMPONENT because that would
			-- mess up tax charges (tax charge interval isn't used)
			-- assume that 1-second offset indicates day...
			FROM_CUT_AS_HED(A.DISPUTE_DATE,p_TIME_ZONE,DECODE(TO_CHAR(A.DISPUTE_DATE,'SS'),'01','DD','MI5')) "DISPUTE_DATE",
			A.DISPUTE_STATUS,
			A.MARKET_STATUS,
			A.SUBMIT_STATUS,
			A.OLD_BILL_AMOUNT "BILLED_AMOUNT",
			A.NEW_BILL_AMOUNT "CORRECTED_AMOUNT",
			A.OLD_BILL_AMOUNT-A.NEW_BILL_AMOUNT "DIFFERENCE",
			A.DISPUTE_DESC "DESCRIPTION",
			A.ENTRY_DATE,
			A.ENTITY_ID,
			A.PRODUCT_ID,
			A.COMPONENT_ID,
			A.STATEMENT_TYPE,
			A.STATEMENT_STATE
		FROM BILLING_CHARGE_DISPUTE A,
			PURCHASING_SELLING_ENTITY B,
			PRODUCT C,
			COMPONENT D,
			TABLE(CAST(v_VALID_IDs AS ID_TABLE)) E
		WHERE E.ID IN (SD.g_ALL_DATA_ENTITY_ID, A.ENTITY_ID)
			AND (p_PRODUCT_ID = g_ALL OR A.PRODUCT_ID = p_PRODUCT_ID)
			AND (p_COMPONENT_ID = g_ALL OR A.COMPONENT_ID = p_COMPONENT_ID)
			AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
			AND A.STATEMENT_STATE = g_INTERNAL_STATE
			AND A.DISPUTE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND (UPPER(p_STATUS_FILTER) = g_ALL_STRING OR UPPER(A.DISPUTE_STATUS) = UPPER(p_STATUS_FILTER))
			AND B.PSE_ID = A.ENTITY_ID
			AND C.PRODUCT_ID = A.PRODUCT_ID
			AND D.COMPONENT_ID = A.COMPONENT_ID
		ORDER BY 1,2,3,4;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END GET_PSE_DISPUTE_STATUS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_POOL_DISPUTE_STATUS
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_STATUS_FILTER IN VARCHAR,
	p_STATEMENT_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
v_BEGIN_DATE DATE;
v_END_DATE DATE;
BEGIN

	p_STATUS := GA.SUCCESS;

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
	UT.CUT_DATE_RANGE(TRUNC(p_BEGIN_DATE), TRUNC(p_END_DATE), p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	OPEN p_CURSOR FOR
		SELECT B.POOL_NAME "BILL_ENTITY",
			C.PRODUCT_NAME "PRODUCT",
			D.COMPONENT_NAME "COMPONENT",
            A.STATEMENT_DATE,
			-- we can't use GET_FORMAT_FROM_COMPONENT because that would
			-- mess up tax charges (tax charge interval isn't used)
			-- assume that 1-second offset indicates day...
			FROM_CUT_AS_HED(A.DISPUTE_DATE,p_TIME_ZONE,DECODE(TO_CHAR(A.DISPUTE_DATE,'SS'),'01','DD','MI5')) "DISPUTE_DATE",
			A.DISPUTE_STATUS,
			A.MARKET_STATUS,
			A.SUBMIT_STATUS,
			A.OLD_BILL_AMOUNT "BILLED_AMOUNT",
			A.NEW_BILL_AMOUNT "CORRECTED_AMOUNT",
			A.OLD_BILL_AMOUNT-A.NEW_BILL_AMOUNT "DIFFERENCE",
			A.DISPUTE_DESC "DESCRIPTION",
			A.ENTRY_DATE,
			A.ENTITY_ID,
			A.PRODUCT_ID,
			A.COMPONENT_ID,
			A.STATEMENT_TYPE,
			A.STATEMENT_STATE
		FROM BILLING_CHARGE_DISPUTE A,
			POOL B,
			PRODUCT C,
			COMPONENT D
		WHERE (p_ENTITY_ID = g_ALL OR A.ENTITY_ID = p_ENTITY_ID)
			AND (p_PRODUCT_ID = g_ALL OR A.PRODUCT_ID = p_PRODUCT_ID)
			AND (p_COMPONENT_ID = g_ALL OR A.COMPONENT_ID = p_COMPONENT_ID)
			AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
			AND A.STATEMENT_STATE = g_INTERNAL_STATE
			AND A.DISPUTE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND (UPPER(p_STATUS_FILTER) = g_ALL_STRING OR UPPER(A.DISPUTE_STATUS) = UPPER(p_STATUS_FILTER))
			AND B.POOL_ID = A.ENTITY_ID
			AND C.PRODUCT_ID = A.PRODUCT_ID
			AND D.COMPONENT_ID = A.COMPONENT_ID
		ORDER BY 1,2,3,4;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END GET_POOL_DISPUTE_STATUS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_BP_DISPUTE_STATUS
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_STATUS_FILTER IN VARCHAR,
	p_STATEMENT_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
v_BEGIN_DATE DATE;
v_END_DATE DATE;
BEGIN

	p_STATUS := GA.SUCCESS;

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
	UT.CUT_DATE_RANGE(TRUNC(p_BEGIN_DATE), TRUNC(p_END_DATE), p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	OPEN p_CURSOR FOR
		SELECT B.BILL_PARTY_NAME "BILL_ENTITY",
			C.PRODUCT_NAME "PRODUCT",
			D.COMPONENT_NAME "COMPONENT",
            A.STATEMENT_DATE,
			-- we can't use GET_FORMAT_FROM_COMPONENT because that would
			-- mess up tax charges (tax charge interval isn't used)
			-- assume that 1-second offset indicates day...
			FROM_CUT_AS_HED(A.DISPUTE_DATE,p_TIME_ZONE,DECODE(TO_CHAR(A.DISPUTE_DATE,'SS'),'01','DD','MI5')) "DISPUTE_DATE",
			A.DISPUTE_STATUS,
			A.MARKET_STATUS,
			A.SUBMIT_STATUS,
			A.OLD_BILL_AMOUNT "BILLED_AMOUNT",
			A.NEW_BILL_AMOUNT "CORRECTED_AMOUNT",
			A.OLD_BILL_AMOUNT-A.NEW_BILL_AMOUNT "DIFFERENCE",
			A.DISPUTE_DESC "DESCRIPTION",
			A.ENTRY_DATE,
			A.ENTITY_ID,
			A.PRODUCT_ID,
			A.COMPONENT_ID,
			A.STATEMENT_TYPE,
			A.STATEMENT_STATE
		FROM BILLING_CHARGE_DISPUTE A,
			BILL_PARTY B,
			PRODUCT C,
			COMPONENT D
		WHERE (p_ENTITY_ID = g_ALL OR A.ENTITY_ID = p_ENTITY_ID)
			AND (p_PRODUCT_ID = g_ALL OR A.PRODUCT_ID = p_PRODUCT_ID)
			AND (p_COMPONENT_ID = g_ALL OR A.COMPONENT_ID = p_COMPONENT_ID)
			AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
			AND A.STATEMENT_STATE = g_INTERNAL_STATE
			AND A.DISPUTE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND (UPPER(p_STATUS_FILTER) = g_ALL_STRING OR UPPER(A.DISPUTE_STATUS) = UPPER(p_STATUS_FILTER))
			AND B.BILL_PARTY_ID = A.ENTITY_ID
			AND C.PRODUCT_ID = A.PRODUCT_ID
			AND D.COMPONENT_ID = A.COMPONENT_ID
		ORDER BY 1,2,3,4;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END GET_BP_DISPUTE_STATUS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_DISPUTE_STATUS
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_STATUS_FILTER IN VARCHAR,
	p_STATEMENT_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
BEGIN

	p_STATUS := GA.SUCCESS;
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_POSITION_AND_BILLING THEN
		GET_BP_DISPUTE_STATUS(p_CALLING_MODULE, p_MODEL_ID, p_ENTITY_ID, p_PRODUCT_ID, p_COMPONENT_ID, p_STATUS_FILTER, p_STATEMENT_TYPE, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_STATUS, p_CURSOR);
	ELSIF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING THEN
		GET_PSE_DISPUTE_STATUS(p_CALLING_MODULE, p_MODEL_ID, p_ENTITY_ID, p_PRODUCT_ID, p_COMPONENT_ID, p_STATUS_FILTER, p_STATEMENT_TYPE, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_STATUS, p_CURSOR);
	ELSIF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_GAS_DELIVERY THEN
		GET_POOL_DISPUTE_STATUS(p_CALLING_MODULE, p_MODEL_ID, p_ENTITY_ID, p_PRODUCT_ID, p_COMPONENT_ID, p_STATUS_FILTER, p_STATEMENT_TYPE, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_STATUS, p_CURSOR);
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END GET_DISPUTE_STATUS;
---------------------------------------------------------------------------------------------------
PROCEDURE PRODUCT_NAMES
	(
	p_STATEMENT_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
BEGIN

	p_STATUS := GA.SUCCESS;
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	OPEN p_CURSOR FOR
		SELECT DISTINCT B.PRODUCT_NAME, A.PRODUCT_ID
		FROM BILLING_STATEMENT A,
			PRODUCT B
		WHERE STATEMENT_TYPE = p_STATEMENT_TYPE
			AND STATEMENT_STATE = g_INTERNAL_STATE
			--AND STATEMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND A.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM BILLING_STATEMENT
				WHERE ENTITY_ID = A.ENTITY_ID
					AND PRODUCT_ID = A.PRODUCT_ID
					AND COMPONENT_ID = A.COMPONENT_ID
					AND STATEMENT_TYPE = A.STATEMENT_TYPE
					AND STATEMENT_STATE = A.STATEMENT_STATE
					AND STATEMENT_DATE = A.STATEMENT_DATE
					AND AS_OF_DATE <= p_AS_OF_DATE)
			AND B.PRODUCT_ID = A.PRODUCT_ID
		ORDER BY 1;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END PRODUCT_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE COMPONENT_NAMES
	(
	p_STATEMENT_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
BEGIN

	p_STATUS := GA.SUCCESS;
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	OPEN p_CURSOR FOR
		SELECT DISTINCT B.COMPONENT_NAME, A.COMPONENT_ID
		FROM BILLING_STATEMENT A,
			COMPONENT B
		WHERE STATEMENT_TYPE = p_STATEMENT_TYPE
			AND STATEMENT_STATE = g_INTERNAL_STATE
--			AND STATEMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND A.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM BILLING_STATEMENT
				WHERE ENTITY_ID = A.ENTITY_ID
					AND PRODUCT_ID = A.PRODUCT_ID
					AND COMPONENT_ID = A.COMPONENT_ID
					AND STATEMENT_TYPE = A.STATEMENT_TYPE
					AND STATEMENT_STATE = A.STATEMENT_STATE
					AND STATEMENT_DATE = A.STATEMENT_DATE
					AND AS_OF_DATE <= p_AS_OF_DATE)
			AND B.COMPONENT_ID = A.COMPONENT_ID
		ORDER BY 1;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END COMPONENT_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_INVOICE_COMPARISON
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_INVOICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
    p_INVOICE_CATEGORY IN VARCHAR,
    p_PERIOD_BEGIN OUT DATE,
    p_PERIOD_END OUT DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
v_INVOICE_BEGIN_DATE DATE;
v_INVOICE_END_DATE DATE;
v_INVOICE_CATEGORY VARCHAR2(32);
BEGIN
	p_STATUS := GA.SUCCESS;
	BEGIN
	    SELECT BEGIN_DATE, END_DATE INTO v_INVOICE_BEGIN_DATE, v_INVOICE_END_DATE
	    FROM INVOICE
	    WHERE ENTITY_ID = p_ENTITY_ID
        	AND BEGIN_DATE <= p_INVOICE_DATE
        	AND END_DATE >= p_INVOICE_DATE
            AND ROWNUM = 1;
	    p_PERIOD_BEGIN := v_INVOICE_BEGIN_DATE;
        p_PERIOD_END := v_INVOICE_END_DATE;
	EXCEPTION
    	WHEN NO_DATA_FOUND THEN
        	v_INVOICE_BEGIN_DATE := p_INVOICE_DATE;
            v_INVOICE_END_DATE := p_INVOICE_DATE;
		    p_PERIOD_BEGIN := NULL;
	        p_PERIOD_END := NULL;
	END;
    IF p_INVOICE_CATEGORY = '<ALL>' THEN
    	v_INVOICE_CATEGORY := '%';
	ELSE
    	v_INVOICE_CATEGORY := p_INVOICE_CATEGORY;
	END IF;

	OPEN p_CURSOR FOR
		SELECT * FROM
		(SELECT B.LINE_ITEM_NAME,
			A.STATEMENT_STATE,
			A.STATEMENT_TYPE,
			DECODE(UPPER(C.CHARGE_TYPE), 'TAX', 'Tax', 'Current') "LINE_ITEM_TYPE",
            DECODE(UPPER(NVL(B.DEFAULT_DISPLAY,'CHARGE')),'BILL',B.LINE_ITEM_BILL_AMOUNT,B.LINE_ITEM_AMOUNT) "LINE_ITEM_DEFAULT_AMOUNT",
			B.LINE_ITEM_AMOUNT,
			B.LINE_ITEM_BILL_AMOUNT
		FROM INVOICE A,
			INVOICE_LINE_ITEM B,
			COMPONENT C
		WHERE A.ENTITY_ID = p_ENTITY_ID
			AND A.STATEMENT_TYPE > 0
			AND A.STATEMENT_STATE IN (g_INTERNAL_STATE, g_EXTERNAL_STATE)
			AND A.BEGIN_DATE = v_INVOICE_BEGIN_DATE
			AND A.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE) FROM INVOICE
					WHERE ENTITY_ID = A.ENTITY_ID
						AND STATEMENT_TYPE = A.STATEMENT_TYPE
						AND STATEMENT_STATE = A.STATEMENT_STATE
						AND BEGIN_DATE = A.BEGIN_DATE
						AND AS_OF_DATE <= p_AS_OF_DATE)
			AND B.INVOICE_ID = A.INVOICE_ID
            AND NVL(B.LINE_ITEM_CATEGORY,' ') LIKE v_INVOICE_CATEGORY
			AND C.COMPONENT_ID(+) = B.COMPONENT_ID
		UNION ALL
        SELECT LINE_ITEM_NAME,
			STATEMENT_STATE,
			STATEMENT_TYPE,
			DECODE(LINE_ITEM_TYPE, 'P', 'Payment', 'F', 'Finance Charge', 'A', 'Adjustment', 'B', 'Balance', 'M', 'Miscellaneous', 'X', 'Manual Line Item Tax', '?') "LINE_ITEM_TYPE",
            DECODE(UPPER(NVL(DEFAULT_DISPLAY,'CHARGE')),'BILL',LINE_ITEM_BILL_AMOUNT,LINE_ITEM_AMOUNT) "LINE_ITEM_DEFAULT_AMOUNT",
			LINE_ITEM_AMOUNT,
			LINE_ITEM_BILL_AMOUNT
		FROM INVOICE_USER_LINE_ITEM
		WHERE ENTITY_ID = p_ENTITY_ID
			AND STATEMENT_TYPE > 0
			AND STATEMENT_STATE IN (g_INTERNAL_STATE, g_EXTERNAL_STATE)
			AND BEGIN_DATE = v_INVOICE_BEGIN_DATE
            AND NVL(LINE_ITEM_CATEGORY,' ') LIKE v_INVOICE_CATEGORY)
		ORDER BY 4, 1, 2, 3;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;
END GET_INVOICE_COMPARISON;
---------------------------------------------------------------------------------------------------
FUNCTION GET_INVOICE_OPTION
	(
    p_CALLING_MODULE IN VARCHAR2,
    p_ENTITY_ID IN NUMBER
    ) RETURN CHAR IS
BEGIN
	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING THEN
    	DECLARE
        	v_OPTION CHAR(1);
        BEGIN
        	SELECT DECODE(UPPER(INVOICE_LINE_ITEM_OPTION),'BY PRODUCT','1',
        				'BY PRODUCT-COMPONENT','2','BY ACCOUNT SERVICE','3',
                        'BY COMPONENT','4','EXTERNAL','X','2')
            INTO v_OPTION
            FROM PURCHASING_SELLING_ENTITY
            WHERE PSE_ID = p_ENTITY_ID;
            RETURN NVL(v_OPTION,'2'); -- 2 is the default option
		EXCEPTION
        	WHEN OTHERS THEN
	            RETURN '2'; -- 2 is the default option
        END;
    ELSE
    	RETURN GA.INVOICE_LINE_ITEM_OPTION;
    END IF;
END GET_INVOICE_OPTION;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_STATEMENT_SUM_FOR_PAIRS
	(
    p_ENTITY_ID IN NUMBER,
    p_PRODUCTS_COMPONENTS IN VARCHAR2,
    p_STATEMENT_TYPE IN NUMBER,
    p_STATEMENT_STATE IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_AS_OF_DATE IN DATE,
    p_CHARGE_AMOUNT OUT NUMBER,
    p_BILL_AMOUNT OUT NUMBER,
    p_IN_DISPUTE OUT NUMBER
    ) AS
v_NUMBER_TABLE GA.ID_TABLE;
v_STRING_TABLE GA.STRING_TABLE;
v_WORK_ID NUMBER;
v_INDEX BINARY_INTEGER;
BEGIN
	UT.TOKENS_FROM_STRING(p_PRODUCTS_COMPONENTS,';',v_STRING_TABLE);
	UT.GET_RTO_WORK_ID(v_WORK_ID);
    v_INDEX := v_STRING_TABLE.FIRST;
    WHILE v_STRING_TABLE.EXISTS(v_INDEX) LOOP
		UT.IDS_FROM_STRING(v_STRING_TABLE(v_INDEX),',',v_NUMBER_TABLE);
		INSERT INTO RTO_WORK (WORK_ID, WORK_XID, WORK_DATA)
		  	VALUES (v_WORK_ID, v_NUMBER_TABLE(1), v_NUMBER_TABLE(2));
    	v_INDEX := v_STRING_TABLE.NEXT(v_INDEX);
    END LOOP;

	SELECT MAX(A.IN_DISPUTE),
        SUM(A.BILL_AMOUNT),
        SUM(A.CHARGE_AMOUNT)
	INTO p_IN_DISPUTE,
    	p_BILL_AMOUNT,
        p_CHARGE_AMOUNT
	FROM BILLING_STATEMENT A,
		(SELECT WORK_XID "PRODUCT_ID", TO_NUMBER(WORK_DATA) "COMPONENT_ID"
        	FROM RTO_WORK
            WHERE WORK_ID = v_WORK_ID) B
    WHERE A.ENTITY_ID = p_ENTITY_ID
    	AND A.PRODUCT_ID > 0
        AND A.COMPONENT_ID > 0
        AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
        AND A.STATEMENT_STATE = p_STATEMENT_STATE
        AND A.STATEMENT_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
        AND A.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
         					FROM BILLING_STATEMENT
                             WHERE ENTITY_ID = A.ENTITY_ID
                             	AND PRODUCT_ID = A.PRODUCT_ID
                                 AND COMPONENT_ID = A.COMPONENT_ID
                                 AND STATEMENT_TYPE = A.STATEMENT_TYPE
                                 AND STATEMENT_STATE = A.STATEMENT_STATE
                                 AND STATEMENT_DATE = A.STATEMENT_DATE
                                 AND AS_OF_DATE <= p_AS_OF_DATE)
		AND (A.PRODUCT_ID = B.PRODUCT_ID OR B.PRODUCT_ID = g_ALL)
    	AND (A.COMPONENT_ID = B.COMPONENT_ID OR B.COMPONENT_ID = g_ALL);

	UT.PURGE_RTO_WORK(v_WORK_ID);
EXCEPTION
	WHEN OTHERS THEN
    	UT.PURGE_RTO_WORK(v_WORK_ID);
        RAISE;
END GET_STATEMENT_SUM_FOR_PAIRS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_STATEMENTS_FOR_LINE_ITEM(
	p_CALLING_MODULE IN VARCHAR2,
    p_ENTITY_ID IN NUMBER,
    p_INVOICE_LINE_ITEM IN INVOICE_LINE_ITEM%ROWTYPE,
    p_RECORD IN OUT NOCOPY INVOICE_VALID_RECORD_TYPE,
    p_AS_OF_DATE IN DATE
    ) AS
v_LINE_ITEM_OPTION VARCHAR2(32) := UPPER(p_INVOICE_LINE_ITEM.LINE_ITEM_OPTION);
v_ENTITY_TYPE VARCHAR2(16);
BEGIN
	-- make sure we know the invoice roll-up option
    IF v_LINE_ITEM_OPTION IS NULL THEN
        SELECT DECODE(GA.INVOICE_LINE_ITEM_OPTION,'1','BY PRODUCT','2','BY PRODUCT-COMPONENT',
        			'3','BY ACCOUNT SERVICE','4','BY COMPONENT',
                    'X','EXTERNAL','BY PRODUCT-COMPONENT')
		INTO v_LINE_ITEM_OPTION
        FROM DUAL;
    END IF;

    IF v_LINE_ITEM_OPTION = 'BY PRODUCT' THEN
    	p_RECORD.PRODUCT_COMPONENT_PAIRS := p_INVOICE_LINE_ITEM.PRODUCT_ID||',-1';
    ELSIF v_LINE_ITEM_OPTION = 'BY PRODUCT-COMPONENT' THEN
    	p_RECORD.PRODUCT_COMPONENT_PAIRS := p_INVOICE_LINE_ITEM.PRODUCT_ID||','||p_INVOICE_LINE_ITEM.COMPONENT_ID;
    ELSIF v_LINE_ITEM_OPTION = 'BY ACCOUNT SERVICE' THEN
    	-- do nothing - this invoice option isn't supported for
        -- invoice validation
    	p_RECORD.PRODUCT_COMPONENT_PAIRS := NULL;
    ELSIF v_LINE_ITEM_OPTION = 'BY COMPONENT' THEN
    	p_RECORD.PRODUCT_COMPONENT_PAIRS := '-1,'||p_INVOICE_LINE_ITEM.COMPONENT_ID;
    ELSE -- unknown options indicate external roll-up option
    	-- determine entity type
        SELECT DECODE(UPPER(SUBSTR(p_CALLING_MODULE,1,1)),g_SCHEDULING,g_PSE,
        												  g_GAS_DELIVERY,g_POOL,
                                                          g_POSITION_AND_BILLING,g_BILL_PARTY)
		INTO v_ENTITY_TYPE FROM DUAL;
    	XS.UNROLL_INVOICE_LINE_ITEM(p_ENTITY_ID,v_ENTITY_TYPE,p_AS_OF_DATE,p_INVOICE_LINE_ITEM,p_RECORD.PRODUCT_COMPONENT_PAIRS);
    END IF;

    IF NOT p_RECORD.PRODUCT_COMPONENT_PAIRS IS NULL THEN
    	-- get sum and dispute status for products/components
        GET_STATEMENT_SUM_FOR_PAIRS (p_RECORD.ENTITY_ID,p_RECORD.PRODUCT_COMPONENT_PAIRS,
			        	p_RECORD.STATEMENT_TYPE,p_RECORD.STATEMENT_STATE,
                        p_RECORD.BEGIN_DATE,p_RECORD.END_DATE,p_AS_OF_DATE,
			        	p_RECORD.STATEMENT_CHARGE_AMOUNT,p_RECORD.STATEMENT_BILL_AMOUNT,p_RECORD.IN_DISPUTE);
        IF p_RECORD.DEFAULT_DISPLAY = 'BILL' THEN
         	p_RECORD.STATEMENT_DEFAULT_AMOUNT := p_RECORD.STATEMENT_BILL_AMOUNT;
		ELSE
        	p_RECORD.STATEMENT_DEFAULT_AMOUNT := p_RECORD.STATEMENT_CHARGE_AMOUNT;
        END IF;
        p_RECORD.DEFAULT_DIFFERENCE := NVL(p_RECORD.LINE_ITEM_DEFAULT_AMOUNT,0)-NVL(p_RECORD.STATEMENT_DEFAULT_AMOUNT,0);
        p_RECORD.CHARGE_DIFFERENCE := NVL(p_RECORD.LINE_ITEM_AMOUNT,0)-NVL(p_RECORD.STATEMENT_CHARGE_AMOUNT,0);
        p_RECORD.BILL_DIFFERENCE := NVL(p_RECORD.LINE_ITEM_BILL_AMOUNT,0)-NVL(p_RECORD.STATEMENT_BILL_AMOUNT,0);
    END IF;
END GET_STATEMENTS_FOR_LINE_ITEM;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_INVOICE_VALIDATION
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_INVOICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
    p_INVOICE_CATEGORY IN VARCHAR,
    p_STATEMENT_TYPE IN NUMBER,
    p_STATEMENT_STATE IN NUMBER,
    p_PERIOD_BEGIN OUT DATE,
    p_PERIOD_END OUT DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
v_INVOICE_BEGIN_DATE DATE;
v_INVOICE_END_DATE DATE;
v_INVOICE_CATEGORY VARCHAR2(32);
v_RECORDS INVOICE_VALID_RECORD_TABLE;
v_INDEX BINARY_INTEGER;
v_INVOICE_OPTION CHAR(1);
v_INVOICE_LINE_ITEM INVOICE_LINE_ITEM%ROWTYPE;
BEGIN
	p_STATUS := GA.SUCCESS;
	BEGIN
	    SELECT BEGIN_DATE, END_DATE INTO v_INVOICE_BEGIN_DATE, v_INVOICE_END_DATE
	    FROM INVOICE
	    WHERE ENTITY_ID = p_ENTITY_ID
        	AND BEGIN_DATE <= p_INVOICE_DATE
        	AND END_DATE >= p_INVOICE_DATE
            AND ROWNUM = 1;
	    p_PERIOD_BEGIN := v_INVOICE_BEGIN_DATE;
        p_PERIOD_END := v_INVOICE_END_DATE;
	EXCEPTION
    	WHEN NO_DATA_FOUND THEN
        	v_INVOICE_BEGIN_DATE := p_INVOICE_DATE;
            v_INVOICE_END_DATE := p_INVOICE_DATE;
		    p_PERIOD_BEGIN := NULL;
	        p_PERIOD_END := NULL;
	END;
    IF p_INVOICE_CATEGORY = '<ALL>' THEN
    	v_INVOICE_CATEGORY := '%';
	ELSE
    	v_INVOICE_CATEGORY := p_INVOICE_CATEGORY;
	END IF;

    -- fetch invoice data
	SELECT INVOICE_VALID_RECORD_TYPE(
    	INVOICE_ID, LINE_ITEM_NAME, LINE_ITEM_TYPE, IS_MANUAL,
        LINE_ITEM_DEFAULT_AMOUNT, LINE_ITEM_AMOUNT, LINE_ITEM_BILL_AMOUNT,
        DEFAULT_DISPLAY, STATEMENT_TYPE, STATEMENT_STATE,
        BEGIN_DATE, END_DATE, ENTITY_ID, ENTITY_INTERVAL,
        NULL, NULL, NULL, 0, NULL, NULL, NULL, NULL
	    )
    BULK COLLECT INTO v_RECORDS
    FROM
	(SELECT A.INVOICE_ID,
    	B.LINE_ITEM_NAME,
		DECODE(UPPER(C.CHARGE_TYPE), 'TAX', 'Tax', 'Current') "LINE_ITEM_TYPE",
        DECODE(UPPER(NVL(B.DEFAULT_DISPLAY,'CHARGE')),'BILL',B.LINE_ITEM_BILL_AMOUNT,B.LINE_ITEM_AMOUNT) "LINE_ITEM_DEFAULT_AMOUNT",
		B.LINE_ITEM_AMOUNT,
		B.LINE_ITEM_BILL_AMOUNT,
        B.DEFAULT_DISPLAY,
		B.STATEMENT_TYPE,
		A.STATEMENT_STATE,
        B.BEGIN_DATE,
        B.END_DATE,
        A.ENTITY_ID,
        D.STATEMENT_INTERVAL "ENTITY_INTERVAL",
        0 "IS_MANUAL"
	FROM INVOICE A,
		INVOICE_LINE_ITEM B,
		COMPONENT C,
        PURCHASING_SELLING_ENTITY D
	WHERE A.ENTITY_ID = p_ENTITY_ID
		AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
		AND A.STATEMENT_STATE = p_STATEMENT_STATE
		AND A.BEGIN_DATE = v_INVOICE_BEGIN_DATE
		AND A.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE) FROM INVOICE
				WHERE ENTITY_ID = A.ENTITY_ID
					AND STATEMENT_TYPE = A.STATEMENT_TYPE
					AND STATEMENT_STATE = A.STATEMENT_STATE
					AND BEGIN_DATE = A.BEGIN_DATE
					AND AS_OF_DATE <= p_AS_OF_DATE)
		AND B.INVOICE_ID = A.INVOICE_ID
        AND NVL(B.LINE_ITEM_CATEGORY,' ') LIKE v_INVOICE_CATEGORY
		AND C.COMPONENT_ID(+) = B.COMPONENT_ID
        AND D.PSE_ID = A.ENTITY_ID
	UNION ALL
    SELECT 0 "INVOICE_ID",
    	LINE_ITEM_NAME,
		DECODE(LINE_ITEM_TYPE, 'P', 'Payment', 'F', 'Finance Charge', 'A', 'Adjustment', 'B', 'Balance', 'M', 'Miscellaneous', 'X', 'Manual Line Item Tax', '?') "LINE_ITEM_TYPE",
        DECODE(UPPER(NVL(DEFAULT_DISPLAY,'CHARGE')),'BILL',LINE_ITEM_BILL_AMOUNT,LINE_ITEM_AMOUNT) "LINE_ITEM_DEFAULT_AMOUNT",
		LINE_ITEM_AMOUNT,
		LINE_ITEM_BILL_AMOUNT,
        DEFAULT_DISPLAY,
        STATEMENT_TYPE,
        STATEMENT_STATE,
        BEGIN_DATE,
        NULL "END_DATE",
        ENTITY_ID,
        NULL "ENTITY_INTERVAL",
        1 "IS_MANUAL"
	FROM INVOICE_USER_LINE_ITEM
	WHERE ENTITY_ID = p_ENTITY_ID
		AND STATEMENT_TYPE = p_STATEMENT_TYPE
		AND STATEMENT_STATE = p_STATEMENT_STATE
		AND BEGIN_DATE = v_INVOICE_BEGIN_DATE
        AND NVL(LINE_ITEM_CATEGORY,' ') LIKE v_INVOICE_CATEGORY);

    -- then loop through and populate statement data
    v_INDEX := v_RECORDS.FIRST;
    WHILE v_RECORDS.EXISTS(v_INDEX) LOOP
    	IF v_RECORDS(v_INDEX).IS_MANUAL = 0 THEN
        	-- query the billing statement numbers for this row
            v_INVOICE_OPTION := GET_INVOICE_OPTION(p_CALLING_MODULE,p_ENTITY_ID);
            SELECT * INTO v_INVOICE_LINE_ITEM
            	FROM INVOICE_LINE_ITEM
                WHERE INVOICE_ID = v_RECORDS(v_INDEX).INVOICE_ID
               	AND LINE_ITEM_NAME = v_RECORDS(v_INDEX).LINE_ITEM_NAME;
			GET_STATEMENTS_FOR_LINE_ITEM(p_CALLING_MODULE, p_ENTITY_ID, v_INVOICE_LINE_ITEM, v_RECORDS(v_INDEX), p_AS_OF_DATE);
        END IF;
    	v_INDEX := v_RECORDS.NEXT(v_INDEX);
    END LOOP;

    -- finally, return it all
    OPEN p_CURSOR FOR
    	SELECT LINE_ITEM_NAME, LINE_ITEM_TYPE,
	        LINE_ITEM_DEFAULT_AMOUNT, LINE_ITEM_AMOUNT, LINE_ITEM_BILL_AMOUNT,
	        DEFAULT_DISPLAY, STATEMENT_TYPE, STATEMENT_TYPE_NAME,
            STATEMENT_STATE, BEGIN_DATE, END_DATE, ENTITY_ID, ENTITY_INTERVAL,
	        STATEMENT_DEFAULT_AMOUNT, STATEMENT_CHARGE_AMOUNT, STATEMENT_BILL_AMOUNT,
	        IN_DISPUTE, PRODUCT_COMPONENT_PAIRS,
	        DEFAULT_DIFFERENCE, CHARGE_DIFFERENCE, BILL_DIFFERENCE
    	FROM TABLE(CAST(v_RECORDS AS INVOICE_VALID_RECORD_TABLE)) A,
        	STATEMENT_TYPE B
		WHERE STATEMENT_TYPE_ID = STATEMENT_TYPE
        ORDER BY 2,1;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;
END GET_INVOICE_VALIDATION;
---------------------------------------------------------------------------------------------------
FUNCTION GET_FORMAT_FROM_INTERVAL
	(
	p_INTERVAL IN VARCHAR
	) RETURN VARCHAR IS
v_TRUNC VARCHAR(8);
BEGIN
--	SELECT DECODE(UPPER(SUBSTR(p_INTERVAL,1,2)),'5 ','MI5','10','MI10','15','MI15','20','MI20','30','MI30','HO','HH','DA','DD','WE','DY','MO','MM','QU','Q','YE','YY')
--	INTO v_TRUNC FROM DUAL;
	SELECT DECODE(UPPER(SUBSTR(p_INTERVAL,1,2)),'5 ','MI5','10','MI5','15','MI5','20','MI5','30','MI5','HO','HH','DA','DD','WE','DD','MO','DD','QU','DD','YE','DD')
	INTO v_TRUNC FROM DUAL;

	RETURN v_TRUNC;
END GET_FORMAT_FROM_INTERVAL;
---------------------------------------------------------------------------------------------------
FUNCTION GET_FORMAT_FROM_COMPONENT
	(
	p_COMPONENT_ID IN NUMBER
	) RETURN VARCHAR IS
v_INTERVAL VARCHAR(32);
BEGIN
	SELECT RATE_INTERVAL INTO v_INTERVAL
	FROM COMPONENT
	WHERE COMPONENT_ID = p_COMPONENT_ID;

	RETURN GET_FORMAT_FROM_INTERVAL(v_INTERVAL);
END GET_FORMAT_FROM_COMPONENT;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_EXPORT_ENTITIES
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
    p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_AS_OF_DATE IN DATE,
    p_STATUS OUT NUMBER,
    p_MESSAGE OUT VARCHAR,
	p_CURSOR IN OUT GA.REFCURSOR
    ) AS
BEGIN
	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_POSITION_AND_BILLING THEN
    	OPEN p_CURSOR FOR
    		SELECT DISTINCT ENTITY_ID, BILL_PARTY_NAME
            FROM BILLING_STATEMENT A, BILL_PARTY B
            WHERE STATEMENT_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
    	        AND STATEMENT_TYPE = p_STATEMENT_TYPE
                AND STATEMENT_STATE = p_STATEMENT_STATE
                AND AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
                					FROM BILLING_STATEMENT
                                    WHERE ENTITY_ID = A.ENTITY_ID
                                    	AND PRODUCT_ID = A.PRODUCT_ID
                                        AND COMPONENT_ID = A.COMPONENT_ID
                                        AND STATEMENT_DATE = A.STATEMENT_DATE
                                        AND STATEMENT_TYPE = A.STATEMENT_TYPE
                                        AND STATEMENT_STATE = A.STATEMENT_STATE
                                        AND AS_OF_DATE <= p_AS_OF_DATE)
				AND BILL_PARTY_ID = ENTITY_ID
			ORDER BY BILL_PARTY_NAME;
	ELSIF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING THEN
    	OPEN p_CURSOR FOR
    		SELECT DISTINCT ENTITY_ID, PSE_NAME
            FROM BILLING_STATEMENT A, PURCHASING_SELLING_ENTITY B
            WHERE STATEMENT_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
    	        AND STATEMENT_TYPE = p_STATEMENT_TYPE
                AND STATEMENT_STATE = p_STATEMENT_STATE
                AND AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
                					FROM BILLING_STATEMENT
                                    WHERE ENTITY_ID = A.ENTITY_ID
                                    	AND PRODUCT_ID = A.PRODUCT_ID
                                        AND COMPONENT_ID = A.COMPONENT_ID
                                        AND STATEMENT_DATE = A.STATEMENT_DATE
                                        AND STATEMENT_TYPE = A.STATEMENT_TYPE
                                        AND STATEMENT_STATE = A.STATEMENT_STATE
                                        AND AS_OF_DATE <= p_AS_OF_DATE)
				AND PSE_ID = ENTITY_ID
			ORDER BY PSE_NAME;
	ELSIF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_GAS_DELIVERY THEN
    	OPEN p_CURSOR FOR
    		SELECT DISTINCT ENTITY_ID, POOL_NAME
            FROM BILLING_STATEMENT A, POOL B
            WHERE STATEMENT_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
    	        AND STATEMENT_TYPE = p_STATEMENT_TYPE
                AND STATEMENT_STATE = p_STATEMENT_STATE
                AND AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
                					FROM BILLING_STATEMENT
                                    WHERE ENTITY_ID = A.ENTITY_ID
                                    	AND PRODUCT_ID = A.PRODUCT_ID
                                        AND COMPONENT_ID = A.COMPONENT_ID
                                        AND STATEMENT_DATE = A.STATEMENT_DATE
                                        AND STATEMENT_TYPE = A.STATEMENT_TYPE
                                        AND STATEMENT_STATE = A.STATEMENT_STATE
                                        AND AS_OF_DATE <= p_AS_OF_DATE)
				AND POOL_ID = ENTITY_ID
			ORDER BY POOL_NAME;
	END IF;
EXCEPTION
	WHEN OTHERS THEN
    	p_STATUS := SQLCODE;
        p_MESSAGE := SQLERRM;
END GET_EXPORT_ENTITIES;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_EXPORT_INVOICE_SUMMARY
	(
    p_MODEL_ID IN NUMBER,
    p_INVOICE_ID IN NUMBER,
    p_WORK_ID IN NUMBER
    ) AS
v_SEQ NUMBER := 0;
v_DATE_FMT VARCHAR2(32) := NVL(MODEL_VALUE_AT_KEY(p_MODEL_ID,'BILLING','INVOICE','DATE FORMAT',0),'YYYY/MM/DD');
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_INVOICE_DATE DATE;
v_INVOICE_NUMBER VARCHAR2(16);
v_INVOICE_SUB_LEDGER_NUMBER VARCHAR2(16);
v_INVOICE_STATUS VARCHAR2(32);
v_LAST_INVOICE_GROUP VARCHAR2(32) := ' ';
v_LAST_EMIT_SUBTOTAL NUMBER := 0;
v_SUB_TOTAL NUMBER := 0;
v_GRAND_TOTAL NUMBER := 0;
v_LINE_ITEM_PREFIX VARCHAR2(2);
CURSOR c_LINE_ITEMS IS
	SELECT B.LINE_ITEM_NAME,
 		DECODE(UPPER(C.CHARGE_TYPE), 'TAX', 'T', 'C') AS LINE_ITEM_TYPE,
 		DECODE(UPPER(C.CHARGE_TYPE), 'TAX', 6, 5) AS LINE_ITEM_GROUP_ORDER,
        D.INVOICE_GROUP_NAME,
        NVL(C.INVOICE_GROUP_ORDER,0) AS INVOICE_GROUP_ORDER,
 		B.LINE_ITEM_QUANTITY,
        B.LINE_ITEM_RATE,
        B.LINE_ITEM_AMOUNT,
 		NVL(C.EXCLUDE_FROM_INVOICE_TOTAL,0) AS EXCLUDE_FROM_INVOICE_TOTAL,
 		NVL(D.SHOW_TITLE_ON_INVOICE,0) AS SHOW_TITLE_ON_INVOICE,
 		NVL(D.SHOW_SUBTOTAL_ON_INVOICE,0) AS SHOW_SUBTOTAL_ON_INVOICE,
        NVL(D.DISPLAY_ORDER,0) AS INVOICE_GROUP_DISPLAY_ORDER
	FROM INVOICE A,
		INVOICE_LINE_ITEM B,
 		COMPONENT C,
 		INVOICE_GROUP D
	WHERE A.INVOICE_ID = p_INVOICE_ID
		AND B.INVOICE_ID = A.INVOICE_ID
		AND B.COMPONENT_ID = C.COMPONENT_ID
		AND D.INVOICE_GROUP_ID(+) = C.INVOICE_GROUP_ID
	UNION ALL
	SELECT B.LINE_ITEM_NAME,
		B.LINE_ITEM_TYPE,
		DECODE(B.LINE_ITEM_TYPE, 'B', 1, 'P', 2, 'A', 3, 'F', 4, 'M', 7, 'X', 8, 99)  AS LINE_ITEM_GROUP_ORDER,
        C.INVOICE_GROUP_NAME,
        NVL(B.INVOICE_GROUP_ORDER,0) AS INVOICE_GROUP_ORDER,
		B.LINE_ITEM_QUANTITY,
        B.LINE_ITEM_RATE,
        B.LINE_ITEM_AMOUNT,
		NVL(B.EXCLUDE_FROM_INVOICE_TOTAL,0) AS EXCLUDE_FROM_INVOICE_TOTAL,
 		NVL(C.SHOW_TITLE_ON_INVOICE,0) AS SHOW_TITLE_ON_INVOICE,
 		NVL(C.SHOW_SUBTOTAL_ON_INVOICE,0) AS SHOW_SUBTOTAL_ON_INVOICE,
        NVL(C.DISPLAY_ORDER,0) AS INVOICE_GROUP_DISPLAY_ORDER
	FROM INVOICE A,
		INVOICE_USER_LINE_ITEM B,
	    INVOICE_GROUP C
	WHERE A.INVOICE_ID = p_INVOICE_ID
		AND B.ENTITY_ID = A.ENTITY_ID
		AND B.STATEMENT_TYPE = A.STATEMENT_TYPE
 		AND B.STATEMENT_STATE = A.STATEMENT_STATE
 		AND B.BEGIN_DATE = A.BEGIN_DATE
		AND C.INVOICE_GROUP_ID(+) = B.INVOICE_GROUP_ID
	ORDER BY INVOICE_GROUP_DISPLAY_ORDER ASC,
 		INVOICE_GROUP_NAME ASC,
 		INVOICE_GROUP_ORDER ASC,
      	LINE_ITEM_GROUP_ORDER ASC,
 		LINE_ITEM_NAME ASC;
BEGIN
	SELECT BEGIN_DATE, END_DATE, INVOICE_DATE, INVOICE_NUMBER, INVOICE_SUB_LEDGER_NUMBER, INVOICE_STATUS
    INTO v_BEGIN_DATE, v_END_DATE, v_INVOICE_DATE, v_INVOICE_NUMBER, v_INVOICE_SUB_LEDGER_NUMBER, v_INVOICE_STATUS
    FROM INVOICE
    WHERE INVOICE_ID = p_INVOICE_ID;
    -- start building invoice into RTO_WORK - header info first
	INSERT INTO RTO_WORK (WORK_ID, WORK_SEQ, WORK_DATA)
    	VALUES (p_WORK_ID, v_SEQ, 'Invoice Date: '||TO_CHAR(v_INVOICE_DATE,v_DATE_FMT));
    v_SEQ := v_SEQ+1;
    IF NOT v_INVOICE_SUB_LEDGER_NUMBER IS NULL THEN
    	v_INVOICE_NUMBER := v_INVOICE_NUMBER||'-'||v_INVOICE_SUB_LEDGER_NUMBER;
    END IF;
	INSERT INTO RTO_WORK (WORK_ID, WORK_SEQ, WORK_DATA)
    	VALUES (p_WORK_ID, v_SEQ, 'Invoice Number: '||v_INVOICE_NUMBER);
    v_SEQ := v_SEQ+1;
	INSERT INTO RTO_WORK (WORK_ID, WORK_SEQ, WORK_DATA)
    	VALUES (p_WORK_ID, v_SEQ, 'Invoice Status: '||v_INVOICE_STATUS);
    v_SEQ := v_SEQ+1;
	INSERT INTO RTO_WORK (WORK_ID, WORK_SEQ, WORK_DATA)
    	VALUES (p_WORK_ID, v_SEQ, 'Invoice Period: '||TO_CHAR(v_BEGIN_DATE,v_DATE_FMT)||' - '||TO_CHAR(v_END_DATE,v_DATE_FMT));
    v_SEQ := v_SEQ+1;
	INSERT INTO RTO_WORK (WORK_ID, WORK_SEQ, WORK_DATA)
    	VALUES (p_WORK_ID, v_SEQ, '');
    v_SEQ := v_SEQ+1;
	INSERT INTO RTO_WORK (WORK_ID, WORK_SEQ, WORK_DATA)
    	VALUES (p_WORK_ID, v_SEQ, '||Quantity|Rate|Amount');
    v_SEQ := v_SEQ+1;
    -- then export all the line items
    FOR v_LINE_ITEM IN c_LINE_ITEMS LOOP
    	-- pad with space so we don't have to worry about NULLs throwing off boolean test
    	IF v_LINE_ITEM.INVOICE_GROUP_NAME||' ' <> v_LAST_INVOICE_GROUP THEN
        	-- reset for new group
            IF v_LAST_EMIT_SUBTOTAL = 1 THEN
            	INSERT INTO RTO_WORK (WORK_ID, WORK_SEQ, WORK_DATA)
                	VALUES (p_WORK_ID, v_SEQ, 'Sub-Total||||'||TRIM(TO_CHAR(v_SUB_TOTAL,'9999999999999.99')));
                v_SEQ := v_SEQ+1;
            END IF;
        	v_SUB_TOTAL := 0;
        	INSERT INTO RTO_WORK (WORK_ID, WORK_SEQ, WORK_DATA)
            	VALUES (p_WORK_ID, v_SEQ, '');
            v_SEQ := v_SEQ+1;
            IF v_LINE_ITEM.SHOW_TITLE_ON_INVOICE = 1 THEN
            	INSERT INTO RTO_WORK (WORK_ID, WORK_SEQ, WORK_DATA)
                	VALUES (p_WORK_ID, v_SEQ, v_LINE_ITEM.INVOICE_GROUP_NAME);
                v_SEQ := v_SEQ+1;
            END IF;
            v_LAST_INVOICE_GROUP := v_LINE_ITEM.INVOICE_GROUP_NAME||' ';
            v_LAST_EMIT_SUBTOTAL := v_LINE_ITEM.SHOW_SUBTOTAL_ON_INVOICE;
        END IF;
        -- write the line items
        IF v_LINE_ITEM.EXCLUDE_FROM_INVOICE_TOTAL = 1 THEN
        	v_LINE_ITEM_PREFIX := '*';
        ELSE
        	v_LINE_ITEM_PREFIX := ' ';
            v_SUB_TOTAL := v_SUB_TOTAL + v_LINE_ITEM.LINE_ITEM_AMOUNT;
            v_GRAND_TOTAL := v_GRAND_TOTAL + v_LINE_ITEM.LINE_ITEM_AMOUNT;
        END IF;
    	INSERT INTO RTO_WORK (WORK_ID, WORK_SEQ, WORK_DATA)
        	VALUES (p_WORK_ID, v_SEQ, v_LINE_ITEM_PREFIX||'|'||v_LINE_ITEM.LINE_ITEM_NAME||
            					'|'||TRIM(TO_CHAR(v_LINE_ITEM.LINE_ITEM_QUANTITY,'9999999999999.99'))||
                                '|'||TRIM(TO_CHAR(v_LINE_ITEM.LINE_ITEM_RATE,'9999999999999.999999'))||
                                '|'||TRIM(TO_CHAR(v_LINE_ITEM.LINE_ITEM_AMOUNT,'9999999999999.99')));
        v_SEQ := v_SEQ+1;
    END LOOP;
    -- make sure to catch last subtotal if necessary
    IF v_LAST_EMIT_SUBTOTAL = 1 THEN
    	INSERT INTO RTO_WORK (WORK_ID, WORK_SEQ, WORK_DATA)
        	VALUES (p_WORK_ID, v_SEQ, 'Sub-Total||||'||TRIM(TO_CHAR(v_SUB_TOTAL,'9999999999999.99')));
        v_SEQ := v_SEQ+1;
    END IF;
	INSERT INTO RTO_WORK (WORK_ID, WORK_SEQ, WORK_DATA)
    	VALUES (p_WORK_ID, v_SEQ, '');
    v_SEQ := v_SEQ+1;
    -- now emit the grand total
	INSERT INTO RTO_WORK (WORK_ID, WORK_SEQ, WORK_DATA)
    	VALUES (p_WORK_ID, v_SEQ, 'Grand Total||||'||TRIM(TO_CHAR(v_GRAND_TOTAL,'9999999999999.99')));
    v_SEQ := v_SEQ+1;
END GET_EXPORT_INVOICE_SUMMARY;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_EXPORT_SUMMARY
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
    p_STATEMENT_TYPE IN NUMBER,
    p_STATEMENT_STATE IN NUMBER,
    p_BEGIN_DATE IN OUT DATE,
    p_END_DATE IN OUT DATE,
    p_AS_OF_DATE IN DATE,
    p_ID_PAIRS OUT VARCHAR,
    p_ENTITY_NAME OUT VARCHAR,
    p_STATUS OUT NUMBER,
    p_MESSAGE OUT VARCHAR,
	p_CURSOR IN OUT GA.REFCURSOR
    ) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_ID_PAIRS VARCHAR2(4000) := '';
v_WORK_ID NUMBER;
v_SEQ NUMBER := 0;
v_GRAND_TOTAL NUMBER := 0;
v_MANUAL_COUNT NUMBER;
v_MANUAL_TOTAL NUMBER;
v_DO_MANUAL NUMBER := 0;
v_EXPORT_INVOICE NUMBER;
v_INVOICE_ID NUMBER;

CURSOR c_PRODUCTS IS
	SELECT A.PRODUCT_ID, PRODUCT_NAME, SUM(CHARGE_AMOUNT) "CHARGE_AMOUNT"
	FROM BILLING_STATEMENT A,
    	PRODUCT B
    WHERE ENTITY_ID = p_ENTITY_ID
    	AND STATEMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
    	AND STATEMENT_TYPE = p_STATEMENT_TYPE
        AND STATEMENT_STATE = p_STATEMENT_STATE
		AND AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			 	FROM BILLING_STATEMENT
				WHERE ENTITY_ID = A.ENTITY_ID
					AND PRODUCT_ID = A.PRODUCT_ID
					AND COMPONENT_ID = A.COMPONENT_ID
					AND STATEMENT_TYPE = A.STATEMENT_TYPE
					AND STATEMENT_STATE = A.STATEMENT_STATE
					AND STATEMENT_DATE = A.STATEMENT_DATE
					AND AS_OF_DATE <= p_AS_OF_DATE)
		AND B.PRODUCT_ID = A.PRODUCT_ID
    GROUP BY A.PRODUCT_ID, PRODUCT_NAME
	ORDER BY PRODUCT_NAME;

CURSOR c_COMPONENTS(p_PRODUCT_ID IN NUMBER) IS
	SELECT A.COMPONENT_ID, COMPONENT_NAME, SUM(CHARGE_AMOUNT) "CHARGE_AMOUNT"
	FROM BILLING_STATEMENT A,
    	COMPONENT B
    WHERE ENTITY_ID = p_ENTITY_ID
    	AND PRODUCT_ID = p_PRODUCT_ID
    	AND STATEMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
    	AND STATEMENT_TYPE = p_STATEMENT_TYPE
        AND STATEMENT_STATE = p_STATEMENT_STATE
		AND AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			 	FROM BILLING_STATEMENT
				WHERE ENTITY_ID = A.ENTITY_ID
					AND PRODUCT_ID = A.PRODUCT_ID
					AND COMPONENT_ID = A.COMPONENT_ID
					AND STATEMENT_TYPE = A.STATEMENT_TYPE
					AND STATEMENT_STATE = A.STATEMENT_STATE
					AND STATEMENT_DATE = A.STATEMENT_DATE
					AND AS_OF_DATE <= p_AS_OF_DATE)
		AND B.COMPONENT_ID = A.COMPONENT_ID
        -- exclude transmission charges
        AND NOT (UPPER(CHARGE_VIEW_TYPE) = 'TRANSMISSION' OR
        		 (UPPER(CHARGE_VIEW_TYPE) = 'EXTERNAL' AND XS.COMPONENT_IS_TX_CHARGE(p_CALLING_MODULE,p_MODEL_ID,A.COMPONENT_ID)=1))
    GROUP BY A.COMPONENT_ID, COMPONENT_NAME
	ORDER BY COMPONENT_NAME;

CURSOR c_TX_CHARGES(p_PRODUCT_ID IN NUMBER) IS
	SELECT 0 "COMPONENT_ID",
    	DECODE(UPPER(SUBSTR(A.CHARGE_VIEW_TYPE,1,3)),'EXT',XS.GET_TX_SERVICE_TYPE(p_CALLING_MODULE,p_MODEL_ID,A.COMPONENT_ID),
				        		DECODE(UPPER(B.RATE_STRUCTURE),'INTERNAL','None',B.COMPONENT_REFERENCE)) "COMPONENT_NAME",
        SUM(CHARGE_AMOUNT) "CHARGE_AMOUNT"
	FROM BILLING_STATEMENT A,
    	COMPONENT B
    WHERE ENTITY_ID = p_ENTITY_ID
    	AND PRODUCT_ID = p_PRODUCT_ID
    	AND STATEMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
    	AND STATEMENT_TYPE = p_STATEMENT_TYPE
        AND STATEMENT_STATE = p_STATEMENT_STATE
		AND AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			 	FROM BILLING_STATEMENT
				WHERE ENTITY_ID = A.ENTITY_ID
					AND PRODUCT_ID = A.PRODUCT_ID
					AND COMPONENT_ID = A.COMPONENT_ID
					AND STATEMENT_TYPE = A.STATEMENT_TYPE
					AND STATEMENT_STATE = A.STATEMENT_STATE
					AND STATEMENT_DATE = A.STATEMENT_DATE
					AND AS_OF_DATE <= p_AS_OF_DATE)
		AND B.COMPONENT_ID = A.COMPONENT_ID
        -- include transmission charges only
        AND (UPPER(CHARGE_VIEW_TYPE) = 'TRANSMISSION' OR
        		 (UPPER(CHARGE_VIEW_TYPE) = 'EXTERNAL' AND XS.COMPONENT_IS_TX_CHARGE(p_CALLING_MODULE,p_MODEL_ID,A.COMPONENT_ID)=1))
    GROUP BY 0, DECODE(UPPER(SUBSTR(A.CHARGE_VIEW_TYPE,1,3)),'EXT',XS.GET_TX_SERVICE_TYPE(p_CALLING_MODULE,p_MODEL_ID,A.COMPONENT_ID),
									        		DECODE(UPPER(B.RATE_STRUCTURE),'INTERNAL','None',B.COMPONENT_REFERENCE))
	ORDER BY COMPONENT_NAME;

CURSOR c_ID_PAIRS IS
	SELECT DISTINCT A.PRODUCT_ID||','||A.COMPONENT_ID "PAIR",
    	PRODUCT_NAME, COMPONENT_NAME
	FROM BILLING_STATEMENT A,
    	PRODUCT B,
    	COMPONENT C
    WHERE ENTITY_ID = p_ENTITY_ID
    	AND STATEMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
    	AND STATEMENT_TYPE = p_STATEMENT_TYPE
        AND STATEMENT_STATE = p_STATEMENT_STATE
		AND AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			 	FROM BILLING_STATEMENT
				WHERE ENTITY_ID = A.ENTITY_ID
					AND PRODUCT_ID = A.PRODUCT_ID
					AND COMPONENT_ID = A.COMPONENT_ID
					AND STATEMENT_TYPE = A.STATEMENT_TYPE
					AND STATEMENT_STATE = A.STATEMENT_STATE
					AND STATEMENT_DATE = A.STATEMENT_DATE
					AND AS_OF_DATE <= p_AS_OF_DATE)
		AND B.PRODUCT_ID = A.PRODUCT_ID
		AND C.COMPONENT_ID = A.COMPONENT_ID
    ORDER BY PRODUCT_NAME, COMPONENT_NAME;

CURSOR c_MANUAL_INVOICE_LINES IS
	SELECT DISTINCT B.LINE_ITEM_NAME, B.LINE_ITEM_AMOUNT
    FROM INVOICE A, INVOICE_USER_LINE_ITEM B
    WHERE A.ENTITY_ID = p_ENTITY_ID
    	AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
        AND A.STATEMENT_STATE = p_STATEMENT_STATE
    	AND A.BEGIN_DATE <= v_END_DATE
        AND A.AS_OF_DATE =
        	(SELECT MAX(AS_OF_DATE)
            	FROM INVOICE
                WHERE ENTITY_ID = A.ENTITY_ID
                	AND STATEMENT_TYPE = A.STATEMENT_TYPE
                    AND STATEMENT_STATE = A.STATEMENT_STATE
                    AND BEGIN_DATE = A.BEGIN_DATE
                    AND AS_OF_DATE <= p_AS_OF_DATE)
        AND A.END_DATE >= v_BEGIN_DATE
        AND B.ENTITY_ID = A.ENTITY_ID
        AND B.STATEMENT_TYPE = A.STATEMENT_TYPE
        AND B.STATEMENT_STATE = A.STATEMENT_STATE
        AND B.BEGIN_DATE = A.BEGIN_DATE;
BEGIN

	p_STATUS := GA.SUCCESS;
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    v_EXPORT_INVOICE := NVL(TO_NUMBER(MODEL_VALUE_AT_KEY(p_MODEL_ID,'Billing Export','Options', 'Use Invoice For Summary', 0)),0);

    IF v_EXPORT_INVOICE = 1 THEN
    	BEGIN
        	SELECT TRUNC(BEGIN_DATE), ADD_SECONDS_TO_DATE(TRUNC(END_DATE)+1,-1), INVOICE_ID
            INTO v_BEGIN_DATE, v_END_DATE, v_INVOICE_ID
            FROM INVOICE A
            WHERE ENTITY_ID = p_ENTITY_ID
		    	AND STATEMENT_TYPE = p_STATEMENT_TYPE
		        AND STATEMENT_STATE = p_STATEMENT_STATE
                AND BEGIN_DATE <= p_BEGIN_DATE
                AND AS_OF_DATE =
		        	(SELECT MAX(AS_OF_DATE)
		            	FROM INVOICE
		                WHERE ENTITY_ID = A.ENTITY_ID
		                	AND STATEMENT_TYPE = A.STATEMENT_TYPE
		                    AND STATEMENT_STATE = A.STATEMENT_STATE
		                    AND BEGIN_DATE = A.BEGIN_DATE
		                    AND AS_OF_DATE <= p_AS_OF_DATE)
				AND END_DATE >= p_BEGIN_DATE;
        EXCEPTION
        	WHEN NO_DATA_FOUND THEN
            	-- return no data
            	p_ID_PAIRS := '';
                NULL_CURSOR(p_CURSOR);
                RETURN;
        END;
	ELSE
    	v_BEGIN_DATE := PC.GET_CORRECT_STATEMENT_DATE(p_CALLING_MODULE,p_ENTITY_ID,p_BEGIN_DATE);
        v_END_DATE := PC.GET_CORRECT_STATEMENT_DATE(p_CALLING_MODULE,p_ENTITY_ID,p_END_DATE);
        v_END_DATE := PC.GET_CORRECT_STATEMENT_END_DATE(p_CALLING_MODULE,p_ENTITY_ID,v_END_DATE);
        IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING THEN
        	-- for PSE Billing, only export manual line items if the invoice and
            -- statement intervals are the same
            SELECT DECODE(UPPER(SUBSTR(STATEMENT_INTERVAL,1,2)),UPPER(SUBSTR(INVOICE_INTERVAL,1,2)),1,0)
            INTO v_DO_MANUAL
            FROM PURCHASING_SELLING_ENTITY
            WHERE PSE_ID = p_ENTITY_ID;
        ELSE
        	-- non-PSE Billing? then invoice and statement intervals are always
            -- the same: Month
        	v_DO_MANUAL := 1;
        END IF;
    END IF;

	UT.GET_RTO_WORK_ID(v_WORK_ID);

    IF v_EXPORT_INVOICE = 1 THEN
    	GET_EXPORT_INVOICE_SUMMARY (p_MODEL_ID, v_INVOICE_ID, v_WORK_ID);
    ELSE
        -- build the output into RTO_WORK
        FOR v_PRODUCT IN c_PRODUCTS LOOP
        	v_GRAND_TOTAL := v_GRAND_TOTAL + v_PRODUCT.CHARGE_AMOUNT;
        	INSERT INTO RTO_WORK (WORK_ID, WORK_SEQ, WORK_DATA)
            	VALUES (v_WORK_ID, v_SEQ, v_PRODUCT.PRODUCT_NAME||'|||$'||ROUND(v_PRODUCT.CHARGE_AMOUNT,2));
            v_SEQ := v_SEQ+1;
        	FOR v_TX_CHARGE IN c_TX_CHARGES(v_PRODUCT.PRODUCT_ID) LOOP
            	INSERT INTO RTO_WORK (WORK_ID, WORK_SEQ, WORK_DATA)
                	VALUES (v_WORK_ID, v_SEQ, '|'||EXPORT_TX_TITLE(v_TX_CHARGE.COMPONENT_NAME)||'|||$'||ROUND(v_TX_CHARGE.CHARGE_AMOUNT,2));
                v_SEQ := v_SEQ+1;
            END LOOP;
            FOR v_COMPONENT IN c_COMPONENTS(v_PRODUCT.PRODUCT_ID) LOOP
            	INSERT INTO RTO_WORK (WORK_ID, WORK_SEQ, WORK_DATA)
                	VALUES (v_WORK_ID, v_SEQ, '|'||v_COMPONENT.COMPONENT_NAME||'|||$'||ROUND(v_COMPONENT.CHARGE_AMOUNT,2));
                v_SEQ := v_SEQ+1;
            END LOOP;
        END LOOP;

        IF v_DO_MANUAL = 1 THEN
        	-- monthly billing? then also put manual invoice line items
    		SELECT COUNT(*), SUM(B.LINE_ITEM_AMOUNT) INTO v_MANUAL_COUNT, v_MANUAL_TOTAL
    	    FROM INVOICE A, INVOICE_USER_LINE_ITEM B
            WHERE A.ENTITY_ID = p_ENTITY_ID
            	AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
                AND A.STATEMENT_STATE = p_STATEMENT_STATE
            	AND A.BEGIN_DATE <= v_END_DATE
                AND A.END_DATE >= v_BEGIN_DATE
                AND B.ENTITY_ID = A.ENTITY_ID
                AND B.STATEMENT_TYPE = A.STATEMENT_TYPE
                AND B.STATEMENT_STATE = A.STATEMENT_STATE
                AND B.BEGIN_DATE = A.BEGIN_DATE;
            IF v_MANUAL_COUNT > 0 THEN
    			v_GRAND_TOTAL := v_GRAND_TOTAL + v_MANUAL_TOTAL;
    	        INSERT INTO RTO_WORK (WORK_ID, WORK_SEQ, WORK_DATA)
    	        	VALUES (v_WORK_ID, v_SEQ, 'Manual Line Items|||$'||ROUND(v_MANUAL_TOTAL,2));
    	        v_SEQ := v_SEQ+1;
    			FOR v_MANUAL_LINE IN c_MANUAL_INVOICE_LINES LOOP
    	        	INSERT INTO RTO_WORK (WORK_ID, WORK_SEQ, WORK_DATA)
    	            	VALUES (v_WORK_ID, v_SEQ, '|'||v_MANUAL_LINE.LINE_ITEM_NAME||'|||$'||ROUND(v_MANUAL_LINE.LINE_ITEM_AMOUNT,2));
    	            v_SEQ := v_SEQ+1;
    	        END LOOP;
    		END IF;
        END IF;

    	INSERT INTO RTO_WORK (WORK_ID, WORK_SEQ, WORK_DATA)
        	VALUES (v_WORK_ID, v_SEQ, ' ');
        v_SEQ := v_SEQ+1;
    	INSERT INTO RTO_WORK (WORK_ID, WORK_SEQ, WORK_DATA)
        	VALUES (v_WORK_ID, v_SEQ, 'Grand Total|||$'||ROUND(v_GRAND_TOTAL,2));
	END IF;

    -- select output into cursor
    OPEN p_CURSOR FOR
    	SELECT WORK_DATA
        FROM RTO_WORK
        WHERE WORK_ID = v_WORK_ID
        ORDER BY WORK_SEQ;

    -- get list of products/components
	FOR v_PAIR IN c_ID_PAIRS LOOP
		v_ID_PAIRS := v_ID_PAIRS||v_PAIR.PAIR||';';
	END LOOP;
	p_ID_PAIRS := v_ID_PAIRS;

    p_BEGIN_DATE := TRUNC(v_BEGIN_DATE);
    p_END_DATE := TRUNC(v_END_DATE);

    -- get entity name
	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_POSITION_AND_BILLING THEN
    	SELECT BILL_PARTY_NAME INTO p_ENTITY_NAME
        FROM BILL_PARTY
        WHERE BILL_PARTY_ID = p_ENTITY_ID;
	ELSIF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING THEN
    	SELECT PSE_NAME INTO p_ENTITY_NAME
        FROM PURCHASING_SELLING_ENTITY
        WHERE PSE_ID = p_ENTITY_ID;
	ELSIF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_GAS_DELIVERY THEN
    	SELECT POOL_NAME INTO p_ENTITY_NAME
        FROM POOL
        WHERE POOL_ID = p_ENTITY_ID;
	END IF;

    -- cleanup and then done
	UT.PURGE_RTO_WORK(v_WORK_ID);

EXCEPTION
	WHEN OTHERS THEN
    	UT.PURGE_RTO_WORK(v_WORK_ID);
        NULL_CURSOR(p_CURSOR);
		p_STATUS := SQLCODE;
        p_MESSAGE := SQLERRM;

END GET_EXPORT_SUMMARY;
---------------------------------------------------------------------------------------------------
PROCEDURE WRITE_TX_CHARGE_LINE
	(
    p_TRANSACTION_NAME IN VARCHAR,
    p_TRANSACTION_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_INTERVAL IN VARCHAR,
    p_CAPACITY_RESERVED IN NUMBER,
    p_TRANS_RATE IN NUMBER, p_TRANS_AMOUNT IN NUMBER,
    p_AS1_RATE IN NUMBER, p_AS1_AMOUNT IN NUMBER,
    p_AS2_RATE IN NUMBER, p_AS2_AMOUNT IN NUMBER,
    p_AS3_RATE IN NUMBER, p_AS3_AMOUNT IN NUMBER,
    p_AS4_RATE IN NUMBER, p_AS4_AMOUNT IN NUMBER,
    p_AS5_RATE IN NUMBER, p_AS5_AMOUNT IN NUMBER,
    p_AS6_RATE IN NUMBER, p_AS6_AMOUNT IN NUMBER,
    p_WORK_ID IN NUMBER,
    p_OUT_WORK_ID IN NUMBER,
    p_TIME_ZONE IN VARCHAR,
    p_SEQ IN OUT NUMBER
    ) AS
v_ROW_TOTAL NUMBER;
v_ROW_NOTES VARCHAR2(32);
v_FMT_BEGIN_DATE VARCHAR2(32);
v_OFFSET NUMBER;
CURSOR c_NOTES IS
	SELECT DISTINCT A.CHARGE_INTERVAL "NOTE"
   	FROM TRANSMISSION_CHARGE A, RTO_WORK B
    WHERE TRANSACTION_NAME = p_TRANSACTION_NAME
    	AND TRANSACTION_ID = p_TRANSACTION_ID
        AND CHARGE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
        AND CHARGE_ID < 0
        AND WORK_XID = CHARGE_ID
        AND WORK_ID = p_WORK_ID
        AND NOT (CHARGE_INTERVAL IS NULL)
	ORDER BY 1;
BEGIN
    v_ROW_TOTAL := p_TRANS_AMOUNT+p_AS1_AMOUNT+p_AS2_AMOUNT+
            	p_AS3_AMOUNT+p_AS4_AMOUNT+p_AS5_AMOUNT+p_AS6_AMOUNT;
    -- gather notes for this row
    v_ROW_NOTES := '';
    FOR v_NOTE IN c_NOTES LOOP
    	v_ROW_NOTES := v_ROW_NOTES||' '||v_NOTE.NOTE;
    END LOOP;
    -- format begin date - not hour-ending
    SELECT DECODE(UPPER(SUBSTR(p_INTERVAL,1,2)),'5 ',5,'10',10,'15',15,'20',20,'30',30,'HO',60,'DA',0,'WE',0,'MO',0,'QU',0,'YE',0)
    INTO v_OFFSET FROM DUAL;
    IF v_OFFSET <= 0 THEN
    	v_FMT_BEGIN_DATE := FROM_CUT_AS_HED(p_BEGIN_DATE,p_TIME_ZONE,GET_FORMAT_FROM_INTERVAL(p_INTERVAL));
    ELSE
    	v_FMT_BEGIN_DATE := TO_CHAR(NEW_TIME(ADD_MINUTES_TO_DATE(p_BEGIN_DATE,-v_OFFSET),CUT_TIME_ZONE,p_TIME_ZONE),'YYYY-MM-DD HH24:MI');
    END IF;
    -- put into to output work table
    INSERT INTO RTO_WORK (WORK_ID, WORK_SEQ, WORK_DATA)
    	VALUES (p_OUT_WORK_ID, p_SEQ, p_TRANSACTION_NAME||'|'||
                                      ''''||v_FMT_BEGIN_DATE||'|'||
                                      ''''||FROM_CUT_AS_HED(p_END_DATE,p_TIME_ZONE,GET_FORMAT_FROM_INTERVAL(p_INTERVAL))||'|'||
                                      p_CAPACITY_RESERVED||'|'||
                                      ROUND(p_TRANS_RATE,2)||'|'||ROUND(p_TRANS_AMOUNT,2)||'|'||
                                      ROUND(p_AS1_RATE,2)||'|'||ROUND(p_AS1_AMOUNT,2)||'|'||
                                      ROUND(p_AS2_RATE,2)||'|'||ROUND(p_AS2_AMOUNT,2)||'|'||
                                      ROUND(p_AS3_RATE,2)||'|'||ROUND(p_AS3_AMOUNT,2)||'|'||
                                      ROUND(p_AS4_RATE,2)||'|'||ROUND(p_AS4_AMOUNT,2)||'|'||
                                      ROUND(p_AS5_RATE,2)||'|'||ROUND(p_AS5_AMOUNT,2)||'|'||
                                      ROUND(p_AS6_RATE,2)||'|'||ROUND(p_AS6_AMOUNT,2)||'|'||
                                      ROUND(v_ROW_TOTAL,2)||'|'||v_ROW_NOTES);
    p_SEQ := p_SEQ+1;
END WRITE_TX_CHARGE_LINE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_TX_CHARGE_EXPORT_DETAIL
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
    p_PRODUCT_ID IN NUMBER,
    p_STATEMENT_TYPE IN NUMBER,
    p_STATEMENT_STATE IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_AS_OF_DATE IN DATE,
    p_TIME_ZONE IN VARCHAR,
	p_CURSOR IN OUT GA.REFCURSOR
    ) AS
v_WORK_ID NUMBER;
v_CHARGE_ID NUMBER;
v_OUT_WORK_ID NUMBER;
v_SEQ NUMBER;
v_LAST_TX_ID NUMBER := -1;
v_INTERVAL VARCHAR2(16);
CURSOR c_EXT IS
	SELECT COMPONENT_ID
	FROM BILLING_STATEMENT A
    WHERE ENTITY_ID = p_ENTITY_ID
    	AND PRODUCT_ID = p_PRODUCT_ID
    	AND STATEMENT_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
    	AND STATEMENT_TYPE = p_STATEMENT_TYPE
        AND STATEMENT_STATE = p_STATEMENT_STATE
		AND AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			 	FROM BILLING_STATEMENT
				WHERE ENTITY_ID = A.ENTITY_ID
					AND PRODUCT_ID = A.PRODUCT_ID
					AND COMPONENT_ID = A.COMPONENT_ID
					AND STATEMENT_TYPE = A.STATEMENT_TYPE
					AND STATEMENT_STATE = A.STATEMENT_STATE
					AND STATEMENT_DATE = A.STATEMENT_DATE
					AND AS_OF_DATE <= p_AS_OF_DATE)
        -- external transmission charges
		AND (UPPER(CHARGE_VIEW_TYPE) = 'EXTERNAL' AND XS.COMPONENT_IS_TX_CHARGE(p_CALLING_MODULE,p_MODEL_ID,A.COMPONENT_ID)=1);
CURSOR c_LINES IS
	SELECT TRANSACTION_NAME,
    	TRANSACTION_ID,
        CAPACITY_RESERVED,
        CHARGE_DATE,
        AVG(DECODE(UPPER(SERVICE_TYPE),'NONE',CHARGE_RATE,NULL)) "TRANS_RATE",
        SUM(DECODE(UPPER(SERVICE_TYPE),'NONE',CHARGE_AMOUNT,0)) "TRANS_AMOUNT",
        AVG(DECODE(UPPER(SERVICE_TYPE),'SCHEDULE 1',CHARGE_RATE,NULL)) "AS1_RATE",
        SUM(DECODE(UPPER(SERVICE_TYPE),'SCHEDULE 1',CHARGE_AMOUNT,0)) "AS1_AMOUNT",
        AVG(DECODE(UPPER(SERVICE_TYPE),'SCHEDULE 2',CHARGE_RATE,NULL)) "AS2_RATE",
        SUM(DECODE(UPPER(SERVICE_TYPE),'SCHEDULE 2',CHARGE_AMOUNT,0)) "AS2_AMOUNT",
        AVG(DECODE(UPPER(SERVICE_TYPE),'SCHEDULE 3',CHARGE_RATE,NULL)) "AS3_RATE",
        SUM(DECODE(UPPER(SERVICE_TYPE),'SCHEDULE 3',CHARGE_AMOUNT,0)) "AS3_AMOUNT",
        AVG(DECODE(UPPER(SERVICE_TYPE),'SCHEDULE 4',CHARGE_RATE,NULL)) "AS4_RATE",
        SUM(DECODE(UPPER(SERVICE_TYPE),'SCHEDULE 4',CHARGE_AMOUNT,0)) "AS4_AMOUNT",
        AVG(DECODE(UPPER(SERVICE_TYPE),'SCHEDULE 5',CHARGE_RATE,NULL)) "AS5_RATE",
        SUM(DECODE(UPPER(SERVICE_TYPE),'SCHEDULE 5',CHARGE_AMOUNT,0)) "AS5_AMOUNT",
        AVG(DECODE(UPPER(SERVICE_TYPE),'SCHEDULE 6',CHARGE_RATE,NULL)) "AS6_RATE",
        SUM(DECODE(UPPER(SERVICE_TYPE),'SCHEDULE 6',CHARGE_AMOUNT,0)) "AS6_AMOUNT"
    FROM
    	-- bullt-in transmission charges
    (SELECT A.TRANSACTION_NAME,
    	A.TRANSACTION_ID,
        A.CAPACITY_RESERVED,
        A.CHARGE_DATE,
        DECODE(A.CAPACITY_RESERVED,0,A.CHARGE_RATE,A.CHARGE_AMOUNT/A.CAPACITY_RESERVED) "CHARGE_RATE",
        A.CHARGE_AMOUNT,
        DECODE(UPPER(C.RATE_STRUCTURE),'INTERNAL','None',C.COMPONENT_REFERENCE) "SERVICE_TYPE"
	FROM TRANSMISSION_CHARGE A,
    	BILLING_STATEMENT B,
        COMPONENT C
	WHERE B.ENTITY_ID = p_ENTITY_ID
    	AND B.PRODUCT_ID = p_PRODUCT_ID
    	AND B.STATEMENT_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
    	AND B.STATEMENT_TYPE = p_STATEMENT_TYPE
        AND B.STATEMENT_STATE = p_STATEMENT_STATE
		AND B.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			 	FROM BILLING_STATEMENT
				WHERE ENTITY_ID = B.ENTITY_ID
					AND PRODUCT_ID = B.PRODUCT_ID
					AND COMPONENT_ID = B.COMPONENT_ID
					AND STATEMENT_TYPE = B.STATEMENT_TYPE
					AND STATEMENT_STATE = B.STATEMENT_STATE
					AND STATEMENT_DATE = B.STATEMENT_DATE
					AND AS_OF_DATE <= p_AS_OF_DATE)
        AND A.CHARGE_ID = B.CHARGE_ID
        AND A.CHARGE_ID > 0
        AND A.CHARGE_AMOUNT <> 0
        AND C.COMPONENT_ID = B.COMPONENT_ID
    UNION ALL
    	-- external transmission charges
	SELECT A.TRANSACTION_NAME,
    	A.TRANSACTION_ID,
        A.CAPACITY_RESERVED,
        A.CHARGE_DATE,
        DECODE(A.CAPACITY_RESERVED,0,A.CHARGE_RATE,A.CHARGE_AMOUNT/A.CAPACITY_RESERVED) "CHARGE_RATE",
        A.CHARGE_AMOUNT,
        B.WORK_DATA "SERVICE_TYPE"
	FROM TRANSMISSION_CHARGE A,
    	RTO_WORK B
	WHERE A.CHARGE_ID < 0
        AND A.CHARGE_AMOUNT <> 0
    	AND B.WORK_ID = v_WORK_ID
        AND B.WORK_XID = A.CHARGE_ID)
    GROUP BY TRANSACTION_NAME, TRANSACTION_ID, CAPACITY_RESERVED, CHARGE_DATE
	ORDER BY TRANSACTION_NAME, TRANSACTION_ID, CHARGE_DATE;
v_TOTALS c_LINES%ROWTYPE;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
BEGIN
	UT.GET_RTO_WORK_ID(v_WORK_ID);
	UT.GET_RTO_WORK_ID(v_OUT_WORK_ID);

    FOR v_EXT IN c_EXT LOOP
		UT.GET_RTO_WORK_ID(v_CHARGE_ID); -- get temp charge ID
        v_CHARGE_ID := -v_CHARGE_ID; -- negative to make sure it won't interfere w/ existing valid charge IDs
        INSERT INTO RTO_WORK (WORK_ID, WORK_XID) VALUES (v_WORK_ID, v_CHARGE_ID);
        XS.GET_TX_CHARGES_FOR_REPORT(p_CALLING_MODULE, p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_ENTITY_ID, p_PRODUCT_ID, v_EXT.COMPONENT_ID, p_STATEMENT_TYPE, p_TIME_ZONE, p_AS_OF_DATE, v_CHARGE_ID);
        -- add oasis service type to work table
        UPDATE RTO_WORK SET WORK_DATA = XS.GET_TX_SERVICE_TYPE(p_CALLING_MODULE, p_MODEL_ID, v_EXT.COMPONENT_ID)
        	WHERE WORK_ID = v_WORK_ID AND WORK_XID = v_CHARGE_ID;
    END LOOP;

    -- use output work table for creating report view
    	-- headers first
    INSERT INTO RTO_WORK (WORK_ID, WORK_SEQ, WORK_DATA)
    	VALUES (v_OUT_WORK_ID, 0, '||||'||EXPORT_TX_LABEL('None')||'|'||EXPORT_TX_LABEL('None')||'|'
        								||EXPORT_TX_LABEL('Schedule 1')||'|'||EXPORT_TX_LABEL('Schedule 1')||'|'
        								||EXPORT_TX_LABEL('Schedule 2')||'|'||EXPORT_TX_LABEL('Schedule 2')||'|'
        								||EXPORT_TX_LABEL('Schedule 3')||'|'||EXPORT_TX_LABEL('Schedule 3')||'|'
        								||EXPORT_TX_LABEL('Schedule 4')||'|'||EXPORT_TX_LABEL('Schedule 4')||'|'
        								||EXPORT_TX_LABEL('Schedule 5')||'|'||EXPORT_TX_LABEL('Schedule 5')||'|'
        								||EXPORT_TX_LABEL('Schedule 6')||'|'||EXPORT_TX_LABEL('Schedule 6')||'||');
    INSERT INTO RTO_WORK (WORK_ID, WORK_SEQ, WORK_DATA)
    	VALUES (v_OUT_WORK_ID, 1, 'Reservation|Begin Date|End Date|Quant.Reserved|Rate|Amount|Rate|Amount|Rate|Amount|Rate|Amount|Rate|Amount|Rate|Amount|Rate|Amount|Total|Notes');
	v_SEQ := 2;
    v_TOTALS.TRANSACTION_ID := -1;

    FOR v_LINE IN c_LINES LOOP
    	-- compact the line items - instead of one row per charge date, one row per common rates/capacities with
        -- begin and end date
        IF v_TOTALS.TRANSACTION_ID <> v_LINE.TRANSACTION_ID OR v_TOTALS.CAPACITY_RESERVED <> v_LINE.CAPACITY_RESERVED
        	OR v_TOTALS.TRANS_RATE <> v_LINE.TRANS_RATE
            OR v_TOTALS.AS1_RATE <> v_LINE.AS1_RATE OR v_TOTALS.AS2_RATE <> v_LINE.AS2_RATE
            OR v_TOTALS.AS3_RATE <> v_LINE.AS3_RATE OR v_TOTALS.AS4_RATE <> v_LINE.AS4_RATE
            OR v_TOTALS.AS5_RATE <> v_LINE.AS5_RATE OR v_TOTALS.AS6_RATE <> v_LINE.AS6_RATE THEN
        	-- only write to RTO_WORK when something changes
        	IF v_TOTALS.TRANSACTION_ID <> -1 THEN
                IF v_TOTALS.TRANSACTION_ID <> v_LAST_TX_ID THEN
                	v_LAST_TX_ID := v_TOTALS.TRANSACTION_ID;
                    BEGIN
        	            SELECT TRANSACTION_INTERVAL INTO v_INTERVAL
                        FROM INTERCHANGE_TRANSACTION WHERE TRANSACTION_ID = v_TOTALS.TRANSACTION_ID;
                    EXCEPTION
                    	WHEN OTHERS THEN
                        	v_INTERVAL := '';
                    END;
                END IF;
            	WRITE_TX_CHARGE_LINE (
                	v_TOTALS.TRANSACTION_NAME,
                    v_TOTALS.TRANSACTION_ID,
                    v_BEGIN_DATE,
                    v_END_DATE,
                    v_INTERVAL,
                    v_TOTALS.CAPACITY_RESERVED,
                    v_TOTALS.TRANS_RATE, v_TOTALS.TRANS_AMOUNT,
                    v_TOTALS.AS1_RATE, v_TOTALS.AS1_AMOUNT,
                    v_TOTALS.AS2_RATE, v_TOTALS.AS2_AMOUNT,
                    v_TOTALS.AS3_RATE, v_TOTALS.AS3_AMOUNT,
                    v_TOTALS.AS4_RATE, v_TOTALS.AS4_AMOUNT,
                    v_TOTALS.AS5_RATE, v_TOTALS.AS5_AMOUNT,
                    v_TOTALS.AS6_RATE, v_TOTALS.AS6_AMOUNT,
                    v_WORK_ID,
                    v_OUT_WORK_ID,
                    p_TIME_ZONE,
                    v_SEQ
                );
			END IF;
            -- re-initialize totals from current line
            v_TOTALS := v_LINE;
            v_BEGIN_DATE := v_LINE.CHARGE_DATE;
		ELSE
        	-- not a new line? then just accumulate the numbers
            v_TOTALS.TRANS_AMOUNT := v_TOTALS.TRANS_AMOUNT + v_LINE.TRANS_AMOUNT;
            v_TOTALS.AS1_AMOUNT := v_TOTALS.AS1_AMOUNT + v_LINE.AS1_AMOUNT;
            v_TOTALS.AS2_AMOUNT := v_TOTALS.AS2_AMOUNT + v_LINE.AS2_AMOUNT;
            v_TOTALS.AS3_AMOUNT := v_TOTALS.AS3_AMOUNT + v_LINE.AS3_AMOUNT;
            v_TOTALS.AS4_AMOUNT := v_TOTALS.AS4_AMOUNT + v_LINE.AS4_AMOUNT;
            v_TOTALS.AS5_AMOUNT := v_TOTALS.AS5_AMOUNT + v_LINE.AS5_AMOUNT;
            v_TOTALS.AS6_AMOUNT := v_TOTALS.AS6_AMOUNT + v_LINE.AS6_AMOUNT;
		END IF;
        -- keep pushing out end date
        v_END_DATE := v_LINE.CHARGE_DATE;
    END LOOP;
    -- write final line
	IF v_TOTALS.TRANSACTION_ID <> -1 THEN
        IF v_TOTALS.TRANSACTION_ID <> v_LAST_TX_ID THEN
        	v_LAST_TX_ID := v_TOTALS.TRANSACTION_ID;
            BEGIN
             SELECT TRANSACTION_INTERVAL INTO v_INTERVAL
                FROM INTERCHANGE_TRANSACTION WHERE TRANSACTION_ID = v_TOTALS.TRANSACTION_ID;
            EXCEPTION
            	WHEN OTHERS THEN
                	v_INTERVAL := '';
            END;
        END IF;
    	WRITE_TX_CHARGE_LINE (
        	v_TOTALS.TRANSACTION_NAME,
            v_TOTALS.TRANSACTION_ID,
            v_BEGIN_DATE,
            v_END_DATE,
            v_INTERVAL,
            v_TOTALS.CAPACITY_RESERVED,
            v_TOTALS.TRANS_RATE, v_TOTALS.TRANS_AMOUNT,
            v_TOTALS.AS1_RATE, v_TOTALS.AS1_AMOUNT,
            v_TOTALS.AS2_RATE, v_TOTALS.AS2_AMOUNT,
            v_TOTALS.AS3_RATE, v_TOTALS.AS3_AMOUNT,
            v_TOTALS.AS4_RATE, v_TOTALS.AS4_AMOUNT,
            v_TOTALS.AS5_RATE, v_TOTALS.AS5_AMOUNT,
            v_TOTALS.AS6_RATE, v_TOTALS.AS6_AMOUNT,
            v_WORK_ID,
            v_OUT_WORK_ID,
            p_TIME_ZONE,
            v_SEQ
        );
	END IF;

    -- select all this output into cursor
    OPEN p_CURSOR FOR
    	SELECT WORK_DATA
        FROM RTO_WORK
        WHERE WORK_ID = v_OUT_WORK_ID
        ORDER BY WORK_SEQ;

    -- cleanup and then done
    DELETE TRANSMISSION_CHARGE WHERE CHARGE_ID IN
    	(SELECT WORK_XID FROM RTO_WORK WHERE WORK_ID = v_WORK_ID);
	UT.PURGE_RTO_WORK(v_WORK_ID);
	UT.PURGE_RTO_WORK(v_OUT_WORK_ID);

EXCEPTION
	WHEN OTHERS THEN
	    DELETE TRANSMISSION_CHARGE WHERE CHARGE_ID IN
	    	(SELECT WORK_XID FROM RTO_WORK WHERE WORK_ID = v_WORK_ID);
    	UT.PURGE_RTO_WORK(v_WORK_ID);
		UT.PURGE_RTO_WORK(v_OUT_WORK_ID);
        RAISE;

END GET_TX_CHARGE_EXPORT_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_EXPORT_DETAIL
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
    p_STATEMENT_TYPE IN NUMBER,
    p_STATEMENT_STATE IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_AS_OF_DATE IN DATE,
    p_TIME_ZONE IN VARCHAR,
    p_ID_PAIRS IN OUT VARCHAR,
    p_USE_NORMAL_DETAIL OUT NUMBER,
    p_PRODUCT_NAME OUT VARCHAR,
    p_PRODUCT_ID OUT NUMBER,
    p_COMPONENT_NAME OUT VARCHAR,
    p_COMPONENT_ID OUT NUMBER,
    p_HEADER_ROWS OUT NUMBER,
    p_STATUS OUT NUMBER,
    p_MESSAGE OUT VARCHAR,
	p_CURSOR IN OUT GA.REFCURSOR
    ) AS

v_WORK_ID NUMBER;
v_PAIR_TABLE GA.STRING_TABLE;
v_ID_TABLE GA.ID_TABLE;
v_TX_CHARGE_COUNT NUMBER;
v_ID_PAIRS VARCHAR2(4000) := '';
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_RATE_STRUCTURE VARCHAR2(32);
v_NAME VARCHAR2(32);
v_EXCLUDE_DETAILS NUMBER;

CURSOR c_ID_PAIRS IS
	SELECT DISTINCT WORK_XID||','||WORK_DATA "PAIR",
    	PRODUCT_NAME, COMPONENT_NAME
	FROM RTO_WORK A,
    	PRODUCT B,
    	COMPONENT C
    WHERE WORK_ID = v_WORK_ID
		AND B.PRODUCT_ID = WORK_XID
		AND C.COMPONENT_ID = WORK_DATA
    ORDER BY PRODUCT_NAME, COMPONENT_NAME;

BEGIN

	p_STATUS := GA.SUCCESS;
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    v_EXCLUDE_DETAILS := NVL(TO_NUMBER(MODEL_VALUE_AT_KEY(p_MODEL_ID,'Billing Export','Options', 'Exclude Details', 0)),0);
    IF v_EXCLUDE_DETAILS = 1 THEN
    	p_ID_PAIRS := '';
        p_USE_NORMAL_DETAIL := 0;
        -- empty recordset
        OPEN p_CURSOR FOR
        	SELECT NULL FROM DUAL WHERE 0=1;
    END IF;

	v_BEGIN_DATE := TRUNC(p_BEGIN_DATE);
	v_END_DATE := ADD_SECONDS_TO_DATE(TRUNC(p_END_DATE)+1,-1);
	UT.GET_RTO_WORK_ID(v_WORK_ID);
	UT.TOKENS_FROM_STRING(p_ID_PAIRS, ';', v_PAIR_TABLE);

	FOR v_INDEX IN v_PAIR_TABLE.FIRST..v_PAIR_TABLE.LAST LOOP
    	IF NOT (v_PAIR_TABLE(v_INDEX) IS NULL) THEN
			UT.IDS_FROM_STRING(v_PAIR_TABLE(v_INDEX), ',', v_ID_TABLE);
	    	INSERT INTO RTO_WORK (WORK_ID, WORK_XID, WORK_DATA, WORK_SEQ)
	        	VALUES (v_WORK_ID, v_ID_TABLE(1), v_ID_TABLE(2), v_INDEX);
        END IF;
    END LOOP;

    -- get next product
    SELECT WORK_XID, PRODUCT_NAME INTO p_PRODUCT_ID, p_PRODUCT_NAME
    FROM (SELECT WORK_XID, PRODUCT_NAME
    	FROM RTO_WORK, PRODUCT
        WHERE WORK_ID = v_WORK_ID
        	AND PRODUCT_ID = WORK_XID
        ORDER BY WORK_SEQ)
    WHERE ROWNUM = 1;

    -- remove from list of components those that are tx charges
    DELETE RTO_WORK
    WHERE WORK_ID = v_WORK_ID
    	AND WORK_XID = p_PRODUCT_ID
        AND WORK_DATA IN (SELECT DISTINCT TO_CHAR(COMPONENT_ID)
        				FROM BILLING_STATEMENT
						WHERE (UPPER(CHARGE_VIEW_TYPE) = 'TRANSMISSION' OR
							(UPPER(CHARGE_VIEW_TYPE) = 'EXTERNAL' AND XS.COMPONENT_IS_TX_CHARGE(p_CALLING_MODULE,p_MODEL_ID,COMPONENT_ID)=1)));

    IF SQL%ROWCOUNT > 0 THEN
    	-- rowcount > 0 means that there were some transmission charges - so
        -- compute those
    	p_COMPONENT_ID := 0;
        p_COMPONENT_NAME := 'Transmission Charges';
        p_HEADER_ROWS := 2;
        p_USE_NORMAL_DETAIL := 0;
        GET_TX_CHARGE_EXPORT_DETAIL (p_CALLING_MODULE, p_MODEL_ID, p_ENTITY_ID, p_PRODUCT_ID,
			p_STATEMENT_TYPE, p_STATEMENT_STATE, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, p_TIME_ZONE, p_CURSOR);
    ELSE
    	-- otherwise, process normal components
    	-- get component
        SELECT WORK_DATA, COMPONENT_NAME, RATE_STRUCTURE
        INTO p_COMPONENT_ID, p_COMPONENT_NAME, v_RATE_STRUCTURE
        FROM (SELECT WORK_DATA, COMPONENT_NAME, RATE_STRUCTURE
        	FROM RTO_WORK, COMPONENT
            WHERE WORK_ID = v_WORK_ID
            	AND COMPONENT_ID = WORK_DATA
            ORDER BY WORK_SEQ)
        WHERE ROWNUM = 1;
        -- remove this one from the list
        DELETE RTO_WORK WHERE WORK_ID = v_WORK_ID AND WORK_XID = p_PRODUCT_ID
        	AND WORK_DATA = TO_CHAR(p_COMPONENT_ID);
        -- give external charges a chance to customize output
		IF UPPER(v_RATE_STRUCTURE) = 'EXTERNAL' THEN
        	XS.GET_CHARGES_FOR_REPORT(p_CALLING_MODULE,p_MODEL_ID,v_BEGIN_DATE,v_END_DATE,p_ENTITY_ID,p_PRODUCT_ID,p_COMPONENT_ID,p_STATEMENT_TYPE,p_STATEMENT_STATE,p_TIME_ZONE,p_AS_OF_DATE,v_NAME,p_USE_NORMAL_DETAIL,p_HEADER_ROWS,p_CURSOR);
            IF NOT (v_NAME IS NULL) THEN
            	p_COMPONENT_NAME := v_NAME;
            END IF;
        ELSE
	        -- standard drill-down details will do - no need to query any data
		    p_USE_NORMAL_DETAIL := 1;
        END IF;
        IF p_USE_NORMAL_DETAIL = 1 THEN
			NULL_CURSOR(p_CURSOR);
        END IF;
    END IF;

    -- re-build list of ID pairs
    FOR v_PAIR IN c_ID_PAIRS LOOP
    	v_ID_PAIRS := v_ID_PAIRS||v_PAIR.PAIR||';';
    END LOOP;
    p_ID_PAIRS := v_ID_PAIRS;

    -- cleanup and then done
	UT.PURGE_RTO_WORK(v_WORK_ID);

EXCEPTION
	WHEN OTHERS THEN
    	UT.PURGE_RTO_WORK(v_WORK_ID);
		p_STATUS := SQLCODE;
        p_MESSAGE := SQLERRM;

END GET_EXPORT_DETAIL;
---------------------------------------------------------------------------------------------------
FUNCTION EXPORT_TX_TITLE
	(p_TX_SERVICE_TYPE IN VARCHAR) RETURN VARCHAR IS
BEGIN
	RETURN NVL(GET_DICTIONARY_VALUE(p_TX_SERVICE_TYPE, 1, 'BILLING EXPORT', 'TX SERVICE TYPE TITLE'),p_TX_SERVICE_TYPE);
END EXPORT_TX_TITLE;
---------------------------------------------------------------------------------------------------
FUNCTION EXPORT_TX_LABEL
	(p_TX_SERVICE_TYPE IN VARCHAR) RETURN VARCHAR IS
BEGIN
	RETURN NVL(GET_DICTIONARY_VALUE(p_TX_SERVICE_TYPE, 1, 'BILLING EXPORT', 'TX SERVICE TYPE LABEL'),p_TX_SERVICE_TYPE);
END EXPORT_TX_LABEL;
---------------------------------------------------------------------------------------------------
PROCEDURE TAX_COMPONENTS
	(
    p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
    ) AS
BEGIN
	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
    	SELECT DISTINCT COMPONENT_NAME "ENTITY_NAME", COMPONENT_ID "ENTITY_ID"
        FROM COMPONENT
        WHERE UPPER(CHARGE_TYPE) = 'TAX';

EXCEPTION
	WHEN OTHERS THEN
    	p_STATUS := SQLCODE;
END TAX_COMPONENTS;
---------------------------------------------------------------------------------------------------
FUNCTION GET_DOMAIN_ID
	(
    p_CALLING_MODULE IN VARCHAR
    ) RETURN NUMBER IS
v_DOMAIN_ALIAS VARCHAR2(32);
v_DOMAIN_ID NUMBER;
BEGIN
	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = 'S' THEN
    	v_DOMAIN_ALIAS := g_PSE;
	ELSIF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = 'G' THEN
    	v_DOMAIN_ALIAS := g_POOL;
	ELSE --IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = 'P' THEN
    	v_DOMAIN_ALIAS := g_BILL_PARTY;
    END IF;

    ID.ID_FOR_ENTITY_DOMAIN_ALIAS(v_DOMAIN_ALIAS, v_DOMAIN_ID);

    RETURN v_DOMAIN_ID;
END GET_DOMAIN_ID;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_ENTITY_TIME_ZONE
	(
    p_CALLING_MODULE IN VARCHAR,
    p_MODEL_ID IN NUMBER,
    p_ENTITY_ID IN NUMBER,
    p_TIME_ZONE OUT VARCHAR2,
    p_STATUS OUT NUMBER
    ) AS
BEGIN
	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING THEN
		SELECT TIME_ZONE INTO p_TIME_ZONE
	    FROM PURCHASING_SELLING_ENTITY
        WHERE PSE_ID = p_ENTITY_ID;
	ELSE
    	p_TIME_ZONE := LOCAL_TIME_ZONE;
	END IF;

EXCEPTION
	WHEN OTHERS THEN
    	p_TIME_ZONE := NULL;
        p_STATUS := SQLCODE;

END GET_ENTITY_TIME_ZONE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_INVOICE_CATEGORIES
	(
    p_ENTITY_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_AS_OF_DATE IN DATE,
    p_STATUS OUT NUMBER,
    p_CURSOR IN OUT GA.REFCURSOR
    ) AS
BEGIN
	OPEN p_CURSOR FOR
    	SELECT DISTINCT LINE_ITEM_CATEGORY
        FROM INVOICE A,
        	INVOICE_LINE_ITEM B
		WHERE A.ENTITY_ID = p_ENTITY_ID
        	AND A.STATEMENT_TYPE > 0
            AND A.STATEMENT_STATE BETWEEN 1 AND 2
            AND A.BEGIN_DATE <= p_BEGIN_DATE
            AND A.END_DATE >= p_BEGIN_DATE
            AND A.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
            					FROM INVOICE
                                WHERE ENTITY_ID = A.ENTITY_ID
                                	AND STATEMENT_TYPE = A.STATEMENT_TYPE
                                    AND STATEMENT_STATE = A.STATEMENT_STATE
                                    AND BEGIN_DATE = A.BEGIN_DATE
                                    AND AS_OF_DATE <= p_AS_OF_DATE)
			AND B.INVOICE_ID = A.INVOICE_ID
            AND NOT (B.LINE_ITEM_CATEGORY IS NULL);

	p_STATUS := GA.SUCCESS;
EXCEPTION
	WHEN OTHERS THEN
        p_STATUS := SQLCODE;
END GET_INVOICE_CATEGORIES;
---------------------------------------------------------------------------------------------------
PROCEDURE APPROVE_INVOICE
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_INVOICE_ID IN NUMBER,
	p_STATUS OUT NUMBER
	) AS
BEGIN

	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) = g_SCHEDULING THEN
		DECLARE
			v_ENTITY_ID NUMBER(9);
		BEGIN
			SELECT ENTITY_ID INTO v_ENTITY_ID
			FROM INVOICE WHERE INVOICE_ID = p_INVOICE_ID;

			IF NOT SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_PSE_INVOICE_APPROVE, v_ENTITY_ID) THEN
		   		RAISE INSUFFICIENT_PRIVILEGES;
			END IF;
		END;
	END IF;

	UPDATE INVOICE SET
		APPROVED_BY = SECURITY_CONTROLS.CURRENT_USER,
		APPROVED_WHEN = SYSDATE
	WHERE INVOICE_ID = p_INVOICE_ID;

	p_STATUS := GA.SUCCESS;
EXCEPTION
	WHEN OTHERS THEN
        p_STATUS := SQLCODE;
END APPROVE_INVOICE;
---------------------------------------------------------------------------------------------------
PROCEDURE UPLOAD_EMAIL_FILE
	(
	p_CALLING_MODULE IN VARCHAR2,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_WORK_ID IN OUT NUMBER,
	p_DATA IN VARCHAR2
	) AS
v_SEQ NUMBER;
BEGIN
	-- call the first time w/ work_id = 0, then for subsequent calls use the outbound value of
	-- work_id. upload file chunks for given entity - each file's first chunk must begin with
	-- '* filename.ext mime/type 0'. The trailing digit indicates that the following lines are text
	-- if it is zero or hex-encoded binary if it is 1.

	-- when all files are uploaded, call bs.send_emails()

	IF NVL(p_WORK_ID,0) = 0 THEN
		UT.GET_RTO_WORK_ID(p_WORK_ID);
	END IF;

	SELECT NVL(MAX(WORK_SEQ),0)+1 INTO v_SEQ
	FROM RTO_WORK
	WHERE WORK_ID = p_WORK_ID
		AND WORK_XID = p_ENTITY_ID;

	INSERT INTO RTO_WORK (WORK_ID, WORK_XID, WORK_SEQ, WORK_DATA)
		VALUES (p_WORK_ID, p_ENTITY_ID, v_SEQ, p_DATA);

END UPLOAD_EMAIL_FILE;
---------------------------------------------------------------------------------------------------
PROCEDURE ADD_EMAIL_FILES_FOR_ENTITY
	(
	p_ENTITY_ID IN NUMBER,
	p_WORK_ID IN NUMBER,
	p_EMAIL IN OUT NOCOPY ML.EMAIL_REC
	) AS
CURSOR c_CHUNKS IS
	SELECT WORK_DATA "DATA"
	FROM RTO_WORK
	WHERE WORK_ID = p_WORK_ID
		AND WORK_XID = p_ENTITY_ID
	ORDER BY WORK_SEQ;
v_HEX_ENCODED BOOLEAN := FALSE;
v_XFER_ENCODING VARCHAR2(32);
v_BEGUN_ATTACHMENT BOOLEAN := FALSE;
v_TOKENS GA.STRING_TABLE;
v_DATA VARCHAR2(4000);
v_BLOB BLOB := NULL;
BEGIN
	FOR v_CHUNK IN c_CHUNKS LOOP
		IF SUBSTR(v_CHUNK.DATA,1,1) = '*' THEN
			-- begin new attachment
        	IF v_BEGUN_ATTACHMENT THEN
				IF v_HEX_ENCODED THEN
					DBMS_LOB.CLOSE(v_BLOB);
					ML.WRITE_BLOB_BASE64(p_EMAIL, v_BLOB);
					DBMS_LOB.FREETEMPORARY(v_BLOB);
					v_BLOB := NULL;
				END IF;

        		ML.END_ATTACHMENT(p_EMAIL);
        	END IF;

			UT.TOKENS_FROM_STRING(v_CHUNK.DATA,' ',v_TOKENS);
			IF v_TOKENS(4) = '1' THEN
				v_XFER_ENCODING := ML.g_BASE64_ENCODING;
				v_HEX_ENCODED := TRUE;
				DBMS_LOB.CREATETEMPORARY(v_BLOB, TRUE);
				DBMS_LOB.OPEN(v_BLOB, DBMS_LOB.LOB_READWRITE);
			ELSE
				v_XFER_ENCODING := NULL;
				v_HEX_ENCODED := FALSE;
			END IF;

			ML.BEGIN_ATTACHMENT(p_EMAIL, v_TOKENS(3), FALSE, v_TOKENS(2), v_XFER_ENCODING);
			v_BEGUN_ATTACHMENT := TRUE;
		ELSE
			-- unescape leading quote/asterisk if necessary
			IF SUBSTR(v_CHUNK.DATA,1,1) = '''' THEN
				v_DATA := SUBSTR(v_CHUNK.DATA,2);
			ELSE
				v_DATA := v_CHUNK.DATA;
			END IF;
			-- write attachment data
			IF v_HEX_ENCODED THEN
				DECLARE
					v_RAW RAW(4000);
					v_LEN BINARY_INTEGER;
				BEGIN
					v_RAW := CD.HEX_DECODE(v_DATA);
					v_LEN := UTL_RAW.LENGTH(v_RAW);
					DBMS_LOB.WRITEAPPEND(v_BLOB, v_LEN, v_RAW);
				END;
			ELSE
				ML.WRITE_TEXT(p_EMAIL, v_DATA);
			END IF;
		END IF;
	END LOOP;

	IF v_BEGUN_ATTACHMENT THEN
        IF v_HEX_ENCODED THEN
        	DBMS_LOB.CLOSE(v_BLOB);
        	ML.WRITE_BLOB_BASE64(p_EMAIL, v_BLOB);
        	DBMS_LOB.FREETEMPORARY(v_BLOB);
        	v_BLOB := NULL;
        END IF;

		ML.END_ATTACHMENT(p_EMAIL);
	END IF;

END ADD_EMAIL_FILES_FOR_ENTITY;
---------------------------------------------------------------------------------------------------
PROCEDURE ADD_MESSAGE_BODY
	(
	p_CALLING_MODULE IN VARCHAR2,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_IDs IN ID_TABLE,
	p_EMAIL IN OUT NOCOPY ML.EMAIL_REC
	) AS
v_SOMETHING_DONE BOOLEAN := FALSE;
BEGIN
	XS.INVOICE_EMAIL_MESSAGE_BODY(p_CALLING_MODULE, p_MODEL_ID, p_ENTITY_IDs, p_EMAIL, v_SOMETHING_DONE);
	IF NOT v_SOMETHING_DONE THEN
		-- todo: add a default message body
		NULL;
	END IF;
END ADD_MESSAGE_BODY;
---------------------------------------------------------------------------------------------------
PROCEDURE ADD_EXTRA_ATTACHMENTS
	(
	p_CALLING_MODULE IN VARCHAR2,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_IDs IN ID_TABLE,
	p_EMAIL IN OUT NOCOPY ML.EMAIL_REC
	) AS
BEGIN
	XS.INVOICE_EMAIL_ADD_ATTACHMENTS(p_CALLING_MODULE, p_MODEL_ID, p_ENTITY_IDs, p_EMAIL);
END ADD_EXTRA_ATTACHMENTS;
---------------------------------------------------------------------------------------------------
FUNCTION GET_SENDER_ADDRESS
	(
	p_MODEL_ID IN NUMBER
	) RETURN VARCHAR2 IS
v_RET VARCHAR2(512);
BEGIN
	v_RET := GET_DICTIONARY_VALUE(SECURITY_CONTROLS.CURRENT_USER, p_MODEL_ID, 'Billing', 'Invoice', 'E-mail Sender', '?', 0);
	IF v_RET IS NULL THEN
		BEGIN
			SELECT A.VALUE INTO v_RET
			FROM SYSTEM_DICTIONARY A
			WHERE A.MODEL_ID = p_MODEL_ID
				AND UPPER(A.MODULE) = 'BILLING'
				AND UPPER(A.KEY1) = 'INVOICE'
				AND UPPER(A.KEY2) = 'E-MAIL SENDER'
				AND UPPER(A.KEY3) = '?'
				AND UPPER(SECURITY_CONTROLS.CURRENT_USER) LIKE UPPER(A.SETTING_NAME)
				AND ROWNUM = 1;
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				IF NVL(p_MODEL_ID,0) <> 0 THEN
        			SELECT A.VALUE INTO v_RET
        			FROM SYSTEM_DICTIONARY A
        			WHERE A.MODEL_ID = 0 -- global
        				AND UPPER(A.MODULE) = 'BILLING'
        				AND UPPER(A.KEY1) = 'INVOICE'
        				AND UPPER(A.KEY2) = 'E-MAIL SENDER'
        				AND UPPER(A.KEY3) = '?'
        				AND UPPER(SECURITY_CONTROLS.CURRENT_USER) LIKE UPPER(A.SETTING_NAME)
        				AND ROWNUM = 1;
				ELSE
					v_RET := NULL;
				END IF;
		END;
	END IF;

	RETURN v_RET;

EXCEPTION
	WHEN OTHERS THEN
		RETURN NULL;
END GET_SENDER_ADDRESS;
---------------------------------------------------------------------------------------------------
PROCEDURE SEND_EMAILS
	(
	p_CALLING_MODULE IN VARCHAR2,
	p_MODEL_ID IN NUMBER,
	p_WORK_ID IN NUMBER
	) AS

v_GROUPING VARCHAR2(128);
v_PREV_RECIPIENT NUMBER := 0;
v_B64ENCODED BOOLEAN;
v_EMAIL ML.EMAIL_REC;
v_DOMAIN_ID NUMBER;
v_SUBJECT VARCHAR2(512);
v_SENDER VARCHAR2(512);
v_IDs ID_TABLE;
v_IDX BINARY_INTEGER;

CURSOR c_RECIPIENTS IS
	SELECT DISTINCT D.EMAIL_ADDRESS
	FROM RTO_WORK A,
		CATEGORY B,
		ENTITY_DOMAIN_CONTACT C,
		CONTACT D
	WHERE A.WORK_ID = p_WORK_ID
		AND UPPER(B.CATEGORY_NAME) LIKE 'INVOICE RECIPIENT%'
		AND C.ENTITY_DOMAIN_ID = v_DOMAIN_ID
		AND C.OWNER_ENTITY_ID = A.WORK_XID
		AND C.CATEGORY_ID = B.CATEGORY_ID
		AND D.CONTACT_ID = C.CONTACT_ID
		AND NVL(D.EMAIL_ADDRESS,'?') <> '?'
	ORDER BY 1;

CURSOR c_ENTITIES IS
	SELECT A.WORK_XID "ENTITY_ID",
		COUNT(D.EMAIL_ADDRESS)
	FROM RTO_WORK A,
		CATEGORY B,
		ENTITY_DOMAIN_CONTACT C,
		CONTACT D
	WHERE A.WORK_ID = p_WORK_ID
		AND UPPER(B.CATEGORY_NAME) LIKE 'INVOICE RECIPIENT%'
		AND C.ENTITY_DOMAIN_ID = v_DOMAIN_ID
		AND C.OWNER_ENTITY_ID = A.WORK_XID
		AND C.CATEGORY_ID = B.CATEGORY_ID
		AND D.CONTACT_ID = C.CONTACT_ID
		AND NVL(D.EMAIL_ADDRESS,'?') <> '?'
	GROUP BY A.WORK_XID
	HAVING COUNT(D.EMAIL_ADDRESS) > 0;

CURSOR c_RECIPIENTS_FOR_ENTITY(p_ENTITY_ID IN NUMBER) IS
	SELECT DISTINCT D.EMAIL_ADDRESS
	FROM CATEGORY B,
		ENTITY_DOMAIN_CONTACT C,
		CONTACT D
	WHERE UPPER(B.CATEGORY_NAME) LIKE 'INVOICE RECIPIENT%'
		AND C.ENTITY_DOMAIN_ID = v_DOMAIN_ID
		AND C.OWNER_ENTITY_ID = p_ENTITY_ID
		AND C.CATEGORY_ID = B.CATEGORY_ID
		AND D.CONTACT_ID = C.CONTACT_ID
		AND NVL(D.EMAIL_ADDRESS,'?') <> '?'
	ORDER BY 1;

BEGIN
	v_GROUPING := GET_DICTIONARY_VALUE('E-mail Grouping', p_MODEL_ID, 'Billing', 'Invoice', '?', '?', 0);

	v_DOMAIN_ID := CASE UPPER(SUBSTR(p_CALLING_MODULE,1,1))
					WHEN g_SCHEDULING THEN
						-160 -- PSE
					WHEN g_GAS_DELIVERY THEN
						-230 -- POOL
					WHEN g_POSITION_AND_BILLING THEN
						-250 -- BILL_PARTY
					END;
	v_SUBJECT := GET_DICTIONARY_VALUE('E-mail Subject', p_MODEL_ID, 'Billing', 'Invoice', '?', '?', 0);
	v_SENDER := GET_SENDER_ADDRESS(p_MODEL_ID);

	IF UPPER(v_GROUPING) = 'BY RECIPIENT' THEN
		-- This means of grouping sends one e-mail per recipient and gathers all bills together
		-- on it. This would be the preferred setting in cases where certain recipient receive
		-- bills for multiple entities, and they would prefer to receive a single e-mail with all
		-- bills vs. one e-mail per bill.

		FOR v_RECIPIENT IN c_RECIPIENTS LOOP

			v_EMAIL := ML.BEGIN_MAIL('Send Invoice', v_SENDER, v_SUBJECT, v_RECIPIENT.EMAIL_ADDRESS);

			SELECT ID_TYPE(A.ENTITY_ID)
			BULK COLLECT INTO v_IDs
			FROM (SELECT DISTINCT A.WORK_XID "ENTITY_ID"
				FROM RTO_WORK A,
					CATEGORY B,
					ENTITY_DOMAIN_CONTACT C,
					CONTACT D
				WHERE A.WORK_ID = p_WORK_ID
					AND UPPER(B.CATEGORY_NAME) LIKE 'INVOICE RECIPIENT%'
					AND C.ENTITY_DOMAIN_ID = v_DOMAIN_ID
					AND C.OWNER_ENTITY_ID = A.WORK_XID
					AND C.CATEGORY_ID = B.CATEGORY_ID
					AND D.CONTACT_ID = C.CONTACT_ID
					AND NVL(D.EMAIL_ADDRESS,'?') = v_RECIPIENT.EMAIL_ADDRESS) A;

			ADD_MESSAGE_BODY (p_CALLING_MODULE, p_MODEL_ID, v_IDs, v_EMAIL);

			v_IDX := v_IDs.FIRST;
			WHILE v_IDs.EXISTS(v_IDX) LOOP
				ADD_EMAIL_FILES_FOR_ENTITY (v_IDs(v_IDX).ID, p_WORK_ID, v_EMAIL);
				v_IDX := v_IDs.NEXT(v_IDX);
			END LOOP;

			ADD_EXTRA_ATTACHMENTS (p_CALLING_MODULE, p_MODEL_ID, v_IDs, v_EMAIL);

			ML.END_MAIL(v_EMAIL, FALSE);

		END LOOP;

	ELSE -- 'BY ENTITY'
		-- This means of grouping sends one e-mail per bill entity - and sends it to all
		-- applicable recipients. This is the default setting.

		FOR v_ENTITY IN c_ENTITIES LOOP

			v_EMAIL := ML.BEGIN_MAIL('Send Invoice', v_SENDER, v_SUBJECT);

			FOR v_RECIPIENT IN c_RECIPIENTS_FOR_ENTITY(v_ENTITY.ENTITY_ID) LOOP
				ML.ADD_RECIPIENT(v_EMAIL, v_RECIPIENT.EMAIL_ADDRESS);
			END LOOP;
			v_IDs := ID_TABLE();
			v_IDs.EXTEND;
			v_IDs(v_IDs.LAST) := ID_TYPE(v_ENTITY.ENTITY_ID);

			ADD_MESSAGE_BODY (p_CALLING_MODULE, p_MODEL_ID, v_IDs, v_EMAIL);
			ADD_EMAIL_FILES_FOR_ENTITY (v_ENTITY.ENTITY_ID, p_WORK_ID, v_EMAIL);
			ADD_EXTRA_ATTACHMENTS (p_CALLING_MODULE, p_MODEL_ID, v_IDs, v_EMAIL);

			ML.END_MAIL(v_EMAIL, FALSE);

		END LOOP;
	END IF;

	-- now send all of the e-mails at once
	ML.PROCESS_ALL_PENDING;

END SEND_EMAILS;
---------------------------------------------------------------------------------------------------
FUNCTION GET_SENT_STATUS
	(
	p_MODEL_ID IN NUMBER,
	p_OLD_STATUS IN VARCHAR2
	) RETURN VARCHAR2 IS
v_NEW_STATUS VARCHAR2(128);
BEGIN
	SELECT VALUE INTO v_NEW_STATUS
	FROM SYSTEM_LABEL
	WHERE MODEL_ID = p_MODEL_ID
		AND UPPER(MODULE) = 'BILLING'
		AND UPPER(KEY1) = 'INVOICE'
		AND UPPER(KEY2) = 'STATUS'
		AND UPPER(KEY3) = '?'
		AND UPPER(VALUE) LIKE UPPER(p_OLD_STATUS)||'%SENT%'
		AND ROWNUM = 1;

	RETURN v_NEW_STATUS;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
		-- try global model ID
		IF NVL(p_MODEL_ID,0) <> 0 THEN
			RETURN GET_SENT_STATUS (0, p_OLD_STATUS);
		ELSE
			RETURN NULL;
		END IF;
END GET_SENT_STATUS;
---------------------------------------------------------------------------------------------------
PROCEDURE UPDATE_INVOICE_STATUS_SENT
	(
	p_CALLING_MODULE IN VARCHAR2,
	p_MODEL_ID IN NUMBER,
	p_INVOICE_ID IN NUMBER
	) AS
v_OLD_STATUS VARCHAR2(128);
v_NEW_STATUS VARCHAR2(128);
BEGIN
	SELECT A.INVOICE_STATUS INTO v_OLD_STATUS
	FROM INVOICE A
	WHERE INVOICE_ID = p_INVOICE_ID;

	v_NEW_STATUS := GET_SENT_STATUS(p_MODEL_ID, v_OLD_STATUS);

	IF v_NEW_STATUS IS NULL THEN
		RETURN;
	ELSE
		UPDATE INVOICE SET INVOICE_STATUS = v_NEW_STATUS
		WHERE INVOICE_ID = p_INVOICE_ID;
	END IF;

END UPDATE_INVOICE_STATUS_SENT;
---------------------------------------------------------------------------------------------------
END BS;
/
