CREATE OR REPLACE PACKAGE BODY QC AS
---------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
    RETURN '$Revision: 1.1 $';
END WHAT_VERSION;
----------------------------------------------------------------------------------------------------
FUNCTION MODULE_FOR_REQUEST_TYPE
	(
	p_REQUEST_TYPE IN CHAR
	)  RETURN VARCHAR IS

v_MODULE_NAME VARCHAR(16);

BEGIN

	SELECT DECODE(UPPER(SUBSTR(p_REQUEST_TYPE,1,1)),
		'F','FORECASTING',
		'B','SETTLEMENT',
		'U','SETTLEMENT',
		g_WILD_CARD,'SETTLEMENT',
		'FORECASTING') INTO v_MODULE_NAME FROM DUAL;
    RETURN v_MODULE_NAME;

END MODULE_FOR_REQUEST_TYPE;
---------------------------------------------------------------------------------------------------
FUNCTION SERVICE_IS_VERSIONED
	(
	p_REQUEST_TYPE IN CHAR
	)  RETURN BOOLEAN IS

-- Answer True if the Service is versioned for the specified request type; otherwise answer False.

BEGIN

	RETURN ((p_REQUEST_TYPE = GA.FORECAST_SERVICE AND GA.VERSION_FORECAST)
		OR (p_REQUEST_TYPE = GA.BACKCAST_SERVICE AND GA.VERSION_BACKCAST)
		OR (p_REQUEST_TYPE = GA.ACTUAL_SERVICE AND GA.VERSION_ACTUAL));

END SERVICE_IS_VERSIONED;
---------------------------------------------------------------------------------------------------
FUNCTION AS_OF_DATE_FOR_REQUEST
	(
	p_REQUEST_TYPE IN CHAR,
	p_AS_OF_DATE IN DATE
	)  RETURN DATE IS

-- Answer the Version As Of Date for this request.
v_VERSION_DOMAIN VARCHAR(32);
BEGIN

	SELECT DECODE(UPPER(SUBSTR(p_REQUEST_TYPE,1,1)),
		GA.FORECAST_SERVICE,'Forecast',
		GA.BACKCAST_SERVICE,'Backcast',
		GA.ACTUAL_SERVICE,'Usage Allocation',
		--g_WILD_CARD,'Usage Allocation',
		'Forecast') INTO v_VERSION_DOMAIN FROM DUAL;

	IF SERVICE_IS_VERSIONED(p_REQUEST_TYPE) THEN
		RETURN CORRECTED_AS_OF_DATE(p_AS_OF_DATE, v_VERSION_DOMAIN);
	ELSE
		RETURN LOW_DATE;
	END IF;

END AS_OF_DATE_FOR_REQUEST;
---------------------------------------------------------------------------------------------------
FUNCTION IS_VERSIONED_REQUEST
	(
	p_REQUEST_TYPE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE
	)  RETURN BOOLEAN IS

-- Answer True if the request is for versioned data; otherwise answer False.

BEGIN

	RETURN (SERVICE_IS_VERSIONED(p_REQUEST_TYPE) AND p_AS_OF_DATE = CURRENT_VERSION_DATE AND NOT TRUNC(p_BEGIN_DATE) = TRUNC(p_END_DATE));

END IS_VERSIONED_REQUEST;
---------------------------------------------------------------------------------------------------
FUNCTION GET_SERVICE_LOCATION_ID
	(
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_DATE IN DATE
	) RETURN NUMBER IS

-- Answer the account service location id and service point id assignment for the specified day
-- Answer CONSTANTS.NOT_ASSIGNED when there is not an assigned service location

v_SERVICE_LOCATION_ID NUMBER;

BEGIN

	SELECT SERVICE_LOCATION_ID
	INTO v_SERVICE_LOCATION_ID
	FROM ACCOUNT_SERVICE_LOCATION
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND p_SERVICE_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE)
		AND ROWNUM = 1;

	RETURN v_SERVICE_LOCATION_ID;

 	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN CONSTANTS.NOT_ASSIGNED;

END GET_SERVICE_LOCATION_ID;
----------------------------------------------------------------------------------------------------
FUNCTION IS_CACHED_USAGE
	(
	p_ACCOUNT_ID IN NUMBER
	) RETURN BOOLEAN IS

-- Answer TRUE if the account has external interval usage.

v_IS_EXTERNAL_INTERVAL_USAGE NUMBER(1);
v_IS_AGGREGATE_ACCOUNT NUMBER(1);
v_ACCOUNT_METER_TYPE CHAR(1);
v_DATE DATE := TRUNC(SYSDATE);
BEGIN

	SELECT IS_EXTERNAL_INTERVAL_USAGE, IS_AGGREGATE_ACCOUNT, UPPER(SUBSTR(ACCOUNT_METER_TYPE,1,1))
	INTO v_IS_EXTERNAL_INTERVAL_USAGE, v_IS_AGGREGATE_ACCOUNT, v_ACCOUNT_METER_TYPE
	FROM ACCOUNT A, ACCOUNT_STATUS B, ACCOUNT_STATUS_NAME STATUS_NAME
	WHERE B.ACCOUNT_ID = A.ACCOUNT_ID
		AND v_DATE BETWEEN B.BEGIN_DATE AND NVL(B.END_DATE, v_DATE)
		AND STATUS_NAME.STATUS_NAME = B.STATUS_NAME
		AND STATUS_NAME.IS_ACTIVE = 1
		AND A.ACCOUNT_ID = p_ACCOUNT_ID;

	RETURN (v_IS_EXTERNAL_INTERVAL_USAGE = 1 AND v_IS_AGGREGATE_ACCOUNT = 0 AND v_ACCOUNT_METER_TYPE = 'I');

 	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN FALSE;

END IS_CACHED_USAGE;
----------------------------------------------------------------------------------------------------
PROCEDURE NULL_CURSOR
    (
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
		SELECT NULL FROM DUAL;

END NULL_CURSOR;
----------------------------------------------------------------------------------------------------
FUNCTION TAG_INDEX_LOOKUP
	(
	p_TAG IN NUMBER,
	p_TAG_INDEX IN OUT NOCOPY GA.NUMBER_TABLE
	)  RETURN BINARY_INTEGER IS

v_INDEX BINARY_INTEGER;

BEGIN

-- Lookup the specified tag in the collection of tags and answer the index within the table.
	v_INDEX := p_TAG_INDEX.FIRST;
	WHILE v_INDEX <= p_TAG_INDEX.LAST LOOP
		IF p_TAG = p_TAG_INDEX(v_INDEX) THEN
			RETURN v_INDEX;
		END IF;
		v_INDEX := p_TAG_INDEX.NEXT(v_INDEX);
	END LOOP;

-- No tag found so add it to the index table.
	p_TAG_INDEX(p_TAG_INDEX.COUNT + 1) := p_TAG;
	RETURN p_TAG_INDEX.COUNT;

END TAG_INDEX_LOOKUP;
---------------------------------------------------------------------------------------------------
FUNCTION GET_SCENARIO_RUN_MODE
	(
	p_SCENARIO_ID IN NUMBER
	)  RETURN NUMBER IS

v_RUN_MODE NUMBER(1);

BEGIN

	SELECT NVL(RUN_MODE, GA.HOUR_MODE)
	INTO v_RUN_MODE
	FROM LOAD_FORECAST_SCENARIO
	WHERE SCENARIO_ID = p_SCENARIO_ID;

	RETURN v_RUN_MODE;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN GA.HOUR_MODE;

END GET_SCENARIO_RUN_MODE;
---------------------------------------------------------------------------------------------------
PROCEDURE SET_DISPLAY_PREFERENCES
    (
	p_DISPLAY_PREFERENCE IN VARCHAR,
	p_EDC IN OUT NUMBER,
	p_PSE IN OUT NUMBER,
	p_ESP IN OUT NUMBER,
	p_POOL IN OUT NUMBER
	) AS

BEGIN

	SELECT DECODE(INSTR(UPPER(p_DISPLAY_PREFERENCE), 'EDC'),0,0,1) INTO p_EDC FROM DUAL;
	SELECT DECODE(INSTR(UPPER(p_DISPLAY_PREFERENCE), 'PSE'),0,0,1) INTO p_PSE FROM DUAL;
	SELECT DECODE(INSTR(UPPER(p_DISPLAY_PREFERENCE), 'ESP'),0,0,1) INTO p_ESP FROM DUAL;
	SELECT DECODE(INSTR(UPPER(p_DISPLAY_PREFERENCE), 'POOL'),0,0,1) INTO p_POOL FROM DUAL;

END SET_DISPLAY_PREFERENCES;
---------------------------------------------------------------------------------------------------
PROCEDURE REPLICATE_WEEKLY_USAGE
	(
	p_SOURCE IN SERVICE_USAGE_TYPE,
	p_TARGET IN OUT NOCOPY SERVICE_USAGE_TABLE
	) AS

v_DAY NUMBER(2);
v_INDEX BINARY_INTEGER;

BEGIN

	IF p_SOURCE.USAGE_CODE = GA.WEEK_DAY THEN -- Weekday
		v_DAY := 4;
	ELSIF p_SOURCE.USAGE_CODE = GA.WEEK_END THEN -- Weekend
		v_DAY := 1;
	END IF;

	FOR v_INDEX IN 0..v_DAY LOOP
		p_TARGET.EXTEND;
		p_TARGET(p_TARGET.LAST) := SERVICE_USAGE_TYPE(p_SOURCE.SERVICE_ID, GA.STANDARD, p_SOURCE.USAGE_DATE + v_INDEX, p_SOURCE.USAGE_VAL);
	END LOOP;

END REPLICATE_WEEKLY_USAGE;
---------------------------------------------------------------------------------------------------
PROCEDURE REPLICATE_MONTHLY_USAGE
	(
	p_SOURCE IN SERVICE_USAGE_TYPE,
	p_TARGET IN OUT NOCOPY SERVICE_USAGE_TABLE
	) AS

v_DAY NUMBER(2);
v_DATE DATE;
v_INDEX BINARY_INTEGER;
v_WEEKEND BOOLEAN;

BEGIN

	v_DAY := TO_NUMBER(TO_CHAR(LAST_DAY(FROM_CUT(p_SOURCE.USAGE_DATE, GA.LOCAL_TIME_ZONE)),'DD'));

	FOR v_INDEX IN 0..v_DAY - 1 LOOP
		v_DATE := p_SOURCE.USAGE_DATE + v_INDEX;
		v_WEEKEND := TO_CHAR(FROM_CUT(v_DATE, GA.LOCAL_TIME_ZONE),'DY') IN ('SA','SU');
		IF (v_WEEKEND AND p_SOURCE.USAGE_CODE = GA.WEEK_END) OR (NOT v_WEEKEND AND p_SOURCE.USAGE_CODE = GA.WEEK_DAY) THEN
		p_TARGET.EXTEND;
		p_TARGET(p_TARGET.LAST) := SERVICE_USAGE_TYPE(p_SOURCE.SERVICE_ID, GA.STANDARD, p_SOURCE.USAGE_DATE + v_INDEX, p_SOURCE.USAGE_VAL);
		END IF;
	END LOOP;

END REPLICATE_MONTHLY_USAGE;
---------------------------------------------------------------------------------------------------
PROCEDURE REPLICATE_USAGE
	(
	p_RUN_MODE IN NUMBER,
	p_SOURCE IN SERVICE_USAGE_TABLE,
	p_TARGET IN OUT NOCOPY SERVICE_USAGE_TABLE
	) AS

v_INDEX BINARY_INTEGER;

BEGIN

	IF p_RUN_MODE = GA.WEEK_MODE THEN
		v_INDEX := p_SOURCE.FIRST;
		WHILE v_INDEX <= p_SOURCE.LAST LOOP
			REPLICATE_WEEKLY_USAGE(p_SOURCE(v_INDEX), p_TARGET);
			v_INDEX := p_SOURCE.NEXT(v_INDEX);
		END LOOP;
	ELSIF p_RUN_MODE = GA.MONTH_MODE THEN
		v_INDEX := p_SOURCE.FIRST;
		WHILE v_INDEX <= p_SOURCE.LAST LOOP
			REPLICATE_MONTHLY_USAGE(p_SOURCE(v_INDEX), p_TARGET);
			v_INDEX := p_SOURCE.NEXT(v_INDEX);
		END LOOP;
	END IF;

END REPLICATE_USAGE;
---------------------------------------------------------------------------------------------------
PROCEDURE IN_FILL_AGGREGATE_ENROLLMENT
    (
	p_CASE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS

-- Insert zero fill records for an aggregate accounts assigned to an ESP over the time period.

CURSOR c_AGGREGATE IS
    SELECT AGGREGATE_ID
	FROM AGGREGATE_ACCOUNT_ESP A
	WHERE (p_ESP_ID = CONSTANTS.ALL_ID OR ESP_ID = p_ESP_ID)
	    AND NOT EXISTS
		    (
			SELECT SERVICE_ACCOUNTS
			FROM AGGREGATE_ACCOUNT_SERVICE B
			WHERE B.CASE_ID = p_CASE_ID
				AND B.AGGREGATE_ID = A.AGGREGATE_ID
			    AND B.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
			);

v_SERVICE_DATE DATE;
v_COUNT NUMBER;
v_AS_OF_DATE DATE;

BEGIN

    IF GA.VERSION_AGGREGATE_ACCOUNT_SVC = FALSE THEN
    	    v_AS_OF_DATE := LOW_DATE;
    ELSE
	    v_AS_OF_DATE := CORRECTED_AS_OF_DATE(p_AS_OF_DATE);
    END IF;

	FOR v_AGGREGATE IN c_AGGREGATE LOOP
		v_SERVICE_DATE := TRUNC(p_BEGIN_DATE);
		WHILE v_SERVICE_DATE <= TRUNC(p_END_DATE) LOOP
		    SELECT COUNT(*)
			INTO v_COUNT
			FROM AGGREGATE_ACCOUNT_SERVICE
			WHERE CASE_ID = p_CASE_ID
				AND AGGREGATE_ID = v_AGGREGATE.AGGREGATE_ID
				AND SERVICE_DATE = v_SERVICE_DATE;
			IF v_COUNT = 0 THEN
			    INSERT INTO AGGREGATE_ACCOUNT_SERVICE(
				 	CASE_ID,
				   AGGREGATE_ID,
					SERVICE_DATE,
					AS_OF_DATE,
					SERVICE_ACCOUNTS)
				VALUES(
					p_CASE_ID,
				   v_AGGREGATE.AGGREGATE_ID,
					v_SERVICE_DATE,
					v_AS_OF_DATE,
					0);
			END IF;
			v_SERVICE_DATE := v_SERVICE_DATE + 1;
		END LOOP;
	END LOOP;

    p_STATUS := GA.SUCCESS;
END IN_FILL_AGGREGATE_ENROLLMENT;
---------------------------------------------------------------------------------------------------
PROCEDURE TREE_BRANCHES_ACCOUNT
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_DISPLAY_PREFERENCE IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SORT_PREFERENCE IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the EDC-PSE-ESP relationships
-- p_SORT_PREFERENCE only code 2 supported here - Missing Values; Otherwise Alpha Sort

v_EDC NUMBER(1);
v_PSE NUMBER(1);
v_ESP NUMBER(1);
v_POOL NUMBER(1);
v_AS_OF_DATE DATE;
v_REQUEST_TYPE CHAR(1) :=  UPPER(SUBSTR(p_REQUEST_TYPE,1,1));

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;
	v_AS_OF_DATE := AS_OF_DATE_FOR_REQUEST(v_REQUEST_TYPE, p_AS_OF_DATE);

	SET_DISPLAY_PREFERENCES(p_DISPLAY_PREFERENCE, v_EDC, v_PSE, v_ESP, v_POOL);

	IF IS_VERSIONED_REQUEST(v_REQUEST_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) THEN
		IF v_REQUEST_TYPE = g_WILD_CARD THEN
		 --OR STATEMENT WAS CAUSING FULL TABLE SCAN.  THIS SECTION IS CALLED FROM COMPARISON.
			OPEN p_CURSOR FOR
				SELECT DECODE(v_EDC,1, B.EDC_ID, CONSTANTS.NOT_ASSIGNED) "EDC_ID",
					DECODE(v_EDC, 1, B.EDC_NAME, NULL) "EDC_NAME",
					DECODE(v_PSE, 1, C.PSE_ID, CONSTANTS.NOT_ASSIGNED) "PSE_ID",
					DECODE(v_PSE, 1, C.PSE_NAME, NULL) "PSE_NAME",
					DECODE(v_ESP, 1, D.ESP_ID, CONSTANTS.NOT_ASSIGNED) "ESP_ID",
					DECODE(v_ESP, 1, D.ESP_NAME, NULL) "ESP_NAME",
					DECODE(v_POOL, 1, E.POOL_ID, CONSTANTS.NOT_ASSIGNED) "POOL_ID",
					DECODE(v_POOL, 1, E.POOL_NAME, NULL) "POOL_NAME",
					DECODE(p_SORT_PREFERENCE,2,-A.PROFILE_ZERO_COUNT,0) "SORT_PREFERENCE"
				FROM
					(SELECT B.EDC_ID, B.PSE_ID, B.ESP_ID, C.POOL_ID, SUM(D.PROFILE_ZERO_COUNT) "PROFILE_ZERO_COUNT"
					FROM SERVICE A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, SERVICE_STATE D
					WHERE A.MODEL_ID = p_MODEL_ID
						AND A.SCENARIO_ID = p_SCENARIO_ID
						AND A.AS_OF_DATE =
							(SELECT MAX(AS_OF_DATE)
							FROM SERVICE
							WHERE MODEL_ID = A.MODEL_ID
								AND SCENARIO_ID = p_SCENARIO_ID
								AND ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
								AND PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
								AND SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
								AND AS_OF_DATE <= v_AS_OF_DATE)
						AND B.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
						AND A.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
						AND C.SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
						AND D.SERVICE_ID = A.SERVICE_ID
						AND D.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
					GROUP BY B.EDC_ID, B.PSE_ID, B.ESP_ID, C.POOL_ID)  A,
				    ENERGY_DISTRIBUTION_COMPANY B,
					PURCHASING_SELLING_ENTITY C,
					ENERGY_SERVICE_PROVIDER D,
					POOL E
				WHERE B.EDC_ID = A.EDC_ID
				    AND C.PSE_ID = A.PSE_ID
					AND D.ESP_ID = A.ESP_ID
					AND E.POOL_ID = A.POOL_ID
					ORDER BY 9,2,4,6,8;
		ELSE
			OPEN p_CURSOR FOR
				SELECT DECODE(v_EDC,1, B.EDC_ID, CONSTANTS.NOT_ASSIGNED) "EDC_ID",
					DECODE(v_EDC, 1, B.EDC_NAME, NULL) "EDC_NAME",
					DECODE(v_PSE, 1, C.PSE_ID, CONSTANTS.NOT_ASSIGNED) "PSE_ID",
					DECODE(v_PSE, 1, C.PSE_NAME, NULL) "PSE_NAME",
					DECODE(v_ESP, 1, D.ESP_ID, CONSTANTS.NOT_ASSIGNED) "ESP_ID",
					DECODE(v_ESP, 1, D.ESP_NAME, NULL) "ESP_NAME",
					DECODE(v_POOL, 1, E.POOL_ID, CONSTANTS.NOT_ASSIGNED) "POOL_ID",
					DECODE(v_POOL, 1, E.POOL_NAME, NULL) "POOL_NAME",
					DECODE(p_SORT_PREFERENCE,2,-A.PROFILE_ZERO_COUNT,0) "SORT_PREFERENCE"
				FROM
					(SELECT B.EDC_ID, B.PSE_ID, B.ESP_ID, C.POOL_ID, SUM(D.PROFILE_ZERO_COUNT) "PROFILE_ZERO_COUNT"
					FROM SERVICE A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, SERVICE_STATE D
					WHERE A.MODEL_ID = p_MODEL_ID
						AND A.SCENARIO_ID = p_SCENARIO_ID
						AND A.AS_OF_DATE =
							(SELECT MAX(AS_OF_DATE)
							FROM SERVICE
							WHERE MODEL_ID = A.MODEL_ID
								AND SCENARIO_ID = p_SCENARIO_ID
								AND ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
								AND PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
								AND SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
								AND AS_OF_DATE <= v_AS_OF_DATE)
						AND B.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
						AND A.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
						AND C.SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
						AND D.SERVICE_ID = A.SERVICE_ID
						AND v_REQUEST_TYPE = D.SERVICE_CODE
						AND D.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
					GROUP BY B.EDC_ID, B.PSE_ID, B.ESP_ID, C.POOL_ID)  A,
				    ENERGY_DISTRIBUTION_COMPANY B,
					PURCHASING_SELLING_ENTITY C,
					ENERGY_SERVICE_PROVIDER D,
					POOL E
				WHERE B.EDC_ID = A.EDC_ID
				    AND C.PSE_ID = A.PSE_ID
					AND D.ESP_ID = A.ESP_ID
					AND E.POOL_ID = A.POOL_ID
					ORDER BY 9,2,4,6,8;
		END IF;
	ELSE
		 --OR STATEMENT WAS CAUSING FULL TABLE SCAN.  THIS SECTION IS CALLED FROM COMPARISON.
		IF v_REQUEST_TYPE = g_WILD_CARD THEN
			OPEN p_CURSOR FOR
				SELECT DECODE(v_EDC,1, B.EDC_ID, CONSTANTS.NOT_ASSIGNED) "EDC_ID",
					DECODE(v_EDC, 1, B.EDC_NAME, NULL) "EDC_NAME",
					DECODE(v_PSE, 1, C.PSE_ID, CONSTANTS.NOT_ASSIGNED) "PSE_ID",
					DECODE(v_PSE, 1, C.PSE_NAME, NULL) "PSE_NAME",
					DECODE(v_ESP, 1, D.ESP_ID, CONSTANTS.NOT_ASSIGNED) "ESP_ID",
					DECODE(v_ESP, 1, D.ESP_NAME, NULL) "ESP_NAME",
					DECODE(v_POOL, 1, E.POOL_ID, CONSTANTS.NOT_ASSIGNED) "POOL_ID",
					DECODE(v_POOL, 1, E.POOL_NAME, NULL) "POOL_NAME",
					DECODE(p_SORT_PREFERENCE,2,-A.PROFILE_ZERO_COUNT,0) "SORT_PREFERENCE"
				FROM
					(SELECT B.EDC_ID, B.PSE_ID, B.ESP_ID, C.POOL_ID, SUM(D.PROFILE_ZERO_COUNT) "PROFILE_ZERO_COUNT"
					FROM SERVICE A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, SERVICE_STATE D
					WHERE A.MODEL_ID = p_MODEL_ID
						AND A.SCENARIO_ID = p_SCENARIO_ID
						AND A.AS_OF_DATE = v_AS_OF_DATE
						AND B.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
						AND A.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
						AND C.SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
						AND D.SERVICE_ID = A.SERVICE_ID
						AND D.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
					GROUP BY B.EDC_ID, B.PSE_ID, B.ESP_ID, C.POOL_ID)  A,
				    ENERGY_DISTRIBUTION_COMPANY B,
					PURCHASING_SELLING_ENTITY C,
					ENERGY_SERVICE_PROVIDER D,
					POOL E
				WHERE B.EDC_ID = A.EDC_ID
				    AND C.PSE_ID = A.PSE_ID
					AND D.ESP_ID = A.ESP_ID
					AND E.POOL_ID = A.POOL_ID
					ORDER BY 9,2,4,6,8;
		ELSE
			OPEN p_CURSOR FOR
				SELECT DECODE(v_EDC,1, B.EDC_ID, CONSTANTS.NOT_ASSIGNED) "EDC_ID",
					DECODE(v_EDC, 1, B.EDC_NAME, NULL) "EDC_NAME",
					DECODE(v_PSE, 1, C.PSE_ID, CONSTANTS.NOT_ASSIGNED) "PSE_ID",
					DECODE(v_PSE, 1, C.PSE_NAME, NULL) "PSE_NAME",
					DECODE(v_ESP, 1, D.ESP_ID, CONSTANTS.NOT_ASSIGNED) "ESP_ID",
					DECODE(v_ESP, 1, D.ESP_NAME, NULL) "ESP_NAME",
					DECODE(v_POOL, 1, E.POOL_ID, CONSTANTS.NOT_ASSIGNED) "POOL_ID",
					DECODE(v_POOL, 1, E.POOL_NAME, NULL) "POOL_NAME",
					DECODE(p_SORT_PREFERENCE,2,-A.PROFILE_ZERO_COUNT,0) "SORT_PREFERENCE"
				FROM
					(SELECT B.EDC_ID, B.PSE_ID, B.ESP_ID, C.POOL_ID, SUM(D.PROFILE_ZERO_COUNT) "PROFILE_ZERO_COUNT"
					FROM SERVICE A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, SERVICE_STATE D
					WHERE A.MODEL_ID = p_MODEL_ID
						AND A.SCENARIO_ID = p_SCENARIO_ID
						AND A.AS_OF_DATE = v_AS_OF_DATE
						AND B.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
						AND A.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
						AND C.SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
						AND D.SERVICE_ID = A.SERVICE_ID
						AND D.SERVICE_CODE = v_REQUEST_TYPE
						AND D.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
					GROUP BY B.EDC_ID, B.PSE_ID, B.ESP_ID, C.POOL_ID)  A,
				    ENERGY_DISTRIBUTION_COMPANY B,
					PURCHASING_SELLING_ENTITY C,
					ENERGY_SERVICE_PROVIDER D,
					POOL E
				WHERE B.EDC_ID = A.EDC_ID
				    AND C.PSE_ID = A.PSE_ID
					AND D.ESP_ID = A.ESP_ID
					AND E.POOL_ID = A.POOL_ID
					ORDER BY 9,2,4,6,8;
		END IF;
	END IF;

END TREE_BRANCHES_ACCOUNT;
---------------------------------------------------------------------------------------------------
PROCEDURE TREE_BRANCHES_ENROLLMENT
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_DISPLAY_PREFERENCE IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_INCLUDE_STANDARD_OFFER IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the EDC-PSE-ESP relationships for Enrollment

v_BEGIN_DATE DATE := TRUNC(p_BEGIN_DATE);
v_END_DATE DATE := TRUNC(p_END_DATE);
v_EDC NUMBER(1);
v_PSE NUMBER(1);
v_ESP NUMBER(1);
v_POOL NUMBER(1);
v_ESP_TYPE CHAR(1);

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;

	SET_DISPLAY_PREFERENCES(p_DISPLAY_PREFERENCE, v_EDC, v_PSE, v_ESP, v_POOL);
	SELECT DECODE(p_INCLUDE_STANDARD_OFFER,0,'S','@') INTO v_ESP_TYPE FROM DUAL;

	OPEN p_CURSOR FOR
		SELECT DECODE(v_EDC,1, B.EDC_ID, CONSTANTS.NOT_ASSIGNED) "EDC_ID",
		    DECODE(v_EDC, 1, B.EDC_NAME, NULL) "EDC_NAME",
			DECODE(v_PSE, 1, C.PSE_ID, CONSTANTS.NOT_ASSIGNED) "PSE_ID",
		    DECODE(v_PSE, 1, C.PSE_NAME, NULL) "PSE_NAME",
			DECODE(v_ESP, 1, D.ESP_ID, CONSTANTS.NOT_ASSIGNED) "ESP_ID",
			DECODE(v_ESP, 1, D.ESP_NAME, NULL) "ESP_NAME",
			DECODE(v_POOL, 1, E.POOL_ID, CONSTANTS.NOT_ASSIGNED) "POOL_ID",
			DECODE(v_POOL, 1, E.POOL_NAME, NULL) "POOL_NAME"
		FROM
			(SELECT DISTINCT EDC_ID, PSE_ID, ESP_ID, POOL_ID
			FROM ACCOUNT_ENROLLMENT_TREE
			WHERE EDC_BEGIN_DATE <= v_END_DATE AND NVL(EDC_END_DATE, v_END_DATE) >= v_BEGIN_DATE
				AND ESP_BEGIN_DATE <= v_END_DATE AND NVL(ESP_END_DATE, v_END_DATE) >= v_BEGIN_DATE
				AND PSE_BEGIN_DATE <= v_END_DATE AND NVL(PSE_END_DATE, v_END_DATE) >= v_BEGIN_DATE)  A,
			ENERGY_DISTRIBUTION_COMPANY B,
			PURCHASING_SELLING_ENTITY C,
			ENERGY_SERVICE_PROVIDER D,
			POOL E
		WHERE B.EDC_ID = A.EDC_ID
			AND C.PSE_ID = A.PSE_ID
			AND D.ESP_ID = A.ESP_ID
			AND NOT UPPER(SUBSTR(D.ESP_TYPE,1,1)) = v_ESP_TYPE
			AND E.POOL_ID = A.POOL_ID
		ORDER BY 2,4,6,8;

END TREE_BRANCHES_ENROLLMENT;
---------------------------------------------------------------------------------------------------
PROCEDURE TREE_BRANCHES_ANCILLARY
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_DISPLAY_PREFERENCE IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	  TREE_BRANCHES_ENROLLMENT(p_REQUEST_TYPE,p_MODEL_ID,p_SCENARIO_ID,p_DISPLAY_PREFERENCE,p_BEGIN_DATE,p_END_DATE,p_AS_OF_DATE,1,p_STATUS,p_CURSOR);

END TREE_BRANCHES_ANCILLARY;
---------------------------------------------------------------------------------------------------
PROCEDURE TREE_BRANCHES_COMPARISON
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_DISPLAY_PREFERENCE IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the EDC-PSE-ESP relationships

v_EDC NUMBER(1);
v_PSE NUMBER(1);
v_ESP NUMBER(1);
v_POOL NUMBER(1);
v_REQUEST_TYPE CHAR(1) :=  UPPER(SUBSTR(p_REQUEST_TYPE,1,1));
v_AS_OF_DATE DATE;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;
	v_AS_OF_DATE := AS_OF_DATE_FOR_REQUEST('U', p_AS_OF_DATE);

	SET_DISPLAY_PREFERENCES(p_DISPLAY_PREFERENCE, v_EDC, v_PSE, v_ESP, v_POOL);

	IF IS_VERSIONED_REQUEST(v_REQUEST_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) THEN
		OPEN p_CURSOR FOR
			SELECT DECODE(v_EDC,1, B.EDC_ID, CONSTANTS.NOT_ASSIGNED) "EDC_ID",
				DECODE(v_EDC, 1, B.EDC_NAME, NULL) "EDC_NAME",
				DECODE(v_PSE, 1, C.PSE_ID, CONSTANTS.NOT_ASSIGNED) "PSE_ID",
				DECODE(v_PSE, 1, C.PSE_NAME, NULL) "PSE_NAME",
				DECODE(v_ESP, 1, D.ESP_ID, CONSTANTS.NOT_ASSIGNED) "ESP_ID",
				DECODE(v_ESP, 1, D.ESP_NAME, NULL) "ESP_NAME",
				DECODE(v_POOL, 1, E.POOL_ID, CONSTANTS.NOT_ASSIGNED) "POOL_ID",
				DECODE(v_POOL, 1, E.POOL_NAME, NULL) "POOL_NAME"
			FROM
				(SELECT DISTINCT B.EDC_ID, B.PSE_ID, B.ESP_ID, C.POOL_ID
				FROM SERVICE A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, SERVICE_STATE D
				WHERE A.MODEL_ID = p_MODEL_ID
					AND A.SCENARIO_ID = p_SCENARIO_ID
					AND A.AS_OF_DATE =
						(SELECT MAX(AS_OF_DATE)
						FROM SERVICE
						WHERE MODEL_ID = A.MODEL_ID
							AND SCENARIO_ID = A.SCENARIO_ID
							AND ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
							AND PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
							AND SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
							AND AS_OF_DATE <= v_AS_OF_DATE)
					AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
					AND A.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
					AND A.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
					AND D.SERVICE_ID = A.SERVICE_ID
					AND D.SERVICE_CODE IN (GA.FORECAST_SERVICE, GA.BACKCAST_SERVICE, GA.ACTUAL_SERVICE)
					AND D.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE))  A,
			    ENERGY_DISTRIBUTION_COMPANY B,
				PURCHASING_SELLING_ENTITY C,
				ENERGY_SERVICE_PROVIDER D,
				POOL E
			WHERE B.EDC_ID = A.EDC_ID
			    AND C.PSE_ID = A.PSE_ID
				AND D.ESP_ID = A.ESP_ID
				AND E.POOL_ID = A.POOL_ID
				ORDER BY 2,4,6,8;
	ELSE
		OPEN p_CURSOR FOR
			SELECT DECODE(v_EDC,1, B.EDC_ID, CONSTANTS.NOT_ASSIGNED) "EDC_ID",
				DECODE(v_EDC, 1, B.EDC_NAME, NULL) "EDC_NAME",
				DECODE(v_PSE, 1, C.PSE_ID, CONSTANTS.NOT_ASSIGNED) "PSE_ID",
				DECODE(v_PSE, 1, C.PSE_NAME, NULL) "PSE_NAME",
				DECODE(v_ESP, 1, D.ESP_ID, CONSTANTS.NOT_ASSIGNED) "ESP_ID",
				DECODE(v_ESP, 1, D.ESP_NAME, NULL) "ESP_NAME",
				DECODE(v_POOL, 1, E.POOL_ID, CONSTANTS.NOT_ASSIGNED) "POOL_ID",
				DECODE(v_POOL, 1, E.POOL_NAME, NULL) "POOL_NAME"
			FROM
				(SELECT DISTINCT B.EDC_ID, B.PSE_ID, B.ESP_ID, C.POOL_ID
				FROM SERVICE A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, SERVICE_STATE D
				WHERE A.MODEL_ID = p_MODEL_ID
					AND A.SCENARIO_ID = p_SCENARIO_ID
					AND A.AS_OF_DATE = v_AS_OF_DATE
					AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
					AND A.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
					AND A.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
					AND D.SERVICE_ID = A.SERVICE_ID
					AND D.SERVICE_CODE IN (GA.FORECAST_SERVICE, GA.BACKCAST_SERVICE, GA.ACTUAL_SERVICE)
					AND D.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE))  A,
			    ENERGY_DISTRIBUTION_COMPANY B,
				PURCHASING_SELLING_ENTITY C,
				ENERGY_SERVICE_PROVIDER D,
				POOL E
			WHERE B.EDC_ID = A.EDC_ID
			    AND C.PSE_ID = A.PSE_ID
				AND D.ESP_ID = A.ESP_ID
				AND E.POOL_ID = A.POOL_ID
				ORDER BY 2,4,6,8;
	END IF;

END TREE_BRANCHES_COMPARISON;
---------------------------------------------------------------------------------------------------
PROCEDURE TREE_BRANCHES_FINANCIAL
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_DISPLAY_PREFERENCE IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_EDC NUMBER(1);
v_PSE NUMBER(1);
v_ESP NUMBER(1);
v_POOL NUMBER(1);
v_AS_OF_DATE DATE;
v_POSITION_TYPE CHAR(1);

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	SET_DISPLAY_PREFERENCES(p_DISPLAY_PREFERENCE, v_EDC, v_PSE, v_ESP, v_POOL);
	SELECT DECODE(UPPER(SUBSTR(p_REQUEST_TYPE,1,1)),'F',1,'B',2,3) INTO v_POSITION_TYPE FROM DUAL;

	p_STATUS := GA.SUCCESS;

	IF GA.VERSION_STATEMENT THEN
		OPEN p_CURSOR FOR
			SELECT DECODE(v_EDC,1, B.EDC_ID, CONSTANTS.NOT_ASSIGNED) "EDC_ID",
				DECODE(v_EDC, 1, B.EDC_NAME, NULL) "EDC_NAME",
				DECODE(v_PSE, 1, C.PSE_ID, CONSTANTS.NOT_ASSIGNED) "PSE_ID",
				DECODE(v_PSE, 1, C.PSE_NAME, NULL) "PSE_NAME",
				DECODE(v_ESP, 1, D.ESP_ID, CONSTANTS.NOT_ASSIGNED) "ESP_ID",
				DECODE(v_ESP, 1, D.ESP_NAME, NULL) "ESP_NAME",
				DECODE(v_POOL, 1, E.POOL_ID, CONSTANTS.NOT_ASSIGNED) "POOL_ID",
				DECODE(v_POOL, 1, E.POOL_NAME, NULL) "POOL_NAME"
			FROM
				(SELECT DISTINCT B.EDC_ID, B.PSE_ID, B.ESP_ID, C.POOL_ID
				FROM SERVICE A, PROVIDER_SERVICE B, SERVICE_DELIVERY C
				WHERE A.MODEL_ID = p_MODEL_ID
					AND A.SCENARIO_ID = p_SCENARIO_ID
					AND A.AS_OF_DATE =
						(SELECT MAX(AS_OF_DATE)
						FROM SERVICE
						WHERE MODEL_ID = A.MODEL_ID
							AND SCENARIO_ID = p_SCENARIO_ID
							AND AS_OF_DATE <= v_AS_OF_DATE
							AND PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
							AND ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
							AND SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID)
					AND B.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
					AND A.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
					AND C.SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
					AND EXISTS
						(SELECT *
						FROM SERVICE_POSITION_CHARGE
						WHERE SERVICE_ID = A.SERVICE_ID
							AND POSITION_TYPE = v_POSITION_TYPE
							AND CHARGE_DATE BETWEEN TRUNC(p_BEGIN_DATE, 'MONTH') AND LAST_DAY(p_END_DATE))
				GROUP BY B.EDC_ID, B.PSE_ID, B.ESP_ID, C.POOL_ID)  A,
			    ENERGY_DISTRIBUTION_COMPANY B,
				PURCHASING_SELLING_ENTITY C,
				ENERGY_SERVICE_PROVIDER D,
				POOL E
			WHERE B.EDC_ID = A.EDC_ID
			    AND C.PSE_ID = A.PSE_ID
				AND D.ESP_ID = A.ESP_ID
				AND E.POOL_ID = A.POOL_ID
				ORDER BY 2,4,6,8;
	ELSE
		OPEN p_CURSOR FOR
			SELECT DECODE(v_EDC,1, B.EDC_ID, CONSTANTS.NOT_ASSIGNED) "EDC_ID",
				DECODE(v_EDC, 1, B.EDC_NAME, NULL) "EDC_NAME",
				DECODE(v_PSE, 1, C.PSE_ID, CONSTANTS.NOT_ASSIGNED) "PSE_ID",
				DECODE(v_PSE, 1, C.PSE_NAME, NULL) "PSE_NAME",
				DECODE(v_ESP, 1, D.ESP_ID, CONSTANTS.NOT_ASSIGNED) "ESP_ID",
				DECODE(v_ESP, 1, D.ESP_NAME, NULL) "ESP_NAME",
				DECODE(v_POOL, 1, E.POOL_ID, CONSTANTS.NOT_ASSIGNED) "POOL_ID",
				DECODE(v_POOL, 1, E.POOL_NAME, NULL) "POOL_NAME"
			FROM
				(SELECT DISTINCT B.EDC_ID, B.PSE_ID, B.ESP_ID, C.POOL_ID
				FROM SERVICE A, PROVIDER_SERVICE B, SERVICE_DELIVERY C
				WHERE A.MODEL_ID = p_MODEL_ID
					AND A.SCENARIO_ID = p_SCENARIO_ID
					AND A.AS_OF_DATE = LOW_DATE
					AND B.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
					AND A.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
					AND C.SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
					AND EXISTS
						(SELECT *
						FROM SERVICE_POSITION_CHARGE
						WHERE SERVICE_ID = A.SERVICE_ID
							AND POSITION_TYPE = v_POSITION_TYPE
							AND CHARGE_DATE BETWEEN TRUNC(p_BEGIN_DATE, 'MONTH') AND LAST_DAY(p_END_DATE))
				GROUP BY B.EDC_ID, B.PSE_ID, B.ESP_ID, C.POOL_ID)  A,
			    ENERGY_DISTRIBUTION_COMPANY B,
				PURCHASING_SELLING_ENTITY C,
				ENERGY_SERVICE_PROVIDER D,
				POOL E
			WHERE B.EDC_ID = A.EDC_ID
			    AND C.PSE_ID = A.PSE_ID
				AND D.ESP_ID = A.ESP_ID
				AND E.POOL_ID = A.POOL_ID
				ORDER BY 2,4,6,8;
	END IF;

END TREE_BRANCHES_FINANCIAL;
---------------------------------------------------------------------------------------------------
PROCEDURE TREE_BRANCHES_FINANCIAL_PROD
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_DISPLAY_PREFERENCE IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_POSITION_TYPE CHAR(1);
v_BEGIN_DATE DATE := TRUNC(p_BEGIN_DATE, 'MONTH');
v_END_DATE DATE := LAST_DAY(TRUNC(p_END_DATE));
BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	SELECT DECODE(UPPER(SUBSTR(p_REQUEST_TYPE,1,1)),'F',1,'B',2,3) INTO v_POSITION_TYPE FROM DUAL;

	p_STATUS := GA.SUCCESS;

		OPEN p_CURSOR FOR
			SELECT DISTINCT B.PRODUCT_ID, B.PRODUCT_NAME, C.COMPONENT_ID, C.COMPONENT_NAME
			FROM SERVICE_POSITION_CHARGE A, PRODUCT B, COMPONENT C
			WHERE A.SERVICE_ID IN (SELECT SERVICE_ID FROM SERVICE WHERE SCENARIO_ID = p_SCENARIO_ID)
				AND A.POSITION_TYPE = v_POSITION_TYPE
				AND A.CHARGE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND A.PRODUCT_TYPE IN ('R','C')
				AND A.PRODUCT_ID = B.PRODUCT_ID
				AND A.COMPONENT_ID = C.COMPONENT_ID
			ORDER BY 2, 4;

END TREE_BRANCHES_FINANCIAL_PROD;
---------------------------------------------------------------------------------------------------
PROCEDURE TREE_BRANCHES_VALIDATION
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_DISPLAY_PREFERENCE IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the EDC-PSE-ESP relationships for enrollment

v_EDC NUMBER(1);
v_PSE NUMBER(1);
v_ESP NUMBER(1);
v_POOL NUMBER(1);
v_SERVICE_DATE DATE  := TRUNC(p_BEGIN_DATE);

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;
	SET_DISPLAY_PREFERENCES(p_DISPLAY_PREFERENCE, v_EDC, v_PSE, v_ESP, v_POOL);

	OPEN p_CURSOR FOR
		SELECT DECODE(v_EDC,1, B.EDC_ID, CONSTANTS.NOT_ASSIGNED) "EDC_ID",
			DECODE(v_EDC, 1, B.EDC_NAME, NULL) "EDC_NAME",
			DECODE(v_PSE, 1, C.PSE_ID, CONSTANTS.NOT_ASSIGNED) "PSE_ID",
			DECODE(v_PSE, 1, C.PSE_NAME, NULL) "PSE_NAME",
			DECODE(v_ESP, 1, D.ESP_ID, CONSTANTS.NOT_ASSIGNED) "ESP_ID",
			DECODE(v_ESP, 1, D.ESP_NAME, NULL) "ESP_NAME",
			DECODE(v_POOL, 1, E.POOL_ID, CONSTANTS.NOT_ASSIGNED) "POOL_ID",
			DECODE(v_POOL, 1, E.POOL_NAME, NULL) "POOL_NAME"
		FROM
		  (SELECT DISTINCT B.EDC_ID, B.PSE_ID, B.ESP_ID, D.POOL_ID
		   FROM SERVICE_VALIDATION_BEST_FIT A, PROVIDER_SERVICE B, SERVICE C, SERVICE_DELIVERY D
		   WHERE A.SERVICE_DATE = v_SERVICE_DATE
				AND A.SERVICE_ID = C.SERVICE_ID
				AND C.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
				AND D.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID) A,
			ENERGY_DISTRIBUTION_COMPANY B,
			PURCHASING_SELLING_ENTITY C,
			ENERGY_SERVICE_PROVIDER D,
			POOL E
		WHERE B.EDC_ID = A.EDC_ID
			AND C.PSE_ID = A.PSE_ID
			AND D.ESP_ID = A.ESP_ID
			AND E.POOL_ID = A.POOL_ID
		ORDER BY 2,4,6,8;

END TREE_BRANCHES_VALIDATION;
---------------------------------------------------------------------------------------------------
PROCEDURE TREE_BRANCHES_PERIOD_USAGE
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_INCUMBENT_TYPE IN CHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the EDC-ESP relationships for Consumption entries over the specified date range.

BEGIN

	IF GA.VERSION_CONSUMPTION THEN
		OPEN p_CURSOR FOR
			SELECT B.EDC_ID "EDC_ID",
				B.EDC_NAME "EDC_NAME",
				C.ESP_ID "ESP_ID",
				C.ESP_NAME "ESP_NAME"
			FROM
				(SELECT DISTINCT B.EDC_ID, B.ESP_ID
				FROM SERVICE A, PROVIDER_SERVICE B, SERVICE_CONSUMPTION C
				WHERE A.MODEL_ID = p_MODEL_ID
					AND A.SCENARIO_ID = p_SCENARIO_ID
					AND A.AS_OF_DATE =
						(SELECT MAX(AS_OF_DATE)
						FROM SERVICE
						WHERE MODEL_ID = A.MODEL_ID
							AND SCENARIO_ID = p_SCENARIO_ID
							AND AS_OF_DATE <= p_AS_OF_DATE
							AND PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
							AND ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID)
					AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
					AND C.SERVICE_ID = A.SERVICE_ID
					AND C.BEGIN_DATE <= TRUNC(p_END_DATE)
					AND C.END_DATE >= TRUNC(p_BEGIN_DATE)
					AND C.UNIT_OF_MEASUREMENT = GA.DEFAULT_UNIT_OF_MEASUREMENT
					AND UPPER(SUBSTR(C.METER_TYPE,1,1)) = 'P')  A,
				ENERGY_DISTRIBUTION_COMPANY B,
				ENERGY_SERVICE_PROVIDER C
			WHERE B.EDC_ID = A.EDC_ID
				AND C.ESP_ID = A.ESP_ID
			ORDER BY DECODE(p_INCUMBENT_TYPE,'EDC', B.EDC_NAME, C.ESP_NAME), DECODE(p_INCUMBENT_TYPE,'EDC', C.ESP_NAME, B.EDC_NAME);
	ELSE
		OPEN p_CURSOR FOR
			SELECT B.EDC_ID "EDC_ID",
				B.EDC_NAME "EDC_NAME",
				C.ESP_ID "ESP_ID",
				C.ESP_NAME "ESP_NAME"
			FROM
				(SELECT DISTINCT B.EDC_ID, B.ESP_ID
				FROM SERVICE A, PROVIDER_SERVICE B, SERVICE_CONSUMPTION C
				WHERE A.MODEL_ID = p_MODEL_ID
					AND A.SCENARIO_ID = p_SCENARIO_ID
					AND A.AS_OF_DATE = CONSTANTS.LOW_DATE
					AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
					AND C.SERVICE_ID = A.SERVICE_ID
					AND C.BEGIN_DATE <= TRUNC(p_END_DATE)
					AND C.END_DATE >= TRUNC(p_BEGIN_DATE)
					AND C.UNIT_OF_MEASUREMENT = GA.DEFAULT_UNIT_OF_MEASUREMENT
					AND UPPER(SUBSTR(C.METER_TYPE,1,1)) = 'P')  A,
				ENERGY_DISTRIBUTION_COMPANY B,
				ENERGY_SERVICE_PROVIDER C
			WHERE B.EDC_ID = A.EDC_ID
				AND C.ESP_ID = A.ESP_ID
			ORDER BY DECODE(p_INCUMBENT_TYPE,'EDC', B.EDC_NAME, C.ESP_NAME), DECODE(p_INCUMBENT_TYPE,'EDC', C.ESP_NAME, B.EDC_NAME);
	END IF;

END TREE_BRANCHES_PERIOD_USAGE;
---------------------------------------------------------------------------------------------------
PROCEDURE TREE_BRANCHES_INTERVAL_USAGE
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_INCUMBENT_TYPE IN CHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the EDC-ESP relationships for Consumption entries over the specified date range.

BEGIN

	IF GA.VERSION_CONSUMPTION THEN
		OPEN p_CURSOR FOR
			SELECT B.EDC_ID "EDC_ID", B.EDC_NAME "EDC_NAME", C.ESP_ID "ESP_ID", C.ESP_NAME "ESP_NAME"
			FROM
				(SELECT DISTINCT A.EDC_ID, A.ESP_ID
				FROM PROVIDER_SERVICE A
				WHERE EXISTS
					(SELECT 1
					FROM SERVICE B, SERVICE_STATE C
					WHERE B.MODEL_ID = p_MODEL_ID
						AND B.SCENARIO_ID = p_SCENARIO_ID
						AND B.AS_OF_DATE =
							(SELECT MAX(AS_OF_DATE)
							FROM SERVICE
							WHERE MODEL_ID = B.MODEL_ID
								AND SCENARIO_ID = p_SCENARIO_ID
								AND AS_OF_DATE <= p_AS_OF_DATE
								AND ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
								AND PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
								AND SERVICE_DELIVERY_ID = B.SERVICE_DELIVERY_ID)
						AND B.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
						AND C.SERVICE_ID = B.SERVICE_ID
						AND C.SERVICE_CODE = GA.ACTUAL_SERVICE
						AND C.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
						AND UPPER(C.METER_TYPE) = 'I')) X, ENERGY_DISTRIBUTION_COMPANY B, ENERGY_SERVICE_PROVIDER C
			WHERE B.EDC_ID = X.EDC_ID
				AND C.ESP_ID = X.ESP_ID
			ORDER BY DECODE(p_INCUMBENT_TYPE,'EDC', B.EDC_NAME, C.ESP_NAME), DECODE(p_INCUMBENT_TYPE,'EDC', C.ESP_NAME, B.EDC_NAME);
	ELSE
		OPEN p_CURSOR FOR
			SELECT B.EDC_ID "EDC_ID", B.EDC_NAME "EDC_NAME", C.ESP_ID "ESP_ID", C.ESP_NAME "ESP_NAME"
			FROM
				(SELECT DISTINCT A.EDC_ID, A.ESP_ID
				FROM PROVIDER_SERVICE A
				WHERE EXISTS
					(SELECT 1
					FROM SERVICE B, SERVICE_STATE C
					WHERE B.MODEL_ID = p_MODEL_ID
						AND B.SCENARIO_ID = p_SCENARIO_ID
						AND B.AS_OF_DATE = CONSTANTS.LOW_DATE
						AND B.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
						AND C.SERVICE_ID = B.SERVICE_ID
						AND C.SERVICE_CODE = GA.ACTUAL_SERVICE
						AND C.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
						AND UPPER(C.METER_TYPE) = 'I')) X, ENERGY_DISTRIBUTION_COMPANY B, ENERGY_SERVICE_PROVIDER C
			WHERE B.EDC_ID = X.EDC_ID
				AND C.ESP_ID = X.ESP_ID
			ORDER BY DECODE(p_INCUMBENT_TYPE,'EDC', B.EDC_NAME, C.ESP_NAME), DECODE(p_INCUMBENT_TYPE,'EDC', C.ESP_NAME, B.EDC_NAME);
	END IF;

END TREE_BRANCHES_INTERVAL_USAGE;
---------------------------------------------------------------------------------------------------
PROCEDURE TREE_BRANCHES_METERED_USAGE
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_METER_TYPE IN CHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the EDC-ESP relationships for Consumption entries over the specified date range.
-- Soon to be deprecated by changes made to GUI call to API.

v_INCUMBENT_TYPE CHAR(3);

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;

	SELECT UPPER(SUBSTR(INCUMBENT_TYPE,1,3)) INTO v_INCUMBENT_TYPE FROM INCUMBENT_ENTITY;

	IF UPPER(SUBSTR(p_METER_TYPE,1,1)) = 'P' THEN
		TREE_BRANCHES_PERIOD_USAGE(p_REQUEST_TYPE, p_MODEL_ID, p_SCENARIO_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, v_INCUMBENT_TYPE, p_STATUS, p_CURSOR);
	ELSIF UPPER(SUBSTR(p_METER_TYPE,1,1)) = 'I' THEN
		TREE_BRANCHES_INTERVAL_USAGE(p_REQUEST_TYPE, p_MODEL_ID, p_SCENARIO_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, v_INCUMBENT_TYPE, p_STATUS, p_CURSOR);
	END IF;

END TREE_BRANCHES_METERED_USAGE;
---------------------------------------------------------------------------------------------------
PROCEDURE TREE_BRANCHES_LIMIT
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_DISPLAY_PREFERENCE IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the EDC-PSE-ESP relationships for enrollment

v_EDC NUMBER(1);
v_PSE NUMBER(1);
v_ESP NUMBER(1);
v_POOL NUMBER(1);
v_AS_OF_DATE DATE;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;
	SET_DISPLAY_PREFERENCES(p_DISPLAY_PREFERENCE, v_EDC, v_PSE, v_ESP, v_POOL);
	v_AS_OF_DATE := AS_OF_DATE_FOR_REQUEST(UPPER(SUBSTR(p_REQUEST_TYPE,1,1)), p_AS_OF_DATE);
	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('AS_OF_DATE=' || UT.TRACE_DATE(v_AS_OF_DATE));
	END IF;

	OPEN p_CURSOR FOR
		SELECT DECODE(v_EDC,1, B.EDC_ID, CONSTANTS.NOT_ASSIGNED) "EDC_ID",
			DECODE(v_EDC, 1, B.EDC_NAME, NULL) "EDC_NAME",
			DECODE(v_PSE, 1, C.PSE_ID, CONSTANTS.NOT_ASSIGNED) "PSE_ID",
			DECODE(v_PSE, 1, C.PSE_NAME, NULL) "PSE_NAME",
			DECODE(v_ESP, 1, D.ESP_ID, CONSTANTS.NOT_ASSIGNED) "ESP_ID",
			DECODE(v_ESP, 1, D.ESP_NAME, NULL) "ESP_NAME",
			DECODE(v_POOL, 1, E.POOL_ID, CONSTANTS.NOT_ASSIGNED) "POOL_ID",
			DECODE(v_POOL, 1, E.POOL_NAME, NULL) "POOL_NAME"
		FROM
		  (SELECT DISTINCT F.EDC_ID, F.PSE_ID, F.ESP_ID, G.POOL_ID
			FROM CONTRACT_LIMIT A,
				CONTRACT_LIMIT_QUANTITY B,
				CONTRACT_ASSIGNMENT C,
				ACCOUNT_SERVICE D,
				SERVICE E,
				PROVIDER_SERVICE F,
				ESP_POOL G
			WHERE B.LIMIT_ID = A.LIMIT_ID
				AND B.BEGIN_DATE <= p_END_DATE
				AND NVL(B.END_DATE, p_END_DATE) >= p_BEGIN_DATE
				AND C.CONTRACT_ID = B.CONTRACT_ID
				AND C.ENTITY_DOMAIN_ID IN(-170, -190)
				AND C.OWNER_ENTITY_ID IN(D.ACCOUNT_ID, D.METER_ID)
				AND E.MODEL_ID = p_MODEL_ID
				AND E.SCENARIO_ID = p_SCENARIO_ID
				AND E.AS_OF_DATE = v_AS_OF_DATE
				AND E.PROVIDER_SERVICE_ID = F.PROVIDER_SERVICE_ID
				AND E.ACCOUNT_SERVICE_ID = D.ACCOUNT_SERVICE_ID
				AND G.ESP_ID = F.ESP_ID) A,
			ENERGY_DISTRIBUTION_COMPANY B,
			PURCHASING_SELLING_ENTITY C,
			ENERGY_SERVICE_PROVIDER D,
			POOL E
		WHERE B.EDC_ID = A.EDC_ID
			AND C.PSE_ID = A.PSE_ID
			AND D.ESP_ID = A.ESP_ID
			AND E.POOL_ID = A.POOL_ID
		ORDER BY 2,4,6,8;

END TREE_BRANCHES_LIMIT;
---------------------------------------------------------------------------------------------------
FUNCTION TREE_NODES_NEED_FIND
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE
	) RETURN NUMBER IS

--If the number of accounts to be returned is greater than the sysdict threshold, then
--p_NEED_FIND will be 1.

v_AS_OF_DATE DATE := LOW_DATE;
v_THRESHOLD NUMBER;
v_NEED_FIND NUMBER(1);
BEGIN

	v_THRESHOLD := TO_NUMBER(NVL(MODEL_VALUE_AT_KEY(0,'System','Account','Find Threshold'),-1));
	IF v_THRESHOLD <= 0 THEN
		v_NEED_FIND := 0;
	ELSIF v_THRESHOLD = 1 THEN
		v_NEED_FIND := 1;
	ELSE
	    SELECT DECODE(COUNT(*),v_THRESHOLD,1,0)
		 INTO v_NEED_FIND
		 FROM PROVIDER_SERVICE A, ACCOUNT_SERVICE B, SERVICE C, SERVICE_DELIVERY D
			WHERE (p_EDC_ID = g_NA_BRANCH OR A.EDC_ID = p_EDC_ID)
				AND (p_ESP_ID = g_NA_BRANCH OR A.ESP_ID = p_ESP_ID)
				AND (p_PSE_ID = g_NA_BRANCH OR A.PSE_ID = p_PSE_ID)
				AND C.MODEL_ID = p_MODEL_ID
				AND C.SCENARIO_ID = p_SCENARIO_ID
				AND C.AS_OF_DATE = v_AS_OF_DATE
				AND C.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
				AND C.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
				AND C.SERVICE_DELIVERY_ID = D.SERVICE_DELIVERY_ID
				AND (p_POOL_ID = g_NA_BRANCH OR D.POOL_ID = p_POOL_ID)
				AND ROWNUM <= v_THRESHOLD;
	END IF;

	RETURN v_NEED_FIND;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN 0;

END TREE_NODES_NEED_FIND;
---------------------------------------------------------------------------------------------------
PROCEDURE TREE_NODES_ACCOUNT
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SORT_PREFERENCE IN NUMBER,
	p_IS_EXTERNAL_FORECAST IN NUMBER,
	p_SEARCH_STRING IN VARCHAR := '%%',
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the retail accounts associated with an EDC-PSE-ESP.
-- p_SORT_PREFERENCE codes: 1 - Account Model Option, 2 - Missing Values, 3 - Profile Type; Alpha Sub-sort.

v_REQUEST_TYPE CHAR(1) := UPPER(SUBSTR(p_REQUEST_TYPE,1,1));
v_AS_OF_DATE DATE;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;
	v_AS_OF_DATE := AS_OF_DATE_FOR_REQUEST(v_REQUEST_TYPE, p_AS_OF_DATE);

	IF LENGTH(p_SEARCH_STRING) <= 1 AND TREE_NODES_NEED_FIND(v_REQUEST_TYPE, p_MODEL_ID, p_SCENARIO_ID, p_EDC_ID, p_PSE_ID, p_ESP_ID, p_POOL_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) = 1 THEN
		OPEN p_CURSOR FOR
			  SELECT g_NEED_FIND FROM DUAL;
	ELSIF IS_VERSIONED_REQUEST(v_REQUEST_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) THEN
		OPEN p_CURSOR FOR
		    SELECT B.ACCOUNT_DISPLAY_NAME AS ACCOUNT_NAME,
				B.ACCOUNT_ID,
				C.SERVICE_LOCATION_NAME,
				C.SERVICE_LOCATION_ID,
				D.METER_NAME,
				D.METER_ID,
				A.AGGREGATE_ID,
				A.USE_USAGE_DAY_PROFILE,
				A.PROFILE_TYPE,
				A.PROFILE_ZERO_COUNT,
				DECODE(p_SORT_PREFERENCE,1,DECODE(A.AGGREGATE_ID,0,DECODE(A.METER_ID,0,'B','C'),'A'),2,TO_CHAR(999999-A.PROFILE_ZERO_COUNT),3,A.PROFILE_TYPE) AS SORT_PREFERENCE,
				B.MODEL_ID AS METER_MODEL_ID
			FROM
				(SELECT ACCOUNT_ID, SERVICE_LOCATION_ID, METER_ID, AGGREGATE_ID,
					SUM(DECODE(E.PROFILE_TYPE,'U',1,0)) AS USE_USAGE_DAY_PROFILE,
					MAX(E.PROFILE_TYPE) AS PROFILE_TYPE,
					SUM(E.PROFILE_ZERO_COUNT) AS PROFILE_ZERO_COUNT
				FROM PROVIDER_SERVICE A, ACCOUNT_SERVICE B, SERVICE C, SERVICE_DELIVERY D, SERVICE_STATE E
				WHERE (p_EDC_ID = g_NA_BRANCH OR A.EDC_ID = p_EDC_ID)
					AND (p_ESP_ID = g_NA_BRANCH OR A.ESP_ID = p_ESP_ID)
					AND (p_PSE_ID = g_NA_BRANCH OR A.PSE_ID = p_PSE_ID)
					AND C.MODEL_ID = p_MODEL_ID
					AND C.SCENARIO_ID = p_SCENARIO_ID
					AND C.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
					AND C.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
					AND C.SERVICE_DELIVERY_ID = D.SERVICE_DELIVERY_ID
					AND (p_POOL_ID = g_NA_BRANCH OR D.POOL_ID = p_POOL_ID)
					AND E.SERVICE_ID = C.SERVICE_ID
					AND (v_REQUEST_TYPE = g_WILD_CARD OR E.SERVICE_CODE = v_REQUEST_TYPE)
					AND E.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
					AND C.AS_OF_DATE =
						(SELECT MAX(AS_OF_DATE)
						FROM SERVICE
						WHERE MODEL_ID = C.MODEL_ID
							AND SCENARIO_ID = C.SCENARIO_ID
							AND ACCOUNT_SERVICE_ID = C.ACCOUNT_SERVICE_ID
							AND PROVIDER_SERVICE_ID = C.PROVIDER_SERVICE_ID
							AND SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
							AND AS_OF_DATE <= v_AS_OF_DATE)
				GROUP BY ACCOUNT_ID, SERVICE_LOCATION_ID, METER_ID, AGGREGATE_ID) A,
				ACCOUNT B,
				SERVICE_LOCATION C,
				METER D
			WHERE B.ACCOUNT_ID = A.ACCOUNT_ID
				AND C.SERVICE_LOCATION_ID = A.SERVICE_LOCATION_ID
				AND D.METER_ID = A.METER_ID
			ORDER BY 11,1,2,3,4,5;
	ELSE
		OPEN p_CURSOR FOR
		    SELECT B.ACCOUNT_DISPLAY_NAME AS ACCOUNT_NAME,
				B.ACCOUNT_ID,
				C.SERVICE_LOCATION_NAME,
				C.SERVICE_LOCATION_ID,
				D.METER_NAME,
				D.METER_ID,
				A.AGGREGATE_ID,
				A.USE_USAGE_DAY_PROFILE,
				A.PROFILE_TYPE,
				A.PROFILE_ZERO_COUNT,
				DECODE(p_SORT_PREFERENCE,1,DECODE(A.AGGREGATE_ID,0,DECODE(A.METER_ID,0,'B','C'),'A'),2,TO_CHAR(999999-A.PROFILE_ZERO_COUNT),3,A.PROFILE_TYPE) AS SORT_PREFERENCE,
				B.MODEL_ID AS METER_MODEL_ID
			FROM
				(SELECT ACCOUNT_ID, SERVICE_LOCATION_ID, METER_ID, AGGREGATE_ID,
					SUM(DECODE(E.PROFILE_TYPE,'U',1,0)) AS USE_USAGE_DAY_PROFILE,
					MAX(E.PROFILE_TYPE) AS PROFILE_TYPE,
					SUM(E.PROFILE_ZERO_COUNT) AS PROFILE_ZERO_COUNT
				FROM PROVIDER_SERVICE A, ACCOUNT_SERVICE B, SERVICE C, SERVICE_DELIVERY D, SERVICE_STATE E
				WHERE (p_EDC_ID = g_NA_BRANCH OR A.EDC_ID = p_EDC_ID)
					AND (p_ESP_ID = g_NA_BRANCH OR A.ESP_ID = p_ESP_ID)
					AND (p_PSE_ID = g_NA_BRANCH OR A.PSE_ID = p_PSE_ID)
					AND C.MODEL_ID = p_MODEL_ID
					AND C.SCENARIO_ID = p_SCENARIO_ID
					AND C.AS_OF_DATE = v_AS_OF_DATE
					AND C.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
					AND C.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
					AND C.SERVICE_DELIVERY_ID = D.SERVICE_DELIVERY_ID
					AND E.SERVICE_ID = C.SERVICE_ID
					AND (p_POOL_ID = g_NA_BRANCH OR D.POOL_ID = p_POOL_ID)
					AND (v_REQUEST_TYPE = g_WILD_CARD OR E.SERVICE_CODE = v_REQUEST_TYPE)
					AND E.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
				GROUP BY ACCOUNT_ID, SERVICE_LOCATION_ID, METER_ID, AGGREGATE_ID) A,
				ACCOUNT B,
				SERVICE_LOCATION C,
				METER D
			WHERE B.ACCOUNT_ID = A.ACCOUNT_ID
				AND (p_SEARCH_STRING = '%' OR B.ACCOUNT_NAME LIKE p_SEARCH_STRING)
				AND C.SERVICE_LOCATION_ID = A.SERVICE_LOCATION_ID
				AND D.METER_ID = A.METER_ID
			ORDER BY 11,1,2,3,4,5;
	END IF;

END TREE_NODES_ACCOUNT;
---------------------------------------------------------------------------------------------------
PROCEDURE TREE_NODES_ACCOUNT
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SORT_PREFERENCE IN NUMBER,
	p_SEARCH_STRING IN VARCHAR := '%%',
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the retail accounts associated with an EDC-PSE-ESP.

 v_IS_EXTERNAL_FORECAST NUMBER(1) := 0;

BEGIN

	TREE_NODES_ACCOUNT(p_REQUEST_TYPE, p_MODEL_ID, p_SCENARIO_ID, p_EDC_ID, p_PSE_ID, p_ESP_ID, p_POOL_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_SORT_PREFERENCE, v_IS_EXTERNAL_FORECAST, p_SEARCH_STRING, p_STATUS, p_CURSOR);

END TREE_NODES_ACCOUNT;
---------------------------------------------------------------------------------------------------
PROCEDURE TREE_NODES_ACCOUNT_EXT
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SORT_PREFERENCE IN NUMBER,
	p_SEARCH_STRING IN VARCHAR := '%%',
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the retail accounts that have external forecast option
-- associated with an EDC-PSE-ESP.

 v_SORT_PREFERENCE NUMBER(1) := 1;
 v_IS_EXTERNAL_FORECAST NUMBER(1) := 1;

BEGIN

	TREE_NODES_ACCOUNT(p_REQUEST_TYPE, p_MODEL_ID, p_SCENARIO_ID, p_EDC_ID, p_PSE_ID, p_ESP_ID, p_POOL_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, v_SORT_PREFERENCE, v_IS_EXTERNAL_FORECAST, p_SEARCH_STRING, p_STATUS, p_CURSOR);

END TREE_NODES_ACCOUNT_EXT;
---------------------------------------------------------------------------------------------------
PROCEDURE TREE_NODES_ACCOUNT_FIND
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the retail accounts associated with an EDC-PSE-ESP.

v_REQUEST_TYPE CHAR(1) := UPPER(SUBSTR(p_REQUEST_TYPE,1,1));
v_AS_OF_DATE DATE;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;
	v_AS_OF_DATE := AS_OF_DATE_FOR_REQUEST(v_REQUEST_TYPE, p_AS_OF_DATE);

	IF IS_VERSIONED_REQUEST(v_REQUEST_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) THEN
		OPEN p_CURSOR FOR
			SELECT	A.EDC_ID,
				A.PSE_ID,
				A.ESP_ID,
				A.POOL_ID,
				B.ACCOUNT_DISPLAY_NAME AS ACCOUNT_NAME,
				B.ACCOUNT_ID,
				C.SERVICE_LOCATION_NAME,
				C.SERVICE_LOCATION_ID,
				D.METER_NAME,
				D.METER_ID,
				A.AGGREGATE_ID,
				A.USE_USAGE_DAY_PROFILE,
				DECODE(A.AGGREGATE_ID,0,DECODE(D.METER_ID,0,'B','C'),'A') AS ORDER_BY_TYPE,
				A.PROFILE_TYPE,
				0 AS PROFILE_ZERO_COUNT,
				0 AS SORT_PREFERENCE,
				B.MODEL_ID AS METER_MODEL_ID
			FROM
				(SELECT DISTINCT ACCOUNT_ID, SERVICE_LOCATION_ID, METER_ID, AGGREGATE_ID, EDC_ID, PSE_ID, ESP_ID, POOL_ID,
					SUM(DECODE(E.PROFILE_TYPE,'U',1,0)) AS USE_USAGE_DAY_PROFILE, MAX(E.PROFILE_TYPE) AS PROFILE_TYPE
				FROM ACCOUNT_SERVICE A, PROVIDER_SERVICE B, SERVICE C, SERVICE_DELIVERY D, SERVICE_STATE E
				WHERE A.ACCOUNT_ID = p_ACCOUNT_ID
					AND C.MODEL_ID = p_MODEL_ID
					AND C.SCENARIO_ID = C.SCENARIO_ID
					AND C.AS_OF_DATE =
						(SELECT MAX(AS_OF_DATE)
						FROM SERVICE
						WHERE MODEL_ID = C.MODEL_ID
							AND SCENARIO_ID = C.SCENARIO_ID
							AND ACCOUNT_SERVICE_ID = C.ACCOUNT_SERVICE_ID
							AND PROVIDER_SERVICE_ID = C.PROVIDER_SERVICE_ID
							AND SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
							AND AS_OF_DATE <= v_AS_OF_DATE)
					AND C.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
					AND C.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
					AND C.SERVICE_DELIVERY_ID = D.SERVICE_DELIVERY_ID
					AND E.SERVICE_ID = C.SERVICE_ID
					AND (v_REQUEST_TYPE = g_WILD_CARD OR E.SERVICE_CODE = v_REQUEST_TYPE)
					AND E.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
				 GROUP BY ACCOUNT_ID, SERVICE_LOCATION_ID, METER_ID, AGGREGATE_ID, EDC_ID, PSE_ID, ESP_ID, POOL_ID) A,
				ACCOUNT B,
				SERVICE_LOCATION C,
				METER D
			WHERE B.ACCOUNT_ID = A.ACCOUNT_ID
				AND C.SERVICE_LOCATION_ID = A.SERVICE_LOCATION_ID
				AND D.METER_ID = A.METER_ID
			ORDER BY 13,1,2,3,4,5,6,7,8,9;
	ELSE
		OPEN p_CURSOR FOR
			SELECT	A.EDC_ID,
				A.PSE_ID,
				A.ESP_ID,
				A.POOL_ID,
				B.ACCOUNT_DISPLAY_NAME AS ACCOUNT_NAME,
				B.ACCOUNT_ID,
				C.SERVICE_LOCATION_NAME,
				C.SERVICE_LOCATION_ID,
				D.METER_NAME,
				D.METER_ID,
				A.AGGREGATE_ID,
				A.USE_USAGE_DAY_PROFILE,
				DECODE(A.AGGREGATE_ID,0,DECODE(D.METER_ID,0,'B','C'),'A') AS ORDER_BY_TYPE,
				A.PROFILE_TYPE,
				0 AS PROFILE_ZERO_COUNT,
				0 AS SORT_PREFERENCE,
				B.MODEL_ID AS METER_MODEL_ID
			FROM
				(SELECT DISTINCT ACCOUNT_ID, SERVICE_LOCATION_ID, METER_ID, AGGREGATE_ID, EDC_ID, PSE_ID, ESP_ID, POOL_ID,
					SUM(DECODE(E.PROFILE_TYPE,'U',1,0)) AS USE_USAGE_DAY_PROFILE, MAX(E.PROFILE_TYPE) AS PROFILE_TYPE
				FROM ACCOUNT_SERVICE A, PROVIDER_SERVICE B, SERVICE C, SERVICE_DELIVERY D, SERVICE_STATE E
				WHERE A.ACCOUNT_ID = p_ACCOUNT_ID
					AND C.MODEL_ID = p_MODEL_ID
					AND C.SCENARIO_ID = C.SCENARIO_ID
					AND C.AS_OF_DATE = v_AS_OF_DATE
					AND C.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
					AND C.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
					AND C.SERVICE_DELIVERY_ID = D.SERVICE_DELIVERY_ID
					AND E.SERVICE_ID = C.SERVICE_ID
					AND (v_REQUEST_TYPE = g_WILD_CARD OR E.SERVICE_CODE = v_REQUEST_TYPE)
					AND E.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
				 GROUP BY ACCOUNT_ID, SERVICE_LOCATION_ID, METER_ID, AGGREGATE_ID, EDC_ID, PSE_ID, ESP_ID, POOL_ID) A,
				ACCOUNT B,
				SERVICE_LOCATION C,
				METER D
			WHERE B.ACCOUNT_ID = A.ACCOUNT_ID
				AND C.SERVICE_LOCATION_ID = A.SERVICE_LOCATION_ID
				AND D.METER_ID = A.METER_ID
			ORDER BY 13,1,2,3,4,5,6,7,8,9;
	END IF;

END TREE_NODES_ACCOUNT_FIND;
---------------------------------------------------------------------------------------------------
PROCEDURE TREE_NODES_ACCOUNT_FIND_EXT
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	TREE_NODES_ACCOUNT_FIND(p_REQUEST_TYPE, p_MODEL_ID, p_ACCOUNT_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_STATUS, p_CURSOR);

END TREE_NODES_ACCOUNT_FIND_EXT;
---------------------------------------------------------------------------------------------------
PROCEDURE TREE_NODES_ANCILLARY
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SEARCH_STRING IN VARCHAR := '%%',
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the retail accounts associated with an EDC-PSE-ESP.

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;

	IF LENGTH(p_SEARCH_STRING) <= 1 AND TREE_NODES_NEED_FIND(p_REQUEST_TYPE, p_MODEL_ID, p_SCENARIO_ID, p_EDC_ID, p_PSE_ID, p_ESP_ID, p_POOL_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) = 1 THEN
		OPEN p_CURSOR FOR
			  SELECT g_NEED_FIND FROM DUAL;
	ELSE
		OPEN p_CURSOR FOR
			SELECT B.ACCOUNT_DISPLAY_NAME AS ACCOUNT_NAME,
				B.ACCOUNT_ID,
				C.SERVICE_LOCATION_NAME,
				C.SERVICE_LOCATION_ID,
				D.METER_NAME,
				D.METER_ID,
				A.AGGREGATE_ID,
				0 AS USE_USAGE_DAY_PROFILE,
				DECODE(A.AGGREGATE_ID,0,DECODE(D.METER_ID,0,'B','C'),'A') AS ORDER_BY_TYPE,
				'' AS PROFILE_TYPE,
				B.MODEL_ID AS METER_MODEL_ID
			FROM
				(SELECT DISTINCT A.ACCOUNT_ID, D.SERVICE_LOCATION_ID, E.METER_ID, 0 AS AGGREGATE_ID
				FROM ACCOUNT ACCT, ACCOUNT_ESP A, ACCOUNT_EDC B, PSE_ESP C, ACCOUNT_SERVICE_LOCATION D, SERVICE_LOCATION_METER E
				WHERE (p_ESP_ID = g_NA_BRANCH OR A.ESP_ID = p_ESP_ID)
					AND (p_POOL_ID = g_NA_BRANCH OR A.POOL_ID = p_POOL_ID)
					AND A.BEGIN_DATE <= TRUNC(p_END_DATE) AND NVL(A.END_DATE, HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
					AND A.ACCOUNT_ID = B.ACCOUNT_ID
					AND (p_EDC_ID = g_NA_BRANCH OR B.EDC_ID = p_EDC_ID)
					AND B.BEGIN_DATE <= TRUNC(p_END_DATE) AND NVL(B.END_DATE, HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
					AND (p_PSE_ID = g_NA_BRANCH OR C.PSE_ID = p_PSE_ID)
					AND C.ESP_ID = A.ESP_ID
					AND C.BEGIN_DATE <= NVL(A.END_DATE, HIGH_DATE) AND NVL(C.END_DATE, HIGH_DATE) >= A.BEGIN_DATE
					AND D.ACCOUNT_ID = A.ACCOUNT_ID
					AND D.BEGIN_DATE <= TRUNC(p_END_DATE) AND NVL(D.END_DATE, HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
					AND D.SERVICE_LOCATION_ID = E.SERVICE_LOCATION_ID(+)
					AND E.BEGIN_DATE(+) <= NVL(D.END_DATE, HIGH_DATE) AND NVL(E.END_DATE(+), HIGH_DATE) >= D.BEGIN_DATE
                    AND ACCT.ACCOUNT_ID = A.ACCOUNT_ID
                    AND ACCT.IS_SUB_AGGREGATE = 0
				UNION
				SELECT DISTINCT A.ACCOUNT_ID, D.SERVICE_LOCATION_ID, 0 AS METER_ID, A.AGGREGATE_ID
				FROM AGGREGATE_ACCOUNT_ESP A, ACCOUNT_EDC B, PSE_ESP C, ACCOUNT_SERVICE_LOCATION D
				WHERE (p_ESP_ID = g_NA_BRANCH OR A.ESP_ID = p_ESP_ID)
					AND (p_POOL_ID = g_NA_BRANCH OR A.POOL_ID = p_POOL_ID)
					AND A.BEGIN_DATE <= TRUNC(p_END_DATE) AND NVL(A.END_DATE, HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
					AND A.ACCOUNT_ID = B.ACCOUNT_ID
					AND (p_EDC_ID = g_NA_BRANCH OR B.EDC_ID = p_EDC_ID)
					AND B.BEGIN_DATE <= TRUNC(p_END_DATE) AND NVL(B.END_DATE, HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
					AND (p_PSE_ID = g_NA_BRANCH OR C.PSE_ID = p_PSE_ID)
					AND C.ESP_ID = A.ESP_ID
					AND C.BEGIN_DATE <= NVL(A.END_DATE, HIGH_DATE) AND NVL(C.END_DATE, HIGH_DATE) >= A.BEGIN_DATE
					AND D.ACCOUNT_ID = A.ACCOUNT_ID
					AND D.BEGIN_DATE <= TRUNC(p_END_DATE) AND NVL(D.END_DATE, HIGH_DATE) >= TRUNC(p_BEGIN_DATE)) A,
				ACCOUNT B,
				SERVICE_LOCATION C,
				METER D
			WHERE B.ACCOUNT_ID = A.ACCOUNT_ID
				AND C.SERVICE_LOCATION_ID = A.SERVICE_LOCATION_ID
				AND D.METER_ID(+) = A.METER_ID
			ORDER BY 9,1,2,3,4,5;
		END IF;

END TREE_NODES_ANCILLARY;
---------------------------------------------------------------------------------------------------
PROCEDURE TREE_NODES_ANCILLARY_FIND
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	TREE_NODES_ACCOUNT_FIND(p_REQUEST_TYPE, p_MODEL_ID, p_ACCOUNT_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_STATUS, p_CURSOR);

END TREE_NODES_ANCILLARY_FIND;
---------------------------------------------------------------------------------------------------
PROCEDURE TREE_NODES_COMPARISON
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SEARCH_STRING IN VARCHAR := '%%',
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the retail accounts associated with an EDC-PSE-ESP for the Comparison View.

 v_SORT_PREFERENCE NUMBER(1) := 1;
 v_IS_EXTERNAL_FORECAST NUMBER(1) := 0;

BEGIN

	TREE_NODES_ACCOUNT(g_WILD_CARD, p_MODEL_ID, p_SCENARIO_ID, p_EDC_ID, p_PSE_ID, p_ESP_ID, p_POOL_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, v_SORT_PREFERENCE, v_IS_EXTERNAL_FORECAST, p_SEARCH_STRING, p_STATUS, p_CURSOR);

END TREE_NODES_COMPARISON;
---------------------------------------------------------------------------------------------------
PROCEDURE TREE_NODES_COMPARISON_FIND
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	TREE_NODES_ACCOUNT_FIND(p_REQUEST_TYPE, p_MODEL_ID, p_ACCOUNT_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_STATUS, p_CURSOR);

END TREE_NODES_COMPARISON_FIND;
---------------------------------------------------------------------------------------------------
PROCEDURE TREE_NODES_FINANCIAL
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SEARCH_STRING IN VARCHAR := '%%',
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the retail accounts associated with an EDC-PSE-ESP.

v_AS_OF_DATE DATE;
v_POSITION_TYPE CHAR(1);

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;
	SELECT DECODE(UPPER(SUBSTR(p_REQUEST_TYPE,1,1)),'F',1,'B',2,3) INTO v_POSITION_TYPE FROM DUAL;

	IF LENGTH(p_SEARCH_STRING) <= 1 AND TREE_NODES_NEED_FIND(p_REQUEST_TYPE, p_MODEL_ID, p_SCENARIO_ID, p_EDC_ID, p_PSE_ID, p_ESP_ID, p_POOL_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) = 1 THEN
		OPEN p_CURSOR FOR
			  SELECT g_NEED_FIND FROM DUAL;
	ELSIF GA.VERSION_STATEMENT THEN
		OPEN p_CURSOR FOR
		    SELECT B.ACCOUNT_DISPLAY_NAME "ACCOUNT_NAME",
				B.ACCOUNT_ID,
				C.SERVICE_LOCATION_NAME,
				C.SERVICE_LOCATION_ID,
				D.METER_NAME,
				D.METER_ID,
				A.AGGREGATE_ID,
				B.MODEL_ID "METER_MODEL_ID",
				0 "USE_USAGE_DAY_PROFILE"
			FROM
				(SELECT DISTINCT ACCOUNT_ID, SERVICE_LOCATION_ID, METER_ID, AGGREGATE_ID
				FROM PROVIDER_SERVICE A, ACCOUNT_SERVICE B, SERVICE C, SERVICE_DELIVERY D
				WHERE (p_EDC_ID = g_NA_BRANCH OR A.EDC_ID = p_EDC_ID)
					AND (p_ESP_ID = g_NA_BRANCH OR A.ESP_ID = p_ESP_ID)
					AND (p_PSE_ID = g_NA_BRANCH OR A.PSE_ID = p_PSE_ID)
					AND C.MODEL_ID = p_MODEL_ID
					AND C.SCENARIO_ID = p_SCENARIO_ID
					AND C.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
					AND C.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
					AND C.SERVICE_DELIVERY_ID = D.SERVICE_DELIVERY_ID
					AND (p_POOL_ID = g_NA_BRANCH OR D.POOL_ID = p_POOL_ID)
					AND C.AS_OF_DATE =
						(SELECT MAX(AS_OF_DATE)
						FROM SERVICE
						WHERE MODEL_ID = C.MODEL_ID
							AND SCENARIO_ID = C.SCENARIO_ID
							AND AS_OF_DATE <= v_AS_OF_DATE
							AND PROVIDER_SERVICE_ID = C.PROVIDER_SERVICE_ID
							AND ACCOUNT_SERVICE_ID = C.ACCOUNT_SERVICE_ID
							AND SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID)
					AND EXISTS
						(SELECT *
						FROM SERVICE_POSITION_CHARGE
						WHERE SERVICE_ID = C.SERVICE_ID
							AND POSITION_TYPE = v_POSITION_TYPE
							AND CHARGE_DATE BETWEEN TRUNC(p_BEGIN_DATE, 'MONTH') AND LAST_DAY(p_END_DATE))
				GROUP BY ACCOUNT_ID, SERVICE_LOCATION_ID, METER_ID, AGGREGATE_ID) A,
				ACCOUNT B,
				SERVICE_LOCATION C,
				METER D
			WHERE B.ACCOUNT_ID = A.ACCOUNT_ID
				AND C.SERVICE_LOCATION_ID = A.SERVICE_LOCATION_ID
				AND D.METER_ID = A.METER_ID
			ORDER BY 1,3,5;
	ELSE
		OPEN p_CURSOR FOR
		    SELECT B.ACCOUNT_DISPLAY_NAME "ACCOUNT_NAME",
				B.ACCOUNT_ID,
				C.SERVICE_LOCATION_NAME,
				C.SERVICE_LOCATION_ID,
				D.METER_NAME,
				D.METER_ID,
				A.AGGREGATE_ID,
				B.MODEL_ID "METER_MODEL_ID",
				0 "USE_USAGE_DAY_PROFILE"
			FROM
				(SELECT DISTINCT ACCOUNT_ID, SERVICE_LOCATION_ID, METER_ID, AGGREGATE_ID
				FROM PROVIDER_SERVICE A, ACCOUNT_SERVICE B, SERVICE C, SERVICE_DELIVERY D
				WHERE (p_EDC_ID = g_NA_BRANCH OR A.EDC_ID = p_EDC_ID)
					AND (p_ESP_ID = g_NA_BRANCH OR A.ESP_ID = p_ESP_ID)
					AND (p_PSE_ID = g_NA_BRANCH OR A.PSE_ID = p_PSE_ID)
					AND C.MODEL_ID = p_MODEL_ID
					AND C.SCENARIO_ID = p_SCENARIO_ID
					AND C.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
					AND C.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
					AND C.SERVICE_DELIVERY_ID = D.SERVICE_DELIVERY_ID
					AND (p_POOL_ID = g_NA_BRANCH OR D.POOL_ID = p_POOL_ID)
					AND C.AS_OF_DATE = LOW_DATE
					AND EXISTS
						(SELECT *
						FROM SERVICE_POSITION_CHARGE
						WHERE SERVICE_ID = C.SERVICE_ID
							AND POSITION_TYPE = v_POSITION_TYPE
							AND CHARGE_DATE BETWEEN TRUNC(p_BEGIN_DATE, 'MONTH') AND LAST_DAY(p_END_DATE))
				GROUP BY ACCOUNT_ID, SERVICE_LOCATION_ID, METER_ID, AGGREGATE_ID) A,
				ACCOUNT B,
				SERVICE_LOCATION C,
				METER D
			WHERE B.ACCOUNT_ID = A.ACCOUNT_ID
				AND C.SERVICE_LOCATION_ID = A.SERVICE_LOCATION_ID
				AND D.METER_ID = A.METER_ID
			ORDER BY 1,3,5;
	END IF;

END TREE_NODES_FINANCIAL;
---------------------------------------------------------------------------------------------------
PROCEDURE TREE_NODES_VALIDATION
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_VARIANCE_TEST IN VARCHAR,
	p_SEARCH_STRING IN VARCHAR := '%%',
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the retail accounts associated with an EDC-PSE-ESP.

v_VARIANCE_TEST NUMBER(1);

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;
	SELECT DECODE(UPPER(SUBSTR(p_VARIANCE_TEST,1,1)),'P',g_PEAK_VAR,'H',g_HOUR_VAR,g_TOTAL_VAR) INTO v_VARIANCE_TEST FROM DUAL;

	IF LENGTH(p_SEARCH_STRING) <= 1 AND TREE_NODES_NEED_FIND(p_REQUEST_TYPE, p_MODEL_ID, p_SCENARIO_ID, p_EDC_ID, p_PSE_ID, p_ESP_ID, p_POOL_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) = 1 THEN
		OPEN p_CURSOR FOR
			  SELECT g_NEED_FIND FROM DUAL;
	ELSE
		OPEN p_CURSOR FOR
			SELECT B.ACCOUNT_DISPLAY_NAME AS ACCOUNT_NAME,
				B.ACCOUNT_ID,
				C.SERVICE_LOCATION_NAME,
				C.SERVICE_LOCATION_ID,
				D.METER_NAME,
				D.METER_ID,
				A.AGGREGATE_ID,
				0 AS USE_USAGE_DAY_PROFILE,
				A.PERCENT_DIFF * ((TRUNC(A.PERCENT_DIFF,4) - TRUNC(A.PERCENT_DIFF,5)) * 100000 + 1) AS PERCENT_DIFF,  --PUT THE SIGN BACK IN.
				A.PERCENT_DIFF AS ABS_PERCENT_DIFF, --THIS IS ABSOLUTE VALUE ALREADY.
				A.METHOD,
				A.VARIANCE_RULE,
				B.MODEL_ID AS METER_MODEL_ID
			FROM
				(SELECT DISTINCT ACCOUNT_ID, SERVICE_LOCATION_ID, METER_ID, AGGREGATE_ID,
						DECODE(v_VARIANCE_TEST, g_TOTAL_VAR, MAX(ROUND(ABS(TOTAL_PCT),4) + DECODE(SIGN(TOTAL_PCT),-1,.00002,0)), g_PEAK_VAR, MAX(ROUND(ABS(PEAK_PCT),4) + DECODE(SIGN(PEAK_PCT),-1,.00002,0)), g_HOUR_VAR, MAX(ROUND(ABS(HOUR_PCT),4) + DECODE(SIGN(HOUR_PCT),-1,.00002,0))) AS PERCENT_DIFF,
						DECODE(v_VARIANCE_TEST, g_TOTAL_VAR, MAX(TOTAL_METHOD), g_PEAK_VAR, MAX(PEAK_METHOD), g_HOUR_VAR, MAX(HOUR_METHOD)) AS METHOD,
						DECODE(v_VARIANCE_TEST, g_TOTAL_VAR, SUM(TOTAL_RULE), g_PEAK_VAR, SUM(PEAK_RULE), g_HOUR_VAR, SUM(HOUR_RULE)) AS VARIANCE_RULE
				FROM SERVICE_VALIDATION_BEST_FIT X, ACCOUNT_SERVICE Y, PROVIDER_SERVICE Z, SERVICE V, SERVICE_DELIVERY W, SERVICE_STATE U
				WHERE (p_EDC_ID = g_NA_BRANCH OR Z.EDC_ID = p_EDC_ID)
					AND (p_PSE_ID = g_NA_BRANCH OR Z.PSE_ID = p_PSE_ID)
					AND (p_ESP_ID = g_NA_BRANCH OR Z.ESP_ID = p_ESP_ID)
					AND (p_POOL_ID = g_NA_BRANCH OR W.POOL_ID = p_POOL_ID)
					AND X.SERVICE_ID = V.SERVICE_ID
					AND V.PROVIDER_SERVICE_ID = Z.PROVIDER_SERVICE_ID
					AND V.ACCOUNT_SERVICE_ID = Y.ACCOUNT_SERVICE_ID
					AND V.SERVICE_DELIVERY_ID = W.SERVICE_DELIVERY_ID
					AND U.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
					AND U.SERVICE_ID = V.SERVICE_ID
				GROUP BY ACCOUNT_ID, SERVICE_LOCATION_ID, METER_ID, AGGREGATE_ID) A,
				ACCOUNT B,
				SERVICE_LOCATION C,
				METER D
			WHERE B.ACCOUNT_ID = A.ACCOUNT_ID
				AND C.SERVICE_LOCATION_ID = A.SERVICE_LOCATION_ID
				AND D.METER_ID = A.METER_ID
			ORDER BY 10 DESC,1,2,3,4,5;
		END IF;
END TREE_NODES_VALIDATION;
---------------------------------------------------------------------------------------------------
PROCEDURE TREE_NODES_LIMIT
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SEARCH_STRING IN VARCHAR := '%%',
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the retail accounts associated with an EDC-PSE-ESP.

v_AS_OF_DATE DATE;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;
	v_AS_OF_DATE := AS_OF_DATE_FOR_REQUEST(UPPER(SUBSTR(p_REQUEST_TYPE,1,1)), p_AS_OF_DATE);

	IF LENGTH(p_SEARCH_STRING) <= 1 AND TREE_NODES_NEED_FIND(p_REQUEST_TYPE, p_MODEL_ID, p_SCENARIO_ID, p_EDC_ID, p_PSE_ID, p_ESP_ID, p_POOL_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) = 1 THEN
		OPEN p_CURSOR FOR
			  SELECT g_NEED_FIND FROM DUAL;
	ELSE
		OPEN p_CURSOR FOR
			SELECT B.ACCOUNT_DISPLAY_NAME AS ACCOUNT_NAME,
				B.ACCOUNT_ID,
				C.SERVICE_LOCATION_NAME,
				C.SERVICE_LOCATION_ID,
				D.METER_NAME,
				D.METER_ID,
				A.AGGREGATE_ID,
				0 "USE_USAGE_DAY_PROFILE"
			FROM
			  (SELECT DISTINCT D.ACCOUNT_ID, D.SERVICE_LOCATION_ID, D.METER_ID, D.AGGREGATE_ID
				FROM CONTRACT_LIMIT A,
					CONTRACT_LIMIT_QUANTITY B,
					CONTRACT_ASSIGNMENT C,
					ACCOUNT_SERVICE D,
					SERVICE E
				WHERE B.LIMIT_ID = A.LIMIT_ID
					AND B.BEGIN_DATE <= p_END_DATE
					AND NVL(B.END_DATE, p_END_DATE) >= p_BEGIN_DATE
					AND C.CONTRACT_ID = B.CONTRACT_ID
					AND C.ENTITY_DOMAIN_ID IN(-170, -190)
					AND C.OWNER_ENTITY_ID IN(D.ACCOUNT_ID, D.METER_ID)
					AND E.MODEL_ID = p_MODEL_ID
					AND E.SCENARIO_ID = p_SCENARIO_ID
					AND E.AS_OF_DATE = v_AS_OF_DATE
					AND E.ACCOUNT_SERVICE_ID = D.ACCOUNT_SERVICE_ID) A,
				ACCOUNT B,
				SERVICE_LOCATION C,
				METER D
			WHERE B.ACCOUNT_ID = A.ACCOUNT_ID
				AND C.SERVICE_LOCATION_ID = A.SERVICE_LOCATION_ID
				AND D.METER_ID = A.METER_ID
			ORDER BY 1,3,5;
	END IF;
END TREE_NODES_LIMIT;
---------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNT_DETAIL
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_AGGREGATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_INCLUDE_TD_LOSSES IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the energy forecast for the specified account/meter over the time interval.
-- Request Type is "F", "B", or "U" for Forecast, Backcast, and Usage respectively.

v_SERVICE_LOCATION_ID NUMBER;
v_IS_CACHED BOOLEAN := FALSE;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_AS_OF_DATE DATE;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	v_SERVICE_LOCATION_ID := p_SERVICE_LOCATION_ID;
	IF v_SERVICE_LOCATION_ID < 0 THEN
		v_SERVICE_LOCATION_ID := GET_SERVICE_LOCATION_ID(p_ACCOUNT_ID, p_BEGIN_DATE);
	END IF;

	p_STATUS := GA.SUCCESS;

   IF p_REQUEST_TYPE = GA.ACTUAL_SERVICE THEN
		v_IS_CACHED := GA.ENABLE_EXTERNAL_METER_ACCESS AND IS_CACHED_USAGE(p_ACCOUNT_ID);
		IF v_IS_CACHED THEN
			XS.CACHE_USAGE(p_ACCOUNT_ID, p_SERVICE_LOCATION_ID, p_METER_ID, p_AGGREGATE_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_STATUS);
			IF NOT p_STATUS = GA.SUCCESS THEN
				ERRS.RAISE(MSGCODES.c_ERR_GENERAL,'CACHE_USAGE Returned Non-zero Status: ' || TO_CHAR(p_STATUS));
			END IF;
		END IF;
	ELSE
		v_IS_CACHED := FALSE;
	END IF;

	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_BEGIN_DATE, v_END_DATE);
	v_AS_OF_DATE := AS_OF_DATE_FOR_REQUEST(p_REQUEST_TYPE, p_AS_OF_DATE);

	FS.ENSURE_SERVICE_DETAILS(p_REQUEST_TYPE,
							p_MODEL_ID,
							p_SCENARIO_ID,
							p_EDC_ID,
							p_ESP_ID,
							NUMBER_COLLECTION(p_ACCOUNT_ID),
							v_BEGIN_DATE,
							v_END_DATE,
							v_AS_OF_DATE);

	IF IS_VERSIONED_REQUEST(p_REQUEST_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) THEN
		OPEN p_CURSOR FOR
			SELECT FROM_CUT_AS_HED(F.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, F.LOAD_CODE) "USAGE_DATE",
				SUM(DECODE(p_INCLUDE_TD_LOSSES, 0 , LOAD_VAL, LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL)) "USAGE_VAL"
			FROM ACCOUNT_SERVICE A, PROVIDER_SERVICE B, SERVICE C, SERVICE_DELIVERY D, SERVICE_LOAD F
			WHERE A.ACCOUNT_ID = p_ACCOUNT_ID
				AND (v_SERVICE_LOCATION_ID = g_NA_NODE OR A.SERVICE_LOCATION_ID = v_SERVICE_LOCATION_ID)
				AND (p_METER_ID = g_NA_NODE OR A.METER_ID = p_METER_ID)
				AND (p_AGGREGATE_ID = g_NA_NODE OR A.AGGREGATE_ID = p_AGGREGATE_ID)
				AND (p_EDC_ID = g_NA_BRANCH OR B.EDC_ID = p_EDC_ID)
				AND (p_ESP_ID = g_NA_BRANCH OR B.ESP_ID = p_ESP_ID)
				AND (p_PSE_ID = g_NA_BRANCH OR B.PSE_ID = p_PSE_ID)
				AND (p_POOL_ID = g_NA_BRANCH OR D.POOL_ID = p_POOL_ID)
				AND C.MODEL_ID = p_MODEL_ID
				AND C.SCENARIO_ID = p_SCENARIO_ID
				AND C.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
				AND C.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
				AND C.SERVICE_DELIVERY_ID = D.SERVICE_DELIVERY_ID
				AND C.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM SERVICE
					WHERE MODEL_ID = C.MODEL_ID
						AND SCENARIO_ID = C.SCENARIO_ID
						AND ACCOUNT_SERVICE_ID = C.ACCOUNT_SERVICE_ID
						AND PROVIDER_SERVICE_ID = C.PROVIDER_SERVICE_ID
						AND SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
						AND AS_OF_DATE <= v_AS_OF_DATE)
				AND F.SERVICE_ID = C.SERVICE_ID
				AND F.SERVICE_CODE = p_REQUEST_TYPE
				AND F.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND F.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
			GROUP BY FROM_CUT_AS_HED(F.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, F.LOAD_CODE)
			ORDER BY 1;
    ELSE
		OPEN p_CURSOR FOR
			SELECT FROM_CUT_AS_HED(F.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, F.LOAD_CODE) "USAGE_DATE",
				SUM(DECODE(p_INCLUDE_TD_LOSSES, 0 , LOAD_VAL, LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL)) "USAGE_VAL"
			FROM ACCOUNT_SERVICE A, PROVIDER_SERVICE B, SERVICE C, SERVICE_DELIVERY D, SERVICE_LOAD F
			WHERE A.ACCOUNT_ID = p_ACCOUNT_ID
				AND (v_SERVICE_LOCATION_ID = g_NA_NODE OR A.SERVICE_LOCATION_ID = v_SERVICE_LOCATION_ID)
				AND (p_METER_ID = g_NA_NODE OR A.METER_ID = p_METER_ID)
				AND (p_AGGREGATE_ID = g_NA_NODE OR A.AGGREGATE_ID = p_AGGREGATE_ID)
				AND (p_EDC_ID = g_NA_BRANCH OR B.EDC_ID = p_EDC_ID)
				AND (p_ESP_ID = g_NA_BRANCH OR B.ESP_ID = p_ESP_ID)
				AND (p_PSE_ID = g_NA_BRANCH OR B.PSE_ID = p_PSE_ID)
				AND (p_POOL_ID = g_NA_BRANCH OR D.POOL_ID = p_POOL_ID)
				AND C.MODEL_ID = p_MODEL_ID
				AND C.SCENARIO_ID = p_SCENARIO_ID
				AND C.AS_OF_DATE = v_AS_OF_DATE
				AND C.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
				AND C.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
				AND C.SERVICE_DELIVERY_ID = D.SERVICE_DELIVERY_ID
				AND F.SERVICE_ID = C.SERVICE_ID
				AND F.SERVICE_CODE = p_REQUEST_TYPE
				AND F.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND F.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
			GROUP BY FROM_CUT_AS_HED(F.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, F.LOAD_CODE)
			ORDER BY 1;
	END IF;

	IF v_IS_CACHED THEN
		XS.RELEASE_USAGE(p_ACCOUNT_ID, v_SERVICE_LOCATION_ID, p_METER_ID, p_AGGREGATE_ID, p_BEGIN_DATE, p_END_DATE);
	END IF;

END ACCOUNT_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNT_DETAIL
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_AGGREGATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_INCLUDE_TD_LOSSES NUMBER := 1;

BEGIN

	ACCOUNT_DETAIL(p_REQUEST_TYPE, p_MODEL_ID, p_SCENARIO_ID, p_EDC_ID, p_PSE_ID, p_ESP_ID, p_POOL_ID,
			p_ACCOUNT_ID, p_SERVICE_LOCATION_ID, p_METER_ID, p_AGGREGATE_ID, p_BEGIN_DATE,
			p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE, p_INTERVAL, v_INCLUDE_TD_LOSSES, p_STATUS, p_CURSOR);
END;
---------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNT_DETAIL_USAGE
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_AGGREGATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the metered usage for the specified account/meter over the time interval.

v_INCLUDE_TD_LOSSES NUMBER(1) := 0; -- Do not include Transmission and Distribution Losses in Actual Usage.
v_SERVICE_LOCATION_ID NUMBER;
v_PSE_ID NUMBER(2) := g_NA_BRANCH;
v_POOL_ID NUMBER(2) := g_NA_BRANCH;
v_CURSOR GA.REFCURSOR;
v_USAGE_DATE DATE;
v_USAGE_HED VARCHAR(32);
v_USAGE_VAL NUMBER(16,4);
v_HOUR NUMBER(2);
v_USAGE USAGE_TABLE := USAGE_TABLE();
v_REPEAT BOOLEAN;
v_SKIP BOOLEAN;


BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	v_SERVICE_LOCATION_ID := p_SERVICE_LOCATION_ID;
	IF v_SERVICE_LOCATION_ID < 0 THEN
		v_SERVICE_LOCATION_ID := GET_SERVICE_LOCATION_ID(p_ACCOUNT_ID, p_BEGIN_DATE);
	END IF;

	p_STATUS := GA.SUCCESS;

	ACCOUNT_DETAIL(GA.ACTUAL_SERVICE, p_MODEL_ID, p_SCENARIO_ID, p_EDC_ID, v_PSE_ID, p_ESP_ID, v_POOL_ID, p_ACCOUNT_ID, v_SERVICE_LOCATION_ID, p_METER_ID, p_AGGREGATE_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE, p_INTERVAL, v_INCLUDE_TD_LOSSES, p_STATUS, v_CURSOR);

	LOOP
		FETCH v_CURSOR INTO v_USAGE_HED, v_USAGE_VAL;
		EXIT WHEN v_CURSOR%NOTFOUND;
		v_REPEAT := FALSE;
		v_SKIP := FALSE;
		v_USAGE_DATE := FROM_CUT(DATE_TIME_AS_CUT(SUBSTR(v_USAGE_HED,1,10), SUBSTR(v_USAGE_HED,12), p_TIME_ZONE), p_TIME_ZONE);

		-- SPRING AHEAD DAY
		IF TRUNC(v_USAGE_DATE - 1/86400) = TRUNC(DST_SPRING_AHEAD_DATE(v_USAGE_DATE)) THEN
			v_HOUR :=TO_NUMBER(TO_CHAR(v_USAGE_DATE, 'HH24'));
			v_REPEAT := (GA.DST_SPRING_AHEAD_OPTION = 'A' AND v_HOUR = 1) OR (GA.DST_SPRING_AHEAD_OPTION = 'B' AND v_HOUR = 3);
		-- FALL BACK DAY
		ELSIF TRUNC(v_USAGE_DATE - 1/86400) = TRUNC(DST_FALL_BACK_DATE(v_USAGE_DATE)) THEN
			v_SKIP := TO_CHAR(v_USAGE_DATE, 'HH24:SS') = '02:01';
		END IF;

		IF NOT v_SKIP THEN -- IF v_SKIP, WE SKIP THE CURRENT HOUR.
			v_USAGE.EXTEND;
			v_USAGE(v_USAGE.LAST) := USAGE_TYPE(v_USAGE_DATE, v_USAGE_VAL);
		END IF;

		IF v_REPEAT THEN -- IF v_REPEAT, HERE WE REPEAT THE CURRENT HOUR A SECOND LATER, WITH A ZERO VALUE.
 			v_USAGE.EXTEND;
			v_USAGE(v_USAGE.LAST) := USAGE_TYPE(ADD_SECONDS_TO_DATE(v_USAGE_DATE,1), 0);
		END IF;

	END LOOP;
	CLOSE v_CURSOR;

	OPEN p_CURSOR FOR
		SELECT A.USAGE_DATE, A.USAGE_VAL
		FROM TABLE(CAST(v_USAGE AS USAGE_TABLE)) A
		ORDER BY 1;

END ACCOUNT_DETAIL_USAGE;
---------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNT_DETAIL_EXT
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_AGGREGATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_INCLUDE_TD_LOSSES IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the Energy Forecast, External Forecast and Difference
-- for the specified account/meter over the time interval.
-- Request Type is "F", "B", or "U" for Forecast, Backcast, and Usage respectively.

v_SERVICE_LOCATION_ID NUMBER;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_AS_OF_DATE DATE;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	v_SERVICE_LOCATION_ID := p_SERVICE_LOCATION_ID;
	IF v_SERVICE_LOCATION_ID < 0 THEN
		v_SERVICE_LOCATION_ID := GET_SERVICE_LOCATION_ID(p_ACCOUNT_ID, p_BEGIN_DATE);
	END IF;

	p_STATUS := GA.SUCCESS;

	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_BEGIN_DATE, v_END_DATE);
	v_AS_OF_DATE := AS_OF_DATE_FOR_REQUEST(p_REQUEST_TYPE, p_AS_OF_DATE);

	FS.ENSURE_SERVICE_DETAILS(p_REQUEST_TYPE,
							p_MODEL_ID,
							p_SCENARIO_ID,
							p_EDC_ID,
							p_ESP_ID,
							NUMBER_COLLECTION(p_ACCOUNT_ID),
							v_BEGIN_DATE,
							v_END_DATE,
							v_AS_OF_DATE);

	IF IS_VERSIONED_REQUEST(p_REQUEST_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) THEN
		OPEN p_CURSOR FOR
			SELECT FROM_CUT_AS_HED(F.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, F.LOAD_CODE) "LOAD_DATE",
					 MAX(DECODE(F.LOAD_CODE,GA.EXTERNAL,C.SERVICE_ID,-1)) "SERVICE_ID",
					 MAX(E.IS_EXTERNAL_FORECAST) "IS_EXTERNAL_FORECAST",
					 SUM(DECODE(F.LOAD_CODE,GA.STANDARD,DECODE(p_INCLUDE_TD_LOSSES, 0 , LOAD_VAL, LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL),0)) "INTERNAL_FORECAST",
					 SUM(DECODE(F.LOAD_CODE,GA.EXTERNAL,DECODE(p_INCLUDE_TD_LOSSES, 0 , LOAD_VAL, LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL),0)) "EXTERNAL_FORECAST",
					 SUM(DECODE(F.LOAD_CODE,GA.STANDARD,DECODE(p_INCLUDE_TD_LOSSES, 0 , LOAD_VAL, LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL),0)) -
					 					SUM(DECODE(F.LOAD_CODE,GA.EXTERNAL,DECODE(p_INCLUDE_TD_LOSSES, 0 , LOAD_VAL, LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL),0)) "DIFFERENCE"
			FROM ACCOUNT_SERVICE A, PROVIDER_SERVICE B, SERVICE C, SERVICE_DELIVERY D, SERVICE_STATE E, SERVICE_LOAD F
			WHERE A.ACCOUNT_ID = p_ACCOUNT_ID
				AND (v_SERVICE_LOCATION_ID = g_NA_NODE OR A.SERVICE_LOCATION_ID = v_SERVICE_LOCATION_ID)
				AND (p_METER_ID = g_NA_NODE OR A.METER_ID = p_METER_ID)
				AND (p_AGGREGATE_ID = g_NA_NODE OR A.AGGREGATE_ID = p_AGGREGATE_ID)
				AND (p_EDC_ID = g_NA_BRANCH OR B.EDC_ID = p_EDC_ID)
				AND (p_ESP_ID = g_NA_BRANCH OR B.ESP_ID = p_ESP_ID)
				AND (p_PSE_ID = g_NA_BRANCH OR B.PSE_ID = p_PSE_ID)
				AND (p_POOL_ID = g_NA_BRANCH OR D.POOL_ID = p_POOL_ID)
				AND C.MODEL_ID = p_MODEL_ID
				AND C.SCENARIO_ID = p_SCENARIO_ID
				AND C.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM SERVICE
					WHERE MODEL_ID = C.MODEL_ID
						AND SCENARIO_ID = C.SCENARIO_ID
						AND ACCOUNT_SERVICE_ID = C.ACCOUNT_SERVICE_ID
						AND PROVIDER_SERVICE_ID = C.PROVIDER_SERVICE_ID
						AND SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
						AND AS_OF_DATE <= v_AS_OF_DATE)
				AND C.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
				AND C.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
				AND C.SERVICE_DELIVERY_ID = D.SERVICE_DELIVERY_ID
				AND E.SERVICE_ID = C.SERVICE_ID
				AND E.SERVICE_CODE = p_REQUEST_TYPE
				AND E.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
				AND F.SERVICE_ID = E.SERVICE_ID
				AND F.SERVICE_CODE = p_REQUEST_TYPE
				AND F.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND F.LOAD_CODE IN (GA.EXTERNAL, GA.STANDARD)
				AND TRUNC(DECODE(p_MODEL_ID, GA.ELECTRIC_MODEL, FROM_CUT(F.LOAD_DATE, GA.LOCAL_TIME_ZONE) - g_SECOND, F.LOAD_DATE)) = TRUNC(E.SERVICE_DATE)
			GROUP BY FROM_CUT_AS_HED(F.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, F.LOAD_CODE)
			ORDER BY 1;
	ELSE
		OPEN p_CURSOR FOR
			SELECT FROM_CUT_AS_HED(F.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, F.LOAD_CODE) "LOAD_DATE",
					 MAX(DECODE(F.LOAD_CODE,GA.EXTERNAL,C.SERVICE_ID,-1)) "SERVICE_ID",
					 MAX(E.IS_EXTERNAL_FORECAST) "IS_EXTERNAL_FORECAST",
					 SUM(DECODE(F.LOAD_CODE,GA.STANDARD,DECODE(p_INCLUDE_TD_LOSSES, 0 , LOAD_VAL, LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL),0)) "INTERNAL_FORECAST",
					 SUM(DECODE(F.LOAD_CODE,GA.EXTERNAL,DECODE(p_INCLUDE_TD_LOSSES, 0 , LOAD_VAL, LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL),0)) "EXTERNAL_FORECAST",
					 SUM(DECODE(F.LOAD_CODE,GA.STANDARD,DECODE(p_INCLUDE_TD_LOSSES, 0 , LOAD_VAL, LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL),0)) -
					 					SUM(DECODE(F.LOAD_CODE,GA.EXTERNAL,DECODE(p_INCLUDE_TD_LOSSES, 0 , LOAD_VAL, LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL),0)) "DIFFERENCE"
			FROM ACCOUNT_SERVICE A, PROVIDER_SERVICE B, SERVICE C, SERVICE_DELIVERY D, SERVICE_STATE E, SERVICE_LOAD F
			WHERE A.ACCOUNT_ID = p_ACCOUNT_ID
				AND (v_SERVICE_LOCATION_ID = g_NA_NODE OR A.SERVICE_LOCATION_ID = v_SERVICE_LOCATION_ID)
				AND (p_METER_ID = g_NA_NODE OR A.METER_ID = p_METER_ID)
				AND (p_AGGREGATE_ID = g_NA_NODE OR A.AGGREGATE_ID = p_AGGREGATE_ID)
				AND (p_EDC_ID = g_NA_BRANCH OR B.EDC_ID = p_EDC_ID)
				AND (p_ESP_ID = g_NA_BRANCH OR B.ESP_ID = p_ESP_ID)
				AND (p_PSE_ID = g_NA_BRANCH OR B.PSE_ID = p_PSE_ID)
				AND (p_POOL_ID = g_NA_BRANCH OR D.POOL_ID = p_POOL_ID)
				AND C.MODEL_ID = p_MODEL_ID
				AND C.SCENARIO_ID = p_SCENARIO_ID
				AND C.AS_OF_DATE = v_AS_OF_DATE
				AND C.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
				AND C.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
				AND C.SERVICE_DELIVERY_ID = D.SERVICE_DELIVERY_ID
				AND E.SERVICE_ID = C.SERVICE_ID
				AND E.SERVICE_CODE = p_REQUEST_TYPE
				AND E.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
				AND F.SERVICE_ID = E.SERVICE_ID
				AND F.SERVICE_CODE = p_REQUEST_TYPE
				AND F.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND F.LOAD_CODE IN (GA.EXTERNAL, GA.STANDARD)
				AND TRUNC(DECODE(p_MODEL_ID, GA.ELECTRIC_MODEL, FROM_CUT(F.LOAD_DATE, GA.LOCAL_TIME_ZONE) - g_SECOND, F.LOAD_DATE)) = TRUNC(E.SERVICE_DATE)
			GROUP BY FROM_CUT_AS_HED(F.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, F.LOAD_CODE)
			ORDER BY 1;
	END IF;

END ACCOUNT_DETAIL_EXT;
---------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNT_SUMMARY
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the energy forecast sum for the specified
-- account/meters over the time interval and EDC/PSE/ESP relationship.
-- Request Type is "F", "B", or "U" for Forecast, Backcast, and Usage respectively.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_AS_OF_DATE DATE;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_BEGIN_DATE, v_END_DATE);

	v_AS_OF_DATE := AS_OF_DATE_FOR_REQUEST(p_REQUEST_TYPE, p_AS_OF_DATE);

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('ACCOUNT_SUMMARY');
		LOGS.LOG_DEBUG('REQUEST_TYPE=' || p_REQUEST_TYPE);
		LOGS.LOG_DEBUG('MODEL_ID=' || TO_CHAR(p_MODEL_ID));
		LOGS.LOG_DEBUG('SCENARIO_ID=' || TO_CHAR(p_SCENARIO_ID));
		LOGS.LOG_DEBUG('EDC_ID=' || TO_CHAR(p_EDC_ID));
		LOGS.LOG_DEBUG('PSE_ID=' || TO_CHAR(p_PSE_ID));
		LOGS.LOG_DEBUG('ESP_ID=' || TO_CHAR(p_ESP_ID));
		LOGS.LOG_DEBUG('POOL_ID=' || TO_CHAR(p_POOL_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TO_CHAR(p_END_DATE));
		LOGS.LOG_DEBUG('AS_OF_DATE=' || UT.TRACE_DATE(v_AS_OF_DATE));
		LOGS.LOG_DEBUG('TIME_ZONE=' || p_TIME_ZONE);
		LOGS.LOG_DEBUG('INTERVAL=' || p_INTERVAL);
	END IF;

	IF IS_VERSIONED_REQUEST(p_REQUEST_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) THEN
		OPEN p_CURSOR FOR
			SELECT FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, D.LOAD_CODE) "LOAD_DATE",
					 SUM((LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + NVL(UFE_LOAD_VAL,0))*E.ALLOCATION_PCT/100) "LOAD_VAL"
			FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, SERVICE_OBLIGATION_LOAD D, POOL_AND_POOL_SUB_POOL E
			WHERE (p_EDC_ID = g_NA_BRANCH OR B.EDC_ID = p_EDC_ID)
				AND (p_ESP_ID = g_NA_BRANCH OR B.ESP_ID = p_ESP_ID)
				AND (p_PSE_ID = g_NA_BRANCH OR B.PSE_ID = p_PSE_ID)
				AND E.POOL_ID = p_POOL_ID
				AND E.BEGIN_DATE <= p_END_DATE
				AND NVL(E.END_DATE, HIGH_DATE) >= p_BEGIN_DATE
				AND (p_POOL_ID = g_NA_BRANCH OR C.POOL_ID = E.SUB_POOL_ID)
				AND A.MODEL_ID = p_MODEL_ID
				AND A.SCENARIO_ID = p_SCENARIO_ID
				AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
				AND A.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
				AND D.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
				AND D.SERVICE_CODE = UPPER(SUBSTR(p_REQUEST_TYPE,1,1))
				AND D.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND D.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
				AND A.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM SERVICE_OBLIGATION
					WHERE MODEL_ID = A.MODEL_ID
						AND SCENARIO_ID = A.SCENARIO_ID
						AND PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
						AND SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
						AND AS_OF_DATE <= v_AS_OF_DATE)
			GROUP BY FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, D.LOAD_CODE)
			ORDER BY 1;
	ELSE
		OPEN p_CURSOR FOR
			SELECT FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, D.LOAD_CODE) "LOAD_DATE",
					 SUM((LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + NVL(UFE_LOAD_VAL,0))*E.ALLOCATION_PCT/100) "LOAD_VAL"
			FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, SERVICE_OBLIGATION_LOAD D, POOL_AND_POOL_SUB_POOL E
			WHERE (p_EDC_ID = g_NA_BRANCH OR B.EDC_ID = p_EDC_ID)
				AND (p_ESP_ID = g_NA_BRANCH OR B.ESP_ID = p_ESP_ID)
				AND (p_PSE_ID = g_NA_BRANCH OR B.PSE_ID = p_PSE_ID)
				AND E.POOL_ID = p_POOL_ID
				AND E.BEGIN_DATE <= p_END_DATE
				AND NVL(E.END_DATE, HIGH_DATE) >= p_BEGIN_DATE
				AND (p_POOL_ID = g_NA_BRANCH OR C.POOL_ID = E.SUB_POOL_ID)
				AND A.MODEL_ID = p_MODEL_ID
				AND A.SCENARIO_ID = p_SCENARIO_ID
				AND A.AS_OF_DATE = v_AS_OF_DATE
				AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
				AND A.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
				AND D.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
				AND D.SERVICE_CODE = UPPER(SUBSTR(p_REQUEST_TYPE,1,1))
				AND D.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND D.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
			GROUP BY FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, D.LOAD_CODE)
			ORDER BY 1;
	END IF;

END ACCOUNT_SUMMARY;
---------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNT_SUMMARY_USAGE
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SERVICE_POINT_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the metered usage for the specified
-- EDC for each account/sl/meter combination.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_AS_OF_DATE DATE;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	IF GA.ENABLE_EXTERNAL_METER_ACCESS THEN
		XS.CACHE_USAGE(p_ESP_ID, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, p_STATUS);
		IF NOT p_STATUS = GA.SUCCESS THEN
			ERRS.RAISE(MSGCODES.c_ERR_GENERAL,'CACHE_USAGE Returned Non-zero Status: ' || TO_CHAR(p_STATUS));
		END IF;
	END IF;

	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, TRUNC(p_BEGIN_DATE), TRUNC(p_END_DATE));

	v_AS_OF_DATE := AS_OF_DATE_FOR_REQUEST(p_REQUEST_TYPE, p_AS_OF_DATE);

	IF IS_VERSIONED_REQUEST(p_REQUEST_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) THEN
		OPEN p_CURSOR FOR
			SELECT B.EDC_ID, B.EDC_NAME, C.ESP_ID, C.ESP_NAME, D.ACCOUNT_ID, D.ACCOUNT_NAME, E.SERVICE_LOCATION_ID, E.SERVICE_LOCATION_NAME,
				F.METER_ID, F.METER_NAME, p_BEGIN_DATE "BEGIN_DATE", p_END_DATE "END_DATE", A.AGGREGATE_ID, A.METERED_USAGE, D.ACCOUNT_EXTERNAL_IDENTIFIER, A.NUMBER_OF_ZEROS
			FROM
 	          (SELECT  T.EDC_ID, T.ESP_ID, T.ACCOUNT_ID, T.SERVICE_LOCATION_ID, T.METER_ID, T.AGGREGATE_ID,
					SUM(METERED_USAGE) "METERED_USAGE", --exclude losses
					SUM(NUMBER_OF_ZEROS) "NUMBER_OF_ZEROS"
				FROM SERVICE_STATE E,
                    --Subquery to rollup hourly LOAD_DATES to daily to speed join with SERVICE_STATE - wjc - 30 Jun 03
                    (SELECT A.EDC_ID, A.ESP_ID, B.ACCOUNT_ID, B.SERVICE_LOCATION_ID, B.METER_ID, B.AGGREGATE_ID,
                           SDT.LOCAL_DAY_TRUNC_DATE "LOAD_DATE",
                           SUM(S.LOAD_VAL) "METERED_USAGE", --exclude losses
                           SUM(DECODE(S.LOAD_VAL,0,1,0)) "NUMBER_OF_ZEROS",
                           S.LOAD_CODE, S.SERVICE_CODE, S.SERVICE_ID
                    FROM SYSTEM_DATE_TIME SDT, PROVIDER_SERVICE A, ACCOUNT_SERVICE B, SERVICE C, SERVICE_DELIVERY D,SERVICE_LOAD S
					WHERE SDT.TIME_ZONE = p_TIME_ZONE
						AND SDT.DATA_INTERVAL_TYPE = p_MODEL_ID
						AND SDT.DAY_TYPE = '1'
						AND SDT.CUT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
						AND	A.EDC_ID = p_EDC_ID
						AND A.ESP_ID = p_ESP_ID
					    AND A.PSE_ID = A.PSE_ID
					    AND (p_SERVICE_POINT_ID IN(CONSTANTS.ALL_ID,  CONSTANTS.NOT_ASSIGNED) OR D.SERVICE_POINT_ID = p_SERVICE_POINT_ID)
					    AND C.MODEL_ID = p_MODEL_ID
					    AND C.SCENARIO_ID = p_SCENARIO_ID
					    AND C.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
					    AND C.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
					    AND C.SERVICE_DELIVERY_ID = D.SERVICE_DELIVERY_ID
					    AND C.AS_OF_DATE =
						    (SELECT MAX(AS_OF_DATE)
						    FROM SERVICE
						    WHERE MODEL_ID = C.MODEL_ID
								AND SCENARIO_ID = C.SCENARIO_ID
								AND ACCOUNT_SERVICE_ID = C.ACCOUNT_SERVICE_ID
								AND PROVIDER_SERVICE_ID = C.PROVIDER_SERVICE_ID
								AND SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
								AND AS_OF_DATE <= v_AS_OF_DATE)
						AND S.SERVICE_ID = C.SERVICE_ID
					    AND S.SERVICE_CODE = GA.ACTUAL_SERVICE
					    AND S.LOAD_DATE = SDT.CUT_DATE
					    AND S.LOAD_CODE = GA.STANDARD
                    GROUP BY
                           A.EDC_ID, A.ESP_ID, B.ACCOUNT_ID, B.SERVICE_LOCATION_ID, B.METER_ID, B.AGGREGATE_ID,
                           SDT.LOCAL_DAY_TRUNC_DATE,
                           S.LOAD_CODE, S.SERVICE_CODE, S.SERVICE_ID
                    ) T
				WHERE
					      E.SERVICE_ID = T.SERVICE_ID
					AND E.SERVICE_CODE = GA.ACTUAL_SERVICE
					AND E.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
					AND E.METER_TYPE = 'I'
					AND T.LOAD_DATE = E.SERVICE_DATE
				GROUP BY T.EDC_ID, T.ESP_ID, T.ACCOUNT_ID, T.SERVICE_LOCATION_ID, T.METER_ID, T.AGGREGATE_ID--
                ) A,
               ENERGY_DISTRIBUTION_COMPANY B,
				ENERGY_SERVICE_PROVIDER C,
				ACCOUNT D,
				SERVICE_LOCATION E,
				METER F
			WHERE B.EDC_ID = A.EDC_ID
				AND C.ESP_ID = A.ESP_ID
				AND D.ACCOUNT_ID(+) = A.ACCOUNT_ID
				AND E.SERVICE_LOCATION_ID = A.SERVICE_LOCATION_ID
				AND F.METER_ID = A.METER_ID
			ORDER BY ACCOUNT_NAME, SERVICE_LOCATION_NAME, METER_NAME;
	ELSE
		OPEN p_CURSOR FOR
			SELECT B.EDC_ID, B.EDC_NAME, C.ESP_ID, C.ESP_NAME, D.ACCOUNT_ID, D.ACCOUNT_NAME, E.SERVICE_LOCATION_ID, E.SERVICE_LOCATION_NAME,
				F.METER_ID, F.METER_NAME, p_BEGIN_DATE "BEGIN_DATE", p_END_DATE "END_DATE", A.AGGREGATE_ID, A.METERED_USAGE, D.ACCOUNT_EXTERNAL_IDENTIFIER, A.NUMBER_OF_ZEROS
			FROM
	          (SELECT  T.EDC_ID, T.ESP_ID, T.ACCOUNT_ID, T.SERVICE_LOCATION_ID, T.METER_ID, T.AGGREGATE_ID,
					SUM(METERED_USAGE) "METERED_USAGE", --exclude losses
					SUM(NUMBER_OF_ZEROS) "NUMBER_OF_ZEROS"
				FROM SERVICE_STATE E,
                    --Subquery to rollup hourly LOAD_DATES to daily to speed join with SERVICE_STATE - wjc - 30 Jun 03
                    (SELECT A.EDC_ID, A.ESP_ID, B.ACCOUNT_ID, B.SERVICE_LOCATION_ID, B.METER_ID, B.AGGREGATE_ID,
                           SDT.LOCAL_DAY_TRUNC_DATE "LOAD_DATE",
                           SUM(S.LOAD_VAL) "METERED_USAGE", --exclude losses
                           SUM(DECODE(S.LOAD_VAL,0,1,0)) "NUMBER_OF_ZEROS",
                           S.LOAD_CODE, S.SERVICE_CODE, S.SERVICE_ID
                    FROM SYSTEM_DATE_TIME SDT, PROVIDER_SERVICE A, ACCOUNT_SERVICE B, SERVICE C, SERVICE_DELIVERY D,SERVICE_LOAD S
					WHERE SDT.TIME_ZONE = p_TIME_ZONE
						AND SDT.DATA_INTERVAL_TYPE = p_MODEL_ID
						AND SDT.DAY_TYPE = '1'
						AND SDT.CUT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
						AND	A.EDC_ID = p_EDC_ID
						AND A.ESP_ID = p_ESP_ID
					    AND A.PSE_ID = A.PSE_ID
					    AND (p_SERVICE_POINT_ID IN(CONSTANTS.ALL_ID,  CONSTANTS.NOT_ASSIGNED) OR D.SERVICE_POINT_ID = p_SERVICE_POINT_ID)
					    AND C.MODEL_ID = p_MODEL_ID
					    AND C.SCENARIO_ID = p_SCENARIO_ID
					    AND C.AS_OF_DATE = v_AS_OF_DATE
					    AND C.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
					    AND C.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
					    AND C.SERVICE_DELIVERY_ID = D.SERVICE_DELIVERY_ID
					    AND S.SERVICE_ID = C.SERVICE_ID
					    AND S.SERVICE_CODE = GA.ACTUAL_SERVICE
					    AND S.LOAD_DATE = SDT.CUT_DATE
					    AND S.LOAD_CODE = GA.STANDARD
                    GROUP BY
                           A.EDC_ID, A.ESP_ID, B.ACCOUNT_ID, B.SERVICE_LOCATION_ID, B.METER_ID, B.AGGREGATE_ID,
                           SDT.LOCAL_DAY_TRUNC_DATE,
                           S.LOAD_CODE, S.SERVICE_CODE, S.SERVICE_ID
                    ) T
				WHERE E.SERVICE_ID = T.SERVICE_ID
					AND E.SERVICE_CODE = GA.ACTUAL_SERVICE
					AND E.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
					AND E.METER_TYPE = 'I'
					AND T.LOAD_DATE = E.SERVICE_DATE
				GROUP BY T.EDC_ID, T.ESP_ID, T.ACCOUNT_ID, T.SERVICE_LOCATION_ID, T.METER_ID, T.AGGREGATE_ID--
                ) A,
				ENERGY_DISTRIBUTION_COMPANY B,
				ENERGY_SERVICE_PROVIDER C,
				ACCOUNT D,
				SERVICE_LOCATION E,
				METER F
			WHERE B.EDC_ID = A.EDC_ID
				AND C.ESP_ID = A.ESP_ID
				AND D.ACCOUNT_ID(+) = A.ACCOUNT_ID
				AND E.SERVICE_LOCATION_ID = A.SERVICE_LOCATION_ID
				AND F.METER_ID = A.METER_ID
			ORDER BY ACCOUNT_NAME, SERVICE_LOCATION_NAME, METER_NAME;
	END IF;

	IF GA.ENABLE_EXTERNAL_METER_ACCESS THEN
    	XS.RELEASE_USAGE;
	END IF;

END ACCOUNT_SUMMARY_USAGE;
---------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNT_SUMMARY_EXT
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_INCLUDE_TD_LOSSES IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the energy forecast sum for the specified
-- account/meters over the time interval and EDC/PSE/ESP relationship.
-- Request Type is "F", "B", or "U" for Forecast, Backcast, and Usage respectively.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_AS_OF_DATE DATE;

BEGIN

 	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
 	END IF;

	p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_BEGIN_DATE, v_END_DATE);

	v_AS_OF_DATE := AS_OF_DATE_FOR_REQUEST(p_REQUEST_TYPE, p_AS_OF_DATE);

	IF IS_VERSIONED_REQUEST(p_REQUEST_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) THEN
		OPEN p_CURSOR FOR
			SELECT FROM_CUT_AS_HED(C.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID),
				SUM(DECODE(p_INCLUDE_TD_LOSSES, 0 , C.LOAD_VAL, C.LOAD_VAL + C.TX_LOSS_VAL + C.DX_LOSS_VAL)) / 1000.0 "INTERNAL_FORECAST",
				SUM(DECODE(p_INCLUDE_TD_LOSSES, 0 , NVL(D.LOAD_VAL,0), NVL(D.LOAD_VAL + D.TX_LOSS_VAL + D.DX_LOSS_VAL,0))) / 1000.0 "EXTERNAL_FORECAST",
				(SUM(DECODE(p_INCLUDE_TD_LOSSES, 0 , C.LOAD_VAL, C.LOAD_VAL + C.TX_LOSS_VAL + C.DX_LOSS_VAL))
					- SUM(DECODE(p_INCLUDE_TD_LOSSES, 0 , NVL(D.LOAD_VAL,0), NVL(D.LOAD_VAL + D.TX_LOSS_VAL + D.DX_LOSS_VAL,0)))) /1000.0 "DIFFERENCE"
			FROM PROVIDER_SERVICE A, SERVICE B, SERVICE_LOAD C,SERVICE_LOAD D, SERVICE_DELIVERY E
			WHERE (p_EDC_ID = g_NA_BRANCH OR A.EDC_ID = p_EDC_ID)
				AND (p_ESP_ID = g_NA_BRANCH OR A.ESP_ID = p_ESP_ID)
				AND (p_PSE_ID = g_NA_BRANCH OR A.PSE_ID = p_PSE_ID)
				AND (p_POOL_ID = g_NA_BRANCH OR E.POOL_ID = p_POOL_ID)
				AND B.MODEL_ID = p_MODEL_ID
				AND B.SCENARIO_ID = p_SCENARIO_ID
				AND B.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
				AND B.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
				AND B.SERVICE_DELIVERY_ID = E.SERVICE_DELIVERY_ID
				AND B.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM SERVICE
					WHERE MODEL_ID = B.MODEL_ID
						AND SCENARIO_ID = B.SCENARIO_ID
						AND ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
						AND PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
						AND SERVICE_DELIVERY_ID = B.SERVICE_DELIVERY_ID
						AND AS_OF_DATE <= v_AS_OF_DATE)
				AND C.SERVICE_ID = B.SERVICE_ID
				AND C.SERVICE_CODE = GA.FORECAST_SERVICE
				AND C.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND C.LOAD_CODE = GA.STANDARD
				AND D.SERVICE_ID(+) = C.SERVICE_ID
				AND D.SERVICE_CODE(+) = GA.FORECAST_SERVICE
				AND D.LOAD_DATE(+) = C.LOAD_DATE
				AND D.LOAD_CODE(+) = GA.EXTERNAL
			GROUP BY FROM_CUT_AS_HED(C.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID)
			ORDER BY 1;
	ELSE
		OPEN p_CURSOR FOR
			SELECT FROM_CUT_AS_HED(C.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID),
				SUM(DECODE(p_INCLUDE_TD_LOSSES, 0 , C.LOAD_VAL, C.LOAD_VAL + C.TX_LOSS_VAL + C.DX_LOSS_VAL)) / 1000.0 "INTERNAL_FORECAST",
				SUM(DECODE(p_INCLUDE_TD_LOSSES, 0 , NVL(D.LOAD_VAL,0), NVL(D.LOAD_VAL + D.TX_LOSS_VAL + D.DX_LOSS_VAL,0))) /1000.0 "EXTERNAL_FORECAST",
				(SUM(DECODE(p_INCLUDE_TD_LOSSES, 0 , C.LOAD_VAL, C.LOAD_VAL + C.TX_LOSS_VAL + C.DX_LOSS_VAL))
					- SUM(DECODE(p_INCLUDE_TD_LOSSES, 0 , NVL(D.LOAD_VAL,0), NVL(D.LOAD_VAL + D.TX_LOSS_VAL + D.DX_LOSS_VAL,0)))) /1000.0 "DIFFERENCE"
			FROM PROVIDER_SERVICE A, SERVICE B, SERVICE_LOAD C, SERVICE_LOAD D, SERVICE_DELIVERY E
			WHERE (p_EDC_ID = g_NA_BRANCH OR A.EDC_ID = p_EDC_ID)
				AND (p_ESP_ID = g_NA_BRANCH OR A.ESP_ID = p_ESP_ID)
				AND (p_PSE_ID = g_NA_BRANCH OR A.PSE_ID = p_PSE_ID)
				AND (p_POOL_ID = g_NA_BRANCH OR E.POOL_ID = p_POOL_ID)
				AND B.MODEL_ID = p_MODEL_ID
				AND B.SCENARIO_ID = p_SCENARIO_ID
				AND B.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
				AND B.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
				AND B.SERVICE_DELIVERY_ID = E.SERVICE_DELIVERY_ID
				AND B.AS_OF_DATE = v_AS_OF_DATE
				AND C.SERVICE_ID = B.SERVICE_ID
				AND C.SERVICE_CODE = GA.FORECAST_SERVICE
				AND C.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND C.LOAD_CODE = GA.STANDARD
				AND D.SERVICE_ID(+) = C.SERVICE_ID
				AND D.SERVICE_CODE(+) = GA.FORECAST_SERVICE
				AND D.LOAD_DATE(+) = C.LOAD_DATE
				AND D.LOAD_CODE(+) = GA.EXTERNAL
			GROUP BY FROM_CUT_AS_HED(C.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID)
			ORDER BY 1;
	END IF;

END ACCOUNT_SUMMARY_EXT;
---------------------------------------------------------------------------------------------------
PROCEDURE AGGREGATE_ACCOUNT_ENROLLMENT
    (
	p_REQUEST_TYPE IN CHAR,
	p_CASE_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_IS_ROLLUP IN NUMBER,
	p_INCLUDE_STANDARD_OFFER IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the accounts in service for the specified account, time interval and EDC/PSE/ESP relationship.
-- If IS_ROLLUP = 1, then show rolled up the the Account, instead of by Aggregate.

v_FACTOR_BASE NUMBER (1);

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

   IF GA.ENABLE_IN_FILL_AGG_ENROLLMENT THEN
		IN_FILL_AGGREGATE_ENROLLMENT(p_CASE_ID, p_ESP_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_STATUS);
		IF NOT p_STATUS = GA.SUCCESS THEN
			NULL_CURSOR(p_CURSOR);
			ERRS.RAISE(MSGCODES.c_ERR_GENERAL,'IN_FILL_AGGREGATE_ENROLLMENT Returned Non-zero Status: ' || TO_CHAR(p_STATUS));
		END IF;
	END IF;

	p_STATUS := GA.SUCCESS;
	IF GA.USAGE_FACTOR_PER_UNIT_OPTION THEN
		v_FACTOR_BASE := 1;
	ELSE
		v_FACTOR_BASE := 0;
	END IF;

	IF GA.VERSION_AGGREGATE_ACCOUNT_SVC  THEN
		OPEN p_CURSOR FOR
			SELECT ACCOUNT_NAME,
				DECODE(p_IS_ROLLUP, 1, -1 * ACCOUNT_ID, AGGREGATE_ID) AS AGGREGATE_ID,
				SERVICE_DATE,
				SUM(NVL(SERVICE_ACCOUNTS,0)) "ENROLLMENT",
				CASE WHEN SUM(NVL(SERVICE_ACCOUNTS,0)) = 0 THEN AVG(NVL(USAGE_FACTOR,0)) ELSE SUM(NVL(SERVICE_ACCOUNTS,0) * NVL(USAGE_FACTOR,0)) / SUM(NVL(SERVICE_ACCOUNTS,0)) END "USAGE_FACTOR", 
				SUM(NVL(SERVICE_ACCOUNTS,0) * (v_FACTOR_BASE + NVL(USAGE_FACTOR,0))) "WEIGHTED_ENROLLMENT"
			FROM AGGREGATE_ACCOUNTS A
			WHERE (p_EDC_ID = g_NA_BRANCH OR A.EDC_ID = p_EDC_ID)
				AND (p_ESP_ID = g_NA_BRANCH OR A.ESP_ID = p_ESP_ID)
				AND (p_PSE_ID = g_NA_BRANCH OR A.PSE_ID = p_PSE_ID)
				AND (p_POOL_ID = g_NA_BRANCH OR A.POOL_ID = p_POOL_ID)
				AND A.CASE_ID = p_CASE_ID
				AND A.AGGREGATE_ID = A.AGGREGATE_ID
				AND A.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
				AND A.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM AGGREGATE_ACCOUNTS
					WHERE CASE_ID = A.CASE_ID
						AND AGGREGATE_ID = A.AGGREGATE_ID
						AND SERVICE_DATE = A.SERVICE_DATE
						AND AS_OF_DATE <= p_AS_OF_DATE)
				AND NOT UPPER(SUBSTR(A.ESP_TYPE,1,1)) = DECODE(p_INCLUDE_STANDARD_OFFER,0,'S','@')
			GROUP BY ACCOUNT_NAME, DECODE(p_IS_ROLLUP, 1, -1 * ACCOUNT_ID, AGGREGATE_ID), SERVICE_DATE
			ORDER BY 1,2,3;
	ELSE
		OPEN p_CURSOR FOR
			SELECT ACCOUNT_NAME,
				DECODE(p_IS_ROLLUP, 1, -1 * ACCOUNT_ID, AGGREGATE_ID) AS AGGREGATE_ID,
				SERVICE_DATE,
				SUM(NVL(SERVICE_ACCOUNTS,0)) "ENROLLMENT",
				CASE WHEN SUM(NVL(SERVICE_ACCOUNTS,0)) = 0 THEN AVG(NVL(USAGE_FACTOR,0)) ELSE SUM(NVL(SERVICE_ACCOUNTS,0) * NVL(USAGE_FACTOR,0)) / SUM(NVL(SERVICE_ACCOUNTS,0)) END "USAGE_FACTOR", 
				SUM(NVL(SERVICE_ACCOUNTS,0) * (v_FACTOR_BASE + NVL(USAGE_FACTOR,0))) "WEIGHTED_ENROLLMENT"
			FROM AGGREGATE_ACCOUNTS A
			WHERE (p_EDC_ID = g_NA_BRANCH OR A.EDC_ID = p_EDC_ID)
				AND (p_ESP_ID = g_NA_BRANCH OR A.ESP_ID = p_ESP_ID)
				AND (p_PSE_ID = g_NA_BRANCH OR A.PSE_ID = p_PSE_ID)
				AND (p_POOL_ID = g_NA_BRANCH OR A.POOL_ID = p_POOL_ID)
				AND A.CASE_ID = p_CASE_ID
				AND A.AGGREGATE_ID = A.AGGREGATE_ID
				AND A.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
				AND A.AS_OF_DATE = CONSTANTS.LOW_DATE
				AND NOT UPPER(SUBSTR(A.ESP_TYPE,1,1)) = DECODE(p_INCLUDE_STANDARD_OFFER,0,'S','@')
			GROUP BY ACCOUNT_NAME, DECODE(p_IS_ROLLUP, 1, -1 * ACCOUNT_ID, AGGREGATE_ID), SERVICE_DATE
			ORDER BY 1,2,3;
	END IF;

END AGGREGATE_ACCOUNT_ENROLLMENT;
---------------------------------------------------------------------------------------------------
PROCEDURE NON_AGGREGATE_ENROLLMENT
    (
	p_REQUEST_TYPE IN CHAR,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INCLUDE_STANDARD_OFFER IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the accounts in service for the specified
-- account, time interval and EDC/PSE/ESP relationship.

v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;
	v_BEGIN_DATE := TRUNC(p_BEGIN_DATE);
	v_END_DATE := TRUNC(p_END_DATE);

	OPEN p_CURSOR FOR
        SELECT B.ESP_NAME, A.ACCOUNT_NAME, C.SERVICE_LOCATION_NAME, D.METER_NAME, A.BEGIN_DATE, A.END_DATE, A.ACCOUNT_EXTERNAL_IDENTIFIER
		FROM
		    (
			SELECT DISTINCT C.ESP_ID "ESP_ID",
				A.ACCOUNT_ID,
			   A.ACCOUNT_NAME "ACCOUNT_NAME",
				E.SERVICE_LOCATION_ID "SERVICE_LOCATION_ID",
				NVL(F.METER_ID,0) "METER_ID",
				C.BEGIN_DATE "BEGIN_DATE",
				C.END_DATE "END_DATE",
				A.ACCOUNT_EXTERNAL_IDENTIFIER "ACCOUNT_EXTERNAL_IDENTIFIER"
			FROM ACCOUNT A,
			    ACCOUNT_EDC B,
			    ACCOUNT_ESP C,
				PSE_ESP D,
				ACCOUNT_SERVICE_LOCATION E,
				SERVICE_LOCATION_METER F,
				ACCOUNT_STATUS G,
				ACCOUNT_STATUS_NAME STATUS_NAME
			WHERE A.IS_AGGREGATE_ACCOUNT = 0
				AND A.IS_SUB_AGGREGATE = 0
				AND B.ACCOUNT_ID = A.ACCOUNT_ID
				AND (p_EDC_ID = g_NA_BRANCH OR B.EDC_ID = p_EDC_ID)
				AND B.BEGIN_DATE <= v_END_DATE  AND NVL(B.END_DATE, v_BEGIN_DATE) >=  v_BEGIN_DATE
				AND B.ACCOUNT_ID = A.ACCOUNT_ID
				AND C.ACCOUNT_ID = A.ACCOUNT_ID
				AND (p_ESP_ID = g_NA_BRANCH OR C.ESP_ID = p_ESP_ID)
				AND (p_POOL_ID = g_NA_BRANCH OR C.POOL_ID = p_POOL_ID)
				AND C.BEGIN_DATE <= v_END_DATE  AND NVL(C.END_DATE, v_BEGIN_DATE) >=  v_BEGIN_DATE
				AND D.ESP_ID = C.ESP_ID
				AND NVL(C.BEGIN_DATE, LOW_DATE) <= NVL(D.END_DATE, HIGH_DATE) AND NVL(C.END_DATE, HIGH_DATE) >= NVL(D.BEGIN_DATE, LOW_DATE)
				AND (p_PSE_ID = g_NA_BRANCH OR D.PSE_ID = p_PSE_ID)
			    AND D.BEGIN_DATE <= v_END_DATE  AND NVL(D.END_DATE, v_BEGIN_DATE) >=   v_BEGIN_DATE
				AND E.ACCOUNT_ID = A.ACCOUNT_ID
			    AND E.BEGIN_DATE <= v_END_DATE  AND NVL(E.END_DATE, v_BEGIN_DATE) >=   v_BEGIN_DATE
				AND F.SERVICE_LOCATION_ID(+) = E.SERVICE_LOCATION_ID
				AND STATUS_NAME.STATUS_NAME = G.STATUS_NAME
				AND STATUS_NAME.IS_ACTIVE = 1
				AND G.BEGIN_DATE <= v_END_DATE AND NVL(G.END_DATE, v_BEGIN_DATE) >=  v_BEGIN_DATE
				AND G.ACCOUNT_ID = A.ACCOUNT_ID
				 )  A,
		    ENERGY_SERVICE_PROVIDER B,
			SERVICE_LOCATION C,
			METER D
		WHERE B.ESP_ID = A.ESP_ID
			AND NOT UPPER(SUBSTR(B.ESP_TYPE,1,1)) = DECODE(p_INCLUDE_STANDARD_OFFER,0,'S','@')
		    AND C.SERVICE_LOCATION_ID = A.SERVICE_LOCATION_ID
			AND D.METER_ID = A.METER_ID
			ORDER BY 1,2,3,4;

END NON_AGGREGATE_ENROLLMENT;
---------------------------------------------------------------------------------------------------
PROCEDURE NON_AGG_ENROLLMENT_BY_ACCOUNT
    (
	p_REQUEST_TYPE IN CHAR,
	p_ACCOUNT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INCLUDE_STANDARD_OFFER IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the accounts in service for the specified
-- account, time interval and EDC/PSE/ESP relationship.

v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;
	v_BEGIN_DATE := TRUNC(p_BEGIN_DATE);
	v_END_DATE := TRUNC(p_END_DATE);

	OPEN p_CURSOR FOR
        SELECT B.ESP_NAME, A.ACCOUNT_NAME, C.SERVICE_LOCATION_NAME, D.METER_NAME, A.BEGIN_DATE, A.END_DATE, A.ACCOUNT_EXTERNAL_IDENTIFIER
		FROM
		    (
			SELECT DISTINCT C.ESP_ID "ESP_ID",
				A.ACCOUNT_ID,
			   A.ACCOUNT_NAME "ACCOUNT_NAME",
				E.SERVICE_LOCATION_ID "SERVICE_LOCATION_ID",
				NVL(F.METER_ID,0) "METER_ID",
				C.BEGIN_DATE "BEGIN_DATE",
				C.END_DATE "END_DATE",
				A.ACCOUNT_EXTERNAL_IDENTIFIER "ACCOUNT_EXTERNAL_IDENTIFIER"
			FROM ACCOUNT A,
				ACCOUNT_STATUS B,
				ACCOUNT_STATUS_NAME STATUS_NAME,
			   ACCOUNT_ESP C,
				ACCOUNT_SERVICE_LOCATION E,
				SERVICE_LOCATION_METER F
			WHERE A.IS_AGGREGATE_ACCOUNT = 0
				AND A.IS_SUB_AGGREGATE = 0
				AND A.ACCOUNT_ID = p_ACCOUNT_ID
				AND STATUS_NAME.STATUS_NAME = B.STATUS_NAME
				AND STATUS_NAME.IS_ACTIVE = 1
			   AND B.BEGIN_DATE <= v_END_DATE AND NVL(B.END_DATE, v_BEGIN_DATE) >=  v_BEGIN_DATE
				AND B.ACCOUNT_ID = A.ACCOUNT_ID
				AND C.ACCOUNT_ID = p_ACCOUNT_ID
				AND C.BEGIN_DATE <= v_END_DATE  AND NVL(C.END_DATE, v_BEGIN_DATE) >=  v_BEGIN_DATE
				AND E.ACCOUNT_ID = p_ACCOUNT_ID
			   AND E.BEGIN_DATE <= v_END_DATE  AND NVL(E.END_DATE, v_BEGIN_DATE) >=   v_BEGIN_DATE
				AND F.SERVICE_LOCATION_ID(+) = E.SERVICE_LOCATION_ID
				 )  A,
		    ENERGY_SERVICE_PROVIDER B,
			SERVICE_LOCATION C,
			METER D
		WHERE B.ESP_ID = A.ESP_ID
			AND NOT UPPER(SUBSTR(B.ESP_TYPE,1,1)) = DECODE(p_INCLUDE_STANDARD_OFFER,0,'S','@')
		    AND C.SERVICE_LOCATION_ID = A.SERVICE_LOCATION_ID
			AND D.METER_ID = A.METER_ID
			ORDER BY 1,2,3,4;

END NON_AGG_ENROLLMENT_BY_ACCOUNT;
---------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNT_ENROLLMENT
    (
	p_REQUEST_TYPE IN CHAR,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INCLUDE_STANDARD_OFFER IN NUMBER,
	p_STATUS OUT NUMBER,
	p_SERVICE_DATE IN OUT GA.DATE_TABLE,
	p_SERVICE_ACCOUNTS IN OUT GA.NUMBER_TABLE
	) AS

-- Answer a recordset containing the accounts in service for the specified
-- account, time interval and EDC/PSE/ESP relationship.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_SERVICE_DATE DATE;
v_BEGIN BINARY_INTEGER;
v_END BINARY_INTEGER;
v_INDEX BINARY_INTEGER;

CURSOR c_ENROLLMENT IS
	SELECT GREATEST(GREATEST(GREATEST(EDC_BEGIN_DATE,ESP_BEGIN_DATE),PSE_BEGIN_DATE), v_BEGIN_DATE) "BEGIN_DATE",
		LEAST(LEAST(LEAST(NVL(EDC_END_DATE, v_END_DATE),NVL(ESP_END_DATE, v_END_DATE)), NVL(PSE_END_DATE, v_END_DATE)), v_END_DATE) "END_DATE",
		COUNT(*) "COUNT"
		FROM NON_AGGREGATE_ACCOUNTS
		WHERE (p_EDC_ID = g_NA_BRANCH OR EDC_ID = p_EDC_ID)
			AND (p_ESP_ID = g_NA_BRANCH OR ESP_ID = p_ESP_ID)
			AND (p_PSE_ID = g_NA_BRANCH OR PSE_ID = p_PSE_ID)
			AND (p_POOL_ID = g_NA_BRANCH OR POOL_ID = p_POOL_ID)
			AND EDC_BEGIN_DATE <= v_END_DATE
			AND NVL(EDC_END_DATE, v_END_DATE) >= v_BEGIN_DATE
			AND ESP_BEGIN_DATE <= v_END_DATE
			AND NVL(ESP_END_DATE, v_END_DATE) >= v_BEGIN_DATE
			AND PSE_BEGIN_DATE <= v_END_DATE
			AND NVL(PSE_END_DATE, v_END_DATE) >= v_BEGIN_DATE
			AND NOT UPPER(SUBSTR(ESP_TYPE,1,1)) = DECODE(p_INCLUDE_STANDARD_OFFER,0,'S','@')
	GROUP BY GREATEST(GREATEST(GREATEST(EDC_BEGIN_DATE,ESP_BEGIN_DATE),PSE_BEGIN_DATE), v_BEGIN_DATE),
		LEAST(LEAST(LEAST(NVL(EDC_END_DATE, v_END_DATE),NVL(ESP_END_DATE, v_END_DATE)), NVL(PSE_END_DATE, v_END_DATE)), v_END_DATE);

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;
	v_BEGIN_DATE := TRUNC(p_BEGIN_DATE);
	v_END_DATE := GREATEST(TRUNC(p_END_DATE), v_BEGIN_DATE);
	v_SERVICE_DATE := v_BEGIN_DATE;

    FOR v_INDEX IN 1..(v_END_DATE - v_BEGIN_DATE + 1) LOOP
		p_SERVICE_DATE(v_INDEX) := v_SERVICE_DATE;
		p_SERVICE_ACCOUNTS(v_INDEX) := 0;
		v_SERVICE_DATE := v_SERVICE_DATE + 1;
	END LOOP;

	FOR v_ENROLLMENT IN c_ENROLLMENT LOOP
		v_BEGIN := v_ENROLLMENT.BEGIN_DATE - v_BEGIN_DATE + 1;
		v_END := v_ENROLLMENT.END_DATE - v_BEGIN_DATE + 1;
	    FOR v_INDEX IN v_BEGIN..v_END LOOP
			p_SERVICE_ACCOUNTS(v_INDEX) := p_SERVICE_ACCOUNTS(v_INDEX) + v_ENROLLMENT.COUNT;
		END LOOP;
	END LOOP;

END ACCOUNT_ENROLLMENT;
---------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNT_ENROLLMENT_SUMMARY
    (
	p_REQUEST_TYPE IN CHAR,
	p_CASE_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_INCLUDE_STANDARD_OFFER IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the aggreagate and non-aggregate
-- account service counts by day over the specified time
-- interval and EDC/PSE/ESP relationship.

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

   IF GA.ENABLE_IN_FILL_AGG_ENROLLMENT THEN
		IN_FILL_AGGREGATE_ENROLLMENT(p_CASE_ID, p_ESP_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_STATUS);
		IF NOT p_STATUS = GA.SUCCESS THEN
			NULL_CURSOR(p_CURSOR);
			ERRS.RAISE(MSGCODES.c_ERR_GENERAL,'IN_FILL_AGGREGATE_ENROLLMENT Returned Non-zero Status: ' || TO_CHAR(p_STATUS));
		END IF;
	END IF;

	p_STATUS := GA.SUCCESS;

	IF GA.VERSION_AGGREGATE_ACCOUNT_SVC  THEN
		OPEN p_CURSOR FOR
			SELECT SERVICE_DATE,
				SUM(DECODE(AGGREGATE_ID,0,SERVICE_ACCOUNTS,0)) "NON_AGGREGATE_ACCOUNTS",
				SUM(DECODE(AGGREGATE_ID,0,0,SERVICE_ACCOUNTS)) "AGGREGATE_ACCOUNTS"
			FROM AGGREGATE_ACCOUNTS A
			WHERE (p_EDC_ID = g_NA_BRANCH OR A.EDC_ID = p_EDC_ID)
				AND (p_ESP_ID = g_NA_BRANCH OR A.ESP_ID = p_ESP_ID)
				AND (p_PSE_ID = g_NA_BRANCH OR A.PSE_ID = p_PSE_ID)
				AND (p_POOL_ID = g_NA_BRANCH OR A.POOL_ID = p_POOL_ID)
				AND A.CASE_ID = p_CASE_ID
				AND A.AGGREGATE_ID = A.AGGREGATE_ID
				AND A.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
				AND A.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM AGGREGATE_ACCOUNTS
					WHERE CASE_ID = A.CASE_ID
						AND AGGREGATE_ID = A.AGGREGATE_ID
						AND SERVICE_DATE = A.SERVICE_DATE
						AND AS_OF_DATE <= p_AS_OF_DATE)
				AND NOT UPPER(SUBSTR(A.ESP_TYPE,1,1)) = DECODE(p_INCLUDE_STANDARD_OFFER,0,'S','@')
			GROUP BY SERVICE_DATE
			ORDER BY 1;
	ELSE
		OPEN p_CURSOR FOR
			SELECT SERVICE_DATE,
				SUM(DECODE(AGGREGATE_ID,0,SERVICE_ACCOUNTS,0)) "NON_AGGREGATE_ACCOUNTS",
				SUM(DECODE(AGGREGATE_ID,0,0,SERVICE_ACCOUNTS)) "AGGREGATE_ACCOUNTS"
			FROM AGGREGATE_ACCOUNTS A
			WHERE (p_EDC_ID = g_NA_BRANCH OR A.EDC_ID = p_EDC_ID)
				AND (p_ESP_ID = g_NA_BRANCH OR A.ESP_ID = p_ESP_ID)
				AND (p_PSE_ID = g_NA_BRANCH OR A.PSE_ID = p_PSE_ID)
				AND (p_POOL_ID = g_NA_BRANCH OR A.POOL_ID = p_POOL_ID)
				AND A.CASE_ID = p_CASE_ID
				AND A.AGGREGATE_ID = A.AGGREGATE_ID
				AND A.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
				AND A.AS_OF_DATE = CONSTANTS.LOW_DATE
				AND NOT UPPER(SUBSTR(A.ESP_TYPE,1,1)) = DECODE(p_INCLUDE_STANDARD_OFFER,0,'S','@')
			GROUP BY SERVICE_DATE
			ORDER BY 1;
	END IF;

END ACCOUNT_ENROLLMENT_SUMMARY;
---------------------------------------------------------------------------------------------------
PROCEDURE ENROLLMENT_SUMMARY
    (
	p_REQUEST_TYPE IN CHAR,
	p_CASE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_INCLUDE_STANDARD_OFFER IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the accounts in service for the specified
-- account, time interval and EDC/PSE/ESP relationship.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_SERVICE_DATE DATE;
v_ENROLLMENT_SUMMARY_TABLE ENROLLMENT_SUMMARY_TABLE := ENROLLMENT_SUMMARY_TABLE();


CURSOR c_ENROLLMENT IS
	SELECT GREATEST(GREATEST(ESP_BEGIN_DATE,PSE_BEGIN_DATE), v_BEGIN_DATE) "BEGIN_DATE",
		LEAST(LEAST(NVL(ESP_END_DATE, v_END_DATE), NVL(PSE_END_DATE, v_END_DATE)), v_END_DATE) "END_DATE",
		ESP_ID, ESP_NAME, COUNT(*) "COUNT"
		FROM NON_AGGREGATE_ACCOUNTS
		WHERE EDC_BEGIN_DATE <= v_END_DATE
			AND NVL(EDC_END_DATE, v_END_DATE) >= v_BEGIN_DATE
			AND ESP_BEGIN_DATE <= v_END_DATE
			AND NVL(ESP_END_DATE, v_END_DATE) >= v_BEGIN_DATE
			AND PSE_BEGIN_DATE <= v_END_DATE
			AND NVL(PSE_END_DATE, v_END_DATE) >= v_BEGIN_DATE
			AND NOT UPPER(SUBSTR(ESP_TYPE,1,1)) = DECODE(p_INCLUDE_STANDARD_OFFER,0,'S','@')
		GROUP BY GREATEST(GREATEST(ESP_BEGIN_DATE,PSE_BEGIN_DATE), v_BEGIN_DATE),
			LEAST(LEAST(NVL(ESP_END_DATE, v_END_DATE), NVL(PSE_END_DATE, v_END_DATE)), v_END_DATE), ESP_ID, ESP_NAME;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;
	v_BEGIN_DATE := TRUNC(p_BEGIN_DATE);
	v_END_DATE := GREATEST(TRUNC(p_END_DATE), v_BEGIN_DATE);
	v_SERVICE_DATE := v_BEGIN_DATE;

	--SELECT THE AGGREGATE ENROLLMENT INTO THE TABLE
	IF GA.VERSION_AGGREGATE_ACCOUNT_SVC  THEN
			SELECT ENROLLMENT_SUMMARY_TYPE(A.ESP_ID, A.ESP_NAME, A.SERVICE_DATE,
				SUM(DECODE(AGGREGATE_ID,0,0,SERVICE_ACCOUNTS))) "AGGREGATE_ACCOUNTS"
			BULK COLLECT INTO v_ENROLLMENT_SUMMARY_TABLE
			FROM AGGREGATE_ACCOUNTS A
			WHERE A.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
				AND A.CASE_ID = p_CASE_ID
				AND A.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM AGGREGATE_ACCOUNTS
					WHERE CASE_ID = A.CASE_ID
						AND AGGREGATE_ID = A.AGGREGATE_ID
						AND SERVICE_DATE = A.SERVICE_DATE
						AND AS_OF_DATE <= p_AS_OF_DATE)
				AND NOT UPPER(SUBSTR(A.ESP_TYPE,1,1)) = DECODE(p_INCLUDE_STANDARD_OFFER,0,'S','@')
			GROUP BY ESP_ID, ESP_NAME, SERVICE_DATE;
	ELSE
			SELECT ENROLLMENT_SUMMARY_TYPE(A.ESP_ID, A.ESP_NAME, A.SERVICE_DATE,
				SUM(DECODE(AGGREGATE_ID,0,0,SERVICE_ACCOUNTS))) "AGGREGATE_ACCOUNTS"
			BULK COLLECT INTO v_ENROLLMENT_SUMMARY_TABLE
			FROM AGGREGATE_ACCOUNTS A
			WHERE A.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
				AND A.CASE_ID = p_CASE_ID
				AND A.AS_OF_DATE = LOW_DATE
				AND NOT UPPER(SUBSTR(A.ESP_TYPE,1,1)) = DECODE(p_INCLUDE_STANDARD_OFFER,0,'S','@')
			GROUP BY ESP_ID, ESP_NAME, SERVICE_DATE;
	END IF;


	--ADD IN THE NON-AGGREGATE ENROLLMENT
	FOR v_ENROLLMENT IN c_ENROLLMENT LOOP
		v_SERVICE_DATE := v_ENROLLMENT.BEGIN_DATE;
		WHILE v_SERVICE_DATE <= v_ENROLLMENT.END_DATE LOOP
			 v_ENROLLMENT_SUMMARY_TABLE.EXTEND;
			 v_ENROLLMENT_SUMMARY_TABLE(v_ENROLLMENT_SUMMARY_TABLE.LAST) := ENROLLMENT_SUMMARY_TYPE(v_ENROLLMENT.ESP_ID, v_ENROLLMENT.ESP_NAME, v_SERVICE_DATE, v_ENROLLMENT.COUNT);
			 v_SERVICE_DATE := v_SERVICE_DATE + 1;
		END LOOP;
	END LOOP;

	--SUM IT ALL UP AND RETURN IT
	OPEN p_CURSOR FOR
	  SELECT A.ESP_ID, A.ESP_NAME, FROM_CUT_AS_HED(A.SERVICE_DATE, GA.LOCAL_TIME_ZONE, 'DD',2) AS SERVICE_DATE, SUM(A.ENROLLMENT) AS ENROLLMENT
	  FROM TABLE(CAST(v_ENROLLMENT_SUMMARY_TABLE AS ENROLLMENT_SUMMARY_TABLE)) A
	  GROUP BY A.ESP_ID, A.ESP_NAME, FROM_CUT_AS_HED(A.SERVICE_DATE, GA.LOCAL_TIME_ZONE, 'DD',2)
	  ORDER BY 2,3;

END ENROLLMENT_SUMMARY;
---------------------------------------------------------------------------------------------------
PROCEDURE AGGREGATE_ACCOUNT_UPDATE
    (
	p_REQUEST_TYPE IN CHAR,
	p_CASE_ID IN NUMBER,
	p_UPDATE_TYPE IN VARCHAR,
	p_DATA_TRIPLES IN VARCHAR,
	p_DATE_FORMAT IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS

-- Update the aggregate accounts in service for the specified aggregate id, date and count triples.

v_STRING_TABLE GA.STRING_TABLE;
v_LINE_TABLE GA.STRING_TABLE;
v_INDEX BINARY_INTEGER;
v_AGGREGATE_ID NUMBER;
v_SERVICE_DATE DATE;
v_SERVICE_ACCOUNTS AGGREGATE_ACCOUNT_SERVICE.SERVICE_ACCOUNTS%TYPE;
v_USAGE_FACTOR AGGREGATE_ACCOUNT_SERVICE.USAGE_FACTOR%TYPE;
v_UPDATE_TYPE CHAR(1);
v_AS_OF_DATE DATE;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	IF NOT GA.VERSION_AGGREGATE_ACCOUNT_SVC THEN
		v_AS_OF_DATE := LOW_DATE;
	ELSE
		v_AS_OF_DATE := CORRECTED_AS_OF_DATE(p_AS_OF_DATE);
	END IF;

	SELECT UPPER(SUBSTR(p_UPDATE_TYPE,1,1)) INTO v_UPDATE_TYPE FROM DUAL;
	UT.TOKENS_FROM_STRING(p_DATA_TRIPLES,';', v_STRING_TABLE);
	v_INDEX := v_STRING_TABLE.FIRST;

 	LOOP
		UT.TOKENS_FROM_STRING(v_STRING_TABLE(v_INDEX),',', v_LINE_TABLE);

		v_AGGREGATE_ID := TO_NUMBER(v_LINE_TABLE(1));
		v_SERVICE_DATE := TRUNC(TO_DATE(v_LINE_TABLE(2), p_DATE_FORMAT));
		v_SERVICE_ACCOUNTS := NULL;
		v_USAGE_FACTOR := NULL;
		IF v_UPDATE_TYPE = 'E' THEN
		    v_SERVICE_ACCOUNTS := TO_NUMBER(v_LINE_TABLE(3));
		ELSE
		    v_USAGE_FACTOR := TO_NUMBER(v_LINE_TABLE(3));
		END IF;

		UPDATE AGGREGATE_ACCOUNT_SERVICE
		SET SERVICE_ACCOUNTS = NVL(v_SERVICE_ACCOUNTS, SERVICE_ACCOUNTS),
		    USAGE_FACTOR = NVL(v_USAGE_FACTOR, USAGE_FACTOR)
		WHERE CASE_ID = p_CASE_ID
			AND AGGREGATE_ID = v_AGGREGATE_ID
		   AND SERVICE_DATE = v_SERVICE_DATE
			AND AS_OF_DATE = v_AS_OF_DATE;

		IF SQL%NOTFOUND THEN
		    INSERT INTO AGGREGATE_ACCOUNT_SERVICE(
			   CASE_ID,
				AGGREGATE_ID,
				SERVICE_DATE,
				AS_OF_DATE,
				SERVICE_ACCOUNTS,
				USAGE_FACTOR)
			VALUES(
				p_CASE_ID,
			   v_AGGREGATE_ID,
				v_SERVICE_DATE,
				v_AS_OF_DATE,
				v_SERVICE_ACCOUNTS,
				v_USAGE_FACTOR);
		END IF;

		IF p_STATUS < GA.SUCCESS THEN
			ROLLBACK;
			RETURN;
		END IF;

		EXIT WHEN v_INDEX = v_STRING_TABLE.LAST;
		v_INDEX := v_STRING_TABLE.NEXT(v_INDEX);
	END LOOP;

    p_STATUS := GA.SUCCESS;

END AGGREGATE_ACCOUNT_UPDATE;
---------------------------------------------------------------------------------------------------
PROCEDURE EDC_SUMMARY
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_INCLUDE_UFE IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the total forecast results for an EDC
-- Request Type is "F", "B", or "U" for Forecast, Backcast, and Usage respectively.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_AS_OF_DATE DATE;
v_REQUEST_TYPE CHAR(1) := UPPER(SUBSTR(p_REQUEST_TYPE,1,1));

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_BEGIN_DATE, v_END_DATE);

	v_AS_OF_DATE := AS_OF_DATE_FOR_REQUEST(p_REQUEST_TYPE, p_AS_OF_DATE);

	IF IS_VERSIONED_REQUEST(v_REQUEST_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) THEN
		OPEN p_CURSOR FOR
			SELECT EDC_ID, FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE),
				SUM(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)),
				MIN(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)),
				MAX(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)),
				AVG(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0))
			FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_OBLIGATION_LOAD D
			WHERE (p_EDC_ID = CONSTANTS.ALL_ID OR B.EDC_ID = p_EDC_ID)
				AND A.MODEL_ID = p_MODEL_ID
				AND A.SCENARIO_ID = p_SCENARIO_ID
				AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
				AND A.SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
				AND A.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM SERVICE_OBLIGATION
					WHERE MODEL_ID = A.MODEL_ID
						AND SCENARIO_ID = A.SCENARIO_ID
						AND PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
						AND SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
						AND AS_OF_DATE <= v_AS_OF_DATE)
				AND D.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
				AND D.SERVICE_CODE = v_REQUEST_TYPE
				AND D.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND D.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
			GROUP BY EDC_ID, FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE)
			ORDER BY 1,2;
	ELSE
		OPEN p_CURSOR FOR
			SELECT EDC_ID, FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE),
				SUM(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)),
				MIN(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)),
				MAX(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)),
				AVG(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0))
			FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_OBLIGATION_LOAD D
			WHERE (p_EDC_ID = CONSTANTS.ALL_ID OR B.EDC_ID = p_EDC_ID)
				AND A.MODEL_ID = p_MODEL_ID
				AND A.SCENARIO_ID = p_SCENARIO_ID
				AND A.AS_OF_DATE = v_AS_OF_DATE
				AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
				AND A.SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
				AND D.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
				AND D.SERVICE_CODE = v_REQUEST_TYPE
				AND D.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND D.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
			GROUP BY EDC_ID, FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE)
			ORDER BY 1,2;
	END IF;

END EDC_SUMMARY;
---------------------------------------------------------------------------------------------------
PROCEDURE EDC_PSE_ESP_ROLLUP
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_DISPLAY_OPTION IN VARCHAR,
	p_INCLUDE_UFE IN NUMBER,
	p_FILTER_HOURS IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the supply results for an ESP, PSE and EDC
-- Request Type is "F", "B", or "U" for Forecast, Backcast, and Usage respectively.

v_OPTION CHAR(1);
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_AS_OF_DATE DATE;
v_REQUEST_TYPE CHAR(1) := UPPER(SUBSTR(p_REQUEST_TYPE,1,1));

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_BEGIN_DATE, v_END_DATE);

	SELECT DECODE(UPPER(p_DISPLAY_OPTION),'EDC', 'E', 'PSE', 'P', 'ESP', 'S', 'PSE-ESP', 'B', 'B') INTO v_OPTION FROM DUAL;

	v_AS_OF_DATE := AS_OF_DATE_FOR_REQUEST(p_REQUEST_TYPE, p_AS_OF_DATE);

	IF IS_VERSIONED_REQUEST(v_REQUEST_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) THEN
		OPEN p_CURSOR FOR
			SELECT EDC_ID, PSE_ID, ESP_ID, FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE) "LOAD_DATE",
				SUM(LOAD_VAL) "LOAD_VAL",
				MIN(LOAD_VAL) "MIN_VAL",
				MAX(LOAD_VAL) "MAX_VAL",
				AVG(LOAD_VAL) "AVG_VAL"
			FROM
				(SELECT DECODE(p_EDC_ID, CONSTANTS.ALL_ID, DECODE(v_OPTION, 'E', EDC_ID, CONSTANTS.ALL_ID), EDC_ID) AS EDC_ID,
					DECODE(p_PSE_ID, CONSTANTS.ALL_ID, DECODE(v_OPTION, 'P', PSE_ID, 'B', PSE_ID, CONSTANTS.ALL_ID), PSE_ID) AS PSE_ID,
					DECODE(p_ESP_ID, CONSTANTS.ALL_ID, DECODE(v_OPTION, 'S', ESP_ID, 'B', ESP_ID, CONSTANTS.ALL_ID), ESP_ID) AS ESP_ID,
					LOAD_DATE,
					LOAD_CODE,
					SUM(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "LOAD_VAL"
				FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, SERVICE_OBLIGATION_LOAD D
				WHERE (p_EDC_ID = CONSTANTS.ALL_ID OR B.EDC_ID = p_EDC_ID)
					AND (p_ESP_ID = CONSTANTS.ALL_ID OR B.ESP_ID = p_ESP_ID)
					AND (p_PSE_ID = CONSTANTS.ALL_ID OR B.PSE_ID = p_PSE_ID)
					AND (p_SERVICE_POINT_ID = CONSTANTS.ALL_ID OR C.SERVICE_POINT_ID = p_SERVICE_POINT_ID)
					AND A.MODEL_ID = p_MODEL_ID
					AND A.SCENARIO_ID = p_SCENARIO_ID
					AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
					AND A.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
					AND A.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM SERVICE_OBLIGATION
					WHERE MODEL_ID = A.MODEL_ID
						AND SCENARIO_ID = A.SCENARIO_ID
						AND PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
						AND SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
						AND AS_OF_DATE <= v_AS_OF_DATE)
					AND D.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
					AND D.SERVICE_CODE = v_REQUEST_TYPE
					AND D.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
					AND D.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
					AND IS_DAY_INTERVAL_OF_TYPE(p_FILTER_HOURS, FROM_CUT(D.LOAD_DATE,p_TIME_ZONE)) = 1
				GROUP BY DECODE(p_EDC_ID, CONSTANTS.ALL_ID, DECODE(v_OPTION, 'E', EDC_ID, CONSTANTS.ALL_ID), EDC_ID),
					DECODE(p_PSE_ID, CONSTANTS.ALL_ID, DECODE(v_OPTION, 'P', PSE_ID, 'B', PSE_ID, CONSTANTS.ALL_ID), PSE_ID),
					DECODE(p_ESP_ID, CONSTANTS.ALL_ID, DECODE(v_OPTION, 'S', ESP_ID, 'B', ESP_ID, CONSTANTS.ALL_ID), ESP_ID),
					LOAD_CODE,
					LOAD_DATE) A
			GROUP BY EDC_ID, PSE_ID, ESP_ID, FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE)
			ORDER BY 1,2,3,4;
	ELSE
		OPEN p_CURSOR FOR
			SELECT EDC_ID, PSE_ID, ESP_ID, FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE) "LOAD_DATE",
				SUM(LOAD_VAL) "LOAD_VAL",
				MIN(LOAD_VAL) "MIN_VAL",
				MAX(LOAD_VAL) "MAX_VAL",
				AVG(LOAD_VAL) "AVG_VAL"
			FROM
				(SELECT DECODE(p_EDC_ID, CONSTANTS.ALL_ID, DECODE(v_OPTION, 'E', EDC_ID, CONSTANTS.ALL_ID), EDC_ID) AS EDC_ID,
					DECODE(p_PSE_ID, CONSTANTS.ALL_ID, DECODE(v_OPTION, 'P', PSE_ID, 'B', PSE_ID, CONSTANTS.ALL_ID), PSE_ID) AS PSE_ID,
					DECODE(p_ESP_ID, CONSTANTS.ALL_ID, DECODE(v_OPTION, 'S', ESP_ID, 'B', ESP_ID, CONSTANTS.ALL_ID), ESP_ID) AS ESP_ID,
					LOAD_DATE,
					LOAD_CODE,
					SUM(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "LOAD_VAL"
				FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, SERVICE_OBLIGATION_LOAD D
				WHERE (p_EDC_ID = CONSTANTS.ALL_ID OR B.EDC_ID = p_EDC_ID)
					AND (p_ESP_ID = CONSTANTS.ALL_ID OR B.ESP_ID = p_ESP_ID)
					AND (p_PSE_ID = CONSTANTS.ALL_ID OR B.PSE_ID = p_PSE_ID)
					AND (p_SERVICE_POINT_ID = CONSTANTS.ALL_ID OR C.SERVICE_POINT_ID = p_SERVICE_POINT_ID)
					AND A.MODEL_ID = p_MODEL_ID
					AND A.SCENARIO_ID = p_SCENARIO_ID
					AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
					AND A.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
					AND A.AS_OF_DATE = v_AS_OF_DATE
					AND D.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
					AND D.SERVICE_CODE = v_REQUEST_TYPE
					AND D.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
					AND D.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
					AND IS_DAY_INTERVAL_OF_TYPE(p_FILTER_HOURS, FROM_CUT(D.LOAD_DATE,p_TIME_ZONE)) = 1
				GROUP BY DECODE(p_EDC_ID, CONSTANTS.ALL_ID, DECODE(v_OPTION, 'E', EDC_ID, CONSTANTS.ALL_ID), EDC_ID),
					DECODE(p_PSE_ID, CONSTANTS.ALL_ID, DECODE(v_OPTION, 'P', PSE_ID, 'B', PSE_ID, CONSTANTS.ALL_ID), PSE_ID),
					DECODE(p_ESP_ID, CONSTANTS.ALL_ID, DECODE(v_OPTION, 'S', ESP_ID, 'B', ESP_ID, CONSTANTS.ALL_ID), ESP_ID),
					LOAD_CODE,
					LOAD_DATE) A
			GROUP BY EDC_ID, PSE_ID, ESP_ID, FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE)
			ORDER BY 1,2,3,4;
	END IF;

END EDC_PSE_ESP_ROLLUP;
---------------------------------------------------------------------------------------------------
PROCEDURE EDC_PSE_ESP_POOL_ROLLUP
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_DISPLAY_OPTION IN VARCHAR,
	p_INCLUDE_UFE IN NUMBER,
	p_FILTER_HOURS IN NUMBER,
    p_SHOW_AGG_POOLS IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the supply results for an ESP, PSE and EDC
-- Request Type is "F", "B", or "U" for Forecast, Backcast, and Usage respectively.

v_OPTION CHAR(4);
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_AS_OF_DATE DATE;
v_REQUEST_TYPE CHAR(1) := UPPER(SUBSTR(p_REQUEST_TYPE,1,1));

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_BEGIN_DATE, v_END_DATE);

	SELECT DECODE(UPPER(p_DISPLAY_OPTION),'EDC', '1000', 'PSE', '0100', 'ESP', '0010', 'POOL', '0001', 'PSE-ESP', '0110', 'PSE-POOL', '0101', 'ESP-POOL', '0011', '0111') INTO v_OPTION FROM DUAL;

	v_AS_OF_DATE := AS_OF_DATE_FOR_REQUEST(p_REQUEST_TYPE, p_AS_OF_DATE);

	IF IS_VERSIONED_REQUEST(v_REQUEST_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) THEN
		OPEN p_CURSOR FOR
			SELECT EDC_NAME, PSE_NAME, ESP_NAME, F.POOL_NAME "AGG_POOL_NAME", IS_AGG_POOL, E.POOL_NAME,
            	FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE) "LOAD_DATE",
            	A.EDC_ID, A.PSE_ID, A.ESP_ID, A.POOL_ID,
				SUM(LOAD_VAL) "LOAD_VAL",
				MIN(LOAD_VAL) "MIN_VAL",
				MAX(LOAD_VAL) "MAX_VAL",
				AVG(LOAD_VAL) "AVG_VAL"
			FROM
				(-- normal information
                 SELECT DECODE(SUBSTR(v_OPTION,1,1), '0', CONSTANTS.NOT_ASSIGNED, EDC_ID) "EDC_ID",
	                DECODE(SUBSTR(v_OPTION,2,1), '0', CONSTANTS.NOT_ASSIGNED, PSE_ID) "PSE_ID",
	                DECODE(SUBSTR(v_OPTION,3,1), '0', CONSTANTS.NOT_ASSIGNED, ESP_ID) "ESP_ID",
	                DECODE(SUBSTR(v_OPTION,4,1), '0', CONSTANTS.NOT_ASSIGNED, C.POOL_ID) "POOL_ID",
	                DECODE(SUBSTR(v_OPTION,4,1), '0', CONSTANTS.NOT_ASSIGNED, NVL(D.POOL_ID,C.POOL_ID)) "AGG_POOL_ID",
					0 "IS_AGG_POOL",
					LOAD_DATE,
					LOAD_CODE,
					SUM(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "LOAD_VAL"
				FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, POOL_SUB_POOL D, SERVICE_OBLIGATION_LOAD E
				WHERE (p_EDC_ID = CONSTANTS.ALL_ID OR B.EDC_ID = p_EDC_ID)
					AND (p_ESP_ID = CONSTANTS.ALL_ID OR B.ESP_ID = p_ESP_ID)
					AND (p_PSE_ID = CONSTANTS.ALL_ID OR B.PSE_ID = p_PSE_ID)
					AND (p_SERVICE_POINT_ID = CONSTANTS.ALL_ID OR C.SERVICE_POINT_ID = p_SERVICE_POINT_ID)
					AND (p_POOL_ID = CONSTANTS.ALL_ID OR C.POOL_ID = p_POOL_ID OR D.POOL_ID = p_POOL_ID)
					AND D.SUB_POOL_ID(+) = C.POOL_ID
					AND D.BEGIN_DATE(+) <= p_END_DATE
					AND NVL(D.END_DATE(+), p_END_DATE) >= p_BEGIN_DATE
					AND A.MODEL_ID = p_MODEL_ID
					AND A.SCENARIO_ID = p_SCENARIO_ID
					AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
					AND A.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
					AND A.AS_OF_DATE =
						(SELECT MAX(AS_OF_DATE)
						FROM SERVICE_OBLIGATION
						WHERE MODEL_ID = A.MODEL_ID
							AND SCENARIO_ID = A.SCENARIO_ID
							AND PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
							AND SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
							AND AS_OF_DATE <= v_AS_OF_DATE)
					AND E.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
					AND E.SERVICE_CODE = v_REQUEST_TYPE
					AND E.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
					AND E.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
					AND IS_DAY_INTERVAL_OF_TYPE(p_FILTER_HOURS, FROM_CUT(E.LOAD_DATE, p_TIME_ZONE)) = 1
				GROUP BY DECODE(SUBSTR(v_OPTION,1,1), '0', CONSTANTS.NOT_ASSIGNED, EDC_ID),
	                DECODE(SUBSTR(v_OPTION,2,1), '0', CONSTANTS.NOT_ASSIGNED, PSE_ID),
	                DECODE(SUBSTR(v_OPTION,3,1), '0', CONSTANTS.NOT_ASSIGNED, ESP_ID),
	                DECODE(SUBSTR(v_OPTION,4,1), '0', CONSTANTS.NOT_ASSIGNED, C.POOL_ID),
	                DECODE(SUBSTR(v_OPTION,4,1), '0', CONSTANTS.NOT_ASSIGNED, NVL(D.POOL_ID,C.POOL_ID)), 0,
					LOAD_CODE,
					LOAD_DATE
				UNION ALL
                -- union for additional aggregate pool information
                SELECT DECODE(SUBSTR(v_OPTION,1,1), '0', CONSTANTS.NOT_ASSIGNED, EDC_ID) "EDC_ID",
	                DECODE(SUBSTR(v_OPTION,2,1), '0', CONSTANTS.NOT_ASSIGNED, PSE_ID) "PSE_ID",
	                DECODE(SUBSTR(v_OPTION,3,1), '0', CONSTANTS.NOT_ASSIGNED, ESP_ID) "ESP_ID",
	                DECODE(SUBSTR(v_OPTION,4,1), '0', CONSTANTS.NOT_ASSIGNED, D.POOL_ID) "POOL_ID",
	                DECODE(SUBSTR(v_OPTION,4,1), '0', CONSTANTS.NOT_ASSIGNED, D.POOL_ID) "AGG_POOL_ID",
                    -1 "IS_AGG_POOL",
					LOAD_DATE,
					LOAD_CODE,
					SUM(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "LOAD_VAL"
				FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, POOL_SUB_POOL D, SERVICE_OBLIGATION_LOAD E
				WHERE SUBSTR(v_OPTION,4,1) = '1' -- no need for aggregate-pool info if Pool isn't selected for view
                	AND p_SHOW_AGG_POOLS = 1
                	AND (p_EDC_ID = CONSTANTS.ALL_ID OR B.EDC_ID = p_EDC_ID)
					AND (p_ESP_ID = CONSTANTS.ALL_ID OR B.ESP_ID = p_ESP_ID)
					AND (p_PSE_ID = CONSTANTS.ALL_ID OR B.PSE_ID = p_PSE_ID)
					AND (p_SERVICE_POINT_ID = CONSTANTS.ALL_ID OR C.SERVICE_POINT_ID = p_SERVICE_POINT_ID)
					AND (p_POOL_ID = CONSTANTS.ALL_ID OR D.POOL_ID = p_POOL_ID)
					AND D.SUB_POOL_ID = C.POOL_ID
					AND D.BEGIN_DATE <= p_END_DATE
					AND NVL(D.END_DATE, p_END_DATE) >= p_BEGIN_DATE
                    AND D.POOL_ID <> D.SUB_POOL_ID
					AND A.MODEL_ID = p_MODEL_ID
					AND A.SCENARIO_ID = p_SCENARIO_ID
					AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
					AND A.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
					AND A.AS_OF_DATE =
						(SELECT MAX(AS_OF_DATE)
						FROM SERVICE_OBLIGATION
						WHERE MODEL_ID = A.MODEL_ID
							AND SCENARIO_ID = A.SCENARIO_ID
							AND PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
							AND SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
							AND AS_OF_DATE <= v_AS_OF_DATE)
					AND E.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
					AND E.SERVICE_CODE = v_REQUEST_TYPE
					AND E.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
					AND E.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
					AND IS_DAY_INTERVAL_OF_TYPE(p_FILTER_HOURS, FROM_CUT(E.LOAD_DATE, p_TIME_ZONE)) = 1
				GROUP BY DECODE(SUBSTR(v_OPTION,1,1), '0', CONSTANTS.NOT_ASSIGNED, EDC_ID),
	                DECODE(SUBSTR(v_OPTION,2,1), '0', CONSTANTS.NOT_ASSIGNED, PSE_ID),
	                DECODE(SUBSTR(v_OPTION,3,1), '0', CONSTANTS.NOT_ASSIGNED, ESP_ID),
	                DECODE(SUBSTR(v_OPTION,4,1), '0', CONSTANTS.NOT_ASSIGNED, D.POOL_ID), -1,
					LOAD_CODE,
					LOAD_DATE) A,
                    ENERGY_DISTRIBUTION_COMPANY B,
                    PURCHASING_SELLING_ENTITY C,
                    ENERGY_SERVICE_PROVIDER D,
                    POOL E,
                    POOL F
			WHERE B.EDC_ID (+)= A.EDC_ID
            	AND C.PSE_ID (+)= A.PSE_ID
                AND D.ESP_ID (+)= A.ESP_ID
                AND E.POOL_ID (+)= A.POOL_ID
                AND F.POOL_ID (+)= A.AGG_POOL_ID
			GROUP BY EDC_NAME, PSE_NAME, ESP_NAME, F.POOL_NAME, IS_AGG_POOL, E.POOL_NAME, A.EDC_ID, A.PSE_ID, A.ESP_ID, A.POOL_ID, FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE)
			ORDER BY 1, 2, 3, 4, 5, 6, 7;
	ELSE
		OPEN p_CURSOR FOR
			SELECT EDC_NAME, PSE_NAME, ESP_NAME, F.POOL_NAME "AGG_POOL_NAME", IS_AGG_POOL, E.POOL_NAME,
            	FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE) "LOAD_DATE",
            	A.EDC_ID, A.PSE_ID, A.ESP_ID, A.POOL_ID,
				SUM(LOAD_VAL) "LOAD_VAL",
				MIN(LOAD_VAL) "MIN_VAL",
				MAX(LOAD_VAL) "MAX_VAL",
				AVG(LOAD_VAL) "AVG_VAL"
			FROM
				(-- normal information
                 SELECT DECODE(SUBSTR(v_OPTION,1,1), '0', CONSTANTS.NOT_ASSIGNED, EDC_ID) "EDC_ID",
	                DECODE(SUBSTR(v_OPTION,2,1), '0', CONSTANTS.NOT_ASSIGNED, PSE_ID) "PSE_ID",
	                DECODE(SUBSTR(v_OPTION,3,1), '0', CONSTANTS.NOT_ASSIGNED, ESP_ID) "ESP_ID",
	                DECODE(SUBSTR(v_OPTION,4,1), '0', CONSTANTS.NOT_ASSIGNED, C.POOL_ID) "POOL_ID",
	                DECODE(SUBSTR(v_OPTION,4,1), '0', CONSTANTS.NOT_ASSIGNED, NVL(D.POOL_ID,C.POOL_ID)) "AGG_POOL_ID",
					0 "IS_AGG_POOL",
					LOAD_DATE,
					LOAD_CODE,
					SUM(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "LOAD_VAL"
				FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, POOL_SUB_POOL D, SERVICE_OBLIGATION_LOAD E
				WHERE (p_EDC_ID = CONSTANTS.ALL_ID OR B.EDC_ID = p_EDC_ID)
					AND (p_ESP_ID = CONSTANTS.ALL_ID OR B.ESP_ID = p_ESP_ID)
					AND (p_PSE_ID = CONSTANTS.ALL_ID OR B.PSE_ID = p_PSE_ID)
					AND (p_SERVICE_POINT_ID = CONSTANTS.ALL_ID OR C.SERVICE_POINT_ID = p_SERVICE_POINT_ID)
					AND (p_POOL_ID = CONSTANTS.ALL_ID OR C.POOL_ID = p_POOL_ID OR D.POOL_ID = p_POOL_ID)
					AND D.SUB_POOL_ID(+) = C.POOL_ID
					AND D.BEGIN_DATE(+) <= p_END_DATE
					AND NVL(D.END_DATE(+), p_END_DATE) >= p_BEGIN_DATE
					AND A.MODEL_ID = p_MODEL_ID
					AND A.SCENARIO_ID = p_SCENARIO_ID
					AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
					AND A.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
					AND A.AS_OF_DATE = v_AS_OF_DATE
					AND E.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
					AND E.SERVICE_CODE = v_REQUEST_TYPE
					AND E.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
					AND E.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
					AND IS_DAY_INTERVAL_OF_TYPE(p_FILTER_HOURS, FROM_CUT(E.LOAD_DATE, p_TIME_ZONE)) = 1
				GROUP BY DECODE(SUBSTR(v_OPTION,1,1), '0', CONSTANTS.NOT_ASSIGNED, EDC_ID),
	                DECODE(SUBSTR(v_OPTION,2,1), '0', CONSTANTS.NOT_ASSIGNED, PSE_ID),
	                DECODE(SUBSTR(v_OPTION,3,1), '0', CONSTANTS.NOT_ASSIGNED, ESP_ID),
	                DECODE(SUBSTR(v_OPTION,4,1), '0', CONSTANTS.NOT_ASSIGNED, C.POOL_ID),
	                DECODE(SUBSTR(v_OPTION,4,1), '0', CONSTANTS.NOT_ASSIGNED, NVL(D.POOL_ID,C.POOL_ID)), 0,
					LOAD_CODE,
					LOAD_DATE
				UNION ALL
                -- union for additional aggregate pool information
                SELECT DECODE(SUBSTR(v_OPTION,1,1), '0', CONSTANTS.NOT_ASSIGNED, EDC_ID) "EDC_ID",
	                DECODE(SUBSTR(v_OPTION,2,1), '0', CONSTANTS.NOT_ASSIGNED, PSE_ID) "PSE_ID",
	                DECODE(SUBSTR(v_OPTION,3,1), '0', CONSTANTS.NOT_ASSIGNED, ESP_ID) "ESP_ID",
	                DECODE(SUBSTR(v_OPTION,4,1), '0', CONSTANTS.NOT_ASSIGNED, D.POOL_ID) "POOL_ID",
	                DECODE(SUBSTR(v_OPTION,4,1), '0', CONSTANTS.NOT_ASSIGNED, D.POOL_ID) "AGG_POOL_ID",
                    -1 "IS_AGG_POOL",
					LOAD_DATE,
					LOAD_CODE,
					SUM(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "LOAD_VAL"
				FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, POOL_SUB_POOL D, SERVICE_OBLIGATION_LOAD E
				WHERE SUBSTR(v_OPTION,4,1) = '1' -- no need for aggregate-pool info if Pool isn't selected for view
                	AND p_SHOW_AGG_POOLS = 1
                	AND (p_EDC_ID = CONSTANTS.ALL_ID OR B.EDC_ID = p_EDC_ID)
					AND (p_ESP_ID = CONSTANTS.ALL_ID OR B.ESP_ID = p_ESP_ID)
					AND (p_PSE_ID = CONSTANTS.ALL_ID OR B.PSE_ID = p_PSE_ID)
					AND (p_SERVICE_POINT_ID = CONSTANTS.ALL_ID OR C.SERVICE_POINT_ID = p_SERVICE_POINT_ID)
					AND (p_POOL_ID = CONSTANTS.ALL_ID OR D.POOL_ID = p_POOL_ID)
					AND D.SUB_POOL_ID = C.POOL_ID
					AND D.BEGIN_DATE <= p_END_DATE
					AND NVL(D.END_DATE, p_END_DATE) >= p_BEGIN_DATE
                    AND D.POOL_ID <> D.SUB_POOL_ID
					AND A.MODEL_ID = p_MODEL_ID
					AND A.SCENARIO_ID = p_SCENARIO_ID
					AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
					AND A.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
					AND A.AS_OF_DATE = v_AS_OF_DATE
					AND E.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
					AND E.SERVICE_CODE = v_REQUEST_TYPE
					AND E.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
					AND E.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
					AND IS_DAY_INTERVAL_OF_TYPE(p_FILTER_HOURS, FROM_CUT(E.LOAD_DATE, p_TIME_ZONE)) = 1
				GROUP BY DECODE(SUBSTR(v_OPTION,1,1), '0', CONSTANTS.NOT_ASSIGNED, EDC_ID),
	                DECODE(SUBSTR(v_OPTION,2,1), '0', CONSTANTS.NOT_ASSIGNED, PSE_ID),
	                DECODE(SUBSTR(v_OPTION,3,1), '0', CONSTANTS.NOT_ASSIGNED, ESP_ID),
	                DECODE(SUBSTR(v_OPTION,4,1), '0', CONSTANTS.NOT_ASSIGNED, D.POOL_ID), -1,
					LOAD_CODE,
					LOAD_DATE) A,
                    ENERGY_DISTRIBUTION_COMPANY B,
                    PURCHASING_SELLING_ENTITY C,
                    ENERGY_SERVICE_PROVIDER D,
                    POOL E,
                    POOL F
			WHERE B.EDC_ID (+)= A.EDC_ID
            	AND C.PSE_ID (+)= A.PSE_ID
                AND D.ESP_ID (+)= A.ESP_ID
                AND E.POOL_ID (+)= A.POOL_ID
                AND F.POOL_ID (+)= A.AGG_POOL_ID
			GROUP BY EDC_NAME, PSE_NAME, ESP_NAME, F.POOL_NAME, IS_AGG_POOL, E.POOL_NAME, A.EDC_ID, A.PSE_ID, A.ESP_ID, A.POOL_ID, FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE)
			ORDER BY 1, 2, 3, 4, 5, 6, 7;
	END IF;

END EDC_PSE_ESP_POOL_ROLLUP;
---------------------------------------------------------------------------------------------------
PROCEDURE POOL_SUMMARY
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_INCLUDE_UFE IN NUMBER,
	p_FILTER_HOURS IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the total wholeasle load results for an EDC
-- Request Type is "F", "B", or "U" for Forecast, Backcast, and Usage respectively.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_AS_OF_DATE DATE;
v_REQUEST_TYPE CHAR(1) := UPPER(SUBSTR(p_REQUEST_TYPE,1,1));

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_BEGIN_DATE, v_END_DATE);

	v_AS_OF_DATE := AS_OF_DATE_FOR_REQUEST(p_REQUEST_TYPE, p_AS_OF_DATE);

	IF IS_VERSIONED_REQUEST(v_REQUEST_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) THEN
		OPEN p_CURSOR FOR
			SELECT FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE) "LOAD_DATE",
				SUM(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "LOAD_VAL",
				MIN(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "MIN_LOAD_VAL",
				MAX(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "MAX_LOAD_VAL",
				AVG(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "AVG_LOAD_VAL"
			FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, SERVICE_OBLIGATION_LOAD D, POOL E
			WHERE (p_EDC_ID = CONSTANTS.ALL_ID OR B.EDC_ID = p_EDC_ID)
				AND A.MODEL_ID = p_MODEL_ID
				AND A.SCENARIO_ID = p_SCENARIO_ID
				AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
				AND A.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
				AND A.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM SERVICE_OBLIGATION
					WHERE MODEL_ID = A.MODEL_ID
						AND SCENARIO_ID = A.SCENARIO_ID
						AND PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
						AND SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
						AND AS_OF_DATE <= v_AS_OF_DATE)
				AND D.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
				AND D.SERVICE_CODE = v_REQUEST_TYPE
				AND D.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND D.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
				AND IS_DAY_INTERVAL_OF_TYPE(p_FILTER_HOURS, FROM_CUT(D.LOAD_DATE, p_TIME_ZONE)) = 1
				AND C.POOL_ID = E.POOL_ID
				AND UPPER(SUBSTR(E.POOL_CATEGORY,1,1)) = 'D'
			GROUP BY FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE)
			ORDER BY 1;
	ELSE
		OPEN p_CURSOR FOR
			SELECT FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE) "LOAD_DATE",
				SUM(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "LOAD_VAL",
				MIN(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "MIN_LOAD_VAL",
				MAX(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "MAX_LOAD_VAL",
				AVG(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "AVG_LOAD_VAL"
			FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, SERVICE_OBLIGATION_LOAD D, POOL E
			WHERE (p_EDC_ID = CONSTANTS.ALL_ID OR B.EDC_ID = p_EDC_ID)
				AND A.MODEL_ID = p_MODEL_ID
				AND A.SCENARIO_ID = p_SCENARIO_ID
				AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
				AND A.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
				AND A.AS_OF_DATE = v_AS_OF_DATE
				AND D.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
				AND D.SERVICE_CODE = v_REQUEST_TYPE
				AND D.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND D.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
				AND IS_DAY_INTERVAL_OF_TYPE(p_FILTER_HOURS, FROM_CUT(D.LOAD_DATE,p_TIME_ZONE)) = 1
				AND C.POOL_ID = E.POOL_ID
				AND UPPER(SUBSTR(E.POOL_CATEGORY,1,1)) = 'D'
			GROUP BY FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE)
			ORDER BY 1;
	END IF;

END POOL_SUMMARY;
---------------------------------------------------------------------------------------------------
PROCEDURE WHOLESALE_SUMMARY
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_INCLUDE_UFE IN NUMBER,
	p_FILTER_HOURS IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the total wholeasle load results for an EDC
-- Request Type is "F", "B", or "U" for Forecast, Backcast, and Usage respectively.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_AS_OF_DATE DATE;
v_REQUEST_TYPE CHAR(1) := UPPER(SUBSTR(p_REQUEST_TYPE,1,1));

BEGIN

	IF NOT p_MODEL_ID = GA.ELECTRIC_MODEL THEN
		POOL_SUMMARY(p_REQUEST_TYPE, p_MODEL_ID, p_SCENARIO_ID, p_EDC_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE, p_INTERVAL, p_INCLUDE_UFE, p_FILTER_HOURS, p_STATUS, p_CURSOR);
		RETURN;
	END IF;

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_BEGIN_DATE, v_END_DATE);

	v_AS_OF_DATE := AS_OF_DATE_FOR_REQUEST(p_REQUEST_TYPE, p_AS_OF_DATE);

	IF IS_VERSIONED_REQUEST(v_REQUEST_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) THEN
		OPEN p_CURSOR FOR
			SELECT FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE) "LOAD_DATE",
				SUM(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "LOAD_VAL",
				MIN(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "MIN_LOAD_VAL",
				MAX(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "MAX_LOAD_VAL",
				AVG(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "AVG_LOAD_VAL"
			FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, SERVICE_OBLIGATION_LOAD D
			WHERE (p_EDC_ID = CONSTANTS.ALL_ID OR B.EDC_ID = p_EDC_ID)
				AND A.MODEL_ID = p_MODEL_ID
				AND A.SCENARIO_ID = p_SCENARIO_ID
				AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
				AND A.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
				AND A.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM SERVICE_OBLIGATION
					WHERE MODEL_ID = A.MODEL_ID
						AND SCENARIO_ID = A.SCENARIO_ID
						AND PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
						AND SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
						AND AS_OF_DATE <= v_AS_OF_DATE)
				AND D.SERVICE_CODE = v_REQUEST_TYPE
				AND D.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND D.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
				AND IS_DAY_INTERVAL_OF_TYPE(p_FILTER_HOURS, FROM_CUT(D.LOAD_DATE,p_TIME_ZONE)) = 1
				AND D.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
	 			AND C.IS_WHOLESALE = 1
			GROUP BY FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE)
			ORDER BY 1;
	ELSE
		OPEN p_CURSOR FOR
			SELECT FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE) "LOAD_DATE",
				SUM(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "LOAD_VAL",
				MIN(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "MIN_LOAD_VAL",
				MAX(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "MAX_LOAD_VAL",
				AVG(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "AVG_LOAD_VAL"
			FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, SERVICE_OBLIGATION_LOAD D
			WHERE (p_EDC_ID = CONSTANTS.ALL_ID OR B.EDC_ID = p_EDC_ID)
				AND A.MODEL_ID = p_MODEL_ID
				AND A.SCENARIO_ID = p_SCENARIO_ID
				AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
				AND A.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
				AND A.AS_OF_DATE = v_AS_OF_DATE
				AND D.SERVICE_CODE = v_REQUEST_TYPE
				AND D.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND D.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
				AND IS_DAY_INTERVAL_OF_TYPE(p_FILTER_HOURS, FROM_CUT(D.LOAD_DATE,p_TIME_ZONE)) = 1
				AND D.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
	 			AND C.IS_WHOLESALE = 1
			GROUP BY FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE)
			ORDER BY 1;
	END IF;

END WHOLESALE_SUMMARY;
---------------------------------------------------------------------------------------------------
PROCEDURE SYSTEM_LOAD_AREAS
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SYSTEM_LOAD_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the areas that comprise a system load.

v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_BEGIN_DATE, v_END_DATE);

	IF GA.VERSION_AREA_LOAD THEN
		OPEN p_CURSOR FOR
			SELECT B.AREA_NAME, A.OPERATION_CODE, C.LOAD_CODE, FROM_CUT_AS_HED(C.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID), SUM(C.LOAD_VAL)
			FROM SYSTEM_LOAD_AREA A, AREA B, AREA_LOAD C
			WHERE A.SYSTEM_LOAD_ID = p_SYSTEM_LOAD_ID
				AND B.AREA_ID = A.AREA_ID
				AND C.AREA_ID = B.AREA_ID
				AND C.CASE_ID >= 0
				AND C.LOAD_CODE = DECODE(p_REQUEST_TYPE, 'F', 'F', 'B', 'A', 'U', 'A', 'F')
				AND C.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND C.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM AREA_LOAD
					WHERE AREA_ID = C.AREA_ID
						AND C.CASE_ID >= 0
                        AND LOAD_CODE = C.LOAD_CODE
						AND LOAD_DATE = C.LOAD_DATE
						AND AS_OF_DATE <= p_AS_OF_DATE)
			GROUP BY B.AREA_NAME, A.OPERATION_CODE, C.LOAD_CODE, FROM_CUT_AS_HED(C.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID)
			ORDER BY 1,2,3,4;
	ELSE
		OPEN p_CURSOR FOR
			SELECT B.AREA_NAME, A.OPERATION_CODE, C.LOAD_CODE, FROM_CUT_AS_HED(C.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID), SUM(C.LOAD_VAL)
			FROM SYSTEM_LOAD_AREA A, AREA B, AREA_LOAD C
			WHERE A.SYSTEM_LOAD_ID = p_SYSTEM_LOAD_ID
				AND B.AREA_ID = A.AREA_ID
				AND C.AREA_ID = B.AREA_ID
                AND C.CASE_ID >= 0
				AND C.LOAD_CODE = DECODE(p_REQUEST_TYPE, 'F', 'F', 'B', 'A', 'U', 'A', 'F')
				AND C.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND C.AS_OF_DATE = CONSTANTS.LOW_DATE
			GROUP BY B.AREA_NAME, A.OPERATION_CODE, C.LOAD_CODE, FROM_CUT_AS_HED(C.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID)
			ORDER BY 1,2,3,4;
	END IF;

END SYSTEM_LOAD_AREAS;
---------------------------------------------------------------------------------------------------
PROCEDURE SYSTEM_LOAD_NAMES
    (
	p_REQUEST_TYPE IN CHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of system loads defined in the database.

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT SYSTEM_LOAD_NAME, SYSTEM_LOAD_ID, SYSTEM_LOAD_INTERVAL
		FROM SYSTEM_LOAD
		ORDER BY SYSTEM_LOAD_NAME;

END SYSTEM_LOAD_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE SYSTEM_LOAD_LAST_DATE
    (
	p_REQUEST_TYPE IN CHAR,
	p_EDC_ID IN NUMBER,
	p_LAST_UPDATE OUT DATE,
	p_STATUS OUT NUMBER
	) AS

-- Answer the last update of the specified system load.

v_DATE_STRING VARCHAR(512);

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;

	IF p_REQUEST_TYPE = 'F' THEN
	   GET_VALUE_AT_KEY('UPDATE_FORECAST_SYS_LOAD_DATE', v_DATE_STRING);
	ELSIF p_REQUEST_TYPE IN ('B','U') THEN
	   GET_VALUE_AT_KEY('UPDATE_ACTUAL_SYS_LOAD_DATE', v_DATE_STRING);
	END IF;

    IF v_DATE_STRING IS NULL THEN
	    SELECT B.ENTRY_DATE
		INTO p_LAST_UPDATE
		FROM ENERGY_DISTRIBUTION_COMPANY A, SYSTEM_LOAD B
		WHERE A.EDC_ID = p_EDC_ID
		    AND B.SYSTEM_LOAD_ID = A.EDC_SYSTEM_LOAD_ID;
	ELSE
		p_LAST_UPDATE := TO_DATE(v_DATE_STRING, 'MM/DD/YY HH:MI:SS AM');
	END IF;

	EXCEPTION
	    WHEN NO_DATA_FOUND THEN
	   		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			p_LAST_UPDATE := LOW_DATE;
	    WHEN OTHERS THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			p_LAST_UPDATE := LOW_DATE;
		    p_STATUS := SQLCODE;

END SYSTEM_LOAD_LAST_DATE;
---------------------------------------------------------------------------------------------------
PROCEDURE SERVICE_POINT_NAMES
    (
	p_REQUEST_TYPE IN CHAR,
	p_EDC_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of service points associated with retail accounts.

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT SERVICE_POINT_NAME, SERVICE_POINT_ID
		FROM SERVICE_POINT
		WHERE (p_EDC_ID = CONSTANTS.ALL_ID OR EDC_ID = p_EDC_ID)
		ORDER BY SERVICE_POINT_NAME;

END SERVICE_POINT_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE SERVICE_POINT_NAMES_IN_USE
    (
	p_REQUEST_TYPE IN CHAR,
	p_EDC_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of service points associated with retail accounts.

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT B.SERVICE_POINT_NAME, A.SERVICE_POINT_ID
		FROM (SELECT DISTINCT SERVICE_POINT_ID
			  		FROM SERVICE_OBLIGATION A, SERVICE_DELIVERY B, SERVICE_OBLIGATION_LOAD C
			  		WHERE C.LOAD_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE + 1)
						AND C.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
						AND A.SERVICE_DELIVERY_ID = B.SERVICE_DELIVERY_ID) A,
			  SERVICE_POINT B
		WHERE B.SERVICE_POINT_ID = A.SERVICE_POINT_ID
			AND (p_EDC_ID = CONSTANTS.ALL_ID OR B.EDC_ID = p_EDC_ID)
		ORDER BY SERVICE_POINT_NAME;

END SERVICE_POINT_NAMES_IN_USE;
---------------------------------------------------------------------------------------------------
PROCEDURE STATION_PARAMETER_SUMMARY
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_STATION_ID IN NUMBER,
	p_PARAMETER_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_PARAMETER_CODE IN CHAR,
	p_FILTER_HOURS IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the weather station parameter data.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_WEATHER_CASE_ID NUMBER(9);

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	SELECT WEATHER_CASE_ID
	INTO v_WEATHER_CASE_ID
	FROM LOAD_FORECAST_SCENARIO
	WHERE SCENARIO_ID = p_SCENARIO_ID;

    p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_BEGIN_DATE, v_END_DATE);

	OPEN p_CURSOR FOR
	    SELECT FROM_CUT_AS_HED(PARAMETER_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID) AS PARAMETER_DATE,
		  ROUND(AVG(PARAMETER_VAL),2) AS PARAMETER_VAL,
		  ROUND(MIN(PARAMETER_VAL),2) AS MIN_PARAMETER_VAL,
		  ROUND(MAX(PARAMETER_VAL),2) AS MAX_PARAMETER_VAL
		FROM STATION_PARAMETER_VALUES -- union of standard and composite values
		WHERE CASE_ID = v_WEATHER_CASE_ID
			AND STATION_ID = p_STATION_ID
		    AND PARAMETER_ID = p_PARAMETER_ID
			AND PARAMETER_CODE = p_PARAMETER_CODE
			AND PARAMETER_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND 1 = IS_DAY_INTERVAL_OF_TYPE(p_FILTER_HOURS,FROM_CUT(PARAMETER_DATE,p_TIME_ZONE))
		GROUP BY FROM_CUT_AS_HED(PARAMETER_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID)
		ORDER BY 1;

END STATION_PARAMETER_SUMMARY;
---------------------------------------------------------------------------------------------------
PROCEDURE STATION_PARAMETER_READING
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_CASE_ID IN NUMBER,
	p_STATION_ID IN NUMBER,
	p_PARAMETER_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_PARAMETER_CODE IN CHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the weather station parameter data.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_INTERVAL VARCHAR(8) := p_INTERVAL;
v_PARAM_INTERVAL VARCHAR(16);
v_MODEL_ID NUMBER(2);
BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;

	IF p_PARAMETER_CODE = 'P' THEN -- Projection
		--A projection is always Daily or above.
		v_MODEL_ID := GA.GAS_MODEL;

		UT.CUT_DATE_RANGE(v_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_BEGIN_DATE, v_END_DATE);
		OPEN p_CURSOR FOR
			 SELECT TO_CHAR(PARAMETER_DATE, 'YYYY-MM-DD ') AS PARAMETER_DATE,
			 		  PARAMETER_MIN AS PARAMETER_MIN,
					  PARAMETER_MAX AS PARAMETER_MAX,
					  PARAMETER_AVG AS PARAMETER_AVG,
					  HISTORICAL_BEGIN_DATE, HISTORICAL_END_DATE,
					  HISTORICAL_MIN, HISTORICAL_MAX, HISTORICAL_AVG,
					  HISTORICAL_SUM, HISTORICAL_CNT, HISTORICAL_FACTOR
			 FROM STATION_PARAMETER_PROJECTION
			 WHERE CASE_ID = p_CASE_ID
			 	  AND STATION_ID = p_STATION_ID
			 	  AND PARAMETER_ID = p_PARAMETER_ID
				  AND PARAMETER_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			 ORDER BY 1;
	ELSE -- Comparison
		--use the parameter's interval to determine whether to roll up to hour or day
		SELECT PARAMETER_INTERVAL INTO v_PARAM_INTERVAL	FROM WEATHER_PARAMETER WHERE PARAMETER_ID = p_PARAMETER_ID;
		IF UPPER(v_PARAM_INTERVAL) IN ('DAY','WEEK','MONTH','QUARTER','YEAR') THEN
			v_MODEL_ID := GA.GAS_MODEL;
		ELSIF UPPER(v_PARAM_INTERVAL) IN ('15 MINUTE','30 MINUTE','HOUR') THEN
			v_MODEL_ID := GA.ELECTRIC_MODEL;
		ELSE
			v_MODEL_ID := p_MODEL_ID;
		END IF;
		IF v_INTERVAL IS NULL AND v_MODEL_ID = GA.GAS_MODEL THEN v_INTERVAL := 'DD'; END IF;

		UT.CUT_DATE_RANGE(v_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_INTERVAL, v_BEGIN_DATE, v_END_DATE);
		OPEN p_CURSOR FOR
		    SELECT FROM_CUT_AS_HED(PARAMETER_DATE, p_TIME_ZONE, v_INTERVAL, v_MODEL_ID) AS PARAMETER_DATE,
			 		  AVG(PARAMETER_VAL) AS PARAMETER_VAL
			FROM STATION_PARAMETER_VALUES -- union of standard and composite values
			WHERE STATION_ID = p_STATION_ID
			    AND CASE_ID = p_CASE_ID
                AND PARAMETER_ID = p_PARAMETER_ID
				AND PARAMETER_CODE = p_PARAMETER_CODE
				AND PARAMETER_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			GROUP BY FROM_CUT_AS_HED(PARAMETER_DATE, p_TIME_ZONE, v_INTERVAL, v_MODEL_ID)
			ORDER BY 1;
	END IF;

END STATION_PARAMETER_READING;
---------------------------------------------------------------------------------------------------
PROCEDURE WEATHER_STATION_PARAMETERS
    (
	p_REQUEST_TYPE IN CHAR,
	p_STATION_IDS IN VARCHAR,
	p_PARAMETER_IDS IN VARCHAR,
	p_PARAMETER_CODES IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the weather station parameter data.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_STATION_WORK_ID NUMBER;
v_PARAMETER_WORK_ID NUMBER;
v_STATION_TABLE GA.STRING_TABLE;
v_PARAMETER_TABLE GA.STRING_TABLE;
v_INDEX BINARY_INTEGER;
v_FORECAST CHAR(1) := ' ';
v_USED CHAR(1) := ' ';
v_ACTUAL CHAR(1) := ' ';

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	UT.GET_RTO_WORK_ID(v_STATION_WORK_ID);
	UT.GET_RTO_WORK_ID(v_PARAMETER_WORK_ID);

	UT.TOKENS_FROM_STRING(p_STATION_IDS, ';', v_STATION_TABLE);
	v_INDEX := v_STATION_TABLE.FIRST;
	LOOP
	    UT.POST_RTO_WORK(v_STATION_WORK_ID, NULL, TO_NUMBER(v_STATION_TABLE(v_INDEX)));
		EXIT WHEN v_INDEX = v_STATION_TABLE.LAST;
		v_INDEX := v_STATION_TABLE.NEXT(v_INDEX);
	END LOOP;

	UT.TOKENS_FROM_STRING(p_PARAMETER_IDS, ';', v_PARAMETER_TABLE);
	v_INDEX := v_PARAMETER_TABLE.FIRST;
	LOOP
	    UT.POST_RTO_WORK(v_PARAMETER_WORK_ID, NULL, TO_NUMBER(v_PARAMETER_TABLE(v_INDEX)));
		EXIT WHEN v_INDEX = v_PARAMETER_TABLE.LAST;
		v_INDEX := v_PARAMETER_TABLE.NEXT(v_INDEX);
	END LOOP;

	IF INSTR(p_PARAMETER_CODES,'F') > 0 THEN
	    v_FORECAST := 'F';
	END IF;

	IF INSTR(p_PARAMETER_CODES,'U') > 0 THEN
	    v_USED := 'U';
	END IF;

	IF INSTR(p_PARAMETER_CODES,'A') > 0 THEN
	    v_ACTUAL := 'A';
	END IF;

	OPEN p_CURSOR FOR
	    SELECT STATION_ID,
		    PARAMETER_ID,
			PARAMETER_CODE,
			FROM_CUT_AS_HED(PARAMETER_DATE, p_TIME_ZONE) "PARAMETER_DATE",
			NVL(PARAMETER_VAL, 0) "PARAMETER_VAL"
		FROM STATION_PARAMETER_VALUE
		WHERE EXISTS (SELECT NULL FROM RTO_WORK S WHERE S.WORK_ID = v_STATION_WORK_ID AND S.WORK_XID = STATION_ID)
			AND EXISTS (SELECT NULL FROM RTO_WORK P WHERE P.WORK_ID = v_PARAMETER_WORK_ID AND P.WORK_XID = PARAMETER_ID)
			AND (PARAMETER_CODE = v_FORECAST OR PARAMETER_CODE = v_USED OR PARAMETER_CODE = v_ACTUAL)
			AND PARAMETER_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
	UNION
		SELECT B.STATION_ID,
			A.PARAMETER_ID,
			B.PARAMETER_CODE,
			FROM_CUT_AS_HED(B.PARAMETER_DATE, p_TIME_ZONE) "PARAMETER_DATE",
			SUM(B.PARAMETER_VAL * A.COMPOSITE_COEFFICIENT) "PARAMETER_VAL"
		FROM WEATHER_PARAMETER_COMPOSITE A, STATION_PARAMETER_VALUE B
		WHERE B.PARAMETER_ID = A.COMPOSITE_PARAMETER_ID
			AND EXISTS (SELECT NULL FROM RTO_WORK S WHERE S.WORK_ID = v_STATION_WORK_ID AND S.WORK_XID = B.STATION_ID)
			AND EXISTS (SELECT NULL FROM RTO_WORK P WHERE P.WORK_ID = v_PARAMETER_WORK_ID AND P.WORK_XID = A.PARAMETER_ID)
			AND (PARAMETER_CODE = v_FORECAST OR PARAMETER_CODE = v_USED OR PARAMETER_CODE = v_ACTUAL)
			AND PARAMETER_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		GROUP BY B.STATION_ID,
			A.PARAMETER_ID,
			B.PARAMETER_CODE,
			B.PARAMETER_DATE
	UNION
		SELECT A.STATION_ID,
			B.PARAMETER_ID,
			B.PARAMETER_CODE,
			FROM_CUT_AS_HED(B.PARAMETER_DATE, p_TIME_ZONE) "PARAMETER_DATE",
			SUM(B.PARAMETER_VAL * (A.COMPOSITE_PERCENT / 100.0)) "PARAMETER_VAL"
		FROM WEATHER_STATION_COMPOSITE A ,STATION_PARAMETER_VALUE B
		WHERE B.STATION_ID = A.COMPOSITE_STATION_ID
			AND EXISTS (SELECT NULL FROM RTO_WORK S WHERE S.WORK_ID = v_STATION_WORK_ID AND S.WORK_XID = A.STATION_ID)
			AND EXISTS (SELECT NULL FROM RTO_WORK P WHERE P.WORK_ID = v_PARAMETER_WORK_ID AND P.WORK_XID = B.PARAMETER_ID)
			AND (PARAMETER_CODE = v_FORECAST OR PARAMETER_CODE = v_USED OR PARAMETER_CODE = v_ACTUAL)
			AND PARAMETER_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		GROUP BY A.STATION_ID,
			B.PARAMETER_ID,
			B.PARAMETER_CODE,
			B.PARAMETER_DATE
	ORDER BY 1,2,3,4;

	UT.PURGE_RTO_WORK(v_STATION_WORK_ID);
	UT.PURGE_RTO_WORK(v_PARAMETER_WORK_ID);

	EXCEPTION
	    WHEN OTHERS THEN
			BEGIN
				UT.PURGE_RTO_WORK(v_STATION_WORK_ID);
				UT.PURGE_RTO_WORK(v_PARAMETER_WORK_ID);
			EXCEPTION
				WHEN OTHERS THEN
					ERRS.LOG_AND_CONTINUE();
			END;
			ERRS.LOG_AND_RAISE();

END WEATHER_STATION_PARAMETERS;
---------------------------------------------------------------------------------------------------
PROCEDURE UFE_AGGREGATE_ACCOUNTS
    (
	p_REQUEST_TYPE IN CHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of UFE aggregate accounts.
v_DATE DATE := TRUNC(SYSDATE);
BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT A.ACCOUNT_NAME,
		    A.ACCOUNT_ID,
			DECODE(B.IS_UFE_PARTICIPANT, NULL, A.IS_UFE_PARTICIPANT, B.IS_UFE_PARTICIPANT)
		FROM ACCOUNT A,
		    ACCOUNT_UFE_PARTICIPATION B,
			 ACCOUNT_STATUS C,
			 ACCOUNT_STATUS_NAME STATUS_NAME
		WHERE A.IS_AGGREGATE_ACCOUNT = 1
			AND STATUS_NAME.STATUS_NAME = C.STATUS_NAME
			AND STATUS_NAME.IS_ACTIVE = 1
			AND v_DATE BETWEEN C.BEGIN_DATE AND NVL(C.END_DATE, v_DATE)
			AND C.ACCOUNT_ID = A.ACCOUNT_ID
			AND B.ACCOUNT_ID(+) = A.ACCOUNT_ID
		ORDER BY ACCOUNT_NAME;

END UFE_AGGREGATE_ACCOUNTS;
---------------------------------------------------------------------------------------------------
PROCEDURE SET_ACCOUNT_UFE_PARTICIPATION
    (
	p_REQUEST_TYPE IN CHAR,
	p_ACCOUNT_ID IN NUMBER,
	p_IS_UFE_PARTICIPANT IN NUMBER,
	p_REQUESTOR IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

--  Set the UFE participation indicator for the specified account.

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;

	UPDATE ACCOUNT_UFE_PARTICIPATION
	SET IS_UFE_PARTICIPANT = DECODE(p_IS_UFE_PARTICIPANT, 1, 1, 0)
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND UFE_CODE = UPPER(SUBSTR(p_REQUEST_TYPE,1,1))
		AND UFE_REQUESTOR = UPPER(p_REQUESTOR);

	IF SQL%NOTFOUND THEN
		    INSERT INTO ACCOUNT_UFE_PARTICIPATION(
				ACCOUNT_ID,
				UFE_CODE,
				UFE_REQUESTOR,
				IS_UFE_PARTICIPANT)
			VALUES (
				p_ACCOUNT_ID,
				UPPER(SUBSTR(p_REQUEST_TYPE,1,1)),
				UPPER(p_REQUESTOR),
				p_IS_UFE_PARTICIPANT);
	END IF;

END SET_ACCOUNT_UFE_PARTICIPATION;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_ACCOUNT_UFE_PARTICIPATION
    (
	p_REQUEST_TYPE IN CHAR,
	p_REQUESTOR IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

--  Get the UFE participation indicator for all aggregate accountS.
v_DATE DATE := TRUNC(SYSDATE);
BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;

	INSERT INTO ACCOUNT_UFE_PARTICIPATION (ACCOUNT_ID, UFE_CODE, UFE_REQUESTOR, IS_UFE_PARTICIPANT)
	    (
		SELECT A.ACCOUNT_ID, UPPER(SUBSTR(p_REQUEST_TYPE,1,1)), UPPER(p_REQUESTOR), IS_UFE_PARTICIPANT
		FROM ACCOUNT A, ACCOUNT_STATUS B, ACCOUNT_STATUS_NAME STATUS_NAME
		WHERE UPPER(SUBSTR(A.ACCOUNT_MODEL_OPTION,1,1)) = 'A'
			AND A.IS_AGGREGATE_ACCOUNT = 1
			AND STATUS_NAME.STATUS_NAME = B.STATUS_NAME
			AND STATUS_NAME.IS_ACTIVE = 1
			AND v_DATE BETWEEN B.BEGIN_DATE AND NVL(B.END_DATE, v_DATE)
			AND B.ACCOUNT_ID = A.ACCOUNT_ID
			AND NOT EXISTS (SELECT * FROM ACCOUNT_UFE_PARTICIPATION B
							WHERE B.ACCOUNT_ID = A.ACCOUNT_ID
							AND B.UFE_CODE = UPPER(SUBSTR(p_REQUEST_TYPE,1,1))
							AND B.UFE_REQUESTOR = p_REQUESTOR)
		);

	OPEN p_CURSOR FOR
       	SELECT B.ACCOUNT_NAME, B.ACCOUNT_ID, A.IS_UFE_PARTICIPANT
		FROM ACCOUNT_UFE_PARTICIPATION A,
		    ACCOUNT B
		WHERE B.ACCOUNT_ID = A.ACCOUNT_ID
		AND UFE_CODE = p_REQUEST_TYPE
		AND UFE_REQUESTOR = p_REQUESTOR
		ORDER BY 1;

END GET_ACCOUNT_UFE_PARTICIPATION;
---------------------------------------------------------------------------------------------------
PROCEDURE UFE_ALLOCATION_BY_EDC
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_FILTER_HOURS IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the total UFE allocation results for an EDC
-- Request Type is "F", "B", or "U" for Forecast, Backcast, and Usage respectively.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_AS_OF_DATE DATE;
v_REQUEST_TYPE CHAR(1) := UPPER(SUBSTR(p_REQUEST_TYPE,1,1));

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_BEGIN_DATE, v_END_DATE);
	v_AS_OF_DATE := AS_OF_DATE_FOR_REQUEST(v_REQUEST_TYPE, p_AS_OF_DATE);

	IF IS_VERSIONED_REQUEST(v_REQUEST_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) THEN
		OPEN p_CURSOR FOR
			SELECT FROM_CUT_AS_HED(A.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID) AS "UFE_DATE",
				SUM(UFE_SYSTEM_LOAD) AS "UFE_SYSTEM_LOAD",
				SUM(UFE_SERVICE_LOAD) AS "UFE_RETAIL_LOAD",
				SUM(UFE_SYSTEM_LOAD - UFE_SERVICE_LOAD) AS "UFE_VAL",
				SUM(UFE_SYSTEM_LOAD - UFE_SERVICE_LOAD + TX_LOSS_VAL + DX_LOSS_VAL) AS "RAW_UFE_VAL",
				MIN(UFE_SYSTEM_LOAD) AS "MIN_UFE_SYSTEM_LOAD",
				MAX(UFE_SYSTEM_LOAD) AS "MAX_UFE_SYSTEM_LOAD",
				AVG(UFE_SYSTEM_LOAD) AS "AVG_UFE_SYSTEM_LOAD",
				MIN(UFE_SYSTEM_LOAD - UFE_SERVICE_LOAD) AS "MIN_UFE_VAL",
				MAX(UFE_SYSTEM_LOAD - UFE_SERVICE_LOAD) AS "MAX_UFE_VAL",
				AVG(UFE_SYSTEM_LOAD - UFE_SERVICE_LOAD) AS "AVG_UFE_VAL"
			FROM EDC_SYSTEM_UFE_LOAD A,
            	(SELECT B.EDC_ID, C.LOAD_DATE, C.LOAD_CODE,
                        SUM(C.TX_LOSS_VAL) "TX_LOSS_VAL", SUM(C.DX_LOSS_VAL) "DX_LOSS_VAL"
                	FROM SERVICE_OBLIGATION A,
		                PROVIDER_SERVICE B,
		                SERVICE_OBLIGATION_LOAD C
					WHERE (p_EDC_ID = CONSTANTS.ALL_ID OR B.EDC_ID = p_EDC_ID)
						AND A.MODEL_ID = p_MODEL_ID
						AND A.SCENARIO_ID = p_SCENARIO_ID
						AND A.AS_OF_DATE =
							(SELECT MAX(AS_OF_DATE)
							FROM SERVICE_OBLIGATION
							WHERE MODEL_ID = A.MODEL_ID
								AND SCENARIO_ID = A.SCENARIO_ID
								AND PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
								AND SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
								AND AS_OF_DATE <= v_AS_OF_DATE)
						AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
						AND A.SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
						AND C.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
						AND C.SERVICE_CODE = UPPER(SUBSTR(p_REQUEST_TYPE,1,1))
						AND C.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
						AND C.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
					GROUP BY B.EDC_ID, C.LOAD_DATE, C.LOAD_CODE) B
			WHERE A.MODEL_ID = p_MODEL_ID
				AND A.SCENARIO_ID = p_SCENARIO_ID
				AND A.SERVICE_CODE = UPPER(SUBSTR(p_REQUEST_TYPE,1,1))
				AND A.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND A.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
				AND (p_EDC_ID = CONSTANTS.ALL_ID OR A.EDC_ID = p_EDC_ID)
				AND IS_DAY_INTERVAL_OF_TYPE(p_FILTER_HOURS, FROM_CUT(A.LOAD_DATE,p_TIME_ZONE)) = 1
				AND A.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM EDC_SYSTEM_UFE_LOAD
					WHERE MODEL_ID = A.MODEL_ID
						AND SCENARIO_ID = A.SCENARIO_ID
						AND SERVICE_CODE = A.SERVICE_CODE
						AND LOAD_DATE = A.LOAD_DATE
						AND LOAD_CODE = A.LOAD_CODE
						AND EDC_ID = A.EDC_ID
						AND AS_OF_DATE <= v_AS_OF_DATE)
				AND	B.EDC_ID = A.EDC_ID
				AND B.LOAD_DATE = A.LOAD_DATE
				AND B.LOAD_CODE = A.LOAD_CODE
			GROUP BY FROM_CUT_AS_HED(A.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID)
			ORDER BY 1;
	ELSE
		OPEN p_CURSOR FOR
			SELECT FROM_CUT_AS_HED(A.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID) AS "UFE_DATE",
				SUM(UFE_SYSTEM_LOAD) AS "UFE_SYSTEM_LOAD",
				SUM(UFE_SERVICE_LOAD) AS "UFE_RETAIL_LOAD",
				SUM(UFE_SYSTEM_LOAD - UFE_SERVICE_LOAD) AS "UFE_VAL",
				SUM(UFE_SYSTEM_LOAD - UFE_SERVICE_LOAD + TX_LOSS_VAL + DX_LOSS_VAL) AS "RAW_UFE_VAL",
				MIN(UFE_SYSTEM_LOAD) AS "MIN_UFE_SYSTEM_LOAD",
				MAX(UFE_SYSTEM_LOAD) AS "MAX_UFE_SYSTEM_LOAD",
				AVG(UFE_SYSTEM_LOAD) AS "AVG_UFE_SYSTEM_LOAD",
				MIN(UFE_SYSTEM_LOAD - UFE_SERVICE_LOAD) AS "MIN_UFE_VAL",
				MAX(UFE_SYSTEM_LOAD - UFE_SERVICE_LOAD) AS "MAX_UFE_VAL",
				AVG(UFE_SYSTEM_LOAD - UFE_SERVICE_LOAD) AS "AVG_UFE_VAL"
			FROM EDC_SYSTEM_UFE_LOAD A,
            	(SELECT B.EDC_ID, C.LOAD_DATE, C.LOAD_CODE,
                        SUM(C.TX_LOSS_VAL) "TX_LOSS_VAL", SUM(C.DX_LOSS_VAL) "DX_LOSS_VAL"
                	FROM SERVICE_OBLIGATION A,
		                PROVIDER_SERVICE B,
		                SERVICE_OBLIGATION_LOAD C
					WHERE (p_EDC_ID = CONSTANTS.ALL_ID OR B.EDC_ID = p_EDC_ID)
						AND A.MODEL_ID = p_MODEL_ID
						AND A.SCENARIO_ID = p_SCENARIO_ID
						AND A.AS_OF_DATE = v_AS_OF_DATE
						AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
						AND A.SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
						AND C.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
						AND C.SERVICE_CODE = UPPER(SUBSTR(p_REQUEST_TYPE,1,1))
						AND C.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
						AND C.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
					GROUP BY B.EDC_ID, C.LOAD_DATE, C.LOAD_CODE) B
			WHERE A.MODEL_ID = p_MODEL_ID
				AND A.SCENARIO_ID = p_SCENARIO_ID
				AND A.SERVICE_CODE = UPPER(SUBSTR(p_REQUEST_TYPE,1,1))
				AND A.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND A.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
				AND (p_EDC_ID = CONSTANTS.ALL_ID OR A.EDC_ID = p_EDC_ID)
				AND IS_DAY_INTERVAL_OF_TYPE(p_FILTER_HOURS, FROM_CUT(A.LOAD_DATE,p_TIME_ZONE)) = 1
				AND A.AS_OF_DATE = v_AS_OF_DATE
				AND	B.EDC_ID = A.EDC_ID
				AND B.LOAD_DATE = A.LOAD_DATE
				AND B.LOAD_CODE = A.LOAD_CODE
			GROUP BY FROM_CUT_AS_HED(A.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID)
			ORDER BY 1;
	END IF;

END UFE_ALLOCATION_BY_EDC;
---------------------------------------------------------------------------------------------------
PROCEDURE UFE_ALLOCATION_BY_PSE
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the total UFE allocation results for an EDC by PSE
-- Request Type is "F", "B", or "U" for Forecast, Backcast, and Usage respectively.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_AS_OF_DATE DATE;
v_REQUEST_TYPE CHAR(1) := UPPER(SUBSTR(p_REQUEST_TYPE,1,1));

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_BEGIN_DATE, v_END_DATE);
	v_AS_OF_DATE := AS_OF_DATE_FOR_REQUEST(v_REQUEST_TYPE, p_AS_OF_DATE);

	IF IS_VERSIONED_REQUEST(v_REQUEST_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) THEN
		OPEN p_CURSOR FOR
			SELECT B.PSE_NAME, UFE_DATE, ROUND(UFE_VAL,4) "UFE_VAL"
			FROM
				(SELECT PSE_ID, FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE) "UFE_DATE", SUM(NVL(UFE_LOAD_VAL,0)) "UFE_VAL"
				FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_OBLIGATION_LOAD C
				WHERE (p_EDC_ID = CONSTANTS.ALL_ID OR B.EDC_ID = p_EDC_ID)
					AND A.MODEL_ID = p_MODEL_ID
					AND A.SCENARIO_ID = p_SCENARIO_ID
					AND A.AS_OF_DATE =
						(SELECT MAX(AS_OF_DATE)
						FROM SERVICE_OBLIGATION
						WHERE MODEL_ID = A.MODEL_ID
							AND SCENARIO_ID = A.SCENARIO_ID
							AND PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
							AND SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
							AND AS_OF_DATE <= v_AS_OF_DATE)
					AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
					AND A.SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
					AND C.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
					AND C.SERVICE_CODE = v_REQUEST_TYPE
					AND C.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
					AND C.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
				GROUP BY PSE_ID, FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE)) A,
				PURCHASING_SELLING_ENTITY B
			WHERE B.PSE_ID = A.PSE_ID
			ORDER BY 1,2;
	ELSE
		OPEN p_CURSOR FOR
			SELECT B.PSE_NAME, UFE_DATE, ROUND(UFE_VAL,4) "UFE_VAL"
			FROM
				(SELECT PSE_ID, FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE) "UFE_DATE", SUM(NVL(UFE_LOAD_VAL,0)) "UFE_VAL"
				FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_OBLIGATION_LOAD C
				WHERE (p_EDC_ID = CONSTANTS.ALL_ID OR B.EDC_ID = p_EDC_ID)
					AND A.MODEL_ID = p_MODEL_ID
					AND A.SCENARIO_ID = p_SCENARIO_ID
					AND A.AS_OF_DATE = v_AS_OF_DATE
					AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
					AND A.SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
					AND C.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
					AND C.SERVICE_CODE = v_REQUEST_TYPE
					AND C.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
					AND C.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
				GROUP BY PSE_ID, FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE)) A,
				PURCHASING_SELLING_ENTITY B
			WHERE B.PSE_ID = A.PSE_ID
			ORDER BY 1,2;
	END IF;

END UFE_ALLOCATION_BY_PSE;
---------------------------------------------------------------------------------------------------
PROCEDURE UFE_ALLOCATION_BY_ESP
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the total UFE allocation results for an EDC by PSE and ESP
-- Request Type is "F", "B", or "U" for Forecast, Backcast, and Usage respectively.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_AS_OF_DATE DATE;
v_REQUEST_TYPE CHAR(1) := UPPER(SUBSTR(p_REQUEST_TYPE,1,1));

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_BEGIN_DATE, v_END_DATE);
	v_AS_OF_DATE := AS_OF_DATE_FOR_REQUEST(v_REQUEST_TYPE, p_AS_OF_DATE);

	IF IS_VERSIONED_REQUEST(v_REQUEST_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) THEN
		OPEN p_CURSOR FOR
			SELECT B.PSE_NAME, C.ESP_NAME, UFE_DATE, UFE_VAL
			FROM
				(SELECT PSE_ID, ESP_ID, FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE) "UFE_DATE", SUM(NVL(UFE_LOAD_VAL,0)) "UFE_VAL"
				FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_OBLIGATION_LOAD C
				WHERE (p_EDC_ID = CONSTANTS.ALL_ID OR B.EDC_ID = p_EDC_ID)
					AND A.MODEL_ID = p_MODEL_ID
					AND A.SCENARIO_ID = p_SCENARIO_ID
					AND A.AS_OF_DATE =
						(SELECT MAX(AS_OF_DATE)
						FROM SERVICE_OBLIGATION
						WHERE MODEL_ID = A.MODEL_ID
							AND SCENARIO_ID = A.SCENARIO_ID
							AND AS_OF_DATE <= v_AS_OF_DATE
							AND PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
							AND SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID)
					AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
					AND A.SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
					AND C.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
					AND C.SERVICE_CODE = v_REQUEST_TYPE
					AND C.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
					AND C.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
				GROUP BY PSE_ID, ESP_ID, FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE)) A,
				PURCHASING_SELLING_ENTITY B,
				ENERGY_SERVICE_PROVIDER C
			WHERE B.PSE_ID = A.PSE_ID
				AND C.ESP_ID = A.ESP_ID
			ORDER BY 1,2,3;
	ELSE
		OPEN p_CURSOR FOR
			SELECT B.PSE_NAME, C.ESP_NAME, UFE_DATE, UFE_VAL
			FROM
				(SELECT PSE_ID, ESP_ID, FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE) "UFE_DATE", SUM(NVL(UFE_LOAD_VAL,0)) "UFE_VAL"
				FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_OBLIGATION_LOAD C
				WHERE (p_EDC_ID = CONSTANTS.ALL_ID OR B.EDC_ID = p_EDC_ID)
					AND A.MODEL_ID = p_MODEL_ID
					AND A.SCENARIO_ID = p_SCENARIO_ID
					AND A.AS_OF_DATE = v_AS_OF_DATE
					AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
					AND A.SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
					AND C.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
					AND C.SERVICE_CODE = v_REQUEST_TYPE
					AND C.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
					AND C.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
				GROUP BY PSE_ID, ESP_ID, FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE)) A,
				PURCHASING_SELLING_ENTITY B,
				ENERGY_SERVICE_PROVIDER C
			WHERE B.PSE_ID = A.PSE_ID
				AND C.ESP_ID = A.ESP_ID
			ORDER BY 1,2,3;
	END IF;

END UFE_ALLOCATION_BY_ESP;
---------------------------------------------------------------------------------------------------
PROCEDURE UFE_ALLOCATION_BY_POOL
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
    p_SHOW_AGG_POOLS IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the total UFE allocation results for an EDC by Pool and Sub-Pool
-- Request Type is "F", "B", or "U" for Forecast, Backcast, and Usage respectively.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_AS_OF_DATE DATE;
v_REQUEST_TYPE CHAR(1) := UPPER(SUBSTR(p_REQUEST_TYPE,1,1));

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_BEGIN_DATE, v_END_DATE);
	v_AS_OF_DATE := AS_OF_DATE_FOR_REQUEST(v_REQUEST_TYPE, p_AS_OF_DATE);

	IF IS_VERSIONED_REQUEST(v_REQUEST_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) THEN
		OPEN p_CURSOR FOR
			SELECT B.PSE_NAME, C.ESP_NAME, D.POOL_NAME, UFE_DATE, UFE_VAL, E.POOL_NAME, IS_AGG_POOL
			FROM
				(-- normal information
                 SELECT PSE_ID, ESP_ID, C.POOL_ID "POOL_ID",
                	NVL(D.POOL_ID, C.POOL_ID) "AGG_POOL_ID", 0 "IS_AGG_POOL",
					FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE) "UFE_DATE",
					SUM(NVL(UFE_LOAD_VAL,0)) "UFE_VAL"
				FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, POOL_SUB_POOL D, SERVICE_OBLIGATION_LOAD E
				WHERE (p_EDC_ID = CONSTANTS.ALL_ID OR B.EDC_ID = p_EDC_ID)
					AND A.MODEL_ID = p_MODEL_ID
					AND A.SCENARIO_ID = p_SCENARIO_ID
					AND A.AS_OF_DATE =
						(SELECT MAX(AS_OF_DATE)
						FROM SERVICE_OBLIGATION
						WHERE MODEL_ID = A.MODEL_ID
							AND SCENARIO_ID = A.SCENARIO_ID
							AND AS_OF_DATE <= v_AS_OF_DATE
							AND PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
							AND SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID)
					AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
					AND A.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
					AND D.SUB_POOL_ID(+) = C.POOL_ID
					AND D.BEGIN_DATE(+) <= p_END_DATE
					AND NVL(D.END_DATE(+), p_END_DATE) >= p_BEGIN_DATE
					AND E.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
					AND E.SERVICE_CODE = v_REQUEST_TYPE
					AND E.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
					AND E.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
				GROUP BY PSE_ID, ESP_ID,
                	C.POOL_ID, NVL(D.POOL_ID, C.POOL_ID), 0,
                    FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE)
				UNION ALL
                -- union for additional aggregate pool information
                 SELECT PSE_ID, ESP_ID, D.POOL_ID,
                	D.POOL_ID "AGG_POOL_ID", -1 "IS_AGG_POOL",
					FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE) "UFE_DATE",
					SUM(NVL(UFE_LOAD_VAL,0)) "UFE_VAL"
				FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, POOL_SUB_POOL D, SERVICE_OBLIGATION_LOAD E
				WHERE p_SHOW_AGG_POOLS = 1
                	AND (p_EDC_ID = CONSTANTS.ALL_ID OR B.EDC_ID = p_EDC_ID)
					AND A.MODEL_ID = p_MODEL_ID
					AND A.SCENARIO_ID = p_SCENARIO_ID
					AND A.AS_OF_DATE =
						(SELECT MAX(AS_OF_DATE)
						FROM SERVICE_OBLIGATION
						WHERE MODEL_ID = A.MODEL_ID
							AND SCENARIO_ID = A.SCENARIO_ID
							AND AS_OF_DATE <= v_AS_OF_DATE
							AND PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
							AND SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID)
					AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
					AND A.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
					AND D.SUB_POOL_ID = C.POOL_ID
					AND D.BEGIN_DATE <= p_END_DATE
					AND NVL(D.END_DATE, p_END_DATE) >= p_BEGIN_DATE
                    AND D.POOL_ID <> D.SUB_POOL_ID
					AND E.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
					AND E.SERVICE_CODE = v_REQUEST_TYPE
					AND E.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
					AND E.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
				GROUP BY PSE_ID, ESP_ID, D.POOL_ID, -1,
                    FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE)) A,
				PURCHASING_SELLING_ENTITY B, ENERGY_SERVICE_PROVIDER C, POOL D, POOL E
			WHERE B.PSE_ID = A.PSE_ID
				AND C.ESP_ID = A.ESP_ID
				AND D.POOL_ID = A.POOL_ID
                AND E.POOL_ID = A.AGG_POOL_ID
			ORDER BY 1, 2, 6, 7, 3, 4;
	ELSE
		OPEN p_CURSOR FOR
			SELECT B.PSE_NAME, C.ESP_NAME, D.POOL_NAME, UFE_DATE, UFE_VAL, E.POOL_NAME, IS_AGG_POOL
			FROM
				(-- normal information
                 SELECT PSE_ID, ESP_ID, C.POOL_ID "POOL_ID",
                	NVL(D.POOL_ID, C.POOL_ID) "AGG_POOL_ID", 0 "IS_AGG_POOL",
					FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE) "UFE_DATE",
					SUM(NVL(UFE_LOAD_VAL,0)) "UFE_VAL"
				FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, POOL_SUB_POOL D, SERVICE_OBLIGATION_LOAD E
				WHERE (p_EDC_ID = CONSTANTS.ALL_ID OR B.EDC_ID = p_EDC_ID)
					AND A.MODEL_ID = p_MODEL_ID
					AND A.SCENARIO_ID = p_SCENARIO_ID
					AND A.AS_OF_DATE = v_AS_OF_DATE
					AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
					AND A.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
					AND D.SUB_POOL_ID(+) = C.POOL_ID
					AND D.BEGIN_DATE(+) <= p_END_DATE
					AND NVL(D.END_DATE(+), p_END_DATE) >= p_BEGIN_DATE
					AND E.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
					AND E.SERVICE_CODE = v_REQUEST_TYPE
					AND E.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
					AND E.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
				GROUP BY PSE_ID, ESP_ID,
                	C.POOL_ID, NVL(D.POOL_ID, C.POOL_ID), 0,
                    FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE)
				UNION ALL
                -- union for additional aggregate pool information
                 SELECT PSE_ID, ESP_ID, D.POOL_ID,
                	D.POOL_ID "AGG_POOL_ID", -1 "IS_AGG_POOL",
					FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE) "UFE_DATE",
					SUM(NVL(UFE_LOAD_VAL,0)) "UFE_VAL"
				FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, POOL_SUB_POOL D, SERVICE_OBLIGATION_LOAD E
				WHERE p_SHOW_AGG_POOLS = 1
                	AND (p_EDC_ID = CONSTANTS.ALL_ID OR B.EDC_ID = p_EDC_ID)
					AND A.MODEL_ID = p_MODEL_ID
					AND A.SCENARIO_ID = p_SCENARIO_ID
					AND A.AS_OF_DATE = v_AS_OF_DATE
					AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
					AND A.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
					AND D.SUB_POOL_ID = C.POOL_ID
					AND D.BEGIN_DATE <= p_END_DATE
					AND NVL(D.END_DATE, p_END_DATE) >= p_BEGIN_DATE
                    AND D.POOL_ID <> D.SUB_POOL_ID
					AND E.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
					AND E.SERVICE_CODE = v_REQUEST_TYPE
					AND E.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
					AND E.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
				GROUP BY PSE_ID, ESP_ID, D.POOL_ID, -1,
                    FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE)) A,
				PURCHASING_SELLING_ENTITY B, ENERGY_SERVICE_PROVIDER C, POOL D, POOL E
			WHERE B.PSE_ID = A.PSE_ID
				AND C.ESP_ID = A.ESP_ID
				AND D.POOL_ID = A.POOL_ID
                AND E.POOL_ID = A.AGG_POOL_ID
			ORDER BY 1, 2, 6, 7, 3, 4;
	END IF;

END UFE_ALLOCATION_BY_POOL;
---------------------------------------------------------------------------------------------------
PROCEDURE UFE_ALLOCATION_DETAILS
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
    p_DETAIL IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
    p_SHOW_AGG_POOLS IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the total UFE allocation results for an EDC by Pool and Sub-Pool
-- Request Type is "F", "B", or "U" for Forecast, Backcast, and Usage respectively.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_AS_OF_DATE DATE;
v_REQUEST_TYPE CHAR(1) := UPPER(SUBSTR(p_REQUEST_TYPE,1,1));
v_SHOW_ESP NUMBER;
v_SHOW_POOL NUMBER;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_BEGIN_DATE, v_END_DATE);
	v_AS_OF_DATE := AS_OF_DATE_FOR_REQUEST(v_REQUEST_TYPE, p_AS_OF_DATE);
    IF p_DETAIL = 'PSE' THEN
    	v_SHOW_ESP := 0;
    	v_SHOW_POOL := 0;
    ELSIF p_DETAIL = 'ESP' THEN
    	v_SHOW_ESP := 1;
    	v_SHOW_POOL := 0;
    ELSE
    	v_SHOW_ESP := 1;
    	v_SHOW_POOL := 1;
    END IF;

	IF IS_VERSIONED_REQUEST(v_REQUEST_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) THEN
		OPEN p_CURSOR FOR
			SELECT B.PSE_NAME, C.ESP_NAME, D.POOL_NAME,
            	UFE_DATE, LOAD_VAL, DX_LOSS_VAL, TX_LOSS_VAL, UFE_VAL,
                E.POOL_NAME "AGG_POOL_NAME", IS_AGG_POOL
			FROM
				(-- normal information
                 SELECT PSE_ID,
                 	DECODE(v_SHOW_ESP,1,ESP_ID,CONSTANTS.NOT_ASSIGNED) "ESP_ID",
                    DECODE(v_SHOW_POOL,1,C.POOL_ID,CONSTANTS.NOT_ASSIGNED) "POOL_ID",
                    DECODE(v_SHOW_POOL,1,NVL(D.POOL_ID, C.POOL_ID),CONSTANTS.NOT_ASSIGNED) "AGG_POOL_ID",
                    0 "IS_AGG_POOL",
					FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE) "UFE_DATE",
					SUM(NVL(LOAD_VAL,0)) "LOAD_VAL",
					SUM(NVL(DX_LOSS_VAL,0)) "DX_LOSS_VAL",
					SUM(NVL(TX_LOSS_VAL,0)) "TX_LOSS_VAL",
					SUM(NVL(UFE_LOAD_VAL,0)) "UFE_VAL"
				FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, POOL_SUB_POOL D, SERVICE_OBLIGATION_LOAD E
				WHERE (p_EDC_ID = CONSTANTS.ALL_ID OR B.EDC_ID = p_EDC_ID)
					AND A.MODEL_ID = p_MODEL_ID
					AND A.SCENARIO_ID = p_SCENARIO_ID
					AND A.AS_OF_DATE =
						(SELECT MAX(AS_OF_DATE)
						FROM SERVICE_OBLIGATION
						WHERE MODEL_ID = A.MODEL_ID
							AND SCENARIO_ID = A.SCENARIO_ID
							AND AS_OF_DATE <= v_AS_OF_DATE
							AND PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
							AND SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID)
					AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
					AND A.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
					AND D.SUB_POOL_ID(+) = C.POOL_ID
					AND D.BEGIN_DATE(+) <= p_END_DATE
					AND NVL(D.END_DATE(+), p_END_DATE) >= p_BEGIN_DATE
					AND E.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
					AND E.SERVICE_CODE = v_REQUEST_TYPE
					AND E.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
					AND E.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
				GROUP BY PSE_ID, DECODE(v_SHOW_ESP,1,ESP_ID,CONSTANTS.NOT_ASSIGNED),
                	DECODE(v_SHOW_POOL,1,C.POOL_ID,CONSTANTS.NOT_ASSIGNED),
                    DECODE(v_SHOW_POOL,1,NVL(D.POOL_ID, C.POOL_ID),CONSTANTS.NOT_ASSIGNED), 0,
                    FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE)
				UNION ALL
                -- union for additional aggregate pool information
                 SELECT PSE_ID,
                 	DECODE(v_SHOW_ESP,1,ESP_ID,CONSTANTS.NOT_ASSIGNED) "ESP_ID",
                    DECODE(v_SHOW_POOL,1,D.POOL_ID,CONSTANTS.NOT_ASSIGNED) "POOL_ID",
                    DECODE(v_SHOW_POOL,1,D.POOL_ID,CONSTANTS.NOT_ASSIGNED) "AGG_POOL_ID",
                    -1 "IS_AGG_POOL",
					FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE) "UFE_DATE",
					SUM(NVL(LOAD_VAL,0)) "LOAD_VAL",
					SUM(NVL(DX_LOSS_VAL,0)) "DX_LOSS_VAL",
					SUM(NVL(TX_LOSS_VAL,0)) "TX_LOSS_VAL",
					SUM(NVL(UFE_LOAD_VAL,0)) "UFE_VAL"
				FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, POOL_SUB_POOL D, SERVICE_OBLIGATION_LOAD E
				WHERE v_SHOW_POOL = 1 -- no need to get aggregate pools if pools aren't even being shown
                	AND p_SHOW_AGG_POOLS = 1
                	AND (p_EDC_ID = CONSTANTS.ALL_ID OR B.EDC_ID = p_EDC_ID)
					AND A.MODEL_ID = p_MODEL_ID
					AND A.SCENARIO_ID = p_SCENARIO_ID
					AND A.AS_OF_DATE =
						(SELECT MAX(AS_OF_DATE)
						FROM SERVICE_OBLIGATION
						WHERE MODEL_ID = A.MODEL_ID
							AND SCENARIO_ID = A.SCENARIO_ID
							AND AS_OF_DATE <= v_AS_OF_DATE
							AND PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
							AND SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID)
					AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
					AND A.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
					AND D.SUB_POOL_ID = C.POOL_ID
					AND D.BEGIN_DATE <= p_END_DATE
					AND NVL(D.END_DATE, p_END_DATE) >= p_BEGIN_DATE
                    AND D.POOL_ID <> D.SUB_POOL_ID
					AND E.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
					AND E.SERVICE_CODE = v_REQUEST_TYPE
					AND E.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
					AND E.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
				GROUP BY PSE_ID, DECODE(v_SHOW_ESP,1,ESP_ID,CONSTANTS.NOT_ASSIGNED),
                	DECODE(v_SHOW_POOL,1,D.POOL_ID,CONSTANTS.NOT_ASSIGNED), -1,
                    FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE)) A,
				PURCHASING_SELLING_ENTITY B, ENERGY_SERVICE_PROVIDER C, POOL D, POOL E
			WHERE B.PSE_ID = A.PSE_ID
				AND C.ESP_ID = A.ESP_ID
				AND D.POOL_ID = A.POOL_ID
                AND E.POOL_ID = A.AGG_POOL_ID
			ORDER BY 1, 2, 3, 4;
	ELSE
		OPEN p_CURSOR FOR
			SELECT B.PSE_NAME, C.ESP_NAME, D.POOL_NAME,
            	UFE_DATE, LOAD_VAL, DX_LOSS_VAL, TX_LOSS_VAL, UFE_VAL,
                E.POOL_NAME "AGG_POOL_NAME", IS_AGG_POOL
			FROM
				(-- normal information
                 SELECT PSE_ID,
                 	DECODE(v_SHOW_ESP,1,ESP_ID,CONSTANTS.NOT_ASSIGNED) "ESP_ID",
                    DECODE(v_SHOW_POOL,1,C.POOL_ID,CONSTANTS.NOT_ASSIGNED) "POOL_ID",
                    DECODE(v_SHOW_POOL,1,NVL(D.POOL_ID, C.POOL_ID),CONSTANTS.NOT_ASSIGNED) "AGG_POOL_ID",
                    0 "IS_AGG_POOL",
					FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE) "UFE_DATE",
					SUM(NVL(LOAD_VAL,0)) "LOAD_VAL",
					SUM(NVL(DX_LOSS_VAL,0)) "DX_LOSS_VAL",
					SUM(NVL(TX_LOSS_VAL,0)) "TX_LOSS_VAL",
					SUM(NVL(UFE_LOAD_VAL,0)) "UFE_VAL"
				FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, POOL_SUB_POOL D, SERVICE_OBLIGATION_LOAD E
				WHERE (p_EDC_ID = CONSTANTS.ALL_ID OR B.EDC_ID = p_EDC_ID)
					AND A.MODEL_ID = p_MODEL_ID
					AND A.SCENARIO_ID = p_SCENARIO_ID
					AND A.AS_OF_DATE = v_AS_OF_DATE
					AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
					AND A.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
					AND D.SUB_POOL_ID(+) = C.POOL_ID
					AND D.BEGIN_DATE(+) <= p_END_DATE
					AND NVL(D.END_DATE(+), p_END_DATE) >= p_BEGIN_DATE
					AND E.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
					AND E.SERVICE_CODE = v_REQUEST_TYPE
					AND E.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
					AND E.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
				GROUP BY PSE_ID, DECODE(v_SHOW_ESP,1,ESP_ID,CONSTANTS.NOT_ASSIGNED),
                	DECODE(v_SHOW_POOL,1,C.POOL_ID,CONSTANTS.NOT_ASSIGNED),
                    DECODE(v_SHOW_POOL,1,NVL(D.POOL_ID, C.POOL_ID),CONSTANTS.NOT_ASSIGNED), 0,
                    FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE)
				UNION ALL
                -- union for additional aggregate pool information
                 SELECT PSE_ID,
                 	DECODE(v_SHOW_ESP,1,ESP_ID,CONSTANTS.NOT_ASSIGNED) "ESP_ID",
                    DECODE(v_SHOW_POOL,1,D.POOL_ID,CONSTANTS.NOT_ASSIGNED) "POOL_ID",
                    DECODE(v_SHOW_POOL,1,D.POOL_ID,CONSTANTS.NOT_ASSIGNED) "AGG_POOL_ID",
                    -1 "IS_AGG_POOL",
					FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE) "UFE_DATE",
					SUM(NVL(LOAD_VAL,0)) "LOAD_VAL",
					SUM(NVL(DX_LOSS_VAL,0)) "DX_LOSS_VAL",
					SUM(NVL(TX_LOSS_VAL,0)) "TX_LOSS_VAL",
					SUM(NVL(UFE_LOAD_VAL,0)) "UFE_VAL"
				FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, POOL_SUB_POOL D, SERVICE_OBLIGATION_LOAD E
				WHERE v_SHOW_POOL = 1 -- no need to get aggregate pools if pools aren't even being shown
                	AND p_SHOW_AGG_POOLS = 1
                	AND (p_EDC_ID = CONSTANTS.ALL_ID OR B.EDC_ID = p_EDC_ID)
					AND A.MODEL_ID = p_MODEL_ID
					AND A.SCENARIO_ID = p_SCENARIO_ID
					AND A.AS_OF_DATE = v_AS_OF_DATE
					AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
					AND A.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
					AND D.SUB_POOL_ID = C.POOL_ID
					AND D.BEGIN_DATE <= p_END_DATE
					AND NVL(D.END_DATE, p_END_DATE) >= p_BEGIN_DATE
                    AND D.POOL_ID <> D.SUB_POOL_ID
					AND E.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
					AND E.SERVICE_CODE = v_REQUEST_TYPE
					AND E.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
					AND E.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
				GROUP BY PSE_ID, DECODE(v_SHOW_ESP,1,ESP_ID,CONSTANTS.NOT_ASSIGNED),
                	DECODE(v_SHOW_POOL,1,D.POOL_ID,CONSTANTS.NOT_ASSIGNED), -1,
                    FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, LOAD_CODE)) A,
				PURCHASING_SELLING_ENTITY B, ENERGY_SERVICE_PROVIDER C, POOL D, POOL E
			WHERE B.PSE_ID = A.PSE_ID
				AND C.ESP_ID = A.ESP_ID
				AND D.POOL_ID = A.POOL_ID
                AND E.POOL_ID = A.AGG_POOL_ID
			ORDER BY 1, 2, 3, 4;
	END IF;

END UFE_ALLOCATION_DETAILS;
---------------------------------------------------------------------------------------------------
PROCEDURE STATION_PARAMETER_NAMES
    (
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of weather stations and parameters defined in the database.

BEGIN

	IF NOT CAN_READ('Weather') THEN
		ERRS.RAISE_NO_READ_MODULE('Weather');
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR

	    SELECT B.STATION_NAME,
		    B.STATION_ID,
			C.PARAMETER_NAME,
			C.PARAMETER_ALIAS,
			C.PARAMETER_ID,
			C.PARAMETER_CATEGORY,
			C.PARAMETER_INTERVAL,
			C.PARAMETER_MEASUREMENT,
			C.PROJECTION_PERIOD
		FROM WEATHER_STATION_PARAMETER A,
			WEATHER_STATION B,
			WEATHER_PARAMETER C
		WHERE B.STATION_ID = A.STATION_ID
		    AND C.PARAMETER_ID = A.PARAMETER_ID
		UNION
			SELECT DISTINCT B.STATION_NAME,
				B.STATION_ID,
				C.PARAMETER_NAME,
				C.PARAMETER_ALIAS,
				C.PARAMETER_ID,
				C.PARAMETER_CATEGORY,
				C.PARAMETER_INTERVAL,
				C.PARAMETER_MEASUREMENT,
				C.PROJECTION_PERIOD
			FROM WEATHER_STATION_COMPOSITE A,
				WEATHER_STATION B,
				WEATHER_PARAMETER C,
				WEATHER_STATION_PARAMETER D
			WHERE A.STATION_ID = B.STATION_ID
				AND A.COMPOSITE_STATION_ID = D.STATION_ID
				AND C.PARAMETER_ID = D.PARAMETER_ID

		ORDER BY 1,3;

END STATION_PARAMETER_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE COMPARE_SERVICE_SUMMARY
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the energy forecast sum for the specified
-- account/meters over the time interval and EDC/PSE/ESP relationship.
-- Request Type is "F", "B", or "U" for Forecast, Backcast, and Usage respectively.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_AS_OF_DATE DATE;

BEGIN

	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_BEGIN_DATE, v_END_DATE);
	v_AS_OF_DATE := AS_OF_DATE_FOR_REQUEST(p_REQUEST_TYPE, p_AS_OF_DATE);

	IF IS_VERSIONED_REQUEST(p_REQUEST_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) THEN
		OPEN p_CURSOR FOR
			SELECT FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID) "COMPARE_DATE",
				SUM(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL) "COMPARE_VAL",
				SUM(AGG_LOAD_VAL + AGG_TX_LOSS_VAL + AGG_DX_LOSS_VAL) "AGG_VAL",
				SUM(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL - (AGG_LOAD_VAL + AGG_TX_LOSS_VAL + AGG_DX_LOSS_VAL)) "NON_AGG_VAL"
			FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, SERVICE_OBLIGATION_LOAD D
			WHERE (p_EDC_ID = g_NA_BRANCH OR B.EDC_ID = p_EDC_ID)
				AND (p_ESP_ID = g_NA_BRANCH OR B.ESP_ID = p_ESP_ID)
				AND (p_PSE_ID = g_NA_BRANCH OR B.PSE_ID = p_PSE_ID)
				AND (p_POOL_ID = g_NA_BRANCH OR C.POOL_ID = p_POOL_ID)
				AND A.MODEL_ID = p_MODEL_ID
				AND A.SCENARIO_ID = p_SCENARIO_ID
				AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
				AND A.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
				AND A.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM SERVICE_OBLIGATION
					WHERE MODEL_ID = A.MODEL_ID
						AND SCENARIO_ID = A.SCENARIO_ID
						AND PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
						AND SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
						AND AS_OF_DATE <= v_AS_OF_DATE)
				AND D.SERVICE_CODE = UPPER(SUBSTR(p_REQUEST_TYPE,1,1))
				AND D.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND D.LOAD_CODE = GA.STANDARD
				AND D.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
			GROUP BY FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID)
			ORDER BY 1;
	ELSE
		OPEN p_CURSOR FOR
			SELECT FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID) "COMPARE_DATE",
				SUM(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL) "COMPARE_VAL",
				SUM(AGG_LOAD_VAL + AGG_TX_LOSS_VAL + AGG_DX_LOSS_VAL) "AGG_VAL",
				SUM(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL - (AGG_LOAD_VAL + AGG_TX_LOSS_VAL + AGG_DX_LOSS_VAL)) "NON_AGG_VAL"
			FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, SERVICE_OBLIGATION_LOAD D
			WHERE (p_EDC_ID = g_NA_BRANCH OR B.EDC_ID = p_EDC_ID)
				AND (p_ESP_ID = g_NA_BRANCH OR B.ESP_ID = p_ESP_ID)
				AND (p_PSE_ID = g_NA_BRANCH OR B.PSE_ID = p_PSE_ID)
				AND (p_POOL_ID = g_NA_BRANCH OR C.POOL_ID = p_POOL_ID)
				AND A.MODEL_ID = p_MODEL_ID
				AND A.SCENARIO_ID = p_SCENARIO_ID
				AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
				AND A.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
				AND A.AS_OF_DATE = v_AS_OF_DATE
				AND D.SERVICE_CODE = UPPER(SUBSTR(p_REQUEST_TYPE,1,1))
				AND D.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND D.LOAD_CODE = GA.STANDARD
				AND D.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
			GROUP BY FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID)
			ORDER BY 1;
	END IF;

END COMPARE_SERVICE_SUMMARY;
---------------------------------------------------------------------------------------------------
PROCEDURE COMPARE_SERVICE_DETAIL
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_AGGREGATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the energy Forecast for the specified account/meter over the time interval.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_AS_OF_DATE DATE;
v_STATUS NUMBER;
v_INCLUDE_TD_LOSSES NUMBER(1);

BEGIN

	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_BEGIN_DATE, v_END_DATE);
	v_AS_OF_DATE := AS_OF_DATE_FOR_REQUEST(p_REQUEST_TYPE, p_AS_OF_DATE);

	IF p_REQUEST_TYPE = GA.ACTUAL_SERVICE THEN
		v_INCLUDE_TD_LOSSES := 1;
	ELSE
		v_INCLUDE_TD_LOSSES := 1;
	END IF;

	IF p_REQUEST_TYPE = GA.ACTUAL_SERVICE AND GA.ENABLE_EXTERNAL_METER_ACCESS THEN
		XS.CACHE_USAGE(p_ACCOUNT_ID, p_SERVICE_LOCATION_ID, p_METER_ID, p_AGGREGATE_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, v_STATUS);
		IF NOT v_STATUS = GA.SUCCESS THEN
			ERRS.RAISE(MSGCODES.c_ERR_GENERAL,'CACHE_USAGE Returned Non-zero Status: ' || TO_CHAR(v_STATUS));
		END IF;
	END IF;

	IF IS_VERSIONED_REQUEST(p_REQUEST_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) THEN
		OPEN p_CURSOR FOR
			SELECT FROM_CUT_AS_HED(E.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID) AS COMPARE_DATE,
				SUM(DECODE(v_INCLUDE_TD_LOSSES, 0 , E.LOAD_VAL, E.LOAD_VAL + E.TX_LOSS_VAL + E.DX_LOSS_VAL)) "COMPARE_VAL",
			    SUM(DECODE(B.AGGREGATE_ID, 0, 0, DECODE(v_INCLUDE_TD_LOSSES, 0 , E.LOAD_VAL, E.LOAD_VAL + E.TX_LOSS_VAL + E.DX_LOSS_VAL))) "AGG_VAL",
			    SUM(DECODE(B.AGGREGATE_ID, 0, DECODE(v_INCLUDE_TD_LOSSES, 0 , E.LOAD_VAL, E.LOAD_VAL + E.TX_LOSS_VAL + E.DX_LOSS_VAL), 0)) "NON_AGG_VAL"
			FROM PROVIDER_SERVICE A, ACCOUNT_SERVICE B, SERVICE C, SERVICE_DELIVERY D, SERVICE_LOAD E
			WHERE (p_EDC_ID = g_NA_BRANCH OR A.EDC_ID = p_EDC_ID)
				AND (p_ESP_ID = g_NA_BRANCH OR A.ESP_ID = p_ESP_ID)
				AND (p_PSE_ID = g_NA_BRANCH OR A.PSE_ID = p_PSE_ID)
				AND (p_ACCOUNT_ID = g_NA_NODE OR B.ACCOUNT_ID = p_ACCOUNT_ID)
				AND (p_SERVICE_LOCATION_ID = g_NA_NODE OR B.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID)
				AND (p_METER_ID = g_NA_NODE OR B.METER_ID = p_METER_ID)
				AND (p_AGGREGATE_ID = g_NA_NODE OR B.AGGREGATE_ID = p_AGGREGATE_ID)
				AND (p_POOL_ID = g_NA_BRANCH OR D.POOL_ID = p_POOL_ID)
				AND C.MODEL_ID = p_MODEL_ID
				AND C.SCENARIO_ID = p_SCENARIO_ID
				AND C.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
				AND C.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
				AND C.SERVICE_DELIVERY_ID = D.SERVICE_DELIVERY_ID
				AND C.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM SERVICE
					WHERE MODEL_ID = C.MODEL_ID
						AND SCENARIO_ID = C.SCENARIO_ID
						AND ACCOUNT_SERVICE_ID = C.ACCOUNT_SERVICE_ID
						AND PROVIDER_SERVICE_ID = C.PROVIDER_SERVICE_ID
						AND SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
						AND AS_OF_DATE <= v_AS_OF_DATE)
				AND E.SERVICE_CODE = p_REQUEST_TYPE
				AND E.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND E.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
				AND E.SERVICE_ID = C.SERVICE_ID
			GROUP BY FROM_CUT_AS_HED(E.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID)
			ORDER BY 1;
	ELSE
		OPEN p_CURSOR FOR
			SELECT FROM_CUT_AS_HED(E.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID) AS COMPARE_DATE,
				SUM(DECODE(v_INCLUDE_TD_LOSSES, 0 , E.LOAD_VAL, E.LOAD_VAL + E.TX_LOSS_VAL + E.DX_LOSS_VAL)) "COMPARE_VAL",
			    SUM(DECODE(B.AGGREGATE_ID, 0, 0, DECODE(v_INCLUDE_TD_LOSSES, 0 , E.LOAD_VAL, E.LOAD_VAL + E.TX_LOSS_VAL + E.DX_LOSS_VAL))) "AGG_VAL",
			    SUM(DECODE(B.AGGREGATE_ID, 0, DECODE(v_INCLUDE_TD_LOSSES, 0 , E.LOAD_VAL, E.LOAD_VAL + E.TX_LOSS_VAL + E.DX_LOSS_VAL), 0)) "NON_AGG_VAL"
			FROM PROVIDER_SERVICE A, ACCOUNT_SERVICE B, SERVICE C, SERVICE_DELIVERY D, SERVICE_LOAD E
			WHERE (p_EDC_ID = g_NA_BRANCH OR A.EDC_ID = p_EDC_ID)
				AND (p_ESP_ID = g_NA_BRANCH OR A.ESP_ID = p_ESP_ID)
				AND (p_PSE_ID = g_NA_BRANCH OR A.PSE_ID = p_PSE_ID)
				AND (p_ACCOUNT_ID = g_NA_NODE OR B.ACCOUNT_ID = p_ACCOUNT_ID)
				AND (p_SERVICE_LOCATION_ID = g_NA_NODE OR B.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID)
				AND (p_METER_ID = g_NA_NODE OR B.METER_ID = p_METER_ID)
				AND (p_AGGREGATE_ID = g_NA_NODE OR B.AGGREGATE_ID = p_AGGREGATE_ID)
				AND (p_POOL_ID = g_NA_BRANCH OR D.POOL_ID = p_POOL_ID)
				AND C.MODEL_ID = p_MODEL_ID
				AND C.SCENARIO_ID = p_SCENARIO_ID
				AND C.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
				AND C.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
				AND C.SERVICE_DELIVERY_ID = D.SERVICE_DELIVERY_ID
				AND C.AS_OF_DATE = v_AS_OF_DATE
				AND E.SERVICE_CODE = p_REQUEST_TYPE
				AND E.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND E.LOAD_CODE = GA.STANDARD
				AND E.SERVICE_ID = C.SERVICE_ID
			GROUP BY FROM_CUT_AS_HED(E.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID)
			ORDER BY 1;
	END IF;

	IF p_REQUEST_TYPE = GA.ACTUAL_SERVICE AND GA.ENABLE_EXTERNAL_METER_ACCESS THEN
		XS.RELEASE_USAGE(p_ACCOUNT_ID, p_SERVICE_LOCATION_ID, p_METER_ID, p_AGGREGATE_ID, p_BEGIN_DATE, p_END_DATE);
	END IF;

END COMPARE_SERVICE_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE COMPARE_SERVICE
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_AGGREGATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the energy forecast for the specified
-- account/meter over the time interval.
-- Request Type is "FB", "FU", or "BU" for Forecast vs Backcast, Forecast vs Usage, and Backcast vs Usage respectively.

BEGIN

	IF NOT CAN_READ('SETTLEMENT') THEN
		ERRS.RAISE_NO_READ_MODULE('SETTLEMENT');
	END IF;

	p_STATUS := GA.SUCCESS;

	IF p_ACCOUNT_ID = g_NA_NODE AND  p_SERVICE_LOCATION_ID = g_NA_NODE AND p_METER_ID = g_NA_NODE AND p_AGGREGATE_ID = g_NA_NODE THEN
		COMPARE_SERVICE_SUMMARY(p_REQUEST_TYPE, p_MODEL_ID, p_SCENARIO_ID, p_EDC_ID, p_PSE_ID, p_ESP_ID, p_POOL_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE, p_INTERVAL, p_CURSOR);
	ELSE
		COMPARE_SERVICE_DETAIL(p_REQUEST_TYPE, p_MODEL_ID, p_SCENARIO_ID, p_EDC_ID, p_PSE_ID, p_ESP_ID, p_POOL_ID, p_ACCOUNT_ID, p_SERVICE_LOCATION_ID, p_METER_ID, p_AGGREGATE_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE, p_INTERVAL, p_CURSOR);
	END IF;

END COMPARE_SERVICE;
---------------------------------------------------------------------------------------------------
PROCEDURE EDC_NAMES
    (
	p_REQUEST_TYPE IN CHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of EDCs of the specified type.

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT EDC_NAME, EDC_ID, UPPER(EDC_NAME)
		FROM ENERGY_DISTRIBUTION_COMPANY
		WHERE UPPER(SUBSTR(EDC_STATUS,1,1)) = 'A'
		ORDER BY 3;

END EDC_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE ESP_NAMES
    (
	p_REQUEST_TYPE IN CHAR,
	p_ESP_TYPE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of ESPs of the specified type.
v_ESP_TYPE VARCHAR(64);
BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;
	 v_ESP_TYPE := UPPER(LTRIM(RTRIM(P_ESP_TYPE)));

	OPEN p_CURSOR FOR
	    SELECT ESP_NAME, ESP_ID, UPPER(ESP_NAME)
		FROM ENERGY_SERVICE_PROVIDER
		WHERE UPPER(ESP_TYPE) = DECODE(v_ESP_TYPE,'ALL',UPPER(ESP_TYPE),v_ESP_TYPE)
		    AND UPPER(SUBSTR(ESP_STATUS,1,1)) = 'A'
		ORDER BY 3;

END ESP_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_NAMES
    (
	p_REQUEST_TYPE IN CHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of PSEs (include the backup generation attribute).

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT PSE_NAME, PSE_ID, PSE_IS_BACKUP_GENERATION, UPPER(PSE_NAME)
		FROM PURCHASING_SELLING_ENTITY
		WHERE UPPER(SUBSTR(PSE_STATUS,1,1)) = 'A'
			AND (PSE_IS_RETAIL_AGGREGATOR = 1 OR PSE_IS_BACKUP_GENERATION = 1)
		ORDER BY 4;

END PSE_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE POOL_NAMES
    (
	p_REQUEST_TYPE IN CHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of PSEs (include the backup generation attribute).

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT POOL_NAME, POOL_ID, UPPER(POOL_NAME)
		FROM POOL
		WHERE UPPER(SUBSTR(POOL_STATUS,1,1)) = 'A'
		ORDER BY 3;

END POOL_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE INTERVAL_BILLED_USAGE_DETAIL
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SERVICE_POINT_ID IN NUMBER,
	p_THRESHOLD IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the interval bill usage detail information

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;

	IF GA.ENABLE_EXTERNAL_METER_ACCESS THEN
		XS.CACHE_INTERVAL_CONSUMPTION(p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_STATUS);
	END IF;

	IF GA.VERSION_CONSUMPTION THEN
		OPEN p_CURSOR FOR
			SELECT B.EDC_ID, B.EDC_NAME, C.ESP_ID, C.ESP_NAME, D.ACCOUNT_NAME, D.ACCOUNT_ID, E.SERVICE_LOCATION_NAME, E.SERVICE_LOCATION_ID,
				F.METER_NAME, F.METER_ID, G.PERIOD_NAME, A.BEGIN_DATE, A.END_DATE, A.BILLED_USAGE, A.METERED_USAGE, D.ACCOUNT_EXTERNAL_IDENTIFIER
			FROM
				(SELECT B.ACCOUNT_ID, B.SERVICE_LOCATION_ID, B.METER_ID, D.BEGIN_DATE, D.END_DATE, D.PERIOD_ID, D.BILLED_USAGE, D.METERED_USAGE
				FROM  PROVIDER_SERVICE A, ACCOUNT_SERVICE B, SERVICE C, SERVICE_CONSUMPTION D
				WHERE A.EDC_ID = p_EDC_ID
					AND A.ESP_ID = p_ESP_ID
					AND A.PSE_ID = A.PSE_ID
					AND C.MODEL_ID = p_MODEL_ID
					AND C.SCENARIO_ID = p_SCENARIO_ID
					AND C.AS_OF_DATE =
						(SELECT MAX(AS_OF_DATE)
						FROM SERVICE
						WHERE MODEL_ID = C.MODEL_ID
							AND SCENARIO_ID = C.SCENARIO_ID
							AND AS_OF_DATE <= p_AS_OF_DATE
							AND PROVIDER_SERVICE_ID = C.PROVIDER_SERVICE_ID
							AND ACCOUNT_SERVICE_ID = C.ACCOUNT_SERVICE_ID)
					AND C.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
					AND C.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
					AND D.SERVICE_ID = C.SERVICE_ID
					AND D.BEGIN_DATE <= p_END_DATE
					AND D.END_DATE >= p_BEGIN_DATE
					AND D.METER_TYPE = 'I'
					AND D.UNIT_OF_MEASUREMENT = GA.DEFAULT_UNIT_OF_MEASUREMENT) A,
				ENERGY_DISTRIBUTION_COMPANY B,
				ENERGY_SERVICE_PROVIDER C,
			    ACCOUNT D,
				SERVICE_LOCATION E,
				METER F,
                PERIOD G
			WHERE B.EDC_ID = p_EDC_ID
				AND C.ESP_ID = p_ESP_ID
				AND D.ACCOUNT_ID = A.ACCOUNT_ID
			    AND E.SERVICE_LOCATION_ID = A.SERVICE_LOCATION_ID
				AND F.METER_ID = A.METER_ID
                AND G.PERIOD_ID = A.PERIOD_ID
				ORDER BY D.ACCOUNT_NAME, E.SERVICE_LOCATION_NAME, F.METER_NAME, G.PERIOD_NAME;
	ELSE
		OPEN p_CURSOR FOR
			SELECT B.EDC_ID, B.EDC_NAME, C.ESP_ID, C.ESP_NAME, D.ACCOUNT_NAME, D.ACCOUNT_ID, E.SERVICE_LOCATION_NAME, E.SERVICE_LOCATION_ID,
				F.METER_NAME, F.METER_ID, G.PERIOD_NAME, A.BEGIN_DATE, A.END_DATE, A.BILLED_USAGE, A.METERED_USAGE, D.ACCOUNT_EXTERNAL_IDENTIFIER
			FROM
				(SELECT B.ACCOUNT_ID, B.SERVICE_LOCATION_ID, B.METER_ID, D.BEGIN_DATE, D.END_DATE, D.PERIOD_ID, D.BILLED_USAGE, D.METERED_USAGE
				FROM  PROVIDER_SERVICE A, ACCOUNT_SERVICE B, SERVICE C, SERVICE_CONSUMPTION D
				WHERE A.EDC_ID = p_EDC_ID
					AND A.ESP_ID = p_ESP_ID
					AND A.PSE_ID = A.PSE_ID
					AND C.MODEL_ID = p_MODEL_ID
					AND C.SCENARIO_ID = p_SCENARIO_ID
					AND C.AS_OF_DATE = CONSTANTS.LOW_DATE
					AND C.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
					AND C.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
					AND D.SERVICE_ID = C.SERVICE_ID
					AND D.BEGIN_DATE <= p_END_DATE
					AND D.END_DATE >= p_BEGIN_DATE
					AND D.METER_TYPE = 'I'
					AND D.UNIT_OF_MEASUREMENT = GA.DEFAULT_UNIT_OF_MEASUREMENT) A,
				ENERGY_DISTRIBUTION_COMPANY B,
				ENERGY_SERVICE_PROVIDER C,
			    ACCOUNT D,
				SERVICE_LOCATION E,
				METER F,
                PERIOD G
			WHERE B.EDC_ID = p_EDC_ID
				AND C.ESP_ID = p_ESP_ID
				AND D.ACCOUNT_ID = A.ACCOUNT_ID
			    AND E.SERVICE_LOCATION_ID = A.SERVICE_LOCATION_ID
				AND F.METER_ID = A.METER_ID
                AND G.PERIOD_ID = A.PERIOD_ID
				ORDER BY D.ACCOUNT_NAME, E.SERVICE_LOCATION_NAME, F.METER_NAME, G.PERIOD_NAME;
	END IF;

	IF GA.ENABLE_EXTERNAL_METER_ACCESS THEN
		XS.RELEASE_INTERVAL_CONSUMPTION;
	END IF;

END INTERVAL_BILLED_USAGE_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE PERIOD_BILLED_USAGE_DETAIL
	(
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_CONSUMPTION_CODE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the accounts in service for the specified
-- account, time interval and EDC/PSE/ESP relationship.

v_CONSUMPTION_CODE CHAR(1);
BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;
	v_CONSUMPTION_CODE := UPPER(SUBSTR(p_CONSUMPTION_CODE,1,1));

	IF GA.ENABLE_EXTERNAL_METER_ACCESS THEN
		XS.CACHE_CONSUMPTION(p_SERVICE_DATE, p_SERVICE_DATE, p_AS_OF_DATE, p_STATUS);
	END IF;

	IF GA.VERSION_CONSUMPTION THEN
		OPEN p_CURSOR FOR
			SELECT B.ACCOUNT_NAME,
					 B.ACCOUNT_ID,
                     C.PERIOD_NAME,
					 A.BEGIN_DATE,
					 A.END_DATE,
					 A.NUMBER_OF_DAYS,
					 A.METERS_READ,
					 A.BILLED_USAGE,
					 B.ACCOUNT_EXTERNAL_IDENTIFIER,
					 A.CONSUMPTION_CODE,
					 A.IGNORE_CONSUMPTION,
					 A.HAS_AUDIT_TRAIL,
					 A.CONSUMPTION_ID,
					 A.METERED_USAGE,
					 (A.BILLED_USAGE/A.NUMBER_OF_DAYS) / (DECODE(A.METERS_READ,0,NULL,A.METERS_READ)) "AVERAGE_CONSUMPTION"
			FROM
				(SELECT B.ACCOUNT_ID, D.BEGIN_DATE, D.END_DATE, D.METERS_READ, D.PERIOD_ID, D.BILLED_USAGE,
						  D.CONSUMPTION_CODE, D.IGNORE_CONSUMPTION, 0 "HAS_AUDIT_TRAIL", D.CONSUMPTION_ID,
						  (D.END_DATE - D.BEGIN_DATE) + 1 "NUMBER_OF_DAYS", D.METERED_USAGE
				FROM PROVIDER_SERVICE A, ACCOUNT_SERVICE B, SERVICE C, SERVICE_CONSUMPTION D
				WHERE A.EDC_ID = p_EDC_ID
					AND A.ESP_ID = p_ESP_ID
					AND A.PSE_ID = A.PSE_ID
					AND B.ACCOUNT_ID = p_ACCOUNT_ID
					AND C.MODEL_ID = p_MODEL_ID
					AND C.SCENARIO_ID = p_SCENARIO_ID
					AND C.AS_OF_DATE =
						(SELECT MAX(AS_OF_DATE)
						FROM SERVICE
						WHERE MODEL_ID = C.MODEL_ID
							AND SCENARIO_ID = C.SCENARIO_ID
							AND AS_OF_DATE <= p_AS_OF_DATE
							AND PROVIDER_SERVICE_ID = C.PROVIDER_SERVICE_ID
							AND ACCOUNT_SERVICE_ID = C.ACCOUNT_SERVICE_ID)
					AND C.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
					AND C.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
					AND D.SERVICE_ID = C.SERVICE_ID
					AND TRUNC(p_SERVICE_DATE) BETWEEN D.BEGIN_DATE AND D.END_DATE
					AND (v_CONSUMPTION_CODE = '<' OR D.CONSUMPTION_CODE = v_CONSUMPTION_CODE)
					AND D.METER_TYPE = 'P'
					AND D.UNIT_OF_MEASUREMENT = GA.DEFAULT_UNIT_OF_MEASUREMENT) A,
				ACCOUNT B,
                PERIOD C
			WHERE B.ACCOUNT_ID = A.ACCOUNT_ID
            	AND C.PERIOD_ID = A.PERIOD_ID
			ORDER BY 1,2,3;
	ELSE
		OPEN p_CURSOR FOR
			SELECT B.ACCOUNT_NAME,
					 B.ACCOUNT_ID,
                     C.PERIOD_NAME,
					 A.BEGIN_DATE,
					 A.END_DATE,
					 A.NUMBER_OF_DAYS,
					 A.METERS_READ,
					 A.BILLED_USAGE,
					 B.ACCOUNT_EXTERNAL_IDENTIFIER,
					 A.CONSUMPTION_CODE,
					 A.IGNORE_CONSUMPTION,
					 A.HAS_AUDIT_TRAIL,
					 A.CONSUMPTION_ID,
					 A.METERED_USAGE,
					 (A.BILLED_USAGE/A.NUMBER_OF_DAYS) / (DECODE(A.METERS_READ,0,NULL,A.METERS_READ)) "AVERAGE_CONSUMPTION"
			FROM
				(SELECT B.ACCOUNT_ID, D.BEGIN_DATE, D.END_DATE, D.METERS_READ, D.PERIOD_ID, D.BILLED_USAGE,
						  D.CONSUMPTION_CODE, D.IGNORE_CONSUMPTION, 0 "HAS_AUDIT_TRAIL", D.CONSUMPTION_ID,
						  (D.END_DATE - D.BEGIN_DATE) + 1 "NUMBER_OF_DAYS", D.METERED_USAGE
				FROM PROVIDER_SERVICE A, ACCOUNT_SERVICE B, SERVICE C, SERVICE_CONSUMPTION D
				WHERE A.EDC_ID = p_EDC_ID
					AND A.ESP_ID = p_ESP_ID
					AND A.PSE_ID = A.PSE_ID
					AND B.ACCOUNT_ID = p_ACCOUNT_ID
					AND C.MODEL_ID = p_MODEL_ID
					AND C.SCENARIO_ID = p_SCENARIO_ID
					AND C.AS_OF_DATE = CONSTANTS.LOW_DATE
					AND C.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
					AND C.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
					AND D.SERVICE_ID = C.SERVICE_ID
					AND TRUNC(p_SERVICE_DATE) BETWEEN D.BEGIN_DATE AND D.END_DATE
					AND (v_CONSUMPTION_CODE = '<' OR D.CONSUMPTION_CODE = v_CONSUMPTION_CODE)
					AND D.METER_TYPE = 'P'
					AND D.UNIT_OF_MEASUREMENT = GA.DEFAULT_UNIT_OF_MEASUREMENT) A,
				ACCOUNT B,
                PERIOD C
			WHERE B.ACCOUNT_ID = A.ACCOUNT_ID
            	AND C.PERIOD_ID = A.PERIOD_ID
			ORDER BY 1,2,3;
	END IF;

	IF GA.ENABLE_EXTERNAL_METER_ACCESS THEN
	    XS.RELEASE_CONSUMPTION;
	END IF;

END PERIOD_BILLED_USAGE_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE ACCUMULATE_METERS_READ
	(
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TAG_INDEX IN OUT NOCOPY GA.NUMBER_TABLE,
	p_METERS_READ IN OUT NOCOPY GA.NUMBER_TABLE
	) AS

v_TAG NUMBER;
v_INDEX BINARY_INTEGER;
v_SERVICE_DATE DATE;

CURSOR c_VERSION IS
	SELECT A.EDC_ID, A.ESP_ID, B.ACCOUNT_ID,
		GREATEST(D.BEGIN_DATE, p_BEGIN_DATE) "BEGIN_DATE",
		LEAST(D.END_DATE, p_END_DATE) "END_DATE",
		(NVL(D.METERS_READ,0)) "METERS_READ"
	FROM PROVIDER_SERVICE A, ACCOUNT_SERVICE B, SERVICE C, SERVICE_CONSUMPTION D
	WHERE A.EDC_ID = p_EDC_ID
		AND (p_ESP_ID = CONSTANTS.ALL_ID OR A.ESP_ID = p_ESP_ID)
		AND A.PSE_ID = A.PSE_ID
		AND C.MODEL_ID = p_MODEL_ID
		AND C.SCENARIO_ID = p_SCENARIO_ID
		AND C.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM SERVICE
			WHERE MODEL_ID = C.MODEL_ID
			AND SCENARIO_ID = C.SCENARIO_ID
			AND AS_OF_DATE <= p_AS_OF_DATE
			AND PROVIDER_SERVICE_ID = C.PROVIDER_SERVICE_ID
			AND ACCOUNT_SERVICE_ID = C.ACCOUNT_SERVICE_ID)
		AND C.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
		AND C.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
		AND D.SERVICE_ID = C.SERVICE_ID
		AND D.BEGIN_DATE <= p_END_DATE
		AND D.END_DATE >= p_BEGIN_DATE
		AND D.UNIT_OF_MEASUREMENT = GA.DEFAULT_UNIT_OF_MEASUREMENT
		AND B.AGGREGATE_ID > 0;

CURSOR c_NON_VERSION IS
	SELECT A.EDC_ID, A.ESP_ID, B.ACCOUNT_ID,
		GREATEST(D.BEGIN_DATE, p_BEGIN_DATE) "BEGIN_DATE",
		LEAST(D.END_DATE, p_END_DATE) "END_DATE",
		(NVL(D.METERS_READ,0)) "METERS_READ"
	FROM PROVIDER_SERVICE A, ACCOUNT_SERVICE B, SERVICE C, SERVICE_CONSUMPTION D
	WHERE A.EDC_ID = p_EDC_ID
		AND (p_ESP_ID = CONSTANTS.ALL_ID OR A.ESP_ID = p_ESP_ID)
		AND A.PSE_ID = A.PSE_ID
		AND C.MODEL_ID = p_MODEL_ID
		AND C.SCENARIO_ID = p_SCENARIO_ID
		AND C.AS_OF_DATE = CONSTANTS.LOW_DATE
		AND C.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
		AND C.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
		AND D.SERVICE_ID = C.SERVICE_ID
		AND D.BEGIN_DATE <= p_END_DATE
		AND D.END_DATE >= p_BEGIN_DATE
		AND D.UNIT_OF_MEASUREMENT = GA.DEFAULT_UNIT_OF_MEASUREMENT
		AND B.AGGREGATE_ID > 0;

BEGIN

	IF GA.VERSION_CONSUMPTION THEN
		FOR v_CONSUMPTION IN c_VERSION LOOP
			v_SERVICE_DATE := v_CONSUMPTION.BEGIN_DATE;
			WHILE v_SERVICE_DATE <= v_CONSUMPTION.END_DATE LOOP
				ENCODE_TAG(CONSTANTS.NOT_ASSIGNED, v_CONSUMPTION.ESP_ID, v_CONSUMPTION.ACCOUNT_ID, v_SERVICE_DATE - p_BEGIN_DATE, v_TAG);
				v_INDEX := TAG_INDEX_LOOKUP(v_TAG, p_TAG_INDEX);
				IF p_METERS_READ.EXISTS(v_INDEX) THEN
					p_METERS_READ(v_INDEX) := p_METERS_READ(v_INDEX) + v_CONSUMPTION.METERS_READ;
				ELSE
					p_METERS_READ(v_INDEX) := v_CONSUMPTION.METERS_READ;
				END IF;
				v_SERVICE_DATE := v_SERVICE_DATE + 1;
			END LOOP;
		END LOOP;
	ELSE
		FOR v_CONSUMPTION IN c_NON_VERSION LOOP
			v_SERVICE_DATE := v_CONSUMPTION.BEGIN_DATE;
			WHILE v_SERVICE_DATE <= v_CONSUMPTION.END_DATE LOOP
				ENCODE_TAG(CONSTANTS.NOT_ASSIGNED, v_CONSUMPTION.ESP_ID, v_CONSUMPTION.ACCOUNT_ID, v_SERVICE_DATE - p_BEGIN_DATE, v_TAG);
				v_INDEX := TAG_INDEX_LOOKUP(v_TAG, p_TAG_INDEX);
				IF p_METERS_READ.EXISTS(v_INDEX) THEN
					p_METERS_READ(v_INDEX) := p_METERS_READ(v_INDEX) + v_CONSUMPTION.METERS_READ;
				ELSE
					p_METERS_READ(v_INDEX) := v_CONSUMPTION.METERS_READ;
				END IF;
				v_SERVICE_DATE := v_SERVICE_DATE + 1;
			END LOOP;
		END LOOP;
	END IF;

END ACCUMULATE_METERS_READ;
---------------------------------------------------------------------------------------------------
PROCEDURE ACCUMULATE_AGG_SVC_ACCOUNTS
	(
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TAG_INDEX IN OUT NOCOPY GA.NUMBER_TABLE,
	p_SERVICE_ACCOUNTS IN OUT NOCOPY GA.NUMBER_TABLE
	) AS

v_TAG NUMBER;
v_INDEX BINARY_INTEGER;

--AGGREGATE ONLY

CURSOR c_VERSION IS
	SELECT A.EDC_ID, A.ESP_ID, B.ACCOUNT_ID, D.SERVICE_DATE, SUM(NVL(D.SERVICE_ACCOUNTS,0)) "SERVICE_ACCOUNTS"
	FROM PROVIDER_SERVICE A, ACCOUNT_SERVICE B, SERVICE C, SERVICE_STATE D
	WHERE A.EDC_ID = p_EDC_ID
		AND (p_ESP_ID = CONSTANTS.ALL_ID OR A.ESP_ID = p_ESP_ID)
		AND A.PSE_ID = A.PSE_ID
		AND B.AGGREGATE_ID > 0
		AND C.MODEL_ID = p_MODEL_ID
		AND C.SCENARIO_ID = p_SCENARIO_ID
		AND C.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
		AND C.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
		AND C.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
		AND C.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM SERVICE
			WHERE MODEL_ID = C.MODEL_ID
				AND SCENARIO_ID = C.SCENARIO_ID
				AND ACCOUNT_SERVICE_ID = C.ACCOUNT_SERVICE_ID
				AND PROVIDER_SERVICE_ID = C.PROVIDER_SERVICE_ID
				AND SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
				AND AS_OF_DATE <= p_AS_OF_DATE)
		AND D.SERVICE_CODE = GA.FORECAST_SERVICE
		AND D.SERVICE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
		AND D.SERVICE_ID = C.SERVICE_ID
	GROUP BY A.EDC_ID, A.ESP_ID, B.ACCOUNT_ID, D.SERVICE_DATE;

CURSOR c_NON_VERSION IS
	SELECT A.EDC_ID, A.ESP_ID, B.ACCOUNT_ID, D.SERVICE_DATE, SUM(NVL(D.SERVICE_ACCOUNTS,0)) "SERVICE_ACCOUNTS"
	FROM PROVIDER_SERVICE A, ACCOUNT_SERVICE B, SERVICE C, SERVICE_STATE D
	WHERE A.EDC_ID = p_EDC_ID
		AND (p_ESP_ID = CONSTANTS.ALL_ID OR A.ESP_ID = p_ESP_ID)
		AND A.PSE_ID = A.PSE_ID
		AND B.AGGREGATE_ID > 0
		AND C.MODEL_ID = p_MODEL_ID
		AND C.SCENARIO_ID = p_SCENARIO_ID
		AND C.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
		AND C.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
		AND C.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
		AND C.AS_OF_DATE = LOW_DATE
		AND D.SERVICE_CODE = GA.FORECAST_SERVICE
		AND D.SERVICE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
		AND D.SERVICE_ID = C.SERVICE_ID
	GROUP BY A.EDC_ID, A.ESP_ID, B.ACCOUNT_ID, D.SERVICE_DATE;

BEGIN

	IF GA.VERSION_FORECAST THEN
		FOR v_SERVICE IN c_VERSION LOOP
			ENCODE_TAG(CONSTANTS.NOT_ASSIGNED, v_SERVICE.ESP_ID, v_SERVICE.ACCOUNT_ID,  v_SERVICE.SERVICE_DATE - p_BEGIN_DATE, v_TAG);
			v_INDEX := TAG_INDEX_LOOKUP(v_TAG, p_TAG_INDEX);
			IF p_SERVICE_ACCOUNTS.EXISTS(v_INDEX) THEN
				p_SERVICE_ACCOUNTS(v_INDEX) := p_SERVICE_ACCOUNTS(v_INDEX) + v_SERVICE.SERVICE_ACCOUNTS;
			ELSE
				p_SERVICE_ACCOUNTS(v_INDEX) := v_SERVICE.SERVICE_ACCOUNTS;
			END IF;
		END LOOP;
	ELSE
		FOR v_SERVICE IN c_NON_VERSION LOOP
			ENCODE_TAG(CONSTANTS.NOT_ASSIGNED, v_SERVICE.ESP_ID, v_SERVICE.ACCOUNT_ID, v_SERVICE.SERVICE_DATE - p_BEGIN_DATE, v_TAG);
			v_INDEX := TAG_INDEX_LOOKUP(v_TAG, p_TAG_INDEX);
			IF p_SERVICE_ACCOUNTS.EXISTS(v_INDEX) THEN
				p_SERVICE_ACCOUNTS(v_INDEX) := p_SERVICE_ACCOUNTS(v_INDEX) + v_SERVICE.SERVICE_ACCOUNTS;
			ELSE
				p_SERVICE_ACCOUNTS(v_INDEX) := v_SERVICE.SERVICE_ACCOUNTS;
			END IF;
		END LOOP;
	END IF;

END ACCUMULATE_AGG_SVC_ACCOUNTS;
---------------------------------------------------------------------------------------------------
PROCEDURE ACCUMULATE_ENROLLMENT
	(
	p_MODEL_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TAG_INDEX IN OUT NOCOPY GA.NUMBER_TABLE,
	p_ENROLLMENT IN OUT NOCOPY GA.NUMBER_TABLE
	) AS

v_TAG NUMBER;
v_INDEX BINARY_INTEGER;

CURSOR c_VERSION IS
	SELECT A.EDC_ID, A.ESP_ID, A.ACCOUNT_ID, A.SERVICE_DATE, SUM(NVL(A.SERVICE_ACCOUNTS,0)) "SERVICE_ACCOUNTS"
	FROM AGGREGATE_ACCOUNTS A
	WHERE A.EDC_ID = p_EDC_ID
		AND (p_ESP_ID = CONSTANTS.ALL_ID OR A.ESP_ID = p_ESP_ID)
		AND A.PSE_ID = A.PSE_ID
		AND A.AGGREGATE_ID = A.AGGREGATE_ID
		AND A.SERVICE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
		AND A.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM AGGREGATE_ACCOUNTS
			WHERE AGGREGATE_ID = A.AGGREGATE_ID
				AND SERVICE_DATE = A.SERVICE_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE)
	GROUP BY A.EDC_ID, A.ESP_ID, A.ACCOUNT_ID, A.SERVICE_DATE;

CURSOR c_NON_VERSION IS
	SELECT A.EDC_ID, A.ESP_ID, A.ACCOUNT_ID, A.SERVICE_DATE, SUM(NVL(A.SERVICE_ACCOUNTS,0)) "SERVICE_ACCOUNTS"
	FROM AGGREGATE_ACCOUNTS A
	WHERE A.EDC_ID = p_EDC_ID
		AND (p_ESP_ID = CONSTANTS.ALL_ID OR A.ESP_ID = p_ESP_ID)
		AND A.PSE_ID = A.PSE_ID
		AND A.AGGREGATE_ID = A.AGGREGATE_ID
		AND A.SERVICE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
		AND A.AS_OF_DATE = LOW_DATE
	GROUP BY A.EDC_ID, A.ESP_ID, A.ACCOUNT_ID, A.SERVICE_DATE;

BEGIN

	IF GA.VERSION_AGGREGATE_ACCOUNT_SVC THEN
		FOR v_ENROLLMENT IN c_VERSION LOOP
			ENCODE_TAG(CONSTANTS.NOT_ASSIGNED, v_ENROLLMENT.ESP_ID, v_ENROLLMENT.ACCOUNT_ID, v_ENROLLMENT.SERVICE_DATE - p_BEGIN_DATE, v_TAG);
			v_INDEX := TAG_INDEX_LOOKUP(v_TAG, p_TAG_INDEX);
			IF p_ENROLLMENT.EXISTS(v_INDEX) THEN
				p_ENROLLMENT(v_INDEX) := p_ENROLLMENT(v_INDEX) + v_ENROLLMENT.SERVICE_ACCOUNTS;
			ELSE
				p_ENROLLMENT(v_INDEX) := v_ENROLLMENT.SERVICE_ACCOUNTS;
			END IF;
		END LOOP;
	ELSE
		FOR v_ENROLLMENT IN c_NON_VERSION LOOP
			ENCODE_TAG(CONSTANTS.NOT_ASSIGNED, v_ENROLLMENT.ESP_ID, v_ENROLLMENT.ACCOUNT_ID, v_ENROLLMENT.SERVICE_DATE - p_BEGIN_DATE, v_TAG);
			v_INDEX := TAG_INDEX_LOOKUP(v_TAG, p_TAG_INDEX);
			IF p_ENROLLMENT.EXISTS(v_INDEX) THEN
				p_ENROLLMENT(v_INDEX) := p_ENROLLMENT(v_INDEX) + v_ENROLLMENT.SERVICE_ACCOUNTS;
			ELSE
				p_ENROLLMENT(v_INDEX) := v_ENROLLMENT.SERVICE_ACCOUNTS;
			END IF;
		END LOOP;
	END IF;

END ACCUMULATE_ENROLLMENT;
---------------------------------------------------------------------------------------------------
FUNCTION METERED_USAGE_THRESHOLD
	RETURN NUMBER IS

--If the number of accounts to be returned is greater than the sysdict threshold, then
--p_NEED_FIND will be 1.

v_THRESHOLD NUMBER;

BEGIN

	v_THRESHOLD := TO_NUMBER(NVL(MODEL_VALUE_AT_KEY(0,'System','Metered Usage','Find Threshold'),-1));

	RETURN v_THRESHOLD;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN 0;

END METERED_USAGE_THRESHOLD;
---------------------------------------------------------------------------------------------------
PROCEDURE AGGREGATE_BILLED_USAGE_FIND
	(
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_THRESHOLD IN NUMBER,
	p_COUNT_ONLY IN NUMBER,
	p_USE_ACCOUNT_LIST IN NUMBER,
	p_ACCOUNT_LIST IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the accounts in service for the specified
-- account, time interval and EDC/PSE/ESP relationship.

v_BEGIN_DATE DATE := TRUNC(p_BEGIN_DATE);
v_END_DATE DATE := TRUNC(p_END_DATE);
v_EDC_ID NUMBER(9);
v_ESP_ID NUMBER(9);
v_ACCOUNT_ID NUMBER(9);
v_DATE_ID NUMBER(9);
v_SERVICE_DATE DATE;
v_TAG NUMBER;
v_INDEX BINARY_INTEGER;
v_READS PLS_INTEGER;
v_COUNTS PLS_INTEGER;
v_DELTA PLS_INTEGER;
v_PERCENT NUMBER(16,2);
v_COUNT PLS_INTEGER := 0;
v_METERS_READ GA.NUMBER_TABLE;
v_SERVICE_ACCOUNTS GA.NUMBER_TABLE;
v_TAG_INDEX GA.NUMBER_TABLE;
v_METER_SERVICE METER_SERVICE_TABLE := METER_SERVICE_TABLE();
v_ID_TABLE  ID_TABLE;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;

	--Check if should use p_ACCOUNT_LIST, convert it to ID table
	IF p_USE_ACCOUNT_LIST <> 0 THEN
        UT.ID_TABLE_FROM_STRING(p_ACCOUNT_LIST, ',', v_ID_TABLE);
	END IF;

	IF GA.ENABLE_EXTERNAL_METER_ACCESS THEN
		XS.CACHE_CONSUMPTION(v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, p_STATUS);
	END IF;

	ACCUMULATE_METERS_READ(p_MODEL_ID, p_SCENARIO_ID, p_EDC_ID, p_ESP_ID, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, v_TAG_INDEX, v_METERS_READ);

	IF v_METERS_READ.COUNT > 0 THEN
		IF GA.AGGREGATE_BILLED_USAGE_OPTION = 'ENR' THEN
			ACCUMULATE_ENROLLMENT(p_MODEL_ID, p_EDC_ID, p_ESP_ID, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, v_TAG_INDEX, v_SERVICE_ACCOUNTS);
		ELSIF GA.AGGREGATE_BILLED_USAGE_OPTION = 'SVC' THEN
			ACCUMULATE_AGG_SVC_ACCOUNTS(p_MODEL_ID, p_SCENARIO_ID, p_EDC_ID, p_ESP_ID, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, v_TAG_INDEX, v_SERVICE_ACCOUNTS);
		END IF;

		v_METER_SERVICE.EXTEND(v_METERS_READ.COUNT);
		v_INDEX := v_METERS_READ.FIRST;
		WHILE v_INDEX <= v_METERS_READ.LAST LOOP
			v_TAG := v_TAG_INDEX(v_INDEX);
			DECODE_TAG(v_TAG, v_EDC_ID, v_ESP_ID, v_ACCOUNT_ID, v_DATE_ID);
			v_SERVICE_DATE := v_BEGIN_DATE + v_DATE_ID;
			v_READS := v_METERS_READ(v_INDEX);
			IF v_SERVICE_ACCOUNTS.EXISTS(v_INDEX) THEN
				v_COUNTS := v_SERVICE_ACCOUNTS(v_INDEX);
			ELSE
				v_COUNTS := 0;
			END IF;
			v_DELTA := v_COUNTS - v_READS;
			v_PERCENT := 0;
			IF v_COUNTS > 0 THEN
				v_PERCENT := v_DELTA / v_COUNTS * 100.;
			ELSE
				IF v_READS > 0 THEN
					v_PERCENT := 100;
				END IF;
			END IF;
			v_COUNT := v_COUNT + 1;
			v_METER_SERVICE(v_COUNT) := METER_SERVICE_TYPE(p_EDC_ID, v_ESP_ID, v_ACCOUNT_ID, v_SERVICE_DATE, v_READS, v_COUNTS, v_DELTA, v_PERCENT);
			v_INDEX := v_METERS_READ.NEXT(v_INDEX);
		END LOOP;
	END IF;

    IF p_USE_ACCOUNT_LIST = 0 THEN  --Full query, no account filter
        IF p_COUNT_ONLY = 1 THEN  -- Just the COUNT()
        	OPEN p_CURSOR FOR
        		SELECT
                    COUNT(D.ACCOUNT_ID)  -- Just the COUNT()
        		FROM TABLE(CAST(v_METER_SERVICE AS METER_SERVICE_TABLE)) A,
        		    ENERGY_DISTRIBUTION_COMPANY B,
        			ENERGY_SERVICE_PROVIDER C,
        			ACCOUNT D
        		WHERE ABS(A.PERCENT_DIFFERENCE) >= ABS(p_THRESHOLD)
        			AND B.EDC_ID = A.EDC_ID
        			AND C.ESP_ID = A.ESP_ID
        			AND D.ACCOUNT_ID = A.ACCOUNT_ID
        		ORDER BY A.SERVICE_DATE, B.EDC_NAME, C.ESP_NAME, D.ACCOUNT_NAME;
		ELSE  -- Normal, All fields
        	OPEN p_CURSOR FOR
        		SELECT A.SERVICE_DATE, B.EDC_NAME, B.EDC_ID, C.ESP_NAME, C.ESP_ID, D.ACCOUNT_NAME, D.ACCOUNT_ID,
        			A.SERVICE_ACCOUNTS, A.METERS_READ, A.DIFFERENCE, A.PERCENT_DIFFERENCE, D.ACCOUNT_EXTERNAL_IDENTIFIER
        		FROM TABLE(CAST(v_METER_SERVICE AS METER_SERVICE_TABLE)) A,
        		    ENERGY_DISTRIBUTION_COMPANY B,
        			ENERGY_SERVICE_PROVIDER C,
        			ACCOUNT D
        		WHERE ABS(A.PERCENT_DIFFERENCE) >= ABS(p_THRESHOLD)
        			AND B.EDC_ID = A.EDC_ID
        			AND C.ESP_ID = A.ESP_ID
        			AND D.ACCOUNT_ID = A.ACCOUNT_ID
        		ORDER BY A.SERVICE_DATE, B.EDC_NAME, C.ESP_NAME, D.ACCOUNT_NAME;
		END IF;
	ELSE  --Use v_ID_TABLE as join filter to limit accounts
        	OPEN p_CURSOR FOR
        		SELECT A.SERVICE_DATE, B.EDC_NAME, B.EDC_ID, C.ESP_NAME, C.ESP_ID, D.ACCOUNT_NAME, D.ACCOUNT_ID,
        			A.SERVICE_ACCOUNTS, A.METERS_READ, A.DIFFERENCE, A.PERCENT_DIFFERENCE, D.ACCOUNT_EXTERNAL_IDENTIFIER
        		FROM TABLE(CAST(v_METER_SERVICE AS METER_SERVICE_TABLE)) A,
        		    ENERGY_DISTRIBUTION_COMPANY B,
        			ENERGY_SERVICE_PROVIDER C,
        			ACCOUNT D,
					TABLE(v_ID_TABLE) E
        		WHERE ABS(A.PERCENT_DIFFERENCE) >= ABS(p_THRESHOLD)
        			AND B.EDC_ID = A.EDC_ID
        			AND C.ESP_ID = A.ESP_ID
        			AND D.ACCOUNT_ID = A.ACCOUNT_ID
                    AND D.ACCOUNT_ID = E.ID
        		ORDER BY A.SERVICE_DATE, B.EDC_NAME, C.ESP_NAME, D.ACCOUNT_NAME;
	END IF;

	IF GA.ENABLE_EXTERNAL_METER_ACCESS THEN
		XS.RELEASE_CONSUMPTION;
	END IF;

END AGGREGATE_BILLED_USAGE_FIND;
---------------------------------------------------------------------------------------------------
PROCEDURE NON_AGGR_BILLED_USAGE_FIND
	(
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_COUNT_ONLY IN NUMBER,
	p_USE_ACCOUNT_LIST IN NUMBER,
	p_ACCOUNT_LIST IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_ID_TABLE  ID_TABLE;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;

	--Check if should use p_ACCOUNT_LIST, convert it to ID table
	IF p_USE_ACCOUNT_LIST <> 0 THEN
        UT.ID_TABLE_FROM_STRING(p_ACCOUNT_LIST, ',', v_ID_TABLE);
	END IF;

	IF GA.ENABLE_EXTERNAL_METER_ACCESS THEN
		XS.CACHE_CONSUMPTION(TRUNC(p_BEGIN_DATE), TRUNC(p_END_DATE), p_AS_OF_DATE, p_STATUS);
	END IF;

	IF GA.VERSION_CONSUMPTION THEN
		IF p_USE_ACCOUNT_LIST = 0 THEN  --Full query, no account filter
			IF p_COUNT_ONLY = 1 THEN  -- Just the COUNT()
        		OPEN p_CURSOR FOR
        			SELECT
						COUNT(D.ACCOUNT_ID)  -- Just the COUNT()
        			FROM
        				(SELECT A.EDC_ID, A.ESP_ID, B.ACCOUNT_ID, D.BEGIN_DATE, D.END_DATE, D.PERIOD_ID, D.BILLED_USAGE
        				FROM PROVIDER_SERVICE A, ACCOUNT_SERVICE B, SERVICE C, SERVICE_CONSUMPTION D
        				WHERE A.EDC_ID = p_EDC_ID
        					AND (p_ESP_ID = CONSTANTS.ALL_ID OR A.ESP_ID = p_ESP_ID)
        					AND A.PSE_ID = A.PSE_ID
        					AND B.AGGREGATE_ID = 0
        					AND C.MODEL_ID = p_MODEL_ID
        					AND C.SCENARIO_ID = p_SCENARIO_ID
        					AND C.AS_OF_DATE =
        						(SELECT MAX(AS_OF_DATE)
        						FROM SERVICE
        						WHERE MODEL_ID = C.MODEL_ID
        							AND SCENARIO_ID = C.SCENARIO_ID
        							AND AS_OF_DATE <= p_AS_OF_DATE
        							AND PROVIDER_SERVICE_ID = C.PROVIDER_SERVICE_ID
        							AND ACCOUNT_SERVICE_ID = C.ACCOUNT_SERVICE_ID)
        					AND C.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
        					AND C.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
        					AND D.SERVICE_ID = C.SERVICE_ID
        					AND D.BEGIN_DATE <= TRUNC(p_END_DATE)
        					AND D.END_DATE >= TRUNC(p_BEGIN_DATE)
        					AND D.METER_TYPE = 'P'
							AND D.UNIT_OF_MEASUREMENT = GA.DEFAULT_UNIT_OF_MEASUREMENT) A,
        				ENERGY_DISTRIBUTION_COMPANY B,
        				ENERGY_SERVICE_PROVIDER C,
        				ACCOUNT D,
                        PERIOD E
        			WHERE B.EDC_ID = A.EDC_ID
        				AND C.ESP_ID = A.ESP_ID
        				AND D.ACCOUNT_ID = A.ACCOUNT_ID
                        AND E.PERIOD_ID = A.PERIOD_ID
        				ORDER BY B.EDC_NAME, C.ESP_NAME, D.ACCOUNT_NAME, E.PERIOD_NAME;
			ELSE  -- Normal, All fields
        		OPEN p_CURSOR FOR
        			SELECT B.EDC_NAME, B.EDC_ID, C.ESP_NAME, C.ESP_ID, D.ACCOUNT_NAME, D.ACCOUNT_ID, E.PERIOD_NAME, A.BEGIN_DATE, A.END_DATE, A.BILLED_USAGE, D.ACCOUNT_EXTERNAL_IDENTIFIER
        			FROM
        				(SELECT A.EDC_ID, A.ESP_ID, B.ACCOUNT_ID, D.BEGIN_DATE, D.END_DATE, D.PERIOD_ID, D.BILLED_USAGE
        				FROM PROVIDER_SERVICE A, ACCOUNT_SERVICE B, SERVICE C, SERVICE_CONSUMPTION D
        				WHERE A.EDC_ID = p_EDC_ID
        					AND (p_ESP_ID = CONSTANTS.ALL_ID OR A.ESP_ID = p_ESP_ID)
        					AND A.PSE_ID = A.PSE_ID
        					AND B.AGGREGATE_ID = 0
        					AND C.MODEL_ID = p_MODEL_ID
        					AND C.SCENARIO_ID = p_SCENARIO_ID
        					AND C.AS_OF_DATE =
        						(SELECT MAX(AS_OF_DATE)
        						FROM SERVICE
        						WHERE MODEL_ID = C.MODEL_ID
        							AND SCENARIO_ID = C.SCENARIO_ID
        							AND AS_OF_DATE <= p_AS_OF_DATE
        							AND PROVIDER_SERVICE_ID = C.PROVIDER_SERVICE_ID
        							AND ACCOUNT_SERVICE_ID = C.ACCOUNT_SERVICE_ID)
        					AND C.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
        					AND C.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
        					AND D.SERVICE_ID = C.SERVICE_ID
        					AND D.BEGIN_DATE <= TRUNC(p_END_DATE)
        					AND D.END_DATE >= TRUNC(p_BEGIN_DATE)
        					AND D.METER_TYPE = 'P'
							AND D.UNIT_OF_MEASUREMENT = GA.DEFAULT_UNIT_OF_MEASUREMENT) A,
        				ENERGY_DISTRIBUTION_COMPANY B,
        				ENERGY_SERVICE_PROVIDER C,
        				ACCOUNT D,
                        PERIOD E
        			WHERE B.EDC_ID = A.EDC_ID
        				AND C.ESP_ID = A.ESP_ID
        				AND D.ACCOUNT_ID = A.ACCOUNT_ID
                        AND E.PERIOD_ID = A.PERIOD_ID
        				ORDER BY B.EDC_NAME, C.ESP_NAME, D.ACCOUNT_NAME, E.PERIOD_NAME;
			END IF;
		ELSE  --Use v_ID_TABLE as join filter to limit accounts
    		OPEN p_CURSOR FOR
    			SELECT B.EDC_NAME, B.EDC_ID, C.ESP_NAME, C.ESP_ID, D.ACCOUNT_NAME, D.ACCOUNT_ID, E.PERIOD_NAME, A.BEGIN_DATE, A.END_DATE, A.BILLED_USAGE, D.ACCOUNT_EXTERNAL_IDENTIFIER
    			FROM
    				(SELECT A.EDC_ID, A.ESP_ID, B.ACCOUNT_ID, D.BEGIN_DATE, D.END_DATE, D.PERIOD_ID, D.BILLED_USAGE
    				FROM PROVIDER_SERVICE A, ACCOUNT_SERVICE B, SERVICE C, SERVICE_CONSUMPTION D
						, TABLE(v_ID_TABLE) E
    				WHERE A.EDC_ID = p_EDC_ID
						AND B.ACCOUNT_ID = E.ID
    					AND (p_ESP_ID = CONSTANTS.ALL_ID OR A.ESP_ID = p_ESP_ID)
    					AND A.PSE_ID = A.PSE_ID
    					AND B.AGGREGATE_ID = 0
    					AND C.MODEL_ID = p_MODEL_ID
    					AND C.SCENARIO_ID = p_SCENARIO_ID
    					AND C.AS_OF_DATE =
    						(SELECT MAX(AS_OF_DATE)
    						FROM SERVICE
    						WHERE MODEL_ID = C.MODEL_ID
    							AND SCENARIO_ID = C.SCENARIO_ID
    							AND AS_OF_DATE <= p_AS_OF_DATE
    							AND PROVIDER_SERVICE_ID = C.PROVIDER_SERVICE_ID
    							AND ACCOUNT_SERVICE_ID = C.ACCOUNT_SERVICE_ID)
    					AND C.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
    					AND C.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
    					AND D.SERVICE_ID = C.SERVICE_ID
    					AND D.BEGIN_DATE <= TRUNC(p_END_DATE)
    					AND D.END_DATE >= TRUNC(p_BEGIN_DATE)
    					AND D.METER_TYPE = 'P'
						AND D.UNIT_OF_MEASUREMENT = GA.DEFAULT_UNIT_OF_MEASUREMENT) A,
    				ENERGY_DISTRIBUTION_COMPANY B,
    				ENERGY_SERVICE_PROVIDER C,
    				ACCOUNT D,
                    PERIOD E
    			WHERE B.EDC_ID = A.EDC_ID
    				AND C.ESP_ID = A.ESP_ID
    				AND D.ACCOUNT_ID = A.ACCOUNT_ID
                    AND E.PERIOD_ID = A.PERIOD_ID
    				ORDER BY B.EDC_NAME, C.ESP_NAME, D.ACCOUNT_NAME, E.PERIOD_NAME;
		END IF;
	ELSE
		IF p_USE_ACCOUNT_LIST = 0 THEN  --Full query, no account filter
			IF p_COUNT_ONLY = 1 THEN  -- Just the COUNT()
        		OPEN p_CURSOR FOR
        			SELECT
						COUNT(D.ACCOUNT_ID)  -- Just the COUNT()
        			FROM
        				(SELECT A.EDC_ID, A.ESP_ID, B.ACCOUNT_ID, D.BEGIN_DATE, D.END_DATE, D.PERIOD_ID, D.BILLED_USAGE
        				FROM PROVIDER_SERVICE A, ACCOUNT_SERVICE B, SERVICE C, SERVICE_CONSUMPTION D
        				WHERE A.EDC_ID = p_EDC_ID
        					AND (p_ESP_ID = CONSTANTS.ALL_ID OR A.ESP_ID = p_ESP_ID)
        					AND A.PSE_ID = A.PSE_ID
        					AND B.AGGREGATE_ID = 0
        					AND C.MODEL_ID = p_MODEL_ID
        					AND C.SCENARIO_ID = p_SCENARIO_ID
        					AND C.AS_OF_DATE = CONSTANTS.LOW_DATE
        					AND C.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
        					AND C.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
        					AND D.SERVICE_ID = C.SERVICE_ID
        					AND D.BEGIN_DATE <= TRUNC(p_END_DATE)
        					AND D.END_DATE >= TRUNC(p_BEGIN_DATE)
        					AND D.METER_TYPE = 'P'
							AND D.UNIT_OF_MEASUREMENT = GA.DEFAULT_UNIT_OF_MEASUREMENT) A,
        				ENERGY_DISTRIBUTION_COMPANY B,
        				ENERGY_SERVICE_PROVIDER C,
        				ACCOUNT D,
                        PERIOD E
        			WHERE B.EDC_ID = A.EDC_ID
        				AND C.ESP_ID = A.ESP_ID
        				AND D.ACCOUNT_ID = A.ACCOUNT_ID
                        AND E.PERIOD_ID = A.PERIOD_ID
        				ORDER BY B.EDC_NAME, C.ESP_NAME, D.ACCOUNT_NAME, E.PERIOD_NAME;
			ELSE  -- Normal, All fields
        		OPEN p_CURSOR FOR
        			SELECT B.EDC_NAME, B.EDC_ID, C.ESP_NAME, C.ESP_ID, D.ACCOUNT_NAME, D.ACCOUNT_ID, E.PERIOD_NAME, A.BEGIN_DATE, A.END_DATE, A.BILLED_USAGE, D.ACCOUNT_EXTERNAL_IDENTIFIER
        			FROM
        				(SELECT A.EDC_ID, A.ESP_ID, B.ACCOUNT_ID, D.BEGIN_DATE, D.END_DATE, D.PERIOD_ID, D.BILLED_USAGE
        				FROM PROVIDER_SERVICE A, ACCOUNT_SERVICE B, SERVICE C, SERVICE_CONSUMPTION D
        				WHERE A.EDC_ID = p_EDC_ID
        					AND (p_ESP_ID = CONSTANTS.ALL_ID OR A.ESP_ID = p_ESP_ID)
        					AND A.PSE_ID = A.PSE_ID
        					AND B.AGGREGATE_ID = 0
        					AND C.MODEL_ID = p_MODEL_ID
        					AND C.SCENARIO_ID = p_SCENARIO_ID
        					AND C.AS_OF_DATE = CONSTANTS.LOW_DATE
        					AND C.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
        					AND C.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
        					AND D.SERVICE_ID = C.SERVICE_ID
        					AND D.BEGIN_DATE <= TRUNC(p_END_DATE)
        					AND D.END_DATE >= TRUNC(p_BEGIN_DATE)
        					AND D.METER_TYPE = 'P'
							AND D.UNIT_OF_MEASUREMENT = GA.DEFAULT_UNIT_OF_MEASUREMENT) A,
        				ENERGY_DISTRIBUTION_COMPANY B,
        				ENERGY_SERVICE_PROVIDER C,
        				ACCOUNT D,
                        PERIOD E
        			WHERE B.EDC_ID = A.EDC_ID
        				AND C.ESP_ID = A.ESP_ID
        				AND D.ACCOUNT_ID = A.ACCOUNT_ID
                        AND E.PERIOD_ID = A.PERIOD_ID
        				ORDER BY B.EDC_NAME, C.ESP_NAME, D.ACCOUNT_NAME, E.PERIOD_NAME;
			END IF;
		ELSE  --Use v_ID_TABLE as join filter to limit accounts
    		OPEN p_CURSOR FOR
    			SELECT B.EDC_NAME, B.EDC_ID, C.ESP_NAME, C.ESP_ID, D.ACCOUNT_NAME, D.ACCOUNT_ID, E.PERIOD_NAME, A.BEGIN_DATE, A.END_DATE, A.BILLED_USAGE, D.ACCOUNT_EXTERNAL_IDENTIFIER
    			FROM
    				(SELECT A.EDC_ID, A.ESP_ID, B.ACCOUNT_ID, D.BEGIN_DATE, D.END_DATE, D.PERIOD_ID, D.BILLED_USAGE
    				FROM PROVIDER_SERVICE A, ACCOUNT_SERVICE B, SERVICE C, SERVICE_CONSUMPTION D
						, TABLE(v_ID_TABLE) E
    				WHERE A.EDC_ID = p_EDC_ID
						AND B.ACCOUNT_ID = E.ID
    					AND (p_ESP_ID = CONSTANTS.ALL_ID OR A.ESP_ID = p_ESP_ID)
    					AND A.PSE_ID = A.PSE_ID
    					AND B.AGGREGATE_ID = 0
    					AND C.MODEL_ID = p_MODEL_ID
    					AND C.SCENARIO_ID = p_SCENARIO_ID
    					AND C.AS_OF_DATE = CONSTANTS.LOW_DATE
    					AND C.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
    					AND C.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
    					AND D.SERVICE_ID = C.SERVICE_ID
    					AND D.BEGIN_DATE <= TRUNC(p_END_DATE)
    					AND D.END_DATE >= TRUNC(p_BEGIN_DATE)
    					AND D.METER_TYPE = 'P'
						AND D.UNIT_OF_MEASUREMENT = GA.DEFAULT_UNIT_OF_MEASUREMENT) A,
    				ENERGY_DISTRIBUTION_COMPANY B,
    				ENERGY_SERVICE_PROVIDER C,
    				ACCOUNT D,
                    PERIOD E
    			WHERE B.EDC_ID = A.EDC_ID
    				AND C.ESP_ID = A.ESP_ID
    				AND D.ACCOUNT_ID = A.ACCOUNT_ID
                    AND E.PERIOD_ID = A.PERIOD_ID
    				ORDER BY B.EDC_NAME, C.ESP_NAME, D.ACCOUNT_NAME, E.PERIOD_NAME;
		END IF;
	END IF;
	IF GA.ENABLE_EXTERNAL_METER_ACCESS THEN
	    XS.RELEASE_CONSUMPTION;
	END IF;

END NON_AGGR_BILLED_USAGE_FIND;
---------------------------------------------------------------------------------------------------
PROCEDURE NON_AGGR_CONSUMPTION_NULL_FIND
	(
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_COUNT_ONLY IN NUMBER,
	p_USE_ACCOUNT_LIST IN NUMBER,
	p_ACCOUNT_LIST IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_ID_TABLE  ID_TABLE;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;

	IF GA.ENABLE_EXTERNAL_METER_ACCESS THEN
		XS.CACHE_CONSUMPTION(p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_STATUS);
	END IF;

    IF p_USE_ACCOUNT_LIST = 0 THEN  --Full query, no account filter
        IF p_COUNT_ONLY = 1 THEN  -- Just the COUNT()
        	OPEN p_CURSOR FOR
        		SELECT
        			COUNT(F.ACCOUNT_ID)  -- Just the COUNT()
        		FROM
        			(SELECT DISTINCT ACCOUNT_SERVICE_ID, PROVIDER_SERVICE_ID, SERVICE_DATE
        			FROM SERVICE A, SERVICE_STATE B
        			WHERE A.MODEL_ID = p_MODEL_ID
        				AND A.SCENARIO_ID = p_SCENARIO_ID
        				AND A.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
        				AND A.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
        				AND A.SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
        				AND A.AS_OF_DATE =
        						(SELECT MAX(AS_OF_DATE)
        						FROM SERVICE
        						WHERE MODEL_ID = A.MODEL_ID
        							AND SCENARIO_ID = A.SCENARIO_ID
        							AND ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
        							AND PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
        							AND SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
        							AND AS_OF_DATE <= p_AS_OF_DATE)
        				AND B.SERVICE_CODE = GA.BACKCAST_SERVICE
        				AND B.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
        				AND B.METER_TYPE = 'P'
        				AND B.SERVICE_ID = A.SERVICE_ID
        				AND NOT EXISTS
        					(SELECT 1
        					FROM SERVICE Z, SERVICE_CONSUMPTION X
        					WHERE Z.MODEL_ID = A.MODEL_ID
        						AND Z.SCENARIO_ID = A.SCENARIO_ID
        						AND Z.AS_OF_DATE = CONSTANTS.LOW_DATE
        						AND Z.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
        						AND Z.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
        						AND X.SERVICE_ID = Z.SERVICE_ID
        						AND X.BEGIN_DATE >= B.SERVICE_DATE
        						AND X.END_DATE <= B.SERVICE_DATE
								AND X.UNIT_OF_MEASUREMENT = GA.DEFAULT_UNIT_OF_MEASUREMENT)) A,
        			PROVIDER_SERVICE B,
        			ACCOUNT_SERVICE C,
        			ENERGY_DISTRIBUTION_COMPANY D,
        			ENERGY_SERVICE_PROVIDER E,
        			ACCOUNT F
        		WHERE B.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
        			AND C.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
        			AND D.EDC_ID = B.EDC_ID
        			AND E.ESP_ID = B.ESP_ID
        			AND F.ACCOUNT_ID = C.ACCOUNT_ID
        		GROUP BY D.EDC_NAME, D.EDC_ID, E.ESP_NAME, E.ESP_ID, F.ACCOUNT_NAME, F.ACCOUNT_ID, F.ACCOUNT_EXTERNAL_IDENTIFIER
        		ORDER BY D.EDC_NAME, E.ESP_NAME, F.ACCOUNT_NAME;
        ELSE  -- Normal, All fields
        	OPEN p_CURSOR FOR
        		SELECT D.EDC_NAME, D.EDC_ID, E.ESP_NAME, E.ESP_ID, F.ACCOUNT_NAME, F.ACCOUNT_ID, F.ACCOUNT_EXTERNAL_IDENTIFIER,
        			MIN(A.SERVICE_DATE) "BEGIN_DATE", MAX(A.SERVICE_DATE) "END_DATE", NULL "PERIOD_NAME", 0 "BILLED_USAGE"
        		FROM
        			(SELECT DISTINCT ACCOUNT_SERVICE_ID, PROVIDER_SERVICE_ID, SERVICE_DATE
        			FROM SERVICE A, SERVICE_STATE B
        			WHERE A.MODEL_ID = p_MODEL_ID
        				AND A.SCENARIO_ID = p_SCENARIO_ID
        				AND A.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
        				AND A.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
        				AND A.SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
        				AND A.AS_OF_DATE =
        						(SELECT MAX(AS_OF_DATE)
        						FROM SERVICE
        						WHERE MODEL_ID = A.MODEL_ID
        							AND SCENARIO_ID = A.SCENARIO_ID
        							AND ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
        							AND PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
        							AND SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
        							AND AS_OF_DATE <= p_AS_OF_DATE)
        				AND B.SERVICE_CODE = GA.BACKCAST_SERVICE
        				AND B.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
        				AND B.METER_TYPE = 'P'
        				AND B.SERVICE_ID = A.SERVICE_ID
        				AND NOT EXISTS
        					(SELECT 1
        					FROM SERVICE Z, SERVICE_CONSUMPTION X
        					WHERE Z.MODEL_ID = A.MODEL_ID
        						AND Z.SCENARIO_ID = A.SCENARIO_ID
        						AND Z.AS_OF_DATE = CONSTANTS.LOW_DATE
        						AND Z.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
        						AND Z.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
        						AND X.SERVICE_ID = Z.SERVICE_ID
        						AND X.BEGIN_DATE >= B.SERVICE_DATE
        						AND X.END_DATE <= B.SERVICE_DATE
								AND X.UNIT_OF_MEASUREMENT = GA.DEFAULT_UNIT_OF_MEASUREMENT)) A,
        			PROVIDER_SERVICE B,
        			ACCOUNT_SERVICE C,
        			ENERGY_DISTRIBUTION_COMPANY D,
        			ENERGY_SERVICE_PROVIDER E,
        			ACCOUNT F
        		WHERE B.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
        			AND C.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
        			AND D.EDC_ID = B.EDC_ID
        			AND E.ESP_ID = B.ESP_ID
        			AND F.ACCOUNT_ID = C.ACCOUNT_ID
        		GROUP BY D.EDC_NAME, D.EDC_ID, E.ESP_NAME, E.ESP_ID, F.ACCOUNT_NAME, F.ACCOUNT_ID, F.ACCOUNT_EXTERNAL_IDENTIFIER
        		ORDER BY D.EDC_NAME, E.ESP_NAME, F.ACCOUNT_NAME;
		END IF;
    ELSE  --Use v_ID_TABLE as join filter to limit accounts
        	OPEN p_CURSOR FOR
        		SELECT D.EDC_NAME, D.EDC_ID, E.ESP_NAME, E.ESP_ID, F.ACCOUNT_NAME, F.ACCOUNT_ID, F.ACCOUNT_EXTERNAL_IDENTIFIER,
        			MIN(A.SERVICE_DATE) "BEGIN_DATE", MAX(A.SERVICE_DATE) "END_DATE", NULL "PERIOD_NAME", 0 "BILLED_USAGE"
        		FROM
        			(SELECT DISTINCT ACCOUNT_SERVICE_ID, PROVIDER_SERVICE_ID, SERVICE_DATE
        			FROM SERVICE A, SERVICE_STATE B
        			WHERE A.MODEL_ID = p_MODEL_ID
        				AND A.SCENARIO_ID = p_SCENARIO_ID
        				AND A.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
        				AND A.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
        				AND A.SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
        				AND A.AS_OF_DATE =
        						(SELECT MAX(AS_OF_DATE)
        						FROM SERVICE
        						WHERE MODEL_ID = A.MODEL_ID
        							AND SCENARIO_ID = A.SCENARIO_ID
        							AND ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
        							AND PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
        							AND SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
        							AND AS_OF_DATE <= p_AS_OF_DATE)
        				AND B.SERVICE_CODE = GA.BACKCAST_SERVICE
        				AND B.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
        				AND B.METER_TYPE = 'P'
        				AND B.SERVICE_ID = A.SERVICE_ID
        				AND NOT EXISTS
        					(SELECT 1
        					FROM SERVICE Z, SERVICE_CONSUMPTION X
        					WHERE Z.MODEL_ID = A.MODEL_ID
        						AND Z.SCENARIO_ID = A.SCENARIO_ID
        						AND Z.AS_OF_DATE = CONSTANTS.LOW_DATE
        						AND Z.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
        						AND Z.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
        						AND X.SERVICE_ID = Z.SERVICE_ID
        						AND X.BEGIN_DATE >= B.SERVICE_DATE
        						AND X.END_DATE <= B.SERVICE_DATE
								AND X.UNIT_OF_MEASUREMENT = GA.DEFAULT_UNIT_OF_MEASUREMENT)) A,
        			PROVIDER_SERVICE B,
        			ACCOUNT_SERVICE C,
        			ENERGY_DISTRIBUTION_COMPANY D,
        			ENERGY_SERVICE_PROVIDER E,
        			ACCOUNT F,
					TABLE(v_ID_TABLE) G
        		WHERE B.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
        			AND C.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
        			AND D.EDC_ID = B.EDC_ID
        			AND E.ESP_ID = B.ESP_ID
        			AND F.ACCOUNT_ID = C.ACCOUNT_ID
                    AND f.ACCOUNT_ID = G.ID
        		GROUP BY D.EDC_NAME, D.EDC_ID, E.ESP_NAME, E.ESP_ID, F.ACCOUNT_NAME, F.ACCOUNT_ID, F.ACCOUNT_EXTERNAL_IDENTIFIER
        		ORDER BY D.EDC_NAME, E.ESP_NAME, F.ACCOUNT_NAME;
	END IF;

	IF GA.ENABLE_EXTERNAL_METER_ACCESS THEN
		XS.RELEASE_CONSUMPTION;
	END IF;

END NON_AGGR_CONSUMPTION_NULL_FIND;
---------------------------------------------------------------------------------------------------
PROCEDURE AGGREGATE_METERED_USAGE
	(
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_THRESHOLD IN NUMBER,
	p_USE_ACCOUNT_LIST IN NUMBER,
	p_ACCOUNT_LIST IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_THRESHOLD NUMBER;
v_GET_USAGE BOOLEAN;
v_CURSOR GA.REFCURSOR;
v_NUM_ACCOUNTS NUMBER;
v_USE_ACCOUNT_LIST NUMBER;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;

	v_USE_ACCOUNT_LIST := p_USE_ACCOUNT_LIST;

	IF v_USE_ACCOUNT_LIST = 1 THEN
		--Already have List of Accts to use, don't bother with count
		v_GET_USAGE := TRUE;
		IF p_ACCOUNT_LIST IS NULL THEN
			v_USE_ACCOUNT_LIST := 0;  --Dont use empty list - just use full query
		END IF;
	ELSE
    	--Check if need Find Dlg
		v_THRESHOLD := METERED_USAGE_THRESHOLD;

    	IF v_THRESHOLD <= 0 THEN
    		--Never use Find
    		v_GET_USAGE := TRUE;
    	ELSIF v_THRESHOLD = 1 THEN
    		--Always use Find
    		v_GET_USAGE := FALSE;
    		OPEN p_CURSOR FOR
    			  SELECT g_NEED_FIND FROM DUAL;
    	ELSE --Get Count
			v_GET_USAGE := TRUE;	--Default to just getting it all if can't get count

            --Check if the number of accounts to be returned is greater than the sysdict threshold.
			AGGREGATE_BILLED_USAGE_FIND
            	(
            	p_REQUEST_TYPE,
            	p_MODEL_ID,
            	p_SCENARIO_ID,
            	p_EDC_ID,
            	p_ESP_ID,
            	p_BEGIN_DATE,
            	p_END_DATE,
            	p_AS_OF_DATE,
				p_THRESHOLD,
            	1, --p_COUNT_ONLY,
            	0, --p_USE_ACCOUNT_LIST,
            	p_ACCOUNT_LIST,
            	p_STATUS,
            	v_CURSOR
            	);

        	IF p_STATUS = GA.SUCCESS THEN

    			FETCH v_CURSOR INTO v_NUM_ACCOUNTS;
        		CLOSE v_CURSOR;

        		IF v_NUM_ACCOUNTS >= v_THRESHOLD THEN
            		--Need Find
            		v_GET_USAGE := FALSE;
            		OPEN p_CURSOR FOR
            			  SELECT g_NEED_FIND FROM DUAL;  --Return a flag in cursor
    			END IF;
    		END IF;
    	END IF;
	END IF;

    IF v_GET_USAGE THEN
        --Get the usage p_cursor
        AGGREGATE_BILLED_USAGE_FIND
        	(
        	p_REQUEST_TYPE,
        	p_MODEL_ID,
        	p_SCENARIO_ID,
        	p_EDC_ID,
        	p_ESP_ID,
        	p_BEGIN_DATE,
        	p_END_DATE,
        	p_AS_OF_DATE,
			p_THRESHOLD,
        	0, --p_COUNT_ONLY,
        	v_USE_ACCOUNT_LIST,
        	p_ACCOUNT_LIST,
        	p_STATUS,
        	p_CURSOR
        	);
    END IF;



END AGGREGATE_METERED_USAGE;
---------------------------------------------------------------------------------------------------
PROCEDURE NON_AGGREGATE_METERED_USAGE
	(
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_USE_ACCOUNT_LIST IN NUMBER,
	p_ACCOUNT_LIST IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_THRESHOLD NUMBER;
v_GET_USAGE BOOLEAN;
v_CURSOR GA.REFCURSOR;
v_NUM_ACCOUNTS NUMBER;
v_USE_ACCOUNT_LIST NUMBER;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;

	v_USE_ACCOUNT_LIST := p_USE_ACCOUNT_LIST;

	IF v_USE_ACCOUNT_LIST = 1 THEN
		--Already have List of Accts to use, don't bother with count
		v_GET_USAGE := TRUE;
		IF p_ACCOUNT_LIST IS NULL THEN
			v_USE_ACCOUNT_LIST := 0;  --Dont use empty list - just use full query
		END IF;
	ELSE
    	--Check if need Find Dlg
		v_THRESHOLD := METERED_USAGE_THRESHOLD;

    	IF v_THRESHOLD <= 0 THEN
    		--Never use Find
    		v_GET_USAGE := TRUE;
    	ELSIF v_THRESHOLD = 1 THEN
    		--Always use Find
    		v_GET_USAGE := FALSE;
    		OPEN p_CURSOR FOR
    			  SELECT g_NEED_FIND FROM DUAL;
    	ELSE --Get Count
			v_GET_USAGE := TRUE;	--Default to just getting it all if can't get count

            --Check if the number of accounts to be returned is greater than the sysdict threshold.
			NON_AGGR_BILLED_USAGE_FIND
            	(
            	p_REQUEST_TYPE,
            	p_MODEL_ID,
            	p_SCENARIO_ID,
            	p_EDC_ID,
            	p_ESP_ID,
            	p_BEGIN_DATE,
            	p_END_DATE,
            	p_AS_OF_DATE,
            	1, --p_COUNT_ONLY,
            	0, --p_USE_ACCOUNT_LIST,
            	p_ACCOUNT_LIST,
            	p_STATUS,
            	v_CURSOR
            	);

        	IF p_STATUS = GA.SUCCESS THEN

    			FETCH v_CURSOR INTO v_NUM_ACCOUNTS;
        		CLOSE v_CURSOR;

        		IF v_NUM_ACCOUNTS >= v_THRESHOLD THEN
            		--Need Find
            		v_GET_USAGE := FALSE;
            		OPEN p_CURSOR FOR
            			  SELECT g_NEED_FIND FROM DUAL;  --Return a flag in cursor
    			END IF;
    		END IF;
    	END IF;
	END IF;

    IF v_GET_USAGE THEN
        --Get the usage p_cursor
        NON_AGGR_BILLED_USAGE_FIND
        	(
        	p_REQUEST_TYPE,
        	p_MODEL_ID,
        	p_SCENARIO_ID,
        	p_EDC_ID,
        	p_ESP_ID,
        	p_BEGIN_DATE,
        	p_END_DATE,
        	p_AS_OF_DATE,
        	0, --p_COUNT_ONLY,
        	v_USE_ACCOUNT_LIST,
        	p_ACCOUNT_LIST,
        	p_STATUS,
        	p_CURSOR
        	);
    END IF;



END NON_AGGREGATE_METERED_USAGE;
---------------------------------------------------------------------------------------------------
PROCEDURE NON_AGGREGATE_METERED_NULL
	(
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_USE_ACCOUNT_LIST IN NUMBER,
	p_ACCOUNT_LIST IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_THRESHOLD NUMBER;
v_GET_USAGE BOOLEAN;
v_CURSOR GA.REFCURSOR;
v_NUM_ACCOUNTS NUMBER;
v_USE_ACCOUNT_LIST NUMBER;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;

	v_USE_ACCOUNT_LIST := p_USE_ACCOUNT_LIST;

	IF v_USE_ACCOUNT_LIST = 1 THEN
		--Already have List of Accts to use, don't bother with count
		v_GET_USAGE := TRUE;
		IF p_ACCOUNT_LIST IS NULL THEN
			v_USE_ACCOUNT_LIST := 0;  --Dont use empty list - just use full query
		END IF;
	ELSE
    	--Check if need Find Dlg
		v_THRESHOLD := METERED_USAGE_THRESHOLD;

    	IF v_THRESHOLD <= 0 THEN
    		--Never use Find
    		v_GET_USAGE := TRUE;
    	ELSIF v_THRESHOLD = 1 THEN
    		--Always use Find
    		v_GET_USAGE := FALSE;
    		OPEN p_CURSOR FOR
    			  SELECT g_NEED_FIND FROM DUAL;
    	ELSE --Get Count
			v_GET_USAGE := TRUE;	--Default to just getting it all if can't get count

            --Check if the number of accounts to be returned is greater than the sysdict threshold.
			NON_AGGR_CONSUMPTION_NULL_FIND
            	(
            	p_REQUEST_TYPE,
            	p_MODEL_ID,
            	p_SCENARIO_ID,
            	p_EDC_ID,
            	p_ESP_ID,
            	p_BEGIN_DATE,
            	p_END_DATE,
            	p_AS_OF_DATE,
            	1, --p_COUNT_ONLY,
            	0, --p_USE_ACCOUNT_LIST,
            	p_ACCOUNT_LIST,
            	p_STATUS,
            	v_CURSOR
            	);

        	IF p_STATUS = GA.SUCCESS THEN

    			FETCH v_CURSOR INTO v_NUM_ACCOUNTS;
        		CLOSE v_CURSOR;

        		IF v_NUM_ACCOUNTS >= v_THRESHOLD THEN
            		--Need Find
            		v_GET_USAGE := FALSE;
            		OPEN p_CURSOR FOR
            			  SELECT g_NEED_FIND FROM DUAL;  --Return a flag in cursor
    			END IF;
    		END IF;
    	END IF;
	END IF;

    IF v_GET_USAGE THEN
        --Get the usage p_cursor
        NON_AGGR_CONSUMPTION_NULL_FIND
        	(
        	p_REQUEST_TYPE,
        	p_MODEL_ID,
        	p_SCENARIO_ID,
        	p_EDC_ID,
        	p_ESP_ID,
        	p_BEGIN_DATE,
        	p_END_DATE,
        	p_AS_OF_DATE,
        	0, --p_COUNT_ONLY,
        	v_USE_ACCOUNT_LIST,
        	p_ACCOUNT_LIST,
        	p_STATUS,
        	p_CURSOR
        	);
    END IF;



END NON_AGGREGATE_METERED_NULL;
---------------------------------------------------------------------------------------------------
PROCEDURE PRE_SCHEDULE
	(
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_FILTER_HOURS IN NUMBER,
	p_STATUS IN OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the  pre-schedule results for an PSE

v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_BEGIN_DATE, v_END_DATE);

 	    OPEN p_CURSOR FOR
            SELECT PSE_ID, FROM_CUT_AS_HED(SCHEDULE_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID) AS LOAD_DATE, SUM(AMOUNT) AS LOAD_VAL
			FROM PSE_PRE_SCHEDULE
			WHERE (p_PSE_ID = CONSTANTS.ALL_ID OR PSE_ID = p_PSE_ID)
				AND SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND 1 = IS_DAY_INTERVAL_OF_TYPE(p_FILTER_HOURS,FROM_CUT(SCHEDULE_DATE,p_TIME_ZONE))
    		GROUP BY PSE_ID, FROM_CUT_AS_HED(SCHEDULE_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID)
			ORDER BY 1,2;

END PRE_SCHEDULE;
---------------------------------------------------------------------------------------------------
PROCEDURE NET_SCHEDULE
	(
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_FILTER_HOURS IN NUMBER,
	p_STATUS IN OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the  pre-schedule results for an PSE

v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_BEGIN_DATE, v_END_DATE);

    OPEN p_CURSOR FOR
		SELECT A.PSE_ID AS PSE_ID, FROM_CUT_AS_HED(E.SCHEDULE_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID) AS LOAD_DATE, SUM(E.AMOUNT) AS LOAD_VAL
		FROM PURCHASING_SELLING_ENTITY A,
			INTERCHANGE_TRANSACTION B,
			IT_COMMODITY C,
			SERVICE_POINT D,
			IT_SCHEDULE E
		WHERE (p_PSE_ID = CONSTANTS.ALL_ID OR A.PSE_ID = p_PSE_ID)
			AND A.PSE_IS_RETAIL_AGGREGATOR = 1
			AND B.PURCHASER_ID = A.PSE_ID
			AND C.COMMODITY_ID = B.COMMODITY_ID
			AND UPPER(SUBSTR(C.COMMODITY_TYPE,1,1))  = 'E' -- Energy commodity type.
			AND D.SERVICE_POINT_ID = B.POD_ID
			AND UPPER(SUBSTR(D.SERVICE_POINT_TYPE,1,1)) = 'R' -- Retail Service Point.
			AND E.TRANSACTION_ID = B.TRANSACTION_ID
			AND E.SCHEDULE_TYPE = 0
			AND E.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND 1 = IS_DAY_INTERVAL_OF_TYPE(p_FILTER_HOURS,FROM_CUT(E.SCHEDULE_DATE,p_TIME_ZONE))
			AND E.AS_OF_DATE = SCHEDULE_AS_OF_DATE(E.TRANSACTION_ID, E.SCHEDULE_TYPE, E.SCHEDULE_STATE, E.SCHEDULE_DATE, p_AS_OF_DATE)
   		GROUP BY A.PSE_ID, FROM_CUT_AS_HED(E.SCHEDULE_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID)
		ORDER BY 1,2;

END NET_SCHEDULE;
---------------------------------------------------------------------------------------------------
PROCEDURE MARKET_PRICE_NAMES
	(
	p_REQUEST_TYPE IN CHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of market prices defined in the database.

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT MARKET_PRICE_NAME, MARKET_PRICE_ID, MARKET_PRICE_TYPE, SERVICE_POINT_TYPE
		FROM MARKET_PRICE
		ORDER BY MARKET_PRICE_NAME;

END MARKET_PRICE_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_PROCESS_STATUS
	(
	p_REQUEST_TYPE IN CHAR,
	p_PROCESS_NAME IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the process status states for the specified process name and date range.

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT PROCESS_DATE, PROCESS_STATE, PROCESS_SYSDATE, PROCESS_AS_OF_DATE
		FROM PROCESS_STATUS
		WHERE PROCESS_NAME = p_PROCESS_NAME
			  AND PROCESS_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
		ORDER BY PROCESS_DATE;

END GET_PROCESS_STATUS;
---------------------------------------------------------------------------------------------------
PROCEDURE ESP_SUPPLY_TYPE_SUMMARY
	(
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_SUPPLY_TYPE IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_INCLUDE_UFE IN NUMBER,
	p_FILTER_HOURS IN NUMBER,
	p_STATUS IN OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the ESP summary by Supply Type: Certified, Standard Offer, Defaulted Supply.
-- Request Type is "F", "B", or "U" for Forecast, Backcast, and Usage respectively.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_AS_OF_DATE DATE;
v_REQUEST_TYPE CHAR(1) := UPPER(SUBSTR(p_REQUEST_TYPE,1,1));

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_BEGIN_DATE, v_END_DATE);

	v_AS_OF_DATE := AS_OF_DATE_FOR_REQUEST(p_REQUEST_TYPE, p_AS_OF_DATE);

	IF IS_VERSIONED_REQUEST(v_REQUEST_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) THEN
		OPEN p_CURSOR FOR
			SELECT FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID) "LOAD_DATE",
				SUM(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "LOAD_VAL",
				MIN(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "MIN_LOAD_VAL",
				MAX(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "MAX_LOAD_VAL",
				AVG(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "AVG_LOAD_VAL"
			FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, SERVICE_OBLIGATION_LOAD D
			WHERE (p_EDC_ID = CONSTANTS.ALL_ID OR B.EDC_ID = p_EDC_ID)
				AND A.MODEL_ID = p_MODEL_ID
				AND A.SCENARIO_ID = p_SCENARIO_ID
				AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
				AND A.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
				AND A.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM SERVICE_OBLIGATION
					WHERE MODEL_ID = A.MODEL_ID
						AND SCENARIO_ID = A.SCENARIO_ID
						AND PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
						AND SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
						AND AS_OF_DATE <= v_AS_OF_DATE)
				AND D.SERVICE_CODE = v_REQUEST_TYPE
				AND D.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND D.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
				AND D.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
				AND IS_DAY_INTERVAL_OF_TYPE(p_FILTER_HOURS, FROM_CUT(D.LOAD_DATE,p_TIME_ZONE)) = 1
				AND C.SUPPLY_TYPE = UPPER(SUBSTR(p_SUPPLY_TYPE,1,1))
				AND C.IS_BUG = 0
				AND C.IS_WHOLESALE = 0
			GROUP BY FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID)
			ORDER BY 1;
	ELSE
		OPEN p_CURSOR FOR
			SELECT FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID) "LOAD_DATE",
				SUM(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "LOAD_VAL",
				MIN(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "MIN_LOAD_VAL",
				MAX(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "MAX_LOAD_VAL",
				AVG(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "AVG_LOAD_VAL"
			FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, SERVICE_OBLIGATION_LOAD D
			WHERE (p_EDC_ID = CONSTANTS.ALL_ID OR B.EDC_ID = p_EDC_ID)
				AND A.MODEL_ID = p_MODEL_ID
				AND A.SCENARIO_ID = p_SCENARIO_ID
				AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
				AND A.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
				AND A.AS_OF_DATE = v_AS_OF_DATE
				AND D.SERVICE_CODE = v_REQUEST_TYPE
				AND D.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND D.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
				AND D.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
				AND IS_DAY_INTERVAL_OF_TYPE(p_FILTER_HOURS, FROM_CUT(D.LOAD_DATE,p_TIME_ZONE)) = 1
				AND C.SUPPLY_TYPE = UPPER(SUBSTR(p_SUPPLY_TYPE,1,1))
				AND C.IS_BUG = 0
				AND C.IS_WHOLESALE = 0
			GROUP BY FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID)
			ORDER BY 1;
	END IF;

END ESP_SUPPLY_TYPE_SUMMARY;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_BACKUP_GENERATION_SUMMARY
	(
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_INCLUDE_UFE IN NUMBER,
	p_FILTER_HOURS IN NUMBER,
	p_STATUS IN OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the PSE backup generation.
-- Request Type is "F", "B", or "U" for Forecast, Backcast, and Usage respectively.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_AS_OF_DATE DATE;
v_REQUEST_TYPE CHAR(1) := UPPER(SUBSTR(p_REQUEST_TYPE,1,1));

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_BEGIN_DATE, v_END_DATE);

	v_AS_OF_DATE := AS_OF_DATE_FOR_REQUEST(p_REQUEST_TYPE, p_AS_OF_DATE);

	IF IS_VERSIONED_REQUEST(v_REQUEST_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) THEN
		OPEN p_CURSOR FOR
			SELECT FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID) "LOAD_DATE",
				SUM(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "LOAD_VAL",
				MIN(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "MIN_LOAD_VAL",
				MAX(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "MAX_LOAD_VAL",
				AVG(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "AVG_LOAD_VAL"
			FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, SERVICE_OBLIGATION_LOAD D
			WHERE (p_EDC_ID = CONSTANTS.ALL_ID OR B.EDC_ID = p_EDC_ID)
				AND A.MODEL_ID = p_MODEL_ID
				AND A.SCENARIO_ID = p_SCENARIO_ID
				AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
				AND A.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
				AND A.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM SERVICE_OBLIGATION
					WHERE MODEL_ID = A.MODEL_ID
						AND SCENARIO_ID = A.SCENARIO_ID
						AND PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
						AND SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
						AND AS_OF_DATE <= v_AS_OF_DATE)
				AND D.SERVICE_CODE = v_REQUEST_TYPE
				AND D.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND D.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
				AND D.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
				AND IS_DAY_INTERVAL_OF_TYPE(p_FILTER_HOURS, FROM_CUT(D.LOAD_DATE,p_TIME_ZONE)) = 1
				AND C.IS_BUG = 1
				AND C.IS_WHOLESALE = 0
			GROUP BY FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID)
			ORDER BY 1;
	ELSE
		OPEN p_CURSOR FOR
			SELECT FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID) "LOAD_DATE",
				SUM(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "LOAD_VAL",
				MIN(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "MIN_LOAD_VAL",
				MAX(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "MAX_LOAD_VAL",
				AVG(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + DECODE(p_INCLUDE_UFE,1,NVL(UFE_LOAD_VAL,0),0)) "AVG_LOAD_VAL"
			FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, SERVICE_OBLIGATION_LOAD D
			WHERE (p_EDC_ID = CONSTANTS.ALL_ID OR B.EDC_ID = p_EDC_ID)
				AND A.MODEL_ID = p_MODEL_ID
				AND A.SCENARIO_ID = p_SCENARIO_ID
				AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
				AND A.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
				AND A.AS_OF_DATE = v_AS_OF_DATE
				AND D.SERVICE_CODE = v_REQUEST_TYPE
				AND D.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND D.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
				AND D.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
				AND IS_DAY_INTERVAL_OF_TYPE(p_FILTER_HOURS, FROM_CUT(D.LOAD_DATE,p_TIME_ZONE)) = 1
				AND C.IS_BUG = 1
				AND C.IS_WHOLESALE = 0
			GROUP BY FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID)
			ORDER BY 1;
	END IF;

END PSE_BACKUP_GENERATION_SUMMARY;
---------------------------------------------------------------------------------------------------
PROCEDURE SYSTEM_LOAD_AREA_NAMES
	(
	p_REQUEST_TYPE IN CHAR,
	p_SYSTEM_LOAD_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of system load areas defined in the database.

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT B.AREA_NAME, B.AREA_ID
		FROM SYSTEM_LOAD_AREA A, AREA B
		WHERE A.SYSTEM_LOAD_ID = p_SYSTEM_LOAD_ID
		    AND B.AREA_ID = A.AREA_ID
		ORDER BY B.AREA_NAME;

END SYSTEM_LOAD_AREA_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE AREA_LOADS
	(
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
    p_CASE_ID IN NUMBER,
	p_LOAD_CODE IN CHAR,
	p_AREA_IDS IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the areas from the specified ids.

v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_BEGIN_DATE, v_END_DATE);

	IF GA.VERSION_AREA_LOAD THEN
		OPEN p_CURSOR FOR
			SELECT A.AREA_NAME, FROM_CUT_AS_HED(B.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID), SUM(B.LOAD_VAL)
			FROM AREA A, AREA_LOAD B
			WHERE A.AREA_ID = IN_CANDIDATE_LIST(A.AREA_ID, p_AREA_IDS)
				AND B.CASE_ID = p_CASE_ID
                AND B.AREA_ID = A.AREA_ID
				AND B.LOAD_CODE = DECODE(UPPER(SUBSTR(p_LOAD_CODE,1,1)), 'F', 'F', 'A', 'A', 'U', 'A', UPPER(SUBSTR(p_LOAD_CODE,1,1)))
				AND B.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND B.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM AREA_LOAD
					WHERE AREA_ID = A.AREA_ID   --Use smaller, non-temporal table (A) for speed
						AND CASE_ID = p_CASE_ID        --Query is much faster with CASE_ID specified
						AND LOAD_CODE = B.LOAD_CODE
						AND LOAD_DATE = B.LOAD_DATE
						AND AS_OF_DATE <= p_AS_OF_DATE)
			GROUP BY A.AREA_NAME, FROM_CUT_AS_HED(B.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID)
			ORDER BY 1,2,3;
	ELSE
		OPEN p_CURSOR FOR
			SELECT A.AREA_NAME, FROM_CUT_AS_HED(B.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID), SUM(B.LOAD_VAL)
			FROM AREA A, AREA_LOAD B
			WHERE A.AREA_ID = IN_CANDIDATE_LIST(A.AREA_ID, p_AREA_IDS)
	            AND B.CASE_ID = p_CASE_ID
				AND B.AREA_ID = A.AREA_ID
				AND B.LOAD_CODE = DECODE(UPPER(SUBSTR(p_LOAD_CODE,1,1)), 'F', 'F', 'A', 'A', 'U', 'A', UPPER(SUBSTR(p_LOAD_CODE,1,1)))
				AND B.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND B.AS_OF_DATE = CONSTANTS.LOW_DATE
			GROUP BY A.AREA_NAME, FROM_CUT_AS_HED(B.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID)
			ORDER BY 1,2,3;
	END IF;

END AREA_LOADS;
---------------------------------------------------------------------------------------------------
PROCEDURE NET_LOADS
	(
	p_REQUEST_TYPE IN CHAR,
    p_MODEL_ID IN NUMBER,
	p_CASE_ID IN NUMBER,
	p_LOAD_CODE IN CHAR,
	p_AREA_IDS IN VARCHAR,
	p_SYSTEM_LOAD_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the net loads from the specified ids for the specified system.

v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_BEGIN_DATE, v_END_DATE);

	IF GA.VERSION_AREA_LOAD THEN
		OPEN p_CURSOR FOR
			SELECT FROM_CUT_AS_HED(B.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID),
				SUM(B.LOAD_VAL * DECODE(A.OPERATION_CODE,'A',1.0,'S',-1.0,1.0)) "LOAD_VAL"
			FROM SYSTEM_LOAD_AREA A, AREA_LOAD B
			WHERE B.AREA_ID = IN_CANDIDATE_LIST(B.AREA_ID, p_AREA_IDS)
				AND B.CASE_ID = p_CASE_ID
                AND A.AREA_ID = B.AREA_ID
				AND A.SYSTEM_LOAD_ID = p_SYSTEM_LOAD_ID
				AND B.LOAD_CODE = DECODE(UPPER(SUBSTR(p_LOAD_CODE,1,1)), 'F', 'F', 'A', 'A', 'U', 'A', UPPER(SUBSTR(p_LOAD_CODE,1,1)))
				AND B.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND B.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM AREA_LOAD
					WHERE AREA_ID = A.AREA_ID
						AND CASE_ID = p_CASE_ID        --Query is much faster with CASE_ID specified
						AND LOAD_CODE = B.LOAD_CODE
						AND LOAD_DATE = B.LOAD_DATE
						AND AS_OF_DATE <= p_AS_OF_DATE)
			GROUP BY FROM_CUT_AS_HED(B.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID)
			ORDER BY 1;
	ELSE
		OPEN p_CURSOR FOR
			SELECT FROM_CUT_AS_HED(B.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID),
				SUM(B.LOAD_VAL * DECODE(A.OPERATION_CODE,'A',1.0,'S',-1.0,1.0)) "LOAD_VAL"
			FROM SYSTEM_LOAD_AREA A, AREA_LOAD B
			WHERE B.AREA_ID = IN_CANDIDATE_LIST(B.AREA_ID, p_AREA_IDS)
				AND B.CASE_ID = p_CASE_ID
                AND A.AREA_ID = B.AREA_ID
				AND A.SYSTEM_LOAD_ID = p_SYSTEM_LOAD_ID
				AND B.LOAD_CODE = DECODE(UPPER(SUBSTR(p_LOAD_CODE,1,1)), 'F', 'F', 'A', 'A', 'U', 'A', UPPER(SUBSTR(p_LOAD_CODE,1,1)))
				AND B.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND B.AS_OF_DATE = CONSTANTS.LOW_DATE
			GROUP BY FROM_CUT_AS_HED(B.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID)
			ORDER BY 1;
	END IF;

END NET_LOADS;
---------------------------------------------------------------------------------------------------
PROCEDURE IS_EXTERNAL_FORECAST_UPDATE
	(
	p_REQUEST_TYPE IN CHAR,
	p_DATA_PAIRS IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

-- Update that aggregate accounts in service for the specified aggregate id, date and count triples.

v_STRING_TABLE GA.STRING_TABLE;
v_LINE_TABLE GA.STRING_TABLE;
v_INDEX BINARY_INTEGER;
v_SERVICE_ID NUMBER;
v_IS_EXTERNAL_FORECAST NUMBER(1);

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	UT.TOKENS_FROM_STRING(p_DATA_PAIRS,';', v_STRING_TABLE);
	v_INDEX := v_STRING_TABLE.FIRST;

 	LOOP
		UT.TOKENS_FROM_STRING(v_STRING_TABLE(v_INDEX),',', v_LINE_TABLE);

		v_SERVICE_ID := TO_NUMBER(v_LINE_TABLE(1));
		SELECT DECODE(TO_NUMBER(v_LINE_TABLE(2)),1,1,0) INTO v_IS_EXTERNAL_FORECAST FROM DUAL;

		UPDATE SERVICE_STATE
		SET IS_EXTERNAL_FORECAST = v_IS_EXTERNAL_FORECAST
		WHERE SERVICE_ID = v_SERVICE_ID
			AND SERVICE_CODE = p_REQUEST_TYPE;

		EXIT WHEN v_INDEX = v_STRING_TABLE.LAST;
		v_INDEX := v_STRING_TABLE.NEXT(v_INDEX);
	END LOOP;

    p_STATUS := GA.SUCCESS;

END IS_EXTERNAL_FORECAST_UPDATE;
---------------------------------------------------------------------------------------------------
PROCEDURE SAVE_SYSTEM_LOAD
	(
	p_REQUEST_TYPE IN CHAR,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_DATA_VALUES IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_STRING_TABLE GA.STRING_TABLE;
v_LINE_TABLE GA.STRING_TABLE;
v_DATE VARCHAR(16);
v_TIME VARCHAR(16);
v_INDEX BINARY_INTEGER;
v_AREA_LOAD AREA_LOAD%ROWTYPE;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;
	UT.TOKENS_FROM_STRING(p_DATA_VALUES,';', v_STRING_TABLE);

	v_AREA_LOAD.AS_OF_DATE := CORRECTED_AS_OF_DATE(p_AS_OF_DATE);

 	FOR v_INDEX IN v_STRING_TABLE.FIRST..v_STRING_TABLE.LAST LOOP
		UT.TOKENS_FROM_STRING(v_STRING_TABLE(v_INDEX),',', v_LINE_TABLE);
		v_AREA_LOAD.AREA_ID := TO_NUMBER(v_LINE_TABLE(1));

		v_DATE := SUBSTR(LTRIM(v_LINE_TABLE(2)),1,10);
		IF LENGTH(LTRIM(RTRIM(v_LINE_TABLE(2)))) < 12 THEN
			v_AREA_LOAD.LOAD_DATE := TO_DATE(v_DATE, 'YYYY-MM-DD');
		ELSE
			 v_TIME := RTRIM(SUBSTR(LTRIM(v_LINE_TABLE(2)),12));
			 v_AREA_LOAD.LOAD_DATE := DATE_TIME_AS_CUT(v_DATE, v_TIME, p_TIME_ZONE);
		END IF;

		SELECT DECODE(v_LINE_TABLE(3),'F','F','A','A','U','A',v_LINE_TABLE(3)) INTO v_AREA_LOAD.LOAD_CODE FROM DUAL;
		v_AREA_LOAD.LOAD_VAL := TO_NUMBER(v_LINE_TABLE(4));
		v_AREA_LOAD.CASE_ID := TO_NUMBER(v_LINE_TABLE(5));
		CS.PUT_AREA_LOAD(v_AREA_LOAD, p_STATUS);
	END LOOP;

END SAVE_SYSTEM_LOAD;
----------------------------------------------------------------------------------------------------
PROCEDURE EDC_NAMES_IN_USE
	(
	p_REQUEST_TYPE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of EDCs in use for the specific request type.

v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, GA.LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	OPEN p_CURSOR FOR
		SELECT B.EDC_NAME, B.EDC_ID
		FROM
			(SELECT DISTINCT EDC_ID
			FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_OBLIGATION_LOAD C
			WHERE B.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
				AND C.SERVICE_CODE = UPPER(SUBSTR(p_REQUEST_TYPE,1,1))
				AND C.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND C.LOAD_CODE = C.LOAD_CODE
				AND C.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID)  A,
		    ENERGY_DISTRIBUTION_COMPANY B
		WHERE B.EDC_ID = A.EDC_ID
		ORDER BY B.EDC_NAME;

END EDC_NAMES_IN_USE;
---------------------------------------------------------------------------------------------------
PROCEDURE ESP_NAMES_IN_USE
	(
	p_REQUEST_TYPE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ESP_TYPE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of ESPs in use for the specific request type and supply type.

v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, GA.LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	OPEN p_CURSOR FOR
		SELECT B.ESP_NAME, B.ESP_ID
		FROM
			(SELECT DISTINCT ESP_ID
			FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, SERVICE_OBLIGATION_LOAD D
			WHERE B.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
				AND C.SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
				AND C.SUPPLY_TYPE = UPPER(SUBSTR(p_ESP_TYPE,1,1))
				AND D.SERVICE_CODE = UPPER(SUBSTR(p_REQUEST_TYPE,1,1))
				AND D.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND D.LOAD_CODE = D.LOAD_CODE
				AND D.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID)  A,
		    ENERGY_SERVICE_PROVIDER B
		WHERE B.ESP_ID = A.ESP_ID
		ORDER BY B.ESP_NAME;

END ESP_NAMES_IN_USE;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_NAMES_IN_USE
	(
	p_REQUEST_TYPE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of PSEs in use for the specific request type.

v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, GA.LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	OPEN p_CURSOR FOR
		SELECT B.PSE_NAME, B.PSE_ID
		FROM
			(SELECT DISTINCT PSE_ID
			FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_OBLIGATION_LOAD C
			WHERE B.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
				AND C.SERVICE_CODE = UPPER(SUBSTR(p_REQUEST_TYPE,1,1))
				AND C.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND C.LOAD_CODE = C.LOAD_CODE
				AND C.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID)  A,
		    PURCHASING_SELLING_ENTITY B
		WHERE B.PSE_ID = A.PSE_ID
		ORDER BY B.PSE_NAME;

END PSE_NAMES_IN_USE;
---------------------------------------------------------------------------------------------------
PROCEDURE BUG_MARKET_PRICE_AND_BASIS
	(
	p_REQUEST_TYPE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the backup generation market price and basis.

v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

    p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, GA.LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	OPEN p_CURSOR FOR
		SELECT D.ESP_NAME, A.ESP_ID, FROM_CUT_AS_HED(A.LOAD_DATE, GA.LOCAL_TIME_ZONE) "LOAD_DATE", A.LOAD_VAL, C.PRICE
		FROM
			(SELECT EDC_ID, ESP_ID, LOAD_DATE, SUM(LOAD_VAL + NVL(UFE_LOAD_VAL,0)) "LOAD_VAL"
			FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, SERVICE_OBLIGATION_LOAD D
			WHERE A.MODEL_ID = A.MODEL_ID
				AND A.SCENARIO_ID = A.SCENARIO_ID
				AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
				AND A.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
				AND A.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM SERVICE_OBLIGATION
					WHERE MODEL_ID = A.MODEL_ID
						AND SCENARIO_ID = A.SCENARIO_ID
						AND PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
						AND SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
						AND AS_OF_DATE <= p_AS_OF_DATE)
				AND C.IS_BUG = 1
				AND D.SERVICE_CODE = UPPER(SUBSTR(p_REQUEST_TYPE,1,1))
				AND D.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND D.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
				AND D.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
			GROUP BY EDC_ID, ESP_ID, LOAD_DATE) A,
			MARKET_PRICE B, MARKET_PRICE_VALUE C, ENERGY_SERVICE_PROVIDER D
		WHERE B.EDC_ID = A.EDC_ID
			AND UPPER(RTRIM(B.MARKET_PRICE_TYPE)) = 'BACKUP GENERATION'
			AND C.MARKET_PRICE_ID = B.MARKET_PRICE_ID
			AND C.PRICE_CODE = DECODE(UPPER(SUBSTR(p_REQUEST_TYPE,1,1)),GA.FORECAST_SERVICE,'F',GA.BACKCAST_SERVICE,'P',GA.ACTUAL_SERVICE,'A','A')
			AND C.PRICE_DATE(+) = A.LOAD_DATE
			AND C.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM MARKET_PRICE_VALUE
				WHERE MARKET_PRICE_ID = C.MARKET_PRICE_ID
					AND PRICE_CODE = C.PRICE_CODE
					AND PRICE_DATE = C.PRICE_DATE
					AND AS_OF_DATE <= p_AS_OF_DATE)
			AND D.ESP_ID = A.ESP_ID
		ORDER BY 1,3;

END BUG_MARKET_PRICE_AND_BASIS;
---------------------------------------------------------------------------------------------------
PROCEDURE EXTERNAL_FORECAST_UPDATE
	(
	p_REQUEST_TYPE IN CHAR,
	p_DATA_TRIPLES IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_EXCLUDE_LOSSES IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

-- Update the aggregate accounts in service for the specified aggregate id, date and count triples.

v_STRING_TABLE GA.STRING_TABLE;
v_LINE_TABLE GA.STRING_TABLE;
v_INDEX BINARY_INTEGER;
v_FORECAST_DATE DATE;
v_FORECAST_VAL SERVICE_LOAD.LOAD_VAL%TYPE;
v_DATE VARCHAR(16);
v_TIME VARCHAR(16);
v_SERVICE_ID NUMBER;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	UT.TOKENS_FROM_STRING(p_DATA_TRIPLES,';', v_STRING_TABLE);

 	FOR v_INDEX IN v_STRING_TABLE.FIRST..v_STRING_TABLE.LAST LOOP
		UT.TOKENS_FROM_STRING(v_STRING_TABLE(v_INDEX),',', v_LINE_TABLE);
		v_SERVICE_ID := v_LINE_TABLE(1);
		v_DATE := SUBSTR(v_LINE_TABLE(2),1,10);
		v_TIME := SUBSTR(v_LINE_TABLE(2),11);
		v_FORECAST_DATE := DATE_TIME_AS_CUT(v_DATE, v_TIME, p_TIME_ZONE);
	    v_FORECAST_VAL := TO_NUMBER(v_LINE_TABLE(3));

		IF NOT v_SERVICE_ID = CONSTANTS.NOT_ASSIGNED THEN

			UPDATE SERVICE_LOAD
			SET LOAD_VAL = v_FORECAST_VAL
			WHERE SERVICE_ID = v_SERVICE_ID
				AND SERVICE_CODE = GA.FORECAST_SERVICE
		    	AND LOAD_DATE = v_FORECAST_DATE
				AND LOAD_CODE = GA.EXTERNAL;

			IF SQL%NOTFOUND THEN
			    INSERT INTO SERVICE_LOAD(SERVICE_ID, SERVICE_CODE, LOAD_DATE, LOAD_CODE, LOAD_VAL, TX_LOSS_VAL, DX_LOSS_VAL, UE_LOSS_VAL)
				VALUES(v_SERVICE_ID, GA.FORECAST_SERVICE, v_FORECAST_DATE, GA.EXTERNAL, v_FORECAST_VAL, 0, 0, 0);
			END IF;

			IF p_STATUS < GA.SUCCESS THEN
				ROLLBACK;
				RETURN;
			END IF;
		END IF;

	END LOOP;

    p_STATUS := GA.SUCCESS;

END EXTERNAL_FORECAST_UPDATE;
---------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNTS_IN_USE
	(
	p_REQUEST_TYPE IN CHAR,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_INCUMBENT_TYPE CHAR(3);

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;

	SELECT INCUMBENT_TYPE INTO v_INCUMBENT_TYPE FROM INCUMBENT_ENTITY;

 	OPEN p_CURSOR FOR
		SELECT DISTINCT ASEE.EDC_NAME,
			ASEE.EDC_ID,
			ASEE.ESP_NAME,
			ASEE.ESP_ID,
			ASEE.ACCOUNT_NAME,
			ASEE.ACCOUNT_ID,
			ASEE.SERVICE_LOCATION_NAME,
			ASEE.ACCOUNT_MODEL_OPTION AS MODEL_OPTION
		FROM ACCOUNT_SL_EDC_ESP ASEE, ACCOUNT A
		WHERE (p_EDC_ID = CONSTANTS.ALL_ID OR ASEE.EDC_ID = p_EDC_ID)
			AND ASEE.EDC_BEGIN_DATE <= p_END_DATE
			AND NVL(ASEE.EDC_END_DATE,p_BEGIN_DATE) >= p_BEGIN_DATE
			AND (p_ESP_ID = CONSTANTS.ALL_ID OR ASEE.ESP_ID = p_ESP_ID)
			AND ASEE.ESP_BEGIN_DATE <= p_END_DATE
			AND NVL(ASEE.ESP_END_DATE,p_BEGIN_DATE) >= p_BEGIN_DATE
			AND ASEE.BEGIN_DATE <= p_END_DATE
			AND NVL(ASEE.END_DATE,p_BEGIN_DATE) >= p_BEGIN_DATE
            AND A.ACCOUNT_ID = ASEE.ACCOUNT_ID
            AND A.IS_SUB_AGGREGATE = 0
		ORDER BY DECODE(v_INCUMBENT_TYPE, 'EDC', ASEE.EDC_NAME, ASEE.ESP_NAME),
			DECODE(v_INCUMBENT_TYPE, 'EDC', ASEE.ESP_NAME, ASEE.EDC_NAME),
			ASEE.ACCOUNT_NAME, ASEE.SERVICE_LOCATION_NAME;

END ACCOUNTS_IN_USE;
---------------------------------------------------------------------------------------------------
PROCEDURE THUMBNAIL_SUMMARY
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_AGGREGATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_AS_OF_DATE DATE;
v_REQUEST_TYPE CHAR(1) :=  UPPER(SUBSTR(p_REQUEST_TYPE,1,1));
v_SERVICE_STATE SERVICE_STATE%ROWTYPE;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;
	v_AS_OF_DATE := AS_OF_DATE_FOR_REQUEST(v_REQUEST_TYPE, p_AS_OF_DATE);

-- Answer a Thumbnail Summary at the Provider Level.
	IF p_ACCOUNT_ID <= 0 THEN
		IF IS_VERSIONED_REQUEST(v_REQUEST_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) THEN
			OPEN p_CURSOR FOR
				SELECT DECODE(B.AGGREGATE_ID,0,'Non-Aggregate','Aggregate') "Account Category",
					EXPAND_SVC_STATE_PROFILE_TYPE(E.PROFILE_TYPE) "Profile Type",
					COUNT(*) "Service Accounts",
					SUM(E.SERVICE_ACCOUNTS) "Enrollment",
					SUM(DECODE(NVL(E.PROFILE_ZERO_COUNT,0),0,0,1)) "Accounts Missing Values"
				FROM PROVIDER_SERVICE A, ACCOUNT_SERVICE B, SERVICE C, SERVICE_DELIVERY D, SERVICE_STATE E
				WHERE (p_EDC_ID = g_NA_BRANCH OR A.EDC_ID = p_EDC_ID)
					AND (p_ESP_ID = g_NA_BRANCH OR A.ESP_ID = p_ESP_ID)
					AND (p_PSE_ID = g_NA_BRANCH OR A.PSE_ID = p_PSE_ID)
					AND (p_POOL_ID = g_NA_BRANCH OR D.POOL_ID = p_POOL_ID)
					AND C.MODEL_ID = p_MODEL_ID
					AND C.SCENARIO_ID = p_SCENARIO_ID
					AND C.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
					AND C.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
					AND C.SERVICE_DELIVERY_ID = D.SERVICE_DELIVERY_ID
					AND C.AS_OF_DATE =
						(SELECT MAX(AS_OF_DATE)
						FROM SERVICE
						WHERE MODEL_ID = C.MODEL_ID
							AND SCENARIO_ID = C.SCENARIO_ID
							AND ACCOUNT_SERVICE_ID = C.ACCOUNT_SERVICE_ID
							AND PROVIDER_SERVICE_ID = C.PROVIDER_SERVICE_ID
							AND SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
							AND AS_OF_DATE <= v_AS_OF_DATE)
					AND E.SERVICE_CODE = v_REQUEST_TYPE
					AND E.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
					AND E.SERVICE_ID = C.SERVICE_ID
				GROUP BY DECODE(B.AGGREGATE_ID,0,'Non-Aggregate','Aggregate'),
					EXPAND_SVC_STATE_PROFILE_TYPE(E.PROFILE_TYPE);
		ELSE
			OPEN p_CURSOR FOR
				SELECT DECODE(B.AGGREGATE_ID,0,'Non-Aggregate','Aggregate') "Account Category",
					EXPAND_SVC_STATE_PROFILE_TYPE(E.PROFILE_TYPE) "Profile Type",
					COUNT(*) "Service Accounts",
					SUM(E.SERVICE_ACCOUNTS) "Enrollment",
					SUM(DECODE(NVL(E.PROFILE_ZERO_COUNT,0),0,0,1)) "Accounts Missing Values"
				FROM PROVIDER_SERVICE A, ACCOUNT_SERVICE B, SERVICE C, SERVICE_DELIVERY D, SERVICE_STATE E
				WHERE (p_EDC_ID = g_NA_BRANCH OR A.EDC_ID = p_EDC_ID)
					AND (p_ESP_ID = g_NA_BRANCH OR A.ESP_ID = p_ESP_ID)
					AND (p_PSE_ID = g_NA_BRANCH OR A.PSE_ID = p_PSE_ID)
					AND (p_POOL_ID = g_NA_BRANCH OR D.POOL_ID = p_POOL_ID)
					AND C.MODEL_ID = p_MODEL_ID
					AND C.SCENARIO_ID = p_SCENARIO_ID
					AND C.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
					AND C.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
					AND C.SERVICE_DELIVERY_ID = D.SERVICE_DELIVERY_ID
					AND C.AS_OF_DATE = v_AS_OF_DATE
					AND E.SERVICE_CODE = v_REQUEST_TYPE
					AND E.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
					AND E.SERVICE_ID = C.SERVICE_ID
				GROUP BY DECODE(B.AGGREGATE_ID,0,'Non-Aggregate','Aggregate'),
					EXPAND_SVC_STATE_PROFILE_TYPE(E.PROFILE_TYPE);
		END IF;
	ELSE
-- Answer a Thumbnail Summary at the Account Level.
		IF IS_VERSIONED_REQUEST(v_REQUEST_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) THEN
			SELECT C.* INTO v_SERVICE_STATE
			FROM ACCOUNT_SERVICE A, SERVICE B, SERVICE_STATE C
			WHERE A.ACCOUNT_ID = p_ACCOUNT_ID
				AND (p_SERVICE_LOCATION_ID = g_NA_NODE OR A.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID)
				AND (p_METER_ID = g_NA_NODE OR A.METER_ID = p_METER_ID)
				AND (p_AGGREGATE_ID = g_NA_NODE OR A.AGGREGATE_ID = p_AGGREGATE_ID)
				AND B.MODEL_ID = p_MODEL_ID
				AND B.SCENARIO_ID = p_SCENARIO_ID
				AND B.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
				AND B.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
				AND B.SERVICE_DELIVERY_ID = B.SERVICE_DELIVERY_ID
				AND B.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM SERVICE
					WHERE MODEL_ID = B.MODEL_ID
						AND SCENARIO_ID = B.SCENARIO_ID
						AND ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
						AND PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
						AND SERVICE_DELIVERY_ID = B.SERVICE_DELIVERY_ID
						AND AS_OF_DATE <= v_AS_OF_DATE)
				AND C.SERVICE_CODE = v_REQUEST_TYPE
				AND C.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
				AND C.SERVICE_ID = B.SERVICE_ID
				AND ROWNUM = 1;
		ELSE
			SELECT C.* INTO v_SERVICE_STATE
			FROM ACCOUNT_SERVICE A, SERVICE B, SERVICE_STATE C
			WHERE A.ACCOUNT_ID = p_ACCOUNT_ID
				AND (p_SERVICE_LOCATION_ID = g_NA_NODE OR A.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID)
				AND (p_METER_ID = g_NA_NODE OR A.METER_ID = p_METER_ID)
				AND (p_AGGREGATE_ID = g_NA_NODE OR A.AGGREGATE_ID = p_AGGREGATE_ID)
				AND B.MODEL_ID = p_MODEL_ID
				AND B.SCENARIO_ID = p_SCENARIO_ID
				AND B.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
				AND B.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
				AND B.SERVICE_DELIVERY_ID = B.SERVICE_DELIVERY_ID
				AND B.AS_OF_DATE = v_AS_OF_DATE
				AND C.SERVICE_CODE = v_REQUEST_TYPE
				AND C.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
				AND C.SERVICE_ID = B.SERVICE_ID
				AND ROWNUM = 1;
		END IF;
		OPEN p_CURSOR FOR
			SELECT 'Profile Type' "Attribute", EXPAND_SVC_STATE_PROFILE_TYPE(v_SERVICE_STATE.PROFILE_TYPE) "Value" FROM DUAL
			UNION SELECT 'Profile Source Date' "Attribute", NVL(TO_CHAR(v_SERVICE_STATE.PROFILE_SOURCE_DATE,'Month DD, YYYY'), '<Null>') "Value" FROM DUAL
			UNION SELECT 'Service Accounts' "Attribute", TO_CHAR(v_SERVICE_STATE.SERVICE_ACCOUNTS) "Value" FROM DUAL
			UNION SELECT 'Usage Factor' "Attribute", TO_CHAR(v_SERVICE_STATE.USAGE_FACTOR) "Value" FROM DUAL;
	END IF;

END THUMBNAIL_SUMMARY;
-------------------------------------------------------------------------------------------------
PROCEDURE FINANCIAL_DETAIL
	(
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_AGGREGATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_INTERVAL IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_POSITION_TYPE CHAR(1);
v_SERVICE_CODE CHAR(1);
v_VERSION CHAR(1) := 1;
v_HOURLY_BEGIN_DATE DATE;
v_HOURLY_END_DATE DATE;
v_DAILY_BEGIN_DATE DATE;
v_DAILY_END_DATE DATE;
v_SCENARIO_ROLLUP_TYPE NUMBER(1);

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	--Make sure we have data in the SYSTEM_DATE_TIME table.  Return an error if not.
	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, p_BEGIN_DATE, p_END_DATE);

	SELECT RUN_MODE INTO v_SCENARIO_ROLLUP_TYPE FROM LOAD_FORECAST_SCENARIO WHERE SCENARIO_ID = p_SCENARIO_ID;

    p_STATUS := GA.SUCCESS;
	SELECT DECODE(UPPER(SUBSTR(p_REQUEST_TYPE,1,1)),'F',1,'B',2,3) INTO v_POSITION_TYPE FROM DUAL;
	SELECT DECODE(UPPER(SUBSTR(p_REQUEST_TYPE,1,1)),'F', GA.FORECAST_SERVICE,'B', GA.BACKCAST_SERVICE, GA.ACTUAL_SERVICE) INTO v_SERVICE_CODE FROM DUAL;
	IF GA.VERSION_STATEMENT THEN v_VERSION := 2; END IF;
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_HOURLY_BEGIN_DATE, v_HOURLY_END_DATE);
	UT.CUT_DATE_RANGE(2, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_DAILY_BEGIN_DATE, v_DAILY_END_DATE);

	OPEN p_CURSOR FOR
		SELECT DECODE(p_INTERVAL, 'MM', F.MONTH_YYYY_MM_DD, 'Q', F.QUARTER_YYYY_MM_DD, 'Y', F.YEAR_YYYY_MM_DD) "POSITION_DATE",
		SUM(QUANTITY) "QUANTITY",
		MAX(MAX_QUANTITY) "MAX_QUANTITY",
		SUM(REVENUE) "REVENUE",
		SUM(COST) "COST",
		SUM(REVENUE) - SUM(COST) "MARGIN",
		((SUM(REVENUE) - SUM(COST)) / SUM(DECODE(COST,0,NULL,COST))) * 100 "PERCENT_MARGIN",
		((SUM(REVENUE) - SUM(COST)) / SUM(DECODE(QUANTITY,0,NULL,QUANTITY))) "MARGIN_PER_UNIT"
		FROM
			(SELECT D.SERVICE_ID,
				F.LOCAL_MONTH_TRUNC_DATE "CHARGE_DATE",
				SUM(H.SCENARIO_MULTIPLIER * (E.LOAD_VAL + E.TX_LOSS_VAL + E.DX_LOSS_VAL + E.UE_LOSS_VAL)) "QUANTITY",
				MAX(E.LOAD_VAL + E.TX_LOSS_VAL + E.DX_LOSS_VAL + E.UE_LOSS_VAL) "MAX_QUANTITY"
			FROM PROVIDER_SERVICE A, ACCOUNT_SERVICE B, SERVICE_DELIVERY C, SERVICE D, SERVICE_LOAD E, SYSTEM_DATE_TIME F, SYSTEM_DATE_TIME_SCENARIO H
			WHERE (p_EDC_ID = g_NA_BRANCH OR A.EDC_ID = p_EDC_ID)
				AND (p_ESP_ID = g_NA_BRANCH OR A.ESP_ID = p_ESP_ID)
				AND (p_PSE_ID = g_NA_BRANCH OR A.PSE_ID = p_PSE_ID)
				AND (p_ACCOUNT_ID = g_NA_NODE OR B.ACCOUNT_ID = p_ACCOUNT_ID)
				AND (p_SERVICE_LOCATION_ID = g_NA_NODE OR B.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID)
				AND (p_METER_ID = g_NA_NODE OR B.METER_ID = p_METER_ID)
				AND (p_AGGREGATE_ID = g_NA_NODE OR B.AGGREGATE_ID = p_AGGREGATE_ID)
				AND (p_POOL_ID = g_NA_BRANCH OR C.POOL_ID = p_POOL_ID)
				AND D.MODEL_ID = p_MODEL_ID
				AND D.SCENARIO_ID = p_SCENARIO_ID
				AND ((v_VERSION = 1 AND D.AS_OF_DATE = CONSTANTS.LOW_DATE) OR
					 (D.AS_OF_DATE = (SELECT MAX(AS_OF_DATE) FROM SERVICE WHERE MODEL_ID = D.MODEL_ID AND SCENARIO_ID = D.SCENARIO_ID AND AS_OF_DATE <= D.AS_OF_DATE AND PROVIDER_SERVICE_ID = D.PROVIDER_SERVICE_ID AND ACCOUNT_SERVICE_ID = D.ACCOUNT_SERVICE_ID AND SERVICE_DELIVERY_ID = D.SERVICE_DELIVERY_ID)))
				AND D.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
				AND D.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
				AND D.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
				AND F.TIME_ZONE = p_TIME_ZONE
				AND F.DATA_INTERVAL_TYPE = p_MODEL_ID
				AND F.CUT_DATE BETWEEN v_HOURLY_BEGIN_DATE AND v_HOURLY_END_DATE
				AND E.SERVICE_ID = D.SERVICE_ID
				AND E.SERVICE_CODE = v_SERVICE_CODE
				AND E.LOAD_DATE = F.CUT_DATE
				AND E.LOAD_CODE = F.DAY_TYPE
				AND H.DAY_TYPE = E.LOAD_CODE
				AND H.ROLLUP_DATE = F.LOCAL_DAY_TRUNC_DATE
				AND H.SCENARIO_ROLLUP_TYPE = v_SCENARIO_ROLLUP_TYPE
			GROUP BY D.SERVICE_ID, F.LOCAL_MONTH_TRUNC_DATE) A,
			(SELECT SERVICE_ID,
				CHARGE_DATE,
				SUM(DECODE(PRODUCT_TYPE, 'R', CHARGE_AMOUNT, 0)) "REVENUE",
				SUM(DECODE(PRODUCT_TYPE, 'C', CHARGE_AMOUNT, 0)) "COST"
			FROM SERVICE_POSITION_CHARGE
				WHERE CHARGE_DATE BETWEEN v_DAILY_BEGIN_DATE AND v_DAILY_END_DATE
					AND POSITION_TYPE = v_POSITION_TYPE
			GROUP BY SERVICE_ID, CHARGE_DATE) B,
		SYSTEM_DATE_TIME F
		WHERE A.SERVICE_ID = B.SERVICE_ID
			AND A.CHARGE_DATE = B.CHARGE_DATE
			AND F.TIME_ZONE = p_TIME_ZONE
			AND F.DATA_INTERVAL_TYPE = 2
			AND F.CUT_DATE = A.CHARGE_DATE
		GROUP BY DECODE(p_INTERVAL, 'MM', F.MONTH_YYYY_MM_DD, 'Q', F.QUARTER_YYYY_MM_DD, 'Y', F.YEAR_YYYY_MM_DD)
		ORDER BY 1;

END FINANCIAL_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE FINANCIAL_DETAIL_PRODUCT
	(
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_INTERVAL IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_POSITION_TYPE CHAR(1);
v_SERVICE_CODE CHAR(1);
v_HOURLY_BEGIN_DATE DATE;
v_HOURLY_END_DATE DATE;
v_SCENARIO_ROLLUP_TYPE NUMBER(1);
BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	--Make sure we have data in the SYSTEM_DATE_TIME table.  Return an error if not.
	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, p_BEGIN_DATE, p_END_DATE);

    p_STATUS := GA.SUCCESS;
	SELECT DECODE(UPPER(SUBSTR(p_REQUEST_TYPE,1,1)),'F',1,'B',2,3) INTO v_POSITION_TYPE FROM DUAL;
	SELECT DECODE(UPPER(SUBSTR(p_REQUEST_TYPE,1,1)),'F', GA.FORECAST_SERVICE,'B', GA.BACKCAST_SERVICE, GA.ACTUAL_SERVICE) INTO v_SERVICE_CODE FROM DUAL;
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_HOURLY_BEGIN_DATE, v_HOURLY_END_DATE);
	SELECT RUN_MODE INTO v_SCENARIO_ROLLUP_TYPE FROM LOAD_FORECAST_SCENARIO WHERE SCENARIO_ID = p_SCENARIO_ID;

		OPEN p_CURSOR FOR
			SELECT A.PRODUCT_NAME, B.COMPONENT_NAME, X.POSITION_DATE, C.PERIOD_NAME, X.BAND_NUMBER, X.QUANTITY, X.RATE, X.REVENUE, X.COST, X.REVENUE - X.COST "MARGIN", DECODE(X.COST, 0, NULL, (X.REVENUE - X.COST) / X.COST * 100) "PERCENT_MARGIN", TO_NUMBER(DECODE(X.QUANTITY, 0, NULL, (X.REVENUE - X.COST)/X.QUANTITY)) "MARGIN_PER_UNIT"
			FROM
				(SELECT DECODE(p_INTERVAL, 'MM', F.MONTH_YYYY_MM_DD, 'Q', F.QUARTER_YYYY_MM_DD, 'Y', F.YEAR_YYYY_MM_DD) "POSITION_DATE",
					A.PRODUCT_ID, A.COMPONENT_ID, A.PERIOD_ID, DECODE(A.BAND_NUMBER,0,NULL,A.BAND_NUMBER) "BAND_NUMBER",
                    A.CHARGE_QUANTITY "QUANTITY", A.CHARGE_RATE "RATE",
					DECODE(PRODUCT_TYPE, 'R', CHARGE_AMOUNT, 0) "REVENUE",
					DECODE(PRODUCT_TYPE, 'C', CHARGE_AMOUNT, 0) "COST"
				FROM SERVICE_POSITION_CHARGE A, SYSTEM_DATE_TIME F, SERVICE D
				WHERE D.MODEL_ID = p_MODEL_ID
					AND D.SCENARIO_ID = p_SCENARIO_ID
					AND D.AS_OF_DATE = CONSTANTS.LOW_DATE
					AND A.SERVICE_ID = D.SERVICE_ID
					AND A.POSITION_TYPE = v_POSITION_TYPE
					AND A.CHARGE_DATE BETWEEN TRUNC(p_BEGIN_DATE, 'MM') AND LAST_DAY(TRUNC(p_END_DATE))
					AND A.PRODUCT_TYPE IN ('R','C')
					AND A.PRODUCT_ID = p_PRODUCT_ID
					AND (p_COMPONENT_ID = g_NA_BRANCH OR A.COMPONENT_ID = p_COMPONENT_ID)
					AND F.TIME_ZONE = p_TIME_ZONE
					AND F.DATA_INTERVAL_TYPE = 2
					AND F.DAY_TYPE = GA.STANDARD
					AND F.CUT_DATE = A.CHARGE_DATE) X,
				PRODUCT A, COMPONENT B, PERIOD C
			WHERE A.PRODUCT_ID = X.PRODUCT_ID
				AND B.COMPONENT_ID = X.COMPONENT_ID
                AND C.PERIOD_ID(+) = X.PERIOD_ID
			ORDER BY 1;

END FINANCIAL_DETAIL_PRODUCT;
---------------------------------------------------------------------------------------------------
PROCEDURE FINANCIAL_SUMMARY_PRODUCT
	(
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_SUMMARY_NUMBER IN NUMBER,
	p_POSITION_TYPE IN NUMBER,
	p_SERVICE_CODE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_INTERVAL IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Summary Number 5 = 'Product', 6 = 'Component'
v_HOURLY_BEGIN_DATE DATE;
v_HOURLY_END_DATE DATE;
v_DAILY_BEGIN_DATE DATE;
v_DAILY_END_DATE DATE;
v_SCENARIO_ROLLUP_TYPE NUMBER(1);
BEGIN

	--Make sure we have data in the SYSTEM_DATE_TIME table.  Return an error if not.
	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, p_BEGIN_DATE, p_END_DATE);

    p_STATUS := GA.SUCCESS;
 	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_HOURLY_BEGIN_DATE, v_HOURLY_END_DATE);
 	UT.CUT_DATE_RANGE(2, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_DAILY_BEGIN_DATE, v_DAILY_END_DATE);
	SELECT RUN_MODE INTO v_SCENARIO_ROLLUP_TYPE FROM LOAD_FORECAST_SCENARIO WHERE SCENARIO_ID = p_SCENARIO_ID;

	OPEN p_CURSOR FOR
		SELECT DECODE(p_SUMMARY_NUMBER, 5, C.PRODUCT_NAME, 6, D.COMPONENT_NAME) "NAME",
		DECODE(p_INTERVAL, 'MM', F.MONTH_YYYY_MM_DD, 'Q', F.QUARTER_YYYY_MM_DD, 'Y', F.YEAR_YYYY_MM_DD) "POSITION_DATE",
		SUM(QUANTITY) "QUANTITY",
		MAX(MAX_QUANTITY) "MAX_QUANTITY",
		SUM(REVENUE) "REVENUE",
		SUM(COST) "COST",
		SUM(REVENUE) - SUM(COST) "MARGIN",
		((SUM(REVENUE) - SUM(COST)) / SUM(DECODE(COST,0,NULL,COST))) * 100 "PERCENT_MARGIN",
		((SUM(REVENUE) - SUM(COST)) / SUM(DECODE(QUANTITY,0,NULL,QUANTITY))) "MARGIN_PER_UNIT"
		FROM
			(SELECT B.SERVICE_ID,
				F.LOCAL_MONTH_TRUNC_DATE "CHARGE_DATE",
				SUM(H.SCENARIO_MULTIPLIER * (E.LOAD_VAL + E.TX_LOSS_VAL + E.DX_LOSS_VAL + E.UE_LOSS_VAL)) "QUANTITY",
				MAX(E.LOAD_VAL + E.TX_LOSS_VAL + E.DX_LOSS_VAL + E.UE_LOSS_VAL) "MAX_QUANTITY"
			FROM SERVICE B, SERVICE_LOAD E, SYSTEM_DATE_TIME F, SYSTEM_DATE_TIME_SCENARIO H
			WHERE B.MODEL_ID = p_MODEL_ID
				AND B.SCENARIO_ID = p_SCENARIO_ID
				AND B.AS_OF_DATE = CONSTANTS.LOW_DATE
				AND F.TIME_ZONE = p_TIME_ZONE
				AND F.DATA_INTERVAL_TYPE = p_MODEL_ID
				AND F.CUT_DATE BETWEEN v_HOURLY_BEGIN_DATE AND v_HOURLY_END_DATE
				AND E.SERVICE_ID = B.SERVICE_ID
				AND E.SERVICE_CODE = p_SERVICE_CODE
				AND E.LOAD_DATE = F.CUT_DATE
				AND E.LOAD_CODE = F.DAY_TYPE
				AND H.DAY_TYPE = E.LOAD_CODE
				AND H.ROLLUP_DATE = F.LOCAL_DAY_TRUNC_DATE
				AND H.SCENARIO_ROLLUP_TYPE = v_SCENARIO_ROLLUP_TYPE
			GROUP BY B.SERVICE_ID, F.LOCAL_MONTH_TRUNC_DATE) A,
			(SELECT DECODE(p_SUMMARY_NUMBER, 5, PRODUCT_ID, CONSTANTS.NOT_ASSIGNED) "PRODUCT_ID",
				DECODE(p_SUMMARY_NUMBER, 6, COMPONENT_ID, CONSTANTS.NOT_ASSIGNED) "COMPONENT_ID",
				SERVICE_ID,
				CHARGE_DATE,
				SUM(DECODE(PRODUCT_TYPE, 'R', CHARGE_AMOUNT, 0)) "REVENUE",
				SUM(DECODE(PRODUCT_TYPE, 'C', CHARGE_AMOUNT, 0)) "COST"
			FROM SERVICE_POSITION_CHARGE
				WHERE CHARGE_DATE BETWEEN v_DAILY_BEGIN_DATE AND v_DAILY_END_DATE
					AND POSITION_TYPE = p_POSITION_TYPE
			GROUP BY DECODE(p_SUMMARY_NUMBER, 5, PRODUCT_ID, CONSTANTS.NOT_ASSIGNED),
				DECODE(p_SUMMARY_NUMBER, 6, COMPONENT_ID, CONSTANTS.NOT_ASSIGNED),
				SERVICE_ID,
				CHARGE_DATE ) B,
			PRODUCT C,
			COMPONENT D,
			SYSTEM_DATE_TIME F
		WHERE A.SERVICE_ID = B.SERVICE_ID
			AND A.CHARGE_DATE = B.CHARGE_DATE
			AND F.TIME_ZONE = p_TIME_ZONE
			AND F.DATA_INTERVAL_TYPE = 2
			AND F.CUT_DATE = A.CHARGE_DATE
			AND C.PRODUCT_ID = B.PRODUCT_ID
			AND D.COMPONENT_ID = B.COMPONENT_ID
		GROUP BY DECODE(p_SUMMARY_NUMBER, 5, C.PRODUCT_NAME, 6, D.COMPONENT_NAME), DECODE(p_INTERVAL, 'MM', F.MONTH_YYYY_MM_DD, 'Q', F.QUARTER_YYYY_MM_DD, 'Y', F.YEAR_YYYY_MM_DD)
		ORDER BY 1, 2;

END FINANCIAL_SUMMARY_PRODUCT;
---------------------------------------------------------------------------------------------------
PROCEDURE FINANCIAL_SUMMARY_INVOICE
	(
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_SUMMARY_NUMBER IN NUMBER,
	p_POSITION_TYPE IN NUMBER,
	p_SERVICE_CODE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_INTERVAL IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Summary Number 7 = 'Invoice Group'
v_HOURLY_BEGIN_DATE DATE;
v_HOURLY_END_DATE DATE;
v_DAILY_BEGIN_DATE DATE;
v_DAILY_END_DATE DATE;
v_SCENARIO_ROLLUP_TYPE NUMBER(1);
BEGIN

	--Make sure we have data in the SYSTEM_DATE_TIME table.  Return an error if not.
	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, p_BEGIN_DATE, p_END_DATE);

    p_STATUS := GA.SUCCESS;
 	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_HOURLY_BEGIN_DATE, v_HOURLY_END_DATE);
 	UT.CUT_DATE_RANGE(2, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_DAILY_BEGIN_DATE, v_DAILY_END_DATE);
	SELECT RUN_MODE INTO v_SCENARIO_ROLLUP_TYPE FROM LOAD_FORECAST_SCENARIO WHERE SCENARIO_ID = p_SCENARIO_ID;

	OPEN p_CURSOR FOR
		SELECT C.INVOICE_GROUP_NAME "NAME",
		DECODE(p_INTERVAL, 'MM', F.MONTH_YYYY_MM_DD, 'Q', F.QUARTER_YYYY_MM_DD, 'Y', F.YEAR_YYYY_MM_DD) "POSITION_DATE",
		SUM(QUANTITY) "QUANTITY",
		MAX(MAX_QUANTITY) "MAX_QUANTITY",
		SUM(REVENUE) "REVENUE",
		SUM(COST) "COST",
		SUM(REVENUE) - SUM(COST) "MARGIN",
		((SUM(REVENUE) - SUM(COST)) / SUM(DECODE(COST,0,NULL,COST))) * 100 "PERCENT_MARGIN",
		((SUM(REVENUE) - SUM(COST)) / SUM(DECODE(QUANTITY,0,NULL,QUANTITY))) "MARGIN_PER_UNIT"
		FROM
			(SELECT B.SERVICE_ID,
				F.LOCAL_MONTH_TRUNC_DATE "CHARGE_DATE",
				SUM(H.SCENARIO_MULTIPLIER * (E.LOAD_VAL + E.TX_LOSS_VAL + E.DX_LOSS_VAL + E.UE_LOSS_VAL)) "QUANTITY",
				MAX(E.LOAD_VAL + E.TX_LOSS_VAL + E.DX_LOSS_VAL + E.UE_LOSS_VAL) "MAX_QUANTITY"
			FROM SERVICE B, SERVICE_LOAD E, SYSTEM_DATE_TIME F, SYSTEM_DATE_TIME_SCENARIO H
			WHERE B.MODEL_ID = p_MODEL_ID
				AND B.SCENARIO_ID = p_SCENARIO_ID
				AND B.AS_OF_DATE = CONSTANTS.LOW_DATE
				AND F.TIME_ZONE = p_TIME_ZONE
				AND F.DATA_INTERVAL_TYPE = p_MODEL_ID
				AND F.CUT_DATE BETWEEN v_HOURLY_BEGIN_DATE AND v_HOURLY_END_DATE
				AND E.SERVICE_ID = B.SERVICE_ID
				AND E.SERVICE_CODE = p_SERVICE_CODE
				AND E.LOAD_DATE = F.CUT_DATE
				AND E.LOAD_CODE = F.DAY_TYPE
				AND H.DAY_TYPE = E.LOAD_CODE
				AND H.ROLLUP_DATE = F.LOCAL_DAY_TRUNC_DATE
				AND H.SCENARIO_ROLLUP_TYPE = v_SCENARIO_ROLLUP_TYPE
			GROUP BY B.SERVICE_ID, F.LOCAL_MONTH_TRUNC_DATE) A,
			(SELECT SERVICE_ID,
				CHARGE_DATE,
				B.INVOICE_GROUP_ID,
				SUM(DECODE(PRODUCT_TYPE, 'R', CHARGE_AMOUNT, 0)) "REVENUE",
				SUM(DECODE(PRODUCT_TYPE, 'C', CHARGE_AMOUNT, 0)) "COST"
			FROM SERVICE_POSITION_CHARGE A, COMPONENT B
				WHERE CHARGE_DATE BETWEEN v_DAILY_BEGIN_DATE AND v_DAILY_END_DATE
					AND POSITION_TYPE = p_POSITION_TYPE
					AND A.COMPONENT_ID = B.COMPONENT_ID
			GROUP BY SERVICE_ID, CHARGE_DATE, B.INVOICE_GROUP_ID) B,
			INVOICE_GROUP C,
			SYSTEM_DATE_TIME F
		WHERE A.SERVICE_ID = B.SERVICE_ID
			AND A.CHARGE_DATE = B.CHARGE_DATE
			AND F.TIME_ZONE = p_TIME_ZONE
			AND F.DATA_INTERVAL_TYPE = 2
			AND F.CUT_DATE = A.CHARGE_DATE
			AND C.INVOICE_GROUP_ID = B.INVOICE_GROUP_ID
		GROUP BY C.INVOICE_GROUP_NAME, DECODE(p_INTERVAL, 'MM', F.MONTH_YYYY_MM_DD, 'Q', F.QUARTER_YYYY_MM_DD, 'Y', F.YEAR_YYYY_MM_DD)
		ORDER BY 1, 2;

END FINANCIAL_SUMMARY_INVOICE;
---------------------------------------------------------------------------------------------------
PROCEDURE FINANCIAL_SUMMARY_SERVICE
	(
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_SUMMARY_NUMBER IN NUMBER,
	p_POSITION_TYPE IN NUMBER,
	p_SERVICE_CODE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_INTERVAL IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Summary Number 1 = 'EDC', 2 = 'PSE', 3 = 'ESP', 4 = 'POOL'
v_VERSION CHAR(1) := 1;
v_HOURLY_BEGIN_DATE DATE;
v_HOURLY_END_DATE DATE;
v_DAILY_BEGIN_DATE DATE;
v_DAILY_END_DATE DATE;
v_SCENARIO_ROLLUP_TYPE NUMBER(1);
BEGIN

	--Make sure we have data in the SYSTEM_DATE_TIME table.  Return an error if not.
	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, p_BEGIN_DATE, p_END_DATE);

    p_STATUS := GA.SUCCESS;
	IF GA.VERSION_STATEMENT THEN v_VERSION := 2; END IF;
 	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_HOURLY_BEGIN_DATE, v_HOURLY_END_DATE);
 	UT.CUT_DATE_RANGE(2, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_DAILY_BEGIN_DATE, v_DAILY_END_DATE);
	SELECT RUN_MODE INTO v_SCENARIO_ROLLUP_TYPE FROM LOAD_FORECAST_SCENARIO WHERE SCENARIO_ID = p_SCENARIO_ID;

	--Business Entity-based summary types
	OPEN p_CURSOR FOR
		SELECT DECODE(p_SUMMARY_NUMBER, 1, B.EDC_NAME, 2, C.PSE_NAME, 3, D.ESP_NAME, 4, E.POOL_NAME) "NAME",
		DECODE(p_INTERVAL, 'MM', F.MONTH_YYYY_MM_DD, 'Q', F.QUARTER_YYYY_MM_DD, 'Y', F.YEAR_YYYY_MM_DD) "POSITION_DATE",
		SUM(QUANTITY) "QUANTITY",
		MAX(MAX_QUANTITY) "MAX_QUANTITY",
		SUM(REVENUE) "REVENUE",
		SUM(COST) "COST",
		SUM(REVENUE) - SUM(COST) "MARGIN",
		((SUM(REVENUE) - SUM(COST)) / SUM(DECODE(COST,0,NULL,COST))) * 100 "PERCENT_MARGIN",
		((SUM(REVENUE) - SUM(COST)) / SUM(DECODE(QUANTITY,0,NULL,QUANTITY))) "MARGIN_PER_UNIT"
		FROM
			(SELECT
				D.SERVICE_ID,
				DECODE(p_SUMMARY_NUMBER, 1, A.EDC_ID, CONSTANTS.NOT_ASSIGNED) "EDC_ID",
				DECODE(p_SUMMARY_NUMBER, 2, A.PSE_ID, CONSTANTS.NOT_ASSIGNED) "PSE_ID",
				DECODE(p_SUMMARY_NUMBER, 3, A.ESP_ID, CONSTANTS.NOT_ASSIGNED) "ESP_ID",
				DECODE(p_SUMMARY_NUMBER, 4, C.POOL_ID, CONSTANTS.NOT_ASSIGNED) "POOL_ID",
				F.LOCAL_MONTH_TRUNC_DATE "CHARGE_DATE",
				SUM(H.SCENARIO_MULTIPLIER * (E.LOAD_VAL + E.TX_LOSS_VAL + E.DX_LOSS_VAL + E.UE_LOSS_VAL)) "QUANTITY",
				MAX(E.LOAD_VAL + E.TX_LOSS_VAL + E.DX_LOSS_VAL + E.UE_LOSS_VAL) "MAX_QUANTITY"
			FROM PROVIDER_SERVICE A, SERVICE_DELIVERY C, SERVICE D, SERVICE_LOAD E, SYSTEM_DATE_TIME F, SYSTEM_DATE_TIME_SCENARIO H
			WHERE D.MODEL_ID = p_MODEL_ID
				AND D.SCENARIO_ID = p_SCENARIO_ID
					AND ((v_VERSION = 1 AND D.AS_OF_DATE = CONSTANTS.LOW_DATE) OR
						 (D.AS_OF_DATE = (SELECT MAX(AS_OF_DATE) FROM SERVICE WHERE MODEL_ID = D.MODEL_ID AND SCENARIO_ID = D.SCENARIO_ID AND AS_OF_DATE <= D.AS_OF_DATE AND PROVIDER_SERVICE_ID = D.PROVIDER_SERVICE_ID AND ACCOUNT_SERVICE_ID = D.ACCOUNT_SERVICE_ID AND SERVICE_DELIVERY_ID = D.SERVICE_DELIVERY_ID)))
				AND D.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
				AND D.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
				AND F.TIME_ZONE = p_TIME_ZONE
				AND F.DATA_INTERVAL_TYPE = p_MODEL_ID
				AND F.CUT_DATE BETWEEN v_HOURLY_BEGIN_DATE AND v_HOURLY_END_DATE
				AND E.SERVICE_ID = D.SERVICE_ID
				AND E.SERVICE_CODE = p_SERVICE_CODE
				AND E.LOAD_DATE = F.CUT_DATE
				AND E.LOAD_CODE = F.DAY_TYPE
				AND H.DAY_TYPE = E.LOAD_CODE
				AND H.ROLLUP_DATE = F.LOCAL_DAY_TRUNC_DATE
				AND H.SCENARIO_ROLLUP_TYPE = v_SCENARIO_ROLLUP_TYPE
			GROUP BY D.SERVICE_ID,
				DECODE(p_SUMMARY_NUMBER, 1, A.EDC_ID, CONSTANTS.NOT_ASSIGNED),
				DECODE(p_SUMMARY_NUMBER, 2, A.PSE_ID, CONSTANTS.NOT_ASSIGNED),
				DECODE(p_SUMMARY_NUMBER, 3, A.ESP_ID, CONSTANTS.NOT_ASSIGNED),
				DECODE(p_SUMMARY_NUMBER, 4, C.POOL_ID, CONSTANTS.NOT_ASSIGNED),
				F.LOCAL_MONTH_TRUNC_DATE) A,
			(SELECT SERVICE_ID,
				CHARGE_DATE,
				SUM(DECODE(PRODUCT_TYPE, 'R', CHARGE_AMOUNT, 0)) "REVENUE",
				SUM(DECODE(PRODUCT_TYPE, 'C', CHARGE_AMOUNT, 0)) "COST"
			FROM SERVICE_POSITION_CHARGE
				WHERE CHARGE_DATE BETWEEN v_DAILY_BEGIN_DATE AND v_DAILY_END_DATE
					AND POSITION_TYPE = p_POSITION_TYPE
			GROUP BY SERVICE_ID, CHARGE_DATE) B,
		SYSTEM_DATE_TIME F, ENERGY_DISTRIBUTION_COMPANY B, PURCHASING_SELLING_ENTITY C, ENERGY_SERVICE_PROVIDER D, POOL E
		WHERE A.SERVICE_ID = B.SERVICE_ID
			AND A.CHARGE_DATE = B.CHARGE_DATE
			AND F.TIME_ZONE = p_TIME_ZONE
			AND F.DATA_INTERVAL_TYPE = 2
			AND F.CUT_DATE = A.CHARGE_DATE
			AND B.EDC_ID = A.EDC_ID
			AND C.PSE_ID = A.PSE_ID
			AND D.ESP_ID = A.ESP_ID
			AND E.POOL_ID = A.POOL_ID
		GROUP BY DECODE(p_SUMMARY_NUMBER, 1, B.EDC_NAME, 2, C.PSE_NAME, 3, D.ESP_NAME, 4, E.POOL_NAME), DECODE(p_INTERVAL, 'MM', F.MONTH_YYYY_MM_DD, 'Q', F.QUARTER_YYYY_MM_DD, 'Y', F.YEAR_YYYY_MM_DD)
		ORDER BY 1, 2;

END FINANCIAL_SUMMARY_SERVICE;
---------------------------------------------------------------------------------------------------
PROCEDURE FINANCIAL_SUMMARY
	(
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_SUMMARY_TYPE IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_INTERVAL IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_POSITION_TYPE CHAR(1);
v_SUMMARY_TYPE CHAR(1);
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_SERVICE_CODE CHAR(1);

v_MODEL_ID NUMBER(1) := 2;
BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;
	SELECT DECODE(UPPER(SUBSTR(p_REQUEST_TYPE,1,1)),'F',1,'B',2,3) INTO v_POSITION_TYPE FROM DUAL;
	SELECT DECODE(UPPER(SUBSTR(p_REQUEST_TYPE,1,1)),'F', GA.FORECAST_SERVICE,'B', GA.BACKCAST_SERVICE, GA.ACTUAL_SERVICE) INTO v_SERVICE_CODE FROM DUAL;
	SELECT DECODE(UPPER(p_SUMMARY_TYPE),'EDC',1,'PSE',2,'ESP',3,'POOL',4,'PRODUCT',5,'COMPONENT',6,'INVOICE GROUP',7,1) INTO v_SUMMARY_TYPE FROM DUAL;
	UT.CUT_DATE_RANGE(v_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_BEGIN_DATE, v_END_DATE);

	IF v_SUMMARY_TYPE IN (1,2,3,4) THEN
		FINANCIAL_SUMMARY_SERVICE(p_MODEL_ID, p_SCENARIO_ID, v_SUMMARY_TYPE, v_POSITION_TYPE, v_SERVICE_CODE, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, p_INTERVAL, p_TIME_ZONE, p_STATUS, p_CURSOR);
	ELSIF v_SUMMARY_TYPE IN (5,6) THEN
		FINANCIAL_SUMMARY_PRODUCT(p_MODEL_ID, p_SCENARIO_ID, v_SUMMARY_TYPE, v_POSITION_TYPE, v_SERVICE_CODE, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, p_INTERVAL, p_TIME_ZONE, p_STATUS, p_CURSOR);
	ELSIF v_SUMMARY_TYPE IN (7) THEN
		FINANCIAL_SUMMARY_INVOICE(p_MODEL_ID, p_SCENARIO_ID, v_SUMMARY_TYPE, v_POSITION_TYPE, v_SERVICE_CODE, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, p_INTERVAL, p_TIME_ZONE, p_STATUS, p_CURSOR);
	END IF;

END FINANCIAL_SUMMARY;
---------------------------------------------------------------------------------------------------
PROCEDURE VALIDATION_SUMMARY
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_DISPLAY_MODE IN CHAR,
	p_VARIANCE_TEST IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- ANSWERS A SUMMARY OF ALL ENTITIES DEPENDING ON DISPLAY_MODE ('EDC','PSE','ESP','ACC', OR 'MET')
-- Request Type is "F", "B", or "U" for Forecast, Backcast, and Usage respectively.
v_VARIANCE_TEST NUMBER(1);
BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;
	 SELECT DECODE(UPPER(SUBSTR(p_VARIANCE_TEST,1,1)),'P',g_PEAK_VAR,'H',g_HOUR_VAR,g_TOTAL_VAR)
	 INTO v_VARIANCE_TEST FROM DUAL;

	 IF UPPER(p_DISPLAY_MODE) = 'EDC' THEN
	 	 OPEN p_CURSOR FOR
		 		SELECT 'NA' AS PARENT_NAME, B.EDC_NAME AS ENTITY_NAME, '0' AS EXTERNAL_IDENTIFIER, B.EDC_ID, A.ESP_ID, A.PSE_ID, A.POOL_ID,
						 0 AS ACCOUNT_ID, 0 AS SERVICE_LOCATION_ID, 0 AS METER_ID, 0 AS AGGREGATE_ID,
						 A.NUM_ACCOUNTS, A.PERCENT_DIFF, ABS(A.PERCENT_DIFF), A.DIFFERENCE
				FROM (
					  SELECT EDC_ID, MAX(ESP_ID) AS ESP_ID, MAX(PSE_ID) AS PSE_ID, MAX(POOL_ID) AS POOL_ID,
					  	  DECODE(v_VARIANCE_TEST, g_TOTAL_VAR, SUM(TOTAL_RULE), g_PEAK_VAR, SUM(PEAK_RULE), g_HOUR_VAR, SUM(HOUR_RULE)) AS NUM_ACCOUNTS,
					  	  DECODE(v_VARIANCE_TEST, g_TOTAL_VAR, MAX(TOTAL_PCT), g_PEAK_VAR, MAX(PEAK_PCT), g_HOUR_VAR, MAX(HOUR_PCT)) AS PERCENT_DIFF,
					  	  DECODE(v_VARIANCE_TEST, g_TOTAL_VAR, MAX(TOTAL_VAR), g_PEAK_VAR, MAX(PEAK_VAR), g_HOUR_VAR, MAX(HOUR_VAR)) AS DIFFERENCE
					  FROM SERVICE_VALIDATION_BEST_FIT A, PROVIDER_SERVICE B, SERVICE C, SERVICE_DELIVERY D
					  WHERE A.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
					  	  AND A.SERVICE_ID = C.SERVICE_ID
					  	  AND C.MODEL_ID = p_MODEL_ID
						  AND C.SCENARIO_ID = C.SCENARIO_ID
					     AND C.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
					  	  AND C.ACCOUNT_SERVICE_ID = C.ACCOUNT_SERVICE_ID
						  AND C.SERVICE_DELIVERY_ID = D.SERVICE_DELIVERY_ID
					  GROUP BY EDC_ID ) A,
					ENERGY_DISTRIBUTION_COMPANY B
				WHERE A.EDC_ID = B.EDC_ID
				ORDER BY 2;

	 ELSIF UPPER(p_DISPLAY_MODE) = 'PSE' THEN
	 	 OPEN p_CURSOR FOR
		 		SELECT 'NA' AS PARENT_NAME, B.PSE_NAME AS ENTITY_NAME, '0' AS EXTERNAL_IDENTIFIER, B.PSE_ID, A.EDC_ID, A.ESP_ID, A.POOL_ID,
						 0 AS ACCOUNT_ID, 0 AS SERVICE_LOCATION_ID, 0 AS METER_ID, 0 AS AGGREGATE_ID,
						 A.NUM_ACCOUNTS, A.PERCENT_DIFF, ABS(A.PERCENT_DIFF), A.DIFFERENCE
				FROM (
					  SELECT PSE_ID, MAX(EDC_ID) AS EDC_ID, MAX(ESP_ID) AS ESP_ID, MAX(POOL_ID) AS POOL_ID,
					  	  DECODE(v_VARIANCE_TEST, g_TOTAL_VAR, SUM(TOTAL_RULE), g_PEAK_VAR, SUM(PEAK_RULE), g_HOUR_VAR, SUM(HOUR_RULE)) AS NUM_ACCOUNTS,
					  	  DECODE(v_VARIANCE_TEST, g_TOTAL_VAR, MAX(TOTAL_PCT), g_PEAK_VAR, MAX(PEAK_PCT), g_HOUR_VAR, MAX(HOUR_PCT)) AS PERCENT_DIFF,
					  	  DECODE(v_VARIANCE_TEST, g_TOTAL_VAR, MAX(TOTAL_VAR), g_PEAK_VAR, MAX(PEAK_VAR), g_HOUR_VAR, MAX(HOUR_VAR)) AS DIFFERENCE
					  FROM SERVICE_VALIDATION_BEST_FIT A, PROVIDER_SERVICE B, SERVICE C, SERVICE_DELIVERY D
					  WHERE A.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
					  	  AND A.SERVICE_ID = C.SERVICE_ID
					  	  AND C.MODEL_ID = p_MODEL_ID
						  AND C.SCENARIO_ID = C.SCENARIO_ID
					     AND C.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
					  	  AND C.ACCOUNT_SERVICE_ID = C.ACCOUNT_SERVICE_ID
						  AND C.SERVICE_DELIVERY_ID = D.SERVICE_DELIVERY_ID
					  GROUP BY PSE_ID ) A,
					PURCHASING_SELLING_ENTITY B
				WHERE A.PSE_ID = B.PSE_ID
				ORDER BY 2;

	 ELSIF UPPER(p_DISPLAY_MODE) = 'ESP' THEN
	 	 OPEN p_CURSOR FOR
		 		SELECT 'NA' AS PARENT_NAME, B.ESP_NAME AS ENTITY_NAME, '0' AS EXTERNAL_IDENTIFIER, B.ESP_ID, A.EDC_ID, A.PSE_ID, A.POOL_ID,
						 0 AS ACCOUNT_ID, 0 AS SERVICE_LOCATION_ID, 0 AS METER_ID, 0 AS AGGREGATE_ID,
						 A.NUM_ACCOUNTS, A.PERCENT_DIFF, ABS(A.PERCENT_DIFF), A.DIFFERENCE
				FROM (
					  SELECT ESP_ID, MAX(EDC_ID) AS EDC_ID, MAX(PSE_ID) AS PSE_ID, MAX(POOL_ID) AS POOL_ID,
					  	  DECODE(v_VARIANCE_TEST, g_TOTAL_VAR, SUM(TOTAL_RULE), g_PEAK_VAR, SUM(PEAK_RULE), g_HOUR_VAR, SUM(HOUR_RULE)) AS NUM_ACCOUNTS,
					  	  DECODE(v_VARIANCE_TEST, g_TOTAL_VAR, MAX(TOTAL_PCT), g_PEAK_VAR, MAX(PEAK_PCT), g_HOUR_VAR, MAX(HOUR_PCT)) AS PERCENT_DIFF,
					  	  DECODE(v_VARIANCE_TEST, g_TOTAL_VAR, MAX(TOTAL_VAR), g_PEAK_VAR, MAX(PEAK_VAR), g_HOUR_VAR, MAX(HOUR_VAR)) AS DIFFERENCE
					  FROM SERVICE_VALIDATION_BEST_FIT A, PROVIDER_SERVICE B, SERVICE C, SERVICE_DELIVERY D
					  WHERE A.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
					  	  AND A.SERVICE_ID = C.SERVICE_ID
					  	  AND C.MODEL_ID = p_MODEL_ID
						  AND C.SCENARIO_ID = C.SCENARIO_ID
					     AND C.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
					  	  AND C.ACCOUNT_SERVICE_ID = C.ACCOUNT_SERVICE_ID
						  AND C.SERVICE_DELIVERY_ID = D.SERVICE_DELIVERY_ID
					  GROUP BY ESP_ID ) A,
					ENERGY_SERVICE_PROVIDER B
				WHERE A.ESP_ID = B.ESP_ID
				ORDER BY 2;

	 ELSIF UPPER(p_DISPLAY_MODE) = 'ACC' THEN
	 	 OPEN p_CURSOR FOR
		 		SELECT C.ESP_NAME AS PARENT_NAME, B.ACCOUNT_NAME AS ENTITY_NAME, B.ACCOUNT_EXTERNAL_IDENTIFIER AS EXTERNAL_IDENTIFIER, A.ESP_ID, A.EDC_ID, A.PSE_ID, A.POOL_ID,
						 A.ACCOUNT_ID AS ACCOUNT_ID, A.SERVICE_LOCATION_ID AS SERVICE_LOCATION_ID, 0 AS METER_ID, A.AGGREGATE_ID AS AGGREGATE_ID,
						 0 AS NUM_ACCOUNTS, A.PERCENT_DIFF, ABS(A.PERCENT_DIFF), A.DIFFERENCE
				FROM (
					  SELECT ACCOUNT_ID, EDC_ID, PSE_ID, ESP_ID, POOL_ID, AGGREGATE_ID, SERVICE_LOCATION_ID,
					  	  DECODE(v_VARIANCE_TEST, g_TOTAL_VAR, MAX(TOTAL_PCT), g_PEAK_VAR, MAX(PEAK_PCT), g_HOUR_VAR, MAX(HOUR_PCT)) AS PERCENT_DIFF,
					  	  DECODE(v_VARIANCE_TEST, g_TOTAL_VAR, MAX(TOTAL_VAR), g_PEAK_VAR, MAX(PEAK_VAR), g_HOUR_VAR, MAX(HOUR_VAR)) AS DIFFERENCE
					  FROM SERVICE_VALIDATION_BEST_FIT A, PROVIDER_SERVICE B, ACCOUNT_SERVICE C, SERVICE D, SERVICE_DELIVERY E
					  WHERE A.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
					  	  AND A.SERVICE_ID = D.SERVICE_ID
						  AND D.MODEL_ID = p_MODEL_ID
						  AND D.SCENARIO_ID = D.SCENARIO_ID
					  	  AND D.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
						  AND D.ACCOUNT_SERVICE_ID = C.ACCOUNT_SERVICE_ID
						  AND D.SERVICE_DELIVERY_ID = E.SERVICE_DELIVERY_ID
					  GROUP BY ACCOUNT_ID, EDC_ID, PSE_ID, ESP_ID, POOL_ID, AGGREGATE_ID, SERVICE_LOCATION_ID ) A,
					ACCOUNT B,
					ENERGY_SERVICE_PROVIDER C
				WHERE A.ACCOUNT_ID = B.ACCOUNT_ID
					AND A.ESP_ID = C.ESP_ID
				ORDER BY 1,2;

	 ELSIF UPPER(p_DISPLAY_MODE) = 'MET' THEN
	 	 OPEN p_CURSOR FOR
		 		SELECT C.ACCOUNT_NAME AS PARENT_NAME, B.METER_NAME AS ENTITY_NAME, B.METER_EXTERNAL_IDENTIFIER AS EXTERNAL_IDENTIFIER, A.ESP_ID, A.EDC_ID, A.PSE_ID, A.POOL_ID,
						 A.ACCOUNT_ID AS ACCOUNT_ID, A.SERVICE_LOCATION_ID AS SERVICE_LOCATION_ID, B.METER_ID AS METER_ID, A.AGGREGATE_ID AS AGGREGATE_ID,
						 0 AS NUM_ACCOUNTS, A.PERCENT_DIFF, ABS(A.PERCENT_DIFF), A.DIFFERENCE
				FROM (
					  SELECT METER_ID, ACCOUNT_ID, EDC_ID, PSE_ID, ESP_ID, POOL_ID, AGGREGATE_ID, SERVICE_LOCATION_ID,
					  	  DECODE(v_VARIANCE_TEST, g_TOTAL_VAR, MAX(TOTAL_PCT), g_PEAK_VAR, MAX(PEAK_PCT), g_HOUR_VAR, MAX(HOUR_PCT)) AS PERCENT_DIFF,
					  	  DECODE(v_VARIANCE_TEST, g_TOTAL_VAR, MAX(TOTAL_VAR), g_PEAK_VAR, MAX(PEAK_VAR), g_HOUR_VAR, MAX(HOUR_VAR)) AS DIFFERENCE
					  FROM SERVICE_VALIDATION_BEST_FIT A, PROVIDER_SERVICE B, ACCOUNT_SERVICE C, SERVICE D, SERVICE_DELIVERY E
					  WHERE A.SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
					  	  AND A.SERVICE_ID = D.SERVICE_ID
						  AND D.MODEL_ID = p_MODEL_ID
						  AND D.SCENARIO_ID = D.SCENARIO_ID
					  	  AND D.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
						  AND D.ACCOUNT_SERVICE_ID = C.ACCOUNT_SERVICE_ID
						  AND D.SERVICE_DELIVERY_ID = E.SERVICE_DELIVERY_ID
						  AND C.METER_ID > 0
					  GROUP BY METER_ID, ACCOUNT_ID, EDC_ID, PSE_ID, ESP_ID, POOL_ID, AGGREGATE_ID, SERVICE_LOCATION_ID ) A,
					METER B,
					ACCOUNT C
				WHERE A.METER_ID = B.METER_ID
					AND A.ACCOUNT_ID = C.ACCOUNT_ID
				ORDER BY 1,2;

	  ELSE
	  		NULL_CURSOR(p_CURSOR);
	  END IF;

END VALIDATION_SUMMARY;
---------------------------------------------------------------------------------------------------
PROCEDURE VALIDATION_DETAIL
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_AGGREGATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Request Type is "F", "B", or "U" for Forecast, Backcast, and Usage respectively.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

   p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	    OPEN p_CURSOR FOR
	        SELECT FROM_CUT_AS_HED(A.LOAD_DATE, p_TIME_ZONE, '', p_MODEL_ID) AS LOAD_DATE,
			  			SUM(LOAD_VAL) AS LOAD_VAL,
						SUM(HISTORICAL_VAL) AS HIST_VAL,
						SUM(LOAD_VAL) - SUM(HISTORICAL_VAL) AS HIST_DIFF,
						100 * DECODE(SUM(LOAD_VAL),0,-1,(SUM(LOAD_VAL) - SUM(HISTORICAL_VAL)) / SUM(LOAD_VAL)) AS HIST_PCT,
						SUM(AVERAGE_VAL) AS AVG_VAL,
						SUM(LOAD_VAL) - SUM(AVERAGE_VAL) AS AVG_DIFF,
						100 * DECODE(SUM(LOAD_VAL),0,-1,(SUM(LOAD_VAL) - SUM(AVERAGE_VAL)) / SUM(LOAD_VAL)) AS AVG_PCT,
						SUM(MOST_RECENT_VAL) AS RECENT_VAL,
						SUM(LOAD_VAL) - SUM(MOST_RECENT_VAL) AS RECENT_DIFF,
						100 * DECODE(SUM(LOAD_VAL),0,-1,(SUM(LOAD_VAL) - SUM(MOST_RECENT_VAL)) / SUM(LOAD_VAL)) AS RECENT_PCT
			  FROM SERVICE_VALIDATION_LOAD A, PROVIDER_SERVICE B, ACCOUNT_SERVICE C, SERVICE D, SERVICE_DELIVERY E
			  WHERE (p_EDC_ID = g_NA_BRANCH OR B.EDC_ID = p_EDC_ID)
			     AND (p_PSE_ID = g_NA_BRANCH OR B.PSE_ID = p_PSE_ID)
				  AND (p_ESP_ID = g_NA_BRANCH OR B.ESP_ID = p_ESP_ID)
				  AND (p_POOL_ID = g_NA_BRANCH OR E.POOL_ID = p_POOL_ID)
				  AND (p_ACCOUNT_ID = g_NA_NODE OR C.ACCOUNT_ID = p_ACCOUNT_ID)
				  AND (p_AGGREGATE_ID = g_NA_NODE OR C.AGGREGATE_ID = p_AGGREGATE_ID)
				  AND (p_SERVICE_LOCATION_ID = g_NA_NODE OR C.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID)
				  AND (p_METER_ID = g_NA_NODE OR C.METER_ID = p_METER_ID)
				  AND A.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			  	  AND A.SERVICE_ID = D.SERVICE_ID
				  AND D.MODEL_ID = p_MODEL_ID
				  AND D.SCENARIO_ID = D.SCENARIO_ID
				  AND D.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
			  	  AND D.ACCOUNT_SERVICE_ID = C.ACCOUNT_SERVICE_ID
				  AND D.SERVICE_DELIVERY_ID = E.SERVICE_DELIVERY_ID
			  GROUP BY FROM_CUT_AS_HED(A.LOAD_DATE, p_TIME_ZONE, '', p_MODEL_ID)
			  ORDER BY 1;

END VALIDATION_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE AGGREGATE_SUMMARY
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_INCLUDE_STANDARD_OFFER IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the Enrollment and Energy Use for all Aggregate Accounts
-- and a Total for Non-Aggregate Accounts for the specified Service Date.
-- Request Type is "F", "B", or "U" for USAGE, Backcast, and Usage respectively.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_AS_OF_DATE DATE;
v_STATUS NUMBER;

v_NUM_NON_AGG NUMBER(9);

v_ACCOUNT_IDS NUMBER_COLLECTION;

BEGIN

	UT.CUT_DATE_RANGE(p_MODEL_ID, p_SERVICE_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	v_AS_OF_DATE := AS_OF_DATE_FOR_REQUEST(p_REQUEST_TYPE, p_AS_OF_DATE);

	IF p_REQUEST_TYPE = 'U' AND GA.ENABLE_EXTERNAL_METER_ACCESS THEN
			XS.CACHE_USAGE(p_SERVICE_DATE, p_SERVICE_DATE, p_AS_OF_DATE, v_STATUS);
		IF NOT v_STATUS = GA.SUCCESS THEN
			ERRS.RAISE(MSGCODES.c_ERR_GENERAL,'CACHE_USAGE Returned Non-zero Status: ' || TO_CHAR(v_STATUS));
		END IF;
	END IF;

	-- FIRST, GET ALL AGGREGATE ACCOUNTS AND ENSURE SERVICE DETAILS FOR THEM
	SELECT ACS.ACCOUNT_ID
	BULK COLLECT INTO v_ACCOUNT_IDS
	FROM SERVICE S,
		SERVICE_OBLIGATION SO,
		PROVIDER_SERVICE PS,
		SERVICE_STATE SS,
		ACCOUNT_SERVICE ACS
	WHERE (PS.EDC_ID = p_EDC_ID OR p_EDC_ID = CONSTANTS.ALL_ID)
		AND S.PROVIDER_SERVICE_ID = PS.PROVIDER_SERVICE_ID
		AND S.MODEL_ID = p_MODEL_ID
		AND S.SCENARIO_ID = p_SCENARIO_ID
		AND SS.SERVICE_ID = S.SERVICE_ID
		AND SS.SERVICE_CODE = p_REQUEST_TYPE
		AND SS.SERVICE_DATE = p_SERVICE_DATE
		AND ACS.ACCOUNT_SERVICE_ID = S.ACCOUNT_SERVICE_ID
		AND NVL(ACS.AGGREGATE_ID, CONSTANTS.NOT_ASSIGNED) <> CONSTANTS.NOT_ASSIGNED;

	-- GET A COUNT OF ALL NON-AGGREGATE ACCOUNTS (FOR THE ENROLLMENT ROW IN THE RESULTS)
	SELECT COUNT(DISTINCT ACS.ACCOUNT_SERVICE_ID)
	INTO v_NUM_NON_AGG
	FROM SERVICE S,
		SERVICE_OBLIGATION SO,
		PROVIDER_SERVICE PS,
		SERVICE_STATE SS,
		ACCOUNT_SERVICE ACS
	WHERE (PS.EDC_ID = p_EDC_ID OR p_EDC_ID = CONSTANTS.ALL_ID)
		AND S.PROVIDER_SERVICE_ID = PS.PROVIDER_SERVICE_ID
		AND S.MODEL_ID = p_MODEL_ID
		AND S.SCENARIO_ID = p_SCENARIO_ID
		AND SS.SERVICE_ID = S.SERVICE_ID
		AND SS.SERVICE_CODE = p_REQUEST_TYPE
		AND SS.SERVICE_DATE = p_SERVICE_DATE
		AND ACS.ACCOUNT_SERVICE_ID = S.ACCOUNT_SERVICE_ID
		AND NVL(ACS.AGGREGATE_ID, CONSTANTS.NOT_ASSIGNED) = CONSTANTS.NOT_ASSIGNED;

	FS.ENSURE_SERVICE_DETAILS(p_REQUEST_TYPE,
							p_MODEL_ID,
							p_SCENARIO_ID,
							p_EDC_ID,
							CONSTANTS.ALL_ID,
							v_ACCOUNT_IDS,
							v_BEGIN_DATE,
							v_END_DATE,
							v_AS_OF_DATE);

	IF IS_VERSIONED_REQUEST(p_REQUEST_TYPE, p_SERVICE_DATE, p_SERVICE_DATE, p_AS_OF_DATE) THEN
		OPEN p_CURSOR FOR
			SELECT 0 AS ACCOUNT_ID, 'Non-Aggregate' AS ACCOUNT_NAME,
				FROM_CUT_AS_HED(SOL.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID) AS SERVICE_DATE,
				v_NUM_NON_AGG AS ENROLLMENT, SUM(SOL.LOAD_VAL - SOL.AGG_LOAD_VAL) * 1000 AS ENERGY
			FROM SERVICE_OBLIGATION SO,
				SERVICE_OBLIGATION_LOAD SOL,
				SERVICE_DELIVERY SD,
				PROVIDER_SERVICE PS
			WHERE (PS.EDC_ID = p_EDC_ID OR p_EDC_ID = CONSTANTS.ALL_ID)
				AND NOT SD.SUPPLY_TYPE = DECODE(p_INCLUDE_STANDARD_OFFER,0,'S','@')
				AND SO.PROVIDER_SERVICE_ID = PS.PROVIDER_SERVICE_ID
				AND SO.SERVICE_DELIVERY_ID = SD.SERVICE_DELIVERY_ID
				AND SOL.SERVICE_OBLIGATION_ID = SO.SERVICE_OBLIGATION_ID
				AND SO.MODEL_ID = p_MODEL_ID
				AND SO.SCENARIO_ID = p_SCENARIO_ID
				AND SO.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
									FROM SERVICE_OBLIGATION
									WHERE MODEL_ID = SO.MODEL_ID
										AND SCENARIO_ID = SO.SCENARIO_ID
										AND PROVIDER_SERVICE_ID = SO.PROVIDER_SERVICE_ID
										AND SERVICE_DELIVERY_ID = SO.SERVICE_DELIVERY_ID
										AND AS_OF_DATE <= v_AS_OF_DATE)
				AND SOL.SERVICE_CODE = p_REQUEST_TYPE
				AND SOL.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND SOL.LOAD_CODE = GA.STANDARD
			GROUP BY FROM_CUT_AS_HED(SOL.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID)
			UNION ALL
			SELECT A.ACCOUNT_ID AS ACCOUNT_ID, A.ACCOUNT_DISPLAY_NAME AS ACCOUNT_DISPLAY_NAME,
				FROM_CUT_AS_HED(SL.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID) AS SERVICE_DATE,
				SUM(ST.SERVICE_ACCOUNTS) AS ENROLLMENT, SUM(SL.LOAD_VAL) AS ENERGY
			FROM ACCOUNT_SERVICE ACTS, PROVIDER_SERVICE PS, SERVICE S, SERVICE_DELIVERY SD,
				SERVICE_STATE ST, SERVICE_LOAD SL, ACCOUNT A, TABLE(CAST(v_ACCOUNT_IDS AS NUMBER_COLLECTION)) X
			WHERE ACTS.ACCOUNT_ID = X.COLUMN_VALUE
				AND A.ACCOUNT_ID = ACTS.ACCOUNT_ID
				AND (PS.EDC_ID = p_EDC_ID OR p_EDC_ID = CONSTANTS.ALL_ID)
				AND S.MODEL_ID = p_MODEL_ID
				AND S.SCENARIO_ID = p_SCENARIO_ID
				AND S.PROVIDER_SERVICE_ID = PS.PROVIDER_SERVICE_ID
				AND S.ACCOUNT_SERVICE_ID = ACTS.ACCOUNT_SERVICE_ID
				AND S.SERVICE_DELIVERY_ID = SD.SERVICE_DELIVERY_ID
				AND S.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM SERVICE
					WHERE MODEL_ID = S.MODEL_ID
						AND SCENARIO_ID = S.SCENARIO_ID
						AND ACCOUNT_SERVICE_ID = S.ACCOUNT_SERVICE_ID
						AND PROVIDER_SERVICE_ID = S.PROVIDER_SERVICE_ID
						AND SERVICE_DELIVERY_ID = S.SERVICE_DELIVERY_ID
						AND AS_OF_DATE <= v_AS_OF_DATE)
				AND NOT SD.SUPPLY_TYPE = DECODE(p_INCLUDE_STANDARD_OFFER,0,'S','@')
				AND ST.SERVICE_ID = S.SERVICE_ID
				AND ST.SERVICE_CODE = p_REQUEST_TYPE
				AND ST.SERVICE_DATE = TRUNC(p_SERVICE_DATE)
				AND SL.SERVICE_ID = ST.SERVICE_ID
				AND SL.SERVICE_CODE = p_REQUEST_TYPE
				AND SL.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND SL.LOAD_CODE = GA.STANDARD
				AND TRUNC(DECODE(p_MODEL_ID, GA.ELECTRIC_MODEL, FROM_CUT(SL.LOAD_DATE, GA.LOCAL_TIME_ZONE) - g_SECOND, SL.LOAD_DATE)) = TRUNC(ST.SERVICE_DATE)
    		GROUP BY A.ACCOUNT_ID, A.ACCOUNT_DISPLAY_NAME, FROM_CUT_AS_HED(SL.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID)
			ORDER BY 1, 2, 3;
	ELSE
		OPEN p_CURSOR FOR
		SELECT 0 AS ACCOUNT_ID, 'Non-Aggregate' AS ACCOUNT_NAME,
				FROM_CUT_AS_HED(SOL.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID) AS SERVICE_DATE,
				v_NUM_NON_AGG AS ENROLLMENT, SUM(SOL.LOAD_VAL - SOL.AGG_LOAD_VAL) * 1000 AS ENERGY
			FROM SERVICE_OBLIGATION SO,
				SERVICE_OBLIGATION_LOAD SOL,
				SERVICE_DELIVERY SD,
				PROVIDER_SERVICE PS
			WHERE (PS.EDC_ID = p_EDC_ID OR p_EDC_ID = CONSTANTS.ALL_ID)
				AND NOT SD.SUPPLY_TYPE = DECODE(p_INCLUDE_STANDARD_OFFER,0,'S','@')
				AND SO.PROVIDER_SERVICE_ID = PS.PROVIDER_SERVICE_ID
				AND SO.SERVICE_DELIVERY_ID = SD.SERVICE_DELIVERY_ID
				AND SOL.SERVICE_OBLIGATION_ID = SO.SERVICE_OBLIGATION_ID
				AND SO.MODEL_ID = p_MODEL_ID
				AND SO.SCENARIO_ID = p_SCENARIO_ID
				AND SO.AS_OF_DATE = v_AS_OF_DATE
				AND SOL.SERVICE_CODE = p_REQUEST_TYPE
				AND SOL.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND SOL.LOAD_CODE = GA.STANDARD
			GROUP BY FROM_CUT_AS_HED(SOL.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID)
			UNION ALL
			SELECT A.ACCOUNT_ID AS ACCOUNT_ID, A.ACCOUNT_DISPLAY_NAME AS ACCOUNT_DISPLAY_NAME,
				FROM_CUT_AS_HED(SL.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID) AS SERVICE_DATE,
				SUM(ST.SERVICE_ACCOUNTS) AS ENROLLMENT, SUM(SL.LOAD_VAL) AS ENERGY
			FROM ACCOUNT_SERVICE ACTS, PROVIDER_SERVICE PS, SERVICE S, SERVICE_DELIVERY SD,
				SERVICE_STATE ST, SERVICE_LOAD SL, ACCOUNT A, TABLE(CAST(v_ACCOUNT_IDS AS NUMBER_COLLECTION)) X
			WHERE ACTS.ACCOUNT_ID = X.COLUMN_VALUE
				AND A.ACCOUNT_ID = ACTS.ACCOUNT_ID
				AND (PS.EDC_ID = p_EDC_ID OR p_EDC_ID = CONSTANTS.ALL_ID)
				AND S.MODEL_ID = p_MODEL_ID
				AND S.SCENARIO_ID = p_SCENARIO_ID
				AND S.PROVIDER_SERVICE_ID = PS.PROVIDER_SERVICE_ID
				AND S.ACCOUNT_SERVICE_ID = ACTS.ACCOUNT_SERVICE_ID
				AND S.SERVICE_DELIVERY_ID = SD.SERVICE_DELIVERY_ID
				AND S.AS_OF_DATE = v_AS_OF_DATE
				AND NOT SD.SUPPLY_TYPE = DECODE(p_INCLUDE_STANDARD_OFFER,0,'S','@')
				AND ST.SERVICE_ID = S.SERVICE_ID
				AND ST.SERVICE_CODE = p_REQUEST_TYPE
				AND ST.SERVICE_DATE = TRUNC(p_SERVICE_DATE)
				AND SL.SERVICE_ID = ST.SERVICE_ID
				AND SL.SERVICE_CODE = p_REQUEST_TYPE
				AND SL.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND SL.LOAD_CODE = GA.STANDARD
				AND TRUNC(DECODE(p_MODEL_ID, GA.ELECTRIC_MODEL, FROM_CUT(SL.LOAD_DATE, GA.LOCAL_TIME_ZONE) - g_SECOND, SL.LOAD_DATE)) = TRUNC(ST.SERVICE_DATE)
    		GROUP BY A.ACCOUNT_ID, A.ACCOUNT_DISPLAY_NAME, FROM_CUT_AS_HED(SL.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID)
			ORDER BY 1, 2, 3;
	END IF;

	IF p_REQUEST_TYPE = 'U' AND GA.ENABLE_EXTERNAL_METER_ACCESS THEN
		XS.RELEASE_USAGE;
	END IF;

END AGGREGATE_SUMMARY;
---------------------------------------------------------------------------------------------------
PROCEDURE AGGREGATE_ACCOUNT_SUMMARY
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_INCLUDE_STANDARD_OFFER IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_SYSTEM_PEAK_HOUR OUT NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the Enrollment and Energy Use for all Aggregate Accounts
-- and a Total for Non-Aggregate Accounts for the specified Service Date.
-- Request Type is "F", "B", or "U" for Forecast, Backcast, and Usage respectively.

v_LOAD_CODE CHAR(1);
v_BEGIN_DATE DATE;
v_END_DATE DATE;

CURSOR c_SYSTEM_LOAD_PEAK IS
	SELECT C.LOAD_DATE, SUM((C.LOAD_VAL * DECODE(B.OPERATION_CODE,'A',1.0,'S',-1.0,1.0)))
	FROM ENERGY_DISTRIBUTION_COMPANY A,
		SYSTEM_LOAD_AREA B,
		AREA_LOAD C
	WHERE (p_EDC_ID = CONSTANTS.ALL_ID OR A.EDC_ID = p_EDC_ID)
		AND B.SYSTEM_LOAD_ID = A.EDC_SYSTEM_LOAD_ID
		AND C.AREA_ID = B.AREA_ID
        AND C.CASE_ID >= 0        --Query is much faster with CASE_ID specified
		AND C.LOAD_CODE = v_LOAD_CODE
		AND C.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND C.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM AREA_LOAD
			WHERE AREA_ID = B.AREA_ID
				AND CASE_ID >= 0        --Query is much faster with CASE_ID specified
				AND LOAD_CODE = C.LOAD_CODE
				AND LOAD_DATE = C.LOAD_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE)
	GROUP BY C.LOAD_DATE
	ORDER BY 2;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;
	SELECT DECODE(p_REQUEST_TYPE,'F','F','A') INTO v_LOAD_CODE FROM DUAL;
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_SERVICE_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	p_SYSTEM_PEAK_HOUR := 0;

-- Get the System Peak hour of the System Load associated with the EDC.

	FOR v_SYSTEM_LOAD_PEAK IN c_SYSTEM_LOAD_PEAK LOOP
		p_SYSTEM_PEAK_HOUR := TO_NUMBER(TO_CHAR(FROM_CUT(v_SYSTEM_LOAD_PEAK.LOAD_DATE, p_TIME_ZONE),'HH24'));
		IF p_SYSTEM_PEAK_HOUR = 0 THEN
			p_SYSTEM_PEAK_HOUR := 24;
		END IF;
		EXIT;
	END LOOP;

-- Get the Summary and Interval Detail data by Aggregate Account.
	AGGREGATE_SUMMARY(p_REQUEST_TYPE, p_MODEL_ID, p_SCENARIO_ID, p_EDC_ID, p_SERVICE_DATE, p_AS_OF_DATE, p_INCLUDE_STANDARD_OFFER, p_TIME_ZONE, p_INTERVAL, p_CURSOR);

END AGGREGATE_ACCOUNT_SUMMARY;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_ACCOUNT_USAGE
	(
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Request Type is "F", "B", or "U" for Forecast, Backcast, and Usage respectively.

v_ACCOUNT_IDENT ACCOUNT_IDENT_TABLE := ACCOUNT_IDENT_TABLE();
v_ACCOUNT_USAGE ACCOUNT_USAGE_TABLE := ACCOUNT_USAGE_TABLE();
v_ACCOUNT_EXTERNAL_IDENTIFIER VARCHAR(32);

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

   p_STATUS := GA.SUCCESS;

	SELECT ACCOUNT_EXTERNAL_IDENTIFIER
	INTO v_ACCOUNT_EXTERNAL_IDENTIFIER
	FROM ACCOUNT
	WHERE ACCOUNT_ID = p_ACCOUNT_ID;

	v_ACCOUNT_IDENT.EXTEND();
	v_ACCOUNT_IDENT(v_ACCOUNT_IDENT.LAST) := ACCOUNT_IDENT_TYPE(p_ACCOUNT_ID, v_ACCOUNT_EXTERNAL_IDENTIFIER, NULL);

	XS.GET_ACCOUNT_USAGE(TRUNC(p_BEGIN_DATE), TRUNC(p_END_DATE), p_AS_OF_DATE, v_ACCOUNT_IDENT, v_ACCOUNT_USAGE, p_STATUS);

	OPEN p_CURSOR FOR
		  SELECT A.ACCOUNT_ID,
		  		A.USAGE_DATE AS USAGE_DATE,
				A.USAGE_VAL
		  FROM TABLE(CAST(v_ACCOUNT_USAGE AS ACCOUNT_USAGE_TABLE)) A
		  ORDER BY 1,2;

	v_ACCOUNT_IDENT.DELETE;
	v_ACCOUNT_USAGE.DELETE;

END GET_ACCOUNT_USAGE;
---------------------------------------------------------------------------------------------------
PROCEDURE SCENARIOS
	(
	p_SCENARIO_CATEGORY IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the defined forecast types
-- and their corresponding forecast code.

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE('F')) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE('F'));
	END IF;

    p_STATUS := GA.SUCCESS;

    OPEN p_CURSOR FOR
 		SELECT *
		FROM SCENARIO
		WHERE SCENARIO_CATEGORY IN ('All', p_SCENARIO_CATEGORY)
		ORDER BY SCENARIO_NAME;

END SCENARIOS;
---------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNT_GROUP_NAMES
    (
	p_REQUEST_TYPE IN CHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of EDCs of the specified type.

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT ACCOUNT_GROUP_NAME, ACCOUNT_GROUP_ID, UPPER(ACCOUNT_GROUP_NAME)
		FROM ACCOUNT_GROUP
		ORDER BY 3;

END ACCOUNT_GROUP_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE UPDATE_CONSUMPTION_PERIOD
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_BILLED_USAGE IN NUMBER,
	p_METERS_READ IN NUMBER,
	p_METERED_USAGE IN NUMBER,
	p_IGNORE_CONSUMPTION IN NUMBER,
	p_CONSUMPTION_ID IN NUMBER,
	p_USER_NAME IN VARCHAR,
	p_STATUS OUT NUMBER
	 ) AS

-- PROCEDURE IS CALLED FROM SETTLEMENT AS WELL AS POSITION AND BILLING.

-- Update changed fields in SERVICE_CONSUMPTION table.
v_OLD_CONSUMPTION SERVICE_CONSUMPTION%ROWTYPE;
BEGIN

	IF NOT CAN_WRITE(MODULE_FOR_REQUEST_TYPE(GA.ACTUAL_SERVICE)) THEN
		ERRS.RAISE_NO_WRITE_MODULE(MODULE_FOR_REQUEST_TYPE(GA.ACTUAL_SERVICE));
	END IF;

    p_STATUS := GA.SUCCESS;

	 SELECT *
	 INTO v_OLD_CONSUMPTION
	 FROM SERVICE_CONSUMPTION
	 WHERE CONSUMPTION_ID = p_CONSUMPTION_ID;

	 UPDATE SERVICE_CONSUMPTION
	 SET BEGIN_DATE = p_BEGIN_DATE,
	 	  END_DATE = p_END_DATE,
		  BILLED_USAGE = p_BILLED_USAGE,
		  METERS_READ = p_METERS_READ,
		  METERED_USAGE = p_METERED_USAGE,
		  IGNORE_CONSUMPTION = p_IGNORE_CONSUMPTION
	 WHERE CONSUMPTION_ID = p_CONSUMPTION_ID;

END UPDATE_CONSUMPTION_PERIOD;
---------------------------------------------------------------------------------------------------
PROCEDURE LIMIT_SUMMARY
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_LIMIT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_AS_OF_DATE DATE;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_REQUEST_TYPE CHAR(1) := UPPER(SUBSTR(p_REQUEST_TYPE,1,1));

v_ACCOUNT_IDS NUMBER_COLLECTION;

v_TEMPLATES NUMBER_COLLECTION;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	v_AS_OF_DATE := AS_OF_DATE_FOR_REQUEST(p_REQUEST_TYPE, p_AS_OF_DATE);

	SELECT DISTINCT ACCT_S.ACCOUNT_ID
	BULK COLLECT INTO v_ACCOUNT_IDS
	FROM ACCOUNT_SERVICE ACCT_S,
		CONTRACT_ASSIGNMENT CA,
		CONTRACT_LIMIT_QUANTITY CLQ
	WHERE (CLQ.LIMIT_ID = p_LIMIT_ID AND p_LIMIT_ID = CONSTANTS.ALL_ID)
		AND CA.CONTRACT_ID = CLQ.CONTRACT_ID
		AND CA.OWNER_ENTITY_ID IN (ACCT_S.ACCOUNT_ID, ACCT_S.METER_ID)
		AND CA.ENTITY_DOMAIN_ID IN (EC.ED_ACCOUNT, EC.ED_METER)
		AND p_BEGIN_DATE <= NVL(CLQ.END_DATE, CONSTANTS.HIGH_DATE)
		AND p_END_DATE >= CLQ.BEGIN_DATE
		AND p_BEGIN_DATE <= NVL(CA.END_DATE, CONSTANTS.HIGH_DATE)
		AND p_END_DATE >= CA.BEGIN_DATE;

	FS.ENSURE_SERVICE_DETAILS(p_REQUEST_TYPE,
							p_MODEL_ID,
							GA.BASE_SCENARIO_ID,
							CONSTANTS.ALL_ID,
							CONSTANTS.ALL_ID,
							v_ACCOUNT_IDS,
							v_BEGIN_DATE,
							v_END_DATE,
							v_AS_OF_DATE);

	SELECT DISTINCT CL.TEMPLATE_ID
	BULK COLLECT INTO v_TEMPLATES
	FROM ACCOUNT_SERVICE ACCT_S,
		CONTRACT_ASSIGNMENT CA,
		CONTRACT_LIMIT_QUANTITY CLQ,
		CONTRACT_LIMIT CL
	WHERE (CLQ.LIMIT_ID = p_LIMIT_ID AND p_LIMIT_ID = CONSTANTS.ALL_ID)
		AND CA.CONTRACT_ID = CLQ.CONTRACT_ID
		AND CA.OWNER_ENTITY_ID IN (ACCT_S.ACCOUNT_ID, ACCT_S.METER_ID)
		AND CA.ENTITY_DOMAIN_ID IN (EC.ED_ACCOUNT, EC.ED_METER)
		AND p_BEGIN_DATE <= NVL(CLQ.END_DATE, CONSTANTS.HIGH_DATE)
		AND p_END_DATE >= CLQ.BEGIN_DATE
		AND p_BEGIN_DATE <= NVL(CA.END_DATE, CONSTANTS.HIGH_DATE)
		AND p_END_DATE >= CA.BEGIN_DATE
		AND CL.LIMIT_ID = CLQ.LIMIT_ID;

	SP.CHECK_TEMPLATE_DATES(v_TEMPLATES,
							NUMBER_COLLECTION(CONSTANTS.NOT_ASSIGNED),
							p_TIME_ZONE,
							p_BEGIN_DATE,
							p_END_DATE);

	OPEN p_CURSOR FOR
		SELECT LIMIT_NAME "Limit",
			LIMIT_INTERVAL "Interval",
			INTERVAL_BEGIN_DATE "Interval Begin",
			PERIOD_NAME "Period",
			COUNT(*) "Assignments",
			SUM(DECODE(SIGN(OBSERVED_QUANTITY - LIMIT_QUANTITY), 1, 0, 1)) "Observed <= Limit",
			SUM(DECODE(SIGN(OBSERVED_QUANTITY - LIMIT_QUANTITY), 1, 1, 0)) "Observed > Limit"
		FROM
			(SELECT A.LIMIT_NAME,
				A.LIMIT_ID,
				A.LIMIT_INTERVAL,
				A.PERIOD_NAME,
				A.ACCOUNT_SERVICE_ID,
				TRUNC(FROM_CUT(D.LOAD_DATE, p_TIME_ZONE), DECODE(UPPER(SUBSTR(A.LIMIT_INTERVAL,1,1)),'H', 'HH24', 'D', 'DD', 'M', 'MM', 'Y', 'YYYY', 'MM')) "INTERVAL_BEGIN_DATE",
				A.LIMIT_QUANTITY,
				A.LIMIT_TYPE,
				DECODE(UPPER(SUBSTR(A.LIMIT_TYPE,1,2)), 'EN', SUM(D.LOAD_VAL), 'MI', MIN(D.LOAD_VAL), 'MA', MAX(D.LOAD_VAL), 'PE', SUM(D.LOAD_VAL), AVG(D.LOAD_VAL)) "OBSERVED_QUANTITY"
			FROM
				(SELECT A.LIMIT_NAME, A.LIMIT_ID, A.LIMIT_INTERVAL, A.LIMIT_TYPE, A.TEMPLATE_ID, A.PERIOD_ID, B.PERIOD_NAME, E.ACCOUNT_SERVICE_ID, GREATEST(C.BEGIN_DATE, p_BEGIN_DATE) "BEGIN_DATE", LEAST(NVL(C.END_DATE, p_END_DATE), p_END_DATE) "END_DATE", C.LIMIT_QUANTITY
				FROM CONTRACT_LIMIT A, PERIOD B, CONTRACT_LIMIT_QUANTITY C, CONTRACT_ASSIGNMENT D, ACCOUNT_SERVICE E
				WHERE (p_LIMIT_ID = CONSTANTS.ALL_ID OR A.LIMIT_ID = p_LIMIT_ID)
					AND B.PERIOD_ID = A.PERIOD_ID
					AND C.LIMIT_ID = A.LIMIT_ID
					AND C.BEGIN_DATE <= p_END_DATE
					AND NVL(C.END_DATE, p_END_DATE) >= p_BEGIN_DATE
					AND D.CONTRACT_ID = C.CONTRACT_ID
					AND D.ENTITY_DOMAIN_ID IN (EC.ED_ACCOUNT, EC.ED_METER)
					AND D.OWNER_ENTITY_ID IN(E.ACCOUNT_ID, E.METER_ID)) A,
				TEMPLATE_DATES TD,
				TEMPLATE_DAY_TYPE_PERIOD DT,
				SERVICE C,
				SERVICE_LOAD D
			WHERE TD.TEMPLATE_ID = A.TEMPLATE_ID
				AND C.MODEL_ID = p_MODEL_ID
				AND C.SCENARIO_ID = GA.BASE_SCENARIO_ID
				AND C.AS_OF_DATE = v_AS_OF_DATE
				AND C.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
				AND D.SERVICE_ID = C.SERVICE_ID
				AND D.SERVICE_CODE = v_REQUEST_TYPE
				AND D.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND D.LOAD_CODE = GA.STANDARD
				AND TD.HOLIDAY_SET_ID = CONSTANTS.NOT_ASSIGNED
				AND TD.TIME_ZONE = p_TIME_ZONE
				AND D.LOAD_DATE > TD.CUT_BEGIN_DATE
				AND D.LOAD_DATE <= TD.CUT_END_DATE
				AND DT.DAY_TYPE_ID = TD.DAY_TYPE_ID
				AND D.LOAD_DATE = (TD.CUT_BEGIN_DATE + DT.TIME_STAMP)
				AND A.PERIOD_ID = DT.PERIOD_ID
			GROUP BY A.LIMIT_NAME, A.LIMIT_ID, A.LIMIT_INTERVAL, A.PERIOD_NAME, A.ACCOUNT_SERVICE_ID, TRUNC(FROM_CUT(D.LOAD_DATE, p_TIME_ZONE), DECODE(UPPER(SUBSTR(A.LIMIT_INTERVAL,1,1)),'H', 'HH24', 'D', 'DD', 'M', 'MM', 'Y', 'YYYY', 'MM')), A.LIMIT_QUANTITY, A.LIMIT_TYPE) X
		GROUP BY LIMIT_NAME, LIMIT_INTERVAL, INTERVAL_BEGIN_DATE, PERIOD_NAME
		ORDER BY LIMIT_NAME, LIMIT_INTERVAL, INTERVAL_BEGIN_DATE, PERIOD_NAME;

END LIMIT_SUMMARY;
---------------------------------------------------------------------------------------------------
PROCEDURE LIMIT_DETAIL
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_LIMIT_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_AGGREGATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_AS_OF_DATE DATE;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_REQUEST_TYPE CHAR(1) := UPPER(SUBSTR(p_REQUEST_TYPE,1,1));

v_TEMPLATES NUMBER_COLLECTION;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	v_AS_OF_DATE := AS_OF_DATE_FOR_REQUEST(p_REQUEST_TYPE, p_AS_OF_DATE);

	FS.ENSURE_SERVICE_DETAILS(p_REQUEST_TYPE,
							p_MODEL_ID,
							GA.BASE_SCENARIO_ID,
							CONSTANTS.ALL_ID,
							CONSTANTS.ALL_ID,
							NUMBER_COLLECTION(p_ACCOUNT_ID),
							v_BEGIN_DATE,
							v_END_DATE,
							v_AS_OF_DATE);

	SELECT DISTINCT CL.TEMPLATE_ID
	BULK COLLECT INTO v_TEMPLATES
	FROM CONTRACT_LIMIT CL, CONTRACT_LIMIT_QUANTITY CLQ,
		CONTRACT_ASSIGNMENT CA, ACCOUNT_SERVICE ASER
	WHERE (p_LIMIT_ID = CONSTANTS.ALL_ID OR CL.LIMIT_ID = p_LIMIT_ID)
		AND CL.LIMIT_ID = CLQ.LIMIT_ID
		AND CLQ.BEGIN_DATE <= p_END_DATE
		AND NVL(CLQ.END_DATE, p_END_DATE) >= p_BEGIN_DATE
		AND CA.CONTRACT_ID = CLQ.CONTRACT_ID
		AND CA.ENTITY_DOMAIN_ID IN(EC.ED_ACCOUNT, EC.ED_METER)
		AND CA.OWNER_ENTITY_ID IN(ASER.ACCOUNT_ID, ASER.METER_ID)
		AND ASER.ACCOUNT_ID = p_ACCOUNT_ID
		-- ALLOW METER RESULTS TO BE ROLLED UP INTO ACCOUNT LEVEL IF THE
		-- CONTRACT WAS ASSIGNED AT THE ACCOUNT LEVEL
		AND ASER.SERVICE_LOCATION_ID = CASE WHEN p_SERVICE_LOCATION_ID = CONSTANTS.NOT_ASSIGNED
											AND CA.ENTITY_DOMAIN_ID = EC.ED_ACCOUNT THEN ASER.SERVICE_LOCATION_ID
											ELSE  p_SERVICE_LOCATION_ID END
		AND ASER.METER_ID = CASE WHEN p_METER_ID = CONSTANTS.NOT_ASSIGNED
											AND CA.ENTITY_DOMAIN_ID = EC.ED_ACCOUNT THEN ASER.METER_ID
											ELSE  p_METER_ID END
		AND ASER.AGGREGATE_ID = p_AGGREGATE_ID;

	SP.CHECK_TEMPLATE_DATES(v_TEMPLATES,
							NUMBER_COLLECTION(CONSTANTS.NOT_ASSIGNED),
							p_TIME_ZONE,
							p_BEGIN_DATE,
							p_END_DATE);

	OPEN p_CURSOR FOR
		SELECT LIMIT_NAME "Limit",
			LIMIT_INTERVAL "Interval",
			INTERVAL_BEGIN_DATE "Interval Begin",
			PERIOD_NAME "Period",
 			LIMIT_QUANTITY "Limit Quantity",
 			ROUND(OBSERVED_QUANTITY, 3) "Observed Quantity",
 			ROUND(OBSERVED_QUANTITY - LIMIT_QUANTITY,3) "Difference",
 			ROUND((OBSERVED_QUANTITY - LIMIT_QUANTITY) / LIMIT_QUANTITY * 100,2)  "% Difference"
		FROM
			(SELECT A.LIMIT_NAME,
				A.LIMIT_ID,
				A.LIMIT_INTERVAL,
				A.PERIOD_NAME,
				TRUNC(FROM_CUT(D.LOAD_DATE, p_TIME_ZONE), DECODE(UPPER(SUBSTR(A.LIMIT_INTERVAL,1,1)),'H', 'HH24', 'D', 'DD', 'M', 'MM', 'Y', 'YYYY', 'MM')) "INTERVAL_BEGIN_DATE",
				A.LIMIT_QUANTITY,
				A.LIMIT_TYPE,
				DECODE(UPPER(SUBSTR(A.LIMIT_TYPE,1,2)), 'EN', SUM(D.LOAD_VAL), 'MI', MIN(D.LOAD_VAL), 'MA', MAX(D.LOAD_VAL), 'PE', SUM(D.LOAD_VAL), AVG(D.LOAD_VAL)) "OBSERVED_QUANTITY"
			FROM
				(SELECT DISTINCT D.ENTITY_DOMAIN_ID, A.LIMIT_NAME, A.LIMIT_ID, A.LIMIT_INTERVAL, A.LIMIT_TYPE, A.TEMPLATE_ID, A.PERIOD_ID, B.PERIOD_NAME, GREATEST(C.BEGIN_DATE, p_BEGIN_DATE) "BEGIN_DATE", LEAST(NVL(C.END_DATE, p_END_DATE), p_END_DATE) "END_DATE", C.LIMIT_QUANTITY
				FROM CONTRACT_LIMIT A, PERIOD B, CONTRACT_LIMIT_QUANTITY C, CONTRACT_ASSIGNMENT D, ACCOUNT_SERVICE E
				WHERE (p_LIMIT_ID = CONSTANTS.ALL_ID OR A.LIMIT_ID = p_LIMIT_ID)
					AND B.PERIOD_ID = A.PERIOD_ID
					AND C.LIMIT_ID = A.LIMIT_ID
					AND C.BEGIN_DATE <= p_END_DATE
					AND NVL(C.END_DATE, p_END_DATE) >= p_BEGIN_DATE
					AND D.CONTRACT_ID = C.CONTRACT_ID
					AND D.ENTITY_DOMAIN_ID IN(-170, -190)
					AND D.OWNER_ENTITY_ID IN(E.ACCOUNT_ID, E.METER_ID)
					AND E.ACCOUNT_ID = p_ACCOUNT_ID
					-- ALLOW METER RESULTS TO BE ROLLED UP INTO ACCOUNT LEVEL IF THE
					-- CONTRACT WAS ASSIGNED AT THE ACCOUNT LEVEL
					AND E.SERVICE_LOCATION_ID = CASE WHEN p_SERVICE_LOCATION_ID = CONSTANTS.NOT_ASSIGNED
														AND D.ENTITY_DOMAIN_ID = EC.ED_ACCOUNT THEN E.SERVICE_LOCATION_ID
														ELSE  p_SERVICE_LOCATION_ID END
					AND E.METER_ID = CASE WHEN p_METER_ID = CONSTANTS.NOT_ASSIGNED
														AND D.ENTITY_DOMAIN_ID = EC.ED_ACCOUNT THEN E.METER_ID
														ELSE  p_METER_ID END
					AND E.AGGREGATE_ID = p_AGGREGATE_ID) A,
				TEMPLATE_DATES TD,
				TEMPLATE_DAY_TYPE_PERIOD DT,
				ACCOUNT_SERVICE ACCT_S,
				SERVICE C,
				SERVICE_LOAD D
			WHERE TD.TEMPLATE_ID = A.TEMPLATE_ID
				AND C.MODEL_ID = p_MODEL_ID
				AND C.SCENARIO_ID = GA.BASE_SCENARIO_ID
				AND C.AS_OF_DATE = v_AS_OF_DATE
				AND ACCT_S.ACCOUNT_ID = p_ACCOUNT_ID
				-- ALLOW METER RESULTS TO BE ROLLED UP INTO ACCOUNT LEVEL IF THE
					-- CONTRACT WAS ASSIGNED AT THE ACCOUNT LEVEL
				AND ACCT_S.SERVICE_LOCATION_ID = CASE WHEN p_SERVICE_LOCATION_ID = CONSTANTS.NOT_ASSIGNED
													AND A.ENTITY_DOMAIN_ID = EC.ED_ACCOUNT THEN ACCT_S.SERVICE_LOCATION_ID
													ELSE  p_SERVICE_LOCATION_ID END
				AND ACCT_S.METER_ID = CASE WHEN p_METER_ID = CONSTANTS.NOT_ASSIGNED
													AND A.ENTITY_DOMAIN_ID = EC.ED_ACCOUNT THEN ACCT_S.METER_ID
													ELSE  p_METER_ID END
				AND ACCT_S.AGGREGATE_ID = p_AGGREGATE_ID
				AND C.ACCOUNT_SERVICE_ID = ACCT_S.ACCOUNT_SERVICE_ID
				AND D.SERVICE_ID = C.SERVICE_ID
				AND D.SERVICE_CODE = v_REQUEST_TYPE
				AND D.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND D.LOAD_CODE = GA.STANDARD
				AND TD.HOLIDAY_SET_ID = CONSTANTS.NOT_ASSIGNED
				AND TD.TIME_ZONE = p_TIME_ZONE
				AND D.LOAD_DATE > TD.CUT_BEGIN_DATE
				AND D.LOAD_DATE <= TD.CUT_END_DATE
				AND DT.DAY_TYPE_ID = TD.DAY_TYPE_ID
				AND D.LOAD_DATE = (TD.CUT_BEGIN_DATE + DT.TIME_STAMP)
				AND A.PERIOD_ID = DT.PERIOD_ID
			GROUP BY A.LIMIT_NAME, A.LIMIT_ID, A.LIMIT_INTERVAL, A.PERIOD_NAME, TRUNC(FROM_CUT(D.LOAD_DATE, p_TIME_ZONE), DECODE(UPPER(SUBSTR(A.LIMIT_INTERVAL,1,1)),'H', 'HH24', 'D', 'DD', 'M', 'MM', 'Y', 'YYYY', 'MM')), A.LIMIT_QUANTITY, A.LIMIT_TYPE) X
		ORDER BY LIMIT_NAME, LIMIT_INTERVAL, INTERVAL_BEGIN_DATE, PERIOD_NAME;

END LIMIT_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE LIMIT_NAMES
	(
	p_REQUEST_TYPE IN CHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of system load areas defined in the database.

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT DISTINCT C.LIMIT_NAME, C.LIMIT_ID
		FROM CONTRACT_LIMIT_QUANTITY A, CONTRACT_ASSIGNMENT B, CONTRACT_LIMIT C
		WHERE A.CONTRACT_ID = B.CONTRACT_ID
			AND A.LIMIT_ID = C.LIMIT_ID
			AND B.ENTITY_DOMAIN_ID IN(-170, -190)
		ORDER BY 1;

END LIMIT_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_ALL_SCENARIO_NAMES
	(
	p_REQUEST_TYPE IN CHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT SCENARIO_NAME, SCENARIO_ID
		FROM SCENARIO
		ORDER BY SCENARIO_NAME;

END GET_ALL_SCENARIO_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE LOAD_SCENCMP_SUMMARY
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_A_ID IN NUMBER,
	p_SCENARIO_B_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_AS_OF_DATE DATE;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_BEGIN_DATE, v_END_DATE);

	v_AS_OF_DATE := AS_OF_DATE_FOR_REQUEST(p_REQUEST_TYPE, p_AS_OF_DATE);

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('LOAD_SCENARIO_COMPARISON');
		LOGS.LOG_DEBUG('REQUEST_TYPE=' || p_REQUEST_TYPE);
		LOGS.LOG_DEBUG('MODEL_ID=' || TO_CHAR(p_MODEL_ID));
		LOGS.LOG_DEBUG('SCENARIO_A_ID=' || TO_CHAR(p_SCENARIO_A_ID));
		LOGS.LOG_DEBUG('SCENARIO_B_ID=' || TO_CHAR(p_SCENARIO_B_ID));
		LOGS.LOG_DEBUG('EDC_ID=' || TO_CHAR(p_EDC_ID));
		LOGS.LOG_DEBUG('PSE_ID=' || TO_CHAR(p_PSE_ID));
		LOGS.LOG_DEBUG('ESP_ID=' || TO_CHAR(p_ESP_ID));
		LOGS.LOG_DEBUG('POOL_ID=' || TO_CHAR(p_POOL_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TO_CHAR(p_END_DATE));
		LOGS.LOG_DEBUG('AS_OF_DATE=' || UT.TRACE_DATE(v_AS_OF_DATE));
		LOGS.LOG_DEBUG('TIME_ZONE=' || p_TIME_ZONE);
		LOGS.LOG_DEBUG('INTERVAL=' || p_INTERVAL);
	END IF;

	IF IS_VERSIONED_REQUEST(p_REQUEST_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) THEN
		OPEN p_CURSOR FOR
			SELECT FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, D.LOAD_CODE) "LOAD_DATE", A.SCENARIO_ID , E.SCENARIO_NAME, SUM(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + NVL(UFE_LOAD_VAL,0)) "LOAD_VAL"
			FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, SERVICE_OBLIGATION_LOAD D, SCENARIO E
			WHERE (p_EDC_ID = g_NA_BRANCH OR B.EDC_ID = p_EDC_ID)
				AND (p_ESP_ID = g_NA_BRANCH OR B.ESP_ID = p_ESP_ID)
				AND (p_PSE_ID = g_NA_BRANCH OR B.PSE_ID = p_PSE_ID)
				AND (p_POOL_ID = g_NA_BRANCH OR C.POOL_ID = p_POOL_ID)
				AND A.MODEL_ID = p_MODEL_ID
				AND A.SCENARIO_ID in (p_SCENARIO_A_ID, p_SCENARIO_B_ID)
                AND A.SCENARIO_ID = E.SCENARIO_ID
				AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
				AND A.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
				AND D.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
				AND D.SERVICE_CODE = UPPER(SUBSTR(p_REQUEST_TYPE,1,1))
				AND D.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND D.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
				AND A.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM SERVICE_OBLIGATION
					WHERE MODEL_ID = A.MODEL_ID
						AND SCENARIO_ID = A.SCENARIO_ID
						AND PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
						AND SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
						AND AS_OF_DATE <= v_AS_OF_DATE)
			GROUP BY FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, D.LOAD_CODE), A.SCENARIO_ID, E.SCENARIO_NAME
			ORDER BY 2, 1;
	ELSE
		OPEN p_CURSOR FOR
			SELECT FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, D.LOAD_CODE) "LOAD_DATE", A.SCENARIO_ID, E.SCENARIO_NAME, SUM(LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + NVL(UFE_LOAD_VAL,0)) "LOAD_VAL"
			FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, SERVICE_OBLIGATION_LOAD D, SCENARIO E
			WHERE (p_EDC_ID = g_NA_BRANCH OR B.EDC_ID = p_EDC_ID)
				AND (p_ESP_ID = g_NA_BRANCH OR B.ESP_ID = p_ESP_ID)
				AND (p_PSE_ID = g_NA_BRANCH OR B.PSE_ID = p_PSE_ID)
				AND (p_POOL_ID = g_NA_BRANCH OR C.POOL_ID = p_POOL_ID)
				AND A.MODEL_ID = p_MODEL_ID
				AND A.SCENARIO_ID in (p_SCENARIO_A_ID, p_SCENARIO_B_ID)
                AND A.SCENARIO_ID = E.SCENARIO_ID
				AND A.AS_OF_DATE = v_AS_OF_DATE
				AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
				AND A.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
				AND D.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
				AND D.SERVICE_CODE = UPPER(SUBSTR(p_REQUEST_TYPE,1,1))
				AND D.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND D.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
			GROUP BY FROM_CUT_AS_HED(LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, D.LOAD_CODE), A.SCENARIO_ID, E.SCENARIO_NAME
			ORDER BY 2, 1;
	END IF;

END LOAD_SCENCMP_SUMMARY;
---------------------------------------------------------------------------------------------------
PROCEDURE LOAD_SCENCMP_DETAIL
    (
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_A_ID IN NUMBER,
	p_SCENARIO_B_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_AGGREGATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_INCLUDE_TD_LOSSES IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the energy forecast for the specified account/meter over the time interval.
-- Request Type is "F", "B", or "U" for Forecast, Backcast, and Usage respectively.

v_SERVICE_LOCATION_ID NUMBER;
v_IS_CACHED BOOLEAN := FALSE;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_AS_OF_DATE DATE;

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

	v_SERVICE_LOCATION_ID := p_SERVICE_LOCATION_ID;
	IF v_SERVICE_LOCATION_ID < 0 THEN
		v_SERVICE_LOCATION_ID := GET_SERVICE_LOCATION_ID(p_ACCOUNT_ID, p_BEGIN_DATE);
	END IF;

	p_STATUS := GA.SUCCESS;

   IF p_REQUEST_TYPE = GA.ACTUAL_SERVICE THEN
		v_IS_CACHED := GA.ENABLE_EXTERNAL_METER_ACCESS AND IS_CACHED_USAGE(p_ACCOUNT_ID);
		IF v_IS_CACHED THEN
			XS.CACHE_USAGE(p_ACCOUNT_ID, p_SERVICE_LOCATION_ID, p_METER_ID, p_AGGREGATE_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_STATUS);
			IF NOT p_STATUS = GA.SUCCESS THEN
				ERRS.RAISE(MSGCODES.c_ERR_GENERAL,'CACHE_USAGE Returned Non-zero Status: ' || TO_CHAR(p_STATUS));
			END IF;
		END IF;
	ELSE
		v_IS_CACHED := FALSE;
	END IF;

	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_INTERVAL, v_BEGIN_DATE, v_END_DATE);
	v_AS_OF_DATE := AS_OF_DATE_FOR_REQUEST(p_REQUEST_TYPE, p_AS_OF_DATE);

	FS.ENSURE_SERVICE_DETAILS(p_REQUEST_TYPE,
							p_MODEL_ID,
							p_SCENARIO_A_ID,
							p_EDC_ID,
							p_ESP_ID,
							NUMBER_COLLECTION(p_ACCOUNT_ID),
							v_BEGIN_DATE,
							v_END_DATE,
							v_AS_OF_DATE);

	FS.ENSURE_SERVICE_DETAILS(p_REQUEST_TYPE,
							p_MODEL_ID,
							p_SCENARIO_B_ID,
							p_EDC_ID,
							p_ESP_ID,
							NUMBER_COLLECTION(p_ACCOUNT_ID),
							v_BEGIN_DATE,
							v_END_DATE,
							v_AS_OF_DATE);

	IF IS_VERSIONED_REQUEST(p_REQUEST_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE) THEN
		OPEN p_CURSOR FOR
			SELECT FROM_CUT_AS_HED(F.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, F.LOAD_CODE) "LOAD_DATE",
				C.SCENARIO_ID , E.SCENARIO_NAME,
				SUM(DECODE(p_INCLUDE_TD_LOSSES, 0 , LOAD_VAL, LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL)) "LOAD_VAL"
			FROM ACCOUNT_SERVICE A, PROVIDER_SERVICE B, SERVICE C, SERVICE_DELIVERY D, SERVICE_LOAD F, SCENARIO E
			WHERE A.ACCOUNT_ID = p_ACCOUNT_ID
				AND (v_SERVICE_LOCATION_ID = g_NA_NODE OR A.SERVICE_LOCATION_ID = v_SERVICE_LOCATION_ID)
				AND (p_METER_ID = g_NA_NODE OR A.METER_ID = p_METER_ID)
				AND (p_AGGREGATE_ID = g_NA_NODE OR A.AGGREGATE_ID = p_AGGREGATE_ID)
				AND (p_EDC_ID = g_NA_BRANCH OR B.EDC_ID = p_EDC_ID)
				AND (p_ESP_ID = g_NA_BRANCH OR B.ESP_ID = p_ESP_ID)
				AND (p_PSE_ID = g_NA_BRANCH OR B.PSE_ID = p_PSE_ID)
				AND (p_POOL_ID = g_NA_BRANCH OR D.POOL_ID = p_POOL_ID)
				AND C.MODEL_ID = p_MODEL_ID
				AND C.SCENARIO_ID in (p_SCENARIO_A_ID, p_SCENARIO_B_ID)
                AND C.SCENARIO_ID = E.SCENARIO_ID
				AND C.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
				AND C.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
				AND C.SERVICE_DELIVERY_ID = D.SERVICE_DELIVERY_ID
				AND C.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM SERVICE
					WHERE MODEL_ID = C.MODEL_ID
						AND SCENARIO_ID = C.SCENARIO_ID
						AND ACCOUNT_SERVICE_ID = C.ACCOUNT_SERVICE_ID
						AND PROVIDER_SERVICE_ID = C.PROVIDER_SERVICE_ID
						AND SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
						AND AS_OF_DATE <= v_AS_OF_DATE)
				AND F.SERVICE_ID = C.SERVICE_ID
				AND F.SERVICE_CODE = p_REQUEST_TYPE
				AND F.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND F.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
			GROUP BY FROM_CUT_AS_HED(F.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, F.LOAD_CODE), C.SCENARIO_ID, E.SCENARIO_NAME
			ORDER BY 2, 1;
    ELSE
		OPEN p_CURSOR FOR
			SELECT FROM_CUT_AS_HED(F.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, F.LOAD_CODE) "LOAD_DATE",
				C.SCENARIO_ID, E.SCENARIO_NAME,
				SUM(DECODE(p_INCLUDE_TD_LOSSES, 0 , LOAD_VAL, LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL)) "LOAD_VAL"
			FROM ACCOUNT_SERVICE A, PROVIDER_SERVICE B, SERVICE C, SERVICE_DELIVERY D, SERVICE_LOAD F, SCENARIO E
			WHERE A.ACCOUNT_ID = p_ACCOUNT_ID
				AND (v_SERVICE_LOCATION_ID = g_NA_NODE OR A.SERVICE_LOCATION_ID = v_SERVICE_LOCATION_ID)
				AND (p_METER_ID = g_NA_NODE OR A.METER_ID = p_METER_ID)
				AND (p_AGGREGATE_ID = g_NA_NODE OR A.AGGREGATE_ID = p_AGGREGATE_ID)
				AND (p_EDC_ID = g_NA_BRANCH OR B.EDC_ID = p_EDC_ID)
				AND (p_ESP_ID = g_NA_BRANCH OR B.ESP_ID = p_ESP_ID)
				AND (p_PSE_ID = g_NA_BRANCH OR B.PSE_ID = p_PSE_ID)
				AND (p_POOL_ID = g_NA_BRANCH OR D.POOL_ID = p_POOL_ID)
				AND C.MODEL_ID = p_MODEL_ID
				AND C.SCENARIO_ID in (p_SCENARIO_A_ID, p_SCENARIO_B_ID)
                AND C.SCENARIO_ID = E.SCENARIO_ID
				AND C.AS_OF_DATE = v_AS_OF_DATE
				AND C.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
				AND C.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
				AND C.SERVICE_DELIVERY_ID = D.SERVICE_DELIVERY_ID
				AND F.SERVICE_ID = C.SERVICE_ID
				AND F.SERVICE_CODE = p_REQUEST_TYPE
				AND F.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND F.LOAD_CODE IN (GA.STANDARD, GA.WEEK_DAY, GA.WEEK_END, GA.ANY_DAY)
			GROUP BY FROM_CUT_AS_HED(F.LOAD_DATE, p_TIME_ZONE, p_INTERVAL, p_MODEL_ID, F.LOAD_CODE), C.SCENARIO_ID, E.SCENARIO_NAME
			ORDER BY 2, 1;
	END IF;

	IF v_IS_CACHED THEN
		XS.RELEASE_USAGE(p_ACCOUNT_ID, v_SERVICE_LOCATION_ID, p_METER_ID, p_AGGREGATE_ID, p_BEGIN_DATE, p_END_DATE);
	END IF;

END LOAD_SCENCMP_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE REVENUE_SCENCMP_SUMMARY
	(
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_A_ID IN NUMBER,
	p_SCENARIO_B_ID IN NUMBER,
	p_SUMMARY_TYPE IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_INTERVAL IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_POSITION_TYPE CHAR(1);
v_SUMMARY_TYPE CHAR(1);
v_VERSION CHAR(1) := 1;
v_BEGIN_DATE DATE;
v_END_DATE DATE;

-- Hard coded so that the FROM_CUT_AS_HEAD will work properly with the daily data that returns
v_MODEL_ID NUMBER(1) := 2;
BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;
	SELECT DECODE(UPPER(SUBSTR(p_REQUEST_TYPE,1,1)),'F',1,'B',2,3) INTO v_POSITION_TYPE FROM DUAL;
	SELECT DECODE(UPPER(p_SUMMARY_TYPE),'EDC',1,'PSE',2,'ESP',3,'POOL',4,1) INTO v_SUMMARY_TYPE FROM DUAL;
	IF GA.VERSION_STATEMENT THEN v_VERSION := 2; END IF;

    UT.CUT_DATE_RANGE(v_MODEL_ID, p_BEGIN_DATE, p_END_DATE, GA.LOCAL_TIME_ZONE, p_INTERVAL, v_BEGIN_DATE, v_END_DATE);

	OPEN p_CURSOR FOR
		SELECT CHARGE_DATE, SCENARIO_ID, SCENARIO_NAME, DECODE(v_SUMMARY_TYPE, 1, B.EDC_NAME, 2, C.PSE_NAME, 3, D.ESP_NAME, 4, E.POOL_NAME) "NAME", REVENUE
		FROM
			(SELECT
				DECODE(v_SUMMARY_TYPE, 1, A.EDC_ID, CONSTANTS.NOT_ASSIGNED) "EDC_ID",
				DECODE(v_SUMMARY_TYPE, 2, A.PSE_ID, CONSTANTS.NOT_ASSIGNED) "PSE_ID",
				DECODE(v_SUMMARY_TYPE, 3, A.ESP_ID, CONSTANTS.NOT_ASSIGNED) "ESP_ID",
				DECODE(v_SUMMARY_TYPE, 4, C.POOL_ID, CONSTANTS.NOT_ASSIGNED) "POOL_ID",
				FROM_CUT_AS_HED(CHARGE_DATE, GA.LOCAL_TIME_ZONE, p_INTERVAL, v_MODEL_ID) "CHARGE_DATE",
				D.SCENARIO_ID "SCENARIO_ID", F.SCENARIO_NAME "SCENARIO_NAME",
				SUM(DECODE(E.PRODUCT_TYPE, 'R', E.CHARGE_AMOUNT, 0)) "REVENUE"
			FROM PROVIDER_SERVICE A, ACCOUNT_SERVICE B, SERVICE_DELIVERY C, SERVICE D, SERVICE_POSITION_CHARGE E, SCENARIO F
			WHERE D.MODEL_ID = p_MODEL_ID
				AND D.SCENARIO_ID IN (p_SCENARIO_A_ID, p_SCENARIO_B_ID)
				AND D.SCENARIO_ID = F.SCENARIO_ID
					AND ((v_VERSION = 1 AND D.AS_OF_DATE = CONSTANTS.LOW_DATE) OR
						 (D.AS_OF_DATE = (SELECT MAX(AS_OF_DATE) FROM SERVICE WHERE MODEL_ID = D.MODEL_ID AND SCENARIO_ID = D.SCENARIO_ID AND AS_OF_DATE <= D.AS_OF_DATE AND PROVIDER_SERVICE_ID = D.PROVIDER_SERVICE_ID AND ACCOUNT_SERVICE_ID = D.ACCOUNT_SERVICE_ID AND SERVICE_DELIVERY_ID = D.SERVICE_DELIVERY_ID)))
				AND D.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
				AND D.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
				AND D.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
				AND E.SERVICE_ID = D.SERVICE_ID
				AND E.POSITION_TYPE = v_POSITION_TYPE
				AND E.CHARGE_DATE BETWEEN TRUNC(p_BEGIN_DATE,'MONTH') AND LAST_DAY(p_END_DATE)
			GROUP BY DECODE(v_SUMMARY_TYPE, 1, A.EDC_ID, CONSTANTS.NOT_ASSIGNED),
				DECODE(v_SUMMARY_TYPE, 2, A.PSE_ID, CONSTANTS.NOT_ASSIGNED),
				DECODE(v_SUMMARY_TYPE, 3, A.ESP_ID, CONSTANTS.NOT_ASSIGNED),
				DECODE(v_SUMMARY_TYPE, 4, C.POOL_ID, CONSTANTS.NOT_ASSIGNED),
				FROM_CUT_AS_HED(CHARGE_DATE, GA.LOCAL_TIME_ZONE, p_INTERVAL, v_MODEL_ID), D.SCENARIO_ID, F.SCENARIO_NAME) A,
			ENERGY_DISTRIBUTION_COMPANY B, PURCHASING_SELLING_ENTITY C, ENERGY_SERVICE_PROVIDER D, POOL E
		WHERE B.EDC_ID = A.EDC_ID
			AND C.PSE_ID = A.PSE_ID
			AND D.ESP_ID = A.ESP_ID
			AND E.POOL_ID = A.POOL_ID
		ORDER BY 2, 1;

END REVENUE_SCENCMP_SUMMARY;
---------------------------------------------------------------------------------------------------
PROCEDURE COST_SCENCMP_SUMMARY
	(
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_A_ID IN NUMBER,
	p_SCENARIO_B_ID IN NUMBER,
	p_SUMMARY_TYPE IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_INTERVAL IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_POSITION_TYPE CHAR(1);
v_SUMMARY_TYPE CHAR(1);
v_VERSION CHAR(1) := 1;
v_BEGIN_DATE DATE;
v_END_DATE DATE;

-- Hard coded so that the FROM_CUT_AS_HEAD will work properly with the daily data that returns
v_MODEL_ID NUMBER(1) := 2;
BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;
	SELECT DECODE(UPPER(SUBSTR(p_REQUEST_TYPE,1,1)),'F',1,'B',2,3) INTO v_POSITION_TYPE FROM DUAL;
	SELECT DECODE(UPPER(p_SUMMARY_TYPE),'EDC',1,'PSE',2,'ESP',3,'POOL',4,1) INTO v_SUMMARY_TYPE FROM DUAL;
	IF GA.VERSION_STATEMENT THEN v_VERSION := 2; END IF;

  	UT.CUT_DATE_RANGE(v_MODEL_ID, p_BEGIN_DATE, p_END_DATE, GA.LOCAL_TIME_ZONE, p_INTERVAL, v_BEGIN_DATE, v_END_DATE);


	OPEN p_CURSOR FOR
		SELECT CHARGE_DATE, SCENARIO_ID, SCENARIO_NAME, DECODE(v_SUMMARY_TYPE, 1, B.EDC_NAME, 2, C.PSE_NAME, 3, D.ESP_NAME, 4, E.POOL_NAME) "NAME", COST
		FROM
			(SELECT
				DECODE(v_SUMMARY_TYPE, 1, A.EDC_ID, CONSTANTS.NOT_ASSIGNED) "EDC_ID",
				DECODE(v_SUMMARY_TYPE, 2, A.PSE_ID, CONSTANTS.NOT_ASSIGNED) "PSE_ID",
				DECODE(v_SUMMARY_TYPE, 3, A.ESP_ID, CONSTANTS.NOT_ASSIGNED) "ESP_ID",
				DECODE(v_SUMMARY_TYPE, 4, C.POOL_ID, CONSTANTS.NOT_ASSIGNED) "POOL_ID",
				FROM_CUT_AS_HED(CHARGE_DATE, GA.LOCAL_TIME_ZONE, p_INTERVAL, v_MODEL_ID) "CHARGE_DATE",
				D.SCENARIO_ID "SCENARIO_ID", F.SCENARIO_NAME "SCENARIO_NAME",
				SUM(DECODE(E.PRODUCT_TYPE, 'C', E.CHARGE_AMOUNT, 0)) "COST"
			FROM PROVIDER_SERVICE A, ACCOUNT_SERVICE B, SERVICE_DELIVERY C, SERVICE D, SERVICE_POSITION_CHARGE E, SCENARIO F
			WHERE D.MODEL_ID = p_MODEL_ID
				AND D.SCENARIO_ID IN (p_SCENARIO_A_ID, p_SCENARIO_B_ID)
				AND D.SCENARIO_ID = F.SCENARIO_ID
					AND ((v_VERSION = 1 AND D.AS_OF_DATE = CONSTANTS.LOW_DATE) OR
						 (D.AS_OF_DATE = (SELECT MAX(AS_OF_DATE) FROM SERVICE WHERE MODEL_ID = D.MODEL_ID AND SCENARIO_ID = D.SCENARIO_ID AND AS_OF_DATE <= D.AS_OF_DATE AND PROVIDER_SERVICE_ID = D.PROVIDER_SERVICE_ID AND ACCOUNT_SERVICE_ID = D.ACCOUNT_SERVICE_ID AND SERVICE_DELIVERY_ID = D.SERVICE_DELIVERY_ID)))
				AND D.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
				AND D.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
				AND D.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
				AND E.SERVICE_ID = D.SERVICE_ID
				AND E.POSITION_TYPE = v_POSITION_TYPE
				AND E.CHARGE_DATE BETWEEN TRUNC(p_BEGIN_DATE,'MONTH') AND LAST_DAY(p_END_DATE)
			GROUP BY DECODE(v_SUMMARY_TYPE, 1, A.EDC_ID, CONSTANTS.NOT_ASSIGNED),
				DECODE(v_SUMMARY_TYPE, 2, A.PSE_ID, CONSTANTS.NOT_ASSIGNED),
				DECODE(v_SUMMARY_TYPE, 3, A.ESP_ID, CONSTANTS.NOT_ASSIGNED),
				DECODE(v_SUMMARY_TYPE, 4, C.POOL_ID, CONSTANTS.NOT_ASSIGNED),
				FROM_CUT_AS_HED(CHARGE_DATE, GA.LOCAL_TIME_ZONE, p_INTERVAL, v_MODEL_ID), D.SCENARIO_ID, F.SCENARIO_NAME) A,
			ENERGY_DISTRIBUTION_COMPANY B, PURCHASING_SELLING_ENTITY C, ENERGY_SERVICE_PROVIDER D, POOL E
		WHERE B.EDC_ID = A.EDC_ID
			AND C.PSE_ID = A.PSE_ID
			AND D.ESP_ID = A.ESP_ID
			AND E.POOL_ID = A.POOL_ID
		ORDER BY 2, 1;

END COST_SCENCMP_SUMMARY;
---------------------------------------------------------------------------------------------------
PROCEDURE NETINCOME_SCENCMP_SUMMARY
	(
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_A_ID IN NUMBER,
	p_SCENARIO_B_ID IN NUMBER,
	p_SUMMARY_TYPE IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_INTERVAL IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_POSITION_TYPE CHAR(1);
v_SUMMARY_TYPE CHAR(1);
v_VERSION CHAR(1) := 1;
v_BEGIN_DATE DATE;
v_END_DATE DATE;

-- Hard coded so that the FROM_CUT_AS_HEAD will work properly with the daily data that returns
v_MODEL_ID NUMBER(1) := 2;
BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE)) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE(p_REQUEST_TYPE));
	END IF;

    p_STATUS := GA.SUCCESS;
	SELECT DECODE(UPPER(SUBSTR(p_REQUEST_TYPE,1,1)),'F',1,'B',2,3) INTO v_POSITION_TYPE FROM DUAL;
	SELECT DECODE(UPPER(p_SUMMARY_TYPE),'EDC',1,'PSE',2,'ESP',3,'POOL',4,1) INTO v_SUMMARY_TYPE FROM DUAL;
	IF GA.VERSION_STATEMENT THEN v_VERSION := 2; END IF;

	UT.CUT_DATE_RANGE(v_MODEL_ID, p_BEGIN_DATE, p_END_DATE, GA.LOCAL_TIME_ZONE, p_INTERVAL, v_BEGIN_DATE, v_END_DATE);

	OPEN p_CURSOR FOR
		SELECT CHARGE_DATE, SCENARIO_ID, SCENARIO_NAME, DECODE(v_SUMMARY_TYPE, 1, B.EDC_NAME, 2, C.PSE_NAME, 3, D.ESP_NAME, 4, E.POOL_NAME) "NAME", REVENUE - COST "NET INCOME"
		FROM
			(SELECT
				DECODE(v_SUMMARY_TYPE, 1, A.EDC_ID, CONSTANTS.NOT_ASSIGNED) "EDC_ID",
				DECODE(v_SUMMARY_TYPE, 2, A.PSE_ID, CONSTANTS.NOT_ASSIGNED) "PSE_ID",
				DECODE(v_SUMMARY_TYPE, 3, A.ESP_ID, CONSTANTS.NOT_ASSIGNED) "ESP_ID",
				DECODE(v_SUMMARY_TYPE, 4, C.POOL_ID, CONSTANTS.NOT_ASSIGNED) "POOL_ID",
				FROM_CUT_AS_HED(CHARGE_DATE, GA.LOCAL_TIME_ZONE, p_INTERVAL, v_MODEL_ID) "CHARGE_DATE",
				D.SCENARIO_ID "SCENARIO_ID", F.SCENARIO_NAME "SCENARIO_NAME",
				SUM(DECODE(E.PRODUCT_TYPE, 'C', E.CHARGE_AMOUNT, 0)) "COST",
				SUM(DECODE(E.PRODUCT_TYPE, 'R', E.CHARGE_AMOUNT, 0)) "REVENUE"
			FROM PROVIDER_SERVICE A, ACCOUNT_SERVICE B, SERVICE_DELIVERY C, SERVICE D, SERVICE_POSITION_CHARGE E, SCENARIO F
			WHERE D.MODEL_ID = p_MODEL_ID
				AND D.SCENARIO_ID IN (p_SCENARIO_A_ID, p_SCENARIO_B_ID)
				AND D.SCENARIO_ID = F.SCENARIO_ID
					AND ((v_VERSION = 1 AND D.AS_OF_DATE = CONSTANTS.LOW_DATE) OR
						 (D.AS_OF_DATE = (SELECT MAX(AS_OF_DATE) FROM SERVICE WHERE MODEL_ID = D.MODEL_ID AND SCENARIO_ID = D.SCENARIO_ID AND AS_OF_DATE <= D.AS_OF_DATE AND PROVIDER_SERVICE_ID = D.PROVIDER_SERVICE_ID AND ACCOUNT_SERVICE_ID = D.ACCOUNT_SERVICE_ID AND SERVICE_DELIVERY_ID = D.SERVICE_DELIVERY_ID)))
				AND D.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
				AND D.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
				AND D.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
				AND E.SERVICE_ID = D.SERVICE_ID
				AND E.POSITION_TYPE = v_POSITION_TYPE
				AND E.CHARGE_DATE BETWEEN TRUNC(p_BEGIN_DATE,'MONTH') AND LAST_DAY(p_END_DATE)
			GROUP BY DECODE(v_SUMMARY_TYPE, 1, A.EDC_ID, CONSTANTS.NOT_ASSIGNED),
				DECODE(v_SUMMARY_TYPE, 2, A.PSE_ID, CONSTANTS.NOT_ASSIGNED),
				DECODE(v_SUMMARY_TYPE, 3, A.ESP_ID, CONSTANTS.NOT_ASSIGNED),
				DECODE(v_SUMMARY_TYPE, 4, C.POOL_ID, CONSTANTS.NOT_ASSIGNED),
				FROM_CUT_AS_HED(CHARGE_DATE, GA.LOCAL_TIME_ZONE, p_INTERVAL, v_MODEL_ID), D.SCENARIO_ID, F.SCENARIO_NAME) A,
			ENERGY_DISTRIBUTION_COMPANY B, PURCHASING_SELLING_ENTITY C, ENERGY_SERVICE_PROVIDER D, POOL E
		WHERE B.EDC_ID = A.EDC_ID
			AND C.PSE_ID = A.PSE_ID
			AND D.ESP_ID = A.ESP_ID
			AND E.POOL_ID = A.POOL_ID
		ORDER BY 2, 1;

END NETINCOME_SCENCMP_SUMMARY;
---------------------------------------------------------------------------------------------------
PROCEDURE SETTLEMENT_TYPES
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the defined settlement types
-- and their corresponding codes and other data.

BEGIN

	IF NOT CAN_READ(MODULE_FOR_REQUEST_TYPE('B')) THEN
		ERRS.RAISE_NO_READ_MODULE(MODULE_FOR_REQUEST_TYPE('B'));
	END IF;

    p_STATUS := GA.SUCCESS;

    OPEN p_CURSOR FOR
 		SELECT SETTLEMENT_TYPE_NAME, SETTLEMENT_TYPE_ID, SERVICE_CODE,
			A.SCENARIO_ID, B.SCENARIO_NAME, A.STATEMENT_TYPE_ID, C.STATEMENT_TYPE_NAME
		FROM SETTLEMENT_TYPE A, SCENARIO B, STATEMENT_TYPE C
		WHERE A.SCENARIO_ID = B.SCENARIO_ID
			AND A.STATEMENT_TYPE_ID = C.STATEMENT_TYPE_ID
		ORDER BY SETTLEMENT_TYPE_ORDER;

END SETTLEMENT_TYPES;
---------------------------------------------------------------------------------------------------
FUNCTION EXPAND_SVC_STATE_PROFILE_TYPE
	(
	p_PROFILE_TYPE IN CHAR
	) RETURN VARCHAR2 IS
BEGIN
	RETURN CASE p_PROFILE_TYPE
			WHEN FS.g_HISTORICAL_PROFILE THEN c_PROFILE_TYPE_HISTORICAL
			WHEN FS.g_WRF_PROFILE THEN c_PROFILE_TYPE_WRF
			WHEN FS.g_USAGE_WRF_PROFILE THEN c_PROFILE_TYPE_USAGE_WRF
			WHEN FS.g_CUSTOMER_USAGE_WRF_PROFILE THEN c_PROFILE_TYPE_CUST_USAGE_WRF
			WHEN FS.g_INDEXED_PROFILE THEN c_PROFILE_TYPE_WEATHER_INDEXED
			WHEN FS.g_TYPICAL_PROFILE THEN c_PROFILE_TYPE_TYPICAL_DAY
			WHEN FS.g_COMPOSITE_PROFILE THEN c_PROFILE_TYPE_COMPOSITE
			WHEN FS.g_EXTERNAL_PROFILE THEN c_PROFILE_TYPE_EXTERNAL
			WHEN FS.g_ZERO_PROFILE THEN c_PROFILE_TYPE_ZERO
			WHEN FS.g_ACTUAL_USAGE_PROFILE THEN c_PROFILE_TYPE_ACTUAL_USAGE
			WHEN FS.g_PROXY_USAGE_PROFILE THEN c_PROFILE_TYPE_PROXY_DAY
			ELSE CONSTANTS.UNDEFINED_ATTRIBUTE
			END;
END EXPAND_SVC_STATE_PROFILE_TYPE;
---------------------------------------------------------------------------------------------------
FUNCTION DETERMINE_SVC_STATE_PROF_TYPE
	(
	p_PROFILE_TYPE_DESC IN VARCHAR2
	) RETURN CHAR IS
BEGIN
	RETURN CASE p_PROFILE_TYPE_DESC
			WHEN c_PROFILE_TYPE_HISTORICAL THEN FS.g_HISTORICAL_PROFILE
			WHEN c_PROFILE_TYPE_WRF THEN FS.g_WRF_PROFILE
			WHEN c_PROFILE_TYPE_USAGE_WRF THEN FS.g_USAGE_WRF_PROFILE
			WHEN c_PROFILE_TYPE_CUST_USAGE_WRF THEN FS.g_CUSTOMER_USAGE_WRF_PROFILE
			WHEN c_PROFILE_TYPE_WEATHER_INDEXED THEN FS.g_INDEXED_PROFILE
			WHEN c_PROFILE_TYPE_TYPICAL_DAY THEN FS.g_TYPICAL_PROFILE
			WHEN c_PROFILE_TYPE_COMPOSITE THEN FS.g_COMPOSITE_PROFILE
			WHEN c_PROFILE_TYPE_EXTERNAL THEN FS.g_EXTERNAL_PROFILE
			WHEN c_PROFILE_TYPE_ZERO THEN FS.g_ZERO_PROFILE
			WHEN c_PROFILE_TYPE_ACTUAL_USAGE THEN FS.g_ACTUAL_USAGE_PROFILE
			WHEN c_PROFILE_TYPE_PROXY_DAY THEN FS.g_PROXY_USAGE_PROFILE
			ELSE CONSTANTS.UNDEFINED_ATTRIBUTE
			END;
END DETERMINE_SVC_STATE_PROF_TYPE;
---------------------------------------------------------------------------------------------------
PROCEDURE SEARCH_ACCOUNT_SERVICE
	(
	p_SEARCH_STRING IN VARCHAR2,
	p_SEARCH_OPTION IN VARCHAR2,
	p_SEARCH_OPTION_NAME OUT VARCHAR2,
	p_WORK_ID OUT NUMBER
	) AS
v_SEARCH_STRING VARCHAR2(4000) := p_SEARCH_STRING;
v_CATEGORY_ID	NUMBER(9);
BEGIN
	UT.GET_RTO_WORK_ID(p_WORK_ID);

	-- just strip off "By " prefix of search option
	p_SEARCH_OPTION_NAME := SUBSTR(p_SEARCH_OPTION,4);

	-- simple search string? then search for this string anywhere in the search field
	IF INSTR(v_SEARCH_STRING,'%') = 0 AND INSTR(v_SEARCH_STRING,'_') = 0 THEN
		v_SEARCH_STRING := '%'||v_SEARCH_STRING||'%';
	END IF;

	IF SUBSTR(p_SEARCH_OPTION,1,LENGTH(c_PREFIX_SEARCH_OPTION_ACCT)) = c_PREFIX_SEARCH_OPTION_ACCT THEN

		-- search account service using account fields
		INSERT INTO RTO_WORK(WORK_ID, WORK_XID, WORK_DATA)
		SELECT p_WORK_ID,
			ASVC.ACCOUNT_SERVICE_ID,
			CASE p_SEARCH_OPTION
				WHEN c_SEARCH_OPTION_ACCT_NAME THEN A.ACCOUNT_NAME
				WHEN c_SEARCH_OPTION_ACCT_DISP_NAME THEN A.ACCOUNT_DISPLAY_NAME
				WHEN c_SEARCH_OPTION_ACCT_ALIAS THEN A.ACCOUNT_ALIAS
				WHEN c_SEARCH_OPTION_ACCT_EXTID THEN A.ACCOUNT_EXTERNAL_IDENTIFIER
				ELSE NULL END
		FROM ACCOUNT A,
			ACCOUNT_SERVICE ASVC
		WHERE ( (A.ACCOUNT_NAME LIKE v_SEARCH_STRING AND p_SEARCH_OPTION = c_SEARCH_OPTION_ACCT_NAME)
				OR (A.ACCOUNT_DISPLAY_NAME LIKE v_SEARCH_STRING AND p_SEARCH_OPTION = c_SEARCH_OPTION_ACCT_DISP_NAME)
				OR (A.ACCOUNT_ALIAS LIKE v_SEARCH_STRING AND p_SEARCH_OPTION = c_SEARCH_OPTION_ACCT_ALIAS)
				OR (A.ACCOUNT_EXTERNAL_IDENTIFIER LIKE v_SEARCH_STRING AND p_SEARCH_OPTION = c_SEARCH_OPTION_ACCT_EXTID)
			)
			AND ASVC.ACCOUNT_ID = A.ACCOUNT_ID;

	ELSIF SUBSTR(p_SEARCH_OPTION,1,LENGTH(c_PREFIX_SEARCH_OPTION_SVC_LOC)) = c_PREFIX_SEARCH_OPTION_SVC_LOC THEN

		-- search account service using service location fields
		SELECT MAX(CATEGORY_ID)
		INTO v_CATEGORY_ID -- find category for looking up service location street address
		FROM CATEGORY
		WHERE CATEGORY_NAME = 'Locale';

		INSERT INTO RTO_WORK(WORK_ID, WORK_XID, WORK_DATA)
		SELECT p_WORK_ID,
			ASVC.ACCOUNT_SERVICE_ID,
			CASE p_SEARCH_OPTION
				WHEN c_SEARCH_OPTION_SVC_LOC_NAME THEN SL.SERVICE_LOCATION_NAME
				WHEN c_SEARCH_OPTION_SVC_LOC_ALIAS THEN SL.SERVICE_LOCATION_ALIAS
				WHEN c_SEARCH_OPTION_SVC_LOC_EXTID THEN SL.EXTERNAL_IDENTIFIER
				WHEN c_SEARCH_OPTION_SVC_LOC_ADDR THEN EDA.STREET
				ELSE NULL END
		FROM SERVICE_LOCATION SL,
			ENTITY_DOMAIN_ADDRESS EDA,
			ACCOUNT_SERVICE ASVC
		WHERE EDA.ENTITY_DOMAIN_ID(+) = EC.ED_SERVICE_LOCATION
			AND EDA.OWNER_ENTITY_ID(+) = SL.SERVICE_LOCATION_ID
			AND EDA.CATEGORY_ID(+) = v_CATEGORY_ID
			AND	( (SL.SERVICE_LOCATION_NAME LIKE v_SEARCH_STRING AND p_SEARCH_OPTION = c_SEARCH_OPTION_SVC_LOC_NAME)
				OR (SL.SERVICE_LOCATION_ALIAS LIKE v_SEARCH_STRING AND p_SEARCH_OPTION = c_SEARCH_OPTION_SVC_LOC_ALIAS)
				OR (SL.EXTERNAL_IDENTIFIER LIKE v_SEARCH_STRING AND p_SEARCH_OPTION = c_SEARCH_OPTION_SVC_LOC_EXTID)
				OR (EDA.STREET LIKE v_SEARCH_STRING AND p_SEARCH_OPTION = c_SEARCH_OPTION_SVC_LOC_ADDR)
			)
			AND ASVC.SERVICE_LOCATION_ID = SL.SERVICE_LOCATION_ID;

	ELSIF SUBSTR(p_SEARCH_OPTION,1,LENGTH(c_PREFIX_SEARCH_OPTION_METER)) = c_PREFIX_SEARCH_OPTION_METER THEN

		-- search account service using meter fields
		-- First, search meters
		INSERT INTO RTO_WORK(WORK_ID, WORK_XID, WORK_DATA)
		SELECT p_WORK_ID,
			ASVC.ACCOUNT_SERVICE_ID,
			CASE p_SEARCH_OPTION
				WHEN c_SEARCH_OPTION_METER_NAME THEN M.METER_NAME
				WHEN c_SEARCH_OPTION_METER_ALIAS THEN M.METER_ALIAS
				WHEN c_SEARCH_OPTION_METER_EXTID THEN M.METER_EXTERNAL_IDENTIFIER
				ELSE NULL END
		FROM METER M,
			ACCOUNT_SERVICE ASVC
		WHERE ( (M.METER_NAME LIKE v_SEARCH_STRING AND p_SEARCH_OPTION = c_SEARCH_OPTION_METER_NAME)
				OR (M.METER_ALIAS LIKE v_SEARCH_STRING AND p_SEARCH_OPTION = c_SEARCH_OPTION_METER_ALIAS)
				OR (M.METER_EXTERNAL_IDENTIFIER LIKE v_SEARCH_STRING AND p_SEARCH_OPTION = c_SEARCH_OPTION_METER_EXTID)
			)
			AND ASVC.METER_ID = M.METER_ID;

		-- Then, search account-modeled accounts for meter external identifiers
		IF p_SEARCH_OPTION = c_SEARCH_OPTION_METER_EXTID THEN
			INSERT INTO RTO_WORK(WORK_ID, WORK_XID, WORK_DATA)
			SELECT p_WORK_ID,
				ASVC.ACCOUNT_SERVICE_ID,
				A.ACCOUNT_METER_EXT_IDENTIFIER
			FROM ACCOUNT A,
				ACCOUNT_SERVICE ASVC
			WHERE A.ACCOUNT_MODEL_OPTION = 'Account'
				AND A.ACCOUNT_METER_EXT_IDENTIFIER LIKE v_SEARCH_STRING
				AND ASVC.ACCOUNT_ID = A.ACCOUNT_ID
				AND ASVC.METER_ID = CONSTANTS.NOT_ASSIGNED;
		END IF;
	ELSE
		ERRS.RAISE_BAD_ARGUMENT('Search Option', p_SEARCH_OPTION, 'Unsupported search option');
	END IF;

END SEARCH_ACCOUNT_SERVICE;
---------------------------------------------------------------------------------------------------
PROCEDURE SERVICE_STATE_REPORT
	(
	p_SEARCH_STRING IN VARCHAR2,
	p_SEARCH_OPTION IN VARCHAR2,
	p_SETTLEMENT_TYPE_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_PROFILE_TYPE IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SEARCH_OPTION_NAME OUT VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_PROF_TYPE		VARCHAR2(16) := DETERMINE_SVC_STATE_PROF_TYPE(p_PROFILE_TYPE);
v_WORK_ID		NUMBER(9);
v_SERVICE_CODE	CHAR(1);
v_SCENARIO_ID	NUMBER(9);
BEGIN

	ASSERT(UT.STRING_COLLECTION_CONTAINS(c_ALLOWED_SEARCH_OPTIONS, p_SEARCH_OPTION),
			'Unsupported search option: '||p_SEARCH_OPTION,
			MSGCODES.c_ERR_ARGUMENT);

	-- determine service code and scenario
	IF NVL(p_SETTLEMENT_TYPE_ID,CONSTANTS.NOT_ASSIGNED) = CONSTANTS.NOT_ASSIGNED THEN
		v_SERVICE_CODE := GA.FORECAST_SERVICE;
		v_SCENARIO_ID := NVL(p_SCENARIO_ID, GA.BASE_SCENARIO_ID);
	ELSE
		SELECT SERVICE_CODE, SCENARIO_ID
		INTO v_SERVICE_CODE, v_SCENARIO_ID
		FROM SETTLEMENT_TYPE
		WHERE SETTLEMENT_TYPE_ID = p_SETTLEMENT_TYPE_ID;
	END IF;

	-- now for the report
	BEGIN
		-- find matching ACCOUNT_SERVICE records and store ID in RTO_WORK
		SEARCH_ACCOUNT_SERVICE(p_SEARCH_STRING, p_SEARCH_OPTION, p_SEARCH_OPTION_NAME, v_WORK_ID);

		-- now query
		OPEN p_CURSOR FOR
			SELECT ST.SERVICE_DATE,
				-- don't need to show search match if search option was by account, svc loc, or meter name
				CASE WHEN p_SEARCH_OPTION IN (c_SEARCH_OPTION_ACCT_NAME,c_SEARCH_OPTION_SVC_LOC_NAME,c_SEARCH_OPTION_METER_NAME) THEN NULL ELSE W.WORK_DATA END as SEARCH_MATCH,
				A.ACCOUNT_ID,
				A.ACCOUNT_NAME,
				SL.SERVICE_LOCATION_ID,
				SL.SERVICE_LOCATION_NAME,
				M.METER_ID,
				-- don't show meter name if there isn't one
				CASE WHEN M.METER_ID = CONSTANTS.NOT_ASSIGNED THEN NULL ELSE M.METER_NAME END as METER_NAME,
				ESP.ESP_ID,
				ESP.ESP_NAME,
				P.POOL_ID,
				-- don't show meter name if there isn't one
				CASE WHEN P.POOL_ID = CONSTANTS.NOT_ASSIGNED THEN NULL ELSE P.POOL_NAME END as POOL_NAME,
				-- service state results:
				ST.IS_UFE_PARTICIPANT,
				ST.SERVICE_ACCOUNTS,
				ST.METER_TYPE,
				ST.IS_EXTERNAL_FORECAST,
				ST.IS_AGGREGATE_ACCOUNT,
				ST.IS_AGGREGATE_POOL,
				ST.PROFILE_TYPE,
				ST.PROFILE_SOURCE_DATE,
				PDM.PROXY_DAY_METHOD_ID,
				PDM.PROXY_DAY_METHOD_NAME,
				ST.USAGE_FACTOR,
				ST.SERVICE_INTERVALS
			FROM RTO_WORK W,
				SERVICE SVC,
				SERVICE_STATE ST,
				ACCOUNT_SERVICE ASVC,
				ACCOUNT A,
				SERVICE_LOCATION SL,
				METER M,
				PROVIDER_SERVICE PSVC,
				ENERGY_SERVICE_PROVIDER ESP,
				SERVICE_DELIVERY SVCD,
				POOL P,
				PROXY_DAY_METHOD PDM
			WHERE W.WORK_ID = v_WORK_ID
				AND SVC.ACCOUNT_SERVICE_ID = W.WORK_XID
				AND SVC.MODEL_ID = GA.DEFAULT_MODEL
				AND SVC.SCENARIO_ID = v_SCENARIO_ID
				AND SVC.AS_OF_DATE = CONSTANTS.LOW_DATE
				AND ST.SERVICE_ID = SVC.SERVICE_ID
				AND ST.SERVICE_CODE = v_SERVICE_CODE
				AND ST.SERVICE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
				AND ASVC.ACCOUNT_SERVICE_ID = SVC.ACCOUNT_SERVICE_ID
				AND A.ACCOUNT_ID = ASVC.ACCOUNT_ID
				AND SL.SERVICE_LOCATION_ID = NVL(ASVC.SERVICE_LOCATION_ID, CONSTANTS.NOT_ASSIGNED)
				AND M.METER_ID = NVL(ASVC.METER_ID, CONSTANTS.NOT_ASSIGNED)
				AND PSVC.PROVIDER_SERVICE_ID = SVC.PROVIDER_SERVICE_ID
				AND ESP.ESP_ID = PSVC.ESP_ID
				AND SVCD.SERVICE_DELIVERY_ID = SVC.SERVICE_DELIVERY_ID
				AND P.POOL_ID = NVL(SVCD.POOL_ID, CONSTANTS.NOT_ASSIGNED)
				AND PDM.PROXY_DAY_METHOD_ID(+) = ST.PROXY_DAY_METHOD_ID
			ORDER BY 1, -- SERVICE_DATE
					 2, -- SEARCH_MATCH
					 4, -- ACCOUNT_NAME
					 6, -- SERVICE_LOCATION_NAME
					 8, -- METER_NAME
					10, -- ESP_NAME
					12; -- POOL_NAME

		UT.PURGE_RTO_WORK(v_WORK_ID);

	EXCEPTION
		WHEN OTHERS THEN
			BEGIN
				UT.PURGE_RTO_WORK(v_WORK_ID);
			EXCEPTION
				WHEN OTHERS THEN
					ERRS.LOG_AND_CONTINUE;
			END;
			ERRS.LOG_AND_RAISE;
	END;

END SERVICE_STATE_REPORT;
---------------------------------------------------------------------------------------------------
END QC;
/
