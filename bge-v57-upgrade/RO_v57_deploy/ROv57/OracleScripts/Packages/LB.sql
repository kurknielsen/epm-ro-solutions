CREATE OR REPLACE PACKAGE LB IS
--Revision $Revision: 1.10 $

-- Load Balancing

FUNCTION WHAT_VERSION RETURN VARCHAR;

PROCEDURE BALANCE_TRANSACTION_NAMES
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE BALANCE_SALE_NAMES
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE BALANCE_SUPPLY_NAMES
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE GET_BALANCE_LOAD_REPORT
	(
	p_BALANCE_TRANSACTION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
    p_SCHEDULE_TYPE IN NUMBER,
    p_AS_OF_DATE IN DATE,
	p_UPDATE_DEMAND IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_BALANCE_SUPPLY_REPORT
	(
	p_SUPPLY_TRANSACTION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
    p_SCHEDULE_TYPE IN NUMBER,
    p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE PUT_BALANCE_REPORT
	(
	p_SUPPLY_TRANSACTION_ID IN NUMBER,
	p_BALANCE_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
    p_SCHEDULE_DATE IN VARCHAR,
    p_SCHEDULE_TIME IN VARCHAR,
    p_DISP_SCHEDULED IN NUMBER,
    p_SUPPLY_PRICE IN NUMBER,
    p_ASSIGNED_AMOUNT IN NUMBER,
	p_IS_FIXED IN NUMBER,
	p_UPDATE_DEMAND IN NUMBER,
	p_DEMAND_AMOUNT IN NUMBER,
	p_IMBALANCE_PRICE IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_DYNAMIC_SCHEDULE_LIST
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_LOAD_TRANSACTION_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE GET_DEAL_EVAL_SUMMARY
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_LOAD_TRANSACTION_ID IN NUMBER,
	p_DYNAMIC_TRANSACTION_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PUT_DEAL_EVAL_NOTES
	(
	p_LOAD_TRANSACTION_ID IN NUMBER,
	p_DYNAMIC_TRANSACTION_ID IN NUMBER,
	p_SUPPLY_TRANSACTION_ID IN NUMBER,
	p_NOTES IN VARCHAR2,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_DEAL_EVAL_DETAILS
	(
	p_CUT_BEGIN_DATE IN DATE,
	p_CUT_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_LOAD_TRANSACTION_ID IN NUMBER,
	p_DYNAMIC_TRANSACTION_ID IN NUMBER,
	p_SUPPLY_TRANSACTION_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE EVALUATE_DEALS
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_LOAD_TRANSACTION_ID IN NUMBER,
	p_DYNAMIC_TRANSACTION_ID IN NUMBER,
	p_SUPPLY_TRANSACTION_IDs IN VARCHAR2,
	p_STATUS OUT NUMBER
	);

PROCEDURE COMMIT_DEAL_EVAL
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_LOAD_TRANSACTION_ID IN NUMBER,
	p_DYNAMIC_TRANSACTION_ID IN NUMBER,
	p_SUPPLY_TRANSACTION_ID IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE UNDO_DEAL_EVAL
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_LOAD_TRANSACTION_ID IN NUMBER,
	p_DYNAMIC_TRANSACTION_ID IN NUMBER,
	p_SUPPLY_TRANSACTION_ID IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE REJECT_DEAL_EVAL
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_LOAD_TRANSACTION_ID IN NUMBER,
	p_DYNAMIC_TRANSACTION_ID IN NUMBER,
	p_SUPPLY_TRANSACTION_ID IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE RESTORE_DEAL_EVAL
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_LOAD_TRANSACTION_ID IN NUMBER,
	p_DYNAMIC_TRANSACTION_ID IN NUMBER,
	p_SUPPLY_TRANSACTION_ID IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_DEAL_EVAL_TRANSACTIONS
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_LOAD_TRANSACTION_ID IN NUMBER,
	p_DYNAMIC_TRANSACTION_ID IN NUMBER,
	p_IDs OUT ID_TABLE
	);

PROCEDURE GET_DEAL_EVAL_DATE_RANGE
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_LOAD_TRANSACTION_ID IN NUMBER,
	p_DYNAMIC_TRANSACTION_ID IN NUMBER,
	p_SUPPLY_TRANSACTION_IDs IN ID_TABLE,
	p_OUT_BEGIN_DATE OUT DATE,
	p_OUT_END_DATE OUT DATE
	);

PROCEDURE GET_LIMITS
	(
	p_SCHEDULE_DATE IN DATE,
	p_LOCAL_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_TRANSACTION_ID IN NUMBER,
	p_IS_FIXED IN NUMBER,
	p_MAX OUT NUMBER,
	p_MIN OUT NUMBER,
	p_PRICE OUT NUMBER
	);

PROCEDURE DEFAULT_EVALUATION
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_LOAD_TRANSACTION_ID IN NUMBER,
	p_DYNAMIC_TRANSACTION_ID IN NUMBER,
	p_SUPPLY_TRANSACTION_ID IN NUMBER,
	p_OPTION_ID IN NUMBER
	);

g_STATUS_PENDING VARCHAR2(32) := 'Pending';
g_STATUS_COMMITTED VARCHAR2(32) := 'Committed';
g_STATUS_REJECTED VARCHAR2(32) := 'Rejected';
-- special status that indicates current row is being evaluated
g_STATUS_EVALUATING VARCHAR2(32) := 'Evaluating';

g_BALANCING_ASSIGNMENT_TYPE VARCHAR2(32) := 'LoadBalancing';

END LB;
/
CREATE OR REPLACE PACKAGE BODY LB IS
----------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
    RETURN '$Revision: 1.10 $';
END WHAT_VERSION;
----------------------------------------------------------------------------------------------------
PROCEDURE NULL_CURSOR
    (
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
		SELECT NULL FROM DUAL;

END NULL_CURSOR;
---------------------------------------------------------------------------------------------------
FUNCTION USING_TOTAL_OBL
	RETURN NUMBER IS
v_RET NUMBER;
BEGIN
	-- Are we supporting "total obligation" loads?
	RETURN NVL(GET_DICTIONARY_VALUE('Allow Total Obligation',1,'Scheduling','Load Balancing'), 0);
	-- this needs to be a zero or one
EXCEPTION
	WHEN OTHERS THEN
		RETURN 0; -- error reading flag from dictionary? then assume no "total obligation" support...
END USING_TOTAL_OBL;
---------------------------------------------------------------------------------------------------
FUNCTION GET_TOTAL_OBL_NAME
	RETURN VARCHAR2 IS
v_TOTAL_OBL_NAME VARCHAR2(128);
BEGIN
	-- A total obligation transaction is any Load balance transaction that has Sales balance
	-- transactions linked to it (via LINK_TRANSACTION_ID field of the Sales).
	-- This volume reported for these transactions includes the load value as well as the sum of all
	-- linked sales.
	v_TOTAL_OBL_NAME := GET_DICTIONARY_VALUE('Total Obligation Name',1,'Scheduling','Load Balancing');
	IF v_TOTAL_OBL_NAME IS NULL THEN
		-- default is to just append "(incl. sales)" to the transaction name
		-- the @ character indicates to substitute the actual transaction's name
		v_TOTAL_OBL_NAME := '@ (incl. Sales)';
	END IF;

	RETURN v_TOTAL_OBL_NAME;
END GET_TOTAL_OBL_NAME;
---------------------------------------------------------------------------------------------------
PROCEDURE BALANCE_TRANSACTION_NAMES
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
v_TOTAL_OBL_NAME VARCHAR2(128) := GET_TOTAL_OBL_NAME;
v_USING_TOTAL_OBL NUMBER := USING_TOTAL_OBL;
BEGIN

	IF NOT CAN_READ(ITJ.g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(ITJ.g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		-- normal loads
		SELECT TRANSACTION_NAME, A.TRANSACTION_ID
		FROM INTERCHANGE_TRANSACTION A, IT_STATUS B
		WHERE BEGIN_DATE <= p_END_DATE
			AND END_DATE >= p_BEGIN_DATE
			AND IS_BALANCE_TRANSACTION = 1
			AND UPPER(SUBSTR(TRANSACTION_TYPE,1,2)) IN ('RE','LO')
			AND B.TRANSACTION_ID = A.TRANSACTION_ID
			AND B.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
								FROM IT_STATUS
								WHERE TRANSACTION_ID = B.TRANSACTION_ID)
			AND B.TRANSACTION_IS_ACTIVE = 1
			AND (v_USING_TOTAL_OBL = 0
					OR
				 0 = (SELECT COUNT(*)
					 	FROM INTERCHANGE_TRANSACTION T
                		WHERE T.IS_BALANCE_TRANSACTION = 0
                			AND UPPER(SUBSTR(T.TRANSACTION_TYPE,1,2)) IN ('RE','LO','SA')
							AND T.LINK_TRANSACTION_ID = A.TRANSACTION_ID))
		UNION ALL
		-- "total obligation" loads
		SELECT REPLACE(v_TOTAL_OBL_NAME, '@', TRANSACTION_NAME) TRANSACTION_NAME, A.TRANSACTION_ID
		FROM INTERCHANGE_TRANSACTION A, IT_STATUS B
		WHERE BEGIN_DATE <= p_END_DATE
			AND END_DATE >= p_BEGIN_DATE
			AND IS_BALANCE_TRANSACTION = 1
			AND UPPER(SUBSTR(TRANSACTION_TYPE,1,2)) IN ('RE','LO')
			AND B.TRANSACTION_ID = A.TRANSACTION_ID
			AND B.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
								FROM IT_STATUS
								WHERE TRANSACTION_ID = B.TRANSACTION_ID)
			AND B.TRANSACTION_IS_ACTIVE = 1
			AND v_USING_TOTAL_OBL = 1
			AND 0 < (SELECT COUNT(*)
					 	FROM INTERCHANGE_TRANSACTION T
                		WHERE T.IS_BALANCE_TRANSACTION = 0
                			AND UPPER(SUBSTR(T.TRANSACTION_TYPE,1,2)) IN ('RE','LO','SA')
							AND T.LINK_TRANSACTION_ID = A.TRANSACTION_ID)
		ORDER BY 1, 2;

	EXCEPTION
		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END BALANCE_TRANSACTION_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE BALANCE_SALE_NAMES
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
BEGIN

	IF NOT CAN_READ(ITJ.g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(ITJ.g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT TRANSACTION_NAME, A.TRANSACTION_ID
		FROM INTERCHANGE_TRANSACTION A, IT_STATUS B
		WHERE A.BEGIN_DATE <= p_END_DATE
			AND A.END_DATE >= p_BEGIN_DATE
			AND A.IS_BALANCE_TRANSACTION = 1
			AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) = 'SA'
			AND B.TRANSACTION_ID = A.TRANSACTION_ID
			AND B.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
								FROM IT_STATUS
								WHERE TRANSACTION_ID = B.TRANSACTION_ID)
			AND B.TRANSACTION_IS_ACTIVE = 1
		ORDER BY 1, 2;

	EXCEPTION
		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END BALANCE_SALE_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE BALANCE_SUPPLY_NAMES
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
BEGIN

	IF NOT CAN_READ(ITJ.g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(ITJ.g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT DISTINCT B.TRANSACTION_NAME, B.TRANSACTION_ID
		FROM IT_ASSIGNMENT A, IT_ASSIGNMENT_PERIOD P,
			INTERCHANGE_TRANSACTION B, IT_STATUS C
		WHERE A.ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE
			AND P.ASSIGNMENT_ID = A.ASSIGNMENT_ID
			AND P.BEGIN_DATE <= p_END_DATE
			AND NVL(P.END_DATE,HIGH_DATE) >= p_BEGIN_DATE
			AND B.TRANSACTION_ID = A.FROM_TRANSACTION_ID
			AND B.BEGIN_DATE <= p_END_DATE
			AND B.END_DATE >= p_BEGIN_DATE
			AND C.TRANSACTION_ID = B.TRANSACTION_ID
			AND C.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
								FROM IT_STATUS
								WHERE TRANSACTION_ID = C.TRANSACTION_ID)
			AND C.TRANSACTION_IS_ACTIVE = 1
		ORDER BY 1, 2;

	EXCEPTION
		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END BALANCE_SUPPLY_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_BALANCE_LOAD_REPORT
	(
	p_BALANCE_TRANSACTION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
    p_SCHEDULE_TYPE IN NUMBER,
    p_AS_OF_DATE IN DATE,
	p_UPDATE_DEMAND IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_DEMAND_WORK_ID NUMBER;
v_SUPPLY_WORK_ID NUMBER;
v_TRANSACTION_NAME INTERCHANGE_TRANSACTION.TRANSACTION_NAME%TYPE;
v_SUPPLY_IDs ID_TABLE;
v_INTERVAL_NUMBER NUMBER;
v_TOTAL_OBL_NAME VARCHAR2(128) := GET_TOTAL_OBL_NAME;
v_USING_TOTAL_OBL NUMBER := USING_TOTAL_OBL;
CURSOR c_SALES_VOLS IS
	SELECT SCHEDULE_DATE,
		SUM(AMOUNT) "AMOUNT"
	FROM INTERCHANGE_TRANSACTION T,
		IT_SCHEDULE S
	WHERE T.LINK_TRANSACTION_ID = p_BALANCE_TRANSACTION_ID
		AND T.IS_BALANCE_TRANSACTION = 0
		AND UPPER(SUBSTR(T.TRANSACTION_TYPE,1,2)) IN ('RE', 'LO', 'SA')
		AND S.TRANSACTION_ID = T.TRANSACTION_ID
		AND S.SCHEDULE_TYPE = p_SCHEDULE_TYPE
		AND S.SCHEDULE_STATE = GA.INTERNAL_STATE
		AND S.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
	GROUP BY S.SCHEDULE_DATE;
BEGIN
	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, p_BEGIN_DATE, p_END_DATE);

	p_STATUS := GA.SUCCESS;

	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	SELECT TRANSACTION_NAME, GET_INTERVAL_NUMBER(TRANSACTION_INTERVAL)
	INTO v_TRANSACTION_NAME, v_INTERVAL_NUMBER
	FROM INTERCHANGE_TRANSACTION
	WHERE TRANSACTION_ID = p_BALANCE_TRANSACTION_ID;

	SELECT ID_TYPE(A.FROM_TRANSACTION_ID)
	BULK COLLECT INTO v_SUPPLY_IDs
	FROM IT_ASSIGNMENT A, IT_ASSIGNMENT_PERIOD B, IT_STATUS C
	WHERE A.TO_TRANSACTION_ID = p_BALANCE_TRANSACTION_ID
		AND A.ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE
		AND B.ASSIGNMENT_ID = A.ASSIGNMENT_ID
		AND B.BEGIN_DATE <= p_END_DATE
		AND NVL(B.END_DATE,HIGH_DATE) >= p_BEGIN_DATE
		AND C.TRANSACTION_ID = A.FROM_TRANSACTION_ID
		AND C.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
							FROM IT_STATUS
							WHERE TRANSACTION_ID = C.TRANSACTION_ID
								AND AS_OF_DATE <= p_AS_OF_DATE)
		AND C.TRANSACTION_IS_ACTIVE = 1;

	-- Populate IT_ASSIGNMENT_WORK for Demand
	IA.BUILD_WORK_DATA_TO(p_BALANCE_TRANSACTION_ID, v_BEGIN_DATE, v_END_DATE, p_SCHEDULE_TYPE, TRUE, v_DEMAND_WORK_ID);
	IF v_USING_TOTAL_OBL = 1 THEN
		-- update transaction name to indicate that it is a total obligation
		UPDATE IT_ASSIGNMENT_WORK SET
			TRANSACTION_NAME = REPLACE(v_TOTAL_OBL_NAME, '@', TRANSACTION_NAME)
		WHERE WORK_ID = v_DEMAND_WORK_ID
			AND TRANSACTION_ID = p_BALANCE_TRANSACTION_ID;
    	-- add in Sales volumes if this is a "total obligation" load
    	FOR v_SALES_VOL IN c_SALES_VOLS LOOP
    		UPDATE IT_ASSIGNMENT_WORK SET
    			AMOUNT = AMOUNT + v_SALES_VOL.AMOUNT
    		WHERE WORK_ID = v_DEMAND_WORK_ID
    			AND TRANSACTION_ID = p_BALANCE_TRANSACTION_ID
    			AND SCHEDULE_DATE = v_SALES_VOL.SCHEDULE_DATE;
    	END LOOP;
	END IF;

	-- Populate IT_ASSIGNMENT_WORK for Supply
	IA.BUILD_WORK_ASSIGNMENTS_FROM(p_BALANCE_TRANSACTION_ID, v_SUPPLY_IDs, v_BEGIN_DATE, v_END_DATE, p_TIME_ZONE, p_SCHEDULE_TYPE, g_BALANCING_ASSIGNMENT_TYPE, TRUE, v_SUPPLY_WORK_ID);

	-- Query
	OPEN p_CURSOR FOR
		SELECT SUBSTR(SDT.NO_ROLLUP_YYYY_MM_DD, 1, 10) "SCHEDULE_DATE",
				SUBSTR(SDT.NO_ROLLUP_YYYY_MM_DD, 12) "SCHEDULE_TIME",
				p_BALANCE_TRANSACTION_ID "BALANCE_TRANSACTION_ID",
				L.TRANSACTION_NAME "BALANCE_TRANSACTION_NAME",
				NVL(L.AMOUNT,0) "DEMAND_AMOUNT_OLD",
				L.OTHER_PRICE "IMBALANCE_PRICE",
				S.TRANSACTION_ID "SUPPLY_TRANSACTION_ID",
				S.TRANSACTION_NAME "SUPPLY_TRANSACTION_NAME",
				S.IS_FIXED,
				CASE WHEN S.IS_FIXED = 1 THEN S.AMOUNT ELSE NULL END "FIXED_SCHEDULED",
				CASE WHEN S.IS_FIXED = 1 THEN NULL ELSE S.TERM_MAX END "DISP_MAX",
				CASE WHEN S.IS_FIXED = 1 THEN NULL ELSE S.TERM_MIN END "DISP_MIN",
				CASE WHEN S.IS_FIXED = 1 THEN S.TOTAL_ASSIGNED ELSE NULL END "FIXED_TOTAL_ASSIGNED_OLD",
				CASE WHEN S.IS_FIXED = 1 THEN NULL ELSE S.AMOUNT END "DISP_SCHEDULED_OLD",
				S.PRICE "SUPPLY_PRICE",
				S.ASSIGNED "ASSIGNED_AMOUNT",
				S.ASSIGNED "ASSIGNED_AMOUNT_OLD",
				p_UPDATE_DEMAND "UPDATE_DEMAND"
		FROM SYSTEM_DATE_TIME SDT,
			IT_ASSIGNMENT_WORK L,
			IT_ASSIGNMENT_WORK S
		WHERE SDT.TIME_ZONE = p_TIME_ZONE
			AND SDT.DATA_INTERVAL_TYPE = 1
			AND SDT.DAY_TYPE = '1'
			AND SDT.CUT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND SDT.MINIMUM_INTERVAL_NUMBER >= v_INTERVAL_NUMBER
			AND L.WORK_ID(+) = v_DEMAND_WORK_ID
			AND L.SCHEDULE_DATE(+) = SDT.CUT_DATE
			AND S.WORK_ID(+) = v_SUPPLY_WORK_ID
			AND S.SCHEDULE_DATE(+) = SDT.CUT_DATE
		ORDER BY SDT.CUT_DATE, S.TRANSACTION_NAME;

	IA.PURGE_WORK(v_DEMAND_WORK_ID, v_SUPPLY_WORK_ID);

EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			IA.PURGE_WORK(v_DEMAND_WORK_ID, v_SUPPLY_WORK_ID);
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE();
		END;
		ERRS.LOG_AND_RAISE();

END GET_BALANCE_LOAD_REPORT;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_BALANCE_SUPPLY_REPORT
	(
	p_SUPPLY_TRANSACTION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
    p_SCHEDULE_TYPE IN NUMBER,
    p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_DEMAND_WORK_ID NUMBER;
v_SUPPLY_WORK_ID NUMBER;
v_TRANSACTION_NAME INTERCHANGE_TRANSACTION.TRANSACTION_NAME%TYPE;
v_DEMAND_IDs ID_TABLE;
v_INTERVAL_NUMBER NUMBER;
v_TOTAL_OBL_NAME VARCHAR2(128) := GET_TOTAL_OBL_NAME;
v_USING_TOTAL_OBL NUMBER := USING_TOTAL_OBL;
CURSOR c_SALES_VOLS IS
	SELECT SCHEDULE_DATE,
		X.ID "TRANSACTION_ID",
		SUM(AMOUNT) "AMOUNT"
	FROM TABLE(CAST(v_DEMAND_IDs AS ID_TABLE)) X,
		INTERCHANGE_TRANSACTION T,
		IT_SCHEDULE S
	WHERE T.LINK_TRANSACTION_ID = X.ID
		AND T.IS_BALANCE_TRANSACTION = 0
		AND UPPER(SUBSTR(T.TRANSACTION_TYPE,1,2)) IN ('RE', 'LO', 'SA')
		AND S.TRANSACTION_ID = T.TRANSACTION_ID
		AND S.SCHEDULE_TYPE = p_SCHEDULE_TYPE
		AND S.SCHEDULE_STATE = GA.INTERNAL_STATE
		AND S.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
	GROUP BY S.SCHEDULE_DATE, X.ID;
BEGIN
	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, p_BEGIN_DATE, p_END_DATE);

	p_STATUS := GA.SUCCESS;

	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	SELECT TRANSACTION_NAME, GET_INTERVAL_NUMBER(TRANSACTION_INTERVAL)
	INTO v_TRANSACTION_NAME, v_INTERVAL_NUMBER
	FROM INTERCHANGE_TRANSACTION
	WHERE TRANSACTION_ID = p_SUPPLY_TRANSACTION_ID;

	SELECT ID_TYPE(A.TO_TRANSACTION_ID)
	BULK COLLECT INTO v_DEMAND_IDs
	FROM IT_ASSIGNMENT A, IT_ASSIGNMENT_PERIOD B, INTERCHANGE_TRANSACTION T, IT_STATUS C
	WHERE A.FROM_TRANSACTION_ID = p_SUPPLY_TRANSACTION_ID
		AND A.ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE
		AND T.TRANSACTION_ID = A.TO_TRANSACTION_ID
		AND UPPER(SUBSTR(T.TRANSACTION_TYPE,1,2)) IN ('RE','LO')
		AND B.ASSIGNMENT_ID = A.ASSIGNMENT_ID
		AND B.BEGIN_DATE <= p_END_DATE
		AND NVL(B.END_DATE,HIGH_DATE) >= p_BEGIN_DATE
		AND C.TRANSACTION_ID = A.FROM_TRANSACTION_ID
		AND C.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
							FROM IT_STATUS
							WHERE TRANSACTION_ID = C.TRANSACTION_ID
								AND AS_OF_DATE <= p_AS_OF_DATE)
		AND C.TRANSACTION_IS_ACTIVE = 1;

	-- Populate IT_ASSIGNMENT_WORK for Supply
	IA.BUILD_WORK_DATA_FROM(p_SUPPLY_TRANSACTION_ID, v_BEGIN_DATE, v_END_DATE, p_TIME_ZONE, p_SCHEDULE_TYPE, g_BALANCING_ASSIGNMENT_TYPE, v_SUPPLY_WORK_ID);

	-- Populate IT_ASSIGNMENT_WORK for Demand
	IA.BUILD_WORK_ASSIGNMENTS_TO(p_SUPPLY_TRANSACTION_ID, v_DEMAND_IDs, v_BEGIN_DATE, v_END_DATE, p_TIME_ZONE, p_SCHEDULE_TYPE, g_BALANCING_ASSIGNMENT_TYPE, FALSE, TRUE, v_DEMAND_WORK_ID);
	IF v_USING_TOTAL_OBL = 1 THEN
		-- update transaction names to indicate that if it's a total obligation
		UPDATE IT_ASSIGNMENT_WORK SET
			TRANSACTION_NAME = REPLACE(v_TOTAL_OBL_NAME, '@', TRANSACTION_NAME)
		WHERE WORK_ID = v_DEMAND_WORK_ID
			AND TRANSACTION_ID IN (SELECT LINK_TRANSACTION_ID
                            		FROM INTERCHANGE_TRANSACTION
                            		WHERE IS_BALANCE_TRANSACTION = 0
                            			AND UPPER(SUBSTR(TRANSACTION_TYPE,1,2)) IN ('RE','LO','SA'));
		-- add in Sales volumes for "total obligation" loads
    	FOR v_SALES_VOL IN c_SALES_VOLS LOOP
    		UPDATE IT_ASSIGNMENT_WORK SET
    			AMOUNT = AMOUNT + v_SALES_VOL.AMOUNT
    		WHERE WORK_ID = v_DEMAND_WORK_ID
    			AND TRANSACTION_ID = v_SALES_VOL.TRANSACTION_ID
    			AND SCHEDULE_DATE = v_SALES_VOL.SCHEDULE_DATE;
    	END LOOP;
	END IF;

	-- Query
	OPEN p_CURSOR FOR
		SELECT SUBSTR(SDT.NO_ROLLUP_YYYY_MM_DD, 1, 10) "SCHEDULE_DATE",
				SUBSTR(SDT.NO_ROLLUP_YYYY_MM_DD, 12) "SCHEDULE_TIME",
				p_SUPPLY_TRANSACTION_ID "SUPPLY_TRANSACTION_ID",
				v_TRANSACTION_NAME "SUPPLY_TRANSACTION_NAME",
				S.IS_FIXED,
				CASE WHEN S.IS_FIXED = 1 THEN S.AMOUNT ELSE NULL END "FIXED_SCHEDULED",
				CASE WHEN S.IS_FIXED = 1 THEN NULL ELSE S.TERM_MAX END "DISP_MAX",
				CASE WHEN S.IS_FIXED = 1 THEN NULL ELSE S.TERM_MIN END "DISP_MIN",
				CASE WHEN S.IS_FIXED = 1 THEN S.TOTAL_ASSIGNED ELSE NULL END "FIXED_TOTAL_ASSIGNED_OLD",
				CASE WHEN S.IS_FIXED = 1 THEN NULL ELSE S.AMOUNT END "DISP_SCHEDULED_OLD",
				S.PRICE "SUPPLY_PRICE",
				L.TRANSACTION_ID "BALANCE_TRANSACTION_ID",
				L.TRANSACTION_NAME "BALANCE_TRANSACTION_NAME",
				L.AMOUNT "DEMAND_AMOUNT",
				L.ASSIGNED "ASSIGNED_AMOUNT",
				L.ASSIGNED "ASSIGNED_AMOUNT_OLD",
				L.TOTAL_ASSIGNED "SUPPLY_OLD",
				0 "UPDATE_DEMAND"
		FROM SYSTEM_DATE_TIME SDT,
			IT_ASSIGNMENT_WORK S,
			IT_ASSIGNMENT_WORK L
		WHERE SDT.TIME_ZONE = p_TIME_ZONE
			AND SDT.DATA_INTERVAL_TYPE = 1
			AND SDT.DAY_TYPE = '1'
			AND SDT.CUT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND SDT.MINIMUM_INTERVAL_NUMBER >= v_INTERVAL_NUMBER
			AND S.WORK_ID(+) = v_SUPPLY_WORK_ID
			AND S.SCHEDULE_DATE(+) = SDT.CUT_DATE
			AND L.WORK_ID(+) = v_DEMAND_WORK_ID
			AND L.SCHEDULE_DATE(+) = SDT.CUT_DATE
		ORDER BY SDT.CUT_DATE, L.TRANSACTION_NAME;

	IA.PURGE_WORK(v_DEMAND_WORK_ID, v_SUPPLY_WORK_ID);

EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			IA.PURGE_WORK(v_DEMAND_WORK_ID, v_SUPPLY_WORK_ID);
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE();
		END;
		ERRS.LOG_AND_RAISE();

END GET_BALANCE_SUPPLY_REPORT;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_DYNAMIC_SCHEDULE_LIST
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_LOAD_TRANSACTION_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
BEGIN
	p_STATUS := 0;

	OPEN p_CURSOR FOR
		SELECT '(None)' TRANSACTION_NAME, 0 TRANSACTION_ID
		FROM DUAL
		UNION ALL
		SELECT T.TRANSACTION_NAME, T.TRANSACTION_ID
		FROM INTERCHANGE_TRANSACTION T, IT_ASSIGNMENT A, IT_ASSIGNMENT_PERIOD P
		WHERE A.TO_TRANSACTION_ID = p_LOAD_TRANSACTION_ID
			AND A.ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE
			AND P.ASSIGNMENT_ID = A.ASSIGNMENT_ID
			AND P.BEGIN_DATE <= p_END_DATE
			AND NVL(P.END_DATE,HIGH_DATE) >= p_BEGIN_DATE
			AND T.TRANSACTION_ID = A.FROM_TRANSACTION_ID
			AND T.IS_DISPATCHABLE = 0 -- actually is *not* dispatchable
		ORDER BY 1, 2;

END GET_DYNAMIC_SCHEDULE_LIST;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_DEAL_EVAL_SUMMARY
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_LOAD_TRANSACTION_ID IN NUMBER,
	p_DYNAMIC_TRANSACTION_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
v_SOMETHING_DONE BOOLEAN := FALSE;
v_IDs ID_TABLE;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_DEFAULT_BEGIN_DATE DATE;
v_DEFAULT_END_DATE DATE;
v_LAST_EVAL DATE;
v_CURRENT_OVERLAP_LAST_EVAL NUMBER(1) := 1;
v_USING_TOTAL_OBL NUMBER := USING_TOTAL_OBL;
BEGIN
	p_STATUS := 0;

	-- get list of transactions that apply to this load schedule
	XS.DEAL_EVAL_GET_TRANSACTIONS(p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_SCHEDULE_TYPE, p_TIME_ZONE,
								  p_LOAD_TRANSACTION_ID, p_DYNAMIC_TRANSACTION_ID,
								  v_SOMETHING_DONE, v_IDs);
	-- hook not implemented? fall-back to default behavior
	IF NOT v_SOMETHING_DONE THEN
		GET_DEAL_EVAL_TRANSACTIONS(p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_SCHEDULE_TYPE, p_TIME_ZONE,
									p_LOAD_TRANSACTION_ID, p_DYNAMIC_TRANSACTION_ID,
									v_IDs);
	END IF;

	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

    SELECT NVL(MIN(O.BEGIN_DATE),TRUNC(v_BEGIN_DATE,'HH')+1/24),
		NVL(MAX(O.END_DATE),v_END_DATE), MAX(LAST_EVALUATED)
	INTO v_DEFAULT_BEGIN_DATE, v_DEFAULT_END_DATE, v_LAST_EVAL
	FROM IT_ASSIGNMENT_OPTION O
	WHERE O.TO_TRANSACTION_ID = p_LOAD_TRANSACTION_ID
    	AND O.OTHER_TRANSACTION_ID = p_DYNAMIC_TRANSACTION_ID
		AND O.ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE
    	AND O.BEGIN_DATE <= v_END_DATE
    	AND O.END_DATE >= v_BEGIN_DATE
		AND O.LAST_EVALUATED = (SELECT MAX(LAST_EVALUATED)
								FROM IT_ASSIGNMENT_OPTION
								WHERE TO_TRANSACTION_ID = O.TO_TRANSACTION_ID
									AND OTHER_TRANSACTION_ID = O.OTHER_TRANSACTION_ID
									AND O.ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE);

	IF v_LAST_EVAL IS NULL THEN
		v_CURRENT_OVERLAP_LAST_EVAL := 0;
        SELECT MAX(LAST_EVALUATED)
    	INTO v_LAST_EVAL
    	FROM IT_ASSIGNMENT_OPTION O
    	WHERE O.TO_TRANSACTION_ID = p_LOAD_TRANSACTION_ID
        	AND O.OTHER_TRANSACTION_ID = p_DYNAMIC_TRANSACTION_ID
    		AND O.ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE
        	AND O.BEGIN_DATE <= v_END_DATE
        	AND O.END_DATE >= v_BEGIN_DATE;
	END IF;

	OPEN p_CURSOR FOR
		-- first query for the current WACOG (w/ only current committed supply)
		SELECT 1 "ORDER_BY",
			p_LOAD_TRANSACTION_ID "LOAD_TRANSACTION_ID",
			p_DYNAMIC_TRANSACTION_ID "DYNAMIC_TRANSACTION_ID",
			'(current)' "SUPPLY_TRANSACTION_NAME",
			0 "SUPPLY_TRANSACTION_ID",
			0 "EVALUATE",
			v_CURRENT_OVERLAP_LAST_EVAL "HIGHLIGHT",
			FROM_CUT_AS_HED(v_DEFAULT_BEGIN_DATE,p_TIME_ZONE) "LOCAL_BEGIN_DATE",
			v_DEFAULT_BEGIN_DATE "CUT_BEGIN_DATE",
			FROM_CUT_AS_HED(v_DEFAULT_END_DATE, p_TIME_ZONE) "LOCAL_END_DATE",
			v_DEFAULT_END_DATE "CUT_END_DATE",
			NVL(SUM(A.AMOUNT*A.PRICE),0) "TOTAL_COST",
			CASE WHEN NVL(SUM(A.AMOUNT),0) = 0 THEN NULL ELSE NVL(SUM(A.AMOUNT*A.PRICE),0)/SUM(A.AMOUNT) END "WACOG",
			NVL(SUM(A.AMOUNT),0) - (SELECT NVL(SUM(I.AMOUNT),0)
                    				FROM IT_SCHEDULE I, INTERCHANGE_TRANSACTION IT
                    				WHERE (IT.TRANSACTION_ID = p_LOAD_TRANSACTION_ID
											-- include linked sales for "total obligation" loads
											OR (v_USING_TOTAL_OBL = 1
												AND IT.LINK_TRANSACTION_ID = p_LOAD_TRANSACTION_ID
												AND IT.IS_BALANCE_TRANSACTION = 0
					                			AND UPPER(SUBSTR(IT.TRANSACTION_TYPE,1,2)) IN ('RE','LO','SA')))
										AND I.TRANSACTION_ID = IT.TRANSACTION_ID
                    					AND I.SCHEDULE_TYPE = p_SCHEDULE_TYPE
                    					AND I.SCHEDULE_STATE = GA.INTERNAL_STATE
                    					AND I.SCHEDULE_DATE BETWEEN v_DEFAULT_BEGIN_DATE AND v_DEFAULT_END_DATE) "REMAINING_IMBALANCE",
			NULL "LAST_EVALUATED",
			NULL "STATUS",
			NULL "NOTES"
		FROM IT_ASSIGNMENT_SCHEDULE A,
			IT_ASSIGNMENT B
		WHERE B.TO_TRANSACTION_ID = p_LOAD_TRANSACTION_ID
			AND B.ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE
			AND A.ASSIGNMENT_ID = B.ASSIGNMENT_ID
			AND A.OPTION_ID = GA.COMMITTED_OPTION_ID
			AND A.STATEMENT_TYPE_ID = p_SCHEDULE_TYPE
			AND A.SCHEDULE_STATE = GA.INTERNAL_STATE
			AND A.SCHEDULE_DATE BETWEEN v_DEFAULT_BEGIN_DATE AND v_DEFAULT_END_DATE
		GROUP BY v_DEFAULT_BEGIN_DATE, v_DEFAULT_END_DATE
		-- then query evaluated deals - uncommitted first
		UNION ALL
		SELECT 2 "ORDER_BY",
			p_LOAD_TRANSACTION_ID "LOAD_TRANSACTION_ID",
			p_DYNAMIC_TRANSACTION_ID "DYNAMIC_TRANSACTION_ID",
			B.TRANSACTION_NAME "SUPPLY_TRANSACTION_NAME",
			A.FROM_TRANSACTION_ID "SUPPLY_TRANSACTION_ID",
			0 "EVALUATE",
			CASE WHEN A.LAST_EVALUATED = v_LAST_EVAL THEN 1 ELSE 0 END "HIGHLIGHT",
			FROM_CUT_AS_HED(A.BEGIN_DATE,p_TIME_ZONE) "LOCAL_BEGIN_DATE",
			A.BEGIN_DATE "CUT_BEGIN_DATE",
			FROM_CUT_AS_HED(A.END_DATE,p_TIME_ZONE) "LOCAL_END_DATE",
			A.END_DATE "CUT_END_DATE",
			NVL(SUM(C.AMOUNT*C.PRICE),0) "TOTAL_COST",
			CASE WHEN NVL(SUM(C.AMOUNT),0) = 0 THEN NULL ELSE NVL(SUM(C.AMOUNT*C.PRICE),0)/SUM(C.AMOUNT) END "WACOG",
			NVL(SUM(C.AMOUNT),0) - (SELECT NVL(SUM(I.AMOUNT),0)
                    				FROM IT_SCHEDULE I, INTERCHANGE_TRANSACTION IT
                    				WHERE (IT.TRANSACTION_ID = p_LOAD_TRANSACTION_ID
											-- include linked sales for "total obligation" loads
											OR (v_USING_TOTAL_OBL = 1
												AND IT.LINK_TRANSACTION_ID = p_LOAD_TRANSACTION_ID
												AND IT.IS_BALANCE_TRANSACTION = 0
					                			AND UPPER(SUBSTR(IT.TRANSACTION_TYPE,1,2)) IN ('RE','LO','SA')))
										AND I.TRANSACTION_ID = IT.TRANSACTION_ID
                    					AND I.SCHEDULE_TYPE = p_SCHEDULE_TYPE
                    					AND I.SCHEDULE_STATE = GA.INTERNAL_STATE
                    					AND I.SCHEDULE_DATE BETWEEN A.BEGIN_DATE AND A.END_DATE) "REMAINING_IMBALANCE",
			A.LAST_EVALUATED,
			A.STATUS,
			A.NOTES
		FROM IT_ASSIGNMENT_OPTION A,
			INTERCHANGE_TRANSACTION B,
			IT_ASSIGNMENT_SCHEDULE C,
			IT_ASSIGNMENT D
		WHERE A.TO_TRANSACTION_ID = p_LOAD_TRANSACTION_ID
			AND A.OTHER_TRANSACTION_ID = p_DYNAMIC_TRANSACTION_ID
			AND A.FROM_TRANSACTION_ID IN (SELECT X.ID FROM TABLE(CAST(v_IDs AS ID_TABLE)) X)
			AND A.ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE
			AND A.STATUS <> g_STATUS_COMMITTED
			AND B.TRANSACTION_ID = A.FROM_TRANSACTION_ID
			AND D.TO_TRANSACTION_ID = p_LOAD_TRANSACTION_ID
			AND D.ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE
			AND C.ASSIGNMENT_ID = D.ASSIGNMENT_ID
			AND C.OPTION_ID IN (GA.COMMITTED_OPTION_ID, A.OPTION_ID)
			AND C.STATEMENT_TYPE_ID = p_SCHEDULE_TYPE
			AND C.SCHEDULE_STATE = GA.INTERNAL_STATE
			AND C.SCHEDULE_DATE BETWEEN A.BEGIN_DATE AND A.END_DATE
		GROUP BY B.TRANSACTION_NAME, A.FROM_TRANSACTION_ID, A.BEGIN_DATE, A.END_DATE, A.LAST_EVALUATED, A.STATUS, A.NOTES
		-- ...then committed...
		UNION ALL
		SELECT 3 "ORDER_BY",
			p_LOAD_TRANSACTION_ID "LOAD_TRANSACTION_ID",
			p_DYNAMIC_TRANSACTION_ID "DYNAMIC_TRANSACTION_ID",
			B.TRANSACTION_NAME "SUPPLY_TRANSACTION_NAME",
			A.FROM_TRANSACTION_ID "SUPPLY_TRANSACTION_ID",
			0 "EVALUATE",
			CASE WHEN A.LAST_EVALUATED = v_LAST_EVAL THEN 1 ELSE 0 END "HIGHLIGHT",
			FROM_CUT_AS_HED(A.BEGIN_DATE,p_TIME_ZONE) "LOCAL_BEGIN_DATE",
			A.BEGIN_DATE "CUT_BEGIN_DATE",
			FROM_CUT_AS_HED(A.END_DATE,p_TIME_ZONE) "LOCAL_END_DATE",
			A.END_DATE "CUT_END_DATE",
			NVL(SUM(C.AMOUNT*C.PRICE),0) "TOTAL_COST",
			CASE WHEN NVL(SUM(C.AMOUNT),0) = 0 THEN NULL ELSE NVL(SUM(C.AMOUNT*C.PRICE),0)/SUM(C.AMOUNT) END "WACOG",
			NVL(SUM(C.AMOUNT),0) - (SELECT NVL(SUM(I.AMOUNT),0)
                    				FROM IT_SCHEDULE I, INTERCHANGE_TRANSACTION IT
                    				WHERE (IT.TRANSACTION_ID = p_LOAD_TRANSACTION_ID
											-- include linked sales for "total obligation" loads
											OR (v_USING_TOTAL_OBL = 1
												AND IT.LINK_TRANSACTION_ID = p_LOAD_TRANSACTION_ID
												AND IT.IS_BALANCE_TRANSACTION = 0
					                			AND UPPER(SUBSTR(IT.TRANSACTION_TYPE,1,2)) IN ('RE','LO','SA')))
										AND I.TRANSACTION_ID = IT.TRANSACTION_ID
                    					AND I.SCHEDULE_TYPE = p_SCHEDULE_TYPE
                    					AND I.SCHEDULE_STATE = GA.INTERNAL_STATE
                    					AND I.SCHEDULE_DATE BETWEEN A.BEGIN_DATE AND A.END_DATE) "REMAINING_IMBALANCE",
			A.LAST_EVALUATED,
			A.STATUS,
			A.NOTES
		FROM IT_ASSIGNMENT_OPTION A,
			INTERCHANGE_TRANSACTION B,
			IT_ASSIGNMENT_SCHEDULE C,
			IT_ASSIGNMENT D
		WHERE A.TO_TRANSACTION_ID = p_LOAD_TRANSACTION_ID
			AND A.OTHER_TRANSACTION_ID = p_DYNAMIC_TRANSACTION_ID
			AND A.FROM_TRANSACTION_ID IN (SELECT X.ID FROM TABLE(CAST(v_IDs AS ID_TABLE)) X)
			AND A.ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE
			AND A.STATUS = g_STATUS_COMMITTED
			AND B.TRANSACTION_ID = A.FROM_TRANSACTION_ID
			AND D.TO_TRANSACTION_ID = p_LOAD_TRANSACTION_ID
			AND D.ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE
			AND C.ASSIGNMENT_ID = D.ASSIGNMENT_ID
			AND C.OPTION_ID = GA.COMMITTED_OPTION_ID -- already committed - so committed option ID alone gives us all info we need
			AND C.STATEMENT_TYPE_ID = p_SCHEDULE_TYPE
			AND C.SCHEDULE_STATE = GA.INTERNAL_STATE
			AND C.SCHEDULE_DATE BETWEEN A.BEGIN_DATE AND A.END_DATE
		GROUP BY B.TRANSACTION_NAME, A.FROM_TRANSACTION_ID, A.BEGIN_DATE, A.END_DATE, A.LAST_EVALUATED, A.STATUS, A.NOTES
		-- finally query any other deals
		UNION ALL
		SELECT 4 "ORDER_BY",
			p_LOAD_TRANSACTION_ID "LOAD_TRANSACTION_ID",
			p_DYNAMIC_TRANSACTION_ID "DYNAMIC_TRANSACTION_ID",
			A.TRANSACTION_NAME "SUPPLY_TRANSACTION_NAME",
			A.TRANSACTION_ID "SUPPLY_TRANSACTION_ID",
			0 "EVALUATE",
			0 "HIGHLIGHT",
			NULL "LOCAL_BEGIN_DATE",
			NULL "CUT_BEGIN_DATE",
			NULL "LOCAL_END_DATE",
			NULL "CUT_END_DATE",
			NULL "TOTAL_COST",
			NULL "WACOG",
			NULL "REMAINING_IMBALANCE",
			NULL "LAST_EVALUATED",
			NULL "STATUS",
			NULL "NOTES"
		FROM INTERCHANGE_TRANSACTION A
		WHERE A.TRANSACTION_ID IN (SELECT X.ID FROM TABLE(CAST(v_IDs AS ID_TABLE)) X)
			AND NOT EXISTS (SELECT TRANSACTION_ID FROM IT_ASSIGNMENT_OPTION
							WHERE TO_TRANSACTION_ID = p_LOAD_TRANSACTION_ID
								AND OTHER_TRANSACTION_ID = p_DYNAMIC_TRANSACTION_ID
								AND FROM_TRANSACTION_ID = A.TRANSACTION_ID
								AND ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE)
		ORDER BY ORDER_BY ASC, LAST_EVALUATED DESC, WACOG ASC, REMAINING_IMBALANCE DESC, SUPPLY_TRANSACTION_NAME ASC;

END GET_DEAL_EVAL_SUMMARY;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_DEAL_EVAL_NOTES
	(
	p_LOAD_TRANSACTION_ID IN NUMBER,
	p_DYNAMIC_TRANSACTION_ID IN NUMBER,
	p_SUPPLY_TRANSACTION_ID IN NUMBER,
	p_NOTES IN VARCHAR2,
	p_STATUS OUT NUMBER
	) AS
BEGIN
	UPDATE IT_ASSIGNMENT_OPTION
		SET NOTES = p_NOTES
	WHERE FROM_TRANSACTION_ID = p_SUPPLY_TRANSACTION_ID
		AND TO_TRANSACTION_ID = p_LOAD_TRANSACTION_ID
		AND OTHER_TRANSACTION_ID = p_DYNAMIC_TRANSACTION_ID
		AND ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE;
END PUT_DEAL_EVAL_NOTES;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_DEAL_EVAL_DETAILS
	(
	p_CUT_BEGIN_DATE IN DATE,
	p_CUT_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_LOAD_TRANSACTION_ID IN NUMBER,
	p_DYNAMIC_TRANSACTION_ID IN NUMBER,
	p_SUPPLY_TRANSACTION_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
v_OPTION_ID NUMBER;
v_STATUS VARCHAR2(32);
v_USING_TOTAL_OBL NUMBER := USING_TOTAL_OBL;
BEGIN
	p_STATUS := 0;

    BEGIN
        SELECT OPTION_ID, STATUS
        INTO v_OPTION_ID, v_STATUS
        FROM IT_ASSIGNMENT_OPTION
        WHERE FROM_TRANSACTION_ID = p_SUPPLY_TRANSACTION_ID
    	    AND TO_TRANSACTION_ID = p_LOAD_TRANSACTION_ID
        	AND OTHER_TRANSACTION_ID = p_DYNAMIC_TRANSACTION_ID
			AND ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			v_OPTION_ID := -1;
    END;

	OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(SCHEDULE_DATE,p_TIME_ZONE) "SCHEDULE_DATE",
				SUM(LOAD) "LOAD",
				-- if this option has already been committed, then subtract it out from
				-- the committed columns - committed columns indicate committed supply
				-- *other* than this option
				NVL(SUM(COMMITTED_SUPPLY),0) - CASE WHEN v_STATUS = g_STATUS_COMMITTED THEN
												NVL(SUM(DYNAMIC_SCHEDULE),0) + NVL(SUM(EVAL_SCHEDULE),0)
											ELSE
												0
											END "COMMITTED_SUPPLY",
				NVL(SUM(COMMITTED_COST),0) - CASE WHEN v_STATUS = g_STATUS_COMMITTED THEN
												NVL(SUM(DYNAMIC_COST),0) + NVL(SUM(EVAL_COST),0)
											ELSE
												0
											END "COMMITTED_COST",
				SUM(DYNAMIC_SCHEDULE) "DYNAMIC_SCHEDULE",
				SUM(DYNAMIC_COST) "DYNAMIC_COST",
				SUM(EVAL_SCHEDULE) "EVAL_SCHEDULE",
				SUM(EVAL_COST) "EVAL_COST"
		FROM (SELECT SCHEDULE_DATE,
					SUM(AMOUNT) "LOAD",
					NULL "COMMITTED_SUPPLY",
					NULL "COMMITTED_COST",
					NULL "DYNAMIC_SCHEDULE",
					NULL "DYNAMIC_COST",
					NULL "EVAL_SCHEDULE",
					NULL "EVAL_COST"
			  FROM IT_SCHEDULE A, INTERCHANGE_TRANSACTION B
			  WHERE (B.TRANSACTION_ID = p_LOAD_TRANSACTION_ID
            			-- include linked sales for "total obligation" loads
            			OR (v_USING_TOTAL_OBL = 1
							AND B.LINK_TRANSACTION_ID = p_LOAD_TRANSACTION_ID
            				AND B.IS_BALANCE_TRANSACTION = 0
                         			AND UPPER(SUBSTR(B.TRANSACTION_TYPE,1,2)) IN ('RE','LO','SA')))
				AND A.TRANSACTION_ID = B.TRANSACTION_ID
			  	AND A.SCHEDULE_TYPE = p_SCHEDULE_TYPE
				AND A.SCHEDULE_STATE = GA.INTERNAL_STATE
				AND A.SCHEDULE_DATE BETWEEN p_CUT_BEGIN_DATE AND p_CUT_END_DATE
				AND A.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
									FROM IT_SCHEDULE
									WHERE TRANSACTION_ID = A.TRANSACTION_ID
										AND SCHEDULE_TYPE = A.SCHEDULE_TYPE
										AND SCHEDULE_STATE = A.SCHEDULE_STATE
										AND SCHEDULE_DATE = A.SCHEDULE_DATE
										AND AS_OF_DATE <= p_AS_OF_DATE)
			  GROUP BY SCHEDULE_DATE
			  UNION ALL
			  SELECT SCHEDULE_DATE,
			  		NULL "LOAD",
					SUM(CASE WHEN OPTION_ID = GA.COMMITTED_OPTION_ID THEN A.AMOUNT ELSE NULL END) "COMMITTED_SUPPLY",
					SUM(CASE WHEN OPTION_ID = GA.COMMITTED_OPTION_ID THEN A.AMOUNT*A.PRICE ELSE NULL END) "COMMITTED_COST",
					SUM(CASE WHEN OPTION_ID = v_OPTION_ID AND v_OPTION_ID <> GA.COMMITTED_OPTION_ID AND FROM_TRANSACTION_ID = p_DYNAMIC_TRANSACTION_ID THEN A.AMOUNT ELSE NULL END) "DYNAMIC_SCHEDULE",
					SUM(CASE WHEN OPTION_ID = v_OPTION_ID AND v_OPTION_ID <> GA.COMMITTED_OPTION_ID AND FROM_TRANSACTION_ID = p_DYNAMIC_TRANSACTION_ID THEN A.AMOUNT*A.PRICE ELSE NULL END) "DYNAMIC_COST",
					SUM(CASE WHEN OPTION_ID = v_OPTION_ID AND v_OPTION_ID <> GA.COMMITTED_OPTION_ID AND FROM_TRANSACTION_ID = p_SUPPLY_TRANSACTION_ID THEN A.AMOUNT ELSE NULL END) "EVAL_SCHEDULE",
					SUM(CASE WHEN OPTION_ID = v_OPTION_ID AND v_OPTION_ID <> GA.COMMITTED_OPTION_ID AND FROM_TRANSACTION_ID = p_SUPPLY_TRANSACTION_ID THEN A.AMOUNT*A.PRICE ELSE NULL END) "EVAL_COST"
			  FROM IT_ASSIGNMENT_SCHEDULE A, IT_ASSIGNMENT B
			  WHERE B.TO_TRANSACTION_ID = p_LOAD_TRANSACTION_ID
			  	AND B.ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE
			  	AND A.ASSIGNMENT_ID = B.ASSIGNMENT_ID
				AND A.STATEMENT_TYPE_ID = p_SCHEDULE_TYPE
				AND A.SCHEDULE_STATE = GA.INTERNAL_STATE
			  	AND A.OPTION_ID IN (GA.COMMITTED_OPTION_ID, v_OPTION_ID)
				AND A.SCHEDULE_DATE BETWEEN p_CUT_BEGIN_DATE AND p_CUT_END_DATE
			  GROUP BY SCHEDULE_DATE
			)
		GROUP BY SCHEDULE_DATE
		ORDER BY SCHEDULE_DATE;

END GET_DEAL_EVAL_DETAILS;
---------------------------------------------------------------------------------------------------
PROCEDURE EVALUATE_DEALS
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_LOAD_TRANSACTION_ID IN NUMBER,
	p_DYNAMIC_TRANSACTION_ID IN NUMBER,
	p_SUPPLY_TRANSACTION_IDs IN VARCHAR2,
	p_STATUS OUT NUMBER
	) AS
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_SOMETHING_DONE BOOLEAN;
v_SUPPLY_TRANSACTION_IDs ID_TABLE;
v_ID_TABLE GA.ID_TABLE;
v_IDX BINARY_INTEGER;
v_OPTION_ID NUMBER;
v_SYSDATE DATE := SYSDATE;
BEGIN
	p_STATUS := 0;

	UT.IDS_FROM_STRING(p_SUPPLY_TRANSACTION_IDs, ';', v_ID_TABLE);
	v_IDX := v_ID_TABLE.FIRST;
	v_SUPPLY_TRANSACTION_IDs := ID_TABLE();
	WHILE v_ID_TABLE.EXISTS(v_IDX) LOOP
		v_SUPPLY_TRANSACTION_IDs.EXTEND();
		v_SUPPLY_TRANSACTION_IDs(v_SUPPLY_TRANSACTION_IDs.LAST) := ID_TYPE(v_ID_TABLE(v_IDX));
		v_IDX := v_ID_TABLE.NEXT(v_IDX);
	END LOOP;

	-- get date range to evaluate for this set of supplies
	XS.DEAL_EVAL_GET_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_SCHEDULE_TYPE,
								p_TIME_ZONE, p_LOAD_TRANSACTION_ID, p_DYNAMIC_TRANSACTION_ID,
								v_SUPPLY_TRANSACTION_IDs, v_SOMETHING_DONE, v_BEGIN_DATE, v_END_DATE);
	-- hook not implemented? fall back to default date range
	IF NOT v_SOMETHING_DONE THEN
		GET_DEAL_EVAL_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_SCHEDULE_TYPE,
								p_TIME_ZONE, p_LOAD_TRANSACTION_ID, p_DYNAMIC_TRANSACTION_ID,
								v_SUPPLY_TRANSACTION_IDs, v_BEGIN_DATE, v_END_DATE);
	END IF;

	v_IDX := v_SUPPLY_TRANSACTION_IDs.FIRST;
	WHILE v_SUPPLY_TRANSACTION_IDs.EXISTS(v_IDX) LOOP
		BEGIN
            SELECT OPTION_ID
            INTO v_OPTION_ID
            FROM IT_ASSIGNMENT_OPTION
            WHERE FROM_TRANSACTION_ID = v_SUPPLY_TRANSACTION_IDs(v_IDX).ID
        	    AND TO_TRANSACTION_ID = p_LOAD_TRANSACTION_ID
            	AND OTHER_TRANSACTION_ID = p_DYNAMIC_TRANSACTION_ID
				AND ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE;
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
				SELECT OID.NEXTVAL INTO v_OPTION_ID FROM DUAL;
    			INSERT INTO IT_ASSIGNMENT_OPTION
    				(OPTION_ID, FROM_TRANSACTION_ID, TO_TRANSACTION_ID, OTHER_TRANSACTION_ID,
    				 ASSIGNMENT_TYPE, BEGIN_DATE, END_DATE, STATUS, NOTES, LAST_EVALUATED)
    			VALUES
    				(v_OPTION_ID, v_SUPPLY_TRANSACTION_IDs(v_IDX).ID, p_LOAD_TRANSACTION_ID,
    				p_DYNAMIC_TRANSACTION_ID, g_BALANCING_ASSIGNMENT_TYPE,
    				v_BEGIN_DATE, v_END_DATE, g_STATUS_EVALUATING, NULL, v_SYSDATE);
		END;
		-- perform evaluation for this supply
		XS.DEAL_EVAL_PERFORM_EVAL(v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, p_SCHEDULE_TYPE,
								p_TIME_ZONE, p_LOAD_TRANSACTION_ID, p_DYNAMIC_TRANSACTION_ID,
								v_SUPPLY_TRANSACTION_IDs(v_IDX).ID, v_OPTION_ID,
								v_SOMETHING_DONE);
		-- hook not implemented? fall back to default evaluation
		IF NOT v_SOMETHING_DONE THEN
			DEFAULT_EVALUATION(v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, p_SCHEDULE_TYPE,
								p_TIME_ZONE, p_LOAD_TRANSACTION_ID, p_DYNAMIC_TRANSACTION_ID,
								v_SUPPLY_TRANSACTION_IDs(v_IDX).ID, v_OPTION_ID);
		END IF;

		UPDATE IT_ASSIGNMENT_OPTION
			SET STATUS = g_STATUS_PENDING,
				BEGIN_DATE = v_BEGIN_DATE,
				END_DATE = v_END_DATE,
				LAST_EVALUATED = v_SYSDATE
			WHERE OPTION_ID = v_OPTION_ID;

		v_IDX := v_SUPPLY_TRANSACTION_IDs.NEXT(v_IDX);
		COMMIT;
	END LOOP;

END EVALUATE_DEALS;
---------------------------------------------------------------------------------------------------
PROCEDURE SYNC_SCHEDULES_ASSIGNED
	(
	p_TRANSACTION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER
	) AS
v_IS_FIXED NUMBER;
BEGIN
	SELECT IS_DISPATCHABLE
	INTO v_IS_FIXED
	FROM INTERCHANGE_TRANSACTION
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

	IF v_IS_FIXED = 1 THEN
		RETURN;
	END IF;

	MERGE INTO IT_SCHEDULE A
	USING (SELECT S.SCHEDULE_DATE,
				SUM(S.AMOUNT) "AMOUNT",
				AVG(S.PRICE) "PRICE"
        	FROM IT_ASSIGNMENT_SCHEDULE S, IT_ASSIGNMENT A
        	WHERE A.FROM_TRANSACTION_ID = p_TRANSACTION_ID
				AND A.ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE
				AND S.ASSIGNMENT_ID = A.ASSIGNMENT_ID
        		AND S.OPTION_ID = GA.COMMITTED_OPTION_ID
        		AND S.STATEMENT_TYPE_ID = p_SCHEDULE_TYPE
        		AND S.SCHEDULE_STATE = GA.INTERNAL_STATE
			GROUP BY S.SCHEDULE_DATE) B
	ON (A.TRANSACTION_ID = p_TRANSACTION_ID
		AND A.SCHEDULE_TYPE = p_SCHEDULE_TYPE
        AND A.SCHEDULE_STATE = GA.INTERNAL_STATE
        AND A.SCHEDULE_DATE = B.SCHEDULE_DATE)
	WHEN MATCHED THEN
		UPDATE SET A.AMOUNT = NVL(B.AMOUNT,0),
				   A.PRICE = B.PRICE
	WHEN NOT MATCHED THEN
		INSERT (TRANSACTION_ID, SCHEDULE_TYPE, SCHEDULE_STATE,
				SCHEDULE_DATE, AS_OF_DATE, AMOUNT, PRICE)
        VALUES (p_TRANSACTION_ID, p_SCHEDULE_TYPE, GA.INTERNAL_STATE,
				B.SCHEDULE_DATE, SYSDATE, NVL(B.AMOUNT,0), B.PRICE);

END SYNC_SCHEDULES_ASSIGNED;
---------------------------------------------------------------------------------------------------
PROCEDURE COMMIT_DEAL_EVAL
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_LOAD_TRANSACTION_ID IN NUMBER,
	p_DYNAMIC_TRANSACTION_ID IN NUMBER,
	p_SUPPLY_TRANSACTION_ID IN NUMBER,
	p_STATUS OUT NUMBER
	) AS
v_OPTION_ID NUMBER;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
BEGIN
	p_STATUS := 0;

    SELECT OPTION_ID, BEGIN_DATE, END_DATE
    INTO v_OPTION_ID, v_BEGIN_DATE, v_END_DATE
    FROM IT_ASSIGNMENT_OPTION
    WHERE FROM_TRANSACTION_ID = p_SUPPLY_TRANSACTION_ID
	    AND TO_TRANSACTION_ID = p_LOAD_TRANSACTION_ID
    	AND OTHER_TRANSACTION_ID = p_DYNAMIC_TRANSACTION_ID
		AND ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE;

    XS.BEFORE_DEAL_EVAL_COMMIT(v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, p_SCHEDULE_TYPE, p_TIME_ZONE,
    			p_LOAD_TRANSACTION_ID, p_DYNAMIC_TRANSACTION_ID, p_SUPPLY_TRANSACTION_ID,
    			v_OPTION_ID);

	-- commit to assignment schedule
	MERGE INTO IT_ASSIGNMENT_SCHEDULE A
	USING (SELECT S.ASSIGNMENT_ID,
        		S.SCHEDULE_DATE,
        		S.AMOUNT,
				S.PRICE
        	FROM IT_ASSIGNMENT_SCHEDULE S, IT_ASSIGNMENT A
        	WHERE A.TO_TRANSACTION_ID = p_LOAD_TRANSACTION_ID
				AND A.ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE
				AND S.ASSIGNMENT_ID = A.ASSIGNMENT_ID
        		AND S.OPTION_ID = v_OPTION_ID
        		AND S.STATEMENT_TYPE_ID = p_SCHEDULE_TYPE
        		AND S.SCHEDULE_STATE = GA.INTERNAL_STATE) B
	ON (A.ASSIGNMENT_ID = B.ASSIGNMENT_ID
		AND A.OPTION_ID = GA.COMMITTED_OPTION_ID
        AND A.STATEMENT_TYPE_ID = p_SCHEDULE_TYPE
        AND A.SCHEDULE_STATE = GA.INTERNAL_STATE
        AND A.SCHEDULE_DATE = B.SCHEDULE_DATE)
	WHEN MATCHED THEN
		UPDATE SET A.AMOUNT = NVL(A.AMOUNT,0) + B.AMOUNT,
					A.PRICE = B.PRICE
	WHEN NOT MATCHED THEN
		INSERT (ASSIGNMENT_ID, OPTION_ID,
				STATEMENT_TYPE_ID, SCHEDULE_STATE, SCHEDULE_DATE,
				AMOUNT, PRICE)
        VALUES (B.ASSIGNMENT_ID, GA.COMMITTED_OPTION_ID,
	        	p_SCHEDULE_TYPE, GA.INTERNAL_STATE, B.SCHEDULE_DATE,
    	    	B.AMOUNT, B.PRICE);
	-- re-sync it_schedule with total assigned for dispatchable deals
	SYNC_SCHEDULES_ASSIGNED(p_SUPPLY_TRANSACTION_ID, v_BEGIN_DATE, v_END_DATE, p_SCHEDULE_TYPE);
	SYNC_SCHEDULES_ASSIGNED(p_DYNAMIC_TRANSACTION_ID, v_BEGIN_DATE, v_END_DATE, p_SCHEDULE_TYPE);

    UPDATE IT_ASSIGNMENT_OPTION
    	SET STATUS = g_STATUS_COMMITTED
	WHERE OPTION_ID = v_OPTION_ID;

    XS.AFTER_DEAL_EVAL_COMMIT(v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, p_SCHEDULE_TYPE, p_TIME_ZONE,
    			p_LOAD_TRANSACTION_ID, p_DYNAMIC_TRANSACTION_ID, p_SUPPLY_TRANSACTION_ID,
    			v_OPTION_ID);

END COMMIT_DEAL_EVAL;
---------------------------------------------------------------------------------------------------
PROCEDURE UNDO_DEAL_EVAL
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_LOAD_TRANSACTION_ID IN NUMBER,
	p_DYNAMIC_TRANSACTION_ID IN NUMBER,
	p_SUPPLY_TRANSACTION_ID IN NUMBER,
	p_STATUS OUT NUMBER
	) AS
v_OPTION_ID NUMBER;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
CURSOR c_RECORDS IS
	SELECT S.ASSIGNMENT_ID,
		S.SCHEDULE_DATE,
		S.AMOUNT
	FROM IT_ASSIGNMENT_SCHEDULE S, IT_ASSIGNMENT A
	WHERE A.TO_TRANSACTION_ID = p_LOAD_TRANSACTION_ID
		AND A.ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE
		AND S.ASSIGNMENT_ID = A.ASSIGNMENT_ID
		AND S.OPTION_ID = v_OPTION_ID
		AND S.STATEMENT_TYPE_ID = p_SCHEDULE_TYPE
		AND S.SCHEDULE_STATE = GA.INTERNAL_STATE;

BEGIN
	p_STATUS := 0;

    SELECT OPTION_ID, BEGIN_DATE, END_DATE
    INTO v_OPTION_ID, v_BEGIN_DATE, v_END_DATE
    FROM IT_ASSIGNMENT_OPTION
    WHERE FROM_TRANSACTION_ID = p_SUPPLY_TRANSACTION_ID
	    AND TO_TRANSACTION_ID = p_LOAD_TRANSACTION_ID
    	AND OTHER_TRANSACTION_ID = p_DYNAMIC_TRANSACTION_ID
		AND ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE;

    XS.BEFORE_DEAL_EVAL_UNDO(v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, p_SCHEDULE_TYPE, p_TIME_ZONE,
    			p_LOAD_TRANSACTION_ID, p_DYNAMIC_TRANSACTION_ID, p_SUPPLY_TRANSACTION_ID,
    			v_OPTION_ID);

	-- undo from assignment schedule
	FOR v_RECORD IN c_RECORDS LOOP
		UPDATE IT_ASSIGNMENT_SCHEDULE
			SET AMOUNT = AMOUNT - v_RECORD.AMOUNT
		WHERE ASSIGNMENT_ID = v_RECORD.ASSIGNMENT_ID
			AND OPTION_ID = GA.COMMITTED_OPTION_ID
			AND STATEMENT_TYPE_ID = p_SCHEDULE_TYPE
			AND SCHEDULE_STATE = GA.INTERNAL_STATE
			AND SCHEDULE_DATE = v_RECORD.SCHEDULE_DATE;
	END LOOP;
	-- re-sync it_schedule with total assigned for dispatchable deals
	SYNC_SCHEDULES_ASSIGNED(p_SUPPLY_TRANSACTION_ID, v_BEGIN_DATE, v_END_DATE, p_SCHEDULE_TYPE);
	SYNC_SCHEDULES_ASSIGNED(p_DYNAMIC_TRANSACTION_ID, v_BEGIN_DATE, v_END_DATE, p_SCHEDULE_TYPE);

    UPDATE IT_ASSIGNMENT_OPTION
    	SET STATUS = g_STATUS_PENDING
	WHERE OPTION_ID = v_OPTION_ID;

    XS.AFTER_DEAL_EVAL_UNDO(v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, p_SCHEDULE_TYPE, p_TIME_ZONE,
    			p_LOAD_TRANSACTION_ID, p_DYNAMIC_TRANSACTION_ID, p_SUPPLY_TRANSACTION_ID,
    			v_OPTION_ID);
END UNDO_DEAL_EVAL;
---------------------------------------------------------------------------------------------------
PROCEDURE REJECT_DEAL_EVAL
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_LOAD_TRANSACTION_ID IN NUMBER,
	p_DYNAMIC_TRANSACTION_ID IN NUMBER,
	p_SUPPLY_TRANSACTION_ID IN NUMBER,
	p_STATUS OUT NUMBER
	) AS
v_OPTION_ID NUMBER;
v_STATUS VARCHAR2(32);
v_BEGIN_DATE DATE;
v_END_DATE DATE;
BEGIN
    SELECT OPTION_ID, STATUS, BEGIN_DATE, END_DATE
    INTO v_OPTION_ID, v_STATUS, v_BEGIN_DATE, v_END_DATE
    FROM IT_ASSIGNMENT_OPTION
    WHERE FROM_TRANSACTION_ID = p_SUPPLY_TRANSACTION_ID
        AND TO_TRANSACTION_ID = p_LOAD_TRANSACTION_ID
        AND OTHER_TRANSACTION_ID = p_DYNAMIC_TRANSACTION_ID
		AND ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE;

    XS.BEFORE_DEAL_EVAL_REJECT(v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, p_SCHEDULE_TYPE, p_TIME_ZONE,
    			p_LOAD_TRANSACTION_ID, p_DYNAMIC_TRANSACTION_ID, p_SUPPLY_TRANSACTION_ID,
    			v_OPTION_ID);

	-- committed? then undo it before marking it as rejected
	IF v_STATUS = g_STATUS_COMMITTED THEN
    	UNDO_DEAL_EVAL(p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_SCHEDULE_TYPE, p_TIME_ZONE,
    					p_LOAD_TRANSACTION_ID, p_DYNAMIC_TRANSACTION_ID, p_SUPPLY_TRANSACTION_ID,
    					p_STATUS);
		IF p_STATUS <> 0 THEN
			RETURN;
		END IF;
	END IF;

    UPDATE IT_ASSIGNMENT_OPTION
	    SET STATUS = g_STATUS_REJECTED
    WHERE OPTION_ID = v_OPTION_ID;

    XS.AFTER_DEAL_EVAL_REJECT(v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, p_SCHEDULE_TYPE, p_TIME_ZONE,
    			p_LOAD_TRANSACTION_ID, p_DYNAMIC_TRANSACTION_ID, p_SUPPLY_TRANSACTION_ID,
    			v_OPTION_ID);
END REJECT_DEAL_EVAL;
---------------------------------------------------------------------------------------------------
PROCEDURE RESTORE_DEAL_EVAL
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_LOAD_TRANSACTION_ID IN NUMBER,
	p_DYNAMIC_TRANSACTION_ID IN NUMBER,
	p_SUPPLY_TRANSACTION_ID IN NUMBER,
	p_STATUS OUT NUMBER
	) AS
v_OPTION_ID NUMBER;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
BEGIN
	p_STATUS := 0;

    SELECT OPTION_ID, BEGIN_DATE, END_DATE
    INTO v_OPTION_ID, v_BEGIN_DATE, v_END_DATE
    FROM IT_ASSIGNMENT_OPTION
    WHERE FROM_TRANSACTION_ID = p_SUPPLY_TRANSACTION_ID
	    AND TO_TRANSACTION_ID = p_LOAD_TRANSACTION_ID
    	AND OTHER_TRANSACTION_ID = p_DYNAMIC_TRANSACTION_ID
		AND ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE;

    XS.BEFORE_DEAL_EVAL_RESTORE(v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, p_SCHEDULE_TYPE, p_TIME_ZONE,
        			p_LOAD_TRANSACTION_ID, p_DYNAMIC_TRANSACTION_ID, p_SUPPLY_TRANSACTION_ID,
        			v_OPTION_ID);

    UPDATE IT_ASSIGNMENT_OPTION
	    SET STATUS = g_STATUS_PENDING
    WHERE OPTION_ID = v_OPTION_ID;

    XS.AFTER_DEAL_EVAL_RESTORE(v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, p_SCHEDULE_TYPE, p_TIME_ZONE,
        			p_LOAD_TRANSACTION_ID, p_DYNAMIC_TRANSACTION_ID, p_SUPPLY_TRANSACTION_ID,
        			v_OPTION_ID);
END RESTORE_DEAL_EVAL;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_DEAL_EVAL_TRANSACTIONS
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_LOAD_TRANSACTION_ID IN NUMBER,
	p_DYNAMIC_TRANSACTION_ID IN NUMBER,
	p_IDs OUT ID_TABLE
	) AS
BEGIN

	SELECT ID_TYPE(FROM_TRANSACTION_ID)
	BULK COLLECT INTO p_IDs
	FROM IT_ASSIGNMENT A, IT_ASSIGNMENT_PERIOD P
	WHERE A.TO_TRANSACTION_ID = p_LOAD_TRANSACTION_ID
		AND A.FROM_TRANSACTION_ID <> p_DYNAMIC_TRANSACTION_ID
		AND A.ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE
		AND P.ASSIGNMENT_ID = A.ASSIGNMENT_ID
		AND P.BEGIN_DATE <= p_END_DATE
		AND NVL(P.END_DATE,HIGH_DATE) >= p_BEGIN_DATE;

END GET_DEAL_EVAL_TRANSACTIONS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_DEAL_EVAL_DATE_RANGE
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_LOAD_TRANSACTION_ID IN NUMBER,
	p_DYNAMIC_TRANSACTION_ID IN NUMBER,
	p_SUPPLY_TRANSACTION_IDs IN ID_TABLE,
	p_OUT_BEGIN_DATE OUT DATE,
	p_OUT_END_DATE OUT DATE
	) AS
v_THRESHOLD NUMBER;
v_IS_FIXED NUMBER;
v_NEED_DATES BOOLEAN;
v_BEGIN_DATE DATE := HIGH_DATE;
v_END_DATE DATE := LOW_DATE;
v_TMP_BEGIN DATE;
v_TMP_END DATE;
v_IDX BINARY_INTEGER;
BEGIN
	-- NOTE: This logic only supports Hourly deals !!!

	v_IDX := p_SUPPLY_TRANSACTION_IDs.FIRST;
	WHILE p_SUPPLY_TRANSACTION_IDs.EXISTS(v_IDX) LOOP
		SELECT IS_DISPATCHABLE -- really "is not dispatchable"
		INTO v_IS_FIXED
		FROM INTERCHANGE_TRANSACTION
		WHERE TRANSACTION_ID = p_SUPPLY_TRANSACTION_IDs(v_IDX).ID;

		IF v_IS_FIXED = 1 THEN
			SELECT MIN(SCHEDULE_DATE),
					MAX(SCHEDULE_DATE)
			INTO v_TMP_BEGIN, v_TMP_END
			FROM IT_SCHEDULE
			WHERE TRANSACTION_ID = p_SUPPLY_TRANSACTION_IDs(v_IDX).ID
				AND SCHEDULE_TYPE = p_SCHEDULE_TYPE
				AND SCHEDULE_STATE = GA.INTERNAL_STATE;

			-- get transaction begin/end dates if above query results in NULLs
			v_NEED_DATES := v_TMP_BEGIN IS NULL OR v_TMP_END IS NULL;
		ELSE
			v_NEED_DATES := TRUE; -- get transaction begin/end dates
		END IF;

		IF v_NEED_DATES THEN
			SELECT BEGIN_DATE, END_DATE
			INTO v_TMP_BEGIN, v_TMP_END
			FROM INTERCHANGE_TRANSACTION
			WHERE TRANSACTION_ID = p_SUPPLY_TRANSACTION_IDs(v_IDX).ID;

			UT.CUT_DATE_RANGE(v_TMP_BEGIN, v_TMP_END, p_TIME_ZONE, v_TMP_BEGIN, v_TMP_END);
			-- make sure begin date is HE 1
			v_TMP_BEGIN := TRUNC(v_TMP_BEGIN,'HH')+1/24;
		END IF;

		v_BEGIN_DATE := LEAST(v_TMP_BEGIN, v_BEGIN_DATE);
		v_END_DATE := LEAST(v_TMP_END, v_END_DATE);

		v_IDX := p_SUPPLY_TRANSACTION_IDs.NEXT(v_IDX);
	END LOOP;

	IF v_BEGIN_DATE > v_END_DATE THEN
		-- logic results in invalid date range? use incoming begin/end dates instead
		UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
        -- make sure begin date is HE 1
        v_BEGIN_DATE := TRUNC(v_BEGIN_DATE,'HH')+1/24;
	ELSE
		BEGIN
			v_THRESHOLD := NVL(GET_DICTIONARY_VALUE('Date Range Threshold', 1, 'Scheduling', 'Load Balancing', 'Deal Eval'), 30);
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
				v_THRESHOLD := 30; -- default threshold - 30 days
		END;
		IF v_END_DATE - v_BEGIN_DATE >= v_THRESHOLD THEN
			-- logic results in too long of an evaluation period - use
			-- incoming begin/end dates instead if they are a shorter eval period
			UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_TMP_BEGIN, v_TMP_END);
			-- make sure begin date is HE 1
			v_TMP_BEGIN := TRUNC(v_TMP_BEGIN,'HH')+1/24;

			IF v_TMP_END - v_TMP_BEGIN < v_END_DATE - v_BEGIN_DATE THEN
				v_BEGIN_DATE := v_TMP_BEGIN;
				v_END_DATE := v_TMP_END;
			END IF;
		END IF;
	END IF;

	-- done!
	p_OUT_BEGIN_DATE := v_BEGIN_DATE;
	p_OUT_END_DATE := v_END_DATE;

END GET_DEAL_EVAL_DATE_RANGE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_LIMITS
	(
	p_SCHEDULE_DATE IN DATE,
	p_LOCAL_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_TRANSACTION_ID IN NUMBER,
	p_IS_FIXED IN NUMBER,
	p_MAX OUT NUMBER,
	p_MIN OUT NUMBER,
	p_PRICE OUT NUMBER
	) AS
v_MAX_TX_ID NUMBER;
v_MIN_TX_ID NUMBER;
v_PRICE NUMBER := NULL;
v_IS_FIXED NUMBER(1);
BEGIN
	IF p_IS_FIXED IS NULL THEN
		SELECT NVL(IS_DISPATCHABLE,0)
		INTO v_IS_FIXED
		FROM INTERCHANGE_TRANSACTION
		WHERE TRANSACTION_ID = p_TRANSACTION_ID;
	ELSE
		v_IS_FIXED := p_IS_FIXED;
	END IF;

	IF v_IS_FIXED = 1 THEN
		-- fixed? then get limits from schedule
		SELECT NVL(SUM(AMOUNT),0), NVL(SUM(AMOUNT),0), NVL(AVG(PRICE),0)
		INTO p_MAX, p_MIN, p_PRICE
		FROM IT_SCHEDULE
		WHERE TRANSACTION_ID = p_TRANSACTION_ID
			AND SCHEDULE_TYPE = p_SCHEDULE_TYPE
			AND SCHEDULE_STATE = GA.INTERNAL_STATE
			AND SCHEDULE_DATE = p_SCHEDULE_DATE;
	ELSE
		-- otherwise, get limits from transactions' limit schedules
		BEGIN
    		SELECT LIMIT_TRANSACTION_ID, MIN_TRANSACTION_ID
    		INTO v_MAX_TX_ID, v_MIN_TX_ID
    		FROM INTERCHANGE_TRANSACTION_LIMIT
    		WHERE TRANSACTION_ID = p_TRANSACTION_ID
    			AND LIMIT_INTERVAL = 'Hour'
    			AND p_LOCAL_DATE BETWEEN BEGIN_DATE AND END_DATE;
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
				v_MAX_TX_ID := 0;
				v_MIN_TX_ID := 0;
		END;

		IF v_MAX_TX_ID <> 0 THEN
			SELECT NVL(MAX(AMOUNT),999999),
				AVG(PRICE)
			INTO p_MAX, v_PRICE
			FROM IT_SCHEDULE
			WHERE TRANSACTION_ID = v_MAX_TX_ID
				AND SCHEDULE_TYPE = p_SCHEDULE_TYPE
				AND SCHEDULE_STATE = GA.INTERNAL_STATE
				AND SCHEDULE_DATE = p_SCHEDULE_DATE;
		ELSE
			p_MAX := 999999; -- arbitrarily large value
		END IF;

		IF v_MIN_TX_ID <> 0 THEN
			SELECT NVL(MIN(AMOUNT),0),
				NVL(v_PRICE,NVL(AVG(PRICE),0)) -- get price here if we don't have it yet
			INTO p_MIN, v_PRICE
			FROM IT_SCHEDULE
			WHERE TRANSACTION_ID = v_MIN_TX_ID
				AND SCHEDULE_TYPE = p_SCHEDULE_TYPE
				AND SCHEDULE_STATE = GA.INTERNAL_STATE
				AND SCHEDULE_DATE = p_SCHEDULE_DATE;
		ELSE
			p_MIN := 0;
		END IF;

		p_PRICE := NVL(v_PRICE,0);
	END IF;
END GET_LIMITS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_BALANCE_TX_SCHEDULE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_BALANCE_TRANSACTION_ID IN NUMBER,
	p_OPTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_DATE IN DATE,
	p_AMOUNT IN NUMBER,
	p_PRICE IN NUMBER
	) AS
v_ASSIGNMENT_ID NUMBER;
BEGIN
	SELECT ASSIGNMENT_ID
	INTO v_ASSIGNMENT_ID
	FROM IT_ASSIGNMENT
	WHERE TO_TRANSACTION_ID = p_BALANCE_TRANSACTION_ID
		AND FROM_TRANSACTION_ID = p_TRANSACTION_ID
		AND ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE;

	UPDATE IT_ASSIGNMENT_SCHEDULE
	SET AMOUNT = p_AMOUNT,
		PRICE = p_PRICE
	WHERE ASSIGNMENT_ID = v_ASSIGNMENT_ID
		AND OPTION_ID = p_OPTION_ID
		AND STATEMENT_TYPE_ID = p_SCHEDULE_TYPE
		AND SCHEDULE_STATE = GA.INTERNAL_STATE
		AND SCHEDULE_DATE = p_SCHEDULE_DATE;

	IF SQL%NOTFOUND THEN
		INSERT INTO IT_ASSIGNMENT_SCHEDULE
			(ASSIGNMENT_ID, OPTION_ID, STATEMENT_TYPE_ID, SCHEDULE_STATE,
				SCHEDULE_DATE, AMOUNT, PRICE)
		VALUES
			(v_ASSIGNMENT_ID, p_OPTION_ID, p_SCHEDULE_TYPE, GA.INTERNAL_STATE,
				p_SCHEDULE_DATE, p_AMOUNT, p_PRICE);
	END IF;

END PUT_BALANCE_TX_SCHEDULE;
---------------------------------------------------------------------------------------------------
PROCEDURE DEFAULT_EVALUATION
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_LOAD_TRANSACTION_ID IN NUMBER,
	p_DYNAMIC_TRANSACTION_ID IN NUMBER,
	p_SUPPLY_TRANSACTION_ID IN NUMBER,
	p_OPTION_ID IN NUMBER
	) AS
v_CUR_DATE DATE;
v_LOCAL_DATE DATE;
v_SUPPLY_IS_FIXED NUMBER;
v_DYN_IS_FIXED NUMBER;
v_SUPPLY_LOAD_COUNT NUMBER;
v_DYN_LOAD_COUNT NUMBER;
v_LOAD NUMBER;
v_IMBALANCE NUMBER;
v_SUPPLY_ASSIGNED NUMBER;
v_DYN_ASSIGNED NUMBER;
v_SUPPLY_MAX NUMBER;
v_SUPPLY_MIN NUMBER;
v_SUPPLY_PRICE NUMBER;
v_DYN_MAX NUMBER;
v_DYN_MIN NUMBER;
v_DYN_PRICE NUMBER;
v_SUPPLY_CUR NUMBER;
v_DYN_CUR NUMBER;
v_USING_TOTAL_OBL NUMBER := USING_TOTAL_OBL;
BEGIN
	-- NOTE: This logic only supports Hourly deals !!!

	SELECT IS_DISPATCHABLE
	INTO v_SUPPLY_IS_FIXED
	FROM INTERCHANGE_TRANSACTION
	WHERE TRANSACTION_ID = p_SUPPLY_TRANSACTION_ID;

	SELECT COUNT(*)
	INTO v_SUPPLY_LOAD_COUNT
	FROM (SELECT DISTINCT TO_TRANSACTION_ID
			FROM IT_ASSIGNMENT
			WHERE FROM_TRANSACTION_ID = p_SUPPLY_TRANSACTION_ID
				AND ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE);

	IF p_DYNAMIC_TRANSACTION_ID <> 0 THEN
    	SELECT IS_DISPATCHABLE
    	INTO v_DYN_IS_FIXED
    	FROM INTERCHANGE_TRANSACTION
    	WHERE TRANSACTION_ID = p_DYNAMIC_TRANSACTION_ID;

    	SELECT COUNT(*)
    	INTO v_DYN_LOAD_COUNT
    	FROM (SELECT DISTINCT TO_TRANSACTION_ID
    			FROM IT_ASSIGNMENT
    			WHERE FROM_TRANSACTION_ID = p_DYNAMIC_TRANSACTION_ID
					AND ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE);
	END IF;

	v_CUR_DATE := p_BEGIN_DATE;

	WHILE v_CUR_DATE <= p_END_DATE LOOP
		v_LOCAL_DATE := TRUNC(FROM_CUT(v_CUR_DATE,p_TIME_ZONE)-1/86400);
		-- Get Load value for this hour
		SELECT SUM(AMOUNT)
		INTO v_LOAD
		FROM INTERCHANGE_TRANSACTION T, IT_SCHEDULE S
        WHERE (T.TRANSACTION_ID = p_LOAD_TRANSACTION_ID
    			-- include linked sales for "total obligation" loads
    			OR (v_USING_TOTAL_OBL = 1
					AND T.LINK_TRANSACTION_ID = p_LOAD_TRANSACTION_ID
    				AND T.IS_BALANCE_TRANSACTION = 0
                 			AND UPPER(SUBSTR(T.TRANSACTION_TYPE,1,2)) IN ('RE','LO','SA')))
			AND S.TRANSACTION_ID = T.TRANSACTION_ID
			AND S.SCHEDULE_TYPE = p_SCHEDULE_TYPE
			AND S.SCHEDULE_STATE = GA.INTERNAL_STATE
			AND S.SCHEDULE_DATE = v_CUR_DATE;

		-- Get limits for supply/dyn for this hour
		GET_LIMITS(v_CUR_DATE, v_LOCAL_DATE, p_SCHEDULE_TYPE, p_SUPPLY_TRANSACTION_ID, v_SUPPLY_IS_FIXED, v_SUPPLY_MAX, v_SUPPLY_MIN, v_SUPPLY_PRICE);
        -- only one load for these supply deals? then make sure we don't
        -- evaluate below deals' minimums
        IF v_SUPPLY_LOAD_COUNT > 1 THEN
	        v_SUPPLY_MIN := 0;
        END IF;
		v_SUPPLY_MAX := v_SUPPLY_MAX - v_SUPPLY_MIN;

		-- do the same for the dynamic transaction if there is one
		IF p_DYNAMIC_TRANSACTION_ID <> 0 THEN
			GET_LIMITS(v_CUR_DATE, v_LOCAL_DATE, p_SCHEDULE_TYPE, p_DYNAMIC_TRANSACTION_ID, v_DYN_IS_FIXED, v_DYN_MAX, v_DYN_MIN, v_DYN_PRICE);
            IF v_DYN_LOAD_COUNT > 1 THEN
        	    v_DYN_MIN := 0;
            END IF;
			v_DYN_MAX := v_DYN_MAX - v_DYN_MIN;
		ELSE
			v_DYN_MIN := 0;
		END IF;

		-- Get Total supply for this hour
		SELECT v_LOAD - NVL(SUM(AMOUNT),0),
				NVL(SUM(CASE WHEN FROM_TRANSACTION_ID = p_SUPPLY_TRANSACTION_ID THEN
							AMOUNT
						ELSE
							0
						END),0),
				NVL(SUM(CASE WHEN FROM_TRANSACTION_ID = p_DYNAMIC_TRANSACTION_ID THEN
							AMOUNT
						ELSE
							0
						END),0)
		INTO v_IMBALANCE, v_SUPPLY_ASSIGNED, v_DYN_ASSIGNED
		FROM IT_ASSIGNMENT A, IT_ASSIGNMENT_SCHEDULE S
		WHERE A.TO_TRANSACTION_ID = p_LOAD_TRANSACTION_ID
			AND A.ASSIGNMENT_TYPE = g_BALANCING_ASSIGNMENT_TYPE
			AND S.ASSIGNMENT_ID = A.ASSIGNMENT_ID
			AND S.OPTION_ID = GA.COMMITTED_OPTION_ID
			AND S.STATEMENT_TYPE_ID = p_SCHEDULE_TYPE
			AND S.SCHEDULE_STATE = GA.INTERNAL_STATE
			AND S.SCHEDULE_DATE = v_CUR_DATE;

		-- shift values around to assume that minimums have been met
		v_IMBALANCE := v_IMBALANCE + v_SUPPLY_ASSIGNED + v_DYN_ASSIGNED;
		v_IMBALANCE := v_IMBALANCE - v_SUPPLY_MIN - v_DYN_MIN;

		-- perform balance for this hour
		IF p_DYNAMIC_TRANSACTION_ID = 0 THEN
			-- assign up to max, but don't make schedule negative
			v_SUPPLY_CUR := GREATEST(LEAST(v_IMBALANCE, v_SUPPLY_MAX), 0);

			-- compute these assignments as deltas over existing assignments (including
			-- assumed minimum assignment)
			v_SUPPLY_CUR := v_SUPPLY_CUR+v_SUPPLY_MIN - v_SUPPLY_ASSIGNED;

			-- save assignment
			PUT_BALANCE_TX_SCHEDULE(p_SUPPLY_TRANSACTION_ID, p_LOAD_TRANSACTION_ID,
            						p_OPTION_ID, p_SCHEDULE_TYPE, v_CUR_DATE,
            						v_SUPPLY_CUR, v_SUPPLY_PRICE);
		ELSE
            -- balance cheaper first when under-supply, or most expensive
            -- first when over-supply
            IF (v_SUPPLY_PRICE < v_DYN_PRICE AND v_IMBALANCE > 0) OR
			   (v_SUPPLY_PRICE > v_DYN_PRICE AND v_IMBALANCE < 0) THEN
            	v_SUPPLY_CUR := GREATEST(LEAST(v_IMBALANCE, v_SUPPLY_MAX), 0);
            	v_DYN_CUR := GREATEST(LEAST(v_IMBALANCE-v_SUPPLY_CUR, v_DYN_MAX), 0);
            ELSE
            	v_DYN_CUR := GREATEST(LEAST(v_IMBALANCE, v_DYN_MAX), 0);
            	v_SUPPLY_CUR := GREATEST(LEAST(v_IMBALANCE-v_DYN_CUR, v_SUPPLY_MAX), 0);
            END IF;

			-- compute these assignments as deltas over existing assignments (including
			-- assumed minimum assignment)
			v_SUPPLY_CUR := v_SUPPLY_CUR+v_SUPPLY_MIN - v_SUPPLY_ASSIGNED;
			v_DYN_CUR := v_DYN_CUR+v_DYN_MIN - v_DYN_ASSIGNED;

			-- save assignments
			PUT_BALANCE_TX_SCHEDULE(p_SUPPLY_TRANSACTION_ID, p_LOAD_TRANSACTION_ID,
            						p_OPTION_ID, p_SCHEDULE_TYPE, v_CUR_DATE,
            						v_SUPPLY_CUR, v_SUPPLY_PRICE);
			PUT_BALANCE_TX_SCHEDULE(p_DYNAMIC_TRANSACTION_ID, p_LOAD_TRANSACTION_ID,
            						p_OPTION_ID, p_SCHEDULE_TYPE, v_CUR_DATE,
            						v_DYN_CUR, v_DYN_PRICE);
		END IF;

		v_CUR_DATE := v_CUR_DATE + 1/24;
	END LOOP;
END DEFAULT_EVALUATION;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_BALANCE_REPORT
	(
	p_SUPPLY_TRANSACTION_ID IN NUMBER,
	p_BALANCE_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
    p_SCHEDULE_DATE IN VARCHAR,
    p_SCHEDULE_TIME IN VARCHAR,
    p_DISP_SCHEDULED IN NUMBER,
    p_SUPPLY_PRICE IN NUMBER,
    p_ASSIGNED_AMOUNT IN NUMBER,
	p_IS_FIXED IN NUMBER,
	p_UPDATE_DEMAND IN NUMBER,
	p_DEMAND_AMOUNT IN NUMBER,
	p_IMBALANCE_PRICE IN NUMBER,
	p_STATUS OUT NUMBER
	) AS
v_SCHEDULE_TYPE NUMBER;
v_AMOUNT NUMBER;
BEGIN

	IF NOT CAN_WRITE(ITJ.g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(ITJ.g_MODULE_NAME);
	END IF;

	IF GA.ENABLE_SUPPLY_SCHEDULE_TYPES THEN
		v_SCHEDULE_TYPE := p_SCHEDULE_TYPE;
	ELSE
		v_SCHEDULE_TYPE := 0;
	END IF;

	p_STATUS := GA.SUCCESS;

    -- no contract terms used? then don't update IT_SCHEDULE.AMOUNT for supply schedules
    IF p_IS_FIXED = 1 THEN
		v_AMOUNT := NULL;
	ELSE
		v_AMOUNT := p_DISP_SCHEDULED;
	END IF;
    ITJ.SCHEDULE_UPDATE(p_SUPPLY_TRANSACTION_ID, v_SCHEDULE_TYPE, GA.INTERNAL_STATE, p_SCHEDULE_DATE, p_SCHEDULE_TIME,
				    p_AS_OF_DATE, p_TIME_ZONE, v_AMOUNT, p_SUPPLY_PRICE, p_STATUS, TRUE, p_ASSIGNED_AMOUNT, p_BALANCE_TRANSACTION_ID,
					g_BALANCING_ASSIGNMENT_TYPE);
    IF p_UPDATE_DEMAND = 1 THEN
	    -- if update demand, then the values table should have an additional entry for
    	-- the demand value
	    ITJ.SCHEDULE_UPDATE(p_BALANCE_TRANSACTION_ID, p_SCHEDULE_TYPE, GA.INTERNAL_STATE, p_SCHEDULE_DATE, p_SCHEDULE_TIME,
						    p_AS_OF_DATE, p_TIME_ZONE, p_DEMAND_AMOUNT, p_IMBALANCE_PRICE, p_STATUS);
    END IF;

END PUT_BALANCE_REPORT;
---------------------------------------------------------------------------------------------------
END LB;
/
