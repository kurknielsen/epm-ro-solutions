CREATE OR REPLACE PACKAGE PC AS
--Revision $Revision: 1.213 $

-- Product Costing Package --.

FUNCTION WHAT_VERSION RETURN VARCHAR;

PROCEDURE BILLING_STATEMENT_REQUEST
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_PSE_IDS IN NUMBER_COLLECTION,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_GENERATE_INVOICE IN NUMBER,
	p_TRACE_ON IN NUMBER,
	p_PROCESS_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	);

PROCEDURE BILLING_STATEMENT_REQUEST_E
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_GENERATE_INVOICE IN NUMBER,
	p_TRACE_ON IN NUMBER,
	p_PROCESS_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	);

PROCEDURE NET_RETAIL_POSITION_REQUEST
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_REQUEST_TYPE IN VARCHAR,
    p_STATEMENT_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_PROCESS_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	);

PROCEDURE POST_MARKET_PRICE_REQUEST
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_REQUEST_TYPE IN VARCHAR,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	);

PROCEDURE MARKET_PRICE_BASIS_REQUEST
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_REQUEST_TYPE IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	);

PROCEDURE GET_CHARGE_ID
	(
	p_BILLING_STATEMENT IN OUT BILLING_STATEMENT%ROWTYPE
	);

PROCEDURE GET_ENTITY_INVOICE_HEADER
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_SUBLEDGER_NUM OUT VARCHAR,
	p_BILLING_CONTACT OUT VARCHAR,
	p_BILLING_STREET OUT VARCHAR,
	p_BILLING_CITY OUT VARCHAR,
	p_BILLING_STATE_CODE OUT VARCHAR,
	p_BILLING_POSTAL_CODE OUT VARCHAR,
	p_BILLING_COUNTRY_CODE OUT VARCHAR,
	p_BILLING_PHONE OUT VARCHAR,
	p_BILLING_FAX OUT VARCHAR,
	p_INVOICE_TERMS OUT VARCHAR,
	p_PAY_CHECK_CONTACT OUT VARCHAR,
	p_PAY_CHECK_STREET OUT VARCHAR,
	p_PAY_CHECK_CITY OUT VARCHAR,
	p_PAY_CHECK_STATE_CODE OUT VARCHAR,
	p_PAY_CHECK_POSTAL_CODE OUT VARCHAR,
	p_PAY_CHECK_COUNTRY_CODE OUT VARCHAR,
	p_PAY_ELECTRONIC_DEBIT_NAME OUT VARCHAR,
	p_PAY_ELECTRONIC_DEBIT_NBR OUT VARCHAR,
	p_PAY_ELECTRONIC_CREDIT_NAME OUT VARCHAR,
	p_PAY_ELECTRONIC_CREDIT_NBR OUT VARCHAR,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	);

PROCEDURE PUT_ENTITY_INVOICE_HEADER
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_SUBLEDGER_NUM IN VARCHAR,
	p_BILLING_CONTACT IN VARCHAR,
	p_BILLING_STREET IN VARCHAR,
	p_BILLING_CITY IN VARCHAR,
	p_BILLING_STATE_CODE IN VARCHAR,
	p_BILLING_POSTAL_CODE IN VARCHAR,
	p_BILLING_COUNTRY_CODE IN VARCHAR,
	p_BILLING_PHONE IN VARCHAR,
	p_BILLING_FAX IN VARCHAR,
	p_INVOICE_TERMS IN VARCHAR,
	p_PAY_CHECK_CONTACT IN VARCHAR,
	p_PAY_CHECK_STREET IN VARCHAR,
	p_PAY_CHECK_CITY IN VARCHAR,
	p_PAY_CHECK_STATE_CODE IN VARCHAR,
	p_PAY_CHECK_POSTAL_CODE IN VARCHAR,
	p_PAY_CHECK_COUNTRY_CODE IN VARCHAR,
	p_PAY_ELECTRONIC_DEBIT_NAME IN VARCHAR,
	p_PAY_ELECTRONIC_DEBIT_NBR IN VARCHAR,
	p_PAY_ELECTRONIC_CREDIT_NAME IN VARCHAR,
	p_PAY_ELECTRONIC_CREDIT_NBR IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	);

PROCEDURE GET_INVOICE_HEADER
	(
	p_PRIMARY_CONTACT OUT VARCHAR,
   	p_PRIMARY_PHONE OUT VARCHAR,
	p_SECONDARY_CONTACT OUT VARCHAR,
	p_SECONDARY_PHONE OUT VARCHAR,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	);

PROCEDURE PUT_INVOICE_HEADER
	(
	p_PRIMARY_CONTACT IN VARCHAR,
   	p_PRIMARY_PHONE IN VARCHAR,
	p_SECONDARY_CONTACT IN VARCHAR,
	p_SECONDARY_PHONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	);

PROCEDURE GET_INVOICE
	(
	p_ENTITY_ID IN NUMBER,
	p_ENTITY_TYPE IN VARCHAR,
	p_STATEMENT_TYPE IN NUMBER,
	p_INVOICE_MONTH IN DATE,
	p_AS_OF_DATE IN DATE,
	p_INVOICE IN OUT INVOICE%ROWTYPE
	);

PROCEDURE GET_INVOICE
	(
	p_ENTITY_ID IN NUMBER,
	p_ENTITY_TYPE IN VARCHAR,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_INVOICE IN OUT INVOICE%ROWTYPE,
	p_CREATE_IF_NOT_FOUND BOOLEAN := TRUE
	);

PROCEDURE PUT_INVOICE
	(
	p_INVOICE IN OUT NOCOPY INVOICE%ROWTYPE
	);

PROCEDURE PUT_INVOICE_LINE_ITEM
	(
	p_INVOICE_LINE_ITEM IN OUT NOCOPY INVOICE_LINE_ITEM%ROWTYPE
	);

PROCEDURE PRIOR_BILLING_STATEMENT
	(
	p_PRIOR_CHARGE_ID IN NUMBER,
	p_BILLING_STATEMENT IN OUT BILLING_STATEMENT%ROWTYPE
	);

PROCEDURE PUT_BILLING_STATEMENT
	(
	p_BILLING_STATEMENT IN OUT BILLING_STATEMENT%ROWTYPE
	);

PROCEDURE PSE_BILLING_STATEMENT_CHARGE
	(
	p_BILLING_STATEMENT IN OUT BILLING_STATEMENT%ROWTYPE,
	p_CONTRACT_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_WEEK_BEGIN IN VARCHAR2,
	p_PSE_GROUP IN VARCHAR2 := NULL
	);

FUNCTION BEGIN_DATE_FOR_INTERVAL
	(
	p_DATE IN DATE,
	p_INTERVAL IN VARCHAR2,
	p_ENTITY_ID IN NUMBER,
	p_WEEK_BEGIN IN VARCHAR2
	) RETURN DATE;

FUNCTION END_DATE_FOR_INTERVAL
	(
	p_BEGIN_DATE IN DATE,
	p_INTERVAL IN VARCHAR2,
	p_ENTITY_ID IN NUMBER,
	p_WEEK_BEGIN IN VARCHAR2
	) RETURN DATE;

FUNCTION GET_CORRECT_STATEMENT_DATE
	(
    p_CALLING_MODULE IN VARCHAR,
    p_ENTITY_ID IN NUMBER,
    p_STATEMENT_DATE IN DATE,
    p_IS_DAY IN NUMBER := 1
    ) RETURN DATE;

FUNCTION GET_CORRECT_STATEMENT_END_DATE
	(
    p_CALLING_MODULE IN VARCHAR,
    p_ENTITY_ID IN NUMBER,
    p_STATEMENT_DATE IN DATE
    ) RETURN DATE;

FUNCTION GET_CORRECT_STATEMENT_DATE
	(
    p_CALLING_MODULE IN VARCHAR,
    p_ENTITY_ID IN NUMBER,
    p_STATEMENT_DATE IN VARCHAR,
    p_TIME_ZONE IN VARCHAR
    ) RETURN DATE;

PROCEDURE PRIOR_TRANSMISSION_CHARGE
	(
	p_PRIOR_CHARGE_ID IN NUMBER,
	p_TRANSMISSION_CHARGE IN OUT TRANSMISSION_CHARGE%ROWTYPE
	);

PROCEDURE PUT_TRANSMISSION_CHARGE
	(
	p_TRANSMISSION_CHARGE IN TRANSMISSION_CHARGE%ROWTYPE
	);

PROCEDURE PRIOR_FTR_CHARGE
	(
	p_PRIOR_CHARGE_ID IN NUMBER,
	p_FTR_CHARGE IN OUT FTR_CHARGE%ROWTYPE
	);

PROCEDURE PUT_FTR_CHARGE
	(
	p_FTR_CHARGE IN FTR_CHARGE%ROWTYPE
	);

PROCEDURE PRIOR_LMP_CHARGE
	(
	p_PRIOR_CHARGE_ID IN NUMBER,
	p_LMP_CHARGE IN OUT LMP_CHARGE%ROWTYPE
	);

PROCEDURE PUT_LMP_CHARGE
	(
	p_LMP_CHARGE IN LMP_CHARGE%ROWTYPE
	);

PROCEDURE PRIOR_FORMULA_CHARGE
	(
	p_PRIOR_CHARGE_ID IN NUMBER,
	p_FORMULA_CHARGE IN OUT FORMULA_CHARGE%ROWTYPE
	);

PROCEDURE PUT_FORMULA_CHARGE
	(
	p_FORMULA_CHARGE IN FORMULA_CHARGE%ROWTYPE
	);

PROCEDURE PUT_FORMULA_CHARGE_VAR
	(
	p_FORMULA_CHARGE_VAR IN FORMULA_CHARGE_VARIABLE%ROWTYPE
	);

PROCEDURE PUT_FORMULA_ITERATOR
	(
	p_FORMULA_CHARGE_ITERATOR IN FORMULA_CHARGE_ITERATOR%ROWTYPE
	);

PROCEDURE PUT_FORMULA_ITERATOR_NAMES
	(
	p_FORMULA_CHARGE_ITERATOR_NAME IN FORMULA_CHARGE_ITERATOR_NAME%ROWTYPE
	);

PROCEDURE PRIOR_COMBINATION_CHARGE
	(
	p_PRIOR_CHARGE_ID IN NUMBER,
	p_COMBINATION_CHARGE IN OUT COMBINATION_CHARGE%ROWTYPE
	);

PROCEDURE PUT_COMBINATION_CHARGE
	(
	p_COMBINATION_CHARGE IN COMBINATION_CHARGE%ROWTYPE
	);

FUNCTION GET_PRIOR_CHARGE_ID
	(
	p_BILLING_STATEMENT IN BILLING_STATEMENT%ROWTYPE
	) RETURN NUMBER;

FUNCTION GET_PRIOR_CHARGE_ID
	(
	p_CHARGE_ID IN NUMBER
	) RETURN NUMBER;

FUNCTION GET_WEIGHT_AVG_LMP_PRICE
	(
	p_IS_NET_LOAD IN NUMBER,
	p_BILATERAL_SIGN IN NUMBER,
	p_CONTRACT_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_MARKET_TYPE IN VARCHAR,
	p_MARKET_PRICE_TYPE IN VARCHAR,
	p_SERVICE_DATE IN DATE,
	p_PRICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE
	) RETURN NUMBER;

FUNCTION GET_BILL_CALC_GROUP
	(
	p_PSE_ID IN NUMBER,
	p_DATE IN DATE
	) RETURN VARCHAR2;

FUNCTION GET_CHARGE_AMOUNT
	(
	p_ENTITY_ID	IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_COMPONENT_NAME IN VARCHAR2
	) RETURN NUMBER;

TYPE COMPONENT_BAND_TABLE IS TABLE OF COMPONENT_IMBALANCE_BAND%ROWTYPE INDEX BY BINARY_INTEGER;

TYPE MARKET_PRICE_RECORD IS RECORD
	(
	UNDER_UNDER_PRICE	NUMBER(12,4),
	UNDER_OVER_PRICE	NUMBER(12,4),
	OVER_UNDER_PRICE	NUMBER(12,4),
	OVER_OVER_PRICE	NUMBER(12,4),
	PRICE_DATE		DATE
	);

TYPE MARKET_PRICE_TABLE IS TABLE OF MARKET_PRICE_RECORD INDEX BY BINARY_INTEGER;

TYPE NET_POSITION_RECORD IS RECORD
	(
	DEMAND		NUMBER(12,4),
	SUPPLY		NUMBER(12,4),
	POSITION		NUMBER(12,4),
	SCHEDULE_DATE	DATE
	);

TYPE NET_POSITION_TABLE IS TABLE OF NET_POSITION_RECORD INDEX BY BINARY_INTEGER;

TYPE GENERATION_POSITION_RECORD IS RECORD
	(
	PLANNED		NUMBER(12,4),
	ACTUAL		NUMBER(12,4),
	POSITION		NUMBER(12,4),
	SCHEDULE_DATE	DATE
	);

TYPE GENERATION_POSITION_TABLE IS TABLE OF GENERATION_POSITION_RECORD INDEX BY BINARY_INTEGER;

TYPE SUPPLY_POSITION_RECORD IS RECORD
	(
	UNDER_SUPPLY	NUMBER(12,4),
	OVER_SUPPLY	NUMBER(12,4),
	POSITION		NUMBER(12,4),
	SCHEDULE_DATE	DATE
	);

TYPE SUPPLY_POSITION_TABLE IS TABLE OF SUPPLY_POSITION_RECORD INDEX BY BINARY_INTEGER;

TYPE ACCOUNT_PEAK_ENERGY_RECORD IS RECORD
	(
	ACCOUNT_ID	NUMBER(9),
	PEAK		NUMBER(12,4),
	PEAK_DATE	DATE,
	ENERGY		NUMBER(12,4),
	PSE_OF_RECORD   NUMBER(9)
	);

TYPE ACCOUNT_PEAK_ENERGY_TABLE IS TABLE OF ACCOUNT_PEAK_ENERGY_RECORD INDEX BY BINARY_INTEGER;

g_ACCOUNT_PEAK_AND_ENERGY ACCOUNT_PEAK_ENERGY_TABLE;

g_NOT_ASSIGNED NUMBER(1) := 0;
g_ALL NUMBER(2) := -1;
g_NO_SUB_TYPE CHAR(1) := '?';
g_SUPPRESS_ZERO_COSTS BOOLEAN := TRUE;
g_UNKNOWN NUMBER(4) := -999;
g_ENABLE_SUPPLY_SCHEDULE_TYPES NUMBER(1);

g_STATUS_PENDING VARCHAR2(16) := 'Pending';
g_STATUS_ERROR VARCHAR2(16) := 'Error';

-- Calling Modules. (deprecated)
g_SCHEDULING CHAR(1) := 'B';

g_CONTACT_NAME VARCHAR(32);
g_CONTACT_ALIAS VARCHAR(32);
g_WORK_PHONE VARCHAR(24);
g_HOME_PHONE VARCHAR(24);
g_FAX_PHONE VARCHAR(24);
g_CELL_PHONE VARCHAR(24);
g_EMAIL_ADDRESS VARCHAR(64);
g_STREET VARCHAR(32);
g_CITY VARCHAR(32);
g_STATE_CODE VARCHAR(2);
g_POSTAL_CODE VARCHAR(16);
g_ATTRIBUTE_VAL VARCHAR(128);
g_STATUS NUMBER;
g_INCUMBENT_TYPE VARCHAR(3);
g_INCUMBENT_NAME VARCHAR(32);
g_INCUMBENT_ALIAS VARCHAR(32);
g_INCUMBENT_ID NUMBER;
g_STRING CHAR(6) := 'String';
g_PSE CHAR(3) := 'PSE';
g_POOL CHAR(4) := 'POOL';
g_BILL_PARTY CHAR(10) := 'BILL_PARTY';
g_ANY_EVENT NUMBER(1) := 1;
g_NONE_EVENT NUMBER(1) := 2;
g_PLAN NUMBER(1) := 1;
g_PRELIMINARY NUMBER(1) := 2;
g_FINAL NUMBER(1) := 3;
g_CUSTOMER_USAGE_WRF_CALENDAR NUMBER(1) := 1;
-- MISO needs no hyphens here
--g_DAY_AHEAD VARCHAR2(32) := 'Day-Ahead';
--g_REAL_TIME VARCHAR2(32) := 'Real-Time';
g_DAY_AHEAD VARCHAR2(32) := 'DayAhead';
g_REAL_TIME VARCHAR2(32) := 'RealTime';

g_LMP_INCLUDE_ALL VARCHAR2(16) := 'All';
g_LMP_INCLUDE_NONE VARCHAR2(16) := 'None';
g_LMP_INCLUDE_INTERNAL VARCHAR2(16) := 'Internal Only';
g_LMP_INCLUDE_EXTERNAL VARCHAR2(16) := 'External Only';

g_LMP_CHARGE_ALL VARCHAR2(16) := 'Either';
g_LMP_CHARGE_GENERATION VARCHAR2(16) := 'Net Generation';
g_LMP_CHARGE_LOAD VARCHAR2(16) := 'Net Load';

g_LMP_ACTUAL_PRICE VARCHAR2(32) := 'Actual';
g_LMP_WEIGHT_AVG_PRICE VARCHAR2(32) := 'Weighted Average';
g_LMP_ACT_MINUS_AVG_PRICE VARCHAR2(32) := 'Actual-Weighted Average';

g_COMPONENT_HISTORY GA.ID_TABLE;

g_DELETING_TEMP_ROW BOOLEAN := FALSE;

TYPE HASH_OF_NUMBERS IS TABLE OF NUMBER INDEX BY VARCHAR2(32);

END PC;
/
CREATE OR REPLACE PACKAGE BODY PC AS
---------------------------------------------------------------------------------------------------
g_DO_NET_POSITION BOOLEAN := FALSE;

g_LAST_FORMULA_CHARGE_ID 	FORMULA_CHARGE.CHARGE_ID%TYPE;
g_LAST_FORMULA_ITERATOR_ID	FORMULA_CHARGE.ITERATOR_ID%TYPE;
g_LAST_FORMULA_CHARGE_DATE 	FORMULA_CHARGE.CHARGE_DATE%TYPE;
---------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
    RETURN '$Revision: 1.213 $';
END WHAT_VERSION;
---------------------------------------------------------------------------------------------------
FUNCTION BEGIN_DATE_FOR_INTERVAL
	(
	p_DATE IN DATE,
	p_INTERVAL IN VARCHAR2,
	p_ENTITY_ID IN NUMBER,
	p_WEEK_BEGIN IN VARCHAR2
	) RETURN DATE IS
BEGIN
	IF p_INTERVAL = 'Custom' THEN
    	-- custom interval
        DECLARE
        	v_DATE DATE;
		BEGIN
        	SELECT BEGIN_DATE INTO v_DATE
            FROM PSE_CUSTOM_INVOICE
            WHERE PSE_ID = p_ENTITY_ID
            	AND p_DATE BETWEEN BEGIN_DATE AND END_DATE;
			RETURN v_DATE;
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
            	RETURN p_DATE;
		END;
	ELSE
		-- use DATE_UTIL to determine appropriate begin date
		RETURN DATE_UTIL.BEGIN_DATE_FOR_INTERVAL(p_DATE, p_INTERVAL, p_WEEK_BEGIN);
	END IF;
END BEGIN_DATE_FOR_INTERVAL;
---------------------------------------------------------------------------------------------------
FUNCTION END_DATE_FOR_INTERVAL
	(
	p_BEGIN_DATE IN DATE,
	p_INTERVAL IN VARCHAR2,
	p_ENTITY_ID IN NUMBER,
	p_WEEK_BEGIN IN VARCHAR2
	) RETURN DATE IS
BEGIN
	IF p_INTERVAL = 'Custom' THEN
    	-- custom interval
        DECLARE
        	v_DATE DATE;
		BEGIN
        	SELECT END_DATE INTO v_DATE
            FROM PSE_CUSTOM_INVOICE
            WHERE PSE_ID = p_ENTITY_ID
            	AND BEGIN_DATE = p_BEGIN_DATE;
			RETURN v_DATE;
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
            	RETURN p_BEGIN_DATE;
		END;
	ELSE
		-- use DATE_UTIL to determine appropriate begin date
		RETURN DATE_UTIL.END_DATE_FOR_INTERVAL(p_BEGIN_DATE, p_INTERVAL, p_WEEK_BEGIN);
	END IF;
END END_DATE_FOR_INTERVAL;
---------------------------------------------------------------------------------------------------
FUNCTION GET_CORRECT_STATEMENT_DATE
	(
    p_CALLING_MODULE IN VARCHAR,
    p_ENTITY_ID IN NUMBER,
    p_STATEMENT_DATE IN DATE,
    p_IS_DAY IN NUMBER := 1
    ) RETURN DATE IS
v_TZ VARCHAR2(16);
v_WEEK_BEGIN VARCHAR2(16);
v_INTERVAL VARCHAR2(32);
v_STATEMENT_DATE DATE := p_STATEMENT_DATE;
BEGIN
 	IF p_IS_DAY = 0 THEN
    	v_STATEMENT_DATE := p_STATEMENT_DATE-1/86400;
    END IF;

 	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) <> g_SCHEDULING THEN
		v_STATEMENT_DATE := TRUNC(v_STATEMENT_DATE, 'MONTH');
	ELSE
    	BEGIN
        	SELECT NVL(TIME_ZONE,GA.LOCAL_TIME_ZONE),
            	NVL(STATEMENT_INTERVAL,'Month'),
            	NVL(WEEK_BEGIN,'First of Month')
			INTO v_TZ, v_INTERVAL, v_WEEK_BEGIN
            FROM PURCHASING_SELLING_ENTITY
            WHERE PSE_ID = p_ENTITY_ID;
        EXCEPTION
        	WHEN NO_DATA_FOUND THEN
            	v_TZ := GA.LOCAL_TIME_ZONE;
                v_INTERVAL := 'Month';
                v_WEEK_BEGIN := 'First of Month';
        END;
        IF p_IS_DAY = 1 THEN
        	v_STATEMENT_DATE := TRUNC(v_STATEMENT_DATE);
		ELSE
	        v_STATEMENT_DATE := FROM_CUT(v_STATEMENT_DATE,v_TZ);
        END IF;
        v_STATEMENT_DATE := BEGIN_DATE_FOR_INTERVAL(v_STATEMENT_DATE,v_INTERVAL,p_ENTITY_ID,v_WEEK_BEGIN);
	END IF;

    RETURN v_STATEMENT_DATE;
END GET_CORRECT_STATEMENT_DATE;
---------------------------------------------------------------------------------------------------
FUNCTION GET_CORRECT_STATEMENT_END_DATE
	(
    p_CALLING_MODULE IN VARCHAR,
    p_ENTITY_ID IN NUMBER,
    p_STATEMENT_DATE IN DATE
    ) RETURN DATE IS
v_WEEK_BEGIN VARCHAR2(16);
v_INTERVAL VARCHAR2(32);
v_STATEMENT_DATE DATE := p_STATEMENT_DATE;
BEGIN
 	IF UPPER(SUBSTR(p_CALLING_MODULE,1,1)) <> g_SCHEDULING THEN
		v_STATEMENT_DATE := LAST_DAY(TRUNC(v_STATEMENT_DATE, 'MONTH'));
	ELSE
    	BEGIN
        	SELECT NVL(STATEMENT_INTERVAL,'Month'),
            	NVL(WEEK_BEGIN,'First of Month')
			INTO v_INTERVAL, v_WEEK_BEGIN
            FROM PURCHASING_SELLING_ENTITY
            WHERE PSE_ID = p_ENTITY_ID;
        EXCEPTION
        	WHEN NO_DATA_FOUND THEN
                v_INTERVAL := 'Month';
                v_WEEK_BEGIN := 'First of Month';
        END;
      	v_STATEMENT_DATE := TRUNC(v_STATEMENT_DATE);
        v_STATEMENT_DATE := BEGIN_DATE_FOR_INTERVAL(v_STATEMENT_DATE,v_INTERVAL,p_ENTITY_ID,v_WEEK_BEGIN);
        v_STATEMENT_DATE := END_DATE_FOR_INTERVAL(v_STATEMENT_DATE,v_INTERVAL,p_ENTITY_ID,v_WEEK_BEGIN);
	END IF;

    RETURN v_STATEMENT_DATE;
END GET_CORRECT_STATEMENT_END_DATE;
---------------------------------------------------------------------------------------------------
FUNCTION GET_CORRECT_STATEMENT_DATE
	(
    p_CALLING_MODULE IN VARCHAR,
    p_ENTITY_ID IN NUMBER,
    p_STATEMENT_DATE IN VARCHAR,
    p_TIME_ZONE IN VARCHAR
    ) RETURN DATE IS
v_DATE_STR VARCHAR(16);
v_TIME_STR VARCHAR(16);
v_STATEMENT_DATE DATE;
v_IS_DAY NUMBER(1);
BEGIN
	v_DATE_STR := SUBSTR(LTRIM(RTRIM(p_STATEMENT_DATE)),1,10);
	v_TIME_STR := SUBSTR(LTRIM(RTRIM(p_STATEMENT_DATE)),12);

    v_STATEMENT_DATE := DATE_TIME_AS_CUT(v_DATE_STR,v_TIME_STR,p_TIME_ZONE,1);

    IF TRIM(v_TIME_STR) IS NULL THEN
    	v_IS_DAY := 1;
    ELSE
    	v_IS_DAY := 0;
	END IF;

    RETURN GET_CORRECT_STATEMENT_DATE(p_CALLING_MODULE,p_ENTITY_ID,v_STATEMENT_DATE,v_IS_DAY);
END GET_CORRECT_STATEMENT_DATE;
---------------------------------------------------------------------------------------------------
FUNCTION GET_MARKET_PRICE_ID
	(
	p_MARKET_PRICE_TYPE VARCHAR,
	p_SERVICE_POINT_TYPE IN VARCHAR
	) RETURN NUMBER IS

v_MARKET_PRICE_ID NUMBER;

BEGIN

	 SELECT MARKET_PRICE_ID
	 INTO v_MARKET_PRICE_ID
	 FROM MARKET_PRICE
	 WHERE UPPER(MARKET_PRICE_TYPE) = UPPER(p_MARKET_PRICE_TYPE)
		AND UPPER(SERVICE_POINT_TYPE) = UPPER(p_SERVICE_POINT_TYPE)
		AND ROWNUM = 1;

	RETURN v_MARKET_PRICE_ID;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN g_NOT_ASSIGNED;

END GET_MARKET_PRICE_ID;
---------------------------------------------------------------------------------------------------
FUNCTION GET_PSE_BILLING_ENTITY_ID
	(
	p_CONTRACT_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_PSE_IS_RETAIL_AGGREGATOR IN NUMBER DEFAULT 1
	) RETURN NUMBER IS

v_PSE_ID NUMBER;

BEGIN

	SELECT PSE_ID
	INTO v_PSE_ID
	FROM INTERCHANGE_CONTRACT A, PURCHASING_SELLING_ENTITY B
	WHERE A.CONTRACT_ID = p_CONTRACT_ID
		AND TRUNC(p_SERVICE_DATE) BETWEEN A.BEGIN_DATE AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE)
		AND B.PSE_ID = A.BILLING_ENTITY_ID
		AND UPPER(SUBSTR(B.PSE_STATUS,1,1)) = 'A'
		AND UPPER(SUBSTR(B.PSE_TYPE,1,1)) = 'M'
		AND B.PSE_IS_RETAIL_AGGREGATOR = DECODE(p_PSE_IS_RETAIL_AGGREGATOR,1,1,B.PSE_IS_RETAIL_AGGREGATOR)
	 	AND ROWNUM = 1;

	RETURN v_PSE_ID;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN g_NOT_ASSIGNED;

END GET_PSE_BILLING_ENTITY_ID;
---------------------------------------------------------------------------------------------------
PROCEDURE FILL_MARKET_PRICE_TABLE
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_MARKET_PRICE_TABLE IN OUT MARKET_PRICE_TABLE
	) AS

v_INDEX BINARY_INTEGER := 0;
v_DATE DATE := p_BEGIN_DATE;

BEGIN

	p_MARKET_PRICE_TABLE.DELETE;

	WHILE v_DATE <= p_END_DATE LOOP
		p_MARKET_PRICE_TABLE(v_INDEX).UNDER_UNDER_PRICE := 0;
		p_MARKET_PRICE_TABLE(v_INDEX).UNDER_OVER_PRICE := 0;
		p_MARKET_PRICE_TABLE(v_INDEX).OVER_UNDER_PRICE := 0;
		p_MARKET_PRICE_TABLE(v_INDEX).OVER_OVER_PRICE := 0;
		v_DATE := ADD_HOURS_TO_DATE(v_DATE,1);
		v_INDEX := v_INDEX + 1;
	END LOOP;

END FILL_MARKET_PRICE_TABLE;
----------------------------------------------------------------------------------------------------
PROCEDURE FILL_GENERATION_POSITION_TABLE
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_GENERATION_POSITION_TABLE IN OUT GENERATION_POSITION_TABLE
	) AS

v_INDEX BINARY_INTEGER := 0;
v_DATE DATE := p_BEGIN_DATE;

BEGIN

	p_GENERATION_POSITION_TABLE.DELETE;

	WHILE v_DATE <= p_END_DATE LOOP
		p_GENERATION_POSITION_TABLE(v_INDEX).PLANNED := 0;
	 	p_GENERATION_POSITION_TABLE(v_INDEX).ACTUAL := 0;
	 	p_GENERATION_POSITION_TABLE(v_INDEX).POSITION := 0;
	 	p_GENERATION_POSITION_TABLE(v_INDEX).SCHEDULE_DATE := v_DATE;
		v_DATE := ADD_HOURS_TO_DATE(v_DATE,1);
		v_INDEX := v_INDEX + 1;
	END LOOP;

END FILL_GENERATION_POSITION_TABLE;
----------------------------------------------------------------------------------------------------
PROCEDURE FILL_NET_POSITION_TABLE
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_NET_POSITION_TABLE IN OUT NET_POSITION_TABLE,
	p_INTERVAL IN CHAR DEFAULT 'D'
	) AS

v_INDEX BINARY_INTEGER := 0;
v_DATE DATE := p_BEGIN_DATE;

BEGIN

	p_NET_POSITION_TABLE.DELETE;

	WHILE v_DATE <= p_END_DATE LOOP
		p_NET_POSITION_TABLE(v_INDEX).SUPPLY := 0;
	 	p_NET_POSITION_TABLE(v_INDEX).DEMAND := 0;
	 	p_NET_POSITION_TABLE(v_INDEX).POSITION := 0;
	 	p_NET_POSITION_TABLE(v_INDEX).SCHEDULE_DATE := v_DATE;
		v_DATE := ADD_HOURS_TO_DATE(v_DATE,1);
		v_INDEX := v_INDEX + 1;
	END LOOP;

END FILL_NET_POSITION_TABLE;
----------------------------------------------------------------------------------------------------
PROCEDURE FILL_SUPPLY_POSITION_TABLE
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SUPPLY_POSITION_TABLE IN OUT SUPPLY_POSITION_TABLE
	) AS

v_INDEX BINARY_INTEGER := 0;
v_DATE DATE := p_BEGIN_DATE;

BEGIN

	p_SUPPLY_POSITION_TABLE.DELETE;
	WHILE v_DATE <= p_END_DATE LOOP
	 	p_SUPPLY_POSITION_TABLE(v_INDEX).UNDER_SUPPLY := 0;
		p_SUPPLY_POSITION_TABLE(v_INDEX).OVER_SUPPLY := 0;
	 	p_SUPPLY_POSITION_TABLE(v_INDEX).POSITION := 0;
	 	p_SUPPLY_POSITION_TABLE(v_INDEX).SCHEDULE_DATE := v_DATE;
		v_DATE := ADD_HOURS_TO_DATE(v_DATE,1);
		v_INDEX := v_INDEX + 1;
	END LOOP;

END FILL_SUPPLY_POSITION_TABLE;
----------------------------------------------------------------------------------------------------
PROCEDURE UPDATE_DISPUTE_FLAGS
	(
	p_ENTITY_IDs IN NUMBER_COLLECTION,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATEMENT_TYPE IN NUMBER
	) AS
v_ROW_COUNT NUMBER := 0;
v_IDX BINARY_INTEGER;
v_ID NUMBER;
BEGIN
	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('UPDATE_DISPUTE_FLAGS:');
		LOGS.LOG_DEBUG('  ENTITY_ID = '||TEXT_UTIL.TO_CHAR_ENTITY_LIST(p_ENTITY_IDs,EC.ED_PSE));
		LOGS.LOG_DEBUG('  BEGIN_DATE = '||TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('  END_DATE = '||TEXT_UTIL.TO_CHAR_DATE(p_END_DATE));
		LOGS.LOG_DEBUG('  STATEMENT_TYPE = '||TEXT_UTIL.TO_CHAR_ENTITY(p_STATEMENT_TYPE, EC.ED_STATEMENT_TYPE));
	END IF;

	v_IDX := p_ENTITY_IDs.FIRST;
	WHILE p_ENTITY_IDs.EXISTS(v_IDX) LOOP
		v_ID := p_ENTITY_IDs(v_IDX);
    	-- dummy update so that trigger will re-update billing statement
    	-- with in dispute flags
    	UPDATE BILLING_CHARGE_DISPUTE
    	SET DISPUTE_STATUS = DISPUTE_STATUS
    	WHERE (v_ID = SD.g_ALL_DATA_ENTITY_ID OR ENTITY_ID = v_ID)
    		AND STATEMENT_TYPE = p_STATEMENT_TYPE
    		AND STATEMENT_STATE = GA.INTERNAL_STATE
    		AND STATEMENT_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE;

    	v_ROW_COUNT := v_ROW_COUNT + SQL%ROWCOUNT;

		v_IDX := p_ENTITY_IDs.NEXT(v_IDX);
	END LOOP;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('  - Updated '||v_ROW_COUNT||' row(s)');
	END IF;
END UPDATE_DISPUTE_FLAGS;
----------------------------------------------------------------------------------------------------
PROCEDURE UPDATE_DISPUTE_FLAGS
	(
	p_ENTITY_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATEMENT_TYPE IN NUMBER
	) AS
v_IDs NUMBER_COLLECTION;
BEGIN
	IF p_ENTITY_ID = g_ALL THEN
		v_IDs := NUMBER_COLLECTION(SD.g_ALL_DATA_ENTITY_ID);
	ELSE
		v_IDs := NUMBER_COLLECTION(p_ENTITY_ID);
	END IF;
	UPDATE_DISPUTE_FLAGS (v_IDs, p_BEGIN_DATE, p_END_DATE, p_STATEMENT_TYPE);
END UPDATE_DISPUTE_FLAGS;
----------------------------------------------------------------------------------------------------
PROCEDURE TRACE_NET_POSITION
	(
	p_NET_POSITION_TABLE IN NET_POSITION_TABLE
	) AS

v_INDEX BINARY_INTEGER;

BEGIN

	IF p_NET_POSITION_TABLE.COUNT >0 THEN
		FOR v_INDEX IN p_NET_POSITION_TABLE.FIRST..p_NET_POSITION_TABLE.LAST LOOP
			IF p_NET_POSITION_TABLE.EXISTS(v_INDEX) THEN
				IF v_INDEX = p_NET_POSITION_TABLE.FIRST THEN
					LOGS.LOG_DEBUG('TRACE_NET_POSITION');
					LOGS.LOG_DEBUG('<supply>,<demand>,<position>,<date>@<index>');
				END IF;
				LOGS.LOG_DEBUG(TO_CHAR(p_NET_POSITION_TABLE(v_INDEX).SUPPLY) || ',' ||
					TO_CHAR(p_NET_POSITION_TABLE(v_INDEX).DEMAND) || ',' ||
					TO_CHAR(p_NET_POSITION_TABLE(v_INDEX).POSITION) || ',' ||
					TEXT_UTIL.TO_CHAR_TIME(p_NET_POSITION_TABLE(v_INDEX).SCHEDULE_DATE) || '@' ||
					TO_CHAR(v_INDEX));
			ELSE
				LOGS.LOG_DEBUG('missing value at ' || TO_CHAR(v_INDEX));
			END IF;
		END LOOP;
	END IF;

END TRACE_NET_POSITION;
---------------------------------------------------------------------------------------------------
PROCEDURE TRACE_GENERATION_POSITION
	(
	p_GENERATION_POSITION_TABLE IN GENERATION_POSITION_TABLE
	) AS

v_INDEX BINARY_INTEGER;

BEGIN
	IF p_GENERATION_POSITION_TABLE.COUNT >0 THEN
		FOR v_INDEX IN p_GENERATION_POSITION_TABLE.FIRST..p_GENERATION_POSITION_TABLE.LAST LOOP
			IF p_GENERATION_POSITION_TABLE.EXISTS(v_INDEX) THEN
				IF v_INDEX = p_GENERATION_POSITION_TABLE.FIRST THEN
					LOGS.LOG_DEBUG('TRACE_GENERATION_POSITION');
					LOGS.LOG_DEBUG('<planned>,<actual>,<position>,<date>@<index>');
				END IF;
				LOGS.LOG_DEBUG(TO_CHAR(p_GENERATION_POSITION_TABLE(v_INDEX).PLANNED) || ',' ||
					TO_CHAR(p_GENERATION_POSITION_TABLE(v_INDEX).ACTUAL) || ',' ||
					TO_CHAR(p_GENERATION_POSITION_TABLE(v_INDEX).POSITION) || ',' ||
					TEXT_UTIL.TO_CHAR_TIME(p_GENERATION_POSITION_TABLE(v_INDEX).SCHEDULE_DATE) || '@' ||
					TO_CHAR(v_INDEX));
			ELSE
				LOGS.LOG_DEBUG('missing value at ' || TO_CHAR(v_INDEX));
			END IF;
		END LOOP;
	END IF;

END TRACE_GENERATION_POSITION;
---------------------------------------------------------------------------------------------------
PROCEDURE TRACE_SUPPLY_POSITION
	(
	p_SUPPLY_POSITION_TABLE IN SUPPLY_POSITION_TABLE
	) AS

v_INDEX BINARY_INTEGER;

BEGIN

	IF p_SUPPLY_POSITION_TABLE.COUNT >0 THEN
		FOR v_INDEX IN p_SUPPLY_POSITION_TABLE.FIRST..p_SUPPLY_POSITION_TABLE.LAST LOOP
			IF p_SUPPLY_POSITION_TABLE.EXISTS(v_INDEX) THEN
				IF v_INDEX = p_SUPPLY_POSITION_TABLE.FIRST THEN
					LOGS.LOG_DEBUG('TRACE_SUPPLY_POSITION');
					LOGS.LOG_DEBUG('<over supply>,<under supply>,<position>,<date>@<index>');
				END IF;
				LOGS.LOG_DEBUG(TO_CHAR(p_SUPPLY_POSITION_TABLE(v_INDEX).OVER_SUPPLY) || ',' ||
					TO_CHAR(p_SUPPLY_POSITION_TABLE(v_INDEX).UNDER_SUPPLY) || ',' ||
					TO_CHAR(p_SUPPLY_POSITION_TABLE(v_INDEX).POSITION) || ',' ||
					TEXT_UTIL.TO_CHAR_TIME(p_SUPPLY_POSITION_TABLE(v_INDEX).SCHEDULE_DATE) || '@' ||
					TO_CHAR(v_INDEX));
			ELSE
				LOGS.LOG_DEBUG('missing value at ' || TO_CHAR(v_INDEX));
			END IF;
		END LOOP;
	END IF;

END TRACE_SUPPLY_POSITION;
---------------------------------------------------------------------------------------------------
PROCEDURE TRACE_MARKET_PRICES
	(
	p_MARKET_PRICE_TABLE IN MARKET_PRICE_TABLE
	) AS

v_INDEX BINARY_INTEGER;

BEGIN

	IF p_MARKET_PRICE_TABLE.COUNT > 0 THEN
		FOR v_INDEX IN p_MARKET_PRICE_TABLE.FIRST..p_MARKET_PRICE_TABLE.LAST LOOP
			IF p_MARKET_PRICE_TABLE.EXISTS(v_INDEX) THEN
				IF v_INDEX = p_MARKET_PRICE_TABLE.FIRST THEN
					LOGS.LOG_DEBUG_DETAIL('TRACE_MARKET_PRICES');
					LOGS.LOG_DEBUG_DETAIL('<under under>,<under over>,<over under>,<over over>@(<index>)<date>');
				END IF;
				LOGS.LOG_DEBUG_DETAIL(TO_CHAR(p_MARKET_PRICE_TABLE(v_INDEX).UNDER_UNDER_PRICE) || ',' ||
					TO_CHAR(p_MARKET_PRICE_TABLE(v_INDEX).UNDER_OVER_PRICE) || ',' ||
					TO_CHAR(p_MARKET_PRICE_TABLE(v_INDEX).OVER_UNDER_PRICE) || ',' ||
					TO_CHAR(p_MARKET_PRICE_TABLE(v_INDEX).OVER_OVER_PRICE) || '@(' ||
					TO_CHAR(v_INDEX) || ')' || TEXT_UTIL.TO_CHAR_TIME(p_MARKET_PRICE_TABLE(v_INDEX).PRICE_DATE));
			ELSE
				LOGS.LOG_DEBUG_DETAIL('missing value at ' || TO_CHAR(v_INDEX));
			END IF;
		END LOOP;
	END IF;

END TRACE_MARKET_PRICES;
---------------------------------------------------------------------------------------------------
PROCEDURE TRACE_TABLE
	(
	p_NAME IN VARCHAR,
	p_TABLE IN GA.NUMBER_TABLE
	) AS

v_INDEX BINARY_INTEGER;

BEGIN

	IF p_TABLE.COUNT >0 THEN
		FOR v_INDEX IN p_TABLE.FIRST..p_TABLE.LAST LOOP
			IF p_TABLE.EXISTS(v_INDEX) THEN
				IF v_INDEX =  p_TABLE.FIRST THEN
					LOGS.LOG_DEBUG('TRACE: ' || p_NAME);
					LOGS.LOG_DEBUG('<value>@<index>');
				END IF;
				LOGS.LOG_DEBUG(TO_CHAR(p_TABLE(v_INDEX)) || '@' || TO_CHAR(v_INDEX));
			ELSE
				LOGS.LOG_DEBUG('missing value at ' || TO_CHAR(v_INDEX));
			END IF;
		END LOOP;
	END IF;
END TRACE_TABLE;
---------------------------------------------------------------------------------------------------
PROCEDURE TRACE_COMPONENT_BAND
	(
	p_COMPONENT_BAND_TABLE IN COMPONENT_BAND_TABLE
	) AS

v_INDEX BINARY_INTEGER;

BEGIN

	IF p_COMPONENT_BAND_TABLE.COUNT > 0 THEN
		FOR v_INDEX IN p_COMPONENT_BAND_TABLE.FIRST..p_COMPONENT_BAND_TABLE.LAST LOOP
			IF p_COMPONENT_BAND_TABLE.EXISTS(v_INDEX) THEN
				IF v_INDEX =  p_COMPONENT_BAND_TABLE.FIRST THEN
					LOGS.LOG_DEBUG('TRACE_COMPONENT_BAND');
					LOGS.LOG_DEBUG('<type>,<number>,<minimum>,<threshold>,<multiplier>@<index>');
				END IF;
				LOGS.LOG_DEBUG(p_COMPONENT_BAND_TABLE(v_INDEX).BAND_TYPE || ',' ||
					TO_CHAR(p_COMPONENT_BAND_TABLE(v_INDEX).BAND_NUMBER) || ',' ||
					TO_CHAR(p_COMPONENT_BAND_TABLE(v_INDEX).BAND_MINIMUM) || ',' ||
					TO_CHAR(p_COMPONENT_BAND_TABLE(v_INDEX).BAND_THRESHOLD) || ',' ||
					TO_CHAR(p_COMPONENT_BAND_TABLE(v_INDEX).BAND_MULTIPLIER) || '@' ||
					TO_CHAR(v_INDEX));
			ELSE
				LOGS.LOG_DEBUG('missing value at ' || TO_CHAR(v_INDEX));
			END IF;
		END LOOP;
	END IF;

END TRACE_COMPONENT_BAND;
---------------------------------------------------------------------------------------------------
PROCEDURE TRACE_CONTACT
	(
	p_CONTACT_NAME IN VARCHAR,
	p_CONTACT_ALIAS IN VARCHAR,
	p_WORK_PHONE IN VARCHAR,
	p_HOME_PHONE IN VARCHAR,
	p_FAX_PHONE IN VARCHAR,
	p_CELL_PHONE IN VARCHAR,
	p_EMAIL_ADDRESS IN VARCHAR
	) AS

BEGIN

	LOGS.LOG_DEBUG(' CONTACT=' || p_CONTACT_NAME || ',' || p_CONTACT_NAME || ',' || p_CONTACT_ALIAS || ',' || p_WORK_PHONE || ',' || p_HOME_PHONE || ',' || p_FAX_PHONE || ',' || p_CELL_PHONE || ',' || p_EMAIL_ADDRESS);

END TRACE_CONTACT;
---------------------------------------------------------------------------------------------------
PROCEDURE TRACE_ADDRESS
	(
	p_STREET IN VARCHAR,
	p_CITY  IN VARCHAR,
	p_STATE_CODE IN VARCHAR,
	p_POSTAL_CODE IN VARCHAR,
	p_COUNTRY_CODE IN VARCHAR
	) AS

BEGIN

	LOGS.LOG_DEBUG(' ADDRESS=' || p_STREET || ',' || p_CITY || ',' || p_STATE_CODE || ',' || p_POSTAL_CODE || ',' || p_COUNTRY_CODE);

END TRACE_ADDRESS;
---------------------------------------------------------------------------------------------------
PROCEDURE TRACE_ACCOUNT_PEAK_AND_ENERGY AS

v_INDEX BINARY_INTEGER;

BEGIN

	IF g_ACCOUNT_PEAK_AND_ENERGY.COUNT = 0 THEN
		LOGS.LOG_DEBUG('ACCOUNT_PEAK_AND_ENERGY TABLE IS EMPTY');
	END IF;

	FOR v_INDEX IN g_ACCOUNT_PEAK_AND_ENERGY.FIRST..g_ACCOUNT_PEAK_AND_ENERGY.LAST LOOP
		IF v_INDEX = g_ACCOUNT_PEAK_AND_ENERGY.FIRST THEN
			LOGS.LOG_DEBUG('TRACE_ACCOUNT_PEAK_AND_ENERGY');
			LOGS.LOG_DEBUG('<account id>,<peak>,<energy>,<peak date>,<pse of record>@<index>');
		END IF;
    	LOGS.LOG_DEBUG(TO_CHAR(g_ACCOUNT_PEAK_AND_ENERGY(v_INDEX).ACCOUNT_ID) || ',' ||
		TO_CHAR(g_ACCOUNT_PEAK_AND_ENERGY(v_INDEX).PEAK) || ',' ||
		TO_CHAR(g_ACCOUNT_PEAK_AND_ENERGY(v_INDEX).ENERGY) || ',' ||
		TEXT_UTIL.TO_CHAR_TIME(g_ACCOUNT_PEAK_AND_ENERGY(v_INDEX).PEAK_DATE) || ',' ||
		TO_CHAR(g_ACCOUNT_PEAK_AND_ENERGY(v_INDEX).PSE_OF_RECORD) || '@' ||
		TO_CHAR(v_INDEX));
	END LOOP;

END TRACE_ACCOUNT_PEAK_AND_ENERGY;
---------------------------------------------------------------------------------------------------
FUNCTION IS_INTERVAL_DAY_OR_GREATER
	(
	p_INTERVAL IN VARCHAR
	) RETURN BOOLEAN IS

v_IS_DAY NUMBER;

BEGIN
	SELECT DECODE(UPPER(SUBSTR(p_INTERVAL,1,2)),'HO',0,'30',0,'20',0,'15',0,'10',0,'5 ',0,1)
	INTO v_IS_DAY FROM DUAL;

	IF v_IS_DAY > 0 THEN
		RETURN TRUE;
	ELSE
		RETURN FALSE;
	END IF;

END IS_INTERVAL_DAY_OR_GREATER;
---------------------------------------------------------------------------------------------------
FUNCTION GET_ACCOUNT_SERVICE_NAME
	(
	p_ACCOUNT_SERVICE_ID IN NUMBER
	) RETURN VARCHAR IS

v_NAME VARCHAR(128);

BEGIN

	SELECT B.ACCOUNT_NAME || ' - ' || C.SERVICE_LOCATION_NAME || ' - ' || D.METER_NAME
	INTO v_NAME
	FROM ACCOUNT_SERVICE A, ACCOUNT B, SERVICE_LOCATION C, METER D
	WHERE A.ACCOUNT_SERVICE_ID = p_ACCOUNT_SERVICE_ID
		AND B.ACCOUNT_ID = A.ACCOUNT_ID
		AND C.SERVICE_LOCATION_ID = A.SERVICE_LOCATION_ID
		AND D.METER_ID = A.METER_ID;

	RETURN v_NAME;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN NULL;

END GET_ACCOUNT_SERVICE_NAME;
---------------------------------------------------------------------------------------------------
FUNCTION GET_CONSUMPTION_CODE
	(
	p_MODEL_ID IN NUMBER,
	p_REQUEST_TYPE IN NUMBER
	) RETURN CHAR IS

v_CONSUMPTION_CODE CHAR(1);
v_REQUEST_TYPE VARCHAR(16);

BEGIN

	SELECT DECODE(p_REQUEST_TYPE, 1, 'Forecast', 2, 'Preliminary', 3, 'Final', 'Forecast') INTO v_REQUEST_TYPE FROM DUAL;

-- First check the model specific area to see if the code mapping resides there.
	v_CONSUMPTION_CODE := SUBSTR(MODEL_VALUE_AT_KEY(p_MODEL_ID,'Position and Billing','Consumption Code', v_REQUEST_TYPE),1,1);
	IF v_CONSUMPTION_CODE IS NULL THEN
-- Then check the global area to see if the code mapping resides there.
		v_CONSUMPTION_CODE := SUBSTR(MODEL_VALUE_AT_KEY(g_NOT_ASSIGNED,'Position and Billing','Consumption Code', v_REQUEST_TYPE),1,1);
		IF v_CONSUMPTION_CODE IS NULL THEN
-- If not found then set to internal system default.
			SELECT DECODE(p_REQUEST_TYPE, 1, 'F', 2, 'P', 3, 'A', 'A') INTO v_CONSUMPTION_CODE FROM DUAL;
		END IF;
	END IF;

	RETURN v_CONSUMPTION_CODE;

EXCEPTION
	WHEN OTHERS THEN
		RETURN '?';
END GET_CONSUMPTION_CODE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_MARKET_PRICE
	(
	p_MARKET_PRICE_ID NUMBER,
	p_PRICE_CODE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_MARKET_PRICE_TABLE IN OUT GA.NUMBER_TABLE
	) AS

-- NOTE:  p_BEGIN_DATE AND p_END_DATE are CUT Dates.

v_INDEX BINARY_INTEGER := 0;
v_DATE DATE := p_BEGIN_DATE;
v_WORK_ID NUMBER;

CURSOR c_MARKET_PRICE IS
	SELECT PRICE_DATE "DATE", PRICE
	FROM MARKET_PRICE_VALUE A
	WHERE MARKET_PRICE_ID = p_MARKET_PRICE_ID
		AND PRICE_CODE IN ('F','P','A')
		AND PRICE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
        AND PRICE_CODE =
        	(SELECT DECODE(MAX(DECODE(PRICE_CODE,'F',1,'P',2,'A',3)),1,'F',2,'P',3,'A')
        	FROM MARKET_PRICE_VALUE
            WHERE MARKET_PRICE_ID = A.MARKET_PRICE_ID
            	AND PRICE_CODE IN ('F','P','A')
                AND PRICE_DATE = A.PRICE_DATE)
		AND AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM MARKET_PRICE_VALUE
			WHERE MARKET_PRICE_ID = A.MARKET_PRICE_ID
				AND PRICE_CODE = A.PRICE_CODE
				AND PRICE_DATE = A.PRICE_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE)
	ORDER BY PRICE_DATE;

CURSOR c_FORWARD_PRICE IS
	SELECT WORK_DATE "DATE", WORK_DATA "PRICE"
	FROM RTO_WORK
	WHERE WORK_ID = v_WORK_ID;

BEGIN

	p_MARKET_PRICE_TABLE.DELETE;
	WHILE v_DATE <= p_END_DATE LOOP
		p_MARKET_PRICE_TABLE(v_INDEX) := 0;
		v_DATE := ADD_HOURS_TO_DATE(v_DATE,1);
		v_INDEX := v_INDEX + 1;
	END LOOP;

	CU.GET_HOURLY_FORWARD_PRICES(p_MARKET_PRICE_ID, p_BEGIN_DATE, p_END_DATE, v_WORK_ID);

	FOR v_MARKET_PRICE IN c_MARKET_PRICE LOOP
		v_INDEX := ROUND((v_MARKET_PRICE.DATE - p_BEGIN_DATE) / GA.HOUR_DIVISOR);
		p_MARKET_PRICE_TABLE(v_INDEX) := v_MARKET_PRICE.PRICE;
	END LOOP;
	FOR v_FORWARD_PRICE IN c_FORWARD_PRICE LOOP
		v_INDEX := ROUND((v_FORWARD_PRICE.DATE - p_BEGIN_DATE) / GA.HOUR_DIVISOR);
		-- use forward prices when no hourly price data exists
		IF p_MARKET_PRICE_TABLE(v_INDEX) = 0 THEN
			p_MARKET_PRICE_TABLE(v_INDEX) := v_FORWARD_PRICE.PRICE;
		END IF;
	END LOOP;
	UT.PURGE_RTO_WORK(v_WORK_ID);

	EXCEPTION
		WHEN OTHERS THEN
			BEGIN
				UT.PURGE_RTO_WORK(v_WORK_ID);
			EXCEPTION
				WHEN OTHERS THEN
					ERRS.LOG_AND_CONTINUE;
			END;
			ERRS.LOG_AND_RAISE;

END GET_MARKET_PRICE;
---------------------------------------------------------------------------------------------------
FUNCTION GET_SYSTEM_LOAD_PEAK_DATE
	(
	p_SYSTEM_LOAD_ID IN NUMBER,
	p_LOAD_CODE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE
	) RETURN DATE IS

CURSOR c_LOAD IS
	SELECT B.LOAD_DATE, SUM(DECODE(A.OPERATION_CODE,'S',-1,1) * B.LOAD_VAL) "LOAD_VAL"
   	FROM SYSTEM_LOAD_AREA A, AREA_LOAD B
	WHERE A.SYSTEM_LOAD_ID = p_SYSTEM_LOAD_ID
		AND B.AREA_ID = A.AREA_ID
		AND B.LOAD_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
		AND B.LOAD_CODE = p_LOAD_CODE
		AND B.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM AREA_LOAD
			WHERE AREA_ID = B.AREA_ID
				AND LOAD_CODE = B.LOAD_CODE
				AND LOAD_DATE = B.LOAD_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE)
	GROUP BY B.LOAD_DATE
	ORDER BY LOAD_VAL DESC, LOAD_DATE ASC;

v_PEAK_DATE DATE := NULL;

BEGIN

	FOR v_LOAD IN c_LOAD LOOP
		v_PEAK_DATE := v_LOAD.LOAD_DATE;
		EXIT;
	END LOOP;
	RETURN v_PEAK_DATE;

END GET_SYSTEM_LOAD_PEAK_DATE;
---------------------------------------------------------------------------------------------------
FUNCTION GET_SYSTEM_LOAD_AT_DATE
	(
	p_SYSTEM_LOAD_ID IN NUMBER,
	p_LOAD_CODE IN CHAR,
	p_LOAD_DATE IN DATE,
	p_AS_OF_DATE IN DATE
	) RETURN NUMBER IS

v_LOAD_VAL NUMBER;

BEGIN

	SELECT SUM(DECODE(A.OPERATION_CODE,'S',-1,1) * B.LOAD_VAL) "LOAD_VAL"
	INTO v_LOAD_VAL
	FROM SYSTEM_LOAD_AREA A, AREA_LOAD B
	WHERE A.SYSTEM_LOAD_ID = p_SYSTEM_LOAD_ID
		AND B.AREA_ID = A.AREA_ID
		AND B.LOAD_CODE = p_LOAD_CODE
		AND B.LOAD_DATE  = p_LOAD_DATE
		AND B.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM AREA_LOAD
			WHERE AREA_ID = B.AREA_ID
				AND LOAD_CODE = B.LOAD_CODE
				AND LOAD_DATE = B.LOAD_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE)
	GROUP BY B.LOAD_DATE;

	RETURN v_LOAD_VAL;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN NULL;

END GET_SYSTEM_LOAD_AT_DATE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_PSE_PEAK_DEMAND_AND_DATE
	(
	p_PSE_ID IN NUMBER,
	p_POD_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_PEAK_DEMAND OUT NUMBER,
	p_PEAK_DATE OUT DATE,
    p_TIME_ZONE IN VARCHAR2 := NULL
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

	UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	SELECT X.AMOUNT, X.SCHEDULE_DATE INTO p_PEAK_DEMAND, p_PEAK_DATE
	FROM
		(
		SELECT C.SCHEDULE_DATE, SUM(C.AMOUNT) "AMOUNT"
		FROM INTERCHANGE_TRANSACTION A, IT_STATUS B, IT_SCHEDULE C
		WHERE A.PURCHASER_ID = DECODE(p_PSE_ID, g_NOT_ASSIGNED, A.PURCHASER_ID, p_PSE_ID)
			AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) = 'LO'
			AND A.POD_ID = DECODE(p_POD_ID, g_NOT_ASSIGNED, A.POD_ID, p_POD_ID)
			AND B.TRANSACTION_ID = A.TRANSACTION_ID
			AND B.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM IT_STATUS
				WHERE TRANSACTION_ID = B.TRANSACTION_ID
					AND AS_OF_DATE <= p_AS_OF_DATE)
			AND B.TRANSACTION_IS_ACTIVE = 1
			AND C.TRANSACTION_ID = A.TRANSACTION_ID
	    	AND C.SCHEDULE_TYPE = p_SCHEDULE_TYPE
			AND C.SCHEDULE_STATE = GA.INTERNAL_STATE
			AND C.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND C.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM IT_SCHEDULE
				WHERE TRANSACTION_ID = C.TRANSACTION_ID
					AND SCHEDULE_TYPE = C.SCHEDULE_TYPE
					AND SCHEDULE_STATE = C.SCHEDULE_STATE
					AND SCHEDULE_DATE = C.SCHEDULE_DATE
					AND AS_OF_DATE <= p_AS_OF_DATE)
		GROUP BY C.SCHEDULE_DATE
		ORDER BY AMOUNT DESC, SCHEDULE_DATE DESC
		) X
	WHERE ROWNUM = 1;

EXCEPTION
	WHEN OTHERS THEN
		p_PEAK_DEMAND := 0;
		p_PEAK_DATE := v_BEGIN_DATE;

END GET_PSE_PEAK_DEMAND_AND_DATE;
---------------------------------------------------------------------------------------------------
FUNCTION IS_OASIS_SERVICE_SCHEDULE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_NUMBER IN VARCHAR
	) RETURN BOOLEAN IS

CURSOR c_OASIS_RESERVATION IS
	SELECT *
	FROM OASIS_RESERVATION
	WHERE TRANSACTION_ID = p_TRANSACTION_ID
	ORDER BY CHANGE_DATE;

v_SCHEDULE_NUMBER CHAR(1);
v_IS_SCHEDULE BOOLEAN := FALSE;

BEGIN

	IF UPPER(p_SCHEDULE_NUMBER) = 'NONE' THEN
		RETURN TRUE;
	END IF;

	FOR v_OASIS_RESERVATION IN c_OASIS_RESERVATION LOOP
		IF c_OASIS_RESERVATION%FOUND THEN
			v_SCHEDULE_NUMBER := SUBSTR(p_SCHEDULE_NUMBER, LENGTH(p_SCHEDULE_NUMBER));
	    		IF v_SCHEDULE_NUMBER = '1' THEN
				v_IS_SCHEDULE :=  v_OASIS_RESERVATION.SCHEDULE_1 = 1;
			ELSIF v_SCHEDULE_NUMBER = '2' THEN
				v_IS_SCHEDULE :=  v_OASIS_RESERVATION.SCHEDULE_2 = 1;
			ELSIF v_SCHEDULE_NUMBER = '3' THEN
				v_IS_SCHEDULE :=  v_OASIS_RESERVATION.SCHEDULE_3 = 1;
			ELSIF v_SCHEDULE_NUMBER = '4' THEN
				v_IS_SCHEDULE :=  v_OASIS_RESERVATION.SCHEDULE_4 = 1;
			ELSIF v_SCHEDULE_NUMBER = '5' THEN
				v_IS_SCHEDULE :=  v_OASIS_RESERVATION.SCHEDULE_5 = 1;
			ELSIF v_SCHEDULE_NUMBER = '6' THEN
				v_IS_SCHEDULE :=  v_OASIS_RESERVATION.SCHEDULE_6 = 1;
			END IF;
		ELSE
			v_IS_SCHEDULE := TRUE;
		END IF;
		EXIT;
	END LOOP;

	RETURN v_IS_SCHEDULE;

END IS_OASIS_SERVICE_SCHEDULE;
---------------------------------------------------------------------------------------------------
FUNCTION COMPONENT_IS_ACTIVE_FOR_EVENT
	(
	p_EVENT_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_EVENTS IN EVENT_TABLE
	) RETURN BOOLEAN IS

v_INDEX BINARY_INTEGER;

BEGIN

-- If a component is associated with the any event then answer true; component is always considered active.
	IF p_EVENT_ID = g_ANY_EVENT OR p_EVENT_ID = g_NOT_ASSIGNED OR p_EVENT_ID IS NULL THEN
		RETURN TRUE;
	END IF;

-- If ther are no events defined then answer true; all components are considered active.
	IF p_EVENTS.COUNT = 0 THEN
		RETURN TRUE;
	END IF;

-- If a component is associated with the none event then answer false if there is an active event for the service date.
	IF p_EVENTS.COUNT > 0 THEN
		IF p_EVENT_ID = g_NONE_EVENT THEN
			v_INDEX := p_EVENTS.FIRST;
			WHILE v_INDEX <= p_EVENTS.LAST LOOP
				IF p_SERVICE_DATE BETWEEN p_EVENTS(v_INDEX).BEGIN_DATE AND p_EVENTS(v_INDEX).END_DATE THEN
					RETURN FALSE;
				END IF;
				v_INDEX := p_EVENTS.NEXT(v_INDEX);
			END LOOP;
		END IF;
	END IF;

-- If a component is associated with another event then answer true if this event is active for the service date.
	v_INDEX := p_EVENTS.FIRST;
	WHILE v_INDEX <= p_EVENTS.LAST LOOP
		IF p_EVENTS(v_INDEX).EVENT_ID = p_EVENT_ID AND p_SERVICE_DATE BETWEEN p_EVENTS(v_INDEX).BEGIN_DATE AND p_EVENTS(v_INDEX).END_DATE THEN
			RETURN TRUE;
		END IF;
		v_INDEX := p_EVENTS.NEXT(v_INDEX);
	END LOOP;

-- Componet is not active for specified event for specified service date.
	RETURN FALSE;

END COMPONENT_IS_ACTIVE_FOR_EVENT;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_ACCOUNT_SUM_AND_MAX
	(
	p_REQUEST_TYPE IN CHAR,
	p_ACCOUNT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SUM OUT NUMBER,
	p_MAX OUT NUMBER
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

	UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, GA.LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	p_SUM := 0;
	p_MAX := 0;

	SELECT SUM(C.LOAD_VAL + C.TX_LOSS_VAL + C.DX_LOSS_VAL) / 1000.0, MAX(C.LOAD_VAL + C.TX_LOSS_VAL + C.DX_LOSS_VAL)/ 1000.0
	INTO p_SUM, p_MAX
	FROM ACCOUNT_SERVICE A, SERVICE B, SERVICE_LOAD C
	WHERE A.ACCOUNT_ID = p_ACCOUNT_ID
		AND B.MODEL_ID = GA.ELECTRIC_MODEL
		AND B.SCENARIO_ID = GA.BASE_SCENARIO_ID
		AND B.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM SERVICE
			WHERE MODEL_ID = B.MODEL_ID
				AND SCENARIO_ID = B.SCENARIO_ID
				AND AS_OF_DATE <= p_AS_OF_DATE
				AND PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
				AND ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
				AND SERVICE_DELIVERY_ID = B.SERVICE_DELIVERY_ID)
		AND B.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
		AND C.SERVICE_ID = B.SERVICE_ID
		AND C.SERVICE_CODE = p_REQUEST_TYPE
		AND C.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND C.LOAD_CODE = GA.STANDARD;

EXCEPTION
	WHEN OTHERS THEN
		p_SUM := 0;
		p_MAX := 0;

END GET_ACCOUNT_SUM_AND_MAX;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_ACCOUNT_PEAK_DATE
	(
	p_REQUEST_TYPE IN CHAR,
	p_ACCOUNT_ID IN NUMBER,
	p_PEAK_VAL IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_PEAK_DATE OUT DATE
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

	IF p_PEAK_VAL <= 0 THEN
		p_PEAK_DATE := CONSTANTS.LOW_DATE;
		RETURN;
	END IF;

	UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, GA.LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	SELECT C.LOAD_DATE
	INTO p_PEAK_DATE
	FROM ACCOUNT_SERVICE A, SERVICE B, SERVICE_LOAD C
	WHERE A.ACCOUNT_ID = p_ACCOUNT_ID
		AND B.MODEL_ID = GA.ELECTRIC_MODEL
		AND B.SCENARIO_ID = GA.BASE_SCENARIO_ID
		AND B.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM SERVICE
			WHERE MODEL_ID = B.MODEL_ID
				AND SCENARIO_ID = B.SCENARIO_ID
				AND AS_OF_DATE <= p_AS_OF_DATE
				AND PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
				AND ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
				AND SERVICE_DELIVERY_ID = B.SERVICE_DELIVERY_ID)
		AND B.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
		AND C.SERVICE_ID = B.SERVICE_ID
		AND C.SERVICE_CODE = p_REQUEST_TYPE
		AND C.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND C.LOAD_CODE = GA.STANDARD
		AND (C.LOAD_VAL + C.TX_LOSS_VAL + C.DX_LOSS_VAL) / 1000.0 = p_PEAK_VAL
		AND ROWNUM = 1;

EXCEPTION
	WHEN OTHERS THEN
		p_PEAK_DATE := CONSTANTS.LOW_DATE;

END GET_ACCOUNT_PEAK_DATE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_ACCOUNT_PEAK_AND_ENERGY
	(
	p_SCHEDULE_TYPE IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_PEAK_VAL OUT NUMBER,
	p_PEAK_DATE OUT DATE,
	p_ENERGY_VAL OUT NUMBER
	) AS

v_REQUEST_TYPE CHAR(1);
v_STATUS NUMBER;

BEGIN

	p_PEAK_DATE := CONSTANTS.LOW_DATE;
	p_ENERGY_VAL := 0;
	p_PEAK_VAL := 0;

	SELECT DECODE(p_SCHEDULE_TYPE, 1, 'F', 2, 'B', 'U') INTO v_REQUEST_TYPE FROM DUAL;

 	IF v_REQUEST_TYPE = 'U' AND GA.ENABLE_EXTERNAL_METER_ACCESS THEN
	   XS.CACHE_USAGE(p_ACCOUNT_ID, 0, 0, 0, p_BEGIN_DATE, p_END_DATE, SYSDATE, v_STATUS);
	END IF;

	GET_ACCOUNT_SUM_AND_MAX(v_REQUEST_TYPE, p_ACCOUNT_ID, p_BEGIN_DATE, p_END_DATE,	p_AS_OF_DATE, p_ENERGY_VAL, p_PEAK_VAL);

    GET_ACCOUNT_PEAK_DATE(v_REQUEST_TYPE, p_ACCOUNT_ID, p_PEAK_VAL, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_PEAK_DATE);

 	IF v_REQUEST_TYPE = 'U' AND GA.ENABLE_EXTERNAL_METER_ACCESS THEN
    	XS.RELEASE_USAGE(p_ACCOUNT_ID, 0, 0, 0, p_BEGIN_DATE, p_END_DATE);
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG(TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE) || ',' || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE) || ',' || TO_CHAR(p_PEAK_VAL) || ',' || TEXT_UTIL.TO_CHAR_TIME(p_PEAK_DATE));
	END IF;

END GET_ACCOUNT_PEAK_AND_ENERGY;
---------------------------------------------------------------------------------------------------
PROCEDURE CACHE_ACCOUNT_PEAK_AND_ENERGY
	(
	p_ENTITY_ATTRIBUTE_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE
	) AS

CURSOR c_CACHE IS
    SELECT OWNER_ENTITY_ID, ATTRIBUTE_VAL
	FROM TEMPORAL_ENTITY_ATTRIBUTE
	WHERE ATTRIBUTE_ID = p_ENTITY_ATTRIBUTE_ID
		AND BEGIN_DATE <= TRUNC(p_END_DATE)
		AND NVL(END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE);

v_PEAK NUMBER;
v_PEAK_DATE DATE;
v_ENERGY NUMBER;
v_INDEX BINARY_INTEGER;

BEGIN

	FOR v_CACHE IN c_CACHE LOOP
	    GET_ACCOUNT_PEAK_AND_ENERGY(p_SCHEDULE_TYPE, v_CACHE.OWNER_ENTITY_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, v_PEAK, v_PEAK_DATE, v_ENERGY);
		v_INDEX := v_CACHE.OWNER_ENTITY_ID;
		g_ACCOUNT_PEAK_AND_ENERGY(v_INDEX).ACCOUNT_ID := v_CACHE.OWNER_ENTITY_ID;
		g_ACCOUNT_PEAK_AND_ENERGY(v_INDEX).PEAK := v_PEAK;
		g_ACCOUNT_PEAK_AND_ENERGY(v_INDEX).PEAK_DATE := v_PEAK_DATE;
		g_ACCOUNT_PEAK_AND_ENERGY(v_INDEX).ENERGY := v_ENERGY;
		g_ACCOUNT_PEAK_AND_ENERGY(v_INDEX).PSE_OF_RECORD := CS.GET_ACCOUNT_PSE_OF_RECORD(v_CACHE.OWNER_ENTITY_ID, v_PEAK_DATE);
	END LOOP;

END CACHE_ACCOUNT_PEAK_AND_ENERGY;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_FORWARD_MARKET_PRICES
	(
	p_UNDER_UNDER_PRICE_ID NUMBER,
	p_UNDER_OVER_PRICE_ID NUMBER,
	p_OVER_UNDER_PRICE_ID NUMBER,
	p_OVER_OVER_PRICE_ID NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_MARKET_PRICE_TABLE IN OUT MARKET_PRICE_TABLE
	) AS

v_UNDER_UNDER_WORK_ID NUMBER;
v_UNDER_OVER_WORK_ID NUMBER;
v_OVER_UNDER_WORK_ID NUMBER;
v_OVER_OVER_WORK_ID NUMBER;
v_DIVISOR NUMBER;
v_INDEX BINARY_INTEGER;

CURSOR c_MARKET_PRICE IS
    SELECT MARKET_PRICE_ID "PRICE_ID", PRICE_DATE, PRICE
	FROM MARKET_PRICE_VALUE A
	WHERE (MARKET_PRICE_ID = p_UNDER_UNDER_PRICE_ID
	    OR MARKET_PRICE_ID = p_UNDER_OVER_PRICE_ID
	    OR MARKET_PRICE_ID = p_OVER_UNDER_PRICE_ID
	    OR MARKET_PRICE_ID = p_OVER_OVER_PRICE_ID)
	    AND PRICE_CODE IN ('F','P','A')
		AND PRICE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
        AND PRICE_CODE =
        	(SELECT DECODE(MAX(DECODE(PRICE_CODE,'F',1,'P',2,'A',3)),1,'F',2,'P',3,'A')
        	FROM MARKET_PRICE_VALUE
            WHERE MARKET_PRICE_ID = A.MARKET_PRICE_ID
            	AND PRICE_CODE IN ('F','P','A')
                AND PRICE_DATE = A.PRICE_DATE)
		AND AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM MARKET_PRICE_VALUE
			WHERE MARKET_PRICE_ID = A.MARKET_PRICE_ID
				AND PRICE_CODE = A.PRICE_CODE
				AND PRICE_DATE = A.PRICE_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE)
	ORDER BY MARKET_PRICE_ID, PRICE_DATE;

CURSOR c_FORWARD_PRICE IS
    SELECT WORK_XID "PRICE_ID", WORK_DATE "PRICE_DATE", WORK_DATA "PRICE"
	FROM RTO_WORK
	WHERE (WORK_ID = v_UNDER_UNDER_WORK_ID
	    OR WORK_ID = v_UNDER_OVER_WORK_ID
	    OR WORK_ID = v_OVER_UNDER_WORK_ID
	    OR WORK_ID = v_OVER_OVER_WORK_ID)
	ORDER BY WORK_XID, WORK_DATE;

BEGIN

	v_DIVISOR := GA.HOUR_DIVISOR;

	FILL_MARKET_PRICE_TABLE(p_BEGIN_DATE, p_END_DATE, p_MARKET_PRICE_TABLE);
	CU.GET_HOURLY_FORWARD_PRICES(p_UNDER_UNDER_PRICE_ID, p_BEGIN_DATE, p_END_DATE, v_UNDER_UNDER_WORK_ID);
	CU.GET_HOURLY_FORWARD_PRICES(p_UNDER_OVER_PRICE_ID, p_BEGIN_DATE, p_END_DATE, v_UNDER_OVER_WORK_ID);
	CU.GET_HOURLY_FORWARD_PRICES(p_OVER_UNDER_PRICE_ID, p_BEGIN_DATE, p_END_DATE, v_OVER_UNDER_WORK_ID);
	CU.GET_HOURLY_FORWARD_PRICES(p_OVER_OVER_PRICE_ID, p_BEGIN_DATE, p_END_DATE, v_OVER_OVER_WORK_ID);

	FOR v_MARKET_PRICE IN c_MARKET_PRICE LOOP

		v_INDEX := ROUND((v_MARKET_PRICE.PRICE_DATE - p_BEGIN_DATE) / v_DIVISOR);

		IF v_MARKET_PRICE.PRICE_ID = p_UNDER_UNDER_PRICE_ID THEN
		    p_MARKET_PRICE_TABLE(v_INDEX).UNDER_UNDER_PRICE := v_MARKET_PRICE.PRICE;
		END IF;

		IF v_MARKET_PRICE.PRICE_ID = p_UNDER_OVER_PRICE_ID THEN
		    p_MARKET_PRICE_TABLE(v_INDEX).UNDER_OVER_PRICE := v_MARKET_PRICE.PRICE;
		END IF;

		IF v_MARKET_PRICE.PRICE_ID = p_OVER_UNDER_PRICE_ID THEN
		    p_MARKET_PRICE_TABLE(v_INDEX).OVER_UNDER_PRICE := v_MARKET_PRICE.PRICE;
		END IF;

		IF v_MARKET_PRICE.PRICE_ID = p_OVER_OVER_PRICE_ID THEN
		    p_MARKET_PRICE_TABLE(v_INDEX).OVER_OVER_PRICE := v_MARKET_PRICE.PRICE;
		END IF;

	    p_MARKET_PRICE_TABLE(v_INDEX).PRICE_DATE := v_MARKET_PRICE.PRICE_DATE;

	END LOOP;

	FOR v_FORWARD_PRICE IN c_FORWARD_PRICE LOOP

		v_INDEX := ROUND((v_FORWARD_PRICE.PRICE_DATE - p_BEGIN_DATE) / GA.HOUR_DIVISOR);

		IF v_FORWARD_PRICE.PRICE_ID = p_UNDER_UNDER_PRICE_ID THEN
			IF p_MARKET_PRICE_TABLE(v_INDEX).UNDER_UNDER_PRICE = 0 THEN
			    p_MARKET_PRICE_TABLE(v_INDEX).UNDER_UNDER_PRICE := v_FORWARD_PRICE.PRICE;
			END IF;
		END IF;

		IF v_FORWARD_PRICE.PRICE_ID = p_UNDER_OVER_PRICE_ID THEN
			IF p_MARKET_PRICE_TABLE(v_INDEX).UNDER_OVER_PRICE = 0 THEN
			    p_MARKET_PRICE_TABLE(v_INDEX).UNDER_OVER_PRICE := v_FORWARD_PRICE.PRICE;
			END IF;
		END IF;

		IF v_FORWARD_PRICE.PRICE_ID = p_OVER_UNDER_PRICE_ID THEN
			IF p_MARKET_PRICE_TABLE(v_INDEX).OVER_UNDER_PRICE = 0 THEN
			    p_MARKET_PRICE_TABLE(v_INDEX).OVER_UNDER_PRICE := v_FORWARD_PRICE.PRICE;
			END IF;
		END IF;

		IF v_FORWARD_PRICE.PRICE_ID = p_OVER_OVER_PRICE_ID THEN
			IF p_MARKET_PRICE_TABLE(v_INDEX).OVER_OVER_PRICE = 0 THEN
			    p_MARKET_PRICE_TABLE(v_INDEX).OVER_OVER_PRICE := v_FORWARD_PRICE.PRICE;
			END IF;
		END IF;

	    p_MARKET_PRICE_TABLE(v_INDEX).PRICE_DATE := v_FORWARD_PRICE.PRICE_DATE;

	END LOOP;

	UT.PURGE_RTO_WORK (v_UNDER_UNDER_WORK_ID);
	UT.PURGE_RTO_WORK (v_UNDER_OVER_WORK_ID);
	UT.PURGE_RTO_WORK (v_OVER_UNDER_WORK_ID);
	UT.PURGE_RTO_WORK (v_OVER_OVER_WORK_ID);

EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			UT.PURGE_RTO_WORK (v_UNDER_UNDER_WORK_ID);
			UT.PURGE_RTO_WORK (v_UNDER_OVER_WORK_ID);
			UT.PURGE_RTO_WORK (v_OVER_UNDER_WORK_ID);
			UT.PURGE_RTO_WORK (v_OVER_OVER_WORK_ID);
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE;
		END;
		ERRS.LOG_AND_RAISE;

END GET_FORWARD_MARKET_PRICES;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_MARKET_PRICES
	(
	p_UNDER_UNDER_PRICE_ID NUMBER,
	p_UNDER_OVER_PRICE_ID NUMBER,
	p_OVER_UNDER_PRICE_ID NUMBER,
	p_OVER_OVER_PRICE_ID NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_MARKET_PRICE_TABLE IN OUT MARKET_PRICE_TABLE
	) AS

v_DIVISOR NUMBER;
v_INDEX BINARY_INTEGER;

CURSOR c_MARKET_PRICE IS
    SELECT MARKET_PRICE_ID "PRICE_ID", PRICE_DATE, PRICE
	FROM MARKET_PRICE_VALUE A
	WHERE (MARKET_PRICE_ID = p_UNDER_UNDER_PRICE_ID
	    OR MARKET_PRICE_ID = p_UNDER_OVER_PRICE_ID
	    OR MARKET_PRICE_ID = p_OVER_UNDER_PRICE_ID
	    OR MARKET_PRICE_ID = p_OVER_OVER_PRICE_ID)
	    AND PRICE_CODE IN ('F','P','A')
		AND PRICE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
        AND PRICE_CODE =
        	(SELECT DECODE(MAX(DECODE(PRICE_CODE,'F',1,'P',2,'A',3)),1,'F',2,'P',3,'A')
        	FROM MARKET_PRICE_VALUE
            WHERE MARKET_PRICE_ID = A.MARKET_PRICE_ID
            	AND PRICE_CODE IN ('F','P','A')
                AND PRICE_DATE = A.PRICE_DATE)
		AND AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM MARKET_PRICE_VALUE
			WHERE MARKET_PRICE_ID = A.MARKET_PRICE_ID
				AND PRICE_CODE = A.PRICE_CODE
				AND PRICE_DATE = A.PRICE_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE)
	ORDER BY MARKET_PRICE_ID, PRICE_DATE;

BEGIN

	v_DIVISOR := GA.HOUR_DIVISOR;

	FOR v_MARKET_PRICE IN c_MARKET_PRICE LOOP

		v_INDEX := ROUND((v_MARKET_PRICE.PRICE_DATE - p_BEGIN_DATE) / v_DIVISOR);

		IF v_MARKET_PRICE.PRICE_ID = p_UNDER_UNDER_PRICE_ID THEN
		    p_MARKET_PRICE_TABLE(v_INDEX).UNDER_UNDER_PRICE := v_MARKET_PRICE.PRICE;
		END IF;

		IF v_MARKET_PRICE.PRICE_ID = p_UNDER_OVER_PRICE_ID THEN
		    p_MARKET_PRICE_TABLE(v_INDEX).UNDER_OVER_PRICE := v_MARKET_PRICE.PRICE;
		END IF;

		IF v_MARKET_PRICE.PRICE_ID = p_OVER_UNDER_PRICE_ID THEN
		    p_MARKET_PRICE_TABLE(v_INDEX).OVER_UNDER_PRICE := v_MARKET_PRICE.PRICE;
		END IF;

		IF v_MARKET_PRICE.PRICE_ID = p_OVER_OVER_PRICE_ID THEN
		    p_MARKET_PRICE_TABLE(v_INDEX).OVER_OVER_PRICE := v_MARKET_PRICE.PRICE;
		END IF;

	    p_MARKET_PRICE_TABLE(v_INDEX).PRICE_DATE := v_MARKET_PRICE.PRICE_DATE;

	END LOOP;

END GET_MARKET_PRICES;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_COMPONENT_BANDS
	(
	p_IMBALANCE_ID IN NUMBER,
	p_OVER_SUPPLY_TABLE OUT COMPONENT_BAND_TABLE,
	p_UNDER_SUPPLY_TABLE OUT COMPONENT_BAND_TABLE
	) AS

CURSOR c_COMPONENT_BAND IS
    SELECT *
	FROM COMPONENT_IMBALANCE_BAND
	WHERE IMBALANCE_ID = p_IMBALANCE_ID
	ORDER BY BAND_TYPE, BAND_NUMBER;

BEGIN

    FOR v_COMPONENT_BAND IN c_COMPONENT_BAND LOOP
		IF UPPER(SUBSTR(v_COMPONENT_BAND.BAND_TYPE,1,1)) = 'O' THEN
			p_OVER_SUPPLY_TABLE(v_COMPONENT_BAND.BAND_NUMBER) := v_COMPONENT_BAND;
		ELSIF UPPER(SUBSTR(v_COMPONENT_BAND.BAND_TYPE,1,1)) = 'U' THEN
			p_UNDER_SUPPLY_TABLE(v_COMPONENT_BAND.BAND_NUMBER) := v_COMPONENT_BAND;
		END IF;
	END LOOP;

END GET_COMPONENT_BANDS;
---------------------------------------------------------------------------------------------------
FUNCTION GET_COMPONENT_IMBALANCE
	(
	p_COMPONENT_ID IN NUMBER,
	p_SERVICE_DATE IN DATE
	) RETURN COMPONENT_IMBALANCE%ROWTYPE IS

v_COMPONENT_IMBALANCE COMPONENT_IMBALANCE%ROWTYPE;

BEGIN

    SELECT *
	INTO v_COMPONENT_IMBALANCE
	FROM COMPONENT_IMBALANCE
	WHERE COMPONENT_ID = p_COMPONENT_ID
    	AND SUB_COMPONENT_TYPE = g_NO_SUB_TYPE
        AND SUB_COMPONENT_ID = g_NOT_ASSIGNED
	    AND TRUNC(p_SERVICE_DATE) BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE)
		AND ROWNUM = 1;

	RETURN v_COMPONENT_IMBALANCE;

	EXCEPTION
	    WHEN NO_DATA_FOUND THEN
		    RETURN NULL;

END GET_COMPONENT_IMBALANCE;
---------------------------------------------------------------------------------------------------
FUNCTION GET_COMPONENT
	(
	p_COMPONENT_ID IN NUMBER
	) RETURN COMPONENT%ROWTYPE IS

v_COMPONENT COMPONENT%ROWTYPE;

BEGIN

    SELECT *
	INTO v_COMPONENT
	FROM COMPONENT
	WHERE COMPONENT_ID = p_COMPONENT_ID;

	RETURN v_COMPONENT;

	EXCEPTION
	    WHEN NO_DATA_FOUND THEN
		    RETURN NULL;

END GET_COMPONENT;
---------------------------------------------------------------------------------------------------
FUNCTION GET_COMPONENT_FACTOR
	(
	p_COMPONENT_ID IN NUMBER,
	p_SERVICE_DATE IN DATE
	) RETURN NUMBER IS

v_FACTOR NUMBER;

BEGIN

	SELECT PERCENT_VAL / 100.0
	INTO v_FACTOR
	FROM COMPONENT_PERCENTAGE
	WHERE COMPONENT_ID = p_COMPONENT_ID
        AND TRUNC(p_SERVICE_DATE) BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE)
		AND ROWNUM = 1;

	RETURN v_FACTOR;

	EXCEPTION
	    WHEN NO_DATA_FOUND THEN
		    RETURN 1.0;

END GET_COMPONENT_FACTOR;
---------------------------------------------------------------------------------------------------
FUNCTION GET_COMPONENT_FLAT_RATE
	(
	p_COMPONENT_ID IN NUMBER,
	p_SERVICE_DATE IN DATE
	) RETURN NUMBER IS

v_RATE NUMBER;

BEGIN

	SELECT RATE
	INTO v_RATE
	FROM COMPONENT_FLAT_RATE
	WHERE COMPONENT_ID = p_COMPONENT_ID
    	AND SUB_COMPONENT_TYPE = g_NO_SUB_TYPE
        AND SUB_COMPONENT_ID = g_NOT_ASSIGNED
        AND TRUNC(p_SERVICE_DATE) BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE)
		AND ROWNUM = 1;

	RETURN v_RATE;

	EXCEPTION
	    WHEN NO_DATA_FOUND THEN
		    RETURN 1;

END GET_COMPONENT_FLAT_RATE;
---------------------------------------------------------------------------------------------------
FUNCTION GET_NEXT_DATE_FOR_INTERVAL
	(
	p_DATE IN DATE,
	p_INTERVAL IN VARCHAR
	) RETURN DATE IS

v_INTERVAL CHAR(1);

BEGIN

	v_INTERVAL := UPPER(SUBSTR(p_INTERVAL,1,1));
	IF v_INTERVAL = 'H' THEN
	    RETURN ADD_HOURS_TO_DATE(p_DATE, 1);
	ELSIF v_INTERVAL = 'D' THEN
	    RETURN TRUNC(p_DATE);
	ELSIF v_INTERVAL = 'W' THEN
	    RETURN TRUNC(p_DATE) + 6;
	ELSIF v_INTERVAL = 'M' THEN
	    RETURN LAST_DAY(TRUNC(p_DATE));
	ELSIF v_INTERVAL = 'Y' THEN
	    RETURN LAST_DAY(ADD_MONTHS(TRUNC(p_DATE), 12));
	END IF;

	RETURN NULL;

END GET_NEXT_DATE_FOR_INTERVAL;
---------------------------------------------------------------------------------------------------
FUNCTION GET_ENERGY_IMBALANCE_AMOUNT
	(
	p_CHARGE_ID IN NUMBER,
	p_CHARGE_DATE IN DATE DEFAULT NULL
	) RETURN NUMBER IS

v_ENERGY_IMBALANCE_AMOUNT NUMBER;

BEGIN

    SELECT SUM(ENERGY_IMBALANCE_AMOUNT)
	INTO v_ENERGY_IMBALANCE_AMOUNT
	FROM IMBALANCE_CHARGE_BAND
	WHERE CHARGE_ID = p_CHARGE_ID
	    AND CHARGE_DATE = DECODE(p_CHARGE_DATE, NULL, CHARGE_DATE, p_CHARGE_DATE);

	RETURN v_ENERGY_IMBALANCE_AMOUNT;

	EXCEPTION
	    WHEN NO_DATA_FOUND THEN
		    RETURN 0;

END GET_ENERGY_IMBALANCE_AMOUNT;
---------------------------------------------------------------------------------------------------
PROCEDURE CACHE_GENERATION_TRANSACTIONS
	(
	p_PSE_ID IN NUMBER,
	p_CONTRACT_ID IN NUMBER,
    p_SERVICE_POINT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TXN_WORK_ID OUT NUMBER,
	p_POD_WORK_ID OUT NUMBER
	) AS

v_POD GA.NUMBER_TABLE;
v_POINT_ID NUMBER := NVL(p_SERVICE_POINT_ID,g_ALL);

CURSOR c_GENERATION IS
	SELECT DISTINCT A.TRANSACTION_ID, A.POD_ID
	FROM INTERCHANGE_TRANSACTION A,
		IT_STATUS B,
		IT_COMMODITY C,
		SERVICE_POINT D
	WHERE A.BEGIN_DATE <= TRUNC(p_END_DATE)
		AND NVL(A.END_DATE,CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
		AND A.CONTRACT_ID = DECODE(p_CONTRACT_ID, g_ALL, A.CONTRACT_ID, p_CONTRACT_ID)
		AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) = 'GE' -- Generation Transactions to the POD.
		AND A.PURCHASER_ID = DECODE(p_PSE_ID, g_ALL, A.PURCHASER_ID, p_PSE_ID) -- PSE is Purchase Counter Party to Transaction.
		AND (v_POINT_ID <= 0 OR A.POD_ID = v_POINT_ID)
		AND B.TRANSACTION_ID = A.TRANSACTION_ID
		AND B.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_STATUS
			WHERE TRANSACTION_ID = B.TRANSACTION_ID
				AND AS_OF_DATE <= p_AS_OF_DATE)
		AND B.TRANSACTION_IS_ACTIVE = 1
		AND C.COMMODITY_ID = A.COMMODITY_ID
		AND UPPER(SUBSTR(C.COMMODITY_TYPE,1,1)) = 'E' -- Energy Commodity.
		AND D.SERVICE_POINT_ID = A.POD_ID -- Generation at POD.
		AND UPPER(SUBSTR(D.SERVICE_POINT_TYPE,1,1)) = 'G'; -- Genertaion Points.

BEGIN

	UT.GET_RTO_WORK_ID(p_TXN_WORK_ID);
	UT.POST_RTO_WORK(p_TXN_WORK_ID, NULL, g_UNKNOWN);
	UT.GET_RTO_WORK_ID(p_POD_WORK_ID);
	UT.POST_RTO_WORK(p_POD_WORK_ID, NULL, g_UNKNOWN);

	FOR v_GENERATION IN c_GENERATION LOOP
		UT.POST_RTO_WORK(p_TXN_WORK_ID, NULL, v_GENERATION.TRANSACTION_ID);
		IF NOT v_POD.EXISTS(v_GENERATION.POD_ID) THEN
			UT.POST_RTO_WORK(p_POD_WORK_ID, NULL, v_GENERATION.POD_ID);
			v_POD(v_GENERATION.POD_ID) := v_GENERATION.POD_ID;
		END IF;
	END LOOP;

END CACHE_GENERATION_TRANSACTIONS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_GENERATION_POSITION
	(
	p_PSE_ID IN NUMBER,
	p_CONTRACT_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
    p_SERVICE_POINT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_GENERATION_POSITION_TABLE IN OUT GENERATION_POSITION_TABLE
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_INDEX BINARY_INTEGER;
v_TXN_WORK_ID NUMBER := NULL;
v_POD_WORK_ID NUMBER := NULL;

-- Actual Generation is modeled as Supply at Generation POD's.
CURSOR c_ACTUAL IS
	SELECT SCHEDULE_DATE, SUM(AMOUNT) "AMOUNT"
	FROM IT_SCHEDULE A
	WHERE TRANSACTION_ID IN(SELECT WORK_XID FROM RTO_WORK WHERE WORK_ID = v_TXN_WORK_ID)
 		AND SCHEDULE_TYPE = DECODE(g_ENABLE_SUPPLY_SCHEDULE_TYPES, 1, p_SCHEDULE_TYPE, g_NOT_ASSIGNED)
		AND SCHEDULE_STATE = GA.INTERNAL_STATE
		AND SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_SCHEDULE
			WHERE TRANSACTION_ID = A.TRANSACTION_ID
				AND SCHEDULE_TYPE = A.SCHEDULE_TYPE
				AND SCHEDULE_STATE = A.SCHEDULE_STATE
				AND SCHEDULE_DATE = A.SCHEDULE_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE)
	GROUP BY SCHEDULE_DATE;

-- Planned Generation is modeled as Demand at Generation POR's = Actual Generation POD's..
CURSOR c_PLANNED IS
	SELECT D.SCHEDULE_DATE, SUM(D.AMOUNT) "AMOUNT"
	FROM INTERCHANGE_TRANSACTION A,
		IT_STATUS B,
		IT_COMMODITY C,
		IT_SCHEDULE D,
        RTO_WORK E
	WHERE E.WORK_ID = v_POD_WORK_ID
    	AND A.BEGIN_DATE <= TRUNC(p_END_DATE)
		AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
		AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) <> 'GE'
		AND A.POR_ID = E.WORK_XID -- planned POR = actual POD
		AND B.TRANSACTION_ID = A.TRANSACTION_ID
		AND B.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_STATUS
			WHERE TRANSACTION_ID = B.TRANSACTION_ID
				AND AS_OF_DATE <= p_AS_OF_DATE)
		AND B.TRANSACTION_IS_ACTIVE = 1
		AND C.COMMODITY_ID = A.COMMODITY_ID
		AND UPPER(SUBSTR(C.COMMODITY_TYPE,1,1)) = 'E'
		AND D.TRANSACTION_ID = A.TRANSACTION_ID
		AND D.SCHEDULE_TYPE = DECODE(g_ENABLE_SUPPLY_SCHEDULE_TYPES, 1, p_SCHEDULE_TYPE, g_NOT_ASSIGNED)
		AND D.SCHEDULE_STATE = GA.INTERNAL_STATE
		AND D.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND D.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_SCHEDULE
			WHERE TRANSACTION_ID = D.TRANSACTION_ID
				AND SCHEDULE_TYPE = D.SCHEDULE_TYPE
				AND SCHEDULE_STATE = D.SCHEDULE_STATE
				AND SCHEDULE_DATE = D.SCHEDULE_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE)
	GROUP BY D.SCHEDULE_DATE;

BEGIN

	UT.CUT_DAY_INTERVAL_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	FILL_GENERATION_POSITION_TABLE(v_BEGIN_DATE, v_END_DATE, p_GENERATION_POSITION_TABLE);

	CACHE_GENERATION_TRANSACTIONS(p_PSE_ID, p_CONTRACT_ID, p_SERVICE_POINT_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, v_TXN_WORK_ID, v_POD_WORK_ID);

	FOR v_PLANNED IN c_PLANNED LOOP
		v_INDEX := ROUND((v_PLANNED.SCHEDULE_DATE - v_BEGIN_DATE) / GA.HOUR_DIVISOR);
		p_GENERATION_POSITION_TABLE(v_INDEX).PLANNED := p_GENERATION_POSITION_TABLE(v_INDEX).PLANNED + v_PLANNED.AMOUNT;
	END LOOP;

	FOR v_ACTUAL IN c_ACTUAL LOOP
		v_INDEX := ROUND((v_ACTUAL.SCHEDULE_DATE - v_BEGIN_DATE) / GA.HOUR_DIVISOR);
		p_GENERATION_POSITION_TABLE(v_INDEX).ACTUAL := p_GENERATION_POSITION_TABLE(v_INDEX).ACTUAL + v_ACTUAL.AMOUNT;
	END LOOP;

	UT.PURGE_RTO_WORK(v_TXN_WORK_ID);
	UT.PURGE_RTO_WORK(v_POD_WORK_ID);

EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			UT.PURGE_RTO_WORK(v_TXN_WORK_ID);
			UT.PURGE_RTO_WORK(v_POD_WORK_ID);
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE;
		END;
		ERRS.LOG_AND_RAISE;

END GET_GENERATION_POSITION;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_GENERATION_POSITION
	(
	p_SCHEDULE_TYPE IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_GENERATION_POSITION_TABLE IN OUT GENERATION_POSITION_TABLE
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_INDEX BINARY_INTEGER;

-- Actual Generation is modeled as Supply at Generation POD's.
CURSOR c_ACTUAL IS
	SELECT SCHEDULE_DATE, SUM(AMOUNT) "AMOUNT"
	FROM INTERCHANGE_TRANSACTION A,
		IT_STATUS B,
		IT_COMMODITY C,
		IT_SCHEDULE D
	WHERE A.BEGIN_DATE <= TRUNC(p_END_DATE)
		AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
		AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) = 'GE' -- Generation Transactions to the POD.
		AND A.POD_ID = p_SERVICE_POINT_ID
		AND B.TRANSACTION_ID = A.TRANSACTION_ID
		AND B.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_STATUS
			WHERE TRANSACTION_ID = B.TRANSACTION_ID
				AND AS_OF_DATE <= p_AS_OF_DATE)
		AND B.TRANSACTION_IS_ACTIVE = 1
		AND C.COMMODITY_ID = A.COMMODITY_ID
		AND UPPER(SUBSTR(C.COMMODITY_TYPE,1,1)) = 'E' -- Energy Commodity.
		AND D.TRANSACTION_ID = A.TRANSACTION_ID
 		AND D.SCHEDULE_TYPE = DECODE(g_ENABLE_SUPPLY_SCHEDULE_TYPES, 1, p_SCHEDULE_TYPE, g_NOT_ASSIGNED)
		AND D.SCHEDULE_STATE = GA.INTERNAL_STATE
		AND D.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND D.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_SCHEDULE
			WHERE TRANSACTION_ID = D.TRANSACTION_ID
				AND SCHEDULE_TYPE = D.SCHEDULE_TYPE
				AND SCHEDULE_STATE = D.SCHEDULE_STATE
				AND SCHEDULE_DATE = D.SCHEDULE_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE)
	GROUP BY D.SCHEDULE_DATE;

-- Planned Generation is modeled as Demand at Generation POR's = Actual Generation POD's..
CURSOR c_PLANNED IS
	SELECT D.SCHEDULE_DATE, SUM(D.AMOUNT) "AMOUNT"
	FROM INTERCHANGE_TRANSACTION A,
		IT_STATUS B,
		IT_COMMODITY C,
		IT_SCHEDULE D
	WHERE A.BEGIN_DATE <= TRUNC(p_END_DATE)
		AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
		AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) <> 'GE'
		AND A.POR_ID = p_SERVICE_POINT_ID -- Planned POR = Actual POD.
		AND B.TRANSACTION_ID = A.TRANSACTION_ID
		AND B.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_STATUS
			WHERE TRANSACTION_ID = B.TRANSACTION_ID
				AND AS_OF_DATE <= p_AS_OF_DATE)
		AND B.TRANSACTION_IS_ACTIVE = 1
		AND C.COMMODITY_ID = A.COMMODITY_ID
		AND UPPER(SUBSTR(C.COMMODITY_TYPE,1,1)) = 'E'
		AND D.TRANSACTION_ID = A.TRANSACTION_ID
		AND D.SCHEDULE_TYPE = DECODE(g_ENABLE_SUPPLY_SCHEDULE_TYPES, 1, p_SCHEDULE_TYPE, g_NOT_ASSIGNED)
		AND D.SCHEDULE_STATE = GA.INTERNAL_STATE
		AND D.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND D.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_SCHEDULE
			WHERE TRANSACTION_ID = D.TRANSACTION_ID
				AND SCHEDULE_TYPE = D.SCHEDULE_TYPE
				AND SCHEDULE_STATE = D.SCHEDULE_STATE
				AND SCHEDULE_DATE = D.SCHEDULE_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE)
	GROUP BY D.SCHEDULE_DATE;

BEGIN

	UT.CUT_DAY_INTERVAL_RANGE(p_BEGIN_DATE, p_END_DATE, GA.LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	FILL_GENERATION_POSITION_TABLE(v_BEGIN_DATE, v_END_DATE, p_GENERATION_POSITION_TABLE);

	FOR v_PLANNED IN c_PLANNED LOOP
		v_INDEX := ROUND((v_PLANNED.SCHEDULE_DATE - v_BEGIN_DATE) / GA.HOUR_DIVISOR);
		p_GENERATION_POSITION_TABLE(v_INDEX).PLANNED := p_GENERATION_POSITION_TABLE(v_INDEX).PLANNED + v_PLANNED.AMOUNT;
	END LOOP;

	FOR v_ACTUAL IN c_ACTUAL LOOP
		v_INDEX := ROUND((v_ACTUAL.SCHEDULE_DATE - v_BEGIN_DATE) / GA.HOUR_DIVISOR);
		p_GENERATION_POSITION_TABLE(v_INDEX).ACTUAL := p_GENERATION_POSITION_TABLE(v_INDEX).ACTUAL + v_ACTUAL.AMOUNT;
	END LOOP;

END GET_GENERATION_POSITION;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_GENERATION_BASIS
	(
	p_SCHEDULE_TYPE IN NUMBER,
	p_UNDER IN BOOLEAN,
	p_OVER IN BOOLEAN,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_NET_POSITION_TABLE IN OUT NET_POSITION_TABLE
	) AS

v_IMBALANCE NUMBER;
v_INDEX BINARY_INTEGER;
v_GENERATION_POSITION_TABLE GENERATION_POSITION_TABLE;

CURSOR c_GENERATION IS
	SELECT DISTINCT A.POD_ID
	FROM INTERCHANGE_TRANSACTION A,
		IT_STATUS B,
		IT_COMMODITY C,
		SERVICE_POINT D
	WHERE A.BEGIN_DATE <= TRUNC(p_END_DATE)
		AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
		AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) = 'GE' -- Generation Transactions to the POD.
		AND B.TRANSACTION_ID = A.TRANSACTION_ID
		AND B.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_STATUS
			WHERE TRANSACTION_ID = B.TRANSACTION_ID
				AND AS_OF_DATE <= p_AS_OF_DATE)
		AND B.TRANSACTION_IS_ACTIVE = 1
		AND C.COMMODITY_ID = A.COMMODITY_ID
		AND UPPER(SUBSTR(C.COMMODITY_TYPE,1,1)) = 'E' -- Energy Commodity.
		AND D.SERVICE_POINT_ID = A.POD_ID -- Generation at POD.
		AND UPPER(SUBSTR(D.SERVICE_POINT_TYPE,1,1)) = 'G'; -- Genertaion Points.

BEGIN

	FOR v_GENERATION IN c_GENERATION LOOP
		GET_GENERATION_POSITION(p_SCHEDULE_TYPE, v_GENERATION.POD_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, v_GENERATION_POSITION_TABLE);
		IF v_GENERATION_POSITION_TABLE.COUNT > 0 THEN
			FOR v_INDEX IN v_GENERATION_POSITION_TABLE.FIRST..v_GENERATION_POSITION_TABLE.LAST LOOP
				v_IMBALANCE := v_GENERATION_POSITION_TABLE(v_INDEX).ACTUAL - v_GENERATION_POSITION_TABLE(v_INDEX).PLANNED;
				IF (p_UNDER AND v_IMBALANCE > 0) OR (p_OVER AND v_IMBALANCE < 0)  THEN
					v_IMBALANCE := 0;
				END IF;
				IF NOT p_NET_POSITION_TABLE.EXISTS(v_INDEX) THEN
					p_NET_POSITION_TABLE(v_INDEX).SCHEDULE_DATE := v_GENERATION_POSITION_TABLE(v_INDEX).SCHEDULE_DATE;
					p_NET_POSITION_TABLE(v_INDEX).POSITION := 0;
				END IF;
				p_NET_POSITION_TABLE(v_INDEX).POSITION := p_NET_POSITION_TABLE(v_INDEX).POSITION + v_IMBALANCE;
			END LOOP;
		END IF;
		v_GENERATION_POSITION_TABLE.DELETE;
	END LOOP;

END GET_GENERATION_BASIS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_NET_POSITION
	(
	p_SCHEDULE_TYPE IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_SERVICE_POINT_TYPE IN VARCHAR,
	p_SERVICE_POINT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_NET_POSITION_TABLE IN OUT NET_POSITION_TABLE
	) AS

v_INDEX BINARY_INTEGER;
v_SERVICE_POINT_TYPE CHAR(1);
v_BEGIN_DATE DATE;
v_END_DATE DATE;

CURSOR c_POSITION IS
	SELECT G.SCHEDULE_DATE,
		SUM(DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'LO', G.AMOUNT, 0)) "LOAD",
		SUM(DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'GE', G.AMOUNT, 0)) "GENERATION",
		SUM(DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'PU', G.AMOUNT, 'NO', G.AMOUNT, 0)) "PURCHASES",
		SUM(DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'SA', G.AMOUNT, 0)) "SALES"
	FROM INTERCHANGE_TRANSACTION A,
		IT_STATUS B,
		INTERCHANGE_CONTRACT C,
		PURCHASING_SELLING_ENTITY D,
		IT_COMMODITY E,
		SERVICE_POINT F,
		IT_SCHEDULE G
	WHERE A.BEGIN_DATE <= TRUNC(p_END_DATE)
		AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
		AND B.TRANSACTION_ID = A.TRANSACTION_ID
		AND B.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_STATUS
			WHERE TRANSACTION_ID = B.TRANSACTION_ID
				AND AS_OF_DATE <= p_AS_OF_DATE)
		AND B.TRANSACTION_IS_ACTIVE = 1
		AND C.CONTRACT_ID = A.CONTRACT_ID
		AND D.PSE_ID = C.BILLING_ENTITY_ID
		AND UPPER(SUBSTR(D.PSE_TYPE,1,1)) = 'M' -- Marketer
		AND D.PSE_IS_RETAIL_AGGREGATOR = DECODE(UPPER(SUBSTR(p_SERVICE_POINT_TYPE,1,1)),'R',1,D.PSE_IS_RETAIL_AGGREGATOR)
		AND E.COMMODITY_ID = A.COMMODITY_ID
		AND UPPER(SUBSTR(E.COMMODITY_TYPE,1,1)) = 'E' -- Energy Commodity
		AND ((UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) IN ('LO','SA')
			AND (A.SELLER_ID = C.BILLING_ENTITY_ID	-- PSE is the Selling Party to the Transaction.
				OR A.PSE_ID = C.BILLING_ENTITY_ID)	-- PSE_ID for Gas Party Transactions
			AND A.POR_ID = DECODE(p_SERVICE_POINT_ID, g_NOT_ASSIGNED, A.POR_ID, p_SERVICE_POINT_ID)
			AND F.SERVICE_POINT_ID = A.POR_ID
			AND F.EDC_ID = DECODE(p_EDC_ID, g_ALL, F.EDC_ID, p_EDC_ID)
			AND (v_SERVICE_POINT_TYPE = 'A' OR UPPER(SUBSTR(F.SERVICE_POINT_TYPE,1,1)) = v_SERVICE_POINT_TYPE))
		OR (UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) IN ('PU','NO','GE')
			AND (A.PURCHASER_ID = C.BILLING_ENTITY_ID 	-- PSE is the Purchasing Party to the Transaction.
				OR A.PSE_ID = C.BILLING_ENTITY_ID)	-- PSE_ID for Gas Model Transactions
			AND A.POD_ID = DECODE(p_SERVICE_POINT_ID, g_NOT_ASSIGNED, A.POD_ID, p_SERVICE_POINT_ID)
			AND F.SERVICE_POINT_ID = A.POD_ID
			AND F.EDC_ID = DECODE(p_EDC_ID, g_ALL, F.EDC_ID, p_EDC_ID)
			AND (v_SERVICE_POINT_TYPE = 'A' OR UPPER(SUBSTR(F.SERVICE_POINT_TYPE,1,1)) = v_SERVICE_POINT_TYPE)))
		AND G.TRANSACTION_ID = A.TRANSACTION_ID
		AND ((UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) = 'LO' AND G.SCHEDULE_TYPE = p_SCHEDULE_TYPE)
			OR (UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) IN ('PU','NO','SA','GE') AND G.SCHEDULE_TYPE = DECODE(g_ENABLE_SUPPLY_SCHEDULE_TYPES, 1, p_SCHEDULE_TYPE, g_NOT_ASSIGNED)))
		AND G.SCHEDULE_STATE = GA.INTERNAL_STATE
		AND G.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND G.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_SCHEDULE
			WHERE TRANSACTION_ID = G.TRANSACTION_ID
				AND SCHEDULE_TYPE = G.SCHEDULE_TYPE
				AND SCHEDULE_STATE = G.SCHEDULE_STATE
				AND SCHEDULE_DATE = G.SCHEDULE_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE)
	GROUP BY G.SCHEDULE_DATE;

BEGIN

	UT.CUT_DAY_INTERVAL_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	FILL_NET_POSITION_TABLE(v_BEGIN_DATE, v_END_DATE, p_NET_POSITION_TABLE);

	SELECT UPPER(SUBSTR(p_SERVICE_POINT_TYPE,1,1)) INTO v_SERVICE_POINT_TYPE FROM DUAL;

-- Net Position = Supply (Purchases@POD + Generation@POD - Sales@POR) - Demand (Load @POR)

	FOR v_POSITION IN c_POSITION LOOP
		v_INDEX := ROUND((v_POSITION.SCHEDULE_DATE - p_BEGIN_DATE) / GA.HOUR_DIVISOR);
		p_NET_POSITION_TABLE(v_INDEX).DEMAND := v_POSITION.LOAD;
		p_NET_POSITION_TABLE(v_INDEX).SUPPLY := v_POSITION.PURCHASES + v_POSITION.GENERATION - v_POSITION.SALES;
		p_NET_POSITION_TABLE(v_INDEX).POSITION := p_NET_POSITION_TABLE(v_INDEX).SUPPLY - p_NET_POSITION_TABLE(v_INDEX).DEMAND;
	END LOOP;

END GET_NET_POSITION;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_SUPPLY_POSITION
	(
	p_SCHEDULE_TYPE IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SUPPLY_POSITION IN OUT SUPPLY_POSITION_TABLE
	) AS

-- Compute the EDC Retail Position at all Retail Service Points by summing each PSE's Position.
-- Note: p_BEGIN_DATE and p_END_DATE are CUT dates.

v_IMBALANCE NUMBER;
v_INDEX BINARY_INTEGER;

CURSOR c_POSITION IS
	SELECT G.SCHEDULE_DATE, D.PSE_ID,
		SUM(DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'LO', G.AMOUNT, 0)) "LOAD",
		SUM(DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'GE', G.AMOUNT, 0)) "GENERATION",
		SUM(DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'PU', G.AMOUNT, 'NO', G.AMOUNT, 0)) "PURCHASES",
		SUM(DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'SA', G.AMOUNT, 0)) "SALES"
	FROM INTERCHANGE_TRANSACTION A,
		IT_STATUS B,
		INTERCHANGE_CONTRACT C,
		PURCHASING_SELLING_ENTITY D,
		IT_COMMODITY E,
		SERVICE_POINT F,
		IT_SCHEDULE G
	WHERE A.BEGIN_DATE <= TRUNC(p_END_DATE)
		AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
		AND B.TRANSACTION_ID = A.TRANSACTION_ID
		AND B.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_STATUS
			WHERE TRANSACTION_ID = B.TRANSACTION_ID
				AND AS_OF_DATE <= p_AS_OF_DATE)
		AND B.TRANSACTION_IS_ACTIVE = 1
		AND C.CONTRACT_ID = A.CONTRACT_ID
		AND D.PSE_ID = C.BILLING_ENTITY_ID
		AND UPPER(SUBSTR(D.PSE_TYPE,1,1)) = 'M'
		AND D.PSE_IS_RETAIL_AGGREGATOR = 1
		AND UPPER(SUBSTR(D.PSE_STATUS,1,1)) = 'A'
		AND E.COMMODITY_ID = A.COMMODITY_ID
		AND UPPER(SUBSTR(E.COMMODITY_TYPE,1,1)) = 'E'
		AND ((UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) IN ('LO','SA')
			AND (A.SELLER_ID = C.BILLING_ENTITY_ID 	-- PSE is the Selling Party to the Transaction.
				OR A.PSE_ID = C.BILLING_ENTITY_ID) 	-- PSE_ID for Gas Model Transactions
			AND F.SERVICE_POINT_ID = A.POR_ID
			AND F.EDC_ID = DECODE(p_EDC_ID, g_ALL, F.EDC_ID, p_EDC_ID)
			AND UPPER(SUBSTR(F.SERVICE_POINT_TYPE,1,1)) = 'R')
		OR (UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) IN ('PU','NO','GE')
			AND (A.PURCHASER_ID = C.BILLING_ENTITY_ID -- PSE is the Purchasing Party to the Transaction.
				OR A.PSE_ID = C.BILLING_ENTITY_ID)  -- PSE_ID for Gas Model Transactions
			AND F.SERVICE_POINT_ID = A.POD_ID
			AND F.EDC_ID = DECODE(p_EDC_ID, g_ALL, F.EDC_ID, p_EDC_ID)
			AND UPPER(SUBSTR(F.SERVICE_POINT_TYPE,1,1)) = 'R'))
		AND G.TRANSACTION_ID = A.TRANSACTION_ID
		AND ((UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) = 'LO' AND G.SCHEDULE_TYPE = p_SCHEDULE_TYPE)
			OR (UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) IN ('PU','NO','SA','GE') AND G.SCHEDULE_TYPE = DECODE(g_ENABLE_SUPPLY_SCHEDULE_TYPES, 1, p_SCHEDULE_TYPE, g_NOT_ASSIGNED)))
		AND G.SCHEDULE_STATE = GA.INTERNAL_STATE
		AND G.SCHEDULE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
		AND G.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_SCHEDULE
			WHERE TRANSACTION_ID = G.TRANSACTION_ID
				AND SCHEDULE_TYPE = G.SCHEDULE_TYPE
				AND SCHEDULE_STATE = G.SCHEDULE_STATE
				AND SCHEDULE_DATE = G.SCHEDULE_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE)
	GROUP BY G.SCHEDULE_DATE, D.PSE_ID;

BEGIN

	FILL_SUPPLY_POSITION_TABLE(p_BEGIN_DATE, p_END_DATE, p_SUPPLY_POSITION);

    FOR v_POSITION IN c_POSITION LOOP
		v_INDEX := ROUND((v_POSITION.SCHEDULE_DATE - p_BEGIN_DATE) / GA.HOUR_DIVISOR);
		v_IMBALANCE := (v_POSITION.PURCHASES + v_POSITION.GENERATION - v_POSITION.SALES) - v_POSITION.LOAD;
		p_SUPPLY_POSITION(v_INDEX).SCHEDULE_DATE := v_POSITION.SCHEDULE_DATE;
		IF v_IMBALANCE <= 0 THEN
			p_SUPPLY_POSITION(v_INDEX).UNDER_SUPPLY := p_SUPPLY_POSITION(v_INDEX).UNDER_SUPPLY + ABS(v_IMBALANCE);
		ELSE
			p_SUPPLY_POSITION(v_INDEX).OVER_SUPPLY := p_SUPPLY_POSITION(v_INDEX).OVER_SUPPLY + v_IMBALANCE;
		END IF;
	END LOOP;

	FOR v_INDEX IN p_SUPPLY_POSITION.FIRST..p_SUPPLY_POSITION.LAST LOOP
			p_SUPPLY_POSITION(v_INDEX).POSITION := p_SUPPLY_POSITION(v_INDEX).OVER_SUPPLY - p_SUPPLY_POSITION(v_INDEX).UNDER_SUPPLY;
	END LOOP;

END GET_SUPPLY_POSITION;
---------------------------------------------------------------------------------------------------
FUNCTION GET_PSE_DEMAND_ON_DATE
	(
	p_PSE_ID IN NUMBER,
	p_POD_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_PEAK_DATE IN DATE,
	p_AS_OF_DATE IN DATE
	) RETURN NUMBER IS

v_AMOUNT NUMBER := 0;

CURSOR c_DEMAND IS
	SELECT SUM(C.AMOUNT) "AMOUNT"
	FROM INTERCHANGE_TRANSACTION A, IT_STATUS B, IT_SCHEDULE C
	WHERE A.PURCHASER_ID = p_PSE_ID
		AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) = 'LO'
		AND A.POD_ID = DECODE(p_POD_ID, g_NOT_ASSIGNED, A.POD_ID, p_POD_ID)
		AND B.TRANSACTION_ID = A.TRANSACTION_ID
		AND B.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_STATUS
			WHERE TRANSACTION_ID = B.TRANSACTION_ID
				AND AS_OF_DATE <= p_AS_OF_DATE)
		AND B.TRANSACTION_IS_ACTIVE = 1
		AND C.TRANSACTION_ID = A.TRANSACTION_ID
    	AND C.SCHEDULE_TYPE = p_SCHEDULE_TYPE
		AND C.SCHEDULE_STATE = GA.INTERNAL_STATE
		AND C.SCHEDULE_DATE = p_PEAK_DATE
		AND C.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_SCHEDULE
			WHERE TRANSACTION_ID = C.TRANSACTION_ID
				AND SCHEDULE_TYPE = C.SCHEDULE_TYPE
				AND SCHEDULE_STATE = C.SCHEDULE_STATE
				AND SCHEDULE_DATE = C.SCHEDULE_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE);

BEGIN

	FOR v_DEMAND IN c_DEMAND LOOP
		v_AMOUNT := v_DEMAND.AMOUNT;
	END LOOP;

	RETURN v_AMOUNT;

END GET_PSE_DEMAND_ON_DATE;
---------------------------------------------------------------------------------------------------
PROCEDURE CACHE_OPER_PROFIT_TX_IDs
	(
	p_IDs_WORK_ID OUT NUMBER,
	p_CONTRACT_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE
	) AS
BEGIN

	UT.GET_RTO_WORK_ID(p_IDs_WORK_ID);

	INSERT INTO RTO_WORK (WORK_ID, WORK_XID, WORK_DATA)
	SELECT p_IDs_WORK_ID, A.TRANSACTION_ID, A.TRANSACTION_TYPE
	FROM INTERCHANGE_TRANSACTION A,
		IT_STATUS B
	WHERE A.BEGIN_DATE <= TRUNC(p_END_DATE)
		AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
		AND A.CONTRACT_ID = p_CONTRACT_ID
		AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) IN ('GE','LO')
		AND UPPER(A.TRANSACTION_INTERVAL) =  UPPER(p_COMPONENT.RATE_INTERVAL)
		AND A.POD_ID = DECODE(p_COMPONENT.SERVICE_POINT_ID, g_NOT_ASSIGNED, A.POD_ID, p_COMPONENT.SERVICE_POINT_ID)
		AND A.IS_BID_OFFER = 1
		AND B.TRANSACTION_ID = A.TRANSACTION_ID
		AND B.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_STATUS
			WHERE TRANSACTION_ID = B.TRANSACTION_ID
				AND AS_OF_DATE <= p_AS_OF_DATE)
		AND B.TRANSACTION_IS_ACTIVE = 1;

END CACHE_OPER_PROFIT_TX_IDs;
---------------------------------------------------------------------------------------------------
PROCEDURE CACHE_OPER_PROFIT_DATES
	(
	p_DATES_WORK_ID OUT NUMBER,
	p_IDs_WORK_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE) AS
BEGIN

	UT.GET_RTO_WORK_ID(p_DATES_WORK_ID);

	INSERT INTO RTO_WORK (WORK_ID, WORK_DATE)
	SELECT DISTINCT p_DATES_WORK_ID, B.SCHEDULE_DATE
	FROM RTO_WORK A,
		IT_SCHEDULE B
	WHERE A.WORK_ID = p_IDs_WORK_ID
		AND B.TRANSACTION_ID = A.WORK_XID
		AND B.SCHEDULE_TYPE BETWEEN 1 AND p_SCHEDULE_TYPE
		AND B.SCHEDULE_STATE = GA.INTERNAL_STATE
		AND B.SCHEDULE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
		AND B.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_SCHEDULE
			WHERE TRANSACTION_ID = B.TRANSACTION_ID
				AND SCHEDULE_TYPE = B.SCHEDULE_TYPE
				AND SCHEDULE_STATE = B.SCHEDULE_STATE
				AND SCHEDULE_DATE = B.SCHEDULE_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE);

END CACHE_OPER_PROFIT_DATES;
---------------------------------------------------------------------------------------------------
PROCEDURE NET_OFFER_CURVES
	(
	p_WORK_ID IN NUMBER,
	p_CHARGE_DATE IN DATE,
	p_CHARGE_ID IN NUMBER
	) AS
v_SET_NUMBER NUMBER := 1;
CURSOR c_PRICE_POINTS IS
	SELECT DISTINCT WORK_PRICE "PRICE"
	FROM OPER_PROFIT_WORK
	WHERE WORK_ID = p_WORK_ID
		AND WORK_DATE = p_CHARGE_DATE
	ORDER BY 1;
v_FIRST BOOLEAN := TRUE;
v_FIRST_QUANTITY NUMBER;
BEGIN
	FOR v_PRICE_POINT IN c_PRICE_POINTS LOOP
		IF v_FIRST THEN
			SELECT SUM(WORK_QUANTITY) INTO v_FIRST_QUANTITY
			FROM OPER_PROFIT_WORK A
			WHERE WORK_ID = p_WORK_ID
				AND WORK_DATE = p_CHARGE_DATE
				AND WORK_PRICE = (SELECT NVL(MAX(X.WORK_PRICE),v_PRICE_POINT.PRICE)
						FROM OPER_PROFIT_WORK X
						WHERE X.WORK_ID = A.WORK_ID
							AND X.WORK_XID = A.WORK_XID
							AND X.WORK_DATE = A.WORK_DATE
							AND X.WORK_PRICE <= v_PRICE_POINT.PRICE);
			-- first quantity should be zero, so add it a zero
			-- at same price as first price point
			IF v_FIRST_QUANTITY <> 0 THEN
				INSERT INTO OPER_PROFIT_CHARGE_SET
					(CHARGE_ID, CHARGE_DATE,
					SET_NUMBER, PRICE, QUANTITY)
				VALUES (
					p_CHARGE_ID, p_CHARGE_DATE,
					v_SET_NUMBER, v_PRICE_POINT.PRICE, 0);
				v_SET_NUMBER := v_SET_NUMBER + 1;
			END IF;
			v_FIRST := FALSE;
		END IF;
		INSERT INTO OPER_PROFIT_CHARGE_SET
			(CHARGE_ID, CHARGE_DATE, SET_NUMBER, PRICE, QUANTITY)
		SELECT p_CHARGE_ID,
			p_CHARGE_DATE,
			v_SET_NUMBER,
			v_PRICE_POINT.PRICE,
			SUM(WORK_QUANTITY)
		FROM OPER_PROFIT_WORK A
		WHERE WORK_ID = p_WORK_ID
			AND WORK_DATE = p_CHARGE_DATE
			AND WORK_PRICE = (SELECT NVL(MAX(X.WORK_PRICE),v_PRICE_POINT.PRICE)
					FROM OPER_PROFIT_WORK X
					WHERE X.WORK_ID = A.WORK_ID
						AND X.WORK_XID = A.WORK_XID
						AND X.WORK_DATE = A.WORK_DATE
						AND X.WORK_PRICE <= v_PRICE_POINT.PRICE)
		GROUP BY p_CHARGE_ID, p_CHARGE_DATE, v_SET_NUMBER, v_PRICE_POINT.PRICE;

		v_SET_NUMBER := v_SET_NUMBER + 1;
	END LOOP;
END NET_OFFER_CURVES;
---------------------------------------------------------------------------------------------------
PROCEDURE CACHE_OPER_PROFIT_OFFER_CURVES
	(
	p_IDs_WORK_ID IN NUMBER,
	p_CHARGE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_BID_OFFER_INTERVAL OUT VARCHAR,
	p_UNITS_FACTOR IN NUMBER,
	p_COMPONENT_UNIT IN VARCHAR
	) AS

v_WORK_ID NUMBER;
v_PREV_DATE DATE := NULL;
CURSOR c_BIDS IS
	SELECT DISTINCT A.TRANSACTION_ID,
		A.SCHEDULE_DATE
	FROM IT_TRAIT_SCHEDULE_STATUS A,
		RTO_WORK B
	WHERE B.WORK_ID = p_IDs_WORK_ID
		AND A.TRANSACTION_ID = B.WORK_XID
		AND A.SCHEDULE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
	ORDER BY A.SCHEDULE_DATE;

BEGIN
	UT.GET_RTO_WORK_ID(v_WORK_ID);

	FOR v_BID IN c_BIDS LOOP
		IF NOT (v_PREV_DATE IS NULL) AND v_BID.SCHEDULE_DATE <> v_PREV_DATE THEN
			-- "net" these curves before moving to next date
			NET_OFFER_CURVES (v_WORK_ID, v_PREV_DATE, p_CHARGE_ID);
		END IF;

		-- put the applicable curve into the temp table
		INSERT INTO OPER_PROFIT_WORK
			(WORK_ID, WORK_XID, WORK_DATE, WORK_SET_NUMBER, WORK_PRICE, WORK_QUANTITY)
		SELECT v_WORK_ID, v_BID.TRANSACTION_ID, v_BID.SCHEDULE_DATE, SET_NUMBER, PRICE,
			QUANTITY*DECODE(UPPER(C.COMMODITY_UNIT||p_COMPONENT_UNIT),'MWHMW',p_UNITS_FACTOR,'MWMWH',1/p_UNITS_FACTOR,1)
		FROM BID_OFFER_SET A,
			INTERCHANGE_TRANSACTION B,
			IT_COMMODITY C
		WHERE A.TRANSACTION_ID = v_BID.TRANSACTION_ID
			AND SCHEDULE_STATE = GA.INTERNAL_STATE
			AND SCHEDULE_DATE = v_BID.SCHEDULE_DATE
			AND B.TRANSACTION_ID = A.TRANSACTION_ID
			AND C.COMMODITY_ID = B.COMMODITY_ID;

		v_PREV_DATE := v_BID.SCHEDULE_DATE;
	END LOOP;

	-- "net" the curves for the last date
	NET_OFFER_CURVES (v_WORK_ID, v_PREV_DATE, p_CHARGE_ID);
	-- clean up the temp table
	DELETE FROM OPER_PROFIT_WORK WHERE WORK_ID = v_WORK_ID;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		p_BID_OFFER_INTERVAL := 'HOUR';
		DELETE FROM OPER_PROFIT_WORK WHERE WORK_ID = v_WORK_ID;
	WHEN OTHERS THEN
		BEGIN
			DELETE FROM OPER_PROFIT_WORK WHERE WORK_ID = v_WORK_ID;
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE;
		END;
		ERRS.LOG_AND_RAISE;

END CACHE_OPER_PROFIT_OFFER_CURVES;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_GET_OFFER_CURVE
	(
	p_CHARGE_DATE IN DATE,
	p_CHARGE_ID IN NUMBER,
	p_BID_OFFER_INTERVAL IN VARCHAR
	) AS
v_COUNT NUMBER := 0;
v_TRUNC_INTERVAL VARCHAR(16);
BEGIN

	SELECT COUNT(SET_NUMBER) INTO v_COUNT
	FROM OPER_PROFIT_CHARGE_SET
	WHERE CHARGE_ID = p_CHARGE_ID
		AND CHARGE_DATE = p_CHARGE_DATE;

	-- already have offer curve (from cached ones)? then nothing to do
	IF v_COUNT > 0 THEN
		RETURN;
	END IF;

	SELECT DECODE(UPPER(p_BID_OFFER_INTERVAL), 'MONTH', 'MONTH', 'QUARTER', 'Q', 'YEAR', 'YEAR', 'WEEK', 'DY', 'DAY', 'DD', 'HH')
	INTO v_TRUNC_INTERVAL
	FROM DUAL;

	-- copy offer curve from corresponding cached curve
	INSERT INTO OPER_PROFIT_CHARGE_SET
		(CHARGE_ID, CHARGE_DATE, SET_NUMBER, QUANTITY, PRICE)
	SELECT p_CHARGE_ID, p_CHARGE_DATE, SET_NUMBER, QUANTITY, PRICE
	FROM OPER_PROFIT_CHARGE_SET
	WHERE CHARGE_ID = p_CHARGE_ID
		AND CHARGE_DATE = TRUNC(ADD_SECONDS_TO_DATE(ADD_HOURS_TO_DATE(p_CHARGE_DATE,1),-1), v_TRUNC_INTERVAL);
		-- complex date arithmetic and trunc to accomodate for hour-ending
END PSE_GET_OFFER_CURVE;
---------------------------------------------------------------------------------------------------
FUNCTION OP
	(
	Q IN NUMBER,
	P IN NUMBER,
	B IN GA.FLOAT_TABLE
	) RETURN NUMBER IS

S NUMBER := -1;
PI NUMBER;
Ps1 NUMBER;
QI NUMBER;
Qi_1 NUMBER;
Qs NUMBER;
VAL NUMBER;

BEGIN

	IF B.COUNT < 4 THEN
		RETURN 0;
	END IF;

	VAL := P*Q;
	Qi_1 := B(0*2+1);
	FOR I IN 1..(B.COUNT/2-1) LOOP
		PI := B(I*2);
		QI := B(I*2+1);
		IF QI > Q THEN
			Qs := Qi_1;
			Ps1 := PI;
			S := I-1;
			EXIT;
		END IF;
		VAL := VAL - (PI * (QI - Qi_1));
		Qi_1 := QI;
	END LOOP;
	IF S = -1 THEN
		Qs := B(B.LAST);
		Ps1 := B(B.LAST-1);
	END IF;
	VAL := VAL - (Ps1 * (Q - Qs));

	RETURN VAL;

END OP;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_COMPUTE_OPERATIONAL_PROFIT
	(
	p_OPER_PROFIT_CHARGE IN OUT OPER_PROFIT_CHARGE%ROWTYPE
	) AS

v_PQ_PAIRS GA.FLOAT_TABLE;
v_MARKET_OP NUMBER;
v_DISPATCH_OP NUMBER;
v_ACTUAL_OP NUMBER;
v_INDEX NUMBER;
CURSOR c_PQs IS
	SELECT SET_NUMBER, NVL(PRICE,0) "PRICE", NVL(QUANTITY,0) "QUANTITY"
	FROM OPER_PROFIT_CHARGE_SET
	WHERE CHARGE_ID = p_OPER_PROFIT_CHARGE.CHARGE_ID
		AND CHARGE_DATE = p_OPER_PROFIT_CHARGE.CHARGE_DATE
	ORDER BY SET_NUMBER;

BEGIN

	-- build table of price/quantity pairs
	FOR v_PQ IN c_PQs LOOP
		v_INDEX := (v_PQ.SET_NUMBER - 1) * 2;
		v_PQ_PAIRS(v_INDEX) := v_PQ.PRICE;
		v_PQ_PAIRS(v_INDEX+1) := v_PQ.QUANTITY;
	END LOOP;

	-- compute operational profit
	v_MARKET_OP := OP(p_OPER_PROFIT_CHARGE.MARKET_QUANTITY, p_OPER_PROFIT_CHARGE.CHARGE_RATE, v_PQ_PAIRS);
	v_DISPATCH_OP := OP(p_OPER_PROFIT_CHARGE.DISPATCH_QUANTITY, p_OPER_PROFIT_CHARGE.CHARGE_RATE, v_PQ_PAIRS);
	v_ACTUAL_OP := OP(p_OPER_PROFIT_CHARGE.ACTUAL_QUANTITY, p_OPER_PROFIT_CHARGE.CHARGE_RATE, v_PQ_PAIRS);
	p_OPER_PROFIT_CHARGE.MARKET_OPER_PROFIT := v_MARKET_OP;
	p_OPER_PROFIT_CHARGE.DISPATCH_OPER_PROFIT := v_DISPATCH_OP;
	p_OPER_PROFIT_CHARGE.ACTUAL_OPER_PROFIT := v_ACTUAL_OP;

	-- compute the charge amount
    IF SIGN(p_OPER_PROFIT_CHARGE.DISPATCH_QUANTITY-p_OPER_PROFIT_CHARGE.MARKET_QUANTITY) <>
       SIGN(p_OPER_PROFIT_CHARGE.ACTUAL_QUANTITY-p_OPER_PROFIT_CHARGE.MARKET_QUANTITY) THEN
       	p_OPER_PROFIT_CHARGE.CHARGE_AMOUNT := 0;
	ELSIF v_DISPATCH_OP > v_ACTUAL_OP THEN
		p_OPER_PROFIT_CHARGE.CHARGE_AMOUNT := v_MARKET_OP - v_DISPATCH_OP;
	ELSE
		p_OPER_PROFIT_CHARGE.CHARGE_AMOUNT := v_MARKET_OP - v_ACTUAL_OP;
	END IF;

END PSE_COMPUTE_OPERATIONAL_PROFIT;
---------------------------------------------------------------------------------------------------
FUNCTION GET_PRIOR_CHARGE_ID
	(
	p_BILLING_STATEMENT IN BILLING_STATEMENT%ROWTYPE
	) RETURN NUMBER IS
-- Answer the CHARGE_ID associated with a prior statement type.
v_CHARGE_ID BILLING_STATEMENT.CHARGE_ID%TYPE;
v_COMBO_CHARGE_ID BILLING_STATEMENT.CHARGE_ID%TYPE;
v_PRIOR_TYPE_ID STATEMENT_TYPE.STATEMENT_TYPE_ID%TYPE;
BEGIN
	IF p_BILLING_STATEMENT.PRODUCT_ID < 0 THEN
		-- negative Product ID indicates the Charge ID of a combination charge
        v_COMBO_CHARGE_ID := GET_PRIOR_CHARGE_ID(-p_BILLING_STATEMENT.PRODUCT_ID);
        SELECT COMBINED_CHARGE_ID
        INTO v_CHARGE_ID
        FROM COMBINATION_CHARGE
        WHERE CHARGE_ID = v_COMBO_CHARGE_ID
	        AND COMPONENT_ID = p_BILLING_STATEMENT.COMPONENT_ID
	        AND BEGIN_DATE = p_BILLING_STATEMENT.STATEMENT_DATE;
	ELSE
    	BEGIN
    		SELECT STATEMENT_TYPE_ID INTO v_PRIOR_TYPE_ID
            FROM (SELECT B.STATEMENT_TYPE_ID
            		FROM STATEMENT_TYPE A, STATEMENT_TYPE B
                    WHERE A.STATEMENT_TYPE_ID = p_BILLING_STATEMENT.STATEMENT_TYPE
                    	AND B.STATEMENT_TYPE_ORDER < A.STATEMENT_TYPE_ORDER
    				ORDER BY B.STATEMENT_TYPE_ORDER DESC)
            WHERE ROWNUM = 1;
        EXCEPTION
        	WHEN NO_DATA_FOUND THEN
            	RETURN 0;
        END;

    	IF GA.VERSION_STATEMENT THEN
    		SELECT CHARGE_ID
    		INTO v_CHARGE_ID
    		FROM BILLING_STATEMENT A
    		WHERE ENTITY_ID = p_BILLING_STATEMENT.ENTITY_ID
    			AND PRODUCT_ID = p_BILLING_STATEMENT.PRODUCT_ID
    			AND COMPONENT_ID = p_BILLING_STATEMENT.COMPONENT_ID
    			AND STATEMENT_TYPE = v_PRIOR_TYPE_ID
    			AND STATEMENT_STATE = p_BILLING_STATEMENT.STATEMENT_STATE
    			AND STATEMENT_DATE = p_BILLING_STATEMENT.STATEMENT_DATE
    			AND AS_OF_DATE =
    				(SELECT MAX(AS_OF_DATE)
    				FROM BILLING_STATEMENT
    				WHERE ENTITY_ID = A.ENTITY_ID
    					AND PRODUCT_ID = A.PRODUCT_ID
    					AND COMPONENT_ID = A.COMPONENT_ID
    					AND STATEMENT_TYPE = A.STATEMENT_TYPE
    					AND STATEMENT_STATE = A.STATEMENT_STATE
    					AND STATEMENT_DATE = A.STATEMENT_DATE
    					AND AS_OF_DATE <= p_BILLING_STATEMENT.AS_OF_DATE);
    	ELSE
    		SELECT CHARGE_ID
    		INTO v_CHARGE_ID
    		FROM BILLING_STATEMENT A
    		WHERE ENTITY_ID = p_BILLING_STATEMENT.ENTITY_ID
    			AND PRODUCT_ID = p_BILLING_STATEMENT.PRODUCT_ID
    			AND COMPONENT_ID = p_BILLING_STATEMENT.COMPONENT_ID
    			AND STATEMENT_TYPE = v_PRIOR_TYPE_ID
    			AND STATEMENT_STATE = p_BILLING_STATEMENT.STATEMENT_STATE
    			AND STATEMENT_DATE = p_BILLING_STATEMENT.STATEMENT_DATE
    			AND AS_OF_DATE = CONSTANTS.LOW_DATE;
    	END IF;
	END IF;

	RETURN v_CHARGE_ID;

EXCEPTION
	WHEN OTHERS THEN
		RETURN g_NOT_ASSIGNED;
END GET_PRIOR_CHARGE_ID;
---------------------------------------------------------------------------------------------------
FUNCTION GET_PRIOR_CHARGE_ID
	(
	p_CHARGE_ID IN NUMBER
	) RETURN NUMBER IS
-- Answer the CHARGE_ID associated with a prior statement type.
v_BILLING_STATEMENT BILLING_STATEMENT%ROWTYPE;
BEGIN
    SELECT * INTO v_BILLING_STATEMENT FROM BILLING_STATEMENT WHERE CHARGE_ID = p_CHARGE_ID;
    RETURN GET_PRIOR_CHARGE_ID(v_BILLING_STATEMENT);

EXCEPTION
	WHEN OTHERS THEN
		RETURN g_NOT_ASSIGNED;
END GET_PRIOR_CHARGE_ID;
---------------------------------------------------------------------------------------------------
FUNCTION GET_PRIOR_PERIOD_CHARGE_ID
	(
	p_BILLING_STATEMENT IN BILLING_STATEMENT%ROWTYPE
	) RETURN NUMBER IS

-- Answer the CHARGE_ID associated with a prior period statement.

v_CHARGE_ID BILLING_STATEMENT.CHARGE_ID%TYPE;
v_PREVIOUS_PERIOD_DATE DATE;
v_CALLING_MODULE VARCHAR2(1);

BEGIN
	-- make sure we are looking at correct prior period
    IF p_BILLING_STATEMENT.ENTITY_TYPE = g_PSE THEN
    	v_CALLING_MODULE := g_SCHEDULING;
	ELSE
    	v_CALLING_MODULE := '?';
    END IF;

	v_PREVIOUS_PERIOD_DATE := GET_CORRECT_STATEMENT_DATE(v_CALLING_MODULE,p_BILLING_STATEMENT.ENTITY_ID,p_BILLING_STATEMENT.STATEMENT_DATE-1);

    SELECT CHARGE_ID
    INTO v_CHARGE_ID
    FROM BILLING_STATEMENT A
    WHERE ENTITY_ID = p_BILLING_STATEMENT.ENTITY_ID
	    AND PRODUCT_ID = p_BILLING_STATEMENT.PRODUCT_ID
	    AND COMPONENT_ID = p_BILLING_STATEMENT.COMPONENT_ID
	    AND STATEMENT_TYPE = p_BILLING_STATEMENT.STATEMENT_TYPE
	    AND STATEMENT_STATE = p_BILLING_STATEMENT.STATEMENT_STATE
	    AND STATEMENT_DATE = v_PREVIOUS_PERIOD_DATE
	    AND AS_OF_DATE =
			    (SELECT MAX(AS_OF_DATE)
				    FROM BILLING_STATEMENT
				    WHERE ENTITY_ID = A.ENTITY_ID
				    	AND PRODUCT_ID = A.PRODUCT_ID
				    	AND COMPONENT_ID = A.COMPONENT_ID
				    	AND STATEMENT_TYPE = A.STATEMENT_TYPE
				    	AND STATEMENT_STATE = A.STATEMENT_STATE
				    	AND STATEMENT_DATE = A.STATEMENT_DATE
				    	AND AS_OF_DATE <= p_BILLING_STATEMENT.AS_OF_DATE);

	RETURN v_CHARGE_ID;

EXCEPTION
	WHEN OTHERS THEN
		RETURN g_NOT_ASSIGNED;
END GET_PRIOR_PERIOD_CHARGE_ID;
---------------------------------------------------------------------------------------------------
FUNCTION GET_PRIOR_PERIOD_CHARGE_ID
	(
	p_CHARGE_ID IN NUMBER
	) RETURN NUMBER IS

-- Answer the CHARGE_ID associated with a prior statement type.

v_BILLING_STATEMENT BILLING_STATEMENT%ROWTYPE;

BEGIN

	SELECT * INTO v_BILLING_STATEMENT FROM BILLING_STATEMENT WHERE CHARGE_ID = p_CHARGE_ID;

	RETURN GET_PRIOR_PERIOD_CHARGE_ID(v_BILLING_STATEMENT);

EXCEPTION
	WHEN OTHERS THEN
		RETURN g_NOT_ASSIGNED;
END GET_PRIOR_PERIOD_CHARGE_ID;
---------------------------------------------------------------------------------------------------
FUNCTION GET_PRIOR_PERIOD_QUANTITY
	(
	p_BILLING_STATEMENT IN BILLING_STATEMENT%ROWTYPE
	) RETURN NUMBER IS

-- Answer the Prior Period Quantity associated with a prior period statement.

v_PRIOR_PERIOD_CHARGE_ID NUMBER;
v_PRIOR_PERIOD_QUANTITY NUMBER;

BEGIN

	v_PRIOR_PERIOD_CHARGE_ID := GET_PRIOR_PERIOD_CHARGE_ID(p_BILLING_STATEMENT);

	SELECT PRIOR_PERIOD_QUANTITY
	INTO v_PRIOR_PERIOD_QUANTITY
	FROM BILLING_STATEMENT
	WHERE CHARGE_ID = v_PRIOR_PERIOD_CHARGE_ID;

	RETURN v_PRIOR_PERIOD_QUANTITY;

EXCEPTION
	WHEN OTHERS THEN
		RETURN g_NOT_ASSIGNED;
END GET_PRIOR_PERIOD_QUANTITY;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_CHARGE_ID
	(
	p_BILLING_STATEMENT IN OUT BILLING_STATEMENT%ROWTYPE
	) AS

BEGIN

	SELECT CHARGE_ID
	INTO p_BILLING_STATEMENT.CHARGE_ID
	FROM BILLING_STATEMENT
	WHERE ENTITY_ID = p_BILLING_STATEMENT.ENTITY_ID
		AND PRODUCT_ID = p_BILLING_STATEMENT.PRODUCT_ID
		AND COMPONENT_ID = p_BILLING_STATEMENT.COMPONENT_ID
		AND STATEMENT_TYPE = p_BILLING_STATEMENT.STATEMENT_TYPE
		AND STATEMENT_STATE = p_BILLING_STATEMENT.STATEMENT_STATE
		AND STATEMENT_DATE = p_BILLING_STATEMENT.STATEMENT_DATE
		AND AS_OF_DATE = p_BILLING_STATEMENT.AS_OF_DATE;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		SELECT BID.NEXTVAL INTO p_BILLING_STATEMENT.CHARGE_ID FROM DUAL;
END GET_CHARGE_ID;
---------------------------------------------------------------------------------------------------
FUNCTION GET_PRIOR_PERIOD_IMBALANCE
	(
	p_CHARGE_ID IN NUMBER,
	p_CHARGE_DATE IN DATE
	) RETURN NUMBER IS

-- Answer the Prior Period Imbalance Quantity associated with Imbalance Band 1.

v_PRIOR_PERIOD_IMBALANCE NUMBER;
v_PRIOR_PERIOD_CHARGE_ID NUMBER;
v_PRIOR_PERIOD_SIGN      NUMBER;

BEGIN
	v_PRIOR_PERIOD_CHARGE_ID := GET_PRIOR_PERIOD_CHARGE_ID(p_CHARGE_ID);

	SELECT A.ENERGY_IMBALANCE_QUANTITY, B.SUPPLY-B.DEMAND
	INTO v_PRIOR_PERIOD_IMBALANCE, v_PRIOR_PERIOD_SIGN
	FROM IMBALANCE_CHARGE_BAND A,
	     IMBALANCE_CHARGE B
	WHERE A.CHARGE_ID = v_PRIOR_PERIOD_CHARGE_ID
		AND A.CHARGE_DATE = TRUNC(TRUNC(p_CHARGE_DATE,'MONTH') - 1,'MONTH')
		AND A.BAND_NUMBER = 1
        AND B.CHARGE_ID = A.CHARGE_ID
        AND B.CHARGE_DATE = A.CHARGE_DATE;

    IF  v_PRIOR_PERIOD_SIGN < 0 THEN
	    RETURN (v_PRIOR_PERIOD_IMBALANCE * -1);
    ELSE
	    RETURN v_PRIOR_PERIOD_IMBALANCE;
    END IF;

EXCEPTION
	WHEN OTHERS THEN
		RETURN g_NOT_ASSIGNED;
END GET_PRIOR_PERIOD_IMBALANCE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_BILLING_STATEMENT_CHARGES
	(
	p_BILLING_STATEMENT IN OUT BILLING_STATEMENT%ROWTYPE,
	p_WRITE_BILLING_STATEMENT OUT BOOLEAN
	) AS

v_ITEMS NUMBER(6);
v_QUANTITY NUMBER;
v_AMOUNT NUMBER;
v_RATE NUMBER := g_NOT_ASSIGNED;

BEGIN

	IF p_BILLING_STATEMENT.CHARGE_VIEW_TYPE IN ('BILLING CHARGE','COINCIDENT PEAK') THEN
		SELECT COUNT(1), SUM(CHARGE_QUANTITY), SUM(CHARGE_AMOUNT), AVG(CHARGE_RATE)
		INTO v_ITEMS, v_QUANTITY, v_AMOUNT, v_RATE
		FROM BILLING_CHARGE
		WHERE CHARGE_ID = p_BILLING_STATEMENT.CHARGE_ID;
	ELSIF SUBSTR(p_BILLING_STATEMENT.CHARGE_VIEW_TYPE,1,9) = 'IMBALANCE' THEN
		SELECT COUNT(1), SUM(NET_SYSTEM_IMBALANCE), SUM(ENERGY_IMBALANCE_AMOUNT)
		INTO v_ITEMS, v_QUANTITY, v_AMOUNT
		FROM IMBALANCE_CHARGE
		WHERE CHARGE_ID = p_BILLING_STATEMENT.CHARGE_ID;
	ELSIF p_BILLING_STATEMENT.CHARGE_VIEW_TYPE = 'TRANSMISSION' THEN
		SELECT COUNT(1), SUM(CAPACITY_RESERVED), SUM(CHARGE_AMOUNT), AVG(CHARGE_RATE)
		INTO v_ITEMS, v_QUANTITY, v_AMOUNT, v_RATE
		FROM TRANSMISSION_CHARGE
		WHERE CHARGE_ID = p_BILLING_STATEMENT.CHARGE_ID;
	ELSIF p_BILLING_STATEMENT.CHARGE_VIEW_TYPE = 'ENTITY ATTRIBUTE' THEN
		SELECT COUNT(1), SUM(CHARGE_QUANTITY), SUM(CHARGE_AMOUNT), AVG(CHARGE_RATE)
		INTO v_ITEMS, v_QUANTITY, v_AMOUNT, v_RATE
		FROM ENTITY_ATTRIBUTE_CHARGE
		WHERE CHARGE_ID = p_BILLING_STATEMENT.CHARGE_ID;
	ELSIF p_BILLING_STATEMENT.CHARGE_VIEW_TYPE = 'ACCOUNT SERVICE' THEN
		SELECT COUNT(1), SUM(CHARGE_QUANTITY), SUM(CHARGE_AMOUNT), AVG(CHARGE_RATE)
		INTO v_ITEMS, v_QUANTITY, v_AMOUNT, v_RATE
		FROM ACCOUNT_SERVICE_CHARGE
		WHERE CHARGE_ID = p_BILLING_STATEMENT.CHARGE_ID;
	ELSIF p_BILLING_STATEMENT.CHARGE_VIEW_TYPE = 'OP PROFIT' THEN
		SELECT COUNT(1), SUM(ACTUAL_QUANTITY), SUM(CHARGE_AMOUNT), AVG(CHARGE_RATE)
		INTO v_ITEMS, v_QUANTITY, v_AMOUNT, v_RATE
		FROM OPER_PROFIT_CHARGE
		WHERE CHARGE_ID = p_BILLING_STATEMENT.CHARGE_ID;
	ELSIF p_BILLING_STATEMENT.CHARGE_VIEW_TYPE = 'CONVERSION' THEN
		SELECT COUNT(1), SUM(CHARGE_QUANTITY), SUM(CHARGE_AMOUNT), AVG(CHARGE_RATE)
		INTO v_ITEMS, v_QUANTITY, v_AMOUNT, v_RATE
		FROM CONVERSION_CHARGE
		WHERE CHARGE_ID = p_BILLING_STATEMENT.CHARGE_ID;
	ELSIF p_BILLING_STATEMENT.CHARGE_VIEW_TYPE = 'FORMULA' THEN
		SELECT COUNT(1), SUM(CHARGE_QUANTITY), SUM(CHARGE_AMOUNT), AVG(CHARGE_RATE)
		INTO v_ITEMS, v_QUANTITY, v_AMOUNT, v_RATE
		FROM FORMULA_CHARGE
		WHERE CHARGE_ID = p_BILLING_STATEMENT.CHARGE_ID;
	ELSIF SUBSTR(p_BILLING_STATEMENT.CHARGE_VIEW_TYPE,1,3) = 'LMP' THEN
		SELECT COUNT(1), SUM(CHARGE_QUANTITY), SUM(CHARGE_AMOUNT), AVG(CHARGE_RATE)
		INTO v_ITEMS, v_QUANTITY, v_AMOUNT, v_RATE
		FROM LMP_CHARGE
		WHERE CHARGE_ID = p_BILLING_STATEMENT.CHARGE_ID;
	ELSIF SUBSTR(p_BILLING_STATEMENT.CHARGE_VIEW_TYPE,1,3) = 'FTR' THEN
		SELECT COUNT(1), SUM(CHARGE_QUANTITY), SUM(CHARGE_AMOUNT), AVG(CHARGE_RATE)
		INTO v_ITEMS, v_QUANTITY, v_AMOUNT, v_RATE
		FROM FTR_CHARGE
		WHERE CHARGE_ID = p_BILLING_STATEMENT.CHARGE_ID;
	ELSIF p_BILLING_STATEMENT.CHARGE_VIEW_TYPE = 'COMBINATION' THEN
		SELECT COUNT(1), SUM(CHARGE_QUANTITY), SUM(CHARGE_AMOUNT), AVG(CHARGE_RATE)
		INTO v_ITEMS, v_QUANTITY, v_AMOUNT, v_RATE
		FROM COMBINATION_CHARGE
		WHERE CHARGE_ID = p_BILLING_STATEMENT.CHARGE_ID;
	ELSIF p_BILLING_STATEMENT.CHARGE_VIEW_TYPE = 'TAX CHARGE' THEN
		SELECT COUNT(1), SUM(CHARGE_QUANTITY), SUM(CHARGE_AMOUNT), AVG(CHARGE_RATE)
		INTO v_ITEMS, v_QUANTITY, v_AMOUNT, v_RATE
		FROM TAX_CHARGE
		WHERE CHARGE_ID = p_BILLING_STATEMENT.CHARGE_ID;
	ELSIF p_BILLING_STATEMENT.CHARGE_VIEW_TYPE = 'TAX CHARGE' THEN
		SELECT COUNT(1), SUM(CHARGE_QUANTITY), SUM(CHARGE_AMOUNT), AVG(CHARGE_RATE)
		INTO v_ITEMS, v_QUANTITY, v_AMOUNT, v_RATE
		FROM TAX_CHARGE
		WHERE CHARGE_ID = p_BILLING_STATEMENT.CHARGE_ID;
	ELSIF p_BILLING_STATEMENT.CHARGE_VIEW_TYPE = 'PIPELINE' THEN
		SELECT COUNT(1), SUM(CHARGE_QUANTITY), SUM(CHARGE_AMOUNT), AVG(CHARGE_RATE)
		INTO v_ITEMS, v_QUANTITY, v_AMOUNT, v_RATE
		FROM PIPELINE_CHARGE
		WHERE CHARGE_ID = p_BILLING_STATEMENT.CHARGE_ID;
	ELSE /*IF p_BILLING_STATEMENT.CHARGE_VIEW_TYPE = 'EXTERNAL' THEN*/
		XS.GET_COMPONENT_CHARGES(p_BILLING_STATEMENT, p_WRITE_BILLING_STATEMENT);
		RETURN;
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('GET_BILLING_STATEMENT_CHARGES CHARGE_VIEW_TYPE=' || p_BILLING_STATEMENT.CHARGE_VIEW_TYPE || ', ITEMS=' || TO_CHAR(v_ITEMS) || ', QUANTITY=' || TO_CHAR(v_QUANTITY) || ', AMOUNT=' || TO_CHAR(v_AMOUNT) || ', RATE=' || TO_CHAR(v_RATE));
	END IF;

	IF v_ITEMS > 0 THEN
		p_WRITE_BILLING_STATEMENT := TRUE;
		p_BILLING_STATEMENT.CHARGE_QUANTITY := v_QUANTITY;
		p_BILLING_STATEMENT.CHARGE_AMOUNT := v_AMOUNT;
		--p_BILLING_STATEMENT.CHARGE_RATE := v_RATE;
		IF v_QUANTITY = 0 THEN
			p_BILLING_STATEMENT.CHARGE_RATE := v_RATE;
		ELSE
			p_BILLING_STATEMENT.CHARGE_RATE := v_AMOUNT / v_QUANTITY;
		END IF;
	ELSE
		p_WRITE_BILLING_STATEMENT := FALSE;
	END IF;

END GET_BILLING_STATEMENT_CHARGES;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_BILLING_STATEMENT_STATUS
	(
	p_BILLING_STATEMENT IN OUT BILLING_STATEMENT%ROWTYPE,
	p_STATUS IN VARCHAR2
	) AS
v_ENTRY_DATE DATE := SYSDATE;
BEGIN
    UPDATE BILLING_STATEMENT_STATUS SET
		REVIEW_STATUS = p_STATUS,
		ENTRY_DATE = v_ENTRY_DATE
	WHERE ENTITY_ID = p_BILLING_STATEMENT.ENTITY_ID
		AND STATEMENT_TYPE = p_BILLING_STATEMENT.STATEMENT_TYPE
		AND STATEMENT_STATE = p_BILLING_STATEMENT.STATEMENT_STATE
		AND STATEMENT_DATE = p_BILLING_STATEMENT.STATEMENT_DATE
		AND AS_OF_DATE = p_BILLING_STATEMENT.AS_OF_DATE;

	IF SQL%NOTFOUND THEN
		INSERT INTO BILLING_STATEMENT_STATUS (
			ENTITY_ID,
			STATEMENT_TYPE,
			STATEMENT_STATE,
			STATEMENT_DATE,
			AS_OF_DATE,
            REVIEW_STATUS,
			ENTRY_DATE)
		VALUES (
			p_BILLING_STATEMENT.ENTITY_ID,
			p_BILLING_STATEMENT.STATEMENT_TYPE,
			p_BILLING_STATEMENT.STATEMENT_STATE,
			p_BILLING_STATEMENT.STATEMENT_DATE,
			p_BILLING_STATEMENT.AS_OF_DATE,
            p_STATUS,
			v_ENTRY_DATE);
	END IF;
END PUT_BILLING_STATEMENT_STATUS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_BILLING_STATEMENT
	(
	p_BILLING_STATEMENT IN OUT BILLING_STATEMENT%ROWTYPE
	) AS
v_ENTRY_DATE DATE := SYSDATE;
BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PUT_BILLING_STATEMENT: ' ||
			TO_CHAR(p_BILLING_STATEMENT.ENTITY_ID) || ',' ||
			TO_CHAR(p_BILLING_STATEMENT.PRODUCT_ID) || ',' ||
			TO_CHAR(p_BILLING_STATEMENT.COMPONENT_ID) || ',' ||
			TO_CHAR(p_BILLING_STATEMENT.STATEMENT_TYPE) || ',' ||
			TO_CHAR(p_BILLING_STATEMENT.STATEMENT_STATE) || ',' ||
		    TEXT_UTIL.TO_CHAR_DATE(p_BILLING_STATEMENT.STATEMENT_DATE) || ',' ||
		    TEXT_UTIL.TO_CHAR_TIME(p_BILLING_STATEMENT.AS_OF_DATE) || ',' ||
		    TEXT_UTIL.TO_CHAR_DATE(p_BILLING_STATEMENT.STATEMENT_END_DATE) || ',' ||
		    TEXT_UTIL.TO_CHAR_TIME(p_BILLING_STATEMENT.BASIS_AS_OF_DATE) || ',' ||
			p_BILLING_STATEMENT.CHARGE_INTERVAL || ',' ||
			p_BILLING_STATEMENT.CHARGE_VIEW_TYPE || ',' ||
			p_BILLING_STATEMENT.ENTITY_TYPE || ',' ||
			TO_CHAR(p_BILLING_STATEMENT.CHARGE_QUANTITY) || ',' ||
			TO_CHAR(p_BILLING_STATEMENT.CHARGE_RATE) || ',' ||
			TO_CHAR(p_BILLING_STATEMENT.CHARGE_AMOUNT) || ',' ||
			TO_CHAR(p_BILLING_STATEMENT.BILL_QUANTITY) || ',' ||
			TO_CHAR(p_BILLING_STATEMENT.BILL_AMOUNT) || ',' ||
			TO_CHAR(p_BILLING_STATEMENT.PRIOR_PERIOD_QUANTITY));
	END IF;

	p_BILLING_STATEMENT.ENTRY_DATE := v_ENTRY_DATE;

    UPDATE BILLING_STATEMENT SET
		ROW = p_BILLING_STATEMENT
	WHERE ENTITY_ID = p_BILLING_STATEMENT.ENTITY_ID
		AND PRODUCT_ID = p_BILLING_STATEMENT.PRODUCT_ID
		AND COMPONENT_ID = p_BILLING_STATEMENT.COMPONENT_ID
		AND STATEMENT_TYPE = p_BILLING_STATEMENT.STATEMENT_TYPE
		AND STATEMENT_STATE = p_BILLING_STATEMENT.STATEMENT_STATE
		AND STATEMENT_DATE = p_BILLING_STATEMENT.STATEMENT_DATE
		AND AS_OF_DATE = p_BILLING_STATEMENT.AS_OF_DATE;

	IF SQL%NOTFOUND THEN
		INSERT INTO BILLING_STATEMENT VALUES p_BILLING_STATEMENT;
	END IF;

    -- also update BILLING_STATEMENT_STATUS
	PUT_BILLING_STATEMENT_STATUS(p_BILLING_STATEMENT, g_STATUS_PENDING);

END PUT_BILLING_STATEMENT;
---------------------------------------------------------------------------------------------------
PROCEDURE PRIOR_BILLING_STATEMENT
	(
	p_PRIOR_CHARGE_ID IN NUMBER,
	p_BILLING_STATEMENT IN OUT BILLING_STATEMENT%ROWTYPE
	) AS

BEGIN

	IF GA.APPLY_PRIOR_BILL_CHARGES AND NOT p_PRIOR_CHARGE_ID = g_NOT_ASSIGNED THEN
		SELECT CHARGE_QUANTITY, CHARGE_AMOUNT
		INTO p_BILLING_STATEMENT.BILL_QUANTITY, p_BILLING_STATEMENT.BILL_AMOUNT
	    	FROM BILLING_STATEMENT
		WHERE CHARGE_ID = p_PRIOR_CHARGE_ID
			AND STATEMENT_STATE = GA.INTERNAL_STATE;
		p_BILLING_STATEMENT.BILL_QUANTITY := p_BILLING_STATEMENT.CHARGE_QUANTITY - p_BILLING_STATEMENT.BILL_QUANTITY;
		p_BILLING_STATEMENT.BILL_AMOUNT := p_BILLING_STATEMENT.CHARGE_AMOUNT - p_BILLING_STATEMENT.BILL_AMOUNT;
	ELSE
		p_BILLING_STATEMENT.BILL_QUANTITY := p_BILLING_STATEMENT.CHARGE_QUANTITY;
		p_BILLING_STATEMENT.BILL_AMOUNT := p_BILLING_STATEMENT.CHARGE_AMOUNT;
	END IF;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		p_BILLING_STATEMENT.BILL_QUANTITY := p_BILLING_STATEMENT.CHARGE_QUANTITY;
		p_BILLING_STATEMENT.BILL_AMOUNT := p_BILLING_STATEMENT.CHARGE_AMOUNT;

END PRIOR_BILLING_STATEMENT;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_IMBALANCE_CHARGE
	(
	p_IMBALANCE_CHARGE IN IMBALANCE_CHARGE%ROWTYPE
	) AS

BEGIN

	UPDATE IMBALANCE_CHARGE SET
		ROW = p_IMBALANCE_CHARGE
	WHERE CHARGE_ID = p_IMBALANCE_CHARGE.CHARGE_ID
		AND CHARGE_DATE = p_IMBALANCE_CHARGE.CHARGE_DATE;

	IF SQL%NOTFOUND THEN
	    INSERT INTO IMBALANCE_CHARGE VALUES p_IMBALANCE_CHARGE;
	END IF;

END PUT_IMBALANCE_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PRIOR_IMBALANCE_CHARGE
	(
	p_PRIOR_CHARGE_ID IN NUMBER,
	p_IMBALANCE_CHARGE IN OUT IMBALANCE_CHARGE%ROWTYPE
	) AS

BEGIN

	IF GA.APPLY_PRIOR_BILL_CHARGES AND NOT p_PRIOR_CHARGE_ID = g_NOT_ASSIGNED THEN
		SELECT NET_SYSTEM_IMBALANCE, ENERGY_IMBALANCE_AMOUNT
		INTO p_IMBALANCE_CHARGE.BILL_NET_SYSTEM_IMBALANCE, p_IMBALANCE_CHARGE.BILL_ENERGY_IMBALANCE_AMOUNT
		FROM IMBALANCE_CHARGE
		WHERE CHARGE_ID = p_PRIOR_CHARGE_ID
		    	AND CHARGE_DATE = p_IMBALANCE_CHARGE.CHARGE_DATE;
		p_IMBALANCE_CHARGE.BILL_NET_SYSTEM_IMBALANCE := p_IMBALANCE_CHARGE.NET_SYSTEM_IMBALANCE - p_IMBALANCE_CHARGE.BILL_NET_SYSTEM_IMBALANCE;
		p_IMBALANCE_CHARGE.BILL_ENERGY_IMBALANCE_AMOUNT := p_IMBALANCE_CHARGE.ENERGY_IMBALANCE_AMOUNT - p_IMBALANCE_CHARGE.BILL_ENERGY_IMBALANCE_AMOUNT;
	ELSE
		p_IMBALANCE_CHARGE.BILL_NET_SYSTEM_IMBALANCE := p_IMBALANCE_CHARGE.NET_SYSTEM_IMBALANCE;
		p_IMBALANCE_CHARGE.BILL_ENERGY_IMBALANCE_AMOUNT := p_IMBALANCE_CHARGE.ENERGY_IMBALANCE_AMOUNT;
	END IF;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		p_IMBALANCE_CHARGE.BILL_NET_SYSTEM_IMBALANCE := p_IMBALANCE_CHARGE.NET_SYSTEM_IMBALANCE;
		p_IMBALANCE_CHARGE.BILL_ENERGY_IMBALANCE_AMOUNT := p_IMBALANCE_CHARGE.ENERGY_IMBALANCE_AMOUNT;

END PRIOR_IMBALANCE_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_IMBALANCE_CHARGE_BAND
	(
	p_IMBALANCE_CHARGE_BAND IN IMBALANCE_CHARGE_BAND%ROWTYPE
	) AS

BEGIN

    UPDATE IMBALANCE_CHARGE_BAND SET
		ROW = p_IMBALANCE_CHARGE_BAND
	WHERE CHARGE_ID = p_IMBALANCE_CHARGE_BAND.CHARGE_ID
	    AND CHARGE_DATE = p_IMBALANCE_CHARGE_BAND.CHARGE_DATE
	    AND BAND_NUMBER = p_IMBALANCE_CHARGE_BAND.BAND_NUMBER;

	IF SQL%NOTFOUND THEN
	    INSERT INTO IMBALANCE_CHARGE_BAND VALUES p_IMBALANCE_CHARGE_BAND;
	END IF;

END PUT_IMBALANCE_CHARGE_BAND;
---------------------------------------------------------------------------------------------------
PROCEDURE PRIOR_IMBALANCE_CHARGE_BAND
	(
	p_PRIOR_CHARGE_ID IN NUMBER,
	p_IMBALANCE_CHARGE_BAND IN OUT IMBALANCE_CHARGE_BAND%ROWTYPE
	) AS

BEGIN

	IF GA.APPLY_PRIOR_BILL_CHARGES AND NOT p_PRIOR_CHARGE_ID = g_NOT_ASSIGNED THEN
		SELECT ENERGY_IMBALANCE_QUANTITY, ENERGY_IMBALANCE_AMOUNT
		INTO p_IMBALANCE_CHARGE_BAND.BILL_ENERGY_IMBALANCE_QUANTITY, p_IMBALANCE_CHARGE_BAND.BILL_ENERGY_IMBALANCE_AMOUNT
		FROM IMBALANCE_CHARGE_BAND
		WHERE CHARGE_ID = p_PRIOR_CHARGE_ID
		    	AND CHARGE_DATE = p_IMBALANCE_CHARGE_BAND.CHARGE_DATE
		    	AND BAND_NUMBER = p_IMBALANCE_CHARGE_BAND.BAND_NUMBER;
		p_IMBALANCE_CHARGE_BAND.BILL_ENERGY_IMBALANCE_QUANTITY := p_IMBALANCE_CHARGE_BAND.ENERGY_IMBALANCE_QUANTITY - p_IMBALANCE_CHARGE_BAND.BILL_ENERGY_IMBALANCE_QUANTITY;
		p_IMBALANCE_CHARGE_BAND.BILL_ENERGY_IMBALANCE_AMOUNT := p_IMBALANCE_CHARGE_BAND.ENERGY_IMBALANCE_AMOUNT - p_IMBALANCE_CHARGE_BAND.BILL_ENERGY_IMBALANCE_AMOUNT;
	ELSE
		p_IMBALANCE_CHARGE_BAND.BILL_ENERGY_IMBALANCE_QUANTITY := p_IMBALANCE_CHARGE_BAND.ENERGY_IMBALANCE_QUANTITY;
		p_IMBALANCE_CHARGE_BAND.BILL_ENERGY_IMBALANCE_AMOUNT := p_IMBALANCE_CHARGE_BAND.ENERGY_IMBALANCE_AMOUNT;
	END IF;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		p_IMBALANCE_CHARGE_BAND.BILL_ENERGY_IMBALANCE_QUANTITY := p_IMBALANCE_CHARGE_BAND.ENERGY_IMBALANCE_QUANTITY;
		p_IMBALANCE_CHARGE_BAND.BILL_ENERGY_IMBALANCE_AMOUNT := p_IMBALANCE_CHARGE_BAND.ENERGY_IMBALANCE_AMOUNT;

END PRIOR_IMBALANCE_CHARGE_BAND;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_TRANSMISSION_CHARGE
	(
	p_TRANSMISSION_CHARGE IN TRANSMISSION_CHARGE%ROWTYPE
	) AS

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG(TO_CHAR(p_TRANSMISSION_CHARGE.CHARGE_ID) || ',' ||
		    TEXT_UTIL.TO_CHAR_TIME(p_TRANSMISSION_CHARGE.CHARGE_DATE) || ',' ||
			TO_CHAR(p_TRANSMISSION_CHARGE.TRANSACTION_ID) || ',' ||
			p_TRANSMISSION_CHARGE.TRANSACTION_NAME || ',' ||
			p_TRANSMISSION_CHARGE.CHARGE_INTERVAL || ',' ||
			TO_CHAR(p_TRANSMISSION_CHARGE.CAPACITY_RESERVED) || ',' ||
			TO_CHAR(p_TRANSMISSION_CHARGE.CHARGE_RATE) || ',' ||
			TO_CHAR(p_TRANSMISSION_CHARGE.CHARGE_FACTOR) || ',' ||
			TO_CHAR(p_TRANSMISSION_CHARGE.CHARGE_AMOUNT) || ',' ||
			TO_CHAR(p_TRANSMISSION_CHARGE.BILL_CAPACITY_RESERVED) || ',' ||
			TO_CHAR(p_TRANSMISSION_CHARGE.BILL_AMOUNT));
	END IF;

    UPDATE TRANSMISSION_CHARGE SET
		ROW = p_TRANSMISSION_CHARGE
	WHERE CHARGE_ID = p_TRANSMISSION_CHARGE.CHARGE_ID
	    AND CHARGE_DATE = p_TRANSMISSION_CHARGE.CHARGE_DATE
	    AND TRANSACTION_ID = p_TRANSMISSION_CHARGE.TRANSACTION_ID;

	IF SQL%NOTFOUND THEN
	    INSERT INTO TRANSMISSION_CHARGE VALUES p_TRANSMISSION_CHARGE;
	END IF;

END PUT_TRANSMISSION_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PRIOR_TRANSMISSION_CHARGE
	(
	p_PRIOR_CHARGE_ID IN NUMBER,
	p_TRANSMISSION_CHARGE IN OUT TRANSMISSION_CHARGE%ROWTYPE
	) AS

BEGIN

	IF GA.APPLY_PRIOR_BILL_CHARGES AND NOT p_PRIOR_CHARGE_ID = g_NOT_ASSIGNED THEN
		SELECT CAPACITY_RESERVED, CHARGE_AMOUNT
		INTO p_TRANSMISSION_CHARGE.BILL_CAPACITY_RESERVED, p_TRANSMISSION_CHARGE.BILL_AMOUNT
		FROM TRANSMISSION_CHARGE
		WHERE CHARGE_ID = p_PRIOR_CHARGE_ID
		    	AND CHARGE_DATE = p_TRANSMISSION_CHARGE.CHARGE_DATE
		    	AND TRANSACTION_ID = p_TRANSMISSION_CHARGE.TRANSACTION_ID;
		p_TRANSMISSION_CHARGE.BILL_CAPACITY_RESERVED := p_TRANSMISSION_CHARGE.CAPACITY_RESERVED - p_TRANSMISSION_CHARGE.BILL_CAPACITY_RESERVED;
		p_TRANSMISSION_CHARGE.BILL_AMOUNT := p_TRANSMISSION_CHARGE.CHARGE_AMOUNT - p_TRANSMISSION_CHARGE.BILL_AMOUNT;
	ELSE
		p_TRANSMISSION_CHARGE.BILL_CAPACITY_RESERVED := p_TRANSMISSION_CHARGE.CAPACITY_RESERVED;
		p_TRANSMISSION_CHARGE.BILL_AMOUNT := p_TRANSMISSION_CHARGE.CHARGE_AMOUNT;
	END IF;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		p_TRANSMISSION_CHARGE.BILL_CAPACITY_RESERVED := p_TRANSMISSION_CHARGE.CAPACITY_RESERVED;
		p_TRANSMISSION_CHARGE.BILL_AMOUNT := p_TRANSMISSION_CHARGE.CHARGE_AMOUNT;

END PRIOR_TRANSMISSION_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_ENTITY_ATTRIBUTE_CHARGE
	(
	p_ENTITY_ATTRIBUTE_CHARGE IN ENTITY_ATTRIBUTE_CHARGE%ROWTYPE
	) AS

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG(TO_CHAR(p_ENTITY_ATTRIBUTE_CHARGE.CHARGE_ID) || ',' ||
		    TO_CHAR(p_ENTITY_ATTRIBUTE_CHARGE.ENTITY_DOMAIN_ID) || ',' ||
		    TO_CHAR(p_ENTITY_ATTRIBUTE_CHARGE.ENTITY_ID) || ',' ||
		    TO_CHAR(p_ENTITY_ATTRIBUTE_CHARGE.ATTRIBUTE_ID) || ',' ||
		    TEXT_UTIL.TO_CHAR_TIME(p_ENTITY_ATTRIBUTE_CHARGE.CHARGE_DATE) || ',' ||
		    TEXT_UTIL.TO_CHAR_TIME(p_ENTITY_ATTRIBUTE_CHARGE.PEAK_DATE) || ',' ||
		    TO_CHAR(p_ENTITY_ATTRIBUTE_CHARGE.PEAK_QUANTITY) || ',' ||
		    TO_CHAR(p_ENTITY_ATTRIBUTE_CHARGE.CHARGE_QUANTITY) || ',' ||
		    TO_CHAR(p_ENTITY_ATTRIBUTE_CHARGE.CHARGE_RATE) || ',' ||
		    TO_CHAR(p_ENTITY_ATTRIBUTE_CHARGE.CHARGE_FACTOR) || ',' ||
		    TO_CHAR(p_ENTITY_ATTRIBUTE_CHARGE.CHARGE_AMOUNT) || ',' ||
		    TO_CHAR(p_ENTITY_ATTRIBUTE_CHARGE.BILL_QUANTITY) || ',' ||
		    TO_CHAR(p_ENTITY_ATTRIBUTE_CHARGE.BILL_AMOUNT));
	END IF;

    UPDATE ENTITY_ATTRIBUTE_CHARGE SET
		ROW = p_ENTITY_ATTRIBUTE_CHARGE
	WHERE CHARGE_ID = p_ENTITY_ATTRIBUTE_CHARGE.CHARGE_ID
	    AND ENTITY_DOMAIN_ID = p_ENTITY_ATTRIBUTE_CHARGE.ENTITY_DOMAIN_ID
	    AND ENTITY_ID = p_ENTITY_ATTRIBUTE_CHARGE.ENTITY_ID
	    AND ATTRIBUTE_ID = p_ENTITY_ATTRIBUTE_CHARGE.ATTRIBUTE_ID
	    AND CHARGE_DATE = p_ENTITY_ATTRIBUTE_CHARGE.CHARGE_DATE;

	IF SQL%NOTFOUND THEN
	    INSERT INTO ENTITY_ATTRIBUTE_CHARGE VALUES p_ENTITY_ATTRIBUTE_CHARGE;
	END IF;

END PUT_ENTITY_ATTRIBUTE_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PRIOR_ENTITY_ATTRIBUTE_CHARGE
	(
	p_PRIOR_CHARGE_ID IN NUMBER,
	p_ENTITY_ATTRIBUTE_CHARGE IN OUT ENTITY_ATTRIBUTE_CHARGE%ROWTYPE
	) AS

BEGIN

	IF GA.APPLY_PRIOR_BILL_CHARGES AND NOT p_PRIOR_CHARGE_ID = g_NOT_ASSIGNED THEN
		SELECT CHARGE_QUANTITY, CHARGE_AMOUNT
		INTO p_ENTITY_ATTRIBUTE_CHARGE.BILL_QUANTITY, p_ENTITY_ATTRIBUTE_CHARGE.BILL_AMOUNT
		FROM ENTITY_ATTRIBUTE_CHARGE
		WHERE CHARGE_ID = p_PRIOR_CHARGE_ID
			AND ENTITY_DOMAIN_ID = p_ENTITY_ATTRIBUTE_CHARGE.ENTITY_DOMAIN_ID
			AND ENTITY_ID = p_ENTITY_ATTRIBUTE_CHARGE.ENTITY_ID
			AND ATTRIBUTE_ID = p_ENTITY_ATTRIBUTE_CHARGE.ATTRIBUTE_ID
			AND CHARGE_DATE = p_ENTITY_ATTRIBUTE_CHARGE.CHARGE_DATE;
		p_ENTITY_ATTRIBUTE_CHARGE.BILL_QUANTITY := p_ENTITY_ATTRIBUTE_CHARGE.CHARGE_QUANTITY - p_ENTITY_ATTRIBUTE_CHARGE.BILL_QUANTITY;
		p_ENTITY_ATTRIBUTE_CHARGE.BILL_AMOUNT := p_ENTITY_ATTRIBUTE_CHARGE.CHARGE_AMOUNT - p_ENTITY_ATTRIBUTE_CHARGE.BILL_AMOUNT;
	ELSE
		p_ENTITY_ATTRIBUTE_CHARGE.BILL_QUANTITY := p_ENTITY_ATTRIBUTE_CHARGE.CHARGE_QUANTITY;
		p_ENTITY_ATTRIBUTE_CHARGE.BILL_AMOUNT := p_ENTITY_ATTRIBUTE_CHARGE.CHARGE_AMOUNT;
	END IF;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		p_ENTITY_ATTRIBUTE_CHARGE.BILL_QUANTITY := p_ENTITY_ATTRIBUTE_CHARGE.CHARGE_QUANTITY;
		p_ENTITY_ATTRIBUTE_CHARGE.BILL_AMOUNT := p_ENTITY_ATTRIBUTE_CHARGE.CHARGE_AMOUNT;

END PRIOR_ENTITY_ATTRIBUTE_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_BILLING_CHARGE
	(
	p_BILLING_CHARGE IN BILLING_CHARGE%ROWTYPE
	) AS

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PUT_BILLING_CHARGE: ' ||
			TO_CHAR(p_BILLING_CHARGE.CHARGE_ID) || ',' ||
		    TEXT_UTIL.TO_CHAR_TIME(p_BILLING_CHARGE.CHARGE_DATE) || ',' ||
		    TEXT_UTIL.TO_CHAR_TIME(p_BILLING_CHARGE.PEAK_DATE) || ',' ||
		    TO_CHAR(p_BILLING_CHARGE.PEAK_QUANTITY) || ',' ||
		    TO_CHAR(p_BILLING_CHARGE.SERVICE_POINT_ID) || ',' ||
		    TO_CHAR(p_BILLING_CHARGE.CHARGE_QUANTITY) || ',' ||
		    TO_CHAR(p_BILLING_CHARGE.CHARGE_RATE) || ',' ||
		    TO_CHAR(p_BILLING_CHARGE.CHARGE_FACTOR) || ',' ||
		    TO_CHAR(p_BILLING_CHARGE.CHARGE_AMOUNT) || ',' ||
		    TO_CHAR(p_BILLING_CHARGE.BILL_QUANTITY) || ',' ||
		    TO_CHAR(p_BILLING_CHARGE.BILL_AMOUNT));
	END IF;

    UPDATE BILLING_CHARGE SET
		ROW = p_BILLING_CHARGE
	WHERE CHARGE_ID = p_BILLING_CHARGE.CHARGE_ID
	    AND CHARGE_DATE = p_BILLING_CHARGE.CHARGE_DATE;

	IF SQL%NOTFOUND THEN
	    INSERT INTO BILLING_CHARGE VALUES p_BILLING_CHARGE;
	END IF;

END PUT_BILLING_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PRIOR_BILLING_CHARGE
	(
	p_PRIOR_CHARGE_ID IN NUMBER,
	p_BILLING_CHARGE IN OUT BILLING_CHARGE%ROWTYPE
	) AS

BEGIN

	IF GA.APPLY_PRIOR_BILL_CHARGES AND NOT p_PRIOR_CHARGE_ID = g_NOT_ASSIGNED THEN
		SELECT CHARGE_QUANTITY, CHARGE_AMOUNT
		INTO p_BILLING_CHARGE.BILL_QUANTITY, p_BILLING_CHARGE.BILL_AMOUNT
		FROM BILLING_CHARGE
		WHERE CHARGE_ID = p_PRIOR_CHARGE_ID
		    	AND CHARGE_DATE = p_BILLING_CHARGE.CHARGE_DATE;
		p_BILLING_CHARGE.BILL_QUANTITY := p_BILLING_CHARGE.CHARGE_QUANTITY - p_BILLING_CHARGE.BILL_QUANTITY;
		p_BILLING_CHARGE.BILL_AMOUNT := p_BILLING_CHARGE.CHARGE_AMOUNT - p_BILLING_CHARGE.BILL_AMOUNT;
	ELSE
		p_BILLING_CHARGE.BILL_QUANTITY := p_BILLING_CHARGE.CHARGE_QUANTITY;
		p_BILLING_CHARGE.BILL_AMOUNT := p_BILLING_CHARGE.CHARGE_AMOUNT;
	END IF;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		p_BILLING_CHARGE.BILL_QUANTITY := p_BILLING_CHARGE.CHARGE_QUANTITY;
		p_BILLING_CHARGE.BILL_AMOUNT := p_BILLING_CHARGE.CHARGE_AMOUNT;

END PRIOR_BILLING_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_TAX_CHARGE
	(
	p_TAX_CHARGE IN TAX_CHARGE%ROWTYPE
	) AS

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PUT_TAX_CHARGE: ' ||
			TO_CHAR(p_TAX_CHARGE.CHARGE_ID) || ',' ||
		    TEXT_UTIL.TO_CHAR_TIME(p_TAX_CHARGE.CHARGE_DATE) || ',' ||
		    TO_CHAR(p_TAX_CHARGE.PRODUCT_ID) || ',' ||
		    TO_CHAR(p_TAX_CHARGE.COMPONENT_ID) || ',' ||
		    TO_CHAR(p_TAX_CHARGE.GEOGRAPHY_ID) || ',' ||
		    TO_CHAR(p_TAX_CHARGE.SERVICE_POINT_ID) || ',' ||
		    TO_CHAR(p_TAX_CHARGE.CHARGE_QUANTITY) || ',' ||
		    TO_CHAR(p_TAX_CHARGE.CHARGE_RATE) || ',' ||
		    TO_CHAR(p_TAX_CHARGE.CHARGE_FACTOR) || ',' ||
		    TO_CHAR(p_TAX_CHARGE.CHARGE_AMOUNT) || ',' ||
		    TO_CHAR(p_TAX_CHARGE.BILL_QUANTITY) || ',' ||
		    TO_CHAR(p_TAX_CHARGE.BILL_AMOUNT));
	END IF;

    UPDATE TAX_CHARGE SET
		ROW = p_TAX_CHARGE
	WHERE CHARGE_ID = p_TAX_CHARGE.CHARGE_ID
	    AND CHARGE_DATE = p_TAX_CHARGE.CHARGE_DATE
		AND PRODUCT_ID = p_TAX_CHARGE.PRODUCT_ID
		AND COMPONENT_ID = p_TAX_CHARGE.COMPONENT_ID
		AND GEOGRAPHY_ID = p_TAX_CHARGE.GEOGRAPHY_ID;

	IF SQL%NOTFOUND THEN
	    INSERT INTO TAX_CHARGE VALUES p_TAX_CHARGE;
	END IF;

END PUT_TAX_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PRIOR_TAX_CHARGE
	(
	p_PRIOR_CHARGE_ID IN NUMBER,
	p_TAX_CHARGE IN OUT TAX_CHARGE%ROWTYPE
	) AS

BEGIN

	IF GA.APPLY_PRIOR_BILL_CHARGES AND NOT p_PRIOR_CHARGE_ID = g_NOT_ASSIGNED THEN
		SELECT CHARGE_QUANTITY, CHARGE_AMOUNT
		INTO p_TAX_CHARGE.BILL_QUANTITY, p_TAX_CHARGE.BILL_AMOUNT
		FROM TAX_CHARGE
		WHERE CHARGE_ID = p_PRIOR_CHARGE_ID
		    	AND CHARGE_DATE = p_TAX_CHARGE.CHARGE_DATE
			AND PRODUCT_ID = p_TAX_CHARGE.PRODUCT_ID
			AND COMPONENT_ID = p_TAX_CHARGE.COMPONENT_ID
			AND GEOGRAPHY_ID = p_TAX_CHARGE.GEOGRAPHY_ID;
		p_TAX_CHARGE.BILL_QUANTITY := p_TAX_CHARGE.CHARGE_QUANTITY - p_TAX_CHARGE.BILL_QUANTITY;
		p_TAX_CHARGE.BILL_AMOUNT := p_TAX_CHARGE.CHARGE_AMOUNT - p_TAX_CHARGE.BILL_AMOUNT;
	ELSE
		p_TAX_CHARGE.BILL_QUANTITY := p_TAX_CHARGE.CHARGE_QUANTITY;
		p_TAX_CHARGE.BILL_AMOUNT := p_TAX_CHARGE.CHARGE_AMOUNT;
	END IF;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		p_TAX_CHARGE.BILL_QUANTITY := p_TAX_CHARGE.CHARGE_QUANTITY;
		p_TAX_CHARGE.BILL_AMOUNT := p_TAX_CHARGE.CHARGE_AMOUNT;

END PRIOR_TAX_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_OPER_PROFIT_CHARGE
	(
	p_OPER_PROFIT_CHARGE IN OPER_PROFIT_CHARGE%ROWTYPE
	) AS

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PUT_OPER_PROFIT_CHARGE: ' ||
			TO_CHAR(p_OPER_PROFIT_CHARGE.CHARGE_ID) || ',' ||
		    TEXT_UTIL.TO_CHAR_TIME(p_OPER_PROFIT_CHARGE.CHARGE_DATE) || ',' ||
		    TO_CHAR(p_OPER_PROFIT_CHARGE.SERVICE_POINT_ID) || ',' ||
		    TO_CHAR(p_OPER_PROFIT_CHARGE.MARKET_QUANTITY) || ',' ||
		    TO_CHAR(p_OPER_PROFIT_CHARGE.MARKET_OPER_PROFIT) || ',' ||
		    TO_CHAR(p_OPER_PROFIT_CHARGE.DISPATCH_QUANTITY) || ',' ||
		    TO_CHAR(p_OPER_PROFIT_CHARGE.DISPATCH_OPER_PROFIT) || ',' ||
		    TO_CHAR(p_OPER_PROFIT_CHARGE.ACTUAL_QUANTITY) || ',' ||
		    TO_CHAR(p_OPER_PROFIT_CHARGE.ACTUAL_OPER_PROFIT) || ',' ||
		    TO_CHAR(p_OPER_PROFIT_CHARGE.CHARGE_RATE) || ',' ||
		    TO_CHAR(p_OPER_PROFIT_CHARGE.CHARGE_FACTOR) || ',' ||
		    TO_CHAR(p_OPER_PROFIT_CHARGE.CHARGE_AMOUNT) || ',' ||
		    TO_CHAR(p_OPER_PROFIT_CHARGE.BILL_AMOUNT));
	END IF;

    UPDATE OPER_PROFIT_CHARGE SET
		ROW = p_OPER_PROFIT_CHARGE
	WHERE CHARGE_ID = p_OPER_PROFIT_CHARGE.CHARGE_ID
	    AND CHARGE_DATE = p_OPER_PROFIT_CHARGE.CHARGE_DATE;

	IF SQL%NOTFOUND THEN
	    INSERT INTO OPER_PROFIT_CHARGE VALUES p_OPER_PROFIT_CHARGE;
	END IF;

END PUT_OPER_PROFIT_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PRIOR_OPER_PROFIT_CHARGE
	(
	p_PRIOR_CHARGE_ID IN NUMBER,
	p_OPER_PROFIT_CHARGE IN OUT OPER_PROFIT_CHARGE%ROWTYPE
	) AS

BEGIN

	IF GA.APPLY_PRIOR_BILL_CHARGES AND NOT p_PRIOR_CHARGE_ID = g_NOT_ASSIGNED THEN
		SELECT CHARGE_AMOUNT
		INTO p_OPER_PROFIT_CHARGE.BILL_AMOUNT
		FROM OPER_PROFIT_CHARGE
		WHERE CHARGE_ID = p_PRIOR_CHARGE_ID
		    	AND CHARGE_DATE = p_OPER_PROFIT_CHARGE.CHARGE_DATE;
		p_OPER_PROFIT_CHARGE.BILL_AMOUNT := p_OPER_PROFIT_CHARGE.CHARGE_AMOUNT - p_OPER_PROFIT_CHARGE.BILL_AMOUNT;
	ELSE
		p_OPER_PROFIT_CHARGE.BILL_AMOUNT := p_OPER_PROFIT_CHARGE.CHARGE_AMOUNT;
	END IF;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		p_OPER_PROFIT_CHARGE.BILL_AMOUNT := p_OPER_PROFIT_CHARGE.CHARGE_AMOUNT;

END PRIOR_OPER_PROFIT_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_SERVICE_CHARGE
	(
	p_ACCOUNT_SERVICE_CHARGE IN ACCOUNT_SERVICE_CHARGE%ROWTYPE
	) AS

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG(TO_CHAR(p_ACCOUNT_SERVICE_CHARGE.CHARGE_ID) || ',' ||
		TO_CHAR(p_ACCOUNT_SERVICE_CHARGE.ACCOUNT_SERVICE_ID) || ',' ||
		TO_CHAR(p_ACCOUNT_SERVICE_CHARGE.BAND_NUMBER) || ',' ||
		p_ACCOUNT_SERVICE_CHARGE.BILL_CODE || ',' ||
		TEXT_UTIL.TO_CHAR_DATE(p_ACCOUNT_SERVICE_CHARGE.CHARGE_BEGIN_DATE) || ',' ||
		TEXT_UTIL.TO_CHAR_DATE(p_ACCOUNT_SERVICE_CHARGE.CHARGE_END_DATE) || ',' ||
		TO_CHAR(p_ACCOUNT_SERVICE_CHARGE.CHARGE_QUANTITY) || ',' ||
		TO_CHAR(p_ACCOUNT_SERVICE_CHARGE.CHARGE_RATE) || ',' ||
		TO_CHAR(p_ACCOUNT_SERVICE_CHARGE.CHARGE_FACTOR) || ',' ||
		TO_CHAR(p_ACCOUNT_SERVICE_CHARGE.CHARGE_AMOUNT) || ',' ||
		TO_CHAR(p_ACCOUNT_SERVICE_CHARGE.BILL_QUANTITY) || ',' ||
		TO_CHAR(p_ACCOUNT_SERVICE_CHARGE.BILL_AMOUNT));
	END IF;

    UPDATE ACCOUNT_SERVICE_CHARGE SET
		ROW = p_ACCOUNT_SERVICE_CHARGE
	WHERE CHARGE_ID = p_ACCOUNT_SERVICE_CHARGE.CHARGE_ID
	    AND ACCOUNT_SERVICE_ID = p_ACCOUNT_SERVICE_CHARGE.ACCOUNT_SERVICE_ID
	    AND BAND_NUMBER = p_ACCOUNT_SERVICE_CHARGE.BAND_NUMBER
	    AND BILL_CODE = p_ACCOUNT_SERVICE_CHARGE.BILL_CODE
	    AND CHARGE_BEGIN_DATE = p_ACCOUNT_SERVICE_CHARGE.CHARGE_BEGIN_DATE;

	IF SQL%NOTFOUND THEN
	    INSERT INTO ACCOUNT_SERVICE_CHARGE VALUES p_ACCOUNT_SERVICE_CHARGE;
	END IF;

END PUT_ACCOUNT_SERVICE_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PRIOR_ACCOUNT_SERVICE_CHARGE
	(
	p_PRIOR_CHARGE_ID IN NUMBER,
	p_ACCOUNT_SERVICE_CHARGE IN OUT ACCOUNT_SERVICE_CHARGE%ROWTYPE
	) AS

BEGIN

	IF GA.APPLY_PRIOR_BILL_CHARGES AND NOT p_PRIOR_CHARGE_ID = g_NOT_ASSIGNED THEN
		SELECT CHARGE_QUANTITY, CHARGE_AMOUNT
		INTO p_ACCOUNT_SERVICE_CHARGE.BILL_QUANTITY, p_ACCOUNT_SERVICE_CHARGE.BILL_AMOUNT
		FROM ACCOUNT_SERVICE_CHARGE
		WHERE CHARGE_ID = p_PRIOR_CHARGE_ID
		    AND ACCOUNT_SERVICE_ID = p_ACCOUNT_SERVICE_CHARGE.ACCOUNT_SERVICE_ID
		    AND BAND_NUMBER = p_ACCOUNT_SERVICE_CHARGE.BAND_NUMBER
			AND BILL_CODE = p_ACCOUNT_SERVICE_CHARGE.BILL_CODE
			AND CHARGE_BEGIN_DATE = p_ACCOUNT_SERVICE_CHARGE.CHARGE_BEGIN_DATE;
		p_ACCOUNT_SERVICE_CHARGE.BILL_QUANTITY := p_ACCOUNT_SERVICE_CHARGE.CHARGE_QUANTITY - p_ACCOUNT_SERVICE_CHARGE.BILL_QUANTITY;
		p_ACCOUNT_SERVICE_CHARGE.BILL_AMOUNT := p_ACCOUNT_SERVICE_CHARGE.CHARGE_AMOUNT - p_ACCOUNT_SERVICE_CHARGE.BILL_AMOUNT;
	ELSE
		p_ACCOUNT_SERVICE_CHARGE.BILL_QUANTITY := p_ACCOUNT_SERVICE_CHARGE.CHARGE_QUANTITY;
		p_ACCOUNT_SERVICE_CHARGE.BILL_AMOUNT := p_ACCOUNT_SERVICE_CHARGE.CHARGE_AMOUNT;
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		p_ACCOUNT_SERVICE_CHARGE.BILL_QUANTITY := p_ACCOUNT_SERVICE_CHARGE.CHARGE_QUANTITY;
		p_ACCOUNT_SERVICE_CHARGE.BILL_AMOUNT := p_ACCOUNT_SERVICE_CHARGE.CHARGE_AMOUNT;

END PRIOR_ACCOUNT_SERVICE_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_CONVERSION_CHARGE
	(
	p_CONVERSION_CHARGE IN CONVERSION_CHARGE%ROWTYPE
	) AS

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PUT_CONVERSION_CHARGE: ' ||
			TO_CHAR(p_CONVERSION_CHARGE.CHARGE_ID) || ',' ||
		    TEXT_UTIL.TO_CHAR_TIME(p_CONVERSION_CHARGE.CHARGE_DATE) || ',' ||
			TO_CHAR(p_CONVERSION_CHARGE.SCHEDULE_GROUP_ID) || ',' ||
		    TEXT_UTIL.TO_CHAR_TIME(p_CONVERSION_CHARGE.PEAK_DATE) || ',' ||
		    TO_CHAR(p_CONVERSION_CHARGE.PEAK_DEMAND) || ',' ||
		    TO_CHAR(p_CONVERSION_CHARGE.SCHEDULED_AMOUNT) || ',' ||
		    TO_CHAR(p_CONVERSION_CHARGE.COEFF_X3) || ',' ||
		    TO_CHAR(p_CONVERSION_CHARGE.COEFF_X2) || ',' ||
		    TO_CHAR(p_CONVERSION_CHARGE.COEFF_X1) || ',' ||
		    TO_CHAR(p_CONVERSION_CHARGE.CONST_K) || ',' ||
		    TO_CHAR(p_CONVERSION_CHARGE.CHARGE_QUANTITY) || ',' ||
		    TO_CHAR(p_CONVERSION_CHARGE.CHARGE_RATE) || ',' ||
		    TO_CHAR(p_CONVERSION_CHARGE.CHARGE_FACTOR) || ',' ||
		    TO_CHAR(p_CONVERSION_CHARGE.CHARGE_AMOUNT) || ',' ||
		    TO_CHAR(p_CONVERSION_CHARGE.BILL_QUANTITY) || ',' ||
		    TO_CHAR(p_CONVERSION_CHARGE.BILL_AMOUNT));
	END IF;

    UPDATE CONVERSION_CHARGE SET
		ROW = p_CONVERSION_CHARGE
	WHERE CHARGE_ID = p_CONVERSION_CHARGE.CHARGE_ID
	    AND CHARGE_DATE = p_CONVERSION_CHARGE.CHARGE_DATE
		AND SCHEDULE_GROUP_ID = p_CONVERSION_CHARGE.SCHEDULE_GROUP_ID;

	IF SQL%NOTFOUND THEN
	    INSERT INTO CONVERSION_CHARGE VALUES p_CONVERSION_CHARGE;
	END IF;

END PUT_CONVERSION_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PRIOR_CONVERSION_CHARGE
	(
	p_PRIOR_CHARGE_ID IN NUMBER,
	p_CONVERSION_CHARGE IN OUT CONVERSION_CHARGE%ROWTYPE
	) AS

BEGIN

	IF GA.APPLY_PRIOR_BILL_CHARGES AND NOT p_PRIOR_CHARGE_ID = g_NOT_ASSIGNED THEN
		SELECT CHARGE_QUANTITY, CHARGE_AMOUNT
		INTO p_CONVERSION_CHARGE.BILL_QUANTITY, p_CONVERSION_CHARGE.BILL_AMOUNT
		FROM CONVERSION_CHARGE
		WHERE CHARGE_ID = p_PRIOR_CHARGE_ID
		    	AND CHARGE_DATE = p_CONVERSION_CHARGE.CHARGE_DATE
			AND SCHEDULE_GROUP_ID = p_CONVERSION_CHARGE.SCHEDULE_GROUP_ID;
		p_CONVERSION_CHARGE.BILL_QUANTITY := p_CONVERSION_CHARGE.CHARGE_QUANTITY - p_CONVERSION_CHARGE.BILL_QUANTITY;
		p_CONVERSION_CHARGE.BILL_AMOUNT := p_CONVERSION_CHARGE.CHARGE_AMOUNT - p_CONVERSION_CHARGE.BILL_AMOUNT;
	ELSE
		p_CONVERSION_CHARGE.BILL_QUANTITY := p_CONVERSION_CHARGE.CHARGE_QUANTITY;
		p_CONVERSION_CHARGE.BILL_AMOUNT := p_CONVERSION_CHARGE.CHARGE_AMOUNT;
	END IF;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		p_CONVERSION_CHARGE.BILL_QUANTITY := p_CONVERSION_CHARGE.CHARGE_QUANTITY;
		p_CONVERSION_CHARGE.BILL_AMOUNT := p_CONVERSION_CHARGE.CHARGE_AMOUNT;

END PRIOR_CONVERSION_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_LMP_CHARGE
	(
	p_LMP_CHARGE IN LMP_CHARGE%ROWTYPE
	) AS

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PUT_LMP_CHARGE: ' ||
			TO_CHAR(p_LMP_CHARGE.CHARGE_ID) || ',' ||
		    TEXT_UTIL.TO_CHAR_TIME(p_LMP_CHARGE.CHARGE_DATE) || ',' ||
			TO_CHAR(p_LMP_CHARGE.SOURCE_ID) || ',' ||
			TO_CHAR(p_LMP_CHARGE.DELIVERY_POINT_ID) || ',' ||
			TO_CHAR(p_LMP_CHARGE.SINK_ID) || ',' ||
			TO_CHAR(p_LMP_CHARGE.DA_PURCHASES) || ',' ||
			TO_CHAR(p_LMP_CHARGE.RT_PURCHASES) || ',' ||
			TO_CHAR(p_LMP_CHARGE.DA_SALES) || ',' ||
			TO_CHAR(p_LMP_CHARGE.RT_SALES) || ',' ||
			TO_CHAR(p_LMP_CHARGE.DA_LOAD) || ',' ||
			TO_CHAR(p_LMP_CHARGE.RT_LOAD) || ',' ||
			TO_CHAR(p_LMP_CHARGE.DA_GENERATION) || ',' ||
			TO_CHAR(p_LMP_CHARGE.RT_GENERATION) || ',' ||
			TO_CHAR(p_LMP_CHARGE.PRICE1) || ',' ||
			TO_CHAR(p_LMP_CHARGE.PRICE2) || ',' ||
		    TO_CHAR(p_LMP_CHARGE.CHARGE_QUANTITY) || ',' ||
		    TO_CHAR(p_LMP_CHARGE.CHARGE_RATE) || ',' ||
		    TO_CHAR(p_LMP_CHARGE.CHARGE_FACTOR) || ',' ||
		    TO_CHAR(p_LMP_CHARGE.CHARGE_AMOUNT) || ',' ||
		    TO_CHAR(p_LMP_CHARGE.BILL_QUANTITY) || ',' ||
		    TO_CHAR(p_LMP_CHARGE.BILL_AMOUNT));
	END IF;

    UPDATE LMP_CHARGE SET
		ROW = p_LMP_CHARGE
	WHERE CHARGE_ID = p_LMP_CHARGE.CHARGE_ID
	    AND CHARGE_DATE = p_LMP_CHARGE.CHARGE_DATE
        AND SOURCE_ID = p_LMP_CHARGE.SOURCE_ID
        AND DELIVERY_POINT_ID = p_LMP_CHARGE.DELIVERY_POINT_ID
        AND SINK_ID = p_LMP_CHARGE.SINK_ID;

	IF SQL%NOTFOUND THEN
	    INSERT INTO LMP_CHARGE VALUES p_LMP_CHARGE;
	END IF;

END PUT_LMP_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PRIOR_LMP_CHARGE
	(
	p_PRIOR_CHARGE_ID IN NUMBER,
	p_LMP_CHARGE IN OUT LMP_CHARGE%ROWTYPE
	) AS

BEGIN

	IF GA.APPLY_PRIOR_BILL_CHARGES AND NOT p_PRIOR_CHARGE_ID = g_NOT_ASSIGNED THEN
		SELECT CHARGE_QUANTITY, CHARGE_AMOUNT
		INTO p_LMP_CHARGE.BILL_QUANTITY, p_LMP_CHARGE.BILL_AMOUNT
		FROM LMP_CHARGE
		WHERE CHARGE_ID = p_PRIOR_CHARGE_ID
		    	AND CHARGE_DATE = p_LMP_CHARGE.CHARGE_DATE
                AND SOURCE_ID = p_LMP_CHARGE.SOURCE_ID
                AND DELIVERY_POINT_ID = p_LMP_CHARGE.DELIVERY_POINT_ID
                AND SINK_ID = p_LMP_CHARGE.SINK_ID;
		p_LMP_CHARGE.BILL_QUANTITY := p_LMP_CHARGE.CHARGE_QUANTITY - p_LMP_CHARGE.BILL_QUANTITY;
		p_LMP_CHARGE.BILL_AMOUNT := p_LMP_CHARGE.CHARGE_AMOUNT - p_LMP_CHARGE.BILL_AMOUNT;
	ELSE
		p_LMP_CHARGE.BILL_QUANTITY := p_LMP_CHARGE.CHARGE_QUANTITY;
		p_LMP_CHARGE.BILL_AMOUNT := p_LMP_CHARGE.CHARGE_AMOUNT;
	END IF;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		p_LMP_CHARGE.BILL_QUANTITY := p_LMP_CHARGE.CHARGE_QUANTITY;
		p_LMP_CHARGE.BILL_AMOUNT := p_LMP_CHARGE.CHARGE_AMOUNT;

END PRIOR_LMP_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_FTR_CHARGE
	(
	p_FTR_CHARGE IN FTR_CHARGE%ROWTYPE
	) AS

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PUT_FTR_CHARGE: ' ||
			TO_CHAR(p_FTR_CHARGE.CHARGE_ID) || ',' ||
		    TEXT_UTIL.TO_CHAR_TIME(p_FTR_CHARGE.CHARGE_DATE) || ',' ||
			TO_CHAR(p_FTR_CHARGE.SOURCE_ID) || ',' ||
			TO_CHAR(p_FTR_CHARGE.DELIVERY_POINT_ID) || ',' ||
			TO_CHAR(p_FTR_CHARGE.SINK_ID) || ',' ||
            TO_CHAR(p_FTR_CHARGE.FTR_TYPE) || ',' ||
            TO_CHAR(p_FTR_CHARGE.ALLOC_FACTOR) || ',' ||
			TO_CHAR(p_FTR_CHARGE.PURCHASES) || ',' ||
			TO_CHAR(p_FTR_CHARGE.SALES) || ',' ||
			TO_CHAR(p_FTR_CHARGE.PRICE1) || ',' ||
			TO_CHAR(p_FTR_CHARGE.PRICE2) || ',' ||
		    TO_CHAR(p_FTR_CHARGE.CHARGE_QUANTITY) || ',' ||
		    TO_CHAR(p_FTR_CHARGE.CHARGE_RATE) || ',' ||
		    TO_CHAR(p_FTR_CHARGE.CHARGE_FACTOR) || ',' ||
		    TO_CHAR(p_FTR_CHARGE.CHARGE_AMOUNT) || ',' ||
		    TO_CHAR(p_FTR_CHARGE.BILL_QUANTITY) || ',' ||
		    TO_CHAR(p_FTR_CHARGE.BILL_AMOUNT));
	END IF;

    UPDATE FTR_CHARGE SET
		ROW = p_FTR_CHARGE
	WHERE CHARGE_ID = p_FTR_CHARGE.CHARGE_ID
	    AND CHARGE_DATE = p_FTR_CHARGE.CHARGE_DATE
        AND SOURCE_ID = p_FTR_CHARGE.SOURCE_ID
        AND DELIVERY_POINT_ID = p_FTR_CHARGE.DELIVERY_POINT_ID
        AND SINK_ID = p_FTR_CHARGE.SINK_ID
        AND FTR_TYPE = p_FTR_CHARGE.FTR_TYPE;

	IF SQL%NOTFOUND THEN
	    INSERT INTO FTR_CHARGE VALUES p_FTR_CHARGE;
	END IF;

END PUT_FTR_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PRIOR_FTR_CHARGE
	(
	p_PRIOR_CHARGE_ID IN NUMBER,
	p_FTR_CHARGE IN OUT FTR_CHARGE%ROWTYPE
	) AS

BEGIN

	IF GA.APPLY_PRIOR_BILL_CHARGES AND NOT p_PRIOR_CHARGE_ID = g_NOT_ASSIGNED THEN
		SELECT CHARGE_QUANTITY, CHARGE_AMOUNT
		INTO p_FTR_CHARGE.BILL_QUANTITY, p_FTR_CHARGE.BILL_AMOUNT
		FROM FTR_CHARGE
		WHERE CHARGE_ID = p_PRIOR_CHARGE_ID
		    	AND CHARGE_DATE = p_FTR_CHARGE.CHARGE_DATE
                AND SOURCE_ID = p_FTR_CHARGE.SOURCE_ID
                AND DELIVERY_POINT_ID = p_FTR_CHARGE.DELIVERY_POINT_ID
                AND SINK_ID = p_FTR_CHARGE.SINK_ID
                AND FTR_TYPE = p_FTR_CHARGE.FTR_TYPE;
		p_FTR_CHARGE.BILL_QUANTITY := p_FTR_CHARGE.CHARGE_QUANTITY - p_FTR_CHARGE.BILL_QUANTITY;
		p_FTR_CHARGE.BILL_AMOUNT := p_FTR_CHARGE.CHARGE_AMOUNT - p_FTR_CHARGE.BILL_AMOUNT;
	ELSE
		p_FTR_CHARGE.BILL_QUANTITY := p_FTR_CHARGE.CHARGE_QUANTITY;
		p_FTR_CHARGE.BILL_AMOUNT := p_FTR_CHARGE.CHARGE_AMOUNT;
	END IF;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		p_FTR_CHARGE.BILL_QUANTITY := p_FTR_CHARGE.CHARGE_QUANTITY;
		p_FTR_CHARGE.BILL_AMOUNT := p_FTR_CHARGE.CHARGE_AMOUNT;

END PRIOR_FTR_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_COMBINATION_CHARGE
	(
	p_COMBINATION_CHARGE IN COMBINATION_CHARGE%ROWTYPE
	) AS

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PUT_COMBINATION_CHARGE: ' ||
			TO_CHAR(p_COMBINATION_CHARGE.CHARGE_ID) || ',' ||
		    TEXT_UTIL.TO_CHAR_DATE(p_COMBINATION_CHARGE.BEGIN_DATE) || ',' ||
		    TEXT_UTIL.TO_CHAR_DATE(p_COMBINATION_CHARGE.END_DATE) || ',' ||
			TO_CHAR(p_COMBINATION_CHARGE.COMPONENT_ID) || ',' ||
			TO_CHAR(p_COMBINATION_CHARGE.COMBINED_CHARGE_ID) || ',' ||
			TO_CHAR(p_COMBINATION_CHARGE.CHARGE_VIEW_TYPE) || ',' ||
			TO_CHAR(p_COMBINATION_CHARGE.COEFFICIENT) || ',' ||
		    TO_CHAR(p_COMBINATION_CHARGE.CHARGE_QUANTITY) || ',' ||
		    TO_CHAR(p_COMBINATION_CHARGE.CHARGE_RATE) || ',' ||
		    TO_CHAR(p_COMBINATION_CHARGE.CHARGE_FACTOR) || ',' ||
		    TO_CHAR(p_COMBINATION_CHARGE.CHARGE_AMOUNT) || ',' ||
		    TO_CHAR(p_COMBINATION_CHARGE.BILL_QUANTITY) || ',' ||
		    TO_CHAR(p_COMBINATION_CHARGE.BILL_AMOUNT));
	END IF;

    UPDATE COMBINATION_CHARGE SET
		ROW = p_COMBINATION_CHARGE
	WHERE CHARGE_ID = p_COMBINATION_CHARGE.CHARGE_ID
        AND COMPONENT_ID = p_COMBINATION_CHARGE.COMPONENT_ID
	    AND BEGIN_DATE = p_COMBINATION_CHARGE.BEGIN_DATE;

	IF SQL%NOTFOUND THEN
	    INSERT INTO COMBINATION_CHARGE VALUES p_COMBINATION_CHARGE;
	END IF;

END PUT_COMBINATION_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PRIOR_COMBINATION_CHARGE
	(
	p_PRIOR_CHARGE_ID IN NUMBER,
	p_COMBINATION_CHARGE IN OUT COMBINATION_CHARGE%ROWTYPE
	) AS

BEGIN
	IF GA.APPLY_PRIOR_BILL_CHARGES AND NOT p_PRIOR_CHARGE_ID = g_NOT_ASSIGNED THEN
		SELECT CHARGE_QUANTITY, CHARGE_AMOUNT, COMPONENT_AMOUNT
		INTO p_COMBINATION_CHARGE.BILL_QUANTITY, p_COMBINATION_CHARGE.BILL_AMOUNT,
			p_COMBINATION_CHARGE.BILL_COMPONENT_AMOUNT
		FROM COMBINATION_CHARGE
		WHERE CHARGE_ID = p_PRIOR_CHARGE_ID
		    	AND COMPONENT_ID = p_COMBINATION_CHARGE.COMPONENT_ID
                AND BEGIN_DATE = p_COMBINATION_CHARGE.BEGIN_DATE;
		p_COMBINATION_CHARGE.BILL_QUANTITY := p_COMBINATION_CHARGE.CHARGE_QUANTITY - p_COMBINATION_CHARGE.BILL_QUANTITY;
		p_COMBINATION_CHARGE.BILL_AMOUNT := p_COMBINATION_CHARGE.CHARGE_AMOUNT - p_COMBINATION_CHARGE.BILL_AMOUNT;
		p_COMBINATION_CHARGE.BILL_COMPONENT_AMOUNT := p_COMBINATION_CHARGE.COMPONENT_AMOUNT - p_COMBINATION_CHARGE.BILL_COMPONENT_AMOUNT;
	ELSE
		p_COMBINATION_CHARGE.BILL_QUANTITY := p_COMBINATION_CHARGE.CHARGE_QUANTITY;
		p_COMBINATION_CHARGE.BILL_AMOUNT := p_COMBINATION_CHARGE.CHARGE_AMOUNT;
		p_COMBINATION_CHARGE.BILL_COMPONENT_AMOUNT := p_COMBINATION_CHARGE.COMPONENT_AMOUNT;
	END IF;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		p_COMBINATION_CHARGE.BILL_QUANTITY := p_COMBINATION_CHARGE.CHARGE_QUANTITY;
		p_COMBINATION_CHARGE.BILL_AMOUNT := p_COMBINATION_CHARGE.CHARGE_AMOUNT;
		p_COMBINATION_CHARGE.BILL_COMPONENT_AMOUNT := p_COMBINATION_CHARGE.COMPONENT_AMOUNT;

END PRIOR_COMBINATION_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_PIPELINE_CHARGE
	(
	p_PIPELINE_CHARGE IN PIPELINE_CHARGE%ROWTYPE
	) AS

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PUT_PIPELINE_CHARGE: ' ||
			TO_CHAR(p_PIPELINE_CHARGE.CHARGE_ID) || ',' ||
		    TEXT_UTIL.TO_CHAR_TIME(p_PIPELINE_CHARGE.CHARGE_DATE) || ',' ||
			TO_CHAR(p_PIPELINE_CHARGE.DELIVERY_ID) || ',' ||
			TO_CHAR(p_PIPELINE_CHARGE.POR_ID) || ',' ||
			TO_CHAR(p_PIPELINE_CHARGE.POD_ID) || ',' ||
		    TO_CHAR(p_PIPELINE_CHARGE.CHARGE_QUANTITY) || ',' ||
		    TO_CHAR(p_PIPELINE_CHARGE.CHARGE_RATE) || ',' ||
		    TO_CHAR(p_PIPELINE_CHARGE.CHARGE_FACTOR) || ',' ||
		    TO_CHAR(p_PIPELINE_CHARGE.CHARGE_AMOUNT) || ',' ||
		    TO_CHAR(p_PIPELINE_CHARGE.BILL_QUANTITY) || ',' ||
		    TO_CHAR(p_PIPELINE_CHARGE.BILL_AMOUNT));
	END IF;

    UPDATE PIPELINE_CHARGE SET
		ROW = p_PIPELINE_CHARGE
	WHERE CHARGE_ID = p_PIPELINE_CHARGE.CHARGE_ID
	    AND CHARGE_DATE = p_PIPELINE_CHARGE.CHARGE_DATE
		AND DELIVERY_ID = p_PIPELINE_CHARGE.DELIVERY_ID
		AND POR_ID = p_PIPELINE_CHARGE.POR_ID
		AND POD_ID = p_PIPELINE_CHARGE.POD_ID;

	IF SQL%NOTFOUND THEN
	    INSERT INTO PIPELINE_CHARGE VALUES p_PIPELINE_CHARGE;
	END IF;

END PUT_PIPELINE_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PRIOR_PIPELINE_CHARGE
	(
	p_PRIOR_CHARGE_ID IN NUMBER,
	p_PIPELINE_CHARGE IN OUT PIPELINE_CHARGE%ROWTYPE
	) AS

BEGIN

	IF GA.APPLY_PRIOR_BILL_CHARGES AND NOT p_PRIOR_CHARGE_ID = g_NOT_ASSIGNED THEN
		SELECT CHARGE_QUANTITY, CHARGE_AMOUNT
		INTO p_PIPELINE_CHARGE.BILL_QUANTITY, p_PIPELINE_CHARGE.BILL_AMOUNT
		FROM PIPELINE_CHARGE
		WHERE CHARGE_ID = p_PRIOR_CHARGE_ID
		    	AND CHARGE_DATE = p_PIPELINE_CHARGE.CHARGE_DATE
				AND DELIVERY_ID = p_PIPELINE_CHARGE.DELIVERY_ID
				AND POR_ID = p_PIPELINE_CHARGE.POR_ID
				AND POD_ID = p_PIPELINE_CHARGE.POD_ID;
		p_PIPELINE_CHARGE.BILL_QUANTITY := p_PIPELINE_CHARGE.CHARGE_QUANTITY - p_PIPELINE_CHARGE.BILL_QUANTITY;
		p_PIPELINE_CHARGE.BILL_AMOUNT := p_PIPELINE_CHARGE.CHARGE_AMOUNT - p_PIPELINE_CHARGE.BILL_AMOUNT;
	ELSE
		p_PIPELINE_CHARGE.BILL_QUANTITY := p_PIPELINE_CHARGE.CHARGE_QUANTITY;
		p_PIPELINE_CHARGE.BILL_AMOUNT := p_PIPELINE_CHARGE.CHARGE_AMOUNT;
	END IF;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		p_PIPELINE_CHARGE.BILL_QUANTITY := p_PIPELINE_CHARGE.CHARGE_QUANTITY;
		p_PIPELINE_CHARGE.BILL_AMOUNT := p_PIPELINE_CHARGE.CHARGE_AMOUNT;

END PRIOR_PIPELINE_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PRIOR_FORMULA_CHARGE
	(
	p_PRIOR_CHARGE_ID IN NUMBER,
	p_FORMULA_CHARGE IN OUT FORMULA_CHARGE%ROWTYPE
	) AS
BEGIN
	CALC_ENGINE.PRIOR_FORMULA_CHARGE(p_PRIOR_CHARGE_ID, p_FORMULA_CHARGE);
END PRIOR_FORMULA_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_FORMULA_CHARGE
	(
	p_FORMULA_CHARGE IN FORMULA_CHARGE%ROWTYPE
	) AS
v_COUNT PLS_INTEGER;
BEGIN
	-- verify that there is an entry in parent table - if this is the same charge and iterator
	-- as last call, then we definitely have parent records and can skip this step
	IF g_LAST_FORMULA_CHARGE_ID IS NULL OR g_LAST_FORMULA_ITERATOR_ID IS NULL OR
		g_LAST_FORMULA_CHARGE_ID <> p_FORMULA_CHARGE.CHARGE_ID OR
		g_LAST_FORMULA_ITERATOR_ID <> p_FORMULA_CHARGE.ITERATOR_ID THEN

		SELECT COUNT(1)
		INTO v_COUNT
		FROM FORMULA_CHARGE_ITERATOR
		WHERE CHARGE_ID = p_FORMULA_CHARGE.CHARGE_ID
			AND ITERATOR_ID = p_FORMULA_CHARGE.ITERATOR_ID;

		IF v_COUNT = 0 THEN
			DECLARE
				v_ITER FORMULA_CHARGE_ITERATOR%ROWTYPE;
			BEGIN
				v_ITER.CHARGE_ID := p_FORMULA_CHARGE.CHARGE_ID;
				v_ITER.ITERATOR_ID := p_FORMULA_CHARGE.ITERATOR_ID;
				-- this call updates globals so we don't have to do so here
				PUT_FORMULA_ITERATOR(v_ITER);
			END;
		ELSE
			-- we have parent record - now update globals
			g_LAST_FORMULA_CHARGE_ID := p_FORMULA_CHARGE.CHARGE_ID;
			g_LAST_FORMULA_ITERATOR_ID := p_FORMULA_CHARGE.ITERATOR_ID;
		END IF;

	END IF;

	g_LAST_FORMULA_CHARGE_DATE := p_FORMULA_CHARGE.CHARGE_DATE;

	-- now put the record
	CALC_ENGINE.PUT_FORMULA_CHARGE(p_FORMULA_CHARGE);
END PUT_FORMULA_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_FORMULA_CHARGE_VAR
	(
	p_FORMULA_CHARGE_VAR IN FORMULA_CHARGE_VARIABLE%ROWTYPE
	) AS
v_COUNT PLS_INTEGER;
BEGIN
	-- verify that there is an entry in parent table - if this is the same charge, iterator,
	-- and date as last call, then we definitely have parent records and can skip this step
	IF g_LAST_FORMULA_CHARGE_ID IS NULL OR g_LAST_FORMULA_ITERATOR_ID IS NULL OR
		g_LAST_FORMULA_CHARGE_DATE IS NULL OR
		g_LAST_FORMULA_CHARGE_ID <> p_FORMULA_CHARGE_VAR.CHARGE_ID OR
		g_LAST_FORMULA_ITERATOR_ID <> p_FORMULA_CHARGE_VAR.ITERATOR_ID OR
		g_LAST_FORMULA_CHARGE_DATE <> p_FORMULA_CHARGE_VAR.CHARGE_DATE THEN

		SELECT COUNT(1)
		INTO v_COUNT
		FROM FORMULA_CHARGE
		WHERE CHARGE_ID = p_FORMULA_CHARGE_VAR.CHARGE_ID
			AND ITERATOR_ID = p_FORMULA_CHARGE_VAR.ITERATOR_ID
			AND CHARGE_DATE = p_FORMULA_CHARGE_VAR.CHARGE_DATE;

		IF v_COUNT = 0 THEN
			DECLARE
				v_REC FORMULA_CHARGE%ROWTYPE;
			BEGIN
				v_REC.CHARGE_ID := p_FORMULA_CHARGE_VAR.CHARGE_ID;
				v_REC.ITERATOR_ID := p_FORMULA_CHARGE_VAR.ITERATOR_ID;
				v_REC.CHARGE_DATE := p_FORMULA_CHARGE_VAR.CHARGE_DATE;
				-- this call updates globals so we don't have to do so here
				PUT_FORMULA_CHARGE(v_REC);
			END;
		ELSE
			-- we have parent record - now update globals
			g_LAST_FORMULA_CHARGE_ID := p_FORMULA_CHARGE_VAR.CHARGE_ID;
			g_LAST_FORMULA_ITERATOR_ID := p_FORMULA_CHARGE_VAR.ITERATOR_ID;
			g_LAST_FORMULA_CHARGE_DATE := p_FORMULA_CHARGE_VAR.CHARGE_DATE;
		END IF;

	END IF;

	-- now put the record
	CALC_ENGINE.PUT_FORMULA_CHARGE_VAR(p_FORMULA_CHARGE_VAR);
END PUT_FORMULA_CHARGE_VAR;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_FORMULA_ITERATOR
	(
	p_FORMULA_CHARGE_ITERATOR IN FORMULA_CHARGE_ITERATOR%ROWTYPE
	) AS
v_COUNT PLS_INTEGER;
BEGIN
	-- verify that there is an entry in parent table - if this is the same charge
	-- as last call, then we definitely have parent records and can skip this step
	IF g_LAST_FORMULA_CHARGE_ID IS NULL OR
		g_LAST_FORMULA_CHARGE_ID <> p_FORMULA_CHARGE_ITERATOR.CHARGE_ID THEN

		SELECT COUNT(1)
		INTO v_COUNT
		FROM FORMULA_CHARGE_ITERATOR_NAME
		WHERE CHARGE_ID = p_FORMULA_CHARGE_ITERATOR.CHARGE_ID;

		IF v_COUNT = 0 THEN
			DECLARE
				v_ITER FORMULA_CHARGE_ITERATOR_NAME%ROWTYPE;
			BEGIN
				v_ITER.CHARGE_ID := p_FORMULA_CHARGE_ITERATOR.CHARGE_ID;
				-- this call updates global so we don't have to do so here
				PUT_FORMULA_ITERATOR_NAMES(v_ITER);
			END;
		ELSE
			-- we have parent record - now update global
			g_LAST_FORMULA_CHARGE_ID := p_FORMULA_CHARGE_ITERATOR.CHARGE_ID;
		END IF;

	END IF;

	g_LAST_FORMULA_ITERATOR_ID := p_FORMULA_CHARGE_ITERATOR.ITERATOR_ID;
	g_LAST_FORMULA_CHARGE_DATE := NULL;

	-- now put the record
	CALC_ENGINE.PUT_FORMULA_ITERATOR(p_FORMULA_CHARGE_ITERATOR);
END PUT_FORMULA_ITERATOR;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_FORMULA_ITERATOR_NAMES
	(
	p_FORMULA_CHARGE_ITERATOR_NAME IN FORMULA_CHARGE_ITERATOR_NAME%ROWTYPE
	) AS
BEGIN
	g_LAST_FORMULA_CHARGE_ID := p_FORMULA_CHARGE_ITERATOR_NAME.CHARGE_ID;
	g_LAST_FORMULA_ITERATOR_ID := NULL;
	g_LAST_FORMULA_CHARGE_DATE := NULL;

	CALC_ENGINE.PUT_FORMULA_ITERATOR_NAMES(p_FORMULA_CHARGE_ITERATOR_NAME);
END PUT_FORMULA_ITERATOR_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_AREA_LOAD
	(
	p_AREA_LOAD IN AREA_LOAD%ROWTYPE
	) AS

BEGIN

    UPDATE AREA_LOAD SET
	    LOAD_VAL = p_AREA_LOAD.LOAD_VAL
	WHERE AREA_ID = p_AREA_LOAD.AREA_ID
	    AND LOAD_DATE = p_AREA_LOAD.LOAD_DATE
	    AND LOAD_CODE = p_AREA_LOAD.LOAD_CODE;

	IF SQL%NOTFOUND THEN
	    INSERT INTO AREA_LOAD (
		    AREA_ID,
			LOAD_DATE,
			LOAD_CODE,
			LOAD_VAL)
		VALUES (
		    p_AREA_LOAD.AREA_ID,
			p_AREA_LOAD.LOAD_DATE,
			p_AREA_LOAD.LOAD_CODE,
			p_AREA_LOAD.LOAD_VAL);
	END IF;

END PUT_AREA_LOAD;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_MARKET_PRICE_VALUE
	(
	p_MARKET_PRICE_VALUE IN MARKET_PRICE_VALUE%ROWTYPE
	) AS

BEGIN

    UPDATE MARKET_PRICE_VALUE SET
	    PRICE_BASIS = p_MARKET_PRICE_VALUE.PRICE_BASIS,
	    PRICE = p_MARKET_PRICE_VALUE.PRICE
	WHERE MARKET_PRICE_ID = p_MARKET_PRICE_VALUE.MARKET_PRICE_ID
	    AND PRICE_CODE = p_MARKET_PRICE_VALUE.PRICE_CODE
	    AND PRICE_DATE = p_MARKET_PRICE_VALUE.PRICE_DATE
	    AND AS_OF_DATE = p_MARKET_PRICE_VALUE.AS_OF_DATE;

	IF SQL%NOTFOUND THEN
	    INSERT INTO MARKET_PRICE_VALUE (
		    MARKET_PRICE_ID,
			PRICE_CODE,
			PRICE_DATE,
			AS_OF_DATE,
			PRICE_BASIS,
			PRICE)
		VALUES (
		    p_MARKET_PRICE_VALUE.MARKET_PRICE_ID,
			p_MARKET_PRICE_VALUE.PRICE_CODE,
			p_MARKET_PRICE_VALUE.PRICE_DATE,
			p_MARKET_PRICE_VALUE.AS_OF_DATE,
			p_MARKET_PRICE_VALUE.PRICE_BASIS,
			p_MARKET_PRICE_VALUE.PRICE);
	END IF;

END PUT_MARKET_PRICE_VALUE;
---------------------------------------------------------------------------------------------------
PROCEDURE TRACE_INVOICE
	(
	p_INVOICE IN INVOICE%ROWTYPE
	) AS

BEGIN

	LOGS.LOG_DEBUG_DETAIL('TRACE_INVOICE');
	LOGS.LOG_DEBUG_DETAIL('ENTITY_ID=' || TO_CHAR(p_INVOICE.ENTITY_ID));
	LOGS.LOG_DEBUG_DETAIL('STATEMENT_TYPE=' || TO_CHAR(p_INVOICE.STATEMENT_TYPE));
	LOGS.LOG_DEBUG_DETAIL('STATEMENT_STATE=' || TO_CHAR(p_INVOICE.STATEMENT_STATE));
	LOGS.LOG_DEBUG_DETAIL('BEGIN_DATE=' || TO_CHAR(p_INVOICE.BEGIN_DATE));
	LOGS.LOG_DEBUG_DETAIL('END_DATE=' || TO_CHAR(p_INVOICE.BEGIN_DATE));
	LOGS.LOG_DEBUG_DETAIL('AS_OF_DATE=' || TEXT_UTIL.TO_CHAR_TIME(p_INVOICE.AS_OF_DATE));
	LOGS.LOG_DEBUG_DETAIL('INVOICE_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_INVOICE.INVOICE_DATE));
	LOGS.LOG_DEBUG_DETAIL('INVOICE_NUMBER=' || p_INVOICE.INVOICE_NUMBER);
	LOGS.LOG_DEBUG_DETAIL('INVOICE_SUB_LEDGER_NUMBER=' || p_INVOICE.INVOICE_SUB_LEDGER_NUMBER);
	LOGS.LOG_DEBUG_DETAIL('BILLING_CONTACT=' || p_INVOICE.BILLING_CONTACT);
	LOGS.LOG_DEBUG_DETAIL('BILLING_STREET=' || p_INVOICE.BILLING_STREET);
	LOGS.LOG_DEBUG_DETAIL('BILLING_CITY=' || p_INVOICE.BILLING_CITY);
	LOGS.LOG_DEBUG_DETAIL('BILLING_STATE_CODE=' || p_INVOICE.BILLING_STATE_CODE);
	LOGS.LOG_DEBUG_DETAIL('BILLING_POSTAL_CODE=' || p_INVOICE.BILLING_POSTAL_CODE);
	LOGS.LOG_DEBUG_DETAIL('BILLING_COUNTRY_CODE=' || p_INVOICE.BILLING_COUNTRY_CODE);
	LOGS.LOG_DEBUG_DETAIL('BILLING_PHONE=' || p_INVOICE.BILLING_PHONE);
	LOGS.LOG_DEBUG_DETAIL('BILLING_FAX=' || p_INVOICE.BILLING_FAX);
	LOGS.LOG_DEBUG_DETAIL('INVOICE_TERMS=' || p_INVOICE.INVOICE_TERMS);
	LOGS.LOG_DEBUG_DETAIL('INVOICE_PRIMARY_CONTACT=' || p_INVOICE.INVOICE_PRIMARY_CONTACT);
	LOGS.LOG_DEBUG_DETAIL('INVOICE_PRIMARY_PHONE=' || p_INVOICE.INVOICE_PRIMARY_PHONE);
	LOGS.LOG_DEBUG_DETAIL('INVOICE_SECONDARY_CONTACT=' || p_INVOICE.INVOICE_SECONDARY_CONTACT);
	LOGS.LOG_DEBUG_DETAIL('INVOICE_SECONDARY_PHONE=' || p_INVOICE.INVOICE_SECONDARY_PHONE);
	LOGS.LOG_DEBUG_DETAIL('PAY_CHECK_CONTACT=' || p_INVOICE.PAY_CHECK_CONTACT);
	LOGS.LOG_DEBUG_DETAIL('PAY_CHECK_STREET=' || p_INVOICE.PAY_CHECK_STREET);
	LOGS.LOG_DEBUG_DETAIL('PAY_CHECK_CITY=' || p_INVOICE.PAY_CHECK_CITY);
	LOGS.LOG_DEBUG_DETAIL('PAY_CHECK_STATE_CODE=' || p_INVOICE.PAY_CHECK_STATE_CODE);
	LOGS.LOG_DEBUG_DETAIL('PAY_CHECK_POSTAL_CODE=' || p_INVOICE.PAY_CHECK_POSTAL_CODE);
	LOGS.LOG_DEBUG_DETAIL('PAY_CHECK_COUNTRY_CODE=' || p_INVOICE.PAY_CHECK_COUNTRY_CODE);
	LOGS.LOG_DEBUG_DETAIL('PAY_ELECTRONIC_DEBIT_NAME=' || p_INVOICE.PAY_ELECTRONIC_DEBIT_NAME);
	LOGS.LOG_DEBUG_DETAIL('PAY_ELECTRONIC_DEBIT_NBR=' || p_INVOICE.PAY_ELECTRONIC_DEBIT_NBR);
	LOGS.LOG_DEBUG_DETAIL('PAY_ELECTRONIC_CREDIT_NAME=' || p_INVOICE.PAY_ELECTRONIC_CREDIT_NAME);
	LOGS.LOG_DEBUG_DETAIL('PAY_ELECTRONIC_CREDIT_NBR=' || p_INVOICE.PAY_ELECTRONIC_CREDIT_NBR);
	LOGS.LOG_DEBUG_DETAIL('ENTITY_TYPE=' || p_INVOICE.ENTITY_TYPE);
	LOGS.LOG_DEBUG_DETAIL('INVOICE_STATUS=' || p_INVOICE.INVOICE_STATUS);
	LOGS.LOG_DEBUG_DETAIL('INVOICE_ID=' || TO_CHAR(p_INVOICE.INVOICE_ID));
END TRACE_INVOICE;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_INVOICE
	(
	p_INVOICE IN OUT NOCOPY INVOICE%ROWTYPE
	) AS
v_HAVE_IT BOOLEAN := TRUE;
BEGIN

	IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
		TRACE_INVOICE(p_INVOICE);
	END IF;

	-- Invoice ID not specified? query for it
	IF NVL(p_INVOICE.INVOICE_ID,0) = 0 THEN
		BEGIN
        	SELECT INVOICE_ID
        	INTO p_INVOICE.INVOICE_ID
        	FROM INVOICE
        	WHERE ENTITY_ID = p_INVOICE.ENTITY_ID
        		AND STATEMENT_TYPE = p_INVOICE.STATEMENT_TYPE
        		AND STATEMENT_STATE = p_INVOICE.STATEMENT_STATE
        		AND BEGIN_DATE = p_INVOICE.BEGIN_DATE
        		AND AS_OF_DATE = p_INVOICE.AS_OF_DATE;
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				v_HAVE_IT := FALSE;
		END;
	END IF;

	-- Have an invoice ID - then do update
	IF v_HAVE_IT THEN
		UPDATE INVOICE SET ROW = p_INVOICE
		WHERE INVOICE_ID = p_INVOICE.INVOICE_ID;

		IF SQL%NOTFOUND THEN
			v_HAVE_IT := FALSE; -- didn't actually update anything
								-- so we don't already have an invoice
		END IF;
	END IF;

	-- No invoice updated? then create a new one
	IF NOT v_HAVE_IT THEN
	    SELECT BID.NEXTVAL INTO p_INVOICE.INVOICE_ID FROM DUAL;
	    INSERT INTO INVOICE VALUES p_INVOICE;
	END IF;

END PUT_INVOICE;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_INVOICE_LINE_ITEM
	(
	p_INVOICE_LINE_ITEM IN OUT NOCOPY INVOICE_LINE_ITEM%ROWTYPE
	) AS

BEGIN

	IF p_INVOICE_LINE_ITEM.LINE_ITEM_QUANTITY <> 0 THEN
		p_INVOICE_LINE_ITEM.LINE_ITEM_RATE := ABS(p_INVOICE_LINE_ITEM.LINE_ITEM_AMOUNT) / ABS(p_INVOICE_LINE_ITEM.LINE_ITEM_QUANTITY);
	ELSE
		p_INVOICE_LINE_ITEM.LINE_ITEM_RATE := 0;
	END IF;

	IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
	    LOGS.LOG_DEBUG_DETAIL('PUT_INVOICE_LINE_ITEM');
		LOGS.LOG_DEBUG_DETAIL(p_INVOICE_LINE_ITEM.LINE_ITEM_NAME || ',' ||
			TO_CHAR(p_INVOICE_LINE_ITEM.INVOICE_ID) || ',' ||
			TO_CHAR(p_INVOICE_LINE_ITEM.PRODUCT_ID) || ',' ||
			TO_CHAR(p_INVOICE_LINE_ITEM.COMPONENT_ID) || ',' ||
			TO_CHAR(p_INVOICE_LINE_ITEM.ACCOUNT_SERVICE_ID) || ',' ||
			TO_CHAR(p_INVOICE_LINE_ITEM.LINE_ITEM_QUANTITY) || ',' ||
			TO_CHAR(p_INVOICE_LINE_ITEM.LINE_ITEM_RATE) || ',' ||
			TO_CHAR(p_INVOICE_LINE_ITEM.LINE_ITEM_AMOUNT) || ',' ||
			TO_CHAR(p_INVOICE_LINE_ITEM.LINE_ITEM_BILL_AMOUNT));
	END IF;

	p_INVOICE_LINE_ITEM.ENTRY_DATE := SYSDATE;

    UPDATE INVOICE_LINE_ITEM SET
		ROW = p_INVOICE_LINE_ITEM
	WHERE INVOICE_ID = p_INVOICE_LINE_ITEM.INVOICE_ID
		AND LINE_ITEM_NAME = p_INVOICE_LINE_ITEM.LINE_ITEM_NAME;

	IF SQL%NOTFOUND THEN
	    INSERT INTO INVOICE_LINE_ITEM VALUES p_INVOICE_LINE_ITEM;
	END IF;

END PUT_INVOICE_LINE_ITEM;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_NET_RETAIL_PROFIT_LOSS
	(
	p_NET_RETAIL_PROFIT_LOSS IN NET_RETAIL_PROFIT_LOSS%ROWTYPE
	) AS

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG(TEXT_UTIL.TO_CHAR_TIME(p_NET_RETAIL_PROFIT_LOSS.CHARGE_DATE) || ',' ||
		    TO_CHAR(p_NET_RETAIL_PROFIT_LOSS.SYSTEM_OVER_SUPPLY) || ',' ||
		    TO_CHAR(p_NET_RETAIL_PROFIT_LOSS.SYSTEM_UNDER_SUPPLY) || ',' ||
		    TO_CHAR(p_NET_RETAIL_PROFIT_LOSS.SYSTEM_NET_POSITION) || ',' ||
		    TO_CHAR(p_NET_RETAIL_PROFIT_LOSS.OVER_SUPPLY_RATE) || ',' ||
		    TO_CHAR(p_NET_RETAIL_PROFIT_LOSS.OSF_AMOUNT) || ',' ||
		    TO_CHAR(p_NET_RETAIL_PROFIT_LOSS.OSF_RATE) || ',' ||
		    TO_CHAR(p_NET_RETAIL_PROFIT_LOSS.REVENUE_AMOUNT) || ',' ||
		    TO_CHAR(p_NET_RETAIL_PROFIT_LOSS.BENEFIT_AMOUNT));
	END IF;

    UPDATE NET_RETAIL_PROFIT_LOSS SET
	    SYSTEM_OVER_SUPPLY = p_NET_RETAIL_PROFIT_LOSS.SYSTEM_OVER_SUPPLY,
	    SYSTEM_UNDER_SUPPLY = p_NET_RETAIL_PROFIT_LOSS.SYSTEM_UNDER_SUPPLY,
	    SYSTEM_NET_POSITION = p_NET_RETAIL_PROFIT_LOSS.SYSTEM_NET_POSITION,
	    OVER_SUPPLY_RATE = p_NET_RETAIL_PROFIT_LOSS.OVER_SUPPLY_RATE,
	    UNDER_SUPPLY_RATE = p_NET_RETAIL_PROFIT_LOSS.UNDER_SUPPLY_RATE,
	    OSF_AMOUNT = p_NET_RETAIL_PROFIT_LOSS.OSF_AMOUNT,
	    OSF_RATE = p_NET_RETAIL_PROFIT_LOSS.OSF_RATE,
	    REVENUE_AMOUNT = p_NET_RETAIL_PROFIT_LOSS.REVENUE_AMOUNT,
	    BENEFIT_AMOUNT = p_NET_RETAIL_PROFIT_LOSS.BENEFIT_AMOUNT
	WHERE STATEMENT_TYPE = p_NET_RETAIL_PROFIT_LOSS.STATEMENT_TYPE
	    AND STATEMENT_DATE = p_NET_RETAIL_PROFIT_LOSS.STATEMENT_DATE
	    AND CHARGE_DATE = p_NET_RETAIL_PROFIT_LOSS.CHARGE_DATE
	    AND AS_OF_DATE = p_NET_RETAIL_PROFIT_LOSS.AS_OF_DATE;

	IF SQL%NOTFOUND THEN
	    INSERT INTO NET_RETAIL_PROFIT_LOSS (
		    STATEMENT_TYPE,
			STATEMENT_DATE,
			CHARGE_DATE,
			AS_OF_DATE,
		    SYSTEM_OVER_SUPPLY,
			SYSTEM_UNDER_SUPPLY,
		    SYSTEM_NET_POSITION,
	    	OVER_SUPPLY_RATE,
		    UNDER_SUPPLY_RATE,
		    OSF_AMOUNT,
	    	OSF_RATE,
		    REVENUE_AMOUNT,
		    BENEFIT_AMOUNT)
		VALUES (
		    p_NET_RETAIL_PROFIT_LOSS.STATEMENT_TYPE,
			p_NET_RETAIL_PROFIT_LOSS.STATEMENT_DATE,
			p_NET_RETAIL_PROFIT_LOSS.CHARGE_DATE,
			p_NET_RETAIL_PROFIT_LOSS.AS_OF_DATE,
		    p_NET_RETAIL_PROFIT_LOSS.SYSTEM_OVER_SUPPLY,
			p_NET_RETAIL_PROFIT_LOSS.SYSTEM_UNDER_SUPPLY,
		    p_NET_RETAIL_PROFIT_LOSS.SYSTEM_NET_POSITION,
	    	p_NET_RETAIL_PROFIT_LOSS.OVER_SUPPLY_RATE,
		    p_NET_RETAIL_PROFIT_LOSS.UNDER_SUPPLY_RATE,
		    p_NET_RETAIL_PROFIT_LOSS.OSF_AMOUNT,
	    	p_NET_RETAIL_PROFIT_LOSS.OSF_RATE,
		    p_NET_RETAIL_PROFIT_LOSS.REVENUE_AMOUNT,
		    p_NET_RETAIL_PROFIT_LOSS.BENEFIT_AMOUNT);
	END IF;

END PUT_NET_RETAIL_PROFIT_LOSS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_ENTITY_INVOICE_HEADER
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_SUBLEDGER_NUM OUT VARCHAR,
	p_BILLING_CONTACT OUT VARCHAR,
    p_BILLING_STREET OUT VARCHAR,
    p_BILLING_CITY OUT VARCHAR,
    p_BILLING_STATE_CODE OUT VARCHAR,
    p_BILLING_POSTAL_CODE OUT VARCHAR,
    p_BILLING_COUNTRY_CODE OUT VARCHAR,
	p_BILLING_PHONE OUT VARCHAR,
	p_BILLING_FAX OUT VARCHAR,
    p_INVOICE_TERMS OUT VARCHAR,
    p_PAY_CHECK_CONTACT OUT VARCHAR,
    p_PAY_CHECK_STREET OUT VARCHAR,
    p_PAY_CHECK_CITY OUT VARCHAR,
    p_PAY_CHECK_STATE_CODE OUT VARCHAR,
    p_PAY_CHECK_POSTAL_CODE OUT VARCHAR,
    p_PAY_CHECK_COUNTRY_CODE OUT VARCHAR,
    p_PAY_ELECTRONIC_DEBIT_NAME OUT VARCHAR,
    p_PAY_ELECTRONIC_DEBIT_NBR OUT VARCHAR,
    p_PAY_ELECTRONIC_CREDIT_NAME OUT VARCHAR,
    p_PAY_ELECTRONIC_CREDIT_NBR OUT VARCHAR,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

v_DATE DATE := SYSDATE;
v_ENTITY_TYPE VARCHAR(16) := g_PSE;

BEGIN

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := NULL;

	RO.GET_ENTITY_CONTACT(p_ENTITY_ID, v_ENTITY_TYPE, 'Billing', p_BILLING_CONTACT, g_CONTACT_ALIAS, p_BILLING_PHONE, g_HOME_PHONE, p_BILLING_FAX, g_CELL_PHONE, g_EMAIL_ADDRESS, g_STATUS);
	RO.GET_ENTITY_ADDRESS(p_ENTITY_ID, v_ENTITY_TYPE, 'Billing', p_BILLING_STREET, p_BILLING_CITY, p_BILLING_STATE_CODE, p_BILLING_POSTAL_CODE, p_BILLING_COUNTRY_CODE, g_STATUS);
	RO.GET_ENTITY_ATTRIBUTE('Invoice Terms', v_ENTITY_TYPE, p_ENTITY_ID, v_DATE, p_INVOICE_TERMS, g_STATUS);
	RO.GET_ENTITY_ATTRIBUTE('Subledger Number', v_ENTITY_TYPE, p_ENTITY_ID, v_DATE, p_SUBLEDGER_NUM, g_STATUS);
	RO.GET_ENTITY_CONTACT(p_ENTITY_ID, v_ENTITY_TYPE, 'Payment', p_PAY_CHECK_CONTACT, g_CONTACT_ALIAS, g_WORK_PHONE, g_HOME_PHONE, g_FAX_PHONE, g_CELL_PHONE, g_EMAIL_ADDRESS, g_STATUS);
	RO.GET_ENTITY_ADDRESS(p_ENTITY_ID, v_ENTITY_TYPE, 'Payment', p_PAY_CHECK_STREET, p_PAY_CHECK_CITY, p_PAY_CHECK_STATE_CODE, p_PAY_CHECK_POSTAL_CODE, p_PAY_CHECK_COUNTRY_CODE, g_STATUS);
	RO.GET_ENTITY_ATTRIBUTE('Debit Name', v_ENTITY_TYPE, p_ENTITY_ID, v_DATE, p_PAY_ELECTRONIC_DEBIT_NAME, g_STATUS);
	RO.GET_ENTITY_ATTRIBUTE('Debit Number', v_ENTITY_TYPE, p_ENTITY_ID, v_DATE, p_PAY_ELECTRONIC_DEBIT_NBR, g_STATUS);
	RO.GET_ENTITY_ATTRIBUTE('Credit Name', v_ENTITY_TYPE, p_ENTITY_ID, v_DATE, p_PAY_ELECTRONIC_CREDIT_NAME, g_STATUS);
	RO.GET_ENTITY_ATTRIBUTE('Credit Number', v_ENTITY_TYPE, p_ENTITY_ID, v_DATE, p_PAY_ELECTRONIC_CREDIT_NBR, g_STATUS);

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('GET_ENTITY_INVOICE_HEADER');
	    LOGS.LOG_DEBUG('BILLING CONTACT');
	    TRACE_CONTACT(p_BILLING_CONTACT, g_CONTACT_ALIAS, g_WORK_PHONE, g_HOME_PHONE, g_FAX_PHONE, g_CELL_PHONE, g_EMAIL_ADDRESS);
		TRACE_ADDRESS(p_BILLING_STREET, p_BILLING_CITY, p_BILLING_STATE_CODE, p_BILLING_POSTAL_CODE, p_BILLING_COUNTRY_CODE);
	    LOGS.LOG_DEBUG('PAYMENT CONTACT');
	    TRACE_CONTACT(p_PAY_CHECK_CONTACT, g_CONTACT_ALIAS, g_WORK_PHONE, g_HOME_PHONE, g_FAX_PHONE, g_CELL_PHONE, g_EMAIL_ADDRESS);
		TRACE_ADDRESS(p_PAY_CHECK_STREET, p_PAY_CHECK_CITY, p_PAY_CHECK_STATE_CODE, p_PAY_CHECK_POSTAL_CODE, p_PAY_CHECK_COUNTRY_CODE);
	    LOGS.LOG_DEBUG('INVOICE TERMS=' || p_INVOICE_TERMS);
	    LOGS.LOG_DEBUG('DEBIT NAME=' || p_PAY_ELECTRONIC_DEBIT_NAME);
	    LOGS.LOG_DEBUG('DEBIT NBR=' || p_PAY_ELECTRONIC_DEBIT_NBR);
	    LOGS.LOG_DEBUG('CREDIT NAME=' || p_PAY_ELECTRONIC_CREDIT_NAME);
	    LOGS.LOG_DEBUG('CREDIT NBR=' || p_PAY_ELECTRONIC_CREDIT_NBR);
	END IF;

	EXCEPTION
	    WHEN OTHERS THEN
			p_STATUS := SQLCODE;
			p_MESSAGE := SQLERRM;

END GET_ENTITY_INVOICE_HEADER;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_ENTITY_INVOICE_HEADER
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_SUBLEDGER_NUM IN VARCHAR,
	p_BILLING_CONTACT IN VARCHAR,
    p_BILLING_STREET IN VARCHAR,
    p_BILLING_CITY IN VARCHAR,
    p_BILLING_STATE_CODE IN VARCHAR,
    p_BILLING_POSTAL_CODE IN VARCHAR,
    p_BILLING_COUNTRY_CODE IN VARCHAR,
	p_BILLING_PHONE IN VARCHAR,
	p_BILLING_FAX IN VARCHAR,
    p_INVOICE_TERMS IN VARCHAR,
    p_PAY_CHECK_CONTACT IN VARCHAR,
    p_PAY_CHECK_STREET IN VARCHAR,
    p_PAY_CHECK_CITY IN VARCHAR,
    p_PAY_CHECK_STATE_CODE IN VARCHAR,
    p_PAY_CHECK_POSTAL_CODE IN VARCHAR,
    p_PAY_CHECK_COUNTRY_CODE IN VARCHAR,
    p_PAY_ELECTRONIC_DEBIT_NAME IN VARCHAR,
    p_PAY_ELECTRONIC_DEBIT_NBR IN VARCHAR,
    p_PAY_ELECTRONIC_CREDIT_NAME IN VARCHAR,
    p_PAY_ELECTRONIC_CREDIT_NBR IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

v_DATE DATE := CONSTANTS.LOW_DATE;
v_ENTITY_TYPE VARCHAR(16);

BEGIN

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := NULL;

	v_ENTITY_TYPE := g_PSE;
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_PSE_INVOICE_HEADER, p_ENTITY_ID, EC.ED_PSE);

	RO.PUT_ENTITY_CONTACT(p_ENTITY_ID, v_ENTITY_TYPE, 'Billing', p_BILLING_CONTACT, p_BILLING_PHONE, g_HOME_PHONE, p_BILLING_FAX, g_CELL_PHONE, g_EMAIL_ADDRESS, g_STATUS);
	RO.PUT_ENTITY_ADDRESS(p_ENTITY_ID, v_ENTITY_TYPE, 'Billing', p_BILLING_STREET, NULL, p_BILLING_CITY, p_BILLING_STATE_CODE, p_BILLING_POSTAL_CODE, p_BILLING_COUNTRY_CODE, g_STATUS);
	RO.PUT_ENTITY_ATTRIBUTE('Invoice Terms', v_ENTITY_TYPE, g_STRING, p_ENTITY_ID, v_DATE, NULL, p_INVOICE_TERMS, g_STATUS);
	RO.PUT_ENTITY_ATTRIBUTE('Subledger Number', v_ENTITY_TYPE, g_STRING, p_ENTITY_ID, v_DATE, NULL, p_SUBLEDGER_NUM, g_STATUS);
	RO.PUT_ENTITY_CONTACT(p_ENTITY_ID, v_ENTITY_TYPE, 'Payment', p_PAY_CHECK_CONTACT, g_WORK_PHONE, g_HOME_PHONE, g_FAX_PHONE, g_CELL_PHONE, g_EMAIL_ADDRESS, g_STATUS);
	RO.PUT_ENTITY_ADDRESS(p_ENTITY_ID, v_ENTITY_TYPE, 'Payment', p_PAY_CHECK_STREET, NULL, p_PAY_CHECK_CITY, p_PAY_CHECK_STATE_CODE, p_PAY_CHECK_POSTAL_CODE, p_PAY_CHECK_COUNTRY_CODE, g_STATUS);
	RO.PUT_ENTITY_ATTRIBUTE('Debit Name', v_ENTITY_TYPE, g_STRING, p_ENTITY_ID, v_DATE, NULL, p_PAY_ELECTRONIC_DEBIT_NAME, g_STATUS);
	RO.PUT_ENTITY_ATTRIBUTE('Debit Number', v_ENTITY_TYPE, g_STRING, p_ENTITY_ID, v_DATE, NULL, p_PAY_ELECTRONIC_DEBIT_NBR, g_STATUS);
	RO.PUT_ENTITY_ATTRIBUTE('Credit Name', v_ENTITY_TYPE, g_STRING, p_ENTITY_ID, v_DATE, NULL, p_PAY_ELECTRONIC_CREDIT_NAME, g_STATUS);
	RO.PUT_ENTITY_ATTRIBUTE('Credit Number', v_ENTITY_TYPE, g_STRING, p_ENTITY_ID, v_DATE, NULL, p_PAY_ELECTRONIC_CREDIT_NBR, g_STATUS);

	EXCEPTION
	    WHEN OTHERS THEN
			p_STATUS := SQLCODE;
			p_MESSAGE := SQLERRM;

END PUT_ENTITY_INVOICE_HEADER;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_INVOICE_HEADER
	(
    p_PRIMARY_CONTACT OUT VARCHAR,
   	p_PRIMARY_PHONE OUT VARCHAR,
    p_SECONDARY_CONTACT OUT VARCHAR,
    p_SECONDARY_PHONE OUT VARCHAR,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

BEGIN

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := NULL;

    UT.GET_INCUMBENT_ENTITY(g_INCUMBENT_TYPE, g_INCUMBENT_NAME, g_INCUMBENT_ALIAS, g_INCUMBENT_ID);
	--UT.GET_INCUMBENT_ENTITY returns an ID of 0 when no incumbent entity exists, so contact info doesn't exist
	IF g_INCUMBENT_ID = 0 THEN
	    p_PRIMARY_CONTACT := GA.UNDEFINED_ATTRIBUTE;
		p_PRIMARY_PHONE := GA.UNDEFINED_ATTRIBUTE;
		p_SECONDARY_CONTACT := GA.UNDEFINED_ATTRIBUTE;
    	p_SECONDARY_PHONE := GA.UNDEFINED_ATTRIBUTE;
    ELSE
	    RO.GET_ENTITY_CONTACT(g_INCUMBENT_ID, g_INCUMBENT_TYPE, 'Invoice Primary', p_PRIMARY_CONTACT, g_CONTACT_ALIAS, p_PRIMARY_PHONE, g_HOME_PHONE, g_FAX_PHONE, g_CELL_PHONE, g_EMAIL_ADDRESS, g_STATUS);
	    RO.GET_ENTITY_CONTACT(g_INCUMBENT_ID, g_INCUMBENT_TYPE, 'Invoice Secondary', p_SECONDARY_CONTACT, g_CONTACT_ALIAS, p_SECONDARY_PHONE, g_HOME_PHONE, g_FAX_PHONE, g_CELL_PHONE, g_EMAIL_ADDRESS, g_STATUS);
	END IF;

	EXCEPTION
	    WHEN OTHERS THEN
			p_STATUS := SQLCODE;
			p_MESSAGE := SQLERRM;

END GET_INVOICE_HEADER;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_INVOICE_HEADER
	(
    p_PRIMARY_CONTACT IN VARCHAR,
   	p_PRIMARY_PHONE IN VARCHAR,
    p_SECONDARY_CONTACT IN VARCHAR,
    p_SECONDARY_PHONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

BEGIN

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := NULL;

    UT.GET_INCUMBENT_ENTITY(g_INCUMBENT_TYPE, g_INCUMBENT_NAME, g_INCUMBENT_ALIAS, g_INCUMBENT_ID);
	RO.PUT_ENTITY_CONTACT(g_INCUMBENT_ID, g_INCUMBENT_TYPE, 'Invoice Primary', p_PRIMARY_CONTACT, p_PRIMARY_PHONE, g_HOME_PHONE, g_FAX_PHONE, g_CELL_PHONE, g_EMAIL_ADDRESS, g_STATUS);
	RO.PUT_ENTITY_CONTACT(g_INCUMBENT_ID, g_INCUMBENT_TYPE, 'Invoice Secondary', p_SECONDARY_CONTACT, p_SECONDARY_PHONE, g_HOME_PHONE, g_FAX_PHONE, g_CELL_PHONE, g_EMAIL_ADDRESS, g_STATUS);

	EXCEPTION
	    WHEN OTHERS THEN
			p_STATUS := SQLCODE;
			p_MESSAGE := SQLERRM;

END PUT_INVOICE_HEADER;
---------------------------------------------------------------------------------------------------
PROCEDURE NEW_INVOICE
	(
	p_ENTITY_ID IN NUMBER,
	p_ENTITY_TYPE IN VARCHAR,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_INVOICE IN OUT INVOICE%ROWTYPE
	) AS
v_MESSAGE VARCHAR(128);
BEGIN

 	SELECT BID.NEXTVAL INTO p_INVOICE.INVOICE_ID FROM DUAL;
 	SELECT IID.NEXTVAL INTO p_INVOICE.INVOICE_NUMBER FROM DUAL;

	p_INVOICE.ENTITY_ID := p_ENTITY_ID;
	p_INVOICE.ENTITY_TYPE := UPPER(p_ENTITY_TYPE);
	p_INVOICE.STATEMENT_TYPE := p_STATEMENT_TYPE;
	p_INVOICE.STATEMENT_STATE := p_STATEMENT_STATE;
	p_INVOICE.BEGIN_DATE := p_BEGIN_DATE;
	p_INVOICE.END_DATE := p_END_DATE;
	p_INVOICE.AS_OF_DATE := p_AS_OF_DATE;
	p_INVOICE.INVOICE_DATE := SYSDATE;
	p_INVOICE.INVOICE_STATUS := 'Invoiced';

	GET_INVOICE_HEADER(p_INVOICE.INVOICE_PRIMARY_CONTACT, p_INVOICE.INVOICE_PRIMARY_PHONE,
		p_INVOICE.INVOICE_SECONDARY_CONTACT, p_INVOICE.INVOICE_SECONDARY_PHONE, g_STATUS, v_MESSAGE);

	GET_ENTITY_INVOICE_HEADER(g_SCHEDULING, GA.ELECTRIC_MODEL, p_ENTITY_ID, p_INVOICE.INVOICE_SUB_LEDGER_NUMBER, p_INVOICE.BILLING_CONTACT, p_INVOICE.BILLING_STREET,
		p_INVOICE.BILLING_CITY, p_INVOICE.BILLING_STATE_CODE, p_INVOICE.BILLING_POSTAL_CODE, p_INVOICE.BILLING_COUNTRY_CODE, p_INVOICE.BILLING_PHONE,
		p_INVOICE.BILLING_FAX, p_INVOICE.INVOICE_TERMS, p_INVOICE.PAY_CHECK_CONTACT, p_INVOICE.PAY_CHECK_STREET,
		p_INVOICE.PAY_CHECK_CITY, p_INVOICE.PAY_CHECK_STATE_CODE, p_INVOICE.PAY_CHECK_POSTAL_CODE, p_INVOICE.PAY_CHECK_COUNTRY_CODE,
		p_INVOICE.PAY_ELECTRONIC_DEBIT_NAME, p_INVOICE.PAY_ELECTRONIC_DEBIT_NBR, p_INVOICE.PAY_ELECTRONIC_CREDIT_NAME, p_INVOICE.PAY_ELECTRONIC_CREDIT_NBR,
		g_STATUS, v_MESSAGE);

END NEW_INVOICE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_INVOICE
	(
	p_ENTITY_ID IN NUMBER,
	p_ENTITY_TYPE IN VARCHAR,
	p_STATEMENT_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_INVOICE IN OUT INVOICE%ROWTYPE,
	p_CREATE_IF_NOT_FOUND BOOLEAN := TRUE
	) AS
BEGIN
	GET_INVOICE(p_ENTITY_ID,p_ENTITY_TYPE,p_STATEMENT_TYPE,GA.INTERNAL_STATE,p_BEGIN_DATE,p_END_DATE,p_AS_OF_DATE,p_INVOICE,p_CREATE_IF_NOT_FOUND);
END GET_INVOICE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_INVOICE
	(
	p_ENTITY_ID IN NUMBER,
	p_ENTITY_TYPE IN VARCHAR,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_INVOICE IN OUT INVOICE%ROWTYPE,
	p_CREATE_IF_NOT_FOUND BOOLEAN := TRUE
	) AS

BEGIN

	SELECT *
	INTO p_INVOICE
	FROM INVOICE
	WHERE ENTITY_ID = p_ENTITY_ID
		AND STATEMENT_TYPE = p_STATEMENT_TYPE
		AND STATEMENT_STATE = p_STATEMENT_STATE
		AND BEGIN_DATE = p_BEGIN_DATE
		AND AS_OF_DATE = p_AS_OF_DATE
		AND ENTITY_TYPE = UPPER(p_ENTITY_TYPE);

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		IF p_CREATE_IF_NOT_FOUND THEN
			NEW_INVOICE(p_ENTITY_ID, p_ENTITY_TYPE, p_STATEMENT_TYPE, p_STATEMENT_STATE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_INVOICE);
			PUT_INVOICE(p_INVOICE);
		ELSE
			p_INVOICE.INVOICE_ID := -1;
		END IF;

END GET_INVOICE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_INVOICE
	(
	p_ENTITY_ID IN NUMBER,
	p_ENTITY_TYPE IN VARCHAR,
	p_STATEMENT_TYPE IN NUMBER,
	p_INVOICE_MONTH IN DATE,
	p_AS_OF_DATE IN DATE,
	p_INVOICE IN OUT INVOICE%ROWTYPE
	) AS

BEGIN

	GET_INVOICE(p_ENTITY_ID, p_ENTITY_TYPE, p_STATEMENT_TYPE,
    			p_INVOICE_MONTH, LAST_DAY(p_INVOICE_MONTH),
                p_AS_OF_DATE, p_INVOICE);

END GET_INVOICE;
---------------------------------------------------------------------------------------------------
PROCEDURE GENERATE_INVOICE
	(
	p_ENTITY_ID IN NUMBER,
	p_ENTITY_TYPE IN VARCHAR,
	p_STATEMENT_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
    p_INVOICE_LINE_ITEM_OPTION IN VARCHAR2 := ''
	) AS
v_ENTITY_ID NUMBER(9) := -99999999;
v_INVOICE INVOICE%ROWTYPE;
v_INVOICE_LINE_ITEM INVOICE_LINE_ITEM%ROWTYPE;
v_NAME VARCHAR(128);
v_ITEMS PLS_INTEGER := 0;
v_ELASPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_INVOICE_SIGN NUMBER;
v_LINE_ITEM_OPTION VARCHAR2(32) := UPPER(p_INVOICE_LINE_ITEM_OPTION);
v_CATEGORY_PREF CHAR(1);
v_DEFAULT_DISPLAY VARCHAR2(32);

CURSOR c_BY_PRODUCT IS
	SELECT A.ENTITY_ID, A.PRODUCT_ID,
    	B.PRODUCT_NAME, B.PRODUCT_CATEGORY,
        SUM(A.CHARGE_AMOUNT) "CHARGE_AMOUNT", SUM(A.BILL_AMOUNT) "BILL_AMOUNT", SUM(A.CHARGE_QUANTITY) "CHARGE_QUANTITY"
	FROM BILLING_STATEMENT A, PRODUCT B, COMPONENT C
	WHERE (g_ALL = p_ENTITY_ID OR A.ENTITY_ID = ABS(p_ENTITY_ID))
		AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
		AND A.STATEMENT_STATE = GA.INTERNAL_STATE
		AND A.STATEMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND A.AS_OF_DATE = p_AS_OF_DATE
		AND B.PRODUCT_ID = A.PRODUCT_ID
        AND C.COMPONENT_ID = A.COMPONENT_ID
        AND NVL(C.EXCLUDE_FROM_INVOICE,0) = 0
	GROUP BY A.ENTITY_ID, A.PRODUCT_ID, B.PRODUCT_NAME, B.PRODUCT_CATEGORY
	ORDER BY ENTITY_ID;

CURSOR c_BY_COMPONENT IS
	SELECT A.ENTITY_ID, A.PRODUCT_ID, A.COMPONENT_ID,
    	B.PRODUCT_NAME, C.COMPONENT_NAME, DECODE(v_CATEGORY_PREF,'C',C.COMPONENT_CATEGORY,B.PRODUCT_CATEGORY) "INVOICE_CATEGORY",
        SUM(A.CHARGE_AMOUNT) "CHARGE_AMOUNT", SUM(A.BILL_AMOUNT) "BILL_AMOUNT", SUM(A.CHARGE_QUANTITY) "CHARGE_QUANTITY"
	FROM BILLING_STATEMENT A, PRODUCT B, COMPONENT C
	WHERE (g_ALL = p_ENTITY_ID OR A.ENTITY_ID = ABS(p_ENTITY_ID))
		AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
		AND A.STATEMENT_STATE = GA.INTERNAL_STATE
		AND A.STATEMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND A.AS_OF_DATE = p_AS_OF_DATE
		AND B.PRODUCT_ID = A.PRODUCT_ID
		AND C.COMPONENT_ID = A.COMPONENT_ID
        AND NVL(C.EXCLUDE_FROM_INVOICE,0) = 0
	GROUP BY A.ENTITY_ID, A.PRODUCT_ID, A.COMPONENT_ID, B.PRODUCT_NAME, C.COMPONENT_NAME, DECODE(v_CATEGORY_PREF,'C',C.COMPONENT_CATEGORY,B.PRODUCT_CATEGORY)
	ORDER BY ENTITY_ID;

CURSOR c_BY_COMPONENT_ONLY IS
	SELECT A.ENTITY_ID, A.COMPONENT_ID,
    	C.COMPONENT_NAME, C.COMPONENT_CATEGORY,
        SUM(A.CHARGE_AMOUNT) "CHARGE_AMOUNT", SUM(A.BILL_AMOUNT) "BILL_AMOUNT", SUM(A.CHARGE_QUANTITY) "CHARGE_QUANTITY"
	FROM BILLING_STATEMENT A, PRODUCT B, COMPONENT C
	WHERE (g_ALL = p_ENTITY_ID OR A.ENTITY_ID = ABS(p_ENTITY_ID))
		AND A.STATEMENT_TYPE = p_STATEMENT_TYPE
		AND A.STATEMENT_STATE = GA.INTERNAL_STATE
		AND A.STATEMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND A.AS_OF_DATE = p_AS_OF_DATE
		AND B.PRODUCT_ID = A.PRODUCT_ID
        AND C.COMPONENT_ID = A.COMPONENT_ID
        AND NVL(C.EXCLUDE_FROM_INVOICE,0) = 0
	GROUP BY A.ENTITY_ID, A.COMPONENT_ID, C.COMPONENT_NAME, C.COMPONENT_CATEGORY
	ORDER BY ENTITY_ID;

CURSOR c_BY_PRODUCT_COMPONENT_DETAIL IS
	SELECT B.ENTITY_ID, B.PRODUCT_ID, B.COMPONENT_ID, E.ACCOUNT_SERVICE_ID,
    	C.PRODUCT_NAME, D.COMPONENT_NAME, E.BILL_CODE, DECODE(v_CATEGORY_PREF,'C',D.COMPONENT_CATEGORY,C.PRODUCT_CATEGORY) "INVOICE_CATEGORY",
        SUM(E.CHARGE_AMOUNT) "CHARGE_AMOUNT", SUM(E.BILL_AMOUNT) "BILL_AMOUNT", SUM(E.CHARGE_QUANTITY) "CHARGE_QUANTITY"
	FROM BILL_PARTY A, BILLING_STATEMENT B, PRODUCT C, COMPONENT D, ACCOUNT_SERVICE_CHARGE E
	WHERE (g_ALL = p_ENTITY_ID OR A.BILL_PARTY_ID = ABS(p_ENTITY_ID))
		AND SUBSTR(A.BILL_PARTY_STATUS,1,1) = 'A'
		AND NVL(A.IS_INVOICE_DETAIL,0) = 1
		AND B.ENTITY_ID = A.BILL_PARTY_ID
		AND B.STATEMENT_TYPE = p_STATEMENT_TYPE
		AND B.STATEMENT_STATE = GA.INTERNAL_STATE
		AND B.STATEMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND B.AS_OF_DATE = p_AS_OF_DATE
		AND C.PRODUCT_ID = B.PRODUCT_ID
		AND D.COMPONENT_ID = B.COMPONENT_ID
        AND NVL(D.EXCLUDE_FROM_INVOICE,0) = 0
		AND E.CHARGE_ID = B.CHARGE_ID
	GROUP BY B.ENTITY_ID, B.PRODUCT_ID, B.COMPONENT_ID, E.ACCOUNT_SERVICE_ID, C.PRODUCT_NAME, D.COMPONENT_NAME, E.BILL_CODE, DECODE(v_CATEGORY_PREF,'C',D.COMPONENT_CATEGORY,C.PRODUCT_CATEGORY)
    UNION ALL
    SELECT B.ENTITY_ID, B.PRODUCT_ID, B.COMPONENT_ID, g_NOT_ASSIGNED,
    	C.PRODUCT_NAME, D.COMPONENT_NAME, 'B' "BILL_CODE", DECODE(v_CATEGORY_PREF,'C',D.COMPONENT_CATEGORY,C.PRODUCT_CATEGORY) "INVOICE_CATEGORY",
        SUM(B.CHARGE_AMOUNT) "CHARGE_AMOUNT", SUM(B.BILL_AMOUNT) "BILL_AMOUNT", SUM(B.CHARGE_QUANTITY) "CHARGE_QUANTITY"
	FROM BILL_PARTY A, BILLING_STATEMENT B, PRODUCT C, COMPONENT D
	WHERE (g_ALL = p_ENTITY_ID OR A.BILL_PARTY_ID = ABS(p_ENTITY_ID))
		AND SUBSTR(A.BILL_PARTY_STATUS,1,1) = 'A'
		AND NVL(A.IS_INVOICE_DETAIL,0) = 0
		AND B.ENTITY_ID = A.BILL_PARTY_ID
		AND B.STATEMENT_TYPE = p_STATEMENT_TYPE
		AND B.STATEMENT_STATE = GA.INTERNAL_STATE
		AND B.STATEMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND B.AS_OF_DATE = p_AS_OF_DATE
		AND C.PRODUCT_ID = B.PRODUCT_ID
		AND D.COMPONENT_ID = B.COMPONENT_ID
        AND NVL(D.EXCLUDE_FROM_INVOICE,0) = 0
	GROUP BY B.ENTITY_ID, B.PRODUCT_ID, B.COMPONENT_ID, g_NOT_ASSIGNED, C.PRODUCT_NAME, D.COMPONENT_NAME, DECODE(v_CATEGORY_PREF,'C',D.COMPONENT_CATEGORY,C.PRODUCT_CATEGORY)
	ORDER BY 1;

BEGIN
	SAVEPOINT BEFORE_GEN_INVOICE;

	-- generate the invoice for specified entity and invoice dates

	IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
		LOGS.LOG_DEBUG_DETAIL('GENERATE_INVOICE');
		LOGS.LOG_DEBUG_DETAIL('ENTITY_ID=' || TO_CHAR(p_ENTITY_ID));
		LOGS.LOG_DEBUG_DETAIL('ENTITY_TYPE=' || p_ENTITY_TYPE);
		LOGS.LOG_DEBUG_DETAIL('STATEMENT_TYPE=' || TO_CHAR(p_STATEMENT_TYPE));
		LOGS.LOG_DEBUG_DETAIL('BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE));
		LOGS.LOG_DEBUG_DETAIL('END_DATE=' || TO_CHAR(p_END_DATE));
		LOGS.LOG_DEBUG_DETAIL('AS_OF_DATE=' || TEXT_UTIL.TO_CHAR_TIME(p_AS_OF_DATE));
		LOGS.LOG_DEBUG_DETAIL('INVOICE_LINE_ITEM_OPTION=' || GA.INVOICE_LINE_ITEM_OPTION);
	END IF;

	v_BEGIN_DATE := TRUNC(p_BEGIN_DATE);
	v_END_DATE := TRUNC(p_END_DATE);

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
		LOGS.LOG_INFO_DETAIL('Generating Invoices (STATEMENT_TYPE=' || p_STATEMENT_TYPE || '; BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE,'MON YYYY') ||
	        		'; END_DATE=' || TO_CHAR(p_END_DATE,'MON YYYY') ||
					'; AS_OF_DATE=' || TO_CHAR(p_AS_OF_DATE,'MM/DD/YYYY HH24:MI')||')');
	END IF;

	DELETE INVOICE
	WHERE (g_ALL = p_ENTITY_ID OR ENTITY_ID = ABS(p_ENTITY_ID))
		AND STATEMENT_TYPE = p_STATEMENT_TYPE
		AND STATEMENT_STATE = GA.INTERNAL_STATE
		AND BEGIN_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
		AND AS_OF_DATE = p_AS_OF_DATE
		AND ENTITY_TYPE = UPPER(p_ENTITY_TYPE);

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
		LOGS.LOG_INFO_DETAIL('Deleted ' || SQL%ROWCOUNT || ' old row(s) from INVOICE');
	END IF;

	IF GA.ENABLE_REVERSE_SIGN_INVOICES THEN
		v_INVOICE_SIGN := -1;
	ELSE
		v_INVOICE_SIGN := 1;
	END IF;

	-- get category source preference (PRODUCT_CATEGORY vs. COMPONENT_CATEGORY) from
    -- system dictionary
    v_CATEGORY_PREF := UPPER(SUBSTR(MODEL_VALUE_AT_KEY(0,'Billing', 'Invoice', 'Category Preference',0),1,1));

    -- get default display amount from system dictionary
    v_DEFAULT_DISPLAY := UPPER(SUBSTR(MODEL_VALUE_AT_KEY(0,'Billing', 'Invoice', 'Default Display Amount',0),1,6));
    IF NVL(v_DEFAULT_DISPLAY,' ') <> 'CHARGE' AND NVL(v_DEFAULT_DISPLAY,' ') <> 'BILL' THEN
    	v_DEFAULT_DISPLAY := 'CHARGE';
    END IF;

    -- if parameter is null, use GA switch - otherwise, decode the option text
    IF v_LINE_ITEM_OPTION IS NULL THEN
        SELECT DECODE(GA.INVOICE_LINE_ITEM_OPTION,'1','BY PRODUCT','2','BY PRODUCT-COMPONENT',
        			'3','BY ACCOUNT SERVICE','4','BY COMPONENT',
                    'X','EXTERNAL','BY PRODUCT-COMPONENT')
		INTO v_LINE_ITEM_OPTION
        FROM DUAL;
    END IF;

	IF v_LINE_ITEM_OPTION = 'BY PRODUCT' THEN
		FOR v_BY_PRODUCT IN c_BY_PRODUCT LOOP
			IF NOT v_BY_PRODUCT.ENTITY_ID = v_ENTITY_ID THEN
				SAVEPOINT BEFORE_GEN_INVOICE; -- new entity? redefine savepoint
			    GET_INVOICE(v_BY_PRODUCT.ENTITY_ID, p_ENTITY_TYPE, p_STATEMENT_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, v_INVOICE);
			END IF;
			v_INVOICE_LINE_ITEM.INVOICE_ID := v_INVOICE.INVOICE_ID;
			v_INVOICE_LINE_ITEM.LINE_ITEM_NAME := v_BY_PRODUCT.PRODUCT_NAME;
            v_INVOICE_LINE_ITEM.LINE_ITEM_CATEGORY := v_BY_PRODUCT.PRODUCT_CATEGORY;
			v_INVOICE_LINE_ITEM.PRODUCT_ID := v_BY_PRODUCT.PRODUCT_ID;
			v_INVOICE_LINE_ITEM.COMPONENT_ID := g_NOT_ASSIGNED;
			v_INVOICE_LINE_ITEM.ACCOUNT_SERVICE_ID := g_NOT_ASSIGNED;
			v_INVOICE_LINE_ITEM.OTHER_ID := g_NOT_ASSIGNED;
			v_INVOICE_LINE_ITEM.OTHER_DATA := NULL;
			v_INVOICE_LINE_ITEM.LINE_ITEM_QUANTITY := v_BY_PRODUCT.CHARGE_QUANTITY * v_INVOICE_SIGN;
			v_INVOICE_LINE_ITEM.LINE_ITEM_AMOUNT := v_BY_PRODUCT.CHARGE_AMOUNT * v_INVOICE_SIGN;
			v_INVOICE_LINE_ITEM.LINE_ITEM_BILL_AMOUNT := v_BY_PRODUCT.BILL_AMOUNT * v_INVOICE_SIGN;
            v_INVOICE_LINE_ITEM.DEFAULT_DISPLAY := v_DEFAULT_DISPLAY;
			v_INVOICE_LINE_ITEM.STATEMENT_TYPE := v_INVOICE.STATEMENT_TYPE;
			v_INVOICE_LINE_ITEM.BEGIN_DATE := v_INVOICE.BEGIN_DATE;
			v_INVOICE_LINE_ITEM.END_DATE := v_INVOICE.END_DATE;
            v_INVOICE_LINE_ITEM.LINE_ITEM_OPTION := v_LINE_ITEM_OPTION;
			PUT_INVOICE_LINE_ITEM(v_INVOICE_LINE_ITEM);
			v_ENTITY_ID := v_BY_PRODUCT.ENTITY_ID;
			v_ITEMS := v_ITEMS + 1;
		END LOOP;
	ELSIF v_LINE_ITEM_OPTION = 'BY PRODUCT-COMPONENT' THEN
		FOR v_BY_COMPONENT IN c_BY_COMPONENT LOOP
			IF NOT v_BY_COMPONENT.ENTITY_ID = v_ENTITY_ID THEN
				SAVEPOINT BEFORE_GEN_INVOICE; -- new entity? redefine savepoint
			    GET_INVOICE(v_BY_COMPONENT.ENTITY_ID, p_ENTITY_TYPE, p_STATEMENT_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, v_INVOICE);
			END IF;
			v_INVOICE_LINE_ITEM.INVOICE_ID := v_INVOICE.INVOICE_ID;
			v_INVOICE_LINE_ITEM.LINE_ITEM_NAME := v_BY_COMPONENT.PRODUCT_NAME || ' - ' || v_BY_COMPONENT.COMPONENT_NAME;
            v_INVOICE_LINE_ITEM.LINE_ITEM_CATEGORY := v_BY_COMPONENT.INVOICE_CATEGORY;
			v_INVOICE_LINE_ITEM.PRODUCT_ID := v_BY_COMPONENT.PRODUCT_ID;
			v_INVOICE_LINE_ITEM.COMPONENT_ID := v_BY_COMPONENT.COMPONENT_ID;
			v_INVOICE_LINE_ITEM.ACCOUNT_SERVICE_ID := g_NOT_ASSIGNED;
			v_INVOICE_LINE_ITEM.OTHER_ID := g_NOT_ASSIGNED;
			v_INVOICE_LINE_ITEM.OTHER_DATA := NULL;
			v_INVOICE_LINE_ITEM.LINE_ITEM_QUANTITY := v_BY_COMPONENT.CHARGE_QUANTITY * v_INVOICE_SIGN;
			v_INVOICE_LINE_ITEM.LINE_ITEM_AMOUNT := v_BY_COMPONENT.CHARGE_AMOUNT * v_INVOICE_SIGN;
			v_INVOICE_LINE_ITEM.LINE_ITEM_BILL_AMOUNT := v_BY_COMPONENT.BILL_AMOUNT * v_INVOICE_SIGN;
            v_INVOICE_LINE_ITEM.DEFAULT_DISPLAY := v_DEFAULT_DISPLAY;
			v_INVOICE_LINE_ITEM.STATEMENT_TYPE := v_INVOICE.STATEMENT_TYPE;
			v_INVOICE_LINE_ITEM.BEGIN_DATE := v_INVOICE.BEGIN_DATE;
			v_INVOICE_LINE_ITEM.END_DATE := v_INVOICE.END_DATE;
            v_INVOICE_LINE_ITEM.LINE_ITEM_OPTION := v_LINE_ITEM_OPTION;
			PUT_INVOICE_LINE_ITEM(v_INVOICE_LINE_ITEM);
			v_ENTITY_ID := v_BY_COMPONENT.ENTITY_ID;
			v_ITEMS := v_ITEMS + 1;
		END LOOP;
	ELSIF v_LINE_ITEM_OPTION = 'BY ACCOUNT SERVICE' THEN
		FOR v_BY_PRODUCT_COMPONENT_DETAIL IN c_BY_PRODUCT_COMPONENT_DETAIL LOOP
			IF NOT v_BY_PRODUCT_COMPONENT_DETAIL.ENTITY_ID = v_ENTITY_ID THEN
				SAVEPOINT BEFORE_GEN_INVOICE; -- new entity? redefine savepoint
			    GET_INVOICE(v_BY_PRODUCT_COMPONENT_DETAIL.ENTITY_ID, p_ENTITY_TYPE, p_STATEMENT_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, v_INVOICE);
			END IF;
			v_NAME := v_BY_PRODUCT_COMPONENT_DETAIL.PRODUCT_NAME || ' - ' || v_BY_PRODUCT_COMPONENT_DETAIL.COMPONENT_NAME;
			IF NOT v_BY_PRODUCT_COMPONENT_DETAIL.ACCOUNT_SERVICE_ID = g_NOT_ASSIGNED THEN
				v_NAME := GET_ACCOUNT_SERVICE_NAME(v_BY_PRODUCT_COMPONENT_DETAIL.ACCOUNT_SERVICE_ID) || ' - ' || v_NAME;
			END IF;
			IF v_BY_PRODUCT_COMPONENT_DETAIL.BILL_CODE = 'C' THEN
				v_NAME := v_NAME || ' (Cancel)';
			ELSIF v_BY_PRODUCT_COMPONENT_DETAIL.BILL_CODE = 'R' THEN
				v_NAME := v_NAME || ' (Rebill)';
			END IF;
			v_INVOICE_LINE_ITEM.INVOICE_ID := v_INVOICE.INVOICE_ID;
			v_INVOICE_LINE_ITEM.LINE_ITEM_NAME := v_NAME;
            v_INVOICE_LINE_ITEM.LINE_ITEM_CATEGORY := v_BY_PRODUCT_COMPONENT_DETAIL.INVOICE_CATEGORY;
			v_INVOICE_LINE_ITEM.PRODUCT_ID := v_BY_PRODUCT_COMPONENT_DETAIL.PRODUCT_ID;
			v_INVOICE_LINE_ITEM.COMPONENT_ID := v_BY_PRODUCT_COMPONENT_DETAIL.COMPONENT_ID;
			v_INVOICE_LINE_ITEM.ACCOUNT_SERVICE_ID := v_BY_PRODUCT_COMPONENT_DETAIL.ACCOUNT_SERVICE_ID;
			v_INVOICE_LINE_ITEM.OTHER_ID := g_NOT_ASSIGNED;
			v_INVOICE_LINE_ITEM.OTHER_DATA := NULL;
			v_INVOICE_LINE_ITEM.LINE_ITEM_QUANTITY := v_BY_PRODUCT_COMPONENT_DETAIL.CHARGE_QUANTITY * v_INVOICE_SIGN;
			v_INVOICE_LINE_ITEM.LINE_ITEM_AMOUNT := v_BY_PRODUCT_COMPONENT_DETAIL.CHARGE_AMOUNT * v_INVOICE_SIGN;
			v_INVOICE_LINE_ITEM.LINE_ITEM_BILL_AMOUNT := v_BY_PRODUCT_COMPONENT_DETAIL.BILL_AMOUNT * v_INVOICE_SIGN;
			v_INVOICE_LINE_ITEM.LINE_ITEM_RATE := v_BY_PRODUCT_COMPONENT_DETAIL.BILL_AMOUNT;
            v_INVOICE_LINE_ITEM.DEFAULT_DISPLAY := v_DEFAULT_DISPLAY;
			v_INVOICE_LINE_ITEM.STATEMENT_TYPE := v_INVOICE.STATEMENT_TYPE;
			v_INVOICE_LINE_ITEM.BEGIN_DATE := v_INVOICE.BEGIN_DATE;
			v_INVOICE_LINE_ITEM.END_DATE := v_INVOICE.END_DATE;
            v_INVOICE_LINE_ITEM.LINE_ITEM_OPTION := v_LINE_ITEM_OPTION;
			PUT_INVOICE_LINE_ITEM(v_INVOICE_LINE_ITEM);
			v_ENTITY_ID := v_BY_PRODUCT_COMPONENT_DETAIL.ENTITY_ID;
			v_ITEMS := v_ITEMS + 1;
		END LOOP;
	ELSIF v_LINE_ITEM_OPTION = 'BY COMPONENT' THEN
		FOR v_BY_COMPONENT_ONLY IN c_BY_COMPONENT_ONLY LOOP
			IF NOT v_BY_COMPONENT_ONLY.ENTITY_ID = v_ENTITY_ID THEN
				SAVEPOINT BEFORE_GEN_INVOICE; -- new entity? redefine savepoint
			    GET_INVOICE(v_BY_COMPONENT_ONLY.ENTITY_ID, p_ENTITY_TYPE, p_STATEMENT_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, v_INVOICE);
			END IF;
			v_INVOICE_LINE_ITEM.INVOICE_ID := v_INVOICE.INVOICE_ID;
			v_INVOICE_LINE_ITEM.LINE_ITEM_NAME := v_BY_COMPONENT_ONLY.COMPONENT_NAME;
            v_INVOICE_LINE_ITEM.LINE_ITEM_CATEGORY := v_BY_COMPONENT_ONLY.COMPONENT_CATEGORY;
			v_INVOICE_LINE_ITEM.PRODUCT_ID := g_NOT_ASSIGNED;
			v_INVOICE_LINE_ITEM.COMPONENT_ID := v_BY_COMPONENT_ONLY.COMPONENT_ID;
			v_INVOICE_LINE_ITEM.ACCOUNT_SERVICE_ID := g_NOT_ASSIGNED;
			v_INVOICE_LINE_ITEM.OTHER_ID := g_NOT_ASSIGNED;
			v_INVOICE_LINE_ITEM.OTHER_DATA := NULL;
			v_INVOICE_LINE_ITEM.LINE_ITEM_QUANTITY := v_BY_COMPONENT_ONLY.CHARGE_QUANTITY * v_INVOICE_SIGN;
			v_INVOICE_LINE_ITEM.LINE_ITEM_AMOUNT := v_BY_COMPONENT_ONLY.CHARGE_AMOUNT * v_INVOICE_SIGN;
			v_INVOICE_LINE_ITEM.LINE_ITEM_BILL_AMOUNT := v_BY_COMPONENT_ONLY.BILL_AMOUNT * v_INVOICE_SIGN;
            v_INVOICE_LINE_ITEM.DEFAULT_DISPLAY := v_DEFAULT_DISPLAY;
			v_INVOICE_LINE_ITEM.STATEMENT_TYPE := v_INVOICE.STATEMENT_TYPE;
			v_INVOICE_LINE_ITEM.BEGIN_DATE := v_INVOICE.BEGIN_DATE;
			v_INVOICE_LINE_ITEM.END_DATE := v_INVOICE.END_DATE;
            v_INVOICE_LINE_ITEM.LINE_ITEM_OPTION := v_LINE_ITEM_OPTION;
			PUT_INVOICE_LINE_ITEM(v_INVOICE_LINE_ITEM);
			v_ENTITY_ID := v_BY_COMPONENT_ONLY.ENTITY_ID;
			v_ITEMS := v_ITEMS + 1;
		END LOOP;
	ELSE  -- Other values of v_LINE_ITEM_OPTION are assumed to be external roll-up types
		DECLARE
			v_STATUS NUMBER;
			v_CURSOR GA.REFCURSOR;
			v_LINE_ITEM_NAME INVOICE_LINE_ITEM.LINE_ITEM_NAME%TYPE;
			v_LINE_ITEM_CATEGORY INVOICE_LINE_ITEM.LINE_ITEM_CATEGORY%TYPE;
			v_PRODUCT_ID NUMBER; v_COMPONENT_ID NUMBER; v_ACCOUNT_SERVICE_ID NUMBER;
			v_LINE_ITEM_QUANTITY NUMBER; v_LINE_ITEM_RATE NUMBER;
			v_LINE_ITEM_AMOUNT NUMBER; v_LINE_ITEM_BILL_AMOUNT NUMBER;
            v_LI_DEFAULT_DISPLAY VARCHAR2(6); v_LI_STATEMENT_TYPE NUMBER;
            v_LI_BEGIN_DATE DATE; v_LI_END_DATE DATE;
			v_LINE_ITEM_ENTITY_ID NUMBER;
            v_OTHER_ID NUMBER; v_OTHER_DATA VARCHAR2(128);
		BEGIN
			XS.GET_INVOICE_LINE_ITEMS(p_ENTITY_ID,p_ENTITY_TYPE,p_STATEMENT_TYPE,p_BEGIN_DATE,p_END_DATE,v_LINE_ITEM_OPTION,p_AS_OF_DATE,v_STATUS,v_CURSOR);
			IF v_STATUS = 0 THEN
				LOOP
					FETCH v_CURSOR INTO
                    	v_LINE_ITEM_ENTITY_ID,v_PRODUCT_ID,v_COMPONENT_ID,v_ACCOUNT_SERVICE_ID,
                        v_OTHER_ID,v_OTHER_DATA,
                        v_LINE_ITEM_NAME,v_LINE_ITEM_CATEGORY,
                        v_LINE_ITEM_QUANTITY,v_LINE_ITEM_RATE,v_LINE_ITEM_AMOUNT,v_LINE_ITEM_BILL_AMOUNT,
                        v_LI_DEFAULT_DISPLAY, v_LI_STATEMENT_TYPE, v_LI_BEGIN_DATE, v_LI_END_DATE;
					EXIT WHEN v_CURSOR%NOTFOUND;
					IF NOT v_LINE_ITEM_ENTITY_ID = v_ENTITY_ID THEN
						SAVEPOINT BEFORE_GEN_INVOICE; -- new entity? redefine savepoint
					    GET_INVOICE(v_LINE_ITEM_ENTITY_ID, p_ENTITY_TYPE, p_STATEMENT_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, v_INVOICE);
					END IF;
					v_INVOICE_LINE_ITEM.INVOICE_ID := v_INVOICE.INVOICE_ID;
					v_INVOICE_LINE_ITEM.LINE_ITEM_NAME := v_LINE_ITEM_NAME;
                    v_INVOICE_LINE_ITEM.LINE_ITEM_CATEGORY := v_LINE_ITEM_CATEGORY;
					v_INVOICE_LINE_ITEM.PRODUCT_ID := v_PRODUCT_ID;
					v_INVOICE_LINE_ITEM.COMPONENT_ID := v_COMPONENT_ID;
					v_INVOICE_LINE_ITEM.ACCOUNT_SERVICE_ID := v_ACCOUNT_SERVICE_ID;
                    v_INVOICE_LINE_ITEM.OTHER_ID := v_OTHER_ID;
                    v_INVOICE_LINE_ITEM.OTHER_DATA := v_OTHER_DATA;
					v_INVOICE_LINE_ITEM.LINE_ITEM_QUANTITY := v_LINE_ITEM_QUANTITY * v_INVOICE_SIGN;
					v_INVOICE_LINE_ITEM.LINE_ITEM_RATE := v_LINE_ITEM_RATE;
					v_INVOICE_LINE_ITEM.LINE_ITEM_AMOUNT := v_LINE_ITEM_AMOUNT * v_INVOICE_SIGN;
					v_INVOICE_LINE_ITEM.LINE_ITEM_BILL_AMOUNT := v_LINE_ITEM_BILL_AMOUNT * v_INVOICE_SIGN;
                    IF v_LI_DEFAULT_DISPLAY IS NULL THEN
                    	v_INVOICE_LINE_ITEM.DEFAULT_DISPLAY := v_DEFAULT_DISPLAY;
                    ELSE
                    	v_INVOICE_LINE_ITEM.DEFAULT_DISPLAY := v_LI_DEFAULT_DISPLAY;
                    END IF;
                    IF v_LI_STATEMENT_TYPE IS NULL THEN
                    	v_INVOICE_LINE_ITEM.STATEMENT_TYPE := v_INVOICE.STATEMENT_TYPE;
                    ELSE
                    	v_INVOICE_LINE_ITEM.STATEMENT_TYPE := v_LI_STATEMENT_TYPE;
                    END IF;
                    IF v_LI_BEGIN_DATE IS NULL THEN
                    	v_INVOICE_LINE_ITEM.BEGIN_DATE := v_INVOICE.BEGIN_DATE;
                    ELSE
                    	v_INVOICE_LINE_ITEM.BEGIN_DATE := v_LI_BEGIN_DATE;
                    END IF;
                    IF v_LI_END_DATE IS NULL THEN
                    	v_INVOICE_LINE_ITEM.END_DATE := v_INVOICE.END_DATE;
                    ELSE
                    	v_INVOICE_LINE_ITEM.END_DATE := v_LI_END_DATE;
                    END IF;
		            v_INVOICE_LINE_ITEM.LINE_ITEM_OPTION := v_LINE_ITEM_OPTION;
					PUT_INVOICE_LINE_ITEM(v_INVOICE_LINE_ITEM);
					v_ENTITY_ID := v_ENTITY_ID;
					v_ITEMS := v_ITEMS + 1;
				END LOOP;
				CLOSE v_CURSOR;
			END IF;
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE('Exception while processing custom/external invoice items', p_SAVEPOINT_NAME => 'BEFORE_GEN_INVOICE');
		END;
	END IF;

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
		LOGS.LOG_INFO_DETAIL('Invoices Successfully Generated');
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('GENERATE_INVOICE TIME= ' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELASPSED) || ', LINE ITEM COUNT=' || TO_CHAR(v_ITEMS));
	END IF;

END GENERATE_INVOICE;
---------------------------------------------------------------------------------------------------
PROCEDURE GENERATE_INVOICES
	(
	p_ENTITY_IDS IN NUMBER_COLLECTION,
	p_ENTITY_TYPE IN VARCHAR,
	p_STATEMENT_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE
	) AS
CURSOR c_PSEs IS
	SELECT PSE_ID,
    	NVL(INVOICE_INTERVAL,'Month') "INVOICE_INTERVAL",
        NVL(INVOICE_LINE_ITEM_OPTION,'By Product-Component') "INVOICE_LINE_ITEM_OPTION",
    	NVL(WEEK_BEGIN,'First of Month') "WEEK_BEGIN"
	FROM PURCHASING_SELLING_ENTITY A,
		TABLE(CAST(p_ENTITY_IDs AS NUMBER_COLLECTION)) B
    WHERE (B.COLUMN_VALUE = SD.g_ALL_DATA_ENTITY_ID OR A.PSE_ID = B.COLUMN_VALUE)
		AND IS_BILLING_ENTITY = 1;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_END_LOOP_DATE DATE;
BEGIN
	-- generate one or more invoices for specified billing entity(ies) and
	-- specified invoice date(s)

    -- PSE billing - determine invoice interval and then compute appropriate
    -- invoices
    FOR v_PSE IN c_PSEs LOOP
        v_BEGIN_DATE := BEGIN_DATE_FOR_INTERVAL(p_BEGIN_DATE, v_PSE.INVOICE_INTERVAL, v_PSE.PSE_ID, v_PSE.WEEK_BEGIN);
        v_END_LOOP_DATE := TRUNC(p_END_DATE);
        WHILE v_BEGIN_DATE <= v_END_LOOP_DATE LOOP
            v_END_DATE := END_DATE_FOR_INTERVAL(v_BEGIN_DATE, v_PSE.INVOICE_INTERVAL, v_PSE.PSE_ID, v_PSE.WEEK_BEGIN);
            -- if end date less than begin date, it is because a Custom interval was
            -- specified, but no interval data for given day - so skip it in that case
            IF v_END_DATE >= v_BEGIN_DATE THEN
                GENERATE_INVOICE (v_PSE.PSE_ID, p_ENTITY_TYPE, p_STATEMENT_TYPE,
                v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, v_PSE.INVOICE_LINE_ITEM_OPTION);
            END IF;
            v_BEGIN_DATE := v_END_DATE + 1;
        END LOOP;
    END LOOP;
END GENERATE_INVOICES;
----------------------------------------------------------------------------------------------------
PROCEDURE APPLY_IMBALANCE_CHARGE_BAND
	(
	p_CHARGE_FLAG IN VARCHAR2,
	p_IMBALANCE_SIGN IN NUMBER,
    p_IMBALANCE_TYPE IN VARCHAR2,
	p_COMPONENT_IMBALANCE IN COMPONENT_IMBALANCE%ROWTYPE,
	p_ENERGY_IMBALANCE_RATE IN NUMBER,
	p_IMBALANCE_CHARGE IN IMBALANCE_CHARGE%ROWTYPE,
	p_COMPONENT_BAND_TABLE IN COMPONENT_BAND_TABLE
	) AS

v_MINIMUM NUMBER := 0;
v_THRESHOLD NUMBER := 0;
v_BAND_NUMBER NUMBER := 1;
v_IMBALANCE NUMBER := 0;
v_CHARGE NUMBER := 0;
v_QUANTITY NUMBER := 0;
v_MULTIPLIER NUMBER := 1;
v_IS_PRORATE BOOLEAN;
v_INDEX BINARY_INTEGER;
v_IMBALANCE_CHARGE_BAND IMBALANCE_CHARGE_BAND%ROWTYPE;
v_PRIOR_CHARGE_ID NUMBER;
v_APPLY_BAND_CHARGE BOOLEAN := UPPER(p_IMBALANCE_TYPE) = 'PENALTY';
v_APPLY_ENERGY_IMBALANCE_RATE BOOLEAN := UPPER(p_IMBALANCE_TYPE) = 'CASH OUT';

BEGIN

	v_IMBALANCE_CHARGE_BAND.CHARGE_ID := p_IMBALANCE_CHARGE.CHARGE_ID;
	v_IMBALANCE_CHARGE_BAND.CHARGE_DATE := p_IMBALANCE_CHARGE.CHARGE_DATE;
	v_IMBALANCE := ROUND(ABS(p_IMBALANCE_CHARGE.SUPPLY -  p_IMBALANCE_CHARGE.DEMAND),3);
	v_IS_PRORATE := NVL(p_COMPONENT_IMBALANCE.IS_PRORATE, 0) = 1;
	v_PRIOR_CHARGE_ID := GET_PRIOR_CHARGE_ID(p_IMBALANCE_CHARGE.CHARGE_ID);

	IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
		LOGS.LOG_DEBUG_DETAIL('<band>,<imbalance>,<min>,<threshold>,<quantity>,<rate>,<multiplier>,<amt>(<id>)@<hour>');
	END IF;

	IF p_COMPONENT_BAND_TABLE.COUNT > 0 THEN
		v_INDEX := p_COMPONENT_BAND_TABLE.FIRST;
		WHILE v_INDEX <= p_COMPONENT_BAND_TABLE.LAST LOOP

			v_MINIMUM := p_COMPONENT_BAND_TABLE(v_INDEX).BAND_MINIMUM;
			IF p_COMPONENT_IMBALANCE.IS_PERCENT = 1 THEN
			  IF UPPER(SUBSTR(p_IMBALANCE_TYPE,1,1)) IN ('N','S','P','C') THEN
				 v_MINIMUM := p_IMBALANCE_CHARGE.SUPPLY * (v_MINIMUM / 100.0);
			  ELSE
				 v_MINIMUM := p_IMBALANCE_CHARGE.DEMAND * (v_MINIMUM / 100.0);
		      END IF;
			END IF;

			IF v_IMBALANCE > v_MINIMUM THEN

				v_CHARGE := NVL(p_COMPONENT_BAND_TABLE(v_INDEX).BAND_CHARGE, 0);
				v_THRESHOLD := ABS(p_COMPONENT_BAND_TABLE(v_INDEX).BAND_THRESHOLD);

				IF p_COMPONENT_IMBALANCE.IS_PERCENT = 1 THEN
				   -- 0 THRESHOLD MEANS RESIDUAL - EVERYTHING THAT'S LEFT --
				   IF v_THRESHOLD = 0 THEN
				      v_THRESHOLD := v_IMBALANCE;
				   ELSE
					  IF UPPER(SUBSTR(p_IMBALANCE_TYPE,1,1)) IN ('N','S','P','C') THEN
						 v_THRESHOLD := p_IMBALANCE_CHARGE.SUPPLY * (v_THRESHOLD / 100.0);
					  ELSE
						 v_THRESHOLD := p_IMBALANCE_CHARGE.DEMAND * (v_THRESHOLD / 100.0);
					  END IF;
				   END IF;
				END IF;

				v_QUANTITY := LEAST(v_IMBALANCE, v_THRESHOLD);

				IF v_INDEX = p_COMPONENT_BAND_TABLE.LAST AND v_THRESHOLD = 0 THEN
					v_QUANTITY := v_IMBALANCE;
				END IF;

				v_MULTIPLIER := p_COMPONENT_BAND_TABLE(v_INDEX).BAND_MULTIPLIER;
				v_IMBALANCE_CHARGE_BAND.BAND_NUMBER := v_BAND_NUMBER;
				v_IMBALANCE_CHARGE_BAND.ENERGY_IMBALANCE_QUANTITY := v_QUANTITY;
				v_IMBALANCE_CHARGE_BAND.ENERGY_IMBALANCE_RATE := p_ENERGY_IMBALANCE_RATE;
				IF v_CHARGE > p_ENERGY_IMBALANCE_RATE * v_MULTIPLIER OR v_APPLY_BAND_CHARGE THEN
					v_IMBALANCE_CHARGE_BAND.ENERGY_IMBALANCE_RATE := v_CHARGE;
				END IF;
				IF v_APPLY_BAND_CHARGE THEN
					v_IMBALANCE_CHARGE_BAND.ENERGY_IMBALANCE_AMOUNT := v_QUANTITY * (v_MULTIPLIER * v_CHARGE) * p_IMBALANCE_SIGN;
				ELSE
					IF p_IMBALANCE_CHARGE.BILL_NET_SYSTEM_IMBALANCE = -99999 OR v_APPLY_ENERGY_IMBALANCE_RATE THEN
						v_IMBALANCE_CHARGE_BAND.ENERGY_IMBALANCE_AMOUNT := v_QUANTITY * GREATEST(p_ENERGY_IMBALANCE_RATE * ABS(v_MULTIPLIER), v_CHARGE) * SIGN(v_MULTIPLIER) * p_IMBALANCE_SIGN;
					ELSE
						v_IMBALANCE_CHARGE_BAND.ENERGY_IMBALANCE_AMOUNT := 0;
					END IF;
				END IF;

				IF v_IS_PRORATE OR (NOT v_IS_PRORATE AND v_QUANTITY = v_IMBALANCE) THEN
					PRIOR_IMBALANCE_CHARGE_BAND(v_PRIOR_CHARGE_ID, v_IMBALANCE_CHARGE_BAND);
					IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
					    LOGS.LOG_DEBUG_DETAIL(p_CHARGE_FLAG || ':' ||
						    TO_CHAR(v_BAND_NUMBER) || ',' ||
							TO_CHAR(v_IMBALANCE) || ',' ||
							TO_CHAR(v_MINIMUM) || ',' ||
							TO_CHAR(v_THRESHOLD) || ',' ||
							TO_CHAR(v_QUANTITY) || ',' ||
							TO_CHAR(v_IMBALANCE_CHARGE_BAND.ENERGY_IMBALANCE_RATE ) || ',' ||
							TO_CHAR(v_MULTIPLIER) || ',' ||
							TO_CHAR(v_IMBALANCE_CHARGE_BAND.ENERGY_IMBALANCE_AMOUNT ) || '(' ||
							TO_CHAR(p_IMBALANCE_CHARGE.CHARGE_ID) || ')@' ||
							TO_CHAR(p_IMBALANCE_CHARGE.CHARGE_DATE, 'HH24'));
					END IF;
					PUT_IMBALANCE_CHARGE_BAND(v_IMBALANCE_CHARGE_BAND);
					IF (NOT v_IS_PRORATE AND v_QUANTITY = v_IMBALANCE) THEN
						EXIT;
					END IF;
				END IF;
			END IF;

			v_INDEX := p_COMPONENT_BAND_TABLE.NEXT(v_INDEX);
			v_BAND_NUMBER := v_BAND_NUMBER + 1;
			IF v_IS_PRORATE THEN
			    v_IMBALANCE := GREATEST(v_IMBALANCE - v_QUANTITY, 0);
			END IF;
		END LOOP;
	END IF;

END APPLY_IMBALANCE_CHARGE_BAND;
---------------------------------------------------------------------------------------------------
PROCEDURE APPLY_IMBALANCE_CHARGE_BAND
	(
	p_CHARGE_FLAG IN VARCHAR,
	p_IMBALANCE_SIGN IN NUMBER,
    p_IMBALANCE_TYPE IN VARCHAR2,
	p_COMPONENT_IMBALANCE IN COMPONENT_IMBALANCE%ROWTYPE,
	p_ENERGY_IMBALANCE_RATE IN NUMBER,
	p_IMBALANCE_CHARGE IN IMBALANCE_CHARGE%ROWTYPE,
	p_COMPONENT_BAND_TABLE IN COMPONENT_BAND_TABLE,
	p_NET_RETAIL_IMBALANCE IN BOOLEAN
	) AS

v_MINIMUM NUMBER := 0;
v_THRESHOLD NUMBER := 0;
v_BAND_NUMBER NUMBER := 1;
v_IMBALANCE NUMBER := 0;
v_MINIMUM_CHARGE_RATE NUMBER := 0;
v_QUANTITY NUMBER := 0;
v_MULTIPLIER NUMBER := 1;
v_IS_PRORATE BOOLEAN;
v_INDEX BINARY_INTEGER;
v_IMBALANCE_CHARGE_BAND IMBALANCE_CHARGE_BAND%ROWTYPE;
v_PRIOR_CHARGE_ID NUMBER;

BEGIN

	v_IMBALANCE_CHARGE_BAND.CHARGE_ID := p_IMBALANCE_CHARGE.CHARGE_ID;
	v_IMBALANCE_CHARGE_BAND.CHARGE_DATE := p_IMBALANCE_CHARGE.CHARGE_DATE;
	v_IMBALANCE := ROUND(ABS(p_IMBALANCE_CHARGE.SUPPLY -  p_IMBALANCE_CHARGE.DEMAND),3);
	v_IS_PRORATE := NVL(p_COMPONENT_IMBALANCE.IS_PRORATE, 0) = 1;
	v_PRIOR_CHARGE_ID := GET_PRIOR_CHARGE_ID(p_IMBALANCE_CHARGE.CHARGE_ID);

	IF p_COMPONENT_BAND_TABLE.COUNT > 0 THEN
		v_INDEX := p_COMPONENT_BAND_TABLE.FIRST;

		LOOP

			IF v_IMBALANCE > 0.001 OR v_BAND_NUMBER = 1 THEN
				v_MINIMUM := p_COMPONENT_BAND_TABLE(v_INDEX).BAND_MINIMUM;
				v_THRESHOLD := p_COMPONENT_BAND_TABLE(v_INDEX).BAND_THRESHOLD;

				IF v_INDEX > p_COMPONENT_BAND_TABLE.FIRST AND v_IS_PRORATE AND v_THRESHOLD <> 0 THEN
					v_THRESHOLD := v_THRESHOLD - p_COMPONENT_BAND_TABLE(v_INDEX - 1).BAND_THRESHOLD;
				END IF;

				v_MINIMUM_CHARGE_RATE := NVL(p_COMPONENT_BAND_TABLE(v_INDEX).BAND_CHARGE, 0);

				IF p_COMPONENT_IMBALANCE.IS_PERCENT = 1 THEN
					IF UPPER(SUBSTR(p_IMBALANCE_TYPE,1,1)) IN ('N','S') THEN
						v_THRESHOLD := p_IMBALANCE_CHARGE.SUPPLY * (v_THRESHOLD / 100.0);
					ELSE
						v_THRESHOLD := p_IMBALANCE_CHARGE.DEMAND * (v_THRESHOLD / 100.0);
					END IF;
				END IF;

				IF NOT p_NET_RETAIL_IMBALANCE THEN
					v_THRESHOLD := GREATEST(v_THRESHOLD, v_MINIMUM);
				END IF;

				v_QUANTITY := LEAST(v_IMBALANCE, v_THRESHOLD);

				IF v_THRESHOLD < v_MINIMUM THEN
				    IF  v_IMBALANCE > v_MINIMUM THEN
					    v_QUANTITY := v_MINIMUM;
					ELSE
					    v_QUANTITY := v_IMBALANCE;
					END IF;
				ELSE
				    IF v_THRESHOLD = 0 AND v_MINIMUM = 0 THEN
					    v_QUANTITY := v_IMBALANCE;
					END IF;
				END IF;

-- Allow any remaining imbalance amount to be costed in the top band, not restricted by the threshold.
-- When net position is balanced (<= 0.001 mwh) total imbalance amount is costed at first band.

				IF v_INDEX = p_COMPONENT_BAND_TABLE.LAST OR (p_NET_RETAIL_IMBALANCE AND ABS(p_IMBALANCE_CHARGE.NET_SYSTEM_IMBALANCE) <= 0.001) THEN
					v_QUANTITY := v_IMBALANCE;
					v_THRESHOLD := v_IMBALANCE;
				END IF;

				v_MULTIPLIER := p_COMPONENT_BAND_TABLE(v_INDEX).BAND_MULTIPLIER;
				v_IMBALANCE_CHARGE_BAND.BAND_NUMBER := v_BAND_NUMBER;
				v_IMBALANCE_CHARGE_BAND.ENERGY_IMBALANCE_QUANTITY := v_QUANTITY;
				v_IMBALANCE_CHARGE_BAND.ENERGY_IMBALANCE_RATE := p_ENERGY_IMBALANCE_RATE;
				IF v_MINIMUM_CHARGE_RATE > p_ENERGY_IMBALANCE_RATE * v_MULTIPLIER THEN
					IF UPPER(p_IMBALANCE_TYPE) = 'PENALTY' THEN
						v_IMBALANCE_CHARGE_BAND.ENERGY_IMBALANCE_RATE := v_MINIMUM_CHARGE_RATE * v_MULTIPLIER;
					ELSE
						v_IMBALANCE_CHARGE_BAND.ENERGY_IMBALANCE_RATE := v_MINIMUM_CHARGE_RATE;
					END IF;
				END IF;
				v_IMBALANCE_CHARGE_BAND.ENERGY_IMBALANCE_AMOUNT :=
					v_QUANTITY * GREATEST(p_ENERGY_IMBALANCE_RATE * v_MULTIPLIER, v_MINIMUM_CHARGE_RATE) * p_IMBALANCE_SIGN;

				IF v_IS_PRORATE OR (NOT v_IS_PRORATE AND v_IMBALANCE <= v_THRESHOLD) THEN
					PRIOR_IMBALANCE_CHARGE_BAND(v_PRIOR_CHARGE_ID, v_IMBALANCE_CHARGE_BAND);
					IF LOGS.IS_DEBUG_ENABLED THEN
					    LOGS.LOG_DEBUG(p_CHARGE_FLAG || ':' ||
						    TO_CHAR(v_BAND_NUMBER) || ',' ||
							TO_CHAR(v_IMBALANCE) || ',' ||
							TO_CHAR(v_MINIMUM) || ',' ||
							TO_CHAR(v_THRESHOLD) || ',' ||
							TO_CHAR(v_QUANTITY) || ',' ||
							TO_CHAR(p_ENERGY_IMBALANCE_RATE) || ',' ||
							TO_CHAR(v_MULTIPLIER) || ',' ||
							TO_CHAR(v_IMBALANCE_CHARGE_BAND.ENERGY_IMBALANCE_AMOUNT ) || '(' ||
							TO_CHAR(p_IMBALANCE_CHARGE.CHARGE_ID) || ')@' ||
							TO_CHAR(p_IMBALANCE_CHARGE.CHARGE_DATE, 'HH24'));
					END IF;
					PUT_IMBALANCE_CHARGE_BAND(v_IMBALANCE_CHARGE_BAND);
					IF (NOT v_IS_PRORATE AND v_IMBALANCE <= v_THRESHOLD) THEN
						EXIT;
					END IF;
				END IF;
			END IF;

			EXIT WHEN v_INDEX = p_COMPONENT_BAND_TABLE.LAST;
			v_INDEX := p_COMPONENT_BAND_TABLE.NEXT(v_INDEX);
			v_BAND_NUMBER := v_BAND_NUMBER + 1;
			IF v_IS_PRORATE THEN
			    v_IMBALANCE := GREATEST(v_IMBALANCE - v_QUANTITY, 0);
			END IF;
		END LOOP;
	END IF;

END APPLY_IMBALANCE_CHARGE_BAND;
---------------------------------------------------------------------------------------------------
PROCEDURE APPLY_IMBALANCE_CHARGE
	(
    p_IMBALANCE_TYPE IN VARCHAR2,
	p_COMPONENT_IMBALANCE IN COMPONENT_IMBALANCE%ROWTYPE,
	p_MARKET_PRICE_RECORD IN MARKET_PRICE_RECORD,
	p_IMBALANCE_CHARGE IN OUT IMBALANCE_CHARGE%ROWTYPE,
	p_OVER_SUPPLY_TABLE IN COMPONENT_BAND_TABLE,
	p_UNDER_SUPPLY_TABLE IN COMPONENT_BAND_TABLE,
	p_NET_RETAIL_IMBALANCE IN BOOLEAN := FALSE
	) AS

v_IMBALANCE_SIGN NUMBER := 1;
v_ENERGY_IMBALANCE_RATE NUMBER := 1.0;
v_COMPONENT_BAND_TABLE COMPONENT_BAND_TABLE;
v_CHARGE_FLAG VARCHAR(16);
v_INDEX BINARY_INTEGER;

BEGIN

	IF p_IMBALANCE_CHARGE.NET_SYSTEM_IMBALANCE <= 0 THEN
        IF p_IMBALANCE_CHARGE.SUPPLY <= p_IMBALANCE_CHARGE.DEMAND THEN
            v_ENERGY_IMBALANCE_RATE := p_MARKET_PRICE_RECORD.UNDER_UNDER_PRICE;
			v_COMPONENT_BAND_TABLE := p_UNDER_SUPPLY_TABLE;
			v_IMBALANCE_SIGN := 1;
			v_CHARGE_FLAG := 'UNDER_UNDER';
		ELSE
            v_ENERGY_IMBALANCE_RATE := p_MARKET_PRICE_RECORD.UNDER_OVER_PRICE;
			v_COMPONENT_BAND_TABLE := p_OVER_SUPPLY_TABLE;
			v_IMBALANCE_SIGN := -1;
			v_CHARGE_FLAG := 'UNDER_OVER';
			IF v_ENERGY_IMBALANCE_RATE < 0 THEN -- switch to the under supply prices and bands when negative price.
                v_ENERGY_IMBALANCE_RATE := p_MARKET_PRICE_RECORD.UNDER_UNDER_PRICE;
				v_COMPONENT_BAND_TABLE := p_UNDER_SUPPLY_TABLE;
				FOR v_INDEX IN v_COMPONENT_BAND_TABLE.FIRST..v_COMPONENT_BAND_TABLE.LAST LOOP
					v_COMPONENT_BAND_TABLE(v_INDEX).BAND_CHARGE := 0;
				END LOOP;
				v_IMBALANCE_SIGN := 1;
				v_CHARGE_FLAG := 'UNDER_OVER_SWAP';
			END IF;
        END IF;
	ELSE
        IF p_IMBALANCE_CHARGE.SUPPLY <= p_IMBALANCE_CHARGE.DEMAND THEN
            v_ENERGY_IMBALANCE_RATE := p_MARKET_PRICE_RECORD.OVER_UNDER_PRICE;
			v_COMPONENT_BAND_TABLE := p_UNDER_SUPPLY_TABLE;
			v_IMBALANCE_SIGN := 1;
			v_CHARGE_FLAG := 'OVER_UNDER';
		ELSE
            v_ENERGY_IMBALANCE_RATE := p_MARKET_PRICE_RECORD.OVER_OVER_PRICE;
			v_COMPONENT_BAND_TABLE := p_OVER_SUPPLY_TABLE;
			v_IMBALANCE_SIGN := -1;
			v_CHARGE_FLAG := 'OVER_OVER';
        END IF;
	END IF;

	IF UPPER(p_IMBALANCE_TYPE) IN ('PENALTY', 'CASH OUT', 'ACCUMULATED') THEN
		APPLY_IMBALANCE_CHARGE_BAND(v_CHARGE_FLAG, v_IMBALANCE_SIGN, p_IMBALANCE_TYPE, p_COMPONENT_IMBALANCE, v_ENERGY_IMBALANCE_RATE, p_IMBALANCE_CHARGE, v_COMPONENT_BAND_TABLE);
	ELSE
		APPLY_IMBALANCE_CHARGE_BAND(v_CHARGE_FLAG, v_IMBALANCE_SIGN, p_IMBALANCE_TYPE, p_COMPONENT_IMBALANCE, v_ENERGY_IMBALANCE_RATE, p_IMBALANCE_CHARGE, v_COMPONENT_BAND_TABLE, p_NET_RETAIL_IMBALANCE);
	END IF;

END APPLY_IMBALANCE_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_IMBALANCE_CHARGES
	(
	p_STATEMENT_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_CHARGE_AMOUNT OUT GA.NUMBER_TABLE
	) AS

-- Note: p_BEGIN_DATE and p_END_DATE are CUT dates.

CURSOR c_IMBALANCE_CHARGE IS
	SELECT CHARGE_DATE, SUM(ENERGY_IMBALANCE_AMOUNT) "CHARGE_AMOUNT"
	FROM BILLING_STATEMENT A,
		IMBALANCE_CHARGE B
	WHERE ENTITY_ID = ENTITY_ID
		AND PRODUCT_ID = PRODUCT_ID
		AND COMPONENT_ID = COMPONENT_ID
		AND CHARGE_VIEW_TYPE IN ('IMBALANCE1','IMBALANCE3')
		AND STATEMENT_TYPE = p_STATEMENT_TYPE
		AND STATEMENT_STATE = GA.INTERNAL_STATE
		AND STATEMENT_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND p_END_DATE
		AND AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM BILLING_STATEMENT
			WHERE ENTITY_ID = A.ENTITY_ID
				AND PRODUCT_ID = A.PRODUCT_ID
				AND COMPONENT_ID = A.COMPONENT_ID
				AND STATEMENT_TYPE = A.STATEMENT_TYPE
				AND STATEMENT_STATE = A.STATEMENT_STATE
				AND STATEMENT_DATE = A.STATEMENT_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE)
		AND B.CHARGE_ID = A.CHARGE_ID
		AND CHARGE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
	GROUP BY CHARGE_DATE;

v_INDEX BINARY_INTEGER;

BEGIN

	FOR v_IMBALANCE_CHARGE IN c_IMBALANCE_CHARGE LOOP
		v_INDEX := ROUND((v_IMBALANCE_CHARGE.CHARGE_DATE - p_BEGIN_DATE) / GA.HOUR_DIVISOR);
		p_CHARGE_AMOUNT(v_INDEX) := v_IMBALANCE_CHARGE.CHARGE_AMOUNT;
	END LOOP;

END GET_IMBALANCE_CHARGES;
---------------------------------------------------------------------------------------------------
PROCEDURE NET_RETAIL_PROFIT_AND_LOSS_DAY
	(
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE
	) AS

v_NET_RETAIL_PROFIT_LOSS NET_RETAIL_PROFIT_LOSS%ROWTYPE;
v_SUPPLY_POSITION_TABLE SUPPLY_POSITION_TABLE;
v_OVER_SUPPLY_PRICE GA.NUMBER_TABLE;
v_UNDER_SUPPLY_PRICE GA.NUMBER_TABLE;
v_OSF_PRICE GA.NUMBER_TABLE;
v_CHARGE_AMOUNT GA.NUMBER_TABLE;
v_PRICE_CODE CHAR;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_INDEX BINARY_INTEGER;
v_HOUR_INDEX BINARY_INTEGER;

BEGIN

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
		LOGS.LOG_INFO_DETAIL('Net Retail Profit and Loss - Single day (SERVICE_DATE='||TO_CHAR(p_SERVICE_DATE,'MM/DD/YYYY')||')');
	END IF;

	SELECT DECODE(p_STATEMENT_TYPE,1,'F',2,'P','A') INTO v_PRICE_CODE FROM DUAL;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('NET_RETAIL_PROFIT_AND_LOSS_DAY');
		LOGS.LOG_DEBUG('SCHEDULE_TYPE=' || TO_CHAR(p_SCHEDULE_TYPE));
		LOGS.LOG_DEBUG('STATEMENT_TYPE=' || TO_CHAR(p_STATEMENT_TYPE));
		LOGS.LOG_DEBUG('SERVICE_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_SERVICE_DATE));
		LOGS.LOG_DEBUG('INPUT_AS_OF_DATE=' || TEXT_UTIL.TO_CHAR_TIME(p_INPUT_AS_OF_DATE));
		LOGS.LOG_DEBUG('OUTPUT_AS_OF_DATE=' || TEXT_UTIL.TO_CHAR_TIME(p_OUTPUT_AS_OF_DATE));
		LOGS.LOG_DEBUG('PRICE_CODE=' || v_PRICE_CODE);
	END IF;

	UT.CUT_DAY_INTERVAL_RANGE(p_SERVICE_DATE, p_SERVICE_DATE, GA.LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	GET_SUPPLY_POSITION(p_SCHEDULE_TYPE, g_ALL, v_BEGIN_DATE, v_END_DATE, p_INPUT_AS_OF_DATE, v_SUPPLY_POSITION_TABLE);

	IF LOGS.IS_DEBUG_ENABLED THEN
		TRACE_SUPPLY_POSITION(v_SUPPLY_POSITION_TABLE);
	END IF;

	v_NET_RETAIL_PROFIT_LOSS.STATEMENT_TYPE := p_STATEMENT_TYPE;
	v_NET_RETAIL_PROFIT_LOSS.STATEMENT_DATE := TRUNC(p_SERVICE_DATE);
	v_NET_RETAIL_PROFIT_LOSS.AS_OF_DATE := p_OUTPUT_AS_OF_DATE;

	GET_MARKET_PRICE(GET_MARKET_PRICE_ID('OVER SUPPLY','RETAIL'), v_PRICE_CODE, v_BEGIN_DATE, v_END_DATE, p_INPUT_AS_OF_DATE, v_OVER_SUPPLY_PRICE);
	GET_MARKET_PRICE(GET_MARKET_PRICE_ID('UNDER SUPPLY','RETAIL'), v_PRICE_CODE, v_BEGIN_DATE, v_END_DATE, p_INPUT_AS_OF_DATE, v_UNDER_SUPPLY_PRICE);
	GET_MARKET_PRICE(GET_MARKET_PRICE_ID('COMPOSITE-OSF','RETAIL'), v_PRICE_CODE, v_BEGIN_DATE, v_END_DATE, p_INPUT_AS_OF_DATE, v_OSF_PRICE);

	IF LOGS.IS_DEBUG_ENABLED THEN
		TRACE_TABLE('OVER SUPPLY PRICE', v_OVER_SUPPLY_PRICE);
		TRACE_TABLE('UNDER SUPPLY PRICE', v_UNDER_SUPPLY_PRICE);
		TRACE_TABLE('COMPOSITE-OSF PRICE', v_OSF_PRICE);
	END IF;

	GET_IMBALANCE_CHARGES(p_STATEMENT_TYPE, v_BEGIN_DATE, v_END_DATE, p_INPUT_AS_OF_DATE, v_CHARGE_AMOUNT);
	IF LOGS.IS_DEBUG_ENABLED THEN
		TRACE_TABLE('IMBALANCE CHARGES', v_CHARGE_AMOUNT);
		LOGS.LOG_DEBUG('<date>,<over>,<under>,<position>,<over rate>,<under rate>,<osf>,<osf rate>,<revenue>,<benefit>');
	END IF;

	IF v_SUPPLY_POSITION_TABLE.COUNT > 0 THEN
		FOR v_INDEX IN v_SUPPLY_POSITION_TABLE.FIRST..v_SUPPLY_POSITION_TABLE.LAST LOOP
			v_HOUR_INDEX := ROUND((v_SUPPLY_POSITION_TABLE(v_INDEX).SCHEDULE_DATE - p_SERVICE_DATE) / GA.HOUR_DIVISOR);
			v_NET_RETAIL_PROFIT_LOSS.CHARGE_DATE := v_SUPPLY_POSITION_TABLE(v_INDEX).SCHEDULE_DATE;
			v_NET_RETAIL_PROFIT_LOSS.SYSTEM_OVER_SUPPLY  := v_SUPPLY_POSITION_TABLE(v_INDEX).OVER_SUPPLY;
			v_NET_RETAIL_PROFIT_LOSS.SYSTEM_UNDER_SUPPLY  := v_SUPPLY_POSITION_TABLE(v_INDEX).UNDER_SUPPLY;
			v_NET_RETAIL_PROFIT_LOSS.SYSTEM_NET_POSITION  := v_SUPPLY_POSITION_TABLE(v_INDEX).POSITION;
			v_NET_RETAIL_PROFIT_LOSS.OVER_SUPPLY_RATE  := 0;
			v_NET_RETAIL_PROFIT_LOSS.UNDER_SUPPLY_RATE  := 0;
			v_NET_RETAIL_PROFIT_LOSS.OSF_RATE  := 0;

			IF v_OVER_SUPPLY_PRICE.EXISTS(v_INDEX) THEN
				v_NET_RETAIL_PROFIT_LOSS.OVER_SUPPLY_RATE  := v_OVER_SUPPLY_PRICE(v_INDEX);
			END IF;

			IF v_UNDER_SUPPLY_PRICE.EXISTS(v_INDEX) THEN
				v_NET_RETAIL_PROFIT_LOSS.UNDER_SUPPLY_RATE  := v_UNDER_SUPPLY_PRICE(v_INDEX);
			END IF;

			IF v_OSF_PRICE.EXISTS(v_INDEX) AND v_SUPPLY_POSITION_TABLE(v_INDEX).POSITION > 0 THEN
				v_NET_RETAIL_PROFIT_LOSS.OSF_RATE  := v_OSF_PRICE(v_INDEX);
			END IF;

			v_NET_RETAIL_PROFIT_LOSS.OSF_AMOUNT  := v_NET_RETAIL_PROFIT_LOSS.SYSTEM_NET_POSITION * v_NET_RETAIL_PROFIT_LOSS.OSF_RATE;

			v_NET_RETAIL_PROFIT_LOSS.REVENUE_AMOUNT  := 0;
			IF v_CHARGE_AMOUNT.EXISTS(v_INDEX) THEN
				v_NET_RETAIL_PROFIT_LOSS.REVENUE_AMOUNT  := v_CHARGE_AMOUNT(v_INDEX);
			END IF;

			IF v_NET_RETAIL_PROFIT_LOSS.SYSTEM_NET_POSITION > 0 THEN
				v_NET_RETAIL_PROFIT_LOSS.BENEFIT_AMOUNT  := v_NET_RETAIL_PROFIT_LOSS.REVENUE_AMOUNT + (v_NET_RETAIL_PROFIT_LOSS.SYSTEM_NET_POSITION * v_NET_RETAIL_PROFIT_LOSS.OVER_SUPPLY_RATE);
			ELSIF v_NET_RETAIL_PROFIT_LOSS.SYSTEM_NET_POSITION < 0 THEN
				v_NET_RETAIL_PROFIT_LOSS.BENEFIT_AMOUNT  := v_NET_RETAIL_PROFIT_LOSS.REVENUE_AMOUNT + (v_NET_RETAIL_PROFIT_LOSS.SYSTEM_NET_POSITION * v_NET_RETAIL_PROFIT_LOSS.UNDER_SUPPLY_RATE);
			ELSE
				v_NET_RETAIL_PROFIT_LOSS.BENEFIT_AMOUNT  := 0;
			END IF;

			PUT_NET_RETAIL_PROFIT_LOSS(v_NET_RETAIL_PROFIT_LOSS);

		END LOOP;
	END IF;

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
		LOGS.LOG_INFO_DETAIL('Net Retail Profit and Loss - Single Day Completed');
	END IF;

END NET_RETAIL_PROFIT_AND_LOSS_DAY;
---------------------------------------------------------------------------------------------------
PROCEDURE NET_RETAIL_PROFIT_AND_LOSS
	(
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE
	) AS

v_SERVICE_DATE DATE;
v_ELASPSED NUMBER;

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		v_ELASPSED := DBMS_UTILITY.GET_TIME;
	    LOGS.LOG_DEBUG('NET_RETAIL_PROFIT_AND_LOSS BEGIN AT ' || TEXT_UTIL.TO_CHAR_TIME(SYSDATE));
 	END IF;

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Net Retail Profit and Loss (SCHEDULE_TYPE='||p_SCHEDULE_TYPE||'; STATEMENT_TYPE='||p_STATEMENT_TYPE||
				'; BEGIN_DATE='||TO_CHAR(p_BEGIN_DATE,'MM/DD/YYYY')||'; END_DATE='||TO_CHAR(p_END_DATE,'MM/DD/YYYY')||
				'; INPUT_AS_OF_DATE='||TO_CHAR(p_INPUT_AS_OF_DATE,'MM/DD/YYYY HH24:MI')||'; OUTPUT_AS_OF_DATE='||TO_CHAR(p_OUTPUT_AS_OF_DATE,'MM/DD/YYYY HH24:MI')||')');
	END IF;

	v_SERVICE_DATE := TRUNC(p_BEGIN_DATE);

	WHILE v_SERVICE_DATE <= TRUNC(p_END_DATE) LOOP
		NET_RETAIL_PROFIT_AND_LOSS_DAY(p_SCHEDULE_TYPE, p_STATEMENT_TYPE, v_SERVICE_DATE, p_INPUT_AS_OF_DATE, p_OUTPUT_AS_OF_DATE);
		v_SERVICE_DATE := v_SERVICE_DATE + 1;
	END LOOP;

	IF LOGS.IS_DEBUG_ENABLED THEN
		v_ELASPSED := DBMS_UTILITY.GET_TIME - v_ELASPSED;
	    LOGS.LOG_DEBUG('NET_RETAIL_PROFIT_AND_LOSS END AT ' || TEXT_UTIL.TO_CHAR_TIME(SYSDATE));
	    LOGS.LOG_DEBUG('ELAPSED TIME=' || TO_CHAR(v_ELASPSED));
 	END IF;

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Net Retail Profit and Loss - Completed Successfully');
	END IF;

END NET_RETAIL_PROFIT_AND_LOSS;
---------------------------------------------------------------------------------------------------
FUNCTION EXCLUDE_SERVICE_POINTS
	(
	p_CONTRACT_ID IN NUMBER,
	p_SERVICE_DATE IN DATE
	) RETURN NUMBER IS

CURSOR c_EXCLUDE IS
	SELECT DISTINCT B.SERVICE_POINT_ID
	FROM CONTRACT_PRODUCT_COMPONENT A,
		COMPONENT_IMBALANCE B,
        COMPONENT C
	WHERE A.CONTRACT_ID = p_CONTRACT_ID
		AND A.PRODUCT_ID = 	A.PRODUCT_ID
		AND A.COMPONENT_ID = A.COMPONENT_ID
		AND p_SERVICE_DATE BETWEEN A.BEGIN_DATE AND NVL(A.END_DATE, p_SERVICE_DATE)
		AND B.COMPONENT_ID = A.COMPONENT_ID
        AND B.SUB_COMPONENT_TYPE = g_NO_SUB_TYPE
        AND B.SUB_COMPONENT_ID = g_NOT_ASSIGNED
		AND p_SERVICE_DATE BETWEEN B.BEGIN_DATE AND NVL(B.END_DATE, p_SERVICE_DATE)
        AND C.COMPONENT_ID = B.COMPONENT_ID
		AND UPPER(SUBSTR(C.IMBALANCE_TYPE,1,1)) = 'S' -- Service Point Imbalance
		AND B.SERVICE_POINT_ID > 0;

v_WORK_ID NUMBER := 0;

BEGIN

	UT.GET_RTO_WORK_ID(v_WORK_ID);
	UT.POST_RTO_WORK(v_WORK_ID, NULL, g_UNKNOWN);

	FOR v_EXCLUDE IN c_EXCLUDE LOOP
		UT.POST_RTO_WORK(v_WORK_ID, NULL, v_EXCLUDE.SERVICE_POINT_ID);
	END LOOP;

	RETURN v_WORK_ID;

END EXCLUDE_SERVICE_POINTS;
---------------------------------------------------------------------------------------------------
PROCEDURE CACHE_LOAD_TRANSACTIONS
	(
	p_CONTRACT_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_EXCLUDE_POINTS IN BOOLEAN,
	p_TXN_WORK_ID OUT NUMBER,
	p_POR_WORK_ID OUT NUMBER
	) AS

v_EXCLUDE_WORK_ID NUMBER := 0;
v_POR GA.NUMBER_TABLE;

CURSOR c_DEMAND_X IS
	SELECT DISTINCT A.TRANSACTION_ID, A.POR_ID
	FROM INTERCHANGE_TRANSACTION A, IT_STATUS B, IT_COMMODITY C, SERVICE_POINT D
	WHERE TRUNC(p_SERVICE_DATE) BETWEEN A.BEGIN_DATE AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE)
		AND A.CONTRACT_ID = p_CONTRACT_ID
		AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) = 'LO' -- Demand Transactions to the POR.
		AND A.POR_ID = DECODE(p_SERVICE_POINT_ID, g_NOT_ASSIGNED, A.POR_ID, p_SERVICE_POINT_ID)
-- Exclude service points associated with a service point imbalance component when processing a net retail imbalance component for a PSE.
		AND A.POR_ID NOT IN (SELECT WORK_XID FROM RTO_WORK WHERE WORK_ID = v_EXCLUDE_WORK_ID)
		AND B.TRANSACTION_ID = A.TRANSACTION_ID
		AND B.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_STATUS
			WHERE TRANSACTION_ID = B.TRANSACTION_ID
				AND AS_OF_DATE <= p_AS_OF_DATE)
		AND B.TRANSACTION_IS_ACTIVE = 1
		AND C.COMMODITY_ID = A.COMMODITY_ID
		AND UPPER(SUBSTR(C.COMMODITY_TYPE,1,1)) = 'E'
		AND D.SERVICE_POINT_ID = A.POR_ID
		AND UPPER(SUBSTR(D.SERVICE_POINT_TYPE,1,1)) = 'R';

CURSOR c_DEMAND IS
	SELECT DISTINCT A.TRANSACTION_ID, A.POR_ID
	FROM INTERCHANGE_TRANSACTION A, IT_STATUS B, IT_COMMODITY C, SERVICE_POINT D
	WHERE TRUNC(p_SERVICE_DATE) BETWEEN A.BEGIN_DATE AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE)
		AND A.CONTRACT_ID = p_CONTRACT_ID
		AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) = 'LO' -- Demand Transactions to the POR.
		AND A.POR_ID = DECODE(p_SERVICE_POINT_ID, g_NOT_ASSIGNED, A.POR_ID, p_SERVICE_POINT_ID)
		AND B.TRANSACTION_ID = A.TRANSACTION_ID
		AND B.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_STATUS
			WHERE TRANSACTION_ID = B.TRANSACTION_ID
				AND AS_OF_DATE <= p_AS_OF_DATE)
		AND B.TRANSACTION_IS_ACTIVE = 1
		AND C.COMMODITY_ID = A.COMMODITY_ID
		AND UPPER(SUBSTR(C.COMMODITY_TYPE,1,1)) = 'E'
		AND D.SERVICE_POINT_ID = A.POR_ID
		AND UPPER(SUBSTR(D.SERVICE_POINT_TYPE,1,1)) = 'R';

BEGIN

	UT.GET_RTO_WORK_ID(p_TXN_WORK_ID);
	UT.POST_RTO_WORK(p_TXN_WORK_ID, NULL, g_UNKNOWN);
	UT.GET_RTO_WORK_ID(p_POR_WORK_ID);
	UT.POST_RTO_WORK(p_POR_WORK_ID, NULL, g_UNKNOWN);

	IF p_EXCLUDE_POINTS THEN
		v_EXCLUDE_WORK_ID := EXCLUDE_SERVICE_POINTS(p_CONTRACT_ID, p_SERVICE_DATE);
		FOR v_DEMAND IN c_DEMAND_X LOOP
			UT.POST_RTO_WORK(p_TXN_WORK_ID, NULL, v_DEMAND.TRANSACTION_ID);
			IF NOT v_POR.EXISTS(v_DEMAND.POR_ID) THEN
				UT.POST_RTO_WORK(p_POR_WORK_ID, NULL, v_DEMAND.POR_ID);
				v_POR(v_DEMAND.POR_ID) := v_DEMAND.POR_ID;
			END IF;
		END LOOP;
		UT.PURGE_RTO_WORK(v_EXCLUDE_WORK_ID);
	ELSE
		FOR v_DEMAND IN c_DEMAND LOOP
			UT.POST_RTO_WORK(p_TXN_WORK_ID, NULL, v_DEMAND.TRANSACTION_ID);
			IF NOT v_POR.EXISTS(v_DEMAND.POR_ID) THEN
				UT.POST_RTO_WORK(p_POR_WORK_ID, NULL, v_DEMAND.POR_ID);
				v_POR(v_DEMAND.POR_ID) := v_DEMAND.POR_ID;
			END IF;
		END LOOP;
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			UT.PURGE_RTO_WORK(v_EXCLUDE_WORK_ID);
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE;
		END;
		ERRS.LOG_AND_RAISE;

END CACHE_LOAD_TRANSACTIONS;
---------------------------------------------------------------------------------------------------
PROCEDURE CACHE_SALES_TRANSACTIONS
	(
	p_PSE_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_POR_WORK_ID IN NUMBER,
	p_SALES_WORK_ID OUT NUMBER
	) AS

CURSOR c_SALES IS
	SELECT A.TRANSACTION_ID
	FROM INTERCHANGE_TRANSACTION A,
		IT_STATUS B,
		IT_COMMODITY C
	WHERE TRUNC(p_SERVICE_DATE) BETWEEN A.BEGIN_DATE AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE)
		AND (UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) IN ('SA')
			AND (A.SELLER_ID = p_PSE_ID	-- PSE is the Selling Party to the Transaction.
				OR A.PSE_ID = p_PSE_ID)		-- PSE_ID for Gas Model Transactions
			AND A.POR_ID IN (SELECT WORK_XID FROM RTO_WORK WHERE WORK_ID = p_POR_WORK_ID)) -- Sales are at POR.
		AND B.TRANSACTION_ID = A.TRANSACTION_ID
		AND B.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_STATUS
			WHERE TRANSACTION_ID = B.TRANSACTION_ID
				AND AS_OF_DATE <= p_AS_OF_DATE)
		AND B.TRANSACTION_IS_ACTIVE = 1
		AND C.COMMODITY_ID = A.COMMODITY_ID
		AND UPPER(SUBSTR(C.COMMODITY_TYPE,1,1)) = 'E';

BEGIN

	UT.GET_RTO_WORK_ID(p_SALES_WORK_ID);
	UT.POST_RTO_WORK(p_SALES_WORK_ID, NULL, g_UNKNOWN);

	FOR v_SALE IN c_SALES LOOP
		UT.POST_RTO_WORK(p_SALES_WORK_ID, NULL, v_SALE.TRANSACTION_ID);
	END LOOP;

END CACHE_SALES_TRANSACTIONS;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_RETAIL_IMBALANCE_DAY
	(
	p_CONTRACT_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_CHARGE_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_SERVICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2
	) AS

v_PSE_ID NUMBER;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_NET_RETAIL_IMBALANCE BOOLEAN;
v_COMPONENT_IMBALANCE COMPONENT_IMBALANCE%ROWTYPE;
v_IMBALANCE_CHARGE IMBALANCE_CHARGE%ROWTYPE;
v_OVER_SUPPLY_TABLE COMPONENT_BAND_TABLE;
v_UNDER_SUPPLY_TABLE COMPONENT_BAND_TABLE;
v_RETAIL_POSITION_TABLE NET_POSITION_TABLE;
v_MARKET_PRICE_TABLE MARKET_PRICE_TABLE;
v_NET_POSITION_TABLE NET_POSITION_TABLE;
v_INDEX BINARY_INTEGER;
v_TXN_WORK_ID NUMBER := NULL;
v_POR_WORK_ID NUMBER := NULL;
v_SALES_WORK_ID NUMBER := NULL;
v_EXCLUDE_POINTS BOOLEAN := FALSE;
v_PRIOR_CHARGE_ID NUMBER;
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;

CURSOR c_DEMAND IS
	SELECT SCHEDULE_DATE, SUM(AMOUNT) "LOAD"
	FROM IT_SCHEDULE A
	WHERE TRANSACTION_ID IN(SELECT WORK_XID FROM RTO_WORK WHERE WORK_ID = v_TXN_WORK_ID)
 		AND SCHEDULE_TYPE = p_SCHEDULE_TYPE
		AND SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND SCHEDULE_STATE = GA.INTERNAL_STATE
		AND AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_SCHEDULE
			WHERE TRANSACTION_ID = A.TRANSACTION_ID
				AND SCHEDULE_TYPE = A.SCHEDULE_TYPE
				AND SCHEDULE_STATE = A.SCHEDULE_STATE
				AND SCHEDULE_DATE = A.SCHEDULE_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE)
	GROUP BY SCHEDULE_DATE;

CURSOR c_SUPPLY IS
	SELECT D.SCHEDULE_DATE,
		SUM(DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'GE', D.AMOUNT, 0)) "GENERATION",
		SUM(DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'PU', D.AMOUNT, 'NO', D.AMOUNT, 0)) "PURCHASES"
	FROM INTERCHANGE_TRANSACTION A,
		IT_STATUS B,
		IT_COMMODITY C,
		IT_SCHEDULE D
	WHERE NOT EXISTS (SELECT 1 -- get only supply transactions that are *not* assigned to the load as balancing transactions
                		 FROM RTO_WORK W, IT_ASSIGNMENT IA, IT_ASSIGNMENT_PERIOD IAP
                		 WHERE W.WORK_ID IN (v_TXN_WORK_ID, v_SALES_WORK_ID)
						 	AND W.WORK_XID > 0
							AND IA.TO_TRANSACTION_ID = W.WORK_XID
                		 	AND IA.FROM_TRANSACTION_ID = A.TRANSACTION_ID
							AND IA.ASSIGNMENT_TYPE = LB.g_BALANCING_ASSIGNMENT_TYPE
                			AND IAP.ASSIGNMENT_ID = IA.ASSIGNMENT_ID
                			AND TRUNC(p_SERVICE_DATE) BETWEEN IAP.BEGIN_DATE AND NVL(IAP.END_DATE, CONSTANTS.HIGH_DATE))
		AND TRUNC(p_SERVICE_DATE) BETWEEN A.BEGIN_DATE AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE)
		AND (UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) IN ('GE','PU','NO')
			AND (A.PURCHASER_ID = v_PSE_ID	-- PSE is the Purchasing Party to the Transaction.
				OR A.PSE_ID = v_PSE_ID)		-- PSE_ID for Gas Model Transactions
			AND A.POD_ID IN (SELECT WORK_XID FROM RTO_WORK WHERE WORK_ID = v_POR_WORK_ID)) -- Generation and Purchases are at POD.
		AND B.TRANSACTION_ID = A.TRANSACTION_ID
		AND B.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_STATUS
			WHERE TRANSACTION_ID = B.TRANSACTION_ID
				AND AS_OF_DATE <= p_AS_OF_DATE)
		AND B.TRANSACTION_IS_ACTIVE = 1
		AND C.COMMODITY_ID = A.COMMODITY_ID
		AND UPPER(SUBSTR(C.COMMODITY_TYPE,1,1)) = 'E'
		AND D.TRANSACTION_ID = A.TRANSACTION_ID
		AND D.SCHEDULE_TYPE = DECODE(g_ENABLE_SUPPLY_SCHEDULE_TYPES, 1, p_SCHEDULE_TYPE, g_NOT_ASSIGNED)
		AND D.SCHEDULE_STATE = GA.INTERNAL_STATE
		AND D.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND D.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_SCHEDULE
			WHERE TRANSACTION_ID = D.TRANSACTION_ID
				AND SCHEDULE_TYPE = D.SCHEDULE_TYPE
				AND SCHEDULE_STATE = D.SCHEDULE_STATE
				AND SCHEDULE_DATE = D.SCHEDULE_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE)
	GROUP BY D.SCHEDULE_DATE;

CURSOR c_BALANCED_SUPPLY IS
	SELECT IAS.SCHEDULE_DATE,
		SUM(DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'GE', IAS.AMOUNT, 0)) "GENERATION",
		SUM(DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'PU', IAS.AMOUNT, 'NO', IAS.AMOUNT, 0)) "PURCHASES"
	FROM INTERCHANGE_TRANSACTION A,
		IT_STATUS B,
		IT_ASSIGNMENT IA,
		IT_ASSIGNMENT_SCHEDULE IAS,
		RTO_WORK W
	WHERE W.WORK_ID IN (v_TXN_WORK_ID, v_SALES_WORK_ID)
		AND W.WORK_XID > 0
        AND IA.TO_TRANSACTION_ID = W.WORK_XID
        AND IA.FROM_TRANSACTION_ID = A.TRANSACTION_ID
        AND IA.ASSIGNMENT_TYPE = LB.g_BALANCING_ASSIGNMENT_TYPE
		AND TRUNC(p_SERVICE_DATE) BETWEEN A.BEGIN_DATE AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE)
		AND (UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) IN ('GE','PU','NO')
			AND (A.PURCHASER_ID = v_PSE_ID	-- PSE is the Purchasing Party to the Transaction.
				OR A.PSE_ID = v_PSE_ID))		-- PSE_ID for Gas Model Transactions
		AND B.TRANSACTION_ID = A.TRANSACTION_ID
		AND B.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_STATUS
			WHERE TRANSACTION_ID = B.TRANSACTION_ID
				AND AS_OF_DATE <= p_AS_OF_DATE)
		AND B.TRANSACTION_IS_ACTIVE = 1
		AND IAS.ASSIGNMENT_ID = IA.ASSIGNMENT_ID
		AND IAS.OPTION_ID = GA.COMMITTED_OPTION_ID
		AND IAS.STATEMENT_TYPE_ID = DECODE(g_ENABLE_SUPPLY_SCHEDULE_TYPES, 1, p_SCHEDULE_TYPE, g_NOT_ASSIGNED)
		AND IAS.SCHEDULE_STATE = GA.INTERNAL_STATE
		AND IAS.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
	GROUP BY IAS.SCHEDULE_DATE;

CURSOR c_SALES IS
	SELECT SCHEDULE_DATE, SUM(AMOUNT) "SALES"
	FROM IT_SCHEDULE A
	WHERE TRANSACTION_ID IN(SELECT WORK_XID FROM RTO_WORK WHERE WORK_ID = v_SALES_WORK_ID)
 		AND SCHEDULE_TYPE = p_SCHEDULE_TYPE
		AND SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND SCHEDULE_STATE = GA.INTERNAL_STATE
		AND AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_SCHEDULE
			WHERE TRANSACTION_ID = A.TRANSACTION_ID
				AND SCHEDULE_TYPE = A.SCHEDULE_TYPE
				AND SCHEDULE_STATE = A.SCHEDULE_STATE
				AND SCHEDULE_DATE = A.SCHEDULE_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE)
	GROUP BY SCHEDULE_DATE;

BEGIN

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Retail Imbalance - Single day (SERVICE_DATE='||TO_CHAR(p_SERVICE_DATE,'MM/DD/YYYY')||')');
	END IF;
	UT.CUT_DAY_INTERVAL_RANGE(p_SERVICE_DATE, p_SERVICE_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PSE_RETAIL_IMBALANCE_DAY');
		LOGS.LOG_DEBUG('CONTRACT_ID=' || TO_CHAR(p_CONTRACT_ID));
		LOGS.LOG_DEBUG('CHARGE_ID=' || TO_CHAR(p_CHARGE_ID));
		LOGS.LOG_DEBUG('SERVICE_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_SERVICE_DATE));
	    LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_BEGIN_DATE));
	    LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_END_DATE));
	END IF;
	DBMS_OUTPUT.PUT_LINE('PSE_RETAIL_IMBALANCE_DAY SERVICE_DATE=' || TO_CHAR(p_SERVICE_DATE));
	v_PSE_ID := GET_PSE_BILLING_ENTITY_ID(p_CONTRACT_ID, p_SERVICE_DATE);
	FILL_NET_POSITION_TABLE(v_BEGIN_DATE, v_END_DATE, v_NET_POSITION_TABLE);

	v_COMPONENT_IMBALANCE := GET_COMPONENT_IMBALANCE(p_COMPONENT.COMPONENT_ID, p_SERVICE_DATE);
	IF v_COMPONENT_IMBALANCE.COMPONENT_ID IS NULL THEN
		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG('WARNING: NO COMPONENT_IMBALANCE FOR SERVICE DATE');
		END IF;
		RETURN;
	END IF;

	GET_COMPONENT_BANDS(v_COMPONENT_IMBALANCE.IMBALANCE_ID, v_OVER_SUPPLY_TABLE, v_UNDER_SUPPLY_TABLE);

	v_NET_RETAIL_IMBALANCE := UPPER(SUBSTR(p_COMPONENT.IMBALANCE_TYPE,1,1)) IN ('N','S') ;

	IF v_NET_RETAIL_IMBALANCE THEN
		GET_NET_POSITION(p_SCHEDULE_TYPE, -1, 'RETAIL', 0, p_SERVICE_DATE, p_SERVICE_DATE, p_AS_OF_DATE, p_TIME_ZONE, v_RETAIL_POSITION_TABLE);
		v_EXCLUDE_POINTS := UPPER(SUBSTR(p_COMPONENT.IMBALANCE_TYPE,1,1)) = 'N';
	END IF;

	GET_FORWARD_MARKET_PRICES(v_COMPONENT_IMBALANCE.UNDER_UNDER_PRICE_ID,
		v_COMPONENT_IMBALANCE.UNDER_OVER_PRICE_ID,
		v_COMPONENT_IMBALANCE.OVER_UNDER_PRICE_ID,
		v_COMPONENT_IMBALANCE.OVER_OVER_PRICE_ID,
		p_SCHEDULE_TYPE, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, v_MARKET_PRICE_TABLE);

	IF LOGS.IS_DEBUG_ENABLED THEN
		TRACE_COMPONENT_BAND(v_UNDER_SUPPLY_TABLE);
		IF v_NET_RETAIL_IMBALANCE  THEN
			TRACE_COMPONENT_BAND(v_OVER_SUPPLY_TABLE);
			TRACE_NET_POSITION(v_RETAIL_POSITION_TABLE);
		END IF;
		TRACE_MARKET_PRICES(v_MARKET_PRICE_TABLE);
		LOGS.LOG_DEBUG('<band>,<imbalance>,<min>,<threshold>,<quantity>,<rate>,<multiplier>,<amt>(<id>)@<hour>');
	END IF;

	DELETE IMBALANCE_CHARGE_BAND
	WHERE CHARGE_ID = p_CHARGE_ID
		AND CHARGE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND BAND_NUMBER > 1;

	CACHE_LOAD_TRANSACTIONS(p_CONTRACT_ID, v_COMPONENT_IMBALANCE.SERVICE_POINT_ID, p_SERVICE_DATE, p_AS_OF_DATE, v_EXCLUDE_POINTS, v_TXN_WORK_ID, v_POR_WORK_ID);

	IF LOGS.IS_DEBUG_ENABLED THEN
		DECLARE
			CURSOR c_TRACE1 IS
				SELECT WORK_XID FROM RTO_WORK WHERE WORK_ID = v_TXN_WORK_ID;
			CURSOR c_TRACE2 IS
				SELECT WORK_XID FROM RTO_WORK WHERE WORK_ID = v_POR_WORK_ID;
		BEGIN
			LOGS.LOG_DEBUG('Load Transactions:');
			FOR v_TR1 IN c_TRACE1 LOOP
				IF v_TR1.WORK_XID > 0 THEN
					LOGS.LOG_DEBUG(TO_CHAR(v_TR1.WORK_XID));
				END IF;
			END LOOP;
			LOGS.LOG_DEBUG('Receipt Delivery Points:');
			FOR v_TR2 IN c_TRACE2 LOOP
				IF v_TR2.WORK_XID > 0 THEN
					LOGS.LOG_DEBUG(TO_CHAR(v_TR2.WORK_XID));
				END IF;
			END LOOP;
		END;
	END IF;

	v_ELAPSED := DBMS_UTILITY.GET_TIME;
	FOR v_DEMAND IN c_DEMAND LOOP
		v_INDEX := ROUND((v_DEMAND.SCHEDULE_DATE - v_BEGIN_DATE) / GA.HOUR_DIVISOR);
		v_NET_POSITION_TABLE(v_INDEX).DEMAND := v_DEMAND.LOAD;
	END LOOP;
	DBMS_OUTPUT.PUT_LINE('DEMAND CURSOR TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED));

	CACHE_SALES_TRANSACTIONS(v_PSE_ID, p_SERVICE_DATE, p_AS_OF_DATE, v_POR_WORK_ID, v_SALES_WORK_ID);

	IF LOGS.IS_DEBUG_ENABLED THEN
		DECLARE
			CURSOR c_TRACE IS
				SELECT WORK_XID FROM RTO_WORK WHERE WORK_ID = v_SALES_WORK_ID;
		BEGIN
			LOGS.LOG_DEBUG('Sales Transactions:');
			FOR v_TR IN c_TRACE LOOP
				IF v_TR.WORK_XID > 0 THEN
					LOGS.LOG_DEBUG(v_TR.WORK_XID);
				END IF;
			END LOOP;
		END;
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('Non-Balancing Supply Schedules');
	END IF;

	v_ELAPSED := DBMS_UTILITY.GET_TIME;
	FOR v_SUPPLY IN c_SUPPLY LOOP
		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG(TEXT_UTIL.TO_CHAR_TIME(v_SUPPLY.SCHEDULE_DATE) || ' = ' || TO_CHAR(v_SUPPLY.PURCHASES) || ' + ' || TO_CHAR(v_SUPPLY.GENERATION));
		END IF;
		v_INDEX := ROUND((v_SUPPLY.SCHEDULE_DATE - v_BEGIN_DATE) / GA.HOUR_DIVISOR);
		v_NET_POSITION_TABLE(v_INDEX).SUPPLY := v_SUPPLY.PURCHASES + v_SUPPLY.GENERATION;
	END LOOP;
	DBMS_OUTPUT.PUT_LINE('SUPPLY CURSOR TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED));

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('Balancing Supply Schedules');
	END IF;

	v_ELAPSED := DBMS_UTILITY.GET_TIME;
	FOR v_SUPPLY IN c_BALANCED_SUPPLY LOOP
		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG(TEXT_UTIL.TO_CHAR_TIME(v_SUPPLY.SCHEDULE_DATE) || ' = ' || TO_CHAR(v_SUPPLY.PURCHASES) || ' + ' || TO_CHAR(v_SUPPLY.GENERATION));
		END IF;
		v_INDEX := ROUND((v_SUPPLY.SCHEDULE_DATE - v_BEGIN_DATE) / GA.HOUR_DIVISOR);
		IF NOT v_NET_POSITION_TABLE.EXISTS(v_INDEX) THEN
			v_NET_POSITION_TABLE(v_INDEX).SUPPLY := 0;
		END IF;
		v_NET_POSITION_TABLE(v_INDEX).SUPPLY := v_NET_POSITION_TABLE(v_INDEX).SUPPLY + v_SUPPLY.PURCHASES + v_SUPPLY.GENERATION;
	END LOOP;
	DBMS_OUTPUT.PUT_LINE('BALANCED SUPPLY CURSOR TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED));

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('Sales Schedules');
	END IF;

	v_ELAPSED := DBMS_UTILITY.GET_TIME;
	FOR v_SUPPLY IN c_SALES LOOP
		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG('    ' || TEXT_UTIL.TO_CHAR_TIME(v_SUPPLY.SCHEDULE_DATE) || ' = ' || TO_CHAR(v_SUPPLY.SALES));
		END IF;
		v_INDEX := ROUND((v_SUPPLY.SCHEDULE_DATE - v_BEGIN_DATE) / GA.HOUR_DIVISOR);
		IF NOT v_NET_POSITION_TABLE.EXISTS(v_INDEX) THEN
			v_NET_POSITION_TABLE(v_INDEX).SUPPLY := 0;
		END IF;
		v_NET_POSITION_TABLE(v_INDEX).SUPPLY := v_NET_POSITION_TABLE(v_INDEX).SUPPLY - v_SUPPLY.SALES;
	END LOOP;
	DBMS_OUTPUT.PUT_LINE('SALES CURSOR TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED));

	v_PRIOR_CHARGE_ID := GET_PRIOR_CHARGE_ID(p_CHARGE_ID);

	IF v_NET_POSITION_TABLE.COUNT > 0 THEN
	  FOR v_INDEX IN v_NET_POSITION_TABLE.FIRST..v_NET_POSITION_TABLE.LAST LOOP
		v_IMBALANCE_CHARGE.CHARGE_ID := p_CHARGE_ID;
		v_IMBALANCE_CHARGE.CHARGE_DATE := v_NET_POSITION_TABLE(v_INDEX).SCHEDULE_DATE;
		v_IMBALANCE_CHARGE.DEMAND := v_NET_POSITION_TABLE(v_INDEX).DEMAND;
		v_IMBALANCE_CHARGE.SUPPLY := v_NET_POSITION_TABLE(v_INDEX).SUPPLY;
		v_IMBALANCE_CHARGE.NET_SYSTEM_IMBALANCE := 0;
		v_IMBALANCE_CHARGE.ENERGY_IMBALANCE_AMOUNT := 0;

		IF v_NET_RETAIL_IMBALANCE AND v_RETAIL_POSITION_TABLE.EXISTS(v_INDEX) THEN
		    v_IMBALANCE_CHARGE.NET_SYSTEM_IMBALANCE := v_RETAIL_POSITION_TABLE(v_INDEX).POSITION;
		END IF;

		UT.GET_INCUMBENT_ENTITY(g_INCUMBENT_TYPE, g_INCUMBENT_NAME, g_INCUMBENT_ALIAS, g_INCUMBENT_ID);

		APPLY_IMBALANCE_CHARGE(
		        p_COMPONENT.IMBALANCE_TYPE,
				v_COMPONENT_IMBALANCE,
				v_MARKET_PRICE_TABLE(v_INDEX),
				v_IMBALANCE_CHARGE,
				v_OVER_SUPPLY_TABLE,
				v_UNDER_SUPPLY_TABLE,
				g_INCUMBENT_TYPE = 'EDC');

		v_IMBALANCE_CHARGE.ENERGY_IMBALANCE_AMOUNT := GET_ENERGY_IMBALANCE_AMOUNT(p_CHARGE_ID, v_IMBALANCE_CHARGE.CHARGE_DATE);
		PRIOR_IMBALANCE_CHARGE(v_PRIOR_CHARGE_ID, v_IMBALANCE_CHARGE);
		PUT_IMBALANCE_CHARGE(v_IMBALANCE_CHARGE);

	  END LOOP;
	END IF;

	IF v_TXN_WORK_ID IS NOT NULL THEN
		UT.PURGE_RTO_WORK(v_TXN_WORK_ID);
	END IF;
	IF v_POR_WORK_ID IS NOT NULL THEN
		UT.PURGE_RTO_WORK(v_POR_WORK_ID);
	END IF;
	IF v_SALES_WORK_ID IS NOT NULL THEN
		UT.PURGE_RTO_WORK(v_SALES_WORK_ID);
	END IF;

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Retail Imbalance - Single Day Completed');
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			UT.PURGE_RTO_WORK(v_TXN_WORK_ID);
			UT.PURGE_RTO_WORK(v_POR_WORK_ID);
			UT.PURGE_RTO_WORK(v_SALES_WORK_ID);
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE;
		END;
		ERRS.LOG_AND_RAISE;

END PSE_RETAIL_IMBALANCE_DAY;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_RETAIL_IMBALANCE
	(
	p_CONTRACT_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_CHARGE_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2
	) AS

v_SERVICE_DATE DATE;

BEGIN

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Retail Imbalance (CONTRACT_ID='||p_CONTRACT_ID||'; SCHEDULE_TYPE='||p_SCHEDULE_TYPE||'; STATEMENT_TYPE='||p_STATEMENT_TYPE||
			'; CHARGE_ID='||p_CHARGE_ID||'; COMPONENT='||p_COMPONENT.COMPONENT_NAME||'('||p_COMPONENT.COMPONENT_ID||')'||
			'; BEGIN_DATE='||TO_CHAR(p_BEGIN_DATE,'MM/DD/YYYY')||'; END_DATE='||TO_CHAR(p_END_DATE,'MM/DD/YYYY')||
			'; AS_OF_DATE='||TO_CHAR(p_AS_OF_DATE,'MM/DD/YYYY HH24:MI')||')');
	END IF;

	v_SERVICE_DATE := TRUNC(p_BEGIN_DATE);

	WHILE v_SERVICE_DATE <= TRUNC(p_END_DATE) LOOP
		PSE_RETAIL_IMBALANCE_DAY(p_CONTRACT_ID, p_SCHEDULE_TYPE, p_STATEMENT_TYPE, p_CHARGE_ID, p_COMPONENT, v_SERVICE_DATE, p_AS_OF_DATE, p_TIME_ZONE);
		v_SERVICE_DATE := v_SERVICE_DATE + 1;
	END LOOP;

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Retail Imbalance - Completed Successfully');
	END IF;

END PSE_RETAIL_IMBALANCE;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_GENERATION_IMBALANCE_DAY
	(
	p_CONTRACT_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_CHARGE_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_SERVICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_PSE_ID NUMBER;
v_COMPONENT_IMBALANCE COMPONENT_IMBALANCE%ROWTYPE;
v_IMBALANCE_CHARGE IMBALANCE_CHARGE%ROWTYPE;
v_OVER_SUPPLY_TABLE COMPONENT_BAND_TABLE;
v_UNDER_SUPPLY_TABLE COMPONENT_BAND_TABLE;
v_MARKET_PRICE_TABLE MARKET_PRICE_TABLE;
v_GENERATION_POSITION_TABLE GENERATION_POSITION_TABLE;
v_INDEX BINARY_INTEGER;
v_PRIOR_CHARGE_ID NUMBER;

BEGIN

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Generation Imbalance - Single day (SERVICE_DATE=' || TO_CHAR(p_SERVICE_DATE,'MM/DD/YYYY')||')');
	END IF;
	UT.CUT_DAY_INTERVAL_RANGE(p_SERVICE_DATE, p_SERVICE_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('PSE_GENERATION_IMBALANCE_DAY');
	    LOGS.LOG_DEBUG('CONTRACT_ID=' || TO_CHAR(p_CONTRACT_ID));
	    LOGS.LOG_DEBUG('CHARGE_ID=' || TO_CHAR(p_CHARGE_ID));
	    LOGS.LOG_DEBUG('SERVICE_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_SERVICE_DATE));
	    LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_BEGIN_DATE));
	    LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_END_DATE));
	END IF;

	v_PSE_ID := GET_PSE_BILLING_ENTITY_ID(p_CONTRACT_ID, p_SERVICE_DATE, g_ALL);
	FILL_GENERATION_POSITION_TABLE(v_BEGIN_DATE, v_END_DATE, v_GENERATION_POSITION_TABLE);

	v_COMPONENT_IMBALANCE := GET_COMPONENT_IMBALANCE(p_COMPONENT.COMPONENT_ID, p_SERVICE_DATE);
	GET_COMPONENT_BANDS(v_COMPONENT_IMBALANCE.IMBALANCE_ID, v_OVER_SUPPLY_TABLE, v_UNDER_SUPPLY_TABLE);

	GET_FORWARD_MARKET_PRICES(v_COMPONENT_IMBALANCE.UNDER_UNDER_PRICE_ID,
		v_COMPONENT_IMBALANCE.UNDER_OVER_PRICE_ID,
		v_COMPONENT_IMBALANCE.OVER_UNDER_PRICE_ID,
		v_COMPONENT_IMBALANCE.OVER_OVER_PRICE_ID,
		p_SCHEDULE_TYPE, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, v_MARKET_PRICE_TABLE);

	IF LOGS.IS_DEBUG_ENABLED THEN
		TRACE_COMPONENT_BAND(v_UNDER_SUPPLY_TABLE);
		TRACE_MARKET_PRICES(v_MARKET_PRICE_TABLE);
		LOGS.LOG_DEBUG('<band>,<imbalance>,<min>,<threshold>,<quantity>,<rate>,<multiplier>,<amt>(<id>)@<hour>');
	END IF;

	DELETE IMBALANCE_CHARGE_BAND
	WHERE CHARGE_ID = p_CHARGE_ID
		AND CHARGE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND BAND_NUMBER > 1;

	GET_GENERATION_POSITION(v_PSE_ID, p_CONTRACT_ID, p_SCHEDULE_TYPE, v_COMPONENT_IMBALANCE.SERVICE_POINT_ID, p_SERVICE_DATE, p_SERVICE_DATE, p_AS_OF_DATE, p_TIME_ZONE, v_GENERATION_POSITION_TABLE);
	v_PRIOR_CHARGE_ID := GET_PRIOR_CHARGE_ID(p_CHARGE_ID);
	IF v_GENERATION_POSITION_TABLE.COUNT > 0 THEN
		FOR v_INDEX IN v_GENERATION_POSITION_TABLE.FIRST..v_GENERATION_POSITION_TABLE.LAST LOOP

		v_IMBALANCE_CHARGE.CHARGE_ID := p_CHARGE_ID;
		v_IMBALANCE_CHARGE.CHARGE_DATE := v_GENERATION_POSITION_TABLE(v_INDEX).SCHEDULE_DATE;
		v_IMBALANCE_CHARGE.DEMAND := v_GENERATION_POSITION_TABLE(v_INDEX).PLANNED;
		v_IMBALANCE_CHARGE.SUPPLY := v_GENERATION_POSITION_TABLE(v_INDEX).ACTUAL;
		v_IMBALANCE_CHARGE.NET_SYSTEM_IMBALANCE := 0;
		v_IMBALANCE_CHARGE.ENERGY_IMBALANCE_AMOUNT := 0;

		APPLY_IMBALANCE_CHARGE(
        	p_COMPONENT.IMBALANCE_TYPE,
			v_COMPONENT_IMBALANCE,
			v_MARKET_PRICE_TABLE(v_INDEX),
			v_IMBALANCE_CHARGE,
			v_OVER_SUPPLY_TABLE,
			v_UNDER_SUPPLY_TABLE);

		v_IMBALANCE_CHARGE.ENERGY_IMBALANCE_AMOUNT := GET_ENERGY_IMBALANCE_AMOUNT(p_CHARGE_ID, v_GENERATION_POSITION_TABLE(v_INDEX).SCHEDULE_DATE);
		PRIOR_IMBALANCE_CHARGE(v_PRIOR_CHARGE_ID, v_IMBALANCE_CHARGE);
		PUT_IMBALANCE_CHARGE(v_IMBALANCE_CHARGE);

	  END LOOP;
	END IF;

	v_GENERATION_POSITION_TABLE.DELETE;

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Generation Imbalance - Single Day Completed');
	END IF;

END PSE_GENERATION_IMBALANCE_DAY;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_GENERATION_IMBALANCE
	(
	p_CONTRACT_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_CHARGE_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2
	) AS

v_SERVICE_DATE DATE;

BEGIN

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Generation Imbalance (CONTRACT_ID='||p_CONTRACT_ID||'; SCHEDULE_TYPE='||p_SCHEDULE_TYPE||
			'; CHARGE_ID='||p_CHARGE_ID||'; COMPONENT='||p_COMPONENT.COMPONENT_NAME||'('||p_COMPONENT.COMPONENT_ID||')'||
			'; BEGIN_DATE='||TO_CHAR(p_BEGIN_DATE,'MM/DD/YYYY')||'; END_DATE='||TO_CHAR(p_END_DATE,'MM/DD/YYYY')||
			'; AS_OF_DATE='||TO_CHAR(p_AS_OF_DATE,'MM/DD/YYYY HH24:MI')||')');
	END IF;

	v_SERVICE_DATE := TRUNC(p_BEGIN_DATE);

	WHILE v_SERVICE_DATE <= TRUNC(p_END_DATE) LOOP
		PSE_GENERATION_IMBALANCE_DAY(p_CONTRACT_ID, p_SCHEDULE_TYPE, p_CHARGE_ID, p_COMPONENT, v_SERVICE_DATE, p_AS_OF_DATE, p_TIME_ZONE);
		v_SERVICE_DATE := v_SERVICE_DATE + 1;
	END LOOP;

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Generation Imbalance - Completed Successfully');
	END IF;

END PSE_GENERATION_IMBALANCE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_IMBALANCE_SCHEDULE
	(
	p_CONTRACT_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_IMBALANCE_TRANSACTION IN OUT NOCOPY IMBALANCE_TRANSACTION_TABLE,
	p_IMBALANCE_SCHEDULE IN OUT NOCOPY IMBALANCE_SCHEDULE_TABLE
	) AS

-- Note that p_BEGIN_DATE and p_END_DATE are CUT Dates.

v_INDEX BINARY_INTEGER;
v_OFFSET BINARY_INTEGER;
v_IMBALANCE_SCHEDULE IMBALANCE_SCHEDULE_TABLE := IMBALANCE_SCHEDULE_TABLE();

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('GET_IMBALANCE_SCHEDULE');
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE));
	END IF;

	SELECT IMBALANCE_TRANSACTION_TYPE(A.TRANSACTION_ID, A.TRANSACTION_TYPE)
	BULK COLLECT INTO p_IMBALANCE_TRANSACTION
	FROM (SELECT DISTINCT A.TRANSACTION_ID, UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) "TRANSACTION_TYPE"
		FROM INTERCHANGE_TRANSACTION A, IT_STATUS B, IT_COMMODITY C
		WHERE TRUNC(p_BEGIN_DATE) BETWEEN NVL(A.BEGIN_DATE, CONSTANTS.LOW_DATE) AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE)
			AND A.CONTRACT_ID = p_CONTRACT_ID
			AND (p_SERVICE_POINT_ID = g_NOT_ASSIGNED
				OR (UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) IN ('LO','SA') AND A.POR_ID = p_SERVICE_POINT_ID)
				OR (UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) IN ('GE','PU') AND A.POD_ID = p_SERVICE_POINT_ID))
			AND ((UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) IN ('LO','SA') AND A.SELLER_ID = p_PSE_ID) -- PSE is the Selling Party to the Transaction.
				OR (UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) IN ('GE','PU') AND A.PURCHASER_ID = p_PSE_ID)) -- PSE is the Purchasing Party to the Transaction.
			AND NOT EXISTS (SELECT 1
							FROM IT_ASSIGNMENT IA
							WHERE IA.FROM_TRANSACTION_ID = A.TRANSACTION_ID
								AND IA.ASSIGNMENT_TYPE = LB.g_BALANCING_ASSIGNMENT_TYPE)
			AND B.TRANSACTION_ID = A.TRANSACTION_ID
			AND B.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM IT_STATUS
				WHERE TRANSACTION_ID = B.TRANSACTION_ID
					AND AS_OF_DATE <= p_AS_OF_DATE)
			AND B.TRANSACTION_IS_ACTIVE = 1
			AND C.COMMODITY_ID = A.COMMODITY_ID
			AND UPPER(SUBSTR(C.COMMODITY_TYPE,1,1)) = 'E') A;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('IMBALANCE TRANSACTION COUNT=' || TO_CHAR(p_IMBALANCE_TRANSACTION.COUNT));
		v_INDEX := p_IMBALANCE_TRANSACTION.FIRST;
		WHILE v_INDEX <= p_IMBALANCE_TRANSACTION.LAST LOOP
			LOGS.LOG_DEBUG('TRANSACTION_ID=' || TO_CHAR(p_IMBALANCE_TRANSACTION(v_INDEX).TRANSACTION_ID) || ', TRANSACTION_TYPE=' || p_IMBALANCE_TRANSACTION(v_INDEX).TRANSACTION_TYPE);
			v_INDEX := p_IMBALANCE_TRANSACTION.NEXT(v_INDEX);
		END LOOP;
	END IF;

-- If there are no Transactions that fit the selection criteris then nothing useful can be accomplished here.
	IF p_IMBALANCE_TRANSACTION.COUNT = 0 THEN
		RETURN;
	END IF;

	IF GA.VERSION_SCHEDULE THEN
		SELECT IMBALANCE_SCHEDULE_TYPE(B.SCHEDULE_DATE,
			SUM(DECODE(A.TRANSACTION_TYPE, 'LO', B.AMOUNT, 0)),
			SUM(DECODE(A.TRANSACTION_TYPE, 'GE', B.AMOUNT, 'PU', B.AMOUNT, 'SA', -B.AMOUNT, 0)),0,0)
		BULK COLLECT INTO v_IMBALANCE_SCHEDULE
		FROM TABLE(CAST(p_IMBALANCE_TRANSACTION AS IMBALANCE_TRANSACTION_TABLE)) A, IT_SCHEDULE B
		WHERE B.TRANSACTION_ID = A.TRANSACTION_ID
			AND B.SCHEDULE_TYPE = p_SCHEDULE_TYPE
			AND B.SCHEDULE_STATE = GA.INTERNAL_STATE
			AND B.SCHEDULE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
			AND B.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM IT_SCHEDULE
				WHERE TRANSACTION_ID = B.TRANSACTION_ID
					AND SCHEDULE_TYPE = B.SCHEDULE_TYPE
					AND SCHEDULE_STATE = B.SCHEDULE_STATE
					AND SCHEDULE_DATE = B.SCHEDULE_DATE
					AND AS_OF_DATE <= p_AS_OF_DATE)
		GROUP BY B.SCHEDULE_DATE;
	ELSE
		SELECT IMBALANCE_SCHEDULE_TYPE(B.SCHEDULE_DATE,
			SUM(DECODE(A.TRANSACTION_TYPE, 'LO', B.AMOUNT, 0)),
			SUM(DECODE(A.TRANSACTION_TYPE, 'GE', B.AMOUNT, 'PU', B.AMOUNT, 'SA', -B.AMOUNT, 0)),0,0)
		BULK COLLECT INTO v_IMBALANCE_SCHEDULE
		FROM TABLE(CAST(p_IMBALANCE_TRANSACTION AS IMBALANCE_TRANSACTION_TABLE)) A, IT_SCHEDULE B
		WHERE B.TRANSACTION_ID = A.TRANSACTION_ID
			AND B.SCHEDULE_TYPE = p_SCHEDULE_TYPE
			AND B.SCHEDULE_STATE = GA.INTERNAL_STATE
			AND B.SCHEDULE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
			AND B.AS_OF_DATE = CONSTANTS.LOW_DATE
		GROUP BY B.SCHEDULE_DATE;
	END IF;

-- Apply the Imbalance Schedules
	IF v_IMBALANCE_SCHEDULE.COUNT > 0 THEN
		v_INDEX := v_IMBALANCE_SCHEDULE.FIRST;
		WHILE v_INDEX <= v_IMBALANCE_SCHEDULE.LAST LOOP
			v_OFFSET := ROUND((v_IMBALANCE_SCHEDULE(v_INDEX).SCHEDULE_DATE - p_BEGIN_DATE) / GA.HOUR_DIVISOR) + 1;
			p_IMBALANCE_SCHEDULE(v_OFFSET).DEMAND := p_IMBALANCE_SCHEDULE(v_OFFSET).DEMAND + v_IMBALANCE_SCHEDULE(v_INDEX).DEMAND;
			p_IMBALANCE_SCHEDULE(v_OFFSET).SUPPLY := p_IMBALANCE_SCHEDULE(v_OFFSET).SUPPLY + v_IMBALANCE_SCHEDULE(v_INDEX).SUPPLY;
			v_INDEX := v_IMBALANCE_SCHEDULE.NEXT(v_INDEX);
		END LOOP;
	END IF;

END GET_IMBALANCE_SCHEDULE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_BALANCE_SCHEDULE
	(
	p_CONTRACT_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_IMBALANCE_TRANSACTION IN IMBALANCE_TRANSACTION_TABLE,
	p_IMBALANCE_SCHEDULE IN OUT NOCOPY IMBALANCE_SCHEDULE_TABLE
	) AS

-- Note that p_BEGIN_DATE and p_END_DATE are CUT Dates.

v_INDEX BINARY_INTEGER;
v_OFFSET BINARY_INTEGER;
v_BALANCE_SCHEDULE IMBALANCE_SCHEDULE_TABLE := IMBALANCE_SCHEDULE_TABLE();

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('GET_BALANCE_SCHEDULE');
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE));
	END IF;

-- If there are no Transactions that fit the selection criteris then nothing useful can be accomplished here.
	IF p_IMBALANCE_TRANSACTION.COUNT = 0 THEN
		RETURN;
	END IF;

    SELECT IMBALANCE_SCHEDULE_TYPE(IAS.SCHEDULE_DATE,
        SUM(DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'LO', IAS.AMOUNT, 0)),
        SUM(DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'GE', IAS.AMOUNT, 'PU', IAS.AMOUNT, 'SA', -IAS.AMOUNT, 0)),0,0)
    BULK COLLECT INTO v_BALANCE_SCHEDULE
    FROM INTERCHANGE_TRANSACTION A,
        IT_ASSIGNMENT IA,
        IT_ASSIGNMENT_SCHEDULE IAS
    WHERE A.TRANSACTION_ID IN (SELECT A.TRANSACTION_ID FROM TABLE(CAST(p_IMBALANCE_TRANSACTION AS IMBALANCE_TRANSACTION_TABLE)) A WHERE A.TRANSACTION_TYPE = 'LO')
        AND IA.TO_TRANSACTION_ID = A.TRANSACTION_ID
        AND IA.ASSIGNMENT_TYPE = LB.g_BALANCING_ASSIGNMENT_TYPE
        AND IAS.ASSIGNMENT_ID = IA.ASSIGNMENT_ID
        AND IAS.OPTION_ID = GA.COMMITTED_OPTION_ID
        AND IAS.STATEMENT_TYPE_ID = p_SCHEDULE_TYPE
        AND IAS.SCHEDULE_STATE = GA.INTERNAL_STATE
        AND IAS.SCHEDULE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
    GROUP BY IAS.SCHEDULE_DATE;

-- Apply the Balance Schedules
	IF v_BALANCE_SCHEDULE.COUNT > 0 THEN
		v_INDEX := v_BALANCE_SCHEDULE.FIRST;
		WHILE v_INDEX <= v_BALANCE_SCHEDULE.LAST LOOP
			v_OFFSET := ROUND((v_BALANCE_SCHEDULE(v_INDEX).SCHEDULE_DATE - p_BEGIN_DATE) / GA.HOUR_DIVISOR) + 1;
			p_IMBALANCE_SCHEDULE(v_OFFSET).DEMAND := p_IMBALANCE_SCHEDULE(v_OFFSET).DEMAND + v_BALANCE_SCHEDULE(v_INDEX).DEMAND;
			p_IMBALANCE_SCHEDULE(v_OFFSET).SUPPLY := p_IMBALANCE_SCHEDULE(v_OFFSET).SUPPLY + v_BALANCE_SCHEDULE(v_INDEX).SUPPLY;
			v_INDEX := v_BALANCE_SCHEDULE.NEXT(v_INDEX);
		END LOOP;
	END IF;

END GET_BALANCE_SCHEDULE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_ACCUMULATED_IMBALANCE
	(
	p_CONTRACT_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_ACCUMULATION_PERIOD IN NUMBER,
	p_MAXIMUM_AMOUNT IN NUMBER,
	p_PRIOR_PERIOD_QUANTITY IN NUMBER,
	p_IMBALANCE_SCHEDULE IN OUT NOCOPY IMBALANCE_SCHEDULE_TABLE
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_SERVICE_DATE DATE;
v_INDEX BINARY_INTEGER;
v_IMBALANCE NUMBER;
v_PRIOR_IMBALANCE NUMBER;
v_ACCUMULATED  NUMBER := 999999.999;
v_IMBALANCE_TRANSACTION IMBALANCE_TRANSACTION_TABLE := IMBALANCE_TRANSACTION_TABLE();

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('GET_ACCUMULATED_IMBALANCE');
		LOGS.LOG_DEBUG('PSE_ID=' || TO_CHAR(p_PSE_ID));
		LOGS.LOG_DEBUG('SCHEDULE_TYPE=' || TO_CHAR(p_SCHEDULE_TYPE));
		LOGS.LOG_DEBUG('SERVICE_POINT_ID=' || TO_CHAR(p_SERVICE_POINT_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TO_CHAR(p_END_DATE));
		LOGS.LOG_DEBUG('AS_OF_DATE=' || TEXT_UTIL.TO_CHAR_TIME(p_AS_OF_DATE));
		LOGS.LOG_DEBUG('ACCUMULATION_PERIOD=' || TO_CHAR(p_ACCUMULATION_PERIOD));
	END IF;

	UT.CUT_DAY_INTERVAL_RANGE(p_BEGIN_DATE - p_ACCUMULATION_PERIOD, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

-- Initialize the Imbalance Schedule to have an entry for each hour over the evaluation period.

	p_IMBALANCE_SCHEDULE.DELETE;

	v_SERVICE_DATE := v_BEGIN_DATE;
	v_INDEX := 0;
	WHILE v_SERVICE_DATE <= v_END_DATE LOOP
		v_INDEX := v_INDEX + 1;
		v_SERVICE_DATE := ADD_HOURS_TO_DATE(v_SERVICE_DATE, 1);
	END LOOP;
	p_IMBALANCE_SCHEDULE.EXTEND(v_INDEX);

	v_SERVICE_DATE := v_BEGIN_DATE;
	v_INDEX := 0;
	WHILE v_SERVICE_DATE <= v_END_DATE LOOP
		v_INDEX := v_INDEX + 1;
		p_IMBALANCE_SCHEDULE(v_INDEX) := IMBALANCE_SCHEDULE_TYPE(v_SERVICE_DATE, 0, 0, 0 ,0);
		v_SERVICE_DATE := ADD_HOURS_TO_DATE(v_SERVICE_DATE, 1);
	END LOOP;

	GET_IMBALANCE_SCHEDULE(p_CONTRACT_ID, p_PSE_ID, p_SCHEDULE_TYPE, p_SERVICE_POINT_ID, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, v_IMBALANCE_TRANSACTION, p_IMBALANCE_SCHEDULE);

	GET_BALANCE_SCHEDULE(p_CONTRACT_ID, p_PSE_ID, p_SCHEDULE_TYPE, p_SERVICE_POINT_ID, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, v_IMBALANCE_TRANSACTION, p_IMBALANCE_SCHEDULE);

	v_INDEX := p_IMBALANCE_SCHEDULE.FIRST;
	v_PRIOR_IMBALANCE := p_PRIOR_PERIOD_QUANTITY;
	WHILE v_INDEX <= p_IMBALANCE_SCHEDULE.LAST LOOP
		v_IMBALANCE := p_IMBALANCE_SCHEDULE(v_INDEX).DEMAND - p_IMBALANCE_SCHEDULE(v_INDEX).SUPPLY;
		p_IMBALANCE_SCHEDULE(v_INDEX).IMBALANCE := v_IMBALANCE;
		v_IMBALANCE := v_PRIOR_IMBALANCE + LEAST(ABS(v_IMBALANCE), p_MAXIMUM_AMOUNT) * SIGN(v_IMBALANCE);
		p_IMBALANCE_SCHEDULE(v_INDEX).ACCUMULATED := v_IMBALANCE;
		v_PRIOR_IMBALANCE := v_IMBALANCE;
		v_INDEX := p_IMBALANCE_SCHEDULE.NEXT(v_INDEX);
	END LOOP;


	IF LOGS.IS_DEBUG_ENABLED THEN
		v_INDEX := p_IMBALANCE_SCHEDULE.FIRST;
		LOGS.LOG_DEBUG('TRACE IMBALANCE SCHEDULE...');
		LOGS.LOG_DEBUG('<index>,<date>,<demand>,<supply>,<imbalance>,<accumulated>');
		WHILE v_INDEX <= p_IMBALANCE_SCHEDULE.LAST LOOP
			 p_IMBALANCE_SCHEDULE(v_INDEX).IMBALANCE := p_IMBALANCE_SCHEDULE(v_INDEX).DEMAND - p_IMBALANCE_SCHEDULE(v_INDEX).SUPPLY;
			 IF NOT v_ACCUMULATED = p_IMBALANCE_SCHEDULE(v_INDEX).ACCUMULATED THEN
				LOGS.LOG_DEBUG(TO_CHAR(v_INDEX) || ',' || TEXT_UTIL.TO_CHAR_TIME(p_IMBALANCE_SCHEDULE(v_INDEX).SCHEDULE_DATE) || ',' || TO_CHAR(p_IMBALANCE_SCHEDULE(v_INDEX).DEMAND) || ',' || TO_CHAR(p_IMBALANCE_SCHEDULE(v_INDEX).SUPPLY)  || ',' || TO_CHAR(p_IMBALANCE_SCHEDULE(v_INDEX).IMBALANCE) || ',' || TO_CHAR(p_IMBALANCE_SCHEDULE(v_INDEX).ACCUMULATED));
			END IF;
			v_ACCUMULATED := p_IMBALANCE_SCHEDULE(v_INDEX).ACCUMULATED;
			v_INDEX := p_IMBALANCE_SCHEDULE.NEXT(v_INDEX);
			v_PRIOR_IMBALANCE := v_IMBALANCE;
		END LOOP;
	END IF;

END GET_ACCUMULATED_IMBALANCE;
---------------------------------------------------------------------------------------------------
FUNCTION IMBALANCE_CROSS_OVER
	(
	p_BASE_DATE IN DATE,
	p_FROM_DATE IN DATE,
	p_TO_DATE IN DATE,
	p_IMBALANCE_SCHEDULE IN IMBALANCE_SCHEDULE_TABLE,
	p_DEMAND OUT NUMBER,
	p_SUPPLY OUT NUMBER,
	p_ACCUMULATED_IMBALANCE OUT NUMBER
	) RETURN BOOLEAN IS

-- Note that p_BASE_DATE, p_BEGIN_DATE, and p_END_DATE are all CUT Dates.

v_INDEX BINARY_INTEGER;
v_LAST_INDEX BINARY_INTEGER;

BEGIN

	IF p_IMBALANCE_SCHEDULE.COUNT = 0 THEN
		RETURN FALSE;
	END IF;

	v_INDEX:= ROUND((p_FROM_DATE - p_BASE_DATE) / GA.HOUR_DIVISOR) + 1;
	IF v_INDEX < p_IMBALANCE_SCHEDULE.FIRST THEN
		v_INDEX := p_IMBALANCE_SCHEDULE.FIRST;
	END IF;

	v_LAST_INDEX:= ROUND((p_TO_DATE - p_BASE_DATE) / GA.HOUR_DIVISOR) + 1;
	IF v_LAST_INDEX > p_IMBALANCE_SCHEDULE.LAST THEN
		v_LAST_INDEX := p_IMBALANCE_SCHEDULE.LAST;
	END IF;

	p_DEMAND := p_IMBALANCE_SCHEDULE(v_INDEX).DEMAND;
	p_SUPPLY := p_IMBALANCE_SCHEDULE(v_INDEX).SUPPLY;
	p_ACCUMULATED_IMBALANCE := p_IMBALANCE_SCHEDULE(v_INDEX).ACCUMULATED;
	v_INDEX := p_IMBALANCE_SCHEDULE.NEXT(v_INDEX);

	WHILE v_INDEX <= v_LAST_INDEX LOOP
		IF NOT SIGN(p_IMBALANCE_SCHEDULE(v_INDEX - 1).ACCUMULATED) = SIGN(p_IMBALANCE_SCHEDULE(v_INDEX).ACCUMULATED) THEN
			RETURN TRUE; -- Cross-over
		END IF;
		v_INDEX := p_IMBALANCE_SCHEDULE.NEXT(v_INDEX);
	END LOOP;

	RETURN FALSE; -- No Cross-over

END IMBALANCE_CROSS_OVER;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_ACCUMULATED_IMBALANCE
	(
	p_CONTRACT_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_BILLING_STATEMENT IN OUT BILLING_STATEMENT%ROWTYPE,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2
	) AS

v_PSE_ID NUMBER;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_PRIOR_PERIOD_BEGIN_DATE DATE;
v_PRIOR_PERIOD_END_DATE DATE;
v_FROM_DATE DATE;
v_TO_DATE DATE;
v_DEMAND NUMBER;
v_SUPPLY NUMBER;
v_CROSS_OVER BOOLEAN;
v_COMPONENT_IMBALANCE COMPONENT_IMBALANCE%ROWTYPE;
v_IMBALANCE_CHARGE IMBALANCE_CHARGE%ROWTYPE;
v_OVER_SUPPLY_TABLE COMPONENT_BAND_TABLE;
v_UNDER_SUPPLY_TABLE COMPONENT_BAND_TABLE;
v_MARKET_PRICE_TABLE MARKET_PRICE_TABLE;
v_INDEX BINARY_INTEGER;
v_PRIOR_CHARGE_ID NUMBER;
v_IMBALANCE_SCHEDULE IMBALANCE_SCHEDULE_TABLE := IMBALANCE_SCHEDULE_TABLE();
v_MAXIMUM_AMOUNT NUMBER(2) := 2;
v_ACCUMULATED_IMBALANCE NUMBER;
v_PRIOR_PERIOD_QUANTITY NUMBER;

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PSE_ACCUMULATED_IMBALANCE');
		LOGS.LOG_DEBUG('CONTRACT_ID=' || TO_CHAR(p_CONTRACT_ID));
		LOGS.LOG_DEBUG('CHARGE_ID=' || TO_CHAR(p_BILLING_STATEMENT.CHARGE_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE));
	    LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE));
	END IF;

	v_PSE_ID := GET_PSE_BILLING_ENTITY_ID(p_CONTRACT_ID, p_BEGIN_DATE);

	v_COMPONENT_IMBALANCE := GET_COMPONENT_IMBALANCE(p_COMPONENT.COMPONENT_ID, p_BEGIN_DATE);

	v_PRIOR_PERIOD_QUANTITY := GET_PRIOR_PERIOD_QUANTITY(p_BILLING_STATEMENT);
	GET_ACCUMULATED_IMBALANCE(p_CONTRACT_ID, v_PSE_ID, p_SCHEDULE_TYPE, v_COMPONENT_IMBALANCE.SERVICE_POINT_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE, p_COMPONENT.ACCUMULATION_PERIOD, v_MAXIMUM_AMOUNT, v_PRIOR_PERIOD_QUANTITY, v_IMBALANCE_SCHEDULE);

	IF v_IMBALANCE_SCHEDULE.COUNT = 0 THEN
		RETURN;
	END IF;

	UT.CUT_DAY_INTERVAL_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	UT.CUT_DAY_INTERVAL_RANGE(p_BEGIN_DATE - p_COMPONENT.ACCUMULATION_PERIOD, p_END_DATE - p_COMPONENT.ACCUMULATION_PERIOD, p_TIME_ZONE, v_PRIOR_PERIOD_BEGIN_DATE, v_PRIOR_PERIOD_END_DATE);

-- Save the ending Accumulated Balance In The PSE Billing Statement.
	v_INDEX := ROUND((v_PRIOR_PERIOD_END_DATE - v_PRIOR_PERIOD_BEGIN_DATE) / GA.HOUR_DIVISOR) + 1;
	IF v_IMBALANCE_SCHEDULE.EXISTS(v_INDEX) THEN
		p_BILLING_STATEMENT.PRIOR_PERIOD_QUANTITY := v_IMBALANCE_SCHEDULE(v_INDEX).ACCUMULATED;
	ELSE
		p_BILLING_STATEMENT.PRIOR_PERIOD_QUANTITY := 0;
	END IF;

	GET_COMPONENT_BANDS(v_COMPONENT_IMBALANCE.IMBALANCE_ID, v_OVER_SUPPLY_TABLE, v_UNDER_SUPPLY_TABLE);

-- Get the Market Prices for the Accumulation Period.
	GET_FORWARD_MARKET_PRICES(v_COMPONENT_IMBALANCE.UNDER_UNDER_PRICE_ID,
		v_COMPONENT_IMBALANCE.UNDER_OVER_PRICE_ID,
		v_COMPONENT_IMBALANCE.OVER_UNDER_PRICE_ID,
		v_COMPONENT_IMBALANCE.OVER_OVER_PRICE_ID,
		p_SCHEDULE_TYPE, v_PRIOR_PERIOD_BEGIN_DATE, v_PRIOR_PERIOD_END_DATE, p_AS_OF_DATE, v_MARKET_PRICE_TABLE);

	IF LOGS.IS_DEBUG_ENABLED THEN
		TRACE_COMPONENT_BAND(v_UNDER_SUPPLY_TABLE);
		IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
			TRACE_MARKET_PRICES(v_MARKET_PRICE_TABLE);
		END IF;
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_END_DATE));
		LOGS.LOG_DEBUG('PRIOR_PERIOD_BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_PRIOR_PERIOD_BEGIN_DATE));
		LOGS.LOG_DEBUG('PRIOR_PERIOD_END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_PRIOR_PERIOD_END_DATE));
		LOGS.LOG_DEBUG('PRIOR_PERIOD_QUANTITY=' || TO_CHAR(v_PRIOR_PERIOD_QUANTITY));
		LOGS.LOG_DEBUG('NEXT PRIOR_PERIOD_QUANTITY=' || TO_CHAR(p_BILLING_STATEMENT.PRIOR_PERIOD_QUANTITY));
		LOGS.LOG_DEBUG('<band:#>,<imbalance>,<minimum>,<threshold>,<quantity>,<rate>,<multiplier>,<amount>(<id>)@<hour>');
	END IF;

-- Loop over the Accumulation Period and determine the Imbalance Charge for each hour.
-- The Imbalance amount is subject to charge if there has been at least one Imbalance sign cross-over during the Accumulation Period.
	v_FROM_DATE := v_PRIOR_PERIOD_BEGIN_DATE;
	v_TO_DATE := v_BEGIN_DATE;

	WHILE v_TO_DATE <= v_END_DATE LOOP

-- Determine Cross-over and get Demand and Supply for the associated prior-period hour.
		v_CROSS_OVER := IMBALANCE_CROSS_OVER(v_PRIOR_PERIOD_BEGIN_DATE, v_FROM_DATE, v_TO_DATE, v_IMBALANCE_SCHEDULE, v_DEMAND, v_SUPPLY, v_ACCUMULATED_IMBALANCE);

		IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
			LOGS.LOG_DEBUG_DETAIL(TEXT_UTIL.TO_CHAR_TIME(v_TO_DATE) || ',' || UT.TRACE_BOOLEAN(v_CROSS_OVER) || ',' || TO_CHAR(v_ACCUMULATED_IMBALANCE));
		END IF;

		v_IMBALANCE_CHARGE.CHARGE_ID := p_BILLING_STATEMENT.CHARGE_ID;
		v_IMBALANCE_CHARGE.CHARGE_DATE := v_TO_DATE;
		v_IMBALANCE_CHARGE.DEMAND := v_DEMAND;
		v_IMBALANCE_CHARGE.SUPPLY := v_SUPPLY;
		v_IMBALANCE_CHARGE.NET_SYSTEM_IMBALANCE := v_ACCUMULATED_IMBALANCE;

		IF v_CROSS_OVER THEN
			v_IMBALANCE_CHARGE.BILL_NET_SYSTEM_IMBALANCE := 0;
		ELSE
			v_IMBALANCE_CHARGE.BILL_NET_SYSTEM_IMBALANCE := -99999;
		END IF;

-- Market Prices use a Zero-Base Offset Index.
		v_INDEX := ROUND((v_FROM_DATE - v_PRIOR_PERIOD_BEGIN_DATE) / GA.HOUR_DIVISOR);

		APPLY_IMBALANCE_CHARGE(p_COMPONENT.IMBALANCE_TYPE, v_COMPONENT_IMBALANCE, v_MARKET_PRICE_TABLE(v_INDEX), v_IMBALANCE_CHARGE, v_OVER_SUPPLY_TABLE, v_UNDER_SUPPLY_TABLE);

		v_IMBALANCE_CHARGE.ENERGY_IMBALANCE_AMOUNT := GET_ENERGY_IMBALANCE_AMOUNT(p_BILLING_STATEMENT.CHARGE_ID, v_TO_DATE);
		v_IMBALANCE_CHARGE.BILL_NET_SYSTEM_IMBALANCE := 0;
		PRIOR_IMBALANCE_CHARGE(v_PRIOR_CHARGE_ID, v_IMBALANCE_CHARGE);
		PUT_IMBALANCE_CHARGE(v_IMBALANCE_CHARGE);

		v_FROM_DATE := ADD_HOURS_TO_DATE(v_FROM_DATE, 1);
		v_TO_DATE := ADD_HOURS_TO_DATE(v_TO_DATE, 1);

	END LOOP;

END PSE_ACCUMULATED_IMBALANCE;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_BLOCK_TAXES
	(
	p_TAX_CHARGE IN OUT TAX_CHARGE%ROWTYPE,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_PRIOR_CHARGE_ID IN NUMBER,
	p_GEOGRAPHY_ID IN NUMBER,
	p_WORK_XID IN NUMBER,
	p_WORK_ID IN NUMBER
	) AS

CURSOR c_TAXES IS
	SELECT A.CHARGE_DATE,
    	B.GEOGRAPHY_ID,
		A.CHARGE_QUANTITY,
		C.RATE "CHARGE_RATE",
		GREATEST(C.CHARGE_MIN, C.RATE*A.CHARGE_QUANTITY) "CHARGE_AMOUNT"
	FROM (SELECT WORK_DATE "CHARGE_DATE",
			TO_NUMBER(WORK_DATA) "CHARGE_QUANTITY"
		FROM RTO_WORK
		WHERE WORK_ID = p_WORK_ID
			AND WORK_XID = p_WORK_XID) A,
		(SELECT GEOGRAPHY_ID
    	FROM GEOGRAPHY
        START WITH GEOGRAPHY_ID = p_GEOGRAPHY_ID
        CONNECT BY PRIOR PARENT_GEOGRAPHY_ID = GEOGRAPHY_ID) B,
		COMPONENT_BLOCK_RATE C
	WHERE C.COMPONENT_ID = p_COMPONENT.COMPONENT_ID
		AND C.SUB_COMPONENT_TYPE = 'GEOGRAPHY'
        AND C.SUB_COMPONENT_ID = B.GEOGRAPHY_ID
		AND A.CHARGE_DATE BETWEEN C.BEGIN_DATE AND NVL(C.END_DATE,CONSTANTS.HIGH_DATE)
		AND ((p_COMPONENT.IS_CREDIT_CHARGE = 1 AND A.CHARGE_QUANTITY > 0) OR
			(p_COMPONENT.IS_CREDIT_CHARGE = 0 AND A.CHARGE_QUANTITY < 0))
		AND A.CHARGE_QUANTITY > C.BLOCK_MIN-1
		AND A.CHARGE_QUANTITY <= NVL(C.BLOCK_MAX,A.CHARGE_QUANTITY);
BEGIN
	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('PSE_BLOCK_TAXES');
		LOGS.LOG_DEBUG('TAX_CHARGE_ID=' || TO_CHAR(p_TAX_CHARGE.CHARGE_ID));
		LOGS.LOG_DEBUG('TAX_COMPONENT_ID=' || TO_CHAR(p_COMPONENT.COMPONENT_ID));
		LOGS.LOG_DEBUG('TAX_PRIOR_CHARGE_ID=' || TO_CHAR(p_PRIOR_CHARGE_ID));
		LOGS.LOG_DEBUG('GEOGRAPHY_ID=' || p_GEOGRAPHY_ID);
		LOGS.LOG_DEBUG('WORK_ID=' || TO_CHAR(p_WORK_ID));
		LOGS.LOG_DEBUG('WORK_XID=' || TO_CHAR(p_WORK_XID));
	    LOGS.LOG_DEBUG('<id>,<date>,<product>,<component>,<area-type>,<point>,<area-name>,<charge quantity>,<rate>,<factor>,<amount>,<bill quantity>,<amount>');
	END IF;

	FOR v_TAX IN c_TAXES LOOP
		p_TAX_CHARGE.CHARGE_DATE := v_TAX.CHARGE_DATE;
		p_TAX_CHARGE.CHARGE_QUANTITY := v_TAX.CHARGE_QUANTITY;
		p_TAX_CHARGE.CHARGE_RATE := v_TAX.CHARGE_RATE;
		p_TAX_CHARGE.CHARGE_AMOUNT := v_TAX.CHARGE_AMOUNT * p_TAX_CHARGE.CHARGE_FACTOR;
		p_TAX_CHARGE.GEOGRAPHY_ID := v_TAX.GEOGRAPHY_ID;
		PRIOR_TAX_CHARGE(p_PRIOR_CHARGE_ID, p_TAX_CHARGE);
		PUT_TAX_CHARGE(p_TAX_CHARGE);
	END LOOP;

END PSE_BLOCK_TAXES;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_TIERED_TAXES
	(
	p_TAX_CHARGE IN OUT TAX_CHARGE%ROWTYPE,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_PRIOR_CHARGE_ID IN NUMBER,
	p_GEOGRAPHY_ID IN NUMBER,
	p_WORK_XID IN NUMBER,
	p_WORK_ID IN NUMBER
	) AS

CURSOR c_TAXES IS
	SELECT A.CHARGE_DATE,
    	B.GEOGRAPHY_ID,
		A.CHARGE_QUANTITY,
		MAX(C.RATE) "CHARGE_RATE",
		SUM(GREATEST(C.CHARGE_MIN, C.RATE * (LEAST(NVL(C.BLOCK_MAX,A.CHARGE_QUANTITY), A.CHARGE_QUANTITY) - DECODE(C.BLOCK_MIN,0,0,C.BLOCK_MIN-1)))) "CHARGE_AMOUNT"
	FROM (SELECT WORK_DATE "CHARGE_DATE",
			TO_NUMBER(WORK_DATA) "CHARGE_QUANTITY"
		FROM RTO_WORK
		WHERE WORK_ID = p_WORK_ID
			AND WORK_XID = p_WORK_XID) A,
		(SELECT GEOGRAPHY_ID
    	FROM GEOGRAPHY
        START WITH GEOGRAPHY_ID = p_GEOGRAPHY_ID
        CONNECT BY PRIOR PARENT_GEOGRAPHY_ID = GEOGRAPHY_ID) B,
		COMPONENT_BLOCK_RATE C
	WHERE C.COMPONENT_ID = p_COMPONENT.COMPONENT_ID
    	AND C.SUB_COMPONENT_TYPE = 'GEOGRAPHY'
        AND C.SUB_COMPONENT_ID = B.GEOGRAPHY_ID
		AND A.CHARGE_DATE BETWEEN C.BEGIN_DATE AND NVL(C.END_DATE,CONSTANTS.HIGH_DATE)
		AND ((p_COMPONENT.IS_CREDIT_CHARGE = 1 AND A.CHARGE_QUANTITY > 0) OR
			(p_COMPONENT.IS_CREDIT_CHARGE = 0 AND A.CHARGE_QUANTITY < 0))
		AND A.CHARGE_QUANTITY > C.BLOCK_MIN-1
	GROUP BY A.CHARGE_DATE, B.GEOGRAPHY_ID, A.CHARGE_QUANTITY;

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('PSE_TIERED_TAXES');
		LOGS.LOG_DEBUG('TAX_CHARGE_ID=' || TO_CHAR(p_TAX_CHARGE.CHARGE_ID));
		LOGS.LOG_DEBUG('TAX_COMPONENT_ID=' || TO_CHAR(p_COMPONENT.COMPONENT_ID));
		LOGS.LOG_DEBUG('TAX_PRIOR_CHARGE_ID=' || TO_CHAR(p_PRIOR_CHARGE_ID));
		LOGS.LOG_DEBUG('GEOGRAPHY_ID=' || p_GEOGRAPHY_ID);
		LOGS.LOG_DEBUG('WORK_ID=' || TO_CHAR(p_WORK_ID));
		LOGS.LOG_DEBUG('WORK_XID=' || TO_CHAR(p_WORK_XID));
	    LOGS.LOG_DEBUG('<id>,<date>,<product>,<component>,<area-type>,<point>,<area-name>,<charge quantity>,<rate>,<factor>,<amount>,<bill quantity>,<amount>');
	END IF;

	FOR v_TAX IN c_TAXES LOOP
		p_TAX_CHARGE.CHARGE_DATE := v_TAX.CHARGE_DATE;
		p_TAX_CHARGE.CHARGE_QUANTITY := v_TAX.CHARGE_QUANTITY;
		p_TAX_CHARGE.CHARGE_RATE := v_TAX.CHARGE_RATE;
		p_TAX_CHARGE.CHARGE_AMOUNT := v_TAX.CHARGE_AMOUNT * p_TAX_CHARGE.CHARGE_FACTOR;
		p_TAX_CHARGE.GEOGRAPHY_ID := v_TAX.GEOGRAPHY_ID;
		PRIOR_TAX_CHARGE(p_PRIOR_CHARGE_ID, p_TAX_CHARGE);
		PUT_TAX_CHARGE(p_TAX_CHARGE);
	END LOOP;

END PSE_TIERED_TAXES;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_MARKET_TAXES
	(
	p_TAX_CHARGE IN OUT TAX_CHARGE%ROWTYPE,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_PRIOR_CHARGE_ID IN NUMBER,
	p_GEOGRAPHY_ID IN NUMBER,
	p_WORK_XID IN NUMBER,
	p_WORK_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_AS_OF_DATE IN DATE
	) AS

CURSOR c_TAXES IS
	SELECT A.CHARGE_DATE,
		B.GEOGRAPHY_ID,
		A.CHARGE_QUANTITY,
		D.PRICE*NVL(C.RATE_MULTIPLIER,1)+NVL(C.RATE_ADDER,0) "CHARGE_RATE"
	FROM (SELECT WORK_DATE "CHARGE_DATE",
			TO_NUMBER(WORK_DATA) "CHARGE_QUANTITY"
		FROM RTO_WORK
		WHERE WORK_ID = p_WORK_ID
			AND WORK_XID = p_WORK_XID) A,
		(SELECT GEOGRAPHY_ID
    	FROM GEOGRAPHY
        START WITH GEOGRAPHY_ID = p_GEOGRAPHY_ID
        CONNECT BY PRIOR PARENT_GEOGRAPHY_ID = GEOGRAPHY_ID) B,
		COMPONENT_MARKET_PRICE C,
		MARKET_PRICE_VALUE D
	WHERE C.COMPONENT_ID = p_COMPONENT.COMPONENT_ID
    	AND C.SUB_COMPONENT_TYPE = 'GEOGRAPHY'
        AND C.SUB_COMPONENT_ID = B.GEOGRAPHY_ID
		AND A.CHARGE_DATE BETWEEN C.BEGIN_DATE AND NVL(C.END_DATE,CONSTANTS.HIGH_DATE)
		AND ((p_COMPONENT.IS_CREDIT_CHARGE = 1 AND A.CHARGE_QUANTITY > 0) OR
			(p_COMPONENT.IS_CREDIT_CHARGE = 0 AND A.CHARGE_QUANTITY < 0))
		AND D.MARKET_PRICE_ID = p_COMPONENT.MARKET_PRICE_ID
	    AND D.PRICE_CODE IN ('F','P','A')
		AND D.PRICE_DATE = TRUNC(A.CHARGE_DATE,'MI')
        AND D.PRICE_CODE =
        	(SELECT DECODE(MAX(DECODE(PRICE_CODE,'F',1,'P',2,'A',3)),1,'F',2,'P',3,'A')
        	FROM MARKET_PRICE_VALUE
            WHERE MARKET_PRICE_ID = D.MARKET_PRICE_ID
            	AND PRICE_CODE IN ('F','P','A')
                AND PRICE_DATE = D.PRICE_DATE)
		AND D.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM MARKET_PRICE_VALUE
			WHERE MARKET_PRICE_ID = D.MARKET_PRICE_ID
				AND PRICE_CODE = D.PRICE_CODE
				AND PRICE_DATE = D.PRICE_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE);

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('PSE_MARKET_TAXES');
		LOGS.LOG_DEBUG('TAX_CHARGE_ID=' || TO_CHAR(p_TAX_CHARGE.CHARGE_ID));
		LOGS.LOG_DEBUG('TAX_COMPONENT_ID=' || TO_CHAR(p_COMPONENT.COMPONENT_ID));
		LOGS.LOG_DEBUG('TAX_PRIOR_CHARGE_ID=' || TO_CHAR(p_PRIOR_CHARGE_ID));
		LOGS.LOG_DEBUG('GEOGRAPHY_ID=' || p_GEOGRAPHY_ID);
		LOGS.LOG_DEBUG('WORK_ID=' || TO_CHAR(p_WORK_ID));
		LOGS.LOG_DEBUG('WORK_XID=' || TO_CHAR(p_WORK_XID));
	    LOGS.LOG_DEBUG('<id>,<date>,<product>,<component>,<area-type>,<point>,<area-name>,<charge quantity>,<rate>,<factor>,<amount>,<bill quantity>,<amount>');
	END IF;

	FOR v_TAX IN c_TAXES LOOP
		p_TAX_CHARGE.CHARGE_DATE := v_TAX.CHARGE_DATE;
		p_TAX_CHARGE.CHARGE_QUANTITY := v_TAX.CHARGE_QUANTITY;
		p_TAX_CHARGE.CHARGE_RATE := v_TAX.CHARGE_RATE;
		p_TAX_CHARGE.CHARGE_AMOUNT := p_TAX_CHARGE.CHARGE_QUANTITY * p_TAX_CHARGE.CHARGE_RATE * p_TAX_CHARGE.CHARGE_FACTOR;
		p_TAX_CHARGE.GEOGRAPHY_ID := v_TAX.GEOGRAPHY_ID;
		PRIOR_TAX_CHARGE(p_PRIOR_CHARGE_ID, p_TAX_CHARGE);
		PUT_TAX_CHARGE(p_TAX_CHARGE);
	END LOOP;

END PSE_MARKET_TAXES;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_FLAT_TAXES
	(
	p_TAX_CHARGE IN OUT TAX_CHARGE%ROWTYPE,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_PRIOR_CHARGE_ID IN NUMBER,
	p_GEOGRAPHY_ID IN NUMBER,
	p_WORK_XID IN NUMBER,
	p_WORK_ID IN NUMBER
	) AS

CURSOR c_TAXES IS
	SELECT A.CHARGE_DATE,
		B.GEOGRAPHY_ID,
		A.CHARGE_QUANTITY,
		GREATEST(C.CHARGE_MIN, A.CHARGE_QUANTITY*C.RATE) "CHARGE_AMOUNT",
		C.RATE "CHARGE_RATE"
	FROM (SELECT WORK_DATE "CHARGE_DATE",
			TO_NUMBER(WORK_DATA) "CHARGE_QUANTITY"
		FROM RTO_WORK
		WHERE WORK_ID = p_WORK_ID
			AND WORK_XID = p_WORK_XID) A,
		(SELECT GEOGRAPHY_ID
    	FROM GEOGRAPHY
        START WITH GEOGRAPHY_ID = p_GEOGRAPHY_ID
        CONNECT BY PRIOR PARENT_GEOGRAPHY_ID = GEOGRAPHY_ID) B,
		COMPONENT_FLAT_RATE C
	WHERE C.COMPONENT_ID = p_COMPONENT.COMPONENT_ID
    	AND C.SUB_COMPONENT_TYPE = 'GEOGRAPHY'
        AND C.SUB_COMPONENT_ID = B.GEOGRAPHY_ID
		AND A.CHARGE_DATE BETWEEN C.BEGIN_DATE AND NVL(C.END_DATE,CONSTANTS.HIGH_DATE)
		AND ((p_COMPONENT.IS_CREDIT_CHARGE = 1 AND A.CHARGE_QUANTITY > 0) OR
			(p_COMPONENT.IS_CREDIT_CHARGE = 0 AND A.CHARGE_QUANTITY < 0));

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('PSE_FLAT_TAXES');
		LOGS.LOG_DEBUG('TAX_CHARGE_ID=' || TO_CHAR(p_TAX_CHARGE.CHARGE_ID));
		LOGS.LOG_DEBUG('TAX_COMPONENT_ID=' || TO_CHAR(p_COMPONENT.COMPONENT_ID));
		LOGS.LOG_DEBUG('TAX_PRIOR_CHARGE_ID=' || TO_CHAR(p_PRIOR_CHARGE_ID));
		LOGS.LOG_DEBUG('GEOGRAPHY_ID=' || p_GEOGRAPHY_ID);
		LOGS.LOG_DEBUG('WORK_ID=' || TO_CHAR(p_WORK_ID));
		LOGS.LOG_DEBUG('WORK_XID=' || TO_CHAR(p_WORK_XID));
	    LOGS.LOG_DEBUG('<id>,<date>,<product>,<component>,<area-type>,<point>,<area-name>,<charge quantity>,<rate>,<factor>,<amount>,<bill quantity>,<amount>');
	END IF;

	FOR v_TAX IN c_TAXES LOOP
		p_TAX_CHARGE.CHARGE_DATE := v_TAX.CHARGE_DATE;
		p_TAX_CHARGE.CHARGE_QUANTITY := v_TAX.CHARGE_QUANTITY;
		p_TAX_CHARGE.CHARGE_RATE := v_TAX.CHARGE_RATE;
		p_TAX_CHARGE.CHARGE_AMOUNT := v_TAX.CHARGE_AMOUNT * p_TAX_CHARGE.CHARGE_FACTOR;
		p_TAX_CHARGE.GEOGRAPHY_ID := v_TAX.GEOGRAPHY_ID;
		PRIOR_TAX_CHARGE(p_PRIOR_CHARGE_ID, p_TAX_CHARGE);
		PUT_TAX_CHARGE(p_TAX_CHARGE);
	END LOOP;

END PSE_FLAT_TAXES;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_CALCULATE_TAXES
	(
	p_TAX_CHARGE IN OUT TAX_CHARGE%ROWTYPE,
	p_TAX_COMPONENT IN COMPONENT%ROWTYPE,
	p_TAX_PRIOR_CHARGE_ID IN NUMBER,
    p_GEOGRAPHY_ID IN VARCHAR,
	p_CHARGE_ID IN NUMBER,
	p_CHARGE_VIEW_TYPE IN VARCHAR,
	p_SCHEDULE_TYPE IN NUMBER,
	p_AS_OF_DATE IN DATE
	) AS

v_WORK_ID NUMBER;
v_SOMETHING_DONE BOOLEAN := TRUE;

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('PSE_CALCULATE_TAXES');
		LOGS.LOG_DEBUG('TAX_CHARGE_ID=' || TO_CHAR(p_TAX_CHARGE.CHARGE_ID));
		LOGS.LOG_DEBUG('TAX_COMPONENT_ID=' || TO_CHAR(p_TAX_COMPONENT.COMPONENT_ID));
		LOGS.LOG_DEBUG('TAX_PRIOR_CHARGE_ID=' || TO_CHAR(p_TAX_PRIOR_CHARGE_ID));
		LOGS.LOG_DEBUG('CHARGE_ID=' || TO_CHAR(p_CHARGE_ID));
		LOGS.LOG_DEBUG('CHARGE_VIEW_TYPE=' || p_CHARGE_VIEW_TYPE);
		LOGS.LOG_DEBUG('GEOGRAPHY_ID=' || p_GEOGRAPHY_ID);
		LOGS.LOG_DEBUG('SCHEDULE_TYPE=' || TO_CHAR(p_SCHEDULE_TYPE));
	END IF;

	UT.GET_RTO_WORK_ID(v_WORK_ID);

	IF p_CHARGE_VIEW_TYPE IN ('BILLING CHARGE','COINCIDENT PEAK') THEN
		INSERT INTO RTO_WORK (WORK_ID, WORK_XID, WORK_DATE, WORK_DATA)
		SELECT v_WORK_ID, p_CHARGE_ID, CHARGE_DATE, TO_CHAR(SUM(CHARGE_AMOUNT))
		FROM BILLING_CHARGE
		WHERE CHARGE_ID = p_CHARGE_ID
		GROUP BY v_WORK_ID, p_CHARGE_ID, CHARGE_DATE;
	ELSIF SUBSTR(p_CHARGE_VIEW_TYPE,1,9) = 'IMBALANCE' THEN
		INSERT INTO RTO_WORK (WORK_ID, WORK_XID, WORK_DATE, WORK_DATA)
		SELECT v_WORK_ID, p_CHARGE_ID, CHARGE_DATE, TO_CHAR(SUM(ENERGY_IMBALANCE_AMOUNT))
		FROM IMBALANCE_CHARGE
		WHERE CHARGE_ID = p_CHARGE_ID
		GROUP BY v_WORK_ID, p_CHARGE_ID, CHARGE_DATE;
	ELSIF p_CHARGE_VIEW_TYPE = 'TRANSMISSION' THEN
		INSERT INTO RTO_WORK (WORK_ID, WORK_XID, WORK_DATE, WORK_DATA)
		SELECT v_WORK_ID, p_CHARGE_ID, CHARGE_DATE, TO_CHAR(SUM(CHARGE_AMOUNT))
		FROM TRANSMISSION_CHARGE
		WHERE CHARGE_ID = p_CHARGE_ID
		GROUP BY v_WORK_ID, p_CHARGE_ID, CHARGE_DATE;
	ELSIF p_CHARGE_VIEW_TYPE = 'ENTITY ATTRIBUTE' THEN
		INSERT INTO RTO_WORK (WORK_ID, WORK_XID, WORK_DATE, WORK_DATA)
		SELECT v_WORK_ID, p_CHARGE_ID, CHARGE_DATE, TO_CHAR(SUM(CHARGE_AMOUNT))
		FROM ENTITY_ATTRIBUTE_CHARGE
		WHERE CHARGE_ID = p_CHARGE_ID
		GROUP BY v_WORK_ID, p_CHARGE_ID, CHARGE_DATE;
	ELSIF p_CHARGE_VIEW_TYPE = 'ACCOUNT SERVICE' THEN
		INSERT INTO RTO_WORK (WORK_ID, WORK_XID, WORK_DATE, WORK_DATA)
		SELECT v_WORK_ID, p_CHARGE_ID, CHARGE_BEGIN_DATE, TO_CHAR(SUM(CHARGE_AMOUNT))
		FROM ACCOUNT_SERVICE_CHARGE
		WHERE CHARGE_ID = p_CHARGE_ID
		GROUP BY v_WORK_ID, p_CHARGE_ID, CHARGE_BEGIN_DATE;
	ELSIF p_CHARGE_VIEW_TYPE = 'OP PROFIT' THEN
		INSERT INTO RTO_WORK (WORK_ID, WORK_XID, WORK_DATE, WORK_DATA)
		SELECT v_WORK_ID, p_CHARGE_ID, CHARGE_DATE, TO_CHAR(SUM(CHARGE_AMOUNT))
		FROM OPER_PROFIT_CHARGE
		WHERE CHARGE_ID = p_CHARGE_ID
		GROUP BY v_WORK_ID, p_CHARGE_ID, CHARGE_DATE;
	ELSIF p_CHARGE_VIEW_TYPE = 'CONVERSION' THEN
		INSERT INTO RTO_WORK (WORK_ID, WORK_XID, WORK_DATE, WORK_DATA)
		SELECT v_WORK_ID, p_CHARGE_ID, CHARGE_DATE, TO_CHAR(SUM(CHARGE_AMOUNT))
		FROM CONVERSION_CHARGE
		WHERE CHARGE_ID = p_CHARGE_ID
		GROUP BY v_WORK_ID, p_CHARGE_ID, CHARGE_DATE;
	ELSIF p_CHARGE_VIEW_TYPE = 'FORMULA' THEN
		INSERT INTO RTO_WORK (WORK_ID, WORK_XID, WORK_DATE, WORK_DATA)
		SELECT v_WORK_ID, p_CHARGE_ID, CHARGE_DATE, TO_CHAR(SUM(CHARGE_AMOUNT))
		FROM FORMULA_CHARGE
		WHERE CHARGE_ID = p_CHARGE_ID
		GROUP BY v_WORK_ID, p_CHARGE_ID, CHARGE_DATE;
	ELSIF SUBSTR(p_CHARGE_VIEW_TYPE,1,3) = 'LMP' THEN
		INSERT INTO RTO_WORK (WORK_ID, WORK_XID, WORK_DATE, WORK_DATA)
		SELECT v_WORK_ID, p_CHARGE_ID, CHARGE_DATE, TO_CHAR(SUM(CHARGE_AMOUNT))
		FROM LMP_CHARGE
		WHERE CHARGE_ID = p_CHARGE_ID
		GROUP BY v_WORK_ID, p_CHARGE_ID, CHARGE_DATE;
	ELSIF SUBSTR(p_CHARGE_VIEW_TYPE,1,3) = 'FTR' THEN
		INSERT INTO RTO_WORK (WORK_ID, WORK_XID, WORK_DATE, WORK_DATA)
		SELECT v_WORK_ID, p_CHARGE_ID, CHARGE_DATE, TO_CHAR(SUM(CHARGE_AMOUNT))
		FROM FTR_CHARGE
		WHERE CHARGE_ID = p_CHARGE_ID
		GROUP BY v_WORK_ID, p_CHARGE_ID, CHARGE_DATE;
	ELSIF p_CHARGE_VIEW_TYPE = 'COMBINATION' THEN
		INSERT INTO RTO_WORK (WORK_ID, WORK_XID, WORK_DATE, WORK_DATA)
		SELECT v_WORK_ID, p_CHARGE_ID, BEGIN_DATE, TO_CHAR(SUM(CHARGE_AMOUNT))
		FROM COMBINATION_CHARGE
		WHERE CHARGE_ID = p_CHARGE_ID
		GROUP BY v_WORK_ID, p_CHARGE_ID, BEGIN_DATE;
	ELSIF p_CHARGE_VIEW_TYPE = 'PIPELINE' THEN
		INSERT INTO RTO_WORK (WORK_ID, WORK_XID, WORK_DATE, WORK_DATA)
		SELECT v_WORK_ID, p_CHARGE_ID, CHARGE_DATE, TO_CHAR(SUM(CHARGE_AMOUNT))
		FROM PIPELINE_CHARGE
		WHERE CHARGE_ID = p_CHARGE_ID
		GROUP BY v_WORK_ID, p_CHARGE_ID, CHARGE_DATE;
	ELSE --IF p_CHARGE_VIEW_TYPE = 'EXTERNAL' THEN
		XS.PUT_TAXED_COMPONENT_CHARGES(v_WORK_ID, p_TAX_CHARGE.COMPONENT_ID, p_CHARGE_ID, v_SOMETHING_DONE);
	END IF;

	IF v_SOMETHING_DONE THEN
		IF UPPER(p_TAX_COMPONENT.RATE_STRUCTURE) = 'BLOCK' THEN
			PSE_BLOCK_TAXES(p_TAX_CHARGE, p_TAX_COMPONENT, p_TAX_PRIOR_CHARGE_ID, p_GEOGRAPHY_ID, p_CHARGE_ID, v_WORK_ID);
		ELSIF UPPER(p_TAX_COMPONENT.RATE_STRUCTURE) = 'TIERED' THEN
			PSE_TIERED_TAXES(p_TAX_CHARGE, p_TAX_COMPONENT, p_TAX_PRIOR_CHARGE_ID, p_GEOGRAPHY_ID, p_CHARGE_ID, v_WORK_ID);
		ELSIF UPPER(p_TAX_COMPONENT.RATE_STRUCTURE) = 'MARKET' THEN
			PSE_MARKET_TAXES(p_TAX_CHARGE, p_TAX_COMPONENT, p_TAX_PRIOR_CHARGE_ID, p_GEOGRAPHY_ID, p_CHARGE_ID, v_WORK_ID, p_SCHEDULE_TYPE, p_AS_OF_DATE);
		ELSIF UPPER(p_TAX_COMPONENT.RATE_STRUCTURE) = 'FLAT' THEN
			PSE_FLAT_TAXES(p_TAX_CHARGE, p_TAX_COMPONENT, p_TAX_PRIOR_CHARGE_ID, p_GEOGRAPHY_ID, p_CHARGE_ID, v_WORK_ID);
		END IF;
	END IF;

	UT.PURGE_RTO_WORK(v_WORK_ID);

EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			UT.PURGE_RTO_WORK(v_WORK_ID);
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE;
		END;
		ERRS.LOG_AND_RAISE;

END PSE_CALCULATE_TAXES;
---------------------------------------------------------------------------------------------------
FUNCTION GET_GEOGRAPHY_FOR_OBJECT
	(
    p_DOMAIN_ALIAS IN VARCHAR2,
    p_ENTITY_ID IN NUMBER,
    p_CATEGORY_NAME IN VARCHAR2
    ) RETURN NUMBER IS
v_GEOGRAPHY_ID NUMBER;
BEGIN
	SELECT C.GEOGRAPHY_ID
    INTO v_GEOGRAPHY_ID
    FROM ENTITY_DOMAIN A,
    	CATEGORY B,
        ENTITY_DOMAIN_ADDRESS C
	WHERE A.ENTITY_DOMAIN_TABLE_ALIAS = p_DOMAIN_ALIAS
    	AND UPPER(B.CATEGORY_NAME) = UPPER(p_CATEGORY_NAME)
        AND C.ENTITY_DOMAIN_ID = A.ENTITY_DOMAIN_ID
        AND C.OWNER_ENTITY_ID = p_ENTITY_ID
        AND C.CATEGORY_ID = B.CATEGORY_ID
        AND ROWNUM = 1;

	RETURN NVL(v_GEOGRAPHY_ID,0);
EXCEPTION
	WHEN NO_DATA_FOUND THEN
    	RETURN 0;
END GET_GEOGRAPHY_FOR_OBJECT;
---------------------------------------------------------------------------------------------------
FUNCTION GET_PSE_TAX_GEOGRAPHY_ID
	(
    p_SERVICE_POINT_ID IN NUMBER,
    p_ENTITY_ID IN NUMBER
    ) RETURN NUMBER IS
v_GEOGRAPHY_ID NUMBER;
BEGIN
	v_GEOGRAPHY_ID := GET_GEOGRAPHY_FOR_OBJECT('SERVICE_POINT',p_SERVICE_POINT_ID,'LOCALE');
    IF v_GEOGRAPHY_ID = 0 THEN
		v_GEOGRAPHY_ID := GET_GEOGRAPHY_FOR_OBJECT('PSE',p_ENTITY_ID,'LOCALE');
    END IF;

	RETURN v_GEOGRAPHY_ID;
END GET_PSE_TAX_GEOGRAPHY_ID;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_TAX_CHARGE
	(
	p_CONTRACT_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_CHARGE_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE
	) AS
v_PRIOR_CHARGE_ID NUMBER;
v_TAX_CHARGE TAX_CHARGE%ROWTYPE;
v_GEOGRAPHY_ID NUMBER;
CURSOR c_CHARGES IS
	SELECT B.ENTITY_ID,
    	B.PRODUCT_ID,
		B.COMPONENT_ID,
		B.CHARGE_ID,
		B.CHARGE_VIEW_TYPE,
		C.SERVICE_POINT_ID
	FROM BILLING_STATEMENT A,
		BILLING_STATEMENT B,
		COMPONENT C
	WHERE A.CHARGE_ID = p_CHARGE_ID
		AND B.ENTITY_ID = A.ENTITY_ID
		AND B.STATEMENT_TYPE = A.STATEMENT_TYPE
		AND B.STATEMENT_STATE = A.STATEMENT_STATE
		AND B.STATEMENT_DATE = A.STATEMENT_DATE
		AND B.AS_OF_DATE = A.AS_OF_DATE
		AND C.COMPONENT_ID = B.COMPONENT_ID
		AND UPPER(C.CHARGE_TYPE) <> 'TAX'
		AND C.IS_TAXED = 1;

BEGIN
	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Tax Charge (CONTRACT_ID=' || p_CONTRACT_ID || '; SCHEDULE_TYPE=' || p_SCHEDULE_TYPE || '; STATEMENT_TYPE=' || p_STATEMENT_TYPE ||
			'; CHARGE_ID=' || p_CHARGE_ID || '; COMPONENT=' || p_COMPONENT.COMPONENT_NAME || '(' || p_COMPONENT.COMPONENT_ID || ')' ||
			'; BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE,'MM/DD/YYYY') || '; END_DATE=' || TO_CHAR(p_END_DATE,'MM/DD/YYYY') ||
			'; AS_OF_DATE=' || TO_CHAR(p_AS_OF_DATE,'MM/DD/YYYY HH24:MI')||')');
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('PSE_TAX_CHARGE');
		LOGS.LOG_DEBUG('CONTRACT_ID=' || TO_CHAR(p_CONTRACT_ID));
	    LOGS.LOG_DEBUG('<id>,<date>,<peak date>,<quantity>,<point>,<charge quantity>,<rate>,<factor>,<amount>');
	END IF;

	v_PRIOR_CHARGE_ID := GET_PRIOR_CHARGE_ID(p_CHARGE_ID);
	v_TAX_CHARGE.CHARGE_ID := p_CHARGE_ID;
	v_TAX_CHARGE.CHARGE_FACTOR := GET_COMPONENT_FACTOR(p_COMPONENT.COMPONENT_ID, p_BEGIN_DATE);

	FOR v_CHARGE IN c_CHARGES LOOP
		v_TAX_CHARGE.PRODUCT_ID := v_CHARGE.PRODUCT_ID;
		v_TAX_CHARGE.COMPONENT_ID := v_CHARGE.COMPONENT_ID;
		v_TAX_CHARGE.SERVICE_POINT_ID := v_CHARGE.SERVICE_POINT_ID;
        v_GEOGRAPHY_ID := GET_PSE_TAX_GEOGRAPHY_ID(v_CHARGE.SERVICE_POINT_ID,v_CHARGE.ENTITY_ID);
		PSE_CALCULATE_TAXES(v_TAX_CHARGE, p_COMPONENT, v_PRIOR_CHARGE_ID, v_GEOGRAPHY_ID, v_CHARGE.CHARGE_ID, v_CHARGE.CHARGE_VIEW_TYPE, p_SCHEDULE_TYPE, p_AS_OF_DATE);
	END LOOP;

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Tax Charge - Completed Successfully');
	END IF;

END PSE_TAX_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE APPLY_FTR_AUCTION
	(
	p_PSE_ID IN NUMBER,
    p_CONTRACT_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_CHARGE_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_TRANSMISSION_CHARGE TRANSMISSION_CHARGE%ROWTYPE;
v_PRIOR_CHARGE_ID NUMBER;

CURSOR c_RESERVATIONS IS
	SELECT A.TRANSACTION_NAME,
		A.TRANSACTION_ID,
		SUM(NVL(D.AMOUNT,0)) "CAPACITY_RESERVED",
        AVG(NVL(D.PRICE,0)) "CHARGE_RATE",
        SUM(NVL(D.AMOUNT,0)*NVL(D.PRICE,0)) "CHARGE_AMOUNT"
	FROM INTERCHANGE_TRANSACTION A,
		IT_STATUS B,
		IT_COMMODITY C,
		IT_SCHEDULE D
	WHERE A.BEGIN_DATE <= TRUNC(p_END_DATE)
		AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
		AND A.CONTRACT_ID = p_CONTRACT_ID
		AND A.POD_ID = DECODE(p_COMPONENT.SERVICE_POINT_ID, g_NOT_ASSIGNED, A.POD_ID, p_COMPONENT.SERVICE_POINT_ID)
        AND ((UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) = 'PU' AND A.SELLER_ID = p_PSE_ID)
        	OR (UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) = 'SA' AND A.PURCHASER_ID = p_PSE_ID))
		AND B.TRANSACTION_ID = A.TRANSACTION_ID
		AND B.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_STATUS
			WHERE TRANSACTION_ID = B.TRANSACTION_ID
				AND AS_OF_DATE <= p_AS_OF_DATE)
		AND B.TRANSACTION_IS_ACTIVE = 1
		AND C.COMMODITY_ID = A.COMMODITY_ID
		AND UPPER(SUBSTR(C.COMMODITY_TYPE,1,1)) = 'T'
		AND D.TRANSACTION_ID = A.TRANSACTION_ID
		AND D.SCHEDULE_TYPE = DECODE(g_ENABLE_SUPPLY_SCHEDULE_TYPES, 1, p_SCHEDULE_TYPE, g_NOT_ASSIGNED)
		AND D.SCHEDULE_STATE = GA.INTERNAL_STATE
		AND (D.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			OR UPPER(SUBSTR(A.TRANSACTION_INTERVAL,1,4)) = 'YEAR' AND A.BEGIN_DATE <= TRUNC(p_END_DATE) AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE))
		AND D.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_SCHEDULE
			WHERE TRANSACTION_ID = D.TRANSACTION_ID
				AND SCHEDULE_TYPE = D.SCHEDULE_TYPE
				AND SCHEDULE_STATE = D.SCHEDULE_STATE
				AND SCHEDULE_DATE = D.SCHEDULE_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE)
		GROUP BY A.TRANSACTION_NAME, A.TRANSACTION_ID;

BEGIN

	UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	v_PRIOR_CHARGE_ID := GET_PRIOR_CHARGE_ID(p_CHARGE_ID);
	v_TRANSMISSION_CHARGE.CHARGE_ID := p_CHARGE_ID;
	v_TRANSMISSION_CHARGE.CHARGE_FACTOR := GET_COMPONENT_FACTOR(p_COMPONENT.COMPONENT_ID, p_BEGIN_DATE);

	FOR v_RESERVATIONS IN c_RESERVATIONS LOOP
		v_TRANSMISSION_CHARGE.CHARGE_DATE := v_BEGIN_DATE;
		v_TRANSMISSION_CHARGE.TRANSACTION_NAME := v_RESERVATIONS.TRANSACTION_NAME;
		v_TRANSMISSION_CHARGE.TRANSACTION_ID := v_RESERVATIONS.TRANSACTION_ID;
		v_TRANSMISSION_CHARGE.CHARGE_INTERVAL := NULL; --p_COMPONENT.CHARGE_INTERVAL;
		v_TRANSMISSION_CHARGE.CAPACITY_RESERVED := v_RESERVATIONS.CAPACITY_RESERVED;
        IF v_TRANSMISSION_CHARGE.CAPACITY_RESERVED = 0 THEN
			v_TRANSMISSION_CHARGE.CHARGE_RATE := v_RESERVATIONS.CHARGE_RATE;
        ELSE
			v_TRANSMISSION_CHARGE.CHARGE_RATE := v_RESERVATIONS.CHARGE_AMOUNT/v_RESERVATIONS.CAPACITY_RESERVED;
        END IF;
		v_TRANSMISSION_CHARGE.CHARGE_AMOUNT := v_RESERVATIONS.CHARGE_AMOUNT * v_TRANSMISSION_CHARGE.CHARGE_FACTOR;
		PRIOR_TRANSMISSION_CHARGE(v_PRIOR_CHARGE_ID, v_TRANSMISSION_CHARGE);
		PUT_TRANSMISSION_CHARGE(v_TRANSMISSION_CHARGE);
	END LOOP;

END APPLY_FTR_AUCTION;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_FTR_AUCTION
	(
    p_PSE_ID IN NUMBER,
	p_CONTRACT_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_CHARGE_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Internal FTR Charge (CONTRACT_ID='  ||  TO_CHAR(p_CONTRACT_ID)  ||  '; SCHEDULE_TYPE='  ||  p_SCHEDULE_TYPE  ||  '; STATEMENT_TYPE='  ||  p_STATEMENT_TYPE  ||
					 '; CHARGE_ID='  ||  TO_CHAR(p_CHARGE_ID)  ||  '; COMPONENT='  ||  p_COMPONENT.COMPONENT_NAME  ||  '('  ||  TO_CHAR(p_COMPONENT.COMPONENT_ID)  ||  ')'  ||
					 '; BEGIN_DATE='  ||  TO_CHAR(p_BEGIN_DATE,'MM/DD/YYYY')  ||  '; END_DATE='  ||  TO_CHAR(p_END_DATE,'MM/DD/YYYY')  ||  '; AS_OF_DATE=' || TO_CHAR(p_AS_OF_DATE,'MM/DD/YYYY HH24:MI') || ')');
	END IF;

	v_BEGIN_DATE := TRUNC(p_BEGIN_DATE);

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PSE_FTR_AUCTION_TRANSMISSION');
		LOGS.LOG_DEBUG('CONTRACT_ID=' || TO_CHAR(p_CONTRACT_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_END_DATE));
		LOGS.LOG_DEBUG('<id>,<date>,<txn id>,<name>,<interval>,<capacity>,<rate>,<factor>,<amount>');
	END IF;

	WHILE v_BEGIN_DATE <= TRUNC(p_END_DATE) LOOP
   		v_END_DATE := GET_NEXT_DATE_FOR_INTERVAL(v_BEGIN_DATE, p_COMPONENT.RATE_INTERVAL);
		APPLY_FTR_AUCTION(p_PSE_ID, p_CONTRACT_ID, p_SCHEDULE_TYPE, p_CHARGE_ID, p_COMPONENT, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, p_TIME_ZONE);
		v_BEGIN_DATE := v_END_DATE + 1;
	END LOOP;

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Internal FTR Charge - Completed Successfully');
	END IF;

END PSE_FTR_AUCTION;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_INTERNAL_TRANSMISSION
	(
	p_CONTRACT_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_CHARGE_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_TRANSMISSION_CHARGE TRANSMISSION_CHARGE%ROWTYPE;
v_PRIOR_CHARGE_ID NUMBER;

CURSOR c_RESERVATIONS IS
	SELECT A.TRANSACTION_NAME,
		A.TRANSACTION_ID,
		A.TRANSACTION_INTERVAL "CHARGE_INTERVAL",
		D.SCHEDULE_DATE "CHARGE_DATE",
		D.AMOUNT "CAPACITY_RESERVED",
		D.PRICE "CHARGE_RATE"
	FROM INTERCHANGE_TRANSACTION A,
		IT_STATUS B,
		IT_COMMODITY C,
		IT_SCHEDULE D
	WHERE A.BEGIN_DATE <= TRUNC(p_END_DATE)
		AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
		AND A.CONTRACT_ID = p_CONTRACT_ID
		AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) IN ('PU','NO')
		AND UPPER(A.TRANSACTION_INTERVAL) =  UPPER(p_COMPONENT.RATE_INTERVAL)
		AND A.POD_ID = DECODE(p_COMPONENT.SERVICE_POINT_ID, g_NOT_ASSIGNED, A.POD_ID, p_COMPONENT.SERVICE_POINT_ID)
        AND A.IS_FIRM = DECODE(UPPER(SUBSTR(p_COMPONENT.FIRM_NON_FIRM,1,1)),'N',0,'F',1,A.IS_FIRM)
		AND B.TRANSACTION_ID = A.TRANSACTION_ID
		AND B.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_STATUS
			WHERE TRANSACTION_ID = B.TRANSACTION_ID
				AND AS_OF_DATE <= p_AS_OF_DATE)
		AND B.TRANSACTION_IS_ACTIVE = 1
		AND C.COMMODITY_ID = A.COMMODITY_ID
		AND UPPER(SUBSTR(C.COMMODITY_TYPE,1,1)) = 'T'
		AND D.TRANSACTION_ID = A.TRANSACTION_ID
		AND D.SCHEDULE_TYPE = DECODE(g_ENABLE_SUPPLY_SCHEDULE_TYPES, 1, p_SCHEDULE_TYPE, g_NOT_ASSIGNED)
		AND D.SCHEDULE_STATE = GA.INTERNAL_STATE
		AND (D.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			OR UPPER(SUBSTR(A.TRANSACTION_INTERVAL,1,4)) = 'YEAR' AND A.BEGIN_DATE <= TRUNC(p_END_DATE) AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE))
		AND D.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_SCHEDULE
			WHERE TRANSACTION_ID = D.TRANSACTION_ID
				AND SCHEDULE_TYPE = D.SCHEDULE_TYPE
				AND SCHEDULE_STATE = D.SCHEDULE_STATE
				AND SCHEDULE_DATE = D.SCHEDULE_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE);

BEGIN
	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Internal Transmission Charge (CONTRACT_ID='  ||  TO_CHAR(p_CONTRACT_ID)  ||  '; SCHEDULE_TYPE='  ||  p_SCHEDULE_TYPE  ||  '; STATEMENT_TYPE='  ||  p_STATEMENT_TYPE  ||
					 '; CHARGE_ID='  ||  TO_CHAR(p_CHARGE_ID)  ||  '; COMPONENT='  ||  p_COMPONENT.COMPONENT_NAME  ||  '('  ||  TO_CHAR(p_COMPONENT.COMPONENT_ID)  ||  ')'  ||
					 '; BEGIN_DATE='  ||  TO_CHAR(p_BEGIN_DATE,'MM/DD/YYYY')  ||  '; END_DATE='  ||  TO_CHAR(p_END_DATE,'MM/DD/YYYY')  ||  '; AS_OF_DATE=' || TO_CHAR(p_AS_OF_DATE,'MM/DD/YYYY HH24:MI')||')');
	END IF;

	IF UPPER(SUBSTR(p_COMPONENT.RATE_INTERVAL,1,2)) IN ('DA','WE','MO','YE') THEN
		v_BEGIN_DATE := p_BEGIN_DATE;
		v_END_DATE := p_END_DATE + 1;
	ELSE
		UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PSE_INTERNAL_TRANSMISSION');
		LOGS.LOG_DEBUG('CONTRACT_ID=' || TO_CHAR(p_CONTRACT_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_END_DATE));
		LOGS.LOG_DEBUG('<id>,<date>,<txn id>,<name>,<interval>,<capacity>,<rate>,<factor>,<amount>');
	END IF;

	v_PRIOR_CHARGE_ID := GET_PRIOR_CHARGE_ID(p_CHARGE_ID);
	v_TRANSMISSION_CHARGE.CHARGE_ID := p_CHARGE_ID;
	v_TRANSMISSION_CHARGE.CHARGE_FACTOR := GET_COMPONENT_FACTOR(p_COMPONENT.COMPONENT_ID, p_BEGIN_DATE);

	FOR v_RESERVATIONS IN c_RESERVATIONS LOOP
		v_TRANSMISSION_CHARGE.CHARGE_DATE := v_RESERVATIONS.CHARGE_DATE;
		v_TRANSMISSION_CHARGE.TRANSACTION_NAME := v_RESERVATIONS.TRANSACTION_NAME;
		v_TRANSMISSION_CHARGE.TRANSACTION_ID := v_RESERVATIONS.TRANSACTION_ID;
		v_TRANSMISSION_CHARGE.CHARGE_INTERVAL := v_RESERVATIONS.CHARGE_INTERVAL;
		v_TRANSMISSION_CHARGE.CAPACITY_RESERVED := v_RESERVATIONS.CAPACITY_RESERVED;
		IF UPPER(SUBSTR(v_RESERVATIONS.CHARGE_INTERVAL,1,4)) = 'YEAR' THEN
			v_RESERVATIONS.CHARGE_RATE := v_RESERVATIONS.CHARGE_RATE / 12.0;
		END IF;
		v_TRANSMISSION_CHARGE.CHARGE_RATE := v_RESERVATIONS.CHARGE_RATE;
		v_TRANSMISSION_CHARGE.CHARGE_AMOUNT := v_RESERVATIONS.CAPACITY_RESERVED * v_RESERVATIONS.CHARGE_RATE * v_TRANSMISSION_CHARGE.CHARGE_FACTOR;
		PRIOR_TRANSMISSION_CHARGE(v_PRIOR_CHARGE_ID, v_TRANSMISSION_CHARGE);
		PUT_TRANSMISSION_CHARGE(v_TRANSMISSION_CHARGE);
	END LOOP;

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Internal Transmission Charge - Completed Successfully');
	END IF;

END PSE_INTERNAL_TRANSMISSION;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_UNITS_FACTOR(
	p_INTERVAL IN VARCHAR,
	p_UNITS_FACTOR OUT NUMBER
	) AS
BEGIN
	-- determine the multiplier needed to convert MWH to MW based on the interval
	SELECT DECODE(UPPER(SUBSTR(p_INTERVAL,1,3)),'5 M', 12, '10 ', 6, '15 ', 4, '20 ', 3, '30 ', 2, 1)
	INTO p_UNITS_FACTOR FROM DUAL;

	IF p_UNITS_FACTOR = 0 THEN
		p_UNITS_FACTOR := 1;
	END IF;
EXCEPTION
	WHEN OTHERS THEN
		p_UNITS_FACTOR := 1;
END GET_UNITS_FACTOR;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_INTERNAL_CHARGE
    (
	p_CONTRACT_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_CHARGE_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_BILLING_CHARGE BILLING_CHARGE%ROWTYPE;
v_PRIOR_CHARGE_ID NUMBER;
v_UNITS_FACTOR NUMBER := 1;

CURSOR c_ENERGY IS
    SELECT D.SCHEDULE_DATE "CHARGE_DATE",
		SUM(NVL(D.AMOUNT*DECODE(UPPER(C.COMMODITY_UNIT||p_COMPONENT.QUANTITY_UNIT),'MWHMW',v_UNITS_FACTOR,'MWMWH',1/v_UNITS_FACTOR,1),0)*DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)),'PU',1,'NO',1,'GE',1,'SA',-1,'LO',-1,0)) "CHARGE_QUANTITY",
		SUM(NVL(D.AMOUNT*DECODE(UPPER(C.COMMODITY_UNIT||p_COMPONENT.QUANTITY_UNIT),'MWHMW',v_UNITS_FACTOR,'MWMWH',1/v_UNITS_FACTOR,1),0)*DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)),'PU',1,'NO',1,'GE',1,'SA',-1,'LO',-1,0)*NVL(D.PRICE,0)) "CHARGE_AMOUNT",
		AVG(NVL(D.PRICE,0)) "AVERAGE_PRICE"
	FROM INTERCHANGE_TRANSACTION A,
		IT_STATUS B,
	    IT_COMMODITY C,
	    IT_SCHEDULE D
	WHERE A.BEGIN_DATE <= TRUNC(p_END_DATE)
		AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
		AND A.CONTRACT_ID = p_CONTRACT_ID
		AND UPPER(A.TRANSACTION_INTERVAL) =  UPPER(p_COMPONENT.RATE_INTERVAL)
		AND A.POD_ID = DECODE(p_COMPONENT.SERVICE_POINT_ID, g_NOT_ASSIGNED, A.POD_ID, p_COMPONENT.SERVICE_POINT_ID)
		AND B.TRANSACTION_ID = A.TRANSACTION_ID
		AND B.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_STATUS
			WHERE TRANSACTION_ID = B.TRANSACTION_ID
				AND AS_OF_DATE <= p_AS_OF_DATE)
		AND B.TRANSACTION_IS_ACTIVE = 1
	    AND C.COMMODITY_ID = A.COMMODITY_ID
		AND UPPER(SUBSTR(C.COMMODITY_TYPE,1,1)) = UPPER(SUBSTR(p_COMPONENT.CHARGE_TYPE,1,1))
	    AND D.TRANSACTION_ID = A.TRANSACTION_ID
		AND D.SCHEDULE_TYPE = DECODE(g_ENABLE_SUPPLY_SCHEDULE_TYPES, 1, p_SCHEDULE_TYPE, g_NOT_ASSIGNED)
		AND D.SCHEDULE_STATE = GA.INTERNAL_STATE
		AND (D.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			OR UPPER(SUBSTR(A.TRANSACTION_INTERVAL,1,4)) = 'YEAR' AND A.BEGIN_DATE <= TRUNC(p_END_DATE) AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE))
		AND D.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_SCHEDULE
			WHERE TRANSACTION_ID = D.TRANSACTION_ID
				AND SCHEDULE_TYPE = D.SCHEDULE_TYPE
				AND SCHEDULE_STATE = D.SCHEDULE_STATE
				AND SCHEDULE_DATE = D.SCHEDULE_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE)
	GROUP BY D.SCHEDULE_DATE;

BEGIN

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Internal Charge (CONTRACT_ID=' || p_CONTRACT_ID || '; SCHEDULE_TYPE=' || p_SCHEDULE_TYPE || '; STATEMENT_TYPE=' || p_STATEMENT_TYPE ||
			'; CHARGE_ID=' || p_CHARGE_ID || '; COMPONENT=' || p_COMPONENT.COMPONENT_NAME || '(' || p_COMPONENT.COMPONENT_ID || ')' ||
			'; BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE,'MM/DD/YYYY') || '; END_DATE=' || TO_CHAR(p_END_DATE,'MM/DD/YYYY') ||
			'; AS_OF_DATE=' || TO_CHAR(p_AS_OF_DATE,'MM/DD/YYYY HH24:MI')||')');
	END IF;

	IF UPPER(SUBSTR(p_COMPONENT.RATE_INTERVAL,1,2)) IN ('DA','WE','MO','YE') THEN
	    v_BEGIN_DATE := p_BEGIN_DATE;
		v_END_DATE := p_END_DATE + 1;
	ELSE
	    UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	END IF;
	GET_UNITS_FACTOR(p_COMPONENT.RATE_INTERVAL, v_UNITS_FACTOR);

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('PSE_INTERNAL_CHARGE');
		LOGS.LOG_DEBUG('CONTRACT_ID=' || TO_CHAR(p_CONTRACT_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_END_DATE));
	    LOGS.LOG_DEBUG('<id>,<date>,<peak date>,<quantity>,<point>,<charge quantity>,<rate>,<factor>,<amount>');
	END IF;

	v_PRIOR_CHARGE_ID := GET_PRIOR_CHARGE_ID(p_CHARGE_ID);
	v_BILLING_CHARGE.CHARGE_ID := p_CHARGE_ID;
	v_BILLING_CHARGE.CHARGE_FACTOR := GET_COMPONENT_FACTOR(p_COMPONENT.COMPONENT_ID, v_BEGIN_DATE);
	v_BILLING_CHARGE.SERVICE_POINT_ID := p_COMPONENT.SERVICE_POINT_ID;

	FOR v_ENERGY IN c_ENERGY LOOP
		v_BILLING_CHARGE.CHARGE_DATE := v_ENERGY.CHARGE_DATE;
		v_BILLING_CHARGE.PEAK_QUANTITY := NULL;
		v_BILLING_CHARGE.PEAK_DATE := NULL;
		v_BILLING_CHARGE.CHARGE_QUANTITY := v_ENERGY.CHARGE_QUANTITY;
		v_BILLING_CHARGE.CHARGE_AMOUNT := v_ENERGY.CHARGE_AMOUNT * v_BILLING_CHARGE.CHARGE_FACTOR;
		IF v_ENERGY.CHARGE_QUANTITY = 0 THEN
			v_BILLING_CHARGE.CHARGE_RATE := v_ENERGY.AVERAGE_PRICE;
		ELSE
			v_BILLING_CHARGE.CHARGE_RATE := v_ENERGY.CHARGE_AMOUNT / v_ENERGY.CHARGE_QUANTITY;
		END IF;
		PRIOR_BILLING_CHARGE(v_PRIOR_CHARGE_ID, v_BILLING_CHARGE);
		PUT_BILLING_CHARGE(v_BILLING_CHARGE);
	END LOOP;

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Internal charge - Completed Successfully');
	END IF;

END PSE_INTERNAL_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_MARKET_CHARGE
    (
	p_CONTRACT_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_CHARGE_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_BILLING_CHARGE BILLING_CHARGE%ROWTYPE;
v_PRIOR_CHARGE_ID NUMBER;
v_UNITS_FACTOR NUMBER := 1;

CURSOR c_ENERGY IS
    SELECT D.SCHEDULE_DATE "CHARGE_DATE",
		SUM(NVL(D.AMOUNT*DECODE(UPPER(C.COMMODITY_UNIT||p_COMPONENT.QUANTITY_UNIT),'MWHMW',v_UNITS_FACTOR,'MWMWH',1/v_UNITS_FACTOR,1),0)*DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)),'PU',1,'NO',1,'GE',1,'SA',-1,'LO',-1,0)) "CHARGE_QUANTITY",
		F.PRICE*NVL(E.RATE_MULTIPLIER,1)+NVL(E.RATE_ADDER,0) "CHARGE_RATE"
	FROM INTERCHANGE_TRANSACTION A,
		IT_STATUS B,
	    IT_COMMODITY C,
	    IT_SCHEDULE D,
		COMPONENT_MARKET_PRICE E,
		MARKET_PRICE_VALUE F
	WHERE A.BEGIN_DATE <= TRUNC(p_END_DATE)
		AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
		AND A.CONTRACT_ID = p_CONTRACT_ID
		AND UPPER(A.TRANSACTION_INTERVAL) =  UPPER(p_COMPONENT.RATE_INTERVAL)
		AND A.POD_ID = DECODE(p_COMPONENT.SERVICE_POINT_ID, g_NOT_ASSIGNED, A.POD_ID, p_COMPONENT.SERVICE_POINT_ID)
		AND B.TRANSACTION_ID = A.TRANSACTION_ID
		AND B.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_STATUS
			WHERE TRANSACTION_ID = B.TRANSACTION_ID
				AND AS_OF_DATE <= p_AS_OF_DATE)
		AND B.TRANSACTION_IS_ACTIVE = 1
	    AND C.COMMODITY_ID = A.COMMODITY_ID
		AND UPPER(SUBSTR(C.COMMODITY_TYPE,1,1)) = UPPER(SUBSTR(p_COMPONENT.CHARGE_TYPE,1,1))
	    AND D.TRANSACTION_ID = A.TRANSACTION_ID
		AND D.SCHEDULE_TYPE = DECODE(g_ENABLE_SUPPLY_SCHEDULE_TYPES, 1, p_SCHEDULE_TYPE, g_NOT_ASSIGNED)
		AND D.SCHEDULE_STATE = GA.INTERNAL_STATE
		AND (D.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			OR UPPER(SUBSTR(A.TRANSACTION_INTERVAL,1,4)) = 'YEAR' AND A.BEGIN_DATE <= TRUNC(p_END_DATE) AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE))
		AND D.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_SCHEDULE
			WHERE TRANSACTION_ID = D.TRANSACTION_ID
				AND SCHEDULE_TYPE = D.SCHEDULE_TYPE
				AND SCHEDULE_STATE = D.SCHEDULE_STATE
				AND SCHEDULE_DATE = D.SCHEDULE_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE)
		AND E.COMPONENT_ID = p_COMPONENT.COMPONENT_ID
        AND E.SUB_COMPONENT_TYPE = g_NO_SUB_TYPE
        AND E.SUB_COMPONENT_ID = g_NOT_ASSIGNED
		AND D.SCHEDULE_DATE BETWEEN E.BEGIN_DATE AND NVL(E.END_DATE,CONSTANTS.HIGH_DATE)
		AND F.MARKET_PRICE_ID = p_COMPONENT.MARKET_PRICE_ID
		AND F.PRICE_CODE IN ('F','P','A')
		AND F.PRICE_DATE = TRUNC(D.SCHEDULE_DATE,'MI')
        AND F.PRICE_CODE =
        	(SELECT DECODE(MAX(DECODE(PRICE_CODE,'F',1,'P',2,'A',3)),1,'F',2,'P',3,'A')
        	FROM MARKET_PRICE_VALUE
            WHERE MARKET_PRICE_ID = F.MARKET_PRICE_ID
            	AND PRICE_CODE IN ('F','P','A')
                AND PRICE_DATE = F.PRICE_DATE)
		AND F.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM MARKET_PRICE_VALUE
			WHERE MARKET_PRICE_ID = F.MARKET_PRICE_ID
				AND PRICE_CODE = F.PRICE_CODE
				AND PRICE_DATE = F.PRICE_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE)
	GROUP BY D.SCHEDULE_DATE, F.PRICE*NVL(E.RATE_MULTIPLIER,1)+NVL(E.RATE_ADDER,0);

BEGIN

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Market Charge (CONTRACT_ID=' || p_CONTRACT_ID || '; SCHEDULE_TYPE=' || p_SCHEDULE_TYPE || '; STATEMENT_TYPE=' || p_STATEMENT_TYPE ||
			'; CHARGE_ID=' || p_CHARGE_ID || '; COMPONENT=' || p_COMPONENT.COMPONENT_NAME || '(' || p_COMPONENT.COMPONENT_ID || ')' ||
			'; BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE,'MM/DD/YYYY') || '; END_DATE=' || TO_CHAR(p_END_DATE,'MM/DD/YYYY') ||
			'; AS_OF_DATE=' || TO_CHAR(p_AS_OF_DATE,'MM/DD/YYYY HH24:MI')||')');
	END IF;

	IF UPPER(SUBSTR(p_COMPONENT.RATE_INTERVAL,1,2)) IN ('DA','WE','MO','YE') THEN
	    v_BEGIN_DATE := p_BEGIN_DATE;
		v_END_DATE := p_END_DATE + 1;
	ELSE
	    UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	END IF;
	GET_UNITS_FACTOR(p_COMPONENT.RATE_INTERVAL, v_UNITS_FACTOR);

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('PSE_MARKET_CHARGE');
		LOGS.LOG_DEBUG('CONTRACT_ID=' || TO_CHAR(p_CONTRACT_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_END_DATE));
	    LOGS.LOG_DEBUG('<id>,<date>,<peak date>,<quantity>,<point>,<charge quantity>,<rate>,<factor>,<amount>');
	END IF;

	v_PRIOR_CHARGE_ID := GET_PRIOR_CHARGE_ID(p_CHARGE_ID);
	v_BILLING_CHARGE.CHARGE_ID := p_CHARGE_ID;
	v_BILLING_CHARGE.CHARGE_FACTOR := GET_COMPONENT_FACTOR(p_COMPONENT.COMPONENT_ID, v_BEGIN_DATE);
	v_BILLING_CHARGE.SERVICE_POINT_ID := p_COMPONENT.SERVICE_POINT_ID;

	FOR v_ENERGY IN c_ENERGY LOOP
		v_BILLING_CHARGE.CHARGE_DATE := v_ENERGY.CHARGE_DATE;
		v_BILLING_CHARGE.PEAK_QUANTITY := NULL;
		v_BILLING_CHARGE.PEAK_DATE := NULL;
		v_BILLING_CHARGE.CHARGE_QUANTITY := v_ENERGY.CHARGE_QUANTITY;
		v_BILLING_CHARGE.CHARGE_RATE := v_ENERGY.CHARGE_RATE;
		v_BILLING_CHARGE.CHARGE_AMOUNT := v_BILLING_CHARGE.CHARGE_QUANTITY * v_BILLING_CHARGE.CHARGE_RATE * v_BILLING_CHARGE.CHARGE_FACTOR;
		PRIOR_BILLING_CHARGE(v_PRIOR_CHARGE_ID, v_BILLING_CHARGE);
		PUT_BILLING_CHARGE(v_BILLING_CHARGE);
	END LOOP;

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Market Charge - Completed Successfully');
	END IF;

END PSE_MARKET_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_BLOCK_CHARGE
	(
	p_CONTRACT_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_CHARGE_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_BILLING_CHARGE BILLING_CHARGE%ROWTYPE;
v_PRIOR_CHARGE_ID NUMBER;
v_UNITS_FACTOR NUMBER := 1;
v_TZ VARCHAR2(8);

CURSOR c_ENERGY IS
	SELECT A.CHARGE_DATE,
		A.CHARGE_QUANTITY,
		B.RATE "CHARGE_RATE",
		GREATEST(B.CHARGE_MIN, B.RATE*A.CHARGE_QUANTITY) "CHARGE_AMOUNT"
	FROM (SELECT D.SCHEDULE_DATE "CHARGE_DATE",
			SUM(NVL(D.AMOUNT*DECODE(UPPER(C.COMMODITY_UNIT||p_COMPONENT.QUANTITY_UNIT),'MWHMW',v_UNITS_FACTOR,'MWMWH',1/v_UNITS_FACTOR,1),0)*DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)),'PU',1,'NO',1,'GE',1,'SA',-1,'LO',-1,0)) "CHARGE_QUANTITY"
		FROM INTERCHANGE_TRANSACTION A,
			IT_STATUS B,
			IT_COMMODITY C,
			IT_SCHEDULE D
		WHERE A.BEGIN_DATE <= TRUNC(p_END_DATE)
			AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
			AND A.CONTRACT_ID = p_CONTRACT_ID
			AND UPPER(A.TRANSACTION_INTERVAL) =  UPPER(p_COMPONENT.RATE_INTERVAL)
			AND A.POD_ID = DECODE(p_COMPONENT.SERVICE_POINT_ID, g_NOT_ASSIGNED, A.POD_ID, p_COMPONENT.SERVICE_POINT_ID)
			AND B.TRANSACTION_ID = A.TRANSACTION_ID
			AND B.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM IT_STATUS
				WHERE TRANSACTION_ID = B.TRANSACTION_ID
					AND AS_OF_DATE <= p_AS_OF_DATE)
			AND B.TRANSACTION_IS_ACTIVE = 1
			AND C.COMMODITY_ID = A.COMMODITY_ID
			AND UPPER(SUBSTR(C.COMMODITY_TYPE,1,1)) = UPPER(SUBSTR(p_COMPONENT.CHARGE_TYPE,1,1))
			AND D.TRANSACTION_ID = A.TRANSACTION_ID
			AND D.SCHEDULE_TYPE = DECODE(g_ENABLE_SUPPLY_SCHEDULE_TYPES, 1, p_SCHEDULE_TYPE, g_NOT_ASSIGNED)
			AND D.SCHEDULE_STATE = GA.INTERNAL_STATE
			AND (D.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				OR UPPER(SUBSTR(A.TRANSACTION_INTERVAL,1,4)) = 'YEAR' AND A.BEGIN_DATE <= TRUNC(p_END_DATE) AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE))
			AND D.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM IT_SCHEDULE
				WHERE TRANSACTION_ID = D.TRANSACTION_ID
					AND SCHEDULE_TYPE = D.SCHEDULE_TYPE
					AND SCHEDULE_STATE = D.SCHEDULE_STATE
					AND SCHEDULE_DATE = D.SCHEDULE_DATE
					AND AS_OF_DATE <= p_AS_OF_DATE)
		GROUP BY D.SCHEDULE_DATE) A,
		COMPONENT_BLOCK_RATE B
	WHERE B.COMPONENT_ID = p_COMPONENT.COMPONENT_ID
    	AND B.SUB_COMPONENT_TYPE = g_NO_SUB_TYPE
        AND B.SUB_COMPONENT_ID = g_NOT_ASSIGNED
		AND TRUNC(FROM_CUT(A.CHARGE_DATE,v_TZ)) BETWEEN B.BEGIN_DATE AND NVL(B.END_DATE,CONSTANTS.HIGH_DATE)
		AND A.CHARGE_QUANTITY > B.BLOCK_MIN-1
		AND A.CHARGE_QUANTITY <= NVL(B.BLOCK_MAX,A.CHARGE_QUANTITY);

BEGIN

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Block Rate Charge (CONTRACT_ID=' || p_CONTRACT_ID || '; SCHEDULE_TYPE=' || p_SCHEDULE_TYPE || '; STATEMENT_TYPE=' || p_STATEMENT_TYPE ||
			'; CHARGE_ID=' || p_CHARGE_ID || '; COMPONENT=' || p_COMPONENT.COMPONENT_NAME || '(' || p_COMPONENT.COMPONENT_ID || ')' ||
			'; BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE,'MM/DD/YYYY') || '; END_DATE=' || TO_CHAR(p_END_DATE,'MM/DD/YYYY') ||
			'; AS_OF_DATE=' || TO_CHAR(p_AS_OF_DATE,'MM/DD/YYYY HH24:MI')||')');
	END IF;

	IF UPPER(SUBSTR(p_COMPONENT.RATE_INTERVAL,1,2)) IN ('DA','WE','MO','YE') THEN
	    v_BEGIN_DATE := p_BEGIN_DATE;
		v_END_DATE := p_END_DATE + 1;
        v_TZ := GA.CUT_TIME_ZONE;
	ELSE
	    UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
        v_TZ := p_TIME_ZONE;
	END IF;
	GET_UNITS_FACTOR(p_COMPONENT.RATE_INTERVAL, v_UNITS_FACTOR);

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('PSE_BLOCK_CHARGE');
		LOGS.LOG_DEBUG('CONTRACT_ID=' || TO_CHAR(p_CONTRACT_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_END_DATE));
	    LOGS.LOG_DEBUG('<id>,<date>,<peak date>,<quantity>,<point>,<charge quantity>,<rate>,<factor>,<amount>');
	END IF;

	v_PRIOR_CHARGE_ID := GET_PRIOR_CHARGE_ID(p_CHARGE_ID);
	v_BILLING_CHARGE.CHARGE_ID := p_CHARGE_ID;
	v_BILLING_CHARGE.CHARGE_FACTOR := GET_COMPONENT_FACTOR(p_COMPONENT.COMPONENT_ID, v_BEGIN_DATE);
	v_BILLING_CHARGE.SERVICE_POINT_ID := p_COMPONENT.SERVICE_POINT_ID;

	FOR v_ENERGY IN c_ENERGY LOOP
		v_BILLING_CHARGE.CHARGE_DATE := v_ENERGY.CHARGE_DATE;
		v_BILLING_CHARGE.PEAK_QUANTITY := NULL;
		v_BILLING_CHARGE.PEAK_DATE := NULL;
		v_BILLING_CHARGE.CHARGE_QUANTITY := v_ENERGY.CHARGE_QUANTITY;
		v_BILLING_CHARGE.CHARGE_RATE := v_ENERGY.CHARGE_RATE;
		v_BILLING_CHARGE.CHARGE_AMOUNT := v_ENERGY.CHARGE_AMOUNT * v_BILLING_CHARGE.CHARGE_FACTOR;
		PRIOR_BILLING_CHARGE(v_PRIOR_CHARGE_ID, v_BILLING_CHARGE);
		PUT_BILLING_CHARGE(v_BILLING_CHARGE);
	END LOOP;

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Block Rate Charge - Completed Successfully');
	END IF;

END PSE_BLOCK_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_TIERED_CHARGE
	(
	p_CONTRACT_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_CHARGE_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_BILLING_CHARGE BILLING_CHARGE%ROWTYPE;
v_PRIOR_CHARGE_ID NUMBER;
v_UNITS_FACTOR NUMBER := 1;
v_TZ VARCHAR2(8);

CURSOR c_ENERGY IS
	SELECT A.CHARGE_DATE,
		A.CHARGE_QUANTITY,
		MAX(B.RATE) "CHARGE_RATE",
		SUM(GREATEST(B.CHARGE_MIN, B.RATE * (LEAST(NVL(B.BLOCK_MAX,A.CHARGE_QUANTITY), A.CHARGE_QUANTITY) - DECODE(B.BLOCK_MIN,0,0,B.BLOCK_MIN-1)))) "CHARGE_AMOUNT"
	FROM (SELECT D.SCHEDULE_DATE "CHARGE_DATE",
			SUM(NVL(D.AMOUNT*DECODE(UPPER(C.COMMODITY_UNIT||p_COMPONENT.QUANTITY_UNIT),'MWHMW',v_UNITS_FACTOR,'MWMWH',1/v_UNITS_FACTOR,1),0)*DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)),'PU',1,'NO',1,'GE',1,'SA',-1,'LO',-1,0)) "CHARGE_QUANTITY"
		FROM INTERCHANGE_TRANSACTION A,
			IT_STATUS B,
			IT_COMMODITY C,
			IT_SCHEDULE D
		WHERE A.BEGIN_DATE <= TRUNC(p_END_DATE)
			AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
			AND A.CONTRACT_ID = p_CONTRACT_ID
			AND UPPER(A.TRANSACTION_INTERVAL) =  UPPER(p_COMPONENT.RATE_INTERVAL)
			AND A.POD_ID = DECODE(p_COMPONENT.SERVICE_POINT_ID, g_NOT_ASSIGNED, A.POD_ID, p_COMPONENT.SERVICE_POINT_ID)
			AND B.TRANSACTION_ID = A.TRANSACTION_ID
			AND B.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM IT_STATUS
				WHERE TRANSACTION_ID = B.TRANSACTION_ID
					AND AS_OF_DATE <= p_AS_OF_DATE)
			AND B.TRANSACTION_IS_ACTIVE = 1
			AND C.COMMODITY_ID = A.COMMODITY_ID
			AND UPPER(SUBSTR(C.COMMODITY_TYPE,1,1)) = UPPER(SUBSTR(p_COMPONENT.CHARGE_TYPE,1,1))
			AND D.TRANSACTION_ID = A.TRANSACTION_ID
			AND D.SCHEDULE_TYPE = DECODE(g_ENABLE_SUPPLY_SCHEDULE_TYPES, 1, p_SCHEDULE_TYPE, g_NOT_ASSIGNED)
			AND D.SCHEDULE_STATE = GA.INTERNAL_STATE
			AND (D.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				OR UPPER(SUBSTR(A.TRANSACTION_INTERVAL,1,4)) = 'YEAR' AND A.BEGIN_DATE <= TRUNC(p_END_DATE) AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE))
			AND D.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM IT_SCHEDULE
				WHERE TRANSACTION_ID = D.TRANSACTION_ID
					AND SCHEDULE_TYPE = D.SCHEDULE_TYPE
					AND SCHEDULE_STATE = D.SCHEDULE_STATE
					AND SCHEDULE_DATE = D.SCHEDULE_DATE
					AND AS_OF_DATE <= p_AS_OF_DATE)
		GROUP BY D.SCHEDULE_DATE) A,
		COMPONENT_BLOCK_RATE B
	WHERE B.COMPONENT_ID = p_COMPONENT.COMPONENT_ID
    	AND B.SUB_COMPONENT_TYPE = g_NO_SUB_TYPE
        AND B.SUB_COMPONENT_ID = g_NOT_ASSIGNED
		AND TRUNC(FROM_CUT(A.CHARGE_DATE,v_TZ)) BETWEEN B.BEGIN_DATE AND NVL(B.END_DATE,CONSTANTS.HIGH_DATE)
		AND A.CHARGE_QUANTITY > B.BLOCK_MIN-1
	GROUP BY A.CHARGE_DATE, A.CHARGE_QUANTITY;

BEGIN

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Tiered Rate Charge (CONTRACT_ID=' || p_CONTRACT_ID || '; SCHEDULE_TYPE=' || p_SCHEDULE_TYPE || '; STATEMENT_TYPE=' || p_STATEMENT_TYPE ||
			'; CHARGE_ID=' || p_CHARGE_ID || '; COMPONENT=' || p_COMPONENT.COMPONENT_NAME || '(' || p_COMPONENT.COMPONENT_ID || ')' ||
			'; BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE,'MM/DD/YYYY') || '; END_DATE=' || TO_CHAR(p_END_DATE,'MM/DD/YYYY') ||
			'; AS_OF_DATE=' || TO_CHAR(p_AS_OF_DATE,'MM/DD/YYYY HH24:MI')||')');
	END IF;

	IF UPPER(SUBSTR(p_COMPONENT.RATE_INTERVAL,1,2)) IN ('DA','WE','MO','YE') THEN
	    v_BEGIN_DATE := p_BEGIN_DATE;
		v_END_DATE := p_END_DATE + 1;
        v_TZ := GA.CUT_TIME_ZONE;
	ELSE
	    UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
        v_TZ := p_TIME_ZONE;
	END IF;
	GET_UNITS_FACTOR(p_COMPONENT.RATE_INTERVAL, v_UNITS_FACTOR);

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('PSE_TIERED_CHARGE');
		LOGS.LOG_DEBUG('CONTRACT_ID=' || TO_CHAR(p_CONTRACT_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_END_DATE));
	    LOGS.LOG_DEBUG('<id>,<date>,<peak date>,<quantity>,<point>,<charge quantity>,<rate>,<factor>,<amount>');
	END IF;

	v_PRIOR_CHARGE_ID := GET_PRIOR_CHARGE_ID(p_CHARGE_ID);
	v_BILLING_CHARGE.CHARGE_ID := p_CHARGE_ID;
	v_BILLING_CHARGE.CHARGE_FACTOR := GET_COMPONENT_FACTOR(p_COMPONENT.COMPONENT_ID, v_BEGIN_DATE);
	v_BILLING_CHARGE.SERVICE_POINT_ID := p_COMPONENT.SERVICE_POINT_ID;

	FOR v_ENERGY IN c_ENERGY LOOP
		v_BILLING_CHARGE.CHARGE_DATE := v_ENERGY.CHARGE_DATE;
		v_BILLING_CHARGE.PEAK_QUANTITY := NULL;
		v_BILLING_CHARGE.PEAK_DATE := NULL;
		v_BILLING_CHARGE.CHARGE_QUANTITY := v_ENERGY.CHARGE_QUANTITY;
		v_BILLING_CHARGE.CHARGE_RATE := v_ENERGY.CHARGE_RATE;
		v_BILLING_CHARGE.CHARGE_AMOUNT := v_ENERGY.CHARGE_AMOUNT * v_BILLING_CHARGE.CHARGE_FACTOR;
		PRIOR_BILLING_CHARGE(v_PRIOR_CHARGE_ID, v_BILLING_CHARGE);
		PUT_BILLING_CHARGE(v_BILLING_CHARGE);
	END LOOP;

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Tiered Rate Charge - Completed Successfully');
	END IF;

END PSE_TIERED_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_TOU_CHARGE
	(
	p_CONTRACT_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_CHARGE_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_BILLING_CHARGE BILLING_CHARGE%ROWTYPE;
v_PRIOR_CHARGE_ID NUMBER;
v_UNITS_FACTOR NUMBER := 1;
v_TZ VARCHAR2(8);

CURSOR c_ENERGY IS
	SELECT A.CHARGE_DATE,
		A.CHARGE_QUANTITY,
		D.RATE "CHARGE_RATE"
	FROM (SELECT D.SCHEDULE_DATE "CHARGE_DATE",
			SUM(NVL(D.AMOUNT,0*DECODE(UPPER(C.COMMODITY_UNIT||p_COMPONENT.QUANTITY_UNIT),'MWHMW',v_UNITS_FACTOR,'MWMWH',1/v_UNITS_FACTOR,1))*DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)),'PU',1,'NO',1,'GE',1,'SA',-1,'LO',-1,0)) "CHARGE_QUANTITY"
		FROM INTERCHANGE_TRANSACTION A,
			IT_STATUS B,
			IT_COMMODITY C,
			IT_SCHEDULE D
		WHERE A.BEGIN_DATE <= TRUNC(p_END_DATE)
			AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
			AND A.CONTRACT_ID = p_CONTRACT_ID
			AND UPPER(A.TRANSACTION_INTERVAL) =  UPPER(p_COMPONENT.RATE_INTERVAL)
			AND A.POD_ID = DECODE(p_COMPONENT.SERVICE_POINT_ID, g_NOT_ASSIGNED, A.POD_ID, p_COMPONENT.SERVICE_POINT_ID)
			AND B.TRANSACTION_ID = A.TRANSACTION_ID
			AND B.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM IT_STATUS
				WHERE TRANSACTION_ID = B.TRANSACTION_ID
					AND AS_OF_DATE <= p_AS_OF_DATE)
			AND B.TRANSACTION_IS_ACTIVE = 1
			AND C.COMMODITY_ID = A.COMMODITY_ID
			AND UPPER(SUBSTR(C.COMMODITY_TYPE,1,1)) = UPPER(SUBSTR(p_COMPONENT.CHARGE_TYPE,1,1))
			AND D.TRANSACTION_ID = A.TRANSACTION_ID
			AND D.SCHEDULE_TYPE = DECODE(g_ENABLE_SUPPLY_SCHEDULE_TYPES, 1, p_SCHEDULE_TYPE, g_NOT_ASSIGNED)
			AND D.SCHEDULE_STATE = GA.INTERNAL_STATE
			AND (D.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				OR UPPER(SUBSTR(A.TRANSACTION_INTERVAL,1,4)) = 'YEAR' AND A.BEGIN_DATE <= TRUNC(p_END_DATE) AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE))
			AND D.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM IT_SCHEDULE
				WHERE TRANSACTION_ID = D.TRANSACTION_ID
					AND SCHEDULE_TYPE = D.SCHEDULE_TYPE
					AND SCHEDULE_STATE = D.SCHEDULE_STATE
					AND SCHEDULE_DATE = D.SCHEDULE_DATE
					AND AS_OF_DATE <= p_AS_OF_DATE)
		GROUP BY D.SCHEDULE_DATE) A,
		TEMPLATE_DATES TD,
		TEMPLATE_DAY_TYPE_PERIOD DT,
		COMPONENT_TOU_RATE D
	WHERE A.CHARGE_DATE > TD.CUT_BEGIN_DATE
		AND A.CHARGE_DATE <= TD.CUT_END_DATE
		AND TD.TEMPLATE_ID = p_COMPONENT.TEMPLATE_ID
		AND TD.TIME_ZONE = v_TZ
		AND TD.HOLIDAY_SET_ID = CONSTANTS.NOT_ASSIGNED
		AND DT.DAY_TYPE_ID = TD.DAY_TYPE_ID
		AND A.CHARGE_DATE = (TD.CUT_BEGIN_DATE + DT.TIME_STAMP)
        AND D.COMPONENT_ID = p_COMPONENT.COMPONENT_ID
        AND D.SUB_COMPONENT_TYPE = g_NO_SUB_TYPE
        AND D.SUB_COMPONENT_ID = g_NOT_ASSIGNED
		AND D.PERIOD_ID = DT.PERIOD_ID
        AND TRUNC(FROM_CUT(A.CHARGE_DATE,v_TZ)) BETWEEN D.BEGIN_DATE AND NVL(D.END_DATE,CONSTANTS.HIGH_DATE);

BEGIN

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Time-Of-Use Charge (CONTRACT_ID=' || p_CONTRACT_ID || '; SCHEDULE_TYPE=' || p_SCHEDULE_TYPE || '; STATEMENT_TYPE=' || p_STATEMENT_TYPE ||
			'; CHARGE_ID=' || p_CHARGE_ID || '; COMPONENT=' || p_COMPONENT.COMPONENT_NAME || '(' || p_COMPONENT.COMPONENT_ID || ')' ||
			'; BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE,'MM/DD/YYYY') || '; END_DATE=' || TO_CHAR(p_END_DATE,'MM/DD/YYYY') ||
			'; AS_OF_DATE=' || TO_CHAR(p_AS_OF_DATE,'MM/DD/YYYY HH24:MI')||')');
	END IF;

	SP.CHECK_TEMPLATE_DATES(p_COMPONENT.TEMPLATE_ID,
							CONSTANTS.NOT_ASSIGNED,
							p_TIME_ZONE,
							p_BEGIN_DATE,
							p_END_DATE);

	IF UPPER(SUBSTR(p_COMPONENT.RATE_INTERVAL,1,2)) IN ('DA','WE','MO','YE') THEN
	    v_BEGIN_DATE := p_BEGIN_DATE;
		v_END_DATE := p_END_DATE + 1;
        v_TZ := GA.CUT_TIME_ZONE;
	ELSE
	    UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
        v_TZ := p_TIME_ZONE;
	END IF;
	GET_UNITS_FACTOR(p_COMPONENT.RATE_INTERVAL, v_UNITS_FACTOR);

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('PSE_TOU_CHARGE');
		LOGS.LOG_DEBUG('CONTRACT_ID=' || TO_CHAR(p_CONTRACT_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_END_DATE));
	    LOGS.LOG_DEBUG('<id>,<date>,<peak date>,<quantity>,<point>,<charge quantity>,<rate>,<factor>,<amount>');
	END IF;

	v_PRIOR_CHARGE_ID := GET_PRIOR_CHARGE_ID(p_CHARGE_ID);
	v_BILLING_CHARGE.CHARGE_ID := p_CHARGE_ID;
	v_BILLING_CHARGE.CHARGE_FACTOR := GET_COMPONENT_FACTOR(p_COMPONENT.COMPONENT_ID, v_BEGIN_DATE);
	v_BILLING_CHARGE.SERVICE_POINT_ID := p_COMPONENT.SERVICE_POINT_ID;

	FOR v_ENERGY IN c_ENERGY LOOP
		v_BILLING_CHARGE.CHARGE_DATE := v_ENERGY.CHARGE_DATE;
		v_BILLING_CHARGE.PEAK_QUANTITY := NULL;
		v_BILLING_CHARGE.PEAK_DATE := NULL;
		v_BILLING_CHARGE.CHARGE_QUANTITY := v_ENERGY.CHARGE_QUANTITY;
		v_BILLING_CHARGE.CHARGE_RATE := v_ENERGY.CHARGE_RATE;
		v_BILLING_CHARGE.CHARGE_AMOUNT := v_BILLING_CHARGE.CHARGE_QUANTITY * v_BILLING_CHARGE.CHARGE_RATE * v_BILLING_CHARGE.CHARGE_FACTOR;
		PRIOR_BILLING_CHARGE(v_PRIOR_CHARGE_ID, v_BILLING_CHARGE);
		PUT_BILLING_CHARGE(v_BILLING_CHARGE);
	END LOOP;

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Time-Of-Use Charge - Completed Successfully');
	END IF;

END PSE_TOU_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_FLAT_CHARGE
	(
	p_CONTRACT_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_CHARGE_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_BILLING_CHARGE BILLING_CHARGE%ROWTYPE;
v_PRIOR_CHARGE_ID NUMBER;
v_UNITS_FACTOR NUMBER := 1;
v_TZ VARCHAR2(8);

CURSOR c_ENERGY IS
	SELECT A.CHARGE_DATE,
		A.CHARGE_QUANTITY,
		GREATEST(B.CHARGE_MIN, A.CHARGE_QUANTITY*B.RATE) "CHARGE_AMOUNT",
		B.RATE "CHARGE_RATE"
	FROM (SELECT D.SCHEDULE_DATE "CHARGE_DATE",
			SUM(NVL(D.AMOUNT*DECODE(UPPER(C.COMMODITY_UNIT||p_COMPONENT.QUANTITY_UNIT),'MWHMW',v_UNITS_FACTOR,'MWMWH',1/v_UNITS_FACTOR,1),0)*DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)),'PU',1,'NO',1,'GE',1,'SA',-1,'LO',-1,0)) "CHARGE_QUANTITY"
		FROM INTERCHANGE_TRANSACTION A,
			IT_STATUS B,
			IT_COMMODITY C,
			IT_SCHEDULE D
		WHERE A.BEGIN_DATE <= TRUNC(p_END_DATE)
			AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
			AND A.CONTRACT_ID = p_CONTRACT_ID
			AND UPPER(A.TRANSACTION_INTERVAL) =  UPPER(p_COMPONENT.RATE_INTERVAL)
			AND A.POD_ID = DECODE(p_COMPONENT.SERVICE_POINT_ID, g_NOT_ASSIGNED, A.POD_ID, p_COMPONENT.SERVICE_POINT_ID)
			AND B.TRANSACTION_ID = A.TRANSACTION_ID
			AND B.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM IT_STATUS
				WHERE TRANSACTION_ID = B.TRANSACTION_ID
					AND AS_OF_DATE <= p_AS_OF_DATE)
			AND B.TRANSACTION_IS_ACTIVE = 1
			AND C.COMMODITY_ID = A.COMMODITY_ID
			AND UPPER(SUBSTR(C.COMMODITY_TYPE,1,1)) = UPPER(SUBSTR(p_COMPONENT.CHARGE_TYPE,1,1))
			AND D.TRANSACTION_ID = A.TRANSACTION_ID
			AND D.SCHEDULE_TYPE = DECODE(g_ENABLE_SUPPLY_SCHEDULE_TYPES, 1, p_SCHEDULE_TYPE, g_NOT_ASSIGNED)
			AND D.SCHEDULE_STATE = GA.INTERNAL_STATE
			AND (D.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				OR UPPER(SUBSTR(A.TRANSACTION_INTERVAL,1,4)) = 'YEAR' AND A.BEGIN_DATE <= TRUNC(p_END_DATE) AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE))
			AND D.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM IT_SCHEDULE
				WHERE TRANSACTION_ID = D.TRANSACTION_ID
					AND SCHEDULE_TYPE = D.SCHEDULE_TYPE
					AND SCHEDULE_STATE = D.SCHEDULE_STATE
					AND SCHEDULE_DATE = D.SCHEDULE_DATE
					AND AS_OF_DATE <= p_AS_OF_DATE)
		GROUP BY D.SCHEDULE_DATE) A,
		COMPONENT_FLAT_RATE B
	WHERE TRUNC(FROM_CUT(A.CHARGE_DATE,v_TZ)) BETWEEN B.BEGIN_DATE AND NVL(B.END_DATE,CONSTANTS.HIGH_DATE)
		AND B.COMPONENT_ID = p_COMPONENT.COMPONENT_ID
        AND B.SUB_COMPONENT_TYPE = g_NO_SUB_TYPE
        AND B.SUB_COMPONENT_ID = g_NOT_ASSIGNED;

BEGIN

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Flat Charge (CONTRACT_ID=' || p_CONTRACT_ID || '; SCHEDULE_TYPE=' || p_SCHEDULE_TYPE || '; STATEMENT_TYPE=' || p_STATEMENT_TYPE ||
			'; CHARGE_ID=' || p_CHARGE_ID || '; COMPONENT=' || p_COMPONENT.COMPONENT_NAME || '(' || p_COMPONENT.COMPONENT_ID || ')' ||
			'; BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE,'MM/DD/YYYY') || '; END_DATE=' || TO_CHAR(p_END_DATE,'MM/DD/YYYY') ||
			'; AS_OF_DATE=' || TO_CHAR(p_AS_OF_DATE,'MM/DD/YYYY HH24:MI')||')');
	END IF;

	IF UPPER(SUBSTR(p_COMPONENT.RATE_INTERVAL,1,2)) IN ('DA','WE','MO','YE') THEN
	    v_BEGIN_DATE := p_BEGIN_DATE;
		v_END_DATE := p_END_DATE + 1;
        v_TZ := GA.CUT_TIME_ZONE;
	ELSE
	    UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
        v_TZ := p_TIME_ZONE;
	END IF;
	GET_UNITS_FACTOR(p_COMPONENT.RATE_INTERVAL, v_UNITS_FACTOR);

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('PSE_FLAT_CHARGE');
		LOGS.LOG_DEBUG('CONTRACT_ID=' || TO_CHAR(p_CONTRACT_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_END_DATE));
	    LOGS.LOG_DEBUG('<id>,<date>,<peak date>,<quantity>,<point>,<charge quantity>,<rate>,<factor>,<amount>');
	END IF;

	v_PRIOR_CHARGE_ID := GET_PRIOR_CHARGE_ID(p_CHARGE_ID);
	v_BILLING_CHARGE.CHARGE_ID := p_CHARGE_ID;
	v_BILLING_CHARGE.CHARGE_FACTOR := GET_COMPONENT_FACTOR(p_COMPONENT.COMPONENT_ID, v_BEGIN_DATE);
	v_BILLING_CHARGE.SERVICE_POINT_ID := p_COMPONENT.SERVICE_POINT_ID;

	FOR v_ENERGY IN c_ENERGY LOOP
		v_BILLING_CHARGE.CHARGE_DATE := v_ENERGY.CHARGE_DATE;
		v_BILLING_CHARGE.PEAK_QUANTITY := NULL;
		v_BILLING_CHARGE.PEAK_DATE := NULL;
		v_BILLING_CHARGE.CHARGE_QUANTITY := v_ENERGY.CHARGE_QUANTITY;
		v_BILLING_CHARGE.CHARGE_RATE := v_ENERGY.CHARGE_RATE;
		v_BILLING_CHARGE.CHARGE_AMOUNT := v_ENERGY.CHARGE_AMOUNT * v_BILLING_CHARGE.CHARGE_FACTOR;
		PRIOR_BILLING_CHARGE(v_PRIOR_CHARGE_ID, v_BILLING_CHARGE);
		PUT_BILLING_CHARGE(v_BILLING_CHARGE);
	END LOOP;

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Flat Charge - Completed Successfully');
	END IF;

END PSE_FLAT_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_OPER_PROFIT
    (
	p_CONTRACT_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_CHARGE_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_PRIOR_CHARGE_ID NUMBER;
v_OPER_PROFIT_CHARGE OPER_PROFIT_CHARGE%ROWTYPE;
v_IDs_WORK_ID NUMBER;
v_DATES_WORK_ID NUMBER;
v_INTERVAL VARCHAR(16);
v_UNITS_FACTOR NUMBER := 1;
v_TZ VARCHAR2(8);

CURSOR c_ENERGY IS
    SELECT A.WORK_DATE "CHARGE_DATE",
		SUM(NVL(B.AMOUNT*DECODE(UPPER(H.COMMODITY_UNIT||p_COMPONENT.QUANTITY_UNIT),'MWHMW',v_UNITS_FACTOR,'MWMWH',1/v_UNITS_FACTOR,1),0)*DECODE(UPPER(SUBSTR(A.TYPE,1,2)),'GE',1,'LO',-1,0)) "QUANTITY1",
		SUM(NVL(C.AMOUNT*DECODE(UPPER(H.COMMODITY_UNIT||p_COMPONENT.QUANTITY_UNIT),'MWHMW',v_UNITS_FACTOR,'MWMWH',1/v_UNITS_FACTOR,1),0)*DECODE(UPPER(SUBSTR(A.TYPE,1,2)),'GE',1,'LO',-1,0)) "QUANTITY2",
		SUM(NVL(D.AMOUNT*DECODE(UPPER(H.COMMODITY_UNIT||p_COMPONENT.QUANTITY_UNIT),'MWHMW',v_UNITS_FACTOR,'MWMWH',1/v_UNITS_FACTOR,1),0)*DECODE(UPPER(SUBSTR(A.TYPE,1,2)),'GE',1,'LO',-1,0)) "QUANTITY3",
		F.PRICE*NVL(E.RATE_MULTIPLIER,1)+NVL(E.RATE_ADDER,0) "CHARGE_RATE"
	FROM (SELECT A.WORK_DATE, B.WORK_XID, B.WORK_DATA "TYPE"
		FROM RTO_WORK A, RTO_WORK B
		WHERE A.WORK_ID = v_DATES_WORK_ID
			AND B.WORK_ID = v_IDs_WORK_ID) A,
	    IT_SCHEDULE B,
	    IT_SCHEDULE C,
	    IT_SCHEDULE D,
		COMPONENT_MARKET_PRICE E,
		MARKET_PRICE_VALUE F,
		INTERCHANGE_TRANSACTION G,
		IT_COMMODITY H
	WHERE G.TRANSACTION_ID = A.WORK_XID
		AND H.COMMODITY_ID = G.COMMODITY_ID
		AND B.TRANSACTION_ID (+)= A.WORK_XID
		AND B.SCHEDULE_TYPE (+)= LEAST(1, p_STATEMENT_TYPE)
		AND B.SCHEDULE_STATE (+)= GA.INTERNAL_STATE
		AND B.SCHEDULE_DATE (+)= A.WORK_DATE
		AND B.AS_OF_DATE (+)= SCHEDULE_AS_OF_DATE(A.WORK_XID,LEAST(1,p_STATEMENT_TYPE),GA.INTERNAL_STATE,A.WORK_DATE,p_AS_OF_DATE)
		AND C.TRANSACTION_ID (+)= A.WORK_XID
		AND C.SCHEDULE_TYPE (+)= LEAST(2, p_STATEMENT_TYPE)
		AND C.SCHEDULE_STATE (+)= GA.INTERNAL_STATE
		AND C.SCHEDULE_DATE (+)= A.WORK_DATE
		AND C.AS_OF_DATE (+)= SCHEDULE_AS_OF_DATE(A.WORK_XID,LEAST(1,p_STATEMENT_TYPE),GA.INTERNAL_STATE,A.WORK_DATE,p_AS_OF_DATE)
		AND D.TRANSACTION_ID (+)= A.WORK_XID
		AND D.SCHEDULE_TYPE (+)= LEAST(3, p_STATEMENT_TYPE)
		AND D.SCHEDULE_STATE (+)= GA.INTERNAL_STATE
		AND D.SCHEDULE_DATE (+)= A.WORK_DATE
		AND D.AS_OF_DATE (+)= SCHEDULE_AS_OF_DATE(A.WORK_XID,LEAST(1,p_STATEMENT_TYPE),GA.INTERNAL_STATE,A.WORK_DATE,p_AS_OF_DATE)
		AND E.COMPONENT_ID = p_COMPONENT.COMPONENT_ID
        AND E.SUB_COMPONENT_TYPE = g_NO_SUB_TYPE
        AND E.SUB_COMPONENT_ID = g_NOT_ASSIGNED
		AND TRUNC(FROM_CUT(A.WORK_DATE,v_TZ)) BETWEEN E.BEGIN_DATE AND NVL(E.END_DATE,CONSTANTS.HIGH_DATE)
		AND F.MARKET_PRICE_ID = p_COMPONENT.MARKET_PRICE_ID
		AND F.PRICE_CODE IN ('F','P','A')
		AND F.PRICE_DATE = A.WORK_DATE
        AND F.PRICE_CODE =
        	(SELECT DECODE(MAX(DECODE(PRICE_CODE,'F',1,'P',2,'A',3)),1,'F',2,'P',3,'A')
        	FROM MARKET_PRICE_VALUE
            WHERE MARKET_PRICE_ID = F.MARKET_PRICE_ID
            	AND PRICE_CODE IN ('F','P','A')
                AND PRICE_DATE = F.PRICE_DATE)
		AND F.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM MARKET_PRICE_VALUE
			WHERE MARKET_PRICE_ID = F.MARKET_PRICE_ID
				AND PRICE_CODE = F.PRICE_CODE
				AND PRICE_DATE = F.PRICE_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE)
	GROUP BY A.WORK_DATE, F.PRICE*NVL(E.RATE_MULTIPLIER,1)+NVL(E.RATE_ADDER,0);

BEGIN

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Operational Profit Charge (CONTRACT_ID=' || p_CONTRACT_ID || '; SCHEDULE_TYPE=' || p_SCHEDULE_TYPE || '; STATEMENT_TYPE=' || p_STATEMENT_TYPE ||
			'; CHARGE_ID=' || p_CHARGE_ID || '; COMPONENT=' || p_COMPONENT.COMPONENT_NAME || '(' || p_COMPONENT.COMPONENT_ID || ')' ||
			'; BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE,'MM/DD/YYYY') || '; END_DATE=' || TO_CHAR(p_END_DATE,'MM/DD/YYYY') ||
			'; AS_OF_DATE=' || TO_CHAR(p_AS_OF_DATE,'MM/DD/YYYY HH24:MI')||')');
	END IF;

	IF UPPER(SUBSTR(p_COMPONENT.RATE_INTERVAL,1,2)) IN ('DA','WE','MO','YE') THEN
	    v_BEGIN_DATE := p_BEGIN_DATE;
		v_END_DATE := p_END_DATE + 1;
        v_TZ := GA.CUT_TIME_ZONE;
	ELSE
	    UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
        v_TZ := p_TIME_ZONE;
	END IF;
	GET_UNITS_FACTOR(p_COMPONENT.RATE_INTERVAL, v_UNITS_FACTOR);

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('PSE_OPER_PROFIT');
		LOGS.LOG_DEBUG('CONTRACT_ID=' || TO_CHAR(p_CONTRACT_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_END_DATE));
	    LOGS.LOG_DEBUG('<id>,<date>,<peak date>,<quantity>,<point>,<charge quantity>,<rate>,<factor>,<amount>');
	END IF;

	v_PRIOR_CHARGE_ID := GET_PRIOR_CHARGE_ID(p_CHARGE_ID);
	v_OPER_PROFIT_CHARGE.CHARGE_ID := p_CHARGE_ID;
	v_OPER_PROFIT_CHARGE.CHARGE_FACTOR := GET_COMPONENT_FACTOR(p_COMPONENT.COMPONENT_ID, v_BEGIN_DATE);
	v_OPER_PROFIT_CHARGE.SERVICE_POINT_ID := p_COMPONENT.SERVICE_POINT_ID;
	CACHE_OPER_PROFIT_TX_IDs(v_IDs_WORK_ID, p_CONTRACT_ID, p_COMPONENT, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE);
	CACHE_OPER_PROFIT_DATES(v_DATES_WORK_ID, v_IDs_WORK_ID, p_SCHEDULE_TYPE, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE);
	CACHE_OPER_PROFIT_OFFER_CURVES(v_IDs_WORK_ID, p_CHARGE_ID, v_BEGIN_DATE, v_END_DATE, v_INTERVAL, v_UNITS_FACTOR, p_COMPONENT.QUANTITY_UNIT);

	FOR v_ENERGY IN c_ENERGY LOOP
		v_OPER_PROFIT_CHARGE.CHARGE_DATE := v_ENERGY.CHARGE_DATE;
		v_OPER_PROFIT_CHARGE.ACTUAL_QUANTITY := v_ENERGY.QUANTITY3;
		v_OPER_PROFIT_CHARGE.DISPATCH_QUANTITY := v_ENERGY.QUANTITY2;
		v_OPER_PROFIT_CHARGE.MARKET_QUANTITY := v_ENERGY.QUANTITY1;
		v_OPER_PROFIT_CHARGE.CHARGE_RATE := v_ENERGY.CHARGE_RATE;
		PSE_GET_OFFER_CURVE(v_ENERGY.CHARGE_DATE,p_CHARGE_ID,v_INTERVAL);
		PSE_COMPUTE_OPERATIONAL_PROFIT(v_OPER_PROFIT_CHARGE);
		PRIOR_OPER_PROFIT_CHARGE(v_PRIOR_CHARGE_ID, v_OPER_PROFIT_CHARGE);
		PUT_OPER_PROFIT_CHARGE(v_OPER_PROFIT_CHARGE);
	END LOOP;

	UT.PURGE_RTO_WORK(v_DATES_WORK_ID);
	UT.PURGE_RTO_WORK(v_IDs_WORK_ID);

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Operational Profit Charge - Completed Successfully');
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			UT.PURGE_RTO_WORK(v_DATES_WORK_ID);
			UT.PURGE_RTO_WORK(v_IDs_WORK_ID);
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE;
		END;
		ERRS.LOG_AND_RAISE;

END PSE_OPER_PROFIT;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_PSE_CONVERSION_AMOUNTS
	(
	p_CONTRACT_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_PEAK_DATE IN DATE,
	p_RESTRICT_INTERVAL IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_UNITS_FACTOR NUMBER := 1;
v_TZ VARCHAR2(8);

BEGIN

	IF UPPER(SUBSTR(p_COMPONENT.RATE_INTERVAL,1,2)) IN ('DA','WE','MO','YE') THEN
	    v_BEGIN_DATE := p_BEGIN_DATE;
		v_END_DATE := p_END_DATE + 1;
        v_TZ := GA.CUT_TIME_ZONE;
	ELSE
	    UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
        v_TZ := p_TIME_ZONE;
	END IF;
	GET_UNITS_FACTOR(p_COMPONENT.RATE_INTERVAL, v_UNITS_FACTOR);

	OPEN p_CURSOR FOR
    	    SELECT A.SCHEDULE_GROUP_ID,
    			E.SCHEDULE_DATE "CHARGE_DATE",
    			SUM(NVL(E.AMOUNT*DECODE(UPPER(D.COMMODITY_UNIT||p_COMPONENT.QUANTITY_UNIT),'MWHMW',v_UNITS_FACTOR,'MWMWH',1/v_UNITS_FACTOR,1),0)*DECODE(UPPER(SUBSTR(B.TRANSACTION_TYPE,1,2)),'PU',1,'NO',1,'GE',1,'SA',-1,'LO',-1,0)) "CHARGE_QUANTITY",
    			A.COEFF_X3 "A", A.COEFF_X2 "B", A.COEFF_X1 "C", A.CONST_K "D",
    			A.RATE
    		FROM COMPONENT_CONVERSION_RATE A,
    			INTERCHANGE_TRANSACTION B,
    			IT_STATUS C,
    			IT_COMMODITY D,
    			IT_SCHEDULE E
    		WHERE A.COMPONENT_ID = p_COMPONENT.COMPONENT_ID
            	AND A.SUB_COMPONENT_TYPE = g_NO_SUB_TYPE
                AND A.SUB_COMPONENT_ID = g_NOT_ASSIGNED
    			AND NOT (A.SCHEDULE_GROUP_ID IS NULL)
    			AND A.BEGIN_DATE <= TRUNC(p_END_DATE)
    			AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
    			AND B.SCHEDULE_GROUP_ID = A.SCHEDULE_GROUP_ID
    			AND B.BEGIN_DATE <= TRUNC(p_END_DATE)
    			AND NVL(B.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
    			AND B.CONTRACT_ID = p_CONTRACT_ID
    			AND ((p_RESTRICT_INTERVAL = 0) OR (UPPER(B.TRANSACTION_INTERVAL) =  UPPER(p_COMPONENT.RATE_INTERVAL)))
    			AND B.POD_ID = DECODE(p_COMPONENT.SERVICE_POINT_ID, g_NOT_ASSIGNED, B.POD_ID, p_COMPONENT.SERVICE_POINT_ID)
    			AND C.TRANSACTION_ID = B.TRANSACTION_ID
    			AND C.AS_OF_DATE =
    				(SELECT MAX(AS_OF_DATE)
    				FROM IT_STATUS
    				WHERE TRANSACTION_ID = C.TRANSACTION_ID
    					AND AS_OF_DATE <= p_AS_OF_DATE)
    			AND C.TRANSACTION_IS_ACTIVE = 1
    		    AND D.COMMODITY_ID = B.COMMODITY_ID
    		    AND E.TRANSACTION_ID = B.TRANSACTION_ID
    			AND E.SCHEDULE_TYPE = DECODE(g_ENABLE_SUPPLY_SCHEDULE_TYPES, 1, p_SCHEDULE_TYPE, g_NOT_ASSIGNED)
    			AND E.SCHEDULE_STATE = GA.INTERNAL_STATE
    			AND ((E.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE AND E.SCHEDULE_DATE BETWEEN A.BEGIN_DATE AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE))
    				OR UPPER(SUBSTR(B.TRANSACTION_INTERVAL,1,4)) = 'YEAR' AND B.BEGIN_DATE <= TRUNC(p_END_DATE) AND NVL(B.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE))
    			-- optionally get only values on peak date
    			AND ((p_PEAK_DATE IS NULL) OR (E.SCHEDULE_DATE = p_PEAK_DATE))
    			AND E.AS_OF_DATE =
    				(SELECT MAX(AS_OF_DATE)
    				FROM IT_SCHEDULE
    				WHERE TRANSACTION_ID = E.TRANSACTION_ID
    					AND SCHEDULE_TYPE = E.SCHEDULE_TYPE
    					AND SCHEDULE_STATE = E.SCHEDULE_STATE
    					AND SCHEDULE_DATE = E.SCHEDULE_DATE
    					AND AS_OF_DATE <= p_AS_OF_DATE)
    			AND TRUNC(FROM_CUT(E.SCHEDULE_DATE,v_TZ)) BETWEEN A.BEGIN_DATE AND NVL(A.END_DATE,CONSTANTS.HIGH_DATE)
    		GROUP BY A.SCHEDULE_GROUP_ID, E.SCHEDULE_DATE, A.RATE,	A.COEFF_X3, A.COEFF_X2, A.COEFF_X1, A.CONST_K;

END GET_PSE_CONVERSION_AMOUNTS;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_CONVERSION_CHARGE
    (
	p_CONTRACT_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_CHARGE_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2
	) AS

v_CONVERSION_CHARGE CONVERSION_CHARGE%ROWTYPE;
v_PRIOR_CHARGE_ID NUMBER;
v_CURSOR GA.REFCURSOR;
v_SCHEDULE_GROUP_ID NUMBER;
v_A NUMBER; v_B NUMBER; v_C NUMBER; v_D NUMBER;
v_AMOUNT NUMBER;
v_CHARGE_DATE DATE;
v_RATE NUMBER;

BEGIN

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Conversion Charge (CONTRACT_ID=' || p_CONTRACT_ID || '; SCHEDULE_TYPE=' || p_SCHEDULE_TYPE || '; STATEMENT_TYPE=' || p_STATEMENT_TYPE ||
			'; CHARGE_ID=' || p_CHARGE_ID || '; COMPONENT=' || p_COMPONENT.COMPONENT_NAME || '(' || p_COMPONENT.COMPONENT_ID || ')' ||
			'; BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE,'MM/DD/YYYY') || '; END_DATE=' || TO_CHAR(p_END_DATE,'MM/DD/YYYY') ||
			'; AS_OF_DATE=' || TO_CHAR(p_AS_OF_DATE,'MM/DD/YYYY HH24:MI')||')');
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('PSE_CONVERSION_CHARGE');
		LOGS.LOG_DEBUG('CONTRACT_ID=' || TO_CHAR(p_CONTRACT_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE));
	    LOGS.LOG_DEBUG('<id>,<date>,<peak date>,<quantity>,<point>,<charge quantity>,<rate>,<factor>,<amount>');
	END IF;

	v_PRIOR_CHARGE_ID := GET_PRIOR_CHARGE_ID(p_CHARGE_ID);
	v_CONVERSION_CHARGE.CHARGE_ID := p_CHARGE_ID;
	v_CONVERSION_CHARGE.CHARGE_FACTOR := GET_COMPONENT_FACTOR(p_COMPONENT.COMPONENT_ID, p_BEGIN_DATE);

	-- get data
	GET_PSE_CONVERSION_AMOUNTS (p_CONTRACT_ID, p_SCHEDULE_TYPE, p_COMPONENT, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE, NULL, 1, v_CURSOR);

	LOOP
		FETCH v_CURSOR INTO v_SCHEDULE_GROUP_ID, v_CHARGE_DATE, v_AMOUNT, v_A, v_B, v_C, v_D, v_RATE;
		EXIT WHEN v_CURSOR%NOTFOUND;
		v_CONVERSION_CHARGE.CHARGE_DATE := v_CHARGE_DATE;
		v_CONVERSION_CHARGE.SCHEDULE_GROUP_ID := v_SCHEDULE_GROUP_ID;
		v_CONVERSION_CHARGE.PEAK_DATE := NULL;
		v_CONVERSION_CHARGE.PEAK_DEMAND := NULL;
		v_CONVERSION_CHARGE.SCHEDULED_AMOUNT := v_AMOUNT;
		v_CONVERSION_CHARGE.COEFF_X3 := v_A;
		v_CONVERSION_CHARGE.COEFF_X2 := v_B;
		v_CONVERSION_CHARGE.COEFF_X1 := v_C;
		v_CONVERSION_CHARGE.CONST_K := v_D;
		-- apply conversion formula (3rd order polynomial)
		v_CONVERSION_CHARGE.CHARGE_QUANTITY := v_A * v_AMOUNT * v_AMOUNT * v_AMOUNT +
								   v_B * v_AMOUNT * v_AMOUNT +
								   v_C * v_AMOUNT + v_D;
		v_CONVERSION_CHARGE.CHARGE_RATE := v_RATE;
		v_CONVERSION_CHARGE.CHARGE_AMOUNT := v_CONVERSION_CHARGE.CHARGE_QUANTITY * v_CONVERSION_CHARGE.CHARGE_RATE * v_CONVERSION_CHARGE.CHARGE_FACTOR;
		PRIOR_CONVERSION_CHARGE(v_PRIOR_CHARGE_ID, v_CONVERSION_CHARGE);
		PUT_CONVERSION_CHARGE(v_CONVERSION_CHARGE);
	END LOOP;
	CLOSE v_CURSOR;

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Conversion charge - Completed Successfully');
	END IF;

END PSE_CONVERSION_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_CONVERSION_PEAK_DEMAND
	(
	p_CONTRACT_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_CHARGE_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_CONVERSION_CHARGE CONVERSION_CHARGE%ROWTYPE;
v_PRIOR_CHARGE_ID NUMBER;
v_CURSOR GA.REFCURSOR;
v_SCHEDULE_GROUP_ID NUMBER;
v_A NUMBER; v_B NUMBER; v_C NUMBER; v_D NUMBER;
v_AMOUNT NUMBER;
v_SCHEDULE_DATE DATE;
v_RATE NUMBER;
v_DAY_INTERVAL BOOLEAN;

BEGIN

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Conversion Peak Demand Charge (PSE_ID='||p_PSE_ID||'; SCHEDULE_TYPE='||p_SCHEDULE_TYPE||
			'; CHARGE_ID='||p_CHARGE_ID||'; COMPONENT='||p_COMPONENT.COMPONENT_NAME||'('||p_COMPONENT.COMPONENT_ID||')'||
			'; BEGIN_DATE='||TO_CHAR(p_BEGIN_DATE,'MM/DD/YYYY')||'; END_DATE='||TO_CHAR(p_END_DATE,'MM/DD/YYYY')||
			'; AS_OF_DATE='||TO_CHAR(p_AS_OF_DATE,'MM/DD/YYYY HH24:MI')||')');
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('PSE_CONVERSION_PEAK_DEMAND');
		LOGS.LOG_DEBUG('PSE_ID=' || TO_CHAR(p_PSE_ID));
		LOGS.LOG_DEBUG('SCHEDULE_TYPE=' || TO_CHAR(p_SCHEDULE_TYPE));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE));
	    LOGS.LOG_DEBUG('<id>,<date>,<peak date>,<quantity>,<point>,<charge quantity>,<rate>,<factor>,<amount>');
	END IF;

	v_PRIOR_CHARGE_ID := GET_PRIOR_CHARGE_ID(p_CHARGE_ID);
	v_CONVERSION_CHARGE.CHARGE_ID := p_CHARGE_ID;
	v_DAY_INTERVAL := IS_INTERVAL_DAY_OR_GREATER(p_COMPONENT.RATE_INTERVAL);

	v_BEGIN_DATE := TRUNC(p_BEGIN_DATE);
	WHILE v_BEGIN_DATE <= TRUNC(p_END_DATE) LOOP
   		v_END_DATE := GET_NEXT_DATE_FOR_INTERVAL(v_BEGIN_DATE, p_COMPONENT.RATE_INTERVAL);

		IF LOGS.IS_INFO_DETAIL_ENABLED THEN
		    LOGS.LOG_INFO_DETAIL('Conversion Peak Demand Charge - Starting time period (BEGIN_DATE='||TO_CHAR(v_BEGIN_DATE,'MM/DD/YYYY')||', END_DATE='||TO_CHAR(v_END_DATE,'MM/DD/YYYY')||')');
		END IF;

		IF v_DAY_INTERVAL THEN
			v_CONVERSION_CHARGE.CHARGE_DATE := ADD_SECONDS_TO_DATE(v_BEGIN_DATE,1);
		ELSE
			v_CONVERSION_CHARGE.CHARGE_DATE := v_BEGIN_DATE;
		END IF;
		--GET_PSE_PEAK_DEMAND_AND_DATE(p_PSE_ID, p_COMPONENT.SERVICE_POINT_ID, p_SCHEDULE_TYPE, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, v_CONVERSION_CHARGE.PEAK_DEMAND, v_CONVERSION_CHARGE.PEAK_DATE);
		GET_PSE_PEAK_DEMAND_AND_DATE(0, p_COMPONENT.SERVICE_POINT_ID, p_SCHEDULE_TYPE, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, v_CONVERSION_CHARGE.PEAK_DEMAND, v_CONVERSION_CHARGE.PEAK_DATE, p_TIME_ZONE);
		v_CONVERSION_CHARGE.CHARGE_FACTOR := GET_COMPONENT_FACTOR(p_COMPONENT.COMPONENT_ID, v_BEGIN_DATE);

		-- get data
		GET_PSE_CONVERSION_AMOUNTS (p_CONTRACT_ID, p_SCHEDULE_TYPE, p_COMPONENT, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, p_TIME_ZONE, v_CONVERSION_CHARGE.PEAK_DATE, 0, v_CURSOR);

		LOOP
			FETCH v_CURSOR INTO v_SCHEDULE_GROUP_ID, v_SCHEDULE_DATE, v_AMOUNT, v_A, v_B, v_C, v_D, v_RATE;
			EXIT WHEN v_CURSOR%NOTFOUND;

			v_CONVERSION_CHARGE.SCHEDULE_GROUP_ID := v_SCHEDULE_GROUP_ID;
			v_CONVERSION_CHARGE.SCHEDULED_AMOUNT := v_AMOUNT;
			v_CONVERSION_CHARGE.COEFF_X3 := v_A;
			v_CONVERSION_CHARGE.COEFF_X2 := v_B;
			v_CONVERSION_CHARGE.COEFF_X1 := v_C;
			v_CONVERSION_CHARGE.CONST_K := v_D;
			-- apply conversion formula (3rd order polynomial)
			v_CONVERSION_CHARGE.CHARGE_QUANTITY := v_A * v_AMOUNT * v_AMOUNT * v_AMOUNT +
									   v_B * v_AMOUNT * v_AMOUNT +
									   v_C * v_AMOUNT + v_D;
			v_CONVERSION_CHARGE.CHARGE_RATE := v_RATE;
			v_CONVERSION_CHARGE.CHARGE_AMOUNT := v_CONVERSION_CHARGE.CHARGE_QUANTITY * v_CONVERSION_CHARGE.CHARGE_RATE * v_CONVERSION_CHARGE.CHARGE_FACTOR;

			PRIOR_CONVERSION_CHARGE(v_PRIOR_CHARGE_ID, v_CONVERSION_CHARGE);
			PUT_CONVERSION_CHARGE(v_CONVERSION_CHARGE);
		END LOOP;
		CLOSE v_CURSOR;

		v_BEGIN_DATE := v_END_DATE + 1;

		IF LOGS.IS_INFO_DETAIL_ENABLED THEN
		    LOGS.LOG_INFO_DETAIL('Conversion Peak Demand Charge - Time Period Completed');
		END IF;
	END LOOP;

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Conversion Peak Demand Charge - Completed Successfully');
	END IF;

END PSE_CONVERSION_PEAK_DEMAND;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_TOU_TRANSMISSION
	(
	p_CONTRACT_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_CHARGE_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_TRANSMISSION_CHARGE TRANSMISSION_CHARGE%ROWTYPE;
v_PRIOR_CHARGE_ID NUMBER;
v_TZ VARCHAR2(8);

CURSOR c_TRANSMISSION IS
	SELECT A.TRANSACTION_NAME,
		A.TRANSACTION_ID,
        A.TRANSACTION_INTERVAL "CHARGE_INTERVAL",
		D.SCHEDULE_DATE "CHARGE_DATE",
		D.AMOUNT "CAPACITY_RESERVED",
		G.RATE "CHARGE_RATE"
	FROM INTERCHANGE_TRANSACTION A,
		IT_STATUS B,
		IT_COMMODITY C,
		IT_SCHEDULE D,
		TEMPLATE_DATES TD,
		TEMPLATE_DAY_TYPE_PERIOD DT,
		COMPONENT_TOU_RATE G
	WHERE A.BEGIN_DATE <= TRUNC(p_END_DATE)
		AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
		AND A.CONTRACT_ID = p_CONTRACT_ID
		AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) IN ('PU','NO')
		AND UPPER(A.TRANSACTION_INTERVAL) =  UPPER(p_COMPONENT.RATE_INTERVAL)
		AND A.POD_ID = DECODE(p_COMPONENT.SERVICE_POINT_ID, g_NOT_ASSIGNED, A.POD_ID, p_COMPONENT.SERVICE_POINT_ID)
        AND A.IS_FIRM = DECODE(UPPER(SUBSTR(p_COMPONENT.FIRM_NON_FIRM,1,1)),'N',0,'F',1,A.IS_FIRM)
		AND B.TRANSACTION_ID = A.TRANSACTION_ID
		AND B.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_STATUS
			WHERE TRANSACTION_ID = B.TRANSACTION_ID
				AND AS_OF_DATE <= p_AS_OF_DATE)
		AND B.TRANSACTION_IS_ACTIVE = 1
		AND C.COMMODITY_ID = A.COMMODITY_ID
		AND UPPER(SUBSTR(C.COMMODITY_TYPE,1,1)) = 'T'
		AND D.TRANSACTION_ID = A.TRANSACTION_ID
		AND D.SCHEDULE_TYPE = DECODE(g_ENABLE_SUPPLY_SCHEDULE_TYPES, 1, p_SCHEDULE_TYPE, g_NOT_ASSIGNED)
		AND D.SCHEDULE_STATE = GA.INTERNAL_STATE
		AND (D.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			OR UPPER(SUBSTR(A.TRANSACTION_INTERVAL,1,4)) = 'YEAR' AND A.BEGIN_DATE <= TRUNC(p_END_DATE) AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE))
		AND D.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_SCHEDULE
			WHERE TRANSACTION_ID = D.TRANSACTION_ID
				AND SCHEDULE_TYPE = D.SCHEDULE_TYPE
				AND SCHEDULE_STATE = D.SCHEDULE_STATE
				AND SCHEDULE_DATE = D.SCHEDULE_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE)
		AND TD.TEMPLATE_ID = p_COMPONENT.TEMPLATE_ID
		AND TD.TIME_ZONE = v_TZ
		AND TD.HOLIDAY_SET_ID = CONSTANTS.NOT_ASSIGNED
		AND D.SCHEDULE_DATE > TD.CUT_BEGIN_DATE
		AND D.SCHEDULE_DATE <= TD.CUT_END_DATE
		AND TD.DAY_TYPE_ID = DT.DAY_TYPE_ID
		AND D.SCHEDULE_DATE = TD.CUT_BEGIN_DATE + DT.TIME_STAMP
        AND G.COMPONENT_ID = p_COMPONENT.COMPONENT_ID
        AND G.SUB_COMPONENT_TYPE = g_NO_SUB_TYPE
        AND G.SUB_COMPONENT_ID = g_NOT_ASSIGNED
		AND G.PERIOD_ID = DT.PERIOD_ID
		AND TRUNC(FROM_CUT(D.SCHEDULE_DATE,v_TZ)) BETWEEN G.BEGIN_DATE AND NVL(G.END_DATE,CONSTANTS.HIGH_DATE);

BEGIN

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Time-Of-Use Transmission Charge (CONTRACT_ID=' || p_CONTRACT_ID || '; SCHEDULE_TYPE=' || p_SCHEDULE_TYPE || '; STATEMENT_TYPE=' || p_STATEMENT_TYPE ||
			'; CHARGE_ID=' || p_CHARGE_ID || '; COMPONENT=' || p_COMPONENT.COMPONENT_NAME || '(' || p_COMPONENT.COMPONENT_ID || ')' ||
			'; BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE,'MM/DD/YYYY') || '; END_DATE=' || TO_CHAR(p_END_DATE,'MM/DD/YYYY') ||
			'; AS_OF_DATE=' || TO_CHAR(p_AS_OF_DATE,'MM/DD/YYYY HH24:MI')||')');
	END IF;

	IF UPPER(SUBSTR(p_COMPONENT.RATE_INTERVAL,1,2)) IN ('DA','WE','MO','YE') THEN
	    v_BEGIN_DATE := p_BEGIN_DATE;
		v_END_DATE := p_END_DATE + 1;
        v_TZ := GA.CUT_TIME_ZONE;
	ELSE
	    UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
        v_TZ := p_TIME_ZONE;
	END IF;

	SP.CHECK_TEMPLATE_DATES(p_COMPONENT.TEMPLATE_ID,
							CONSTANTS.NOT_ASSIGNED,
							v_TZ,
							p_BEGIN_DATE,
							p_END_DATE);

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('PSE_TOU_TRANSMISSION');
		LOGS.LOG_DEBUG('CONTRACT_ID=' || TO_CHAR(p_CONTRACT_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_END_DATE));
	    LOGS.LOG_DEBUG('<id>,<date>,<txn id>,<name>,<interval>,<capacity>,<rate>,<factor>,<amount>');
	END IF;

	v_PRIOR_CHARGE_ID := GET_PRIOR_CHARGE_ID(p_CHARGE_ID);
	v_TRANSMISSION_CHARGE.CHARGE_ID := p_CHARGE_ID;
	v_TRANSMISSION_CHARGE.CHARGE_FACTOR := GET_COMPONENT_FACTOR(p_COMPONENT.COMPONENT_ID, p_BEGIN_DATE);

	FOR v_TRANSMISSION IN c_TRANSMISSION LOOP

		IF IS_OASIS_SERVICE_SCHEDULE(v_TRANSMISSION.TRANSACTION_ID, p_COMPONENT.COMPONENT_REFERENCE) THEN
		    v_TRANSMISSION_CHARGE.CHARGE_DATE := v_TRANSMISSION.CHARGE_DATE;
			v_TRANSMISSION_CHARGE.TRANSACTION_NAME := v_TRANSMISSION.TRANSACTION_NAME;
			v_TRANSMISSION_CHARGE.TRANSACTION_ID := v_TRANSMISSION.TRANSACTION_ID;
			v_TRANSMISSION_CHARGE.CHARGE_INTERVAL := p_COMPONENT.RATE_INTERVAL;
			v_TRANSMISSION_CHARGE.CAPACITY_RESERVED := v_TRANSMISSION.CAPACITY_RESERVED;
			v_TRANSMISSION_CHARGE.CHARGE_RATE := v_TRANSMISSION.CHARGE_RATE;
			IF UPPER(SUBSTR(v_TRANSMISSION.CHARGE_INTERVAL,1,4)) = 'YEAR' THEN
				v_TRANSMISSION_CHARGE.CHARGE_RATE := v_TRANSMISSION_CHARGE.CHARGE_RATE/12;
			END IF;
			v_TRANSMISSION_CHARGE.CHARGE_AMOUNT := v_TRANSMISSION.CAPACITY_RESERVED * v_TRANSMISSION_CHARGE.CHARGE_RATE * v_TRANSMISSION_CHARGE.CHARGE_FACTOR;
			PRIOR_TRANSMISSION_CHARGE(v_PRIOR_CHARGE_ID, v_TRANSMISSION_CHARGE);
			PUT_TRANSMISSION_CHARGE(v_TRANSMISSION_CHARGE);
		END IF;

	END LOOP;

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Time-Of-Use Transmission Charge - Completed Successfully');
	END IF;

END PSE_TOU_TRANSMISSION;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_FLAT_TRANSMISSION
	(
	p_CONTRACT_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_CHARGE_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_TRANSMISSION_CHARGE TRANSMISSION_CHARGE%ROWTYPE;
v_PRIOR_CHARGE_ID NUMBER;
v_TZ VARCHAR2(8);

CURSOR c_TRANSMISSION IS
    SELECT A.TRANSACTION_NAME,
	    A.TRANSACTION_ID,
		A.TRANSACTION_INTERVAL "CHARGE_INTERVAL",
	    D.SCHEDULE_DATE "CHARGE_DATE",
		D.AMOUNT "CAPACITY_RESERVED"
	FROM INTERCHANGE_TRANSACTION A,
		IT_STATUS B,
	    IT_COMMODITY C,
	    IT_SCHEDULE D
	WHERE A.BEGIN_DATE <= TRUNC(p_END_DATE)
		AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
		AND A.CONTRACT_ID = p_CONTRACT_ID
		AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) IN ('PU','NO')
		AND UPPER(A.TRANSACTION_INTERVAL) =  UPPER(p_COMPONENT.RATE_INTERVAL)
		AND A.POD_ID = DECODE(p_COMPONENT.SERVICE_POINT_ID, g_NOT_ASSIGNED, A.POD_ID, p_COMPONENT.SERVICE_POINT_ID)
        AND A.IS_FIRM = DECODE(UPPER(SUBSTR(p_COMPONENT.FIRM_NON_FIRM,1,1)),'N',0,'F',1,A.IS_FIRM)
		AND B.TRANSACTION_ID = A.TRANSACTION_ID
		AND B.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_STATUS
			WHERE TRANSACTION_ID = B.TRANSACTION_ID
				AND AS_OF_DATE <= p_AS_OF_DATE)
		AND B.TRANSACTION_IS_ACTIVE = 1
		AND C.COMMODITY_ID = A.COMMODITY_ID
		AND UPPER(SUBSTR(C.COMMODITY_TYPE,1,1)) = 'T'
		AND D.TRANSACTION_ID = A.TRANSACTION_ID
		AND D.SCHEDULE_TYPE = DECODE(g_ENABLE_SUPPLY_SCHEDULE_TYPES, 1, p_SCHEDULE_TYPE, g_NOT_ASSIGNED)
		AND D.SCHEDULE_STATE = GA.INTERNAL_STATE
		AND (D.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			OR UPPER(SUBSTR(A.TRANSACTION_INTERVAL,1,4)) = 'YEAR' AND A.BEGIN_DATE <= TRUNC(p_END_DATE) AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE))
		AND D.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_SCHEDULE
			WHERE TRANSACTION_ID = D.TRANSACTION_ID
				AND SCHEDULE_TYPE = D.SCHEDULE_TYPE
				AND SCHEDULE_STATE = D.SCHEDULE_STATE
				AND SCHEDULE_DATE = D.SCHEDULE_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE);

BEGIN

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Flat Transmission Charge (CONTRACT_ID=' || p_CONTRACT_ID || '; SCHEDULE_TYPE=' || p_SCHEDULE_TYPE || '; STATEMENT_TYPE=' || p_STATEMENT_TYPE ||
			'; CHARGE_ID=' || p_CHARGE_ID || '; COMPONENT=' || p_COMPONENT.COMPONENT_NAME || '(' || p_COMPONENT.COMPONENT_ID || ')' ||
			'; BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE,'MM/DD/YYYY') || '; END_DATE=' || TO_CHAR(p_END_DATE,'MM/DD/YYYY') ||
			'; AS_OF_DATE=' || TO_CHAR(p_AS_OF_DATE,'MM/DD/YYYY HH24:MI')||')');
	END IF;

	IF UPPER(SUBSTR(p_COMPONENT.RATE_INTERVAL,1,2)) IN ('DA','WE','MO','YE') THEN
	    v_BEGIN_DATE := p_BEGIN_DATE;
		v_END_DATE := p_END_DATE + 1;
        v_TZ := GA.CUT_TIME_ZONE;
	ELSE
	    UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
        v_TZ := p_TIME_ZONE;
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('PSE_FLAT_TRANSMISSION');
		LOGS.LOG_DEBUG('CONTRACT_ID=' || TO_CHAR(p_CONTRACT_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_END_DATE));
	    LOGS.LOG_DEBUG('<id>,<date>,<txn id>,<name>,<interval>,<capacity>,<rate>,<factor>,<amount>');
	END IF;

	v_PRIOR_CHARGE_ID := GET_PRIOR_CHARGE_ID(p_CHARGE_ID);
	v_TRANSMISSION_CHARGE.CHARGE_ID := p_CHARGE_ID;
	v_TRANSMISSION_CHARGE.CHARGE_FACTOR := GET_COMPONENT_FACTOR(p_COMPONENT.COMPONENT_ID, p_BEGIN_DATE);

	FOR v_TRANSMISSION IN c_TRANSMISSION LOOP

		IF IS_OASIS_SERVICE_SCHEDULE(v_TRANSMISSION.TRANSACTION_ID, p_COMPONENT.COMPONENT_REFERENCE) THEN
		    v_TRANSMISSION_CHARGE.CHARGE_DATE := v_TRANSMISSION.CHARGE_DATE;
			v_TRANSMISSION_CHARGE.TRANSACTION_NAME := v_TRANSMISSION.TRANSACTION_NAME;
			v_TRANSMISSION_CHARGE.TRANSACTION_ID := v_TRANSMISSION.TRANSACTION_ID;
			v_TRANSMISSION_CHARGE.CHARGE_INTERVAL := p_COMPONENT.RATE_INTERVAL;
			v_TRANSMISSION_CHARGE.CAPACITY_RESERVED := v_TRANSMISSION.CAPACITY_RESERVED;
			v_TRANSMISSION_CHARGE.CHARGE_RATE := GET_COMPONENT_FLAT_RATE(p_COMPONENT.COMPONENT_ID, FROM_CUT(v_TRANSMISSION.CHARGE_DATE,v_TZ));
			IF UPPER(SUBSTR(v_TRANSMISSION.CHARGE_INTERVAL,1,4)) = 'YEAR' THEN
				v_TRANSMISSION_CHARGE.CHARGE_RATE := v_TRANSMISSION_CHARGE.CHARGE_RATE/12;
			END IF;
			v_TRANSMISSION_CHARGE.CHARGE_AMOUNT := v_TRANSMISSION.CAPACITY_RESERVED * v_TRANSMISSION_CHARGE.CHARGE_RATE * v_TRANSMISSION_CHARGE.CHARGE_FACTOR;
			PRIOR_TRANSMISSION_CHARGE(v_PRIOR_CHARGE_ID, v_TRANSMISSION_CHARGE);
			PUT_TRANSMISSION_CHARGE(v_TRANSMISSION_CHARGE);
		END IF;

	END LOOP;

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Flat Transmission Charge - Completed Successfully');
	END IF;

END PSE_FLAT_TRANSMISSION;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_FLAT_PEAK_DEMAND
	(
	p_PSE_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_CHARGE_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_BILLING_CHARGE BILLING_CHARGE%ROWTYPE;
v_PRIOR_CHARGE_ID NUMBER;
v_DAY_INTERVAL BOOLEAN;

BEGIN

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Flat Peak Demand Charge (PSE_ID='||p_PSE_ID||'; SCHEDULE_TYPE='||p_SCHEDULE_TYPE||
			'; CHARGE_ID='||p_CHARGE_ID||'; COMPONENT='||p_COMPONENT.COMPONENT_NAME||'('||p_COMPONENT.COMPONENT_ID||')'||
			'; BEGIN_DATE='||TO_CHAR(p_BEGIN_DATE,'MM/DD/YYYY')||'; END_DATE='||TO_CHAR(p_END_DATE,'MM/DD/YYYY')||
			'; AS_OF_DATE='||TO_CHAR(p_AS_OF_DATE,'MM/DD/YYYY HH24:MI')||')');
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('PSE_FLAT_PEAK_DEMAND');
		LOGS.LOG_DEBUG('PSE_ID=' || TO_CHAR(p_PSE_ID));
		LOGS.LOG_DEBUG('SCHEDULE_TYPE=' || TO_CHAR(p_SCHEDULE_TYPE));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE));
	    LOGS.LOG_DEBUG('<id>,<date>,<peak date>,<quantity>,<point>,<charge quantity>,<rate>,<factor>,<amount>');
	END IF;

	v_PRIOR_CHARGE_ID := GET_PRIOR_CHARGE_ID(p_CHARGE_ID);
	v_BILLING_CHARGE.CHARGE_ID := p_CHARGE_ID;
	v_BILLING_CHARGE.SERVICE_POINT_ID := p_COMPONENT.SERVICE_POINT_ID;
	v_DAY_INTERVAL := IS_INTERVAL_DAY_OR_GREATER(p_COMPONENT.RATE_STRUCTURE);

	v_BEGIN_DATE := TRUNC(p_BEGIN_DATE);
	WHILE v_BEGIN_DATE <= TRUNC(p_END_DATE) LOOP
   		v_END_DATE := GET_NEXT_DATE_FOR_INTERVAL(v_BEGIN_DATE, p_COMPONENT.RATE_INTERVAL);

		IF LOGS.IS_INFO_DETAIL_ENABLED THEN
		    LOGS.LOG_INFO_DETAIL('Flat Peak Demand Charge - Starting time period (BEGIN_DATE='||TO_CHAR(v_BEGIN_DATE,'MM/DD/YYYY')||', END_DATE='||TO_CHAR(v_END_DATE,'MM/DD/YYYY')||')');
		END IF;

		IF v_DAY_INTERVAL THEN
			v_BILLING_CHARGE.CHARGE_DATE := ADD_SECONDS_TO_DATE(v_BEGIN_DATE,1);
		ELSE
			v_BILLING_CHARGE.CHARGE_DATE := v_BEGIN_DATE;
		END IF;
		GET_PSE_PEAK_DEMAND_AND_DATE(p_PSE_ID, p_COMPONENT.SERVICE_POINT_ID, p_SCHEDULE_TYPE, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, v_BILLING_CHARGE.PEAK_QUANTITY, v_BILLING_CHARGE.PEAK_DATE, p_TIME_ZONE);
		v_BILLING_CHARGE.CHARGE_QUANTITY := v_BILLING_CHARGE.PEAK_QUANTITY;
		v_BILLING_CHARGE.CHARGE_RATE := GET_COMPONENT_FLAT_RATE(p_COMPONENT.COMPONENT_ID, v_BEGIN_DATE);
		v_BILLING_CHARGE.CHARGE_FACTOR := GET_COMPONENT_FACTOR(p_COMPONENT.COMPONENT_ID, v_BEGIN_DATE);
		v_BILLING_CHARGE.CHARGE_AMOUNT := v_BILLING_CHARGE.CHARGE_QUANTITY * v_BILLING_CHARGE.CHARGE_RATE * v_BILLING_CHARGE.CHARGE_FACTOR;
		PRIOR_BILLING_CHARGE(v_PRIOR_CHARGE_ID, v_BILLING_CHARGE);
		PUT_BILLING_CHARGE(v_BILLING_CHARGE);
		v_BEGIN_DATE := v_END_DATE + 1;

		IF LOGS.IS_INFO_DETAIL_ENABLED THEN
		    LOGS.LOG_INFO_DETAIL('Flat Peak Demand Charge - Time Period Completed');
		END IF;

	END LOOP;

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Flat Peak Demand Charge - Completed Successfully');
	END IF;

END PSE_FLAT_PEAK_DEMAND;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_FLAT_SERVICE
	(
	p_CONTRACT_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_CHARGE_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_BILLING_CHARGE BILLING_CHARGE%ROWTYPE;
v_PRIOR_CHARGE_ID NUMBER;
v_DAY_INTERVAL BOOLEAN;

BEGIN

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Flat Service Charge (CONTRACT_ID='||p_CONTRACT_ID||'; STATEMENT_TYPE='||p_STATEMENT_TYPE||
			'; CHARGE_ID='||p_CHARGE_ID||'; COMPONENT='||p_COMPONENT.COMPONENT_NAME||'('||p_COMPONENT.COMPONENT_ID||')'||
			'; BEGIN_DATE='||TO_CHAR(p_BEGIN_DATE,'MM/DD/YYYY')||'; END_DATE='||TO_CHAR(p_END_DATE,'MM/DD/YYYY')||')');
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('PSE_FLAT_SERVICE');
		LOGS.LOG_DEBUG('CONTRACT_ID=' || TO_CHAR(p_CONTRACT_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_END_DATE));
	    LOGS.LOG_DEBUG('<id>,<date>,<peak date>,<quantity>,<point>,<charge quantity>,<rate>,<factor>,<amount>');
	END IF;

	v_PRIOR_CHARGE_ID := GET_PRIOR_CHARGE_ID(p_CHARGE_ID);
	v_BILLING_CHARGE.CHARGE_ID := p_CHARGE_ID;
	v_BILLING_CHARGE.SERVICE_POINT_ID := p_COMPONENT.SERVICE_POINT_ID;
	v_DAY_INTERVAL := IS_INTERVAL_DAY_OR_GREATER(p_COMPONENT.RATE_STRUCTURE);

	v_BEGIN_DATE := TRUNC(p_BEGIN_DATE);
	WHILE v_BEGIN_DATE <= TRUNC(p_END_DATE) LOOP
   		v_END_DATE := GET_NEXT_DATE_FOR_INTERVAL(v_BEGIN_DATE, p_COMPONENT.RATE_INTERVAL);

		IF LOGS.IS_INFO_DETAIL_ENABLED THEN
		    LOGS.LOG_INFO_DETAIL('Flat Service Charge - Starting time period (BEGIN_DATE='||TO_CHAR(v_BEGIN_DATE,'MM/DD/YYYY')||', END_DATE='||TO_CHAR(v_END_DATE,'MM/DD/YYYY')||')');
		END IF;

		IF v_DAY_INTERVAL THEN
			v_BILLING_CHARGE.CHARGE_DATE := ADD_SECONDS_TO_DATE(v_BEGIN_DATE,1);
		ELSE
			v_BILLING_CHARGE.CHARGE_DATE := v_BEGIN_DATE;
		END IF;
		v_BILLING_CHARGE.PEAK_QUANTITY := 0;
		v_BILLING_CHARGE.PEAK_DATE := NULL;
		v_BILLING_CHARGE.CHARGE_QUANTITY := 1;
		v_BILLING_CHARGE.CHARGE_RATE := GET_COMPONENT_FLAT_RATE(p_COMPONENT.COMPONENT_ID, v_BEGIN_DATE);
		v_BILLING_CHARGE.CHARGE_FACTOR := GET_COMPONENT_FACTOR(p_COMPONENT.COMPONENT_ID, v_BEGIN_DATE);
		v_BILLING_CHARGE.CHARGE_AMOUNT := v_BILLING_CHARGE.CHARGE_QUANTITY * v_BILLING_CHARGE.CHARGE_RATE * v_BILLING_CHARGE.CHARGE_FACTOR;
		PRIOR_BILLING_CHARGE(v_PRIOR_CHARGE_ID, v_BILLING_CHARGE);
		PUT_BILLING_CHARGE(v_BILLING_CHARGE);
		v_BEGIN_DATE := v_END_DATE + 1;

		IF LOGS.IS_INFO_DETAIL_ENABLED THEN
		    LOGS.LOG_INFO_DETAIL('Flat Service Charge - Time Period Completed');
		END IF;

	END LOOP;

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Flat Service Charge - Completed Successfully');
	END IF;

END PSE_FLAT_SERVICE;
---------------------------------------------------------------------------------------------------
PROCEDURE APPLY_ENTITY_ATTRIBUTE
	(
	p_PSE_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_CHARGE_TYPE IN VARCHAR,
	p_CHARGE_ID IN NUMBER,
	p_COMPONENT_ENTITY_ATTRIBUTE IN COMPONENT_ENTITY_ATTRIBUTE%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_ENTITY_ATTRIBUTE_ID NUMBER;
v_ENTITY_ATTRIBUTE_CHARGE ENTITY_ATTRIBUTE_CHARGE%ROWTYPE;
v_IS_PEAK_DEMAND BOOLEAN;
v_PRIOR_CHARGE_ID NUMBER;

CURSOR c_ENTITY_ATTRIBUTE IS
    SELECT OWNER_ENTITY_ID, ATTRIBUTE_VAL
	FROM TEMPORAL_ENTITY_ATTRIBUTE
	WHERE ATTRIBUTE_ID = v_ENTITY_ATTRIBUTE_ID
		AND BEGIN_DATE <= TRUNC(p_END_DATE)
		AND NVL(END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
		AND OWNER_ENTITY_ID IN
			(
			SELECT ACCOUNT_ID
			FROM ACCOUNT_ESP
			WHERE ESP_ID IN
				(
				SELECT ESP_ID
				FROM PSE_ESP
				WHERE PSE_ID = p_PSE_ID
					AND BEGIN_DATE <= TRUNC(p_END_DATE)
					AND NVL(END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
				)
			AND BEGIN_DATE <= TRUNC(p_END_DATE)
			AND NVL(END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
			);

BEGIN
	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Entity Attribute Charge - Starting time period (BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE,'MM/DD/YYYY') || ', END_DATE=' || TO_CHAR(p_END_DATE,'MM/DD/YYYY')||')');
	END IF;

	UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	v_ENTITY_ATTRIBUTE_ID := p_COMPONENT_ENTITY_ATTRIBUTE.ENTITY_ATTRIBUTE_ID;
	v_IS_PEAK_DEMAND := UPPER(p_CHARGE_TYPE) = 'PEAK DEMAND';

	IF g_ACCOUNT_PEAK_AND_ENERGY.COUNT = 0 THEN
		 CACHE_ACCOUNT_PEAK_AND_ENERGY(v_ENTITY_ATTRIBUTE_ID, p_SCHEDULE_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE);
		IF LOGS.IS_DEBUG_ENABLED THEN
			TRACE_ACCOUNT_PEAK_AND_ENERGY;
		END IF;
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('APPLY_ENTITY_ATTRIBUTE');
		LOGS.LOG_DEBUG('CHARGE_TYPE=' || p_CHARGE_TYPE);
	    LOGS.LOG_DEBUG('<id>,<domain id>,<entity id>,<attribute id>,<date>,<peak date>,<quantity>,<charge quantity>,<rate>,<factor>,<amount>');
	END IF;

	v_PRIOR_CHARGE_ID := GET_PRIOR_CHARGE_ID(p_CHARGE_ID);
	v_ENTITY_ATTRIBUTE_CHARGE.CHARGE_FACTOR := GET_COMPONENT_FACTOR(p_COMPONENT_ENTITY_ATTRIBUTE.COMPONENT_ID, p_BEGIN_DATE);

	FOR v_ENTITY_ATTRIBUTE IN c_ENTITY_ATTRIBUTE LOOP
		IF p_COMPONENT_ENTITY_ATTRIBUTE.ENTITY_DOMAIN_ID = -170 THEN -- Retail Account --
			IF (v_IS_PEAK_DEMAND AND g_ACCOUNT_PEAK_AND_ENERGY(v_ENTITY_ATTRIBUTE.OWNER_ENTITY_ID).PSE_OF_RECORD = p_PSE_ID) OR NOT v_IS_PEAK_DEMAND THEN
				v_ENTITY_ATTRIBUTE_CHARGE.CHARGE_ID := p_CHARGE_ID;
				v_ENTITY_ATTRIBUTE_CHARGE.ENTITY_DOMAIN_ID := p_COMPONENT_ENTITY_ATTRIBUTE.ENTITY_DOMAIN_ID;
				v_ENTITY_ATTRIBUTE_CHARGE.ENTITY_ID := v_ENTITY_ATTRIBUTE.OWNER_ENTITY_ID;
				v_ENTITY_ATTRIBUTE_CHARGE.ATTRIBUTE_ID := p_COMPONENT_ENTITY_ATTRIBUTE.ENTITY_ATTRIBUTE_ID;
				v_ENTITY_ATTRIBUTE_CHARGE.CHARGE_DATE := v_BEGIN_DATE;
				v_ENTITY_ATTRIBUTE_CHARGE.PEAK_DATE := NVL(g_ACCOUNT_PEAK_AND_ENERGY(v_ENTITY_ATTRIBUTE.OWNER_ENTITY_ID).PEAK_DATE,CONSTANTS.LOW_DATE);
				IF v_IS_PEAK_DEMAND THEN
				    v_ENTITY_ATTRIBUTE_CHARGE.PEAK_QUANTITY := NVL(g_ACCOUNT_PEAK_AND_ENERGY(v_ENTITY_ATTRIBUTE.OWNER_ENTITY_ID).PEAK,0);
				ELSE
				    v_ENTITY_ATTRIBUTE_CHARGE.PEAK_QUANTITY := NVL(g_ACCOUNT_PEAK_AND_ENERGY(v_ENTITY_ATTRIBUTE.OWNER_ENTITY_ID).ENERGY,0);
				END IF;
				v_ENTITY_ATTRIBUTE_CHARGE.CHARGE_QUANTITY := NVL(g_ACCOUNT_PEAK_AND_ENERGY(v_ENTITY_ATTRIBUTE.OWNER_ENTITY_ID).PEAK,0);
				v_ENTITY_ATTRIBUTE_CHARGE.CHARGE_RATE := NVL(v_ENTITY_ATTRIBUTE.ATTRIBUTE_VAL,0);
				v_ENTITY_ATTRIBUTE_CHARGE.CHARGE_AMOUNT := v_ENTITY_ATTRIBUTE_CHARGE.CHARGE_QUANTITY * v_ENTITY_ATTRIBUTE.ATTRIBUTE_VAL * v_ENTITY_ATTRIBUTE_CHARGE.CHARGE_FACTOR;
				PRIOR_ENTITY_ATTRIBUTE_CHARGE(v_PRIOR_CHARGE_ID, v_ENTITY_ATTRIBUTE_CHARGE);
				PUT_ENTITY_ATTRIBUTE_CHARGE(v_ENTITY_ATTRIBUTE_CHARGE);
			END IF;
		END IF;
	END LOOP;

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Entity Attribute Charge - Time Period Completed');
	END IF;

END APPLY_ENTITY_ATTRIBUTE;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_ENTITY_ATTRIBUTE
	(
	p_PSE_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_CHARGE_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_COMPONENT_ID NUMBER;

CURSOR c_COMPONENT_ENTITY_ATTRIBUTE IS
    SELECT *
	FROM COMPONENT_ENTITY_ATTRIBUTE
	WHERE COMPONENT_ID = v_COMPONENT_ID
    	AND SUB_COMPONENT_TYPE = g_NO_SUB_TYPE
        AND SUB_COMPONENT_ID = g_NOT_ASSIGNED
		AND BEGIN_DATE <= TRUNC(p_END_DATE)
		AND NVL(END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE);

BEGIN

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Entity Attribute Charge (PSE_ID=' || p_PSE_ID || '; SCHEDULE_TYPE=' || p_SCHEDULE_TYPE || '; STATEMENT_TYPE=' || p_STATEMENT_TYPE ||
			'; CHARGE_ID=' || p_CHARGE_ID || '; COMPONENT=' || p_COMPONENT.COMPONENT_NAME || '(' || p_COMPONENT.COMPONENT_ID || ')' ||
			'; BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE,'MM/DD/YYYY') || '; END_DATE=' || TO_CHAR(p_END_DATE,'MM/DD/YYYY') ||
			'; AS_OF_DATE=' || TO_CHAR(p_AS_OF_DATE,'MM/DD/YYYY HH24:MI')||')');
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('PSE_ENTITY_ATTRIBUTE');
		LOGS.LOG_DEBUG('SCHEDULE_TYPE=' || TO_CHAR(p_SCHEDULE_TYPE));
		LOGS.LOG_DEBUG('STATEMENT_TYPE=' || TO_CHAR(p_STATEMENT_TYPE));
		LOGS.LOG_DEBUG('CHARGE_ID=' || TO_CHAR(p_CHARGE_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE));
	END IF;

	v_COMPONENT_ID := p_COMPONENT.COMPONENT_ID;

	FOR v_COMPONENT_ENTITY_ATTRIBUTE IN c_COMPONENT_ENTITY_ATTRIBUTE LOOP
		v_BEGIN_DATE := TRUNC(p_BEGIN_DATE);
		WHILE v_BEGIN_DATE <= TRUNC(p_END_DATE) LOOP
    		v_END_DATE := GET_NEXT_DATE_FOR_INTERVAL(v_BEGIN_DATE, p_COMPONENT.RATE_INTERVAL);
			APPLY_ENTITY_ATTRIBUTE(p_PSE_ID, p_SCHEDULE_TYPE, p_STATEMENT_TYPE, p_COMPONENT.CHARGE_TYPE, p_CHARGE_ID, v_COMPONENT_ENTITY_ATTRIBUTE, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, p_TIME_ZONE);
			v_BEGIN_DATE := v_END_DATE + 1;
		END LOOP;
	END LOOP;

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Entity Attribute Charge - Completed Successfully');
	END IF;

END PSE_ENTITY_ATTRIBUTE;
---------------------------------------------------------------------------------------------------
PROCEDURE APPLY_COINCIDENT_PEAK_SHARE
	(
	p_PSE_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_LOAD_CODE IN CHAR,
	p_CHARGE_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_PEAK_DATE DATE;
v_SYSTEM_LOAD_ID NUMBER;
v_PEAK_QUANTITY NUMBER;
v_COMPONENT_COINCIDENT_PEAK COMPONENT_COINCIDENT_PEAK%ROWTYPE;
v_BILLING_CHARGE BILLING_CHARGE%ROWTYPE;
v_DEMAND NUMBER;
v_PRIOR_CHARGE_ID NUMBER;

BEGIN

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Coincident Peak Share Charge - Starting time period (BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE,'MM/DD/YYYY') || ', END_DATE=' || TO_CHAR(p_END_DATE,'MM/DD/YYYY')||')');
	END IF;

	UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	v_PRIOR_CHARGE_ID := GET_PRIOR_CHARGE_ID(p_CHARGE_ID);

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('APPLY_COINCIDENT_PEAK_SHARE');
		LOGS.LOG_DEBUG('LOAD_CODE=' || p_LOAD_CODE);
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_END_DATE));
	END IF;

    SELECT *
	INTO v_COMPONENT_COINCIDENT_PEAK
	FROM COMPONENT_COINCIDENT_PEAK
	WHERE  COMPONENT_ID = p_COMPONENT.COMPONENT_ID
    	AND SUB_COMPONENT_TYPE = g_NO_SUB_TYPE
        AND SUB_COMPONENT_ID = g_NOT_ASSIGNED
	    AND BEGIN_DATE <= TRUNC(p_END_DATE)
		AND NVL(END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
		AND ROWNUM = 1;

	v_SYSTEM_LOAD_ID := v_COMPONENT_COINCIDENT_PEAK.A_SYSTEM_LOAD_ID;
	v_PEAK_DATE := GET_SYSTEM_LOAD_PEAK_DATE(v_SYSTEM_LOAD_ID, p_LOAD_CODE, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE);

	IF v_COMPONENT_COINCIDENT_PEAK.B_SYSTEM_LOAD_ID > 0 THEN
	    v_SYSTEM_LOAD_ID := v_COMPONENT_COINCIDENT_PEAK.B_SYSTEM_LOAD_ID;
	END IF;

	v_PEAK_QUANTITY := GET_SYSTEM_LOAD_AT_DATE(v_SYSTEM_LOAD_ID, p_LOAD_CODE, v_PEAK_DATE, p_AS_OF_DATE);
	v_DEMAND := GET_PSE_DEMAND_ON_DATE(p_PSE_ID, p_COMPONENT.SERVICE_POINT_ID, p_SCHEDULE_TYPE, v_PEAK_DATE, p_AS_OF_DATE);

	v_BILLING_CHARGE.CHARGE_ID := p_CHARGE_ID;
	v_BILLING_CHARGE.CHARGE_DATE := v_BEGIN_DATE;
	v_BILLING_CHARGE.PEAK_DATE := v_PEAK_DATE;
	v_BILLING_CHARGE.PEAK_QUANTITY := v_DEMAND;
	v_BILLING_CHARGE.SERVICE_POINT_ID := p_COMPONENT.SERVICE_POINT_ID;
	v_BILLING_CHARGE.CHARGE_RATE := v_COMPONENT_COINCIDENT_PEAK.RATE;
	v_BILLING_CHARGE.CHARGE_FACTOR := GET_COMPONENT_FACTOR(p_COMPONENT.COMPONENT_ID, p_BEGIN_DATE);

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('<id>,<date>,<peak date>,<quantity>,<point>,<charge quantity>,<rate>,<factor>,<amount>');
	END IF;

    v_BILLING_CHARGE.CHARGE_QUANTITY := v_DEMAND / v_PEAK_QUANTITY;
	v_BILLING_CHARGE.CHARGE_AMOUNT := v_BILLING_CHARGE.CHARGE_QUANTITY * v_BILLING_CHARGE.CHARGE_RATE * v_BILLING_CHARGE.CHARGE_FACTOR;
	PRIOR_BILLING_CHARGE(v_PRIOR_CHARGE_ID, v_BILLING_CHARGE);
	PUT_BILLING_CHARGE(v_BILLING_CHARGE);

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Coincident Peak Share Charge - Time Period Completed');
	END IF;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN;

END APPLY_COINCIDENT_PEAK_SHARE;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_COINCIDENT_PEAK_SHARE
	(
	p_PSE_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_CHARGE_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2
	) AS

v_LOAD_CODE CHAR(1);
v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Coincident Peak Share Charge (PSE_ID='||p_PSE_ID||'; SCHEDULE_TYPE='||p_SCHEDULE_TYPE||'; STATEMENT_TYPE='||p_STATEMENT_TYPE||
			'; CHARGE_ID='||p_CHARGE_ID||'; COMPONENT='||p_COMPONENT.COMPONENT_NAME||'('||p_COMPONENT.COMPONENT_ID||')'||
			'; BEGIN_DATE='||TO_CHAR(p_BEGIN_DATE,'MM/DD/YYYY')||'; END_DATE='||TO_CHAR(p_END_DATE,'MM/DD/YYYY')||
			'; AS_OF_DATE='||TO_CHAR(p_AS_OF_DATE,'MM/DD/YYYY HH24:MI')||')');
	END IF;

	SELECT DECODE(p_SCHEDULE_TYPE, 1, 'F', 'A') INTO v_LOAD_CODE FROM DUAL;
	v_BEGIN_DATE := TRUNC(p_BEGIN_DATE);

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('PSE_COINCIDENT_PEAK_SHARE');
		LOGS.LOG_DEBUG('SCHEDULE_TYPE=' || TO_CHAR(p_SCHEDULE_TYPE));
		LOGS.LOG_DEBUG('STATEMENT_TYPE=' || TO_CHAR(p_STATEMENT_TYPE));
		LOGS.LOG_DEBUG('CHARGE_ID=' || TO_CHAR(p_CHARGE_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE));
	END IF;

	WHILE v_BEGIN_DATE <= TRUNC(p_END_DATE) LOOP
   		v_END_DATE := GET_NEXT_DATE_FOR_INTERVAL(v_BEGIN_DATE, p_COMPONENT.RATE_INTERVAL);
		APPLY_COINCIDENT_PEAK_SHARE(p_PSE_ID, p_SCHEDULE_TYPE, v_LOAD_CODE, p_CHARGE_ID, p_COMPONENT, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, p_TIME_ZONE);
		v_BEGIN_DATE := v_END_DATE + 1;
	END LOOP;

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Coincident Peak Share Charge - Completed Successfully');
	END IF;

END PSE_COINCIDENT_PEAK_SHARE;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_FORMULA_CHARGE
	(
	p_PSE_GROUP IN VARCHAR2,
	p_PSE_ID IN NUMBER,
    p_CONTRACT_ID IN NUMBER,
    p_PRODUCT_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_CHARGE_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_WEEK_BEGIN IN VARCHAR2
	) AS
v_BEGIN_DATE		DATE;
v_END_DATE			DATE;
v_PROC_NAME			VARCHAR2(512);
v_VARIABLE_CACHE	UT.STRING_MAP;
BEGIN
	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Formula Charge (PSE_ID='||p_PSE_ID||'; SCHEDULE_TYPE='||p_SCHEDULE_TYPE||'; STATEMENT_TYPE='||p_STATEMENT_TYPE||
			'; CHARGE_ID='||p_CHARGE_ID||'; COMPONENT='||p_COMPONENT.COMPONENT_NAME||'('||p_COMPONENT.COMPONENT_ID||')'||
			'; BEGIN_DATE='||TO_CHAR(p_BEGIN_DATE,'MM/DD/YYYY')||'; END_DATE='||TO_CHAR(p_END_DATE,'MM/DD/YYYY')||
			'; AS_OF_DATE='||TO_CHAR(p_AS_OF_DATE,'MM/DD/YYYY HH24:MI')||')');
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('PSE_FORMULA_CHARGE');
		LOGS.LOG_DEBUG('SCHEDULE_TYPE=' || TO_CHAR(p_SCHEDULE_TYPE));
		LOGS.LOG_DEBUG('STATEMENT_TYPE=' || TO_CHAR(p_STATEMENT_TYPE));
		LOGS.LOG_DEBUG('CHARGE_ID=' || TO_CHAR(p_CHARGE_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE));
	END IF;

	UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

    -- initialize the context
    v_VARIABLE_CACHE(':billing_entity') := '('||TO_CHAR(p_PSE_ID)||')';
    v_VARIABLE_CACHE(':bill_calc_group') := '('''||p_PSE_GROUP||''')';
    v_VARIABLE_CACHE(':product') := '('||TO_CHAR(p_PRODUCT_ID)||')';
    v_VARIABLE_CACHE(':contract') := '('||TO_CHAR(p_CONTRACT_ID)||')';
    v_VARIABLE_CACHE(':statement_type') := '('||TO_CHAR(p_STATEMENT_TYPE)||')';
    v_VARIABLE_CACHE(':time_zone') := '('''||p_TIME_ZONE||''')';
    v_VARIABLE_CACHE(':as_of') := '(TO_DATE('''||TO_CHAR(p_AS_OF_DATE,'yyyy-mm-dd hh24:mi:ss')||''',''yyyy-mm-dd hh24:mi:ss''))';
    v_VARIABLE_CACHE(':process_id') := '('''||LOGS.CURRENT_PROCESS_ID||''')';
    v_VARIABLE_CACHE(':session_id') := '('''||LOGS.CURRENT_PROCESS_ID||''')';
	v_VARIABLE_CACHE(':statement_date') := '(TO_DATE('''||TO_CHAR(p_BEGIN_DATE,'yyyy-mm-dd hh24:mi:ss')||''',''yyyy-mm-dd hh24:mi:ss''))';
	v_VARIABLE_CACHE(':statement_end_date') := '(TO_DATE('''||TO_CHAR(p_END_DATE,'yyyy-mm-dd hh24:mi:ss')||''',''yyyy-mm-dd hh24:mi:ss''))';

	v_PROC_NAME := SUBSTR( 'Calculate Billing Statements: ' ||
						TEXT_UTIL.TO_CHAR_ENTITY(p_PSE_ID, EC.ED_PSE)||', ' ||
						TEXT_UTIL.TO_CHAR_ENTITY(p_STATEMENT_TYPE, EC.ED_STATEMENT_TYPE)||', ' ||
						TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE)||' -> '||TEXT_UTIL.TO_CHAR_DATE(p_END_DATE),
					1, 512 );

	CALC_ENGINE.RUN_FORMULA_COMPONENT(p_CHARGE_ID,
									GET_PRIOR_CHARGE_ID(p_CHARGE_ID),
									p_COMPONENT,
									v_BEGIN_DATE,
									V_END_DATE,
									TRUE,
									p_TIME_ZONE,
									p_AS_OF_DATE,
									p_WEEK_BEGIN,
									v_VARIABLE_CACHE,
									v_PROC_NAME
									);

	v_VARIABLE_CACHE.DELETE;

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Formula Charge - Completed Successfully');
	END IF;
END PSE_FORMULA_CHARGE;
---------------------------------------------------------------------------------------------------
FUNCTION GET_WEIGHT_AVG_LMP_PRICE
	(
	p_IS_NET_LOAD IN NUMBER,
	p_BILATERAL_SIGN IN NUMBER,
	p_CONTRACT_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_MARKET_TYPE IN VARCHAR,
	p_MARKET_PRICE_TYPE IN VARCHAR,
	p_SERVICE_DATE IN DATE,
	p_PRICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE
	) RETURN NUMBER IS
v_RET NUMBER;
v_TYPE1 VARCHAR2(16);
v_TYPE2 VARCHAR2(16);
BEGIN
    IF p_IS_NET_LOAD = 1 THEN
    	-- load-weighted average LMP
        v_TYPE1 := 'LO';
		-- default logic is that "load" equals Load plus Sales - but if Bilateral Sign
		-- is negative one, then it is Load plus Purchases
        v_TYPE2 := CASE WHEN p_BILATERAL_SIGN < 0 THEN 'PU' ELSE 'SA' END;
    ELSE
    	-- otherwise generation-weighted average LMP
        v_TYPE1 := 'GE';
        v_TYPE2 := CASE WHEN p_BILATERAL_SIGN < 0 THEN 'SA' ELSE 'PU' END;
    END IF;

	IF UPPER(p_MARKET_TYPE) = UPPER(g_DAY_AHEAD) THEN
        SELECT DECODE(NVL(SUM(B.AMOUNT),0),0,NULL,SUM(B.AMOUNT*A.PRICE)/SUM(B.AMOUNT))
        INTO v_RET
        FROM MARKET_PRICE_VALUE A,
        	IT_SCHEDULE B,
            MARKET_PRICE C,
            INTERCHANGE_TRANSACTION D,
            IT_COMMODITY E,
            IT_STATUS F
	    WHERE D.BEGIN_DATE <= TRUNC(p_SERVICE_DATE)
    		AND NVL(D.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_SERVICE_DATE)
			AND D.CONTRACT_ID = p_CONTRACT_ID
				AND D.COMMODITY_ID IN
					(SELECT COMMODITY_ID
						FROM IT_COMMODITY
						WHERE COMMODITY_NAME IN('DayAhead Energy', 'Virtual Energy'))
        	AND UPPER(SUBSTR(D.TRANSACTION_TYPE,1,2)) IN (v_TYPE1,v_TYPE2)
            AND F.TRANSACTION_ID = D.TRANSACTION_ID
            AND F.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
            					FROM IT_STATUS
                                WHERE TRANSACTION_ID = F.TRANSACTION_ID
                                	AND AS_OF_DATE <= p_AS_OF_DATE)
            AND F.TRANSACTION_IS_ACTIVE = 1
        	AND E.COMMODITY_ID = D.COMMODITY_ID
            AND E.MARKET_TYPE = p_MARKET_TYPE
            AND C.MARKET_TYPE = p_MARKET_TYPE
            AND C.MARKET_PRICE_TYPE = p_MARKET_PRICE_TYPE
			AND C.POD_ID = CASE WHEN D.TRANSACTION_TYPE = 'Sale' THEN D.POR_ID ELSE D.POD_ID END
            AND B.TRANSACTION_ID = D.TRANSACTION_ID
            AND B.SCHEDULE_TYPE = p_STATEMENT_TYPE
            AND B.SCHEDULE_STATE = GA.INTERNAL_STATE
            AND B.SCHEDULE_DATE = p_PRICE_DATE
            AND B.AS_OF_DATE =
            	(SELECT MAX(AS_OF_DATE)
                FROM IT_SCHEDULE
                WHERE TRANSACTION_ID = B.TRANSACTION_ID
                	AND SCHEDULE_TYPE = B.SCHEDULE_TYPE
                    AND SCHEDULE_STATE = B.SCHEDULE_STATE
                    AND SCHEDULE_DATE = B.SCHEDULE_DATE
                    AND AS_OF_DATE <= p_AS_OF_DATE)
            AND A.MARKET_PRICE_ID = C.MARKET_PRICE_ID
        	AND A.PRICE_CODE IN ('F','P','A')
	        AND A.PRICE_DATE = p_PRICE_DATE
	        AND A.PRICE_CODE =
		        (SELECT DECODE(MAX(DECODE(PRICE_CODE,'F',1,'P',2,'A',3)),1,'F',2,'P',3,'A')
		        FROM MARKET_PRICE_VALUE
	         	WHERE MARKET_PRICE_ID = A.MARKET_PRICE_ID
		          	AND PRICE_CODE IN ('F','P','A')
					AND PRICE_DATE = A.PRICE_DATE)
			AND A.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM MARKET_PRICE_VALUE
		        WHERE MARKET_PRICE_ID = A.MARKET_PRICE_ID
			        AND PRICE_CODE = A.PRICE_CODE
			        AND PRICE_DATE = A.PRICE_DATE
			        AND AS_OF_DATE <= p_AS_OF_DATE);
	ELSE
    	-- non day-ahead charges use deviation for weight
	    SELECT CASE ROUND(SUM(RT_AMOUNT-DA_AMOUNT),1) WHEN 0 THEN
        (CASE SUM(RT_AMOUNT) WHEN 0 THEN NULL ELSE SUM(RT_AMOUNT*PRICE)/SUM(RT_AMOUNT) END)
        ELSE
        (CASE SUM(RT_AMOUNT-DA_AMOUNT) WHEN 0 THEN NULL ELSE SUM((RT_AMOUNT-DA_AMOUNT)*PRICE)/SUM(RT_AMOUNT-DA_AMOUNT) END)
		END
     	INTO v_RET
        FROM (SELECT A.POD_ID, A.POR_ID,
            	A.AMOUNT "RT_AMOUNT",
                A.PRICE,
                (SELECT NVL(SUM(X.AMOUNT),0)
                 FROM IT_SCHEDULE X,
                    INTERCHANGE_TRANSACTION B,
                    IT_STATUS C,
                    IT_COMMODITY D
			     WHERE B.BEGIN_DATE <= TRUNC(p_SERVICE_DATE)
					AND NVL(B.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_SERVICE_DATE)
    			 	AND B.CONTRACT_ID = p_CONTRACT_ID
					AND UPPER(SUBSTR(B.TRANSACTION_TYPE,1,2)) IN (v_TYPE1,v_TYPE2)
                    AND B.POD_ID = A.POD_ID
					AND B.POR_ID = A.POR_ID
                    AND C.TRANSACTION_ID = B.TRANSACTION_ID
                    AND C.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
                        					FROM IT_STATUS
                                            WHERE TRANSACTION_ID = C.TRANSACTION_ID
                                            	AND AS_OF_DATE <= p_AS_OF_DATE)
                    AND C.TRANSACTION_IS_ACTIVE = 1
                 	AND D.COMMODITY_ID = B.COMMODITY_ID
                    AND D.MARKET_TYPE = g_DAY_AHEAD
                    AND X.TRANSACTION_ID = B.TRANSACTION_ID
                    AND X.SCHEDULE_TYPE = p_STATEMENT_TYPE
                    AND X.SCHEDULE_STATE = GA.INTERNAL_STATE
                    AND X.SCHEDULE_DATE = p_PRICE_DATE
                    AND X.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
                        					FROM IT_SCHEDULE
                                            WHERE TRANSACTION_ID = X.TRANSACTION_ID
                                            	AND SCHEDULE_TYPE = X.SCHEDULE_TYPE
                                                AND SCHEDULE_STATE = X.SCHEDULE_STATE
                                                AND SCHEDULE_DATE = X.SCHEDULE_DATE
                                                AND AS_OF_DATE <= p_AS_OF_DATE)
                 ) "DA_AMOUNT"
            FROM (SELECT D.POD_ID,
					D.POR_ID,
                	NVL(SUM(B.AMOUNT),0) "AMOUNT",
                    AVG(A.PRICE) "PRICE"
        	    FROM MARKET_PRICE_VALUE A,
                	IT_SCHEDULE B,
                    MARKET_PRICE C,
                    INTERCHANGE_TRANSACTION D,
                    IT_COMMODITY E,
                    IT_STATUS F
			    WHERE D.BEGIN_DATE <= TRUNC(p_SERVICE_DATE)
    				AND NVL(D.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_SERVICE_DATE)
        	    	AND D.CONTRACT_ID = p_CONTRACT_ID
        			AND UPPER(SUBSTR(D.TRANSACTION_TYPE,1,2)) IN (v_TYPE1,v_TYPE2)
                    AND F.TRANSACTION_ID = D.TRANSACTION_ID
                    AND F.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
                    					FROM IT_STATUS
                                        WHERE TRANSACTION_ID = F.TRANSACTION_ID
                                        	AND AS_OF_DATE <= p_AS_OF_DATE)
                    AND F.TRANSACTION_IS_ACTIVE = 1
                	AND E.COMMODITY_ID = D.COMMODITY_ID
                    AND E.MARKET_TYPE = p_MARKET_TYPE
                    AND C.MARKET_TYPE = p_MARKET_TYPE
                    AND C.MARKET_PRICE_TYPE = p_MARKET_PRICE_TYPE
                    AND C.POD_ID = CASE WHEN D.TRANSACTION_TYPE = 'Sale' THEN D.POR_ID ELSE D.POD_ID END
                    AND B.TRANSACTION_ID = D.TRANSACTION_ID
                    AND B.SCHEDULE_TYPE = p_STATEMENT_TYPE
                    AND B.SCHEDULE_STATE = GA.INTERNAL_STATE
                    AND B.SCHEDULE_DATE = p_PRICE_DATE
                    AND B.AS_OF_DATE =
                    	(SELECT MAX(AS_OF_DATE)
                        FROM IT_SCHEDULE
                        WHERE TRANSACTION_ID = B.TRANSACTION_ID
                        	AND SCHEDULE_TYPE = B.SCHEDULE_TYPE
                            AND SCHEDULE_STATE = B.SCHEDULE_STATE
                            AND SCHEDULE_DATE = B.SCHEDULE_DATE
                            AND AS_OF_DATE <= p_AS_OF_DATE)
                    AND A.MARKET_PRICE_ID = C.MARKET_PRICE_ID
        			AND A.PRICE_CODE IN ('F','P','A')
        			AND A.PRICE_DATE = p_PRICE_DATE
        		    AND A.PRICE_CODE =
        		    	(SELECT DECODE(MAX(DECODE(PRICE_CODE,'F',1,'P',2,'A',3)),1,'F',2,'P',3,'A')
        	    		FROM MARKET_PRICE_VALUE
        	        	WHERE MARKET_PRICE_ID = A.MARKET_PRICE_ID
        		        	AND PRICE_CODE IN ('F','P','A')
        		            AND PRICE_DATE = A.PRICE_DATE)
        			AND A.AS_OF_DATE =
        				(SELECT MAX(AS_OF_DATE)
        				FROM MARKET_PRICE_VALUE
        				WHERE MARKET_PRICE_ID = A.MARKET_PRICE_ID
        					AND PRICE_CODE = A.PRICE_CODE
        					AND PRICE_DATE = A.PRICE_DATE
        					AND AS_OF_DATE <= p_AS_OF_DATE)
    			GROUP BY D.POD_ID, D.POR_ID) A);
    END IF;

	RETURN v_RET;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
    	RETURN NULL;
    WHEN TOO_MANY_ROWS THEN
    	RETURN NULL;
END GET_WEIGHT_AVG_LMP_PRICE;
---------------------------------------------------------------------------------------------------
FUNCTION GET_LMP_PRICE
	(
    p_MARKET_PRICE_ID IN NUMBER,
    p_PRICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE
    ) RETURN NUMBER IS
v_RET NUMBER;
BEGIN
    SELECT A.PRICE
    INTO v_RET
    FROM MARKET_PRICE_VALUE A
    WHERE A.MARKET_PRICE_ID = p_MARKET_PRICE_ID
		AND A.PRICE_CODE IN ('F','P','A')
		AND A.PRICE_DATE = p_PRICE_DATE
	    AND A.PRICE_CODE =
	    	(SELECT DECODE(MAX(DECODE(PRICE_CODE,'F',1,'P',2,'A',3)),1,'F',2,'P',3,'A')
    		FROM MARKET_PRICE_VALUE
        	WHERE MARKET_PRICE_ID = A.MARKET_PRICE_ID
	        	AND PRICE_CODE IN ('F','P','A')
	            AND PRICE_DATE = A.PRICE_DATE)
		AND A.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM MARKET_PRICE_VALUE
			WHERE MARKET_PRICE_ID = A.MARKET_PRICE_ID
				AND PRICE_CODE = A.PRICE_CODE
				AND PRICE_DATE = A.PRICE_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE);

	RETURN v_RET;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
    	RETURN NULL;
    WHEN TOO_MANY_ROWS THEN
    	RETURN NULL;
END GET_LMP_PRICE;
---------------------------------------------------------------------------------------------------
FUNCTION GET_ALTERNATE_PRICE
	(
    p_TRANSACTION_IDs IN ID_TABLE,
	p_SCHEDULE_TYPE IN NUMBER,
    p_SCHEDULE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_ALT_PRICE IN VARCHAR2
    ) RETURN NUMBER IS
v_TOTAL_COST NUMBER := 0;
v_TOTAL_QUANTITY NUMBER := 0;
v_PRICE NUMBER;
v_QUANTITY NUMBER;
v_RET NUMBER;
v_MINQ NUMBER;
v_MINP NUMBER;
v_MAXQ NUMBER;
v_MAXP NUMBER;
v_UP BOOLEAN;
v_IDX BINARY_INTEGER;
v_BO_ID NUMBER := NULL;
v_DATE DATE;
v_TRANSACTION INTERCHANGE_TRANSACTION%ROWTYPE;
v_INTERVAL VARCHAR2(16);
BEGIN
	CASE UPPER(SUBSTR(p_ALT_PRICE,1,9))
	WHEN 'INTERNAL' THEN
        SELECT CASE
				WHEN NVL(SUM(B.AMOUNT),0) = 0 THEN
					NULL
				ELSE
					NVL(SUM(B.AMOUNT*B.PRICE),0) / NVL(SUM(B.AMOUNT),0)
				END
        INTO v_RET
        FROM TABLE(CAST(p_TRANSACTION_IDs AS ID_TABLE)) A,
        	IT_SCHEDULE B
        WHERE B.TRANSACTION_ID = A.ID
    		AND B.SCHEDULE_TYPE = DECODE(g_ENABLE_SUPPLY_SCHEDULE_TYPES, 1, p_SCHEDULE_TYPE, g_NOT_ASSIGNED)
    		AND B.SCHEDULE_STATE = GA.INTERNAL_STATE
    		AND B.SCHEDULE_DATE = p_SCHEDULE_DATE
    		AND B.AS_OF_DATE =
    			(SELECT MAX(AS_OF_DATE)
    			FROM IT_SCHEDULE
    			WHERE TRANSACTION_ID = B.TRANSACTION_ID
    				AND SCHEDULE_TYPE = B.SCHEDULE_TYPE
    				AND SCHEDULE_STATE = B.SCHEDULE_STATE
    				AND SCHEDULE_DATE = B.SCHEDULE_DATE
    				AND AS_OF_DATE <= p_AS_OF_DATE);

		RETURN v_RET;

	WHEN 'BID/OFFER' THEN
		IF TRIM(UPPER(SUBSTR(p_ALT_PRICE,10))) IS NOT NULL THEN
    		CASE TRIM(UPPER(SUBSTR(p_ALT_PRICE,10)))
    		WHEN 'HIGH' THEN
    			v_UP := TRUE;
    		WHEN 'LOW' THEN
    			v_UP := FALSE;
    		ELSE
    			RETURN 0; -- unrecognized alternate price
    		END CASE;
		END IF;

		v_IDX := p_TRANSACTION_IDs.FIRST;
		WHILE p_TRANSACTION_IDs.EXISTS(v_IDX) LOOP
			-- first get quantity
            SELECT NVL(SUM(AMOUNT),0)
            INTO v_QUANTITY
            FROM IT_SCHEDULE A
            WHERE TRANSACTION_ID = p_TRANSACTION_IDs(v_IDX).ID
        		AND SCHEDULE_TYPE = DECODE(g_ENABLE_SUPPLY_SCHEDULE_TYPES, 1, p_SCHEDULE_TYPE, g_NOT_ASSIGNED)
        		AND SCHEDULE_STATE = GA.INTERNAL_STATE
        		AND SCHEDULE_DATE = p_SCHEDULE_DATE
        		AND AS_OF_DATE =
        			(SELECT MAX(AS_OF_DATE)
        			FROM IT_SCHEDULE
        			WHERE TRANSACTION_ID = A.TRANSACTION_ID
        				AND SCHEDULE_TYPE = A.SCHEDULE_TYPE
        				AND SCHEDULE_STATE = A.SCHEDULE_STATE
        				AND SCHEDULE_DATE = A.SCHEDULE_DATE
        				AND AS_OF_DATE <= p_AS_OF_DATE);

			-- then get rate
			IF v_BO_ID IS NULL THEN
				-- try to get the first non-standing bid/offer ID and use that
				SELECT * INTO v_TRANSACTION FROM INTERCHANGE_TRANSACTION WHERE TRANSACTION_ID = p_TRANSACTION_IDs(v_IDX).ID;
				v_INTERVAL := MM.GET_BID_OFFER_INTERVAL(v_TRANSACTION);

				SELECT 0,
					TRUNC(p_SCHEDULE_DATE+1/24-1/86400, DECODE(UPPER(v_INTERVAL),'MONTH','MM','QUARTER','Q','YEAR','YY','WEEK','DY','DAY','DD','HH'))
				INTO v_BO_ID, v_DATE
				FROM IT_TRAIT_SCHEDULE_STATUS A
				WHERE A.TRANSACTION_ID = p_TRANSACTION_IDs(v_IDX).ID
					AND ROWNUM = 1;
			END IF;
			-- use grouping functions to prevent no_rows_found exception
			SELECT MIN(QUANTITY),
				MIN(PRICE)
			INTO v_MINQ, v_MINP
			FROM BID_OFFER_SET A
			WHERE TRANSACTION_ID = p_TRANSACTION_IDs(v_IDX).ID
				AND SCHEDULE_STATE = GA.INTERNAL_STATE
				AND SCHEDULE_DATE = v_DATE
				AND QUANTITY = (SELECT MIN(QUANTITY)
								FROM BID_OFFER_SET
								WHERE TRANSACTION_ID = A.TRANSACTION_ID
    								AND SCHEDULE_STATE = A.SCHEDULE_STATE
    								AND SCHEDULE_DATE = A.SCHEDULE_DATE);
			-- use grouping functions to prevent no_rows_found exception
			SELECT MAX(QUANTITY),
				MAX(PRICE)
			INTO v_MAXQ, v_MAXP
			FROM BID_OFFER_SET A
			WHERE TRANSACTION_ID = p_TRANSACTION_IDs(v_IDX).ID
				AND SCHEDULE_STATE = GA.INTERNAL_STATE
				AND SCHEDULE_DATE = v_DATE
				AND QUANTITY = (SELECT MAX(QUANTITY)
								FROM BID_OFFER_SET
								WHERE TRANSACTION_ID = A.TRANSACTION_ID
    								AND SCHEDULE_STATE = A.SCHEDULE_STATE
    								AND SCHEDULE_DATE = A.SCHEDULE_DATE);
			IF v_QUANTITY >= v_MAXQ THEN
				v_PRICE := v_MAXP;
			ELSIF v_QUANTITY <= v_MINQ THEN
				v_PRICE := v_MINP;
			ELSIF v_UP THEN
				SELECT MIN(PRICE)
				INTO v_PRICE
				FROM BID_OFFER_SET A
    			WHERE TRANSACTION_ID = p_TRANSACTION_IDs(v_IDX).ID
    				AND SCHEDULE_STATE = GA.INTERNAL_STATE
    				AND SCHEDULE_DATE = v_DATE
					AND QUANTITY = (SELECT MIN(QUANTITY)
									FROM BID_OFFER_SET
    								WHERE TRANSACTION_ID = A.TRANSACTION_ID
        								AND SCHEDULE_STATE = A.SCHEDULE_STATE
        								AND SCHEDULE_DATE = A.SCHEDULE_DATE
										AND QUANTITY >= v_QUANTITY);
			ELSE -- NOT v_UP
				SELECT MAX(PRICE)
				INTO v_PRICE
				FROM BID_OFFER_SET A
    			WHERE TRANSACTION_ID = p_TRANSACTION_IDs(v_IDX).ID
    				AND SCHEDULE_STATE = GA.INTERNAL_STATE
    				AND SCHEDULE_DATE = v_DATE
					AND QUANTITY = (SELECT MAX(QUANTITY)
									FROM BID_OFFER_SET
    								WHERE TRANSACTION_ID = A.TRANSACTION_ID
        								AND SCHEDULE_STATE = A.SCHEDULE_STATE
        								AND SCHEDULE_DATE = A.SCHEDULE_DATE
										AND QUANTITY <= v_QUANTITY);
			END IF;

			-- update totals
			v_TOTAL_QUANTITY := v_TOTAL_QUANTITY + v_QUANTITY;
			v_TOTAL_COST := v_TOTAL_COST + v_QUANTITY*v_PRICE;

			v_IDX := p_TRANSACTION_IDs.NEXT(v_IDX);
		END LOOP;

		IF v_TOTAL_QUANTITY = 0 THEN
			RETURN NULL;
		ELSE
			RETURN v_TOTAL_COST / v_TOTAL_QUANTITY;
		END IF;

	ELSE
		RETURN 0;
	END CASE;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
    	RETURN NULL;
    WHEN TOO_MANY_ROWS THEN
    	RETURN NULL;
END GET_ALTERNATE_PRICE;
---------------------------------------------------------------------------------------------------
-- This version of the function is called by PSE_LMP_COMMODITY_CHARGE
FUNCTION GET_LMP_QUANTITY
	(
    p_SERVICE_DATE IN DATE,
    p_SCHEDULE_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_CONTRACT_ID IN NUMBER,
    p_INTERVAL IN VARCHAR2,
    p_TRANSACTION_TYPE IN VARCHAR2,
    p_TRANSACTION_TYPE_NEG IN VARCHAR2,
    p_IS_IMPORT_EXPORT IN NUMBER,
	p_COMMODITY_ID IN NUMBER,
    p_SOURCE_ID IN NUMBER,
    p_POD_ID IN NUMBER,
    p_SINK_ID IN NUMBER,
	p_IS_ZONE IN NUMBER,
    p_QUANTITY_UNIT IN VARCHAR2,
    p_UNITS_FACTOR IN NUMBER,
	p_TRANSACTION_IDs IN OUT NOCOPY ID_TABLE
    ) RETURN NUMBER IS
v_RET NUMBER;
v_TX_IDs ID_TABLE := ID_TABLE();
v_IDX BINARY_INTEGER;

BEGIN
	-- first query value
	SELECT NVL(SUM(DECODE(UPPER(C.COMMODITY_UNIT||p_QUANTITY_UNIT),'MWHMW',p_UNITS_FACTOR,'MWMWH',1/p_UNITS_FACTOR,1) *
							CASE UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2))
								WHEN UPPER(SUBSTR(p_TRANSACTION_TYPE,1,2)) THEN
									1
								ELSE
									-1
								END * D.AMOUNT),0)
	INTO v_RET
    FROM INTERCHANGE_TRANSACTION A,
    	IT_STATUS B,
		IT_COMMODITY C,
		IT_SCHEDULE D
    WHERE C.COMMODITY_ID = p_COMMODITY_ID
		AND A.BEGIN_DATE <= TRUNC(p_SERVICE_DATE)
    	AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_SERVICE_DATE)
    	AND A.CONTRACT_ID = p_CONTRACT_ID
    	AND UPPER(A.TRANSACTION_INTERVAL) = UPPER(p_INTERVAL)
		AND A.COMMODITY_ID = C.COMMODITY_ID
		AND A.SOURCE_ID = DECODE(p_SOURCE_ID, g_NOT_ASSIGNED, A.SOURCE_ID, p_SOURCE_ID)
    	AND A.POD_ID = DECODE(p_POD_ID, g_NOT_ASSIGNED, A.POD_ID, p_POD_ID)
    	AND A.SINK_ID = DECODE(p_SINK_ID, g_NOT_ASSIGNED, A.SINK_ID, p_SINK_ID)
    	AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) IN ( UPPER(SUBSTR(p_TRANSACTION_TYPE,1,2)), UPPER(SUBSTR(p_TRANSACTION_TYPE_NEG,1,2)) )
        AND A.IS_IMPORT_EXPORT = p_IS_IMPORT_EXPORT
    	AND B.TRANSACTION_ID = A.TRANSACTION_ID
    	AND B.AS_OF_DATE =
    		(SELECT MAX(AS_OF_DATE)
    		FROM IT_STATUS
    		WHERE TRANSACTION_ID = B.TRANSACTION_ID
    			AND AS_OF_DATE <= p_AS_OF_DATE)
    	AND B.TRANSACTION_IS_ACTIVE = 1
		AND D.TRANSACTION_ID = A.TRANSACTION_ID
		AND D.SCHEDULE_TYPE = DECODE(g_ENABLE_SUPPLY_SCHEDULE_TYPES, 1, p_SCHEDULE_TYPE, g_NOT_ASSIGNED)
		AND D.SCHEDULE_STATE = GA.INTERNAL_STATE
		AND D.SCHEDULE_DATE = p_SCHEDULE_DATE
		AND D.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_SCHEDULE
			WHERE TRANSACTION_ID = D.TRANSACTION_ID
				AND SCHEDULE_TYPE = D.SCHEDULE_TYPE
				AND SCHEDULE_STATE = D.SCHEDULE_STATE
				AND SCHEDULE_DATE = D.SCHEDULE_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE)
		AND ( ( UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) = UPPER(SUBSTR(p_TRANSACTION_TYPE,1,2)) AND D.AMOUNT > 0 )
				OR
			  ( UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) = UPPER(SUBSTR(p_TRANSACTION_TYPE_NEG,1,2)) AND D.AMOUNT < 0 ) );

	IF p_TRANSACTION_IDs IS NOT NULL THEN
		-- append transaction IDs to list
    	SELECT ID_TYPE(A.TRANSACTION_ID)
    	BULK COLLECT INTO v_TX_IDs
        FROM INTERCHANGE_TRANSACTION A,
        	IT_STATUS B
        WHERE A.BEGIN_DATE <= TRUNC(p_SERVICE_DATE)
        	AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_SERVICE_DATE)
        	AND A.CONTRACT_ID = p_CONTRACT_ID
        	AND UPPER(A.TRANSACTION_INTERVAL) = UPPER(p_INTERVAL)
    		AND A.COMMODITY_ID = p_COMMODITY_ID
    		AND A.SOURCE_ID = DECODE(p_SOURCE_ID, g_NOT_ASSIGNED, A.SOURCE_ID, p_SOURCE_ID)
        	AND A.POD_ID = DECODE(p_POD_ID, g_NOT_ASSIGNED, A.POD_ID, p_POD_ID)
        	AND A.SINK_ID = DECODE(p_SINK_ID, g_NOT_ASSIGNED, A.SINK_ID, p_SINK_ID)
        	AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) IN ( UPPER(SUBSTR(p_TRANSACTION_TYPE,1,2)), UPPER(SUBSTR(p_TRANSACTION_TYPE_NEG,1,2)) )
            AND A.IS_IMPORT_EXPORT = p_IS_IMPORT_EXPORT
        	AND B.TRANSACTION_ID = A.TRANSACTION_ID
        	AND B.AS_OF_DATE =
        		(SELECT MAX(AS_OF_DATE)
        		FROM IT_STATUS
        		WHERE TRANSACTION_ID = B.TRANSACTION_ID
        			AND AS_OF_DATE <= p_AS_OF_DATE)
        	AND B.TRANSACTION_IS_ACTIVE = 1;

		v_IDX := v_TX_IDs.FIRST;
		WHILE v_TX_IDs.EXISTS(v_IDX) LOOP
			p_TRANSACTION_IDs.EXTEND();
			p_TRANSACTION_IDs(p_TRANSACTION_IDs.LAST) := v_TX_IDs(v_IDX);
			v_IDX := v_TX_IDs.NEXT(v_IDX);
		END LOOP;
	END IF;

	RETURN v_RET;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
    	RETURN 0;
END GET_LMP_QUANTITY;
---------------------------------------------------------------------------------------------------
-- This version of the function is called by PSE_LMP_BILATERAL_CHARGE
FUNCTION GET_LMP_QUANTITY
	(
    p_SERVICE_DATE IN DATE,
    p_SCHEDULE_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_CONTRACT_ID IN NUMBER,
    p_INTERVAL IN VARCHAR2,
    p_TRANSACTION_TYPE IN VARCHAR2,
    p_IS_IMPORT_EXPORT IN NUMBER,
    p_IS_VIRTUAL IN NUMBER,
    p_MARKET_TYPE IN VARCHAR2,
    p_SOURCE_ID IN NUMBER,
    p_POD_ID IN NUMBER,
    p_SINK_ID IN NUMBER,
    p_QUANTITY_UNIT IN VARCHAR2,
    p_UNITS_FACTOR IN NUMBER
    ) RETURN NUMBER IS
v_RET NUMBER;
BEGIN
    SELECT NVL(SUM(DECODE(UPPER(C.COMMODITY_UNIT||p_QUANTITY_UNIT),'MWHMW',p_UNITS_FACTOR,'MWMWH',1/p_UNITS_FACTOR,1)*D.AMOUNT),0)
    INTO v_RET
    FROM INTERCHANGE_TRANSACTION A,
    	IT_STATUS B,
    	IT_COMMODITY C,
    	IT_SCHEDULE D
    WHERE A.BEGIN_DATE <= TRUNC(p_SERVICE_DATE)
    	AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_SERVICE_DATE)
    	AND A.CONTRACT_ID = p_CONTRACT_ID
    	AND UPPER(A.TRANSACTION_INTERVAL) = UPPER(p_INTERVAL)
    	AND A.SOURCE_ID = DECODE(p_SOURCE_ID, g_NOT_ASSIGNED, A.SOURCE_ID, p_SOURCE_ID)
    	AND A.POD_ID = DECODE(p_POD_ID, g_NOT_ASSIGNED, A.POD_ID, p_POD_ID)
    	AND A.SINK_ID = DECODE(p_SINK_ID, g_NOT_ASSIGNED, A.SINK_ID, p_SINK_ID)
    	AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) = UPPER(SUBSTR(p_TRANSACTION_TYPE,1,2))
        AND A.IS_IMPORT_EXPORT = p_IS_IMPORT_EXPORT
    	AND B.TRANSACTION_ID = A.TRANSACTION_ID
    	AND B.AS_OF_DATE =
    		(SELECT MAX(AS_OF_DATE)
    		FROM IT_STATUS
    		WHERE TRANSACTION_ID = B.TRANSACTION_ID
    			AND AS_OF_DATE <= p_AS_OF_DATE)
    	AND B.TRANSACTION_IS_ACTIVE = 1
    	AND C.COMMODITY_ID = A.COMMODITY_ID
    	AND UPPER(SUBSTR(C.COMMODITY_TYPE,1,1)) = 'E'
        AND C.IS_VIRTUAL = p_IS_VIRTUAL
        AND C.MARKET_TYPE = p_MARKET_TYPE
		AND D.TRANSACTION_ID = A.TRANSACTION_ID
		AND D.SCHEDULE_TYPE = DECODE(g_ENABLE_SUPPLY_SCHEDULE_TYPES, 1, p_SCHEDULE_TYPE, g_NOT_ASSIGNED)
		AND D.SCHEDULE_STATE = GA.INTERNAL_STATE
		AND D.SCHEDULE_DATE = p_SCHEDULE_DATE
		AND D.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_SCHEDULE
			WHERE TRANSACTION_ID = D.TRANSACTION_ID
				AND SCHEDULE_TYPE = D.SCHEDULE_TYPE
				AND SCHEDULE_STATE = D.SCHEDULE_STATE
				AND SCHEDULE_DATE = D.SCHEDULE_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE);

	RETURN v_RET;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
    	RETURN 0;
END GET_LMP_QUANTITY;
---------------------------------------------------------------------------------------------------
-- This version of the function is called by PSE_LMP_ENERGY_CHARGE
FUNCTION GET_LMP_QUANTITY
	(
    p_SERVICE_DATE IN DATE,
    p_SCHEDULE_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_CONTRACT_ID IN NUMBER,
    p_INTERVAL IN VARCHAR2,
    p_TRANSACTION_TYPE IN VARCHAR2,
    p_IS_IMPORT_EXPORT IN NUMBER,
    p_IS_VIRTUAL IN NUMBER,
    p_MARKET_TYPE IN VARCHAR2,
    p_POINT_ID IN NUMBER,
    p_QUANTITY_UNIT IN VARCHAR2,
    p_UNITS_FACTOR IN NUMBER
    ) RETURN NUMBER IS
v_RET NUMBER;
BEGIN
    SELECT NVL(SUM(DECODE(UPPER(C.COMMODITY_UNIT||p_QUANTITY_UNIT),'MWHMW',p_UNITS_FACTOR,'MWMWH',1/p_UNITS_FACTOR,1)*D.AMOUNT),0)
    INTO v_RET
    FROM INTERCHANGE_TRANSACTION A,
    	IT_STATUS B,
    	IT_COMMODITY C,
    	IT_SCHEDULE D
    WHERE A.BEGIN_DATE <= TRUNC(p_SERVICE_DATE)
    	AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_SERVICE_DATE)
    	AND A.CONTRACT_ID = p_CONTRACT_ID
    	AND UPPER(A.TRANSACTION_INTERVAL) = UPPER(p_INTERVAL)
		AND (p_POINT_ID = g_NOT_ASSIGNED OR
        		CASE UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2))
                WHEN 'PU' THEN NVL(SINK_ID,POD_ID)
                WHEN 'SA' THEN NVL(SOURCE_ID,POR_ID)
    			ELSE POD_ID
                END = p_POINT_ID)
    	AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) = UPPER(SUBSTR(p_TRANSACTION_TYPE,1,2))
        AND A.IS_IMPORT_EXPORT = p_IS_IMPORT_EXPORT
    	AND B.TRANSACTION_ID = A.TRANSACTION_ID
    	AND B.AS_OF_DATE =
    		(SELECT MAX(AS_OF_DATE)
    		FROM IT_STATUS
    		WHERE TRANSACTION_ID = B.TRANSACTION_ID
    			AND AS_OF_DATE <= p_AS_OF_DATE)
    	AND B.TRANSACTION_IS_ACTIVE = 1
    	AND C.COMMODITY_ID = A.COMMODITY_ID
    	AND UPPER(SUBSTR(C.COMMODITY_TYPE,1,1)) = 'E'
        AND C.IS_VIRTUAL = p_IS_VIRTUAL
        AND C.MARKET_TYPE = p_MARKET_TYPE
		AND D.TRANSACTION_ID = A.TRANSACTION_ID
		AND D.SCHEDULE_TYPE = DECODE(g_ENABLE_SUPPLY_SCHEDULE_TYPES, 1, p_SCHEDULE_TYPE, g_NOT_ASSIGNED)
		AND D.SCHEDULE_STATE = GA.INTERNAL_STATE
		AND D.SCHEDULE_DATE = p_SCHEDULE_DATE
		AND D.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_SCHEDULE
			WHERE TRANSACTION_ID = D.TRANSACTION_ID
				AND SCHEDULE_TYPE = D.SCHEDULE_TYPE
				AND SCHEDULE_STATE = D.SCHEDULE_STATE
				AND SCHEDULE_DATE = D.SCHEDULE_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE);

	RETURN v_RET;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
    	RETURN 0;
END GET_LMP_QUANTITY;
---------------------------------------------------------------------------------------------------
FUNCTION GET_FIRST_INTERVAL
	(
	p_DATE IN DATE,
	p_INTERVAL IN VARCHAR
	) RETURN DATE IS

v_INTERVAL CHAR(2);

BEGIN

	v_INTERVAL := UPPER(SUBSTR(p_INTERVAL,1,2));
	IF v_INTERVAL = 'HO' THEN
	    RETURN TRUNC(p_DATE)+1/24;
	ELSIF v_INTERVAL = '5 ' THEN
	    RETURN TRUNC(p_DATE)+5/(24*60);
	ELSIF v_INTERVAL = '10' THEN
	    RETURN TRUNC(p_DATE)+10/(24*60);
	ELSIF v_INTERVAL = '15' THEN
	    RETURN TRUNC(p_DATE)+15/(24*60);
	ELSIF v_INTERVAL = '30' THEN
	    RETURN TRUNC(p_DATE)+30/(24*60);
	ELSE -- Day, Week, Month, Quarter, Year
	    RETURN TRUNC(p_DATE)+1/86400;
	END IF;

	RETURN NULL;

END GET_FIRST_INTERVAL;
---------------------------------------------------------------------------------------------------
FUNCTION GET_NEXT_INTERVAL
	(
	p_DATE IN DATE,
	p_INTERVAL IN VARCHAR
	) RETURN DATE IS

v_INTERVAL CHAR(2);

BEGIN

	v_INTERVAL := UPPER(SUBSTR(p_INTERVAL,1,2));
	IF v_INTERVAL = 'HO' THEN
	    RETURN p_DATE+1/24;
	ELSIF v_INTERVAL = 'DA' THEN
	    RETURN p_DATE + 1;
	ELSIF v_INTERVAL = 'WE' THEN
	    RETURN p_DATE + 7;
	ELSIF v_INTERVAL = 'MO' THEN
	    RETURN ADD_MONTHS(p_DATE,1);
	ELSIF v_INTERVAL = 'YE' THEN
	    RETURN ADD_MONTHS(p_DATE,12);
	ELSIF v_INTERVAL = '5 ' THEN
	    RETURN p_DATE+5/(24*60);
	ELSIF v_INTERVAL = '10' THEN
	    RETURN p_DATE+10/(24*60);
	ELSIF v_INTERVAL = '15' THEN
	    RETURN p_DATE+15/(24*60);
	ELSIF v_INTERVAL = '30' THEN
	    RETURN p_DATE+30/(24*60);
	ELSIF v_INTERVAL = 'QU' THEN
	    RETURN ADD_MONTHS(p_DATE,3);
	END IF;

	RETURN NULL;

END GET_NEXT_INTERVAL;
---------------------------------------------------------------------------------------------------
FUNCTION GET_FTR_ALLOC_FACTOR
	(
    p_SERVICE_DATE IN DATE,
    p_SCHEDULE_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_PSE_ID IN NUMBER
    ) RETURN NUMBER IS
v_RET NUMBER;
BEGIN
    SELECT AVG(NVL(D.AMOUNT,1.0))
    INTO v_RET
    FROM INTERCHANGE_TRANSACTION A,
    	IT_STATUS B,
    	IT_SCHEDULE D
    WHERE A.BEGIN_DATE <= TRUNC(p_SERVICE_DATE)
    	AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_SERVICE_DATE)
    	AND A.SELLER_ID = p_PSE_ID
    	AND UPPER(A.TRANSACTION_TYPE) = 'FTR ALLOC FACTOR'
    	AND B.TRANSACTION_ID = A.TRANSACTION_ID
    	AND B.AS_OF_DATE = CONSTANTS.LOW_DATE
    	AND B.TRANSACTION_IS_ACTIVE = 1
		AND D.TRANSACTION_ID = A.TRANSACTION_ID
		AND D.SCHEDULE_TYPE = DECODE(g_ENABLE_SUPPLY_SCHEDULE_TYPES, 1, p_SCHEDULE_TYPE, g_NOT_ASSIGNED)
		AND D.SCHEDULE_STATE = GA.INTERNAL_STATE
		AND D.SCHEDULE_DATE = p_SCHEDULE_DATE
		AND D.AS_OF_DATE = CONSTANTS.LOW_DATE;

	RETURN v_RET;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
    	RETURN 1.0;
END GET_FTR_ALLOC_FACTOR;
---------------------------------------------------------------------------------------------------
FUNCTION GET_FTR_QUANTITY
	(
    p_SERVICE_DATE IN DATE,
    p_SCHEDULE_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_CONTRACT_ID IN NUMBER,
    p_INTERVAL IN VARCHAR2,
    p_TRANSACTION_TYPE IN VARCHAR2,
    p_IS_OBLIGATION IN NUMBER,
    p_SOURCE_ID IN NUMBER,
    p_POD_ID IN NUMBER,
    p_SINK_ID IN NUMBER,
    p_QUANTITY_UNIT IN VARCHAR2,
    p_UNITS_FACTOR IN NUMBER
    ) RETURN NUMBER IS
v_RET NUMBER;
BEGIN
    SELECT NVL(SUM(DECODE(UPPER(C.COMMODITY_UNIT||p_QUANTITY_UNIT),'MWHMW',p_UNITS_FACTOR,'MWMWH',1/p_UNITS_FACTOR,1)*D.AMOUNT),0)
    INTO v_RET
    FROM INTERCHANGE_TRANSACTION A,
    	IT_STATUS B,
    	IT_COMMODITY C,
    	IT_SCHEDULE D
    WHERE A.BEGIN_DATE <= TRUNC(p_SERVICE_DATE)
    	AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_SERVICE_DATE)
    	AND A.CONTRACT_ID = p_CONTRACT_ID
    	AND UPPER(A.TRANSACTION_INTERVAL) = UPPER(p_INTERVAL)
    	AND A.SOURCE_ID = DECODE(p_SOURCE_ID, g_NOT_ASSIGNED, A.SOURCE_ID, p_SOURCE_ID)
    	AND A.POD_ID = DECODE(p_POD_ID, g_NOT_ASSIGNED, A.POD_ID, p_POD_ID)
    	AND A.SINK_ID = DECODE(p_SINK_ID, g_NOT_ASSIGNED, A.SINK_ID, p_SINK_ID)
    	AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) = UPPER(SUBSTR(p_TRANSACTION_TYPE,1,2))
        AND UPPER(A.AGREEMENT_TYPE) LIKE DECODE(p_IS_OBLIGATION,1,'%OBL%','%OPT%')
    	AND B.TRANSACTION_ID = A.TRANSACTION_ID
    	AND B.AS_OF_DATE = CONSTANTS.LOW_DATE
    	AND B.TRANSACTION_IS_ACTIVE = 1
    	AND C.COMMODITY_ID = A.COMMODITY_ID
    	AND UPPER(SUBSTR(C.COMMODITY_TYPE,1,1)) = 'T'
		AND D.TRANSACTION_ID = A.TRANSACTION_ID
		AND D.SCHEDULE_TYPE = DECODE(g_ENABLE_SUPPLY_SCHEDULE_TYPES, 1, p_SCHEDULE_TYPE, g_NOT_ASSIGNED)
		AND D.SCHEDULE_STATE = GA.INTERNAL_STATE
		AND D.SCHEDULE_DATE = p_SCHEDULE_DATE
		AND D.AS_OF_DATE = CONSTANTS.LOW_DATE;

	RETURN v_RET;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
    	RETURN 0;
END GET_FTR_QUANTITY;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_PJM_FTR_AMOUNT
	(
    p_SERVICE_DATE IN DATE,
    p_SCHEDULE_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_CONTRACT_ID IN NUMBER,
    p_INTERVAL IN VARCHAR2,
    p_TRANSACTION_TYPE IN VARCHAR2,
    p_IS_OBLIGATION IN NUMBER,
    p_SOURCE_ID IN NUMBER,
    p_POD_ID IN NUMBER,
    p_SINK_ID IN NUMBER,
    p_QUANTITY_UNIT IN VARCHAR2,
    p_UNITS_FACTOR IN NUMBER,
    p_PRICE IN NUMBER,
    p_AMOUNT OUT NUMBER,
    p_QUANTITY OUT NUMBER
    ) AS
BEGIN
    SELECT NVL(SUM(DECODE(UPPER(C.COMMODITY_UNIT||p_QUANTITY_UNIT),'MWHMW',p_UNITS_FACTOR,'MWMWH',1/p_UNITS_FACTOR,1)*D.AMOUNT),0),
          NVL(SUM(ROUND(DECODE(UPPER(C.COMMODITY_UNIT||p_QUANTITY_UNIT),'MWHMW',p_UNITS_FACTOR,'MWMWH',1/p_UNITS_FACTOR,1)*D.AMOUNT * p_PRICE,2)),0)
    INTO p_QUANTITY, p_AMOUNT
    FROM INTERCHANGE_TRANSACTION A,
    	IT_STATUS B,
    	IT_COMMODITY C,
    	IT_SCHEDULE D
    WHERE A.BEGIN_DATE <= TRUNC(p_SERVICE_DATE)
    	AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_SERVICE_DATE)
    	AND A.CONTRACT_ID = p_CONTRACT_ID
    	AND UPPER(A.TRANSACTION_INTERVAL) = UPPER(p_INTERVAL)
    	AND A.SOURCE_ID = DECODE(p_SOURCE_ID, g_NOT_ASSIGNED, A.SOURCE_ID, p_SOURCE_ID)
    	AND A.POD_ID = DECODE(p_POD_ID, g_NOT_ASSIGNED, A.POD_ID, p_POD_ID)
    	AND A.SINK_ID = DECODE(p_SINK_ID, g_NOT_ASSIGNED, A.SINK_ID, p_SINK_ID)
    	AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) = UPPER(SUBSTR(p_TRANSACTION_TYPE,1,2))
        AND UPPER(A.AGREEMENT_TYPE) LIKE DECODE(p_IS_OBLIGATION,1,'%OBL%','%OPT%')
    	AND B.TRANSACTION_ID = A.TRANSACTION_ID
    	AND B.AS_OF_DATE = CONSTANTS.LOW_DATE
    	AND B.TRANSACTION_IS_ACTIVE = 1
    	AND C.COMMODITY_ID = A.COMMODITY_ID
    	AND UPPER(SUBSTR(C.COMMODITY_TYPE,1,1)) = 'T'
		AND D.TRANSACTION_ID = A.TRANSACTION_ID
		AND D.SCHEDULE_TYPE = DECODE(g_ENABLE_SUPPLY_SCHEDULE_TYPES, 1, p_SCHEDULE_TYPE, g_NOT_ASSIGNED)
		AND D.SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE
		AND D.SCHEDULE_DATE = p_SCHEDULE_DATE
		AND D.AS_OF_DATE = CONSTANTS.LOW_DATE;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        NULL;

END GET_PJM_FTR_AMOUNT;
---------------------------------------------------------------------------------------------------
FUNCTION GET_FTR_QUANTITY_SUM
	(
    p_SERVICE_DATE IN DATE,
    p_SCHEDULE_BEG_DATE IN DATE,
    p_SCHEDULE_END_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_CONTRACT_ID IN NUMBER,
    p_INTERVAL IN VARCHAR2,
    p_TRANSACTION_TYPE IN VARCHAR2,
    p_IS_OBLIGATION IN NUMBER,
    p_SOURCE_ID IN NUMBER,
    p_POD_ID IN NUMBER,
    p_SINK_ID IN NUMBER,
    p_QUANTITY_UNIT IN VARCHAR2,
    p_UNITS_FACTOR IN NUMBER
    ) RETURN NUMBER IS
v_RET NUMBER;
BEGIN
    SELECT SUM(D.AMOUNT)
    INTO v_RET
    FROM INTERCHANGE_TRANSACTION A,
    	IT_STATUS B,
    	IT_COMMODITY C,
    	IT_SCHEDULE D
    WHERE A.BEGIN_DATE <= TRUNC(p_SERVICE_DATE)
    	AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_SERVICE_DATE)
    	AND A.CONTRACT_ID = p_CONTRACT_ID
    	AND UPPER(A.TRANSACTION_INTERVAL) = UPPER(p_INTERVAL)
    	AND A.SOURCE_ID = DECODE(p_SOURCE_ID, g_NOT_ASSIGNED, A.SOURCE_ID, p_SOURCE_ID)
    	AND A.POD_ID = DECODE(p_POD_ID, g_NOT_ASSIGNED, A.POD_ID, p_POD_ID)
    	AND A.SINK_ID = DECODE(p_SINK_ID, g_NOT_ASSIGNED, A.SINK_ID, p_SINK_ID)
    	AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) = UPPER(SUBSTR(p_TRANSACTION_TYPE,1,2))
        AND UPPER(A.AGREEMENT_TYPE) LIKE DECODE(p_IS_OBLIGATION,1,'%OBL%','%OPT%')
    	AND B.TRANSACTION_ID = A.TRANSACTION_ID
    	AND B.AS_OF_DATE =
    		(SELECT MAX(AS_OF_DATE)
    		FROM IT_STATUS
    		WHERE TRANSACTION_ID = B.TRANSACTION_ID
    			AND AS_OF_DATE <= p_AS_OF_DATE)
    	AND B.TRANSACTION_IS_ACTIVE = 1
    	AND C.COMMODITY_ID = A.COMMODITY_ID
    	AND UPPER(SUBSTR(C.COMMODITY_TYPE,1,1)) = 'T'
		AND D.TRANSACTION_ID = A.TRANSACTION_ID
		AND D.SCHEDULE_TYPE = DECODE(g_ENABLE_SUPPLY_SCHEDULE_TYPES, 1, p_SCHEDULE_TYPE, g_NOT_ASSIGNED)
		AND D.SCHEDULE_STATE = GA.INTERNAL_STATE
		AND D.SCHEDULE_DATE BETWEEN p_SCHEDULE_BEG_DATE AND p_SCHEDULE_END_DATE
		AND D.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_SCHEDULE
			WHERE TRANSACTION_ID = D.TRANSACTION_ID
				AND SCHEDULE_TYPE = D.SCHEDULE_TYPE
				AND SCHEDULE_STATE = D.SCHEDULE_STATE
				AND SCHEDULE_DATE = D.SCHEDULE_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE);

	RETURN v_RET;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
    	RETURN 0;
END GET_FTR_QUANTITY_SUM;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_FTR_ALLOCATION
	(
    p_PSE_ID IN NUMBER,
	p_CONTRACT_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_CHARGE_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_DATE DATE;
v_FTR_CHARGE FTR_CHARGE%ROWTYPE;
v_PRIOR_CHARGE_ID NUMBER;
v_UNITS_FACTOR NUMBER := 1;
v_PUT_ROW BOOLEAN;
v_PJM_FLAG BOOLEAN := FALSE;
v_SC VARCHAR2(16);
v_SUM_OBL_PURCH IT_SCHEDULE.AMOUNT%TYPE;
v_SUM_OPT_PURCH IT_SCHEDULE.AMOUNT%TYPE;
v_FLAG BINARY_INTEGER := 0;
v_FTR_AMOUNT NUMBER;

CURSOR c_POINTS IS
	SELECT DISTINCT A.SOURCE_ID "SOURCE_ID",
    				g_NOT_ASSIGNED "POD_ID",
                    A.SINK_ID "SINK_ID",
    				B.MARKET_PRICE_ID "MARKET_PRICE_ID1",
    				C.MARKET_PRICE_ID "MARKET_PRICE_ID2"
    FROM INTERCHANGE_TRANSACTION A,
    	MARKET_PRICE B,
        MARKET_PRICE C,
				SERVICE_POINT S
	WHERE A.BEGIN_DATE <= TRUNC(p_END_DATE)
		AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
		AND A.CONTRACT_ID = p_CONTRACT_ID
		AND UPPER(A.TRANSACTION_INTERVAL) =  UPPER(p_COMPONENT.RATE_INTERVAL)
        AND A.POD_ID = DECODE(p_COMPONENT.SERVICE_POINT_ID,g_NOT_ASSIGNED,A.POD_ID,p_COMPONENT.SERVICE_POINT_ID)
        AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) IN ('PU','SA')
        AND B.MARKET_PRICE_TYPE = p_COMPONENT.MARKET_PRICE_TYPE
        AND B.MARKET_TYPE = p_COMPONENT.MARKET_TYPE
    	AND B.POD_ID = A.SOURCE_ID
				AND S.SERVICE_POINT_ID = A.SINK_ID
        AND C.MARKET_PRICE_TYPE =
			        (CASE WHEN v_FLAG = 1 AND UPPER(S.NODE_TYPE) = 'ZONE' AND UPPER(p_COMPONENT.MARKET_PRICE_TYPE) = 'LOCATIONAL MARGINAL PRICE' THEN 'FTR Zonal LMP'
                        WHEN v_FLAG = 1 AND UPPER(S.NODE_TYPE) = 'ZONE' AND UPPER(p_COMPONENT.MARKET_PRICE_TYPE) = 'MARGINAL CONGESTION COMPONENT' THEN 'FTR Zonal Congestion Price'
                ELSE p_COMPONENT.MARKET_PRICE_TYPE END)
        AND C.MARKET_TYPE = p_COMPONENT.MARKET_TYPE
    	AND C.POD_ID = A.SINK_ID
		AND UPPER(A.AGREEMENT_TYPE) LIKE '%FTR%';
BEGIN

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('FTR Allocation Charge (CONTRACT_ID=' || p_CONTRACT_ID || '; SCHEDULE_TYPE=' || p_SCHEDULE_TYPE || '; STATEMENT_TYPE=' || p_STATEMENT_TYPE ||
			'; CHARGE_ID=' || p_CHARGE_ID || '; COMPONENT=' || p_COMPONENT.COMPONENT_NAME || '(' || p_COMPONENT.COMPONENT_ID || ')' ||
			'; BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE,'MM/DD/YYYY') || '; END_DATE=' || TO_CHAR(p_END_DATE,'MM/DD/YYYY') ||
			'; AS_OF_DATE=' || TO_CHAR(p_AS_OF_DATE,'MM/DD/YYYY HH24:MI')||')');
	END IF;

	IF UPPER(SUBSTR(p_COMPONENT.RATE_INTERVAL,1,2)) IN ('DA','WE','MO','YE') THEN
	    v_BEGIN_DATE := p_BEGIN_DATE;
		v_END_DATE := p_END_DATE + 1;
	ELSE
	    UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
        v_BEGIN_DATE := TO_CUT(GET_FIRST_INTERVAL(p_BEGIN_DATE,p_COMPONENT.RATE_INTERVAL),p_TIME_ZONE);
	END IF;
	GET_UNITS_FACTOR(p_COMPONENT.RATE_INTERVAL, v_UNITS_FACTOR);

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('PSE_FTR_ALLOCATION');
		LOGS.LOG_DEBUG('CONTRACT_ID=' || TO_CHAR(p_CONTRACT_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_END_DATE));
	    LOGS.LOG_DEBUG('<id>,<date>,<src id>,<pod id>,<sink id>,<obligations>,<options>,<da sales>,<rt sales>,<da load>,<rt load>,<da gen>,<rt gen>,<quantity>,<rate>,<factor>,<amount>');
	END IF;

	v_PRIOR_CHARGE_ID := GET_PRIOR_CHARGE_ID(p_CHARGE_ID);
	v_FTR_CHARGE.CHARGE_ID := p_CHARGE_ID;

    --cgn set pjm flag since charge handled differently for pjm and miso
    SELECT SC_ALIAS INTO v_SC
    FROM INTERCHANGE_CONTRACT I, SCHEDULE_COORDINATOR S
    WHERE I.CONTRACT_ID = p_CONTRACT_ID
    AND I.SC_ID = S.SC_ID;
    IF UPPER(v_SC) = 'PJM' THEN
    	v_PJM_FLAG := TRUE;
        v_FLAG := 1;
    END IF;


	FOR v_POINT IN c_POINTS LOOP
   		v_FTR_CHARGE.SOURCE_ID := v_POINT.SOURCE_ID;
        v_FTR_CHARGE.DELIVERY_POINT_ID := v_POINT.POD_ID;
        v_FTR_CHARGE.SINK_ID := v_POINT.SINK_ID;

        v_DATE := v_BEGIN_DATE; --GET_FIRST_INTERVAL(v_BEGIN_DATE,p_COMPONENT.RATE_INTERVAL);

        -- cgn get the sum of puchases for the month. If zero, don't need to gather the
        -- purchases for each hour in the month (PJM only)
        v_SUM_OBL_PURCH := GET_FTR_QUANTITY_SUM(TRUNC(p_BEGIN_DATE+(v_DATE-v_BEGIN_DATE)),
            							v_BEGIN_DATE, v_END_DATE,p_SCHEDULE_TYPE,p_AS_OF_DATE,p_CONTRACT_ID,
                                        p_COMPONENT.RATE_INTERVAL,'PU',1,
                                        v_POINT.SOURCE_ID,v_POINT.POD_ID,v_POINT.SINK_ID,
                                        p_COMPONENT.QUANTITY_UNIT,v_UNITS_FACTOR);




        v_SUM_OPT_PURCH := GET_FTR_QUANTITY_SUM(TRUNC(p_BEGIN_DATE+(v_DATE-v_BEGIN_DATE)),
            							v_BEGIN_DATE, v_END_DATE,p_SCHEDULE_TYPE,p_AS_OF_DATE,p_CONTRACT_ID,
                                        p_COMPONENT.RATE_INTERVAL,'PU',0,
                                        v_POINT.SOURCE_ID,v_POINT.POD_ID,v_POINT.SINK_ID,
                                        p_COMPONENT.QUANTITY_UNIT,v_UNITS_FACTOR);


        IF ((v_SUM_OBL_PURCH > 0 OR v_SUM_OPT_PURCH > 0) AND v_PJM_FLAG = TRUE) OR v_PJM_FLAG = FALSE THEN
            WHILE v_DATE <= v_END_DATE LOOP
            	v_FTR_CHARGE.CHARGE_DATE := v_DATE;
    			v_FTR_CHARGE.CHARGE_FACTOR := GET_COMPONENT_FACTOR(p_COMPONENT.COMPONENT_ID, v_DATE);

                -- First do Obligations
            	v_PUT_ROW := FALSE;
                v_FTR_CHARGE.FTR_TYPE := 'Obligation';

                IF v_PJM_FLAG = FALSE THEN
                    v_FTR_CHARGE.ALLOC_FACTOR := GET_FTR_ALLOC_FACTOR(TRUNC(p_BEGIN_DATE+(v_DATE-v_BEGIN_DATE)),
                							v_DATE,p_SCHEDULE_TYPE,p_AS_OF_DATE,p_PSE_ID);
                ELSE
                    --ftr allocation factor not used in the PJM calculation anymore
                    v_FTR_CHARGE.ALLOC_FACTOR := 1;
                END IF;

                 -- get the rate
              	v_FTR_CHARGE.PRICE1 := GET_LMP_PRICE(v_POINT.MARKET_PRICE_ID1, v_DATE, p_AS_OF_DATE);
              	v_FTR_CHARGE.PRICE2 := GET_LMP_PRICE(v_POINT.MARKET_PRICE_ID2, v_DATE, p_AS_OF_DATE);

               IF v_PJM_FLAG = FALSE THEN
                    v_FTR_CHARGE.ALLOC_FACTOR := GET_FTR_ALLOC_FACTOR(TRUNC(p_BEGIN_DATE+(v_DATE-v_BEGIN_DATE)),
                							v_DATE,p_SCHEDULE_TYPE,p_AS_OF_DATE,p_PSE_ID);
                ELSE
                    --ftr allocation factor not used in the PJM calculation anymore
                    v_FTR_CHARGE.ALLOC_FACTOR := 1;
                END IF;

                -- get the rate
              	v_FTR_CHARGE.PRICE1 := GET_LMP_PRICE(v_POINT.MARKET_PRICE_ID1, v_DATE, p_AS_OF_DATE);
              	v_FTR_CHARGE.PRICE2 := GET_LMP_PRICE(v_POINT.MARKET_PRICE_ID2, v_DATE, p_AS_OF_DATE);

                --If the LMP is not yet available, credit should be 0. To accomplish this, set both rates to 0.
                --Specific request from Allegheny Energy.
                IF (v_FTR_CHARGE.Price1 IS NULL OR v_FTR_CHARGE.Price2 IS NULL) AND v_PJM_FLAG = TRUE THEN
                    v_FTR_CHARGE.Price1 := 0;
                    v_FTR_CHARGE.Price2 := 0;
                END IF;


                -- gather FTR purchases
                IF v_PJM_FLAG = FALSE THEN
            	    v_FTR_CHARGE.PURCHASES := GET_FTR_QUANTITY(TRUNC(p_BEGIN_DATE+(v_DATE-v_BEGIN_DATE)),
                							v_DATE,p_SCHEDULE_TYPE,p_AS_OF_DATE,p_CONTRACT_ID,
                                            p_COMPONENT.RATE_INTERVAL,'PU',1,
                                            v_POINT.SOURCE_ID,v_POINT.POD_ID,v_POINT.SINK_ID,
                                            p_COMPONENT.QUANTITY_UNIT,v_UNITS_FACTOR);

                ELSE
                    -- A new procedure is used so that the quantity * price can be
                    -- rounded before summing for precision issues with Billing report.
                    GET_PJM_FTR_AMOUNT(TRUNC(p_BEGIN_DATE+(v_DATE-v_BEGIN_DATE)),
                							v_DATE,p_SCHEDULE_TYPE,p_AS_OF_DATE,p_CONTRACT_ID,
                                            p_COMPONENT.RATE_INTERVAL,'PU',1,
                                            v_POINT.SOURCE_ID,v_POINT.POD_ID,v_POINT.SINK_ID,
                                            p_COMPONENT.QUANTITY_UNIT,v_UNITS_FACTOR,
                                            NVL(v_FTR_CHARGE.PRICE2,0)-NVL(v_FTR_CHARGE.PRICE1,0),
                                            v_FTR_AMOUNT, v_FTR_CHARGE.PURCHASES);



                IF NVL(v_FTR_CHARGE.PURCHASES,0) <> 0 THEN v_PUT_ROW := TRUE; END IF;
                END IF;


                --now gather sales
                -- cgn don't need to gather sales for PJM
                IF v_PJM_FLAG = FALSE THEN
            		v_FTR_CHARGE.SALES := GET_FTR_QUANTITY(TRUNC(p_BEGIN_DATE+(v_DATE-v_BEGIN_DATE)),
                							v_DATE,p_SCHEDULE_TYPE,p_AS_OF_DATE,p_CONTRACT_ID,
                                            p_COMPONENT.RATE_INTERVAL,'SA',1,
                                            v_POINT.SOURCE_ID,v_POINT.POD_ID,v_POINT.SINK_ID,
                                            p_COMPONENT.QUANTITY_UNIT,v_UNITS_FACTOR);
                ELSE
                	v_FTR_CHARGE.SALES := 0;
                END IF;
                IF NVL(v_FTR_CHARGE.SALES,0) <> 0 THEN v_PUT_ROW := TRUE; END IF;

                -- and wrap up this entry
                IF v_PUT_ROW THEN -- only put row if all non-null data
    	            IF v_PJM_FLAG = FALSE THEN
                    	v_FTR_CHARGE.CHARGE_RATE := NVL(v_FTR_CHARGE.PRICE1,0)-NVL(v_FTR_CHARGE.PRICE2,0);
                    ELSE
                    	v_FTR_CHARGE.CHARGE_RATE := NVL(v_FTR_CHARGE.PRICE2,0)-NVL(v_FTR_CHARGE.PRICE1,0);
                    END IF;

                    v_FTR_CHARGE.CHARGE_QUANTITY := NVL(v_FTR_CHARGE.PURCHASES,0)-NVL(v_FTR_CHARGE.SALES,0);
                    IF v_PJM_FLAG = FALSE THEN
                    	IF v_FTR_CHARGE.CHARGE_RATE*v_FTR_CHARGE.CHARGE_QUANTITY < 0 THEN
                    		v_FTR_CHARGE.CHARGE_QUANTITY := v_FTR_CHARGE.CHARGE_QUANTITY*NVL(v_FTR_CHARGE.ALLOC_FACTOR,0);
    					END IF;
                        v_FTR_CHARGE.CHARGE_AMOUNT := v_FTR_CHARGE.CHARGE_FACTOR*v_FTR_CHARGE.CHARGE_RATE*v_FTR_CHARGE.CHARGE_QUANTITY;
                    ELSE
                        v_FTR_CHARGE.CHARGE_AMOUNT := v_FTR_AMOUNT;
                    END IF;

                    PRIOR_FTR_CHARGE(v_PRIOR_CHARGE_ID, v_FTR_CHARGE);
                    PUT_FTR_CHARGE(v_FTR_CHARGE);

    			END IF;

                -- Next do Options
            	v_PUT_ROW := FALSE;
                v_FTR_CHARGE.FTR_TYPE := 'Option';

                -- gather FTR purchases
                IF v_PJM_FLAG = FALSE THEN
            	    v_FTR_CHARGE.PURCHASES := GET_FTR_QUANTITY(TRUNC(p_BEGIN_DATE+(v_DATE-v_BEGIN_DATE)),
                							v_DATE,p_SCHEDULE_TYPE,p_AS_OF_DATE,p_CONTRACT_ID,
                                            p_COMPONENT.RATE_INTERVAL,'PU',0,
                                            v_POINT.SOURCE_ID,v_POINT.POD_ID,v_POINT.SINK_ID,
                                            p_COMPONENT.QUANTITY_UNIT,v_UNITS_FACTOR);
                    IF NVL(v_FTR_CHARGE.PURCHASES,0) <> 0 THEN v_PUT_ROW := TRUE; END IF;
                ELSE
                    -- A new procedure is used so that the quantity * price can be
                    -- rounded before summing for precision issues with Billing report.
                    GET_PJM_FTR_AMOUNT(TRUNC(p_BEGIN_DATE+(v_DATE-v_BEGIN_DATE)),
                							v_DATE,p_SCHEDULE_TYPE,p_AS_OF_DATE,p_CONTRACT_ID,
                                            p_COMPONENT.RATE_INTERVAL,'PU',0,
                                            v_POINT.SOURCE_ID,v_POINT.POD_ID,v_POINT.SINK_ID,
                                            p_COMPONENT.QUANTITY_UNIT,v_UNITS_FACTOR,
                                            NVL(v_FTR_CHARGE.PRICE2,0)-NVL(v_FTR_CHARGE.PRICE1,0),
                                            v_FTR_AMOUNT, v_FTR_CHARGE.PURCHASES);

                 IF NVL(v_FTR_CHARGE.PURCHASES,0) <> 0 THEN v_PUT_ROW := TRUE; END IF;
                END IF;

                --now gather sales
                -- cgn don't need to gather sales for PJM
            	 IF v_PJM_FLAG = FALSE THEN

    	            v_FTR_CHARGE.SALES := GET_FTR_QUANTITY(TRUNC(p_BEGIN_DATE+(v_DATE-v_BEGIN_DATE)),
                							v_DATE,p_SCHEDULE_TYPE,p_AS_OF_DATE,p_CONTRACT_ID,
                                            p_COMPONENT.RATE_INTERVAL,'SA',0,
                                            v_POINT.SOURCE_ID,v_POINT.POD_ID,v_POINT.SINK_ID,
                                            p_COMPONENT.QUANTITY_UNIT,v_UNITS_FACTOR);
                ELSE
                	v_FTR_CHARGE.SALES := 0;
                END IF;
                IF NVL(v_FTR_CHARGE.SALES,0) <> 0 THEN v_PUT_ROW := TRUE; END IF;

            -- and wrap up this entry
                IF v_PUT_ROW THEN -- only put row if all non-null data
    	           	IF v_PJM_FLAG = FALSE THEN
                    	v_FTR_CHARGE.CHARGE_RATE := v_FTR_CHARGE.PRICE1-v_FTR_CHARGE.PRICE2;
                    ELSE
                    	v_FTR_CHARGE.CHARGE_RATE := v_FTR_CHARGE.PRICE2-v_FTR_CHARGE.PRICE1;
                    END IF;
                	v_FTR_CHARGE.CHARGE_QUANTITY := v_FTR_CHARGE.PURCHASES-v_FTR_CHARGE.SALES;
                	IF v_PJM_FLAG = FALSE THEN
                    -- cgn different logic pjm vs. miso
                		IF v_FTR_CHARGE.CHARGE_RATE*v_FTR_CHARGE.CHARGE_QUANTITY < 0 THEN
                			v_FTR_CHARGE.CHARGE_QUANTITY := v_FTR_CHARGE.CHARGE_QUANTITY*NVL(v_FTR_CHARGE.ALLOC_FACTOR,0);
						ELSE
                			v_FTR_CHARGE.CHARGE_QUANTITY := 0;
						END IF;
                        v_FTR_CHARGE.CHARGE_AMOUNT := v_FTR_CHARGE.CHARGE_FACTOR*v_FTR_CHARGE.CHARGE_RATE*v_FTR_CHARGE.CHARGE_QUANTITY;
                    ELSE
                        v_FTR_CHARGE.CHARGE_AMOUNT := v_FTR_AMOUNT;
                	END IF;

                	PRIOR_FTR_CHARGE(v_PRIOR_CHARGE_ID, v_FTR_CHARGE);
                	PUT_FTR_CHARGE(v_FTR_CHARGE);
				END IF;
            	v_DATE := GET_NEXT_INTERVAL(v_DATE,p_COMPONENT.RATE_INTERVAL);
			END LOOP;
        END IF;
    END LOOP;
	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('FTR Allocation Charge - Completed Successfully');
	END IF;

END PSE_FTR_ALLOCATION;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_LMP_COMMODITY_CHARGE
	(
	p_CONTRACT_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_CHARGE_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_DATE DATE;
v_SERVICE_DATE DATE;
v_LMP_CHARGE LMP_CHARGE%ROWTYPE;
v_COMMODITY_ID1 NUMBER;
v_COMMODITY_ID2 NUMBER;
v_BL_SCALE NUMBER := NVL(p_COMPONENT.BILATERALS_SIGN,1);
v_PRIOR_CHARGE_ID NUMBER;
v_UNITS_FACTOR NUMBER := 1;
v_PUT_ROW BOOLEAN;
v_LMP_PRICE NUMBER := 0;
v_TRANSACTIONS ID_TABLE := NULL;

CURSOR c_POINTS IS
	SELECT DISTINCT A.POD_ID, C.MARKET_PRICE_ID
    FROM INTERCHANGE_TRANSACTION A,
		SERVICE_POINT B,
    	MARKET_PRICE C
	WHERE A.BEGIN_DATE <= TRUNC(p_END_DATE)
		AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
		AND A.CONTRACT_ID = p_CONTRACT_ID
		AND UPPER(A.TRANSACTION_INTERVAL) =  UPPER(p_COMPONENT.RATE_INTERVAL)
        AND A.POD_ID = DECODE(p_COMPONENT.SERVICE_POINT_ID,g_NOT_ASSIGNED,A.POD_ID,p_COMPONENT.SERVICE_POINT_ID)
        AND A.COMMODITY_ID = p_COMPONENT.LMP_COMMODITY_ID
		AND B.SERVICE_POINT_ID(+) = A.POD_ID
        AND C.MARKET_PRICE_TYPE = p_COMPONENT.MARKET_PRICE_TYPE
        AND C.COMMODITY_ID = A.COMMODITY_ID
    	AND ((NVL(p_COMPONENT.USE_ZONAL_PRICE,0) <> 0 AND C.ZOD_ID = B.SERVICE_ZONE_ID)
			OR (NVL(p_COMPONENT.USE_ZONAL_PRICE,0) = 0 AND C.POD_ID = A.POD_ID))
        AND C.MARKET_PRICE_INTERVAL = A.TRANSACTION_INTERVAL;

BEGIN

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('LMP Commodity Charge (CONTRACT_ID=' || p_CONTRACT_ID || '; SCHEDULE_TYPE=' || p_SCHEDULE_TYPE || '; STATEMENT_TYPE=' || p_STATEMENT_TYPE ||
			'; CHARGE_ID=' || p_CHARGE_ID || '; COMPONENT=' || p_COMPONENT.COMPONENT_NAME || '(' || p_COMPONENT.COMPONENT_ID || ')' ||
			'; BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE,'MM/DD/YYYY') || '; END_DATE=' || TO_CHAR(p_END_DATE,'MM/DD/YYYY') ||
			'; AS_OF_DATE=' || TO_CHAR(p_AS_OF_DATE,'MM/DD/YYYY HH24:MI')||')');
	END IF;

	IF UPPER(SUBSTR(p_COMPONENT.RATE_INTERVAL,1,2)) IN ('DA','WE','MO','YE') THEN
	    v_BEGIN_DATE := p_BEGIN_DATE;
		v_END_DATE := p_END_DATE + 1;
	ELSE
	    UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
        v_BEGIN_DATE := TO_CUT(GET_FIRST_INTERVAL(p_BEGIN_DATE,p_COMPONENT.RATE_INTERVAL),p_TIME_ZONE);
	END IF;
	GET_UNITS_FACTOR(p_COMPONENT.RATE_INTERVAL, v_UNITS_FACTOR);

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('PSE_LMP_COMMODITY');
		LOGS.LOG_DEBUG('CONTRACT_ID=' || TO_CHAR(p_CONTRACT_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_END_DATE));
	    LOGS.LOG_DEBUG('<id>,<date>,<src id>,<pod id>,<sink id>,<da purch>,<rt purch>,<da sales>,<rt sales>,<da load>,<rt load>,<da gen>,<rt gen>,<quantity>,<rate>,<factor>,<amount>');
	END IF;

	v_PRIOR_CHARGE_ID := GET_PRIOR_CHARGE_ID(p_CHARGE_ID);
	v_LMP_CHARGE.CHARGE_ID := p_CHARGE_ID;
	IF NVL(p_COMPONENT.LMP_BASE_COMMODITY_ID,0) <> 0 THEN
		v_COMMODITY_ID1 := p_COMPONENT.LMP_BASE_COMMODITY_ID;
		v_COMMODITY_ID2 := p_COMPONENT.LMP_COMMODITY_ID;
	ELSE
		v_COMMODITY_ID1 := p_COMPONENT.LMP_COMMODITY_ID;
		v_COMMODITY_ID2 := 0;
	END IF;

	FOR v_POINT IN c_POINTS LOOP
   		v_LMP_CHARGE.SOURCE_ID := g_NOT_ASSIGNED;
        v_LMP_CHARGE.DELIVERY_POINT_ID := v_POINT.POD_ID;
        v_LMP_CHARGE.SINK_ID := g_NOT_ASSIGNED;

        v_DATE := v_BEGIN_DATE; --GET_FIRST_INTERVAL(v_BEGIN_DATE,p_COMPONENT.RATE_INTERVAL);
        WHILE v_DATE <= v_END_DATE LOOP
        	v_LMP_CHARGE.CHARGE_DATE := v_DATE;
			v_SERVICE_DATE := TRUNC(p_BEGIN_DATE+(v_DATE-v_BEGIN_DATE));
        	v_PUT_ROW := FALSE;

			-- commodity ID2 == 0 means that the DA amounts are *the* amounts,
			-- so we're interested in those transaction IDs - so don't pass NULL
			-- as the ID table
            IF v_COMMODITY_ID2 = 0 THEN v_TRANSACTIONS := ID_TABLE(); END IF;
        	v_LMP_CHARGE.DA_LOAD := GET_LMP_QUANTITY(v_SERVICE_DATE,
            							v_DATE,p_SCHEDULE_TYPE,p_AS_OF_DATE,p_CONTRACT_ID,
                                        p_COMPONENT.RATE_INTERVAL,'LO','GE',0,v_COMMODITY_ID1,
                                        g_NOT_ASSIGNED,v_POINT.POD_ID,g_NOT_ASSIGNED,
										p_COMPONENT.USE_ZONAL_PRICE,
                                        p_COMPONENT.QUANTITY_UNIT,v_UNITS_FACTOR,
										v_TRANSACTIONS);
            IF NVL(v_LMP_CHARGE.DA_LOAD,0) <> 0 THEN v_PUT_ROW := TRUE; END IF;

        	v_LMP_CHARGE.DA_GENERATION := GET_LMP_QUANTITY(v_SERVICE_DATE,
            							v_DATE,p_SCHEDULE_TYPE,p_AS_OF_DATE,p_CONTRACT_ID,
                                        p_COMPONENT.RATE_INTERVAL,'GE','LO',0,v_COMMODITY_ID1,
                                        g_NOT_ASSIGNED,v_POINT.POD_ID,g_NOT_ASSIGNED,
										p_COMPONENT.USE_ZONAL_PRICE,
                                        p_COMPONENT.QUANTITY_UNIT,v_UNITS_FACTOR,
										v_TRANSACTIONS);
            IF NVL(v_LMP_CHARGE.DA_GENERATION,0) <> 0 THEN v_PUT_ROW := TRUE; END IF;

        	v_LMP_CHARGE.DA_PURCHASES := GET_LMP_QUANTITY(v_SERVICE_DATE,
            							v_DATE,p_SCHEDULE_TYPE,p_AS_OF_DATE,p_CONTRACT_ID,
                                        p_COMPONENT.RATE_INTERVAL,'PU','SA',0,v_COMMODITY_ID1,
                                        g_NOT_ASSIGNED,v_POINT.POD_ID,g_NOT_ASSIGNED,
										p_COMPONENT.USE_ZONAL_PRICE,
                                        p_COMPONENT.QUANTITY_UNIT,v_UNITS_FACTOR,
										v_TRANSACTIONS);
            IF NVL(v_LMP_CHARGE.DA_PURCHASES,0) <> 0 THEN v_PUT_ROW := TRUE; END IF;

        	v_LMP_CHARGE.DA_SALES := GET_LMP_QUANTITY(v_SERVICE_DATE,
            							v_DATE,p_SCHEDULE_TYPE,p_AS_OF_DATE,p_CONTRACT_ID,
                                        p_COMPONENT.RATE_INTERVAL,'SA','PU',0,v_COMMODITY_ID1,
                                        g_NOT_ASSIGNED,v_POINT.POD_ID,g_NOT_ASSIGNED,
										p_COMPONENT.USE_ZONAL_PRICE,
                                        p_COMPONENT.QUANTITY_UNIT,v_UNITS_FACTOR,
										v_TRANSACTIONS);
            IF NVL(v_LMP_CHARGE.DA_SALES,0) <> 0 THEN v_PUT_ROW := TRUE; END IF;

            --now gather real-time quantities
            IF v_COMMODITY_ID2 <> 0 THEN
				v_TRANSACTIONS := ID_TABLE();
            	v_LMP_CHARGE.RT_LOAD := GET_LMP_QUANTITY(v_SERVICE_DATE,
                							v_DATE,p_SCHEDULE_TYPE,p_AS_OF_DATE,p_CONTRACT_ID,
                                            p_COMPONENT.RATE_INTERVAL,'LO','GE',0,v_COMMODITY_ID2,
                                            g_NOT_ASSIGNED,v_POINT.POD_ID,g_NOT_ASSIGNED,
    										p_COMPONENT.USE_ZONAL_PRICE,
                                            p_COMPONENT.QUANTITY_UNIT,v_UNITS_FACTOR,
											v_TRANSACTIONS);
                IF NVL(v_LMP_CHARGE.RT_LOAD,0) <> 0 THEN v_PUT_ROW := TRUE; END IF;

            	v_LMP_CHARGE.RT_GENERATION := GET_LMP_QUANTITY(v_SERVICE_DATE,
                							v_DATE,p_SCHEDULE_TYPE,p_AS_OF_DATE,p_CONTRACT_ID,
                                            p_COMPONENT.RATE_INTERVAL,'GE','LO',0,v_COMMODITY_ID2,
                                            g_NOT_ASSIGNED,v_POINT.POD_ID,g_NOT_ASSIGNED,
    										p_COMPONENT.USE_ZONAL_PRICE,
                                            p_COMPONENT.QUANTITY_UNIT,v_UNITS_FACTOR,
											v_TRANSACTIONS);
                IF NVL(v_LMP_CHARGE.RT_GENERATION,0) <> 0 THEN v_PUT_ROW := TRUE; END IF;

            	v_LMP_CHARGE.RT_PURCHASES := GET_LMP_QUANTITY(v_SERVICE_DATE,
                							v_DATE,p_SCHEDULE_TYPE,p_AS_OF_DATE,p_CONTRACT_ID,
                                            p_COMPONENT.RATE_INTERVAL,'PU','SA',0,v_COMMODITY_ID2,
                                            g_NOT_ASSIGNED,v_POINT.POD_ID,g_NOT_ASSIGNED,
    										p_COMPONENT.USE_ZONAL_PRICE,
                                            p_COMPONENT.QUANTITY_UNIT,v_UNITS_FACTOR,
											v_TRANSACTIONS);
                IF NVL(v_LMP_CHARGE.RT_PURCHASES,0) <> 0 THEN v_PUT_ROW := TRUE; END IF;

            	v_LMP_CHARGE.RT_SALES := GET_LMP_QUANTITY(v_SERVICE_DATE,
                							v_DATE,p_SCHEDULE_TYPE,p_AS_OF_DATE,p_CONTRACT_ID,
                                            p_COMPONENT.RATE_INTERVAL,'SA','PU',0,v_COMMODITY_ID2,
                                            g_NOT_ASSIGNED,v_POINT.POD_ID,g_NOT_ASSIGNED,
    										p_COMPONENT.USE_ZONAL_PRICE,
                                            p_COMPONENT.QUANTITY_UNIT,v_UNITS_FACTOR,
											v_TRANSACTIONS);
                IF NVL(v_LMP_CHARGE.RT_SALES,0) <> 0 THEN v_PUT_ROW := TRUE; END IF;
            END IF;

            IF v_PUT_ROW THEN -- only put row if all non-null data
	            -- compute the total quantity
            	IF v_COMMODITY_ID2 = 0 THEN
                	v_LMP_CHARGE.CHARGE_QUANTITY := NVL(v_LMP_CHARGE.DA_LOAD,0)-NVL(v_LMP_CHARGE.DA_GENERATION,0)+
                    							v_BL_SCALE*NVL(v_LMP_CHARGE.DA_SALES,0)-v_BL_SCALE*NVL(v_LMP_CHARGE.DA_PURCHASES,0);
                ELSE
                	v_LMP_CHARGE.CHARGE_QUANTITY := (NVL(v_LMP_CHARGE.RT_LOAD,0)-NVL(v_LMP_CHARGE.DA_LOAD,0))-
    	                						(NVL(v_LMP_CHARGE.RT_GENERATION,0)-NVL(v_LMP_CHARGE.DA_GENERATION,0))+
                    							v_BL_SCALE*(NVL(v_LMP_CHARGE.RT_SALES,0)-NVL(v_LMP_CHARGE.DA_SALES,0))-
                                                v_BL_SCALE*(NVL(v_LMP_CHARGE.RT_PURCHASES,0)-NVL(v_LMP_CHARGE.DA_PURCHASES,0));
                END IF;

                -- Compute the charge rate:
                v_LMP_PRICE := NVL(GET_LMP_PRICE(v_POINT.MARKET_PRICE_ID, v_DATE, p_AS_OF_DATE),0);
                IF UPPER(NVL(p_COMPONENT.ALTERNATE_PRICE,'None')) IN ('?','NONE') THEN
	                v_LMP_CHARGE.CHARGE_RATE := v_LMP_PRICE;
                ELSE
                    v_LMP_CHARGE.PRICE1 := v_LMP_PRICE;
                    v_LMP_CHARGE.PRICE2 := NVL(GET_ALTERNATE_PRICE(v_TRANSACTIONs, p_SCHEDULE_TYPE, v_DATE, p_AS_OF_DATE, p_COMPONENT.ALTERNATE_PRICE),0);
                    CASE UPPER(p_COMPONENT.ALTERNATE_PRICE_FUNCTION)
                    WHEN 'ALWAYS ALT' THEN
	                    v_LMP_CHARGE.CHARGE_RATE := v_LMP_CHARGE.PRICE2;
                    WHEN 'MIN' THEN
	                    v_LMP_CHARGE.CHARGE_RATE := LEAST(v_LMP_CHARGE.PRICE1,v_LMP_CHARGE.PRICE2);
                    WHEN 'MAX' THEN
    	                v_LMP_CHARGE.CHARGE_RATE := GREATEST(v_LMP_CHARGE.PRICE1,v_LMP_CHARGE.PRICE2);
                    WHEN 'AVERAGE' THEN
        	            v_LMP_CHARGE.CHARGE_RATE := (v_LMP_CHARGE.PRICE1+v_LMP_CHARGE.PRICE2)/2.0;
                    WHEN 'DIFFERENCE' THEN
            	        v_LMP_CHARGE.CHARGE_RATE := ABS(v_LMP_CHARGE.PRICE1-v_LMP_CHARGE.PRICE2);
                    WHEN '+DIFFERENCE' THEN
            	        v_LMP_CHARGE.CHARGE_RATE := v_LMP_CHARGE.PRICE1-v_LMP_CHARGE.PRICE2;
                    WHEN '-DIFFERENCE' THEN
            	        v_LMP_CHARGE.CHARGE_RATE := v_LMP_CHARGE.PRICE2-v_LMP_CHARGE.PRICE1;
                    ELSE
                        -- no function? just use the LMP rate
                        v_LMP_CHARGE.CHARGE_RATE := v_LMP_CHARGE.PRICE1;
                    END CASE;
                END IF;

	            -- wrap up this entry
    			v_LMP_CHARGE.CHARGE_FACTOR := GET_COMPONENT_FACTOR(p_COMPONENT.COMPONENT_ID, v_DATE);
                v_LMP_CHARGE.CHARGE_AMOUNT := v_LMP_CHARGE.CHARGE_RATE*v_LMP_CHARGE.CHARGE_FACTOR*v_LMP_CHARGE.CHARGE_QUANTITY;
                PRIOR_LMP_CHARGE(v_PRIOR_CHARGE_ID, v_LMP_CHARGE);
                PUT_LMP_CHARGE(v_LMP_CHARGE);
			END IF;
			v_DATE := GET_NEXT_INTERVAL(v_DATE,p_COMPONENT.RATE_INTERVAL);
		END LOOP;
    END LOOP;

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('LMP Commodity Charge - Completed Successfully');
	END IF;

END PSE_LMP_COMMODITY_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_LMP_ENERGY_CHARGE
	(
    p_IS_IMPORTS_EXPORTS IN NUMBER,
    p_IS_VIRTUAL IN NUMBER,
	p_CONTRACT_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_CHARGE_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_DATE DATE;
v_SERVICE_DATE DATE;
v_LMP_CHARGE LMP_CHARGE%ROWTYPE;
v_PRIOR_CHARGE_ID NUMBER;
v_UNITS_FACTOR NUMBER := 1;
v_PUT_ROW BOOLEAN;
v_BL_SCALE NUMBER := NVL(p_COMPONENT.BILATERALS_SIGN,1);
v_NET_INTERCHANGES HASH_OF_NUMBERS;
v_WEIGHT_AVG_PRICES HASH_OF_NUMBERS;
v_NET_INTERCHANGE NUMBER := 0;
v_WEIGHT_AVG_PRICE NUMBER := 0;
v_LMP_PRICE NUMBER := 0;
v_NEED_NET_INTERCHANGE BOOLEAN;
v_NEED_WEIGHT_AVG_PRICE BOOLEAN;
v_COMPUTE_NET_INTERCHANGE BOOLEAN;
v_HAVE_NET_INTERCHANGE BOOLEAN;
v_HASH_KEY VARCHAR2(32);
v_NET_DA_LOAD NUMBER; v_NET_DA_GENERATION NUMBER;
v_NET_RT_LOAD NUMBER; v_NET_RT_GENERATION NUMBER;
v_NET_DA_PURCHASES NUMBER; v_NET_DA_SALES NUMBER;
v_NET_RT_PURCHASES NUMBER; v_NET_RT_SALES NUMBER;

-- this query just returns ID of zero if the price is just a weighted average
-- because we don't need service point LMPs in details
CURSOR c_POINTS IS
	-- virtuals? then use points for virtual commodity transactions
	SELECT DISTINCT A.POD_ID, B.MARKET_PRICE_ID
    FROM INTERCHANGE_TRANSACTION A,
    	MARKET_PRICE B,
		IT_COMMODITY C
	WHERE p_IS_VIRTUAL = 1
		AND UPPER(p_COMPONENT.LMP_PRICE_CALC) <> UPPER(g_LMP_WEIGHT_AVG_PRICE)
		AND A.BEGIN_DATE <= TRUNC(p_END_DATE)
		AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
		AND A.CONTRACT_ID = p_CONTRACT_ID
		AND UPPER(A.TRANSACTION_INTERVAL) =  UPPER(p_COMPONENT.RATE_INTERVAL)
        AND A.POD_ID = DECODE(p_COMPONENT.SERVICE_POINT_ID,g_NOT_ASSIGNED,A.POD_ID,p_COMPONENT.SERVICE_POINT_ID)
		AND C.COMMODITY_ID = A.COMMODITY_ID
		AND NVL(C.IS_VIRTUAL,0) = 1
        AND B.MARKET_PRICE_TYPE = p_COMPONENT.MARKET_PRICE_TYPE
        AND B.MARKET_TYPE = p_COMPONENT.MARKET_TYPE
    	AND B.POD_ID = A.POD_ID
        AND B.MARKET_PRICE_INTERVAL = A.TRANSACTION_INTERVAL
	UNION ALL
	-- asset related? then use Generation/Load points
	SELECT DISTINCT A.POD_ID, B.MARKET_PRICE_ID
    FROM INTERCHANGE_TRANSACTION A,
    	MARKET_PRICE B,
		IT_COMMODITY C
	WHERE p_IS_IMPORTS_EXPORTS <> 1
		AND p_IS_VIRTUAL <> 1
		AND UPPER(p_COMPONENT.LMP_PRICE_CALC) <> UPPER(g_LMP_WEIGHT_AVG_PRICE)
		AND A.BEGIN_DATE <= TRUNC(p_END_DATE)
		AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
		AND A.CONTRACT_ID = p_CONTRACT_ID
		AND UPPER(A.TRANSACTION_INTERVAL) =  UPPER(p_COMPONENT.RATE_INTERVAL)
	  	AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) IN ('GE','LO')
        AND A.POD_ID = DECODE(p_COMPONENT.SERVICE_POINT_ID,g_NOT_ASSIGNED,A.POD_ID,p_COMPONENT.SERVICE_POINT_ID)
		AND C.COMMODITY_ID = A.COMMODITY_ID
		AND NVL(C.IS_VIRTUAL,0) <> 1
        AND B.MARKET_PRICE_TYPE = p_COMPONENT.MARKET_PRICE_TYPE
        AND B.MARKET_TYPE = p_COMPONENT.MARKET_TYPE
    	AND B.POD_ID = A.POD_ID
        AND B.MARKET_PRICE_INTERVAL = A.TRANSACTION_INTERVAL
	UNION ALL
	-- non-asset related? then use all except Generation/Load points
	SELECT A.POD_ID, B.MARKET_PRICE_ID
    FROM (SELECT DISTINCT CASE UPPER(SUBSTR(TRANSACTION_TYPE,1,2))
							WHEN 'PU' THEN
								NVL(SINK_ID,POD_ID)
							ELSE
								NVL(SOURCE_ID,POR_ID)
							END "POD_ID",
							TRANSACTION_INTERVAL
			FROM INTERCHANGE_TRANSACTION A, IT_COMMODITY C
        	WHERE p_IS_IMPORTS_EXPORTS = 1
				AND p_IS_VIRTUAL <> 1
        		AND UPPER(p_COMPONENT.LMP_PRICE_CALC) <> UPPER(g_LMP_WEIGHT_AVG_PRICE)
        		AND A.BEGIN_DATE <= TRUNC(p_END_DATE)
        		AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
        		AND A.CONTRACT_ID = p_CONTRACT_ID
        		AND UPPER(A.TRANSACTION_INTERVAL) =  UPPER(p_COMPONENT.RATE_INTERVAL)
			  	AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) IN ('PU','SA')
        		AND C.COMMODITY_ID = A.COMMODITY_ID
        		AND NVL(IS_VIRTUAL,0) <> 1
			) A,
    	MARKET_PRICE B,
		IT_COMMODITY C
	WHERE A.POD_ID NOT IN (SELECT POD_ID
						    FROM INTERCHANGE_TRANSACTION A, IT_COMMODITY C
                        	WHERE A.BEGIN_DATE <= TRUNC(p_END_DATE)
                        		AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
                        		AND A.CONTRACT_ID = p_CONTRACT_ID
                        		AND UPPER(A.TRANSACTION_INTERVAL) =  UPPER(p_COMPONENT.RATE_INTERVAL)
                        	  	AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) IN ('GE','LO')
                        		AND C.COMMODITY_ID = A.COMMODITY_ID
                        		AND NVL(IS_VIRTUAL,0) <> 1 )
        AND A.POD_ID = DECODE(p_COMPONENT.SERVICE_POINT_ID,g_NOT_ASSIGNED,A.POD_ID,p_COMPONENT.SERVICE_POINT_ID)
        AND B.MARKET_PRICE_TYPE = p_COMPONENT.MARKET_PRICE_TYPE
        AND B.MARKET_TYPE = p_COMPONENT.MARKET_TYPE
    	AND B.POD_ID = A.POD_ID
        AND B.MARKET_PRICE_INTERVAL = A.TRANSACTION_INTERVAL
	UNION ALL
	-- weighted-average price? just come back w/ zero IDs
	SELECT 0 "POD_ID", 0 "MARKET_PRICE_ID"
	FROM DUAL
	WHERE UPPER(p_COMPONENT.LMP_PRICE_CALC) = UPPER(g_LMP_WEIGHT_AVG_PRICE);

BEGIN

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('LMP Energy Charge (CONTRACT_ID=' || p_CONTRACT_ID || '; SCHEDULE_TYPE=' || p_SCHEDULE_TYPE || '; STATEMENT_TYPE=' || p_STATEMENT_TYPE ||
			'; CHARGE_ID=' || p_CHARGE_ID || '; COMPONENT=' || p_COMPONENT.COMPONENT_NAME || '(' || p_COMPONENT.COMPONENT_ID || ')' ||
			'; BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE,'MM/DD/YYYY') || '; END_DATE=' || TO_CHAR(p_END_DATE,'MM/DD/YYYY') ||
			'; AS_OF_DATE=' || TO_CHAR(p_AS_OF_DATE,'MM/DD/YYYY HH24:MI')||')');
	END IF;

	IF UPPER(SUBSTR(p_COMPONENT.RATE_INTERVAL,1,2)) IN ('DA','WE','MO','YE') THEN
	    v_BEGIN_DATE := p_BEGIN_DATE;
		v_END_DATE := p_END_DATE + 1;
	ELSE
	    UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
        v_BEGIN_DATE := TO_CUT(GET_FIRST_INTERVAL(p_BEGIN_DATE,p_COMPONENT.RATE_INTERVAL),p_TIME_ZONE);
	END IF;
	GET_UNITS_FACTOR(p_COMPONENT.RATE_INTERVAL, v_UNITS_FACTOR);

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('PSE_LMP_ENERGY');
		LOGS.LOG_DEBUG('CONTRACT_ID=' || TO_CHAR(p_CONTRACT_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_END_DATE));
	    LOGS.LOG_DEBUG('<id>,<date>,<src id>,<pod id>,<sink id>,<da purch>,<rt purch>,<da sales>,<rt sales>,<da load>,<rt load>,<da gen>,<rt gen>,<quantity>,<rate>,<factor>,<amount>');
	END IF;

	v_PRIOR_CHARGE_ID := GET_PRIOR_CHARGE_ID(p_CHARGE_ID);
	v_LMP_CHARGE.CHARGE_ID := p_CHARGE_ID;

	v_NEED_WEIGHT_AVG_PRICE := UPPER(p_COMPONENT.LMP_PRICE_CALC) = UPPER(g_LMP_WEIGHT_AVG_PRICE) OR UPPER(p_COMPONENT.LMP_PRICE_CALC) = UPPER(g_LMP_ACT_MINUS_AVG_PRICE);
	v_NEED_NET_INTERCHANGE := v_NEED_WEIGHT_AVG_PRICE OR UPPER(p_COMPONENT.CHARGE_WHEN) = UPPER(g_LMP_CHARGE_GENERATION) OR UPPER(p_COMPONENT.CHARGE_WHEN) = UPPER(g_LMP_CHARGE_LOAD);
	v_COMPUTE_NET_INTERCHANGE := v_NEED_NET_INTERCHANGE AND UPPER(p_COMPONENT.LMP_PRICE_CALC) <> UPPER(g_LMP_WEIGHT_AVG_PRICE);

		FOR v_POINT IN c_POINTS LOOP
		v_LMP_CHARGE.SOURCE_ID         := g_NOT_ASSIGNED;
		v_LMP_CHARGE.DELIVERY_POINT_ID := v_POINT.POD_ID;
		v_LMP_CHARGE.SINK_ID           := g_NOT_ASSIGNED;

		v_DATE := v_BEGIN_DATE; --GET_FIRST_INTERVAL(v_BEGIN_DATE,p_COMPONENT.RATE_INTERVAL);
		WHILE v_DATE <= v_END_DATE LOOP
			v_LMP_CHARGE.CHARGE_DATE := v_DATE;
			v_SERVICE_DATE           := TRUNC(p_BEGIN_DATE + (v_DATE - v_BEGIN_DATE));
			v_PUT_ROW                := FALSE;

			-- do we need net interchange for this component?
			IF v_NEED_NET_INTERCHANGE THEN
				-- if so, see if we already have it cached
				v_HASH_KEY             := TO_CHAR(v_DATE, 'YYYY/MM/DD HH24:MI:SS');
				v_HAVE_NET_INTERCHANGE := v_NET_INTERCHANGES.EXISTS(v_HASH_KEY);
				IF v_HAVE_NET_INTERCHANGE THEN
					v_NET_INTERCHANGE := v_NET_INTERCHANGES(v_HASH_KEY);
				END IF;
			ELSE
				v_HAVE_NET_INTERCHANGE := FALSE;
			END IF;

			-- gather day-ahead quantities
			IF p_IS_IMPORTS_EXPORTS = 1 THEN
				v_LMP_CHARGE.DA_LOAD := GET_LMP_QUANTITY(v_SERVICE_DATE, v_DATE, p_SCHEDULE_TYPE,
																								 p_AS_OF_DATE, p_CONTRACT_ID,
																								 p_COMPONENT.RATE_INTERVAL, 'PU', 1, p_IS_VIRTUAL,
																								 g_DAY_AHEAD, v_POINT.POD_ID,
																								 p_COMPONENT.QUANTITY_UNIT, v_UNITS_FACTOR);
				IF NVL(v_LMP_CHARGE.DA_LOAD, 0) <> 0 THEN
					v_PUT_ROW := TRUE;
				END IF;

				v_LMP_CHARGE.DA_GENERATION := GET_LMP_QUANTITY(v_SERVICE_DATE, v_DATE, p_SCHEDULE_TYPE,
																											 p_AS_OF_DATE, p_CONTRACT_ID,
																											 p_COMPONENT.RATE_INTERVAL, 'SA', 1,
																											 p_IS_VIRTUAL, g_DAY_AHEAD, v_POINT.POD_ID,
																											 p_COMPONENT.QUANTITY_UNIT, v_UNITS_FACTOR);
				IF NVL(v_LMP_CHARGE.DA_GENERATION, 0) <> 0 THEN
					v_PUT_ROW := TRUE;
				END IF;

				IF v_COMPUTE_NET_INTERCHANGE AND NOT v_HAVE_NET_INTERCHANGE THEN
					v_NET_DA_LOAD       := GET_LMP_QUANTITY(v_SERVICE_DATE, v_DATE, p_SCHEDULE_TYPE,
																									p_AS_OF_DATE, p_CONTRACT_ID,
																									p_COMPONENT.RATE_INTERVAL, 'PU', 1, p_IS_VIRTUAL,
																									g_DAY_AHEAD, g_NOT_ASSIGNED,
																									p_COMPONENT.QUANTITY_UNIT, v_UNITS_FACTOR);
					v_NET_DA_GENERATION := GET_LMP_QUANTITY(v_SERVICE_DATE, v_DATE, p_SCHEDULE_TYPE,
																									p_AS_OF_DATE, p_CONTRACT_ID,
																									p_COMPONENT.RATE_INTERVAL, 'SA', 1, p_IS_VIRTUAL,
																									g_DAY_AHEAD, g_NOT_ASSIGNED,
																									p_COMPONENT.QUANTITY_UNIT, v_UNITS_FACTOR);
				END IF;
			ELSE
				v_LMP_CHARGE.DA_LOAD := GET_LMP_QUANTITY(v_SERVICE_DATE, v_DATE, p_SCHEDULE_TYPE,
																								 p_AS_OF_DATE, p_CONTRACT_ID,
																								 p_COMPONENT.RATE_INTERVAL, 'LO', 0, p_IS_VIRTUAL,
																								 g_DAY_AHEAD, v_POINT.POD_ID,
																								 p_COMPONENT.QUANTITY_UNIT, v_UNITS_FACTOR);
				IF NVL(v_LMP_CHARGE.DA_LOAD, 0) <> 0 THEN
					v_PUT_ROW := TRUE;
				END IF;

				v_LMP_CHARGE.DA_GENERATION := GET_LMP_QUANTITY(v_SERVICE_DATE, v_DATE, p_SCHEDULE_TYPE,
																											 p_AS_OF_DATE, p_CONTRACT_ID,
																											 p_COMPONENT.RATE_INTERVAL, 'GE', 0,
																											 p_IS_VIRTUAL, g_DAY_AHEAD, v_POINT.POD_ID,
																											 p_COMPONENT.QUANTITY_UNIT, v_UNITS_FACTOR);
				IF NVL(v_LMP_CHARGE.DA_GENERATION, 0) <> 0 THEN
					v_PUT_ROW := TRUE;
				END IF;

				IF v_COMPUTE_NET_INTERCHANGE AND NOT v_HAVE_NET_INTERCHANGE THEN
					v_NET_DA_LOAD       := GET_LMP_QUANTITY(v_SERVICE_DATE, v_DATE, p_SCHEDULE_TYPE,
																									p_AS_OF_DATE, p_CONTRACT_ID,
																									p_COMPONENT.RATE_INTERVAL, 'LO', 0, p_IS_VIRTUAL,
																									g_DAY_AHEAD, g_NOT_ASSIGNED,
																									p_COMPONENT.QUANTITY_UNIT, v_UNITS_FACTOR);
					v_NET_DA_GENERATION := GET_LMP_QUANTITY(v_SERVICE_DATE, v_DATE, p_SCHEDULE_TYPE,
																									p_AS_OF_DATE, p_CONTRACT_ID,
																									p_COMPONENT.RATE_INTERVAL, 'GE', 0, p_IS_VIRTUAL,
																									g_DAY_AHEAD, g_NOT_ASSIGNED,
																									p_COMPONENT.QUANTITY_UNIT, v_UNITS_FACTOR);
				END IF;
			END IF;

      -- this is a hack for MISO RT_ASSET_EN, RT_NASSET_EN, RT_FIN_CG, and
      -- RT_FIN_LS, none of which consider realtime fin bilaterals in the calculation
      -- This must be fixed before PJM shadowing will work!!!
			IF p_COMPONENT.MARKET_TYPE = g_DAY_AHEAD THEN
        v_LMP_CHARGE.DA_PURCHASES := GET_LMP_QUANTITY(v_SERVICE_DATE, v_DATE, p_SCHEDULE_TYPE,
  																										p_AS_OF_DATE, p_CONTRACT_ID,
  																										p_COMPONENT.RATE_INTERVAL, 'PU', 0, p_IS_VIRTUAL,
  																										g_DAY_AHEAD, v_POINT.POD_ID,
  																										p_COMPONENT.QUANTITY_UNIT, v_UNITS_FACTOR);
  			IF NVL(v_LMP_CHARGE.DA_PURCHASES, 0) <> 0 THEN
  				v_PUT_ROW := TRUE;
  			END IF;

  			v_LMP_CHARGE.DA_SALES := GET_LMP_QUANTITY(v_SERVICE_DATE, v_DATE, p_SCHEDULE_TYPE,
  																								p_AS_OF_DATE, p_CONTRACT_ID,
  																								p_COMPONENT.RATE_INTERVAL, 'SA', 0, p_IS_VIRTUAL,
  																								g_DAY_AHEAD, v_POINT.POD_ID,
  																								p_COMPONENT.QUANTITY_UNIT, v_UNITS_FACTOR);
  			IF NVL(v_LMP_CHARGE.DA_SALES, 0) <> 0 THEN
  				v_PUT_ROW := TRUE;
  			END IF;

  			IF v_COMPUTE_NET_INTERCHANGE AND NOT v_HAVE_NET_INTERCHANGE THEN
  				v_NET_DA_PURCHASES := GET_LMP_QUANTITY(v_SERVICE_DATE, v_DATE, p_SCHEDULE_TYPE, p_AS_OF_DATE,
  																							 p_CONTRACT_ID, p_COMPONENT.RATE_INTERVAL, 'PU', 0,
  																							 p_IS_VIRTUAL, g_DAY_AHEAD, g_NOT_ASSIGNED,
  																							 p_COMPONENT.QUANTITY_UNIT, v_UNITS_FACTOR);
  				v_NET_DA_SALES     := GET_LMP_QUANTITY(v_SERVICE_DATE, v_DATE, p_SCHEDULE_TYPE, p_AS_OF_DATE,
  																							 p_CONTRACT_ID, p_COMPONENT.RATE_INTERVAL, 'SA', 0,
  																							 p_IS_VIRTUAL, g_DAY_AHEAD, g_NOT_ASSIGNED,
  																							 p_COMPONENT.QUANTITY_UNIT, v_UNITS_FACTOR);
  			END IF;
      END IF;

			--now gather real-time quantities
			IF p_COMPONENT.MARKET_TYPE <> g_DAY_AHEAD THEN
				IF p_IS_IMPORTS_EXPORTS = 1 THEN
					v_LMP_CHARGE.RT_LOAD := GET_LMP_QUANTITY(v_SERVICE_DATE, v_DATE, p_SCHEDULE_TYPE,
																									 p_AS_OF_DATE, p_CONTRACT_ID,
																									 p_COMPONENT.RATE_INTERVAL, 'PU', 1, p_IS_VIRTUAL,
																									 p_COMPONENT.MARKET_TYPE, v_POINT.POD_ID,
																									 p_COMPONENT.QUANTITY_UNIT, v_UNITS_FACTOR);
					IF NVL(v_LMP_CHARGE.RT_LOAD, 0) <> 0 THEN
						v_PUT_ROW := TRUE;
					END IF;

					v_LMP_CHARGE.RT_GENERATION := GET_LMP_QUANTITY(v_SERVICE_DATE, v_DATE, p_SCHEDULE_TYPE,
																												 p_AS_OF_DATE, p_CONTRACT_ID,
																												 p_COMPONENT.RATE_INTERVAL, 'SA', 1,
																												 p_IS_VIRTUAL, p_COMPONENT.MARKET_TYPE,
																												 v_POINT.POD_ID, p_COMPONENT.QUANTITY_UNIT,
																												 v_UNITS_FACTOR);
					IF NVL(v_LMP_CHARGE.RT_GENERATION, 0) <> 0 THEN
						v_PUT_ROW := TRUE;
					END IF;

					IF v_COMPUTE_NET_INTERCHANGE AND NOT v_HAVE_NET_INTERCHANGE THEN
						v_NET_RT_LOAD       := GET_LMP_QUANTITY(v_SERVICE_DATE, v_DATE, p_SCHEDULE_TYPE,
																										p_AS_OF_DATE, p_CONTRACT_ID,
																										p_COMPONENT.RATE_INTERVAL, 'PU', 1, p_IS_VIRTUAL,
																										p_COMPONENT.MARKET_TYPE, g_NOT_ASSIGNED,
																										p_COMPONENT.QUANTITY_UNIT, v_UNITS_FACTOR);
						v_NET_RT_GENERATION := GET_LMP_QUANTITY(v_SERVICE_DATE, v_DATE, p_SCHEDULE_TYPE,
																										p_AS_OF_DATE, p_CONTRACT_ID,
																										p_COMPONENT.RATE_INTERVAL, 'SA', 1, p_IS_VIRTUAL,
																										p_COMPONENT.MARKET_TYPE, g_NOT_ASSIGNED,
																										p_COMPONENT.QUANTITY_UNIT, v_UNITS_FACTOR);
					END IF;
				ELSE
					v_LMP_CHARGE.RT_LOAD := GET_LMP_QUANTITY(v_SERVICE_DATE, v_DATE, p_SCHEDULE_TYPE,
																									 p_AS_OF_DATE, p_CONTRACT_ID,
																									 p_COMPONENT.RATE_INTERVAL, 'LO', 0, p_IS_VIRTUAL,
																									 p_COMPONENT.MARKET_TYPE, v_POINT.POD_ID,
																									 p_COMPONENT.QUANTITY_UNIT, v_UNITS_FACTOR);
					IF NVL(v_LMP_CHARGE.RT_LOAD, 0) <> 0 THEN
						v_PUT_ROW := TRUE;
					END IF;

					v_LMP_CHARGE.RT_GENERATION := GET_LMP_QUANTITY(v_SERVICE_DATE, v_DATE, p_SCHEDULE_TYPE,
																												 p_AS_OF_DATE, p_CONTRACT_ID,
																												 p_COMPONENT.RATE_INTERVAL, 'GE', 0,
																												 p_IS_VIRTUAL, p_COMPONENT.MARKET_TYPE,
																												 v_POINT.POD_ID, p_COMPONENT.QUANTITY_UNIT,
																												 v_UNITS_FACTOR);
					IF NVL(v_LMP_CHARGE.RT_GENERATION, 0) <> 0 THEN
						v_PUT_ROW := TRUE;
					END IF;

					IF v_COMPUTE_NET_INTERCHANGE AND NOT v_HAVE_NET_INTERCHANGE THEN
						v_NET_RT_LOAD       := GET_LMP_QUANTITY(v_SERVICE_DATE, v_DATE, p_SCHEDULE_TYPE,
																										p_AS_OF_DATE, p_CONTRACT_ID,
																										p_COMPONENT.RATE_INTERVAL, 'LO', 0, p_IS_VIRTUAL,
																										p_COMPONENT.MARKET_TYPE, g_NOT_ASSIGNED,
																										p_COMPONENT.QUANTITY_UNIT, v_UNITS_FACTOR);
						v_NET_RT_GENERATION := GET_LMP_QUANTITY(v_SERVICE_DATE, v_DATE, p_SCHEDULE_TYPE,
																										p_AS_OF_DATE, p_CONTRACT_ID,
																										p_COMPONENT.RATE_INTERVAL, 'GE', 0, p_IS_VIRTUAL,
																										p_COMPONENT.MARKET_TYPE, g_NOT_ASSIGNED,
																										p_COMPONENT.QUANTITY_UNIT, v_UNITS_FACTOR);
					END IF;
				END IF;

				v_LMP_CHARGE.RT_PURCHASES := GET_LMP_QUANTITY(v_SERVICE_DATE, v_DATE, p_SCHEDULE_TYPE,
																											p_AS_OF_DATE, p_CONTRACT_ID,
																											p_COMPONENT.RATE_INTERVAL, 'PU', 0,
																											p_IS_VIRTUAL, p_COMPONENT.MARKET_TYPE,
																											v_POINT.POD_ID, p_COMPONENT.QUANTITY_UNIT,
																											v_UNITS_FACTOR);
				IF NVL(v_LMP_CHARGE.RT_PURCHASES, 0) <> 0 THEN
					v_PUT_ROW := TRUE;
				END IF;

				v_LMP_CHARGE.RT_SALES := GET_LMP_QUANTITY(v_SERVICE_DATE, v_DATE, p_SCHEDULE_TYPE,
																									p_AS_OF_DATE, p_CONTRACT_ID,
																									p_COMPONENT.RATE_INTERVAL, 'SA', 0, p_IS_VIRTUAL,
																									p_COMPONENT.MARKET_TYPE, v_POINT.POD_ID,
																									p_COMPONENT.QUANTITY_UNIT, v_UNITS_FACTOR);
				IF NVL(v_LMP_CHARGE.RT_SALES, 0) <> 0 THEN
					v_PUT_ROW := TRUE;
				END IF;

				IF v_COMPUTE_NET_INTERCHANGE AND NOT v_HAVE_NET_INTERCHANGE THEN
					v_NET_RT_PURCHASES := GET_LMP_QUANTITY(v_SERVICE_DATE, v_DATE, p_SCHEDULE_TYPE,
																								 p_AS_OF_DATE, p_CONTRACT_ID,
																								 p_COMPONENT.RATE_INTERVAL, 'PU', 0, p_IS_VIRTUAL,
																								 p_COMPONENT.MARKET_TYPE, g_NOT_ASSIGNED,
																								 p_COMPONENT.QUANTITY_UNIT, v_UNITS_FACTOR);
					v_NET_RT_SALES     := GET_LMP_QUANTITY(v_SERVICE_DATE, v_DATE, p_SCHEDULE_TYPE,
																								 p_AS_OF_DATE, p_CONTRACT_ID,
																								 p_COMPONENT.RATE_INTERVAL, 'SA', 0, p_IS_VIRTUAL,
																								 p_COMPONENT.MARKET_TYPE, g_NOT_ASSIGNED,
																								 p_COMPONENT.QUANTITY_UNIT, v_UNITS_FACTOR);
				END IF;
			END IF;

			IF v_PUT_ROW THEN
				-- only put row if all non-null data
				-- compute the total quantity
				IF p_COMPONENT.MARKET_TYPE = g_DAY_AHEAD THEN
					-- Day-Ahead quantity:
					v_LMP_CHARGE.CHARGE_QUANTITY := NVL(v_LMP_CHARGE.DA_LOAD, 0) -
																					NVL(v_LMP_CHARGE.DA_GENERATION, 0) +
																					v_BL_SCALE * NVL(v_LMP_CHARGE.DA_SALES, 0) -
																					v_BL_SCALE * NVL(v_LMP_CHARGE.DA_PURCHASES, 0);

					IF v_NEED_NET_INTERCHANGE AND NOT v_HAVE_NET_INTERCHANGE THEN
						IF v_COMPUTE_NET_INTERCHANGE THEN
							v_NET_INTERCHANGE := NVL(v_NET_DA_LOAD, 0) - NVL(v_NET_DA_GENERATION, 0) +
																	 v_BL_SCALE * NVL(v_NET_DA_SALES, 0) -
																	 v_BL_SCALE * NVL(v_NET_DA_PURCHASES, 0);
						ELSE
							-- don't have to compute it because its the same as the charge quantity
							v_NET_INTERCHANGE := v_LMP_CHARGE.CHARGE_QUANTITY;
						END IF;
						v_NET_INTERCHANGES(v_HASH_KEY) := v_NET_INTERCHANGE;
					END IF;
				ELSE
					-- Real-Time quantity:
					v_LMP_CHARGE.CHARGE_QUANTITY := (NVL(v_LMP_CHARGE.RT_LOAD, 0) -
																					NVL(v_LMP_CHARGE.DA_LOAD, 0)) -
																					(NVL(v_LMP_CHARGE.RT_GENERATION, 0) -
																					NVL(v_LMP_CHARGE.DA_GENERATION, 0)) +
																					v_BL_SCALE * (NVL(v_LMP_CHARGE.RT_SALES, 0) -
																					NVL(v_LMP_CHARGE.DA_SALES, 0)) -
																					v_BL_SCALE * (NVL(v_LMP_CHARGE.RT_PURCHASES, 0) -
																					NVL(v_LMP_CHARGE.DA_PURCHASES, 0));

					IF v_NEED_NET_INTERCHANGE AND NOT v_HAVE_NET_INTERCHANGE THEN
						IF v_COMPUTE_NET_INTERCHANGE THEN
							v_NET_INTERCHANGE := (NVL(v_NET_RT_LOAD, 0) - NVL(v_NET_DA_LOAD, 0)) -
																	 (NVL(v_NET_RT_GENERATION, 0) - NVL(v_NET_DA_GENERATION, 0)) +
																	 v_BL_SCALE * (NVL(v_NET_RT_SALES, 0) - NVL(v_NET_DA_SALES, 0)) -
																	 v_BL_SCALE *
																	 (NVL(v_NET_RT_PURCHASES, 0) - NVL(v_NET_DA_PURCHASES, 0));
						ELSE
							-- don't have to compute it because its the same as the charge quantity
							v_NET_INTERCHANGE := v_LMP_CHARGE.CHARGE_QUANTITY;
						END IF;
						v_NET_INTERCHANGES(v_HASH_KEY) := v_NET_INTERCHANGE;
					END IF;
				END IF;

				IF v_NEED_NET_INTERCHANGE THEN
					-- depending on CHARGE_WHEN, we may not need to store this row
					IF UPPER(p_COMPONENT.CHARGE_WHEN) = UPPER(g_LMP_CHARGE_LOAD) AND v_NET_INTERCHANGE <= 0 THEN
						v_PUT_ROW := FALSE;
					ELSIF UPPER(p_COMPONENT.CHARGE_WHEN) = UPPER(g_LMP_CHARGE_GENERATION) AND
								v_NET_INTERCHANGE >= 0 THEN
						v_PUT_ROW := FALSE;
					END IF;
				END IF;

				IF v_PUT_ROW THEN
					-- do we still need to put this row?
					-- Compute the charge rate:
					v_LMP_PRICE := NVL(GET_LMP_PRICE(v_POINT.MARKET_PRICE_ID, v_DATE, p_AS_OF_DATE), 0);
					IF v_NEED_WEIGHT_AVG_PRICE THEN
						IF v_WEIGHT_AVG_PRICES.EXISTS(v_HASH_KEY) THEN
							v_WEIGHT_AVG_PRICE := v_WEIGHT_AVG_PRICES(v_HASH_KEY);
						ELSE
							v_WEIGHT_AVG_PRICE := NVL(GET_WEIGHT_AVG_LMP_PRICE(CASE WHEN v_NET_INTERCHANGE > 0 THEN 1 ELSE 0 END,
										v_BL_SCALE,
										p_CONTRACT_ID, p_STATEMENT_TYPE,
										p_COMPONENT.MARKET_TYPE,
										p_COMPONENT.MARKET_PRICE_TYPE,
										v_SERVICE_DATE, v_DATE, p_AS_OF_DATE),
										0);
						END IF;
						IF UPPER(p_COMPONENT.LMP_PRICE_CALC) = UPPER(g_LMP_ACT_MINUS_AVG_PRICE) THEN
							-- rate is Actual (LMP) minus weighted average
							v_LMP_CHARGE.PRICE1      := v_LMP_PRICE;
							v_LMP_CHARGE.PRICE2      := v_WEIGHT_AVG_PRICE;
							v_LMP_CHARGE.CHARGE_RATE := v_LMP_CHARGE.PRICE1 - v_LMP_CHARGE.PRICE2;
						ELSE
							-- otherwise, must be weighted average price
							v_LMP_CHARGE.CHARGE_RATE := v_WEIGHT_AVG_PRICE;
						END IF;
					ELSE
						v_LMP_CHARGE.CHARGE_RATE := v_LMP_PRICE;
					END IF;

					-- wrap up this entry
					v_LMP_CHARGE.CHARGE_FACTOR := GET_COMPONENT_FACTOR(p_COMPONENT.COMPONENT_ID, v_DATE);
					v_LMP_CHARGE.CHARGE_AMOUNT := v_LMP_CHARGE.CHARGE_RATE * v_LMP_CHARGE.CHARGE_FACTOR *
																				v_LMP_CHARGE.CHARGE_QUANTITY;
					PRIOR_LMP_CHARGE(v_PRIOR_CHARGE_ID, v_LMP_CHARGE);
					PUT_LMP_CHARGE(v_LMP_CHARGE);
				END IF;
			END IF;

			v_DATE := GET_NEXT_INTERVAL(v_DATE, p_COMPONENT.RATE_INTERVAL);
		END LOOP;
	END LOOP;


	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('LMP Energy Charge - Completed Successfully');
	END IF;

END PSE_LMP_ENERGY_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_LMP_BILATERAL_CHARGE(p_CONTRACT_ID    IN NUMBER,
																	 p_SCHEDULE_TYPE  IN NUMBER,
																	 p_STATEMENT_TYPE IN NUMBER,
																	 p_CHARGE_ID      IN NUMBER,
																	 p_COMPONENT      IN COMPONENT%ROWTYPE,
																	 p_BEGIN_DATE     IN DATE,
																	 p_END_DATE       IN DATE,
																	 p_AS_OF_DATE     IN DATE,
																	 p_TIME_ZONE	  IN VARCHAR2) AS

	v_BEGIN_DATE      DATE;
	v_END_DATE        DATE;
	v_DATE            DATE;
	v_LMP_CHARGE      LMP_CHARGE%ROWTYPE;
	v_PRIOR_CHARGE_ID NUMBER;
	v_UNITS_FACTOR    NUMBER := 1;
	v_PUT_ROW         BOOLEAN;
	v_INCLUDE_EXT     BOOLEAN;
	v_INCLUDE_INT     BOOLEAN;
	v_EXT_AMT         NUMBER;

	CURSOR c_PURCHASE_POINTS IS
		SELECT DISTINCT g_NOT_ASSIGNED    "SOURCE_ID",
										A.POD_ID          "POD_ID",
										A.SINK_ID         "SINK_ID",
										B.MARKET_PRICE_ID "MARKET_PRICE_ID1",
										C.MARKET_PRICE_ID "MARKET_PRICE_ID2"
			FROM INTERCHANGE_TRANSACTION A, MARKET_PRICE B, MARKET_PRICE C
		 WHERE A.BEGIN_DATE <= TRUNC(p_END_DATE)
			 AND NVL(A.END_DATE,
							 CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
			 AND A.CONTRACT_ID = p_CONTRACT_ID
			 AND UPPER(A.TRANSACTION_INTERVAL) = UPPER(p_COMPONENT.RATE_INTERVAL)
			 AND A.POD_ID = DECODE(p_COMPONENT.SERVICE_POINT_ID,
														 g_NOT_ASSIGNED,
														 A.POD_ID,
														 p_COMPONENT.SERVICE_POINT_ID)
			 AND UPPER(SUBSTR(A.TRANSACTION_TYPE,
												1,
												2)) = 'PU'
			 AND B.MARKET_PRICE_TYPE = p_COMPONENT.MARKET_PRICE_TYPE
			 AND B.MARKET_TYPE = p_COMPONENT.MARKET_TYPE
			 AND B.POD_ID = A.POD_ID
			 AND C.MARKET_PRICE_TYPE = p_COMPONENT.MARKET_PRICE_TYPE
			 AND C.MARKET_TYPE = p_COMPONENT.MARKET_TYPE
			 AND C.POD_ID = A.SINK_ID
			 AND UPPER(A.AGREEMENT_TYPE) NOT LIKE '%FTR%';

	CURSOR c_SALE_POINTS IS
		SELECT DISTINCT A.SOURCE_ID       "SOURCE_ID",
										A.POD_ID          "POD_ID",
										g_NOT_ASSIGNED    "SINK_ID",
										B.MARKET_PRICE_ID "MARKET_PRICE_ID1",
										C.MARKET_PRICE_ID "MARKET_PRICE_ID2"
			FROM INTERCHANGE_TRANSACTION A, MARKET_PRICE B, MARKET_PRICE C
		 WHERE UPPER(p_COMPONENT.LMP_INCLUDE_SALES) <> UPPER(g_LMP_INCLUDE_NONE)
			 AND A.BEGIN_DATE <= TRUNC(p_END_DATE)
			 AND NVL(A.END_DATE,
							 CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
			 AND A.CONTRACT_ID = p_CONTRACT_ID
			 AND UPPER(A.TRANSACTION_INTERVAL) = UPPER(p_COMPONENT.RATE_INTERVAL)
			 AND A.POD_ID = DECODE(p_COMPONENT.SERVICE_POINT_ID,
														 g_NOT_ASSIGNED,
														 A.POD_ID,
														 p_COMPONENT.SERVICE_POINT_ID)
			 AND UPPER(SUBSTR(A.TRANSACTION_TYPE,
												1,
												2)) = 'SA'
			 AND B.MARKET_PRICE_TYPE = p_COMPONENT.MARKET_PRICE_TYPE
			 AND B.MARKET_TYPE = p_COMPONENT.MARKET_TYPE
			 AND B.POD_ID = A.SOURCE_ID
			 AND C.MARKET_PRICE_TYPE = p_COMPONENT.MARKET_PRICE_TYPE
			 AND C.MARKET_TYPE = p_COMPONENT.MARKET_TYPE
			 AND C.POD_ID = A.POD_ID
			 AND UPPER(A.AGREEMENT_TYPE) NOT LIKE '%FTR%';

BEGIN

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
		LOGS.LOG_INFO_DETAIL('LMP Bilateral Charge (CONTRACT_ID=' || p_CONTRACT_ID || '; SCHEDULE_TYPE=' ||
										p_SCHEDULE_TYPE || '; STATEMENT_TYPE=' || p_STATEMENT_TYPE ||
										'; CHARGE_ID=' || p_CHARGE_ID || '; COMPONENT=' ||
										p_COMPONENT.COMPONENT_NAME || '(' || p_COMPONENT.COMPONENT_ID || ')' ||
										'; BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE,
																							 'MM/DD/YYYY') || '; END_DATE=' ||
										TO_CHAR(p_END_DATE,
														'MM/DD/YYYY') || '; AS_OF_DATE=' ||
										TO_CHAR(p_AS_OF_DATE,
														'MM/DD/YYYY HH24:MI')||')');
	END IF;

	IF UPPER(SUBSTR(p_COMPONENT.RATE_INTERVAL,
									1,
									2)) IN ('DA',
													'WE',
													'MO',
													'YE') THEN
		v_BEGIN_DATE := p_BEGIN_DATE;
		v_END_DATE   := p_END_DATE + 1;
	ELSE
		UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE,
											p_END_DATE,
											p_TIME_ZONE,
											v_BEGIN_DATE,
											v_END_DATE);
		v_BEGIN_DATE := TO_CUT(GET_FIRST_INTERVAL(p_BEGIN_DATE,
																							p_COMPONENT.RATE_INTERVAL),
													 p_TIME_ZONE);
	END IF;
	GET_UNITS_FACTOR(p_COMPONENT.RATE_INTERVAL,
									 v_UNITS_FACTOR);

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PSE_LMP_BILATERAL');
		LOGS.LOG_DEBUG('CONTRACT_ID=' || TO_CHAR(p_CONTRACT_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_END_DATE));
		LOGS.LOG_DEBUG('<id>,<date>,<src id>,<pod id>,<sink id>,<da purch>,<rt purch>,<da sales>,<rt sales>,<da load>,<rt load>,<da gen>,<rt gen>,<quantity>,<rate>,<factor>,<amount>');
	END IF;

	v_PRIOR_CHARGE_ID      := GET_PRIOR_CHARGE_ID(p_CHARGE_ID);
	v_LMP_CHARGE.CHARGE_ID := p_CHARGE_ID;

	-- first process purchases
	v_LMP_CHARGE.DA_SALES := NULL;
	v_LMP_CHARGE.RT_SALES := NULL;
	v_INCLUDE_EXT         := NVL(p_COMPONENT.LMP_INCLUDE_EXT,
															 0) = 1;
	FOR v_POINT IN c_PURCHASE_POINTS LOOP
		v_LMP_CHARGE.SOURCE_ID         := v_POINT.SOURCE_ID;
		v_LMP_CHARGE.DELIVERY_POINT_ID := v_POINT.POD_ID;
		v_LMP_CHARGE.SINK_ID           := v_POINT.SINK_ID;

		v_DATE := v_BEGIN_DATE; --GET_FIRST_INTERVAL(v_BEGIN_DATE,p_COMPONENT.RATE_INTERVAL);
		WHILE v_DATE <= v_END_DATE LOOP
			v_LMP_CHARGE.CHARGE_DATE := v_DATE;
			v_PUT_ROW                := FALSE;

			-- gather day-ahead quantities
      IF p_COMPONENT.MARKET_TYPE = g_DAY_AHEAD THEN
  			v_LMP_CHARGE.DA_PURCHASES := GET_LMP_QUANTITY(TRUNC(p_BEGIN_DATE +
  																													(v_DATE - v_BEGIN_DATE)),
  																										v_DATE,
  																										p_SCHEDULE_TYPE,
  																										p_AS_OF_DATE,
  																										p_CONTRACT_ID,
  																										p_COMPONENT.RATE_INTERVAL,
  																										'PU',
  																										0,
  																										0,
  																										g_DAY_AHEAD,
  																										v_POINT.SOURCE_ID,
  																										v_POINT.POD_ID,
  																										v_POINT.SINK_ID,
  																										p_COMPONENT.QUANTITY_UNIT,
  																										v_UNITS_FACTOR);
  			IF v_INCLUDE_EXT THEN
  				v_EXT_AMT                 := GET_LMP_QUANTITY(TRUNC(p_BEGIN_DATE +
  																														(v_DATE - v_BEGIN_DATE)),
  																											v_DATE,
  																											p_SCHEDULE_TYPE,
  																											p_AS_OF_DATE,
  																											p_CONTRACT_ID,
  																											p_COMPONENT.RATE_INTERVAL,
  																											'PU',
  																											1,
  																											0,
  																											g_DAY_AHEAD,
  																											v_POINT.SOURCE_ID,
  																											v_POINT.POD_ID,
  																											v_POINT.SINK_ID,
  																											p_COMPONENT.QUANTITY_UNIT,
  																											v_UNITS_FACTOR);
  				v_LMP_CHARGE.DA_PURCHASES := NVL(v_LMP_CHARGE.DA_PURCHASES,
  																				 0) + NVL(v_EXT_AMT,
  																									0);
  			END IF;
      END IF;
			IF NVL(v_LMP_CHARGE.DA_PURCHASES,
						 0) <> 0 THEN
				v_PUT_ROW := TRUE;
			END IF;

			--now gather real-time quantities
			IF p_COMPONENT.MARKET_TYPE <> g_DAY_AHEAD THEN
				v_LMP_CHARGE.RT_PURCHASES := GET_LMP_QUANTITY(TRUNC(p_BEGIN_DATE +
																														(v_DATE - v_BEGIN_DATE)),
																											v_DATE,
																											p_SCHEDULE_TYPE,
																											p_AS_OF_DATE,
																											p_CONTRACT_ID,
																											p_COMPONENT.RATE_INTERVAL,
																											'PU',
																											0,
																											0,
																											p_COMPONENT.MARKET_TYPE,
																											v_POINT.SOURCE_ID,
																											v_POINT.POD_ID,
																											v_POINT.SINK_ID,
																											p_COMPONENT.QUANTITY_UNIT,
																											v_UNITS_FACTOR);
				IF v_INCLUDE_EXT THEN
					v_EXT_AMT                 := GET_LMP_QUANTITY(TRUNC(p_BEGIN_DATE +
																															(v_DATE - v_BEGIN_DATE)),
																												v_DATE,
																												p_SCHEDULE_TYPE,
																												p_AS_OF_DATE,
																												p_CONTRACT_ID,
																												p_COMPONENT.RATE_INTERVAL,
																												'PU',
																												1,
																												0,
																												p_COMPONENT.MARKET_TYPE,
																												v_POINT.SOURCE_ID,
																												v_POINT.POD_ID,
																												v_POINT.SINK_ID,
																												p_COMPONENT.QUANTITY_UNIT,
																												v_UNITS_FACTOR);
					v_LMP_CHARGE.RT_PURCHASES := NVL(v_LMP_CHARGE.RT_PURCHASES,
																					 0) + NVL(v_EXT_AMT,
																										0);
				END IF;
				IF NVL(v_LMP_CHARGE.RT_PURCHASES,
							 0) <> 0 THEN
					v_PUT_ROW := TRUE;
				END IF;
			END IF;

			IF v_PUT_ROW THEN
				-- only put row if all non-null data
				-- get the rate
				-- 9-may-2005, jbc: i think that this is incorrect, and price 2 should
				-- go with the POD, and price 1 should go with the sink
				--v_LMP_CHARGE.PRICE1 := GET_LMP_PRICE(v_POINT.MARKET_PRICE_ID1, v_DATE, p_AS_OF_DATE);
				--v_LMP_CHARGE.PRICE2 := GET_LMP_PRICE(v_POINT.MARKET_PRICE_ID2, v_DATE, p_AS_OF_DATE);
				v_LMP_CHARGE.PRICE1 := GET_LMP_PRICE(v_POINT.MARKET_PRICE_ID2,
																						 v_DATE,
																						 p_AS_OF_DATE);
				v_LMP_CHARGE.PRICE2 := GET_LMP_PRICE(v_POINT.MARKET_PRICE_ID1,
																						 v_DATE,
																						 p_AS_OF_DATE);

				v_LMP_CHARGE.CHARGE_RATE := NVL(v_LMP_CHARGE.PRICE1,
																				0) - NVL(v_LMP_CHARGE.PRICE2,
																								 0);
				-- and wrap up this entry
				IF p_COMPONENT.MARKET_TYPE = g_DAY_AHEAD THEN
					v_LMP_CHARGE.CHARGE_QUANTITY := NVL(v_LMP_CHARGE.DA_PURCHASES,
																							0);
				ELSE
					v_LMP_CHARGE.CHARGE_QUANTITY := NVL(v_LMP_CHARGE.RT_PURCHASES,
																							0) - NVL(v_LMP_CHARGE.DA_PURCHASES,
																											 0);
				END IF;
				v_LMP_CHARGE.CHARGE_FACTOR := GET_COMPONENT_FACTOR(p_COMPONENT.COMPONENT_ID,
																													 v_DATE);
				v_LMP_CHARGE.CHARGE_AMOUNT := v_LMP_CHARGE.CHARGE_RATE *
																			v_LMP_CHARGE.CHARGE_FACTOR *
																			v_LMP_CHARGE.CHARGE_QUANTITY;

				PRIOR_LMP_CHARGE(v_PRIOR_CHARGE_ID,
												 v_LMP_CHARGE);
				PUT_LMP_CHARGE(v_LMP_CHARGE);
			END IF;
			v_DATE := GET_NEXT_INTERVAL(v_DATE,
																	p_COMPONENT.RATE_INTERVAL);
		END LOOP;
	END LOOP;

	-- then process sales
	v_LMP_CHARGE.DA_PURCHASES := NULL;
	v_LMP_CHARGE.RT_PURCHASES := NULL;
	v_INCLUDE_EXT             := v_INCLUDE_EXT AND UPPER(p_COMPONENT.LMP_INCLUDE_SALES) NOT IN
															 (UPPER(g_LMP_INCLUDE_NONE),
																UPPER(g_LMP_INCLUDE_INTERNAL));
	v_INCLUDE_INT             := UPPER(p_COMPONENT.LMP_INCLUDE_SALES)
															 NOT IN (UPPER(g_LMP_INCLUDE_NONE),
																			 UPPER(g_LMP_INCLUDE_EXTERNAL));
	FOR v_POINT IN c_SALE_POINTS LOOP
		v_LMP_CHARGE.SOURCE_ID         := v_POINT.SOURCE_ID;
		v_LMP_CHARGE.DELIVERY_POINT_ID := v_POINT.POD_ID;
		v_LMP_CHARGE.SINK_ID           := v_POINT.SINK_ID;

		v_DATE := v_BEGIN_DATE; --GET_FIRST_INTERVAL(v_BEGIN_DATE,p_COMPONENT.RATE_INTERVAL);
		WHILE v_DATE <= v_END_DATE LOOP
			v_LMP_CHARGE.CHARGE_DATE := v_DATE;
			v_PUT_ROW                := FALSE;

			-- gather day-ahead quantities
      -- hack for MISO: day-ahead fin scheds don't play in RT_FIN_LS
      -- and RT_FIN_CG calcs
      IF p_COMPONENT.MARKET_TYPE = g_DAY_AHEAD THEN
  			IF v_INCLUDE_INT THEN
  				v_LMP_CHARGE.DA_SALES := GET_LMP_QUANTITY(TRUNC(p_BEGIN_DATE +
  																												(v_DATE - v_BEGIN_DATE)),
  																									v_DATE,
  																									p_SCHEDULE_TYPE,
  																									p_AS_OF_DATE,
  																									p_CONTRACT_ID,
  																									p_COMPONENT.RATE_INTERVAL,
  																									'SA',
  																									0,
  																									0,
  																									g_DAY_AHEAD,
  																									v_POINT.SOURCE_ID,
  																									v_POINT.POD_ID,
  																									v_POINT.SINK_ID,
  																									p_COMPONENT.QUANTITY_UNIT,
  																									v_UNITS_FACTOR);
  			ELSE
  				v_LMP_CHARGE.DA_SALES := 0;
  			END IF;
  			IF v_INCLUDE_EXT THEN
  				v_EXT_AMT             := GET_LMP_QUANTITY(TRUNC(p_BEGIN_DATE +
  																												(v_DATE - v_BEGIN_DATE)),
  																									v_DATE,
  																									p_SCHEDULE_TYPE,
  																									p_AS_OF_DATE,
  																									p_CONTRACT_ID,
  																									p_COMPONENT.RATE_INTERVAL,
  																									'SA',
  																									1,
  																									0,
  																									g_DAY_AHEAD,
  																									v_POINT.SOURCE_ID,
  																									v_POINT.POD_ID,
  																									v_POINT.SINK_ID,
  																									p_COMPONENT.QUANTITY_UNIT,
  																									v_UNITS_FACTOR);
  				v_LMP_CHARGE.DA_SALES := NVL(v_LMP_CHARGE.DA_SALES,
  																		 0) + NVL(v_EXT_AMT,
  																							0);
  			END IF;
      END IF;
			IF NVL(v_LMP_CHARGE.DA_SALES,
						 0) <> 0 THEN
				v_PUT_ROW := TRUE;
			END IF;

			--now gather real-time quantities
			IF p_COMPONENT.MARKET_TYPE <> g_DAY_AHEAD THEN
				IF v_INCLUDE_INT THEN
					v_LMP_CHARGE.RT_SALES := GET_LMP_QUANTITY(TRUNC(p_BEGIN_DATE +
																													(v_DATE - v_BEGIN_DATE)),
																										v_DATE,
																										p_SCHEDULE_TYPE,
																										p_AS_OF_DATE,
																										p_CONTRACT_ID,
																										p_COMPONENT.RATE_INTERVAL,
																										'SA',
																										0,
																										0,
																										p_COMPONENT.MARKET_TYPE,
																										v_POINT.SOURCE_ID,
																										v_POINT.POD_ID,
																										v_POINT.SINK_ID,
																										p_COMPONENT.QUANTITY_UNIT,
																										v_UNITS_FACTOR);
				ELSE
					v_LMP_CHARGE.RT_SALES := 0;
				END IF;
				IF v_INCLUDE_EXT THEN
					v_EXT_AMT             := GET_LMP_QUANTITY(TRUNC(p_BEGIN_DATE +
																													(v_DATE - v_BEGIN_DATE)),
																										v_DATE,
																										p_SCHEDULE_TYPE,
																										p_AS_OF_DATE,
																										p_CONTRACT_ID,
																										p_COMPONENT.RATE_INTERVAL,
																										'SA',
																										1,
																										0,
																										p_COMPONENT.MARKET_TYPE,
																										v_POINT.SOURCE_ID,
																										v_POINT.POD_ID,
																										v_POINT.SINK_ID,
																										p_COMPONENT.QUANTITY_UNIT,
																										v_UNITS_FACTOR);
					v_LMP_CHARGE.RT_SALES := NVL(v_LMP_CHARGE.RT_SALES,
																			 0) + NVL(v_EXT_AMT,
																								0);
				END IF;
				IF NVL(v_LMP_CHARGE.RT_SALES,
							 0) <> 0 THEN
					v_PUT_ROW := TRUE;
				END IF;
			END IF;

			IF v_PUT_ROW THEN
				-- only put row if all non-null data
				-- get the rate
				v_LMP_CHARGE.PRICE1      := GET_LMP_PRICE(v_POINT.MARKET_PRICE_ID1,
																									v_DATE,
																									p_AS_OF_DATE);
				v_LMP_CHARGE.PRICE2      := GET_LMP_PRICE(v_POINT.MARKET_PRICE_ID2,
																									v_DATE,
																									p_AS_OF_DATE);
				v_LMP_CHARGE.CHARGE_RATE := NVL(v_LMP_CHARGE.PRICE1,
																				0) - NVL(v_LMP_CHARGE.PRICE2,
																								 0);
				-- and wrap up this entry
				IF p_COMPONENT.MARKET_TYPE = g_DAY_AHEAD THEN
					v_LMP_CHARGE.CHARGE_QUANTITY := NVL(v_LMP_CHARGE.DA_SALES,
																							0);
				ELSE
					v_LMP_CHARGE.CHARGE_QUANTITY := NVL(v_LMP_CHARGE.RT_SALES,
																							0) - NVL(v_LMP_CHARGE.DA_SALES,
																											 0);
				END IF;
				v_LMP_CHARGE.CHARGE_FACTOR := GET_COMPONENT_FACTOR(p_COMPONENT.COMPONENT_ID,
																													 v_DATE);
				v_LMP_CHARGE.CHARGE_AMOUNT := v_LMP_CHARGE.CHARGE_RATE *
																			v_LMP_CHARGE.CHARGE_FACTOR *
																			v_LMP_CHARGE.CHARGE_QUANTITY;

				PRIOR_LMP_CHARGE(v_PRIOR_CHARGE_ID,
												 v_LMP_CHARGE);
				PUT_LMP_CHARGE(v_LMP_CHARGE);
			END IF;
			v_DATE := GET_NEXT_INTERVAL(v_DATE,
																	p_COMPONENT.RATE_INTERVAL);
		END LOOP;
	END LOOP;

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
		LOGS.LOG_INFO_DETAIL('LMP Bilateral Charge - Completed Successfully');
	END IF;

END PSE_LMP_BILATERAL_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_COMBINATION_CHARGE
	(
	p_PSE_GROUP IN VARCHAR2,
	p_BILLING_STATEMENT IN BILLING_STATEMENT%ROWTYPE,
    p_CONTRACT_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_CHARGE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_WEEK_BEGIN IN VARCHAR2
	) AS
CURSOR c_COMBINED_COMPONENTS IS
	SELECT B.COMPONENT_ID,
		A.COEFFICIENT,
		GREATEST(p_BEGIN_DATE,A.BEGIN_DATE) "BEGIN_DATE",
		LEAST(p_END_DATE,NVL(A.END_DATE,HIGH_DATE)) "END_DATE"
	FROM COMPONENT_COMBINATION A,
		COMPONENT B
	WHERE A.COMPONENT_ID = p_COMPONENT.COMPONENT_ID
    	AND A.SUB_COMPONENT_TYPE = g_NO_SUB_TYPE
        AND A.SUB_COMPONENT_ID = g_NOT_ASSIGNED
		AND A.BEGIN_DATE <= p_END_DATE
		AND NVL(A.END_DATE,HIGH_DATE) >= p_BEGIN_DATE
		AND A.COEFFICIENT <> 0.0 -- ignore zero-charges
		AND B.COMPONENT_ID = A.COMBINED_COMPONENT_ID
	ORDER BY DECODE(UPPER(B.CHARGE_TYPE),'TAX',1,0),
		DECODE(UPPER(B.RATE_STRUCTURE),'EXTERNAL',1,0),
        B.COMPUTATION_ORDER;
v_BILLING_STATEMENT BILLING_STATEMENT%ROWTYPE;
v_WRITE_BILLING_STATEMENT BOOLEAN;
v_COMPONENT COMPONENT%ROWTYPE;
v_COMBINATION_CHARGE COMBINATION_CHARGE%ROWTYPE;
v_PRIOR_CHARGE_ID NUMBER;
BEGIN
	v_BILLING_STATEMENT.CHARGE_ID := 0;

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Combination Charge (CONTRACT_ID=' || p_CONTRACT_ID || '; SCHEDULE_TYPE=' || p_SCHEDULE_TYPE || '; STATEMENT_TYPE=' || p_STATEMENT_TYPE ||
			'; CHARGE_ID=' || p_CHARGE_ID || '; COMPONENT=' || p_COMPONENT.COMPONENT_ID ||
			'; BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE,'MM/DD/YYYY') || '; END_DATE=' || TO_CHAR(p_END_DATE,'MM/DD/YYYY')||')');
	END IF;

	v_COMBINATION_CHARGE.CHARGE_ID := p_CHARGE_ID;
	v_COMBINATION_CHARGE.CHARGE_FACTOR := GET_COMPONENT_FACTOR(p_COMPONENT.COMPONENT_ID, p_BEGIN_DATE);
    v_PRIOR_CHARGE_ID := GET_PRIOR_CHARGE_ID(p_CHARGE_ID);

	FOR v_COMBINED_COMPONENT IN c_COMBINED_COMPONENTS LOOP
		v_COMPONENT := GET_COMPONENT(v_COMBINED_COMPONENT.COMPONENT_ID);
		-- create entry in BILLING_STATEMENT so that all calculations work
		-- correctly - since retrieval of bill_quantity and bill_amount
		-- require it...
		v_BILLING_STATEMENT.ENTITY_ID := p_BILLING_STATEMENT.ENTITY_ID;
		v_BILLING_STATEMENT.ENTITY_TYPE := 'PSE';
		v_BILLING_STATEMENT.PRODUCT_ID := -p_CHARGE_ID;
		v_BILLING_STATEMENT.COMPONENT_ID := v_COMBINED_COMPONENT.COMPONENT_ID;
		v_BILLING_STATEMENT.STATEMENT_TYPE := p_STATEMENT_TYPE;
		v_BILLING_STATEMENT.STATEMENT_STATE := GA.INTERNAL_STATE;
		v_BILLING_STATEMENT.STATEMENT_DATE := v_COMBINED_COMPONENT.BEGIN_DATE;
		v_BILLING_STATEMENT.STATEMENT_END_DATE := v_COMBINED_COMPONENT.END_DATE;
		v_BILLING_STATEMENT.AS_OF_DATE := p_BILLING_STATEMENT.AS_OF_DATE;
		v_BILLING_STATEMENT.BASIS_AS_OF_DATE := p_BILLING_STATEMENT.BASIS_AS_OF_DATE;
        GET_CHARGE_ID(v_BILLING_STATEMENT);
        v_BILLING_STATEMENT.CHARGE_QUANTITY := 0;
        v_BILLING_STATEMENT.CHARGE_RATE := 0;
        v_BILLING_STATEMENT.CHARGE_AMOUNT := 0;
        v_BILLING_STATEMENT.BILL_QUANTITY := 0;
        v_BILLING_STATEMENT.BILL_AMOUNT := 0;
		PUT_BILLING_STATEMENT(v_BILLING_STATEMENT); -- store so that logic that fetches bill quantities/amounts will work
		-- run calculations
		PSE_BILLING_STATEMENT_CHARGE(v_BILLING_STATEMENT, p_CONTRACT_ID, p_SCHEDULE_TYPE, p_STATEMENT_TYPE, v_COMPONENT, v_COMBINED_COMPONENT.BEGIN_DATE, v_COMBINED_COMPONENT.END_DATE, p_AS_OF_DATE, p_TIME_ZONE, p_WEEK_BEGIN, p_PSE_GROUP);
		-- store results if necessary
        GET_BILLING_STATEMENT_CHARGES(v_BILLING_STATEMENT, v_WRITE_BILLING_STATEMENT);
        IF v_WRITE_BILLING_STATEMENT THEN
			-- store charge detail row
			v_COMBINATION_CHARGE.COMPONENT_ID := v_COMBINED_COMPONENT.COMPONENT_ID;
			v_COMBINATION_CHARGE.COMBINED_CHARGE_ID := v_BILLING_STATEMENT.CHARGE_ID;
			v_COMBINATION_CHARGE.CHARGE_VIEW_TYPE := v_BILLING_STATEMENT.CHARGE_VIEW_TYPE;
			v_COMBINATION_CHARGE.BEGIN_DATE := v_COMBINED_COMPONENT.BEGIN_DATE;
			v_COMBINATION_CHARGE.END_DATE := v_COMBINED_COMPONENT.END_DATE;
			v_COMBINATION_CHARGE.CHARGE_QUANTITY := v_BILLING_STATEMENT.CHARGE_QUANTITY;
			v_COMBINATION_CHARGE.CHARGE_RATE := v_BILLING_STATEMENT.CHARGE_RATE;
			v_COMBINATION_CHARGE.COMPONENT_AMOUNT := v_BILLING_STATEMENT.CHARGE_AMOUNT;
			v_COMBINATION_CHARGE.COEFFICIENT := v_COMBINED_COMPONENT.COEFFICIENT;
			v_COMBINATION_CHARGE.CHARGE_AMOUNT := v_BILLING_STATEMENT.CHARGE_AMOUNT * v_COMBINATION_CHARGE.COEFFICIENT * v_COMBINATION_CHARGE.CHARGE_FACTOR;
			v_COMBINATION_CHARGE.BILL_QUANTITY := v_BILLING_STATEMENT.BILL_QUANTITY;
			v_COMBINATION_CHARGE.BILL_COMPONENT_AMOUNT := v_BILLING_STATEMENT.BILL_AMOUNT;
			v_COMBINATION_CHARGE.BILL_AMOUNT := v_BILLING_STATEMENT.BILL_AMOUNT * v_COMBINATION_CHARGE.COEFFICIENT * v_COMBINATION_CHARGE.CHARGE_FACTOR;
	        PRIOR_COMBINATION_CHARGE(v_PRIOR_CHARGE_ID, v_COMBINATION_CHARGE);
			PUT_COMBINATION_CHARGE(v_COMBINATION_CHARGE);
    		-- update charge ID first, so that delete trigger doesn't destroy
    		-- the details we just calculated - details are preserved for drill-down
    		-- from top-level combination charge
    		UPDATE BILLING_STATEMENT SET CHARGE_ID = -CHARGE_ID WHERE CHARGE_ID = v_BILLING_STATEMENT.CHARGE_ID;
			v_BILLING_STATEMENT.CHARGE_ID := -v_BILLING_STATEMENT.CHARGE_ID;
        END IF;
		-- clean up temp row from billing statement table
		g_DELETING_TEMP_ROW := TRUE;
	    DELETE BILLING_STATEMENT WHERE CHARGE_ID = v_BILLING_STATEMENT.CHARGE_ID;
		g_DELETING_TEMP_ROW := FALSE;
	END LOOP;

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Combination Charge - Completed Successfully');
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		-- clean up if necessary
		IF v_BILLING_STATEMENT.CHARGE_ID <> 0 THEN
			BEGIN
    			g_DELETING_TEMP_ROW := TRUE;
    		    DELETE BILLING_STATEMENT WHERE CHARGE_ID = v_BILLING_STATEMENT.CHARGE_ID;
    			g_DELETING_TEMP_ROW := FALSE;
			EXCEPTION
				WHEN OTHERS THEN
	    			g_DELETING_TEMP_ROW := FALSE;
					ERRS.LOG_AND_CONTINUE;
			END;
		END IF;
		g_DELETING_TEMP_ROW := FALSE;
		ERRS.LOG_AND_RAISE;

END PSE_COMBINATION_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_PIPELINE_CHARGE
    (
	p_CONTRACT_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_CHARGE_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2
	) AS

v_FUEL BOOLEAN;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_PIPELINE_CHARGE PIPELINE_CHARGE%ROWTYPE;
v_PRIOR_CHARGE_ID NUMBER;

CURSOR c_SCHEDULES IS
    SELECT A.TRANSACTION_ID "DELIVERY_ID",
		D.POR_ID, D.POD_ID,
		D.SEGMENT_ORDER "SEGMENT_NUMBER",
		E.SCHEDULE_DATE "CHARGE_DATE",
		E.DELIVERED_AMOUNT,
		E.FUEL_AMOUNT
	FROM INTERCHANGE_TRANSACTION A,
		IT_STATUS B,
	    IT_COMMODITY C,
	    IT_SEGMENT D,
		IT_SEGMENT_SCHEDULE E
	WHERE A.BEGIN_DATE <= TRUNC(p_END_DATE)
		AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
		AND UPPER(A.TRANSACTION_INTERVAL) =  UPPER(p_COMPONENT.RATE_INTERVAL)
		AND A.TRANSACTION_TYPE = 'Delivery'
		AND B.TRANSACTION_ID = A.TRANSACTION_ID
		AND B.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_STATUS
			WHERE TRANSACTION_ID = B.TRANSACTION_ID
				AND AS_OF_DATE <= p_AS_OF_DATE)
		AND B.TRANSACTION_IS_ACTIVE = 1
	    AND C.COMMODITY_ID = A.COMMODITY_ID
		AND UPPER(SUBSTR(C.COMMODITY_TYPE,1,1)) = 'G'
	    AND D.TRANSACTION_ID = A.TRANSACTION_ID
		AND D.CONTRACT_ID = p_CONTRACT_ID
		AND D.POD_ID = DECODE(p_COMPONENT.SERVICE_POINT_ID, g_NOT_ASSIGNED, D.POD_ID, p_COMPONENT.SERVICE_POINT_ID)
		AND E.IT_SEGMENT_ID = D.IT_SEGMENT_ID
		AND E.STATEMENT_TYPE_ID = p_SCHEDULE_TYPE
		AND E.SCHEDULE_STATE = GA.INTERNAL_STATE
		AND E.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND E.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_SEGMENT_SCHEDULE
			WHERE IT_SEGMENT_ID = E.IT_SEGMENT_ID
				AND STATEMENT_TYPE_ID = E.STATEMENT_TYPE_ID
				AND SCHEDULE_STATE = E.SCHEDULE_STATE
				AND SCHEDULE_DATE = E.SCHEDULE_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE);

BEGIN

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Pipeline Charge (CONTRACT_ID=' || p_CONTRACT_ID || '; SCHEDULE_TYPE=' || p_SCHEDULE_TYPE || '; STATEMENT_TYPE=' || p_STATEMENT_TYPE ||
			'; CHARGE_ID=' || p_CHARGE_ID || '; COMPONENT=' || p_COMPONENT.COMPONENT_NAME || '(' || p_COMPONENT.COMPONENT_ID || ')' ||
			'; BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE,'MM/DD/YYYY') || '; END_DATE=' || TO_CHAR(p_END_DATE,'MM/DD/YYYY') ||
			'; AS_OF_DATE=' || TO_CHAR(p_AS_OF_DATE,'MM/DD/YYYY HH24:MI')||')');
	END IF;

	IF UPPER(SUBSTR(p_COMPONENT.RATE_INTERVAL,1,2)) IN ('DA','WE','MO','YE') THEN
	    v_BEGIN_DATE := p_BEGIN_DATE;
		v_END_DATE := p_END_DATE + 1;
	ELSE
	    UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('PSE_PIPELINE_CHARGE');
		LOGS.LOG_DEBUG('CONTRACT_ID=' || TO_CHAR(p_CONTRACT_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_END_DATE));
	    LOGS.LOG_DEBUG('<id>,<date>,<delivery>,<por>,<pod>,<quantity>,<rate>,<factor>,<amount>');
	END IF;

	v_PRIOR_CHARGE_ID := GET_PRIOR_CHARGE_ID(p_CHARGE_ID);
	v_PIPELINE_CHARGE.CHARGE_ID := p_CHARGE_ID;
	v_PIPELINE_CHARGE.CHARGE_FACTOR := GET_COMPONENT_FACTOR(p_COMPONENT.COMPONENT_ID, v_BEGIN_DATE);
	v_FUEL := UPPER(p_COMPONENT.CHARGE_TYPE) = 'PIPELINE FUEL';

	FOR v_SCHEDULES IN c_SCHEDULES LOOP
		v_PIPELINE_CHARGE.CHARGE_DATE := v_SCHEDULES.CHARGE_DATE;
		v_PIPELINE_CHARGE.DELIVERY_ID := v_SCHEDULES.DELIVERY_ID;
		v_PIPELINE_CHARGE.POR_ID := v_SCHEDULES.POR_ID;
		v_PIPELINE_CHARGE.POD_ID := v_SCHEDULES.POD_ID;
		v_PIPELINE_CHARGE.SEGMENT_NUMBER := v_SCHEDULES.SEGMENT_NUMBER;
		IF v_FUEL THEN
			v_PIPELINE_CHARGE.CHARGE_QUANTITY := v_SCHEDULES.FUEL_AMOUNT;
			v_PIPELINE_CHARGE.CHARGE_RATE := GDJ.LOOKUP_PIPELINE_FUEL_RATE(p_CONTRACT_ID, v_SCHEDULES.POR_ID, v_SCHEDULES.POD_ID, v_SCHEDULES.CHARGE_DATE);
		ELSE
			v_PIPELINE_CHARGE.CHARGE_QUANTITY := v_SCHEDULES.DELIVERED_AMOUNT;
			v_PIPELINE_CHARGE.CHARGE_RATE := GDJ.LOOKUP_PIPELINE_COMMODITY_RATE(p_CONTRACT_ID, v_SCHEDULES.POR_ID, v_SCHEDULES.POD_ID, v_SCHEDULES.CHARGE_DATE);
		END IF;
		v_PIPELINE_CHARGE.CHARGE_AMOUNT := v_PIPELINE_CHARGE.CHARGE_QUANTITY * v_PIPELINE_CHARGE.CHARGE_RATE * v_PIPELINE_CHARGE.CHARGE_FACTOR;
		PRIOR_PIPELINE_CHARGE(v_PRIOR_CHARGE_ID, v_PIPELINE_CHARGE);
		PUT_PIPELINE_CHARGE(v_PIPELINE_CHARGE);
	END LOOP;

	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    LOGS.LOG_INFO_DETAIL('Pipeline Charge - Completed Successfully');
	END IF;

END PSE_PIPELINE_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_BILLING_STATEMENT_CHARGE
	(
	p_BILLING_STATEMENT IN OUT BILLING_STATEMENT%ROWTYPE,
	p_CONTRACT_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_WEEK_BEGIN IN VARCHAR2,
	p_PSE_GROUP IN VARCHAR2 := NULL
	) AS

v_RATE_STRUCTURE VARCHAR(32);
v_IMBALANCE_TYPE VARCHAR(16);

BEGIN
	-- make sure that a combination charge hasn't caused a circular reference
	IF g_COMPONENT_HISTORY.EXISTS(p_COMPONENT.COMPONENT_ID) THEN
		ERRS.RAISE(MSGCODES.c_ERR_CIRC_REF, TEXT_UTIL.TO_CHAR_ENTITY(p_COMPONENT.COMPONENT_ID, EC.ED_COMPONENT, TRUE));
	END IF;
	g_COMPONENT_HISTORY(p_COMPONENT.COMPONENT_ID) := 1;

	v_RATE_STRUCTURE := UPPER(p_COMPONENT.RATE_STRUCTURE);

	IF UPPER(p_COMPONENT.CHARGE_TYPE) = 'TAX' AND v_RATE_STRUCTURE <> 'EXTERNAL' THEN
        -- external tax components get computed below
        p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'TAX CHARGE';
        PSE_TAX_CHARGE(p_CONTRACT_ID, p_SCHEDULE_TYPE, p_STATEMENT_TYPE, p_BILLING_STATEMENT.CHARGE_ID, p_COMPONENT, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE);
	ELSIF v_RATE_STRUCTURE = 'IMBALANCE' THEN
		v_IMBALANCE_TYPE := UPPER(p_COMPONENT.IMBALANCE_TYPE);
		IF v_IMBALANCE_TYPE = 'NET RETAIL' THEN
		    p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'IMBALANCE1';
			PSE_RETAIL_IMBALANCE(p_CONTRACT_ID, p_SCHEDULE_TYPE, p_STATEMENT_TYPE, p_BILLING_STATEMENT.CHARGE_ID, p_COMPONENT, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE);
		ELSIF v_IMBALANCE_TYPE = 'GENERATION' THEN
		    p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'IMBALANCE2';
			PSE_GENERATION_IMBALANCE(p_CONTRACT_ID, p_SCHEDULE_TYPE, p_BILLING_STATEMENT.CHARGE_ID, p_COMPONENT, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE);
		ELSIF v_IMBALANCE_TYPE = 'SERVICE POINT' THEN
		    p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'IMBALANCE3';
			PSE_RETAIL_IMBALANCE(p_CONTRACT_ID, p_SCHEDULE_TYPE, p_STATEMENT_TYPE, p_BILLING_STATEMENT.CHARGE_ID, p_COMPONENT, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE);
		ELSIF v_IMBALANCE_TYPE = 'ACCUMULATED' THEN
		    p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'IMBALANCE4';
			PSE_ACCUMULATED_IMBALANCE(p_CONTRACT_ID, p_SCHEDULE_TYPE, p_STATEMENT_TYPE, p_BILLING_STATEMENT, p_COMPONENT, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE);
		END IF;
	ELSIF v_RATE_STRUCTURE = 'CONVERSION' THEN
		IF UPPER(p_COMPONENT.CHARGE_TYPE) = 'CONVERSION' THEN
			p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'CONVERSION';
			PSE_CONVERSION_CHARGE(p_CONTRACT_ID, p_SCHEDULE_TYPE, p_STATEMENT_TYPE, p_BILLING_STATEMENT.CHARGE_ID, p_COMPONENT, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE);
		ELSIF UPPER(p_COMPONENT.CHARGE_TYPE) = 'PEAK DEMAND' THEN
			p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'CONVERSION';
			PSE_CONVERSION_PEAK_DEMAND(p_CONTRACT_ID, p_BILLING_STATEMENT.ENTITY_ID, p_SCHEDULE_TYPE, p_BILLING_STATEMENT.CHARGE_ID, p_COMPONENT, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE);
		END IF;
	ELSIF v_RATE_STRUCTURE = 'FLAT' THEN
	    IF UPPER(p_COMPONENT.CHARGE_TYPE) = 'TRANSMISSION' THEN
		    p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'TRANSMISSION';
			PSE_FLAT_TRANSMISSION(p_CONTRACT_ID, p_SCHEDULE_TYPE, p_STATEMENT_TYPE, p_BILLING_STATEMENT.CHARGE_ID, p_COMPONENT, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE);
	    ELSIF UPPER(p_COMPONENT.CHARGE_TYPE) = 'PEAK DEMAND' THEN
		    p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'BILLING CHARGE';
			PSE_FLAT_PEAK_DEMAND(p_BILLING_STATEMENT.ENTITY_ID, p_SCHEDULE_TYPE, p_BILLING_STATEMENT.CHARGE_ID, p_COMPONENT, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE);
	    ELSIF UPPER(p_COMPONENT.CHARGE_TYPE) = 'SERVICE' THEN
		    p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'BILLING CHARGE';
			PSE_FLAT_SERVICE(p_CONTRACT_ID, p_STATEMENT_TYPE, p_BILLING_STATEMENT.CHARGE_ID, p_COMPONENT, p_BEGIN_DATE, p_END_DATE);
	    ELSIF UPPER(p_COMPONENT.CHARGE_TYPE) IN ('ENERGY','CAPACITY','GAS') THEN
		    p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'BILLING CHARGE';
			PSE_FLAT_CHARGE(p_CONTRACT_ID, p_SCHEDULE_TYPE, p_STATEMENT_TYPE, p_BILLING_STATEMENT.CHARGE_ID, p_COMPONENT, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE);
		END IF;
	ELSIF v_RATE_STRUCTURE = 'INTERNAL' THEN
    	IF UPPER(p_COMPONENT.CHARGE_TYPE) = 'FTR AUCTION' THEN
		    p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'TRANSMISSION';
			PSE_FTR_AUCTION(p_BILLING_STATEMENT.ENTITY_ID, p_CONTRACT_ID, p_SCHEDULE_TYPE, p_STATEMENT_TYPE, p_BILLING_STATEMENT.CHARGE_ID, p_COMPONENT, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE);
	    ELSIF UPPER(p_COMPONENT.CHARGE_TYPE) = 'TRANSMISSION' THEN
		    p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'TRANSMISSION';
			PSE_INTERNAL_TRANSMISSION(p_CONTRACT_ID, p_SCHEDULE_TYPE, p_STATEMENT_TYPE, p_BILLING_STATEMENT.CHARGE_ID, p_COMPONENT, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE);
	    ELSIF UPPER(p_COMPONENT.CHARGE_TYPE) IN ('ENERGY','CAPACITY','GAS') THEN
		    p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'BILLING CHARGE';
			PSE_INTERNAL_CHARGE(p_CONTRACT_ID, p_SCHEDULE_TYPE, p_STATEMENT_TYPE, p_BILLING_STATEMENT.CHARGE_ID, p_COMPONENT, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE);
	    ELSIF UPPER(p_COMPONENT.CHARGE_TYPE) IN ('PIPELINE COMMODITY','PIPELINE FUEL') THEN
		    p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'PIPELINE';
			PSE_PIPELINE_CHARGE(p_CONTRACT_ID, p_SCHEDULE_TYPE, p_STATEMENT_TYPE, p_BILLING_STATEMENT.CHARGE_ID, p_COMPONENT, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE);
		END IF;
	ELSIF v_RATE_STRUCTURE = 'MARKET' THEN
	    IF UPPER(p_COMPONENT.CHARGE_TYPE) IN ('ENERGY','CAPACITY','GAS') THEN
		    p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'BILLING CHARGE';
			PSE_MARKET_CHARGE(p_CONTRACT_ID, p_SCHEDULE_TYPE, p_STATEMENT_TYPE, p_BILLING_STATEMENT.CHARGE_ID, p_COMPONENT, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE);
	    ELSIF UPPER(p_COMPONENT.CHARGE_TYPE) = 'OP PROFIT' THEN
		    p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'OP PROFIT';
			PSE_OPER_PROFIT(p_CONTRACT_ID, p_SCHEDULE_TYPE, p_STATEMENT_TYPE, p_BILLING_STATEMENT.CHARGE_ID, p_COMPONENT, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE);
	    END IF;
	ELSIF v_RATE_STRUCTURE = 'BLOCK' THEN
	    IF UPPER(p_COMPONENT.CHARGE_TYPE) IN ('ENERGY','CAPACITY','GAS') THEN
		    p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'BILLING CHARGE';
			PSE_BLOCK_CHARGE(p_CONTRACT_ID, p_SCHEDULE_TYPE, p_STATEMENT_TYPE, p_BILLING_STATEMENT.CHARGE_ID, p_COMPONENT, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE);
	    END IF;
	ELSIF v_RATE_STRUCTURE = 'TIERED' THEN
	    IF UPPER(p_COMPONENT.CHARGE_TYPE) IN ('ENERGY','CAPACITY','GAS') THEN
		    p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'BILLING CHARGE';
			PSE_TIERED_CHARGE(p_CONTRACT_ID, p_SCHEDULE_TYPE, p_STATEMENT_TYPE, p_BILLING_STATEMENT.CHARGE_ID, p_COMPONENT, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE);
	    END IF;
	ELSIF v_RATE_STRUCTURE = 'TIME OF USE' THEN
	    IF UPPER(p_COMPONENT.CHARGE_TYPE) = 'TRANSMISSION' THEN
		    p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'TRANSMISSION';
			PSE_TOU_TRANSMISSION(p_CONTRACT_ID, p_SCHEDULE_TYPE, p_STATEMENT_TYPE, p_BILLING_STATEMENT.CHARGE_ID, p_COMPONENT, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE);
	    ELSIF UPPER(p_COMPONENT.CHARGE_TYPE) IN ('ENERGY','CAPACITY','GAS') THEN
		    p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'BILLING CHARGE';
			PSE_TOU_CHARGE(p_CONTRACT_ID, p_SCHEDULE_TYPE, p_STATEMENT_TYPE, p_BILLING_STATEMENT.CHARGE_ID, p_COMPONENT, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE);
	    END IF;
	ELSIF v_RATE_STRUCTURE = 'LMP' THEN
    	IF UPPER(p_COMPONENT.CHARGE_TYPE) = 'FTR ALLOCATION' THEN
		    p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'FTR ALLOC';
            PSE_FTR_ALLOCATION(p_BILLING_STATEMENT.ENTITY_ID, p_CONTRACT_ID, p_SCHEDULE_TYPE, p_STATEMENT_TYPE, p_BILLING_STATEMENT.CHARGE_ID, p_COMPONENT, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE);
    	ELSIF UPPER(p_COMPONENT.CHARGE_TYPE) = 'COMMODITY' THEN
        	IF NVL(p_COMPONENT.LMP_BASE_COMMODITY_ID,0) = 0 THEN
            	p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'LMP1';
            ELSE -- there is a base component
            	p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'LMP2';
            END IF;
			IF NVL(UPPER(p_COMPONENT.ALTERNATE_PRICE),'NONE') <> 'NONE' THEN
				-- have to show two prices in details, so change charge view type
				p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := p_BILLING_STATEMENT.CHARGE_VIEW_TYPE||'B';
			END IF;
            PSE_LMP_COMMODITY_CHARGE(p_CONTRACT_ID, p_SCHEDULE_TYPE, p_STATEMENT_TYPE, p_BILLING_STATEMENT.CHARGE_ID, p_COMPONENT, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE);
    	ELSIF UPPER(p_COMPONENT.CHARGE_TYPE) = 'ENERGY' THEN
        	IF UPPER(p_COMPONENT.MARKET_TYPE) = UPPER(g_DAY_AHEAD) THEN
            	p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'LMP1';
            ELSE -- REAL-TIME
            	p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'LMP2';
            END IF;
			IF UPPER(p_COMPONENT.LMP_PRICE_CALC) = UPPER(g_LMP_ACT_MINUS_AVG_PRICE) THEN
				-- have to show two prices in details, so change charge view type
				p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := p_BILLING_STATEMENT.CHARGE_VIEW_TYPE||'B';
			END IF;
            PSE_LMP_ENERGY_CHARGE(0,0,p_CONTRACT_ID, p_SCHEDULE_TYPE, p_STATEMENT_TYPE, p_BILLING_STATEMENT.CHARGE_ID, p_COMPONENT, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE);
        ELSIF UPPER(p_COMPONENT.CHARGE_TYPE) = 'VIRTUAL ENERGY' THEN
        	p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'LMP3';
			IF UPPER(p_COMPONENT.LMP_PRICE_CALC) = UPPER(g_LMP_ACT_MINUS_AVG_PRICE) THEN
				-- have to show two prices in details, so change charge view type
				p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := p_BILLING_STATEMENT.CHARGE_VIEW_TYPE||'B';
			END IF;
            PSE_LMP_ENERGY_CHARGE(0,1,p_CONTRACT_ID, p_SCHEDULE_TYPE, p_STATEMENT_TYPE, p_BILLING_STATEMENT.CHARGE_ID, p_COMPONENT, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE);
        ELSIF UPPER(p_COMPONENT.CHARGE_TYPE) = 'BILATERALS' THEN
        	IF UPPER(p_COMPONENT.MARKET_TYPE) = UPPER(g_DAY_AHEAD) THEN
            	p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'LMP4';
            ELSE -- REAL-TIME
            	p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'LMP5';
            END IF;
            PSE_LMP_BILATERAL_CHARGE(p_CONTRACT_ID, p_SCHEDULE_TYPE, p_STATEMENT_TYPE, p_BILLING_STATEMENT.CHARGE_ID, p_COMPONENT, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE);
        ELSIF UPPER(p_COMPONENT.CHARGE_TYPE) = 'EXPORTS/IMPORTS' THEN
        	IF UPPER(p_COMPONENT.MARKET_TYPE) = UPPER(g_DAY_AHEAD) THEN
            	p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'LMP6';
            ELSE -- REAL-TIME
            	p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'LMP7';
            END IF;
			IF UPPER(p_COMPONENT.LMP_PRICE_CALC) = UPPER(g_LMP_ACT_MINUS_AVG_PRICE) THEN
				-- have to show two prices in details, so change charge view type
				p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := p_BILLING_STATEMENT.CHARGE_VIEW_TYPE||'B';
			END IF;
            PSE_LMP_ENERGY_CHARGE(1,0,p_CONTRACT_ID, p_SCHEDULE_TYPE, p_STATEMENT_TYPE, p_BILLING_STATEMENT.CHARGE_ID, p_COMPONENT, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE);
        END IF;
	ELSIF v_RATE_STRUCTURE = 'ENTITY ATTRIBUTE' THEN
	    p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'ENTITY ATTRIBUTE';
		PSE_ENTITY_ATTRIBUTE(p_BILLING_STATEMENT.ENTITY_ID, p_SCHEDULE_TYPE, p_STATEMENT_TYPE, p_BILLING_STATEMENT.CHARGE_ID, p_COMPONENT, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE);
	ELSIF v_RATE_STRUCTURE = 'COINCIDENT PEAK SHARE' THEN
	    p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'COINCIDENT PEAK';
		PSE_COINCIDENT_PEAK_SHARE(p_BILLING_STATEMENT.ENTITY_ID, p_SCHEDULE_TYPE, p_STATEMENT_TYPE, p_BILLING_STATEMENT.CHARGE_ID, p_COMPONENT, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE);
    ELSIF v_RATE_STRUCTURE = 'FORMULA' THEN
	    p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'FORMULA';
    	PSE_FORMULA_CHARGE(p_PSE_GROUP, p_BILLING_STATEMENT.ENTITY_ID, p_CONTRACT_ID, p_BILLING_STATEMENT.PRODUCT_ID, p_SCHEDULE_TYPE, p_STATEMENT_TYPE, p_BILLING_STATEMENT.CHARGE_ID, p_COMPONENT, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE, p_WEEK_BEGIN);
	ELSIF v_RATE_STRUCTURE = 'COMBINATION' THEN
	    p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'COMBINATION';
    	PSE_COMBINATION_CHARGE(p_PSE_GROUP, p_BILLING_STATEMENT, p_CONTRACT_ID, p_SCHEDULE_TYPE, p_STATEMENT_TYPE, p_COMPONENT, p_BILLING_STATEMENT.CHARGE_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE, p_WEEK_BEGIN);
	ELSE --IF v_RATE_STRUCTURE = 'EXTERNAL' THEN
		p_BILLING_STATEMENT.CHARGE_VIEW_TYPE := 'EXTERNAL';
		XS.COMPUTE_COMPONENT_CHARGES(p_CONTRACT_ID, p_SCHEDULE_TYPE, p_STATEMENT_TYPE, p_BILLING_STATEMENT.CHARGE_ID, p_COMPONENT, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE, p_BILLING_STATEMENT.ENTITY_ID);
	END IF;

END PSE_BILLING_STATEMENT_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_BILLING_STATEMENT_REQUEST
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_PSE_IDs IN NUMBER_COLLECTION,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_GENERATE_INVOICE IN NUMBER,
	p_TRACE_ON IN NUMBER,
	p_PROCESS_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

v_CONTRACT_ID NUMBER(9);
v_COMPONENT COMPONENT%ROWTYPE;
v_BILLING_STATEMENT BILLING_STATEMENT%ROWTYPE;
v_ELASPSED PLS_INTEGER;
v_COMPONENT_COUNT NUMBER := 0;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_END_LOOP_DATE DATE;
v_INPUT_AS_OF_DATE DATE;
v_MIN_DATE DATE := p_BEGIN_DATE;
v_HAVE_PUT_ROW BOOLEAN := FALSE;
v_CHARGE_BEGIN DATE;
v_CHARGE_END DATE;
v_SKIP_CHARGE BOOLEAN := FALSE;
v_WHEN VARCHAR2(32);
v_PSE_GROUP VARCHAR2(64);
v_WRITE_BILLING_STATEMENT BOOLEAN;
v_PRIOR_CHARGE_ID NUMBER;

CURSOR c_STATEMENTS IS
    SELECT DISTINCT -1 "PSE_ID",
		GET_BILL_CALC_GROUP(A.BILLING_ENTITY_ID, p_BEGIN_DATE) "PSE_GROUP_NAME",
		NVL(E.STATEMENT_INTERVAL,'Month') "STATEMENT_INTERVAL",
        NVL(E.WEEK_BEGIN,'First of Month') "WEEK_BEGIN",
        NVL(E.TIME_ZONE,GA.LOCAL_TIME_ZONE) "TIME_ZONE"
	FROM INTERCHANGE_CONTRACT A,
		PURCHASING_SELLING_ENTITY E,
		TABLE(CAST(p_PSE_IDs AS NUMBER_COLLECTION)) F
	WHERE (F.COLUMN_VALUE = SD.g_ALL_DATA_ENTITY_ID OR A.BILLING_ENTITY_ID = F.COLUMN_VALUE)
		AND (NVL(A.IS_EVERGREEN,0)=1
			OR (NVL(A.BEGIN_DATE, p_BEGIN_DATE) <= p_END_DATE
    			AND NVL(A.END_DATE, p_END_DATE) >= p_BEGIN_DATE))
        AND UPPER(A.CONTRACT_STATUS) <> 'INACTIVE'
		AND E.PSE_ID = A.BILLING_ENTITY_ID
		AND E.PSE_ID > 0
		AND UPPER(E.PSE_STATUS) <> 'INACTIVE'
		AND NVL(GET_BILL_CALC_GROUP(A.BILLING_ENTITY_ID, p_BEGIN_DATE),'?') <> '?'
	UNION
    SELECT A.BILLING_ENTITY_ID "PSE_ID",
		E.PSE_NAME "PSE_GROUP_NAME",
		NVL(E.STATEMENT_INTERVAL,'Month') "STATEMENT_INTERVAL",
        NVL(E.WEEK_BEGIN,'First of Month') "WEEK_BEGIN",
        NVL(E.TIME_ZONE,GA.LOCAL_TIME_ZONE) "TIME_ZONE"
	FROM INTERCHANGE_CONTRACT A,
		PURCHASING_SELLING_ENTITY E,
		TABLE(CAST(p_PSE_IDs AS NUMBER_COLLECTION)) F
	WHERE (F.COLUMN_VALUE = SD.g_ALL_DATA_ENTITY_ID OR A.BILLING_ENTITY_ID = F.COLUMN_VALUE)
		AND (NVL(A.IS_EVERGREEN,0)=1
			OR (NVL(A.BEGIN_DATE, p_BEGIN_DATE) <= p_END_DATE
    			AND NVL(A.END_DATE, p_END_DATE) >= p_BEGIN_DATE))
        AND UPPER(A.CONTRACT_STATUS) <> 'INACTIVE'
		AND E.PSE_ID = A.BILLING_ENTITY_ID
		AND E.PSE_ID > 0
		AND UPPER(E.PSE_STATUS) <> 'INACTIVE'
		AND NVL(GET_BILL_CALC_GROUP(A.BILLING_ENTITY_ID, p_BEGIN_DATE),'?') = '?'
	ORDER BY 1, 2, 3, 4, 5;

CURSOR c_CHARGES(p_BEGIN_DATE IN DATE, p_END_DATE IN DATE, p_PSE_ID IN NUMBER, p_PSE_GROUP_NAME IN VARCHAR2) IS
    SELECT DISTINCT B.PRODUCT_ID, B.COMPONENT_ID,
        NVL(C.WHICH_INTERVAL,'Last') "WHICH_INTERVAL",
    	DECODE(UPPER(C.CHARGE_TYPE),'TAX',1,0) "IS_TAX",
		DECODE(UPPER(C.RATE_STRUCTURE),'EXTERNAL',1,0) "IS_EXTERNAL",
        C.COMPUTATION_ORDER
	FROM INTERCHANGE_CONTRACT A,
	    CONTRACT_PRODUCT_COMPONENT B,
		COMPONENT C,
		PRODUCT_COMPONENT D,
		PURCHASING_SELLING_ENTITY E,
		TABLE(CAST(p_PSE_IDs AS NUMBER_COLLECTION)) F
	WHERE (F.COLUMN_VALUE = SD.g_ALL_DATA_ENTITY_ID OR A.BILLING_ENTITY_ID = F.COLUMN_VALUE)
		AND (A.BILLING_ENTITY_ID = p_PSE_ID
			OR (p_PSE_ID = -1 AND NVL(GET_BILL_CALC_GROUP(A.BILLING_ENTITY_ID, p_BEGIN_DATE),'?') = p_PSE_GROUP_NAME))
		AND (NVL(A.IS_EVERGREEN,0)=1
			OR (NVL(A.BEGIN_DATE, p_BEGIN_DATE) <= p_END_DATE
    			AND NVL(A.END_DATE, p_END_DATE) >= p_BEGIN_DATE))
        AND UPPER(A.CONTRACT_STATUS) <> 'INACTIVE'
		AND B.CONTRACT_ID = A.CONTRACT_ID
		AND (p_PRODUCT_ID = g_ALL OR B.PRODUCT_ID = p_PRODUCT_ID)
		AND (p_COMPONENT_ID = g_ALL OR B.COMPONENT_ID = p_COMPONENT_ID)
		AND B.BEGIN_DATE <= p_END_DATE
		AND NVL(B.END_DATE, p_END_DATE) >= p_BEGIN_DATE
		AND C.COMPONENT_ID = B.COMPONENT_ID
		AND D.PRODUCT_ID = B.PRODUCT_ID
		AND D.COMPONENT_ID = B.COMPONENT_ID
		AND D.BEGIN_DATE <= p_END_DATE
		AND NVL(D.END_DATE, p_END_DATE) >= p_BEGIN_DATE
		AND E.PSE_ID = A.BILLING_ENTITY_ID
		AND E.PSE_ID > 0
		AND UPPER(E.PSE_STATUS) <> 'INACTIVE'
		-- now make sure that all date ranges agree
		AND GREATEST(p_BEGIN_DATE,
				CASE WHEN A.IS_EVERGREEN=1 THEN p_BEGIN_DATE ELSE A.BEGIN_DATE END,
				B.BEGIN_DATE,
				D.BEGIN_DATE) <=
    		LEAST(p_END_DATE,
    				CASE WHEN A.IS_EVERGREEN=1 THEN p_END_DATE ELSE NVL(A.END_DATE,p_END_DATE) END,
    				NVL(B.END_DATE,p_END_DATE),
    				NVL(D.END_DATE,p_END_DATE))
	ORDER BY DECODE(UPPER(C.CHARGE_TYPE),'TAX',1,0),
		DECODE(UPPER(C.RATE_STRUCTURE),'EXTERNAL',1,0),
        C.COMPUTATION_ORDER;
	-- order by clauses force internal charges to be computed before external charges, and all
	-- non-tax charges to be computed before tax charges

CURSOR c_PSEs(p_BEGIN_DATE IN DATE, p_END_DATE IN DATE, p_PSE_ID IN NUMBER, p_PSE_GROUP_NAME IN VARCHAR2,
			  p_PRODUCT_ID IN NUMBER, p_COMPONENT_ID IN NUMBER) IS
    SELECT A.CONTRACT_ID, E.PSE_ID, E.PSE_NAME,
		GREATEST(CASE WHEN A.IS_EVERGREEN=1 THEN LOW_DATE ELSE A.BEGIN_DATE END,
				B.BEGIN_DATE,
				D.BEGIN_DATE) "BEGIN_DATE",
		LEAST(CASE WHEN A.IS_EVERGREEN=1 THEN HIGH_DATE ELSE NVL(A.END_DATE,HIGH_DATE) END,
				NVL(B.END_DATE,p_END_DATE),
				NVL(D.END_DATE,p_END_DATE)) "END_DATE"
	FROM INTERCHANGE_CONTRACT A,
	    CONTRACT_PRODUCT_COMPONENT B,
		COMPONENT C,
		PRODUCT_COMPONENT D,
		PURCHASING_SELLING_ENTITY E,
		TABLE(CAST(p_PSE_IDs AS NUMBER_COLLECTION)) F
	WHERE (F.COLUMN_VALUE = SD.g_ALL_DATA_ENTITY_ID OR A.BILLING_ENTITY_ID = F.COLUMN_VALUE)
		AND (A.BILLING_ENTITY_ID = p_PSE_ID
			OR (p_PSE_ID = -1 AND NVL(GET_BILL_CALC_GROUP(A.BILLING_ENTITY_ID, p_BEGIN_DATE),'?') = p_PSE_GROUP_NAME))
		AND (NVL(A.IS_EVERGREEN,0)=1
			OR (NVL(A.BEGIN_DATE, p_BEGIN_DATE) <= p_END_DATE
    			AND NVL(A.END_DATE, p_END_DATE) >= p_BEGIN_DATE))
        AND UPPER(A.CONTRACT_STATUS) <> 'INACTIVE'
		AND B.CONTRACT_ID = A.CONTRACT_ID
		AND B.PRODUCT_ID = p_PRODUCT_ID
		AND B.COMPONENT_ID = p_COMPONENT_ID
		AND B.BEGIN_DATE <= p_END_DATE
		AND NVL(B.END_DATE, p_END_DATE) >= p_BEGIN_DATE
		AND C.COMPONENT_ID = B.COMPONENT_ID
		AND D.PRODUCT_ID = B.PRODUCT_ID
		AND D.COMPONENT_ID = B.COMPONENT_ID
		AND D.BEGIN_DATE <= p_END_DATE
		AND NVL(D.END_DATE, p_END_DATE) >= p_BEGIN_DATE
		AND E.PSE_ID = A.BILLING_ENTITY_ID
		AND E.PSE_ID > 0
		AND UPPER(E.PSE_STATUS) <> 'INACTIVE'
		-- now make sure that all date ranges agree
		AND GREATEST(p_BEGIN_DATE,
				CASE WHEN A.IS_EVERGREEN=1 THEN p_BEGIN_DATE ELSE A.BEGIN_DATE END,
				B.BEGIN_DATE,
				D.BEGIN_DATE) <=
    		LEAST(p_END_DATE,
    				CASE WHEN A.IS_EVERGREEN=1 THEN p_END_DATE ELSE NVL(A.END_DATE,p_END_DATE) END,
    				NVL(B.END_DATE,p_END_DATE),
    				NVL(D.END_DATE,p_END_DATE))
	ORDER BY A.BILLING_ENTITY_ID;
	-- order by clauses force internal charges to be computed before external charges, and all
	-- non-tax charges to be computed before tax charges

BEGIN
	SAVEPOINT BEFORE_BILL_CALC;

	LOGS.START_PROCESS('Calculate Billing Statements', p_BEGIN_DATE, p_END_DATE, p_TRACE_ON => p_TRACE_ON);

	LOGS.SET_PROCESS_TARGET_PARAMETER('PSE_ID', TEXT_UTIL.TO_CHAR_ENTITY_LIST(p_PSE_IDs, EC.ED_PSE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('SCHEDULE_TYPE', TEXT_UTIL.TO_CHAR_ENTITY(p_SCHEDULE_TYPE, EC.ED_STATEMENT_TYPE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('STATEMENT_TYPE', TEXT_UTIL.TO_CHAR_ENTITY(p_STATEMENT_TYPE, EC.ED_STATEMENT_TYPE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('INPUT_AS_OF_DATE', TEXT_UTIL.TO_CHAR_TIME(v_INPUT_AS_OF_DATE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('OUTPUT_AS_OF_DATE', TEXT_UTIL.TO_CHAR_TIME(p_OUTPUT_AS_OF_DATE));

	v_INPUT_AS_OF_DATE := CORRECTED_AS_OF_DATE(p_INPUT_AS_OF_DATE);
	g_ACCOUNT_PEAK_AND_ENERGY.DELETE;

	--THIS CALL IS OUT OF DATE AND NO LONGER NEEDED SAYS JOSH
	--SELECT DECODE(p_SCHEDULE_TYPE, 1, 'F', 2, 'B', 'A') INTO v_REQUEST_TYPE FROM DUAL;
	--POST_MARKET_PRICE_REQUEST(p_CALLING_MODULE, p_MODEL_ID, v_REQUEST_TYPE, p_SCHEDULE_TYPE, p_BEGIN_DATE, p_END_DATE, v_INPUT_AS_OF_DATE, p_OUTPUT_AS_OF_DATE, 0, p_STATUS, p_MESSAGE);

	IF GA.ENABLE_SUPPLY_SCHEDULE_TYPES THEN
		g_ENABLE_SUPPLY_SCHEDULE_TYPES := 1;
	ELSE
		g_ENABLE_SUPPLY_SCHEDULE_TYPES := 0;
	END IF;

	v_END_LOOP_DATE := TRUNC(p_END_DATE);

	-- loop through all entities for which we are computing statements
	FOR v_STATEMENT IN c_STATEMENTS LOOP
		v_BEGIN_DATE := BEGIN_DATE_FOR_INTERVAL(p_BEGIN_DATE, v_STATEMENT.STATEMENT_INTERVAL, v_STATEMENT.PSE_ID, v_STATEMENT.WEEK_BEGIN);
        IF v_BEGIN_DATE < v_MIN_DATE THEN
        	v_MIN_DATE := v_BEGIN_DATE;
		END IF;

        IF v_STATEMENT.PSE_ID = -1 THEN
            v_PSE_GROUP := v_STATEMENT.PSE_GROUP_NAME;
        ELSE
            v_PSE_GROUP := NULL;
        END IF;

		IF LOGS.IS_INFO_DETAIL_ENABLED THEN
			IF v_STATEMENT.PSE_ID = -1 THEN
		        LOGS.LOG_INFO_DETAIL('Calculating bills for Bill Calculation Group = '||v_STATEMENT.PSE_GROUP_NAME);
			ELSE
		        LOGS.LOG_INFO_DETAIL('Calculating bills for PSE = '||v_STATEMENT.PSE_GROUP_NAME);
			END IF;
		END IF;

		-- now loop through all statement dates in the specified date range for this entity
		WHILE v_BEGIN_DATE <= v_END_LOOP_DATE LOOP
			v_HAVE_PUT_ROW := FALSE;
			v_END_DATE := END_DATE_FOR_INTERVAL(v_BEGIN_DATE, v_STATEMENT.STATEMENT_INTERVAL, v_STATEMENT.PSE_ID, v_STATEMENT.WEEK_BEGIN);

			IF LOGS.IS_INFO_DETAIL_ENABLED THEN
                LOGS.LOG_INFO_DETAIL('Calculating statement for '||TO_CHAR(v_BEGIN_DATE,'mm/dd/yyyy')||' through '||TO_CHAR(v_END_DATE,'mm/dd/yyyy'));
			END IF;

            -- clean-up existing statements prior to re-calc
			IF v_STATEMENT.PSE_ID = -1 THEN
    	    	DELETE BILLING_STATEMENT
    	    	WHERE ENTITY_ID IN (SELECT PSE_ID
									FROM PURCHASING_SELLING_ENTITY A,
										TABLE(CAST(p_PSE_IDs AS NUMBER_COLLECTION)) B
									WHERE (B.COLUMN_VALUE = SD.g_ALL_DATA_ENTITY_ID OR A.PSE_ID = B.COLUMN_VALUE)
										AND NVL(GET_BILL_CALC_GROUP(A.PSE_ID, p_BEGIN_DATE),'?') = v_STATEMENT.PSE_GROUP_NAME)
    	    		AND STATEMENT_TYPE = p_STATEMENT_TYPE
    	    		AND STATEMENT_STATE = GA.INTERNAL_STATE
    	    		AND STATEMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
					AND p_PRODUCT_ID IN (g_ALL, PRODUCT_ID)
					AND p_COMPONENT_ID IN (g_ALL, COMPONENT_ID)
    	    		AND AS_OF_DATE = p_OUTPUT_AS_OF_DATE;
			ELSE
    	    	DELETE BILLING_STATEMENT
    	    	WHERE ENTITY_ID =  v_STATEMENT.PSE_ID
    	    		AND STATEMENT_TYPE = p_STATEMENT_TYPE
    	    		AND STATEMENT_STATE = GA.INTERNAL_STATE
    	    		AND STATEMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
					AND p_PRODUCT_ID IN (g_ALL, PRODUCT_ID)
					AND p_COMPONENT_ID IN (g_ALL, COMPONENT_ID)
    	    		AND AS_OF_DATE = p_OUTPUT_AS_OF_DATE;
			END IF;
	    	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    	    LOGS.LOG_INFO_DETAIL('Deleted '||SQL%ROWCOUNT||' old row(s) from BILLING_STATEMENT');
	    	END IF;

			COMMIT;
			-- immediately re-establish savepoint
			SAVEPOINT BEFORE_BILL_CALC;


            -- if end date less than begin date, it is because a Custom interval was
            -- specified, but no interval data for given day - so skip it in that case
            IF v_END_DATE >= v_BEGIN_DATE THEN

    			-- loop through all components for this statement
    			FOR v_CHARGE IN c_CHARGES(v_BEGIN_DATE, v_END_DATE, v_STATEMENT.PSE_ID, v_STATEMENT.PSE_GROUP_NAME) LOOP

        			v_COMPONENT := GET_COMPONENT(v_CHARGE.COMPONENT_ID);
        			IF LOGS.IS_INFO_DETAIL_ENABLED THEN
                        LOGS.LOG_INFO_DETAIL('Calculating Component = '||v_COMPONENT.COMPONENT_NAME);
        			END IF;

        			v_BILLING_STATEMENT.ENTITY_TYPE := 'PSE';
        			v_BILLING_STATEMENT.PRODUCT_ID := v_CHARGE.PRODUCT_ID;
        			v_BILLING_STATEMENT.COMPONENT_ID := v_CHARGE.COMPONENT_ID;
        			v_BILLING_STATEMENT.STATEMENT_TYPE := p_STATEMENT_TYPE;
        			v_BILLING_STATEMENT.STATEMENT_STATE := GA.INTERNAL_STATE;
        			v_BILLING_STATEMENT.STATEMENT_DATE := v_BEGIN_DATE;
                    v_BILLING_STATEMENT.STATEMENT_END_DATE := v_END_DATE;
        			v_BILLING_STATEMENT.AS_OF_DATE := p_OUTPUT_AS_OF_DATE;
        			v_BILLING_STATEMENT.BASIS_AS_OF_DATE := v_INPUT_AS_OF_DATE;
        			v_BILLING_STATEMENT.CHARGE_INTERVAL := v_COMPONENT.RATE_INTERVAL;

                	-- if charge interval is greater than statement interval, then this
                    -- charge should only show up on first or last statement of charge
                    -- interval (i.e. monthly charge should show up on 1st or last day
                    -- of month when statement interval is daily)
					v_SKIP_CHARGE := FALSE;
	                IF DATE_UTIL.INTERVAL_ORD(v_COMPONENT.RATE_INTERVAL) > DATE_UTIL.INTERVAL_ORD(v_STATEMENT.STATEMENT_INTERVAL) THEN
                    	v_CHARGE_BEGIN := BEGIN_DATE_FOR_INTERVAL(v_BEGIN_DATE, v_COMPONENT.RATE_INTERVAL, v_STATEMENT.PSE_ID, v_STATEMENT.WEEK_BEGIN);
                        v_CHARGE_END := END_DATE_FOR_INTERVAL(v_CHARGE_BEGIN, v_COMPONENT.RATE_INTERVAL, v_STATEMENT.PSE_ID, v_STATEMENT.WEEK_BEGIN);
                        v_WHEN := UPPER(v_CHARGE.WHICH_INTERVAL);
                        IF v_WHEN = 'FIRST' THEN
                        	v_SKIP_CHARGE := v_BEGIN_DATE > v_CHARGE_BEGIN;
                        ELSIF v_WHEN = 'LAST' THEN
                        	v_SKIP_CHARGE := v_END_DATE < v_CHARGE_END;
						END IF;
					ELSE
						v_CHARGE_BEGIN := v_BEGIN_DATE;
						v_CHARGE_END := v_END_DATE;
	                END IF;

                    -- perform charge calculations
                    IF NOT v_SKIP_CHARGE THEN
						FOR v_PSE IN c_PSEs(v_BEGIN_DATE, v_END_DATE, v_STATEMENT.PSE_ID, v_STATEMENT.PSE_GROUP_NAME, v_CHARGE.PRODUCT_ID, v_CHARGE.COMPONENT_ID) LOOP
                    		IF LOGS.IS_INFO_DETAIL_ENABLED AND v_STATEMENT.PSE_ID = -1 THEN
                   		        LOGS.LOG_INFO_DETAIL('Calculating bills for PSE = '||v_PSE.PSE_NAME);
                    		END IF;

    						v_CHARGE_BEGIN := GREATEST(v_CHARGE_BEGIN, v_PSE.BEGIN_DATE);
    						v_CHARGE_END := LEAST(v_CHARGE_END, v_PSE.END_DATE);

                			v_CONTRACT_ID := v_PSE.CONTRACT_ID;
                			v_BILLING_STATEMENT.ENTITY_ID := v_PSE.PSE_ID;

                			GET_CHARGE_ID(v_BILLING_STATEMENT);

                			v_BILLING_STATEMENT.CHARGE_QUANTITY := 0;
                			v_BILLING_STATEMENT.CHARGE_RATE := 0;
                			v_BILLING_STATEMENT.CHARGE_AMOUNT := 0;
                			v_BILLING_STATEMENT.BILL_QUANTITY := 0;
                			v_BILLING_STATEMENT.BILL_AMOUNT := 0;

                			PUT_BILLING_STATEMENT (v_BILLING_STATEMENT);
        					v_HAVE_PUT_ROW := TRUE;

                			IF LOGS.IS_DEBUG_ENABLED THEN
                				LOGS.LOG_DEBUG('PSE_ID=' || TO_CHAR(v_PSE.PSE_ID));
                				LOGS.LOG_DEBUG('PRODUCT_ID=' || TO_CHAR(v_CHARGE.PRODUCT_ID));
                				LOGS.LOG_DEBUG('COMPONENT_ID=' || TO_CHAR(v_CHARGE.COMPONENT_ID));
                				LOGS.LOG_DEBUG('CHARGE_INTERVAL=' || v_COMPONENT.RATE_INTERVAL);
                				LOGS.LOG_DEBUG('RATE_STRUCTURE=' || v_COMPONENT.RATE_STRUCTURE);
                			END IF;

            				g_COMPONENT_HISTORY.DELETE; -- clear stack

    	    				PSE_BILLING_STATEMENT_CHARGE(v_BILLING_STATEMENT, v_CONTRACT_ID, p_SCHEDULE_TYPE,
								p_STATEMENT_TYPE, v_COMPONENT, v_CHARGE_BEGIN, v_CHARGE_END, v_INPUT_AS_OF_DATE,
								v_STATEMENT.TIME_ZONE, v_STATEMENT.WEEK_BEGIN, v_PSE_GROUP);

                            GET_BILLING_STATEMENT_CHARGES(v_BILLING_STATEMENT, v_WRITE_BILLING_STATEMENT);
                            IF v_WRITE_BILLING_STATEMENT THEN
                                v_PRIOR_CHARGE_ID := GET_PRIOR_CHARGE_ID(v_BILLING_STATEMENT);
                                PRIOR_BILLING_STATEMENT(v_PRIOR_CHARGE_ID, v_BILLING_STATEMENT);
                                PUT_BILLING_STATEMENT(v_BILLING_STATEMENT);
                            ELSE
                                g_DELETING_TEMP_ROW := TRUE;
                                DELETE BILLING_STATEMENT WHERE CHARGE_ID = v_BILLING_STATEMENT.CHARGE_ID;
                                g_DELETING_TEMP_ROW := FALSE;
                            END IF;

                            COMMIT;
							-- immediately re-establish savepoint
							SAVEPOINT BEFORE_BILL_CALC;

			                v_COMPONENT_COUNT := v_COMPONENT_COUNT + 1;

						END LOOP;
					END IF;
				END LOOP;

    			v_BEGIN_DATE := v_END_DATE + 1;
			ELSE
            	-- no custom interval available? try next day
            	v_BEGIN_DATE := v_BEGIN_DATE + 1;
			END IF;
		END LOOP;
	END LOOP;

	IF p_GENERATE_INVOICE = 1 THEN
		-- regenerate all invoices in range
		GENERATE_INVOICES(p_PSE_IDs, g_PSE, p_STATEMENT_TYPE, p_BEGIN_DATE, p_END_DATE, p_OUTPUT_AS_OF_DATE);
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		v_ELASPSED := DBMS_UTILITY.GET_TIME - v_ELASPSED;
		LOGS.LOG_DEBUG('COMPONENT COUNT=' || TO_CHAR(v_COMPONENT_COUNT));
		LOGS.LOG_DEBUG('BILLING_STATEMENT_REQUEST END AT ' || TEXT_UTIL.TO_CHAR_TIME(SYSDATE));
		LOGS.LOG_DEBUG('ELAPSED TIME=' || TO_CHAR(v_ELASPSED));
 	END IF;

	IF g_DO_NET_POSITION THEN
		NET_RETAIL_PROFIT_AND_LOSS(p_SCHEDULE_TYPE, p_STATEMENT_TYPE, p_BEGIN_DATE, p_END_DATE, v_INPUT_AS_OF_DATE, p_OUTPUT_AS_OF_DATE);
	END IF;

	-- finally, update the IN_DISPUTE flag for rows that have dispute information
	UPDATE_DISPUTE_FLAGS (p_PSE_IDs, v_MIN_DATE, v_END_LOOP_DATE, p_STATEMENT_TYPE);

	LOGS.STOP_PROCESS(p_MESSAGE, p_PROCESS_STATUS);
	COMMIT;

EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			g_DELETING_TEMP_ROW := FALSE;
			IF v_HAVE_PUT_ROW THEN
				PUT_BILLING_STATEMENT_STATUS(v_BILLING_STATEMENT, g_STATUS_ERROR);
			END IF;
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE;
		END;
		ERRS.ABORT_PROCESS(p_SAVEPOINT_NAME => 'BEFORE_BILL_CALC');
END PSE_BILLING_STATEMENT_REQUEST;
---------------------------------------------------------------------------------------------------
PROCEDURE BILLING_STATEMENT_REQUEST_E
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_GENERATE_INVOICE IN NUMBER,
	p_TRACE_ON IN NUMBER,
	p_PROCESS_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS
v_PSE_IDs NUMBER_COLLECTION := NUMBER_COLLECTION(p_PSE_ID);
BEGIN
	IF p_PSE_ID = g_ALL THEN
		v_PSE_IDs := NULL;
	END IF;

	BILLING_STATEMENT_REQUEST(p_CALLING_MODULE, p_MODEL_ID, v_PSE_IDs,
							p_PRODUCT_ID, p_COMPONENT_ID,
							p_SCHEDULE_TYPE, p_STATEMENT_TYPE,
							p_BEGIN_DATE, p_END_DATE,
							p_INPUT_AS_OF_DATE, p_OUTPUT_AS_OF_DATE,
							p_GENERATE_INVOICE, p_TRACE_ON,
							p_PROCESS_STATUS, p_MESSAGE);
END BILLING_STATEMENT_REQUEST_E;
---------------------------------------------------------------------------------------------------
PROCEDURE BILLING_STATEMENT_REQUEST
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_PSE_IDS IN NUMBER_COLLECTION,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_GENERATE_INVOICE IN NUMBER,
	p_TRACE_ON IN NUMBER,
	p_PROCESS_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

	v_PRODUCT_ID NUMBER(9) := NVL(p_PRODUCT_ID, g_ALL);
	v_COMPONENT_ID NUMBER(9) := NVL(p_COMPONENT_ID, g_ALL);
	v_VALID_IDs ID_TABLE;
	v_PSE_IDs NUMBER_COLLECTION := NUMBER_COLLECTION();
	v_IDX BINARY_INTEGER;
	v_TRACE_ON NUMBER(1) := NVL(p_TRACE_ON, 0);
	v_INPUT_AS_OF_DATE DATE := NVL(p_INPUT_AS_OF_DATE, CURRENT_VERSION_DATE);
	v_OUTPUT_AS_OF_DATE DATE := NVL(p_OUTPUT_AS_OF_DATE, LOW_DATE);

	--Schedule Type is the "input" type, while Statement Type is the "output" type.
	--For now, we will make them always be the same.  We may later decide to add another
	--dropdown from Data Exchange to specify Input vs. Output.
	v_SCHEDULE_TYPE NUMBER(9) := p_STATEMENT_TYPE;
BEGIN

	IF p_PSE_IDs IS NULL THEN
		-- no IDs specified? run for all
		v_VALID_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_PSE_BILL_CALCULATE);
		v_IDX := v_VALID_IDs.FIRST;
		WHILE v_VALID_IDs.EXISTS(v_IDX) LOOP
			v_PSE_IDs.EXTEND();
			v_PSE_IDs(v_PSE_IDs.LAST) := v_VALID_IDs(v_IDX).ID;
			v_IDX := v_VALID_IDs.NEXT(v_IDX);
		END LOOP;
	ELSE
		-- IDs specified? make sure user actually has access
		v_IDX := p_PSE_IDs.FIRST;
		WHILE p_PSE_IDs.EXISTS(v_IDX) LOOP
			IF SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_PSE_BILL_CALCULATE,p_PSE_IDs(v_IDX)) THEN
				v_PSE_IDs.EXTEND();
				v_PSE_IDs(v_PSE_IDs.LAST) := p_PSE_IDs(v_IDX);
			END IF;
			v_IDX := p_PSE_IDs.NEXT(v_IDX);
		END LOOP;
	END IF;

    PSE_BILLING_STATEMENT_REQUEST(p_CALLING_MODULE, p_MODEL_ID, v_PSE_IDs,
								  v_PRODUCT_ID, v_COMPONENT_ID, v_SCHEDULE_TYPE, p_STATEMENT_TYPE,
								  p_BEGIN_DATE, p_END_DATE, v_INPUT_AS_OF_DATE, v_OUTPUT_AS_OF_DATE,
								  p_GENERATE_INVOICE, v_TRACE_ON, p_PROCESS_STATUS, p_MESSAGE);

END BILLING_STATEMENT_REQUEST;
---------------------------------------------------------------------------------------------------
PROCEDURE NET_RETAIL_POSITION_REQUEST
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_REQUEST_TYPE IN VARCHAR,
	p_STATEMENT_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_PROCESS_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

v_ELASPSED NUMBER;
v_COMPONENT COMPONENT%ROWTYPE;
v_BILLING_STATEMENT BILLING_STATEMENT%ROWTYPE;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_END_LOOP_DATE DATE;
v_WRITE_BILLING_STATEMENT BOOLEAN;
v_INPUT_AS_OF_DATE DATE;
v_PRIOR_CHARGE_ID NUMBER;
v_MIN_DATE DATE := p_BEGIN_DATE;
v_LAST_ENTITY_ID NUMBER(9) := -1;
v_VALID_IDs ID_TABLE;
v_STATUS NUMBER;
v_MESSAGE VARCHAR2(4000);

CURSOR c_IMBALANCE_COMPONENT IS
    SELECT A.CONTRACT_ID, A.BILLING_ENTITY_ID, C.PRODUCT_ID, C.COMPONENT_ID,
    	UPPER(SUBSTR(D.IMBALANCE_TYPE,1,1)) "IMBALANCE_TYPE",
        B.STATEMENT_INTERVAL, B.WEEK_BEGIN, B.TIME_ZONE
	FROM INTERCHANGE_CONTRACT A,
	    PURCHASING_SELLING_ENTITY B,
	    CONTRACT_PRODUCT_COMPONENT C,
		COMPONENT D,
		COMPONENT_IMBALANCE E,
		TABLE(CAST(v_VALID_IDs AS ID_TABLE)) F
	WHERE NVL(A.BEGIN_DATE, p_BEGIN_DATE) <= p_END_DATE
		AND NVL(A.END_DATE, p_END_DATE) >= p_BEGIN_DATE
		AND A.BILLING_ENTITY_ID = F.ID
		AND B.PSE_ID = A.BILLING_ENTITY_ID
		AND UPPER(SUBSTR(B.PSE_TYPE,1,1)) = 'M'
		AND B.PSE_IS_RETAIL_AGGREGATOR = 1
		AND C.CONTRACT_ID = A.CONTRACT_ID
		AND C.BEGIN_DATE <= p_END_DATE
		AND NVL(C.END_DATE, p_END_DATE) >= p_BEGIN_DATE
		AND D.COMPONENT_ID = C.COMPONENT_ID
		AND UPPER(D.RATE_STRUCTURE) = 'IMBALANCE'
		AND E.COMPONENT_ID = D.COMPONENT_ID
        AND E.SUB_COMPONENT_TYPE = g_NO_SUB_TYPE
        AND E.SUB_COMPONENT_ID = g_NOT_ASSIGNED
		AND UPPER(SUBSTR(D.IMBALANCE_TYPE,1,1)) IN ('N','S')
		AND E.BEGIN_DATE <= p_END_DATE
		AND NVL(E.END_DATE, p_END_DATE) >= p_BEGIN_DATE
	ORDER BY A.BILLING_ENTITY_ID;

BEGIN
	SAVEPOINT BEFORE_NET_POSITION_CALC;

	LOGS.START_PROCESS('Compute Net Retail Position', p_BEGIN_DATE, p_END_DATE,
						p_EVENT_LEVEL => LEAST(LOGS.CURRENT_LOG_LEVEL,
												 CASE p_TRACE_ON WHEN 1 THEN LOGS.c_LEVEL_DEBUG
												 				 WHEN 2 THEN LOGS.c_LEVEL_DEBUG_DETAIL
																 ELSE LOGS.c_LEVEL_FATAL
																 END));

	LOGS.SET_PROCESS_TARGET_PARAMETER('STATEMENT_TYPE', TEXT_UTIL.TO_CHAR_ENTITY(p_STATEMENT_TYPE, EC.ED_STATEMENT_TYPE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('INPUT_AS_OF_DATE', TEXT_UTIL.TO_CHAR_TIME(v_INPUT_AS_OF_DATE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('OUTPUT_AS_OF_DATE', TEXT_UTIL.TO_CHAR_TIME(p_OUTPUT_AS_OF_DATE));


	v_VALID_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_PSE_BILL_CALCULATE);

	v_INPUT_AS_OF_DATE := CORRECTED_AS_OF_DATE(p_INPUT_AS_OF_DATE);

	IF GA.ENABLE_SUPPLY_SCHEDULE_TYPES THEN
		g_ENABLE_SUPPLY_SCHEDULE_TYPES := 1;
	ELSE
		g_ENABLE_SUPPLY_SCHEDULE_TYPES := 0;
	END IF;

	IF p_REQUEST_TYPE IS NOT NULL THEN
		POST_MARKET_PRICE_REQUEST(p_CALLING_MODULE, p_MODEL_ID, p_REQUEST_TYPE, p_STATEMENT_TYPE, p_BEGIN_DATE, p_END_DATE, v_INPUT_AS_OF_DATE, p_OUTPUT_AS_OF_DATE, p_TRACE_ON, v_STATUS, v_MESSAGE);
		IF NVL(v_STATUS, GA.SUCCESS) <> GA.SUCCESS THEN
			LOGS.LOG_ERROR('POST_MARKET_PRICE_REQUEST indicates error status ('||v_STATUS||'): '||v_MESSAGE);
		END IF;
	END IF;

	v_END_LOOP_DATE := TRUNC(p_END_DATE);
	FOR v_IMBALANCE_COMPONENT IN c_IMBALANCE_COMPONENT LOOP
		v_BEGIN_DATE := BEGIN_DATE_FOR_INTERVAL(p_BEGIN_DATE, v_IMBALANCE_COMPONENT.STATEMENT_INTERVAL, v_IMBALANCE_COMPONENT.BILLING_ENTITY_ID, v_IMBALANCE_COMPONENT.WEEK_BEGIN);
        IF v_BEGIN_DATE < v_MIN_DATE THEN
        	v_MIN_DATE := v_BEGIN_DATE;
		END IF;
        -- first component for this entity? then delete this entity's statements
		IF v_LAST_ENTITY_ID <> v_IMBALANCE_COMPONENT.BILLING_ENTITY_ID THEN
	    	DELETE IMBALANCE_CHARGE A
	    	WHERE A.CHARGE_ID IN
	    			(SELECT DISTINCT X.CHARGE_ID
	    			FROM BILLING_STATEMENT X
	    			WHERE X.ENTITY_ID = v_IMBALANCE_COMPONENT.BILLING_ENTITY_ID
	    				AND X.PRODUCT_ID > 0
	    				AND X.COMPONENT_ID IN (SELECT DISTINCT COMPONENT_ID
                        						FROM COMPONENT
                                                WHERE UPPER(SUBSTR(IMBALANCE_TYPE,1,1)) IN ('N','S'))
	    				AND X.STATEMENT_TYPE = p_STATEMENT_TYPE
	                    AND X.STATEMENT_STATE = GA.INTERNAL_STATE
	    				AND X.STATEMENT_DATE BETWEEN v_BEGIN_DATE AND p_END_DATE
	    				AND X.AS_OF_DATE = p_OUTPUT_AS_OF_DATE);
	    	IF LOGS.IS_INFO_DETAIL_ENABLED THEN
	    	    LOGS.LOG_INFO_DETAIL('Deleted ' || SQL%ROWCOUNT || ' old row(s) from IMBALANCE_CHARGE');
	    	END IF;

	        COMMIT;
			-- immediately re-define savepoint
			SAVEPOINT BEFORE_NET_POSITION_CALC;

            v_LAST_ENTITY_ID := v_IMBALANCE_COMPONENT.BILLING_ENTITY_ID;
		END IF;

		WHILE v_BEGIN_DATE <= v_END_LOOP_DATE LOOP
			v_END_DATE := END_DATE_FOR_INTERVAL(v_BEGIN_DATE, v_IMBALANCE_COMPONENT.STATEMENT_INTERVAL, v_IMBALANCE_COMPONENT.BILLING_ENTITY_ID, v_IMBALANCE_COMPONENT.WEEK_BEGIN);

			v_COMPONENT := GET_COMPONENT(v_IMBALANCE_COMPONENT.COMPONENT_ID);
			v_BILLING_STATEMENT.ENTITY_ID := v_IMBALANCE_COMPONENT.BILLING_ENTITY_ID;
			v_BILLING_STATEMENT.PRODUCT_ID := v_IMBALANCE_COMPONENT.PRODUCT_ID;
			v_BILLING_STATEMENT.COMPONENT_ID := v_IMBALANCE_COMPONENT.COMPONENT_ID;
			v_BILLING_STATEMENT.STATEMENT_TYPE := p_STATEMENT_TYPE;
			v_BILLING_STATEMENT.STATEMENT_STATE := GA.INTERNAL_STATE;
			v_BILLING_STATEMENT.STATEMENT_DATE := v_BEGIN_DATE;
			v_BILLING_STATEMENT.STATEMENT_END_DATE := v_END_DATE;
			v_BILLING_STATEMENT.AS_OF_DATE := p_OUTPUT_AS_OF_DATE;
			v_BILLING_STATEMENT.BASIS_AS_OF_DATE := v_INPUT_AS_OF_DATE;
			v_BILLING_STATEMENT.CHARGE_INTERVAL := v_COMPONENT.RATE_INTERVAL;
			SELECT DECODE(v_IMBALANCE_COMPONENT.IMBALANCE_TYPE,'N','IMBALANCE1','IMBALANCE3') INTO v_BILLING_STATEMENT.CHARGE_VIEW_TYPE FROM DUAL;

			GET_CHARGE_ID(v_BILLING_STATEMENT);
			-- PUT THIS LINE SO IT CAN BE USED TO DETERMINE PRIOR CHARGE IDs
			v_BILLING_STATEMENT.CHARGE_QUANTITY := 0;
			v_BILLING_STATEMENT.CHARGE_AMOUNT := 0;
			v_BILLING_STATEMENT.BILL_QUANTITY := 0;
			v_BILLING_STATEMENT.CHARGE_RATE := 0;
			v_BILLING_STATEMENT.BILL_AMOUNT := 0;
			PUT_BILLING_STATEMENT (v_BILLING_STATEMENT);

			PSE_RETAIL_IMBALANCE(v_IMBALANCE_COMPONENT.CONTRACT_ID, p_STATEMENT_TYPE, p_STATEMENT_TYPE, v_BILLING_STATEMENT.CHARGE_ID, v_COMPONENT, v_BEGIN_DATE, v_END_DATE, v_INPUT_AS_OF_DATE, v_IMBALANCE_COMPONENT.TIME_ZONE);

			GET_BILLING_STATEMENT_CHARGES(v_BILLING_STATEMENT, v_WRITE_BILLING_STATEMENT);
			IF v_WRITE_BILLING_STATEMENT THEN
				v_PRIOR_CHARGE_ID := GET_PRIOR_CHARGE_ID(v_BILLING_STATEMENT);
				PRIOR_BILLING_STATEMENT(v_PRIOR_CHARGE_ID, v_BILLING_STATEMENT);
				PUT_BILLING_STATEMENT(v_BILLING_STATEMENT);
			ELSE
				g_DELETING_TEMP_ROW := TRUE;
				DELETE BILLING_STATEMENT WHERE CHARGE_ID = v_BILLING_STATEMENT.CHARGE_ID;
				g_DELETING_TEMP_ROW := FALSE;
			END IF;

		END LOOP;

		v_BEGIN_DATE := v_END_DATE + 1;
	END LOOP;

	IF LOGS.IS_DEBUG_ENABLED THEN
		v_ELASPSED := DBMS_UTILITY.GET_TIME - v_ELASPSED;
	    LOGS.LOG_DEBUG('NET_RETAIL_POSITION_REQUEST END AT ' || TEXT_UTIL.TO_CHAR_TIME(SYSDATE));
	    LOGS.LOG_DEBUG('ELAPSED TIME=' || TO_CHAR(v_ELASPSED));
 	END IF;

	NET_RETAIL_PROFIT_AND_LOSS(p_STATEMENT_TYPE, p_STATEMENT_TYPE, p_BEGIN_DATE, p_END_DATE, v_INPUT_AS_OF_DATE, p_OUTPUT_AS_OF_DATE);

	-- finally, update the IN_DISPUTE flag for rows that have dispute information
	UPDATE_DISPUTE_FLAGS (g_ALL, v_MIN_DATE, v_END_LOOP_DATE, p_STATEMENT_TYPE);

	LOGS.STOP_PROCESS(p_MESSAGE, p_PROCESS_STATUS);

	COMMIT;

EXCEPTION
    WHEN OTHERS THEN
        g_DELETING_TEMP_ROW := FALSE;
		ERRS.ABORT_PROCESS(p_SAVEPOINT_NAME => 'BEFORE_NET_POSITION_CALC');

END NET_RETAIL_POSITION_REQUEST;
---------------------------------------------------------------------------------------------------
PROCEDURE POST_RETAIL_LOAD_BASIS
	(
	p_SUPPLY_TYPE IN CHAR,
	p_IS_BUG IN NUMBER,
	p_REQUEST_TYPE IN CHAR,
	p_PRICE_CODE IN CHAR,
	p_MARKET_PRICE IN MARKET_PRICE%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE
	) AS

-- Note: p_BEGIN_DATE and p_END_DATE are CUT Dates.

v_MARKET_PRICE_VALUE MARKET_PRICE_VALUE%ROWTYPE;

CURSOR c_RETAIL_LOAD IS
    SELECT LOAD_DATE, SUM(LOAD_VAL + UFE_LOAD_VAL) "LOAD_VAL"
	FROM SERVICE_OBLIGATION A, SERVICE_DELIVERY B, SERVICE_OBLIGATION_LOAD C
	WHERE A.MODEL_ID = GA.DEFAULT_MODEL
		AND A.SCENARIO_ID = GA.BASE_SCENARIO_ID
		AND A.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM SERVICE_OBLIGATION
			WHERE MODEL_ID = A.MODEL_ID
				AND SCENARIO_ID = A.SCENARIO_ID
				AND AS_OF_DATE <= p_INPUT_AS_OF_DATE
				AND PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
				AND SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID)
		AND A.PROVIDER_SERVICE_ID IN (SELECT PROVIDER_SERVICE_ID FROM PROVIDER_SERVICE WHERE EDC_ID = p_MARKET_PRICE.EDC_ID)
		AND B.SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
		AND B.SUPPLY_TYPE = NVL(p_SUPPLY_TYPE, B.SUPPLY_TYPE)
       	AND B.IS_BUG = p_IS_BUG
		AND B.IS_WHOLESALE = 0
		AND C.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
		AND C.SERVICE_CODE = p_REQUEST_TYPE
		AND C.LOAD_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
		AND C.LOAD_CODE = GA.STANDARD
	GROUP BY LOAD_DATE;

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('POST_RETAIL_LOAD_BASIS');
		LOGS.LOG_DEBUG('SUPPLY_TYPE=' || p_SUPPLY_TYPE);
		LOGS.LOG_DEBUG('IS_BUG=' || TO_CHAR(p_IS_BUG));
		LOGS.LOG_DEBUG('REQUEST_TYPE=' || p_REQUEST_TYPE);
		LOGS.LOG_DEBUG('PRICE_CODE=' || p_PRICE_CODE);
	END IF;

	v_MARKET_PRICE_VALUE.MARKET_PRICE_ID := p_MARKET_PRICE.MARKET_PRICE_ID;
	v_MARKET_PRICE_VALUE.PRICE_CODE := p_PRICE_CODE;
	v_MARKET_PRICE_VALUE.AS_OF_DATE := p_OUTPUT_AS_OF_DATE;
	v_MARKET_PRICE_VALUE.PRICE := 0;

	FOR v_RETAIL_LOAD IN c_RETAIL_LOAD LOOP
		v_MARKET_PRICE_VALUE.PRICE_DATE := v_RETAIL_LOAD.LOAD_DATE;
		v_MARKET_PRICE_VALUE.PRICE_BASIS := v_RETAIL_LOAD.LOAD_VAL;
		PUT_MARKET_PRICE_VALUE(v_MARKET_PRICE_VALUE);
	END LOOP;

END POST_RETAIL_LOAD_BASIS;
---------------------------------------------------------------------------------------------------
PROCEDURE POST_POSITION_BASIS
	(
	p_MARKET_PRICE_TYPE IN VARCHAR,
	p_SCHEDULE_TYPE IN NUMBER,
	p_REQUEST_TYPE IN CHAR,
	p_PRICE_CODE IN CHAR,
	p_MARKET_PRICE IN MARKET_PRICE%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE
	) AS

v_POSITION NUMBER;
v_OVER BOOLEAN;
v_UNDER BOOLEAN;
v_MARKET_PRICE_VALUE MARKET_PRICE_VALUE%ROWTYPE;
v_NET_POSITION_TABLE NET_POSITION_TABLE;
v_INDEX BINARY_INTEGER;

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('POST_POSITION_BASIS');
		LOGS.LOG_DEBUG('MARKET_PRICE_TYPE=' || p_MARKET_PRICE_TYPE);
		LOGS.LOG_DEBUG('SCHEDULE_TYPE=' || TO_CHAR(p_SCHEDULE_TYPE));
		LOGS.LOG_DEBUG('REQUEST_TYPE=' || p_REQUEST_TYPE);
		LOGS.LOG_DEBUG('PRICE_CODE=' || p_PRICE_CODE);
	END IF;

	v_MARKET_PRICE_VALUE.MARKET_PRICE_ID := p_MARKET_PRICE.MARKET_PRICE_ID;
	v_MARKET_PRICE_VALUE.PRICE_CODE := p_PRICE_CODE;
	v_MARKET_PRICE_VALUE.AS_OF_DATE := p_OUTPUT_AS_OF_DATE;
	v_MARKET_PRICE_VALUE.PRICE := 0;

	v_UNDER := INSTR(p_MARKET_PRICE_TYPE, 'UNDER') > 0;
	v_OVER := INSTR(p_MARKET_PRICE_TYPE, 'OVER') > 0;

	IF UPPER(p_MARKET_PRICE.SERVICE_POINT_TYPE) = 'GENERATION' THEN
		GET_GENERATION_BASIS(p_SCHEDULE_TYPE, v_UNDER, v_OVER, p_BEGIN_DATE, p_END_DATE, p_INPUT_AS_OF_DATE, v_NET_POSITION_TABLE);
	ELSE
		GET_NET_POSITION(p_SCHEDULE_TYPE, p_MARKET_PRICE.EDC_ID, p_MARKET_PRICE.SERVICE_POINT_TYPE,
			p_MARKET_PRICE.POD_ID, p_BEGIN_DATE, p_END_DATE, p_INPUT_AS_OF_DATE, GA.LOCAL_TIME_ZONE, v_NET_POSITION_TABLE);
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		TRACE_NET_POSITION(v_NET_POSITION_TABLE);
	END IF;

	IF v_NET_POSITION_TABLE.COUNT = 0 AND LOGS.IS_INFO_DETAIL_ENABLED THEN
		LOGS.LOG_WARN('NET POSITION NOT FOUND FOR MARKET PRICE TYPE OF ' || p_MARKET_PRICE_TYPE);
	ELSE
		FOR v_INDEX IN v_NET_POSITION_TABLE.FIRST..v_NET_POSITION_TABLE.LAST LOOP
			IF v_NET_POSITION_TABLE.EXISTS(v_INDEX) THEN
				v_POSITION := v_NET_POSITION_TABLE(v_INDEX).POSITION;
				IF (v_UNDER AND v_POSITION > 0) OR (v_OVER AND v_POSITION < 0)  THEN
					v_POSITION := 0;
				END IF;
				v_MARKET_PRICE_VALUE.PRICE_DATE :=  v_NET_POSITION_TABLE(v_INDEX).SCHEDULE_DATE;
				v_MARKET_PRICE_VALUE.PRICE_BASIS := ABS(v_POSITION);
				PUT_MARKET_PRICE_VALUE(v_MARKET_PRICE_VALUE);
			END IF;
		END LOOP;
	END IF;

END POST_POSITION_BASIS;
---------------------------------------------------------------------------------------------------
PROCEDURE COMPUTE_COMPOSITE_OSF
	(
	p_MARKET_PRICE_ID NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PRICE_CODE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE
	) AS

-- NOTE:  p_BEGIN_DATE AND p_END_DATE are CUT Dates.

CURSOR c_MARKET_PRICE_COMPOSITE IS
    SELECT COMPOSITE_MARKET_PRICE_ID, COMPOSITE_MULTIPLIER, COMPOSITE_OPTION
	FROM MARKET_PRICE_COMPOSITE
	WHERE MARKET_PRICE_ID = p_MARKET_PRICE_ID;

v_MARKET_PRICE_TABLE GA.NUMBER_TABLE;
v_COMPOSITE_TABLE GA.NUMBER_TABLE;
v_SUPPLY_POSITION SUPPLY_POSITION_TABLE;
v_VALUE NUMBER;
v_CODE CHAR(1);
v_SUPPLY NUMBER;
v_DATE DATE;
v_MARKET_PRICE_VALUE MARKET_PRICE_VALUE%ROWTYPE;
v_INDEX BINARY_INTEGER;

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('COMPUTE_COMPOSITE_OSF');
	    LOGS.LOG_DEBUG('MARKET_PRICE_ID=' || TO_CHAR(p_MARKET_PRICE_ID));
	    LOGS.LOG_DEBUG('EDC_ID=' || TO_CHAR(p_EDC_ID));
	    LOGS.LOG_DEBUG('PRICE_CODE=' || p_PRICE_CODE);
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE));
	END IF;

	FOR v_INDEX IN 0..ROUND((p_END_DATE - p_BEGIN_DATE) / GA.HOUR_DIVISOR) LOOP
	 	v_COMPOSITE_TABLE(v_INDEX) := 0;
	END LOOP;

	FOR v_MARKET_PRICE_COMPOSITE IN c_MARKET_PRICE_COMPOSITE LOOP

		IF LOGS.IS_DEBUG_ENABLED THEN
		    LOGS.LOG_DEBUG('MARKET_PRICE_COMPOSITE_ID=' || TO_CHAR(v_MARKET_PRICE_COMPOSITE.COMPOSITE_MARKET_PRICE_ID));
		    LOGS.LOG_DEBUG('COMPOSITE_MULTIPLIER=' || TO_CHAR(v_MARKET_PRICE_COMPOSITE.COMPOSITE_MULTIPLIER));
		    LOGS.LOG_DEBUG('COMPOSITE_OPTION=' || v_MARKET_PRICE_COMPOSITE.COMPOSITE_OPTION);
		END IF;

		GET_MARKET_PRICE(v_MARKET_PRICE_COMPOSITE.COMPOSITE_MARKET_PRICE_ID, p_PRICE_CODE, p_BEGIN_DATE, p_END_DATE, p_INPUT_AS_OF_DATE, v_MARKET_PRICE_TABLE);

		IF LOGS.IS_DEBUG_ENABLED THEN
		    TRACE_TABLE('COMPOSITE PRICE', v_MARKET_PRICE_TABLE);
			LOGS.LOG_DEBUG('<supply>,<price>=<value>@<index>');
		END IF;

		GET_SUPPLY_POSITION(p_SCHEDULE_TYPE, p_EDC_ID, p_BEGIN_DATE, p_END_DATE, p_INPUT_AS_OF_DATE, v_SUPPLY_POSITION);

		v_CODE := UPPER(SUBSTR(v_MARKET_PRICE_COMPOSITE.COMPOSITE_OPTION,5,1));
		v_INDEX := v_MARKET_PRICE_TABLE.FIRST;
		WHILE v_INDEX <= v_MARKET_PRICE_TABLE.LAST LOOP
		    v_SUPPLY := 0;
			IF v_SUPPLY_POSITION.EXISTS(v_INDEX) THEN
			    IF v_CODE = 'U' THEN
				    v_SUPPLY := v_SUPPLY_POSITION(v_INDEX).UNDER_SUPPLY;
				ELSIF v_CODE = 'O' THEN
				    v_SUPPLY := v_SUPPLY_POSITION(v_INDEX).OVER_SUPPLY;
				ELSIF v_CODE = 'N' THEN
				    v_SUPPLY := GREATEST(v_SUPPLY_POSITION(v_INDEX).OVER_SUPPLY - v_SUPPLY_POSITION(v_INDEX).UNDER_SUPPLY,0);
				END IF;
			END IF;

			v_VALUE := v_SUPPLY * v_MARKET_PRICE_TABLE(v_INDEX) * v_MARKET_PRICE_COMPOSITE.COMPOSITE_MULTIPLIER;
			v_COMPOSITE_TABLE(v_INDEX) := v_COMPOSITE_TABLE(v_INDEX) + v_VALUE;
			IF LOGS.IS_DEBUG_ENABLED THEN
			    LOGS.LOG_DEBUG(TO_CHAR(v_SUPPLY) || ',' || TO_CHAR(v_MARKET_PRICE_TABLE(v_INDEX)) || '=' || TO_CHAR(v_VALUE) || '@' || TO_CHAR(v_INDEX));
			END IF;
			v_INDEX := v_MARKET_PRICE_TABLE.NEXT(v_INDEX);
		END LOOP;
	END LOOP;

	v_DATE := p_BEGIN_DATE;
	v_MARKET_PRICE_VALUE.MARKET_PRICE_ID := p_MARKET_PRICE_ID;
	v_MARKET_PRICE_VALUE.PRICE_CODE := p_PRICE_CODE;
	v_MARKET_PRICE_VALUE.AS_OF_DATE := p_OUTPUT_AS_OF_DATE;
	v_MARKET_PRICE_VALUE.PRICE_BASIS := 0;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('<over supply>,<composite price>=<value>@<index>@<date>');
	END IF;

	v_INDEX := v_COMPOSITE_TABLE.FIRST;
	WHILE v_INDEX <= v_COMPOSITE_TABLE.LAST LOOP
		IF v_SUPPLY_POSITION.EXISTS(v_INDEX) THEN
		    v_SUPPLY := v_SUPPLY_POSITION(v_INDEX).OVER_SUPPLY;
		END IF;
	    v_MARKET_PRICE_VALUE.PRICE_DATE := v_DATE;
		IF v_SUPPLY > 0 THEN
		    v_MARKET_PRICE_VALUE.PRICE := v_COMPOSITE_TABLE(v_INDEX) / v_SUPPLY;
		ELSE
		    v_MARKET_PRICE_VALUE.PRICE := 0;
		END IF;
		IF LOGS.IS_DEBUG_ENABLED THEN
		    LOGS.LOG_DEBUG(TO_CHAR(v_SUPPLY) || ',' || TO_CHAR(v_COMPOSITE_TABLE(v_INDEX)) || '=' || TO_CHAR(v_MARKET_PRICE_VALUE.PRICE) || '@' || TO_CHAR(v_INDEX) || '@' || TEXT_UTIL.TO_CHAR_TIME(v_DATE));
		END IF;
		PUT_MARKET_PRICE_VALUE(v_MARKET_PRICE_VALUE);
		v_DATE := ADD_MINUTES_TO_DATE(v_DATE, 60);
		v_INDEX := v_COMPOSITE_TABLE.NEXT(v_INDEX);
	END LOOP;

END COMPUTE_COMPOSITE_OSF;
---------------------------------------------------------------------------------------------------
PROCEDURE MARKET_PRICE_BASIS_REQUEST
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_REQUEST_TYPE IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

CURSOR c_MARKET_PRICE IS
    SELECT *
	FROM MARKET_PRICE
	WHERE NOT UPPER(MARKET_PRICE_TYPE) = 'USER DEFINED';

v_REQUEST_TYPE CHAR(1);
v_SCHEDULE_TYPE NUMBER;
v_ELASPSED NUMBER;
v_PRICE_CODE CHAR(1);
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_MARKET_PRICE_TYPE MARKET_PRICE.MARKET_PRICE_TYPE%TYPE;
v_INPUT_AS_OF_DATE DATE;
v_OUTPUT_AS_OF_DATE DATE;

BEGIN

	IF NOT CAN_WRITE('PRODUCT') THEN
		ERRS.RAISE_NO_WRITE_MODULE('PRODUCT');
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := NULL;

	v_INPUT_AS_OF_DATE := CORRECTED_AS_OF_DATE(p_INPUT_AS_OF_DATE);
	v_OUTPUT_AS_OF_DATE := CORRECTED_AS_OF_DATE(p_OUTPUT_AS_OF_DATE);

	v_REQUEST_TYPE := UPPER(SUBSTR(p_REQUEST_TYPE,1,1));
	SELECT DECODE(UPPER(SUBSTR(p_REQUEST_TYPE,1,1)),'F', 1, 'B', 2, 'U', 3, 1) INTO v_SCHEDULE_TYPE FROM DUAL;
	SELECT DECODE(UPPER(SUBSTR(p_REQUEST_TYPE,1,1)),'F', 'F', 'B', 'P', 'A') INTO v_PRICE_CODE FROM DUAL;
	UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, GA.LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);


	IF LOGS.IS_DEBUG_ENABLED THEN
		v_ELASPSED := DBMS_UTILITY.GET_TIME;
		LOGS.LOG_DEBUG('MARKET_PRICE_BASIS_REQUEST BEGIN AT ' || TEXT_UTIL.TO_CHAR_TIME(SYSDATE));
		LOGS.LOG_DEBUG('CALLING_MODULE=' || p_CALLING_MODULE);
		LOGS.LOG_DEBUG('MODEL_ID=' || p_MODEL_ID);
		LOGS.LOG_DEBUG('REQUEST_TYPE=' || p_REQUEST_TYPE);
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE));
		LOGS.LOG_DEBUG('INPUT_AS_OF_DATE=' || TEXT_UTIL.TO_CHAR_TIME(v_INPUT_AS_OF_DATE));
		LOGS.LOG_DEBUG('OUTPUT_AS_OF_DATE=' || TEXT_UTIL.TO_CHAR_TIME(v_OUTPUT_AS_OF_DATE));
		LOGS.LOG_DEBUG('SCHEDULE_TYPE=' || TO_CHAR(v_SCHEDULE_TYPE));
	END IF;

	FOR v_MARKET_PRICE IN c_MARKET_PRICE LOOP
		v_MARKET_PRICE_TYPE := UPPER(v_MARKET_PRICE.MARKET_PRICE_TYPE);

		IF v_MARKET_PRICE_TYPE = 'STANDARD OFFER SUPPLY' THEN
			POST_RETAIL_LOAD_BASIS('S', 0, v_REQUEST_TYPE, v_PRICE_CODE, v_MARKET_PRICE, v_BEGIN_DATE, v_END_DATE, v_INPUT_AS_OF_DATE, v_OUTPUT_AS_OF_DATE);
		ELSIF v_MARKET_PRICE_TYPE = 'DEFAULTED SUPPLY' THEN
			POST_RETAIL_LOAD_BASIS('D', 0, v_REQUEST_TYPE, v_PRICE_CODE, v_MARKET_PRICE, v_BEGIN_DATE, v_END_DATE, v_INPUT_AS_OF_DATE, v_OUTPUT_AS_OF_DATE);
		ELSIF v_MARKET_PRICE_TYPE = 'BACKUP GENERATION' THEN
			POST_RETAIL_LOAD_BASIS(NULL, 1, v_REQUEST_TYPE, v_PRICE_CODE, v_MARKET_PRICE, v_BEGIN_DATE, v_END_DATE, v_INPUT_AS_OF_DATE, v_OUTPUT_AS_OF_DATE);
		ELSIF v_MARKET_PRICE_TYPE IN ('UNDER SUPPLY' ,'OVER SUPPLY') THEN
			POST_POSITION_BASIS(v_MARKET_PRICE_TYPE, v_SCHEDULE_TYPE, v_REQUEST_TYPE, v_PRICE_CODE, v_MARKET_PRICE, v_BEGIN_DATE, v_END_DATE, v_INPUT_AS_OF_DATE, v_OUTPUT_AS_OF_DATE);
		END IF;
	END LOOP;

	IF LOGS.IS_DEBUG_ENABLED THEN
		v_ELASPSED := DBMS_UTILITY.GET_TIME - v_ELASPSED;
		LOGS.LOG_DEBUG('MARKET_PRICE_BASIS_REQUEST END AT ' || TEXT_UTIL.TO_CHAR_TIME(SYSDATE));
		LOGS.LOG_DEBUG('ELAPSED TIME=' || TO_CHAR(v_ELASPSED));
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;
		p_MESSAGE := SQLERRM;

END MARKET_PRICE_BASIS_REQUEST;
---------------------------------------------------------------------------------------------------
PROCEDURE POST_MARKET_PRICE_REQUEST
	(
	p_CALLING_MODULE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_REQUEST_TYPE IN VARCHAR,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

CURSOR c_MARKET_PRICE IS
    SELECT MARKET_PRICE_ID, EDC_ID
	FROM MARKET_PRICE
	WHERE UPPER(MARKET_PRICE_TYPE) = 'COMPOSITE-OSF';

v_ELASPSED NUMBER;
v_PRICE_CODE CHAR(1);
v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

	IF NOT CAN_WRITE('PRODUCT') THEN
		ERRS.RAISE_NO_WRITE_MODULE('PRODUCT');
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := NULL;

	SELECT DECODE(UPPER(SUBSTR(p_REQUEST_TYPE,1,1)),'F', 'F', 'B', 'P', 'A') INTO v_PRICE_CODE FROM DUAL;
	UT.CUT_DAY_INTERVAL_RANGE(p_BEGIN_DATE, p_END_DATE, GA.LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	IF LOGS.IS_DEBUG_ENABLED THEN
	   	v_ELASPSED := DBMS_UTILITY.GET_TIME;
	    LOGS.LOG_DEBUG('POST_MARKET_PRICE_REQUEST BEGIN AT ' || TEXT_UTIL.TO_CHAR_TIME(SYSDATE));
		LOGS.LOG_DEBUG('CALLING_MODULE=' || p_CALLING_MODULE);
		LOGS.LOG_DEBUG('MODEL_ID=' || TO_CHAR(p_MODEL_ID));
		LOGS.LOG_DEBUG('REQUEST_TYPE=' || p_REQUEST_TYPE);
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE));
		LOGS.LOG_DEBUG('INPUT_AS_OF_DATE=' || TEXT_UTIL.TO_CHAR_TIME(p_INPUT_AS_OF_DATE));
		LOGS.LOG_DEBUG('OUTPUT_AS_OF_DATE=' || TEXT_UTIL.TO_CHAR_TIME(p_OUTPUT_AS_OF_DATE));
		LOGS.LOG_DEBUG('SCHEDULE_TYPE=' || TO_CHAR(p_SCHEDULE_TYPE));
	END IF;

	FOR v_MARKET_PRICE IN c_MARKET_PRICE LOOP
		COMPUTE_COMPOSITE_OSF(v_MARKET_PRICE.MARKET_PRICE_ID, p_SCHEDULE_TYPE, v_MARKET_PRICE.EDC_ID, v_PRICE_CODE, v_BEGIN_DATE, v_END_DATE, p_INPUT_AS_OF_DATE, p_OUTPUT_AS_OF_DATE);
	END LOOP;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('POST_MARKET_PRICE_REQUEST END AT ' || TEXT_UTIL.TO_CHAR_TIME(SYSDATE));
		LOGS.LOG_DEBUG('ELAPSED TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELASPSED));
 	END IF;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;
		p_MESSAGE := SQLERRM;

END POST_MARKET_PRICE_REQUEST;
---------------------------------------------------------------------------------------------------
FUNCTION GET_BILL_CALC_GROUP
	(
	p_PSE_ID IN NUMBER,
	p_DATE IN DATE
	) RETURN VARCHAR2 IS
v_RET VARCHAR2(64);
BEGIN
	SELECT B.ATTRIBUTE_VAL
	INTO v_RET
	FROM ENTITY_ATTRIBUTE A,
		TEMPORAL_ENTITY_ATTRIBUTE B
	WHERE A.ENTITY_DOMAIN_ID = EC.ED_PSE
		AND A.ATTRIBUTE_NAME = 'BillCalcGroup'
		AND B.OWNER_ENTITY_ID = p_PSE_ID
		AND B.ATTRIBUTE_ID = A.ATTRIBUTE_ID
		AND TRUNC(p_DATE) BETWEEN TRUNC(B.BEGIN_DATE) AND TRUNC(NVL(B.END_DATE,p_DATE));

	RETURN v_RET;
EXCEPTION
	WHEN OTHERS THEN
		RETURN NULL;
END GET_BILL_CALC_GROUP;
---------------------------------------------------------------------------------------------------
FUNCTION GET_CHARGE_AMOUNT
	(
	p_ENTITY_ID	IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_COMPONENT_NAME IN VARCHAR2
	) RETURN NUMBER AS
v_AMT NUMBER;
BEGIN
	SELECT SUM(CHARGE_AMOUNT)
	INTO v_AMT
	FROM BILLING_STATEMENT BS, COMPONENT C
	WHERE BS.ENTITY_ID = p_ENTITY_ID
		AND BS.STATEMENT_TYPE = p_STATEMENT_TYPE
		AND BS.STATEMENT_STATE = CONSTANTS.INTERNAL_STATE
		AND BS.STATEMENT_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
		AND BS.AS_OF_DATE = CONSTANTS.LOW_DATE
		AND BS.COMPONENT_ID = C.COMPONENT_ID
		AND C.COMPONENT_NAME = p_COMPONENT_NAME;

	RETURN NVL(v_AMT,0);
END GET_CHARGE_AMOUNT;
---------------------------------------------------------------------------------------------------
END PC;
/
