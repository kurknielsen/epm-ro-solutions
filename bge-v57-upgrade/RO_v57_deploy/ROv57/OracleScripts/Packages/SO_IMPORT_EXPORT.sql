CREATE OR REPLACE PACKAGE SO_IMPORT_EXPORT AS
--Revision $Revision: 1.13 $

-- System Object Configuration Import/Export Package.

FUNCTION WHAT_VERSION RETURN VARCHAR;

PROCEDURE GET_SYSTEM_OBJECT_SCRIPT_XML
	(
	p_OBJECT_ID_LIST IN NUMBER_COLLECTION,
	p_PRODUCT_SCRIPT_TYPE IN VARCHAR2,
	p_EXPORT_MODE IN VARCHAR2,
	p_FILE OUT CLOB
	);

PROCEDURE GET_PRODUCT_SCRIPT_XML
	(
	p_ENTITY_LIST IN VARCHAR2,
	p_FILE OUT CLOB
	);

PROCEDURE IMPORT_SYSTEM_OBJECT_XML_CLOB
	(
	p_IMPORT_FILE IN OUT NOCOPY CLOB,
	p_IMPORT_FILE_PATH IN VARCHAR2,
	p_IMPORT_MODE IN VARCHAR2,
	p_PROCESS_STATUS OUT NUMBER,
	p_PROCESS_ID OUT VARCHAR2,
	p_MESSAGE OUT VARCHAR2
	);

FUNCTION SEE_IF_SIDE_DIFFERS_FROM_OBJ
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_OBJECT_ID IN NUMBER,
	p_IMPORT_SIDE IN VARCHAR2
	) RETURN NUMBER;

PROCEDURE ACCEPT_OR_REJECT
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_INCLUDE_DESCENDANTS IN NUMBER,
	p_ACCEPTED_SIDE IN VARCHAR2,
	p_FORCE IN NUMBER,
	p_OBJECT_ID IN NUMBER_COLLECTION
	);

PROCEDURE ACCEPT_OR_REJECT_ALL
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_ACCEPTED_SIDE IN VARCHAR2,
	p_FORCE IN NUMBER
	);

--=================================================
--     SYSTEM OBJECT RESOLVE CONFLICTS REPORT LOGIC
--=================================================

FUNCTION GET_FORMATTED_OBJECT_NAME
	(
	p_OBJECT_NAME IN VARCHAR2,
	p_MERGE_TYPE IN VARCHAR2,
	p_CONFLICT_COUNT IN NUMBER
	) RETURN VARCHAR2;

FUNCTION GET_FORMATTED_CATEGORY_NAME
	(
	p_OBJECT_CATEGORY IN VARCHAR2,
	p_CONFLICT_COUNT IN NUMBER
	) RETURN VARCHAR2;

PROCEDURE GET_IMPORT_STATUS_TREE
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_IMPORT_LIST
	(
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_MERGE_TYPE_LIST
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_IMPORT_STATUS_RPT_MASTER
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_OBJECT_ID IN NUMBER,
	p_PARENT_OBJECT_ID IN NUMBER,
	p_OBJECT_CATEGORY IN VARCHAR2,
	p_INCLUDE_DESCENDANTS IN NUMBER,
	p_MERGE_TYPES IN VARCHAR2,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE GET_IMPORT_STATUS_RPT_DETAIL
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_OBJECT_ID IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PUT_IMPORT_STATUS_RPT_DETAIL
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_OBJECT_ID IN NUMBER,
	p_ATTRIBUTE_ID IN NUMBER,
	p_COLUMN_NAME IN VARCHAR2,
	p_CURRENT_VAL IN VARCHAR2
	);

PROCEDURE SET_IMPORT_STATUS
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_NEW_IMPORT_STATUS IN VARCHAR2
	);

PROCEDURE PURGE_IMPORT_LOG
	(
	p_OBJECT_IMPORT_ID IN NUMBER
	);

PROCEDURE PREV_IMPORT_WARNING
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_PRODUCT_SCRIPT_TYPE IN VARCHAR2,
	p_WARNING_MESSAGE OUT VARCHAR2
	);

PROCEDURE CLOSE_OPEN_IMPORT;


	c_IMODE_DIFF CONSTANT VARCHAR2(32) := 'Differences';
	c_IMODE_OVERWRITE CONSTANT VARCHAR2(32) := 'Overwrite';
	c_IMODE_OVERWRITE_PRSV CONSTANT VARCHAR2(32) := 'Overwrite:PreserveFormats';
	c_IMODE_FMTS_INSERT CONSTANT VARCHAR2(32) := 'InsertFormats';
	c_IMODE_FMTS_OVERWRITE CONSTANT VARCHAR2(32) := 'OverwriteFormats';
	c_IMODE_OVERWRITE_FORCE CONSTANT VARCHAR2(32) := 'Overwrite:Force';

	c_EMODE_FORMATS_ONLY CONSTANT VARCHAR2(32) := 'Formats';
	c_EMODE_REGULAR CONSTANT VARCHAR2(32) := 'Regular';
	c_EMODE_REPOSITORY CONSTANT VARCHAR2(32) := 'Repository';
	c_EMODE_PRODUCT_SCRIPT CONSTANT VARCHAR2(32) := 'ProductScript';

END SO_IMPORT_EXPORT;
/
CREATE OR REPLACE PACKAGE BODY SO_IMPORT_EXPORT AS

	TYPE OBJECT_ID_MAP IS TABLE OF NUMBER(1) INDEX BY BINARY_INTEGER;
	SEP CONSTANT VARCHAR2(1) := '~';

	c_MSG_CRYSTAL_ORIG_OR_IMPORT CONSTANT VARCHAR2(200) := 'Crystal Rpt Template''s "Current Val" must be set to either the Original or Imported value.';

	c_XML_DATE_TIME_FORMAT CONSTANT VARCHAR2(32) := 'YYYY-MM-DD HH24:MI:SS';
	c_CONFIG_NAMESPACE CONSTANT VARCHAR2(64) := 'xmlns="http://www.newenergyassoc.com/mighty/configuration"';
	c_CONFIG_NAMESPACE_NAME CONSTANT VARCHAR2(64) := 'http://www.newenergyassoc.com/mighty/configuration';

	c_IMPORT_STATUS_OPEN CONSTANT VARCHAR2(16) := 'Open';
	c_IMPORT_STATUS_CLOSED CONSTANT VARCHAR2(16) := 'Closed';

	c_SIDE_ORIGINAL CONSTANT VARCHAR2(32) := 'Original';
	c_SIDE_IMPORTED CONSTANT VARCHAR2(32) := 'Imported';

	c_MERGE_TYPE_NO_DIFF CONSTANT VARCHAR2(16) := 'No Difference';
	c_MERGE_TYPE_ADD CONSTANT VARCHAR2(16) := 'Add';
	c_MERGE_TYPE_CHANGE CONSTANT VARCHAR2(16) := 'Change';
	c_MERGE_TYPE_CONFLICT CONSTANT VARCHAR2(16) := 'Conflict';
	c_MERGE_TYPE_DELETE CONSTANT VARCHAR2(16) := 'Delete';
	c_MERGE_TYPE_CONFLICT_DELETE CONSTANT VARCHAR2(16) := 'Conflict Delete';
	c_MERGE_TYPE_IGNORE_CHANGE CONSTANT VARCHAR2(16) := 'Ignore Change';
	c_MERGE_TYPE_IGNORE_DELETE CONSTANT VARCHAR2(16) := 'Ignore Delete';

	c_COLNAME_DISP_NAME CONSTANT VARCHAR2(16) := 'Display Name';
	c_COLNAME_DISP_ORDER CONSTANT VARCHAR2(16) := 'Display Order';
	c_COLNAME_IS_HIDDEN CONSTANT VARCHAR2(16) := 'Is Hidden';
	c_COLNAME_CRYSTAL CONSTANT VARCHAR2(32) := 'Crystal Rpt Template';

	--Configuration Import/Export actions
	c_ACTION_SO_EXPORT CONSTANT VARCHAR2(32) := 'Configuration Export';
	c_ACTION_SO_IMPORT CONSTANT VARCHAR2(32) := 'Configuration Import';
	c_ACTION_SO_MANAGE_MY CONSTANT VARCHAR2(32) := 'Manage My Configuration Imports';
	c_ACTION_SO_MANAGE_ALL CONSTANT VARCHAR2(32) := 'Manage All Configuration Imports';

	--Excluded Object return ID
	c_EXCLUDED_OBJECT CONSTANT NUMBER(2) := -3;

	c_PROD_SCRIPT_TYPE_CORE CONSTANT VARCHAR2(8) := 'Core';

----------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
	RETURN '$Revision: 1.13 $';
END WHAT_VERSION;
----------------------------------------------------------------------------------------------------
PROCEDURE CHECK_IMPORT_IS_OPEN
	(
	p_IMPORT_ID IN NUMBER
	) AS
	v_IMPORT_STATUS VARCHAR2(32);
BEGIN
	SELECT I.IMPORT_STATUS INTO v_IMPORT_STATUS FROM SYSTEM_OBJECT_IMPORT I WHERE I.OBJECT_IMPORT_ID = p_IMPORT_ID;

	IF NOT v_IMPORT_STATUS = c_IMPORT_STATUS_OPEN THEN
		ERRS.RAISE(MSGCODES.c_ERR_SO_IMP_CLOSED);
	END IF;

END CHECK_IMPORT_IS_OPEN;
----------------------------------------------------------------------------------------------------
PROCEDURE CHECK_IMPORT_IS_CLOSED
	(
	p_IMPORT_ID IN NUMBER
	) AS
	v_IMPORT_STATUS VARCHAR2(32);
BEGIN
	SELECT I.IMPORT_STATUS INTO v_IMPORT_STATUS FROM SYSTEM_OBJECT_IMPORT I WHERE I.OBJECT_IMPORT_ID = p_IMPORT_ID;

	IF NOT v_IMPORT_STATUS = c_IMPORT_STATUS_CLOSED THEN
		ERRS.RAISE(MSGCODES.c_ERR_SO_IMP_OPEN);
	END IF;

END CHECK_IMPORT_IS_CLOSED;
----------------------------------------------------------------------------------------------------
PROCEDURE CHECK_ALL_IMPORTS_ARE_CLOSED AS
	v_IMPORT_IS_OPEN NUMBER(1);
BEGIN
	SELECT MAX(CASE I.IMPORT_STATUS WHEN 'Open' THEN 1 ELSE 0 END)
	INTO v_IMPORT_IS_OPEN
	FROM SYSTEM_OBJECT_IMPORT I;

	IF v_IMPORT_IS_OPEN = 1 THEN
		ERRS.RAISE(MSGCODES.c_ERR_SO_IMP_OPEN_CONFLICT);
	END IF;

END CHECK_ALL_IMPORTS_ARE_CLOSED;
----------------------------------------------------------------------------------------------------
PROCEDURE CHECK_PRIVILEGE_MANAGE
	(
	p_IMPORT_ID IN NUMBER
	) AS
	v_USER_NAME APPLICATION_USER.USER_NAME%TYPE;
BEGIN

	--Get the name of the user that initiated this import.
	BEGIN
		SELECT USER_NAME INTO v_USER_NAME
		FROM SYSTEM_OBJECT_IMPORT A, APPLICATION_USER B
		WHERE A.OBJECT_IMPORT_ID = p_IMPORT_ID
			AND A.USER_ID = B.USER_ID;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			v_USER_NAME := NULL;
	END;

	--If not, and if this is not the curent user's import, raise the error.
	IF v_USER_NAME <> SECURITY_INFO.CURRENT_USER THEN
		SD.VERIFY_ACTION_IS_ALLOWED(c_ACTION_SO_MANAGE_ALL);
	ELSE
		--If it is, see if the user can manage his own import.  If not, raise the error.
		SD.VERIFY_ACTION_IS_ALLOWED(c_ACTION_SO_MANAGE_MY);
	END IF;

END CHECK_PRIVILEGE_MANAGE;
----------------------------------------------------------------------------------------------------
--===============================================
--     SYSTEM OBJECT XML EXPORT LOGIC
--===============================================
-- Check to see if this is an "Excluded Object" according to the System Label table.
-- By default, the "Transaction Traits" module is excluded, and the
-- "Product Development Use Only" data exchange is excluded.
FUNCTION IS_EXCLUDED_OBJECT
	(
	p_OBJECT_CATEGORY IN VARCHAR2,
	p_OBJECT_NAME IN VARCHAR2
	) RETURN BOOLEAN IS
	v_COUNT BINARY_INTEGER := 0;
BEGIN

	SELECT COUNT(1)
	INTO v_COUNT
	FROM SYSTEM_LABEL
	WHERE MODEL_ID = 0
		AND MODULE = 'System'
		AND KEY1 = 'Configuration Export'
		AND KEY2 = 'Excluded Objects'
		AND KEY3 = p_OBJECT_CATEGORY
		AND UPPER(VALUE) = UPPER(p_OBJECT_NAME);

	RETURN v_COUNT > 0;
END IS_EXCLUDED_OBJECT;
----------------------------------------------------------------------------------------------------
FUNCTION IS_EXCLUDED_OBJECT
	(
	p_OBJECT_ID IN NUMBER
	) RETURN BOOLEAN IS

	v_OBJECT_NAME SYSTEM_OBJECT.OBJECT_NAME%TYPE;
	v_OBJECT_CATEGORY SYSTEM_OBJECT.OBJECT_CATEGORY%TYPE;
BEGIN

	SELECT OBJECT_NAME, OBJECT_CATEGORY
	INTO v_OBJECT_NAME, v_OBJECT_CATEGORY
	FROM SYSTEM_OBJECT
	WHERE OBJECT_ID = p_OBJECT_ID;

	RETURN IS_EXCLUDED_OBJECT(v_OBJECT_CATEGORY, v_OBJECT_NAME);
END IS_EXCLUDED_OBJECT;
----------------------------------------------------------------------------------------------------
FUNCTION GET_EXCLUDED_OBJECT_ID_LIST RETURN NUMBER_COLLECTION IS
	v_IDS NUMBER_COLLECTION;
BEGIN
	SELECT O.OBJECT_ID
	BULK COLLECT INTO v_IDS
	FROM SYSTEM_LABEL L, SYSTEM_OBJECT O
	WHERE L.MODEL_ID = 0
		AND L.MODULE = 'System'
		AND L.KEY1 = 'Configuration Export'
		AND L.KEY2 = 'Excluded Objects'
		AND UPPER(O.OBJECT_NAME) = UPPER(L.VALUE)
		AND O.OBJECT_CATEGORY = L.KEY3;

	RETURN v_IDS;
END GET_EXCLUDED_OBJECT_ID_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SYSTEM_OBJECT_SCRIPT_XML
	(
	p_OBJECT_ID_LIST IN NUMBER_COLLECTION,
	p_PRODUCT_SCRIPT_TYPE IN VARCHAR2,
	p_EXPORT_MODE IN VARCHAR2,
	p_FILE OUT CLOB
	) AS

	v_COUNT BINARY_INTEGER;
	v_INDEX BINARY_INTEGER;
	v_MAIN_CLOB CLOB;
	v_REF_CLOB CLOB;
	v_CONDITIONAL_FORMAT_CLOB CLOB;
	v_MAIN_OBJECTS_XML XMLTYPE;
	v_REF_OBJECTS_XML XMLTYPE;
	v_CONDITIONAL_FORMATS_XML XMLTYPE;
	v_FULL_XML XMLTYPE;
	v_SHARED_MODULE_ID NUMBER(9);

	v_CONDITIONAL_FORMAT_IDS ID_TABLE := ID_TABLE();
	v_USED_OBJECT_IDS OBJECT_ID_MAP;
	v_REF_OBJECT_IDS OBJECT_ID_MAP;
	v_REF_OBJ_COUNT BINARY_INTEGER;

    v_OBJECT_CATEGORY SYSTEM_OBJECT.OBJECT_CATEGORY%TYPE;

	PROCEDURE APPEND_MAIN_CLOB(p_STR IN VARCHAR2) AS
	BEGIN
		DBMS_LOB.WRITEAPPEND(v_MAIN_CLOB, LENGTH(p_STR), p_STR);
	END;
	PROCEDURE APPEND_REF_CLOB(p_STR IN VARCHAR2) AS
	BEGIN
		DBMS_LOB.WRITEAPPEND(v_REF_CLOB, LENGTH(p_STR), p_STR);
	END;
	-----------------------------------------------------
	PROCEDURE ADD_REFERENCED_FORMATS(p_SYSTEM_OBJECT_ID IN NUMBER) AS
		CURSOR c_REFERENCED_FMTS IS
			SELECT B.CONDITIONAL_FORMAT_ID
			FROM SYSTEM_OBJECT_ATTRIBUTE A, CONDITIONAL_FORMAT B
			WHERE A.OBJECT_ID = p_SYSTEM_OBJECT_ID
				  AND A.ATTRIBUTE_ID = 28
				  AND B.CONDITIONAL_FORMAT_NAME = A.ATTRIBUTE_VAL;
	BEGIN
		--If this is a column, add its format if it has one.
		FOR v_REFERENCED_FMTS IN c_REFERENCED_FMTS LOOP
			v_CONDITIONAL_FORMAT_IDS.EXTEND();
			v_CONDITIONAL_FORMAT_IDS(v_CONDITIONAL_FORMAT_IDS.LAST) := ID_TYPE(v_REFERENCED_FMTS.CONDITIONAL_FORMAT_ID);
		END LOOP;
	END ADD_REFERENCED_FORMATS;
	-----------------------------------------------------
	PROCEDURE ADD_REFERENCED_OBJECTS(p_SYSTEM_OBJECT_ID IN NUMBER) AS
		v_OBJECT_CATEGORY VARCHAR2(32);
		v_BASE_CONFIG_NAMES VARCHAR2(4000);
		v_BASE_CONFIG_TABLE STRING_TABLE;
		v_REF_ID NUMBER(9);

		CURSOR c_BASE_CONFIGS IS
			SELECT OBJECT_ID
			FROM SYSTEM_OBJECT A
			WHERE A.PARENT_OBJECT_ID = v_SHARED_MODULE_ID
				  AND UPPER(A.OBJECT_NAME) IN (SELECT UPPER(X.STRING_VAL) FROM TABLE(CAST(v_BASE_CONFIG_TABLE AS STRING_TABLE)) X);

		PROCEDURE ADD_REF_OBJECT(p_OBJECT_ID IN NUMBER) AS
		BEGIN
			IF NOT (v_USED_OBJECT_IDS.EXISTS(p_OBJECT_ID) OR v_REF_OBJECT_IDS.EXISTS(p_OBJECT_ID)) THEN
				v_REF_OBJECT_IDS(p_OBJECT_ID) := 1;
			END IF;
		END ADD_REF_OBJECT;

	BEGIN
		SELECT OBJECT_CATEGORY INTO v_OBJECT_CATEGORY FROM SYSTEM_OBJECT WHERE OBJECT_ID = p_SYSTEM_OBJECT_ID;

		--Referenced Objects include the following:
		--  Shared Objects (for Anything)
		BEGIN
			SELECT B.OBJECT_ID
			INTO v_REF_ID
			FROM SYSTEM_OBJECT_ATTRIBUTE A, SYSTEM_OBJECT B
			WHERE A.OBJECT_ID = p_SYSTEM_OBJECT_ID
				  AND A.ATTRIBUTE_ID = -1
				  AND UPPER(B.OBJECT_NAME) = UPPER(A.ATTRIBUTE_VAL)
				  AND B.PARENT_OBJECT_ID = v_SHARED_MODULE_ID;
			ADD_REF_OBJECT(v_REF_ID);
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
				NULL;
		END;

		--  Base Grid Config (for Reports)
		IF v_OBJECT_CATEGORY = 'Report' THEN
			BEGIN
				SELECT ATTRIBUTE_VAL
				INTO v_BASE_CONFIG_NAMES
				FROM SYSTEM_OBJECT_ATTRIBUTE A
				WHERE A.OBJECT_ID = p_SYSTEM_OBJECT_ID
					  AND A.ATTRIBUTE_ID = 413;

				UT.STRING_TABLE_FROM_STRING(v_BASE_CONFIG_NAMES, ',', v_BASE_CONFIG_TABLE);

				FOR v_BASE_CONFIGS IN C_BASE_CONFIGS LOOP
					ADD_REF_OBJECT(v_BASE_CONFIGS.OBJECT_ID);
				END LOOP;

			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
					NULL;
			END;
		END IF;

		--  System Views (for Layouts)
		IF v_OBJECT_CATEGORY = 'Layout' THEN
			BEGIN
				SELECT B.OBJECT_ID
				INTO v_REF_ID
				FROM SYSTEM_OBJECT_ATTRIBUTE A, SYSTEM_OBJECT B
				WHERE A.OBJECT_ID = p_SYSTEM_OBJECT_ID
					  AND A.ATTRIBUTE_ID = 708
					  AND UPPER(B.OBJECT_NAME) = UPPER(A.ATTRIBUTE_VAL)
					  AND B.OBJECT_CATEGORY = 'System View';
				ADD_REF_OBJECT(v_REF_ID);
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
					NULL;
			END;
		END IF;

		--  Layouts, System Views (for Actions)
		--  These do not get exported.  In the future, this may change.
		--  If so, the following code could be used.
		/*
		IF v_OBJECT_CATEGORY = 'Action' THEN
			BEGIN
				SELECT C.OBJECT_ID
				INTO v_REF_ID
				FROM SYSTEM_OBJECT_ATTRIBUTE A, SYSTEM_OBJECT_ATTRIBUTE B, SYSTEM_OBJECT C
				WHERE A.OBJECT_ID = p_SYSTEM_OBJECT_ID
					  AND A.ATTRIBUTE_ID = 1006 -- Type
					  AND A.ATTRIBUTE_VAL IN ('1', '2') -- Layout and System View Action Type
					  AND B.OBJECT_ID = p_SYSTEM_OBJECT_ID
					  AND B.ATTRIBUTE_ID = 1007 -- Type Reference
					  AND C.OBJECT_NAME = B.ATTRIBUTE_VAL
					  AND C.OBJECT_CATEGORY = CASE A.ATTRIBUTE_VAL WHEN '1' THEN 'Layout' ELSE 'System View' END;

				ADD_REF_OBJECT(v_REF_ID);
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					NULL;
			END;
		END IF;
		*/

	END ADD_REFERENCED_OBJECTS;
	-----------------------------------------------------
	PROCEDURE GET_OBJECT_PATH_XML
		(
		p_SYSTEM_OBJECT_ID IN NUMBER,
		p_FOR_REPOSITORY IN BOOLEAN,
		p_PATH_XML OUT XMLTYPE
		) AS
		v_PATH_STR VARCHAR2(4000) := '';
		v_PARENT_COUNT BINARY_INTEGER := 0;
		CURSOR C_PARENTS IS
			SELECT *
			FROM SYSTEM_OBJECT A
			WHERE A.OBJECT_ID <> p_SYSTEM_OBJECT_ID
			START WITH A.OBJECT_ID = p_SYSTEM_OBJECT_ID
			CONNECT BY PRIOR A.PARENT_OBJECT_ID = A.OBJECT_ID
			ORDER BY LEVEL DESC;
	BEGIN
		IF p_FOR_REPOSITORY THEN
			-- all repository reports have one parent: ReportRepository
			SELECT XMLELEMENT("Path", XMLFOREST('ReportRepository' AS "name", 'Module' AS "category")) INTO p_PATH_XML FROM DUAL;
		ELSE
			FOR v_PARENTS IN C_PARENTS LOOP
				v_PATH_STR := v_PATH_STR || '<Path>';
				v_PATH_STR := v_PATH_STR || '<name>' || v_PARENTS.OBJECT_NAME || '</name>' || '<category>' || v_PARENTS.OBJECT_CATEGORY ||
							  '</category>';
				v_PARENT_COUNT := v_PARENT_COUNT + 1;
			END LOOP;
			IF v_PARENT_COUNT = 0 THEN
				v_PATH_STR := '<Path/>';
			ELSE
				FOR I IN 1 .. v_PARENT_COUNT LOOP
					v_PATH_STR := v_PATH_STR || '</Path>';
				END LOOP;
			END IF;
			p_PATH_XML := XMLTYPE.CREATEXML(v_PATH_STR);
		END IF;
	END GET_OBJECT_PATH_XML;
	-----------------------------------------------------
	PROCEDURE GET_OBJECT_COLUMNS_XMLFRAG
		(
		p_SYSTEM_OBJECT_ID IN NUMBER,
		p_COLS_XMLFRAG OUT XMLTYPE
		) AS
	BEGIN
		SELECT XMLFOREST(A.OBJECT_NAME AS "name",
			CASE A.OBJECT_INDEX WHEN 0 THEN NULL ELSE A.OBJECT_INDEX END AS "index",
			A.OBJECT_CATEGORY AS "category",
			CASE A.OBJECT_TYPE WHEN 'Default' THEN NULL ELSE A.OBJECT_TYPE END AS "type",
			A.OBJECT_ALIAS AS "alias",
			A.OBJECT_DESC AS "desc",
			A.OBJECT_DISPLAY_NAME AS "displayName",
			A.OBJECT_TAG AS "tag",
			A.OBJECT_ORDER AS "order",
			A.OBJECT_IS_HIDDEN AS "isHidden")
		INTO p_COLS_XMLFRAG
		FROM SYSTEM_OBJECT A
		WHERE A.OBJECT_ID = p_SYSTEM_OBJECT_ID;
	END GET_OBJECT_COLUMNS_XMLFRAG;
	-----------------------------------------------------
	PROCEDURE GET_OBJECT_ATTRIBUTES_XMLFRAG
		(
		p_SYSTEM_OBJECT_ID IN NUMBER,
		p_ATTRIBUTES_XMLFRAG OUT XMLTYPE
		) AS
	BEGIN

		SELECT XMLAGG(XMLELEMENT("Attribute",
			XMLATTRIBUTES(B.ATTRIBUTE_ID AS "id", A.ATTRIBUTE_NAME AS "name"),
			B.ATTRIBUTE_VAL))
		INTO p_ATTRIBUTES_XMLFRAG
		FROM SYSTEM_OBJECT_ATTRIBUTE B, SYSTEM_ATTRIBUTE A
		WHERE B.OBJECT_ID = p_SYSTEM_OBJECT_ID
			  AND A.ATTRIBUTE_ID = B.ATTRIBUTE_ID;

	END GET_OBJECT_ATTRIBUTES_XMLFRAG;
	-----------------------------------------------------
	PROCEDURE GET_OBJECT_CRYSTAL_XMLFRAG
		(
		p_SYSTEM_OBJECT_ID IN NUMBER,
		p_CRYSTAL_XMLFRAG OUT XMLTYPE
		) AS
		v_NUM_TEMPLATES NUMBER;
	BEGIN

		SELECT COUNT(1) INTO v_NUM_TEMPLATES FROM CRYSTAL_REPORT_FILES WHERE OBJECT_ID = p_SYSTEM_OBJECT_ID;

		IF v_NUM_TEMPLATES > 0 THEN
			SELECT XMLAGG(XMLELEMENT("CrystalTemplate",
									 XMLELEMENT("templateType", C.TEMPLATE_TYPE),
									 XMLELEMENT("reportFile", CD.BASE64ENCODE(UTL_COMPRESS.LZ_COMPRESS(C.REPORT_FILE)))))
			INTO p_CRYSTAL_XMLFRAG
			FROM CRYSTAL_REPORT_FILES C
			WHERE C.OBJECT_ID = p_SYSTEM_OBJECT_ID;
		ELSE
			p_CRYSTAL_XMLFRAG := NULL;
		END IF;

	END GET_OBJECT_CRYSTAL_XMLFRAG;
	-----------------------------------------------------
	PROCEDURE APPEND_SYSTEM_OBJECT_TO_CLOB
		(
		p_SYSTEM_OBJECT_ID IN NUMBER,
		p_PRODUCT_SCRIPT_TYPE IN VARCHAR2,
		p_IS_TOP_LEVEL_OBJECT IN NUMBER,
		p_IS_REPORT_REPOSITORY IN BOOLEAN,
		p_CLOB IN OUT NOCOPY CLOB
		) AS
		v_PATH_XML XMLTYPE;
		v_COLS_XMLFRAG XMLTYPE;
		v_ATTRIBUTES_XML XMLTYPE;
		v_CRYSTAL_XML XMLTYPE;

        -- Get all the children for the selected System Object
        CURSOR c_ALL_CHILDREN IS
			SELECT OBJECT_ID FROM SYSTEM_OBJECT
			WHERE PARENT_OBJECT_ID = p_SYSTEM_OBJECT_ID
			ORDER BY OBJECT_CATEGORY, OBJECT_NAME;

        -- Get all the children that belong to selected System Object's Product Script Type
        -- Use selected System Object's Product Script Type if Product Script Type is null for the child.
		CURSOR c_PROD_SCRIPT_CHILDREN IS
            SELECT O.OBJECT_ID, O.OBJECT_NAME, NVL(A.ATTRIBUTE_VAL, p_PRODUCT_SCRIPT_TYPE)
            FROM SYSTEM_OBJECT O, SYSTEM_OBJECT_ATTRIBUTE A
            WHERE PARENT_OBJECT_ID = p_SYSTEM_OBJECT_ID
                AND A.OBJECT_ID(+) = O.OBJECT_ID
                AND A.ATTRIBUTE_ID(+) = -7
                AND NVL(A.ATTRIBUTE_VAL, p_PRODUCT_SCRIPT_TYPE) = p_PRODUCT_SCRIPT_TYPE
            ORDER BY OBJECT_CATEGORY, OBJECT_NAME;

		PROCEDURE APPEND(p_CLOB_TO_APPEND IN CLOB) AS
		BEGIN
			DBMS_LOB.APPEND(p_CLOB, p_CLOB_TO_APPEND);
		END APPEND;
		PROCEDURE APPEND(p_STR IN VARCHAR2) AS
		BEGIN
			DBMS_LOB.WRITEAPPEND(p_CLOB, LENGTH(p_STR), p_STR);
		END;
	BEGIN

		--Check to see if we've already processed this object.  If we have, skip it to avoid circular references.
		IF v_USED_OBJECT_IDS.EXISTS(p_SYSTEM_OBJECT_ID) THEN
			RETURN;
		END IF;

		--Check to see if this is an "Excluded Object".  If it is, skip it.
		IF IS_EXCLUDED_OBJECT(p_SYSTEM_OBJECT_ID) THEN
			RETURN;
		END IF;

		APPEND('<Object>');

		--If this is a top level object, append its Path element.
		IF p_IS_TOP_LEVEL_OBJECT = 1 THEN
			GET_OBJECT_PATH_XML(p_SYSTEM_OBJECT_ID, p_IS_REPORT_REPOSITORY, v_PATH_XML);
			IF v_PATH_XML IS NOT NULL THEN
				APPEND(v_PATH_XML.GETCLOBVAL());
			END IF;
		END IF;

		--Append the elements for all the columns in the System Object table.
		GET_OBJECT_COLUMNS_XMLFRAG(p_SYSTEM_OBJECT_ID, v_COLS_XMLFRAG);
		APPEND(v_COLS_XMLFRAG.GETCLOBVAL());

		--Append an element for each System Object Attribute.
		GET_OBJECT_ATTRIBUTES_XMLFRAG(p_SYSTEM_OBJECT_ID, v_ATTRIBUTES_XML);
		IF v_ATTRIBUTES_XML IS NOT NULL THEN
			APPEND(v_ATTRIBUTES_XML.GETCLOBVAL());
		END IF;

		--Append the elements for any Crystal Report templates referenced by the Object.
		GET_OBJECT_CRYSTAL_XMLFRAG(p_SYSTEM_OBJECT_ID, v_CRYSTAL_XML);
		IF v_CRYSTAL_XML IS NOT NULL THEN
			APPEND(v_CRYSTAL_XML.GETCLOBVAL());
		END IF;

		--Add this object to the list of processed objects.
		v_USED_OBJECT_IDS(p_SYSTEM_OBJECT_ID) := 1;

		--Add any of its references to the ref objects list.
		ADD_REFERENCED_OBJECTS(p_SYSTEM_OBJECT_ID);

		--Add any of its referenced Conditional Formats to the Conditional Formats list.
		ADD_REFERENCED_FORMATS(p_SYSTEM_OBJECT_ID);

        -- Check if the System Object is a Layout
        SELECT OBJECT_CATEGORY INTO v_OBJECT_CATEGORY FROM SYSTEM_OBJECT WHERE OBJECT_ID = p_SYSTEM_OBJECT_ID;

        -- Regular Export
        IF p_EXPORT_MODE <> c_EMODE_PRODUCT_SCRIPT  THEN
            FOR v_CHILDREN IN C_ALL_CHILDREN LOOP
                APPEND_SYSTEM_OBJECT_TO_CLOB(v_CHILDREN.OBJECT_ID, p_PRODUCT_SCRIPT_TYPE, 0, FALSE, p_CLOB);
            END LOOP;
        -- Product Development Export
        ELSE
            FOR v_CHILDREN IN c_PROD_SCRIPT_CHILDREN LOOP
                APPEND_SYSTEM_OBJECT_TO_CLOB(v_CHILDREN.OBJECT_ID, p_PRODUCT_SCRIPT_TYPE, 0, FALSE, p_CLOB);
            END LOOP;
        END IF;

		APPEND('</Object>');

	END APPEND_SYSTEM_OBJECT_TO_CLOB;
	-------------------------------------------------------------------------
	PROCEDURE GET_CONDITIONAL_FORMAT_XML
		(
		p_CONDITIONAL_FORMAT_IDS IN ID_TABLE,
		p_CONDITIONAL_FORMAT_XML OUT XMLTYPE
		) AS
	BEGIN
		SELECT XMLELEMENT("ConditionalFormats",
			  XMLAGG(XMLELEMENT("ConditionalFormat",
					XMLFOREST(A.CONDITIONAL_FORMAT_NAME AS "name",
							  A.CONDITIONAL_FORMAT_ALIAS AS "alias",
							  A.CONDITIONAL_FORMAT_DESC AS "desc",
							  A.CONDITIONAL_FORMAT_MODULE AS "module"),
					(SELECT XMLAGG(XMLELEMENT("ConditionalFormatItem",
								  XMLFOREST(B.ITEM_NUMBER AS "itemNumber",
											B.COLOR_WHEN_FORMULA AS "colorWhenFormula",
											B.FOREGROUND_COLOR AS "foregroundColor",
											B.BACKGROUND_COLOR AS "backgroundColor",
											B.IS_BOLD AS "isBold",
											B.IS_ITALIC AS "isItalic",
											B.IS_STRIKE_THROUGH AS "isStrikeThrough",
											B.IS_UNDERLINE AS "isUnderline"))
								ORDER BY ITEM_NUMBER)
					 FROM CONDITIONAL_FORMAT_ITEM B
					 WHERE B.CONDITIONAL_FORMAT_ID = A.CONDITIONAL_FORMAT_ID))
				ORDER BY CONDITIONAL_FORMAT_NAME))
		INTO p_CONDITIONAL_FORMAT_XML
		FROM CONDITIONAL_FORMAT A
		WHERE A.CONDITIONAL_FORMAT_ID IN (SELECT DISTINCT X.ID FROM TABLE(CAST(p_CONDITIONAL_FORMAT_IDS AS ID_TABLE)) X);

		IF p_CONDITIONAL_FORMAT_XML IS NULL THEN
			p_CONDITIONAL_FORMAT_XML := XMLTYPE.CREATEXML('<ConditionalFormats/>');
		END IF;
	END GET_CONDITIONAL_FORMAT_XML;

BEGIN

	--Make sure the user is allowed to export a configuration.
	SD.VERIFY_ACTION_IS_ALLOWED(c_ACTION_SO_EXPORT);

	--Get the ID for the Shared Module.
	SO.ID_FOR_SYSTEM_OBJECT(0, 'Shared', 0, 'Module', 'Default', TRUE, v_SHARED_MODULE_ID);

	--Create <MainObjects> element
	DBMS_LOB.CREATETEMPORARY(v_MAIN_CLOB, TRUE);
	DBMS_LOB.OPEN(v_MAIN_CLOB, DBMS_LOB.LOB_READWRITE);
	v_COUNT := p_OBJECT_ID_LIST.COUNT;
	APPEND_MAIN_CLOB('<MainObjects>');
	FOR I IN 1 .. v_COUNT LOOP
        APPEND_SYSTEM_OBJECT_TO_CLOB(p_OBJECT_ID_LIST(I), p_PRODUCT_SCRIPT_TYPE, 1, p_EXPORT_MODE = c_EMODE_REPOSITORY, v_MAIN_CLOB);
	END LOOP;
	APPEND_MAIN_CLOB('</MainObjects>');
	v_MAIN_OBJECTS_XML := XMLTYPE.CREATEXML(v_MAIN_CLOB);
	DBMS_LOB.CLOSE(v_MAIN_CLOB);
	DBMS_LOB.FREETEMPORARY(v_MAIN_CLOB);

	--Create <ReferencedObjects> element
	DBMS_LOB.CREATETEMPORARY(v_REF_CLOB, TRUE);
	DBMS_LOB.OPEN(v_REF_CLOB, DBMS_LOB.LOB_READWRITE);
	APPEND_REF_CLOB('<ReferencedObjects>');
	LOOP
		v_INDEX := v_REF_OBJECT_IDS.FIRST;
		EXIT WHEN NOT v_REF_OBJECT_IDS.EXISTS(v_INDEX);

        -- Include all the reference objects for a regular export
        IF p_PRODUCT_SCRIPT_TYPE IS NULL THEN
            APPEND_SYSTEM_OBJECT_TO_CLOB(v_INDEX, p_PRODUCT_SCRIPT_TYPE, 1, FALSE, v_REF_CLOB);
        --  Include only the reference objects that belong to the Product Script
        ELSE
            SELECT COUNT(1) INTO v_REF_OBJ_COUNT FROM SYSTEM_OBJECT O, SYSTEM_OBJECT_ATTRIBUTE A
            WHERE O.OBJECT_ID = v_INDEX
                AND O.PARENT_OBJECT_ID = v_SHARED_MODULE_ID
                AND A.OBJECT_ID(+) = O.OBJECT_ID
                AND A.ATTRIBUTE_ID(+) = -7
                AND NVL(A.ATTRIBUTE_VAL, UPPER(c_PROD_SCRIPT_TYPE_CORE)) = UPPER(TRIM(p_PRODUCT_SCRIPT_TYPE));

            IF v_REF_OBJ_COUNT > 0 THEN
                --Each one of these is a top level element.
                APPEND_SYSTEM_OBJECT_TO_CLOB(v_INDEX, p_PRODUCT_SCRIPT_TYPE, 1, FALSE, v_REF_CLOB);
            END IF;
            v_REF_OBJ_COUNT := 0;
          END IF;
		v_REF_OBJECT_IDS.DELETE(v_INDEX);
	END LOOP;
	APPEND_REF_CLOB('</ReferencedObjects>');
	v_REF_OBJECTS_XML := XMLTYPE.CREATEXML(v_REF_CLOB);

	DBMS_LOB.CLOSE(v_REF_CLOB);
	DBMS_LOB.FREETEMPORARY(v_REF_CLOB);

	--Create <ConditionalFormats> element.
	--For some reason, converting the XML to a CLOB and back causes it to have proper
	--  line breaks.  If we don't do that, everything winds up on one line.
	GET_CONDITIONAL_FORMAT_XML(v_CONDITIONAL_FORMAT_IDS, v_CONDITIONAL_FORMATS_XML);
	v_CONDITIONAL_FORMAT_CLOB := v_CONDITIONAL_FORMATS_XML.GETCLOBVAL();
	v_CONDITIONAL_FORMATS_XML := XMLTYPE.CREATEXML(v_CONDITIONAL_FORMAT_CLOB);

	--If we only want conditional formats, clear out the other XML.
	IF p_EXPORT_MODE = c_EMODE_FORMATS_ONLY THEN
		SELECT XMLELEMENT("MainObjects") INTO v_MAIN_OBJECTS_XML FROM DUAL;
		SELECT XMLELEMENT("ReferencedObjects") INTO v_REF_OBJECTS_XML FROM DUAL;
	END IF;

	--Combine them into the main <SystemObjectConfiguration> element.
    IF p_EXPORT_MODE = c_EMODE_PRODUCT_SCRIPT THEN
        SELECT XMLELEMENT("SystemObjectConfiguration",
            XMLATTRIBUTES(c_CONFIG_NAMESPACE_NAME AS "xmlns",
                TO_CHAR(SYSDATE, c_XML_DATE_TIME_FORMAT) AS "scriptCreateDate",
                NVL(p_PRODUCT_SCRIPT_TYPE, c_PROD_SCRIPT_TYPE_CORE) AS "productScriptType",
                CASE p_EXPORT_MODE WHEN c_EMODE_PRODUCT_SCRIPT THEN '$Revision: 1.13 $' ELSE NULL END AS "productScriptRevision"),
            XMLCONCAT(v_MAIN_OBJECTS_XML, v_REF_OBJECTS_XML, v_CONDITIONAL_FORMATS_XML))
        INTO v_FULL_XML
        FROM DUAL;
    ELSE
        SELECT XMLELEMENT("SystemObjectConfiguration",
            XMLATTRIBUTES(c_CONFIG_NAMESPACE_NAME AS "xmlns",
                TO_CHAR(SYSDATE, c_XML_DATE_TIME_FORMAT) AS "scriptCreateDate",
                CASE p_EXPORT_MODE WHEN c_EMODE_PRODUCT_SCRIPT THEN '$Revision: 1.13 $' ELSE NULL END AS "productScriptRevision"),
            XMLCONCAT(v_MAIN_OBJECTS_XML, v_REF_OBJECTS_XML, v_CONDITIONAL_FORMATS_XML))
        INTO v_FULL_XML
        FROM DUAL;
    END IF;

	p_FILE := v_FULL_XML.GETCLOBVAL;

END GET_SYSTEM_OBJECT_SCRIPT_XML;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_PRODUCT_SCRIPT_XML
	(
	p_ENTITY_LIST IN VARCHAR2,
	p_FILE OUT CLOB
	) AS
    v_OBJECT_IDs NUMBER_COLLECTION;
    v_SHARED_MODULE_ID NUMBER(9);
BEGIN
    --Get the ID for the Shared Module.
	SO.ID_FOR_SYSTEM_OBJECT(0, 'Shared', 0, 'Module', 'Default', TRUE, v_SHARED_MODULE_ID);

    IF UPPER(p_ENTITY_LIST) = c_PROD_SCRIPT_TYPE_CORE THEN
	    GET_SYSTEM_OBJECT_SCRIPT_XML(NUMBER_COLLECTION(0), p_ENTITY_LIST, c_EMODE_PRODUCT_SCRIPT, p_FILE);
    ELSE
        SELECT OBJECT_ID
        BULK COLLECT INTO v_OBJECT_IDs
        FROM
            -- Hierarchical Query to get the first node that belongs to the Product Script Type
            (SELECT SO.OBJECT_ID, SO.OBJECT_NAME, SO.PRODUCT_SCRIPT_TYPE
            FROM
                -- Outer join to get the Product Script Type Attribute
                (SELECT O.OBJECT_ID, O.OBJECT_NAME, O.PARENT_OBJECT_ID, NVL(A.ATTRIBUTE_VAL, UPPER(c_PROD_SCRIPT_TYPE_CORE)) AS PRODUCT_SCRIPT_TYPE
                FROM SYSTEM_OBJECT O, SYSTEM_OBJECT_ATTRIBUTE A
                WHERE O.PARENT_OBJECT_ID <> v_SHARED_MODULE_ID
                    AND A.OBJECT_ID(+) = O.OBJECT_ID
                    AND A.ATTRIBUTE_ID(+) = -7) SO
            START WITH SO.OBJECT_ID = 0
            CONNECT BY PRIOR SO.OBJECT_ID = SO.PARENT_OBJECT_ID AND UPPER(PRIOR SO.PRODUCT_SCRIPT_TYPE) <> UPPER(p_ENTITY_LIST)
            ORDER BY SO.OBJECT_NAME)
        WHERE UPPER(PRODUCT_SCRIPT_TYPE) = UPPER(p_ENTITY_LIST);

        GET_SYSTEM_OBJECT_SCRIPT_XML(v_OBJECT_IDs, p_ENTITY_LIST, c_EMODE_PRODUCT_SCRIPT, p_FILE);
    END IF;
END GET_PRODUCT_SCRIPT_XML;
----------------------------------------------------------------------------------------------------

--===============================================
--     SYSTEM OBJECT XML IMPORT LOGIC
--===============================================

----------------------------------------------------------------------------------------------------
PROCEDURE IMPORT_CONDITIONAL_FORMATS
	(
	p_XML IN XMLTYPE,
	p_IMPORT_MODE IN VARCHAR2
	) AS

	v_CONDITIONAL_FORMAT_ID NUMBER(9);

	CURSOR C_FORMATS IS
		SELECT EXTRACTVALUE(VALUE(FMT), '/ConditionalFormat/name', c_CONFIG_NAMESPACE) "CONDITIONAL_FORMAT_NAME",
			   EXTRACTVALUE(VALUE(FMT), '/ConditionalFormat/alias', c_CONFIG_NAMESPACE) "CONDITIONAL_FORMAT_ALIAS",
			   EXTRACTVALUE(VALUE(FMT), '/ConditionalFormat/desc', c_CONFIG_NAMESPACE) "CONDITIONAL_FORMAT_DESC",
			   EXTRACTVALUE(VALUE(FMT), '/ConditionalFormat/module', c_CONFIG_NAMESPACE) "CONDITIONAL_FORMAT_MODULE",
			   EXTRACT(VALUE(FMT), '/ConditionalFormat/ConditionalFormatItem', c_CONFIG_NAMESPACE) "CONDITIONAL_FORMAT_ITEMS"
		FROM TABLE(XMLSEQUENCE(EXTRACT(p_XML, '/ConditionalFormats/ConditionalFormat', c_CONFIG_NAMESPACE))) FMT;

	-- INNER PROCEDURE ---
	PROCEDURE OVERWRITE_CONDITIONAL_FORMAT
		(
		p_CONDITIONAL_FORMAT_ID IN NUMBER,
		v_FORMAT IN C_FORMATS%ROWTYPE
		) AS
		v_ID NUMBER(9);
		CURSOR C_FORMAT_ITEMS IS
			SELECT EXTRACTVALUE(VALUE(ITEM), '/ConditionalFormatItem/itemNumber', c_CONFIG_NAMESPACE) "ITEM_NUMBER",
				   EXTRACTVALUE(VALUE(ITEM), '/ConditionalFormatItem/colorWhenFormula', c_CONFIG_NAMESPACE) "COLOR_WHEN_FORMULA",
				   EXTRACTVALUE(VALUE(ITEM), '/ConditionalFormatItem/foregroundColor', c_CONFIG_NAMESPACE) "FOREGROUND_COLOR",
				   EXTRACTVALUE(VALUE(ITEM), '/ConditionalFormatItem/backgroundColor', c_CONFIG_NAMESPACE) "BACKGROUND_COLOR",
				   EXTRACTVALUE(VALUE(ITEM), '/ConditionalFormatItem/isBold', c_CONFIG_NAMESPACE) "IS_BOLD",
				   EXTRACTVALUE(VALUE(ITEM), '/ConditionalFormatItem/isItalic', c_CONFIG_NAMESPACE) "IS_ITALIC",
				   EXTRACTVALUE(VALUE(ITEM), '/ConditionalFormatItem/isStrikeThrough', c_CONFIG_NAMESPACE) "IS_STRIKE_THROUGH",
				   EXTRACTVALUE(VALUE(ITEM), '/ConditionalFormatItem/isUnderline', c_CONFIG_NAMESPACE) "IS_UNDERLINE"
			FROM TABLE(XMLSEQUENCE(EXTRACT(v_FORMAT.CONDITIONAL_FORMAT_ITEMS, '/ConditionalFormatItem', c_CONFIG_NAMESPACE))) ITEM;
	BEGIN
		--Create the Format if it does not exist.
		IF p_CONDITIONAL_FORMAT_ID <= 0 THEN
			IO.PUT_CONDITIONAL_FORMAT(v_ID,
									  v_FORMAT.CONDITIONAL_FORMAT_NAME,
									  v_FORMAT.CONDITIONAL_FORMAT_ALIAS,
									  CASE WHEN v_FORMAT.CONDITIONAL_FORMAT_DESC = '?' THEN
									  'Created via Configuration Import on ' || UT.TRACE_DATE(SYSDATE) || '.' ELSE
									  v_FORMAT.CONDITIONAL_FORMAT_DESC END,
									  0,
									  v_FORMAT.CONDITIONAL_FORMAT_MODULE);
		--Wipe out its items if it does exist.
		ELSE
			v_ID := p_CONDITIONAL_FORMAT_ID;
			DELETE CONDITIONAL_FORMAT_ITEM WHERE CONDITIONAL_FORMAT_ID = v_ID;
		END IF;

		FOR v_ITEM IN C_FORMAT_ITEMS LOOP
			EM.PUT_CONDITIONAL_FORMAT_ITEM(v_ID,
										   v_ITEM.ITEM_NUMBER,
										   v_ITEM.COLOR_WHEN_FORMULA,
										   v_ITEM.FOREGROUND_COLOR,
										   v_ITEM.BACKGROUND_COLOR,
										   v_ITEM.IS_BOLD,
										   v_ITEM.IS_ITALIC,
										   v_ITEM.IS_STRIKE_THROUGH,
										   v_ITEM.IS_UNDERLINE);
		END LOOP;
	END OVERWRITE_CONDITIONAL_FORMAT;

	-- MAIN PROCEDURE --
BEGIN

	--Ignore this step for the See Differences mode.
	IF p_IMPORT_MODE = c_IMODE_DIFF THEN
		RETURN;
	END IF;

	FOR v_FORMAT IN C_FORMATS LOOP
		--See if we can find the existing format
		BEGIN
			v_CONDITIONAL_FORMAT_ID := EI.GET_ID_FROM_NAME(v_FORMAT.CONDITIONAL_FORMAT_NAME, EC.ED_CONDITIONAL_FORMAT);
		EXCEPTION
			WHEN MSGCODES.e_ERR_NO_SUCH_ENTRY THEN
				ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
				v_CONDITIONAL_FORMAT_ID := -1;
		END;

		--If Import Mode is "Overwrite" then wipe out and replace the Conditional Format.
		--Otherwise, insert the Conditional Format only if it does not exist.
		IF p_IMPORT_MODE IN (c_IMODE_OVERWRITE, c_IMODE_FMTS_OVERWRITE) OR v_CONDITIONAL_FORMAT_ID <= 0 THEN
			OVERWRITE_CONDITIONAL_FORMAT(v_CONDITIONAL_FORMAT_ID, v_FORMAT);
		END IF;
	END LOOP;
END IMPORT_CONDITIONAL_FORMATS;
----------------------------------------------------------------------------------------------------
FUNCTION GET_PREVIOUS_PRODUCT_IMPORT_ID
	(
	p_OBJECT_IMPORT_ID IN NUMBER := NULL,
	p_PRODUCT_SCRIPT_TYPE IN VARCHAR2
	) RETURN NUMBER IS
	v_THIS_IMPORT_DATE DATE;
	v_PREV_OBJECT_IMPORT_ID NUMBER;
	v_THIS_REVISION SYSTEM_OBJECT_IMPORT.PRODUCT_SCRIPT_REVISION%TYPE;
BEGIN

	--If the current import ID is not specified, just get the most recent.
	IF p_OBJECT_IMPORT_ID IS NULL THEN
		SELECT OBJECT_IMPORT_ID
		INTO v_PREV_OBJECT_IMPORT_ID
		FROM SYSTEM_OBJECT_IMPORT
		WHERE PRODUCT_SCRIPT_TYPE = p_PRODUCT_SCRIPT_TYPE
			AND IMPORTED_DATE =
				(SELECT MAX(IMPORTED_DATE)
				FROM SYSTEM_OBJECT_IMPORT
				WHERE PRODUCT_SCRIPT_TYPE = p_PRODUCT_SCRIPT_TYPE);
	--Otherwise, get the most recent import before the specified one.
	ELSE
		SELECT IMPORTED_DATE, PRODUCT_SCRIPT_REVISION
		INTO v_THIS_IMPORT_DATE, v_THIS_REVISION
		FROM SYSTEM_OBJECT_IMPORT
		WHERE OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID;

		SELECT OBJECT_IMPORT_ID
		INTO v_PREV_OBJECT_IMPORT_ID
		FROM SYSTEM_OBJECT_IMPORT
		WHERE PRODUCT_SCRIPT_TYPE = p_PRODUCT_SCRIPT_TYPE
			AND IMPORTED_DATE =
				(SELECT MAX(IMPORTED_DATE)
				FROM SYSTEM_OBJECT_IMPORT
				WHERE PRODUCT_SCRIPT_TYPE = p_PRODUCT_SCRIPT_TYPE
					AND IMPORTED_DATE < v_THIS_IMPORT_DATE
					AND PRODUCT_SCRIPT_REVISION <> v_THIS_REVISION);
	END IF;

	RETURN v_PREV_OBJECT_IMPORT_ID;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN -1;
END GET_PREVIOUS_PRODUCT_IMPORT_ID;
----------------------------------------------------------------------------------------------------
PROCEDURE ADD_OBJECT_AS_ITEM
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_OBJECT IN SYSTEM_OBJECT%ROWTYPE
	) AS
BEGIN
	--Add current object to Item table if it does not already exist.
	INSERT INTO SYSTEM_OBJECT_IMPORT_ITEM
		(
		OBJECT_IMPORT_ID,
		OBJECT_ID,
		PARENT_OBJECT_ID,
		OBJECT_NAME,
		OBJECT_INDEX,
		OBJECT_CATEGORY,
		OBJECT_TYPE
		)
	VALUES
		(
		p_OBJECT_IMPORT_ID,
		p_OBJECT.OBJECT_ID,
		p_OBJECT.PARENT_OBJECT_ID,
		p_OBJECT.OBJECT_NAME,
		p_OBJECT.OBJECT_INDEX,
		p_OBJECT.OBJECT_CATEGORY,
		p_OBJECT.OBJECT_TYPE
		);
EXCEPTION
	WHEN DUP_VAL_ON_INDEX THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		NULL; -- It's okay if it is already there.
END ADD_OBJECT_AS_ITEM;
----------------------------------------------------------------------------------------------------
PROCEDURE ADD_TO_IMPORT_LOG
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_OBJECT IN SYSTEM_OBJECT%ROWTYPE,
	p_IMPORT_SIDE IN VARCHAR2
	) AS
BEGIN
	--Add current object to Import Log table for this side
	INSERT INTO SYSTEM_OBJECT_IMPORT_LOG
		(
		OBJECT_IMPORT_ID,
		OBJECT_ID,
		IMPORT_SIDE,
		OBJECT_ALIAS,
		OBJECT_DESC,
		OBJECT_DISPLAY_NAME,
		OBJECT_TAG,
		OBJECT_ORDER,
		OBJECT_IS_HIDDEN,
		IS_MODIFIED,
		IS_OBJECT_PRESENT
		)
	VALUES
		(
		p_OBJECT_IMPORT_ID,
		p_OBJECT.OBJECT_ID,
		p_IMPORT_SIDE,
		p_OBJECT.OBJECT_ALIAS,
		p_OBJECT.OBJECT_DESC,
		p_OBJECT.OBJECT_DISPLAY_NAME,
		p_OBJECT.OBJECT_TAG,
		p_OBJECT.OBJECT_ORDER,
		p_OBJECT.OBJECT_IS_HIDDEN,
		p_OBJECT.IS_MODIFIED,
		1
		);
END ADD_TO_IMPORT_LOG;
----------------------------------------------------------------------------------------------------
PROCEDURE ADD_TO_IMPORT_ATTR_LOG
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_OBJECT_ATTRIBUTE IN SYSTEM_OBJECT_ATTRIBUTE%ROWTYPE,
	p_IMPORT_SIDE IN VARCHAR2
	) AS
BEGIN

	--Add attribute information to Attribute Log table for this side.
	INSERT INTO SYSTEM_OBJECT_IMPORT_ATTR_LOG
		(
		OBJECT_IMPORT_ID,
		OBJECT_ID,
		IMPORT_SIDE,
		ATTRIBUTE_ID,
		ATTRIBUTE_VAL
		)
	VALUES
		(
		p_OBJECT_IMPORT_ID,
		p_OBJECT_ATTRIBUTE.OBJECT_ID,
		p_IMPORT_SIDE,
		p_OBJECT_ATTRIBUTE.ATTRIBUTE_ID,
		p_OBJECT_ATTRIBUTE.ATTRIBUTE_VAL
		);

END ADD_TO_IMPORT_ATTR_LOG;
----------------------------------------------------------------------------------------------------
PROCEDURE ADD_TO_IMPORT_CRYSTAL
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_OBJECT_ID IN NUMBER,
	p_IMPORT_SIDE IN VARCHAR2,
	p_TEMPLATE_TYPE IN VARCHAR2,
	p_REPORT_FILE IN BLOB
	) AS
BEGIN

	--Add crystal report template to Crystal table for this side.
	INSERT INTO SYSTEM_OBJECT_IMPORT_CRYSTAL
		(
		OBJECT_IMPORT_ID,
		OBJECT_ID,
		IMPORT_SIDE,
		TEMPLATE_TYPE,
		REPORT_FILE
		)
	VALUES
		(
		p_OBJECT_IMPORT_ID,
		p_OBJECT_ID,
		p_IMPORT_SIDE,
		p_TEMPLATE_TYPE,
		p_REPORT_FILE
		);

END ADD_TO_IMPORT_CRYSTAL;
----------------------------------------------------------------------------------------------------
FUNCTION STORE_OBJECT_PATH
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_PATH IN XMLTYPE
	) RETURN NUMBER IS

	v_NEXT_PATH XMLTYPE;
	v_OBJECT SYSTEM_OBJECT%ROWTYPE;
BEGIN
	--Get the parent object ID, adding the path objects to the Key table as we go.
	--If path objects do not exist, create new IDs for them, and add them to the Item table.

	LOGS.LOG_DEBUG(SUBSTR('STORE_OBJECT_PATH path=' || p_PATH.GETSTRINGVAL(), 1, 4000));

	--Walk down the Hierarchical Path.
	v_NEXT_PATH := p_PATH;
	v_OBJECT.PARENT_OBJECT_ID := -1;
	WHILE v_NEXT_PATH IS NOT NULL LOOP

		--Get the outer-most path object so far in the path.
		SELECT EXTRACTVALUE(VALUE(OBJ), '/Path/name', c_CONFIG_NAMESPACE) "OBJECT_NAME",
			   EXTRACTVALUE(VALUE(OBJ), '/Path/category', c_CONFIG_NAMESPACE) "OBJECT_CATEGORY",
			   NVL(EXTRACTVALUE(VALUE(OBJ), '/Path/index', c_CONFIG_NAMESPACE), 0) "OBJECT_INDEX",
			   NVL(EXTRACTVALUE(VALUE(OBJ), '/Path/type', c_CONFIG_NAMESPACE), 'Default') "OBJECT_TYPE",
			   EXTRACT(VALUE(OBJ), 'Path/Path', c_CONFIG_NAMESPACE) "NEXT_PATH"
		INTO v_OBJECT.OBJECT_NAME, v_OBJECT.OBJECT_CATEGORY, v_OBJECT.OBJECT_INDEX, v_OBJECT.OBJECT_TYPE, v_NEXT_PATH
		FROM TABLE(XMLSEQUENCE(EXTRACT(v_NEXT_PATH, '/Path', c_CONFIG_NAMESPACE))) OBJ;

		LOGS.LOG_DEBUG('Next Path Element: parent=' || v_OBJECT.PARENT_OBJECT_ID || ' name=' || v_OBJECT.OBJECT_NAME || ' index=' ||
					   v_OBJECT.OBJECT_INDEX || ' category=' || v_OBJECT.OBJECT_CATEGORY || ' type=' || v_OBJECT.OBJECT_TYPE);

		--If this is an Excluded Object, do not create it.  Return -3 as the parent ID so
		--  that we do not continue importing this object.
		IF IS_EXCLUDED_OBJECT(v_OBJECT.OBJECT_CATEGORY, v_OBJECT.OBJECT_NAME) THEN
			LOGS.LOG_WARN('Configuration for the Excluded Object "'||v_OBJECT.OBJECT_NAME||'" was found in this import.  This configuration was ignored.');
			RETURN c_EXCLUDED_OBJECT;
		END IF;

		--Find its ID.
		SO.ID_FOR_SYSTEM_OBJECT(v_OBJECT.PARENT_OBJECT_ID,
								v_OBJECT.OBJECT_NAME,
								v_OBJECT.OBJECT_INDEX,
								v_OBJECT.OBJECT_CATEGORY,
								v_OBJECT.OBJECT_TYPE,
								FALSE,
								v_OBJECT.OBJECT_ID);

		LOGS.LOG_DEBUG('  id= ' || v_OBJECT.OBJECT_ID);

		--Create a new ID if the object does not exist.
		IF v_OBJECT.OBJECT_ID < 0 THEN
			SELECT MID.NEXTVAL INTO v_OBJECT.OBJECT_ID FROM DUAL;
		END IF;

		--Add current object to Item table if it does not already exist.
		ADD_OBJECT_AS_ITEM(p_OBJECT_IMPORT_ID, v_OBJECT);

		--Get ready for the next loop.
		v_OBJECT.PARENT_OBJECT_ID := v_OBJECT.OBJECT_ID;
	END LOOP;

	--Return the lowest ID.
	RETURN v_OBJECT.OBJECT_ID;

END STORE_OBJECT_PATH;
----------------------------------------------------------------------------------------------------
PROCEDURE STORE_ORIGINAL_OBJECT_DATA
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_STARTING_OBJECT_ID IN NUMBER
	) AS

	v_OBJECT_ID NUMBER(9);
	v_EXCLUDED_OBJECTS NUMBER_COLLECTION := GET_EXCLUDED_OBJECT_ID_LIST;

	-- Get the list of all children of the starting object, excluding any excluded objects
	--   that are marked as "excluded" and any of their children.
	CURSOR c_OBJECTS IS
		SELECT O.* FROM SYSTEM_OBJECT O START WITH OBJECT_ID = p_STARTING_OBJECT_ID
		CONNECT BY PRIOR OBJECT_ID = PARENT_OBJECT_ID
			AND OBJECT_ID NOT IN (SELECT X.COLUMN_VALUE FROM TABLE(CAST(v_EXCLUDED_OBJECTS AS NUMBER_COLLECTION)) X);

	CURSOR c_ATTRIBUTES IS
		SELECT A.* FROM SYSTEM_OBJECT_ATTRIBUTE A WHERE OBJECT_ID = v_OBJECT_ID;

	CURSOR c_CRYSTAL IS
		SELECT C.* FROM CRYSTAL_REPORT_FILES C WHERE C.OBJECT_ID = v_OBJECT_ID;

BEGIN
	--If this is a top-level and pre-existing object,  grab its existing Hierarchy to put
	--  into the "Original" side of the Log tables, and in the Item table.

	FOR v_OBJECT IN c_OBJECTS LOOP
		v_OBJECT_ID := v_OBJECT.OBJECT_ID;

		--Add to the Item table if it does not already exist.
		ADD_OBJECT_AS_ITEM(p_OBJECT_IMPORT_ID, v_OBJECT);

		--Add to the Object table for the "Original" side.
		ADD_TO_IMPORT_LOG(p_OBJECT_IMPORT_ID, v_OBJECT, c_SIDE_ORIGINAL);

		--Add the attributes
		FOR v_ATTR IN c_ATTRIBUTES LOOP
			ADD_TO_IMPORT_ATTR_LOG(p_OBJECT_IMPORT_ID, v_ATTR, c_SIDE_ORIGINAL);
		END LOOP;

		--Add any Crystal Templates
		FOR v_CRYSTAL IN c_CRYSTAL LOOP
			ADD_TO_IMPORT_CRYSTAL(p_OBJECT_IMPORT_ID, v_OBJECT_ID, c_SIDE_ORIGINAL, v_CRYSTAL.TEMPLATE_TYPE, v_CRYSTAL.REPORT_FILE);
		END LOOP;

	END LOOP;
END STORE_ORIGINAL_OBJECT_DATA;
----------------------------------------------------------------------------------------------------
PROCEDURE STORE_IMPORTED_OBJECT_DATA
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_ATTRIBUTES IN XMLTYPE,
	p_CRYSTAL IN XMLTYPE,
	p_OBJECT IN SYSTEM_OBJECT%ROWTYPE
	) AS

	CURSOR c_ATTRIBUTES IS
		SELECT p_OBJECT.OBJECT_ID "OBJECT_ID",
			TO_NUMBER(EXTRACTVALUE(VALUE(OBJ), '/Attribute/@id', c_CONFIG_NAMESPACE)) "ATTRIBUTE_ID",
			EXTRACTVALUE(VALUE(OBJ), '/Attribute', c_CONFIG_NAMESPACE) "ATTRIBUTE_VAL"
		FROM TABLE(XMLSEQUENCE(EXTRACT(p_ATTRIBUTES, '/Attribute', c_CONFIG_NAMESPACE))) OBJ;

	CURSOR c_CRYSTAL IS
		SELECT EXTRACTVALUE(VALUE(OBJ), '/CrystalTemplate/templateType', c_CONFIG_NAMESPACE) "TEMPLATE_TYPE",
			UTL_COMPRESS.LZ_UNCOMPRESS(CD.BASE64DECODE(EXTRACT(VALUE(OBJ), '/CrystalTemplate/reportFile/text()', c_CONFIG_NAMESPACE).GETCLOBVAL())) "REPORT_FILE"
		FROM TABLE(XMLSEQUENCE(EXTRACT(p_CRYSTAL, '/CrystalTemplate', c_CONFIG_NAMESPACE))) OBJ;

BEGIN

	--Add to the Object table for the "Imported" side.
	ADD_TO_IMPORT_LOG(p_OBJECT_IMPORT_ID, p_OBJECT, c_SIDE_IMPORTED);

	--Add the attributes
	FOR v_ATTR IN c_ATTRIBUTES LOOP
		ADD_TO_IMPORT_ATTR_LOG(p_OBJECT_IMPORT_ID, v_ATTR, c_SIDE_IMPORTED);
	END LOOP;

	--Add the crystal templates
	FOR v_CRYSTAL IN c_CRYSTAL LOOP
		ADD_TO_IMPORT_CRYSTAL(p_OBJECT_IMPORT_ID, p_OBJECT.OBJECT_ID, c_SIDE_IMPORTED, v_CRYSTAL.TEMPLATE_TYPE, v_CRYSTAL.REPORT_FILE);
	END LOOP;

END STORE_IMPORTED_OBJECT_DATA;
----------------------------------------------------------------------------------------------------
-- See if there are any differences in crystal templates between the
--   object in Import 1 and Side 1 and the object in Import 2 and Side 2.
FUNCTION SEE_IF_CRYSTAL_SIDES_DIFFER
	(
	p_OBJECT_IMPORT_ID_1 IN NUMBER,
	p_IMPORT_SIDE_1 IN VARCHAR2,
	p_OBJECT_IMPORT_ID_2 IN NUMBER,
	p_IMPORT_SIDE_2 IN VARCHAR2,
	p_OBJECT_ID IN NUMBER
	) RETURN NUMBER IS

CURSOR c_TYPES IS
	SELECT DISTINCT TEMPLATE_TYPE
	FROM SYSTEM_OBJECT_IMPORT_CRYSTAL
	WHERE ((OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID_1 AND IMPORT_SIDE = p_IMPORT_SIDE_1)
			OR (OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID_2 AND IMPORT_SIDE = p_IMPORT_SIDE_2))
		AND OBJECT_ID = p_OBJECT_ID;

	v_BLOB1 BLOB;
	v_BLOB2 BLOB;
BEGIN

	FOR v_TYPE IN c_TYPES LOOP
		SELECT REPORT_FILE INTO v_BLOB1
		FROM SYSTEM_OBJECT_IMPORT_CRYSTAL
		WHERE OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID_1
			AND OBJECT_ID = p_OBJECT_ID
			AND TEMPLATE_TYPE = v_TYPE.TEMPLATE_TYPE
			AND IMPORT_SIDE = p_IMPORT_SIDE_1;

		SELECT REPORT_FILE INTO v_BLOB2
		FROM SYSTEM_OBJECT_IMPORT_CRYSTAL
		WHERE OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID_2
			AND OBJECT_ID = p_OBJECT_ID
			AND TEMPLATE_TYPE = v_TYPE.TEMPLATE_TYPE
			AND IMPORT_SIDE = p_IMPORT_SIDE_2;

		--The compare function returns 0 if the BLOBs are the same.
		--If they are not the same, then we have found a difference.
		IF DBMS_LOB.COMPARE(v_BLOB1, v_BLOB2) > 0 THEN
			RETURN 1;
		END IF;
	END LOOP;

	RETURN 0;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		--if one of the blobs does not exist, then we have found a difference.
		RETURN 1;

END SEE_IF_CRYSTAL_SIDES_DIFFER;
----------------------------------------------------------------------------------------------------
--See if there are any differences in crystal templates between the
--  "Imported" and "Original" sides of the specified import.
FUNCTION SEE_IF_CRYSTAL_SIDES_DIFFER
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_OBJECT_ID IN NUMBER
	) RETURN NUMBER IS
BEGIN
	RETURN SEE_IF_CRYSTAL_SIDES_DIFFER(p_OBJECT_IMPORT_ID, c_SIDE_ORIGINAL, p_OBJECT_IMPORT_ID, c_SIDE_IMPORTED, p_OBJECT_ID);
END SEE_IF_CRYSTAL_SIDES_DIFFER;
----------------------------------------------------------------------------------------------------
-- See if there are any differences this object, its attributes, or its crystal templates between the
--   object in Import 1 and Side 1 and the object in Import 2 and Side 2.
FUNCTION SEE_IF_SIDES_DIFFER
	(
	p_OBJECT_IMPORT_ID_1 IN NUMBER,
	p_IMPORT_SIDE_1 IN VARCHAR2,
	p_OBJECT_IMPORT_ID_2 IN NUMBER,
	p_IMPORT_SIDE_2 IN VARCHAR2,
	p_OBJECT_ID IN NUMBER
	) RETURN NUMBER IS
	v_RTN NUMBER(1);

	FUNCTION GET_OBJECT_STRING (p_OBJECT_IMPORT_ID IN NUMBER, p_IMPORT_SIDE IN VARCHAR2) RETURN VARCHAR2 IS
		v_STR VARCHAR2(4000);
	BEGIN
		SELECT OBJECT_ALIAS ||SEP|| OBJECT_DESC ||SEP|| OBJECT_DISPLAY_NAME ||SEP|| OBJECT_TAG ||SEP|| OBJECT_ORDER ||SEP|| OBJECT_IS_HIDDEN "STR"
		INTO v_STR
		FROM SYSTEM_OBJECT_IMPORT_LOG
		WHERE OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID
			AND OBJECT_ID = p_OBJECT_ID
			AND IMPORT_SIDE = p_IMPORT_SIDE;
		RETURN v_STR;
	EXCEPTION
		WHEN OTHERS THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN NULL;
	END GET_OBJECT_STRING;
BEGIN

	IF GET_OBJECT_STRING(p_OBJECT_IMPORT_ID_1, p_IMPORT_SIDE_1) = GET_OBJECT_STRING(p_OBJECT_IMPORT_ID_2, p_IMPORT_SIDE_2) THEN
		SELECT CASE COUNT(1) WHEN 0 THEN 0 ELSE 1 END
		INTO v_RTN
		FROM
			(
			--This query first gathers together the full set of attributes and values in both
			--  sides of the import.  Then it subtracts all the rows that are the same in both.
			--  If the result is that we are left with no rows, then we have no differences.
			--  However, if some rows are returned, then there were some differences between the two sides.
			SELECT DISTINCT ATTRIBUTE_ID, ATTRIBUTE_VAL
			FROM SYSTEM_OBJECT_IMPORT_ATTR_LOG
			WHERE ((OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID_1 AND IMPORT_SIDE = p_IMPORT_SIDE_1)
					OR (OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID_2 AND IMPORT_SIDE = p_IMPORT_SIDE_2))
				AND OBJECT_ID = p_OBJECT_ID
			MINUS
				(
				SELECT ATTRIBUTE_ID, ATTRIBUTE_VAL
				FROM SYSTEM_OBJECT_IMPORT_ATTR_LOG
				WHERE OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID_1
					AND OBJECT_ID = p_OBJECT_ID
					AND IMPORT_SIDE = p_IMPORT_SIDE_1
				INTERSECT
				SELECT ATTRIBUTE_ID, ATTRIBUTE_VAL
				FROM SYSTEM_OBJECT_IMPORT_ATTR_LOG
				WHERE OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID_2
					AND OBJECT_ID = p_OBJECT_ID
					AND IMPORT_SIDE = p_IMPORT_SIDE_2
				)
			);
		IF v_RTN = 0 THEN
			v_RTN := SEE_IF_CRYSTAL_SIDES_DIFFER(p_OBJECT_IMPORT_ID_1, p_IMPORT_SIDE_1, p_OBJECT_IMPORT_ID_2, p_IMPORT_SIDE_2, p_OBJECT_ID);
		END IF;
	ELSE
		v_RTN := 1;
	END IF;

	RETURN v_RTN;

END SEE_IF_SIDES_DIFFER;
----------------------------------------------------------------------------------------------------
-- See if there are any differences this object, its attributes, or its crystal templates between the
--   "Original" and "Imported" sides of the specified import.
FUNCTION SEE_IF_SIDES_DIFFER
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_OBJECT_ID IN NUMBER
	) RETURN NUMBER IS
BEGIN
	RETURN SEE_IF_SIDES_DIFFER(p_OBJECT_IMPORT_ID, c_SIDE_ORIGINAL, p_OBJECT_IMPORT_ID, c_SIDE_IMPORTED, p_OBJECT_ID);
END SEE_IF_SIDES_DIFFER;
----------------------------------------------------------------------------------------------------
FUNCTION SEE_IF_CRYSTAL_DIFFER_FROM_OBJ
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_OBJECT_ID IN NUMBER,
	p_IMPORT_SIDE IN VARCHAR2
	) RETURN NUMBER IS

CURSOR c_TYPES IS
	SELECT DISTINCT TEMPLATE_TYPE
	FROM
		(SELECT TEMPLATE_TYPE
		FROM SYSTEM_OBJECT_IMPORT_CRYSTAL
		WHERE OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID
			AND OBJECT_ID = p_OBJECT_ID
			AND IMPORT_SIDE = p_IMPORT_SIDE
		UNION ALL
		SELECT TEMPLATE_TYPE
		FROM CRYSTAL_REPORT_FILES
		WHERE OBJECT_ID = p_OBJECT_ID);

	v_BLOB1 BLOB;
	v_BLOB2 BLOB;
BEGIN

	--See if there are any differences in crystal templates between the
	--  specified side ("Imported" or "Original") and what is currently in the System Object tables.
	FOR v_TYPE IN c_TYPES LOOP
		SELECT REPORT_FILE INTO v_BLOB1
		FROM SYSTEM_OBJECT_IMPORT_CRYSTAL
		WHERE OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID
			AND OBJECT_ID = p_OBJECT_ID
			AND IMPORT_SIDE = p_IMPORT_SIDE
			AND TEMPLATE_TYPE = v_TYPE.TEMPLATE_TYPE;

		SELECT REPORT_FILE INTO v_BLOB2
		FROM CRYSTAL_REPORT_FILES
		WHERE OBJECT_ID = p_OBJECT_ID
			AND TEMPLATE_TYPE = v_TYPE.TEMPLATE_TYPE;

		--The compare function returns 0 if the BLOBs are the same.
		--If they are not the same, then we have found a difference.
		IF DBMS_LOB.COMPARE(v_BLOB1, v_BLOB2) > 0 THEN
			RETURN 1;
		END IF;
	END LOOP;

	RETURN 0;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		--if one of the blobs does not exist, then we have found a difference.
		RETURN 1;
END SEE_IF_CRYSTAL_DIFFER_FROM_OBJ;
----------------------------------------------------------------------------------------------------
FUNCTION SEE_IF_SIDE_DIFFERS_FROM_OBJ
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_OBJECT_ID IN NUMBER,
	p_IMPORT_SIDE IN VARCHAR2
	) RETURN NUMBER IS
	v_RTN NUMBER(1);
	v_OBJECT_STRING VARCHAR2(4000);
	v_SIDE_STRING VARCHAR2(4000);

	FUNCTION GET_OBJECT_STRING_SIDE RETURN VARCHAR2 IS
		v_STR VARCHAR2(4000);
	BEGIN
		SELECT OBJECT_ALIAS ||SEP|| OBJECT_DESC ||SEP|| OBJECT_DISPLAY_NAME ||SEP|| OBJECT_TAG ||SEP|| OBJECT_ORDER ||SEP|| OBJECT_IS_HIDDEN "STR"
		INTO v_STR
		FROM SYSTEM_OBJECT_IMPORT_LOG
		WHERE OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID
			AND OBJECT_ID = p_OBJECT_ID
			AND IMPORT_SIDE = p_IMPORT_SIDE;
		RETURN v_STR;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN NULL;
	END GET_OBJECT_STRING_SIDE;

	FUNCTION GET_OBJECT_STRING_OBJ RETURN VARCHAR2 IS
		v_STR VARCHAR2(4000);
	BEGIN
		SELECT OBJECT_ALIAS ||SEP|| OBJECT_DESC ||SEP|| OBJECT_DISPLAY_NAME ||SEP|| OBJECT_TAG ||SEP|| OBJECT_ORDER ||SEP|| OBJECT_IS_HIDDEN "STR"
		INTO v_STR
		FROM SYSTEM_OBJECT
		WHERE OBJECT_ID = p_OBJECT_ID;
		RETURN v_STR;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN NULL;
	END GET_OBJECT_STRING_OBJ;
BEGIN

	--See if there are any differences in this object, its attributes, or its crystal templates between the
	--  specified sid ("Imported" or "Original") and what is currently in the System Object tables.

	v_OBJECT_STRING := GET_OBJECT_STRING_OBJ;
	v_SIDE_STRING := GET_OBJECT_STRING_SIDE;

	IF v_OBJECT_STRING IS NULL AND v_SIDE_STRING IS NULL THEN
		v_RTN := 0;
	ELSIF v_SIDE_STRING = v_OBJECT_STRING THEN
		SELECT CASE COUNT(1) WHEN 0 THEN 0 ELSE 1 END
		INTO v_RTN
		FROM
			(
				(
				SELECT ATTRIBUTE_ID, ATTRIBUTE_VAL
				FROM SYSTEM_OBJECT_IMPORT_ATTR_LOG
				WHERE OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID
					AND OBJECT_ID = p_OBJECT_ID
					AND IMPORT_SIDE = p_IMPORT_SIDE
				UNION
				SELECT ATTRIBUTE_ID, ATTRIBUTE_VAL
				FROM SYSTEM_OBJECT_ATTRIBUTE
				WHERE OBJECT_ID = p_OBJECT_ID
				)
			MINUS
				(
				SELECT ATTRIBUTE_ID, ATTRIBUTE_VAL
				FROM SYSTEM_OBJECT_IMPORT_ATTR_LOG
				WHERE OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID
					AND OBJECT_ID = p_OBJECT_ID
					AND IMPORT_SIDE = p_IMPORT_SIDE
				INTERSECT
				SELECT ATTRIBUTE_ID, ATTRIBUTE_VAL
				FROM SYSTEM_OBJECT_ATTRIBUTE
				WHERE OBJECT_ID = p_OBJECT_ID
				)
			);

		IF v_RTN = 0 THEN
			v_RTN := SEE_IF_CRYSTAL_DIFFER_FROM_OBJ(p_OBJECT_IMPORT_ID, p_OBJECT_ID, p_IMPORT_SIDE);
		END IF;
	ELSE
		v_RTN := 1;
	END IF;

	RETURN v_RTN;

END SEE_IF_SIDE_DIFFERS_FROM_OBJ;
----------------------------------------------------------------------------------------------------
FUNCTION IS_SYSTEM_OBJECT_IN_SIDE
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_OBJECT_ID IN NUMBER,
	p_IMPORT_SIDE IN VARCHAR2
	) RETURN BOOLEAN IS
	v_COUNT NUMBER := 0;
BEGIN
	--See if an object with this ID exists in the SYSTEM_OBJECT_IMPORT_SIDE table for the specified import and side.
	SELECT NVL(MAX(IS_OBJECT_PRESENT),0) INTO v_COUNT
	FROM SYSTEM_OBJECT_IMPORT_LOG
	WHERE OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID
		AND OBJECT_ID = p_OBJECT_ID
		AND IMPORT_SIDE = p_IMPORT_SIDE;

	RETURN v_COUNT = 1;

END IS_SYSTEM_OBJECT_IN_SIDE;
----------------------------------------------------------------------------------------------------
FUNCTION SET_MERGE_TYPES
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_PRODUCT_SCRIPT_TYPE IN VARCHAR2
	) RETURN NUMBER IS

	v_NUM_CONFLICTS NUMBER := 0;
	v_MERGE_TYPE VARCHAR2(16) := NULL;
	v_IMPORT_IS_MODIFIED NUMBER(1) := NULL;
	v_PREV_PROJECT_IMPORT_ID NUMBER(9);
	v_PREV_EXISTS BOOLEAN;
    v_IS_PRODUCT_SCRIPT NUMBER(1) := 0;

	CURSOR c_OBJECTS IS
		SELECT ITEM.OBJECT_ID,
			NVL(LOG_O.IS_OBJECT_PRESENT,0) "PRESENT_IN_ORIGINAL",
			NVL(LOG_I.IS_OBJECT_PRESENT,0) "PRESENT_IN_IMPORTED",
			LOG_O.IS_MODIFIED "ORIGINAL_IS_MODIFIED"
		FROM SYSTEM_OBJECT_IMPORT_ITEM ITEM,
			SYSTEM_OBJECT_IMPORT_LOG LOG_O,
			SYSTEM_OBJECT_IMPORT_LOG LOG_I
		WHERE ITEM.OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID
			AND LOG_O.OBJECT_IMPORT_ID(+) = ITEM.OBJECT_IMPORT_ID
			AND LOG_O.OBJECT_ID(+) = ITEM.OBJECT_ID
			AND LOG_O.IMPORT_SIDE(+) = c_SIDE_ORIGINAL
			AND LOG_I.OBJECT_IMPORT_ID(+) = ITEM.OBJECT_IMPORT_ID
			AND LOG_I.OBJECT_ID(+) = ITEM.OBJECT_ID
			AND LOG_I.IMPORT_SIDE(+) = c_SIDE_IMPORTED;
BEGIN
	v_PREV_PROJECT_IMPORT_ID := GET_PREVIOUS_PRODUCT_IMPORT_ID(p_OBJECT_IMPORT_ID, p_PRODUCT_SCRIPT_TYPE);

	v_PREV_EXISTS := v_PREV_PROJECT_IMPORT_ID > 0;
    v_IS_PRODUCT_SCRIPT := CASE WHEN p_PRODUCT_SCRIPT_TYPE IS NULL THEN 0 ELSE 1 END;

	--Take a pass through the objects in the import and set each object's Merge Type
	--and Imported IS_MODIFIED value.  Return the number of Conflict merge types we found.
	FOR v_OBJ IN c_OBJECTS LOOP

		--This is a path object.
		IF v_OBJ.PRESENT_IN_ORIGINAL = 0 AND v_OBJ.PRESENT_IN_IMPORTED = 0 THEN
			v_MERGE_TYPE := NULL;
			v_IMPORT_IS_MODIFIED := NULL;
		--This object is added by the import.
		ELSIF v_OBJ.PRESENT_IN_ORIGINAL = 0 AND v_OBJ.PRESENT_IN_IMPORTED = 1 THEN
			v_MERGE_TYPE := c_MERGE_TYPE_ADD;
			v_IMPORT_IS_MODIFIED := CASE v_IS_PRODUCT_SCRIPT WHEN 1 THEN 0 ELSE 1 END;
		--This object is deleted by the import.
		ELSIF v_OBJ.PRESENT_IN_ORIGINAL = 1 AND v_OBJ.PRESENT_IN_IMPORTED = 0 THEN
			--If we are importing a product script, and this object did not exist the last time we imported
			--  a product script, then it was never part of the product, and we should just ignore it.
			IF v_IS_PRODUCT_SCRIPT = 1 AND v_PREV_EXISTS AND NOT IS_SYSTEM_OBJECT_IN_SIDE(v_PREV_PROJECT_IMPORT_ID, v_OBJ.OBJECT_ID, c_SIDE_IMPORTED) THEN
				v_MERGE_TYPE := c_MERGE_TYPE_IGNORE_DELETE;
			ELSE
				v_MERGE_TYPE := CASE v_OBJ.ORIGINAL_IS_MODIFIED WHEN 1 THEN c_MERGE_TYPE_CONFLICT_DELETE ELSE c_MERGE_TYPE_DELETE END;
			END IF;
			v_IMPORT_IS_MODIFIED := NULL;
		--This object exists in both and is the same across both.
		ELSIF SEE_IF_SIDES_DIFFER(p_OBJECT_IMPORT_ID, v_OBJ.OBJECT_ID) = 0 THEN
			v_MERGE_TYPE := c_MERGE_TYPE_NO_DIFF;
			v_IMPORT_IS_MODIFIED := CASE WHEN v_IS_PRODUCT_SCRIPT = 0 AND v_OBJ.ORIGINAL_IS_MODIFIED = 1 THEN 1 ELSE 0 END;
		--This object exists in both, but is different.
		ELSE
			--If we are importing a product script, and the imported value is the same
			--  as it was the last time we imported a product script, then just ignore it.
			IF v_IS_PRODUCT_SCRIPT = 1 AND v_PREV_EXISTS AND SEE_IF_SIDES_DIFFER(v_PREV_PROJECT_IMPORT_ID, c_SIDE_IMPORTED, p_OBJECT_IMPORT_ID, c_SIDE_IMPORTED, v_OBJ.OBJECT_ID) = 0 THEN
				v_MERGE_TYPE := c_MERGE_TYPE_IGNORE_CHANGE;
			ELSE
				v_MERGE_TYPE := CASE v_OBJ.ORIGINAL_IS_MODIFIED WHEN 1 THEN c_MERGE_TYPE_CONFLICT ELSE c_MERGE_TYPE_CHANGE END;
			END IF;
			v_IMPORT_IS_MODIFIED := CASE v_IS_PRODUCT_SCRIPT WHEN 1 THEN 0 ELSE 1 END;
		END IF;

		UPDATE SYSTEM_OBJECT_IMPORT_ITEM
		SET MERGE_TYPE = v_MERGE_TYPE
		WHERE OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID
			AND OBJECT_ID = v_OBJ.OBJECT_ID;

		UPDATE SYSTEM_OBJECT_IMPORT_LOG
		SET IS_MODIFIED = v_IMPORT_IS_MODIFIED
		WHERE OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID
			AND OBJECT_ID = v_OBJ.OBJECT_ID
			AND IMPORT_SIDE = c_SIDE_IMPORTED;

		IF v_MERGE_TYPE IN (c_MERGE_TYPE_CONFLICT, c_MERGE_TYPE_CONFLICT_DELETE) THEN
			v_NUM_CONFLICTS := v_NUM_CONFLICTS + 1;
		END IF;

	END LOOP;

	RETURN v_NUM_CONFLICTS;
END SET_MERGE_TYPES;
----------------------------------------------------------------------------------------------------
FUNCTION IS_SYSTEM_OBJECT_PRESENT
	(
	p_OBJECT_ID IN NUMBER
	) RETURN BOOLEAN IS
	v_COUNT NUMBER := 0;
BEGIN

	--See if an object with this ID exists in the SYSTEM_OBJECT table.

	SELECT COUNT(1) INTO v_COUNT
	FROM SYSTEM_OBJECT O
	WHERE O.OBJECT_ID = p_OBJECT_ID;

	RETURN v_COUNT = 1;

END IS_SYSTEM_OBJECT_PRESENT;
----------------------------------------------------------------------------------------------------
PROCEDURE UPDATE_CRYSTAL_FROM_SIDE
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_OBJECT_ID IN NUMBER,
	p_IMPORT_SIDE IN VARCHAR2
	) AS

	v_CRYSTAL CRYSTAL_REPORT_FILES%ROWTYPE;

CURSOR c_CRYSTAL IS
	SELECT OBJECT_ID, TEMPLATE_TYPE, REPORT_FILE, SYSDATE
	FROM SYSTEM_OBJECT_IMPORT_CRYSTAL
	WHERE OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID
		AND OBJECT_ID = p_OBJECT_ID
		AND IMPORT_SIDE = p_IMPORT_SIDE;

BEGIN
	--Replace reports for a SYSTEM_OBJECT with those from a specified side.
	DELETE CRYSTAL_REPORT_FILES
	WHERE OBJECT_ID = p_OBJECT_ID;

	FOR v_CRYSTAL IN c_CRYSTAL LOOP
		INSERT INTO CRYSTAL_REPORT_FILES VALUES v_CRYSTAL;
	END LOOP;
END UPDATE_CRYSTAL_FROM_SIDE;
----------------------------------------------------------------------------------------------------
PROCEDURE UPDATE_OBJECT_FROM_SIDE
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_OBJECT_ID IN NUMBER,
	p_IMPORT_SIDE IN VARCHAR2
	) AS

	v_LOG SYSTEM_OBJECT_IMPORT_LOG%ROWTYPE;
	v_ATTR SYSTEM_OBJECT_ATTRIBUTE%ROWTYPE;

CURSOR c_ATTRIBUTES IS
	SELECT OBJECT_ID, ATTRIBUTE_ID, ATTRIBUTE_VAL
	FROM SYSTEM_OBJECT_IMPORT_ATTR_LOG
	WHERE OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID
		AND OBJECT_ID = p_OBJECT_ID
		AND IMPORT_SIDE = p_IMPORT_SIDE;

BEGIN
	--Raise an error if we cannot edit this object.
	SO.CHECK_OBJECT_PRIVILEGE(p_OBJECT_ID, SO.g_PRIV_EDIT);

	--Update an object, its attributes, and its crystal reports from
	--  a particular side.

	SELECT *
	INTO v_LOG
	FROM SYSTEM_OBJECT_IMPORT_LOG
	WHERE OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID
		AND OBJECT_ID = p_OBJECT_ID
		AND IMPORT_SIDE = p_IMPORT_SIDE;

	--Update System Object table
	UPDATE SYSTEM_OBJECT
	SET OBJECT_ALIAS = v_LOG.OBJECT_ALIAS,
		OBJECT_DESC = v_LOG.OBJECT_DESC,
		OBJECT_DISPLAY_NAME = v_LOG.OBJECT_DISPLAY_NAME,
		OBJECT_TAG = v_LOG.OBJECT_TAG,
		OBJECT_ORDER = v_LOG.OBJECT_ORDER,
		OBJECT_IS_HIDDEN = v_LOG.OBJECT_IS_HIDDEN,
		ENTRY_DATE = SYSDATE
	WHERE OBJECT_ID = p_OBJECT_ID;

	--Replace attributes
	DELETE SYSTEM_OBJECT_ATTRIBUTE
	WHERE OBJECT_ID = p_OBJECT_ID;

	FOR v_ATTR IN c_ATTRIBUTES LOOP
		INSERT INTO SYSTEM_OBJECT_ATTRIBUTE VALUES v_ATTR;
	END LOOP;

	--Replace crystal
	UPDATE_CRYSTAL_FROM_SIDE(p_OBJECT_IMPORT_ID, p_OBJECT_ID, p_IMPORT_SIDE);

	--Set IS_MODIFIED
	--Note that this must be a separate step from the earlier Update since
	--  changing Attributes will reset the IS_MODIFIED status.
	UPDATE SYSTEM_OBJECT
	SET IS_MODIFIED = v_LOG.IS_MODIFIED
	WHERE OBJECT_ID = p_OBJECT_ID;

END UPDATE_OBJECT_FROM_SIDE;
----------------------------------------------------------------------------------------------------
PROCEDURE ADD_OBJECT_KEYS_TO_SYSTEM_OBJ
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_OBJECT_ID IN NUMBER
	) AS
	v_OBJ SYSTEM_OBJECT%ROWTYPE;
BEGIN
	-- Add just the key fields of the object into the SYSTEM_OBJECT table.
	-- We would do this if we are inserting a Path object for which we have no other information,
	-- or if we are adding a new object, and all its other columns and attributes will be set in
	-- another step.
	SELECT
		OBJECT_ID,
		PARENT_OBJECT_ID,
		OBJECT_NAME,
		OBJECT_INDEX,
		OBJECT_CATEGORY,
		OBJECT_TYPE,
		1
	INTO v_OBJ.OBJECT_ID,
		v_OBJ.PARENT_OBJECT_ID,
		v_OBJ.OBJECT_NAME,
		v_OBJ.OBJECT_INDEX,
		v_OBJ.OBJECT_CATEGORY,
		v_OBJ.OBJECT_TYPE,
		v_OBJ.IS_MODIFIED
	FROM SYSTEM_OBJECT_IMPORT_ITEM
	WHERE OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID
		AND OBJECT_ID = p_OBJECT_ID;

	--Raise an error if we cannot edit this object.
	SO.CHECK_OBJECT_PRIVILEGE(v_OBJ.PARENT_OBJECT_ID, SO.g_PRIV_EDIT, p_INHERITABLE => TRUE);

	INSERT INTO SYSTEM_OBJECT VALUES v_OBJ;

EXCEPTION
	WHEN DUP_VAL_ON_INDEX THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		--It's okay if it already exists.
		NULL;

END ADD_OBJECT_KEYS_TO_SYSTEM_OBJ;
----------------------------------------------------------------------------------------------------
PROCEDURE ADD_OBJECT_FROM_ITEM
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_OBJECT_ID IN NUMBER,
	p_PARENT_OBJECT_ID IN NUMBER := NULL,
	p_IMPORT_SIDE IN VARCHAR2 := NULL
	) AS

	v_PARENT_OBJECT_ID NUMBER(9) := p_PARENT_OBJECT_ID;

CURSOR c_OBJECT_PARENTS IS
	SELECT OBJECT_ID
	FROM SYSTEM_OBJECT_IMPORT_ITEM
	WHERE OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID
	START WITH OBJECT_ID = v_PARENT_OBJECT_ID
	CONNECT BY PRIOR PARENT_OBJECT_ID = OBJECT_ID
	ORDER BY LEVEL DESC;

BEGIN
	--If we don't know the parent object ID, look it up.
	IF v_PARENT_OBJECT_ID IS NULL THEN
		SELECT PARENT_OBJECT_ID INTO v_PARENT_OBJECT_ID
		FROM SYSTEM_OBJECT_IMPORT_ITEM
		WHERE OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID
			AND OBJECT_ID = p_OBJECT_ID;
	END IF;

	--Make sure parents exist in SO tables.
	IF NOT IS_SYSTEM_OBJECT_PRESENT(v_PARENT_OBJECT_ID) THEN
		FOR v_PARENT IN c_OBJECT_PARENTS LOOP
			ADD_OBJECT_KEYS_TO_SYSTEM_OBJ(p_OBJECT_IMPORT_ID, v_PARENT.OBJECT_ID);
		END LOOP;
	END IF;

	--Add the System Object's keys.
	ADD_OBJECT_KEYS_TO_SYSTEM_OBJ(p_OBJECT_IMPORT_ID, p_OBJECT_ID);

	--Let the Update handle the rest.
	IF NOT p_IMPORT_SIDE IS NULL THEN
		UPDATE_OBJECT_FROM_SIDE(p_OBJECT_IMPORT_ID, p_OBJECT_ID, p_IMPORT_SIDE);
	END IF;

END ADD_OBJECT_FROM_ITEM;
----------------------------------------------------------------------------------------------------
PROCEDURE ACCEPT_OR_REJECT
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_INCLUDE_DESCENDANTS IN NUMBER,
	p_ACCEPTED_SIDE IN VARCHAR2,
	p_FORCE IN NUMBER,
	p_OBJECT_ID IN NUMBER_COLLECTION
	) AS
	v_IDX BINARY_INTEGER;
	v_OBJECT_ID NUMBER(9);
	v_COUNT NUMBER;

CURSOR c_OBJECTS IS
	SELECT ITEM.OBJECT_ID,
		ITEM.PARENT_OBJECT_ID,
		MERGE_TYPE,
		CASE WHEN SIDE.OBJECT_ID IS NULL THEN 0 ELSE 1 END "EXISTS_IN_SIDE",
		CASE WHEN OBJ.OBJECT_ID IS NULL THEN 0 ELSE 1 END "EXISTS_IN_SO"
	FROM SYSTEM_OBJECT_IMPORT_ITEM ITEM,
		SYSTEM_OBJECT_IMPORT_LOG SIDE,
		SYSTEM_OBJECT OBJ
	WHERE ITEM.OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID
		AND ITEM.OBJECT_ID IN (SELECT X.COLUMN_VALUE FROM TABLE(CAST(p_OBJECT_ID AS NUMBER_COLLECTION)) X)
		AND SIDE.OBJECT_IMPORT_ID(+) = ITEM.OBJECT_IMPORT_ID
		AND SIDE.OBJECT_ID(+) = ITEM.OBJECT_ID
		AND SIDE.IMPORT_SIDE(+) = p_ACCEPTED_SIDE
		AND OBJ.OBJECT_ID(+) = ITEM.OBJECT_ID;

--NOTE: The inner query in this cursor may not appear to be necessary, but
--  there were rows missing in the hierarchical query results if it was not done this way.
--  The outer joins with the LOG table appeared to cause problems.
CURSOR c_OBJECTS_AND_DESCENDANTS IS
	SELECT X.OBJECT_ID,
		X.PARENT_OBJECT_ID,
		X.MERGE_TYPE,
		X.EXISTS_IN_SIDE,
		X.EXISTS_IN_SO
	FROM
		(SELECT ITEM.OBJECT_ID, ITEM.PARENT_OBJECT_ID, ITEM.MERGE_TYPE,
			CASE WHEN SIDE.OBJECT_ID IS NULL THEN 0 ELSE 1 END "EXISTS_IN_SIDE",
			CASE WHEN OBJ.OBJECT_ID IS NULL THEN 0 ELSE 1 END "EXISTS_IN_SO"
		FROM SYSTEM_OBJECT_IMPORT_ITEM ITEM,
			SYSTEM_OBJECT_IMPORT_LOG SIDE,
			SYSTEM_OBJECT OBJ
		WHERE ITEM.OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID
			AND SIDE.OBJECT_IMPORT_ID(+) = ITEM.OBJECT_IMPORT_ID
			AND SIDE.OBJECT_ID(+) = ITEM.OBJECT_ID
			AND SIDE.IMPORT_SIDE(+) = p_ACCEPTED_SIDE
			AND OBJ.OBJECT_ID(+) = ITEM.OBJECT_ID
		) X
	START WITH X.OBJECT_ID = v_OBJECT_ID
	CONNECT BY PRIOR X.OBJECT_ID = X.PARENT_OBJECT_ID;

	PROCEDURE HANDLE_OBJECT
		(
		p_OBJ IN c_OBJECTS%ROWTYPE
		) AS
	BEGIN
		-- Do nothing if this is a path element.
		IF p_OBJ.MERGE_TYPE IS NULL THEN
			NULL;
		-- If the object only exists in the	SO tables, delete it.
		ELSIF p_OBJ.EXISTS_IN_SO = 1 AND p_OBJ.EXISTS_IN_SIDE = 0 THEN
			IF p_FORCE = 1 OR NOT p_OBJ.MERGE_TYPE = c_MERGE_TYPE_IGNORE_DELETE THEN
				SELECT COUNT(1) INTO v_COUNT FROM SYSTEM_OBJECT WHERE OBJECT_ID = p_OBJ.OBJECT_ID;
				IF v_COUNT > 0 THEN
					SO.DELETE_SYSTEM_OBJECT(p_OBJ.OBJECT_ID);
				END IF;
			END IF;
		-- If the object only exists in the accepted Side, add it.
		ELSIF p_OBJ.EXISTS_IN_SO = 0 AND p_OBJ.EXISTS_IN_SIDE = 1 THEN
			--Make sure parents exist in SO tables, and add the object itself.
			--Then update everything else.
			ADD_OBJECT_FROM_ITEM(p_OBJECT_IMPORT_ID, p_OBJ.OBJECT_ID, p_OBJ.PARENT_OBJECT_ID, p_ACCEPTED_SIDE);

		-- If object exists in both the accepted Side and the SO tables
		-- and there are differences, apply the accepted Side.
		ELSIF p_OBJ.EXISTS_IN_SO = 1 AND p_OBJ.EXISTS_IN_SIDE = 1 THEN
			IF p_FORCE = 1 OR NOT (p_OBJ.MERGE_TYPE = c_MERGE_TYPE_IGNORE_CHANGE AND p_ACCEPTED_SIDE = c_SIDE_IMPORTED) THEN
				IF SEE_IF_SIDE_DIFFERS_FROM_OBJ(p_OBJECT_IMPORT_ID, p_OBJ.OBJECT_ID, p_ACCEPTED_SIDE) = 1 THEN
					--Update System Object table, Replace attributes, Replace reports, Set IS_MODIFIED
					UPDATE_OBJECT_FROM_SIDE(p_OBJECT_IMPORT_ID, p_OBJ.OBJECT_ID, p_ACCEPTED_SIDE);
				END IF;
			END IF;
		END IF;
	END HANDLE_OBJECT;
BEGIN

	--Make sure the user is allowed to use the configuration import.
	SD.VERIFY_ACTION_IS_ALLOWED(c_ACTION_SO_IMPORT);

	--Raise an error if the import is closed.
	CHECK_IMPORT_IS_OPEN(p_OBJECT_IMPORT_ID);

	--If we are including descendants, just do one Object ID at a time,
	--since the hierarchical query does not work so well with multiple roots.
	IF p_INCLUDE_DESCENDANTS = 1 THEN
		v_IDX := p_OBJECT_ID.FIRST;
		WHILE p_OBJECT_ID.EXISTS(v_IDX) LOOP
			v_OBJECT_ID := p_OBJECT_ID(v_IDX);
			FOR v_OBJ IN c_OBJECTS_AND_DESCENDANTS LOOP
				HANDLE_OBJECT(v_OBJ);
			END LOOP;
		v_IDX := p_OBJECT_ID.NEXT(v_IDX);
		END LOOP;
	--If not including descendants, just go through all the objects in the list.
	ELSE
		FOR v_OBJ IN c_OBJECTS LOOP
			HANDLE_OBJECT(v_OBJ);
		END LOOP;
	END IF;

END ACCEPT_OR_REJECT;
----------------------------------------------------------------------------------------------------
PROCEDURE ACCEPT_OR_REJECT_ALL
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_ACCEPTED_SIDE IN VARCHAR2,
	p_FORCE IN NUMBER
	) AS
BEGIN

	ACCEPT_OR_REJECT(p_OBJECT_IMPORT_ID, 1, p_ACCEPTED_SIDE, p_FORCE, NUMBER_COLLECTION(0));

END ACCEPT_OR_REJECT_ALL;
----------------------------------------------------------------------------------------------------
PROCEDURE INSERT_SYSTEM_SYSTEM_OBJECT AS
	v_OBJECT_ID NUMBER;
BEGIN
--Make sure the "System" System Object exists already.

	--It should be the only thing with a category of "System".
	--If there is something else with a category of "System" then we have a big problem.
	SELECT OBJECT_ID
	INTO v_OBJECT_ID
	FROM SYSTEM_OBJECT
	WHERE OBJECT_CATEGORY = 'System';

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		INSERT INTO SYSTEM_OBJECT(
			OBJECT_ID,
			PARENT_OBJECT_ID,
			OBJECT_NAME,
			OBJECT_INDEX,
			OBJECT_CATEGORY,
			OBJECT_TYPE,
			OBJECT_ALIAS,
			OBJECT_DESC,
			OBJECT_DISPLAY_NAME,
			OBJECT_TAG,
			OBJECT_ORDER,
			OBJECT_IS_HIDDEN,
			IS_MODIFIED,
			ENTRY_DATE)
		VALUES (
			0,
			-1,
			'System',
			0,
			'System',
			'Default',
			'System',
			'System',
			'System',
			'',
			0,
			0,
			0,
			SYSDATE);
END;
----------------------------------------------------------------------------------------------------
PROCEDURE IMPORT_SYSTEM_OBJECTS_STAGING
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_XML IN XMLTYPE,
	p_STARTING_PATH IN VARCHAR2,
	p_IS_TOP_LEVEL IN BOOLEAN,
	p_PARENT_OBJECT_ID IN NUMBER
	) AS

	v_IS_PRE_EXISTING BOOLEAN;
	v_OBJECT SYSTEM_OBJECT%ROWTYPE;

	CURSOR c_IMPORTED_OBJECTS IS
		SELECT EXTRACT(VALUE(OBJ), '/Object/Path', c_CONFIG_NAMESPACE) "PATH",
			   EXTRACTVALUE(VALUE(OBJ), '/Object/name', c_CONFIG_NAMESPACE) "OBJECT_NAME",
			   NVL(EXTRACTVALUE(VALUE(OBJ), '/Object/index', c_CONFIG_NAMESPACE), 0) "OBJECT_INDEX",
			   EXTRACTVALUE(VALUE(OBJ), '/Object/category', c_CONFIG_NAMESPACE) "OBJECT_CATEGORY",
			   NVL(EXTRACTVALUE(VALUE(OBJ), '/Object/type', c_CONFIG_NAMESPACE), 'Default') "OBJECT_TYPE",
			   EXTRACTVALUE(VALUE(OBJ), '/Object/alias', c_CONFIG_NAMESPACE) "OBJECT_ALIAS",
			   EXTRACTVALUE(VALUE(OBJ), '/Object/desc', c_CONFIG_NAMESPACE) "OBJECT_DESC",
			   EXTRACTVALUE(VALUE(OBJ), '/Object/displayName', c_CONFIG_NAMESPACE) "OBJECT_DISPLAY_NAME",
			   EXTRACTVALUE(VALUE(OBJ), '/Object/tag', c_CONFIG_NAMESPACE) "OBJECT_TAG",
			   EXTRACTVALUE(VALUE(OBJ), '/Object/order', c_CONFIG_NAMESPACE) "OBJECT_ORDER",
			   EXTRACTVALUE(VALUE(OBJ), '/Object/isHidden', c_CONFIG_NAMESPACE) "OBJECT_IS_HIDDEN",
			   EXTRACT(VALUE(OBJ), '/Object/Attribute', c_CONFIG_NAMESPACE) "ATTRIBUTES",
			   EXTRACT(VALUE(OBJ), '/Object/CrystalTemplate', c_CONFIG_NAMESPACE) "CRYSTAL_TEMPLATES",
			   EXTRACT(VALUE(OBJ), '/Object/Object', c_CONFIG_NAMESPACE) "CHILD_OBJECTS"
		FROM TABLE(XMLSEQUENCE(EXTRACT(p_XML, p_STARTING_PATH, c_CONFIG_NAMESPACE))) OBJ;

BEGIN

	--Import the objects from the XML into the SYSTEM_OBJECT_IMPORT staging tables.

	LOGS.LOG_DEBUG('importing parent=' || p_PARENT_OBJECT_ID || '; starting_path=' || p_STARTING_PATH);

	--First, make sure the "System" SYSTEM_OBJECT exists.  It is the very top of the hierarchy.
	INSERT_SYSTEM_SYSTEM_OBJECT;

	--For each object...
	FOR v_IMPORTED_OBJECT IN c_IMPORTED_OBJECTS LOOP
		v_OBJECT.OBJECT_NAME := v_IMPORTED_OBJECT.OBJECT_NAME;
		v_OBJECT.OBJECT_INDEX := v_IMPORTED_OBJECT.OBJECT_INDEX;
		v_OBJECT.OBJECT_CATEGORY := v_IMPORTED_OBJECT.OBJECT_CATEGORY;
		v_OBJECT.OBJECT_TYPE := v_IMPORTED_OBJECT.OBJECT_TYPE;
		v_OBJECT.OBJECT_ALIAS := v_IMPORTED_OBJECT.OBJECT_ALIAS;
		v_OBJECT.OBJECT_DESC := v_IMPORTED_OBJECT.OBJECT_DESC;
		v_OBJECT.OBJECT_DISPLAY_NAME := v_IMPORTED_OBJECT.OBJECT_DISPLAY_NAME;
		v_OBJECT.OBJECT_TAG := v_IMPORTED_OBJECT.OBJECT_TAG;
		v_OBJECT.OBJECT_ORDER := v_IMPORTED_OBJECT.OBJECT_ORDER;
		v_OBJECT.OBJECT_IS_HIDDEN := v_IMPORTED_OBJECT.OBJECT_IS_HIDDEN;
		v_OBJECT.IS_MODIFIED := NULL;

		--If this is an excluded object, we want to stop right here and not process
		--  it or any of its children.
		IF IS_EXCLUDED_OBJECT(v_OBJECT.OBJECT_CATEGORY, v_OBJECT.OBJECT_NAME) THEN
			LOGS.LOG_WARN('Configuration for the Excluded Object "'||v_OBJECT.OBJECT_NAME||'" was found in this import.  This configuration was ignored.');
			RETURN;
		END IF;

		--Get the parent object ID, adding the parent objects to the Key table as we go.
		--If parents do not exist, create new IDs for them, and add them to the Key table.
		IF p_IS_TOP_LEVEL THEN
			IF UPPER(v_OBJECT.OBJECT_CATEGORY) = 'SYSTEM' THEN
				v_OBJECT.PARENT_OBJECT_ID := -1;
			ELSE
				v_OBJECT.PARENT_OBJECT_ID := STORE_OBJECT_PATH(p_OBJECT_IMPORT_ID, v_IMPORTED_OBJECT.PATH);
				--If one of the parents was an excluded object, we do not want to process this object
				--  or any of its children.
				IF v_OBJECT.PARENT_OBJECT_ID = c_EXCLUDED_OBJECT THEN
					RETURN;
				END IF;
			END IF;
		ELSE
			v_OBJECT.PARENT_OBJECT_ID := p_PARENT_OBJECT_ID;
		END IF;

		--Look up the Object's ID based on its ParentObject Id.
		SO.ID_FOR_SYSTEM_OBJECT(v_OBJECT.PARENT_OBJECT_ID,
								v_OBJECT.OBJECT_NAME,
								v_OBJECT.OBJECT_INDEX,
								v_OBJECT.OBJECT_CATEGORY,
								v_OBJECT.OBJECT_TYPE,
								FALSE,
								v_OBJECT.OBJECT_ID);

		--Is the object pre-existing?  (Is it already there in the SO table?)
		v_IS_PRE_EXISTING := v_OBJECT.OBJECT_ID >= 0;

		--If not pre-existing, create a new Object ID to use.
		IF NOT v_IS_PRE_EXISTING THEN
			SELECT MID.NEXTVAL INTO v_OBJECT.OBJECT_ID FROM DUAL;
		END IF;

		--Add current object to Item table if it does not already exist.
		ADD_OBJECT_AS_ITEM(p_OBJECT_IMPORT_ID, v_OBJECT);

		--If this is a top-level and pre-existing object,  grab its existing Hierarchy to put
		--  into the "Original" side of the Item and Log tables.
		--  This forms the internal side of the comparison.
		IF v_IS_PRE_EXISTING AND p_IS_TOP_LEVEL THEN
			STORE_ORIGINAL_OBJECT_DATA(p_OBJECT_IMPORT_ID, v_OBJECT.OBJECT_ID);
		END IF;

		--Store info to "Imported" side of Data tables for this object and its attributes.
		STORE_IMPORTED_OBJECT_DATA(p_OBJECT_IMPORT_ID, v_IMPORTED_OBJECT.ATTRIBUTES, v_IMPORTED_OBJECT.CRYSTAL_TEMPLATES, v_OBJECT);

		--Process child objects.
		IMPORT_SYSTEM_OBJECTS_STAGING(p_OBJECT_IMPORT_ID, v_IMPORTED_OBJECT.CHILD_OBJECTS, '/Object', FALSE, v_OBJECT.OBJECT_ID);

	END LOOP;

END IMPORT_SYSTEM_OBJECTS_STAGING;
----------------------------------------------------------------------------------------------------
PROCEDURE IMPORT_SYSTEM_OBJECT_XML_CLOB
	(
	p_IMPORT_FILE IN OUT NOCOPY CLOB,
	p_IMPORT_FILE_PATH IN VARCHAR2,
	p_IMPORT_MODE IN VARCHAR2,
	p_PROCESS_STATUS OUT NUMBER,
	p_PROCESS_ID OUT VARCHAR2,
	p_MESSAGE OUT VARCHAR2
	) AS

	v_FULL_XML XMLTYPE;
	v_CONDITIONAL_FORMAT_XML XMLTYPE;
	v_OBJECT_XML XMLTYPE;
	v_OBJECT_IMPORT_ID NUMBER(9);
	v_IS_PRODUCT_SCRIPT NUMBER(1);
	v_IMPORT_STAYS_OPEN BOOLEAN := FALSE;
	v_NUM_CONFLICTS NUMBER;
	v_REVISION SYSTEM_OBJECT_IMPORT.PRODUCT_SCRIPT_REVISION%TYPE := NULL;
	v_PRODUCT_SCRIPT_TYPE SYSTEM_OBJECT_IMPORT.PRODUCT_SCRIPT_TYPE%TYPE := NULL;
	v_COUNT BINARY_INTEGER;
BEGIN

	SAVEPOINT BEFORE_CONFIGURATION_IMPORT;
	LOGS.START_PROCESS('Configuration Import');

	--Make sure the user is allowed to use the configuration import.
	SD.VERIFY_ACTION_IS_ALLOWED(c_ACTION_SO_IMPORT);

	--Make sure there are no open imports already.
	CHECK_ALL_IMPORTS_ARE_CLOSED;

	LOGS.SET_PROCESS_TARGET_PARAMETER('IMPORT_MODE', p_IMPORT_MODE);
	LOGS.SET_PROCESS_TARGET_PARAMETER('FILE_PATH', p_IMPORT_FILE_PATH);

	--Start a new import.
	v_FULL_XML := XMLTYPE.CREATEXML(p_IMPORT_FILE);
    v_IS_PRODUCT_SCRIPT := v_FULL_XML.EXISTSNODE('/SystemObjectConfiguration/@productScriptType', c_CONFIG_NAMESPACE);

    IF v_IS_PRODUCT_SCRIPT = 1 THEN
        v_PRODUCT_SCRIPT_TYPE := v_FULL_XML.EXTRACT('/SystemObjectConfiguration/@productScriptType', c_CONFIG_NAMESPACE).GETSTRINGVAL();
		v_REVISION := v_FULL_XML.EXTRACT('/SystemObjectConfiguration/@productScriptRevision', c_CONFIG_NAMESPACE).GETSTRINGVAL();

		SELECT COUNT(1) INTO v_COUNT
		FROM SYSTEM_OBJECT_IMPORT I
		WHERE I.PRODUCT_SCRIPT_TYPE = v_PRODUCT_SCRIPT_TYPE
			AND I.PRODUCT_SCRIPT_REVISION = v_REVISION;

		IF v_COUNT > 0 THEN
			p_MESSAGE := 'Import for Product Script Type - ' || v_PRODUCT_SCRIPT_TYPE ||
							' and Revision - ' || v_REVISION || ' already exists. Purge the older revision and try to re-import again.';
			LOGS.LOG_WARN(p_MESSAGE);
			RETURN;
		END IF;
	END IF;

	SELECT MID.NEXTVAL INTO v_OBJECT_IMPORT_ID FROM DUAL;
	INSERT INTO SYSTEM_OBJECT_IMPORT
	VALUES
		(v_OBJECT_IMPORT_ID,
		 SECURITY_CONTROLS.CURRENT_USER_ID,
		 SYSDATE,
		 'Open',
		 p_IMPORT_MODE,
		 PARSE_UTIL.FILE_NAME_FROM_PATH(p_IMPORT_FILE_PATH),
  		 v_PRODUCT_SCRIPT_TYPE,
		 v_REVISION
		 );

	--Import conditional formats.
	v_CONDITIONAL_FORMAT_XML := v_FULL_XML.EXTRACT('/SystemObjectConfiguration/ConditionalFormats', c_CONFIG_NAMESPACE);
	IMPORT_CONDITIONAL_FORMATS(v_CONDITIONAL_FORMAT_XML, p_IMPORT_MODE);

	IF p_IMPORT_MODE NOT IN (c_IMODE_FMTS_INSERT, c_IMODE_FMTS_OVERWRITE) THEN
		--Put main system objects into staging tables.
		v_OBJECT_XML := v_FULL_XML.EXTRACT('/SystemObjectConfiguration/MainObjects', c_CONFIG_NAMESPACE);
		IMPORT_SYSTEM_OBJECTS_STAGING(v_OBJECT_IMPORT_ID, v_OBJECT_XML, '/MainObjects/Object', TRUE, null);

		--Put referenced system objects into staging tables.
		v_OBJECT_XML := v_FULL_XML.EXTRACT('/SystemObjectConfiguration/ReferencedObjects', c_CONFIG_NAMESPACE);
		IMPORT_SYSTEM_OBJECTS_STAGING(v_OBJECT_IMPORT_ID, v_OBJECT_XML, '/ReferencedObjects/Object', TRUE, null);

		--Update the Merge Type and Imported Is Modified for all the objects.
		v_NUM_CONFLICTS := SET_MERGE_TYPES(v_OBJECT_IMPORT_ID, v_PRODUCT_SCRIPT_TYPE);

		--Accept the entire import if we are in Overwrite mode.
		--The import stays open if we are Accepting All and there are any conflicts.
		IF p_IMPORT_MODE IN (c_IMODE_OVERWRITE, c_IMODE_OVERWRITE_PRSV) THEN
			ACCEPT_OR_REJECT_ALL(v_OBJECT_IMPORT_ID, c_SIDE_IMPORTED, 0);
			v_IMPORT_STAYS_OPEN := v_NUM_CONFLICTS > 0;
		--Accept the entire import in "Force" mode if we are in Overwrite-Force mode.
		ELSIF p_IMPORT_MODE = c_IMODE_OVERWRITE_FORCE THEN
			ACCEPT_OR_REJECT_ALL(v_OBJECT_IMPORT_ID, c_SIDE_IMPORTED, 1);
			v_IMPORT_STAYS_OPEN := v_NUM_CONFLICTS > 0;
		ELSE
			v_IMPORT_STAYS_OPEN := FALSE;
		END IF;
	ELSE
		v_IMPORT_STAYS_OPEN := FALSE;
	END IF;

	-- Close the import if needed.
	IF v_IMPORT_STAYS_OPEN THEN
		p_MESSAGE := 'Configuration has been successfully imported, with some conflicts.  See "Configuration Import Results" screen for details.';
	ELSE
		UPDATE SYSTEM_OBJECT_IMPORT SET IMPORT_STATUS = c_IMPORT_STATUS_CLOSED WHERE OBJECT_IMPORT_ID = v_OBJECT_IMPORT_ID;
		p_MESSAGE := 'Configuration has been successfully imported and closed.';
	END IF;
	IF p_IMPORT_MODE = c_IMODE_DIFF THEN
		-- Make sure user is aware that no changes were actually made.
		p_MESSAGE := p_MESSAGE||UTL_TCP.CRLF||'Local configuration has not been updated.  See "Configuration Import Results" screen to see contents of this import file.';
	END IF;

	--Additional message to take the process status into account.
	p_MESSAGE := LOGS.GET_FINISH_MESSAGE || UTL_TCP.CRLF || p_MESSAGE;

	p_PROCESS_ID := TO_CHAR(LOGS.CURRENT_PROCESS_ID);
	LOGS.STOP_PROCESS(p_MESSAGE, p_PROCESS_STATUS);
	COMMIT;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.ABORT_PROCESS(p_SAVEPOINT_NAME => 	'BEFORE_CONFIGURATION_IMPORT');

END IMPORT_SYSTEM_OBJECT_XML_CLOB;
----------------------------------------------------------------------------------------------------
--=================================================
--     SYSTEM OBJECT RESOLVE CONFLICTS REPORT LOGIC
--=================================================
PROCEDURE GET_CONFLICT_COUNT_WORK
	(
	p_OBJECT_ID IN NUMBER,
	p_IS_CONFLICT IN NUMBER,
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_OBJECT_WORK_ID IN NUMBER,
	p_NUM_CONFLICTS OUT BINARY_INTEGER
	) IS

CURSOR c_CHILDREN IS
	SELECT OBJECT_ID,
		CASE WHEN MERGE_TYPE IN (c_MERGE_TYPE_CONFLICT, c_MERGE_TYPE_CONFLICT_DELETE) THEN 1 ELSE 0 END "IS_CONFLICT"
	FROM SYSTEM_OBJECT_IMPORT_ITEM
	WHERE OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID
		AND PARENT_OBJECT_ID = p_OBJECT_ID;

	v_CUR BINARY_INTEGER;
BEGIN
	--This function stores the sum of conflict counts for the current object and all its children to the work table
	--  so that the Conflict Tree can join to it.

	p_NUM_CONFLICTS := p_IS_CONFLICT;

	--Find total conflict count for this object's children
	FOR v_REC IN c_CHILDREN LOOP
		GET_CONFLICT_COUNT_WORK(v_REC.OBJECT_ID, v_REC.IS_CONFLICT, p_OBJECT_IMPORT_ID, p_OBJECT_WORK_ID, v_CUR);
		p_NUM_CONFLICTS := p_NUM_CONFLICTS + v_CUR;
	END LOOP;

	--Insert total conflict count for this object.
	INSERT INTO RTO_WORK (WORK_ID, WORK_SEQ, WORK_XID) VALUES (p_OBJECT_WORK_ID, p_OBJECT_ID, p_NUM_CONFLICTS);

END GET_CONFLICT_COUNT_WORK;
----------------------------------------------------------------------------------------------------
FUNCTION GET_FORMATTED_OBJECT_NAME
	(
	p_OBJECT_NAME IN VARCHAR2,
	p_MERGE_TYPE IN VARCHAR2,
	p_CONFLICT_COUNT IN NUMBER
	) RETURN VARCHAR2 IS
	FUNCTION GET_FORMATTED_CONFLICT_NUMBER (p_NUMBER IN NUMBER) RETURN VARCHAR2 IS
	BEGIN
		RETURN CASE WHEN p_NUMBER > 0 THEN '<font color="red"><b> (' || TO_CHAR(p_NUMBER) || ') </b></font>' ELSE NULL END;
	END GET_FORMATTED_CONFLICT_NUMBER;
BEGIN
	RETURN CASE
		--Object is a parent only, and not included in the Import.
		WHEN p_MERGE_TYPE IS NULL
			THEN '<html><font color="gray"><i>' || p_OBJECT_NAME || '</i></font>' ||
				GET_FORMATTED_CONFLICT_NUMBER(p_CONFLICT_COUNT) || '</html>'
		--Object is itself a conflict
		WHEN p_MERGE_TYPE IN (c_MERGE_TYPE_CONFLICT, c_MERGE_TYPE_CONFLICT_DELETE)
			THEN '<html><font color="red"><b>' || p_OBJECT_NAME || ' </b></font>' ||
				GET_FORMATTED_CONFLICT_NUMBER(p_CONFLICT_COUNT - 1) || '</html>'
		--Otherwise, object name is not specially formatted.
		ELSE
			'<html>' || p_OBJECT_NAME ||
				GET_FORMATTED_CONFLICT_NUMBER(p_CONFLICT_COUNT) || '</html>'
	END;

END GET_FORMATTED_OBJECT_NAME;
----------------------------------------------------------------------------------------------------
FUNCTION GET_FORMATTED_CATEGORY_NAME
	(
	p_OBJECT_CATEGORY IN VARCHAR2,
	p_CONFLICT_COUNT IN NUMBER
	) RETURN VARCHAR2 IS
BEGIN
	RETURN '<html>' || p_OBJECT_CATEGORY || 's' ||
		CASE WHEN p_CONFLICT_COUNT > 0 THEN '<font color="red"><b> (' || p_CONFLICT_COUNT || ')</b></font></html>'
		END;
END GET_FORMATTED_CATEGORY_NAME;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_IMPORT_STATUS_TREE
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

	v_OBJECT_WORK_ID NUMBER;
	DUMMY BINARY_INTEGER;
BEGIN

	--Make sure the user is allowed to use the configuration import.
	SD.VERIFY_ACTION_IS_ALLOWED(c_ACTION_SO_IMPORT);

	-- Store conflict sum for each object and its sub-tree in the work table.
	UT.GET_RTO_WORK_ID(v_OBJECT_WORK_ID);
	GET_CONFLICT_COUNT_WORK(-1, 0, p_OBJECT_IMPORT_ID, v_OBJECT_WORK_ID, DUMMY);

	OPEN p_CURSOR FOR
		SELECT ITEM.PATH,
			ITEM.OBJECT_ID,
			ITEM.PARENT_OBJECT_ID,
			ITEM.OBJECT_CATEGORY,
			GET_FORMATTED_OBJECT_NAME(ITEM.OBJECT_NAME, ITEM.MERGE_TYPE, W.WORK_XID) AS NAME,
			GET_FORMATTED_CATEGORY_NAME(ITEM.OBJECT_CATEGORY,  SUM(W.WORK_XID) OVER (PARTITION BY ITEM.PARENT_OBJECT_ID, ITEM.OBJECT_CATEGORY)) "CATEGORY_DISPLAY_NAME",
			'' AS REQUIRED_CHILDREN, --used by MightyHierarchyTree.java
			ORIG.OBJECT_ID AS ORIG_OBJECT_ID,
			IMP.OBJECT_ID AS IMP_OBJECT_ID
		FROM
			(SELECT OBJECT_IMPORT_ID,
				OBJECT_ID,
				SYS_CONNECT_BY_PATH(TO_CHAR(OBJECT_INDEX, '9999') || REPLACE(SUBSTR(OBJECT_NAME, 1, 16), ':', '-')
					|| TO_CHAR(OBJECT_ID, '999999999'), '::') AS PATH,
				PARENT_OBJECT_ID,
				OBJECT_CATEGORY,
				OBJECT_NAME,
				MERGE_TYPE
			FROM SYSTEM_OBJECT_IMPORT_ITEM
			START WITH OBJECT_ID = 0
				AND OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID
			CONNECT BY PARENT_OBJECT_ID = PRIOR OBJECT_ID
				AND OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID
			) ITEM,
			RTO_WORK W,
			SYSTEM_OBJECT_IMPORT_LOG ORIG,
			SYSTEM_OBJECT_IMPORT_LOG IMP,
			SYSTEM_OBJECT SO
		WHERE W.WORK_ID = v_OBJECT_WORK_ID
			AND W.WORK_SEQ = ITEM.OBJECT_ID
			--Imported objects
			AND IMP.OBJECT_IMPORT_ID(+) = ITEM.OBJECT_IMPORT_ID
			AND IMP.OBJECT_ID(+) = ITEM.OBJECT_ID
			AND IMP.IMPORT_SIDE(+) = c_SIDE_IMPORTED
			--Original objects
			AND ORIG.OBJECT_IMPORT_ID(+) = ITEM.OBJECT_IMPORT_ID
			AND ORIG.OBJECT_ID(+) = ITEM.OBJECT_ID
			AND ORIG.IMPORT_SIDE(+) = c_SIDE_ORIGINAL
			--System Object table.
			AND SO.OBJECT_ID(+) = ITEM.OBJECT_ID
		ORDER BY PATH;

	UT.PURGE_RTO_WORK(v_OBJECT_WORK_ID);

END GET_IMPORT_STATUS_TREE;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_IMPORT_LIST(p_CURSOR OUT GA.REFCURSOR) AS
BEGIN

	--Outer joined on APPLICATION_USER incase the USER_ID in SYSTEM_OBJECT_IMPORT is null,
	--  as could happen when the database is built from scratch or a user is deleted.
	OPEN p_CURSOR FOR
	SELECT
		CASE WHEN I.PRODUCT_SCRIPT_TYPE IS NOT NULL THEN
			TRIM(U.USER_NAME) || ' ' || TO_CHAR(I.IMPORTED_DATE, 'MM/DD/YYYY HH:MM AM') || ' ' || '(' || I.IMPORT_STATUS || '):' || I.PRODUCT_SCRIPT_TYPE || '-' || I.PRODUCT_SCRIPT_REVISION
		ELSE
			TRIM(U.USER_NAME) || ' ' || TO_CHAR(I.IMPORTED_DATE, 'MM/DD/YYYY HH:MM AM') || ' ' || '(' || I.IMPORT_STATUS || '):' || I.IMPORT_FILENAME
		END AS OBJECT_IMPORT_NAME,
		I.OBJECT_IMPORT_ID
	FROM SYSTEM_OBJECT_IMPORT I, APPLICATION_USER U
	WHERE I.USER_ID = U.USER_ID(+)
	ORDER BY IMPORTED_DATE DESC;

END GET_IMPORT_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_MERGE_TYPE_LIST
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN

	OPEN p_CURSOR FOR
	SELECT
		CASE WHEN MERGE_TYPE IN (c_MERGE_TYPE_CONFLICT, c_MERGE_TYPE_CONFLICT_DELETE) THEN
			'<html>'||MERGE_TYPE||'<font color="red"><b> (' || COUNT || ')</b></font></html>'
		ELSE
			MERGE_TYPE || ' (' || COUNT || ')'
		END AS MERGE_TYPE
	FROM
		(SELECT MERGE_TYPE, COUNT(1) "COUNT"
		FROM SYSTEM_OBJECT_IMPORT_ITEM L
		WHERE L.OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID
			AND L.MERGE_TYPE IS NOT NULL
		GROUP BY MERGE_TYPE)
	ORDER BY 1;

END GET_MERGE_TYPE_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_IMPORT_STATUS_RPT_MASTER
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_OBJECT_ID IN NUMBER,
	p_PARENT_OBJECT_ID IN NUMBER,
	p_OBJECT_CATEGORY IN VARCHAR2,
	p_INCLUDE_DESCENDANTS IN NUMBER,
	p_MERGE_TYPES IN VARCHAR2,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
	v_OBJECT_CATEGORY SYSTEM_OBJECT.OBJECT_CATEGORY%TYPE;
	v_OBJECT_ID NUMBER(9);
	v_MERGE_TYPE_NAMES VARCHAR2(256);
	v_MERGE_TYPES STRING_TABLE;
BEGIN

	IF (p_OBJECT_ID = -1) THEN -- THEN USE THE PARENT_OBJECT_ID AND CATEGORY
		v_OBJECT_ID := p_PARENT_OBJECT_ID;
		v_OBJECT_CATEGORY := p_OBJECT_CATEGORY;
	ELSE
		v_OBJECT_ID := p_OBJECT_ID;
		v_OBJECT_CATEGORY := NULL;
	END IF;

	-- STRIP THE NUMBERS IN PARENTHESES AND ANY HTML FROM THE MERGE TYPES.
	v_MERGE_TYPE_NAMES := REGEXP_REPLACE(p_MERGE_TYPES, '(<.+?>| \(\d+\))', '');

	-- ONLY LOOK AT THE USER SPECIFIED MERGE TYPES
	UT.STRING_TABLE_FROM_STRING(v_MERGE_TYPE_NAMES, ',', v_MERGE_TYPES);

	OPEN p_CURSOR FOR
		SELECT DISPLAY_PATH, OBJECT_NAME, OBJECT_ID, OBJECT_CATEGORY, MERGE_TYPE,
			CASE WHEN MERGE_TYPE = c_MERGE_TYPE_NO_DIFF THEN NULL
				WHEN IMPORTED_DIFFERS = 0 THEN 'Y'
				WHEN ORIGINAL_DIFFERS = 0 THEN 'N'
				ELSE 'Partial'
			END "IMPORT_ACCEPTED",
			CASE WHEN MERGE_TYPE = c_MERGE_TYPE_ADD AND IMPORTED_DIFFERS = 0 THEN 'Added'
				WHEN MERGE_TYPE IN (c_MERGE_TYPE_DELETE, c_MERGE_TYPE_CONFLICT_DELETE, c_MERGE_TYPE_IGNORE_DELETE) AND IMPORTED_DIFFERS = 0 THEN 'Deleted'
				WHEN MERGE_TYPE IN (c_MERGE_TYPE_CHANGE, c_MERGE_TYPE_CONFLICT, c_MERGE_TYPE_IGNORE_CHANGE) AND IMPORTED_DIFFERS = 0 THEN 'Changed'
				WHEN MERGE_TYPE <> c_MERGE_TYPE_NO_DIFF AND ORIGINAL_DIFFERS = 0 THEN 'None'
				WHEN ORIGINAL_DIFFERS = 1 AND IMPORTED_DIFFERS = 1 THEN 'Partial'
				ELSE ''
			END "ACTION_TAKEN"
		FROM
			(SELECT DISPLAY_PATH, OBJECT_NAME, OBJECT_ID, OBJECT_CATEGORY, MERGE_TYPE,
				SEE_IF_SIDE_DIFFERS_FROM_OBJ(p_OBJECT_IMPORT_ID, OBJECT_ID, c_SIDE_ORIGINAL) "ORIGINAL_DIFFERS",
				SEE_IF_SIDE_DIFFERS_FROM_OBJ(p_OBJECT_IMPORT_ID, OBJECT_ID, c_SIDE_IMPORTED) "IMPORTED_DIFFERS"
			FROM
				(SELECT DISTINCT A.OBJECT_ID,
					SYS_CONNECT_BY_PATH(REPLACE(A.OBJECT_NAME, ' / ', '/'), ' / ') AS DISPLAY_PATH,
					A.PARENT_OBJECT_ID,
					A.OBJECT_IMPORT_ID,
					A.OBJECT_NAME,
					A.OBJECT_CATEGORY,
					A.MERGE_TYPE
				FROM SYSTEM_OBJECT_IMPORT_ITEM A
				WHERE A.MERGE_TYPE IN (SELECT X.STRING_VAL FROM TABLE(CAST(v_MERGE_TYPES AS STRING_TABLE)) X)
					--Remove the parent object if we clicked on a category.
					AND (v_OBJECT_CATEGORY IS NULL OR A.OBJECT_ID != v_OBJECT_ID)
				START WITH A.OBJECT_ID = v_OBJECT_ID
					AND A.OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID
				CONNECT BY A.PARENT_OBJECT_ID = PRIOR A.OBJECT_ID
					AND A.OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID
					--Always include the first level of descendants if we clicked on a category.
					AND (p_INCLUDE_DESCENDANTS = 1
						OR (v_OBJECT_CATEGORY IS NOT NULL AND (v_OBJECT_ID IN (A.PARENT_OBJECT_ID, A.OBJECT_ID))))
					--If this is for a particular category, prune to only that category for the first level.
					AND (A.OBJECT_CATEGORY LIKE NVL(v_OBJECT_CATEGORY, '%')
						OR (A.PARENT_OBJECT_ID != v_OBJECT_ID AND A.OBJECT_ID != v_OBJECT_ID))
				))
		ORDER BY DISPLAY_PATH;

END GET_IMPORT_STATUS_RPT_MASTER;
----------------------------------------------------------------------------------------------------
FUNCTION GET_CRYSTAL_STRING_FOR_SIDE
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_OBJECT_ID IN NUMBER,
	p_IMPORT_SIDE IN VARCHAR2
	) RETURN VARCHAR2 IS
	v_RTN VARCHAR2(4000) := NULL;

CURSOR c_SIDE_TEMPLATES IS
	SELECT TEMPLATE_TYPE, LENGTH(REPORT_FILE) "LENGTH"
	FROM SYSTEM_OBJECT_IMPORT_CRYSTAL
	WHERE OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID
		AND OBJECT_ID = p_OBJECT_ID
		AND IMPORT_SIDE = p_IMPORT_SIDE;
BEGIN

	--Return a string that represents a list of all the crystal template types that a given object
	--  has, along with the size of the template file.

	FOR v_TEMPLATE IN c_SIDE_TEMPLATES LOOP
		IF v_RTN IS NULL THEN v_RTN := p_IMPORT_SIDE || '('; END IF;
		v_RTN := v_RTN || v_TEMPLATE.TEMPLATE_TYPE || ':' || v_TEMPLATE.LENGTH || ',';
	END LOOP;

	--Trim trailing comma.
	IF v_RTN IS NOT NULL THEN
		v_RTN := SUBSTR(v_RTN,1,LENGTH(v_RTN)-1) || ')';
	END IF;

	RETURN v_RTN;
END GET_CRYSTAL_STRING_FOR_SIDE;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_IMPORT_STATUS_RPT_DETAIL
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_OBJECT_ID IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
	v_ORIGINAL_TEMPLATE_STRING VARCHAR2(4000);
	v_IMPORTED_TEMPLATE_STRING VARCHAR2(4000) := 'TEST';
	v_CURRENT_TEMPLATE_STRING VARCHAR2(4000);

	FUNCTION GET_CRYSTAL_STRING_FOR_OBJ RETURN VARCHAR2 IS
		v_RTN VARCHAR2(4000);
	BEGIN
		IF SEE_IF_CRYSTAL_DIFFER_FROM_OBJ(p_OBJECT_IMPORT_ID, p_OBJECT_ID, c_SIDE_ORIGINAL) = 0 THEN
			v_RTN := GET_CRYSTAL_STRING_FOR_SIDE(p_OBJECT_IMPORT_ID, p_OBJECT_ID, c_SIDE_ORIGINAL);
		ELSIF SEE_IF_CRYSTAL_DIFFER_FROM_OBJ(p_OBJECT_IMPORT_ID, p_OBJECT_ID, c_SIDE_IMPORTED) = 0 THEN
			v_RTN := GET_CRYSTAL_STRING_FOR_SIDE(p_OBJECT_IMPORT_ID, p_OBJECT_ID, c_SIDE_IMPORTED);
		ELSE
			v_RTN := 'NEITHER';
		END IF;
		RETURN v_RTN;
	END GET_CRYSTAL_STRING_FOR_OBJ;

BEGIN

	v_ORIGINAL_TEMPLATE_STRING := GET_CRYSTAL_STRING_FOR_SIDE(p_OBJECT_IMPORT_ID, p_OBJECT_ID, c_SIDE_ORIGINAL);
	v_IMPORTED_TEMPLATE_STRING := GET_CRYSTAL_STRING_FOR_SIDE(p_OBJECT_IMPORT_ID, p_OBJECT_ID, c_SIDE_IMPORTED);
	v_CURRENT_TEMPLATE_STRING := GET_CRYSTAL_STRING_FOR_OBJ;

	--Open the cursor for the grid that displays all the attributes and pseudo-attributes of the
	--current object, for its Original, Imported, and Current states.
	OPEN p_CURSOR FOR
		SELECT SA.ATTRIBUTE_ID,
			X.COLUMN_NAME,
			NVL(SA.ATTRIBUTE_NAME, X.COLUMN_NAME) "ATTRIBUTE_NAME",
			MAX(CASE IMPORT_SIDE WHEN c_SIDE_ORIGINAL THEN ATTRIBUTE_VAL ELSE NULL END) "ORIGINAL_VAL",
			MAX(CASE IMPORT_SIDE WHEN c_SIDE_IMPORTED THEN ATTRIBUTE_VAL ELSE NULL END) "IMPORTED_VAL",
			MAX(CASE IMPORT_SIDE WHEN 'CURRENT' THEN ATTRIBUTE_VAL ELSE NULL END) "CURRENT_VAL"
		FROM
			--
			-- Normal Attributes
			--
			(SELECT ATTRIBUTE_ID, NULL "COLUMN_NAME", ATTRIBUTE_VAL, IMPORT_SIDE "IMPORT_SIDE"
			FROM SYSTEM_OBJECT_IMPORT_ATTR_LOG
			WHERE OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID
				AND OBJECT_ID = p_OBJECT_ID
			UNION ALL
			SELECT ATTRIBUTE_ID, NULL "COLUMN_NAME", ATTRIBUTE_VAL, 'CURRENT'
			FROM SYSTEM_OBJECT_ATTRIBUTE
			WHERE OBJECT_ID = p_OBJECT_ID

			--
			-- Display Name (We show it in the attribute grid even though it is not a true "Attribute"
			--
			UNION ALL
			SELECT 0, c_COLNAME_DISP_NAME, OBJECT_DISPLAY_NAME, IMPORT_SIDE
			FROM SYSTEM_OBJECT_IMPORT_LOG
			WHERE OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID
				AND OBJECT_ID = p_OBJECT_ID
			UNION ALL
			SELECT 0, c_COLNAME_DISP_NAME, OBJECT_DISPLAY_NAME, 'CURRENT'
			FROM SYSTEM_OBJECT
			WHERE OBJECT_ID = p_OBJECT_ID

			--
			-- Display Order (We show it in the attribute grid even though it is not a true "Attribute"
			--
			UNION ALL
			SELECT 0, c_COLNAME_DISP_ORDER, TO_CHAR(OBJECT_ORDER), IMPORT_SIDE
			FROM SYSTEM_OBJECT_IMPORT_LOG
			WHERE OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID
				AND OBJECT_ID = p_OBJECT_ID
			UNION ALL
			SELECT 0, c_COLNAME_DISP_ORDER, TO_CHAR(OBJECT_ORDER), 'CURRENT'
			FROM SYSTEM_OBJECT
			WHERE OBJECT_ID = p_OBJECT_ID

			--
			-- Is Hidden (We show it in the attribute grid even though it is not a true "Attribute"
			--
			UNION ALL
			SELECT 0, c_COLNAME_IS_HIDDEN, TO_CHAR(OBJECT_IS_HIDDEN), IMPORT_SIDE
			FROM SYSTEM_OBJECT_IMPORT_LOG
			WHERE OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID
				AND OBJECT_ID = p_OBJECT_ID
			UNION ALL
			SELECT 0, c_COLNAME_IS_HIDDEN, TO_CHAR(OBJECT_IS_HIDDEN), 'CURRENT'
			FROM SYSTEM_OBJECT
			WHERE OBJECT_ID = p_OBJECT_ID

			--
			-- Crystal Report Template (We show it in the attribute grid even though it is not a true "Attribute"
			-- We actually show a string with the Template Types.
			--
			UNION ALL
			SELECT 0, c_COLNAME_CRYSTAL, v_IMPORTED_TEMPLATE_STRING, c_SIDE_IMPORTED
			FROM DUAL WHERE v_IMPORTED_TEMPLATE_STRING IS NOT NULL

			UNION ALL
			SELECT 0, c_COLNAME_CRYSTAL, v_ORIGINAL_TEMPLATE_STRING, c_SIDE_ORIGINAL
			FROM DUAL WHERE v_ORIGINAL_TEMPLATE_STRING IS NOT NULL

			UNION ALL
			SELECT 0, c_COLNAME_CRYSTAL, v_CURRENT_TEMPLATE_STRING, 'CURRENT'
			FROM DUAL WHERE v_CURRENT_TEMPLATE_STRING IS NOT NULL
			) X, SYSTEM_ATTRIBUTE SA
		WHERE SA.ATTRIBUTE_ID(+) = X.ATTRIBUTE_ID
		GROUP BY SA.ATTRIBUTE_ID, X.COLUMN_NAME, SA.ATTRIBUTE_NAME
		ORDER BY 2;

END GET_IMPORT_STATUS_RPT_DETAIL;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_IMPORT_STATUS_RPT_DETAIL
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_OBJECT_ID IN NUMBER,
	p_ATTRIBUTE_ID IN NUMBER,
	p_COLUMN_NAME IN VARCHAR2,
	p_CURRENT_VAL IN VARCHAR2
	) AS
BEGIN

	--Make sure the user is allowed to use the configuration import.
	SD.VERIFY_ACTION_IS_ALLOWED(c_ACTION_SO_IMPORT);

	--Raise an error if the import is closed.
	CHECK_IMPORT_IS_OPEN(p_OBJECT_IMPORT_ID);

	--Raise an error if we cannot edit this object.
	SO.CHECK_OBJECT_PRIVILEGE(p_OBJECT_ID, SO.g_PRIV_EDIT);

	--If the object does not exist, create it first.
	IF NOT IS_SYSTEM_OBJECT_PRESENT(p_OBJECT_ID) THEN
		ADD_OBJECT_FROM_ITEM(p_OBJECT_IMPORT_ID, p_OBJECT_ID);
	END IF;

	IF p_ATTRIBUTE_ID IS NOT NULL AND p_ATTRIBUTE_ID <> 0 THEN
		--Save the true "Attributes"
		UPDATE SYSTEM_OBJECT_ATTRIBUTE
		SET ATTRIBUTE_VAL = p_CURRENT_VAL
		WHERE OBJECT_ID = p_OBJECT_ID
			AND ATTRIBUTE_ID = p_ATTRIBUTE_ID;

		IF SQL%ROWCOUNT = 0 THEN
			INSERT INTO SYSTEM_OBJECT_ATTRIBUTE
			VALUES (p_OBJECT_ID, p_ATTRIBUTE_ID, p_CURRENT_VAL);
		END IF;
	ELSE
		--Save the pseudo-Attributes, such as Display Name, Display Order, and Is Hidden
		IF p_COLUMN_NAME = c_COLNAME_DISP_NAME THEN
			UPDATE SYSTEM_OBJECT
			SET OBJECT_DISPLAY_NAME = p_CURRENT_VAL
			WHERE OBJECT_ID = p_OBJECT_ID;
		ELSIF p_COLUMN_NAME = c_COLNAME_DISP_ORDER THEN
			UPDATE SYSTEM_OBJECT
			SET OBJECT_ORDER = p_CURRENT_VAL
			WHERE OBJECT_ID = p_OBJECT_ID;
		ELSIF p_COLUMN_NAME = c_COLNAME_IS_HIDDEN THEN
			UPDATE SYSTEM_OBJECT
			SET OBJECT_IS_HIDDEN = p_CURRENT_VAL
			WHERE OBJECT_ID = p_OBJECT_ID;
		--Save the Crystal Template -- the user can only copy the template string from the Imported or Original side.
		--  If it does not equal one of these, then it is not valid.
		ELSIF p_COLUMN_NAME = c_COLNAME_CRYSTAL THEN
			IF p_CURRENT_VAL = GET_CRYSTAL_STRING_FOR_SIDE(p_OBJECT_IMPORT_ID, p_OBJECT_ID, c_SIDE_ORIGINAL) THEN
				UPDATE_CRYSTAL_FROM_SIDE(p_OBJECT_IMPORT_ID, p_OBJECT_ID, c_SIDE_ORIGINAL);
			ELSIF p_CURRENT_VAL = GET_CRYSTAL_STRING_FOR_SIDE(p_OBJECT_IMPORT_ID, p_OBJECT_ID, c_SIDE_IMPORTED) THEN
				UPDATE_CRYSTAL_FROM_SIDE(p_OBJECT_IMPORT_ID, p_OBJECT_ID, c_SIDE_IMPORTED);
			ELSE
				ERRS.RAISE_BAD_ARGUMENT('Current Val', p_CURRENT_VAL, c_MSG_CRYSTAL_ORIG_OR_IMPORT);
			END IF;
		END IF;
	END IF;

END PUT_IMPORT_STATUS_RPT_DETAIL;
----------------------------------------------------------------------------------------------------
PROCEDURE SET_IMPORT_STATUS
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_NEW_IMPORT_STATUS IN VARCHAR2
	) AS
BEGIN
	CHECK_PRIVILEGE_MANAGE(p_OBJECT_IMPORT_ID);

	--You cannot open an import unless there are no other open imports.
	IF p_NEW_IMPORT_STATUS = c_IMPORT_STATUS_OPEN THEN
		CHECK_ALL_IMPORTS_ARE_CLOSED;
	END IF;

	UPDATE SYSTEM_OBJECT_IMPORT SET IMPORT_STATUS = p_NEW_IMPORT_STATUS WHERE OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID;
END SET_IMPORT_STATUS;
----------------------------------------------------------------------------------------------------
PROCEDURE PURGE_IMPORT_LOG
	(
	p_OBJECT_IMPORT_ID IN NUMBER
	) AS
BEGIN
	CHECK_PRIVILEGE_MANAGE(p_OBJECT_IMPORT_ID);
	CHECK_IMPORT_IS_CLOSED(p_OBJECT_IMPORT_ID);

	DELETE FROM SYSTEM_OBJECT_IMPORT WHERE OBJECT_IMPORT_ID = p_OBJECT_IMPORT_ID;

END PURGE_IMPORT_LOG;
----------------------------------------------------------------------------------------------------
PROCEDURE PREV_IMPORT_WARNING
	(
	p_OBJECT_IMPORT_ID IN NUMBER,
	p_PRODUCT_SCRIPT_TYPE IN VARCHAR2,
	p_WARNING_MESSAGE OUT VARCHAR2
	) AS
BEGIN
	IF p_OBJECT_IMPORT_ID <> GET_PREVIOUS_PRODUCT_IMPORT_ID(p_OBJECT_IMPORT_ID, p_PRODUCT_SCRIPT_TYPE) THEN
		p_WARNING_MESSAGE := 'Most recent import is necessary for future migration. ' ||
                              'Continue to purge the import if you plan to re-run the import immediately. ' ||
                              'Do you want to continue?';
	END IF;
END PREV_IMPORT_WARNING;
----------------------------------------------------------------------------------------------------
PROCEDURE CLOSE_OPEN_IMPORT AS
    v_OBJECT_IMPORT_ID SYSTEM_OBJECT_IMPORT.OBJECT_IMPORT_ID%TYPE;
BEGIN
    SELECT MAX(OBJECT_IMPORT_ID)
    INTO v_OBJECT_IMPORT_ID
    FROM SYSTEM_OBJECT_IMPORT
    WHERE IMPORT_STATUS = c_IMPORT_STATUS_OPEN;

    IF v_OBJECT_IMPORT_ID IS NOT NULL THEN
        SET_IMPORT_STATUS(v_OBJECT_IMPORT_ID, c_IMPORT_STATUS_CLOSED);
    END IF;
END CLOSE_OPEN_IMPORT;
----------------------------------------------------------------------------------------------------
END SO_IMPORT_EXPORT;
/
