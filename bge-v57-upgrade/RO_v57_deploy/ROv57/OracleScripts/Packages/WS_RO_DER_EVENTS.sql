CREATE OR REPLACE PACKAGE WS_RO_DER_EVENTS IS
-- $Revision: 1.7 $

FUNCTION WHAT_VERSION RETURN VARCHAR2;

PROCEDURE CREATE_EVENT
	(
	p_IDENTIFIED_BY    IN VARCHAR2 := NULL,
	p_VPP_IDENT        IN VARCHAR2,
	p_START_TIME       IN DATE,
	p_STOP_TIME        IN DATE,
	p_EVENT_TYPE       IN VARCHAR2 := NULL,
	p_EVENT_DESC       IN VARCHAR2 := NULL,
	p_SCHEDULE_DATES   IN DATE_COLLECTION := NULL,
	p_SCHEDULE_AMOUNTS IN NUMBER_COLLECTION := NULL,
	p_SCHEDULE_PRICES  IN NUMBER_COLLECTION := NULL,
	p_EVENT_IDENT      OUT VARCHAR2
	);

PROCEDURE UPDATE_EVENT
	(
	p_IDENTIFIED_BY    IN VARCHAR2 := NULL,
	p_EVENT_IDENT      IN VARCHAR2,
	p_START_TIME       IN DATE := NULL,
	p_STOP_TIME        IN DATE := NULL,
	p_EVENT_TYPE       IN VARCHAR2 := NULL,
	p_EVENT_DESC       IN VARCHAR2 := NULL,
	p_SCHEDULE_DATES   IN DATE_COLLECTION := NULL,
	p_SCHEDULE_AMOUNTS IN NUMBER_COLLECTION := NULL,
	p_SCHEDULE_PRICES  IN NUMBER_COLLECTION := NULL
	);

PROCEDURE START_EVENT
	(
	p_IDENTIFIED_BY         IN VARCHAR2 := NULL,
	p_EVENT_IDENT           IN VARCHAR2,
	p_EXTERNAL_SYSTEM_IDENT IN VARCHAR2
	);

PROCEDURE CONFIRM_EVENT
	(
	p_IDENTIFIED_BY         IN VARCHAR2 := NULL,
	p_EVENT_IDENT           IN VARCHAR2,
	p_EXTERNAL_SYSTEM_IDENT IN VARCHAR2,
	p_DER_OPTOUT_IDENTS     IN STRING_COLLECTION,
	p_DER_OPTOUT_DATES      IN DATE_COLLECTION
	);

PROCEDURE CANCEL_EVENT
	(
	p_IDENTIFIED_BY IN VARCHAR2 := NULL,
	p_EVENT_IDENT   IN VARCHAR2
	);

PROCEDURE STOP_ALL_EVENTS;

PROCEDURE RESUME_ALL_EVENTS;

PROCEDURE IMPORT_EVENT_REDUCTION
	(
	p_IDENTIFIED_BY         IN VARCHAR2 := NULL,
	p_EVENT_IDENT           IN VARCHAR2,
	p_EXTERNAL_SYSTEM_IDENT IN VARCHAR2,
	p_FEEDER_SECTION_IDENTS IN STRING_COLLECTION,
	p_SCHEDULE_DATES        IN DATE_COLLECTION_COLLECTION,
	p_SCHEDULE_AMOUNTS      IN NUMBER_COLLECTION_COLLECTION
	);

PROCEDURE IMPORT_PREMISE_RESULTS
	(
	p_IDENTIFIED_BY         IN VARCHAR2 := NULL,
	p_EVENT_IDENT           IN VARCHAR2,
	p_EXTERNAL_SYSTEM_IDENT IN VARCHAR2,
	p_PREMISE_IDENTS        IN STRING_COLLECTION,
	p_DER_TYPE_IDENTS       IN STRING_COLLECTION,
	p_OPTOUT_DATES 	        IN DATE_COLLECTION,
	p_OVERRIDE_DATES 	    IN DATE_COLLECTION,
	p_FAILURES              IN NUMBER_COLLECTION,
	p_SCHEDULE_DATES        IN DATE_COLLECTION_COLLECTION,
	p_SCHEDULE_AMOUNTS      IN NUMBER_COLLECTION_COLLECTION
	);

PROCEDURE IMPORT_DER_RESULTS
	(
	p_IDENTIFIED_BY         IN VARCHAR2 := NULL,
	p_EVENT_IDENT           IN VARCHAR2,
	p_EXTERNAL_SYSTEM_IDENT IN VARCHAR2,
	p_DER_IDENTS            IN STRING_COLLECTION,
	p_DER_OVERRIDE_DATES    IN DATE_COLLECTION,
	p_DER_FAILURE_DATES     IN DATE_COLLECTION,
	p_SCHEDULE_DATES        IN DATE_COLLECTION_COLLECTION,
	p_SCHEDULE_AMOUNTS      IN NUMBER_COLLECTION_COLLECTION
	);

PROCEDURE IMPORT_DERMS_FORECAST
	(
	p_IDENTIFIED_BY         IN VARCHAR2 := NULL,
	p_EXTERNAL_SYSTEM_IDENT IN VARCHAR2,
	p_PROGRAM_IDENT         IN VARCHAR2,
	p_FORECAST_TYPE	        IN VARCHAR2 := NULL,
	p_FEEDER_SECTION_IDENTS IN STRING_COLLECTION,
	p_DATES                 IN DATE_COLLECTION_COLLECTION,
	p_AVAILABILTY           IN NUMBER_COLLECTION_COLLECTION,
	p_CAPABILITY            IN NUMBER_COLLECTION_COLLECTION,
	p_PARTICIPANT_COUNT     IN NUMBER_COLLECTION_COLLECTION
	);

PROCEDURE IMPORT_FEEDER_SECTION_PRIORITY
	(
	p_IDENTIFIED_BY         IN VARCHAR2 := NULL,
	p_FEEDER_SECTION_IDENTS IN STRING_COLLECTION,
	p_PRIORITIES            IN NUMBER_COLLECTION
	);

END WS_RO_DER_EVENTS;
/
CREATE OR REPLACE PACKAGE BODY WS_RO_DER_EVENTS IS
--------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR2 IS
BEGIN
    RETURN '$Revision: 1.7 $';
END WHAT_VERSION;
---------------------------------------------------------------------------------------------------
PROCEDURE CREATE_EVENT
	(
	p_IDENTIFIED_BY    IN VARCHAR2 := NULL,
	p_VPP_IDENT        IN VARCHAR2,
	p_START_TIME       IN DATE,
	p_STOP_TIME        IN DATE,
	p_EVENT_TYPE       IN VARCHAR2 := NULL,
	p_EVENT_DESC       IN VARCHAR2 := NULL,
	p_SCHEDULE_DATES   IN DATE_COLLECTION := NULL,
	p_SCHEDULE_AMOUNTS IN NUMBER_COLLECTION := NULL,
	p_SCHEDULE_PRICES  IN NUMBER_COLLECTION := NULL,
	p_EVENT_IDENT      OUT VARCHAR2
	) AS
	v_VPP_ID   NUMBER;
	v_EVENT_ID NUMBER;
	v_SUCCESS_COUNT BINARY_INTEGER;
	v_FAIL_COUNT BINARY_INTEGER;
	v_EVENT_NAME VARCHAR2(32);
    v_START_TIME DATE;
    v_STOP_TIME DATE;
    v_SCHEDULE_DATES DATE_COLLECTION;
BEGIN
	v_VPP_ID := EI.GET_ID_FROM_WS_IDENTIFIER(p_VPP_IDENT, EC.ED_VPP, p_IDENTIFIED_BY);
    
    v_START_TIME := TO_CUT(p_START_TIME, 'GMT');
    v_STOP_TIME := TO_CUT(p_STOP_TIME, 'GMT');
    v_SCHEDULE_DATES := UT.CUT_DATE_COLL(p_SCHEDULE_DATES, 'GMT');

	DEMAND_RESPONSE.CREATE_EVENT(v_VPP_ID,
								 v_START_TIME,
								 v_STOP_TIME,
								 p_EVENT_TYPE,
								 p_EVENT_DESC,
								 v_SCHEDULE_DATES,
								 p_SCHEDULE_AMOUNTS,
								 p_SCHEDULE_PRICES,
								 v_EVENT_ID,
								 v_SUCCESS_COUNT,
								 v_FAIL_COUNT);
	-- For now, we can't do anything with the counts. When we are able to change this interface
	-- and return extra info, we will return information regarding how many dispatch messages were
	-- successfully sent and how many failed

	v_EVENT_NAME := EI.GET_ENTITY_NAME(EC.ED_DR_EVENT, v_EVENT_ID);

	EI.PUT_WS_IDENTIFIER_FOR_ID(v_EVENT_NAME, v_EVENT_ID, EC.ED_DR_EVENT, p_IDENTIFIED_BY);
	
	p_EVENT_IDENT := EI.GET_WS_IDENTIFIER_FROM_ID(v_EVENT_ID, EC.ED_DR_EVENT, p_IDENTIFIED_BY);

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_RAISE();
END CREATE_EVENT;
--------------------------------------------------------------------------------
PROCEDURE UPDATE_EVENT
	(
	p_IDENTIFIED_BY    IN VARCHAR2 := NULL,
	p_EVENT_IDENT      IN VARCHAR2,
	p_START_TIME       IN DATE := NULL,
	p_STOP_TIME        IN DATE := NULL,
	p_EVENT_TYPE       IN VARCHAR2 := NULL,
	p_EVENT_DESC       IN VARCHAR2 := NULL,
	p_SCHEDULE_DATES   IN DATE_COLLECTION := NULL,
	p_SCHEDULE_AMOUNTS IN NUMBER_COLLECTION := NULL,
	p_SCHEDULE_PRICES  IN NUMBER_COLLECTION := NULL
	) AS
	v_EVENT_ID NUMBER;
	v_SUCCESS_COUNT BINARY_INTEGER;
	v_FAIL_COUNT BINARY_INTEGER;
BEGIN
	v_EVENT_ID := EI.GET_ID_FROM_WS_IDENTIFIER(p_EVENT_IDENT, EC.ED_DR_EVENT, p_IDENTIFIED_BY);

	DEMAND_RESPONSE.UPDATE_EVENT(v_EVENT_ID,
								 p_START_TIME,
								 p_STOP_TIME,
								 p_EVENT_TYPE,
								 p_EVENT_DESC,
								 p_SCHEDULE_DATES,
								 p_SCHEDULE_AMOUNTS,
								 p_SCHEDULE_PRICES,
								 v_SUCCESS_COUNT,
								 v_FAIL_COUNT);
	-- For now, we can't do anything with the counts. When we are able to change this interface
	-- and return extra info, we will return information regarding how many dispatch messages were
	-- successfully sent and how many failed

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_RAISE();
END UPDATE_EVENT;
--------------------------------------------------------------------------------
PROCEDURE START_EVENT
	(
	p_IDENTIFIED_BY         IN VARCHAR2 := NULL,
	p_EVENT_IDENT           IN VARCHAR2,
	p_EXTERNAL_SYSTEM_IDENT IN VARCHAR2
	) AS
	v_EVENT_ID           NUMBER;
	v_EXTERNAL_SYSTEM_ID NUMBER;
BEGIN
	v_EVENT_ID := EI.GET_ID_FROM_WS_IDENTIFIER(p_EVENT_IDENT, EC.ED_DR_EVENT, p_IDENTIFIED_BY);
	v_EXTERNAL_SYSTEM_ID := EI.GET_ID_FROM_WS_IDENTIFIER(p_EXTERNAL_SYSTEM_IDENT,
														 EC.ED_EXTERNAL_SYSTEM,
														 p_IDENTIFIED_BY);

	DEMAND_RESPONSE.START_EVENT(v_EVENT_ID, v_EXTERNAL_SYSTEM_ID);
EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_RAISE();
END START_EVENT;
--------------------------------------------------------------------------------
PROCEDURE CONFIRM_EVENT
	(
	p_IDENTIFIED_BY         IN VARCHAR2 := NULL,
	p_EVENT_IDENT           IN VARCHAR2,
	p_EXTERNAL_SYSTEM_IDENT IN VARCHAR2,
	p_DER_OPTOUT_IDENTS     IN STRING_COLLECTION,
	p_DER_OPTOUT_DATES      IN DATE_COLLECTION
	) AS
	v_EVENT_ID           NUMBER;
	v_EXTERNAL_SYSTEM_ID NUMBER;
	v_DER_OPTOUT_IDS     NUMBER_COLLECTION;
	v_IDX                NUMBER;
    v_DER_OPTOUT_DATES   DATE_COLLECTION;
BEGIN
	v_EVENT_ID := EI.GET_ID_FROM_WS_IDENTIFIER(p_EVENT_IDENT, EC.ED_DR_EVENT, p_IDENTIFIED_BY);
	v_EXTERNAL_SYSTEM_ID := EI.GET_ID_FROM_WS_IDENTIFIER(p_EXTERNAL_SYSTEM_IDENT,
														 EC.ED_EXTERNAL_SYSTEM,
														 p_IDENTIFIED_BY);
	v_DER_OPTOUT_IDS := NUMBER_COLLECTION();
	v_IDX := p_DER_OPTOUT_IDENTS.FIRST;
	WHILE v_IDX IS NOT NULL LOOP
		v_DER_OPTOUT_IDS.EXTEND();
		v_DER_OPTOUT_IDS(v_IDX) := EI.GET_ID_FROM_WS_IDENTIFIER(p_DER_OPTOUT_IDENTS(v_IDX),
																EC.ED_DER,
																p_IDENTIFIED_BY);
		v_IDX := p_DER_OPTOUT_IDENTS.NEXT(v_IDX);
	END LOOP;
    
    v_DER_OPTOUT_DATES := UT.CUT_DATE_COLL(p_DER_OPTOUT_DATES, 'GMT');

	DEMAND_RESPONSE.CONFIRM_EVENT(v_EVENT_ID, v_EXTERNAL_SYSTEM_ID, v_DER_OPTOUT_IDS, v_DER_OPTOUT_DATES);
EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_RAISE();
END CONFIRM_EVENT;
--------------------------------------------------------------------------------
PROCEDURE CANCEL_EVENT
	(
	p_IDENTIFIED_BY IN VARCHAR2 := NULL,
	p_EVENT_IDENT   IN VARCHAR2
	) AS
	v_EVENT_ID NUMBER;
	v_SUCCESS_COUNT BINARY_INTEGER;
	v_FAIL_COUNT BINARY_INTEGER;
BEGIN
	v_EVENT_ID := EI.GET_ID_FROM_WS_IDENTIFIER(p_EVENT_IDENT, EC.ED_DR_EVENT, p_IDENTIFIED_BY);
	DEMAND_RESPONSE.CANCEL_EVENT(v_EVENT_ID,
								 v_SUCCESS_COUNT,
								 v_FAIL_COUNT);
	-- For now, we can't do anything with the counts. When we are able to change this interface
	-- and return extra info, we will return information regarding how many dispatch messages were
	-- successfully sent and how many failed
EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_RAISE();
END CANCEL_EVENT;
--------------------------------------------------------------------------------
PROCEDURE STOP_ALL_EVENTS AS
BEGIN
	DEMAND_RESPONSE.STOP_ALL_EVENTS();
EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_RAISE();
END STOP_ALL_EVENTS;
--------------------------------------------------------------------------------
PROCEDURE RESUME_ALL_EVENTS AS
BEGIN
	DEMAND_RESPONSE.RESUME_ALL_EVENTS();
EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_RAISE();
END RESUME_ALL_EVENTS;
--------------------------------------------------------------------------------
PROCEDURE IMPORT_EVENT_REDUCTION
	(
	p_IDENTIFIED_BY         IN VARCHAR2 := NULL,
	p_EVENT_IDENT           IN VARCHAR2,
	p_EXTERNAL_SYSTEM_IDENT IN VARCHAR2,
	p_FEEDER_SECTION_IDENTS IN STRING_COLLECTION,
	p_SCHEDULE_DATES        IN DATE_COLLECTION_COLLECTION,
	p_SCHEDULE_AMOUNTS      IN NUMBER_COLLECTION_COLLECTION
	) AS
	v_EVENT_ID           NUMBER;
	v_EXTERNAL_SYSTEM_ID NUMBER;
	v_FEEDER_SECTION_IDS NUMBER_COLLECTION;
	v_IDX                NUMBER;

	v_MIN_DATE DATE;
	v_MAX_DATE DATE;

	v_IMPORT_TO_SCHED SYSTEM_DICTIONARY.VALUE%TYPE;
	v_VPP_IDS NUMBER_COLLECTION := NUMBER_COLLECTION();
    v_SCHEDULE_DATES DATE_COLLECTION_COLLECTION;
BEGIN
	v_EVENT_ID := EI.GET_ID_FROM_WS_IDENTIFIER(p_EVENT_IDENT, EC.ED_DR_EVENT, p_IDENTIFIED_BY);
	v_EXTERNAL_SYSTEM_ID := EI.GET_ID_FROM_WS_IDENTIFIER(p_EXTERNAL_SYSTEM_IDENT,
														 EC.ED_EXTERNAL_SYSTEM,
														 p_IDENTIFIED_BY);
    v_FEEDER_SECTION_IDS := NUMBER_COLLECTION();
	v_IDX := p_FEEDER_SECTION_IDENTS.FIRST;
	WHILE v_IDX IS NOT NULL LOOP
		v_FEEDER_SECTION_IDS.EXTEND();
		v_FEEDER_SECTION_IDS(v_IDX) := EI.GET_ID_FROM_WS_IDENTIFIER(p_FEEDER_SECTION_IDENTS(v_IDX),
																	EC.ED_TX_FEEDER_SEGMENT,
																	p_IDENTIFIED_BY);
		v_IDX := p_FEEDER_SECTION_IDENTS.NEXT(v_IDX);
	END LOOP;
    
    v_SCHEDULE_DATES := UT.CUT_DATE_COLL_COLL(p_SCHEDULE_DATES, 'GMT');

	DEMAND_RESPONSE.IMPORT_EVENT_REDUCTION(v_EVENT_ID,
										   v_EXTERNAL_SYSTEM_ID,
										   v_FEEDER_SECTION_IDS,
										   v_SCHEDULE_DATES,
										   p_SCHEDULE_AMOUNTS);

	UT.GET_DATE_COLL_COLL_MIN_MAX(p_SCHEDULE_DATES, v_MIN_DATE, v_MAX_DATE);

	v_VPP_IDS.EXTEND();

	SELECT E.VPP_ID
	INTO v_VPP_IDS(1)
	FROM DR_EVENT E
	WHERE E.EVENT_ID = v_EVENT_ID;

	DER_CAPACITY_ENGINE.CALC_VPP_RESULT_FROM_SEGMENT(1, CONSTANTS.CODE_BACKCAST,
													GA.BASE_SCENARIO_ID, v_MIN_DATE, v_MAX_DATE,
													EC.ED_VPP, v_VPP_IDS, TRUE);


	-- Get the System Dictionary flag for copying to Schedules
	SP.GET_SYSTEM_DICTIONARY_VALUE(0,
								'Load Management',
								'Demand Response',
								'?',
								'?',
								'Import VPP External to Schedule',
								v_IMPORT_TO_SCHED);


	IF UT.BOOLEAN_FROM_STRING(v_IMPORT_TO_SCHED) THEN
		DEMAND_RESPONSE_UI.ACCEPT_VPPS_INTO_SCHEDULES(v_MIN_DATE, v_MAX_DATE, GA.CUT_TIME_ZONE,
													CONSTANTS.CODE_BACKCAST, 1, v_VPP_IDS);
	END IF;


END IMPORT_EVENT_REDUCTION;
--------------------------------------------------------------------------------
PROCEDURE IMPORT_PREMISE_RESULTS
	(
	p_IDENTIFIED_BY         IN VARCHAR2 := NULL,
	p_EVENT_IDENT           IN VARCHAR2,
	p_EXTERNAL_SYSTEM_IDENT IN VARCHAR2,
	p_PREMISE_IDENTS        IN STRING_COLLECTION,
	p_DER_TYPE_IDENTS       IN STRING_COLLECTION,
	p_OPTOUT_DATES 	        IN DATE_COLLECTION,
	p_OVERRIDE_DATES 	    IN DATE_COLLECTION,
	p_FAILURES              IN NUMBER_COLLECTION,
	p_SCHEDULE_DATES        IN DATE_COLLECTION_COLLECTION,
	p_SCHEDULE_AMOUNTS      IN NUMBER_COLLECTION_COLLECTION
	) AS
	v_EVENT_ID           NUMBER;
	v_EXTERNAL_SYSTEM_ID NUMBER;
	v_PREMISE_IDS        NUMBER_COLLECTION;
	v_DER_TYPE_IDS       NUMBER_COLLECTION;
	v_IDX                NUMBER;
    v_OPTOUT_DATES       DATE_COLLECTION;
    v_OVERRIDE_DATES     DATE_COLLECTION;
    v_SCHEDULE_DATES     DATE_COLLECTION_COLLECTION;
BEGIN
	v_EVENT_ID := EI.GET_ID_FROM_WS_IDENTIFIER(p_EVENT_IDENT, EC.ED_DR_EVENT, p_IDENTIFIED_BY);
	v_EXTERNAL_SYSTEM_ID := EI.GET_ID_FROM_WS_IDENTIFIER(p_EXTERNAL_SYSTEM_IDENT,
														 EC.ED_EXTERNAL_SYSTEM,
														 p_IDENTIFIED_BY);

	v_DER_TYPE_IDS := NUMBER_COLLECTION();
	v_IDX := p_DER_TYPE_IDENTS.FIRST;
	WHILE v_IDX IS NOT NULL LOOP
		v_DER_TYPE_IDS.EXTEND();
		v_DER_TYPE_IDS(v_IDX) := EI.GET_ID_FROM_WS_IDENTIFIER(p_DER_TYPE_IDENTS(v_IDX), EC.ED_DER_TYPE, p_IDENTIFIED_BY);
		v_IDX := p_DER_TYPE_IDENTS.NEXT(v_IDX);
	END LOOP;

	v_PREMISE_IDS := NUMBER_COLLECTION();
	v_IDX := p_PREMISE_IDENTS.FIRST;
	WHILE v_IDX IS NOT NULL LOOP
		v_PREMISE_IDS.EXTEND();
		v_PREMISE_IDS(v_IDX) := EI.GET_ID_FROM_WS_IDENTIFIER(p_PREMISE_IDENTS(v_IDX), EC.ED_SERVICE_LOCATION, p_IDENTIFIED_BY);
		v_IDX := p_PREMISE_IDENTS.NEXT(v_IDX);
	END LOOP;
    
    v_OPTOUT_DATES := UT.CUT_DATE_COLL(p_OPTOUT_DATES, 'GMT');
    v_OVERRIDE_DATES := UT.CUT_DATE_COLL(p_OVERRIDE_DATES, 'GMT');
    v_SCHEDULE_DATES := UT.CUT_DATE_COLL_COLL(p_SCHEDULE_DATES, 'GMT');

	DEMAND_RESPONSE.IMPORT_PREMISE_RESULTS(v_EVENT_ID,
									   		v_EXTERNAL_SYSTEM_ID,
									   		v_PREMISE_IDS,
											v_DER_TYPE_IDS,
											v_OPTOUT_DATES,
									   		v_OVERRIDE_DATES,
									   		p_FAILURES,
									   		v_SCHEDULE_DATES,
									   		p_SCHEDULE_AMOUNTS);
EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_RAISE();
END IMPORT_PREMISE_RESULTS;
--------------------------------------------------------------------------------
PROCEDURE IMPORT_DER_RESULTS
	(
	p_IDENTIFIED_BY         IN VARCHAR2 := NULL,
	p_EVENT_IDENT           IN VARCHAR2,
	p_EXTERNAL_SYSTEM_IDENT IN VARCHAR2,
	p_DER_IDENTS            IN STRING_COLLECTION,
	p_DER_OVERRIDE_DATES    IN DATE_COLLECTION,
	p_DER_FAILURE_DATES     IN DATE_COLLECTION,
	p_SCHEDULE_DATES        IN DATE_COLLECTION_COLLECTION,
	p_SCHEDULE_AMOUNTS      IN NUMBER_COLLECTION_COLLECTION
	) AS
	v_EVENT_ID           NUMBER;
	v_EXTERNAL_SYSTEM_ID NUMBER;
	v_DER_IDS            NUMBER_COLLECTION;
	v_IDX                NUMBER;
    v_DER_OVERRIDE_DATES DATE_COLLECTION;
    v_DER_FAILURE_DATES  DATE_COLLECTION;
    v_SCHEDULE_DATES     DATE_COLLECTION_COLLECTION;
BEGIN
	v_EVENT_ID := EI.GET_ID_FROM_WS_IDENTIFIER(p_EVENT_IDENT, EC.ED_DR_EVENT, p_IDENTIFIED_BY);
	v_EXTERNAL_SYSTEM_ID := EI.GET_ID_FROM_WS_IDENTIFIER(p_EXTERNAL_SYSTEM_IDENT,
														 EC.ED_EXTERNAL_SYSTEM,
														 p_IDENTIFIED_BY);

	v_DER_IDS := NUMBER_COLLECTION();
	v_IDX := p_DER_IDENTS.FIRST;
	WHILE v_IDX IS NOT NULL LOOP
		v_DER_IDS.EXTEND();
		v_DER_IDS(v_IDX) := EI.GET_ID_FROM_WS_IDENTIFIER(p_DER_IDENTS(v_IDX), EC.ED_DER, p_IDENTIFIED_BY);
		v_IDX := p_DER_IDENTS.NEXT(v_IDX);
	END LOOP;
    
    v_DER_OVERRIDE_DATES := UT.CUT_DATE_COLL(p_DER_OVERRIDE_DATES, 'GMT');
    v_DER_FAILURE_DATES := UT.CUT_DATE_COLL(p_DER_FAILURE_DATES, 'GMT');
    v_SCHEDULE_DATES := UT.CUT_DATE_COLL_COLL(p_SCHEDULE_DATES, 'GMT');

	DEMAND_RESPONSE.IMPORT_DER_RESULTS(v_EVENT_ID,
									   v_EXTERNAL_SYSTEM_ID,
									   v_DER_IDS,
									   v_DER_OVERRIDE_DATES,
									   v_DER_FAILURE_DATES,
									   v_SCHEDULE_DATES,
									   p_SCHEDULE_AMOUNTS);
EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_RAISE();
END IMPORT_DER_RESULTS;
--------------------------------------------------------------------------------
PROCEDURE IMPORT_DERMS_FORECAST
	(
	p_IDENTIFIED_BY         IN VARCHAR2 := NULL,
	p_EXTERNAL_SYSTEM_IDENT IN VARCHAR2,
	p_PROGRAM_IDENT         IN VARCHAR2,
	p_FORECAST_TYPE	        IN VARCHAR2 := NULL, -- Ignored - do not remove: required for interface compatibility
	p_FEEDER_SECTION_IDENTS IN STRING_COLLECTION,
	p_DATES                 IN DATE_COLLECTION_COLLECTION,
	p_AVAILABILTY           IN NUMBER_COLLECTION_COLLECTION,
	p_CAPABILITY            IN NUMBER_COLLECTION_COLLECTION,
	p_PARTICIPANT_COUNT     IN NUMBER_COLLECTION_COLLECTION
	) AS
	v_EXTERNAL_SYSTEM_ID NUMBER;
	v_PROGRAM_ID         NUMBER;
	v_FEEDER_SECTION_IDS NUMBER_COLLECTION;
	v_IDX                NUMBER;
	v_MIN_DATE DATE;
	v_MAX_DATE DATE;

	v_IMPORT_TO_SCHED SYSTEM_DICTIONARY.VALUE%TYPE;
	v_VPP_IDS NUMBER_COLLECTION := NUMBER_COLLECTION();
    v_DATES DATE_COLLECTION_COLLECTION;
BEGIN
	v_EXTERNAL_SYSTEM_ID := EI.GET_ID_FROM_WS_IDENTIFIER(p_EXTERNAL_SYSTEM_IDENT,
														 EC.ED_EXTERNAL_SYSTEM,
														 p_IDENTIFIED_BY);
	v_PROGRAM_ID := EI.GET_ID_FROM_WS_IDENTIFIER(p_PROGRAM_IDENT, EC.ED_PROGRAM, p_IDENTIFIED_BY);

	v_FEEDER_SECTION_IDS := NUMBER_COLLECTION();
	v_IDX := p_FEEDER_SECTION_IDENTS.FIRST;
	WHILE v_IDX IS NOT NULL LOOP
		v_FEEDER_SECTION_IDS.EXTEND();
		v_FEEDER_SECTION_IDS(v_IDX) := EI.GET_ID_FROM_WS_IDENTIFIER(p_FEEDER_SECTION_IDENTS(v_IDX),
																	EC.ED_TX_FEEDER_SEGMENT,
																	p_IDENTIFIED_BY);
		v_IDX := p_FEEDER_SECTION_IDENTS.NEXT(v_IDX);
	END LOOP;
    
    v_DATES := UT.CUT_DATE_COLL_COLL(p_DATES, 'GMT');

	DEMAND_RESPONSE.IMPORT_DERMS_FORECAST(v_EXTERNAL_SYSTEM_ID,
										  v_PROGRAM_ID,
										  v_FEEDER_SECTION_IDS,
										  v_DATES,
										  p_AVAILABILTY,
										  p_CAPABILITY,
										  p_PARTICIPANT_COUNT);

	UT.GET_DATE_COLL_COLL_MIN_MAX(v_DATES, v_MIN_DATE, v_MAX_DATE);

	SELECT DISTINCT VPP.VPP_ID
	BULK COLLECT INTO v_VPP_IDS
	FROM TX_FEEDER_SEGMENT SEG, TX_FEEDER F,
		TX_SUB_STATION SS, SERVICE_ZONE SZ,
		VIRTUAL_POWER_PLANT VPP,
		TABLE(CAST(v_FEEDER_SECTION_IDS AS NUMBER_COLLECTION)) X
	WHERE SEG.FEEDER_SEGMENT_ID = X.COLUMN_VALUE
		AND F.FEEDER_ID = SEG.FEEDER_ID
		AND SS.SUB_STATION_ID = F.SUB_STATION_ID
		AND SZ.SERVICE_ZONE_ID = SS.SERVICE_ZONE_ID
		AND VPP.SERVICE_ZONE_ID = SZ.SERVICE_ZONE_ID
		AND VPP.PROGRAM_ID = v_PROGRAM_ID;

	DER_CAPACITY_ENGINE.CALC_VPP_RESULT_FROM_SEGMENT(1, CONSTANTS.CODE_FORECAST,
													GA.BASE_SCENARIO_ID, v_MIN_DATE, v_MAX_DATE,
													EC.ED_VPP, v_VPP_IDS, TRUE);

	-- SINCE EXTERNAL DATA COULD BE DRIVING THE INTERNAL VPP FORECAST DATA, (USING DER_SEG_RESULT_IS_EXT)
	-- RECALC INTERNAL VPP FORECAST
	DER_CAPACITY_ENGINE.CALC_VPP_RESULT_FROM_SEGMENT(0, CONSTANTS.CODE_FORECAST,
													GA.BASE_SCENARIO_ID, v_MIN_DATE, v_MAX_DATE,
													EC.ED_VPP, v_VPP_IDS, TRUE);

	-- Get the System Dictionary flag for copying to Schedules
	SP.GET_SYSTEM_DICTIONARY_VALUE(0,
								'Load Management',
								'Demand Response',
								'?',
								'?',
								'Import VPP External to Schedule',
								v_IMPORT_TO_SCHED);

	IF UT.BOOLEAN_FROM_STRING(v_IMPORT_TO_SCHED) THEN
		DEMAND_RESPONSE.ACCEPT_VPPS_INTO_SCHEDULES(v_MIN_DATE, v_MAX_DATE, GA.CUT_TIME_ZONE, CONSTANTS.CODE_FORECAST, 1, v_VPP_IDS);
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_RAISE();
END IMPORT_DERMS_FORECAST;
--------------------------------------------------------------------------------
PROCEDURE IMPORT_FEEDER_SECTION_PRIORITY
	(
	p_IDENTIFIED_BY         IN VARCHAR2 := NULL,
	p_FEEDER_SECTION_IDENTS IN STRING_COLLECTION,
	p_PRIORITIES            IN NUMBER_COLLECTION
	) AS
	v_FEEDER_SECTION_IDS NUMBER_COLLECTION;
    v_PRIORITIES         NUMBER_COLLECTION;
    v_FEEDER_SECTION_ID  NUMBER;
	v_IDX                NUMBER;
BEGIN
	v_FEEDER_SECTION_IDS := NUMBER_COLLECTION();
    v_PRIORITIES := NUMBER_COLLECTION();
	v_IDX := p_FEEDER_SECTION_IDENTS.FIRST;
	WHILE v_IDX IS NOT NULL LOOP
        -- 9/21/09 - BZ 21327 - DDZ - EI.GET_ID_FROM_WS_IDENTIFIER generates a No Entity Found
        -- Exception when it can't find a Feeder Segment, which will stop the entire
        -- import, so now this method has an exception block
        BEGIN
		    v_FEEDER_SECTION_ID := EI.GET_ID_FROM_WS_IDENTIFIER(p_FEEDER_SECTION_IDENTS(v_IDX),
																	    EC.ED_TX_FEEDER_SEGMENT,
																	    p_IDENTIFIED_BY);
        EXCEPTION
            WHEN MSGCODES.e_ERR_NO_SUCH_ENTRY THEN
                v_FEEDER_SECTION_ID := NULL;
                ERRS.LOG_AND_CONTINUE();
        END;
        IF v_FEEDER_SECTION_ID IS NOT NULL THEN
            v_FEEDER_SECTION_IDS.EXTEND();
            v_FEEDER_SECTION_IDS(v_FEEDER_SECTION_IDS.LAST) := v_FEEDER_SECTION_ID;
            v_PRIORITIES.EXTEND();
            v_PRIORITIES(v_PRIORITIES.LAST) := p_PRIORITIES(v_IDX);
        END IF;
		v_IDX := p_FEEDER_SECTION_IDENTS.NEXT(v_IDX);
	END LOOP;
	DEMAND_RESPONSE.IMPORT_FEEDER_SEGMENT_PRIORITY(v_FEEDER_SECTION_IDS, v_PRIORITIES);

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_RAISE();
END IMPORT_FEEDER_SECTION_PRIORITY;
--------------------------------------------------------------------------------
END WS_RO_DER_EVENTS;
/
