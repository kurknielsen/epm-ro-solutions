CREATE OR REPLACE PACKAGE BODY MM_PJM_GEN_REPORTS IS

g_ALL_DATA NUMBER(9) := SD.g_ALL_DATA_ENTITY_ID;
g_NOT_SUBMITTED VARCHAR2(16) := 'Not Submitted';
k_Pumped_Storage_Hydro       constant varchar2(64):='Pumped Storage Hydro'; --jab
k_Non_Pumped_Storage_Hydro   constant varchar2(64):='Non Pumped Storage Hydro';  --jab
k_PERIOD1                    constant varchar2(64):='PERIOD1';  --jab
k_PERIOD2                    constant varchar2(64):='PERIOD2';  --jab
---------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR2 IS
BEGIN
    RETURN '$Revision: 1.1 $';
END WHAT_VERSION;
---------------------------------------------------------------------------------------------------
PROCEDURE NULL_CURSOR
    (
	p_CURSOR IN OUT REF_CURSOR
	) AS

BEGIN
	OPEN p_CURSOR FOR
		SELECT NULL FROM DUAL;
END NULL_CURSOR;
-------------------------------------------------------------------------------------
FUNCTION GET_SINGLE_STATUS
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SUBMIT_STATUS IN VARCHAR2,
	p_MARKET_STATUS IN VARCHAR2
	) RETURN VARCHAR2 IS
BEGIN
	RETURN CASE
		WHEN p_TRANSACTION_ID IS NULL THEN 'Missing'
		WHEN p_SUBMIT_STATUS = 'Submitted' THEN NVL(p_MARKET_STATUS,'Rejected')
		ELSE NVL(p_SUBMIT_STATUS, g_NOT_SUBMITTED)
	END;
END GET_SINGLE_STATUS;
-------------------------------------------------------------------------------------
PROCEDURE GET_UNIT_DETAILS_RPT
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_IS_SCHEDULE_DETAILS IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR,
    p_UNIT_TYPE IN VARCHAR2,
    p_PERIOD_TYPE IN VARCHAR2,
    p_TRANS_ID IN NUMBER   
	) AS

	v_SCHEDULE_STATE NUMBER(1) := 1;
	v_SC_ID NUMBER(9) := EI.GET_ID_FROM_IDENTIFIER_EXTSYS('PJM', EC.ED_SC, EC.ES_PJM);
	v_ALLOWED_TXNS ID_TABLE := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_TXN_SELECT);
	v_ALL_TXNS NUMBER(1) := 0;
	v_BEGIN_DATE DATE;
	v_END_DATE DATE;
	v_INTERVAL_NUMBER NUMBER(3);
	v_DAY_INTERVAL_TYPE NUMBER(1) := 2;
	v_PJM_TXN_TYPE VARCHAR2(16) := CASE NVL(p_IS_SCHEDULE_DETAILS,0) WHEN 1 THEN MM_PJM_EMKT_UTIL.g_PJM_GEN_SCHEDULE_TXN_TYPE ELSE MM_PJM_EMKT_UTIL.g_PJM_GEN_UNIT_DATA_TXN_TYPE END;
	v_TRAIT_GROUP_TYPE VARCHAR2(16) := CASE NVL(p_IS_SCHEDULE_DETAILS,0) WHEN 1 THEN '%' ELSE 'UnitDetail' END;
    V_COUNT NUMBER;
    v_period1_begin     date:=to_date('01-apr-'||to_char(p_begin_date,'yyyy'));
    v_period1_end       date:=last_day(to_date('01-sep-'||to_char(p_begin_date,'yyyy')));
    v_period2_begin     date:=to_date('01-oct-'||to_char(p_begin_date,'yyyy'));
    v_period2_end       date:=last_day(to_date('01-mar-'||to_char(to_number(to_char(p_begin_date,'yyyy')) + 1)));
    v_period_bool       boolean;
    v_PERIOD_NUM        number:=0;


BEGIN

    --BZ 17168 - enhancements to the PJM Generation reports (added additional parameters required for pumped storage units)
    v_PERIOD_NUM := 0;
    IF p_PERIOD_TYPE = k_period1 and p_begin_date between v_period1_begin and v_period1_end THEN
        v_PERIOD_NUM := 1;
    ELSIF p_PERIOD_TYPE = k_period2 and p_begin_date between v_period2_begin and v_period2_end THEN
       v_PERIOD_NUM := 1;
    END IF;

	v_INTERVAL_NUMBER := GET_INTERVAL_NUMBER('Day');
	UT.CUT_DATE_RANGE(1, p_BEGIN_DATE, p_BEGIN_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	p_STATUS := GA.SUCCESS;

	IF v_ALLOWED_TXNS(1).ID = g_ALL_DATA THEN v_ALL_TXNS := 1; END IF;

    IF UPPER(p_UNIT_TYPE) = UPPER(k_Pumped_Storage_Hydro) THEN
         v_COUNT := 1;
    ELSE v_COUNT := 0;
    END IF;

	OPEN p_CURSOR FOR
		SELECT T.RESOURCE_NAME, T.PSE_NAME,
			T.CUT_DATE_SCHEDULING,
			TO_CHAR(T.GROUP_ORDER,'0000') "GROUP_ORDER",
			NVL(SET_NUMBER, 1) "SET_NUMBER",
			T.IS_SERIES,
			T.TRAIT_ORDER,
			T.TRAIT_GROUP_ID,
			T.TRANSACTION_ID,
			T.TRAIT_INDEX,
			T.GROUP_DISPLAY_NAME,
			T.TRANSACTION_ALIAS,
			T.AGREEMENT_TYPE,
			T.DISPLAY_NAME || CASE T.IS_SERIES WHEN 1 THEN NVL(TO_CHAR(SET_NUMBER),'1') ELSE '' END "DISPLAY_NAME",
			DATA_TYPE, EDIT_MASK, COMBO_LIST, FORMAT,
			ITS.TRAIT_VAL TRAIT_VAL,
        
			GET_SINGLE_STATUS(ITSS.TRANSACTION_ID, ITSS.SUBMIT_STATUS, ITSS.MARKET_STATUS) "SUBMIT_STATUS"
		FROM IT_TRAIT_SCHEDULE ITS, IT_TRAIT_SCHEDULE_STATUS ITSS,
			(SELECT TXN.TRANSACTION_NAME, TXN.TRANSACTION_ALIAS, TXN.AGREEMENT_TYPE, TXN.TRANSACTION_ID, R.RESOURCE_ID, R.RESOURCE_NAME, P.PSE_NAME, TR.TRAIT_GROUP_ID,
				TR.TRAIT_INDEX, TG.IS_SERIES, TG.DISPLAY_NAME "GROUP_DISPLAY_NAME", TR.DISPLAY_NAME, TG.DISPLAY_ORDER "GROUP_ORDER", SDT.CUT_DATE_SCHEDULING,
				TR.DATA_TYPE, TR.EDIT_MASK, TR.COMBO_LIST, TR.FORMAT, TR.DISPLAY_ORDER "TRAIT_ORDER"
			FROM PJM_GEN_TXNS_BY_TYPE TXN,                 
                 (
                 select nvl(purp.ATTRIBUTE_VAl,k_Non_Pumped_Storage_Hydro ) pump_storage,sr.*
                 from   SUPPLY_RESOURCE SR,
                        (select purp.ATTRIBUTE_VAl,OWNER_ENTITY_ID
                         from   TEMPORAL_ENTITY_ATTRIBUTE PURP,
                                ENTITY_ATTRIBUTE ea
                         where  ea.attribute_name = 'UNIT_TYPE'
                         and    ea.ATTRIBUTE_ID = purp.ATTRIBUTE_ID
                        ) purp
                 where PURP.OWNER_ENTITY_ID (+) = SR.RESOURCE_ID
                 ) r, --jab
				INTERCHANGE_CONTRACT IC, PURCHASING_SELLING_ENTITY P,
				TRANSACTION_TRAIT_ATTRIBUTES TR, TRANSACTION_TRAIT_GROUP TG,
				SYSTEM_DATE_TIME SDT, IT_STATUS STAT
			WHERE TXN.TRANSACTION_TYPE = 'Generation'
				AND TXN.PJM_GEN_TXN_TYPE = v_PJM_TXN_TYPE
				AND TXN.IS_BID_OFFER = 1
				AND p_BEGIN_DATE <= TXN.END_DATE
				AND p_END_DATE >= TXN.BEGIN_DATE
				AND STAT.TRANSACTION_ID = TXN.TRANSACTION_ID
				AND STAT.TRANSACTION_IS_ACTIVE = 1
				AND (v_ALL_TXNS = 1 OR TXN.TRANSACTION_ID IN (SELECT IDS.ID FROM TABLE(CAST(v_ALLOWED_TXNS AS ID_TABLE)) IDS))
				AND NOT EXISTS (SELECT 1 FROM PJM_SERVICE_POINT_OWNERSHIP WHERE SERVICE_POINT_ID = TXN.POD_ID AND CONTRACT_ID = TXN.CONTRACT_ID AND BEGIN_DATE <= p_END_DATE AND NVL(END_DATE, p_END_DATE) >= p_BEGIN_DATE AND IS_SCHEDULER = 0)
				AND R.RESOURCE_ID = TXN.RESOURCE_ID
                and PUMP_STORAGE =  p_UNIT_TYPE
				AND IC.CONTRACT_ID = TXN.CONTRACT_ID
				AND P.PSE_ID = IC.BILLING_ENTITY_ID
				AND TG.SC_ID = v_SC_ID
				AND TG.TRAIT_CATEGORY = v_PJM_TXN_TYPE
                and (TXN.TRANSACTION_ID = p_TRANS_ID OR P_TRANS_ID = -1) 
				AND TG.TRAIT_GROUP_TYPE LIKE v_TRAIT_GROUP_TYPE
				AND TR.TRAIT_GROUP_ID = TG.TRAIT_GROUP_ID
                AND TR.DISPLAY_NAME = CASE WHEN UPPER(p_UNIT_TYPE) <> UPPER(k_Pumped_Storage_Hydro) AND TR.DISPLAY_NAME IN('PS Pump Factor','PS Initial MWH','PS Final MWH','PS Max MWH','PS Min MWH','PS Min Gen','PS Min Pump') THEN NULL ELSE TR.DISPLAY_NAME  END
				AND SDT.TIME_ZONE = p_TIME_ZONE
				AND SDT.DATA_INTERVAL_TYPE = v_DAY_INTERVAL_TYPE
				AND SDT.DAY_TYPE = '1'
				AND SDT.CUT_DATE_SCHEDULING BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND SDT.MINIMUM_INTERVAL_NUMBER >= v_INTERVAL_NUMBER
                and 1= v_PERIOD_NUM --jab
			) T
		WHERE ITS.TRANSACTION_ID(+) = T.TRANSACTION_ID
			AND ITS.SCHEDULE_STATE(+) = v_SCHEDULE_STATE
			AND ITS.SCHEDULE_DATE(+) = T.CUT_DATE_SCHEDULING
			AND ITS.TRAIT_GROUP_ID(+) = T.TRAIT_GROUP_ID
			AND ITS.TRAIT_INDEX(+) = T.TRAIT_INDEX
			AND ITSS.TRANSACTION_ID(+) = T.TRANSACTION_ID
			AND ITSS.SCHEDULE_DATE(+) = T.CUT_DATE_SCHEDULING
UNION all
select      ' Total ' RESOURCE_NAME,
            '  ' PSE_NAME,
            NULL CUT_DATE_SCHEDULING, 
            GROUP_ORDER,
            SET_NUMBER,
            IS_SERIES,
            TRAIT_ORDER,
            TRAIT_GROUP_ID,
           NULL TRANSACTION_ID,
            TRAIT_INDEX,
            GROUP_DISPLAY_NAME,
            NULL TRANSACTION_ALIAS,
            NULL AGREEMENT_TYPE,
            DISPLAY_NAME,
            DATA_TYPE,
            EDIT_MASK,
            COMBO_LIST,
            FORMAT,
            to_char(sum(to_number(TRAIT_VAL))) TRAIT_VAL,           
            NULL SUBMIT_STATUS
from
     (
       SELECT T.RESOURCE_NAME, T.PSE_NAME,
            T.CUT_DATE_SCHEDULING,
            TO_CHAR(T.GROUP_ORDER,'0000') "GROUP_ORDER",
            NVL(SET_NUMBER, 1) "SET_NUMBER",
            T.IS_SERIES,
            T.TRAIT_ORDER,
            T.TRAIT_GROUP_ID,
            T.TRANSACTION_ID,
            T.TRAIT_INDEX,
            T.GROUP_DISPLAY_NAME,
            T.TRANSACTION_ALIAS,
            T.AGREEMENT_TYPE,
            T.DISPLAY_NAME || CASE T.IS_SERIES WHEN 1 THEN NVL(TO_CHAR(SET_NUMBER),'1') ELSE '' END "DISPLAY_NAME",
            DATA_TYPE, EDIT_MASK, COMBO_LIST, FORMAT,
            ITS.TRAIT_VAL TRAIT_VAL ,
            1 TRAIT_VAL_NUM,
            GET_SINGLE_STATUS(ITSS.TRANSACTION_ID, ITSS.SUBMIT_STATUS, ITSS.MARKET_STATUS) "SUBMIT_STATUS"
        FROM IT_TRAIT_SCHEDULE ITS, IT_TRAIT_SCHEDULE_STATUS ITSS,
            (SELECT TXN.TRANSACTION_NAME, TXN.TRANSACTION_ALIAS, TXN.AGREEMENT_TYPE, TXN.TRANSACTION_ID, R.RESOURCE_ID, R.RESOURCE_NAME, P.PSE_NAME, TR.TRAIT_GROUP_ID,
                TR.TRAIT_INDEX, TG.IS_SERIES, TG.DISPLAY_NAME "GROUP_DISPLAY_NAME", TR.DISPLAY_NAME, TG.DISPLAY_ORDER "GROUP_ORDER", SDT.CUT_DATE_SCHEDULING,
                TR.DATA_TYPE, TR.EDIT_MASK, TR.COMBO_LIST, TR.FORMAT, TR.DISPLAY_ORDER "TRAIT_ORDER"
            FROM PJM_GEN_TXNS_BY_TYPE TXN,                 
                 (
                 select nvl(purp.ATTRIBUTE_VAl,k_Non_Pumped_Storage_Hydro ) pump_storage,sr.*
                 from   SUPPLY_RESOURCE SR,
                        (select purp.ATTRIBUTE_VAl,OWNER_ENTITY_ID
                         from   TEMPORAL_ENTITY_ATTRIBUTE PURP,
                                ENTITY_ATTRIBUTE ea
                         where  ea.attribute_name = 'UNIT_TYPE'
                         and    ea.ATTRIBUTE_ID = purp.ATTRIBUTE_ID
                        ) purp
                 where PURP.OWNER_ENTITY_ID (+) = SR.RESOURCE_ID
                 ) r, --jab
                INTERCHANGE_CONTRACT IC, PURCHASING_SELLING_ENTITY P,
                TRANSACTION_TRAIT_ATTRIBUTES TR, TRANSACTION_TRAIT_GROUP TG,
                SYSTEM_DATE_TIME SDT, IT_STATUS STAT
            WHERE TXN.TRANSACTION_TYPE = 'Generation'
                AND TXN.PJM_GEN_TXN_TYPE = v_PJM_TXN_TYPE
                AND TXN.IS_BID_OFFER = 1
                AND p_BEGIN_DATE <= TXN.END_DATE
                AND p_END_DATE >= TXN.BEGIN_DATE
                AND STAT.TRANSACTION_ID = TXN.TRANSACTION_ID
                AND STAT.TRANSACTION_IS_ACTIVE = 1
                AND (v_ALL_TXNS = 1 OR TXN.TRANSACTION_ID IN (SELECT IDS.ID FROM TABLE(CAST(v_ALLOWED_TXNS AS ID_TABLE)) IDS))
                AND NOT EXISTS (SELECT 1 FROM PJM_SERVICE_POINT_OWNERSHIP WHERE SERVICE_POINT_ID = TXN.POD_ID AND CONTRACT_ID = TXN.CONTRACT_ID AND BEGIN_DATE <= p_END_DATE AND NVL(END_DATE, p_END_DATE) >= p_BEGIN_DATE AND IS_SCHEDULER = 0)
                and TR.DATA_TYPE = 'Number'
                AND R.RESOURCE_ID = TXN.RESOURCE_ID
                and PUMP_STORAGE =  p_UNIT_TYPE
                AND IC.CONTRACT_ID = TXN.CONTRACT_ID
                AND P.PSE_ID = IC.BILLING_ENTITY_ID
                AND TG.SC_ID = v_SC_ID
                AND TG.TRAIT_CATEGORY = v_PJM_TXN_TYPE
                AND TG.TRAIT_GROUP_TYPE LIKE v_TRAIT_GROUP_TYPE
                AND TR.TRAIT_GROUP_ID = TG.TRAIT_GROUP_ID
                and (TXN.TRANSACTION_ID = p_TRANS_ID OR P_TRANS_ID = -1)
                AND TR.DISPLAY_NAME = CASE WHEN UPPER(p_UNIT_TYPE) <> UPPER(k_Pumped_Storage_Hydro) AND TR.DISPLAY_NAME IN('PS Pump Factor','PS Initial MWH','PS Final MWH','PS Max MWH','PS Min MWH','PS Min Gen','PS Min Pump') THEN NULL ELSE TR.DISPLAY_NAME  END
                AND SDT.TIME_ZONE = p_TIME_ZONE
                AND SDT.DATA_INTERVAL_TYPE = v_DAY_INTERVAL_TYPE
                AND SDT.DAY_TYPE = '1'
                AND SDT.CUT_DATE_SCHEDULING BETWEEN v_BEGIN_DATE AND v_END_DATE
                AND SDT.MINIMUM_INTERVAL_NUMBER >= v_INTERVAL_NUMBER
                and 1= v_PERIOD_NUM --jab
            ) T
        WHERE ITS.TRANSACTION_ID(+) = T.TRANSACTION_ID
            AND ITS.SCHEDULE_STATE(+) = v_SCHEDULE_STATE
            AND ITS.SCHEDULE_DATE(+) = T.CUT_DATE_SCHEDULING
            AND ITS.TRAIT_GROUP_ID(+) = T.TRAIT_GROUP_ID
            AND ITS.TRAIT_INDEX(+) = T.TRAIT_INDEX
            AND ITSS.TRANSACTION_ID(+) = T.TRANSACTION_ID
            AND ITSS.SCHEDULE_DATE(+) = T.CUT_DATE_SCHEDULING
    )
group by    GROUP_ORDER,
            SET_NUMBER,
            IS_SERIES,
            TRAIT_ORDER,
            TRAIT_GROUP_ID,
            TRAIT_INDEX,
            GROUP_DISPLAY_NAME,
            DISPLAY_NAME,
            DATA_TYPE,
            EDIT_MASK,
            COMBO_LIST,
            FORMAT
		ORDER BY 1,2,3,4,5,6;  

END GET_UNIT_DETAILS_RPT;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_SCHED_DETAILS_RPT
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_IS_SCHEDULE_DETAILS IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

	v_SCHEDULE_STATE NUMBER(1) := 1;
	v_SC_ID NUMBER(9) := EI.GET_ID_FROM_IDENTIFIER_EXTSYS('PJM', EC.ED_SC, EC.ES_PJM);
	v_ALLOWED_TXNS ID_TABLE := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_TXN_SELECT);
	v_ALL_TXNS NUMBER(1) := 0;
	v_BEGIN_DATE DATE;
	v_END_DATE DATE;
	v_INTERVAL_NUMBER NUMBER(3);
	v_DAY_INTERVAL_TYPE NUMBER(1) := 2;
	v_PJM_TXN_TYPE VARCHAR2(16) := CASE NVL(p_IS_SCHEDULE_DETAILS,0) WHEN 1 THEN MM_PJM_EMKT_UTIL.g_PJM_GEN_SCHEDULE_TXN_TYPE ELSE MM_PJM_EMKT_UTIL.g_PJM_GEN_UNIT_DATA_TXN_TYPE END;
	v_TRAIT_GROUP_TYPE VARCHAR2(16) := CASE NVL(p_IS_SCHEDULE_DETAILS,0) WHEN 1 THEN '%' ELSE 'UnitDetail' END;
BEGIN

	v_INTERVAL_NUMBER := GET_INTERVAL_NUMBER('Day');
	UT.CUT_DATE_RANGE(1, p_BEGIN_DATE, p_BEGIN_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	p_STATUS := GA.SUCCESS;

	IF v_ALLOWED_TXNS(1).ID = g_ALL_DATA THEN v_ALL_TXNS := 1; END IF;

	OPEN p_CURSOR FOR
		SELECT T.RESOURCE_NAME, T.PSE_NAME,
			T.CUT_DATE_SCHEDULING,
			TO_CHAR(T.GROUP_ORDER,'0000') "GROUP_ORDER",
			NVL(SET_NUMBER, 1) "SET_NUMBER",
			T.IS_SERIES,
			T.TRAIT_ORDER,
			T.TRAIT_GROUP_ID,
			T.TRANSACTION_ID,
			T.TRAIT_INDEX,
			T.GROUP_DISPLAY_NAME,
			T.TRANSACTION_ALIAS,
			T.AGREEMENT_TYPE,
			T.DISPLAY_NAME || CASE T.IS_SERIES WHEN 1 THEN NVL(TO_CHAR(SET_NUMBER),'1') ELSE '' END "DISPLAY_NAME",
			DATA_TYPE, EDIT_MASK, COMBO_LIST, FORMAT,
			ITS.TRAIT_VAL,
			GET_SINGLE_STATUS(ITSS.TRANSACTION_ID, ITSS.SUBMIT_STATUS, ITSS.MARKET_STATUS) "SUBMIT_STATUS"
		FROM IT_TRAIT_SCHEDULE ITS, IT_TRAIT_SCHEDULE_STATUS ITSS,
			(SELECT TXN.TRANSACTION_NAME, TXN.TRANSACTION_ALIAS, TXN.AGREEMENT_TYPE, TXN.TRANSACTION_ID, R.RESOURCE_ID, R.RESOURCE_NAME, P.PSE_NAME, TR.TRAIT_GROUP_ID,
				TR.TRAIT_INDEX, TG.IS_SERIES, TG.DISPLAY_NAME "GROUP_DISPLAY_NAME", TR.DISPLAY_NAME, TG.DISPLAY_ORDER "GROUP_ORDER", SDT.CUT_DATE_SCHEDULING,
				TR.DATA_TYPE, TR.EDIT_MASK, TR.COMBO_LIST, TR.FORMAT, TR.DISPLAY_ORDER "TRAIT_ORDER"
			FROM PJM_GEN_TXNS_BY_TYPE TXN, SUPPLY_RESOURCE R,
				INTERCHANGE_CONTRACT IC, PURCHASING_SELLING_ENTITY P,
				TRANSACTION_TRAIT_ATTRIBUTES TR, TRANSACTION_TRAIT_GROUP TG,
				SYSTEM_DATE_TIME SDT, IT_STATUS STAT
			WHERE TXN.TRANSACTION_TYPE = 'Generation'
				AND TXN.PJM_GEN_TXN_TYPE = v_PJM_TXN_TYPE
				AND TXN.IS_BID_OFFER = 1
				AND p_BEGIN_DATE <= TXN.END_DATE
				AND p_END_DATE >= TXN.BEGIN_DATE
				AND STAT.TRANSACTION_ID = TXN.TRANSACTION_ID
				AND STAT.TRANSACTION_IS_ACTIVE = 1
				AND (v_ALL_TXNS = 1 OR TXN.TRANSACTION_ID IN (SELECT IDS.ID FROM TABLE(CAST(v_ALLOWED_TXNS AS ID_TABLE)) IDS))
				AND NOT EXISTS (SELECT 1 FROM PJM_SERVICE_POINT_OWNERSHIP WHERE SERVICE_POINT_ID = TXN.POD_ID AND CONTRACT_ID = TXN.CONTRACT_ID AND BEGIN_DATE <= p_END_DATE AND NVL(END_DATE, p_END_DATE) >= p_BEGIN_DATE AND IS_SCHEDULER = 0)
				AND R.RESOURCE_ID = TXN.RESOURCE_ID
				AND IC.CONTRACT_ID = TXN.CONTRACT_ID
				AND P.PSE_ID = IC.BILLING_ENTITY_ID
				AND TG.SC_ID = v_SC_ID
				AND TG.TRAIT_CATEGORY = v_PJM_TXN_TYPE
				AND TG.TRAIT_GROUP_TYPE LIKE v_TRAIT_GROUP_TYPE
				AND TR.TRAIT_GROUP_ID = TG.TRAIT_GROUP_ID
				AND SDT.TIME_ZONE = p_TIME_ZONE
				AND SDT.DATA_INTERVAL_TYPE = v_DAY_INTERVAL_TYPE
				AND SDT.DAY_TYPE = '1'
				AND SDT.CUT_DATE_SCHEDULING BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND SDT.MINIMUM_INTERVAL_NUMBER >= v_INTERVAL_NUMBER
			) T
		WHERE ITS.TRANSACTION_ID(+) = T.TRANSACTION_ID
			AND ITS.SCHEDULE_STATE(+) = v_SCHEDULE_STATE
			AND ITS.SCHEDULE_DATE(+) = T.CUT_DATE_SCHEDULING
			AND ITS.TRAIT_GROUP_ID(+) = T.TRAIT_GROUP_ID
			AND ITS.TRAIT_INDEX(+) = T.TRAIT_INDEX
			AND ITSS.TRANSACTION_ID(+) = T.TRANSACTION_ID
			AND ITSS.SCHEDULE_DATE(+) = T.CUT_DATE_SCHEDULING
		ORDER BY 1,2,3,4,5,6;

END GET_SCHED_DETAILS_RPT;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_RESOURCE_TXN_LIST
    (
    p_PJM_TXN_TYPE IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

    v_ATTRIBUTE_ID NUMBER(9);
	v_ALLOWED_TXNS ID_TABLE := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_TXN_SELECT);
BEGIN

    p_STATUS := GA.SUCCESS;

    IF p_PJM_TXN_TYPE IS NOT NULL THEN
	  ID.ID_FOR_ENTITY_ATTRIBUTE('PJM_PNODEID', EC.ED_SUPPLY_RESOURCE, 'String', FALSE, v_ATTRIBUTE_ID);
      OPEN p_CURSOR FOR
      SELECT
             A.RESOURCE_NAME,
             T.TRANSACTION_ID,
             T.PJM_GEN_TXN_TYPE
			FROM
				SUPPLY_RESOURCE A,
				TEMPORAL_ENTITY_ATTRIBUTE B,
				PJM_GEN_TXNS_BY_TYPE T,
				TABLE(CAST(v_ALLOWED_TXNS AS ID_TABLE)) IDS,
				IT_STATUS S
			WHERE
				B.OWNER_ENTITY_ID = A.RESOURCE_ID
				AND B.ATTRIBUTE_ID = v_ATTRIBUTE_ID
				AND T.RESOURCE_ID = A.RESOURCE_ID
				AND T.PJM_GEN_TXN_TYPE = p_PJM_TXN_TYPE
				AND T.BEGIN_DATE <= p_END_DATE
				AND T.END_DATE >= p_BEGIN_DATE
				AND S.TRANSACTION_ID = T.TRANSACTION_ID
				AND S.TRANSACTION_IS_ACTIVE = 1
				AND (IDS.ID = g_ALL_DATA OR IDS.ID = T.TRANSACTION_ID)
				--Only get Tier 2 Spin since that's what we query into.
				AND T.AGREEMENT_TYPE = CASE p_PJM_TXN_TYPE WHEN MM_PJM_EMKT_UTIL.g_PJM_GEN_SPIN_RES_TXN_TYPE THEN 'Tier2' ELSE T.AGREEMENT_TYPE END
				AND NOT EXISTS (SELECT 1 FROM PJM_SERVICE_POINT_OWNERSHIP WHERE SERVICE_POINT_ID = T.POD_ID AND CONTRACT_ID = T.CONTRACT_ID AND BEGIN_DATE <= p_END_DATE AND NVL(END_DATE, p_END_DATE) >= p_BEGIN_DATE AND IS_SCHEDULER = 0)
			ORDER BY
				RESOURCE_NAME;
    ELSE
        NULL_CURSOR(p_CURSOR);
    END IF;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END GET_RESOURCE_TXN_LIST;
--------------------------------------------------------------------------------------------------------
--BZ 17168 - enhancements to the PJM Generation reports (added additional parameters required for pumped storage units)
PROCEDURE GET_RESOURCE_TXN_LIST_ALL
    (
    p_PJM_TXN_TYPE IN VARCHAR2,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_UNIT_TYPE in VARCHAR2,
    p_STATUS OUT NUMBER,
    p_CURSOR IN OUT REF_CURSOR
    ) AS

   v_ATTRIBUTE_ID NUMBER(9);
	v_ALLOWED_TXNS ID_TABLE := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_TXN_SELECT);
BEGIN

    p_STATUS := GA.SUCCESS;

    ut.debug_trace(p_PJM_TXN_TYPE);
    ut.debug_trace(p_UNIT_TYPE);

    IF p_PJM_TXN_TYPE IS NOT NULL THEN
      ID.ID_FOR_ENTITY_ATTRIBUTE('PJM_PNODEID', EC.ED_SUPPLY_RESOURCE, 'String', FALSE, v_ATTRIBUTE_ID);
      OPEN p_CURSOR FOR
      SELECT
             A.RESOURCE_NAME,
             T.TRANSACTION_ID,
             T.PJM_GEN_TXN_TYPE
			FROM
				--SUPPLY_RESOURCE A,
               (SELECT A.*
                FROM  SUPPLY_RESOURCE A,
                (select nvl(purp.ATTRIBUTE_VAl,k_Non_Pumped_Storage_Hydro ) pump_storage,sr.resource_id
                 from   SUPPLY_RESOURCE SR,
                        (select purp.ATTRIBUTE_VAl,OWNER_ENTITY_ID
                         from   TEMPORAL_ENTITY_ATTRIBUTE PURP,
                                ENTITY_ATTRIBUTE ea
                         where  ea.attribute_name = 'UNIT_TYPE'
                         and    ea.ATTRIBUTE_ID = purp.ATTRIBUTE_ID
                        ) purp
                 where PURP.OWNER_ENTITY_ID (+) = SR.RESOURCE_ID
                 ) r
                WHERE r.resource_id = a.resource_id
                and   r.pump_storage = p_UNIT_TYPE
                ) A,
				TEMPORAL_ENTITY_ATTRIBUTE B,
				PJM_GEN_TXNS_BY_TYPE T,
				TABLE(CAST(v_ALLOWED_TXNS AS ID_TABLE)) IDS,
				IT_STATUS S
			WHERE
				B.OWNER_ENTITY_ID = A.RESOURCE_ID
				AND B.ATTRIBUTE_ID = v_ATTRIBUTE_ID
				AND T.RESOURCE_ID = A.RESOURCE_ID
				AND T.PJM_GEN_TXN_TYPE = p_PJM_TXN_TYPE
				AND T.BEGIN_DATE <= p_END_DATE
				AND T.END_DATE >= p_BEGIN_DATE
				AND S.TRANSACTION_ID = T.TRANSACTION_ID
				AND S.TRANSACTION_IS_ACTIVE = 1
				AND (IDS.ID = g_ALL_DATA OR IDS.ID = T.TRANSACTION_ID)
				--Only get Tier 2 Spin since that's what we query into.
				AND T.AGREEMENT_TYPE = CASE p_PJM_TXN_TYPE WHEN MM_PJM_EMKT_UTIL.g_PJM_GEN_SPIN_RES_TXN_TYPE THEN 'Tier2' ELSE T.AGREEMENT_TYPE END
				AND NOT EXISTS (SELECT 1 FROM PJM_SERVICE_POINT_OWNERSHIP WHERE SERVICE_POINT_ID = T.POD_ID AND CONTRACT_ID = T.CONTRACT_ID AND BEGIN_DATE <= p_END_DATE AND NVL(END_DATE, p_END_DATE) >= p_BEGIN_DATE AND IS_SCHEDULER = 0)
			UNION ALL
                SELECT
                  ' ALL ' RESOURCE_NAME,
                 -1       TRANSACTION_ID,
                  ' ALL ' PJM_GEN_TXN_TYPE
                FROM DUAL
    				RESOURCE_NAME
             ORDER BY
				RESOURCE_NAME;
    ELSE
        NULL_CURSOR(p_CURSOR);
    END IF;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END GET_RESOURCE_TXN_LIST_ALL;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_RESOURCE_LIST
    (
    p_PJM_TXN_TYPE IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

    v_ATTRIBUTE_ID NUMBER(9);
	v_ALLOWED_TXNS ID_TABLE := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_TXN_SELECT);
BEGIN

    p_STATUS := GA.SUCCESS;

    IF p_PJM_TXN_TYPE IS NOT NULL THEN
      ID.ID_FOR_ENTITY_ATTRIBUTE('PJM_PNODEID', EC.ED_SUPPLY_RESOURCE, 'String', FALSE, v_ATTRIBUTE_ID);
		OPEN p_CURSOR FOR
			SELECT
				DISTINCT
				A.RESOURCE_NAME,
				A.RESOURCE_ID
			FROM
				SUPPLY_RESOURCE A,
				TEMPORAL_ENTITY_ATTRIBUTE B,
				PJM_GEN_TXNS_BY_TYPE T,
				TABLE(CAST(v_ALLOWED_TXNS AS ID_TABLE)) IDS,
				IT_STATUS S
			WHERE
				B.OWNER_ENTITY_ID = A.RESOURCE_ID
				AND B.ATTRIBUTE_ID = v_ATTRIBUTE_ID
				AND T.RESOURCE_ID = A.RESOURCE_ID
				AND T.PJM_GEN_TXN_TYPE = p_PJM_TXN_TYPE
				AND T.BEGIN_DATE <= p_END_DATE
				AND T.END_DATE >= p_BEGIN_DATE
				AND S.TRANSACTION_ID = T.TRANSACTION_ID
				AND S.TRANSACTION_IS_ACTIVE = 1
				AND (IDS.ID = g_ALL_DATA OR IDS.ID = T.TRANSACTION_ID)
				AND NOT EXISTS (SELECT 1 FROM PJM_SERVICE_POINT_OWNERSHIP WHERE SERVICE_POINT_ID = T.POD_ID AND CONTRACT_ID = T.CONTRACT_ID AND BEGIN_DATE <= p_END_DATE AND NVL(END_DATE, p_END_DATE) >= p_BEGIN_DATE AND IS_SCHEDULER = 0)
			ORDER BY
	            RESOURCE_NAME;
    ELSE
        NULL_CURSOR(p_CURSOR);
    END IF;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END GET_RESOURCE_LIST;
-------------------------------------------------------------------------------------------------
PROCEDURE GET_PRICE_COST_CURVE_RPT_SUMM
    (
	p_RESOURCE_ID IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INTERVAL IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_OFFSET NUMBER := 0;
v_INTERVAL VARCHAR2(16);
v_DAY_INTERVAL_TYPE NUMBER(1);
v_FROM_CUT_INTERVAL VARCHAR2(4);
v_INTERVAL_NUMBER NUMBER;
v_WORK_ID NUMBER(9);
v_SCHEDULE_STATE NUMBER(1) := NVL(p_SCHEDULE_STATE, 1);
BEGIN

    -- Return immediately if we don't have a TRANSACTION_ID
    IF p_RESOURCE_ID IS NULL OR p_RESOURCE_ID = TG.g_NO_ENTITY_ID THEN
        NULL_CURSOR(p_CURSOR);
        RETURN;
    END IF;

	--Get the interval of data to display.
	v_INTERVAL := 'Day';
	v_INTERVAL_NUMBER := GET_INTERVAL_NUMBER(v_INTERVAL);
	v_DAY_INTERVAL_TYPE := 2;
	v_FROM_CUT_INTERVAL := 'DD';

	-- Add the traits that are specific to this report.
	UT.GET_RTO_WORK_ID(v_WORK_ID);
	UT.POST_RTO_WORK(v_WORK_ID, TG.g_TI_OFFER_PRICE, TG.g_TG_OFFER_CURVE);
	UT.POST_RTO_WORK(v_WORK_ID, TG.g_TI_OFFER_QUANTITY, TG.g_TG_OFFER_CURVE);
	UT.POST_RTO_WORK(v_WORK_ID, 1, MM_PJM_UTIL.g_TG_SEL_AVAILABLE);

    --Make sure we have data in the SYSTEM_DATE_TIME table.  Return an error if not.
	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, p_BEGIN_DATE, p_END_DATE);

    p_STATUS := GA.SUCCESS;

    UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	-- recompute offset - it may need to be one hour off of a multiple of 24 hours if looking
	-- back crosses a DST day
	v_OFFSET := v_BEGIN_DATE - (TO_CUT(TRUNC(p_BEGIN_DATE-v_OFFSET),p_TIME_ZONE)+1/86400);
	v_BEGIN_DATE := v_BEGIN_DATE-v_OFFSET;
	v_END_DATE := v_END_DATE-v_OFFSET;

    OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(CUT_DATE_SCHEDULING + v_OFFSET, p_TIME_ZONE, v_FROM_CUT_INTERVAL) "SCHEDULE_DATE_STR",
			A.TRANSACTION_ID,
			A.TRANSACTION_IDENTIFIER,
			A.TRANSACTION_NAME,
			A.TRANSACTION_ALIAS "SCHEDULE_NAME",
			A.TRANSACTION_DESC "SCHEDULE_DESCRIPTION",
			A.SCHEDULE_NUMBER,
			A.TRAIT_GROUP_ID,
			A.TRAIT_INDEX,
			NVL(A.GROUP_DISPLAY_NAME, NVL(A.TRAIT_GROUP_NAME, ' ')) "TRAIT_GROUP_NAME",
			CASE WHEN A.IS_SERIES = 0 THEN A.DISPLAY_NAME ELSE A.DISPLAY_NAME || NVL(B.SET_NUMBER,1) END "DISPLAY_NAME",
			NVL(B.SET_NUMBER, 1) "SET_NUMBER",
			A.DATA_TYPE, A.EDIT_MASK, A.COMBO_LIST, A.FORMAT, B.TRAIT_VAL,
			TO_NUMBER(TO_CHAR(A.CUT_DATE_SCHEDULING,'HH24')) "ROWNUM",
			ROWNUM "REAL_ROWNUM",
			CUT_DATE_SCHEDULING + v_OFFSET "CUT_DATE_SCHEDULING",
			GROUP_ORDER, TRAIT_ORDER,
			GET_SINGLE_STATUS(C.TRANSACTION_ID, C.SUBMIT_STATUS, C.MARKET_STATUS) "SUBMIT_STATUS",
			NVL(U.USER_DISPLAY_NAME, U.USER_NAME) AS SUBMITTED_BY,
			C.SUBMIT_DATE
		FROM (SELECT IT.TRANSACTION_ID, IT.TRANSACTION_IDENTIFIER, IT.TRANSACTION_NAME, IT.TRANSACTION_ALIAS, IT.TRANSACTION_DESC,
					IT.AGREEMENT_TYPE "SCHEDULE_NUMBER",
					Z.CUT_DATE_SCHEDULING, X.TRAIT_GROUP_NAME,
					X.DISPLAY_NAME "GROUP_DISPLAY_NAME", X.DISPLAY_ORDER "GROUP_ORDER",
					X.TRAIT_GROUP_ID, X.IS_STATEMENT_TYPE_SPECIFIC, X.IS_SERIES,
					Y.TRAIT_INDEX, Y.DISPLAY_NAME, Y.DISPLAY_ORDER "TRAIT_ORDER",
					Y.DATA_TYPE, Y.EDIT_MASK, Y.COMBO_LIST, Y.FORMAT
            FROM TRANSACTION_TRAIT_GROUP X, TRANSACTION_TRAIT_ATTRIBUTES Y, SYSTEM_DATE_TIME Z, RTO_WORK TR, PJM_GEN_TXNS_BY_TYPE IT
			WHERE IT.RESOURCE_ID = p_RESOURCE_ID
				AND IT.BEGIN_DATE <= p_END_DATE
				AND IT.END_DATE >= p_BEGIN_DATE
				AND TR.WORK_ID = v_WORK_ID
    			AND X.TRAIT_GROUP_ID = TR.WORK_XID
    			AND X.IS_SPARSE = 0
    			AND Y.TRAIT_GROUP_ID = X.TRAIT_GROUP_ID
    			AND Y.TRAIT_INDEX = TR.WORK_SEQ
                AND Z.TIME_ZONE = p_TIME_ZONE
                AND Z.DATA_INTERVAL_TYPE = v_DAY_INTERVAL_TYPE
                AND Z.DAY_TYPE = 1
                AND Z.CUT_DATE_SCHEDULING BETWEEN v_BEGIN_DATE AND v_END_DATE
    		    AND Z.MINIMUM_INTERVAL_NUMBER >= v_INTERVAL_NUMBER
                AND IT.PJM_GEN_TXN_TYPE = 'Schedule'
            ) A,
			IT_TRAIT_SCHEDULE B, IT_TRAIT_SCHEDULE_STATUS C, APPLICATION_USER U
		WHERE B.TRANSACTION_ID(+) = A.TRANSACTION_ID
			AND B.SCHEDULE_STATE(+) = v_SCHEDULE_STATE
			AND B.SCHEDULE_DATE(+) = A.CUT_DATE_SCHEDULING
			AND B.TRAIT_GROUP_ID(+) = A.TRAIT_GROUP_ID
			AND B.TRAIT_INDEX(+) = A.TRAIT_INDEX
			AND B.STATEMENT_TYPE_ID(+) = CASE A.IS_STATEMENT_TYPE_SPECIFIC WHEN 0 THEN 0 ELSE p_SCHEDULE_TYPE END
			AND C.TRANSACTION_ID(+) = A.TRANSACTION_ID
			AND C.SCHEDULE_DATE(+) = A.CUT_DATE_SCHEDULING
			AND U.USER_ID (+) = C.SUBMITTED_BY_ID
		ORDER BY GROUP_ORDER, SET_NUMBER, TRAIT_ORDER, CUT_DATE_SCHEDULING;

		UT.PURGE_RTO_WORK(v_WORK_ID);
END GET_PRICE_COST_CURVE_RPT_SUMM;
-------------------------------------------------------------------------------------

PROCEDURE PUT_PRICE_COST_CURVE_RPT_SUMM
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_CUT_DATE_SCHEDULING IN DATE,
	p_TRAIT_GROUP_ID IN NUMBER,
	p_TRAIT_INDEX IN NUMBER,
	p_SET_NUMBER IN NUMBER,
	p_TRAIT_VAL IN VARCHAR,
	p_CURVE_MULTIPLIER IN NUMBER,
	p_CURVE_ADDER IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS
	v_ADJUSTED_TRAIT_VAL IT_TRAIT_SCHEDULE.TRAIT_VAL%TYPE;
BEGIN

	-- Adjust the Offer Curve Price by the Multiplier and Adder
	IF p_TRAIT_GROUP_ID = 1 AND p_TRAIT_INDEX = 1 THEN
		BEGIN
			v_ADJUSTED_TRAIT_VAL := TO_NUMBER(p_TRAIT_VAL) * NVL(p_CURVE_MULTIPLIER, 1) + NVL(p_CURVE_ADDER, 0);
		EXCEPTION
			WHEN OTHERS THEN
				v_ADJUSTED_TRAIT_VAL := p_TRAIT_VAL;
		END;
	ELSE
		v_ADJUSTED_TRAIT_VAL := p_TRAIT_VAL;
	END IF;

	TG.PUT_IT_TRAIT_SCHED_DETAIL_RPT(p_TRANSACTION_ID, p_SCHEDULE_STATE, p_SCHEDULE_TYPE, p_CUT_DATE_SCHEDULING, p_TRAIT_GROUP_ID, p_TRAIT_INDEX, p_SET_NUMBER,
		v_ADJUSTED_TRAIT_VAL, NULL, NULL, NULL);

END PUT_PRICE_COST_CURVE_RPT_SUMM;
-------------------------------------------------------------------------------------
FUNCTION GET_BID_OFFER_INTERVAL
	(
	p_TRANSACTION IN INTERCHANGE_TRANSACTION%ROWTYPE
	) RETURN VARCHAR2 IS
v_PJM_TXN_TYPE VARCHAR2(64);
BEGIN

	SELECT T.PJM_GEN_TXN_TYPE
	INTO v_PJM_TXN_TYPE
	FROM PJM_GEN_TXNS_BY_TYPE T
	WHERE T.TRANSACTION_ID = p_TRANSACTION.TRANSACTION_ID;

	IF v_PJM_TXN_TYPE = MM_PJM_EMKT_UTIL.g_PJM_GEN_UNIT_DATA_TXN_TYPE THEN
		RETURN 'Hour';
    ELSIF v_PJM_TXN_TYPE = MM_PJM_EMKT_UTIL.g_PJM_GEN_SCHEDULE_TXN_TYPE THEN
		RETURN 'Day';
    ELSIF v_PJM_TXN_TYPE = MM_PJM_EMKT_UTIL.g_PJM_GEN_REGULATION_TXN_TYPE THEN
         RETURN 'Day';
    ELSIF v_PJM_TXN_TYPE = MM_PJM_EMKT_UTIL.g_PJM_GEN_SPIN_RES_TXN_TYPE THEN
         RETURN 'Day';
	END IF;
END GET_BID_OFFER_INTERVAL;
-------------------------------------------------------------------------------------
PROCEDURE GET_UNIT_UPDATE_SUMMARY_RPT
	(
	p_BEGIN_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS
	v_SCHEDULE_STATE NUMBER(1) := 1;
	v_BEGIN_DATE DATE;
	v_END_DATE DATE;
	v_INTERVAL_NUMBER NUMBER(3);
	v_DAY_INTERVAL_TYPE NUMBER(1) := 1;
	v_SC_ID NUMBER(9) := EI.GET_ID_FROM_IDENTIFIER_EXTSYS('PJM', EC.ED_SC, EC.ES_PJM);
	v_ALLOWED_TXNS ID_TABLE := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_TXN_SELECT);
	v_ALLOW_ALL_DATA NUMBER(1) := 0;
BEGIN
	v_INTERVAL_NUMBER := GET_INTERVAL_NUMBER('Hour');

	UT.CUT_DATE_RANGE(1, p_BEGIN_DATE, p_BEGIN_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	IF v_ALLOWED_TXNS(v_ALLOWED_TXNS.FIRST).ID = g_ALL_DATA THEN
		v_ALLOW_ALL_DATA := 1;
	END IF;

	OPEN p_CURSOR FOR
		SELECT RESOURCE_NAME, PSE_NAME, DISPLAY_ORDER, TRANSACTION_ID, TRAIT_GROUP_ID,
			TRAIT_INDEX, DISPLAY_NAME, RESOURCE_ID,
			CASE WHEN MIN_VAL = MAX_VAL THEN MIN_VAL ELSE 'various' END "TRAIT_VAL"
		FROM
			(
			SELECT T.PSE_NAME, T.RESOURCE_NAME, T.TRAIT_GROUP_ID, T.TRANSACTION_ID,
				T.TRAIT_INDEX, T.DISPLAY_NAME, T.DISPLAY_ORDER, T.RESOURCE_ID,
				MIN(NVL(ITS.TRAIT_VAL,' ')) "MIN_VAL", MAX(NVL(ITS.TRAIT_VAL,' ')) "MAX_VAL"
			FROM IT_TRAIT_SCHEDULE ITS,
				(SELECT TXN.TRANSACTION_NAME, TXN.TRANSACTION_ID, R.RESOURCE_ID, R.RESOURCE_NAME, P.PSE_NAME, TR.TRAIT_GROUP_ID,
					TR.TRAIT_INDEX, TR.DISPLAY_NAME, TG.DISPLAY_ORDER, SDT.CUT_DATE_SCHEDULING
				FROM PJM_GEN_TXNS_BY_TYPE TXN, SUPPLY_RESOURCE R,
					INTERCHANGE_CONTRACT IC, PURCHASING_SELLING_ENTITY P,
					TRANSACTION_TRAIT_ATTRIBUTES TR, TRANSACTION_TRAIT_GROUP TG,
					SYSTEM_DATE_TIME SDT, IT_STATUS STAT
				WHERE TXN.TRANSACTION_TYPE = 'Generation'
					AND TXN.PJM_GEN_TXN_TYPE = 'Unit Data'
					AND p_BEGIN_DATE BETWEEN TXN.BEGIN_DATE AND TXN.END_DATE
					AND STAT.TRANSACTION_ID = TXN.TRANSACTION_ID
					AND STAT.TRANSACTION_IS_ACTIVE = 1
					AND (v_ALLOW_ALL_DATA = 1 OR TXN.TRANSACTION_ID IN (SELECT IDS.ID FROM TABLE(CAST(v_ALLOWED_TXNS AS ID_TABLE)) IDS))
					AND R.RESOURCE_ID = TXN.RESOURCE_ID
					AND IC.CONTRACT_ID = TXN.CONTRACT_ID
					AND P.PSE_ID = IC.BILLING_ENTITY_ID
					--IF YOU CHANGE THIS, BE SURE TO CHANGE THE ROLL_FORWARD_UNIT_UPDATES PROC AS WELL!!
					AND TG.SC_ID = v_SC_ID
					AND TG.TRAIT_CATEGORY = 'Unit Data'
					AND TG.TRAIT_GROUP_TYPE = 'Summary'
					AND TR.TRAIT_GROUP_ID = TG.TRAIT_GROUP_ID
					AND TR.TRAIT_INDEX = 1
					AND SDT.TIME_ZONE = p_TIME_ZONE
					AND SDT.DATA_INTERVAL_TYPE = v_DAY_INTERVAL_TYPE
					AND SDT.DAY_TYPE = 1
					AND SDT.CUT_DATE_SCHEDULING BETWEEN v_BEGIN_DATE AND v_END_DATE
					AND SDT.MINIMUM_INTERVAL_NUMBER >= v_INTERVAL_NUMBER
				) T
			WHERE ITS.TRANSACTION_ID(+) = T.TRANSACTION_ID
				AND ITS.SCHEDULE_STATE(+) = v_SCHEDULE_STATE
				AND ITS.SCHEDULE_DATE(+) = T.CUT_DATE_SCHEDULING
				AND ITS.TRAIT_GROUP_ID(+) = T.TRAIT_GROUP_ID
				AND ITS.TRAIT_INDEX(+) = T.TRAIT_INDEX
				AND ITS.SET_NUMBER(+) = 1
				AND ITS.STATEMENT_TYPE_ID(+) = 0
			GROUP BY T.PSE_NAME, T.RESOURCE_NAME, T.TRAIT_GROUP_ID, T.TRANSACTION_ID,
				T.TRAIT_INDEX, T.DISPLAY_NAME, T.DISPLAY_ORDER, T.RESOURCE_ID
			) A
		ORDER BY 1,2,3;

END GET_UNIT_UPDATE_SUMMARY_RPT;
-------------------------------------------------------------------------------------
PROCEDURE ROLL_FORWARD_UNIT_UPDATES
	(
	p_FROM_DATE IN DATE,
	p_TO_DATE IN DATE,
	p_DELETE_EXISTING_DATA IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_MESSAGE OUT VARCHAR2
	) AS
	v_TRAIT_GROUP_IDS ID_TABLE := ID_TABLE();
	v_SC_ID NUMBER(9) := EI.GET_ID_FROM_IDENTIFIER_EXTSYS('PJM', EC.ED_SC, EC.ES_PJM);
BEGIN
	SELECT ID_TYPE(TRAIT_GROUP_ID)
	BULK COLLECT INTO v_TRAIT_GROUP_IDS
	FROM TRANSACTION_TRAIT_GROUP TG
	WHERE TG.SC_ID = v_SC_ID
		AND TG.TRAIT_CATEGORY = 'Unit Data'
		AND TG.TRAIT_GROUP_TYPE = 'Summary'
		AND TG.TRAIT_GROUP_INTERVAL = 'Hour';

	TG.ROLL_FORWARD_TRAIT_GROUPS(p_FROM_DATE, p_TO_DATE, v_TRAIT_GROUP_IDS, p_DELETE_EXISTING_DATA, p_TIME_ZONE, p_MESSAGE);

END ROLL_FORWARD_UNIT_UPDATES;
-------------------------------------------------------------------------------------
PROCEDURE ROLL_FORWARD_REG_UPDATES
	(
	p_FROM_DATE IN DATE,
	p_TO_DATE IN DATE,
	p_DELETE_EXISTING_DATA IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_MESSAGE OUT VARCHAR2
	) AS
	v_TRAIT_GROUP_IDS ID_TABLE := ID_TABLE();
	v_SC_ID NUMBER(9) := EI.GET_ID_FROM_IDENTIFIER_EXTSYS('PJM', EC.ED_SC, EC.ES_PJM);
BEGIN
	SELECT ID_TYPE(TRAIT_GROUP_ID)
	BULK COLLECT INTO v_TRAIT_GROUP_IDS
	FROM TRANSACTION_TRAIT_GROUP TG
	WHERE TG.SC_ID = v_SC_ID
		AND TG.TRAIT_CATEGORY = 'Regulation'
		AND TG.TRAIT_GROUP_INTERVAL = 'Hour';

	TG.ROLL_FORWARD_TRAIT_GROUPS(p_FROM_DATE, p_TO_DATE, v_TRAIT_GROUP_IDS, p_DELETE_EXISTING_DATA, p_TIME_ZONE, p_MESSAGE);

END ROLL_FORWARD_REG_UPDATES;
-------------------------------------------------------------------------------------
PROCEDURE ROLL_FORWARD_SPIN_UPDATES
	(
	p_FROM_DATE IN DATE,
	p_TO_DATE IN DATE,
	p_DELETE_EXISTING_DATA IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_MESSAGE OUT VARCHAR2
	) AS
	v_TRAIT_GROUP_IDS ID_TABLE := ID_TABLE();
	v_SC_ID NUMBER(9) := EI.GET_ID_FROM_IDENTIFIER_EXTSYS('PJM', EC.ED_SC, EC.ES_PJM);
BEGIN
	SELECT ID_TYPE(TRAIT_GROUP_ID)
	BULK COLLECT INTO v_TRAIT_GROUP_IDS
	FROM TRANSACTION_TRAIT_GROUP TG
	WHERE TG.SC_ID = v_SC_ID
		AND TG.TRAIT_CATEGORY = 'Spinning Reserve'
		AND TG.TRAIT_GROUP_INTERVAL = 'Hour';

	TG.ROLL_FORWARD_TRAIT_GROUPS(p_FROM_DATE, p_TO_DATE, v_TRAIT_GROUP_IDS, p_DELETE_EXISTING_DATA, p_TIME_ZONE, p_MESSAGE);

END ROLL_FORWARD_SPIN_UPDATES;
-------------------------------------------------------------------------------------
PROCEDURE GET_UNIT_SCHEDULE_RPT
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CURSOR IN OUT REF_CURSOR,
	p_STATUS OUT NUMBER
	) AS
	v_ALLOWED_TXNS ID_TABLE := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_TXN_SELECT);
BEGIN

	OPEN p_CURSOR FOR
	SELECT TRANSACTION_NAME,
		TXN.TRANSACTION_ID,
		TXN.RESOURCE_ID,
		IC.BILLING_ENTITY_ID "PSE_ID",
		TXN.AGREEMENT_TYPE "SCHEDULE_NUMBER",
		TXN.TRANSACTION_ALIAS "SCHEDULE_NAME",
		TXN.TRANSACTION_DESC "SCHEDULE_DESCRIPTION"
	FROM PJM_GEN_TXNS_BY_TYPE TXN, IT_STATUS S,
		INTERCHANGE_CONTRACT IC,
		TABLE(CAST(v_ALLOWED_TXNS AS ID_TABLE)) IDS
	WHERE TXN.PJM_GEN_TXN_TYPE = MM_PJM_EMKT_UTIL.g_PJM_GEN_SCHEDULE_TXN_TYPE
		AND TXN.BEGIN_DATE <= p_END_DATE
		AND TXN.END_DATE >= p_BEGIN_DATE
		AND S.TRANSACTION_ID = TXN.TRANSACTION_ID
		AND S.TRANSACTION_IS_ACTIVE = 1
		AND IC.CONTRACT_ID = TXN.CONTRACT_ID
		AND (IDS.ID = g_ALL_DATA OR IDS.ID = TXN.TRANSACTION_ID)
	ORDER BY 1;

END GET_UNIT_SCHEDULE_RPT;
-------------------------------------------------------------------------------------
PROCEDURE PUT_UNIT_SCHEDULE_RPT
	(
	p_TRANSACTION_ID IN NUMBER,
	p_RESOURCE_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_SCHEDULE_NUMBER IN VARCHAR2,
	p_SCHEDULE_NAME IN VARCHAR2,
	p_SCHEDULE_DESCRIPTION IN VARCHAR2,
	p_MESSAGE OUT VARCHAR2,
	p_STATUS OUT NUMBER
	) AS
	v_ISO_ACCOUNT_NAME VARCHAR2(64);
	v_LOCATION_NAME VARCHAR2(64);
	v_TRANSACTION_ID NUMBER(9);
	v_PNODEID_ATTRIBUTE_ID NUMBER(9);
BEGIN

	--Add new Transaction.
	IF p_TRANSACTION_ID IS NULL OR p_TRANSACTION_ID = 0 THEN

		--Find ISO Account name
		SELECT CONTRACT_ALIAS INTO v_ISO_ACCOUNT_NAME FROM INTERCHANGE_CONTRACT WHERE BILLING_ENTITY_ID = p_PSE_ID;

		--Find PNODEID of Resource
        ID.ID_FOR_ENTITY_ATTRIBUTE('PJM_PNODEID', EC.ED_SUPPLY_RESOURCE, 'String', FALSE, v_PNODEID_ATTRIBUTE_ID);
        SELECT ATTRIBUTE_VAL INTO v_LOCATION_NAME FROM TEMPORAL_ENTITY_ATTRIBUTE
		WHERE OWNER_ENTITY_ID = p_RESOURCE_ID
			AND ATTRIBUTE_ID = v_PNODEID_ATTRIBUTE_ID;

		--Create the Transaction
		MM_PJM_EMKT_UTIL.GET_TRANSACTION_ID(v_ISO_ACCOUNT_NAME, v_LOCATION_NAME, 'Generation', MM_PJM_UTIL.g_COMM_DA_ENERGY, 0, 0, TRUE, v_TRANSACTION_ID, p_MESSAGE, p_SCHEDULE_NUMBER, MM_PJM_EMKT_UTIL.g_PJM_GEN_SCHEDULE_TXN_TYPE, NULL);

		IF p_MESSAGE IS NOT NULL THEN RETURN; END IF;

	--Change name/desc of existing Transaction.
	ELSE
		v_TRANSACTION_ID := p_TRANSACTION_ID;
	END IF;

	UPDATE INTERCHANGE_TRANSACTION
	SET TRANSACTION_ALIAS = p_SCHEDULE_NAME,
		TRANSACTION_DESC = p_SCHEDULE_DESCRIPTION
	WHERE TRANSACTION_ID = v_TRANSACTION_ID;

END PUT_UNIT_SCHEDULE_RPT;
-------------------------------------------------------------------------------------
PROCEDURE GET_STATUS_SUMMARY_RPT
	(
	p_BEGIN_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS
	v_SCHEDULE_STATE NUMBER(1) := 1;
	v_BEGIN_DATE DATE;
	v_END_DATE DATE;
	v_INTERVAL_NUMBER NUMBER(3);
	v_DAY_INTERVAL_TYPE NUMBER(1) := 1;
	v_SC_ID NUMBER(9) := EI.GET_ID_FROM_IDENTIFIER_EXTSYS('PJM', EC.ED_SC, EC.ES_PJM);
	v_ALLOWED_TXNS ID_TABLE := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_TXN_SELECT);
BEGIN
	v_INTERVAL_NUMBER := GET_INTERVAL_NUMBER('Hour');

	UT.CUT_DATE_RANGE(1, p_BEGIN_DATE, p_BEGIN_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	OPEN p_CURSOR FOR
		SELECT RESOURCE_NAME, PSE_NAME,
			CASE PJM_GEN_TXN_TYPE WHEN 'Unit Data' THEN 0 WHEN 'Schedule' THEN 10 WHEN 'Regulation' THEN 20 ELSE 30 END "TYPE_ORDER",
			INTERVAL,	PJM_GEN_TXN_TYPE, TRANSACTION_ID, RESOURCE_ID,
			CASE WHEN MIN_VAL = MAX_VAL THEN MIN_VAL ELSE 'various' END "SUBMIT_STATUS"
		FROM
			(
			SELECT T.PSE_NAME, T.RESOURCE_NAME, MAX(T.TRANSACTION_ID) "TRANSACTION_ID", T.RESOURCE_ID,
				PJM_GEN_TXN_TYPE,
				CASE TO_CHAR(ITSS.SCHEDULE_DATE, 'SS') WHEN '01' THEN 'Daily' ELSE 'Hourly' END "INTERVAL",
				MIN(GET_SINGLE_STATUS(ITSS.TRANSACTION_ID, ITSS.SUBMIT_STATUS, ITSS.MARKET_STATUS)) "MIN_VAL",
				MAX(GET_SINGLE_STATUS(ITSS.TRANSACTION_ID, ITSS.SUBMIT_STATUS, ITSS.MARKET_STATUS)) "MAX_VAL"
			FROM IT_TRAIT_SCHEDULE_STATUS ITSS,
				(SELECT TXN.TRANSACTION_NAME, TXN.TRANSACTION_ID, R.RESOURCE_ID, R.RESOURCE_NAME, P.PSE_NAME,PJM_GEN_TXN_TYPE
				FROM PJM_GEN_TXNS_BY_TYPE TXN, SUPPLY_RESOURCE R,
					INTERCHANGE_CONTRACT IC, PURCHASING_SELLING_ENTITY P,
					IT_STATUS STAT,
					TABLE(CAST(v_ALLOWED_TXNS AS ID_TABLE)) IDS
				WHERE TXN.TRANSACTION_TYPE = 'Generation'
					AND TXN.IS_BID_OFFER = 1
					AND p_BEGIN_DATE BETWEEN TXN.BEGIN_DATE AND TXN.END_DATE
					AND STAT.TRANSACTION_ID = TXN.TRANSACTION_ID
					AND STAT.TRANSACTION_IS_ACTIVE = 1
					AND (IDS.ID = g_ALL_DATA OR IDS.ID = TXN.TRANSACTION_ID)
					AND R.RESOURCE_ID = TXN.RESOURCE_ID
					AND IC.CONTRACT_ID = TXN.CONTRACT_ID
					AND P.PSE_ID = IC.BILLING_ENTITY_ID
					AND TXN.AGREEMENT_TYPE = CASE TXN.PJM_GEN_TXN_TYPE WHEN MM_PJM_EMKT_UTIL.g_PJM_GEN_SPIN_RES_TXN_TYPE THEN 'Tier2' ELSE TXN.AGREEMENT_TYPE END
				) T
			WHERE ITSS.TRANSACTION_ID(+) = T.TRANSACTION_ID
				AND ITSS.SCHEDULE_DATE(+) BETWEEN v_BEGIN_DATE AND v_END_DATE
			GROUP BY T.PSE_NAME, T.RESOURCE_NAME,
				PJM_GEN_TXN_TYPE,
				CASE TO_CHAR(ITSS.SCHEDULE_DATE, 'SS') WHEN '01' THEN 'Daily' ELSE 'Hourly' END,
				T.RESOURCE_ID
			) A
		ORDER BY 1,2,3,4;

END GET_STATUS_SUMMARY_RPT;
-------------------------------------------------------------------------------------
PROCEDURE GET_TRAITS_WITH_STATUS_RPT
    (
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_REPORT_TYPE IN VARCHAR2,
	p_TRAIT_GROUP_FILTER IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_DATE_OFFSET IN NUMBER DEFAULT 0,
	p_INTERVAL IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_OFFSET NUMBER := NVL(p_DATE_OFFSET,0);
v_INTERVAL VARCHAR2(16);
v_DAY_INTERVAL_TYPE NUMBER(1);
v_FROM_CUT_INTERVAL VARCHAR2(4);
v_INTERVAL_NUMBER NUMBER;
v_WORK_ID NUMBER(9);
v_SCHEDULE_STATE NUMBER(1) := NVL(p_SCHEDULE_STATE, 1);
v_PUMP_ATTRIBUTE_ID number(9) ;
V_COUNT NUMBER;

BEGIN

    -- Return immediately if we don't have a TRANSACTION_ID
    IF p_TRANSACTION_ID IS NULL OR p_TRANSACTION_ID < 0 THEN
        NULL_CURSOR(p_CURSOR);
        RETURN;
    END IF;



	--Get the interval of data to display.
	IF p_INTERVAL = '<Offer>' THEN
		v_INTERVAL := MM.GET_BID_OFFER_INTERVAL(p_TRANSACTION_ID);
	ELSE
		v_INTERVAL := p_INTERVAL;
	END IF;
	v_INTERVAL_NUMBER := GET_INTERVAL_NUMBER(v_INTERVAL);

	-- Get the list of Trait Group IDS from the appropriate market.
	MM.GET_TRAITS_FOR_TRANSACTION(p_TRANSACTION_ID, p_REPORT_TYPE, NVL(p_TRAIT_GROUP_FILTER, '%'), p_INTERVAL, v_WORK_ID);

	--BZ 17168 - enhancements to the PJM Generation reports (added additional parameters required for pumped storage units)
	--A new attribute , Unit Type has been created for all Resources. The value of the attribute is NULL or 'Pumped Storage'
    ID.ID_FOR_ENTITY_ATTRIBUTE('UNIT_TYPE', EC.ED_SUPPLY_RESOURCE, 'String', FALSE, v_PUMP_ATTRIBUTE_ID);


     SELECT COUNT(*)
     INTO   V_COUNT
     FROM   SUPPLY_RESOURCE SR,
		    TEMPORAL_ENTITY_ATTRIBUTE PURP,
            INTERCHANGE_TRANSACTION t
     WHERE  PURP.ATTRIBUTE_ID    = v_PUMP_ATTRIBUTE_ID
     AND    PURP.OWNER_ENTITY_ID = SR.RESOURCE_ID
     AND    p_TRANSACTION_ID     = T.TRANSACTION_ID
     and    upper(purp.ATTRIBUTE_VAL)=  upper(k_Pumped_Storage_Hydro)
     AND    sr.RESOURCE_ID     = T.RESOURCE_ID;

	IF INTERVAL_IS_ATLEAST_DAILY(v_INTERVAL) THEN
        v_DAY_INTERVAL_TYPE := 2;
		v_FROM_CUT_INTERVAL := 'DD';
    ELSE
        v_DAY_INTERVAL_TYPE := 1;
		v_FROM_CUT_INTERVAL := 'MI5';
    END IF;

    --Make sure we have data in the SYSTEM_DATE_TIME table.  Return an error if not.
	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, p_BEGIN_DATE, p_END_DATE);

    p_STATUS := GA.SUCCESS;

    UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	-- recompute offset - it may need to be one hour off of a multiple of 24 hours if looking
	-- back crosses a DST day
	v_OFFSET := v_BEGIN_DATE - (TO_CUT(TRUNC(p_BEGIN_DATE-v_OFFSET),p_TIME_ZONE)+1/86400);
	v_BEGIN_DATE := v_BEGIN_DATE-v_OFFSET;
	v_END_DATE := v_END_DATE-v_OFFSET;

    OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(CUT_DATE_SCHEDULING + v_OFFSET, p_TIME_ZONE, v_FROM_CUT_INTERVAL) "SCHEDULE_DATE_STR",
			A.TRAIT_GROUP_ID,
			A.TRAIT_INDEX,
			NVL(A.GROUP_DISPLAY_NAME, NVL(A.TRAIT_GROUP_NAME, ' ')) "TRAIT_GROUP_NAME",
			CASE WHEN A.IS_SERIES = 0 THEN A.DISPLAY_NAME ELSE A.DISPLAY_NAME || NVL(B.SET_NUMBER,1) END "DISPLAY_NAME",
			NVL(B.SET_NUMBER, 1) "SET_NUMBER",
			A.DATA_TYPE, A.EDIT_MASK, A.COMBO_LIST, A.FORMAT, B.TRAIT_VAL,
			TO_NUMBER(TO_CHAR(A.CUT_DATE_SCHEDULING,'HH24')) "ROWNUM",
			ROWNUM "REAL_ROWNUM",
			CUT_DATE_SCHEDULING + v_OFFSET "CUT_DATE_SCHEDULING",
			GROUP_ORDER, TRAIT_ORDER,
			GET_SINGLE_STATUS(C.TRANSACTION_ID, C.SUBMIT_STATUS, C.MARKET_STATUS) "SUBMIT_STATUS",
			NVL(U.USER_DISPLAY_NAME, U.USER_NAME) AS SUBMITTED_BY,
			C.SUBMIT_DATE
		FROM (SELECT Z.CUT_DATE_SCHEDULING, X.TRAIT_GROUP_NAME,
					X.DISPLAY_NAME "GROUP_DISPLAY_NAME", X.DISPLAY_ORDER "GROUP_ORDER",
					X.TRAIT_GROUP_ID, X.IS_STATEMENT_TYPE_SPECIFIC, X.IS_SERIES,
					Y.TRAIT_INDEX, Y.DISPLAY_NAME, Y.DISPLAY_ORDER "TRAIT_ORDER",
					Y.DATA_TYPE, Y.EDIT_MASK, Y.COMBO_LIST, Y.FORMAT
            FROM TRANSACTION_TRAIT_GROUP X, TRANSACTION_TRAIT_ATTRIBUTES Y, SYSTEM_DATE_TIME Z, RTO_WORK TR
			WHERE TR.WORK_ID = v_WORK_ID
    			AND X.TRAIT_GROUP_ID = TR.WORK_XID
    			AND X.TRAIT_GROUP_INTERVAL IN (v_INTERVAL, p_INTERVAL)
    			AND X.IS_SPARSE = 0
    			AND Y.TRAIT_GROUP_ID = X.TRAIT_GROUP_ID
    			AND Y.TRAIT_INDEX = TR.WORK_SEQ
                AND Z.TIME_ZONE = p_TIME_ZONE
                AND Z.DATA_INTERVAL_TYPE = v_DAY_INTERVAL_TYPE
                AND Z.DAY_TYPE = 1
                AND Z.CUT_DATE_SCHEDULING BETWEEN v_BEGIN_DATE AND v_END_DATE
    		    AND Z.MINIMUM_INTERVAL_NUMBER >= v_INTERVAL_NUMBER
                AND Y.DISPLAY_NAME = CASE WHEN V_COUNT < 1 AND Y.DISPLAY_NAME in ('Min Pump','Min Gen') tHEN null   ELSE Y.DISPLAY_NAME  END
            ) A,
			IT_TRAIT_SCHEDULE B, IT_TRAIT_SCHEDULE_STATUS C, APPLICATION_USER U
		WHERE B.TRANSACTION_ID(+) = p_TRANSACTION_ID
			AND B.SCHEDULE_STATE(+) = v_SCHEDULE_STATE
			AND B.SCHEDULE_DATE(+) = A.CUT_DATE_SCHEDULING
			AND B.TRAIT_GROUP_ID(+) = A.TRAIT_GROUP_ID
			AND B.TRAIT_INDEX(+) = A.TRAIT_INDEX
			AND B.STATEMENT_TYPE_ID(+) = CASE A.IS_STATEMENT_TYPE_SPECIFIC WHEN 0 THEN 0 ELSE p_SCHEDULE_TYPE END
			AND C.TRANSACTION_ID(+) = p_TRANSACTION_ID
			AND C.SCHEDULE_DATE(+) = A.CUT_DATE_SCHEDULING
			AND U.USER_ID (+) = C.SUBMITTED_BY_ID
	--	ORDER BY GROUP_ORDER, SET_NUMBER, TRAIT_ORDER, CUT_DATE_SCHEDULING
UNION all
select      ' Total Row ' SCHEDULE_DATE_STR,
            TRAIT_GROUP_ID,
            TRAIT_INDEX,
            TRAIT_GROUP_NAME,
            DISPLAY_NAME,
            SET_NUMBER,
            DATA_TYPE, EDIT_MASK, COMBO_LIST, FORMAT,
            to_char(sum_trait) TRAIT_VAL,
            NULL , --main.ROWNUM,
            main.REAL_ROWNUM,
            CUT_DATE_SCHEDULING,
            GROUP_ORDER, TRAIT_ORDER,
            ' ' SUBMIT_STATUS,
            ' ' SUBMITTED_BY,
            SUBMIT_DATE
from
    (SELECT FROM_CUT_AS_HED(CUT_DATE_SCHEDULING + v_OFFSET, p_TIME_ZONE, v_FROM_CUT_INTERVAL) "SCHEDULE_DATE_STR",
            A.TRAIT_GROUP_ID,
            A.TRAIT_INDEX,
            NVL(A.GROUP_DISPLAY_NAME, NVL(A.TRAIT_GROUP_NAME, ' ')) "TRAIT_GROUP_NAME",
            CASE WHEN A.IS_SERIES = 0 THEN A.DISPLAY_NAME ELSE A.DISPLAY_NAME || NVL(B.SET_NUMBER,1) END "DISPLAY_NAME",
            NVL(B.SET_NUMBER, 1) "SET_NUMBER",
            A.DATA_TYPE, A.EDIT_MASK, A.COMBO_LIST, A.FORMAT,
          --  to_number(B.TRAIT_VAL) TRAIT_VAL,  --jab
            B.TRAIT_VAL,
            TO_NUMBER(TO_CHAR(A.CUT_DATE_SCHEDULING,'HH24')) "ROWNUM",
            ROWNUM "REAL_ROWNUM",
            CUT_DATE_SCHEDULING + v_OFFSET "CUT_DATE_SCHEDULING",
            GROUP_ORDER, TRAIT_ORDER,
            GET_SINGLE_STATUS(C.TRANSACTION_ID, C.SUBMIT_STATUS, C.MARKET_STATUS) "SUBMIT_STATUS",
            C.SUBMITTED_BY_ID,
            C.SUBMIT_DATE,
            sum(B.TRAIT_VAL) over (partition by A.TRAIT_GROUP_ID,A.TRAIT_INDEX,NVL(B.SET_NUMBER,1),A.DISPLAY_NAME) sum_trait,
            row_number() over (partition by A.TRAIT_GROUP_ID,A.TRAIT_INDEX,NVL(B.SET_NUMBER,1),A.DISPLAY_NAME order by CUT_DATE_SCHEDULING) rw
        FROM (SELECT Z.CUT_DATE_SCHEDULING, X.TRAIT_GROUP_NAME,
                    X.DISPLAY_NAME "GROUP_DISPLAY_NAME", X.DISPLAY_ORDER "GROUP_ORDER",
                    X.TRAIT_GROUP_ID, X.IS_STATEMENT_TYPE_SPECIFIC, X.IS_SERIES,
                    Y.TRAIT_INDEX, Y.DISPLAY_NAME, Y.DISPLAY_ORDER "TRAIT_ORDER",
                    Y.DATA_TYPE, Y.EDIT_MASK, Y.COMBO_LIST, Y.FORMAT
            FROM TRANSACTION_TRAIT_GROUP X, TRANSACTION_TRAIT_ATTRIBUTES Y, SYSTEM_DATE_TIME Z, RTO_WORK TR
            WHERE TR.WORK_ID = v_WORK_ID
                AND X.TRAIT_GROUP_ID = TR.WORK_XID
                AND X.TRAIT_GROUP_INTERVAL IN (v_INTERVAL, p_INTERVAL)
                AND X.IS_SPARSE = 0
                AND Y.TRAIT_GROUP_ID = X.TRAIT_GROUP_ID
                AND Y.TRAIT_INDEX = TR.WORK_SEQ
                AND Z.TIME_ZONE = p_TIME_ZONE
                AND Z.DATA_INTERVAL_TYPE = v_DAY_INTERVAL_TYPE
                AND Z.DAY_TYPE = 1
                AND Z.CUT_DATE_SCHEDULING BETWEEN v_BEGIN_DATE AND v_END_DATE
                AND Z.MINIMUM_INTERVAL_NUMBER >= v_INTERVAL_NUMBER
                and y.DATA_TYPE = 'Number'
                AND Y.DISPLAY_NAME = CASE WHEN V_COUNT < 1 AND Y.DISPLAY_NAME in ('Min Pump','Min Gen') tHEN null   ELSE Y.DISPLAY_NAME  END
            ) A,
            IT_TRAIT_SCHEDULE B, IT_TRAIT_SCHEDULE_STATUS C
        WHERE B.TRANSACTION_ID(+) = p_TRANSACTION_ID
            AND B.SCHEDULE_STATE(+) = v_SCHEDULE_STATE
            AND B.SCHEDULE_DATE(+) = A.CUT_DATE_SCHEDULING
            AND B.TRAIT_GROUP_ID(+) = A.TRAIT_GROUP_ID
            AND B.TRAIT_INDEX(+) = A.TRAIT_INDEX
            AND B.STATEMENT_TYPE_ID(+) = CASE A.IS_STATEMENT_TYPE_SPECIFIC WHEN 0 THEN 0 ELSE p_SCHEDULE_TYPE END
            AND C.TRANSACTION_ID(+) = p_TRANSACTION_ID
            AND C.SCHEDULE_DATE(+) = A.CUT_DATE_SCHEDULING
 ) main
where rw = 1
		ORDER BY GROUP_ORDER, SET_NUMBER, TRAIT_ORDER, CUT_DATE_SCHEDULING
     ;

		UT.PURGE_RTO_WORK(v_WORK_ID);
END GET_TRAITS_WITH_STATUS_RPT;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_SCHEDULE_OFFER_RPT_MASTER
	(
	p_RESOURCE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

	v_INTERVAL_NUMBER NUMBER(3) := GET_INTERVAL_NUMBER('Day');
	v_BEGIN_DATE DATE;
	v_END_DATE DATE;
BEGIN

--ONLY FOR ONE DAY AT A TIME!
    UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_BEGIN_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

    OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(CUT_DATE_SCHEDULING, p_TIME_ZONE, 'DD') "SCHEDULE_DATE_STR",
			A.TRANSACTION_ID,
			A.TRANSACTION_IDENTIFIER,
			A.TRANSACTION_NAME,
			A.TRANSACTION_ALIAS "SCHEDULE_NAME",
			A.TRANSACTION_DESC "SCHEDULE_DESCRIPTION",
			A.SCHEDULE_NUMBER,
			B.TRAIT_VAL "SEL_AVAILABLE",
			CUT_DATE_SCHEDULING "CUT_DATE_SCHEDULING",
			GET_SINGLE_STATUS(C.TRANSACTION_ID, C.SUBMIT_STATUS, C.MARKET_STATUS) "SUBMIT_STATUS",
			NVL(U.USER_DISPLAY_NAME, U.USER_NAME) AS SUBMITTED_BY,
			C.SUBMIT_DATE
		FROM (SELECT IT.TRANSACTION_ID, IT.TRANSACTION_IDENTIFIER, IT.TRANSACTION_NAME, IT.TRANSACTION_ALIAS, IT.TRANSACTION_DESC,
					IT.AGREEMENT_TYPE "SCHEDULE_NUMBER", Z.CUT_DATE_SCHEDULING
            FROM SYSTEM_DATE_TIME Z, PJM_GEN_TXNS_BY_TYPE IT
			WHERE IT.RESOURCE_ID = p_RESOURCE_ID
				AND p_BEGIN_DATE BETWEEN IT.BEGIN_DATE AND IT.END_DATE
				AND IT.PJM_GEN_TXN_TYPE = 'Schedule'
				AND NOT EXISTS (SELECT 1 FROM PJM_SERVICE_POINT_OWNERSHIP WHERE SERVICE_POINT_ID = IT.POD_ID AND CONTRACT_ID = IT.CONTRACT_ID  AND p_BEGIN_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE, p_BEGIN_DATE) AND IS_SCHEDULER = 0)
				AND Z.TIME_ZONE = p_TIME_ZONE
				AND Z.DATA_INTERVAL_TYPE = 2
				AND Z.DAY_TYPE = 1
				AND Z.CUT_DATE_SCHEDULING BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND Z.MINIMUM_INTERVAL_NUMBER >= v_INTERVAL_NUMBER
            ) A,
			IT_TRAIT_SCHEDULE B, IT_TRAIT_SCHEDULE_STATUS C, APPLICATION_USER U
		WHERE B.TRANSACTION_ID(+) = A.TRANSACTION_ID
			AND B.SCHEDULE_STATE(+) = 1
			AND B.SCHEDULE_DATE(+) = A.CUT_DATE_SCHEDULING
			AND B.TRAIT_GROUP_ID(+) = MM_PJM_UTIL.g_TG_SEL_AVAILABLE
 			AND B.TRAIT_INDEX(+) = 1
 			AND B.SET_NUMBER(+) = 1
 			AND B.STATEMENT_TYPE_ID(+) = 0
			AND C.TRANSACTION_ID(+) = B.TRANSACTION_ID
			AND C.SCHEDULE_DATE(+) = B.SCHEDULE_DATE
			AND U.USER_ID (+) = C.SUBMITTED_BY_ID
		ORDER BY CUT_DATE_SCHEDULING;

END GET_SCHEDULE_OFFER_RPT_MASTER;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_SCHEDULE_OFFER_RPT
    (
	p_RESOURCE_ID IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_CUT_DATE_SCHEDULING IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

v_SCHEDULE_STATE NUMBER(1) := NVL(p_SCHEDULE_STATE, 1);
BEGIN

    -- Return immediately if we don't have a TRANSACTION_ID
    IF p_RESOURCE_ID IS NULL OR p_RESOURCE_ID = TG.g_NO_ENTITY_ID THEN
        NULL_CURSOR(p_CURSOR);
        RETURN;
    END IF;

    p_STATUS := GA.SUCCESS;

    OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(p_CUT_DATE_SCHEDULING, p_TIME_ZONE, 'DD') "SCHEDULE_DATE_STR",
			A.TRANSACTION_ID,
			A.TRANSACTION_IDENTIFIER,
			A.TRANSACTION_NAME,
			A.TRANSACTION_ALIAS "SCHEDULE_NAME",
			A.TRANSACTION_DESC "SCHEDULE_DESCRIPTION",
			A.SCHEDULE_NUMBER,
			A.TRAIT_GROUP_ID,
			A.TRAIT_INDEX,
			NVL(A.GROUP_DISPLAY_NAME, NVL(A.TRAIT_GROUP_NAME, ' ')) "TRAIT_GROUP_NAME",
--			CASE WHEN A.IS_SERIES = 0 THEN A.DISPLAY_NAME ELSE A.DISPLAY_NAME || NVL(B.SET_NUMBER,1) END "DISPLAY_NAME",
			A.DISPLAY_NAME,
			NVL(B.SET_NUMBER, 1) "SET_NUMBER",
			A.DATA_TYPE, A.EDIT_MASK, A.COMBO_LIST, A.FORMAT, B.TRAIT_VAL,
			p_CUT_DATE_SCHEDULING "CUT_DATE_SCHEDULING",
			GROUP_ORDER, TRAIT_ORDER,
			GET_SINGLE_STATUS(C.TRANSACTION_ID, C.SUBMIT_STATUS, C.MARKET_STATUS) "SUBMIT_STATUS",
			NVL(U.USER_DISPLAY_NAME, U.USER_NAME) AS SUBMITTED_BY,
			C.SUBMIT_DATE
		FROM (SELECT IT.TRANSACTION_ID, IT.TRANSACTION_IDENTIFIER, IT.TRANSACTION_NAME, IT.TRANSACTION_ALIAS, IT.TRANSACTION_DESC,
					IT.AGREEMENT_TYPE "SCHEDULE_NUMBER",
					X.TRAIT_GROUP_NAME,
					X.DISPLAY_NAME "GROUP_DISPLAY_NAME", X.DISPLAY_ORDER "GROUP_ORDER",
					X.TRAIT_GROUP_ID, X.IS_STATEMENT_TYPE_SPECIFIC, X.IS_SERIES,
					Y.TRAIT_INDEX, Y.DISPLAY_NAME, Y.DISPLAY_ORDER "TRAIT_ORDER",
					Y.DATA_TYPE, Y.EDIT_MASK, Y.COMBO_LIST, Y.FORMAT
            FROM TRANSACTION_TRAIT_GROUP X, TRANSACTION_TRAIT_ATTRIBUTES Y, PJM_GEN_TXNS_BY_TYPE IT
			WHERE IT.RESOURCE_ID = p_RESOURCE_ID
				AND TRUNC(p_CUT_DATE_SCHEDULING) BETWEEN IT.BEGIN_DATE AND IT.END_DATE
				AND X.TRAIT_GROUP_ID = TG.g_TG_OFFER_CURVE
				AND Y.TRAIT_GROUP_ID = X.TRAIT_GROUP_ID
				AND IT.PJM_GEN_TXN_TYPE = 'Schedule'
				AND NOT EXISTS (SELECT 1 FROM PJM_SERVICE_POINT_OWNERSHIP WHERE SERVICE_POINT_ID = IT.POD_ID AND CONTRACT_ID = IT.CONTRACT_ID AND TRUNC(p_CUT_DATE_SCHEDULING) BETWEEN BEGIN_DATE AND NVL(END_DATE, p_CUT_DATE_SCHEDULING) AND IS_SCHEDULER = 0)
            ) A,
			IT_TRAIT_SCHEDULE B, IT_TRAIT_SCHEDULE_STATUS C, APPLICATION_USER U
		WHERE B.TRANSACTION_ID(+) = A.TRANSACTION_ID
			AND B.SCHEDULE_STATE(+) = v_SCHEDULE_STATE
			AND B.SCHEDULE_DATE(+) = p_CUT_DATE_SCHEDULING
			AND B.TRAIT_GROUP_ID(+) = A.TRAIT_GROUP_ID
			AND B.TRAIT_INDEX(+) = A.TRAIT_INDEX
			AND B.STATEMENT_TYPE_ID(+) = CASE A.IS_STATEMENT_TYPE_SPECIFIC WHEN 0 THEN 0 ELSE p_SCHEDULE_TYPE END
			AND C.TRANSACTION_ID(+) = A.TRANSACTION_ID
			AND C.SCHEDULE_DATE(+) = p_CUT_DATE_SCHEDULING
			AND U.USER_ID (+) = C.SUBMITTED_BY_ID
		ORDER BY GROUP_ORDER, SET_NUMBER, TRAIT_ORDER, CUT_DATE_SCHEDULING;

END GET_SCHEDULE_OFFER_RPT;
-------------------------------------------------------------------------------------
PROCEDURE SHIFT_PRICE_CURVE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_CUT_DATE_SCHEDULING IN DATE,
	p_MULTIPLIER IN NUMBER,
	p_ADDER IN NUMBER
	) AS
	v_MULTIPLIER NUMBER := CASE p_MULTIPLIER WHEN 0 THEN 1 ELSE NVL(p_MULTIPLIER, 1) END;
BEGIN

	UPDATE IT_TRAIT_SCHEDULE
	SET TRAIT_VAL = ROUND((TO_NUMBER(TRAIT_VAL)*v_MULTIPLIER) + NVL(p_ADDER,0),2)
	WHERE TRANSACTION_ID = p_TRANSACTION_ID
		AND SCHEDULE_STATE = 1
		AND SCHEDULE_DATE = p_CUT_DATE_SCHEDULING
		AND TRAIT_GROUP_ID = TG.g_TG_OFFER_CURVE
		AND TRAIT_INDEX = TG.g_TI_OFFER_PRICE;

END SHIFT_PRICE_CURVE;
-------------------------------------------------------------------------------------
--BZ 17168 - enhancements to the PJM Generation reports (added additional parameters required for pumped storage units)
PROCEDURE GET_PUMPED_HYDRO_FILTER
    (
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	)
AS
BEGIN
     p_STATUS := GA.SUCCESS;

    OPEN p_CURSOR FOR
     select distinct purp.ATTRIBUTE_VAl
     from   TEMPORAL_ENTITY_ATTRIBUTE PURP,
            ENTITY_ATTRIBUTE ea
     where  ea.attribute_name = 'UNIT_TYPE'
     and    ea.ATTRIBUTE_ID = purp.ATTRIBUTE_ID
     UNION ALL
     select k_Non_Pumped_Storage_Hydro
     from   dual;
END GET_PUMPED_HYDRO_FILTER;
END MM_PJM_GEN_REPORTS;
/
