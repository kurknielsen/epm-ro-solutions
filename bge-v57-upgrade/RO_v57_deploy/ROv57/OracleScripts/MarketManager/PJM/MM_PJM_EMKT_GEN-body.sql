CREATE OR REPLACE PACKAGE BODY MM_PJM_EMKT_GEN IS
---------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR2 IS
BEGIN
    RETURN '$Revision: 1.1 $';
END WHAT_VERSION;
---------------------------------------------------------------------------------------------------
FUNCTION PACKAGE_NAME RETURN VARCHAR IS
BEGIN
     RETURN 'MM_PJM_EMKT_GEN';
END PACKAGE_NAME;
----------------------------------------------------------------------------------------------------
PROCEDURE NULL_CURSOR
    (
	p_CURSOR IN OUT REF_CURSOR
	) AS

BEGIN
	OPEN p_CURSOR FOR
		SELECT NULL FROM DUAL;
END NULL_CURSOR;
---------------------------------------------------------------------------------------------------
FUNCTION GET_SCHED_NUM_FOR_TXN_ID
	(
	p_TRANSACTION_ID IN NUMBER
	) RETURN NUMBER IS
	v_SCHEDULE_NUMBER NUMBER;
BEGIN

	SELECT TO_NUMBER(NVL(CASE AGREEMENT_TYPE WHEN '?' THEN '1' ELSE AGREEMENT_TYPE END,'1'))
	INTO v_SCHEDULE_NUMBER
	FROM INTERCHANGE_TRANSACTION ITX
	WHERE ITX.TRANSACTION_ID = p_TRANSACTION_ID;

	RETURN v_SCHEDULE_NUMBER;
END GET_SCHED_NUM_FOR_TXN_ID;
---------------------------------------------------------------------------------------------------
FUNCTION GET_LOCATION_FOR_TXN_ID
	(
	p_TRANSACTION_ID IN NUMBER
	) RETURN VARCHAR2 IS
	v_LOCATION VARCHAR2(64);
	v_PNODEID_ATTRIBUTE_ID NUMBER(9);
BEGIN
	ID.ID_FOR_ENTITY_ATTRIBUTE('PJM_PNODEID', EC.ED_SUPPLY_RESOURCE, 'String', FALSE, v_PNODEID_ATTRIBUTE_ID);

	SELECT TEA.ATTRIBUTE_VAL
	INTO v_LOCATION
	FROM TEMPORAL_ENTITY_ATTRIBUTE TEA, SUPPLY_RESOURCE R, INTERCHANGE_TRANSACTION ITX
	WHERE ITX.TRANSACTION_ID = p_TRANSACTION_ID
		AND ITX.RESOURCE_ID = R.RESOURCE_ID
		AND TEA.OWNER_ENTITY_ID = R.RESOURCE_ID
		AND TEA.ATTRIBUTE_ID = v_PNODEID_ATTRIBUTE_ID;

	RETURN v_LOCATION;
END GET_LOCATION_FOR_TXN_ID;
---------------------------------------------------------------------------------------------------
PROCEDURE IMPORT_SPREG_AWARD
    (
    p_ACCOUNT_NAME IN VARCHAR2,
    p_RECORDS IN MEX_PJM_EMKT_SPIN_RES_AWAR_TBL,
    p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR2
    ) AS
v_IDX BINARY_INTEGER;
v_REG_TRANSACTION_ID NUMBER(9);
v_SPINRES_TIER1_TXN_ID NUMBER(9);
v_SPINRES_TIER2_TXN_ID NUMBER(9);
v_SCHEDULE_DATE DATE;
v_SCHEDULE_STATE NUMBER(1) := GA.INTERNAL_STATE;
BEGIN

	p_STATUS := GA.SUCCESS;
	IF p_RECORDS.COUNT = 0 THEN
		RETURN;
	END IF;

    v_IDX := p_RECORDS.FIRST;

	WHILE p_RECORDS.EXISTS(v_IDX) LOOP
        v_SCHEDULE_DATE := TO_CUT_WITH_OPTIONS(p_RECORDS(v_IDX).RESPONSE_DATE + p_RECORDS(v_IDX).RESPONSE_HOUR / 24,
                                                MM_PJM_EMKT_UTIL.g_PJM_TIME_ZONE, MM_PJM_UTIL.g_DST_SPRING_AHEAD_OPTION);

        IF p_RECORDS(v_IDX).REG_AWARD > 0 THEN
            MM_PJM_EMKT_UTIL.GET_TRANSACTION_ID(p_ACCOUNT_NAME, p_RECORDS(v_IDX).LOCATION,
                                            'Generation', MM_PJM_UTIL.g_COMM_REGULATION, 0, 0, TRUE, v_REG_TRANSACTION_ID,
                                            p_MESSAGE, NULL, MM_PJM_EMKT_UTIL.g_PJM_GEN_REGULATION_TXN_TYPE, NULL);
            MM_PJM_EMKT_UTIL.PUT_MARKET_RESULTS(v_REG_TRANSACTION_ID, v_SCHEDULE_DATE,
                                        GA.INTERNAL_STATE, NULL,
                                        p_RECORDS(v_IDX).REG_AWARD,
                                        p_STATUS, p_MESSAGE);
        END IF;

        IF p_RECORDS(v_IDX).TIER_ONE_MW > 0 THEN
            MM_PJM_EMKT_UTIL.GET_TRANSACTION_ID(p_ACCOUNT_NAME, p_RECORDS(v_IDX).LOCATION,
                                            'Generation', MM_PJM_UTIL.g_COMM_SPIN_RES, 0, 0, TRUE, v_SPINRES_TIER1_TXN_ID,
                                            p_MESSAGE, NULL, MM_PJM_EMKT_UTIL.g_PJM_GEN_SPIN_RES_TXN_TYPE, 'Tier1');
            MM_PJM_EMKT_UTIL.PUT_MARKET_RESULTS(v_SPINRES_TIER1_TXN_ID, v_SCHEDULE_DATE,
                                        GA.INTERNAL_STATE, NULL,
                                        p_RECORDS(v_IDX).TIER_ONE_MW,
                                        p_STATUS, p_MESSAGE);
        END IF;

        IF p_RECORDS(v_IDX).TIER_TWO_MW > 0 OR p_RECORDS(v_IDX).SELF_SCHEDULED_MW > 0 THEN
            MM_PJM_EMKT_UTIL.GET_TRANSACTION_ID(p_ACCOUNT_NAME, p_RECORDS(v_IDX).LOCATION,
                                            'Generation', MM_PJM_UTIL.g_COMM_SPIN_RES, 0, 0, TRUE, v_SPINRES_TIER2_TXN_ID,
                                            p_MESSAGE, NULL, MM_PJM_EMKT_UTIL.g_PJM_GEN_SPIN_RES_TXN_TYPE, 'Tier2');
            IF p_RECORDS(v_IDX).TIER_TWO_MW > 0 THEN
                MM_PJM_EMKT_UTIL.PUT_MARKET_RESULTS(v_SPINRES_TIER2_TXN_ID, v_SCHEDULE_DATE,
                                        GA.INTERNAL_STATE, NULL,
                                        p_RECORDS(v_IDX).TIER_TWO_MW,
                                        p_STATUS, p_MESSAGE);
            END IF;
            IF p_RECORDS(v_IDX).SELF_SCHEDULED_MW > 0 THEN
				TG.PUT_IT_TRAIT_SCHEDULE(v_SPINRES_TIER2_TXN_ID, v_SCHEDULE_STATE, 0, v_SCHEDULE_DATE, MM_PJM_UTIL.g_TG_SCH_SELF_SCHEDULED, 1, 1, p_RECORDS(v_IDX).SELF_SCHEDULED_MW, CUT_TIME_ZONE);
            END IF;

        END IF;

    	v_IDX := p_RECORDS.NEXT(v_IDX);
    END LOOP;

    COMMIT;

END IMPORT_SPREG_AWARD;
------------------------------------------------------------------------------------
PROCEDURE IMPORT_PARAMETER_LIMITS
	(
	p_SCHEDULE_STATE IN NUMBER,
	p_ACCOUNT_NAME IN VARCHAR2,
	p_RECORDS IN MEX_PJM_EMKT_PARAM_LIMIT_TBL,
	p_STATUS OUT NUMBER,
	p_ERROR_MESSAGE OUT VARCHAR2
	) IS

	v_SCHEDULE_DATE DATE;
	v_TRANSACTION_ID NUMBER(9);
	v_IDX            BINARY_INTEGER;

	PROCEDURE PUT_DAILY_VAL
		(
		p_VALUE IN VARCHAR2,
		p_TRAIT_GROUP_ID IN NUMBER
		) IS
		v_TRAIT_INDEX NUMBER(9) := 1;
		v_SET_NUMBER NUMBER(9) := 1;
	BEGIN
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, p_SCHEDULE_STATE, 0, v_SCHEDULE_DATE, p_TRAIT_GROUP_ID, v_TRAIT_INDEX, v_SET_NUMBER, p_VALUE, CUT_TIME_ZONE);
	END PUT_DAILY_VAL;

BEGIN
 	p_STATUS := GA.SUCCESS;

	IF p_RECORDS.COUNT = 0 THEN
		RETURN;
	END IF; -- nothing to do

	v_IDX := p_RECORDS.FIRST;

	WHILE p_RECORDS.EXISTS(v_IDX) LOOP
		v_SCHEDULE_DATE := TRUNC(p_RECORDS(v_IDX).SCHEDULE_DAY) + 1/86400;

		MM_PJM_EMKT_UTIL.GET_TRANSACTION_ID(p_ACCOUNT_NAME,
                           p_RECORDS(v_IDX).LOCATION,
			               'Generation',
                           MM_PJM_UTIL.g_COMM_DA_ENERGY,
                           0,
                           0,
                           TRUE,
                           v_TRANSACTION_ID,
                           p_ERROR_MESSAGE,
                           NULL,
                           MM_PJM_EMKT_UTIL.g_PJM_GEN_UNIT_DATA_TXN_TYPE,
                           NULL);

		IF NOT p_ERROR_MESSAGE IS NULL THEN
			RETURN;
		END IF;

		PUT_DAILY_VAL(p_RECORDS(v_IDX).MINRUNTIMELIMIT, MM_PJM_UTIL.g_TG_DEF_MIN_RUNTIME_LIMIT);
		PUT_DAILY_VAL(p_RECORDS(v_IDX).MINDOWNTIMELIMIT, MM_PJM_UTIL.g_TG_DEF_MIN_DOWNTIME_LIMIT);
		PUT_DAILY_VAL(p_RECORDS(v_IDX).MAXDAILYSTARTSLIMIT, MM_PJM_UTIL.g_TG_DEF_MAX_DAILY_START_LIMIT);
		PUT_DAILY_VAL(p_RECORDS(v_IDX).MAXWEEKLYSTARTSLIMIT, MM_PJM_UTIL.g_TG_DEF_MAX_WEEKLY_STRT_LIMIT);
        PUT_DAILY_VAL(p_RECORDS(v_IDX).TURNDOWNRATIOLIMIT, MM_PJM_UTIL.g_TG_DEF_TURNDOWN_RATIO_LIMIT);
		PUT_DAILY_VAL(p_RECORDS(v_IDX).PARAMDESC, MM_PJM_UTIL.g_TG_DEF_PARAM_LIMIT_DESC);

		v_IDX := p_RECORDS.NEXT(v_IDX);
	END LOOP;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;
		p_ERROR_MESSAGE := PACKAGE_NAME || '.IMPORT_PARAMETER_LIMITS: ' || UT.GET_FULL_ERRM;
END IMPORT_PARAMETER_LIMITS;
-------------------------------------------------------------------------------------
PROCEDURE IMPORT_UNIT_DETAIL
	(
	p_SCHEDULE_STATE IN NUMBER,
	p_ACCOUNT_NAME IN VARCHAR2,
	p_RECORDS IN MEX_PJM_EMKT_UNIT_DETAIL_TBL,
	p_STATUS OUT NUMBER,
	p_ERROR_MESSAGE OUT VARCHAR2
	) IS

	v_SCHEDULE_DATE DATE;
	v_TRANSACTION_ID NUMBER(9);
	v_IDX            BINARY_INTEGER;
	v_ER_IDX         BINARY_INTEGER;
	v_SR_IDX         BINARY_INTEGER;
    v_DSC_IDX        BINARY_INTEGER;
	v_ER_RECORDS     MEX_PJM_EMKT_UNIT_DTL_ER_TBL := MEX_PJM_EMKT_UNIT_DTL_ER_TBL();
	v_SR_RECORDS     MEX_PJM_EMKT_UNIT_DTL_SR_TBL := MEX_PJM_EMKT_UNIT_DTL_SR_TBL();
    v_DSC_RECORDS     MEX_PJM_EMKT_UNIT_DTL_DSC_TBL := MEX_PJM_EMKT_UNIT_DTL_DSC_TBL();

	PROCEDURE PUT_DAILY_VAL
		(
		p_VALUE IN VARCHAR2,
		p_TRAIT_GROUP_ID IN NUMBER
		) IS
		v_TRAIT_INDEX NUMBER(9) := 1;
		v_SET_NUMBER NUMBER(9) := 1;
	BEGIN
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, p_SCHEDULE_STATE, 0, v_SCHEDULE_DATE, p_TRAIT_GROUP_ID, v_TRAIT_INDEX, v_SET_NUMBER, p_VALUE, CUT_TIME_ZONE);
	END PUT_DAILY_VAL;

	PROCEDURE PUT_DAILY_CURVE
		(
		p_TRAIT_GROUP_ID IN NUMBER,
		p_TRAIT_INDEX IN NUMBER,
		p_TRAIT_VAL IN VARCHAR2,
		p_SET_NUMBER IN NUMBER
		) IS
	BEGIN
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, p_SCHEDULE_STATE, 0, v_SCHEDULE_DATE, p_TRAIT_GROUP_ID, p_TRAIT_INDEX, p_SET_NUMBER, p_TRAIT_VAL, CUT_TIME_ZONE);
	END PUT_DAILY_CURVE;

	PROCEDURE CLEAR_CURVE
		(
		p_TRAIT_GROUP_ID IN NUMBER
		) IS
	BEGIN
		DELETE IT_TRAIT_SCHEDULE
		WHERE TRANSACTION_ID = v_TRANSACTION_ID
			AND SCHEDULE_STATE = p_SCHEDULE_STATE
			AND SCHEDULE_DATE = v_SCHEDULE_DATE
			AND TRAIT_GROUP_ID = p_TRAIT_GROUP_ID;
	END CLEAR_CURVE;
BEGIN
 	p_STATUS := GA.SUCCESS;

	IF p_RECORDS.COUNT = 0 THEN
		RETURN;
	END IF; -- nothing to do

	v_IDX := p_RECORDS.FIRST;

	WHILE p_RECORDS.EXISTS(v_IDX) LOOP
		v_SCHEDULE_DATE := TRUNC(p_RECORDS(v_IDX).SCHEDULE_DAY) + 1/86400;

		MM_PJM_EMKT_UTIL.GET_TRANSACTION_ID(p_ACCOUNT_NAME,
                           p_RECORDS(v_IDX).LOCATION,
			               'Generation',
                           MM_PJM_UTIL.g_COMM_DA_ENERGY,
                           0,
                           0,
                           TRUE,
                           v_TRANSACTION_ID,
                           p_ERROR_MESSAGE,
                           NULL,
                           MM_PJM_EMKT_UTIL.g_PJM_GEN_UNIT_DATA_TXN_TYPE,
                           NULL);

		IF NOT p_ERROR_MESSAGE IS NULL THEN
			RETURN;
		END IF;

		PUT_DAILY_VAL( p_RECORDS(v_IDX).COMMITSTATUS, MM_PJM_UTIL.g_TG_DEF_COMMIT_STATUS);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).FIXEDGEN, MM_PJM_UTIL.g_TG_DEF_FIXED_GEN);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).MINECONOMICLIMIT,MM_PJM_UTIL.g_TG_DEF_ECON_MIN);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).MAXECONOMICLIMIT,MM_PJM_UTIL.g_TG_DEF_ECON_MAX);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).MINEMERGENCYLIMIT,MM_PJM_UTIL.g_TG_DEF_EMER_MIN);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).MAXEMERGENCYLIMIT,MM_PJM_UTIL.g_TG_DEF_EMER_MAX);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).MINREGULATIONLIMIT,MM_PJM_UTIL.g_TG_DEF_REGULATION_MIN);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).MAXREGULATIONLIMIT,MM_PJM_UTIL.g_TG_DEF_REGULATION_MAX);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).MAXSPINNINGLIMIT,MM_PJM_UTIL.g_TG_DEF_SPINNING_MAX);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).LOWECONOMICTEMPRANGEMW,MM_PJM_UTIL.g_TG_DEF_LOW_ECON_MW);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).LOWECONOMICTEMPRANGETEMP,MM_PJM_UTIL.g_TG_DEF_LOW_ECON_TEMP);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).MIDECONOMICTEMPRANGEMW,MM_PJM_UTIL.g_TG_DEF_MID_ECON_MW);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).MIDECONOMICTEMPRANGETEMP,MM_PJM_UTIL.g_TG_DEF_MID_ECON_TEMP);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).HIGHECONOMICTEMPRANGEMW,MM_PJM_UTIL.g_TG_DEF_HIGH_ECON_MW);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).HIGHECONOMICTEMPRANGETEMP,MM_PJM_UTIL.g_TG_DEF_HIGH_ECON_TEMP);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).LOWEMERGENCYTEMPRANGEMW,MM_PJM_UTIL.g_TG_DEF_LOW_EMER_MW);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).LOWEMERGENCYTEMPRANGETEMP,MM_PJM_UTIL.g_TG_DEF_LOW_EMER_TEMP);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).MIDEMERGENCYTEMPRANGEMW,MM_PJM_UTIL.g_TG_DEF_MID_EMER_MW);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).MIDEMERGENCYTEMPRANGETEMP,MM_PJM_UTIL.g_TG_DEF_MID_EMER_TEMP);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).HIGHEMERGENCYTEMPRANGEMW,MM_PJM_UTIL.g_TG_DEF_HIGH_EMER_MW);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).HIGHEMERGENCYTEMPRANGETEMP,MM_PJM_UTIL.g_TG_DEF_HIGH_EMER_TEMP);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).DEFAULTRAMPRATE,MM_PJM_UTIL.g_TG_DEF_RAMP_RATE);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).CONDENSEAVAILABLE,MM_PJM_UTIL.g_TG_DEF_CONDENSE_AVAILABLE);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).CONDENSESTARTUPCOST,MM_PJM_UTIL.g_TG_DEF_CONDENSE_START_COST);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).CONDENSEENERGYUSAGE,MM_PJM_UTIL.g_TG_DEF_CONDENSE_ENERGY_USAGE);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).CONDENSENOTIFICATION,MM_PJM_UTIL.g_TG_DEF_CONDENSE_NOTIF);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).CONDENSEHOURLYCOST,MM_PJM_UTIL.g_TG_DEF_CONDENSE_HOURLY_COST);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).CC_MIN_TIME_BETWEEN, MM_PJM_UTIL.g_TG_DEF_CC_MIN_TIME_BETWEEN);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).CC_ALLOW_SIMPLE_CYCLE, MM_PJM_UTIL.g_TG_DEF_CC_ALLOW_SIMPLE_CYCLE);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).CC_FACTOR, MM_PJM_UTIL.g_TG_DEF_CC_FACTOR);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).PS_PUMPING_FACTOR, MM_PJM_UTIL.g_TG_DEF_PS_PUMPING_FACTOR);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).PS_INITIAL_MWH, MM_PJM_UTIL.g_TG_DEF_PS_INITIAL_MWH);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).PS_FINAL_MWH, MM_PJM_UTIL.g_TG_DEF_PS_FINAL_MWH);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).PS_MAX_MWH, MM_PJM_UTIL.g_TG_DEF_PS_MAX_MWH);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).PS_MIN_MWH, MM_PJM_UTIL.g_TG_DEF_PS_MIN_MWH);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).PS_MIN_GEN_MW, MM_PJM_UTIL.g_TG_DEF_PS_MIN_GEN_MW);
		PUT_DAILY_VAL( p_RECORDS(v_IDX).PS_MIN_PUMP_MW, MM_PJM_UTIL.g_TG_DEF_PS_MIN_PUMP_MW);

		v_ER_RECORDS := p_RECORDS(v_IDX).ENERGYRAMPRATECURVE;
		IF v_ER_RECORDS.COUNT > 0 THEN
			CLEAR_CURVE(MM_PJM_UTIL.g_TG_DEF_ENERGY_RAMP_CURVE);
			v_ER_IDX := v_ER_RECORDS.FIRST;
			WHILE v_ER_RECORDS.EXISTS(v_ER_IDX) LOOP
				PUT_DAILY_CURVE(MM_PJM_UTIL.g_TG_DEF_ENERGY_RAMP_CURVE, MM_PJM_UTIL.g_TI_DEF_ENERGY_RAMP_MW, v_ER_RECORDS(v_ER_IDX).MW, v_ER_IDX);
				PUT_DAILY_CURVE(MM_PJM_UTIL.g_TG_DEF_ENERGY_RAMP_CURVE, MM_PJM_UTIL.g_TI_DEF_ENERGY_RAMP_RATE, v_ER_RECORDS(v_ER_IDX).RATE, v_ER_IDX);
				v_ER_IDX := v_ER_RECORDS.NEXT(v_ER_IDX);
			END LOOP;
		END IF;

		v_SR_RECORDS := p_RECORDS(v_IDX).SPINRAMPRATECURVE;
		IF v_SR_RECORDS.COUNT > 0 THEN
			CLEAR_CURVE(MM_PJM_UTIL.g_TG_DEF_SPIN_RAMP_CURVE);
			v_SR_IDX := v_SR_RECORDS.FIRST;
			WHILE v_SR_RECORDS.EXISTS(v_SR_IDX) LOOP
				PUT_DAILY_CURVE(MM_PJM_UTIL.g_TG_DEF_SPIN_RAMP_CURVE, MM_PJM_UTIL.g_TI_DEF_SPIN_RAMP_MW, v_SR_RECORDS(v_SR_IDX).MW, v_SR_IDX);
				PUT_DAILY_CURVE(MM_PJM_UTIL.g_TG_DEF_SPIN_RAMP_CURVE, MM_PJM_UTIL.g_TI_DEF_SPIN_RAMP_RATE, v_SR_RECORDS(v_SR_IDX).RATE, v_SR_IDX);
				v_SR_IDX := v_SR_RECORDS.NEXT(v_SR_IDX);
			END LOOP;
		END IF;

        v_DSC_RECORDS := p_RECORDS(v_IDX).DEFAULTSTARTUPCOSTS;
		IF v_DSC_RECORDS.COUNT > 0 THEN
			CLEAR_CURVE(MM_PJM_UTIL.g_TG_DEF_DEFAULT_STARTUP_COST);
			v_DSC_IDX := v_DSC_RECORDS.FIRST;
			WHILE v_DSC_RECORDS.EXISTS(v_DSC_IDX) LOOP
				PUT_DAILY_CURVE(MM_PJM_UTIL.g_TG_DEF_DEFAULT_STARTUP_COST, MM_PJM_UTIL.g_TI_DEF_DSC_INTERVAL , v_DSC_RECORDS(v_DSC_IDX).INTERVAL, v_DSC_IDX);
                PUT_DAILY_CURVE(MM_PJM_UTIL.g_TG_DEF_DEFAULT_STARTUP_COST, MM_PJM_UTIL.g_TI_DEF_DSC_USESTARTUP , v_DSC_RECORDS(v_DSC_IDX).USECOSTBASEDSTARTUP, v_DSC_IDX);
                PUT_DAILY_CURVE(MM_PJM_UTIL.g_TG_DEF_DEFAULT_STARTUP_COST, MM_PJM_UTIL.g_TI_DEF_DSC_NOLOADCOST , v_DSC_RECORDS(v_DSC_IDX).NOLOADCOST, v_DSC_IDX);
                PUT_DAILY_CURVE(MM_PJM_UTIL.g_TG_DEF_DEFAULT_STARTUP_COST, MM_PJM_UTIL.g_TI_DEF_DSC_COLDSTARTUPCOST , v_DSC_RECORDS(v_DSC_IDX).COLDSTARTUPCOST, v_DSC_IDX);
                PUT_DAILY_CURVE(MM_PJM_UTIL.g_TG_DEF_DEFAULT_STARTUP_COST, MM_PJM_UTIL.g_TI_DEF_DSC_INTMDSARTUPCOST , v_DSC_RECORDS(v_DSC_IDX).INTERMEDIATESTARTUPCOST, v_DSC_IDX);
                PUT_DAILY_CURVE(MM_PJM_UTIL.g_TG_DEF_DEFAULT_STARTUP_COST, MM_PJM_UTIL.g_TI_DEF_DSC_HOTSTARTUPCOST , v_DSC_RECORDS(v_DSC_IDX).HOTSTARTUPCOST, v_DSC_IDX);
				v_DSC_IDX := v_DSC_RECORDS.NEXT(v_DSC_IDX);
			END LOOP;
		END IF;

		v_IDX := p_RECORDS.NEXT(v_IDX);
	END LOOP;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;
		p_ERROR_MESSAGE := PACKAGE_NAME || '.IMPORT_UNIT_DETAIL: ' || UT.GET_FULL_ERRM;
END IMPORT_UNIT_DETAIL;
-------------------------------------------------------------------------------------
PROCEDURE QUERY_UNIT_DETAIL
	(
	p_CRED			 IN mex_credentials,
	p_SCHEDULE_STATE IN NUMBER,
	p_REQUEST_DATE  IN DATE,
	p_LOG_ONLY      IN NUMBER,
	p_STATUS OUT NUMBER,
	p_ERROR_MESSAGE OUT VARCHAR2,
	p_LOGGER IN OUT mm_logger_adapter
	) AS

	v_RECORDS MEX_PJM_EMKT_UNIT_DETAIL_TBL;

BEGIN
	p_STATUS    := GA.SUCCESS;
	IF MM_PJM_UTIL.HAS_ESUITE_ACCESS(MM_PJM_EMKT_UTIL.g_EMKT_GEN_ATTR, p_CRED.EXTERNAL_ACCOUNT_NAME) THEN

		MEX_PJM_EMKT.FETCH_UNIT_DETAIL(p_CRED => p_CRED,
									   p_LOG_ONLY => p_LOG_ONLY,
									   p_LOCATION_TYPE => MEX_PJM_EMKT.g_LOC_TYPE_PORTFOLIO,
									   p_LOCATION_NAME => MM_PJM_EMKT_UTIL.GET_GEN_PORTFOLIO_NAME(p_CRED.EXTERNAL_ACCOUNT_NAME),
									   p_REQUEST_DATE => p_REQUEST_DATE,
									   p_RECORDS => v_RECORDS,
									   p_STATUS => p_STATUS,
									   p_MESSAGE => p_ERROR_MESSAGE,
									   p_LOGGER => p_LOGGER);

		IF p_STATUS >= 0 THEN
			IMPORT_UNIT_DETAIL( p_SCHEDULE_STATE, p_CRED.EXTERNAL_ACCOUNT_NAME, v_RECORDS, p_STATUS, p_ERROR_MESSAGE);
			IF p_ERROR_MESSAGE IS NOT NULL THEN RETURN; END IF;

			IF p_SCHEDULE_STATE = 1 THEN
				IMPORT_UNIT_DETAIL( 2, p_CRED.EXTERNAL_ACCOUNT_NAME, v_RECORDS, p_STATUS, p_ERROR_MESSAGE);
				IF p_ERROR_MESSAGE IS NOT NULL THEN RETURN; END IF;

			END IF;
		END IF;
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;
		p_ERROR_MESSAGE := PACKAGE_NAME || '.QUERY_UNIT_DETAIL: ' || UT.GET_FULL_ERRM;
END QUERY_UNIT_DETAIL;
-------------------------------------------------------------------------------------
PROCEDURE QUERY_PARAMETER_LIMITS
	(
	p_CRED			 IN mex_credentials,
	p_SCHEDULE_STATE IN NUMBER,
	p_REQUEST_DATE  IN DATE,
	p_LOG_ONLY      IN NUMBER,
	p_STATUS OUT NUMBER,
	p_ERROR_MESSAGE OUT VARCHAR2,
	p_LOGGER IN OUT mm_logger_adapter
	) AS

	v_RECORDS MEX_PJM_EMKT_PARAM_LIMIT_TBL;

BEGIN
	p_STATUS    := GA.SUCCESS;
	IF MM_PJM_UTIL.HAS_ESUITE_ACCESS(MM_PJM_EMKT_UTIL.g_EMKT_GEN_ATTR, p_CRED.EXTERNAL_ACCOUNT_NAME) THEN

		MEX_PJM_EMKT.FETCH_PARAMETER_LIMITS(p_CRED => p_CRED,
                                        p_REQUEST_DATE => p_REQUEST_DATE,
									    p_LOG_ONLY => p_LOG_ONLY,
									    p_RECORDS => v_RECORDS,
									    p_STATUS => p_STATUS,
									    p_MESSAGE => p_ERROR_MESSAGE,
									    p_LOGGER => p_LOGGER);

		IF p_STATUS = GA.SUCCESS THEN
			IMPORT_PARAMETER_LIMITS(p_SCHEDULE_STATE, p_CRED.EXTERNAL_ACCOUNT_NAME, v_RECORDS, p_STATUS, p_ERROR_MESSAGE);
        END IF;
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;
		p_ERROR_MESSAGE := PACKAGE_NAME || '.QUERY_PARAMETER_LIMITS: ' || UT.GET_FULL_ERRM;
END QUERY_PARAMETER_LIMITS;
-------------------------------------------------------------------------------------
PROCEDURE GET_SUBMIT_UNIT_DETAIL_XML
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_DATE IN DATE,
	p_SUBMIT_XML OUT XMLTYPE,
	p_STATUS OUT NUMBER,
	p_ERROR_MESSAGE OUT VARCHAR2
	) AS

	l_LOCATION VARCHAR2(32);
	l_CUT_DATE DATE := TRUNC(p_SCHEDULE_DATE) + 1/86400;
    v_INTERVAL BINARY_INTEGER;

	v_MAIN_RECORDS MEX_PJM_EMKT_UNIT_DETAIL_TBL := MEX_PJM_EMKT_UNIT_DETAIL_TBL();
	v_ERAMP_RECORDS MEX_PJM_EMKT_UNIT_DTL_ER_TBL := MEX_PJM_EMKT_UNIT_DTL_ER_TBL();
	v_SRAMP_RECORDS MEX_PJM_EMKT_UNIT_DTL_SR_TBL := MEX_PJM_EMKT_UNIT_DTL_SR_TBL();
	v_STARTUP_COST_RECORDS MEX_PJM_EMKT_UNIT_DTL_DSC_TBL := MEX_PJM_EMKT_UNIT_DTL_DSC_TBL();

	FUNCTION STR_VAL(p_TRAIT_GROUP_ID IN NUMBER) RETURN VARCHAR2 IS
	BEGIN
		RETURN MM_PJM_EMKT_UTIL.GET_IT_TRAIT_SCHEDULE(p_TRAIT_GROUP_ID, p_TRANSACTION_ID, 1, l_CUT_DATE);
	END STR_VAL;
	FUNCTION NUM_VAL(p_TRAIT_GROUP_ID IN NUMBER) RETURN NUMBER IS
	BEGIN
		RETURN TO_NUMBER(STR_VAL(p_TRAIT_GROUP_ID));
	END NUM_VAL;

BEGIN

	p_STATUS := MEX_UTIL.g_SUCCESS;

	l_LOCATION := GET_LOCATION_FOR_TXN_ID(p_TRANSACTION_ID);

    IF TO_CHAR(l_CUT_DATE, 'MM') >= 4 AND TO_CHAR(l_CUT_DATE, 'MM') <=9 THEN
        --Interval 1 is April through Sept
        v_INTERVAL := 1;
    ELSE
        --Interval 1 is Oct through Mar
        v_INTERVAL := 2;
    END IF;        

	--Get the Energy Ramp Curve.
	SELECT MEX_PJM_EMKT_UNIT_DTL_ER(
		SUM(CASE A.TRAIT_INDEX WHEN MM_PJM_UTIL.g_TI_DEF_ENERGY_RAMP_MW THEN TO_NUMBER(A.TRAIT_VAL) ELSE 0 END),
		SUM(CASE A.TRAIT_INDEX WHEN MM_PJM_UTIL.g_TI_DEF_ENERGY_RAMP_RATE THEN TO_NUMBER(A.TRAIT_VAL) ELSE 0 END))
	BULK COLLECT INTO v_ERAMP_RECORDS
	FROM IT_TRAIT_SCHEDULE A
	WHERE TRANSACTION_ID = p_TRANSACTION_ID
		AND SCHEDULE_STATE = GA.INTERNAL_STATE
		AND SCHEDULE_DATE = l_CUT_DATE
		AND TRAIT_GROUP_ID = MM_PJM_UTIL.g_TG_DEF_ENERGY_RAMP_CURVE
	GROUP BY SET_NUMBER;

	--Get the Spin Ramp Curve.
	SELECT MEX_PJM_EMKT_UNIT_DTL_SR(
		SUM(CASE A.TRAIT_INDEX WHEN MM_PJM_UTIL.g_TI_DEF_SPIN_RAMP_MW THEN TO_NUMBER(A.TRAIT_VAL) ELSE 0 END),
		SUM(CASE A.TRAIT_INDEX WHEN MM_PJM_UTIL.g_TI_DEF_SPIN_RAMP_RATE THEN TO_NUMBER(A.TRAIT_VAL) ELSE 0 END))
	BULK COLLECT INTO v_SRAMP_RECORDS
	FROM IT_TRAIT_SCHEDULE A
	WHERE TRANSACTION_ID = p_TRANSACTION_ID
		AND SCHEDULE_STATE = GA.INTERNAL_STATE
		AND SCHEDULE_DATE = l_CUT_DATE
		AND TRAIT_GROUP_ID = MM_PJM_UTIL.g_TG_DEF_SPIN_RAMP_CURVE
	GROUP BY SET_NUMBER;

	--Get the Default Startup Costs.
	SELECT MEX_PJM_EMKT_UNIT_DTL_DSC(
		v_INTERVAL,		
        B.TRAIT_VAL,
		SUM(CASE A.TRAIT_INDEX WHEN MM_PJM_UTIL.g_TI_DEF_DSC_NOLOADCOST THEN TO_NUMBER(A.TRAIT_VAL) ELSE 0 END),
		SUM(CASE A.TRAIT_INDEX WHEN MM_PJM_UTIL.g_TI_DEF_DSC_COLDSTARTUPCOST THEN TO_NUMBER(A.TRAIT_VAL) ELSE 0 END),
		SUM(CASE A.TRAIT_INDEX WHEN MM_PJM_UTIL.g_TI_DEF_DSC_INTMDSARTUPCOST THEN TO_NUMBER(A.TRAIT_VAL) ELSE 0 END),
		SUM(CASE A.TRAIT_INDEX WHEN MM_PJM_UTIL.g_TI_DEF_DSC_HOTSTARTUPCOST THEN TO_NUMBER(A.TRAIT_VAL) ELSE 0 END))
	BULK COLLECT INTO v_STARTUP_COST_RECORDS
	FROM IT_TRAIT_SCHEDULE A, IT_TRAIT_SCHEDULE B
	WHERE A.TRANSACTION_ID = p_TRANSACTION_ID
		AND A.SCHEDULE_STATE = GA.INTERNAL_STATE
		AND A.SCHEDULE_DATE = l_CUT_DATE
		AND A.TRAIT_GROUP_ID = MM_PJM_UTIL.g_TG_DEF_DEFAULT_STARTUP_COST
        AND A.SET_NUMBER = 1
        AND B.TRANSACTION_ID = A.TRANSACTION_ID
        AND B.SCHEDULE_STATE = A.SCHEDULE_STATE
        AND B.SCHEDULE_DATE = A.SCHEDULE_DATE
        AND B.TRAIT_GROUP_ID = A.TRAIT_GROUP_ID
        AND B.SET_NUMBER = 1
        AND B.TRAIT_INDEX = 2
	GROUP BY A.SET_NUMBER, B.TRAIT_VAL;
	
	--Get the main Unit Details.
	v_MAIN_RECORDS.EXTEND();
	v_MAIN_RECORDS(v_MAIN_RECORDS.LAST) := MEX_PJM_EMKT_UNIT_DETAIL(
											SCHEDULE_DAY => l_CUT_DATE,
                                            LOCATION => l_LOCATION,
                                            COMMITSTATUS => STR_VAL(MM_PJM_UTIL.g_TG_DEF_COMMIT_STATUS),
                                            FIXEDGEN => STR_VAL(MM_PJM_UTIL.g_TG_DEF_FIXED_GEN),
                                            CONDENSEAVAILABLE => STR_VAL(MM_PJM_UTIL.g_TG_DEF_CONDENSE_AVAILABLE),
                                            CONDENSESTARTUPCOST => NUM_VAL(MM_PJM_UTIL.g_TG_DEF_CONDENSE_START_COST),
                                            CONDENSEENERGYUSAGE => NUM_VAL(MM_PJM_UTIL.g_TG_DEF_CONDENSE_ENERGY_USAGE),
                                            CONDENSENOTIFICATION => NUM_VAL(MM_PJM_UTIL.g_TG_DEF_CONDENSE_NOTIF),
                                            CONDENSEHOURLYCOST => NUM_VAL(MM_PJM_UTIL.g_TG_DEF_CONDENSE_HOURLY_COST),
                                            DEFAULTRAMPRATE => NUM_VAL(MM_PJM_UTIL.g_TG_DEF_RAMP_RATE),
                                            MINECONOMICLIMIT => NUM_VAL(MM_PJM_UTIL.g_TG_DEF_ECON_MIN),
                                            MAXECONOMICLIMIT => NUM_VAL(MM_PJM_UTIL.g_TG_DEF_ECON_MAX),
                                            MINEMERGENCYLIMIT => NUM_VAL(MM_PJM_UTIL.g_TG_DEF_EMER_MIN),
                                            MAXEMERGENCYLIMIT => NUM_VAL(MM_PJM_UTIL.g_TG_DEF_EMER_MAX),
                                            MINREGULATIONLIMIT => NUM_VAL(MM_PJM_UTIL.g_TG_DEF_REGULATION_MIN),
                                            MAXREGULATIONLIMIT => NUM_VAL(MM_PJM_UTIL.g_TG_DEF_REGULATION_MAX),
                                            MAXSPINNINGLIMIT => NUM_VAL(MM_PJM_UTIL.g_TG_DEF_SPINNING_MAX),
                                            LOWECONOMICTEMPRANGEMW => NUM_VAL(MM_PJM_UTIL.g_TG_DEF_LOW_ECON_MW),
                                            LOWECONOMICTEMPRANGETEMP => NUM_VAL(MM_PJM_UTIL.g_TG_DEF_LOW_ECON_TEMP),
                                            MIDECONOMICTEMPRANGEMW => NUM_VAL(MM_PJM_UTIL.g_TG_DEF_MID_ECON_MW),
                                            MIDECONOMICTEMPRANGETEMP => NUM_VAL(MM_PJM_UTIL.g_TG_DEF_MID_ECON_TEMP),
                                            HIGHECONOMICTEMPRANGEMW => NUM_VAL(MM_PJM_UTIL.g_TG_DEF_HIGH_ECON_MW),
                                            HIGHECONOMICTEMPRANGETEMP => NUM_VAL(MM_PJM_UTIL.g_TG_DEF_HIGH_ECON_TEMP),
                                            LOWEMERGENCYTEMPRANGEMW => NUM_VAL(MM_PJM_UTIL.g_TG_DEF_LOW_EMER_MW),
                                            LOWEMERGENCYTEMPRANGETEMP => NUM_VAL(MM_PJM_UTIL.g_TG_DEF_LOW_EMER_TEMP),
                                            MIDEMERGENCYTEMPRANGEMW => NUM_VAL(MM_PJM_UTIL.g_TG_DEF_MID_EMER_MW),
                                            MIDEMERGENCYTEMPRANGETEMP => NUM_VAL(MM_PJM_UTIL.g_TG_DEF_MID_EMER_TEMP),
                                            HIGHEMERGENCYTEMPRANGEMW => NUM_VAL(MM_PJM_UTIL.g_TG_DEF_HIGH_EMER_MW),
                                            HIGHEMERGENCYTEMPRANGETEMP => NUM_VAL(MM_PJM_UTIL.g_TG_DEF_HIGH_EMER_TEMP),
                                            ENERGYRAMPRATECURVE => v_ERAMP_RECORDS,
                                            SPINRAMPRATECURVE => v_SRAMP_RECORDS,
											DEFAULTSTARTUPCOSTS => v_STARTUP_COST_RECORDS,
											CC_MIN_TIME_BETWEEN => NUM_VAL(MM_PJM_UTIL.g_TG_DEF_CC_MIN_TIME_BETWEEN),
											CC_ALLOW_SIMPLE_CYCLE => STR_VAL(MM_PJM_UTIL.g_TG_DEF_CC_ALLOW_SIMPLE_CYCLE),
											CC_FACTOR => NUM_VAL(MM_PJM_UTIL.g_TG_DEF_CC_FACTOR),
											PS_PUMPING_FACTOR => NUM_VAL(MM_PJM_UTIL.g_TG_DEF_PS_PUMPING_FACTOR),
											PS_INITIAL_MWH => NUM_VAL(MM_PJM_UTIL.g_TG_DEF_PS_INITIAL_MWH),
											PS_FINAL_MWH => NUM_VAL(MM_PJM_UTIL.g_TG_DEF_PS_FINAL_MWH),
											PS_MAX_MWH => NUM_VAL(MM_PJM_UTIL.g_TG_DEF_PS_MAX_MWH),
											PS_MIN_MWH => NUM_VAL(MM_PJM_UTIL.g_TG_DEF_PS_MIN_MWH),
											PS_MIN_GEN_MW => NUM_VAL(MM_PJM_UTIL.g_TG_DEF_PS_MIN_GEN_MW),
											PS_MIN_PUMP_MW => NUM_VAL(MM_PJM_UTIL.g_TG_DEF_PS_MIN_PUMP_MW)
                                           );

	IF v_MAIN_RECORDS.COUNT > 0 THEN
		MEX_PJM_EMKT.GETX_SUBMIT_UNIT_DETAIL(v_MAIN_RECORDS, p_SUBMIT_XML, p_STATUS, p_ERROR_MESSAGE);
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;
		p_ERROR_MESSAGE := PACKAGE_NAME || '.GET_SUBMIT_UNIT_DETAIL_XML: ' || UT.GET_FULL_ERRM;
END GET_SUBMIT_UNIT_DETAIL_XML;
-------------------------------------------------------------------------------------
PROCEDURE IMPORT_UNIT_UPDATES
	(
	p_SCHEDULE_STATE IN NUMBER,
	p_ACCOUNT_NAME IN VARCHAR2,
	p_RECORDS IN MEX_PJM_EMKT_UNIT_UPDATES_TBL,
	p_STATUS OUT NUMBER,
	p_ERROR_MESSAGE OUT VARCHAR2
	) IS

	v_IDX BINARY_INTEGER;
	v_TRANSACTION_ID NUMBER;
	v_UPDATE_HOUR DATE;
	v_SCHEDULE_STATE NUMBER(1) := p_SCHEDULE_STATE;

BEGIN
	p_STATUS := GA.SUCCESS;

	IF p_RECORDS.COUNT = 0 THEN
		RETURN;
	END IF; -- nothing to do

	-- loop over the response table, and update the traits for this resource
	v_IDX := p_RECORDS.FIRST;

	WHILE p_RECORDS.EXISTS(v_IDX) LOOP
		v_UPDATE_HOUR := p_RECORDS(v_IDX).RESPONSE_DATE;

		MM_PJM_EMKT_UTIL.GET_TRANSACTION_ID(p_ACCOUNT_NAME,
                           p_RECORDS(v_IDX).LOCATION,
                           'Generation',
                           MM_PJM_UTIL.g_COMM_DA_ENERGY,
                           0,
                           0,
                           TRUE,
                           v_TRANSACTION_ID,
                           p_ERROR_MESSAGE,
                           NULL,
                           MM_PJM_EMKT_UTIL.g_PJM_GEN_UNIT_DATA_TXN_TYPE,
                           NULL);

		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, v_UPDATE_HOUR, MM_PJM_UTIL.g_TG_UPD_ECON_MIN, 1, 1, p_RECORDS(v_IDX).ECONOMIC_MIN_MW, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, v_UPDATE_HOUR, MM_PJM_UTIL.g_TG_UPD_ECON_MAX, 1, 1, p_RECORDS(v_IDX).ECONOMIC_MAX_MW, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, v_UPDATE_HOUR, MM_PJM_UTIL.g_TG_UPD_EMER_MIN, 1, 1, p_RECORDS(v_IDX).EMERGENCY_MIN_MW, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, v_UPDATE_HOUR, MM_PJM_UTIL.g_TG_UPD_EMER_MAX, 1, 1, p_RECORDS(v_IDX).EMERGENCY_MAX_MW, CUT_TIME_ZONE);

		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, v_UPDATE_HOUR, MM_PJM_UTIL.g_TG_UPD_COMMIT_STATUS, 1, 1, NVL(p_RECORDS(v_IDX).COMMIT_STATUS, 'Economic'), CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, v_UPDATE_HOUR, MM_PJM_UTIL.g_TG_UPD_FIXED_GEN, 1, 1, p_RECORDS(v_IDX).FIXED_GEN, CUT_TIME_ZONE);

		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, v_UPDATE_HOUR, MM_PJM_UTIL.g_TG_UPD_DEF_ECON_MIN, 1, 1, p_RECORDS(v_IDX).DEF_ECONOMIC_MIN_MW, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, v_UPDATE_HOUR, MM_PJM_UTIL.g_TG_UPD_DEF_ECON_MAX, 1, 1, p_RECORDS(v_IDX).DEF_ECONOMIC_MAX_MW, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, v_UPDATE_HOUR, MM_PJM_UTIL.g_TG_UPD_DEF_EMER_MIN, 1, 1, p_RECORDS(v_IDX).DEF_EMERGENCY_MIN_MW, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, v_UPDATE_HOUR, MM_PJM_UTIL.g_TG_UPD_DEF_EMER_MAX, 1, 1, p_RECORDS(v_IDX).DEF_EMERGENCY_MAX_MW, CUT_TIME_ZONE);

		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, v_UPDATE_HOUR, MM_PJM_UTIL.g_TG_UPD_NOTIF_TIME, 1, 1, p_RECORDS(v_IDX).NOTIFICATION_TIME, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, v_UPDATE_HOUR, MM_PJM_UTIL.g_TG_UPD_PS_MIN_GEN_MW, 1, 1, p_RECORDS(v_IDX).PS_MIN_GEN_MW, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, v_UPDATE_HOUR, MM_PJM_UTIL.g_TG_UPD_PS_MIN_PUMP_MW, 1, 1, p_RECORDS(v_IDX).PS_MIN_PUMP_MW, CUT_TIME_ZONE);

		v_IDX := p_RECORDS.NEXT(v_IDX);
	END LOOP;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS        := SQLCODE;
		p_ERROR_MESSAGE := PACKAGE_NAME || '.IMPORT_UNIT_UPDATES: ' || UT.GET_FULL_ERRM;

END IMPORT_UNIT_UPDATES;
-------------------------------------------------------------------------------------
PROCEDURE QUERY_UNIT_UPDATES
	(
	p_CRED			 IN mex_credentials,
	p_SCHEDULE_STATE IN NUMBER,
	p_REQUEST_DATE  IN DATE,
	P_LOG_ONLY IN NUMBER,
	p_STATUS OUT NUMBER,
	p_ERROR_MESSAGE OUT VARCHAR2,
	p_LOGGER IN OUT mm_logger_adapter
	) AS

	v_RECORDS MEX_PJM_EMKT_UNIT_UPDATES_TBL;

BEGIN
	p_STATUS    := GA.SUCCESS;
	IF MM_PJM_UTIL.HAS_ESUITE_ACCESS(MM_PJM_EMKT_UTIL.g_EMKT_GEN_ATTR, p_CRED.EXTERNAL_ACCOUNT_NAME) THEN

		MEX_PJM_EMKT.FETCH_UNIT_UPDATES(P_CRED => p_CRED,
										P_LOG_ONLY => P_LOG_ONLY,
										P_LOCATION_TYPE => MEX_PJM_EMKT.g_LOC_TYPE_PORTFOLIO,
										P_LOCATION_NAME => MM_PJM_EMKT_UTIL.GET_GEN_PORTFOLIO_NAME(p_CRED.EXTERNAL_ACCOUNT_NAME),
										P_REQUEST_DATE => p_REQUEST_DATE,
										P_RECORDS => v_RECORDS,
										P_STATUS => p_STATUS,
										P_MESSAGE => p_ERROR_MESSAGE,
										P_LOGGER => p_LOGGER);

		IF p_STATUS >= 0 THEN
			IMPORT_UNIT_UPDATES(p_SCHEDULE_STATE, p_CRED.EXTERNAL_ACCOUNT_NAME, v_RECORDS, p_STATUS, p_ERROR_MESSAGE);
			IF p_SCHEDULE_STATE = 1 THEN
				IMPORT_UNIT_UPDATES(2, p_CRED.EXTERNAL_ACCOUNT_NAME, v_RECORDS, p_STATUS, p_ERROR_MESSAGE);
			END IF;
		END IF;
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS        := SQLCODE;
		p_ERROR_MESSAGE := PACKAGE_NAME || '.QUERY_UNIT_DETAIL: ' ||
												 UT.GET_FULL_ERRM;
END QUERY_UNIT_UPDATES;
------------------------------------------------------------------------------------
PROCEDURE GET_SUBMIT_UNIT_UPDATE_XML
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_DATE IN DATE,
    p_SUBMIT_HOURS IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_SUBMIT_XML OUT XMLTYPE,
	p_STATUS OUT NUMBER,
	p_ERROR_MESSAGE OUT VARCHAR2
	) AS

	v_RECORDS MEX_PJM_EMKT_UNIT_UPDATES_TBL;

	l_LOCATION SERVICE_POINT.EXTERNAL_IDENTIFIER%TYPE;
	v_CURRENT_HOUR NUMBER(2);
    v_SCHEDULE_DATE DATE;
	v_INDEX BINARY_INTEGER;
	v_HOURS VARCHAR2(128);
	v_HOUR_STRING_TABLE GA.STRING_TABLE;
    v_IS_FALL_BACK BOOLEAN := FALSE;  
    v_NUM BINARY_INTEGER := 0;

	v_MIN_ECONOMIC_MW_HOUR  IT_TRAIT_SCHEDULE.TRAIT_VAL%TYPE;
	v_MAX_ECONOMIC_MW_HOUR  IT_TRAIT_SCHEDULE.TRAIT_VAL%TYPE;
	v_MIN_EMERGENCY_MW_HOUR IT_TRAIT_SCHEDULE.TRAIT_VAL%TYPE;
	v_MAX_EMERGENCY_MW_HOUR IT_TRAIT_SCHEDULE.TRAIT_VAL%TYPE;
	v_COMMIT_STATUS_HOUR IT_TRAIT_SCHEDULE.TRAIT_VAL%TYPE;
	v_FIXED_GEN_HOUR IT_TRAIT_SCHEDULE.TRAIT_VAL%TYPE;

	FUNCTION GET_TRAIT_VAL(p_TRAIT_GROUP_ID IN NUMBER) RETURN VARCHAR2 IS
	BEGIN
		RETURN MM_PJM_EMKT_UTIL.GET_IT_TRAIT_SCHEDULE(p_TRAIT_GROUP_ID, p_TRANSACTION_ID, 1, v_SCHEDULE_DATE);
	END GET_TRAIT_VAL;

BEGIN

	p_STATUS := MEX_UTIL.g_SUCCESS;
	v_RECORDS := MEX_PJM_EMKT_UNIT_UPDATES_TBL();
	l_LOCATION := GET_LOCATION_FOR_TXN_ID(p_TRANSACTION_ID);

	v_HOURS := REPLACE(p_SUBMIT_HOURS, '''', '');
	UT.TOKENS_FROM_STRING(v_HOURS, ',', v_HOUR_STRING_TABLE);
	v_INDEX := v_HOUR_STRING_TABLE.FIRST;

    IF TRUNC(DST_FALL_BACK_DATE(p_SCHEDULE_DATE)) = TRUNC(p_SCHEDULE_DATE) THEN
        v_IS_FALL_BACK := TRUE;
    END IF; 

	--LOOP OVER HOURS INCLUDED IN SUBMIT HOURS.
	LOOP
        v_CURRENT_HOUR  := TO_NUMBER(v_HOUR_STRING_TABLE(v_INDEX));
        IF v_IS_FALL_BACK AND v_CURRENT_HOUR = 3 THEN
            v_CURRENT_HOUR := 2;           
            v_NUM := 1;
        ELSIF v_IS_FALL_BACK AND v_CURRENT_HOUR > 3 THEN
            v_CURRENT_HOUR := v_CURRENT_HOUR - 1;  
            v_NUM := 0;
        ELSE
           v_NUM := 0;     
        END IF;     
        
        v_SCHEDULE_DATE := TO_CUT_WITH_OPTIONS(p_SCHEDULE_DATE + v_CURRENT_HOUR / 24 + v_NUM/86400,  
                                                p_TIME_ZONE,
                                                MM_PJM_UTIL.g_DST_SPRING_AHEAD_OPTION);

		v_MIN_ECONOMIC_MW_HOUR := GET_TRAIT_VAL(MM_PJM_UTIL.g_TG_UPD_ECON_MIN);
		v_MAX_ECONOMIC_MW_HOUR := GET_TRAIT_VAL(MM_PJM_UTIL.g_TG_UPD_ECON_MAX);
		v_MIN_EMERGENCY_MW_HOUR := GET_TRAIT_VAL(MM_PJM_UTIL.g_TG_UPD_EMER_MIN);
		v_MAX_EMERGENCY_MW_HOUR := GET_TRAIT_VAL(MM_PJM_UTIL.g_TG_UPD_EMER_MAX);
		v_COMMIT_STATUS_HOUR := NVL(GET_TRAIT_VAL(MM_PJM_UTIL.g_TG_UPD_COMMIT_STATUS), 'Economic');
		v_FIXED_GEN_HOUR := GET_TRAIT_VAL(MM_PJM_UTIL.g_TG_UPD_FIXED_GEN);

		v_RECORDS.EXTEND();
		v_RECORDS(v_RECORDS.LAST) := MEX_PJM_EMKT_UNIT_UPDATES(
            RESPONSE_DATE => v_SCHEDULE_DATE,
			LOCATION => l_LOCATION,
			ECONOMIC_MIN_MW => TO_NUMBER(v_MIN_ECONOMIC_MW_HOUR),
			ECONOMIC_MAX_MW => TO_NUMBER(v_MAX_ECONOMIC_MW_HOUR),
			EMERGENCY_MIN_MW => TO_NUMBER(v_MIN_EMERGENCY_MW_HOUR),
			EMERGENCY_MAX_MW => TO_NUMBER(v_MAX_EMERGENCY_MW_HOUR),
			COMMIT_STATUS => v_COMMIT_STATUS_HOUR,
			FIXED_GEN => TO_NUMBER(v_FIXED_GEN_HOUR),
			-- These next four are not needed on submit.
			DEF_ECONOMIC_MIN_MW => NULL,
			DEF_ECONOMIC_MAX_MW => NULL,
			DEF_EMERGENCY_MIN_MW => NULL,
			DEF_EMERGENCY_MAX_MW => NULL,
			NOTIFICATION_TIME => GET_TRAIT_VAL(MM_PJM_UTIL.g_TG_UPD_NOTIF_TIME),
			PS_MIN_GEN_MW => GET_TRAIT_VAL(MM_PJM_UTIL.g_TG_UPD_PS_MIN_GEN_MW),
			PS_MIN_PUMP_MW => GET_TRAIT_VAL(MM_PJM_UTIL.g_TG_UPD_PS_MIN_PUMP_MW)
			);

        EXIT WHEN v_INDEX = v_HOUR_STRING_TABLE.LAST;
		v_INDEX := v_HOUR_STRING_TABLE.NEXT(v_INDEX);
	END LOOP;

	IF v_RECORDS.COUNT > 0 THEN
		MEX_PJM_EMKT.GETX_SUBMIT_UNIT_UPDATE(v_RECORDS, p_SUBMIT_XML, p_STATUS, p_ERROR_MESSAGE);
	END IF;

END GET_SUBMIT_UNIT_UPDATE_XML;
-------------------------------------------------------------------------------------
PROCEDURE QUERY_SPREG_AWARD
	(
	p_CRED			 IN mex_credentials,
	p_REQUEST_DATE IN DATE,
	p_LOG_ONLY      IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR2,
	p_LOGGER IN OUT mm_logger_adapter
	) AS

	v_RECORDS MEX_PJM_EMKT_SPIN_RES_AWAR_TBL;

BEGIN

	p_STATUS    := GA.SUCCESS;


	IF MM_PJM_UTIL.HAS_ESUITE_ACCESS(MM_PJM_EMKT_UTIL.g_EMKT_GEN_ATTR, p_CRED.EXTERNAL_ACCOUNT_NAME) THEN

		MEX_PJM_EMKT.FETCH_SPREG_AWARD(p_CRED => p_CRED,
									   p_LOG_ONLY => p_LOG_ONLY,
									   p_LOCATION_TYPE => MEX_PJM_EMKT.g_LOC_TYPE_PORTFOLIO,
									   p_LOCATION_NAME => MM_PJM_EMKT_UTIL.GET_GEN_PORTFOLIO_NAME(p_CRED.EXTERNAL_ACCOUNT_NAME),
									   p_REQUEST_DATE => p_REQUEST_DATE,
									   p_RECORDS => v_RECORDS,
									   p_STATUS => p_STATUS,
									   p_MESSAGE => p_MESSAGE,
									   p_LOGGER => p_LOGGER);
		IF p_STATUS >= 0 THEN
			IMPORT_SPREG_AWARD(p_CRED.EXTERNAL_ACCOUNT_NAME, v_RECORDS, p_STATUS, p_MESSAGE);
		END IF;
	END IF;

EXCEPTION
		WHEN OTHERS THEN
			p_STATUS        := SQLCODE;
			p_MESSAGE := PACKAGE_NAME || '.QUERY_SPREG_AWARD: ' ||
												 UT.GET_FULL_ERRM;

END QUERY_SPREG_AWARD;
-------------------------------------------------------------------------------------
PROCEDURE IMPORT_SCHEDULE_DETAIL
	(
	p_SCHEDULE_STATE IN NUMBER,
	p_ACCOUNT_NAME IN VARCHAR2,
	p_RECORDS IN MEX_PJM_EMKT_SCHED_DETAIL_TBL,
	p_STATUS OUT NUMBER,
	p_ERROR_MESSAGE OUT VARCHAR2
	) IS

    v_IDX BINARY_INTEGER;
    v_TRANSACTION_ID NUMBER;
	v_SCHEDULE_STATE NUMBER(1) := p_SCHEDULE_STATE;

BEGIN
	p_STATUS := GA.SUCCESS;

	IF p_RECORDS.COUNT = 0 THEN
		RETURN;
	END IF; -- nothing to do

	-- loop over the response table, and update the traits for this resource
	v_IDX := p_RECORDS.FIRST;

    WHILE p_RECORDS.EXISTS(v_IDX) LOOP
		MM_PJM_EMKT_UTIL.GET_TRANSACTION_ID(p_ACCOUNT_NAME, p_RECORDS(v_IDX).LOCATION, 'Generation', MM_PJM_UTIL.g_COMM_DA_ENERGY, 0, 0, TRUE, v_TRANSACTION_ID, p_ERROR_MESSAGE, p_RECORDS(v_IDX).SCHEDULE_NUMBER, MM_PJM_EMKT_UTIL.g_PJM_GEN_SCHEDULE_TXN_TYPE, NULL);

		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).SCHEDULE_DAY, MM_PJM_UTIL.g_TG_SCH_MARKET, 1, 1, p_RECORDS(v_IDX).MARKET_TYPE, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).SCHEDULE_DAY, MM_PJM_UTIL.g_TG_SCH_ECON_MIN, 1, 1, p_RECORDS(v_IDX).ECONOMIC_MIN_MW, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).SCHEDULE_DAY, MM_PJM_UTIL.g_TG_SCH_ECON_MAX, 1, 1, p_RECORDS(v_IDX).ECONOMIC_MAX_MW, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).SCHEDULE_DAY, MM_PJM_UTIL.g_TG_SCH_EMER_MIN, 1, 1, p_RECORDS(v_IDX).EMERGENCY_MIN_MW, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).SCHEDULE_DAY, MM_PJM_UTIL.g_TG_SCH_EMER_MAX, 1, 1, p_RECORDS(v_IDX).EMERGENCY_MAX_MW, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).SCHEDULE_DAY, MM_PJM_UTIL.g_TG_SCH_USE_STARTUP_NO_LOAD, 1, 1, p_RECORDS(v_IDX).USE_STARTUP_NO_LOAD, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).SCHEDULE_DAY, MM_PJM_UTIL.g_TG_SCH_PRIMARY_FUEL, 1, 1, p_RECORDS(v_IDX).PRIMARY_FUEL, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).SCHEDULE_DAY, MM_PJM_UTIL.g_TG_SCH_SECONDARY_FUEL, 1, 1, p_RECORDS(v_IDX).SECONDARY_FUEL, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).SCHEDULE_DAY, MM_PJM_UTIL.g_TG_SCH_NO_LOAD_COST, 1, 1, p_RECORDS(v_IDX).NO_LOAD_COST, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).SCHEDULE_DAY, MM_PJM_UTIL.g_TG_SCH_COLD_START_COST, 1, 1, p_RECORDS(v_IDX).COLD_STARTUP_COST, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).SCHEDULE_DAY, MM_PJM_UTIL.g_TG_SCH_INTER_START_COST, 1, 1, p_RECORDS(v_IDX).INTERMEDIATE_STARTUP_COST, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).SCHEDULE_DAY, MM_PJM_UTIL.g_TG_SCH_HOT_START_COST, 1, 1, p_RECORDS(v_IDX).HOT_STARTUP_COST, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).SCHEDULE_DAY, MM_PJM_UTIL.g_TG_SCH_MIN_RUNTIME, 1, 1, p_RECORDS(v_IDX).MINIMUM_RUNTIME, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).SCHEDULE_DAY, MM_PJM_UTIL.g_TG_SCH_MAX_RUNTIME, 1, 1, p_RECORDS(v_IDX).MAXIMUM_RUNTIME, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).SCHEDULE_DAY, MM_PJM_UTIL.g_TG_SCH_MIN_DOWNTIME, 1, 1, p_RECORDS(v_IDX).MINIMUM_DOWNTIME, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).SCHEDULE_DAY, MM_PJM_UTIL.g_TG_SCH_HOT_TO_COLD_TIME, 1, 1, p_RECORDS(v_IDX).HOT_TO_COLD__TIME, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).SCHEDULE_DAY, MM_PJM_UTIL.g_TG_SCH_HOT_TO_INTER_TIME, 1, 1, p_RECORDS(v_IDX).HOT_TO_INTERMEDIATE__TIME, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).SCHEDULE_DAY, MM_PJM_UTIL.g_TG_SCH_COLD_START_TIME, 1, 1, p_RECORDS(v_IDX).COLD_STARTUP_TIME, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).SCHEDULE_DAY, MM_PJM_UTIL.g_TG_SCH_INTER_START_TIME, 1, 1, p_RECORDS(v_IDX).INTERMEDIATE_STARTUP_TIME, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).SCHEDULE_DAY, MM_PJM_UTIL.g_TG_SCH_HOT_START_TIME, 1, 1, p_RECORDS(v_IDX).HOT_STARTUP_TIME, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).SCHEDULE_DAY, MM_PJM_UTIL.g_TG_SCH_COLD_NOTIF_TIME, 1, 1, p_RECORDS(v_IDX).COLD_NOTIFICATION_TIME, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).SCHEDULE_DAY, MM_PJM_UTIL.g_TG_SCH_INTER_NOTIF_TIME, 1, 1, p_RECORDS(v_IDX).INTERMEDIATE_NOTIFICATION_TIME, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).SCHEDULE_DAY, MM_PJM_UTIL.g_TG_SCH_HOT_NOTIF_TIME, 1, 1, p_RECORDS(v_IDX).HOT_NOTIFICATION_TIME, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).SCHEDULE_DAY, MM_PJM_UTIL.g_TG_SCH_MAX_DAILY_STARTS, 1, 1, p_RECORDS(v_IDX).MAXIMUM_DAILY_STARTS, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).SCHEDULE_DAY, MM_PJM_UTIL.g_TG_SCH_MAX_WEEKLY_STARTS, 1, 1, p_RECORDS(v_IDX).MAXIMUM_WEEKLY_STARTS, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).SCHEDULE_DAY, MM_PJM_UTIL.g_TG_SCH_MAX_WEEKLY_ENERGY, 1, 1, p_RECORDS(v_IDX).MAXIMUM_WEEKLY_ENERGY, CUT_TIME_ZONE);

		v_IDX := p_RECORDS.NEXT(v_IDX);
	END LOOP;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS        := SQLCODE;
		p_ERROR_MESSAGE := PACKAGE_NAME || '.IMPORT_SCHEDULE_DETAIL: ' || UT.GET_FULL_ERRM;

END IMPORT_SCHEDULE_DETAIL;
-------------------------------------------------------------------------------------
PROCEDURE QUERY_SCHEDULE_DETAIL
	(
	p_CRED			 IN mex_credentials,
	p_SCHEDULE_STATE IN NUMBER,
	p_REQUEST_DATE  IN DATE,
	p_LOG_ONLY      IN NUMBER,
	p_STATUS OUT NUMBER,
	p_ERROR_MESSAGE OUT VARCHAR2,
	p_LOGGER IN OUT mm_logger_adapter
	) AS

	v_RECORDS MEX_PJM_EMKT_SCHED_DETAIL_TBL;

BEGIN

	p_STATUS    := GA.SUCCESS;
	IF MM_PJM_UTIL.HAS_ESUITE_ACCESS(MM_PJM_EMKT_UTIL.g_EMKT_GEN_ATTR, p_CRED.EXTERNAL_ACCOUNT_NAME) THEN

		MEX_PJM_EMKT.FETCH_SCHEDULE_DETAIL(P_CRED => p_CRED,
										   P_LOG_ONLY => P_LOG_ONLY,
										   P_LOCATION_TYPE => MEX_PJM_EMKT.g_LOC_TYPE_PORTFOLIO,
										   P_LOCATION_NAME => MM_PJM_EMKT_UTIL.GET_GEN_PORTFOLIO_NAME(p_CRED.EXTERNAL_ACCOUNT_NAME),
										   P_REQUEST_DATE => p_REQUEST_DATE,
										   P_RECORDS => v_RECORDS,
										   P_STATUS => p_STATUS,
										   P_MESSAGE => p_ERROR_MESSAGE,
										   p_LOGGER => p_LOGGER);

		IF p_STATUS >= 0 THEN
			IMPORT_SCHEDULE_DETAIL(p_SCHEDULE_STATE, p_CRED.EXTERNAL_ACCOUNT_NAME, v_RECORDS, p_STATUS, p_ERROR_MESSAGE);
			IF p_SCHEDULE_STATE = 1 THEN
				IMPORT_SCHEDULE_DETAIL(2, p_CRED.EXTERNAL_ACCOUNT_NAME, v_RECORDS, p_STATUS, p_ERROR_MESSAGE);
			END IF;
		END IF;
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS        := SQLCODE;
		p_ERROR_MESSAGE := PACKAGE_NAME || '.QUERY_SCHEDULE_OFFER: ' || UT.GET_FULL_ERRM;

END QUERY_SCHEDULE_DETAIL;
-------------------------------------------------------------------------------------
PROCEDURE GET_SUBMIT_SCHEDULE_DETAIL_XML
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_DATE  IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SUBMIT_XML OUT XMLTYPE,
	p_STATUS OUT NUMBER,
	p_ERROR_MESSAGE OUT VARCHAR2
	) AS

	v_RECORDS MEX_PJM_EMKT_SCHED_DETAIL_TBL := MEX_PJM_EMKT_SCHED_DETAIL_TBL();

	l_LOCATION SERVICE_POINT.EXTERNAL_IDENTIFIER%TYPE;
	l_SCHEDULE_NUMBER NUMBER;
	l_CUT_DATE DATE;

	FUNCTION STR_VAL(p_TRAIT_GROUP_ID IN NUMBER) RETURN VARCHAR2 IS
	BEGIN
		RETURN MM_PJM_EMKT_UTIL.GET_IT_TRAIT_SCHEDULE(p_TRAIT_GROUP_ID, p_TRANSACTION_ID, 1, l_CUT_DATE);
	END STR_VAL;
	FUNCTION NUM_VAL(p_TRAIT_GROUP_ID IN NUMBER) RETURN NUMBER IS
	BEGIN
		RETURN TO_NUMBER(STR_VAL(p_TRAIT_GROUP_ID));
	END NUM_VAL;

BEGIN

	p_STATUS := MEX_UTIL.g_SUCCESS;

	l_CUT_DATE := TRUNC(p_SCHEDULE_DATE) + 1/86400;

	l_SCHEDULE_NUMBER := GET_SCHED_NUM_FOR_TXN_ID(p_TRANSACTION_ID);
	l_LOCATION := GET_LOCATION_FOR_TXN_ID(p_TRANSACTION_ID);

	-- There is only one set of Schedule Details per transaction per day.
	v_RECORDS.EXTEND();
	v_RECORDS(v_RECORDS.LAST) := MEX_PJM_EMKT_SCHED_DETAIL(
		LOCATION => l_LOCATION,
		SCHEDULE_NUMBER => l_SCHEDULE_NUMBER,
		SCHEDULE_DAY => l_CUT_DATE,
		MARKET_TYPE => STR_VAL(MM_PJM_UTIL.g_TG_SCH_MARKET),
		ECONOMIC_MIN_MW => NUM_VAL(MM_PJM_UTIL.g_TG_SCH_ECON_MIN),
		ECONOMIC_MAX_MW => NUM_VAL(MM_PJM_UTIL.g_TG_SCH_ECON_MAX),
		EMERGENCY_MIN_MW => NUM_VAL(MM_PJM_UTIL.g_TG_SCH_EMER_MIN),
		EMERGENCY_MAX_MW => NUM_VAL(MM_PJM_UTIL.g_TG_SCH_EMER_MAX),
		USE_STARTUP_NO_LOAD => STR_VAL(MM_PJM_UTIL.g_TG_SCH_USE_STARTUP_NO_LOAD),
		PRIMARY_FUEL => STR_VAL(MM_PJM_UTIL.g_TG_SCH_PRIMARY_FUEL),
		SECONDARY_FUEL => STR_VAL(MM_PJM_UTIL.g_TG_SCH_SECONDARY_FUEL),
		NO_LOAD_COST => NUM_VAL(MM_PJM_UTIL.g_TG_SCH_NO_LOAD_COST),
		COLD_STARTUP_COST => NUM_VAL(MM_PJM_UTIL.g_TG_SCH_COLD_START_COST),
		INTERMEDIATE_STARTUP_COST => NUM_VAL(MM_PJM_UTIL.g_TG_SCH_INTER_START_COST),
		HOT_STARTUP_COST => NUM_VAL(MM_PJM_UTIL.g_TG_SCH_HOT_START_COST),
		MINIMUM_RUNTIME => NUM_VAL(MM_PJM_UTIL.g_TG_SCH_MIN_RUNTIME),
		MAXIMUM_RUNTIME => NUM_VAL(MM_PJM_UTIL.g_TG_SCH_MAX_RUNTIME),
		MINIMUM_DOWNTIME => NUM_VAL(MM_PJM_UTIL.g_TG_SCH_MIN_DOWNTIME),
		HOT_TO_COLD__TIME => NUM_VAL(MM_PJM_UTIL.g_TG_SCH_HOT_TO_COLD_TIME),
		HOT_TO_INTERMEDIATE__TIME => NUM_VAL(MM_PJM_UTIL.g_TG_SCH_HOT_TO_INTER_TIME),
		COLD_STARTUP_TIME => NUM_VAL(MM_PJM_UTIL.g_TG_SCH_COLD_START_TIME),
		INTERMEDIATE_STARTUP_TIME => NUM_VAL(MM_PJM_UTIL.g_TG_SCH_INTER_START_TIME),
		HOT_STARTUP_TIME => NUM_VAL(MM_PJM_UTIL.g_TG_SCH_HOT_START_TIME),
		COLD_NOTIFICATION_TIME => NUM_VAL(MM_PJM_UTIL.g_TG_SCH_COLD_NOTIF_TIME),
		INTERMEDIATE_NOTIFICATION_TIME => NUM_VAL(MM_PJM_UTIL.g_TG_SCH_INTER_NOTIF_TIME),
		HOT_NOTIFICATION_TIME => NUM_VAL(MM_PJM_UTIL.g_TG_SCH_HOT_NOTIF_TIME),
		MAXIMUM_DAILY_STARTS => NUM_VAL(MM_PJM_UTIL.g_TG_SCH_MAX_DAILY_STARTS),
		MAXIMUM_WEEKLY_STARTS => NUM_VAL(MM_PJM_UTIL.g_TG_SCH_MAX_WEEKLY_STARTS),
		MAXIMUM_WEEKLY_ENERGY => NUM_VAL(MM_PJM_UTIL.g_TG_SCH_MAX_WEEKLY_ENERGY)
		);

	IF v_RECORDS.COUNT > 0 THEN
		MEX_PJM_EMKT.GETX_SUBMIT_SCHEDULE_DETAIL(v_RECORDS, p_SUBMIT_XML, p_STATUS, p_ERROR_MESSAGE);
	END IF;

END GET_SUBMIT_SCHEDULE_DETAIL_XML;
-------------------------------------------------------------------------------------
PROCEDURE IMPORT_SCHEDULE_OFFER
	(
	p_SCHEDULE_STATE IN NUMBER,
	p_ACCOUNT_NAME IN VARCHAR2,
	p_RECORDS IN MEX_PJM_EMKT_SCHED_OFFER_TBL,
	p_STATUS OUT NUMBER,
	p_ERROR_MESSAGE OUT VARCHAR2
	) IS

	l_DATE DATE;
	l_LOCATION_NAME SUPPLY_RESOURCE.RESOURCE_NAME%TYPE;
	l_TRANSACTION_ID INTERCHANGE_TRANSACTION.TRANSACTION_ID%TYPE;
    l_SCHEDULE_NUMBER NUMBER;
	l_SET_NUMBER NUMBER;
	v_IDX BINARY_INTEGER;
	v_SCHEDULE_STATE NUMBER(1) := p_SCHEDULE_STATE;
BEGIN
	p_STATUS := GA.SUCCESS;

	IF p_RECORDS.COUNT = 0 THEN
		RETURN;
	END IF; -- nothing to do

	-- loop over the response Table, and update the traits for this resource
	-- (playing a few games to figure out the transaction ID associated with it)
	l_LOCATION_NAME := NULL;
	l_SET_NUMBER    := 1;
    l_SCHEDULE_NUMBER := NULL;

	v_IDX := p_RECORDS.FIRST;

	WHILE p_RECORDS.EXISTS(v_IDX) LOOP
		IF ((l_LOCATION_NAME IS NULL AND p_RECORDS(v_IDX).LOCATION IS NOT NULL) OR p_RECORDS(v_IDX).LOCATION != l_LOCATION_NAME) OR
           ((l_SCHEDULE_NUMBER IS NULL AND p_RECORDS(v_IDX).SCHEDULE_NUMBER IS NOT NULL) OR p_RECORDS(v_IDX).SCHEDULE_NUMBER != l_SCHEDULE_NUMBER) THEN
			-- update the counter for the p/q pair
			l_SET_NUMBER := 1;
			-- update the location name
			l_LOCATION_NAME := p_RECORDS(v_IDX).LOCATION;
            --update the schedule number
            l_SCHEDULE_NUMBER := p_RECORDS(v_IDX).SCHEDULE_NUMBER;

			MM_PJM_EMKT_UTIL.GET_TRANSACTION_ID(p_ACCOUNT_NAME, p_RECORDS(v_IDX).LOCATION, 'Generation', MM_PJM_UTIL.g_COMM_DA_ENERGY, 0, 0, TRUE, l_TRANSACTION_ID, p_ERROR_MESSAGE, p_RECORDS(v_IDX).SCHEDULE_NUMBER,MM_PJM_EMKT_UTIL.g_PJM_GEN_SCHEDULE_TXN_TYPE, NULL);
			TG.PUT_IT_TRAIT_SCHEDULE(l_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).RESPONSE_DATE, MM_PJM_UTIL.g_TG_OFF_SLOPE, 1, 1, CASE p_RECORDS(v_IDX).SLOPE WHEN 1 THEN 'Point Slope' ELSE 'Block Mode' END, CUT_TIME_ZONE);
		END IF;

		l_DATE := p_RECORDS(v_IDX).RESPONSE_DATE + 1/86400;
		BO.PUT_BID_OFFER_SET(p_TRANSACTION_ID => l_TRANSACTION_ID,
										 p_BID_OFFER_ID   => 0,
										 p_SCHEDULE_STATE => v_SCHEDULE_STATE,
										 p_SCHEDULE_DATE  => l_DATE,
										 p_SET_NUMBER     => l_SET_NUMBER,
										 p_PRICE          => p_RECORDS(v_IDX).PRICE,
										 p_QUANTITY       => p_RECORDS(v_IDX).QUANTITY,
										 p_OFFER_STATUS   => 'P',
										 p_TIME_ZONE      => MM_PJM_EMKT_UTIL.g_PJM_TIME_ZONE,
										 p_STATUS         => p_STATUS);
		l_SET_NUMBER := l_SET_NUMBER + 1;
		v_IDX := p_RECORDS.NEXT(v_IDX);
	END LOOP;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS        := SQLCODE;
		p_ERROR_MESSAGE := PACKAGE_NAME || '.IMPORT_SCHEDULE_OFFER: ' || UT.GET_FULL_ERRM;

END IMPORT_SCHEDULE_OFFER;
-------------------------------------------------------------------------------------
PROCEDURE QUERY_SCHEDULE_OFFER
	(
	p_CRED			 IN mex_credentials,
	p_SCHEDULE_STATE IN NUMBER,
    p_REQUEST_DAY   IN DATE,
	p_LOG_ONLY      IN NUMBER,
    p_STATUS OUT NUMBER,
    p_ERROR_MESSAGE OUT VARCHAR2,
	p_LOGGER IN OUT mm_logger_adapter
    )
    AS

    v_RECORDS MEX_PJM_EMKT_SCHED_OFFER_TBL;

BEGIN

	p_STATUS    := GA.SUCCESS;
	IF MM_PJM_UTIL.HAS_ESUITE_ACCESS(MM_PJM_EMKT_UTIL.g_EMKT_GEN_ATTR, p_CRED.EXTERNAL_ACCOUNT_NAME) THEN

		MEX_PJM_EMKT.FETCH_SCHEDULE_OFFER(P_CRED => p_CRED,
										  P_LOG_ONLY => P_LOG_ONLY,
										  P_LOCATION_TYPE => MEX_PJM_EMKT.g_LOC_TYPE_PORTFOLIO,
										  P_LOCATION_NAME => MM_PJM_EMKT_UTIL.GET_GEN_PORTFOLIO_NAME(p_CRED.EXTERNAL_ACCOUNT_NAME),
										  P_REQUEST_DATE => p_REQUEST_DAY,
										  P_RECORDS => v_RECORDS,
										  P_STATUS => p_STATUS,
										  P_MESSAGE => p_ERROR_MESSAGE,
										  P_LOGGER => p_LOGGER);

		IF p_STATUS >= 0 THEN
			IMPORT_SCHEDULE_OFFER(p_SCHEDULE_STATE, p_CRED.EXTERNAL_ACCOUNT_NAME, v_RECORDS, p_STATUS, p_ERROR_MESSAGE);
			IF p_SCHEDULE_STATE = 1 THEN
				IMPORT_SCHEDULE_OFFER(2, p_CRED.EXTERNAL_ACCOUNT_NAME, v_RECORDS, p_STATUS, p_ERROR_MESSAGE);
			END IF;
		END IF;
	END IF;

EXCEPTION
		WHEN OTHERS THEN
			p_STATUS        := SQLCODE;
			p_ERROR_MESSAGE := PACKAGE_NAME || '.QUERY_SCHEDULE_OFFER: ' ||
												 UT.GET_FULL_ERRM;

END QUERY_SCHEDULE_OFFER;
-------------------------------------------------------------------------------------
PROCEDURE GET_SUBMIT_SCHEDULE_OFFER_XML
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_DATE  IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SUBMIT_XML OUT XMLTYPE,
	p_STATUS OUT NUMBER,
	p_ERROR_MESSAGE  OUT VARCHAR2
	) AS

    v_RECORDS MEX_PJM_EMKT_SCHED_OFFER_TBL := MEX_PJM_EMKT_SCHED_OFFER_TBL();

    l_LOCATION SERVICE_POINT.EXTERNAL_IDENTIFIER%TYPE;
    l_OFFER_SLOPE VARCHAR2(32);
    l_SCHEDULE_NUMBER NUMBER;
    l_CUT_DATE DATE;

CURSOR c_SETS IS
	SELECT l_CUT_DATE, l_SCHEDULE_NUMBER, l_LOCATION, l_OFFER_SLOPE, BOS.QUANTITY, BOS.PRICE
	FROM BID_OFFER_SET BOS
	WHERE BOS.TRANSACTION_ID = p_TRANSACTION_ID
		AND BOS.SCHEDULE_STATE = 1
		AND BOS.SCHEDULE_DATE = l_CUT_DATE
	ORDER BY BOS.SET_NUMBER ASC;
BEGIN

	p_STATUS := MEX_UTIL.g_SUCCESS;

	l_CUT_DATE := TRUNC(p_SCHEDULE_DATE) + 1/86400;
	l_LOCATION := GET_LOCATION_FOR_TXN_ID(p_TRANSACTION_ID);
	l_SCHEDULE_NUMBER := GET_SCHED_NUM_FOR_TXN_ID(p_TRANSACTION_ID);
	l_OFFER_SLOPE := MM_PJM_EMKT_UTIL.GET_IT_TRAIT_SCHEDULE(MM_PJM_UTIL.g_TG_OFF_SLOPE, p_TRANSACTION_ID, 1, l_CUT_DATE);

	-- Loop through the set numbers.
	FOR v_SETS IN c_SETS LOOP
		v_RECORDS.EXTEND();
		v_RECORDS(v_RECORDS.LAST()) := MEX_PJM_EMKT_SCHED_OFFER(
			RESPONSE_DATE   => v_SETS.L_CUT_DATE,
			SCHEDULE_NUMBER => v_SETS.L_SCHEDULE_NUMBER,
			LOCATION => v_SETS.L_LOCATION,
			SLOPE => CASE UPPER(v_SETS.L_OFFER_SLOPE) WHEN 'POINT SLOPE' THEN 1 ELSE 0 END,
			QUANTITY => v_SETS.QUANTITY,
			PRICE => v_SETS.PRICE
		);
	END LOOP;

	IF v_RECORDS.COUNT > 0 THEN
		MEX_PJM_EMKT.GETX_SUBMIT_SCHEDULE_OFFER(v_RECORDS, p_SUBMIT_XML, p_STATUS, p_ERROR_MESSAGE);
	END IF;

END GET_SUBMIT_SCHEDULE_OFFER_XML;
-------------------------------------------------------------------------------------
PROCEDURE IMPORT_SCHEDULE_SELECTION
	(
	p_SCHEDULE_STATE IN NUMBER,
	p_ACCOUNT_NAME IN VARCHAR2,
	p_RECORDS IN MEX_PJM_EMKT_SCHED_SEL_TBL,
	p_STATUS OUT NUMBER,
	p_ERROR_MESSAGE OUT VARCHAR2
	) IS

	v_IDX BINARY_INTEGER;
	v_TRANSACTION_ID    NUMBER;

BEGIN
	p_STATUS := GA.SUCCESS;

	IF p_RECORDS.COUNT = 0 THEN
		RETURN;
	END IF; -- nothing to do

	-- loop over the response table, and update the traits for this resource
	v_IDX := p_RECORDS.FIRST;
	WHILE p_RECORDS.EXISTS(v_IDX) LOOP
		MM_PJM_EMKT_UTIL.GET_TRANSACTION_ID(p_ACCOUNT_NAME, p_RECORDS(v_IDX).LOCATION, 'Generation', MM_PJM_UTIL.g_COMM_DA_ENERGY, 0, 0, TRUE, v_TRANSACTION_ID, p_ERROR_MESSAGE, p_RECORDS(v_IDX).SCHEDULE_NUMBER, MM_PJM_EMKT_UTIL.g_PJM_GEN_SCHEDULE_TXN_TYPE,NULL);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, p_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).RESPONSE_DATE, MM_PJM_UTIL.g_TG_SEL_AVAILABLE, 1, 1, p_RECORDS(v_IDX).AVAILABLE, CUT_TIME_ZONE);
		v_IDX := p_RECORDS.NEXT(v_IDX);
	END LOOP;

END IMPORT_SCHEDULE_SELECTION;
-------------------------------------------------------------------------------------
PROCEDURE QUERY_SCHEDULE_SELECTION
	(
	p_CRED			 IN mex_credentials,
	p_SCHEDULE_STATE IN NUMBER,
	p_REQUEST_DATE IN DATE,
	p_LOG_ONLY      IN NUMBER,
	p_STATUS OUT NUMBER,
	p_ERROR_MESSAGE OUT VARCHAR2,
	p_LOGGER IN OUT mm_logger_adapter
	) AS

    v_RECORDS MEX_PJM_EMKT_SCHED_SEL_TBL;

BEGIN

	p_STATUS    := GA.SUCCESS;
	IF MM_PJM_UTIL.HAS_ESUITE_ACCESS(MM_PJM_EMKT_UTIL.g_EMKT_GEN_ATTR, p_CRED.EXTERNAL_ACCOUNT_NAME) THEN

		MEX_PJM_EMKT.FETCH_SCHEDULE_SELECTION(p_CRED => p_CRED,
									   p_LOG_ONLY => p_LOG_ONLY,
									   p_LOCATION_TYPE => MEX_PJM_EMKT.g_LOC_TYPE_PORTFOLIO,
									   p_LOCATION_NAME => MM_PJM_EMKT_UTIL.GET_GEN_PORTFOLIO_NAME(p_CRED.EXTERNAL_ACCOUNT_NAME),
									   p_REQUEST_DATE => p_REQUEST_DATE,
									   p_RECORDS => v_RECORDS,
									   p_STATUS => p_STATUS,
									   p_MESSAGE => p_ERROR_MESSAGE,
									   p_LOGGER => p_LOGGER);

		IF p_STATUS >= 0 THEN
			IMPORT_SCHEDULE_SELECTION(p_SCHEDULE_STATE, p_CRED.EXTERNAL_ACCOUNT_NAME, v_RECORDS, p_STATUS, p_ERROR_MESSAGE);
			IF p_SCHEDULE_STATE = 1 THEN
				IMPORT_SCHEDULE_SELECTION(2, p_CRED.EXTERNAL_ACCOUNT_NAME, v_RECORDS, p_STATUS, p_ERROR_MESSAGE);
			END IF;
		END IF;
	END IF;

END QUERY_SCHEDULE_SELECTION;
-------------------------------------------------------------------------------------
PROCEDURE GET_SUBMIT_SCHEDULE_SEL_XML
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SUBMIT_XML OUT XMLTYPE,
	p_STATUS OUT NUMBER,
	p_ERROR_MESSAGE OUT VARCHAR2
	) AS

	v_RECORDS MEX_PJM_EMKT_SCHED_SEL_TBL := MEX_PJM_EMKT_SCHED_SEL_TBL();

	l_SCHEDULE_NUMBER NUMBER;
	l_CUT_DATE DATE := p_SCHEDULE_DATE + 1/86400;

	-- get the external ID of the resource's service point through the transaction
	l_LOCATION SERVICE_POINT.EXTERNAL_IDENTIFIER%TYPE;
	v_VAL IT_TRAIT_SCHEDULE.TRAIT_VAL%TYPE;

BEGIN

	p_STATUS := MEX_UTIL.g_SUCCESS;
	l_LOCATION := GET_LOCATION_FOR_TXN_ID(p_TRANSACTION_ID);
	l_SCHEDULE_NUMBER := GET_SCHED_NUM_FOR_TXN_ID(p_TRANSACTION_ID);


	-- There is only one Schedule Selection value per day, per Transaction.
	v_VAL := MM_PJM_EMKT_UTIL.GET_IT_TRAIT_SCHEDULE(MM_PJM_UTIL.g_TG_SEL_AVAILABLE, p_TRANSACTION_ID, 1, l_CUT_DATE);
	IF v_VAL IS NOT NULL THEN
		v_RECORDS.EXTEND();
		v_RECORDS(v_RECORDS.LAST()) := MEX_PJM_EMKT_SCHED_SEL(
				RESPONSE_DATE => l_CUT_DATE,
				LOCATION => l_LOCATION,
				SCHEDULE_NUMBER => l_SCHEDULE_NUMBER,
				AVAILABLE => v_VAL
				);
	END IF;

	IF v_RECORDS.COUNT > 0 THEN
		MEX_PJM_EMKT.GETX_SUBMIT_SCHEDULE_SELECTION(v_RECORDS, p_SUBMIT_XML, p_STATUS, p_ERROR_MESSAGE);
	END IF;

END GET_SUBMIT_SCHEDULE_SEL_XML;
-------------------------------------------------------------------------------------
PROCEDURE IMPORT_REGULATION_OFFER
          (
		  p_SCHEDULE_STATE IN NUMBER,
	      p_ACCOUNT_NAME IN VARCHAR2,
	      p_RECORDS IN MEX_PJM_EMKT_REG_OFFER_TBL,
	      p_STATUS OUT NUMBER,
	      p_MESSAGE OUT VARCHAR2
          ) AS

    v_IDX            BINARY_INTEGER;
    v_TRANSACTION_ID NUMBER(9);
	v_SCHEDULE_STATE NUMBER(1) := p_SCHEDULE_STATE;

BEGIN
	p_STATUS := GA.SUCCESS;

	IF p_RECORDS.COUNT = 0 THEN
		RETURN;
	END IF; -- nothing to do

	-- loop over the response table, and update the traits for this resource
	v_IDX := p_RECORDS.FIRST;

	WHILE p_RECORDS.EXISTS(v_IDX) LOOP

        MM_PJM_EMKT_UTIL.GET_TRANSACTION_ID(p_ACCOUNT_NAME,
                           p_RECORDS(v_IDX).LOCATION,
			               'Generation',
                           MM_PJM_UTIL.g_COMM_REGULATION,
                           0,
                           0,
                           TRUE,
                           v_TRANSACTION_ID,
                           p_MESSAGE,
                           NULL,
                           MM_PJM_EMKT_UTIL.g_PJM_GEN_REGULATION_TXN_TYPE,
                           NULL);

		BO.PUT_BID_OFFER_SET(p_TRANSACTION_ID => v_TRANSACTION_ID,
    						 p_BID_OFFER_ID   => 0,
    						 p_SCHEDULE_STATE => v_SCHEDULE_STATE,
    						 p_SCHEDULE_DATE  => p_RECORDS(v_IDX).RESPONSE_DATE,
    						 p_SET_NUMBER     => 1,
    						 p_PRICE          => p_RECORDS(v_IDX).PRICE,
    						 p_QUANTITY       => p_RECORDS(v_IDX).QUANTITY,
    						 p_OFFER_STATUS   => 'P',
    						 p_TIME_ZONE      => MM_PJM_EMKT_UTIL.g_PJM_TIME_ZONE,
    						 p_STATUS         => p_STATUS);
  		-- update trait values
        TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).RESPONSE_DATE, MM_PJM_UTIL.g_TG_REG_OFF_UNAVAILABLE, 1, 1, p_RECORDS(v_IDX).UNAVAILABLE, CUT_TIME_ZONE);
        TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).RESPONSE_DATE, MM_PJM_UTIL.g_TG_REG_OFF_SELF_SCHEDULED, 1, 1, p_RECORDS(v_IDX).SELF_SCHEDULED, CUT_TIME_ZONE);
        TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).RESPONSE_DATE, MM_PJM_UTIL.g_TG_REG_OFF_MINIMUM_MW, 1, 1, p_RECORDS(v_IDX).MINIMUM_MW, CUT_TIME_ZONE);

		v_IDX := p_RECORDS.NEXT(v_IDX);
	END LOOP;

EXCEPTION
  	WHEN OTHERS THEN
  		p_STATUS        := SQLCODE;
  		p_MESSAGE := PACKAGE_NAME || '.IMPORT_REGULATION_OFFER: ' || UT.GET_FULL_ERRM;

END IMPORT_REGULATION_OFFER;
-------------------------------------------------------------------------------------
PROCEDURE IMPORT_SPIN_RESERVE_OFFER
          (
		  p_SCHEDULE_STATE IN NUMBER,
	      p_ACCOUNT_NAME IN VARCHAR2,
	      p_RECORDS IN MEX_PJM_EMKT_SPIN_RES_OFF_TBL,
	      p_STATUS OUT NUMBER,
	      p_MESSAGE OUT VARCHAR2
          ) AS

    v_IDX            BINARY_INTEGER;
    v_TRANSACTION_ID NUMBER(9);
	v_SCHEDULE_STATE NUMBER(1) := p_SCHEDULE_STATE;

BEGIN
	p_STATUS := GA.SUCCESS;

	IF p_RECORDS.COUNT = 0 THEN
		RETURN;
	END IF; -- nothing to do

	-- loop over the response table, and update the traits for this resource
	v_IDX := p_RECORDS.FIRST;

	WHILE p_RECORDS.EXISTS(v_IDX) LOOP

        MM_PJM_EMKT_UTIL.GET_TRANSACTION_ID(p_ACCOUNT_NAME,
                           p_RECORDS(v_IDX).LOCATION,
			               'Generation',
                           MM_PJM_UTIL.g_COMM_SPIN_RES,
                           0,
                           0,
                           TRUE,
                           v_TRANSACTION_ID,
                           p_MESSAGE,
                           NULL,
                           MM_PJM_EMKT_UTIL.g_PJM_GEN_SPIN_RES_TXN_TYPE,
                           'Tier2');

		BO.PUT_BID_OFFER_SET(p_TRANSACTION_ID => v_TRANSACTION_ID,
    						 p_BID_OFFER_ID   => 0,
    						 p_SCHEDULE_STATE => v_SCHEDULE_STATE,
    						 p_SCHEDULE_DATE  => p_RECORDS(v_IDX).RESPONSE_DATE,
    						 p_SET_NUMBER     => 1,
    						 p_PRICE          => p_RECORDS(v_IDX).PRICE,
    						 p_QUANTITY       => p_RECORDS(v_IDX).QUANTITY,
    						 p_OFFER_STATUS   => 'P',
    						 p_TIME_ZONE      => MM_PJM_EMKT_UTIL.g_PJM_TIME_ZONE,
    						 p_STATUS         => p_STATUS);
  		-- update trait values
        TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).RESPONSE_DATE, MM_PJM_UTIL.g_TG_SPIN_OFF_COND_AVAILABLE, 1, 1, p_RECORDS(v_IDX).CONDENSE_AVAILABLE, CUT_TIME_ZONE);
        TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).RESPONSE_DATE, MM_PJM_UTIL.g_TG_SPIN_OFF_COND_START_COST, 1, 1, p_RECORDS(v_IDX).COND_STARTUP_COST, CUT_TIME_ZONE);
        TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).RESPONSE_DATE, MM_PJM_UTIL.g_TG_SPIN_OFF_COND_EN_USAGE, 1, 1, p_RECORDS(v_IDX).COND_ENERGY_USAGE, CUT_TIME_ZONE);
        TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).RESPONSE_DATE, MM_PJM_UTIL.g_TG_SPIN_OFF_COND_TO_GEN_COST, 1, 1, p_RECORDS(v_IDX).COND_TO_GEN_COST, CUT_TIME_ZONE);
        TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).RESPONSE_DATE, MM_PJM_UTIL.g_TG_SPIN_OFF_SPIN_AS_COND, 1, 1, p_RECORDS(v_IDX).SPIN_AS_CONDENSER, CUT_TIME_ZONE);
        TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).RESPONSE_DATE, MM_PJM_UTIL.g_TG_SPIN_OFF_FULL_LOAD_HR, 1, 1, p_RECORDS(v_IDX).FULL_LOAD_HR, CUT_TIME_ZONE);
        TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).RESPONSE_DATE, MM_PJM_UTIL.g_TG_SPIN_OFF_REDUCED_LOAD_HR, 1, 1, p_RECORDS(v_IDX).REDUCED_LOAD_HR, CUT_TIME_ZONE);
        TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, p_RECORDS(v_IDX).RESPONSE_DATE, MM_PJM_UTIL.g_TG_SPIN_OFF_VOM_RATE, 1, 1, p_RECORDS(v_IDX).VOM_RATE, CUT_TIME_ZONE);

		v_IDX := p_RECORDS.NEXT(v_IDX);
	END LOOP;

EXCEPTION
  	WHEN OTHERS THEN
  		p_STATUS        := SQLCODE;
  		p_MESSAGE := PACKAGE_NAME || '.IMPORT_SPIN_RESERVE_OFFER: ' || UT.GET_FULL_ERRM;

END IMPORT_SPIN_RESERVE_OFFER;
-------------------------------------------------------------------------------------
PROCEDURE GET_SUBMIT_SPIN_OFFER_XML
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_DATE  IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SUBMIT_XML OUT XMLTYPE,
	p_STATUS OUT NUMBER,
	p_ERROR_MESSAGE  OUT VARCHAR2
	) AS

	l_LOCATION SERVICE_POINT.EXTERNAL_IDENTIFIER%TYPE;
	l_XML_FRAGMENT XMLTYPE;
	l_CUT_DATE DATE := TRUNC(p_SCHEDULE_DATE) + 1/86400;
	v_RECORDS MEX_PJM_EMKT_SPIN_RES_OFF_TBL := MEX_PJM_EMKT_SPIN_RES_OFF_TBL();

BEGIN

	p_STATUS := MEX_UTIL.g_SUCCESS;
	l_LOCATION := GET_LOCATION_FOR_TXN_ID(p_TRANSACTION_ID);

	v_RECORDS.EXTEND();
	v_RECORDS(v_RECORDS.LAST) := MEX_PJM_EMKT_SPIN_RES_OFF(
            RESPONSE_DATE => l_CUT_DATE,
			LOCATION => l_LOCATION,
			QUANTITY => TO_NUMBER(MM_PJM_EMKT_UTIL.GET_IT_TRAIT_SCHEDULE(TG.g_TG_OFFER_CURVE, p_TRANSACTION_ID, GA.INTERNAL_STATE, l_CUT_DATE, TG.g_TI_OFFER_QUANTITY, 1)),
			PRICE => TO_NUMBER(MM_PJM_EMKT_UTIL.GET_IT_TRAIT_SCHEDULE(TG.g_TG_OFFER_CURVE, p_TRANSACTION_ID, GA.INTERNAL_STATE, l_CUT_DATE, TG.g_TI_OFFER_PRICE, 1)),
			CONDENSE_AVAILABLE => MM_PJM_EMKT_UTIL.GET_IT_TRAIT_SCHEDULE(MM_PJM_UTIL.g_TG_SPIN_OFF_COND_AVAILABLE, p_TRANSACTION_ID, GA.INTERNAL_STATE, l_CUT_DATE),
			COND_STARTUP_COST => MM_PJM_EMKT_UTIL.GET_IT_TRAIT_SCHEDULE(MM_PJM_UTIL.g_TG_SPIN_OFF_COND_START_COST, p_TRANSACTION_ID, GA.INTERNAL_STATE, l_CUT_DATE),
			COND_ENERGY_USAGE => MM_PJM_EMKT_UTIL.GET_IT_TRAIT_SCHEDULE(MM_PJM_UTIL.g_TG_SPIN_OFF_COND_EN_USAGE, p_TRANSACTION_ID, GA.INTERNAL_STATE, l_CUT_DATE),
			COND_TO_GEN_COST => MM_PJM_EMKT_UTIL.GET_IT_TRAIT_SCHEDULE(MM_PJM_UTIL.g_TG_SPIN_OFF_COND_TO_GEN_COST, p_TRANSACTION_ID, GA.INTERNAL_STATE, l_CUT_DATE),
			SPIN_AS_CONDENSER => MM_PJM_EMKT_UTIL.GET_IT_TRAIT_SCHEDULE(MM_PJM_UTIL.g_TG_SPIN_OFF_SPIN_AS_COND, p_TRANSACTION_ID, GA.INTERNAL_STATE, l_CUT_DATE),
			FULL_LOAD_HR  => MM_PJM_EMKT_UTIL.GET_IT_TRAIT_SCHEDULE(MM_PJM_UTIL.g_TG_SPIN_OFF_FULL_LOAD_HR, p_TRANSACTION_ID, GA.INTERNAL_STATE, l_CUT_DATE),
			REDUCED_LOAD_HR => MM_PJM_EMKT_UTIL.GET_IT_TRAIT_SCHEDULE(MM_PJM_UTIL.g_TG_SPIN_OFF_REDUCED_LOAD_HR, p_TRANSACTION_ID, GA.INTERNAL_STATE, l_CUT_DATE),
			VOM_RATE => MM_PJM_EMKT_UTIL.GET_IT_TRAIT_SCHEDULE(MM_PJM_UTIL.g_TG_SPIN_OFF_VOM_RATE, p_TRANSACTION_ID, GA.INTERNAL_STATE, l_CUT_DATE)
			);

	IF v_RECORDS.COUNT > 0 THEN
		MEX_PJM_EMKT.GETX_SUBMIT_SPIN_OFFER(v_RECORDS, p_SUBMIT_XML, p_STATUS, p_ERROR_MESSAGE);
	END IF;

END GET_SUBMIT_SPIN_OFFER_XML;
-------------------------------------------------------------------------------------
PROCEDURE QUERY_REGULATION_OFFER
	(
	p_CRED			 IN mex_credentials,
	p_SCHEDULE_STATE IN NUMBER,
    p_REQUEST_DAY IN DATE,
	p_LOG_ONLY      IN NUMBER,
    p_STATUS OUT NUMBER,
    p_MESSAGE OUT VARCHAR2,
	p_LOGGER IN OUT mm_logger_adapter
    ) AS

	v_RECORDS MEX_PJM_EMKT_REG_OFFER_TBL;

BEGIN

	p_STATUS    := GA.SUCCESS;
	IF MM_PJM_UTIL.HAS_ESUITE_ACCESS(MM_PJM_EMKT_UTIL.g_EMKT_GEN_ATTR, p_CRED.EXTERNAL_ACCOUNT_NAME) THEN
		MEX_PJM_EMKT.FETCH_REGULATION_OFFER(p_CRED => p_CRED,
									   p_LOG_ONLY => p_LOG_ONLY,
									   p_LOCATION_TYPE => MEX_PJM_EMKT.g_LOC_TYPE_PORTFOLIO,
									   p_LOCATION_NAME => MM_PJM_EMKT_UTIL.GET_GEN_PORTFOLIO_NAME(p_CRED.EXTERNAL_ACCOUNT_NAME),
									   p_REQUEST_DATE => p_REQUEST_DAY,
									   p_RECORDS => v_RECORDS,
									   p_STATUS => p_STATUS,
									   p_MESSAGE => p_MESSAGE,
									   p_LOGGER => p_LOGGER);
		IF p_STATUS >= 0 THEN
			IMPORT_REGULATION_OFFER(p_SCHEDULE_STATE, p_CRED.EXTERNAL_ACCOUNT_NAME, v_RECORDS, p_STATUS, p_MESSAGE);
			IF p_SCHEDULE_STATE = 1 THEN
				IMPORT_REGULATION_OFFER(2, p_CRED.EXTERNAL_ACCOUNT_NAME, v_RECORDS, p_STATUS, p_MESSAGE);
			END IF;
		END IF;
	END IF;

    COMMIT;

EXCEPTION
    WHEN OTHERS THEN
    	p_STATUS        := SQLCODE;
    	p_MESSAGE := PACKAGE_NAME || '.QUERY_REGULATION_OFFER: ' || UT.GET_FULL_ERRM;

END QUERY_REGULATION_OFFER;
-------------------------------------------------------------------------------------
PROCEDURE GET_SUBMIT_REG_OFFER_XML
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_DATE  IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SUBMIT_XML OUT XMLTYPE,
	p_STATUS OUT NUMBER,
	p_ERROR_MESSAGE  OUT VARCHAR2
	) AS

	l_LOCATION SERVICE_POINT.EXTERNAL_IDENTIFIER%TYPE;
	l_XML_FRAGMENT XMLTYPE;
	l_CUT_DATE DATE := TRUNC(p_SCHEDULE_DATE) + 1/86400;
	v_RECORDS MEX_PJM_EMKT_REG_OFFER_TBL := MEX_PJM_EMKT_REG_OFFER_TBL();

BEGIN

	p_STATUS := MEX_UTIL.g_SUCCESS;
	l_LOCATION := GET_LOCATION_FOR_TXN_ID(p_TRANSACTION_ID);

	v_RECORDS.EXTEND();
	v_RECORDS(v_RECORDS.LAST) := MEX_PJM_EMKT_REG_OFFER(
            RESPONSE_DATE => l_CUT_DATE,
			LOCATION => l_LOCATION,
			QUANTITY => TO_NUMBER(MM_PJM_EMKT_UTIL.GET_IT_TRAIT_SCHEDULE(TG.g_TG_OFFER_CURVE, p_TRANSACTION_ID, GA.INTERNAL_STATE, l_CUT_DATE, TG.g_TI_OFFER_QUANTITY, 1)),
			PRICE => TO_NUMBER(MM_PJM_EMKT_UTIL.GET_IT_TRAIT_SCHEDULE(TG.g_TG_OFFER_CURVE, p_TRANSACTION_ID, GA.INTERNAL_STATE, l_CUT_DATE, TG.g_TI_OFFER_PRICE, 1)),
			UNAVAILABLE => MM_PJM_EMKT_UTIL.GET_IT_TRAIT_SCHEDULE(MM_PJM_UTIL.g_TG_REG_OFF_UNAVAILABLE, p_TRANSACTION_ID, GA.INTERNAL_STATE, l_CUT_DATE),
			SELF_SCHEDULED => MM_PJM_EMKT_UTIL.GET_IT_TRAIT_SCHEDULE(MM_PJM_UTIL.g_TG_REG_OFF_SELF_SCHEDULED, p_TRANSACTION_ID, GA.INTERNAL_STATE, l_CUT_DATE),
			MINIMUM_MW => TO_NUMBER(MM_PJM_EMKT_UTIL.GET_IT_TRAIT_SCHEDULE(MM_PJM_UTIL.g_TG_REG_OFF_MINIMUM_MW, p_TRANSACTION_ID, GA.INTERNAL_STATE, l_CUT_DATE))
			);

	IF v_RECORDS.COUNT > 0 THEN
		MEX_PJM_EMKT.GETX_SUBMIT_REG_OFFER(v_RECORDS, p_SUBMIT_XML, p_STATUS, p_ERROR_MESSAGE);
	END IF;

END GET_SUBMIT_REG_OFFER_XML;
-------------------------------------------------------------------------------------
PROCEDURE QUERY_SPIN_RESERVE_OFFER
	(
	p_CRED			 IN mex_credentials,
	p_SCHEDULE_STATE IN NUMBER,
    p_REQUEST_DAY IN DATE,
	p_LOG_ONLY      IN NUMBER,
    p_STATUS OUT NUMBER,
    p_MESSAGE OUT VARCHAR2,
	p_LOGGER IN OUT mm_logger_adapter
    ) AS

	v_RECORDS MEX_PJM_EMKT_SPIN_RES_OFF_TBL;

BEGIN
	p_STATUS    := GA.SUCCESS;

	IF MM_PJM_UTIL.HAS_ESUITE_ACCESS(MM_PJM_EMKT_UTIL.g_EMKT_GEN_ATTR, p_CRED.EXTERNAL_ACCOUNT_NAME) THEN

		MEX_PJM_EMKT.FETCH_SPIN_RESERVE_OFFER(p_CRED => p_CRED,
									   p_LOG_ONLY => p_LOG_ONLY,
									   p_LOCATION_TYPE => MEX_PJM_EMKT.g_LOC_TYPE_PORTFOLIO,
									   p_LOCATION_NAME => MM_PJM_EMKT_UTIL.GET_GEN_PORTFOLIO_NAME(p_CRED.EXTERNAL_ACCOUNT_NAME),
									   p_REQUEST_DATE => p_REQUEST_DAY,
									   p_RECORDS => v_RECORDS,
									   p_STATUS => p_STATUS,
									   p_MESSAGE => p_MESSAGE,
									   p_LOGGER => p_LOGGER);
		IF p_STATUS >= 0 THEN
			IMPORT_SPIN_RESERVE_OFFER(p_SCHEDULE_STATE, p_CRED.EXTERNAL_ACCOUNT_NAME, v_RECORDS, p_STATUS, p_MESSAGE);
			IF p_SCHEDULE_STATE = 1 THEN
				IMPORT_SPIN_RESERVE_OFFER(2, p_CRED.EXTERNAL_ACCOUNT_NAME, v_RECORDS, p_STATUS, p_MESSAGE);
			END IF;
		END IF;
	END IF;

    COMMIT;
END QUERY_SPIN_RESERVE_OFFER;
-------------------------------------------------------------------------------------
PROCEDURE IMPORT_UNIT_SCHEDULES
	(
	p_ACCOUNT_NAME IN VARCHAR2,
	p_RECORDS IN MEX_PJM_EMKT_UNIT_SCHED_TBL,
	p_STATUS OUT NUMBER,
	p_ERROR_MESSAGE OUT VARCHAR2
	) IS

	v_IDX BINARY_INTEGER;
	v_TRANSACTION_ID NUMBER;
	v_ALIAS INTERCHANGE_TRANSACTION.TRANSACTION_ALIAS%TYPE := '<<INITVAL>>';
	v_DESC INTERCHANGE_TRANSACTION.TRANSACTION_DESC%TYPE := '<<INITVAL>>';
BEGIN
	p_STATUS := GA.SUCCESS;

	IF p_RECORDS.COUNT = 0 THEN
		RETURN;
	END IF; -- nothing to do

	v_IDX := p_RECORDS.FIRST;

 	WHILE p_RECORDS.EXISTS(v_IDX) LOOP
		-- Get the Transaction ID, and create it if it does not exist.
		MM_PJM_EMKT_UTIL.GET_TRANSACTION_ID(p_ACCOUNT_NAME, p_RECORDS(v_IDX).LOCATION_NAME, 'Generation', MM_PJM_UTIL.g_COMM_DA_ENERGY, 0, 0, TRUE, v_TRANSACTION_ID, p_ERROR_MESSAGE, p_RECORDS(v_IDX).SCHEDULE_NUMBER, MM_PJM_EMKT_UTIL.g_PJM_GEN_SCHEDULE_TXN_TYPE, NULL);

		-- See if the Transaction's Alias and Description are different from the Schedule Name and Schedule Desc.
		SELECT TRANSACTION_ALIAS, TRANSACTION_DESC
		INTO v_ALIAS, v_DESC
		FROM INTERCHANGE_TRANSACTION
		WHERE TRANSACTION_ID = v_TRANSACTION_ID;

		-- Update alias and desc if they are different.
		IF NVL(v_ALIAS,'<<INITVAL>>') <> p_RECORDS(v_IDX).SCHEDULE_NAME OR
				NVL(v_DESC,'<<INITVAL>>') <> p_RECORDS(v_IDX).SCHEDULE_DESCRIPTION THEN
			UPDATE INTERCHANGE_TRANSACTION
			SET TRANSACTION_ALIAS = p_RECORDS(v_IDX).SCHEDULE_NAME,
				TRANSACTION_DESC = p_RECORDS(v_IDX).SCHEDULE_DESCRIPTION
			WHERE TRANSACTION_ID = v_TRANSACTION_ID;
		END IF;

		v_IDX := p_RECORDS.NEXT(v_IDX);
	END LOOP;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;
		p_ERROR_MESSAGE := PACKAGE_NAME || '.IMPORT_UNIT_SCHEDULES: ' || UT.GET_FULL_ERRM;

END IMPORT_UNIT_SCHEDULES;
-------------------------------------------------------------------------------------
PROCEDURE QUERY_UNIT_SCHEDULES
	(
	p_CRED			 IN mex_credentials,
	p_LOG_ONLY      IN NUMBER,
	p_STATUS OUT NUMBER,
	p_ERROR_MESSAGE OUT VARCHAR2,
	p_LOGGER IN OUT mm_logger_adapter
	) AS


	v_RECORDS MEX_PJM_EMKT_UNIT_SCHED_TBL;

BEGIN
	p_STATUS    := GA.SUCCESS;
	IF MM_PJM_UTIL.HAS_ESUITE_ACCESS(MM_PJM_EMKT_UTIL.g_EMKT_GEN_ATTR, p_CRED.EXTERNAL_ACCOUNT_NAME) THEN

		MEX_PJM_EMKT.FETCH_UNIT_SCHEDULES(p_CRED => p_CRED,
									   p_LOG_ONLY => p_LOG_ONLY,
									   p_LOCATION_TYPE => MEX_PJM_EMKT.g_LOC_TYPE_PORTFOLIO,
									   p_LOCATION_NAME => MM_PJM_EMKT_UTIL.GET_GEN_PORTFOLIO_NAME(p_CRED.EXTERNAL_ACCOUNT_NAME),
									   p_RECORDS => v_RECORDS,
									   p_STATUS => p_STATUS,
									   p_MESSAGE => p_ERROR_MESSAGE,
									   p_LOGGER => p_LOGGER);
		IF p_STATUS >= 0 THEN
			IMPORT_UNIT_SCHEDULES(p_CRED.EXTERNAL_ACCOUNT_NAME, v_RECORDS, p_STATUS, p_ERROR_MESSAGE);
		END IF;
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS        := SQLCODE;
		p_ERROR_MESSAGE := PACKAGE_NAME || '.QUERY_UNIT_SCHEDULES: ' || UT.GET_FULL_ERRM;

END QUERY_UNIT_SCHEDULES;
-------------------------------------------------------------------------------------
PROCEDURE GET_SUBMIT_UNIT_SCHEDULE_XML
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SUBMIT_XML OUT XMLTYPE,
	p_STATUS OUT NUMBER,
	p_ERROR_MESSAGE OUT VARCHAR2
	) AS

	l_LOCATION SERVICE_POINT.EXTERNAL_IDENTIFIER%TYPE;
	l_SCHEDULE_NUMBER NUMBER;

BEGIN

	p_STATUS := MEX_UTIL.g_SUCCESS;

	l_LOCATION := GET_LOCATION_FOR_TXN_ID(p_TRANSACTION_ID);
	l_SCHEDULE_NUMBER := GET_SCHED_NUM_FOR_TXN_ID(p_TRANSACTION_ID);

	-- It is much simpler to just get the xml here than packing into tables and sending to MEX.
	-- This is an experiment as to whether it makes sense to MEX-ify things.  In this case, no.
	SELECT XMLELEMENT("UnitSchedules",
		XMLATTRIBUTES(l_LOCATION AS "location"),
		XMLELEMENT("UnitSchedule",
			XMLATTRIBUTES(T.AGREEMENT_TYPE AS "schedule"),
			XMLELEMENT("ScheduleName", T.TRANSACTION_ALIAS),
			XMLELEMENT("ScheduleDescription", T.TRANSACTION_DESC)))
	INTO p_SUBMIT_XML
	FROM PJM_GEN_TXNS_BY_TYPE T
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

END GET_SUBMIT_UNIT_SCHEDULE_XML;
-------------------------------------------------------------------------------------
PROCEDURE IMPORT_REGULATION_UPDATE
	(
	p_SCHEDULE_STATE IN NUMBER,
	p_ACCOUNT_NAME IN VARCHAR2,
	p_RECORDS IN MEX_PJM_EMKT_REG_UPDATE_TBL,
	p_STATUS OUT NUMBER,
	p_ERROR_MESSAGE OUT VARCHAR2
	) IS

	v_IDX BINARY_INTEGER;
	v_TRANSACTION_ID NUMBER;
	v_UPDATE_HOUR DATE;
	v_SCHEDULE_STATE NUMBER(1) := p_SCHEDULE_STATE;

BEGIN
	p_STATUS := GA.SUCCESS;

	IF p_RECORDS.COUNT = 0 THEN
		RETURN;
	END IF; -- nothing to do

	-- loop over the response table, and update the traits for this resource
	v_IDX := p_RECORDS.FIRST;

	WHILE p_RECORDS.EXISTS(v_IDX) LOOP
		v_UPDATE_HOUR := p_RECORDS(v_IDX).RESPONSE_DATE;

		MM_PJM_EMKT_UTIL.GET_TRANSACTION_ID(p_ACCOUNT_NAME,
			p_RECORDS(v_IDX).LOCATION,
			'Generation',
			MM_PJM_UTIL.g_COMM_REGULATION,
			0,
			0,
			TRUE,
			v_TRANSACTION_ID,
			p_ERROR_MESSAGE,
			NULL,
			MM_PJM_EMKT_UTIL.g_PJM_GEN_REGULATION_TXN_TYPE,
			NULL);

		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, v_UPDATE_HOUR, MM_PJM_UTIL.g_TG_REG_UPD_MW, 1, 1, p_RECORDS(v_IDX).QUANTITY, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, v_UPDATE_HOUR, MM_PJM_UTIL.g_TG_REG_UPD_UNAVAILABLE, 1, 1, p_RECORDS(v_IDX).UNAVAILABLE, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, v_UPDATE_HOUR, MM_PJM_UTIL.g_TG_REG_UPD_SPILLING, 1, 1, p_RECORDS(v_IDX).SPILLING, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, v_UPDATE_HOUR, MM_PJM_UTIL.g_TG_REG_UPD_SELF_SCHEDULED, 1, 1, p_RECORDS(v_IDX).SELF_SCHEDULED, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, v_UPDATE_HOUR, MM_PJM_UTIL.g_TG_REG_UPD_MAX_MW, 1, 1, p_RECORDS(v_IDX).LIMIT_MAX_MW, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, v_UPDATE_HOUR, MM_PJM_UTIL.g_TG_REG_UPD_MIN_MW, 1, 1, p_RECORDS(v_IDX).LIMIT_MIN_MW, CUT_TIME_ZONE);

		v_IDX := p_RECORDS.NEXT(v_IDX);
	END LOOP;

END IMPORT_REGULATION_UPDATE;
-------------------------------------------------------------------------------------
PROCEDURE QUERY_REGULATION_UPDATE
	(
	p_CRED			 IN mex_credentials,
	p_SCHEDULE_STATE IN NUMBER,
    p_REQUEST_DAY IN DATE,
	p_LOG_ONLY      IN NUMBER,
    p_STATUS OUT NUMBER,
    p_MESSAGE OUT VARCHAR2,
	p_LOGGER IN OUT mm_logger_adapter
    ) AS

	v_RECORDS MEX_PJM_EMKT_REG_UPDATE_TBL;

BEGIN

	p_STATUS    := GA.SUCCESS;
	IF MM_PJM_UTIL.HAS_ESUITE_ACCESS(MM_PJM_EMKT_UTIL.g_EMKT_GEN_ATTR, p_CRED.EXTERNAL_ACCOUNT_NAME) THEN
		MEX_PJM_EMKT.FETCH_REGULATION_UPDATE(p_CRED => p_CRED,
									   p_LOG_ONLY => p_LOG_ONLY,
									   p_LOCATION_TYPE => MEX_PJM_EMKT.g_LOC_TYPE_PORTFOLIO,
									   p_LOCATION_NAME => MM_PJM_EMKT_UTIL.GET_GEN_PORTFOLIO_NAME(p_CRED.EXTERNAL_ACCOUNT_NAME),
									   p_REQUEST_DATE => p_REQUEST_DAY,
									   p_RECORDS => v_RECORDS,
									   p_STATUS => p_STATUS,
									   p_MESSAGE => p_MESSAGE,
									   p_LOGGER => p_LOGGER);

		IF p_STATUS >= 0 OR p_STATUS IS NULL THEN
			IMPORT_REGULATION_UPDATE(p_SCHEDULE_STATE, p_CRED.EXTERNAL_ACCOUNT_NAME, v_RECORDS, p_STATUS, p_MESSAGE);
			IF p_SCHEDULE_STATE = 1 THEN
				IMPORT_REGULATION_UPDATE(2, p_CRED.EXTERNAL_ACCOUNT_NAME, v_RECORDS, p_STATUS, p_MESSAGE);
			END IF;
		END IF;
	END IF;

END QUERY_REGULATION_UPDATE;
-------------------------------------------------------------------------------------
PROCEDURE GET_SUBMIT_REG_UPDATE_XML
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_DATE IN DATE,
    p_SUBMIT_HOURS IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_SUBMIT_XML OUT XMLTYPE,
	p_STATUS OUT NUMBER,
	p_ERROR_MESSAGE  OUT VARCHAR2
	) AS

	v_RECORDS MEX_PJM_EMKT_REG_UPDATE_TBL := MEX_PJM_EMKT_REG_UPDATE_TBL();
	l_LOCATION SERVICE_POINT.EXTERNAL_IDENTIFIER%TYPE;
	v_CURRENT_HOUR NUMBER(2);
    v_SCHEDULE_DATE DATE;
	v_INDEX BINARY_INTEGER;
	v_HOURS VARCHAR2(128);
	v_HOUR_STRING_TABLE GA.STRING_TABLE;
    v_IS_FALL_BACK BOOLEAN := FALSE;  
    v_NUM BINARY_INTEGER := 0;

BEGIN

	p_STATUS := MEX_UTIL.g_SUCCESS;
	l_LOCATION := GET_LOCATION_FOR_TXN_ID(p_TRANSACTION_ID);

	v_HOURS := REPLACE(p_SUBMIT_HOURS, '''', '');
	UT.TOKENS_FROM_STRING(v_HOURS, ',', v_HOUR_STRING_TABLE);
	v_INDEX := v_HOUR_STRING_TABLE.FIRST;
    
    IF TRUNC(DST_FALL_BACK_DATE(p_SCHEDULE_DATE)) = TRUNC(p_SCHEDULE_DATE) THEN
        v_IS_FALL_BACK := TRUE;
    END IF;       

	--LOOP OVER HOURS INCLUDED IN SUBMIT HOURS.
	LOOP        
        
        v_CURRENT_HOUR  := TO_NUMBER(v_HOUR_STRING_TABLE(v_INDEX));
        IF v_IS_FALL_BACK AND v_CURRENT_HOUR = 3 THEN
            v_CURRENT_HOUR := 2;           
            v_NUM := 1;
        ELSIF v_IS_FALL_BACK AND v_CURRENT_HOUR > 3 THEN
            v_CURRENT_HOUR := v_CURRENT_HOUR - 1;  
            v_NUM := 0;
        ELSE
           v_NUM := 0;     
        END IF;            
        
        v_SCHEDULE_DATE := TO_CUT_WITH_OPTIONS(p_SCHEDULE_DATE + v_CURRENT_HOUR / 24 + v_NUM/86400, 
                                                p_TIME_ZONE,
                                                MM_PJM_UTIL.g_DST_SPRING_AHEAD_OPTION);

		v_RECORDS.EXTEND();
		v_RECORDS(v_RECORDS.LAST) := MEX_PJM_EMKT_REG_UPDATE(
            RESPONSE_DATE => v_SCHEDULE_DATE,
			LOCATION => l_LOCATION,
			QUANTITY => MM_PJM_EMKT_UTIL.GET_IT_TRAIT_SCHEDULE(MM_PJM_UTIL.g_TG_REG_UPD_MW, p_TRANSACTION_ID, GA.INTERNAL_STATE, v_SCHEDULE_DATE),
			UNAVAILABLE => MM_PJM_EMKT_UTIL.GET_IT_TRAIT_SCHEDULE(MM_PJM_UTIL.g_TG_REG_UPD_UNAVAILABLE, p_TRANSACTION_ID, GA.INTERNAL_STATE, v_SCHEDULE_DATE),
			SPILLING => MM_PJM_EMKT_UTIL.GET_IT_TRAIT_SCHEDULE(MM_PJM_UTIL.g_TG_REG_UPD_SPILLING, p_TRANSACTION_ID, GA.INTERNAL_STATE, v_SCHEDULE_DATE),
			SELF_SCHEDULED => MM_PJM_EMKT_UTIL.GET_IT_TRAIT_SCHEDULE(MM_PJM_UTIL.g_TG_REG_UPD_SELF_SCHEDULED, p_TRANSACTION_ID, GA.INTERNAL_STATE, v_SCHEDULE_DATE),
			LIMIT_MAX_MW => MM_PJM_EMKT_UTIL.GET_IT_TRAIT_SCHEDULE(MM_PJM_UTIL.g_TG_REG_UPD_MAX_MW, p_TRANSACTION_ID, GA.INTERNAL_STATE, v_SCHEDULE_DATE),
			LIMIT_MIN_MW => MM_PJM_EMKT_UTIL.GET_IT_TRAIT_SCHEDULE(MM_PJM_UTIL.g_TG_REG_UPD_MIN_MW, p_TRANSACTION_ID, GA.INTERNAL_STATE, v_SCHEDULE_DATE)
			);

        EXIT WHEN v_INDEX = v_HOUR_STRING_TABLE.LAST;
		v_INDEX := v_HOUR_STRING_TABLE.NEXT(v_INDEX);
	END LOOP;

	IF v_RECORDS.COUNT > 0 THEN
		MEX_PJM_EMKT.GETX_SUBMIT_REG_UPDATE(v_RECORDS, p_SUBMIT_XML, p_STATUS, p_ERROR_MESSAGE);
	END IF;
END GET_SUBMIT_REG_UPDATE_XML;
-------------------------------------------------------------------------------------
PROCEDURE IMPORT_SPIN_RESERVE_UPDATE
	(
	p_SCHEDULE_STATE IN NUMBER,
	p_ACCOUNT_NAME IN VARCHAR2,
	p_RECORDS IN MEX_PJM_EMKT_SPIN_RES_UPD_TBL,
	p_STATUS OUT NUMBER,
	p_ERROR_MESSAGE OUT VARCHAR2
	) IS

	v_IDX BINARY_INTEGER;
	v_TRANSACTION_ID NUMBER;
	v_UPDATE_HOUR DATE;
	v_SCHEDULE_STATE NUMBER(1) := p_SCHEDULE_STATE;

BEGIN
	p_STATUS := GA.SUCCESS;

	IF p_RECORDS.COUNT = 0 THEN
		RETURN;
	END IF; -- nothing to do

	-- loop over the response table, and update the traits for this resource
	v_IDX := p_RECORDS.FIRST;

	WHILE p_RECORDS.EXISTS(v_IDX) LOOP
		v_UPDATE_HOUR := p_RECORDS(v_IDX).RESPONSE_DATE;

		MM_PJM_EMKT_UTIL.GET_TRANSACTION_ID(p_ACCOUNT_NAME,
			p_RECORDS(v_IDX).LOCATION,
			'Generation',
			MM_PJM_UTIL.g_COMM_SPIN_RES,
			0,
			0,
			TRUE,
			v_TRANSACTION_ID,
			p_ERROR_MESSAGE,
			NULL,
			MM_PJM_EMKT_UTIL.g_PJM_GEN_SPIN_RES_TXN_TYPE,
			'Tier2');

		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, v_UPDATE_HOUR, MM_PJM_UTIL.g_TG_SPIN_UPD_OFFER_MW, 1, 1, p_RECORDS(v_IDX).QUANTITY, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, v_UPDATE_HOUR, MM_PJM_UTIL.g_TG_SPIN_UPD_UNAVAILABLE, 1, 1, p_RECORDS(v_IDX).UNAVAILABLE, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, v_UPDATE_HOUR, MM_PJM_UTIL.g_TG_SPIN_UPD_SELF_SCHEDULED, 1, 1, p_RECORDS(v_IDX).SELF_SCHEDULED_MW, CUT_TIME_ZONE);
		TG.PUT_IT_TRAIT_SCHEDULE(v_TRANSACTION_ID, v_SCHEDULE_STATE, 0, v_UPDATE_HOUR, MM_PJM_UTIL.g_TG_SPIN_UPD_MAX_MW, 1, 1, p_RECORDS(v_IDX).SPIN_MAX_MW, CUT_TIME_ZONE);

		v_IDX := p_RECORDS.NEXT(v_IDX);
	END LOOP;

END IMPORT_SPIN_RESERVE_UPDATE;
-------------------------------------------------------------------------------------
PROCEDURE QUERY_SPIN_RESERVE_UPDATE
	(
	p_CRED			 IN mex_credentials,
	p_SCHEDULE_STATE IN NUMBER,
    p_REQUEST_DAY IN DATE,
	p_LOG_ONLY      IN NUMBER,
    p_STATUS OUT NUMBER,
    p_MESSAGE OUT VARCHAR2,
	p_LOGGER IN OUT mm_logger_adapter
    ) AS

	v_RECORDS MEX_PJM_EMKT_SPIN_RES_UPD_TBL;

BEGIN
	p_STATUS    := GA.SUCCESS;

	IF MM_PJM_UTIL.HAS_ESUITE_ACCESS(MM_PJM_EMKT_UTIL.g_EMKT_GEN_ATTR, p_CRED.EXTERNAL_ACCOUNT_NAME) THEN

		MEX_PJM_EMKT.FETCH_SPIN_RESERVE_UPDATE(p_CRED => p_CRED,
									   p_LOG_ONLY => p_LOG_ONLY,
									   p_LOCATION_TYPE => MEX_PJM_EMKT.g_LOC_TYPE_PORTFOLIO,
									   p_LOCATION_NAME => MM_PJM_EMKT_UTIL.GET_GEN_PORTFOLIO_NAME(p_CRED.EXTERNAL_ACCOUNT_NAME),
									   p_REQUEST_DATE => p_REQUEST_DAY,
									   p_RECORDS => v_RECORDS,
									   p_STATUS => p_STATUS,
									   p_MESSAGE => p_MESSAGE,
									   p_LOGGER => p_LOGGER);
		IF p_STATUS >= 0 OR p_STATUS IS NULL THEN
			IMPORT_SPIN_RESERVE_UPDATE(p_SCHEDULE_STATE, p_CRED.EXTERNAL_ACCOUNT_NAME, v_RECORDS, p_STATUS, p_MESSAGE);
			IF p_SCHEDULE_STATE = 1 THEN
				IMPORT_SPIN_RESERVE_UPDATE(2, p_CRED.EXTERNAL_ACCOUNT_NAME, v_RECORDS, p_STATUS, p_MESSAGE);
			END IF;
		END IF;
	END IF;

END QUERY_SPIN_RESERVE_UPDATE;
-------------------------------------------------------------------------------------

PROCEDURE GET_SUBMIT_SPIN_UPDATE_XML
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_DATE IN DATE,
    p_SUBMIT_HOURS IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_SUBMIT_XML OUT XMLTYPE,
	p_STATUS OUT NUMBER,
	p_ERROR_MESSAGE  OUT VARCHAR2
	) AS

	v_RECORDS MEX_PJM_EMKT_SPIN_RES_UPD_TBL := MEX_PJM_EMKT_SPIN_RES_UPD_TBL();
	l_LOCATION SERVICE_POINT.EXTERNAL_IDENTIFIER%TYPE;
	v_CURRENT_HOUR NUMBER(2);
    v_SCHEDULE_DATE DATE;
	v_INDEX BINARY_INTEGER;
	v_HOURS VARCHAR2(128);
	v_HOUR_STRING_TABLE GA.STRING_TABLE;

BEGIN

	p_STATUS := MEX_UTIL.g_SUCCESS;
	l_LOCATION := GET_LOCATION_FOR_TXN_ID(p_TRANSACTION_ID);

	v_HOURS := REPLACE(p_SUBMIT_HOURS, '''', '');
	UT.TOKENS_FROM_STRING(v_HOURS, ',', v_HOUR_STRING_TABLE);
	v_INDEX := v_HOUR_STRING_TABLE.FIRST;

	--LOOP OVER HOURS INCLUDED IN SUBMIT HOURS.
	LOOP
        v_CURRENT_HOUR  := TO_NUMBER(v_HOUR_STRING_TABLE(v_INDEX));
  		v_SCHEDULE_DATE := TO_CUT_WITH_OPTIONS(p_SCHEDULE_DATE + v_CURRENT_HOUR / 24,
                                                p_TIME_ZONE,
                                                MM_PJM_UTIL.g_DST_SPRING_AHEAD_OPTION);

		v_RECORDS.EXTEND();
		v_RECORDS(v_RECORDS.LAST) := MEX_PJM_EMKT_SPIN_RES_UPD(
            RESPONSE_DATE => v_SCHEDULE_DATE,
			LOCATION => l_LOCATION,
			QUANTITY => MM_PJM_EMKT_UTIL.GET_IT_TRAIT_SCHEDULE(MM_PJM_UTIL.g_TG_SPIN_UPD_OFFER_MW, p_TRANSACTION_ID, GA.INTERNAL_STATE, v_SCHEDULE_DATE),
			SPIN_MAX_MW => MM_PJM_EMKT_UTIL.GET_IT_TRAIT_SCHEDULE(MM_PJM_UTIL.g_TG_SPIN_UPD_MAX_MW, p_TRANSACTION_ID, GA.INTERNAL_STATE, v_SCHEDULE_DATE),
			UNAVAILABLE => MM_PJM_EMKT_UTIL.GET_IT_TRAIT_SCHEDULE(MM_PJM_UTIL.g_TG_SPIN_UPD_UNAVAILABLE, p_TRANSACTION_ID, GA.INTERNAL_STATE, v_SCHEDULE_DATE),
			SELF_SCHEDULED_MW => MM_PJM_EMKT_UTIL.GET_IT_TRAIT_SCHEDULE(MM_PJM_UTIL.g_TG_SPIN_UPD_SELF_SCHEDULED, p_TRANSACTION_ID, GA.INTERNAL_STATE, v_SCHEDULE_DATE)
			);

        EXIT WHEN v_INDEX = v_HOUR_STRING_TABLE.LAST;
		v_INDEX := v_HOUR_STRING_TABLE.NEXT(v_INDEX);
	END LOOP;

	IF v_RECORDS.COUNT > 0 THEN
		MEX_PJM_EMKT.GETX_SUBMIT_SPIN_UPDATE(v_RECORDS, p_SUBMIT_XML, p_STATUS, p_ERROR_MESSAGE);
	END IF;
END GET_SUBMIT_SPIN_UPDATE_XML;
-------------------------------------------------------------------------------------
PROCEDURE IMPORT_BY_TRANSACTION_ID
	(
	p_XML IN XMLTYPE,
	p_ACCOUNT_NAME IN VARCHAR2,
	p_TRANSACTION_ID IN NUMBER,
	p_ACTION IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_ERROR_MESSAGE OUT VARCHAR2
	) AS

	v_SCHED_OFFER_RECORDS MEX_PJM_EMKT_SCHED_OFFER_TBL := MEX_PJM_EMKT_SCHED_OFFER_TBL();
	v_SCHED_DETAIL_RECORDS MEX_PJM_EMKT_SCHED_DETAIL_TBL := MEX_PJM_EMKT_SCHED_DETAIL_TBL();
	v_SCHED_SEL_RECORDS MEX_PJM_EMKT_SCHED_SEL_TBL := MEX_PJM_EMKT_SCHED_SEL_TBL();
	v_UNIT_UPDATES_RECORDS MEX_PJM_EMKT_UNIT_UPDATES_TBL := MEX_PJM_EMKT_UNIT_UPDATES_TBL();
	v_UNIT_DETAIL_RECORDS MEX_PJM_EMKT_UNIT_DETAIL_TBL := MEX_PJM_EMKT_UNIT_DETAIL_TBL();
	v_REG_OFFER_RECORDS MEX_PJM_EMKT_REG_OFFER_TBL := MEX_PJM_EMKT_REG_OFFER_TBL();
	v_REG_UPDATE_RECORDS MEX_PJM_EMKT_REG_UPDATE_TBL := MEX_PJM_EMKT_REG_UPDATE_TBL();
	v_SPIN_OFFER_RECORDS MEX_PJM_EMKT_SPIN_RES_OFF_TBL := MEX_PJM_EMKT_SPIN_RES_OFF_TBL();
	v_SPIN_UPDATE_RECORDS MEX_PJM_EMKT_SPIN_RES_UPD_TBL := MEX_PJM_EMKT_SPIN_RES_UPD_TBL();
BEGIN
	p_STATUS := GA.SUCCESS;

	-- The response to a successful query by transaction is a message that
	-- contains exactly what was submitted by the transaction.
	CASE p_ACTION
			WHEN g_ET_SUBMIT_SCHED_OFFER THEN
				MEX_PJM_EMKT.PARSE_SCHEDULE_OFFER(p_XML,v_SCHED_OFFER_RECORDS, p_STATUS, p_ERROR_MESSAGE);
				IF p_STATUS = GA.SUCCESS THEN
					IMPORT_SCHEDULE_OFFER(GA.EXTERNAL_STATE, p_ACCOUNT_NAME, v_SCHED_OFFER_RECORDS, p_STATUS, p_ERROR_MESSAGE);
				END IF;
			WHEN g_ET_SUBMIT_SCHED_DETAIL THEN
				MEX_PJM_EMKT.PARSE_SCHEDULE_DETAIL(p_XML,v_SCHED_DETAIL_RECORDS, p_STATUS, p_ERROR_MESSAGE);
				IF p_STATUS = GA.SUCCESS THEN
					IMPORT_SCHEDULE_DETAIL(GA.EXTERNAL_STATE, p_ACCOUNT_NAME, v_SCHED_DETAIL_RECORDS, p_STATUS, p_ERROR_MESSAGE);
			   END IF;
			WHEN g_ET_SUBMIT_SCHED_SELECTION THEN
				MEX_PJM_EMKT.PARSE_SCHEDULE_SELECTION(p_XML,v_SCHED_SEL_RECORDS, p_STATUS, p_ERROR_MESSAGE);
				IF p_STATUS = GA.SUCCESS THEN
					IMPORT_SCHEDULE_SELECTION(GA.EXTERNAL_STATE, p_ACCOUNT_NAME, v_SCHED_SEL_RECORDS, p_STATUS, p_ERROR_MESSAGE);
			   END IF;
			WHEN g_ET_SUBMIT_UNIT_UPDATE THEN
				MEX_PJM_EMKT.PARSE_UNIT_UPDATES(p_XML,v_UNIT_UPDATES_RECORDS, p_STATUS, p_ERROR_MESSAGE);
				IF p_STATUS = GA.SUCCESS THEN
					IMPORT_UNIT_UPDATES(GA.EXTERNAL_STATE, p_ACCOUNT_NAME, v_UNIT_UPDATES_RECORDS, p_STATUS, p_ERROR_MESSAGE);
				END IF;
			WHEN g_ET_SUBMIT_UNIT_DETAIL THEN
				MEX_PJM_EMKT.PARSE_UNIT_DETAIL(p_XML, v_UNIT_DETAIL_RECORDS, p_STATUS, p_ERROR_MESSAGE);
				IF p_STATUS = GA.SUCCESS THEN
					IMPORT_UNIT_DETAIL(GA.EXTERNAL_STATE, p_ACCOUNT_NAME, v_UNIT_DETAIL_RECORDS, p_STATUS, p_ERROR_MESSAGE);
				END IF;
			WHEN g_ET_SUBMIT_UNIT_SCHEDULE THEN
				-- It is questionable whether we should import these after a submit, since there is no internal/external here.
				p_STATUS := GA.SUCCESS;
				--MEX_PJM_EMKT.PARSE_UNIT_SCHEDULES(p_XML, v_UNIT_SCHEDULE_RECORDS, p_STATUS, p_ERROR_MESSAGE);
				--IF p_STATUS = GA.SUCCESS THEN
				--	IMPORT_UNIT_SCHEDULES(p_EXTERNAL_CREDENTIAL, v_UNIT_SCHEDULE_RECORDS, p_STATUS, p_ERROR_MESSAGE);
				--END IF;

			WHEN g_ET_SUBMIT_SPIN_OFFER THEN
				MEX_PJM_EMKT.PARSE_SPIN_RESERVE_OFFER(p_XML, v_SPIN_OFFER_RECORDS, p_STATUS, p_ERROR_MESSAGE);
				IF p_STATUS = GA.SUCCESS THEN
					IMPORT_SPIN_RESERVE_OFFER(GA.EXTERNAL_STATE, p_ACCOUNT_NAME, v_SPIN_OFFER_RECORDS, p_STATUS, p_ERROR_MESSAGE);
				END IF;
			WHEN g_ET_SUBMIT_SPIN_UPDATE THEN
				MEX_PJM_EMKT.PARSE_SPIN_RESERVE_UPDATE(p_XML, v_SPIN_UPDATE_RECORDS, p_STATUS, p_ERROR_MESSAGE);
				IF p_STATUS = GA.SUCCESS THEN
					IMPORT_SPIN_RESERVE_UPDATE(GA.EXTERNAL_STATE, p_ACCOUNT_NAME, v_SPIN_UPDATE_RECORDS, p_STATUS, p_ERROR_MESSAGE);
				END IF;
			WHEN g_ET_SUBMIT_REG_OFFER THEN
				MEX_PJM_EMKT.PARSE_REGULATION_OFFER(p_XML, v_REG_OFFER_RECORDS, p_STATUS, p_ERROR_MESSAGE);
				IF p_STATUS = GA.SUCCESS THEN
					IMPORT_REGULATION_OFFER(GA.EXTERNAL_STATE, p_ACCOUNT_NAME, v_REG_OFFER_RECORDS, p_STATUS, p_ERROR_MESSAGE);
				END IF;
			WHEN g_ET_SUBMIT_REG_UPDATE THEN
				MEX_PJM_EMKT.PARSE_REGULATION_UPDATE(p_XML, v_REG_UPDATE_RECORDS, p_STATUS, p_ERROR_MESSAGE);
				IF p_STATUS = GA.SUCCESS THEN
					IMPORT_REGULATION_UPDATE(GA.EXTERNAL_STATE, p_ACCOUNT_NAME, v_REG_UPDATE_RECORDS, p_STATUS, p_ERROR_MESSAGE);
				END IF;
     END CASE;

	IF p_STATUS <> GA.SUCCESS THEN
		LOGS.LOG_WARN('Failed to query by transaction id:' || p_TRANSACTION_ID || ' for ' || p_ACTION);
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;
		p_ERROR_MESSAGE := PACKAGE_NAME || '.QUERY_BY_TRANSACTION_ID: ' || UT.GET_FULL_ERRM;
END IMPORT_BY_TRANSACTION_ID;
-------------------------------------------------------------------------------------
PROCEDURE GET_SUBMIT_XML
	(
	p_EXCHANGE_TYPE IN VARCHAR2,
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_DAY DATE,
	p_SUBMIT_HOURS IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_XML OUT XMLTYPE,
	p_SUBMIT_MODE OUT NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR2
	) AS

BEGIN

	CASE p_EXCHANGE_TYPE
		WHEN g_ET_SUBMIT_SCHED_OFFER THEN
			p_SUBMIT_MODE := MM_PJM_EMKT_UTIL.g_SUBMIT_MODE_DAILY;
			GET_SUBMIT_SCHEDULE_OFFER_XML(p_TRANSACTION_ID, p_SCHEDULE_DAY, p_TIME_ZONE, p_XML, p_STATUS, p_MESSAGE);
		WHEN g_ET_SUBMIT_SCHED_DETAIL THEN
			p_SUBMIT_MODE := MM_PJM_EMKT_UTIL.g_SUBMIT_MODE_DAILY;
			GET_SUBMIT_SCHEDULE_DETAIL_XML(p_TRANSACTION_ID, p_SCHEDULE_DAY, p_TIME_ZONE, p_XML, p_STATUS, p_MESSAGE);
		WHEN g_ET_SUBMIT_SCHED_SELECTION THEN
			p_SUBMIT_MODE := MM_PJM_EMKT_UTIL.g_SUBMIT_MODE_DAILY;
			GET_SUBMIT_SCHEDULE_SEL_XML(p_TRANSACTION_ID, p_SCHEDULE_DAY, p_TIME_ZONE, p_XML, p_STATUS, p_MESSAGE);
		WHEN g_ET_SUBMIT_UNIT_UPDATE THEN
			p_SUBMIT_MODE := MM_PJM_EMKT_UTIL.g_SUBMIT_MODE_SOME_HOURS;
			GET_SUBMIT_UNIT_UPDATE_XML(p_TRANSACTION_ID, p_SCHEDULE_DAY, p_SUBMIT_HOURS, p_TIME_ZONE, p_XML, p_STATUS, p_MESSAGE);
		WHEN g_ET_SUBMIT_UNIT_SCHEDULE THEN
			p_SUBMIT_MODE := MM_PJM_EMKT_UTIL.g_SUBMIT_MODE_DAILY;
			GET_SUBMIT_UNIT_SCHEDULE_XML(p_TRANSACTION_ID, p_XML, p_STATUS, p_MESSAGE);
 		WHEN g_ET_SUBMIT_UNIT_DETAIL THEN
			p_SUBMIT_MODE := MM_PJM_EMKT_UTIL.g_SUBMIT_MODE_DAILY;
 			GET_SUBMIT_UNIT_DETAIL_XML(p_TRANSACTION_ID, p_SCHEDULE_DAY, p_XML, p_STATUS, p_MESSAGE);
		WHEN g_ET_SUBMIT_SPIN_OFFER THEN
			p_SUBMIT_MODE := MM_PJM_EMKT_UTIL.g_SUBMIT_MODE_DAILY;
			GET_SUBMIT_SPIN_OFFER_XML(p_TRANSACTION_ID, p_SCHEDULE_DAY, p_TIME_ZONE, p_XML, p_STATUS, p_MESSAGE);
		WHEN g_ET_SUBMIT_SPIN_UPDATE THEN
			p_SUBMIT_MODE := MM_PJM_EMKT_UTIL.g_SUBMIT_MODE_SOME_HOURS;
			GET_SUBMIT_SPIN_UPDATE_XML(p_TRANSACTION_ID, p_SCHEDULE_DAY, p_SUBMIT_HOURS, p_TIME_ZONE, p_XML, p_STATUS, p_MESSAGE);
		WHEN g_ET_SUBMIT_REG_OFFER THEN
			p_SUBMIT_MODE := MM_PJM_EMKT_UTIL.g_SUBMIT_MODE_DAILY;
			GET_SUBMIT_REG_OFFER_XML(p_TRANSACTION_ID, p_SCHEDULE_DAY, p_TIME_ZONE, p_XML, p_STATUS, p_MESSAGE);
		WHEN g_ET_SUBMIT_REG_UPDATE THEN
			p_SUBMIT_MODE := MM_PJM_EMKT_UTIL.g_SUBMIT_MODE_SOME_HOURS;
			GET_SUBMIT_REG_UPDATE_XML(p_TRANSACTION_ID, p_SCHEDULE_DAY, p_SUBMIT_HOURS, p_TIME_ZONE, p_XML, p_STATUS, p_MESSAGE);
	ELSE
		p_MESSAGE := 'Action ' || p_EXCHANGE_TYPE || ' has not been defined in MM_PJM_EMKT_GEN.';
	END CASE;
EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;
		p_MESSAGE := PACKAGE_NAME || '.GET_SUBMIT_XML: ' || UT.GET_FULL_ERRM;
END GET_SUBMIT_XML;
-------------------------------------------------------------------------------------

END MM_PJM_EMKT_GEN;
/
