CREATE OR REPLACE PACKAGE BODY MM_SEM AS

----------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
    RETURN '$Revision: 1.11 $';
END WHAT_VERSION;
----------------------------------------------------------------------------------------
/*----------------------------------------------------------------------------*
*   GET_TRAITS_FOR_TRANSACTION                                                *
*----------------------------------------------------------------------------*/
PROCEDURE GET_TRAITS_FOR_TRANSACTION
(
	p_TRANSACTION_ID     IN NUMBER,
	p_REPORT_TYPE        IN VARCHAR2,
	p_TRAIT_GROUP_FILTER IN VARCHAR2,
	p_INTERVAL           IN VARCHAR2,
	p_WORK_ID            OUT NUMBER
) IS
	v_TRANSACTION INTERCHANGE_TRANSACTION%ROWTYPE;
BEGIN
	UT.GET_RTO_WORK_ID(p_WORK_ID);

	SELECT *
	INTO   v_TRANSACTION
	FROM   INTERCHANGE_TRANSACTION
	WHERE  TRANSACTION_ID = p_TRANSACTION_ID;

	INSERT INTO RTO_WORK
		(WORK_ID, WORK_SEQ, WORK_XID)
		SELECT p_WORK_ID, B.TRAIT_INDEX, A.TRAIT_GROUP_ID
		FROM   TRANSACTION_TRAIT_GROUP A, TRANSACTION_TRAIT B
		WHERE  (A.SC_ID = -1 OR A.SC_ID = v_TRANSACTION.SC_ID)
			AND (A.TRAIT_CATEGORY = '%' OR INSTR(A.TRAIT_CATEGORY, v_TRANSACTION.TRANSACTION_TYPE) > 0)
			AND (A.TRAIT_GROUP_TYPE = '%' OR A.TRAIT_GROUP_TYPE LIKE p_TRAIT_GROUP_FILTER)
			AND B.TRAIT_GROUP_ID = A.TRAIT_GROUP_ID
			AND B.TRAIT_GROUP_ID != TG.g_TG_RAMP_CURVE
			AND (NVL(v_TRANSACTION.TRANSACTION_TYPE, 'Load') != 'SRA' OR B.TRAIT_GROUP_ID != TG.g_TG_OFFER_CURVE);

END GET_TRAITS_FOR_TRANSACTION;
----------------------------------------------------------------------------------------
/*----------------------------------------------------------------------------*
*   GET_BID_OFFER_INTERVAL                                                    *
*----------------------------------------------------------------------------*/
FUNCTION GET_BID_OFFER_INTERVAL(p_TRANSACTION IN INTERCHANGE_TRANSACTION%ROWTYPE)
	RETURN VARCHAR2 IS
	v_RETURN VARCHAR2(12);
BEGIN
	BEGIN
		v_RETURN := g_INTERVAL_TBL(p_TRANSACTION.TRANSACTION_TYPE);
	EXCEPTION
		-- By default pass 'Day' and not raise the error.
		WHEN NO_DATA_FOUND THEN
			v_RETURN := g_INTERVAL_TBL(k_DEFAULT);
	END;
	RETURN v_RETURN;
END GET_BID_OFFER_INTERVAL;
----------------------------------------------------------------------------------------
PROCEDURE GET_AFFECTED_DATE_RANGE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_CUT_DATE IN OUT DATE,
	p_IS_SUB_DAILY IN BOOLEAN,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE
	) AS
v_TRANSACTION_ROW INTERCHANGE_TRANSACTION%ROWTYPE;
v_INTERVAL NUMBER;
v_LOCAL_DATE DATE := FROM_CUT(p_CUT_DATE, MM_SEM_UTIL.g_TZ)-6/24; -- trading day starts at 6:00
BEGIN
    SELECT * INTO v_TRANSACTION_ROW
    FROM INTERCHANGE_TRANSACTION
    WHERE TRANSACTION_ID = p_TRANSACTION_ID;

    v_INTERVAL := GET_INTERVAL_NUMBER(GET_BID_OFFER_INTERVAL(v_TRANSACTION_ROW));

    IF v_INTERVAL = GET_INTERVAL_NUMBER('DD') THEN
		IF p_IS_SUB_DAILY THEN
       		p_CUT_DATE := TRUNC(v_LOCAL_DATE-1/86400)+1/86400;
		END IF;
		p_BEGIN_DATE := p_CUT_DATE;
		p_END_DATE := p_CUT_DATE;
    ELSE -- 30 minute
        IF p_IS_SUB_DAILY THEN
			p_BEGIN_DATE := p_CUT_DATE;
       		p_END_DATE := p_CUT_DATE;
        ELSE
			MM_SEM_UTIL.OFFER_DATE_RANGE(v_LOCAL_DATE-1/86400, p_BEGIN_DATE, p_END_DATE);
        END IF;
    END IF;
END GET_AFFECTED_DATE_RANGE;
----------------------------------------------------------------------------------------
FUNCTION TRAIT_AFFECTS_STATUS
	(
	p_TRANSACTION_ID IN NUMBER,
	p_TRAIT_GROUP_ID IN NUMBER,
	p_TRAIT_INDEX IN NUMBER
	) RETURN BOOLEAN IS
BEGIN
	IF p_TRAIT_GROUP_ID = MM_SEM_UTIL.g_TG_SEM_TXN_ID
	   OR p_TRAIT_GROUP_ID = MM_SEM_UTIL.g_TG_SRA_VALIDITY_STATUS
	   	OR p_TRAIT_GROUP_ID = MM_SEM_UTIL.g_TG_EXT_IDENT THEN
		RETURN FALSE;
	ELSE
		RETURN TRUE;
	END IF;
END TRAIT_AFFECTS_STATUS;
----------------------------------------------------------------------------------------
PROCEDURE GET_TRAITS_FOR_OFFER_MGT_GEN
(
	p_MODULE	IN	VARCHAR2,
	p_KEY1		IN	VARCHAR2,
	p_KEY2		IN	VARCHAR2,
	p_KEY3		IN	VARCHAR2,
	p_WORK_ID  OUT	NUMBER
) AS
BEGIN
	-- Populate RTO_WORK with the Trait Groups defined as System Labels.
	-- System Label also defines the order and number of times they should appear in the grid.
	UT.GET_RTO_WORK_ID(p_WORK_ID);

	FOR v_CURSOR IN (SELECT SL.*
					   FROM SYSTEM_LABEL SL
					  WHERE SL.MODEL_ID 	= CONSTANTS.GLOBAL_MODEL
						AND MODULE			= p_MODULE
						AND SL.KEY1			= p_KEY1
						AND SL.KEY2			= p_KEY2
						AND SL.KEY3			= p_KEY3
					 ORDER BY SL.POSITION
					 ) LOOP
		FOR v_IDX IN 1..NVL(v_CURSOR.CODE, 1) LOOP
			INSERT INTO RTO_WORK
				(
				 WORK_ID,
				 WORK_SEQ,
				 WORK_XID,
				 WORK_DATA
				)
			VALUES
				(p_WORK_ID,
				 (v_CURSOR.POSITION * 100000) + (v_IDX - 1) * 100,
				 EI.GET_ID_FROM_NAME(v_CURSOR.VALUE, EC.ED_TRANSACTION_TRAIT_GROUP),
				 v_IDX
				);
		END LOOP;
	END LOOP;
END GET_TRAITS_FOR_OFFER_MGT_GEN;
----------------------------------------------------------------------------------------
PROCEDURE GET_OFF_MGT_GEN_VERIFY_ACT
	(
	p_GENERATOR_IDS			IN	NUMBER_COLLECTION,
	p_GATE_WINDOW_IDS		IN	NUMBER_COLLECTION,
	p_ALL_WINDOW_TYPES		IN	NUMBER,
	p_ALL_GENERATORS		IN	NUMBER,
	p_TRANSACTION_IDS	   OUT	NUMBER_COLLECTION
	) AS
BEGIN
	p_TRANSACTION_IDS := NUMBER_COLLECTION();

	FOR v_CURSOR IN(WITH STATEMENT_TYPES AS
						(SELECT ESI.EXTERNAL_IDENTIFIER		AS STATEMENT_TYPE_IDENT,
								STY.STATEMENT_TYPE_ID		AS STATEMENT_TYPE_ID,
								STY.STATEMENT_TYPE_ORDER	AS STATEMENT_TYPE_ORDER
						   FROM EXTERNAL_SYSTEM_IDENTIFIER	ESI,
								STATEMENT_TYPE				STY,
								TABLE(CAST(p_GATE_WINDOW_IDS AS NUMBER_COLLECTION)) GATE_IDS
						  WHERE STY.STATEMENT_TYPE_ID		= ESI.ENTITY_ID
							AND (GATE_IDS.COLUMN_VALUE		= STY.STATEMENT_TYPE_ID OR p_ALL_WINDOW_TYPES = CONSTANTS.ALL_ID)
							AND ESI.IDENTIFIER_TYPE			= MM_SEM_UTIL.g_STATEMENT_TYPE_GATE_WINDOW
							AND ESI.ENTITY_DOMAIN_ID 		= EC.ED_STATEMENT_TYPE
							AND ESI.EXTERNAL_SYSTEM_ID		= EC.ES_SEM
						)
						SELECT DISTINCT IT.TRANSACTION_ID
						   FROM SERVICE_POINT SVC,
								INTERCHANGE_TRANSACTION IT,
								SCHEDULE_COORDINATOR SC,
								INTERCHANGE_CONTRACT IC,
								IT_COMMODITY ITC,
								EXTERNAL_SYSTEM_IDENTIFIER ESI,
							    TABLE(CAST(p_GENERATOR_IDS AS NUMBER_COLLECTION)) GEN_IDS,
							    STATEMENT_TYPES STY
						  WHERE SVC.SERVICE_POINT_ID 	= IT.POD_ID
							AND IT.IS_BID_OFFER 		= 1
							AND IT.TRANSACTION_TYPE 	= MM_SEM_UTIL.c_TXN_TYPE_GENERATION
							AND (IT.AGREEMENT_TYPE IS NOT NULL AND IT.AGREEMENT_TYPE <> CONSTANTS.UNDEFINED_ATTRIBUTE)
							AND IT.SC_ID 	= SC.SC_ID
							AND SC.SC_NAME = 'SEM'
							AND IT.COMMODITY_ID 		= ITC.COMMODITY_ID
							AND ITC.COMMODITY_ALIAS 	= MM_SEM_UTIL.c_COMMODITY_ENERGY
							AND IT.TRANSACTION_INTERVAL = DATE_UTIL.c_NAME_30MIN
							AND EXISTS(SELECT 1
									  	 FROM EXTERNAL_SYSTEM_IDENTIFIER E
										WHERE IC.CONTRACT_ID = E.ENTITY_ID
										  AND E.EXTERNAL_SYSTEM_ID = EC.ES_SEM
										  AND E.ENTITY_DOMAIN_ID = EC.ED_INTERCHANGE_CONTRACT
										  AND E.EXTERNAL_IDENTIFIER IS NOT NULL
									  )
							AND SVC.SERVICE_POINT_ID 	= ESI.ENTITY_ID
							AND (GEN_IDS.COLUMN_VALUE	= SVC.SERVICE_POINT_ID OR p_ALL_GENERATORS = CONSTANTS.ALL_ID)
							AND ESI.ENTITY_DOMAIN_ID 	= EC.ED_SERVICE_POINT
							AND ESI.EXTERNAL_SYSTEM_ID 	= EC.ES_SEM
						   AND ESI.EXTERNAL_IDENTIFIER LIKE 'GU_%'
						   AND IT.AGREEMENT_TYPE		= STY.STATEMENT_TYPE_IDENT) LOOP
		SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_TXN_SELECT, v_CURSOR.TRANSACTION_ID, EC.ED_TRANSACTION);
		p_TRANSACTION_IDS.EXTEND;
		p_TRANSACTION_IDS(p_TRANSACTION_IDS.COUNT) := v_CURSOR.TRANSACTION_ID;
	END LOOP;
END GET_OFF_MGT_GEN_VERIFY_ACT;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_IT_TRAIT_OFFER_MGT_GEN
	(
	p_BEGIN_DATE			IN	DATE,
	p_END_DATE				IN	DATE,
	p_TIME_ZONE 			IN	VARCHAR2,
	p_GENERATOR_IDS			IN	NUMBER_COLLECTION,
	p_GATE_WINDOW_IDS		IN	NUMBER_COLLECTION,
	p_STATUS			   OUT	NUMBER,
	p_CURSOR			   OUT	GA.REFCURSOR
	) AS
	v_WORK_ID			NUMBER(9);
	v_ALL_ID			NUMBER_COLLECTION := NUMBER_COLLECTION(CONSTANTS.ALL_ID);
	v_RESULT			NUMBER_COLLECTION := NUMBER_COLLECTION();
	v_ALL_WINDOW_TYPES	NUMBER(9);
	v_ALL_GENERATORS	NUMBER(9);
	v_TRANSACTION_IDS	NUMBER_COLLECTION;
	c_MODULE			CONSTANT VARCHAR2(14)	:= 'MarketExchange';
	c_KEY1				CONSTANT VARCHAR2(3)	:= 'SEM';
	c_KEY2				CONSTANT VARCHAR2(16)	:= 'Offer Management';
	c_KEY3				CONSTANT VARCHAR2(18)	:= 'Generator COD';
BEGIN
	-- Check if <All> is part of the Generator selections made in the filter.
	v_RESULT := v_ALL_ID MULTISET INTERSECT p_GENERATOR_IDS;
	v_ALL_GENERATORS := CASE WHEN (v_RESULT.COUNT > 0) THEN CONSTANTS.ALL_ID ELSE 0 END;

	-- Check if <All> is part of the Gate Window selections made in the filter.
	v_RESULT := v_ALL_ID MULTISET INTERSECT p_GATE_WINDOW_IDS;
	v_ALL_WINDOW_TYPES := CASE WHEN (v_RESULT.COUNT > 0) THEN CONSTANTS.ALL_ID ELSE 0 END;

	-- For each Transaction ID that meets the filter criteria, check if there is "select" privilege.
	GET_OFF_MGT_GEN_VERIFY_ACT(p_GENERATOR_IDS		=>	p_GENERATOR_IDS,
							   p_GATE_WINDOW_IDS	=>	p_GATE_WINDOW_IDS,
							   p_ALL_WINDOW_TYPES	=>	v_ALL_WINDOW_TYPES,
							   p_ALL_GENERATORS		=>	v_ALL_GENERATORS,
							   p_TRANSACTION_IDS	=>	v_TRANSACTION_IDS
							  );

	-- Populate RTO_WORK with the Trait Groups defined as System Labels.
	-- System Label also defines the order and number of times they should appear in the grid.
	MM_SEM.GET_TRAITS_FOR_OFFER_MGT_GEN(c_MODULE, c_KEY1, c_KEY2, c_KEY3, v_WORK_ID);

    -- Make sure we have data in the SYSTEM_DATE_TIME table.  Return an error if not.
	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, p_BEGIN_DATE, p_END_DATE);

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		WITH STATEMENT_TYPES AS
			  -- Fetch the Statement Types that match the filter criteria
						(SELECT ESI.EXTERNAL_IDENTIFIER		AS STATEMENT_TYPE_IDENT,
								STY.STATEMENT_TYPE_ID		AS STATEMENT_TYPE_ID,
								STY.STATEMENT_TYPE_ORDER	AS STATEMENT_TYPE_ORDER
						   FROM EXTERNAL_SYSTEM_IDENTIFIER	ESI,
								STATEMENT_TYPE				STY,
								TABLE(CAST(p_GATE_WINDOW_IDS AS NUMBER_COLLECTION)) GATE_IDS
						  WHERE STY.STATEMENT_TYPE_ID		= ESI.ENTITY_ID
							AND (GATE_IDS.COLUMN_VALUE		= STY.STATEMENT_TYPE_ID OR v_ALL_WINDOW_TYPES = CONSTANTS.ALL_ID)
							AND ESI.IDENTIFIER_TYPE			= MM_SEM_UTIL.g_STATEMENT_TYPE_GATE_WINDOW
							AND ESI.ENTITY_DOMAIN_ID 		= EC.ED_STATEMENT_TYPE
							AND ESI.EXTERNAL_SYSTEM_ID		= EC.ES_SEM
						)
		SELECT A.GENERATOR				AS GENERATOR,
			   A.GATE_WINDOW			AS GATE_WINDOW,
			   A.TRAIT_ORDER			AS TRAIT_ORDER,
			   CASE A.IS_SERIES
             	   WHEN 0 THEN
            			A.TRAIT_DISPLAY_NAME
          		   ELSE
            			A.TRAIT_DISPLAY_NAME || ' ' || NVL(A.SET_NUMBER,1)
          		   END         			AS TRAIT_GROUP,
			   SUBSTR(TO_CHAR(A.CUT_DATE_SCHEDULING, MM_SEM_UTIL.g_DATE_FORMAT),1,10)  AS DISPLAY_DATE,
			   TG.TO_CHAR_TRAIT_VAL(ITS.TRAIT_VAL,A.DATA_TYPE)	AS TRAIT_VAL,
			   A.TRANSACTION_ID			AS TRANSACTION_ID,
			   A.TRAIT_GROUP_ID 		AS TRAIT_GROUP_ID,
			   A.CUT_DATE_SCHEDULING 	AS CUT_DATE_SCHEDULING,
			   1 						AS SCHEDULE_STATE,
			   A.TRAIT_INDEX			AS TRAIT_INDEX,
			   A.SET_NUMBER				AS SET_NUMBER,
			   0 						AS STATEMENT_TYPE_ID,
			   A.STATEMENT_TYPE_ORDER	AS STATEMENT_TYPE_ORDER
		  -- Fetch the Trait Groups and their Attributes that match the filter criteria
		  FROM (SELECT SDT.CUT_DATE_SCHEDULING	AS CUT_DATE_SCHEDULING,
		  			   TTG.DISPLAY_NAME 		AS GROUP_DISPLAY_NAME,
					   TTG.DISPLAY_ORDER 		AS GROUP_ORDER,
					   TTG.TRAIT_GROUP_ID,
					   TTG.IS_STATEMENT_TYPE_SPECIFIC,
					   TTG.IS_SERIES,
					   TTA.TRAIT_INDEX,
					   TTA.DISPLAY_NAME			AS TRAIT_DISPLAY_NAME,
					   RW.WORK_SEQ + TTA.DISPLAY_ORDER	AS TRAIT_ORDER,
					   TO_NUMBER(RW.WORK_DATA)	AS SET_NUMBER,
					   TTA.DATA_TYPE,
					   TTA.EDIT_MASK,
					   TTA.COMBO_LIST,
					   TTA.FORMAT,
					   TTA.AFTER_EDIT,
					   IT.TRANSACTION_ID,
					   EI.GET_ENTITY_IDENTIFIER_EXTSYS(EC.ED_SERVICE_POINT, SP.SERVICE_POINT_ID, EC.ES_SEM)	AS GENERATOR,
					   IT.AGREEMENT_TYPE		AS GATE_WINDOW,
					   STY.STATEMENT_TYPE_ORDER	AS STATEMENT_TYPE_ORDER
				  FROM INTERCHANGE_TRANSACTION 		IT,
					   TRANSACTION_TRAIT_GROUP		TTG,
					   TRANSACTION_TRAIT_ATTRIBUTES	TTA,
					   SERVICE_POINT				SP,
					   SYSTEM_DATE_TIME				SDT,
					   RTO_WORK						RW,
					   STATEMENT_TYPES				STY,
					   TABLE(CAST(v_TRANSACTION_IDS AS NUMBER_COLLECTION))	TRANSACTION_IDS
				 WHERE RW.WORK_ID 				= v_WORK_ID
				   AND TTG.TRAIT_GROUP_ID		= RW.WORK_XID
				   AND TTA.TRAIT_GROUP_ID 		= TTG.TRAIT_GROUP_ID
				   AND SP.SERVICE_POINT_ID 		= IT.POD_ID
				   AND STY.STATEMENT_TYPE_IDENT	= IT.AGREEMENT_TYPE
				   AND IT.TRANSACTION_ID		= TRANSACTION_IDS.COLUMN_VALUE
				   AND IT.AGREEMENT_TYPE IS NOT NULL
				   AND TTG.IS_SPARSE			= 0
				   AND SDT.TIME_ZONE			= p_TIME_ZONE
				   AND SDT.DATA_INTERVAL_TYPE 	= 2
				   AND SDT.DAY_TYPE				= 1
				   AND SDT.LOCAL_DAY_TRUNC_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE) A,
			   IT_TRAIT_SCHEDULE	ITS
		 -- Fetch the values for the Trait Attributes.
		 -- The outer join is to fetch values for all Attributes for all days, irrespective of them having any values.
		 WHERE ITS.TRAIT_GROUP_ID(+) 	= A.TRAIT_GROUP_ID
		   AND ITS.TRANSACTION_ID(+) 	= A.TRANSACTION_ID
		   AND ITS.SCHEDULE_DATE(+) 	= A.CUT_DATE_SCHEDULING
		   AND ITS.TRAIT_INDEX(+) 		= A.TRAIT_INDEX
		   AND ITS.SET_NUMBER(+)		= A.SET_NUMBER
		   AND ITS.STATEMENT_TYPE_ID(+) = 0
		   AND ITS.SCHEDULE_STATE(+)	= 1
		ORDER BY A.TRANSACTION_ID, A.TRAIT_ORDER, A.TRAIT_INDEX, A.CUT_DATE_SCHEDULING;

		-- RTO_WORK is used through out the product and it is good idea to purge the table
		-- to avoid interference with other areas of the code.
		UT.PURGE_RTO_WORK(v_WORK_ID);
END GET_IT_TRAIT_OFFER_MGT_GEN;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_IT_TRAIT_OFFER_MGT_DET_GEN
	(
	p_TRANSACTION_ID		IN	NUMBER,
	p_CUT_DATE_SCHEDULING	IN	DATE,
	p_TIME_ZONE 			IN	VARCHAR2,
	p_STATUS			   OUT	NUMBER,
	p_CURSOR			   OUT	GA.REFCURSOR
	) AS
BEGIN
	TG.GET_IT_TRAIT_SCHED_TRAIT_RPT(p_TRANSACTION_ID		=>	p_TRANSACTION_ID,
									p_SCHEDULE_STATE		=>	1,
									p_SCHEDULE_TYPE			=>	0,
									p_REPORT_TYPE			=>	NULL,
									p_TRAIT_GROUP_FILTER	=>	NULL,
									p_BEGIN_DATE			=>	TRUNC(p_CUT_DATE_SCHEDULING),
									p_END_DATE				=>	TRUNC(p_CUT_DATE_SCHEDULING),
									p_DATE_OFFSET			=>	0,
									p_INTERVAL				=>	DATE_UTIL.c_NAME_30MIN,
									p_TIME_ZONE				=>	p_TIME_ZONE,
									p_STATUS				=>	p_STATUS,
									p_CURSOR				=>	p_CURSOR,
									p_TRADING_DATE_OFFSET	=>	MM_SEM_UTIL.g_TRADE_DAY_HOUR_SHIFT/24);
END GET_IT_TRAIT_OFFER_MGT_DET_GEN;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_OFF_MGT_IU_VERIFY_ACT
	(
	p_INTERCONNECTOR_IDS	IN	NUMBER_COLLECTION,
	p_GATE_WINDOW_IDS		IN	NUMBER_COLLECTION,
	p_ALL_WINDOW_TYPES		IN	NUMBER,
	p_ALL_INTERCONNECTORS	IN	NUMBER,
	p_TRANSACTION_IDS	   OUT	NUMBER_COLLECTION
	) AS
BEGIN
	p_TRANSACTION_IDS := NUMBER_COLLECTION();

	FOR v_CURSOR IN(WITH STATEMENT_TYPES AS
						(SELECT ESI.EXTERNAL_IDENTIFIER	AS STATEMENT_TYPE_IDENT,
								STY.STATEMENT_TYPE_ID		AS STATEMENT_TYPE_ID,
								STY.STATEMENT_TYPE_ORDER	AS STATEMENT_TYPE_ORDER
						   FROM EXTERNAL_SYSTEM_IDENTIFIER	ESI,
								STATEMENT_TYPE				STY,
								TABLE(CAST(p_GATE_WINDOW_IDS AS NUMBER_COLLECTION)) GATE_IDS
						  WHERE STY.STATEMENT_TYPE_ID		= ESI.ENTITY_ID
							AND (GATE_IDS.COLUMN_VALUE		= STY.STATEMENT_TYPE_ID OR p_ALL_WINDOW_TYPES = CONSTANTS.ALL_ID)
							AND ESI.IDENTIFIER_TYPE			= MM_SEM_UTIL.g_STATEMENT_TYPE_GATE_WINDOW
							AND ESI.ENTITY_DOMAIN_ID 		= EC.ED_STATEMENT_TYPE
							AND ESI.EXTERNAL_SYSTEM_ID		= EC.ES_SEM
						)
						SELECT DISTINCT IT.TRANSACTION_ID    AS TRANSACTION_ID
						   FROM SERVICE_POINT SVC,
								INTERCHANGE_TRANSACTION IT,
								SCHEDULE_COORDINATOR SC,
								INTERCHANGE_CONTRACT IC,
								IT_COMMODITY ITC,
								EXTERNAL_SYSTEM_IDENTIFIER ESI_POD,
								EXTERNAL_SYSTEM_IDENTIFIER ESI_IC,
							    TABLE(CAST(p_INTERCONNECTOR_IDS AS NUMBER_COLLECTION)) INTERCONNECTOR_IDS,
							    STATEMENT_TYPES				STY
						  WHERE SVC.SERVICE_POINT_ID 		= IT.POD_ID
						   AND (INTERCONNECTOR_IDS.COLUMN_VALUE	= ESI_POD.ENTITY_ID
								OR p_ALL_INTERCONNECTORS = CONSTANTS.ALL_ID)
							AND IT.IS_BID_OFFER 			= 1
							AND IT.TRANSACTION_TYPE			= MM_SEM_UTIL.c_TXN_TYPE_NOMINATION
							AND (IT.AGREEMENT_TYPE IS NOT NULL AND IT.AGREEMENT_TYPE <> CONSTANTS.UNDEFINED_ATTRIBUTE)
							AND IT.SC_ID					= SC.SC_ID
							AND SC.SC_NAME					= 'SEM'
							AND IT.COMMODITY_ID				= ITC.COMMODITY_ID
							AND ITC.COMMODITY_ALIAS			= MM_SEM_UTIL.c_COMMODITY_ENERGY
							AND IT.TRANSACTION_INTERVAL		= DATE_UTIL.c_NAME_30MIN
						    AND IC.CONTRACT_ID				= IT.CONTRACT_ID
							AND IC.CONTRACT_ID				= ESI_IC.ENTITY_ID
							AND ESI_IC.EXTERNAL_SYSTEM_ID	= EC.ES_SEM
							AND ESI_IC.ENTITY_DOMAIN_ID		= EC.ED_INTERCHANGE_CONTRACT
							AND ESI_IC.EXTERNAL_IDENTIFIER IS NOT NULL
							AND SVC.SERVICE_POINT_ID		= ESI_POD.ENTITY_ID
							AND ESI_POD.ENTITY_DOMAIN_ID	= EC.ED_SERVICE_POINT
							AND ESI_POD.EXTERNAL_SYSTEM_ID 	= EC.ES_SEM
						    AND ESI_POD.EXTERNAL_IDENTIFIER LIKE 'I_%'
						    AND IT.AGREEMENT_TYPE			= STY.STATEMENT_TYPE_IDENT) LOOP
		SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_TXN_SELECT, v_CURSOR.TRANSACTION_ID, EC.ED_TRANSACTION);
		p_TRANSACTION_IDS.EXTEND;
		p_TRANSACTION_IDS(p_TRANSACTION_IDS.COUNT) := v_CURSOR.TRANSACTION_ID;
		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG('Transaction ID added to collection: ' || p_TRANSACTION_IDS(p_TRANSACTION_IDS.COUNT));
		END IF;
	END LOOP;
END GET_OFF_MGT_IU_VERIFY_ACT;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_IT_TRAIT_OFFER_MGT_IU
	(
	p_BEGIN_DATE			IN	DATE,
	p_END_DATE				IN	DATE,
	p_TIME_ZONE 			IN	VARCHAR2,
	p_INTERCONNECTOR_IDS	IN	NUMBER_COLLECTION,
	p_GATE_WINDOW_IDS		IN	NUMBER_COLLECTION,
	p_DATE_OFFSET			IN	NUMBER,
	p_SCHEDULE_TYPE			IN	NUMBER,
	p_SCHEDULE_STATE		IN	NUMBER,
	p_INTERVAL				IN	VARCHAR2,
	p_STATUS			   OUT	NUMBER,
	p_CURSOR			   OUT	GA.REFCURSOR
	) AS
	v_WORK_ID				NUMBER(9);
	v_ALL_ID				NUMBER_COLLECTION := NUMBER_COLLECTION(CONSTANTS.ALL_ID);
	v_RESULT				NUMBER_COLLECTION := NUMBER_COLLECTION();
	v_ALL_WINDOW_TYPES		NUMBER(9);
	v_ALL_INTERCONNECTORS	NUMBER(9);
	v_INTERVAL_NUMBER		NUMBER;
	v_DAY_INTERVAL_TYPE		NUMBER(1);
	v_FROM_CUT_INTERVAL		VARCHAR2(4);
	v_SCHEDULE_STATE		NUMBER(1) := NVL(p_SCHEDULE_STATE, 1);
	v_BEGIN_DATE			DATE;
	v_END_DATE				DATE;
	v_OFFSET				NUMBER := NVL(p_DATE_OFFSET,0);
	v_TRANSACTION_IDS		NUMBER_COLLECTION;
	v_INTERVAL				VARCHAR2(20);
	c_MODULE				CONSTANT VARCHAR2(14)	:= 'MarketExchange';
	c_KEY1					CONSTANT VARCHAR2(3)	:= 'SEM';
	c_KEY2					CONSTANT VARCHAR2(16)	:= 'Offer Management';
	c_COD_KEY3				CONSTANT VARCHAR2(20)	:= 'Interconnector COD';
	c_DAILY_KEY3			CONSTANT VARCHAR2(25)	:= 'Interconnector COD Daily';
BEGIN
	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('--------------------GET_IT_TRAIT_OFFER_MGT_IU--------------------');
		LOGS.LOG_DEBUG('p_BEGIN_DATE: ' || TO_CHAR(p_BEGIN_DATE, 'YYYY-MM-DD HH24:MI:SS'));
		LOGS.LOG_DEBUG('p_END_DATE: ' || TO_CHAR(p_END_DATE, 'YYYY-MM-DD HH24:MI:SS'));
		LOGS.LOG_DEBUG('p_TIME_ZONE: ' || p_TIME_ZONE);
		FOR v_IDX IN p_INTERCONNECTOR_IDS.FIRST..p_INTERCONNECTOR_IDS.LAST LOOP
			LOGS.LOG_DEBUG('p_INTERCONNECTOR_IDS( ' || v_IDX || '): ' || p_INTERCONNECTOR_IDS(v_IDX));
		END LOOP;
		FOR v_IDX IN p_GATE_WINDOW_IDS.FIRST..p_GATE_WINDOW_IDS.LAST LOOP
			LOGS.LOG_DEBUG('p_GATE_WINDOW_IDS( ' || v_IDX || '): ' || p_GATE_WINDOW_IDS(v_IDX));
		END LOOP;
		LOGS.LOG_DEBUG('p_DATE_OFFSET: ' || p_DATE_OFFSET);
		LOGS.LOG_DEBUG('p_SCHEDULE_TYPE: ' || p_SCHEDULE_TYPE);
		LOGS.LOG_DEBUG('p_SCHEDULE_STATE: ' || p_SCHEDULE_STATE);
		LOGS.LOG_DEBUG('p_INTERVAL: ' || p_INTERVAL);
	END IF;

	-- Check if <All> is part of the Generator selections made in the filter.
	v_RESULT := v_ALL_ID MULTISET INTERSECT p_INTERCONNECTOR_IDS;
	v_ALL_INTERCONNECTORS := CASE WHEN (v_RESULT.COUNT > 0) THEN CONSTANTS.ALL_ID ELSE 0 END;

	-- Check if <All> is part of the Gate Window selections made in the filter.
	v_RESULT := v_ALL_ID MULTISET INTERSECT p_GATE_WINDOW_IDS;
	v_ALL_WINDOW_TYPES := CASE WHEN (v_RESULT.COUNT > 0) THEN CONSTANTS.ALL_ID ELSE 0 END;

	-- For each Transaction ID that meets the filter criteria, check if there is "select" privilege.
	GET_OFF_MGT_IU_VERIFY_ACT(p_INTERCONNECTOR_IDS	=>	p_INTERCONNECTOR_IDS,
							  p_GATE_WINDOW_IDS		=>	p_GATE_WINDOW_IDS,
							  p_ALL_WINDOW_TYPES	=>	v_ALL_WINDOW_TYPES,
							  p_ALL_INTERCONNECTORS	=>	v_ALL_INTERCONNECTORS,
							  p_TRANSACTION_IDS		=>	v_TRANSACTION_IDS
							 );

	-- Populate RTO_WORK with the Trait Groups defined as System Labels.
	-- System Label also defines the order and number of times they should appear in the grid.
	IF p_INTERVAL = g_OFFER_INTERVAL THEN
		MM_SEM.GET_TRAITS_FOR_OFFER_MGT_GEN(c_MODULE, c_KEY1, c_KEY2, c_COD_KEY3, v_WORK_ID);
	ELSE
		MM_SEM.GET_TRAITS_FOR_OFFER_MGT_GEN(c_MODULE, c_KEY1, c_KEY2, c_DAILY_KEY3, v_WORK_ID);
	END IF;

	--Get the interval of data to display.
	IF p_INTERVAL = g_OFFER_INTERVAL THEN
		v_INTERVAL := g_INTERVAL_TBL(k_NOMINATION);
	ELSE
		v_INTERVAL := p_INTERVAL;
	END IF;

	v_INTERVAL_NUMBER := GET_INTERVAL_NUMBER(v_INTERVAL);

	IF INTERVAL_IS_ATLEAST_DAILY(v_INTERVAL) THEN
        v_DAY_INTERVAL_TYPE := 2;
		v_FROM_CUT_INTERVAL := 'DD';
		-- This is CALENDAR_DATE Range
		UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
    ELSE
        v_DAY_INTERVAL_TYPE := 1;
		v_FROM_CUT_INTERVAL := 'MI5';
		-- This is TRADING_DATE Range
    	MM_SEM_UTIL.OFFER_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, v_BEGIN_DATE, v_END_DATE);
    END IF;

    p_STATUS := GA.SUCCESS;

    -- Make sure we have data in the SYSTEM_DATE_TIME table.  Return an error if not.
	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, p_BEGIN_DATE, p_END_DATE);

    p_STATUS := GA.SUCCESS;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('v_ALL_INTERCONNECTORS: ' || v_ALL_INTERCONNECTORS);
		LOGS.LOG_DEBUG('v_ALL_WINDOW_TYPES: ' || v_ALL_WINDOW_TYPES);
		LOGS.LOG_DEBUG('Count of transactions: ' || v_TRANSACTION_IDS.COUNT);
		LOGS.LOG_DEBUG('v_OFFSET: ' || v_OFFSET);
		LOGS.LOG_DEBUG('v_INTERVAL: ' || v_INTERVAL);
		LOGS.LOG_DEBUG('v_INTERVAL_NUMBER: ' || v_INTERVAL_NUMBER);
		LOGS.LOG_DEBUG('v_DAY_INTERVAL_TYPE: ' || v_DAY_INTERVAL_TYPE);
		LOGS.LOG_DEBUG('v_FROM_CUT_INTERVAL: ' || v_FROM_CUT_INTERVAL);
		LOGS.LOG_DEBUG('v_BEGIN_DATE: ' || TO_CHAR(v_BEGIN_DATE, 'YYYY-MM-DD HH24:MI:SS'));
		LOGS.LOG_DEBUG('v_END_DATE: ' || TO_CHAR(v_END_DATE, 'YYYY-MM-DD HH24:MI:SS'));
		LOGS.LOG_DEBUG('v_SCHEDULE_STATE: ' || v_SCHEDULE_STATE);
	END IF;

	OPEN p_CURSOR FOR
		WITH STATEMENT_TYPES AS
			-- Fetch the Statement Types that match the filter criteria
			(SELECT ESI.EXTERNAL_IDENTIFIER		AS STATEMENT_TYPE_IDENT,
					STY.STATEMENT_TYPE_ID		AS STATEMENT_TYPE_ID,
					STY.STATEMENT_TYPE_ORDER	AS STATEMENT_TYPE_ORDER
			   FROM EXTERNAL_SYSTEM_IDENTIFIER	ESI,
					STATEMENT_TYPE				STY,
					TABLE(CAST(p_GATE_WINDOW_IDS AS NUMBER_COLLECTION)) GATE_IDS
			  WHERE STY.STATEMENT_TYPE_ID		= ESI.ENTITY_ID
				AND (GATE_IDS.COLUMN_VALUE		= STY.STATEMENT_TYPE_ID OR v_ALL_WINDOW_TYPES = CONSTANTS.ALL_ID)
				AND ESI.IDENTIFIER_TYPE			= MM_SEM_UTIL.g_STATEMENT_TYPE_GATE_WINDOW
				AND ESI.ENTITY_DOMAIN_ID 		= EC.ED_STATEMENT_TYPE
				AND ESI.EXTERNAL_SYSTEM_ID		= EC.ES_SEM
			)
		SELECT A.INTERCONNECTOR_NAME,
			   FROM_CUT_AS_HED(CUT_DATE_SCHEDULING + v_OFFSET, p_TIME_ZONE, v_FROM_CUT_INTERVAL) "SCHEDULE_DATE_STR",
			   A.TRANSACTION_ID AS TRANSACTION_ID,
			   A.STATEMENT_TYPE_ORDER	AS	STATEMENT_TYPE_ORDER,
			   A.GATE_WINDOW	AS GATE_WINDOW,
			   A.TRAIT_GROUP_ID,
			   A.TRAIT_INDEX,
			   COALESCE(A.GROUP_DISPLAY_NAME, A.TRAIT_GROUP_NAME, ' ') "TRAIT_GROUP_NAME",
			   CASE
			   	   WHEN A.IS_SERIES = 0 THEN
				   	   A.DISPLAY_NAME
				   ELSE
				   	   A.DISPLAY_NAME||' '||NVL(A.SET_NUMBER,1)
				   END 			AS DISPLAY_NAME,
			   A.SET_NUMBER		AS SET_NUMBER,
			   A.DATA_TYPE,
			   A.EDIT_MASK,
			   A.COMBO_LIST,
			   A.FORMAT,
			   A.AFTER_EDIT,
			   TG.TO_CHAR_TRAIT_VAL(B.TRAIT_VAL,A.DATA_TYPE) 	AS TRAIT_VAL,
			   TO_NUMBER(TO_CHAR(A.CUT_DATE_SCHEDULING,'HH24')) AS "ROWNUM",
			   ROWNUM											AS REAL_ROWNUM,
			   CUT_DATE_SCHEDULING + v_OFFSET					AS CUT_DATE_SCHEDULING,
			   GROUP_ORDER,
			   TRAIT_ORDER
		FROM (SELECT EI.GET_ENTITY_IDENTIFIER_EXTSYS(EC.ED_INTERCHANGE_CONTRACT, IT.CONTRACT_ID, EC.ES_SEM)
					  || ' : ' || EI.GET_ENTITY_IDENTIFIER_EXTSYS(EC.ED_SERVICE_POINT, IT.POD_ID, EC.ES_SEM) AS INTERCONNECTOR_NAME,
					 IT.TRANSACTION_ID,
					 IT.AGREEMENT_TYPE					AS GATE_WINDOW,
					 SDT.CUT_DATE_SCHEDULING			AS CUT_DATE_SCHEDULING,
					 TTG.TRAIT_GROUP_NAME,
					 TTG.DISPLAY_NAME					AS GROUP_DISPLAY_NAME,
					 TR.WORK_SEQ + TTA.DISPLAY_ORDER	AS GROUP_ORDER,
					 TTG.TRAIT_GROUP_ID,
					 TTG.IS_STATEMENT_TYPE_SPECIFIC,
					 TTG.IS_SERIES,
					 TTA.TRAIT_INDEX,
					 TTA.DISPLAY_NAME,
					 TTA.DISPLAY_ORDER					AS TRAIT_ORDER,
					 TTA.DATA_TYPE,
					 TTA.EDIT_MASK,
					 TTA.COMBO_LIST,
					 TTA.FORMAT,
					 TTA.AFTER_EDIT,
					 TR.WORK_DATA						AS SET_NUMBER,
					 STY.STATEMENT_TYPE_ORDER			AS STATEMENT_TYPE_ORDER
				FROM INTERCHANGE_TRANSACTION 		IT,
					 TRANSACTION_TRAIT_GROUP 		TTG,
					 TRANSACTION_TRAIT_ATTRIBUTES 	TTA,
					 SYSTEM_DATE_TIME 				SDT,
					 RTO_WORK						TR,
					 TABLE(CAST(v_TRANSACTION_IDS AS NUMBER_COLLECTION))	TRANSACTION_IDS,
					 STATEMENT_TYPES				STY
			   WHERE TR.WORK_ID 			= v_WORK_ID
				 AND TTG.TRAIT_GROUP_ID 	= TR.WORK_XID
				 AND TTG.IS_SPARSE			= 0
				 AND TTG.TRAIT_GROUP_INTERVAL IN (v_INTERVAL, p_INTERVAL)
				 AND TTA.TRAIT_GROUP_ID		= TTG.TRAIT_GROUP_ID
				 AND IT.TRANSACTION_ID		= TRANSACTION_IDS.COLUMN_VALUE
			     AND IT.AGREEMENT_TYPE		= STY.STATEMENT_TYPE_IDENT
				 AND SDT.TIME_ZONE			= p_TIME_ZONE
				 AND SDT.DATA_INTERVAL_TYPE	= v_DAY_INTERVAL_TYPE
				 AND SDT.DAY_TYPE 			= 1
				 AND SDT.CUT_DATE_SCHEDULING BETWEEN v_BEGIN_DATE AND v_END_DATE
				 AND SDT.MINIMUM_INTERVAL_NUMBER >= v_INTERVAL_NUMBER
            ) A,
			IT_TRAIT_SCHEDULE B
		WHERE B.TRANSACTION_ID(+)		= A.TRANSACTION_ID
		  AND B.SCHEDULE_STATE(+) 		= v_SCHEDULE_STATE
		  AND B.SCHEDULE_DATE(+)		= A.CUT_DATE_SCHEDULING
		  AND B.TRAIT_GROUP_ID(+)		= A.TRAIT_GROUP_ID
		  AND B.TRAIT_INDEX(+)			= A.TRAIT_INDEX
		  AND B.SET_NUMBER(+)			= A.SET_NUMBER
		  AND B.STATEMENT_TYPE_ID(+)	= CASE A.IS_STATEMENT_TYPE_SPECIFIC WHEN 0 THEN 0 ELSE p_SCHEDULE_TYPE END
		ORDER BY TRANSACTION_ID, GROUP_ORDER, SET_NUMBER, TRAIT_ORDER, CUT_DATE_SCHEDULING;

		-- RTO_WORK is used through out the product and it is good idea to purge the table
		-- to avoid interference with other areas of the code.
		UT.PURGE_RTO_WORK(v_WORK_ID);
END GET_IT_TRAIT_OFFER_MGT_IU;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_IT_TRAIT_OFFER_MGT_GEN
	(
	p_TRANSACTION_ID 		IN NUMBER,
	p_CUT_DATE_SCHEDULING 	IN DATE,
	p_TRAIT_GROUP_ID 		IN NUMBER,
	p_TRAIT_INDEX 			IN NUMBER,
	p_SET_NUMBER 			IN NUMBER,
	p_TRAIT_VAL 			IN VARCHAR2
	) AS
	v_SCHEDULE_DATE 		DATE;
	v_SCHEDULE_STATE 		NUMBER(1);
	v_SCHEDULE_TYPE 		NUMBER(1);
BEGIN
	v_SCHEDULE_DATE 	:= TRUNC(p_CUT_DATE_SCHEDULING) + g_SECOND;
	v_SCHEDULE_TYPE 	:= 0;
	v_SCHEDULE_STATE 	:= 1;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('p_TRANSACTION_ID: '|| p_TRANSACTION_ID);
		LOGS.LOG_DEBUG('p_CUT_DATE_SCHEDULING: '|| p_CUT_DATE_SCHEDULING);
		LOGS.LOG_DEBUG('p_SCHEDULE_DATE: '|| v_SCHEDULE_DATE);
		LOGS.LOG_DEBUG('p_TRAIT_GROUP_ID: '|| p_TRAIT_GROUP_ID);
		LOGS.LOG_DEBUG('p_TRAIT_INDEX: '|| p_TRAIT_INDEX);
		LOGS.LOG_DEBUG('p_SET_NUMBER: '|| p_SET_NUMBER);
		LOGS.LOG_DEBUG('p_TRAIT_VAL: '|| p_TRAIT_VAL);
	END IF;
	TG.PUT_IT_TRAIT_SCHEDULE_AS_CUT(p_TRANSACTION_ID,
									v_SCHEDULE_STATE,
									v_SCHEDULE_TYPE,
									v_SCHEDULE_DATE,
									p_TRAIT_GROUP_ID,
									p_TRAIT_INDEX,
									p_SET_NUMBER,
									p_TRAIT_VAL);
	COMMIT;
END PUT_IT_TRAIT_OFFER_MGT_GEN;
----------------------------------------------------------------------------------------------------
PROCEDURE IT_TRAIT_OFFER_MGT_GEN_ACCEPT
	(
	p_TRANSACTION_ID 		IN NUMBER,
	p_CUT_DATE_SCHEDULING 	IN DATE
	) AS
BEGIN
	-- Accept the Transaction.
	TG.IT_TRAIT_STATUS_ACCEPT(p_TRANSACTION_ID, DATE_COLLECTION(TRUNC(p_CUT_DATE_SCHEDULING) + g_SECOND));
END IT_TRAIT_OFFER_MGT_GEN_ACCEPT;
---------------------------------------------------------------------------------------------------
PROCEDURE IT_TRAIT_OFFER_ACCEPT
	(
	p_TRANSACTION_ID 		IN NUMBER,
	p_CUT_DATE_SCHEDULING 	IN DATE_COLLECTION
	) AS
BEGIN
	-- Accept the Transaction.for various intervals.
	TG.IT_TRAIT_STATUS_ACCEPT(p_TRANSACTION_ID, p_CUT_DATE_SCHEDULING);
END IT_TRAIT_OFFER_ACCEPT;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_IT_TRAIT_SCHED_DETAIL_RPT
	(
	p_TRANSACTION_ID		IN NUMBER,
	p_SCHEDULE_STATE		IN NUMBER,
	p_SCHEDULE_TYPE			IN NUMBER,
	p_CUT_DATE_SCHEDULING	IN DATE,
	p_TRAIT_GROUP_ID		IN NUMBER,
	p_TRAIT_INDEX			IN NUMBER,
	p_SET_NUMBER			IN NUMBER,
	p_TRAIT_VAL				IN VARCHAR,
	p_REASON_FOR_CHANGE		IN VARCHAR2,
	p_OTHER_REASON			IN VARCHAR2,
	p_PROCESS_MESSAGE		IN VARCHAR2
	) AS
BEGIN
	TG.PUT_IT_TRAIT_SCHED_DETAIL_RPT(p_TRANSACTION_ID		=>	p_TRANSACTION_ID,
									 p_SCHEDULE_STATE		=>	p_SCHEDULE_STATE,
									 p_SCHEDULE_TYPE		=>	p_SCHEDULE_TYPE,
									 p_CUT_DATE_SCHEDULING	=>	p_CUT_DATE_SCHEDULING,
									 p_TRAIT_GROUP_ID		=>	p_TRAIT_GROUP_ID,
									 p_TRAIT_INDEX			=>	p_TRAIT_INDEX,
									 p_SET_NUMBER			=>	p_SET_NUMBER,
									 p_TRAIT_VAL			=>	p_TRAIT_VAL,
									 p_REASON_FOR_CHANGE	=>	p_REASON_FOR_CHANGE,
									 p_OTHER_REASON			=>	p_OTHER_REASON,
									 p_PROCESS_MESSAGE		=>	p_PROCESS_MESSAGE);
END PUT_IT_TRAIT_SCHED_DETAIL_RPT;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_OFFER_SUBMISSION_STATUS
  (
  p_BEGIN_DATE IN DATE,
  p_END_DATE IN DATE,
  p_TIME_ZONE IN VARCHAR2,
  p_GATE_WINDOW_ID IN NUMBER,
  p_RESOURCE_TYPE IN VARCHAR2, -- Generators or Interconnectors
  p_CURSOR OUT GA.REFCURSOR
  ) AS
  v_GATE_WINDOW EXTERNAL_SYSTEM_IDENTIFIER.EXTERNAL_IDENTIFIER%TYPE;
  v_MESSAGE VARCHAR2(5000);
  v_STATUS NUMBER;
  v_LABEL VARCHAR2(64);
  v_CURSOR GA.REFCURSOR;
  v_TRANSACTION_ID INTERCHANGE_TRANSACTION.TRANSACTION_ID%TYPE;
  v_TRANSACTION_NAME INTERCHANGE_TRANSACTION.TRANSACTION_NAME%TYPE;
  v_WORK_ID NUMBER;
  v_WORK_SEQ NUMBER;
  v_TRANSACTION_TYPE VARCHAR2(64);
BEGIN
  -- Make sure we have data in the SYSTEM_DATE_TIME table.  Return an error if not.
	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, p_BEGIN_DATE, p_END_DATE);

  IF p_RESOURCE_TYPE = g_OFFER_UI_GENERATORS THEN
    v_TRANSACTION_TYPE := MM_SEM.k_GENERATION;
  ELSE
    v_TRANSACTION_TYPE := MM_SEM.k_NOMINATION;
  END IF;

  -- get the list of transactions
  SELECT ESI.EXTERNAL_IDENTIFIER
  INTO v_GATE_WINDOW
  FROM EXTERNAL_SYSTEM_IDENTIFIER ESI
  WHERE ESI.ENTITY_ID = p_GATE_WINDOW_ID
    AND ESI.IDENTIFIER_TYPE = MM_SEM_UTIL.g_STATEMENT_TYPE_GATE_WINDOW
    AND ESI.ENTITY_DOMAIN_ID = EC.ED_STATEMENT_TYPE
    AND ESI.EXTERNAL_SYSTEM_ID = EC.ES_SEM;
  MM_SEM_OFFER.OFFER_ENTITY_LIST_GATE(p_BEGIN_DATE => p_BEGIN_DATE,
                                      p_END_DATE => p_END_DATE,
                                      p_INCLUDE_ALL => 0,
                                      p_GATE_WINDOW => v_GATE_WINDOW,
                                      p_TRANSACTION_TYPE => v_TRANSACTION_TYPE,
                                      p_LABEL => v_LABEL,
                                      p_STATUS => v_STATUS,
                                      p_MESSAGE => v_MESSAGE,
                                      p_CURSOR => v_CURSOR);

  UT.GET_RTO_WORK_ID(v_WORK_ID);
  v_WORK_SEQ := 0;
  LOOP
    FETCH v_CURSOR INTO v_TRANSACTION_NAME, v_TRANSACTION_ID;
    EXIT WHEN v_CURSOR%NOTFOUND;
    INSERT INTO RTO_WORK
				(
				 WORK_ID,
				 WORK_SEQ,
				 WORK_XID,
				 WORK_DATA
				)
			VALUES
				(
         v_WORK_ID,
				 v_WORK_SEQ,
				 v_TRANSACTION_ID,
				 v_TRANSACTION_NAME
				);
      v_WORK_SEQ := v_WORK_SEQ + 1;
  END LOOP;

    OPEN p_CURSOR FOR
  WITH ID_TIME_TABLE AS (
    -- This represents a table of
    -- each transaction ID along with each date in time range
    -- 3 dates are returned:
    --   TRUNC_DATE - for display
    --   GEN_DATE_SELECTOR - for selecting Generator statuses
    --   IC_DATE_SELECTOR - for selecting Interconnector statuses
    -- Example:
    --   TRANSACTION_ID  TRUNC_DATE  GEN_DATE_SELECTOR       IC_DATE_SELECTOR
    --   1009            11/1/2011   11/1/2011 12:00:01 AM   11/1/2011 06:30:00 AM
    --   1009            11/2/2011   11/2/2011 12:00:01 AM   11/2/2011 06:30:00 AM
    --   1010            11/1/2011   11/1/2011 12:00:01 AM   11/1/2011 06:30:00 AM
    --   1010            11/2/2011   11/2/2011 12:00:01 AM   11/2/2011 06:30:00 AM
    SELECT RW.WORK_XID TRANSACTION_ID,
           RW.WORK_DATA OFFER_IDENTIFIER,
           SDT.LOCAL_DAY_TRUNC_DATE TRUNC_DATE,
           SDT.CUT_DATE_SCHEDULING GEN_DATE_SELECTOR,
           SDT.LOCAL_DAY_TRUNC_DATE+6/24+30/1440 IC_DATE_SELECTOR
    FROM RTO_WORK RW,
         SYSTEM_DATE_TIME SDT
    WHERE RW.WORK_ID = v_WORK_ID
      AND SDT.DATA_INTERVAL_TYPE = 2 -- daily
          AND SDT.LOCAL_DAY_TRUNC_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
  )
  -- Select statuses that exist in IT_TRAIT_SCHEDULE_STATUS
  -- equality join on TRANSACTION_ID and SCHEDULE_DATE (depends on v_TRANSACTION_TYPE)
  SELECT SUBSTR(TO_CHAR(ITT.TRUNC_DATE, MM_SEM_UTIL.g_DATE_FORMAT),1,10) OFFER_DATE,
         ITT.TRANSACTION_ID TRANSACTION_ID,
         ITT.OFFER_IDENTIFIER OFFER_IDENTIFIER,
           NVL(ITSS.MARKET_STATUS, NVL(ITSS.SUBMIT_STATUS, CASE WHEN ITSS.REVIEW_STATUS = 'Accepted' THEN 'Approved' ELSE ITSS.REVIEW_STATUS END)) STATUS
  FROM ID_TIME_TABLE ITT,
       IT_TRAIT_SCHEDULE_STATUS ITSS
  WHERE ITT.TRANSACTION_ID = ITSS.TRANSACTION_ID
    -- match SCHEDULE_DATE based on appropriate selector/v_TRANSACTION_TYPE
    AND ITSS.SCHEDULE_DATE = CASE WHEN v_TRANSACTION_TYPE = MM_SEM.k_GENERATION THEN ITT.GEN_DATE_SELECTOR ELSE ITT.IC_DATE_SELECTOR END
  UNION ALL
  -- Select NULL statuses for transaction/date combination
  -- that do not exist in IT_TRAIT_SCHEDULE_STATUS
  SELECT SUBSTR(TO_CHAR(ITT.TRUNC_DATE, MM_SEM_UTIL.g_DATE_FORMAT),1,10) OFFER_DATE,
         ITT.TRANSACTION_ID TRANSACTION_ID,
         ITT.OFFER_IDENTIFIER OFFER_IDENTIFIER,
         NULL STATUS
  FROM ID_TIME_TABLE ITT
  WHERE NOT EXISTS (
    SELECT 1
    FROM IT_TRAIT_SCHEDULE_STATUS ITSS
    WHERE ITSS.TRANSACTION_ID = ITT.TRANSACTION_ID
      -- match SCHEDULE_DATE based on appropriate selector/v_TRANSACTION_TYPE
      AND ITSS.SCHEDULE_DATE = CASE WHEN v_TRANSACTION_TYPE = MM_SEM.k_GENERATION THEN ITT.GEN_DATE_SELECTOR ELSE ITT.IC_DATE_SELECTOR END
  )
    ORDER BY OFFER_IDENTIFIER,OFFER_DATE
    ;

  UT.PURGE_RTO_WORK(v_WORK_ID);

END GET_OFFER_SUBMISSION_STATUS;
---------------------------------------------------------------------------------------------------
PROCEDURE COMBINED_OFFERS_SUBMIT
  (
  p_BEGIN_DATE IN DATE,
  p_END_DATE IN DATE,
  p_TRANSACTION_IDS IN NUMBER_COLLECTION,
	p_LOG_TYPE IN NUMBER,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR2
  ) AS
  v_ID NUMBER;
  v_FOUND NUMBER;
  v_ID_SET NUMBER_COLLECTION := NUMBER_COLLECTION();
  v_ID_STRING VARCHAR2(4000) := '';
  c_DELIMITER CONSTANT CHAR := ',';
BEGIN
  FOR I IN 1..p_TRANSACTION_IDS.COUNT LOOP
    v_ID := p_TRANSACTION_IDS(I);
    SELECT COUNT(*) INTO v_FOUND FROM TABLE(CAST(v_ID_SET AS NUMBER_COLLECTION)) WHERE COLUMN_VALUE = v_ID;
    IF v_FOUND = 0 THEN
      v_ID_SET.EXTEND;
      v_ID_SET(v_ID_SET.COUNT) := v_ID;
      v_ID_STRING := v_ID_STRING || TO_CHAR(v_ID) || c_DELIMITER;
    END IF;
  END LOOP;
  SELECT RTRIM(v_ID_STRING, ',') INTO v_ID_STRING FROM DUAL;

  MM_SEM_OFFER.SUBMIT_OFFERS(p_ENTITY_LIST => v_ID_STRING,
                             p_ENTITY_LIST_DELIMITER => c_DELIMITER,
                             p_BEGIN_DATE => p_BEGIN_DATE,
                             p_END_DATE => p_END_DATE,
                             p_LOG_TYPE => p_LOG_TYPE,
                             p_TRACE_ON => p_TRACE_ON,
                             p_STATUS => p_STATUS,
                             p_MESSAGE => p_MESSAGE);
END COMBINED_OFFERS_SUBMIT;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_EXCLUDED_BIDS
  (
   p_BEGIN_DATE IN DATE,
   p_END_DATE IN DATE,
   p_TIME_ZONE IN VARCHAR2,
   p_INTERCONNECTOR_IDS IN NUMBER_COLLECTION,
   p_GATE_WINDOW_IDS IN NUMBER_COLLECTION,
   p_CURSOR OUT GA.REFCURSOR
  ) AS
  v_RESULT			NUMBER_COLLECTION := NUMBER_COLLECTION();
  v_ALL_WINDOW_TYPES	NUMBER(9);
  v_ALL_INTERCONNECTORS	NUMBER(9);
  v_ALL_ID			NUMBER_COLLECTION := NUMBER_COLLECTION(CONSTANTS.ALL_ID);
  v_BEGIN_DATE DATE;
  v_END_DATE DATE;
  v_MIN_INTERVAL_NUMBER NUMBER(2) := GET_INTERVAL_NUMBER('MI30');
  v_TRAITS STRING_COLLECTION := STRING_COLLECTION('P', 'Q', 'X');
BEGIN
	-- Check if <All> is part of the Interconnector selections made in the filter.
	v_RESULT := v_ALL_ID MULTISET INTERSECT p_INTERCONNECTOR_IDS;
  v_ALL_INTERCONNECTORS := CASE WHEN (v_RESULT.COUNT > 0) THEN CONSTANTS.ALL_ID ELSE 0 END;

	-- Check if <All> is part of the Gate Window selections made in the filter.
	v_RESULT := v_ALL_ID MULTISET INTERSECT p_GATE_WINDOW_IDS;
	v_ALL_WINDOW_TYPES := CASE WHEN (v_RESULT.COUNT > 0) THEN CONSTANTS.ALL_ID ELSE 0 END;

  -- Make sure we have data in the SYSTEM_DATE_TIME table.  Return an error if not.
	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, p_BEGIN_DATE, p_END_DATE);

  UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

  OPEN p_CURSOR FOR
       SELECT FROM_CUT_AS_HED(SDT.CUT_DATE, p_TIME_ZONE, DATE_UTIL.c_ABBR_30MIN) AS DELIVERY_DATE,
              GATE_WINDOW,
              PARTICIPANT_NAME,
              RESOURCE_NAME,
              PQ_INDEX,
              TRAIT_NAME,
              TRAIT_VALUE,
              MAX_IMPORT_CAP,
              MAX_EXPORT_CAP
       FROM SYSTEM_DATE_TIME SDT,
         (SELECT EXCL_BIDS.*,
            TR.COLUMN_VALUE || TO_CHAR(EXCL_BIDS.PQ_INDEX) AS TRAIT_NAME,
            CASE WHEN TR.COLUMN_VALUE = 'P' THEN TO_CHAR(PRICE)
                 WHEN TR.COLUMN_VALUE = 'Q' THEN TO_CHAR(QUANTITY)
                 WHEN TR.COLUMN_VALUE = 'X' THEN EXCLUDED_FLAG
            END AS TRAIT_VALUE
         FROM
           (SELECT EB.*
           FROM SEM_EXCLUDED_BIDS EB,
                EXTERNAL_SYSTEM_IDENTIFIER	SVC_IDENT,
                SERVICE_POINT SVC,
                TABLE(CAST(p_INTERCONNECTOR_IDS AS NUMBER_COLLECTION)) SP_IDS,
                EXTERNAL_SYSTEM_IDENTIFIER	ST_IDENT,
                STATEMENT_TYPE ST,
                TABLE(CAST(p_GATE_WINDOW_IDS AS NUMBER_COLLECTION)) GATE_IDS
           WHERE TRIM(UPPER(SVC_IDENT.EXTERNAL_IDENTIFIER)) = TRIM(UPPER(EB.RESOURCE_NAME))
                 AND SVC_IDENT.ENTITY_DOMAIN_ID	= EC.ED_SERVICE_POINT
							   AND SVC_IDENT.EXTERNAL_SYSTEM_ID 	= EC.ES_SEM
						     AND SVC_IDENT.EXTERNAL_IDENTIFIER LIKE 'I_%'
                 AND SVC.SERVICE_POINT_ID = SVC_IDENT.ENTITY_ID
                 AND (SP_IDS.COLUMN_VALUE	= SVC.SERVICE_POINT_ID OR v_ALL_INTERCONNECTORS = CONSTANTS.ALL_ID)
                 AND ST_IDENT.IDENTIFIER_TYPE			= MM_SEM_UTIL.g_STATEMENT_TYPE_GATE_WINDOW
							   AND ST_IDENT.ENTITY_DOMAIN_ID 		= EC.ED_STATEMENT_TYPE
							   AND ST_IDENT.EXTERNAL_SYSTEM_ID		= EC.ES_SEM
                 AND TRIM(UPPER(ST_IDENT.EXTERNAL_IDENTIFIER)) = TRIM(UPPER(EB.GATE_WINDOW))
                 AND ST.STATEMENT_TYPE_ID = ST_IDENT.ENTITY_ID
                 AND (GATE_IDS.COLUMN_VALUE	= ST.STATEMENT_TYPE_ID OR v_ALL_WINDOW_TYPES = CONSTANTS.ALL_ID)) EXCL_BIDS,
            TABLE(CAST(v_TRAITS AS STRING_COLLECTION)) TR)
       WHERE SDT.TIME_ZONE = p_TIME_ZONE
            AND SDT.DATA_INTERVAL_TYPE = 1
            AND SDT.DAY_TYPE = '1'
            AND SDT.CUT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
            AND SDT.MINIMUM_INTERVAL_NUMBER >= v_MIN_INTERVAL_NUMBER
            AND DELIVERY_DATE(+) = SDT.CUT_DATE
       ORDER BY FROM_CUT_AS_HED(SDT.CUT_DATE, p_TIME_ZONE, DATE_UTIL.c_ABBR_30MIN), RESOURCE_NAME, GATE_WINDOW, PQ_INDEX, TRAIT_NAME;
END GET_EXCLUDED_BIDS;
---------------------------------------------------------------------------------------------------
BEGIN
    g_INTERVAL_TBL(k_NOMINATION) := '30 Minute';
    g_INTERVAL_TBL(k_GENERATION) := 'Day';
    g_INTERVAL_TBL(k_LOAD) := 'Day';
    g_INTERVAL_TBL(k_DEFAULT) := 'Day';
END MM_SEM;
/
