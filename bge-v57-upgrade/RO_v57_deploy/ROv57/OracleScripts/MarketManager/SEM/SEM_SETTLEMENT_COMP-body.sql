CREATE OR REPLACE PACKAGE BODY SEM_SETTLEMENT_COMP IS
-- Private type declarations

-- Private constant declarations
g_COMP_TYPE_SCHEDULE CONSTANT VARCHAR2(32) := 'Schedule';
g_COMP_TYPE_MP CONSTANT VARCHAR2(32) := 'Market Price';
g_COMP_TYPE_COMPONENT CONSTANT VARCHAR2(32) := 'Component';

g_COMPARISON_ITEM_NET_DEMAND CONSTANT VARCHAR2(32) := 'NDLF';
g_COMPARISON_ITEM_MD CONSTANT VARCHAR2(32) := 'MD';  			-- metered demand
g_COMPARISON_ITEM_MSQ_GEN CONSTANT VARCHAR2(32) := 'MSQ';
g_COMPARISON_ITEM_DISPATCH_QTY CONSTANT VARCHAR2(32) := 'DQ';
g_COMPARISON_ITEM_EGBL_AVAL CONSTANT VARCHAR2(32) := 'EA';
g_COMPARISON_ITEM_METERED_GEN CONSTANT VARCHAR2(32) := 'MG';
g_COMPARISON_ITEM_SMP CONSTANT VARCHAR2(32) := 'SMP';
g_COMPARISON_ITEM_CPDP CONSTANT VARCHAR2(32) := 'CPDP';
g_COMPARISON_ITEM_CPGP CONSTANT VARCHAR2(32) := 'CPGP';
g_COMPARISON_ITEM_NDLFESU CONSTANT VARCHAR2(32) := 'NDLFESU';

g_COMBO_LIST_SEPERATOR CONSTANT VARCHAR2(32) := '---------------------';

g_CT_REALLOC CONSTANT VARCHAR2(32) := 'REALLOC';
g_CT_INTEREST CONSTANT VARCHAR2(32) := 'INTEREST';
g_CT_VAT CONSTANT VARCHAR2(32) := 'VAT';

g_STATEMENT_COMPARISON CONSTANT VARCHAR2(32) := 'Statement Comparison';
g_INVOICE_COMPARISON CONSTANT VARCHAR2(32) := 'Invoice Comparison';
g_TOLERANCE_SYS_ALERT VARCHAR2(64) := 'SEM Settlement Tolerance Alert';

c_MSG_INVALID_TOL_DIFF VARCHAR2(128) := '% Difference filter value is not a valid number.';
c_MSG_MISSING_TOL_DIFF VARCHAR2(128) := 'At least one of the Tolerance % Difference need to be specified to view the report.';
c_MSG_MISSING_TOL_DIFF_ENERGY VARCHAR2(128) := 'IE T&D or Internal Volume % Difference need to be specified to view the Energy Volume report.';
c_MSG_MISSING_TOL_DIFF_TDIE VARCHAR2(128) := 'Interval or Non-Interval Volume % Difference need to be specified to view the IE T&D Volume report.';

g_TXN_TYPE_LOAD CONSTANT VARCHAR2(32) := 'Load';
g_COMMODITY_ALIAS_RETAIL_LOAD CONSTANT VARCHAR2(32) := 'Retail Load';
g_SG_METER_TYPE_INTERVAL CONSTANT VARCHAR2(32) := 'Interval';
g_SG_METER_TYPE_PERIOD CONSTANT VARCHAR2(32) := 'Period';

-- Private variable declarations

-- Function and procedure implementations
----------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
	RETURN '$Revision: 1.3 $';
END WHAT_VERSION;
--------------------------------------------------------------------------------
PROCEDURE NULL_CURSOR(p_CURSOR IN OUT REF_CURSOR) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT NULL	FROM DUAL;
END NULL_CURSOR;
--------------------------------------------------------------------------------
PROCEDURE GET_PARTICIPANTS
(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
) AS
BEGIN
	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT DISTINCT PSE.PSE_NAME AS PARTICIPANT_NAME,
			PSE.PSE_ID AS PARTICIPANT_ID
		FROM SEM_SETTLEMENT_ENTITY S,
			PURCHASING_SELLING_ENTITY PSE
		WHERE PSE.PSE_ID = S.PARTICIPANT_PSE_ID
		ORDER BY PSE.PSE_NAME;
END;
--------------------------------------------------------------------------------
PROCEDURE GET_STATEMENT_COMPARISON_ITEMS
(
	p_PARTICIPANT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
) AS
BEGIN
	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT * FROM
			(SELECT g_COMPARISON_ITEM_NET_DEMAND FROM DUAL
			UNION ALL
			SELECT g_COMPARISON_ITEM_MSQ_GEN FROM DUAL
			UNION ALL
			SELECT g_COMPARISON_ITEM_DISPATCH_QTY FROM DUAL
			UNION ALL
			SELECT g_COMPARISON_ITEM_EGBL_AVAL FROM DUAL
			UNION ALL
			SELECT g_COMPARISON_ITEM_METERED_GEN FROM DUAL
			UNION ALL
			SELECT g_COMPARISON_ITEM_SMP FROM DUAL
			UNION ALL
			SELECT g_COMPARISON_ITEM_CPDP FROM DUAL
			UNION ALL
			SELECT g_COMPARISON_ITEM_CPGP FROM DUAL
			UNION ALL
			SELECT g_COMPARISON_ITEM_NDLFESU FROM DUAL
				UNION ALL
				SELECT g_COMPARISON_ITEM_MD FROM DUAL
			ORDER BY 1)
		UNION ALL
		SELECT g_COMBO_LIST_SEPERATOR FROM DUAL -- Seperate the Determinant and Components
		UNION ALL
		SELECT * FROM
			(SELECT DISTINCT C.COMPONENT_NAME
			 FROM COMPONENT C,
				BILLING_STATEMENT B,
				SEM_SETTLEMENT_ENTITY S
			 WHERE C.RATE_STRUCTURE = 'Formula'
				AND B.COMPONENT_ID = C.COMPONENT_ID
				AND S.SETTLEMENT_PSE_ID = B.ENTITY_ID
				AND S.MARKET_NAME = C.COMPONENT_CATEGORY
				AND S.PARTICIPANT_PSE_ID = p_PARTICIPANT_ID
				-- Following components do not have a resource iterator and are excluded
				AND C.COMPONENT_NAME NOT IN (g_CT_INTEREST, g_CT_REALLOC, g_CT_VAT)
			 ORDER BY C.COMPONENT_NAME);
END;
--------------------------------------------------------------------------------
PROCEDURE GET_INVOICE_COMPARISON_ITEMS
(
	p_PARTICIPANT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
) AS
BEGIN
	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT DISTINCT C.COMPONENT_NAME
		FROM INVOICE_LINE_ITEM L,
			COMPONENT C,
			INVOICE I,
			SEM_SETTLEMENT_ENTITY S
		WHERE C.COMPONENT_ID = L.COMPONENT_ID
			AND L.INVOICE_ID = I.INVOICE_ID
			AND S.SETTLEMENT_PSE_ID = I.ENTITY_ID
			AND S.MARKET_NAME = C.COMPONENT_CATEGORY
			AND S.PARTICIPANT_PSE_ID = p_PARTICIPANT_ID
		ORDER BY C.COMPONENT_NAME;
END;
--------------------------------------------------------------------------------
PROCEDURE GET_TOLERANCE_COMPARISON_ITEMS
(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
) AS
BEGIN
	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT * FROM
			(SELECT g_COMPARISON_ITEM_NET_DEMAND FROM DUAL
			UNION ALL
			SELECT g_COMPARISON_ITEM_MSQ_GEN FROM DUAL
			UNION ALL
			SELECT g_COMPARISON_ITEM_DISPATCH_QTY FROM DUAL
			UNION ALL
			SELECT g_COMPARISON_ITEM_EGBL_AVAL FROM DUAL
			UNION ALL
			SELECT g_COMPARISON_ITEM_METERED_GEN FROM DUAL
			UNION ALL
			SELECT g_COMPARISON_ITEM_SMP FROM DUAL
			UNION ALL
			SELECT g_COMPARISON_ITEM_CPDP FROM DUAL
			UNION ALL
			SELECT g_COMPARISON_ITEM_CPGP FROM DUAL
			UNION ALL
			SELECT g_COMPARISON_ITEM_NDLFESU FROM DUAL
			UNION ALL
			SELECT g_COMPARISON_ITEM_MD FROM DUAL
			ORDER BY 1)
		UNION ALL
		SELECT g_COMBO_LIST_SEPERATOR FROM DUAL -- Seperate the Determinant and Components
		UNION ALL
		SELECT * FROM
			(SELECT DISTINCT C.COMPONENT_NAME
			 FROM COMPONENT C
			 ORDER BY C.COMPONENT_NAME);
END;
--------------------------------------------------------------------------------
PROCEDURE GET_TOLERANCES
(
	p_PSE_ID IN NUMBER,
	p_COMPARISON_ITEM IN VARCHAR2,
	p_STATEMENT_TYPE1_ID IN NUMBER,
	p_STATEMENT_STATE1_ID IN NUMBER,
	p_STATEMENT_TYPE2_ID IN NUMBER,
	p_STATEMENT_STATE2_ID IN NUMBER,
	p_ABSOLUTE_ERROR_TOL OUT NUMBER,
	p_RELATIVE_ERROR_TOL OUT NUMBER,
	p_STATUS OUT NUMBER
) AS
BEGIN
	p_STATUS := GA.SUCCESS;

	SELECT T.ABSOLUTE_ERROR_TOLERANCE, T.RELATIVE_ERROR_TOLERANCE
		INTO p_ABSOLUTE_ERROR_TOL, p_RELATIVE_ERROR_TOL
	FROM SEM_SETTLEMENT_TOLERANCE T
	WHERE T.PSE_ID = p_PSE_ID
		AND T.COMPARISON_ITEM = p_COMPARISON_ITEM
		AND T.STATEMENT_TYPE1_ID = p_STATEMENT_TYPE1_ID
		AND T.STATEMENT_STATE1_ID = p_STATEMENT_STATE1_ID
		AND T.STATEMENT_TYPE2_ID = p_STATEMENT_TYPE2_ID
		AND T.STATEMENT_STATE2_ID = p_STATEMENT_STATE2_ID;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
		p_ABSOLUTE_ERROR_TOL := NULL;
		p_RELATIVE_ERROR_TOL := NULL;
END;
--------------------------------------------------------------------------------
FUNCTION GET_BILLING_ENTITY
(
	p_PARTICIPANT_PSE_ID NUMBER,
	p_COMPONENT VARCHAR2
) RETURN NUMBER IS
	v_BILLING_ENTITY PURCHASING_SELLING_ENTITY.PSE_ID%TYPE;
BEGIN
	SELECT S.SETTLEMENT_PSE_ID INTO v_BILLING_ENTITY
	FROM COMPONENT C,
		SEM_SETTLEMENT_ENTITY S
	WHERE C.COMPONENT_NAME = p_COMPONENT
		AND S.MARKET_NAME = C.COMPONENT_CATEGORY
		AND S.PARTICIPANT_PSE_ID = p_PARTICIPANT_PSE_ID;

	RETURN v_BILLING_ENTITY;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
		RETURN NULL;
END;
--------------------------------------------------------------------------------
FUNCTION GET_ABSOLUTE_ERROR
(
	p_COMPARE_FROM_VALUE NUMBER,
	p_COMPARE_TO_VALUE NUMBER
) RETURN NUMBER IS
BEGIN
	RETURN CASE WHEN p_COMPARE_FROM_VALUE IS NULL OR p_COMPARE_TO_VALUE IS NULL THEN NULL ELSE (p_COMPARE_FROM_VALUE - p_COMPARE_TO_VALUE) END;
END;
--------------------------------------------------------------------------------
FUNCTION GET_RELATIVE_ERROR
(
	p_COMPARE_FROM_VALUE NUMBER,
	p_COMPARE_TO_VALUE NUMBER
) RETURN NUMBER IS
BEGIN
	RETURN CASE WHEN p_COMPARE_TO_VALUE = 0 OR p_COMPARE_FROM_VALUE IS NULL OR p_COMPARE_TO_VALUE IS NULL THEN NULL ELSE (p_COMPARE_FROM_VALUE - p_COMPARE_TO_VALUE)/p_COMPARE_TO_VALUE END;
END;
--------------------------------------------------------------------------------
PROCEDURE GET_SCHED_COMP_STATEMENT_TYPE
(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
) AS
v_IDs ID_TABLE;
BEGIN
	p_STATUS := GA.SUCCESS;

	v_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE('Select by Statement Type',-740);

	OPEN p_CURSOR FOR
		SELECT STATEMENT_TYPE_NAME,
			STATEMENT_TYPE_ID
		FROM STATEMENT_TYPE A,
			TABLE(CAST(v_IDs AS ID_TABLE)) X
		WHERE X.ID IN (A.STATEMENT_TYPE_ID, SD.g_ALL_DATA_ENTITY_ID)
		ORDER BY STATEMENT_TYPE_NAME;

END;
--------------------------------------------------------------------------------
PROCEDURE GET_ERROR_TOLERANCE_RPT
(
	p_STATUS OUT NUMBER,
	p_CURSOR OUT REF_CURSOR
) AS

BEGIN
	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT P.PSE_ID,
			T.COMPARISON_ITEM,
			T.STATEMENT_TYPE1_ID,
			T.STATEMENT_STATE1_ID,
			T.STATEMENT_TYPE2_ID,
			T.STATEMENT_STATE2_ID,
			T.ABSOLUTE_ERROR_TOLERANCE,
			T.RELATIVE_ERROR_TOLERANCE
		FROM SEM_SETTLEMENT_TOLERANCE T,
			PURCHASING_SELLING_ENTITY P
		WHERE P.PSE_ID = T.PSE_ID
		ORDER BY P.PSE_NAME,
				T.COMPARISON_ITEM;
END;
--------------------------------------------------------------------------------
FUNCTION VALIDATE_TOLERANCE_DETAILS
(
	p_PSE_ID IN NUMBER,
	p_COMPARISON_ITEM IN VARCHAR2,
	p_STATEMENT_TYPE1_ID IN NUMBER,
	p_STATEMENT_STATE1_ID IN NUMBER,
	p_STATEMENT_TYPE2_ID IN NUMBER,
	p_STATEMENT_STATE2_ID IN NUMBER,
	p_MESSAGE OUT VARCHAR2
)
RETURN BOOLEAN
AS
p_MISSING_REQ_FIELD VARCHAR2(1024);
TYPE ARRAY IS VARRAY(10) OF VARCHAR2(64);
v_REQ_FIELDS ARRAY := ARRAY();
v_COMMA_OR_AND VARCHAR2(8);
BEGIN

	IF p_PSE_ID IS NULL THEN
		v_REQ_FIELDS.EXTEND();
		v_REQ_FIELDS(v_REQ_FIELDS.LAST) := 'PSE';
	END IF;

	IF p_COMPARISON_ITEM IS NULL THEN
		v_REQ_FIELDS.EXTEND();
		v_REQ_FIELDS(v_REQ_FIELDS.LAST) := 'Determinant';
	END IF;

	IF p_STATEMENT_TYPE1_ID IS NULL THEN
		v_REQ_FIELDS.EXTEND();
		v_REQ_FIELDS(v_REQ_FIELDS.LAST) := 'Statement Type1';
	END IF;

	IF p_STATEMENT_STATE1_ID IS NULL THEN
		v_REQ_FIELDS.EXTEND();
		v_REQ_FIELDS(v_REQ_FIELDS.LAST) := 'Statement State1';
	END IF;

	IF p_STATEMENT_TYPE2_ID IS NULL THEN
		v_REQ_FIELDS.EXTEND();
		v_REQ_FIELDS(v_REQ_FIELDS.LAST) := 'Statement Type2';
	END IF;

	IF p_STATEMENT_STATE2_ID IS NULL THEN
		v_REQ_FIELDS.EXTEND();
		v_REQ_FIELDS(v_REQ_FIELDS.LAST) := 'Statement State2';
	END IF;

	IF v_REQ_FIELDS.COUNT > 0 THEN
		FOR I IN v_REQ_FIELDS.FIRST .. v_REQ_FIELDS.LAST LOOP
			IF I = v_REQ_FIELDS.LAST THEN
				v_COMMA_OR_AND := ' and';
			ELSE
				v_COMMA_OR_AND := ',';
			END IF;

			IF I = v_REQ_FIELDS.FIRST THEN
				p_MISSING_REQ_FIELD := p_MISSING_REQ_FIELD || v_REQ_FIELDS(I);
			ELSE
				p_MISSING_REQ_FIELD := p_MISSING_REQ_FIELD || v_COMMA_OR_AND || ' ' || v_REQ_FIELDS(I);
			END IF;

		END LOOP;
		p_MESSAGE := 'One or more of the following required fields are missing: '
					 || UTL_TCP.CRLF
					 || p_MISSING_REQ_FIELD || '.';
		RETURN FALSE;
	END IF;

	IF p_COMPARISON_ITEM = g_COMBO_LIST_SEPERATOR THEN
		p_MESSAGE := 'Please select a valid Comparison Item.';
		RETURN FALSE;
	END IF;

	RETURN TRUE;
END;
--------------------------------------------------------------------------------
PROCEDURE PUT_ERROR_TOLERANCE
(
	p_PSE_ID IN NUMBER,
	p_COMPARISON_ITEM IN VARCHAR2,
	p_STATEMENT_TYPE1_ID IN NUMBER,
	p_STATEMENT_STATE1_ID IN NUMBER,
	p_STATEMENT_TYPE2_ID IN NUMBER,
	p_STATEMENT_STATE2_ID IN NUMBER,
	p_ABSOLUTE_ERROR_TOLERANCE IN NUMBER,
	p_RELATIVE_ERROR_TOLERANCE IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR2
)
IS
	v_IS_VALID BOOLEAN := FALSE;
BEGIN
	p_STATUS := GA.SUCCESS;

	-- Validate the required fields
	v_IS_VALID := VALIDATE_TOLERANCE_DETAILS(p_PSE_ID, p_COMPARISON_ITEM,
									p_STATEMENT_TYPE1_ID, p_STATEMENT_STATE1_ID,
									p_STATEMENT_TYPE2_ID, p_STATEMENT_STATE2_ID,
									p_MESSAGE);

	IF v_IS_VALID THEN
		-- Try to update an existing record
		UPDATE SEM_SETTLEMENT_TOLERANCE T SET
			T.ABSOLUTE_ERROR_TOLERANCE = p_ABSOLUTE_ERROR_TOLERANCE,
			T.RELATIVE_ERROR_TOLERANCE = p_RELATIVE_ERROR_TOLERANCE
		WHERE T.PSE_ID = p_PSE_ID
			AND T.COMPARISON_ITEM = p_COMPARISON_ITEM
			AND T.STATEMENT_TYPE1_ID = p_STATEMENT_TYPE1_ID
			AND T.STATEMENT_STATE1_ID = p_STATEMENT_STATE1_ID
			AND T.STATEMENT_TYPE2_ID = p_STATEMENT_TYPE2_ID
			AND T.STATEMENT_STATE2_ID = p_STATEMENT_STATE2_ID;

		-- If the previous update did not find a match, then insert a new record.
		IF SQL%NOTFOUND THEN
			INSERT INTO SEM_SETTLEMENT_TOLERANCE
				(PSE_ID,
				COMPARISON_ITEM,
				STATEMENT_TYPE1_ID,
				STATEMENT_STATE1_ID,
				STATEMENT_TYPE2_ID,
				STATEMENT_STATE2_ID,
				ABSOLUTE_ERROR_TOLERANCE,
				RELATIVE_ERROR_TOLERANCE)
			VALUES(
				p_PSE_ID,
				p_COMPARISON_ITEM,
				p_STATEMENT_TYPE1_ID,
				p_STATEMENT_STATE1_ID,
				p_STATEMENT_TYPE2_ID,
				p_STATEMENT_STATE2_ID,
				p_ABSOLUTE_ERROR_TOLERANCE,
				p_RELATIVE_ERROR_TOLERANCE);
		END IF;
	END IF;
END;
------------------------------------------------------------------------------
PROCEDURE DELETE_ERROR_TOLERANCE
(
	p_PSE_ID IN NUMBER,
	p_COMPARISON_ITEM IN VARCHAR2,
	p_STATEMENT_TYPE1_ID IN NUMBER,
	p_STATEMENT_STATE1_ID IN NUMBER,
	p_STATEMENT_TYPE2_ID IN NUMBER,
	p_STATEMENT_STATE2_ID IN NUMBER,
	p_STATUS OUT NUMBER
)
IS
BEGIN
	p_STATUS := GA.SUCCESS;

	DELETE FROM SEM_SETTLEMENT_TOLERANCE T
	WHERE T.PSE_ID = p_PSE_ID
		AND T.COMPARISON_ITEM = p_COMPARISON_ITEM
		AND T.STATEMENT_TYPE1_ID = p_STATEMENT_TYPE1_ID
		AND T.STATEMENT_STATE1_ID = p_STATEMENT_STATE1_ID
		AND T.STATEMENT_TYPE2_ID = p_STATEMENT_TYPE2_ID
		AND T.STATEMENT_STATE2_ID = p_STATEMENT_STATE2_ID;
END;
--------------------------------------------------------------------------------
FUNCTION GET_COMPONENT_FOR_SMP
(
	p_PARTICIPANT_ID IN NUMBER
) RETURN VARCHAR2
IS
	v_EN_CONTRACT_ID INTERCHANGE_CONTRACT.CONTRACT_ID%TYPE;
	v_COMP_NAME EXTERNAL_SYSTEM_IDENTIFIER.EXTERNAL_IDENTIFIER%TYPE;

BEGIN

	--get the energy contract associated with the participant
	SELECT CONTRACT_ID INTO v_EN_CONTRACT_ID
	  FROM INTERCHANGE_CONTRACT
	 WHERE BILLING_ENTITY_ID IN
		  (SELECT SETTLEMENT_PSE_ID
			 FROM SEM_SETTLEMENT_ENTITY
			WHERE PARTICIPANT_PSE_ID = p_PARTICIPANT_ID
			  AND MARKET_NAME = 'EN');

	--BZ 16229: use the components assigned to the energy contract
	--look for 'ENPEX', 'ENCEX', 'ENCJEX' based on the external identifier for the component
	--there is no market participant that will have both 'ENCEX', 'ENCJEX' components
	--therefore this query will always return one line.
	SELECT EXTERNAL_IDENTIFIER INTO v_COMP_NAME
	  FROM (SELECT E.EXTERNAL_IDENTIFIER
			  FROM EXTERNAL_SYSTEM_IDENTIFIER E, CONTRACT_PRODUCT_COMPONENT C
			 WHERE C.CONTRACT_ID = v_EN_CONTRACT_ID
                   AND E.EXTERNAL_SYSTEM_ID = EC.ES_SEM
			   AND E.ENTITY_DOMAIN_ID = EC.ED_COMPONENT
			   AND E.EXTERNAL_IDENTIFIER IN ('ENPEX', 'ENCEX', 'ENCJEX')
			   AND C.COMPONENT_ID = E.ENTITY_ID);
	RETURN v_COMP_NAME;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			RETURN NULL;
	END;
	--------------------------------------------------------------------------------
	FUNCTION GET_COMPONENT_FOR_CPDP
	(
		p_PARTICIPANT_ID IN NUMBER
	) RETURN VARCHAR2
	IS
		v_CONTRACT_ID INTERCHANGE_CONTRACT.CONTRACT_ID%TYPE;
		v_COMP_NAME EXTERNAL_SYSTEM_IDENTIFIER.EXTERNAL_IDENTIFIER%TYPE;

	BEGIN

		--get the energy contract associated with the participant
        SELECT CONTRACT_ID INTO v_CONTRACT_ID
          FROM INTERCHANGE_CONTRACT
         WHERE BILLING_ENTITY_ID IN
              (SELECT SETTLEMENT_PSE_ID
                 FROM SEM_SETTLEMENT_ENTITY
                WHERE PARTICIPANT_PSE_ID = p_PARTICIPANT_ID
                  AND MARKET_NAME = 'CA');

		--bz 18702: for the ESU participant we have to get CPDP from CCJEX; otherwise we get it from CCEX
		--there is no market participant that will have both CCEX and CCJEX components
		--therefore this query will always return one line.
        SELECT EXTERNAL_IDENTIFIER INTO v_COMP_NAME
          FROM (SELECT E.EXTERNAL_IDENTIFIER
                  FROM EXTERNAL_SYSTEM_IDENTIFIER E, CONTRACT_PRODUCT_COMPONENT C
                 WHERE C.CONTRACT_ID = v_CONTRACT_ID
                   AND E.EXTERNAL_SYSTEM_ID = EC.ES_SEM
				   AND E.ENTITY_DOMAIN_ID = EC.ED_COMPONENT
                   AND E.EXTERNAL_IDENTIFIER IN ('CCEX', 'CCJEX')
                   AND C.COMPONENT_ID = E.ENTITY_ID);
		RETURN v_COMP_NAME;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			RETURN NULL;
	END GET_COMPONENT_FOR_CPDP;
	--------------------------------------------------------------------------------
	FUNCTION GET_COMPONENT_FOR_MG
	(
		p_PARTICIPANT_ID IN NUMBER
	) RETURN VARCHAR2
	IS
		v_CONTRACT_ID INTERCHANGE_CONTRACT.CONTRACT_ID%TYPE;
		v_COMP_NAME EXTERNAL_SYSTEM_IDENTIFIER.EXTERNAL_IDENTIFIER%TYPE;

	BEGIN

		--get the energy contract associated with the participant
        SELECT CONTRACT_ID INTO v_CONTRACT_ID
          FROM INTERCHANGE_CONTRACT
         WHERE BILLING_ENTITY_ID IN
              (SELECT SETTLEMENT_PSE_ID
                 FROM SEM_SETTLEMENT_ENTITY
                WHERE PARTICIPANT_PSE_ID = p_PARTICIPANT_ID
                  AND MARKET_NAME = 'EN');

		-- 4-may-2009, jbc, bz 18588:
		--The original MG comparison used UNIMPEX, but wind and DSU participants
		--don't get charged this. Wind participants get charged TCHAREX (as do the participants
		--that get charged UNIMPEX), but DSUs don't get charged either. So, we start w/ UNIMPEX
		--for historical reasons; if we can't find that we look for TCHAREX, and finally land on ENPEX.
		--Note that unlike the other GET_COMPONENT_FOR_* functions, this contract can have all of
		--these components assigned, so we go in priority order (UNIMPEX for historical use, TCHAREX
		--for APTGs, and finally ENPEX for DSUs).
        SELECT EXTERNAL_IDENTIFIER INTO v_COMP_NAME
          FROM (SELECT E.EXTERNAL_IDENTIFIER
                  FROM EXTERNAL_SYSTEM_IDENTIFIER E, CONTRACT_PRODUCT_COMPONENT C
                 WHERE C.CONTRACT_ID = v_CONTRACT_ID
                   AND E.EXTERNAL_SYSTEM_ID = EC.ES_SEM
				   AND E.ENTITY_DOMAIN_ID = EC.ED_COMPONENT
                   AND E.EXTERNAL_IDENTIFIER IN ('UNIMPEX', 'TCHAREX', 'ENPEX')
                   AND C.COMPONENT_ID = E.ENTITY_ID
				   ORDER BY 1 DESC)
		WHERE ROWNUM = 1;
		RETURN v_COMP_NAME;

	EXCEPTION
	WHEN NO_DATA_FOUND THEN
		RETURN NULL;
	END GET_COMPONENT_FOR_MG;
	--------------------------------------------------------------------------------
	-- This procedure is used by the UI report and the Alerts
	--------------------------------------------------------------------------------
	PROCEDURE GET_STATEMENT_COMPARISON_RPT
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PARTICIPANT_ID IN NUMBER,
	p_COMPARISON_ITEM IN VARCHAR2,
	p_COMP_FROM_STATEMENT_TYPE_ID IN NUMBER,
	p_COMP_TO_STATEMENT_TYPE_ID IN NUMBER,
	p_COMP_FROM_STATEMENT_STATE IN NUMBER,
	p_COMP_TO_STATEMENT_STATE IN NUMBER,
	p_VIOLATIONS_ONLY IN NUMBER DEFAULT 0,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR,
	p_MESSAGE OUT VARCHAR2
) AS
	v_ABSOLUTE_ERROR_TOLERANCE NUMBER;
	v_RELATIVE_ERROR_TOLERANCE NUMBER;

	v_COMPONENT COMPONENT.COMPONENT_NAME%TYPE;
	v_VARIABLE_NAME FORMULA_CHARGE_VARIABLE.VARIABLE_NAME%TYPE;
	v_COMPARISON_TYPE VARCHAR2(32);
	v_BILLING_ENTITY_ID NUMBER;

	v_USE_FORMULA_VARIABLE BOOLEAN := FALSE;
BEGIN
	p_STATUS := GA.SUCCESS;

	-- Make sure that the combo list seperator is not selected
	IF p_COMPARISON_ITEM = g_COMBO_LIST_SEPERATOR THEN
		p_MESSAGE := 'Please select a valid Comparison Item.';
		NULL_CURSOR(p_CURSOR);
		RETURN;
	END IF;

	-- Get the Absolute and Relative Error Tolerances
	GET_TOLERANCES(p_PARTICIPANT_ID,
					p_COMPARISON_ITEM,
					p_COMP_FROM_STATEMENT_TYPE_ID,
					p_COMP_FROM_STATEMENT_STATE,
					p_COMP_TO_STATEMENT_TYPE_ID,
					p_COMP_TO_STATEMENT_STATE,
					v_ABSOLUTE_ERROR_TOLERANCE,
					v_RELATIVE_ERROR_TOLERANCE,
					p_STATUS);

	-- Set Component, Variable Name and Comparison Type variable
	CASE
		--------------------------------------------
		--- Market Prices Determinants
		--------------------------------------------
		-- SMP
		WHEN p_COMPARISON_ITEM = g_COMPARISON_ITEM_SMP THEN
			v_COMPONENT := GET_COMPONENT_FOR_SMP(p_PARTICIPANT_ID);
			v_VARIABLE_NAME := 'SMP';
			v_COMPARISON_TYPE := g_COMP_TYPE_MP;
		-- CPDP
		WHEN p_COMPARISON_ITEM = g_COMPARISON_ITEM_CPDP THEN
			v_COMPONENT := 'CCEX';
			v_VARIABLE_NAME := 'CPDP';
			v_COMPARISON_TYPE := g_COMP_TYPE_MP;
		-- CPGP
		WHEN p_COMPARISON_ITEM = g_COMPARISON_ITEM_CPGP THEN
			v_COMPONENT := 'CPEX';
			v_VARIABLE_NAME := 'CPGPrice';
			v_COMPARISON_TYPE := g_COMP_TYPE_MP;
		--------------------------------------------
		-- Schedules Determinants
		--------------------------------------------
		-- ND
		WHEN p_COMPARISON_ITEM = g_COMPARISON_ITEM_NET_DEMAND THEN
			v_COMPONENT := 'ENCEX';
				v_VARIABLE_NAME := 'NDLF';
			v_COMPARISON_TYPE := g_COMP_TYPE_SCHEDULE;
				v_USE_FORMULA_VARIABLE := TRUE;
			-- MD
			WHEN p_COMPARISON_ITEM = g_COMPARISON_ITEM_MD THEN
				v_COMPONENT := 'ENCEX';
				v_VARIABLE_NAME := 'MD';
				v_COMPARISON_TYPE := g_COMP_TYPE_SCHEDULE;
				v_USE_FORMULA_VARIABLE := TRUE;
		-- MSQ
		WHEN p_COMPARISON_ITEM = g_COMPARISON_ITEM_MSQ_GEN THEN
			v_COMPONENT := 'ENPEX';
			v_VARIABLE_NAME := 'MSQ';
			v_COMPARISON_TYPE := g_COMP_TYPE_SCHEDULE;
			v_USE_FORMULA_VARIABLE := TRUE;
		-- DQ
		WHEN p_COMPARISON_ITEM = g_COMPARISON_ITEM_DISPATCH_QTY THEN
			v_COMPONENT := 'ENPEX';
			v_VARIABLE_NAME := 'DQ';
			v_COMPARISON_TYPE := g_COMP_TYPE_SCHEDULE;
			v_USE_FORMULA_VARIABLE := TRUE;
		-- EA
		WHEN p_COMPARISON_ITEM = g_COMPARISON_ITEM_EGBL_AVAL THEN
			v_COMPONENT := 'CPEX';
			v_VARIABLE_NAME := 'EA';
			v_COMPARISON_TYPE := g_COMP_TYPE_SCHEDULE;
			v_USE_FORMULA_VARIABLE := TRUE;
		-- MG
		WHEN p_COMPARISON_ITEM = g_COMPARISON_ITEM_METERED_GEN THEN
				v_COMPONENT := GET_COMPONENT_FOR_MG(p_PARTICIPANT_ID);
				v_VARIABLE_NAME := CASE v_COMPONENT WHEN 'UNIMPEX' THEN 'ActualOutput' WHEN 'TCHAREX' THEN 'MG' ELSE 'MG_inp' END;
			v_COMPARISON_TYPE := g_COMP_TYPE_SCHEDULE;
			v_USE_FORMULA_VARIABLE := TRUE;
		-- NDLFESU
		WHEN p_COMPARISON_ITEM = g_COMPARISON_ITEM_NDLFESU THEN
			v_COMPONENT := 'ENCJEX';
			v_COMPARISON_TYPE := g_COMP_TYPE_SCHEDULE;
			v_USE_FORMULA_VARIABLE := FALSE;
		--------------------------------------------
		-- Other Components
		--------------------------------------------
		ELSE
			v_COMPONENT := p_COMPARISON_ITEM;
			v_COMPARISON_TYPE := g_COMP_TYPE_COMPONENT;
	END CASE;

	-- Get the Billing Entity ID based on the component and Participant
	v_BILLING_ENTITY_ID := GET_BILLING_ENTITY(p_PARTICIPANT_ID, v_COMPONENT);

	CASE
		-- Market Price Items
		WHEN v_COMPARISON_TYPE = g_COMP_TYPE_MP THEN
			OPEN p_CURSOR FOR
				SELECT * FROM
					(SELECT FROM_CUT_AS_HED(NVL(X.CHARGE_DATE, Y.CHARGE_DATE), MM_SEM_UTIL.g_TZ, 'MI30') AS CHARGE_DATE,
							NULL AS RESOURCE_NAME,
							X.VAL AS COMPARE_FROM_VALUE,
							Y.VAL AS COMPARE_TO_VALUE,
							GET_ABSOLUTE_ERROR(X.VAL,Y.VAL) AS ABSOLUTE_ERROR,
							GET_RELATIVE_ERROR(X.VAL,Y.VAL) AS RELATIVE_ERROR,
							v_ABSOLUTE_ERROR_TOLERANCE AS ABSOLUTE_ERROR_TOLERANCE,
							v_RELATIVE_ERROR_TOLERANCE AS RELATIVE_ERROR_TOLERANCE
					FROM
						(SELECT DISTINCT F.CHARGE_DATE, F.VARIABLE_VAL AS VAL
						 FROM COMPONENT C,
							BILLING_STATEMENT B,
							FORMULA_CHARGE_VARIABLE F
						 WHERE C.COMPONENT_NAME = v_COMPONENT
							AND B.COMPONENT_ID = C.COMPONENT_ID
							AND B.ENTITY_ID = v_BILLING_ENTITY_ID
							AND B.STATEMENT_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
							AND B.STATEMENT_TYPE = p_COMP_FROM_STATEMENT_TYPE_ID
							AND B.STATEMENT_STATE = p_COMP_FROM_STATEMENT_STATE
							AND F.CHARGE_ID = B.CHARGE_ID
							AND F.VARIABLE_NAME = v_VARIABLE_NAME) X FULL OUTER JOIN
						(SELECT DISTINCT F.CHARGE_DATE, F.VARIABLE_VAL AS VAL
						 FROM COMPONENT C,
							BILLING_STATEMENT B,
							FORMULA_CHARGE_VARIABLE F
						 WHERE C.COMPONENT_NAME = v_COMPONENT
							AND B.COMPONENT_ID = C.COMPONENT_ID
							AND B.ENTITY_ID = v_BILLING_ENTITY_ID
							AND B.STATEMENT_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
							AND B.STATEMENT_TYPE = p_COMP_TO_STATEMENT_TYPE_ID
							AND B.STATEMENT_STATE = p_COMP_TO_STATEMENT_STATE
							AND F.CHARGE_ID = B.CHARGE_ID
							AND F.VARIABLE_NAME = v_VARIABLE_NAME) Y
					ON Y.CHARGE_DATE = X.CHARGE_DATE)
				WHERE (p_VIOLATIONS_ONLY = 1 AND ABSOLUTE_ERROR > v_ABSOLUTE_ERROR_TOLERANCE)
						OR (p_VIOLATIONS_ONLY = 1 AND RELATIVE_ERROR > v_RELATIVE_ERROR_TOLERANCE)
						OR (p_VIOLATIONS_ONLY = 0)
				ORDER BY CHARGE_DATE;
		-- Schedule Type Items
		WHEN v_COMPARISON_TYPE = g_COMP_TYPE_SCHEDULE THEN
			-- Get the Variable Value from the Formula_Charge_Variable table
			IF v_USE_FORMULA_VARIABLE THEN
				OPEN p_CURSOR FOR
					SELECT * FROM
						(SELECT FROM_CUT_AS_HED(NVL(X.CHARGE_DATE, Y.CHARGE_DATE), MM_SEM_UTIL.g_TZ, 'MI30') AS CHARGE_DATE,
								NVL(X.RESOURCE_NAME, Y.RESOURCE_NAME) AS RESOURCE_NAME,
								X.VAL AS COMPARE_FROM_VALUE,
								Y.VAL AS COMPARE_TO_VALUE,
								GET_ABSOLUTE_ERROR(X.VAL,Y.VAL) AS ABSOLUTE_ERROR,
								GET_RELATIVE_ERROR(X.VAL,Y.VAL) AS RELATIVE_ERROR,
								v_ABSOLUTE_ERROR_TOLERANCE AS ABSOLUTE_ERROR_TOLERANCE,
								v_RELATIVE_ERROR_TOLERANCE AS RELATIVE_ERROR_TOLERANCE
						FROM
							(SELECT F.CHARGE_DATE, F.VARIABLE_VAL AS VAL, I.ITERATOR1 AS RESOURCE_NAME
							 FROM COMPONENT C,
								BILLING_STATEMENT B,
								FORMULA_CHARGE_VARIABLE F,
								FORMULA_CHARGE_ITERATOR I
							 WHERE C.COMPONENT_NAME = v_COMPONENT
								AND B.COMPONENT_ID = C.COMPONENT_ID
								AND B.ENTITY_ID = v_BILLING_ENTITY_ID
								AND B.STATEMENT_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
								AND B.STATEMENT_TYPE = p_COMP_FROM_STATEMENT_TYPE_ID
								AND B.STATEMENT_STATE = p_COMP_FROM_STATEMENT_STATE
								AND F.CHARGE_ID = B.CHARGE_ID
								AND F.VARIABLE_NAME = v_VARIABLE_NAME
								AND I.CHARGE_ID = F.CHARGE_ID
								AND I.ITERATOR_ID = F.ITERATOR_ID) X FULL OUTER JOIN
							(SELECT F.CHARGE_DATE, F.VARIABLE_VAL AS VAL, I.ITERATOR1 AS RESOURCE_NAME
							 FROM COMPONENT C,
								BILLING_STATEMENT B,
								FORMULA_CHARGE_VARIABLE F,
								FORMULA_CHARGE_ITERATOR I
							 WHERE C.COMPONENT_NAME = v_COMPONENT
								AND B.COMPONENT_ID = C.COMPONENT_ID
								AND B.ENTITY_ID = v_BILLING_ENTITY_ID
								AND B.STATEMENT_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
								AND B.STATEMENT_TYPE = p_COMP_TO_STATEMENT_TYPE_ID
								AND B.STATEMENT_STATE = p_COMP_TO_STATEMENT_STATE
								AND F.CHARGE_ID = B.CHARGE_ID
								AND F.VARIABLE_NAME = v_VARIABLE_NAME
								AND I.CHARGE_ID = F.CHARGE_ID
								AND I.ITERATOR_ID = F.ITERATOR_ID) Y
						ON Y.CHARGE_DATE = X.CHARGE_DATE
							AND Y.RESOURCE_NAME = X.RESOURCE_NAME)
					WHERE (p_VIOLATIONS_ONLY = 1 AND ABSOLUTE_ERROR > v_ABSOLUTE_ERROR_TOLERANCE)
						OR (p_VIOLATIONS_ONLY = 1 AND RELATIVE_ERROR > v_RELATIVE_ERROR_TOLERANCE)
						OR (p_VIOLATIONS_ONLY = 0)
					ORDER BY RESOURCE_NAME, CHARGE_DATE;
			ELSE
				-- Get the Charge Qty from the Formula_Charge table
				OPEN p_CURSOR FOR
					SELECT * FROM
						(SELECT FROM_CUT_AS_HED(NVL(X.CHARGE_DATE, Y.CHARGE_DATE), MM_SEM_UTIL.g_TZ, 'MI30') AS CHARGE_DATE,
								NVL(X.RESOURCE_NAME, Y.RESOURCE_NAME) AS RESOURCE_NAME,
								X.VAL AS COMPARE_FROM_VALUE,
								Y.VAL AS COMPARE_TO_VALUE,
								GET_ABSOLUTE_ERROR(X.VAL,Y.VAL) AS ABSOLUTE_ERROR,
								GET_RELATIVE_ERROR(X.VAL,Y.VAL) AS RELATIVE_ERROR,
								v_ABSOLUTE_ERROR_TOLERANCE AS ABSOLUTE_ERROR_TOLERANCE,
								v_RELATIVE_ERROR_TOLERANCE AS RELATIVE_ERROR_TOLERANCE
						FROM
							(SELECT FC.CHARGE_DATE, FC.CHARGE_QUANTITY AS VAL, I.ITERATOR1 AS RESOURCE_NAME
							 FROM COMPONENT C,
								BILLING_STATEMENT B,
								FORMULA_CHARGE FC,
								FORMULA_CHARGE_ITERATOR I
							 WHERE C.COMPONENT_NAME = v_COMPONENT
								AND B.COMPONENT_ID = C.COMPONENT_ID
								AND B.ENTITY_ID = v_BILLING_ENTITY_ID
								AND B.STATEMENT_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
								AND B.STATEMENT_TYPE = p_COMP_FROM_STATEMENT_TYPE_ID
								AND B.STATEMENT_STATE = p_COMP_FROM_STATEMENT_STATE
								AND FC.CHARGE_ID = B.CHARGE_ID
								AND I.CHARGE_ID = FC.CHARGE_ID
								AND I.ITERATOR_ID = FC.ITERATOR_ID) X FULL OUTER JOIN
							(SELECT FC.CHARGE_DATE, FC.CHARGE_QUANTITY AS VAL, I.ITERATOR1 AS RESOURCE_NAME
							 FROM COMPONENT C,
								BILLING_STATEMENT B,
								FORMULA_CHARGE FC,
								FORMULA_CHARGE_ITERATOR I
							 WHERE C.COMPONENT_NAME = v_COMPONENT
								AND B.COMPONENT_ID = C.COMPONENT_ID
								AND B.ENTITY_ID = v_BILLING_ENTITY_ID
								AND B.STATEMENT_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
								AND B.STATEMENT_TYPE = p_COMP_TO_STATEMENT_TYPE_ID
								AND B.STATEMENT_STATE = p_COMP_TO_STATEMENT_STATE
								AND FC.CHARGE_ID = B.CHARGE_ID
								AND I.CHARGE_ID = FC.CHARGE_ID
								AND I.ITERATOR_ID = FC.ITERATOR_ID) Y
						ON Y.CHARGE_DATE = X.CHARGE_DATE
							AND Y.RESOURCE_NAME = X.RESOURCE_NAME)
					WHERE (p_VIOLATIONS_ONLY = 1 AND ABSOLUTE_ERROR > v_ABSOLUTE_ERROR_TOLERANCE)
						OR (p_VIOLATIONS_ONLY = 1 AND RELATIVE_ERROR > v_RELATIVE_ERROR_TOLERANCE)
						OR (p_VIOLATIONS_ONLY = 0)
					ORDER BY RESOURCE_NAME, CHARGE_DATE;
			END IF;
		WHEN v_COMPARISON_TYPE = g_COMP_TYPE_COMPONENT THEN
			-- Get the Charge Amount from the Formula_Charge table
				OPEN p_CURSOR FOR
					SELECT * FROM
						(SELECT FROM_CUT_AS_HED(NVL(X.CHARGE_DATE, Y.CHARGE_DATE), MM_SEM_UTIL.g_TZ, 'MI30') AS CHARGE_DATE,
								NVL(X.RESOURCE_NAME, Y.RESOURCE_NAME) AS RESOURCE_NAME,
								X.VAL AS COMPARE_FROM_VALUE,
								Y.VAL AS COMPARE_TO_VALUE,
								GET_ABSOLUTE_ERROR(X.VAL,Y.VAL) AS ABSOLUTE_ERROR,
								GET_RELATIVE_ERROR(X.VAL,Y.VAL) AS RELATIVE_ERROR,
								v_ABSOLUTE_ERROR_TOLERANCE AS ABSOLUTE_ERROR_TOLERANCE,
								v_RELATIVE_ERROR_TOLERANCE AS RELATIVE_ERROR_TOLERANCE
						FROM
							(SELECT FC.CHARGE_DATE, FC.CHARGE_AMOUNT AS VAL, I.ITERATOR1 AS RESOURCE_NAME
							 FROM COMPONENT C,
								BILLING_STATEMENT B,
								FORMULA_CHARGE FC,
								FORMULA_CHARGE_ITERATOR I
							 WHERE C.COMPONENT_NAME = v_COMPONENT
								AND B.COMPONENT_ID = C.COMPONENT_ID
								AND B.ENTITY_ID = v_BILLING_ENTITY_ID
								AND B.STATEMENT_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
								AND B.STATEMENT_TYPE = p_COMP_FROM_STATEMENT_TYPE_ID
								AND B.STATEMENT_STATE = p_COMP_FROM_STATEMENT_STATE
								AND FC.CHARGE_ID = B.CHARGE_ID
								AND I.CHARGE_ID = FC.CHARGE_ID
								AND I.ITERATOR_ID = FC.ITERATOR_ID) X FULL OUTER JOIN
							(SELECT FC.CHARGE_DATE, FC.CHARGE_AMOUNT AS VAL, I.ITERATOR1 AS RESOURCE_NAME
							 FROM COMPONENT C,
								BILLING_STATEMENT B,
								FORMULA_CHARGE FC,
								FORMULA_CHARGE_ITERATOR I
							 WHERE C.COMPONENT_NAME = v_COMPONENT
								AND B.COMPONENT_ID = C.COMPONENT_ID
								AND B.ENTITY_ID = v_BILLING_ENTITY_ID
								AND B.STATEMENT_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
								AND B.STATEMENT_TYPE = p_COMP_TO_STATEMENT_TYPE_ID
								AND B.STATEMENT_STATE = p_COMP_TO_STATEMENT_STATE
								AND FC.CHARGE_ID = B.CHARGE_ID
								AND I.CHARGE_ID = FC.CHARGE_ID
								AND I.ITERATOR_ID = FC.ITERATOR_ID) Y
						ON Y.CHARGE_DATE = X.CHARGE_DATE
							AND Y.RESOURCE_NAME = X.RESOURCE_NAME)
					WHERE (p_VIOLATIONS_ONLY = 1 AND ABSOLUTE_ERROR > v_ABSOLUTE_ERROR_TOLERANCE)
						OR (p_VIOLATIONS_ONLY = 1 AND RELATIVE_ERROR > v_RELATIVE_ERROR_TOLERANCE)
						OR (p_VIOLATIONS_ONLY = 0)
					ORDER BY RESOURCE_NAME, CHARGE_DATE;
		ELSE
			NULL_CURSOR(p_CURSOR);
	END CASE;
END;
--------------------------------------------------------------------------------
-- This procedure is used by the UI report and the Alerts
--------------------------------------------------------------------------------
PROCEDURE GET_INVOICE_COMPARISON_RPT
(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PARTICIPANT_ID IN NUMBER,
	p_COMPARISON_ITEM IN VARCHAR2,
	p_COMP_FROM_STATEMENT_TYPE_ID IN NUMBER,
	p_COMP_TO_STATEMENT_TYPE_ID IN NUMBER,
	p_COMP_FROM_STATEMENT_STATE IN NUMBER,
	p_COMP_TO_STATEMENT_STATE IN NUMBER,
	p_VIOLATIONS_ONLY IN NUMBER DEFAULT 0,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
) AS
	v_ABSOLUTE_ERROR_TOLERANCE NUMBER;
	v_RELATIVE_ERROR_TOLERANCE NUMBER;
	v_BILLING_ENTITY_ID NUMBER;
	v_REVERSE_SIGN_CONSTANT NUMBER := 1;
BEGIN
	p_STATUS := GA.SUCCESS;

	-- Get the Absolute and Relative Error Tolerances
	GET_TOLERANCES(p_PARTICIPANT_ID,
					p_COMPARISON_ITEM,
					p_COMP_FROM_STATEMENT_TYPE_ID,
					p_COMP_FROM_STATEMENT_STATE,
					p_COMP_TO_STATEMENT_TYPE_ID,
					p_COMP_TO_STATEMENT_STATE,
					v_ABSOLUTE_ERROR_TOLERANCE,
					v_RELATIVE_ERROR_TOLERANCE,
					p_STATUS);

	-- Get the Billing Entity ID based on the component and Participant
	v_BILLING_ENTITY_ID := GET_BILLING_ENTITY(p_PARTICIPANT_ID, p_COMPARISON_ITEM);

	IF GA.ENABLE_REVERSE_SIGN_INVOICES = TRUE THEN
		v_REVERSE_SIGN_CONSTANT := -1;
	END IF;

	OPEN p_CURSOR FOR
		SELECT *
		FROM (SELECT BEGIN_DATE,
				END_DATE,
				COMPARE_FROM_VALUE,
				COMPARE_TO_VALUE,
				GET_ABSOLUTE_ERROR(COMPARE_FROM_VALUE, COMPARE_TO_VALUE) AS ABSOLUTE_ERROR,
				GET_RELATIVE_ERROR(COMPARE_FROM_VALUE, COMPARE_TO_VALUE) AS RELATIVE_ERROR,
				v_ABSOLUTE_ERROR_TOLERANCE AS ABSOLUTE_ERROR_TOLERANCE,
				v_RELATIVE_ERROR_TOLERANCE AS RELATIVE_ERROR_TOLERANCE
			FROM (SELECT I.BEGIN_DATE, -- Invoice query
					I.END_DATE,
					L.LINE_ITEM_AMOUNT AS COMPARE_TO_VALUE,
					-- Get the Statement Value with the date range of the Invoice
					-- Reverse the sign if the GA.ENABLE_REVERSE_SIGN_INVOICES is TRUE
					(SELECT v_REVERSE_SIGN_CONSTANT * SUM(B.CHARGE_AMOUNT)
					FROM COMPONENT C,
						BILLING_STATEMENT B
					WHERE C.COMPONENT_NAME = p_COMPARISON_ITEM
						AND B.COMPONENT_ID = C.COMPONENT_ID
						AND B.ENTITY_ID = v_BILLING_ENTITY_ID
						AND B.STATEMENT_DATE BETWEEN I.BEGIN_DATE AND I.END_DATE
						AND B.STATEMENT_TYPE = p_COMP_FROM_STATEMENT_TYPE_ID
						AND B.STATEMENT_STATE = p_COMP_FROM_STATEMENT_STATE) AS COMPARE_FROM_VALUE
				FROM INVOICE_LINE_ITEM L,
					INVOICE I,
					COMPONENT C
				WHERE I.INVOICE_ID = L.INVOICE_ID
					AND I.ENTITY_ID = v_BILLING_ENTITY_ID
					AND C.COMPONENT_ID = L.COMPONENT_ID
					AND C.COMPONENT_NAME = p_COMPARISON_ITEM
					AND I.BEGIN_DATE <= p_END_DATE
					AND I.END_DATE >= p_BEGIN_DATE
					AND I.STATEMENT_TYPE = p_COMP_TO_STATEMENT_TYPE_ID
					AND I.STATEMENT_STATE = p_COMP_TO_STATEMENT_STATE)
			ORDER BY BEGIN_DATE, END_DATE)
		WHERE (p_VIOLATIONS_ONLY = 1 AND ABSOLUTE_ERROR > v_ABSOLUTE_ERROR_TOLERANCE)
				OR (p_VIOLATIONS_ONLY = 1 AND RELATIVE_ERROR > v_RELATIVE_ERROR_TOLERANCE)
				OR (p_VIOLATIONS_ONLY = 0);
END;
--------------------------------------------------------------------------------
PROCEDURE RAISE_VARIANCE_ALERTS
(
	p_OPERATING_DAY IN DATE,
	p_COMPARISON_TYPE IN VARCHAR2,
	p_STATUS OUT NUMBER
) AS
	v_STATUS NUMBER;
	v_CURSOR REF_CURSOR;
	v_MESSAGE VARCHAR2(2000);
	v_ITEM_DETAIL_CATEGORY VARCHAR2(32);
	v_CHARGE_DATE DATE;
	v_BEGIN_DATE DATE;
	v_END_DATE DATE;
	v_RESOURCE_NAME SERVICE_POINT.SERVICE_POINT_NAME%TYPE;
	v_COMPARE_FROM_VALUE NUMBER;
	v_COMPARE_TO_VALUE NUMBER;
	v_ABSOLUTE_ERROR NUMBER;
	v_RELATIVE_ERROR NUMBER;
	v_ABS_ERROR_TOL NUMBER;
	v_REL_ERROR_TOL NUMBER;

	-- Cursor to get all the statement days for an operating day
	CURSOR c_STATEMENT_DAY (v_OPERATING_DATE IN DATE, v_PUBLICATION_TYPE IN VARCHAR2) IS
		SELECT DISTINCT C.BEGIN_DATE, C.END_DATE
		FROM SEM_SETTLEMENT_CALENDAR C
		WHERE C.PUBLICATION_DATE = TRUNC(p_OPERATING_DAY, 'DD')
		  AND C.PUBLICATION_TYPE = v_PUBLICATION_TYPE
		ORDER BY BEGIN_DATE, END_DATE;

	-- Cursor to get all the tolerance specifications
	CURSOR c_TOLERANCE_SPEC IS
		SELECT PSE_ID,
			COMPARISON_ITEM,
			STATEMENT_TYPE1_ID,
			STATEMENT_STATE1_ID,
			STATEMENT_TYPE2_ID,
			STATEMENT_STATE2_ID
		FROM SEM_SETTLEMENT_TOLERANCE;

BEGIN
	p_STATUS := GA.SUCCESS;

	-- Get the Item Detail Category required for Statement days
	IF (UPPER(TRIM(p_COMPARISON_TYPE)) = UPPER(g_STATEMENT_COMPARISON)) THEN
		v_ITEM_DETAIL_CATEGORY := MM_SEM_SETTLEMENT_CALENDAR.c_PUBLICATION_TYPE_REPORT;
	ELSIF (UPPER(TRIM(p_COMPARISON_TYPE)) = UPPER(g_INVOICE_COMPARISON)) THEN
		v_ITEM_DETAIL_CATEGORY := MM_SEM_SETTLEMENT_CALENDAR.c_PUBLICATION_TYPE_INVOICE;
	ELSE
		v_ITEM_DETAIL_CATEGORY := NULL;
	END IF;

	-- Loop through all the statement dates
	FOR v_STATEMENT_DAY IN c_STATEMENT_DAY(p_OPERATING_DAY, v_ITEM_DETAIL_CATEGORY) LOOP
		-- Loop through the tolerances
		FOR PSE_TOL_DETAILS IN c_TOLERANCE_SPEC LOOP
			-- Statement Comparison
			IF (UPPER(TRIM(p_COMPARISON_TYPE)) = UPPER(g_STATEMENT_COMPARISON)) THEN
				GET_STATEMENT_COMPARISON_RPT(v_STATEMENT_DAY.BEGIN_DATE, -- Begin Date
											 v_STATEMENT_DAY.END_DATE, -- End Date
											 PSE_TOL_DETAILS.PSE_ID, -- Participant
											 PSE_TOL_DETAILS.COMPARISON_ITEM, -- Comparison Item Determinant or Component
											 PSE_TOL_DETAILS.STATEMENT_TYPE1_ID, -- Statement Type1
											 PSE_TOL_DETAILS.STATEMENT_TYPE2_ID, -- Statement Type2
											 PSE_TOL_DETAILS.STATEMENT_STATE1_ID, -- Statement State1
											 PSE_TOL_DETAILS.STATEMENT_STATE2_ID, -- Statement State2
											 1, -- Violation Only
											 v_STATUS,
											 v_CURSOR,
											 v_MESSAGE);

				-- If there are one or more records, get the first record and raise an alert
				LOOP
				FETCH v_CURSOR INTO v_CHARGE_DATE, v_RESOURCE_NAME, v_COMPARE_FROM_VALUE, v_COMPARE_TO_VALUE,
									v_ABSOLUTE_ERROR, v_RELATIVE_ERROR, v_ABS_ERROR_TOL, v_REL_ERROR_TOL;
					IF v_CURSOR%FOUND THEN
							ALERTS.TRIGGER_ALERTS(g_TOLERANCE_SYS_ALERT,
												  LOGS.c_LEVEL_NOTICE,
											  'Tolerance values breached for Partipant: ' || EI.GET_ENTITY_NAME(EC.ED_PSE, PSE_TOL_DETAILS.PSE_ID) || UTL_TCP.CRLF
														 || CASE WHEN v_RESOURCE_NAME IS NULL THEN '' ELSE 'Resource: ' || v_RESOURCE_NAME || UTL_TCP.CRLF END
														 || 'Date: ' || v_CHARGE_DATE || UTL_TCP.CRLF
														 || 'Comparison Item: ' || PSE_TOL_DETAILS.COMPARISON_ITEM || UTL_TCP.CRLF
														 || 'Compare From Statement Type: ' || EI.GET_ENTITY_NAME(EC.ED_STATEMENT_TYPE, PSE_TOL_DETAILS.STATEMENT_TYPE1_ID) || UTL_TCP.CRLF
														 || 'Compare From Statement State: ' || CASE WHEN PSE_TOL_DETAILS.STATEMENT_STATE1_ID = 1 THEN 'Internal' ELSE 'External' END || UTL_TCP.CRLF
														 || 'Compare To Statement Type: ' || EI.GET_ENTITY_NAME(EC.ED_STATEMENT_TYPE, PSE_TOL_DETAILS.STATEMENT_TYPE2_ID) || UTL_TCP.CRLF
														 || 'Compare To Statement State: ' || CASE WHEN PSE_TOL_DETAILS.STATEMENT_STATE2_ID = 1 THEN 'Internal' ELSE 'External' END || UTL_TCP.CRLF
												  );
/*
							ALERTS.SEND_ALERT(g_TOLERANCE_SYS_ALERT,
										  'Tolerance values breached for Partipant: ' || EI.GET_ENTITY_NAME(EC.ED_PSE, PSE_TOL_DETAILS.PSE_ID) || UTL_TCP.CRLF
													 || CASE WHEN v_RESOURCE_NAME IS NULL THEN '' ELSE 'Resource: ' || v_RESOURCE_NAME || UTL_TCP.CRLF END
													 || 'Date: ' || v_CHARGE_DATE || UTL_TCP.CRLF
													 || 'Comparison Item: ' || PSE_TOL_DETAILS.COMPARISON_ITEM || UTL_TCP.CRLF
													 || 'Compare From Statement Type: ' || EI.GET_ENTITY_NAME(EC.ED_STATEMENT_TYPE, PSE_TOL_DETAILS.STATEMENT_TYPE1_ID) || UTL_TCP.CRLF
													 || 'Compare From Statement State: ' || CASE WHEN PSE_TOL_DETAILS.STATEMENT_STATE1_ID = 1 THEN 'Internal' ELSE 'External' END || UTL_TCP.CRLF
													 || 'Compare To Statement Type: ' || EI.GET_ENTITY_NAME(EC.ED_STATEMENT_TYPE, PSE_TOL_DETAILS.STATEMENT_TYPE2_ID) || UTL_TCP.CRLF
													 || 'Compare To Statement State: ' || CASE WHEN PSE_TOL_DETAILS.STATEMENT_STATE2_ID = 1 THEN 'Internal' ELSE 'External' END || UTL_TCP.CRLF,
										  v_STATUS,
											  ML.c_PRIORITY_NORMAL,
											  SYSDATE);
*/
						EXIT;
					ELSE
						EXIT;
					END IF;
				END LOOP;
			-- Invoice Comparison
			ELSIF (UPPER(TRIM(p_COMPARISON_TYPE)) = UPPER(g_INVOICE_COMPARISON)) THEN
				GET_INVOICE_COMPARISON_RPT(v_STATEMENT_DAY.BEGIN_DATE, -- Begin Date
											 v_STATEMENT_DAY.END_DATE, -- End Date
											 PSE_TOL_DETAILS.PSE_ID, -- Participant
											 PSE_TOL_DETAILS.COMPARISON_ITEM, -- Comparison Item Determinant or Component
											 PSE_TOL_DETAILS.STATEMENT_TYPE1_ID, -- Invoice Type
											 PSE_TOL_DETAILS.STATEMENT_TYPE2_ID, -- Statement Type
											 PSE_TOL_DETAILS.STATEMENT_STATE1_ID, -- Invoice State
											 PSE_TOL_DETAILS.STATEMENT_STATE2_ID, -- Statement State
											 1, -- Violation Only
											 v_STATUS,
											 v_CURSOR);

				-- If there are one or more records, get the first record and raise an alert
				LOOP
				FETCH v_CURSOR INTO v_BEGIN_DATE, v_END_DATE, v_COMPARE_FROM_VALUE, v_COMPARE_TO_VALUE,
									v_ABSOLUTE_ERROR, v_RELATIVE_ERROR, v_ABS_ERROR_TOL, V_REL_ERROR_TOL;
					IF v_CURSOR%FOUND THEN
							ALERTS.TRIGGER_ALERTS(g_TOLERANCE_SYS_ALERT,
												  LOGS.c_LEVEL_NOTICE,
											  'Tolerance values breached for Partipant: ' || EI.GET_ENTITY_NAME(EC.ED_PSE, PSE_TOL_DETAILS.PSE_ID) || UTL_TCP.CRLF
												 || 'Invoice Begin Date: ' || v_BEGIN_DATE || UTL_TCP.CRLF
												 || 'Invoice End Date: ' || v_END_DATE || UTL_TCP.CRLF
												 || 'Comparison Item: ' || PSE_TOL_DETAILS.COMPARISON_ITEM || UTL_TCP.CRLF
												 || 'Compare From Statement Type: ' || EI.GET_ENTITY_NAME(EC.ED_STATEMENT_TYPE, PSE_TOL_DETAILS.STATEMENT_TYPE1_ID) || UTL_TCP.CRLF
												 || 'Compare From Statement State: ' || CASE WHEN PSE_TOL_DETAILS.STATEMENT_STATE1_ID = 1 THEN 'Internal' ELSE 'External' END || UTL_TCP.CRLF
												 || 'Compare To Statement Type: ' || EI.GET_ENTITY_NAME(EC.ED_STATEMENT_TYPE, PSE_TOL_DETAILS.STATEMENT_TYPE2_ID) || UTL_TCP.CRLF
												 || 'Compare To Statement State: ' || CASE WHEN PSE_TOL_DETAILS.STATEMENT_STATE2_ID = 1 THEN 'Internal' ELSE 'External' END || UTL_TCP.CRLF
												  );
/*
							ALERTS.SEND_ALERT(g_TOLERANCE_SYS_ALERT,
										  'Tolerance values breached for Partipant: ' || EI.GET_ENTITY_NAME(EC.ED_PSE, PSE_TOL_DETAILS.PSE_ID) || UTL_TCP.CRLF
											 || 'Invoice Begin Date: ' || v_BEGIN_DATE || UTL_TCP.CRLF
											 || 'Invoice End Date: ' || v_END_DATE || UTL_TCP.CRLF
											 || 'Comparison Item: ' || PSE_TOL_DETAILS.COMPARISON_ITEM || UTL_TCP.CRLF
											 || 'Compare From Statement Type: ' || EI.GET_ENTITY_NAME(EC.ED_STATEMENT_TYPE, PSE_TOL_DETAILS.STATEMENT_TYPE1_ID) || UTL_TCP.CRLF
											 || 'Compare From Statement State: ' || CASE WHEN PSE_TOL_DETAILS.STATEMENT_STATE1_ID = 1 THEN 'Internal' ELSE 'External' END || UTL_TCP.CRLF
											 || 'Compare To Statement Type: ' || EI.GET_ENTITY_NAME(EC.ED_STATEMENT_TYPE, PSE_TOL_DETAILS.STATEMENT_TYPE2_ID) || UTL_TCP.CRLF
											 || 'Compare To Statement State: ' || CASE WHEN PSE_TOL_DETAILS.STATEMENT_STATE2_ID = 1 THEN 'Internal' ELSE 'External' END || UTL_TCP.CRLF,
										  v_STATUS,
											  ML.c_PRIORITY_NORMAL,
											  SYSDATE);
*/
						EXIT;
					ELSE
						EXIT;
					END IF;
				END LOOP;
			END IF;

		END LOOP;
	END LOOP;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;
END;
--------------------------------------------------------------------------------
PROCEDURE SUPPLIER_PARTICIPANT_LIST
(
	p_BEGIN_DATE DATE,
	p_END_DATE DATE,
	p_CURSOR IN OUT GA.REFCURSOR
) AS
	v_ATTRIBUTE_ID NUMBER(9);
BEGIN
	ID.ID_FOR_ENTITY_ATTRIBUTE(MM_SEM_UTIL.g_EA_RESOURCE_TYPE, EC.ED_SERVICE_POINT, NULL, FALSE, v_ATTRIBUTE_ID);

	OPEN p_CURSOR FOR
		SELECT DISTINCT PSE.PSE_NAME, PSE.PSE_ID
		FROM SEM_SETTLEMENT_ENTITY SSE,
			SEM_SERVICE_POINT_PSE SPP,
			TEMPORAL_ENTITY_ATTRIBUTE TEA,
			PURCHASING_SELLING_ENTITY PSE
		WHERE SPP.PSE_ID = SSE.PARTICIPANT_PSE_ID
			AND SPP.BEGIN_DATE <= p_END_DATE
			AND NVL(SPP.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND TEA.OWNER_ENTITY_ID = SPP.POD_ID
			AND TEA.ATTRIBUTE_ID = v_ATTRIBUTE_ID
			AND TEA.BEGIN_DATE <= p_END_DATE
			AND NVL(TEA.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND REGEXP_LIKE(ATTRIBUTE_VAL, MM_SEM_UTIL.g_REGEXP_SUP_UNIT_TYPE)
			AND PSE.PSE_ID = SPP.PSE_ID;
END SUPPLIER_PARTICIPANT_LIST;
---------------------------------------------------------------------------------
PROCEDURE COMPONENT_LIST
(
	p_PARTICIPANT_ID NUMBER,
	p_BEGIN_DATE DATE,
	p_END_DATE DATE,
	p_CURSOR IN OUT GA.REFCURSOR
) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT COMPONENT_NAME FROM
			(SELECT C.COMPONENT_NAME
			FROM SEM_SETTLEMENT_ENTITY S,
				INTERCHANGE_CONTRACT IC,
				CONTRACT_PRODUCT_COMPONENT CPC,
				SEM_SLMT_VAL_COMPONENTS C
			WHERE S.PARTICIPANT_PSE_ID = p_PARTICIPANT_ID
				AND IC.BILLING_ENTITY_ID = S.SETTLEMENT_PSE_ID
				AND IC.BEGIN_DATE <= p_END_DATE
				AND NVL(IC.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
				AND CPC.CONTRACT_ID = IC.CONTRACT_ID
				AND CPC.BEGIN_DATE <= p_END_DATE
				AND NVL(CPC.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
				AND C.COMPONENT_ID = CPC.COMPONENT_ID
			ORDER BY C.POSITION)
		UNION ALL
		SELECT CONSTANTS.ALL_STRING FROM DUAL;
END COMPONENT_LIST;
---------------------------------------------------------------------------------
PROCEDURE SUPPLIER_UNIT_LIST
(
	p_BEGIN_DATE DATE,
	p_END_DATE DATE,
	p_PARTICIPANT_ID NUMBER,
	p_CURSOR OUT GA.REFCURSOR
) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT DISTINCT IDENT.EXTERNAL_IDENTIFIER AS SUPPLIER_UNIT_NAME
		FROM SEM_SETTLEMENT_ENTITY S,
			SEM_SERVICE_POINT_PSE P,
			EXTERNAL_SYSTEM_IDENTIFIER IDENT
		WHERE S.PARTICIPANT_PSE_ID = p_PARTICIPANT_ID
			AND P.BEGIN_DATE <= p_END_DATE
			AND NVL(P.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND P.PSE_ID = S.PARTICIPANT_PSE_ID
			AND IDENT.EXTERNAL_SYSTEM_ID = EC.ES_SEM
			AND IDENT.ENTITY_DOMAIN_ID = EC.ED_SERVICE_POINT
			AND IDENT.IDENTIFIER_TYPE = EI.g_DEFAULT_IDENTIFIER_TYPE
			AND IDENT.ENTITY_ID = POD_ID
		ORDER BY 1;
END SUPPLIER_UNIT_LIST;
--------------------------------------------------------------------------------
FUNCTION GET_STATEMENT_DATES
(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_MARKET_TYPE IN VARCHAR2
)
RETURN STATEMENT_DATE_TABLE PIPELINED IS

v_NUMBER_OF_MONTHS NUMBER;
v_NUMBER_OF_WEEKS NUMBER;
BEGIN
	-- For Capacity Market, the Invoice Period is Monthly
	-- where the Invoice Begin Date is the first day of the month and
	-- Invoice End Date is the last day of the month.
	IF p_MARKET_TYPE = MM_SEM_SETTLEMENT.g_CAPACITY_MARKET_NAME THEN
		v_NUMBER_OF_MONTHS := MONTHS_BETWEEN(TRUNC(p_END_DATE, 'MM'), TRUNC(p_BEGIN_DATE, 'MM')) + 1;
		FOR cur_SERV_LOC IN
			(SELECT INVOICE_BEGIN_DATE,
				INVOICE_END_DATE,
				STMT_DAYS.COLUMN_VALUE AS STATEMENT_DATE
			FROM (SELECT ADD_MONTHS(TRUNC(p_BEGIN_DATE, 'MM'),(LEVEL-1) * 1) AS INVOICE_BEGIN_DATE,
					LAST_DAY(ADD_MONTHS(TRUNC(p_BEGIN_DATE, 'MM'),(LEVEL-1) * 1)) AS INVOICE_END_DATE
				FROM DUAL CONNECT BY LEVEL <= v_NUMBER_OF_MONTHS) INV,
				TABLE(CAST(DATE_UTIL.DATES_IN_INTERVAL_RANGE(INV.INVOICE_BEGIN_DATE, INV.INVOICE_END_DATE, CONSTANTS.INTERVAL_DAY) AS DATE_COLLECTION)) STMT_DAYS)
		LOOP
			PIPE ROW(STATEMENT_DATE_TYPE(cur_SERV_LOC.INVOICE_BEGIN_DATE, cur_SERV_LOC.INVOICE_END_DATE, cur_SERV_LOC.STATEMENT_DATE));
		END LOOP;
	-- For Energy Market, the Invoice Period is weekly
	-- where the Invoice Begin Date is the first Sunday of or prior to the Begin Date
	-- and the Invoice End Date is the Saturday of or following the End Date.
	ELSIF p_MARKET_TYPE = MM_SEM_SETTLEMENT.g_ENERGY_MARKET_NAME THEN
		v_NUMBER_OF_WEEKS := (DATE_UTIL.WEEK_TRUNC(p_END_DATE, DATE_UTIL.c_WEEK_BEGIN_SUNDAY)-DATE_UTIL.WEEK_TRUNC(p_BEGIN_DATE, DATE_UTIL.c_WEEK_BEGIN_SUNDAY))/7 + 1;
		FOR cur_SERV_LOC IN
			(SELECT INVOICE_BEGIN_DATE,
				INVOICE_END_DATE,
				STMT_DAYS.COLUMN_VALUE AS STATEMENT_DATE
			FROM (SELECT DATE_UTIL.WEEK_TRUNC(p_BEGIN_DATE, DATE_UTIL.c_WEEK_BEGIN_SUNDAY) + (LEVEL-1)*7 AS INVOICE_BEGIN_DATE,
					(DATE_UTIL.WEEK_TRUNC(p_BEGIN_DATE, DATE_UTIL.c_WEEK_BEGIN_SUNDAY) + (LEVEL-1)*7) + 6 AS INVOICE_END_DATE
				FROM DUAL CONNECT BY LEVEL <= v_NUMBER_OF_WEEKS) INV,
				TABLE(CAST(DATE_UTIL.DATES_IN_INTERVAL_RANGE(INV.INVOICE_BEGIN_DATE, INV.INVOICE_END_DATE, CONSTANTS.INTERVAL_DAY) AS DATE_COLLECTION)) STMT_DAYS)
		LOOP
			PIPE ROW(STATEMENT_DATE_TYPE(cur_SERV_LOC.INVOICE_BEGIN_DATE, cur_SERV_LOC.INVOICE_END_DATE, cur_SERV_LOC.STATEMENT_DATE));
		END LOOP;
	END IF;
  	RETURN;
END GET_STATEMENT_DATES;
--------------------------------------------------------------------------------
PROCEDURE STATEMENT_TYPE_LIST
(
	p_CURSOR IN OUT GA.REFCURSOR
) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT S.STATEMENT_TYPE_NAME, S.STATEMENT_TYPE_ID
		FROM EXTERNAL_SYSTEM_IDENTIFIER ESI,
		 	STATEMENT_TYPE S
		WHERE ESI.EXTERNAL_SYSTEM_ID = EC.ES_SEM
			AND ESI.ENTITY_DOMAIN_ID = EC.ED_STATEMENT_TYPE
			AND ESI.IDENTIFIER_TYPE = MM_SEM_UTIl.g_STATEMENT_TYPE_SETTLEMENT
			AND ESI.EXTERNAL_IDENTIFIER IN (MM_SEM_UTIL.g_EXTID_SETTLEMENT_P, MM_SEM_UTIL.g_EXTID_SETTLEMENT_F)
			AND S.STATEMENT_TYPE_ID = ESI.ENTITY_ID
		ORDER BY 1;
END STATEMENT_TYPE_LIST;
--------------------------------------------------------------------------------
PROCEDURE CACHE_COMPARISON_SUMMARY
(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PARTICIPANT_ID IN NUMBER,
	p_STATEMENT_TYPE_ID IN NUMBER, -- -2 implies 'Best Available'
	p_COMPONENT_NAME IN VARCHAR2
) AS
BEGIN
	INSERT INTO SEM_SETTLEMENT_COMP_SUMM_WORK
		SELECT INTERNAL.INVOICE_BEGIN_DATE,
			INTERNAL.INVOICE_END_DATE,
			INTERNAL.STMT_TYPE,
			INTERNAL.ENTITY_ID,
			INTERNAL.COMPONENT_ID,
			INTERNAL.STATEMENT_DATE,
			INTERNAL.STMT_AMOUNT,
			INTERNAL.STMT_QUANTITY,
			INTERNAL.PIR_AMOUNT,
			INTERNAL.PIR_QUANTITY,
			INTERNAL.TDIE_AMOUNT,
			INTERNAL.TDIE_QUANTITY,
			BS.CHARGE_AMOUNT AS INTERNAL_AMOUNT,
			BS.CHARGE_QUANTITY AS INTERNAL_QUANTITY
		FROM (SELECT TDIE.*, BS.CHARGE_AMOUNT AS TDIE_AMOUNT, BS.CHARGE_QUANTITY AS TDIE_QUANTITY
			FROM (SELECT PIR.*, BS.CHARGE_AMOUNT AS PIR_AMOUNT, BS.CHARGE_QUANTITY AS PIR_QUANTITY
				FROM (SELECT STMT.*,
						PIR_EXT_IDENT.ENTITY_ID AS PIR_STMT_TYPE,
						TDIE_EXT_IDENT.ENTITY_ID AS TDIE_STMT_TYPE,
						STMT.STMT_TYPE AS INT_STMT_TYPE
					FROM (SELECT BS.ENTITY_ID,
							BS.STATEMENT_DATE,
							BS.STATEMENT_TYPE AS STMT_TYPE,
							STMT_EXT_IDENT.EXTERNAL_IDENTIFIER AS STMT_TYPE_EXT_IDENT,
							BS.COMPONENT_ID,
							INVOICE_BEGIN_DATE,
							INVOICE_END_DATE,
							CHARGE_AMOUNT AS STMT_AMOUNT,
							CHARGE_QUANTITY AS STMT_QUANTITY
						FROM (SELECT INVOICE_BEGIN_DATE, INVOICE_END_DATE, X.STATEMENT_DATE, ENTITY_ID, COMPONENT_ID
							  FROM -- Get the Component List
									(SELECT DISTINCT C.COMPONENT_ID, S.SETTLEMENT_PSE_ID AS ENTITY_ID, S.MARKET_NAME
									FROM SEM_SETTLEMENT_ENTITY S,
										INTERCHANGE_CONTRACT IC,
										CONTRACT_PRODUCT_COMPONENT CPC,
										SEM_SLMT_VAL_COMPONENTS C
									WHERE S.PARTICIPANT_PSE_ID = p_PARTICIPANT_ID
										AND IC.BILLING_ENTITY_ID = S.SETTLEMENT_PSE_ID
										AND IC.BEGIN_DATE <= p_END_DATE
										AND NVL(IC.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
										AND CPC.CONTRACT_ID = IC.CONTRACT_ID
										AND CPC.BEGIN_DATE <= p_END_DATE
										AND NVL(CPC.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
										AND C.COMPONENT_ID = CPC.COMPONENT_ID
										AND (C.COMPONENT_NAME = p_COMPONENT_NAME OR CONSTANTS.ALL_STRING = p_COMPONENT_NAME)) COMP,
									-- Get the Invoice Period Begin/End Date and Statement Dates
									TABLE(GET_STATEMENT_DATES(p_BEGIN_DATE, p_END_DATE, COMP.MARKET_NAME))X) Y,
							  BILLING_STATEMENT BS,
							  EXTERNAL_SYSTEM_IDENTIFIER STMT_EXT_IDENT
						WHERE BS.ENTITY_ID(+) = Y.ENTITY_ID
							AND BS.COMPONENT_ID(+) = Y.COMPONENT_ID
							-- If the Statement Type is -2 (Best Available), get the best available statement type for the invoice period
							AND (p_STATEMENT_TYPE_ID = g_STMT_TYPE_BEST_AVAILABLE
									 AND BS.STATEMENT_TYPE =(SELECT DISTINCT LAST_VALUE(S.STATEMENT_TYPE)
															OVER (ORDER BY T.STATEMENT_TYPE_ORDER ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
															FROM BILLING_STATEMENT S, STATEMENT_TYPE T
															WHERE S.ENTITY_ID = Y.ENTITY_ID
																AND S.COMPONENT_ID = Y.COMPONENT_ID
																AND S.STATEMENT_STATE = CONSTANTS.EXTERNAL_STATE
																AND S.AS_OF_DATE = CONSTANTS.LOW_DATE
																AND S.STATEMENT_DATE = Y.STATEMENT_DATE
																AND T.STATEMENT_TYPE_ID = S.STATEMENT_TYPE)
									OR (p_STATEMENT_TYPE_ID <> g_STMT_TYPE_BEST_AVAILABLE AND BS.STATEMENT_TYPE = p_STATEMENT_TYPE_ID))
							AND BS.STATEMENT_STATE(+) = CONSTANTS.EXTERNAL_STATE  -- External
							AND BS.STATEMENT_DATE(+) = Y.STATEMENT_DATE
							AND BS.AS_OF_DATE(+) = CONSTANTS.LOW_DATE
							AND STMT_EXT_IDENT.EXTERNAL_SYSTEM_ID = EC.ES_SEM
							AND STMT_EXT_IDENT.ENTITY_DOMAIN_ID = EC.ED_STATEMENT_TYPE
							AND STMT_EXT_IDENT.IDENTIFIER_TYPE = MM_SEM_UTIL.g_STATEMENT_TYPE_SETTLEMENT
							AND STMT_EXT_IDENT.ENTITY_ID = BS.STATEMENT_TYPE) STMT,
						EXTERNAL_SYSTEM_IDENTIFIER PIR_EXT_IDENT,
						EXTERNAL_SYSTEM_IDENTIFIER TDIE_EXT_IDENT
					WHERE -- PIR
						PIR_EXT_IDENT.EXTERNAL_SYSTEM_ID(+) = EC.ES_SEM
						AND PIR_EXT_IDENT.ENTITY_DOMAIN_ID(+) = EC.ED_STATEMENT_TYPE
						AND PIR_EXT_IDENT.IDENTIFIER_TYPE(+) = MM_SEM_UTIL.g_STATEMENT_TYPE_SETTLEMENT
						AND PIR_EXT_IDENT.EXTERNAL_IDENTIFIER(+) = 'SMO ' || STMT.STMT_TYPE_EXT_IDENT
						-- TDIE
						AND TDIE_EXT_IDENT.EXTERNAL_SYSTEM_ID(+) = EC.ES_TDIE
						AND TDIE_EXT_IDENT.ENTITY_DOMAIN_ID(+) = EC.ED_STATEMENT_TYPE
						AND TDIE_EXT_IDENT.IDENTIFIER_TYPE(+) = EI.g_DEFAULT_IDENTIFIER_TYPE
						AND TDIE_EXT_IDENT.EXTERNAL_IDENTIFIER(+) = STMT.STMT_TYPE_EXT_IDENT) PIR,
				BILLING_STATEMENT BS
			WHERE BS.ENTITY_ID(+) = PIR.ENTITY_ID
				AND BS.COMPONENT_ID(+) = PIR.COMPONENT_ID
				AND BS.STATEMENT_TYPE(+) = PIR.PIR_STMT_TYPE
				AND BS.STATEMENT_STATE(+) = CONSTANTS.INTERNAL_STATE
				AND BS.STATEMENT_DATE(+) = PIR.STATEMENT_DATE
				AND BS.AS_OF_DATE(+) = CONSTANTS.LOW_DATE) TDIE,
			BILLING_STATEMENT BS
		WHERE BS.ENTITY_ID(+) = TDIE.ENTITY_ID
			AND BS.COMPONENT_ID(+) = TDIE.COMPONENT_ID
			AND BS.STATEMENT_TYPE(+) = TDIE.TDIE_STMT_TYPE
			AND BS.STATEMENT_STATE(+) = CONSTANTS.INTERNAL_STATE
			AND BS.STATEMENT_DATE(+) = TDIE.STATEMENT_DATE
			AND BS.AS_OF_DATE(+) = CONSTANTS.LOW_DATE) INTERNAL,
		BILLING_STATEMENT BS
		WHERE BS.ENTITY_ID(+) = INTERNAL.ENTITY_ID
			AND BS.COMPONENT_ID(+) = INTERNAL.COMPONENT_ID
			AND BS.STATEMENT_TYPE(+) = INTERNAL.INT_STMT_TYPE
			AND BS.STATEMENT_STATE(+) = CONSTANTS.INTERNAL_STATE
			AND BS.STATEMENT_DATE(+) = INTERNAL.STATEMENT_DATE
			AND BS.AS_OF_DATE(+) = CONSTANTS.LOW_DATE;

END CACHE_COMPARISON_SUMMARY;
--------------------------------------------------------------------------------
PROCEDURE TOLERANCE_FILTER_TO_NUMBER
	(
	p_FILTER_NAME IN VARCHAR2,
	p_FILTER_VALUE IN VARCHAR2,
	p_NUMBER_VALUE OUT NUMBER,
	p_MESSAGE OUT VARCHAR2
	) AS
BEGIN
	p_NUMBER_VALUE := CASE WHEN p_FILTER_VALUE IS NULL THEN NULL ELSE TO_NUMBER(p_FILTER_VALUE) END;
EXCEPTION
	WHEN VALUE_ERROR THEN
		p_MESSAGE := p_FILTER_NAME||' '||c_MSG_INVALID_TOL_DIFF;
END TOLERANCE_FILTER_TO_NUMBER;
--------------------------------------------------------------------------------
PROCEDURE SEM_COMP_SUMMARY
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PARTICIPANT_ID IN NUMBER,
	p_STATEMENT_TYPE_ID IN NUMBER, -- Initial, Indicative or Best Available
	p_COMPONENT IN VARCHAR2, -- Component Name or <All>
	p_ENABLE_TOLERANCE IN NUMBER,
	p_PIR_PCT_TOLERANCE_DIFF IN VARCHAR2,
	p_TDIE_PCT_TOLERANCE_DIFF IN VARCHAR2,
	p_INTERNAL_PCT_TOLERANCE_DIFF IN VARCHAR2,
	p_REPORT_TYPE IN VARCHAR2, -- 'Charge Amount' or 'Energy Volume'
	p_CURSOR IN OUT GA.REFCURSOR,
	p_MESSAGE OUT VARCHAR2
	) AS
v_STATEMENT_TYPE_ID STATEMENT_TYPE.STATEMENT_TYPE_ID%TYPE;
v_PIR_PCT_TOLERANCE_DIFF NUMBER;
v_TDIE_PCT_TOLERANCE_DIFF NUMBER;
v_INTERNAL_PCT_TOLERANCE_DIFF NUMBER;
v_REV_SIGN_INVOICE_MULTIPLIER NUMBER;
BEGIN
	-- Check if the % Difference Tolerance values are valid numbers
	IF p_REPORT_TYPE = g_STMT_VAL_RPT_TYPE_CHG_AMOUNT THEN
		TOLERANCE_FILTER_TO_NUMBER('PIR', p_PIR_PCT_TOLERANCE_DIFF, v_PIR_PCT_TOLERANCE_DIFF, p_MESSAGE);
	END IF;
	IF p_MESSAGE IS NULL THEN
		TOLERANCE_FILTER_TO_NUMBER('IE T&D', p_TDIE_PCT_TOLERANCE_DIFF, v_TDIE_PCT_TOLERANCE_DIFF, p_MESSAGE);
	END IF;
	IF p_MESSAGE IS NULL THEN
		TOLERANCE_FILTER_TO_NUMBER('Internal', p_INTERNAL_PCT_TOLERANCE_DIFF, v_INTERNAL_PCT_TOLERANCE_DIFF, p_MESSAGE);
	END IF;
	IF p_MESSAGE IS NOT NULL THEN
		NULL_CURSOR(p_CURSOR);
		RETURN;
	END IF;

	IF p_ENABLE_TOLERANCE = 1 THEN
		-- Validate if we have at least one of the % Difference input to run a variance report
		IF ((p_REPORT_TYPE = g_STMT_VAL_RPT_TYPE_CHG_AMOUNT AND (v_PIR_PCT_TOLERANCE_DIFF IS NULL AND v_TDIE_PCT_TOLERANCE_DIFF IS NULL AND p_INTERNAL_PCT_TOLERANCE_DIFF IS NULL)) OR
			 (p_REPORT_TYPE = g_STMT_VAL_RPT_TYPE_ENERGY_VOL AND (v_TDIE_PCT_TOLERANCE_DIFF IS NULL AND p_INTERNAL_PCT_TOLERANCE_DIFF IS NULL))) THEN
			p_MESSAGE := c_MSG_MISSING_TOL_DIFF;
			NULL_CURSOR(p_CURSOR);
			RETURN;
		END IF;
	END IF;

	-- Truncate the temporary table
	EXECUTE IMMEDIATE 'TRUNCATE TABLE SEM_SETTLEMENT_COMP_SUMM_WORK';

	-- Get the Statement Type from the Invoice
	IF p_STATEMENT_TYPE_ID = g_STMT_TYPE_BEST_AVAILABLE THEN
		FOR cur_SLMT_PSE_IDS IN
			(SELECT DISTINCT SSE.SETTLEMENT_PSE_ID, SSE.PARTICIPANT_PSE_ID, C.COMPONENT_NAME, C.COMPONENT_ID, INV.INVOICE_BEGIN_DATE, INV.INVOICE_END_DATE
			FROM SEM_SLMT_VAL_COMPONENTS C,
				SEM_SETTLEMENT_ENTITY SSE,
				TABLE(GET_STATEMENT_DATES(p_BEGIN_DATE, p_END_DATE, SSE.MARKET_NAME)) INV
			WHERE (C.COMPONENT_NAME = p_COMPONENT OR p_COMPONENT = CONSTANTS.ALL_STRING)
				AND SSE.MARKET_NAME = C.COMPONENT_CATEGORY
				AND SSE.PARTICIPANT_PSE_ID = p_PARTICIPANT_ID)
		LOOP
			BEGIN
				-- Get the Best Available Invoice's Statement Type for the Invoice period
				-- If available use Invoice's Statement Type
				-- Else use -2(Best Available) as Statement Type
				SELECT DISTINCT LAST_VALUE(I.STATEMENT_TYPE) OVER (ORDER BY T.STATEMENT_TYPE_ORDER ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
				INTO v_STATEMENT_TYPE_ID
				FROM INVOICE I, INVOICE_LINE_ITEM L, STATEMENT_TYPE T
				WHERE I.ENTITY_ID = cur_SLMT_PSE_IDS.SETTLEMENT_PSE_ID
					AND I.BEGIN_DATE <= cur_SLMT_PSE_IDS.INVOICE_END_DATE
					AND NVL(I.END_DATE, CONSTANTS.HIGH_DATE) >= cur_SLMT_PSE_IDS.INVOICE_BEGIN_DATE
					AND L.COMPONENT_ID = cur_SLMT_PSE_IDS.COMPONENT_ID
					AND T.STATEMENT_TYPE_ID = I.STATEMENT_TYPE;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					v_STATEMENT_TYPE_ID := g_STMT_TYPE_BEST_AVAILABLE;
			END;

			-- Cache the Comparison Summary Results
			IF v_STATEMENT_TYPE_ID IS NOT NULL THEN
				CACHE_COMPARISON_SUMMARY(cur_SLMT_PSE_IDS.INVOICE_BEGIN_DATE,
										cur_SLMT_PSE_IDS.INVOICE_END_DATE,
										cur_SLMT_PSE_IDS.PARTICIPANT_PSE_ID,
										v_STATEMENT_TYPE_ID,
										cur_SLMT_PSE_IDS.COMPONENT_NAME);
			END IF;

		END LOOP;
	ELSE
		v_STATEMENT_TYPE_ID := p_STATEMENT_TYPE_ID;
		-- Cache the Comparison Summary Results
		IF v_STATEMENT_TYPE_ID IS NOT NULL THEN
			CACHE_COMPARISON_SUMMARY(p_BEGIN_DATE,
									p_END_DATE,
									p_PARTICIPANT_ID,
									v_STATEMENT_TYPE_ID,
									p_COMPONENT);
		END IF;
	END IF;

    v_REV_SIGN_INVOICE_MULTIPLIER := CASE WHEN GA.ENABLE_REVERSE_SIGN_INVOICES = TRUE THEN -1 ELSE 1 END;

	OPEN p_CURSOR FOR
		SELECT p_REPORT_TYPE AS REPORT_TYPE,
			INV.INVOICE_NUMBER,
			SUMM.INVOICE_BEGIN_DATE,
			SUMM.INVOICE_END_DATE,
			SUMM.STATEMENT_TYPE AS STATEMENT_TYPE_ID,
			CASE WHEN SUMM.STATEMENT_TYPE = g_STMT_TYPE_BEST_AVAILABLE THEN 'Various' ELSE T.STATEMENT_TYPE_NAME END STATEMENT_TYPE_NAME,
			SUMM.COMPONENT_ID,
			C.COMPONENT_NAME,
			SUMM.ENTITY_ID,
			p_PARTICIPANT_ID AS PARTICIPANT_ID,
			CASE WHEN p_REPORT_TYPE = g_STMT_VAL_RPT_TYPE_CHG_AMOUNT
                    THEN SUM(INV.LINE_ITEM_AMOUNT) * v_REV_SIGN_INVOICE_MULTIPLIER
                    ELSE NULL END AS INVOICE_AMOUNT,
			p_ENABLE_TOLERANCE AS ENABLE_TOLERANCE,
			v_PIR_PCT_TOLERANCE_DIFF AS PIR_PCT_TOLERANCE_DIFF,
			v_TDIE_PCT_TOLERANCE_DIFF AS TDIE_PCT_TOLERANCE_DIFF,
			v_INTERNAL_PCT_TOLERANCE_DIFF AS INTERNAL_PCT_TOLERANCE_DIFF,
			STATEMENT_AMOUNT,
			PIR_AMOUNT,
			TDIE_AMOUNT,
			INTERNAL_AMOUNT,
			STATEMENT_VOLUME,
			TDIE_VOLUME,
			INTERNAL_VOLUME
		FROM (SELECT S.INVOICE_BEGIN_DATE,
				S.INVOICE_END_DATE,
				CASE WHEN MIN(STATEMENT_TYPE) <> MAX(STATEMENT_TYPE) THEN g_STMT_TYPE_BEST_AVAILABLE ELSE MIN(STATEMENT_TYPE) END AS STATEMENT_TYPE,
				S.COMPONENT_ID,
				S.ENTITY_ID,
				CASE WHEN p_REPORT_TYPE = g_STMT_VAL_RPT_TYPE_CHG_AMOUNT THEN SUM(S.STMT_AMOUNT) ELSE NULL END AS STATEMENT_AMOUNT,
				CASE WHEN p_REPORT_TYPE = g_STMT_VAL_RPT_TYPE_ENERGY_VOL THEN SUM(S.STMT_QUANTITY) ELSE NULL END AS STATEMENT_VOLUME,
				CASE WHEN p_REPORT_TYPE = g_STMT_VAL_RPT_TYPE_CHG_AMOUNT THEN SUM(S.PIR_AMOUNT) ELSE NULL END  AS PIR_AMOUNT,
				CASE WHEN p_REPORT_TYPE = g_STMT_VAL_RPT_TYPE_CHG_AMOUNT THEN SUM(S.TDIE_AMOUNT) ELSE NULL END AS TDIE_AMOUNT,
				CASE WHEN p_REPORT_TYPE = g_STMT_VAL_RPT_TYPE_ENERGY_VOL THEN SUM(S.TDIE_QUANTITY) ELSE NULL END AS TDIE_VOLUME,
				CASE WHEN p_REPORT_TYPE = g_STMT_VAL_RPT_TYPE_CHG_AMOUNT THEN SUM(S.INTERNAL_AMOUNT) ELSE NULL END  AS INTERNAL_AMOUNT,
				CASE WHEN p_REPORT_TYPE = g_STMT_VAL_RPT_TYPE_ENERGY_VOL THEN SUM(S.INTERNAL_QUANTITY) ELSE NULL END AS INTERNAL_VOLUME
			FROM SEM_SETTLEMENT_COMP_SUMM_WORK S
			GROUP BY S.INVOICE_BEGIN_DATE,
				S.INVOICE_END_DATE,
				S.COMPONENT_ID,
				S.ENTITY_ID) SUMM,
			(SELECT I.ENTITY_ID, I.BEGIN_DATE, I.END_DATE, I.STATEMENT_TYPE, L.COMPONENT_ID, I.INVOICE_NUMBER, L.LINE_ITEM_AMOUNT FROM INVOICE I, INVOICE_LINE_ITEM L
			 WHERE 	I.BEGIN_DATE <= p_END_DATE
				AND NVL(I.END_DATE, HIGH_DATE) >= p_BEGIN_DATE
				AND I.STATEMENT_STATE = CONSTANTS.EXTERNAL_STATE -- External
				AND I.AS_OF_DATE = CONSTANTS.LOW_DATE
				AND L.INVOICE_ID = I.INVOICE_ID) INV,
			STATEMENT_TYPE T,
			COMPONENT C
		WHERE INV.ENTITY_ID(+) = SUMM.ENTITY_ID
			AND INV.BEGIN_DATE(+) = SUMM.INVOICE_BEGIN_DATE
			AND INV.END_DATE(+) = SUMM.INVOICE_END_DATE
			AND INV.COMPONENT_ID(+) = SUMM.COMPONENT_ID
			AND T.STATEMENT_TYPE_ID(+) = SUMM.STATEMENT_TYPE
			AND C.COMPONENT_ID = SUMM.COMPONENT_ID
			AND -- If Enable Tolerance is set to 1, then display only row where tolerance diff % > expected tolerance %
				-- Else show all rows. The non-null tolerances are be ignored.
				((p_ENABLE_TOLERANCE = 1 AND
					(p_REPORT_TYPE = g_STMT_VAL_RPT_TYPE_CHG_AMOUNT AND NVL(STATEMENT_AMOUNT,0) <> 0 AND
						((PIR_AMOUNT IS NOT NULL AND v_PIR_PCT_TOLERANCE_DIFF IS NOT NULL AND ABS((STATEMENT_AMOUNT - NVL(PIR_AMOUNT,0))/STATEMENT_AMOUNT)*100 > v_PIR_PCT_TOLERANCE_DIFF)
					 	OR (TDIE_AMOUNT IS NOT NULL AND v_TDIE_PCT_TOLERANCE_DIFF IS NOT NULL AND ABS((STATEMENT_AMOUNT - NVL(TDIE_AMOUNT,0))/STATEMENT_AMOUNT)*100 > v_TDIE_PCT_TOLERANCE_DIFF)
						 OR (INTERNAL_AMOUNT IS NOT NULL AND v_INTERNAL_PCT_TOLERANCE_DIFF IS NOT NULL AND ABS((STATEMENT_AMOUNT - NVL(INTERNAL_AMOUNT,0))/STATEMENT_AMOUNT)*100 > v_INTERNAL_PCT_TOLERANCE_DIFF))) OR
					(p_REPORT_TYPE = g_STMT_VAL_RPT_TYPE_ENERGY_VOL AND NVL(STATEMENT_VOLUME,0) <> 0 AND
						((TDIE_VOLUME IS NOT NULL AND v_TDIE_PCT_TOLERANCE_DIFF IS NOT NULL AND ABS((STATEMENT_VOLUME - NVL(TDIE_VOLUME,0))/STATEMENT_VOLUME)*100 > v_TDIE_PCT_TOLERANCE_DIFF)
						 OR (INTERNAL_VOLUME IS NOT NULL AND v_INTERNAL_PCT_TOLERANCE_DIFF IS NOT NULL AND ABS((STATEMENT_VOLUME - NVL(INTERNAL_VOLUME,0))/STATEMENT_VOLUME)*100 > v_INTERNAL_PCT_TOLERANCE_DIFF)))
				) OR p_ENABLE_TOLERANCE = 0)
		GROUP BY p_REPORT_TYPE,
			INV.INVOICE_NUMBER,
			SUMM.INVOICE_BEGIN_DATE,
			SUMM.INVOICE_END_DATE,
			SUMM.STATEMENT_TYPE,
			CASE WHEN SUMM.STATEMENT_TYPE = g_STMT_TYPE_BEST_AVAILABLE THEN 'Various' ELSE T.STATEMENT_TYPE_NAME END,
			SUMM.COMPONENT_ID,
			C.COMPONENT_NAME,
			SUMM.ENTITY_ID,
			p_PARTICIPANT_ID,
			STATEMENT_AMOUNT,
			STATEMENT_VOLUME,
			p_ENABLE_TOLERANCE,
			v_PIR_PCT_TOLERANCE_DIFF,
			v_TDIE_PCT_TOLERANCE_DIFF,
			v_INTERNAL_PCT_TOLERANCE_DIFF,
			PIR_AMOUNT,
			TDIE_AMOUNT,
			TDIE_VOLUME,
			INTERNAL_AMOUNT,
			INTERNAL_VOLUME
		ORDER BY COMPONENT_NAME,
			INVOICE_BEGIN_DATE,
			INVOICE_END_DATE,
			STATEMENT_TYPE_NAME;

END SEM_COMP_SUMMARY;
--------------------------------------------------------------------------------
PROCEDURE SEM_COMP_DETAILS
	(
	p_INVOICE_BEGIN_DATE IN DATE,
	p_INVOICE_END_DATE IN DATE,
	p_ENTITY_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_REPORT_TYPE IN VARCHAR2, --'Charge Amount' or 'Energy Volume'
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT S.STATEMENT_DATE,
			S.STATEMENT_TYPE AS STMT_TYPE,
			T.STATEMENT_TYPE_NAME,
			S.COMPONENT_ID,
			C.COMPONENT_NAME,
			S.ENTITY_ID,
			CASE WHEN p_REPORT_TYPE = g_STMT_VAL_RPT_TYPE_CHG_AMOUNT THEN S.STMT_AMOUNT ELSE NULL END AS STATEMENT_AMOUNT,
			CASE WHEN p_REPORT_TYPE = g_STMT_VAL_RPT_TYPE_CHG_AMOUNT THEN S.PIR_AMOUNT ELSE NULL END  AS PIR_AMOUNT,
			CASE WHEN p_REPORT_TYPE = g_STMT_VAL_RPT_TYPE_CHG_AMOUNT THEN S.TDIE_AMOUNT ELSE NULL END AS TDIE_AMOUNT,
			CASE WHEN p_REPORT_TYPE = g_STMT_VAL_RPT_TYPE_CHG_AMOUNT THEN S.INTERNAL_AMOUNT ELSE NULL END  AS INTERNAL_AMOUNT,
			CASE WHEN p_REPORT_TYPE = g_STMT_VAL_RPT_TYPE_ENERGY_VOL THEN S.STMT_QUANTITY ELSE NULL END AS STATEMENT_VOLUME,
			CASE WHEN p_REPORT_TYPE = g_STMT_VAL_RPT_TYPE_ENERGY_VOL THEN S.TDIE_QUANTITY ELSE NULL END AS TDIE_VOLUME,
			CASE WHEN p_REPORT_TYPE = g_STMT_VAL_RPT_TYPE_ENERGY_VOL THEN S.INTERNAL_QUANTITY ELSE NULL END AS INTERNAL_VOLUME
		FROM SEM_SETTLEMENT_COMP_SUMM_WORK S,
			STATEMENT_TYPE T,
			COMPONENT C
		WHERE S.INVOICE_BEGIN_DATE = p_INVOICE_BEGIN_DATE
			AND S.INVOICE_END_DATE = p_INVOICE_END_DATE
			AND S.ENTITY_ID = p_ENTITY_ID
			AND S.COMPONENT_ID = p_COMPONENT_ID
			AND T.STATEMENT_TYPE_ID = S.STATEMENT_TYPE
			AND C.COMPONENT_ID = S.COMPONENT_ID
		ORDER BY 1;
END SEM_COMP_DETAILS;
--------------------------------------------------------------------------------
FUNCTION DETERMINE_SLMT_RUN_INDICATOR
	(
	p_STATEMENT_TYPE_ID IN NUMBER,
	p_STATEMENT_DATE IN DATE,
	p_MARKET_TYPE IN VARCHAR2, -- 'EN' or 'CA'
    p_JURISDICTION IN VARCHAR2 -- 'ROI' or 'NI'
	) RETURN VARCHAR2 IS
	v_EXT_SYS_IDENT EXTERNAL_SYSTEM_IDENTIFIER.EXTERNAL_IDENTIFIER%TYPE;
	v_RUN_INDICATOR TDIE_MESSAGE.SETTLEMENT_RUN_INDICATOR%TYPE;
	v_RUN_TYPE SEM_SETTLEMENT_CALENDAR.RUN_TYPE%TYPE;
	v_MARKET SEM_SETTLEMENT_CALENDAR.MARKET%TYPE;
BEGIN
	-- Get the External System Identifier
	SELECT MAX(IDENT.EXTERNAL_IDENTIFIER)
	INTO v_EXT_SYS_IDENT
	FROM EXTERNAL_SYSTEM_IDENTIFIER IDENT
	WHERE IDENT.ENTITY_DOMAIN_ID = EC.ED_STATEMENT_TYPE
		AND IDENT.EXTERNAL_SYSTEM_ID = EC.ES_TDIE
		AND IDENT.IDENTIFIER_TYPE = Ei.g_DEFAULT_IDENTIFIER_TYPE
		AND IDENT.ENTITY_ID = p_STATEMENT_TYPE_ID;

	IF v_EXT_SYS_IDENT = MM_SEM_UTIL.g_EXTID_SETTLEMENT_P THEN
		v_RUN_INDICATOR := CASE p_JURISDICTION WHEN MM_TDIE_UTIL.c_TDIE_JURISDICTION_ROI THEN '10' WHEN MM_TDIE_UTIL.c_TDIE_JURISDICTION_NI THEN 'D+1' END;
	ELSIF v_EXT_SYS_IDENT = MM_SEM_UTIL.g_EXTID_SETTLEMENT_F THEN
		v_RUN_INDICATOR := CASE p_JURISDICTION WHEN MM_TDIE_UTIL.c_TDIE_JURISDICTION_ROI THEN '20' WHEN MM_TDIE_UTIL.c_TDIE_JURISDICTION_NI THEN 'D+4' END;
	ELSE
		v_MARKET := MM_SEM_SETTLEMENT_CALENDAR.GET_MARKET_NAME_FOR_ABBREV(p_MARKET_TYPE);

		-- Lookup the revision calendar to find the appropriate Revision Type
		SELECT MAX(C.RUN_TYPE)
		INTO v_RUN_TYPE
		FROM SEM_SETTLEMENT_CALENDAR C
		WHERE C.RUN_IDENTIFIER = v_EXT_SYS_IDENT
		  AND C.PUBLICATION_TYPE = MM_SEM_SETTLEMENT_CALENDAR.c_PUBLICATION_TYPE_INVOICE
		  AND C.RUN_TYPE IN (MM_SEM_SETTLEMENT_CALENDAR.c_RUN_TYPE_M4,
		  					 MM_SEM_SETTLEMENT_CALENDAR.c_RUN_TYPE_M13,
							 MM_SEM_SETTLEMENT_CALENDAR.c_RUN_TYPE_ADHOC)
		  AND p_STATEMENT_DATE BETWEEN C.BEGIN_DATE AND C.END_DATE
		  AND C.MARKET = v_MARKET;

		v_RUN_INDICATOR := CASE WHEN v_RUN_TYPE = MM_SEM_SETTLEMENT_CALENDAR.c_RUN_TYPE_M4 THEN 30
								WHEN v_RUN_TYPE = MM_SEM_SETTLEMENT_CALENDAR.c_RUN_TYPE_M13 THEN 40
								ELSE 50 END;

	END IF;
	RETURN v_RUN_INDICATOR;
END DETERMINE_SLMT_RUN_INDICATOR;
---------------------------------------------------------------------------------
PROCEDURE CACHE_FORMULA_CHARGE_DETAILS
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PARTICIPANT_ID IN NUMBER,
	p_STATEMENT_TYPE_ID IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_COMPONENT_NAME IN VARCHAR2,
	p_SUPPLIER_UNIT IN VARCHAR2,-- Supplier Unit or '<All>'
	p_DETAIL_TYPE IN VARCHAR2 -- Statement, PIR, TDIE, Internal
	) AS
BEGIN
	INSERT INTO SEM_SETTLEMENT_COMP_DTL_WORK
	SELECT BS.STATEMENT_DATE,
		FC.CHARGE_DATE,
		FI.ITERATOR1,
		p_STATEMENT_TYPE_ID,
		COMP.COMPONENT_ID,
		p_DETAIL_TYPE,
		FC.CHARGE_AMOUNT,
		FC.CHARGE_QUANTITY,
		BS.ENTITY_ID,
		BS.PRODUCT_ID,
		NULL, -- TDIE_ID
		NULL,  -- REVIEW_STATUS
		NULL -- JURISDICTION
	FROM (SELECT DISTINCT C.COMPONENT_ID, S.SETTLEMENT_PSE_ID AS ENTITY_ID
		FROM SEM_SETTLEMENT_ENTITY S,
			INTERCHANGE_CONTRACT IC,
			CONTRACT_PRODUCT_COMPONENT CPC,
			SEM_SLMT_VAL_COMPONENTS C
		WHERE S.PARTICIPANT_PSE_ID = p_PARTICIPANT_ID
			AND IC.BILLING_ENTITY_ID = S.SETTLEMENT_PSE_ID
			AND IC.BEGIN_DATE <= p_END_DATE
			AND NVL(IC.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND CPC.CONTRACT_ID = IC.CONTRACT_ID
			AND CPC.BEGIN_DATE <= p_END_DATE
			AND NVL(CPC.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND C.COMPONENT_ID = CPC.COMPONENT_ID
			AND (C.COMPONENT_NAME = p_COMPONENT_NAME OR CONSTANTS.ALL_STRING = p_COMPONENT_NAME)) COMP,
		BILLING_STATEMENT BS,
		FORMULA_CHARGE_ITERATOR FI,
		FORMULA_CHARGE FC
	WHERE BS.ENTITY_ID = COMP.ENTITY_ID
		AND BS.COMPONENT_ID = COMP.COMPONENT_ID
		AND BS.STATEMENT_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
		AND BS.STATEMENT_TYPE = p_STATEMENT_TYPE_ID
		AND BS.STATEMENT_STATE = p_STATEMENT_STATE
		AND BS.AS_OF_DATE = LOW_DATE
		AND FI.CHARGE_ID = BS.CHARGE_ID
		AND (FI.ITERATOR1 = p_SUPPLIER_UNIT OR CONSTANTS.ALL_STRING = p_SUPPLIER_UNIT)
		AND FC.CHARGE_ID = BS.CHARGE_ID
		AND FC.ITERATOR_ID = FI.ITERATOR_ID;
END CACHE_FORMULA_CHARGE_DETAILS;
---------------------------------------------------------------------------------
PROCEDURE CHARGE_AMOUNT_INTERVAL_DETAILS
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INTERVAL IN VARCHAR2, -- '30 Minute' or 'Day'
	p_PARTICIPANT_ID IN NUMBER,
	p_STMT_TYPE IN NUMBER,
	p_COMPONENT IN VARCHAR2,
	p_SUPPLIER_UNIT IN VARCHAR2, -- Supplier Unit or '<All>'
	p_ENABLE_TOLERANCE IN NUMBER,
	p_PIR_PCT_TOLERANCE_DIFF IN VARCHAR2,
	p_TDIE_PCT_TOLERANCE_DIFF IN VARCHAR2,
	p_INTERNAL_PCT_TOLERANCE_DIFF IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR,
	p_MESSAGE OUT VARCHAR2
	) AS
	v_EXT_IDENT_STMT_TYPE EXTERNAL_SYSTEM_IDENTIFIER.EXTERNAL_IDENTIFIER%TYPE;
	v_PIR_STMT_TYPE_ID STATEMENT_TYPE.STATEMENT_TYPE_ID%TYPE;
	v_TDIE_STMT_TYPE_ID STATEMENT_TYPE.STATEMENT_TYPE_ID%TYPE;
	v_CUT_BEGIN_DATE DATE;
	v_CUT_END_DATE DATE;
	v_STATEMENT_TYPE_NAME STATEMENT_TYPE.STATEMENT_TYPE_NAME%TYPE;
	v_PIR_PCT_TOLERANCE_DIFF NUMBER;
	v_TDIE_PCT_TOLERANCE_DIFF NUMBER;
	v_INTERNAL_PCT_TOLERANCE_DIFF NUMBER;
BEGIN
	-- Check if the % Difference Tolerance values are valid numbers
	TOLERANCE_FILTER_TO_NUMBER('PIR', p_PIR_PCT_TOLERANCE_DIFF, v_PIR_PCT_TOLERANCE_DIFF, p_MESSAGE);
	IF p_MESSAGE IS NULL THEN
		TOLERANCE_FILTER_TO_NUMBER('IE T&D', p_TDIE_PCT_TOLERANCE_DIFF, v_TDIE_PCT_TOLERANCE_DIFF, p_MESSAGE);
	END IF;
	IF p_MESSAGE IS NULL THEN
		TOLERANCE_FILTER_TO_NUMBER('Internal', p_INTERNAL_PCT_TOLERANCE_DIFF, v_INTERNAL_PCT_TOLERANCE_DIFF, p_MESSAGE);
	END IF;
	IF p_MESSAGE IS NOT NULL THEN
		NULL_CURSOR(p_CURSOR);
		RETURN;
	END IF;

	IF p_ENABLE_TOLERANCE = 1 THEN
		-- Validate if we have at least one of the % Difference input to run a variance report
		IF v_PIR_PCT_TOLERANCE_DIFF IS NULL AND v_TDIE_PCT_TOLERANCE_DIFF IS NULL AND p_INTERNAL_PCT_TOLERANCE_DIFF IS NULL THEN
			p_MESSAGE := c_MSG_MISSING_TOL_DIFF;
			NULL_CURSOR(p_CURSOR);
			RETURN;
		END IF;
	END IF;

	SP.CHECK_SYSTEM_DATE_TIME(MM_SEM_UTIL.g_TZ,p_BEGIN_DATE,p_END_DATE);
	UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, MM_SEM_UTIL.g_TZ, v_CUT_BEGIN_DATE, v_CUT_END_DATE);

	v_STATEMENT_TYPE_NAME := EI.GET_ENTITY_NAME(EC.ED_STATEMENT_TYPE, p_STMT_TYPE);
	-- Get the External Identifier for the Statement
	v_EXT_IDENT_STMT_TYPE := EI.GET_ENTITY_IDENTIFIER_EXTSYS(EC.ED_STATEMENT_TYPE, p_STMT_TYPE, EC.ES_SEM, MM_SEM_UTIL.g_STATEMENT_TYPE_SETTLEMENT);

	-- Get the PIR Statement Type ID
	v_PIR_STMT_TYPE_ID := EI.GET_ID_FROM_IDENTIFIER_EXTSYS('SMO ' || v_EXT_IDENT_STMT_TYPE,
							EC.ED_STATEMENT_TYPE,
							EC.ES_SEM,
							MM_SEM_UTIL.g_STATEMENT_TYPE_SETTLEMENT,
							1);

	-- Get the TDIE Statement Type ID
	v_TDIE_STMT_TYPE_ID := EI.GET_ID_FROM_IDENTIFIER_EXTSYS(v_EXT_IDENT_STMT_TYPE,
							EC.ED_STATEMENT_TYPE,
							EC.ES_TDIE,
							EI.g_DEFAULT_IDENTIFIER_TYPE,
							1);

	-- Truncate the temporary table
	EXECUTE IMMEDIATE 'TRUNCATE TABLE SEM_SETTLEMENT_COMP_DTL_WORK';

	-- Statement Amount
	CACHE_FORMULA_CHARGE_DETAILS(p_BEGIN_DATE,
								p_END_DATE,
								p_PARTICIPANT_ID,
								p_STMT_TYPE,
								CONSTANTS.EXTERNAL_STATE,
								p_COMPONENT,
								p_SUPPLIER_UNIT,
								g_STMT_VAL_DETAIL_TYPE_STMT);

	-- PIR Amount
	CACHE_FORMULA_CHARGE_DETAILS(p_BEGIN_DATE,
								p_END_DATE,
								p_PARTICIPANT_ID,
								v_PIR_STMT_TYPE_ID,
								CONSTANTS.INTERNAL_STATE,
								p_COMPONENT,
								p_SUPPLIER_UNIT,
								g_STMT_VAL_DETAIL_TYPE_PIR);

	-- TDIE Amount
	CACHE_FORMULA_CHARGE_DETAILS(p_BEGIN_DATE,
								p_END_DATE,
								p_PARTICIPANT_ID,
								v_TDIE_STMT_TYPE_ID,
								CONSTANTS.INTERNAL_STATE,
								p_COMPONENT,
								p_SUPPLIER_UNIT,
								g_STMT_VAL_DETAIL_TYPE_TDIE);
	-- Internal Amount
	CACHE_FORMULA_CHARGE_DETAILS(p_BEGIN_DATE,
								p_END_DATE,
								p_PARTICIPANT_ID,
								p_STMT_TYPE,
								CONSTANTS.INTERNAL_STATE,
								p_COMPONENT,
								p_SUPPLIER_UNIT,
								g_STMT_VAL_DETAIL_TYPE_INT);

	OPEN p_CURSOR FOR
		SELECT DETAILS.*,
			p_ENABLE_TOLERANCE AS ENABLE_TOLERANCE,
			v_PIR_PCT_TOLERANCE_DIFF AS PIR_PCT_TOLERANCE_DIFF,
			v_TDIE_PCT_TOLERANCE_DIFF AS TDIE_PCT_TOLERANCE_DIFF,
			v_INTERNAL_PCT_TOLERANCE_DIFF AS INTERNAL_PCT_TOLERANCE_DIFF
		FROM (SELECT S.ENTITY_ID,
				S.PRODUCT_ID,
				C.COMPONENT_ID,
				C.COMPONENT_NAME,
				p_STMT_TYPE AS STATEMENT_TYPE,
				v_STATEMENT_TYPE_NAME AS STATEMENT_TYPE_NAME,
				S.STATEMENT_DATE,
				S.SUPPLIER_UNIT,
				CASE p_INTERVAL
					WHEN DATE_UTIL.c_NAME_30MIN THEN TRIM(SDT.MI30_YYYY_MM_DD)
					WHEN DATE_UTIL.c_NAME_DAY THEN TRIM(SDT.DAY_YYYY_MM_DD)
				END AS DETAIL_DATE_STR,
				SUM(CASE WHEN S.DETAIL_TYPE = g_STMT_VAL_DETAIL_TYPE_STMT THEN S.AMOUNT ELSE NULL END) AS STATEMENT_AMOUNT,
				SUM(CASE WHEN S.DETAIL_TYPE = g_STMT_VAL_DETAIL_TYPE_PIR THEN S.AMOUNT ELSE NULL END) AS PIR_AMOUNT,
				SUM(CASE WHEN S.DETAIL_TYPE = g_STMT_VAL_DETAIL_TYPE_TDIE THEN S.AMOUNT ELSE NULL END) AS TDIE_AMOUNT,
				SUM(CASE WHEN S.DETAIL_TYPE = g_STMT_VAL_DETAIL_TYPE_INT THEN S.AMOUNT ELSE NULL END) AS INTERNAL_AMOUNT,
				MAX(CASE WHEN D.DISPUTE_DATE IS NULL OR UPPER(D.DISPUTE_STATUS) = 'NONE' OR UPPER(D.DISPUTE_STATUS) = 'RESOLVED' OR UPPER(D.DISPUTE_STATUS) = 'CANCELLED'  THEN 0 ELSE 1 END) AS DISPUTE_STATUS
			FROM SEM_SETTLEMENT_COMP_DTL_WORK S,
				COMPONENT C,
				BILLING_CHARGE_DISPUTE D,
				SYSTEM_DATE_TIME SDT
			WHERE C.COMPONENT_ID = S.COMPONENT_ID
				-- Billing Dispute
				AND D.ENTITY_ID(+) = S.ENTITY_ID
				AND D.PRODUCT_ID(+) = S.PRODUCT_ID
				AND D.COMPONENT_ID(+) = S.COMPONENT_ID
				AND D.STATEMENT_TYPE(+) = S.STATEMENT_TYPE
				AND D.STATEMENT_STATE(+) = CONSTANTS.EXTERNAL_STATE -- State of the Statement
				AND D.STATEMENT_DATE(+) = S.STATEMENT_DATE
				AND D.DISPUTE_DATE(+) = S.DETAIL_DATE
				AND D.ITERATOR1(+) = S.SUPPLIER_UNIT
				-- System Date Time
				AND SDT.TIME_ZONE = MM_SEM_UTIL.g_TZ
				AND SDT.DATA_INTERVAL_TYPE = 1
				AND SDT.DAY_TYPE = '1'
				AND SDT.CUT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
				AND S.DETAIL_DATE(+) = SDT.CUT_DATE
				AND S.STATEMENT_DATE IS NOT NULL
			GROUP BY S.ENTITY_ID,
				S.PRODUCT_ID,
				C.COMPONENT_ID,
				C.COMPONENT_NAME,
				p_STMT_TYPE,
				v_STATEMENT_TYPE_NAME,
				S.STATEMENT_DATE,
				S.SUPPLIER_UNIT,
				CASE p_INTERVAL
					WHEN DATE_UTIL.c_NAME_30MIN THEN TRIM(SDT.MI30_YYYY_MM_DD)
					WHEN DATE_UTIL.c_NAME_DAY THEN TRIM(SDT.DAY_YYYY_MM_DD)
				END) DETAILS
		WHERE ((p_ENABLE_TOLERANCE = 1 AND NVL(STATEMENT_AMOUNT,0) <> 0 AND
					((PIR_AMOUNT IS NOT NULL AND v_PIR_PCT_TOLERANCE_DIFF IS NOT NULL AND ABS((STATEMENT_AMOUNT - NVL(PIR_AMOUNT,0))/STATEMENT_AMOUNT)*100 > v_PIR_PCT_TOLERANCE_DIFF)
					OR (TDIE_AMOUNT IS NOT NULL AND v_TDIE_PCT_TOLERANCE_DIFF IS NOT NULL AND ABS((STATEMENT_AMOUNT - NVL(TDIE_AMOUNT,0))/STATEMENT_AMOUNT)*100 > v_TDIE_PCT_TOLERANCE_DIFF)
					 OR (INTERNAL_AMOUNT IS NOT NULL AND v_INTERNAL_PCT_TOLERANCE_DIFF IS NOT NULL AND ABS((STATEMENT_AMOUNT - NVL(INTERNAL_AMOUNT,0))/STATEMENT_AMOUNT)*100 > v_INTERNAL_PCT_TOLERANCE_DIFF))
				) OR p_ENABLE_TOLERANCE = 0)
		ORDER BY COMPONENT_NAME,
			SUPPLIER_UNIT,
			STATEMENT_TYPE_NAME,
			DETAIL_DATE_STR;

END CHARGE_AMOUNT_INTERVAL_DETAILS;
---------------------------------------------------------------------------------
PROCEDURE CACHE_SCHEDULE_DETAILS
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PARTICIPANT_ID IN NUMBER,
	p_STATEMENT_TYPE_ID IN NUMBER,
	p_SUPPLIER_UNIT IN VARCHAR2,-- Supplier Unit or '<All>'
	p_DETAIL_TYPE IN VARCHAR2 -- 300,341 and 342
	) AS
	v_BEGIN_DATE DATE;
	v_END_DATE DATE;
BEGIN
	UT.CUT_DATE_RANGE(CONSTANTS.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, MM_SEM_UTIL.g_TZ,
					v_BEGIN_DATE, v_END_DATE);

    -- Get accepted backcast schedules that represent 300/341 aggregated volumes
    IF p_DETAIL_TYPE IN (g_STMT_VAL_DETAIL_TYPE_300, g_STMT_VAL_DETAIL_TYPE_341) THEN

        INSERT INTO SEM_SETTLEMENT_COMP_DTL_WORK
        SELECT -- Subtracted a second to get the correct Local Day
            TRUNC(FROM_CUT(S.SCHEDULE_DATE, MM_SEM_UTIL.g_TZ)-1/86400) AS STATEMENT_DATE,
            DATE_UTIL.HED_TRUNC(S.SCHEDULE_DATE, DATE_UTIL.c_ABBR_30MIN) AS DETAIL_DATE,
            IDENT.EXTERNAL_IDENTIFIER AS SUPPLIER_UNIT,
            S.SCHEDULE_TYPE AS STATEMENT_TYPE,
            -1 AS COMPONENT_ID,
            p_DETAIL_TYPE AS DETAIL_TYPE,
            NULL AS AMOUNT,
            SUM(S.AMOUNT) AS QUANTITY,
            NULL, -- ENTITY_ID
            NULL, -- PRODUCT_ID
            NULL, -- TDIE_ID
            NULL,  -- UNDER_REVIEW
            NULL -- JURISDICTION
        FROM SEM_MP_UNITS SP,
            EXTERNAL_SYSTEM_IDENTIFIER IDENT,
            INTERCHANGE_TRANSACTION IT,
            IT_COMMODITY C,
            SCHEDULE_COORDINATOR SC,
            SCHEDULE_GROUP SG,
            IT_SCHEDULE S
        WHERE -- Service Point
            SP.PSE_ID = p_PARTICIPANT_ID
            AND SP.RESOURCE_TYPE LIKE '%SU%'
            AND SP.EFFECTIVE_DATE(+) <= p_END_DATE
            AND NVL(SP.EXPIRATION_DATE(+), CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
            AND IDENT.EXTERNAL_SYSTEM_ID = EC.ES_SEM
            AND IDENT.ENTITY_DOMAIN_ID = EC.ED_SERVICE_POINT
            AND IDENT.IDENTIFIER_TYPE = EI.g_DEFAULT_IDENTIFIER_TYPE
            AND (IDENT.EXTERNAL_IDENTIFIER = p_SUPPLIER_UNIT OR CONSTANTS.ALL_STRING = p_SUPPLIER_UNIT)
            AND IDENT.ENTITY_ID = SP.POD_ID
            -- Interchange Transaction, Commodity and Schedule Group
            AND IT.BEGIN_DATE <= p_END_DATE
            AND NVL(IT.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
            AND C.COMMODITY_ID(+) = IT.COMMODITY_ID
            AND SC.SC_ID(+) = IT.SC_ID
            AND SG.SCHEDULE_GROUP_ID(+) = IT.SCHEDULE_GROUP_ID
            AND SC.SC_ALIAS IN (MM_TDIE_UTIL.c_ESBN_ALIAS,MM_TDIE_UTIL.c_NIE_ALIAS)
            AND IT.POD_ID = SP.POD_ID
            AND IT.TRANSACTION_TYPE = g_TXN_TYPE_LOAD
            AND C.COMMODITY_ALIAS = g_COMMODITY_ALIAS_RETAIL_LOAD
            AND IT.TRANSACTION_INTERVAL IN (DATE_UTIL.c_NAME_15MIN,DATE_UTIL.c_NAME_30MIN)
            AND SG.METER_TYPE = CASE p_DETAIL_TYPE WHEN g_STMT_VAL_DETAIL_TYPE_300 THEN g_SG_METER_TYPE_PERIOD ELSE g_SG_METER_TYPE_INTERVAL END
            -- Transaction Schedule
            AND S.TRANSACTION_ID = IT.TRANSACTION_ID
            AND S.SCHEDULE_TYPE = p_STATEMENT_TYPE_ID
            AND S.SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE
            AND S.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
        GROUP BY TRUNC(FROM_CUT(S.SCHEDULE_DATE, MM_SEM_UTIL.g_TZ)-1/86400),
            DATE_UTIL.HED_TRUNC(S.SCHEDULE_DATE, DATE_UTIL.c_ABBR_30MIN),
            IDENT.EXTERNAL_IDENTIFIER,
            S.SCHEDULE_TYPE;
    -- Get accepted backcast schedules that represent 342 aggregated volumes by Earn ID
    -- for non-participating generator units
    ELSIF p_DETAIL_TYPE = g_STMT_VAL_DETAIL_TYPE_342 THEN
        INSERT INTO SEM_SETTLEMENT_COMP_DTL_WORK
        SELECT -- Subtracted a second to get the correct Local Day
            TRUNC(FROM_CUT(S.SCHEDULE_DATE, MM_SEM_UTIL.g_TZ)-1/86400) AS STATEMENT_DATE,
            DATE_UTIL.HED_TRUNC(S.SCHEDULE_DATE, DATE_UTIL.c_ABBR_30MIN) AS DETAIL_DATE,
            TGU.SUPPLIER_UNIT,
            S.SCHEDULE_TYPE AS STATEMENT_TYPE,
            -1 AS COMPONENT_ID,
            p_DETAIL_TYPE AS DETAIL_TYPE,
            NULL AS AMOUNT,
            -1 * SUM(S.AMOUNT) AS QUANTITY,
            NULL, -- ENTITY_ID
            NULL, -- PRODUCT_ID
            NULL, -- TDIE_ID
            NULL,  -- UNDER_REVIEW
            NULL -- JURISDICTION
        FROM (SELECT DISTINCT GEN_SP_ID, SUPPLIER_UNIT FROM TDIE_GEN_UNITS
                WHERE PSE_ID = p_PARTICIPANT_ID
                    AND (SUPPLIER_UNIT = p_SUPPLIER_UNIT OR CONSTANTS.ALL_STRING = p_SUPPLIER_UNIT)
                    AND BEGIN_DATE <= p_END_DATE
                    AND NVL(END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE) TGU,
            INTERCHANGE_TRANSACTION IT,
            IT_COMMODITY C,
            SCHEDULE_COORDINATOR SC,
            SCHEDULE_GROUP SG,
            IT_SCHEDULE S
        WHERE -- Interchange Transaction, Commodity and Schedule Group
            IT.BEGIN_DATE <= p_END_DATE
            AND NVL(IT.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
            AND C.COMMODITY_ID(+) = IT.COMMODITY_ID
            AND SC.SC_ID(+) = IT.SC_ID
            AND SG.SCHEDULE_GROUP_ID(+) = IT.SCHEDULE_GROUP_ID
            AND SC.SC_ALIAS IN (MM_TDIE_UTIL.c_ESBN_ALIAS,MM_TDIE_UTIL.c_NIE_ALIAS)
            AND IT.POD_ID = TGU.GEN_SP_ID
            AND IT.TRANSACTION_TYPE = g_TXN_TYPE_LOAD
            AND C.COMMODITY_ALIAS = g_COMMODITY_ALIAS_RETAIL_LOAD
            AND IT.TRANSACTION_INTERVAL IN (DATE_UTIL.c_NAME_15MIN,DATE_UTIL.c_NAME_30MIN)
            AND SG.METER_TYPE = g_SG_METER_TYPE_INTERVAL
            -- Transaction Schedule
            AND S.TRANSACTION_ID = IT.TRANSACTION_ID
            AND S.SCHEDULE_TYPE = p_STATEMENT_TYPE_ID
            AND S.SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE
            AND S.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
        GROUP BY TRUNC(FROM_CUT(S.SCHEDULE_DATE, MM_SEM_UTIL.g_TZ)-1/86400),
            DATE_UTIL.HED_TRUNC(S.SCHEDULE_DATE, DATE_UTIL.c_ABBR_30MIN),
            TGU.SUPPLIER_UNIT,
            S.SCHEDULE_TYPE;
    END IF;

END CACHE_SCHEDULE_DETAILS;
---------------------------------------------------------------------------------
PROCEDURE CACHE_TDIE_DETAILS
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PARTICIPANT_ID IN NUMBER,
	p_STATEMENT_TYPE_ID IN NUMBER,
	p_COMPONENT_NAME IN VARCHAR2,
	p_SUPPLIER_UNIT IN VARCHAR2, -- Supplier Unit or '<All>'
	p_DETAIL_TYPE IN VARCHAR2 -- 591, 595 and 598
	) AS
	v_MARKET_TYPE SEM_SETTLEMENT_CALENDAR.MARKET%TYPE;
	v_COMPONENT_ID COMPONENT.COMPONENT_ID% TYPE := EI.GET_ID_FROM_NAME(p_COMPONENT_NAME, EC.ED_COMPONENT);
BEGIN
	-- Get the Market Type from the Component
	SELECT COMPONENT_CATEGORY
	INTO v_MARKET_TYPE
	FROM COMPONENT
	WHERE COMPONENT_NAME = p_COMPONENT_NAME;

    IF p_DETAIL_TYPE IN (g_STMT_VAL_DETAIL_TYPE_591, g_STMT_VAL_DETAIL_TYPE_595) THEN
        INSERT INTO SEM_SETTLEMENT_COMP_DTL_WORK
            -- ROI591,595
            SELECT DETAILS.SETTLEMENT_DATE,
                DETAILS.DETAIL_DATE,
                DETAILS.LOCATION_ID AS UNIT_ID,
                p_STATEMENT_TYPE_ID,
                v_COMPONENT_ID, -- COMPONENT
                p_DETAIL_TYPE,
                NULL, -- AMOUNT
                SUM(DETAILS.QUANTITY)/1000 AS QUANTITY, -- 591 and 595 Volumes are in KWh
                NULL, -- ENTITY_ID
                NULL, -- PRODUCT_ID
                DETAILS.TDIE_ID,
                MAX(DETAILS.UNDER_REVIEW) AS UNDER_REVIEW,
                JURISDICTION
            FROM (SELECT TM.MESSAGE_DATE AS SETTLEMENT_DATE,
                    DATE_UTIL.HED_TRUNC(TAC.INTERVAL_PERIOD_TIMESTAMP, DATE_UTIL.c_ABBR_30MIN) AS DETAIL_DATE,
                    TM.LOCATION_ID,
                    TAC.LA_AGGREGATED_CONSUMPTION AS QUANTITY,
                    TM.TDIE_ID,
                    TAC.UNDER_REVIEW,
                    'ROI' AS JURISDICTION
                FROM EXTERNAL_SYSTEM_IDENTIFIER IDENT,
                    SEM_MP_UNITS SP,
                    TDIE_MESSAGE TM,
                    TDIE_AGG_CONSUMPTION TAC
                WHERE -- Supplier Unit(s) for the participant
                    SP.PSE_ID = p_PARTICIPANT_ID
                    AND SP.RESOURCE_TYPE LIKE '%SU%'
                    AND SP.EFFECTIVE_DATE(+) <= p_END_DATE
                    AND NVL(SP.EXPIRATION_DATE(+), CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
                    AND IDENT.EXTERNAL_SYSTEM_ID = EC.ES_SEM
                    AND IDENT.ENTITY_DOMAIN_ID = EC.ED_SERVICE_POINT
                    AND IDENT.IDENTIFIER_TYPE = EI.g_DEFAULT_IDENTIFIER_TYPE
                    AND (IDENT.EXTERNAL_IDENTIFIER = p_SUPPLIER_UNIT OR CONSTANTS.ALL_STRING = p_SUPPLIER_UNIT)
                    AND IDENT.ENTITY_ID = SP.POD_ID
                    -- TDIE Message
                    AND TM.MESSAGE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
                    AND TM.MESSAGE_TYPE_CODE = p_DETAIL_TYPE
                    AND TM.LOCATION_ID = IDENT.EXTERNAL_IDENTIFIER
                    AND TM.SETTLEMENT_RUN_INDICATOR = DETERMINE_SLMT_RUN_INDICATOR(p_STATEMENT_TYPE_ID, TM.MESSAGE_DATE, v_MARKET_TYPE, MM_TDIE_UTIL.c_TDIE_JURISDICTION_ROI)
                    -- TDIE Agg Consumption
                    AND TAC.TDIE_ID = TM.TDIE_ID
                UNION ALL
                SELECT N.SETTLEMENT_DATE,
                    DATE_UTIL.HED_TRUNC(N.SCHEDULE_DATE, DATE_UTIL.c_ABBR_30MIN) AS DETAIL_DATE,
                    N.UNIT_ID,
                    N.QUANTITY,
                    N.TDIE_ID,
                    CASE WHEN REV.TDIE_ID IS NULL THEN 0 ELSE 1 END AS UNDER_REVIEW,
                    'NIE' AS JURISDICTION
                FROM
                    -- N591,595
                    (SELECT TM.MESSAGE_DATE AS SETTLEMENT_DATE,
                        TND.SCHEDULE_DATE,
                        TM.LOCATION_ID AS UNIT_ID,
                        TND.ENERGY AS QUANTITY,
                        TM.TDIE_ID
                    FROM EXTERNAL_SYSTEM_IDENTIFIER IDENT,
                        SEM_MP_UNITS SP,
                        TDIE_MESSAGE TM,
                        TDIE_NIETD TN,
                        TDIE_NIETD_DETAIL TND
                    WHERE -- Supplier Unit(s) for the participant
                        SP.PSE_ID = p_PARTICIPANT_ID
                        AND SP.RESOURCE_TYPE LIKE '%SU%'
                        AND SP.EFFECTIVE_DATE(+) <= p_END_DATE
                        AND NVL(SP.EXPIRATION_DATE(+), CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
                        AND IDENT.EXTERNAL_SYSTEM_ID = EC.ES_SEM
                        AND IDENT.ENTITY_DOMAIN_ID = EC.ED_SERVICE_POINT
                        AND IDENT.IDENTIFIER_TYPE = EI.g_DEFAULT_IDENTIFIER_TYPE
                        AND (IDENT.EXTERNAL_IDENTIFIER = p_SUPPLIER_UNIT OR CONSTANTS.ALL_STRING = p_SUPPLIER_UNIT)
                        AND IDENT.ENTITY_ID = SP.POD_ID
                        -- TDIE Message
                        AND TM.MESSAGE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
                        AND TM.MESSAGE_TYPE_CODE = 'N' || p_DETAIL_TYPE
                        AND TM.LOCATION_ID = IDENT.EXTERNAL_IDENTIFIER
                        AND TM.SETTLEMENT_RUN_INDICATOR = DETERMINE_SLMT_RUN_INDICATOR(p_STATEMENT_TYPE_ID, TM.MESSAGE_DATE, v_MARKET_TYPE, MM_TDIE_UTIL.c_TDIE_JURISDICTION_NI)
                        -- TDIE NIETD and Details
                        AND TN.TDIE_ID = TM.TDIE_ID
                        AND TND.TDIE_DETAIL_ID = TN.TDIE_DETAIL_ID
                        AND TND.ENERGY_TYPE = 'P') N, -- Use Period Energy Type only
                    TDIE_NIETD_UNDER_REVIEW REV
                    WHERE -- Under Review flag
                        REV.TDIE_ID(+) = N.TDIE_ID
                        AND REV.SCHEDULE_DATE(+) = N.SCHEDULE_DATE
                        AND REV.ENERGY_TYPE(+) = 'P'
                ) DETAILS
            GROUP BY DETAILS.SETTLEMENT_DATE,
                DETAILS.DETAIL_DATE,
                DETAILS.LOCATION_ID,
                p_STATEMENT_TYPE_ID,
                v_COMPONENT_ID, -- COMPONENT
                p_DETAIL_TYPE,
                NULL, -- AMOUNT
                NULL, -- ENTITY_ID
                NULL, -- PRODUCT_ID
                DETAILS.TDIE_ID, -- Use Period Energy Type only
                JURISDICTION;
    ELSIF p_DETAIL_TYPE = g_STMT_VAL_DETAIL_TYPE_598 THEN
        INSERT INTO SEM_SETTLEMENT_COMP_DTL_WORK
        SELECT DETAILS.SETTLEMENT_DATE,
            DETAILS.DETAIL_DATE,
            DETAILS.SUPPLIER_UNIT,
            p_STATEMENT_TYPE_ID,
            v_COMPONENT_ID, -- COMPONENT
            p_DETAIL_TYPE,
            NULL, -- AMOUNT
            SUM(DETAILS.QUANTITY)/1000 AS QUANTITY, -- 591 and 595 Volumes are in KWh
            NULL, -- ENTITY_ID
            NULL, -- PRODUCT_ID
            NULL, -- TDIE_ID,
            NULL AS UNDER_REVIEW,
            JURISDICTION
        FROM (-- ROI598
            SELECT TM.MESSAGE_DATE AS SETTLEMENT_DATE,
                DATE_UTIL.HED_TRUNC(TAG.INTERVAL_PERIOD_TIMESTAMP, DATE_UTIL.c_ABBR_30MIN) AS DETAIL_DATE,
                G.SUPPLIER_UNIT AS SUPPLIER_UNIT,
                TAG.LA_METERED_GENERATION AS QUANTITY,
                TM.TDIE_ID,
                'ROI' AS JURISDICTION
            FROM (SELECT DISTINCT SUPPLIER_UNIT, GENERATOR_UNIT FROM TDIE_GEN_UNITS
                WHERE PSE_ID = p_PARTICIPANT_ID
                    AND (SUPPLIER_UNIT = p_SUPPLIER_UNIT OR CONSTANTS.ALL_STRING = p_SUPPLIER_UNIT)
                    AND BEGIN_DATE <= p_END_DATE
                    AND NVL(END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE) G,
                TDIE_MESSAGE TM,
                TDIE_AGG_GENERATION TAG
            WHERE -- TDIE Message
                TM.MESSAGE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
                AND TM.MESSAGE_TYPE_CODE = p_DETAIL_TYPE
                AND TM.LOCATION_ID = G.GENERATOR_UNIT
                AND TM.SETTLEMENT_RUN_INDICATOR = DETERMINE_SLMT_RUN_INDICATOR(p_STATEMENT_TYPE_ID, TM.MESSAGE_DATE, v_MARKET_TYPE, MM_TDIE_UTIL.c_TDIE_JURISDICTION_ROI)
                -- TDIE Agg Generation
                AND TAG.TDIE_ID = TM.TDIE_ID
            UNION ALL
            --N598
            SELECT TM.MESSAGE_DATE AS SETTLEMENT_DATE,
                DATE_UTIL.HED_TRUNC(TND.SCHEDULE_DATE, DATE_UTIL.c_ABBR_30MIN) AS DETAIL_DATE,
                G.SUPPLIER_UNIT AS SUPPLIER_UNIT,
                TND.ENERGY AS QUANTITY,
                TM.TDIE_ID,
                'NIE' AS JURISDICTION
            FROM (SELECT DISTINCT SUPPLIER_UNIT, GENERATOR_UNIT FROM TDIE_GEN_UNITS
                WHERE PSE_ID = p_PARTICIPANT_ID
                    AND (SUPPLIER_UNIT = p_SUPPLIER_UNIT OR CONSTANTS.ALL_STRING = p_SUPPLIER_UNIT)
                    AND BEGIN_DATE <= p_END_DATE
                    AND NVL(END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE) G,
                TDIE_MESSAGE TM,
                TDIE_NIETD TN,
                TDIE_NIETD_DETAIL TND
            WHERE -- TDIE Message
                TM.MESSAGE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
                AND TM.MESSAGE_TYPE_CODE = 'N' || p_DETAIL_TYPE
                AND TM.LOCATION_ID = G.GENERATOR_UNIT
                AND TM.SETTLEMENT_RUN_INDICATOR = DETERMINE_SLMT_RUN_INDICATOR(p_STATEMENT_TYPE_ID, TM.MESSAGE_DATE, v_MARKET_TYPE, MM_TDIE_UTIL.c_TDIE_JURISDICTION_NI)
                -- TDIE NIETD and Details
                AND TN.TDIE_ID = TM.TDIE_ID
                AND TND.TDIE_DETAIL_ID = TN.TDIE_DETAIL_ID
                AND TND.ENERGY_TYPE = 'P'
            ) DETAILS
        GROUP BY DETAILS.SETTLEMENT_DATE,
            DETAILS.DETAIL_DATE,
            DETAILS.SUPPLIER_UNIT,
            p_STATEMENT_TYPE_ID,
            v_COMPONENT_ID, -- COMPONENT
            p_DETAIL_TYPE,
            NULL, -- AMOUNT
            NULL, -- ENTITY_ID
            NULL, -- PRODUCT_ID
            NULL, -- TDIE_ID
            JURISDICTION;
    END IF;
END CACHE_TDIE_DETAILS;
---------------------------------------------------------------------------------
PROCEDURE ENERGY_VOLUME_INTERVAL_DETAILS
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INTERVAL IN VARCHAR2, -- '30 Minute' or 'Day'
	p_PARTICIPANT_ID IN NUMBER,
	p_STMT_TYPE IN NUMBER,
	p_COMPONENT_NAME IN VARCHAR2,
	p_SUPPLIER_UNIT IN VARCHAR2, -- Supplier Unit or '<All>'
	p_ENABLE_TOLERANCE IN NUMBER,
	p_TDIE_PCT_TOLERANCE_DIFF IN VARCHAR2,
	p_INTERNAL_PCT_TOLERANCE_DIFF IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR,
	p_MESSAGE OUT VARCHAR2
	) AS
	v_EXT_IDENT_STMT_TYPE EXTERNAL_SYSTEM_IDENTIFIER.EXTERNAL_IDENTIFIER%TYPE;
	v_TDIE_STMT_TYPE_ID STATEMENT_TYPE.STATEMENT_TYPE_ID%TYPE;
	v_COMPONENT_ID COMPONENT.COMPONENT_ID%TYPE := EI.GET_ID_FROM_NAME(p_COMPONENT_NAME, EC.ED_COMPONENT);
	v_CUT_BEGIN_DATE DATE;
	v_CUT_END_DATE DATE;
	v_STATEMENT_TYPE_NAME STATEMENT_TYPE.STATEMENT_TYPE_NAME%TYPE;
	v_TDIE_PCT_TOLERANCE_DIFF NUMBER;
	v_INTERNAL_PCT_TOLERANCE_DIFF NUMBER;
BEGIN
	-- Check if the % Difference Tolerance values are valid numbers
	TOLERANCE_FILTER_TO_NUMBER('IE T&D', p_TDIE_PCT_TOLERANCE_DIFF, v_TDIE_PCT_TOLERANCE_DIFF, p_MESSAGE);
	IF p_MESSAGE IS NULL THEN
		TOLERANCE_FILTER_TO_NUMBER('Internal', p_INTERNAL_PCT_TOLERANCE_DIFF, v_INTERNAL_PCT_TOLERANCE_DIFF, p_MESSAGE);
	END IF;
	IF p_MESSAGE IS NOT NULL THEN
		NULL_CURSOR(p_CURSOR);
		RETURN;
	END IF;

	IF p_ENABLE_TOLERANCE = 1 THEN
		-- Validate if we have at least one of the % Difference input to run a variance report
		IF v_TDIE_PCT_TOLERANCE_DIFF IS NULL AND v_INTERNAL_PCT_TOLERANCE_DIFF IS NULL THEN
			p_MESSAGE := c_MSG_MISSING_TOL_DIFF_ENERGY;
			NULL_CURSOR(p_CURSOR);
			RETURN;
		END IF;
	END IF;

	SP.CHECK_SYSTEM_DATE_TIME(MM_SEM_UTIL.g_TZ,p_BEGIN_DATE,p_END_DATE);
	UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, MM_SEM_UTIL.g_TZ, v_CUT_BEGIN_DATE, v_CUT_END_DATE);

	v_STATEMENT_TYPE_NAME := EI.GET_ENTITY_NAME(EC.ED_STATEMENT_TYPE, p_STMT_TYPE);
	-- Get the External Identifier for the Statement
	v_EXT_IDENT_STMT_TYPE := EI.GET_ENTITY_IDENTIFIER_EXTSYS(EC.ED_STATEMENT_TYPE, p_STMT_TYPE, EC.ES_SEM, MM_SEM_UTIL.g_STATEMENT_TYPE_SETTLEMENT);

	-- Get the TDIE Statement Type ID
	v_TDIE_STMT_TYPE_ID := EI.GET_ID_FROM_IDENTIFIER_EXTSYS(v_EXT_IDENT_STMT_TYPE,
							EC.ED_STATEMENT_TYPE,
							EC.ES_TDIE,
							EI.g_DEFAULT_IDENTIFIER_TYPE,
							1);

	-- Truncate the temporary table
	EXECUTE IMMEDIATE 'TRUNCATE TABLE SEM_SETTLEMENT_COMP_DTL_WORK';

	-- Statement Volume
	CACHE_FORMULA_CHARGE_DETAILS(p_BEGIN_DATE,
								p_END_DATE,
								p_PARTICIPANT_ID,
								p_STMT_TYPE,
								CONSTANTS.EXTERNAL_STATE,
								p_COMPONENT_NAME,
								p_SUPPLIER_UNIT,
								g_STMT_VAL_DETAIL_TYPE_STMT);
	-- TDIE Volume for 591 Message
	CACHE_TDIE_DETAILS(p_BEGIN_DATE,
								p_END_DATE,
								p_PARTICIPANT_ID,
								v_TDIE_STMT_TYPE_ID,
								p_COMPONENT_NAME,
								p_SUPPLIER_UNIT,
								g_STMT_VAL_DETAIL_TYPE_591);
	-- TDIE Volume for 595 Message
	CACHE_TDIE_DETAILS(p_BEGIN_DATE,
								p_END_DATE,
								p_PARTICIPANT_ID,
								v_TDIE_STMT_TYPE_ID,
								p_COMPONENT_NAME,
								p_SUPPLIER_UNIT,
								g_STMT_VAL_DETAIL_TYPE_595);

	-- TDIE Volume for 596 Message
	CACHE_FORMULA_CHARGE_DETAILS(p_BEGIN_DATE,
								p_END_DATE,
								p_PARTICIPANT_ID,
								v_TDIE_STMT_TYPE_ID,
								CONSTANTS.INTERNAL_STATE,
								p_COMPONENT_NAME,
								p_SUPPLIER_UNIT,
								g_STMT_VAL_DETAIL_TYPE_596);

	-- TDIE Volume for 598 Message
	CACHE_TDIE_DETAILS(p_BEGIN_DATE,
								p_END_DATE,
								p_PARTICIPANT_ID,
								v_TDIE_STMT_TYPE_ID,
								p_COMPONENT_NAME,
								p_SUPPLIER_UNIT,
								g_STMT_VAL_DETAIL_TYPE_598);
	-- Internal Volume
	CACHE_FORMULA_CHARGE_DETAILS(p_BEGIN_DATE,
								p_END_DATE,
								p_PARTICIPANT_ID,
								p_STMT_TYPE,
								CONSTANTS.INTERNAL_STATE,
								p_COMPONENT_NAME,
								p_SUPPLIER_UNIT,
								g_STMT_VAL_DETAIL_TYPE_INT);
	OPEN p_CURSOR FOR
		SELECT DETAILS.*,
			p_ENABLE_TOLERANCE AS ENABLE_TOLERANCE,
			v_TDIE_PCT_TOLERANCE_DIFF AS TDIE_PCT_TOLERANCE_DIFF,
			v_INTERNAL_PCT_TOLERANCE_DIFF AS INTERNAL_PCT_TOLERANCE_DIFF
		FROM (SELECT MAX(S.ENTITY_ID) AS ENTITY_ID,
				MAX(S.PRODUCT_ID) AS PRODUCT_ID,
				v_COMPONENT_ID AS COMPONENT_ID,
				p_STMT_TYPE AS STATEMENT_TYPE,
				v_STATEMENT_TYPE_NAME AS STATEMENT_TYPE_NAME,
				S.STATEMENT_DATE AS STATEMENT_DATE,
				S.SUPPLIER_UNIT,
				CASE p_INTERVAL
					WHEN DATE_UTIL.c_NAME_30MIN THEN TRIM(SDT.MI30_YYYY_MM_DD)
					WHEN DATE_UTIL.c_NAME_DAY THEN TRIM(SDT.DAY_YYYY_MM_DD)
				END AS DETAIL_DATE_STR,
				SUM(CASE WHEN S.DETAIL_TYPE = g_STMT_VAL_DETAIL_TYPE_STMT THEN S.QUANTITY ELSE NULL END) AS STATEMENT_VOLUME,
				SUM(CASE WHEN S.DETAIL_TYPE = g_STMT_VAL_DETAIL_TYPE_INT THEN S.QUANTITY ELSE NULL END) AS INTERNAL_VOLUME,
				SUM(CASE WHEN S.DETAIL_TYPE = g_STMT_VAL_DETAIL_TYPE_591 THEN S.QUANTITY ELSE NULL END) AS AGG_591_VOLUME,
				SUM(CASE WHEN S.DETAIL_TYPE = g_STMT_VAL_DETAIL_TYPE_595 THEN S.QUANTITY ELSE NULL END) AS AGG_595_VOLUME,
				SUM(CASE WHEN S.DETAIL_TYPE = g_STMT_VAL_DETAIL_TYPE_598 THEN S.QUANTITY ELSE NULL END) AS AGG_598_VOLUME,
				SUM(CASE WHEN S.DETAIL_TYPE = g_STMT_VAL_DETAIL_TYPE_596 THEN S.QUANTITY ELSE NULL END) AS TDIE_VOLUME, -- 596 Message
				MAX(CASE WHEN D.DISPUTE_DATE IS NULL OR UPPER(D.DISPUTE_STATUS) = 'NONE' OR UPPER(D.DISPUTE_STATUS) = 'RESOLVED' OR UPPER(D.DISPUTE_STATUS) = 'CANCELLED'  THEN 0 ELSE 1 END) AS DISPUTE_STATUS
			FROM SYSTEM_DATE_TIME SDT,
				SEM_SETTLEMENT_COMP_DTL_WORK S,
				BILLING_CHARGE_DISPUTE D
			WHERE -- System Date Time
				SDT.TIME_ZONE = MM_SEM_UTIL.g_TZ
				AND SDT.DATA_INTERVAL_TYPE = 1
				AND SDT.DAY_TYPE = '1'
				AND SDT.CUT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
				AND S.DETAIL_DATE(+) = SDT.CUT_DATE
				-- Dispute
				AND D.ENTITY_ID(+) = S.ENTITY_ID
				AND D.PRODUCT_ID(+) = S.PRODUCT_ID
				AND D.COMPONENT_ID(+) = S.COMPONENT_ID
				AND D.STATEMENT_TYPE(+) = S.STATEMENT_TYPE
				AND D.STATEMENT_STATE(+) = CONSTANTS.EXTERNAL_STATE -- State of the Statement
				AND D.STATEMENT_DATE(+) = S.STATEMENT_DATE
				AND D.DISPUTE_DATE(+) = S.DETAIL_DATE
				AND D.ITERATOR1(+) = S.SUPPLIER_UNIT
				AND S.STATEMENT_DATE IS NOT NULL
			GROUP BY v_COMPONENT_ID,
				p_STMT_TYPE,
				v_STATEMENT_TYPE_NAME,
				S.STATEMENT_DATE,
				S.SUPPLIER_UNIT,
				CASE p_INTERVAL
					WHEN DATE_UTIL.c_NAME_30MIN THEN TRIM(SDT.MI30_YYYY_MM_DD)
					WHEN DATE_UTIL.c_NAME_DAY THEN TRIM(SDT.DAY_YYYY_MM_DD)
				END
			) DETAILS
		WHERE -- If Enable Tolerance is set to 1, then display only rows where tolerance diff % > expected tolerance %
			-- Else show all rows. The non-null tolerances are be ignored.
			((p_ENABLE_TOLERANCE = 1 AND NVL(STATEMENT_VOLUME,0) <> 0 AND
				((TDIE_VOLUME IS NOT NULL AND v_TDIE_PCT_TOLERANCE_DIFF IS NOT NULL AND ABS((STATEMENT_VOLUME - NVL(TDIE_VOLUME,0))/STATEMENT_VOLUME)*100 > v_TDIE_PCT_TOLERANCE_DIFF)
				OR (INTERNAL_VOLUME IS NOT NULL AND v_INTERNAL_PCT_TOLERANCE_DIFF IS NOT NULL AND ABS((STATEMENT_VOLUME - NVL(INTERNAL_VOLUME,0))/STATEMENT_VOLUME)*100 > v_INTERNAL_PCT_TOLERANCE_DIFF))
			) OR p_ENABLE_TOLERANCE = 0)
		ORDER BY SUPPLIER_UNIT,
			STATEMENT_TYPE_NAME,
			DETAIL_DATE_STR;

END ENERGY_VOLUME_INTERVAL_DETAILS;
---------------------------------------------------------------------------------
PROCEDURE TDIE_VOLUME_INTERVAL_DETAILS
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INTERVAL IN VARCHAR2, -- '30 Minute' or 'Day'
	p_PARTICIPANT_ID IN NUMBER,
	p_STMT_TYPE IN NUMBER,
	p_COMPONENT_NAME IN VARCHAR2,
	p_SUPPLIER_UNIT IN VARCHAR2, -- Supplier Unit or '<All>'
	p_ENABLE_TOLERANCE IN NUMBER,
	p_INVL_PCT_TOLERANCE_DIFF IN VARCHAR2,
	p_NON_INVL_PCT_TOLERANCE_DIFF IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR,
	p_MESSAGE OUT VARCHAR2
	)
AS
	v_EXT_IDENT_STMT_TYPE EXTERNAL_SYSTEM_IDENTIFIER.EXTERNAL_IDENTIFIER%TYPE;
	v_TDIE_STMT_TYPE_ID STATEMENT_TYPE.STATEMENT_TYPE_ID%TYPE;
	v_COMPONENT_ID COMPONENT.COMPONENT_ID%TYPE := EI.GET_ID_FROM_NAME(p_COMPONENT_NAME, EC.ED_COMPONENT);
	v_CUT_BEGIN_DATE DATE;
	v_CUT_END_DATE DATE;
	v_STATEMENT_TYPE_NAME STATEMENT_TYPE.STATEMENT_TYPE_NAME%TYPE;
	v_INVL_PCT_TOLERANCE_DIFF NUMBER;
	v_NON_INVL_PCT_TOLERANCE_DIFF NUMBER;
BEGIN
	-- Check if the % Difference Tolerance values are valid numbers
    TOLERANCE_FILTER_TO_NUMBER('Interval', p_INVL_PCT_TOLERANCE_DIFF, v_INVL_PCT_TOLERANCE_DIFF, p_MESSAGE);
    IF p_MESSAGE IS NULL THEN
        TOLERANCE_FILTER_TO_NUMBER('Non-interval', p_NON_INVL_PCT_TOLERANCE_DIFF, v_NON_INVL_PCT_TOLERANCE_DIFF, p_MESSAGE);
    END IF;
	IF p_MESSAGE IS NOT NULL THEN
		NULL_CURSOR(p_CURSOR);
		RETURN;
	END IF;

	 IF p_ENABLE_TOLERANCE = 1 THEN
        -- Validate if we have at least one of the % Difference input to run a variance report
        IF v_INVL_PCT_TOLERANCE_DIFF IS NULL AND v_NON_INVL_PCT_TOLERANCE_DIFF IS NULL THEN
            p_MESSAGE := c_MSG_MISSING_TOL_DIFF_TDIE;
            NULL_CURSOR(p_CURSOR);
            RETURN;
        END IF;
	ELSE
        p_MESSAGE := NULL;
	END IF;

	SP.CHECK_SYSTEM_DATE_TIME(MM_SEM_UTIL.g_TZ,p_BEGIN_DATE,p_END_DATE);
	UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, MM_SEM_UTIL.g_TZ, v_CUT_BEGIN_DATE, v_CUT_END_DATE);

	v_STATEMENT_TYPE_NAME := EI.GET_ENTITY_NAME(EC.ED_STATEMENT_TYPE, p_STMT_TYPE);
	-- Get the External Identifier for the Statement
	v_EXT_IDENT_STMT_TYPE := EI.GET_ENTITY_IDENTIFIER_EXTSYS(EC.ED_STATEMENT_TYPE, p_STMT_TYPE, EC.ES_SEM, MM_SEM_UTIL.g_STATEMENT_TYPE_SETTLEMENT);

	-- Get the TDIE Statement Type ID
	v_TDIE_STMT_TYPE_ID := EI.GET_ID_FROM_IDENTIFIER_EXTSYS(v_EXT_IDENT_STMT_TYPE,
							EC.ED_STATEMENT_TYPE,
							EC.ES_TDIE,
							EI.g_DEFAULT_IDENTIFIER_TYPE,
							1);

	-- Truncate the temporary table
	EXECUTE IMMEDIATE 'TRUNCATE TABLE SEM_SETTLEMENT_COMP_DTL_WORK';

	-- TDIE Volume for 595 Message
	CACHE_TDIE_DETAILS(p_BEGIN_DATE,
								p_END_DATE,
								p_PARTICIPANT_ID,
								v_TDIE_STMT_TYPE_ID,
								p_COMPONENT_NAME,
								p_SUPPLIER_UNIT,
								g_STMT_VAL_DETAIL_TYPE_595);
	-- TDIE Volume for 591 Message
	CACHE_TDIE_DETAILS(p_BEGIN_DATE,
								p_END_DATE,
								p_PARTICIPANT_ID,
								v_TDIE_STMT_TYPE_ID,
								p_COMPONENT_NAME,
								p_SUPPLIER_UNIT,
								g_STMT_VAL_DETAIL_TYPE_591);

	-- TDIE Volume for 341 Message
	CACHE_SCHEDULE_DETAILS(p_BEGIN_DATE,
								p_END_DATE,
								p_PARTICIPANT_ID,
								p_STMT_TYPE,
								p_SUPPLIER_UNIT,
								g_STMT_VAL_DETAIL_TYPE_341);

	-- TDIE Volume for 300 Message
	CACHE_SCHEDULE_DETAILS(p_BEGIN_DATE,
								p_END_DATE,
								p_PARTICIPANT_ID,
								p_STMT_TYPE,
								p_SUPPLIER_UNIT,
								g_STMT_VAL_DETAIL_TYPE_300);

    -- TDIE Volume for 342 Message
	CACHE_SCHEDULE_DETAILS(p_BEGIN_DATE,
								p_END_DATE,
								p_PARTICIPANT_ID,
								p_STMT_TYPE,
								p_SUPPLIER_UNIT,
								g_STMT_VAL_DETAIL_TYPE_342);

    -- TDIE Volume for 598 Message
	CACHE_TDIE_DETAILS(p_BEGIN_DATE,
								p_END_DATE,
								p_PARTICIPANT_ID,
								v_TDIE_STMT_TYPE_ID,
								p_COMPONENT_NAME,
								p_SUPPLIER_UNIT,
								g_STMT_VAL_DETAIL_TYPE_598);

	OPEN p_CURSOR FOR
		SELECT DETAILS.*,
			p_ENABLE_TOLERANCE AS ENABLE_TOLERANCE,
			v_INVL_PCT_TOLERANCE_DIFF AS INVL_PCT_TOLERANCE_DIFF,
			v_NON_INVL_PCT_TOLERANCE_DIFF AS NON_INVL_PCT_TOLERANCE_DIFF
		FROM (SELECT S.ENTITY_ID,
				S.PRODUCT_ID,
				v_COMPONENT_ID AS COMPONENT_ID,
				p_STMT_TYPE AS STATEMENT_TYPE,
				v_STATEMENT_TYPE_NAME AS STATEMENT_TYPE_NAME,
				S.SUPPLIER_UNIT,
				CASE p_INTERVAL
					WHEN DATE_UTIL.c_NAME_30MIN THEN TRIM(SDT.MI30_YYYY_MM_DD)
					WHEN DATE_UTIL.c_NAME_DAY THEN TRIM(SDT.DAY_YYYY_MM_DD)
				END AS DETAIL_DATE_STR,
				CASE p_INTERVAL
					WHEN DATE_UTIL.c_NAME_30MIN THEN SDT.CUT_DATE
					ELSE NULL
				END AS CUT_SCHEDULE_DATE,
				SUM(CASE WHEN S.DETAIL_TYPE = g_STMT_VAL_DETAIL_TYPE_595 THEN S.QUANTITY ELSE NULL END) AS TDIE_595_VOLUME,
				SUM(CASE WHEN S.DETAIL_TYPE = g_STMT_VAL_DETAIL_TYPE_591 THEN S.QUANTITY ELSE NULL END) AS TDIE_591_VOLUME,
				SUM(CASE WHEN S.DETAIL_TYPE = g_STMT_VAL_DETAIL_TYPE_341 THEN S.QUANTITY ELSE NULL END) AS TDIE_341_VOLUME,
				SUM(CASE WHEN S.DETAIL_TYPE = g_STMT_VAL_DETAIL_TYPE_300 THEN S.QUANTITY ELSE NULL END) AS TDIE_300_VOLUME,
                SUM(CASE WHEN S.DETAIL_TYPE = g_STMT_VAL_DETAIL_TYPE_342 THEN S.QUANTITY ELSE NULL END) AS TDIE_342_VOLUME,
                SUM(CASE WHEN S.DETAIL_TYPE = g_STMT_VAL_DETAIL_TYPE_598 THEN S.QUANTITY ELSE NULL END) AS TDIE_598_VOLUME,
				MAX(CASE WHEN S.DETAIL_TYPE = g_STMT_VAL_DETAIL_TYPE_595 THEN S.TDIE_ID ELSE NULL END) AS TDIE_ID_595,
				MAX(CASE WHEN S.DETAIL_TYPE = g_STMT_VAL_DETAIL_TYPE_595 THEN S.UNDER_REVIEW ELSE NULL END) AS UNDER_REVIEW_595,
				MAX(CASE WHEN S.DETAIL_TYPE = g_STMT_VAL_DETAIL_TYPE_595 THEN S.JURISDICTION ELSE NULL END) AS JURISDICTION_595,
				MAX(CASE WHEN S.DETAIL_TYPE = g_STMT_VAL_DETAIL_TYPE_591 THEN S.TDIE_ID ELSE NULL END) AS TDIE_ID_591,
				MAX(CASE WHEN S.DETAIL_TYPE = g_STMT_VAL_DETAIL_TYPE_591 THEN S.UNDER_REVIEW ELSE NULL END) AS UNDER_REVIEW_591,
				MAX(CASE WHEN S.DETAIL_TYPE = g_STMT_VAL_DETAIL_TYPE_591 THEN S.JURISDICTION ELSE NULL END) AS JURISDICTION_591
			FROM SEM_SETTLEMENT_COMP_DTL_WORK S,
				STATEMENT_TYPE T,
				SYSTEM_DATE_TIME SDT
			WHERE T.STATEMENT_TYPE_ID = S.STATEMENT_TYPE
				-- System Date Time
				AND SDT.TIME_ZONE = MM_SEM_UTIL.g_TZ
				AND SDT.DATA_INTERVAL_TYPE = 1
				AND SDT.DAY_TYPE = '1'
				AND SDT.CUT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
				AND S.DETAIL_DATE(+) = SDT.CUT_DATE
				AND S.STATEMENT_DATE IS NOT NULL
			GROUP BY S.ENTITY_ID,
				S.PRODUCT_ID,
				v_COMPONENT_ID,
				p_STMT_TYPE,
				v_STATEMENT_TYPE_NAME,
				S.SUPPLIER_UNIT,
				CASE p_INTERVAL
					WHEN DATE_UTIL.c_NAME_30MIN THEN TRIM(SDT.MI30_YYYY_MM_DD)
					WHEN DATE_UTIL.c_NAME_DAY THEN TRIM(SDT.DAY_YYYY_MM_DD)
				END,
				CASE p_INTERVAL
					WHEN DATE_UTIL.c_NAME_30MIN THEN SDT.CUT_DATE
					ELSE NULL
				END
			) DETAILS
		WHERE -- If Enable Tolerance is set to 1, then display only row where tolerance diff % > expected tolerance %
			-- Else show all rows. The non-null tolerances are be ignored.
			(p_ENABLE_TOLERANCE = 1 AND
				((NVL(TDIE_595_VOLUME,0) <> 0 AND TDIE_595_VOLUME IS NOT NULL AND v_INVL_PCT_TOLERANCE_DIFF IS NOT NULL AND ABS((TDIE_595_VOLUME - NVL(TDIE_341_VOLUME,0))/TDIE_595_VOLUME)*100 > v_INVL_PCT_TOLERANCE_DIFF)
				OR (NVL(TDIE_591_VOLUME,0) <> 0 AND TDIE_591_VOLUME IS NOT NULL AND v_NON_INVL_PCT_TOLERANCE_DIFF IS NOT NULL AND ABS((TDIE_591_VOLUME - NVL(TDIE_300_VOLUME,0))/TDIE_591_VOLUME)*100 > v_NON_INVL_PCT_TOLERANCE_DIFF)
                OR (NVL(TDIE_598_VOLUME,0) <> 0 AND TDIE_598_VOLUME IS NOT NULL AND v_INVL_PCT_TOLERANCE_DIFF IS NOT NULL AND ABS((TDIE_598_VOLUME - NVL(TDIE_342_VOLUME,0))/TDIE_598_VOLUME)*100 > v_INVL_PCT_TOLERANCE_DIFF))
			OR p_ENABLE_TOLERANCE = 0)
		ORDER BY SUPPLIER_UNIT,
			STATEMENT_TYPE_NAME,
			DETAIL_DATE_STR;
END TDIE_VOLUME_INTERVAL_DETAILS;
---------------------------------------------------------------------------------
PROCEDURE PUT_TDIE_UNDER_REVIEW
	(
	p_TDIE_ID_595 IN NUMBER,
	p_UNDER_REVIEW_595 IN NUMBER,
	p_JURISDICTION_595 IN VARCHAR2,
	p_TDIE_ID_591 IN NUMBER,
	p_UNDER_REVIEW_591 IN NUMBER,
	p_JURISDICTION_591 IN VARCHAR2,
	p_CUT_SCHEDULE_DATE IN DATE
	) AS
BEGIN
	IF p_TDIE_ID_595 IS NOT NULL THEN
		IF p_JURISDICTION_595 = 'ROI' THEN
			UPDATE TDIE_AGG_CONSUMPTION TAC
			SET TAC.UNDER_REVIEW = p_UNDER_REVIEW_595
			WHERE TAC.TDIE_ID = p_TDIE_ID_595
				AND TAC.INTERVAL_PERIOD_TIMESTAMP
					BETWEEN DATE_UTIL.GET_INTERVAL_BEGIN_DATE(p_CUT_SCHEDULE_DATE, DATE_UTIL.c_ABBR_30MIN) AND p_CUT_SCHEDULE_DATE;
		ELSIF p_JURISDICTION_595 = 'NIE' THEN
			MM_TDIE_UI.PUT_NIETD_UNDER_REVIEW(p_TDIE_ID_595, p_CUT_SCHEDULE_DATE, p_UNDER_REVIEW_595);
		END IF;
	END IF;

	IF p_TDIE_ID_591 IS NOT NULL THEN
		IF p_JURISDICTION_591 = 'ROI' THEN
			UPDATE TDIE_AGG_CONSUMPTION TAC
			SET TAC.UNDER_REVIEW = p_UNDER_REVIEW_591
			WHERE TAC.TDIE_ID = p_TDIE_ID_591
				AND TAC.INTERVAL_PERIOD_TIMESTAMP
					BETWEEN DATE_UTIL.GET_INTERVAL_BEGIN_DATE(p_CUT_SCHEDULE_DATE, DATE_UTIL.c_ABBR_30MIN) AND p_CUT_SCHEDULE_DATE;
		ELSIF p_JURISDICTION_591 = 'NIE' THEN
			MM_TDIE_UI.PUT_NIETD_UNDER_REVIEW(p_TDIE_ID_591, p_CUT_SCHEDULE_DATE, p_UNDER_REVIEW_591);
		END IF;

	END IF;
END PUT_TDIE_UNDER_REVIEW;
---------------------------------------------------------------------------------
PROCEDURE NON_PART_GEN_VOLUME_DETAILS
	(
    p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INTERVAL IN VARCHAR2, -- '30 Minute' or 'Day'
	p_PARTICIPANT_ID IN NUMBER,
	p_STMT_TYPE IN NUMBER,
	p_COMPONENT_NAME IN VARCHAR2,
	p_SUPPLIER_UNIT IN VARCHAR2, -- Supplier Unit or '<All>'
    p_CURSOR OUT GA.REFCURSOR
	) AS
    v_MARKET_TYPE SEM_SETTLEMENT_CALENDAR.MARKET%TYPE;
    v_EXT_IDENT_STMT_TYPE EXTERNAL_SYSTEM_IDENTIFIER.EXTERNAL_IDENTIFIER%TYPE;
	v_TDIE_STMT_TYPE_ID STATEMENT_TYPE.STATEMENT_TYPE_ID%TYPE;
	v_CUT_BEGIN_DATE DATE;
	v_CUT_END_DATE DATE;
BEGIN
	SP.CHECK_SYSTEM_DATE_TIME(MM_SEM_UTIL.g_TZ,p_BEGIN_DATE,p_END_DATE);
	UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, MM_SEM_UTIL.g_TZ, v_CUT_BEGIN_DATE, v_CUT_END_DATE);

	-- Get the External Identifier for the Statement
	v_EXT_IDENT_STMT_TYPE := EI.GET_ENTITY_IDENTIFIER_EXTSYS(EC.ED_STATEMENT_TYPE, p_STMT_TYPE, EC.ES_SEM, MM_SEM_UTIL.g_STATEMENT_TYPE_SETTLEMENT);

	-- Get the TDIE Statement Type ID
	v_TDIE_STMT_TYPE_ID := EI.GET_ID_FROM_IDENTIFIER_EXTSYS(v_EXT_IDENT_STMT_TYPE,
							EC.ED_STATEMENT_TYPE,
							EC.ES_TDIE,
							EI.g_DEFAULT_IDENTIFIER_TYPE,
							1);

	-- Get the Market Type from the Component
	SELECT COMPONENT_CATEGORY
	INTO v_MARKET_TYPE
	FROM COMPONENT
	WHERE COMPONENT_NAME = p_COMPONENT_NAME;

    OPEN p_CURSOR FOR
        SELECT CASE p_INTERVAL
                        WHEN DATE_UTIL.c_NAME_30MIN THEN TRIM(SDT.MI30_YYYY_MM_DD)
                        WHEN DATE_UTIL.c_NAME_DAY THEN TRIM(SDT.DAY_YYYY_MM_DD)
            END AS DETAIL_DATE_STR,
            EARN_ID,
            SUM(CASE WHEN S.DETAIL_TYPE = g_STMT_VAL_DETAIL_TYPE_598 THEN S.QUANTITY ELSE NULL END) AS GEN_VOLUME_598,
            SUM(CASE WHEN S.DETAIL_TYPE = g_STMT_VAL_DETAIL_TYPE_342 THEN S.QUANTITY ELSE NULL END) AS GEN_VOLUME_342
        FROM
            (--ROI598
            SELECT DATE_UTIL.HED_TRUNC(TAG.INTERVAL_PERIOD_TIMESTAMP, DATE_UTIL.c_ABBR_30MIN) AS DETAIL_DATE,
                TGU.GENERATOR_UNIT AS EARN_ID,
                TAG.LA_METERED_GENERATION/1000 AS QUANTITY,
                TM.MESSAGE_DATE,
                g_STMT_VAL_DETAIL_TYPE_598 AS DETAIL_TYPE
            FROM (SELECT DISTINCT GENERATOR_UNIT FROM TDIE_GEN_UNITS
                  WHERE PSE_ID = p_PARTICIPANT_ID
                    AND (SUPPLIER_UNIT = p_SUPPLIER_UNIT OR CONSTANTS.ALL_STRING = p_SUPPLIER_UNIT)
                    AND BEGIN_DATE <= p_END_DATE
                    AND NVL(END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE) TGU,
                TDIE_MESSAGE TM,
                TDIE_AGG_GENERATION TAG
            WHERE -- TDIE Message
                TM.MESSAGE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
                AND TM.MESSAGE_TYPE_CODE = g_STMT_VAL_DETAIL_TYPE_598
                AND TM.LOCATION_ID = TGU.GENERATOR_UNIT
                AND TM.SETTLEMENT_RUN_INDICATOR = DETERMINE_SLMT_RUN_INDICATOR(v_TDIE_STMT_TYPE_ID, TM.MESSAGE_DATE, v_MARKET_TYPE, MM_TDIE_UTIL.c_TDIE_JURISDICTION_ROI)
                -- TDIE Agg Generation
                AND TAG.TDIE_ID = TM.TDIE_ID
            UNION ALL
            --N598
            SELECT DATE_UTIL.HED_TRUNC(TND.SCHEDULE_DATE, DATE_UTIL.c_ABBR_30MIN) AS DETAIL_DATE,
                TGU.GENERATOR_UNIT AS EARN_ID,
                TND.ENERGY/1000 AS QUANTITY,
                TM.MESSAGE_DATE,
                g_STMT_VAL_DETAIL_TYPE_598 AS DETAIL_TYPE
            FROM (SELECT DISTINCT GENERATOR_UNIT FROM TDIE_GEN_UNITS
                  WHERE PSE_ID = p_PARTICIPANT_ID
                    AND (SUPPLIER_UNIT = p_SUPPLIER_UNIT OR CONSTANTS.ALL_STRING = p_SUPPLIER_UNIT)
                    AND BEGIN_DATE <= p_END_DATE
                    AND NVL(END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE) TGU,
                TDIE_MESSAGE TM,
                TDIE_NIETD TN,
                TDIE_NIETD_DETAIL TND
            WHERE -- TDIE Message
                TM.MESSAGE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
                AND TM.MESSAGE_TYPE_CODE = 'N' || g_STMT_VAL_DETAIL_TYPE_598
                AND TM.LOCATION_ID = TGU.GENERATOR_UNIT
                AND TM.SETTLEMENT_RUN_INDICATOR = DETERMINE_SLMT_RUN_INDICATOR(v_TDIE_STMT_TYPE_ID, TM.MESSAGE_DATE, v_MARKET_TYPE, MM_TDIE_UTIL.c_TDIE_JURISDICTION_NI)
                -- TDIE NIETD and Details
                AND TN.TDIE_ID = TM.TDIE_ID
                AND TND.TDIE_DETAIL_ID = TN.TDIE_DETAIL_ID
                AND TND.ENERGY_TYPE = 'P'
            UNION ALL
            --342
            SELECT DATE_UTIL.HED_TRUNC(S.SCHEDULE_DATE, DATE_UTIL.c_ABBR_30MIN) AS DETAIL_DATE,
                TGU.GENERATOR_UNIT,
                -1 * S.AMOUNT,
                TRUNC(FROM_CUT(S.SCHEDULE_DATE, MM_SEM_UTIL.g_TZ)-1/86400) AS STATEMENT_DATE,
                g_STMT_VAL_DETAIL_TYPE_342 AS DETAIL_TYPE
            FROM (SELECT DISTINCT GENERATOR_UNIT, GEN_SP_ID FROM TDIE_GEN_UNITS
                  WHERE PSE_ID = p_PARTICIPANT_ID
                    AND (SUPPLIER_UNIT = p_SUPPLIER_UNIT OR CONSTANTS.ALL_STRING = p_SUPPLIER_UNIT)
                    AND BEGIN_DATE <= p_END_DATE
                    AND NVL(END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE) TGU,
                INTERCHANGE_TRANSACTION IT,
                IT_COMMODITY C,
                SCHEDULE_COORDINATOR SC,
                SCHEDULE_GROUP SG,
                IT_SCHEDULE S
            WHERE -- IT Transaction
                IT.BEGIN_DATE <= p_END_DATE
                AND NVL(IT.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
                AND C.COMMODITY_ID(+) = IT.COMMODITY_ID
                AND SC.SC_ID(+) = IT.SC_ID
                AND SG.SCHEDULE_GROUP_ID(+) = IT.SCHEDULE_GROUP_ID
                AND SC.SC_ALIAS IN (MM_TDIE_UTIL.c_ESBN_ALIAS,MM_TDIE_UTIL.c_NIE_ALIAS)
                AND IT.POD_ID = TGU.GEN_SP_ID
                AND IT.TRANSACTION_TYPE = g_TXN_TYPE_LOAD
                AND C.COMMODITY_ALIAS = g_COMMODITY_ALIAS_RETAIL_LOAD
                AND IT.TRANSACTION_INTERVAL IN (DATE_UTIL.c_NAME_15MIN, DATE_UTIL.c_NAME_30MIN)
                AND SG.METER_TYPE = g_SG_METER_TYPE_INTERVAL
                -- Transaction Schedule
                AND S.TRANSACTION_ID = IT.TRANSACTION_ID
                AND S.SCHEDULE_TYPE = p_STMT_TYPE
                AND S.SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE
                AND S.SCHEDULE_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
             ) S,
             SYSTEM_DATE_TIME SDT
        WHERE SDT.TIME_ZONE = MM_SEM_UTIL.g_TZ
            AND SDT.DATA_INTERVAL_TYPE = 1
            AND SDT.DAY_TYPE = '1'
            AND SDT.CUT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
            AND S.DETAIL_DATE(+) = SDT.CUT_DATE
            AND S.MESSAGE_DATE IS NOT NULL
        GROUP BY
            CASE p_INTERVAL
                        WHEN DATE_UTIL.c_NAME_30MIN THEN TRIM(SDT.MI30_YYYY_MM_DD)
                        WHEN DATE_UTIL.c_NAME_DAY THEN TRIM(SDT.DAY_YYYY_MM_DD)
            END,
            EARN_ID
        ORDER BY DETAIL_DATE_STR,
            EARN_ID;

END NON_PART_GEN_VOLUME_DETAILS;
---------------------------------------------------------------------------------
-- For the report validating the NDLFESU with MGR Determinants
-- Will be used by the UI and perform various functions
PROCEDURE NDLFESU_VALIDATION_DETAILS
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INTERVAL IN VARCHAR2, -- '30 Minute','Week','Day','Month'
	p_STATEMENT_TYPE_ID IN NUMBER,
    p_TIME_ZONE IN VARCHAR2,
    p_CURSOR OUT GA.REFCURSOR
  ) AS
  v_MIN_INTRVL_NUM NUMBER;
  v_NEW_BEGIN_DATE DATE;
  v_NEW_END_DATE DATE;
  v_CUT_BEGIN_DATE DATE;
  v_CUT_END_DATE DATE;
  c_NI_DETERMINANTS CONSTANT VARCHAR2(32) := 'NI Determinants';
  c_ALL_DETERMINANTS CONSTANT VARCHAR2(32) := 'All Island Determinants';
  c_NI_GEN_BREAKOUT CONSTANT VARCHAR2(32) := 'NI Metered Gen Breakout';
  c_ALL_GEN_BREAKOUT CONSTANT VARCHAR2(32) := 'All Island Metered Gen Breakout';
  c_NI_ESU_PT_IDENT CONSTANT VARCHAR2(32) := 'PT_500036';  -- JC: participant responsible for the NI error supplier unit;
                                                           -- needed to look up NDLFESU from energy PIR (not MO or CA)
BEGIN

  -- Get the number corresponding to the minimum interval, in this
  -- specific report 30 minutes is the minimum interval
  v_MIN_INTRVL_NUM := GET_INTERVAL_NUMBER('MI30');
  -- Manipulate the begin and end dates based on the chosen interval for intervals
  -- 'week' and 'month'.
  IF p_INTERVAL NOT IN (CONSTANTS.INTERVAL_30_MINUTE, CONSTANTS.INTERVAL_DAY) THEN
        v_NEW_BEGIN_DATE := DATE_UTIL.BEGIN_DATE_FOR_INTERVAL(p_BEGIN_DATE,p_INTERVAL);
        v_NEW_END_DATE := DATE_UTIL.END_DATE_FOR_INTERVAL(DATE_UTIL.BEGIN_DATE_FOR_INTERVAL(p_END_DATE,p_INTERVAL),p_INTERVAL);
  ELSE
        v_NEW_BEGIN_DATE := p_BEGIN_DATE;
        v_NEW_END_DATE := p_END_DATE;
  END IF;
  -- Get the cut dates based on the new manipulated dates
  UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL,v_NEW_BEGIN_DATE,v_NEW_END_DATE,p_TIME_ZONE,v_CUT_BEGIN_DATE,v_CUT_END_DATE);
  -- Check if the System Date Time table is populated / throw exception
  SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, p_BEGIN_DATE, p_END_DATE);
  -- Truncate the temporary helper tables used for this procedure
  EXECUTE IMMEDIATE 'TRUNCATE TABLE SEM_NDLFESU_VALIDATION_TEMP';
  EXECUTE IMMEDIATE 'TRUNCATE TABLE SEM_NDLFESU_VALID_TEMP_DATE';

  -- Populating the first helper table with GP Settlement data
  INSERT
  INTO SEM_NDLFESU_VALIDATION_TEMP( VALIDATION_DATE,
                                    DETERMINANT_TYPE,
                                    MG,
                                    MGIU,
                                    MGEU,
                                    NIJ,
                                    JMGLF,
                                    JMDLF )
       SELECT
         SGPS.CHARGE_DATE,
         c_NI_DETERMINANTS AS DETERMINANT_TYPE,
         SUM(CASE WHEN SGPS.VARIABLE_TYPE = 'MG' THEN SGPS.VALUE ELSE NULL END) AS MG,
         SUM(CASE WHEN SGPS.VARIABLE_TYPE = 'MGIU' OR  SGPS.VARIABLE_TYPE = 'MGIUG' THEN NVL(SGPS.VALUE, 0) ELSE 0 END) AS MGIU,
         SUM(CASE WHEN SGPS.VARIABLE_TYPE = 'MGEU' THEN NVL(SGPS.VALUE, 0) ELSE 0 END) AS MGEU,
         SUM(CASE WHEN SGPS.VARIABLE_TYPE = 'NIJ' THEN SGPS.VALUE ELSE NULL END) AS NIJ,
         SUM(CASE WHEN SGPS.VARIABLE_TYPE = 'JMGLF' THEN SGPS.VALUE ELSE NULL END) AS JMGLF,
         SUM(CASE WHEN SGPS.VARIABLE_TYPE = 'JMDLF' THEN SGPS.VALUE ELSE NULL END) AS JMDLF
       FROM SEM_GP_SETTLEMENT SGPS
       WHERE SGPS.STATEMENT_TYPE = p_STATEMENT_TYPE_ID
             AND SGPS.CHARGE_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
             AND SGPS.VARIABLE_TYPE IN ('MG','MGIU','MGIUG','MGEU','NIJ','JMGLF','JMDLF')
             AND SGPS.JURISDICTION = MM_SEM_UTIL.c_SEM_JURIDICTION_NI
             AND (UPPER(SUBSTR(SGPS.RESOURCE_NAME,1,5)) = 'GU_50' OR RESOURCE_NAME='?')
       GROUP BY SGPS.CHARGE_DATE
     UNION ALL
       SELECT
         SGPS.CHARGE_DATE,
         c_ALL_DETERMINANTS AS DETERMINANT_TYPE,
         SUM(CASE WHEN SGPS.VARIABLE_TYPE = 'MG' THEN SGPS.VALUE ELSE NULL END) AS MG,
         SUM(CASE WHEN SGPS.VARIABLE_TYPE = 'MGIU' OR SGPS.VARIABLE_TYPE = 'MGIUG' THEN NVL(SGPS.VALUE, 0) ELSE 0 END) AS MGIU,
         SUM(CASE WHEN SGPS.VARIABLE_TYPE = 'MGEU' THEN NVL(SGPS.VALUE, 0) ELSE 0 END) AS MGEU,
         SUM(CASE WHEN SGPS.VARIABLE_TYPE = 'NIJ' THEN SGPS.VALUE ELSE NULL END) AS NIJ,
         SUM(CASE WHEN SGPS.VARIABLE_TYPE = 'JMGLF' THEN SGPS.VALUE ELSE NULL END) AS JMGLF,
         SUM(CASE WHEN SGPS.VARIABLE_TYPE = 'JMDLF' THEN SGPS.VALUE ELSE NULL END) AS JMDLF
       FROM SEM_GP_SETTLEMENT SGPS
       WHERE SGPS.STATEMENT_TYPE = p_STATEMENT_TYPE_ID
             AND SGPS.CHARGE_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
             AND SGPS.VARIABLE_TYPE IN ('MG','MGIU','MGIUG','MGEU','NIJ','JMGLF','JMDLF')
             AND (UPPER(SUBSTR(SGPS.RESOURCE_NAME,1,5)) IN ('GU_40','GU_50') OR RESOURCE_NAME='?')
       GROUP BY SGPS.CHARGE_DATE;

  -- Insert data into the second temp table using the first and SEM_MP_INFO
  INSERT
  INTO SEM_NDLFESU_VALID_TEMP_DATE(VALIDATION_DATE,
                                   DATA_TYPE,
                                   NDLFESU_PIR,
                                   NDLFESU_CALC,
                                   MG,
                                   MGIU,
                                   MGEU,
                                   NIJ,
                                   JMGLF,
                                   JMDLF)
            SELECT VALIDATION_DATE AS VD,
                   c_NI_DETERMINANTS AS DATA_TYPE,
                   NULL AS NDLFESU_PIR,
                   NULL AS NDLFESU_CALC,
                   (MG+MGIU+MGEU) AS MG,
                   NULL AS MGIU,
                   NULL AS MGEU,
                   NIJ,
                   JMGLF,
                   JMDLF
            FROM  SEM_NDLFESU_VALIDATION_TEMP NI
            WHERE NI.DETERMINANT_TYPE = c_NI_DETERMINANTS
        UNION ALL
            SELECT  VALIDATION_DATE AS VD,
                    c_ALL_DETERMINANTS AS DATA_TYPE,
                    NULL AS NDLFESU_PIR,
                    NULL AS NDLFESU_CALC,
                    (MG+MGIU+MGEU) AS MG,
                    NULL AS MGIU,
                    NULL AS MGEU,
                    NULL AS NIJ,
                    JMGLF,
                    JMDLF
            FROM SEM_NDLFESU_VALIDATION_TEMP NI
            WHERE NI.DETERMINANT_TYPE = c_ALL_DETERMINANTS
        UNION ALL
            SELECT  VALIDATION_DATE AS VD,
                    c_NI_GEN_BREAKOUT AS DATA_TYPE,
                    NULL AS NDLFESU_PIR,
                    NULL AS NDLFESU_CALC,
                    MG,
                    MGIU,
                    MGEU,
                    NULL AS NIJ,
                    NULL AS JMGLF,
                    NULL AS JMDLF
            FROM SEM_NDLFESU_VALIDATION_TEMP NI
            WHERE NI.DETERMINANT_TYPE = c_NI_DETERMINANTS
        UNION ALL
            SELECT  VALIDATION_DATE AS VD,
                    c_ALL_GEN_BREAKOUT AS DATA_TYPE,
                    NULL AS NDLFESU_PIR,
                    NULL AS NDLFESU_CALC,
                    MG,
                    MGIU,
                    MGEU,
                    NULL AS NIJ,
                    NULL AS JMGLF,
                    NULL AS JMDLF
            FROM SEM_NDLFESU_VALIDATION_TEMP NI
            WHERE NI.DETERMINANT_TYPE = c_ALL_DETERMINANTS;

  -- Merge PIR with the second temp table where the dates match. Done so that
  -- we can anchor the NDLFESU_PIR and NDLFESU_CALC columns
  MERGE INTO SEM_NDLFESU_VALID_TEMP_DATE T
  USING (SELECT SMPI.CHARGE_DATE AS VALIDATION_DATE,
                ROUND(SUM(SMPI.VALUE),8) AS NDLFESU_PIR
         FROM SEM_MP_INFO SMPI
         WHERE SMPI.STATEMENT_ID IN (SELECT S.STATEMENT_ID
		 							   FROM SEM_MP_STATEMENT S,
									        SEM_SETTLEMENT_ENTITY E
		 							  WHERE S.STATEMENT_TYPE = p_STATEMENT_TYPE_ID
									    AND S.STATEMENT_DATE BETWEEN v_NEW_BEGIN_DATE AND v_NEW_END_DATE
									    AND E.PARTICIPANT_PSE_ID = EI.GET_ID_FROM_IDENTIFIER_EXTSYS(c_NI_ESU_PT_IDENT, EC.ED_PSE, EC.ES_SEM)
										AND E.MARKET_NAME='EN'
										AND S.ENTITY_ID = E.SETTLEMENT_PSE_ID)
           AND SMPI.CHARGE_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
           AND SMPI.VARIABLE_TYPE = 'NDLFESU'
         GROUP BY SMPI.CHARGE_DATE) S
  ON (S.VALIDATION_DATE = T.VALIDATION_DATE)
  WHEN MATCHED THEN
    UPDATE SET T.NDLFESU_PIR = S.NDLFESU_PIR
  WHEN NOT MATCHED THEN
    INSERT (T.VALIDATION_DATE, T.DATA_TYPE, T.NDLFESU_PIR)
    VALUES (S.VALIDATION_DATE, c_NI_DETERMINANTS, S.NDLFESU_PIR);

  -- Merge Calc into the second temp table where the dates match
  MERGE INTO SEM_NDLFESU_VALID_TEMP_DATE T
  USING (SELECT  NI.VALIDATION_DATE AS VALIDATION_DATE,
                 -- NDLFESU Calculation 'Simplified' Formula
                 (SUM(ALL_ISLAND.MG+ALL_ISLAND.MGIU+ALL_ISLAND.MGEU)-SUM(ALL_ISLAND.JMGLF))
                 *(SUM(NI.MG+NI.MGIU+NI.MGEU)+SUM(NI.NIJ))
                 /SUM(ALL_ISLAND.MG+ALL_ISLAND.MGIU+ALL_ISLAND.MGEU)
               /*  -(SUM(NI.MG+NI.MGIU+NI.MGEU)+SUM(NI.JMDLF)+SUM(NI.NIJ)) AS NDLFESU_CALC */ -- MCR 9/19 BZ.28632
                -(SUM(NI.MG+NI.MGIU+NI.MGEU) - ABS(SUM(NI.JMDLF)) + SUM(NI.NIJ)) AS NDLFESU_CALC    -- MCR 9/19 BZ.28632
         FROM (SELECT *
               FROM SEM_NDLFESU_VALIDATION_TEMP SN
               WHERE SN.DETERMINANT_TYPE = c_NI_DETERMINANTS) NI,
              (SELECT * FROM SEM_NDLFESU_VALIDATION_TEMP SA
               WHERE SA.DETERMINANT_TYPE = c_ALL_DETERMINANTS) ALL_ISLAND
         WHERE NI.VALIDATION_DATE = ALL_ISLAND.VALIDATION_DATE
         GROUP BY NI.VALIDATION_DATE) S
  ON (S.VALIDATION_DATE = T.VALIDATION_DATE)
  WHEN MATCHED THEN
    UPDATE SET T.NDLFESU_CALC = S.NDLFESU_CALC
  WHEN NOT MATCHED THEN
    INSERT (T.VALIDATION_DATE, T.DATA_TYPE, T.NDLFESU_CALC)
    VALUES (S.VALIDATION_DATE, c_NI_DETERMINANTS, S.NDLFESU_CALC);

  COMMIT;

  -- Roll up the data using system date time depending on the selected interval
  -- This query selects from the second helper table. The minimum interval that the
  -- roll up is based on is 30 minutes in this report.
  OPEN p_CURSOR FOR
        SELECT SUBSTR(X.DT,1,10) AS DT,
               SUBSTR(X.DT,11) AS DT_TIME,
               X.DATA_TYPE,
               ROUND(SUM(X.NDLFESU_PIR),8) AS NDLFESU_PIR,
               ROUND(SUM(X.NDLFESU_CALC),8) AS NDLFESU_CALC,
               CASE X.DATA_TYPE -- Extra column for ordering the DATA_TYPE in the report
                  WHEN c_NI_DETERMINANTS THEN 1
                  WHEN c_ALL_DETERMINANTS THEN 2
                  WHEN c_NI_GEN_BREAKOUT THEN 3
                  WHEN c_ALL_GEN_BREAKOUT THEN 4 END AS BREAK_ORDER,
               ROUND(SUM(X.MG),8) AS MG,
               ROUND(SUM(X.MGIU),8) AS MGIU,
               ROUND(SUM(X.MGEU),8) AS MGEU,
               ROUND(SUM(X.NIJ),8) AS NIJ,
               ROUND(SUM(X.JMGLF),8) AS JMGLF,
               ROUND(SUM(X.JMDLF),8) AS JMDLF
        FROM   (SELECT TRIM(CASE p_INTERVAL
                            WHEN CONSTANTS.INTERVAL_30_MINUTE THEN SDT.MI30_YYYY_MM_DD
                            WHEN CONSTANTS.INTERVAL_DAY THEN SDT.DAY_YYYY_MM_DD
                            WHEN CONSTANTS.INTERVAL_WEEK THEN SDT.WEEK_YYYY_MM_DD
                            WHEN CONSTANTS.INTERVAL_MONTH THEN SDT.MONTH_YYYY_MM_DD END) AS DT,
                       NVL(A.DATA_TYPE, c_ALL_DETERMINANTS) AS DATA_TYPE,
                       A.NDLFESU_PIR,
                       A.NDLFESU_CALC,
                       A.MG,
                       A.MGIU,
                       A.MGEU,
                       A.NIJ,
                       A.JMGLF,
                       A.JMDLF
                       FROM SEM_NDLFESU_VALID_TEMP_DATE A, SYSTEM_DATE_TIME SDT
                       WHERE
                           A.VALIDATION_DATE (+) = SDT.CUT_DATE
                           AND SDT.DAY_TYPE = GA.STANDARD
                           AND SDT.DATA_INTERVAL_TYPE = CONSTANTS.ELECTRIC_MODEL
                           AND SDT.CUT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
                           AND SDT.TIME_ZONE = p_TIME_ZONE
                           -- Added minimum interval requirement join constraint
                           AND SDT.MINIMUM_INTERVAL_NUMBER >= v_MIN_INTRVL_NUM
                           ) X
         GROUP BY  X.DATA_TYPE, X.DT
         ORDER BY DT, DT_TIME, DATA_TYPE, NDLFESU_PIR;
END NDLFESU_VALIDATION_DETAILS;
---------------------------------------------------------------------------------
END SEM_SETTLEMENT_COMP;
/
