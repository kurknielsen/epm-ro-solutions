CREATE OR REPLACE PACKAGE BODY MM_SEM_CREDIT_SHADOW IS

	g_STMT_INITIAL NUMBER(9);
	g_STMT_INDIC NUMBER(9);
	g_STMT_M4 NUMBER(9);
	g_STMT_M13 NUMBER(9);
	g_TRACE_ON BOOLEAN;

----------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
    RETURN '$Revision: 1.27 $';
END WHAT_VERSION;
----------------------------------------------------------------------------------------

FUNCTION ADD_DAYS
	(
	p_DATE IN DATE,
	p_NUMBER_OF_DAYS IN BINARY_INTEGER,
	p_WD_OR_CD IN VARCHAR2
	) RETURN DATE IS

v_DATE DATE;
v_WDS_ADDED BINARY_INTEGER := 0;
BEGIN
	IF p_DATE IS NULL THEN
		--RUNAWAY LOOP!
		RETURN NULL;
	END IF;

	IF p_WD_OR_CD = 'WD' THEN
		v_DATE := p_DATE;
		WHILE v_WDS_ADDED < ABS(p_NUMBER_OF_DAYS) LOOP
			v_DATE := v_DATE + CASE WHEN p_NUMBER_OF_DAYS < 0 THEN -1 ELSE 1 END;

			--If this is not a weekend or holiday, we have added a Working Day.
			IF (NOT TO_CHAR(v_DATE,'Dy') IN (DATE_CONST.k_SAT, DATE_CONST.k_SUN)) AND (NOT IS_HOLIDAY(v_DATE)) THEN
				v_WDS_ADDED := v_WDS_ADDED + 1;
			END IF;
		END LOOP;
	ELSIF p_WD_OR_CD = 'CD' THEN
		v_DATE := p_DATE + p_NUMBER_OF_DAYS;
	END IF;

	RETURN v_DATE;
END;
-----------------------------------------------------------------------------------------------------------------
PROCEDURE GET_EUR_TO_GBP_EXCH_PRICE_ID
	(
	p_IS_CAPACITY_RATE BOOLEAN DEFAULT FALSE,
	p_MARKET_PRICE_ID OUT NUMBER,
	p_PRICE_DATE_TRUNC_TO OUT VARCHAR2
	) AS
BEGIN
	IF p_IS_CAPACITY_RATE THEN
		p_MARKET_PRICE_ID := MM_SEM_UTIL.GET_MARKET_PRICE_ID('Annual Capacity Exchange Rate: Euro to Pound', 'Commodity Price', '30 Minute', FALSE);
		p_PRICE_DATE_TRUNC_TO := 'MM';
	ELSE
		p_MARKET_PRICE_ID := MM_SEM_UTIL.GET_MARKET_PRICE_ID('Trading Day Exchange Rate: Euro to Pound', 'Commodity Price', '30 Minute', FALSE);
		p_PRICE_DATE_TRUNC_TO := 'DD';
	END IF;
END GET_EUR_TO_GBP_EXCH_PRICE_ID;
-----------------------------------------------------------------------------------------------------------------
FUNCTION GET_EUR_TO_GBP_EXCH_RATE
	(
	p_CREDIT_MARKET IN VARCHAR2,
	p_ASSESSMENT_DATE IN DATE
	) RETURN NUMBER IS
	v_RTN NUMBER;
	v_MARKET_PRICE_ID NUMBER;
	v_PRICE_DATE_TRUNC_TO VARCHAR2(16);
BEGIN
	GET_EUR_TO_GBP_EXCH_PRICE_ID(p_CREDIT_MARKET = c_MARKET_CA, v_MARKET_PRICE_ID, v_PRICE_DATE_TRUNC_TO);

	SELECT PRICE
	INTO v_RTN
	FROM MARKET_PRICE_VALUE
	WHERE MARKET_PRICE_ID = v_MARKET_PRICE_ID
		AND PRICE_CODE = 'A'
		AND PRICE_DATE = TRUNC(p_ASSESSMENT_DATE, v_PRICE_DATE_TRUNC_TO);
	RETURN v_RTN;
END GET_EUR_TO_GBP_EXCH_RATE;
-----------------------------------------------------------------------------------------------------------------
PROCEDURE GET_GBP_TO_EUR_EXCH_PRICE_ID
	(
	p_IS_CAPACITY_RATE BOOLEAN DEFAULT FALSE,
	p_MARKET_PRICE_ID OUT NUMBER,
	p_PRICE_DATE_TRUNC_TO OUT VARCHAR2
	) AS
BEGIN
	IF p_IS_CAPACITY_RATE THEN
		p_MARKET_PRICE_ID := MM_SEM_UTIL.GET_MARKET_PRICE_ID('Annual Capacity Exchange Rate: Pound to Euro', 'Commodity Price', '30 Minute', FALSE);
		p_PRICE_DATE_TRUNC_TO := 'MM';
	ELSE
		p_MARKET_PRICE_ID := MM_SEM_UTIL.GET_MARKET_PRICE_ID('Trading Day Exchange Rate: Pound to Euro', 'Commodity Price', '30 Minute', FALSE);
		p_PRICE_DATE_TRUNC_TO := 'DD';
	END IF;
END GET_GBP_TO_EUR_EXCH_PRICE_ID;
-----------------------------------------------------------------------------------------------------------------
FUNCTION GET_GBP_TO_EUR_EXCH_RATE
	(
	p_CREDIT_MARKET IN VARCHAR2,
	p_ASSESSMENT_DATE IN DATE
	) RETURN NUMBER IS
	v_RTN NUMBER;
	v_MARKET_PRICE_ID NUMBER;
	v_PRICE_DATE_TRUNC_TO VARCHAR2(16);
BEGIN
	GET_GBP_TO_EUR_EXCH_PRICE_ID(p_CREDIT_MARKET = c_MARKET_CA, v_MARKET_PRICE_ID, v_PRICE_DATE_TRUNC_TO);

	SELECT PRICE
	INTO v_RTN
	FROM MARKET_PRICE_VALUE
	WHERE MARKET_PRICE_ID = v_MARKET_PRICE_ID
		AND PRICE_CODE = 'A'
		AND PRICE_DATE = TRUNC(p_ASSESSMENT_DATE, v_PRICE_DATE_TRUNC_TO);
	RETURN v_RTN;
END GET_GBP_TO_EUR_EXCH_RATE;
-----------------------------------------------------------------------------------------------------------------
FUNCTION GET_BILLING_ENTITY_ID
	(
	p_PARTICIPANT_PSE_ID IN NUMBER,
	p_MARKET_NAME IN VARCHAR2
	) RETURN NUMBER IS
	v_RTN NUMBER(9);
BEGIN

	SELECT SETTLEMENT_PSE_ID INTO v_RTN
	FROM SEM_SETTLEMENT_ENTITY
	WHERE PARTICIPANT_PSE_ID = p_PARTICIPANT_PSE_ID
		AND MARKET_NAME = p_MARKET_NAME;

	RETURN v_RTN;
END GET_BILLING_ENTITY_ID;
-----------------------------------------------------------------------------------------------------------------
-- Look up the participant pse default ext id (e.g., PT_500031)
-- from the settlement pse id (e.g., id for SEM:PT_500031:EN)
FUNCTION GET_PARTICIPANT_PSE_EXT_IDENT
    (
	p_SETTLEMENT_PSE_ID IN NUMBER
	) RETURN EXTERNAL_SYSTEM_IDENTIFIER.EXTERNAL_IDENTIFIER%TYPE IS
	v_PARTICIPANT_PSE_EXT_IDENT EXTERNAL_SYSTEM_IDENTIFIER.EXTERNAL_IDENTIFIER%TYPE;
BEGIN

   SELECT ESI.EXTERNAL_IDENTIFIER
   INTO v_PARTICIPANT_PSE_EXT_IDENT
   FROM SEM_SETTLEMENT_ENTITY SSE,
		EXTERNAL_SYSTEM_IDENTIFIER ESI
   WHERE SSE.SETTLEMENT_PSE_ID = p_SETTLEMENT_PSE_ID
     AND SSE.PARTICIPANT_PSE_ID = ESI.ENTITY_ID
	 AND ESI.EXTERNAL_SYSTEM_ID = EC.ES_SEM
	 AND ESI.ENTITY_DOMAIN_ID = EC.ED_PSE
	 AND ESI.IDENTIFIER_TYPE = 'Default';

   RETURN v_PARTICIPANT_PSE_EXT_IDENT;

END GET_PARTICIPANT_PSE_EXT_IDENT;
-----------------------------------------------------------------------------------------------------------------
FUNCTION GET_PSE_FIXED_CREDIT_REQT
	(
	p_PSE_ID IN NUMBER,
	p_PSE_TYPE IN VARCHAR2,
	p_ASSESSMENT_DATE IN DATE,
	p_CREDIT_MARKET IN VARCHAR2
	) RETURN NUMBER IS
	v_REQT SEM_CREDIT_RESULT.FIXED_CREDIT_REQT%TYPE;
	v_MULTIPLIER NUMBER;
	v_UNIT_TYPE_REGEXP VARCHAR2(16);
	v_ATTRIBUTE_ID NUMBER(9);
BEGIN

	--We do not want to double count for both CA and EN.  So if this is CA, return 0.
	IF p_CREDIT_MARKET = c_MARKET_CA THEN
		RETURN 0;
	END IF;

	ID.ID_FOR_ENTITY_ATTRIBUTE(MM_SEM_UTIL.g_EA_RESOURCE_TYPE, EC.ED_SERVICE_POINT, NULL, FALSE, v_ATTRIBUTE_ID);

	SELECT CASE p_PSE_TYPE
		WHEN MM_SEM_UTIL.g_PSE_TYPE_GENERATOR_UNITS THEN A.FIXED_CREDIT_REQT_GEN
		ELSE A.FIXED_CREDIT_REQT_SUP END
	INTO v_MULTIPLIER
	FROM SEM_CREDIT_INPUT_YEARLY A
	WHERE p_ASSESSMENT_DATE BETWEEN A.BEGIN_DATE AND NVL(A.END_DATE, p_ASSESSMENT_DATE);

	IF p_PSE_TYPE = MM_SEM_UTIL.g_PSE_TYPE_GENERATOR_UNITS THEN
--ASSUME: THAT THIS IS THE RIGHT RESOURCE TYPE
		v_UNIT_TYPE_REGEXP := MM_SEM_UTIL.g_REGEXP_GEN_UNIT_TYPE;
	ELSE
--ASSUME: THAT THIS IS THE RIGHT RESOURCE TYPE
		v_UNIT_TYPE_REGEXP := MM_SEM_UTIL.g_REGEXP_SUP_UNIT_TYPE;
	END IF;

	SELECT v_MULTIPLIER * COUNT(1)
	INTO v_REQT
	FROM
		(SELECT DISTINCT POD_ID
		FROM SEM_SERVICE_POINT_PSE A, TEMPORAL_ENTITY_ATTRIBUTE B
		WHERE PSE_ID = p_PSE_ID
			AND p_ASSESSMENT_DATE BETWEEN A.BEGIN_DATE AND NVL(A.END_DATE, p_ASSESSMENT_DATE)
			AND B.OWNER_ENTITY_ID = A.POD_ID
			AND B.ATTRIBUTE_ID = v_ATTRIBUTE_ID
			AND p_ASSESSMENT_DATE BETWEEN B.BEGIN_DATE AND NVL(B.END_DATE, p_ASSESSMENT_DATE)
			AND REGEXP_LIKE(B.ATTRIBUTE_VAL, v_UNIT_TYPE_REGEXP)
		--Add in the MOYLE interconnector if we have a nomination there.
		UNION ALL
		SELECT DISTINCT IT.POD_ID
		FROM SEM_SETTLEMENT_ENTITY SSE,	INTERCHANGE_TRANSACTION IT, INTERCHANGE_CONTRACT IC
		WHERE SSE.PARTICIPANT_PSE_ID = p_PSE_ID
			AND IC.BILLING_ENTITY_ID = SSE.SETTLEMENT_PSE_ID
			AND IT.CONTRACT_ID = IC.CONTRACT_ID
			AND IT.TRANSACTION_TYPE = 'Nomination'
		);

	RETURN v_REQT;

END GET_PSE_FIXED_CREDIT_REQT;
-----------------------------------------------------------------------------------------------------------------
PROCEDURE GET_PSE_SRAS
	(
	p_ASSESSMENT_DATE IN DATE,
	p_STATEMENT_TYPE_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CREDIT_MARKET IN VARCHAR2,
	p_CREDIT_CATEGORY IN VARCHAR2,
	p_TOTAL_SRAS OUT NUMBER,
	p_SUBMITTED_SRAS OUT NUMBER
	) AS

	v_BEGIN_DATE DATE;
	v_END_DATE DATE;
	v_COMMODITY_ID NUMBER(9);
	v_MARKET_PRICE_ID NUMBER(9);
	v_FROM_CURRENCY VARCHAR2(4);
	v_BUYER_SELLER_MULTIPLIER NUMBER(2);
	v_PRICE_DATE_TRUNC_TO VARCHAR2(8);
	v_BUYER_CURRENCY VARCHAR2(4);
	v_SELLER_CURRENCY VARCHAR2(4);
	v_APPLY_EXCHANGE_RATE BINARY_INTEGER := 0;

CURSOR c_SRA_TRANSACTIONS IS
	SELECT DISTINCT T.TRANSACTION_ID, T.PURCHASER_ID, T.SELLER_ID
	FROM INTERCHANGE_TRANSACTION T
	WHERE T.TRANSACTION_TYPE = 'SRA'
		AND T.COMMODITY_ID = v_COMMODITY_ID
		AND p_PSE_ID IN (T.PURCHASER_ID, T.SELLER_ID)
		AND p_BEGIN_DATE <= T.END_DATE
		AND p_END_DATE >= T.BEGIN_DATE;

BEGIN
	IF p_BEGIN_DATE IS NULL OR p_END_DATE IS NULL THEN
		p_TOTAL_SRAS := 0;
		p_SUBMITTED_SRAS := 0;
		RETURN;
	END IF;

	--SRAs are stored as Daily Traits, which are stored at TRUNC(DATE) PLUS A SECOND.
	--So let's do the same thing to our date range.
	v_BEGIN_DATE := TRUNC(p_BEGIN_DATE) + 1/86400;
	v_END_DATE := TRUNC(p_END_DATE) + 1/86400;

	--SRAs are stored by Commodity, for Energy or Capacity.
	v_COMMODITY_ID := EI.GET_ID_FROM_ALIAS(CASE p_CREDIT_MARKET WHEN c_MARKET_EN THEN c_COMMODITY_ALIAS_ENERGY ELSE c_COMMODITY_ALIAS_CAPACITY END, EC.ED_IT_COMMODITY);

	--Loop over each SRA Transaction.
	FOR v_SRA IN c_SRA_TRANSACTIONS LOOP

		v_APPLY_EXCHANGE_RATE := 0;

		--SRA is stored in the currency of the buyer (20-mar-2008, jbc: nope, it's the seller; fix to BZ 15495
		v_FROM_CURRENCY := GET_PSE_CURRENCY(v_SRA.SELLER_ID, p_BEGIN_DATE);
		--We subtract the SRA for the buyer, and add for the seller.
		v_BUYER_SELLER_MULTIPLIER := CASE WHEN p_PSE_ID = v_SRA.PURCHASER_ID THEN -1 ELSE 1 END;

		--LD BZ 16132 - apply the exchange rate only if the buyer has a different currency than the seller
		--otherwise keep the currency unchanged
		v_BUYER_CURRENCY := GET_PSE_CURRENCY(v_SRA.PURCHASER_ID, p_BEGIN_DATE);
		v_SELLER_CURRENCY := GET_PSE_CURRENCY(v_SRA.SELLER_ID, p_BEGIN_DATE);
		IF p_PSE_ID = v_SRA.PURCHASER_ID AND v_BUYER_CURRENCY <> v_SELLER_CURRENCY  THEN
			IF v_BUYER_CURRENCY = c_CURRENCY_GBP THEN
				--get the exchange rate Euro to Pound
				GET_EUR_TO_GBP_EXCH_PRICE_ID(p_CREDIT_MARKET = c_MARKET_CA, v_MARKET_PRICE_ID, v_PRICE_DATE_TRUNC_TO);
			ELSE
				--get the exchange rate Pound to Euro
				GET_GBP_TO_EUR_EXCH_PRICE_ID(p_CREDIT_MARKET = c_MARKET_CA, v_MARKET_PRICE_ID, v_PRICE_DATE_TRUNC_TO);
			END IF;
			v_APPLY_EXCHANGE_RATE := 1;
		END IF;

		--Insert all the SRAs for this Transaction that are not Rejected.
		INSERT INTO SEM_CREDIT_DAILY_SRA (ASSESSMENT_DATE,STATEMENT_TYPE_ID,PSE_ID,CREDIT_MARKET,CREDIT_CATEGORY,STATEMENT_DATE,TRANSACTION_ID,IS_ACCEPTED,RAW_SRA_AMOUNT,NATIVE_CURRENCY,EXCHANGE_RATE,SRA_AMOUNT)
		SELECT p_ASSESSMENT_DATE, p_STATEMENT_TYPE_ID, p_PSE_ID, p_CREDIT_MARKET, p_CREDIT_CATEGORY,
			SRA_DATE,
			v_SRA.TRANSACTION_ID,
			MAX(CASE WHEN SUBMIT_STATUS = 'Submitted' AND MARKET_STATUS = 'Accepted' THEN 1 ELSE 0 END),
			SUM(SRA_AMOUNT),
			v_FROM_CURRENCY,
			CASE v_APPLY_EXCHANGE_RATE WHEN 1 THEN EXCH_PRICE ELSE NULL END,
			CASE v_APPLY_EXCHANGE_RATE WHEN 1 THEN EXCH_PRICE ELSE 1 END * SUM(SRA_AMOUNT)
		FROM
			(SELECT TRUNC(SRA.SCHEDULE_DATE) "SRA_DATE",
				GREATEST(NVL(REJ.TRAIT_VAL, 0), NVL(CAN.TRAIT_VAL,0)) "IS_VALID", -- makes sure that it is neither rejected or cancelled
				ITSS.SUBMIT_STATUS,
				ITSS.MARKET_STATUS,
				v_BUYER_SELLER_MULTIPLIER * TO_NUMBER(SRA.TRAIT_VAL) "SRA_AMOUNT",
				EXCH.PRICE "EXCH_PRICE"
			FROM IT_TRAIT_SCHEDULE SRA, IT_TRAIT_SCHEDULE_STATUS ITSS, MARKET_PRICE_VALUE EXCH, IT_TRAIT_SCHEDULE REJ, IT_TRAIT_SCHEDULE CAN
			WHERE SRA.TRANSACTION_ID = v_SRA.TRANSACTION_ID
				AND SRA.SCHEDULE_STATE = GA.INTERNAL_STATE
				AND SRA.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND SRA.TRAIT_GROUP_ID = MM_SEM_UTIL.g_TG_SRA_VALUE
				AND SRA.TRAIT_INDEX = 1
				AND SRA.SET_NUMBER = 1
				AND ITSS.TRANSACTION_ID = SRA.TRANSACTION_ID
				AND ITSS.SCHEDULE_DATE = SRA.SCHEDULE_DATE
				AND EXCH.MARKET_PRICE_ID(+) = v_MARKET_PRICE_ID
				AND EXCH.PRICE_CODE(+) = 'A'
				AND EXCH.PRICE_DATE(+) = TRUNC(SRA.SCHEDULE_DATE, v_PRICE_DATE_TRUNC_TO)
				AND EXCH.AS_OF_DATE(+) = c_LOW_DATE
				AND REJ.TRANSACTION_ID(+) = SRA.TRANSACTION_ID
				AND REJ.SCHEDULE_STATE(+) = GA.INTERNAL_STATE
				AND REJ.SCHEDULE_DATE(+) = SRA.SCHEDULE_DATE
				AND REJ.TRAIT_GROUP_ID(+) = MM_SEM_UTIL.g_TG_SRA_VALIDITY_STATUS
				AND REJ.TRAIT_INDEX(+) = MM_SEM_UTIL.g_TI_SRA_VAL_STAT_REJECTED
				AND REJ.SET_NUMBER(+) = 1
				AND REJ.STATEMENT_TYPE_ID(+) = 0
				AND CAN.TRANSACTION_ID(+) = SRA.TRANSACTION_ID
				AND CAN.SCHEDULE_STATE(+) = GA.INTERNAL_STATE
				AND CAN.SCHEDULE_DATE(+) = SRA.SCHEDULE_DATE
				AND CAN.TRAIT_GROUP_ID(+) = MM_SEM_UTIL.g_TG_SRA_VALIDITY_STATUS
				AND CAN.TRAIT_INDEX(+) = MM_SEM_UTIL.g_TI_SRA_VAL_STAT_CANCELLED
				AND CAN.SET_NUMBER(+) = 1
				AND CAN.STATEMENT_TYPE_ID(+) = 0
			)
		WHERE IS_VALID = 0
		GROUP BY SRA_DATE, EXCH_PRICE;

	END LOOP;

	SELECT NVL(SUM(SRA_AMOUNT),0),
		NVL(SUM(IS_ACCEPTED * SRA_AMOUNT),0)
	INTO p_TOTAL_SRAS, p_SUBMITTED_SRAS
	FROM SEM_CREDIT_DAILY_SRA
	WHERE ASSESSMENT_DATE = p_ASSESSMENT_DATE
		AND STATEMENT_TYPE_ID = p_STATEMENT_TYPE_ID
		AND PSE_ID = p_PSE_ID
		AND CREDIT_MARKET = p_CREDIT_MARKET
		AND CREDIT_CATEGORY = p_CREDIT_CATEGORY;

END GET_PSE_SRAS;
-----------------------------------------------------------------------------------------------------------------
PROCEDURE GET_BILLING_STMT_ENTITIES
	(
	p_PARTICIPANT_PSE_ID IN NUMBER,
	p_CREDIT_MARKET IN VARCHAR2,
	p_ENTITY_ID_1 OUT NUMBER,
	p_ENTITY_ID_2 OUT NUMBER
	) AS

	c_NO_ENTITY_ID CONSTANT NUMBER := -1;

	FUNCTION GET_SETTLEMENT_ENTITY_ID (p_MARKET_NAME IN VARCHAR2) RETURN NUMBER IS
		v_RTN NUMBER;
	BEGIN
		SELECT SETTLEMENT_PSE_ID
		INTO v_RTN
		FROM SEM_SETTLEMENT_ENTITY
		WHERE PARTICIPANT_PSE_ID = p_PARTICIPANT_PSE_ID
			AND MARKET_NAME = p_MARKET_NAME;
		RETURN v_RTN;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			RETURN c_NO_ENTITY_ID;
	END GET_SETTLEMENT_ENTITY_ID;
BEGIN

	IF p_CREDIT_MARKET = c_MARKET_EN THEN
		p_ENTITY_ID_1 := GET_SETTLEMENT_ENTITY_ID('EN');
		p_ENTITY_ID_2 := GET_SETTLEMENT_ENTITY_ID('MO');
	ELSE
		p_ENTITY_ID_1 := GET_SETTLEMENT_ENTITY_ID('CA');
		p_ENTITY_ID_2 := c_NO_ENTITY_ID;
	END IF;

	IF g_TRACE_ON THEN
		UT.DEBUG_TRACE('CR:GET_BILLING_STMT_ENTITIES');
		UT.DEBUG_TRACE('CR:   ENTITY_IDS =' || p_ENTITY_ID_1 || ' AND ' || p_ENTITY_ID_2);
	END IF;

END GET_BILLING_STMT_ENTITIES;
-----------------------------------------------------------------------------------------------------------------
FUNCTION CACHE_RESETTLEMENT_DATA
	(
	p_ASSESSMENT_DATE IN DATE,
	p_PSE_ID IN NUMBER,
	p_CREDIT_MARKET IN VARCHAR2,
	p_FROM_CURRENCY IN VARCHAR2,
	p_STATEMENT_TYPE_ID IN NUMBER,
	p_CREDIT_CATEGORY IN VARCHAR2
	) RETURN NUMBER IS
	v_ENTITY_ID_1 NUMBER(9);
	v_ENTITY_ID_2 NUMBER(9);
	v_BEGIN_DATE DATE;
	v_END_DATE DATE;
	v_PUBLISH_BEGIN_DATE DATE;
	v_PUBLISH_END_DATE DATE;
	v_BILL_AMOUNT NUMBER;
	v_RESETTLEMENT_STATEMENT_ID STATEMENT_TYPE.STATEMENT_TYPE_ID%TYPE;
	v_IDs NUMBER_COLLECTION;
	v_DAYS_TO_PAY_INVOICE NUMBER(1);
	v_RESETTLEMENT_MARKET VARCHAR2(16);

	CURSOR c_RESETTL IS
	SELECT C.BEGIN_DATE AS STATEMENT_BEGIN,
	       C.END_DATE AS STATEMENT_END,
		   C.RUN_IDENTIFIER AS REVISION_IDENTIFIER
	FROM SEM_SETTLEMENT_CALENDAR C
	WHERE C.MARKET = v_RESETTLEMENT_MARKET
	  AND C.PUBLICATION_TYPE = MM_SEM_SETTLEMENT_CALENDAR.c_PUBLICATION_TYPE_INVOICE
	  AND C.RUN_TYPE IN (MM_SEM_SETTLEMENT_CALENDAR.c_RUN_TYPE_M4,
	  					 MM_SEM_SETTLEMENT_CALENDAR.c_RUN_TYPE_M13,
						 MM_SEM_SETTLEMENT_CALENDAR.c_RUN_TYPE_ADHOC)
	  AND C.PUBLICATION_DATE BETWEEN v_PUBLISH_BEGIN_DATE AND v_PUBLISH_END_DATE;

BEGIN

	GET_BILLING_STMT_ENTITIES(p_PSE_ID, p_CREDIT_MARKET, v_ENTITY_ID_1, v_ENTITY_ID_2);

	v_RESETTLEMENT_MARKET := CASE WHEN p_CREDIT_MARKET = c_MARKET_EN THEN MM_SEM_SETTLEMENT_CALENDAR.c_MARKET_ENERGY ELSE MM_SEM_SETTLEMENT_CALENDAR.c_MARKET_CAPACITY END;
	v_DAYS_TO_PAY_INVOICE := NVL(RO.GET_ENTITY_ATTRIBUTE(c_ATTR_DAYS_TO_PAY_INVOICE, EC.ED_PSE, p_PSE_ID, p_ASSESSMENT_DATE),3);

	v_PUBLISH_BEGIN_DATE := ADD_DAYS(p_ASSESSMENT_DATE, -1*v_DAYS_TO_PAY_INVOICE, 'WD') + 1;
	v_PUBLISH_END_DATE := p_ASSESSMENT_DATE;

	FOR v_ITEM IN c_RESETTL LOOP
		v_IDs := EI.GET_IDs_FROM_IDENTIFIER_EXTSYS(v_ITEM.REVISION_IDENTIFIER, EC.ED_STATEMENT_TYPE, EC.ES_SEM, MM_SEM_UTIL.g_STATEMENT_TYPE_SETTLEMENT);
		IF v_IDs.COUNT = 0 THEN
			RAISE_APPLICATION_ERROR(-20000,'No statement type exists in Settlement Calendar for '''||v_ITEM.REVISION_IDENTIFIER||'''');
	ELSE
			v_RESETTLEMENT_STATEMENT_ID := v_IDs(v_IDs.FIRST);
	END IF;

		v_BEGIN_DATE := v_ITEM.STATEMENT_BEGIN;
		v_END_DATE := v_ITEM.STATEMENT_END;

	-- ASSUME: For now, assume that we can get all the charges except for those in the "SEM MISC" product.
	-- In the future, we may need to pick out only certain components.
		-- If that happens, we should put aay and the statement type (item detail)
	INSERT INTO SEM_CREDIT_DAILY_STMT (ASSESSMENT_DATE, STATEMENT_TYPE_ID, PSE_ID, CREDIT_MARKET, CREDIT_CATEGORY, STATEMENT_DATE, ENTITY_ID, BEST_STATEMENT_TYPE, BEST_STATEMENT_STATE, BILL_AMOUNT, NATIVE_CURRENCY)
	SELECT p_ASSESSMENT_DATE, p_STATEMENT_TYPE_ID, p_PSE_ID, p_CREDIT_MARKET, p_CREDIT_CATEGORY,
		X.STATEMENT_DATE,
		X.ENTITY_ID,
		X.STATEMENT_TYPE,
		X.STATEMENT_STATE,
		-1 * SUM(X.BILL_AMOUNT),
		p_FROM_CURRENCY
	FROM
		(SELECT BILL_AMOUNT,
			C.COMPONENT_ID,
			STATEMENT_DATE,
			STATEMENT_STATE,
			STATEMENT_TYPE,
			ENTITY_ID
		FROM BILLING_STATEMENT B, COMPONENT C
		WHERE ENTITY_ID IN (v_ENTITY_ID_1, v_ENTITY_ID_2)
			AND STATEMENT_TYPE = v_RESETTLEMENT_STATEMENT_ID
    		AND STATEMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND STATEMENT_STATE = GA.EXTERNAL_STATE
			AND AS_OF_DATE = c_LOW_DATE
			AND C.COMPONENT_ID = B.COMPONENT_ID
			--Exclude the REALLOC component since we add SRAs in separately.
			AND C.EXTERNAL_IDENTIFIER <> c_EXCLUDED_COMPONENT_IDENT
		) X
	GROUP BY STATEMENT_DATE, ENTITY_ID, STATEMENT_TYPE, STATEMENT_STATE;

	END LOOP;

	--Return the total from the staging table.
	SELECT SUM(BILL_AMOUNT)
	INTO v_BILL_AMOUNT
	FROM SEM_CREDIT_DAILY_STMT
	WHERE ASSESSMENT_DATE = p_ASSESSMENT_DATE
		AND STATEMENT_TYPE_ID = p_STATEMENT_TYPE_ID
		AND PSE_ID = p_PSE_ID
		AND CREDIT_MARKET = p_CREDIT_MARKET
		AND CREDIT_CATEGORY = p_CREDIT_CATEGORY;

	RETURN v_BILL_AMOUNT;

END CACHE_RESETTLEMENT_DATA;
-----------------------------------------------------------------------------------------------------------------
-- This function returns the effective VAT rate for an entity (a PSE),
-- best available statement type and state, for the given statement date
-- and credit market.  The credit market is used to define the time range
-- for which values will be considered.  If no VAT values are published
-- on the invoice (no VAT component values are found), the VAT rate as
-- defined on the Schedule Coordinator obtainable from MM_SEM_SHADOW_BILL.GET_TAX_RATE
-- will be returned.  Otherwise, the rate will be computed as the ratio
-- of the total VAT amount (sum of VAT component values) to the total charge amount
-- (sum of non VAT component values).  If no values are found, 0 is returned.
FUNCTION GET_EFFECTIVE_VAT_RATE
    (
	p_ENTITY_ID IN NUMBER,
	p_BEST_AVAL_STATEMENT_TYPE_ID IN NUMBER,
    p_BEST_AVAL_STATEMENT_STATE IN NUMBER,
    p_STATEMENT_DATE IN DATE,
    p_CREDIT_MARKET IN VARCHAR2
    ) RETURN NUMBER IS
    v_PERIOD_START_DATE DATE;
    v_PERIOD_END_DATE DATE;
    v_TOTAL_VAT_AMOUNT NUMBER;
    v_TOTAL_CHG_AMOUNT NUMBER;
BEGIN
    IF p_CREDIT_MARKET = 'EN' THEN
        v_PERIOD_START_DATE := DATE_UTIL.WEEK_TRUNC(p_STATEMENT_DATE, DATE_UTIL.c_WEEK_BEGIN_SUNDAY);
        v_PERIOD_END_DATE := v_PERIOD_START_DATE + 6;
    ELSIF p_CREDIT_MARKET = 'CA' THEN
        v_PERIOD_START_DATE := TRUNC(p_STATEMENT_DATE, 'MONTH');
        v_PERIOD_END_DATE := LAST_DAY(p_STATEMENT_DATE);
    END IF;

    -- Total VAT Amount
    SELECT SUM(CHARGE_AMOUNT)
    INTO v_TOTAL_VAT_AMOUNT
    FROM BILLING_STATEMENT BS, COMPONENT C
    WHERE BS.STATEMENT_DATE BETWEEN v_PERIOD_START_DATE AND v_PERIOD_END_DATE
        AND BS.ENTITY_ID = p_ENTITY_ID
        AND BS.STATEMENT_TYPE = p_BEST_AVAL_STATEMENT_TYPE_ID
        AND BS.STATEMENT_STATE = p_BEST_AVAL_STATEMENT_STATE
        AND AS_OF_DATE = c_LOW_DATE
        AND C.COMPONENT_ID = BS.COMPONENT_ID
        AND C.EXTERNAL_IDENTIFIER IN (SELECT X.COLUMN_VALUE
                                       FROM TABLE(CAST(c_VAT_COMPONENTS AS STRING_COLLECTION)) X);

	IF v_TOTAL_VAT_AMOUNT IS NULL THEN
	    -- [BZ 30715] if no VAT values are on the invoice (that is, no VAT component
		-- values are found in the time range), return the rate from the Schedule
		-- Coordinator obtainable from MM_SEM_SHADOW_BILL.GET_TAX_RATE
	    RETURN NVL(MM_SEM_SHADOW_BILL.GET_TAX_RATE(p_STATEMENT_DATE, p_ENTITY_ID), 0);
	ELSE
		-- Total Charge Amount
		SELECT SUM(CHARGE_AMOUNT)
		INTO v_TOTAL_CHG_AMOUNT
		FROM BILLING_STATEMENT BS, COMPONENT C
		WHERE BS.STATEMENT_DATE BETWEEN v_PERIOD_START_DATE AND v_PERIOD_END_DATE
			AND BS.ENTITY_ID = p_ENTITY_ID
			AND BS.STATEMENT_TYPE = p_BEST_AVAL_STATEMENT_TYPE_ID
			AND BS.STATEMENT_STATE = p_BEST_AVAL_STATEMENT_STATE
			AND AS_OF_DATE = c_LOW_DATE
			AND C.COMPONENT_ID = BS.COMPONENT_ID
			AND C.EXTERNAL_IDENTIFIER <> c_EXCLUDED_COMPONENT_IDENT
			AND C.EXTERNAL_IDENTIFIER NOT IN (SELECT X.COLUMN_VALUE
										FROM TABLE(CAST(c_VAT_COMPONENTS AS STRING_COLLECTION)) X);

		RETURN CASE WHEN v_TOTAL_CHG_AMOUNT <> 0 THEN NVL(v_TOTAL_VAT_AMOUNT/v_TOTAL_CHG_AMOUNT,0) ELSE 0 END;
	END IF;
END GET_EFFECTIVE_VAT_RATE;
-----------------------------------------------------------------------------------------------------------------
FUNCTION GET_BEST_BILLING_STMT_DATA
	(
	p_ASSESSMENT_DATE IN DATE,
	p_PARTICIPANT_PSE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CREDIT_MARKET IN VARCHAR2,
	p_FROM_CURRENCY IN VARCHAR2,
	p_STATEMENT_TYPE_ID IN NUMBER,
	p_CREDIT_CATEGORY IN VARCHAR2,
    p_USE_BLENDED_VAT_RATE IN BOOLEAN
	) RETURN NUMBER IS
	v_ENTITY_ID_1 NUMBER(9);
	v_ENTITY_ID_2 NUMBER(9);
	v_BEGIN_DATE DATE := TRUNC(p_BEGIN_DATE);
	v_END_DATE DATE := TRUNC(p_END_DATE);
	v_MARKET_PRICE_ID NUMBER(9);
	v_PRICE_DATE_TRUNC_TO VARCHAR2(8);
	v_BILL_AMOUNT NUMBER;
    v_USE_BLENDED_VAT_RATE NUMBER(1) := UT.NUMBER_FROM_BOOLEAN(p_USE_BLENDED_VAT_RATE);
BEGIN
	IF p_BEGIN_DATE IS NULL OR p_END_DATE IS NULL THEN
		RETURN 0;
	END IF;

	GET_EUR_TO_GBP_EXCH_PRICE_ID(p_CREDIT_MARKET = 'CA', v_MARKET_PRICE_ID, v_PRICE_DATE_TRUNC_TO);

	-- ASSUME: For now, assume that we can get all the charges except for those in the "SEM MISC" product.
	-- In the future, we may need to pick out only certain components.
	-- If that happens, we should put a list of excluded components into SYSTEM_LABEL.
	GET_BILLING_STMT_ENTITIES(p_PARTICIPANT_PSE_ID, p_CREDIT_MARKET, v_ENTITY_ID_1, v_ENTITY_ID_2);

	-- Get the best available billing data for the day.
	-- First try for External Statement Initial,
	-- then for External Statement Indicative,
	-- then for Internal Statement Initial,
	-- then for Internal Statement Indicative,
	-- finally for the specified STATEMENT_TYPE_ID.
	-- Run the IF clause, if this CC Run is **NOT** for UNDEFINED EXPOSURE
	IF	p_CREDIT_CATEGORY <> c_CATEGORY_UNDEF THEN
		INSERT INTO SEM_CREDIT_DAILY_STMT (ASSESSMENT_DATE, STATEMENT_TYPE_ID, PSE_ID, CREDIT_MARKET, CREDIT_CATEGORY, STATEMENT_DATE, ENTITY_ID, BEST_STATEMENT_TYPE, BEST_STATEMENT_STATE, BILL_AMOUNT, NATIVE_CURRENCY, EXCHANGE_RATE_POUND_TO_EURO, EURO_BILL_AMOUNT)
		SELECT p_ASSESSMENT_DATE, p_STATEMENT_TYPE_ID, p_PARTICIPANT_PSE_ID, p_CREDIT_MARKET, p_CREDIT_CATEGORY,
			X.STATEMENT_DATE,
			X.ENTITY_ID,
			X.STATEMENT_TYPE,
			X.STATEMENT_STATE,
			CASE WHEN p_CREDIT_CATEGORY = c_CATEGORY_UNDEF THEN -1 * SUM(X.CHARGE_AMOUNT) * (1+ GET_EFFECTIVE_VAT_RATE(X.ENTITY_ID,
																					X.STATEMENT_TYPE,
																					X.STATEMENT_STATE,
																					X.STATEMENT_DATE,
																					p_CREDIT_MARKET))
				ELSE -1 * SUM(X.CHARGE_AMOUNT) END,
			p_FROM_CURRENCY,
			MAX(CASE p_FROM_CURRENCY WHEN c_CURRENCY_GBP THEN NVL(1/EXCH.PRICE,1) ELSE NULL END),
			CASE WHEN p_CREDIT_CATEGORY = c_CATEGORY_UNDEF AND p_FROM_CURRENCY = c_CURRENCY_GBP
					THEN -1 * SUM(NVL(1/EXCH.PRICE,1) * X.CHARGE_AMOUNT) * (1+ GET_EFFECTIVE_VAT_RATE(X.ENTITY_ID,
																					X.STATEMENT_TYPE,
																					X.STATEMENT_STATE,
																					X.STATEMENT_DATE,
																					p_CREDIT_MARKET))
				 WHEN p_CREDIT_CATEGORY = c_CATEGORY_UNDEF AND p_FROM_CURRENCY = c_CURRENCY_EURO
					THEN -1 * SUM(X.CHARGE_AMOUNT) * (1+ GET_EFFECTIVE_VAT_RATE(X.ENTITY_ID,
																					X.STATEMENT_TYPE,
																					X.STATEMENT_STATE,
																					X.STATEMENT_DATE,
																					p_CREDIT_MARKET))
				 ELSE NULL END
		FROM
			(SELECT CHARGE_AMOUNT,
				C.COMPONENT_ID,
				STATEMENT_DATE,
				STATEMENT_STATE,
				STATEMENT_TYPE,
				ENTITY_ID,
				CASE WHEN STATEMENT_STATE = 2 AND STATEMENT_TYPE = g_STMT_INITIAL THEN 1
					WHEN STATEMENT_STATE = 2 AND STATEMENT_TYPE = g_STMT_INDIC THEN 2
					WHEN STATEMENT_STATE = 1 AND STATEMENT_TYPE = g_STMT_INITIAL THEN 3
					WHEN STATEMENT_STATE = 1 AND STATEMENT_TYPE = g_STMT_INDIC THEN 4
					WHEN STATEMENT_STATE = 1 AND STATEMENT_TYPE = p_STATEMENT_TYPE_ID THEN 5
					ELSE 9 END "PRIORITY",
				MIN(CASE WHEN STATEMENT_STATE = 2 AND STATEMENT_TYPE = g_STMT_INITIAL THEN 1
					WHEN STATEMENT_STATE = 2 AND STATEMENT_TYPE = g_STMT_INDIC THEN 2
					WHEN STATEMENT_STATE = 1 AND STATEMENT_TYPE = g_STMT_INITIAL THEN 3
					WHEN STATEMENT_STATE = 1 AND STATEMENT_TYPE = g_STMT_INDIC THEN 4
					WHEN STATEMENT_STATE = 1 AND STATEMENT_TYPE = p_STATEMENT_TYPE_ID THEN 5
					ELSE 9 END) OVER (PARTITION BY STATEMENT_DATE) "BEST_PRIORITY"
			FROM BILLING_STATEMENT B, COMPONENT C
			WHERE ENTITY_ID IN (v_ENTITY_ID_1, v_ENTITY_ID_2)
				AND STATEMENT_TYPE IN (g_STMT_INITIAL, g_STMT_INDIC, p_STATEMENT_TYPE_ID)
				AND STATEMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND AS_OF_DATE = c_LOW_DATE
				AND C.COMPONENT_ID = B.COMPONENT_ID
				--Exclude the REALLOC component since we add SRAs in separately.
				AND C.EXTERNAL_IDENTIFIER <> c_EXCLUDED_COMPONENT_IDENT
				-- Exclude the tax components if we are supposed to use the blended rate
				AND ((v_USE_BLENDED_VAT_RATE = 0 AND p_CREDIT_CATEGORY <> c_CATEGORY_UNDEF) OR
					C.EXTERNAL_IDENTIFIER NOT IN (SELECT X.COLUMN_VALUE
												  FROM TABLE(CAST(c_VAT_COMPONENTS AS STRING_COLLECTION)) X))
			) X, MARKET_PRICE_VALUE EXCH
		WHERE PRIORITY = BEST_PRIORITY
		  AND EXCH.MARKET_PRICE_ID(+) = v_MARKET_PRICE_ID
		  AND EXCH.PRICE_CODE(+) = 'A'
		  AND EXCH.PRICE_DATE(+) = TRUNC(STATEMENT_DATE, v_PRICE_DATE_TRUNC_TO)
		  AND EXCH.AS_OF_DATE(+) = c_LOW_DATE
		GROUP BY STATEMENT_DATE, ENTITY_ID, STATEMENT_TYPE, STATEMENT_STATE;
	-- Run the ELSE clause, if this CC Run **IS** for UNDEFINED EXPOSURE
	-- The main reason behind this ELSE clause is the addition of the AND clause in the WHERE clause
	-- where the IUGEX components are excluded from the sub-query. In all other aspects, it is just the same as in the
	-- IF clause
	ELSE
		INSERT INTO SEM_CREDIT_DAILY_STMT (ASSESSMENT_DATE, STATEMENT_TYPE_ID, PSE_ID, CREDIT_MARKET, CREDIT_CATEGORY, STATEMENT_DATE, ENTITY_ID, BEST_STATEMENT_TYPE, BEST_STATEMENT_STATE, BILL_AMOUNT, NATIVE_CURRENCY, EXCHANGE_RATE_POUND_TO_EURO, EURO_BILL_AMOUNT)
		SELECT p_ASSESSMENT_DATE, p_STATEMENT_TYPE_ID, p_PARTICIPANT_PSE_ID, p_CREDIT_MARKET, p_CREDIT_CATEGORY,
			X.STATEMENT_DATE,
			X.ENTITY_ID,
			X.STATEMENT_TYPE,
			X.STATEMENT_STATE,
			CASE WHEN p_CREDIT_CATEGORY = c_CATEGORY_UNDEF THEN -1 * SUM(X.CHARGE_AMOUNT) * (1+ GET_EFFECTIVE_VAT_RATE(X.ENTITY_ID,
																					X.STATEMENT_TYPE,
																					X.STATEMENT_STATE,
																					X.STATEMENT_DATE,
																					p_CREDIT_MARKET))
				ELSE -1 * SUM(X.CHARGE_AMOUNT) END,
			p_FROM_CURRENCY,
			MAX(CASE p_FROM_CURRENCY WHEN c_CURRENCY_GBP THEN NVL(1/EXCH.PRICE,1) ELSE NULL END),
			CASE WHEN p_CREDIT_CATEGORY = c_CATEGORY_UNDEF AND p_FROM_CURRENCY = c_CURRENCY_GBP
					THEN -1 * SUM(NVL(1/EXCH.PRICE,1) * X.CHARGE_AMOUNT) * (1+ GET_EFFECTIVE_VAT_RATE(X.ENTITY_ID,
																					X.STATEMENT_TYPE,
																					X.STATEMENT_STATE,
																					X.STATEMENT_DATE,
																					p_CREDIT_MARKET))
				 WHEN p_CREDIT_CATEGORY = c_CATEGORY_UNDEF AND p_FROM_CURRENCY = c_CURRENCY_EURO
					THEN -1 * SUM(X.CHARGE_AMOUNT) * (1+ GET_EFFECTIVE_VAT_RATE(X.ENTITY_ID,
																					X.STATEMENT_TYPE,
																					X.STATEMENT_STATE,
																					X.STATEMENT_DATE,
																					p_CREDIT_MARKET))
				 ELSE NULL END
		FROM
			(SELECT CHARGE_AMOUNT,
				C.COMPONENT_ID,
				STATEMENT_DATE,
				STATEMENT_STATE,
				STATEMENT_TYPE,
				ENTITY_ID,
				CASE WHEN STATEMENT_STATE = 2 AND STATEMENT_TYPE = g_STMT_INITIAL THEN 1
					WHEN STATEMENT_STATE = 2 AND STATEMENT_TYPE = g_STMT_INDIC THEN 2
					WHEN STATEMENT_STATE = 1 AND STATEMENT_TYPE = g_STMT_INITIAL THEN 3
					WHEN STATEMENT_STATE = 1 AND STATEMENT_TYPE = g_STMT_INDIC THEN 4
					WHEN STATEMENT_STATE = 1 AND STATEMENT_TYPE = p_STATEMENT_TYPE_ID THEN 5
					ELSE 9 END "PRIORITY",
				MIN(CASE WHEN STATEMENT_STATE = 2 AND STATEMENT_TYPE = g_STMT_INITIAL THEN 1
					WHEN STATEMENT_STATE = 2 AND STATEMENT_TYPE = g_STMT_INDIC THEN 2
					WHEN STATEMENT_STATE = 1 AND STATEMENT_TYPE = g_STMT_INITIAL THEN 3
					WHEN STATEMENT_STATE = 1 AND STATEMENT_TYPE = g_STMT_INDIC THEN 4
					WHEN STATEMENT_STATE = 1 AND STATEMENT_TYPE = p_STATEMENT_TYPE_ID THEN 5
					ELSE 9 END) OVER (PARTITION BY STATEMENT_DATE) "BEST_PRIORITY"
			FROM BILLING_STATEMENT B, COMPONENT C
			WHERE ENTITY_ID IN (v_ENTITY_ID_1, v_ENTITY_ID_2)
				AND STATEMENT_TYPE IN (g_STMT_INITIAL, g_STMT_INDIC, p_STATEMENT_TYPE_ID)
				AND STATEMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND AS_OF_DATE = c_LOW_DATE
				AND C.COMPONENT_ID = B.COMPONENT_ID
				--Exclude the REALLOC component since we add SRAs in separately.
				AND C.EXTERNAL_IDENTIFIER <> c_EXCLUDED_COMPONENT_IDENT
				-- Exclude the tax components if we are supposed to use the blended rate
				AND ((v_USE_BLENDED_VAT_RATE = 0 AND p_CREDIT_CATEGORY <> c_CATEGORY_UNDEF) OR
					C.EXTERNAL_IDENTIFIER NOT IN (SELECT X.COLUMN_VALUE
												  FROM TABLE(CAST(c_VAT_COMPONENTS AS STRING_COLLECTION)) X))
				-- Exclude the UNDEF IDT components
				AND C.EXTERNAL_IDENTIFIER NOT IN (SELECT X.COLUMN_VALUE
												  FROM TABLE(CAST(c_IDT_UNDEF_COMPONENTS AS STRING_COLLECTION)) X)
			) X, MARKET_PRICE_VALUE EXCH
		WHERE PRIORITY = BEST_PRIORITY
		  AND EXCH.MARKET_PRICE_ID(+) = v_MARKET_PRICE_ID
		  AND EXCH.PRICE_CODE(+) = 'A'
		  AND EXCH.PRICE_DATE(+) = TRUNC(STATEMENT_DATE, v_PRICE_DATE_TRUNC_TO)
		  AND EXCH.AS_OF_DATE(+) = c_LOW_DATE
		GROUP BY STATEMENT_DATE, ENTITY_ID, STATEMENT_TYPE, STATEMENT_STATE;
	END IF;

    IF p_USE_BLENDED_VAT_RATE THEN
        UPDATE SEM_CREDIT_DAILY_STMT ST
        SET ST.BILL_AMOUNT = ST.BILL_AMOUNT * (1+(MM_SEM_SHADOW_BILL.GET_TAX_RATE(ST.STATEMENT_DATE, ST.ENTITY_ID, 0))),
            ST.EURO_BILL_AMOUNT = ST.EURO_BILL_AMOUNT * (1+(MM_SEM_SHADOW_BILL.GET_TAX_RATE(ST.STATEMENT_DATE, ST.ENTITY_ID, 0)))
        WHERE ST.PSE_ID = p_PARTICIPANT_PSE_ID
            AND ST.ASSESSMENT_DATE = p_ASSESSMENT_DATE
            AND ST.STATEMENT_TYPE_ID = p_STATEMENT_TYPE_ID
            AND ST.CREDIT_MARKET = p_CREDIT_MARKET
            AND ST.CREDIT_CATEGORY = p_CREDIT_CATEGORY;
    END IF;

	--Return the total from the staging table.
	SELECT CASE WHEN p_CREDIT_CATEGORY = c_CATEGORY_UNDEF THEN SUM(EURO_BILL_AMOUNT)
	            ELSE SUM(BILL_AMOUNT) END
	INTO v_BILL_AMOUNT
	FROM SEM_CREDIT_DAILY_STMT
	WHERE ASSESSMENT_DATE = p_ASSESSMENT_DATE
		AND STATEMENT_TYPE_ID = p_STATEMENT_TYPE_ID
		AND PSE_ID = p_PARTICIPANT_PSE_ID
		AND CREDIT_MARKET = p_CREDIT_MARKET
		AND CREDIT_CATEGORY = p_CREDIT_CATEGORY;

	RETURN v_BILL_AMOUNT;

END GET_BEST_BILLING_STMT_DATA;
-----------------------------------------------------------------------------------------------------------------
PROCEDURE PUT_NDLF_DETAILS
	(
	p_ASSESSMENT_DATE IN DATE,
	p_STATEMENT_TYPE_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_CREDIT_MARKET IN VARCHAR2,
	p_CURRENCY_CALCS IN SEM_CREDIT_CALC_CURRENCY%ROWTYPE,
	p_TIME_ZONE IN VARCHAR2
	) AS

	v_DAY_BEGIN_DATE DATE;
	v_DAY_END_DATE DATE;
	v_POWER_COMMODITY_ID NUMBER(9);
	v_STATEMENT_TYPE_ID NUMBER(9);

CURSOR c_DAILY_EN_SETTLEMENT IS
	SELECT STATEMENT_DATE, ENTITY_ID
	FROM SEM_CREDIT_DAILY_STMT STMT, SEM_SETTLEMENT_ENTITY SSE
	WHERE ASSESSMENT_DATE = p_ASSESSMENT_DATE
		AND STATEMENT_TYPE_ID = p_STATEMENT_TYPE_ID
		AND PSE_ID = p_PSE_ID
		AND CREDIT_MARKET = p_CREDIT_MARKET
		AND CREDIT_CATEGORY = c_CATEGORY_UNDEF
		AND STMT.ENTITY_ID = SSE.SETTLEMENT_PSE_ID
		AND SSE.PARTICIPANT_PSE_ID = p_PSE_ID
		AND SSE.MARKET_NAME = 'EN';

-- For Energy Supplier Undefined Exposure for Standard participants, we need to factor in the VMOP and NDLF.
-- The formula for the HistSettlement for those participants is <Total for the day> ChrgEN + (VMOP * NDLF).
-- This procedure stores the VMOP and NDLF numbers into the SEM_CREDIT_DAILY_STMT table alongside the
--    ChrgEN (Billing Statement Total) amounts that are already in the table so that they can
--    be used to calculate total Undefined Exposure in the GET_PSE_UNDEFINED_DATA_STD procedure.
BEGIN

	ID.ID_FOR_COMMODITY('Power', FALSE, v_POWER_COMMODITY_ID);

	FOR v_DAY IN c_DAILY_EN_SETTLEMENT LOOP
		UT.CUT_DATE_RANGE(1, v_DAY.STATEMENT_DATE, v_DAY.STATEMENT_DATE, p_TIME_ZONE, v_DAY_BEGIN_DATE, v_DAY_END_DATE);

		SELECT BEST_STATEMENT_TYPE
		INTO v_STATEMENT_TYPE_ID
		FROM SEM_CREDIT_DAILY_STMT A
		WHERE A.ASSESSMENT_DATE = p_ASSESSMENT_DATE
			AND A.STATEMENT_TYPE_ID = p_STATEMENT_TYPE_ID
			AND A.PSE_ID = p_PSE_ID
			AND A.CREDIT_MARKET = p_CREDIT_MARKET
			AND A.CREDIT_CATEGORY = c_CATEGORY_UNDEF
			AND A.STATEMENT_DATE = v_DAY.STATEMENT_DATE
			AND A.ENTITY_ID = v_DAY.ENTITY_ID;

		UPDATE SEM_CREDIT_DAILY_STMT A
		SET VMOP = 	p_CURRENCY_CALCS.VAR_MO_PRICE,
			NDLF =
				-1*(SELECT
					SUM(ITS_AMOUNT * MM_SEM_SHADOW_BILL.GET_TLAF(SCHEDULE_DATE, SERVICE_POINT_NAME, v_DAY.ENTITY_ID))
				FROM
					(SELECT SERVICE_POINT_NAME,
						ITS.SCHEDULE_DATE,
						SUM(ITS.AMOUNT) "ITS_AMOUNT"
					FROM SEM_SERVICE_POINT_PSE SPP,
						INTERCHANGE_TRANSACTION T,
						SERVICE_POINT SP,
						IT_SCHEDULE ITS
					WHERE SPP.PSE_ID = p_PSE_ID
						AND T.POD_ID = SPP.POD_ID
						AND T.COMMODITY_ID = v_POWER_COMMODITY_ID
						AND T.SC_ID = MM_SEM_UTIL.SEM_SC_ID
						AND T.TRANSACTION_TYPE = 'Load'
						AND SP.SERVICE_POINT_ID = T.POD_ID
						AND ITS.TRANSACTION_ID = T.TRANSACTION_ID
						AND ITS.SCHEDULE_TYPE = v_STATEMENT_TYPE_ID
						AND ITS.SCHEDULE_STATE = GA.INTERNAL_STATE
						AND ITS.SCHEDULE_DATE BETWEEN v_DAY_BEGIN_DATE AND v_DAY_END_DATE
						AND ITS.AS_OF_DATE = c_LOW_DATE
					GROUP BY SERVICE_POINT_NAME, SCHEDULE_DATE
					)
				)
		WHERE A.ASSESSMENT_DATE = p_ASSESSMENT_DATE
			AND A.STATEMENT_TYPE_ID = p_STATEMENT_TYPE_ID
			AND A.PSE_ID = p_PSE_ID
			AND A.CREDIT_MARKET = p_CREDIT_MARKET
			AND A.CREDIT_CATEGORY = c_CATEGORY_UNDEF
			AND A.STATEMENT_DATE = v_DAY.STATEMENT_DATE
			AND A.ENTITY_ID = v_DAY.ENTITY_ID;
	END LOOP;
END PUT_NDLF_DETAILS;
-----------------------------------------------------------------------------------------------------------------
FUNCTION GET_PSE_INVOICES_NOT_PAID
	(
	p_ASSESSMENT_DATE IN DATE,
	p_PSE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CREDIT_MARKET IN VARCHAR2,
	p_FROM_CURRENCY IN VARCHAR2,
	p_STATEMENT_TYPE_ID IN NUMBER
	) RETURN NUMBER IS
	v_BILLING_STATEMENT_RESULT NUMBER;
	v_SRA_TOTAL NUMBER;
	v_SRA_SUBMITTED NUMBER;
BEGIN

	IF g_TRACE_ON THEN
		UT.DEBUG_TRACE('CR:GET_PSE_INVOICES_NOT_PAID');
		UT.DEBUG_TRACE('CR:   PSE_ID=' || p_PSE_ID);
		UT.DEBUG_TRACE('CR:   BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE, 'YYYY-MM-DD HH24:MI'));
		UT.DEBUG_TRACE('CR:   END_DATE=' || TO_CHAR(p_END_DATE, 'YYYY-MM-DD HH24:MI'));
		UT.DEBUG_TRACE('CR:   CREDIT_MARKET=' || p_CREDIT_MARKET);
		UT.DEBUG_TRACE('CR:   STATEMENT_TYPE_ID=' || p_STATEMENT_TYPE_ID);
	END IF;

	--Store the best available data in the Billing Statement Table for that date range.
	v_BILLING_STATEMENT_RESULT := GET_BEST_BILLING_STMT_DATA(p_ASSESSMENT_DATE, p_PSE_ID, p_BEGIN_DATE, p_END_DATE,
		p_CREDIT_MARKET, p_FROM_CURRENCY, p_STATEMENT_TYPE_ID, c_CATEGORY_INV_NOT_PAID, FALSE);

	-- get the resettlement data
	v_BILLING_STATEMENT_RESULT := CACHE_RESETTLEMENT_DATA(p_ASSESSMENT_DATE, p_PSE_ID,
		p_CREDIT_MARKET, p_FROM_CURRENCY, p_STATEMENT_TYPE_ID, c_CATEGORY_INV_NOT_PAID);

	--Add in the SRAs separately.
	GET_PSE_SRAS(p_ASSESSMENT_DATE, p_STATEMENT_TYPE_ID, p_PSE_ID, p_BEGIN_DATE, p_END_DATE, p_CREDIT_MARKET, c_CATEGORY_INV_NOT_PAID, v_SRA_TOTAL, v_SRA_SUBMITTED);

	--ASSUME: That SRAs Submitted is the right thing to use here -- not SRAs Total.
	RETURN NVL(v_BILLING_STATEMENT_RESULT,0) + NVL(v_SRA_SUBMITTED,0);
END GET_PSE_INVOICES_NOT_PAID;
-----------------------------------------------------------------------------------------------------------------
FUNCTION GET_PSE_STMT_NOT_INVOICED
	(
	p_ASSESSMENT_DATE IN DATE,
	p_PSE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CREDIT_MARKET IN VARCHAR2,
	p_FROM_CURRENCY IN VARCHAR2,
	p_STATEMENT_TYPE_ID IN NUMBER
	) RETURN NUMBER IS
	v_BILLING_STATEMENT_RESULT NUMBER;
BEGIN

	--Get the best available data in the Billing Statement Table for that date range.
	v_BILLING_STATEMENT_RESULT := GET_BEST_BILLING_STMT_DATA(p_ASSESSMENT_DATE, p_PSE_ID, p_BEGIN_DATE, p_END_DATE,
		p_CREDIT_MARKET, p_FROM_CURRENCY, p_STATEMENT_TYPE_ID, c_CATEGORY_STMT_NOT_INV, TRUE);

	--That's all we need, unlike the Invoiced Not Paid.
	RETURN NVL(v_BILLING_STATEMENT_RESULT,0);
END GET_PSE_STMT_NOT_INVOICED;
-----------------------------------------------------------------------------------------------------------------
FUNCTION GET_PSE_UNDEFINED_DATA_ADJ
	(
	p_ASSESSMENT_DATE IN DATE,
	p_STATEMENT_TYPE_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_PSE_TYPE IN VARCHAR2,
	p_CREDIT_MARKET IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CAPACITY_ADJ_FACTOR IN NUMBER,
	p_CURRENCY_CALCS IN SEM_CREDIT_CALC_CURRENCY%ROWTYPE,
	p_TIME_ZONE IN VARCHAR2,
	p_EXCHANGE_RATE IN NUMBER
	) RETURN NUMBER IS
	v_VOL NUMBER;
	v_BEGIN_DATE DATE;
	v_END_DATE DATE;
	v_SUP_GEN_MULTIPLIER NUMBER(2) := CASE p_PSE_TYPE WHEN MM_SEM_UTIL.g_PSE_TYPE_GENERATOR_UNITS THEN -1 ELSE 1 END;
-- Get the undefined period total for New/Adjusted Participants, and store the calculation details.
BEGIN
	UT.CUT_DATE_RANGE(1, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	--BZ 17093 - the calculation needs to be in the native currency of the Participant
	--apply the exchange rate to the assessment price
	INSERT INTO SEM_CREDIT_DAILY_UNDEF_ADJ (ASSESSMENT_DATE,STATEMENT_TYPE_ID,PSE_ID,CREDIT_MARKET,STATEMENT_DATE,FORECAST_VOLUME,CAPACITY_ADJ_FACTOR,ASSESSMENT_PRICE, VAT_RATE)
	SELECT p_ASSESSMENT_DATE, p_STATEMENT_TYPE_ID, p_PSE_ID, p_CREDIT_MARKET,
		SDT.LOCAL_DAY_TRUNC_DATE,
		v_SUP_GEN_MULTIPLIER * SUM(AMOUNT),
		p_CAPACITY_ADJ_FACTOR,
		p_EXCHANGE_RATE *(CASE p_CREDIT_MARKET WHEN c_MARKET_EN THEN p_CURRENCY_CALCS.CREDIT_ASSESSMENT_PRICE ELSE p_CURRENCY_CALCS.ESTIMATED_CAPACITY_PRICE END),
		MM_SEM_SHADOW_BILL.GET_TAX_RATE(SDT.LOCAL_DAY_TRUNC_DATE, p_PSE_ID, 1)
	FROM INTERCHANGE_TRANSACTION A, IT_SCHEDULE B, SYSTEM_DATE_TIME SDT
	WHERE A.TRANSACTION_TYPE = 'Unit Forecast'
		AND A.PSE_ID = p_PSE_ID
		AND B.TRANSACTION_ID = A.TRANSACTION_ID
		AND B.SCHEDULE_TYPE = p_STATEMENT_TYPE_ID
		AND B.SCHEDULE_STATE = GA.INTERNAL_STATE
		AND B.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND B.AS_OF_DATE = c_LOW_DATE
		AND SDT.TIME_ZONE = p_TIME_ZONE
		AND SDT.DATA_INTERVAL_TYPE = 1
		AND SDT.DAY_TYPE = '1'
		AND SDT.CUT_DATE_SCHEDULING = B.SCHEDULE_DATE
	GROUP BY SDT.LOCAL_DAY_TRUNC_DATE;

	--Return the total of the Forecast Output or Forecast Demand for the specified date range.
	SELECT SUM(FORECAST_VOLUME)
	INTO v_VOL
	FROM SEM_CREDIT_DAILY_UNDEF_ADJ
	WHERE ASSESSMENT_DATE = p_ASSESSMENT_DATE
		AND STATEMENT_TYPE_ID = p_STATEMENT_TYPE_ID
		AND PSE_ID = p_PSE_ID
		AND CREDIT_MARKET = p_CREDIT_MARKET;

	RETURN v_VOL;

END GET_PSE_UNDEFINED_DATA_ADJ;
-----------------------------------------------------------------------------------------------------------------
PROCEDURE GET_PSE_UNDEFINED_DATA_STD
	(
	p_ASSESSMENT_DATE IN DATE,
	p_STATEMENT_TYPE_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_PSE_TYPE IN VARCHAR2,
	p_CREDIT_MARKET IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_FROM_CURRENCY IN VARCHAR2,
	p_DAYS_IN_SAMPLE IN NUMBER,
	p_CURRENCY_CALCS IN SEM_CREDIT_CALC_CURRENCY%ROWTYPE,
	p_TIME_ZONE IN VARCHAR2,
	p_AVG_HIST_SETTLEMENT OUT NUMBER,
	p_STD_DEV_HIST_SETTLEMENT OUT NUMBER
	) AS
	DUMMY NUMBER;

-- Get the undefined period total for Standard Participants, and store the calculation details.
BEGIN
	IF p_BEGIN_DATE IS NULL OR p_END_DATE IS NULL THEN
		p_AVG_HIST_SETTLEMENT := 0;
		p_STD_DEV_HIST_SETTLEMENT := 0;
		RETURN;
	END IF;

	--First store the statement details for the whole Historical date range.
	DUMMY := GET_BEST_BILLING_STMT_DATA(p_ASSESSMENT_DATE, p_PSE_ID, p_BEGIN_DATE, p_END_DATE,
		p_CREDIT_MARKET, p_FROM_CURRENCY, p_STATEMENT_TYPE_ID, c_CATEGORY_UNDEF, FALSE);

	--Update to include the NDLF and VMOP for Energy Supplier.
	IF p_PSE_TYPE = MM_SEM_UTIL.g_PSE_TYPE_SUPPLIER_UNITS AND p_CREDIT_MARKET = c_MARKET_EN THEN
		PUT_NDLF_DETAILS(p_ASSESSMENT_DATE, p_STATEMENT_TYPE_ID, p_PSE_ID, p_CREDIT_MARKET, p_CURRENCY_CALCS, p_TIME_ZONE);
	END IF;

	--Store the values of all the samples that are the size of the Undef period found in the HAP.
	INSERT INTO	SEM_CREDIT_DAILY_UNDEF_STD(ASSESSMENT_DATE,STATEMENT_TYPE_ID,PSE_ID,CREDIT_MARKET,SAMPLE_BEGIN_DATE,SAMPLE_END_DATE,SAMPLE_AMOUNT)
	SELECT p_ASSESSMENT_DATE, p_STATEMENT_TYPE_ID, p_PSE_ID, p_CREDIT_MARKET,
		SAMPLE_BEGIN_DATE,
		SAMPLE_BEGIN_DATE + p_DAYS_IN_SAMPLE - 1,
		SAMPLE_AMOUNT
	FROM
		--Get the rolling total of each slice that is the size of the Undef period.
		(SELECT SUM(DAILY_SAMPLE_AMOUNT) OVER (
			ORDER BY STATEMENT_DATE
			RANGE BETWEEN 0 PRECEDING AND p_DAYS_IN_SAMPLE - 1 FOLLOWING
			) "SAMPLE_AMOUNT", STATEMENT_DATE "SAMPLE_BEGIN_DATE"
		FROM
			--BZ 17093 -
			--This needs to be in the native currency of the Participant
			(SELECT SUM(BILL_AMOUNT + NVL(VMOP * NDLF, 0)/NVL(EXCHANGE_RATE_POUND_TO_EURO, 1)) "DAILY_SAMPLE_AMOUNT",
				STMT.STATEMENT_DATE
			FROM SEM_CREDIT_DAILY_STMT STMT, SEM_SETTLEMENT_ENTITY SSE
			WHERE STMT.ASSESSMENT_DATE = p_ASSESSMENT_DATE
				AND STMT.STATEMENT_TYPE_ID = p_STATEMENT_TYPE_ID
				AND STMT.PSE_ID = p_PSE_ID
				AND STMT.CREDIT_MARKET = p_CREDIT_MARKET
				AND STMT.CREDIT_CATEGORY = c_CATEGORY_UNDEF
				AND STMT.ENTITY_ID = SSE.SETTLEMENT_PSE_ID
			GROUP BY STMT.STATEMENT_DATE)
		)
	-- This date range is different because we only want the full slices in the date range --
	-- we want to cut off the last few slices that don't have the full number of days in them.
	WHERE SAMPLE_BEGIN_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE - p_DAYS_IN_SAMPLE + 1;

	--Return the Avg and Std Dev of the slice totals.
	SELECT AVG(SAMPLE_AMOUNT), STDDEV(SAMPLE_AMOUNT)
	INTO p_AVG_HIST_SETTLEMENT, p_STD_DEV_HIST_SETTLEMENT
	FROM SEM_CREDIT_DAILY_UNDEF_STD
	WHERE ASSESSMENT_DATE = p_ASSESSMENT_DATE
		AND STATEMENT_TYPE_ID = p_STATEMENT_TYPE_ID
		AND PSE_ID = p_PSE_ID
		AND CREDIT_MARKET = p_CREDIT_MARKET;

END GET_PSE_UNDEFINED_DATA_STD;
-----------------------------------------------------------------------------------------------------------------
FUNCTION GET_PSE_UNDEFINED_EXPOSURE
	(
	p_PSE_STATUS IN VARCHAR2,
	p_PSE_TYPE IN VARCHAR2,
	p_ASSESSMENT_DATE IN DATE,
	p_CREDIT_MARKET IN VARCHAR2,
	p_FROM_CURRENCY IN VARCHAR2,
	p_PSE_CALCS IN SEM_CREDIT_CALC_PSE%ROWTYPE,
	p_CURRENCY_CALCS IN SEM_CREDIT_CALC_CURRENCY%ROWTYPE,
	p_TIME_ZONE IN VARCHAR2,
	p_EXCHANGE_RATE IN NUMBER
	) RETURN NUMBER IS
	v_UNDEF SEM_CREDIT_RESULT.UNDEFINED_EXPOSURE%TYPE;
	v_ANPP SEM_CREDIT_INPUT_YEARLY.ANALYSIS_PERCENTILE_PARAM%TYPE;
	v_CREDIT_VOLUME NUMBER;
	v_AVG_HIST_SETTLEMENT NUMBER;
	v_STDDEV_HIST_SETTLEMENT NUMBER;
	v_DAYS_IN_SAMPLE NUMBER;
BEGIN

	-- This is used only for Standard Participants.
	IF p_PSE_STATUS = c_CREDIT_STATUS_STANDARD THEN
		v_DAYS_IN_SAMPLE := p_PSE_CALCS.UNDEFINED_PERIOD_END_DATE - p_PSE_CALCS.UNDEFINED_PERIOD_BEGIN_DATE + 1;

		GET_PSE_UNDEFINED_DATA_STD(p_ASSESSMENT_DATE, p_PSE_CALCS.STATEMENT_TYPE_ID,
			p_PSE_CALCS.PSE_ID, p_PSE_TYPE, p_CREDIT_MARKET, p_PSE_CALCS.HIST_ASSESSMENT_BEGIN_DATE, p_PSE_CALCS.HIST_ASSESSMENT_END_DATE,
			p_FROM_CURRENCY, v_DAYS_IN_SAMPLE, p_CURRENCY_CALCS, p_TIME_ZONE, v_AVG_HIST_SETTLEMENT, v_STDDEV_HIST_SETTLEMENT);

		SELECT A.ANALYSIS_PERCENTILE_PARAM
		INTO v_ANPP
		FROM SEM_CREDIT_INPUT_YEARLY A
		WHERE p_ASSESSMENT_DATE BETWEEN A.BEGIN_DATE AND NVL(A.END_DATE, p_ASSESSMENT_DATE);

		-- 5-may-2009, jbc, BZ 18585: UDEF should always be further away from zero than the avg hist settlement
		/*IF p_PSE_TYPE = MM_SEM_UTIL.g_PSE_TYPE_SUPPLIER_UNITS THEN
		   v_UNDEF := v_AVG_HIST_SETTLEMENT + v_ANPP * v_STDDEV_HIST_SETTLEMENT;
		ELSE
		   v_UNDEF := v_AVG_HIST_SETTLEMENT - v_ANPP * v_STDDEV_HIST_SETTLEMENT;
		END IF;*/
		v_UNDEF := (ABS(v_AVG_HIST_SETTLEMENT) + ABS(v_ANPP * v_STDDEV_HIST_SETTLEMENT)) * (CASE SIGN(v_AVG_HIST_SETTLEMENT) WHEN 0 THEN 1 ELSE SIGN(v_AVG_HIST_SETTLEMENT) END);

		--Update the PSE Calcs with the details.
		UPDATE SEM_CREDIT_CALC_PSE
		SET AVERAGE_HIST_SETTLEMENT = v_AVG_HIST_SETTLEMENT,
			STD_DEVIATION_HIST_SETTLEMENT = v_STDDEV_HIST_SETTLEMENT
		WHERE ASSESSMENT_DATE = p_ASSESSMENT_DATE
			AND STATEMENT_TYPE_ID = p_PSE_CALCS.STATEMENT_TYPE_ID
			AND PSE_ID = p_PSE_CALCS.PSE_ID
			AND CREDIT_MARKET = p_PSE_CALCS.CREDIT_MARKET;

	-- This is used only for New/Adjusted Participants.
	ELSE
		v_CREDIT_VOLUME := GET_PSE_UNDEFINED_DATA_ADJ(p_ASSESSMENT_DATE, p_PSE_CALCS.STATEMENT_TYPE_ID,
			p_PSE_CALCS.PSE_ID, p_PSE_TYPE, p_CREDIT_MARKET, p_PSE_CALCS.UNDEFINED_PERIOD_BEGIN_DATE, p_PSE_CALCS.UNDEFINED_PERIOD_END_DATE,
			p_PSE_CALCS.CAPACITY_ADJUSTMENT_FACTOR, p_CURRENCY_CALCS, p_TIME_ZONE, p_EXCHANGE_RATE);

		SELECT SUM(FORECAST_VOLUME * NVL(CAPACITY_ADJ_FACTOR,1) * ASSESSMENT_PRICE * NVL((1+VAT_RATE),1))
		INTO v_UNDEF
		FROM SEM_CREDIT_DAILY_UNDEF_ADJ
		WHERE ASSESSMENT_DATE = p_ASSESSMENT_DATE
			AND STATEMENT_TYPE_ID = p_PSE_CALCS.STATEMENT_TYPE_ID
			AND PSE_ID = p_PSE_CALCS.PSE_ID
			AND CREDIT_MARKET = p_CREDIT_MARKET;

		--Update the PSE Calcs with the details.
		UPDATE SEM_CREDIT_CALC_PSE
		SET CREDIT_ASSESSMENT_VOLUME = v_CREDIT_VOLUME
		WHERE ASSESSMENT_DATE = p_ASSESSMENT_DATE
			AND STATEMENT_TYPE_ID = p_PSE_CALCS.STATEMENT_TYPE_ID
			AND PSE_ID = p_PSE_CALCS.PSE_ID
			AND CREDIT_MARKET = p_PSE_CALCS.CREDIT_MARKET;
	END IF;

	RETURN v_UNDEF;

END GET_PSE_UNDEFINED_EXPOSURE;
-----------------------------------------------------------------------------------------------------------------
FUNCTION GET_PSE_CURRENCY
	(
	p_PSE_ID IN NUMBER,
	p_ASSESSMENT_DATE IN DATE
	) RETURN VARCHAR2 IS
	v_CURRENCY VARCHAR2(8);
BEGIN

	--PSE Currency is now attached to the Participant PSE.
	v_CURRENCY := NVL(RO.GET_ENTITY_ATTRIBUTE('Currency', EC.ED_PSE, p_PSE_ID, p_ASSESSMENT_DATE), c_CURRENCY_EURO);
	RETURN v_CURRENCY;

END GET_PSE_CURRENCY;
-----------------------------------------------------------------------------------------------------------------
FUNCTION GET_PARTY_CURRENCY
	(
	p_ENTITY_GROUP_ID IN NUMBER,
	p_ASSESSMENT_DATE IN DATE
	) RETURN VARCHAR2 IS
	v_CURRENCY VARCHAR2(8);
BEGIN

	v_CURRENCY := NVL(RO.GET_ENTITY_ATTRIBUTE(c_ATTR_PARTY_CURRENCY, EC.ED_ENTITY_GROUP, p_ENTITY_GROUP_ID, p_ASSESSMENT_DATE), c_CURRENCY_EURO);
	RETURN v_CURRENCY;

END GET_PARTY_CURRENCY;
-----------------------------------------------------------------------------------------------------------------
PROCEDURE GET_PRICE_STATISTICS
	(
	p_MARKET_PRICE_ID IN NUMBER,
	p_BEGIN_DAY IN DATE,
	p_END_DAY IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_AVERAGE_PRICE OUT NUMBER,
	p_STD_DEV_PRICE OUT NUMBER
	) AS

	v_BEGIN_DATE DATE;
	v_END_DATE DATE;
BEGIN

	UT.CUT_DATE_RANGE(1, p_BEGIN_DAY, p_END_DAY, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

    SELECT AVG(PRICE), STDDEV(PRICE)
	INTO p_AVERAGE_PRICE, p_STD_DEV_PRICE
	FROM MARKET_PRICE_VALUE A
	WHERE MARKET_PRICE_ID = p_MARKET_PRICE_ID
	    AND PRICE_CODE IN ('F','P','A')
		AND PRICE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
        AND PRICE_CODE =
        	(SELECT DECODE(MAX(DECODE(PRICE_CODE,'F',1,'P',2,'A',3)),1,'F',2,'P',3,'A')
        	FROM MARKET_PRICE_VALUE
            WHERE MARKET_PRICE_ID = A.MARKET_PRICE_ID
            	AND PRICE_CODE IN ('F','P','A')
                AND PRICE_DATE = A.PRICE_DATE)
		AND AS_OF_DATE = c_LOW_DATE;

END GET_PRICE_STATISTICS;
-----------------------------------------------------------------------------------------------------------------
PROCEDURE GET_SETTLEMENT_CALENDAR_DATA
	(
	p_ASSESSMENT_DATE IN DATE,
	p_CREDIT_MARKET IN VARCHAR2,
	p_LAST_INVOICE_RECV_DATE OUT DATE,
	p_LAST_INVOICE_END_DATE OUT DATE,
	p_NOT_INVOICED_END_DATE OUT DATE,
	p_ACTUAL_PERIOD_END_DATE OUT DATE
	) AS
	v_MARKET VARCHAR2(16) := CASE p_CREDIT_MARKET WHEN c_MARKET_EN THEN MM_SEM_SETTLEMENT_CALENDAR.c_MARKET_ENERGY ELSE MM_SEM_SETTLEMENT_CALENDAR.c_MARKET_CAPACITY END;
BEGIN

	-- Determine the most recent Invoice Receipt and End Date.
	-- Since we are looking for the MAX, we can use END_DATE
	SELECT MAX(C.PUBLICATION_DATE), MAX(C.END_DATE)
	INTO p_LAST_INVOICE_RECV_DATE, p_LAST_INVOICE_END_DATE
	FROM SEM_SETTLEMENT_CALENDAR C
	WHERE C.PUBLICATION_TYPE = MM_SEM_SETTLEMENT_CALENDAR.c_PUBLICATION_TYPE_INVOICE
	  AND C.MARKET = v_MARKET
	  AND C.RUN_IDENTIFIER = 'F'
	  AND C.PUBLICATION_DATE <= p_ASSESSMENT_DATE;

	--Determined the Settled Not Invoiced End Date
	SELECT MAX(C.END_DATE)
	INTO p_NOT_INVOICED_END_DATE
	FROM SEM_SETTLEMENT_CALENDAR C
	WHERE C.PUBLICATION_TYPE = MM_SEM_SETTLEMENT_CALENDAR.c_PUBLICATION_TYPE_REPORT
	  AND C.MARKET = v_MARKET
	  AND C.RUN_IDENTIFIER IN ('P','F')
	  --NOTE:  This < sign was changed from <= since it seems the SMO has not calc'd the statements before the credit cover.
	  AND C.PUBLICATION_DATE < p_ASSESSMENT_DATE
	  -- Since we are looking for the MAX, we can use END_DATE
	  AND C.END_DATE >= NVL(p_LAST_INVOICE_END_DATE, c_MARKET_START_DAY);

	--The end of the Actual Exposure Period is either the end of the last available statement, or the end of the last available invoice.
	p_ACTUAL_PERIOD_END_DATE := COALESCE(p_NOT_INVOICED_END_DATE, p_LAST_INVOICE_END_DATE);

END GET_SETTLEMENT_CALENDAR_DATA;
-----------------------------------------------------------------------------------------------------------------
PROCEDURE GET_HIST_ASSESSMENT_PERIOD
	(
	p_ASSESSMENT_DATE IN DATE,
	p_CREDIT_MARKET IN VARCHAR2,
	p_NUMBER_OF_DAYS OUT NUMBER,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE
	) AS
-- This proc figures out the historical assessment period for a Credit Market and returns it.
-- There was a circular dependency on when this was needed, so I broke it out into its own procedure
-- in order to simplify the logic a bit.
	DUMMY DATE;
	v_ACTUAL_PERIOD_END_DATE DATE;
BEGIN

	SELECT CASE p_CREDIT_MARKET WHEN c_MARKET_EN THEN A.HIST_ASSESSMENT_PERIOD_EN ELSE A.HIST_ASSESSMENT_PERIOD_CA END
	INTO p_NUMBER_OF_DAYS
	FROM SEM_CREDIT_INPUT_YEARLY A
	WHERE p_ASSESSMENT_DATE BETWEEN A.BEGIN_DATE AND NVL(A.END_DATE, p_ASSESSMENT_DATE);

	--Get the end of the actual period from the Settlement Calendar.
	GET_SETTLEMENT_CALENDAR_DATA(p_ASSESSMENT_DATE, p_CREDIT_MARKET, DUMMY, DUMMY, DUMMY, v_ACTUAL_PERIOD_END_DATE);

	p_BEGIN_DATE := v_ACTUAL_PERIOD_END_DATE - p_NUMBER_OF_DAYS + 1;
	p_END_DATE := v_ACTUAL_PERIOD_END_DATE;

END GET_HIST_ASSESSMENT_PERIOD;
-----------------------------------------------------------------------------------------------------------------
PROCEDURE SET_DATE_RANGES
	(
	p_PSE_ID IN NUMBER,
	p_ASSESSMENT_DATE IN DATE,
	p_CREDIT_MARKET IN VARCHAR2,
	p_PSE_TYPE IN VARCHAR2,
	p_SEM_CREDIT_CALC_PSE IN OUT SEM_CREDIT_CALC_PSE%ROWTYPE
	) AS

v_LAST_INVOICE_END_DATE DATE;
v_LAST_INVOICE_RECV_DATE DATE;
v_INVOICE_PAID_ON DATE;
v_ACTUAL_PERIOD_END_DATE DATE;
v_NUM_DAYS BINARY_INTEGER;
v_DAY_TYPE VARCHAR2(2);
v_SC_ID NUMBER(9) := MM_SEM_UTIL.SEM_SC_ID;
BEGIN
	-- Determine and store the ranges of the Not Paid, Not Invoiced, and HAP Periods for Energy and Capacity
	-- via lookups to the Settlement Calendar table.

	--Do the lookups into the Settlement Calendar
	GET_SETTLEMENT_CALENDAR_DATA(p_ASSESSMENT_DATE, p_CREDIT_MARKET, v_LAST_INVOICE_RECV_DATE, v_LAST_INVOICE_END_DATE,
		p_SEM_CREDIT_CALC_PSE.NOT_INVOICED_END_DATE, v_ACTUAL_PERIOD_END_DATE);

	-- Determine whether we have already paid the invoices.
	-- If not, the Last Invoice range is the Not Paid period; otherwise, there is no Not Paid period.
	p_SEM_CREDIT_CALC_PSE.DAYS_TO_PAY_INVOICE := NVL(RO.GET_ENTITY_ATTRIBUTE(c_ATTR_DAYS_TO_PAY_INVOICE, EC.ED_PSE, p_PSE_ID, p_ASSESSMENT_DATE),3);

	v_INVOICE_PAID_ON := ADD_DAYS(v_LAST_INVOICE_RECV_DATE, p_SEM_CREDIT_CALC_PSE.DAYS_TO_PAY_INVOICE, 'WD');
	IF v_INVOICE_PAID_ON <= p_ASSESSMENT_DATE THEN
		p_SEM_CREDIT_CALC_PSE.NOT_PAID_BEGIN_DATE := NULL;
		p_SEM_CREDIT_CALC_PSE.NOT_PAID_END_DATE := NULL;
	ELSE
		p_SEM_CREDIT_CALC_PSE.NOT_PAID_BEGIN_DATE := GREATEST(CASE p_CREDIT_MARKET WHEN c_MARKET_EN THEN v_LAST_INVOICE_END_DATE - 6 ELSE TRUNC(v_LAST_INVOICE_END_DATE, 'MM') END, c_MARKET_START_DAY);
		p_SEM_CREDIT_CALC_PSE.NOT_PAID_END_DATE := v_LAST_INVOICE_END_DATE;
	END IF;

	-- Determine the Settlement Not Invoiced Period.
	IF p_SEM_CREDIT_CALC_PSE.NOT_INVOICED_END_DATE IS NULL THEN
		p_SEM_CREDIT_CALC_PSE.NOT_INVOICED_BEGIN_DATE := NULL;
	ELSE
		p_SEM_CREDIT_CALC_PSE.NOT_INVOICED_BEGIN_DATE := NVL(v_LAST_INVOICE_END_DATE + 1, c_MARKET_START_DAY);
	END IF;

	-- Determine the Undefined Period begin date.
	p_SEM_CREDIT_CALC_PSE.UNDEFINED_PERIOD_BEGIN_DATE := NVL(v_ACTUAL_PERIOD_END_DATE + 1, c_MARKET_START_DAY);

	-- Add in the Suspension Period to find the Undefined Period end date.
	v_NUM_DAYS := NVL(RO.GET_ENTITY_ATTRIBUTE(
		CASE p_PSE_TYPE WHEN MM_SEM_UTIL.g_PSE_TYPE_SUPPLIER_UNITS
		THEN c_ATTR_SUP_SUSP_PERIOD ELSE c_ATTR_GEN_SUSP_PERIOD END, EC.ED_SC, v_SC_ID, p_ASSESSMENT_DATE),0);
	v_DAY_TYPE := NVL(RO.GET_ENTITY_ATTRIBUTE(
		CASE p_PSE_TYPE WHEN MM_SEM_UTIL.g_PSE_TYPE_SUPPLIER_UNITS
		THEN c_ATTR_SUP_SUSP_PERIOD_TYPE ELSE c_ATTR_GEN_SUSP_PERIOD_TYPE END, EC.ED_SC, v_SC_ID, p_ASSESSMENT_DATE),'CD');
	p_SEM_CREDIT_CALC_PSE.UNDEFINED_PERIOD_END_DATE := ADD_DAYS(p_ASSESSMENT_DATE, v_NUM_DAYS, v_DAY_TYPE);

	p_SEM_CREDIT_CALC_PSE.UNDEFINED_PERIOD := p_SEM_CREDIT_CALC_PSE.UNDEFINED_PERIOD_END_DATE - p_SEM_CREDIT_CALC_PSE.UNDEFINED_PERIOD_BEGIN_DATE + 1;

	-- Determine the Historical Assessment Period
	GET_HIST_ASSESSMENT_PERIOD(p_ASSESSMENT_DATE, p_CREDIT_MARKET, p_SEM_CREDIT_CALC_PSE.HIST_ASSESSMENT_PERIOD, p_SEM_CREDIT_CALC_PSE.HIST_ASSESSMENT_BEGIN_DATE, p_SEM_CREDIT_CALC_PSE.HIST_ASSESSMENT_END_DATE);

END SET_DATE_RANGES;
-----------------------------------------------------------------------------------------------------------------
PROCEDURE GET_CALCS_FOR_PSE
	(
	p_PSE_ID IN NUMBER,
	p_PSE_TYPE IN VARCHAR2,
	p_ASSESSMENT_DATE IN DATE,
	p_STATEMENT_TYPE_ID IN NUMBER,
	p_CURRENCY_CALCS IN SEM_CREDIT_CALC_CURRENCY%ROWTYPE,
	p_EN_PSE_CALCS OUT SEM_CREDIT_CALC_PSE%ROWTYPE,
	p_CA_PSE_CALCS OUT SEM_CREDIT_CALC_PSE%ROWTYPE
	) AS

v_EN_NUM_DAYS_UNDEF BINARY_INTEGER;
v_CA_NUM_DAYS_UNDEF BINARY_INTEGER;
v_CAPACITY_ADJUSTMENT_FACTOR SEM_CREDIT_CALC_PSE.CAPACITY_ADJUSTMENT_FACTOR%TYPE;
BEGIN

	-- First fill the key fields into the row.
	p_EN_PSE_CALCS.ASSESSMENT_DATE := p_ASSESSMENT_DATE;
	p_EN_PSE_CALCS.STATEMENT_TYPE_ID := p_STATEMENT_TYPE_ID;
	p_EN_PSE_CALCS.PSE_ID := p_PSE_ID;
	p_EN_PSE_CALCS.CREDIT_MARKET := c_MARKET_EN;
	p_CA_PSE_CALCS.ASSESSMENT_DATE := p_ASSESSMENT_DATE;
	p_CA_PSE_CALCS.STATEMENT_TYPE_ID := p_STATEMENT_TYPE_ID;
	p_CA_PSE_CALCS.PSE_ID := p_PSE_ID;
	p_CA_PSE_CALCS.CREDIT_MARKET := c_MARKET_CA;

	-- Next fill in all the dates
	SET_DATE_RANGES(p_PSE_ID, p_ASSESSMENT_DATE, c_MARKET_EN, p_PSE_TYPE, p_EN_PSE_CALCS);
	SET_DATE_RANGES(p_PSE_ID, p_ASSESSMENT_DATE, c_MARKET_CA, p_PSE_TYPE, p_CA_PSE_CALCS);

	v_EN_NUM_DAYS_UNDEF := p_EN_PSE_CALCS.UNDEFINED_PERIOD_END_DATE - p_EN_PSE_CALCS.UNDEFINED_PERIOD_BEGIN_DATE + 1;
	v_CA_NUM_DAYS_UNDEF := p_CA_PSE_CALCS.UNDEFINED_PERIOD_END_DATE - p_CA_PSE_CALCS.UNDEFINED_PERIOD_BEGIN_DATE + 1;

	-- Determine the Capacity Adjustment Factor.
	IF p_ASSESSMENT_DATE >= c_YEAR_AFTER_MARKET_START THEN
		--This adjustment factor is not used after the first year.
		v_CAPACITY_ADJUSTMENT_FACTOR := NULL;
	ELSE
		v_CAPACITY_ADJUSTMENT_FACTOR :=
			((p_CURRENCY_CALCS.CREDIT_ASSESSMENT_PRICE * v_EN_NUM_DAYS_UNDEF)
				+ (p_CURRENCY_CALCS.ESTIMATED_CAPACITY_PRICE * v_CA_NUM_DAYS_UNDEF))
			/ (p_CURRENCY_CALCS.CREDIT_ASSESSMENT_PRICE * v_EN_NUM_DAYS_UNDEF);
	END IF;

	p_EN_PSE_CALCS.CAPACITY_ADJUSTMENT_FACTOR := v_CAPACITY_ADJUSTMENT_FACTOR;
	p_CA_PSE_CALCS.CAPACITY_ADJUSTMENT_FACTOR := v_CAPACITY_ADJUSTMENT_FACTOR;

	p_EN_PSE_CALCS.PSE_TYPE := p_PSE_TYPE;
	p_CA_PSE_CALCS.PSE_TYPE := p_PSE_TYPE;

END GET_CALCS_FOR_PSE;
-----------------------------------------------------------------------------------------------------------------
FUNCTION GET_CALCS_FOR_CURRENCY
	(
	p_ASSESSMENT_DATE IN DATE,
	p_STATEMENT_TYPE_ID IN NUMBER,
	p_CURRENCY IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2
	) RETURN SEM_CREDIT_CALC_CURRENCY%ROWTYPE IS

v_CURRENCY_CALCS SEM_CREDIT_CALC_CURRENCY%ROWTYPE;
v_NUM_DAYS NUMBER;
v_MARKET_PRICE_ID NUMBER(9);
v_EN_HAP_BEGIN_DATE DATE;
v_EN_HAP_END_DATE DATE;
v_CA_HAP_BEGIN_DATE DATE;
v_CA_HAP_END_DATE DATE;
v_SC_ID NUMBER(9) := MM_SEM_UTIL.SEM_SC_ID;
BEGIN

	v_CURRENCY_CALCS.ASSESSMENT_DATE := p_ASSESSMENT_DATE;
	v_CURRENCY_CALCS.STATEMENT_TYPE_ID := p_STATEMENT_TYPE_ID;
	v_CURRENCY_CALCS.CURRENCY := p_CURRENCY;

	--Determine the Historical Assessment Periods.
	GET_HIST_ASSESSMENT_PERIOD(p_ASSESSMENT_DATE, c_MARKET_EN, v_NUM_DAYS, v_EN_HAP_BEGIN_DATE, v_EN_HAP_END_DATE);
	GET_HIST_ASSESSMENT_PERIOD(p_ASSESSMENT_DATE, c_MARKET_CA, v_NUM_DAYS, v_CA_HAP_BEGIN_DATE, v_CA_HAP_END_DATE);

	--Get the Analysis Percentile Parameter for the Year of the Assessment Date.
	SELECT A.ANALYSIS_PERCENTILE_PARAM
	INTO v_CURRENCY_CALCS.ANALYSIS_PERCENTILE_PARAM
	FROM SEM_CREDIT_INPUT_YEARLY A
	WHERE p_ASSESSMENT_DATE BETWEEN A.BEGIN_DATE AND NVL(A.END_DATE, p_ASSESSMENT_DATE);

	--Get the MAX VMOP and Imperfections Price for the EN HAP.
	SELECT MAX(A.VAR_MO_PRICE), MAX(A.IMPERFECTIONS_PRICE)
	INTO v_CURRENCY_CALCS.VAR_MO_PRICE, v_CURRENCY_CALCS.IMPERFECTIONS_PRICE
	FROM SEM_CREDIT_INPUT_YEARLY A
	WHERE v_EN_HAP_BEGIN_DATE <= NVL(A.END_DATE, p_ASSESSMENT_DATE)
		AND v_EN_HAP_END_DATE >= A.BEGIN_DATE;

	--Get the SMP for this Currency.
	IF p_CURRENCY = c_CURRENCY_EURO THEN
		v_MARKET_PRICE_ID := MM_SEM_UTIL.GET_MARKET_PRICE_ID('System Marginal Price Euro', 'Commodity Price', '30 Minute', FALSE);
	ELSE
		v_MARKET_PRICE_ID := MM_SEM_UTIL.GET_MARKET_PRICE_ID('System Marginal Price Pound', 'Commodity Price', '30 Minute', FALSE);
	END IF;
	GET_PRICE_STATISTICS(v_MARKET_PRICE_ID, v_EN_HAP_BEGIN_DATE, v_EN_HAP_END_DATE, p_TIME_ZONE, v_CURRENCY_CALCS.AVERAGE_SMP, v_CURRENCY_CALCS.STD_DEVIATION_SMP);

	--Get the CPDP.  There is only one CPDP.
	--ASSUME: It is okay to leave the CPDP blank for Pounds since we will not be using it anyways.
	IF p_CURRENCY = c_CURRENCY_EURO THEN
		v_MARKET_PRICE_ID := MM_SEM_UTIL.GET_MARKET_PRICE_ID('Capacity Payments Demand Price', 'Commodity Price', '30 Minute', FALSE);
		GET_PRICE_STATISTICS(v_MARKET_PRICE_ID, v_EN_HAP_BEGIN_DATE, v_EN_HAP_END_DATE, p_TIME_ZONE, v_CURRENCY_CALCS.AVERAGE_CPDP, v_CURRENCY_CALCS.STD_DEVIATION_CPDP);
	END IF;

	--Look to see if there are initial prices defined.
	v_CURRENCY_CALCS.CREDIT_ASSESSMENT_PRICE := RO.GET_ENTITY_ATTRIBUTE(c_ATTR_INITIAL_ENERGY_PRICE, EC.ED_SC, v_SC_ID, p_ASSESSMENT_DATE);
	v_CURRENCY_CALCS.ESTIMATED_CAPACITY_PRICE := RO.GET_ENTITY_ATTRIBUTE(c_ATTR_INITIAL_CAP_PRICE, EC.ED_SC, v_SC_ID, p_ASSESSMENT_DATE);

	--If they are no longer defined, then calculate them from the data available.
	IF v_CURRENCY_CALCS.CREDIT_ASSESSMENT_PRICE IS NULL THEN
		v_CURRENCY_CALCS.CREDIT_ASSESSMENT_PRICE := v_CURRENCY_CALCS.AVERAGE_SMP +
				(v_CURRENCY_CALCS.ANALYSIS_PERCENTILE_PARAM * v_CURRENCY_CALCS.STD_DEVIATION_SMP) +
				v_CURRENCY_CALCS.VAR_MO_PRICE +
				v_CURRENCY_CALCS.IMPERFECTIONS_PRICE;
	END IF;

	IF v_CURRENCY_CALCS.ESTIMATED_CAPACITY_PRICE IS NULL THEN
		v_CURRENCY_CALCS.ESTIMATED_CAPACITY_PRICE := v_CURRENCY_CALCS.AVERAGE_CPDP +
				(v_CURRENCY_CALCS.ANALYSIS_PERCENTILE_PARAM * v_CURRENCY_CALCS.STD_DEVIATION_CPDP);
	END IF;

	RETURN v_CURRENCY_CALCS;

END GET_CALCS_FOR_CURRENCY;
-----------------------------------------------------------------------------------------------------------------
FUNCTION GET_TOTALS_FOR_PSE_MARKET
	(
	p_PSE_ID IN NUMBER,
	p_PSE_STATUS IN VARCHAR2,
	p_PSE_TYPE IN VARCHAR2,
	p_ENTITY_GROUP_ID IN NUMBER,
	p_CREDIT_MARKET IN VARCHAR2,
	p_FROM_CURRENCY IN VARCHAR2,
	p_ASSESSMENT_DATE IN DATE,
	p_STATEMENT_TYPE_ID IN NUMBER,
	p_PSE_CALCS IN SEM_CREDIT_CALC_PSE%ROWTYPE,
	p_CURRENCY_CALCS IN SEM_CREDIT_CALC_CURRENCY%ROWTYPE,
	p_TIME_ZONE IN VARCHAR2
	) RETURN SEM_CREDIT_RESULT%ROWTYPE IS

	v_PSE_RESULT SEM_CREDIT_RESULT%ROWTYPE;
	v_EXCHANGE_RATE NUMBER;
	v_FIXED_EXCHANGE_RATE NUMBER;
BEGIN

	v_PSE_RESULT.ASSESSMENT_DATE := p_ASSESSMENT_DATE;
	v_PSE_RESULT.STATEMENT_TYPE_ID := p_STATEMENT_TYPE_ID;
	v_PSE_RESULT.PSE_ID := p_PSE_ID;
	v_PSE_RESULT.STATEMENT_STATE := GA.INTERNAL_STATE;
	v_PSE_RESULT.CREDIT_MARKET := p_CREDIT_MARKET;
	v_PSE_RESULT.ENTITY_GROUP_ID := p_ENTITY_GROUP_ID;

	--Get the Exchange Rate so we can store results in Native Currency of Party.
	v_PSE_RESULT.CURRENCY := GET_PARTY_CURRENCY(p_ENTITY_GROUP_ID, p_ASSESSMENT_DATE);
	IF v_PSE_RESULT.CURRENCY = c_CURRENCY_EURO THEN
		v_EXCHANGE_RATE := 1;
		v_FIXED_EXCHANGE_RATE := 1;
	ELSE
		v_EXCHANGE_RATE := GET_EUR_TO_GBP_EXCH_RATE(p_CREDIT_MARKET, p_ASSESSMENT_DATE);
		IF p_CREDIT_MARKET = c_MARKET_EN THEN
			--The Exchange Rate for the Fixed Contribution is always the Annual Capacity rate.
			v_FIXED_EXCHANGE_RATE := GET_EUR_TO_GBP_EXCH_RATE(c_MARKET_CA, p_ASSESSMENT_DATE);
		ELSE
			v_FIXED_EXCHANGE_RATE := v_EXCHANGE_RATE;
		END IF;
	END IF;

	-- Determine Participant Status, and Currency
	v_PSE_RESULT.PARTICIPANT_STATUS := NVL(RO.GET_ENTITY_ATTRIBUTE(c_ATTR_PSE_STATUS, EC.ED_PSE, p_PSE_ID, p_ASSESSMENT_DATE), c_CREDIT_STATUS_NEW);
	v_PSE_RESULT.PSE_TYPE := p_PSE_TYPE;

	--BZ16299 - do not apply the Exchange Rate for Invoiced not Paid and Settl not Invoiced
	-- Calculate Data for Actual Period
	v_PSE_RESULT.INVOICES_NOT_PAID := GET_PSE_INVOICES_NOT_PAID(p_ASSESSMENT_DATE, p_PSE_ID,
		p_PSE_CALCS.NOT_PAID_BEGIN_DATE, p_PSE_CALCS.NOT_PAID_END_DATE, p_CREDIT_MARKET,
		p_FROM_CURRENCY, p_STATEMENT_TYPE_ID);

	v_PSE_RESULT.SETTLEMENT_NOT_INVOICED := GET_PSE_STMT_NOT_INVOICED(p_ASSESSMENT_DATE, p_PSE_ID,
		p_PSE_CALCS.NOT_INVOICED_BEGIN_DATE, p_PSE_CALCS.NOT_INVOICED_END_DATE, p_CREDIT_MARKET,
		p_FROM_CURRENCY, p_STATEMENT_TYPE_ID);

	--BZ 17093- Undefined Exposure calculations should be performed in GBP
	--Do not apply the Daily Exchange Rate
	--These calculations need to be in the native currency of the Participant

	v_PSE_RESULT.UNDEFINED_EXPOSURE := NVL(GET_PSE_UNDEFINED_EXPOSURE(p_PSE_STATUS, p_PSE_TYPE,
		p_ASSESSMENT_DATE, p_CREDIT_MARKET, p_FROM_CURRENCY, p_PSE_CALCS, p_CURRENCY_CALCS, p_TIME_ZONE, v_EXCHANGE_RATE),0);

	GET_PSE_SRAS(p_ASSESSMENT_DATE, p_STATEMENT_TYPE_ID, p_PSE_ID, NVL(p_PSE_CALCS.NOT_INVOICED_BEGIN_DATE, p_PSE_CALCS.UNDEFINED_PERIOD_BEGIN_DATE),
		p_PSE_CALCS.UNDEFINED_PERIOD_END_DATE, p_CREDIT_MARKET, c_CATEGORY_SRA, v_PSE_RESULT.SRAS_TOTAL, v_PSE_RESULT.SRAS_SUBMITTED);

	v_PSE_RESULT.SRAS_TOTAL := v_PSE_RESULT.SRAS_TOTAL;
	v_PSE_RESULT.SRAS_SUBMITTED := v_PSE_RESULT.SRAS_SUBMITTED;

	-- Calculate Remaining Pieces
	v_PSE_RESULT.FIXED_CREDIT_REQT := GET_PSE_FIXED_CREDIT_REQT(p_PSE_ID, p_PSE_TYPE, p_ASSESSMENT_DATE, p_CREDIT_MARKET) * v_FIXED_EXCHANGE_RATE;

	-- Calculate total Required Credit Cover.
	v_PSE_RESULT.REQD_CREDIT_COVER := GREATEST(0,
		v_PSE_RESULT.INVOICES_NOT_PAID
		+ v_PSE_RESULT.SETTLEMENT_NOT_INVOICED
		+ v_PSE_RESULT.UNDEFINED_EXPOSURE
		+ v_PSE_RESULT.SRAS_SUBMITTED); --Note it does not include fixed.  That gets added in at the party level.

  -- traded amount
  v_PSE_RESULT.INTCONN_TRADED_AMT := GET_PSE_TRADED_AMT(p_ASSESSMENT_DATE, p_PSE_ID, p_CREDIT_MARKET);

	v_PSE_RESULT.CALCULATED_DATE := SYSDATE;

	RETURN v_PSE_RESULT;

END GET_TOTALS_FOR_PSE_MARKET;
-----------------------------------------------------------------------------------------------------------------
FUNCTION GET_GATE_WINDOW_NAMES
RETURN STRING_COLLECTION
IS
  v_GATE_WINDOWS STRING_COLLECTION;
BEGIN
  SELECT A.EXTERNAL_IDENTIFIER
  BULK COLLECT INTO v_GATE_WINDOWS
  FROM EXTERNAL_SYSTEM_IDENTIFIER A,
       STATEMENT_TYPE             ST
  WHERE A.ENTITY_DOMAIN_ID = EC.ED_STATEMENT_TYPE
  AND A.IDENTIFIER_TYPE = 'Gate Window'
  AND A.ENTITY_ID = ST.STATEMENT_TYPE_ID
  ORDER BY ST.STATEMENT_TYPE_ORDER DESC;

  RETURN v_GATE_WINDOWS;
END GET_GATE_WINDOW_NAMES;
-----------------------------------------------------------------------------------------------------------------
FUNCTION GET_MSP_RUN_TYPE_NAMES
RETURN STRING_COLLECTION
IS
  v_MSP_RUN_TYPES STRING_COLLECTION;
BEGIN
  SELECT A.EXTERNAL_IDENTIFIER
  BULK COLLECT INTO v_MSP_RUN_TYPES
  FROM EXTERNAL_SYSTEM_IDENTIFIER A,
       STATEMENT_TYPE             ST
  WHERE A.ENTITY_DOMAIN_ID = EC.ED_STATEMENT_TYPE
  AND A.IDENTIFIER_TYPE = 'Run Type'
  AND A.ENTITY_ID = ST.STATEMENT_TYPE_ID
  ORDER BY ST.STATEMENT_TYPE_ORDER DESC;

  RETURN v_MSP_RUN_TYPES;
END GET_MSP_RUN_TYPE_NAMES;
-----------------------------------------------------------------------------------------------------------------
PROCEDURE GET_IDT_DATE_RANGE
(
  p_RUN_TYPE      IN VARCHAR2,
  p_ASSESSMENT_DATE  IN DATE,
  p_GATE_CUT_BEGIN_DATE  OUT DATE,
  p_GATE_CUT_END_DATE   OUT DATE
)IS
  v_VALID_RUN_TYPES STRING_COLLECTION := GET_MSP_RUN_TYPE_NAMES;
  v_BEGIN_TIME_STRING  VARCHAR2(32);
  v_END_TIME_STRING  VARCHAR2(32);
  v_OFFSET_STRING    VARCHAR2(32);
BEGIN
  -- Verify if the incoming RUN_TYPE is valid
  ASSERT(UT.STRING_COLLECTION_CONTAINS(v_VALID_RUN_TYPES, p_RUN_TYPE), 'Run Type value=' || p_RUN_TYPE || ' is invalid',
       MSGCODES.c_ERR_ARGUMENT);

  -- Get the actual system dictionary settings
  v_BEGIN_TIME_STRING := GET_DICTIONARY_VALUE('IDT_BEGIN_TIME', 0, 'MarketExchange', 'SEM', 'Intra Day Trading', p_RUN_TYPE);
  v_END_TIME_STRING   := GET_DICTIONARY_VALUE('IDT_END_TIME', 0, 'MarketExchange', 'SEM', 'Intra Day Trading', p_RUN_TYPE);
  v_OFFSET_STRING   := GET_DICTIONARY_VALUE('IDT_DATE_OFFSET', 0, 'MarketExchange', 'SEM', 'Intra Day Trading', p_RUN_TYPE);

  -- Return the date format -- If any error is raised here, let it bubble-up and be handled by the caller.
  /*
   TODO: owner="USREARU" category="Fix" priority="1 - High" created="5/8/2012"
   text="Should the error be handled here? Ask what BA's expectation is."
   */
   WITH SYS_DICT AS (SELECT CAST(TO_DATE(v_BEGIN_TIME_STRING, 'HH24:MI') AS TIMESTAMP) AS TS_BEGIN,
                  CAST(TO_DATE(v_END_TIME_STRING, 'HH24:MI') AS TIMESTAMP)   AS TS_END
              FROM DUAL)
  SELECT TO_CUT(TRUNC(p_ASSESSMENT_DATE) + TO_DSINTERVAL(v_OFFSET_STRING || ' 0:0:0') + TO_DSINTERVAL('0 ' ||
       EXTRACT(HOUR FROM SYS_DICT.TS_BEGIN) || ':' || EXTRACT(MINUTE FROM SYS_DICT.TS_BEGIN) || ':' ||
       EXTRACT(SECOND FROM SYS_DICT.TS_BEGIN)), GA.LOCAL_TIME_ZONE),
       TO_CUT(TRUNC(p_ASSESSMENT_DATE) + TO_DSINTERVAL(TO_NUMBER(v_OFFSET_STRING) + 1 || ' 0:0:0') + TO_DSINTERVAL('0 ' ||
       EXTRACT(HOUR FROM SYS_DICT.TS_END) || ':' || EXTRACT(MINUTE FROM SYS_DICT.TS_END) || ':' ||
       EXTRACT(SECOND FROM SYS_DICT.TS_END)), GA.LOCAL_TIME_ZONE)
  INTO p_GATE_CUT_BEGIN_DATE, p_GATE_CUT_END_DATE
  FROM SYS_DICT;
END GET_IDT_DATE_RANGE;
-----------------------------------------------------------------------------------------------------------------
FUNCTION GET_TOTALS_FOR_PARTY
	(
	p_ENTITY_GROUP_ID IN NUMBER,
	p_ASSESSMENT_DATE IN DATE,
	p_STATEMENT_TYPE_ID IN NUMBER
	) RETURN SEM_CREDIT_RESULT%ROWTYPE IS

v_PARTY_RESULT SEM_CREDIT_RESULT%ROWTYPE;
BEGIN

	v_PARTY_RESULT.ASSESSMENT_DATE := p_ASSESSMENT_DATE;
	v_PARTY_RESULT.STATEMENT_TYPE_ID := p_STATEMENT_TYPE_ID;
	v_PARTY_RESULT.ENTITY_GROUP_ID := p_ENTITY_GROUP_ID;
	v_PARTY_RESULT.PSE_ID := c_NOT_ASSIGNED;
	v_PARTY_RESULT.CREDIT_MARKET := c_MARKET_SEM;
	v_PARTY_RESULT.STATEMENT_STATE := GA.INTERNAL_STATE;

	--ASSUME: Status is really by Participant and this can be null.
	v_PARTY_RESULT.PARTICIPANT_STATUS := NULL;
	v_PARTY_RESULT.CURRENCY := GET_PARTY_CURRENCY(p_ENTITY_GROUP_ID, p_ASSESSMENT_DATE);
	v_PARTY_RESULT.PSE_TYPE := NULL;

	BEGIN
		--Leave Posted Credit Cover in its party's native currency.
		SELECT POSTED_CREDIT_COVER
		INTO v_PARTY_RESULT.POSTED_CREDIT_COVER
		FROM SEM_CREDIT_INPUT_ENTITY_GROUP A
		WHERE A.ASSESSMENT_DAY = p_ASSESSMENT_DATE
			AND A.ENTITY_GROUP_ID = p_ENTITY_GROUP_ID;
	EXCEPTION
		WHEN OTHERS THEN
			v_PARTY_RESULT.POSTED_CREDIT_COVER := NULL;
	END;

	v_PARTY_RESULT.WARNING_LIMIT := RO.GET_ENTITY_ATTRIBUTE(c_ATTR_WARNING_LIMIT, EC.ED_ENTITY_GROUP, p_ENTITY_GROUP_ID, p_ASSESSMENT_DATE);
	v_PARTY_RESULT.CALCULATED_DATE := SYSDATE;

	SELECT SUM(GREATEST(INVOICES_NOT_PAID, 0)),
		SUM(GREATEST(SETTLEMENT_NOT_INVOICED, 0)),
		SUM(GREATEST(UNDEFINED_EXPOSURE, 0)),
		SUM(FIXED_CREDIT_REQT),
		SUM(GREATEST(SRAS_TOTAL, 0)),
		SUM(GREATEST(SRAS_SUBMITTED, 0)),
    SUM(INTCONN_TRADED_AMT)
	INTO v_PARTY_RESULT.INVOICES_NOT_PAID,
		v_PARTY_RESULT.SETTLEMENT_NOT_INVOICED,
		v_PARTY_RESULT.UNDEFINED_EXPOSURE,
		v_PARTY_RESULT.FIXED_CREDIT_REQT,
		v_PARTY_RESULT.SRAS_TOTAL,
		v_PARTY_RESULT.SRAS_SUBMITTED,
    v_PARTY_RESULT.INTCONN_TRADED_AMT
	FROM SEM_CREDIT_RESULT
	WHERE ASSESSMENT_DATE = p_ASSESSMENT_DATE
		AND STATEMENT_TYPE_ID = p_STATEMENT_TYPE_ID
		AND ENTITY_GROUP_ID = p_ENTITY_GROUP_ID
		AND PSE_ID <> c_NOT_ASSIGNED
		AND STATEMENT_STATE = GA.INTERNAL_STATE;

	SELECT GROSS_CC + v_PARTY_RESULT.FIXED_CREDIT_REQT,
		NET_CC_SUBMITTED_SRAS + v_PARTY_RESULT.FIXED_CREDIT_REQT,
		NET_CC_ALL_SRAS + v_PARTY_RESULT.FIXED_CREDIT_REQT
	INTO v_PARTY_RESULT.GROSS_CC,
		v_PARTY_RESULT.REQD_CREDIT_COVER,
		v_PARTY_RESULT.NET_CC_ALL_SRAS
	FROM (SELECT GREATEST(0, SUM(INVOICES_NOT_PAID + SETTLEMENT_NOT_INVOICED + UNDEFINED_EXPOSURE)) "GROSS_CC",
			    GREATEST(0, SUM(INVOICES_NOT_PAID + SETTLEMENT_NOT_INVOICED + UNDEFINED_EXPOSURE + SRAS_SUBMITTED)) "NET_CC_SUBMITTED_SRAS",
			    GREATEST(0, SUM(INVOICES_NOT_PAID + SETTLEMENT_NOT_INVOICED + UNDEFINED_EXPOSURE + SRAS_TOTAL)) "NET_CC_ALL_SRAS"
		  FROM SEM_CREDIT_RESULT
		  WHERE ASSESSMENT_DATE = p_ASSESSMENT_DATE
			AND STATEMENT_TYPE_ID = p_STATEMENT_TYPE_ID
			AND ENTITY_GROUP_ID = p_ENTITY_GROUP_ID
			AND PSE_ID <> c_NOT_ASSIGNED
			AND STATEMENT_STATE = GA.INTERNAL_STATE);

	v_PARTY_RESULT.BREACH_AMOUNT := GREATEST(0, v_PARTY_RESULT.REQD_CREDIT_COVER - v_PARTY_RESULT.POSTED_CREDIT_COVER);

	RETURN v_PARTY_RESULT;
END GET_TOTALS_FOR_PARTY;
-----------------------------------------------------------------------------------------------------------------
FUNCTION GET_FRW_START_DATE
    (
	p_ASSESSMENT_DATE IN DATE,
	p_CREDIT_MARKET IN VARCHAR2
	) RETURN DATE AS
	v_MARKET VARCHAR2(16) := CASE p_CREDIT_MARKET WHEN c_MARKET_EN THEN MM_SEM_SETTLEMENT_CALENDAR.c_MARKET_ENERGY ELSE MM_SEM_SETTLEMENT_CALENDAR.c_MARKET_CAPACITY END;
	v_LATEST_PUBLICATION_DATE DATE;
	v_FRW_START_DATE DATE;
BEGIN

    -- the Future Risk Window (FRW) starts at midnight on the day after the settlement date of the last initial statement
	SELECT MAX(C.PUBLICATION_DATE), TO_CUT(MAX(C.END_DATE)+1+30/1440, GA.LOCAL_TIME_ZONE)
	INTO v_LATEST_PUBLICATION_DATE, v_FRW_START_DATE
    FROM SEM_SETTLEMENT_CALENDAR C
    WHERE C.PUBLICATION_TYPE = MM_SEM_SETTLEMENT_CALENDAR.c_PUBLICATION_TYPE_REPORT
      AND C.MARKET = v_MARKET
      AND C.RUN_IDENTIFIER = MM_SEM_UTIL.g_EXTID_SETTLEMENT_F
      AND C.PUBLICATION_DATE <= p_ASSESSMENT_DATE;

	RETURN v_FRW_START_DATE;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
	    RETURN NULL;

END GET_FRW_START_DATE;
-----------------------------------------------------------------------------------------------------------------
FUNCTION GET_PSE_TRADED_AMT
  (
  p_ASSESSMENT_DATE IN DATE,
  p_PSE_ID IN NUMBER,
  p_CREDIT_MARKET IN VARCHAR2
  ) RETURN NUMBER IS

  v_TRAIT_INDEX IT_TRAIT_SCHEDULE.TRAIT_INDEX%TYPE;
  v_MSP_RUN_TYPE_NAMES STRING_COLLECTION;
  v_RESULT NUMBER;
  v_IS_MSP_RUN_CANCELLED NUMBER;
  v_MSP_RUN_TYPE_NAME EXTERNAL_SYSTEM_IDENTIFIER.EXTERNAL_IDENTIFIER%TYPE;
  v_START_DATE DATE;
  v_NEXT_STMT_START_DATE DATE;
  v_END_DATE DATE;
  v_STATEMENT_TYPE_ID STATEMENT_TYPE.STATEMENT_TYPE_ID%TYPE;
  v_MSP_RUN_TYPE_RESULT NUMBER;
  
  v_TEV_TXN_COUNT NUMBER;

  CURSOR c_TEV_TXNS IS
	SELECT IT.TRANSACTION_ID, IT.TRANSACTION_NAME, IT.AGREEMENT_TYPE, S.STATEMENT_TYPE_ORDER
	FROM INTERCHANGE_TRANSACTION IT,
		 EXTERNAL_SYSTEM_IDENTIFIER PSE_ESI,
		 EXTERNAL_SYSTEM_IDENTIFIER IC_ESI,
		 STATEMENT_TYPE S,
		 EXTERNAL_SYSTEM_IDENTIFIER ST_ESI
	WHERE ST_ESI.ENTITY_DOMAIN_ID = EC.ED_STATEMENT_TYPE
		  AND ST_ESI.EXTERNAL_SYSTEM_ID = EC.ES_SEM
		  AND ST_ESI.IDENTIFIER_TYPE = 'Gate Window'
		  AND S.STATEMENT_TYPE_ID = ST_ESI.ENTITY_ID
		  AND IT.AGREEMENT_TYPE = ST_ESI.EXTERNAL_IDENTIFIER
		  AND IT.TRANSACTION_TYPE = MM_SEM_CREDIT_SHADOW.c_TXN_TYPE_TRADED_EXPOSURE
		  AND PSE_ESI.EXTERNAL_SYSTEM_ID =EC.ES_SEM
		  AND PSE_ESI.ENTITY_DOMAIN_ID = EC.ED_PSE
		  AND PSE_ESI.ENTITY_ID = p_PSE_ID
		  AND PSE_ESI.IDENTIFIER_TYPE = EI.g_DEFAULT_IDENTIFIER_TYPE
		  AND IC_ESI.EXTERNAL_SYSTEM_ID = EC.ES_SEM
		  AND IC_ESI.ENTITY_DOMAIN_ID = EC.ED_INTERCHANGE_CONTRACT
		  AND IC_ESI.ENTITY_ID = IT.CONTRACT_ID
		  AND IC_ESI.IDENTIFIER_TYPE = EI.g_DEFAULT_IDENTIFIER_TYPE
		  AND PSE_ESI.EXTERNAL_IDENTIFIER = IC_ESI.EXTERNAL_IDENTIFIER
		  ORDER BY S.STATEMENT_TYPE_ORDER;

BEGIN
-- No TEV transactions? return zero as TEV for this PSE
	SELECT COUNT(*)
	INTO v_TEV_TXN_COUNT
	FROM INTERCHANGE_TRANSACTION IT,
		 EXTERNAL_SYSTEM_IDENTIFIER PSE_ESI,
		 EXTERNAL_SYSTEM_IDENTIFIER IC_ESI
	WHERE IT.TRANSACTION_TYPE = MM_SEM_CREDIT_SHADOW.c_TXN_TYPE_TRADED_EXPOSURE
	  AND PSE_ESI.EXTERNAL_SYSTEM_ID = EC.ES_SEM
	  AND PSE_ESI.ENTITY_DOMAIN_ID = EC.ED_PSE
	  AND PSE_ESI.ENTITY_ID = p_PSE_ID
	  AND PSE_ESI.IDENTIFIER_TYPE = EI.g_DEFAULT_IDENTIFIER_TYPE
	  AND IC_ESI.EXTERNAL_SYSTEM_ID = EC.ES_SEM
	  AND IC_ESI.ENTITY_DOMAIN_ID = EC.ED_INTERCHANGE_CONTRACT
	  AND IC_ESI.ENTITY_ID = IT.CONTRACT_ID
	  AND IC_ESI.IDENTIFIER_TYPE = EI.g_DEFAULT_IDENTIFIER_TYPE
	  AND PSE_ESI.EXTERNAL_IDENTIFIER = IC_ESI.EXTERNAL_IDENTIFIER;

	IF v_TEV_TXN_COUNT = 0 THEN
		RETURN 0;
	END IF;

  --Determine trait index based on market -> v_TRAIT_INDEX
  --(ETEV=1, CTEV=2)
  IF p_CREDIT_MARKET = MM_SEM_CREDIT_SHADOW.c_MARKET_EN THEN
    v_TRAIT_INDEX := MM_SEM_UTIL.g_TI_SEM_TRADED_EXP_ETEV;
  ELSE
    v_TRAIT_INDEX := MM_SEM_UTIL.g_TI_SEM_TRADED_EXP_CTEV;
  END IF;

  IF GET_FRW_START_DATE(p_ASSESSMENT_DATE, p_CREDIT_MARKET) IS NULL THEN
      LOGS.LOG_WARN('Settlement Calendar does not contain an Initial Statement prior to the assessment date of ' ||
	                TO_CHAR(p_ASSESSMENT_DATE) || ' for Credit Market ' || p_CREDIT_MARKET);
  END IF;

  v_RESULT := 0;
  v_MSP_RUN_TYPE_NAMES := GET_MSP_RUN_TYPE_NAMES;
  -- modify the start date to the FRW start date
	 v_NEXT_STMT_START_DATE := GET_FRW_START_DATE(p_ASSESSMENT_DATE, p_CREDIT_MARKET);

    $if $$UNIT_TEST_MODE = 1 $THEN
    IF UNIT_TEST_UTIL.g_CURRENT_TEST_PROCEDURE IN ('TEST_MM_SEM_CREDIT_SHADOW.T_GET_PSE_TR_AMT_BEST_STMT',
                                                   'TEST_MM_SEM_CREDIT_SHADOW.T_GET_PSE_TR_AMT_MISS_STMT') THEN
        INSERT INTO RTO_WORK(WORK_DATA)
        SELECT 'CREDIT_MARKET=' || p_CREDIT_MARKET || ',' ||
            'ASSESSMENT_DATE=' || TEXT_UTIL.TO_CHAR_TIME(p_ASSESSMENT_DATE) || ',' ||
            'FRW_START_DATE=' || TEXT_UTIL.TO_CHAR_TIME(v_NEXT_STMT_START_DATE)
        FROM DUAL;
    END IF;
    $end
  FOR v_IDX IN 1..v_MSP_RUN_TYPE_NAMES.COUNT LOOP
    v_MSP_RUN_TYPE_NAME := v_MSP_RUN_TYPE_NAMES(v_IDX);

    -- see if MSP run has been cancelled
    SELECT COUNT(*)
    INTO v_IS_MSP_RUN_CANCELLED
    FROM SEM_MSP_CANCELLATION SMC
    WHERE SMC.TRADE_DATE = p_ASSESSMENT_DATE
      AND SMC.RUN_TYPE = v_MSP_RUN_TYPE_NAME;

    -- only add gate values if MSP run has not been cancelled
    IF v_IS_MSP_RUN_CANCELLED = 0 AND v_NEXT_STMT_START_DATE IS NOT NULL THEN
      -- get the gate date range relative to the assessment date
      GET_IDT_DATE_RANGE(v_MSP_RUN_TYPE_NAME, p_ASSESSMENT_DATE, v_START_DATE, v_END_DATE);
     -- because EA2 and EA date ranges overlap, we shouldn't re-initialize for EA
	  -- (note we are assuming that EA immediately follows EA2 in the loop)
	  IF v_MSP_RUN_TYPE_NAME != 'EA' THEN
		  v_START_DATE := v_NEXT_STMT_START_DATE;
		  v_NEXT_STMT_START_DATE := v_END_DATE + 1/48;
	  END IF;
	  
	  IF v_START_DATE > v_END_DATE THEN
	      LOGS.LOG_WARN('Future Risk Window start date of ' || TEXT_UTIL.TO_CHAR_TIME(v_START_DATE) ||
		                ' is after MSP run type ' || v_MSP_RUN_TYPE_NAME ||
						' end date of ' || TEXT_UTIL.TO_CHAR_TIME(v_END_DATE));
   ELSE
		  -- get the statement type id for the MSP run type
		  /*
		  SELECT ESI.ENTITY_ID
		  INTO v_STATEMENT_TYPE_ID
		  FROM EXTERNAL_SYSTEM_IDENTIFIER ESI
		  WHERE ESI.EXTERNAL_SYSTEM_ID = EC.ES_SEM
			AND ESI.ENTITY_DOMAIN_ID = EC.ED_STATEMENT_TYPE
			AND ESI.IDENTIFIER_TYPE = 'Run Type'
			AND ESI.EXTERNAL_IDENTIFIER = v_MSP_RUN_TYPE_NAME;
		*/

		v_STATEMENT_TYPE_ID := EI.GET_ID_FROM_IDENTIFIER_EXTSYS(v_MSP_RUN_TYPE_NAME, EC.ED_STATEMENT_TYPE, EC.ES_SEM, 'Run Type');
		
		  FOR r_TEV_TXN IN c_TEV_TXNS LOOP
		  -- get gate result
			SELECT SUM(ITS.TRAIT_VAL)
			INTO v_MSP_RUN_TYPE_RESULT
			FROM IT_TRAIT_SCHEDULE ITS
			WHERE ITS.TRANSACTION_ID = r_TEV_TXN.TRANSACTION_ID
				AND ITS.SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE
				AND ITS.SCHEDULE_DATE BETWEEN v_START_DATE AND v_END_DATE
				AND ITS.TRAIT_GROUP_ID = MM_SEM_UTIL.g_TG_SEM_TRADED_EXPOSURE
				AND ITS.TRAIT_INDEX = v_TRAIT_INDEX
				AND ITS.SET_NUMBER = 1
				AND ITS.STATEMENT_TYPE_ID = v_STATEMENT_TYPE_ID;

			v_RESULT := v_RESULT + NVL(v_MSP_RUN_TYPE_RESULT,0);

			$if $$UNIT_TEST_MODE = 1 $THEN
				IF UNIT_TEST_UTIL.g_CURRENT_TEST_PROCEDURE IN ('TEST_MM_SEM_CREDIT_SHADOW.T_GET_PSE_TR_AMT_BEST_STMT',
                                                   'TEST_MM_SEM_CREDIT_SHADOW.T_GET_PSE_TR_AMT_MISS_STMT') THEN
					INSERT INTO RTO_WORK(WORK_DATA)
					SELECT 'MSP_RUN_TYPE_NAME=' || v_MSP_RUN_TYPE_NAME || ',' ||
							'START_DATE=' || TEXT_UTIL.TO_CHAR_TIME(v_START_DATE) || ',' ||
						'END_DATE=' || TEXT_UTIL.TO_CHAR_TIME(v_END_DATE)
					FROM DUAL;
				END IF;
			$end
		END LOOP;
	  END IF;
    END IF;
  END LOOP;

  RETURN v_RESULT;
END GET_PSE_TRADED_AMT;
-----------------------------------------------------------------------------------------------------------------
PROCEDURE RUN_CREDIT_CALCULATION
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATEMENT_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_TRACE_ON IN NUMBER,
	p_MESSAGE OUT VARCHAR2
	) AS
	v_ASSESSMENT_DATE DATE;
	v_STATEMENT_TYPE_ID NUMBER := p_STATEMENT_TYPE;

CURSOR c_PSEs IS
	SELECT DISTINCT B.ENTITY_ID "PSE_ID",
		B.ENTITY_GROUP_ID "ENTITY_GROUP_ID"
	FROM ENTITY_GROUP_ASSIGNMENT B, ENTITY_GROUP C
	WHERE p_BEGIN_DATE <= NVL(B.END_DATE, p_END_DATE)
		AND p_END_DATE >= B.BEGIN_DATE
		AND B.ENTITY_GROUP_ID = C.ENTITY_GROUP_ID
		AND C.GROUP_CATEGORY = c_ENTITY_GROUP_CATEGORY;

CURSOR c_PARTIES IS
	SELECT DISTINCT ENTITY_GROUP_ID
	FROM SEM_CREDIT_RESULT
	WHERE ASSESSMENT_DATE = v_ASSESSMENT_DATE
		AND STATEMENT_TYPE_ID = v_STATEMENT_TYPE_ID;

v_CURRENCY_CALCS SEM_CREDIT_CALC_CURRENCY%ROWTYPE;
v_EN_PSE_CALCS SEM_CREDIT_CALC_PSE%ROWTYPE;
v_CA_PSE_CALCS SEM_CREDIT_CALC_PSE%ROWTYPE;
v_EN_PSE_TOTALS SEM_CREDIT_RESULT%ROWTYPE;
v_CA_PSE_TOTALS SEM_CREDIT_RESULT%ROWTYPE;
v_PARTY_TOTALS SEM_CREDIT_RESULT%ROWTYPE;
v_PSE_STATUS VARCHAR2(1);
v_PSE_TYPE VARCHAR2(1);
v_PSE_CURRENCY VARCHAR2(16);

BEGIN

  g_TRACE_ON := p_TRACE_ON > 0;

  -- Clear out any old data for this date range.
  DELETE SEM_CREDIT_RESULT
  WHERE ASSESSMENT_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
    AND STATEMENT_TYPE_ID = v_STATEMENT_TYPE_ID
    AND STATEMENT_STATE = 1;

  DELETE SEM_CREDIT_CALC_CURRENCY
  WHERE ASSESSMENT_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
    AND STATEMENT_TYPE_ID = v_STATEMENT_TYPE_ID;

  DELETE SEM_CREDIT_CALC_PSE
  WHERE ASSESSMENT_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
    AND STATEMENT_TYPE_ID = v_STATEMENT_TYPE_ID;

  -- For each day in the date range
  v_ASSESSMENT_DATE := TRUNC(p_BEGIN_DATE);
  WHILE v_ASSESSMENT_DATE <= TRUNC(p_END_DATE) LOOP

    -- Calculate and store Currency-related factors for each currency.
    v_CURRENCY_CALCS := GET_CALCS_FOR_CURRENCY(v_ASSESSMENT_DATE, v_STATEMENT_TYPE_ID, c_CURRENCY_EURO, p_TIME_ZONE);
    INSERT INTO SEM_CREDIT_CALC_CURRENCY VALUES v_CURRENCY_CALCS;

    -- Calculate and Store the totals for each Participant PSE and Market (EN or CA)
    FOR v_PSE IN c_PSEs LOOP
      v_PSE_STATUS := NVL(RO.GET_ENTITY_ATTRIBUTE(c_ATTR_PSE_STATUS, EC.ED_PSE, v_PSE.PSE_ID, v_ASSESSMENT_DATE), c_CREDIT_STATUS_NEW);
      v_PSE_TYPE := MM_SEM_UTIL.GET_PSE_UNIT_TYPE(v_PSE.PSE_ID, 1, v_ASSESSMENT_DATE);

      -- Determine the currency for which the data is stored in the Billing Statement table.
      -- If it is not Euros, we will need to convert the data to Euros.
      v_PSE_CURRENCY := GET_PSE_CURRENCY(v_PSE.PSE_ID, v_ASSESSMENT_DATE);

      GET_CALCS_FOR_PSE(v_PSE.PSE_ID, v_PSE_TYPE, v_ASSESSMENT_DATE, v_STATEMENT_TYPE_ID, v_CURRENCY_CALCS, v_EN_PSE_CALCS, v_CA_PSE_CALCS);
      INSERT INTO SEM_CREDIT_CALC_PSE VALUES v_EN_PSE_CALCS;
      INSERT INTO SEM_CREDIT_CALC_PSE VALUES v_CA_PSE_CALCS;

      v_EN_PSE_TOTALS := GET_TOTALS_FOR_PSE_MARKET(v_PSE.PSE_ID, v_PSE_STATUS, v_PSE_TYPE, v_PSE.ENTITY_GROUP_ID, c_MARKET_EN, v_PSE_CURRENCY, v_ASSESSMENT_DATE, v_STATEMENT_TYPE_ID, v_EN_PSE_CALCS, v_CURRENCY_CALCS, p_TIME_ZONE);
      v_CA_PSE_TOTALS := GET_TOTALS_FOR_PSE_MARKET(v_PSE.PSE_ID, v_PSE_STATUS, v_PSE_TYPE, v_PSE.ENTITY_GROUP_ID, c_MARKET_CA, v_PSE_CURRENCY, v_ASSESSMENT_DATE, v_STATEMENT_TYPE_ID, v_CA_PSE_CALCS, v_CURRENCY_CALCS, p_TIME_ZONE);
      INSERT INTO SEM_CREDIT_RESULT VALUES v_EN_PSE_TOTALS;
      INSERT INTO SEM_CREDIT_RESULT VALUES v_CA_PSE_TOTALS;
    END LOOP;

    -- Store the totals for each party.
    FOR v_PARTY IN c_PARTIES LOOP
      v_PARTY_TOTALS := GET_TOTALS_FOR_PARTY(v_PARTY.ENTITY_GROUP_ID, v_ASSESSMENT_DATE, v_STATEMENT_TYPE_ID);
      INSERT INTO SEM_CREDIT_RESULT VALUES v_PARTY_TOTALS;
    END LOOP;

    v_ASSESSMENT_DATE := v_ASSESSMENT_DATE + 1;
  END LOOP; --Over Dates

END RUN_CREDIT_CALCULATION;
-----------------------------------------------------------------------------------------------------------------
PROCEDURE POPULATE_TE_TRAIT_VALUES
	(
	p_RTO_WORK_ID IN NUMBER,
	p_TRANSACTION_ID IN NUMBER,
	p_STATEMENT_TYPE_ID IN NUMBER,
	p_STATEMENT_STATE IN NUMBER := 1,
	p_SET_NUMBER IN NUMBER := 1
	) AS
BEGIN
  MERGE INTO IT_TRAIT_SCHEDULE S
  USING (SELECT p_TRANSACTION_ID AS TRANSACTION_ID,
             p_STATEMENT_STATE AS SCHEDULE_STATE, -- Schedule State Internal or External
             WORK_DATE,
             MM_SEM_UTIL.g_TG_SEM_TRADED_EXPOSURE AS TRAIT_GROUP_ID,
             WORK_SEQ,
             p_SET_NUMBER AS SET_NUMBER, -- Set Number
             p_STATEMENT_TYPE_ID AS STATEMENT_TYPE_ID,
             WORK_DATA AS TRAIT_VAL
      FROM RTO_WORK
      WHERE WORK_ID = p_RTO_WORK_ID) TE
  ON (S.TRANSACTION_ID = TE.TRANSACTION_ID
       AND S.SCHEDULE_STATE = TE.SCHEDULE_STATE
       AND S.SCHEDULE_DATE = TE.WORK_DATE
       AND S.TRAIT_GROUP_ID = TE.TRAIT_GROUP_ID
       AND S.TRAIT_INDEX = TE.WORK_SEQ
       AND S.SET_NUMBER = TE.SET_NUMBER
       AND S.STATEMENT_TYPE_ID = TE.STATEMENT_TYPE_ID)
  WHEN MATCHED THEN
       UPDATE SET S.TRAIT_VAL = TE.TRAIT_VAL,
                  S.ENTRY_DATE = SYSDATE
  WHEN NOT MATCHED THEN
    INSERT (TRANSACTION_ID,
           SCHEDULE_STATE,
           SCHEDULE_DATE,
           TRAIT_GROUP_ID,
           TRAIT_INDEX,
           SET_NUMBER,
           STATEMENT_TYPE_ID,
           TRAIT_VAL,
           ENTRY_DATE)
    VALUES (TE.TRANSACTION_ID,
           TE.SCHEDULE_STATE,
           TE.WORK_DATE,
           TE.TRAIT_GROUP_ID,
           TE.WORK_SEQ,
           TE.SET_NUMBER,
           TE.STATEMENT_TYPE_ID,
           TE.TRAIT_VAL,
           SYSDATE);
END POPULATE_TE_TRAIT_VALUES;
-----------------------------------------------------------------------------------------------------------------
PROCEDURE GET_MSQ_MIUN
	(
	p_WORK_ID               IN NUMBER,
	p_TIME_ZONE             IN VARCHAR2,
	p_GATE_CUT_BEGIN_DATE  	IN DATE,
	p_GATE_CUT_END_DATE		   IN DATE,
 	p_GATE_WINDOW		         IN VARCHAR2,
 	p_RUN_TYPE_ID           IN NUMBER,
	p_POD_ID				            IN NUMBER,
	p_PSE_ID				            IN NUMBER,
	p_TRAIT_INDEX           IN NUMBER
	) AS
     v_MIN_INTERVAL_NUMBER NUMBER(2) := GET_INTERVAL_NUMBER('MI30');
BEGIN
	LOGS.LOG_DEBUG('Get '|| CASE WHEN p_TRAIT_INDEX = MM_SEM_UTIL.g_TI_SEM_TRADED_EXP_MSQ THEN 'MSQ' ELSE 'MIUN' END || ' for: ' || UTL_TCP.CRLF ||
			   ' Gate Begin Cut Date: ' || TEXT_UTIL.TO_CHAR_TIME(p_GATE_CUT_BEGIN_DATE) || UTL_TCP.CRLF ||
			   ' Gate End Cut Date: ' || TEXT_UTIL.TO_CHAR_TIME(p_GATE_CUT_END_DATE) || UTL_TCP.CRLF ||
			   ' Gate Window: '|| p_GATE_WINDOW || UTL_TCP.CRLF ||
      			' Run Type: '|| EI.GET_ENTITY_IDENTIFIER_EXTSYS(EC.ED_STATEMENT_TYPE, p_RUN_TYPE_ID, EC.ED_STATEMENT_TYPE, 'Run Type') || UTL_TCP.CRLF ||
			   ' Service Point: ' || EI.GET_ENTITY_NAME(EC.ED_SERVICE_POINT, p_POD_ID) || UTL_TCP.CRLF ||
			   ' PSE Name: '|| EI.GET_ENTITY_NAME(EC.ED_PSE, p_PSE_ID));

	INSERT INTO RTO_WORK (WORK_ID,
						  WORK_DATE,
						  WORK_SEQ,
						  WORK_DATA
						  )
	SELECT p_WORK_ID,
		   SDT.CUT_DATE,
		   p_TRAIT_INDEX,
		   TO_CHAR(NVL(AMOUNT,0))
	FROM (SELECT S.SCHEDULE_DATE,
			     SUM(S.AMOUNT) AS AMOUNT
		    FROM INTERCHANGE_TRANSACTION IT,
			     INTERCHANGE_CONTRACT IC,
			     IT_SCHEDULE S
		   WHERE IT.TRANSACTION_TYPE 	= MM_SEM_UTIL.c_TXN_TYPE_NOMINATION
        AND IT.POD_ID		= p_POD_ID
        AND IT.SC_ID			= MM_SEM_UTIL.SEM_SC_ID
        AND TRIM(IT.AGREEMENT_TYPE) = p_GATE_WINDOW
        AND UPPER(TRIM(IC.CONTRACT_ALIAS))	= UPPER(TRIM(EI.GET_ENTITY_IDENTIFIER_EXTSYS(EC.ED_PSE, p_PSE_ID, EC.ES_SEM)))
        AND IC.CONTRACT_ID 	= IT.CONTRACT_ID
        AND S.TRANSACTION_ID = IT.TRANSACTION_ID
        AND S.SCHEDULE_DATE BETWEEN p_GATE_CUT_BEGIN_DATE AND p_GATE_CUT_END_DATE
        AND S.SCHEDULE_TYPE = p_RUN_TYPE_ID
        AND S.SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE
     GROUP BY S.SCHEDULE_DATE),
		 SYSTEM_DATE_TIME SDT
	  WHERE SDT.TIME_ZONE			= p_TIME_ZONE
		AND SDT.DATA_INTERVAL_TYPE	= 1
		AND SDT.DAY_TYPE			= '1'
		AND SDT.MINIMUM_INTERVAL_NUMBER >= v_MIN_INTERVAL_NUMBER
		AND SDT.CUT_DATE			= SCHEDULE_DATE(+)
		AND SDT.CUT_DATE BETWEEN p_GATE_CUT_BEGIN_DATE AND p_GATE_CUT_END_DATE;
END GET_MSQ_MIUN;
-----------------------------------------------------------------------------------------------------------------
PROCEDURE GET_LLQ_HLQ
	(
	p_WORK_ID				IN	NUMBER,
	p_TRAIT_INDEX			IN	NUMBER,
	p_LOOK_UP_TRAIT_INDEX	IN	NUMBER
	) AS
BEGIN
	LOGS.LOG_DEBUG('Get ' || CASE WHEN p_TRAIT_INDEX = MM_SEM_UTIL.g_TI_SEM_TRADED_EXP_LLQ THEN 'LLQ' ELSE 'HLQ' END
              || ' using:' || CASE WHEN p_LOOK_UP_TRAIT_INDEX = MM_SEM_UTIL.g_TI_SEM_TRADED_EXP_MSQ THEN 'MSQ' ELSE 'MIUN' END || '.');

	INSERT INTO RTO_WORK (WORK_ID,
						  WORK_DATE,
						  WORK_SEQ,
						  WORK_DATA
						  )
	SELECT p_WORK_ID		AS WORK_ID,
		   RW.WORK_DATE		AS WORK_DATE,
		   p_TRAIT_INDEX	AS WORK_SEQ,
		   CASE p_TRAIT_INDEX
		   	   WHEN MM_SEM_UTIL.g_TI_SEM_TRADED_EXP_LLQ THEN
			   	   LEAST(0, TO_NUMBER(RW.WORK_DATA))
			   WHEN MM_SEM_UTIL.g_TI_SEM_TRADED_EXP_HLQ THEN
			   	   GREATEST(0, TO_NUMBER(RW.WORK_DATA))
		   END WORK_DATA
	  FROM RTO_WORK RW
	 WHERE RW.WORK_ID	= p_WORK_ID
	   AND RW.WORK_SEQ	= p_LOOK_UP_TRAIT_INDEX;
END GET_LLQ_HLQ;
-----------------------------------------------------------------------------------------------------------------
FUNCTION GET_ECPI
(
	p_ASSESSMENT_DATE	IN DATE,
	p_PSE_ID			IN NUMBER
)RETURN NUMBER
IS
	v_RETURN NUMBER;
	v_ADJUSTED_ASSESSMENT_DATE DATE;
	v_ENTITY_GROUP_ID	ENTITY_GROUP.ENTITY_GROUP_ID%TYPE;
BEGIN
	-- We need to get the "Assessment Date" that is actually the most recent publication date that PRECEDES the p_ASSESSMENT_DATE
	-- This can be peremptorily resolved by consulting the SEM_SETTLEMENT_CALENDAR
	SELECT MAX(PUBLICATION_DATE)
	INTO v_ADJUSTED_ASSESSMENT_DATE
	FROM SEM_SETTLEMENT_CALENDAR A
	WHERE A.PUBLICATION_DATE <= p_ASSESSMENT_DATE - 2
	AND A.PUBLICATION_TYPE = 'Report'
	AND A.MARKET = 'Energy'
	AND A.RUN_TYPE = 'Initial';

	-- Get the Entity Group Id for Group Category "SEM Credit" and for PSE Domain
	BEGIN
		/*
		SELECT A.ENTITY_GROUP_ID
		INTO v_ENTITY_GROUP_ID
		FROM ENTITY_GROUP_ASSIGNMENT A
		WHERE A.ENTITY_GROUP_ID IN (SELECT A.ENTITY_GROUP_ID
									FROM ENTITY_GROUP A
									WHERE A.GROUP_CATEGORY = 'SEM Credit'
									AND A.ENTITY_DOMAIN_ID = EC.ED_PSE)
		AND v_ADJUSTED_ASSESSMENT_DATE BETWEEN A.BEGIN_DATE AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE)
		AND A.ENTITY_ID = p_PSE_ID;
		*/
		-- jbc, 19-dec-2013: should fix the issue where the billing PSE needs to be assigned to the credit party
		SELECT A.ENTITY_GROUP_ID
		INTO v_ENTITY_GROUP_ID
		FROM ENTITY_GROUP_ASSIGNMENT A, ENTITY_GROUP E, SEM_SETTLEMENT_ENTITY S
		WHERE E.GROUP_CATEGORY = 'SEM Credit'
		AND E.ENTITY_DOMAIN_ID = EC.ED_PSE
		AND A.ENTITY_GROUP_ID =E.ENTITY_GROUP_ID
		AND v_ADJUSTED_ASSESSMENT_DATE BETWEEN A.BEGIN_DATE AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE)
		AND S.SETTLEMENT_PSE_ID =  p_PSE_ID
		AND S.MARKET_NAME = 'EN'
		AND A.ENTITY_ID = S.PARTICIPANT_PSE_ID;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_EXTRA_MESSAGE => 'PSE ''' || TEXT_UTIL.TO_CHAR_ENTITY(p_PSE_ID, EC.ED_PSE) ||
													  ''' is not assigned to an Entity Group of Category=''SEM Credit''',
								  p_LOG_LEVEL => LOGS.c_LEVEL_WARN);
	END;

	-- Now use this "Adjusted Assessment Date" to query the ECPI value to return it
	-- If there are more entries, highest Version Number wins
	BEGIN
		SELECT A.ECPI
		INTO v_RETURN
		FROM (
/*
				SELECT A.ECPI, RANK() OVER(ORDER BY A.VERSION DESC) "RANKING"
				FROM SEM_CREDIT_CALC_EXTERNAL A
				WHERE A.ASSESSMENT_DATE = v_ADJUSTED_ASSESSMENT_DATE
				AND A.ENTITY_GROUP_ID = v_ENTITY_GROUP_ID
				AND A.CREDIT_MARKET = c_MARKET_EN
*/
				SELECT A.ECPI, RANK() OVER(ORDER BY A.ASSESSMENT_DATE DESC, A.VERSION DESC) "RANKING"
				FROM SEM_CREDIT_CALC_EXTERNAL A
				WHERE A.ASSESSMENT_DATE <= v_ADJUSTED_ASSESSMENT_DATE
				AND A.ENTITY_GROUP_ID = v_ENTITY_GROUP_ID
				AND A.CREDIT_MARKET = c_MARKET_EN
			 )A
		WHERE A.RANKING = 1;
	EXCEPTION
	WHEN NO_DATA_FOUND THEN
		-- Log the error message with WARN log-level
		ERRS.LOG_AND_CONTINUE(p_EXTRA_MESSAGE => 'ECPI Value for Assessment Date=' ||
							  TEXT_UTIL.TO_CHAR_DATE(p_ASSESSMENT_DATE) ||
							  ' and Settlement Calendar adjusted Assessment Date=' ||
							  TEXT_UTIL.TO_CHAR_DATE(v_ADJUSTED_ASSESSMENT_DATE) || ' returned no data. Assuming 0.',
							  p_LOG_LEVEL => LOGS.c_LEVEL_WARN);
		v_RETURN := 0;
	END;

	-- Return the value
	RETURN v_RETURN;
END GET_ECPI;
-----------------------------------------------------------------------------------------------------------------
PROCEDURE GET_ETEV
	(
	p_WORK_ID				IN	NUMBER,
	p_TIME_ZONE				IN	VARCHAR2,
	p_GATE_CUT_BEGIN_DATE	IN	DATE,
	p_GATE_CUT_END_DATE		IN	DATE,
	p_POD_ID				IN	NUMBER,
	p_PSE_ID				IN	NUMBER,
	p_GATE_WINDOW				IN	VARCHAR2,
 p_RUN_TYPE       IN VARCHAR2,
	p_VAT_RATE				IN	NUMBER
	) AS
 	v_MIN_INTERVAL_NUMBER	NUMBER(2) := GET_INTERVAL_NUMBER('MI30');
	v_RESOURCE_NAME			EXTERNAL_SYSTEM_IDENTIFIER.EXTERNAL_IDENTIFIER%TYPE;
	v_PARTICIPANT_NAME		PURCHASING_SELLING_ENTITY.PSE_NAME%TYPE;
BEGIN
	v_RESOURCE_NAME := EI.GET_ENTITY_IDENTIFIER_EXTSYS(EC.ED_SERVICE_POINT, p_POD_ID, EC.ES_SEM);
	v_PARTICIPANT_NAME := GET_PARTICIPANT_PSE_EXT_IDENT(p_PSE_ID);

	LOGS.LOG_DEBUG('Get ETEV using:' || UTL_TCP.CRLF ||
			       ' Gate Begin Cut Date: ' || TEXT_UTIL.TO_CHAR_TIME(p_GATE_CUT_BEGIN_DATE) || UTL_TCP.CRLF ||
				   ' Gate End Cut Date: ' || TEXT_UTIL.TO_CHAR_TIME(p_GATE_CUT_END_DATE) || UTL_TCP.CRLF ||
       ' Gate Window: ' || p_GATE_WINDOW || UTL_TCP.CRLF ||
			       ' PSE Name: ' || v_PARTICIPANT_NAME || UTL_TCP.CRLF ||
			       ' VAT Rate: ' || TO_CHAR(p_VAT_RATE) || UTL_TCP.CRLF);

	INSERT INTO RTO_WORK (WORK_ID,
						  WORK_DATE,
						  WORK_SEQ,
						  WORK_DATA
						  )
		SELECT p_WORK_ID	AS WORK_ID,
			   CUT_DATE		AS WORK_DATE,
			   MM_SEM_UTIL.g_TI_SEM_TRADED_EXP_ETEV
							AS TRAIT_INDEX,
			   -- This is the formula to calculate ETEV value for each interval.
			   -- Greatest is used to filter out negative values
				CASE WHEN p_RUN_TYPE = 'EP2' THEN NVL(SUM(-1 * ((ABS(Z.QUANTITY) - ABS(Z.PREVIOUS_QUANTITY)) * Z.PRICE * (1 + p_VAT_RATE))*0.5), 0)
					        ELSE GREATEST(NVL(SUM(-1 * ((ABS(Z.QUANTITY) - ABS(Z.PREVIOUS_QUANTITY)) * Z.PRICE * (1 + p_VAT_RATE))*0.5), 0), 0)
				END AS TRAIT_VAL
		  FROM (SELECT Y.DELIVERY_DATE,
				   	   Y.QUANTITY QUANTITY,
					   GREATEST(Y.PREVIOUS_QUANTITY, TO_NUMBER(LLQ.WORK_DATA)) PREVIOUS_QUANTITY,
					   -- 1. If LLQ < Q1, then use P1(Next Price).
					   -- 2. If there are n P/Q pairs and HLQ > Qn, the Price will Pn(Previous Price).
					   NVL(Y.PRICE, NVL(Y.NEXT_PRICE, Y.PREVIOUS_PRICE)) AS PRICE
					   -- From the base data, get the previous, present
					   -- and next Quantity and Price values.
			   	 FROM (SELECT X.DELIVERY_DATE,
							  X.PRICE,
							  X.QUANTITY,
							  X.TRAIT_INDEX,
							  LAG(X.PRICE) OVER(PARTITION BY DELIVERY_DATE ORDER BY DELIVERY_DATE, QUANTITY, PRICE) PREVIOUS_PRICE,
							  LAG(X.QUANTITY) OVER(PARTITION BY DELIVERY_DATE ORDER BY DELIVERY_DATE, QUANTITY, PRICE) PREVIOUS_QUANTITY,
							  LEAD(X.PRICE) OVER(PARTITION BY DELIVERY_DATE ORDER BY DELIVERY_DATE, QUANTITY, PRICE) NEXT_PRICE,
							  LEAD(X.QUANTITY) OVER(PARTITION BY DELIVERY_DATE ORDER BY DELIVERY_DATE, QUANTITY, PRICE) NEXT_QUANTITY
							  -- Get all the PQ pairs without any filters.
							  -- Have separate rows for LLQ and HLQ.
							  -- Order by Quantity and Price for each interval.
							  -- This is the base data.
						      FROM (SELECT LLQ.WORK_DATE	 AS DELIVERY_DATE,
										   -1				 AS TRAIT_INDEX,
									       NULL			 	 AS PRICE,
									       TO_NUMBER(LLQ.WORK_DATA) AS QUANTITY,
									       -1				 AS PQ_INDEX
								      FROM RTO_WORK LLQ
								     WHERE LLQ.WORK_ID			= p_WORK_ID
								       AND LLQ.WORK_SEQ			= MM_SEM_UTIL.g_TI_SEM_TRADED_EXP_LLQ
								    UNION ALL
								    SELECT DELIVERY_DATE,
									       1 AS TRAIT_INDEX,
									       PRICE,
									       QUANTITY,
									       PQ_INDEX
								      FROM SEM_EXCLUDED_BIDS SEB_VALUES
								     WHERE SEB_VALUES.PARTICIPANT_NAME	= v_PARTICIPANT_NAME
								       AND SEB_VALUES.RESOURCE_NAME		= v_RESOURCE_NAME
								       AND SEB_VALUES.GATE_WINDOW		= p_GATE_WINDOW
								       AND SEB_VALUES.EXCLUDED_FLAG		= 'N'
								       AND SEB_VALUES.DELIVERY_DATE BETWEEN p_GATE_CUT_BEGIN_DATE AND p_GATE_CUT_END_DATE
									   AND NOT EXISTS (SELECT 1
									   					 FROM SEM_EXCLUDED_BIDS SEB_CANCELLATIONS
														WHERE SEB_CANCELLATIONS.PARTICIPANT_NAME	= v_PARTICIPANT_NAME
														  AND SEB_CANCELLATIONS.RESOURCE_NAME		= v_RESOURCE_NAME
														  AND SEB_CANCELLATIONS.GATE_WINDOW			= p_GATE_WINDOW
														  AND SEB_CANCELLATIONS.EXCLUDED_FLAG		= 'Y'
														  AND SEB_CANCELLATIONS.DELIVERY_DATE		= SEB_VALUES.DELIVERY_DATE
                						AND SEB_CANCELLATIONS.PQ_INDEX = SEB_VALUES.PQ_INDEX
													  )
								    UNION ALL
								    SELECT HLQ.WORK_DATE 	 AS DELIVERY_DATE,
									       99999		 	 AS TRAIT_INDEX,
									       NULL			 	 AS PRICE,
									       TO_NUMBER(HLQ.WORK_DATA) AS QUANTITY,
									       99999			 AS PQ_INDEX
								    FROM RTO_WORK HLQ
								   WHERE HLQ.WORK_ID			= p_WORK_ID
								     AND HLQ.WORK_SEQ			= MM_SEM_UTIL.g_TI_SEM_TRADED_EXP_HLQ
								  ORDER BY DELIVERY_DATE, QUANTITY, PRICE
							       ) X
						) Y,
						RTO_WORK		   			 LLQ,
						RTO_WORK		   			 HLQ
				  WHERE Y.DELIVERY_DATE		= LLQ.WORK_DATE
					AND ((Y.QUANTITY >= TO_NUMBER(LLQ.WORK_DATA) AND Y.QUANTITY <= TO_NUMBER(HLQ.WORK_DATA) AND Y.TRAIT_INDEX = MM_SEM_UTIL.g_TI_SEM_TRADED_EXP_ETEV)
						  OR (Y.TRAIT_INDEX <> MM_SEM_UTIL.g_TI_SEM_TRADED_EXP_ETEV))
          			-- For all other gate windows, lookup P/Q values in just 2nd and 4th quadrant
					-- For EP2, lookup P/Q values in all quadrants
  				    AND ((p_RUN_TYPE  NOT IN ('EP2') AND ((NVL(Y.PRICE, 0) >= 0 AND Y.QUANTITY <= 0) OR (NVL(Y.PRICE, 0) <= 0 AND Y.QUANTITY >= 0)))
                		OR p_RUN_TYPE  IN ('EP2'))
				  	AND LLQ.WORK_ID			= p_WORK_ID
					AND LLQ.WORK_SEQ		= MM_SEM_UTIL.g_TI_SEM_TRADED_EXP_LLQ
					AND HLQ.WORK_ID			= LLQ.WORK_ID
					AND HLQ.WORK_DATE		= LLQ.WORK_DATE
					AND HLQ.WORK_SEQ		= MM_SEM_UTIL.g_TI_SEM_TRADED_EXP_HLQ) Z,
		 SYSTEM_DATE_TIME SDT
	WHERE SDT.TIME_ZONE					= p_TIME_ZONE
	  AND SDT.DATA_INTERVAL_TYPE		= 1
	  AND SDT.DAY_TYPE					= '1'
	  AND SDT.MINIMUM_INTERVAL_NUMBER  >= v_MIN_INTERVAL_NUMBER
	  AND SDT.CUT_DATE					= DELIVERY_DATE(+)
	  AND SDT.CUT_DATE BETWEEN p_GATE_CUT_BEGIN_DATE AND p_GATE_CUT_END_DATE
	GROUP BY CUT_DATE
	ORDER BY CUT_DATE;
END GET_ETEV;
-----------------------------------------------------------------------------------------------------------------
PROCEDURE GET_CTEV
	(
	p_WORK_ID				       		IN	NUMBER,
	p_TIME_ZONE			          		IN	VARCHAR2,
	p_GATE_CUT_BEGIN_DATE	  			IN	DATE,
	p_GATE_CUT_END_DATE		   			IN	DATE,
	p_ASSESSMENT_DATE       			IN DATE,
	p_PSE_ID                			IN NUMBER,
	p_TRAIT_INDEX			        	IN	NUMBER,
	p_LOOK_UP_TRAIT_INDEX	  			IN	NUMBER,
	p_VAT_RATE              			IN NUMBER
	) AS
	v_ECPI NUMBER := GET_ECPI(p_ASSESSMENT_DATE, p_PSE_ID);
	v_MIN_INTERVAL_NUMBER NUMBER(2) := GET_INTERVAL_NUMBER('MI30');
BEGIN
	LOGS.LOG_DEBUG('Get CTEV using '|| CASE WHEN p_LOOK_UP_TRAIT_INDEX = MM_SEM_UTIL.g_TI_SEM_TRADED_EXP_MSQ THEN 'MSQ' ELSE 'MIUN' END || ' : ' || UTL_TCP.CRLF ||
			   ' Gate Begin Cut Date: ' || TEXT_UTIL.TO_CHAR_TIME(p_GATE_CUT_BEGIN_DATE) || UTL_TCP.CRLF ||
			   ' Gate End Cut Date: ' || TEXT_UTIL.TO_CHAR_TIME(p_GATE_CUT_END_DATE) || UTL_TCP.CRLF ||
			   ' Gate Assessment Date: ' || TEXT_UTIL.TO_CHAR_DATE(p_ASSESSMENT_DATE) || UTL_TCP.CRLF ||
			   ' PSE Name: ' || EI.GET_ENTITY_NAME(EC.ED_PSE, p_PSE_ID) || UTL_TCP.CRLF ||
			   ' VAT Rate: ' || TO_CHAR(p_VAT_RATE) || UTL_TCP.CRLF ||
			   ' ECPI: '  || TO_CHAR(v_ECPI));

	-- add the calculated CTEV to the work table
	INSERT INTO RTO_WORK (WORK_ID, WORK_DATE, WORK_SEQ, WORK_DATA)
	SELECT p_WORK_ID		AS WORK_ID,
        SDT.CUT_DATE,
        p_TRAIT_INDEX	AS WORK_SEQ,
        NVL(CTEV.TRAIT_VALUE,0) AS TRAIT_VALUE
	FROM (SELECT RW.WORK_DATE		AS WORK_DATE,
         CASE WHEN p_LOOK_UP_TRAIT_INDEX = MM_SEM_UTIL.g_TI_SEM_TRADED_EXP_MSQ THEN
              -1 * TO_NUMBER(RW.WORK_DATA) * v_ECPI * (1 + (p_VAT_RATE))*0.5
              WHEN p_LOOK_UP_TRAIT_INDEX = MM_SEM_UTIL.g_TI_SEM_TRADED_EXP_MIUN THEN
              -1 * LEAST(0, TO_NUMBER(RW.WORK_DATA) * v_ECPI * (1 + (p_VAT_RATE)))*0.5
              ELSE NULL
        END AS TRAIT_VALUE
	    FROM RTO_WORK RW
     WHERE RW.WORK_ID	= p_WORK_ID
	       AND RW.WORK_SEQ	= p_LOOK_UP_TRAIT_INDEX) CTEV,
		   SYSTEM_DATE_TIME SDT
	WHERE SDT.TIME_ZONE	= p_TIME_ZONE
    AND SDT.DATA_INTERVAL_TYPE	= 1
    AND SDT.DAY_TYPE			= '1'
    AND SDT.MINIMUM_INTERVAL_NUMBER >= v_MIN_INTERVAL_NUMBER
    AND SDT.CUT_DATE			= CTEV.WORK_DATE(+)
    AND SDT.CUT_DATE BETWEEN p_GATE_CUT_BEGIN_DATE AND p_GATE_CUT_END_DATE;
	
	-- add the ECPI to the work table - this is a total hack
	INSERT INTO RTO_WORK (WORK_ID, WORK_DATE, WORK_SEQ, WORK_DATA)
	SELECT p_WORK_ID		AS WORK_ID,
        SDT.CUT_DATE,
        7	AS WORK_SEQ,
        v_ECPI AS TRAIT_VALUE
	FROM (SELECT RW.WORK_DATE		AS WORK_DATE,
         CASE WHEN p_LOOK_UP_TRAIT_INDEX = MM_SEM_UTIL.g_TI_SEM_TRADED_EXP_MSQ THEN
              -1 * TO_NUMBER(RW.WORK_DATA) * v_ECPI * (1 + (p_VAT_RATE))*0.5
              WHEN p_LOOK_UP_TRAIT_INDEX = MM_SEM_UTIL.g_TI_SEM_TRADED_EXP_MIUN THEN
              -1 * LEAST(0, TO_NUMBER(RW.WORK_DATA) * v_ECPI * (1 + (p_VAT_RATE)))*0.5
              ELSE NULL
        END AS TRAIT_VALUE
	    FROM RTO_WORK RW
     WHERE RW.WORK_ID	= p_WORK_ID
	       AND RW.WORK_SEQ	= p_LOOK_UP_TRAIT_INDEX) CTEV,
		   SYSTEM_DATE_TIME SDT
	WHERE SDT.TIME_ZONE	= p_TIME_ZONE
    AND SDT.DATA_INTERVAL_TYPE	= 1
    AND SDT.DAY_TYPE			= '1'
    AND SDT.MINIMUM_INTERVAL_NUMBER >= v_MIN_INTERVAL_NUMBER
    AND SDT.CUT_DATE			= CTEV.WORK_DATE(+)
    AND SDT.CUT_DATE BETWEEN p_GATE_CUT_BEGIN_DATE AND p_GATE_CUT_END_DATE;
END GET_CTEV;
-----------------------------------------------------------------------------------------------------------------
PROCEDURE GET_TRAIT_VALS_FOR_TRADED_EXP
	(
	p_TRANSACTION_ID	IN	NUMBER,
	p_TIME_ZONE			IN	VARCHAR2,
	p_ASSESSMENT_DATE	IN	DATE,
	p_STATEMENT_TYPE_ID	IN	NUMBER,
	p_POD_ID			IN	NUMBER,
	p_PSE_ID			IN	NUMBER
	) AS
	v_GATE_CUT_BEGIN_DATE		DATE;
	v_GATE_CUT_END_DATE			DATE;
	v_WORK_ID					NUMBER(9);
	v_RUN_TYPE	  				EXTERNAL_SYSTEM_IDENTIFIER.EXTERNAL_IDENTIFIER%TYPE;
	v_TRAIT_INDEX_MSQ_OR_MIUN	IT_TRAIT_SCHEDULE.TRAIT_INDEX%TYPE;
	v_VAT_RATE					NUMBER;
	v_JURISDICTION				VARCHAR2(32);
	v_GATE_WINDOW INTERCHANGE_TRANSACTION.AGREEMENT_TYPE%TYPE;

BEGIN
	LOGS.LOG_DEBUG('Getting Trait Values for Traded Exposure.');

	v_RUN_TYPE := EI.GET_ENTITY_IDENTIFIER_EXTSYS(EC.ED_STATEMENT_TYPE, p_STATEMENT_TYPE_ID, EC.ES_SEM, MM_SEM_UTIL.g_STATEMENT_TYPE_RUN_TYPE);

	-- Assumption is that the transaction would have the agreement type set to 'EA'.
	BEGIN
	 SELECT IT.AGREEMENT_TYPE
	 INTO v_GATE_WINDOW
	 FROM INTERCHANGE_TRANSACTION IT
	 WHERE IT.TRANSACTION_ID = p_TRANSACTION_ID;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
	ERRS.LOG_AND_RAISE(p_EXTRA_MESSAGE => 'Interchange Transaction ''' || TEXT_UTIL.TO_CHAR_ENTITY(p_TRANSACTION_ID, EC.ED_TRANSACTION) ||
	           ''' is not assigned an Agreement Type');
	END;

	-- Get VAT Rate for Jurisdiction
	v_JURISDICTION := RO.GET_ENTITY_ATTRIBUTE(MM_SEM_UTIL.g_EA_PSE_JURISDICTION, EC.ED_PSE, p_PSE_ID, p_ASSESSMENT_DATE);
	IF v_JURISDICTION = 'NI' THEN
    	v_VAT_RATE := RO.GET_ENTITY_ATTRIBUTE(MM_SEM_UTIL.g_EA_NI_GEN_TAX_RATE, EC.ED_SC, MM_SEM_UTIL.SEM_SC_ID, p_ASSESSMENT_DATE);
 	ELSIF v_JURISDICTION = 'ROI' THEN
    	v_VAT_RATE := RO.GET_ENTITY_ATTRIBUTE(MM_SEM_UTIL.g_EA_ROI_GEN_TAX_RATE, EC.ED_SC, MM_SEM_UTIL.SEM_SC_ID, p_ASSESSMENT_DATE);
 	END IF;

	UT.GET_RTO_WORK_ID(v_WORK_ID);

	-- Get Begin and End Dates for the Run Type
	GET_IDT_DATE_RANGE(v_RUN_TYPE,
					   p_ASSESSMENT_DATE,
					   v_GATE_CUT_BEGIN_DATE,
					   v_GATE_CUT_END_DATE
					  );

	IF v_RUN_TYPE = 'EP2' THEN
		v_TRAIT_INDEX_MSQ_OR_MIUN := MM_SEM_UTIL.g_TI_SEM_TRADED_EXP_MSQ;
	ELSE
		v_TRAIT_INDEX_MSQ_OR_MIUN := MM_SEM_UTIL.g_TI_SEM_TRADED_EXP_MIUN;
	END IF;

	-- Get MSQ/MIUN
	GET_MSQ_MIUN(v_WORK_ID,
				 p_TIME_ZONE,
				 v_GATE_CUT_BEGIN_DATE,
				 v_GATE_CUT_END_DATE,
     			 v_GATE_WINDOW,
     			 p_STATEMENT_TYPE_ID,
				 p_POD_ID,
				 p_PSE_ID,
				 v_TRAIT_INDEX_MSQ_OR_MIUN
				 );

	-- Get LLQ
	GET_LLQ_HLQ(v_WORK_ID,
				MM_SEM_UTIL.g_TI_SEM_TRADED_EXP_LLQ,
				v_TRAIT_INDEX_MSQ_OR_MIUN
			   );

	-- Get HLQ
	GET_LLQ_HLQ(v_WORK_ID,
				MM_SEM_UTIL.g_TI_SEM_TRADED_EXP_HLQ,
				v_TRAIT_INDEX_MSQ_OR_MIUN
			   );

	-- Get ETEV
	GET_ETEV(v_WORK_ID,
			 p_TIME_ZONE,
			 v_GATE_CUT_BEGIN_DATE,
			 v_GATE_CUT_END_DATE,
			 p_POD_ID,
			 p_PSE_ID,
			 v_GATE_WINDOW,
    v_RUN_TYPE,
			 v_VAT_RATE
			);

	-- Get CTEV
	GET_CTEV(v_WORK_ID,
			 p_TIME_ZONE,
			 v_GATE_CUT_BEGIN_DATE,
			 v_GATE_CUT_END_DATE,
			 p_ASSESSMENT_DATE,
			 p_PSE_ID,
			 MM_SEM_UTIL.g_TI_SEM_TRADED_EXP_CTEV,
			 v_TRAIT_INDEX_MSQ_OR_MIUN,
			 v_VAT_RATE
			);

    POPULATE_TE_TRAIT_VALUES(v_WORK_ID, p_TRANSACTION_ID, p_STATEMENT_TYPE_ID);

	UT.PURGE_RTO_WORK(v_WORK_ID);
END GET_TRAIT_VALS_FOR_TRADED_EXP;
-----------------------------------------------------------------------------------------------------------------
PROCEDURE RUN_TRADED_EXPOSURE
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_TRACE_ON IN NUMBER,
    p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR2
	) AS
	v_ASSESSMENT_DATE 	DATE;
	v_PSE_ID			INTERCHANGE_TRANSACTION.CONTRACT_ID%TYPE;
	v_CONTRACT_ALIAS	INTERCHANGE_CONTRACT.CONTRACT_ALIAS%TYPE;
	v_MSP_RUN_TYPES STRING_COLLECTION := GET_MSP_RUN_TYPE_NAMES;
	v_MSP_RUN_TYPE_ID	NUMBER;
 v_FIRST_RUN_TYPE STATEMENT_TYPE.STATEMENT_TYPE_NAME%TYPE;
 v_LAST_RUN_TYPE STATEMENT_TYPE.STATEMENT_TYPE_NAME%TYPE;

  CURSOR c_TXNs IS
  	SELECT IT.TRANSACTION_ID,
		   IT.TRANSACTION_NAME,
		   IT.CONTRACT_ID,
		   IT.POD_ID
	  FROM INTERCHANGE_TRANSACTION		IT
	 WHERE IT.TRANSACTION_TYPE		= 'Traded Exposure'
	   AND IT.TRANSACTION_INTERVAL	= DATE_UTIL.c_NAME_30MIN
	   AND IT.IS_BID_OFFER			= 1
	   AND IT.TRAIT_CATEGORY		= 'Traded Exposure'
	   AND IT.SC_ID					= MM_SEM_UTIL.SEM_SC_ID;

BEGIN

  LOGS.START_PROCESS('Run Traded Exposure', p_TRACE_ON => p_TRACE_ON, p_TARGET_BEGIN_DATE => p_BEGIN_DATE, p_TARGET_END_DATE => p_END_DATE );

  -- For each day in the date range
  -- Make sure we have data in the SYSTEM_DATE_TIME table. 
  -- We're subtracting last run type's offset from p_END_DATE 
  -- and adding first run type's offset + 1 to the p_BEGIN_DATE
  SELECT DISTINCT FIRST_VALUE(EXTERNAL_IDENTIFIER)OVER (ORDER BY ST.STATEMENT_TYPE_ORDER DESC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING),
         LAST_VALUE(EXTERNAL_IDENTIFIER)OVER (ORDER BY ST.STATEMENT_TYPE_ORDER DESC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
  INTO v_FIRST_RUN_TYPE, v_LAST_RUN_TYPE      
  FROM EXTERNAL_SYSTEM_IDENTIFIER A,
       STATEMENT_TYPE ST
  WHERE A.ENTITY_DOMAIN_ID = EC.ED_STATEMENT_TYPE
  AND A.IDENTIFIER_TYPE = 'Run Type'
  AND A.ENTITY_ID = ST.STATEMENT_TYPE_ID;
  
  SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, 
                            p_BEGIN_DATE + TO_NUMBER(GET_DICTIONARY_VALUE('IDT_DATE_OFFSET', 0, 'MarketExchange', 'SEM', 'Intra Day Trading', v_FIRST_RUN_TYPE)), 
                            p_END_DATE + TO_NUMBER(GET_DICTIONARY_VALUE('IDT_DATE_OFFSET', 0, 'MarketExchange', 'SEM', 'Intra Day Trading', v_LAST_RUN_TYPE) + 1));
                            
  v_ASSESSMENT_DATE := TRUNC(p_BEGIN_DATE);

  FOR v_TXN IN c_TXNs LOOP
    v_CONTRACT_ALIAS := EI.GET_ENTITY_ALIAS(p_ENTITY_DOMAIN_ID => EC.ED_INTERCHANGE_CONTRACT, p_ENTITY_ID => v_TXN.CONTRACT_ID);
    v_PSE_ID := EI.GET_ID_FROM_IDENTIFIER_EXTSYS(v_CONTRACT_ALIAS, EC.ED_PSE, EC.ES_SEM, EI.g_DEFAULT_IDENTIFIER_TYPE);

      FOR v_IDX IN v_MSP_RUN_TYPES.FIRST..v_MSP_RUN_TYPES.LAST LOOP
        v_MSP_RUN_TYPE_ID := EI.GET_ID_FROM_IDENTIFIER_EXTSYS(v_MSP_RUN_TYPES(v_IDX), EC.ED_STATEMENT_TYPE, EC.ES_SEM,'Run Type');

          WHILE v_ASSESSMENT_DATE <= TRUNC(p_END_DATE) LOOP
                    LOGS.LOG_INFO('Details of Transaction whose Trait Values are being calculated:' || UTL_TCP.CRLF ||
								  ' Assessment Date: ' || v_ASSESSMENT_DATE || UTL_TCP.CRLF ||
								  ' Interchange Transaction Name: ' || v_TXN.TRANSACTION_NAME || UTL_TCP.CRLF ||
								  ' Run Type: ' || v_MSP_RUN_TYPES(v_IDX) || UTL_TCP.CRLF ||
								  ' Service Point: ' || EI.GET_ENTITY_NAME(EC.ED_SERVICE_POINT, v_TXN.POD_ID) || UTL_TCP.CRLF ||
								  ' PSE Name: ' || EI.GET_ENTITY_NAME(EC.ED_PSE, v_PSE_ID));

                    $IF $$UNIT_TEST_MODE  <> 1 OR $$UNIT_TEST_MODE IS NULL $THEN
						GET_TRAIT_VALS_FOR_TRADED_EXP(v_TXN.TRANSACTION_ID,
													  p_TIME_ZONE,
													  v_ASSESSMENT_DATE,
													  v_MSP_RUN_TYPE_ID,
													  v_TXN.POD_ID,
													  v_PSE_ID
													  );
                     $END

                     v_ASSESSMENT_DATE := v_ASSESSMENT_DATE + 1;
          END LOOP;-- Over Dates
          v_ASSESSMENT_DATE:=TRUNC(p_BEGIN_DATE);
      END LOOP;
  END LOOP;

  LOGS.STOP_PROCESS(p_MESSAGE, p_STATUS);
  COMMIT;
EXCEPTION
  WHEN OTHERS THEN
    ERRS.ABORT_PROCESS;
END RUN_TRADED_EXPOSURE;
-----------------------------------------------------------------------------------------------------------------
BEGIN
  --Cache the IDs for inital and indicative statements.
  g_STMT_INITIAL := EI.GET_ID_FROM_IDENTIFIER_EXTSYS(MM_SEM_UTIL.g_EXTID_SETTLEMENT_F, EC.ED_STATEMENT_TYPE, EC.ES_SEM, MM_SEM_UTIL.g_STATEMENT_TYPE_SETTLEMENT);
  g_STMT_INDIC := EI.GET_ID_FROM_IDENTIFIER_EXTSYS(MM_SEM_UTIL.g_EXTID_SETTLEMENT_P, EC.ED_STATEMENT_TYPE, EC.ES_SEM, MM_SEM_UTIL.g_STATEMENT_TYPE_SETTLEMENT);
  g_STMT_M4 := EI.GET_ID_FROM_IDENTIFIER_EXTSYS(MM_SEM_UTIL.g_EXTID_SETTLEMENT_F1, EC.ED_STATEMENT_TYPE, EC.ES_SEM, MM_SEM_UTIL.g_STATEMENT_TYPE_SETTLEMENT);
  g_STMT_M13 := EI.GET_ID_FROM_IDENTIFIER_EXTSYS(MM_SEM_UTIL.g_EXTID_SETTLEMENT_F2, EC.ED_STATEMENT_TYPE, EC.ES_SEM, MM_SEM_UTIL.g_STATEMENT_TYPE_SETTLEMENT);

END MM_SEM_CREDIT_SHADOW;
/
