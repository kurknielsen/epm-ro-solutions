CREATE OR REPLACE PACKAGE BODY MM_TDIE_UI IS

g_CRLF                 CONSTANT VARCHAR2(10) := UTL_TCP.CRLF;
g_HIGH_DATE            CONSTANT DATE := CONSTANTS.HIGH_DATE;
g_NI_HARMONISATION_START_DATE 	DATE;
--------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
   RETURN '$Revision: 1.4 $';
END WHAT_VERSION;
----------------------------------------------------------------------------------------------------
PROCEDURE ROI_GENERATOR_NAME_LIST
	(
	p_SUPPLIER_UNIT IN VARCHAR2,
   	p_SETTLEMENT_RUN_INDICATOR IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
v_SU_ID	NUMBER(9);
BEGIN
	IF p_SUPPLIER_UNIT = CONSTANTS.ALL_STRING THEN

        OPEN p_CURSOR FOR
            SELECT ESI.EXTERNAL_IDENTIFIER as GENERATOR_NAME
            FROM SERVICE_POINT SP,
                EXTERNAL_SYSTEM_IDENTIFIER ESI,
                -- WE WANT ALL GENERATORS, NOT JUST THOSE THAT ARE MAPPED TO A SUPPLY UNIT
                -- SO WE LOOK AT ALL THE LOCATION_IDS FROM 598 MESSAGES
                (SELECT DISTINCT TM.LOCATION_ID
                    FROM TDIE_MESSAGE TM
                    WHERE TM.MESSAGE_TYPE_CODE = c_TYPE_598
                        AND TM.SETTLEMENT_RUN_INDICATOR = p_SETTLEMENT_RUN_INDICATOR
                        AND TM.MESSAGE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE) EARN_IDS
			WHERE ESI.EXTERNAL_SYSTEM_ID = EC.ES_TDIE
				AND ESI.ENTITY_DOMAIN_ID = EC.ED_SERVICE_POINT
				AND ESI.IDENTIFIER_TYPE = EI.g_DEFAULT_IDENTIFIER_TYPE
                AND ESI.EXTERNAL_IDENTIFIER = EARN_IDS.LOCATION_ID
				AND SP.SERVICE_POINT_ID = ESI.ENTITY_ID
				AND SP.SERVICE_POINT_TYPE = 'Generation'
			ORDER BY 1;

	ELSE

		v_SU_ID := EI.GET_ID_FROM_IDENTIFIER_EXTSYS(p_SUPPLIER_UNIT, EC.ED_SERVICE_POINT, EC.ES_SEM);

		OPEN p_CURSOR FOR
			SELECT DISTINCT TGU.GENERATOR_UNIT
            FROM TDIE_GEN_UNITS TGU
            WHERE TGU.SU_SP_ID = v_SU_ID
                AND TGU.BEGIN_DATE <= p_END_DATE
                AND NVL(TGU.END_DATE, g_HIGH_DATE) >= p_BEGIN_DATE
			ORDER BY 1;

	END IF;

END ROI_GENERATOR_NAME_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE NIETD_MESSAGE_DETAILS
	(
	p_DEMAND_TYPE IN VARCHAR2,
	p_SUPPLIER_UNIT IN VARCHAR2,
	p_SETTLEMENT_RUN_INDICATOR IN VARCHAR2,
	p_SHOW_DETAIL IN NUMBER,
	p_LOAD_PROFILE IN STRING_COLLECTION,
	p_LOSS_FACTOR IN STRING_COLLECTION,
	p_UOS_TARIFF IN STRING_COLLECTION,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
v_LOAD_PROFILES	STRING_COLLECTION;
v_LOSS_FACTORS	STRING_COLLECTION;
v_UOS_TARIFFS	STRING_COLLECTION;
	----
	FUNCTION GET_COLLECTION_VAL(p_PARM IN STRING_COLLECTION) RETURN STRING_COLLECTION IS
		c_ALL CONSTANT STRING_COLLECTION := STRING_COLLECTION(CONSTANTS.ALL_STRING);
	BEGIN
		IF p_PARM IS NULL OR p_PARM.COUNT = 0 THEN
			RETURN c_ALL;
		ELSE
			RETURN p_PARM;
		END IF;
	END GET_COLLECTION_VAL;
	----
BEGIN

	IF p_SHOW_DETAIL = 1 THEN
		v_LOAD_PROFILES := GET_COLLECTION_VAL(p_LOAD_PROFILE);
		v_LOSS_FACTORS := GET_COLLECTION_VAL(p_LOSS_FACTOR);
		v_UOS_TARIFFS := GET_COLLECTION_VAL(p_UOS_TARIFF);

		OPEN p_CURSOR FOR
			SELECT TM.TDIE_ID,
				SUBSTR(FROM_CUT_AS_HED(TND.SCHEDULE_DATE, p_TIME_ZONE, DATE_UTIL.c_ABBR_30MIN),1,10) as SCHEDULE_DATE,
					TRIM(SUBSTR(FROM_CUT_AS_HED(TND.SCHEDULE_DATE, p_TIME_ZONE, DATE_UTIL.c_ABBR_30MIN),12)) as SCHEDULE_TIME,
				TND.SCHEDULE_DATE as CUT_SCHEDULE_DATE,
				TM.LOCATION_ID,
				NULL as UNDER_REVIEW,
				-- Only showing load profile for 591 - always zero for 595 and 598
				CASE WHEN p_DEMAND_TYPE = 'N591' THEN TN.LOAD_PROFILE ELSE NULL END as LOAD_PROFILE,
				TN.LINE_LOSS_FACTOR_ID as LOSS_FACTOR,
				TN.UOS_TARIFF,
				TND.ENERGY
			FROM TDIE_MESSAGE TM,
				TDIE_NIETD TN,
				TDIE_NIETD_DETAIL TND,
				TABLE(CAST(v_LOAD_PROFILES AS STRING_COLLECTION)) LP,
				TABLE(CAST(v_LOSS_FACTORS AS STRING_COLLECTION)) LF,
				TABLE(CAST(v_UOS_TARIFFS AS STRING_COLLECTION)) UT
			WHERE (TM.LOCATION_ID = p_SUPPLIER_UNIT OR p_SUPPLIER_UNIT = CONSTANTS.ALL_STRING)
				AND TM.MESSAGE_TYPE_CODE = p_DEMAND_TYPE
				AND TM.MESSAGE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
				AND TM.SETTLEMENT_RUN_INDICATOR = p_SETTLEMENT_RUN_INDICATOR
				AND TN.TDIE_ID = TM.TDIE_ID
				AND (LP.COLUMN_VALUE IN (TN.LOAD_PROFILE, CONSTANTS.ALL_STRING))
				AND (LF.COLUMN_VALUE IN (TN.LINE_LOSS_FACTOR_ID,CONSTANTS.ALL_STRING))
				AND (UT.COLUMN_VALUE IN (TN.UOS_TARIFF,CONSTANTS.ALL_STRING))
				AND TND.TDIE_DETAIL_ID = TN.TDIE_DETAIL_ID
				AND	TND.ENERGY_TYPE = c_PERIOD_ENERGY
			ORDER BY TM.LOCATION_ID, TND.SCHEDULE_DATE;
	ELSE
		OPEN p_CURSOR FOR
			SELECT TM.TDIE_ID,
				SUBSTR(FROM_CUT_AS_HED(TND.SCHEDULE_DATE, p_TIME_ZONE, DATE_UTIL.c_ABBR_30MIN),1,10) as SCHEDULE_DATE,
					TRIM(SUBSTR(FROM_CUT_AS_HED(TND.SCHEDULE_DATE, p_TIME_ZONE, DATE_UTIL.c_ABBR_30MIN),12)) as SCHEDULE_TIME,
				TND.SCHEDULE_DATE as CUT_SCHEDULE_DATE,
				TM.LOCATION_ID,
				CASE WHEN p_DEMAND_TYPE = c_TYPE_N598 THEN NULL
					ELSE (SELECT COUNT(TNUR.TDIE_ID)
						FROM TDIE_NIETD_UNDER_REVIEW TNUR
						WHERE TNUR.TDIE_ID = TM.TDIE_ID
							AND TNUR.SCHEDULE_DATE = TND.SCHEDULE_DATE)
				END as UNDER_REVIEW,
				NULL LOAD_PROFILE,
				NULL LINE_LOSS_FACTOR,
				NULL UOS_TARIFF,
				SUM(TND.ENERGY) as ENERGY
			FROM TDIE_MESSAGE TM,
				TDIE_NIETD TN,
				TDIE_NIETD_DETAIL TND
			WHERE (TM.LOCATION_ID = p_SUPPLIER_UNIT OR p_SUPPLIER_UNIT = CONSTANTS.ALL_STRING)
				AND TM.MESSAGE_TYPE_CODE = p_DEMAND_TYPE
				AND TM.MESSAGE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
				AND TM.SETTLEMENT_RUN_INDICATOR = p_SETTLEMENT_RUN_INDICATOR
				AND TN.TDIE_ID = TM.TDIE_ID
				AND TND.TDIE_DETAIL_ID = TN.TDIE_DETAIL_ID
				AND	TND.ENERGY_TYPE = c_PERIOD_ENERGY
			GROUP BY TM.TDIE_ID,
				TND.SCHEDULE_DATE,
				TM.LOCATION_ID
			ORDER BY TM.LOCATION_ID, TND.SCHEDULE_DATE;
	END IF;

END NIETD_MESSAGE_DETAILS;
----------------------------------------------------------------------------------------------------
FUNCTION GET_JURISDICTION
	(
	p_SERVICE_POINT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_IS_NPG IN BOOLEAN -- false means this is a Supplier Unit
	) RETURN VARCHAR2 IS

v_RET		VARCHAR2(32);
v_COMM_ID	NUMBER(9);

BEGIN
	IF p_IS_NPG THEN
		v_COMM_ID := EI.GET_ID_FROM_ALIAS('Energy', EC.ED_IT_COMMODITY);
		-- Determine jurisdiction based on SC of corresponding transaction
		SELECT MIN(CASE IT.SC_ID
					WHEN MM_TDIE_UTIL.g_NIE_SC_ID THEN
						c_JURISDICTION_NI
					WHEN MM_TDIE_UTIL.g_ESBN_SC_ID THEN
						c_JURISDICTION_ROI
					ELSE
						NULL
					END)
		INTO v_RET
		FROM INTERCHANGE_TRANSACTION IT
		WHERE IT.POD_ID = p_SERVICE_POINT_ID
			AND IT.TRANSACTION_TYPE = 'Generation'
			AND IT.COMMODITY_ID = v_COMM_ID
			AND ROWNUM = 1;
	ELSE
		-- Get juridition for supply unit
		SELECT MIN(JURISDICTION)
		INTO v_RET
		FROM SEM_MP_UNITS SMU
		WHERE SMU.POD_ID = p_SERVICE_POINT_ID
			AND SMU.EFFECTIVE_DATE <= NVL(p_END_DATE,g_HIGH_DATE)
			AND NVL(SMU.EXPIRATION_DATE,g_HIGH_DATE) >= p_BEGIN_DATE
			AND ROWNUM = 1;
	END IF;

	RETURN v_RET;
END GET_JURISDICTION;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_NIETD_UNDER_REVIEW
	(
	p_TDIE_ID IN NUMBER,
	p_CUT_SCHEDULE_DATE IN DATE,
	p_UNDER_REVIEW IN NUMBER
	) AS
	v_COUNT NUMBER;
BEGIN
	IF p_UNDER_REVIEW = 1 THEN

		SELECT COUNT(1) INTO v_COUNT
		FROM TDIE_NIETD_UNDER_REVIEW
		WHERE TDIE_ID = p_TDIE_ID
			AND SCHEDULE_DATE = p_CUT_SCHEDULE_DATE
			AND ENERGY_TYPE = c_PERIOD_ENERGY;

		IF v_COUNT = 0 THEN
			INSERT INTO TDIE_NIETD_UNDER_REVIEW(TDIE_ID,SCHEDULE_DATE,ENERGY_TYPE)
			VALUES
			(
			p_TDIE_ID,
			p_CUT_SCHEDULE_DATE,
			c_PERIOD_ENERGY
			);
		END IF;

	ELSE
		DELETE FROM TDIE_NIETD_UNDER_REVIEW
		WHERE TDIE_ID = p_TDIE_ID
			AND SCHEDULE_DATE = p_CUT_SCHEDULE_DATE
			AND ENERGY_TYPE = c_PERIOD_ENERGY;
	END IF;
END PUT_NIETD_UNDER_REVIEW;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_UNDER_REVIEW
	(
	p_TDIE_ID IN NUMBER,
	p_INTERVAL_PERIOD_TIMESTAMP IN DATE,
	p_UNDER_REVIEW IN NUMBER
	) AS
BEGIN
	UPDATE TDIE_AGG_CONSUMPTION
	SET UNDER_REVIEW = p_UNDER_REVIEW
	WHERE TDIE_ID = p_TDIE_ID
		AND INTERVAL_PERIOD_TIMESTAMP = p_INTERVAL_PERIOD_TIMESTAMP;

END PUT_UNDER_REVIEW;
----------------------------------------------------------------------------------------------------
FUNCTION GENERATOR_IS_MAPPED_TO_SU
	(
	p_GENERATOR_NAME IN VARCHAR2,
	p_SUPPLIER_UNIT IN VARCHAR2,
	p_DATE IN DATE
	) RETURN NUMBER IS

    v_TEST PLS_INTEGER;
BEGIN

	SELECT COUNT(1)
    INTO v_TEST
    FROM TDIE_GEN_UNITS TGU
    WHERE TGU.GENERATOR_UNIT = p_GENERATOR_NAME
        AND TGU.SUPPLIER_UNIT = p_SUPPLIER_UNIT;

    IF v_TEST > 0 THEN
        RETURN 1;
    ELSE
        RETURN 0;
    END IF;

END GENERATOR_IS_MAPPED_TO_SU;
----------------------------------------------------------------------------------------------------
PROCEDURE ROI_59X_MESSAGE_DETAILS
	(
	p_FILE_TYPE IN VARCHAR2,
	p_SUPPLIER_UNIT IN VARCHAR2,
	p_SETTLEMENT_RUN_INDICATOR IN VARCHAR2,
	p_GENERATOR_NAME IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_JURISDICTION IN VARCHAR2,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
v_INTERVAL VARCHAR2(16);

BEGIN
	-- Assert for the value of new parameter p_JURISDICTION
	ASSERT(p_JURISDICTION IS NULL OR p_JURISDICTION IN (c_JURISDICTION_ROI, c_JURISDICTION_NI),
		   'Jurisdiction should either be empty or should be ROI or NI. Got = ' || p_JURISDICTION,
		   MSGCODES.c_ERR_ARGUMENT);

	IF p_FILE_TYPE != c_TYPE_596 AND p_JURISDICTION = c_JURISDICTION_ROI  THEN
		v_INTERVAL := DATE_UTIL.c_ABBR_15MIN;
	ELSE
		v_INTERVAL := DATE_UTIL.c_ABBR_30MIN;
	END IF;

	IF p_SUPPLIER_UNIT = CONSTANTS.ALL_STRING THEN
			IF p_FILE_TYPE = c_TYPE_595 OR p_FILE_TYPE = c_TYPE_591 THEN
			OPEN p_CURSOR FOR
				SELECT SUBSTR(FROM_CUT_AS_HED(TAC.INTERVAL_PERIOD_TIMESTAMP, p_TIME_ZONE, v_INTERVAL),1,10) as SETTLEMENT_DATE,
					TRIM(SUBSTR(FROM_CUT_AS_HED(TAC.INTERVAL_PERIOD_TIMESTAMP, p_TIME_ZONE, v_INTERVAL),12)) as SETTLEMENT_TIME,
					TM.TDIE_ID,
					TAC.INTERVAL_PERIOD_TIMESTAMP,
					TM.LOCATION_ID as SUPPLIER_UNIT,
					TAC.LA_AGGREGATED_CONSUMPTION,
					TAC.AGGREGATED_CONSUMPTION,
					TAC.UNDER_REVIEW,
					CASE TM.MESSAGE_TYPE_CODE
						WHEN c_TYPE_595 THEN DETAILS.DLF_CODE
						WHEN c_TYPE_591 THEN DETAILS.LOAD_PROFILE_CODE
					END BREAK_HEADER,
					DETAILS.AGGREGATED_CONSUMPTION DLF_DTL_AGGREGATED_CONSUMPTION,
					DETAILS.LA_AGGREGATED_CONSUMPTION DLF_DTL_LA_AGG_CONSUMPTION
				FROM TDIE_MESSAGE TM,
					TDIE_AGG_CONSUMPTION TAC,
					(SELECT TACD.TDIE_ID, TACD.DLF_CODE, TACD.LOAD_PROFILE_CODE, TACDD.INTERVAL_PERIOD_TIMESTAMP,
						TACDD.AGGREGATED_CONSUMPTION, TACDD.LA_AGGREGATED_CONSUMPTION
					 FROM TDIE_AGG_CONSUMPTION_DLF TACD,
						TDIE_AGG_CONSUMPTION_DLF_DTL TACDD
					 WHERE TACDD.TDIE_DETAIL_ID = TACD.TDIE_DETAIL_ID) DETAILS
				WHERE TM.MESSAGE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
					AND EXISTS (SELECT NULL
								FROM SEM_MP_UNITS SMU
								WHERE SMU.EFFECTIVE_DATE <= p_END_DATE
								AND NVL(SMU.EXPIRATION_DATE,g_HIGH_DATE) >= p_BEGIN_DATE
								AND SMU.JURISDICTION = p_JURISDICTION
								AND SMU.RESOURCE_TYPE = 'SU'
								AND TM.LOCATION_ID = EI.GET_ENTITY_IDENTIFIER_EXTSYS(EC.ED_SERVICE_POINT, SMU.POD_ID, EC.ES_SEM))
					AND TM.SETTLEMENT_RUN_INDICATOR = p_SETTLEMENT_RUN_INDICATOR
					AND TM.MESSAGE_TYPE_CODE = p_FILE_TYPE
					AND TAC.TDIE_ID = TM.TDIE_ID
					AND DETAILS.TDIE_ID (+) = TAC.TDIE_ID
					AND DETAILS.INTERVAL_PERIOD_TIMESTAMP (+) = TAC.INTERVAL_PERIOD_TIMESTAMP;
			ELSIF p_FILE_TYPE = c_TYPE_596 THEN
				OPEN p_CURSOR FOR
					SELECT SUBSTR(FROM_CUT_AS_HED(TSC.END_TIME, p_TIME_ZONE, DATE_UTIL.c_ABBR_30MIN),1,10) as SETTLEMENT_DATE,
						TRIM(SUBSTR(FROM_CUT_AS_HED(TSC.END_TIME, p_TIME_ZONE, DATE_UTIL.c_ABBR_30MIN),12)) as SETTLEMENT_TIME,
						TM.RECIPIENT_ID as SUPPLIER_ID,
						TM.LOCATION_ID as SUPPLIER_UNIT,
						TSC.MEASURED_QUANTITY
					FROM TDIE_MESSAGE TM,
						TDIE_SMO_CONSUMPTION TSC
					WHERE FROM_CUT(TM.MESSAGE_DATE, p_TIME_ZONE) BETWEEN p_BEGIN_DATE AND p_END_DATE
						AND EXISTS (SELECT NULL
								FROM SEM_MP_UNITS SMU
								WHERE SMU.EFFECTIVE_DATE <= p_END_DATE
								AND NVL(SMU.EXPIRATION_DATE,g_HIGH_DATE) >= p_BEGIN_DATE
								AND SMU.JURISDICTION = p_JURISDICTION
								AND SMU.RESOURCE_TYPE = 'SU'
								AND TM.LOCATION_ID = EI.GET_ENTITY_IDENTIFIER_EXTSYS(EC.ED_SERVICE_POINT, SMU.POD_ID, EC.ES_SEM))
						AND TM.SETTLEMENT_RUN_INDICATOR = p_SETTLEMENT_RUN_INDICATOR
						AND TM.MESSAGE_TYPE_CODE = p_FILE_TYPE
						AND TSC.TDIE_ID = TM.TDIE_ID
				   ORDER BY 1,2,3,4;
			ELSIF p_FILE_TYPE = c_TYPE_598 THEN
				OPEN p_CURSOR FOR
					SELECT X.SETTLEMENT_DATE, X.SETTLEMENT_TIME, X.SUPPLIER_ID, X.GENERATOR_UNIT, X.SUPPLIER_UNIT, X.LA_METERED_GENERATION
					FROM
						(SELECT SUBSTR(FROM_CUT_AS_HED(TAG.INTERVAL_PERIOD_TIMESTAMP, p_TIME_ZONE, DATE_UTIL.C_ABBR_15MIN), 1, 10) AS SETTLEMENT_DATE,
								TRIM(SUBSTR(FROM_CUT_AS_HED(TAG.INTERVAL_PERIOD_TIMESTAMP, p_TIME_ZONE, DATE_UTIL.C_ABBR_15MIN), 12)) AS SETTLEMENT_TIME,
								TM.RECIPIENT_ID AS SUPPLIER_ID,
								TM.LOCATION_ID AS GENERATOR_UNIT,
								NVL(TGU.SUPPLIER_UNIT, 'N/A') AS SUPPLIER_UNIT,
								TAG.LA_METERED_GENERATION,
								TGU.JURISDICTION
						FROM TDIE_MESSAGE TM,
							 TDIE_AGG_GENERATION TAG,
							 TDIE_GEN_UNITS TGU
						/* FROM_CUT is not used on TM.MESSAGE_DATE in the query because 598 does not use CUT_TIME for the MESSAGE_DATE. */
						WHERE TM.MESSAGE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE -- Here filtering to retrieve Messages with MESSAGE_DATE between GUI BEGIN_DATE and END_DATE
							AND (p_GENERATOR_NAME = CONSTANTS.ALL_STRING OR TM.LOCATION_ID = p_GENERATOR_NAME)
							AND TM.LOCATION_ID = TGU.GENERATOR_UNIT (+) -- TDIE_GEN_UNITS returns only Generator Units that have a mapping to Supplier Units. Outer join to pull the unmapped Generator Units.
							AND TM.MESSAGE_DATE BETWEEN NVL(TGU.BEGIN_DATE(+), CONSTANTS.LOW_DATE) AND NVL(TGU.END_DATE(+), CONSTANTS.HIGH_DATE)
							AND TM.SETTLEMENT_RUN_INDICATOR = p_SETTLEMENT_RUN_INDICATOR
							AND TM.MESSAGE_TYPE_CODE = p_FILE_TYPE
							AND TAG.TDIE_ID = TM.TDIE_ID) X
							-- This 598 report alone does not need <ALL> from jurisdiction but <ALL> from entire system
					WHERE (X.SUPPLIER_UNIT = p_SUPPLIER_UNIT OR p_SUPPLIER_UNIT = CONSTANTS.ALL_STRING)
					AND (X.JURISDICTION IS NULL OR X.JURISDICTION = p_JURISDICTION)
					ORDER BY X.GENERATOR_UNIT,
							 X.SUPPLIER_UNIT,
							 X.SETTLEMENT_DATE,
							 X.SETTLEMENT_TIME;
			END IF;
	ELSIF p_SUPPLIER_UNIT <> CONSTANTS.ALL_STRING THEN
			IF p_FILE_TYPE = c_TYPE_595 OR p_FILE_TYPE = c_TYPE_591 THEN
				OPEN p_CURSOR FOR
					SELECT SUBSTR(FROM_CUT_AS_HED(TAC.INTERVAL_PERIOD_TIMESTAMP, p_TIME_ZONE, v_INTERVAL),1,10) as SETTLEMENT_DATE,
						TRIM(SUBSTR(FROM_CUT_AS_HED(TAC.INTERVAL_PERIOD_TIMESTAMP, p_TIME_ZONE, v_INTERVAL),12)) as SETTLEMENT_TIME,
						TM.TDIE_ID,
						TAC.INTERVAL_PERIOD_TIMESTAMP,
						TM.LOCATION_ID as SUPPLIER_UNIT,
						TAC.LA_AGGREGATED_CONSUMPTION,
						TAC.AGGREGATED_CONSUMPTION,
						TAC.UNDER_REVIEW,
						CASE TM.MESSAGE_TYPE_CODE
							WHEN c_TYPE_595 THEN DETAILS.DLF_CODE
							WHEN c_TYPE_591 THEN DETAILS.LOAD_PROFILE_CODE
						END BREAK_HEADER,
						DETAILS.AGGREGATED_CONSUMPTION DLF_DTL_AGGREGATED_CONSUMPTION,
						DETAILS.LA_AGGREGATED_CONSUMPTION DLF_DTL_LA_AGG_CONSUMPTION
					FROM TDIE_MESSAGE TM,
						TDIE_AGG_CONSUMPTION TAC,
						(SELECT TACD.TDIE_ID, TACD.DLF_CODE, TACD.LOAD_PROFILE_CODE, TACDD.INTERVAL_PERIOD_TIMESTAMP,
							TACDD.AGGREGATED_CONSUMPTION, TACDD.LA_AGGREGATED_CONSUMPTION
						 FROM TDIE_AGG_CONSUMPTION_DLF TACD,
							TDIE_AGG_CONSUMPTION_DLF_DTL TACDD
						 WHERE TACDD.TDIE_DETAIL_ID = TACD.TDIE_DETAIL_ID) DETAILS
					WHERE TM.MESSAGE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
						AND TM.LOCATION_ID = p_SUPPLIER_UNIT
						AND TM.SETTLEMENT_RUN_INDICATOR = p_SETTLEMENT_RUN_INDICATOR
						AND TM.MESSAGE_TYPE_CODE = p_FILE_TYPE
						AND TAC.TDIE_ID = TM.TDIE_ID
						AND DETAILS.TDIE_ID (+) = TAC.TDIE_ID
						AND DETAILS.INTERVAL_PERIOD_TIMESTAMP (+) = TAC.INTERVAL_PERIOD_TIMESTAMP;
			ELSIF p_FILE_TYPE = c_TYPE_596 THEN
				OPEN p_CURSOR FOR
					SELECT SUBSTR(FROM_CUT_AS_HED(TSC.END_TIME, p_TIME_ZONE, DATE_UTIL.c_ABBR_30MIN),1,10) as SETTLEMENT_DATE,
						TRIM(SUBSTR(FROM_CUT_AS_HED(TSC.END_TIME, p_TIME_ZONE, DATE_UTIL.c_ABBR_30MIN),12)) as SETTLEMENT_TIME,
						TM.RECIPIENT_ID as SUPPLIER_ID,
						TM.LOCATION_ID as SUPPLIER_UNIT,
						TSC.MEASURED_QUANTITY
					FROM TDIE_MESSAGE TM,
						TDIE_SMO_CONSUMPTION TSC
					WHERE FROM_CUT(TM.MESSAGE_DATE, p_TIME_ZONE) BETWEEN p_BEGIN_DATE AND p_END_DATE
						AND TM.LOCATION_ID = p_SUPPLIER_UNIT
						AND TM.SETTLEMENT_RUN_INDICATOR = p_SETTLEMENT_RUN_INDICATOR
						AND TM.MESSAGE_TYPE_CODE = p_FILE_TYPE
						AND TSC.TDIE_ID = TM.TDIE_ID
				   ORDER BY 1,2,3,4;
			ELSIF p_FILE_TYPE = c_TYPE_598 THEN
				OPEN p_CURSOR FOR
					SELECT X.*
					FROM
						(SELECT SUBSTR(FROM_CUT_AS_HED(TAG.INTERVAL_PERIOD_TIMESTAMP, p_TIME_ZONE, DATE_UTIL.C_ABBR_15MIN), 1, 10) AS SETTLEMENT_DATE,
								TRIM(SUBSTR(FROM_CUT_AS_HED(TAG.INTERVAL_PERIOD_TIMESTAMP, p_TIME_ZONE, DATE_UTIL.C_ABBR_15MIN), 12)) AS SETTLEMENT_TIME,
								TM.RECIPIENT_ID AS SUPPLIER_ID,
								TM.LOCATION_ID AS GENERATOR_UNIT,
								NVL(TGU.SUPPLIER_UNIT, 'N/A') AS SUPPLIER_UNIT,
								TAG.LA_METERED_GENERATION
						FROM TDIE_MESSAGE TM,
							 TDIE_AGG_GENERATION TAG,
							 TDIE_GEN_UNITS TGU
						/* FROM_CUT is not used on TM.MESSAGE_DATE in the query because 598 does not use CUT_TIME for the MESSAGE_DATE. */
						WHERE TM.MESSAGE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE -- Here filtering to retrieve Messages with MESSAGE_DATE between GUI BEGIN_DATE and END_DATE
							AND (p_GENERATOR_NAME = CONSTANTS.ALL_STRING OR TM.LOCATION_ID = p_GENERATOR_NAME)
							AND TM.LOCATION_ID = TGU.GENERATOR_UNIT (+) -- TDIE_GEN_UNITS returns only Generator Units that have a mapping to Supplier Units. Outer join to pull the unmapped Generator Units.
							AND TM.SETTLEMENT_RUN_INDICATOR = p_SETTLEMENT_RUN_INDICATOR
							AND TM.MESSAGE_TYPE_CODE = p_FILE_TYPE
							AND TAG.TDIE_ID = TM.TDIE_ID
							AND TM.MESSAGE_DATE >= NVL(TGU.BEGIN_DATE,CONSTANTS.LOW_DATE) -- BEGIN_DATE and END_DATE for unmapped Generator Units will be NULL. NVL should take care.
							AND TM.MESSAGE_DATE <= NVL(TGU.END_DATE,CONSTANTS.HIGH_DATE)) X
					WHERE (X.SUPPLIER_UNIT = p_SUPPLIER_UNIT)
					ORDER BY X.GENERATOR_UNIT,
							 X.SUPPLIER_UNIT,
							 X.SETTLEMENT_DATE,
							 X.SETTLEMENT_TIME;
			END IF;
	ELSE
		OPEN p_CURSOR FOR
				SELECT NULL FROM DUAL;
	END IF;
END ROI_59X_MESSAGE_DETAILS;
----------------------------------------------------------------------------------------------------
PROCEDURE SUPPLIER_UNIT_LIST
	(
	p_FILE_TYPE IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_JURISDICTION IN VARCHAR2,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
v_JURISDICTION VARCHAR2(3);
BEGIN
    -- Assert for the value of new parameter p_JURISDICTION
	ASSERT(p_JURISDICTION IS NULL OR p_JURISDICTION IN (c_JURISDICTION_ROI, c_JURISDICTION_NI),
		   'Jurisdiction should either be empty or should be ROI or NI. Got = ' || p_JURISDICTION,
		   MSGCODES.c_ERR_ARGUMENT);

	-- Get the jurisdiction assigned
	IF p_JURISDICTION IS NOT NULL THEN
		v_JURISDICTION := p_JURISDICTION;
	ELSE
		v_JURISDICTION := CASE WHEN SUBSTR(p_FILE_TYPE,1,1) = 'N' THEN c_JURISDICTION_NI ELSE c_JURISDICTION_ROI END;
	END IF;

	IF p_FILE_TYPE <> c_TYPE_598 THEN
		OPEN p_CURSOR FOR
			-- show all SUs
			SELECT DISTINCT EI.GET_ENTITY_IDENTIFIER_EXTSYS(EC.ED_SERVICE_POINT, SMU.POD_ID, EC.ES_SEM) AS SUPPLIER_UNIT
			FROM SEM_MP_UNITS SMU
			WHERE SMU.EFFECTIVE_DATE <= p_END_DATE
				AND NVL(SMU.EXPIRATION_DATE,g_HIGH_DATE) >= p_BEGIN_DATE
				AND SMU.JURISDICTION = v_JURISDICTION
				AND SMU.RESOURCE_TYPE = 'SU'
			ORDER BY 1;
	ELSE
		-- For file type '598', just show SUs with at least one
		-- mapped generator
		OPEN p_CURSOR FOR
			SELECT DISTINCT TGU.SUPPLIER_UNIT AS SUPPLIER_UNIT
			FROM TDIE_GEN_UNITS TGU
            WHERE TGU.JURISDICTION = v_JURISDICTION
                AND TGU.BEGIN_DATE <= p_END_DATE
                AND NVL(TGU.END_DATE, g_HIGH_DATE) >= p_BEGIN_DATE
			ORDER BY 1;
	END IF;

END SUPPLIER_UNIT_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE TDIE_3XX_MESSAGES
	(
	p_ERRORS_ONLY IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_METER_TYPE IN VARCHAR2,
	p_LOAD_PROFILE_CODE IN VARCHAR2,
	p_DUOS_GROUP IN VARCHAR2,
	p_SEARCH_STRING IN VARCHAR2,
	p_IS_NI_HARMONISATION_SCREEN IN VARCHAR2,
	p_CURSOR IN OUT GA.REFCURSOR,
	p_WARNING_MESSAGE OUT VARCHAR2
	) AS

v_SEARCH_STRING VARCHAR2(128) := GUI_UTIL.FIX_SEARCH_STRING(p_SEARCH_STRING);
v_PREFIX VARCHAR2(1) := CASE WHEN p_IS_NI_HARMONISATION_SCREEN = 0 THEN 'N' ELSE NULL END;

BEGIN
	p_WARNING_MESSAGE := NULL;

	IF p_METER_TYPE IN ('Interval','HH') THEN
		-- interval meter data
		OPEN p_CURSOR FOR
			SELECT TM.MESSAGE_TYPE_CODE,
				TM.TDIE_MPRN_MSG_ID as TDIE_ID,
				TM.MPRN,
				TM.READ_DATE,
        		TM.GENERATOR_UNITID,
				TM.MARKET_TIMESTAMP,
				TM.TX_REF_NUMBER,
				NVL(E.EVENT_TEXT,E.EVENT_ERRM) as ERROR_MESSAGE,
				TTE.IGNORE_ERROR
			FROM TDIE_34X_MPRN TM,
				TDIE_34X_EXCEPTION TTE,
				PROCESS_LOG_EVENT E
			WHERE TM.READ_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
				AND TM.MESSAGE_TYPE_CODE IN (v_PREFIX||'341', v_PREFIX||'342')
				AND TM.MPRN LIKE v_SEARCH_STRING
				AND TTE.TDIE_MPRN_MSG_ID(+) = TM.TDIE_MPRN_MSG_ID
				AND E.EVENT_ID(+) = TTE.EVENT_ID
				AND (p_ERRORS_ONLY <> 1 OR (E.EVENT_ID IS NOT NULL AND TTE.IGNORE_ERROR <> 1))
			ORDER BY MPRN, READ_DATE, MARKET_TIMESTAMP;
	ELSE
		-- non-interval meter data
		OPEN p_CURSOR FOR
			SELECT /*+ ordered index(tm tdie_message_ix02) use_nl(ttm) use_nl(tte) use_nl(e) */
				TM.TDIE_ID,
				TM.MESSAGE_TYPE_CODE,
				TM.TX_REF_NUMBER,
				TM.MARKET_TIMESTAMP,
				TM.LOCATION_ID as MPRN,
				TTM.DUOS_GROUP,
				TTM.LOAD_PROFILE_CODE,
				TM.MESSAGE_DATE as READ_DATE,
				TTM.NETWORKS_REFERENCE_NUMBER,
				TM.TX_REF_NUMBER,
				NVL(E.EVENT_TEXT,E.EVENT_ERRM) ERROR_MESSAGE,
				TTE.IGNORE_ERROR
			FROM TDIE_MESSAGE TM,
				TDIE_300_MPRN TTM,
				TDIE_300_EXCEPTION TTE,
				PROCESS_LOG_EVENT E
			WHERE TM.MESSAGE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
				AND TM.LOCATION_ID LIKE v_SEARCH_STRING
				AND TM.MESSAGE_TYPE_CODE IN (v_PREFIX||'300',v_PREFIX||'300S',v_PREFIX||'300W',v_PREFIX||'305',v_PREFIX||'306',v_PREFIX||'306W',v_PREFIX||'307',v_PREFIX||'307W',v_PREFIX||'310',v_PREFIX||'310W',v_PREFIX||'320',v_PREFIX||'320W',v_PREFIX||'332',v_PREFIX||'332W')
				AND TTM.TDIE_ID = TM.TDIE_ID
				AND p_LOAD_PROFILE_CODE IN (TTM.LOAD_PROFILE_CODE, CONSTANTS.ALL_STRING)
				AND p_DUOS_GROUP IN (TTM.DUOS_GROUP, CONSTANTS.ALL_STRING)
				AND TTE.TDIE_ID(+) = TM.TDIE_ID
				AND E.EVENT_ID(+) = TTE.EVENT_ID
				AND (p_ERRORS_ONLY <> 1 OR (E.EVENT_ID IS NOT NULL AND TTE.IGNORE_ERROR <> 1))
			ORDER BY MPRN, READ_DATE, MARKET_TIMESTAMP, MESSAGE_TYPE_CODE;
	END IF;

	IF p_BEGIN_DATE < g_NI_HARMONISATION_START_DATE AND p_IS_NI_HARMONISATION_SCREEN = 1 THEN
			p_WARNING_MESSAGE := '<font color="FF0000"> <b> Check NI Meter Data Messages report for pre-harmonisation messages </b></font> :';
		END IF;

END TDIE_3XX_MESSAGES;
----------------------------------------------------------------------------------------------------
PROCEDURE TDIE_3XX_SYSTEM_LABELS
	(
	p_MODEL_ID		  IN VARCHAR2,
	p_MODULE		  IN VARCHAR2,
	p_KEY1			  IN VARCHAR2,
	p_KEY2			  IN VARCHAR2,
	p_KEY3			  IN VARCHAR2,
	p_CURSOR          IN OUT GA.REFCURSOR
	) AS
BEGIN
	 OPEN p_CURSOR FOR
		  SELECT DISTINCT VALUE
		  FROM SYSTEM_LABEL
		  WHERE (p_MODEL_ID = -1 OR MODEL_ID = p_MODEL_ID OR MODEL_ID = 0)
			 AND UPPER(MODULE) = UPPER(p_MODULE)
			 AND UPPER(KEY1) LIKE UPPER(NVL(p_KEY1,CONSTANTS.UNDEFINED_ATTRIBUTE))
			 AND UPPER(KEY2) LIKE UPPER(NVL(p_KEY2,CONSTANTS.UNDEFINED_ATTRIBUTE))
			 AND UPPER(KEY3) LIKE UPPER(NVL(p_KEY3,CONSTANTS.UNDEFINED_ATTRIBUTE))
			 AND NVL(IS_HIDDEN,0) = 0
		  ORDER BY VALUE;
END TDIE_3XX_SYSTEM_LABELS;
----------------------------------------------------------------------------------------------------
PROCEDURE TDIE_3XX_MESSAGE_DETAILS
	(
	p_MESSAGE_TYPE_CODE IN VARCHAR2,
	p_TDIE_ID IN NUMBER,
	p_DETAIL_TYPE IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_IS_NI_HARMONISATION_SCREEN IN VARCHAR2,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
BEGIN

	IF p_MESSAGE_TYPE_CODE IN ('341','342','N341','N342') THEN
		-- interval meter details
		OPEN p_CURSOR FOR
			SELECT '<html><b>Serial#</b>: '||TMC.SERIAL_NUMBER||', <b>Category</b>: '||TMC.METER_CATEGORY_CODE||'</html>' AS METER,
				'<html><b>Register</b>: '||TMC.REGISTER_TYPE_CODE||' <i>(Interval: '||TMC.METERING_INTERVAL||')</i></html>' AS REGISTER,
				TMC.UOM_CODE,
				-- The format string to the FROM_CUT_AS_HED should be based on the METERING_INTERVAL
				SUBSTR(FROM_CUT_AS_HED(TMI.INTERVAL_PERIOD_TIMESTAMP, p_TIME_ZONE, CASE
																					   WHEN TMC.METERING_INTERVAL = 30 THEN
																							DATE_UTIL.c_ABBR_30MIN
																					   ELSE
																							DATE_UTIL.c_ABBR_15MIN
																					   END),1,10)	AS SCHEDULE_DATE,
				SUBSTR(FROM_CUT_AS_HED(TMI.INTERVAL_PERIOD_TIMESTAMP, p_TIME_ZONE, CASE
																					   WHEN TMC.METERING_INTERVAL = 30 THEN
																							DATE_UTIL.c_ABBR_30MIN
																					   ELSE
																							DATE_UTIL.c_ABBR_15MIN
																					   END),12) 	AS SCHEDULE_TIME,
				TMI.INTERVAL_STATUS_CODE, TMI.INTERVAL_VALUE, TMI.NET_ACTIVE_DEMAND_VALUE
			FROM TDIE_34X_MPRN TM,
				TDIE_34X_MPRN_CHANNEL TMC,
				TDIE_34X_INTERVAL TMI
			WHERE TM.TDIE_MPRN_MSG_ID = p_TDIE_ID
				AND TMC.TDIE_MPRN_MSG_ID = TM.TDIE_MPRN_MSG_ID
				AND TMI.TDIE_MPRN_CHANNEL_ID = TMC.TDIE_MPRN_CHANNEL_ID;
	ELSE
		-- non-interval meter details
		IF p_DETAIL_TYPE = 'Usage Factors' THEN
			OPEN p_CURSOR FOR
				SELECT TTUF.EFFECTIVE_FROM_DATE,
					TTUF.TIMESLOT_CODE,
					TTUF.USAGE_FACTOR,
					TTUF.USAGE_FACTOR_TYPE
				FROM TDIE_300_USAGE_FACTOR TTUF
				WHERE TTUF.TDIE_ID = p_TDIE_ID
				ORDER BY 1,2,4;
		ELSE
			OPEN p_CURSOR FOR
				SELECT TTME.SERIAL_NUMBER,
						TTME.METER_CATEGORY_CODE,
						CASE WHEN TTR.REGISTER_NODE_TYPE = CONSTANTS.UNDEFINED_ATTRIBUTE THEN NULL
								ELSE TTR.REGISTER_NODE_TYPE END as REGISTER_NODE_TYPE,
						TTR.REGISTER_TYPE_CODE,
						TTR.METER_REGISTER_SEQUENCE,
						TTR.TIMESLOT_CODE,
						TTR.UOM_CODE,
						TTR.PREVIOUS_READ_DATE,
						TTR.CONSUMPTION,
						TTR.ANNUALISED_ACTUAL_CONSUMPTION,
						TTR.ESTIMATED_USAGE_FACTOR
					FROM TDIE_300_REGISTER TTR,
						TDIE_300_METER TTME
					WHERE TTME.TDIE_ID = p_TDIE_ID
						AND TTR.SERIAL_NUMBER = TTME.SERIAL_NUMBER
						AND TTR.TDIE_ID = TTME.TDIE_ID
					ORDER BY 1,3,5,4,6,7;
		END IF;
	END IF;

END TDIE_3XX_MESSAGE_DETAILS;
----------------------------------------------------------------------------------------------------
PROCEDURE REPROCESS_INTERVAL_34X_MSGS
	(
	p_JURISDICTION IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_MARKET_TIMESTAMP IN DATE
	) AS

	v_PREFIX VARCHAR2(1) := CASE WHEN p_JURISDICTION = 'NIE' THEN 'N' ELSE NULL END;

BEGIN

	-- Find all messages for given jurisdiction and date range
	FOR v_REC IN (SELECT TDIE_MPRN_MSG_ID
				 FROM TDIE_34X_MPRN M
				 WHERE READ_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
				 	AND MESSAGE_TYPE_CODE IN (v_PREFIX||'341', v_PREFIX||'342')
					-- correlated sub-query to get "latest message as of specified market timestamp"
					AND MARKET_TIMESTAMP = (SELECT MAX(MARKET_TIMESTAMP)
											FROM TDIE_34X_MPRN M2
											WHERE M2.MPRN = M.MPRN
												AND M2.READ_DATE = M.READ_DATE
												AND M2.MARKET_TIMESTAMP <= p_MARKET_TIMESTAMP)
				) LOOP

		-- Re-process this file
		MM_TDIE_IMPORTS.PROCESS_34X_MPRN(v_REC.TDIE_MPRN_MSG_ID);

	END LOOP;

END REPROCESS_INTERVAL_34X_MSGS;
----------------------------------------------------------------------------------------------------
PROCEDURE REPROCESS_3XX_MESSAGES
	(
	p_JURISDICTION IN VARCHAR2,
	p_METER_TYPE IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_MARKET_TIMESTAMP IN DATE,
	p_PROCESS_ID OUT VARCHAR2,
	p_PROCESS_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR2
	) AS
BEGIN
	SAVEPOINT BEFORE_REPROCESS;

	LOGS.START_PROCESS('Reprocess IE T' || CONSTANTS.AMPERSAND || 'D Meter Data Messages', p_BEGIN_DATE, p_END_DATE);
	LOGS.SET_PROCESS_TARGET_PARAMETER('MARKET_TIMESTAMP', TEXT_UTIL.TO_CHAR_TIME(p_MARKET_TIMESTAMP));

	IF p_METER_TYPE IN ('Interval','HH',CONSTANTS.ALL_STRING) THEN
		REPROCESS_INTERVAL_34X_MSGS(p_JURISDICTION, p_BEGIN_DATE, p_END_DATE, p_MARKET_TIMESTAMP);
	ELSE
		-- Upcoming change request: add support for re-processing NQH/NHH messages
		ERRS.RAISE_BAD_ARGUMENT('Meter Type', p_METER_TYPE, 'Only Interval/HH meter types are supported');
	END IF;

	-- Done!
	p_PROCESS_ID := LOGS.CURRENT_PROCESS_ID;
	LOGS.STOP_PROCESS(p_MESSAGE, p_PROCESS_STATUS);
	COMMIT;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.ABORT_PROCESS(p_SAVEPOINT_NAME => 'BEFORE_REPROCESS');

END REPROCESS_3XX_MESSAGES;
----------------------------------------------------------------------------------------------------
PROCEDURE IGNORE_3XX_EXCEPTIONS
	(
	p_MESSAGE_TYPE_CODE IN STRING_COLLECTION,
	p_TDIE_ID IN NUMBER_COLLECTION
	) AS

v_IDX PLS_INTEGER;

BEGIN
	ASSERT(p_MESSAGE_TYPE_CODE IS NOT NULL, 'Message Type Codes must be specified', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_TDIE_ID IS NOT NULL, 'Message record IDs must be specified', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_MESSAGE_TYPE_CODE.COUNT = p_TDIE_ID.COUNT, 'Message Type Codes and Message record IDs are inconsistent in length', MSGCODES.c_ERR_ARGUMENT);

	v_IDX := p_TDIE_ID.FIRST;
	WHILE p_TDIE_ID.EXISTS(v_IDX) LOOP
		IF MM_TDIE_UTIL.IS_NQH_NHH_3XX_MESSAGE(p_MESSAGE_TYPE_CODE(v_IDX)) THEN
			UPDATE TDIE_300_EXCEPTION
				SET IGNORE_ERROR = 1
			WHERE TDIE_ID = p_TDIE_ID(v_IDX);
		ELSIF MM_TDIE_UTIL.IS_QH_HH_3XX_MESSAGE(p_MESSAGE_TYPE_CODE(v_IDX)) THEN
			UPDATE TDIE_34X_EXCEPTION
				SET IGNORE_ERROR = 1
			WHERE TDIE_MPRN_MSG_ID = p_TDIE_ID(v_IDX);
		ELSE
			ERRS.RAISE_BAD_ARGUMENT('Message Type Code', p_MESSAGE_TYPE_CODE(v_IDX), 'Specified message type code is not a known IE T' || CONSTANTS.AMPERSAND || 'D meter data message.');
		END IF;

		v_IDX := p_TDIE_ID.NEXT(v_IDX);
	END LOOP;

END IGNORE_3XX_EXCEPTIONS;
----------------------------------------------------------------------------------------------------
PROCEDURE PROCESS_3XX_MESSAGES
	(
	p_MESSAGE_TYPE_CODE IN STRING_COLLECTION,
	p_TDIE_ID IN NUMBER_COLLECTION,
	p_PROCESS_ID OUT VARCHAR2,
	p_PROCESS_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR2
	) AS

v_IDX 					PLS_INTEGER;
BEGIN
	ASSERT(p_MESSAGE_TYPE_CODE IS NOT NULL, 'Message Type Codes must be specified', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_TDIE_ID IS NOT NULL, 'Message record IDs must be specified', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_MESSAGE_TYPE_CODE.COUNT = p_TDIE_ID.COUNT, 'Message Type Codes and Message record IDs are inconsistent in length', MSGCODES.c_ERR_ARGUMENT);

	BEGIN
		SAVEPOINT BEFORE_PROCESS;

		LOGS.START_PROCESS('Process IE T' || CONSTANTS.AMPERSAND || 'D Meter Data Messages');

		v_IDX := p_TDIE_ID.FIRST;
		WHILE p_TDIE_ID.EXISTS(v_IDX) LOOP
			IF MM_TDIE_UTIL.IS_NQH_NHH_3XX_MESSAGE(p_MESSAGE_TYPE_CODE(v_IDX)) THEN
				MM_TDIE_IMPORTS.PROCESS_300(p_TDIE_ID(v_IDX));
			ELSIF MM_TDIE_UTIL.IS_QH_HH_3XX_MESSAGE(p_MESSAGE_TYPE_CODE(v_IDX)) THEN
				MM_TDIE_IMPORTS.PROCESS_34X_MPRN(p_TDIE_ID(v_IDX));
			ELSE
				LOGS.LOG_ERROR('Specified message type code, '||p_MESSAGE_TYPE_CODE(v_IDX)||', is not a known IE T' || CONSTANTS.AMPERSAND || 'D meter data message.');
			END IF;

			v_IDX := p_TDIE_ID.NEXT(v_IDX);
		END LOOP;

		-- Done!
		p_PROCESS_ID := LOGS.CURRENT_PROCESS_ID;
		LOGS.STOP_PROCESS(p_MESSAGE, p_PROCESS_STATUS);
		COMMIT;

	EXCEPTION
		WHEN OTHERS THEN
			ERRS.ABORT_PROCESS(p_SAVEPOINT_NAME => 'BEFORE_PROCESS');

	END;
END PROCESS_3XX_MESSAGES;
----------------------------------------------------------------------------------------------------
PROCEDURE LOG_MPRN_GEN_MAP_ERROR
    (
    p_ACCOUNT_ID IN NUMBER,
    p_MPRN IN VARCHAR2,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE
    ) AS

    v_ERR_LOG VARCHAR2(2000);
    v_FIRST BOOLEAN := TRUE;

BEGIN

    v_ERR_LOG := 'MPRN ' || p_MPRN || ' has multiple Non-Participating Generators associated over the given '
        || ' date range: ';

    v_FIRST := TRUE;

    FOR v_GEN_REC IN (SELECT SU.SERVICE_POINT_NAME, TGU.GENERATOR_UNIT, TGU.BEGIN_DATE, TGU.END_DATE
                        FROM TDIE_GEN_UNITS TGU,
                            SERVICE_POINT SU
                        WHERE TGU.ACCOUNT_ID = p_ACCOUNT_ID
                            AND TGU.BEGIN_DATE <= p_END_DATE
                            AND NVL(TGU.END_DATE, g_HIGH_DATE) >= p_BEGIN_DATE
                            AND SU.SERVICE_POINT_ID = TGU.GEN_SP_ID) LOOP

        IF NOT v_FIRST THEN
            v_ERR_LOG := v_ERR_LOG || ', ';
        ELSE
            v_FIRST := FALSE;
        END IF;

        v_ERR_LOG := v_ERR_LOG || v_GEN_REC.GENERATOR_UNIT || '(' || v_GEN_REC.SERVICE_POINT_NAME
                        || '): ' || TEXT_UTIL.TO_CHAR_DATE_RANGE(v_GEN_REC.BEGIN_DATE, v_GEN_REC.END_DATE);

    END LOOP;

    LOGS.LOG_ERROR(v_ERR_LOG);


END LOG_MPRN_GEN_MAP_ERROR;
----------------------------------------------------------------------------------------------------
PROCEDURE LOG_GEN_SU_MAP_ERROR
    (
    p_GEN_SP_ID IN NUMBER,
    p_GEN_UNIT_IDENT IN VARCHAR2,
    p_GEN_UNIT_NAME IN VARCHAR2,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE
    ) AS

    v_ERR_LOG VARCHAR2(2000);
    v_FIRST BOOLEAN := TRUE;

BEGIN

    v_ERR_LOG := 'Non-Participating Generator ' || p_GEN_UNIT_IDENT || '(' || p_GEN_UNIT_NAME
            || ') has multiple Supplier Units associated over the given date range: ';

    v_FIRST := TRUE;

    FOR v_SU_REC IN (SELECT SU.SERVICE_POINT_NAME, TGU.SUPPLIER_UNIT, TGU.BEGIN_DATE, TGU.END_DATE
                        FROM TDIE_GEN_UNITS TGU,
                            SERVICE_POINT SU
                        WHERE TGU.GEN_SP_ID = p_GEN_SP_ID
                            AND TGU.BEGIN_DATE <= p_END_DATE
                            AND NVL(TGU.END_DATE, g_HIGH_DATE) >= p_BEGIN_DATE
                            AND SU.SERVICE_POINT_ID = TGU.SU_SP_ID) LOOP

        IF NOT v_FIRST THEN
            v_ERR_LOG := v_ERR_LOG || ', ';
        ELSE
            v_FIRST := FALSE;
        END IF;

        v_ERR_LOG := v_ERR_LOG || v_SU_REC.SUPPLIER_UNIT || '(' || v_SU_REC.SERVICE_POINT_NAME
                        || '): ' || TEXT_UTIL.TO_CHAR_DATE_RANGE(v_SU_REC.BEGIN_DATE, v_SU_REC.END_DATE);

    END LOOP;

    LOGS.LOG_ERROR(v_ERR_LOG);


END LOG_GEN_SU_MAP_ERROR;
-------------------------------------------------------------------------------
PROCEDURE EARN_ID_MPRN_SU_MAPPING(p_CURSOR IN OUT GA.REFCURSOR) AS
  c_ES_TDIE          CONSTANT NUMBER(9) := EC.ES_TDIE;
  c_ES_SEM           CONSTANT NUMBER(9) := EC.ES_SEM;
  c_ED_SERVICE_POINT CONSTANT NUMBER(9) := EC.ED_SERVICE_POINT;
  c_ED_ESP           CONSTANT NUMBER(9) := EC.ED_ESP;
  c_SP_TYPE_GEN      CONSTANT SERVICE_POINT.SERVICE_POINT_TYPE%TYPE := 'Generation';
  v_SU_MAP_REC                TDIE_EARN_ID_MPRN_SU_MAPPING%ROWTYPE;
  v_SU_ERROR_REC              TDIE_EARN_ID_MPRN_SU_MAPPING%ROWTYPE;
BEGIN

  -- STEP 1a -------------------------------------------------------------------
  -- Get the schedule group assignment for the EARN_IDs
  --   * log error when none exists
  --   * log error if more than one exists per EARN_ID
  FOR A IN (-- NO schedule group assignment -----------
            WITH E AS (SELECT *
                         FROM EXTERNAL_SYSTEM_IDENTIFIER E
                        WHERE E.EXTERNAL_SYSTEM_ID = c_ES_TDIE
                          AND E.ENTITY_DOMAIN_ID   = c_ED_SERVICE_POINT)
             SELECT SP.SERVICE_POINT_ID     AS EARN_ID,
                    SP.SERVICE_POINT_NAME   AS EARN_NAME,
                    SG.SCHEDULE_GROUP_NAME  AS SCHEDULE_GROUP_NAME,
                    SG.SCHEDULE_GROUP_ID    AS SCHEDULE_GROUP_ID,
                    ('EARN ID: '
                     ||SP.SERVICE_POINT_NAME
                     ||' must be assigned to a schedule group. '
                     ) AS COMMENTS
               FROM SERVICE_POINT   SP,
                    SCHEDULE_GROUP  SG,
                    E
              WHERE SP.SERVICE_POINT_ID   = E.ENTITY_ID
                AND SP.SERVICE_POINT_TYPE = c_SP_TYPE_GEN
                AND SP.SERVICE_POINT_ID   = SG.SERVICE_POINT_ID(+)
                AND SG.SERVICE_POINT_ID IS NULL
            UNION ALL
            -- These have schedule group assignment -----------
             SELECT SP.SERVICE_POINT_ID     AS EARN_ID,
                    SP.SERVICE_POINT_NAME   AS EARN_NAME,
                    SG.SCHEDULE_GROUP_NAME  AS SCHEDULE_GROUP_NAME,
                    SG.SCHEDULE_GROUP_ID    AS SCHEDULE_GROUP_ID,
                    NULL                    AS COMMENTS
               FROM SERVICE_POINT   SP,
                    SCHEDULE_GROUP  SG,
                    E
              WHERE SP.SERVICE_POINT_ID   = E.ENTITY_ID
                AND SP.SERVICE_POINT_TYPE = c_SP_TYPE_GEN
                AND SP.SERVICE_POINT_ID   = SG.SERVICE_POINT_ID(+)
                AND SG.SERVICE_POINT_ID IS NOT NULL
               ORDER BY EARN_NAME,
                        SCHEDULE_GROUP_NAME
            ) LOOP

        UPDATE TDIE_EARN_ID_MPRN_SU_MAPPING TMAP
           SET TMAP.SCHEDULE_GROUP_ID   = A.SCHEDULE_GROUP_ID,
               TMAP.SCHEDULE_GROUP_NAME = A.SCHEDULE_GROUP_NAME,
               TMAP.COMMENTS = (CASE
                                   WHEN TMAP.COMMENTS IS NULL THEN
                                      -- FIRST DUPLICATE ASSIGNMENT FOUND.
                                      'EARN ID: '||A.EARN_NAME||' is assigned to more than one schedule group.'||
                                      '  Groups: '||TMAP.SCHEDULE_GROUP_NAME||', '||A.SCHEDULE_GROUP_NAME||'. '
                                   ELSE
                                      (CASE
                                         WHEN INSTR(TMAP.COMMENTS,'Groups:',1) > 0 THEN
                                            -- MULTIPLE DUPLICATE ASSIGNEMENT
                                            RTRIM(TMAP.COMMENTS,'.')||', '||A.SCHEDULE_GROUP_NAME||'.'
                                         ELSE
                                           g_CRLF||
                                           'EARN ID: '||A.EARN_NAME||' is assigned to more than one schedule group.'||
                                           '  Groups: '||TMAP.SCHEDULE_GROUP_NAME||', '||A.SCHEDULE_GROUP_NAME||'. '
                                       END)
                                END)
           WHERE TMAP.EARN_ID = A.EARN_ID;

        IF SQL%ROWCOUNT = 0 THEN
          INSERT INTO TDIE_EARN_ID_MPRN_SU_MAPPING (EARN_ID,
                                                    EARN_NAME,
                                                    SCHEDULE_GROUP_ID,
                                                    SCHEDULE_GROUP_NAME,
                                                    COMMENTS)
                                            VALUES (A.EARN_ID,
                                                    A.EARN_NAME,
                                                    A.SCHEDULE_GROUP_ID,
                                                    A.SCHEDULE_GROUP_NAME,
                                                    A.COMMENTS);
       END IF;
  END LOOP;
  -- STEP 1a -------------------------------------------------------------------

  -- STEP 1b ------------------------------------------------------------------
  -- For EARN ID records that have multiple schedule group assignements, NULL out
  -- the schedule_group_id and schedule_group_name fields.  Needed to keep them
  -- in STEP 1a to report the error log as per functional specification.
  UPDATE TDIE_EARN_ID_MPRN_SU_MAPPING TMAP
     SET TMAP.SCHEDULE_GROUP_ID = NULL,
         TMAP.SCHEDULE_GROUP_NAME = NULL
   WHERE TMAP.COMMENTS LIKE '%is assigned to more than one schedule group.%';
  -- STEP 1b ------------------------------------------------------------------

  -- STEP 2 -------------------------------------------------------------------
  -- Get the associated MPRNs for the given EARN_IDs that have a valid schedule group assignment.
  -- At this point we have a distinct list of EARN IDs from step 1a/b.  Since there could be multiple
  -- MPRNs associated with each EARN ID. An update is attempted first to see if an exact match can be
  -- found (assume NULL table data will be replaced with query value data). The insert comes into play
  -- when there are multiple MPRN records associated.
  -- Were also getting the SU name (ESP_EXTERNAL_IDENTIFIER) and the begin and end date for the supplier
  -- unit since it is available within this complex join.  We use the external identifier to traverse
  -- back to the associated account for the supplier unit.
  BEGIN
     FOR B IN (
              WITH -- E table of EARN IDs ------------------------------------------------------------
                   E AS (SELECT TMAP.EARN_ID             AS EARN_ID,
                                TMAP.EARN_NAME           AS EARN_NAME,
                                TMAP.SCHEDULE_GROUP_ID   AS SCHEDULE_GROUP_ID,
                                TMAP.SCHEDULE_GROUP_NAME AS SCHEDULE_GROUP_NAME,
                                TMAP.COMMENTS            AS COMMENTS
                           FROM TDIE_EARN_ID_MPRN_SU_MAPPING TMAP
                          WHERE TMAP.SCHEDULE_GROUP_ID IS NOT NULL
                         ),
                   -- M table OF MPRNs --------------------------------------------------------------
                   M AS (SELECT DISTINCT
                                ACT.ACCOUNT_NAME             AS MPRN_NAME,
                                ACT.ACCOUNT_ID               AS MPRN_ID,
                                MSG.BEGIN_DATE               AS MPRN_BEGIN_DATE,
                                MSG.END_DATE                 AS MPRN_END_DATE,
                                MSG.SCHEDULE_GROUP_ID        AS SCHEDULE_GROUP_ID,
                                ACT.ACCOUNT_ID               AS ACCOUNT_ID
                           FROM ACCOUNT                  ACT,
                                ACCOUNT_SERVICE_LOCATION ASL,
                                SERVICE_LOCATION_METER   SLM,
                                METER_SCHEDULE_GROUP     MSG,
                                METER                    MTR
                          WHERE ACT.ACCOUNT_MODEL_OPTION = 'Meter'
                            AND ACT.ACCOUNT_ID           = ASL.ACCOUNT_ID
                            AND ASL.SERVICE_LOCATION_ID  = SLM.SERVICE_LOCATION_ID
                            AND SLM.METER_ID             = MSG.METER_ID
                            AND SLM.BEGIN_DATE           <= NVL(MSG.END_DATE, g_HIGH_DATE)
                            AND NVL(SLM.END_DATE, g_HIGH_DATE) > MSG.BEGIN_DATE
                            AND MTR.METER_ID             = MSG.METER_ID
                            AND MTR.METER_STATUS         = 'Active'
                            AND MTR.METER_TYPE           = 'Interval'
                        ),
                   -- ESP table of ACCOUNT/ESP RELATIONSHIPS
                   ESP AS (SELECT ACT.ACCOUNT_ID           AS ACCOUNT_ID,
                                  AE.ESP_ID                AS ESP_ID,
                                  ESP.ESP_NAME             AS ESP_NAME,
                                  ESI.EXTERNAL_IDENTIFIER  AS ESP_EXTERNAL_IDENTIFIER,
                                  AE.BEGIN_DATE            AS ESP_BEGIN_DATE,
                                  AE.END_DATE              AS ESP_END_DATE
                             FROM ACCOUNT                    ACT,
                                  ACCOUNT_ESP                AE,
                                  ENERGY_SERVICE_PROVIDER    ESP,
                                  EXTERNAL_SYSTEM_IDENTIFIER ESI
                            WHERE ACT.ACCOUNT_ID = AE.ACCOUNT_ID
                              AND AE.ESP_ID      = ESP.ESP_ID
                              AND ESI.EXTERNAL_SYSTEM_ID = c_ES_SEM
                              AND ESI.ENTITY_DOMAIN_ID = c_ED_ESP
                              AND ESI.ENTITY_ID = ESP.ESP_ID
                           )
              SELECT DISTINCT
                     E.EARN_ID,
                     E.EARN_NAME,
                     M.MPRN_ID,
                     M.MPRN_NAME,
                     M.MPRN_BEGIN_DATE,
                     M.MPRN_END_DATE,
                     E.SCHEDULE_GROUP_NAME,
                     E.SCHEDULE_GROUP_ID,
                     (CASE
                        WHEN M.MPRN_ID IS NULL THEN
                          CASE
                             WHEN E.COMMENTS IS NULL THEN
                               'EARN ID: '||E.EARN_NAME||' is missing an MPRN assignment. '
                             ELSE
                               E.COMMENTS||g_CRLF||
                               'EARN ID: '||E.EARN_NAME||' is missing an MPRN assignment. '
                          END
                        ELSE
                          E.COMMENTS
                     END) AS COMMENTS,
                     ESP.ESP_EXTERNAL_IDENTIFIER AS ESP_EXTERNAL_IDENTIFIER,
                     ESP.ESP_BEGIN_DATE,
                     ESP.ESP_END_DATE
                FROM E,
                     M,
                     ESP
               WHERE M.SCHEDULE_GROUP_ID(+)                = E.SCHEDULE_GROUP_ID
                 AND ESP.ACCOUNT_ID(+)                     = M.ACCOUNT_ID
                 AND ESP.ESP_BEGIN_DATE(+)                <= NVL(M.MPRN_END_DATE, g_HIGH_DATE)
                 AND NVL(ESP.ESP_END_DATE(+), g_HIGH_DATE) > M.MPRN_BEGIN_DATE
       ) LOOP

        UPDATE TDIE_EARN_ID_MPRN_SU_MAPPING TMAP
           SET TMAP.MPRN_ID                 = B.MPRN_ID,
               TMAP.MPRN_NAME               = B.MPRN_NAME,
               TMAP.MPRN_BEGIN_DATE         = B.MPRN_BEGIN_DATE,
               TMAP.MPRN_END_DATE           = B.MPRN_END_DATE,
               TMAP.COMMENTS                = B.COMMENTS,
               TMAP.ESP_EXTERNAL_IDENTIFIER = B.ESP_EXTERNAL_IDENTIFIER,
               TMAP.SU_BEGIN_DATE           = B.ESP_BEGIN_DATE,
               TMAP.SU_END_DATE             = B.ESP_END_DATE
         WHERE TMAP.EARN_ID = B.EARN_ID
           AND (TMAP.MPRN_ID IS NULL OR TMAP.MPRN_ID = B.MPRN_ID)
           AND (TMAP.MPRN_BEGIN_DATE IS NULL OR TMAP.MPRN_BEGIN_DATE = B.MPRN_BEGIN_DATE)
           AND (TMAP.MPRN_END_DATE IS NULL OR TMAP.MPRN_END_DATE = B.MPRN_END_DATE)
           AND (TMAP.ESP_EXTERNAL_IDENTIFIER IS NULL OR TMAP.ESP_EXTERNAL_IDENTIFIER = B.ESP_EXTERNAL_IDENTIFIER)
           AND (TMAP.SU_BEGIN_DATE IS NULL OR TMAP.SU_BEGIN_DATE = B.ESP_BEGIN_DATE)
           AND (TMAP.SU_END_DATE IS NULL OR TMAP.SU_END_DATE = B.ESP_END_DATE);

         IF SQL%ROWCOUNT = 0 THEN
           INSERT INTO TDIE_EARN_ID_MPRN_SU_MAPPING (EARN_ID,
                                                     EARN_NAME,
                                                     MPRN_ID,
                                                     MPRN_NAME,
                                                     MPRN_BEGIN_DATE,
                                                     MPRN_END_DATE,
                                                     SCHEDULE_GROUP_NAME,
                                                     SCHEDULE_GROUP_ID,
                                                     COMMENTS,
                                                     ESP_EXTERNAL_IDENTIFIER,
                                                     SU_BEGIN_DATE,
                                                     SU_END_DATE)
                                             VALUES (B.EARN_ID,
                                                     B.EARN_NAME,
                                                     B.MPRN_ID,
                                                     B.MPRN_NAME,
                                                     B.MPRN_BEGIN_DATE,
                                                     B.MPRN_END_DATE,
                                                     B.SCHEDULE_GROUP_NAME,
                                                     B.SCHEDULE_GROUP_ID,
                                                     B.COMMENTS,
                                                     B.ESP_EXTERNAL_IDENTIFIER,
                                                     B.ESP_BEGIN_DATE,
                                                     B.ESP_END_DATE);
         END IF;-- IF SQL%ROWCOUNT = 0 THEN

      END LOOP;--FOR B IN (...

  END; -- STEP 2 --------------------------------------------------------------

  -- STEP 3 -------------------------------------------------------------------
  -- FIND THE ASSOCIATED SUPPLIER UNIT (SINGLE EARN ID/SU MAPPING PER DAY)
  -- The association between EARN and SU should be one to one on any given day, if not then log an error.
  -- At this point we have EARN IDs, and all the MPRN's accociated with each.  We also have the SU external identifier
  -- and the begin and end dates of the supplier unit association.  We now need to look the service point
  -- for the supplier unit.
  FOR su IN (SELECT TMAP.*
               FROM TDIE_EARN_ID_MPRN_SU_MAPPING  TMAP
              ORDER BY TMAP.EARN_NAME,
                       TMAP.MPRN_NAME,
                       TMAP.MPRN_BEGIN_DATE,
                       TMAP.MPRN_END_DATE,
                       TMAP.ESP_EXTERNAL_IDENTIFIER,
                       TMAP.SU_BEGIN_DATE,
                       TMAP.SU_END_DATE
             ) LOOP
     BEGIN

        SELECT SP.SERVICE_POINT_ID   AS SU_ID,
               SP.SERVICE_POINT_NAME AS SU_NAME
          INTO v_SU_MAP_REC.SU_ID,
               v_SU_MAP_REC.SU_NAME
          FROM SERVICE_POINT              SP,
               EXTERNAL_SYSTEM_IDENTIFIER ESI
         WHERE ESI.EXTERNAL_IDENTIFIER    = SU.ESP_EXTERNAL_IDENTIFIER
           AND ESI.EXTERNAL_SYSTEM_ID     = c_ES_SEM
           AND ESI.ENTITY_DOMAIN_ID       = c_ED_SERVICE_POINT
           AND SP.SERVICE_POINT_ID        = ESI.ENTITY_ID;


        UPDATE TDIE_EARN_ID_MPRN_SU_MAPPING TMAP
           SET TMAP.SU_ID         = v_SU_MAP_REC.SU_ID,
               TMAP.SU_NAME       = v_SU_MAP_REC.SU_NAME
         WHERE TMAP.EARN_ID         = SU.EARN_ID
           AND (TMAP.MPRN_ID IS NULL OR TMAP.MPRN_ID = SU.MPRN_ID)
           AND (TMAP.MPRN_BEGIN_DATE IS NULL OR TMAP.MPRN_BEGIN_DATE = SU.MPRN_BEGIN_DATE)
           AND (TMAP.MPRN_END_DATE IS NULL OR TMAP.MPRN_END_DATE = SU.MPRN_END_DATE)
           AND (TMAP.ESP_EXTERNAL_IDENTIFIER IS NULL OR TMAP.ESP_EXTERNAL_IDENTIFIER = SU.ESP_EXTERNAL_IDENTIFIER)
           AND (TMAP.SU_BEGIN_DATE IS NULL OR TMAP.SU_BEGIN_DATE = SU.SU_BEGIN_DATE)
           AND (TMAP.SU_END_DATE IS NULL OR TMAP.SU_END_DATE = SU.SU_END_DATE);

        EXCEPTION
           WHEN NO_DATA_FOUND THEN
             UPDATE TDIE_EARN_ID_MPRN_SU_MAPPING TMAP
                SET TMAP.SU_BEGIN_DATE = NULL,
                    TMAP.SU_END_DATE   = NULL,
                    TMAP.COMMENTS = (CASE
                                        WHEN SU.COMMENTS IS NULL THEN
                                          'EARN ID: '||SU.EARN_NAME||' must be associated with a supplier unit. '
                                        ELSE
                                          SU.COMMENTS||g_CRLF||
                                          'EARN ID: '||SU.EARN_NAME||' must be associated with a supplier unit. '
                                     END)
              WHERE TMAP.EARN_ID = SU.EARN_ID
                AND (TMAP.MPRN_ID IS NULL OR TMAP.MPRN_ID = SU.MPRN_ID)
                AND (TMAP.MPRN_BEGIN_DATE IS NULL OR TMAP.MPRN_BEGIN_DATE = SU.MPRN_BEGIN_DATE)
                AND (TMAP.MPRN_END_DATE IS NULL OR TMAP.MPRN_END_DATE = SU.MPRN_END_DATE)
                AND (TMAP.ESP_EXTERNAL_IDENTIFIER IS NULL OR TMAP.ESP_EXTERNAL_IDENTIFIER = SU.ESP_EXTERNAL_IDENTIFIER)
                AND (TMAP.SU_BEGIN_DATE IS NULL OR TMAP.SU_BEGIN_DATE = SU.SU_BEGIN_DATE)
                AND (TMAP.SU_END_DATE IS NULL OR TMAP.SU_END_DATE = SU.SU_END_DATE);

           WHEN TOO_MANY_ROWS THEN
             UPDATE TDIE_EARN_ID_MPRN_SU_MAPPING TMAP
                SET TMAP.SU_BEGIN_DATE = NULL,
                    TMAP.SU_END_DATE   = NULL,
                    TMAP.COMMENTS = (CASE
                                        WHEN SU.COMMENTS IS NULL THEN
                                          'EARN ID: '||SU.EARN_NAME||' is associated with more than one supplier unit. '
                                        ELSE
                                          SU.COMMENTS||g_CRLF||
                                          'EARN ID: '||SU.EARN_NAME||' is associated with more than one supplier unit. '
                                     END)
              WHERE TMAP.EARN_ID         = SU.EARN_ID
                AND (TMAP.MPRN_ID IS NULL OR TMAP.MPRN_ID = SU.MPRN_ID)
                AND (TMAP.MPRN_BEGIN_DATE IS NULL OR TMAP.MPRN_BEGIN_DATE = SU.MPRN_BEGIN_DATE)
                AND (TMAP.MPRN_END_DATE IS NULL OR TMAP.MPRN_END_DATE = SU.MPRN_END_DATE)
                AND (TMAP.ESP_EXTERNAL_IDENTIFIER IS NULL OR TMAP.ESP_EXTERNAL_IDENTIFIER = SU.ESP_EXTERNAL_IDENTIFIER)
                AND (TMAP.SU_BEGIN_DATE IS NULL OR TMAP.SU_BEGIN_DATE = SU.SU_BEGIN_DATE)
                AND (TMAP.SU_END_DATE IS NULL OR TMAP.SU_END_DATE = SU.SU_END_DATE);

         WHEN OTHERS THEN
           RAISE;
     END;

  END LOOP;--FOR su IN
  -- STEP 3 -------------------------------------------------------------------

  -- STEP 4 -------------------------------------------------------------------
  v_SU_ERROR_REC := NULL;
  FOR SU_ERROR IN (SELECT DISTINCT
                          EARN_ID,
                          EARN_NAME,
                          ESP_EXTERNAL_IDENTIFIER,
                          SU_BEGIN_DATE,
                          NVL(SU_END_DATE, g_HIGH_DATE) AS SU_END_DATE
                     FROM TDIE_EARN_ID_MPRN_SU_MAPPING
                    WHERE ESP_EXTERNAL_IDENTIFIER IS NOT NULL
                     ORDER BY EARN_ID,
                              ESP_EXTERNAL_IDENTIFIER,
                              SU_BEGIN_DATE,
                              SU_END_DATE
                   ) LOOP

     CASE -- Case1
        -- First record only
        WHEN (v_SU_ERROR_REC.EARN_ID IS NULL OR
              v_SU_ERROR_REC.EARN_ID <> SU_ERROR.EARN_ID) THEN
          v_SU_ERROR_REC.EARN_ID                 := SU_ERROR.EARN_ID;
          v_SU_ERROR_REC.EARN_NAME               := SU_ERROR.EARN_NAME;
          v_SU_ERROR_REC.ESP_EXTERNAL_IDENTIFIER := SU_ERROR.ESP_EXTERNAL_IDENTIFIER;
          v_SU_ERROR_REC.SU_BEGIN_DATE           := SU_ERROR.SU_BEGIN_DATE;
          v_SU_ERROR_REC.SU_END_DATE             := SU_ERROR.SU_END_DATE;

        -- When same EARN ID as previous record.
        WHEN v_SU_ERROR_REC.EARN_ID = SU_ERROR.EARN_ID THEN
           CASE --Case2
               WHEN v_SU_ERROR_REC.ESP_EXTERNAL_IDENTIFIER <> SU_ERROR.ESP_EXTERNAL_IDENTIFIER THEN
                  -- Check to make sure that the dates for the two records are exclusive.
                  -- If the date range of the current record falls within the date range of the
                  -- previous record then throw error.
                  IF (v_SU_ERROR_REC.SU_BEGIN_DATE >= SU_ERROR.SU_BEGIN_DATE AND
                      v_SU_ERROR_REC.SU_BEGIN_DATE  < SU_ERROR.SU_END_DATE) OR
                     (v_SU_ERROR_REC.SU_END_DATE    > SU_ERROR.SU_BEGIN_DATE AND
                      v_SU_ERROR_REC.SU_END_DATE   <= SU_ERROR.SU_END_DATE) THEN

                     UPDATE TDIE_EARN_ID_MPRN_SU_MAPPING TMAP
                        SET TMAP.SU_ID         = NULL,
                            TMAP.SU_NAME       = NULL,
                            TMAP.SU_BEGIN_DATE = NULL,
                            TMAP.SU_END_DATE   = NULL,
                            TMAP.COMMENTS = (CASE
                                                WHEN TMAP.COMMENTS IS NULL THEN
                                                  'EARN ID: '||SU_ERROR.EARN_NAME||' is associated with more than one supplier unit. '
                                                ELSE
                                                  TMAP.COMMENTS||g_CRLF||
                                                  'EARN ID: '||SU_ERROR.EARN_NAME||' is associated with more than one supplier unit. '
                                             END)
                      WHERE TMAP.EARN_ID = SU_ERROR.EARN_ID;

                    v_SU_ERROR_REC.EARN_ID                 := SU_ERROR.EARN_ID;
                    v_SU_ERROR_REC.EARN_NAME               := SU_ERROR.EARN_NAME;
                    v_SU_ERROR_REC.ESP_EXTERNAL_IDENTIFIER := SU_ERROR.ESP_EXTERNAL_IDENTIFIER;
                    v_SU_ERROR_REC.SU_BEGIN_DATE           := SU_ERROR.SU_BEGIN_DATE;
                    v_SU_ERROR_REC.SU_END_DATE             := SU_ERROR.SU_END_DATE;

                  ELSE
                    -- Dates are exclusive so not an error case.
                    v_SU_ERROR_REC.EARN_ID                 := SU_ERROR.EARN_ID;
                    v_SU_ERROR_REC.EARN_NAME               := SU_ERROR.EARN_NAME;
                    v_SU_ERROR_REC.ESP_EXTERNAL_IDENTIFIER := SU_ERROR.ESP_EXTERNAL_IDENTIFIER;
                    v_SU_ERROR_REC.SU_BEGIN_DATE           := SU_ERROR.SU_BEGIN_DATE;
                    v_SU_ERROR_REC.SU_END_DATE             := SU_ERROR.SU_END_DATE;
                 END IF;--IF (v_SU_ERROR_REC.SU_BEGIN_DATE >= SU_ERROR.SU_BEGIN_DATE...

            ELSE
               -- EARN ID and ESP are the same as previous record, not an error case.
               v_SU_ERROR_REC.EARN_ID                 := SU_ERROR.EARN_ID;
               v_SU_ERROR_REC.EARN_NAME               := SU_ERROR.EARN_NAME;
               v_SU_ERROR_REC.ESP_EXTERNAL_IDENTIFIER := SU_ERROR.ESP_EXTERNAL_IDENTIFIER;
               v_SU_ERROR_REC.SU_BEGIN_DATE           := SU_ERROR.SU_BEGIN_DATE;
               v_SU_ERROR_REC.SU_END_DATE             := SU_ERROR.SU_END_DATE;
            END CASE; -- Case2

     END CASE; --Case1

  END LOOP;--FOR SU_ERROR IN
  -- STEP 4 -------------------------------------------------------------------

  -- RETURN RESULTS FROM TEMPORARY TABLE.
  OPEN p_CURSOR FOR
     SELECT E.EARN_NAME,
            E.MPRN_NAME,
            E.MPRN_BEGIN_DATE,
            E.MPRN_END_DATE,
            E.SU_NAME,
            E.SU_BEGIN_DATE,
            E.SU_END_DATE,
            E.COMMENTS
       FROM TDIE_EARN_ID_MPRN_SU_MAPPING E
       ORDER BY E.EARN_NAME,
                E.MPRN_NAME,
                E.MPRN_BEGIN_DATE,
                E.MPRN_END_DATE,
                E.SU_NAME,
                E.SU_BEGIN_DATE,
                E.SU_END_DATE;

   -- Clean Up temp tables for multiple calls.
   DELETE FROM TDIE_EARN_ID_MPRN_SU_MAPPING;
   COMMIT;

END EARN_ID_MPRN_SU_MAPPING;

----------------------------------------------------------------------------------------------------
BEGIN
	g_NI_HARMONISATION_START_DATE := TO_DATE(GET_DICTIONARY_VALUE(p_SETTING_NAME	=> 'NI Harmonisation Start Date'
																 ,p_MODEL_ID 		=> 0
																 ,p_MODULE 		=> 'MarketExchange'
																 ,p_KEY1			=> 'TDIE'
																 ,p_KEY2			=> 'Harmonisation'), 'YYYY-MM-DD');
END MM_TDIE_UI;
/
