CREATE OR REPLACE TRIGGER HOLIDAY_SCHEDULE_CHANGE
  AFTER UPDATE OR INSERT OR DELETE ON HOLIDAY_SCHEDULE  
  FOR EACH ROW
BEGIN

	-- UPDATE THE DAY_NAME FOR THE OLD AND NEW HOLIDAY_SET FOR THE OLD AND NEW HOLIDAY
	-- (BOTH COLUMNS COULD HAVE CHANGED)
	MERGE INTO TEMPLATE_DATES TD
		USING (SELECT TD.TIME_ZONE,
					TD.TEMPLATE_ID,
					TD.HOLIDAY_SET_ID,
					TD.LOCAL_DATE,
					TD.CUT_BEGIN_DATE,
					TD.CUT_END_DATE,
					TGT.DAY_TYPE_ID AS NEW_DAY_TYPE_ID
				FROM TEMPLATE_DATES TD,
					TEMPLATE_DAY_TYPE SRC,
					TEMPLATE_DAY_TYPE TGT,
					(SELECT :NEW.HOLIDAY_SET_ID AS HOLIDAY_SET_ID, HO.HOLIDAY_DATE
						FROM HOLIDAY_OBSERVANCE HO
						WHERE HO.HOLIDAY_ID = :NEW.HOLIDAY_ID) HOL
				WHERE TD.HOLIDAY_SET_ID IN (:OLD.HOLIDAY_SET_ID, :NEW.HOLIDAY_SET_ID)
					AND TD.LOCAL_DATE IN (SELECT HO.HOLIDAY_DATE
											FROM HOLIDAY_OBSERVANCE HO
											WHERE HO.HOLIDAY_ID IN (:OLD.HOLIDAY_ID, :NEW.HOLIDAY_ID) )
					AND HOL.HOLIDAY_SET_ID (+) = TD.HOLIDAY_SET_ID
					AND HOL.HOLIDAY_DATE (+) = TD.LOCAL_DATE
					AND SRC.DAY_TYPE_ID = TD.DAY_TYPE_ID
					AND TGT.TEMPLATE_ID = SRC.TEMPLATE_ID
					AND TGT.SEASON_ID = SRC.SEASON_ID
					AND TGT.DST_TYPE = SRC.DST_TYPE
					AND TGT.DAY_NAME = (CASE WHEN HOL.HOLIDAY_SET_ID IS NOT NULL THEN
											'Hol'
											ELSE TO_CHAR(TD.LOCAL_DATE, 'Dy') END)) UPD
		ON (UPD.TIME_ZONE = TD.TIME_ZONE
			AND UPD.TEMPLATE_ID = TD.TEMPLATE_ID
			AND UPD.HOLIDAY_SET_ID = TD.HOLIDAY_SET_ID
			AND UPD.LOCAL_DATE = TD.LOCAL_DATE)
		WHEN MATCHED THEN
			UPDATE SET TD.DAY_TYPE_ID = UPD.NEW_DAY_TYPE_ID;
  
END HOLIDAY_SCHEDULE_CHANGE;
/
