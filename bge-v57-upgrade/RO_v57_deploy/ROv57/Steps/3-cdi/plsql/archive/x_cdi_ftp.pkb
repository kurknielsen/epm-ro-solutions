CREATE OR REPLACE PACKAGE BODY CDI_FTP AS

TYPE t_STRING_TABLE IS TABLE OF VARCHAR2(32766);

c_PACKAGE                      CONSTANT VARCHAR2(16) := 'CDI_FTP';
c_DATA_CONNECTION_ALREADY_OPEN CONSTANT PLS_INTEGER := 125;
c_FILE_STATUS_OK               CONSTANT PLS_INTEGER := 150;
c_COMMAND_NOT_IMPLEMENTED      CONSTANT PLS_INTEGER := 202;
c_SERVICE_READY_FOR_NEW_USER   CONSTANT PLS_INTEGER := 220;
c_ENTERING_PASSIVE_MODE        CONSTANT PLS_INTEGER := 227;
c_USER_LOGGED_IN_PROCEED       CONSTANT PLS_INTEGER := 230;
c_USER_NAME_OK_NEED_PASSWORD   CONSTANT PLS_INTEGER := 331;
c_NEED_ACCOUNT_FOR_LOGIN       CONSTANT PLS_INTEGER := 332;
c_OK_RETURN_CODE               CONSTANT PLS_INTEGER := 0;
c_CONVERT_CRLF                 CONSTANT BOOLEAN     := FALSE;

-- Additional Return Codes --
-- 421   Service not available, closing control connection. This may be a reply to any command if the service knows it must shut down.
-- 425 	Can't open data connection.
-- 426 	Connection closed; transfer aborted.
-- 450 	Requested file action not taken. File unavailable (e.g., file busy).
-- 451 	Requested action aborted: local error in processing.
-- 452 	Requested action not taken. Insufficient storage space in system.
-- 500 	Syntax error, command unrecognized. This may include errors such as command line too long
-- 501 	Syntax error in parameters or arguments.
-- 502 	Command not implemented.
-- 503 	Bad sequence of commands.
-- 504 	Command not implemented for that parameter.
-- 530 	Not logged in.
-- 532 	Need account for storing files.
-- 550 	Requested action not taken. File unavailable (e.g., file not found, no access).
-- 551 	Requested action aborted: page type unknown.
-- 552 	Requested file action aborted. Exceeded storage allocation (for current directory or dataset).
-- 553 	Requested action not taken. File name not allowed.

e_FATAL_ERROR EXCEPTION;

l_REPLY t_STRING_TABLE := t_STRING_TABLE();

PROCEDURE DEBUG_TRACE(p_PROCEDURE IN VARCHAR2, p_MESSAGE IN VARCHAR2) IS
BEGIN
   IF LOGS.IS_DEBUG_ENABLED THEN
      LOGS.LOG_INFO(p_MESSAGE, p_PROCEDURE, NULL, c_PACKAGE);
   END IF;
END DEBUG_TRACE;

FUNCTION PARSE_PORT_NUMBER(p_PORT_STRING IN VARCHAR2 ) RETURN NUMBER IS
v_PORT_NUMBER NUMBER;
v_PORT_ENCODING VARCHAR2(32767);
BEGIN
-- Parse the port number encoding from the server reply --
-- Reply is in the format xyzh1,h2,h3,h4,p1,p2xyz --
-- xyz = possible character data (server-dependent, may not exist) --
-- h1-h4 = server IP elements; ignore since we know the host already --
-- p1,p2 = port number encoding (port number = p1 * 256 + p2  --
   v_PORT_ENCODING := TRANSLATE(p_PORT_STRING, '0123456789', '0000000000');
   v_PORT_ENCODING := SUBSTR(p_PORT_STRING, INSTR(v_PORT_ENCODING, '0'), INSTR(v_PORT_ENCODING, '0', -1) - INSTR(v_PORT_ENCODING, '0') + 1);
   v_PORT_ENCODING := SUBSTR(v_PORT_ENCODING, INSTR(v_PORT_ENCODING, ',', 1, 4) + 1);
   v_PORT_NUMBER := 256 * TO_NUMBER(SUBSTR(v_PORT_ENCODING, 1, INSTR(v_PORT_ENCODING, ',') - 1));
   v_PORT_NUMBER := v_PORT_NUMBER + TO_NUMBER(SUBSTR(v_PORT_ENCODING, INSTR(v_PORT_ENCODING, ',') + 1));
RETURN v_PORT_NUMBER;
END PARSE_PORT_NUMBER;

FUNCTION GET_REPLY
   (
   p_CONNECTION IN OUT NOCOPY UTL_TCP.CONNECTION,
   p_RESPONSE IN OUT VARCHAR2
   ) RETURN NUMBER IS
v_PROCEDURE VARCHAR2(32) := 'GET_REPLY';
v_LENGTH NUMBER;
v_CODE NUMBER;
v_BUFFER VARCHAR2(32767);
v_REPLY_CODE VARCHAR2(3) := NULL;
BEGIN
   v_BUFFER := UTL_TCP.GET_LINE(p_CONNECTION, TRUE);
   DEBUG_TRACE(v_PROCEDURE, v_BUFFER);
--   v_CODE := TO_NUMBER(SUBSTR(v_BUFFER,1,3));
--   v_BUFFER := SUBSTR(v_BUFFER,4);
   p_RESPONSE := p_RESPONSE || SUBSTR(v_BUFFER, 2);
   IF SUBSTR(v_BUFFER,1,1 ) = '-' THEN
      LOOP
         v_LENGTH := UTL_TCP.READ_LINE(p_CONNECTION, v_BUFFER);
         DEBUG_TRACE(v_PROCEDURE, v_BUFFER);
         BEGIN
            v_CODE := TO_NUMBER(SUBSTR(v_BUFFER,1,3));
            v_BUFFER := SUBSTR(v_BUFFER,4);
            IF SUBSTR(v_BUFFER,1,1) = ' ' THEN
               p_RESPONSE := p_RESPONSE || SUBSTR(v_BUFFER,2);
               EXIT;
            END IF;
         EXCEPTION
            WHEN VALUE_ERROR THEN
               NULL;
         END;
         p_RESPONSE := p_RESPONSE || v_BUFFER;
      END LOOP;
   END IF;
   RETURN v_CODE;
END GET_REPLY;

FUNCTION SEND_COMMAND
   (
   p_CONNECTION IN OUT NOCOPY UTL_TCP.CONNECTION,
   p_COMMAND IN VARCHAR2,
   p_RESPONSE OUT VARCHAR2
   ) RETURN NUMBER IS
v_PROCEDURE VARCHAR2(32) := 'SEND_COMMAND';
v_RETURN_CODE NUMBER := 0;
BEGIN
   DEBUG_TRACE(v_PROCEDURE, 'Command: ' || p_COMMAND);
   v_RETURN_CODE := UTL_TCP.WRITE_LINE(p_CONNECTION, p_COMMAND);
   v_RETURN_CODE := GET_REPLY(p_CONNECTION, p_RESPONSE);
   DEBUG_TRACE(v_PROCEDURE, 'Response: ' || p_RESPONSE);
   DEBUG_TRACE(v_PROCEDURE, 'Return Code: ' || TO_CHAR(v_RETURN_CODE));
   RETURN v_RETURN_CODE;
END SEND_COMMAND;

FUNCTION CLOSE_CONNECTION(p_CONNECTION IN OUT NOCOPY UTL_TCP.CONNECTION) RETURN NUMBER IS
BEGIN
   IF p_CONNECTION.REMOTE_HOST IS NULL THEN
      RETURN c_OK_RETURN_CODE;
   END IF;
   UTL_TCP.CLOSE_CONNECTION(p_CONNECTION);
   RETURN c_OK_RETURN_CODE;
EXCEPTION
   WHEN UTL_TCP.NETWORK_ERROR THEN
      RETURN c_OK_RETURN_CODE;
END CLOSE_CONNECTION;

FUNCTION OPEN_CONNECTION
   (
   p_CONNECTION OUT NOCOPY UTL_TCP.CONNECTION,
   p_HOST_URL IN VARCHAR2,
   p_PORT IN NUMBER,
   p_USERNAME IN VARCHAR2,
   p_PASSWORD IN VARCHAR2,
   p_RESPONSE OUT VARCHAR2,
   p_TIMEOUT IN NUMBER DEFAULT 60
   )RETURN NUMBER IS
v_PROCEDURE VARCHAR2(32) := 'OPEN_CONNECTION';
v_CODE NUMBER;
v_IGNORE NUMBER;
BEGIN
   p_CONNECTION := UTL_TCP.OPEN_CONNECTION(p_HOST_URL, p_PORT, TX_TIMEOUT => p_TIMEOUT);
   v_CODE := GET_REPLY(p_CONNECTION, p_RESPONSE);
   IF v_CODE = c_SERVICE_READY_FOR_NEW_USER THEN
      v_CODE := SEND_COMMAND(p_CONNECTION, 'USER ' || p_USERNAME, p_RESPONSE);
      IF v_CODE IN (c_USER_NAME_OK_NEED_PASSWORD, c_NEED_ACCOUNT_FOR_LOGIN) THEN
         v_CODE := SEND_COMMAND(p_CONNECTION, 'PASS ' || p_PASSWORD, p_RESPONSE);
         IF v_CODE NOT IN (c_COMMAND_NOT_IMPLEMENTED, c_USER_LOGGED_IN_PROCEED) THEN
            RAISE e_FATAL_ERROR;
         END IF;
      ELSE
         RAISE e_FATAL_ERROR;
      END IF;
   END IF;
   v_CODE := SEND_COMMAND(p_CONNECTION, 'TYPE A', p_RESPONSE);
   DEBUG_TRACE(v_PROCEDURE, 'Logged into ' || p_CONNECTION.REMOTE_HOST || ' at port ' || p_CONNECTION.REMOTE_PORT );
   RETURN c_OK_RETURN_CODE;
EXCEPTION
   WHEN e_FATAL_ERROR THEN
      DEBUG_TRACE(v_PROCEDURE, 'Fatal error opening connection:');
      DEBUG_TRACE(v_PROCEDURE, 'Code: ' || v_CODE);
      DEBUG_TRACE(v_PROCEDURE, 'Response: ' || p_RESPONSE);
      v_IGNORE := CLOSE_CONNECTION(p_CONNECTION);
      RETURN v_CODE;
END OPEN_CONNECTION;

FUNCTION GET_ASCII_FILE
   (
   p_CONNECTION IN OUT NOCOPY UTL_TCP.CONNECTION,
   p_REMOTE_FILE_PATH IN VARCHAR2,
   p_CONTENT_CONTAINER IN OUT NOCOPY CDI_CONTAINER_CONTENT,
   p_RESPONSE OUT VARCHAR2
   ) RETURN NUMBER IS
v_PROCEDURE VARCHAR2(32) := 'GET_ASCII_FILE';
v_BUFFER VARCHAR2(32767);
v_CODE NUMBER := -1;
v_IGNORE_CODE NUMBER;
v_PASSIVE_CONNECTION UTL_TCP.CONNECTION;
v_PORT_NUMBER NUMBER;
BEGIN
-- Switch To Passive Mode For Content Transport --
   v_CODE := SEND_COMMAND(p_CONNECTION, 'PASV', p_RESPONSE);
   IF v_CODE = c_ENTERING_PASSIVE_MODE THEN
      BEGIN
         v_PORT_NUMBER := PARSE_PORT_NUMBER(p_RESPONSE);
         v_PASSIVE_CONNECTION := UTL_TCP.OPEN_CONNECTION(p_CONNECTION.REMOTE_HOST, v_PORT_NUMBER, TX_TIMEOUT => p_CONNECTION.TX_TIMEOUT);
         DEBUG_TRACE(v_PROCEDURE, 'Data connection: ' || v_PASSIVE_CONNECTION.REMOTE_HOST || ':' || v_PASSIVE_CONNECTION.REMOTE_PORT);
         v_CODE := SEND_COMMAND(p_CONNECTION, 'RETR ' || REPLACE(p_REMOTE_FILE_PATH, CHR(12), CHR(0)), p_RESPONSE);
         IF v_CODE <> c_FILE_STATUS_OK THEN
            RAISE e_FATAL_ERROR;
         END IF;
-- Begin The Download Process --
         BEGIN
            p_CONTENT_CONTAINER := CDI_CONTAINER_CONTENT();
            LOOP
               v_BUFFER := UTL_TCP.GET_LINE(v_PASSIVE_CONNECTION, FALSE);
               p_CONTENT_CONTAINER.EXTEND;
               p_CONTENT_CONTAINER(p_CONTENT_CONTAINER.COUNT) := v_BUFFER;
               DEBUG_TRACE(v_PROCEDURE, v_BUFFER);
            END LOOP;
         EXCEPTION
            WHEN UTL_TCP.END_OF_INPUT THEN NULL;
         END;
        v_CODE := CLOSE_CONNECTION(v_PASSIVE_CONNECTION);
        v_CODE := GET_REPLY(p_CONNECTION, p_RESPONSE);
        IF v_CODE BETWEEN 400 AND 599 THEN
           RAISE e_FATAL_ERROR;
        END IF;
      EXCEPTION
         WHEN OTHERS THEN
            v_CODE := SQLCODE;
            p_RESPONSE := SQLERRM;
            LOGS.LOG_ERROR(p_RESPONSE, v_PROCEDURE, NULL, c_PACKAGE);
            RAISE e_FATAL_ERROR;
      END;
   ELSE
      RAISE e_FATAL_ERROR;
   END IF;
   v_CODE := CLOSE_CONNECTION(v_PASSIVE_CONNECTION);
   RETURN c_OK_RETURN_CODE;
EXCEPTION
   WHEN e_FATAL_ERROR THEN
      DEBUG_TRACE(v_PROCEDURE, 'Fatal error getting file: ' || p_REMOTE_FILE_PATH);
      DEBUG_TRACE(v_PROCEDURE, 'Code: ' || v_CODE);
      DEBUG_TRACE(v_PROCEDURE, 'Response: ' || p_RESPONSE);
      v_IGNORE_CODE := CLOSE_CONNECTION(v_PASSIVE_CONNECTION);
      RETURN v_CODE;
   WHEN OTHERS THEN
      LOGS.LOG_ERROR(SQLERRM, v_PROCEDURE, NULL, c_PACKAGE);
      RETURN -1;
END GET_ASCII_FILE;

FUNCTION GET_ASCII_FILE
   (
   p_HOST_URL IN VARCHAR2,
   p_PORT IN NUMBER,
   p_USERNAME IN VARCHAR2,
   p_PASSWORD IN VARCHAR2,
   p_SOURCE_FILE_PATH IN VARCHAR2,
   p_CONTENT_CONTAINER OUT CDI_CONTAINER_CONTENT,
   p_RESPONSE OUT VARCHAR2
   ) RETURN NUMBER IS
v_CONNECTION UTL_TCP.CONNECTION;
v_CODE NUMBER;
v_IGNORE NUMBER;
BEGIN
   v_CODE := CDI_FTP.OPEN_CONNECTION(v_CONNECTION, p_HOST_URL, p_PORT, p_USERNAME, p_PASSWORD, p_RESPONSE, 10);
   IF v_CODE <> c_OK_RETURN_CODE THEN
      RETURN v_CODE;
   END IF;
   v_CODE := CDI_FTP.GET_ASCII_FILE(v_CONNECTION, p_SOURCE_FILE_PATH, p_CONTENT_CONTAINER, p_RESPONSE);
   v_IGNORE := CDI_FTP.CLOSE_CONNECTION(v_CONNECTION);
   RETURN v_CODE;
END GET_ASCII_FILE;

FUNCTION PUT_ASCII_FILE
   (
   p_CONNECTION IN OUT NOCOPY UTL_TCP.CONNECTION,
   p_REMOTE_FILE_PATH IN VARCHAR2,
   p_CONTENT IN CLOB,
   p_RESPONSE OUT VARCHAR2
   ) RETURN NUMBER IS
v_PROCEDURE VARCHAR2(32) := 'PUT_ASCII_FILE';
v_BUFFER VARCHAR2(32767);
v_AMOUNT BINARY_INTEGER := 32767; -- Switch To 10000 (Or Use Binary) If You Get ORA-06502 --
v_POSITION INTEGER := 1;
v_CODE NUMBER := -1;
v_IGNORE_CODE NUMBER;
v_PASSIVE_CONNECTION UTL_TCP.CONNECTION;
v_PORT_NUMBER NUMBER;
v_RESULT PLS_INTEGER;
v_CONTENT_LENGTH INTEGER;
v_FTP_TASK VARCHAR2(32) := 'SEND_COMMAND';
BEGIN

-- Switch To Passive Mode For Content Transport --
   v_CODE := SEND_COMMAND(p_CONNECTION, 'PASV', p_RESPONSE);
   IF v_CODE = c_ENTERING_PASSIVE_MODE THEN
      BEGIN
         v_PORT_NUMBER := PARSE_PORT_NUMBER(p_RESPONSE);
         v_PASSIVE_CONNECTION := UTL_TCP.OPEN_CONNECTION(p_CONNECTION.REMOTE_HOST, v_PORT_NUMBER, TX_TIMEOUT => p_CONNECTION.TX_TIMEOUT);
         DEBUG_TRACE(v_PROCEDURE, 'Data connection: ' || v_PASSIVE_CONNECTION.REMOTE_HOST || ':' || v_PASSIVE_CONNECTION.REMOTE_PORT);
         v_CODE := SEND_COMMAND(p_CONNECTION, 'STOR ' || REPLACE(p_REMOTE_FILE_PATH, CHR(12), CHR(0)), p_RESPONSE);
         IF v_CODE NOT IN(c_FILE_STATUS_OK,c_DATA_CONNECTION_ALREADY_OPEN) THEN
            RAISE e_FATAL_ERROR;
         END IF;
-- Begin The Upload Process --
         BEGIN
            v_CONTENT_LENGTH := DBMS_LOB.GETLENGTH(p_CONTENT);
            DEBUG_TRACE(v_PROCEDURE, 'Begin Transfer Content Length: ' || TO_CHAR(v_CONTENT_LENGTH));
            WHILE v_POSITION <= v_CONTENT_LENGTH LOOP
               DBMS_LOB.READ (p_CONTENT, v_AMOUNT, v_POSITION, v_BUFFER);
               IF c_CONVERT_CRLF THEN
                  v_BUFFER := REPLACE(v_BUFFER, CHR(13), NULL);
               END IF;
               DEBUG_TRACE(v_PROCEDURE, 'Transfer Buffer Length: ' || TO_CHAR(LENGTH(v_BUFFER)));
               v_RESULT := UTL_TCP.WRITE_TEXT(v_PASSIVE_CONNECTION, v_BUFFER, LENGTH(v_BUFFER));
               UTL_TCP.FLUSH(v_PASSIVE_CONNECTION);
               v_POSITION := v_POSITION + v_AMOUNT;
            END LOOP;
            DEBUG_TRACE(v_PROCEDURE, 'End Transfer');
        EXCEPTION
           WHEN UTL_TCP.END_OF_INPUT THEN NULL;
        END;
        v_CODE := CLOSE_CONNECTION(v_PASSIVE_CONNECTION);
        v_CODE := GET_REPLY(p_CONNECTION, p_RESPONSE);
        IF v_CODE BETWEEN 400 AND 599 THEN
           RAISE e_FATAL_ERROR;
        END IF;
      EXCEPTION
         WHEN OTHERS THEN
            v_CODE := SQLCODE;
            p_RESPONSE := SQLERRM;
            LOGS.LOG_ERROR(p_RESPONSE, v_PROCEDURE, NULL, c_PACKAGE);
            RAISE e_FATAL_ERROR;
      END;
   ELSE
      RAISE e_FATAL_ERROR;
   END IF;
   v_CODE := CLOSE_CONNECTION(v_PASSIVE_CONNECTION);
   RETURN c_OK_RETURN_CODE;
EXCEPTION
   WHEN e_FATAL_ERROR THEN
      DEBUG_TRACE(v_PROCEDURE, 'Fatal error putting file: ' || p_REMOTE_FILE_PATH);
      DEBUG_TRACE(v_PROCEDURE, 'Code: ' || v_CODE);
      DEBUG_TRACE(v_PROCEDURE, 'Response: ' || p_RESPONSE);
      v_IGNORE_CODE := CLOSE_CONNECTION(v_PASSIVE_CONNECTION);
      RETURN v_CODE;
   WHEN OTHERS THEN
      LOGS.LOG_ERROR(SQLERRM, v_PROCEDURE, NULL, c_PACKAGE);
      RETURN -1;
END PUT_ASCII_FILE;

FUNCTION PUT_ASCII_FILE
   (
   p_HOST_URL IN VARCHAR2,
   p_PORT IN NUMBER,
   p_USERNAME IN VARCHAR2,
   p_PASSWORD IN VARCHAR2,
   p_TARGET_FILE_PATH IN VARCHAR2,
   p_CONTENT IN CLOB,
   p_RESPONSE OUT VARCHAR2
   ) RETURN NUMBER IS
v_CONNECTION UTL_TCP.CONNECTION;
v_CODE NUMBER;
v_IGNORE NUMBER;
BEGIN
   v_CODE := CDI_FTP.OPEN_CONNECTION(v_CONNECTION, p_HOST_URL, p_PORT, p_USERNAME, p_PASSWORD, p_RESPONSE, 10);
   IF v_CODE <> c_OK_RETURN_CODE THEN
      RETURN v_CODE;
   END IF;
   v_CODE := CDI_FTP.PUT_ASCII_FILE(v_CONNECTION, p_TARGET_FILE_PATH, p_CONTENT, p_RESPONSE);
   v_IGNORE := CDI_FTP.CLOSE_CONNECTION(v_CONNECTION);
   RETURN v_CODE;
END PUT_ASCII_FILE;

PROCEDURE GET_REPLY(p_CONNECTION IN OUT NOCOPY UTL_TCP.CONNECTION) AS
v_REPLY_CODE VARCHAR2(3) := NULL;
v_COUNTER PLS_INTEGER := 0;
BEGIN
   DEBUG_TRACE('GET_REPLY','Entry');
   LOOP
      l_REPLY.EXTEND;
      l_REPLY(l_REPLY.LAST) := UTL_TCP.GET_LINE(p_CONNECTION, TRUE);
      DEBUG_TRACE('GET_REPLY', l_REPLY(l_REPLY.LAST));
      IF v_REPLY_CODE IS NULL THEN
         v_REPLY_CODE := SUBSTR(l_REPLY(l_REPLY.LAST),1,3);
      END IF;
      IF SUBSTR(v_REPLY_CODE,1,1) IN ('4','5') THEN
         ERRS.LOG_AND_RAISE('GET_REPLY: ' || l_REPLY(l_REPLY.LAST));
      ELSIF (SUBSTR(l_REPLY(l_REPLY.LAST),1,3) = v_REPLY_CODE AND SUBSTR(l_REPLY(l_REPLY.LAST),4,1) = ' ') THEN
         EXIT;
      END IF;
      v_COUNTER := v_COUNTER + 1;
      IF v_COUNTER > 1000 THEN
         ERRS.LOG_AND_RAISE('Loop Counter Exceeds Maximum');
      END IF;
   END LOOP;
EXCEPTION
   WHEN UTL_TCP.END_OF_INPUT THEN
      NULL;
END GET_REPLY;

PROCEDURE SEND_COMMAND(p_CONNECTION IN OUT NOCOPY UTL_TCP.CONNECTION, p_COMMAND IN VARCHAR2, p_REPLY IN BOOLEAN DEFAULT TRUE) AS
v_RESULT PLS_INTEGER;
BEGIN
   DEBUG_TRACE('SEND_COMMAND', p_COMMAND);
   v_RESULT := UTL_TCP.WRITE_LINE(p_CONNECTION, p_COMMAND);
   IF p_REPLY THEN
      GET_REPLY(p_CONNECTION);
   END IF;
END SEND_COMMAND;

FUNCTION LOGIN
   (
   p_HOST    IN  VARCHAR2,
   p_PORT    IN  VARCHAR2,
   p_USER    IN  VARCHAR2,
   p_PASS    IN  VARCHAR2,
   p_TIMEOUT IN  NUMBER := NULL
   ) RETURN UTL_TCP.CONNECTION AS
v_CONNECTION UTL_TCP.CONNECTION;
BEGIN
  l_REPLY.DELETE;
  v_CONNECTION := UTL_TCP.OPEN_CONNECTION(p_HOST, p_PORT, TX_TIMEOUT => p_TIMEOUT);
  GET_REPLY(v_CONNECTION);
  SEND_COMMAND(v_CONNECTION, 'USER ' || p_USER);
  SEND_COMMAND(v_CONNECTION, 'PASS ' || p_PASS);
  RETURN v_CONNECTION;
END LOGIN;

PROCEDURE LOGOUT(p_CONNECTION IN OUT NOCOPY UTL_TCP.CONNECTION, p_REPLY IN BOOLEAN DEFAULT TRUE) AS
BEGIN
   SEND_COMMAND(p_CONNECTION, 'QUIT', p_REPLY);
   UTL_TCP.CLOSE_CONNECTION(p_CONNECTION);
END LOGOUT;

FUNCTION GET_PASSIVE(p_CONNECTION IN OUT NOCOPY UTL_TCP.CONNECTION) RETURN UTL_TCP.CONNECTION AS
v_CONNECTION UTL_TCP.CONNECTION;
v_REPLY VARCHAR2(32766);
v_PORT1 NUMBER(10);
v_PORT2 NUMBER(10);
BEGIN
   SEND_COMMAND(p_CONNECTION, 'PASV');
   v_REPLY := l_REPLY(l_REPLY.LAST);
   v_REPLY := REPLACE(SUBSTR(v_REPLY, INSTR(v_REPLY, '(') + 1, (INSTR(v_REPLY, ')')) - (INSTR(v_REPLY, '('))-1), ',', '.');
   v_PORT1 := TO_NUMBER(SUBSTR(v_REPLY, INSTR(v_REPLY, '.', 1, 4)+1, (INSTR(v_REPLY, '.', 1, 5)-1) - (INSTR(v_REPLY, '.', 1, 4))));
   v_PORT2 := TO_NUMBER(SUBSTR(v_REPLY, INSTR(v_REPLY, '.', 1, 5)+1));
   v_CONNECTION := UTL_TCP.OPEN_CONNECTION(p_CONNECTION.REMOTE_HOST, 256 * v_PORT1 + v_PORT2);
   RETURN v_CONNECTION;
END GET_PASSIVE;

PROCEDURE LIST(p_CONNECTION IN OUT NOCOPY UTL_TCP.CONNECTION, p_DIRECTORY IN VARCHAR2, p_COMMAND IN VARCHAR2 DEFAULT 'LIST', p_LIST OUT t_STRING_TABLE) AS
v_CONNECTION UTL_TCP.CONNECTION;
v_LIST t_STRING_TABLE := t_STRING_TABLE();
v_REPLY_CODE VARCHAR2(3) := NULL;
v_COUNTER PLS_INTEGER := 0;
BEGIN
   v_CONNECTION := GET_PASSIVE(p_CONNECTION);
   SEND_COMMAND(p_CONNECTION, p_COMMAND || ' ' || p_DIRECTORY, TRUE);
   BEGIN
      LOOP
         v_LIST.EXTEND;
         v_LIST(v_LIST.LAST) := UTL_TCP.GET_LINE(v_CONNECTION, TRUE);
         DEBUG_TRACE('LIST', v_LIST(v_LIST.LAST));
         IF v_REPLY_CODE IS NULL THEN
            v_REPLY_CODE := SUBSTR(v_LIST(v_LIST.LAST),1,3);
         END IF;
         IF SUBSTR(v_REPLY_CODE,1,1) IN ('4','5')  AND SUBSTR(v_REPLY_CODE,4,1) = ' ' THEN
            ERRS.LOG_AND_RAISE('LIST: ' || v_LIST(v_LIST.LAST));
         ELSIF (SUBSTR(l_REPLY(l_REPLY.LAST),1,3) = v_REPLY_CODE AND SUBSTR(l_REPLY(l_REPLY.LAST),4,1) = ' ') THEN
            EXIT;
         END IF;
         v_COUNTER := v_COUNTER + 1;
         IF v_COUNTER > 1000 THEN
            ERRS.LOG_AND_RAISE('Loop Counter Exceeds Maximum');
         END IF;
      END LOOP;
   EXCEPTION
      WHEN UTL_TCP.END_OF_INPUT THEN
         NULL;
   END;
   v_LIST.DELETE(v_LIST.LAST);
   p_LIST := v_LIST;
   UTL_TCP.CLOSE_CONNECTION(v_CONNECTION);
   GET_REPLY(p_CONNECTION);
EXCEPTION
   WHEN OTHERS THEN
      UTL_TCP.CLOSE_CONNECTION(v_CONNECTION);
      ERRS.LOG_AND_RAISE;
END LIST;

END CDI_FTP;
/
