CREATE OR REPLACE PACKAGE BODY CDI_AMI AS

-- Package Constants --
c_PACKAGE_NAME                 CONSTANT VARCHAR2(16) := 'CDI_AMI';
c_STEP_NAME                    CONSTANT VARCHAR2(32) := NULL;
c_SYSTEM_SETTING_BOOK          CONSTANT VARCHAR2(32) := 'Custom Data Interface';
c_SYSTEM_SETTING_CHAPTER       CONSTANT VARCHAR2(16) := 'AMI';
c_SYSTEM_SETTING_PAGE_USAGE    CONSTANT VARCHAR2(32) := 'Usage';
c_SYSTEM_SETTING_PAGE_SETTLE   CONSTANT VARCHAR2(32) := 'Settlement';
c_SYSTEM_SETTING_PAGE_ARCHIVE  CONSTANT VARCHAR2(32) := 'Archive';
c_SYSTEM_SETTING_PAGE_CERTIFY  CONSTANT VARCHAR2(32) := 'Certification';
c_SETTING_LOG_LEVEL            CONSTANT VARCHAR2(32) := 'Log Level';
c_AMI_ACCOUNT_USAGE_PROCESS    CONSTANT VARCHAR2(30) := 'CDI: AMI Account Usage Import';
c_AMI_SA_SETTLEMENT_PROCESS    CONSTANT VARCHAR2(30) := 'CDI: AMI SA Settlement Setup';
c_AMI_SA_ARCHIVE_PROCESS       CONSTANT VARCHAR2(30) := 'CDI: AMI SA Settlement Archive';
c_AMI_CERTIFY_SYNC_PROCESS     CONSTANT VARCHAR2(30) := 'CDI: AMI Certification Sync';
c_AMI_PSEUDO_ACCOUNT_SIC_CODE  CONSTANT VARCHAR2(4)  := 'AMI';
c_EDC_EXTERNAL_IDENTIFIER      CONSTANT VARCHAR2(4)  := 'BGE';
c_AMI_CHANNEL_2_ESP_NAME       CONSTANT VARCHAR2(32) := 'BGE';
c_AMI_CHANNEL_2_PSE_NAME       CONSTANT VARCHAR2(32) := 'BGE';
c_AMI_CHANNEL_2_POOL_NAME      CONSTANT VARCHAR2(32) := 'BGE';
c_DEFAULT_TIME_ZONE            CONSTANT VARCHAR2(4)  := 'EDT';
c_DISTRIBUTION                 CONSTANT VARCHAR2(16) := 'Distribution';
c_NOT_ASSIGNED                 CONSTANT VARCHAR2(16) := 'Not Assigned';
c_AMI_CHANNEL_2                CONSTANT VARCHAR2(16) := 'AMI Channel 2';
c_DATE_FORMAT                  CONSTANT VARCHAR2(24) := 'MM/DD/YYYY';
c_DATE_TIME_FORMAT             CONSTANT VARCHAR2(24) := 'MM/DD/YYYY HH24:MI:SS';
c_YES                          CONSTANT CHAR(1) := 'Y';
c_NO                           CONSTANT CHAR(1) := 'N';
c_COMMA                        CONSTANT CHAR(1) := ',';
c_CRLF                         CONSTANT CHAR(2) := CHR(13) || CHR(10);
c_SYSTEM_SETTING_LIBRARY       CONSTANT NUMBER(1) := 0;
c_INCREMENT_ONE_UNIT           CONSTANT NUMBER(1) := 1;
c_NOT_ASSIGNED_ID              CONSTANT NUMBER(1) := 0;
c_ONE_HOUR                     CONSTANT NUMBER := 1/24;
c_DO_NOT_CREATE_ENTITY         CONSTANT BOOLEAN   := FALSE;
c_EXIT                         CONSTANT VARCHAR2(16) := 'Exit';

l_AMI_EDC_ID                   PLS_INTEGER;
l_AMI_SERVICE_LOCATION_ID      PLS_INTEGER;
l_AMI_LOSS_FACTOR_ID           PLS_INTEGER;
l_SYSDATE                      DATE;

CURSOR c_SELECT_AMI_USAGE IS
   SELECT C.SERVICE_ID, X.*
   FROM RTO_STAGING.AMI_USAGE X
      JOIN ACCOUNT A ON A.ACCOUNT_EXTERNAL_IDENTIFIER = X.AMI_ACCOUNT_NAME
      JOIN ACCOUNT_SERVICE B ON B.ACCOUNT_ID = A.ACCOUNT_ID
      JOIN SERVICE C ON C.MODEL_ID = GA.ELECTRIC_MODEL AND C.SCENARIO_ID = GA.BASE_SCENARIO_ID AND C.AS_OF_DATE = CONSTANTS.LOW_DATE AND C.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
   ORDER BY X.AMI_ACCOUNT_NAME, X.SERVICE_DATE;

TYPE t_AMI_USAGE     IS TABLE OF c_SELECT_AMI_USAGE%ROWTYPE;
TYPE t_SERVICE_STATE IS TABLE OF SERVICE_STATE%ROWTYPE;
TYPE t_SERVICE_LOAD  IS TABLE OF SERVICE_LOAD%ROWTYPE;

PROCEDURE INITIALIZE_INTERFACE(p_INTERFACE_NAME IN VARCHAR2) AS
v_PROCEDURE_NAME VARCHAR2(32) := 'INITIALIZE_INTERFACE';
v_SETTING VARCHAR2(32);
v_SYSTEM_SETTING_PAGE VARCHAR2(32) :=
   CASE p_INTERFACE_NAME
      WHEN c_AMI_ACCOUNT_USAGE_PROCESS THEN c_SYSTEM_SETTING_PAGE_USAGE
      WHEN c_AMI_SA_SETTLEMENT_PROCESS THEN c_SYSTEM_SETTING_PAGE_SETTLE
      WHEN c_AMI_SA_ARCHIVE_PROCESS    THEN c_SYSTEM_SETTING_PAGE_ARCHIVE
      WHEN c_AMI_CERTIFY_SYNC_PROCESS  THEN c_SYSTEM_SETTING_PAGE_CERTIFY
      ELSE NULL
   END;
BEGIN
   v_SETTING := UPPER(NVL(GET_DICTIONARY_VALUE(c_SETTING_LOG_LEVEL, c_SYSTEM_SETTING_LIBRARY, c_SYSTEM_SETTING_BOOK, c_SYSTEM_SETTING_CHAPTER, v_SYSTEM_SETTING_PAGE), 'INFO'));
   LOGS.LOG_INFO('Log Level: ' || TO_CHAR(v_SETTING), v_PROCEDURE_NAME, 'System Setting', c_PACKAGE_NAME);
   LOGS.SET_CURRENT_LOG_LEVEL(CASE v_SETTING WHEN 'DEBUG' THEN LOGS.c_LEVEL_DEBUG ELSE LOGS.c_LEVEL_INFO END);
   IF LOGS.CURRENT_LOG_LEVEL = LOGS.c_LEVEL_DEBUG THEN
      LOGS.SET_PERSISTING_TRACE(TRUE);
   END IF;
   l_SYSDATE := SYSDATE;
END INITIALIZE_INTERFACE;

PROCEDURE STOP_PROCESS AS
v_STATUS NUMBER;
v_MESSAGE VARCHAR2(1000);
BEGIN
   LOGS.STOP_PROCESS(v_MESSAGE, v_STATUS);
END STOP_PROCESS;

FUNCTION GET_PSE_OF_RECORD(p_ESP_EXTERNAL_IDENTIFIER IN VARCHAR2, p_SERVICE_DATE IN DATE) RETURN PLS_INTEGER AS
v_PROCEDURE_NAME VARCHAR2(32) := 'GET_PSE_OF_RECORD';
v_ESP_ID PLS_INTEGER;
v_PSE_ID PLS_INTEGER;
BEGIN
   v_ESP_ID := ID.ID_FOR_ESP_EXTERNAL_IDENTIFIER(p_ESP_EXTERNAL_IDENTIFIER);
   IF v_ESP_ID = GA.NO_DATA_FOUND THEN
      LOGS.LOG_ERROR('Energy Service Provider Not Found For: ' || p_ESP_EXTERNAL_IDENTIFIER, v_PROCEDURE_NAME, 'Call ID.ID_FOR_ESP_EXTERNAL_IDENTIFIER API', c_PACKAGE_NAME);
   END IF;
   SELECT NVL(MAX(PSE_ID), c_NOT_ASSIGNED_ID) INTO v_PSE_ID FROM PSE_ESP WHERE ESP_ID = v_ESP_ID AND p_SERVICE_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE);
   RETURN v_PSE_ID;
END GET_PSE_OF_RECORD;

FUNCTION GET_DISTRIBUTION_LOSS_FACTOR(p_ACCOUNT_NAME IN VARCHAR2, p_SERVICE_DATE IN DATE) RETURN NUMBER AS
v_PATTERN_VAL LOSS_FACTOR_PATTERN.LOSS_VAL%TYPE; --@@V57 Migration--
BEGIN
   SELECT NVL(AVG(D.LOSS_VAL),0) INTO v_PATTERN_VAL --@@V57 Migration--
   FROM ACCOUNT A
      JOIN ACCOUNT_LOSS_FACTOR B ON B.ACCOUNT_ID = A.ACCOUNT_ID AND B.CASE_ID = GA.BASE_CASE_ID AND p_SERVICE_DATE BETWEEN B.BEGIN_DATE AND NVL(B.END_DATE, p_SERVICE_DATE)
      JOIN LOSS_FACTOR_MODEL C ON C.LOSS_FACTOR_ID = B.LOSS_FACTOR_ID AND C.FACTOR_TYPE = c_DISTRIBUTION AND p_SERVICE_DATE BETWEEN C.BEGIN_DATE AND NVL(C.END_DATE, p_SERVICE_DATE)
      JOIN LOSS_FACTOR_PATTERN D ON D.PATTERN_ID = C.PATTERN_ID
   WHERE A.ACCOUNT_NAME = p_ACCOUNT_NAME;
   RETURN v_PATTERN_VAL;
END GET_DISTRIBUTION_LOSS_FACTOR;

PROCEDURE EXTRACT_SERVICE_STATE(p_USAGE_RECORD IN c_SELECT_AMI_USAGE%ROWTYPE, p_SERVICE_STATE IN OUT t_SERVICE_STATE) AS
BEGIN
   p_SERVICE_STATE.EXTEND;
   p_SERVICE_STATE(p_SERVICE_STATE.LAST).SERVICE_ID           := p_USAGE_RECORD.SERVICE_ID;
   p_SERVICE_STATE(p_SERVICE_STATE.LAST).SERVICE_CODE         := GA.ACTUAL_SERVICE;
   p_SERVICE_STATE(p_SERVICE_STATE.LAST).SERVICE_DATE         := p_USAGE_RECORD.SERVICE_DATE;
   p_SERVICE_STATE(p_SERVICE_STATE.LAST).BASIS_AS_OF_DATE     := NULL;
   p_SERVICE_STATE(p_SERVICE_STATE.LAST).IS_UFE_PARTICIPANT   := 1;
   p_SERVICE_STATE(p_SERVICE_STATE.LAST).SERVICE_ACCOUNTS     := 1;
   p_SERVICE_STATE(p_SERVICE_STATE.LAST).METER_TYPE           := 'I';
   p_SERVICE_STATE(p_SERVICE_STATE.LAST).IS_EXTERNAL_FORECAST := 0;
   p_SERVICE_STATE(p_SERVICE_STATE.LAST).IS_AGGREGATE_ACCOUNT := 0;
   p_SERVICE_STATE(p_SERVICE_STATE.LAST).IS_AGGREGATE_POOL    := 0;
   p_SERVICE_STATE(p_SERVICE_STATE.LAST).PROFILE_TYPE         := NULL;
   p_SERVICE_STATE(p_SERVICE_STATE.LAST).PROFILE_SOURCE_DATE  := NULL;
   p_SERVICE_STATE(p_SERVICE_STATE.LAST).PROFILE_ZERO_COUNT   := NULL;
   p_SERVICE_STATE(p_SERVICE_STATE.LAST).USAGE_FACTOR         := 1;
   p_SERVICE_STATE(p_SERVICE_STATE.LAST).SERVICE_INTERVALS    := 1;
END EXTRACT_SERVICE_STATE;

PROCEDURE EXTRACT_SERVICE_LOAD(p_USAGE_RECORD IN c_SELECT_AMI_USAGE%ROWTYPE, p_SERVICE_LOAD IN OUT t_SERVICE_LOAD) AS
-- The Spring DST Transition Day Record Will Contain 24 Hour-End Values With Hour-End 3 Set To 0 --
-- The Fall DST Transition Day Record Will Contain 25 Hour-End Values Populated Sequentially --
v_DISTRIBUTION_LOSS_FACTOR LOSS_FACTOR_PATTERN.LOSS_VAL%TYPE; --@@V57 Migration--
v_DST_TRANSITION_DAY NUMBER(1);
v_SERVICE_DATE DATE := TO_CUT(p_USAGE_RECORD.SERVICE_DATE, LOCAL_TIME_ZONE);
   PROCEDURE APPEND_SERVICE_LOAD(p_LOAD_VAL IN NUMBER) AS
   BEGIN
      v_SERVICE_DATE := v_SERVICE_DATE + c_ONE_HOUR;
      p_SERVICE_LOAD.EXTEND;
      p_SERVICE_LOAD(p_SERVICE_LOAD.LAST).SERVICE_ID := p_USAGE_RECORD.SERVICE_ID;
      p_SERVICE_LOAD(p_SERVICE_LOAD.LAST).SERVICE_CODE := GA.ACTUAL_SERVICE;
      p_SERVICE_LOAD(p_SERVICE_LOAD.LAST).LOAD_DATE := v_SERVICE_DATE;
      p_SERVICE_LOAD(p_SERVICE_LOAD.LAST).LOAD_CODE := GA.STANDARD;
      p_SERVICE_LOAD(p_SERVICE_LOAD.LAST).LOAD_VAL := p_LOAD_VAL;
      p_SERVICE_LOAD(p_SERVICE_LOAD.LAST).TX_LOSS_VAL := 0;
      p_SERVICE_LOAD(p_SERVICE_LOAD.LAST).DX_LOSS_VAL := p_LOAD_VAL * v_DISTRIBUTION_LOSS_FACTOR;
      p_SERVICE_LOAD(p_SERVICE_LOAD.LAST).UE_LOSS_VAL := 0;
   END APPEND_SERVICE_LOAD;
BEGIN
   v_DISTRIBUTION_LOSS_FACTOR := GET_DISTRIBUTION_LOSS_FACTOR(p_USAGE_RECORD.AMI_ACCOUNT_NAME, p_USAGE_RECORD.SERVICE_DATE);
   v_DST_TRANSITION_DAY := CASE TRUNC(p_USAGE_RECORD.SERVICE_DATE) WHEN TRUNC(DST_SPRING_AHEAD_DATE(p_USAGE_RECORD.SERVICE_DATE)) THEN 1 WHEN TRUNC(DST_FALL_BACK_DATE(p_USAGE_RECORD.SERVICE_DATE)) THEN 2 ELSE 0 END;
   APPEND_SERVICE_LOAD(p_USAGE_RECORD.KW_1);
   APPEND_SERVICE_LOAD(p_USAGE_RECORD.KW_2);
   IF v_DST_TRANSITION_DAY <> 1 THEN
      APPEND_SERVICE_LOAD(p_USAGE_RECORD.KW_3);
   END IF;
   APPEND_SERVICE_LOAD(p_USAGE_RECORD.KW_4);
   APPEND_SERVICE_LOAD(p_USAGE_RECORD.KW_5);
   APPEND_SERVICE_LOAD(p_USAGE_RECORD.KW_6);
   APPEND_SERVICE_LOAD(p_USAGE_RECORD.KW_7);
   APPEND_SERVICE_LOAD(p_USAGE_RECORD.KW_8);
   APPEND_SERVICE_LOAD(p_USAGE_RECORD.KW_9);
   APPEND_SERVICE_LOAD(p_USAGE_RECORD.KW_10);
   APPEND_SERVICE_LOAD(p_USAGE_RECORD.KW_11);
   APPEND_SERVICE_LOAD(p_USAGE_RECORD.KW_12);
   APPEND_SERVICE_LOAD(p_USAGE_RECORD.KW_13);
   APPEND_SERVICE_LOAD(p_USAGE_RECORD.KW_14);
   APPEND_SERVICE_LOAD(p_USAGE_RECORD.KW_15);
   APPEND_SERVICE_LOAD(p_USAGE_RECORD.KW_16);
   APPEND_SERVICE_LOAD(p_USAGE_RECORD.KW_17);
   APPEND_SERVICE_LOAD(p_USAGE_RECORD.KW_18);
   APPEND_SERVICE_LOAD(p_USAGE_RECORD.KW_19);
   APPEND_SERVICE_LOAD(p_USAGE_RECORD.KW_20);
   APPEND_SERVICE_LOAD(p_USAGE_RECORD.KW_21);
   APPEND_SERVICE_LOAD(p_USAGE_RECORD.KW_22);
   APPEND_SERVICE_LOAD(p_USAGE_RECORD.KW_23);
   APPEND_SERVICE_LOAD(p_USAGE_RECORD.KW_24);
   IF v_DST_TRANSITION_DAY = 2 THEN
      APPEND_SERVICE_LOAD(p_USAGE_RECORD.KW_25);
   END IF;
END EXTRACT_SERVICE_LOAD;

PROCEDURE POST_AMI_ACCOUNT_USAGE AS
v_PROCEDURE_NAME VARCHAR2(32) := 'POST_AMI_ACCOUNT_USAGE';
v_SERVICE_STATE t_SERVICE_STATE := t_SERVICE_STATE();
v_SERVICE_LOAD  t_SERVICE_LOAD := t_SERVICE_LOAD();
v_LAST_AMI_ACCOUNT_NAME VARCHAR2(64);
v_COUNT PLS_INTEGER;
v_MARK_TIME PLS_INTEGER := DBMS_UTILITY.GET_TIME;
   PROCEDURE PUT_SERVICE_CONTENT AS
      v_START_TIME PLS_INTEGER := DBMS_UTILITY.GET_TIME;
      v_SERVICE_STATE_COUNT PLS_INTEGER := v_SERVICE_STATE.COUNT;
      v_SERVICE_LOAD_COUNT PLS_INTEGER := v_SERVICE_LOAD.COUNT;
      BEGIN
         FORALL i IN v_SERVICE_STATE.FIRST..v_SERVICE_STATE.LAST
            INSERT INTO SERVICE_STATE VALUES v_SERVICE_STATE(i);
         FORALL i IN v_SERVICE_LOAD.FIRST..v_SERVICE_LOAD.LAST
            INSERT INTO SERVICE_LOAD VALUES v_SERVICE_LOAD(i);
         v_SERVICE_STATE.DELETE;
         v_SERVICE_LOAD.DELETE;
      LOGS.LOG_DEBUG('Account: ' || v_LAST_AMI_ACCOUNT_NAME || ', Service State Count: ' || TO_CHAR(v_SERVICE_STATE_COUNT) || ', Service Load Count: ' || TO_CHAR(v_SERVICE_LOAD_COUNT) || ', Seconds: ' || TO_CHAR((DBMS_UTILITY.GET_TIME - v_START_TIME) / 100), v_PROCEDURE_NAME, 'PUT_SERVICE_CONTENT', c_PACKAGE_NAME);
   END PUT_SERVICE_CONTENT;
BEGIN
   SELECT COUNT(*) INTO v_COUNT FROM RTO_STAGING.AMI_USAGE;
   LOGS.INIT_PROCESS_PROGRESS('Account Usage Day', v_COUNT, 'AMI Account Usage Days');
   FOR v_SELECT_AMI_USAGE IN c_SELECT_AMI_USAGE LOOP
      IF v_LAST_AMI_ACCOUNT_NAME IS NULL THEN
         v_LAST_AMI_ACCOUNT_NAME := v_SELECT_AMI_USAGE.AMI_ACCOUNT_NAME;
      END IF;
      IF v_SELECT_AMI_USAGE.AMI_ACCOUNT_NAME <> v_LAST_AMI_ACCOUNT_NAME THEN
         PUT_SERVICE_CONTENT;
      END IF;
      EXTRACT_SERVICE_STATE(v_SELECT_AMI_USAGE, v_SERVICE_STATE);
      EXTRACT_SERVICE_LOAD(v_SELECT_AMI_USAGE, v_SERVICE_LOAD);
      LOGS.INCREMENT_PROCESS_PROGRESS;
      v_LAST_AMI_ACCOUNT_NAME := v_SELECT_AMI_USAGE.AMI_ACCOUNT_NAME;
   END LOOP;
   PUT_SERVICE_CONTENT;
   LOGS.LOG_INFO('Elapsed Seconds: ' || TO_CHAR(ROUND((DBMS_UTILITY.GET_TIME-v_MARK_TIME)/100)), v_PROCEDURE_NAME, c_EXIT, c_PACKAGE_NAME);
END POST_AMI_ACCOUNT_USAGE;

PROCEDURE ARCHIVE_AMI_ACCOUNT_USAGE(p_STATEMENT_TYPE_ID IN NUMBER, p_SETTLEMENT_START_DATE IN DATE, p_SETTLEMENT_STOP_DATE IN DATE) AS
v_PROCEDURE_NAME VARCHAR2(32) := 'ARCHIVE_AMI_ACCOUNT_USAGE';
v_MARK_TIME PLS_INTEGER := DBMS_UTILITY.GET_TIME;
BEGIN
-- Delete Content From The Archive That Covers The Settlement Time Period --
   DELETE CDI_AMI_USAGE_ARCHIVE
   WHERE STATEMENT_TYPE_ID = p_STATEMENT_TYPE_ID
      AND SERVICE_DATE BETWEEN p_SETTLEMENT_START_DATE AND p_SETTLEMENT_STOP_DATE;
   LOGS.LOG_DEBUG('Record Count: ' || TO_CHAR(SQL%ROWCOUNT), v_PROCEDURE_NAME, 'Delete CDI_AMI_USAGE_ARCHIVE', c_PACKAGE_NAME);
-- Insert Content From The Staging Table That Contains All AMI Pseudo-Account Usage For The Settlement Time Period --
   INSERT INTO CDI_AMI_USAGE_ARCHIVE(AMI_ACCOUNT_NAME, STATEMENT_TYPE_ID, SERVICE_DATE, KW_1, KW_2, KW_3, KW_4, KW_5, KW_6, KW_7, KW_8, KW_9, KW_10, KW_11, KW_12, KW_13, KW_14, KW_15, KW_16, KW_17, KW_18, KW_19, KW_20, KW_21, KW_22, KW_23, KW_24, KW_25, SA_COUNT, ENTRY_DATE)
   SELECT AMI_ACCOUNT_NAME, p_STATEMENT_TYPE_ID, SERVICE_DATE, KW_1, KW_2, KW_3, KW_4, KW_5, KW_6, KW_7, KW_8, KW_9, KW_10, KW_11, KW_12, KW_13, KW_14, KW_15, KW_16, KW_17, KW_18, KW_19, KW_20, KW_21, KW_22, KW_23, KW_24, KW_25, SA_COUNT, l_SYSDATE
   FROM RTO_STAGING.AMI_USAGE;
   LOGS.LOG_DEBUG('Record Count: ' || TO_CHAR(SQL%ROWCOUNT), v_PROCEDURE_NAME, 'Insert CDI_AMI_USAGE_ARCHIVE', c_PACKAGE_NAME);
   LOGS.LOG_INFO('Elapsed Seconds: ' || TO_CHAR(ROUND((DBMS_UTILITY.GET_TIME-v_MARK_TIME)/100)), v_PROCEDURE_NAME, c_EXIT, c_PACKAGE_NAME);
END ARCHIVE_AMI_ACCOUNT_USAGE;

PROCEDURE DELETE_AMI_SERVICE_LOAD(p_SETTLEMENT_START_DATE IN DATE, p_SETTLEMENT_STOP_DATE IN DATE) AS
v_PROCEDURE_NAME VARCHAR2(32) := 'DELETE_AMI_SERVICE_LOAD';
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_SERVICE_IDENT SERVICE_IDENT_TABLE;
v_MARK_TIME PLS_INTEGER := DBMS_UTILITY.GET_TIME;
BEGIN
   UT.CUT_DATE_RANGE(p_SETTLEMENT_START_DATE, p_SETTLEMENT_STOP_DATE, LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
-- Collect All AMI Psuudo-Account Service Identifiers --
    SELECT SERVICE_IDENT_TYPE(SERVICE_ID, NULL, NULL)
    BULK COLLECT INTO v_SERVICE_IDENT
    FROM
      (SELECT DISTINCT C.SERVICE_ID
      FROM ACCOUNT A
         JOIN ACCOUNT_SERVICE B ON B.ACCOUNT_ID = A.ACCOUNT_ID
         JOIN SERVICE C ON C.MODEL_ID = GA.ELECTRIC_MODEL AND C.SCENARIO_ID = GA.BASE_SCENARIO_ID AND C.AS_OF_DATE = CONSTANTS.LOW_DATE AND C.ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
      WHERE A.ACCOUNT_SIC_CODE = 'AMI');
   LOGS.LOG_DEBUG('Record Count: ' || TO_CHAR(v_SERVICE_IDENT.COUNT), v_PROCEDURE_NAME, 'Collect SERVICE_IDENT', c_PACKAGE_NAME);
-- Delete Any AMI Pseudo-Account Interval Usage That Covers The Settlement Time Period --
   DELETE SERVICE_LOAD
   WHERE SERVICE_ID IN (SELECT SERVICE_ID FROM TABLE(CAST(v_SERVICE_IDENT AS SERVICE_IDENT_TABLE)))
      AND SERVICE_CODE = GA.ACTUAL_SERVICE
      AND LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE;
   LOGS.LOG_DEBUG('Record Count: ' || TO_CHAR(SQL%ROWCOUNT), v_PROCEDURE_NAME, 'Delete SERVICE_LOAD', c_PACKAGE_NAME);
   DELETE SERVICE_STATE
   WHERE SERVICE_ID IN (SELECT SERVICE_ID FROM TABLE(CAST(v_SERVICE_IDENT AS SERVICE_IDENT_TABLE)))
      AND SERVICE_CODE = GA.ACTUAL_SERVICE
      AND SERVICE_DATE BETWEEN p_SETTLEMENT_START_DATE AND p_SETTLEMENT_STOP_DATE;
   LOGS.LOG_DEBUG('Record Count: ' || TO_CHAR(SQL%ROWCOUNT), v_PROCEDURE_NAME, 'Delete SERVICE_STATE', c_PACKAGE_NAME);
   LOGS.LOG_INFO('Elapsed Seconds: ' || TO_CHAR(ROUND((DBMS_UTILITY.GET_TIME-v_MARK_TIME)/100)), v_PROCEDURE_NAME, c_EXIT, c_PACKAGE_NAME);
END DELETE_AMI_SERVICE_LOAD;

PROCEDURE ENSURE_AMI_SERVICE(p_SETTLEMENT_START_DATE IN DATE, p_SETTLEMENT_STOP_DATE IN DATE) AS
v_PROCEDURE_NAME VARCHAR2(32) := 'ENSURE_AMI_SERVICE';
v_SERVICE_LOCATION_ID PLS_INTEGER;
v_SERVICE_POINT_ID PLS_INTEGER;
v_EDC_ID PLS_INTEGER;
v_PSE_ID PLS_INTEGER;
v_SC_ID PLS_INTEGER;
v_ACCOUNT_SERVICE_ID PLS_INTEGER;
v_PROVIDER_SERVICE_ID PLS_INTEGER;
v_SERVICE_DELIVERY_ID PLS_INTEGER;
v_SERVICE_OBLIGATION_ID PLS_INTEGER;
v_SERVICE_ID PLS_INTEGER;
v_COUNT PLS_INTEGER := 0;
v_CAST_CONTEXT CAST_CONTEXT_TYPE := CAST_CONTEXT_TYPE(NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL); --@@V57 Migration--
v_MARK_TIME PLS_INTEGER := DBMS_UTILITY.GET_TIME;
CURSOR c_SELECT IS
   SELECT X.ACCOUNT_EXTERNAL_IDENTIFIER, X.ESP_EXTERNAL_IDENTIFIER, X.POOL_EXTERNAL_IDENTIFIER, A.ACCOUNT_ID, B.ESP_ID, C.POOL_ID, D.ACCOUNT_SERVICE_ID, E.SERVICE_ID
   FROM
      (SELECT DISTINCT AMI_ACCOUNT_NAME AS ACCOUNT_EXTERNAL_IDENTIFIER,
         CASE WHEN AMI_ACCOUNT_NAME = c_AMI_CHANNEL_2 THEN c_AMI_CHANNEL_2_ESP_NAME  ELSE SUBSTR(SUBSTR(AMI_ACCOUNT_NAME, 1, INSTR(AMI_ACCOUNT_NAME, '_') - 1), 5) END AS ESP_EXTERNAL_IDENTIFIER,
         CASE WHEN AMI_ACCOUNT_NAME = c_AMI_CHANNEL_2 THEN c_AMI_CHANNEL_2_POOL_NAME ELSE SUBSTR(AMI_ACCOUNT_NAME, INSTR(AMI_ACCOUNT_NAME, '_') + 1) END AS POOL_EXTERNAL_IDENTIFIER
      FROM RTO_STAGING.AMI_USAGE) X
         LEFT JOIN ACCOUNT                 A ON A.ACCOUNT_EXTERNAL_IDENTIFIER = X.ACCOUNT_EXTERNAL_IDENTIFIER
         LEFT JOIN ENERGY_SERVICE_PROVIDER B ON B.ESP_EXTERNAL_IDENTIFIER = X.ESP_EXTERNAL_IDENTIFIER
         LEFT JOIN POOL                    C ON C.POOL_EXTERNAL_IDENTIFIER = X.POOL_EXTERNAL_IDENTIFIER
         LEFT JOIN ACCOUNT_SERVICE         D ON D.ACCOUNT_ID = A.ACCOUNT_ID AND D.SERVICE_LOCATION_ID = v_SERVICE_LOCATION_ID AND D.METER_ID = c_NOT_ASSIGNED_ID AND D.AGGREGATE_ID = c_NOT_ASSIGNED_ID
         LEFT JOIN SERVICE                 E ON E.MODEL_ID = GA.ELECTRIC_MODEL AND E.SCENARIO_ID = GA.BASE_SCENARIO_ID AND E.AS_OF_DATE = CONSTANTS.LOW_DATE AND E.ACCOUNT_SERVICE_ID = D.ACCOUNT_SERVICE_ID
   WHERE A.ACCOUNT_ID IS NULL OR B.ESP_ID IS NULL OR C.POOL_ID IS NULL OR D.ACCOUNT_SERVICE_ID IS NULL OR E.SERVICE_ID IS NULL;
BEGIN
   SELECT NVL(MAX(EDC_ID), c_NOT_ASSIGNED_ID), NVL(MAX(EDC_SC_ID), c_NOT_ASSIGNED_ID) INTO v_EDC_ID, v_SC_ID FROM ENERGY_DISTRIBUTION_COMPANY WHERE EDC_NAME = 'BGE';
   IF v_EDC_ID = c_NOT_ASSIGNED_ID THEN
      LOGS.LOG_ERROR('EDC "BGE" Not Defined', v_PROCEDURE_NAME, 'Verify EDC', c_PACKAGE_NAME);
   END IF;
   SELECT NVL(MAX(SERVICE_LOCATION_ID), c_NOT_ASSIGNED_ID), NVL(MAX(SERVICE_POINT_ID), c_NOT_ASSIGNED_ID) INTO v_SERVICE_LOCATION_ID, v_SERVICE_POINT_ID FROM SERVICE_LOCATION WHERE SERVICE_LOCATION_NAME = 'BWI';
   IF v_SERVICE_LOCATION_ID = c_NOT_ASSIGNED_ID THEN
      LOGS.LOG_ERROR('Service Location "BWI" Not Defined', v_PROCEDURE_NAME, 'Verify Service Location', c_PACKAGE_NAME);
   END IF;
   v_CAST_CONTEXT.MODEL_ID := GA.ELECTRIC_MODEL;
   v_CAST_CONTEXT.SCENARIO_ID := GA.BASE_SCENARIO_ID;
   v_CAST_CONTEXT.OUTPUT_AS_OF_DATE := CONSTANTS.LOW_DATE;
   FOR v_SELECT IN c_SELECT LOOP
      IF v_SELECT.ACCOUNT_ID IS NULL THEN
         LOGS.LOG_ERROR('Account External Identifier Not Defined: "' || v_SELECT.ACCOUNT_EXTERNAL_IDENTIFIER, v_PROCEDURE_NAME, 'Verfify Account', c_PACKAGE_NAME);
      ELSIF v_SELECT.ESP_ID IS NULL THEN
         LOGS.LOG_ERROR('ESP External Identifier Not Defined: ' || v_SELECT.ESP_EXTERNAL_IDENTIFIER, v_PROCEDURE_NAME, 'Verfify ESP', c_PACKAGE_NAME);
      ELSIF v_SELECT.ESP_ID IS NULL THEN
         LOGS.LOG_ERROR('Pool External Identifier Not Defined: ' || v_SELECT.POOL_EXTERNAL_IDENTIFIER, v_PROCEDURE_NAME, 'Verfify Pool', c_PACKAGE_NAME);
      ELSIF v_SELECT.ACCOUNT_SERVICE_ID IS NULL OR v_SELECT.SERVICE_ID IS NULL THEN
         CS.GET_ACCOUNT_SERVICE_ID(v_SELECT.ACCOUNT_ID, v_SERVICE_LOCATION_ID, c_NOT_ASSIGNED_ID, c_NOT_ASSIGNED_ID, v_ACCOUNT_SERVICE_ID);
         v_PSE_ID := GET_PSE_OF_RECORD(v_SELECT.ESP_EXTERNAL_IDENTIFIER, p_SETTLEMENT_START_DATE);
         CS.GET_PROVIDER_SERVICE_ID(v_EDC_ID, v_SELECT.ESP_ID, v_PSE_ID, v_PROVIDER_SERVICE_ID);
         CS.SET_SERVICE_DELIVERY_ID(
            p_POOL_ID             => v_SELECT.POOL_ID,
            p_SERVICE_POINT_ID    => v_SERVICE_POINT_ID,
            p_SERVICE_ZONE_ID     => c_NOT_ASSIGNED_ID,
            p_SCHEDULE_GROUP_ID   => c_NOT_ASSIGNED_ID,
            p_SC_ID               => v_SC_ID,
            p_SUPPLY_TYPE         => 'S',
            p_IS_BUG              => 0,
            p_IS_WHOLESALE        => 0,
            p_IS_AGGREGATE_POOL   => 0,
            p_SERVICE_DELIVERY_ID => v_SERVICE_DELIVERY_ID);
         v_SERVICE_ID := CS.GET_SERVICE_ID(
            p_MODEL_ID            => GA.ELECTRIC_MODEL,
            p_SCENARIO_ID         => GA.BASE_SCENARIO_ID,
            p_AS_OF_DATE          => CONSTANTS.LOW_DATE,
            p_PROVIDER_SERVICE_ID => v_PROVIDER_SERVICE_ID,
            p_ACCOUNT_SERVICE_ID  => v_ACCOUNT_SERVICE_ID,
            p_SERVICE_DELIVERY_ID => v_SERVICE_DELIVERY_ID);
         v_SERVICE_OBLIGATION_ID := CX.GET_SERVICE_OBLIGATION_ID(v_CAST_CONTEXT, v_PROVIDER_SERVICE_ID, v_SERVICE_DELIVERY_ID);
         v_COUNT := v_COUNT + 1;
      END IF;
   END LOOP;
   LOGS.LOG_INFO('Record Count: ' || TO_CHAR(v_COUNT), v_PROCEDURE_NAME, 'Setup Service Identity', c_PACKAGE_NAME);
   LOGS.LOG_INFO('Elapsed Seconds: ' || TO_CHAR(ROUND((DBMS_UTILITY.GET_TIME-v_MARK_TIME)/100)), v_PROCEDURE_NAME, c_EXIT, c_PACKAGE_NAME);
END ENSURE_AMI_SERVICE;

PROCEDURE RUN_AMI_ACCOUNT_USAGE_IMPORT(p_STATEMENT_TYPE_ID IN NUMBER, p_BEGIN_DATE IN DATE, p_END_DATE IN DATE) AS
v_PROCEDURE_NAME VARCHAR2(32) := 'RUN_AMI_ACCOUNT_USAGE_IMPORT';
v_SETTLEMENT_START_DATE DATE := TRUNC(p_BEGIN_DATE);
v_SETTLEMENT_STOP_DATE DATE := TRUNC(p_END_DATE);
v_COUNT PLS_INTEGER;
v_MARK_TIME PLS_INTEGER := DBMS_UTILITY.GET_TIME;
BEGIN
-- Initialize This Interface And Start The Process Log --
   SECURITY_CONTROLS.SET_CURRENT_USER(SECURITY_CONTROLS.c_SUSER_SYSTEM);
   LOGS.START_PROCESS(c_AMI_ACCOUNT_USAGE_PROCESS, v_SETTLEMENT_START_DATE, v_SETTLEMENT_STOP_DATE);
   LOGS.LOG_INFO('Statement Type: ' || TO_CHAR(p_STATEMENT_TYPE_ID) || ', Begin Date: ' || TO_CHAR(p_BEGIN_DATE, c_DATE_FORMAT) || ', End Date: ' || TO_CHAR(p_END_DATE, c_DATE_FORMAT));
-- Determine If There Is Content To Process --
   SELECT COUNT(*) INTO v_COUNT FROM RTO_STAGING.AMI_USAGE;
   IF v_COUNT > 0 THEN
-- Ensure All Service Identifiers Have Been Created For Each AMI Pseudo-Account --
      ENSURE_AMI_SERVICE(v_SETTLEMENT_START_DATE, v_SETTLEMENT_STOP_DATE);
-- Archive The Usage Content --
      ARCHIVE_AMI_ACCOUNT_USAGE(p_STATEMENT_TYPE_ID, v_SETTLEMENT_START_DATE, v_SETTLEMENT_STOP_DATE);
-- Delete AMI Pseudo-Account Service Load Derived From A Prior Run Of AMI Account Usage Import --
      DELETE_AMI_SERVICE_LOAD(v_SETTLEMENT_START_DATE, v_SETTLEMENT_STOP_DATE);
-- Process AMI Usage Content --
      POST_AMI_ACCOUNT_USAGE;
-- Clear The Staging Table Content To Signal Successful Completion --
      DELETE RTO_STAGING.AMI_USAGE;
   ELSE
      LOGS.LOG_WARN('No Records In The RTO_STAGING.AMI_USAGE Table.', v_PROCEDURE_NAME, 'Staging Table Content', c_PACKAGE_NAME);
   END IF;
-- Close The Interface And Stop The Process Log --
   LOGS.LOG_INFO(c_AMI_ACCOUNT_USAGE_PROCESS || ' Complete. Elapsed Seconds: ' || TO_CHAR(ROUND((DBMS_UTILITY.GET_TIME-v_MARK_TIME)/100)), v_PROCEDURE_NAME, c_EXIT, c_PACKAGE_NAME);
   STOP_PROCESS;
EXCEPTION
   WHEN OTHERS THEN
      ERRS.ABORT_PROCESS;
END RUN_AMI_ACCOUNT_USAGE_IMPORT;

PROCEDURE STATEMENT_TYPE_LIST(p_LABEL OUT VARCHAR2, p_CURSOR OUT GA.REFCURSOR) AS
BEGIN
   p_LABEL := 'Statement Type';
   OPEN p_CURSOR FOR
      SELECT STATEMENT_TYPE_NAME "OPTION", STATEMENT_TYPE_ID "OPTION_ID"
      FROM STATEMENT_TYPE
      WHERE STATEMENT_TYPE_NAME IN ('Final','Post Final Settlement #1')
      ORDER BY STATEMENT_TYPE_ID;
END STATEMENT_TYPE_LIST;

PROCEDURE DEX_POST_AMI_ACCOUNT_USAGE
   (
   p_ENTITY_LIST IN VARCHAR2,  --Statement Type Id--
   p_BEGIN_DATE  IN DATE,
   p_END_DATE    IN DATE,
   p_MESSAGE    OUT VARCHAR2
   ) AS
v_STATEMENT_TYPE_ID PLS_INTEGER := TO_NUMBER(TRIM(p_ENTITY_LIST));
v_BEGIN VARCHAR2(64) := 'TO_DATE(''' || TO_CHAR(p_BEGIN_DATE,'MM/DD/YYYY') || ''',''MM/DD/YYYY'')';
v_END VARCHAR2(64) := 'TO_DATE(''' || TO_CHAR(p_END_DATE,'MM/DD/YYYY') || ''',''MM/DD/YYYY'')';
v_PLSQL_BLOCK VARCHAR2(1000) := 'BEGIN CDI_AMI.RUN_AMI_ACCOUNT_USAGE_IMPORT(' || TO_CHAR(v_STATEMENT_TYPE_ID) || ', ' || v_BEGIN || ', ' || v_END || '); END;';
v_JOB_NAME VARCHAR2(64) := DBMS_SCHEDULER.GENERATE_JOB_NAME('IMPORT_AMI_USAGE#');
v_COUNT PLS_INTEGER;
BEGIN
   IF LOGS.CURRENT_LOG_LEVEL <= LOGS.c_LEVEL_DEBUG THEN
      p_MESSAGE := 'Debug Mode - PLSQL Block: ' || v_PLSQL_BLOCK;
      RETURN;
   END IF;
-- Check To See If There Is A Job Currently Running --
   SELECT COUNT(*) INTO v_COUNT FROM USER_SCHEDULER_JOBS WHERE SUBSTR(JOB_NAME,1,17) = v_JOB_NAME AND STATE = 'RUNNING';
   IF v_COUNT = 0 THEN
      DBMS_SCHEDULER.CREATE_JOB(v_JOB_NAME, 'PLSQL_BLOCK', v_PLSQL_BLOCK, START_DATE => NULL, ENABLED => TRUE, AUTO_DROP => TRUE, COMMENTS => 'Job Initiated By ' || USER);
      p_MESSAGE := 'AMI Account Usage Import Job Submitted.' || c_CRLF || 'Check Process Log For Execution Details.';
   ELSE
      p_MESSAGE := 'An AMI Account Usage Import Job Is Currently Running.' || c_CRLF || 'Only One Job Should Be Active At A Time.';
   END IF;
   COMMIT;
EXCEPTION
   WHEN OTHERS THEN
      p_MESSAGE := 'Exception: ' || SQLERRM;
END DEX_POST_AMI_ACCOUNT_USAGE;

PROCEDURE DEX_REPOST_AMI_ACCOUNT_USAGE
   (
   p_ENTITY_LIST IN VARCHAR2,  --Statement Type Id--
   p_BEGIN_DATE  IN DATE,
   p_END_DATE    IN DATE,
   p_MESSAGE    OUT VARCHAR2
   ) AS
v_STATEMENT_TYPE_ID PLS_INTEGER := TO_NUMBER(TRIM(p_ENTITY_LIST));
v_JOB_NAME VARCHAR2(64) := DBMS_SCHEDULER.GENERATE_JOB_NAME('IMPORT_AMI_USAGE#');
v_COUNT PLS_INTEGER;
BEGIN
-- Check To See If There Is A Job Currently Running --
   SELECT COUNT(*) INTO v_COUNT FROM USER_SCHEDULER_JOBS WHERE SUBSTR(JOB_NAME,1,17) = v_JOB_NAME AND STATE = 'RUNNING';
   IF v_COUNT = 0 THEN
      DELETE RTO_STAGING.AMI_USAGE;
      INSERT /*APPEND*/ INTO RTO_STAGING.AMI_USAGE(AMI_ACCOUNT_NAME, SERVICE_DATE, KW_1, KW_2, KW_3, KW_4, KW_5, KW_6, KW_7, KW_8, KW_9, KW_10, KW_11, KW_12, KW_13, KW_14, KW_15, KW_16, KW_17, KW_18, KW_19, KW_20, KW_21, KW_22, KW_23, KW_24, KW_25, SA_COUNT, ENTRY_DATE)
      SELECT AMI_ACCOUNT_NAME, SERVICE_DATE, KW_1, KW_2, KW_3, KW_4, KW_5, KW_6, KW_7, KW_8, KW_9, KW_10, KW_11, KW_12, KW_13, KW_14, KW_15, KW_16, KW_17, KW_18, KW_19, KW_20, KW_21, KW_22, KW_23, KW_24, KW_25, SA_COUNT, ENTRY_DATE
      FROM CDI_AMI_USAGE_ARCHIVE 
      WHERE SERVICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
         AND STATEMENT_TYPE_ID = v_STATEMENT_TYPE_ID;
      COMMIT;
      DEX_POST_AMI_ACCOUNT_USAGE(p_ENTITY_LIST, p_BEGIN_DATE, p_END_DATE, p_MESSAGE);
   ELSE
      p_MESSAGE := 'An AMI Account Usage Import Job Is Currently Running.' || c_CRLF || 'Only One Job Should Be Active At A Time.';
   END IF;
EXCEPTION
   WHEN OTHERS THEN
      p_MESSAGE := 'Exception: ' || SQLERRM;
END DEX_REPOST_AMI_ACCOUNT_USAGE;

PROCEDURE RUN_AMI_SA_SETTLEMENT_SETUP(p_BEGIN_DATE IN DATE) AS
v_PROCEDURE_NAME VARCHAR2(32) := 'RUN_AMI_SA_SETTLEMENT_SETUP';
v_SETTLEMENT_START_DATE DATE := TRUNC(p_BEGIN_DATE, 'MONTH');
v_SETTLEMENT_STOP_DATE DATE := LAST_DAY(p_BEGIN_DATE);
v_PJM_UPLOAD_DATE DATE := LAST_DAY(TRUNC(SYSDATE));
v_ENTRY_TIMESTAMP TIMESTAMP := SYSTIMESTAMP;
v_COUNT PLS_INTEGER;
v_MARK_TIME PLS_INTEGER := DBMS_UTILITY.GET_TIME;
BEGIN
-- Initialize This Interface And Start The Process Log --
   LOGS.START_PROCESS(c_AMI_SA_SETTLEMENT_PROCESS, v_SETTLEMENT_START_DATE, v_SETTLEMENT_STOP_DATE);
   INITIALIZE_INTERFACE(c_AMI_SA_SETTLEMENT_PROCESS);
-- Clear The Target Table --
   EXECUTE IMMEDIATE 'TRUNCATE TABLE CDI_AMI_SA_SETTLEMENT';
-- Populate The List Of Service Agreements Which Can Be Settled With AMI Usage In The Final Settlement --
   INSERT /*+ APPEND */ INTO CDI_AMI_SA_SETTLEMENT(BILL_ACCOUNT, SERVICE_POINT, PREMISE_NUMBER, TARIFF_ID, SUPPLIER, POLR_TYPE, PLC_BAND, SPECIAL_NOTATION, EFFECTIVE_DATE, TERMINATION_DATE, ENTRY_TIMESTAMP, SETTLEMENT_START_DATE, SETTLEMENT_STOP_DATE, PJM_UPLOAD_DATE)
   SELECT /*+ ORDERED INDEX(U,"BGE_RTO_MONTHLY_USAGE_IDX002") INDEX(U,"BGE_RTO_MONTHLY_USAGE_IDX003") PARALLEL(M,4) PARALLEL(B,4) USE_HASH(M,U) USE_HASH(U,B) */
      DISTINCT M.BILL_ACCOUNT, M.SERVICE_POINT, M.PREMISE_NUMBER, M.TARIFF_ID, M.SUPPLIER, M.POLR_TYPE, B.PLC_BAND,
      CASE WHEN TRIM(M.SPECIAL_NOTATION) IS NULL OR UPPER(TRIM(M.SPECIAL_NOTATION)) = 'BANKRUPTCY' THEN NULL ELSE REPLACE(UPPER(TRIM(M.SPECIAL_NOTATION)),' ') END,
      GREATEST(U.BEGIN_DATE, v_SETTLEMENT_START_DATE), LEAST(U.END_DATE, v_SETTLEMENT_STOP_DATE), v_ENTRY_TIMESTAMP, v_SETTLEMENT_START_DATE, v_SETTLEMENT_STOP_DATE, v_PJM_UPLOAD_DATE
   FROM BGE_RTO_MONTHLY_USAGE U
      JOIN BGE_MASTER_ACCOUNT   M ON M.BILL_ACCOUNT = U.BILL_ACCOUNT AND M.SERVICE_POINT = U.SERVICE_POINT AND U.BEGIN_DATE BETWEEN M.EFFECTIVE_DATE AND M.TERMINATION_DATE
      JOIN CDI_ACCOUNT_PLC_BAND B ON B.BILL_ACCOUNT = M.BILL_ACCOUNT AND B.SERVICE_POINT = M.SERVICE_POINT AND U.BEGIN_DATE BETWEEN B.BEGIN_DATE     AND B.END_DATE AND B.PREMISE_NUMBER = M.PREMISE_NUMBER
   WHERE NVL(U.PROCESS_CODE,'VALID') NOT IN ('ERROR','CANCEL')
      AND NVL(U.IS_ALM,0) = 0
      AND U.READ_CODE IN ('EB','RB')
      AND NVL(U.AMI_CHECK,'XXX') = 'AMI'
      AND U.BEGIN_DATE <= v_SETTLEMENT_STOP_DATE
      AND U.END_DATE >= v_SETTLEMENT_START_DATE;
   v_COUNT := SQL%ROWCOUNT;
-- Close The Interface And Stop The Process Log --
   LOGS.LOG_INFO('Number Of Records Inserted In The CDI_BGE_CI_VALIDATE Table: ' || TO_CHAR(v_COUNT), v_PROCEDURE_NAME, c_STEP_NAME, c_PACKAGE_NAME);
   LOGS.LOG_INFO(c_AMI_SA_SETTLEMENT_PROCESS || ' Complete. Elapsed Seconds: ' || TO_CHAR(ROUND((DBMS_UTILITY.GET_TIME-v_MARK_TIME)/100)), v_PROCEDURE_NAME, c_EXIT, c_PACKAGE_NAME);
   STOP_PROCESS;
EXCEPTION
   WHEN OTHERS THEN
      ERRS.ABORT_PROCESS;
END RUN_AMI_SA_SETTLEMENT_SETUP;

PROCEDURE RUN_AMI_SA_SETTLEMENT_ARCHIVE AS
v_PROCEDURE_NAME VARCHAR2(32) := 'RUN_AMI_SA_SETTLEMENT_ARCHIVE';
v_DELETE_COUNT PLS_INTEGER;
v_INSERT_COUNT PLS_INTEGER;
v_MARK_TIME PLS_INTEGER := DBMS_UTILITY.GET_TIME;
BEGIN
-- Initialize This Interface And Start The Process Log --
   LOGS.START_PROCESS(c_AMI_SA_ARCHIVE_PROCESS);
   INITIALIZE_INTERFACE(c_AMI_SA_ARCHIVE_PROCESS);
-- Before Posting New Content, Delete All Existing Records With Common Settlement Start, Settlement End, And PJM Upload Dates --
   DELETE CDI_AMI_SA_SETTLEMENT_ARCHIVE X
   WHERE (SETTLEMENT_START_DATE, SETTLEMENT_STOP_DATE, PJM_UPLOAD_DATE) = (SELECT DISTINCT SETTLEMENT_START_DATE, SETTLEMENT_STOP_DATE, PJM_UPLOAD_DATE FROM CDI_AMI_SA_SETTLEMENT);
   v_DELETE_COUNT := SQL%ROWCOUNT;
   INSERT INTO CDI_AMI_SA_SETTLEMENT_ARCHIVE(BILL_ACCOUNT, SERVICE_POINT, PREMISE_NUMBER, TARIFF_ID, SUPPLIER, POLR_TYPE, SPECIAL_NOTATION, PLC_BAND, EFFECTIVE_DATE, TERMINATION_DATE, ENTRY_TIMESTAMP, SETTLEMENT_START_DATE, SETTLEMENT_STOP_DATE, PJM_UPLOAD_DATE)
   SELECT BILL_ACCOUNT, SERVICE_POINT, PREMISE_NUMBER, TARIFF_ID, SUPPLIER, POLR_TYPE, SPECIAL_NOTATION, PLC_BAND, EFFECTIVE_DATE, TERMINATION_DATE, ENTRY_TIMESTAMP, SETTLEMENT_START_DATE, SETTLEMENT_STOP_DATE, PJM_UPLOAD_DATE FROM CDI_AMI_SA_SETTLEMENT;
   v_INSERT_COUNT := SQL%ROWCOUNT;
-- Close The Interface And Stop The Process Log --
   LOGS.LOG_INFO(c_AMI_SA_ARCHIVE_PROCESS || ' Complete. Delete CDI_AMI_SA_SETTLEMENT_ARCHIVE Count: ' || TO_CHAR(v_DELETE_COUNT) || ', Insert CDI_AMI_SA_SETTLEMENT_ARCHIVE Count: ' || TO_CHAR(v_INSERT_COUNT), v_PROCEDURE_NAME, c_EXIT, c_PACKAGE_NAME);
   STOP_PROCESS;
EXCEPTION
   WHEN OTHERS THEN
      ERRS.ABORT_PROCESS;
END RUN_AMI_SA_SETTLEMENT_ARCHIVE;

PROCEDURE GET_AMI_SA_SETTLEMENT_SUMMARY(p_SETTLEMENT_MONTH IN DATE, p_CURSOR OUT GA.REFCURSOR) AS
--@@Wrapper Procedure@@--
BEGIN
   CDI_REPORT.GET_AMI_SA_SETTLEMENT_SUMMARY(p_SETTLEMENT_MONTH, p_CURSOR);
END GET_AMI_SA_SETTLEMENT_SUMMARY;

PROCEDURE GET_AMI_SA_SETTLEMENT_DETAIL(p_SETTLEMENT_MONTH IN DATE, p_SERVICE_DATE IN DATE, p_CURSOR OUT GA.REFCURSOR) AS
--@@Wrapper Procedure@@--
BEGIN
   CDI_REPORT.GET_AMI_SA_SETTLEMENT_DETAIL(p_SETTLEMENT_MONTH, p_SERVICE_DATE, p_CURSOR);
END GET_AMI_SA_SETTLEMENT_DETAIL;

END CDI_AMI;
/

