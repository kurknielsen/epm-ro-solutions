CREATE OR REPLACE PACKAGE BODY CDI_ACCOUNT_SYNC AS

c_PACKAGE_NAME                 CONSTANT VARCHAR2(32) := 'CDI_ACCOUNT_SYNC';
c_SYSTEM_SETTING_MODULE        CONSTANT VARCHAR2(32) := 'Client Data Interface';
c_SYSTEM_SETTING_KEY1          CONSTANT VARCHAR2(32) := 'Data Import';
c_SYSTEM_SETTING_KEY2          CONSTANT VARCHAR2(32) := 'Account Sync';
c_ACCOUNT_SYNC_PROCESS         CONSTANT VARCHAR2(32) := 'CDI: Account Sync';
c_ACCOUNT_MODEL_OPTION         CONSTANT VARCHAR2(16) := 'Account';
c_AGGREGATE_MODEL_OPTION       CONSTANT VARCHAR2(16) := 'Aggregate';
c_INTERVAL_ACCOUNT_METER_TYPE  CONSTANT VARCHAR2(16) := 'Interval';
c_PERIOD_ACCOUNT_METER_TYPE    CONSTANT VARCHAR2(16) := 'Period';
c_CALENDAR_TYPE_FORECAST       CONSTANT VARCHAR2(16) := 'Forecast';
c_CALENDAR_TYPE_BACKCAST       CONSTANT VARCHAR2(16) := 'Backcast';
c_DATE_FORMAT                  CONSTANT VARCHAR2(16) := 'MM/DD/YYYY';
c_ENTRY                        CONSTANT VARCHAR2(8)  := 'Entry';
c_EXIT                         CONSTANT VARCHAR2(8)  := 'Exit';
c_DEFAULT_PLC_BAND             CONSTANT CHAR(1)      := 'Z';
c_MIN_I_ACCOUNTS               CONSTANT NUMBER       := 1;
c_MIN_A_ACCOUNTS               CONSTANT NUMBER       := 0;
c_INSTALLED_CAPACITY           CONSTANT VARCHAR2(16) := 'ICAP';
c_NETWORK_SERVICE              CONSTANT VARCHAR2(16) := 'Network Service';

l_ACCOUNT_ASSIGN_SYNC_LIST     CDI_ACCOUNT_ASSIGN_SYNC_LIST;

PROCEDURE GATHER_TABLE_STATS(p_TABLE_NAME IN VARCHAR2) IS
BEGIN
   DBMS_STATS.GATHER_TABLE_STATS(OWNNAME => USER, TABNAME => p_TABLE_NAME, ESTIMATE_PERCENT => DBMS_STATS.AUTO_SAMPLE_SIZE, BLOCK_SAMPLE => TRUE, DEGREE => NULL, CASCADE => TRUE);
END GATHER_TABLE_STATS;

PROCEDURE STAGE_CONTENT(p_FROM_DATE IN DATE, p_SYNC_DAYS IN PLS_INTEGER) AS
v_PROCEDURE_NAME VARCHAR2(30) := 'STAGE_CONTENT';
v_FROM_DATE DATE := TRUNC(p_FROM_DATE);
v_TO_DATE   DATE := TRUNC(p_FROM_DATE) + p_SYNC_DAYS;
v_MARK_TIME PLS_INTEGER := DBMS_UTILITY.GET_TIME;
BEGIN

   LOGS.LOG_INFO(c_ENTRY || ', From Date: ' || TO_CHAR(v_FROM_DATE, c_DATE_FORMAT) || ', To Date: ' || TO_CHAR(v_TO_DATE, c_DATE_FORMAT), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
   EXECUTE IMMEDIATE 'TRUNCATE TABLE CDI_MAIN';
   INSERT /*+ APPEND */ INTO CDI_MAIN (BILL_ACCOUNT, SERVICE_POINT, PREMISE_NUMBER, TARIFF_CODE, NODE, POLR_TYPE, SUPPLIER, CITY_COUNTY, EFFECT_DATE, TERM_DATE, SPECIAL_NOTATION, STATUS_INDICATION, BGE_TIMESTAMP, TIME_STAMP, IDR_STATUS, RTO_POOL_ID, PLC_BAND, RTO_ACCOUNT_ID, ESP_ID, METER_TYPE, VOLTAGE_LEVEL, RATE_CLASS, ACCOUNT_METER_EXT_IDENTIFIER, IS_ALM, IS_TOU, REPORTED_SEGMENT)
   SELECT BILL_ACCOUNT, SERVICE_POINT, PREMISE_NUMBER, TARIFF_CODE, NODE, TRIM(POLR_TYPE) POLR_TYPE, SUPPLIER, CITY_COUNTY_CODE, GREATEST(EFFECTIVE_DATE, v_FROM_DATE) "EFFECT_DATE", LEAST(NVL(TERMINATION_DATE, CONSTANTS.HIGH_DATE), v_TO_DATE) "TERM_DATE", NULL "SPECIAL_NOTATION", STATUS_INDICATION, GREATEST(EFFECTIVE_DATE, v_FROM_DATE) AS AGG_BEGIN_DATE, LEAST(NVL(TERMINATION_DATE, CONSTANTS.HIGH_DATE), v_TO_DATE) AS AGG_END_DATE, IDR_STATUS, RTRIM(RTRIM(RTRIM(RTRIM(RTO_POOL_ID,'_EMPTY'),'_CABLEDEVICE'),'_IDSALES'),'_MTR_CHANGE') || '_' || c_DEFAULT_PLC_BAND "RTO_POOL_ID", c_DEFAULT_PLC_BAND "PLC_BAND", AGGR_IDENTIFIER, ESP_ID, METER_TYPE, VOLTAGE_LEVEL, RATE_CLASS, STUDY_ID, NULL, NULL, REPORTED_SEGMENT
   FROM BGE_MASTER_ACCOUNT
   WHERE EFFECTIVE_DATE <= v_TO_DATE
      AND TERMINATION_DATE >= v_FROM_DATE;
   LOGS.LOG_INFO('Number Of Records Posted To The CDI_MAIN Table: ' || TO_CHAR(SQL%ROWCOUNT), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
   COMMIT;
   GATHER_TABLE_STATS('CDI_MAIN');

   EXECUTE IMMEDIATE 'TRUNCATE TABLE CDI_INDIVIDUAL_ACCOUNT_NEW';
   INSERT /*+ APPEND */ INTO CDI_INDIVIDUAL_ACCOUNT_NEW(BILL_ACCOUNT, SUPPLIER, BEGIN_DATE, END_DATE, IDR_STATUS, RTO_POOL_ID, PLC_BAND, RTO_ACCOUNT_IDENTIFIER, ESP_ID, METER_TYPE, VOLTAGE_LEVEL, RATE_CLASS, ACCOUNT_METER_EXT_IDENTIFIER, USAGE_VAL)
   SELECT BILL_ACCOUNT, SUPPLIER, EFFECT_DATE, TERM_DATE, IDR_STATUS, TRIM(RTO_POOL_ID), PLC_BAND, RTO_ACCOUNT_ID, ESP_ID, METER_TYPE, VOLTAGE_LEVEL, RATE_CLASS, ACCOUNT_METER_EXT_IDENTIFIER, 0
   FROM CDI_MAIN 
   WHERE IDR_STATUS = 'Y'
   UNION ALL
   SELECT NULL, SUPPLIER, EFFECT_DATE, TERM_DATE, IDR_STATUS, TRIM(RTO_POOL_ID), PLC_BAND, RTO_ACCOUNT_ID, ESP_ID, METER_TYPE, VOLTAGE_LEVEL, RATE_CLASS, ACCOUNT_METER_EXT_IDENTIFIER, 0
   FROM CDI_MAIN
   WHERE IDR_STATUS <> 'Y'
   GROUP BY POLR_TYPE, SUPPLIER, EFFECT_DATE, TERM_DATE, IDR_STATUS, TRIM(RTO_POOL_ID), PLC_BAND, RTO_ACCOUNT_ID, ESP_ID, METER_TYPE , VOLTAGE_LEVEL, RATE_CLASS, ACCOUNT_METER_EXT_IDENTIFIER;
   LOGS.LOG_INFO('Number Of Records Posted To The CDI_INDIVIDUAL_ACCOUNT_NEW Table: ' || TO_CHAR(SQL%ROWCOUNT), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
   COMMIT;
   GATHER_TABLE_STATS('CDI_INDIVIDUAL_ACCOUNT_NEW');

   SELECT CDI_ACCOUNT_ASSIGN_SYNC_TYPE(RTO_ACCOUNT_IDENTIFIER, 'BGE', TRIM(SUPPLIER), RTO_POOL_ID, CASE WHEN METER_TYPE = 'I' THEN BILL_ACCOUNT ELSE '?' END, NULL, RTO_ACCOUNT_IDENTIFIER, RATE_CLASS, RATE_CLASS, NULL, NULL, CASE WHEN METER_TYPE = 'I' THEN c_INTERVAL_ACCOUNT_METER_TYPE ELSE c_PERIOD_ACCOUNT_METER_TYPE END, 'BWI', BEGIN_DATE, END_DATE)
   BULK COLLECT INTO l_ACCOUNT_ASSIGN_SYNC_LIST
   FROM CDI_INDIVIDUAL_ACCOUNT_NEW
   ORDER BY RTO_ACCOUNT_IDENTIFIER, BEGIN_DATE, END_DATE;
   LOGS.LOG_INFO('Individual Account New Collector Count: ' || TO_CHAR(l_ACCOUNT_ASSIGN_SYNC_LIST.COUNT), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
   LOGS.LOG_INFO('Elapsed Seconds: ' || TO_CHAR(ROUND((DBMS_UTILITY.GET_TIME-v_MARK_TIME)/100)), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);

END STAGE_CONTENT;

PROCEDURE SYNC_POOL(p_FROM_DATE IN DATE, p_SYNC_DAYS IN NUMBER) AS
v_PROCEDURE_NAME VARCHAR2(30) := 'SYNC_POOL';
v_POOL_SYNC_LIST CDI_POOL_SYNC_LIST;
v_MARK_TIME PLS_INTEGER := DBMS_UTILITY.GET_TIME;
BEGIN
   LOGS.LOG_INFO(c_ENTRY, v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
   SELECT CDI_POOL_SYNC_TYPE(POOL_EXTERNAL_IDENTIFIER, POOL_EXTERNAL_IDENTIFIER, POOL_EXTERNAL_IDENTIFIER, POOL_EXTERNAL_IDENTIFIER, 'Active', 'None', 0, NULL, TRIM(POLR_TYPE), 0, TRIM(TARIFF_CODE), TRIM(PLC_BAND), TRIM(REPORTED_SEGMENT), TRIM(VOLTAGE_LEVEL))
   BULK COLLECT INTO v_POOL_SYNC_LIST
   FROM (SELECT DISTINCT TRIM(RTO_POOL_ID) "POOL_EXTERNAL_IDENTIFIER", TARIFF_CODE, POLR_TYPE, PLC_BAND, SPECIAL_NOTATION, IS_TOU, REPORTED_SEGMENT, VOLTAGE_LEVEL FROM CDI_MAIN);
   LOGS.LOG_INFO('Pool List Collector Count: ' || TO_CHAR(v_POOL_SYNC_LIST.COUNT), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
   IF v_POOL_SYNC_LIST IS NULL OR v_POOL_SYNC_LIST.COUNT() = 0 THEN
      LOGS.LOG_WARN('Pool List Collector Is Empty', v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
   ELSE 
      CDI_BK.SYNC_POOL(v_POOL_SYNC_LIST);
   END IF;
   LOGS.LOG_INFO('Elapsed Seconds: ' || TO_CHAR(ROUND((DBMS_UTILITY.GET_TIME-v_MARK_TIME)/100)), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
END SYNC_POOL;

PROCEDURE SYNC_ACCOUNT(p_FROM_DATE IN DATE, p_SYNC_DAYS IN NUMBER) AS
v_PROCEDURE_NAME VARCHAR2(30) := 'SYNC_ACCOUNT';
v_ACCOUNT_LIST             CDI_ACCOUNT_SYNC_LIST;
v_ACCOUNT_CALENDAR_LIST    CDI_ACCOUNT_CALENDAR_SYNC_LIST;
v_ACCOUNT_LOSS_FACTOR_LIST CDI_ACCNT_LOSS_FAC_SYNC_LIST;
v_AMI_BEFORE PLS_INTEGER;
v_AMI_AFTER  PLS_INTEGER;
v_MARK_TIME  PLS_INTEGER := DBMS_UTILITY.GET_TIME;
BEGIN

   LOGS.LOG_INFO(c_ENTRY, v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
   SELECT COUNT(*) INTO v_AMI_BEFORE FROM ACCOUNT WHERE ACCOUNT_SIC_CODE = 'AMI';

   WITH SELECT_ACCOUNTS AS
      (SELECT DISTINCT RTO_ACCOUNT_IDENTIFIER "ACCOUNT_EXTERNAL_IDENTIFIER", RTO_ACCOUNT_IDENTIFIER "ACCOUNT_NAME", CASE WHEN METER_TYPE = 'I' THEN c_INTERVAL_ACCOUNT_METER_TYPE ELSE c_PERIOD_ACCOUNT_METER_TYPE END "ACCOUNT_METER_TYPE", NULL "ACCOUNT_DUNS_NUMBER", NULL "ACCOUNT_SIC_CODE", ACCOUNT_METER_EXT_IDENTIFIER, RTO_POOL_ID "ACCOUNT_POOL_IDENTIFIER"
      FROM CDI_INDIVIDUAL_ACCOUNT_NEW
      UNION SELECT DISTINCT ACCOUNT_EXTERNAL_IDENTIFIER, ACCOUNT_NAME, ACCOUNT_METER_TYPE, ACCOUNT_DUNS_NUMBER, ACCOUNT_SIC_CODE, ACCOUNT_METER_EXT_IDENTIFIER, ACCOUNT_POOL_IDENTIFIER
      FROM CDI_AMI_PSEUDO_ACCOUNT$)
   SELECT CDI_ACCOUNT_SYNC_TYPE(
      ACCOUNT_NAME,                                                                                                                 -- ACCOUNT_NAME --
      CASE WHEN ACCOUNT_NAME LIKE '%AMI%' THEN SUBSTR(TRIM(SUBSTR(ACCOUNT_NAME, INSTR(ACCOUNT_NAME, '_') + 1)),1,32) ELSE NULL END, -- ACCOUNT_ALIAS --
      ACCOUNT_EXTERNAL_IDENTIFIER,                                                                                                  -- ACCOUNT_EXTERNAL_IDENTIFIER --
      NULL,                                                                                                                         -- ACCOUNT_DISPLAY_NAME --
      NULL,                                                                                                                         -- ACCOUNT_BILL_OPTION --
      CASE WHEN ACCOUNT_METER_TYPE = c_INTERVAL_ACCOUNT_METER_TYPE THEN c_ACCOUNT_MODEL_OPTION ELSE c_AGGREGATE_MODEL_OPTION END,   -- ACCOUNT_MODEL_OPTION --
      ACCOUNT_SIC_CODE,                                                                                                             -- ACCOUNT_SIC_CODE --
      'Eastern',                                                                                                                    -- ACCOUNT_TIME_ZONE --
      ACCOUNT_METER_TYPE,                                                                                                           -- ACCOUNT_METER_TYPE --
      'Active',                                                                                                                     -- ACCOUNT_STATUS --
      1,                                                                                                                            -- ACCOUNT_IS_ACTIVE --
      1,                                                                                                                            -- MODEL_ID --
      1,                                                                                                                            -- IS_UFE_PARTICIPANT --
      0,                                                                                                                            -- IS_EXTERNAL_INTERVAL_USAGE --
      0,                                                                                                                            -- IS_EXTERNAL_BILLED_USAGE --
      0,                                                                                                                            -- IS_CREATE_SETTLEMENT_PROFILE --
      0,                                                                                                                            -- IS_EXTERNAL_FORECAST --
      NULL,                                                                                                                         -- SERVICE_LOCATION_NAME --
      NULL,                                                                                                                         -- SERVICE_POINT_NAME --
      NULL,                                                                                                                         -- WEATHER_STATION_NAME --
      NULL,                                                                                                                         -- BILL_CYCLE_NAME --
      NULL,                                                                                                                         -- ACCOUNT_DESC --
      ACCOUNT_DUNS_NUMBER,                                                                                                          -- ACCOUNT_DUNS_NUMBER --
      ACCOUNT_METER_EXT_IDENTIFIER,                                                                                                 -- ACCOUNT_METER_EXT_IDENTIFIER --
      CONSTANTS.NOT_ASSIGNED,                                                                                                       -- ACCOUNT_ROLLUP_ID --
      CASE WHEN ACCOUNT_METER_TYPE <> c_INTERVAL_ACCOUNT_METER_TYPE THEN 1 ELSE 0 END,                                              -- IS_AGGREGATE_ACCOUNT --
      CONSTANTS.NOT_ASSIGNED)                                                                                                       -- TX_SERVICE_TYPE_ID --
   BULK COLLECT INTO v_ACCOUNT_LIST
   FROM SELECT_ACCOUNTS
   ORDER BY ACCOUNT_EXTERNAL_IDENTIFIER;
   LOGS.LOG_INFO('Account Sync Collector Count: ' || TO_CHAR(v_ACCOUNT_LIST.COUNT), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);

   SELECT CDI_ACCOUNT_CALENDAR_SYNC_TYPE(ACCOUNT_EXTERNAL_IDENTIFIER, CASE WHEN ACCOUNT_METER_TYPE = c_PERIOD_ACCOUNT_METER_TYPE THEN ACCOUNT_EXTERNAL_IDENTIFIER ELSE CASE WHEN RATE_CLASS IN ('NR','P') THEN 'PL' ELSE RATE_CLASS END || '_BWI' END || '_Settlement', c_CALENDAR_TYPE_BACKCAST, GA.BASE_CASE_ID, BEGIN_DATE, END_DATE)
   BULK COLLECT INTO v_ACCOUNT_CALENDAR_LIST
   FROM TABLE(CAST(l_ACCOUNT_ASSIGN_SYNC_LIST AS CDI_ACCOUNT_ASSIGN_SYNC_LIST))
   WHERE ACCOUNT_METER_TYPE = c_INTERVAL_ACCOUNT_METER_TYPE
   ORDER BY ACCOUNT_EXTERNAL_IDENTIFIER, BEGIN_DATE, END_DATE;
   LOGS.LOG_INFO('Account Forecast Calendar Collector Count: ' || TO_CHAR(v_ACCOUNT_CALENDAR_LIST.COUNT), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);

   SELECT CDI_ACCNT_LOSS_FAC_SYNC_TYPE(RTO_ACCOUNT_IDENTIFIER, VOLTAGE_LEVEL, BEGIN_DATE, END_DATE)
   BULK COLLECT INTO v_ACCOUNT_LOSS_FACTOR_LIST
   FROM
      (SELECT RTO_ACCOUNT_IDENTIFIER, VOLTAGE_LEVEL, MIN(BEGIN_DATE) "BEGIN_DATE", MAX(END_DATE) "END_DATE"
      FROM
         (SELECT RTO_ACCOUNT_IDENTIFIER, VOLTAGE_LEVEL, BEGIN_DATE, END_DATE
         FROM CDI_INDIVIDUAL_ACCOUNT_NEW
         WHERE RTO_ACCOUNT_IDENTIFIER NOT IN (SELECT ACCOUNT_EXTERNAL_IDENTIFIER FROM ACCOUNT WHERE ACCOUNT_MODEL_OPTION = 'Aggregate')
         UNION SELECT ACCOUNT_EXTERNAL_IDENTIFIER, VOLTAGE_LEVEL, BEGIN_DATE, END_DATE
         FROM CDI_AMI_PSEUDO_ACCOUNT$)
      GROUP BY RTO_ACCOUNT_IDENTIFIER, VOLTAGE_LEVEL
      ORDER BY RTO_ACCOUNT_IDENTIFIER, BEGIN_DATE, END_DATE);
   LOGS.LOG_INFO('Account Loss Factor Collector Count: ' || TO_CHAR(v_ACCOUNT_LOSS_FACTOR_LIST.COUNT), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);

   GATHER_TABLE_STATS('ACCOUNT');
   CDI_BK.SYNC_ACCOUNT(v_ACCOUNT_LIST);
   CDI_BK.SYNC_ACCOUNT_CALENDAR_AFTER(p_FROM_DATE, c_CALENDAR_TYPE_BACKCAST, v_ACCOUNT_CALENDAR_LIST);
   CDI_BK.SYNC_ACCOUNT_LOSS_FACTOR_AFTER(p_FROM_DATE, GA.BASE_CASE_ID, v_ACCOUNT_LOSS_FACTOR_LIST);
   GATHER_TABLE_STATS('ACCOUNT_CALENDAR');
   GATHER_TABLE_STATS('ACCOUNT_LOSS_FACTOR');

   SELECT COUNT(*) INTO v_AMI_AFTER FROM ACCOUNT WHERE ACCOUNT_SIC_CODE = 'AMI';
   LOGS.LOG_INFO('AMI Pseudo-Account Processing Counts, Before: ' || TO_CHAR(v_AMI_BEFORE) || ', After: ' || TO_CHAR(v_AMI_AFTER) || ', Delta: ' || TO_CHAR(v_AMI_AFTER - v_AMI_BEFORE), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
   LOGS.LOG_INFO('Elapsed Seconds: ' || TO_CHAR(ROUND((DBMS_UTILITY.GET_TIME-v_MARK_TIME)/100)), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);

END SYNC_ACCOUNT;

PROCEDURE SYNC_ACCOUNT_EDC(p_FROM_DATE IN DATE, p_SYNC_DAYS IN NUMBER) AS
v_PROCEDURE_NAME VARCHAR2(30) := 'SYNC_ACCOUNT_EDC';
v_ACCOUNT_EDC_SYNC CDI_ACCOUNT_EDC_SYNC_LIST;
v_MARK_TIME PLS_INTEGER := DBMS_UTILITY.GET_TIME;
BEGIN
   LOGS.LOG_INFO(c_ENTRY, v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
   SELECT CDI_ACCOUNT_EDC_SYNC_TYPE(ACCOUNT_EXTERNAL_IDENTIFIER, EDC_EXTERNAL_IDENTIFIER, EDC_ACCOUNT_NUMBER, RATE_CLASS, '?', BEGIN_DATE, END_DATE)
   BULK COLLECT INTO v_ACCOUNT_EDC_SYNC
   FROM
      (SELECT ACCOUNT_EXTERNAL_IDENTIFIER, EDC_EXTERNAL_IDENTIFIER, EDC_ACCOUNT_NUMBER, RATE_CLASS, MIN(BEGIN_DATE) AS BEGIN_DATE, MAX(END_DATE) AS END_DATE
      FROM TABLE(CAST(l_ACCOUNT_ASSIGN_SYNC_LIST AS CDI_ACCOUNT_ASSIGN_SYNC_LIST))
      GROUP BY ACCOUNT_EXTERNAL_IDENTIFIER, EDC_EXTERNAL_IDENTIFIER, EDC_ACCOUNT_NUMBER, RATE_CLASS
      UNION SELECT ACCOUNT_EXTERNAL_IDENTIFIER, EDC_EXTERNAL_IDENTIFIER, NULL, NULL, BEGIN_DATE, END_DATE
      FROM CDI_AMI_PSEUDO_ACCOUNT$
      ORDER BY 1,2,5,6);
   LOGS.LOG_INFO('Account EDC Sync Collector Count: ' || TO_CHAR(v_ACCOUNT_EDC_SYNC.COUNT), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
   CDI_BK.SYNC_ACCOUNT_EDC_AFTER(p_FROM_DATE, v_ACCOUNT_EDC_SYNC);
   GATHER_TABLE_STATS('ACCOUNT_EDC');
   LOGS.LOG_INFO('Elapsed Seconds: ' || TO_CHAR(ROUND((DBMS_UTILITY.GET_TIME-v_MARK_TIME)/100)), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
END SYNC_ACCOUNT_EDC;

PROCEDURE SYNC_ACCOUNT_ESP(p_FROM_DATE IN DATE, p_SYNC_DAYS IN NUMBER) AS
v_PROCEDURE_NAME VARCHAR2(30) := 'SYNC_ACCOUNT_ESP';
v_ACCOUNT_ESP_SYNC CDI_ACCOUNT_ESP_SYNC_LIST;
v_MARK_TIME PLS_INTEGER := DBMS_UTILITY.GET_TIME;
BEGIN
   LOGS.LOG_INFO(c_ENTRY, v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
   SELECT CDI_ACCOUNT_ESP_SYNC_TYPE(ACCOUNT_EXTERNAL_IDENTIFIER, ESP_EXTERNAL_IDENTIFIER, POOL_EXTERNAL_IDENTIFIER, BEGIN_DATE, END_DATE,'?')
   BULK COLLECT INTO v_ACCOUNT_ESP_SYNC
   FROM
   (SELECT DISTINCT ACCOUNT_EXTERNAL_IDENTIFIER, ESP_EXTERNAL_IDENTIFIER, POOL_EXTERNAL_IDENTIFIER, CASE WHEN ACCOUNT_METER_TYPE = c_INTERVAL_ACCOUNT_METER_TYPE THEN BEGIN_DATE ELSE MIN (BEGIN_DATE) OVER (PARTITION BY ACCOUNT_EXTERNAL_IDENTIFIER, EDC_EXTERNAL_IDENTIFIER, POOL_EXTERNAL_IDENTIFIER) END BEGIN_DATE, CASE WHEN ACCOUNT_METER_TYPE = c_INTERVAL_ACCOUNT_METER_TYPE THEN END_DATE ELSE MAX(END_DATE) OVER (PARTITION BY ACCOUNT_EXTERNAL_IDENTIFIER, EDC_EXTERNAL_IDENTIFIER, POOL_EXTERNAL_IDENTIFIER) END END_DATE
   FROM TABLE(CAST(l_ACCOUNT_ASSIGN_SYNC_LIST AS CDI_ACCOUNT_ASSIGN_SYNC_LIST))
   WHERE ACCOUNT_METER_TYPE = c_INTERVAL_ACCOUNT_METER_TYPE)
   ORDER BY ACCOUNT_EXTERNAL_IDENTIFIER, ESP_EXTERNAL_IDENTIFIER, POOL_EXTERNAL_IDENTIFIER, BEGIN_DATE, END_DATE;
   LOGS.LOG_INFO('Account ESP Sync Collector Count: ' || TO_CHAR(v_ACCOUNT_ESP_SYNC.COUNT), v_PROCEDURE_NAME);
   CDI_BK.SYNC_ACCOUNT_ESP_AFTER(p_FROM_DATE, v_ACCOUNT_ESP_SYNC);
   GATHER_TABLE_STATS('ACCOUNT_ESP');
   LOGS.LOG_INFO('Elapsed Seconds: ' || TO_CHAR(ROUND((DBMS_UTILITY.GET_TIME-v_MARK_TIME)/100)), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
END SYNC_ACCOUNT_ESP;

PROCEDURE SYNC_ACCOUNT_SERVICE_LOCATION(p_FROM_DATE IN DATE, p_SYNC_DAYS IN NUMBER) AS
v_PROCEDURE_NAME VARCHAR2(30) := 'SYNC_ACCOUNT_SERVICE_LOCATION';
CURSOR c_SELECT IS
   WITH STAGED_CONTENT AS
      (SELECT DISTINCT ACCOUNT_EXTERNAL_IDENTIFIER, SERVICE_LOCATION_IDENTIFIER
      FROM
         (SELECT DISTINCT ACCOUNT_EXTERNAL_IDENTIFIER, ACCOUNT_SERV_LOC_EXT_ID "SERVICE_LOCATION_IDENTIFIER" FROM TABLE(CAST(l_ACCOUNT_ASSIGN_SYNC_LIST AS CDI_ACCOUNT_ASSIGN_SYNC_LIST))
         UNION
         SELECT DISTINCT ACCOUNT_EXTERNAL_IDENTIFIER, SERVICE_LOCATION_IDENTIFIER FROM CDI_AMI_PSEUDO_ACCOUNT$))
   SELECT X.ACCOUNT_EXTERNAL_IDENTIFIER, X.SERVICE_LOCATION_IDENTIFIER, A.ACCOUNT_ID, SL.SERVICE_LOCATION_ID, CASE WHEN ASL.ACCOUNT_ID IS NULL THEN 1 ELSE 0 END IS_NEW_ENTRY
   FROM STAGED_CONTENT X
      LEFT JOIN ACCOUNT A ON A.ACCOUNT_EXTERNAL_IDENTIFIER = X.ACCOUNT_EXTERNAL_IDENTIFIER
      LEFT JOIN SERVICE_LOCATION SL ON SL.EXTERNAL_IDENTIFIER = X.SERVICE_LOCATION_IDENTIFIER
      LEFT JOIN ACCOUNT_SERVICE_LOCATION ASL ON ASL.ACCOUNT_ID = A.ACCOUNT_ID AND ASL.SERVICE_LOCATION_ID = SL.SERVICE_LOCATION_ID AND ASL.BEGIN_DATE = CONSTANTS.LOW_DATE;
v_COUNT PLS_INTEGER := 0;
v_MARK_TIME PLS_INTEGER := DBMS_UTILITY.GET_TIME;
BEGIN
   LOGS.LOG_INFO(c_ENTRY, v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
   FOR v_SELECT IN c_SELECT LOOP
      IF v_SELECT.ACCOUNT_ID IS NULL THEN
         LOGS.LOG_ERROR('Account Associated With The External Identifier "' || v_SELECT.ACCOUNT_EXTERNAL_IDENTIFIER || '" Is Not Defined', v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
      END IF;
      IF v_SELECT.ACCOUNT_ID IS NULL THEN
         LOGS.LOG_ERROR('Service Location Associated With The External Identifier "' || v_SELECT.SERVICE_LOCATION_IDENTIFIER || '" Is Not Defined', v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
      END IF;
      IF v_SELECT.IS_NEW_ENTRY = 1 THEN
         RO.PUT_ACCOUNT_SERVICE_LOCATION(
            p_ACCOUNT_ID          => v_SELECT.ACCOUNT_ID,
            p_SERVICE_LOCATION_ID => v_SELECT.SERVICE_LOCATION_ID,
            p_SERVICE_DATE        => CONSTANTS.LOW_DATE);
         v_COUNT := v_COUNT + 1;
      END IF;
   END LOOP;
   GATHER_TABLE_STATS('ACCOUNT_SERVICE_LOCATION');
   LOGS.LOG_INFO('Account Service Location Insert Count: ' || TO_CHAR(v_COUNT), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
   LOGS.LOG_INFO('Elapsed Seconds: ' || TO_CHAR(ROUND((DBMS_UTILITY.GET_TIME-v_MARK_TIME)/100)), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
END SYNC_ACCOUNT_SERVICE_LOCATION;

PROCEDURE CACHE_DAILY_USAGE_FACTOR(p_SERVICE_DATE IN DATE) AS
v_PROCEDURE_NAME VARCHAR2(30) := 'CACHE_DAILY_USAGE_FACTOR';
v_ASSIGNED PLS_INTEGER;
v_NOT_ASSIGNED PLS_INTEGER;
v_MARK_TIME PLS_INTEGER := DBMS_UTILITY.GET_TIME;
BEGIN
   LOGS.LOG_INFO('Cache Daily Usage Factors For Service Date: ' || TO_CHAR(p_SERVICE_DATE, c_DATE_FORMAT), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
   EXECUTE IMMEDIATE 'TRUNCATE TABLE CDI_DAILY_USAGE_FACTOR';
   INSERT INTO CDI_DAILY_USAGE_FACTOR(BILL_ACCOUNT, SERVICE_POINT, USAGE_FACTOR)
   WITH CANDIDATES AS
      (SELECT BILL_ACCOUNT, SERVICE_POINT, MAX(BEGIN_DATE) "BEGIN_DATE"
      FROM BGE_RTO_MONTHLY_USAGE
      WHERE BEGIN_DATE <= p_SERVICE_DATE
      GROUP BY BILL_ACCOUNT, SERVICE_POINT)
   SELECT B.BILL_ACCOUNT, B.SERVICE_POINT, CASE WHEN B.USAGE_FACTOR = -1 THEN 1 ELSE B.USAGE_FACTOR END
   FROM CANDIDATES A
      JOIN BGE_RTO_MONTHLY_USAGE B ON B.BILL_ACCOUNT = A.BILL_ACCOUNT AND B.SERVICE_POINT = A.SERVICE_POINT AND B.BEGIN_DATE = A.BEGIN_DATE;
   LOGS.LOG_INFO('Daily Usage Factor Records: ' || TO_CHAR(SQL%ROWCOUNT), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
   COMMIT;
   LOGS.LOG_INFO('Elapsed Seconds: ' || TO_CHAR(ROUND((DBMS_UTILITY.GET_TIME-v_MARK_TIME)/100)), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
END CACHE_DAILY_USAGE_FACTOR;

PROCEDURE SYNC_AGGREGATE_ACCOUNT(p_FROM_DATE IN DATE, p_SYNC_DAYS IN NUMBER) AS
v_PROCEDURE_NAME VARCHAR2(30) := 'SYNC_AGGREGATE_ACCOUNT';
CURSOR c_SELECT_MISSING IS SELECT * FROM CDI_AGGREGATE_ACCOUNT$ WHERE ACCOUNT_ID IS NULL OR ESP_ID IS NULL OR POOL_ID IS NULL;
CURSOR c_SELECT_NEW IS
   SELECT DISTINCT ACCOUNT_ID, ESP_ID, POOL_ID
   FROM CDI_AGGREGATE_ACCOUNT$ X
   WHERE ACCOUNT_ID IS NOT NULL
      AND ESP_ID IS NOT NULL
      AND POOL_ID IS NOT NULL
      AND NOT EXISTS (SELECT NULL FROM AGGREGATE_ACCOUNT_ESP WHERE ACCOUNT_ID = X.ACCOUNT_ID AND ESP_ID = X.ESP_ID AND POOL_ID = X.POOL_ID AND BEGIN_DATE = CONSTANTS.LOW_DATE);
v_ENTRY_DATE   DATE := CURRENT_DATE;
v_SERVICE_DATE DATE := p_FROM_DATE;
v_END_DATE     DATE := p_FROM_DATE + p_SYNC_DAYS - 1;
v_COUNT        PLS_INTEGER := 0;
v_STATUS       PLS_INTEGER;
v_MARK_TIME    PLS_INTEGER := DBMS_UTILITY.GET_TIME;
BEGIN
   LOGS.LOG_INFO(c_ENTRY, v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
   EXECUTE IMMEDIATE 'TRUNCATE TABLE CDI_AGGREGATE_ACCOUNTS';
   INSERT /*APPEND*/ INTO CDI_AGGREGATE_ACCOUNTS(RTO_ACCOUNT_ID, SUPPLIER, RTO_POOL_ID, BEGIN_DATE, END_DATE, CUSTOMER_COUNT, USAGE_FACTOR)
   SELECT RTO_ACCOUNT_ID, SUPPLIER, RTO_POOL_ID, EFFECT_DATE "BEGIN_DATE", TERM_DATE "END_DATE", COUNT(*), NULL USAGE_FACTOR
   FROM CDI_MAIN
   WHERE IDR_STATUS <> 'Y'
   GROUP BY RTO_ACCOUNT_ID, SUPPLIER, RTO_POOL_ID, EFFECT_DATE, TERM_DATE;
   LOGS.LOG_INFO('Number Of Records Posted To The CDI_AGGREGATE_ACCOUNTS Table: ' || TO_CHAR(SQL%ROWCOUNT), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
   COMMIT;
-- Capture Any New Aggregate-Account/ESP/Pool Combinations --
   FOR v_SELECT IN c_SELECT_NEW LOOP
      RA.PUT_AGGREGATE_ACCOUNT_ESP(
         p_ACCOUNT_ID     => v_SELECT.ACCOUNT_ID,
         p_ESP_ID         => v_SELECT.ESP_ID,
         p_POOL_ID        => v_SELECT.POOL_ID,
         p_BEGIN_DATE     => p_FROM_DATE,
         p_END_DATE       => v_END_DATE,
         p_OLD_ESP_ID     => v_SELECT.ESP_ID,
         p_OLD_POOL_ID    => v_SELECT.POOL_ID,
         p_OLD_BEGIN_DATE => p_FROM_DATE,
         p_STATUS         => v_STATUS);
      v_COUNT := v_COUNT + SQL%ROWCOUNT;
   END LOOP;
   LOGS.LOG_INFO('Aggregate Account ESP Insert Count: ' || TO_CHAR(v_COUNT), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
   COMMIT;
-- Inventory Any Missing Entity References --
   FOR v_SELECT IN c_SELECT_MISSING LOOP
      IF v_SELECT.ACCOUNT_ID IS NULL THEN
         LOGS.LOG_ERROR('Account Associated With The External Identifier "' || v_SELECT.ACCOUNT_IDENTIFIER || '" Is Not Defined', v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
      END IF;
      IF v_SELECT.ESP_ID IS NULL THEN
         LOGS.LOG_ERROR('ESP Associated With The External Identifier "' || v_SELECT.ESP_IDENTIFIER || '" Is Not Defined', v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
      END IF;   
      IF v_SELECT.POOL_ID IS NULL THEN
         LOGS.LOG_ERROR('Pool Associated With The External Identifier "' || v_SELECT.POOL_IDENTIFIER || '" Is Not Defined', v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
      END IF;
   END LOOP;
   COMMIT;
   GATHER_TABLE_STATS('AGGREGATE_ACCOUNT_ESP');
   LOGS.LOG_INFO('Elapsed Seconds: ' || TO_CHAR(ROUND((DBMS_UTILITY.GET_TIME-v_MARK_TIME)/100)), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
END SYNC_AGGREGATE_ACCOUNT;

PROCEDURE SYNC_AGGREGATE_ACCOUNT_SERVICE(p_FROM_DATE IN DATE, p_SYNC_DAYS IN NUMBER) AS
v_PROCEDURE_NAME VARCHAR2(30) := 'SYNC_AGGREGATE_ACCOUNT_SERVICE';
v_SERVICE_DATE DATE := p_FROM_DATE;
v_END_DATE     DATE := p_FROM_DATE + p_SYNC_DAYS - 1;
v_MARK_TIME    PLS_INTEGER := DBMS_UTILITY.GET_TIME;
BEGIN
-- Populate The ESP Service Accounts Of Record For Each Aggregate Account Over The Specified Time Period --
-- Iterate Over The Service Sync Period --
   WHILE v_SERVICE_DATE <= v_END_DATE LOOP
      LOGS.LOG_INFO_DETAIL('Processing Service Date: ' || TO_CHAR(v_SERVICE_DATE, c_DATE_FORMAT), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
      DELETE AGGREGATE_ACCOUNT_SERVICE WHERE CASE_ID = GA.BASE_CASE_ID AND SERVICE_DATE = v_SERVICE_DATE;
      INSERT INTO AGGREGATE_ACCOUNT_SERVICE(CASE_ID, AGGREGATE_ID, SERVICE_DATE, AS_OF_DATE, SERVICE_ACCOUNTS, ENROLLED_ACCOUNTS)
      SELECT GA.BASE_CASE_ID, AGGREGATE_ID, v_SERVICE_DATE, CONSTANTS.LOW_DATE, SUM(SERVICE_ACCOUNTS) "SERVICE_ACCOUNTS", SUM(SERVICE_ACCOUNTS) "ENROLLED_ACCOUNTS"
      FROM CDI_AGGREGATE_ACCOUNT$
      WHERE v_SERVICE_DATE BETWEEN BEGIN_DATE AND END_DATE
         AND AGGREGATE_ID IS NOT NULL
      GROUP BY AGGREGATE_ID;
      LOGS.LOG_INFO_DETAIL('Aggregate Account Service Enrollment Count: ' || TO_CHAR(SQL%ROWCOUNT), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
-- Cache The Customer Usage Factors For The Service Date --
      CACHE_DAILY_USAGE_FACTOR(v_SERVICE_DATE);
      MERGE INTO AGGREGATE_ACCOUNT_SERVICE T
      USING
         (WITH SELECT_USAGE_FACTOR AS
            (SELECT A.RTO_ACCOUNT_ID, A.SUPPLIER, A.RTO_POOL_ID, AVG(NVL(B.USAGE_FACTOR,1)) "USAGE_FACTOR"
            FROM CDI_MAIN A
               LEFT JOIN CDI_DAILY_USAGE_FACTOR B ON B.BILL_ACCOUNT = A.BILL_ACCOUNT AND B.SERVICE_POINT = A.SERVICE_POINT
            WHERE A.IDR_STATUS <> 'Y'
               AND v_SERVICE_DATE BETWEEN A.EFFECT_DATE AND A.TERM_DATE
            GROUP BY A.RTO_ACCOUNT_ID, A.SUPPLIER, A.RTO_POOL_ID)
         SELECT GA.BASE_CASE_ID "CASE_ID", G.AGGREGATE_ID, v_SERVICE_DATE "SERVICE_DATE", CONSTANTS.LOW_DATE "AS_OF_DATE", X.USAGE_FACTOR
         FROM SELECT_USAGE_FACTOR X
            LEFT JOIN ACCOUNT                 A ON A.ACCOUNT_EXTERNAL_IDENTIFIER = X.RTO_ACCOUNT_ID
            LEFT JOIN ENERGY_SERVICE_PROVIDER E ON E.ESP_EXTERNAL_IDENTIFIER = X.SUPPLIER
            LEFT JOIN POOL                    P ON P.POOL_EXTERNAL_IDENTIFIER = X.RTO_POOL_ID
            LEFT JOIN AGGREGATE_ACCOUNT_ESP   G ON G.ACCOUNT_ID = A.ACCOUNT_ID AND G.ESP_ID = E.ESP_ID AND G.POOL_ID = P.POOL_ID) S
      ON (T.CASE_ID = S.CASE_ID AND T.AGGREGATE_ID = S.AGGREGATE_ID AND T.SERVICE_DATE = S.SERVICE_DATE AND T.AS_OF_DATE = S.AS_OF_DATE)
      WHEN MATCHED THEN
         UPDATE SET T.USAGE_FACTOR = S.USAGE_FACTOR;
      LOGS.LOG_INFO_DETAIL('Aggregate Account Service Usage Factor Update Count: ' || TO_CHAR(SQL%ROWCOUNT), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
-- Advance The Service Date --
      v_SERVICE_DATE := v_SERVICE_DATE + 1;
      COMMIT;
   END LOOP;
   COMMIT;
   GATHER_TABLE_STATS('AGGREGATE_ACCOUNT_SERVICE');
   LOGS.LOG_INFO('Elapsed Seconds: ' || TO_CHAR(ROUND((DBMS_UTILITY.GET_TIME-v_MARK_TIME)/100)), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
END SYNC_AGGREGATE_ACCOUNT_SERVICE;

PROCEDURE SYNC_PLC_NSPL(p_FROM_DATE IN DATE, p_SYNC_DAYS IN NUMBER) AS
v_PROCEDURE_NAME VARCHAR2(30) := 'SYNC_PLC_NSPL';
v_INSTALLED_CAPACITY_ID PLS_INTEGER;
v_NETWORK_SERVICE_ID    PLS_INTEGER;
v_UPDATE_COUNT          PLS_INTEGER;
v_INSERT_COUNT          PLS_INTEGER;
v_MARK_TIME             PLS_INTEGER := DBMS_UTILITY.GET_TIME;
v_BEGIN_DATE       DATE := p_FROM_DATE;
v_END_DATE         DATE := p_FROM_DATE + p_SYNC_DAYS - 1;
v_SERVICE_DATE     DATE;
v_SERVICE_END_DATE DATE;
CURSOR c_INTERVAL_ACCOUNTS IS
   SELECT C.ACCOUNT_ID, CASE WHEN SUBSTR(B.TAG_ID,5,1) = 'C' THEN v_INSTALLED_CAPACITY_ID ELSE v_NETWORK_SERVICE_ID END "ANCILLARY_SERVICE_ID", GREATEST(A.EFFECT_DATE, B.BEGIN_DATE, v_BEGIN_DATE) "BEGIN_DATE", LEAST(A.TERM_DATE, B.END_DATE, v_END_DATE) "END_DATE", TO_NUMBER(B.TAG_VAL) "SERVICE_VAL"
   FROM CDI_MAIN           A 
      JOIN CDI_PLC_ICAP_TX B ON B.BILL_ACCOUNT = A.BILL_ACCOUNT AND B.SERVICE_POINT = A.SERVICE_POINT AND B.PREMISE_NUMBER = A.PREMISE_NUMBER AND B.BEGIN_DATE <= v_END_DATE AND B.END_DATE >= v_BEGIN_DATE 
      JOIN ACCOUNT         C ON C.ACCOUNT_NAME = A.RTO_ACCOUNT_ID    
   WHERE A.EFFECT_DATE  <= v_END_DATE
      AND A.TERM_DATE   >= v_BEGIN_DATE
      AND A.EFFECT_DATE <= B.END_DATE
      AND A.TERM_DATE   >= B.BEGIN_DATE
      AND A.IDR_STATUS = 'Y'
   ORDER BY ACCOUNT_ID, BEGIN_DATE;   
CURSOR c_NON_INTERVAL_ACCOUNTS IS
   WITH ANCILLARY_SERVICE_CONTENT AS
      (SELECT RTO_ACCOUNT_ID "ACCOUNT_IDENTIFIER", SUPPLIER "ESP_IDENTIFIER", RTO_POOL_ID "POOL_IDENTIFIER", CASE WHEN SUBSTR(B.TAG_ID,5,1) = 'C' THEN v_INSTALLED_CAPACITY_ID ELSE v_NETWORK_SERVICE_ID END "ANCILLARY_SERVICE_ID", GREATEST(A.EFFECT_DATE, B.BEGIN_DATE, v_BEGIN_DATE) "BEGIN_DATE", LEAST(A.TERM_DATE, B.END_DATE, v_END_DATE) "END_DATE", SUM(TAG_VAL) "SERVICE_VAL"
      FROM CDI_MAIN A
         JOIN CDI_PLC_ICAP_TX B ON B.BILL_ACCOUNT = A.BILL_ACCOUNT AND B.SERVICE_POINT = A.SERVICE_POINT AND B.PREMISE_NUMBER = A.PREMISE_NUMBER AND B.BEGIN_DATE <= A.TERM_DATE AND B.END_DATE >= A.EFFECT_DATE
      WHERE A.EFFECT_DATE  <=  v_END_DATE 
         AND A.TERM_DATE   >= v_BEGIN_DATE
         AND A.EFFECT_DATE <=  B.END_DATE
         AND A.TERM_DATE   >=  B.BEGIN_DATE
         AND A.IDR_STATUS <> 'Y'
      GROUP BY A.RTO_ACCOUNT_ID, A.SUPPLIER, A.RTO_POOL_ID, CASE WHEN SUBSTR(B.TAG_ID,5,1) = 'C' THEN v_INSTALLED_CAPACITY_ID ELSE v_NETWORK_SERVICE_ID END, GREATEST(A.EFFECT_DATE, B.BEGIN_DATE, v_BEGIN_DATE), LEAST(A.TERM_DATE, B.END_DATE, v_END_DATE))
   SELECT A.ACCOUNT_NAME, AAE.AGGREGATE_ID, X.ANCILLARY_SERVICE_ID, X.BEGIN_DATE, X.END_DATE, X.SERVICE_VAL
   FROM ANCILLARY_SERVICE_CONTENT X
      JOIN ACCOUNT                 A ON A.ACCOUNT_EXTERNAL_IDENTIFIER = X.ACCOUNT_IDENTIFIER
      JOIN ENERGY_SERVICE_PROVIDER E ON E.ESP_EXTERNAL_IDENTIFIER = X.ESP_IDENTIFIER
      JOIN POOL                    P ON P.POOL_EXTERNAL_IDENTIFIER = X.POOL_IDENTIFIER
      JOIN AGGREGATE_ACCOUNT_ESP AAE ON AAE.ACCOUNT_ID = A.ACCOUNT_ID AND AAE.ESP_ID = E.ESP_ID AND AAE.POOL_ID = P.POOL_ID;
BEGIN
   LOGS.LOG_INFO(c_ENTRY, v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
   
   SELECT MAX(ANCILLARY_SERVICE_ID) INTO v_INSTALLED_CAPACITY_ID FROM ANCILLARY_SERVICE WHERE ANCILLARY_SERVICE_NAME =  c_INSTALLED_CAPACITY;
   SELECT MAX(ANCILLARY_SERVICE_ID) INTO v_NETWORK_SERVICE_ID    FROM ANCILLARY_SERVICE WHERE ANCILLARY_SERVICE_NAME =  c_NETWORK_SERVICE;

   DELETE ACCOUNT_ANCILLARY_SERVICE  WHERE BEGIN_DATE >= v_BEGIN_DATE AND ANCILLARY_SERVICE_ID IN (v_INSTALLED_CAPACITY_ID, v_NETWORK_SERVICE_ID);
   LOGS.LOG_INFO('Account Ancillary Service Delete Count: ' || TO_CHAR(SQL%ROWCOUNT), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
   UPDATE ACCOUNT_ANCILLARY_SERVICE SET END_DATE = v_BEGIN_DATE - 1 WHERE END_DATE IS NULL OR END_DATE >= v_BEGIN_DATE  AND ANCILLARY_SERVICE_ID IN (v_INSTALLED_CAPACITY_ID, v_NETWORK_SERVICE_ID);
   DELETE AGGREGATE_ANCILLARY_SERVICE WHERE SERVICE_DATE >= v_BEGIN_DATE AND ANCILLARY_SERVICE_ID IN (v_INSTALLED_CAPACITY_ID, v_NETWORK_SERVICE_ID);
   LOGS.LOG_INFO('Aggregate Ancillary Service Delete Count: ' || TO_CHAR(SQL%ROWCOUNT), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);

-- Process Account Ancillary Service Assignments --
   v_UPDATE_COUNT := 0;
   v_INSERT_COUNT := 0;
   UPDATE ACCOUNT_ANCILLARY_SERVICE SET SERVICE_VAL = 0 WHERE BEGIN_DATE >= p_FROM_DATE;
   LOGS.LOG_INFO('Account Ancillary Service Pre-Process Update Count: ' || TO_CHAR(SQL%ROWCOUNT), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
   FOR v_SELECT IN c_INTERVAL_ACCOUNTS LOOP
      UPDATE ACCOUNT_ANCILLARY_SERVICE SET
         SERVICE_VAL = v_SELECT.SERVICE_VAL,
         BEGIN_DATE  = LEAST(BEGIN_DATE, v_SELECT.BEGIN_DATE),
         END_DATE    = GREATEST(END_DATE, v_SELECT.END_DATE),
         ENTRY_DATE  = CURRENT_DATE                         
      WHERE ACCOUNT_ID = v_SELECT.ACCOUNT_ID
         AND ANCILLARY_SERVICE_ID = v_SELECT.ANCILLARY_SERVICE_ID 
         AND BEGIN_DATE= v_SELECT.BEGIN_DATE;
      v_UPDATE_COUNT := v_UPDATE_COUNT + SQL%ROWCOUNT; 
      IF SQL%ROWCOUNT = 0 THEN            
         INSERT INTO ACCOUNT_ANCILLARY_SERVICE(ACCOUNT_ID, ANCILLARY_SERVICE_ID, BEGIN_DATE, END_DATE, SERVICE_VAL, ENTRY_DATE) 
         VALUES(v_SELECT.ACCOUNT_ID, v_SELECT.ANCILLARY_SERVICE_ID, v_SELECT.BEGIN_DATE, v_SELECT.END_DATE, v_SELECT.SERVICE_VAL, SYSDATE);
         v_INSERT_COUNT := v_INSERT_COUNT + 1; 
      END IF;
   END LOOP;
   LOGS.LOG_INFO('Account Ancillary Service Update Count: ' || TO_CHAR(v_UPDATE_COUNT) || ', Insert Count: ' || TO_CHAR(v_INSERT_COUNT), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
-- Process Aggregate Account Ancillary Service Assignments --
   v_UPDATE_COUNT := 0;
   v_INSERT_COUNT := 0;
   FOR v_SELECT IN c_NON_INTERVAL_ACCOUNTS LOOP
      v_SERVICE_END_DATE := NVL(v_SELECT.END_DATE, v_END_DATE);
      v_SERVICE_DATE := v_SELECT.BEGIN_DATE;
      LOGS.INIT_PROCESS_PROGRESS('Processing Ancillary Service For ' || v_SELECT.ACCOUNT_NAME || '...', (v_SERVICE_END_DATE - v_SERVICE_DATE) + 1, 'Days');
      WHILE v_SERVICE_DATE <= v_SERVICE_END_DATE LOOP
         UPDATE AGGREGATE_ANCILLARY_SERVICE SET SERVICE_VAL = SERVICE_VAL + v_SELECT.SERVICE_VAL                           
         WHERE AGGREGATE_ID = v_SELECT.AGGREGATE_ID
            AND ANCILLARY_SERVICE_ID = v_SELECT.ANCILLARY_SERVICE_ID
            AND SERVICE_DATE = v_SERVICE_DATE
            AND AS_OF_DATE = CONSTANTS.LOW_DATE;             
         v_UPDATE_COUNT := v_UPDATE_COUNT + SQL%ROWCOUNT; 
         IF SQL%ROWCOUNT =  0 THEN            
            INSERT INTO AGGREGATE_ANCILLARY_SERVICE(AGGREGATE_ID, ANCILLARY_SERVICE_ID, SERVICE_DATE, AS_OF_DATE, SERVICE_VAL)
            VALUES(v_SELECT.AGGREGATE_ID, v_SELECT.ANCILLARY_SERVICE_ID, v_SERVICE_DATE, CONSTANTS.LOW_DATE, v_SELECT.SERVICE_VAL);  
            v_INSERT_COUNT := v_INSERT_COUNT + 1; 
         END IF;
         v_SERVICE_DATE := v_SERVICE_DATE + 1;
         LOGS.INCREMENT_PROCESS_PROGRESS;
      END LOOP;
   END LOOP;
   LOGS.UPDATE_PROCESS_PROGRESS(NULL); 
   GATHER_TABLE_STATS('ACCOUNT_ANCILLARY_SERVICE');
   GATHER_TABLE_STATS('AGGREGATE_ANCILLARY_SERVICE');
   LOGS.LOG_INFO('Aggregate Ancillary Service Update Count: ' || TO_CHAR(v_UPDATE_COUNT) || ', Insert Count: ' || TO_CHAR(v_INSERT_COUNT), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
   LOGS.LOG_INFO('Elapsed Seconds: ' || TO_CHAR(ROUND((DBMS_UTILITY.GET_TIME-v_MARK_TIME)/100)), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
END SYNC_PLC_NSPL;  

PROCEDURE RUN_INTERFACE
   (
   p_FROM_DATE IN DATE DEFAULT SYSDATE,
   p_SYNC_DAYS IN PLS_INTEGER DEFAULT NULL,
   p_STATUS   OUT NUMBER,
   p_MESSAGE  OUT VARCHAR2
   ) AS
v_PROCEDURE_NAME VARCHAR2(30) := 'RUN_INTERFACE';
v_FROM_DATE      DATE;
v_SYNC_DAYS      PLS_INTEGER;
v_COUNT          PLS_INTEGER;
v_MARK_TIME PLS_INTEGER := DBMS_UTILITY.GET_TIME;
BEGIN
   LOGS.START_PROCESS(c_ACCOUNT_SYNC_PROCESS);
   v_FROM_DATE  := TRUNC(p_FROM_DATE);
   v_SYNC_DAYS := NVL(p_SYNC_DAYS, TO_NUMBER(NVL(GET_DICTIONARY_VALUE('Sync Forward Days', GA.GLOBAL_MODEL, c_SYSTEM_SETTING_MODULE, c_SYSTEM_SETTING_KEY1, c_SYSTEM_SETTING_KEY2), '10')));
   LOGS.LOG_INFO('From Date: ' || TO_CHAR(v_FROM_DATE, c_DATE_FORMAT) || ', Sync Forward Days: ' || TO_CHAR(v_SYNC_DAYS), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
   STAGE_CONTENT(v_FROM_DATE, v_SYNC_DAYS);
   SYNC_POOL(v_FROM_DATE, v_SYNC_DAYS);
   SYNC_ACCOUNT(v_FROM_DATE, v_SYNC_DAYS);
   SYNC_ACCOUNT_EDC(v_FROM_DATE, v_SYNC_DAYS);
   SYNC_ACCOUNT_ESP(v_FROM_DATE, v_SYNC_DAYS);
   SYNC_ACCOUNT_SERVICE_LOCATION(v_FROM_DATE, v_SYNC_DAYS);
   SYNC_AGGREGATE_ACCOUNT(v_FROM_DATE, v_SYNC_DAYS);
   SYNC_AGGREGATE_ACCOUNT_SERVICE(v_FROM_DATE, v_SYNC_DAYS);
   SYNC_PLC_NSPL(v_FROM_DATE, v_SYNC_DAYS);
   COMMIT;
   LOGS.LOG_INFO(c_ACCOUNT_SYNC_PROCESS || ' Complete. Elapsed Seconds: ' || TO_CHAR(ROUND((DBMS_UTILITY.GET_TIME-v_MARK_TIME)/100)), v_PROCEDURE_NAME, p_SOURCE_NAME => c_PACKAGE_NAME);
   LOGS.STOP_PROCESS(p_MESSAGE, p_STATUS);
EXCEPTION
   WHEN OTHERS THEN
      ERRS.ABORT_PROCESS;
      p_MESSAGE := SQLERRM;
      p_STATUS := SQLCODE;
END RUN_INTERFACE;

PROCEDURE DEX_INTERFACE
   (
   p_BEGIN_DATE IN DATE,
   p_END_DATE   IN DATE,
   p_STATUS   OUT NUMBER,
   p_MESSAGE  OUT VARCHAR2
   ) AS
BEGIN
   RUN_INTERFACE(p_BEGIN_DATE, CASE WHEN p_END_DATE < p_BEGIN_DATE THEN p_BEGIN_DATE ELSE p_END_DATE END - p_BEGIN_DATE + 1, p_STATUS, p_MESSAGE);
END DEX_INTERFACE;

END CDI_ACCOUNT_SYNC;
/