CREATE OR REPLACE PACKAGE BODY CDI_PJM_INSCHEDULE AS

-- Package Types --
SUBTYPE INTERNAL_ID IS NUMBER(9);
TYPE r_ESCHEDULE IS RECORD (CONTRACT_NUMBER NUMBER(16), SCHEDULE_DATE DATE, LOCAL_DAY DATE, ALT_LOCAL_HOUR NUMBER(2), AMOUNT NUMBER(14,4), PRIOR_CONTRACT_NUMBER NUMBER(16), PRIOR_LOCAL_DAY DATE);
TYPE t_ESCHEDULE_CURSOR IS REF CURSOR RETURN r_ESCHEDULE;
TYPE t_LOSS_FACTOR_CACHE IS TABLE OF NUMBER(8,6) INDEX BY VARCHAR2(32);
TYPE t_SETTLEMENT_CONTENT IS TABLE OF VARCHAR2(10000) INDEX BY VARCHAR2(32);

-- Package Constants --
c_PACKAGE                      CONSTANT VARCHAR2(32) := 'CDI_PJM_ESCHEDULE';
c_SYSTEM_SETTING_MODULE        CONSTANT VARCHAR2(32) := 'MarketExchange';
c_SYSTEM_SETTING_KEY1          CONSTANT VARCHAR2(32) := 'PJM';
c_SYSTEM_SETTING_KEY2          CONSTANT VARCHAR2(32) := 'InSchedule';
c_SETTING_ACCOUNT_NAME         CONSTANT VARCHAR2(32) := 'Account Name';
c_SETTING_CONTRACT_ROLLUP      CONSTANT VARCHAR2(32) := 'Roll-Up By Contract';
c_SETTING_LOSS_FACTOR_NAME     CONSTANT VARCHAR2(32) := 'Transmission Loss Factor';
c_SETTING_RECON_DELTA_MODE     CONSTANT VARCHAR2(32) := 'Reconciliation Delta Mode';
c_SETTING_ENABLE_FLOOR_TO_ZERO CONSTANT VARCHAR2(32) := 'Enable Floor To Zero';
c_QUERY_SCHEDULES              CONSTANT VARCHAR2(32) := 'Query Schedules';
c_SETTING_LOG_ONLY             CONSTANT VARCHAR2(32) := 'Log Only';
c_PROCESS_NAME_SUBMIT_SCHEDULE CONSTANT VARCHAR2(64) := 'CDI: Submit inSchedules To PJM';
c_PROCESS_NAME_EXPORT_SCHEDULE CONSTANT VARCHAR2(64) := 'CDI: Export inSchedules To File';
c_PROCESS_NAME_QUERY_SCHEDULE  CONSTANT VARCHAR2(64) := 'CDI: Query inSchedules From PJM';
c_PROCESS_NAME_FINAL_TO_FILE   CONSTANT VARCHAR2(64) := 'CDI: Save Final Settlement To File';
c_PJM_ESCHEDULE_APPLICATION    CONSTANT VARCHAR2(8)  := 'esched';
c_SCHEDULE_NORMAL_DAY          CONSTANT VARCHAR2(8)  := 'Normal';
c_SCHEDULE_LONG_DAY            CONSTANT VARCHAR2(8)  := 'Long';
c_SCHEDULE_SHORT_DAY           CONSTANT VARCHAR2(8)  := 'Short';
c_ENERGY_COMMODITY_TYPE        CONSTANT VARCHAR2(8)  := 'Energy';
c_LOAD_TRANSACTION_TYPE        CONSTANT VARCHAR2(8)  := 'Load';
c_REQUEST_CONTENTTYPE          CONSTANT VARCHAR2(64) := 'text/xml';
c_SUBMIT_EXCHANGE_TYPE         CONSTANT VARCHAR2(8)  := 'Submit';
c_QUERY_EXCHANGE_TYPE          CONSTANT VARCHAR2(8)  := 'Query';
c_DATE_FORMAT                  CONSTANT VARCHAR2(16) := 'MM/DD/YYYY';
c_SHORT_DATE_FORMAT            CONSTANT VARCHAR2(16) := 'DD-MON-YY';
c_NUMBER_FORMAT                CONSTANT VARCHAR2(16) := '0999.999';
c_DATE_TIME_KEY                CONSTANT VARCHAR2(32) := 'MM/DD/YYYY HH24:MI';
c_DATE_TIME_FORMAT             CONSTANT VARCHAR2(32) := 'MM/DD/YYYY HH24:MI:SS';
c_SCHEDULE_PENDING             CONSTANT CHAR(1)      := 'P';
c_SCHEDULE_CONFIRMED           CONSTANT CHAR(1)      := 'C';
c_DST_SPRING_AHEAD_OPTION      CONSTANT CHAR(1)      := 'B';
c_FILE_FORMAT_OPTION           CONSTANT CHAR(1)      := 'A';
c_CRLF                         CONSTANT CHAR(2)      := CHR(13) || CHR(10);
c_COMMA                        CONSTANT CHAR(1)      := ',';
c_LOG_TYPE                     CONSTANT NUMBER(1)    := 2;
c_SCHEDULES_CONF_BEGIN         CONSTANT NUMBER(2)    := 14;
c_SCHEDULES_CONF_END           CONSTANT NUMBER(2)    := 38;
c_SCHEDULES_PEND_BEGIN         CONSTANT NUMBER(2)    := 39;
c_SCHEDULES_PEND_END           CONSTANT NUMBER(2)    := 63;

-- Package Globals --
l_LOG_ONLY                     NUMBER(1) := 0;
l_TRACE_ON                     NUMBER(1) := 0;
l_ENABLE_RECON_DELTA_MODE      NUMBER(1) := 1;
l_ROLL_UP_BY_CONTRACT          NUMBER(1) := 1;
l_ENABLE_FLOOR_TO_ZERO         NUMBER(1) := 0;
l_LOSS_FACTOR_CACHE            t_LOSS_FACTOR_CACHE;

FUNCTION FORMAT_EXCEPTION_MESSAGE(p_MESSAGE IN VARCHAR2) RETURN VARCHAR2 AS
v_MESSAGE VARCHAR2(4000) := SUBSTR(p_MESSAGE, 1, INSTR(p_MESSAGE, CHR(10)) - 1);
BEGIN
   RETURN CASE WHEN LENGTH(v_MESSAGE) = 0 THEN p_MESSAGE ELSE SUBSTR(v_MESSAGE, 12) || ' [' || SUBSTR(v_MESSAGE,1,9) || ']' END;
END FORMAT_EXCEPTION_MESSAGE;

PROCEDURE INITIALIZE_INTERFACE AS
BEGIN 
   l_ENABLE_RECON_DELTA_MODE := CASE WHEN NVL(UPPER(SUBSTR(GET_DICTIONARY_VALUE(c_SETTING_RECON_DELTA_MODE, GA.GLOBAL_MODEL, c_SYSTEM_SETTING_MODULE, c_SYSTEM_SETTING_KEY1, c_SYSTEM_SETTING_KEY2),1,1)),1) IN ('1','Y','T') THEN 1 ELSE 0 END;
   l_ROLL_UP_BY_CONTRACT := CASE WHEN NVL(UPPER(SUBSTR(GET_DICTIONARY_VALUE(c_SETTING_CONTRACT_ROLLUP, GA.GLOBAL_MODEL, c_SYSTEM_SETTING_MODULE, c_SYSTEM_SETTING_KEY1, c_SYSTEM_SETTING_KEY2),1,1)),1) IN ('1','Y','T') THEN 1 ELSE 0 END;
   l_ENABLE_FLOOR_TO_ZERO := CASE WHEN NVL(UPPER(SUBSTR(GET_DICTIONARY_VALUE(c_SETTING_ENABLE_FLOOR_TO_ZERO, GA.GLOBAL_MODEL, c_SYSTEM_SETTING_MODULE, c_SYSTEM_SETTING_KEY1, c_SYSTEM_SETTING_KEY2),1,1)),1) IN ('1','Y','T') THEN 1 ELSE 0 END;
   LOGS.LOG_INFO('Setting ' || c_SETTING_RECON_DELTA_MODE || ': ' || TO_CHAR(l_ENABLE_RECON_DELTA_MODE));
   LOGS.LOG_INFO('Setting ' || c_SETTING_CONTRACT_ROLLUP || ': ' || TO_CHAR(l_ROLL_UP_BY_CONTRACT));
   LOGS.LOG_INFO('Setting ' || c_SETTING_ENABLE_FLOOR_TO_ZERO || ': ' || TO_CHAR(l_ENABLE_FLOOR_TO_ZERO));
END INITIALIZE_INTERFACE;

PROCEDURE CACHE_LOSS_FACTOR(p_LOSS_FACTOR_NAME IN VARCHAR2, p_BEGIN_DATE IN DATE, p_END_DATE IN DATE, p_LOSS_TYPE IN VARCHAR2 DEFAULT CALC_UTIL.c_LOSS_TYPE_TRANSMISSION) AS
v_PROCEDURE VARCHAR2(32) := 'CACHE_LOSS_FACTOR';
v_LOSS_FACTOR_ID INTERNAL_ID;
v_SERVICE_DATE DATE := p_BEGIN_DATE;
v_KEY VARCHAR2(32);
BEGIN
   l_LOSS_FACTOR_CACHE.DELETE;
   SELECT NVL(MAX(LOSS_FACTOR_ID), CONSTANTS.NOT_ASSIGNED) INTO v_LOSS_FACTOR_ID FROM LOSS_FACTOR WHERE LOSS_FACTOR_NAME = p_LOSS_FACTOR_NAME;
   IF v_LOSS_FACTOR_ID = CONSTANTS.NOT_ASSIGNED THEN
      LOGS.LOG_WARN('No Loss Factor Defined For: ' || p_LOSS_FACTOR_NAME);
   END IF;
   WHILE v_SERVICE_DATE <= p_END_DATE LOOP
      v_KEY := TO_CHAR(v_SERVICE_DATE, c_DATE_FORMAT);
      l_LOSS_FACTOR_CACHE(v_KEY) := CASE WHEN v_LOSS_FACTOR_ID = CONSTANTS.NOT_ASSIGNED THEN 0 ELSE CALC_UTIL.GET_LOSS_FACTOR(v_LOSS_FACTOR_ID, v_SERVICE_DATE, p_LOSS_TYPE => p_LOSS_TYPE, p_FACTOR_TYPE => CALC_UTIL.c_FACTOR_TYPE_LOSS) END;
      LOGS.LOG_DEBUG('Loss Factor On ' || v_KEY || ': ' || TO_CHAR(l_LOSS_FACTOR_CACHE(v_KEY)));
      v_SERVICE_DATE := v_SERVICE_DATE + 1;
   END LOOP;
END CACHE_LOSS_FACTOR;

FUNCTION GET_LOSS_FACTOR(p_SERVICE_DATE IN DATE) RETURN NUMBER AS
v_KEY VARCHAR2(32) := TO_CHAR(CASE WHEN TO_NUMBER(TO_CHAR(p_SERVICE_DATE,'HH24')) = 0 THEN p_SERVICE_DATE - 1 ELSE p_SERVICE_DATE END, c_DATE_FORMAT);
BEGIN
   RETURN 1 + CASE WHEN l_LOSS_FACTOR_CACHE.EXISTS(v_KEY) THEN l_LOSS_FACTOR_CACHE(v_KEY) ELSE 0 END;
END GET_LOSS_FACTOR;

PROCEDURE GET_SCHEDULE
   (
   p_SCHEDULE_TYPE IN NUMBER,
   p_BEGIN_DATE    IN DATE,
   p_END_DATE      IN DATE,
   p_CURSOR       OUT t_ESCHEDULE_CURSOR
   ) AS
v_PROCEDURE VARCHAR2(32) := 'GET_SCHEDULE';
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_TRANSACTIONS CONTRACT_SCHEDULE_TABLE := CONTRACT_SCHEDULE_TABLE();
v_SCHEDULE CONTRACT_SCHEDULE_TABLE := CONTRACT_SCHEDULE_TABLE();
v_FLOOR_TO_ZERO NUMBER(1) := CASE WHEN p_SCHEDULE_TYPE = CONSTANTS.SCHEDULE_TYPE_PRELIM AND l_ENABLE_FLOOR_TO_ZERO = 1 THEN 1 ELSE 0 END;
CURSOR c_SELECT IS
   SELECT A.TRANSACTION_NAME, A.TRANSACTION_ID, A.CONTRACT_ID, A.LOCAL_DAY, CASE WHEN B.BEGIN_DATE IS NULL THEN 0 ELSE 1 END "CONTRACT_IN_EFFECT", BEGIN_SCHEDULE_DATE, END_SCHEDULE_DATE, EXPECTED_COUNT,
      (SELECT COUNT(*) FROM IT_SCHEDULE WHERE TRANSACTION_ID = A.TRANSACTION_ID AND SCHEDULE_TYPE = p_SCHEDULE_TYPE AND SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE AND SCHEDULE_DATE BETWEEN A.BEGIN_SCHEDULE_DATE AND A.END_SCHEDULE_DATE) "OBSERVED_COUNT"
   FROM
      (SELECT A.TRANSACTION_NAME, A.TRANSACTION_ID, A.CONTRACT_ID, C.LOCAL_DAY, MIN(C.CUT_DATE) "BEGIN_SCHEDULE_DATE", MAX(C.CUT_DATE) "END_SCHEDULE_DATE", COUNT(*) "EXPECTED_COUNT"
      FROM INTERCHANGE_TRANSACTION A
         JOIN IT_COMMODITY B ON B.COMMODITY_ID = A.COMMODITY_ID AND B.COMMODITY_TYPE = c_ENERGY_COMMODITY_TYPE
         CROSS JOIN (SELECT * FROM CDI_EASTERN_PREVAILING_TIME$ WHERE CUT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE) C 
      WHERE A.TRANSACTION_TYPE = c_LOAD_TRANSACTION_TYPE
         AND A.CONTRACT_ID > 0
         AND EXISTS (SELECT NULL FROM IT_SCHEDULE WHERE TRANSACTION_ID = A.TRANSACTION_ID AND SCHEDULE_TYPE = p_SCHEDULE_TYPE AND SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE AND SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE)
      GROUP BY A.TRANSACTION_NAME, A.TRANSACTION_ID, A.CONTRACT_ID, C.LOCAL_DAY) A
         LEFT JOIN TP_CONTRACT_NUMBER B ON B.CONTRACT_ID = A.CONTRACT_ID
   WHERE A.LOCAL_DAY BETWEEN NVL(B.BEGIN_DATE, A.LOCAL_DAY) AND NVL(B.END_DATE, A.LOCAL_DAY);
   PROCEDURE ADD_TO_CANDIDATES(p_TRANSACTION_ID IN NUMBER, p_CONTRACT_ID IN NUMBER) AS
   BEGIN
      FOR v_INDEX IN 1..v_TRANSACTIONS.COUNT LOOP
         IF v_TRANSACTIONS(v_INDEX).TRANSACTION_ID = p_TRANSACTION_ID AND v_TRANSACTIONS(v_INDEX).CONTRACT_ID = p_CONTRACT_ID THEN
            RETURN;
         END IF;
      END LOOP;
      v_TRANSACTIONS.EXTEND;
      v_TRANSACTIONS(v_TRANSACTIONS.LAST) := CONTRACT_SCHEDULE_TYPE(p_CONTRACT_ID, p_TRANSACTION_ID, NULL, NULL);
   END ADD_TO_CANDIDATES;
BEGIN
   LOGS.LOG_INFO('Schedule Type: ' || TO_CHAR(p_SCHEDULE_TYPE));
   LOGS.LOG_INFO('Floor To Zero Is Enabled: ' || CASE WHEN v_FLOOR_TO_ZERO = 1 THEN 'Y' ELSE 'N' END);
-- Validate The Schedules For Missing Schedule Content And Capture The Set Of Transactions That Pass --
   UT.CUT_DAY_INTERVAL_RANGE(p_BEGIN_DATE, p_END_DATE, GA.LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
   FOR v_SELECT IN c_SELECT LOOP
      IF v_SELECT.OBSERVED_COUNT <> v_SELECT.EXPECTED_COUNT THEN
         IF v_SELECT.OBSERVED_COUNT = 0 AND V_SELECT.CONTRACT_IN_EFFECT = 0 THEN
            LOGS.LOG_INFO('No Schedule Content For "' || v_SELECT.TRANSACTION_NAME || '" On: ' || TEXT_UTIL.TO_CHAR_DATE(v_SELECT.LOCAL_DAY) || '.');
         ELSE
            LOGS.LOG_WARN('Missing Schedule Content For "' || v_SELECT.TRANSACTION_NAME || '" On: ' || TEXT_UTIL.TO_CHAR_DATE(v_SELECT.LOCAL_DAY) || ', Expected: ' || TO_CHAR(v_SELECT.EXPECTED_COUNT) || ', Observed: ' || TO_CHAR(v_SELECT.OBSERVED_COUNT));
         END IF;
      ELSE
-- Collect The Set Of Transaction And Contract Ids Into A Structure That Can Be Used In A Set Operation --
         ADD_TO_CANDIDATES(v_SELECT.TRANSACTION_ID, v_SELECT.CONTRACT_ID);
      END IF;
   END LOOP;
   LOGS.LOG_INFO('Transaction Set Count: ' || TO_CHAR(v_TRANSACTIONS.COUNT) || '.');
-- Collect The Schedule Content To Be Processed --
   SELECT CONTRACT_SCHEDULE_TYPE(A.CONTRACT_ID, CASE WHEN l_ROLL_UP_BY_CONTRACT = 1 THEN CONSTANTS.NOT_ASSIGNED ELSE A.TRANSACTION_ID END, C.SCHEDULE_DATE,
      ROUND(CASE WHEN p_SCHEDULE_TYPE = CONSTANTS.SCHEDULE_TYPE_FINAL THEN CASE WHEN l_ENABLE_RECON_DELTA_MODE = 1 THEN (NVL(D.AMOUNT,0)-NVL(C.AMOUNT,0)) * 1000 ELSE NVL(D.AMOUNT,0) END ELSE NVL(C.AMOUNT,0) END, 3))
   BULK COLLECT INTO v_SCHEDULE
   FROM TABLE(CAST(v_TRANSACTIONS AS CONTRACT_SCHEDULE_TABLE)) A
      JOIN INTERCHANGE_TRANSACTION B ON B.TRANSACTION_ID = A.TRANSACTION_ID AND B.CONTRACT_ID = A.CONTRACT_ID
      JOIN IT_SCHEDULE             C ON C.TRANSACTION_ID = B.TRANSACTION_ID AND C.SCHEDULE_TYPE = p_SCHEDULE_TYPE   AND C.SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE AND C.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
      LEFT JOIN IT_SCHEDULE        D ON D.TRANSACTION_ID = C.TRANSACTION_ID AND D.SCHEDULE_TYPE = p_SCHEDULE_TYPE-1 AND D.SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE AND D.SCHEDULE_DATE = C.SCHEDULE_DATE;
   LOGS.LOG_INFO('Schedule Content Count: ' || TO_CHAR(v_SCHEDULE.COUNT) || '.');
-- Collect And Order The Schedule Content Into A Cursor Based On The Roll-Up Option --
   IF l_ROLL_UP_BY_CONTRACT = 0 THEN
      OPEN p_CURSOR FOR
         SELECT CONTRACT_NUMBER, SCHEDULE_DATE, LOCAL_DAY, ALT_LOCAL_HOUR, CASE WHEN v_FLOOR_TO_ZERO = 1 THEN GREATEST(AMOUNT,0) ELSE AMOUNT END "AMOUNT",
            LAG(CONTRACT_NUMBER, 1, CONTRACT_NUMBER) OVER (ORDER BY CONTRACT_NUMBER) "PRIOR_CONTRACT_NUMBER",
            LAG(LOCAL_DAY, 1, LOCAL_DAY) OVER(PARTITION BY CONTRACT_NUMBER ORDER BY SCHEDULE_DATE) "PRIOR_LOCAL_DAY"
         FROM
            (SELECT B.TRANSACTION_IDENTIFIER "CONTRACT_NUMBER", A.SCHEDULE_DATE, C.LOCAL_DAY, C.ALT_LOCAL_HOUR, SUM(A.SCHEDULE_VAL) "AMOUNT"
            FROM TABLE(CAST(v_SCHEDULE AS CONTRACT_SCHEDULE_TABLE)) A, INTERCHANGE_TRANSACTION B, CDI_EASTERN_PREVAILING_TIME$ C
            WHERE B.TRANSACTION_ID = A.TRANSACTION_ID
               AND C.CUT_DATE = A.SCHEDULE_DATE
            GROUP BY B.TRANSACTION_IDENTIFIER, A.SCHEDULE_DATE, C.LOCAL_DAY, C.ALT_LOCAL_HOUR)
         ORDER BY 1,2;
   ELSE
      OPEN p_CURSOR FOR
         SELECT CONTRACT_NUMBER, SCHEDULE_DATE, LOCAL_DAY, ALT_LOCAL_HOUR, CASE WHEN v_FLOOR_TO_ZERO = 1 THEN GREATEST(AMOUNT,0) ELSE AMOUNT END "AMOUNT",
            LAG(CONTRACT_NUMBER, 1, CONTRACT_NUMBER) OVER (ORDER BY CONTRACT_NUMBER) "PRIOR_CONTRACT_NUMBER",
            LAG(LOCAL_DAY, 1, CONSTANTS.LOW_DATE) OVER(PARTITION BY CONTRACT_NUMBER ORDER BY SCHEDULE_DATE) "PRIOR_LOCAL_DAY"
         FROM
            (SELECT B.CONTRACT_NUMBER, A.SCHEDULE_DATE, C.LOCAL_DAY, C.ALT_LOCAL_HOUR, SUM(A.SCHEDULE_VAL) "AMOUNT"
            FROM TABLE(CAST(v_SCHEDULE AS CONTRACT_SCHEDULE_TABLE)) A, TP_CONTRACT_NUMBER B, CDI_EASTERN_PREVAILING_TIME$ C
            WHERE B.CONTRACT_ID = A.CONTRACT_ID
               AND B.CONTRACT_NUMBER IS NOT NULL
               AND C.CUT_DATE = A.SCHEDULE_DATE
               AND C.LOCAL_DAY BETWEEN B.BEGIN_DATE AND NVL(B.END_DATE, CONSTANTS.HIGH_DATE)
            GROUP BY B.CONTRACT_NUMBER, A.SCHEDULE_DATE, C.LOCAL_DAY, C.ALT_LOCAL_HOUR)
         ORDER BY 1,2;
   END IF;
   LOGS.LOG_INFO('Exit - GET_SCHEDULE');
END GET_SCHEDULE;

PROCEDURE FORMAT_ESCHEDULE
   (
   p_SCHEDULE_TYPE IN NUMBER,
   p_ESCHEDULE_FORMAT IN CDI_ESCHEDULE_FORMAT_LIST,
   p_CONTENT IN OUT CLOB
   ) AS
v_PROCEDURE VARCHAR2(32) := 'FORMAT_ESCHEDULE';
TYPE t_SCHEDULE IS TABLE OF VARCHAR2(4000) INDEX BY PLS_INTEGER;
CURSOR c_SELECT_A IS
   SELECT DISTINCT LOCAL_DAY
   FROM TABLE(CAST(p_ESCHEDULE_FORMAT AS CDI_ESCHEDULE_FORMAT_LIST))
   ORDER BY LOCAL_DAY;
CURSOR c_SELECT_B(p_LOCAL_DAY IN DATE) IS
   SELECT DISTINCT CONTRACT_NUMBER
   FROM TABLE(CAST(p_ESCHEDULE_FORMAT AS CDI_ESCHEDULE_FORMAT_LIST))
   WHERE LOCAL_DAY = p_LOCAL_DAY
   ORDER BY CONTRACT_NUMBER;
CURSOR c_SELECT_C(p_LOCAL_DAY IN DATE, p_CONTRACT_NUMBER IN NUMBER, p_FLOOR_TO_ZERO IN NUMBER) IS
   SELECT ALT_LOCAL_HOUR, CASE WHEN p_FLOOR_TO_ZERO = 1 THEN GREATEST(AMOUNT,0) ELSE AMOUNT END "AMOUNT"
   FROM TABLE(CAST(p_ESCHEDULE_FORMAT AS CDI_ESCHEDULE_FORMAT_LIST))
   WHERE LOCAL_DAY = p_LOCAL_DAY
      AND CONTRACT_NUMBER = p_CONTRACT_NUMBER
   ORDER BY ALT_LOCAL_HOUR;
v_SCHEDULE_TYPE VARCHAR(16) := CASE WHEN p_SCHEDULE_TYPE = CONSTANTS.SCHEDULE_TYPE_FINAL AND l_ENABLE_RECON_DELTA_MODE = 1 THEN '*ENGREC*' ELSE '*INTSCH*' END;
v_FLOOR_TO_ZERO NUMBER(1) := CASE WHEN p_SCHEDULE_TYPE = CONSTANTS.SCHEDULE_TYPE_PRELIM AND l_ENABLE_FLOOR_TO_ZERO = 1 THEN 1 ELSE 0 END;
v_CONTRACT VARCHAR2(4000) := 'CONTRACTID';
v_BUFFER VARCHAR2(4000);
v_CONTRACT_COUNT PLS_INTEGER := 0;
v_SCHEDULE_COUNT PLS_INTEGER := 0;
v_INDEX PLS_INTEGER;
v_SCHEDULE t_SCHEDULE;
   FUNCTION REPEAT(p_STRING IN VARCHAR2, p_TIMES IN PLS_INTEGER) RETURN VARCHAR2 AS
   v_STRING VARCHAR2(4000);
   BEGIN
      FOR v_INDEX IN 1..p_TIMES LOOP
         v_STRING := v_STRING || CASE WHEN LENGTH(v_STRING) = 0 THEN NULL ELSE c_COMMA END || p_STRING;
      END LOOP;
      RETURN v_STRING;
   END REPEAT;
BEGIN
   LOGS.LOG_INFO('Entry');
   LOGS.LOG_INFO('eSchedule Record Count: ' || TO_CHAR(p_ESCHEDULE_FORMAT.COUNT));
   FOR v_SELECT_A IN c_SELECT_A LOOP
      LOGS.LOG_INFO('Process Local Day: ' || TO_CHAR(v_SELECT_A.LOCAL_DAY, c_DATE_FORMAT));
      FOR v_SELECT_B IN c_SELECT_B(v_SELECT_A.LOCAL_DAY) LOOP
         LOGS.LOG_INFO('Process Contract Number: ' || TO_CHAR(v_SELECT_B.CONTRACT_NUMBER));
         v_CONTRACT := v_CONTRACT || c_COMMA || TO_CHAR(v_SELECT_B.CONTRACT_NUMBER);
         v_CONTRACT_COUNT := v_CONTRACT_COUNT + 1;
         v_SCHEDULE_COUNT := 0;
         FOR v_SELECT_C IN c_SELECT_C(v_SELECT_A.LOCAL_DAY, v_SELECT_B.CONTRACT_NUMBER, v_FLOOR_TO_ZERO) LOOP
            IF NOT v_SCHEDULE.EXISTS(v_SELECT_C.ALT_LOCAL_HOUR) THEN
               v_SCHEDULE(v_SELECT_C.ALT_LOCAL_HOUR) := TO_CHAR(v_SELECT_C.ALT_LOCAL_HOUR) || c_COMMA || TRIM(TO_CHAR(v_SELECT_C.AMOUNT, c_NUMBER_FORMAT));
            ELSE
               v_SCHEDULE(v_SELECT_C.ALT_LOCAL_HOUR) := v_SCHEDULE(v_SELECT_C.ALT_LOCAL_HOUR) || c_COMMA || TRIM(TO_CHAR(v_SELECT_C.AMOUNT, c_NUMBER_FORMAT));
               v_SCHEDULE_COUNT := v_SCHEDULE_COUNT + 1;
            END IF;
         END LOOP;
         LOGS.LOG_INFO('Schedule Count: ' || TO_CHAR(v_SCHEDULE_COUNT));
      END LOOP;
      LOGS.LOG_INFO('Schedule Hours: ' || TO_CHAR(v_SCHEDULE.COUNT));
      v_BUFFER := '*HE*' || REPEAT(v_SCHEDULE_TYPE, v_CONTRACT_COUNT) || c_CRLF;
      DBMS_LOB.WRITEAPPEND(p_CONTENT, LENGTH(v_BUFFER), v_BUFFER);
      v_BUFFER := v_CONTRACT || c_CRLF;
      DBMS_LOB.WRITEAPPEND(p_CONTENT, LENGTH(v_BUFFER), v_BUFFER);
      v_BUFFER := 'STARTDATE' || REPEAT(TO_CHAR(v_SELECT_A.LOCAL_DAY, c_DATE_FORMAT), v_CONTRACT_COUNT) || c_CRLF;
      DBMS_LOB.WRITEAPPEND(p_CONTENT, LENGTH(v_BUFFER), v_BUFFER);
      v_BUFFER := 'ENDDATE' || REPEAT(TO_CHAR(v_SELECT_A.LOCAL_DAY, c_DATE_FORMAT), v_CONTRACT_COUNT) || c_CRLF;
      DBMS_LOB.WRITEAPPEND(p_CONTENT, LENGTH(v_BUFFER), v_BUFFER);
      v_INDEX := v_SCHEDULE.FIRST;
      WHILE v_INDEX IS NOT NULL LOOP
         v_BUFFER := v_SCHEDULE(v_INDEX) || c_CRLF;
         DBMS_LOB.WRITEAPPEND(p_CONTENT, LENGTH(v_BUFFER), v_BUFFER);
         v_INDEX := v_SCHEDULE.NEXT(v_INDEX);
      END LOOP;
      v_SCHEDULE.DELETE;
      v_CONTRACT:= 'CONTRACTID';
      v_CONTRACT_COUNT := 0;
   END LOOP;
   LOGS.LOG_INFO('Exit');
END FORMAT_ESCHEDULE;

PROCEDURE GET_SCHEDULE_CONTENT
   (
   p_SCHEDULE_TYPE IN NUMBER,
   p_BEGIN_DATE IN DATE,
   p_END_DATE IN DATE,
   p_CONTENT OUT CLOB,
   p_COUNT OUT PLS_INTEGER
   ) AS
v_PROCEDURE VARCHAR2(32) := 'GET_SCHEDULE_CONTENT';
v_HEADER VARCHAR(16) := CASE WHEN p_SCHEDULE_TYPE = CONSTANTS.SCHEDULE_TYPE_FINAL AND l_ENABLE_RECON_DELTA_MODE = 1 THEN '*ENGREC*' ELSE '*INTSCH*' END;
v_FOOTER VARCHAR(16) := CASE WHEN p_SCHEDULE_TYPE = CONSTANTS.SCHEDULE_TYPE_FINAL AND l_ENABLE_RECON_DELTA_MODE = 1 THEN '-' ELSE '' END || c_CRLF;
v_BUFFER VARCHAR2(1000);
v_ESCHEDULE r_ESCHEDULE;
v_CURSOR t_ESCHEDULE_CURSOR;
v_ESCHEDULE_FORMAT CDI_ESCHEDULE_FORMAT_LIST := CDI_ESCHEDULE_FORMAT_LIST();
   FUNCTION POST_HOUR_SPEC(p_LOCAL_HOUR IN NUMBER, p_AMOUNT IN NUMBER) RETURN VARCHAR2 AS
   v_HOUR_SPEC VARCHAR2(64);
   BEGIN
      RETURN TO_CHAR(p_LOCAL_HOUR -1 ) || '-' || TO_CHAR(p_LOCAL_HOUR) || ' ' || TO_CHAR(p_AMOUNT) || c_CRLF;
   END POST_HOUR_SPEC;
BEGIN
   LOGS.LOG_INFO('Entry');
   p_COUNT := 0;
   GET_SCHEDULE(p_SCHEDULE_TYPE, p_BEGIN_DATE, p_END_DATE, v_CURSOR);
   DBMS_LOB.CREATETEMPORARY(p_CONTENT, TRUE);
   DBMS_LOB.OPEN(p_CONTENT, DBMS_LOB.LOB_READWRITE);
   LOOP
      FETCH v_CURSOR INTO v_ESCHEDULE;
      EXIT WHEN v_CURSOR%NOTFOUND;
      IF c_FILE_FORMAT_OPTION = 'A' THEN
         IF v_ESCHEDULE.CONTRACT_NUMBER <> v_ESCHEDULE.PRIOR_CONTRACT_NUMBER OR v_ESCHEDULE.LOCAL_DAY <> v_ESCHEDULE.PRIOR_LOCAL_DAY THEN
            v_BUFFER := v_HEADER || c_CRLF || v_ESCHEDULE.CONTRACT_NUMBER || c_CRLF || TO_CHAR(v_ESCHEDULE.LOCAL_DAY, c_DATE_FORMAT) || c_CRLF || TO_CHAR(v_ESCHEDULE.LOCAL_DAY, c_DATE_FORMAT) || c_CRLF || POST_HOUR_SPEC(v_ESCHEDULE.ALT_LOCAL_HOUR, v_ESCHEDULE.AMOUNT);
            DBMS_LOB.WRITEAPPEND(p_CONTENT, LENGTH(v_BUFFER), v_BUFFER);
            p_COUNT := p_COUNT + 5;
         ELSE
            v_BUFFER := POST_HOUR_SPEC(v_ESCHEDULE.ALT_LOCAL_HOUR, v_ESCHEDULE.AMOUNT);
            DBMS_LOB.WRITEAPPEND(p_CONTENT, LENGTH(v_BUFFER), v_BUFFER);
            p_COUNT := p_COUNT + 1;
         END IF;
      ELSIF c_FILE_FORMAT_OPTION = 'B' THEN
         v_ESCHEDULE_FORMAT.EXTEND;
         v_ESCHEDULE_FORMAT(v_ESCHEDULE_FORMAT.LAST) := CDI_ESCHEDULE_FORMAT_TYPE(v_ESCHEDULE.CONTRACT_NUMBER, v_ESCHEDULE.SCHEDULE_DATE, v_ESCHEDULE.LOCAL_DAY, v_ESCHEDULE.ALT_LOCAL_HOUR, v_ESCHEDULE.AMOUNT, v_ESCHEDULE.PRIOR_CONTRACT_NUMBER, v_ESCHEDULE.PRIOR_LOCAL_DAY);
      END IF;
   END LOOP;
-- Close The Cursor --
   IF v_CURSOR IS NOT NULL THEN
      CLOSE v_CURSOR;
   END IF;
-- Process Format Option B If Enabled
   IF c_FILE_FORMAT_OPTION = 'B' THEN
      FORMAT_ESCHEDULE(p_SCHEDULE_TYPE, v_ESCHEDULE_FORMAT, p_CONTENT);
   END IF;
-- Close The File Container --
   IF p_CONTENT IS NOT NULL THEN
      DBMS_LOB.CLOSE(p_CONTENT);
   END IF;
   LOGS.LOG_INFO('Exit - GET_SCHEDULE_CONTENT');
END GET_SCHEDULE_CONTENT;
------------------------------------------------------------------------------
-- REVISION HISTORY
-- DATE       AUTHOR         DESCRIPTION
------------ -------------- --------------------------------------------------
--2020-11-13 Kurk Nielsen   Added 'action=upload' Parameter
------------------------------------------------------------------------------
PROCEDURE REQUEST_SUBMIT
   (
   p_SCHEDULE_TYPE IN NUMBER,
   p_BEGIN_DATE    IN DATE,
   p_END_DATE      IN DATE,
   p_CONTENT       IN CLOB,
   p_STATUS       OUT NUMBER,
   p_MESSAGE      OUT VARCHAR2
   ) AS
v_PROCEDURE VARCHAR2(32) := 'REQUEST_SUBMIT';
v_CREDENTIALS MEX_CREDENTIALS;
v_LOGGER MM_LOGGER_ADAPTER;
v_PARAMETER_MAP MEX_UTIL.PARAMETER_MAP:= MEX_SWITCHBOARD.c_EMPTY_PARAMETER_MAP;
v_RESPONSE CLOB;
v_EXTERNAL_ACCOUNT_NAME VARCHAR2(32):= MM_PJM.c_EXTERNAL_ACCOUNT_NAME; 
v_STATUS NUMBER;
BEGIN
   LOGS.LOG_INFO('Entry');
   IF v_EXTERNAL_ACCOUNT_NAME IS NULL THEN
      ERRS.RAISE_BUSINESS_RULE_ERROR(' PJM Account Name Is Not Defined.');
   END IF;
-- Set The Parameter Map --
   v_PARAMETER_MAP(CDI_MEX_PJM.c_REPORT_TYPE) := 'Submit-eSchedule';
   v_PARAMETER_MAP(CDI_MEX_PJM.c_ACTION) := 'upload';   
-- Initialize The Market Exchange Interface --
   LOGS.LOG_INFO('Entry - INIT_MEX');
   MEX_SWITCHBOARD.INIT_MEX(
      p_EXTERNAL_SYSTEM_ID => EC.ES_PJM,
      p_EXTERNAL_ACCOUNT_NAME => v_EXTERNAL_ACCOUNT_NAME,
      p_PROCESS_NAME => c_PROCESS_NAME_SUBMIT_SCHEDULE,
      p_EXCHANGE_NAME => c_SUBMIT_EXCHANGE_TYPE,
      p_LOG_TYPE => c_LOG_TYPE,
      p_TRACE_ON => l_TRACE_ON,
      p_CREDENTIALS => v_CREDENTIALS,
      p_LOGGER => v_LOGGER);   
-- Make The Request --
   LOGS.LOG_INFO('Entry - RUN_PJM_BROWSERLESS');
   CDI_MEX_PJM.RUN_PJM_BROWSERLESS(
      p_CREDENTIALS => v_CREDENTIALS,
      p_BEGIN_DATE  => p_BEGIN_DATE,
      p_END_DATE  => p_END_DATE,
      p_PARAMETER_MAP  => v_PARAMETER_MAP,
      p_REQUEST_APPLICATION  => c_PJM_ESCHEDULE_APPLICATION,
      p_REQUEST_DIRECTORY  => 'upload',
      p_REQUEST => p_CONTENT,
      p_REQUEST_CONTENTTYPE => 'html',
      p_RESPONSE => v_RESPONSE,
      p_LOGGER  => v_LOGGER,
      p_STATUS => v_STATUS);
   LOGS.LOG_INFO('PJM Interface Submit Status:' || TO_CHAR(v_STATUS));
   p_MESSAGE := DBMS_LOB.SUBSTR(PARSE_UTIL.HTML_RESPONSE_TO_TEXT(v_RESPONSE),32767,1);
   LOGS.LOG_INFO('PJM Interface Submit Message:' || p_MESSAGE);
   IF p_MESSAGE LIKE '%Successfully Uploaded%' THEN
      p_MESSAGE := NULL;
   END IF;
   DBMS_LOB.FREETEMPORARY(v_RESPONSE);
   LOGS.LOG_INFO('Exit');
END REQUEST_SUBMIT;

PROCEDURE SUBMIT_SCHEDULES_TO_PJM
   (
   p_SCHEDULE_TYPE IN NUMBER,
   p_BEGIN_DATE    IN DATE,
   p_END_DATE      IN DATE,
   p_TRACE_ON      IN NUMBER,
   p_STATUS       OUT NUMBER,
   p_MESSAGE      OUT VARCHAR2
   ) AS
v_CONTENT CLOB;
v_COUNT PLS_INTEGER;
BEGIN
-- Initiate Process Log --
   LOGS.START_PROCESS(c_PROCESS_NAME_SUBMIT_SCHEDULE, p_BEGIN_DATE, p_END_DATE, p_TRACE_ON => p_TRACE_ON);
   LOGS.LOG_INFO(c_PROCESS_NAME_SUBMIT_SCHEDULE);
   LOGS.LOG_INFO('Schedule_Type: ' || CASE p_SCHEDULE_TYPE WHEN CONSTANTS.SCHEDULE_TYPE_FORECAST THEN 'Forecast' WHEN CONSTANTS.SCHEDULE_TYPE_PRELIM THEN 'Preliminary' WHEN CONSTANTS.SCHEDULE_TYPE_FINAL THEN 'Final' ELSE '?' END);
   LOGS.LOG_INFO('Begin Date: ' || TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE));
   LOGS.LOG_INFO('End Date: ' || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE));
   INITIALIZE_INTERFACE;
   l_TRACE_ON := p_TRACE_ON;
-- Fetch The Schedule Content From RO For The Specified Time Period --
   GET_SCHEDULE_CONTENT(p_SCHEDULE_TYPE, p_BEGIN_DATE, p_END_DATE, v_CONTENT, v_COUNT);
-- Submit The Content To The PJM Interface --
   REQUEST_SUBMIT(p_SCHEDULE_TYPE, p_BEGIN_DATE, p_END_DATE, v_CONTENT, p_STATUS, p_MESSAGE);
   IF p_MESSAGE IS NULL THEN
      p_MESSAGE := c_PROCESS_NAME_SUBMIT_SCHEDULE || ' Complete.' || c_CRLF || 'Number Of Schedule Records In Submission: ' || TO_CHAR(v_COUNT) || '.';
   END IF;
   LOGS.LOG_INFO(p_MESSAGE);
   LOGS.STOP_PROCESS(p_MESSAGE, p_STATUS);
EXCEPTION
   WHEN OTHERS THEN
      p_MESSAGE := FORMAT_EXCEPTION_MESSAGE(DBMS_UTILITY.FORMAT_ERROR_STACK);
      ROLLBACK;
      ERRS.ABORT_PROCESS;
END SUBMIT_SCHEDULES_TO_PJM;

PROCEDURE EXPORT_SCHEDULES_TO_FILE
   (
   p_SCHEDULE_TYPE IN NUMBER,
   p_BEGIN_DATE    IN DATE,
   p_END_DATE      IN DATE,
   p_TRACE_ON      IN NUMBER,
   p_FILE         OUT CLOB,
   p_STATUS       OUT NUMBER,
   p_MESSAGE      OUT VARCHAR2
   ) AS
v_PROCEDURE VARCHAR2(32) := 'EXPORT_SCHEDULES_TO_FILE';
v_COUNT PLS_INTEGER;
BEGIN
-- Initiate Process Log --
   LOGS.START_PROCESS(c_PROCESS_NAME_EXPORT_SCHEDULE, p_BEGIN_DATE, p_END_DATE, p_TRACE_ON => p_TRACE_ON);
   LOGS.LOG_INFO(c_PROCESS_NAME_EXPORT_SCHEDULE);
   LOGS.LOG_INFO('Schedule_Type: ' || CASE p_SCHEDULE_TYPE WHEN CONSTANTS.SCHEDULE_TYPE_FORECAST THEN 'Forecast' WHEN CONSTANTS.SCHEDULE_TYPE_PRELIM THEN 'Preliminary' WHEN CONSTANTS.SCHEDULE_TYPE_FINAL THEN 'Final' ELSE '?' END);
   LOGS.LOG_INFO('Begin Date: ' || TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE));
   LOGS.LOG_INFO('End Date: ' || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE));
   INITIALIZE_INTERFACE;
   l_TRACE_ON := p_TRACE_ON;
-- Fetch The Schedule Content From RO For The Specified Time Period --
   GET_SCHEDULE_CONTENT(p_SCHEDULE_TYPE, p_BEGIN_DATE, p_END_DATE, p_FILE, v_COUNT);
   p_MESSAGE := c_PROCESS_NAME_EXPORT_SCHEDULE || ' Complete.' || c_CRLF || 'Number Of Schedule Records In File: ' || TO_CHAR(v_COUNT) || '.';
   LOGS.STOP_PROCESS(p_MESSAGE, p_STATUS);
EXCEPTION
   WHEN OTHERS THEN
      p_MESSAGE := FORMAT_EXCEPTION_MESSAGE(DBMS_UTILITY.FORMAT_ERROR_STACK);
      ROLLBACK;
      ERRS.ABORT_PROCESS;
END EXPORT_SCHEDULES_TO_FILE;

PROCEDURE PUT_SCHEDULE
   (
   p_FIELDS IN PARSE_UTIL.STRING_TABLE,
   p_TRANSACTION_ID IN NUMBER,
   p_SCHEDULE_TYPE IN NUMBER,
   p_SCHEDULE_DATE IN DATE,
   p_DAY_TYPE IN VARCHAR2
   ) AS
v_PROCEDURE VARCHAR2(32) := 'PUT_SCHEDULE';
v_VALUE VARCHAR2(16);
v_SCHEDULE_DATE DATE;
v_STATUS NUMBER;
v_SCHEDULE_STATUS VARCHAR2(1);
v_MAX_HOUR NUMBER(2) := CASE WHEN p_DAY_TYPE = c_SCHEDULE_LONG_DAY THEN 25 ELSE 24 END;

BEGIN
-- Determine The Status Of The Schedule: Confirmed Or Pending, Seller Status Is In Fields(4), Buyer Status Is In Fields(6) --
   v_SCHEDULE_STATUS := CASE WHEN UPPER(p_FIELDS(4)) = c_SCHEDULE_CONFIRMED AND UPPER(p_FIELDS(6)) = c_SCHEDULE_CONFIRMED THEN c_SCHEDULE_CONFIRMED ELSE c_SCHEDULE_PENDING END;
-- Fields 14 To 38 Are Confirmed Entries, 39 To 63 Are Pending Entries --
   FOR v_HOUR IN 1 .. v_MAX_HOUR LOOP
-- On The Short Day There Is No Hour End 3 --
      IF (p_DAY_TYPE = c_SCHEDULE_NORMAL_DAY) OR (p_DAY_TYPE = c_SCHEDULE_LONG_DAY) OR (p_DAY_TYPE = c_SCHEDULE_SHORT_DAY AND v_HOUR <> 3) THEN
         IF NVL(LENGTH(p_FIELDS(v_HOUR + c_SCHEDULES_CONF_BEGIN - 1)), 0) > 0 THEN
            v_VALUE := p_FIELDS(v_HOUR + c_SCHEDULES_CONF_BEGIN - 1);
         ELSIF NVL(LENGTH(p_FIELDS(v_HOUR + c_SCHEDULES_PEND_BEGIN - 1)), 0) > 0 THEN
            v_VALUE := p_FIELDS(v_HOUR + c_SCHEDULES_PEND_BEGIN - 1);
         ELSE
            v_VALUE := NULL;
         END IF;
-- Put The Schedule Value For The Hour --
         IF v_VALUE IS NOT NULL THEN
            IF p_DAY_TYPE = c_SCHEDULE_LONG_DAY AND v_HOUR = 25 THEN
-- The 25th Hour Represents The Second Hour End 2 --
               v_SCHEDULE_DATE := p_SCHEDULE_DATE + 2 / 24 + (1 / (24 * 60 * 60));
            ELSIF p_DAY_TYPE = c_SCHEDULE_SHORT_DAY AND v_HOUR = 2 THEN
-- File Skips Hour 3, But For Storing In RO As Hour-Ending We Skip Hour 2 --
               v_SCHEDULE_DATE := p_SCHEDULE_DATE + (v_HOUR + 1) / 24;
            ELSE
               v_SCHEDULE_DATE := p_SCHEDULE_DATE + v_HOUR / 24;
            END IF;
-- Store The Schedule Amount For This Hour --
            ITJ.PUT_IT_SCHEDULE(
               p_TRANSACTION_ID => p_TRANSACTION_ID,
               p_SCHEDULE_TYPE => p_SCHEDULE_TYPE,
               p_SCHEDULE_STATE =>  CONSTANTS.EXTERNAL_STATE,
               p_SCHEDULE_DATE => TO_CUT_WITH_OPTIONS(v_SCHEDULE_DATE, GA.LOCAL_TIME_ZONE, c_DST_SPRING_AHEAD_OPTION),
               p_AS_OF_DATE => CONSTANTS.LOW_DATE,
               p_AMOUNT => TO_NUMBER(v_VALUE),
               p_PRICE => NULL,
               p_STATUS => v_STATUS);
            ERRS.VALIDATE_STATUS('ITJ.PUT_IT_SCHEDULE', v_STATUS);
        END IF;
      END IF;
   END LOOP;
END PUT_SCHEDULE;

FUNCTION GET_TRANSACTION_ID(p_CONTRACT_NUMBER IN VARCHAR2, p_SCHEDULE_DATE IN DATE) RETURN INTERNAL_ID AS
-- Answer The Transaction Id Associated With The Specified Contract Number --
v_TRANSACTION_ID INTERNAL_ID;
v_COUNT PLS_INTEGER;
BEGIN
   SELECT MIN(TRANSACTION_ID), COUNT(*) INTO v_TRANSACTION_ID, v_COUNT
   FROM TP_CONTRACT_NUMBER A, INTERCHANGE_TRANSACTION B
   WHERE A.CONTRACT_NUMBER = p_CONTRACT_NUMBER
      AND p_SCHEDULE_DATE BETWEEN A.BEGIN_DATE AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE)
      AND B.CONTRACT_ID = A.CONTRACT_ID
      AND B.COMMODITY_ID = (SELECT COMMODITY_ID FROM IT_COMMODITY WHERE COMMODITY_NAME = 'Retail Load');
   IF v_COUNT > 1 THEN
      ERRS.RAISE_BUSINESS_RULE_ERROR(' More Than One Retail Load Transaction Associated With Contract Number: ' || p_CONTRACT_NUMBER);
   END IF;
   RETURN NVL(v_TRANSACTION_ID, CONSTANTS.NOT_ASSIGNED);
END GET_TRANSACTION_ID;

PROCEDURE PUT_SCHEDULE_RECORD
   (
   p_EXTERNAL_ACCOUNT_NAME in VARCHAR2,
   p_SCHEDULE_TYPE IN NUMBER,
   p_RECORD IN VARCHAR2,
   p_CONTRACT_NUMBER OUT VARCHAR2,
   p_TRANSACTION_DEFINED OUT BOOLEAN
   ) AS
v_PROCEDURE VARCHAR2(32) := 'PUT_SCHEDULE_RECORD';
v_FIELDS PARSE_UTIL.STRING_TABLE;
v_SCHEDULE_DATE DATE;
v_TRANSACTION_ID INTERNAL_ID;
v_HOURS NUMBER(2);
v_DAY_TYPE VARCHAR2(32);
BEGIN
   PARSE_UTIL.TOKENS_FROM_STRING(p_RECORD, c_COMMA, v_FIELDS);
   p_CONTRACT_NUMBER := v_FIELDS(1);
   v_SCHEDULE_DATE := TO_DATE(v_FIELDS(2), c_SHORT_DATE_FORMAT);
-- Get The RO Transaction Associated With The PJM Contract Number --
   v_TRANSACTION_ID := GET_TRANSACTION_ID(p_CONTRACT_NUMBER, v_SCHEDULE_DATE);
   IF v_TRANSACTION_ID = CONSTANTS.NOT_ASSIGNED  THEN
      p_TRANSACTION_DEFINED := FALSE;
   ELSE
-- Extend Transaction Date Range If Needed --
      UPDATE INTERCHANGE_TRANSACTION SET
         BEGIN_DATE = CASE WHEN BEGIN_DATE > v_SCHEDULE_DATE THEN v_SCHEDULE_DATE ELSE BEGIN_DATE END,
         END_DATE = CASE WHEN END_DATE < v_SCHEDULE_DATE THEN v_SCHEDULE_DATE ELSE END_DATE END
      WHERE TRANSACTION_ID = v_TRANSACTION_ID
         AND v_SCHEDULE_DATE NOT BETWEEN BEGIN_DATE AND END_DATE;
-- Determine Day Length In Hours --
      v_HOURS := CASE WHEN NVL(LENGTH(v_FIELDS(c_SCHEDULES_CONF_END)), 0) > 0 OR NVL(LENGTH(v_FIELDS(c_SCHEDULES_PEND_END)), 0) > 0 THEN 25 WHEN NVL(LENGTH(v_FIELDS(c_SCHEDULES_CONF_END - 1)), 0) = 0 AND NVL(LENGTH(v_FIELDS(c_SCHEDULES_PEND_END - 1)), 0) = 0 THEN 23 ELSE 24 END;
-- Determine DST Day Type --
      v_DAY_TYPE := CASE WHEN v_SCHEDULE_DATE = TRUNC(DST_FALL_BACK_DATE(v_SCHEDULE_DATE)) OR v_HOURS > 24 THEN c_SCHEDULE_LONG_DAY WHEN v_SCHEDULE_DATE = TRUNC(DST_SPRING_AHEAD_DATE(v_SCHEDULE_DATE)) AND v_HOURS < 24 THEN c_SCHEDULE_SHORT_DAY ELSE c_SCHEDULE_NORMAL_DAY END;
-- Process The Record --
      PUT_SCHEDULE(v_FIELDS, v_TRANSACTION_ID, p_SCHEDULE_TYPE, v_SCHEDULE_DATE, v_DAY_TYPE);
      p_TRANSACTION_DEFINED := TRUE;
   END IF;
END PUT_SCHEDULE_RECORD;

PROCEDURE POST_SCHEDULE_CONTENT
   (
   p_EXTERNAL_ACCOUNT_NAME IN VARCHAR2,
   p_SCHEDULE_TYPE IN NUMBER,
   p_CONTENT IN CLOB
   ) AS
v_PROCEDURE VARCHAR2(32) := 'POST_SCHEDULE_CONTENT';
v_CONTRACT_NUMBER VARCHAR2(32);
v_TRANSACTION_DEFINED BOOLEAN;
v_RECORDS PARSE_UTIL.BIG_STRING_TABLE_MP;
v_INDEX BINARY_INTEGER;
v_COUNT PLS_INTEGER := 0;
v_INVALID_COUNT PLS_INTEGER := 0;
TYPE t_CONTRACT_WO_TRANSACTION IS TABLE OF BOOLEAN INDEX BY VARCHAR2(32);
v_CONTRACT_WO_TRANSACTION t_CONTRACT_WO_TRANSACTION;
BEGIN
   LOGS.LOG_INFO('Entry');
   PARSE_UTIL.PARSE_CLOB_INTO_LINES(p_CONTENT, v_RECORDS);
-- First Record Is A Header, Start With Second Record --
   v_INDEX := v_RECORDS.NEXT(v_RECORDS.FIRST);
-- Iterate Over The Content Records And Process --
   WHILE v_RECORDS.EXISTS(v_INDEX) LOOP
      IF LENGTH(v_RECORDS(v_INDEX)) > 0 THEN
         PUT_SCHEDULE_RECORD(p_EXTERNAL_ACCOUNT_NAME, p_SCHEDULE_TYPE, v_RECORDS(v_INDEX), v_CONTRACT_NUMBER, v_TRANSACTION_DEFINED);
         IF v_TRANSACTION_DEFINED THEN
            v_COUNT := v_COUNT + 1;
         ELSE
            IF NOT v_CONTRACT_WO_TRANSACTION.EXISTS(v_CONTRACT_NUMBER) THEN
               LOGS.LOG_WARN(' No Transaction Associated With Contract Number: ' || v_CONTRACT_NUMBER);
               v_CONTRACT_WO_TRANSACTION(v_CONTRACT_NUMBER) := TRUE;
            END IF;
            v_INVALID_COUNT := v_INVALID_COUNT + 1;
         END IF;
      END IF;
      v_INDEX := v_RECORDS.NEXT(v_INDEX);
   END LOOP;
   LOGS.LOG_INFO('Records Processed: ' || TO_CHAR(v_COUNT) || '.');
   LOGS.LOG_INFO('Invalid Records Encountered: ' || TO_CHAR(v_INVALID_COUNT) || '.');
   LOGS.LOG_INFO('Exit');
END POST_SCHEDULE_CONTENT;

PROCEDURE DELETE_EXTERNAL_SCHEDULES
   (
   p_SCHEDULE_TYPE IN NUMBER,
   p_BEGIN_DATE IN DATE,
   p_END_DATE IN DATE
   ) AS
v_PROCEDURE VARCHAR2(32) := 'DELETE_EXTERNAL_SCHEDULES';
v_BEGIN_DATE DATE;
v_END_DATE DATE;
BEGIN
   LOGS.LOG_INFO('Entry');
   UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, GA.LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
   LOGS.LOG_INFO('Delete External Schedule Content For Time Range: ' || TEXT_UTIL.TO_CHAR_TIME(v_BEGIN_DATE) || '-' || TEXT_UTIL.TO_CHAR_TIME(v_END_DATE) || '.');
   DELETE IT_SCHEDULE
   WHERE TRANSACTION_ID IN (SELECT TRANSACTION_ID FROM INTERCHANGE_TRANSACTION WHERE TRANSACTION_TYPE = c_LOAD_TRANSACTION_TYPE AND COMMODITY_ID IN (SELECT COMMODITY_ID FROM IT_COMMODITY WHERE COMMODITY_NAME IN ('Energy','Retail Load')))
      AND SCHEDULE_TYPE = p_SCHEDULE_TYPE
      AND SCHEDULE_STATE = CONSTANTS.EXTERNAL_STATE
      AND SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE;
   LOGS.LOG_INFO('Number Of Records Deleted Prior To Import: ' || TO_CHAR(SQL%ROWCOUNT) || '.');
   LOGS.LOG_INFO('Exit');
END DELETE_EXTERNAL_SCHEDULES;

PROCEDURE REQUEST_QUERY
   (
   p_SCHEDULE_TYPE IN NUMBER,
   p_BEGIN_DATE IN DATE,
   p_END_DATE IN DATE
   ) AS
v_PROCEDURE VARCHAR2(32) := 'REQUEST_QUERY';
v_CREDENTIALS MEX_CREDENTIALS;
v_LOGGER MM_LOGGER_ADAPTER;
v_PARAMETER_MAP MEX_UTIL.PARAMETER_MAP := MEX_SWITCHBOARD.c_EMPTY_PARAMETER_MAP;
v_RESPONSE CLOB;
v_EXTERNAL_ACCOUNT_NAME VARCHAR2(32) := GET_DICTIONARY_VALUE(c_SETTING_ACCOUNT_NAME, GA.GLOBAL_MODEL, c_SYSTEM_SETTING_MODULE, c_SYSTEM_SETTING_KEY1);
v_STATUS NUMBER;
BEGIN
   LOGS.LOG_INFO('Entry');
   IF v_EXTERNAL_ACCOUNT_NAME IS NULL THEN
      ERRS.RAISE_BUSINESS_RULE_ERROR(' PJM Account Name Is Not Defined.');
   END IF;
-- Set The Parameter Map --
   v_PARAMETER_MAP(CDI_MEX_PJM.c_REPORT_TYPE) := 'schedules';
-- Initialize The Market Exchange Interface --
   MEX_SWITCHBOARD.INIT_MEX(
      p_EXTERNAL_SYSTEM_ID => EC.ES_PJM,
      p_EXTERNAL_ACCOUNT_NAME => v_EXTERNAL_ACCOUNT_NAME,
      p_PROCESS_NAME => c_PROCESS_NAME_QUERY_SCHEDULE,
      p_EXCHANGE_NAME => c_QUERY_EXCHANGE_TYPE,
      p_LOG_TYPE => c_LOG_TYPE,
      p_TRACE_ON => l_TRACE_ON,
      p_CREDENTIALS => v_CREDENTIALS,
      p_LOGGER => v_LOGGER);
-- Make The Request --
   CDI_MEX_PJM.RUN_PJM_BROWSERLESS(
      p_CREDENTIALS => v_CREDENTIALS,
      p_BEGIN_DATE  => p_BEGIN_DATE,
      p_END_DATE  => p_END_DATE,
      p_PARAMETER_MAP  => v_PARAMETER_MAP,
      p_REQUEST_APPLICATION  => c_PJM_ESCHEDULE_APPLICATION,
      p_REQUEST_DIRECTORY  => 'download',
      p_LOGGER  => v_LOGGER,
      p_RESPONSE => v_RESPONSE,
      p_STATUS => v_STATUS);
-- Raise A Business Exception If There Is No Schedule Conetent For The Specified Time Period --
   IF v_STATUS = MEX_SWITCHBOARD.c_STATUS_SUCCESS THEN
      IF v_RESPONSE LIKE '%No Schedules Found:%' THEN
         ERRS.RAISE_BUSINESS_RULE_ERROR(' No Schedules Found For Specified Time Period.');
      END IF;
-- Delete External Preliminary Data For Allocated Default Supplier Schedules And EGS Schedule Data --
      DELETE_EXTERNAL_SCHEDULES(p_SCHEDULE_TYPE, p_BEGIN_DATE, p_END_DATE);
-- Process The Result Container --
      POST_SCHEDULE_CONTENT(v_EXTERNAL_ACCOUNT_NAME, p_SCHEDULE_TYPE, v_RESPONSE);
   END IF;
   LOGS.LOG_INFO('Exit');
END REQUEST_QUERY;

PROCEDURE QUERY_SCHEDULES_FROM_PJM
   (
   p_SCHEDULE_TYPE IN NUMBER,
   p_BEGIN_DATE    IN DATE,
   p_END_DATE      IN DATE,
   p_TRACE_ON      IN NUMBER,
   p_STATUS       OUT NUMBER,
   p_MESSAGE      OUT VARCHAR2
   ) AS
v_PROCEDURE VARCHAR2(32) := 'QUERY_SCHEDULES_FROM_PJM';
BEGIN
-- Initiate Process Log --
   LOGS.START_PROCESS(c_PROCESS_NAME_QUERY_SCHEDULE, p_BEGIN_DATE, p_END_DATE, p_TRACE_ON => p_TRACE_ON);
   LOGS.LOG_INFO(c_PROCESS_NAME_QUERY_SCHEDULE);
   LOGS.LOG_INFO('Schedule_Type: ' || CASE p_SCHEDULE_TYPE WHEN CONSTANTS.SCHEDULE_TYPE_FORECAST THEN 'Forecast' WHEN CONSTANTS.SCHEDULE_TYPE_PRELIM THEN 'Preliminary' WHEN CONSTANTS.SCHEDULE_TYPE_FINAL THEN 'Final' ELSE '?' END);
   LOGS.LOG_INFO('Begin Date: ' || TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE));
   LOGS.LOG_INFO('End Date: ' || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE));
   l_TRACE_ON := p_TRACE_ON;
-- Fetch The Content From PJM For The Time Period And Store As An External Schedule --
   REQUEST_QUERY(p_SCHEDULE_TYPE, p_BEGIN_DATE, p_END_DATE);
   LOGS.STOP_PROCESS(p_MESSAGE, p_STATUS);
EXCEPTION
   WHEN OTHERS THEN
      p_MESSAGE := FORMAT_EXCEPTION_MESSAGE(DBMS_UTILITY.FORMAT_ERROR_STACK);
      ROLLBACK;
      ERRS.ABORT_PROCESS;
END QUERY_SCHEDULES_FROM_PJM;

PROCEDURE SAVE_FINAL_SETTLEMENT_TO_FILE
   (
   p_BEGIN_DATE IN DATE,
   p_END_DATE   IN DATE,
   p_FILE      OUT CLOB,
   p_STATUS    OUT NUMBER,
   p_MESSAGE   OUT VARCHAR2
   ) AS
CURSOR c_SYSTEM_LOAD(p_CUT_BEGIN_DATE IN DATE, p_CUT_END_DATE IN DATE) IS
SELECT T.CUT_DATE, T.LOCAL_DATE,
   MAX(CASE WHEN A.SERVICE_CODE = CONSTANTS.CODE_BACKCAST THEN A.UFE_SYSTEM_LOAD ELSE 0 END) "PRELIM",
   MAX(CASE WHEN A.SERVICE_CODE = CONSTANTS.CODE_ACTUAL   THEN A.UFE_SYSTEM_LOAD ELSE 0 END) "FINAL"
FROM CDI_EASTERN_PREVAILING_TIME$ T
   JOIN EDC_SYSTEM_UFE_LOAD       A ON A.LOAD_DATE = T.CUT_DATE AND A.MODEL_ID = GA.ELECTRIC_MODEL AND A.SCENARIO_ID = GA.BASE_SCENARIO_ID AND A.SERVICE_CODE IN (CONSTANTS.CODE_BACKCAST, CONSTANTS.CODE_ACTUAL) AND A.LOAD_CODE = GA.STANDARD AND A.EDC_ID = (SELECT EDC_ID FROM ENERGY_DISTRIBUTION_COMPANY WHERE EDC_EXTERNAL_IDENTIFIER = 'SMECO')
   WHERE T.CUT_DATE BETWEEN p_CUT_BEGIN_DATE AND p_CUT_END_DATE
GROUP BY T.CUT_DATE, T.LOCAL_DATE
ORDER BY T.CUT_DATE;
CURSOR c_SUPPLIER(p_CUT_BEGIN_DATE IN DATE, p_CUT_END_DATE IN DATE) IS
   SELECT DISTINCT C.ESP_ID, D.ESP_ALIAS, E.CONTRACT_NUMBER
   FROM CDI_EASTERN_PREVAILING_TIME$ T
      JOIN SERVICE_OBLIGATION_LOAD   A ON A.LOAD_DATE = T.CUT_DATE AND A.SERVICE_CODE IN (CONSTANTS.CODE_BACKCAST, CONSTANTS.CODE_ACTUAL) AND A.LOAD_CODE = GA.STANDARD
      JOIN SERVICE_OBLIGATION        B ON B.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID AND B.MODEL_ID = GA.ELECTRIC_MODEL AND B.SCENARIO_ID = GA.BASE_SCENARIO_ID
      JOIN PROVIDER_SERVICE          C ON C.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
      JOIN ENERGY_SERVICE_PROVIDER   D ON D.ESP_ID = C.ESP_ID AND D.ESP_ALIAS <> CONSTANTS.UNDEFINED_ATTRIBUTE
      LEFT JOIN TP_CONTRACT_NUMBER   E ON E.CONTRACT_NAME = D.ESP_ALIAS
   WHERE T.CUT_DATE BETWEEN p_CUT_BEGIN_DATE AND p_CUT_END_DATE
   ORDER BY CASE WHEN D.ESP_ALIAS = 'SMECO' THEN '0' ELSE D.ESP_ALIAS END;
CURSOR c_SUPPLIER_LOAD(p_ESP_ID IN NUMBER, p_CUT_BEGIN_DATE IN DATE, p_CUT_END_DATE IN DATE) IS
   SELECT T.CUT_DATE, T.LOCAL_DATE,
      MAX(CASE WHEN A.SERVICE_CODE = CONSTANTS.CODE_BACKCAST THEN A.LOAD_VAL + A.TX_LOSS_VAL + A.DX_LOSS_VAL + A.UFE_LOAD_VAL ELSE 0 END) "PRELIM",
      MAX(CASE WHEN A.SERVICE_CODE = CONSTANTS.CODE_ACTUAL   THEN A.LOAD_VAL + A.TX_LOSS_VAL + A.DX_LOSS_VAL + A.UFE_LOAD_VAL ELSE 0 END) "FINAL"
   FROM CDI_EASTERN_PREVAILING_TIME$ T
      JOIN SERVICE_OBLIGATION_LOAD   A ON A.LOAD_DATE = T.CUT_DATE AND A.SERVICE_CODE IN (CONSTANTS.CODE_BACKCAST, CONSTANTS.CODE_ACTUAL) AND A.LOAD_CODE = GA.STANDARD
      JOIN SERVICE_OBLIGATION        B ON B.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID AND B.MODEL_ID = GA.ELECTRIC_MODEL AND B.SCENARIO_ID = GA.BASE_SCENARIO_ID
      JOIN PROVIDER_SERVICE          C ON C.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID AND C.ESP_ID = p_ESP_ID
   WHERE T.CUT_DATE BETWEEN p_CUT_BEGIN_DATE AND p_CUT_END_DATE
   GROUP BY T.CUT_DATE, T.LOCAL_DATE
   ORDER BY T.CUT_DATE;
v_CONTENT t_SETTLEMENT_CONTENT;
v_CUT_BEGIN_DATE DATE;
v_CUT_END_DATE DATE;
v_COUNT PLS_INTEGER := 0;
v_TX_LOSS_FACTOR NUMBER;
v_INDEX VARCHAR2(32);
v_BUFFER VARCHAR2(1000);
v_HEADER_1 VARCHAR2(1000) := 'Service';
v_HEADER_2 VARCHAR2(1000) := 'Date';
v_HEADER_3 VARCHAR2(1000) := 'Time';
v_TEMPLATE VARCHAR2(100) := ',~,~,~,~,~,~';
v_LOSS_FACTOR_NAME VARCHAR2(32) := NVL(GET_DICTIONARY_VALUE(c_SETTING_LOSS_FACTOR_NAME, GA.GLOBAL_MODEL, c_SYSTEM_SETTING_MODULE, c_SYSTEM_SETTING_KEY1, c_SYSTEM_SETTING_KEY2),CONSTANTS.NONE_STRING);
BEGIN
-- Initiate Process Log --
   LOGS.START_PROCESS(c_PROCESS_NAME_FINAL_TO_FILE, p_BEGIN_DATE, p_END_DATE);
   LOGS.LOG_INFO(c_PROCESS_NAME_FINAL_TO_FILE);
   LOGS.LOG_INFO('Begin Date: ' || TO_CHAR(p_BEGIN_DATE, c_DATE_FORMAT));
   LOGS.LOG_INFO('End Date: ' || TO_CHAR(p_END_DATE, c_DATE_FORMAT));
   UT.CUT_DAY_INTERVAL_RANGE(p_BEGIN_DATE, p_END_DATE, GA.LOCAL_TIME_ZONE, v_CUT_BEGIN_DATE, v_CUT_END_DATE);
   LOGS.LOG_INFO('Cut Begin Date: ' || TO_CHAR(v_CUT_BEGIN_DATE, c_DATE_TIME_FORMAT));
   LOGS.LOG_INFO('Cut End Date: ' || TO_CHAR(v_CUT_END_DATE), c_DATE_TIME_FORMAT);
   p_MESSAGE := NULL;
-- Cache The Transmission Loss Factors To Be Added To The Service Load --
   CACHE_LOSS_FACTOR(v_LOSS_FACTOR_NAME, p_BEGIN_DATE, p_END_DATE + 1);
-- Stage The System Load --
   LOGS.LOG_INFO('Processing System Load');
   v_HEADER_1 := v_HEADER_1 || REPLACE(v_TEMPLATE,'~','System');
   v_HEADER_2 := v_HEADER_2 || ',Load,Load With Losses,Load,Load With Losses,Load,Load With Losses';
   v_HEADER_3 := v_HEADER_3 || ',Prelim MWh,Prelim MWh,Final MWh,Final MWh,Delta kWh,Delta kWh';
   FOR v_SELECT IN c_SYSTEM_LOAD(v_CUT_BEGIN_DATE, v_CUT_END_DATE) LOOP
      v_TX_LOSS_FACTOR := GET_LOSS_FACTOR(v_SELECT.LOCAL_DATE);
      v_BUFFER := TO_CHAR(v_SELECT.PRELIM) || ',' || TO_CHAR(ROUND(v_SELECT.PRELIM * v_TX_LOSS_FACTOR,3)) || ',' || TO_CHAR(v_SELECT.FINAL) || ',' || TO_CHAR(ROUND(v_SELECT.FINAL * v_TX_LOSS_FACTOR,3)) || ',' || TO_CHAR(v_SELECT.PRELIM - v_SELECT.FINAL) || ',' || TO_CHAR(ROUND((v_SELECT.PRELIM - v_SELECT.FINAL) * v_TX_LOSS_FACTOR,3)) || ',';
      v_CONTENT(TO_CHAR(v_SELECT.LOCAL_DATE, c_DATE_TIME_KEY)) := v_BUFFER; 
   END LOOP;
-- Iterate Over Each Supplier --
   FOR v_SUPPLIER IN c_SUPPLIER(v_CUT_BEGIN_DATE, v_CUT_END_DATE) LOOP
      LOGS.LOG_INFO('Processing Supplier: ' || v_SUPPLIER.ESP_ALIAS);
      v_HEADER_1 := v_HEADER_1 || REPLACE(v_TEMPLATE,'~',v_SUPPLIER.ESP_ALIAS || CASE WHEN v_SUPPLIER.CONTRACT_NUMBER IS NOT NULL THEN ' (' || v_SUPPLIER.CONTRACT_NUMBER || ')' ELSE '' END);
      v_HEADER_2 := v_HEADER_2 || ',Load,Load With Losses,Load,Load With Losses,Load,Load With Losses';
      v_HEADER_3 := v_HEADER_3 || ',Prelim MWh,Prelim MWh,Final MWh,Final MWh,Delta kWh,Delta kWh';
-- Stage The Supplier Load --
      FOR v_SELECT IN c_SUPPLIER_LOAD(v_SUPPLIER.ESP_ID, v_CUT_BEGIN_DATE, v_CUT_END_DATE) LOOP
         v_TX_LOSS_FACTOR := GET_LOSS_FACTOR(v_SELECT.LOCAL_DATE);
         v_BUFFER := TO_CHAR(v_SELECT.PRELIM) || ',' || TO_CHAR(ROUND(v_SELECT.PRELIM * v_TX_LOSS_FACTOR,3)) || ',' || TO_CHAR(v_SELECT.FINAL) || ',' || TO_CHAR(ROUND(v_SELECT.FINAL * v_TX_LOSS_FACTOR,3)) || ',' || TO_CHAR(ROUND((v_SELECT.PRELIM - v_SELECT.FINAL) * 1000)) || ',' || TO_CHAR(ROUND((v_SELECT.PRELIM - v_SELECT.FINAL) * v_TX_LOSS_FACTOR * 1000)) || ',';
         v_CONTENT(TO_CHAR(v_SELECT.LOCAL_DATE, c_DATE_TIME_KEY)) := v_CONTENT(TO_CHAR(v_SELECT.LOCAL_DATE, c_DATE_TIME_KEY)) || v_BUFFER; 
      END LOOP;
   END LOOP;
   DBMS_LOB.CREATETEMPORARY(p_FILE, TRUE);
   DBMS_LOB.OPEN(p_FILE, DBMS_LOB.LOB_READWRITE);
   v_HEADER_1 := v_HEADER_1 || c_CRLF;
   v_HEADER_2 := v_HEADER_2 || c_CRLF;
   v_HEADER_3 := v_HEADER_3 || c_CRLF;
   DBMS_LOB.WRITEAPPEND(p_FILE, LENGTH(v_HEADER_1), v_HEADER_1);
   DBMS_LOB.WRITEAPPEND(p_FILE, LENGTH(v_HEADER_2), v_HEADER_2);
   DBMS_LOB.WRITEAPPEND(p_FILE, LENGTH(v_HEADER_3), v_HEADER_3);
   v_INDEX := v_CONTENT.FIRST;
   WHILE v_INDEX IS NOT NULL LOOP
      v_BUFFER := v_INDEX || ',' || RTRIM(v_CONTENT(v_INDEX), ',') || c_CRLF;
      DBMS_LOB.WRITEAPPEND(p_FILE, LENGTH(v_BUFFER), v_BUFFER);
      v_COUNT := v_COUNT + 1;
      v_INDEX := v_CONTENT.NEXT(v_INDEX);
   END LOOP;
   DBMS_LOB.CLOSE(p_FILE);
   p_MESSAGE := 'Number Of Records Written To File: ' || TO_CHAR(v_COUNT);
   LOGS.LOG_INFO(p_MESSAGE);
   LOGS.LOG_INFO(c_PROCESS_NAME_FINAL_TO_FILE || ' Complete');
   LOGS.STOP_PROCESS(p_MESSAGE, p_STATUS);
EXCEPTION
   WHEN OTHERS THEN
      p_MESSAGE := FORMAT_EXCEPTION_MESSAGE(DBMS_UTILITY.FORMAT_ERROR_STACK);
      LOGS.LOG_ERROR(p_MESSAGE);
      ERRS.ABORT_PROCESS;
END SAVE_FINAL_SETTLEMENT_TO_FILE;

END CDI_PJM_INSCHEDULE;
/
