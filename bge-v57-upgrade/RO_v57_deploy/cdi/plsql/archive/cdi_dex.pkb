CREATE OR REPLACE PACKAGE BODY CDI_DEX AS

-- Package Types --
SUBTYPE INTERNAL_ID IS NUMBER(9);

-- Package Constants --
c_PACKAGE                      CONSTANT VARCHAR2(16) := 'CDI_DEX';
c_SYSTEM_SETTING_LIBRARY       CONSTANT NUMBER(1)    := 0;
c_SYSTEM_SETTING_BOOK          CONSTANT VARCHAR2(32) := 'Custom Data Interface';
c_SYSTEM_SETTING_CHAPTER_1     CONSTANT VARCHAR2(32) := 'Forecast';
c_SYSTEM_SETTING_CHAPTER_2     CONSTANT VARCHAR2(32) := 'Backcast';
c_SYSTEM_SETTING_CHAPTER_3     CONSTANT VARCHAR2(32) := 'PLC/NSPL';
c_SYSTEM_SETTING_PAGE          CONSTANT VARCHAR2(32) := 'Data Exchange';
c_SETTING_DEMAND_BID_LIST      CONSTANT VARCHAR2(32) := 'Enable Demand Bid List';
c_SETTING_FORECAST_DELETE_LIST CONSTANT VARCHAR2(32) := 'Enable Forecast Delete List';
c_SETTING_BACKCAST_DELETE_LIST CONSTANT VARCHAR2(32) := 'Enable Backcast Delete List';
c_SETTING_EGS_SUPPLIER_LIST    CONSTANT VARCHAR2(32) := 'Enable EGS Supplier List';
c_SETTING_BACKCAST_SCHED_LIST  CONSTANT VARCHAR2(32) := 'Enable Backcast Schedule List';
c_SETTING_ACCOUNT_TYPE_LIST    CONSTANT VARCHAR2(32) := 'Enable Account Type List';
c_FORECAST_CATEGORY            CONSTANT VARCHAR2(32) := 'Forecast';
c_BACKCAST_CATEGORY            CONSTANT VARCHAR2(32) := 'Backcast';
c_REQUEST_TYPE_BODY            CONSTANT VARCHAR2(32) := 'Request Body';
c_DEMAND_BID_IDENTIFIER        CONSTANT VARCHAR2(64) := 'Request: MARKET_SUBMIT:SubmitFixedDemand for % (pjmemkt.submit)';
c_ESCHEDULE_IDENTIFIER         CONSTANT VARCHAR2(64) := 'Request: Submit Schedule for % (pjmbrowserless.esched)';
c_DEMAND_BID_TAG               CONSTANT VARCHAR2(32) := '<DemandBid day=';
c_DEMAND_BID_HOURLY_TAG        CONSTANT VARCHAR2(32) := '<DemandBidHourly hour=';
c_ENABLE_MARKET_EXCHANGE       CONSTANT BOOLEAN      := FALSE;
c_CRLF                         CONSTANT CHAR(2)      := CHR(13) || CHR(10);
-- Package Globals --
l_STATUS                       NUMBER;
l_MESSAGE                      VARCHAR2(4000);


FUNCTION ID_FOR_COMMODITY(p_COMMODITY_NAME IN VARCHAR2) RETURN NUMBER AS
v_COMMODITY_ID INTERNAL_ID;
BEGIN
   ID.ID_FOR_COMMODITY(p_COMMODITY_NAME, FALSE, v_COMMODITY_ID);
   RETURN v_COMMODITY_ID;
END ID_FOR_COMMODITY;

FUNCTION FORMAT_EXCEPTION_MESSAGE(p_MESSAGE IN VARCHAR2) RETURN VARCHAR2 AS
v_MESSAGE VARCHAR2(4000) := SUBSTR(p_MESSAGE, 1, INSTR(p_MESSAGE, CHR(10)) - 1);
BEGIN
   RETURN CASE WHEN LENGTH(v_MESSAGE) = 0 THEN p_MESSAGE ELSE SUBSTR(v_MESSAGE, 12) || ' [' || SUBSTR(v_MESSAGE,1,9) || ']' END;
END FORMAT_EXCEPTION_MESSAGE;

PROCEDURE STOP_PROCESS AS
BEGIN
   l_MESSAGE := NULL;
   l_STATUS := NULL;
   LOGS.STOP_PROCESS(l_MESSAGE, l_STATUS);
END STOP_PROCESS;

PROCEDURE DEMAND_BID_LIST
   (
   p_BEGIN_DATE IN DATE,
   p_END_DATE IN DATE,
   p_CURSOR OUT GA.REFCURSOR,
   p_LABEL OUT VARCHAR2
   ) AS
-- Answer A List Of Demand Bid Transaction Names If The Option Is Enabled, Otherwise Answer Null To Disable The Entity List Widget --
BEGIN
   IF UPPER(SUBSTR(NVL(GET_DICTIONARY_VALUE(c_SETTING_DEMAND_BID_LIST, c_SYSTEM_SETTING_LIBRARY, c_SYSTEM_SETTING_BOOK, c_SYSTEM_SETTING_CHAPTER_1, c_SYSTEM_SETTING_PAGE), CDI_CONSTANTS.c_YES),1,1)) = CDI_CONSTANTS.c_YES THEN
      OPEN p_CURSOR FOR
         SELECT TRANSACTION_NAME, TRANSACTION_ID
         FROM INTERCHANGE_TRANSACTION
         WHERE TRANSACTION_TYPE = CDI_CONSTANTS.c_LOAD_TRANSACTION
            AND BEGIN_DATE <= p_END_DATE
            AND END_DATE >= p_BEGIN_DATE
            AND COMMODITY_ID = (SELECT COMMODITY_ID FROM IT_COMMODITY WHERE COMMODITY_NAME = CDI_CONSTANTS.c_DAYAHEAD_ENERGY)
            AND SCHEDULE_GROUP_ID = (SELECT SCHEDULE_GROUP_ID FROM SCHEDULE_GROUP WHERE SCHEDULE_GROUP_NAME = CDI_CONSTANTS.c_DEMAND_BID)
         ORDER BY TRANSACTION_NAME;
      p_LABEL := CDI_CONSTANTS.c_SCHEDULE_LIST;
   ELSE
      OPEN p_CURSOR FOR SELECT NULL FROM DUAL;
      p_LABEL := NULL;
   END IF;
END DEMAND_BID_LIST;

PROCEDURE BACKCAST_SCHEDULE_LIST
   (
   p_BEGIN_DATE IN DATE,
   p_END_DATE IN DATE,
   p_CURSOR OUT GA.REFCURSOR,
   p_LABEL OUT VARCHAR2
   ) AS
-- Answer A List Of Backcast Transaction Names For PJM Submission If The Option Is Enabled, Otherwise Answer Null To Disable The Entity List Widget --
BEGIN
   IF UPPER(SUBSTR(NVL(GET_DICTIONARY_VALUE(c_SETTING_BACKCAST_SCHED_LIST, c_SYSTEM_SETTING_LIBRARY, c_SYSTEM_SETTING_BOOK, c_SYSTEM_SETTING_CHAPTER_2, c_SYSTEM_SETTING_PAGE), CDI_CONSTANTS.c_YES),1,1)) = CDI_CONSTANTS.c_YES THEN
      OPEN p_CURSOR FOR
         SELECT TRANSACTION_NAME, TRANSACTION_ID
         FROM INTERCHANGE_TRANSACTION T
         WHERE TRANSACTION_TYPE = CDI_CONSTANTS.c_LOAD_TRANSACTION
            AND BEGIN_DATE <= p_END_DATE
            AND END_DATE >= p_BEGIN_DATE
            AND SCHEDULE_GROUP_ID IN (SELECT SCHEDULE_GROUP_ID FROM SCHEDULE_GROUP WHERE SCHEDULE_GROUP_NAME IN (CDI_CONSTANTS.c_ALLOCATION,CDI_CONSTANTS.c_EGS))
            AND EXISTS (SELECT NULL FROM IT_SCHEDULE WHERE TRANSACTION_ID = T.TRANSACTION_ID AND SCHEDULE_TYPE = CONSTANTS.SCHEDULE_TYPE_PRELIM AND SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE AND SCHEDULE_DATE BETWEEN TO_CUT(p_BEGIN_DATE, CDI_CONSTANTS.c_LOCAL_TIME_ZONE) AND TO_CUT(p_END_DATE + 1, CDI_CONSTANTS.c_LOCAL_TIME_ZONE))
         ORDER BY TRANSACTION_NAME;
      p_LABEL := CDI_CONSTANTS.c_SCHEDULE_LIST;
   ELSE
      OPEN p_CURSOR FOR SELECT NULL FROM DUAL;
      p_LABEL := NULL;
   END IF;
END BACKCAST_SCHEDULE_LIST;

PROCEDURE SCHEDULE_DELETE_LIST
   (
   p_SCHEDULE_CATEGORY IN VARCHAR2,
   p_BEGIN_DATE IN DATE,
   p_END_DATE IN DATE,
   p_CURSOR OUT GA.REFCURSOR,
   p_LABEL OUT VARCHAR2
   ) AS
-- Answer A List Of Forecast/Backcast Transaction Names If The Option Is Enabled, Otherwise Answer Null To Disable The Entity List Widget --
v_TRANSACTIONS IDENT_TABLE;
BEGIN
   IF UPPER(SUBSTR(NVL(GET_DICTIONARY_VALUE(CASE p_SCHEDULE_CATEGORY WHEN c_FORECAST_CATEGORY THEN c_SETTING_FORECAST_DELETE_LIST ELSE c_SETTING_BACKCAST_DELETE_LIST END, c_SYSTEM_SETTING_LIBRARY, c_SYSTEM_SETTING_BOOK, CASE p_SCHEDULE_CATEGORY WHEN c_FORECAST_CATEGORY THEN c_SYSTEM_SETTING_CHAPTER_1 ELSE c_SYSTEM_SETTING_CHAPTER_2 END, c_SYSTEM_SETTING_PAGE), CDI_CONSTANTS.c_YES),1,1)) = CDI_CONSTANTS.c_YES THEN
      v_TRANSACTIONS := CDI_TASK.GET_TRANSACTION_CANDIDATES(CDI_CONSTANTS.c_LOAD_TRANSACTION, CASE WHEN p_SCHEDULE_CATEGORY = c_FORECAST_CATEGORY THEN GA.SCHEDULE_TYPE_FORECAST ELSE CDI_CONSTANTS.c_BACKCAST_SCHEDULE_FAMILY END, p_BEGIN_DATE, p_END_DATE);
      OPEN p_CURSOR FOR
         SELECT IDENT_NAME "TRANSACTION_NAME", IDENT_ID "TRANSACTION_ID" FROM TABLE(CAST(v_TRANSACTIONS AS IDENT_TABLE)) ORDER BY 1;
         p_LABEL := CDI_CONSTANTS.c_SCHEDULE_LIST;
      ELSE
         OPEN p_CURSOR FOR SELECT NULL FROM DUAL;
         p_LABEL := NULL;
      END IF;
END SCHEDULE_DELETE_LIST;

PROCEDURE ACCOUNT_TYPE_LIST(p_CURSOR OUT GA.REFCURSOR, p_LABEL OUT VARCHAR2) AS
-- Answer A List Containing "Aggregate Account" And "Non-Aggregate Account" Entries To Allow The User To Specify The Category Of Account --
BEGIN
   IF UPPER(SUBSTR(NVL(GET_DICTIONARY_VALUE(c_SETTING_ACCOUNT_TYPE_LIST, c_SYSTEM_SETTING_LIBRARY, c_SYSTEM_SETTING_BOOK, c_SYSTEM_SETTING_CHAPTER_2, c_SYSTEM_SETTING_PAGE), CDI_CONSTANTS.c_YES),1,1)) = CDI_CONSTANTS.c_YES THEN
      OPEN p_CURSOR FOR
         SELECT CDI_CONSTANTS.c_AGGREGATE_ACCOUNT "ACCOUNT_TYPE", 1 "ACCOUNT_TYPE_ID" FROM DUAL
         UNION SELECT CDI_CONSTANTS.c_NON_AGGREGATE_ACCOUNT "ACCOUNT_TYPE", 2 "ACCOUNT_TYPE_ID" FROM DUAL
         ORDER BY 1;
      p_LABEL := 'Account Type List';
   ELSE
      OPEN p_CURSOR FOR SELECT NULL FROM DUAL;
      p_LABEL := NULL;
   END IF;
END ACCOUNT_TYPE_LIST;

PROCEDURE EGS_SUPPLIER_LIST
   (
   p_BEGIN_DATE IN DATE,
   p_END_DATE IN DATE,
   p_CURSOR OUT GA.REFCURSOR,
   p_LABEL OUT VARCHAR2
   ) AS
-- Answer A List Of EGS Suppliers That Have Made Modifications To Content For The Time Period --
BEGIN
   IF UPPER(SUBSTR(NVL(GET_DICTIONARY_VALUE(c_SETTING_EGS_SUPPLIER_LIST, c_SYSTEM_SETTING_LIBRARY, c_SYSTEM_SETTING_BOOK, c_SYSTEM_SETTING_CHAPTER_2, c_SYSTEM_SETTING_PAGE), CDI_CONSTANTS.c_YES),1,1)) = CDI_CONSTANTS.c_YES THEN
      OPEN p_CURSOR FOR
         SELECT DISTINCT B.ESP_NAME, A.SUPPLIER_INDEX
         FROM CDI_SUCCESS_ACCOUNT$ A, ENERGY_SERVICE_PROVIDER B
         WHERE EXISTS (SELECT NULL FROM CDI_SUCCESS_FORECAST WHERE SUPPLIER_INDEX = A.SUPPLIER_INDEX AND FORECAST_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE)
            AND B.ESP_ID = A.ESP_ID;
      p_LABEL := 'EGS Supplier List';
   ELSE
      OPEN p_CURSOR FOR SELECT NULL FROM DUAL;
      p_LABEL := NULL;
   END IF;
END EGS_SUPPLIER_LIST;

PROCEDURE SCHEDULE_TYPE_LIST(p_CURSOR OUT GA.REFCURSOR, p_LABEL OUT VARCHAR2) AS
-- Answer A List Containing "SCHEDULE TYPE Entries To Allow The User To Specify --
BEGIN
   OPEN p_CURSOR FOR
      SELECT STATEMENT_TYPE_NAME "SCHEDULE_TYPE_NAME", STATEMENT_TYPE_ID "SCHEDULE_TYPE_ID"
      FROM STATEMENT_TYPE
      WHERE STATEMENT_TYPE_NAME IN ('Preliminary','Mark-to-Market')
      ORDER BY 1;
   p_LABEL := 'Schedule Type List';
END SCHEDULE_TYPE_LIST;

PROCEDURE GET_DEMAND_BID_TRANSACTIONS
   (
   p_BEGIN_DATE IN DATE,
   p_END_DATE IN DATE,
   p_ENTITY_ID_COLLECTION IN NUMBER_COLLECTION,
   p_TRANSACTIONS_CSV IN OUT NOCOPY VARCHAR2,
   p_TRANSACTIONS IN OUT NOCOPY IDENT_TABLE
   ) AS
v_PROCEDURE VARCHAR2(32) := 'GET_DEMAND_BID_TRANSACTIONS';
CURSOR c_SELECT_ALL IS
   SELECT TRANSACTION_ID, TRANSACTION_NAME
   FROM INTERCHANGE_TRANSACTION
   WHERE TRANSACTION_TYPE = CDI_CONSTANTS.c_LOAD_TRANSACTION
      AND BEGIN_DATE <= p_END_DATE
      AND END_DATE >= p_BEGIN_DATE
      AND COMMODITY_ID = (SELECT COMMODITY_ID FROM IT_COMMODITY WHERE COMMODITY_NAME = CDI_CONSTANTS.c_DAYAHEAD_ENERGY)
      AND SCHEDULE_GROUP_ID = (SELECT SCHEDULE_GROUP_ID FROM SCHEDULE_GROUP WHERE SCHEDULE_GROUP_NAME = CDI_CONSTANTS.c_DEMAND_BID);
CURSOR c_SELECT_SOME IS
   SELECT TRANSACTION_ID, TRANSACTION_NAME
   FROM INTERCHANGE_TRANSACTION
   WHERE TRANSACTION_ID IN (SELECT * FROM TABLE(CAST(p_ENTITY_ID_COLLECTION AS NUMBER_COLLECTION)));
BEGIN
   p_TRANSACTIONS_CSV := '';
   p_TRANSACTIONS.DELETE;
   IF p_ENTITY_ID_COLLECTION.COUNT = 0 THEN
      FOR v_SELECT IN c_SELECT_ALL LOOP
         p_TRANSACTIONS_CSV := p_TRANSACTIONS_CSV || TO_CHAR(v_SELECT.TRANSACTION_ID) || CDI_CONSTANTS.c_COMMA;
         p_TRANSACTIONS.EXTEND;
         p_TRANSACTIONS(p_TRANSACTIONS.COUNT) := IDENT_TYPE(v_SELECT.TRANSACTION_ID, v_SELECT.TRANSACTION_NAME);
         LOGS.LOG_DEBUG('Name: ' || v_SELECT.TRANSACTION_NAME || ', Id: ' || TO_CHAR(v_SELECT.TRANSACTION_ID), v_PROCEDURE, CDI_CONSTANTS.c_MESSAGE, c_PACKAGE);
      END LOOP;
   ELSE
      FOR v_SELECT IN c_SELECT_SOME LOOP
         p_TRANSACTIONS_CSV := p_TRANSACTIONS_CSV || TO_CHAR(v_SELECT.TRANSACTION_ID) || CDI_CONSTANTS.c_COMMA;
         p_TRANSACTIONS.EXTEND;
         p_TRANSACTIONS(p_TRANSACTIONS.COUNT) := IDENT_TYPE(v_SELECT.TRANSACTION_ID, v_SELECT.TRANSACTION_NAME);
         LOGS.LOG_DEBUG('Name: ' || v_SELECT.TRANSACTION_NAME || ', Id: ' || TO_CHAR(v_SELECT.TRANSACTION_ID), v_PROCEDURE, CDI_CONSTANTS.c_MESSAGE, c_PACKAGE);
      END LOOP;
   END IF;
   p_TRANSACTIONS_CSV := RTRIM(p_TRANSACTIONS_CSV, CDI_CONSTANTS.c_COMMA);
   LOGS.LOG_DEBUG('Transaction Count: ' || TO_CHAR(p_TRANSACTIONS.COUNT), v_PROCEDURE, CDI_CONSTANTS.c_MESSAGE, c_PACKAGE);
   LOGS.LOG_DEBUG('Trasnsaction Csv: ' || p_TRANSACTIONS_CSV, v_PROCEDURE, CDI_CONSTANTS.c_MESSAGE, c_PACKAGE);
END GET_DEMAND_BID_TRANSACTIONS;

PROCEDURE DELETE_TRANSACTION_SCHEDULES
   (
   p_SCHEDULE_CATEGORY IN VARCHAR2,
   p_BEGIN_DATE IN DATE,
   p_END_DATE IN DATE,
   p_ENTITY_ID_COLLECTION IN NUMBER_COLLECTION,
   p_TRACE_ON IN NUMBER,
   p_MESSAGE OUT VARCHAR2
   ) AS
v_PROCEDURE VARCHAR2(32) := 'DELETE_TRANSACTION_SCHEDULES';
v_IDENT_TABLE IDENT_TABLE;
BEGIN
   LOGS.START_PROCESS('Delete Transaction Schedules', p_BEGIN_DATE, p_END_DATE, p_EVENT_LEVEL => CASE WHEN p_TRACE_ON > 0 THEN LOGS.c_LEVEL_DEBUG ELSE NULL END);
   LOGS.LOG_INFO('Delete ' || p_SCHEDULE_CATEGORY || ' Schedules For Time Period: ' || TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE) || ' - ' || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE) || ', Entity Collection Count: ' || TO_CHAR(p_ENTITY_ID_COLLECTION.COUNT), v_PROCEDURE, CDI_CONSTANTS.c_MESSAGE, c_PACKAGE);
   IF p_ENTITY_ID_COLLECTION.COUNT = 0 THEN
      CDI_TASK.DELETE_LOAD_SCHEDULES(CASE WHEN p_SCHEDULE_CATEGORY = c_FORECAST_CATEGORY THEN GA.SCHEDULE_TYPE_FORECAST ELSE CDI_CONSTANTS.c_BACKCAST_SCHEDULE_FAMILY END, p_BEGIN_DATE, p_END_DATE);
   ELSE
      SELECT IDENT_TYPE(TRANSACTION_ID, TRANSACTION_NAME)
      BULK COLLECT INTO v_IDENT_TABLE
      FROM INTERCHANGE_TRANSACTION
      WHERE TRANSACTION_ID IN (SELECT * FROM TABLE(CAST(p_ENTITY_ID_COLLECTION AS NUMBER_COLLECTION)));
      CDI_TASK.DELETE_LOAD_SCHEDULES(CASE WHEN p_SCHEDULE_CATEGORY = c_FORECAST_CATEGORY THEN GA.SCHEDULE_TYPE_FORECAST ELSE CDI_CONSTANTS.c_BACKCAST_SCHEDULE_FAMILY END, p_BEGIN_DATE, p_END_DATE, v_IDENT_TABLE);
   END IF;
   p_MESSAGE := 'Delete ' || p_SCHEDULE_CATEGORY || ' Schedules Complete.';
   COMMIT;
   STOP_PROCESS;
EXCEPTION
   WHEN OTHERS THEN
      p_MESSAGE := FORMAT_EXCEPTION_MESSAGE(DBMS_UTILITY.FORMAT_ERROR_STACK);
      ROLLBACK;
      ERRS.ABORT_PROCESS;
END DELETE_TRANSACTION_SCHEDULES;

PROCEDURE IMPORT_WEATHER
   (
   p_TRACE_ON IN NUMBER,
   p_MESSAGE OUT VARCHAR2
   ) AS
v_PROCEDURE VARCHAR2(32) := 'IMPORT_WEATHER';
-- Invoke The IDR Processes To Retrieve Current Published Weather From The Service Provider And Import Into RetailOffice Data Structures --
-- Note That The IDR Schema Must Grant The Execute Privilege On The IDR Procedures To The RetailOffice Schema --
BEGIN
   LOGS.START_PROCESS('Import Weather', p_EVENT_LEVEL => CASE WHEN p_TRACE_ON > 0 THEN LOGS.c_LEVEL_DEBUG ELSE NULL END);
-- Execute The Weather Interface --
   LOGS.LOG_INFO('Download Weather From Ftp Site.', v_PROCEDURE, CDI_CONSTANTS.c_MESSAGE, c_PACKAGE);
   IDR.WEATHER_INTERFACE_POST_2010.GET_WEATHER_FROM_FTP;
   LOGS.LOG_INFO('Download Weather Complete.', v_PROCEDURE, CDI_CONSTANTS.c_MESSAGE, c_PACKAGE);
   LOGS.LOG_INFO('Synchronize Weather With RetailOffice.', v_PROCEDURE, CDI_CONSTANTS.c_MESSAGE, c_PACKAGE);
   IDR.RO_SYNCH225.SYNCH_WEATHER_POST_2010;
   LOGS.LOG_INFO('Synchronize Weather Complete.', v_PROCEDURE, CDI_CONSTANTS.c_MESSAGE, c_PACKAGE);
   p_MESSAGE := 'Weather Import Complete. See "IDR" Process Log For Details.';
   COMMIT;
   STOP_PROCESS;
EXCEPTION
   WHEN OTHERS THEN
      p_MESSAGE := FORMAT_EXCEPTION_MESSAGE(DBMS_UTILITY.FORMAT_ERROR_STACK);
      ROLLBACK;
      ERRS.ABORT_PROCESS;
END IMPORT_WEATHER;

PROCEDURE EXPORT_BACKCAST_TO_SUCCESS
   (
   p_BEGIN_DATE IN DATE,
   p_END_DATE IN DATE,
   p_ENTITY_ID_COLLECTION IN NUMBER_COLLECTION,
   p_TRACE_ON IN NUMBER,
   p_MESSAGE OUT VARCHAR2
   ) AS
-- Entity Collection Can Contain: 1-"Aggregate Account" And 2-"Non-Aggregate Account" Entries To Allow The User To Specify The Category Of Account To Export --
v_PROCEDURE VARCHAR2(32) := 'EXPORT_BACKCAST_TO_SUCCESS';
v_ACCOUNT_TYPE VARCHAR2(32);
v_AGGREGATE_RECORDS_EXPORTED PLS_INTEGER;
v_ACCOUNT_RECORDS_EXPORTED PLS_INTEGER;
BEGIN
   LOGS.START_PROCESS('Export Backcast To SUCCESS', p_BEGIN_DATE, p_END_DATE, p_EVENT_LEVEL => CASE WHEN p_TRACE_ON > 0 THEN LOGS.c_LEVEL_DEBUG ELSE NULL END);
   v_ACCOUNT_TYPE := CASE WHEN p_ENTITY_ID_COLLECTION.COUNT IN (0,2) THEN CONSTANTS.ALL_STRING ELSE CASE WHEN p_ENTITY_ID_COLLECTION(1) = 1 THEN CDI_CONSTANTS.c_AGGREGATE_ACCOUNT ELSE CDI_CONSTANTS.c_NON_AGGREGATE_ACCOUNT END END;
   LOGS.LOG_INFO('Export Backcast For Account Type: ' || v_ACCOUNT_TYPE || ', Time Period: ' || TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE) || ' - ' || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE), v_PROCEDURE, CDI_CONSTANTS.c_MESSAGE, c_PACKAGE);
   CDI_TASK.EXPORT_BACKCAST_TO_SUCCESS(v_ACCOUNT_TYPE, p_BEGIN_DATE, p_END_DATE, v_AGGREGATE_RECORDS_EXPORTED, v_ACCOUNT_RECORDS_EXPORTED);
   p_MESSAGE := 'Export Backcast Complete.' || c_CRLF || '  Aggregate Account Records Exported: ' || TO_CHAR(v_AGGREGATE_RECORDS_EXPORTED) || '.' || c_CRLF || '  Non-Aggregate Account Records Exported: ' || TO_CHAR(v_ACCOUNT_RECORDS_EXPORTED) || '.';
   COMMIT;
   STOP_PROCESS;
EXCEPTION
   WHEN OTHERS THEN
      p_MESSAGE := FORMAT_EXCEPTION_MESSAGE(DBMS_UTILITY.FORMAT_ERROR_STACK);
      ROLLBACK;
      ERRS.ABORT_PROCESS;
END EXPORT_BACKCAST_TO_SUCCESS;

PROCEDURE IMPORT_BACKCAST_FROM_SUCCESS
   (
   p_BEGIN_DATE IN DATE,
   p_END_DATE IN DATE,
   p_ENTITY_ID_COLLECTION IN NUMBER_COLLECTION,
   p_TRACE_ON IN NUMBER,
   p_MESSAGE OUT VARCHAR2
   ) AS
v_PROCEDURE VARCHAR2(32) := 'IMPORT_BACKCAST_FROM_SUCCESS';
v_RECORDS_IMPORTED PLS_INTEGER;
v_ANOMALY_COUNT PLS_INTEGER;
BEGIN
   LOGS.START_PROCESS('Import Backcast From SUCCESS', p_BEGIN_DATE, p_END_DATE, p_EVENT_LEVEL => CASE WHEN p_TRACE_ON > 0 THEN LOGS.c_LEVEL_DEBUG ELSE NULL END);
   LOGS.LOG_INFO('Import Backcast For Time Period: ' || TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE) || ' - ' || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE), v_PROCEDURE, CDI_CONSTANTS.c_MESSAGE, c_PACKAGE);
   CDI_TASK.IMPORT_BACKCAST_FROM_SUCCESS(p_BEGIN_DATE, p_END_DATE, p_ENTITY_ID_COLLECTION, p_TRACE_ON, v_RECORDS_IMPORTED, v_ANOMALY_COUNT);
   p_MESSAGE := CASE WHEN v_ANOMALY_COUNT > 0 THEN 'Number Of Non-Aggregate Account Anomalies Detected: ' || TO_CHAR(v_ANOMALY_COUNT) ELSE 'Import Backcast Complete. Number Of Records Imported: ' || TO_CHAR(v_RECORDS_IMPORTED) END || '.';
   COMMIT;
   STOP_PROCESS;
EXCEPTION
   WHEN OTHERS THEN
      p_MESSAGE := FORMAT_EXCEPTION_MESSAGE(DBMS_UTILITY.FORMAT_ERROR_STACK);
      ROLLBACK;
      ERRS.ABORT_PROCESS;
END IMPORT_BACKCAST_FROM_SUCCESS;

PROCEDURE ALLOCATE_UFE_ACCEPT_BACKCAST
   (
   p_BEGIN_DATE IN DATE,
   p_END_DATE IN DATE,
   p_TRACE_ON IN NUMBER,
   p_MESSAGE OUT VARCHAR2
   ) AS
v_PROCEDURE VARCHAR2(32) := 'ALLOCATE_UFE_ACCEPT_BACKCAST';
BEGIN
   LOGS.START_PROCESS('Allocate UFE And Accept Backcast', p_BEGIN_DATE, p_END_DATE, p_EVENT_LEVEL => CASE WHEN p_TRACE_ON > 0 THEN LOGS.c_LEVEL_DEBUG ELSE NULL END);
   LOGS.LOG_INFO('Allocate UFE And Accept Backcast For Time Period: ' || TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE) || ' - ' || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE), v_PROCEDURE, CDI_CONSTANTS.c_MESSAGE, c_PACKAGE);
   CDI_TASK.ALLOCATE_UFE_ACCEPT_BACKCAST(p_BEGIN_DATE, p_END_DATE, p_TRACE_ON);
   p_MESSAGE := 'Allocate UFE And Accept Backcast Complete.' || INITCAP(LOGS.GET_FINISH_MESSAGE);
   COMMIT;
   STOP_PROCESS;
EXCEPTION
   WHEN OTHERS THEN
      p_MESSAGE := FORMAT_EXCEPTION_MESSAGE(DBMS_UTILITY.FORMAT_ERROR_STACK);
      ROLLBACK;
      ERRS.ABORT_PROCESS;
END ALLOCATE_UFE_ACCEPT_BACKCAST;

PROCEDURE EXPORT_BACKCAST_UFE_TO_SUCCESS
   (
   p_BEGIN_DATE IN DATE,
   p_END_DATE IN DATE,
   p_TRACE_ON IN NUMBER,
   p_MESSAGE OUT VARCHAR2
   ) AS
v_PROCEDURE VARCHAR2(32) := 'EXPORT_BACKCAST_UFE_TO_SUCCESS';
v_RECORDS_EXPORTED PLS_INTEGER;
BEGIN
   LOGS.START_PROCESS('Export Backcast UFE To SUCCESS', p_BEGIN_DATE, p_END_DATE, p_EVENT_LEVEL => CASE WHEN p_TRACE_ON > 0 THEN LOGS.c_LEVEL_DEBUG ELSE NULL END);
   LOGS.LOG_INFO('Export Backcast UFE For Time Period: ' || TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE) || ' - ' || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE), v_PROCEDURE, CDI_CONSTANTS.c_MESSAGE, c_PACKAGE);
   CDI_TASK.EXPORT_BACKCAST_UFE_TO_SUCCESS(p_BEGIN_DATE, p_END_DATE, v_RECORDS_EXPORTED);
   p_MESSAGE := 'Export Backcast UFE Complete. Number Of Records Exported: ' || TO_CHAR(v_RECORDS_EXPORTED) || '.';
   COMMIT;
   STOP_PROCESS;
EXCEPTION
   WHEN OTHERS THEN
      p_MESSAGE := FORMAT_EXCEPTION_MESSAGE(DBMS_UTILITY.FORMAT_ERROR_STACK);
      ROLLBACK;
      ERRS.ABORT_PROCESS;
END EXPORT_BACKCAST_UFE_TO_SUCCESS;

PROCEDURE GET_BACKCAST_TRANSACTIONS
   (
   p_BEGIN_DATE IN DATE,
   p_END_DATE IN DATE,
   p_ENTITY_ID_COLLECTION IN NUMBER_COLLECTION,
   p_TRANSACTIONS_CSV IN OUT NOCOPY VARCHAR2,
   p_TRANSACTIONS IN OUT NOCOPY IDENT_TABLE
   ) AS
v_PROCEDURE VARCHAR2(32) := 'GET_BACKCAST_TRANSACTIONS';
CURSOR c_SELECT_ALL IS
   SELECT TRANSACTION_ID, TRANSACTION_NAME
   FROM INTERCHANGE_TRANSACTION
   WHERE TRANSACTION_TYPE = CDI_CONSTANTS.c_LOAD_TRANSACTION
      AND BEGIN_DATE <= p_END_DATE
      AND END_DATE >= p_BEGIN_DATE
      AND COMMODITY_ID = (SELECT COMMODITY_ID FROM IT_COMMODITY WHERE COMMODITY_NAME = CDI_CONSTANTS.c_ENERGY)
      AND SCHEDULE_GROUP_ID = (SELECT SCHEDULE_GROUP_ID FROM SCHEDULE_GROUP WHERE SCHEDULE_GROUP_NAME = CDI_CONSTANTS.c_DEMAND_BID); --??????????????????????????????????--
CURSOR c_SELECT_SOME IS
   SELECT TRANSACTION_ID, TRANSACTION_NAME
   FROM INTERCHANGE_TRANSACTION
   WHERE TRANSACTION_ID IN (SELECT * FROM TABLE(CAST(p_ENTITY_ID_COLLECTION AS NUMBER_COLLECTION)));
BEGIN
   p_TRANSACTIONS_CSV := '';
   p_TRANSACTIONS.DELETE;
   IF p_ENTITY_ID_COLLECTION.COUNT = 0 THEN
      FOR v_SELECT IN c_SELECT_ALL LOOP
         p_TRANSACTIONS_CSV := p_TRANSACTIONS_CSV || TO_CHAR(v_SELECT.TRANSACTION_ID) || CDI_CONSTANTS.c_COMMA;
         p_TRANSACTIONS.EXTEND;
         p_TRANSACTIONS(p_TRANSACTIONS.COUNT) := IDENT_TYPE(v_SELECT.TRANSACTION_ID, v_SELECT.TRANSACTION_NAME);
         LOGS.LOG_DEBUG('Name: ' || v_SELECT.TRANSACTION_NAME || ', Id: ' || TO_CHAR(v_SELECT.TRANSACTION_ID), v_PROCEDURE, CDI_CONSTANTS.c_MESSAGE, c_PACKAGE);
      END LOOP;
   ELSE
      FOR v_SELECT IN c_SELECT_SOME LOOP
         p_TRANSACTIONS_CSV := p_TRANSACTIONS_CSV || TO_CHAR(v_SELECT.TRANSACTION_ID) || CDI_CONSTANTS.c_COMMA;
         p_TRANSACTIONS.EXTEND;
         p_TRANSACTIONS(p_TRANSACTIONS.COUNT) := IDENT_TYPE(v_SELECT.TRANSACTION_ID, v_SELECT.TRANSACTION_NAME);
         LOGS.LOG_DEBUG('Name: ' || v_SELECT.TRANSACTION_NAME || ', Id: ' || TO_CHAR(v_SELECT.TRANSACTION_ID), v_PROCEDURE, CDI_CONSTANTS.c_MESSAGE, c_PACKAGE);
      END LOOP;
   END IF;
   p_TRANSACTIONS_CSV := RTRIM(p_TRANSACTIONS_CSV, CDI_CONSTANTS.c_COMMA);
   LOGS.LOG_DEBUG('Transaction Count: ' || TO_CHAR(p_TRANSACTIONS.COUNT), v_PROCEDURE, CDI_CONSTANTS.c_MESSAGE, c_PACKAGE);
   LOGS.LOG_DEBUG('Transaction Csv: ' || p_TRANSACTIONS_CSV, v_PROCEDURE, CDI_CONSTANTS.c_MESSAGE, c_PACKAGE);
END GET_BACKCAST_TRANSACTIONS;

PROCEDURE ACCEPT_ANCILLARY_SCHEDULE
   (
   p_BEGIN_DATE IN DATE,
   p_END_DATE IN DATE,
   p_TRACE_ON IN NUMBER,
   p_MESSAGE OUT VARCHAR2
   ) AS
v_PROCEDURE VARCHAR2(32) := 'ACCEPT_ANCILLARY_SCHEDULE';
BEGIN
   LOGS.START_PROCESS('Accept PLC/NSPL Schedules', p_BEGIN_DATE, p_END_DATE, p_EVENT_LEVEL => CASE WHEN p_TRACE_ON > 0 THEN LOGS.c_LEVEL_DEBUG ELSE NULL END);
   LOGS.LOG_INFO('Accept PLC/NSPL Schedules For Time Period: ' || TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE) || ' - ' || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE), v_PROCEDURE, CDI_CONSTANTS.c_MESSAGE, c_PACKAGE);
-- Invoke Core Market Interface Functionality --
-- Use: FS.AGGREGATE_ANC_SVC(p_ANCILLARY_SERVICE_ID,p_BEGIN_DATE,p_END_DATE,p_TIME_ZONE) --
-- Use: RS.ACCEPT_ANC_SVC_INTO_SCHEDULES(p_ANCILLARY_SERVICE_ID,p_BEGIN_DATE,p_END_DATE,p_TIME_ZONE,p_SCHEDULE_TYPE);
   LOGS.LOG_INFO('PLC Ancillary Service Id: ' || TO_CHAR(CDI_CONSTANTS.PEAK_LOAD_CAPACITY), v_PROCEDURE, CDI_CONSTANTS.c_MESSAGE, c_PACKAGE);
   FS.AGGREGATE_ANC_SVC(CDI_CONSTANTS.PEAK_LOAD_CAPACITY, p_BEGIN_DATE, p_END_DATE, CDI_CONSTANTS.c_LOCAL_TIME_ZONE);
   RS.ACCEPT_ANC_SVC_INTO_SCHEDULES(CDI_CONSTANTS.PEAK_LOAD_CAPACITY, p_BEGIN_DATE, p_END_DATE, CDI_CONSTANTS.c_LOCAL_TIME_ZONE, CONSTANTS.SCHEDULE_TYPE_FINAL);
   LOGS.LOG_INFO('NSPL Ancillary Service Id: ' || TO_CHAR(CDI_CONSTANTS.NETWORK_SERVICE_PEAK_LOAD), v_PROCEDURE, CDI_CONSTANTS.c_MESSAGE, c_PACKAGE);
   FS.AGGREGATE_ANC_SVC(CDI_CONSTANTS.NETWORK_SERVICE_PEAK_LOAD, p_BEGIN_DATE, p_END_DATE, CDI_CONSTANTS.c_LOCAL_TIME_ZONE);
   RS.ACCEPT_ANC_SVC_INTO_SCHEDULES(CDI_CONSTANTS.NETWORK_SERVICE_PEAK_LOAD, p_BEGIN_DATE, p_END_DATE, CDI_CONSTANTS.c_LOCAL_TIME_ZONE, CONSTANTS.SCHEDULE_TYPE_FINAL);
-- Invoke The PLC Post-Processing Allocations --
   CDI_PLC_NSPL.ROUND_EGS_PLC(p_BEGIN_DATE, p_END_DATE, p_TRACE_ON, l_STATUS, l_MESSAGE);
   ERRS.VALIDATE_STATUS('CDI_PLC_NSPL.ROUND_EGS_PLC', l_STATUS, p_MESSAGE);
   CDI_TASK.EXECUTE_CALCULATION_PROCESS(CDI_CONSTANTS.c_ALLOCATE_TO_PLC_CALC, CONSTANTS.SCHEDULE_TYPE_FINAL, p_BEGIN_DATE, p_END_DATE, p_TRACE_ON);
-- Invoke The NSPL Post-Processing Allocations --
   CDI_PLC_NSPL.SCALE_NSPL(p_BEGIN_DATE, p_END_DATE, p_TRACE_ON, l_STATUS, l_MESSAGE);
   ERRS.VALIDATE_STATUS('CDI_PLC_NSPL.SCALE_NSPL', l_STATUS, p_MESSAGE);
   CDI_TASK.EXECUTE_CALCULATION_PROCESS(CDI_CONSTANTS.c_ALLOCATE_TO_NSPL_CALC, CONSTANTS.SCHEDULE_TYPE_FINAL, p_BEGIN_DATE, p_END_DATE, p_TRACE_ON);
   p_MESSAGE := 'Accept PLC/NSPL Schedules Complete.' || INITCAP(LOGS.GET_FINISH_MESSAGE);
   STOP_PROCESS;
EXCEPTION
   WHEN OTHERS THEN
      p_MESSAGE := FORMAT_EXCEPTION_MESSAGE(DBMS_UTILITY.FORMAT_ERROR_STACK);
      ROLLBACK;
      ERRS.ABORT_PROCESS;
END ACCEPT_ANCILLARY_SCHEDULE;

PROCEDURE ACCEPT_MARK_TO_MARKET_SCHEDULE
   (
   p_BEGIN_DATE IN DATE,
   p_END_DATE IN DATE,
   p_TRACE_ON IN NUMBER,
   p_MESSAGE OUT VARCHAR2
   ) AS
v_PROCEDURE VARCHAR2(32) := 'ACCEPT_MARK_TO_MARKET_SCHEDULE';
BEGIN
   LOGS.START_PROCESS('Accept Mark-To-Market Schedules', p_BEGIN_DATE, p_END_DATE, p_EVENT_LEVEL => CASE WHEN p_TRACE_ON > 0 THEN LOGS.c_LEVEL_DEBUG ELSE NULL END);
   LOGS.LOG_INFO('Accept Mark-To-Market Schedules For Time Period: ' || TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE) || ' - ' || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE), v_PROCEDURE, CDI_CONSTANTS.c_MESSAGE, c_PACKAGE);
   CDI_TASK.ACCEPT_MARK_TO_MARKET_SCHEDULE(p_BEGIN_DATE, p_END_DATE, p_TRACE_ON);
   p_MESSAGE := 'Accept Mark-To-Market Schedules Complete.';
   COMMIT;
   STOP_PROCESS;
EXCEPTION
   WHEN OTHERS THEN
      p_MESSAGE := FORMAT_EXCEPTION_MESSAGE(DBMS_UTILITY.FORMAT_ERROR_STACK);
      ROLLBACK;
      ERRS.ABORT_PROCESS;
END ACCEPT_MARK_TO_MARKET_SCHEDULE;

PROCEDURE IMPORT_SYSTEM_LOAD
   (
   p_BEGIN_DATE IN DATE,
   p_END_DATE IN DATE,
   p_TRACE_ON IN NUMBER,
   p_MESSAGE OUT VARCHAR2
   ) AS
v_PROCEDURE VARCHAR2(32) := 'IMPORT_SYSTEM_LOAD';
v_LOG_ONLY NUMBER(1) := 1;
v_LOG_TYPE NUMBER(1) := NULL;
v_TRANSACTIONS_CSV VARCHAR2(4000);
BEGIN
   LOGS.LOG_INFO('Import System Load Schedule For Time Period: ' || TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE) || ' - ' || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE), v_PROCEDURE, CDI_CONSTANTS.c_MESSAGE, c_PACKAGE);
-- Invoke Core Market Interface Functionality --
-- Use: MM_PJM_EMTR.MARKET_EXCHANGE(p_BEGIN_DATE,p_END_DATE,p_EXCHANGE_TYPE,p_ENTITY_LIST,p_ENTITY_LIST_DELIMITER,p_LOG_ONLY,p_LOG_TYPE,p_TRACE_ON,p_STATUS,p_MESSAGE);
   MM_PJM_EMTR.MARKET_EXCHANGE(p_BEGIN_DATE, p_END_DATE, MM_PJM_EMTR.g_ET_QUERY_LOAD_W_LOSSES, v_TRANSACTIONS_CSV, CDI_CONSTANTS.c_COMMA, v_LOG_ONLY, v_LOG_TYPE, p_TRACE_ON, l_STATUS, p_MESSAGE);
   ERRS.VALIDATE_STATUS('MM_PJM_EMTR.MARKET_EXCHANGE', l_STATUS, p_MESSAGE);
   p_MESSAGE := 'Import System Load Schedule Complete, ' || INITCAP(p_MESSAGE);
EXCEPTION
   WHEN OTHERS THEN
      p_MESSAGE := FORMAT_EXCEPTION_MESSAGE(DBMS_UTILITY.FORMAT_ERROR_STACK);
END IMPORT_SYSTEM_LOAD;

PROCEDURE IMPORT_POWERMETER_SYSTEM_LOAD
   (
   p_BEGIN_DATE IN DATE,
   p_END_DATE IN DATE,
   p_TRACE_ON IN NUMBER,
   p_MESSAGE OUT VARCHAR2
   ) AS
v_PROCEDURE VARCHAR2(32) := 'IMPORT_POWERMETER_SYSTEM_LOAD';
v_LOG_ONLY NUMBER(1) := 1;
v_LOG_TYPE NUMBER(1) := NULL;
BEGIN
   LOGS.LOG_INFO('Import System Load Schedule For Time Period: ' || TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE) || ' - ' || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE), v_PROCEDURE, CDI_CONSTANTS.c_MESSAGE, c_PACKAGE);
-- Invoke Core Market Interface Functionality --
-- Use: MM_PJM_POWERMETER.QUERY_POWERMETER(p_BEGIN_DATE,p_END_DATE,p_EXCHANGE_TYPE,p_LOG_ONLY,p_LOG_TYPE,p_TRACE_ON,p_STATUS,p_MESSAGE);
   MM_PJM_POWERMETER.QUERY_POWERMETER(p_BEGIN_DATE, p_END_DATE, MM_PJM_EMTR.g_ET_QUERY_LOAD_W_LOSSES, v_LOG_ONLY, v_LOG_TYPE, p_TRACE_ON, l_STATUS, p_MESSAGE);
   ERRS.VALIDATE_STATUS('MM_PJM_POWERMETER.QUERY_POWERMETER', l_STATUS, p_MESSAGE);
   p_MESSAGE := 'Import Power Meter System Load Schedule Complete, ' || INITCAP(p_MESSAGE);
EXCEPTION
   WHEN OTHERS THEN
      p_MESSAGE := FORMAT_EXCEPTION_MESSAGE(DBMS_UTILITY.FORMAT_ERROR_STACK);
END IMPORT_POWERMETER_SYSTEM_LOAD;

END CDI_DEX;
/
