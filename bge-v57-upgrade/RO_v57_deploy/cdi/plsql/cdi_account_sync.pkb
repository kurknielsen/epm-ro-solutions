CREATE OR REPLACE PACKAGE BODY CDI_ACCOUNT_SYNC AS

c_PACKAGE_NAME                 CONSTANT VARCHAR2(32) := 'CDI_ACCOUNT_SYNC';
c_SYSTEM_SETTING_MODULE        CONSTANT VARCHAR2(32) := 'Client Data Interface';
c_SYSTEM_SETTING_KEY1          CONSTANT VARCHAR2(32) := 'Data Import';
c_SYSTEM_SETTING_KEY2          CONSTANT VARCHAR2(32) := 'Account Sync';
c_ACCOUNT_SYNC_PROCESS         CONSTANT VARCHAR2(32) := 'CDI: Account Sync';
c_ACCOUNT_MODEL_OPTION         CONSTANT VARCHAR2(16) := 'Account';
c_AGGREGATE_MODEL_OPTION       CONSTANT VARCHAR2(16) := 'Aggregate';
c_INTERVAL_ACCOUNT_METER_TYPE  CONSTANT VARCHAR2(16) := 'Interval';
c_PERIOD_ACCOUNT_METER_TYPE    CONSTANT VARCHAR2(16) := 'Period';
c_CALENDAR_TYPE_FORECAST       CONSTANT VARCHAR2(16) := 'Forecast';
c_CALENDAR_TYPE_BACKCAST       CONSTANT VARCHAR2(16) := 'Backcast';
c_DATE_FORMAT                  CONSTANT VARCHAR2(16) := 'MM/DD/YYYY';
c_DEFAULT_PLC_BAND             CONSTANT CHAR(1)      := 'Z';
c_MIN_I_ACCOUNTS               CONSTANT NUMBER       := 1;
c_MIN_A_ACCOUNTS               CONSTANT NUMBER       := 0;
c_INSTALLED_CAPACITY           CONSTANT VARCHAR2(16) := 'ICAP';
c_NETWORK_SERVICE              CONSTANT VARCHAR2(16) := 'Network Service';

l_ACCOUNT_ASSIGN_SYNC_LIST     CDI_ACCOUNT_ASSIGN_SYNC_LIST;
l_USAGE_FACTOR_LOOKUP_MONTHS   PLS_INTEGER := 3;
 
PROCEDURE GATHER_TABLE_STATS(p_TABLE_NAME IN VARCHAR2) IS
BEGIN
   DBMS_STATS.GATHER_TABLE_STATS(OWNNAME => USER, TABNAME => p_TABLE_NAME, ESTIMATE_PERCENT => DBMS_STATS.AUTO_SAMPLE_SIZE, BLOCK_SAMPLE => TRUE, DEGREE => NULL, CASCADE => TRUE);
END GATHER_TABLE_STATS;

PROCEDURE CLEAR_STAGING_AREA IS
BEGIN
   EXECUTE IMMEDIATE 'TRUNCATE TABLE CDI_MAIN';
   EXECUTE IMMEDIATE 'TRUNCATE TABLE CDI_INDIVIDUAL_ACCOUNT_NEW';
   EXECUTE IMMEDIATE 'TRUNCATE TABLE CDI_PLC_NSPL_CACHE';
   EXECUTE IMMEDIATE 'TRUNCATE TABLE CDI_USAGE_FACTOR_CACHE';
   EXECUTE IMMEDIATE 'TRUNCATE TABLE CDI_AGGREGATE_ACCOUNTS';
   EXECUTE IMMEDIATE 'TRUNCATE TABLE CDI_PLC_NSPL_CACHE';
   EXECUTE IMMEDIATE 'TRUNCATE TABLE CDI_AGGREGATE_SERVICE_CACHE';
END CLEAR_STAGING_AREA;

PROCEDURE STAGE_CONTENT(p_FROM_DATE IN DATE, p_TO_DATE IN DATE) AS
v_MARK_TIME PLS_INTEGER := DBMS_UTILITY.GET_TIME;
BEGIN

   CLEAR_STAGING_AREA;
   INSERT /*+ APPEND */ INTO CDI_MAIN (BILL_ACCOUNT, SERVICE_POINT, PREMISE_NUMBER, TARIFF_CODE, NODE, POLR_TYPE, SUPPLIER, CITY_COUNTY, EFFECT_DATE, TERM_DATE, SPECIAL_NOTATION, STATUS_INDICATION, BGE_TIMESTAMP, TIME_STAMP, IDR_STATUS, RTO_POOL_ID, PLC_BAND, RTO_ACCOUNT_ID, ESP_ID, METER_TYPE, VOLTAGE_LEVEL, RATE_CLASS, ACCOUNT_METER_EXT_IDENTIFIER, IS_ALM, IS_TOU, REPORTED_SEGMENT)
   SELECT BILL_ACCOUNT, SERVICE_POINT, PREMISE_NUMBER, TARIFF_CODE, NODE, TRIM(POLR_TYPE) POLR_TYPE, SUPPLIER, CITY_COUNTY_CODE, GREATEST(EFFECTIVE_DATE, p_FROM_DATE) "EFFECT_DATE", LEAST(NVL(TERMINATION_DATE, CONSTANTS.HIGH_DATE), p_TO_DATE) "TERM_DATE", NULL "SPECIAL_NOTATION", STATUS_INDICATION, GREATEST(EFFECTIVE_DATE, p_FROM_DATE) AS AGG_BEGIN_DATE, LEAST(NVL(TERMINATION_DATE, CONSTANTS.HIGH_DATE), p_TO_DATE) AS AGG_END_DATE, IDR_STATUS, RTRIM(RTRIM(RTRIM(RTRIM(RTO_POOL_ID,'_EMPTY'),'_CABLEDEVICE'),'_IDSALES'),'_MTR_CHANGE') || '_' || c_DEFAULT_PLC_BAND "RTO_POOL_ID", c_DEFAULT_PLC_BAND "PLC_BAND", AGGR_IDENTIFIER, ESP_ID, METER_TYPE, VOLTAGE_LEVEL, RATE_CLASS, STUDY_ID, NULL, NULL, REPORTED_SEGMENT
   FROM BGE_MASTER_ACCOUNT
   WHERE EFFECTIVE_DATE <= p_TO_DATE
      AND TERMINATION_DATE >= p_FROM_DATE;
   LOGS.LOG_INFO('Number Of Records Posted To The CDI_MAIN Table: ' || TO_CHAR(SQL%ROWCOUNT));
   GATHER_TABLE_STATS('CDI_MAIN');

   INSERT /*+ APPEND */ INTO CDI_INDIVIDUAL_ACCOUNT_NEW(BILL_ACCOUNT, SUPPLIER, BEGIN_DATE, END_DATE, IDR_STATUS, RTO_POOL_ID, PLC_BAND, RTO_ACCOUNT_IDENTIFIER, ESP_ID, METER_TYPE, VOLTAGE_LEVEL, RATE_CLASS, ACCOUNT_METER_EXT_IDENTIFIER, USAGE_VAL)
   SELECT BILL_ACCOUNT, SUPPLIER, EFFECT_DATE, TERM_DATE, IDR_STATUS, TRIM(RTO_POOL_ID), PLC_BAND, RTO_ACCOUNT_ID, ESP_ID, METER_TYPE, VOLTAGE_LEVEL, RATE_CLASS, ACCOUNT_METER_EXT_IDENTIFIER, 0
   FROM CDI_MAIN 
   WHERE IDR_STATUS = 'Y'
   UNION ALL
   SELECT NULL, SUPPLIER, EFFECT_DATE, TERM_DATE, IDR_STATUS, TRIM(RTO_POOL_ID), PLC_BAND, RTO_ACCOUNT_ID, ESP_ID, METER_TYPE, VOLTAGE_LEVEL, RATE_CLASS, ACCOUNT_METER_EXT_IDENTIFIER, 0
   FROM CDI_MAIN
   WHERE IDR_STATUS <> 'Y'
   GROUP BY POLR_TYPE, SUPPLIER, EFFECT_DATE, TERM_DATE, IDR_STATUS, TRIM(RTO_POOL_ID), PLC_BAND, RTO_ACCOUNT_ID, ESP_ID, METER_TYPE , VOLTAGE_LEVEL, RATE_CLASS, ACCOUNT_METER_EXT_IDENTIFIER;
   LOGS.LOG_INFO('Number Of Records Posted To The CDI_INDIVIDUAL_ACCOUNT_NEW Table: ' || TO_CHAR(SQL%ROWCOUNT));
   GATHER_TABLE_STATS('CDI_INDIVIDUAL_ACCOUNT_NEW');
   COMMIT;
   
   SELECT CDI_ACCOUNT_ASSIGN_SYNC_TYPE(RTO_ACCOUNT_IDENTIFIER, 'BGE', TRIM(SUPPLIER), RTO_POOL_ID, CASE WHEN METER_TYPE = 'I' THEN BILL_ACCOUNT ELSE '?' END, NULL, RTO_ACCOUNT_IDENTIFIER, RATE_CLASS, RATE_CLASS, NULL, NULL, CASE WHEN METER_TYPE = 'I' THEN c_INTERVAL_ACCOUNT_METER_TYPE ELSE c_PERIOD_ACCOUNT_METER_TYPE END, 'BWI', BEGIN_DATE, END_DATE)
   BULK COLLECT INTO l_ACCOUNT_ASSIGN_SYNC_LIST
   FROM CDI_INDIVIDUAL_ACCOUNT_NEW
   ORDER BY RTO_ACCOUNT_IDENTIFIER, BEGIN_DATE, END_DATE;
   LOGS.LOG_INFO('Individual Account New Collector Count: ' || TO_CHAR(l_ACCOUNT_ASSIGN_SYNC_LIST.COUNT));
   LOGS.LOG_INFO('Stage Content Elapsed Seconds: ' || TO_CHAR(ROUND((DBMS_UTILITY.GET_TIME-v_MARK_TIME)/100)));

END STAGE_CONTENT;

PROCEDURE SYNC_POOL(p_FROM_DATE IN DATE) AS
v_POOL_SYNC_LIST CDI_POOL_SYNC_LIST;
v_MARK_TIME PLS_INTEGER := DBMS_UTILITY.GET_TIME;
BEGIN
   SELECT CDI_POOL_SYNC_TYPE(POOL_EXTERNAL_IDENTIFIER, POOL_EXTERNAL_IDENTIFIER, POOL_EXTERNAL_IDENTIFIER, POOL_EXTERNAL_IDENTIFIER, 'Active', 'None', 0, NULL, TRIM(POLR_TYPE), 0, TRIM(TARIFF_CODE), TRIM(PLC_BAND), TRIM(REPORTED_SEGMENT), TRIM(VOLTAGE_LEVEL))
   BULK COLLECT INTO v_POOL_SYNC_LIST
   FROM (SELECT DISTINCT TRIM(RTO_POOL_ID) "POOL_EXTERNAL_IDENTIFIER", TARIFF_CODE, POLR_TYPE, PLC_BAND, SPECIAL_NOTATION, IS_TOU, REPORTED_SEGMENT, VOLTAGE_LEVEL FROM CDI_MAIN);
   LOGS.LOG_INFO('Pool List Collector Count: ' || TO_CHAR(v_POOL_SYNC_LIST.COUNT));
   IF v_POOL_SYNC_LIST IS NULL OR v_POOL_SYNC_LIST.COUNT() = 0 THEN
      LOGS.LOG_WARN('Pool List Collector Is Empty');
   ELSE 
      CDI_BK.SYNC_POOL(v_POOL_SYNC_LIST);
   END IF;
   LOGS.LOG_INFO('Sync Pool Elapsed Seconds: ' || TO_CHAR(ROUND((DBMS_UTILITY.GET_TIME-v_MARK_TIME)/100)));
END SYNC_POOL;

PROCEDURE SYNC_ACCOUNT(p_FROM_DATE IN DATE) AS
v_ACCOUNT_LIST             CDI_ACCOUNT_SYNC_LIST;
v_ACCOUNT_CALENDAR_LIST    CDI_ACCOUNT_CALENDAR_SYNC_LIST;
v_ACCOUNT_LOSS_FACTOR_LIST CDI_ACCNT_LOSS_FAC_SYNC_LIST;
v_AMI_BEFORE PLS_INTEGER;
v_AMI_AFTER  PLS_INTEGER;
v_MARK_TIME  PLS_INTEGER := DBMS_UTILITY.GET_TIME;
BEGIN
   SELECT COUNT(*) INTO v_AMI_BEFORE FROM ACCOUNT WHERE ACCOUNT_SIC_CODE = 'AMI';
   WITH SELECT_ACCOUNTS AS
      (SELECT DISTINCT RTO_ACCOUNT_IDENTIFIER "ACCOUNT_EXTERNAL_IDENTIFIER", RTO_ACCOUNT_IDENTIFIER "ACCOUNT_NAME", CASE WHEN METER_TYPE = 'I' THEN c_INTERVAL_ACCOUNT_METER_TYPE ELSE c_PERIOD_ACCOUNT_METER_TYPE END "ACCOUNT_METER_TYPE", NULL "ACCOUNT_DUNS_NUMBER", NULL "ACCOUNT_SIC_CODE", ACCOUNT_METER_EXT_IDENTIFIER, RTO_POOL_ID "ACCOUNT_POOL_IDENTIFIER"
      FROM CDI_INDIVIDUAL_ACCOUNT_NEW
      UNION SELECT DISTINCT ACCOUNT_EXTERNAL_IDENTIFIER, ACCOUNT_NAME, ACCOUNT_METER_TYPE, ACCOUNT_DUNS_NUMBER, ACCOUNT_SIC_CODE, ACCOUNT_METER_EXT_IDENTIFIER, ACCOUNT_POOL_IDENTIFIER
      FROM CDI_AMI_PSEUDO_ACCOUNT$)
   SELECT CDI_ACCOUNT_SYNC_TYPE(
      ACCOUNT_NAME,                                                                                                                 -- ACCOUNT_NAME --
      CASE WHEN ACCOUNT_NAME LIKE '%AMI%' THEN SUBSTR(TRIM(SUBSTR(ACCOUNT_NAME, INSTR(ACCOUNT_NAME, '_') + 1)),1,32) ELSE NULL END, -- ACCOUNT_ALIAS --
      ACCOUNT_EXTERNAL_IDENTIFIER,                                                                                                  -- ACCOUNT_EXTERNAL_IDENTIFIER --
      NULL,                                                                                                                         -- ACCOUNT_DISPLAY_NAME --
      NULL,                                                                                                                         -- ACCOUNT_BILL_OPTION --
      CASE WHEN ACCOUNT_METER_TYPE = c_INTERVAL_ACCOUNT_METER_TYPE THEN c_ACCOUNT_MODEL_OPTION ELSE c_AGGREGATE_MODEL_OPTION END,   -- ACCOUNT_MODEL_OPTION --
      ACCOUNT_SIC_CODE,                                                                                                             -- ACCOUNT_SIC_CODE --
      'Eastern',                                                                                                                    -- ACCOUNT_TIME_ZONE --
      ACCOUNT_METER_TYPE,                                                                                                           -- ACCOUNT_METER_TYPE --
      'Active',                                                                                                                     -- ACCOUNT_STATUS --
      1,                                                                                                                            -- ACCOUNT_IS_ACTIVE --
      1,                                                                                                                            -- MODEL_ID --
      1,                                                                                                                            -- IS_UFE_PARTICIPANT --
      0,                                                                                                                            -- IS_EXTERNAL_INTERVAL_USAGE --
      0,                                                                                                                            -- IS_EXTERNAL_BILLED_USAGE --
      0,                                                                                                                            -- IS_CREATE_SETTLEMENT_PROFILE --
      0,                                                                                                                            -- IS_EXTERNAL_FORECAST --
      NULL,                                                                                                                         -- SERVICE_LOCATION_NAME --
      NULL,                                                                                                                         -- SERVICE_POINT_NAME --
      NULL,                                                                                                                         -- WEATHER_STATION_NAME --
      NULL,                                                                                                                         -- BILL_CYCLE_NAME --
      NULL,                                                                                                                         -- ACCOUNT_DESC --
      ACCOUNT_DUNS_NUMBER,                                                                                                          -- ACCOUNT_DUNS_NUMBER --
      ACCOUNT_METER_EXT_IDENTIFIER,                                                                                                 -- ACCOUNT_METER_EXT_IDENTIFIER --
      CONSTANTS.NOT_ASSIGNED,                                                                                                       -- ACCOUNT_ROLLUP_ID --
      CASE WHEN ACCOUNT_METER_TYPE <> c_INTERVAL_ACCOUNT_METER_TYPE THEN 1 ELSE 0 END,                                              -- IS_AGGREGATE_ACCOUNT --
      CONSTANTS.NOT_ASSIGNED)                                                                                                       -- TX_SERVICE_TYPE_ID --
   BULK COLLECT INTO v_ACCOUNT_LIST
   FROM SELECT_ACCOUNTS
   ORDER BY ACCOUNT_EXTERNAL_IDENTIFIER;
   LOGS.LOG_INFO('Account Sync Collector Count: ' || TO_CHAR(v_ACCOUNT_LIST.COUNT));

   SELECT CDI_ACCOUNT_CALENDAR_SYNC_TYPE(ACCOUNT_EXTERNAL_IDENTIFIER, CASE WHEN ACCOUNT_METER_TYPE = c_PERIOD_ACCOUNT_METER_TYPE THEN ACCOUNT_EXTERNAL_IDENTIFIER ELSE CASE WHEN RATE_CLASS IN ('NR','P') THEN 'PL' ELSE RATE_CLASS END || '_BWI' END || '_Settlement', c_CALENDAR_TYPE_BACKCAST, GA.BASE_CASE_ID, BEGIN_DATE, END_DATE)
   BULK COLLECT INTO v_ACCOUNT_CALENDAR_LIST
   FROM TABLE(CAST(l_ACCOUNT_ASSIGN_SYNC_LIST AS CDI_ACCOUNT_ASSIGN_SYNC_LIST))
   WHERE ACCOUNT_METER_TYPE = c_INTERVAL_ACCOUNT_METER_TYPE
   ORDER BY ACCOUNT_EXTERNAL_IDENTIFIER, BEGIN_DATE, END_DATE;
   LOGS.LOG_INFO('Account Forecast Calendar Collector Count: ' || TO_CHAR(v_ACCOUNT_CALENDAR_LIST.COUNT));

   SELECT CDI_ACCNT_LOSS_FAC_SYNC_TYPE(RTO_ACCOUNT_IDENTIFIER, VOLTAGE_LEVEL, BEGIN_DATE, END_DATE)
   BULK COLLECT INTO v_ACCOUNT_LOSS_FACTOR_LIST
   FROM
      (SELECT RTO_ACCOUNT_IDENTIFIER, VOLTAGE_LEVEL, MIN(BEGIN_DATE) "BEGIN_DATE", MAX(END_DATE) "END_DATE"
      FROM
         (SELECT RTO_ACCOUNT_IDENTIFIER, VOLTAGE_LEVEL, BEGIN_DATE, END_DATE
         FROM CDI_INDIVIDUAL_ACCOUNT_NEW
         WHERE RTO_ACCOUNT_IDENTIFIER NOT IN (SELECT ACCOUNT_EXTERNAL_IDENTIFIER FROM ACCOUNT WHERE ACCOUNT_MODEL_OPTION = 'Aggregate')
         UNION SELECT ACCOUNT_EXTERNAL_IDENTIFIER, VOLTAGE_LEVEL, BEGIN_DATE, END_DATE
         FROM CDI_AMI_PSEUDO_ACCOUNT$)
      GROUP BY RTO_ACCOUNT_IDENTIFIER, VOLTAGE_LEVEL
      ORDER BY RTO_ACCOUNT_IDENTIFIER, BEGIN_DATE, END_DATE);
   LOGS.LOG_INFO('Account Loss Factor Collector Count: ' || TO_CHAR(v_ACCOUNT_LOSS_FACTOR_LIST.COUNT));

   GATHER_TABLE_STATS('ACCOUNT');
   CDI_BK.SYNC_ACCOUNT(v_ACCOUNT_LIST);
   CDI_BK.SYNC_ACCOUNT_CALENDAR_AFTER(p_FROM_DATE, c_CALENDAR_TYPE_BACKCAST, v_ACCOUNT_CALENDAR_LIST);
   CDI_BK.SYNC_ACCOUNT_LOSS_FACTOR_AFTER(p_FROM_DATE, GA.BASE_CASE_ID, v_ACCOUNT_LOSS_FACTOR_LIST);
   GATHER_TABLE_STATS('ACCOUNT_CALENDAR');
   GATHER_TABLE_STATS('ACCOUNT_LOSS_FACTOR');

   SELECT COUNT(*) INTO v_AMI_AFTER FROM ACCOUNT WHERE ACCOUNT_SIC_CODE = 'AMI';
   LOGS.LOG_INFO('AMI Pseudo-Account Processing Counts, Before: ' || TO_CHAR(v_AMI_BEFORE) || ', After: ' || TO_CHAR(v_AMI_AFTER) || ', Delta: ' || TO_CHAR(v_AMI_AFTER - v_AMI_BEFORE));
   LOGS.LOG_INFO('Sync Account Elapsed Seconds: ' || TO_CHAR(ROUND((DBMS_UTILITY.GET_TIME-v_MARK_TIME)/100)));

END SYNC_ACCOUNT;

PROCEDURE SYNC_ACCOUNT_EDC(p_FROM_DATE IN DATE) AS
v_ACCOUNT_EDC_SYNC CDI_ACCOUNT_EDC_SYNC_LIST;
v_MARK_TIME PLS_INTEGER := DBMS_UTILITY.GET_TIME;
BEGIN
   SELECT CDI_ACCOUNT_EDC_SYNC_TYPE(ACCOUNT_EXTERNAL_IDENTIFIER, EDC_EXTERNAL_IDENTIFIER, EDC_ACCOUNT_NUMBER, RATE_CLASS, '?', BEGIN_DATE, END_DATE)
   BULK COLLECT INTO v_ACCOUNT_EDC_SYNC
   FROM
      (SELECT ACCOUNT_EXTERNAL_IDENTIFIER, EDC_EXTERNAL_IDENTIFIER, EDC_ACCOUNT_NUMBER, RATE_CLASS, MIN(BEGIN_DATE) AS BEGIN_DATE, MAX(END_DATE) AS END_DATE
      FROM TABLE(CAST(l_ACCOUNT_ASSIGN_SYNC_LIST AS CDI_ACCOUNT_ASSIGN_SYNC_LIST))
      GROUP BY ACCOUNT_EXTERNAL_IDENTIFIER, EDC_EXTERNAL_IDENTIFIER, EDC_ACCOUNT_NUMBER, RATE_CLASS
      UNION SELECT ACCOUNT_EXTERNAL_IDENTIFIER, EDC_EXTERNAL_IDENTIFIER, NULL, NULL, BEGIN_DATE, END_DATE
      FROM CDI_AMI_PSEUDO_ACCOUNT$
      ORDER BY 1,2,5,6);
   LOGS.LOG_INFO('Account EDC Sync Collector Count: ' || TO_CHAR(v_ACCOUNT_EDC_SYNC.COUNT));
   CDI_BK.SYNC_ACCOUNT_EDC_AFTER(p_FROM_DATE, v_ACCOUNT_EDC_SYNC);
   GATHER_TABLE_STATS('ACCOUNT_EDC');
   LOGS.LOG_INFO('Sync Account EDC Elapsed Seconds: ' || TO_CHAR(ROUND((DBMS_UTILITY.GET_TIME-v_MARK_TIME)/100)));
END SYNC_ACCOUNT_EDC;

PROCEDURE SYNC_ACCOUNT_ESP(p_FROM_DATE IN DATE) AS
v_ACCOUNT_ESP_SYNC CDI_ACCOUNT_ESP_SYNC_LIST;
v_MARK_TIME PLS_INTEGER := DBMS_UTILITY.GET_TIME;
BEGIN
   SELECT CDI_ACCOUNT_ESP_SYNC_TYPE(ACCOUNT_EXTERNAL_IDENTIFIER, ESP_EXTERNAL_IDENTIFIER, POOL_EXTERNAL_IDENTIFIER, BEGIN_DATE, END_DATE,'?')
   BULK COLLECT INTO v_ACCOUNT_ESP_SYNC
   FROM
   (SELECT DISTINCT ACCOUNT_EXTERNAL_IDENTIFIER, ESP_EXTERNAL_IDENTIFIER, POOL_EXTERNAL_IDENTIFIER, CASE WHEN ACCOUNT_METER_TYPE = c_INTERVAL_ACCOUNT_METER_TYPE THEN BEGIN_DATE ELSE MIN (BEGIN_DATE) OVER (PARTITION BY ACCOUNT_EXTERNAL_IDENTIFIER, EDC_EXTERNAL_IDENTIFIER, POOL_EXTERNAL_IDENTIFIER) END BEGIN_DATE, CASE WHEN ACCOUNT_METER_TYPE = c_INTERVAL_ACCOUNT_METER_TYPE THEN END_DATE ELSE MAX(END_DATE) OVER (PARTITION BY ACCOUNT_EXTERNAL_IDENTIFIER, EDC_EXTERNAL_IDENTIFIER, POOL_EXTERNAL_IDENTIFIER) END END_DATE
   FROM TABLE(CAST(l_ACCOUNT_ASSIGN_SYNC_LIST AS CDI_ACCOUNT_ASSIGN_SYNC_LIST))
   WHERE ACCOUNT_METER_TYPE = c_INTERVAL_ACCOUNT_METER_TYPE)
   ORDER BY ACCOUNT_EXTERNAL_IDENTIFIER, ESP_EXTERNAL_IDENTIFIER, POOL_EXTERNAL_IDENTIFIER, BEGIN_DATE, END_DATE;
   LOGS.LOG_INFO('Account ESP Sync Collector Count: ' || TO_CHAR(v_ACCOUNT_ESP_SYNC.COUNT));
   CDI_BK.SYNC_ACCOUNT_ESP_AFTER(p_FROM_DATE, v_ACCOUNT_ESP_SYNC);
   GATHER_TABLE_STATS('ACCOUNT_ESP');
   LOGS.LOG_INFO('Sync Account ESP Elapsed Seconds: ' || TO_CHAR(ROUND((DBMS_UTILITY.GET_TIME-v_MARK_TIME)/100)));
END SYNC_ACCOUNT_ESP;

PROCEDURE SYNC_ACCOUNT_SERVICE_LOCATION(p_FROM_DATE IN DATE) AS
CURSOR c_SELECT IS
   WITH STAGED_CONTENT AS
      (SELECT DISTINCT ACCOUNT_EXTERNAL_IDENTIFIER, SERVICE_LOCATION_IDENTIFIER
      FROM
         (SELECT DISTINCT ACCOUNT_EXTERNAL_IDENTIFIER, ACCOUNT_SERV_LOC_EXT_ID "SERVICE_LOCATION_IDENTIFIER" FROM TABLE(CAST(l_ACCOUNT_ASSIGN_SYNC_LIST AS CDI_ACCOUNT_ASSIGN_SYNC_LIST))
         UNION
         SELECT DISTINCT ACCOUNT_EXTERNAL_IDENTIFIER, SERVICE_LOCATION_IDENTIFIER FROM CDI_AMI_PSEUDO_ACCOUNT$))
   SELECT X.ACCOUNT_EXTERNAL_IDENTIFIER, X.SERVICE_LOCATION_IDENTIFIER, A.ACCOUNT_ID, SL.SERVICE_LOCATION_ID, CASE WHEN ASL.ACCOUNT_ID IS NULL THEN 1 ELSE 0 END IS_NEW_ENTRY
   FROM STAGED_CONTENT X
      LEFT JOIN ACCOUNT A ON A.ACCOUNT_EXTERNAL_IDENTIFIER = X.ACCOUNT_EXTERNAL_IDENTIFIER
      LEFT JOIN SERVICE_LOCATION SL ON SL.EXTERNAL_IDENTIFIER = X.SERVICE_LOCATION_IDENTIFIER
      LEFT JOIN ACCOUNT_SERVICE_LOCATION ASL ON ASL.ACCOUNT_ID = A.ACCOUNT_ID AND ASL.SERVICE_LOCATION_ID = SL.SERVICE_LOCATION_ID AND ASL.BEGIN_DATE = CONSTANTS.LOW_DATE;
v_COUNT PLS_INTEGER := 0;
v_MARK_TIME PLS_INTEGER := DBMS_UTILITY.GET_TIME;
BEGIN
   FOR v_SELECT IN c_SELECT LOOP
      IF v_SELECT.ACCOUNT_ID IS NULL THEN
         LOGS.LOG_ERROR('Account Associated With The External Identifier "' || v_SELECT.ACCOUNT_EXTERNAL_IDENTIFIER || '" Is Not Defined');
      END IF;
      IF v_SELECT.ACCOUNT_ID IS NULL THEN
         LOGS.LOG_ERROR('Service Location Associated With The External Identifier "' || v_SELECT.SERVICE_LOCATION_IDENTIFIER || '" Is Not Defined');
      END IF;
      IF v_SELECT.IS_NEW_ENTRY = 1 THEN
         RO.PUT_ACCOUNT_SERVICE_LOCATION(
            p_ACCOUNT_ID          => v_SELECT.ACCOUNT_ID,
            p_SERVICE_LOCATION_ID => v_SELECT.SERVICE_LOCATION_ID,
            p_SERVICE_DATE        => CONSTANTS.LOW_DATE);
         v_COUNT := v_COUNT + 1;
      END IF;
   END LOOP;
   GATHER_TABLE_STATS('ACCOUNT_SERVICE_LOCATION');
   LOGS.LOG_INFO('Account Service Location Insert Count: ' || TO_CHAR(v_COUNT));
   LOGS.LOG_INFO('Sync Account Service Location Elapsed Seconds: ' || TO_CHAR(ROUND((DBMS_UTILITY.GET_TIME-v_MARK_TIME)/100)));
END SYNC_ACCOUNT_SERVICE_LOCATION;

PROCEDURE CACHE_USAGE_FACTOR(p_BEGIN_DATE IN DATE, p_END_DATE IN DATE) AS
v_MARK_TIME PLS_INTEGER := DBMS_UTILITY.GET_TIME;
v_COUNT PLS_INTEGER;
BEGIN
-- Populate The Staging Table With The Latest Usage Factor That Pre-Dates The End Date Of The Sync Period --
   INSERT /*+ APPEND */ INTO CDI_USAGE_FACTOR_CACHE(BILL_ACCOUNT, SERVICE_POINT, USAGE_FACTOR)
   SELECT /*+ PARALLEL(B,8) */  BILL_ACCOUNT, SERVICE_POINT, USAGE_FACTOR
   FROM
      (SELECT /*+ PARALLEL_INDEX(A,8) */ BILL_ACCOUNT, SERVICE_POINT, CASE WHEN USAGE_FACTOR = -1 THEN 1 ELSE USAGE_FACTOR END "USAGE_FACTOR", ROW_NUMBER() OVER(PARTITION BY  BILL_ACCOUNT, SERVICE_POINT ORDER BY BILL_ACCOUNT, SERVICE_POINT, BEGIN_DATE DESC) AS RN
      FROM BGE_RTO_MONTHLY_USAGE A
      WHERE BEGIN_DATE <= p_END_DATE
         AND USAGE_FACTOR IS NOT NULL) B
   WHERE RN = 1;
   LOGS.LOG_INFO('Number Of Usage Factor Records Cached: ' || TO_CHAR(SQL%ROWCOUNT));
   GATHER_TABLE_STATS('CDI_USAGE_FACTOR_CACHE');
-- Determine The Number Of Bill Accounts That Do Not Have An Assigned Usage Factor For The Period --
   SELECT COUNT(DISTINCT SERVICE_POINT) INTO v_COUNT
   FROM CDI_MAIN X
   WHERE X.IDR_STATUS <> 'Y'
      AND NOT EXISTS (SELECT NULL FROM CDI_USAGE_FACTOR_CACHE WHERE BILL_ACCOUNT = X.BILL_ACCOUNT AND SERVICE_POINT = X.SERVICE_POINT); 
   LOGS.LOG_INFO('Number Of Bill Accounts Without An Assigned Usage Factor: ' || TO_CHAR(v_COUNT));
   LOGS.LOG_INFO('Cache Usage Factor Elapsed Seconds: ' || TO_CHAR(ROUND((DBMS_UTILITY.GET_TIME-v_MARK_TIME)/100)));
END CACHE_USAGE_FACTOR;

PROCEDURE SYNC_AGGREGATE_ACCOUNT(p_FROM_DATE IN DATE, p_TO_DATE IN DATE) AS
CURSOR c_SELECT_MISSING IS SELECT * FROM CDI_AGGREGATE_ACCOUNT$ WHERE ACCOUNT_ID IS NULL OR ESP_ID IS NULL OR POOL_ID IS NULL;
CURSOR c_SELECT_NEW IS
   SELECT DISTINCT ACCOUNT_ID, ESP_ID, POOL_ID
   FROM CDI_AGGREGATE_ACCOUNT$ X
   WHERE ACCOUNT_ID IS NOT NULL
      AND ESP_ID IS NOT NULL
      AND POOL_ID IS NOT NULL
      AND NOT EXISTS (SELECT NULL FROM AGGREGATE_ACCOUNT_ESP WHERE ACCOUNT_ID = X.ACCOUNT_ID AND ESP_ID = X.ESP_ID AND POOL_ID = X.POOL_ID AND BEGIN_DATE = CONSTANTS.LOW_DATE);
v_ENTRY_DATE   DATE := CURRENT_DATE;
v_SERVICE_DATE DATE := p_FROM_DATE;
v_COUNT        PLS_INTEGER := 0;
v_STATUS       PLS_INTEGER;
v_MARK_TIME    PLS_INTEGER := DBMS_UTILITY.GET_TIME;
BEGIN
   INSERT /*APPEND*/ INTO CDI_AGGREGATE_ACCOUNTS(RTO_ACCOUNT_ID, SUPPLIER, RTO_POOL_ID, BEGIN_DATE, END_DATE, CUSTOMER_COUNT, USAGE_FACTOR)
   SELECT RTO_ACCOUNT_ID, SUPPLIER, RTO_POOL_ID, EFFECT_DATE "BEGIN_DATE", TERM_DATE "END_DATE", COUNT(*), NULL USAGE_FACTOR
   FROM CDI_MAIN
   WHERE IDR_STATUS <> 'Y'
   GROUP BY RTO_ACCOUNT_ID, SUPPLIER, RTO_POOL_ID, EFFECT_DATE, TERM_DATE;
   LOGS.LOG_INFO('Number Of Records Posted To The CDI_AGGREGATE_ACCOUNTS Table: ' || TO_CHAR(SQL%ROWCOUNT));
-- Capture Any New Aggregate-Account/ESP/Pool Combinations --
   FOR v_SELECT IN c_SELECT_NEW LOOP
      RA.PUT_AGGREGATE_ACCOUNT_ESP(
         p_ACCOUNT_ID     => v_SELECT.ACCOUNT_ID,
         p_ESP_ID         => v_SELECT.ESP_ID,
         p_POOL_ID        => v_SELECT.POOL_ID,
         p_BEGIN_DATE     => p_FROM_DATE,
         p_END_DATE       => p_TO_DATE,
         p_OLD_ESP_ID     => v_SELECT.ESP_ID,
         p_OLD_POOL_ID    => v_SELECT.POOL_ID,
         p_OLD_BEGIN_DATE => p_FROM_DATE,
         p_STATUS         => v_STATUS);
      v_COUNT := v_COUNT + SQL%ROWCOUNT;
   END LOOP;
   LOGS.LOG_INFO('Aggregate Account ESP Insert Count: ' || TO_CHAR(v_COUNT));
-- Inventory Any Missing Entity References --
   FOR v_SELECT IN c_SELECT_MISSING LOOP
      IF v_SELECT.ACCOUNT_ID IS NULL THEN
         LOGS.LOG_ERROR('Account Associated With The External Identifier "' || v_SELECT.ACCOUNT_IDENTIFIER || '" Is Not Defined');
      END IF;
      IF v_SELECT.ESP_ID IS NULL THEN
         LOGS.LOG_ERROR('ESP Associated With The External Identifier "' || v_SELECT.ESP_IDENTIFIER || '" Is Not Defined');
      END IF;   
      IF v_SELECT.POOL_ID IS NULL THEN
         LOGS.LOG_ERROR('Pool Associated With The External Identifier "' || v_SELECT.POOL_IDENTIFIER || '" Is Not Defined');
      END IF;
   END LOOP;
   GATHER_TABLE_STATS('AGGREGATE_ACCOUNT_ESP');
   LOGS.LOG_INFO('Aggregate Account Elapsed Seconds: ' || TO_CHAR(ROUND((DBMS_UTILITY.GET_TIME-v_MARK_TIME)/100)));
END SYNC_AGGREGATE_ACCOUNT;


PROCEDURE SYNC_AGGREGATE_ACCOUNT_SERVICE(p_FROM_DATE IN DATE, p_TO_DATE IN DATE) AS
v_SERVICE_DATE DATE := p_FROM_DATE;
v_MARK_TIME PLS_INTEGER := DBMS_UTILITY.GET_TIME;
BEGIN
-- Cache Usage Factors For The Sync Period --   
   CACHE_USAGE_FACTOR(p_FROM_DATE, p_TO_DATE);
-- Populate The ESP Service Accounts Of Record For Each Aggregate Account Over The Specified Time Period --
   INSERT /*APPEND*/ INTO CDI_AGGREGATE_SERVICE_CACHE(AGGREGATE_ID, SERVICE_DATE, SERVICE_ACCOUNTS)
   WITH DATE_RANGE AS (SELECT LOCAL_DAY FROM CDI_LOCAL_DAY$ WHERE LOCAL_DAY BETWEEN p_FROM_DATE and p_TO_DATE)
   SELECT AA.AGGREGATE_ID, DR.LOCAL_DAY, SUM(AA.SERVICE_ACCOUNTS) "SERVICE_ACCOUNTS"
   FROM DATE_RANGE DR
      JOIN CDI_AGGREGATE_ACCOUNT$ AA ON DR.LOCAL_DAY BETWEEN AA.BEGIN_DATE AND AA.END_DATE
   GROUP BY AA.AGGREGATE_ID, DR.LOCAL_DAY;
   LOGS.LOG_INFO('Aggregate Account Service Records Cached: ' || TO_CHAR(SQL%ROWCOUNT));
-- Get The Associated Accumulated Usage Factor For Each Aggregate Account Over The Specified Time Period --
   MERGE INTO CDI_AGGREGATE_SERVICE_CACHE T
   USING
   (WITH
      DATE_RANGE AS (SELECT LOCAL_DAY FROM CDI_LOCAL_DAY$ WHERE LOCAL_DAY BETWEEN p_FROM_DATE AND p_TO_DATE),
      USAGE_FACTOR AS
         (SELECT DR.LOCAL_DAY, A.RTO_ACCOUNT_ID, A.SUPPLIER, A.RTO_POOL_ID, AVG(NVL(B.USAGE_FACTOR,1)) "USAGE_FACTOR"
         FROM DATE_RANGE DR
            JOIN CDI_MAIN A ON A.IDR_STATUS <> 'Y' AND DR.LOCAL_DAY BETWEEN A.EFFECT_DATE AND A.TERM_DATE
            LEFT JOIN CDI_USAGE_FACTOR_CACHE B ON B.BILL_ACCOUNT = A.BILL_ACCOUNT AND B.SERVICE_POINT = A.SERVICE_POINT 
         GROUP BY DR.LOCAL_DAY, A.RTO_ACCOUNT_ID, A.SUPPLIER, A.RTO_POOL_ID)
      SELECT G.AGGREGATE_ID, X.LOCAL_DAY "SERVICE_DATE", X.USAGE_FACTOR
      FROM USAGE_FACTOR X
         LEFT JOIN ACCOUNT                 A ON A.ACCOUNT_EXTERNAL_IDENTIFIER = X.RTO_ACCOUNT_ID
         LEFT JOIN ENERGY_SERVICE_PROVIDER E ON E.ESP_EXTERNAL_IDENTIFIER = X.SUPPLIER
         LEFT JOIN POOL                    P ON P.POOL_EXTERNAL_IDENTIFIER = X.RTO_POOL_ID
         LEFT JOIN AGGREGATE_ACCOUNT_ESP   G ON G.ACCOUNT_ID = A.ACCOUNT_ID AND G.ESP_ID = E.ESP_ID AND G.POOL_ID = P.POOL_ID) S
   ON (T.AGGREGATE_ID = S.AGGREGATE_ID AND T.SERVICE_DATE = S.SERVICE_DATE)
   WHEN MATCHED THEN
      UPDATE SET T.USAGE_FACTOR = S.USAGE_FACTOR;
   LOGS.LOG_INFO('Aggregate Account Service Usage Factor Records Updated: ' || TO_CHAR(SQL%ROWCOUNT));
-- Delete Any Records That Are No Longer In Context Based On The Current Enrollment State --
   DELETE FROM AGGREGATE_ACCOUNT_SERVICE X
   WHERE SERVICE_DATE BETWEEN p_FROM_DATE AND p_TO_DATE
      AND NOT EXISTS (SELECT NULL FROM CDI_AGGREGATE_SERVICE_CACHE WHERE CASE_ID = GA.BASE_CASE_ID AND AGGREGATE_ID = X.AGGREGATE_ID AND SERVICE_DATE = X.SERVICE_DATE)
      AND CASE_ID = GA.BASE_CASE_ID;
   LOGS.LOG_INFO('Aggregate Account Service Records Deleted: ' || TO_CHAR(SQL%ROWCOUNT));
-- Update Any Records That Have Changes Based On The Current Enrollment State --
   MERGE INTO AGGREGATE_ACCOUNT_SERVICE T
   USING
      (SELECT 1 "CASE_ID", X.AGGREGATE_ID, X.SERVICE_DATE, C.SERVICE_ACCOUNTS, C.USAGE_FACTOR
      FROM AGGREGATE_ACCOUNT_SERVICE X
         JOIN CDI_AGGREGATE_SERVICE_CACHE C ON C.AGGREGATE_ID = X.AGGREGATE_ID AND C.SERVICE_DATE = X.SERVICE_DATE AND (C.SERVICE_ACCOUNTS <> X.SERVICE_ACCOUNTS OR C.USAGE_FACTOR <> X.USAGE_FACTOR)
      WHERE X.SERVICE_DATE BETWEEN p_FROM_DATE AND p_TO_DATE
         AND X.CASE_ID = GA.BASE_CASE_ID) S
   ON (T.CASE_ID = S.CASE_ID AND T.AGGREGATE_ID = S.AGGREGATE_ID AND T.SERVICE_DATE = S.SERVICE_DATE)
   WHEN MATCHED THEN
      UPDATE SET T.SERVICE_ACCOUNTS = S.SERVICE_ACCOUNTS, T.USAGE_FACTOR = S.USAGE_FACTOR;
   LOGS.LOG_INFO('Aggregate Account Service Records Updated: ' || TO_CHAR(SQL%ROWCOUNT));
-- Insert Any New Records That Are In The Current Enrollment State --
   MERGE INTO AGGREGATE_ACCOUNT_SERVICE T
   USING
      (SELECT GA.BASE_CASE_ID "CASE_ID", AGGREGATE_ID, SERVICE_DATE, SERVICE_ACCOUNTS, USAGE_FACTOR
      FROM CDI_AGGREGATE_SERVICE_CACHE X
      WHERE NOT EXISTS (SELECT NULL FROM AGGREGATE_ACCOUNT_SERVICE WHERE CASE_ID = 1 AND AGGREGATE_ID = X.AGGREGATE_ID AND SERVICE_DATE = X.SERVICE_DATE)) S
   ON (T.CASE_ID = S.CASE_ID AND T.AGGREGATE_ID = S.AGGREGATE_ID AND T.SERVICE_DATE = S.SERVICE_DATE)
   WHEN NOT MATCHED THEN
      INSERT(CASE_ID, AGGREGATE_ID, SERVICE_DATE, AS_OF_DATE, SERVICE_ACCOUNTS, ENROLLED_ACCOUNTS, USAGE_FACTOR)
      VALUES(S.CASE_ID, S.AGGREGATE_ID, S.SERVICE_DATE, LOW_DATE, S.SERVICE_ACCOUNTS, S.SERVICE_ACCOUNTS, S.USAGE_FACTOR);
   LOGS.LOG_INFO('Aggregate Account Service Records Inserted: ' || TO_CHAR(SQL%ROWCOUNT));
   GATHER_TABLE_STATS('AGGREGATE_ACCOUNT_SERVICE');
   LOGS.LOG_INFO('Aggregate Account Service Elapsed Seconds: ' || TO_CHAR(ROUND((DBMS_UTILITY.GET_TIME-v_MARK_TIME)/100)));
END SYNC_AGGREGATE_ACCOUNT_SERVICE;

PROCEDURE SYNC_ACCOUNT_ANCILLARY_SERVICE(p_PERIOD_BEGIN_DATE IN DATE, p_PERIOD_END_DATE IN DATE, p_ANCILLARY_SERVICE_ID IN NUMBER, p_TAG_ID_SUFFIX IN CHAR) AS
CURSOR c_SELECT IS
   SELECT C.ACCOUNT_ID, GREATEST(A.EFFECT_DATE, B.BEGIN_DATE, p_PERIOD_BEGIN_DATE) "BEGIN_DATE", LEAST(A.TERM_DATE, B.END_DATE, p_PERIOD_END_DATE) "END_DATE", TO_NUMBER(B.TAG_VAL) "SERVICE_VAL"
   FROM CDI_MAIN           A 
      JOIN CDI_PLC_ICAP_TX B ON B.BILL_ACCOUNT = A.BILL_ACCOUNT AND B.SERVICE_POINT = A.SERVICE_POINT AND B.PREMISE_NUMBER = A.PREMISE_NUMBER AND B.BEGIN_DATE <= p_PERIOD_END_DATE AND B.END_DATE >= p_PERIOD_BEGIN_DATE AND SUBSTR(B.TAG_ID,5,1) = p_TAG_ID_SUFFIX
      JOIN ACCOUNT         C ON C.ACCOUNT_NAME = A.RTO_ACCOUNT_ID    
   WHERE A.EFFECT_DATE  <= p_PERIOD_END_DATE
      AND A.TERM_DATE   >= p_PERIOD_BEGIN_DATE
      AND A.EFFECT_DATE <= B.END_DATE
      AND A.TERM_DATE   >= B.BEGIN_DATE
      AND A.IDR_STATUS = 'Y'
   ORDER BY ACCOUNT_ID, BEGIN_DATE;   
v_OLD_BEGIN_DATE DATE;
v_OLD_END_DATE   DATE;
v_NEW_BEGIN_DATE DATE;
v_NEW_END_DATE   DATE;
v_COUNT     PLS_INTEGER := 0;
v_MARK_TIME PLS_INTEGER := DBMS_UTILITY.GET_TIME;
v_ROWID ROWID;
BEGIN
   DELETE ACCOUNT_ANCILLARY_SERVICE WHERE BEGIN_DATE >= p_PERIOD_BEGIN_DATE AND ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID;
   LOGS.LOG_INFO('Account Ancillary Service "' || p_TAG_ID_SUFFIX || '" Existing Record Delete Count: ' || TO_CHAR(SQL%ROWCOUNT));
   UPDATE ACCOUNT_ANCILLARY_SERVICE SET END_DATE = p_PERIOD_BEGIN_DATE - 1
   WHERE ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID
      AND (END_DATE IS NULL OR END_DATE >= p_PERIOD_BEGIN_DATE);
   LOGS.LOG_INFO('Account Ancillary Service "' || p_TAG_ID_SUFFIX || '" Existing Record End Date Update Count: ' || TO_CHAR(SQL%ROWCOUNT));
   FOR v_SELECT IN c_SELECT LOOP
      v_NEW_BEGIN_DATE := v_SELECT.BEGIN_DATE;
      v_NEW_END_DATE := v_SELECT.END_DATE;
      BEGIN
         SELECT ROWID, BEGIN_DATE, END_DATE INTO v_ROWID, v_OLD_BEGIN_DATE, v_OLD_END_DATE
         FROM ACCOUNT_ANCILLARY_SERVICE
         WHERE ACCOUNT_ID = v_SELECT.ACCOUNT_ID
            AND ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID
            AND (BEGIN_DATE BETWEEN v_NEW_BEGIN_DATE AND NVL(v_NEW_END_DATE + 1, CONSTANTS.HIGH_DATE) OR NVL(END_DATE, CONSTANTS.HIGH_DATE) BETWEEN v_NEW_BEGIN_DATE - 1 AND NVL(v_NEW_END_DATE, CONSTANTS.HIGH_DATE) OR (v_NEW_BEGIN_DATE >= BEGIN_DATE AND NVL(v_NEW_END_DATE, CONSTANTS.HIGH_DATE) <= NVL(END_DATE, CONSTANTS.HIGH_DATE)))
            AND SERVICE_VAL = v_SELECT.SERVICE_VAL;
      EXCEPTION
         WHEN NO_DATA_FOUND THEN
            v_ROWID := NULL;
         WHEN OTHERS THEN
            ERRS.LOG_AND_CONTINUE('ACCOUNT: ' || TO_CHAR(v_SELECT.ACCOUNT_ID) || ', Ancillary Service: ' || TO_CHAR(p_ANCILLARY_SERVICE_ID) || ', Begin Date: ' || TO_CHAR(v_NEW_BEGIN_DATE,c_DATE_FORMAT) || ', End Date: ' || TO_CHAR(v_NEW_END_DATE,c_DATE_FORMAT) || ', Service Val: ' || TO_CHAR(v_SELECT.SERVICE_VAL));
      END;
      IF v_ROWID IS NOT NULL THEN
         UPDATE ACCOUNT_ANCILLARY_SERVICE SET
            BEGIN_DATE = LEAST(v_NEW_BEGIN_DATE, v_OLD_BEGIN_DATE),
            END_DATE = GREATEST(v_NEW_END_DATE, v_OLD_END_DATE),
            ENTRY_DATE = SYSDATE
         WHERE ROWID = v_ROWID;
      ELSE
         INSERT INTO ACCOUNT_ANCILLARY_SERVICE(ACCOUNT_ID, ANCILLARY_SERVICE_ID, BEGIN_DATE, END_DATE, SERVICE_VAL, ENTRY_DATE)
         VALUES(v_SELECT.ACCOUNT_ID, p_ANCILLARY_SERVICE_ID, v_NEW_BEGIN_DATE, v_NEW_END_DATE, v_SELECT.SERVICE_VAL, CURRENT_DATE);
      END IF;
      v_COUNT := v_COUNT + 1;
   END LOOP;
   LOGS.LOG_INFO('Account Ancillary Service "' || p_TAG_ID_SUFFIX || '" Update Count: ' || TO_CHAR(v_COUNT) || ', Elapsed Seconds: ' || TO_CHAR(ROUND((DBMS_UTILITY.GET_TIME-v_MARK_TIME)/100)));
END SYNC_ACCOUNT_ANCILLARY_SERVICE;

PROCEDURE SYNC_AGG_ANCILLARY_SERVICE(p_PERIOD_BEGIN_DATE IN DATE, p_PERIOD_END_DATE IN DATE, p_INSTALLED_CAPACITY_ID IN NUMBER, p_NETWORK_SERVICE_ID IN NUMBER) AS
CURSOR c_SELECT IS
   SELECT ANCILLARY_SERVICE_ID, BEGIN_DATE, END_DATE, SERVICE_VAL, AGGREGATE_ID
   FROM CDI_PLC_NSPL_CACHE
   WHERE AGGREGATE_ID IS NOT NULL;
v_SERVICE_DATE     DATE;
v_SERVICE_END_DATE DATE;
v_UPDATE_COUNT     PLS_INTEGER := 0;
v_INSERT_COUNT     PLS_INTEGER := 0;
v_MARK_TIME        PLS_INTEGER := DBMS_UTILITY.GET_TIME;
BEGIN
   DELETE AGGREGATE_ANCILLARY_SERVICE WHERE SERVICE_DATE >= p_PERIOD_BEGIN_DATE AND ANCILLARY_SERVICE_ID IN (p_INSTALLED_CAPACITY_ID, p_NETWORK_SERVICE_ID);
   LOGS.LOG_INFO('Aggregate Ancillary Service Delete Count: ' || TO_CHAR(SQL%ROWCOUNT));
   INSERT /* APPEND */ INTO CDI_PLC_NSPL_CACHE(ACCOUNT_IDENTIFIER, ESP_IDENTIFIER, POOL_IDENTIFIER, ANCILLARY_SERVICE_ID, BEGIN_DATE, END_DATE, SERVICE_VAL)
   SELECT RTO_ACCOUNT_ID "ACCOUNT_IDENTIFIER", SUPPLIER "ESP_IDENTIFIER", RTO_POOL_ID "POOL_IDENTIFIER", CASE WHEN SUBSTR(B.TAG_ID,5,1) = 'C' THEN p_INSTALLED_CAPACITY_ID ELSE p_NETWORK_SERVICE_ID END "ANCILLARY_SERVICE_ID", GREATEST(A.EFFECT_DATE, B.BEGIN_DATE, p_PERIOD_BEGIN_DATE) "BEGIN_DATE", LEAST(A.TERM_DATE, B.END_DATE, p_PERIOD_END_DATE) "END_DATE", SUM(TAG_VAL) "SERVICE_VAL"
   FROM CDI_MAIN A
      JOIN CDI_PLC_ICAP_TX B ON B.BILL_ACCOUNT = A.BILL_ACCOUNT AND B.SERVICE_POINT = A.SERVICE_POINT AND B.PREMISE_NUMBER = A.PREMISE_NUMBER AND B.BEGIN_DATE <= A.TERM_DATE AND B.END_DATE >= A.EFFECT_DATE
   WHERE A.EFFECT_DATE  <= p_PERIOD_END_DATE 
      AND A.TERM_DATE   >= p_PERIOD_BEGIN_DATE
      AND A.EFFECT_DATE <= B.END_DATE
      AND A.TERM_DATE   >= B.BEGIN_DATE
      AND A.IDR_STATUS <> 'Y'
   GROUP BY A.RTO_ACCOUNT_ID, A.SUPPLIER, A.RTO_POOL_ID, CASE WHEN SUBSTR(B.TAG_ID,5,1) = 'C' THEN p_INSTALLED_CAPACITY_ID ELSE p_NETWORK_SERVICE_ID END, GREATEST(A.EFFECT_DATE, B.BEGIN_DATE, p_PERIOD_BEGIN_DATE), LEAST(A.TERM_DATE, B.END_DATE, p_PERIOD_END_DATE);
   LOGS.LOG_INFO('Aggregate Ancillary Service Records Cached: ' || TO_CHAR(SQL%ROWCOUNT));
   GATHER_TABLE_STATS('CDI_PLC_NSPL_CACHE');
   UPDATE CDI_PLC_NSPL_CACHE SET AGGREGATE_ID =
      (SELECT MAX(Z.AGGREGATE_ID)
      FROM CDI_PLC_NSPL_CACHE X
         JOIN ACCOUNT                 A ON A.ACCOUNT_EXTERNAL_IDENTIFIER = X.ACCOUNT_IDENTIFIER
         JOIN ENERGY_SERVICE_PROVIDER E ON E.ESP_EXTERNAL_IDENTIFIER = X.ESP_IDENTIFIER
         JOIN POOL                    P ON P.POOL_EXTERNAL_IDENTIFIER = X.POOL_IDENTIFIER
         JOIN AGGREGATE_ACCOUNT_ESP   Z ON Z.ACCOUNT_ID = A.ACCOUNT_ID AND Z.ESP_ID = E.ESP_ID AND Z.POOL_ID = P.POOL_ID);
   FOR v_SELECT IN c_SELECT LOOP
      v_SERVICE_END_DATE := NVL(v_SELECT.END_DATE, p_PERIOD_END_DATE);
      v_SERVICE_DATE := v_SELECT.BEGIN_DATE;
      WHILE v_SERVICE_DATE <= v_SERVICE_END_DATE LOOP
         UPDATE AGGREGATE_ANCILLARY_SERVICE SET SERVICE_VAL = SERVICE_VAL + v_SELECT.SERVICE_VAL                           
         WHERE AGGREGATE_ID = v_SELECT.AGGREGATE_ID
            AND ANCILLARY_SERVICE_ID = v_SELECT.ANCILLARY_SERVICE_ID
            AND SERVICE_DATE = v_SERVICE_DATE
            AND AS_OF_DATE = CONSTANTS.LOW_DATE;             
         v_UPDATE_COUNT := v_UPDATE_COUNT + SQL%ROWCOUNT; 
         IF SQL%ROWCOUNT =  0 THEN            
            INSERT INTO AGGREGATE_ANCILLARY_SERVICE(AGGREGATE_ID, ANCILLARY_SERVICE_ID, SERVICE_DATE, AS_OF_DATE, SERVICE_VAL)
            VALUES(v_SELECT.AGGREGATE_ID, v_SELECT.ANCILLARY_SERVICE_ID, v_SERVICE_DATE, CONSTANTS.LOW_DATE, v_SELECT.SERVICE_VAL);  
            v_INSERT_COUNT := v_INSERT_COUNT + 1; 
         END IF;
         v_SERVICE_DATE := v_SERVICE_DATE + 1;
      END LOOP;
   END LOOP;
   LOGS.LOG_INFO('Aggregate Ancillary Service Update Count: ' || TO_CHAR(v_UPDATE_COUNT) || ', Insert Count: ' || TO_CHAR(v_INSERT_COUNT) || TO_CHAR(ROUND((DBMS_UTILITY.GET_TIME-v_MARK_TIME)/100)));
END SYNC_AGG_ANCILLARY_SERVICE;

PROCEDURE SYNC_PLC_NSPL(p_FROM_DATE IN DATE, p_TO_DATE IN DATE) AS
v_INSTALLED_CAPACITY_ID PLS_INTEGER;
v_NETWORK_SERVICE_ID    PLS_INTEGER;
v_MARK_TIME             PLS_INTEGER := DBMS_UTILITY.GET_TIME;
BEGIN
   SELECT MAX(ANCILLARY_SERVICE_ID) INTO v_INSTALLED_CAPACITY_ID FROM ANCILLARY_SERVICE WHERE ANCILLARY_SERVICE_NAME =  c_INSTALLED_CAPACITY;
   SELECT MAX(ANCILLARY_SERVICE_ID) INTO v_NETWORK_SERVICE_ID    FROM ANCILLARY_SERVICE WHERE ANCILLARY_SERVICE_NAME =  c_NETWORK_SERVICE;
-- Process Account Ancillary Service Assignments --
   SYNC_ACCOUNT_ANCILLARY_SERVICE(p_FROM_DATE, p_TO_DATE, v_INSTALLED_CAPACITY_ID, 'C');
   SYNC_ACCOUNT_ANCILLARY_SERVICE(p_FROM_DATE, p_TO_DATE, v_NETWORK_SERVICE_ID, 'T');
-- Process Aggregate Account Ancillary Service Assignments --
   SYNC_AGG_ANCILLARY_SERVICE(p_FROM_DATE, p_TO_DATE, v_INSTALLED_CAPACITY_ID, v_NETWORK_SERVICE_ID);
   GATHER_TABLE_STATS('ACCOUNT_ANCILLARY_SERVICE');
   GATHER_TABLE_STATS('AGGREGATE_ANCILLARY_SERVICE');
   LOGS.LOG_INFO('Sync PLC/NSPL Elapsed Seconds: ' || TO_CHAR(ROUND((DBMS_UTILITY.GET_TIME-v_MARK_TIME)/100)));
END SYNC_PLC_NSPL;  

PROCEDURE RUN_INTERFACE(p_FROM_DATE IN DATE DEFAULT NULL, p_SYNC_DAYS IN PLS_INTEGER DEFAULT NULL) AS
v_FROM_DATE          DATE;
v_TO_DATE            DATE;
v_SYNC_BACKWARD_DAYS PLS_INTEGER := TO_NUMBER(NVL(GET_DICTIONARY_VALUE('Sync Backward Days', GA.GLOBAL_MODEL, c_SYSTEM_SETTING_MODULE, c_SYSTEM_SETTING_KEY1, c_SYSTEM_SETTING_KEY2), '1'));
v_SYNC_FORWARD_DAYS  PLS_INTEGER := TO_NUMBER(NVL(GET_DICTIONARY_VALUE('Sync Forward Days',  GA.GLOBAL_MODEL, c_SYSTEM_SETTING_MODULE, c_SYSTEM_SETTING_KEY1, c_SYSTEM_SETTING_KEY2), '10'));
v_SYNC_DAYS          PLS_INTEGER;
v_COUNT              PLS_INTEGER;
v_STATUS             PLS_INTEGER;
v_MARK_TIME          PLS_INTEGER := DBMS_UTILITY.GET_TIME;
v_MESSAGE            VARCHAR2(1000);
BEGIN
   v_FROM_DATE := NVL(p_FROM_DATE, TRUNC(CURRENT_DATE) - v_SYNC_BACKWARD_DAYS);
   v_SYNC_DAYS := NVL(p_SYNC_DAYS, v_SYNC_BACKWARD_DAYS + v_SYNC_FORWARD_DAYS);
   v_TO_DATE := p_FROM_DATE + v_SYNC_DAYS;
   LOGS.START_PROCESS(c_ACCOUNT_SYNC_PROCESS, v_FROM_DATE, v_TO_DATE);
   LOGS.LOG_INFO('Sync From Date: ' || TO_CHAR(v_FROM_DATE, c_DATE_FORMAT) || ', To Date: ' || TO_CHAR(v_TO_DATE, c_DATE_FORMAT) || ', Sync Days: ' || TO_CHAR(v_SYNC_DAYS));
   LOGS.INIT_PROCESS_PROGRESS('Account Sync Process', 9, 'Steps');
   LOGS.INCREMENT_PROCESS_PROGRESS(1, 'Stage Content');
   STAGE_CONTENT(v_FROM_DATE, v_TO_DATE);
   LOGS.INCREMENT_PROCESS_PROGRESS(1, 'Sync Pool');
   SYNC_POOL(v_FROM_DATE);
   LOGS.INCREMENT_PROCESS_PROGRESS(1, 'Sync Account');
   SYNC_ACCOUNT(v_FROM_DATE);
   LOGS.INCREMENT_PROCESS_PROGRESS(1, 'Sync Account EDC');
   SYNC_ACCOUNT_EDC(v_FROM_DATE);
   LOGS.INCREMENT_PROCESS_PROGRESS(1, 'Sync Account ESP');
   SYNC_ACCOUNT_ESP(v_FROM_DATE);
   LOGS.INCREMENT_PROCESS_PROGRESS(1, 'Sync Account Service Location');
   SYNC_ACCOUNT_SERVICE_LOCATION(v_FROM_DATE);
   LOGS.INCREMENT_PROCESS_PROGRESS(1, 'Sync Aggregate Account');
   SYNC_AGGREGATE_ACCOUNT(v_FROM_DATE, v_TO_DATE);
   LOGS.INCREMENT_PROCESS_PROGRESS(1, 'Sync Aggregate Account Service');
   SYNC_AGGREGATE_ACCOUNT_SERVICE(v_FROM_DATE, v_TO_DATE);
   LOGS.INCREMENT_PROCESS_PROGRESS(1, 'Sync PLC/NSPL');
   SYNC_PLC_NSPL(v_FROM_DATE, v_TO_DATE);
   COMMIT;
   LOGS.UPDATE_PROCESS_PROGRESS(9, 'Complete');
   v_MESSAGE :=  c_ACCOUNT_SYNC_PROCESS || ' Complete. Elapsed Seconds: ' || TO_CHAR(ROUND((DBMS_UTILITY.GET_TIME-v_MARK_TIME)/100));
   LOGS.LOG_INFO(v_MESSAGE);
   LOGS.STOP_PROCESS(v_MESSAGE, v_STATUS);
EXCEPTION
   WHEN OTHERS THEN
      ROLLBACK;
      ERRS.ABORT_PROCESS;
END RUN_INTERFACE;

PROCEDURE DEX_INTERFACE(p_BEGIN_DATE IN DATE, p_END_DATE IN DATE) AS
BEGIN
   RUN_INTERFACE(p_BEGIN_DATE, CASE WHEN p_END_DATE < p_BEGIN_DATE THEN p_BEGIN_DATE ELSE p_END_DATE END - p_BEGIN_DATE + 1);
END DEX_INTERFACE;

END CDI_ACCOUNT_SYNC;
/