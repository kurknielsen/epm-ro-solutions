CREATE OR REPLACE PACKAGE BODY QM AS
---------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
    RETURN '$Revision: 1.174 $';
END WHAT_VERSION;
----------------------------------------------------------------------------------------------------
PROCEDURE NULL_CURSOR
	(
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR SELECT NULL FROM DUAL;

END NULL_CURSOR;
----------------------------------------------------------------------------------------------------
PROCEDURE TRACE_TABLE
	(
	p_NAME IN VARCHAR,
	p_TABLE IN GA.NUMBER_TABLE
	) AS

v_INDEX BINARY_INTEGER;

BEGIN

	IF p_TABLE.COUNT > 0 THEN
		FOR v_INDEX IN p_TABLE.FIRST..p_TABLE.LAST LOOP
			IF p_TABLE.EXISTS(v_INDEX) THEN
				IF v_INDEX =  p_TABLE.FIRST THEN
					LOGS.LOG_DEBUG('TRACE: ' || p_NAME);
					LOGS.LOG_DEBUG('<value>@<index>');
				END IF;
				LOGS.LOG_DEBUG(TO_CHAR(p_TABLE(v_INDEX)) || '@' || TO_CHAR(v_INDEX));
			ELSE
				LOGS.LOG_DEBUG('<missing value at ' || TO_CHAR(v_INDEX) || '>');
			END IF;
		END LOOP;
	ELSE
		LOGS.LOG_DEBUG('TRACE: ' || p_NAME);
		LOGS.LOG_DEBUG('<empty table>');
	END IF;

END TRACE_TABLE;
---------------------------------------------------------------------------------------------------
PROCEDURE TRACE_SPARSE_TABLE
	(
	p_NAME IN VARCHAR,
	p_TABLE IN GA.NUMBER_TABLE
	) AS

v_INDEX BINARY_INTEGER;

BEGIN

	v_INDEX := p_TABLE.FIRST;
	LOOP
		IF p_TABLE.EXISTS(v_INDEX) THEN
			IF v_INDEX =  p_TABLE.FIRST THEN
				LOGS.LOG_DEBUG('TRACE: ' || p_NAME);
				LOGS.LOG_DEBUG('<value>@<index>');
			END IF;
			LOGS.LOG_DEBUG(TO_CHAR(p_TABLE(v_INDEX)) || '@' || TO_CHAR(v_INDEX));
		ELSE
			LOGS.LOG_DEBUG('missing value at ' || TO_CHAR(v_INDEX));
		END IF;
		EXIT WHEN v_INDEX = p_TABLE.LAST;
		v_INDEX := p_TABLE.NEXT(v_INDEX);
	END LOOP;

END TRACE_SPARSE_TABLE;
---------------------------------------------------------------------------------------------------
PROCEDURE EDC_NAMES
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of EDCs of the specified type.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT EDC_NAME, EDC_ID
		FROM ENERGY_DISTRIBUTION_COMPANY
		WHERE UPPER(SUBSTR(EDC_STATUS,1,1)) = 'A'
		ORDER BY EDC_NAME;

END EDC_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE SERVICE_POINT_NAMES
	(
	p_EDC_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of service points associated with retail accounts.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT SERVICE_POINT_NAME, SERVICE_POINT_ID
		FROM SERVICE_POINT
		WHERE EDC_ID = DECODE(p_EDC_ID, CONSTANTS.ALL_ID, EDC_ID, p_EDC_ID)
		ORDER BY SERVICE_POINT_NAME;

END SERVICE_POINT_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE PERIOD_NAMES
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of periods.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT PERIOD_NAME, PERIOD_ID
		FROM PERIOD
		ORDER BY PERIOD_NAME;


END PERIOD_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE TEMPLATE_NAMES
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of TEMPLATEs.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT TEMPLATE_NAME, TEMPLATE_ID
		FROM TEMPLATE
		WHERE NVL(IS_DAY_TYPE, 0) = 0
			AND TEMPLATE_ID > CONSTANTS.NOT_ASSIGNED
		ORDER BY TEMPLATE_NAME;


END TEMPLATE_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE TEMPLATE_PERIOD_NAMES
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the unique combinations of TEMPLATE and PERIOD names in SEASON_TEMPLATE.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT DISTINCT TEMPLATE_NAME || '~' || PERIOD_NAME "TEMPLATE_PERIOD_NAME",
			P.PERIOD_ID "TEMPLATE_PERIOD_ID",
			T.TEMPLATE_ID
		FROM SEASON_TEMPLATE S, TEMPLATE T, PERIOD P
		WHERE S.TEMPLATE_ID = T.TEMPLATE_ID
			AND S.PERIOD_ID = P.PERIOD_ID
		ORDER BY 1;


END TEMPLATE_PERIOD_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE MARKET_PRICE_NAMES
	(
	p_EDC_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of market price names.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT MARKET_PRICE_NAME, MARKET_PRICE_ID
		FROM MARKET_PRICE
		WHERE EDC_ID = DECODE(p_EDC_ID, CONSTANTS.ALL_ID, EDC_ID, p_EDC_ID)
		ORDER BY MARKET_PRICE_NAME;


END MARKET_PRICE_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE PRODUCT_NAMES
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names and IDs of products.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT PRODUCT_NAME, PRODUCT_ID
		FROM PRODUCT
		ORDER BY PRODUCT_NAME;


END PRODUCT_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE CALENDAR_NAMES
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names and IDs of calendars.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT CALENDAR_NAME, CALENDAR_ID
		FROM CALENDAR
		WHERE CALENDAR_ID > 0
		ORDER BY CALENDAR_NAME;


END CALENDAR_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE STATION_NAMES
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of weather station names.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT STATION_NAME, STATION_ID
		FROM WEATHER_STATION
		WHERE STATION_ID > 0
		ORDER BY STATION_NAME;


END STATION_NAMES;
---------------------------------------------------------------------------------------------------
FUNCTION COERCE_DATE
	(
	p_DATE IN DATE,
	p_YEAR IN CHAR
	) RETURN DATE IS

BEGIN

	RETURN(TO_DATE(TO_CHAR(p_DATE,'DD-MON-') || p_YEAR, 'DD-MON-YYYY'));

EXCEPTION
	WHEN ERRS.e_INVALID_DATE THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN (TO_DATE(TO_CHAR(p_DATE - 1,'DD-MON-') || p_YEAR, 'DD-MON-YYYY'));

END COERCE_DATE;
---------------------------------------------------------------------------------------------------
FUNCTION GET_CHARGE_ID
    (
	p_CHARGE_ID IN NUMBER
	) RETURN NUMBER IS

v_CHARGE_ID NUMBER := p_CHARGE_ID;

BEGIN

	IF p_CHARGE_ID = CONSTANTS.NOT_ASSIGNED THEN
		SELECT QID.NEXTVAL INTO v_CHARGE_ID FROM DUAL;
	END IF;

	RETURN v_CHARGE_ID;

END GET_CHARGE_ID;
---------------------------------------------------------------------------------------------------
FUNCTION GET_PROSPECT_ID
    (
	p_PROSPECT_ID IN NUMBER
	) RETURN NUMBER IS

v_PROSPECT_ID NUMBER := p_PROSPECT_ID;

BEGIN

	IF p_PROSPECT_ID = CONSTANTS.NOT_ASSIGNED THEN
		SELECT QID.NEXTVAL INTO v_PROSPECT_ID FROM DUAL;
	END IF;

	RETURN v_PROSPECT_ID;

END GET_PROSPECT_ID;
---------------------------------------------------------------------------------------------------
FUNCTION GET_PROFILE_ID
    (
	p_CALENDAR_ID IN NUMBER,
	p_SERVICE_DATE IN DATE
	) RETURN NUMBER IS

CURSOR c_CALENDAR_PROFILE_LIBRARY IS
	SELECT B.PROFILE_ID, DECODE(TSDN.DAY_NAME,'Hol',0,1) "DAY_NAME_CODE"
	FROM CALENDAR_PROFILE_LIBRARY A,
		LOAD_PROFILE B,
		TEMPLATE_SEASON_DAY_NAME TSDN,
		SEASON D,
		SEASON_DATES I
	WHERE A.CALENDAR_ID = p_CALENDAR_ID
		AND p_SERVICE_DATE BETWEEN A.BEGIN_DATE AND NVL(A.END_DATE, p_SERVICE_DATE)
		AND B.PROFILE_LIBRARY_ID = A.PROFILE_LIBRARY_ID
		AND TSDN.TEMPLATE_ID = B.PROFILE_TEMPLATE_ID
		AND TSDN.DAY_NAME = TO_CHAR(p_SERVICE_DATE,'Dy')
		AND D.SEASON_ID = TSDN.SEASON_ID
		AND I.SEASON_ID = D.SEASON_ID
        AND p_SERVICE_DATE BETWEEN I.BEGIN_DATE AND I.END_DATE  --Replace DATE_IS_WITHIN_SEASON fxn
	ORDER BY DECODE(TSDN.DAY_NAME,'Hol',0,1);

BEGIN

	FOR v_CALENDAR_PROFILE_LIBRARY IN c_CALENDAR_PROFILE_LIBRARY LOOP
		RETURN v_CALENDAR_PROFILE_LIBRARY.PROFILE_ID;
	END LOOP;

	RETURN CONSTANTS.NOT_ASSIGNED;

END GET_PROFILE_ID;
---------------------------------------------------------------------------------------------------
FUNCTION IS_WRF_CALENDAR
	(
	p_CALENDAR_ID IN NUMBER,
	p_SERVICE_DATE IN DATE
	) RETURN BOOLEAN IS

-- Answer true if the calendar specifies a single wrf profile.

v_PROFILE_ID NUMBER(9);
v_PROFILE_TYPE VARCHAR(32);
v_IS_WRF_CALENDAR BOOLEAN := FALSE;

BEGIN

	v_PROFILE_ID := GET_PROFILE_ID(p_CALENDAR_ID, p_SERVICE_DATE);
	IF NOT v_PROFILE_ID = CONSTANTS.NOT_ASSIGNED THEN
		SELECT UPPER(PROFILE_TYPE) INTO v_PROFILE_TYPE FROM LOAD_PROFILE WHERE PROFILE_ID = v_PROFILE_ID;
		v_IS_WRF_CALENDAR := v_PROFILE_TYPE = 'WRF';
	END IF;

	RETURN v_IS_WRF_CALENDAR;

EXCEPTION
	WHEN OTHERS THEN
	    ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN FALSE;

END IS_WRF_CALENDAR;
---------------------------------------------------------------------------------------------------
FUNCTION GET_CALENDAR_NAME
	(
	p_CALENDAR_ID IN NUMBER
	) RETURN VARCHAR IS

v_CALENDAR_NAME CALENDAR.CALENDAR_NAME%TYPE; --@@Implementation Override--

BEGIN

	SELECT CALENDAR_NAME INTO v_CALENDAR_NAME FROM CALENDAR WHERE CALENDAR_ID = p_CALENDAR_ID;

	RETURN v_CALENDAR_NAME;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN 'UNKNOWN';

END GET_CALENDAR_NAME;
---------------------------------------------------------------------------------------------------
FUNCTION GET_LOSS_FACTOR
	(
	p_LOSS_FACTOR_ID IN NUMBER,
	p_SERVICE_DATE IN DATE
	) RETURN NUMBER IS

-- Answer a loss factor containing the transmission and distribution loss factors.

CURSOR c_FACTORS IS
	SELECT UPPER(SUBSTR(A.LOSS_TYPE,1,1)) "LOSS_TYPE", B.EXPANSION_VAL "LOSS_FACTOR_VAL"
	FROM LOSS_FACTOR_MODEL A, LOSS_FACTOR_PATTERN B
	WHERE A.LOSS_FACTOR_ID = p_LOSS_FACTOR_ID
		AND A.LOSS_TYPE IN ('Transmission','Distribution')
		AND A.INTERVAL = 'Day'
		AND p_SERVICE_DATE BETWEEN A.BEGIN_DATE AND NVL(A.END_DATE, p_SERVICE_DATE)
		AND B.PATTERN_ID = A.PATTERN_ID
		AND B.PATTERN_DATE = TRUNC(A.BEGIN_DATE);

v_TRANSMISSION_LOSS_FACTOR NUMBER(10,6) := 0;
v_DISTRIBUTION_LOSS_FACTOR NUMBER(10,6) := 0;

v_CONTAINS_SCHED NUMBER(9) := 0;

BEGIN

	SELECT COUNT(1) INTO v_CONTAINS_SCHED
	FROM LOSS_FACTOR_MODEL MODEL
	WHERE MODEL.LOSS_FACTOR_ID = p_LOSS_FACTOR_ID
	AND MODEL.LOSS_TYPE IN ('Transmission','Distribution')
	AND MODEL.INTERVAL = 'Day'
	AND p_SERVICE_DATE BETWEEN MODEL.BEGIN_DATE AND NVL(MODEL.END_DATE, p_SERVICE_DATE)
	AND MODEL.MODEL_TYPE = CONSTANTS.LOSS_FACTOR_MODEL_SCHEDULE;

	IF NVL(v_CONTAINS_SCHED, 0) > 0 THEN

	  LOGS.LOG_WARN(TEXT_UTIL.TO_CHAR_ENTITY(p_LOSS_FACTOR_ID, EC.ED_LOSS_FACTOR, TRUE) ||
	  	' is associated with models of type Schedule.  This is not supported.');

	  RETURN 1.0;

	ELSE

	  FOR v_FACTORS IN c_FACTORS LOOP
		  IF v_FACTORS.LOSS_TYPE = 'T' THEN
			  v_TRANSMISSION_LOSS_FACTOR := v_FACTORS.LOSS_FACTOR_VAL;
		  ELSE
			  v_DISTRIBUTION_LOSS_FACTOR := v_FACTORS.LOSS_FACTOR_VAL;
		  END IF;
	  END LOOP;

	  RETURN (1.0 + v_TRANSMISSION_LOSS_FACTOR) * (1.0 + v_DISTRIBUTION_LOSS_FACTOR);

	END IF;



END GET_LOSS_FACTOR;
---------------------------------------------------------------------------------------------------
FUNCTION GET_TEMPLATE_FOR_PRODUCT
	(
	p_PRODUCT_ID IN NUMBER,
	p_SERVICE_DATE IN DATE
	) RETURN VARCHAR IS

CURSOR c_TEMPLATES IS
	SELECT DISTINCT B.TEMPLATE_ID
	FROM PRODUCT_COMPONENT A, COMPONENT B
	WHERE A.PRODUCT_ID = p_PRODUCT_ID
		AND p_SERVICE_DATE BETWEEN A.BEGIN_DATE AND NVL(A.END_DATE, HIGH_DATE)
		AND B.COMPONENT_ID = A.COMPONENT_ID
	ORDER BY 1 DESC;

v_TEMPLATE_ID NUMBER(9) := CONSTANTS.NOT_ASSIGNED;

BEGIN

	FOR v_TEMPLATES IN c_TEMPLATES LOOP
		v_TEMPLATE_ID := v_TEMPLATES.TEMPLATE_ID;
		EXIT;
	END LOOP;

	RETURN v_TEMPLATE_ID;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN CONSTANTS.NOT_ASSIGNED;

END GET_TEMPLATE_FOR_PRODUCT;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_PARTICIPANT_ENROLLMENT
	(
	p_EVALUATION_ID IN NUMBER,
	p_PARTICIPANT_ID IN NUMBER,
	p_ENROLLMENT IN OUT NOCOPY GA.NUMBER_TABLE
	) AS

CURSOR c_ENROLLMENT IS
	SELECT ENROLLMENT_MONTH, ENROLLMENT
	FROM POSITION_ANALYSIS_ENROLLMENT
	WHERE EVALUATION_ID = p_EVALUATION_ID
		AND PARTICIPANT_ID = p_PARTICIPANT_ID;

BEGIN

	FOR v_ENROLLMENT IN c_ENROLLMENT LOOP
		p_ENROLLMENT(TO_CHAR(v_ENROLLMENT.ENROLLMENT_MONTH,'J')) := v_ENROLLMENT.ENROLLMENT;
	END LOOP;

END GET_PARTICIPANT_ENROLLMENT;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_QUOTE_CALENDAR_PRODUCT
	(
	p_QUOTE_ID IN NUMBER,
	p_QUOTE_SCENARIO IN VARCHAR,
	p_PROFILE_CALENDAR_ID IN NUMBER,
	p_OFFER_PRODUCT_ID IN NUMBER,
	p_COST_PRODUCT_ID IN NUMBER,
	p_COMPARE_PRODUCT_ID IN NUMBER,
	p_LOSS_FACTOR_ID IN NUMBER,
	p_IS_SELECTED_OFFER IN NUMBER,
	p_USE_BILLING_DETERMINANTS IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	p_STATUS := GA.SUCCESS;

	UPDATE QUOTE_CALENDAR_PRODUCT SET
		PROFILE_CALENDAR_ID = p_PROFILE_CALENDAR_ID,
		OFFER_PRODUCT_ID = p_OFFER_PRODUCT_ID,
		COST_PRODUCT_ID = p_COST_PRODUCT_ID,
		COMPARE_PRODUCT_ID = p_COMPARE_PRODUCT_ID,
		LOSS_FACTOR_ID = p_LOSS_FACTOR_ID,
		IS_SELECTED_OFFER = DECODE(p_IS_SELECTED_OFFER, 1,1,0),
		USE_BILLING_DETERMINANTS = DECODE(p_USE_BILLING_DETERMINANTS, 1,1,0),
		ENTRY_DATE = SYSDATE
	WHERE QUOTE_ID = p_QUOTE_ID
		AND QUOTE_SCENARIO = p_QUOTE_SCENARIO;

	IF SQL%NOTFOUND THEN
		INSERT INTO QUOTE_CALENDAR_PRODUCT (
			QUOTE_ID,
			QUOTE_SCENARIO,
			PROFILE_CALENDAR_ID,
			OFFER_PRODUCT_ID,
			COST_PRODUCT_ID,
			COMPARE_PRODUCT_ID,
			LOSS_FACTOR_ID,
			IS_SELECTED_OFFER,
			USE_BILLING_DETERMINANTS,
			ENTRY_DATE)
		VALUES (
			p_QUOTE_ID,
			p_QUOTE_SCENARIO,
			p_PROFILE_CALENDAR_ID,
			p_OFFER_PRODUCT_ID,
			p_COST_PRODUCT_ID,
			p_COMPARE_PRODUCT_ID,
			p_LOSS_FACTOR_ID,
			DECODE(p_IS_SELECTED_OFFER, 1,1,0),
			DECODE(p_USE_BILLING_DETERMINANTS, 1,1,0),
			SYSDATE);
	END IF;


END PUT_QUOTE_CALENDAR_PRODUCT;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_QUOTE_BILLING_DETERMINANT
    (
	p_QUOTE_ID IN NUMBER,
	p_PERIOD_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_DEMAND IN NUMBER,
	p_ENERGY IN NUMBER,
	p_OLD_PERIOD_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_OLD_END_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	p_STATUS := GA.SUCCESS;

    UPDATE QUOTE_BILLING_DETERMINANT SET
		PERIOD_ID = p_PERIOD_ID,
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(p_END_DATE),
		DEMAND = p_DEMAND,
		ENERGY = p_ENERGY,
		ENTRY_DATE = SYSDATE
	WHERE QUOTE_ID = p_QUOTE_ID
		AND PERIOD_ID = p_OLD_PERIOD_ID
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE)
		AND END_DATE = TRUNC(p_OLD_END_DATE);

	IF SQL%NOTFOUND THEN
		INSERT INTO QUOTE_BILLING_DETERMINANT (
			QUOTE_ID,
			PERIOD_ID,
			BEGIN_DATE,
			END_DATE,
			DEMAND,
			ENERGY,
			ENTRY_DATE)
		VALUES (
			p_QUOTE_ID,
			p_PERIOD_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(p_END_DATE),
			p_DEMAND,
			p_ENERGY,
			SYSDATE);
	END IF;


END PUT_QUOTE_BILLING_DETERMINANT;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_QUOTE_COMPONENT_CHARGE
	(
	p_QUOTE_COMPONENT_CHARGE IN QUOTE_COMPONENT_CHARGE%ROWTYPE
	) AS

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG(TO_CHAR(p_QUOTE_COMPONENT_CHARGE.CHARGE_ID) || ',' ||
			UT.TRACE_DATE(p_QUOTE_COMPONENT_CHARGE.CHARGE_DATE) || ',' ||
			TO_CHAR(p_QUOTE_COMPONENT_CHARGE.PERIOD_ID) || ',' ||
			TO_CHAR(p_QUOTE_COMPONENT_CHARGE.CHARGE_ENERGY) || ',' ||
			TO_CHAR(p_QUOTE_COMPONENT_CHARGE.CHARGE_DEMAND) || ',' ||
			TO_CHAR(p_QUOTE_COMPONENT_CHARGE.CHARGE_RATE) || ',' ||
			TO_CHAR(p_QUOTE_COMPONENT_CHARGE.CHARGE_AMOUNT) || ',' ||
			TO_CHAR(p_QUOTE_COMPONENT_CHARGE.CHARGE_FACTOR));
	END IF;

	INSERT INTO QUOTE_COMPONENT_CHARGE (
		CHARGE_ID,
		CHARGE_DATE,
		PERIOD_ID,
		CHARGE_ENERGY,
		CHARGE_DEMAND,
		CHARGE_RATE,
		CHARGE_AMOUNT,
		CHARGE_FACTOR)
	VALUES (
		p_QUOTE_COMPONENT_CHARGE.CHARGE_ID,
		p_QUOTE_COMPONENT_CHARGE.CHARGE_DATE,
		p_QUOTE_COMPONENT_CHARGE.PERIOD_ID,
		p_QUOTE_COMPONENT_CHARGE.CHARGE_ENERGY,
		p_QUOTE_COMPONENT_CHARGE.CHARGE_DEMAND,
		p_QUOTE_COMPONENT_CHARGE.CHARGE_RATE,
		p_QUOTE_COMPONENT_CHARGE.CHARGE_AMOUNT,
		p_QUOTE_COMPONENT_CHARGE.CHARGE_FACTOR);

END PUT_QUOTE_COMPONENT_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_QUOTE_COMPONENT_POSITION
    (
	p_QUOTE_COMPONENT_POSITION IN OUT QUOTE_COMPONENT_POSITION%ROWTYPE
	) AS

BEGIN

 	IF LOGS.IS_DEBUG_ENABLED THEN
 		LOGS.LOG_DEBUG(TO_CHAR(p_QUOTE_COMPONENT_POSITION.QUOTE_ID) || ',' ||
 			p_QUOTE_COMPONENT_POSITION.QUOTE_SCENARIO || ',' ||
			UT.TRACE_DATE(p_QUOTE_COMPONENT_POSITION.QUOTE_MONTH) || ',' ||
 			TO_CHAR(p_QUOTE_COMPONENT_POSITION.PERIOD_ID) || ',' ||
 			TO_CHAR(p_QUOTE_COMPONENT_POSITION.QUOTE_ENERGY) || ',' ||
 			TO_CHAR(p_QUOTE_COMPONENT_POSITION.QUOTE_DEMAND) || ',' ||
 			TO_CHAR(p_QUOTE_COMPONENT_POSITION.QUOTE_REVENUE) || ',' ||
 			TO_CHAR(p_QUOTE_COMPONENT_POSITION.QUOTE_COST));
 	END IF;

	UPDATE QUOTE_COMPONENT_POSITION SET
		QUOTE_ENERGY = QUOTE_ENERGY + p_QUOTE_COMPONENT_POSITION.QUOTE_ENERGY,
		QUOTE_DEMAND = GREATEST(QUOTE_DEMAND,p_QUOTE_COMPONENT_POSITION.QUOTE_DEMAND),
		QUOTE_REVENUE = QUOTE_REVENUE + p_QUOTE_COMPONENT_POSITION.QUOTE_REVENUE,
		QUOTE_COST = QUOTE_COST + p_QUOTE_COMPONENT_POSITION.QUOTE_COST
	WHERE QUOTE_ID = p_QUOTE_COMPONENT_POSITION.QUOTE_ID
		AND QUOTE_SCENARIO = p_QUOTE_COMPONENT_POSITION.QUOTE_SCENARIO
		AND QUOTE_MONTH = p_QUOTE_COMPONENT_POSITION.QUOTE_MONTH
		AND PERIOD_ID = p_QUOTE_COMPONENT_POSITION.PERIOD_ID;

	IF SQL%NOTFOUND THEN
		INSERT INTO QUOTE_COMPONENT_POSITION (
			QUOTE_ID,
			QUOTE_SCENARIO,
			QUOTE_MONTH,
			PERIOD_ID,
			QUOTE_ENERGY,
			QUOTE_DEMAND,
			QUOTE_REVENUE,
			QUOTE_COST)
		VALUES (
			p_QUOTE_COMPONENT_POSITION.QUOTE_ID,
			p_QUOTE_COMPONENT_POSITION.QUOTE_SCENARIO,
			p_QUOTE_COMPONENT_POSITION.QUOTE_MONTH,
			p_QUOTE_COMPONENT_POSITION.PERIOD_ID,
			p_QUOTE_COMPONENT_POSITION.QUOTE_ENERGY,
			p_QUOTE_COMPONENT_POSITION.QUOTE_DEMAND,
			p_QUOTE_COMPONENT_POSITION.QUOTE_REVENUE,
			p_QUOTE_COMPONENT_POSITION.QUOTE_COST);
	END IF;

END PUT_QUOTE_COMPONENT_POSITION;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_QUOTE_COMPONENT_POSITION
	(
	p_QUOTE_ID IN NUMBER,
	p_QUOTE_SCENARIO IN VARCHAR,
	p_NUMBER_OF_CUSTOMERS IN NUMBER,
	p_DETERMINANTS IN DETERMINANT_TABLE,
	p_OFFER IN CHARGE_COMPONENT_TABLE,
	p_COST IN CHARGE_COMPONENT_TABLE,
	p_COMPARE IN CHARGE_COMPONENT_TABLE
	) AS

CURSOR c_DETERMINANTS IS
	SELECT TRUNC(A.DAY_DATE(),'MONTH') "MONTH",
		SUM(A.DETERMINANT_1) * p_NUMBER_OF_CUSTOMERS "ENERGY",
		MAX(A.DETERMINANT_2) * p_NUMBER_OF_CUSTOMERS "DEMAND"
	FROM TABLE(CAST(p_DETERMINANTS AS DETERMINANT_TABLE)) A
	GROUP BY TRUNC(A.DAY_DATE(),'MONTH');

CURSOR c_REVENUE IS
	SELECT TRUNC(A.BEGIN_DATE,'MONTH') "MONTH",
		SUM(A.AMOUNT) * p_NUMBER_OF_CUSTOMERS "AMOUNT"
	FROM TABLE(CAST(p_OFFER AS CHARGE_COMPONENT_TABLE)) A
	GROUP BY TRUNC(A.BEGIN_DATE,'MONTH');

CURSOR c_COST IS
	SELECT TRUNC(A.BEGIN_DATE,'MONTH') "MONTH",
		SUM(A.AMOUNT) * p_NUMBER_OF_CUSTOMERS "AMOUNT"
	FROM TABLE(CAST(p_COST AS CHARGE_COMPONENT_TABLE)) A
	GROUP BY TRUNC(A.BEGIN_DATE,'MONTH');

CURSOR c_COMPARE IS
	SELECT TRUNC(A.BEGIN_DATE,'MONTH') "MONTH",
		SUM(A.AMOUNT) * p_NUMBER_OF_CUSTOMERS "AMOUNT"
	FROM TABLE(CAST(p_COMPARE AS CHARGE_COMPONENT_TABLE)) A
	GROUP BY TRUNC(A.BEGIN_DATE,'MONTH');

BEGIN

	DELETE QUOTE_COMPONENT_POSITION WHERE QUOTE_ID = p_QUOTE_ID AND QUOTE_SCENARIO = p_QUOTE_SCENARIO;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PUT_QUOTE_COMPONENT_POSITION DETERMINANTS...');
	END IF;

	FOR v_DETERMINANTS IN c_DETERMINANTS LOOP
		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG(TO_CHAR(v_DETERMINANTS.MONTH) || ',' || TO_CHAR(v_DETERMINANTS.ENERGY) || ',' || TO_CHAR(v_DETERMINANTS.DEMAND));
		END IF;
		INSERT INTO QUOTE_COMPONENT_POSITION(QUOTE_ID, QUOTE_SCENARIO, QUOTE_MONTH, PERIOD_ID, QUOTE_ENERGY, QUOTE_DEMAND)
		VALUES(p_QUOTE_ID, p_QUOTE_SCENARIO, v_DETERMINANTS.MONTH, CONSTANTS.ALL_ID, v_DETERMINANTS.ENERGY, v_DETERMINANTS.DEMAND);
	END LOOP;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PUT_QUOTE_COMPONENT_POSITION REVENUE...');
	END IF;

	FOR v_REVENUE IN c_REVENUE LOOP
		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG(TO_CHAR(v_REVENUE.MONTH) || ',' || TO_CHAR(v_REVENUE.AMOUNT));
		END IF;
		UPDATE QUOTE_COMPONENT_POSITION
		SET QUOTE_REVENUE = v_REVENUE.AMOUNT
		WHERE QUOTE_ID = p_QUOTE_ID
			AND QUOTE_SCENARIO = p_QUOTE_SCENARIO
			AND QUOTE_MONTH = v_REVENUE.MONTH
			AND PERIOD_ID = CONSTANTS.ALL_ID;
	END LOOP;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PUT_QUOTE_COMPONENT_POSITION COST...');
	END IF;

	FOR v_COST IN c_COST LOOP
		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG(TO_CHAR(v_COST.MONTH) || ',' || TO_CHAR(v_COST.AMOUNT));
		END IF;
		UPDATE QUOTE_COMPONENT_POSITION
		SET QUOTE_COST = v_COST.AMOUNT
		WHERE QUOTE_ID = p_QUOTE_ID
			AND QUOTE_SCENARIO = p_QUOTE_SCENARIO
			AND QUOTE_MONTH = v_COST.MONTH
			AND PERIOD_ID = CONSTANTS.ALL_ID;
	END LOOP;
	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PUT_QUOTE_COMPONENT_POSITION COMPARE...');
	END IF;

	FOR v_COMPARE IN c_COMPARE LOOP
		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG(TO_CHAR(v_COMPARE.MONTH) || ',' || TO_CHAR(v_COMPARE.AMOUNT));
		END IF;
		UPDATE QUOTE_COMPONENT_POSITION
		SET QUOTE_COMPARE = v_COMPARE.AMOUNT
		WHERE QUOTE_ID = p_QUOTE_ID
			AND QUOTE_SCENARIO = p_QUOTE_SCENARIO
			AND QUOTE_MONTH = v_COMPARE.MONTH
			AND PERIOD_ID = CONSTANTS.ALL_ID;
	END LOOP;

END PUT_QUOTE_COMPONENT_POSITION;
---------------------------------------------------------------------------------------------------
PROCEDURE CREATE_QUOTE_POSITION
    (
	p_QUOTE_ID IN NUMBER,
	p_QUOTE_SCENARIO IN VARCHAR
	) AS

CURSOR c_CHARGES IS
	SELECT A.PRODUCT_CATEGORY,
		TRUNC(CHARGE_DATE,'MONTH') "QUOTE_MONTH",
		DECODE(UPPER(C.RATE_STRUCTURE), 'MARKET',0,PERIOD_ID) "PERIOD_ID",
		SUM(CHARGE_ENERGY) "QUOTE_ENERGY",
		MAX(CHARGE_DEMAND) "QUOTE_DEMAND",
		SUM(CHARGE_AMOUNT) "QUOTE_REVENUE"
	FROM QUOTE_COMPONENT A, QUOTE_COMPONENT_CHARGE B, COMPONENT C
	WHERE A.QUOTE_ID = p_QUOTE_ID
		AND A.QUOTE_SCENARIO = p_QUOTE_SCENARIO
		AND A.PRODUCT_CATEGORY = 'R'
		AND B.CHARGE_ID =  A.CHARGE_ID
		AND C.COMPONENT_ID = A.COMPONENT_ID
	GROUP BY A.PRODUCT_CATEGORY, TRUNC(CHARGE_DATE,'MONTH'), DECODE(UPPER(C.RATE_STRUCTURE), 'MARKET',0,PERIOD_ID)
	UNION
	SELECT A.PRODUCT_CATEGORY,
		TRUNC(CHARGE_DATE,'MONTH') "QUOTE_MONTH",
		DECODE(UPPER(C.RATE_STRUCTURE), 'MARKET',0,PERIOD_ID) "PERIOD_ID",
		SUM(CHARGE_ENERGY) "QUOTE_ENERGY",
		MAX(CHARGE_DEMAND) "QUOTE_DEMAND",
		SUM(CHARGE_AMOUNT) "QUOTE_REVENUE"
	FROM QUOTE_COMPONENT A, QUOTE_COMPONENT_CHARGE B, COMPONENT C
	WHERE A.QUOTE_ID = p_QUOTE_ID
		AND A.QUOTE_SCENARIO = p_QUOTE_SCENARIO
		AND A.PRODUCT_CATEGORY = 'C'
		AND B.CHARGE_ID =  A.CHARGE_ID
		AND C.COMPONENT_ID = A.COMPONENT_ID
	GROUP BY A.PRODUCT_CATEGORY, TRUNC(CHARGE_DATE,'MONTH'), DECODE(UPPER(C.RATE_STRUCTURE), 'MARKET',0,PERIOD_ID);

v_QUOTE_COMPONENT_POSITION QUOTE_COMPONENT_POSITION%ROWTYPE;

BEGIN

	v_QUOTE_COMPONENT_POSITION.QUOTE_ID := p_QUOTE_ID;
	v_QUOTE_COMPONENT_POSITION.QUOTE_SCENARIO :=  p_QUOTE_SCENARIO;

	FOR v_CHARGES IN c_CHARGES LOOP
		v_QUOTE_COMPONENT_POSITION.QUOTE_MONTH := v_CHARGES.QUOTE_MONTH;
		v_QUOTE_COMPONENT_POSITION.PERIOD_ID := v_CHARGES.PERIOD_ID;
		IF v_CHARGES.PRODUCT_CATEGORY = 'R' THEN
			v_QUOTE_COMPONENT_POSITION.QUOTE_REVENUE := v_CHARGES.QUOTE_REVENUE;
			v_QUOTE_COMPONENT_POSITION.QUOTE_COST := 0;
			v_QUOTE_COMPONENT_POSITION.QUOTE_ENERGY := v_CHARGES.QUOTE_ENERGY;
			v_QUOTE_COMPONENT_POSITION.QUOTE_DEMAND := v_CHARGES.QUOTE_DEMAND;
		ELSE
			v_QUOTE_COMPONENT_POSITION.QUOTE_REVENUE := 0;
			v_QUOTE_COMPONENT_POSITION.QUOTE_COST := v_CHARGES.QUOTE_REVENUE;
			v_QUOTE_COMPONENT_POSITION.QUOTE_ENERGY := 0;
			v_QUOTE_COMPONENT_POSITION.QUOTE_DEMAND := 0;
		END IF;
		PUT_QUOTE_COMPONENT_POSITION(v_QUOTE_COMPONENT_POSITION);
	END LOOP;

END CREATE_QUOTE_POSITION;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_QUOTE_COMPONENT
    (
	p_QUOTE_COMPONENT IN OUT QUOTE_COMPONENT%ROWTYPE
	) AS

BEGIN

 	IF LOGS.IS_DEBUG_ENABLED THEN
 		LOGS.LOG_DEBUG(TO_CHAR(p_QUOTE_COMPONENT.QUOTE_ID) || ',' ||
 			p_QUOTE_COMPONENT.QUOTE_SCENARIO || ',' ||
 			p_QUOTE_COMPONENT.PRODUCT_CATEGORY || ',' ||
 			TO_CHAR(p_QUOTE_COMPONENT.PRODUCT_ID) || ',' ||
 			TO_CHAR(p_QUOTE_COMPONENT.COMPONENT_ID) || ',' ||
 			TO_CHAR(p_QUOTE_COMPONENT.CHARGE_ID));
 	END IF;

	IF NOT p_QUOTE_COMPONENT.CHARGE_ID = CONSTANTS.NOT_ASSIGNED THEN
		INSERT INTO QUOTE_COMPONENT (
			QUOTE_ID,
			QUOTE_SCENARIO,
			PRODUCT_CATEGORY,
			PRODUCT_ID,
			COMPONENT_ID,
			CHARGE_ID,
			ENTRY_DATE)
		VALUES (
			p_QUOTE_COMPONENT.QUOTE_ID,
			p_QUOTE_COMPONENT.QUOTE_SCENARIO,
			p_QUOTE_COMPONENT.PRODUCT_CATEGORY,
			p_QUOTE_COMPONENT.PRODUCT_ID,
			p_QUOTE_COMPONENT.COMPONENT_ID,
			p_QUOTE_COMPONENT.CHARGE_ID,
			SYSDATE);
	END IF;

END PUT_QUOTE_COMPONENT;
---------------------------------------------------------------------------------------------------
PROCEDURE PROFILE_ADJUSTMENT
    (
	p_FACTOR IN NUMBER,
	p_ENERGY OUT NUMBER,
	p_DEMAND OUT NUMBER,
	p_PROFILE IN OUT GA.NUMBER_TABLE
	) AS

BEGIN

	p_ENERGY := 0;
	p_DEMAND := 0;

	FOR v_INDEX IN p_PROFILE.FIRST..p_PROFILE.LAST LOOP
		IF p_PROFILE.EXISTS(v_INDEX) THEN
			p_PROFILE(v_INDEX) := p_PROFILE(v_INDEX) * p_FACTOR;
			p_ENERGY := p_ENERGY + p_PROFILE(v_INDEX);
			IF p_PROFILE(v_INDEX) > p_DEMAND THEN
				p_DEMAND := p_PROFILE(v_INDEX);
			END IF;
		END IF;
	END LOOP;

END PROFILE_ADJUSTMENT;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_BILLING_DETERMINANTS
	(
	p_QUOTE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CONSUMPTION IN OUT NOCOPY CONSUMPTION_TABLE,
	p_EARLIEST_BEGIN_DATE OUT DATE,
	p_LATEST_END_DATE OUT DATE
	) AS

CURSOR c_DETERMINANT IS
	SELECT PERIOD_ID, BEGIN_DATE, END_DATE, DEMAND, ENERGY
	FROM QUOTE_BILLING_DETERMINANT
	WHERE QUOTE_ID = p_QUOTE_ID;

v_BEGIN_YEAR CHAR(4) := TO_CHAR(p_BEGIN_DATE, 'YYYY');
v_END_YEAR CHAR(4) := TO_CHAR(p_END_DATE, 'YYYY');
v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('GET_BILLING_DETERMINANTS');
	END IF;

	p_CONSUMPTION.DELETE;
	p_EARLIEST_BEGIN_DATE := HIGH_DATE;
	p_LATEST_END_DATE := LOW_DATE;

	FOR v_DETERMINANT IN c_DETERMINANT LOOP
		p_CONSUMPTION.EXTEND;
		p_CONSUMPTION(p_CONSUMPTION.LAST) := CONSUMPTION_TYPE(v_DETERMINANT.BEGIN_DATE, v_DETERMINANT.END_DATE, CONSTANTS.NOT_ASSIGNED, v_DETERMINANT.PERIOD_ID, v_DETERMINANT.ENERGY, v_DETERMINANT.DEMAND);
		v_BEGIN_DATE := COERCE_DATE(v_DETERMINANT.BEGIN_DATE, v_BEGIN_YEAR);
		v_END_DATE := COERCE_DATE(v_DETERMINANT.END_DATE, v_END_YEAR);
		IF v_BEGIN_DATE <= p_END_DATE AND v_END_DATE >= p_BEGIN_DATE THEN
			IF v_BEGIN_DATE < p_EARLIEST_BEGIN_DATE THEN
				p_EARLIEST_BEGIN_DATE := v_BEGIN_DATE;
			END IF;
			IF v_END_DATE > p_LATEST_END_DATE THEN
				p_LATEST_END_DATE := v_END_DATE;
			END IF;
		END IF;
	END LOOP;

END GET_BILLING_DETERMINANTS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_QUOTE_DETERMINANTS
	(
	p_QUOTE_ID IN NUMBER,
	p_CALENDAR_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_STATION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_USE_BILLING_DETERMINANTS IN NUMBER,
	p_DETERMINANTS IN OUT NOCOPY DETERMINANT_TABLE
	) AS

v_EARLIEST_BEGIN_DATE DATE;
v_LATEST_END_DATE DATE;
v_CONSUMPTION CONSUMPTION_TABLE := CONSUMPTION_TABLE();
v_DETERMINANTS DETERMINANT_TABLE := DETERMINANT_TABLE();

BEGIN

	IF p_USE_BILLING_DETERMINANTS = 1 THEN
		GET_BILLING_DETERMINANTS(p_QUOTE_ID, p_BEGIN_DATE, p_END_DATE, v_CONSUMPTION, v_EARLIEST_BEGIN_DATE, v_LATEST_END_DATE);
		CU.GET_PROJECTION_DETERMINANTS(p_CALENDAR_ID, 'DAY', p_TEMPLATE_ID, p_STATION_ID, v_EARLIEST_BEGIN_DATE, v_LATEST_END_DATE, p_AS_OF_DATE, LOGS.IS_DEBUG_DETAIL_ENABLED, v_DETERMINANTS);
		CU.GET_PRORATED_CONSUMPTION(p_BEGIN_DATE, p_END_DATE, v_DETERMINANTS, v_CONSUMPTION, LOGS.IS_DEBUG_DETAIL_ENABLED, p_DETERMINANTS);
	ELSE
		CU.GET_PROJECTION_DETERMINANTS(p_CALENDAR_ID, 'DAY', CONSTANTS.NOT_ASSIGNED, p_STATION_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, LOGS.IS_DEBUG_DETAIL_ENABLED, p_DETERMINANTS);
	END IF;

END GET_QUOTE_DETERMINANTS;
---------------------------------------------------------------------------------------------------
PROCEDURE UPDATE_QUOTE_SEASONAL_RATES
	(
	p_QUOTE_ID IN NUMBER,
	p_SERVICE_BEGIN_DATE IN DATE,
	p_SERVICE_END_DATE IN DATE,
	p_PERIOD_ID IN NUMBER,
	p_TRACE_ON IN NUMBER,
	p_STATUS IN OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS


BEGIN
    --First, update the Q.PRICING_SEASON, grouping months that match the seasons in QUOTE_PRICING_SEASON
    UPDATE QUOTE_COMPONENT_POSITION Q SET
    PRICING_SEASON =
        (SELECT nvl(S.PRICING_SEASON,'<none>')
        FROM QUOTE_PRICING_SEASON S
        WHERE S.QUOTE_ID = Q.QUOTE_ID
            AND S.PRICING_MONTH = TO_NUMBER(TO_CHAR(Q.QUOTE_MONTH,'MM'))
        )
    WHERE  Q.QUOTE_ID = p_QUOTE_ID
            AND Q.QUOTE_MONTH BETWEEN TRUNC(p_SERVICE_BEGIN_DATE, 'MONTH') AND LAST_DAY(p_SERVICE_END_DATE)
    		AND PERIOD_ID = p_PERIOD_ID;

    --Then update the Q.SEASONAL_rates grouped by PRICING_SEASON
    --Note: an attempted merge of these 2 update queries did not yield correct SUMs of grouped rates.
    UPDATE QUOTE_COMPONENT_POSITION Q
    SET (SEASONAL_COST_RATE, SEASONAL_COMPARE_RATE, SEASONAL_REVENUE_RATE) =
        (SELECT
            ROUND((SUM(NVL(Q2.QUOTE_COST,0))) / (GREATEST(SUM(NVL(Q2.QUOTE_ENERGY, 0)),0.0001)),5) "SEASONAL_COST_RATE",
            ROUND((SUM(NVL(Q2.QUOTE_COMPARE,0))) / (GREATEST(SUM(NVL(Q2.QUOTE_ENERGY, 0)),0.0001)),5) "SEASONAL_COMPARE_RATE",
            ROUND((SUM(NVL(Q2.QUOTE_REVENUE,0))) / (GREATEST(SUM(NVL(Q2.QUOTE_ENERGY, 0)),0.0001)),5) "SEASONAL_REVENUE_RATE"
       FROM QUOTE_COMPONENT_POSITION Q2
        WHERE  Q2.QUOTE_ID = Q.QUOTE_ID
            AND NVL(Q2.PRICING_SEASON,'X') = NVL(Q.PRICING_SEASON,'X')   --Needed to create result row even for Null season
    		AND Q2.PERIOD_ID = p_PERIOD_ID
        )
    WHERE  Q.QUOTE_ID = p_QUOTE_ID
            AND Q.QUOTE_MONTH BETWEEN TRUNC(p_SERVICE_BEGIN_DATE, 'MONTH') AND LAST_DAY(p_SERVICE_END_DATE)
    		AND PERIOD_ID = p_PERIOD_ID;

END UPDATE_QUOTE_SEASONAL_RATES;
---------------------------------------------------------------------------------------------------
PROCEDURE APPLY_PRODUCT_COMPONENT_CHARGE
	(
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_PERIOD_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ENROLLMENT IN NUMBER,
	p_LOSS_FACTOR IN NUMBER,
	p_STATION_ID IN NUMBER,
	p_CALENDAR_ID IN NUMBER,
	p_BILL_CYCLE_ID IN NUMBER,
	p_DETERMINANTS IN DETERMINANT_TABLE,
	p_CHARGE_COMPONENTS IN OUT NOCOPY CHARGE_COMPONENT_TABLE,
    p_NEED_PERIOD_IDs IN BOOLEAN := FALSE,
    p_INTERVAL_DETERMINANTS IN BOOLEAN := FALSE
	) AS

--Calculate QUANTITY, RATE, and Charge AMOUNT for the given Product Component.
--Moved from CU to avoid circular package reference after adding call to FS.COMPOSITE_PROFILE_FOR_CALENDAR
-- in support of hourly Market Price calculations. -06/28/2004-wjc

v_CHARGE_TYPE CHAR(1);
v_BEGIN_DATE DATE := TRUNC(p_BEGIN_DATE);
v_END_DATE DATE;
v_DATE DATE;
v_QUANTITY NUMBER(16,6);
v_RATE NUMBER(16,6);
v_AMOUNT NUMBER(16,6);
v_FACTOR NUMBER(16,6);
v_ENERGY NUMBER(16,6);
v_DEMAND NUMBER(16,6);
v_LOAD NUMBER(16,6);
v_RATE_STRUCTURE VARCHAR(16) := UPPER(LTRIM(RTRIM(p_COMPONENT.RATE_STRUCTURE)));
v_MARKET_PRICE_TABLE GA.NUMBER_TABLE;
v_INDEX BINARY_INTEGER;
v_MP_INDEX BINARY_INTEGER;
v_COMPOSITE_PROFILE_STRING VARCHAR2(1024);
v_PROFILE_STRING_TABLE GA.STRING_TABLE;
v_NEED_AMOUNT_CALC BOOLEAN;

BEGIN

	IF UPPER(p_COMPONENT.CHARGE_TYPE) = 'CONSUMPTION' THEN
		CU.APPLY_CONSUMPTION_CHARGE(p_PRODUCT_ID, p_COMPONENT, p_DETERMINANTS, p_CHARGE_COMPONENTS);
		RETURN;
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('APPLY_PRODUCT_COMPONENT_CHARGE PERIOD_ID=' || TO_CHAR(p_PERIOD_ID) || ', BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE) || ', END_DATE=' || TO_CHAR(p_END_DATE));
		LOGS.LOG_DEBUG('COMPONENT_ID=' || TO_CHAR(p_COMPONENT.COMPONENT_ID) || ', CHARGE_TYPE=' || p_COMPONENT.CHARGE_TYPE || ', RATE_STRUCTURE=' || p_COMPONENT.RATE_STRUCTURE || ', RATE_INTERVAL=' || p_COMPONENT.RATE_INTERVAL || ', UPPER( RATE_STRUCTURE)=' || v_RATE_STRUCTURE);
		LOGS.LOG_DEBUG('<begin>,<end>,<quantity>,<rate>,<amount>,<tax>');
	END IF;

	SELECT DECODE(UPPER(p_COMPONENT.CHARGE_TYPE), 'ENERGY', 'E', 'PEAK DEMAND', 'D', 'SERVICE', 'S', 'DEMAND HOURS', 'H', 'COMMODITY', 'E', 'TRANSPORTATION', 'E', '?') INTO v_CHARGE_TYPE FROM DUAL;
	-- Bugzilla 4967 - Treat transmission and distribution charges as energy if in *WHs
	IF (UPPER(p_COMPONENT.CHARGE_TYPE) = 'TRANSMISSION' OR UPPER(p_COMPONENT.CHARGE_TYPE) = 'DISTRIBUTION') AND (INSTR(UPPER(p_COMPONENT.QUANTITY_UNIT),'WH')>0) THEN
		v_CHARGE_TYPE := 'E';
	END IF;

	v_BEGIN_DATE := CU.GET_INITIAL_DATE_FOR_INTERVAL(v_BEGIN_DATE, p_COMPONENT.RATE_INTERVAL, p_BILL_CYCLE_ID);

	WHILE v_BEGIN_DATE <= p_END_DATE LOOP

		v_END_DATE := CU.GET_NEXT_DATE_FOR_INTERVAL(v_BEGIN_DATE, p_COMPONENT.RATE_INTERVAL, p_BILL_CYCLE_ID);

		IF v_CHARGE_TYPE IN ('E','D','H') THEN
			CU.GET_CHARGE_QUANTITY(p_COMPONENT, p_PERIOD_ID, v_BEGIN_DATE, LEAST(p_END_DATE, v_END_DATE), p_DETERMINANTS, v_ENERGY, v_DEMAND, p_NEED_PERIOD_IDs, p_INTERVAL_DETERMINANTS);
		END IF;

		SELECT DECODE(v_CHARGE_TYPE, 'E', v_ENERGY, 'D', v_DEMAND, 'H', v_ENERGY, 'S', 1.0, 0.0) INTO v_QUANTITY FROM DUAL;
		v_QUANTITY := v_QUANTITY * p_ENROLLMENT * p_LOSS_FACTOR;

		v_FACTOR := CU.GET_COMPONENT_FACTOR(p_COMPONENT.COMPONENT_ID, v_BEGIN_DATE);
        v_NEED_AMOUNT_CALC := TRUE;

        IF v_RATE_STRUCTURE = 'FLAT' THEN
			v_RATE := CU.GET_COMPONENT_FLAT_RATE(p_COMPONENT.COMPONENT_ID, v_QUANTITY, v_BEGIN_DATE);
		ELSIF v_RATE_STRUCTURE = 'BLOCK' THEN
			v_RATE := CU.GET_COMPONENT_BLOCK_RATE(p_COMPONENT.COMPONENT_ID, v_QUANTITY, v_BEGIN_DATE);
		ELSIF v_RATE_STRUCTURE = 'TIERED' THEN
			IF v_CHARGE_TYPE = 'H' THEN
				v_RATE := CU.GET_COMPONENT_TIERED_RATE(p_COMPONENT.COMPONENT_ID, v_ENERGY, v_BEGIN_DATE, v_DEMAND);
			ELSE
				v_RATE := CU.GET_COMPONENT_TIERED_RATE(p_COMPONENT.COMPONENT_ID, v_QUANTITY, v_BEGIN_DATE);
			END IF;
		ELSIF v_RATE_STRUCTURE = 'TIME OF USE' THEN
			v_RATE := CU.GET_COMPONENT_TOU_RATE(p_COMPONENT.COMPONENT_ID, p_PERIOD_ID, v_BEGIN_DATE);
		ELSIF v_RATE_STRUCTURE = 'MARKET' THEN
			--Modified 06/28/2004-wjc- Use hourly Market Rates and Composite_Profile_For_Calendar
			v_RATE := CU.GET_COMPONENT_MARKET_RATE(p_COMPONENT.COMPONENT_ID, p_COMPONENT.MARKET_PRICE_ID, v_BEGIN_DATE, v_MARKET_PRICE_TABLE);
        	IF v_MARKET_PRICE_TABLE.COUNT > 1 THEN
                v_QUANTITY := 0;
                v_AMOUNT := 0;
                v_DATE := v_BEGIN_DATE;
                WHILE v_DATE <= v_END_DATE LOOP  --over all days in interval
            		--Get hourly quantities from composite profile times hourly market prices
                    IF v_NEED_AMOUNT_CALC THEN   --1st time through, already called GET_COMPONENT_MARKET_RATE
                        v_NEED_AMOUNT_CALC := FALSE;
                    ELSE
            			v_RATE := CU.GET_COMPONENT_MARKET_RATE(p_COMPONENT.COMPONENT_ID, p_COMPONENT.MARKET_PRICE_ID, v_DATE, v_MARKET_PRICE_TABLE);
                    END IF;
                	IF v_MARKET_PRICE_TABLE.COUNT > 1 THEN
                        FS.COMPOSITE_PROFILE_FOR_CALENDAR(p_CALENDAR_ID, v_DATE, NULL, p_STATION_ID, v_COMPOSITE_PROFILE_STRING);
                    	UT.TOKENS_FROM_STRING(v_COMPOSITE_PROFILE_STRING, ',', v_PROFILE_STRING_TABLE);
                        v_MP_INDEX := v_MARKET_PRICE_TABLE.FIRST;
                    	FOR v_INDEX IN v_PROFILE_STRING_TABLE.FIRST..v_PROFILE_STRING_TABLE.LAST LOOP
                            IF v_MARKET_PRICE_TABLE.EXISTS(v_MP_INDEX) THEN
                        		IF LENGTH(v_PROFILE_STRING_TABLE(v_INDEX)) > 0 THEN
                        			v_LOAD := NVL(TO_NUMBER(v_PROFILE_STRING_TABLE(v_INDEX)), 0);   -- HOURLY LOAD
                                    v_LOAD := v_LOAD * p_ENROLLMENT * p_LOSS_FACTOR;
                        			v_AMOUNT := v_AMOUNT + (v_LOAD * v_MARKET_PRICE_TABLE(v_MP_INDEX) * v_FACTOR);  -- AMOUNT is sum of (hourly loads * hourly prices)
                                    v_QUANTITY := v_QUANTITY + v_LOAD;   -- QUANTITY is sum of hourly loads
                        		END IF;
                                v_MP_INDEX := v_MARKET_PRICE_TABLE.NEXT(v_MP_INDEX);
                            END IF;
                        END LOOP;

                    END IF;
                    v_DATE := v_DATE + 1;  --Next day
                END LOOP;  --'MARKET'
            END IF;

            IF v_QUANTITY * v_FACTOR <> 0 THEN
                v_RATE := v_AMOUNT /(v_QUANTITY * v_FACTOR);  --Reverse calculate weighted avg rate
            END IF;

		ELSIF v_RATE_STRUCTURE = 'COMPOSITE' THEN
			v_RATE := CU.GET_COMPOSITE_COMPONENT_RATE(p_COMPONENT.COMPONENT_ID, v_CHARGE_TYPE, p_PERIOD_ID, v_ENERGY, v_DEMAND, v_BEGIN_DATE, v_END_DATE);
-- Re-determine the appropriate v_QUANTITY if the Rate Structure was COMPOSITE, since the resulting selected component may have had a different CHARGE_TYPE.
			v_QUANTITY := CU.GET_COMPOSITE_COMPONENT_QUANT(p_COMPONENT.COMPONENT_ID, v_CHARGE_TYPE, v_ENERGY, v_DEMAND, v_BEGIN_DATE);
		END IF;

        IF v_NEED_AMOUNT_CALC THEN
		   v_AMOUNT := v_QUANTITY * v_RATE * v_FACTOR;
		END IF;
		p_CHARGE_COMPONENTS.EXTEND;
		p_CHARGE_COMPONENTS(p_CHARGE_COMPONENTS.LAST) := CHARGE_COMPONENT_TYPE(p_PRODUCT_ID, p_COMPONENT.COMPONENT_ID, CONSTANTS.NOT_ASSIGNED, CONSTANTS.NOT_ASSIGNED, p_PERIOD_ID, v_CHARGE_TYPE, v_BEGIN_DATE, v_END_DATE, NULL, v_QUANTITY, v_RATE, v_AMOUNT, v_FACTOR, CONSTANTS.NOT_ASSIGNED, CONSTANTS.NOT_ASSIGNED, CONSTANTS.NOT_ASSIGNED, NULL);

		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG(UT.TRACE_DATE(v_BEGIN_DATE) || ',' || UT.TRACE_DATE(v_END_DATE) || ',' || TO_CHAR(v_QUANTITY) || ',' || TO_CHAR(v_RATE) || ',' || TO_CHAR(v_AMOUNT) || ',' || TO_CHAR(v_FACTOR));
		END IF;

		v_BEGIN_DATE := v_END_DATE + 1;

	END LOOP;

END APPLY_PRODUCT_COMPONENT_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE APPLY_PRODUCT_COMPONENTS
	(
	p_PRODUCT_ID IN NUMBER,
	p_DETERMINANTS IN DETERMINANT_TABLE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ENROLLMENT IN NUMBER,
	p_LOSS_FACTOR IN NUMBER,
	p_STATION_ID IN NUMBER,
	p_CALENDAR_ID IN NUMBER,
	p_BILL_CYCLE_ID IN NUMBER,
	p_TRACE_ON IN BOOLEAN,
	p_CHARGE_COMPONENTS IN OUT NOCOPY CHARGE_COMPONENT_TABLE
	) AS

--APPLY_PRODUCT_COMPONENT_CHARGE for all components of Product.
--Moved from CU to avoid circular package reference after adding call to FS.COMPOSITE_PROFILE_FOR_CALENDAR
-- in support of hourly Market Price calculations. -06/28/2004-wjc

v_COMPONENT COMPONENT%ROWTYPE;
v_ELASPSED NUMBER := DBMS_UTILITY.GET_TIME;

CURSOR c_COMPONENTS IS
	SELECT COMPONENT_ID
	FROM PRODUCT_COMPONENT
	WHERE PRODUCT_ID = p_PRODUCT_ID
		AND BEGIN_DATE <= p_END_DATE
		AND NVL(END_DATE, p_END_DATE) >= p_BEGIN_DATE;

CURSOR c_PERIODS IS
	SELECT DISTINCT PERIOD_ID
	FROM SEASON_TEMPLATE
	WHERE TEMPLATE_ID = v_COMPONENT.TEMPLATE_ID;

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('APPLY_PRODUCT_COMPONENTS');
		LOGS.LOG_DEBUG('PRODUCT_ID=' || TO_CHAR(p_PRODUCT_ID) || ', BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE) || ', END_DATE=' || TO_CHAR(p_END_DATE));
		LOGS.LOG_DEBUG('ENROLLMENT=' || TO_CHAR(p_ENROLLMENT) || ', LOSS_FACTOR=' || TO_CHAR(p_LOSS_FACTOR));
	END IF;

	p_CHARGE_COMPONENTS.DELETE;

	IF p_DETERMINANTS.COUNT = 0 THEN
		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG('NO DETERMINANTS');
		END IF;
		RETURN;
	END IF;

	FOR v_COMPONENTS IN c_COMPONENTS LOOP

		v_COMPONENT := CU.GET_COMPONENT(v_COMPONENTS.COMPONENT_ID);

		IF v_COMPONENT.COMPONENT_ID IS NOT NULL THEN
			IF UPPER(v_COMPONENT.RATE_STRUCTURE) = 'TIME OF USE' THEN
				FOR v_PERIODS IN c_PERIODS LOOP
					APPLY_PRODUCT_COMPONENT_CHARGE(p_PRODUCT_ID, v_COMPONENT, v_PERIODS.PERIOD_ID, p_BEGIN_DATE, p_END_DATE, p_ENROLLMENT, p_LOSS_FACTOR, p_STATION_ID, p_CALENDAR_ID, p_BILL_CYCLE_ID, p_DETERMINANTS, p_CHARGE_COMPONENTS);
				END LOOP;
			ELSE
				APPLY_PRODUCT_COMPONENT_CHARGE(p_PRODUCT_ID, v_COMPONENT, CONSTANTS.ALL_ID, p_BEGIN_DATE, p_END_DATE, p_ENROLLMENT, p_LOSS_FACTOR, p_STATION_ID, p_CALENDAR_ID, p_BILL_CYCLE_ID, p_DETERMINANTS, p_CHARGE_COMPONENTS);
			END IF;
		END IF;

	END LOOP;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('APPLY_PRODUCT_COMPONENTS TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELASPSED));
	END IF;

END APPLY_PRODUCT_COMPONENTS;
---------------------------------------------------------------------------------------------------
PROCEDURE RUN_QUOTE_REQUEST
	(
	p_QUOTE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

v_SERVICE_BEGIN_DATE DATE := TRUNC(p_BEGIN_DATE, 'MONTH');
v_SERVICE_END_DATE DATE := LAST_DAY(TRUNC(p_END_DATE));
v_ELASPSED NUMBER;
v_LOSS_FACTOR NUMBER;
v_QUOTE_REQUEST QUOTE_REQUEST%ROWTYPE;
v_PRORATION DETERMINANT_TABLE := DETERMINANT_TABLE();
v_OFFER CHARGE_COMPONENT_TABLE := CHARGE_COMPONENT_TABLE();
v_COST CHARGE_COMPONENT_TABLE := CHARGE_COMPONENT_TABLE();
v_COMPARE CHARGE_COMPONENT_TABLE := CHARGE_COMPONENT_TABLE();
v_AS_OF_DATE DATE := LOW_DATE;
v_TEMPLATE_ID NUMBER(9);
v_LAST_TEMPLATE_ID NUMBER(9);

CURSOR c_QUOTE_CALENDAR_PRODUCTS IS
	SELECT * FROM QUOTE_CALENDAR_PRODUCT WHERE QUOTE_ID = p_QUOTE_ID;

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK.';
	IF LOGS.IS_DEBUG_ENABLED THEN
		v_ELASPSED := DBMS_UTILITY.GET_TIME;
		LOGS.LOG_DEBUG('RUN_QUOTE_REQUEST BEGIN AT ' || UT.TRACE_DATE(SYSDATE));
		LOGS.LOG_DEBUG('QUOTE_ID=' || TO_CHAR(p_QUOTE_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || UT.TRACE_DATE(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || UT.TRACE_DATE(p_END_DATE));
		LOGS.LOG_DEBUG('AS_OF_DATE=' || UT.TRACE_DATE(v_AS_OF_DATE));
		LOGS.LOG_DEBUG('SERVICE_BEGIN_DATE=' || UT.TRACE_DATE(v_SERVICE_BEGIN_DATE));
		LOGS.LOG_DEBUG('SERVICE_END_DATE=' || UT.TRACE_DATE(v_SERVICE_END_DATE));
	END IF;

	SELECT * INTO v_QUOTE_REQUEST FROM QUOTE_REQUEST WHERE QUOTE_ID = p_QUOTE_ID;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('CUSTOMER_CLASS=' || v_QUOTE_REQUEST.CUSTOMER_CLASS);
		LOGS.LOG_DEBUG('NUMBER_OF_CUSTOMERS=' || TO_CHAR(v_QUOTE_REQUEST.NUMBER_OF_CUSTOMERS));
		LOGS.LOG_DEBUG('STATION_ID=' || TO_CHAR(v_QUOTE_REQUEST.STATION_ID));
	END IF;

	FOR v_QUOTE_CALENDAR_PRODUCTS IN c_QUOTE_CALENDAR_PRODUCTS LOOP
		v_LOSS_FACTOR := GET_LOSS_FACTOR(v_QUOTE_CALENDAR_PRODUCTS.LOSS_FACTOR_ID, v_SERVICE_BEGIN_DATE);
		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG('LOSS_FACTOR=' || TO_CHAR(v_LOSS_FACTOR));
		END IF;

		v_TEMPLATE_ID := GET_TEMPLATE_FOR_PRODUCT(v_QUOTE_CALENDAR_PRODUCTS.OFFER_PRODUCT_ID, v_SERVICE_BEGIN_DATE);
		GET_QUOTE_DETERMINANTS(p_QUOTE_ID, v_QUOTE_CALENDAR_PRODUCTS.PROFILE_CALENDAR_ID, v_TEMPLATE_ID, v_QUOTE_REQUEST.STATION_ID, v_SERVICE_BEGIN_DATE, v_SERVICE_END_DATE, v_AS_OF_DATE, v_QUOTE_CALENDAR_PRODUCTS.USE_BILLING_DETERMINANTS, v_PRORATION);
		APPLY_PRODUCT_COMPONENTS(v_QUOTE_CALENDAR_PRODUCTS.OFFER_PRODUCT_ID, v_PRORATION, v_SERVICE_BEGIN_DATE, v_SERVICE_END_DATE, v_QUOTE_REQUEST.NUMBER_OF_CUSTOMERS, 1.0, v_QUOTE_REQUEST.STATION_ID, v_QUOTE_CALENDAR_PRODUCTS.PROFILE_CALENDAR_ID, CONSTANTS.NOT_ASSIGNED, LOGS.IS_DEBUG_ENABLED, v_OFFER);

		v_LAST_TEMPLATE_ID := v_TEMPLATE_ID;
		v_TEMPLATE_ID := GET_TEMPLATE_FOR_PRODUCT(v_QUOTE_CALENDAR_PRODUCTS.COST_PRODUCT_ID, v_SERVICE_BEGIN_DATE);
		IF v_TEMPLATE_ID = v_LAST_TEMPLATE_ID THEN
			GET_QUOTE_DETERMINANTS(p_QUOTE_ID, v_QUOTE_CALENDAR_PRODUCTS.PROFILE_CALENDAR_ID, v_TEMPLATE_ID, v_QUOTE_REQUEST.STATION_ID, v_SERVICE_BEGIN_DATE, v_SERVICE_END_DATE, v_AS_OF_DATE, v_QUOTE_CALENDAR_PRODUCTS.USE_BILLING_DETERMINANTS, v_PRORATION);
		END IF;
		APPLY_PRODUCT_COMPONENTS(v_QUOTE_CALENDAR_PRODUCTS.COST_PRODUCT_ID, v_PRORATION, v_SERVICE_BEGIN_DATE, v_SERVICE_END_DATE, v_QUOTE_REQUEST.NUMBER_OF_CUSTOMERS, v_LOSS_FACTOR, v_QUOTE_REQUEST.STATION_ID, v_QUOTE_CALENDAR_PRODUCTS.PROFILE_CALENDAR_ID, CONSTANTS.NOT_ASSIGNED, LOGS.IS_DEBUG_ENABLED, v_COST);

		v_LAST_TEMPLATE_ID := v_TEMPLATE_ID;
		v_TEMPLATE_ID := GET_TEMPLATE_FOR_PRODUCT(v_QUOTE_CALENDAR_PRODUCTS.COMPARE_PRODUCT_ID, v_SERVICE_BEGIN_DATE);
		IF v_TEMPLATE_ID = v_LAST_TEMPLATE_ID THEN
			GET_QUOTE_DETERMINANTS(p_QUOTE_ID, v_QUOTE_CALENDAR_PRODUCTS.PROFILE_CALENDAR_ID, v_TEMPLATE_ID, v_QUOTE_REQUEST.STATION_ID, v_SERVICE_BEGIN_DATE, v_SERVICE_END_DATE, v_AS_OF_DATE, v_QUOTE_CALENDAR_PRODUCTS.USE_BILLING_DETERMINANTS, v_PRORATION);
		END IF;
		APPLY_PRODUCT_COMPONENTS(v_QUOTE_CALENDAR_PRODUCTS.COMPARE_PRODUCT_ID, v_PRORATION, v_SERVICE_BEGIN_DATE, v_SERVICE_END_DATE, v_QUOTE_REQUEST.NUMBER_OF_CUSTOMERS, 1.0, v_QUOTE_REQUEST.STATION_ID, v_QUOTE_CALENDAR_PRODUCTS.PROFILE_CALENDAR_ID, CONSTANTS.NOT_ASSIGNED, LOGS.IS_DEBUG_ENABLED, v_COMPARE);

		PUT_QUOTE_COMPONENT_POSITION(p_QUOTE_ID, v_QUOTE_CALENDAR_PRODUCTS.QUOTE_SCENARIO, v_QUOTE_REQUEST.NUMBER_OF_CUSTOMERS, v_PRORATION, v_OFFER, v_COST, v_COMPARE);

	END LOOP;

    UPDATE_QUOTE_SEASONAL_RATES(p_QUOTE_ID, v_SERVICE_BEGIN_DATE, v_SERVICE_END_DATE, CONSTANTS.ALL_ID,p_TRACE_ON, p_STATUS,p_MESSAGE);

	IF LOGS.IS_DEBUG_ENABLED THEN
		v_ELASPSED := DBMS_UTILITY.GET_TIME - v_ELASPSED;
	    LOGS.LOG_DEBUG('RUN_QUOTE_REQUEST END AT ' || UT.TRACE_DATE(SYSDATE) || ', ELAPSED TIME=' || TO_CHAR(v_ELASPSED));
 	END IF;

END RUN_QUOTE_REQUEST;
---------------------------------------------------------------------------------------------------
PROCEDURE QUOTE_SUMMARY
	(
	p_QUOTE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PERIOD_ID IN NUMBER,
	p_PERIOD_TOTAL IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the summary results for a quote execution.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT QUOTE_SCENARIO,
			DECODE(p_PERIOD_TOTAL, g_TOTAL, p_END_DATE, QUOTE_MONTH) "QUOTE_MONTH",
			SUM(NVL(QUOTE_ENERGY,0)) "QUOTE_ENERGY",
			MAX(NVL(QUOTE_DEMAND,0)) "QUOTE_DEMAND",
			SUM(NVL(QUOTE_COMPARE,0)) "COMPARE_COST",
			SUM(NVL(QUOTE_REVENUE,0)) "QUOTE_REVENUE",
			SUM(NVL(QUOTE_COST,0)) "QUOTE_COST",
			SUM(NVL(QUOTE_REVENUE-QUOTE_COST,0)) "MARGIN",
			100 * (SUM(NVL(QUOTE_REVENUE,0)) - SUM(NVL(QUOTE_COST,0))) / (SUM(NVL(QUOTE_REVENUE,0)) + 0.001) "MARGIN %",
			SUM(NVL(QUOTE_COMPARE-QUOTE_REVENUE,0)) "SAVINGS",
			100 * (SUM(NVL(QUOTE_COMPARE,0)) - SUM(NVL(QUOTE_REVENUE,0))) / (SUM(NVL(QUOTE_COMPARE,0)) + 0.001) "SAVINGS %"
		FROM QUOTE_COMPONENT_POSITION
		WHERE QUOTE_ID = p_QUOTE_ID
			AND QUOTE_MONTH BETWEEN TRUNC(p_BEGIN_DATE,'MONTH') AND LAST_DAY(p_END_DATE)
			AND PERIOD_ID = DECODE(p_PERIOD_ID, g_TOTAL, PERIOD_ID, p_PERIOD_ID)
		GROUP BY QUOTE_SCENARIO, DECODE(p_PERIOD_TOTAL, g_TOTAL, p_END_DATE, QUOTE_MONTH)
		ORDER BY QUOTE_SCENARIO, QUOTE_MONTH;


END QUOTE_SUMMARY;
---------------------------------------------------------------------------------------------------
PROCEDURE CAMPAIGN_SUMMARY
	(
	p_CAMPAIGN_NAME IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PERIOD_ID IN NUMBER,
	p_PERIOD_TOTAL IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the summary results for a quote execution.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT R.CAMPAIGN_NAME,
			DECODE(p_PERIOD_TOTAL, g_TOTAL, p_END_DATE, QUOTE_MONTH) "QUOTE_MONTH",
			SUM(P.QUOTE_ENERGY) "ENERGY",
			SUM(P.QUOTE_REVENUE) "REVENUE",
			SUM(P.QUOTE_COST) "COST",
			SUM(P.QUOTE_REVENUE-P.QUOTE_COST) "MARGIN",
			100 * SUM(P.QUOTE_REVENUE-P.QUOTE_COST) / SUM(P.QUOTE_REVENUE) "MARGIN %"
		FROM QUOTE_COMPONENT_POSITION P, QUOTE_REQUEST R
		WHERE P.QUOTE_ID = R.QUOTE_ID
		    AND R.CAMPAIGN_NAME = DECODE(p_CAMPAIGN_NAME, g_ALL_STRING, R.CAMPAIGN_NAME, p_CAMPAIGN_NAME)
			AND P.QUOTE_MONTH BETWEEN TRUNC(p_BEGIN_DATE,'MONTH') AND LAST_DAY(p_END_DATE)
			AND P.PERIOD_ID = DECODE(p_PERIOD_ID, g_TOTAL, P.PERIOD_ID, p_PERIOD_ID)
		GROUP BY R.CAMPAIGN_NAME, DECODE(p_PERIOD_TOTAL, g_TOTAL, p_END_DATE, QUOTE_MONTH)
		ORDER BY R.CAMPAIGN_NAME, QUOTE_MONTH;


END CAMPAIGN_SUMMARY;
---------------------------------------------------------------------------------------------------
PROCEDURE QUOTE_REQUESTS
	(
	p_EDC_ID IN NUMBER,
	p_CAMPAIGN_NAME IN VARCHAR2,
	p_CUSTOMER_NAME IN VARCHAR2,
	p_CUSTOMER_REP_NAME IN VARCHAR2,
	p_QUOTE_STATUS IN VARCHAR2,
	p_QUOTE_EFFECTIVE_DATE IN DATE,
	p_QUOTE_EXPIRATION_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the quote_request records matching the criteria
BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT QUOTE_ID,
			   QUOTE_NAME "Quote Name",
			   CAMPAIGN_NAME "Campaign",
			   QUOTE_STATUS "Status",
			   QUOTE_TYPE "Type",
			   QUOTE_EFFECTIVE_DATE "Effective",
			   QUOTE_EXPIRATION_DATE "Expiration",
			   CUSTOMER_NAME "Customer Name",
			   CUSTOMER_TYPE "Customer Type",
			   CUSTOMER_CLASS "Class",
			   EDC_ACCOUNT_NUMBER "EDC Account",
			   CUSTOMER_REP_NAME "Sales Rep",
			   SERVICE_BEGIN_DATE "Service Begin",
			   SERVICE_END_DATE "Service End",
			   NUMBER_OF_CUSTOMERS "Number of Customers",
			   SIGNING_PROBABILITY "Probability",
			   ENTRY_DATE "Entry Date"

		FROM QUOTE_REQUEST
		WHERE EDC_ID = DECODE(p_EDC_ID, CONSTANTS.ALL_ID, EDC_ID, p_EDC_ID)
                  AND CAMPAIGN_NAME = DECODE(p_CAMPAIGN_NAME, g_ALL_STRING, CAMPAIGN_NAME, p_CAMPAIGN_NAME)
                  AND CUSTOMER_NAME = DECODE(p_CUSTOMER_NAME, g_ALL_STRING, CUSTOMER_NAME, p_CUSTOMER_NAME)
                  AND CUSTOMER_REP_NAME = DECODE(p_CUSTOMER_REP_NAME, g_ALL_STRING, CUSTOMER_REP_NAME, p_CUSTOMER_REP_NAME)
                  AND QUOTE_STATUS = DECODE(p_QUOTE_STATUS, g_ALL_STRING, QUOTE_STATUS, p_QUOTE_STATUS)
		ORDER BY QUOTE_STATUS;


END QUOTE_REQUESTS;
---------------------------------------------------------------------------------------------------
PROCEDURE CAMPAIGN_NAMES
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the unique CAMPAIGN_NAMEs IN the quote_request records
BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT DISTINCT CAMPAIGN_NAME
		FROM QUOTE_REQUEST
		ORDER BY 1;


END CAMPAIGN_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE CUSTOMER_NAMES
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the unique CUSTOMER_NAMEs IN the quote_request records
BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT DISTINCT CUSTOMER_NAME
		FROM QUOTE_REQUEST
		ORDER BY 1;


END CUSTOMER_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE CUSTOMER_TYPES
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the unique CUSTOMER_TYPEs IN the quote_request records
BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT DISTINCT CUSTOMER_TYPE
		FROM QUOTE_REQUEST
		ORDER BY 1;


END CUSTOMER_TYPES;
---------------------------------------------------------------------------------------------------
PROCEDURE CUSTOMER_REPS
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the unique CUSTOMER_REPs IN the quote_request records
BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT DISTINCT CUSTOMER_REP_NAME
		FROM QUOTE_REQUEST
		ORDER BY 1;


END CUSTOMER_REPS;
---------------------------------------------------------------------------------------------------
PROCEDURE CUSTOMER_CLASSES
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the unique CUSTOMER_CLASSes IN the quote_request records
BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT DISTINCT CUSTOMER_CLASS
		FROM QUOTE_REQUEST
		ORDER BY 1;


END CUSTOMER_CLASSES;
---------------------------------------------------------------------------------------------------
PROCEDURE QUOTE_TYPES
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the unique QUOTE_TYPEs IN the quote_request records
BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT DISTINCT QUOTE_TYPE
		FROM QUOTE_REQUEST
		ORDER BY 1;


END QUOTE_TYPES;
---------------------------------------------------------------------------------------------------
PROCEDURE QUOTE_STATUSES
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the unique QUOTE_STATUSes IN the quote_request records
BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT DISTINCT QUOTE_STATUS
		FROM QUOTE_REQUEST
		ORDER BY 1;


END QUOTE_STATUSES;
---------------------------------------------------------------------------------------------------
PROCEDURE EDC_ACCOUNT_NUMBERS
	(
	p_CUSTOMER_NAME IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the unique EDC_ACCOUNT_NUMBERS IN the quote_request records
BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT DISTINCT EDC_ACCOUNT_NUMBER
		FROM QUOTE_REQUEST
                WHERE CUSTOMER_NAME = DECODE(p_CUSTOMER_NAME, g_ALL_STRING, CUSTOMER_NAME, p_CUSTOMER_NAME)
		ORDER BY 1;


END EDC_ACCOUNT_NUMBERS;
---------------------------------------------------------------------------------------------------
PROCEDURE QUOTE_BILLING_DETERMINANTS
	(
	p_QUOTE_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the QUOTE_BILLING_DETERMINANT records matching the criteria
BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT A.QUOTE_ID,
			   A.BEGIN_DATE,
			   A.END_DATE,
			   A.PERIOD_ID,
			   B.PERIOD_NAME "PERIOD",
			   A.DEMAND,
			   A.ENERGY,
			   A.ENTRY_DATE
		FROM QUOTE_BILLING_DETERMINANT A, PERIOD B
		WHERE QUOTE_ID = DECODE(p_QUOTE_ID, CONSTANTS.ALL_ID, QUOTE_ID, p_QUOTE_ID)
		  AND A.PERIOD_ID = B.PERIOD_ID
		ORDER BY 1,2,3;


END QUOTE_BILLING_DETERMINANTS;
---------------------------------------------------------------------------------------------------
PROCEDURE RUN_COMPUTE_RATE
	(
	p_QUOTE_ID IN NUMBER,
	p_COST_PRODUCT_ID IN NUMBER,
	p_CALENDAR_ID IN NUMBER,
	p_USE_BILLING_DETERMINANTS IN NUMBER,
	p_MARGIN IN VARCHAR,
	p_MARGIN_PERCENT IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_RATE OUT NUMBER,
	p_STATUS OUT NUMBER
	) AS

-- Compute the RATE for the given the criteria

v_SERVICE_BEGIN_DATE DATE := TRUNC(p_BEGIN_DATE, 'MONTH');
v_SERVICE_END_DATE DATE := LAST_DAY(TRUNC(p_END_DATE));
v_EARLIEST_BEGIN_DATE DATE;
v_LATEST_END_DATE DATE;
v_ELASPSED NUMBER;
v_CONSUMPTION CONSUMPTION_TABLE := CONSUMPTION_TABLE();
v_DETERMINANTS DETERMINANT_TABLE := DETERMINANT_TABLE();
v_PRORATION DETERMINANT_TABLE := DETERMINANT_TABLE();
v_COST CHARGE_COMPONENT_TABLE := CHARGE_COMPONENT_TABLE();
v_ENERGY NUMBER;
v_AMOUNT  NUMBER;

BEGIN

	p_STATUS := GA.SUCCESS;
	IF LOGS.IS_DEBUG_ENABLED THEN
		v_ELASPSED := DBMS_UTILITY.GET_TIME;
		LOGS.LOG_DEBUG('RUN_COMPUTE_RATE BEGIN AT ' || UT.TRACE_DATE(SYSDATE));
		LOGS.LOG_DEBUG('QUOTE_ID=' || TO_CHAR(p_QUOTE_ID));
		LOGS.LOG_DEBUG('COST_PRODUCT_ID=' || TO_CHAR(p_COST_PRODUCT_ID));
		LOGS.LOG_DEBUG('CALENDAR_ID=' || TO_CHAR(p_CALENDAR_ID));
		LOGS.LOG_DEBUG('USE_BILLING_DETERMINANTS=' || TO_CHAR(p_USE_BILLING_DETERMINANTS));
		LOGS.LOG_DEBUG('MARGIN=' || p_MARGIN);
		LOGS.LOG_DEBUG('MARGIN_PERCENT=' || p_MARGIN_PERCENT);
		LOGS.LOG_DEBUG('BEGIN_DATE=' || UT.TRACE_DATE(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || UT.TRACE_DATE(p_END_DATE));
		LOGS.LOG_DEBUG('SERVICE_BEGIN_DATE=' || UT.TRACE_DATE(v_SERVICE_BEGIN_DATE));
		LOGS.LOG_DEBUG('SERVICE_END_DATE=' || UT.TRACE_DATE(v_SERVICE_END_DATE));
	END IF;

	IF p_USE_BILLING_DETERMINANTS = 1 THEN
		GET_BILLING_DETERMINANTS(p_QUOTE_ID, v_SERVICE_BEGIN_DATE, v_SERVICE_END_DATE, v_CONSUMPTION, v_EARLIEST_BEGIN_DATE, v_LATEST_END_DATE);
		CU.GET_PROJECTION_DETERMINANTS(p_CALENDAR_ID, 'DAY', CONSTANTS.NOT_ASSIGNED, CONSTANTS.NOT_ASSIGNED, v_EARLIEST_BEGIN_DATE, v_LATEST_END_DATE, LOW_DATE, LOGS.IS_DEBUG_DETAIL_ENABLED, v_DETERMINANTS);
		CU.GET_PRORATED_CONSUMPTION(v_SERVICE_BEGIN_DATE, v_SERVICE_END_DATE, v_DETERMINANTS, v_CONSUMPTION, LOGS.IS_DEBUG_DETAIL_ENABLED, v_PRORATION);
	ELSE
		CU.GET_PROJECTION_DETERMINANTS(p_CALENDAR_ID, 'DAY', CONSTANTS.NOT_ASSIGNED, CONSTANTS.NOT_ASSIGNED, v_SERVICE_BEGIN_DATE, v_SERVICE_END_DATE, LOW_DATE, LOGS.IS_DEBUG_DETAIL_ENABLED, v_PRORATION);
	END IF;
	CU.APPLY_PRODUCT_COMPONENTS(p_COST_PRODUCT_ID, v_PRORATION, v_SERVICE_BEGIN_DATE, v_SERVICE_END_DATE, LOGS.IS_DEBUG_ENABLED, v_COST);

	SELECT SUM(A.DETERMINANT_1)
	INTO v_ENERGY
	FROM TABLE(CAST(v_PRORATION AS DETERMINANT_TABLE)) A;

	SELECT SUM(A.AMOUNT)
	INTO v_AMOUNT
	FROM TABLE(CAST(v_COST AS CHARGE_COMPONENT_TABLE)) A;

	p_RATE := 0;
	IF v_ENERGY > 0 THEN
		IF LTRIM(RTRIM(p_MARGIN)) IS NOT NULL THEN
			v_AMOUNT := v_AMOUNT + TO_NUMBER(p_MARGIN);
		ELSIF TRIM(RTRIM(p_MARGIN_PERCENT)) IS NOT NULL THEN
			v_AMOUNT := v_AMOUNT *  (1.0 + (TO_NUMBER(p_MARGIN_PERCENT) / 100));
		END IF;
		p_RATE := v_AMOUNT / v_ENERGY;
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		v_ELASPSED := DBMS_UTILITY.GET_TIME - v_ELASPSED;
	    LOGS.LOG_DEBUG('RUN_COMPUTE_RATE END AT ' || UT.TRACE_DATE(SYSDATE) || ', ELAPSED TIME=' || TO_CHAR(v_ELASPSED));
 	END IF;


END RUN_COMPUTE_RATE;
---------------------------------------------------------------------------------------------------
PROCEDURE TOKENS_FROM_STRING_LARGE
	(
	p_STRING IN VARCHAR,
	p_DELIMETER IN CHAR,
	p_STRING_TABLE OUT STRING_TABLE_LARGE
	) AS

v_COUNT BINARY_INTEGER := 0;
v_BEGIN_POS NUMBER := 1;
v_END_POS NUMBER := 1;
v_LENGTH NUMBER;
v_TOKEN VARCHAR(512);
v_LOOP_COUNTER NUMBER;

BEGIN

-- IF THE ARGUMENT STRING IS EMPTY THEN EXIT THE PROCEDURE

	IF LTRIM(RTRIM(p_STRING)) IS NULL THEN
		RETURN;
	END IF;

	v_LENGTH := LENGTH(p_STRING);
	v_LOOP_COUNTER := 0;

	LOOP
		v_END_POS := INSTR(p_STRING, p_DELIMETER, v_BEGIN_POS);
		IF v_END_POS = 0 THEN
			v_TOKEN := LTRIM(RTRIM(SUBSTR(p_STRING, v_BEGIN_POS)));
			v_END_POS := v_LENGTH;
		ELSE
			v_TOKEN := LTRIM(RTRIM(SUBSTR(p_STRING, v_BEGIN_POS, v_END_POS - v_BEGIN_POS)));
		END IF;
		v_COUNT := v_COUNT + 1;
		p_STRING_TABLE(v_COUNT) := v_TOKEN;
		v_BEGIN_POS := v_END_POS + 1;
		v_LOOP_COUNTER := v_LOOP_COUNTER + 1;
		IF v_LOOP_COUNTER > 10000 THEN
			ERRS.RAISE(MSGCODES.c_ERR_RUNAWAY_LOOP);
		END IF;
		EXIT WHEN v_BEGIN_POS > v_LENGTH;
	END LOOP;

-- IF THE ARGUMENT STRING IS TERMINATED WITH THE DELIMITER THEN APPEND A NULL STRING TOKEN TO THE TABLE

	IF SUBSTR(p_STRING, v_LENGTH) = p_DELIMETER THEN
		v_COUNT := v_COUNT + 1;
		p_STRING_TABLE(v_COUNT) := NULL;
	END IF;

	EXCEPTION
	    WHEN VALUE_ERROR THEN
			ERRS.RAISE(MSGCODES.c_ERR_GENERAL, 'VALUE_ERROR: LOOP_COUNTER=' || v_LOOP_COUNTER
				|| ',TOKEN=' || v_TOKEN
				|| ',BEGIN_POS=' || TO_CHAR(v_BEGIN_POS)
				|| ',END_POS=' || TO_CHAR(v_END_POS)
				|| ',LENGTH=' || TO_CHAR(v_LENGTH));

END TOKENS_FROM_STRING_LARGE;
----------------------------------------------------------------------------------------------------
PROCEDURE PROSPECTS
	(
	p_SCREEN_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the PROSPECT records matching the SCREEN_ID.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT A.EDC_ID,
			   E.EDC_NAME "EDC Name",
			   A.EDC_NAME "EDC External Name",
			   A.ACCOUNT_NUMBER "Account Number",
			   A.COMPARE_PRODUCT_ID,
			   P.PRODUCT_NAME "Tariff Product",
			   A.EDC_TARIFF "EDC Tariff",
			   C.CALENDAR_ID,
			   C.CALENDAR_NAME "Load Profile Calendar",
			   A.EDC_RATE_CLASS "Rate Class",
			   SUM(U.ENERGY) "Total Energy",
			   MAX(U.DEMAND) "Peak Demand",
			   A.PROSPECT_ID
		FROM PROSPECT A, CALENDAR C, PRODUCT P, ENERGY_DISTRIBUTION_COMPANY E, PROSPECT_CONSUMPTION U
		WHERE A.SCREEN_ID = p_SCREEN_ID
		  AND P.PRODUCT_ID = A.COMPARE_PRODUCT_ID
		  AND C.CALENDAR_ID = A.PROFILE_CALENDAR_ID
		  AND E.EDC_ID = A.EDC_ID
		  AND U.PROSPECT_ID (+) = A.PROSPECT_ID
		GROUP BY
			   A.EDC_ID,
			   E.EDC_NAME,
			   A.EDC_NAME,
			   A.ACCOUNT_NUMBER,
			   A.COMPARE_PRODUCT_ID,
			   P.PRODUCT_NAME,
			   A.EDC_TARIFF,
			   C.CALENDAR_ID,
			   C.CALENDAR_NAME,
			   A.EDC_RATE_CLASS,
			   A.PROSPECT_ID
		ORDER BY A.PROSPECT_ID;

END PROSPECTS;
---------------------------------------------------------------------------------------------------
PROCEDURE PROSPECT_SCREEN_EVALUATIONS
	(
	p_SCREEN_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the PROSPECT_SCREEN_EVALUATION records matching the SCREEN_ID.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT A.OFFER_PRODUCT_ID,
			   P1.PRODUCT_NAME "Offer Product",
			   0 AS "Evaluate",
			   A.COST_PRODUCT_ID,
			   P2.PRODUCT_NAME "Cost Product",
			   A.COMPARE_PRODUCT_ID,
			   P3.PRODUCT_NAME "Compare Product",
			   C.CALENDAR_ID,
			   C.CALENDAR_NAME "Load Profile Calendar",
			   W.STATION_ID,
			   W.STATION_NAME,
			   A.LOSS_FACTOR_ID,
			   L.LOSS_FACTOR_NAME "LOSS_FACTOR",
			   A.BEGIN_DATE "Begin Date",
			   A.END_DATE "End Date",
			   A.EVALUATION_ID
		FROM PROSPECT_SCREEN_EVALUATION A, CALENDAR C, PRODUCT P1, PRODUCT P2, PRODUCT P3, WEATHER_STATION W, LOSS_FACTOR L
		WHERE A.SCREEN_ID = p_SCREEN_ID
		  AND P1.PRODUCT_ID(+) = A.OFFER_PRODUCT_ID
		  AND P2.PRODUCT_ID(+) = A.COST_PRODUCT_ID
		  AND P3.PRODUCT_ID(+) = A.COMPARE_PRODUCT_ID
		  AND C.CALENDAR_ID(+) = A.PROFILE_CALENDAR_ID
		  AND W.STATION_ID(+) = A.STATION_ID
		  AND L.LOSS_FACTOR_ID(+) = A.LOSS_FACTOR_ID
		ORDER BY A.EVALUATION_ID;

END PROSPECT_SCREEN_EVALUATIONS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_DISTINCT_OFFERS
	(
	p_SCREEN_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the DISTINCT combinations of COMPARE_PRODUCT_ID and PROFILE_CALENDAR_ID matching the SCREEN_ID.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	--Note: Field names returned here must match those in PROSPECT_SCREEN_EVALUATIONS
	--  if the two recordsets are compared.
	--This procedure has been superceded by PROSPECT_EVAL_DISTINCT_OFFERS
	--  for populating the Evaluation Offers grid, but is being left for possible future reference.
	OPEN p_CURSOR FOR
		SELECT DISTINCT
			   A.COMPARE_PRODUCT_ID,
			   P.PRODUCT_NAME "Compare Product",
			   C.CALENDAR_ID,
			   C.CALENDAR_NAME "Load Profile Calendar"
		FROM PROSPECT A, CALENDAR C, PRODUCT P
		WHERE A.SCREEN_ID = p_SCREEN_ID
		  AND P.PRODUCT_ID = A.COMPARE_PRODUCT_ID
		  AND C.CALENDAR_ID = A.PROFILE_CALENDAR_ID
		ORDER BY 1;
END GET_DISTINCT_OFFERS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_PROSPECT_SCREEN_EVALUATION
    (
	p_SCREEN_ID IN NUMBER,
	p_OFFER_PRODUCT_ID IN NUMBER,
	p_COST_PRODUCT_ID IN NUMBER,
	p_COMPARE_PRODUCT_ID IN NUMBER,
	p_PROFILE_CALENDAR_ID IN NUMBER,
	p_STATION_ID IN NUMBER,
	p_LOSS_FACTOR_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_EVALUATION_ID IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

v_EVALUATION_ID NUMBER;

BEGIN

	p_STATUS := GA.SUCCESS;

	IF p_EVALUATION_ID = CONSTANTS.NOT_ASSIGNED THEN
		SELECT QID.NEXTVAL INTO v_EVALUATION_ID FROM DUAL;
	ELSE
		v_EVALUATION_ID := p_EVALUATION_ID;
	END IF;

    UPDATE PROSPECT_SCREEN_EVALUATION SET
		OFFER_PRODUCT_ID = p_OFFER_PRODUCT_ID,
		COST_PRODUCT_ID = p_COST_PRODUCT_ID,
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(p_END_DATE),
		STATION_ID = p_STATION_ID,
		LOSS_FACTOR_ID = p_LOSS_FACTOR_ID,
		EVALUATION_ID = v_EVALUATION_ID,
		ENTRY_DATE = SYSDATE
	WHERE SCREEN_ID = p_SCREEN_ID
		AND COMPARE_PRODUCT_ID = p_COMPARE_PRODUCT_ID
		AND PROFILE_CALENDAR_ID = p_PROFILE_CALENDAR_ID;

	IF SQL%NOTFOUND THEN
		INSERT INTO PROSPECT_SCREEN_EVALUATION (
			SCREEN_ID,
			OFFER_PRODUCT_ID,
			COST_PRODUCT_ID,
			COMPARE_PRODUCT_ID,
			PROFILE_CALENDAR_ID,
			STATION_ID,
			LOSS_FACTOR_ID,
			BEGIN_DATE,
			END_DATE,
			EVALUATION_ID,
			ENTRY_DATE)
		VALUES (
			p_SCREEN_ID,
			p_OFFER_PRODUCT_ID,
			p_COST_PRODUCT_ID,
			p_COMPARE_PRODUCT_ID,
			p_PROFILE_CALENDAR_ID,
			p_STATION_ID,
			p_LOSS_FACTOR_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(p_END_DATE),
			v_EVALUATION_ID,
			SYSDATE);
	END IF;

END PUT_PROSPECT_SCREEN_EVALUATION;
---------------------------------------------------------------------------------------------------
PROCEDURE PROSPECT_EVAL_DISTINCT_OFFERS
	(
	p_SCREEN_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the PROSPECT_SCREEN_EVALUATION records
--   that have DISTINCT combinations of COMPARE_PRODUCT_ID and PROFILE_CALENDAR_ID
--   and match the SCREEN_ID.
-- Used to populate the Evaluation Offers grid.
BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT A.OFFER_PRODUCT_ID,
			   P1.PRODUCT_NAME "Offer Product",
			   0 AS "Evaluate",
			   A.COST_PRODUCT_ID,
			   P2.PRODUCT_NAME "Cost Product",
			   D.COMPARE_PRODUCT_ID,
			   P3.PRODUCT_NAME "Compare Product",
			   D.PROFILE_CALENDAR_ID,
			   C.CALENDAR_NAME "Load Profile Calendar",
			   A.LOSS_FACTOR_ID,
			   L.LOSS_FACTOR_NAME "Loss_Factor",
			   A.BEGIN_DATE "Begin_Date",
			   A.END_DATE "End_Date",
			   A.EVALUATION_ID
		FROM DISTINCT_PROSPECT_OFFERS D, PROSPECT_SCREEN_EVALUATION A, CALENDAR C, PRODUCT P1, PRODUCT P2, PRODUCT P3, LOSS_FACTOR L
		WHERE D.SCREEN_ID = p_SCREEN_ID
		  AND A.SCREEN_ID(+) = D.SCREEN_ID
		  AND A.COMPARE_PRODUCT_ID(+) = D.COMPARE_PRODUCT_ID
		  AND A.PROFILE_CALENDAR_ID(+) = D.PROFILE_CALENDAR_ID
		  AND P1.PRODUCT_ID(+) = A.OFFER_PRODUCT_ID
		  AND P2.PRODUCT_ID(+) = A.COST_PRODUCT_ID
		  AND P3.PRODUCT_ID = D.COMPARE_PRODUCT_ID
		  AND C.CALENDAR_ID = D.PROFILE_CALENDAR_ID
		  AND L.LOSS_FACTOR_ID(+) = A.LOSS_FACTOR_ID
		ORDER BY A.EVALUATION_ID;

END PROSPECT_EVAL_DISTINCT_OFFERS;
---------------------------------------------------------------------------------------------------
PROCEDURE PROSPECT_EVALUATION_RESULTS
	(
	p_SCREEN_ID IN NUMBER,
	p_EVALUATION_ID_LIST IN VARCHAR,
	p_PERIOD_TOTAL IN NUMBER,
	p_MIN_SAVINGS IN NUMBER,
	p_IS_SAVINGS_PERCENT IN NUMBER,
	p_MIN_MARGIN IN NUMBER,
	p_IS_MARGIN_PERCENT IN NUMBER,
	p_MIN_REVENUE IN NUMBER,
	p_IS_REVENUE_PERCENT IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the results for an evaluation execution.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	IF p_PERIOD_TOTAL = 0 THEN	  --Display Months, not Totals
		OPEN p_CURSOR FOR
			SELECT
				P.SCREEN_ID,
				E.EVALUATION_ID "Offer Number",
				E.PROSPECT_ID,
				P.ACCOUNT_NUMBER,
				SERVICE_MONTH "SERVICE_MONTH",
				SUM(NVL(PROSPECT_ENERGY,0)) "ENERGY",
				MAX(NVL(PROSPECT_DEMAND,0)) "DEMAND",
				SUM(NVL(PROSPECT_COMPARE,0)) "COMPARE",
				SUM(NVL(PROSPECT_REVENUE,0)) "OFFER",
				SUM(NVL(PROSPECT_COST,0)) "COST",
				SUM(NVL(PROSPECT_COMPARE - PROSPECT_REVENUE,0)) "SAVINGS",
				100 * (SUM(NVL(PROSPECT_COMPARE,0)) - SUM(NVL(PROSPECT_REVENUE,0))) / (SUM(NVL(PROSPECT_COMPARE,0)) + .0001) "SAVINGS %",
				SUM(NVL(PROSPECT_REVENUE - PROSPECT_COST,0)) "MARGIN",
				100 * (SUM(NVL(PROSPECT_REVENUE,0)) - SUM(NVL(PROSPECT_COST,0))) / (SUM(NVL(PROSPECT_REVENUE,0)) + .0001) "MARGIN %",
				SUM(NVL(PROSPECT_COMPARE,0)) / (SUM(NVL(PROSPECT_ENERGY,0)) + .0001) "COMPARE_RATE",
				SUM(NVL(PROSPECT_REVENUE,0)) / (SUM(NVL(PROSPECT_ENERGY,0)) + .0001) "OFFER_RATE",
				SUM(NVL(PROSPECT_COST,0)) / (SUM(NVL(PROSPECT_ENERGY,0)) + .0001) "COST_RATE"
			FROM PROSPECT_EVALUATION E, PROSPECT P
			WHERE E.PROSPECT_ID = P.PROSPECT_ID
			  AND P.SCREEN_ID = p_SCREEN_ID
			GROUP BY
				P.SCREEN_ID,
				E.EVALUATION_ID,
				E.PROSPECT_ID,
				P.ACCOUNT_NUMBER,
				SERVICE_MONTH
			HAVING
			   -- revenue
			   SUM(NVL(PROSPECT_REVENUE,0)) > DECODE(p_IS_REVENUE_PERCENT,1,-99999999999,p_MIN_REVENUE)  -- if percent, don't care
			   -- margin
			   AND SUM(NVL(PROSPECT_REVENUE - PROSPECT_COST,0)) > DECODE(p_IS_MARGIN_PERCENT,1,-99999999999,p_MIN_MARGIN)  -- if percent, don't care
			   -- savings
			   AND SUM(NVL(PROSPECT_COMPARE - PROSPECT_REVENUE,0)) > DECODE(p_IS_SAVINGS_PERCENT,1,-99999999999,p_MIN_SAVINGS)  -- if percent, don't care
			   -- margin %
			   AND 100 * (SUM(NVL(PROSPECT_REVENUE,0)) - SUM(NVL(PROSPECT_COST,0))) / (SUM(NVL(PROSPECT_REVENUE,0)) + .0001) > DECODE(p_IS_MARGIN_PERCENT,0,-99999999999,p_MIN_MARGIN)  -- if NOT percent, don't care
			   -- savings %
			   AND 100 * (SUM(NVL(PROSPECT_COMPARE,0)) - SUM(NVL(PROSPECT_REVENUE,0))) / (SUM(NVL(PROSPECT_COMPARE,0)) + .0001) > DECODE(p_IS_SAVINGS_PERCENT,0,-99999999999,p_MIN_SAVINGS)  -- if NOT percent, don't care
			ORDER BY P.ACCOUNT_NUMBER,SERVICE_MONTH;
	ELSE	--Display Totals for all Months
		OPEN p_CURSOR FOR
			SELECT
				P.SCREEN_ID,
				E.EVALUATION_ID "Offer Number",
				E.PROSPECT_ID,
				P.ACCOUNT_NUMBER,
				MIN(SERVICE_MONTH) "BEGIN_DATE",
				MAX(SERVICE_MONTH) "END_DATE",
				SUM(NVL(PROSPECT_ENERGY,0)) "ENERGY",
				MAX(NVL(PROSPECT_DEMAND,0)) "DEMAND",
				SUM(NVL(PROSPECT_COMPARE,0)) "COMPARE",
				SUM(NVL(PROSPECT_REVENUE,0)) "OFFER",
				SUM(NVL(PROSPECT_COST,0)) "COST",
				SUM(NVL(PROSPECT_COMPARE - PROSPECT_REVENUE,0)) "SAVINGS",
				100 * (SUM(NVL(PROSPECT_COMPARE,0)) - SUM(NVL(PROSPECT_REVENUE,0))) / (SUM(NVL(PROSPECT_COMPARE,0)) + .0001) "SAVINGS %",
				SUM(NVL(PROSPECT_REVENUE - PROSPECT_COST,0)) "MARGIN",
				100 * (SUM(NVL(PROSPECT_REVENUE,0)) - SUM(NVL(PROSPECT_COST,0))) / (SUM(NVL(PROSPECT_REVENUE,0)) + .0001) "MARGIN %",
				SUM(NVL(PROSPECT_COMPARE,0)) / (SUM(NVL(PROSPECT_ENERGY,0)) + .0001) "COMPARE_RATE",
				SUM(NVL(PROSPECT_REVENUE,0)) / (SUM(NVL(PROSPECT_ENERGY,0)) + .0001) "OFFER_RATE",
				SUM(NVL(PROSPECT_COST,0)) / (SUM(NVL(PROSPECT_ENERGY,0)) + .0001) "COST_RATE"
			FROM PROSPECT_EVALUATION E, PROSPECT P
			WHERE E.PROSPECT_ID = P.PROSPECT_ID
			  AND P.SCREEN_ID = p_SCREEN_ID
			GROUP BY
				P.SCREEN_ID,
				E.EVALUATION_ID,
				E.PROSPECT_ID,
				P.ACCOUNT_NUMBER
			HAVING
			   -- revenue
			   SUM(NVL(PROSPECT_REVENUE,0)) > DECODE(p_IS_REVENUE_PERCENT,1,-99999999999,p_MIN_REVENUE)  -- if percent, don't care
			   -- margin
			   AND SUM(NVL(PROSPECT_REVENUE - PROSPECT_COST,0)) > DECODE(p_IS_MARGIN_PERCENT,1,-99999999999,p_MIN_MARGIN)  -- if percent, don't care
			   -- savings
			   AND SUM(NVL(PROSPECT_COMPARE - PROSPECT_REVENUE,0)) > DECODE(p_IS_SAVINGS_PERCENT,1,-99999999999,p_MIN_SAVINGS)  -- if percent, don't care
			   -- margin %
			   AND 100 * (SUM(NVL(PROSPECT_REVENUE,0)) - SUM(NVL(PROSPECT_COST,0))) / (SUM(NVL(PROSPECT_REVENUE,0)) + .0001) > DECODE(p_IS_MARGIN_PERCENT,0,-99999999999,p_MIN_MARGIN)  -- if NOT percent, don't care
			   -- savings %
			   AND 100 * (SUM(NVL(PROSPECT_COMPARE,0)) - SUM(NVL(PROSPECT_REVENUE,0))) / (SUM(NVL(PROSPECT_COMPARE,0)) + .0001) > DECODE(p_IS_SAVINGS_PERCENT,0,-99999999999,p_MIN_SAVINGS)  -- if NOT percent, don't care
			ORDER BY P.ACCOUNT_NUMBER, MIN(SERVICE_MONTH);
	END IF;


END PROSPECT_EVALUATION_RESULTS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_POSITION_PARTICIPANT
	(
	o_OID OUT NUMBER,
	p_PARTICIPANT_ID IN NUMBER,
	p_EVALUATION_ID IN NUMBER,
	p_PARTICIPANT_ENTITY_ID IN NUMBER,
	p_PARTICIPANT_TYPE IN VARCHAR,
	p_PARTICIPANT_NAME IN VARCHAR,
	p_LOSS_FACTOR_ID IN NUMBER,
	p_STATION_ID IN NUMBER,
	p_CALENDAR_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_USAGE_FACTOR IN NUMBER,
	p_USE_BILLING_DETERMINANTS IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

v_PARTICIPANT_ID NUMBER;
v_CALENDAR_PROJECTION_TYPE VARCHAR(1);

-- Put a POSITION_ANALYSIS_PARTICIPANT record
BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	IF p_PARTICIPANT_ID = CONSTANTS.NOT_ASSIGNED THEN
		SELECT QID.NEXTVAL INTO v_PARTICIPANT_ID FROM DUAL;
	ELSE
		v_PARTICIPANT_ID := p_PARTICIPANT_ID;
	END IF;

	IF QM.IS_WRF_CALENDAR(p_CALENDAR_ID,SYSDATE) THEN
	    v_CALENDAR_PROJECTION_TYPE := 'W';
	ELSE
	    v_CALENDAR_PROJECTION_TYPE := 'P';
	END IF;

	UPDATE POSITION_ANALYSIS_PARTICIPANT SET
		PARTICIPANT_ENTITY_ID = p_PARTICIPANT_ENTITY_ID,
		PARTICIPANT_TYPE = p_PARTICIPANT_TYPE,
		PARTICIPANT_NAME = p_PARTICIPANT_NAME,
		LOSS_FACTOR_ID = p_LOSS_FACTOR_ID,
		STATION_ID = p_STATION_ID,
		CALENDAR_ID = p_CALENDAR_ID,
		PRODUCT_ID = p_PRODUCT_ID,
		CALENDAR_PROJECTION_TYPE = v_CALENDAR_PROJECTION_TYPE,
		USAGE_FACTOR = p_USAGE_FACTOR,
		USE_BILLING_DETERMINANTS = p_USE_BILLING_DETERMINANTS,
		ENTRY_DATE = SYSDATE
	WHERE PARTICIPANT_ID = v_PARTICIPANT_ID
		AND EVALUATION_ID = p_EVALUATION_ID;
	o_OID := v_PARTICIPANT_ID;

	IF SQL%NOTFOUND THEN
		INSERT INTO POSITION_ANALYSIS_PARTICIPANT (
			PARTICIPANT_ID,
			EVALUATION_ID,
			PARTICIPANT_ENTITY_ID,
			PARTICIPANT_TYPE,
			PARTICIPANT_NAME,
			LOSS_FACTOR_ID,
			STATION_ID,
			CALENDAR_ID,
			PRODUCT_ID,
			CALENDAR_PROJECTION_TYPE,
			USAGE_FACTOR,
			USE_BILLING_DETERMINANTS,
			ENTRY_DATE)
		VALUES (
			v_PARTICIPANT_ID,
			p_EVALUATION_ID,
			p_PARTICIPANT_ENTITY_ID,
			p_PARTICIPANT_TYPE,
			p_PARTICIPANT_NAME,
			p_LOSS_FACTOR_ID,
			p_STATION_ID,
			p_CALENDAR_ID,
			p_PRODUCT_ID,
			v_CALENDAR_PROJECTION_TYPE,
			p_USAGE_FACTOR,
			p_USE_BILLING_DETERMINANTS,
			SYSDATE);
	    o_OID := v_PARTICIPANT_ID;
	END IF;

END PUT_POSITION_PARTICIPANT;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_PROSPECT_EVALUATION
	(
	p_EVALUATION_ID IN NUMBER,
	p_PROSPECT_ID IN NUMBER,
	p_DETERMINANTS IN DETERMINANT_TABLE,
	p_OFFER IN CHARGE_COMPONENT_TABLE,
	p_COST IN CHARGE_COMPONENT_TABLE,
	p_COMPARE IN CHARGE_COMPONENT_TABLE
	) AS

CURSOR c_DATA IS
	SELECT TRUNC(A.DAY_DATE(),'MONTH') "MONTH",
		SUM(A.DETERMINANT_1) "ENERGY",
		MAX(A.DETERMINANT_2) "DEMAND"
	FROM TABLE(CAST(p_DETERMINANTS AS DETERMINANT_TABLE)) A
	GROUP BY TRUNC(A.DAY_DATE(),'MONTH');

v_REVENUE NUMBER;
v_COST NUMBER;
v_COMPARE NUMBER;

BEGIN

	DELETE PROSPECT_EVALUATION WHERE EVALUATION_ID = p_EVALUATION_ID AND PROSPECT_ID = p_PROSPECT_ID;

	FOR v_DATA IN c_DATA LOOP
		SELECT SUM(A.AMOUNT) INTO v_REVENUE FROM TABLE(CAST(p_OFFER AS CHARGE_COMPONENT_TABLE)) A WHERE TRUNC(A.BEGIN_DATE,'MONTH') = v_DATA.MONTH;
		SELECT SUM(A.AMOUNT) INTO v_COST FROM TABLE(CAST(p_COST AS CHARGE_COMPONENT_TABLE)) A WHERE TRUNC(A.BEGIN_DATE,'MONTH') = v_DATA.MONTH;
		SELECT SUM(A.AMOUNT) INTO v_COMPARE FROM TABLE(CAST(p_COMPARE AS CHARGE_COMPONENT_TABLE)) A WHERE TRUNC(A.BEGIN_DATE,'MONTH') = v_DATA.MONTH;
		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG(TO_CHAR(v_DATA.MONTH) || ',' || TO_CHAR(v_DATA.ENERGY) || ',' || TO_CHAR(v_DATA.DEMAND) || ',' || TO_CHAR( v_REVENUE) || ',' || TO_CHAR( v_COST) || ',' || TO_CHAR( v_COMPARE));
		END IF;
		INSERT INTO PROSPECT_EVALUATION VALUES(p_EVALUATION_ID, p_PROSPECT_ID, v_DATA.MONTH, v_DATA.ENERGY, v_DATA.DEMAND, v_REVENUE, v_COST, v_COMPARE);
	END LOOP;

END PUT_PROSPECT_EVALUATION;
---------------------------------------------------------------------------------------------------
PROCEDURE RUN_PROSPECT_EVALUATION
    (
	p_SCREEN_ID IN NUMBER,
	p_EVALUATION_ID IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

v_PROSPECT_SCREEN_EVALUATION PROSPECT_SCREEN_EVALUATION%ROWTYPE;
v_CONSUMPTION CONSUMPTION_TABLE := CONSUMPTION_TABLE();
v_DETERMINANTS DETERMINANT_TABLE := DETERMINANT_TABLE();
v_OFFER CHARGE_COMPONENT_TABLE := CHARGE_COMPONENT_TABLE();
v_COST CHARGE_COMPONENT_TABLE := CHARGE_COMPONENT_TABLE();
v_COMPARE CHARGE_COMPONENT_TABLE := CHARGE_COMPONENT_TABLE();
v_LAST_PROSPECT_ID NUMBER(9) := 999999999;
v_LOSS_FACTOR NUMBER;
v_CALENDAR_NAME CALENDAR.CALENDAR_NAME%TYPE; --@@Implementation Override--

CURSOR c_PROSPECT_CONSUMPTION IS
	SELECT C.PROSPECT_ID, C.BEGIN_DATE, C.END_DATE, C.TEMPLATE_ID, C.PERIOD_ID, C.ENERGY, C.DEMAND
	FROM PROSPECT_SCREEN_EVALUATION A, PROSPECT B, PROSPECT_CONSUMPTION C
	WHERE A.SCREEN_ID = p_SCREEN_ID
		AND A.EVALUATION_ID = p_EVALUATION_ID
		AND B.SCREEN_ID = A.SCREEN_ID
		AND B.PROFILE_CALENDAR_ID = A.PROFILE_CALENDAR_ID
		AND B.COMPARE_PRODUCT_ID = A.COMPARE_PRODUCT_ID
		AND C.PROSPECT_ID = B.PROSPECT_ID
	UNION
	SELECT 999999999, SYSDATE, SYSDATE, 0, 0, 0, 0 FROM DUAL
	ORDER BY 1;

BEGIN

	p_STATUS := GA.SUCCESS;

	SELECT *
	INTO v_PROSPECT_SCREEN_EVALUATION
	FROM PROSPECT_SCREEN_EVALUATION
	WHERE EVALUATION_ID = p_EVALUATION_ID;

	v_LOSS_FACTOR := GET_LOSS_FACTOR(v_PROSPECT_SCREEN_EVALUATION.LOSS_FACTOR_ID, v_PROSPECT_SCREEN_EVALUATION.BEGIN_DATE);

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('RUN_PROSPECT_EVALUATION');
		LOGS.LOG_DEBUG('EVALUATION_ID=' || TO_CHAR(p_EVALUATION_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TO_CHAR(v_PROSPECT_SCREEN_EVALUATION.BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TO_CHAR(v_PROSPECT_SCREEN_EVALUATION.END_DATE));
		LOGS.LOG_DEBUG('LOSS_FACTOR=' || TO_CHAR(v_LOSS_FACTOR));
	END IF;

	FOR v_PROSPECT_CONSUMPTION IN c_PROSPECT_CONSUMPTION LOOP
		IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
			LOGS.LOG_DEBUG_DETAIL('PROSPECT_ID=' || TO_CHAR(v_PROSPECT_CONSUMPTION.PROSPECT_ID) || ', LAST_PROSPECT_ID=' || TO_CHAR(v_LAST_PROSPECT_ID));
		END IF;
		IF NOT v_PROSPECT_CONSUMPTION.PROSPECT_ID = v_LAST_PROSPECT_ID AND NOT v_LAST_PROSPECT_ID = 999999999 THEN
			IF v_CONSUMPTION.COUNT > 0 THEN
				CU.GET_PRORATED_DETERMINANTS(v_PROSPECT_SCREEN_EVALUATION.PROFILE_CALENDAR_ID, v_PROSPECT_SCREEN_EVALUATION.BEGIN_DATE, v_PROSPECT_SCREEN_EVALUATION.END_DATE, p_AS_OF_DATE, v_CONSUMPTION, LOGS.IS_DEBUG_DETAIL_ENABLED, v_DETERMINANTS);
				IF v_DETERMINANTS.COUNT = 0 THEN
					v_CALENDAR_NAME := GET_CALENDAR_NAME(v_PROSPECT_SCREEN_EVALUATION.PROFILE_CALENDAR_ID);
					ERRS.RAISE(MSGCODES.c_ERR_GENERAL,'MISSING CALENDAR PROJECTION DETERMINANTS FOR ' || v_CALENDAR_NAME);
				END IF;
				CU.APPLY_PRODUCT_COMPONENTS(v_PROSPECT_SCREEN_EVALUATION.OFFER_PRODUCT_ID, v_DETERMINANTS, v_PROSPECT_SCREEN_EVALUATION.BEGIN_DATE, v_PROSPECT_SCREEN_EVALUATION.END_DATE, LOGS.IS_DEBUG_ENABLED, v_OFFER);
				CU.APPLY_PRODUCT_COMPONENTS(v_PROSPECT_SCREEN_EVALUATION.COST_PRODUCT_ID, v_DETERMINANTS, v_PROSPECT_SCREEN_EVALUATION.BEGIN_DATE, v_PROSPECT_SCREEN_EVALUATION.END_DATE, 1, v_LOSS_FACTOR, LOGS.IS_DEBUG_ENABLED, v_COST);
				CU.APPLY_PRODUCT_COMPONENTS(v_PROSPECT_SCREEN_EVALUATION.COMPARE_PRODUCT_ID, v_DETERMINANTS, v_PROSPECT_SCREEN_EVALUATION.BEGIN_DATE, v_PROSPECT_SCREEN_EVALUATION.END_DATE, LOGS.IS_DEBUG_ENABLED, v_COMPARE);
				PUT_PROSPECT_EVALUATION(p_EVALUATION_ID, v_LAST_PROSPECT_ID, v_DETERMINANTS, v_OFFER, v_COST, v_COMPARE);
				v_CONSUMPTION.DELETE;
				v_OFFER.DELETE;
				v_COST.DELETE;
				v_COMPARE.DELETE;
			END IF;
		END IF;
		v_CONSUMPTION.EXTEND;
		v_CONSUMPTION(v_CONSUMPTION.LAST) := CONSUMPTION_TYPE(v_PROSPECT_CONSUMPTION.BEGIN_DATE, v_PROSPECT_CONSUMPTION.END_DATE, v_PROSPECT_CONSUMPTION.TEMPLATE_ID, v_PROSPECT_CONSUMPTION.PERIOD_ID, v_PROSPECT_CONSUMPTION.ENERGY, v_PROSPECT_CONSUMPTION.DEMAND);
		v_LAST_PROSPECT_ID := v_PROSPECT_CONSUMPTION.PROSPECT_ID;
	END LOOP;

END RUN_PROSPECT_EVALUATION;
---------------------------------------------------------------------------------------------------
PROCEDURE RUN_PROSPECT_EVALUATIONS
    (
	p_SCREEN_ID IN NUMBER,
	p_EVALUATION_ID_LIST IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

v_ARGUMENTS_TABLE GA.STRING_TABLE;
v_INDEX BINARY_INTEGER;
v_EVALUATION_ID NUMBER;
v_ELASPSED NUMBER := DBMS_UTILITY.GET_TIME;
v_AS_OF_DATE DATE;


BEGIN

	v_AS_OF_DATE := LOW_DATE;  --For now, always use LOW_DATE instead of p_AS_OF_DATE

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK.';
	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('RUN_PROSPECT_EVALUATIONS BEGIN AT ' || UT.TRACE_DATE(SYSDATE));
		LOGS.LOG_DEBUG('SCREEN_ID=' || TO_CHAR(p_SCREEN_ID));
		LOGS.LOG_DEBUG('EVALUATION_ID_LIST=' || p_EVALUATION_ID_LIST);
	END IF;

	UT.TOKENS_FROM_STRING(p_EVALUATION_ID_LIST, ';', v_ARGUMENTS_TABLE);

	FOR v_INDEX IN v_ARGUMENTS_TABLE.FIRST..v_ARGUMENTS_TABLE.LAST LOOP
		IF LENGTH(v_ARGUMENTS_TABLE(v_INDEX)) > 0 THEN
			v_EVALUATION_ID := v_ARGUMENTS_TABLE(v_INDEX);
			RUN_PROSPECT_EVALUATION(p_SCREEN_ID, v_EVALUATION_ID, v_AS_OF_DATE, p_STATUS, p_MESSAGE);
		END IF;
	END LOOP;

	v_ELASPSED := DBMS_UTILITY.GET_TIME - v_ELASPSED;

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('RUN_PROSPECT_EVALUATIONS END AT ' || UT.TRACE_DATE(SYSDATE));
	    LOGS.LOG_DEBUG('ELAPSED TIME=' || TO_CHAR(v_ELASPSED));
 	END IF;

END RUN_PROSPECT_EVALUATIONS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_CALENDAR_PROJECTION
	(
	p_CALENDAR_ID IN NUMBER,
	p_PROJECTION_TYPE IN VARCHAR,
	p_TEMPLATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_INTERVAL IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names and IDs of calendars.

v_AS_OF_DATE DATE;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_INTERVAL VARCHAR(16);

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	v_AS_OF_DATE := CORRECTED_AS_OF_DATE(p_AS_OF_DATE,'Profiling');

	IF SUBSTR(p_PROJECTION_TYPE,1,1) = 'M' THEN
		OPEN p_CURSOR FOR
			SELECT FROM_CUT_AS_HED(B.PROJECTION_DATE, STD_TIME_ZONE(LOCAL_TIME_ZONE), p_INTERVAL) AS PROJECTION_DATE,
				B.PERIOD_ID, SUM(B.ENERGY) AS ENERGY, MAX(B.DEMAND) AS DEMAND
			FROM CALENDAR_PROJECTION A, PROJECTION_PATTERN B
			WHERE CALENDAR_ID = p_CALENDAR_ID
				AND PROJECTION_TYPE = 'MONTH'
				AND TEMPLATE_ID = CONSTANTS.NOT_ASSIGNED
				AND AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM CALENDAR_PROJECTION
					WHERE CALENDAR_ID = A.CALENDAR_ID
						AND PROJECTION_TYPE = A.PROJECTION_TYPE
						AND TEMPLATE_ID = A.TEMPLATE_ID
						AND AS_OF_DATE <= v_AS_OF_DATE)
				AND B.PROJECTION_ID = A.PROJECTION_ID
				AND B.PROJECTION_DATE BETWEEN TRUNC(p_BEGIN_DATE,'DD') AND TRUNC(p_END_DATE,'DD')
			GROUP BY FROM_CUT_AS_HED(B.PROJECTION_DATE, STD_TIME_ZONE(LOCAL_TIME_ZONE), p_INTERVAL), B.PERIOD_ID
			ORDER BY 1,2;
	ELSE
		SELECT DECODE(p_INTERVAL, 'DD', 'DAY', 'MM', 'MONTH', 'HOUR') INTO v_INTERVAL FROM DUAL;
		v_BEGIN_DATE := TRUNC(p_BEGIN_DATE, p_INTERVAL);
		v_END_DATE := ADVANCE_DATE(TRUNC(p_END_DATE, p_INTERVAL), v_INTERVAL);
		OPEN p_CURSOR FOR
			SELECT FROM_CUT_AS_HED(B.PROJECTION_DATE, STD_TIME_ZONE(LOCAL_TIME_ZONE), p_INTERVAL, 2) AS PROJECTION_DATE,
				B.PERIOD_ID, SUM(B.ENERGY) AS ENERGY, MAX(B.DEMAND) AS DEMAND
			FROM CALENDAR_PROJECTION A, PROJECTION_PATTERN B
			WHERE CALENDAR_ID = p_CALENDAR_ID
				AND PROJECTION_TYPE = 'DAY'
				AND TEMPLATE_ID = p_TEMPLATE_ID
				AND AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM CALENDAR_PROJECTION
					WHERE CALENDAR_ID = A.CALENDAR_ID
						AND PROJECTION_TYPE = A.PROJECTION_TYPE
						AND TEMPLATE_ID = A.TEMPLATE_ID
						AND AS_OF_DATE <= v_AS_OF_DATE)
				AND B.PROJECTION_ID = A.PROJECTION_ID
				AND B.PROJECTION_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			GROUP BY FROM_CUT_AS_HED(B.PROJECTION_DATE, STD_TIME_ZONE(LOCAL_TIME_ZONE), p_INTERVAL, 2), B.PERIOD_ID
			ORDER BY 1,2;
	END IF;


END GET_CALENDAR_PROJECTION;
---------------------------------------------------------------------------------------------------
PROCEDURE CONTOUR_POSITION_ANALYSIS_WEA
	(
	p_EVALUATION_ID IN NUMBER,
	p_STATION_ID IN NUMBER,
	p_PARAMETER_ID IN NUMBER,
	p_TARGET_MONTH IN DATE,
	p_PARAMETER_AVG IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_ENTRY_DATE DATE := SYSDATE;
v_AVG_FACTOR NUMBER;

CURSOR c_FACTOR IS
	SELECT TRUNC(FROM_CUT(PARAMETER_DATE,LOCAL_TIME_ZONE) - g_SECOND) "PARAMETER_DATE",
		COUNT(PARAMETER_VAL) "HOURS",
		SUM(PARAMETER_VAL) "PARAMETER_SUM"
	FROM POSITION_ANALYSIS_WEATHER
	WHERE EVALUATION_ID = p_EVALUATION_ID
		AND STATION_ID = p_STATION_ID
		AND PARAMETER_ID = p_PARAMETER_ID
		AND PARAMETER_INTERVAL = 'H'
		AND PARAMETER_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
	GROUP BY TRUNC(FROM_CUT(PARAMETER_DATE,LOCAL_TIME_ZONE) - g_SECOND);

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('CONTOUR_POSITION_ANALYSIS_WEA');
		LOGS.LOG_DEBUG('EVALUATION_ID=' || TO_CHAR(p_EVALUATION_ID));
		LOGS.LOG_DEBUG('STATION_ID=' || TO_CHAR(p_STATION_ID));
		LOGS.LOG_DEBUG('PARAMETER_ID=' || TO_CHAR(p_PARAMETER_ID));
		LOGS.LOG_DEBUG('TARGET_MONTH=' || TO_CHAR(p_TARGET_MONTH));
		LOGS.LOG_DEBUG('PARAMETER_AVG=' || TO_CHAR(p_PARAMETER_AVG));
	END IF;

	UT.CUT_DATE_RANGE(TRUNC(p_TARGET_MONTH,'MONTH'), LAST_DAY(p_TARGET_MONTH), LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	FOR v_FACTOR IN c_FACTOR LOOP
		v_AVG_FACTOR := p_PARAMETER_AVG * v_FACTOR.HOURS / v_FACTOR.PARAMETER_SUM;
	END LOOP;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('AVG_FACTOR=' || TO_CHAR(v_AVG_FACTOR));
	END IF;

	UPDATE POSITION_ANALYSIS_WEATHER
	SET PARAMETER_VAL = PARAMETER_VAL * v_AVG_FACTOR,
		ENTRY_DATE = v_ENTRY_DATE
	WHERE EVALUATION_ID = p_EVALUATION_ID
		AND STATION_ID = p_STATION_ID
		AND PARAMETER_ID = p_PARAMETER_ID
		AND PARAMETER_INTERVAL = 'H'
		AND PARAMETER_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE;

END CONTOUR_POSITION_ANALYSIS_WEA;
---------------------------------------------------------------------------------------------------
PROCEDURE CONTOUR_POSITION_ANALYSIS_SPOT
	(
	p_EVALUATION_ID IN NUMBER,
	p_MARKET_PRICE_ID IN NUMBER,
	p_TARGET_MONTH IN DATE,
	p_ON_PEAK_AVG IN NUMBER,
	p_OFF_PEAK_AVG IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_ENTRY_DATE DATE := SYSDATE;
v_ON_PEAK_FACTOR NUMBER;
v_OFF_PEAK_FACTOR NUMBER;

CURSOR c_FACTOR IS
	SELECT DECODE(DECODE(TO_CHAR(PRICE_DATE,'HH24'),23,2,0,2,1,2,2,2,3,2,4,2,5,2,6,2,1),1,'P', 'O') "TOU",
		COUNT(PRICE_VAL) "HOURS",
		SUM(PRICE_VAL) "PRICE_SUM"
	FROM POSITION_ANALYSIS_SPOT_MARKET
	WHERE EVALUATION_ID = p_EVALUATION_ID
		AND MARKET_PRICE_ID = p_MARKET_PRICE_ID
		AND PRICE_INTERVAL = 'H'
		AND PRICE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
	GROUP BY DECODE(DECODE(TO_CHAR(PRICE_DATE,'HH24'),23,2,0,2,1,2,2,2,3,2,4,2,5,2,6,2,1),1,'P', 'O');

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('CONTOUR_POSITION_ANALYSIS_SPOT');
	END IF;

	UT.CUT_DATE_RANGE(TRUNC(p_TARGET_MONTH,'MONTH'), LAST_DAY(p_TARGET_MONTH), LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	FOR v_FACTOR IN c_FACTOR LOOP
		IF v_FACTOR.TOU = 'P' THEN
			v_ON_PEAK_FACTOR := p_ON_PEAK_AVG * v_FACTOR.HOURS / v_FACTOR.PRICE_SUM;
		ELSIF v_FACTOR.TOU = 'O' THEN
			v_OFF_PEAK_FACTOR := p_OFF_PEAK_AVG * v_FACTOR.HOURS / v_FACTOR.PRICE_SUM;
		END IF;
	END LOOP;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('ON_PEAK_FACTOR=' || TO_CHAR(v_ON_PEAK_FACTOR));
		LOGS.LOG_DEBUG('OFF_PEAK_FACTOR=' || TO_CHAR(v_OFF_PEAK_FACTOR));
	END IF;

	UPDATE POSITION_ANALYSIS_SPOT_MARKET
	SET PRICE_VAL = PRICE_VAL * DECODE(DECODE(TO_CHAR(PRICE_DATE,'HH24'),23,2,0,2,1,2,2,2,3,2,4,2,5,2,6,2,1),1, v_ON_PEAK_FACTOR, v_OFF_PEAK_FACTOR),
		ENTRY_DATE = v_ENTRY_DATE
	WHERE EVALUATION_ID = p_EVALUATION_ID
		AND MARKET_PRICE_ID = p_MARKET_PRICE_ID
		AND PRICE_INTERVAL = 'H'
		AND PRICE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE;

END CONTOUR_POSITION_ANALYSIS_SPOT;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_POSITION_ANALYSIS_SPOT
	(
	p_EVALUATION_ID IN NUMBER,
	p_MARKET_PRICE_ID IN NUMBER,
	p_SOURCE_DATE IN DATE,
	p_TARGET_DATE IN DATE,
	p_ENTRY_DATE IN DATE
	) AS

--Deprecated at 2.2 - replaced by PUT_POSITION_ANALYSIS_SPOTMKT
v_AS_OF_DATE DATE := SYSDATE;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_TIME_ZONE CHAR(3) := STD_TIME_ZONE(LOCAL_TIME_ZONE);
v_TARGET_YEAR CHAR(5) := TO_CHAR(p_TARGET_DATE,'-YYYY');
v_TARGET_DATE CHAR(7) := TO_CHAR(p_TARGET_DATE,'DD-MON-');

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PUT_POSITION_ANALYSIS_SPOT');
		LOGS.LOG_DEBUG('EVALUATION_ID=' || TO_CHAR(p_EVALUATION_ID));
		LOGS.LOG_DEBUG('MARKET_PRICE_ID=' || TO_CHAR(p_MARKET_PRICE_ID));
		LOGS.LOG_DEBUG('SOURCE_DATE=' || TO_CHAR(p_SOURCE_DATE));
		LOGS.LOG_DEBUG('TARGET_DATE=' || TO_CHAR(p_TARGET_DATE));
	END IF;

	UT.CUT_DATE_RANGE(p_SOURCE_DATE, v_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	INSERT INTO POSITION_ANALYSIS_SPOT_MARKET(EVALUATION_ID, MARKET_PRICE_ID, PRICE_INTERVAL, PRICE_DATE, PRICE_VAL, ENTRY_DATE)
	SELECT p_EVALUATION_ID,
		p_MARKET_PRICE_ID,
		'H',
		DECODE(GA.DEFAULT_MODEL, GA.ELECTRIC_MODEL, TO_CUT(TO_DATE(v_TARGET_DATE || TO_CHAR(FROM_CUT(PRICE_DATE,v_TIME_ZONE),'HH24') || v_TARGET_YEAR, 'DD-MON-HH24-YYYY') + DECODE(TO_CHAR(FROM_CUT(PRICE_DATE,v_TIME_ZONE),'HH24'),0,1,0), v_TIME_ZONE), p_TARGET_DATE),
		PRICE,
		p_ENTRY_DATE
	FROM MARKET_PRICE_VALUE A
	WHERE A.MARKET_PRICE_ID = p_MARKET_PRICE_ID
		AND A.PRICE_CODE = 'A'
		AND A.PRICE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM MARKET_PRICE_VALUE
			WHERE MARKET_PRICE_ID = A.MARKET_PRICE_ID
				AND PRICE_CODE = A.PRICE_CODE
				AND PRICE_DATE = A.PRICE_DATE
				AND AS_OF_DATE <= v_AS_OF_DATE);

END PUT_POSITION_ANALYSIS_SPOT;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_POSITION_ANALYSIS_SPOTMKT
	(
	p_MODEL_ID IN NUMBER,
	p_EVALUATION_ID IN NUMBER,
	p_MARKET_PRICE_ID IN NUMBER,
	p_SOURCE_DATE IN DATE,
	p_TARGET_DATE IN DATE,
	p_ENTRY_DATE IN DATE
	) AS

--Adapted from PUT_POSITION_ANALYSIS_SPOT at 2.2 to include p_MODEL_ID

v_AS_OF_DATE DATE := SYSDATE;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_TIME_ZONE CHAR(3) := STD_TIME_ZONE(LOCAL_TIME_ZONE);
v_TARGET_YEAR CHAR(5) := TO_CHAR(p_TARGET_DATE,'-YYYY');
v_TARGET_DATE CHAR(7) := TO_CHAR(p_TARGET_DATE,'DD-MON-');

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PUT_POSITION_ANALYSIS_SPOT');
		LOGS.LOG_DEBUG('EVALUATION_ID=' || TO_CHAR(p_EVALUATION_ID));
		LOGS.LOG_DEBUG('MARKET_PRICE_ID=' || TO_CHAR(p_MARKET_PRICE_ID));
		LOGS.LOG_DEBUG('SOURCE_DATE=' || TO_CHAR(p_SOURCE_DATE));
		LOGS.LOG_DEBUG('TARGET_DATE=' || TO_CHAR(p_TARGET_DATE));
	END IF;

	UT.CUT_DATE_RANGE(p_MODEL_ID,  p_SOURCE_DATE, v_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	INSERT INTO POSITION_ANALYSIS_SPOT_MARKET(EVALUATION_ID, MARKET_PRICE_ID, PRICE_INTERVAL, PRICE_DATE, PRICE_VAL, ENTRY_DATE)
	SELECT p_EVALUATION_ID,
		p_MARKET_PRICE_ID,
		'H',
        --For Electric, create new CUT date mapped to target year, (??for now, trunc'd to Hour by 'HH24' ??!!)
        --For Gas, just use p_TARGET_DATE.
		DECODE(p_MODEL_ID, GA.ELECTRIC_MODEL, TO_CUT(TO_DATE(v_TARGET_DATE || TO_CHAR(FROM_CUT(PRICE_DATE,v_TIME_ZONE),'HH24') || v_TARGET_YEAR, 'DD-MON-HH24-YYYY') + DECODE(TO_CHAR(FROM_CUT(PRICE_DATE,v_TIME_ZONE),'HH24'),0,1,0), v_TIME_ZONE), p_TARGET_DATE),
		PRICE,
		p_ENTRY_DATE
	FROM MARKET_PRICE_VALUE A
	WHERE A.MARKET_PRICE_ID = p_MARKET_PRICE_ID
		AND A.PRICE_CODE = 'A'
		AND A.PRICE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM MARKET_PRICE_VALUE
			WHERE MARKET_PRICE_ID = A.MARKET_PRICE_ID
				AND PRICE_CODE = A.PRICE_CODE
				AND PRICE_DATE = A.PRICE_DATE
				AND AS_OF_DATE <= v_AS_OF_DATE);

END PUT_POSITION_ANALYSIS_SPOTMKT;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_POSITION_ANALYSIS_SPOT_AVG
	(
	p_MODEL_ID IN NUMBER,
	p_EVALUATION_ID IN NUMBER,
	p_MARKET_PRICE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ENTRY_DATE IN DATE
	) AS

-- Calculate the On-Peak and Off-Peak monthly price averages for the CUT_DATE_RANGE.
-- Call PUT_POSITION_ANALYSIS_SPOT_AVG with a CUT_DATE_RANGE!

v_TIME_ZONE CHAR(3) := LOCAL_TIME_ZONE;
v_ADJUST NUMBER(6,5) :=  1/86400;      --1 second for Electric

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PUT_POSITION_ANALYSIS_SPOT_AVG');
		LOGS.LOG_DEBUG('EVALUATION_ID=' || TO_CHAR(p_EVALUATION_ID));
		LOGS.LOG_DEBUG('MARKET_PRICE_ID=' || TO_CHAR(p_MARKET_PRICE_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || UT.TRACE_DATE(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || UT.TRACE_DATE(p_END_DATE));
	END IF;

    IF p_MODEL_ID = GA.GAS_MODEL THEN
		v_ADJUST := 0;     --no adjustment for Gas
	END IF;

-- Insert 'P' and 'O' monthly seed values
	INSERT INTO POSITION_ANALYSIS_SPOT_MARKET(EVALUATION_ID, MARKET_PRICE_ID, PRICE_INTERVAL, PRICE_DATE, ENTRY_DATE, PRICE_VAL)
	SELECT EVALUATION_ID,
		MARKET_PRICE_ID,
		DECODE(DECODE(TO_CHAR(FROM_CUT(PRICE_DATE, v_TIME_ZONE),'HH24'),23,2,0,2,1,2,2,2,3,2,4,2,5,2,6,2,1),1,'P', 'O'),
		--Use TRUNC of FROM_CUT dates here for Hourly but not for Daily Gas Model
		TRUNC(DECODE(p_MODEL_ID, GA.GAS_MODEL, PRICE_DATE, FROM_CUT(PRICE_DATE, v_TIME_ZONE) - v_ADJUST), 'MONTH'),
		p_ENTRY_DATE,
		AVG(PRICE_VAL)
	FROM POSITION_ANALYSIS_SPOT_MARKET A
	WHERE A.EVALUATION_ID = p_EVALUATION_ID
		AND A.MARKET_PRICE_ID = p_MARKET_PRICE_ID
		AND A.PRICE_INTERVAL = 'H'
		AND A.PRICE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
	GROUP BY EVALUATION_ID,
		MARKET_PRICE_ID,
		DECODE(DECODE(TO_CHAR(FROM_CUT(PRICE_DATE, v_TIME_ZONE),'HH24'),23,2,0,2,1,2,2,2,3,2,4,2,5,2,6,2,1),1,'P', 'O'),
		TRUNC(DECODE(p_MODEL_ID, GA.GAS_MODEL, PRICE_DATE, FROM_CUT(PRICE_DATE, v_TIME_ZONE) - v_ADJUST), 'MONTH'),
		p_ENTRY_DATE;

END PUT_POSITION_ANALYSIS_SPOT_AVG;
---------------------------------------------------------------------------------------------------
PROCEDURE SEED_POSITION_ANALYSIS_SPOT
	(
	p_EVALUATION_ID IN NUMBER,
	p_MARKET_PRICE_ID IN NUMBER,
	p_SOURCE_YEAR IN DATE,
	p_TARGET_YEAR IN DATE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

    --Deprecated at 2.2 - replaced by SEED_POSITION_ANALYSIS_SPOTMKT to include p_MODEL_ID

v_TARGET_DATE DATE;
v_TARGET_YEAR_BEGIN_DATE DATE;
v_TARGET_YEAR_END_DATE DATE;
v_SOURCE_DATE DATE;
v_SOURCE_BEGIN_DATE DATE;
v_SOURCE_END_DATE DATE;
v_ELASPSED NUMBER;
v_STATUS NUMBER;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_ENTRY_DATE DATE := SYSDATE;

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK.';

	IF LOGS.IS_DEBUG_ENABLED THEN
	   	v_ELASPSED := DBMS_UTILITY.GET_TIME;
		LOGS.LOG_DEBUG('SEED_POSITION_ANALYSIS_SPOT BEGIN AT ' || UT.TRACE_DATE(SYSDATE));
		LOGS.LOG_DEBUG('EVALUATION_ID=' || TO_CHAR(p_EVALUATION_ID));
		LOGS.LOG_DEBUG('MARKET_PRICE_ID=' || TO_CHAR(p_MARKET_PRICE_ID));
		LOGS.LOG_DEBUG('SOURCE_YEAR=' || TO_CHAR(p_SOURCE_YEAR));
		LOGS.LOG_DEBUG('TARGET_YEAR=' || TO_CHAR(p_TARGET_YEAR));
	END IF;

	v_SOURCE_BEGIN_DATE := TRUNC(p_SOURCE_YEAR,'YEAR');
	v_SOURCE_END_DATE := LAST_DAY(ADD_MONTHS(TRUNC(p_SOURCE_YEAR,'YEAR'),11));
	v_TARGET_DATE := TRUNC(p_TARGET_YEAR,'YEAR');
	v_TARGET_YEAR_BEGIN_DATE := v_TARGET_DATE;
	v_TARGET_YEAR_END_DATE := LAST_DAY(ADD_MONTHS(v_TARGET_YEAR_BEGIN_DATE,11));
	UT.CUT_DATE_RANGE(v_TARGET_DATE, v_TARGET_YEAR_END_DATE, LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

-- Clear the destination table to allow inserts.
	DELETE POSITION_ANALYSIS_SPOT_MARKET
	WHERE EVALUATION_ID = p_EVALUATION_ID
		AND MARKET_PRICE_ID = p_MARKET_PRICE_ID
		AND PRICE_INTERVAL= 'H'
		AND PRICE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE;

-- Loop over the days of the target year and replicate the closest similar day in the source year to each target day..
	WHILE v_TARGET_DATE <= v_TARGET_YEAR_END_DATE LOOP

		FS.SIMILAR_DAY_TYPE(CONSTANTS.NOT_ASSIGNED, v_TARGET_DATE, v_SOURCE_BEGIN_DATE, v_SOURCE_END_DATE, v_SOURCE_DATE, v_STATUS);
		PUT_POSITION_ANALYSIS_SPOTMKT(GA.DEFAULT_MODEL, p_EVALUATION_ID, p_MARKET_PRICE_ID, v_SOURCE_DATE, v_TARGET_DATE, v_ENTRY_DATE);
		v_TARGET_DATE := v_TARGET_DATE + 1;

	END LOOP;

-- Clear the destination table of non-hourly records to allow inserts.
	DELETE POSITION_ANALYSIS_SPOT_MARKET
	WHERE EVALUATION_ID = p_EVALUATION_ID
		AND MARKET_PRICE_ID = p_MARKET_PRICE_ID
		AND NOT PRICE_INTERVAL = 'H'
		--Monthly dates for AVGs are TRUNC'd to midnite - Not CUT dates
		AND PRICE_DATE BETWEEN v_TARGET_YEAR_BEGIN_DATE AND v_TARGET_YEAR_END_DATE;

-- Calculate the On-Peak and Off-Peak monthly price averages for this target year.
	PUT_POSITION_ANALYSIS_SPOT_AVG(GA.DEFAULT_MODEL, p_EVALUATION_ID, p_MARKET_PRICE_ID, v_BEGIN_DATE, v_END_DATE, v_ENTRY_DATE);

-- From 'P' and 'O' records just inserted, insert identical 'K' (PK) and 'F' (OFFPK)
-- monthly historical values to remain unchanged as reference to user
	INSERT INTO POSITION_ANALYSIS_SPOT_MARKET(EVALUATION_ID, MARKET_PRICE_ID, PRICE_INTERVAL, PRICE_DATE, ENTRY_DATE, PRICE_VAL)
	SELECT EVALUATION_ID,
		MARKET_PRICE_ID,
		DECODE(PRICE_INTERVAL,'P','K','O','F'),
		PRICE_DATE,
		ENTRY_DATE,
		PRICE_VAL
	FROM POSITION_ANALYSIS_SPOT_MARKET A
	WHERE A.EVALUATION_ID = p_EVALUATION_ID
		AND A.MARKET_PRICE_ID = p_MARKET_PRICE_ID
		--Monthly dates for AVGs are TRUNC'd to midnite - Not CUT dates
		AND A.PRICE_DATE BETWEEN v_TARGET_YEAR_BEGIN_DATE AND v_TARGET_YEAR_END_DATE
		AND A.PRICE_INTERVAL IN ('P','O');

	IF LOGS.IS_DEBUG_ENABLED THEN
		v_ELASPSED := DBMS_UTILITY.GET_TIME - v_ELASPSED;
		LOGS.LOG_DEBUG('SEED_POSITION_ANALYSIS_SPOT END AT ' || UT.TRACE_DATE(SYSDATE));
		LOGS.LOG_DEBUG('ELAPSED TIME=' || TO_CHAR(v_ELASPSED));
	END IF;

END SEED_POSITION_ANALYSIS_SPOT;
---------------------------------------------------------------------------------------------------
PROCEDURE SEED_POSITION_ANALYSIS_SPOTMKT
	(
	p_MODEL_ID IN NUMBER,
	p_EVALUATION_ID IN NUMBER,
	p_MARKET_PRICE_ID IN NUMBER,
	p_SOURCE_YEAR IN DATE,
	p_TARGET_YEAR IN DATE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

--Adapted from SEED_POSITION_ANALYSIS_SPOT at 2.2 to include p_MODEL_ID

v_TARGET_DATE DATE;
v_TARGET_YEAR_BEGIN_DATE DATE;
v_TARGET_YEAR_END_DATE DATE;
v_SOURCE_DATE DATE;
v_SOURCE_BEGIN_DATE DATE;
v_SOURCE_END_DATE DATE;
v_ELASPSED NUMBER;
v_STATUS NUMBER;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_ENTRY_DATE DATE := SYSDATE;

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK.';

	IF LOGS.IS_DEBUG_ENABLED THEN
	   	v_ELASPSED := DBMS_UTILITY.GET_TIME;
		LOGS.LOG_DEBUG('SEED_POSITION_ANALYSIS_SPOT BEGIN AT ' || UT.TRACE_DATE(SYSDATE));
		LOGS.LOG_DEBUG('EVALUATION_ID=' || TO_CHAR(p_EVALUATION_ID));
		LOGS.LOG_DEBUG('MARKET_PRICE_ID=' || TO_CHAR(p_MARKET_PRICE_ID));
		LOGS.LOG_DEBUG('SOURCE_YEAR=' || TO_CHAR(p_SOURCE_YEAR));
		LOGS.LOG_DEBUG('TARGET_YEAR=' || TO_CHAR(p_TARGET_YEAR));
	END IF;

	v_SOURCE_BEGIN_DATE := TRUNC(p_SOURCE_YEAR,'YEAR');
	v_SOURCE_END_DATE := LAST_DAY(ADD_MONTHS(TRUNC(p_SOURCE_YEAR,'YEAR'),11));
	v_TARGET_DATE := TRUNC(p_TARGET_YEAR,'YEAR');
	v_TARGET_YEAR_BEGIN_DATE := v_TARGET_DATE;
	v_TARGET_YEAR_END_DATE := LAST_DAY(ADD_MONTHS(v_TARGET_YEAR_BEGIN_DATE,11));
	UT.CUT_DATE_RANGE(p_MODEL_ID, v_TARGET_DATE, v_TARGET_YEAR_END_DATE, LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

-- Clear the destination table to allow inserts.
	DELETE POSITION_ANALYSIS_SPOT_MARKET
	WHERE EVALUATION_ID = p_EVALUATION_ID
		AND MARKET_PRICE_ID = p_MARKET_PRICE_ID
		AND PRICE_INTERVAL= 'H'
		--Use CUT_DATE_RANGE dates here to adjust for Hourly or Daily by Model
		AND PRICE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE;

-- Loop over the days of the target year and replicate the closest similar day in the source year to each target day..
	WHILE v_TARGET_DATE <= v_TARGET_YEAR_END_DATE LOOP

		FS.SIMILAR_DAY_TYPE(CONSTANTS.NOT_ASSIGNED, v_TARGET_DATE, v_SOURCE_BEGIN_DATE, v_SOURCE_END_DATE, v_SOURCE_DATE, v_STATUS);
		PUT_POSITION_ANALYSIS_SPOTMKT(p_MODEL_ID, p_EVALUATION_ID, p_MARKET_PRICE_ID, v_SOURCE_DATE, v_TARGET_DATE, v_ENTRY_DATE);
		v_TARGET_DATE := v_TARGET_DATE + 1;

	END LOOP;

-- Clear the destination table of non-hourly records to allow inserts.
	DELETE POSITION_ANALYSIS_SPOT_MARKET
	WHERE EVALUATION_ID = p_EVALUATION_ID
		AND MARKET_PRICE_ID = p_MARKET_PRICE_ID
		AND NOT PRICE_INTERVAL = 'H'
		--Monthly dates for AVGs are TRUNC'd to midnite - Not CUT dates
		AND PRICE_DATE BETWEEN v_TARGET_YEAR_BEGIN_DATE AND v_TARGET_YEAR_END_DATE;

-- Calculate the On-Peak and Off-Peak monthly price averages for this target year.
	PUT_POSITION_ANALYSIS_SPOT_AVG(p_MODEL_ID, p_EVALUATION_ID, p_MARKET_PRICE_ID, v_BEGIN_DATE, v_END_DATE, v_ENTRY_DATE);

-- From 'P' and 'O' records just inserted, insert identical 'K' (PK) and 'F' (OFFPK)
-- monthly historical values to remain unchanged as reference to user
	INSERT INTO POSITION_ANALYSIS_SPOT_MARKET(EVALUATION_ID, MARKET_PRICE_ID, PRICE_INTERVAL, PRICE_DATE, ENTRY_DATE, PRICE_VAL)
	SELECT EVALUATION_ID,
		MARKET_PRICE_ID,
		DECODE(PRICE_INTERVAL,'P','K','O','F'),
		PRICE_DATE,
		ENTRY_DATE,
		PRICE_VAL
	FROM POSITION_ANALYSIS_SPOT_MARKET A
	WHERE A.EVALUATION_ID = p_EVALUATION_ID
		AND A.MARKET_PRICE_ID = p_MARKET_PRICE_ID
		--Monthly dates for AVGs are TRUNC'd to midnite - Not CUT dates
		AND A.PRICE_DATE BETWEEN v_TARGET_YEAR_BEGIN_DATE AND v_TARGET_YEAR_END_DATE
		AND A.PRICE_INTERVAL IN ('P','O');

	IF LOGS.IS_DEBUG_ENABLED THEN
		v_ELASPSED := DBMS_UTILITY.GET_TIME - v_ELASPSED;
		LOGS.LOG_DEBUG('SEED_POSITION_ANALYSIS_SPOT END AT ' || UT.TRACE_DATE(SYSDATE));
		LOGS.LOG_DEBUG('ELAPSED TIME=' || TO_CHAR(v_ELASPSED));
	END IF;


END SEED_POSITION_ANALYSIS_SPOTMKT;
---------------------------------------------------------------------------------------------------
PROCEDURE UPDATE_POS_ANALYSIS_MKTPRC_AVG
	(
	p_MODEL_ID IN NUMBER,
	p_EVALUATION_ID IN NUMBER,
	p_MARKET_PRICE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS

--Adapted from SEED_POSITION_ANALYSIS_SPOT at 2.2 to include p_MODEL_ID

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_ENTRY_DATE DATE := SYSDATE;

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

-- Clear the existing monthly records to allow inserts.
	DELETE POSITION_ANALYSIS_SPOT_MARKET
	WHERE EVALUATION_ID = p_EVALUATION_ID
		AND MARKET_PRICE_ID = p_MARKET_PRICE_ID
		AND PRICE_INTERVAL IN ('P','O')
		--Monthly dates are TRUNC'd to midnite - Not CUT dates
		AND PRICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE + 1);

	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

-- Calculate the On-Peak and Off-Peak monthly price averages for the CUT_DATE_RANGE.
-- Call PUT_POSITION_ANALYSIS_SPOT_AVG with a CUT_DATE_RANGE!
	PUT_POSITION_ANALYSIS_SPOT_AVG(p_MODEL_ID, p_EVALUATION_ID, p_MARKET_PRICE_ID, v_BEGIN_DATE, v_END_DATE, v_ENTRY_DATE);

END UPDATE_POS_ANALYSIS_MKTPRC_AVG;
---------------------------------------------------------------------------------------------------
PROCEDURE UPDATE_POS_ANALYSIS_SPOT_AVG
	(
	p_EVALUATION_ID IN NUMBER,
	p_MARKET_PRICE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS

--Deprecated at 2.2 - replaced by UPDATE_POS_ANALYSIS_MKTPRC_AVG to include p_MODEL_ID

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_ENTRY_DATE DATE := SYSDATE;

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

-- Clear the existing monthly records to allow inserts.
	DELETE POSITION_ANALYSIS_SPOT_MARKET
	WHERE EVALUATION_ID = p_EVALUATION_ID
		AND MARKET_PRICE_ID = p_MARKET_PRICE_ID
		AND PRICE_INTERVAL IN ('P','O')
		--Monthly dates are TRUNC'd to midnite - Not CUT dates
		AND PRICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE + 1);

	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

-- Calculate the On-Peak and Off-Peak monthly price averages for the CUT_DATE_RANGE.
-- Call PUT_POSITION_ANALYSIS_SPOT_AVG with a CUT_DATE_RANGE!
	PUT_POSITION_ANALYSIS_SPOT_AVG(GA.DEFAULT_MODEL, p_EVALUATION_ID, p_MARKET_PRICE_ID, v_BEGIN_DATE, v_END_DATE, v_ENTRY_DATE);

END UPDATE_POS_ANALYSIS_SPOT_AVG;
---------------------------------------------------------------------------------------------------
PROCEDURE UPDATE_POS_ANALYSIS_WEA_AVG
	(
	p_EVALUATION_ID IN NUMBER,
	p_STATION_ID IN NUMBER,
	p_PARAMETER_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_ENTRY_DATE DATE := SYSDATE;
v_WEATHER_PARAMETER_INTERVAL WEATHER_PARAMETER.PARAMETER_INTERVAL%TYPE;

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

-- Clear the existing monthly records to allow inserts.
	DELETE POSITION_ANALYSIS_WEATHER
	WHERE EVALUATION_ID = p_EVALUATION_ID
		AND STATION_ID = p_STATION_ID
		AND PARAMETER_ID = p_PARAMETER_ID
		AND PARAMETER_INTERVAL = 'M'
		--Monthly dates are TRUNC'd to midnite
		AND PARAMETER_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE + 1);

	SELECT PARAMETER_INTERVAL
	INTO v_WEATHER_PARAMETER_INTERVAL
	FROM WEATHER_PARAMETER
	WHERE PARAMETER_ID=p_PARAMETER_ID;

	IF UPPER(v_WEATHER_PARAMETER_INTERVAL) = 'DAY' THEN
		--Monthly and Daily Dates are TRUNCed (at midnite)
		v_BEGIN_DATE := TRUNC(p_BEGIN_DATE);
		v_END_DATE := TRUNC(p_END_DATE);
		-- Insert monthly weather station parameter averages from daily readings.
		INSERT INTO POSITION_ANALYSIS_WEATHER(EVALUATION_ID, STATION_ID, PARAMETER_ID, PARAMETER_INTERVAL, PARAMETER_DATE, ENTRY_DATE, PARAMETER_VAL)
		SELECT p_EVALUATION_ID, STATION_ID, PARAMETER_ID, 'M', TRUNC(PARAMETER_DATE,'MONTH'), v_ENTRY_DATE, AVG(PARAMETER_VAL)
		FROM POSITION_ANALYSIS_WEATHER
		WHERE EVALUATION_ID = p_EVALUATION_ID
			AND STATION_ID = p_STATION_ID
			AND PARAMETER_ID = p_PARAMETER_ID
			AND PARAMETER_INTERVAL = 'H'
			AND PARAMETER_DATE  BETWEEN v_BEGIN_DATE AND v_END_DATE
		GROUP BY p_EVALUATION_ID, STATION_ID, PARAMETER_ID, 'M', TRUNC(PARAMETER_DATE,'MONTH'), v_ENTRY_DATE;
    ELSE
		-- Hourly data needs to be retrieved by CUT_DATE_RANGE,
		-- but backed up 1 second to put midnite into previous day before TRUNC to month.
	    UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
		-- Insert monthly weather station parameter averages from hourly readings.
		INSERT INTO POSITION_ANALYSIS_WEATHER(EVALUATION_ID, STATION_ID, PARAMETER_ID, PARAMETER_INTERVAL, PARAMETER_DATE, ENTRY_DATE, PARAMETER_VAL)
		SELECT p_EVALUATION_ID, STATION_ID, PARAMETER_ID, 'M', TRUNC(PARAMETER_DATE - g_SECOND,'MONTH'), v_ENTRY_DATE, AVG(PARAMETER_VAL)
		FROM POSITION_ANALYSIS_WEATHER
		WHERE EVALUATION_ID = p_EVALUATION_ID
			AND STATION_ID = p_STATION_ID
			AND PARAMETER_ID = p_PARAMETER_ID
			AND PARAMETER_INTERVAL = 'H'
			AND PARAMETER_DATE  BETWEEN v_BEGIN_DATE AND v_END_DATE
		GROUP BY p_EVALUATION_ID, STATION_ID, PARAMETER_ID, 'M', TRUNC(PARAMETER_DATE - g_SECOND,'MONTH'), v_ENTRY_DATE;
	END IF;

END UPDATE_POS_ANALYSIS_WEA_AVG;
---------------------------------------------------------------------------------------------------
PROCEDURE SEED_POSITION_ANALYSIS_WEATHER
	(
	p_EVALUATION_ID IN NUMBER,
	p_STATION_ID IN NUMBER,
	p_SOURCE_YEAR IN DATE,
	p_TARGET_YEAR IN DATE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

v_SOURCE_BEGIN_DATE DATE;
v_SOURCE_END_DATE DATE;
v_TARGET_BEGIN_DATE DATE;
v_TARGET_END_DATE DATE;
v_YEAR CHAR(4) := TO_CHAR(p_TARGET_YEAR,'YYYY');
v_ENTRY_DATE DATE := SYSDATE;
v_TIME_ZONE CHAR(3) := LOCAL_TIME_ZONE;

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK.';

	UT.CUT_DATE_RANGE(TRUNC(p_SOURCE_YEAR, 'YEAR'), ADD_MONTHS(TRUNC(p_SOURCE_YEAR, 'YEAR'),12) - 1, v_TIME_ZONE, v_SOURCE_BEGIN_DATE, v_SOURCE_END_DATE);
	UT.CUT_DATE_RANGE(TRUNC(p_TARGET_YEAR, 'YEAR'), ADD_MONTHS(TRUNC(p_TARGET_YEAR, 'YEAR'),12) - 1, v_TIME_ZONE, v_TARGET_BEGIN_DATE, v_TARGET_END_DATE);

-- Delete hourly weather data so we can do inserts.
	DELETE POSITION_ANALYSIS_WEATHER
	WHERE EVALUATION_ID = p_EVALUATION_ID
		AND STATION_ID = p_STATION_ID
		AND PARAMETER_ID = PARAMETER_ID
		AND ((PARAMETER_INTERVAL = 'H' AND PARAMETER_DATE BETWEEN v_TARGET_BEGIN_DATE AND v_TARGET_END_DATE)
		OR (PARAMETER_INTERVAL = 'M' AND PARAMETER_DATE BETWEEN TRUNC(v_TARGET_BEGIN_DATE) AND TRUNC(v_TARGET_END_DATE)));

-- Insert monthly weather station parameter minimum, maximum, and average readings.
	INSERT INTO POSITION_ANALYSIS_WEATHER(EVALUATION_ID, STATION_ID, PARAMETER_ID, PARAMETER_INTERVAL, PARAMETER_DATE, ENTRY_DATE, PARAMETER_VAL)
	SELECT p_EVALUATION_ID, B.STATION_ID, B.PARAMETER_ID, 'M', TO_DATE('1-' || TO_CHAR(FROM_CUT(B.PARAMETER_DATE,v_TIME_ZONE),'MON-') || v_YEAR,'DD-MON-YYYY'), v_ENTRY_DATE, AVG(PARAMETER_VAL)
	FROM WEATHER_STATION_PARAMETER A, STATION_PARAMETER_VALUE B
	WHERE A.STATION_ID = p_STATION_ID
		AND B.CASE_ID = GA.BASE_CASE_ID    --Base_Case Only
		AND B.STATION_ID = A.STATION_ID
		AND B.PARAMETER_ID = A.PARAMETER_ID
		AND B.PARAMETER_CODE = 'A'
		AND B.PARAMETER_DATE BETWEEN v_SOURCE_BEGIN_DATE AND v_SOURCE_END_DATE
	GROUP BY p_EVALUATION_ID, B.STATION_ID, B.PARAMETER_ID, 'M', TO_DATE('1-' || TO_CHAR(FROM_CUT(B.PARAMETER_DATE,v_TIME_ZONE),'MON-') || v_YEAR,'DD-MON-YYYY'), v_ENTRY_DATE;

-- Insert daily weather station parameter minimum, maximum, and average readings (for daily parameters).
	INSERT INTO POSITION_ANALYSIS_WEATHER(EVALUATION_ID, STATION_ID, PARAMETER_ID, PARAMETER_INTERVAL, PARAMETER_DATE, ENTRY_DATE, PARAMETER_VAL)
	SELECT p_EVALUATION_ID, B.STATION_ID, B.PARAMETER_ID, 'H', TO_DATE('1-' || TO_CHAR(FROM_CUT(B.PARAMETER_DATE,v_TIME_ZONE),'MON-') || v_YEAR,'DD-MON-YYYY'), v_ENTRY_DATE, AVG(PARAMETER_VAL)
	FROM WEATHER_STATION_PARAMETER A, STATION_PARAMETER_VALUE B, WEATHER_PARAMETER P
	WHERE A.STATION_ID = p_STATION_ID
		AND B.CASE_ID = GA.BASE_CASE_ID    --Base_Case Only
		AND B.STATION_ID = A.STATION_ID
		AND B.PARAMETER_ID = A.PARAMETER_ID
		AND B.PARAMETER_CODE = 'A'
		AND P.PARAMETER_ID = A.PARAMETER_ID
		AND UPPER(P.PARAMETER_INTERVAL) = 'DAY'
		AND B.PARAMETER_DATE BETWEEN v_SOURCE_BEGIN_DATE AND v_SOURCE_END_DATE
	GROUP BY p_EVALUATION_ID, B.STATION_ID, B.PARAMETER_ID, 'H', TO_DATE('1-' || TO_CHAR(FROM_CUT(B.PARAMETER_DATE,v_TIME_ZONE),'MON-') || v_YEAR,'DD-MON-YYYY'), v_ENTRY_DATE;

-- Insert hourly weather station parameter minimum, maximum, and average readings.
	INSERT INTO POSITION_ANALYSIS_WEATHER(EVALUATION_ID, STATION_ID, PARAMETER_ID, PARAMETER_INTERVAL, PARAMETER_DATE, ENTRY_DATE, PARAMETER_VAL)
	SELECT p_EVALUATION_ID, B.STATION_ID, B.PARAMETER_ID, 'H', TO_DATE('1-' || TO_CHAR(FROM_CUT(B.PARAMETER_DATE,v_TIME_ZONE),'MON-HH24-') || v_YEAR,'DD-MON-HH24-YYYY') + DECODE(TO_CHAR(FROM_CUT(B.PARAMETER_DATE,v_TIME_ZONE),'HH24'),0,1,0), v_ENTRY_DATE, AVG(PARAMETER_VAL)
	FROM WEATHER_STATION_PARAMETER A, STATION_PARAMETER_VALUE B, WEATHER_PARAMETER P
	WHERE A.STATION_ID = p_STATION_ID
		AND B.CASE_ID = GA.BASE_CASE_ID    --Base_Case Only
		AND B.STATION_ID = A.STATION_ID
		AND B.PARAMETER_ID = A.PARAMETER_ID
		AND B.PARAMETER_CODE = 'A'
		AND P.PARAMETER_ID = A.PARAMETER_ID
		AND UPPER(P.PARAMETER_INTERVAL) = 'HOUR'
		AND B.PARAMETER_DATE BETWEEN v_SOURCE_BEGIN_DATE AND v_SOURCE_END_DATE
	GROUP BY p_EVALUATION_ID, B.STATION_ID, B.PARAMETER_ID, 'H', TO_DATE('1-' || TO_CHAR(FROM_CUT(B.PARAMETER_DATE,v_TIME_ZONE),'MON-HH24-') || v_YEAR,'DD-MON-HH24-YYYY') + DECODE(TO_CHAR(FROM_CUT(B.PARAMETER_DATE,v_TIME_ZONE),'HH24'),0,1,0), v_ENTRY_DATE;

END SEED_POSITION_ANALYSIS_WEATHER;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_STATION_PARAMETERS
	(
	p_EVALUATION_ID IN NUMBER,
	p_STATION_ID IN NUMBER,
	p_PRIMARY_PARAMETER_ID IN NUMBER,
	p_SECONDARY_PARAMETER_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATION_PARAMETER IN OUT NOCOPY STATION_PARAMETER_TABLE
	) AS

BEGIN

	SELECT STATION_PARAMETER_TYPE(STATION_ID, PARAMETER_ID, PARAMETER_DATE, PARAMETER_VAL)
	BULK COLLECT INTO p_STATION_PARAMETER
	FROM POSITION_ANALYSIS_WEATHER
	WHERE EVALUATION_ID = p_EVALUATION_ID
		AND STATION_ID = p_STATION_ID
		AND (PARAMETER_ID = p_PRIMARY_PARAMETER_ID OR PARAMETER_ID = p_SECONDARY_PARAMETER_ID)
		AND PARAMETER_INTERVAL = 'H'
		AND PARAMETER_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
	ORDER BY PARAMETER_DATE, PARAMETER_ID;

END GET_STATION_PARAMETERS;
---------------------------------------------------------------------------------------------------
PROCEDURE BUILD_CANDIDATE_TREE
	(
	p_EVALUATION_ID IN NUMBER,
	p_MODEL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS

v_DATE DATE := TRUNC(SYSDATE);
v_CASE_ID NUMBER;

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

    --Must include CASE_ID in all queries where it is part of Primary Key to avoid very slow queries against large tables
    v_CASE_ID := GA.BASE_CASE_ID;    --Base_Case Only for now

	DELETE POSITION_ANALYSIS_CANDIDATE WHERE EVALUATION_ID = p_EVALUATION_ID;

	INSERT INTO POSITION_ANALYSIS_CANDIDATE(EVALUATION_ID, ACCOUNT_ID, SERVICE_LOCATION_ID, METER_ID, AGGREGATE_ID, EDC_ID, PSE_ID, ESP_ID, POOL_ID, CALENDAR_ID, PRODUCT_ID, LOSS_FACTOR_ID, USAGE_FACTOR, ENROLLMENT)
	SELECT p_EVALUATION_ID, A.ACCOUNT_ID, D.SERVICE_LOCATION_ID, CONSTANTS.NOT_ASSIGNED, CONSTANTS.NOT_ASSIGNED, B.EDC_ID, NVL(I.PSE_ID,CONSTANTS.NOT_ASSIGNED), C.ESP_ID, C.POOL_ID,
	NVL(E.CALENDAR_ID, CONSTANTS.NOT_ASSIGNED), NVL(F.PRODUCT_ID, CONSTANTS.NOT_ASSIGNED), NVL(G.LOSS_FACTOR_ID, CONSTANTS.NOT_ASSIGNED), NVL(H.FACTOR_VAL, 0.0), 1
	FROM ACCOUNT A,
		ACCOUNT_EDC B,
		ACCOUNT_ESP C,
		ACCOUNT_SERVICE_LOCATION D,
		ACCOUNT_CALENDAR E,
		ACCOUNT_PRODUCT F,
		ACCOUNT_LOSS_FACTOR G,
		ACCOUNT_USAGE_FACTOR H,
		PSE_ESP I,
		ACCOUNT_STATUS S,
		ACCOUNT_STATUS_NAME STATUS_NAME
	WHERE
		S.ACCOUNT_ID=A.ACCOUNT_ID
		AND STATUS_NAME.STATUS_NAME = S.STATUS_NAME
		AND STATUS_NAME.IS_ACTIVE = 1
		AND S.BEGIN_DATE <= v_DATE
		AND (S.END_DATE IS NULL OR v_DATE <= S.END_DATE)
		AND A.MODEL_ID = p_MODEL_ID
		AND UPPER(SUBSTR(A.ACCOUNT_MODEL_OPTION,1,2)) = 'AC'
		AND B.ACCOUNT_ID = A.ACCOUNT_ID
		AND p_BEGIN_DATE BETWEEN B.BEGIN_DATE AND NVL(B.END_DATE, p_END_DATE)
		AND C.ACCOUNT_ID = A.ACCOUNT_ID
		AND p_BEGIN_DATE BETWEEN C.BEGIN_DATE AND NVL(C.END_DATE, p_END_DATE)
		AND D.ACCOUNT_ID = A.ACCOUNT_ID
		AND p_BEGIN_DATE BETWEEN D.BEGIN_DATE AND NVL(D.END_DATE, p_END_DATE)
		AND E.CASE_ID(+) = v_CASE_ID             --Use CASE_ID
		AND E.ACCOUNT_ID(+) = A.ACCOUNT_ID
		AND E.CALENDAR_TYPE(+) = 'Forecast'
		AND p_BEGIN_DATE BETWEEN E.BEGIN_DATE(+) AND NVL(E.END_DATE(+), p_END_DATE)
		AND F.CASE_ID(+) = v_CASE_ID             --Use CASE_ID
		AND F.ACCOUNT_ID(+) = A.ACCOUNT_ID
		AND F.PRODUCT_TYPE(+) = 'R'  --Revenue
		AND p_BEGIN_DATE BETWEEN F.BEGIN_DATE(+) AND NVL(F.END_DATE(+), p_END_DATE)
		AND G.CASE_ID(+) = v_CASE_ID             --Use CASE_ID
		AND G.ACCOUNT_ID(+) = A.ACCOUNT_ID
		AND p_BEGIN_DATE BETWEEN G.BEGIN_DATE(+) AND NVL(G.END_DATE(+), p_END_DATE)
		AND H.CASE_ID(+) = v_CASE_ID             --Use CASE_ID
		AND H.ACCOUNT_ID(+) = A.ACCOUNT_ID
		AND p_BEGIN_DATE BETWEEN H.BEGIN_DATE(+) AND NVL(H.END_DATE(+), p_END_DATE)
		AND I.ESP_ID(+) = C.ESP_ID
		AND p_BEGIN_DATE BETWEEN I.BEGIN_DATE(+) AND NVL(I.END_DATE(+), p_END_DATE);

	INSERT INTO POSITION_ANALYSIS_CANDIDATE(EVALUATION_ID, ACCOUNT_ID, SERVICE_LOCATION_ID, METER_ID, AGGREGATE_ID, EDC_ID, PSE_ID, ESP_ID, POOL_ID, CALENDAR_ID, PRODUCT_ID, LOSS_FACTOR_ID, USAGE_FACTOR, ENROLLMENT)
	SELECT p_EVALUATION_ID, A.ACCOUNT_ID, D.SERVICE_LOCATION_ID, CONSTANTS.NOT_ASSIGNED, C.AGGREGATE_ID, B.EDC_ID, NVL(H.PSE_ID,CONSTANTS.NOT_ASSIGNED), C.ESP_ID, C.POOL_ID,
	NVL(E.CALENDAR_ID, CONSTANTS.NOT_ASSIGNED), NVL(F.PRODUCT_ID, CONSTANTS.NOT_ASSIGNED), NVL(G.LOSS_FACTOR_ID, CONSTANTS.NOT_ASSIGNED), NVL(I.USAGE_FACTOR, 0.0), I.SERVICE_ACCOUNTS
	FROM ACCOUNT A,
		ACCOUNT_EDC B,
		AGGREGATE_ACCOUNT_ESP C,
		ACCOUNT_SERVICE_LOCATION D,
		ACCOUNT_CALENDAR E,
		ACCOUNT_PRODUCT F,
		ACCOUNT_LOSS_FACTOR G,
		PSE_ESP H,
		AGGREGATE_ACCOUNT_SERVICE I,
		ACCOUNT_STATUS S,
		ACCOUNT_STATUS_NAME STATUS_NAME
	WHERE
		S.ACCOUNT_ID=A.ACCOUNT_ID
		AND STATUS_NAME.STATUS_NAME = S.STATUS_NAME
		AND STATUS_NAME.IS_ACTIVE = 1
		AND S.BEGIN_DATE <= v_DATE
		AND (S.END_DATE IS NULL OR v_DATE <= S.END_DATE)
		AND A.MODEL_ID = p_MODEL_ID
		AND UPPER(SUBSTR(A.ACCOUNT_MODEL_OPTION,1,2)) = 'AG'
		AND B.ACCOUNT_ID = A.ACCOUNT_ID
		AND p_BEGIN_DATE BETWEEN B.BEGIN_DATE AND NVL(B.END_DATE, p_END_DATE)
		AND C.ACCOUNT_ID = A.ACCOUNT_ID
		AND p_BEGIN_DATE BETWEEN C.BEGIN_DATE AND NVL(C.END_DATE, p_END_DATE)
		AND D.ACCOUNT_ID = A.ACCOUNT_ID
		AND p_BEGIN_DATE BETWEEN D.BEGIN_DATE AND NVL(D.END_DATE, p_END_DATE)
		AND E.CASE_ID(+) = v_CASE_ID             --Use CASE_ID
		AND E.ACCOUNT_ID(+) = A.ACCOUNT_ID
		AND E.CALENDAR_TYPE(+) = 'Forecast'
		AND p_BEGIN_DATE BETWEEN E.BEGIN_DATE(+) AND NVL(E.END_DATE(+), p_END_DATE)
		AND F.CASE_ID(+) = v_CASE_ID             --Use CASE_ID
		AND F.ACCOUNT_ID(+) = A.ACCOUNT_ID
		AND F.PRODUCT_TYPE(+) = 'R'  --Revenue
		AND p_BEGIN_DATE BETWEEN F.BEGIN_DATE(+) AND NVL(F.END_DATE(+), p_END_DATE)
		AND G.CASE_ID(+) = v_CASE_ID             --Use CASE_ID
		AND G.ACCOUNT_ID(+) = A.ACCOUNT_ID
		AND p_BEGIN_DATE BETWEEN G.BEGIN_DATE(+) AND NVL(G.END_DATE(+), p_END_DATE)
		AND H.ESP_ID(+) = C.ESP_ID
		AND p_BEGIN_DATE BETWEEN H.BEGIN_DATE(+) AND NVL(H.END_DATE(+), p_END_DATE)
		AND I.CASE_ID = v_CASE_ID             --Use CASE_ID
		AND I.AGGREGATE_ID = C.AGGREGATE_ID
		AND I.SERVICE_DATE =
			(SELECT MIN(SERVICE_DATE)
			FROM AGGREGATE_ACCOUNT_SERVICE
			WHERE AGGREGATE_ID = C.AGGREGATE_ID   --Use smaller, non-temporal table (C) for speed
		        AND CASE_ID = v_CASE_ID                --Query is 100 times faster with CASE_ID specified in subquery and outer query!!!!
				AND SERVICE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE)
		AND I.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM AGGREGATE_ACCOUNT_SERVICE
			WHERE AGGREGATE_ID = C.AGGREGATE_ID    --Use smaller, non-temporal table (C) for speed
		        AND CASE_ID = v_CASE_ID                 --Query is 100 times faster with CASE_ID specified in subquery and outer query!!!!
				AND SERVICE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
				AND AS_OF_DATE <= SYSDATE);

	INSERT INTO POSITION_ANALYSIS_CANDIDATE(EVALUATION_ID, ACCOUNT_ID, SERVICE_LOCATION_ID, METER_ID, AGGREGATE_ID, EDC_ID, PSE_ID, ESP_ID, POOL_ID, CALENDAR_ID, PRODUCT_ID, LOSS_FACTOR_ID, USAGE_FACTOR, ENROLLMENT)
	SELECT p_EVALUATION_ID, A.ACCOUNT_ID, D.SERVICE_LOCATION_ID, E.METER_ID, CONSTANTS.NOT_ASSIGNED, B.EDC_ID, NVL(J.PSE_ID,CONSTANTS.NOT_ASSIGNED), C.ESP_ID, C.POOL_ID,
	NVL(F.CALENDAR_ID, CONSTANTS.NOT_ASSIGNED), NVL(G.PRODUCT_ID, CONSTANTS.NOT_ASSIGNED), NVL(H.LOSS_FACTOR_ID, CONSTANTS.NOT_ASSIGNED), NVL(I.FACTOR_VAL, 0.0), 1
	FROM ACCOUNT A,
		ACCOUNT_EDC B,
		ACCOUNT_ESP C,
		ACCOUNT_SERVICE_LOCATION D,
		SERVICE_LOCATION_METER E,
		METER_CALENDAR F,
		METER_PRODUCT G,
		METER_LOSS_FACTOR H,
		METER_USAGE_FACTOR I,
		PSE_ESP J,
		ACCOUNT_STATUS S,
		ACCOUNT_STATUS_NAME STATUS_NAME
	WHERE
		S.ACCOUNT_ID=A.ACCOUNT_ID
		AND STATUS_NAME.STATUS_NAME = S.STATUS_NAME
		AND STATUS_NAME.IS_ACTIVE = 1
		AND S.BEGIN_DATE <= v_DATE
		AND (S.END_DATE IS NULL OR v_DATE <= S.END_DATE)
		AND A.MODEL_ID = p_MODEL_ID
		AND UPPER(SUBSTR(A.ACCOUNT_MODEL_OPTION,1,2)) = 'ME'
		AND B.ACCOUNT_ID = A.ACCOUNT_ID
		AND p_BEGIN_DATE BETWEEN B.BEGIN_DATE AND NVL(B.END_DATE, p_END_DATE)
		AND C.ACCOUNT_ID = A.ACCOUNT_ID
		AND p_BEGIN_DATE BETWEEN C.BEGIN_DATE AND NVL(C.END_DATE, p_END_DATE)
		AND D.ACCOUNT_ID = A.ACCOUNT_ID
		AND p_BEGIN_DATE BETWEEN D.BEGIN_DATE AND NVL(D.END_DATE, p_END_DATE)
		AND E.SERVICE_LOCATION_ID = D.SERVICE_LOCATION_ID
		AND p_BEGIN_DATE BETWEEN E.BEGIN_DATE AND NVL(E.END_DATE, p_END_DATE)
		AND F.CASE_ID(+) = v_CASE_ID             --Use CASE_ID
		AND F.METER_ID(+) = E.METER_ID
		AND F.CALENDAR_TYPE(+) = 'Forecast'
		AND p_BEGIN_DATE BETWEEN F.BEGIN_DATE(+) AND NVL(F.END_DATE(+), p_END_DATE)
		AND G.CASE_ID(+) = v_CASE_ID             --Use CASE_ID
		AND G.METER_ID(+) = E.METER_ID
		AND G.PRODUCT_TYPE(+) = 'R'  --Revenue
		AND p_BEGIN_DATE BETWEEN G.BEGIN_DATE(+) AND NVL(G.END_DATE(+), p_END_DATE)
		AND H.CASE_ID(+) = v_CASE_ID             --Use CASE_ID
		AND H.METER_ID(+) = E.METER_ID
		AND p_BEGIN_DATE BETWEEN H.BEGIN_DATE(+) AND NVL(H.END_DATE(+), p_END_DATE)
		AND I.CASE_ID(+) = v_CASE_ID             --Use CASE_ID
		AND I.METER_ID(+) = E.METER_ID
		AND p_BEGIN_DATE BETWEEN I.BEGIN_DATE(+) AND NVL(I.END_DATE(+), p_END_DATE)
		AND J.ESP_ID(+) = C.ESP_ID
		AND p_BEGIN_DATE BETWEEN J.BEGIN_DATE(+) AND NVL(J.END_DATE(+), p_END_DATE);


END BUILD_CANDIDATE_TREE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_CANDIDATE_TREE_BRANCHES
	(
	p_EVALUATION_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT A.EDC_NAME, A.EDC_ID, B.PSE_NAME, B.PSE_ID, C.ESP_NAME, C.ESP_ID, D.POOL_NAME, D.POOL_ID
		FROM
			(SELECT DISTINCT EDC_ID, PSE_ID, ESP_ID, POOL_ID
			FROM POSITION_ANALYSIS_CANDIDATE
			WHERE EVALUATION_ID = p_EVALUATION_ID) X,
			ENERGY_DISTRIBUTION_COMPANY A,
			PURCHASING_SELLING_ENTITY B,
			ENERGY_SERVICE_PROVIDER C,
			POOL D
		WHERE A.EDC_ID = X.EDC_ID
			AND B.PSE_ID = X.PSE_ID
			AND C.ESP_ID = X.ESP_ID
			AND D.POOL_ID = X.POOL_ID
		ORDER BY 1,3,5,7;


END GET_CANDIDATE_TREE_BRANCHES;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_CANDIDATE_TREE_NODES
	(
	p_EVALUATION_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT A.ACCOUNT_DISPLAY_NAME "ACCOUNT_NAME",
		    A.ACCOUNT_ID,
			B.SERVICE_LOCATION_NAME,
			B.SERVICE_LOCATION_ID,
			B.WEATHER_STATION_ID "STATION_ID",
			W.STATION_NAME "STATION",
			C.METER_NAME,
			C.METER_ID,
			X.AGGREGATE_ID,
			D.CALENDAR_NAME "CALENDAR",
			D.CALENDAR_ID,
			E.PRODUCT_NAME "PRODUCT",
			E.PRODUCT_ID,
			F.LOSS_FACTOR_NAME "LOSS_FACTOR",
			F.LOSS_FACTOR_ID,
			X.USAGE_FACTOR,
			X.ENROLLMENT
		FROM
			(SELECT ACCOUNT_ID, SERVICE_LOCATION_ID, METER_ID, AGGREGATE_ID, CALENDAR_ID, PRODUCT_ID, LOSS_FACTOR_ID, USAGE_FACTOR, ENROLLMENT
			FROM POSITION_ANALYSIS_CANDIDATE
			WHERE EVALUATION_ID = p_EVALUATION_ID
				AND EDC_ID = DECODE(p_EDC_ID,0,EDC_ID,p_EDC_ID) --p_EDC_ID
				AND PSE_ID = DECODE(p_PSE_ID,0,PSE_ID,p_PSE_ID) --p_PSE_ID
				AND ESP_ID = DECODE(p_ESP_ID,0,ESP_ID,p_ESP_ID) --p_ESP_ID
				AND POOL_ID = DECODE(p_POOL_ID,0,POOL_ID,p_POOL_ID) --p_POOL_ID
				) X,
			ACCOUNT A,
			SERVICE_LOCATION B,
			METER C,
			CALENDAR D,
			PRODUCT E,
			LOSS_FACTOR F,
			WEATHER_STATION W
		WHERE A.ACCOUNT_ID = X.ACCOUNT_ID
			AND B.SERVICE_LOCATION_ID = X.SERVICE_LOCATION_ID
			AND C.METER_ID = X.METER_ID
			AND D.CALENDAR_ID(+) = X.CALENDAR_ID
			AND E.PRODUCT_ID(+) = X.PRODUCT_ID
			AND F.LOSS_FACTOR_ID(+) = X.LOSS_FACTOR_ID
			AND W.STATION_ID(+) = B.WEATHER_STATION_ID
		ORDER BY 1,3,5;


END GET_CANDIDATE_TREE_NODES;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_PARTICIPANT_DETERMINANTS
    (
	p_PARTICIPANT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_POSITION_ANALYSIS_LOAD IN OUT NOCOPY POSITION_ANALYSIS_LOAD_TABLE,
	p_DETERMINANTS IN OUT NOCOPY DETERMINANT_TABLE
	) AS

-- Derive the Position Analysis Cost Determinants over the Begin and End date range.

v_INDEX BINARY_INTEGER;
v_MONTH_INDEX BINARY_INTEGER;
v_DAYS NUMBER(2);
v_MONTH_DATE DATE;
v_DAY_DATE DATE;
v_DAY_TYPE DAY_TYPE_TABLE;
v_ENROLLMENT GA.ID_TABLE;
v_ENERGY GA.FLOAT_TABLE;
v_DEMAND GA.FLOAT_TABLE;
v_ENR NUMBER(8);
v_ENG NUMBER(20,4);
v_DMD NUMBER(20,4);
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('GET_PARTICIPANT_DETERMINANTS, BEGIN_DATE=' || UT.TRACE_DATE(p_BEGIN_DATE) || ', END_DATE=' || UT.TRACE_DATE(p_END_DATE) || ', POSITION_ANALYSIS_LOAD.COUNT=' || TO_CHAR(p_POSITION_ANALYSIS_LOAD.COUNT));
	END IF;

-- Determine the count of Weekday and Weekend days in each month.
	v_MONTH_DATE := p_BEGIN_DATE;
	WHILE v_MONTH_DATE <= p_END_DATE LOOP
		v_MONTH_INDEX := TO_NUMBER(TO_CHAR(v_MONTH_DATE,'J'));
		FOR v_DAY IN 1..TO_NUMBER(TO_CHAR(LAST_DAY(v_MONTH_DATE),'DD')) LOOP
			v_DAY_DATE := TO_DATE(TO_CHAR(v_DAY) || TO_CHAR(v_MONTH_DATE,'-MON-YYYY'),'DD-MON-YYYY');
			IF NOT v_DAY_TYPE.EXISTS(v_MONTH_INDEX) THEN
				v_DAY_TYPE(v_MONTH_INDEX).WD_DAYS := 0;
				v_DAY_TYPE(v_MONTH_INDEX).WE_DAYS := 0;
			END IF;
			IF TO_CHAR(v_DAY_DATE,'DY') IN ('SAT','SUN') THEN
				v_DAY_TYPE(v_MONTH_INDEX).WE_DAYS := v_DAY_TYPE(v_MONTH_INDEX).WE_DAYS + 1;
			ELSE
				v_DAY_TYPE(v_MONTH_INDEX).WD_DAYS := v_DAY_TYPE(v_MONTH_INDEX).WD_DAYS + 1;
			END IF;
		END LOOP;
-- Initialize the Energy and Demand monthly accumulators.
		v_ENERGY(v_MONTH_INDEX) := 0;
		v_DEMAND(v_MONTH_INDEX) := -999999;
		v_MONTH_DATE := ADD_MONTHS(v_MONTH_DATE,1);
	END LOOP;

-- Accumulate the Energy and determine the Peak Demand for each month.
	FOR v_INDEX IN p_POSITION_ANALYSIS_LOAD.FIRST..p_POSITION_ANALYSIS_LOAD.LAST LOOP
		IF p_POSITION_ANALYSIS_LOAD.EXISTS(v_INDEX) AND p_POSITION_ANALYSIS_LOAD(v_INDEX).LOAD_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE THEN
			IF p_POSITION_ANALYSIS_LOAD(v_INDEX).PARTICIPANT_ID = p_PARTICIPANT_ID THEN
				v_MONTH_DATE := TRUNC(p_POSITION_ANALYSIS_LOAD(v_INDEX).LOAD_DATE, 'MONTH');
				v_MONTH_INDEX := TO_NUMBER(TO_CHAR(v_MONTH_DATE,'J'));
				SELECT DECODE(p_POSITION_ANALYSIS_LOAD(v_INDEX).DAY_TYPE,'D', v_DAY_TYPE(v_MONTH_INDEX).WD_DAYS, v_DAY_TYPE(v_MONTH_INDEX).WE_DAYS) INTO v_DAYS FROM DUAL;
				p_POSITION_ANALYSIS_LOAD(v_INDEX).DAYS := v_DAYS;
				v_ENERGY(v_MONTH_INDEX) := v_ENERGY(v_MONTH_INDEX) + p_POSITION_ANALYSIS_LOAD(v_INDEX).LOAD_VAL * v_DAYS;
				IF p_POSITION_ANALYSIS_LOAD(v_INDEX).LOAD_VAL > v_DEMAND(v_MONTH_INDEX) THEN
					v_DEMAND(v_MONTH_INDEX) := p_POSITION_ANALYSIS_LOAD(v_INDEX).LOAD_VAL;
				END IF;
				IF NOT v_ENROLLMENT.EXISTS(v_MONTH_INDEX) THEN
					v_ENROLLMENT(v_MONTH_INDEX) := p_POSITION_ANALYSIS_LOAD(v_INDEX).ENROLLMENT;
				END IF;
			END IF;
		END IF;
	END LOOP;

-- Save the hourly day type patterns as a single Determinant for the month.
	v_MONTH_DATE := p_BEGIN_DATE;
	p_DETERMINANTS.DELETE;
	WHILE v_MONTH_DATE <= p_END_DATE LOOP
		v_MONTH_INDEX := TO_NUMBER(TO_CHAR(v_MONTH_DATE,'J'));
		p_DETERMINANTS.EXTEND;
		IF v_ENERGY.EXISTS(v_MONTH_INDEX) THEN v_ENG := v_ENERGY(v_MONTH_INDEX); ELSE v_ENG := 0; END IF;
		IF v_DEMAND.EXISTS(v_MONTH_INDEX) THEN v_DMD := v_DEMAND(v_MONTH_INDEX); ELSE v_DMD := 0; END IF;
		IF v_ENROLLMENT.EXISTS(v_MONTH_INDEX) THEN v_ENR := v_ENROLLMENT(v_MONTH_INDEX); ELSE v_ENR := 1; END IF;
		p_DETERMINANTS(p_DETERMINANTS.LAST) := DETERMINANT_TYPE(CONSTANTS.NOT_ASSIGNED, v_MONTH_DATE, v_MONTH_DATE, v_MONTH_DATE, v_ENG, v_DMD, v_ENR, 'B', CONSTANTS.NOT_ASSIGNED, CONSTANTS.NOT_ASSIGNED, CONSTANTS.NOT_ASSIGNED);
		v_MONTH_DATE := ADD_MONTHS(v_MONTH_DATE,1);
	END LOOP;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('GET_PARTICIPANT_DETERMINANTS TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED) || ', COUNT=' || TO_CHAR(p_DETERMINANTS.COUNT));
	END IF;

END GET_PARTICIPANT_DETERMINANTS;
-----------------------------------------------------------------------------------------------
PROCEDURE PUT_SUPPLY_BLOCK_SEGMENTS
    (
	p_MODEL_ID IN NUMBER,
	p_EVALUATION_ID IN NUMBER,
	p_SEGMENT_NAME IN VARCHAR,
	p_SEGMENTS IN SEGMENT_TABLE
	) AS

v_DAY_TYPE_CODE CHAR(1);
v_MONTH_DATE DATE;
v_DAY_TYPE BINARY_INTEGER;
v_MONTH BINARY_INTEGER;
v_HOUR BINARY_INTEGER;
v_INDEX BINARY_INTEGER;
v_DAY NUMBER(1);

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PUT_SUPPLY_BLOCK_SEGMENTS FOR ' || p_SEGMENT_NAME);
		LOGS.LOG_DEBUG('SEGMENTS.COUNT=' || TO_CHAR(p_SEGMENTS.COUNT));
		IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
			LOGS.LOG_DEBUG_DETAIL('<index>,<day type>,<month>,<quantity>,<cost>,<order>,<count>');
		END IF;
	END IF;

	IF p_SEGMENTS.COUNT > 0 THEN
		v_INDEX := p_SEGMENTS.FIRST;
		WHILE v_INDEX <= p_SEGMENTS.LAST LOOP
			v_DAY_TYPE := v_INDEX / 100000000;
			v_MONTH := (v_INDEX - (v_DAY_TYPE * 100000000)) / 100;
			v_HOUR := MOD(v_INDEX,100);
			v_DAY := 0;
			IF v_HOUR = 24 THEN
				v_HOUR := 0;
				v_DAY := 1;
			END IF;
			v_MONTH_DATE := TO_DATE('01' || TO_CHAR(v_MONTH) || TO_CHAR(v_HOUR),'DDYYYYMMHH24') + v_DAY;
			IF p_MODEL_ID = GA.GAS_MODEL THEN v_MONTH_DATE := TRUNC(v_MONTH_DATE); END IF;
			SELECT DECODE(v_DAY_TYPE,1,'D','E') INTO v_DAY_TYPE_CODE FROM DUAL;

			IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
				LOGS.LOG_DEBUG_DETAIL(TO_CHAR(v_INDEX) || ',' || v_DAY_TYPE_CODE || ',' || TO_CHAR(v_MONTH_DATE) || ',' || TO_CHAR(p_SEGMENTS(v_INDEX).SEGMENT_QUANTITY) || ',' || TO_CHAR(p_SEGMENTS(v_INDEX).SEGMENT_COST) || ',' || TO_CHAR(p_SEGMENTS(v_INDEX).SEGMENT_ORDER) || ',' || TO_CHAR(p_SEGMENTS(v_INDEX).SEGMENT_COUNT));
			END IF;

			INSERT INTO POSITION_ANALYSIS_SEGMENT (EVALUATION_ID, SEGMENT_NAME, SEGMENT_TYPE, SEGMENT_DAY_TYPE, SEGMENT_DATE, SEGMENT_QUANTITY, SEGMENT_COST, SEGMENT_ORDER)
			VALUES (p_EVALUATION_ID, p_SEGMENT_NAME ||' (' || p_SEGMENTS(v_INDEX).SEGMENT_ORDER || ')', 'B', v_DAY_TYPE_CODE, v_MONTH_DATE,
				p_SEGMENTS(v_INDEX).SEGMENT_QUANTITY / p_SEGMENTS(v_INDEX).SEGMENT_COUNT,
				p_SEGMENTS(v_INDEX).SEGMENT_COST / p_SEGMENTS(v_INDEX).SEGMENT_COUNT,
				p_SEGMENTS(v_INDEX).SEGMENT_ORDER);

			v_INDEX := p_SEGMENTS.NEXT(v_INDEX);

		END LOOP;
	END IF;

END PUT_SUPPLY_BLOCK_SEGMENTS;
---------------------------------------------------------------------------------------------------
PROCEDURE SET_SUPPLY_BLOCK_SEGMENTS
    (
	p_MODEL_ID IN NUMBER,
	p_EVALUATION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	) AS

v_HOURS NUMBER(2);
v_SERVICE_DATE DATE;
v_SEGMENTS SEGMENT_TABLE;
v_CONDITION GA.BOOLEAN_TABLE;
v_INDEX BINARY_INTEGER;
v_HOUR BINARY_INTEGER;
v_DAY BINARY_INTEGER;
v_DMH BINARY_INTEGER;
v_DAYS_OF_WEEK VARCHAR2(7);

CURSOR c_BLOCK IS
	SELECT A.TEMPLATE_NAME, A.BLOCK_ORDER, A.BLOCK_QUANTITY, A.BLOCK_PRICE, A.BEGIN_DATE, A.END_DATE, B.START_HOUR_END, B.STOP_HOUR_END, B.INTERIOR_PERIOD, B.DAY_OF_WEEK
	FROM POSITION_ANALYSIS_SUPPLY_BLOCK A, SCHEDULE_TEMPLATE B
	WHERE A.EVALUATION_ID = p_EVALUATION_ID
		AND B.TEMPLATE_NAME(+) = A.TEMPLATE_NAME
	ORDER BY A.BLOCK_ORDER;

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('SET_SUPPLY_BLOCK_SEGMENTS');
		LOGS.LOG_DEBUG('EVALUATION_ID=' || TO_CHAR(p_EVALUATION_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TO_CHAR(p_END_DATE));
		LOGS.LOG_DEBUG('<template>,<order>,<quantity>,<price>,<begin date>,<end date>,<start hour end>,<stop hour end>,<interior period>,<dow>');
	END IF;

	DELETE POSITION_ANALYSIS_SEGMENT
	WHERE EVALUATION_ID = p_EVALUATION_ID
		AND SEGMENT_NAME = SEGMENT_NAME
		AND SEGMENT_TYPE = 'B';

	--!!Should fix for sub-hourly intervals
    IF p_MODEL_ID = GA.ELECTRIC_MODEL THEN v_HOURS := 24; ELSE v_HOURS := 1; END IF;

-- Loop over the supply blocks.
	FOR v_BLOCK IN c_BLOCK LOOP
		v_SERVICE_DATE := GREATEST(p_BEGIN_DATE, v_BLOCK.BEGIN_DATE);

		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG(v_BLOCK.TEMPLATE_NAME || ',' || TO_CHAR(v_BLOCK.BLOCK_ORDER) || ',' || TO_CHAR(v_BLOCK.BLOCK_QUANTITY) || ',' || TO_CHAR(v_BLOCK.BLOCK_PRICE) || ',' || TO_CHAR(v_BLOCK.BEGIN_DATE) || ',' || TO_CHAR(v_BLOCK.END_DATE) || ',' || TO_CHAR(v_BLOCK.START_HOUR_END) || ',' || TO_CHAR(v_BLOCK.STOP_HOUR_END) || ',' || TO_CHAR(v_BLOCK.INTERIOR_PERIOD) || ',' || v_BLOCK.DAY_OF_WEEK);
		END IF;

-- Set the Day of Week indicator.
		v_DAYS_OF_WEEK := v_BLOCK.DAY_OF_WEEK;
        IF v_BLOCK.DAY_OF_WEEK IS NULL THEN
        	IF LOGS.IS_DEBUG_ENABLED THEN
        		LOGS.LOG_DEBUG('No matching SCHEDULE_TEMPLATE for TEMPLATE_NAME=' || v_BLOCK.TEMPLATE_NAME);
        	END IF;
        END IF;

        FOR v_INDEX IN 1..7 LOOP
			v_CONDITION(v_INDEX) := SUBSTR(v_DAYS_OF_WEEK,v_INDEX,1) = 1;
		END LOOP;

-- Loop over the days of the period and apply the schedule to the appropriate hours.
		WHILE v_SERVICE_DATE <= LEAST(p_END_DATE, v_BLOCK.END_DATE) LOOP
			SELECT DECODE(TO_CHAR(v_SERVICE_DATE,'DY'),'MON',1,'TUE',2,'WED',3,'THU',4,'FRI',5,'SAT',6,'SUN',7) INTO v_INDEX FROM DUAL;
			IF v_CONDITION(v_INDEX) THEN
				SELECT DECODE(v_INDEX,6,2,7,2,1) INTO v_DAY FROM DUAL;
				FOR v_HOUR IN 1..v_HOURS LOOP
					IF (v_BLOCK.INTERIOR_PERIOD = 1 AND v_HOUR BETWEEN v_BLOCK.START_HOUR_END AND v_BLOCK.STOP_HOUR_END)
						OR (v_BLOCK.INTERIOR_PERIOD = 0 AND v_HOUR NOT BETWEEN v_BLOCK.START_HOUR_END AND v_BLOCK.STOP_HOUR_END) THEN
						v_DMH := v_DAY * 100000000 + TO_NUMBER(TO_CHAR(TRUNC(v_SERVICE_DATE,'MONTH'),'YYYYMM')) * 100 + v_HOUR;
						IF v_SEGMENTS.EXISTS(v_DMH) THEN
							v_SEGMENTS(v_DMH).SEGMENT_COUNT := v_SEGMENTS(v_DMH).SEGMENT_COUNT + 1;
							v_SEGMENTS(v_DMH).SEGMENT_QUANTITY := v_SEGMENTS(v_DMH).SEGMENT_QUANTITY + v_BLOCK.BLOCK_QUANTITY;
							v_SEGMENTS(v_DMH).SEGMENT_COST := v_SEGMENTS(v_DMH).SEGMENT_COST + (v_BLOCK.BLOCK_QUANTITY * v_BLOCK.BLOCK_PRICE);
						ELSE
							v_SEGMENTS(v_DMH).SEGMENT_COUNT := 1;
							v_SEGMENTS(v_DMH).SEGMENT_ORDER := v_BLOCK.BLOCK_ORDER;
							v_SEGMENTS(v_DMH).SEGMENT_QUANTITY := v_BLOCK.BLOCK_QUANTITY;
							v_SEGMENTS(v_DMH).SEGMENT_COST := v_BLOCK.BLOCK_QUANTITY * v_BLOCK.BLOCK_PRICE;
						END IF;
					END IF;
				END LOOP;
			END IF;
			v_SERVICE_DATE := v_SERVICE_DATE + 1;
		END LOOP;
		PUT_SUPPLY_BLOCK_SEGMENTS(p_MODEL_ID, p_EVALUATION_ID, v_BLOCK.TEMPLATE_NAME, v_SEGMENTS);
		v_SEGMENTS.DELETE;
	END LOOP;

END SET_SUPPLY_BLOCK_SEGMENTS;
---------------------------------------------------------------------------------------------------
PROCEDURE SET_LOAD_SEGMENTS
    (
	p_MODEL_ID IN NUMBER,
	p_EVALUATION_ID IN NUMBER
	) AS

v_SUMMARY_DIVISOR NUMBER := 1000;        --KW to MW
v_ADJUST_TIME  g_SECOND%TYPE := g_SECOND;     --Get midnite to proper day

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('SET_LOAD_SEGMENTS');
	END IF;

	IF p_MODEL_ID = GA.GAS_MODEL THEN
		v_SUMMARY_DIVISOR := 10;     --Therms to Decatherms
        v_ADJUST_TIME:= 0;           --No Adjustment for daily
	END IF;

	DELETE POSITION_ANALYSIS_SEGMENT
	WHERE EVALUATION_ID = p_EVALUATION_ID
		AND SEGMENT_NAME = 'LOAD'
		AND SEGMENT_TYPE = 'L';

	INSERT INTO POSITION_ANALYSIS_SEGMENT(EVALUATION_ID, SEGMENT_NAME, SEGMENT_TYPE, SEGMENT_DAY_TYPE, SEGMENT_DATE, SEGMENT_ORDER, SEGMENT_QUANTITY)
	SELECT A.EVALUATION_ID, 'LOAD', 'L', A.DAY_TYPE, A.LOAD_DATE, 0, SUM(A.LOAD_VAL * B.ENROLLMENT / v_SUMMARY_DIVISOR)
	FROM POSITION_ANALYSIS_LOAD A,
		POSITION_ANALYSIS_ENROLLMENT B
	WHERE A.EVALUATION_ID = p_EVALUATION_ID
		AND B.EVALUATION_ID = A.EVALUATION_ID
		AND B.PARTICIPANT_ID = A.PARTICIPANT_ID
		AND B.ENROLLMENT_MONTH = TRUNC(A.LOAD_DATE - v_ADJUST_TIME, 'MONTH')
	GROUP BY A.EVALUATION_ID, 'LOAD', 'L', A.DAY_TYPE, A.LOAD_DATE, 0;

END SET_LOAD_SEGMENTS;
---------------------------------------------------------------------------------------------------
PROCEDURE SET_SPOT_MARKET_SEGMENTS
    (
	p_MODEL_ID IN NUMBER,
	p_EVALUATION_ID IN NUMBER,
	p_MARKET_PRICE_ID IN NUMBER
	) AS

v_ENTRY_DATE DATE := SYSDATE;
v_ADJUST_TIME  g_SECOND%TYPE := g_SECOND;     --Get midnite to proper day for Electric Model

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('SET_SPOT_MARKET_SEGMENTS');
		LOGS.LOG_DEBUG('EVALUATION_ID=' || TO_CHAR(p_EVALUATION_ID));
		LOGS.LOG_DEBUG('MARKET_PRICE_ID=' || TO_CHAR(p_MARKET_PRICE_ID));
	END IF;

	IF p_MODEL_ID = GA.GAS_MODEL THEN
        v_ADJUST_TIME:= 0;           --No Adjustment for daily
	END IF;

	DELETE POSITION_ANALYSIS_SEGMENT
	WHERE EVALUATION_ID = p_EVALUATION_ID
		AND SEGMENT_NAME = 'SPOT'
		AND SEGMENT_TYPE = 'S';

	INSERT INTO POSITION_ANALYSIS_SEGMENT(EVALUATION_ID, SEGMENT_NAME, SEGMENT_TYPE, SEGMENT_DAY_TYPE, SEGMENT_DATE, SEGMENT_ORDER, SEGMENT_QUANTITY)
	SELECT p_EVALUATION_ID, 'SPOT', 'S', SEGMENT_DAY_TYPE, SEGMENT_DATE, 0, SUM(SEGMENT_QUANTITY * DECODE(SEGMENT_TYPE,'L',1,-1))
	FROM POSITION_ANALYSIS_SEGMENT
	WHERE EVALUATION_ID = p_EVALUATION_ID
	GROUP BY p_EVALUATION_ID, 'SPOT', 'S', SEGMENT_DAY_TYPE, SEGMENT_DATE, 0;

	DELETE POSITION_ANALYSIS_SPOT_MARKET
	WHERE EVALUATION_ID = p_EVALUATION_ID
		AND MARKET_PRICE_ID = p_MARKET_PRICE_ID
		AND PRICE_INTERVAL IN ('D','E');

	IF p_MODEL_ID = GA.ELECTRIC_MODEL THEN
		INSERT INTO POSITION_ANALYSIS_SPOT_MARKET(EVALUATION_ID, MARKET_PRICE_ID, PRICE_INTERVAL, PRICE_DATE, ENTRY_DATE, PRICE_VAL)
			SELECT p_EVALUATION_ID,
				p_MARKET_PRICE_ID,
				DECODE(TO_CHAR(FROM_CUT(PRICE_DATE, LOCAL_TIME_ZONE) - g_SECOND,'DY'),'SAT','E','SUN','E','D') "DAY_TYPE",
				TO_DATE('01' || TO_CHAR(FROM_CUT(PRICE_DATE, LOCAL_TIME_ZONE),'MMYYYYHH24'),'DDMMYYYYHH24') + DECODE(TO_CHAR(FROM_CUT(PRICE_DATE, LOCAL_TIME_ZONE),'HH24'),0,1,0) "PRICE_DATE",
				v_ENTRY_DATE,
				AVG(A.PRICE_VAL) "PRICE_VAL"
			FROM POSITION_ANALYSIS_SPOT_MARKET A
			WHERE A.EVALUATION_ID = p_EVALUATION_ID
				AND A.MARKET_PRICE_ID = p_MARKET_PRICE_ID
				AND A.PRICE_INTERVAL = 'H'
			GROUP BY TO_DATE('01' || TO_CHAR(FROM_CUT(PRICE_DATE, LOCAL_TIME_ZONE),'MMYYYYHH24'),'DDMMYYYYHH24') + DECODE(TO_CHAR(FROM_CUT(PRICE_DATE, LOCAL_TIME_ZONE),'HH24'),0,1,0),
				DECODE(TO_CHAR(FROM_CUT(PRICE_DATE, LOCAL_TIME_ZONE) - g_SECOND,'DY'),'SAT','E','SUN','E','D');
	ELSE    --Gas Model
		INSERT INTO POSITION_ANALYSIS_SPOT_MARKET(EVALUATION_ID, MARKET_PRICE_ID, PRICE_INTERVAL, PRICE_DATE, ENTRY_DATE, PRICE_VAL)
			SELECT p_EVALUATION_ID, p_MARKET_PRICE_ID, DECODE(TO_CHAR(PRICE_DATE,'DY'),'SAT','E','SUN','E','D') "DAY_TYPE", TRUNC(PRICE_DATE,'MONTH') "PRICE_DATE", v_ENTRY_DATE, AVG(A.PRICE_VAL) "PRICE_VAL"
			FROM POSITION_ANALYSIS_SPOT_MARKET A
			WHERE A.EVALUATION_ID = p_EVALUATION_ID
				AND A.MARKET_PRICE_ID = p_MARKET_PRICE_ID
				AND A.PRICE_INTERVAL = 'H'
			GROUP BY DECODE(TO_CHAR(PRICE_DATE,'DY'),'SAT','E','SUN','E','D'), TRUNC(PRICE_DATE,'MONTH');
	END IF;

 	UPDATE POSITION_ANALYSIS_SEGMENT X
 	SET X.SEGMENT_COST =
 		(SELECT X.SEGMENT_QUANTITY * AVG(A.PRICE_VAL)
 		FROM POSITION_ANALYSIS_SPOT_MARKET A
 		WHERE A.EVALUATION_ID = X.EVALUATION_ID
 			AND A.MARKET_PRICE_ID = p_MARKET_PRICE_ID
 			AND A.PRICE_INTERVAL = X.SEGMENT_DAY_TYPE
 			AND A.PRICE_DATE = X.SEGMENT_DATE)
 	WHERE X.EVALUATION_ID = p_EVALUATION_ID
 		AND X.SEGMENT_NAME = 'SPOT'
 		AND X.SEGMENT_TYPE = 'S';

END SET_SPOT_MARKET_SEGMENTS;
---------------------------------------------------------------------------------------------------
PROCEDURE SET_GAS_TXN_SEGMENTS
    (
	p_EVALUATION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN CHAR
	) AS

BEGIN

	INSERT INTO POSITION_ANALYSIS_SEGMENT(EVALUATION_ID, SEGMENT_NAME, SEGMENT_TYPE, SEGMENT_DAY_TYPE, SEGMENT_DATE, SEGMENT_ORDER, SEGMENT_QUANTITY, SEGMENT_COST)
	SELECT A.EVALUATION_ID, SUBSTR(B.TRANSACTION_NAME,1,32), 'T', DECODE(TO_CHAR(C.SCHEDULE_DATE,'DY'),'SAT','E','SUN','E','D'), TRUNC(C.SCHEDULE_DATE, 'MONTH'), 0,
		SUM(C.AMOUNT) / COUNT(*), SUM(C.AMOUNT * NVL(C.PRICE,0)) / COUNT(*)
	FROM POSITION_ANALYSIS_TRANSACTION A, INTERCHANGE_TRANSACTION B, IT_SCHEDULE C
	WHERE A.EVALUATION_ID = p_EVALUATION_ID
		AND B.TRANSACTION_ID = A.TRANSACTION_ID
		AND C.TRANSACTION_ID = A.TRANSACTION_ID
		AND C.SCHEDULE_TYPE = 1
		AND C.SCHEDULE_STATE = 1
		AND C.SCHEDULE_DATE BETWEEN p_BEGIN_DATE AND (p_END_DATE+1/86400)
		AND C.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_SCHEDULE
			WHERE TRANSACTION_ID = C.TRANSACTION_ID
				AND SCHEDULE_TYPE = C.SCHEDULE_TYPE
				AND SCHEDULE_STATE = C.SCHEDULE_STATE
				AND SCHEDULE_DATE = C.SCHEDULE_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE)
	GROUP BY A.EVALUATION_ID, SUBSTR(B.TRANSACTION_NAME,1,32), 'T', DECODE(TO_CHAR(C.SCHEDULE_DATE,'DY'),'SAT','E','SUN','E','D'), TRUNC(C.SCHEDULE_DATE, 'MONTH'), 0;

END SET_GAS_TXN_SEGMENTS;
---------------------------------------------------------------------------------------------------
PROCEDURE SET_ELECTRIC_TXN_SEGMENTS
    (
	p_EVALUATION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN CHAR
	) AS

BEGIN

	INSERT INTO POSITION_ANALYSIS_SEGMENT(EVALUATION_ID, SEGMENT_NAME, SEGMENT_TYPE, SEGMENT_DAY_TYPE, SEGMENT_DATE, SEGMENT_ORDER, SEGMENT_QUANTITY, SEGMENT_COST)
	SELECT A.EVALUATION_ID,
		SUBSTR(B.TRANSACTION_NAME,1,32),
		'T',
		DECODE(TO_CHAR(FROM_CUT(C.SCHEDULE_DATE, p_TIME_ZONE) - g_SECOND,'DY'),'SAT','E','SUN','E','D'),
		TO_DATE('01' || TO_CHAR(FROM_CUT(C.SCHEDULE_DATE, p_TIME_ZONE),'MMYYYYHH24'),'DDMMYYYYHH24') + DECODE(TO_CHAR(FROM_CUT(C.SCHEDULE_DATE, p_TIME_ZONE),'HH24'),0,1,0),
		0,
		SUM(C.AMOUNT) / COUNT(*),
		SUM(C.AMOUNT * NVL(C.PRICE,0)) / COUNT(*)
	FROM POSITION_ANALYSIS_TRANSACTION A, INTERCHANGE_TRANSACTION B, IT_SCHEDULE C
	WHERE A.EVALUATION_ID = p_EVALUATION_ID
		AND B.TRANSACTION_ID = A.TRANSACTION_ID
		AND C.TRANSACTION_ID = A.TRANSACTION_ID
		AND C.SCHEDULE_TYPE = 1
		AND C.SCHEDULE_STATE = 1
		AND C.SCHEDULE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
		AND C.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM IT_SCHEDULE
			WHERE TRANSACTION_ID = C.TRANSACTION_ID
				AND SCHEDULE_TYPE = C.SCHEDULE_TYPE
				AND SCHEDULE_STATE = C.SCHEDULE_STATE
				AND SCHEDULE_DATE = C.SCHEDULE_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE)
	GROUP BY A.EVALUATION_ID,
		SUBSTR(B.TRANSACTION_NAME,1,32),
		'T',
		DECODE(TO_CHAR(FROM_CUT(C.SCHEDULE_DATE, p_TIME_ZONE) - g_SECOND,'DY'),'SAT','E','SUN','E','D'),
		TO_DATE('01' || TO_CHAR(FROM_CUT(C.SCHEDULE_DATE, p_TIME_ZONE),'MMYYYYHH24'),'DDMMYYYYHH24') + DECODE(TO_CHAR(FROM_CUT(C.SCHEDULE_DATE, p_TIME_ZONE),'HH24'),0,1,0),
		0;

END SET_ELECTRIC_TXN_SEGMENTS;
---------------------------------------------------------------------------------------------------
PROCEDURE SET_TRANSACTION_SEGMENTS
    (
	p_MODEL_ID IN NUMBER,
	p_EVALUATION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_TIME_ZONE CHAR(3) := LOCAL_TIME_ZONE;

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('SET_TRANSACTION_SEGMENTS');
		LOGS.LOG_DEBUG('EVALUATION_ID=' || TO_CHAR(p_EVALUATION_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TO_CHAR(p_END_DATE));
		LOGS.LOG_DEBUG('AS_OF_DATE=' || UT.TRACE_DATE(p_AS_OF_DATE));
	END IF;

	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, v_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	DELETE POSITION_ANALYSIS_SEGMENT
	WHERE EVALUATION_ID = p_EVALUATION_ID
		AND SEGMENT_NAME = SEGMENT_NAME
		AND SEGMENT_TYPE = 'T';

	IF p_MODEL_ID = GA.ELECTRIC_MODEL THEN
		SET_ELECTRIC_TXN_SEGMENTS(p_EVALUATION_ID, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, v_TIME_ZONE);
	ELSE
		SET_GAS_TXN_SEGMENTS(p_EVALUATION_ID, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, v_TIME_ZONE);
	END IF;

END SET_TRANSACTION_SEGMENTS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_POSITION_ANALYSIS_REVENUE
	(
	p_MODEL_ID IN NUMBER,
	p_EVALUATION_ID IN NUMBER,
	p_PARTICIPANT_ID IN NUMBER,
	p_DETERMINANTS IN DETERMINANT_TABLE,
	p_PRODUCT IN CHARGE_COMPONENT_TABLE
	) AS

CURSOR c_DATA IS
	SELECT TRUNC(A.DAY_DATE(),'MONTH') "MONTH",
		SUM(A.DETERMINANT_1) "ENERGY",
		MAX(A.DETERMINANT_2) "DEMAND",
		AVG(A.ENROLLMENT) "ENROLLMENT"
	FROM TABLE(CAST(p_DETERMINANTS AS DETERMINANT_TABLE)) A
	GROUP BY TRUNC(A.DAY_DATE(),'MONTH');

v_AMOUNT NUMBER;
v_SUMMARY_DIVISOR NUMBER := 1000;        --KW to MW

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PUT_POSITION_ANALYSIS_REVENUE');
	END IF;

	IF p_MODEL_ID = GA.GAS_MODEL THEN
		v_SUMMARY_DIVISOR := 10;     --Therms to Decatherms
	END IF;

	FOR v_DATA IN c_DATA LOOP
		SELECT SUM(A.AMOUNT) INTO v_AMOUNT FROM TABLE(CAST(p_PRODUCT AS CHARGE_COMPONENT_TABLE)) A WHERE TRUNC(A.BEGIN_DATE,'MONTH') = v_DATA.MONTH;
		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG(TO_CHAR(v_DATA.MONTH) || ',' || TO_CHAR(v_DATA.ENERGY / v_SUMMARY_DIVISOR) || ',' || TO_CHAR(v_DATA.DEMAND / v_SUMMARY_DIVISOR) || ',' || TO_CHAR(v_DATA.ENROLLMENT) || ',' || TO_CHAR( v_AMOUNT));
		END IF;
		INSERT INTO POSITION_ANALYSIS_REVENUE VALUES(p_EVALUATION_ID, p_PARTICIPANT_ID, v_DATA.MONTH, v_DATA.ENERGY * v_DATA.ENROLLMENT / v_SUMMARY_DIVISOR, v_DATA.DEMAND * v_DATA.ENROLLMENT / v_SUMMARY_DIVISOR, v_AMOUNT * v_DATA.ENROLLMENT);
	END LOOP;

END PUT_POSITION_ANALYSIS_REVENUE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_POSITION_ANALYSIS_LOAD
	(
	p_EVALUATION_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT A.LOAD_DATE, A.DAY_TYPE, SUM(A.LOAD_VAL * NVL(B.ENROLLMENT,1)) "LOAD_VAL"
		FROM POSITION_ANALYSIS_LOAD A, POSITION_ANALYSIS_ENROLLMENT B
		WHERE A.EVALUATION_ID = p_EVALUATION_ID
		GROUP BY A.LOAD_DATE, A.DAY_TYPE
		ORDER BY 1,2;


END GET_POSITION_ANALYSIS_LOAD;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_POSITION_ANALYSIS_LOAD
	(
	p_EVALUATION_ID IN NUMBER,
	p_POSITION_ANALYSIS_LOAD IN POSITION_ANALYSIS_LOAD_TABLE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	) AS

v_ENTRY_DATE DATE := SYSDATE;

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PUT_POSITION_ANALYSIS_LOAD');
	END IF;

	INSERT INTO POSITION_ANALYSIS_LOAD(EVALUATION_ID, PARTICIPANT_ID, DAY_TYPE, LOAD_DATE, LOAD_VAL, ENTRY_DATE)
	SELECT p_EVALUATION_ID, A.PARTICIPANT_ID, A.DAY_TYPE, A.LOAD_DATE, A.LOAD_VAL * A.LOSS_FACTOR_VAL, v_ENTRY_DATE
	FROM TABLE(CAST(p_POSITION_ANALYSIS_LOAD AS POSITION_ANALYSIS_LOAD_TABLE)) A
	WHERE A.LOAD_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE + 1;

END PUT_POSITION_ANALYSIS_LOAD;
---------------------------------------------------------------------------------------------------
PROCEDURE ADJUST_PARTICIPANT_LOAD
	(
	p_PARTICIPANT IN POSITION_ANALYSIS_PARTICIPANT%ROWTYPE,
	p_PRORATION IN OUT NOCOPY DETERMINANT_TABLE,
	p_POSITION_ANALYSIS_LOAD IN OUT NOCOPY POSITION_ANALYSIS_LOAD_TABLE
	) AS

v_INDEX BINARY_INTEGER;
v_IDX BINARY_INTEGER;
v_LOAD_VAL GA.NUMBER_TABLE;
v_MONTH_INDEX BINARY_INTEGER;
v_FACTOR NUMBER;
v_AMOUNT NUMBER;

CURSOR c_ADJUST IS
	SELECT TRUNC(A.LOAD_DATE,'MONTH') "LOAD_DATE", SUM(A.LOAD_VAL * A.DAYS) "LOAD_VAL"
	FROM TABLE(CAST(p_POSITION_ANALYSIS_LOAD AS POSITION_ANALYSIS_LOAD_TABLE)) A
	WHERE A.PARTICIPANT_ID = p_PARTICIPANT.PARTICIPANT_ID
	GROUP BY TRUNC(A.LOAD_DATE,'MONTH');

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('ADJUST_PARTICIPANT_LOAD');
	END IF;

	FOR v_ADJUST IN c_ADJUST LOOP
		v_MONTH_INDEX := TO_NUMBER(TO_CHAR(v_ADJUST.LOAD_DATE,'J'));
		v_LOAD_VAL(v_MONTH_INDEX) := v_ADJUST.LOAD_VAL;
	END LOOP;

	FOR v_INDEX IN p_PRORATION.FIRST..p_PRORATION.LAST LOOP
		v_MONTH_INDEX := TO_NUMBER(TO_CHAR(TRUNC(p_PRORATION(v_INDEX).DAY_DATE,'MONTH'),'J'));
		v_FACTOR := ROUND(p_PRORATION(v_INDEX).ENERGY / v_LOAD_VAL(v_MONTH_INDEX),6);
		IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
			LOGS.LOG_DEBUG_DETAIL(TO_CHAR(p_PRORATION(v_INDEX).PERIOD_ID) || ',' || UT.TRACE_DATE(p_PRORATION(v_INDEX).DAY_DATE) || ',' || TO_CHAR(p_PRORATION(v_INDEX).ENERGY) || ',' || TO_CHAR(p_PRORATION(v_INDEX).ENROLLMENT) || ',' || TO_CHAR(v_FACTOR));
		END IF;
		v_AMOUNT := 0;
		FOR v_IDX IN p_POSITION_ANALYSIS_LOAD.FIRST..p_POSITION_ANALYSIS_LOAD.LAST LOOP
			IF p_POSITION_ANALYSIS_LOAD(v_IDX).PARTICIPANT_ID = p_PARTICIPANT.PARTICIPANT_ID THEN
				IF TO_NUMBER(TO_CHAR(TRUNC(p_POSITION_ANALYSIS_LOAD(v_IDX).LOAD_DATE, 'MONTH'),'J')) = v_MONTH_INDEX THEN
					p_POSITION_ANALYSIS_LOAD(v_IDX).LOAD_VAL := p_POSITION_ANALYSIS_LOAD(v_IDX).LOAD_VAL * v_FACTOR;
					v_AMOUNT := v_AMOUNT + p_POSITION_ANALYSIS_LOAD(v_IDX).LOAD_VAL * p_POSITION_ANALYSIS_LOAD(v_IDX).DAYS;
				END IF;
			END IF;
		END LOOP;
		IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
			LOGS.LOG_DEBUG_DETAIL(TO_CHAR(p_PRORATION(v_INDEX).ENERGY) || ',' || TO_CHAR(v_LOAD_VAL(v_MONTH_INDEX)) || ',' || TO_CHAR(v_FACTOR) || ',' || TO_CHAR(v_AMOUNT));
		END IF;
	END LOOP;

END ADJUST_PARTICIPANT_LOAD;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_PARTICIPANT_WRF_LOAD
	(
	p_MODEL_ID IN NUMBER,
	p_EVALUATION_ID IN NUMBER,
	p_PARTICIPANT_ID IN NUMBER,
	p_PROFILE_ID IN NUMBER,
	p_STATION_PARAMETER IN STATION_PARAMETER_TABLE,
	p_PRIMARY_PARAMETER_ID IN NUMBER,
	p_SECONDARY_PARAMETER_ID IN NUMBER,
	p_MONTH_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_USAGE_FACTOR IN NUMBER,
	p_LOSS_FACTOR IN NUMBER,
	p_POSITION_ANALYSIS_LOAD IN OUT NOCOPY POSITION_ANALYSIS_LOAD_TABLE
	) AS

v_WRF_VAR_1 GA.NUMBER_TABLE;
v_WRF_VAR_2 GA.NUMBER_TABLE;
v_WRF_PROFILE GA.NUMBER_TABLE;
v_LOAD_DATE DATE;
v_INDEX BINARY_INTEGER;
v_TRACE_ON NUMBER(1) := 0;
v_STATUS NUMBER;
v_MESSAGE VARCHAR(128);
v_ADJUST_HOUR NUMBER := 0;

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('GET_PARTICIPANT_WRF_LOAD@2');
		LOGS.LOG_DEBUG('PRIMARY_PARAMETER_ID=' || TO_CHAR(p_PRIMARY_PARAMETER_ID));
		LOGS.LOG_DEBUG('SECONDARY_PARAMETER_ID=' || TO_CHAR(p_SECONDARY_PARAMETER_ID));
		LOGS.LOG_DEBUG('MONTH_DATE=' || TO_CHAR(p_MONTH_DATE));
		v_TRACE_ON := 1;
	END IF;

	IF p_MODEL_ID = GA.ELECTRIC_MODEL THEN
		v_ADJUST_HOUR := 1;     --Add Hour to date
	END IF;

-- Get the weather station parameter data associated with the WRF for the month.
	IF p_STATION_PARAMETER.COUNT > 0 THEN
		FOR v_INDEX IN p_STATION_PARAMETER.FIRST..p_STATION_PARAMETER.LAST LOOP
			IF p_STATION_PARAMETER.EXISTS(v_INDEX) THEN
				IF TRUNC(p_STATION_PARAMETER(v_INDEX).PARAMETER_DATE,'MONTH') = p_MONTH_DATE THEN
					IF p_STATION_PARAMETER(v_INDEX).PARAMETER_ID = p_PRIMARY_PARAMETER_ID THEN
						v_WRF_VAR_1(v_WRF_VAR_1.COUNT+1) := p_STATION_PARAMETER(v_INDEX).PARAMETER_VAL;
					ELSIF p_STATION_PARAMETER(v_INDEX).PARAMETER_ID = p_SECONDARY_PARAMETER_ID THEN
						v_WRF_VAR_2(v_WRF_VAR_2.COUNT+1) := p_STATION_PARAMETER(v_INDEX).PARAMETER_VAL;
					END IF;
				END IF;
			END IF;
		END LOOP;
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		TRACE_TABLE('WRF_VAR_1', v_WRF_VAR_1);
		IF p_SECONDARY_PARAMETER_ID > CONSTANTS.NOT_ASSIGNED THEN
			TRACE_TABLE('WRF_VAR_2', v_WRF_VAR_2);
		END IF;
	END IF;

-- Accumulate the WRF Profile Load for a Weekday in the Month.
	FS.WRF_PROFILE_PROJECTION(p_PROFILE_ID, NEXT_DAY(p_MONTH_DATE, 'MONDAY'), p_AS_OF_DATE, v_TRACE_ON, v_WRF_VAR_1, v_WRF_VAR_2, v_WRF_PROFILE, v_STATUS, v_MESSAGE);
	v_LOAD_DATE := ADD_HOURS_TO_DATE(p_MONTH_DATE,v_ADJUST_HOUR);
	IF v_WRF_PROFILE.COUNT > 0 THEN
		FOR v_INDEX IN v_WRF_PROFILE.FIRST..v_WRF_PROFILE.LAST LOOP
			IF v_WRF_PROFILE.EXISTS(v_INDEX) THEN
				p_POSITION_ANALYSIS_LOAD.EXTEND;
				p_POSITION_ANALYSIS_LOAD(p_POSITION_ANALYSIS_LOAD.LAST) := POSITION_ANALYSIS_LOAD_TYPE(p_PARTICIPANT_ID, 'D', v_LOAD_DATE, v_WRF_PROFILE(v_INDEX) * p_USAGE_FACTOR, p_LOSS_FACTOR, 0, 0);
				v_LOAD_DATE := ADD_HOURS_TO_DATE(v_LOAD_DATE,v_ADJUST_HOUR);
			END IF;
		END LOOP;
	END IF;

-- Accumulate the WRF Profile Load for a Weekend in the Month.
	FS.WRF_PROFILE_PROJECTION(p_PROFILE_ID, NEXT_DAY(p_MONTH_DATE, 'SATURDAY'), p_AS_OF_DATE, v_TRACE_ON, v_WRF_VAR_1, v_WRF_VAR_2, v_WRF_PROFILE, v_STATUS, v_MESSAGE);
	v_LOAD_DATE := ADD_HOURS_TO_DATE(p_MONTH_DATE,v_ADJUST_HOUR);
	IF v_WRF_PROFILE.COUNT > 0 THEN
		FOR v_INDEX IN v_WRF_PROFILE.FIRST..v_WRF_PROFILE.LAST LOOP
			IF v_WRF_PROFILE.EXISTS(v_INDEX) THEN
				p_POSITION_ANALYSIS_LOAD.EXTEND;
				p_POSITION_ANALYSIS_LOAD(p_POSITION_ANALYSIS_LOAD.LAST) := POSITION_ANALYSIS_LOAD_TYPE(p_PARTICIPANT_ID, 'E', v_LOAD_DATE, v_WRF_PROFILE(v_INDEX) * p_USAGE_FACTOR, p_LOSS_FACTOR, 0, 0);
				v_LOAD_DATE := ADD_HOURS_TO_DATE(v_LOAD_DATE,v_ADJUST_HOUR);
			END IF;
		END LOOP;
	END IF;

END GET_PARTICIPANT_WRF_LOAD;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_PARTICIPANT_WRF_CAL_LOAD
	(
	p_MODEL_ID IN NUMBER,
	p_EVALUATION_ID IN NUMBER,
	p_PARTICIPANT_ID IN NUMBER,
	p_CALENDAR_ID IN NUMBER,
	p_STATION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_USAGE_FACTOR IN NUMBER,
	p_LOSS_FACTOR IN NUMBER,
	p_POSITION_ANALYSIS_LOAD IN OUT NOCOPY POSITION_ANALYSIS_LOAD_TABLE
	) AS

v_MONTH_DATE DATE := TRUNC(p_BEGIN_DATE,'MONTH');
v_STATION_PARAMETER STATION_PARAMETER_TABLE := STATION_PARAMETER_TABLE();
v_PRIMARY_PARAMETER_ID NUMBER(9) := 0;
v_SECONDARY_PARAMETER_ID NUMBER(9) := 0;
v_PROFILE_ID NUMBER(9);

CURSOR c_WRF_PARAMETERS IS
	SELECT VARIABLE_NBR, PARAMETER_ID
	FROM LOAD_PROFILE_WRF_WEATHER
	WHERE PROFILE_ID = v_PROFILE_ID
	ORDER BY VARIABLE_NBR;

BEGIN

-- Get the Profile Id in effect at the beginning of the execution periodi
	v_PROFILE_ID := GET_PROFILE_ID(p_CALENDAR_ID, p_BEGIN_DATE);

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('GET_PARTICIPANT_WRF_CAL_LOAD@1');
		LOGS.LOG_DEBUG('PARTICIPANT_ID=' || TO_CHAR(p_PARTICIPANT_ID));
		LOGS.LOG_DEBUG('CALENDAR_ID=' || TO_CHAR(p_CALENDAR_ID));
		LOGS.LOG_DEBUG('STATION_ID=' || TO_CHAR(p_STATION_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TO_CHAR(p_END_DATE));
		LOGS.LOG_DEBUG('AS_OF_DATE=' || UT.TRACE_DATE(p_AS_OF_DATE));
		LOGS.LOG_DEBUG('USAGE_FACTOR=' || TO_CHAR(p_USAGE_FACTOR));
		LOGS.LOG_DEBUG('LOSS_FACTOR=' || TO_CHAR(p_LOSS_FACTOR));
		LOGS.LOG_DEBUG('PROFILE_ID=' || TO_CHAR(v_PROFILE_ID));
	END IF;

-- Get the WRF Load Profile Weather Parameters.
	FOR v_WRF_PARAMETERS IN c_WRF_PARAMETERS LOOP
		IF v_WRF_PARAMETERS.VARIABLE_NBR = 0 THEN
			v_PRIMARY_PARAMETER_ID := NVL(v_WRF_PARAMETERS.PARAMETER_ID, CONSTANTS.NOT_ASSIGNED);
		ELSIF v_WRF_PARAMETERS.VARIABLE_NBR = 1 THEN
			v_SECONDARY_PARAMETER_ID := NVL(v_WRF_PARAMETERS.PARAMETER_ID, CONSTANTS.NOT_ASSIGNED);
		END IF;
	END LOOP;

-- Get the Weather data associated with the WRF profiles
	GET_STATION_PARAMETERS(p_EVALUATION_ID, p_STATION_ID, v_PRIMARY_PARAMETER_ID, v_SECONDARY_PARAMETER_ID, p_BEGIN_DATE, p_END_DATE, v_STATION_PARAMETER);

-- Accumulate the Load over the Begin and End date range.
	WHILE v_MONTH_DATE <= TRUNC(p_END_DATE,'MONTH') LOOP
		v_PROFILE_ID := GET_PROFILE_ID(p_CALENDAR_ID, v_MONTH_DATE);
		GET_PARTICIPANT_WRF_LOAD(p_MODEL_ID, p_EVALUATION_ID, p_PARTICIPANT_ID, v_PROFILE_ID, v_STATION_PARAMETER, v_PRIMARY_PARAMETER_ID,
			v_SECONDARY_PARAMETER_ID, v_MONTH_DATE, p_AS_OF_DATE, p_USAGE_FACTOR, p_LOSS_FACTOR, p_POSITION_ANALYSIS_LOAD);
		v_MONTH_DATE := ADD_MONTHS(v_MONTH_DATE,1);
	END LOOP;

END GET_PARTICIPANT_WRF_CAL_LOAD;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_PARTICIPANT_PROJECTED_LOAD
	(
	p_EVALUATION_ID IN NUMBER,
	p_PARTICIPANT_ID IN NUMBER,
	p_CALENDAR_ID IN NUMBER,
	p_STATION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_USAGE_FACTOR IN NUMBER,
	p_LOSS_FACTOR IN NUMBER,
	p_POSITION_ANALYSIS_LOAD IN OUT NOCOPY POSITION_ANALYSIS_LOAD_TABLE
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;

CURSOR c_PROJECTION IS
	SELECT DECODE(B.PERIOD_ID,-1,'D','E') "DAY_TYPE", B.PROJECTION_DATE, ENERGY * p_USAGE_FACTOR "PROJECTION_VAL"
	FROM CALENDAR_PROJECTION A, PROJECTION_PATTERN B
	WHERE CALENDAR_ID = p_CALENDAR_ID
		AND PROJECTION_TYPE = 'MONTH'
		AND TEMPLATE_ID = CONSTANTS.NOT_ASSIGNED
		AND AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM CALENDAR_PROJECTION
			WHERE CALENDAR_ID = A.CALENDAR_ID
				AND PROJECTION_TYPE = A.PROJECTION_TYPE
				AND TEMPLATE_ID = A.TEMPLATE_ID
				AND AS_OF_DATE <= p_AS_OF_DATE)
		AND B.PROJECTION_ID = A.PROJECTION_ID
		AND B.PERIOD_ID IN (-1,-2)
		AND B.PROJECTION_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE;

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('GET_PARTICIPANT_PROJECTED_LOAD');
		LOGS.LOG_DEBUG('PARTICIPANT_ID=' || TO_CHAR(p_PARTICIPANT_ID));
		LOGS.LOG_DEBUG('CALENDAR_ID=' || TO_CHAR(p_CALENDAR_ID));
	END IF;

	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	FOR v_PROJECTION IN c_PROJECTION LOOP
		p_POSITION_ANALYSIS_LOAD.EXTEND;
		p_POSITION_ANALYSIS_LOAD(p_POSITION_ANALYSIS_LOAD.LAST) := POSITION_ANALYSIS_LOAD_TYPE(p_PARTICIPANT_ID, v_PROJECTION.DAY_TYPE, v_PROJECTION.PROJECTION_DATE, v_PROJECTION.PROJECTION_VAL, p_LOSS_FACTOR, 0, 0);
	END LOOP;

END GET_PARTICIPANT_PROJECTED_LOAD;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_PARTICIPANT_LOAD
	(
	p_MODEL_ID IN NUMBER,
	p_PARTICIPANT IN POSITION_ANALYSIS_PARTICIPANT%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_POSITION_ANALYSIS_LOAD IN OUT NOCOPY POSITION_ANALYSIS_LOAD_TABLE
	) AS

v_LOSS_FACTOR NUMBER(10,6);
v_USAGE_FACTOR NUMBER(10,6);
v_INDEX BINARY_INTEGER;
v_MONTH_INDEX BINARY_INTEGER;
v_ENROLLMENT GA.NUMBER_TABLE;
v_CALENDAR_NAME CALENDAR.CALENDAR_NAME%TYPE; --@@Implementation Override--
v_ADJUST_TIME  g_SECOND%TYPE := g_SECOND;     --Get midnite to proper day for Electric Model

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('GET_PARTICIPANT_LOAD FOR ' || p_PARTICIPANT.PARTICIPANT_NAME);
		LOGS.LOG_DEBUG('BEGIN_DATE= ' || TO_CHAR(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE= ' || TO_CHAR(p_END_DATE));
		LOGS.LOG_DEBUG('CALENDAR_PROJECTION_TYPE=' || p_PARTICIPANT.CALENDAR_PROJECTION_TYPE);
	END IF;

	IF p_MODEL_ID = GA.GAS_MODEL THEN
        v_ADJUST_TIME:= 0;           --No Adjustment for daily
	END IF;

	p_POSITION_ANALYSIS_LOAD.DELETE;

	v_LOSS_FACTOR := GET_LOSS_FACTOR(p_PARTICIPANT.LOSS_FACTOR_ID, p_BEGIN_DATE);
	IF GA.USAGE_FACTOR_PER_UNIT_OPTION THEN
		v_USAGE_FACTOR := 1.0 + p_PARTICIPANT.USAGE_FACTOR;
	ELSE
		v_USAGE_FACTOR := p_PARTICIPANT.USAGE_FACTOR;
	END IF;

	IF p_PARTICIPANT.CALENDAR_PROJECTION_TYPE = 'P' THEN
		GET_PARTICIPANT_PROJECTED_LOAD(p_PARTICIPANT.EVALUATION_ID, p_PARTICIPANT.PARTICIPANT_ID, p_PARTICIPANT.CALENDAR_ID, p_PARTICIPANT.STATION_ID,
			p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, v_USAGE_FACTOR, v_LOSS_FACTOR, p_POSITION_ANALYSIS_LOAD);
	ELSIF p_PARTICIPANT.CALENDAR_PROJECTION_TYPE = 'W' THEN
		GET_PARTICIPANT_WRF_CAL_LOAD(p_MODEL_ID, p_PARTICIPANT.EVALUATION_ID, p_PARTICIPANT.PARTICIPANT_ID, p_PARTICIPANT.CALENDAR_ID, p_PARTICIPANT.STATION_ID,
			p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, v_USAGE_FACTOR, v_LOSS_FACTOR, p_POSITION_ANALYSIS_LOAD);
	END IF;

	GET_PARTICIPANT_ENROLLMENT(p_PARTICIPANT.EVALUATION_ID, p_PARTICIPANT.PARTICIPANT_ID, v_ENROLLMENT);

	IF p_POSITION_ANALYSIS_LOAD.COUNT > 0 THEN
		FOR v_INDEX IN p_POSITION_ANALYSIS_LOAD.FIRST..p_POSITION_ANALYSIS_LOAD.LAST LOOP
			v_MONTH_INDEX := TO_CHAR(TRUNC(p_POSITION_ANALYSIS_LOAD(v_INDEX).LOAD_DATE - v_ADJUST_TIME, 'MONTH'),'J');
			IF v_ENROLLMENT.EXISTS(v_MONTH_INDEX) THEN
				p_POSITION_ANALYSIS_LOAD(v_INDEX).ENROLLMENT := v_ENROLLMENT(v_MONTH_INDEX);
			ELSE
				p_POSITION_ANALYSIS_LOAD(v_INDEX).ENROLLMENT := 1;
			END IF;
		END LOOP;
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		IF p_POSITION_ANALYSIS_LOAD.COUNT > 0 THEN
			LOGS.LOG_DEBUG('TRACE POSITION_ANALYSIS_LOAD TABLE...');
			FOR v_INDEX IN p_POSITION_ANALYSIS_LOAD.FIRST..p_POSITION_ANALYSIS_LOAD.LAST LOOP
				IF p_POSITION_ANALYSIS_LOAD.EXISTS(v_INDEX) THEN
					LOGS.LOG_DEBUG(p_POSITION_ANALYSIS_LOAD(v_INDEX).DAY_TYPE || ',' || UT.TRACE_DATE(p_POSITION_ANALYSIS_LOAD(v_INDEX).LOAD_DATE) || ',' || TO_CHAR(p_POSITION_ANALYSIS_LOAD(v_INDEX).LOAD_VAL) || ',' || TO_CHAR(p_POSITION_ANALYSIS_LOAD(v_INDEX).ENROLLMENT));
				END IF;
			END LOOP;
		END IF;
	END IF;

	IF p_POSITION_ANALYSIS_LOAD.COUNT = 0 THEN
		v_CALENDAR_NAME := GET_CALENDAR_NAME(p_PARTICIPANT.CALENDAR_ID);
		ERRS.RAISE(MSGCODES.c_ERR_GENERAL,'MISSING CALENDAR PROJECTION LOAD FOR ' || v_CALENDAR_NAME);
	END IF;

END GET_PARTICIPANT_LOAD;
---------------------------------------------------------------------------------------------------
PROCEDURE RUN_POSITION_ANALYSIS_LOAD
    (
	p_EVALUATION_ID IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

--Deprecated at 2.2 - replaced by RUN_POSITION_ANALYSIS_LD_EVAL to include p_MODEL_ID

v_ELASPSED PLS_INTEGER;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_EARLIEST_BEGIN_DATE DATE;
v_LATEST_END_DATE DATE;
v_POSITION_ANALYSIS_EVALUATION POSITION_ANALYSIS_EVALUATION%ROWTYPE;
v_POSITION_ANALYSIS_LOAD POSITION_ANALYSIS_LOAD_TABLE := POSITION_ANALYSIS_LOAD_TABLE();
v_CONSUMPTION CONSUMPTION_TABLE := CONSUMPTION_TABLE();
v_DETERMINANTS DETERMINANT_TABLE := DETERMINANT_TABLE();
v_PRORATION DETERMINANT_TABLE := DETERMINANT_TABLE();
v_PRODUCT CHARGE_COMPONENT_TABLE := CHARGE_COMPONENT_TABLE();

CURSOR c_PARTICIPANT IS
	SELECT *
	FROM POSITION_ANALYSIS_PARTICIPANT
	WHERE EVALUATION_ID = p_EVALUATION_ID;

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK.';
	v_ELASPSED := DBMS_UTILITY.GET_TIME;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('RUN_POSITION_ANALYSIS_LOAD BEGIN AT ' || UT.TRACE_DATE(SYSDATE));
		LOGS.LOG_DEBUG('EVALUATION_ID=' || TO_CHAR(p_EVALUATION_ID));
	END IF;

	SELECT * INTO v_POSITION_ANALYSIS_EVALUATION FROM POSITION_ANALYSIS_EVALUATION WHERE EVALUATION_ID = p_EVALUATION_ID;
	v_BEGIN_DATE := TRUNC(v_POSITION_ANALYSIS_EVALUATION.BEGIN_DATE,'MONTH');
	v_END_DATE := LAST_DAY(v_POSITION_ANALYSIS_EVALUATION.END_DATE);

	DELETE POSITION_ANALYSIS_LOAD
	WHERE EVALUATION_ID = p_EVALUATION_ID
		AND PARTICIPANT_ID = PARTICIPANT_ID
		AND DAY_TYPE IN('D','E')
		AND LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE + 1;

	DELETE POSITION_ANALYSIS_REVENUE WHERE EVALUATION_ID = p_EVALUATION_ID;

	FOR v_PARTICIPANT IN c_PARTICIPANT LOOP
		IF v_PARTICIPANT.PARTICIPANT_TYPE = 'Q' AND v_PARTICIPANT.USE_BILLING_DETERMINANTS = 1 THEN
			GET_BILLING_DETERMINANTS(v_PARTICIPANT.PARTICIPANT_ENTITY_ID, v_BEGIN_DATE, v_END_DATE, v_CONSUMPTION, v_EARLIEST_BEGIN_DATE, v_LATEST_END_DATE);
			IF LOGS.IS_DEBUG_ENABLED THEN
				LOGS.LOG_DEBUG('BEGIN_DATE=' || TO_CHAR(v_BEGIN_DATE) || ', END_DATE=' || TO_CHAR(v_END_DATE));
				LOGS.LOG_DEBUG('EARLIEST_BEGIN_DATE=' || TO_CHAR(v_EARLIEST_BEGIN_DATE) || ', LATEST_END_DATE=' || TO_CHAR(v_LATEST_END_DATE));
			END IF;
			GET_PARTICIPANT_LOAD(GA.DEFAULT_MODEL, v_PARTICIPANT, v_EARLIEST_BEGIN_DATE, v_LATEST_END_DATE, p_AS_OF_DATE, v_POSITION_ANALYSIS_LOAD);
			GET_PARTICIPANT_DETERMINANTS(v_PARTICIPANT.PARTICIPANT_ID, v_BEGIN_DATE, v_END_DATE, v_POSITION_ANALYSIS_LOAD, v_DETERMINANTS);
			CU.GET_PRORATED_CONSUMPTION(v_BEGIN_DATE, v_END_DATE, v_DETERMINANTS, v_CONSUMPTION, LOGS.IS_DEBUG_DETAIL_ENABLED, v_PRORATION);
			ADJUST_PARTICIPANT_LOAD(v_PARTICIPANT, v_PRORATION, v_POSITION_ANALYSIS_LOAD);
		ELSE
			GET_PARTICIPANT_LOAD(GA.DEFAULT_MODEL, v_PARTICIPANT, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, v_POSITION_ANALYSIS_LOAD);
			GET_PARTICIPANT_DETERMINANTS(v_PARTICIPANT.PARTICIPANT_ID, v_BEGIN_DATE, v_END_DATE, v_POSITION_ANALYSIS_LOAD, v_PRORATION);
		END IF;
		CU.APPLY_PRODUCT_COMPONENTS(v_PARTICIPANT.PRODUCT_ID, v_PRORATION, v_BEGIN_DATE, v_END_DATE, LOGS.IS_DEBUG_ENABLED, v_PRODUCT);
		PUT_POSITION_ANALYSIS_LOAD(p_EVALUATION_ID, v_POSITION_ANALYSIS_LOAD, v_BEGIN_DATE, v_END_DATE);
		PUT_POSITION_ANALYSIS_REVENUE(GA.DEFAULT_MODEL, p_EVALUATION_ID, v_PARTICIPANT.PARTICIPANT_ID, v_PRORATION, v_PRODUCT);
		v_CONSUMPTION.DELETE;
		v_DETERMINANTS.DELETE;
	END LOOP;

	SET_LOAD_SEGMENTS(GA.DEFAULT_MODEL, p_EVALUATION_ID);

	SET_TRANSACTION_SEGMENTS(GA.DEFAULT_MODEL, p_EVALUATION_ID, v_POSITION_ANALYSIS_EVALUATION.BEGIN_DATE, v_POSITION_ANALYSIS_EVALUATION.END_DATE, p_AS_OF_DATE);

	SET_SPOT_MARKET_SEGMENTS(GA.DEFAULT_MODEL, p_EVALUATION_ID, v_POSITION_ANALYSIS_EVALUATION.MARKET_PRICE_ID);

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('RUN_POSITION_ANALYSIS_LOAD END AT ' || UT.TRACE_DATE(SYSDATE));
	    LOGS.LOG_DEBUG('ELAPSED TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELASPSED));
	END IF;

END RUN_POSITION_ANALYSIS_LOAD;
---------------------------------------------------------------------------------------------------
PROCEDURE RUN_POSITION_ANALYSIS_LD_EVAL
    (
	p_MODEL_ID IN NUMBER,
	p_EVALUATION_ID IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

--Adapted from RUN_POSITION_ANALYSIS_LOAD at 2.2 to include p_MODEL_ID

v_ELASPSED PLS_INTEGER;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_EARLIEST_BEGIN_DATE DATE;
v_LATEST_END_DATE DATE;
v_POSITION_ANALYSIS_EVALUATION POSITION_ANALYSIS_EVALUATION%ROWTYPE;
v_POSITION_ANALYSIS_LOAD POSITION_ANALYSIS_LOAD_TABLE := POSITION_ANALYSIS_LOAD_TABLE();
v_CONSUMPTION CONSUMPTION_TABLE := CONSUMPTION_TABLE();
v_DETERMINANTS DETERMINANT_TABLE := DETERMINANT_TABLE();
v_PRORATION DETERMINANT_TABLE := DETERMINANT_TABLE();
v_PRODUCT CHARGE_COMPONENT_TABLE := CHARGE_COMPONENT_TABLE();

CURSOR c_PARTICIPANT IS
	SELECT *
	FROM POSITION_ANALYSIS_PARTICIPANT
	WHERE EVALUATION_ID = p_EVALUATION_ID;

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK.';
	v_ELASPSED := DBMS_UTILITY.GET_TIME;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('RUN_POSITION_ANALYSIS_LD_EVAL BEGIN AT ' || UT.TRACE_DATE(SYSDATE));
		LOGS.LOG_DEBUG('EVALUATION_ID=' || TO_CHAR(p_EVALUATION_ID));
	END IF;

	SELECT * INTO v_POSITION_ANALYSIS_EVALUATION FROM POSITION_ANALYSIS_EVALUATION WHERE EVALUATION_ID = p_EVALUATION_ID;
	v_BEGIN_DATE := TRUNC(v_POSITION_ANALYSIS_EVALUATION.BEGIN_DATE,'MONTH');
	v_END_DATE := LAST_DAY(v_POSITION_ANALYSIS_EVALUATION.END_DATE);

	DELETE POSITION_ANALYSIS_LOAD
	WHERE EVALUATION_ID = p_EVALUATION_ID
		AND PARTICIPANT_ID = PARTICIPANT_ID
		AND DAY_TYPE IN('D','E')
		AND LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE + 1;

	DELETE POSITION_ANALYSIS_REVENUE WHERE EVALUATION_ID = p_EVALUATION_ID;

	FOR v_PARTICIPANT IN c_PARTICIPANT LOOP
		IF v_PARTICIPANT.PARTICIPANT_TYPE = 'Q' AND v_PARTICIPANT.USE_BILLING_DETERMINANTS = 1 THEN
			GET_BILLING_DETERMINANTS(v_PARTICIPANT.PARTICIPANT_ENTITY_ID, v_BEGIN_DATE, v_END_DATE, v_CONSUMPTION, v_EARLIEST_BEGIN_DATE, v_LATEST_END_DATE);
			IF LOGS.IS_DEBUG_ENABLED THEN
				LOGS.LOG_DEBUG('BEGIN_DATE=' || TO_CHAR(v_BEGIN_DATE) || ', END_DATE=' || TO_CHAR(v_END_DATE));
				LOGS.LOG_DEBUG('EARLIEST_BEGIN_DATE=' || TO_CHAR(v_EARLIEST_BEGIN_DATE) || ', LATEST_END_DATE=' || TO_CHAR(v_LATEST_END_DATE));
			END IF;
			GET_PARTICIPANT_LOAD(p_MODEL_ID, v_PARTICIPANT, v_EARLIEST_BEGIN_DATE, v_LATEST_END_DATE, p_AS_OF_DATE, v_POSITION_ANALYSIS_LOAD);
			GET_PARTICIPANT_DETERMINANTS(v_PARTICIPANT.PARTICIPANT_ID, v_BEGIN_DATE, v_END_DATE, v_POSITION_ANALYSIS_LOAD, v_DETERMINANTS);
			CU.GET_PRORATED_CONSUMPTION(v_BEGIN_DATE, v_END_DATE, v_DETERMINANTS, v_CONSUMPTION, LOGS.IS_DEBUG_DETAIL_ENABLED, v_PRORATION);
			ADJUST_PARTICIPANT_LOAD(v_PARTICIPANT, v_PRORATION, v_POSITION_ANALYSIS_LOAD);
		ELSE
			GET_PARTICIPANT_LOAD(p_MODEL_ID, v_PARTICIPANT, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, v_POSITION_ANALYSIS_LOAD);
			GET_PARTICIPANT_DETERMINANTS(v_PARTICIPANT.PARTICIPANT_ID, v_BEGIN_DATE, v_END_DATE, v_POSITION_ANALYSIS_LOAD, v_PRORATION);
		END IF;
		CU.APPLY_PRODUCT_COMPONENTS(v_PARTICIPANT.PRODUCT_ID, v_PRORATION, v_BEGIN_DATE, v_END_DATE, LOGS.IS_DEBUG_ENABLED, v_PRODUCT);
		PUT_POSITION_ANALYSIS_LOAD(p_EVALUATION_ID, v_POSITION_ANALYSIS_LOAD, v_BEGIN_DATE, v_END_DATE);
		PUT_POSITION_ANALYSIS_REVENUE(p_MODEL_ID, p_EVALUATION_ID, v_PARTICIPANT.PARTICIPANT_ID, v_PRORATION, v_PRODUCT);
		v_CONSUMPTION.DELETE;
		v_DETERMINANTS.DELETE;
	END LOOP;

	SET_LOAD_SEGMENTS(p_MODEL_ID, p_EVALUATION_ID);

	SET_TRANSACTION_SEGMENTS(p_MODEL_ID, p_EVALUATION_ID, v_POSITION_ANALYSIS_EVALUATION.BEGIN_DATE, v_POSITION_ANALYSIS_EVALUATION.END_DATE, p_AS_OF_DATE);

	SET_SPOT_MARKET_SEGMENTS(p_MODEL_ID, p_EVALUATION_ID, v_POSITION_ANALYSIS_EVALUATION.MARKET_PRICE_ID);

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('RUN_POSITION_ANALYSIS_LD_EVAL END AT ' || UT.TRACE_DATE(SYSDATE));
	    LOGS.LOG_DEBUG('ELAPSED TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELASPSED));
 	END IF;

END RUN_POSITION_ANALYSIS_LD_EVAL;
---------------------------------------------------------------------------------------------------
PROCEDURE RUN_POSITION_ANALYSIS
    (
	p_EVALUATION_ID IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

v_ELASPSED PLS_INTEGER;
v_POSITION_ANALYSIS_EVALUATION POSITION_ANALYSIS_EVALUATION%ROWTYPE;

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK.';
	v_ELASPSED := DBMS_UTILITY.GET_TIME;
	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('RUN_POSITION_ANALYSIS BEGIN AT ' || UT.TRACE_DATE(SYSDATE));
		LOGS.LOG_DEBUG('EVALUATION_ID=' || TO_CHAR(p_EVALUATION_ID));
	END IF;

	SELECT * INTO v_POSITION_ANALYSIS_EVALUATION FROM POSITION_ANALYSIS_EVALUATION WHERE EVALUATION_ID = p_EVALUATION_ID;

	--Should modify this procedure to use p_MODEL_ID instead of GA.DEFAULT_MODEL.
    SET_SUPPLY_BLOCK_SEGMENTS(GA.DEFAULT_MODEL, p_EVALUATION_ID,  v_POSITION_ANALYSIS_EVALUATION.BEGIN_DATE, v_POSITION_ANALYSIS_EVALUATION.END_DATE);

	--Don't need to call SET_SPOT_MARKET_SEGMENTS from both here and RUN_POSITION_ANALYSIS_LD_EVAL
    --SET_SPOT_MARKET_SEGMENTS(GA.DEFAULT_MODEL, p_EVALUATION_ID, v_POSITION_ANALYSIS_EVALUATION.MARKET_PRICE_ID);

	UPDATE POSITION_ANALYSIS_EVALUATION
	SET LAST_RUN_DATE = SYSDATE
	WHERE EVALUATION_ID = p_EVALUATION_ID;

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('RUN_POSITION_ANALYSIS END AT ' || UT.TRACE_DATE(SYSDATE));
	    LOGS.LOG_DEBUG('ELAPSED TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELASPSED));
 	END IF;

END RUN_POSITION_ANALYSIS;
----------------------------------------------------------------------------------------------------
PROCEDURE SCHEDULE_TEMPLATE_REQUEST
	(
	p_METHOD_OPTION IN VARCHAR,
	p_TEMPLATE_NAME IN VARCHAR,
	p_START_HOUR_END IN NUMBER,
	p_STOP_HOUR_END IN NUMBER,
	p_INTERIOR_PERIOD IN NUMBER,
	p_DAY_OF_WEEK IN VARCHAR,
	p_INCLUDE_HOLIDAYS IN NUMBER,
	p_TEMPLATE_ORDER IN NUMBER,
	p_OLD_TEMPLATE_NAME IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_START_HOUR_END NUMBER(2);
v_STOP_HOUR_END NUMBER(2);

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	IF UPPER(SUBSTR(p_METHOD_OPTION,1,1)) = 'M' THEN -- Modify; Insert or Update
		v_START_HOUR_END := GREATEST(LEAST(NVL(p_START_HOUR_END, 1), 24), 1);
		v_STOP_HOUR_END := GREATEST(LEAST(GREATEST(NVL(p_STOP_HOUR_END, 24), 1), 24), v_START_HOUR_END);

-- Try to update an existing record
		UPDATE SCHEDULE_TEMPLATE SET
			TEMPLATE_NAME = LTRIM(RTRIM(p_TEMPLATE_NAME)),
			START_HOUR_END = v_START_HOUR_END,
			STOP_HOUR_END = v_STOP_HOUR_END,
			INTERIOR_PERIOD = NVL(p_INTERIOR_PERIOD,1),
			DAY_OF_WEEK = LTRIM(RTRIM(NVL(p_DAY_OF_WEEK,'1111111'))),
			INCLUDE_HOLIDAYS = NVL(p_INCLUDE_HOLIDAYS,1),
			TEMPLATE_ORDER = NVL(p_TEMPLATE_ORDER,999)
		WHERE TEMPLATE_NAME = LTRIM(RTRIM(p_OLD_TEMPLATE_NAME));

-- If the previous update did not find a match, then insert a new record.

		IF SQL%NOTFOUND THEN
			INSERT INTO SCHEDULE_TEMPLATE (
				TEMPLATE_NAME,
				START_HOUR_END,
				STOP_HOUR_END,
				INTERIOR_PERIOD,
				DAY_OF_WEEK,
				INCLUDE_HOLIDAYS,
				TEMPLATE_ORDER)
			VALUES (
				LTRIM(RTRIM(p_TEMPLATE_NAME)),
				v_START_HOUR_END,
				v_STOP_HOUR_END,
				NVL(p_INTERIOR_PERIOD,1),
				LTRIM(RTRIM(NVL(p_DAY_OF_WEEK,'1111111'))),
				NVL(p_INCLUDE_HOLIDAYS,1),
				NVL(p_TEMPLATE_ORDER,999));
		END IF;

	ELSIF UPPER(SUBSTR(p_METHOD_OPTION,1,1)) = 'D' THEN -- Delete
		DELETE SCHEDULE_TEMPLATE WHERE TEMPLATE_NAME = LTRIM(RTRIM(p_TEMPLATE_NAME));
	END IF;

END SCHEDULE_TEMPLATE_REQUEST;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_SCHEDULER_TREE
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
    p_IS_BID_OFFER IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the scheduler tree for all transactions within the specified temporal scope.

v_SCHEDULER_TREE_HIERARCHY VARCHAR2(32) := NVL(MODEL_VALUE_AT_KEY(GA.ELECTRIC_MODEL,'Scheduling','Scheduler Tree','Hierarchy'),'A');
v_SCHEDULER_TREE_TYPE CHAR(1) := SUBSTR(v_SCHEDULER_TREE_HIERARCHY,1,1);
v_ALLOWED_TXNS ID_TABLE := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_TXN_SELECT);
BEGIN


	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	IF v_SCHEDULER_TREE_TYPE = 'A' THEN
		OPEN p_CURSOR FOR
			SELECT DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)),'PU','Transaction','SA','Transaction','PA','Transaction','LO','Load','RE','Load',A.TRANSACTION_TYPE) AS TRANSACTION_TYPE,
				B.COMMODITY_NAME,
				C.SERVICE_POINT_TYPE,
				A.TRANSACTION_NAME,
				A.TRANSACTION_ID,
				D.TRANSACTION_IS_ACTIVE
			FROM INTERCHANGE_TRANSACTION A, IT_COMMODITY B, SERVICE_POINT C, IT_STATUS D,
				TABLE(CAST(v_ALLOWED_TXNS AS ID_TABLE)) X
			WHERE BEGIN_DATE <= p_END_DATE
				AND END_DATE >= p_BEGIN_DATE
                AND (p_IS_BID_OFFER = 0 OR IS_BID_OFFER = 1)
				AND B.COMMODITY_ID = A.COMMODITY_ID
				AND C.SERVICE_POINT_ID = A.POD_ID
				AND D.TRANSACTION_ID = A.TRANSACTION_ID
				AND D.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM IT_STATUS
					WHERE TRANSACTION_ID = D.TRANSACTION_ID
						AND AS_OF_DATE <= p_AS_OF_DATE)
				AND (X.ID = SD.g_ALL_DATA_ENTITY_ID OR A.TRANSACTION_ID = X.ID)
			ORDER BY 1 DESC, 2 ASC, 3 ASC, 4 ASC;
	ELSIF v_SCHEDULER_TREE_TYPE = 'B' THEN
		OPEN p_CURSOR FOR
			SELECT C.SC_NAME,
				DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)),'PU','Transaction','SA','Transaction','PA','Transaction','LO','Load','RE','Load',A.TRANSACTION_TYPE) AS TRANSACTION_TYPE,
				B.COMMODITY_NAME,
				A.TRANSACTION_NAME,
				A.TRANSACTION_ID,
				D.TRANSACTION_IS_ACTIVE
			FROM INTERCHANGE_TRANSACTION A, IT_COMMODITY B, SCHEDULE_COORDINATOR C, IT_STATUS D,
				TABLE(CAST(v_ALLOWED_TXNS AS ID_TABLE)) X
			WHERE BEGIN_DATE <= p_END_DATE
				AND END_DATE >= p_BEGIN_DATE
                AND (p_IS_BID_OFFER = 0 OR IS_BID_OFFER = 1)
				AND B.COMMODITY_ID = A.COMMODITY_ID
				AND C.SC_ID = A.SC_ID
				AND D.TRANSACTION_ID = A.TRANSACTION_ID
				AND D.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM IT_STATUS
					WHERE TRANSACTION_ID = D.TRANSACTION_ID
						AND AS_OF_DATE <= p_AS_OF_DATE)
				AND (X.ID = SD.g_ALL_DATA_ENTITY_ID OR A.TRANSACTION_ID = X.ID)
			ORDER BY 1 ASC, 2 DESC, 3 ASC, 4 ASC;
	ELSIF v_SCHEDULER_TREE_TYPE = 'C' THEN
		OPEN p_CURSOR FOR
			SELECT C.SC_NAME,
				NVL(F.RESOURCE_GROUP_NAME, 'Not Assigned'),
				B.COMMODITY_NAME,
				A.TRANSACTION_NAME,
				A.TRANSACTION_ID,
				D.TRANSACTION_IS_ACTIVE
			FROM INTERCHANGE_TRANSACTION A, IT_COMMODITY B, SCHEDULE_COORDINATOR C, IT_STATUS D, SUPPLY_RESOURCE E, SUPPLY_RESOURCE_GROUP F,
				TABLE(CAST(v_ALLOWED_TXNS AS ID_TABLE)) X
			WHERE BEGIN_DATE <= p_END_DATE
				AND END_DATE >= p_BEGIN_DATE
                AND (p_IS_BID_OFFER = 0 OR IS_BID_OFFER = 1)
				AND B.COMMODITY_ID = A.COMMODITY_ID
				AND C.SC_ID = A.SC_ID
				AND D.TRANSACTION_ID = A.TRANSACTION_ID
				AND D.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM IT_STATUS
					WHERE TRANSACTION_ID = D.TRANSACTION_ID
						AND AS_OF_DATE <= p_AS_OF_DATE)
				AND E.RESOURCE_ID(+) = A.RESOURCE_ID
				AND F.RESOURCE_GROUP_ID(+) = E.RESOURCE_GROUP_ID
				AND A.TRANSACTION_ID IN (SELECT X.ID FROM TABLE(CAST(v_ALLOWED_TXNS AS ID_TABLE))X)
				AND (X.ID = SD.g_ALL_DATA_ENTITY_ID OR A.TRANSACTION_ID = X.ID)
			ORDER BY 1 ASC, 2 ASC, 3 DESC, 4 ASC;
--	ELSIF v_SCHEDULER_TREE_TYPE = '*' THEN
--    	CUSTOM_SCHEDULER_TREE(SUBSTR(v_SCHEDULER_TREE_HIERARCHY,2),p_BEGIN_DATE,p_END_DATE,p_AS_OF_DATE,p_IS_BID_OFFER,v_ALLOWED_TXNS,p_STATUS,p_CURSOR);
--	ELSIF v_SCHEDULER_TREE_TYPE = 'X' THEN
--    	XS.GET_SCHEDULER_TREE (p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_IS_BID_OFFER, p_STATUS, p_CURSOR);
	END IF;

END GET_SCHEDULER_TREE;
---------------------------------------------------------------------------------------------------
END QM;
/

