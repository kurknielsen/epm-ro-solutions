CREATE OR REPLACE PACKAGE BODY FS AS
gc_PACKAGE_NAME            CONSTANT VARCHAR(30)  := 'FS';
gc_CRLF                    CONSTANT VARCHAR2(10) := UTL_TCP.CRLF;
--@@Begin Implementation Override --
c_DATE_FORMAT              CONSTANT VARCHAR2(16) := 'MM/DD/YYYY';
c_DATE_TIME_FORMAT         CONSTANT VARCHAR2(32) := 'MM/DD/YYYY HH24:MI:SS';
l_ENABLE_SERVICE_PARTITIONING BOOLEAN := TRUE;
--@@End Implementation Override--
----------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
    RETURN '$Revision: 1.10 $';
END WHAT_VERSION;
----------------------------------------------------------------------------------------------------
FUNCTION NEW_CAST_CONTEXT RETURN CAST_CONTEXT_TYPE IS
v_CAST_CONTEXT CAST_CONTEXT_TYPE;
BEGIN
	v_CAST_CONTEXT := CAST_CONTEXT_TYPE(NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	RETURN v_CAST_CONTEXT;
END NEW_CAST_CONTEXT;
----------------------------------------------------------------------------------------------------
FUNCTION GET_PROCESS_NAME
	(
	p_REQUEST_TYPE IN CHAR,
	p_REQUEST_MODE IN NUMBER
	) RETURN VARCHAR2 AS
	v_PROCESS_NAME VARCHAR2(32);
BEGIN

	-- Build the Process Name
	CASE
		WHEN p_REQUEST_TYPE = 'A' THEN
			v_PROCESS_NAME := 'Usage Allocation';
		WHEN p_REQUEST_MODE = GA.STATEMENT_MODE THEN
			v_PROCESS_NAME := 'Financial Forecast';
		WHEN p_REQUEST_TYPE = 'S' THEN
			v_PROCESS_NAME := 'Create Settlement Profile';
		WHEN p_REQUEST_TYPE = 'F' AND (p_REQUEST_MODE IN(GA.STANDARD_MODE, GA.ACCOUNT_GROUP_MODE)) THEN
			v_PROCESS_NAME := 'Forecast';
		WHEN p_REQUEST_TYPE = 'B' AND (p_REQUEST_MODE IN(GA.STANDARD_MODE, GA.ACCOUNT_GROUP_MODE)) THEN
			v_PROCESS_NAME := 'Backcast';
		ELSE
			v_PROCESS_NAME := 'FS.CAST_SERVICE_REQUEST';
	END CASE;

	RETURN v_PROCESS_NAME;
END GET_PROCESS_NAME;
----------------------------------------------------------------------------------------------------
FUNCTION ADJUST_SPRING_AHEAD_DAY
	(
	p_PROFILE IN GA.NUMBER_TABLE
	) RETURN GA.NUMBER_TABLE IS

v_PROFILE GA.NUMBER_TABLE;
v_INTERVAL DST_INTERVAL_MAP.INTERVAL%TYPE;
v_SRC_TYPE DST_TYPE.DST_TYPE%TYPE;

BEGIN

	IF p_PROFILE.COUNT < 23 THEN
		RETURN p_PROFILE;	-- MUST BE DAILY
	END IF;

	IF p_PROFILE.COUNT IN (23, 46, 92) THEN
		RETURN p_PROFILE; -- ALREADY ADJUSTED
	END IF;

	IF p_PROFILE.COUNT = 24 THEN
		v_INTERVAL := DATE_UTIL.c_NAME_HOUR;
		v_SRC_TYPE := CONSTANTS.DST_TYPE_NONE;
	ELSIF p_PROFILE.COUNT = 48 THEN
		v_INTERVAL := DATE_UTIL.c_NAME_30MIN;
		v_SRC_TYPE := CONSTANTS.DST_TYPE_NONE;
	ELSIF p_PROFILE.COUNT = 96 THEN
		v_INTERVAL := DATE_UTIL.c_NAME_15MIN;
		v_SRC_TYPE := CONSTANTS.DST_TYPE_NONE;
	ELSIF p_PROFILE.COUNT = 25 THEN
		v_INTERVAL := DATE_UTIL.c_NAME_HOUR;
		v_SRC_TYPE := CONSTANTS.DST_TYPE_FALL_BACK;
	ELSIF p_PROFILE.COUNT = 50 THEN
		v_INTERVAL := DATE_UTIL.c_NAME_30MIN;
		v_SRC_TYPE := CONSTANTS.DST_TYPE_FALL_BACK;
	ELSIF p_PROFILE.COUNT = 100 THEN
		v_INTERVAL := DATE_UTIL.c_NAME_15MIN;
		v_SRC_TYPE := CONSTANTS.DST_TYPE_FALL_BACK;
	ELSE
		LOGS.LOG_WARN('Encountered an unexpected profile size of ' || p_PROFILE.COUNT);
		v_INTERVAL := DATE_UTIL.c_NAME_HOUR; -- ASSUME HOUR
		v_SRC_TYPE := CONSTANTS.DST_TYPE_NONE;
	END IF;

	DATE_UTIL.TRANSFORM_NUMBER_TBL_FOR_DST(p_PROFILE,
											v_SRC_TYPE,
											CONSTANTS.DST_TYPE_SPRING_AHEAD,
											v_INTERVAL,
											v_PROFILE);

	RETURN v_PROFILE;

END ADJUST_SPRING_AHEAD_DAY;
----------------------------------------------------------------------------------------------------
FUNCTION ADJUST_FALL_BACK_DAY
	(
	p_PROFILE IN GA.NUMBER_TABLE
	) RETURN GA.NUMBER_TABLE IS

v_PROFILE GA.NUMBER_TABLE;
v_INTERVAL DST_INTERVAL_MAP.INTERVAL%TYPE;
v_SRC_TYPE DST_TYPE.DST_TYPE%TYPE;

BEGIN

	IF p_PROFILE.COUNT < 23 THEN
		RETURN p_PROFILE;	-- MUST BE DAILY
	END IF;

	IF p_PROFILE.COUNT IN (25, 50, 100) THEN
		RETURN p_PROFILE; -- ALREADY ADJUSTED
	END IF;

	IF p_PROFILE.COUNT = 24 THEN
		v_INTERVAL := DATE_UTIL.c_NAME_HOUR;
		v_SRC_TYPE := CONSTANTS.DST_TYPE_NONE;
	ELSIF p_PROFILE.COUNT = 48 THEN
		v_INTERVAL := DATE_UTIL.c_NAME_30MIN;
		v_SRC_TYPE := CONSTANTS.DST_TYPE_NONE;
	ELSIF p_PROFILE.COUNT = 96 THEN
		v_INTERVAL := DATE_UTIL.c_NAME_15MIN;
		v_SRC_TYPE := CONSTANTS.DST_TYPE_NONE;
	ELSIF p_PROFILE.COUNT = 23 THEN
		v_INTERVAL := DATE_UTIL.c_NAME_HOUR;
		v_SRC_TYPE := CONSTANTS.DST_TYPE_SPRING_AHEAD;
	ELSIF p_PROFILE.COUNT = 46 THEN
		v_INTERVAL := DATE_UTIL.c_NAME_30MIN;
		v_SRC_TYPE := CONSTANTS.DST_TYPE_SPRING_AHEAD;
	ELSIF p_PROFILE.COUNT = 92 THEN
		v_INTERVAL := DATE_UTIL.c_NAME_15MIN;
		v_SRC_TYPE := CONSTANTS.DST_TYPE_SPRING_AHEAD;
	ELSE
		LOGS.LOG_WARN('Encountered an unexpected profile size of ' || p_PROFILE.COUNT);
		v_INTERVAL := DATE_UTIL.c_NAME_HOUR; -- ASSUME HOUR
		v_SRC_TYPE := CONSTANTS.DST_TYPE_NONE;
	END IF;

	DATE_UTIL.TRANSFORM_NUMBER_TBL_FOR_DST(p_PROFILE,
											v_SRC_TYPE,
											CONSTANTS.DST_TYPE_FALL_BACK,
											v_INTERVAL,
											v_PROFILE);

	RETURN v_PROFILE;

END ADJUST_FALL_BACK_DAY;
----------------------------------------------------------------------------------------------------
FUNCTION SERVICE_AS_OF_DATE
	(
	p_SERVICE_CODE IN CHAR,
	p_AS_OF_DATE IN DATE
	) RETURN DATE IS

BEGIN

	IF p_SERVICE_CODE = GA.FORECAST_SERVICE AND NOT GA.VERSION_FORECAST THEN
		RETURN LOW_DATE;
	ELSIF p_SERVICE_CODE = GA.BACKCAST_SERVICE AND NOT GA.VERSION_BACKCAST THEN
		RETURN LOW_DATE;
	ELSIF p_SERVICE_CODE = GA.ACTUAL_SERVICE AND NOT GA.VERSION_ACTUAL THEN
		RETURN LOW_DATE;
	END IF;

	RETURN p_AS_OF_DATE;

END SERVICE_AS_OF_DATE;
----------------------------------------------------------------------------------------------------
FUNCTION COERCE_DATE_TO_DAY_TYPE
	(
	p_DATE IN DATE,
	p_DAY_TYPE IN NUMBER
	) RETURN DATE IS

v_DATE DATE;
v_INDEX BINARY_INTEGER;

BEGIN

	v_DATE := p_DATE;

	FOR v_INDEX IN 1..6 LOOP
		--IF WE ARE COERCING TO A WEEKEND, MAKE SURE IT IS SATURDAY OR SUNDAY.
		IF (p_DAY_TYPE = GA.WEEK_END AND TO_CHAR(v_DATE,'D') IN(1,7))
		--IF WE ARE COERCING TO A WEEKDAY, MAKE SURE IT IS MON-FRI AND NOT A HOLIDAY.
		OR (p_DAY_TYPE = GA.WEEK_DAY AND TO_CHAR(v_DATE,'D') BETWEEN 2 AND 6 AND NOT IS_HOLIDAY(v_DATE)) THEN
			RETURN v_DATE;
		END IF;
		v_DATE := v_DATE + 1;
	END LOOP;

	RETURN v_DATE;

END COERCE_DATE_TO_DAY_TYPE;
----------------------------------------------------------------------------------------------------
FUNCTION GET_COMPONENT
	(
	p_COMPONENT_ID IN NUMBER
	) RETURN COMPONENT%ROWTYPE IS

v_COMPONENT COMPONENT%ROWTYPE;

BEGIN

    SELECT *
	INTO v_COMPONENT
	FROM COMPONENT
	WHERE COMPONENT_ID = p_COMPONENT_ID;

	RETURN v_COMPONENT;

	EXCEPTION
	    WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		    RETURN NULL;

END GET_COMPONENT;

--@@Begin Implementation Override --
--@@Truncate Sevice State And Service Load Tables For The Exection Time Period -- 
PROCEDURE TRUNCATE_TABLESPACE(p_TABLE_NAME IN VARCHAR2, p_FROM_DATE IN DATE, p_TO_DATE IN DATE, p_SERVICE_TYPE IN VARCHAR2) AS
v_PROCEDURE VARCHAR2(32) := 'TRUNCATE_TABLESPACE';
v_SERVICE_DATE DATE := TRUNC(p_FROM_DATE);
v_PARTITION  VARCHAR2(32);
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;
BEGIN
   WHILE v_SERVICE_DATE <= TRUNC(p_TO_DATE) LOOP
      v_PARTITION := 'P' || TO_CHAR(v_SERVICE_DATE,'YYYYMMDD') || p_SERVICE_TYPE;
      EXECUTE IMMEDIATE 'ALTER TABLE ' || p_TABLE_NAME || ' TRUNCATE SUBPARTITION ' || v_PARTITION || ' REUSE STORAGE';
      v_SERVICE_DATE := v_SERVICE_DATE + 1;
   END LOOP;
   LOGS.LOG_INFO('Truncate Table "' || p_TABLE_NAME || '" Tablespace Elapsed Time: ' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED), v_PROCEDURE);
END TRUNCATE_TABLESPACE;
--@@End Implementation Override --

PROCEDURE ADJUST_FOR_DAYLIGHT_SAVINGS
	(
	p_SERVICE_DATE IN DATE,
	p_PROFILE IN OUT NOCOPY GA.NUMBER_TABLE,
	p_TX_LOSS IN OUT NOCOPY GA.NUMBER_TABLE,
	p_DX_LOSS IN OUT NOCOPY GA.NUMBER_TABLE,
	p_UE_LOSS IN OUT NOCOPY GA.NUMBER_TABLE
	) AS

BEGIN

	IF UPPER(SUBSTR(LOCAL_TIME_ZONE,2,1)) = 'D' OR UPPER(SUBSTR(LOCAL_TIME_ZONE,3,1)) = 'S' THEN
		IF TRUNC(p_SERVICE_DATE) = TRUNC(DST_SPRING_AHEAD_DATE(p_SERVICE_DATE)) THEN
			p_PROFILE := ADJUST_SPRING_AHEAD_DAY(p_PROFILE);
			p_TX_LOSS := ADJUST_SPRING_AHEAD_DAY(p_TX_LOSS);
			p_DX_LOSS := ADJUST_SPRING_AHEAD_DAY(p_DX_LOSS);
			p_UE_LOSS := ADJUST_SPRING_AHEAD_DAY(p_UE_LOSS);
		ELSIF TRUNC(p_SERVICE_DATE) = TRUNC(DST_FALL_BACK_DATE(p_SERVICE_DATE)) THEN
			p_PROFILE := ADJUST_FALL_BACK_DAY(p_PROFILE);
			p_TX_LOSS := ADJUST_FALL_BACK_DAY(p_TX_LOSS);
			p_DX_LOSS := ADJUST_FALL_BACK_DAY(p_DX_LOSS);
			p_UE_LOSS := ADJUST_FALL_BACK_DAY(p_UE_LOSS);
		ELSE -- NORMAL DAY, PROFILE COULD BE SHORT OR LONG IF IT'S PROXY DAY, ADJUST BACK TO STANDARD
			FP.ADJUST_TO_STANDARD_PROFILE(p_PROFILE);
		END IF;
	END IF;

END ADJUST_FOR_DAYLIGHT_SAVINGS;
----------------------------------------------------------------------------------------------------
FUNCTION GET_EDC_FOR_ACCOUNT
	(
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_IS_ACCOUNT_SERVICE IN BOOLEAN DEFAULT FALSE
	) RETURN NUMBER IS

-- Answer the assigned EDC id for the account.

v_EDC_ID NUMBER;

BEGIN

	IF p_IS_ACCOUNT_SERVICE THEN
		SELECT B.EDC_ID
		INTO v_EDC_ID
		FROM ACCOUNT_SERVICE A, ACCOUNT_EDC B
		WHERE A.ACCOUNT_SERVICE_ID = p_ACCOUNT_ID
			AND B.ACCOUNT_ID = A.ACCOUNT_ID
			AND p_SERVICE_DATE BETWEEN B.BEGIN_DATE AND NVL(B.END_DATE, CONSTANTS.HIGH_DATE);
	ELSE
		SELECT EDC_ID
		INTO v_EDC_ID
		FROM ACCOUNT_EDC
		WHERE ACCOUNT_ID = p_ACCOUNT_ID
			AND p_SERVICE_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE, CONSTANTS.HIGH_DATE);
	END IF;

	RETURN v_EDC_ID;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN CONSTANTS.NOT_ASSIGNED;
END GET_EDC_FOR_ACCOUNT;
----------------------------------------------------------------------------------------------------
PROCEDURE CAST_CANDIDATES
	(
	p_EDC_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	IF NOT CAN_READ('PUBLIC') THEN
		ERRS.RAISE_NO_READ_MODULE('PUBLIC');
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT A.ACCOUNT_MODEL_OPTION,
			A.ACCOUNT_NAME,
			A.ACCOUNT_ID,
			E.SERVICE_LOCATION_NAME,
			E.SERVICE_LOCATION_ID,
			'' "METER_NAME",
			-1 "METER_ID",
			D.BEGIN_DATE,
			D.END_DATE
		FROM ACCOUNT A, ACCOUNT_STATUS B, ACCOUNT_STATUS_NAME STATUS_NAME,  ACCOUNT_EDC C, ACCOUNT_SERVICE_LOCATION D, SERVICE_LOCATION E
		WHERE UPPER(SUBSTR(A.ACCOUNT_MODEL_OPTION,1,1)) = 'A'
            AND A.IS_SUB_AGGREGATE = 0
			AND B.ACCOUNT_ID = A.ACCOUNT_ID
			AND B.BEGIN_DATE <= p_END_DATE
			AND NVL(B.END_DATE, p_END_DATE) >= p_BEGIN_DATE
			AND STATUS_NAME.STATUS_NAME = B.STATUS_NAME
			AND STATUS_NAME.IS_ACTIVE = 1
			AND C.ACCOUNT_ID = B.ACCOUNT_ID
			AND (p_EDC_ID = g_ALL OR C.EDC_ID = p_EDC_ID)
			AND C.BEGIN_DATE <= p_END_DATE
			AND NVL(C.END_DATE, p_END_DATE) >= p_BEGIN_DATE
			AND D.ACCOUNT_ID = C.ACCOUNT_ID
			AND D.BEGIN_DATE <= p_END_DATE
			AND NVL(D.END_DATE, p_END_DATE) >= p_BEGIN_DATE
			AND E.SERVICE_LOCATION_ID = D.SERVICE_LOCATION_ID
		UNION
		SELECT A.ACCOUNT_MODEL_OPTION,
			A.ACCOUNT_NAME,
			A.ACCOUNT_ID,
			E.SERVICE_LOCATION_NAME,
			E.SERVICE_LOCATION_ID,
			G.METER_NAME,
			G.METER_ID,
			F.BEGIN_DATE,
			F.END_DATE
		FROM ACCOUNT A, ACCOUNT_STATUS B, ACCOUNT_STATUS_NAME STATUS_NAME, ACCOUNT_EDC C, ACCOUNT_SERVICE_LOCATION D, SERVICE_LOCATION E, SERVICE_LOCATION_METER F, METER G, ACCOUNT_STATUS_NAME MSN
		WHERE UPPER(SUBSTR(A.ACCOUNT_MODEL_OPTION,1,1)) = 'M'
            AND A.IS_SUB_AGGREGATE = 0
			AND B.ACCOUNT_ID = A.ACCOUNT_ID
			AND B.BEGIN_DATE <= p_END_DATE
			AND NVL(B.END_DATE, p_END_DATE) >= p_BEGIN_DATE
			AND STATUS_NAME.STATUS_NAME = B.STATUS_NAME
			AND STATUS_NAME.IS_ACTIVE = 1
			AND C.ACCOUNT_ID = B.ACCOUNT_ID
			AND (p_EDC_ID = g_ALL OR C.EDC_ID = p_EDC_ID)
			AND C.BEGIN_DATE <= p_END_DATE
			AND NVL(C.END_DATE, p_END_DATE) >= p_BEGIN_DATE
			AND D.ACCOUNT_ID = C.ACCOUNT_ID
			AND D.BEGIN_DATE <= p_END_DATE
			AND NVL(D.END_DATE, p_END_DATE) >= p_BEGIN_DATE
			AND E.SERVICE_LOCATION_ID = D.SERVICE_LOCATION_ID
			AND F.SERVICE_LOCATION_ID = E.SERVICE_LOCATION_ID
			AND F.BEGIN_DATE <= NVL(D.END_DATE, F.BEGIN_DATE)
			AND NVL(F.END_DATE, D.BEGIN_DATE) >= D.BEGIN_DATE
			AND G.METER_ID = F.METER_ID
			AND MSN.STATUS_NAME = G.METER_STATUS
			AND MSN.IS_ACTIVE = 1
		ORDER BY 1,2;


END CAST_CANDIDATES;
----------------------------------------------------------------------------------------------------
PROCEDURE CAST_LOGIC_BEGIN AS
-- Begin Cast Caching Logic
BEGIN
	NULL;
END CAST_LOGIC_BEGIN;
----------------------------------------------------------------------------------------------------
PROCEDURE INITIALIZE_SERVICE_LOAD AS

BEGIN

	g_SERVICE_LOAD_XREF.DELETE;
	g_SERVICE_LOAD_ID.DELETE;
	g_SERVICE_LOAD_DATE.DELETE;
	g_SERVICE_LOAD_VAL.DELETE;
	g_SERVICE_LOAD_TX_LOSS_VAL.DELETE;
	g_SERVICE_LOAD_DX_LOSS_VAL.DELETE;
	g_SERVICE_LOAD_UE_LOSS_VAL.DELETE;
	g_SERVICE_LOAD_CACHE_SIZE  := 0;

END INITIALIZE_SERVICE_LOAD;
----------------------------------------------------------------------------------------------------
PROCEDURE INITIALIZE_SOB_LOAD AS

BEGIN

	g_SOB_LOAD_XREF.DELETE;
	g_SOB_LOAD_ID.DELETE;
	g_SOB_LOAD_DATE.DELETE;
	g_SOB_LOAD_VAL.DELETE;
	g_SOB_TX_LOSS_VAL.DELETE;
	g_SOB_DX_LOSS_VAL.DELETE;
	g_SOB_UE_LOSS_VAL.DELETE;
	g_SOB_AGG_LOAD_VAL.DELETE;
	g_SOB_AGG_TX_LOSS_VAL.DELETE;
	g_SOB_AGG_DX_LOSS_VAL.DELETE;

END INITIALIZE_SOB_LOAD;
----------------------------------------------------------------------------------------------------
PROCEDURE INITIALIZE_SERVICE AS

BEGIN

	g_SERVICE_MODEL_XREF.DELETE;
	g_SERVICE_XREF.DELETE;
	g_SERVICE_ID.DELETE;
	g_ACCOUNT_SERVICE_ID.DELETE;
	g_PROVIDER_SERVICE_ID.DELETE;
	g_SERVICE_DELIVERY_ID.DELETE;
	g_SERVICE_DATE.DELETE;
	g_SERVICE_OBLIGATION_ID.DELETE;
	g_POOL_ID.DELETE;
	g_SERVICE_POINT_ID.DELETE;
	g_SCHEDULE_GROUP_ID.DELETE;
	g_STATION_ID.DELETE;
	g_CAST_CALENDAR_ID.DELETE;
	g_SETTLEMENT_PROFILE_ID.DELETE;
	g_IS_UFE_PARTICIPANT.DELETE;
	g_IS_CREATE_SETTLEMENT_PROFILE.DELETE;
	g_SERVICE_ACCOUNTS.DELETE;
	g_METER_TYPE.DELETE;
	g_SUPPLY_TYPE.DELETE;
	g_IS_BUG.DELETE;
	g_IS_WHOLESALE.DELETE;
	g_IS_AGGREGATE_ACCOUNT.DELETE;
	g_IS_AGGREGATE_POOL.DELETE;
	g_IS_EXTERNAL_FORECAST.DELETE;
	g_PROFILE_TYPE.DELETE;
	g_PROFILE_SOURCE_DATE.DELETE;
	g_PROFILE_ZERO_COUNT.DELETE;
	g_USAGE_FACTOR.DELETE;
	g_GROWTH_FACTOR.DELETE;
	g_SERVICE_INTERVALS.DELETE;
	g_AGGREGATE_POOLS_SUB_POOLS.DELETE;

	INITIALIZE_SERVICE_LOAD;

	INITIALIZE_SOB_LOAD;

END INITIALIZE_SERVICE;
----------------------------------------------------------------------------------------------------
PROCEDURE STORE_SERVICE_STATE
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE
	) AS

v_INDEX BINARY_INTEGER;
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;

BEGIN

	FORALL v_INDEX IN 1..g_SERVICE_XREF.COUNT
		MERGE INTO SERVICE_STATE SS
		USING (SELECT g_SERVICE_ID(v_INDEX) as SERVICE_ID,
					p_CAST_CONTEXT.REQUEST_TYPE as SERVICE_CODE,
					g_SERVICE_DATE(v_INDEX) as SERVICE_DATE,
					p_CAST_CONTEXT.INPUT_AS_OF_DATE as BASIS_AS_OF_DATE,
					g_IS_UFE_PARTICIPANT(v_INDEX) as IS_UFE_PARTICIPANT,
					g_SERVICE_ACCOUNTS(v_INDEX) as SERVICE_ACCOUNTS,
					g_METER_TYPE(v_INDEX) as METER_TYPE,
					g_IS_EXTERNAL_FORECAST(v_INDEX) as IS_EXTERNAL_FORECAST,
					g_IS_AGGREGATE_ACCOUNT(v_INDEX) as IS_AGGREGATE_ACCOUNT,
					g_IS_AGGREGATE_POOL(v_INDEX) as IS_AGGREGATE_POOL,
					g_PROFILE_TYPE(v_INDEX) as PROFILE_TYPE,
					g_PROFILE_SOURCE_DATE(v_INDEX) as PROFILE_SOURCE_DATE,
					g_PROFILE_ZERO_COUNT(v_INDEX) as PROFILE_ZERO_COUNT,
					CASE WHEN g_PROFILE_TYPE(v_INDEX) = g_PROXY_USAGE_PROFILE THEN g_PROXY_DAY_METHOD_ID(v_INDEX) ELSE NULL END as PROXY_DAY_METHOD_ID,
					g_USAGE_FACTOR(v_INDEX) as USAGE_FACTOR,
					g_SERVICE_INTERVALS(v_INDEX) as SERVICE_INTERVALS,
					CASE WHEN p_CAST_CONTEXT.ACCUMULATE_ONLY = 1 THEN 0 ELSE 1 END as HAS_DETAILS
				FROM DUAL WHERE NOT (g_IS_AGGREGATE_ACCOUNT(v_INDEX)=1 AND g_METER_TYPE(v_INDEX)='I')) N
		ON (SS.SERVICE_ID = N.SERVICE_ID
			AND SS.SERVICE_CODE = N.SERVICE_CODE
			AND SS.SERVICE_DATE = N.SERVICE_DATE)
		WHEN MATCHED THEN
			UPDATE SET SS.BASIS_AS_OF_DATE = N.BASIS_AS_OF_DATE,
						SS.IS_UFE_PARTICIPANT = N.IS_UFE_PARTICIPANT,
						SS.SERVICE_ACCOUNTS = N.SERVICE_ACCOUNTS,
						SS.METER_TYPE = N.METER_TYPE,
						SS.IS_EXTERNAL_FORECAST = N.IS_EXTERNAL_FORECAST,
						SS.IS_AGGREGATE_ACCOUNT = N.IS_AGGREGATE_ACCOUNT,
						SS.IS_AGGREGATE_POOL = N.IS_AGGREGATE_POOL,
						SS.PROFILE_TYPE = N.PROFILE_TYPE,
						SS.PROFILE_SOURCE_DATE = N.PROFILE_SOURCE_DATE,
						SS.PROFILE_ZERO_COUNT = N.PROFILE_ZERO_COUNT,
						SS.PROXY_DAY_METHOD_ID = N.PROXY_DAY_METHOD_ID,
						SS.USAGE_FACTOR = N.USAGE_FACTOR,
						SS.SERVICE_INTERVALS = N.SERVICE_INTERVALS,
						SS.HAS_DETAILS = N.HAS_DETAILS
		WHEN NOT MATCHED THEN
			INSERT (SS.SERVICE_ID, SS.SERVICE_CODE, SS.SERVICE_DATE, SS.BASIS_AS_OF_DATE, SS.IS_UFE_PARTICIPANT,
					SS.SERVICE_ACCOUNTS, SS.METER_TYPE, SS.IS_EXTERNAL_FORECAST, SS.IS_AGGREGATE_ACCOUNT,
					SS.IS_AGGREGATE_POOL, SS.PROFILE_TYPE, SS.PROFILE_SOURCE_DATE, SS.PROFILE_ZERO_COUNT,
					SS.PROXY_DAY_METHOD_ID, SS.USAGE_FACTOR, SS.SERVICE_INTERVALS, SS.HAS_DETAILS)
			VALUES (N.SERVICE_ID, N.SERVICE_CODE, N.SERVICE_DATE, N.BASIS_AS_OF_DATE, N.IS_UFE_PARTICIPANT,
					N.SERVICE_ACCOUNTS, N.METER_TYPE, N.IS_EXTERNAL_FORECAST, N.IS_AGGREGATE_ACCOUNT,
					N.IS_AGGREGATE_POOL, N.PROFILE_TYPE, N.PROFILE_SOURCE_DATE, N.PROFILE_ZERO_COUNT,
					N.PROXY_DAY_METHOD_ID, N.USAGE_FACTOR, N.SERVICE_INTERVALS, N.HAS_DETAILS);

	LOGS.LOG_DEBUG('STORE_SERVICE_STATE ELAPSED TIME='  || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED) || ', COUNT=' || TO_CHAR(g_SERVICE_XREF.COUNT));

END STORE_SERVICE_STATE;
----------------------------------------------------------------------------------------------------
PROCEDURE STORE_SERVICE_LOAD
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE
	) AS

v_INDEX BINARY_INTEGER;
v_LOAD_CODE CHAR(1);
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;

BEGIN

	IF p_CAST_CONTEXT.ACCUMULATE_ONLY = 1 THEN
		-- DON'T SAVE ANY SERVICE_LOAD DETAILS; ACCUMULATE ONLY
		RETURN;
	END IF;

	IF p_CAST_CONTEXT.RUN_MODE IN (GA.MONTH_MODE, GA.WEEK_MODE) THEN
		v_LOAD_CODE := p_CAST_CONTEXT.DAY_TYPE;
	ELSE
		v_LOAD_CODE := GA.STANDARD;
	END IF;

	FORALL v_INDEX IN 1..g_SERVICE_LOAD_ID.COUNT
		INSERT INTO SERVICE_LOAD(SERVICE_ID, SERVICE_CODE, LOAD_DATE, LOAD_CODE, LOAD_VAL, TX_LOSS_VAL, DX_LOSS_VAL, UE_LOSS_VAL)
		VALUES (g_SERVICE_LOAD_ID(v_INDEX), p_CAST_CONTEXT.SERVICE_CODE, g_SERVICE_LOAD_DATE(v_INDEX), v_LOAD_CODE,
			g_SERVICE_LOAD_VAL(v_INDEX),
			g_SERVICE_LOAD_TX_LOSS_VAL(v_INDEX),
			g_SERVICE_LOAD_DX_LOSS_VAL(v_INDEX),
			g_SERVICE_LOAD_UE_LOSS_VAL(v_INDEX));

	LOGS.LOG_DEBUG('STORE_SERVICE_LOAD ELAPSED TIME='  || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED) || ', COUNT=' || TO_CHAR(g_SERVICE_LOAD_ID.COUNT));

END STORE_SERVICE_LOAD;
----------------------------------------------------------------------------------------------------
PROCEDURE STORE_SERVICE_OBLIGATION_LOAD
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_OVERRIDE_ACCUMULATE_SOB_LOAD IN BOOLEAN DEFAULT FALSE
	) AS

v_INDEX BINARY_INTEGER;
v_LOAD_CODE CHAR(1);
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;

BEGIN

	IF p_CAST_CONTEXT.ACCUMULATE_SOB_LOAD = 0 AND NOT p_OVERRIDE_ACCUMULATE_SOB_LOAD THEN
		RETURN;
	END IF;

	IF p_CAST_CONTEXT.RUN_MODE IN (GA.MONTH_MODE, GA.WEEK_MODE) THEN
		v_LOAD_CODE := p_CAST_CONTEXT.DAY_TYPE;
	ELSE
		v_LOAD_CODE := GA.STANDARD;
	END IF;

	FORALL v_INDEX IN 1..g_SOB_LOAD_ID.COUNT
		INSERT INTO SERVICE_OBLIGATION_LOAD(SERVICE_OBLIGATION_ID, SERVICE_CODE, LOAD_DATE, LOAD_CODE, LOAD_VAL, TX_LOSS_VAL, DX_LOSS_VAL, AGG_LOAD_VAL, AGG_TX_LOSS_VAL, AGG_DX_LOSS_VAL, UFE_LOAD_VAL)
		VALUES (g_SOB_LOAD_ID(v_INDEX), p_CAST_CONTEXT.SERVICE_CODE, g_SOB_LOAD_DATE(v_INDEX), v_LOAD_CODE,
			g_SOB_LOAD_VAL(v_INDEX) / p_CAST_CONTEXT.SYSTEM_UNITS,
			g_SOB_TX_LOSS_VAL(v_INDEX) / p_CAST_CONTEXT.SYSTEM_UNITS,
			g_SOB_DX_LOSS_VAL(v_INDEX) / p_CAST_CONTEXT.SYSTEM_UNITS,
			g_SOB_AGG_LOAD_VAL(v_INDEX) / p_CAST_CONTEXT.SYSTEM_UNITS,
			g_SOB_AGG_TX_LOSS_VAL(v_INDEX) / p_CAST_CONTEXT.SYSTEM_UNITS,
			g_SOB_AGG_DX_LOSS_VAL(v_INDEX) / p_CAST_CONTEXT.SYSTEM_UNITS,
			NVL(g_SOB_UE_LOSS_VAL(v_INDEX),0) / p_CAST_CONTEXT.SYSTEM_UNITS);

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('STORE_SERVICE_OBLIGATION_LOAD ELAPSED TIME='  || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED) || ', COUNT=' || TO_CHAR(g_SOB_LOAD_ID.COUNT));
	END IF;

END STORE_SERVICE_OBLIGATION_LOAD;
----------------------------------------------------------------------------------------------------
PROCEDURE FETCH_ACTUAL_SERVICE
	(
	p_MODEL_ID IN NUMBER,
	p_SERVICE_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_LOAD_DATE IN OUT NOCOPY GA.DATE_TABLE,
	p_LOAD_VAL IN OUT NOCOPY GA.FLOAT_TABLE
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_INDEX BINARY_INTEGER;
v_SERVICE_USAGE SERVICE_USAGE_TABLE := SERVICE_USAGE_TABLE();

BEGIN

	UT.CUT_DATE_RANGE(p_MODEL_ID, p_SERVICE_DATE, LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	p_LOAD_DATE.DELETE;
	p_LOAD_VAL.DELETE;

	SELECT SERVICE_USAGE_TYPE(A.SERVICE_ID, A.SERVICE_CODE, A.LOAD_DATE, A.LOAD_VAL)
	BULK COLLECT INTO v_SERVICE_USAGE
	FROM SERVICE_LOAD A
	WHERE A.SERVICE_ID = p_SERVICE_ID
		AND A.SERVICE_CODE = GA.ACTUAL_SERVICE
		AND A.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND A.LOAD_CODE = GA.STANDARD
	ORDER BY A.LOAD_DATE;

	IF v_SERVICE_USAGE.COUNT > 0 THEN
		v_INDEX := v_SERVICE_USAGE.FIRST;
		WHILE v_INDEX <= v_SERVICE_USAGE.LAST LOOP
			p_LOAD_DATE(p_LOAD_DATE.COUNT + 1) := v_SERVICE_USAGE(v_INDEX).USAGE_DATE;
			p_LOAD_VAL(p_LOAD_VAL.COUNT + 1) := v_SERVICE_USAGE(v_INDEX).USAGE_VAL;
			v_INDEX := v_SERVICE_USAGE.NEXT(v_INDEX);
		END LOOP;
	END IF;

END FETCH_ACTUAL_SERVICE;
----------------------------------------------------------------------------------------------------
PROCEDURE STORE_ACTUAL_SERVICE_LOSSES
	(
	p_SERVICE_ID IN NUMBER,
	p_LOAD_DATE IN GA.DATE_TABLE,
	p_TX_LOSS IN GA.FACTOR_TABLE,
	p_DX_LOSS IN GA.FACTOR_TABLE,
	p_UE_LOSS IN GA.FACTOR_TABLE
	) AS

v_INDEX BINARY_INTEGER;

BEGIN

	FORALL v_INDEX IN 1..p_LOAD_DATE.COUNT
		UPDATE SERVICE_LOAD SET TX_LOSS_VAL = p_TX_LOSS(v_INDEX), DX_LOSS_VAL = p_DX_LOSS(v_INDEX), UE_LOSS_VAL = p_UE_LOSS(v_INDEX)
		WHERE SERVICE_ID = p_SERVICE_ID
			AND SERVICE_CODE = GA.ACTUAL_SERVICE
			AND LOAD_DATE = p_LOAD_DATE(v_INDEX)
			AND LOAD_CODE = GA.STANDARD;

END STORE_ACTUAL_SERVICE_LOSSES;
----------------------------------------------------------------------------------------------------
PROCEDURE APPLY_ACTUAL_SERVICE_LOSSES
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE
	) AS

v_SERVICE_DATE DATE;
v_LOAD_DATE GA.DATE_TABLE;
v_LOAD_VAL GA.FLOAT_TABLE;
v_TX_LOSS GA.FACTOR_TABLE;
v_DX_LOSS GA.FACTOR_TABLE;
v_UE_LOSS GA.FACTOR_TABLE;
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;

CURSOR c_SERVICE IS
	SELECT DISTINCT A.SERVICE_ID, C.ACCOUNT_SERVICE_ID, B.EDC_ID
	FROM SERVICE A, PROVIDER_SERVICE B, ACCOUNT_SERVICE C
	WHERE A.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
		AND A.SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
		AND A.AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE
		AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
		AND A.ACCOUNT_SERVICE_ID = C.ACCOUNT_SERVICE_ID
		AND C.AGGREGATE_ID = 0
	ORDER BY 1;

BEGIN

	FOR v_SERVICE IN c_SERVICE LOOP
		v_SERVICE_DATE := p_CAST_CONTEXT.BEGIN_DATE;
		WHILE v_SERVICE_DATE <= p_CAST_CONTEXT.END_DATE LOOP
			FETCH_ACTUAL_SERVICE(p_CAST_CONTEXT.MODEL_ID, v_SERVICE.SERVICE_ID, v_SERVICE_DATE, v_LOAD_DATE, v_LOAD_VAL);
			IF v_LOAD_DATE.COUNT > 0 THEN
				APPLY_LOSS_FACTORS(v_SERVICE.ACCOUNT_SERVICE_ID, v_SERVICE.EDC_ID, v_SERVICE_DATE, v_LOAD_VAL, v_TX_LOSS, v_DX_LOSS, v_UE_LOSS, TRUE);
				STORE_ACTUAL_SERVICE_LOSSES(v_SERVICE.SERVICE_ID, v_LOAD_DATE, v_TX_LOSS, v_DX_LOSS, v_UE_LOSS);
			END IF;
			v_SERVICE_DATE := v_SERVICE_DATE + 1;
		END LOOP;
	END LOOP;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('APPLY_ACTUAL_SERVICE_LOSSES ELAPSED TIME='  || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED));
	END IF;

END APPLY_ACTUAL_SERVICE_LOSSES;
----------------------------------------------------------------------------------------------------
PROCEDURE DELETE_SERVICE_OBLIGATION_LOAD
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_ELASPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;

BEGIN

	UT.CUT_DATE_RANGE(p_CAST_CONTEXT.MODEL_ID, p_CAST_CONTEXT.BEGIN_DATE, p_CAST_CONTEXT.END_DATE, LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

--@@Begin Implementation Override --
   IF l_ENABLE_SERVICE_PARTITIONING AND p_CAST_CONTEXT.EDC_ID = g_ALL AND p_CAST_CONTEXT.ESP_ID = g_ALL AND p_CAST_CONTEXT.ACCOUNT_ID = g_ALL THEN
      TRUNCATE_TABLESPACE('SERVICE_OBLIGATION_LOAD', p_CAST_CONTEXT.BEGIN_DATE, p_CAST_CONTEXT.END_DATE, p_CAST_CONTEXT.REQUEST_TYPE);
      RETURN;
   END IF;
--@@End Implementation Override --

	DELETE SERVICE_OBLIGATION_LOAD X
	WHERE EXISTS
		(SELECT 1
		FROM SERVICE_OBLIGATION SO,
			PROVIDER_SERVICE PS
		WHERE SO.SERVICE_OBLIGATION_ID = X.SERVICE_OBLIGATION_ID
			AND SO.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
			AND SO.SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
			AND SO.AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE
			AND SO.PROVIDER_SERVICE_ID = PS.PROVIDER_SERVICE_ID
			AND (PS.EDC_ID = p_CAST_CONTEXT.EDC_ID OR p_CAST_CONTEXT.EDC_ID = g_ALL)
			AND (PS.ESP_ID = p_CAST_CONTEXT.ESP_ID OR p_CAST_CONTEXT.ESP_ID = g_ALL))
		AND X.SERVICE_CODE = p_CAST_CONTEXT.SERVICE_CODE
		AND X.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('DELETE_SERVICE_OBLIGATION_LOAD ELAPSED TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELASPSED));
	END IF;

END DELETE_SERVICE_OBLIGATION_LOAD;
----------------------------------------------------------------------------------------------------
PROCEDURE DELETE_SVC_OBLIGATION_ANC_SVC
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_ANCILLARY_SERVICE_ID IN NUMBER
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_ELASPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;

BEGIN

	UT.CUT_DATE_RANGE(p_CAST_CONTEXT.MODEL_ID, p_CAST_CONTEXT.BEGIN_DATE, p_CAST_CONTEXT.END_DATE, LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	DELETE SERVICE_OBLIGATION_ANC_SVC X
	WHERE EXISTS
		(SELECT 1
		FROM SERVICE_OBLIGATION
		WHERE SERVICE_OBLIGATION_ID = X.SERVICE_OBLIGATION_ID
			AND MODEL_ID = p_CAST_CONTEXT.MODEL_ID
			AND SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
			AND AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE)
		AND X.ANCILLARY_SERVICE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND X.ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('DELETE_SERVICE_OBLIGATION_ANC_SVC ELAPSED TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELASPSED));
	END IF;

END DELETE_SVC_OBLIGATION_ANC_SVC;
----------------------------------------------------------------------------------------------------
PROCEDURE DELETE_EDC_SYSTEM_UFE_LOAD
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_ELASPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;

BEGIN

	UT.CUT_DATE_RANGE(p_CAST_CONTEXT.MODEL_ID, p_CAST_CONTEXT.BEGIN_DATE, p_CAST_CONTEXT.END_DATE, LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	DELETE EDC_SYSTEM_UFE_LOAD
	WHERE MODEL_ID = p_CAST_CONTEXT.MODEL_ID
		AND SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
		AND AS_OF_DATE  = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE
		AND SERVICE_CODE = p_CAST_CONTEXT.SERVICE_CODE
		AND LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND (p_CAST_CONTEXT.EDC_ID = g_ALL OR EDC_ID = p_CAST_CONTEXT.EDC_ID);

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('DELETE_EDC_SYSTEM_UFE_LOAD ELAPSED TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELASPSED));
	END IF;

END DELETE_EDC_SYSTEM_UFE_LOAD;
----------------------------------------------------------------------------------------------------
PROCEDURE SET_EDC_SYSTEM_UFE_LOAD
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	) AS

-- Insert the total and ufe forecast, backcast, or usage rolled up by EDC and date of service.
-- Note that p_BEGIN_DATE and p_END_DATE are CUT dates.

v_ELAPSED_TIME PLS_INTEGER := DBMS_UTILITY.GET_TIME;

BEGIN

	INSERT INTO EDC_SYSTEM_UFE_LOAD(MODEL_ID, SCENARIO_ID, AS_OF_DATE, SERVICE_CODE, LOAD_DATE, LOAD_CODE, EDC_ID, UFE_SERVICE_LOAD, UFE_PARTICIPANT_LOAD)
	SELECT B.MODEL_ID, B.SCENARIO_ID, B.AS_OF_DATE, C.SERVICE_CODE, C.LOAD_DATE, C.LOAD_CODE, A.EDC_ID, SUM(C.LOAD_VAL + C.TX_LOSS_VAL + C.DX_LOSS_VAL), SUM(C.UFE_LOAD_VAL)
	FROM PROVIDER_SERVICE A, SERVICE_OBLIGATION B, SERVICE_OBLIGATION_LOAD C
	WHERE (p_CAST_CONTEXT.EDC_ID = g_ALL OR A.EDC_ID = p_CAST_CONTEXT.EDC_ID)
		AND B.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
		AND B.SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
		AND B.AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE
		AND B.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
		AND C.SERVICE_OBLIGATION_ID = B.SERVICE_OBLIGATION_ID
		AND C.SERVICE_CODE = p_CAST_CONTEXT.SERVICE_CODE
		AND C.LOAD_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
	GROUP BY B.MODEL_ID, B.SCENARIO_ID, B.AS_OF_DATE, C.SERVICE_CODE, C.LOAD_DATE, C.LOAD_CODE, A.EDC_ID;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('SET_EDC_SYSTEM_UFE_LOAD ELAPSED TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED_TIME));
	END IF;

END SET_EDC_SYSTEM_UFE_LOAD;
----------------------------------------------------------------------------------------------------
PROCEDURE SET_EDC_SYSTEM_AREA_LOAD
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	) AS

-- Update the system area load by edc and begin and end date range.
-- Note that p_BEGIN_DATE and p_END_DATE are CUT dates.

CURSOR c_LOAD_CHECK IS
	SELECT B.SYSTEM_LOAD_NAME, B.SYSTEM_LOAD_ID, TRUNC(FROM_CUT(C.LOAD_DATE, LOCAL_TIME_ZONE)) "LOAD_DATE", COUNT(1) "MISSING"
	FROM ENERGY_DISTRIBUTION_COMPANY A, SYSTEM_LOAD B, EDC_SYSTEM_UFE_LOAD C
	WHERE (p_CAST_CONTEXT.EDC_ID = g_ALL OR A.EDC_ID = p_CAST_CONTEXT.EDC_ID)
		AND B.SYSTEM_LOAD_ID = A.EDC_SYSTEM_LOAD_ID
		AND C.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
		AND C.SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
		AND C.AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE
		AND C.SERVICE_CODE = p_CAST_CONTEXT.SERVICE_CODE
		AND C.LOAD_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
		AND C.LOAD_CODE = p_CAST_CONTEXT.LOAD_CODE
		AND C.EDC_ID = A.EDC_ID
		AND C.UFE_SYSTEM_LOAD IS NULL
	GROUP BY B.SYSTEM_LOAD_NAME, B.SYSTEM_LOAD_ID, TRUNC(FROM_CUT(C.LOAD_DATE, LOCAL_TIME_ZONE))
	ORDER BY 1,3;

v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;

BEGIN

	IF GA.VERSION_AREA_LOAD THEN
		UPDATE EDC_SYSTEM_UFE_LOAD X
		SET X.UFE_SYSTEM_LOAD =
			(SELECT SUM(C.LOAD_VAL * DECODE(B.OPERATION_CODE,'A',1.0,'S',-1.0,1.0))
			FROM ENERGY_DISTRIBUTION_COMPANY A, SYSTEM_LOAD_AREA B, AREA_LOAD C
			WHERE A.EDC_ID = X.EDC_ID
				AND B.SYSTEM_LOAD_ID = A.EDC_SYSTEM_LOAD_ID
				AND C.CASE_ID = p_CAST_CONTEXT.AREA_LOAD_CASE_ID
				AND C.AREA_ID = B.AREA_ID
				AND C.LOAD_CODE = p_CAST_CONTEXT.SYSTEM_LOAD_CODE
				AND C.LOAD_DATE = X.LOAD_DATE
				AND C.AS_OF_DATE =
					(SELECT AS_OF_DATE
					FROM AREA_LOAD
					WHERE AREA_ID = C.AREA_ID
						AND LOAD_CODE = C.LOAD_CODE
						AND LOAD_DATE = C.LOAD_DATE
						AND AS_OF_DATE <= p_CAST_CONTEXT.INPUT_AS_OF_DATE))
		WHERE X.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
			AND X.SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
			AND X.AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE
			AND X.SERVICE_CODE = p_CAST_CONTEXT.SERVICE_CODE
			AND X.LOAD_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
			AND X.LOAD_CODE = p_CAST_CONTEXT.LOAD_CODE
			AND (p_CAST_CONTEXT.EDC_ID = g_ALL OR X.EDC_ID = p_CAST_CONTEXT.EDC_ID);
	ELSE
		UPDATE EDC_SYSTEM_UFE_LOAD X
		SET X.UFE_SYSTEM_LOAD =
			(SELECT SUM(C.LOAD_VAL * DECODE(B.OPERATION_CODE,'A',1.0,'S',-1.0,1.0))
			FROM ENERGY_DISTRIBUTION_COMPANY A, SYSTEM_LOAD_AREA B, AREA_LOAD C
			WHERE A.EDC_ID = X.EDC_ID
				AND B.SYSTEM_LOAD_ID = A.EDC_SYSTEM_LOAD_ID
				AND C.CASE_ID = p_CAST_CONTEXT.AREA_LOAD_CASE_ID
				AND C.AREA_ID = B.AREA_ID
				AND C.LOAD_CODE = p_CAST_CONTEXT.SYSTEM_LOAD_CODE
				AND C.LOAD_DATE = X.LOAD_DATE
				AND C.AS_OF_DATE = LOW_DATE)
		WHERE X.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
			AND X.SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
			AND X.AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE
			AND X.SERVICE_CODE = p_CAST_CONTEXT.SERVICE_CODE
			AND X.LOAD_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
			AND X.LOAD_CODE = p_CAST_CONTEXT.LOAD_CODE
			AND (p_CAST_CONTEXT.EDC_ID = g_ALL OR X.EDC_ID = p_CAST_CONTEXT.EDC_ID);
	END IF;

	IF GA.ENABLE_SYSTEM_UFE_LOAD_CHECK THEN
		FOR v_LOAD_CHECK IN c_LOAD_CHECK LOOP
			LOGS.LOG_ERROR('Missing System Area Load Values for ' || v_LOAD_CHECK.SYSTEM_LOAD_NAME || ' on ' || TO_CHAR(v_LOAD_CHECK.LOAD_DATE,'MM-DD-YYYY'));
		END LOOP;
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('SET_EDC_SYSTEM_AREA_LOAD ELAPSED TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED));
	END IF;

END SET_EDC_SYSTEM_AREA_LOAD;
----------------------------------------------------------------------------------------------------
PROCEDURE SET_SERVICE_OBLIGATION_UFE
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	) AS

-- Update the retail load ufe by edc and begin and end date range.
-- Note that p_BEGIN_DATE and p_END_DATE are CUT dates.

v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;

BEGIN

	IF NOT p_CAST_CONTEXT.APPLY_UFE_CODE = 0 THEN
		UPDATE SERVICE_OBLIGATION_LOAD X
		SET X.UFE_LOAD_VAL =
			(SELECT NVL(A.UFE_LOAD_VAL,0)
			FROM
				(SELECT B.SERVICE_OBLIGATION_ID, C.SERVICE_CODE, C.LOAD_DATE, C.LOAD_CODE, ROUND(NVL(C.UFE_LOAD_VAL / DECODE(D.UFE_PARTICIPANT_LOAD, 0, NULL, D.UFE_PARTICIPANT_LOAD) * (D.UFE_SYSTEM_LOAD - D.UFE_SERVICE_LOAD),0),6) "UFE_LOAD_VAL"
				FROM PROVIDER_SERVICE A, SERVICE_OBLIGATION B, SERVICE_OBLIGATION_LOAD C, EDC_SYSTEM_UFE_LOAD D
				WHERE (p_CAST_CONTEXT.EDC_ID = g_ALL OR A.EDC_ID = p_CAST_CONTEXT.EDC_ID)
					AND B.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
					AND B.SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
					AND B.AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE
					AND B.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
					AND C.SERVICE_OBLIGATION_ID = B.SERVICE_OBLIGATION_ID
					AND C.SERVICE_CODE = p_CAST_CONTEXT.SERVICE_CODE
					AND C.LOAD_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
					AND C.LOAD_CODE = p_CAST_CONTEXT.LOAD_CODE
					AND D.MODEL_ID = B.MODEL_ID
					AND D.SCENARIO_ID = B.SCENARIO_ID
					AND D.AS_OF_DATE = B.AS_OF_DATE
					AND D.SERVICE_CODE = C.SERVICE_CODE
					AND D.LOAD_DATE = C.LOAD_DATE
					AND D.LOAD_CODE = C.LOAD_CODE
					AND D.EDC_ID = A.EDC_ID) A
		WHERE X.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
			AND X.SERVICE_CODE = A.SERVICE_CODE
			AND X.LOAD_DATE = A.LOAD_DATE
			AND X.LOAD_CODE = A.LOAD_CODE)
	WHERE X.SERVICE_OBLIGATION_ID IN (SELECT DISTINCT SERVICE_OBLIGATION_ID FROM SERVICE_OBLIGATION WHERE MODEL_ID = p_CAST_CONTEXT.MODEL_ID AND SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID AND AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE)
		AND X.SERVICE_CODE = p_CAST_CONTEXT.SERVICE_CODE
		AND X.LOAD_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
		AND X.LOAD_CODE = p_CAST_CONTEXT.LOAD_CODE;
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('SET_SERVICE_OBLIGATION_UFE ELAPSED TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED));
	END IF;

END SET_SERVICE_OBLIGATION_UFE;
----------------------------------------------------------------------------------------------------
PROCEDURE SET_SERVICE_OBLIGATION_LOAD
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_SERVICE_DATE IN DATE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	) AS

-- Note that p_BEGIN_DATE and p_END_DATE are CUT dates.

v_APPLY_UFE NUMBER(1);
v_INDEX BINARY_INTEGER;
v_SOB_INDEX BINARY_INTEGER := 0;
v_SERVICE_OBLIGATION_LOAD SERVICE_OBLIGATION_LOAD_TABLE := SERVICE_OBLIGATION_LOAD_TABLE();
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;

BEGIN

	IF p_CAST_CONTEXT.ACCUMULATE_SOB_LOAD = 1 THEN
		RETURN;
	END IF;

	IF p_CAST_CONTEXT.INCUMBENT_TYPE = 'EDC' THEN
		SELECT DECODE(p_CAST_CONTEXT.APPLY_UFE_CODE,0,0,1) INTO v_APPLY_UFE FROM DUAL;
	ELSE
		v_APPLY_UFE := 2;
	END IF;


	SELECT /* ORDERED USE_NL(A,B) USE_NL(B,C) USE_NL(C,D) INDEX(B) INDEX(C) INDEX(D) */
	  SERVICE_OBLIGATION_LOAD_TYPE(
		A.SERVICE_OBLIGATION_ID,
		D.LOAD_DATE,
		SUM(D.LOAD_VAL),
		SUM(D.TX_LOSS_VAL),
		SUM(D.DX_LOSS_VAL),
		SUM(DECODE(C.IS_AGGREGATE_ACCOUNT, 1, D.LOAD_VAL, 0)),
		SUM(DECODE(C.IS_AGGREGATE_ACCOUNT, 1, D.TX_LOSS_VAL, 0)),
		SUM(DECODE(C.IS_AGGREGATE_ACCOUNT, 1, D.DX_LOSS_VAL, 0)),
		SUM(DECODE(v_APPLY_UFE, 0, 0, 1, DECODE(C.IS_UFE_PARTICIPANT,1, D.LOAD_VAL + D.TX_LOSS_VAL + D.DX_LOSS_VAL, 0), 2, D.UE_LOSS_VAL, 0)))
	BULK COLLECT INTO v_SERVICE_OBLIGATION_LOAD
	FROM SERVICE_OBLIGATION A, SERVICE B, SERVICE_STATE C, SERVICE_LOAD D, PROVIDER_SERVICE PS
	WHERE A.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
		AND A.SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
		AND A.AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE
		AND B.MODEL_ID = A.MODEL_ID
		AND B.SCENARIO_ID = A.SCENARIO_ID
		AND B.AS_OF_DATE = A.AS_OF_DATE
		AND B.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
		AND B.SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
		AND C.SERVICE_ID = B.SERVICE_ID
		AND C.SERVICE_CODE = p_CAST_CONTEXT.SERVICE_CODE
		AND C.SERVICE_DATE = p_SERVICE_DATE
		AND C.IS_AGGREGATE_POOL = CONSTANTS.NOT_ASSIGNED
		AND D.SERVICE_ID = C.SERVICE_ID
		AND D.SERVICE_CODE = C.SERVICE_CODE
		AND D.LOAD_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
		AND D.LOAD_CODE = p_CAST_CONTEXT.LOAD_CODE
        AND PS.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
        AND (PS.EDC_ID = p_CAST_CONTEXT.EDC_ID OR p_CAST_CONTEXT.EDC_ID = g_ALL)
		AND (PS.ESP_ID = p_CAST_CONTEXT.ESP_ID OR p_CAST_CONTEXT.ESP_ID = g_ALL)
	GROUP BY A.SERVICE_OBLIGATION_ID, D.LOAD_DATE;

	INITIALIZE_SOB_LOAD;

	v_INDEX := v_SERVICE_OBLIGATION_LOAD.FIRST;
	WHILE v_INDEX <= v_SERVICE_OBLIGATION_LOAD.LAST LOOP
		v_SOB_INDEX := v_SOB_INDEX + 1;
		g_SOB_LOAD_ID(v_SOB_INDEX) := v_SERVICE_OBLIGATION_LOAD(v_INDEX).SERVICE_OBLIGATION_ID;
		g_SOB_LOAD_DATE(v_SOB_INDEX) := v_SERVICE_OBLIGATION_LOAD(v_INDEX).LOAD_DATE;
		g_SOB_LOAD_VAL(v_SOB_INDEX) := v_SERVICE_OBLIGATION_LOAD(v_INDEX).LOAD_VAL;
		g_SOB_TX_LOSS_VAL(v_SOB_INDEX) := v_SERVICE_OBLIGATION_LOAD(v_INDEX).TX_LOSS_VAL;
		g_SOB_DX_LOSS_VAL(v_SOB_INDEX) := v_SERVICE_OBLIGATION_LOAD(v_INDEX).DX_LOSS_VAL;
		g_SOB_AGG_LOAD_VAL(v_SOB_INDEX) := v_SERVICE_OBLIGATION_LOAD(v_INDEX).AGG_LOAD_VAL;
		g_SOB_AGG_TX_LOSS_VAL(v_SOB_INDEX) := v_SERVICE_OBLIGATION_LOAD(v_INDEX).AGG_TX_LOSS_VAL;
		g_SOB_AGG_DX_LOSS_VAL(v_SOB_INDEX) := v_SERVICE_OBLIGATION_LOAD(v_INDEX).AGG_DX_LOSS_VAL;
		g_SOB_UE_LOSS_VAL(v_SOB_INDEX) := v_SERVICE_OBLIGATION_LOAD(v_INDEX).UFE_LOAD_VAL;
		v_INDEX := v_SERVICE_OBLIGATION_LOAD.NEXT(v_INDEX);
	END LOOP;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('SET_SERVICE_OBLIGATION_LOAD ELAPSED TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED) || ', COUNT=' || TO_CHAR(v_SERVICE_OBLIGATION_LOAD.COUNT));
	END IF;

	STORE_SERVICE_OBLIGATION_LOAD(p_CAST_CONTEXT, TRUE);

END SET_SERVICE_OBLIGATION_LOAD;
----------------------------------------------------------------------------------------------------
PROCEDURE SET_AGG_POOL_SERVICE_LOAD
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_SERVICE_DATE IN DATE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	) AS

-- Note that p_BEGIN_DATE and p_END_DATE are CUT dates.

v_APPLY_UFE NUMBER(1);
v_SECOND NUMBER(6,5);
v_INDEX BINARY_INTEGER;
v_SOB_INDEX BINARY_INTEGER := 0;
v_SERVICE_OBLIGATION_LOAD SERVICE_OBLIGATION_LOAD_TABLE := SERVICE_OBLIGATION_LOAD_TABLE();
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;

BEGIN

	IF p_CAST_CONTEXT.ACCUMULATE_SOB_LOAD = 1 THEN
		-- NO NEED TO GENERATE THIS SINCEITS BEEN ACCUMULATED AS WE
		-- FOUND SERVICE_LOAD
		RETURN;
	END IF;

	IF p_CAST_CONTEXT.INCUMBENT_TYPE = 'EDC' THEN
		SELECT DECODE(p_CAST_CONTEXT.APPLY_UFE_CODE,0,0,1) INTO v_APPLY_UFE FROM DUAL;
	ELSE
		v_APPLY_UFE := 2;
	END IF;

	SELECT DECODE(p_CAST_CONTEXT.MODEL_ID, GA.ELECTRIC_MODEL, g_SECOND, CONSTANTS.NOT_ASSIGNED) INTO v_SECOND FROM DUAL;

	SELECT SERVICE_OBLIGATION_LOAD_TYPE(A.SERVICE_OBLIGATION_ID, Q.LOAD_DATE,
		Q.LOAD_VAL * D.ALLOCATION_PCT * E.ALLOCATION_PCT / 10000.0,
		Q.TX_LOSS_VAL * D.ALLOCATION_PCT * E.ALLOCATION_PCT / 10000.0,
		Q.DX_LOSS_VAL * D.ALLOCATION_PCT * E.ALLOCATION_PCT / 10000.0,
		Q.AGG_LOAD_VAL * D.ALLOCATION_PCT * E.ALLOCATION_PCT / 10000.0,
		Q.AGG_TX_LOSS_VAL * D.ALLOCATION_PCT * E.ALLOCATION_PCT / 10000.0,
		Q.AGG_DX_LOSS_VAL * D.ALLOCATION_PCT * E.ALLOCATION_PCT / 10000.0,
		Q.UFE_LOAD_VAL * D.ALLOCATION_PCT * E.ALLOCATION_PCT / 10000.0)
	BULK COLLECT INTO v_SERVICE_OBLIGATION_LOAD
	FROM (SELECT B.POOL_ID,
			D.LOAD_DATE,
			SUM(D.LOAD_VAL) "LOAD_VAL",
			SUM(D.TX_LOSS_VAL) "TX_LOSS_VAL",
			SUM(D.DX_LOSS_VAL) "DX_LOSS_VAL",
			SUM(DECODE(C.IS_AGGREGATE_ACCOUNT, 1, D.LOAD_VAL, 0)) "AGG_LOAD_VAL",
			SUM(DECODE(C.IS_AGGREGATE_ACCOUNT, 1, D.TX_LOSS_VAL, 0)) "AGG_TX_LOSS_VAL",
			SUM(DECODE(C.IS_AGGREGATE_ACCOUNT, 1, D.DX_LOSS_VAL, 0)) "AGG_DX_LOSS_VAL",
			SUM(DECODE(v_APPLY_UFE, 0, 0, 1, DECODE(C.IS_UFE_PARTICIPANT,1, D.LOAD_VAL + D.TX_LOSS_VAL + D.DX_LOSS_VAL, 0), 2, D.UE_LOSS_VAL, 0)) "UFE_LOAD_VAL"
		FROM SERVICE A, SERVICE_DELIVERY B, SERVICE_STATE C, SERVICE_LOAD D
		WHERE A.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
			AND A.SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
			AND A.AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE
			AND A.SERVICE_DELIVERY_ID = B.SERVICE_DELIVERY_ID
			AND C.SERVICE_ID = A.SERVICE_ID
			AND C.SERVICE_CODE = p_CAST_CONTEXT.SERVICE_CODE
			AND C.SERVICE_DATE = p_SERVICE_DATE
			AND C.IS_AGGREGATE_POOL = g_ON
			AND D.SERVICE_ID = C.SERVICE_ID
			AND D.SERVICE_CODE = C.SERVICE_CODE
			AND D.LOAD_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
			AND TRUNC(FROM_CUT(D.LOAD_DATE, LOCAL_TIME_ZONE) - v_SECOND) = C.SERVICE_DATE
		GROUP BY B.POOL_ID, D.LOAD_DATE) Q,
		SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, ESP_POOL D, POOL_SUB_POOL E
	WHERE A.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
		AND A.SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
		AND A.AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE
		AND A.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
		AND A.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
		AND C.IS_AGGREGATE_POOL = g_ON
		AND D.ESP_ID = B.ESP_ID
		AND D.POOL_ID = C.POOL_ID
		AND p_CAST_CONTEXT.SERVICE_DATE BETWEEN D.BEGIN_DATE AND NVL(D.END_DATE, p_CAST_CONTEXT.SERVICE_DATE)
        AND E.SUB_POOL_ID = D.POOL_ID
		AND p_CAST_CONTEXT.SERVICE_DATE BETWEEN E.BEGIN_DATE AND NVL(E.END_DATE, p_CAST_CONTEXT.SERVICE_DATE)
		AND Q.POOL_ID = E.POOL_ID;

	INITIALIZE_SOB_LOAD;

	v_INDEX := v_SERVICE_OBLIGATION_LOAD.FIRST;
	WHILE v_INDEX <= v_SERVICE_OBLIGATION_LOAD.LAST LOOP
		v_SOB_INDEX := v_SOB_INDEX + 1;
		g_SOB_LOAD_ID(v_SOB_INDEX) := v_SERVICE_OBLIGATION_LOAD(v_INDEX).SERVICE_OBLIGATION_ID;
		g_SOB_LOAD_DATE(v_SOB_INDEX) := v_SERVICE_OBLIGATION_LOAD(v_INDEX).LOAD_DATE;
		g_SOB_LOAD_VAL(v_SOB_INDEX) := v_SERVICE_OBLIGATION_LOAD(v_INDEX).LOAD_VAL;
		g_SOB_TX_LOSS_VAL(v_SOB_INDEX) := v_SERVICE_OBLIGATION_LOAD(v_INDEX).TX_LOSS_VAL;
		g_SOB_DX_LOSS_VAL(v_SOB_INDEX) := v_SERVICE_OBLIGATION_LOAD(v_INDEX).DX_LOSS_VAL;
		g_SOB_AGG_LOAD_VAL(v_SOB_INDEX) := v_SERVICE_OBLIGATION_LOAD(v_INDEX).AGG_LOAD_VAL;
		g_SOB_AGG_TX_LOSS_VAL(v_SOB_INDEX) := v_SERVICE_OBLIGATION_LOAD(v_INDEX).AGG_TX_LOSS_VAL;
		g_SOB_AGG_DX_LOSS_VAL(v_SOB_INDEX) := v_SERVICE_OBLIGATION_LOAD(v_INDEX).AGG_DX_LOSS_VAL;
		g_SOB_UE_LOSS_VAL(v_SOB_INDEX) := v_SERVICE_OBLIGATION_LOAD(v_INDEX).UFE_LOAD_VAL;
		v_INDEX := v_SERVICE_OBLIGATION_LOAD.NEXT(v_INDEX);
	END LOOP;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('SET_AGG_POOL_SERVICE_LOAD ELAPSED TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED) || ', COUNT=' || TO_CHAR(v_SERVICE_OBLIGATION_LOAD.COUNT));
	END IF;

	STORE_SERVICE_OBLIGATION_LOAD(p_CAST_CONTEXT, TRUE);

END SET_AGG_POOL_SERVICE_LOAD;
----------------------------------------------------------------------------------------------------
PROCEDURE SET_SERVICE_OBLIGATION_DAY
	(
	p_CAST_CONTEXT IN OUT NOCOPY CAST_CONTEXT_TYPE
	) AS

-- Create the EDC and Provider Load summary for the specified context.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;

BEGIN

	UT.CUT_DATE_RANGE(p_CAST_CONTEXT.MODEL_ID, p_CAST_CONTEXT.SERVICE_DATE, p_CAST_CONTEXT.SERVICE_DATE, LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

--RUN ONCE FOR WEEKDAY, AND ONCE FOR WEEKEND.
   	IF p_CAST_CONTEXT.RUN_MODE IN (GA.WEEK_MODE, GA.MONTH_MODE) AND p_CAST_CONTEXT.SCENARIO_USE_DAY_TYPE = 1 THEN
		   	  p_CAST_CONTEXT.DAY_TYPE := GA.WEEK_DAY;
			  p_CAST_CONTEXT.LOAD_CODE := GA.WEEK_DAY;
			  SET_SERVICE_OBLIGATION_LOAD(p_CAST_CONTEXT, p_CAST_CONTEXT.SERVICE_DATE, v_BEGIN_DATE, v_END_DATE);
			  p_CAST_CONTEXT.DAY_TYPE := GA.WEEK_END;
			  p_CAST_CONTEXT.LOAD_CODE := GA.WEEK_END;
   	END IF;

	SET_SERVICE_OBLIGATION_LOAD(p_CAST_CONTEXT, p_CAST_CONTEXT.SERVICE_DATE, v_BEGIN_DATE, v_END_DATE);

	IF GA.ENABLE_AGGREGATE_POOL_MODEL THEN
		SET_AGG_POOL_SERVICE_LOAD(p_CAST_CONTEXT, p_CAST_CONTEXT.SERVICE_DATE, v_BEGIN_DATE, v_END_DATE);
	END IF;

	SET_EDC_SYSTEM_UFE_LOAD(p_CAST_CONTEXT, v_BEGIN_DATE, v_END_DATE);

	IF p_CAST_CONTEXT.INCUMBENT_TYPE = 'EDC' THEN
		SET_EDC_SYSTEM_AREA_LOAD(p_CAST_CONTEXT, v_BEGIN_DATE, v_END_DATE);
		SET_SERVICE_OBLIGATION_UFE(p_CAST_CONTEXT, v_BEGIN_DATE, v_END_DATE);
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('SET_SERVICE_OBLIGATION_DAY FOR ' || TO_CHAR(p_CAST_CONTEXT.SERVICE_DATE) || ' ELAPSED TIME=' || TO_CHAR(v_ELAPSED));
	END IF;

END SET_SERVICE_OBLIGATION_DAY;
----------------------------------------------------------------------------------------------------
PROCEDURE ENSURE_SERVICE_OBLIGATION
    (
    p_CAST_CONTEXT IN OUT NOCOPY CAST_CONTEXT_TYPE
    ) AS

    v_RESULT NUMBER(9);

BEGIN

    FOR v_REC IN (SELECT DISTINCT S.PROVIDER_SERVICE_ID, S.SERVICE_DELIVERY_ID
                    FROM SERVICE_STATE SS,
                        SERVICE S
                    WHERE SS.SERVICE_DATE BETWEEN p_CAST_CONTEXT.BEGIN_DATE AND p_CAST_CONTEXT.END_DATE
                        AND SS.SERVICE_CODE = p_CAST_CONTEXT.SERVICE_CODE
                        AND S.SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
                        AND S.SERVICE_ID = SS.SERVICE_ID
                        AND S.MODEL_ID = p_CAST_CONTEXT.MODEL_ID) LOOP

        v_RESULT := CX.GET_SERVICE_OBLIGATION_ID(p_CAST_CONTEXT, v_REC.PROVIDER_SERVICE_ID, v_REC.SERVICE_DELIVERY_ID);

    END LOOP;

END ENSURE_SERVICE_OBLIGATION;
----------------------------------------------------------------------------------------------------
PROCEDURE SET_SERVICE_OBLIGATION
	(
	p_CAST_CONTEXT IN OUT NOCOPY CAST_CONTEXT_TYPE
	) AS

-- Create the EDC and Provider Load summary for the specified context.

v_ELASPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;

BEGIN

	DELETE_SERVICE_OBLIGATION_LOAD(p_CAST_CONTEXT);
	DELETE_EDC_SYSTEM_UFE_LOAD(p_CAST_CONTEXT);

    IF p_CAST_CONTEXT.SERVICE_CODE = 'A' THEN
        ENSURE_SERVICE_OBLIGATION(p_CAST_CONTEXT);
    END IF;

-- Recalc all Non-Aggregate Account Actual Service Losses
	IF p_CAST_CONTEXT.SERVICE_CODE = GA.ACTUAL_SERVICE AND GA.ENABLE_ACTUAL_LOSSES_RECALC THEN
		APPLY_ACTUAL_SERVICE_LOSSES(p_CAST_CONTEXT);
	END IF;

	p_CAST_CONTEXT.SERVICE_DATE := p_CAST_CONTEXT.BEGIN_DATE;
	WHILE p_CAST_CONTEXT.SERVICE_DATE <= p_CAST_CONTEXT.END_DATE LOOP
		SET_SERVICE_OBLIGATION_DAY(p_CAST_CONTEXT);
		p_CAST_CONTEXT.SERVICE_DATE := p_CAST_CONTEXT.SERVICE_DATE + 1;
	END LOOP;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('SET_SERVICE_OBLIGATION ELAPSED TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELASPSED));
	END IF;

END SET_SERVICE_OBLIGATION;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SERVICE_LOAD_DETERMINANTS
	(
	p_SERVICE_ID IN NUMBER,
	p_ACCOUNT_SERVICE_ID IN NUMBER,
	p_SERVICE_CODE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_DETERMINANTS IN OUT NOCOPY DETERMINANT_TABLE
	) AS

BEGIN

	SELECT DETERMINANT_TYPE(CONSTANTS.NOT_ASSIGNED, LOAD_DATE, LOAD_DATE, LOAD_DATE, LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + UE_LOSS_VAL, LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL + UE_LOSS_VAL, CONSTANTS.NOT_ASSIGNED, 'B', p_ACCOUNT_SERVICE_ID, CONSTANTS.NOT_ASSIGNED, CONSTANTS.NOT_ASSIGNED)
	BULK COLLECT INTO p_DETERMINANTS
	FROM SERVICE_LOAD
	WHERE SERVICE_ID = p_SERVICE_ID
		AND SERVICE_CODE = p_SERVICE_CODE
		AND LOAD_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
		AND LOAD_CODE = GA.STANDARD;

END GET_SERVICE_LOAD_DETERMINANTS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_SERVICE_REVENUE
	(
	p_CAST_CONTEXT IN OUT NOCOPY CAST_CONTEXT_TYPE
	) AS

CURSOR c_REQUEST IS
	SELECT DISTINCT A.SERVICE_ID, B.ACCOUNT_SERVICE_ID, D.PRODUCT_TYPE, E.PRODUCT_ID, E.COMPONENT_ID
	FROM SERVICE A, ACCOUNT_SERVICE B, ACCOUNT_STATUS C, ACCOUNT_STATUS_NAME STATUS_NAME, ACCOUNT_PRODUCT D, PRODUCT_COMPONENT E
	WHERE A.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
		AND A.SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
		AND A.AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE
		AND B.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
		AND B.METER_ID = CONSTANTS.NOT_ASSIGNED
		AND C.ACCOUNT_ID = B.ACCOUNT_ID
		AND C.BEGIN_DATE <= p_CAST_CONTEXT.SERVICE_DATE
		AND NVL(C.END_DATE, p_CAST_CONTEXT.SERVICE_DATE) >= p_CAST_CONTEXT.SERVICE_DATE
		AND STATUS_NAME.STATUS_NAME = C.STATUS_NAME
		AND STATUS_NAME.IS_ACTIVE = 1
		AND D.CASE_ID = p_CAST_CONTEXT.PRODUCT_CASE_ID
		AND D.ACCOUNT_ID = B.ACCOUNT_ID
		AND D.PRODUCT_TYPE IN ('R','C')
		AND D.BEGIN_DATE <= p_CAST_CONTEXT.SERVICE_DATE
		AND NVL(D.END_DATE, p_CAST_CONTEXT.SERVICE_DATE) >= p_CAST_CONTEXT.SERVICE_DATE
		AND E.PRODUCT_ID = D.PRODUCT_ID
		AND E.BEGIN_DATE <= p_CAST_CONTEXT.SERVICE_DATE
		AND NVL(E.END_DATE, p_CAST_CONTEXT.SERVICE_DATE) >= p_CAST_CONTEXT.SERVICE_DATE
	UNION SELECT DISTINCT A.SERVICE_ID, B.ACCOUNT_SERVICE_ID, D.PRODUCT_TYPE, E.PRODUCT_ID, E.COMPONENT_ID
	FROM SERVICE A, ACCOUNT_SERVICE B, ACCOUNT_STATUS C, ACCOUNT_STATUS_NAME STATUS_NAME, METER_PRODUCT D, PRODUCT_COMPONENT E
	WHERE A.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
		AND A.SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
		AND A.AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE
		AND B.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
		AND NOT B.METER_ID = CONSTANTS.NOT_ASSIGNED
		AND C.ACCOUNT_ID = B.ACCOUNT_ID
		AND C.BEGIN_DATE <= p_CAST_CONTEXT.SERVICE_DATE
		AND NVL(C.END_DATE, p_CAST_CONTEXT.SERVICE_DATE) >= p_CAST_CONTEXT.SERVICE_DATE
		AND STATUS_NAME.STATUS_NAME = C.STATUS_NAME
		AND STATUS_NAME.IS_ACTIVE = 1
		AND D.CASE_ID = p_CAST_CONTEXT.PRODUCT_CASE_ID
		AND D.METER_ID = B.METER_ID
		AND D.PRODUCT_TYPE IN ('R','C')
		AND D.BEGIN_DATE <= p_CAST_CONTEXT.SERVICE_DATE
		AND NVL(D.END_DATE, p_CAST_CONTEXT.SERVICE_DATE) >= p_CAST_CONTEXT.SERVICE_DATE
		AND E.PRODUCT_ID = D.PRODUCT_ID
		AND E.BEGIN_DATE <= p_CAST_CONTEXT.SERVICE_DATE
		AND NVL(E.END_DATE, p_CAST_CONTEXT.SERVICE_DATE) >= p_CAST_CONTEXT.SERVICE_DATE
	ORDER BY 1,2,3,4,5;

v_LAST_SERVICE_ID NUMBER(9) := 999999999;
v_DETERMINANTS DETERMINANT_TABLE := DETERMINANT_TABLE();
v_CHARGE_COMPONENTS CHARGE_COMPONENT_TABLE := CHARGE_COMPONENT_TABLE();
v_COMPONENT COMPONENT%ROWTYPE;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_SERVICE_XREF GA.ID_TABLE;
v_SERVICE GA.ID_TABLE;
v_REVENUE GA.FLOAT_TABLE;
v_EXPENSE GA.FLOAT_TABLE;
v_INDEX BINARY_INTEGER;
v_XREF_ID BINARY_INTEGER;
v_ELASPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;

BEGIN

	UT.CUT_DATE_RANGE(p_CAST_CONTEXT.MODEL_ID, p_CAST_CONTEXT.SERVICE_DATE, LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	FOR v_REQUEST IN c_REQUEST LOOP
		IF NOT v_LAST_SERVICE_ID = v_REQUEST.SERVICE_ID THEN
			GET_SERVICE_LOAD_DETERMINANTS(v_REQUEST.SERVICE_ID, v_REQUEST.ACCOUNT_SERVICE_ID, p_CAST_CONTEXT.SERVICE_CODE, v_BEGIN_DATE, v_END_DATE, v_DETERMINANTS);
		END IF;

		IF NOT v_SERVICE_XREF.EXISTS(v_REQUEST.SERVICE_ID) THEN
			v_SERVICE_XREF(v_REQUEST.SERVICE_ID) := v_SERVICE_XREF.COUNT + 1;
		END IF;

		v_XREF_ID := v_SERVICE_XREF(v_REQUEST.SERVICE_ID);
		v_SERVICE(v_XREF_ID) := v_REQUEST.SERVICE_ID;

		IF v_DETERMINANTS.COUNT > 0 THEN
			v_COMPONENT := GET_COMPONENT(v_REQUEST.COMPONENT_ID);
			CU.APPLY_PRODUCT_COMPONENT(v_REQUEST.PRODUCT_ID, v_COMPONENT, v_DETERMINANTS, p_CAST_CONTEXT.SERVICE_DATE, p_CAST_CONTEXT.SERVICE_DATE, 1, 1, CONSTANTS.NOT_ASSIGNED, LOGS.IS_DEBUG_ENABLED, v_CHARGE_COMPONENTS);
			v_INDEX := v_CHARGE_COMPONENTS.FIRST;
			WHILE v_INDEX <= v_CHARGE_COMPONENTS.LAST LOOP
				IF v_REQUEST.PRODUCT_TYPE = 'R' THEN
					IF NOT v_REVENUE.EXISTS(v_XREF_ID) THEN
						v_REVENUE(v_XREF_ID) := v_CHARGE_COMPONENTS(v_INDEX).AMOUNT;
					ELSE
						v_REVENUE(v_XREF_ID) := v_REVENUE(v_XREF_ID) + v_CHARGE_COMPONENTS(v_INDEX).AMOUNT;
					END IF;
				ELSE
					IF NOT v_EXPENSE.EXISTS(v_XREF_ID) THEN
						v_EXPENSE(v_XREF_ID) := v_CHARGE_COMPONENTS(v_INDEX).AMOUNT;
					ELSE
						v_EXPENSE(v_XREF_ID) := v_EXPENSE(v_XREF_ID) + v_CHARGE_COMPONENTS(v_INDEX).AMOUNT;
					END IF;
				END IF;
				v_INDEX := v_CHARGE_COMPONENTS.NEXT(v_INDEX);
			END LOOP;
		END IF;
		v_LAST_SERVICE_ID := v_REQUEST.SERVICE_ID;
	END LOOP;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('GET_SERVICE_REVENUE ELAPSED TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELASPSED));
	END IF;

END GET_SERVICE_REVENUE;
---------------------------------------------------------------------------------------------------
PROCEDURE TRACE_SERVICE
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE
	) AS

v_ACCOUNT_SERVICE_ID BINARY_INTEGER;
v_INDEX BINARY_INTEGER;

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		v_ACCOUNT_SERVICE_ID := g_SERVICE_XREF.FIRST;
		WHILE v_ACCOUNT_SERVICE_ID <= g_SERVICE_XREF.FIRST LOOP
			v_INDEX := g_SERVICE_XREF(v_ACCOUNT_SERVICE_ID);
			LOGS.LOG_DEBUG('TRACE_SERVICE ACCOUNT_SERVICE_ID=' || TO_CHAR(v_ACCOUNT_SERVICE_ID) || ', XREF_ID=' || TO_CHAR(v_INDEX));
			LOGS.LOG_DEBUG('SERVICE_DATE=' || TO_CHAR(g_SERVICE_DATE(v_INDEX)));
			LOGS.LOG_DEBUG('SERVICE_ID='  || TO_CHAR(g_SERVICE_ID(v_INDEX)));
			LOGS.LOG_DEBUG('ACCOUNT_SERVICE_ID='  || TO_CHAR(g_ACCOUNT_SERVICE_ID(v_INDEX)));
			LOGS.LOG_DEBUG('PROVIDER_SERVICE_ID='  || TO_CHAR(g_PROVIDER_SERVICE_ID(v_INDEX)));
			LOGS.LOG_DEBUG('SERVICE_DELIVERY_ID='  || TO_CHAR(g_SERVICE_DELIVERY_ID(v_INDEX)));
			LOGS.LOG_DEBUG('SERVICE_OBLIGATION_ID='  || TO_CHAR(g_SERVICE_OBLIGATION_ID(v_INDEX)));
			LOGS.LOG_DEBUG('POOL_ID='  || TO_CHAR(g_POOL_ID(v_INDEX)));
			LOGS.LOG_DEBUG('SERVICE_POINT_ID='  || TO_CHAR(g_SERVICE_POINT_ID(v_INDEX)));
			LOGS.LOG_DEBUG('IS_UFE_PARTICIPANT='  || g_IS_UFE_PARTICIPANT(v_INDEX));
			LOGS.LOG_DEBUG('IS_CREATE_SETTLEMENT_PROFILE='  || g_IS_CREATE_SETTLEMENT_PROFILE(v_INDEX));
			LOGS.LOG_DEBUG('METER_TYPE='  || g_METER_TYPE(v_INDEX));
			LOGS.LOG_DEBUG('IS_EXTERNAL_FORECAST='  || g_IS_EXTERNAL_FORECAST(v_INDEX));
			LOGS.LOG_DEBUG('SERVICE_ACCOUNTS='  || TO_CHAR(g_SERVICE_ACCOUNTS(v_INDEX)));
			LOGS.LOG_DEBUG('SCHEDULE_GROUP_ID='  || TO_CHAR(g_SCHEDULE_GROUP_ID(v_INDEX)));
			LOGS.LOG_DEBUG('STATION_ID='  || TO_CHAR(g_STATION_ID(v_INDEX)));
			LOGS.LOG_DEBUG('CAST_CALENDAR_ID='  || TO_CHAR(g_CAST_CALENDAR_ID(v_INDEX)));
			LOGS.LOG_DEBUG('SUPPLY_TYPE='  || g_SUPPLY_TYPE(v_INDEX));
			LOGS.LOG_DEBUG('IS_BUG='  || g_IS_BUG(v_INDEX));
			LOGS.LOG_DEBUG('IS_WHOLESALE='  || g_IS_WHOLESALE(v_INDEX));
			LOGS.LOG_DEBUG('IS_AGGREGATE_ACCOUNT='  || g_IS_AGGREGATE_ACCOUNT(v_INDEX));
			LOGS.LOG_DEBUG('IS_AGGREGATE_POOL='  || g_IS_AGGREGATE_POOL(v_INDEX));
			LOGS.LOG_DEBUG('USAGE_FACTOR='  || TO_CHAR(g_USAGE_FACTOR(v_INDEX)));
			LOGS.LOG_DEBUG('GROWTH_FACTOR='  || TO_CHAR(g_GROWTH_FACTOR(v_INDEX)));
			LOGS.LOG_DEBUG('SERVICE_INTERVALS='  || TO_CHAR(g_SERVICE_INTERVALS(v_INDEX)));
			v_ACCOUNT_SERVICE_ID := g_SERVICE_XREF.NEXT(v_ACCOUNT_SERVICE_ID);
		END LOOP;
	END IF;

END TRACE_SERVICE;
----------------------------------------------------------------------------------------------------
FUNCTION COERCE_INTERVAL
	(
	p_INDEX IN BINARY_INTEGER,
	p_SOURCE_INTERVALS IN BINARY_INTEGER,
	p_TARGET_INTERVALS IN BINARY_INTEGER
	) RETURN BINARY_INTEGER IS

BEGIN

	IF p_SOURCE_INTERVALS = 24 THEN
		IF p_TARGET_INTERVALS = 24 THEN
			RETURN p_INDEX;
		ELSIF p_TARGET_INTERVALS = 48 THEN
			RETURN FLOOR((p_INDEX + 1) / 2);
		ELSIF p_TARGET_INTERVALS = 96 THEN
			RETURN FLOOR((p_INDEX + 3) / 4);
		END IF;
	ELSIF p_SOURCE_INTERVALS = 48 THEN
		IF p_TARGET_INTERVALS = 24 THEN
			RETURN p_INDEX * 2;
		ELSIF p_TARGET_INTERVALS = 48 THEN
			RETURN p_INDEX;
		ELSIF p_TARGET_INTERVALS = 96 THEN
			RETURN p_INDEX * 4;
		END IF;
	ELSIF p_SOURCE_INTERVALS = 96 THEN
		IF p_TARGET_INTERVALS = 24 THEN
			RETURN p_INDEX * 4;
		ELSIF p_TARGET_INTERVALS = 48 THEN
			RETURN p_INDEX * 2;
		ELSIF p_TARGET_INTERVALS = 96 THEN
			RETURN p_INDEX;
		END IF;
	END IF;

	RETURN p_INDEX;

END COERCE_INTERVAL;
----------------------------------------------------------------------------------------------------
FUNCTION GET_LOSS_FACTOR_FROM_PATTERN
	(
	p_INDEX IN BINARY_INTEGER,
	p_INTERVALS IN NUMBER,
	p_LOSS_FACTOR_PATTERN IN GA.NUMBER_TABLE
	) RETURN NUMBER IS

v_INDEX BINARY_INTEGER;

BEGIN

	IF p_LOSS_FACTOR_PATTERN.COUNT = CONSTANTS.NOT_ASSIGNED THEN
		RETURN CONSTANTS.NOT_ASSIGNED;
	END IF;

	IF p_LOSS_FACTOR_PATTERN.COUNT = 1 THEN
		v_INDEX := p_LOSS_FACTOR_PATTERN.FIRST;
	ELSIF p_LOSS_FACTOR_PATTERN.COUNT = p_INTERVALS THEN
		v_INDEX := p_INDEX;
	ELSE
		v_INDEX := COERCE_INTERVAL(p_INDEX, p_LOSS_FACTOR_PATTERN.COUNT, p_INTERVALS);
	END IF;

	IF p_LOSS_FACTOR_PATTERN.EXISTS(v_INDEX) THEN
		RETURN p_LOSS_FACTOR_PATTERN(v_INDEX);
	ELSE
		RETURN CONSTANTS.NOT_ASSIGNED;
	END IF;

END GET_LOSS_FACTOR_FROM_PATTERN;
----------------------------------------------------------------------------------------------------
PROCEDURE APPLY_LOSS_FACTORS
	(
	p_ACCOUNT_SERVICE_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_LOAD IN GA.FLOAT_TABLE,
	p_TX_LOSS IN OUT NOCOPY GA.FACTOR_TABLE,
	p_DX_LOSS IN OUT NOCOPY GA.FACTOR_TABLE,
	p_UE_LOAD IN OUT NOCOPY GA.FACTOR_TABLE,
	p_FAULT_CACHE IN BOOLEAN DEFAULT FALSE
	) AS

v_INDEX BINARY_INTEGER;
$IF $$UNIT_TEST_MODE = 1 $THEN
  v_LOAD_CNT           BINARY_INTEGER := 0;
  v_TX_LOSS_FACTOR_CNT BINARY_INTEGER := 0;
  v_DX_LOSS_FACTOR_CNT BINARY_INTEGER := 0;
  v_UE_LOSS_FACTOR_CNT BINARY_INTEGER := 0;
$END
v_TX_LOSS_FACTOR NUMBER(14,8) := 1;
v_DX_LOSS_FACTOR NUMBER(14,8) := 1;
v_UE_LOSS_FACTOR NUMBER(14,8) := 1;
v_TX_LOSS_FACTOR_PATTERN GA.NUMBER_TABLE;
v_DX_LOSS_FACTOR_PATTERN GA.NUMBER_TABLE;
v_UE_LOSS_FACTOR_PATTERN GA.NUMBER_TABLE;
v_PROFILE GA.NUMBER_TABLE;

BEGIN
   $IF $$UNIT_TEST_MODE = 1 $THEN
      IF UNIT_TEST_UTIL.g_CURRENT_TEST_PROCEDURE LIKE 'TEST_FS.T_REAPPLY_LOSS_FACTORS' THEN

        -- Columns with _ID and ENTRY_DATE will be excluded from the list.
        v_LOAD_CNT           := p_LOAD.LAST-p_LOAD.FIRST;
        v_TX_LOSS_FACTOR_CNT := p_TX_LOSS.LAST-p_TX_LOSS.FIRST;
        v_DX_LOSS_FACTOR_CNT := p_DX_LOSS.LAST-p_DX_LOSS.FIRST;
        v_UE_LOSS_FACTOR_CNT := p_UE_LOAD.LAST-p_UE_LOAD.FIRST;

        INSERT INTO RTO_WORK(WORK_DATA)
        SELECT gc_CRLF ||'-----------------------------------------------------'|| gc_CRLF ||
               'p_EDC_ID (name) = '|| EI.GET_ENTITY_NAME(-100,p_EDC_ID) || gc_CRLF ||
               'p_SERVICE_DATE (cut)  = '|| TO_CHAR(p_SERVICE_DATE,'YYYY-MM-DD') || gc_CRLF ||
               'p_LOAD.COUNT    = '|| TO_CHAR(v_LOAD_CNT) || gc_CRLF ||
               'p_TX_LOSS.COUNT = '|| TO_CHAR(v_TX_LOSS_FACTOR_CNT) || gc_CRLF ||
               'p_DX_LOSS.COUNT = '|| TO_CHAR(v_DX_LOSS_FACTOR_CNT) || gc_CRLF ||
               'p_UE_LOAD.COUNT = '|| TO_CHAR(v_UE_LOSS_FACTOR_CNT) || gc_CRLF ||
               'p_FAULT_CACHE   = FALSE '|| gc_CRLF
           FROM DUAL;
        GOTO APPLY_LOSS_FACTOR_END;
      END IF;
   $END

	CX.GET_LOSS_FACTOR_PATTERN(p_ACCOUNT_SERVICE_ID, p_EDC_ID, p_SERVICE_DATE, p_FAULT_CACHE, v_TX_LOSS_FACTOR_PATTERN, v_DX_LOSS_FACTOR_PATTERN, v_UE_LOSS_FACTOR_PATTERN);

    -- Adjust just the losses and not the profile (which have already been adjusted for DST
    -- PROFILE passed in as null collection
    ADJUST_FOR_DAYLIGHT_SAVINGS(p_SERVICE_DATE, v_PROFILE, v_TX_LOSS_FACTOR_PATTERN, v_DX_LOSS_FACTOR_PATTERN, v_UE_LOSS_FACTOR_PATTERN);

	v_INDEX := p_LOAD.FIRST;
	WHILE v_INDEX <= p_LOAD.LAST LOOP
		v_TX_LOSS_FACTOR := GET_LOSS_FACTOR_FROM_PATTERN(v_INDEX, p_LOAD.COUNT, v_TX_LOSS_FACTOR_PATTERN);
		v_DX_LOSS_FACTOR := GET_LOSS_FACTOR_FROM_PATTERN(v_INDEX, p_LOAD.COUNT, v_DX_LOSS_FACTOR_PATTERN);
		v_UE_LOSS_FACTOR := GET_LOSS_FACTOR_FROM_PATTERN(v_INDEX, p_LOAD.COUNT, v_UE_LOSS_FACTOR_PATTERN);
        IF LOGS.IS_DEBUG_ENABLED THEN
            LOGS.LOG_DEBUG_MORE_DETAIL('DX_LOSS_FACTOR('||v_INDEX||')'|| v_DX_LOSS_FACTOR);
            LOGS.LOG_DEBUG_MORE_DETAIL('TX_LOSS_FACTOR('||v_INDEX||')'|| v_TX_LOSS_FACTOR);
            LOGS.LOG_DEBUG_MORE_DETAIL('UE_LOSS_FACTOR('||v_INDEX||')'|| v_UE_LOSS_FACTOR);
        END IF;
        p_DX_LOSS(v_INDEX) := (p_LOAD(v_INDEX)) * v_DX_LOSS_FACTOR;
		p_TX_LOSS(v_INDEX) := (p_LOAD(v_INDEX) + p_DX_LOSS(v_INDEX)) * v_TX_LOSS_FACTOR;
		p_UE_LOAD(v_INDEX) := (p_LOAD(v_INDEX) + p_DX_LOSS(v_INDEX) + p_TX_LOSS(v_INDEX)) * v_UE_LOSS_FACTOR;
		v_INDEX := p_LOAD.NEXT(v_INDEX);
	END LOOP;

   <<APPLY_LOSS_FACTOR_END>>
   NULL;-- Above label can not be the last line in the block.

END APPLY_LOSS_FACTORS;
----------------------------------------------------------------------------------------------------
PROCEDURE ASSIGN_CUSTOMER_SERVICE_LOAD
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_ACCOUNT_SERVICE_ID IN NUMBER,
	p_SERVICE_ID IN NUMBER,
	p_LOAD_VAL IN GA.NUMBER_TABLE,
	p_TX_LOSS_FACTOR IN NUMBER,
	p_DX_LOSS_FACTOR IN NUMBER,
	p_UE_LOSS_FACTOR IN NUMBER,
	p_USAGE_FACTOR IN NUMBER,
	p_GROWTH_FACTOR IN NUMBER,
	p_AGGREGATE_LOAD OUT NUMBER,
	p_AGGREGATE_COUNT OUT NUMBER
	) AS

v_INDEX BINARY_INTEGER;
v_CUSTOMER_ID GA.ID_TABLE;
v_CU_LOAD_VAL GA.NUMBER_TABLE;
v_DX_LOSS_VAL GA.NUMBER_TABLE;
v_TX_LOSS_VAL GA.NUMBER_TABLE;
v_UE_LOSS_VAL GA.NUMBER_TABLE;
v_LOAD_VAL NUMBER(16,6);
v_COUNT BINARY_INTEGER := 0;
v_LOAD_CODE CHAR(1);
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;
v_LAST PLS_INTEGER;
v_AGGREGATE_LOAD NUMBER := 0;

BEGIN

	p_AGGREGATE_LOAD := 0;
	p_AGGREGATE_COUNT := 0;
	v_INDEX := p_LOAD_VAL.FIRST;
	v_LAST := p_LOAD_VAL.LAST;

	IF (GA.STORE_CUST_SVC_LOAD_BACKCAST AND p_CAST_CONTEXT.REQUEST_TYPE = GA.BACKCAST_SERVICE)
		OR (GA.STORE_CUST_SVC_LOAD_FORECAST AND p_CAST_CONTEXT.REQUEST_TYPE = GA.FORECAST_SERVICE)
    THEN
		WHILE v_INDEX <= v_LAST LOOP
			v_LOAD_VAL  := NVL(p_LOAD_VAL(v_INDEX),0);
			v_AGGREGATE_LOAD := v_AGGREGATE_LOAD + v_LOAD_VAL;
			v_LOAD_VAL := v_LOAD_VAL * p_USAGE_FACTOR;
			v_LOAD_VAL := v_LOAD_VAL + (v_LOAD_VAL * p_GROWTH_FACTOR);
			v_COUNT := v_COUNT + 1;
			v_CUSTOMER_ID(v_COUNT) := v_INDEX;
			v_CU_LOAD_VAL(v_COUNT) := v_LOAD_VAL;
			v_DX_LOSS_VAL(v_COUNT) := (v_LOAD_VAL) * p_DX_LOSS_FACTOR;
			v_TX_LOSS_VAL(v_COUNT) := (v_LOAD_VAL + v_DX_LOSS_VAL(v_COUNT)) * p_TX_LOSS_FACTOR;
			v_UE_LOSS_VAL(v_COUNT) := (v_LOAD_VAL + v_DX_LOSS_VAL(v_COUNT) + v_TX_LOSS_VAL(v_COUNT)) * p_UE_LOSS_FACTOR;
			v_INDEX := p_LOAD_VAL.NEXT(v_INDEX);
		END LOOP;
	ELSE
		WHILE v_INDEX <= v_LAST LOOP
			v_AGGREGATE_LOAD := v_AGGREGATE_LOAD + NVL(p_LOAD_VAL(v_INDEX),0);
			v_COUNT := v_COUNT + 1;
			v_INDEX := p_LOAD_VAL.NEXT(v_INDEX);
		END LOOP;
	END IF;

    p_AGGREGATE_LOAD := v_AGGREGATE_LOAD;
	p_AGGREGATE_COUNT := v_COUNT;

	IF p_CAST_CONTEXT.RUN_MODE IN (GA.MONTH_MODE, GA.WEEK_MODE) THEN
		v_LOAD_CODE := p_CAST_CONTEXT.DAY_TYPE;
	ELSE
		v_LOAD_CODE := GA.STANDARD;
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('ASSIGN_CUSTOMER_SERVICE_LOAD');
		LOGS.LOG_DEBUG('SERVICE_ID=' || TO_CHAR(p_SERVICE_ID) || ', AGGREGATE_LOAD=' || TO_CHAR(p_AGGREGATE_LOAD) || ', AGGREGATE_COUNT=' || TO_CHAR(p_AGGREGATE_COUNT));
	END IF;

	IF (GA.STORE_CUST_SVC_LOAD_BACKCAST AND p_CAST_CONTEXT.REQUEST_TYPE = GA.BACKCAST_SERVICE)
		OR (GA.STORE_CUST_SVC_LOAD_FORECAST AND p_CAST_CONTEXT.REQUEST_TYPE = GA.FORECAST_SERVICE)
    THEN
      	FORALL v_INDEX IN 1..v_COUNT
      		INSERT INTO CUSTOMER_SERVICE_LOAD(SERVICE_ID,
				CUSTOMER_ID,
				SERVICE_CODE,
				LOAD_DATE,
				LOAD_CODE,
				LOAD_VAL,
				TX_LOSS_VAL,
				DX_LOSS_VAL,
				UE_LOSS_VAL)
      		VALUES (p_SERVICE_ID,
				v_CUSTOMER_ID(v_INDEX),
				p_CAST_CONTEXT.SERVICE_CODE,
				p_CAST_CONTEXT.SERVICE_DATE,
				v_LOAD_CODE,
				v_CU_LOAD_VAL(v_INDEX),
				v_TX_LOSS_VAL(v_INDEX),
				v_DX_LOSS_VAL(v_INDEX),
				v_UE_LOSS_VAL(v_INDEX));
     END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('ASSIGN_CUSTOMER_SERVICE_LOAD ELAPSED TIME='  || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED) || ', COUNT=' || TO_CHAR(v_COUNT));
	END IF;

END ASSIGN_CUSTOMER_SERVICE_LOAD;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_SERVICE_OBLIGATION_CACHE
	(
	p_SERVICE_OBLIGATION_ID IN NUMBER,
	p_XREF_ID IN NUMBER,
	p_LOAD_DATE IN DATE,
	p_INTERVAL IN NUMBER,
	p_DAY_TYPE IN NUMBER,
	p_LOAD_VAL IN NUMBER,
	p_TX_LOSS_VAL IN NUMBER,
	p_DX_LOSS_VAL IN NUMBER,
	p_UE_LOSS_VAL IN NUMBER,
	p_APPLY_UFE IN NUMBER,
	p_ALLOCATION_PCT IN NUMBER
	) AS


	v_SOB_INDEX	VARCHAR2(16);
	v_SID		BINARY_INTEGER;

BEGIN

	v_SOB_INDEX := (p_SERVICE_OBLIGATION_ID * 1000) + (p_INTERVAL * 10) + p_DAY_TYPE;
	IF NOT g_SOB_LOAD_XREF.EXISTS(v_SOB_INDEX) THEN
		g_SOB_LOAD_XREF(v_SOB_INDEX) := g_SOB_LOAD_XREF.COUNT + 1;
	END IF;
	v_SID := g_SOB_LOAD_XREF(v_SOB_INDEX);

	IF NOT g_SOB_LOAD_ID.EXISTS(v_SID) THEN
		g_SOB_LOAD_ID(v_SID) := p_SERVICE_OBLIGATION_ID;
		g_SOB_LOAD_DATE(v_SID) := p_LOAD_DATE;
		g_SOB_LOAD_VAL(v_SID) := 0;
		g_SOB_TX_LOSS_VAL(v_SID) := 0;
		g_SOB_DX_LOSS_VAL(v_SID) := 0;
		g_SOB_UE_LOSS_VAL(v_SID) := 0;
		g_SOB_AGG_LOAD_VAL(v_SID) := 0;
		g_SOB_AGG_TX_LOSS_VAL(v_SID) := 0;
		g_SOB_AGG_DX_LOSS_VAL(v_SID) := 0;
	END IF;

	g_SOB_LOAD_VAL(v_SID) := g_SOB_LOAD_VAL(v_SID) + p_LOAD_VAL * p_ALLOCATION_PCT;
	g_SOB_TX_LOSS_VAL(v_SID) := g_SOB_TX_LOSS_VAL(v_SID) + p_TX_LOSS_VAL * p_ALLOCATION_PCT;
	g_SOB_DX_LOSS_VAL(v_SID) := g_SOB_DX_LOSS_VAL(v_SID) + p_DX_LOSS_VAL * p_ALLOCATION_PCT;
	IF g_IS_AGGREGATE_ACCOUNT(p_XREF_ID) = 1 THEN
		g_SOB_AGG_LOAD_VAL(v_SID) := g_SOB_AGG_LOAD_VAL(v_SID) + p_LOAD_VAL * p_ALLOCATION_PCT;
		g_SOB_AGG_TX_LOSS_VAL(v_SID) := g_SOB_AGG_TX_LOSS_VAL(v_SID) + p_TX_LOSS_VAL * p_ALLOCATION_PCT;
		g_SOB_AGG_DX_LOSS_VAL(v_SID) := g_SOB_AGG_DX_LOSS_VAL(v_SID) + p_DX_LOSS_VAL * p_ALLOCATION_PCT;
	END IF;

	IF p_APPLY_UFE = 1 AND g_IS_UFE_PARTICIPANT(p_XREF_ID) = g_ON THEN
		g_SOB_UE_LOSS_VAL(v_SID) := g_SOB_UE_LOSS_VAL(v_SID) + (p_LOAD_VAL + p_TX_LOSS_VAL +p_DX_LOSS_VAL) * p_ALLOCATION_PCT;
	ELSIF p_APPLY_UFE = 2 THEN
		g_SOB_UE_LOSS_VAL(v_SID) := g_SOB_UE_LOSS_VAL(v_SID) + p_UE_LOSS_VAL * p_ALLOCATION_PCT;
	END IF;

END PUT_SERVICE_OBLIGATION_CACHE;
----------------------------------------------------------------------------------------------------
PROCEDURE GENERATE_POOL_SUB_POOLS
	(
	p_AGG_POOL_ID IN NUMBER,
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE
	) AS

	v_SUB_POOLS SUB_POOLS := SUB_POOLS();

BEGIN

	SELECT SO.SERVICE_OBLIGATION_ID, (PSP.ALLOCATION_PCT * EP.ALLOCATION_PCT ) / (100*100)
	BULK COLLECT INTO v_SUB_POOLS
	FROM INCUMBENT_ENTITY IE,
		ENERGY_DISTRIBUTION_COMPANY EDC,
		ENERGY_SERVICE_PROVIDER ESP,
		PURCHASING_SELLING_ENTITY PSE,
		PSE_ESP PE,
		SERVICE_DELIVERY SD,
		PROVIDER_SERVICE PS,
		SERVICE_OBLIGATION SO,
		ESP_POOL EP,
		POOL_SUB_POOL PSP
	WHERE IE.INCUMBENT_TYPE = 'EDC'
		AND EDC.EDC_ID = IE.INCUMBENT_ID -- EDC IS THE INCUMBENT EDC
		AND PSP.POOL_ID = p_AGG_POOL_ID -- GET THE SUB POOLS FOR THE AGG POOL
		AND p_CAST_CONTEXT.SERVICE_DATE BETWEEN PSP.BEGIN_DATE AND NVL(PSP.END_DATE, CONSTANTS.HIGH_DATE)
		AND EP.POOL_ID = PSP.SUB_POOL_ID -- GET THE ASSIGNED ESPS FOR THE SUB POOLS
		AND p_CAST_CONTEXT.SERVICE_DATE BETWEEN EP.BEGIN_DATE AND NVL(EP.END_DATE, CONSTANTS.HIGH_DATE)
		AND ESP.ESP_ID = EP.ESP_ID
		AND PE.ESP_ID = ESP.ESP_ID -- GET THE PSE ASSIGNED TO THE ESPS (WHICH ARE IN TURN ASSIGNED TO THE SUB_POOL, FUN!)
		AND p_CAST_CONTEXT.SERVICE_DATE BETWEEN PE.BEGIN_DATE AND NVL(PE.END_DATE, CONSTANTS.HIGH_DATE)
		AND PSE.PSE_ID = PE.PSE_ID
		AND SD.POOL_ID = PSP.SUB_POOL_ID
		AND SD.SERVICE_POINT_ID = CONSTANTS.NOT_ASSIGNED
		AND SD.SERVICE_ZONE_ID = CONSTANTS.NOT_ASSIGNED
		AND SD.SCHEDULE_GROUP_ID = CONSTANTS.NOT_ASSIGNED
		AND SD.SC_ID = EDC.EDC_SC_ID
		AND SD.SUPPLY_TYPE = UPPER(SUBSTR(ESP.ESP_TYPE, 1, 1))
		AND SD.IS_BUG = PSE.PSE_IS_BACKUP_GENERATION
		AND SD.IS_WHOLESALE = 0
		AND SD.IS_AGGREGATE_POOL = 1
		AND PS.EDC_ID = EDC.EDC_ID
		AND PS.ESP_ID = ESP.ESP_ID
		AND PS.PSE_ID = PSE.PSE_ID
		AND SO.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
		AND SO.SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
		AND SO.AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE
		AND SO.PROVIDER_SERVICE_ID = PS.PROVIDER_SERVICE_ID
		AND SO.SERVICE_DELIVERY_ID = SD.SERVICE_DELIVERY_ID;

	g_AGGREGATE_POOLS_SUB_POOLS(p_AGG_POOL_ID) := v_SUB_POOLS;

END GENERATE_POOL_SUB_POOLS;
----------------------------------------------------------------------------------------------------
PROCEDURE ASSIGN_SERVICE_LOAD
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_ACCOUNT_SERVICE_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_APPLY_USAGE_FACTOR IN BOOLEAN,
	p_XREF_ID IN BINARY_INTEGER,
	p_PROFILE IN OUT NOCOPY GA.NUMBER_TABLE
	) AS

v_SERVICE_ID 		NUMBER(9);
v_BASE_DATE 		DATE;
v_TRUNC_BASE_DATE	DATE;

v_LOAD_DATE			DATE;
v_LOAD_VAL			NUMBER(16,4);
v_TX_LOSS_FACTOR	NUMBER(16,6);
v_DX_LOSS_FACTOR	NUMBER(16,6);
v_UE_LOSS_FACTOR	NUMBER(16,6);
v_USAGE_FACTOR		NUMBER(16,6);
v_GROWTH_FACTOR		NUMBER(16,6);
v_SERVICE_ACCOUNTS	NUMBER(16,6);
v_COMPOSITE_FACTOR	NUMBER(16,6);
v_TX_LOSS_VAL		NUMBER(16,6);
v_DX_LOSS_VAL		NUMBER(16,6);
v_UE_LOSS_VAL		NUMBER(16,6);
v_MINUTES			NUMBER(4);
v_INDEX				BINARY_INTEGER;
v_SERVICE_INDEX		VARCHAR2(16);
v_UID				BINARY_INTEGER;
v_PROFILE_ZERO_COUNT	PLS_INTEGER := 0;
v_DAY_TYPE			NUMBER(1);

v_INTERVAL_NUMBER	NUMBER(2);

v_INTERVAL 			NUMBER(3);
v_SOB_INTERVAL 		NUMBER(3);
v_INTERVAL_DIVISOR	NUMBER;
v_APPLY_UFE			NUMBER(1);
v_ADJUSTED_PROFILE	GA.NUMBER_TABLE := FP.COPY_PROFILE(p_PROFILE);
v_TX_LOSS_FACTOR_PATTERN	GA.NUMBER_TABLE;
v_DX_LOSS_FACTOR_PATTERN	GA.NUMBER_TABLE;
v_UE_LOSS_FACTOR_PATTERN	GA.NUMBER_TABLE;
v_ELAPSED			PLS_INTEGER := DBMS_UTILITY.GET_TIME;

v_SOB_ID			NUMBER(9);

v_POOLS				SUB_POOLS;

BEGIN

	IF p_CAST_CONTEXT.INCUMBENT_TYPE = 'EDC' THEN
		SELECT DECODE(p_CAST_CONTEXT.APPLY_UFE_CODE,0,0,1) INTO v_APPLY_UFE FROM DUAL;
	ELSE
		v_APPLY_UFE := 2;
	END IF;

	IF v_ADJUSTED_PROFILE.COUNT IN (23,24,25) THEN
		v_INTERVAL_NUMBER := 24;
	ELSIF v_ADJUSTED_PROFILE.COUNT IN (46,48,50) THEN
		v_INTERVAL_NUMBER := 48;
	ELSIF v_ADJUSTED_PROFILE.COUNT IN (92,96,100) THEN
		v_INTERVAL_NUMBER := 96;
	ELSIF v_ADJUSTED_PROFILE.COUNT = 1 THEN
		v_INTERVAL_NUMBER := 1;
	ELSE
		LOGS.LOG_WARN('Encountered a profile with an unexpected size of ' || v_ADJUSTED_PROFILE.COUNT);
		v_INTERVAL_NUMBER := 24;
	END IF;


	v_MINUTES := 1440 / v_INTERVAL_NUMBER;

    IF p_CAST_CONTEXT.MODEL_ID = GA.ELECTRIC_MODEL THEN
       v_BASE_DATE := BEGIN_HOUR_ENDING_CUT_DAY(p_CAST_CONTEXT.SERVICE_DATE, LOCAL_TIME_ZONE, v_MINUTES);
    ELSE
       v_BASE_DATE := p_CAST_CONTEXT.SERVICE_DATE;
    END IF;

	v_LOAD_DATE := v_BASE_DATE;

	v_TRUNC_BASE_DATE := TO_CUT(p_CAST_CONTEXT.SERVICE_DATE,LOCAL_TIME_ZONE);

	-- We don't need to scale the profile because it's
	-- already been done in seperate tou usage factor logic
	IF p_APPLY_USAGE_FACTOR THEN
		v_USAGE_FACTOR := g_USAGE_FACTOR(p_XREF_ID);
	ELSE
		v_USAGE_FACTOR := 1;
	END IF;
	v_GROWTH_FACTOR := g_GROWTH_FACTOR(p_XREF_ID);
	v_SERVICE_ACCOUNTS  := g_SERVICE_ACCOUNTS(p_XREF_ID);
	v_SERVICE_ID := g_SERVICE_ID(p_XREF_ID);

	IF g_IS_AGGREGATE_ACCOUNT(p_XREF_ID) = 1 AND v_SERVICE_ACCOUNTS = CONSTANTS.NOT_ASSIGNED THEN
		v_SERVICE_ACCOUNTS := CX.GET_AGGREGATE_SERVICE_ACCOUNTS(p_ACCOUNT_SERVICE_ID, p_CAST_CONTEXT.SERVICE_DATE, v_SERVICE_ACCOUNTS);
		g_SERVICE_ACCOUNTS(p_XREF_ID) := v_SERVICE_ACCOUNTS;
	END IF;

	v_COMPOSITE_FACTOR := v_SERVICE_ACCOUNTS * v_USAGE_FACTOR;

	v_TX_LOSS_FACTOR_PATTERN := CX.GET_LOSS_FACTOR_PATTERN(p_ACCOUNT_SERVICE_ID, p_EDC_ID, p_CAST_CONTEXT.SERVICE_DATE, 'Transmission');
	v_DX_LOSS_FACTOR_PATTERN := CX.GET_LOSS_FACTOR_PATTERN(p_ACCOUNT_SERVICE_ID, p_EDC_ID, p_CAST_CONTEXT.SERVICE_DATE, 'Distribution');
	v_UE_LOSS_FACTOR_PATTERN := CX.GET_LOSS_FACTOR_PATTERN(p_ACCOUNT_SERVICE_ID, p_EDC_ID, p_CAST_CONTEXT.SERVICE_DATE, 'UFE');

	IF p_CAST_CONTEXT.MODEL_ID = GA.ELECTRIC_MODEL THEN
		ADJUST_FOR_DAYLIGHT_SAVINGS(p_CAST_CONTEXT.SERVICE_DATE, v_ADJUSTED_PROFILE, v_TX_LOSS_FACTOR_PATTERN, v_DX_LOSS_FACTOR_PATTERN, v_UE_LOSS_FACTOR_PATTERN);
	END IF;

	IF LOGS.IS_DEBUG_ENABLED() THEN
		LOGS.LOG_DEBUG('USAGE_FACTOR=' || TO_CHAR(v_USAGE_FACTOR));
		LOGS.LOG_DEBUG('GROWTH_FACTOR=' || TO_CHAR(v_GROWTH_FACTOR));
		LOGS.LOG_DEBUG('SERVICE_ACCOUNTS=' || TO_CHAR(v_SERVICE_ACCOUNTS));
		LOGS.LOG_DEBUG('COMPOSITE_FACTOR=' || TO_CHAR(v_COMPOSITE_FACTOR));
		LOGS.LOG_DEBUG('TX_LOSS_FACTOR_PATTERN COUNT=' || TO_CHAR(v_TX_LOSS_FACTOR_PATTERN.COUNT));
		LOGS.LOG_DEBUG('DX_LOSS_FACTOR_PATTERN COUNT=' || TO_CHAR(v_DX_LOSS_FACTOR_PATTERN.COUNT));
		LOGS.LOG_DEBUG('UE_LOSS_FACTOR_PATTERN COUNT=' || TO_CHAR(v_UE_LOSS_FACTOR_PATTERN.COUNT));
	END IF;

	v_PROFILE_ZERO_COUNT := 0;

	v_INTERVAL_DIVISOR := FW.INTERVAL_DIVISOR(v_INTERVAL_NUMBER);
	IF p_CAST_CONTEXT.RUN_MODE IN (GA.MONTH_MODE, GA.WEEK_MODE) AND TO_CHAR(p_CAST_CONTEXT.SERVICE_DATE,'DY') IN ('SAT', 'SUN') THEN
		v_DAY_TYPE := 2;
	ELSE
		v_DAY_TYPE := 1;
	END IF;

	IF p_CAST_CONTEXT.MODEL_ID = GA.GAS_MODEL AND GA.ENABLE_CUSTOMER_MODEL THEN
		IF GA.ENABLE_CUSTOMER_CAST AND g_IS_AGGREGATE_ACCOUNT(p_XREF_ID) = 1 THEN
			v_TX_LOSS_FACTOR := GET_LOSS_FACTOR_FROM_PATTERN(1, 1, v_TX_LOSS_FACTOR_PATTERN);
			v_DX_LOSS_FACTOR := GET_LOSS_FACTOR_FROM_PATTERN(1, 1, v_DX_LOSS_FACTOR_PATTERN);
			v_UE_LOSS_FACTOR := GET_LOSS_FACTOR_FROM_PATTERN(1, 1, v_UE_LOSS_FACTOR_PATTERN);
			ASSIGN_CUSTOMER_SERVICE_LOAD(p_CAST_CONTEXT, g_ACCOUNT_SERVICE_ID(p_XREF_ID), v_SERVICE_ID, v_ADJUSTED_PROFILE, v_TX_LOSS_FACTOR, v_DX_LOSS_FACTOR, v_UE_LOSS_FACTOR, v_USAGE_FACTOR, v_GROWTH_FACTOR, v_LOAD_VAL, v_SERVICE_ACCOUNTS);
			v_ADJUSTED_PROFILE.DELETE;
			v_ADJUSTED_PROFILE(v_ADJUSTED_PROFILE.COUNT + 1) := v_LOAD_VAL;
			v_COMPOSITE_FACTOR := v_USAGE_FACTOR;
			g_SERVICE_ACCOUNTS(p_XREF_ID) := v_SERVICE_ACCOUNTS;
			-- copy to outbound p_PROFILE with "average" load to be used in settlement profile
			p_PROFILE.DELETE;
			p_PROFILE(1) := v_LOAD_VAL / v_SERVICE_ACCOUNTS;
		ELSE
			g_SERVICE_ACCOUNTS(p_XREF_ID) := 1;
			v_COMPOSITE_FACTOR := v_USAGE_FACTOR;
		END IF;
	END IF;

	FOR v_INDEX IN v_ADJUSTED_PROFILE.FIRST..v_ADJUSTED_PROFILE.LAST LOOP
		IF v_ADJUSTED_PROFILE.EXISTS(v_INDEX) THEN
			v_LOAD_VAL := v_ADJUSTED_PROFILE(v_INDEX) * v_COMPOSITE_FACTOR;
			v_LOAD_VAL := v_LOAD_VAL + (v_LOAD_VAL * v_GROWTH_FACTOR);
			v_TX_LOSS_FACTOR := GET_LOSS_FACTOR_FROM_PATTERN(v_INDEX, v_INTERVAL_NUMBER, v_TX_LOSS_FACTOR_PATTERN);
			v_DX_LOSS_FACTOR := GET_LOSS_FACTOR_FROM_PATTERN(v_INDEX, v_INTERVAL_NUMBER, v_DX_LOSS_FACTOR_PATTERN);
			v_UE_LOSS_FACTOR := GET_LOSS_FACTOR_FROM_PATTERN(v_INDEX, v_INTERVAL_NUMBER, v_UE_LOSS_FACTOR_PATTERN);
			v_DX_LOSS_VAL := (v_LOAD_VAL) * v_DX_LOSS_FACTOR;
			v_TX_LOSS_VAL := (v_LOAD_VAL + v_DX_LOSS_VAL) * v_TX_LOSS_FACTOR;
			v_UE_LOSS_VAL := (v_LOAD_VAL + v_DX_LOSS_VAL + v_TX_LOSS_VAL) * v_UE_LOSS_FACTOR;
			IF v_LOAD_VAL = 0 THEN
				v_PROFILE_ZERO_COUNT := v_PROFILE_ZERO_COUNT + 1;
			END IF;

			v_INTERVAL := ROUND((v_LOAD_DATE - v_BASE_DATE) / v_INTERVAL_DIVISOR) + 1;
			v_SERVICE_INDEX := (v_SERVICE_ID * 1000) + (v_INTERVAL * 10) + v_DAY_TYPE;

			IF p_CAST_CONTEXT.ACCUMULATE_ONLY = 0 THEN

				IF NOT g_SERVICE_LOAD_XREF.EXISTS(v_SERVICE_INDEX) THEN
					g_SERVICE_LOAD_CACHE_SIZE := g_SERVICE_LOAD_CACHE_SIZE + 1;

					IF GA.ENABLE_CAST_CACHE_FLUSH THEN
					   IF g_SERVICE_LOAD_CACHE_SIZE >= GA.CAST_CACHE_FLUSH_THRESHOLD THEN
						  STORE_SERVICE_LOAD(p_CAST_CONTEXT);
						  INITIALIZE_SERVICE_LOAD;
					   END IF;
					END IF;

					g_SERVICE_LOAD_XREF(v_SERVICE_INDEX) := g_SERVICE_LOAD_XREF.COUNT + 1;
				END IF;
				v_UID := g_SERVICE_LOAD_XREF(v_SERVICE_INDEX);

				IF g_SERVICE_LOAD_ID.EXISTS(v_UID) THEN
					g_SERVICE_LOAD_VAL(v_UID) := g_SERVICE_LOAD_VAL(v_UID) + v_LOAD_VAL;
					g_SERVICE_LOAD_TX_LOSS_VAL(v_UID) := g_SERVICE_LOAD_TX_LOSS_VAL(v_UID) + v_TX_LOSS_VAL;
					g_SERVICE_LOAD_DX_LOSS_VAL(v_UID) := g_SERVICE_LOAD_DX_LOSS_VAL(v_UID) + v_DX_LOSS_VAL;
					g_SERVICE_LOAD_UE_LOSS_VAL(v_UID) := g_SERVICE_LOAD_UE_LOSS_VAL(v_UID) + v_UE_LOSS_VAL;
				ELSE
					g_SERVICE_LOAD_ID(v_UID) := v_SERVICE_ID;
					g_SERVICE_LOAD_DATE(v_UID) := v_LOAD_DATE;
					g_SERVICE_LOAD_VAL(v_UID) := v_LOAD_VAL;
					g_SERVICE_LOAD_TX_LOSS_VAL(v_UID) := v_TX_LOSS_VAL;
					g_SERVICE_LOAD_DX_LOSS_VAL(v_UID) := v_DX_LOSS_VAL;
					g_SERVICE_LOAD_UE_LOSS_VAL(v_UID) := v_UE_LOSS_VAL;
				END IF;

			END IF;

			v_SOB_INTERVAL := ROUND((v_LOAD_DATE - v_TRUNC_BASE_DATE) * 288) + 1;

            -- only accumulate service obligation for non-aggregate pools
			IF p_CAST_CONTEXT.ACCUMULATE_SOB_LOAD = g_ON AND (NOT GA.ENABLE_AGGREGATE_POOL_MODEL OR g_IS_AGGREGATE_POOL(p_XREF_ID) = CONSTANTS.NOT_ASSIGNED) THEN

				PUT_SERVICE_OBLIGATION_CACHE(g_SERVICE_OBLIGATION_ID(p_XREF_ID),
											p_XREF_ID,
											v_LOAD_DATE,
											v_SOB_INTERVAL,
											v_DAY_TYPE,
											v_LOAD_VAL,
											v_TX_LOSS_VAL,
											v_DX_LOSS_VAL,
											v_UE_LOSS_VAL,
											v_APPLY_UFE,
											1);

			END IF;

			IF p_CAST_CONTEXT.ACCUMULATE_SOB_LOAD = g_ON
					AND GA.ENABLE_AGGREGATE_POOL_MODEL AND g_IS_AGGREGATE_POOL(p_XREF_ID) = 1 THEN

				IF NOT g_AGGREGATE_POOLS_SUB_POOLS.EXISTS(g_POOL_ID(p_XREF_ID)) THEN
					GENERATE_POOL_SUB_POOLS(g_POOL_ID(p_XREF_ID),
											p_CAST_CONTEXT);
				END IF;

				v_POOLS := g_AGGREGATE_POOLS_SUB_POOLS(g_POOL_ID(p_XREF_ID));

				FOR v_IDX IN v_POOLS.FIRST .. v_POOLS.LAST LOOP

						PUT_SERVICE_OBLIGATION_CACHE(v_POOLS(v_IDX).SERVICE_OBLIGATION_ID,
													p_XREF_ID,
													v_LOAD_DATE,
													v_SOB_INTERVAL,
													v_DAY_TYPE,
													v_LOAD_VAL,
													v_TX_LOSS_VAL,
													v_DX_LOSS_VAL,
													v_UE_LOSS_VAL,
													v_APPLY_UFE,
													v_POOLS(v_IDX).ALLOCATION_PERCENTAGE);
				END LOOP;
			END IF;

			IF LOGS.IS_DEBUG_ENABLED THEN
				LOGS.LOG_DEBUG(TO_CHAR(v_SERVICE_ID) || ',' || TO_CHAR(v_LOAD_DATE,'HH24:MI') || ',' || TO_CHAR(v_LOAD_VAL) || ',' ||
					TO_CHAR(v_TX_LOSS_VAL) || '(' || TO_CHAR(v_TX_LOSS_FACTOR) || '),' ||
					TO_CHAR(v_DX_LOSS_VAL) || '(' || TO_CHAR(v_DX_LOSS_FACTOR) || '),' ||
					TO_CHAR(v_UE_LOSS_VAL) || '(' || TO_CHAR(v_UE_LOSS_FACTOR) || '),' ||
					TO_CHAR(v_SERVICE_INDEX) || ',' || TO_CHAR(v_UID));
			END IF;
			v_LOAD_DATE := ADD_MINUTES_TO_DATE(v_LOAD_DATE, v_MINUTES);
		END IF;
	END LOOP;
	g_PROFILE_ZERO_COUNT(p_XREF_ID) := v_PROFILE_ZERO_COUNT;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('ASSIGN_SERVICE_LOAD ELAPSED TIME='  || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED));
	END IF;

END ASSIGN_SERVICE_LOAD;
----------------------------------------------------------------------------------------------------
PROCEDURE SCALE_PROFILE_BY_TOU_UF
	(
	p_ACCOUNT_ID IN NUMBER,
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_XREF_ID IN NUMBER,
	p_IS_METER_MODELED IN BOOLEAN,
	p_TOU_USAGE_FACTOR_ID IN NUMBER,
	p_HOLIDAY_SET_ID IN NUMBER,
	p_PROFILE IN OUT NOCOPY GA.NUMBER_TABLE
	) AS

	-- RUNNING TOTALS OF THE LOAD VALUES WITH AND WITHOUT USAGE FACTORS, USED
	-- TO GET THE WEIGHTED AVERAGE OF THE USAGE FACTOR FOR THE DAY
	v_TOTAL_WO_UF NUMBER := 0;
	v_TOTAL_W_UF NUMBER := 0;

	v_USAGE_FACTORS GA.NUMBER_TABLE;
	v_TOU_FACTORS	TOU_USAGE_FACTOR_MAP;
	v_TEMPLATE_ID	TEMPLATE.TEMPLATE_ID%TYPE;

	v_CACHE_KEY		VARCHAR2(32);
	v_SEQ			INTEGER_COLLECTION;

	v_INTERVAL_NUMBER NUMBER(2);
	v_INTERVAL DST_INTERVAL_MAP.INTERVAL%TYPE;
	v_IDX PLS_INTEGER;

BEGIN

    v_INTERVAL := DATE_UTIL.GET_PROFILE_INTERVAL_NAME(p_PROFILE.COUNT);

    IF v_INTERVAL = DATE_UTIL.c_NAME_DAY THEN
        -- JUST USE THE FIRST HOUR
        v_INTERVAL := DATE_UTIL.c_NAME_HOUR;
    ELSIF v_INTERVAL IS NULL THEN
    	v_INTERVAL := DATE_UTIL.c_NAME_HOUR;
		LOGS.LOG_ERROR('A composite profile with an unexpected interval of ' || p_PROFILE.COUNT ||
				' was encountered for ' || TEXT_UTIL.TO_CHAR_ENTITY(p_ACCOUNT_ID, EC.ED_ACCOUNT, TRUE));
	END IF;

	v_INTERVAL_NUMBER := GET_INTERVAL_NUMBER(v_INTERVAL);

	-- IF THE ACCOUNT IS METER MODELED THEN WE GET THE TOU USAGE FACTORS FROM
	-- METER_TOU_US... OTHERWISE ACCOUNT_TOU_US...
	IF NOT p_IS_METER_MODELED THEN
		FOR v_REC IN (SELECT ATUF.TEMPLATE_ID, PER.PERIOD_ID, PER.FACTOR_VAL
					  FROM ACCOUNT_TOU_USAGE_FACTOR ATUF,
					  	   ACCOUNT_TOU_USG_FACTOR_PERIOD PER
					  WHERE ATUF.TOU_USAGE_FACTOR_ID = p_TOU_USAGE_FACTOR_ID
					  	AND PER.TOU_USAGE_FACTOR_ID = p_TOU_USAGE_FACTOR_ID) LOOP
			-- record this entry's template ID
			IF v_TEMPLATE_ID IS NULL THEN
				v_TEMPLATE_ID := v_REC.TEMPLATE_ID;
			END IF;
			-- populate map of usage factor values by period
			v_TOU_FACTORS(v_REC.PERIOD_ID) := v_REC.FACTOR_VAL;
		END LOOP;
	ELSE
		FOR v_REC IN (SELECT MTUF.TEMPLATE_ID, PER.PERIOD_ID, PER.FACTOR_VAL
					  FROM METER_TOU_USAGE_FACTOR MTUF,
					  	   METER_TOU_USAGE_FACTOR_PERIOD PER
					  WHERE MTUF.TOU_USAGE_FACTOR_ID = p_TOU_USAGE_FACTOR_ID
					  	AND PER.TOU_USAGE_FACTOR_ID = p_TOU_USAGE_FACTOR_ID) LOOP
			-- record this entry's template ID
			IF v_TEMPLATE_ID IS NULL THEN
				v_TEMPLATE_ID := v_REC.TEMPLATE_ID;
			END IF;
			-- populate map of usage factor values by period
			v_TOU_FACTORS(v_REC.PERIOD_ID) := v_REC.FACTOR_VAL;
		END LOOP;
	END IF;

	-- no template ID? then above loops must have no rows - meaning no usage factor
	-- values defined. so default to 1.0
	IF v_TEMPLATE_ID IS NULL THEN

		-- no need to touch p_PROFILE -- it's already correct
		-- but set this value to the effective usage factor applied
		g_USAGE_FACTOR(p_XREF_ID) := 1.0;

	ELSE

		-- now gather sequence of usage factor values

		v_CACHE_KEY := v_TEMPLATE_ID||':'||p_HOLIDAY_SET_ID||':'||v_INTERVAL_NUMBER;
		IF NOT g_TOU_PERIOD_IDs.EXISTS(v_CACHE_KEY) THEN
			-- populate sequence of period IDs from tables if needed

			-- USE DST_INTERVAL_MAP AND COLLECT INTO A NUMBER_TABLE SO THAT IT CAN BE SCALED
			-- BY THE ADJUST_FOR_DST METHODS TO MATCH THE APPROPRIATE FACTOR VALUE WITH THE
			-- CORRECT TIME ON DST DAYS (PROFILE WILL ALWAYS BE 24 HRS)
			SELECT DT.PERIOD_ID
			BULK COLLECT INTO v_SEQ
			FROM TEMPLATE_DATES TD,
				TEMPLATE_DAY_TYPE TDT,
				TEMPLATE_DAY_TYPE_PERIOD DT,
				DST_INTERVAL_MAP DIM
			WHERE TD.TEMPLATE_ID = v_TEMPLATE_ID
				AND TD.TIME_ZONE = GA.LOCAL_TIME_ZONE
				AND TD.HOLIDAY_SET_ID = p_HOLIDAY_SET_ID
				AND TD.LOCAL_DATE = p_CAST_CONTEXT.SERVICE_DATE
				AND TD.DAY_TYPE_ID = DT.DAY_TYPE_ID
				AND DT.MINIMUM_INTERVAL_NUMBER >= v_INTERVAL_NUMBER
				AND TDT.DAY_TYPE_ID = TD.DAY_TYPE_ID
				AND DIM.SRC_INTERVAL = DT.TIME_STAMP
				AND DIM.SRC_DST_TYPE = TDT.DST_TYPE
				AND DIM.TGT_DST_TYPE = CONSTANTS.DST_TYPE_NONE
				AND DIM.INTERVAL = v_INTERVAL
			ORDER BY DIM.TGT_INTERVAL;

			g_TOU_PERIOD_IDs(v_CACHE_KEY) := v_SEQ;
		END IF;
		-- generate usg factor sequence using sequence of period IDs in cache and map of usage
		-- factor values by period
		FOR v_IDX IN 1..g_TOU_PERIOD_IDs(v_CACHE_KEY).COUNT LOOP
			IF v_TOU_FACTORS.EXISTS(g_TOU_PERIOD_IDs(v_CACHE_KEY)(v_IDX)) THEN
				-- get value from usage factor map
				v_USAGE_FACTORS(v_IDX) := v_TOU_FACTORS(g_TOU_PERIOD_IDs(v_CACHE_KEY)(v_IDX));
			ELSE
				v_USAGE_FACTORS(v_IDX) := 1.0; -- missing? default to 1.0
			END IF;
		END LOOP;

		-- DST adjustments

		IF UPPER(SUBSTR(LOCAL_TIME_ZONE,2,1)) = 'D' THEN
			-- NORMALLY THIS IS DONE IN ASSIGN_SERVICE_LOAD, BUT IT MAKES CALCULATING
			-- THE WEIGHTED AVERAGE FOR USAGE FACTOR MUCH EASIER IF WE ADJUST IT BEFORE
			-- APPLYING THE USAGE FACTORS
			IF TRUNC(p_CAST_CONTEXT.SERVICE_DATE) =
						TRUNC(DST_SPRING_AHEAD_DATE(p_CAST_CONTEXT.SERVICE_DATE)) THEN
				p_PROFILE := ADJUST_SPRING_AHEAD_DAY(p_PROFILE);
				v_USAGE_FACTORS := ADJUST_SPRING_AHEAD_DAY(v_USAGE_FACTORS);
			ELSIF TRUNC(p_CAST_CONTEXT.SERVICE_DATE) =
						TRUNC(DST_FALL_BACK_DATE(p_CAST_CONTEXT.SERVICE_DATE)) THEN
				p_PROFILE := ADJUST_FALL_BACK_DAY(p_PROFILE);
				v_USAGE_FACTORS := ADJUST_FALL_BACK_DAY(v_USAGE_FACTORS);
			END IF;
		END IF;

		-- apply the usage factors to the incoming shape

		FOR v_IDX IN 1..LEAST(p_PROFILE.COUNT,v_USAGE_FACTORS.COUNT) LOOP
			v_TOTAL_WO_UF := v_TOTAL_WO_UF + p_PROFILE(v_IDX);
			p_PROFILE(v_IDX) := p_PROFILE(v_IDX) * v_USAGE_FACTORS(v_IDX);
			v_TOTAL_W_UF := v_TOTAL_W_UF + p_PROFILE(v_IDX);
		END LOOP;

		-- UPDATE g_USAGE_FACTOR WITH THE WEIGHTED AVERAGE USAGE FACTOR

		IF v_TOTAL_WO_UF <> 0 THEN -- PROTECT AGAINST DIVIDE BY ZERO FOR NULL ACCOUNTS
			g_USAGE_FACTOR(p_XREF_ID) := v_TOTAL_W_UF / v_TOTAL_WO_UF;
		END IF;

		-- Done!
	END IF;

END SCALE_PROFILE_BY_TOU_UF;
----------------------------------------------------------------------------------------------------
PROCEDURE ASSIGN_SERVICE_PROFILE
	(
	p_CAST_CONTEXT IN OUT NOCOPY CAST_CONTEXT_TYPE,
	p_SERVICE_MODEL IN SERVICE_MODEL_TABLE
	) AS

v_ACCOUNT_SERVICE_ID BINARY_INTEGER;
v_PROVIDER_SERVICE_ID BINARY_INTEGER;
v_HAS_PROXY_PROFILE BOOLEAN;
v_PROFILE_IS_CACHED BOOLEAN;
v_AGGREGATE_ID NUMBER(9);
v_PROXY_DAY_METHOD_ID NUMBER(9);
v_PROFILE_SOURCE_DATE DATE;
v_PROFILE_TYPE CHAR(1);
v_END_DATE DATE;
v_USAGE_FACTOR NUMBER(14,6);
v_INDEX BINARY_INTEGER;
v_PROFILE GA.NUMBER_TABLE;
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;

v_TOU_USAGE_FACTOR_ID NUMBER(9) := NULL;

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('ASSIGN_SERVICE_PROFILE');
		LOGS.LOG_DEBUG('USE_INTERVAL_USAGE_IN_BACKCAST=' || UT.TRACE_BOOLEAN(GA.USE_INTERVAL_USAGE_IN_BACKCAST));
	END IF;

-- Clear the Calendar Composite Profile Cache.
	FP.RELEASE_COMPOSITE_PROFILE;

	IF g_SERVICE_ID.COUNT > 0 THEN

		SELECT DECODE(p_CAST_CONTEXT.RUN_MODE, GA.HOUR_MODE, p_CAST_CONTEXT.SERVICE_DATE, GA.DAY_MODE, p_CAST_CONTEXT.SERVICE_DATE, GA.WEEK_MODE, p_CAST_CONTEXT.SERVICE_DATE + 6, LAST_DAY(p_CAST_CONTEXT.SERVICE_DATE)) INTO v_END_DATE FROM DUAL;

		FOR v_XREF_ID IN g_SERVICE_ID.FIRST..g_SERVICE_ID.LAST LOOP
      IF NOT (g_IS_AGGREGATE_ACCOUNT(v_XREF_ID)=1 AND g_METER_TYPE(v_XREF_ID)='I') THEN
			v_ACCOUNT_SERVICE_ID := g_ACCOUNT_SERVICE_ID(v_XREF_ID);
			v_PROVIDER_SERVICE_ID := g_PROVIDER_SERVICE_ID(v_XREF_ID);
			v_AGGREGATE_ID := p_SERVICE_MODEL(g_SERVICE_MODEL_XREF(v_XREF_ID)).AGGREGATE_ID;
			v_PROXY_DAY_METHOD_ID := g_PROXY_DAY_METHOD_ID(v_XREF_ID);
			v_HAS_PROXY_PROFILE := FALSE;

			IF v_AGGREGATE_ID = CONSTANTS.NOT_ASSIGNED AND GA.USE_INTERVAL_USAGE_IN_BACKCAST AND p_CAST_CONTEXT.REQUEST_TYPE = 'B' THEN
				FP.ACTUAL_USAGE_PROFILE(p_CAST_CONTEXT, v_ACCOUNT_SERVICE_ID, v_PROVIDER_SERVICE_ID, g_CAST_CALENDAR_ID(v_XREF_ID), p_CAST_CONTEXT.SERVICE_DATE, v_HAS_PROXY_PROFILE, v_PROFILE_SOURCE_DATE, v_PROFILE);
				v_PROFILE_TYPE := g_ACTUAL_USAGE_PROFILE;
			END IF;

			IF NOT v_HAS_PROXY_PROFILE AND v_AGGREGATE_ID = CONSTANTS.NOT_ASSIGNED AND v_PROXY_DAY_METHOD_ID <> CONSTANTS.NOT_ASSIGNED THEN
				FP.PROXY_USAGE_PROFILE(p_CAST_CONTEXT, v_PROXY_DAY_METHOD_ID, p_SERVICE_MODEL(g_SERVICE_MODEL_XREF(v_XREF_ID)).HOLIDAY_SET_ID,
										v_ACCOUNT_SERVICE_ID, v_PROVIDER_SERVICE_ID, g_CAST_CALENDAR_ID(v_XREF_ID),
										v_HAS_PROXY_PROFILE, v_PROFILE_SOURCE_DATE, v_PROFILE);
				v_PROFILE_TYPE := g_PROXY_USAGE_PROFILE;
			END IF;

			IF p_CAST_CONTEXT.MODEL_ID = GA.GAS_MODEL AND GA.ENABLE_CUSTOMER_MODEL AND g_CAST_CALENDAR_ID(v_XREF_ID) = g_CUSTOMER_USAGE_WRF_CALENDAR THEN
					v_INDEX := g_SERVICE_MODEL_XREF(v_XREF_ID);
					FW.CUSTOMER_USAGE_WRF_PROFILE(p_CAST_CONTEXT, p_SERVICE_MODEL(v_INDEX).AGGREGATE_ID, v_PROFILE);
					v_HAS_PROXY_PROFILE := TRUE;
					v_PROFILE_TYPE := g_CUSTOMER_USAGE_WRF_PROFILE;
					v_PROFILE_SOURCE_DATE := p_CAST_CONTEXT.SERVICE_DATE;
				END IF;

			IF NOT v_HAS_PROXY_PROFILE THEN
			  --Caching is optional via the GA switch.  See GA for comments.
			  	IF GA.ENABLE_RUNTIME_PROFILE_CACHE THEN
				   v_PROFILE_IS_CACHED := FP.COMPOSITE_PROFILE_FROM_CACHE(p_CAST_CONTEXT, g_STATION_ID(v_XREF_ID), g_CAST_CALENDAR_ID(v_XREF_ID), v_PROFILE_TYPE, v_PROFILE_SOURCE_DATE, v_PROFILE);
				   IF NOT v_PROFILE_IS_CACHED THEN
				 	  	v_INDEX := g_SERVICE_MODEL_XREF(v_XREF_ID);
				   	FP.COMPOSITE_PROFILE_FOR_CALENDAR(p_CAST_CONTEXT, g_STATION_ID(v_XREF_ID), g_CAST_CALENDAR_ID(v_XREF_ID), p_SERVICE_MODEL(v_INDEX).EDC_ID, TRUE, v_PROFILE_TYPE, v_PROFILE_SOURCE_DATE, v_PROFILE);
				      FP.COMPOSITE_PROFILE_TO_CACHE(p_CAST_CONTEXT, g_STATION_ID(v_XREF_ID), g_CAST_CALENDAR_ID(v_XREF_ID), v_PROFILE_TYPE, v_PROFILE_SOURCE_DATE, v_PROFILE);
				   END IF;
				ELSE
				   v_INDEX := g_SERVICE_MODEL_XREF(v_XREF_ID);
				   FP.COMPOSITE_PROFILE_FOR_CALENDAR(p_CAST_CONTEXT, g_STATION_ID(v_XREF_ID), g_CAST_CALENDAR_ID(v_XREF_ID), p_SERVICE_MODEL(v_INDEX).EDC_ID, TRUE, v_PROFILE_TYPE, v_PROFILE_SOURCE_DATE, v_PROFILE);
			   END IF;
			END IF;

-- Accumulate the Profile Results to the Global Buffer.
			IF v_PROFILE.COUNT > 0 THEN
				g_PROFILE_TYPE(v_XREF_ID) := v_PROFILE_TYPE;
				g_PROFILE_SOURCE_DATE(v_XREF_ID) := v_PROFILE_SOURCE_DATE;
				v_INDEX := g_SERVICE_MODEL_XREF(v_XREF_ID);

				v_TOU_USAGE_FACTOR_ID := CX.GET_TOU_USAGE_FACTOR_ID(v_ACCOUNT_SERVICE_ID, p_CAST_CONTEXT.SERVICE_DATE);

				IF v_TOU_USAGE_FACTOR_ID IS NOT NULL THEN
					IF v_PROFILE_TYPE NOT IN (g_PROXY_USAGE_PROFILE, g_ACTUAL_USAGE_PROFILE) THEN
						-- SCALE THE PROFILE TABLE BY THE TOU USAGE FACTORS
						SCALE_PROFILE_BY_TOU_UF(p_SERVICE_MODEL(v_INDEX).ACCOUNT_ID,
											p_CAST_CONTEXT,
											v_XREF_ID,
											NVL(p_SERVICE_MODEL(v_INDEX).METER_ID, 0) <> 0,
											v_TOU_USAGE_FACTOR_ID,
											p_SERVICE_MODEL(v_INDEX).HOLIDAY_SET_ID,
											v_PROFILE);
					END IF;
				END IF;

				ASSIGN_SERVICE_LOAD(p_CAST_CONTEXT, v_ACCOUNT_SERVICE_ID, p_SERVICE_MODEL(v_INDEX).EDC_ID,
					CASE WHEN v_TOU_USAGE_FACTOR_ID IS NOT NULL OR v_PROFILE_TYPE IN (g_PROXY_USAGE_PROFILE, g_ACTUAL_USAGE_PROFILE)
                        THEN FALSE ELSE TRUE END, v_XREF_ID, v_PROFILE);
			-- Assign the profile to the settlement profile in backcast mode and the account option is specified.
				IF p_CAST_CONTEXT.RUN_MODE = GA.HOUR_MODE AND p_CAST_CONTEXT.REQUEST_TYPE = 'B' AND g_IS_CREATE_SETTLEMENT_PROFILE(v_XREF_ID) = 1 THEN
					IF p_SERVICE_MODEL(g_SERVICE_MODEL_XREF(v_XREF_ID)).AGGREGATE_ID = CONSTANTS.NOT_ASSIGNED
						AND v_TOU_USAGE_FACTOR_ID IS NULL
                        AND v_PROFILE_TYPE NOT IN (g_PROXY_USAGE_PROFILE, g_ACTUAL_USAGE_PROFILE) THEN
						v_USAGE_FACTOR := g_USAGE_FACTOR(v_XREF_ID);
					ELSE
						v_USAGE_FACTOR := 1;
					END IF;

					IF NOT FP.SETTLEMENT_PROFILE_EXISTS(g_SETTLEMENT_PROFILE_ID(v_XREF_ID)) THEN
						FP.ASSIGN_SETTLEMENT_PROFILE(p_CAST_CONTEXT, g_SETTLEMENT_PROFILE_ID(v_XREF_ID), v_USAGE_FACTOR, v_PROFILE);
					END IF;
				END IF;
			END IF;
      END IF;
			-- Update the process monitor and give the user an opportunity to terminate the process.
			LOGS.INCREMENT_PROCESS_PROGRESS();
		END LOOP;
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('ASSIGN_SERVICE_PROFILE ELAPSED TIME='  || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED));
	END IF;

END ASSIGN_SERVICE_PROFILE;
----------------------------------------------------------------------------------------------------
PROCEDURE FETCH_ENROLLMENT
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE
	) AS

v_USAGE_FACTOR_QUALIFIER NUMBER(1);
v_XREF_ID BINARY_INTEGER;
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;

v_LT_BEGIN_DATE DATE;
v_LT_END_DATE DATE;
v_LT_CASE_ID NUMBER(9);


CURSOR c_VERSIONED_AGGREGATE IS
	SELECT A.ACCOUNT_SERVICE_ID,
		NVL(B.SERVICE_ACCOUNTS,0) "SERVICE_ACCOUNTS",
		NVL(B.USAGE_FACTOR,0) + v_USAGE_FACTOR_QUALIFIER "USAGE_FACTOR"
	FROM ACCOUNT_SERVICE A, AGGREGATE_ACCOUNT_SERVICE B
	WHERE NOT A.AGGREGATE_ID = CONSTANTS.NOT_ASSIGNED
		AND B.CASE_ID = p_CAST_CONTEXT.ENROLLMENT_CASE_ID
		AND B.AGGREGATE_ID = A.AGGREGATE_ID
		AND B.SERVICE_DATE = p_CAST_CONTEXT.SERVICE_DATE
		AND B.AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM AGGREGATE_ACCOUNT_SERVICE
			WHERE AGGREGATE_ID = A.AGGREGATE_ID	--Use smaller, non-temporal table (A) for speed - wjc
				AND CASE_ID = p_CAST_CONTEXT.ENROLLMENT_CASE_ID  --Specify case for speed - wjc
				AND SERVICE_DATE = B.SERVICE_DATE
				AND AS_OF_DATE <= p_CAST_CONTEXT.INPUT_AS_OF_DATE);

CURSOR c_NON_VERSIONED_AGGREGATE IS
	SELECT A.ACCOUNT_SERVICE_ID,
		NVL(B.SERVICE_ACCOUNTS,0) "SERVICE_ACCOUNTS",
		NVL(B.USAGE_FACTOR,0) + v_USAGE_FACTOR_QUALIFIER "USAGE_FACTOR"
	FROM ACCOUNT_SERVICE A, AGGREGATE_ACCOUNT_SERVICE B
	WHERE NOT A.AGGREGATE_ID = CONSTANTS.NOT_ASSIGNED
		AND B.CASE_ID = p_CAST_CONTEXT.ENROLLMENT_CASE_ID
		AND B.AGGREGATE_ID = A.AGGREGATE_ID
		AND B.SERVICE_DATE = p_CAST_CONTEXT.SERVICE_DATE
		AND B.AS_OF_DATE = LOW_DATE;

CURSOR c_LONG_TERM_AGGREGATE IS
	SELECT A.ACCOUNT_SERVICE_ID,
		CASE WHEN SUM(E.POINT_VAL) = 0 THEN 0 ELSE SUM(NVL(B.SERVICE_ACCOUNTS,0)*E.POINT_VAL)/SUM(E.POINT_VAL) END "SERVICE_ACCOUNTS",
		CASE WHEN SUM(E.POINT_VAL) = 0 THEN 0 ELSE SUM((NVL(B.USAGE_FACTOR,0) + v_USAGE_FACTOR_QUALIFIER) *E.POINT_VAL)/SUM(E.POINT_VAL) END "USAGE_FACTOR"
	FROM ACCOUNT_SERVICE A, AGGREGATE_ACCOUNT_SERVICE B, ACCOUNT_CALENDAR C, CALENDAR_PROFILE D, LOAD_PROFILE_POINT E
	WHERE NOT A.AGGREGATE_ID = CONSTANTS.NOT_ASSIGNED
		AND B.CASE_ID = p_CAST_CONTEXT.ENROLLMENT_CASE_ID
		AND B.AGGREGATE_ID = A.AGGREGATE_ID
		AND B.SERVICE_DATE BETWEEN v_LT_BEGIN_DATE AND v_LT_END_DATE
		AND B.AS_OF_DATE = g_LOW_DATE
		AND C.CASE_ID = v_LT_CASE_ID
		AND C.ACCOUNT_ID = A.ACCOUNT_ID
		AND C.CALENDAR_TYPE = FL.g_CAL_TYPE_DAILY_TOTAL
		AND C.BEGIN_DATE <= v_LT_END_DATE
		AND NVL(C.END_DATE, v_LT_BEGIN_DATE) >= v_LT_BEGIN_DATE
		AND D.CALENDAR_ID = C.CALENDAR_ID
		AND D.BEGIN_DATE <= v_LT_END_DATE
		AND NVL(D.END_DATE, v_LT_BEGIN_DATE) >= v_LT_BEGIN_DATE
		AND E.PROFILE_ID = D.PROFILE_ID
		AND E.POINT_INDEX = g_DEFAULT_POINT_INDEX
		AND E.POINT_DATE = B.SERVICE_DATE
		AND E.AS_OF_DATE = g_LOW_DATE
	GROUP BY A.ACCOUNT_SERVICE_ID;

BEGIN

	IF GA.USAGE_FACTOR_PER_UNIT_OPTION THEN
	    v_USAGE_FACTOR_QUALIFIER := 1;
	ELSE
	    v_USAGE_FACTOR_QUALIFIER := 0;
	END IF;

	--Get a weighted average Enrollment and UF if this is a LongTerm run.
	IF p_CAST_CONTEXT.RUN_MODE IN (GA.WEEK_MODE, GA.MONTH_MODE) THEN
		FL.GET_LONG_TERM_DATE_RANGE(p_CAST_CONTEXT.SERVICE_DATE, p_CAST_CONTEXT.SERVICE_DATE, p_CAST_CONTEXT.RUN_MODE, v_LT_BEGIN_DATE, v_LT_END_DATE);
		v_LT_CASE_ID := FL.GET_LONG_TERM_CASE_ID(p_CAST_CONTEXT.RUN_MODE, TRUE);
		FOR v_AGGREGATE IN c_LONG_TERM_AGGREGATE LOOP
			IF g_SERVICE_XREF.EXISTS(v_AGGREGATE.ACCOUNT_SERVICE_ID) THEN
				v_XREF_ID := g_SERVICE_XREF(v_AGGREGATE.ACCOUNT_SERVICE_ID);
				g_SERVICE_ACCOUNTS(v_XREF_ID) := v_AGGREGATE.SERVICE_ACCOUNTS;
				IF p_CAST_CONTEXT.APPLY_USAGE_FACTOR = 1 THEN
					g_USAGE_FACTOR(v_XREF_ID) := v_AGGREGATE.USAGE_FACTOR;
				ELSE
					g_USAGE_FACTOR(v_XREF_ID) := 1;
				END IF;
			END IF;
		END LOOP;
	ELSIF GA.VERSION_AGGREGATE_ACCOUNT_SVC THEN
		FOR v_AGGREGATE IN c_VERSIONED_AGGREGATE LOOP
			IF g_SERVICE_XREF.EXISTS(v_AGGREGATE.ACCOUNT_SERVICE_ID) THEN
				v_XREF_ID := g_SERVICE_XREF(v_AGGREGATE.ACCOUNT_SERVICE_ID);
				g_SERVICE_ACCOUNTS(v_XREF_ID) := v_AGGREGATE.SERVICE_ACCOUNTS;
				IF p_CAST_CONTEXT.APPLY_USAGE_FACTOR = 1 THEN
					g_USAGE_FACTOR(v_XREF_ID) := v_AGGREGATE.USAGE_FACTOR;
				ELSE
					g_USAGE_FACTOR(v_XREF_ID) := 1;
				END IF;
			END IF;
		END LOOP;
	ELSE
		FOR v_AGGREGATE IN c_NON_VERSIONED_AGGREGATE LOOP
			IF g_SERVICE_XREF.EXISTS(v_AGGREGATE.ACCOUNT_SERVICE_ID) THEN
				v_XREF_ID := g_SERVICE_XREF(v_AGGREGATE.ACCOUNT_SERVICE_ID);
				g_SERVICE_ACCOUNTS(v_XREF_ID) := v_AGGREGATE.SERVICE_ACCOUNTS;
				IF p_CAST_CONTEXT.APPLY_USAGE_FACTOR = 1 THEN
					g_USAGE_FACTOR(v_XREF_ID) := v_AGGREGATE.USAGE_FACTOR;
				ELSE
					g_USAGE_FACTOR(v_XREF_ID) := 1;
				END IF;
			END IF;
		END LOOP;
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('FETCH_ENROLLMENT ELAPSED TIME='  || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED));
	END IF;

END FETCH_ENROLLMENT;
----------------------------------------------------------------------------------------------------
PROCEDURE FETCH_SERVICE
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_SERVICE_MODEL IN SERVICE_MODEL_TABLE
	) AS

v_ACCOUNT_SERVICE_ID NUMBER(9);
v_INDEX BINARY_INTEGER;
v_XREF_ID BINARY_INTEGER;
v_SERVICE_DATE DATE := p_CAST_CONTEXT.SERVICE_DATE;
v_SC_ID NUMBER(9);
v_SERVICE_ZONE_ID NUMBER(9);
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;

v_DAYNAME VARCHAR2(3);

BEGIN

-- Initialize Accumulator Cache.
	INITIALIZE_SERVICE;
	IF p_CAST_CONTEXT.REQUEST_TYPE IN ('B','S') THEN
		FP.RELEASE_SETTLEMENT;
	END IF;

	-- Loop over the Service Model and process the ones in temporal scope for the service date>
	v_INDEX := p_SERVICE_MODEL.FIRST;
	WHILE v_INDEX <= p_SERVICE_MODEL.LAST LOOP

		IF v_SERVICE_DATE BETWEEN p_SERVICE_MODEL(v_INDEX).ACCOUNT_BEGIN_DATE AND p_SERVICE_MODEL(v_INDEX).ACCOUNT_END_DATE
			AND v_SERVICE_DATE BETWEEN p_SERVICE_MODEL(v_INDEX).EDC_BEGIN_DATE AND p_SERVICE_MODEL(v_INDEX).EDC_END_DATE
			AND v_SERVICE_DATE BETWEEN p_SERVICE_MODEL(v_INDEX).ESP_BEGIN_DATE AND p_SERVICE_MODEL(v_INDEX).ESP_END_DATE
			AND v_SERVICE_DATE BETWEEN p_SERVICE_MODEL(v_INDEX).PSE_BEGIN_DATE AND p_SERVICE_MODEL(v_INDEX).PSE_END_DATE
			AND v_SERVICE_DATE BETWEEN p_SERVICE_MODEL(v_INDEX).SERVICE_LOCATION_BEGIN_DATE AND p_SERVICE_MODEL(v_INDEX).SERVICE_LOCATION_END_DATE
			AND v_SERVICE_DATE BETWEEN p_SERVICE_MODEL(v_INDEX).METER_BEGIN_DATE AND p_SERVICE_MODEL(v_INDEX).METER_END_DATE THEN

			v_ACCOUNT_SERVICE_ID := p_SERVICE_MODEL(v_INDEX).ACCOUNT_SERVICE_ID;
			v_XREF_ID := g_SERVICE_XREF.COUNT + 1;
			g_SERVICE_MODEL_XREF(v_XREF_ID) := v_INDEX; -- Reference to Primary Service Model Cache.
			g_SERVICE_XREF(v_ACCOUNT_SERVICE_ID) := v_XREF_ID;
			g_SERVICE_DATE(v_XREF_ID) := v_SERVICE_DATE;
			g_ACCOUNT_SERVICE_ID(v_XREF_ID) := p_SERVICE_MODEL(v_INDEX).ACCOUNT_SERVICE_ID;
			g_PROVIDER_SERVICE_ID(v_XREF_ID) := p_SERVICE_MODEL(v_INDEX).PROVIDER_SERVICE_ID;
			g_POOL_ID(v_XREF_ID) := p_SERVICE_MODEL(v_INDEX).POOL_ID;
			g_STATION_ID(v_XREF_ID) := p_SERVICE_MODEL(v_INDEX).STATION_ID;
			g_IS_UFE_PARTICIPANT(v_XREF_ID) := p_SERVICE_MODEL(v_INDEX).IS_UFE_PARTICIPANT;
			g_IS_CREATE_SETTLEMENT_PROFILE(v_XREF_ID) := p_SERVICE_MODEL(v_INDEX).IS_CREATE_SETTLEMENT_PROFILE;
			g_METER_TYPE(v_XREF_ID) := p_SERVICE_MODEL(v_INDEX).METER_TYPE;
			g_IS_EXTERNAL_FORECAST(v_XREF_ID) := p_SERVICE_MODEL(v_INDEX).IS_EXTERNAL_FORECAST;

			IF p_SERVICE_MODEL(v_INDEX).AGGREGATE_ID = 0 THEN
				g_SERVICE_ACCOUNTS(v_XREF_ID) := 1;
				g_IS_AGGREGATE_ACCOUNT(v_XREF_ID) := 0;
			ELSE
				g_SERVICE_ACCOUNTS(v_XREF_ID) := 0;
				g_IS_AGGREGATE_ACCOUNT(v_XREF_ID) := 1;
			END IF;

			g_SCHEDULE_GROUP_ID(v_XREF_ID) := CX.GET_SCHEDULE_GROUP_ID(v_ACCOUNT_SERVICE_ID, p_CAST_CONTEXT.SERVICE_DATE);
			g_SERVICE_POINT_ID(v_XREF_ID) := CX.GET_SERVICE_POINT_ID(g_SCHEDULE_GROUP_ID(v_XREF_ID), p_SERVICE_MODEL(v_INDEX).SERVICE_LOCATION_ID);
			g_CAST_CALENDAR_ID(v_XREF_ID) := CX.GET_CALENDAR_ID(v_ACCOUNT_SERVICE_ID, p_CAST_CONTEXT.SERVICE_DATE, p_CAST_CONTEXT.REQUEST_TYPE);
			g_PROXY_DAY_METHOD_ID(v_XREF_ID) := CX.GET_PROXY_DAY_METHOD_ID(v_ACCOUNT_SERVICE_ID, p_CAST_CONTEXT.SERVICE_DATE, p_CAST_CONTEXT.REQUEST_TYPE);
			g_SUPPLY_TYPE(v_XREF_ID) := CX.GET_ESP_SUPPLY_TYPE(p_SERVICE_MODEL(v_INDEX).ESP_ID);
			g_IS_BUG(v_XREF_ID) := CX.GET_PSE_IS_BUG(p_SERVICE_MODEL(v_INDEX).PSE_ID);
			g_IS_WHOLESALE(v_XREF_ID) := CX.GET_IS_WHOLESALE(p_SERVICE_MODEL(v_INDEX).SERVICE_LOCATION_ID);

			v_SC_ID := CX.GET_SCHEDULE_COORDINATOR_ID(p_SERVICE_MODEL(v_INDEX).EDC_ID, g_SCHEDULE_GROUP_ID(v_XREF_ID));
			v_SERVICE_ZONE_ID := CX.GET_SERVICE_ZONE_ID(p_SERVICE_MODEL(v_INDEX).SERVICE_LOCATION_ID, g_SCHEDULE_GROUP_ID(v_XREF_ID));
			g_IS_AGGREGATE_POOL(v_XREF_ID) := CX.GET_IS_AGGREGATE_POOL(g_POOL_ID(v_XREF_ID));

			g_SERVICE_DELIVERY_ID(v_XREF_ID) := CX.GET_SERVICE_DELIVERY_ID(g_POOL_ID(v_XREF_ID), g_SERVICE_POINT_ID(v_XREF_ID), v_SERVICE_ZONE_ID, g_SCHEDULE_GROUP_ID(v_XREF_ID), v_SC_ID, g_SUPPLY_TYPE(v_XREF_ID), g_IS_BUG(v_XREF_ID), g_IS_WHOLESALE(v_XREF_ID), g_IS_AGGREGATE_POOL(v_XREF_ID));

			g_SERVICE_ID(v_XREF_ID) := CX.GET_SERVICE_ID(p_CAST_CONTEXT, g_PROVIDER_SERVICE_ID(v_XREF_ID), g_ACCOUNT_SERVICE_ID(v_XREF_ID), g_SERVICE_DELIVERY_ID(v_XREF_ID));

			g_SERVICE_OBLIGATION_ID(v_XREF_ID) := CX.GET_SERVICE_OBLIGATION_ID(p_CAST_CONTEXT, g_PROVIDER_SERVICE_ID(v_XREF_ID), g_SERVICE_DELIVERY_ID(v_XREF_ID));

			IF p_CAST_CONTEXT.APPLY_USAGE_FACTOR = 1 THEN
				g_USAGE_FACTOR(v_XREF_ID) := CX.GET_USAGE_FACTOR(v_ACCOUNT_SERVICE_ID, p_CAST_CONTEXT.SERVICE_DATE);
			ELSE
				g_USAGE_FACTOR(v_XREF_ID) := 1;
			END IF;

			g_GROWTH_FACTOR(v_XREF_ID) := CX.GET_GROWTH_FACTOR(v_ACCOUNT_SERVICE_ID, p_CAST_CONTEXT.SERVICE_DATE, p_CAST_CONTEXT.RUN_MODE);

			g_PROFILE_TYPE(v_XREF_ID) := NULL;
			g_PROFILE_SOURCE_DATE(v_XREF_ID) := NULL;
			g_PROFILE_ZERO_COUNT(v_XREF_ID) := 0;

			IF p_CAST_CONTEXT.REQUEST_TYPE = 'B' THEN
				g_SETTLEMENT_PROFILE_ID(v_XREF_ID) := CX.GET_SETTLEMENT_PROFILE_ID(v_ACCOUNT_SERVICE_ID, p_CAST_CONTEXT.SERVICE_DATE);
			END IF;

			g_SERVICE_INTERVALS(v_XREF_ID) := CASE p_CAST_CONTEXT.RUN_MODE
				WHEN  GA.WEEK_MODE THEN 7
				WHEN  GA.MONTH_MODE THEN TO_NUMBER(TO_CHAR(LAST_DAY(v_SERVICE_DATE),'DD')) ELSE 1  END;
		END IF;

		v_INDEX := p_SERVICE_MODEL.NEXT(v_INDEX);

	END LOOP;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('FETCH_SERVICE ELAPSED TIME='  || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED));
	END IF;

END FETCH_SERVICE;
----------------------------------------------------------------------------------------------------

PROCEDURE DELETE_SERVICE(p_CAST_CONTEXT IN CAST_CONTEXT_TYPE) AS
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;
v_CUT_BEGIN	DATE;
v_CUT_END	DATE;
v_LOCAL_TZ	VARCHAR2(8);
v_OFFS1		NUMBER;
v_OFFS2		NUMBER;
BEGIN
--@@Begin Implementation Override --
   IF l_ENABLE_SERVICE_PARTITIONING AND p_CAST_CONTEXT.EDC_ID = g_ALL AND p_CAST_CONTEXT.ESP_ID = g_ALL AND p_CAST_CONTEXT.ACCOUNT_ID = g_ALL THEN
      TRUNCATE_TABLESPACE('SERVICE_LOAD',  p_CAST_CONTEXT.BEGIN_DATE, p_CAST_CONTEXT.END_DATE, p_CAST_CONTEXT.REQUEST_TYPE);
      TRUNCATE_TABLESPACE('SERVICE_STATE', p_CAST_CONTEXT.BEGIN_DATE, p_CAST_CONTEXT.END_DATE, p_CAST_CONTEXT.REQUEST_TYPE);
      RETURN;
   END IF;
--@@End Implementation Override --
-- Delete for Single Account Run.
	IF p_CAST_CONTEXT.ACCOUNT_PROCESS_MODE = 0 THEN
		UT.CUT_DATE_RANGE(p_CAST_CONTEXT.MODEL_ID, p_CAST_CONTEXT.BEGIN_DATE, p_CAST_CONTEXT.END_DATE, GA.LOCAL_TIME_ZONE, v_CUT_BEGIN, v_CUT_END);
		-- Instead of relying on SERVICE_STATE trigger to clean up SERVICE_LOAD, let's issue a delete on SERVICE_LOAD
		-- to help it perform more quickly.
		DELETE SERVICE_LOAD
		WHERE ROWID IN
			(SELECT SL.ROWID
			 FROM ACCOUNT_SERVICE ASVC, SERVICE S, SERVICE_LOAD SL
			 WHERE ASVC.ACCOUNT_ID = p_CAST_CONTEXT.ACCOUNT_ID
				AND S.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
				AND S.SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
				AND S.AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE
				AND S.ACCOUNT_SERVICE_ID = ASVC.ACCOUNT_SERVICE_ID
				AND SL.SERVICE_ID = S.SERVICE_ID
				AND SL.SERVICE_CODE = p_CAST_CONTEXT.REQUEST_TYPE
				AND SL.LOAD_DATE BETWEEN v_CUT_BEGIN AND v_CUT_END);
		DELETE SERVICE_STATE
		WHERE ROWID IN
			(SELECT SS.ROWID
			 FROM ACCOUNT_SERVICE ASVC, SERVICE S, SERVICE_STATE SS
			 WHERE ASVC.ACCOUNT_ID = p_CAST_CONTEXT.ACCOUNT_ID
				AND S.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
				AND S.SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
				AND S.AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE
				AND S.ACCOUNT_SERVICE_ID = ASVC.ACCOUNT_SERVICE_ID
				AND SS.SERVICE_ID = S.SERVICE_ID
				AND SS.SERVICE_CODE = p_CAST_CONTEXT.REQUEST_TYPE
				AND SS.SERVICE_DATE BETWEEN p_CAST_CONTEXT.BEGIN_DATE AND p_CAST_CONTEXT.END_DATE
				AND SS.HAS_DETAILS = 1);
-- Delete In Bulk --
	ELSE
		IF p_CAST_CONTEXT.MODEL_ID = GA.GAS_MODEL THEN
			v_LOCAL_TZ := GA.CUT_TIME_ZONE; -- daily data is not TZ-adjusted
			v_OFFS1 := 0; -- midnight is the start of data for gas/daily
			v_OFFS2 := 1 - 1/86400; -- up to (excluding) midnight is end of data range
		ELSE
			v_LOCAL_TZ := GA.LOCAL_TIME_ZONE;
			v_OFFS1 := 1/86400; -- 1 sec past midnight is the start of data for electric/sub-daily
			v_OFFS2 := 1; -- up through (including) midnight is the last interval (HE 24) of data
		END IF;
		-- Instead of relying on SERVICE_STATE trigger to clean up SERVICE_LOAD, let's issue a bulk delete on SERVICE_LOAD
		-- to help it perform more quickly. We have join SERVICE_STATE into the delete operation to apply the correct
		-- behavior for the specified ACCOUNT_PROCESS_MODE.
		DELETE SERVICE_LOAD
		WHERE ROWID IN
			(SELECT SL.ROWID
			FROM ENERGY_SERVICE_PROVIDER ESP, PROVIDER_SERVICE PS,SERVICE S, SERVICE_STATE SS, SERVICE_LOAD SL
			WHERE (p_CAST_CONTEXT.ESP_IS_CERTIFIED = CONSTANTS.NOT_ASSIGNED OR UPPER(SUBSTR(ESP.ESP_TYPE,1,1)) = 'C')
			  AND PS.ESP_ID = ESP.ESP_ID
			  AND (p_CAST_CONTEXT.EDC_ID = g_ALL OR PS.EDC_ID = p_CAST_CONTEXT.EDC_ID)
			  AND (p_CAST_CONTEXT.ESP_ID = g_ALL OR PS.ESP_ID = p_CAST_CONTEXT.ESP_ID)
			  AND S.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
			  AND S.SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
			  AND S.AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE
			  AND S.PROVIDER_SERVICE_ID = PS.PROVIDER_SERVICE_ID
			  AND SS.SERVICE_ID = S.SERVICE_ID
			  AND SS.SERVICE_CODE = p_CAST_CONTEXT.REQUEST_TYPE
			  AND SS.SERVICE_DATE BETWEEN p_CAST_CONTEXT.BEGIN_DATE AND p_CAST_CONTEXT.END_DATE
			  AND SS.HAS_DETAILS = 1
			  AND SS.IS_AGGREGATE_ACCOUNT = DECODE(p_CAST_CONTEXT.ACCOUNT_PROCESS_MODE, 1, SS.IS_AGGREGATE_ACCOUNT, 2, 1, 3, 0, 4, SS.IS_AGGREGATE_ACCOUNT, 9)
        AND NOT (SS.IS_AGGREGATE_ACCOUNT=1 AND SS.METER_TYPE='I')
			  AND SL.SERVICE_ID = SS.SERVICE_ID
			  AND SL.SERVICE_CODE = SS.SERVICE_CODE
			  AND SL.LOAD_DATE BETWEEN (TO_CUT(TRUNC(SS.SERVICE_DATE), v_LOCAL_TZ)+v_OFFS1) AND (TO_CUT(TRUNC(SS.SERVICE_DATE), v_LOCAL_TZ)+v_OFFS2));
		DELETE SERVICE_STATE
		WHERE ROWID IN
			(SELECT SS.ROWID
			FROM ENERGY_SERVICE_PROVIDER ESP, PROVIDER_SERVICE PS,SERVICE S, SERVICE_STATE SS
			WHERE (p_CAST_CONTEXT.ESP_IS_CERTIFIED = CONSTANTS.NOT_ASSIGNED OR UPPER(SUBSTR(ESP.ESP_TYPE,1,1)) = 'C')
			  AND PS.ESP_ID = ESP.ESP_ID
			  AND (p_CAST_CONTEXT.EDC_ID = g_ALL OR PS.EDC_ID = p_CAST_CONTEXT.EDC_ID)
			  AND (p_CAST_CONTEXT.ESP_ID = g_ALL OR PS.ESP_ID = p_CAST_CONTEXT.ESP_ID)
			  AND S.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
			  AND S.SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
			  AND S.AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE
			  AND S.PROVIDER_SERVICE_ID = PS.PROVIDER_SERVICE_ID
			  AND SS.SERVICE_ID = S.SERVICE_ID
			  AND SS.SERVICE_CODE = p_CAST_CONTEXT.REQUEST_TYPE
			  AND SS.SERVICE_DATE BETWEEN p_CAST_CONTEXT.BEGIN_DATE AND p_CAST_CONTEXT.END_DATE
			  AND SS.HAS_DETAILS = 1
			  AND SS.IS_AGGREGATE_ACCOUNT = DECODE(p_CAST_CONTEXT.ACCOUNT_PROCESS_MODE, 1, SS.IS_AGGREGATE_ACCOUNT, 2, 1, 3, 0, 4, SS.IS_AGGREGATE_ACCOUNT, 9)
        AND NOT (SS.IS_AGGREGATE_ACCOUNT=1 AND SS.METER_TYPE='I'));
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('DELETE_SERVICE ELAPSED TIME='  || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED));
	END IF;

END DELETE_SERVICE;
------------------------------------------------------------------------------------------------
PROCEDURE DELETE_SERVICE_NON_INTERVAL
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE
	) AS

v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;
v_CUT_BEGIN	DATE;
v_CUT_END	DATE;
v_LOCAL_TZ	VARCHAR2(8);
v_OFFS1		NUMBER;
v_OFFS2		NUMBER;
BEGIN

-- Delete for Single Account Run.
	IF p_CAST_CONTEXT.ACCOUNT_PROCESS_MODE = 0 THEN

		UT.CUT_DATE_RANGE(p_CAST_CONTEXT.MODEL_ID, p_CAST_CONTEXT.BEGIN_DATE, p_CAST_CONTEXT.END_DATE, GA.LOCAL_TIME_ZONE, v_CUT_BEGIN, v_CUT_END);

		-- Instead of relying on SERVICE_STATE trigger to clean up SERVICE_LOAD, let's issue a delete on SERVICE_LOAD
		-- to help it perform more quickly.
		DELETE SERVICE_LOAD
		WHERE ROWID IN
			(SELECT SL.ROWID
			 FROM ACCOUNT A, ACCOUNT_SERVICE ASVC, SERVICE S, SERVICE_LOAD SL
			 WHERE A.ACCOUNT_ID = ASVC.ACCOUNT_ID
        AND A.ACCOUNT_METER_TYPE != 'Interval'
        AND ASVC.ACCOUNT_ID = p_CAST_CONTEXT.ACCOUNT_ID
				AND S.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
				AND S.SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
				AND S.AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE
				AND S.ACCOUNT_SERVICE_ID = ASVC.ACCOUNT_SERVICE_ID
				AND SL.SERVICE_ID = S.SERVICE_ID
				AND SL.SERVICE_CODE = p_CAST_CONTEXT.REQUEST_TYPE
				AND SL.LOAD_DATE BETWEEN v_CUT_BEGIN AND v_CUT_END);

		DELETE SERVICE_STATE
		WHERE ROWID IN
			(SELECT SS.ROWID
			 FROM ACCOUNT A ,ACCOUNT_SERVICE ASVC, SERVICE S, SERVICE_STATE SS
			 WHERE A.ACCOUNT_ID = ASVC.ACCOUNT_ID
        AND A.ACCOUNT_METER_TYPE != 'Interval'
        AND ASVC.ACCOUNT_ID = p_CAST_CONTEXT.ACCOUNT_ID
				AND S.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
				AND S.SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
				AND S.AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE
				AND S.ACCOUNT_SERVICE_ID = ASVC.ACCOUNT_SERVICE_ID
				AND SS.SERVICE_ID = S.SERVICE_ID
				AND SS.SERVICE_CODE = p_CAST_CONTEXT.REQUEST_TYPE
				AND SS.SERVICE_DATE BETWEEN p_CAST_CONTEXT.BEGIN_DATE AND p_CAST_CONTEXT.END_DATE
				AND SS.HAS_DETAILS = 1);

-- Delete in bulk
	ELSE

		IF p_CAST_CONTEXT.MODEL_ID = GA.GAS_MODEL THEN
			v_LOCAL_TZ := GA.CUT_TIME_ZONE; -- daily data is not TZ-adjusted
			v_OFFS1 := 0; -- midnight is the start of data for gas/daily
			v_OFFS2 := 1 - 1/86400; -- up to (excluding) midnight is end of data range
		ELSE
			v_LOCAL_TZ := GA.LOCAL_TIME_ZONE;
			v_OFFS1 := 1/86400; -- 1 sec past midnight is the start of data for electric/sub-daily
			v_OFFS2 := 1; -- up through (including) midnight is the last interval (HE 24) of data
		END IF;

		-- Instead of relying on SERVICE_STATE trigger to clean up SERVICE_LOAD, let's issue a bulk delete on SERVICE_LOAD
		-- to help it perform more quickly. We have join SERVICE_STATE into the delete operation to apply the correct
		-- behavior for the specified ACCOUNT_PROCESS_MODE.
		DELETE SERVICE_LOAD
		WHERE ROWID IN
			(SELECT SL.ROWID
			FROM ACCOUNT A ,ACCOUNT_SERVICE ASVC, ENERGY_SERVICE_PROVIDER ESP, PROVIDER_SERVICE PS,SERVICE S, SERVICE_STATE SS, SERVICE_LOAD SL
			WHERE A.ACCOUNT_ID = ASVC.ACCOUNT_ID
        AND A.ACCOUNT_METER_TYPE != 'Interval'
        AND S.ACCOUNT_SERVICE_ID = ASVC.ACCOUNT_SERVICE_ID
        AND (p_CAST_CONTEXT.ESP_IS_CERTIFIED = CONSTANTS.NOT_ASSIGNED OR UPPER(SUBSTR(ESP.ESP_TYPE,1,1)) = 'C')
			  AND PS.ESP_ID = ESP.ESP_ID
			  AND (p_CAST_CONTEXT.EDC_ID = g_ALL OR PS.EDC_ID = p_CAST_CONTEXT.EDC_ID)
			  AND (p_CAST_CONTEXT.ESP_ID = g_ALL OR PS.ESP_ID = p_CAST_CONTEXT.ESP_ID)
			  AND S.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
			  AND S.SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
			  AND S.AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE
			  AND S.PROVIDER_SERVICE_ID = PS.PROVIDER_SERVICE_ID
			  AND SS.SERVICE_ID = S.SERVICE_ID
			  AND SS.SERVICE_CODE = p_CAST_CONTEXT.REQUEST_TYPE
			  AND SS.SERVICE_DATE BETWEEN p_CAST_CONTEXT.BEGIN_DATE AND p_CAST_CONTEXT.END_DATE
			  AND SS.HAS_DETAILS = 1
			  AND SS.IS_AGGREGATE_ACCOUNT = DECODE(p_CAST_CONTEXT.ACCOUNT_PROCESS_MODE, 1, SS.IS_AGGREGATE_ACCOUNT, 2, 1, 3, 0, 4, SS.IS_AGGREGATE_ACCOUNT, 9)
			  AND SL.SERVICE_ID = SS.SERVICE_ID
			  AND SL.SERVICE_CODE = SS.SERVICE_CODE
			  AND SL.LOAD_DATE BETWEEN (TO_CUT(TRUNC(SS.SERVICE_DATE), v_LOCAL_TZ)+v_OFFS1)
			  						AND (TO_CUT(TRUNC(SS.SERVICE_DATE), v_LOCAL_TZ)+v_OFFS2));

		DELETE SERVICE_STATE
		WHERE ROWID IN
			(SELECT SS.ROWID
			FROM  ACCOUNT A ,ACCOUNT_SERVICE ASVC, ENERGY_SERVICE_PROVIDER ESP, PROVIDER_SERVICE PS,SERVICE S, SERVICE_STATE SS
			WHERE A.ACCOUNT_ID = ASVC.ACCOUNT_ID
        AND A.ACCOUNT_METER_TYPE != 'Interval'
        AND S.ACCOUNT_SERVICE_ID = ASVC.ACCOUNT_SERVICE_ID
        AND (p_CAST_CONTEXT.ESP_IS_CERTIFIED = CONSTANTS.NOT_ASSIGNED OR UPPER(SUBSTR(ESP.ESP_TYPE,1,1)) = 'C')
			  AND PS.ESP_ID = ESP.ESP_ID
			  AND (p_CAST_CONTEXT.EDC_ID = g_ALL OR PS.EDC_ID = p_CAST_CONTEXT.EDC_ID)
			  AND (p_CAST_CONTEXT.ESP_ID = g_ALL OR PS.ESP_ID = p_CAST_CONTEXT.ESP_ID)
			  AND S.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
			  AND S.SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
			  AND S.AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE
			  AND S.PROVIDER_SERVICE_ID = PS.PROVIDER_SERVICE_ID
			  AND SS.SERVICE_ID = S.SERVICE_ID
			  AND SS.SERVICE_CODE = p_CAST_CONTEXT.REQUEST_TYPE
			  AND SS.SERVICE_DATE BETWEEN p_CAST_CONTEXT.BEGIN_DATE AND p_CAST_CONTEXT.END_DATE
			  AND SS.HAS_DETAILS = 1
			  AND SS.IS_AGGREGATE_ACCOUNT = DECODE(p_CAST_CONTEXT.ACCOUNT_PROCESS_MODE, 1, SS.IS_AGGREGATE_ACCOUNT, 2, 1, 3, 0, 4, SS.IS_AGGREGATE_ACCOUNT, 9));

	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('DELETE_SERVICE ELAPSED TIME='  || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED));
	END IF;

END DELETE_SERVICE_NON_INTERVAL;
---------------------
PROCEDURE DELETE_CUSTOMER_SERVICE
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE
	) AS

v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;
v_LOAD_CODE CHAR(1);
v_BEGIN_DATE DATE := p_CAST_CONTEXT.BEGIN_DATE;
v_END_DATE DATE := p_CAST_CONTEXT.END_DATE;
BEGIN

	IF (GA.STORE_CUST_SVC_LOAD_BACKCAST AND p_CAST_CONTEXT.REQUEST_TYPE = GA.BACKCAST_SERVICE)
		OR (GA.STORE_CUST_SVC_LOAD_FORECAST AND p_CAST_CONTEXT.REQUEST_TYPE = GA.FORECAST_SERVICE)
	THEN

		IF p_CAST_CONTEXT.RUN_MODE IN (GA.MONTH_MODE, GA.WEEK_MODE) THEN
			v_LOAD_CODE := p_CAST_CONTEXT.DAY_TYPE;
		ELSE
			v_LOAD_CODE := GA.STANDARD;
		END IF;

		IF p_CAST_CONTEXT.ACCOUNT_PROCESS_MODE = 0 THEN
		-- Delete for Single Account Run.
			DELETE CUSTOMER_SERVICE_LOAD
			WHERE SERVICE_ID IN
				(SELECT SERVICE_ID FROM SERVICE
				WHERE MODEL_ID = p_CAST_CONTEXT.MODEL_ID
					AND SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
					AND AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE
					AND ACCOUNT_SERVICE_ID IN (SELECT ACCOUNT_SERVICE_ID FROM ACCOUNT_SERVICE WHERE ACCOUNT_ID = p_CAST_CONTEXT.ACCOUNT_ID))
			AND SERVICE_CODE = p_CAST_CONTEXT.SERVICE_CODE
			AND LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND LOAD_CODE =  v_LOAD_CODE;

		ELSIF p_CAST_CONTEXT.ACCOUNT_PROCESS_MODE IN (1,2) THEN
		-- Delete for the Type of Run: 1-All, 2-Agg, 3-Non-Agg, 4-External.
			IF p_CAST_CONTEXT.EDC_ID = g_ALL AND p_CAST_CONTEXT.ESP_ID = g_ALL THEN
				DELETE CUSTOMER_SERVICE_LOAD
				WHERE SERVICE_ID IN
					(SELECT SERVICE_ID FROM SERVICE
					WHERE MODEL_ID = p_CAST_CONTEXT.MODEL_ID
						AND SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
						AND AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE)
				AND SERVICE_CODE = p_CAST_CONTEXT.SERVICE_CODE
				AND LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND LOAD_CODE =  v_LOAD_CODE;
			ELSE
				DELETE CUSTOMER_SERVICE_LOAD
				WHERE SERVICE_ID IN
					(SELECT SERVICE_ID FROM SERVICE
					WHERE MODEL_ID = p_CAST_CONTEXT.MODEL_ID
						AND SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
						AND AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE
						AND PROVIDER_SERVICE_ID IN
							(SELECT DISTINCT PROVIDER_SERVICE_ID
							FROM PROVIDER_SERVICE
							WHERE (p_CAST_CONTEXT.EDC_ID = g_ALL OR EDC_ID = p_CAST_CONTEXT.EDC_ID)
								AND (p_CAST_CONTEXT.ESP_ID = g_ALL OR ESP_ID = p_CAST_CONTEXT.ESP_ID)))
				AND SERVICE_CODE = p_CAST_CONTEXT.SERVICE_CODE
				AND LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND LOAD_CODE =  v_LOAD_CODE;
			END IF;
		END IF;
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('DELETE_SERVICE ELAPSED TIME='  || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED));
	END IF;

END DELETE_CUSTOMER_SERVICE;
--------------------------------------------------------------------------------------------------
PROCEDURE CAST_SETTLEMENT_MODEL
	(
	p_CAST_CONTEXT IN OUT NOCOPY CAST_CONTEXT_TYPE
	) AS

-- Generate a Settlement Profile for Period Metering and have the create option specified.
-- If p_account_id < 0 then cast all accounts; otherwise cast the specified Account.

v_BACKCAST_CONTEXT CAST_CONTEXT_TYPE := p_CAST_CONTEXT;
v_PROCESS_STEPS PLS_INTEGER;
v_ACCOUNT_SERVICE_ID BINARY_INTEGER;
v_STATION_ID NUMBER(9);
v_CALENDAR_ID NUMBER(9);
v_EDC_ID NUMBER(9);
v_PROFILE_ID NUMBER(9);
v_USAGE_FACTOR NUMBER(14,6);
v_PROFILE_TYPE CHAR(1);
v_PROFILE_SOURCE_DATE DATE;
v_CANDIDATES GA.ID_TABLE;
v_PROFILE GA.NUMBER_TABLE;
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;
v_HAS_PROXY_PROFILE BOOLEAN := FALSE;
v_AGGREGATE_ID NUMBER(9);
v_SUM NUMBER;
v_COUNT PLS_INTEGER;
v_INDEX PLS_INTEGER;

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('CAST_SETTLEMENT_MODEL');
	END IF;

-- Do the prep work to create any Settlement Calendars and Profiles.
	FP.SETTLEMENT_PROFILE_SETUP(p_CAST_CONTEXT);

-- Cache all Settlement Profile Candidates.
	CX.INITIALIZE_CACHE(p_CAST_CONTEXT);
	CX.TRACE_ACCOUNT_SERVICE_IDS;
	CX.TRACE_CALENDARS;
	v_COUNT := CX.GET_SETTLEMENT_COUNT(p_CAST_CONTEXT.BEGIN_DATE);

-- If there are no Accounts to process then terminate the Cast.
	IF v_COUNT = 0 THEN
		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG('NO ACTIVE ACCOUNTS');
		END IF;
		RETURN;
	END IF;

-- Determine the execution scope of this request for monitoring purposes.
		v_PROCESS_STEPS := v_COUNT * (p_CAST_CONTEXT.END_DATE - p_CAST_CONTEXT.BEGIN_DATE + 1);
		LOGS.INIT_PROCESS_PROGRESS(p_TOTAL_WORK => v_PROCESS_STEPS, p_CAN_TERMINATE => TRUE);

	v_BACKCAST_CONTEXT.REQUEST_TYPE := 'B'; -- some APIs expect B as request type, not S, to indicate that we're computing a backcast - like the next one

-- If this is a customer wrf run, then initialize the customer wrf cache.
	IF p_CAST_CONTEXT.MODEL_ID = GA.GAS_MODEL AND GA.ENABLE_CUSTOMER_MODEL AND p_CAST_CONTEXT.HAVE_CUSTOMER_USAGE_WRF = 1 THEN
		FW.INIT_CUSTOMER_WRF_CACHE(v_BACKCAST_CONTEXT);
	END IF;

-- Loop over the days of the Cast period.
	WHILE p_CAST_CONTEXT.SERVICE_DATE <= p_CAST_CONTEXT.END_DATE LOOP

-- Get the Settlement Profile Candidates for this Service Date.
		CX.GET_SETTLEMENT_CANDIDATES(p_CAST_CONTEXT.SERVICE_DATE, v_CANDIDATES);
-- Cache any Customer Usage WRF Profiles.
		IF p_CAST_CONTEXT.MODEL_ID = GA.GAS_MODEL AND GA.ENABLE_CUSTOMER_MODEL AND p_CAST_CONTEXT.HAVE_CUSTOMER_USAGE_WRF = 1 THEN
			FW.CACHE_CUSTOMER_USAGE_WRF_DAY(p_CAST_CONTEXT);
		END IF;

-- Loop over the Candidates.
		IF v_CANDIDATES.COUNT > 0 THEN
			v_ACCOUNT_SERVICE_ID := v_CANDIDATES.FIRST;
			WHILE v_ACCOUNT_SERVICE_ID <= v_CANDIDATES.LAST LOOP
				v_PROFILE_ID := v_CANDIDATES(v_ACCOUNT_SERVICE_ID);
				IF NOT FP.SETTLEMENT_PROFILE_EXISTS(v_PROFILE_ID) THEN
					v_USAGE_FACTOR := CX.GET_USAGE_FACTOR(v_ACCOUNT_SERVICE_ID, p_CAST_CONTEXT.SERVICE_DATE);
					v_CALENDAR_ID := CX.GET_CALENDAR_ID(v_ACCOUNT_SERVICE_ID, p_CAST_CONTEXT.SERVICE_DATE, p_CAST_CONTEXT.REQUEST_TYPE);
					v_EDC_ID := GET_EDC_FOR_ACCOUNT(v_ACCOUNT_SERVICE_ID, p_CAST_CONTEXT.SERVICE_DATE, TRUE);
					v_STATION_ID := CX.GET_STATION_ID(v_ACCOUNT_SERVICE_ID);

					/* don't have v_PROVIDER_SERVICE_ID or any easy way to get it so for now we can't support
					   using actual proxy profiles when running 'Generate Settlement Profiles'. When we change this
					   code to support this, we'll need to add calls to cache proxy info (or better yet, throw all of
					   this away and just re-write from scratch w/out caches....) */
/*					IF v_AGGREGATE_ID = CONSTANTS.NOT_ASSIGNED AND GA.USE_INTERVAL_USAGE_IN_BACKCAST THEN
						FP.PROXY_PROFILE(v_BACKCAST_CONTEXT, v_ACCOUNT_SERVICE_ID, v_PROVIDER_SERVICE_ID, g_CAST_CALENDAR_ID(v_XREF_ID), v_HAS_PROXY_PROFILE, v_PROFILE_SOURCE_DATE, v_PROFILE);
						v_PROFILE_TYPE := g_ACTUAL_USAGE_PROFILE;
					END IF;
*/
					SELECT NVL(AGGREGATE_ID,CONSTANTS.NOT_ASSIGNED) INTO v_AGGREGATE_ID
					FROM ACCOUNT_SERVICE
					wHERE ACCOUNT_SERVICE_ID = v_ACCOUNT_SERVICE_ID;

					IF p_CAST_CONTEXT.MODEL_ID = GA.GAS_MODEL AND GA.ENABLE_CUSTOMER_MODEL AND v_CALENDAR_ID = g_CUSTOMER_USAGE_WRF_CALENDAR THEN
							FW.CUSTOMER_USAGE_WRF_PROFILE(p_CAST_CONTEXT, v_AGGREGATE_ID, v_PROFILE);
							v_HAS_PROXY_PROFILE := TRUE;
							v_PROFILE_TYPE := g_CUSTOMER_USAGE_WRF_PROFILE;
							v_PROFILE_SOURCE_DATE := p_CAST_CONTEXT.SERVICE_DATE;
						END IF;

					IF NOT v_HAS_PROXY_PROFILE THEN
						FP.COMPOSITE_PROFILE_FOR_CALENDAR(p_CAST_CONTEXT, v_STATION_ID, v_CALENDAR_ID, v_EDC_ID, TRUE, v_PROFILE_TYPE, v_PROFILE_SOURCE_DATE, v_PROFILE);
					END IF;

					IF p_CAST_CONTEXT.MODEL_ID = GA.GAS_MODEL AND GA.ENABLE_CUSTOMER_MODEL AND GA.ENABLE_CUSTOMER_CAST AND v_AGGREGATE_ID <> CONSTANTS.NOT_ASSIGNED THEN
						-- v_PROFILE has values by customer - so calculate a single average value for this aggregate account
						v_INDEX := v_PROFILE.FIRST;
						v_SUM := 0;
						v_COUNT := 0;
						WHILE v_PROFILE.EXISTS(v_INDEX) LOOP
							v_SUM := v_SUM + v_PROFILE(v_INDEX);
							v_COUNT := v_COUNT+1;
							v_INDEX := v_PROFILE.NEXT(v_INDEX);
						END LOOP;
						-- update profile to indicate just the average load value
						v_PROFILE.DELETE;
						IF v_COUNT = 0 THEN
							v_PROFILE(1) := 0;
						ELSE
							v_PROFILE(1) := v_SUM / v_COUNT;
						END IF;
					END IF;

					FP.ASSIGN_SETTLEMENT_PROFILE(p_CAST_CONTEXT, v_PROFILE_ID, v_USAGE_FACTOR, v_PROFILE);
				END IF;

-- Increment the only progress range on the stack, initialized above
				LOGS.INCREMENT_PROCESS_PROGRESS();
				v_ACCOUNT_SERVICE_ID := v_CANDIDATES.NEXT(v_ACCOUNT_SERVICE_ID);
			END LOOP;
		END IF;

-- Store the processing results for this Service Date.
		FP.DELETE_SETTLEMENT_PROFILE(p_CAST_CONTEXT);
		FP.STORE_SETTLEMENT_PROFILE(p_CAST_CONTEXT);
		FP.RELEASE_SETTLEMENT;

		FW.RELEASE_WEATHER;
		p_CAST_CONTEXT.SERVICE_DATE := p_CAST_CONTEXT.SERVICE_DATE + 1;
		p_CAST_CONTEXT.PROFILE_DATE := p_CAST_CONTEXT.PROFILE_DATE + 1;

	END LOOP;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('CAST_SETTLEMENT_MODEL ELAPSED TIME='  || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED));
	END IF;

END CAST_SETTLEMENT_MODEL;
----------------------------------------------------------------------------------------------------
PROCEDURE RESET_UFE_PARTICIPATION
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE
	) AS

--  Reset the UFE participation indicator for all aggregate accountS.

CURSOR c_ACCOUNT_UFE_PARTICIPATION IS
	SELECT A.ACCOUNT_ID, A.IS_UFE_PARTICIPANT
	FROM ACCOUNT A, ACCOUNT_STATUS B, ACCOUNT_STATUS_NAME STATUS_NAME
	WHERE UPPER(SUBSTR(A.ACCOUNT_MODEL_OPTION,1,1)) = 'A'
		AND A.IS_AGGREGATE_ACCOUNT = 1
		AND B.ACCOUNT_ID = A.ACCOUNT_ID
		AND p_CAST_CONTEXT.BEGIN_DATE <= NVL(B.END_DATE, CONSTANTS.HIGH_DATE)
		AND p_CAST_CONTEXT.END_DATE >= B.BEGIN_DATE
		AND B.STATUS_NAME = STATUS_NAME.STATUS_NAME
		AND STATUS_NAME.IS_ACTIVE = 1;

BEGIN

	FOR v_ACCOUNT_UFE_PARTICIPATION IN c_ACCOUNT_UFE_PARTICIPATION LOOP
		UPDATE ACCOUNT_UFE_PARTICIPATION
		SET IS_UFE_PARTICIPANT = v_ACCOUNT_UFE_PARTICIPATION.IS_UFE_PARTICIPANT
		WHERE ACCOUNT_ID = v_ACCOUNT_UFE_PARTICIPATION.ACCOUNT_ID
			AND UFE_CODE = UPPER(SUBSTR(p_CAST_CONTEXT.REQUEST_TYPE,1,1))
			AND UFE_REQUESTOR = UPPER(p_CAST_CONTEXT.REQUESTOR);
	END LOOP;

END RESET_UFE_PARTICIPATION;
---------------------------------------------------------------------------------------------------
PROCEDURE CAST_SERVICE_MODEL
	(
	p_CAST_CONTEXT IN OUT NOCOPY CAST_CONTEXT_TYPE
	) AS

-- Generate a Forecast or Backcast for one or all Account, Aggregate, and Meter Model Option Accounts.
-- If p_account_id < 0 then cast all accounts; otherwise cast the specified Account.

v_PROCESS_STEPS PLS_INTEGER;
v_DAYS NUMBER(2);
v_SERVICE_MODEL SERVICE_MODEL_TABLE := SERVICE_MODEL_TABLE();
v_SAVE_PROFILE_DATE DATE;
v_INCREMENTAL_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;

v_HOLIDAY_SETS NUMBER_COLLECTION;
v_TEMPLATES NUMBER_COLLECTION;

BEGIN

-- Option to only Rollup the cast detail to summary level.
	IF p_CAST_CONTEXT.ACCOUNT_PROCESS_MODE = g_SUMMARY_ONLY THEN
		SET_SERVICE_OBLIGATION(p_CAST_CONTEXT);
		RETURN;
	END IF;

-- Select All Aggregate, Account, and Meter Model Accounts active over the Begin and End time period.
	CX.SELECT_SERVICE_MODEL(p_CAST_CONTEXT, v_SERVICE_MODEL);

-- If there are no Accounts to process then terminate the Cast.
	IF v_SERVICE_MODEL.COUNT = 0 THEN
		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG('NO ACTIVE ACCOUNTS');
		END IF;
		RETURN;
	END IF;

	CX.TRACE_SERVICE_MODEL(p_CAST_CONTEXT, v_SERVICE_MODEL);

	SELECT DISTINCT TEMPLATE_ID
	BULK COLLECT INTO v_TEMPLATES
	FROM (SELECT ATUF.TEMPLATE_ID
			FROM TABLE(CAST(v_SERVICE_MODEL AS SERVICE_MODEL_TABLE)) MODELS,
				ACCOUNT A,
				ACCOUNT_TOU_USAGE_FACTOR ATUF
			WHERE A.ACCOUNT_ID = MODELS.ACCOUNT_ID
				AND A.ACCOUNT_MODEL_OPTION = ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_ACCOUNT
				AND A.USE_TOU_USAGE_FACTOR = 1
				AND ATUF.ACCOUNT_ID = A.ACCOUNT_ID
				AND ATUF.CASE_ID = p_CAST_CONTEXT.USAGE_FACTOR_CASE_ID
				AND p_CAST_CONTEXT.SERVICE_DATE BETWEEN ATUF.BEGIN_DATE
															AND NVL(ATUF.END_DATE, CONSTANTS.HIGH_DATE)
		UNION ALL
		 SELECT MTUF.TEMPLATE_ID
		 	FROM TABLE(CAST(v_SERVICE_MODEL AS SERVICE_MODEL_TABLE)) MODELS,
				METER M,
				METER_TOU_USAGE_FACTOR MTUF
			WHERE M.METER_ID = MODELS.METER_ID
				AND M.USE_TOU_USAGE_FACTOR = 1
				AND MTUF.METER_ID = M.METER_ID
				AND MTUF.CASE_ID = p_CAST_CONTEXT.USAGE_FACTOR_CASE_ID
				AND p_CAST_CONTEXT.SERVICE_DATE BETWEEN MTUF.BEGIN_DATE
													AND NVL(MTUF.END_DATE, CONSTANTS.HIGH_DATE));

	SELECT DISTINCT NVL(MODELS.HOLIDAY_SET_ID, CONSTANTS.NOT_ASSIGNED)
	BULK COLLECT INTO v_HOLIDAY_SETS
	FROM TABLE(CAST(v_SERVICE_MODEL AS SERVICE_MODEL_TABLE)) MODELS;

	SP.CHECK_TEMPLATE_DATES(v_TEMPLATES,
							v_HOLIDAY_SETS,
							GA.LOCAL_TIME_ZONE,
							p_CAST_CONTEXT.SERVICE_DATE,
							p_CAST_CONTEXT.SERVICE_DATE);

-- Determine the execution scope of this request for monitoring purposes.
		v_PROCESS_STEPS := v_SERVICE_MODEL.COUNT * (p_CAST_CONTEXT.END_DATE - p_CAST_CONTEXT.BEGIN_DATE + 1);
		LOGS.INIT_PROCESS_PROGRESS(p_TOTAL_WORK => v_PROCESS_STEPS,p_CAN_TERMINATE => TRUE);

-- If this is a customer wrf run, then initialize the customer wrf cache.
	IF p_CAST_CONTEXT.MODEL_ID = GA.GAS_MODEL AND GA.ENABLE_CUSTOMER_MODEL AND p_CAST_CONTEXT.HAVE_CUSTOMER_USAGE_WRF = 1 THEN
		FW.INIT_CUSTOMER_WRF_CACHE(p_CAST_CONTEXT);
	END IF;

-- Synchronize the Account Service and Provider Service Relationships to the Service Model.
	CX.SYNC_SERVICE_MODEL(v_SERVICE_MODEL, p_CAST_CONTEXT.DETAIL_TRACE_ON = g_ON);

-- If Request is for a Backcast then do the prep work to create any Settlement Calendars and Profiles.
	IF p_CAST_CONTEXT.REQUEST_TYPE = 'B' THEN
		FP.SETTLEMENT_PROFILE_SETUP(p_CAST_CONTEXT);
	END IF;

	CX.INITIALIZE_CACHE(p_CAST_CONTEXT);

	IF GA.ENABLE_AGGREGATE_POOL_MODEL THEN
		CX.SYNC_AGGREGATE_POOL(p_CAST_CONTEXT);
	END IF;

-- Delete The Service and Service Usage Tables for the Run Period.
	DELETE_SERVICE(p_CAST_CONTEXT);

	IF p_CAST_CONTEXT.GENERATE_SUMMARY = 1 OR
		p_CAST_CONTEXT.ACCUMULATE_SOB_LOAD = 1 THEN
		DELETE_SERVICE_OBLIGATION_LOAD(p_CAST_CONTEXT);
	END IF;

	IF p_CAST_CONTEXT.GENERATE_SUMMARY = 1 THEN
		DELETE_EDC_SYSTEM_UFE_LOAD(p_CAST_CONTEXT);
	END IF;

--Delete the Customer Service tables for the run period.
	IF p_CAST_CONTEXT.MODEL_ID = GA.GAS_MODEL AND GA.ENABLE_CUSTOMER_MODEL AND GA.ENABLE_CUSTOMER_CAST THEN
		DELETE_CUSTOMER_SERVICE(p_CAST_CONTEXT);
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('SERVICE_MODEL COUNT=' || TO_CHAR(v_SERVICE_MODEL.COUNT) || ' ' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_INCREMENTAL_ELAPSED) || '/' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED));
		v_INCREMENTAL_ELAPSED := DBMS_UTILITY.GET_TIME;
	END IF;

-- Loop over the days of the Cast period.
	WHILE p_CAST_CONTEXT.SERVICE_DATE <= p_CAST_CONTEXT.END_DATE LOOP

-- Determine the number of Service Days used to advance to the next Service Date.
		SELECT DECODE(p_CAST_CONTEXT.RUN_MODE, GA.HOUR_MODE, 1, GA.DAY_MODE, 1, GA.WEEK_MODE, 7, TO_NUMBER(TO_CHAR(LAST_DAY(p_CAST_CONTEXT.SERVICE_DATE),'DD'))) INTO v_DAYS FROM DUAL;

		IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
			LOGS.LOG_DEBUG('CAST_SERVICE_MODEL SERVICE_DATE=' || TO_CHAR(p_CAST_CONTEXT.SERVICE_DATE) || ', PROFILE_DATE=' || TO_CHAR(p_CAST_CONTEXT.PROFILE_DATE) || ', DAYS=' || TO_CHAR(v_DAYS));
		END IF;

-- Clear cache of period IDs by TOU template for current service date
		g_TOU_PERIOD_IDs.DELETE;

-- Process the Week-Day Day Type for Weekly and Monthly Long Term Forecasts
		IF p_CAST_CONTEXT.RUN_MODE IN (GA.WEEK_MODE, GA.MONTH_MODE) THEN
			IF p_CAST_CONTEXT.SCENARIO_USE_DAY_TYPE = 1 THEN
				p_CAST_CONTEXT.DAY_TYPE := GA.WEEK_DAY;
				v_SAVE_PROFILE_DATE := p_CAST_CONTEXT.PROFILE_DATE;
				p_CAST_CONTEXT.PROFILE_DATE := COERCE_DATE_TO_DAY_TYPE(v_SAVE_PROFILE_DATE, p_CAST_CONTEXT.DAY_TYPE);
				IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
					LOGS.LOG_DEBUG('PROCESSING WEEK-DAY DAY TYPE PROFILE_DATE=' || TO_CHAR(p_CAST_CONTEXT.PROFILE_DATE));
				END IF;
			ELSE
				p_CAST_CONTEXT.DAY_TYPE := GA.ANY_DAY;
				IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
					LOGS.LOG_DEBUG('PROCESSING ANY_DAY TYPE PROFILE_DATE=' || TO_CHAR(p_CAST_CONTEXT.PROFILE_DATE));
				END IF;
			END IF;
		END IF;

-- Cache any Proxy Profiles.
		IF p_CAST_CONTEXT.REQUEST_TYPE IN ('F','B') THEN
			FP.CACHE_PROXY_DAY_METHODS(p_CAST_CONTEXT, CX.GET_ALL_PROXY_DAY_METHOD_IDs);
		END IF;

-- Cache any Customer Usage WRF Profiles.
		IF p_CAST_CONTEXT.MODEL_ID = GA.GAS_MODEL AND GA.ENABLE_CUSTOMER_MODEL AND p_CAST_CONTEXT.HAVE_CUSTOMER_USAGE_WRF = 1 THEN
			FW.CACHE_CUSTOMER_USAGE_WRF_DAY(p_CAST_CONTEXT);
		END IF;

-- Retrieve and cache all the Service attributes to this Service Model entry for this Service Date.
		FETCH_SERVICE(p_CAST_CONTEXT, v_SERVICE_MODEL);
		TRACE_SERVICE(p_CAST_CONTEXT);

-- Retrieve and cache Enrollment and Usage Factors for any Aggregate Accounts  for this Service Date.
		FETCH_ENROLLMENT(p_CAST_CONTEXT);

-- Cast using a Composite Profile from Calendar for this Service Date.
		ASSIGN_SERVICE_PROFILE(p_CAST_CONTEXT, v_SERVICE_MODEL);

-- Store the processing results for this Service Date.
		STORE_SERVICE_STATE(p_CAST_CONTEXT);
		STORE_SERVICE_LOAD(p_CAST_CONTEXT);
		STORE_SERVICE_OBLIGATION_LOAD(p_CAST_CONTEXT);

		IF p_CAST_CONTEXT.REQUEST_TYPE = 'B' THEN
			FP.DELETE_SETTLEMENT_PROFILE(p_CAST_CONTEXT);
			FP.STORE_SETTLEMENT_PROFILE(p_CAST_CONTEXT);
		END IF;

		FW.RELEASE_WEATHER;

-- Process the Week-End Day Type for Weekly and Monthly Long Term Forecasts
		IF p_CAST_CONTEXT.RUN_MODE IN (GA.WEEK_MODE, GA.MONTH_MODE) AND p_CAST_CONTEXT.SCENARIO_USE_DAY_TYPE = 1 THEN
			p_CAST_CONTEXT.DAY_TYPE := GA.WEEK_END;
			p_CAST_CONTEXT.PROFILE_DATE := COERCE_DATE_TO_DAY_TYPE(v_SAVE_PROFILE_DATE, p_CAST_CONTEXT.DAY_TYPE);
			IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
					LOGS.LOG_DEBUG('PROCESSING WEEK-END DAY TYPE PROFILE_DATE=' || TO_CHAR(p_CAST_CONTEXT.PROFILE_DATE));
			END IF;
			INITIALIZE_SERVICE_LOAD;
			INITIALIZE_SOB_LOAD;
			ASSIGN_SERVICE_PROFILE(p_CAST_CONTEXT, v_SERVICE_MODEL);
			STORE_SERVICE_LOAD(p_CAST_CONTEXT);
			STORE_SERVICE_OBLIGATION_LOAD(p_CAST_CONTEXT);
			FW.RELEASE_WEATHER;
			p_CAST_CONTEXT.PROFILE_DATE := v_SAVE_PROFILE_DATE;
		END IF;

-- Rollup the cast detail to summary level.
		IF p_CAST_CONTEXT.GENERATE_SUMMARY = 1 THEN
			SET_SERVICE_OBLIGATION_DAY(p_CAST_CONTEXT);
		END IF;

-- Set the Process Status to Pending.
		CS.PUT_PROCESS_STATUS(p_CAST_CONTEXT.PROCESS_NAME, p_CAST_CONTEXT.SERVICE_DATE, p_CAST_CONTEXT.OUTPUT_AS_OF_DATE, 'Pending', SYSDATE);

-- Report Timing for the Service Day.
		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG('TIMING FOR ' || TO_CHAR(p_CAST_CONTEXT.SERVICE_DATE) || ' ' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_INCREMENTAL_ELAPSED) || '/' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED));
			v_INCREMENTAL_ELAPSED := DBMS_UTILITY.GET_TIME;
		END IF;

-- Advance the Service and Profile Dates.
		p_CAST_CONTEXT.SERVICE_DATE := p_CAST_CONTEXT.SERVICE_DATE + v_DAYS;
		p_CAST_CONTEXT.PROFILE_DATE := p_CAST_CONTEXT.PROFILE_DATE + v_DAYS;

-- Commit incremental work in multi-day runs to reduce roll-back overhead.
		IF p_CAST_CONTEXT.INCREMENTAL_COMMIT = 1 THEN
			COMMIT;
		END IF;

	END LOOP;

	IF p_CAST_CONTEXT.GENERATE_SUMMARY = 1 AND GA.ENABLE_RESET_UFE_PARTICIPATION THEN
		RESET_UFE_PARTICIPATION(p_CAST_CONTEXT);
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('CAST_SERVICE_MODEL ELAPSED TIME='  || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED) || ', SERVICE ACCOUNTS=' || TO_CHAR(v_SERVICE_MODEL.COUNT));
	END IF;

END CAST_SERVICE_MODEL;
----------------------------------------------------------------------------------------------------
PROCEDURE CHECK_CUST_USAGE_WRF_CALENDAR
	(
	p_CAST_CONTEXT IN OUT CAST_CONTEXT_TYPE
	) AS

BEGIN

	--Set p_CAST_CONTEXT.HAVE_CUSTOMER_USAGE_WRF
    	SELECT LEAST(COUNT(A.CALENDAR_ID),1) INTO p_CAST_CONTEXT.HAVE_CUSTOMER_USAGE_WRF
    	FROM (SELECT DISTINCT CALENDAR_ID FROM ACCOUNT_CALENDAR WHERE CALENDAR_ID = g_CUSTOMER_USAGE_WRF_CALENDAR AND BEGIN_DATE <= p_CAST_CONTEXT.END_DATE AND NVL(END_DATE, CONSTANTS.HIGH_DATE) >= p_CAST_CONTEXT.BEGIN_DATE
    		UNION SELECT DISTINCT CALENDAR_ID FROM METER_CALENDAR WHERE CALENDAR_ID = g_CUSTOMER_USAGE_WRF_CALENDAR AND BEGIN_DATE <= p_CAST_CONTEXT.END_DATE AND NVL(END_DATE, CONSTANTS.HIGH_DATE) >= p_CAST_CONTEXT.BEGIN_DATE) A;

END CHECK_CUST_USAGE_WRF_CALENDAR;
----------------------------------------------------------------------------------------------------
PROCEDURE SET_CASE_CONTEXT
	(
	p_CAST_CONTEXT IN OUT CAST_CONTEXT_TYPE
	) AS

v_LOAD_FORECAST_SCENARIO LOAD_FORECAST_SCENARIO%ROWTYPE;
v_STATEMENT_FORECAST_SCENARIO STATEMENT_FORECAST_SCENARIO%ROWTYPE;

BEGIN

	IF NOT p_CAST_CONTEXT.REQUEST_MODE = GA.STATEMENT_MODE THEN
		SELECT * INTO v_LOAD_FORECAST_SCENARIO FROM LOAD_FORECAST_SCENARIO WHERE SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID;
		p_CAST_CONTEXT.WEATHER_CASE_ID := v_LOAD_FORECAST_SCENARIO.WEATHER_CASE_ID;
		p_CAST_CONTEXT.AREA_LOAD_CASE_ID := v_LOAD_FORECAST_SCENARIO.AREA_LOAD_CASE_ID;
		p_CAST_CONTEXT.ENROLLMENT_CASE_ID := v_LOAD_FORECAST_SCENARIO.ENROLLMENT_CASE_ID;
		p_CAST_CONTEXT.USAGE_FACTOR_CASE_ID := v_LOAD_FORECAST_SCENARIO.USAGE_FACTOR_CASE_ID;
		p_CAST_CONTEXT.LOSS_FACTOR_CASE_ID := v_LOAD_FORECAST_SCENARIO.LOSS_FACTOR_CASE_ID;
		p_CAST_CONTEXT.GROWTH_FACTOR_CASE_ID := v_LOAD_FORECAST_SCENARIO.GROWTH_FACTOR_CASE_ID;
		p_CAST_CONTEXT.RUN_MODE := v_LOAD_FORECAST_SCENARIO.RUN_MODE;
		p_CAST_CONTEXT.SCENARIO_USE_DAY_TYPE := v_LOAD_FORECAST_SCENARIO.SCENARIO_USE_DAY_TYPE;
		p_CAST_CONTEXT.ACCOUNT_STATUS_LIST := SP.GET_SCENARIO_STATUS_LIST(p_CAST_CONTEXT.SCENARIO_ID);

		--Use the special LT Average Calendar Case for LT Forecast, unless something else was specially assigned.
		IF p_CAST_CONTEXT.RUN_MODE IN (GA.WEEK_MODE, GA.MONTH_MODE)
				AND v_LOAD_FORECAST_SCENARIO.CALENDAR_CASE_ID = GA.BASE_CASE_ID THEN
			p_CAST_CONTEXT.CALENDAR_CASE_ID := FL.GET_LONG_TERM_CASE_ID(p_CAST_CONTEXT.RUN_MODE, FALSE);
		ELSE
			p_CAST_CONTEXT.CALENDAR_CASE_ID := v_LOAD_FORECAST_SCENARIO.CALENDAR_CASE_ID;
		END IF;

	ELSE
		SELECT * INTO v_STATEMENT_FORECAST_SCENARIO FROM STATEMENT_FORECAST_SCENARIO WHERE SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID;
		p_CAST_CONTEXT.PRODUCT_CASE_ID := v_STATEMENT_FORECAST_SCENARIO.PRODUCT_CASE_ID;
		p_CAST_CONTEXT.LOAD_SCENARIO_ID := v_STATEMENT_FORECAST_SCENARIO.LOAD_SCENARIO_ID;
		p_CAST_CONTEXT.RUN_MODE := v_LOAD_FORECAST_SCENARIO.RUN_MODE;
		p_CAST_CONTEXT.ACCOUNT_STATUS_LIST := NULL;
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		p_CAST_CONTEXT.WEATHER_CASE_ID := GA.BASE_CASE_ID;
		p_CAST_CONTEXT.AREA_LOAD_CASE_ID := GA.BASE_CASE_ID;
		p_CAST_CONTEXT.ENROLLMENT_CASE_ID := GA.BASE_CASE_ID;
		p_CAST_CONTEXT.CALENDAR_CASE_ID := GA.BASE_CASE_ID;
		p_CAST_CONTEXT.USAGE_FACTOR_CASE_ID := GA.BASE_CASE_ID;
		p_CAST_CONTEXT.LOSS_FACTOR_CASE_ID := GA.BASE_CASE_ID;
		p_CAST_CONTEXT.GROWTH_FACTOR_CASE_ID := GA.BASE_CASE_ID;
		p_CAST_CONTEXT.PRODUCT_CASE_ID := GA.BASE_CASE_ID;
		p_CAST_CONTEXT.LOAD_SCENARIO_ID := GA.BASE_CASE_ID;
		p_CAST_CONTEXT.RUN_MODE := 0;
		p_CAST_CONTEXT.SCENARIO_USE_DAY_TYPE := 0;
		p_CAST_CONTEXT.HAVE_CUSTOMER_USAGE_WRF := 0;
		p_CAST_CONTEXT.ACCOUNT_STATUS_LIST := NULL;

END SET_CASE_CONTEXT;
----------------------------------------------------------------------------------------------------
PROCEDURE INITIALIZE_CAST_CONTEXT
	(
	p_REQUEST_TYPE IN CHAR,
	p_REQUEST_MODE IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_MODEL_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_PROFILE_BEGIN_DATE IN DATE,
	p_PROFILE_AS_OF_DATE IN DATE,
	p_APPLY_USAGE_FACTOR IN NUMBER,
	p_APPLY_UFE IN NUMBER,
	p_APPLY_UFE_OTHER IN NUMBER,
	p_APPLY_EXTERNAL_FORECAST IN NUMBER,
	p_REQUESTOR IN VARCHAR,
	p_TRACE_ON IN NUMBER,
	p_CAST_CONTEXT IN OUT NOCOPY CAST_CONTEXT_TYPE
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_PROFILE_BEGIN_DATE DATE;

BEGIN

	SELECT DECODE(p_EDC_ID, g_ALL, '<All>', CS.GET_EDC_NAME(p_EDC_ID)) INTO p_CAST_CONTEXT.EDC_NAME FROM DUAL;
	SELECT DECODE(p_ESP_ID, g_ALL, '<All>', CS.GET_ESP_NAME(p_ESP_ID)) INTO p_CAST_CONTEXT.ESP_NAME FROM DUAL;
	SELECT UPPER(SUBSTR(p_REQUEST_TYPE,1,1)) INTO p_CAST_CONTEXT.REQUEST_TYPE FROM DUAL;

	p_CAST_CONTEXT.SERVICE_CODE := p_CAST_CONTEXT.REQUEST_TYPE;
	p_CAST_CONTEXT.LOAD_CODE := GA.STANDARD;
	p_CAST_CONTEXT.REQUEST_MODE := p_REQUEST_MODE;
	p_CAST_CONTEXT.SCENARIO_ID := p_SCENARIO_ID;
	p_CAST_CONTEXT.GENERATE_SUMMARY := CONSTANTS.NOT_ASSIGNED;
	p_CAST_CONTEXT.INCUMBENT_TYPE := UT.GET_INCUMBENT_ENTITY_TYPE;

	SET_CASE_CONTEXT(p_CAST_CONTEXT);

	p_CAST_CONTEXT.MODEL_ID := p_MODEL_ID;
	p_CAST_CONTEXT.EDC_ID := p_EDC_ID;
	p_CAST_CONTEXT.ESP_ID := p_ESP_ID;
	p_CAST_CONTEXT.ESP_IS_CERTIFIED := g_OFF;
	IF p_ESP_ID < g_ALL THEN
		p_CAST_CONTEXT.ESP_ID := g_ALL;
		p_CAST_CONTEXT.ESP_IS_CERTIFIED := g_ON;
	END IF;

-- Set the Account Processing Mode: 1 - All, 2 - Aggregate, 3 - Non-Aggregate, 4 - External, 5 - Summary Only, 0 - Specific Account.
	IF p_ACCOUNT_ID BETWEEN -5 AND -1 THEN
		p_CAST_CONTEXT.ACCOUNT_PROCESS_MODE := ABS(p_ACCOUNT_ID);
		p_CAST_CONTEXT.ACCOUNT_ID := g_ALL;
		p_CAST_CONTEXT.GENERATE_SUMMARY := 1;
	ELSE
		p_CAST_CONTEXT.ACCOUNT_PROCESS_MODE := CONSTANTS.NOT_ASSIGNED;
		p_CAST_CONTEXT.ACCOUNT_ID := ABS(p_ACCOUNT_ID);
		IF p_ACCOUNT_ID < 0 AND NOT GA.CAST_SUMMARY_ONLY_MODE THEN
			p_CAST_CONTEXT.GENERATE_SUMMARY := 1;
		END IF;
	END IF;

	p_CAST_CONTEXT.ACCUMULATE_ONLY := 0;

	IF p_ACCOUNT_ID = g_ALL AND p_CAST_CONTEXT.SERVICE_CODE IN (GA.FORECAST_SERVICE, GA.BACKCAST_SERVICE) THEN
		p_CAST_CONTEXT.ACCUMULATE_SOB_LOAD := 1;

		IF GA.CAST_SUMMARY_ONLY_MODE THEN
			p_CAST_CONTEXT.ACCUMULATE_ONLY := 1;
		END IF;
	ELSE
		p_CAST_CONTEXT.ACCUMULATE_SOB_LOAD := 0;
	END IF;

	p_CAST_CONTEXT.ACCOUNT_GROUP_ID := CONSTANTS.NOT_ASSIGNED;

	IF p_CAST_CONTEXT.REQUEST_MODE = GA.ACCOUNT_GROUP_MODE THEN
		p_CAST_CONTEXT.ACCOUNT_GROUP_ID := ABS(p_ACCOUNT_ID);
		p_CAST_CONTEXT.ACCOUNT_ID := CONSTANTS.NOT_ASSIGNED;
	END IF;

	IF p_CAST_CONTEXT.RUN_MODE = GA.WEEK_MODE THEN
		v_BEGIN_DATE := TRUNC(p_BEGIN_DATE, 'DAY');
		v_END_DATE := TRUNC(p_END_DATE, 'DAY') + 6;
		v_PROFILE_BEGIN_DATE := TRUNC(p_PROFILE_BEGIN_DATE, 'DAY');
	ELSIF p_CAST_CONTEXT.RUN_MODE = GA.MONTH_MODE THEN
		v_BEGIN_DATE := TRUNC(p_BEGIN_DATE, 'MONTH');
		v_END_DATE := LAST_DAY(TRUNC(p_END_DATE, 'MONTH'));
		v_PROFILE_BEGIN_DATE := TRUNC(p_PROFILE_BEGIN_DATE, 'MONTH');
	ELSE
		v_BEGIN_DATE := TRUNC(p_BEGIN_DATE);
		v_END_DATE := TRUNC(p_END_DATE);
		v_PROFILE_BEGIN_DATE := TRUNC(p_PROFILE_BEGIN_DATE);
	END IF;

	p_CAST_CONTEXT.BEGIN_DATE := v_BEGIN_DATE;
	p_CAST_CONTEXT.END_DATE := v_END_DATE;
	p_CAST_CONTEXT.INPUT_AS_OF_DATE := CORRECTED_AS_OF_DATE(p_INPUT_AS_OF_DATE);
	p_CAST_CONTEXT.OUTPUT_AS_OF_DATE := SERVICE_AS_OF_DATE(p_CAST_CONTEXT.SERVICE_CODE, CORRECTED_AS_OF_DATE(p_OUTPUT_AS_OF_DATE));
	p_CAST_CONTEXT.PROFILE_BEGIN_DATE := v_PROFILE_BEGIN_DATE;
	p_CAST_CONTEXT.PROFILE_AS_OF_DATE := CORRECTED_AS_OF_DATE(p_PROFILE_AS_OF_DATE,'Profiling');
	p_CAST_CONTEXT.SERVICE_DATE := p_CAST_CONTEXT.BEGIN_DATE;
	p_CAST_CONTEXT.PROFILE_DATE := p_CAST_CONTEXT.PROFILE_BEGIN_DATE;

	SELECT DECODE(p_CAST_CONTEXT.REQUEST_TYPE, 'F', 'FORECASTING', 'B', 'SETTLEMENT', 'S', 'SETTLEMENT','A', 'SETTLEMENT', 'FORECASTING') INTO p_CAST_CONTEXT.MODULE_NAME FROM DUAL;
	p_CAST_CONTEXT.PROCESS_NAME := GET_PROCESS_NAME(p_REQUEST_TYPE, p_REQUEST_MODE);
	SELECT DECODE(p_CAST_CONTEXT.REQUEST_TYPE, 'F', 'F', 'B', 'A', 'S', 'A', p_CAST_CONTEXT.REQUEST_TYPE) INTO p_CAST_CONTEXT.WEATHER_PARAMETER_CODE FROM DUAL;
	SELECT DECODE(p_CAST_CONTEXT.REQUEST_TYPE, 'F', 'F', 'B', 'A', 'S', 'A', p_CAST_CONTEXT.REQUEST_TYPE) INTO p_CAST_CONTEXT.SYSTEM_LOAD_CODE FROM DUAL;
	SELECT DECODE(p_CAST_CONTEXT.MODEL_ID,1,1000,2,10) INTO p_CAST_CONTEXT.SYSTEM_UNITS FROM DUAL;

	p_CAST_CONTEXT.APPLY_USAGE_FACTOR := p_APPLY_USAGE_FACTOR;
	p_CAST_CONTEXT.APPLY_EXTERNAL_FORECAST := p_APPLY_EXTERNAL_FORECAST;

	IF p_APPLY_UFE = 0 THEN
		p_CAST_CONTEXT.APPLY_UFE_CODE := 0;
	ELSE
		p_CAST_CONTEXT.APPLY_UFE_CODE := 1;
		IF p_APPLY_UFE_OTHER = 1 THEN
			p_CAST_CONTEXT.APPLY_UFE_CODE := 2;
		END IF;
	END IF;

	p_CAST_CONTEXT.REQUESTOR := p_REQUESTOR;
	p_CAST_CONTEXT.DAY_TYPE := g_ANY_DAY;

	IF p_TRACE_ON > 0 THEN
		p_CAST_CONTEXT.TRACE_ON := 1;
		IF p_TRACE_ON > 1 THEN
			p_CAST_CONTEXT.DETAIL_TRACE_ON := 1;
		ELSE
			p_CAST_CONTEXT.DETAIL_TRACE_ON := 0;
		END IF;
	ELSE
		p_CAST_CONTEXT.TRACE_ON := 0;
		p_CAST_CONTEXT.DETAIL_TRACE_ON := 0;
	END IF;

	CHECK_CUST_USAGE_WRF_CALENDAR(p_CAST_CONTEXT);

	IF p_CAST_CONTEXT.END_DATE - p_CAST_CONTEXT.BEGIN_DATE + 1 > GA.CAST_COMMIT_THRESHOLD THEN
		p_CAST_CONTEXT.INCREMENTAL_COMMIT := 1;
	ELSE
		p_CAST_CONTEXT.INCREMENTAL_COMMIT := 0;
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('INITIALIZE_CAST_CONTEXT');
		LOGS.LOG_DEBUG('MODEL_ID=' || TO_CHAR(p_CAST_CONTEXT.MODEL_ID));
		LOGS.LOG_DEBUG('REQUEST_TYPE=' || p_CAST_CONTEXT.REQUEST_TYPE);
		LOGS.LOG_DEBUG('SERVICE_CODE=' || p_CAST_CONTEXT.SERVICE_CODE);
		LOGS.LOG_DEBUG('REQUEST_MODE=' || TO_CHAR(p_CAST_CONTEXT.REQUEST_MODE));
		LOGS.LOG_DEBUG('RUN_MODE=' || TO_CHAR(p_CAST_CONTEXT.RUN_MODE));
		LOGS.LOG_DEBUG('ACCOUNT_PROCESS_MODE=' || TO_CHAR(p_CAST_CONTEXT.ACCOUNT_PROCESS_MODE));
		LOGS.LOG_DEBUG('GENERATE_SUMMARY=' || TO_CHAR(p_CAST_CONTEXT.GENERATE_SUMMARY));
		LOGS.LOG_DEBUG('EDC_ID=' || TO_CHAR(p_CAST_CONTEXT.EDC_ID));
		LOGS.LOG_DEBUG('ESP_ID=' || TO_CHAR(p_CAST_CONTEXT.ESP_ID));
		LOGS.LOG_DEBUG('ESP_IS_CERTIFIED=' || TO_CHAR(p_CAST_CONTEXT.ESP_IS_CERTIFIED));
		LOGS.LOG_DEBUG('EDC_NAME=' || p_CAST_CONTEXT.EDC_NAME);
		LOGS.LOG_DEBUG('ESP_NAME=' || p_CAST_CONTEXT.ESP_NAME);
		LOGS.LOG_DEBUG('ACCOUNT_ID=' || TO_CHAR(p_CAST_CONTEXT.ACCOUNT_ID));
		LOGS.LOG_DEBUG('ACCOUNT_GROUP_ID=' || TO_CHAR(p_CAST_CONTEXT.ACCOUNT_GROUP_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_CAST_CONTEXT.BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_CAST_CONTEXT.END_DATE));
		LOGS.LOG_DEBUG('PROFILE_BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_CAST_CONTEXT.PROFILE_BEGIN_DATE));
		LOGS.LOG_DEBUG('INPUT_AS_OF_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_CAST_CONTEXT.INPUT_AS_OF_DATE));
		LOGS.LOG_DEBUG('OUTPUT_AS_OF_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_CAST_CONTEXT.OUTPUT_AS_OF_DATE));
		LOGS.LOG_DEBUG('PROFILE_AS_OF_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_CAST_CONTEXT.PROFILE_AS_OF_DATE));
		LOGS.LOG_DEBUG('APPLY_UFE_CODE=' || TO_CHAR(p_CAST_CONTEXT.APPLY_UFE_CODE));
		LOGS.LOG_DEBUG('APPLY_EXTERNAL_FORECAST=' || TO_CHAR(p_CAST_CONTEXT.APPLY_EXTERNAL_FORECAST));
		LOGS.LOG_DEBUG('APPLY_USAGE_FACTOR=' || TO_CHAR(p_CAST_CONTEXT.APPLY_USAGE_FACTOR));
		LOGS.LOG_DEBUG('SYSTEM_UNITS=' || TO_CHAR(p_CAST_CONTEXT.SYSTEM_UNITS));
		LOGS.LOG_DEBUG('WEATHER_PARAMETER_CODE=' || p_CAST_CONTEXT.WEATHER_PARAMETER_CODE);
		LOGS.LOG_DEBUG('SYSTEM_LOAD_CODE=' || p_CAST_CONTEXT.SYSTEM_LOAD_CODE);
		LOGS.LOG_DEBUG('PROCESS_NAME=' || p_CAST_CONTEXT.PROCESS_NAME);
		LOGS.LOG_DEBUG('REQUESTOR=' || p_CAST_CONTEXT.REQUESTOR);
		LOGS.LOG_DEBUG('DAY_TYPE=' || p_CAST_CONTEXT.DAY_TYPE);
		LOGS.LOG_DEBUG('INCUMBENT_TYPE=' || p_CAST_CONTEXT.INCUMBENT_TYPE);
		LOGS.LOG_DEBUG('HAVE_CUSTOMER_USAGE_WRF=' || TO_CHAR(p_CAST_CONTEXT.HAVE_CUSTOMER_USAGE_WRF));
		LOGS.LOG_DEBUG('ACCUMULATE_SOB_LOAD=' || TO_CHAR(p_CAST_CONTEXT.ACCUMULATE_SOB_LOAD));
		LOGS.LOG_DEBUG('INCREMENTAL_COMMIT=' || TO_CHAR(p_CAST_CONTEXT.INCREMENTAL_COMMIT));
		LOGS.LOG_DEBUG('SCENARIO_ID=' || TO_CHAR(p_CAST_CONTEXT.SCENARIO_ID));
		LOGS.LOG_DEBUG('SCENARIO_USE_DAY_TYPE=' || TO_CHAR(p_CAST_CONTEXT.SCENARIO_USE_DAY_TYPE));
		LOGS.LOG_DEBUG('WEATHER_CASE_ID=' || TO_CHAR(p_CAST_CONTEXT.WEATHER_CASE_ID));
		LOGS.LOG_DEBUG('AREA_LOAD_CASE_ID=' || TO_CHAR(p_CAST_CONTEXT.AREA_LOAD_CASE_ID));
		LOGS.LOG_DEBUG('ENROLLMENT_CASE_ID=' || TO_CHAR(p_CAST_CONTEXT.ENROLLMENT_CASE_ID));
		LOGS.LOG_DEBUG('CALENDAR_CASE_ID=' || TO_CHAR(p_CAST_CONTEXT.CALENDAR_CASE_ID));
		LOGS.LOG_DEBUG('USAGE_FACTOR_CASE_ID=' || TO_CHAR(p_CAST_CONTEXT.USAGE_FACTOR_CASE_ID));
		LOGS.LOG_DEBUG('LOSS_FACTOR_CASE_ID=' || TO_CHAR(p_CAST_CONTEXT.LOSS_FACTOR_CASE_ID));
		LOGS.LOG_DEBUG('GROWTH_FACTOR_CASE_ID=' || TO_CHAR(p_CAST_CONTEXT.GROWTH_FACTOR_CASE_ID));
		LOGS.LOG_DEBUG('PRODUCT_CASE_ID=' || TO_CHAR(p_CAST_CONTEXT.PRODUCT_CASE_ID));
		LOGS.LOG_DEBUG('ACCOUNT_STATUS_LIST=' || p_CAST_CONTEXT.ACCOUNT_STATUS_LIST);
		LOGS.LOG_DEBUG('EDC_NAME=' || p_CAST_CONTEXT.EDC_NAME);
		LOGS.LOG_DEBUG('ESP_NAME=' || p_CAST_CONTEXT.ESP_NAME);
	END IF;

END INITIALIZE_CAST_CONTEXT;
----------------------------------------------------------------------------------------------------
PROCEDURE FINANCIAL_POSITION_REQUEST
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;
v_POSITION_TYPE CHAR(1);
v_BEGIN_DATE DATE := TRUNC(p_CAST_CONTEXT.BEGIN_DATE,'MONTH');
v_END_DATE DATE;
v_NUM_MONTHS NUMBER(9);
BEGIN

	SELECT DECODE(p_CAST_CONTEXT.REQUEST_TYPE,'F',1,'B',2,'3') INTO v_POSITION_TYPE FROM DUAL;

	v_NUM_MONTHS := CEIL(MONTHS_BETWEEN(LAST_DAY(p_CAST_CONTEXT.END_DATE),v_BEGIN_DATE));

	LOGS.INIT_PROCESS_PROGRESS(p_TOTAL_WORK => v_NUM_MONTHS);

	--Run only one month at a time because the PB procedure does not cross months properly.
	WHILE v_BEGIN_DATE <= p_CAST_CONTEXT.END_DATE LOOP
		v_END_DATE := LAST_DAY(v_BEGIN_DATE);

		FF.SERVICE_POSITION_REQUEST_SCEN(p_CAST_CONTEXT.MODULE_NAME, p_CAST_CONTEXT.MODEL_ID, v_POSITION_TYPE,  v_BEGIN_DATE,  v_END_DATE,  p_CAST_CONTEXT.INPUT_AS_OF_DATE,  p_CAST_CONTEXT.OUTPUT_AS_OF_DATE,  p_CAST_CONTEXT.TRACE_ON + p_CAST_CONTEXT.DETAIL_TRACE_ON, p_CAST_CONTEXT.SCENARIO_ID, p_STATUS, p_MESSAGE);

		LOGS.INCREMENT_PROCESS_PROGRESS();

		v_BEGIN_DATE := ADVANCE_DATE(v_BEGIN_DATE, 'MONTH');
	END LOOP;

	LOGS.LOG_DEBUG('FINANCIAL_POSITION_REQUEST TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED));

END FINANCIAL_POSITION_REQUEST;
----------------------------------------------------------------------------------------------------
PROCEDURE CAST_LOGIC_END AS
-- End Cast Caching Logic
BEGIN
	NULL;
END CAST_LOGIC_END;
----------------------------------------------------------------------------------------------------
PROCEDURE ALLOCATION_LOGIC_BEGIN AS
-- Begin Allocation Caching Logic
BEGIN
	NULL;
END ALLOCATION_LOGIC_BEGIN;
----------------------------------------------------------------------------------------------------
PROCEDURE BILLED_USAGE_ALLOCATION
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_SERVICE_CONSUMPTION IN SERVICE_CONSUMPTION_TYPE,
	p_PROFILE IN USAGE_TABLE,
	p_PROFILE_INTERVAL IN NUMBER,
	p_PROFILE_BEGIN_DATE IN DATE,
	p_PROFILE_END_DATE IN DATE,
	p_PROFILE_OPERATION IN VARCHAR2,
	p_USAGE_ALLOCATION IN OUT NOCOPY USAGE_ALLOCATION_TABLE,
	p_USAGE_ALLOCATION_XREF IN OUT NOCOPY GA.ID_TABLE,
	p_PROFILED_USAGE IN OUT NUMBER,
	p_PROFILE_COUNT IN OUT NUMBER,
	p_IDX IN OUT NUMBER,
	p_USAGE_VALS IN OUT NUMBER_COLLECTION,
	p_USAGE_DATES IN OUT DATE_COLLECTION
	) AS

v_BASE_DATE DATE;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_THIS_DATE DATE; --@@Implementation Override--
v_FACTOR NUMBER;
v_USAGE_VAL NUMBER;
v_INTERVAL NUMBER(8);
v_PROFILE_INTERVAL_DIVISOR NUMBER := FW.INTERVAL_DIVISOR(p_PROFILE_INTERVAL);
v_MINUTES NUMBER(2);
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;
v_IDX PLS_INTEGER;
v_USAGE_VALS NUMBER_COLLECTION;
v_USAGE_DATES DATE_COLLECTION;
v_WITHIN_PERIOD_TBL NUMBER_COLLECTION;
v_PROFILE_INTV_NAME VARCHAR2(64);
v_IS_DST_ZONE BINARY_INTEGER := CASE WHEN UPPER(GA.LOCAL_TIME_ZONE) = UPPER(STD_TIME_ZONE(GA.LOCAL_TIME_ZONE)) THEN 1 ELSE 0 END;

BEGIN

-- Get the profiled usage over the consumption period.
	SELECT DECODE(p_PROFILE_INTERVAL, 48, 30, 96, 15, 60) INTO v_MINUTES FROM DUAL;
	UT.CUT_DATE_RANGE(p_CAST_CONTEXT.MODEL_ID, p_SERVICE_CONSUMPTION.BEGIN_DATE, p_SERVICE_CONSUMPTION.END_DATE, GA.LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
   LOGS.LOG_DEBUG_DETAIL(TEXT_UTIL.TO_CHAR_DATE_RANGE(v_BEGIN_DATE, v_END_DATE));
	SP.CHECK_TEMPLATE_DATES(p_SERVICE_CONSUMPTION.TEMPLATE_ID, CONSTANTS.NOT_ASSIGNED, GA.LOCAL_TIME_ZONE, p_SERVICE_CONSUMPTION.BEGIN_DATE,p_SERVICE_CONSUMPTION.END_DATE);
   v_PROFILE_INTV_NAME := DATE_UTIL.GET_PROFILE_INTERVAL_NAME(p_PROFILE_INTERVAL);

   SELECT TD.CUT_BEGIN_DATE + DT.TIME_STAMP AS CUT_DATE, PROF.USAGE_VAL, CASE WHEN DT.PERIOD_ID = p_SERVICE_CONSUMPTION.PERIOD_ID THEN 1 ELSE 0 END
   BULK COLLECT INTO v_USAGE_DATES, v_USAGE_VALS, v_WITHIN_PERIOD_TBL
   FROM
      (SELECT X.USAGE_DATE AS USAGE_DATE, X.USAGE_VAL AS USAGE_VAL, PROF_LOCAL_DATE, DIM.TGT_INTERVAL
      FROM (SELECT USAGE_DATE, USAGE_VAL, TRUNC(USAGE_DATE-1/86400) AS PROF_LOCAL_DATE FROM TABLE(CAST(p_PROFILE AS USAGE_TABLE))) X, DST_TYPE DT, DST_INTERVAL_MAP DIM
      WHERE PROF_LOCAL_DATE BETWEEN DT.BEGIN_DATE AND DT.END_DATE
         AND DIM.SRC_DST_TYPE = CONSTANTS.DST_TYPE_NONE
         AND DIM.TGT_DST_TYPE = CASE WHEN v_IS_DST_ZONE = 0 THEN DT.DST_TYPE ELSE CONSTANTS.DST_TYPE_NONE END
         AND DIM.INTERVAL = v_PROFILE_INTV_NAME
         AND DIM.SRC_INTERVAL = (X.USAGE_DATE - PROF_LOCAL_DATE)) PROF, TEMPLATE_DATES TD, TEMPLATE_DAY_TYPE_PERIOD DT
   WHERE TD.TEMPLATE_ID = p_SERVICE_CONSUMPTION.TEMPLATE_ID
      AND TD.TIME_ZONE = GA.LOCAL_TIME_ZONE
      AND TD.HOLIDAY_SET_ID = CONSTANTS.NOT_ASSIGNED
      AND TD.LOCAL_DATE = PROF.PROF_LOCAL_DATE
      AND DT.DAY_TYPE_ID = TD.DAY_TYPE_ID
      AND PROF.TGT_INTERVAL = DT.TIME_STAMP
   ORDER BY CUT_DATE;

	v_BEGIN_DATE := CASE WHEN v_BEGIN_DATE > p_PROFILE_BEGIN_DATE THEN v_BEGIN_DATE ELSE p_PROFILE_BEGIN_DATE + 1/NVL(p_PROFILE_INTERVAL,24) END;
   v_END_DATE := CASE WHEN NVL(p_PROFILE_END_DATE,v_END_DATE) >= v_END_DATE THEN v_END_DATE ELSE NVL(p_PROFILE_END_DATE,v_END_DATE)+ 1 END;

	FOR v_IDX IN 1..v_USAGE_DATES.COUNT LOOP
		IF v_USAGE_DATES(v_IDX) BETWEEN v_BEGIN_DATE AND v_END_DATE AND v_WITHIN_PERIOD_TBL(v_IDX) = 1 THEN
			p_IDX := v_IDX;
			p_USAGE_VALS.EXTEND();
			CASE WHEN p_PROFILE_OPERATION = 'Add' OR p_PROFILE_OPERATION = '?' THEN
                p_USAGE_VALS(p_IDX) := NVL(p_USAGE_VALS(p_IDX),0) + v_USAGE_VALS(v_IDX);
			WHEN p_PROFILE_OPERATION = 'Subtract' THEN
                p_USAGE_VALS(p_IDX) := NVL(p_USAGE_VALS(p_IDX),0) - v_USAGE_VALS(v_IDX);
			WHEN p_PROFILE_OPERATION = 'Multiply' THEN
                p_USAGE_VALS(p_IDX) := NVL(p_USAGE_VALS(p_IDX),0) * v_USAGE_VALS(v_IDX);
			ELSE
                p_USAGE_VALS(p_IDX) := v_USAGE_VALS(v_IDX);
			END CASE;
			p_USAGE_DATES(p_IDX) := v_USAGE_DATES(v_IDX);
		END IF;
	END LOOP;

	p_PROFILE_COUNT := p_PROFILE_COUNT - 1;

	IF p_PROFILE_COUNT = 0 THEN -- Calculate Scale Factor Only When Profile Count Becomes 0

   	FOR v_IDX IN 1..p_IDX LOOP
	   	p_PROFILED_USAGE := p_PROFILED_USAGE + p_USAGE_VALS(v_IDX);
	   END LOOP;
	   IF p_PROFILED_USAGE <> 0 THEN
		   v_FACTOR := p_SERVICE_CONSUMPTION.BILLED_USAGE / p_PROFILED_USAGE;
	   ELSE
		   v_FACTOR := 0;
	   END IF;

	   LOGS.LOG_DEBUG('BU: ' || TO_CHAR(p_SERVICE_CONSUMPTION.BILLED_USAGE) || ', PU: ' || TO_CHAR(p_PROFILED_USAGE) || ', F: ' || TO_CHAR(v_FACTOR) || ', BD: ' || TO_CHAR(p_SERVICE_CONSUMPTION.BEGIN_DATE, c_DATE_FORMAT) || ', ED: ' || TO_CHAR(p_SERVICE_CONSUMPTION.END_DATE, c_DATE_FORMAT));

-- Allocate The Consumption Over The Settlement Period Using The Profiled Usage.
	   UT.CUT_DAY_INTERVAL_RANGE(p_CAST_CONTEXT.MODEL_ID, p_CAST_CONTEXT.BEGIN_DATE, p_CAST_CONTEXT.END_DATE, GA.LOCAL_TIME_ZONE, v_MINUTES, v_BASE_DATE, v_END_DATE);
	   UT.CUT_DATE_RANGE(p_CAST_CONTEXT.MODEL_ID, GREATEST(p_CAST_CONTEXT.BEGIN_DATE, p_SERVICE_CONSUMPTION.BEGIN_DATE), LEAST(p_CAST_CONTEXT.END_DATE, p_SERVICE_CONSUMPTION.END_DATE), GA.LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

--@@Begin Implementation Override--
--@@Error Handling For: ORA-06533: Subscript Beyond Count --
         FOR v_IDX IN 1..p_USAGE_DATES.COUNT LOOP
            BEGIN
               IF p_USAGE_DATES(v_IDX) BETWEEN v_BEGIN_DATE AND v_END_DATE AND v_WITHIN_PERIOD_TBL(v_IDX) = 1 THEN
                  v_USAGE_VAL := p_USAGE_VALS(v_IDX) * v_FACTOR;
                  v_THIS_DATE := p_USAGE_DATES(v_IDX);
                  v_INTERVAL := ROUND((v_THIS_DATE - v_BASE_DATE) / v_PROFILE_INTERVAL_DIVISOR) + 1;
                  IF p_USAGE_ALLOCATION_XREF.EXISTS(v_INTERVAL) THEN
                     p_USAGE_ALLOCATION(p_USAGE_ALLOCATION_XREF(v_INTERVAL)).USAGE_VAL :=  p_USAGE_ALLOCATION(p_USAGE_ALLOCATION_XREF(v_INTERVAL)).USAGE_VAL + v_USAGE_VAL;
                  ELSE
                     p_USAGE_ALLOCATION.EXTEND;
                     p_USAGE_ALLOCATION(p_USAGE_ALLOCATION.LAST) := USAGE_ALLOCATION_TYPE(p_SERVICE_CONSUMPTION.ACCOUNT_SERVICE_ID, p_SERVICE_CONSUMPTION.PROVIDER_SERVICE_ID, v_USAGE_DATES(v_IDX), v_USAGE_VAL);
                     p_USAGE_ALLOCATION_XREF(v_INTERVAL) := p_USAGE_ALLOCATION.LAST;
                  END IF;
               END IF;
            EXCEPTION
               WHEN OTHERS THEN
                  LOGS.LOG_WARN('Usage Dates Subscript Beyond Count, Index: ' || TO_CHAR(v_IDX) || ', Count: ' || TO_CHAR(p_USAGE_DATES.COUNT));  
            END;   
         END LOOP;
--@@End Implementation Override--
      LOGS.LOG_DEBUG('Elapsed Time: ' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED) || ', Count: ' || TO_CHAR(p_USAGE_ALLOCATION.COUNT));
   END IF;

END BILLED_USAGE_ALLOCATION;
----------------------------------------------------------------------------------------------------
FUNCTION ASSIGN_USAGE_ALLOCATION
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_XREF_ID IN BINARY_INTEGER,
	p_ACCOUNT_SERVICE_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_PROFILE_INTERVAL IN NUMBER,
	p_USAGE_ALLOCATION IN USAGE_ALLOCATION_TABLE
	) RETURN NUMBER IS

v_COUNT BINARY_INTEGER;
v_INDEX BINARY_INTEGER;
v_INTERVAL BINARY_INTEGER;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_MINUTES NUMBER(2);
v_LOAD_DATE GA.DATE_TABLE;
v_LOAD_VAL GA.FLOAT_TABLE;
v_TX_LOSS GA.FACTOR_TABLE;
v_DX_LOSS GA.FACTOR_TABLE;
v_UE_LOSS GA.FACTOR_TABLE;
v_LOAD NUMBER := 0;
v_PROFILE_INTERVAL_DIVISOR NUMBER := FW.INTERVAL_DIVISOR(p_PROFILE_INTERVAL);
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;
v_INTERVAL_BEGIN_DATE DATE;
v_INTERVAL_END_DATE DATE;
BEGIN

	IF p_USAGE_ALLOCATION.COUNT > 0 THEN

		SELECT DECODE(p_PROFILE_INTERVAL, 48, 30, 96, 15, 60) INTO v_MINUTES FROM DUAL;
		UT.CUT_DATE_RANGE(p_CAST_CONTEXT.MODEL_ID, p_SERVICE_DATE, p_SERVICE_DATE, GA.LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
        UT.CUT_DAY_INTERVAL_RANGE(p_CAST_CONTEXT.MODEL_ID, p_SERVICE_DATE, p_SERVICE_DATE, GA.LOCAL_TIME_ZONE, v_MINUTES, v_INTERVAL_BEGIN_DATE, v_INTERVAL_END_DATE);
        LOGS.LOG_DEBUG_MORE_DETAIL(TEXT_UTIL.TO_CHAR_TIME(v_BEGIN_DATE) || ' '|| TEXT_UTIL.TO_CHAR_TIME(v_END_DATE));
        LOGS.LOG_DEBUG_MORE_DETAIL('INTERVAL BEGIN DATE: ' || TEXT_UTIL.TO_CHAR_TIME(v_INTERVAL_BEGIN_DATE));
-- Cull out the allocation for the current service date in preparation for applying losses.
		v_INDEX := p_USAGE_ALLOCATION.FIRST;

		WHILE v_INDEX <= p_USAGE_ALLOCATION.LAST LOOP
   			IF p_USAGE_ALLOCATION(v_INDEX).USAGE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE THEN
				v_INTERVAL := ROUND((p_USAGE_ALLOCATION(v_INDEX).USAGE_DATE - v_INTERVAL_BEGIN_DATE) / v_PROFILE_INTERVAL_DIVISOR) + 1;
				v_LOAD_DATE(v_INTERVAL) := p_USAGE_ALLOCATION(v_INDEX).USAGE_DATE;
				v_LOAD_VAL(v_INTERVAL) := p_USAGE_ALLOCATION(v_INDEX).USAGE_VAL;
            LOGS.LOG_DEBUG_MORE_DETAIL('INTERVAL: ' || v_INTERVAL);
            LOGS.LOG_DEBUG_MORE_DETAIL('LOAD DATE: ' || TEXT_UTIL.TO_CHAR_TIME(v_LOAD_DATE(v_INTERVAL)));
            LOGS.LOG_DEBUG_MORE_DETAIL('LOAD VAL: ' || v_LOAD_VAL(v_INTERVAL));
			END IF;
			v_INDEX := p_USAGE_ALLOCATION.NEXT(v_INDEX);
		END LOOP;

		IF v_LOAD_DATE.COUNT > 0 THEN
			APPLY_LOSS_FACTORS(p_ACCOUNT_SERVICE_ID, p_EDC_ID, p_SERVICE_DATE, v_LOAD_VAL, v_TX_LOSS, v_DX_LOSS, v_UE_LOSS);
			LOGS.LOG_DEBUG_DETAIL('<index>,<local date>,<cut date>,<load>,<tx loss>,<dx loss>,<ue load>,<buffer count>');
			v_INDEX := v_LOAD_DATE.FIRST;
			WHILE v_INDEX <= v_LOAD_DATE.LAST LOOP
				v_COUNT := g_SERVICE_LOAD_ID.COUNT + 1;
				g_SERVICE_LOAD_ID(v_COUNT) := g_SERVICE_ID(p_XREF_ID);
				IF p_CAST_CONTEXT.MODEL_ID = GA.ELECTRIC_MODEL THEN
                     g_SERVICE_LOAD_DATE(v_COUNT) := v_LOAD_DATE(v_INDEX);
	                IF LOGS.IS_DEBUG_ENABLED THEN
                         LOGS.LOG_DEBUG_MORE_DETAIL('g_SERVICE_LOAD_DATE('||v_COUNT||'): ' || TEXT_UTIL.TO_CHAR_TIME(g_SERVICE_LOAD_DATE(v_COUNT)));
                    END IF;
				ELSE
					g_SERVICE_LOAD_DATE(v_COUNT) := TRUNC(v_LOAD_DATE(v_INDEX));
				END IF;
				g_SERVICE_LOAD_VAL(v_COUNT) := v_LOAD_VAL(v_INDEX);
				g_SERVICE_LOAD_TX_LOSS_VAL(v_COUNT) := v_TX_LOSS(v_INDEX);
				g_SERVICE_LOAD_DX_LOSS_VAL(v_COUNT) := v_DX_LOSS(v_INDEX);
				g_SERVICE_LOAD_UE_LOSS_VAL(v_COUNT) := v_UE_LOSS(v_INDEX);
				v_LOAD := v_LOAD + v_LOAD_VAL(v_INDEX);
				LOGS.LOG_DEBUG_DETAIL(TO_CHAR(v_INDEX) || ',' || TEXT_UTIL.TO_CHAR_DATE(v_LOAD_DATE(v_INDEX)) || ',' || TEXT_UTIL.TO_CHAR_DATE(g_SERVICE_LOAD_DATE(v_COUNT)) || ',' || TO_CHAR(v_LOAD_VAL(v_INDEX)) || ',' || TO_CHAR(v_TX_LOSS(v_INDEX)) || ',' || TO_CHAR(v_DX_LOSS(v_INDEX)) || ',' || TO_CHAR(v_UE_LOSS(v_INDEX)) || '@' || TO_CHAR(v_COUNT));
				v_INDEX := v_LOAD_DATE.NEXT(v_INDEX);
			END LOOP;
		END IF;
	END IF;
	LOGS.LOG_DEBUG('ASSIGN_USAGE_ALLOCATION TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED) || ', SERVICE DATE=' || TO_CHAR(p_SERVICE_DATE) || ', COUNT=' || TO_CHAR(v_LOAD_DATE.COUNT) || ', LOAD=' || TO_CHAR(v_LOAD));
	RETURN v_LOAD;
END ASSIGN_USAGE_ALLOCATION;
----------------------------------------------------------------------------------------------------
PROCEDURE ASSIGN_SERVICE_USAGE
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_ACCOUNT_SERVICE_ID IN NUMBER,
	p_PROVIDER_SERVICE_ID IN NUMBER,
	p_SERVICE_DELIVERY_ID IN NUMBER,
	p_PROFILE_INTERVAL IN NUMBER,
	p_USAGE_ALLOCATION IN USAGE_ALLOCATION_TABLE
	) AS

v_SERVICE_DATE DATE := p_CAST_CONTEXT.BEGIN_DATE;
v_XREF_ID BINARY_INTEGER;
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;
v_ACCOUNT_SERVICE ACCOUNT_SERVICE%ROWTYPE := CX.GET_ACCOUNT_SERVICE(p_ACCOUNT_SERVICE_ID);
v_PROVIDER_SERVICE PROVIDER_SERVICE%ROWTYPE := CX.GET_PROVIDER_SERVICE(p_PROVIDER_SERVICE_ID);
v_SERVICE_DELIVERY SERVICE_DELIVERY%ROWTYPE := CX.GET_SERVICE_DELIVERY(p_SERVICE_DELIVERY_ID);
v_IS_AGGREGATE_POOL NUMBER(1) := v_SERVICE_DELIVERY.IS_AGGREGATE_POOL;
v_LOAD NUMBER := 0;

BEGIN

-- Clear the Buffers.
	g_SERVICE_XREF.DELETE;
	g_SERVICE_ID.DELETE;
	g_SERVICE_DATE.DELETE;
	g_IS_UFE_PARTICIPANT.DELETE;
	g_METER_TYPE.DELETE;
	g_IS_EXTERNAL_FORECAST.DELETE;
	g_IS_AGGREGATE_ACCOUNT.DELETE;
	g_IS_AGGREGATE_POOL.DELETE;
	g_USAGE_FACTOR.DELETE;
	g_SERVICE_ACCOUNTS.DELETE;
	g_SERVICE_INTERVALS.DELETE;
	g_PROFILE_TYPE.DELETE;
	g_PROFILE_SOURCE_DATE.DELETE;
	g_PROFILE_ZERO_COUNT.DELETE;
	g_PROXY_DAY_METHOD_ID.DELETE;

	INITIALIZE_SERVICE_LOAD;

-- Loop over the time period and create service records.
	WHILE v_SERVICE_DATE <= p_CAST_CONTEXT.END_DATE LOOP

		v_XREF_ID := g_SERVICE_XREF.COUNT + 1;
		g_SERVICE_XREF(v_XREF_ID) := v_XREF_ID;

		g_SERVICE_DATE(v_XREF_ID) := v_SERVICE_DATE;
		g_IS_UFE_PARTICIPANT(v_XREF_ID) := CX.GET_IS_UFE_PARTICIPANT(v_ACCOUNT_SERVICE.ACCOUNT_ID);

		g_METER_TYPE(v_XREF_ID) := 'P';
		g_IS_EXTERNAL_FORECAST(v_XREF_ID) := CONSTANTS.NOT_ASSIGNED;
		SELECT DECODE(v_ACCOUNT_SERVICE.AGGREGATE_ID, CONSTANTS.NOT_ASSIGNED, 0, 1) INTO g_IS_AGGREGATE_ACCOUNT(v_XREF_ID) FROM DUAL;
		g_IS_AGGREGATE_POOL(v_XREF_ID) := v_IS_AGGREGATE_POOL;
		g_SERVICE_ACCOUNTS(v_XREF_ID) := CONSTANTS.NOT_ASSIGNED;

		g_SERVICE_ID(v_XREF_ID) := CX.GET_SERVICE_ID(p_CAST_CONTEXT, p_PROVIDER_SERVICE_ID, p_ACCOUNT_SERVICE_ID, p_SERVICE_DELIVERY_ID);

		g_USAGE_FACTOR(v_XREF_ID) := 1;
		g_SERVICE_INTERVALS(v_XREF_ID) := 1;

		g_PROFILE_TYPE(v_XREF_ID) := g_ACTUAL_USAGE_PROFILE;
		g_PROFILE_SOURCE_DATE(v_XREF_ID) := v_SERVICE_DATE;
		g_PROFILE_ZERO_COUNT(v_XREF_ID) := 0;
		g_PROXY_DAY_METHOD_ID(v_XREF_ID) := NULL; -- no proxy days in usage allocation

		v_LOAD := v_LOAD + ASSIGN_USAGE_ALLOCATION(p_CAST_CONTEXT, v_XREF_ID, p_ACCOUNT_SERVICE_ID, v_PROVIDER_SERVICE.EDC_ID, v_SERVICE_DATE, p_PROFILE_INTERVAL, p_USAGE_ALLOCATION);

 		v_SERVICE_DATE := v_SERVICE_DATE + 1;

	END LOOP;

	LOGS.LOG_DEBUG('ASSIGN_SERVICE_USAGE TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED) || ', ACCOUNT_SERVICE_ID=' || TO_CHAR(p_ACCOUNT_SERVICE_ID) || ', PROVIDER_SERVICE_ID=' || TO_CHAR(p_PROVIDER_SERVICE_ID) || ', SERVICE_DELIVERY_ID=' || TO_CHAR(p_SERVICE_DELIVERY_ID)|| ', LOAD=' || TO_CHAR(v_LOAD));

END ASSIGN_SERVICE_USAGE;
----------------------------------------------------------------------------------------------------
PROCEDURE DELETE_ACTUAL_SERVICE
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_ACCOUNT_SERVICE_ID IN NUMBER,
	p_PROVIDER_SERVICE_ID IN NUMBER,
	p_SERVICE_DELIVERY_ID IN NUMBER
	) AS
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;
BEGIN
	DELETE SERVICE_STATE A
	WHERE EXISTS
		(SELECT 1
		FROM SERVICE
		WHERE MODEL_ID = p_CAST_CONTEXT.MODEL_ID
			AND SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
			AND AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE
			AND PROVIDER_SERVICE_ID = p_PROVIDER_SERVICE_ID
			AND ACCOUNT_SERVICE_ID = p_ACCOUNT_SERVICE_ID
			AND SERVICE_DELIVERY_ID = p_SERVICE_DELIVERY_ID
			AND SERVICE_ID = A.SERVICE_ID)
		AND A.SERVICE_CODE = GA.ACTUAL_SERVICE
		AND A.SERVICE_DATE BETWEEN p_CAST_CONTEXT.BEGIN_DATE AND p_CAST_CONTEXT.END_DATE;
		LOGS.LOG_DEBUG('ELAPSED TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED) || ', ACCOUNT_SERVICE_ID=' || TO_CHAR(p_ACCOUNT_SERVICE_ID) || ', PROVIDER_SERVICE_ID=' || TO_CHAR(p_PROVIDER_SERVICE_ID) || ', COUNT=' || TO_CHAR(SQL%ROWCOUNT));
END DELETE_ACTUAL_SERVICE;
----------------------------------------------------------------------------------------------------
PROCEDURE CONSUMPTION_ALLOCATION_REQUEST
	(
	p_CAST_CONTEXT IN OUT NOCOPY CAST_CONTEXT_TYPE
	) AS

v_EARLIEST_BEGIN_DATE DATE;
v_LATEST_END_DATE DATE;
v_ACCOUNT_SERVICE_ID NUMBER(9) := -999;
v_PROVIDER_SERVICE_ID NUMBER(9) := -999;
v_SERVICE_DELIVERY_ID NUMBER(9) := -999;
v_PROFILE_ID NUMBER(9) := -999;
v_PROFILE_INTERVAL NUMBER(6);
v_PROFILE USAGE_TABLE := USAGE_TABLE();
v_USAGE_ALLOCATION USAGE_ALLOCATION_TABLE := USAGE_ALLOCATION_TABLE();
v_USAGE_ALLOCATION_XREF GA.ID_TABLE;
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;
v_PROGRESS_COUNT NUMBER(9);
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_PROFILE_OPERATION VARCHAR2(16);
v_PROFILED_USAGE NUMBER;
v_TOTAL_COUNT NUMBER(6);
v_IDX NUMBER;
v_USAGE_VALS NUMBER_COLLECTION := NUMBER_COLLECTION();
v_USAGE_DATES DATE_COLLECTION;

CURSOR c_CONSUMPTION IS
   SELECT DISTINCT C.BEGIN_DATE AS X, C.END_DATE AS Y, D.BEGIN_DATE AS XX, D.END_DATE AS YY, D.PROFILE_ID, F.ACCOUNT_SERVICE_ID, F.PROVIDER_SERVICE_ID, F.SERVICE_DELIVERY_ID, H.BEGIN_DATE, H.END_DATE, H.CONSUMPTION_ID
   FROM ACCOUNT A, ACCOUNT_STATUS B, ACCOUNT_STATUS_NAME STATUS_NAME, ACCOUNT_CALENDAR C, CALENDAR_PROFILE D, ACCOUNT_SERVICE E, SERVICE F, PROVIDER_SERVICE G, SERVICE_CONSUMPTION H
   WHERE (p_CAST_CONTEXT.ACCOUNT_ID = g_ALL OR A.ACCOUNT_ID = p_CAST_CONTEXT.ACCOUNT_ID)
      AND UPPER(SUBSTR(A.ACCOUNT_MODEL_OPTION,1,1)) = 'A'
      AND A.IS_SUB_AGGREGATE = 0
      AND A.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
      AND UPPER(SUBSTR(A.ACCOUNT_METER_TYPE,1,1)) = 'P'
      AND B.ACCOUNT_ID = A.ACCOUNT_ID
      AND B.BEGIN_DATE <= p_CAST_CONTEXT.END_DATE
      AND NVL(B.END_DATE,p_CAST_CONTEXT.END_DATE) >= p_CAST_CONTEXT.BEGIN_DATE
      AND STATUS_NAME.STATUS_NAME = B.STATUS_NAME
      AND STATUS_NAME.IS_ACTIVE = 1
      AND C.CASE_ID = p_CAST_CONTEXT.CALENDAR_CASE_ID
      AND C.ACCOUNT_ID = A.ACCOUNT_ID
      AND C.CALENDAR_TYPE = 'Settlement'
      AND C.BEGIN_DATE <= p_CAST_CONTEXT.END_DATE
      AND NVL(C.END_DATE,p_CAST_CONTEXT.END_DATE) >= p_CAST_CONTEXT.BEGIN_DATE
      AND D.CALENDAR_ID = C.CALENDAR_ID
      AND D.BEGIN_DATE <= p_CAST_CONTEXT.END_DATE
      AND NVL(D.END_DATE,p_CAST_CONTEXT.END_DATE) >= p_CAST_CONTEXT.BEGIN_DATE
      AND E.ACCOUNT_ID = A.ACCOUNT_ID
      AND F.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
      AND F.SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
      AND F.AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE
      AND F.PROVIDER_SERVICE_ID = G.PROVIDER_SERVICE_ID
      AND F.ACCOUNT_SERVICE_ID = E.ACCOUNT_SERVICE_ID
      AND (p_CAST_CONTEXT.EDC_ID = g_ALL OR G.EDC_ID = p_CAST_CONTEXT.EDC_ID)
      AND (p_CAST_CONTEXT.ESP_ID = g_ALL OR G.ESP_ID = p_CAST_CONTEXT.ESP_ID)
      AND H.SERVICE_ID = F.SERVICE_ID
      AND H.BEGIN_DATE <= TRUNC(p_CAST_CONTEXT.END_DATE)
      AND H.END_DATE >= TRUNC(p_CAST_CONTEXT.BEGIN_DATE)
      AND H.BILL_CODE = GA.BILL_CONSUMPTION
      AND H.CONSUMPTION_CODE = GA.ACTUAL_CONSUMPTION
      AND UPPER(H.UNIT_OF_MEASUREMENT) = UPPER(GA.DEFAULT_UNIT_OF_MEASUREMENT)
   UNION ALL SELECT DISTINCT F.BEGIN_DATE AS X, F.END_DATE AS Y, G.BEGIN_DATE AS XX, G.END_DATE AS YY, G.PROFILE_ID, I.ACCOUNT_SERVICE_ID, I.PROVIDER_SERVICE_ID, I.SERVICE_DELIVERY_ID, K.BEGIN_DATE, K.END_DATE, K.CONSUMPTION_ID
   FROM ACCOUNT A, ACCOUNT_STATUS B, ACCOUNT_STATUS_NAME STATUS_NAME, ACCOUNT_SERVICE_LOCATION C, SERVICE_LOCATION_METER D, METER E, ACCOUNT_STATUS_NAME MSN, METER_CALENDAR F, CALENDAR_PROFILE G, ACCOUNT_SERVICE H, SERVICE I, PROVIDER_SERVICE J, SERVICE_CONSUMPTION K
   WHERE (p_CAST_CONTEXT.ACCOUNT_ID = g_ALL OR A.ACCOUNT_ID = p_CAST_CONTEXT.ACCOUNT_ID)
      AND UPPER(SUBSTR(A.ACCOUNT_MODEL_OPTION,1,1)) = 'M'
      AND A.IS_SUB_AGGREGATE = 0
      AND B.ACCOUNT_ID = A.ACCOUNT_ID
      AND B.BEGIN_DATE <= p_CAST_CONTEXT.END_DATE
      AND NVL(B.END_DATE,p_CAST_CONTEXT.END_DATE) >= p_CAST_CONTEXT.BEGIN_DATE
      AND STATUS_NAME.STATUS_NAME = B.STATUS_NAME
      AND STATUS_NAME.IS_ACTIVE = 1
      AND C.ACCOUNT_ID = A.ACCOUNT_ID
      AND C.BEGIN_DATE <= p_CAST_CONTEXT.END_DATE
      AND NVL(C.END_DATE,p_CAST_CONTEXT.END_DATE) >= p_CAST_CONTEXT.BEGIN_DATE
      AND D.SERVICE_LOCATION_ID = C.SERVICE_LOCATION_ID
      AND D.BEGIN_DATE <= p_CAST_CONTEXT.END_DATE
      AND NVL(D.END_DATE,p_CAST_CONTEXT.END_DATE) >= p_CAST_CONTEXT.BEGIN_DATE
      AND E.METER_ID = D.METER_ID
      AND MSN.STATUS_NAME = E.METER_STATUS
      AND MSN.IS_ACTIVE = 1
      AND A.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
      AND UPPER(SUBSTR(E.METER_TYPE,1,1)) = 'P'
      AND F.CASE_ID = p_CAST_CONTEXT.CALENDAR_CASE_ID
      AND F.METER_ID = E.METER_ID
      AND F.CALENDAR_TYPE = 'Settlement'
      AND G.CALENDAR_ID = F.CALENDAR_ID
      AND G.BEGIN_DATE <= p_CAST_CONTEXT.END_DATE
      AND NVL(G.END_DATE,p_CAST_CONTEXT.END_DATE) >= p_CAST_CONTEXT.BEGIN_DATE
      AND H.METER_ID = F.METER_ID
      AND I.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
      AND I.SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
      AND I.AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE
      AND I.PROVIDER_SERVICE_ID = J.PROVIDER_SERVICE_ID
      AND I.ACCOUNT_SERVICE_ID = H.ACCOUNT_SERVICE_ID
      AND (p_CAST_CONTEXT.EDC_ID = g_ALL OR J.EDC_ID = p_CAST_CONTEXT.EDC_ID)
      AND (p_CAST_CONTEXT.ESP_ID = g_ALL OR J.ESP_ID = p_CAST_CONTEXT.ESP_ID)
      AND K.SERVICE_ID = I.SERVICE_ID
      AND K.BEGIN_DATE <= TRUNC(p_CAST_CONTEXT.END_DATE)
      AND K.END_DATE >= TRUNC(p_CAST_CONTEXT.BEGIN_DATE)
      AND K.BILL_CODE = GA.BILL_CONSUMPTION
      AND K.CONSUMPTION_CODE = GA.ACTUAL_CONSUMPTION
      AND UPPER(K.UNIT_OF_MEASUREMENT) = UPPER(GA.DEFAULT_UNIT_OF_MEASUREMENT)
   ORDER BY 1,2,3,4,5,6,7,8;

CURSOR c_CONSUMPTION_SEGMENT IS
   SELECT SERVICE_CONSUMPTION_TYPE(A.ACCOUNT_SERVICE_ID, A.PROVIDER_SERVICE_ID, A.SERVICE_DELIVERY_ID, B.BEGIN_DATE, B.END_DATE, B.TEMPLATE_ID, B.PERIOD_ID, B.BILLED_USAGE) AS CS_TYPE
   FROM SERVICE A, SERVICE_CONSUMPTION B
   WHERE A.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
      AND A.SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
      AND A.AS_OF_DATE = g_LOW_DATE
      AND A.PROVIDER_SERVICE_ID = v_PROVIDER_SERVICE_ID
      AND A.ACCOUNT_SERVICE_ID = v_ACCOUNT_SERVICE_ID
      AND A.SERVICE_DELIVERY_ID = v_SERVICE_DELIVERY_ID
      AND B.SERVICE_ID = A.SERVICE_ID
      AND B.BEGIN_DATE <= TRUNC(p_CAST_CONTEXT.END_DATE)
      AND B.END_DATE >= TRUNC(p_CAST_CONTEXT.BEGIN_DATE)
      AND B.BILL_CODE = GA.BILL_CONSUMPTION
      AND B.CONSUMPTION_CODE = GA.ACTUAL_CONSUMPTION
      AND UPPER(B.UNIT_OF_MEASUREMENT) = UPPER(GA.DEFAULT_UNIT_OF_MEASUREMENT); --@@Implementation Override--

   PROCEDURE ALLOCATE_PREVIOUS_RESULTS IS
   BEGIN
      IF v_ACCOUNT_SERVICE_ID > 0 AND v_PROFILE_ID > 0 THEN
         LOGS.LOG_DEBUG('FP.GET_SETTLEMENT_PROFILE v_PROFILE_ID: '||TO_CHAR(v_PROFILE_ID) || ' v_EARLIEST_BEGIN_DATE: ' || TO_CHAR(v_EARLIEST_BEGIN_DATE,'MM-DD-YYYY') || ', v_LATEST_END_DATE: ' || TO_CHAR(v_LATEST_END_DATE,'MM-DD-YYYY'));
--Cache the settlement profile over the date range.
         FP.GET_SETTLEMENT_PROFILE(p_CAST_CONTEXT, v_PROFILE_ID, v_EARLIEST_BEGIN_DATE, v_LATEST_END_DATE, v_PROFILE);
-- Loop over each of the consumption segments and allocate the billed usage to the account and provider using the profile.
         FOR v_CONSUMPTION_SEGMENT IN c_CONSUMPTION_SEGMENT LOOP
            LOGS.LOG_DEBUG('BILLED_USAGE_ALLOCATION v_PROFILE_ID: '||TO_CHAR(v_PROFILE_ID) || ' v_BEGIN_DATE: ' || TO_CHAR(v_BEGIN_DATE,'MM-DD-YYYY') || ', v_END_DATE: ' || TO_CHAR(v_END_DATE,'MM-DD-YYYY'));
            BILLED_USAGE_ALLOCATION(p_CAST_CONTEXT, v_CONSUMPTION_SEGMENT.CS_TYPE, v_PROFILE, v_PROFILE_INTERVAL, v_BEGIN_DATE, v_END_DATE, v_PROFILE_OPERATION, v_USAGE_ALLOCATION, v_USAGE_ALLOCATION_XREF, v_PROFILED_USAGE, v_TOTAL_COUNT, v_IDX, v_USAGE_VALS, v_USAGE_DATES);
         END LOOP;
         ASSIGN_SERVICE_USAGE(p_CAST_CONTEXT, v_ACCOUNT_SERVICE_ID, v_PROVIDER_SERVICE_ID, v_SERVICE_DELIVERY_ID, v_PROFILE_INTERVAL, v_USAGE_ALLOCATION);
         DELETE_ACTUAL_SERVICE(p_CAST_CONTEXT, v_ACCOUNT_SERVICE_ID, v_PROVIDER_SERVICE_ID, v_SERVICE_DELIVERY_ID);
         STORE_SERVICE_STATE(p_CAST_CONTEXT);
         STORE_SERVICE_LOAD(p_CAST_CONTEXT);
         -- Commit incremental work in multi-day runs to reduce roll-back overhead.
         IF p_CAST_CONTEXT.INCREMENTAL_COMMIT = 1 THEN COMMIT; END IF;
      END IF;
   END ALLOCATE_PREVIOUS_RESULTS;

BEGIN

-- Option To Only Rollup The Cast Detail To Summary Level.
   IF p_CAST_CONTEXT.ACCOUNT_PROCESS_MODE = g_SUMMARY_ONLY THEN
      SET_SERVICE_OBLIGATION(p_CAST_CONTEXT);
      RETURN;
   END IF;

   INITIALIZE_SERVICE;
   CX.INITIALIZE_CACHE(p_CAST_CONTEXT);

   SELECT COUNT(A.PROFILE_ID) INTO V_PROGRESS_COUNT
   FROM (SELECT DISTINCT D.PROFILE_ID, F.ACCOUNT_SERVICE_ID, F.PROVIDER_SERVICE_ID, F.SERVICE_DELIVERY_ID, H.BEGIN_DATE, H.END_DATE, H.CONSUMPTION_ID
      FROM ACCOUNT A, ACCOUNT_STATUS B, ACCOUNT_STATUS_NAME STATUS_NAME, ACCOUNT_CALENDAR C, CALENDAR_PROFILE D, ACCOUNT_SERVICE E, SERVICE F, PROVIDER_SERVICE G, SERVICE_CONSUMPTION H
      WHERE (p_CAST_CONTEXT.ACCOUNT_ID = g_ALL OR A.ACCOUNT_ID = p_CAST_CONTEXT.ACCOUNT_ID)
         AND UPPER(SUBSTR(A.ACCOUNT_MODEL_OPTION,1,1)) = 'A'
         AND A.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
         AND A.IS_SUB_AGGREGATE = 0
         AND UPPER(SUBSTR(A.ACCOUNT_METER_TYPE,1,1)) = 'P'
         AND B.ACCOUNT_ID = A.ACCOUNT_ID
         AND B.BEGIN_DATE <= p_CAST_CONTEXT.END_DATE
         AND NVL(B.END_DATE,p_CAST_CONTEXT.END_DATE) >= p_CAST_CONTEXT.BEGIN_DATE
         AND STATUS_NAME.STATUS_NAME = B.STATUS_NAME
         AND STATUS_NAME.IS_ACTIVE = 1
         AND C.CASE_ID = p_CAST_CONTEXT.CALENDAR_CASE_ID
         AND C.ACCOUNT_ID = A.ACCOUNT_ID
         AND C.CALENDAR_TYPE = 'Settlement'
         AND C.BEGIN_DATE <= p_CAST_CONTEXT.END_DATE
         AND NVL(C.END_DATE,p_CAST_CONTEXT.END_DATE) >= p_CAST_CONTEXT.BEGIN_DATE
         AND D.CALENDAR_ID = C.CALENDAR_ID
         AND D.BEGIN_DATE <= p_CAST_CONTEXT.END_DATE
         AND NVL(D.END_DATE,p_CAST_CONTEXT.END_DATE) >= p_CAST_CONTEXT.BEGIN_DATE
         AND E.ACCOUNT_ID = A.ACCOUNT_ID
         AND F.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
         AND F.SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
         AND F.AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE
         AND F.PROVIDER_SERVICE_ID = G.PROVIDER_SERVICE_ID
         AND F.ACCOUNT_SERVICE_ID = E.ACCOUNT_SERVICE_ID
         AND (p_CAST_CONTEXT.EDC_ID = g_ALL OR G.EDC_ID = p_CAST_CONTEXT.EDC_ID)
         AND (p_CAST_CONTEXT.ESP_ID = g_ALL OR G.ESP_ID = p_CAST_CONTEXT.ESP_ID)
         AND H.SERVICE_ID = F.SERVICE_ID
         AND H.BEGIN_DATE <= TRUNC(p_CAST_CONTEXT.END_DATE)
         AND H.END_DATE >= TRUNC(p_CAST_CONTEXT.BEGIN_DATE)
         AND H.BILL_CODE = GA.BILL_CONSUMPTION
         AND H.CONSUMPTION_CODE = GA.ACTUAL_CONSUMPTION
         AND UPPER(H.UNIT_OF_MEASUREMENT) = UPPER(GA.DEFAULT_UNIT_OF_MEASUREMENT) --@@Implementation Override--
      UNION ALL SELECT DISTINCT G.PROFILE_ID, I.ACCOUNT_SERVICE_ID, I.PROVIDER_SERVICE_ID, I.SERVICE_DELIVERY_ID, K.BEGIN_DATE, K.END_DATE, K.CONSUMPTION_ID
      FROM ACCOUNT A, ACCOUNT_STATUS B, ACCOUNT_STATUS_NAME STATUS_NAME, ACCOUNT_SERVICE_LOCATION C, SERVICE_LOCATION_METER D, METER E, ACCOUNT_STATUS_NAME MSN, METER_CALENDAR F, CALENDAR_PROFILE G, ACCOUNT_SERVICE H, SERVICE I, PROVIDER_SERVICE J, SERVICE_CONSUMPTION K
      WHERE (p_CAST_CONTEXT.ACCOUNT_ID = g_ALL OR A.ACCOUNT_ID = p_CAST_CONTEXT.ACCOUNT_ID)
         AND UPPER(SUBSTR(A.ACCOUNT_MODEL_OPTION,1,1)) = 'M'
         AND A.IS_SUB_AGGREGATE = 0
         AND B.ACCOUNT_ID = A.ACCOUNT_ID
         AND B.BEGIN_DATE <= p_CAST_CONTEXT.END_DATE
         AND NVL(B.END_DATE,p_CAST_CONTEXT.END_DATE) >= p_CAST_CONTEXT.BEGIN_DATE
         AND STATUS_NAME.STATUS_NAME = B.STATUS_NAME
         AND STATUS_NAME.IS_ACTIVE = 1
         AND C.ACCOUNT_ID = A.ACCOUNT_ID
         AND C.BEGIN_DATE <= p_CAST_CONTEXT.END_DATE
         AND NVL(C.END_DATE,p_CAST_CONTEXT.END_DATE) >= p_CAST_CONTEXT.BEGIN_DATE
         AND D.SERVICE_LOCATION_ID = C.SERVICE_LOCATION_ID
         AND D.BEGIN_DATE <= p_CAST_CONTEXT.END_DATE
         AND NVL(D.END_DATE,p_CAST_CONTEXT.END_DATE) >= p_CAST_CONTEXT.BEGIN_DATE
         AND E.METER_ID = D.METER_ID
         AND MSN.STATUS_NAME = E.METER_STATUS
         AND MSN.IS_ACTIVE = 1
         AND A.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
         AND UPPER(SUBSTR(E.METER_TYPE,1,1)) = 'P'
         AND F.CASE_ID = p_CAST_CONTEXT.CALENDAR_CASE_ID
         AND F.METER_ID = E.METER_ID
         AND F.CALENDAR_TYPE = 'Settlement'
         AND G.CALENDAR_ID = F.CALENDAR_ID
         AND G.BEGIN_DATE <= p_CAST_CONTEXT.END_DATE
         AND NVL(G.END_DATE,p_CAST_CONTEXT.END_DATE) >= p_CAST_CONTEXT.BEGIN_DATE
         AND H.METER_ID = F.METER_ID
         AND I.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
         AND I.SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
         AND I.AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE
         AND I.PROVIDER_SERVICE_ID = J.PROVIDER_SERVICE_ID
         AND I.ACCOUNT_SERVICE_ID = H.ACCOUNT_SERVICE_ID
         AND (p_CAST_CONTEXT.EDC_ID = g_ALL OR J.EDC_ID = p_CAST_CONTEXT.EDC_ID)
         AND (p_CAST_CONTEXT.ESP_ID = g_ALL OR J.ESP_ID = p_CAST_CONTEXT.ESP_ID)
         AND K.SERVICE_ID = I.SERVICE_ID
         AND K.BEGIN_DATE <= TRUNC(p_CAST_CONTEXT.END_DATE)
         AND K.END_DATE >= TRUNC(p_CAST_CONTEXT.BEGIN_DATE)
         AND K.BILL_CODE = GA.BILL_CONSUMPTION
         AND K.CONSUMPTION_CODE = GA.ACTUAL_CONSUMPTION
         AND UPPER(K.UNIT_OF_MEASUREMENT) = UPPER(GA.DEFAULT_UNIT_OF_MEASUREMENT)) A;  --@@Implementation Override--

	v_TOTAL_COUNT := v_PROGRESS_COUNT; --Count Of Number Of Profiles
   LOGS.INIT_PROCESS_PROGRESS(p_TOTAL_WORK => v_PROGRESS_COUNT + 1, p_CAN_TERMINATE => TRUE);
   DELETE_SERVICE_NON_INTERVAL(p_CAST_CONTEXT);
   v_PROFILED_USAGE := 0;
   v_IDX := 0;

   FOR v_CONSUMPTION IN c_CONSUMPTION LOOP
      LOGS.LOG_DEBUG('PS: ' || TO_CHAR(v_CONSUMPTION.PROVIDER_SERVICE_ID) || ', AS: ' || TO_CHAR(v_CONSUMPTION.ACCOUNT_SERVICE_ID) || ', SD: ' || TO_CHAR(v_CONSUMPTION.SERVICE_DELIVERY_ID) || ', P: ' || TO_CHAR(v_CONSUMPTION.PROFILE_ID) || ', BD: ' || TO_CHAR(v_CONSUMPTION.BEGIN_DATE, c_DATE_FORMAT) || ', ED: ' || TO_CHAR(v_CONSUMPTION.END_DATE, c_DATE_FORMAT) || ', CID: ' || TO_CHAR(v_CONSUMPTION.CONSUMPTION_ID));
	--If These Are The Same Record, Then Do The Allocation.
      IF v_ACCOUNT_SERVICE_ID = v_CONSUMPTION.ACCOUNT_SERVICE_ID AND v_PROVIDER_SERVICE_ID = v_CONSUMPTION.PROVIDER_SERVICE_ID AND v_SERVICE_DELIVERY_ID = v_CONSUMPTION.SERVICE_DELIVERY_ID AND v_PROFILE_ID = v_CONSUMPTION.PROFILE_ID THEN
         v_EARLIEST_BEGIN_DATE := LEAST(v_EARLIEST_BEGIN_DATE, v_CONSUMPTION.BEGIN_DATE);
         v_LATEST_END_DATE := GREATEST(v_LATEST_END_DATE, v_CONSUMPTION.END_DATE);
         LOGS.LOG_DEBUG('v_EARLIEST_BEGIN_DATE: ' || TO_CHAR(v_EARLIEST_BEGIN_DATE,'MM-DD-YYYY') || ', v_LATEST_END_DATE: ' || TO_CHAR(v_LATEST_END_DATE,'MM-DD-YYYY'));
      ELSE
         ALLOCATE_PREVIOUS_RESULTS;
         v_USAGE_ALLOCATION.DELETE;
         v_USAGE_ALLOCATION_XREF.DELETE;
         v_ACCOUNT_SERVICE_ID := v_CONSUMPTION.ACCOUNT_SERVICE_ID;
         v_PROVIDER_SERVICE_ID := v_CONSUMPTION.PROVIDER_SERVICE_ID;
         v_SERVICE_DELIVERY_ID := v_CONSUMPTION.SERVICE_DELIVERY_ID;
         v_EARLIEST_BEGIN_DATE := v_CONSUMPTION.BEGIN_DATE;
         v_LATEST_END_DATE := v_CONSUMPTION.END_DATE;
         IF NOT v_PROFILE_ID = v_CONSUMPTION.PROFILE_ID THEN
            v_PROFILE_ID := v_CONSUMPTION.PROFILE_ID;
            v_PROFILE_INTERVAL := FP.GET_PROFILE_INTERVAL(v_PROFILE_ID);
            v_BEGIN_DATE :=  v_CONSUMPTION.X; --Profile begin date
            v_END_DATE :=  v_CONSUMPTION.Y; --Profile end date
            SELECT PROFILE_OPERATION INTO v_PROFILE_OPERATION
            FROM LOAD_PROFILE
            WHERE PROFILE_ID = v_CONSUMPTION.PROFILE_ID;
         END IF;
      END IF;
      LOGS.INCREMENT_PROCESS_PROGRESS();
   END LOOP;

   ALLOCATE_PREVIOUS_RESULTS;
   LOGS.INCREMENT_PROCESS_PROGRESS();

   IF p_CAST_CONTEXT.ACCOUNT_ID < 0 THEN
      SET_SERVICE_OBLIGATION(p_CAST_CONTEXT);
      p_CAST_CONTEXT.SERVICE_DATE := p_CAST_CONTEXT.BEGIN_DATE;
      WHILE p_CAST_CONTEXT.SERVICE_DATE <= p_CAST_CONTEXT.END_DATE LOOP
         CS.PUT_PROCESS_STATUS(p_CAST_CONTEXT.PROCESS_NAME, p_CAST_CONTEXT.SERVICE_DATE, p_CAST_CONTEXT.OUTPUT_AS_OF_DATE, 'Pending', SYSDATE);
         p_CAST_CONTEXT.SERVICE_DATE := p_CAST_CONTEXT.SERVICE_DATE + 1;
      END LOOP;
   END IF;
	CX.RELEASE_CACHE;
   LOGS.LOG_DEBUG('Elspsed Time: ' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED));
EXCEPTION
   WHEN OTHERS THEN
      BEGIN CX.RELEASE_CACHE; EXCEPTION WHEN OTHERS THEN ERRS.LOG_AND_CONTINUE();END;
      ERRS.LOG_AND_RAISE();
END CONSUMPTION_ALLOCATION_REQUEST;

--@@Begin Implementation Override --
PROCEDURE BILLED_USAGE_ALLOCATION_V55
   (
   p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
   p_SERVICE_CONSUMPTION IN SERVICE_CONSUMPTION_TYPE,
   p_PROFILE IN USAGE_TABLE,
   p_PROFILE_INTERVAL IN NUMBER,
   p_USAGE_ALLOCATION IN OUT NOCOPY USAGE_ALLOCATION_TABLE,
   p_USAGE_ALLOCATION_XREF IN OUT NOCOPY GA.ID_TABLE
   ) AS

v_BASE_DATE DATE;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_PROFILED_USAGE NUMBER;
v_FACTOR NUMBER;
v_USAGE_VAL NUMBER;
v_INTERVAL NUMBER(6);
v_PROFILE_INTERVAL_DIVISOR NUMBER := FW.INTERVAL_DIVISOR(p_PROFILE_INTERVAL);
v_MINUTES NUMBER(2);
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;

v_USAGE_VALS NUMBER_COLLECTION;
v_USAGE_DATES DATE_COLLECTION;
v_WITHIN_PERIOD_TBL NUMBER_COLLECTION;
v_PROFILE_INTV_NAME VARCHAR2(64);
v_IS_DST_ZONE BINARY_INTEGER := CASE WHEN UPPER(GA.LOCAL_TIME_ZONE) = UPPER(STD_TIME_ZONE(GA.LOCAL_TIME_ZONE)) THEN 1 ELSE 0 END;

BEGIN

-- Get the profiled usage over the consumption period.
   SELECT DECODE(p_PROFILE_INTERVAL, 48, 30, 96, 15, 60) INTO v_MINUTES FROM DUAL;
   UT.CUT_DATE_RANGE(p_CAST_CONTEXT.MODEL_ID, p_SERVICE_CONSUMPTION.BEGIN_DATE, p_SERVICE_CONSUMPTION.END_DATE, GA.LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
     IF LOGS.IS_DEBUG_ENABLED THEN
        LOGS.LOG_DEBUG_MORE_DETAIL(TEXT_UTIL.TO_CHAR_DATE_RANGE(v_BEGIN_DATE, v_END_DATE));
    END IF;
   SP.CHECK_TEMPLATE_DATES(p_SERVICE_CONSUMPTION.TEMPLATE_ID,
                     CONSTANTS.NOT_ASSIGNED,
                     GA.LOCAL_TIME_ZONE,
                     p_SERVICE_CONSUMPTION.BEGIN_DATE,
                     p_SERVICE_CONSUMPTION.END_DATE);

    v_PROFILE_INTV_NAME := DATE_UTIL.GET_PROFILE_INTERVAL_NAME(p_PROFILE_INTERVAL);

    SELECT TD.CUT_BEGIN_DATE + DT.TIME_STAMP AS CUT_DATE,
      PROF.USAGE_VAL,
      CASE WHEN DT.PERIOD_ID = p_SERVICE_CONSUMPTION.PERIOD_ID THEN 1 ELSE 0 END
   BULK COLLECT INTO v_USAGE_DATES, v_USAGE_VALS, v_WITHIN_PERIOD_TBL
   FROM (SELECT X.USAGE_DATE AS USAGE_DATE,
            X.USAGE_VAL AS USAGE_VAL,
                PROF_LOCAL_DATE,
                DIM.TGT_INTERVAL
         FROM (SELECT USAGE_DATE, USAGE_VAL, TRUNC(USAGE_DATE-1/86400) AS PROF_LOCAL_DATE
                  FROM TABLE(CAST(p_PROFILE AS USAGE_TABLE))) X,
                 DST_TYPE DT,
                 DST_INTERVAL_MAP DIM
            WHERE PROF_LOCAL_DATE BETWEEN DT.BEGIN_DATE AND DT.END_DATE
                AND DIM.SRC_DST_TYPE = CONSTANTS.DST_TYPE_NONE
                AND DIM.TGT_DST_TYPE = CASE WHEN v_IS_DST_ZONE = 0 THEN DT.DST_TYPE ELSE CONSTANTS.DST_TYPE_NONE END
                AND DIM.INTERVAL = v_PROFILE_INTV_NAME
                AND DIM.SRC_INTERVAL = (X.USAGE_DATE - PROF_LOCAL_DATE)) PROF,
      TEMPLATE_DATES TD,
      TEMPLATE_DAY_TYPE_PERIOD DT
   WHERE TD.TEMPLATE_ID = p_SERVICE_CONSUMPTION.TEMPLATE_ID
      AND TD.TIME_ZONE = GA.LOCAL_TIME_ZONE
      AND TD.HOLIDAY_SET_ID = CONSTANTS.NOT_ASSIGNED
      AND TD.LOCAL_DATE = PROF.PROF_LOCAL_DATE
      AND DT.DAY_TYPE_ID = TD.DAY_TYPE_ID
      AND PROF.TGT_INTERVAL = DT.TIME_STAMP
    ORDER BY CUT_DATE;

   v_PROFILED_USAGE := 0;
   FOR v_IDX IN 1..v_USAGE_VALS.COUNT LOOP
      IF v_USAGE_DATES(v_IDX) BETWEEN v_BEGIN_DATE AND v_END_DATE AND v_WITHIN_PERIOD_TBL(v_IDX) = 1 THEN
         v_PROFILED_USAGE := v_PROFILED_USAGE + v_USAGE_VALS(v_IDX);
      END IF;
   END LOOP;

   IF v_PROFILED_USAGE <> 0 THEN
      v_FACTOR := p_SERVICE_CONSUMPTION.BILLED_USAGE / v_PROFILED_USAGE;
   ELSE
      v_FACTOR := 0;
   END IF;

   IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
      LOGS.LOG_DEBUG('BILLED_USAGE=' || TO_CHAR(p_SERVICE_CONSUMPTION.BILLED_USAGE) || ', PROFILED_USAGE=' || TO_CHAR(v_PROFILED_USAGE) || ', FACTOR=' || TO_CHAR(v_FACTOR) || ', BEGIN_DATE=' || TO_CHAR(p_SERVICE_CONSUMPTION.BEGIN_DATE) || ', END_DATE=' || TO_CHAR(p_SERVICE_CONSUMPTION.END_DATE));
   END IF;

-- Allocate the consumption over the settlement period using the profiled usage.
   UT.CUT_DAY_INTERVAL_RANGE(p_CAST_CONTEXT.MODEL_ID, p_CAST_CONTEXT.BEGIN_DATE, p_CAST_CONTEXT.END_DATE, GA.LOCAL_TIME_ZONE, v_MINUTES, v_BASE_DATE, v_END_DATE);
   UT.CUT_DATE_RANGE(p_CAST_CONTEXT.MODEL_ID, GREATEST(p_CAST_CONTEXT.BEGIN_DATE, p_SERVICE_CONSUMPTION.BEGIN_DATE), LEAST(p_CAST_CONTEXT.END_DATE, p_SERVICE_CONSUMPTION.END_DATE), GA.LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

      IF LOGS.IS_DEBUG_ENABLED THEN
        LOGS.LOG_DEBUG_MORE_DETAIL('BILLED USAGE ALLOCATION - CUT DATE RANGE' ||TEXT_UTIL.TO_CHAR_DATE_RANGE(v_BEGIN_DATE, v_END_DATE));
    END IF;
   FOR v_IDX IN 1..v_USAGE_VALS.COUNT LOOP
      IF v_USAGE_DATES(v_IDX) BETWEEN v_BEGIN_DATE AND v_END_DATE AND v_WITHIN_PERIOD_TBL(v_IDX) = 1 THEN
         v_INTERVAL := ROUND((v_USAGE_DATES(v_IDX) - v_BASE_DATE) / v_PROFILE_INTERVAL_DIVISOR) + 1;

            IF LOGS.IS_DEBUG_ENABLED THEN
                LOGS.LOG_DEBUG_MORE_DETAIL('DATE: ' || TEXT_UTIL.TO_CHAR_TIME(v_USAGE_DATES(v_IDX)) || ' --- INTVL: ' || v_INTERVAL);
            END IF;

         v_USAGE_VAL := v_USAGE_VALS(v_IDX) * v_FACTOR;
         IF p_USAGE_ALLOCATION_XREF.EXISTS(v_INTERVAL) THEN
            p_USAGE_ALLOCATION(p_USAGE_ALLOCATION_XREF(v_INTERVAL)).USAGE_VAL :=  p_USAGE_ALLOCATION(p_USAGE_ALLOCATION_XREF(v_INTERVAL)).USAGE_VAL + v_USAGE_VAL;
         ELSE
            p_USAGE_ALLOCATION.EXTEND;
            p_USAGE_ALLOCATION(p_USAGE_ALLOCATION.LAST) := USAGE_ALLOCATION_TYPE(p_SERVICE_CONSUMPTION.ACCOUNT_SERVICE_ID, p_SERVICE_CONSUMPTION.PROVIDER_SERVICE_ID, v_USAGE_DATES(v_IDX), v_USAGE_VAL);
            p_USAGE_ALLOCATION_XREF(v_INTERVAL) := p_USAGE_ALLOCATION.LAST;
         END IF;
      END IF;
   END LOOP;

   IF LOGS.IS_DEBUG_ENABLED THEN
      LOGS.LOG_DEBUG('BILLED_USAGE_ALLOCATION TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED) || ', COUNT=' || TO_CHAR(p_USAGE_ALLOCATION.COUNT));
   END IF;

END BILLED_USAGE_ALLOCATION_V55;
----------------------------------------------------------------------------------------------------
PROCEDURE CONSUMPTION_ALLOCATION_REQ_V55
   (
   p_CAST_CONTEXT IN OUT NOCOPY CAST_CONTEXT_TYPE
   ) AS

v_EARLIEST_BEGIN_DATE DATE;
v_LATEST_END_DATE DATE;
v_ACCOUNT_SERVICE_ID NUMBER(9) := -999;
v_PROVIDER_SERVICE_ID NUMBER(9) := -999;
v_SERVICE_DELIVERY_ID NUMBER(9) := -999;
v_PROFILE_ID NUMBER(9) := -999;
v_PROFILE_INTERVAL NUMBER(6);
v_PROFILE USAGE_TABLE := USAGE_TABLE();
v_USAGE_ALLOCATION USAGE_ALLOCATION_TABLE := USAGE_ALLOCATION_TABLE();
v_USAGE_ALLOCATION_XREF GA.ID_TABLE;
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;
V_PROGRESS_COUNT NUMBER(9);

CURSOR c_CONSUMPTION IS
      SELECT DISTINCT D.PROFILE_ID, F.ACCOUNT_SERVICE_ID, F.PROVIDER_SERVICE_ID, F.SERVICE_DELIVERY_ID, H.BEGIN_DATE, H.END_DATE, H.CONSUMPTION_ID
      FROM ACCOUNT A, ACCOUNT_STATUS B, ACCOUNT_STATUS_NAME STATUS_NAME, ACCOUNT_CALENDAR C, CALENDAR_PROFILE D, ACCOUNT_SERVICE E, SERVICE F, PROVIDER_SERVICE G, SERVICE_CONSUMPTION H
      WHERE (p_CAST_CONTEXT.ACCOUNT_ID = g_ALL OR A.ACCOUNT_ID = p_CAST_CONTEXT.ACCOUNT_ID)
         AND UPPER(SUBSTR(A.ACCOUNT_MODEL_OPTION,1,1)) = 'A'
            AND A.IS_SUB_AGGREGATE = 0
         AND A.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
         AND UPPER(SUBSTR(A.ACCOUNT_METER_TYPE,1,1)) = 'P'
         AND B.ACCOUNT_ID = A.ACCOUNT_ID
         AND B.BEGIN_DATE <= p_CAST_CONTEXT.END_DATE
         AND NVL(B.END_DATE,p_CAST_CONTEXT.END_DATE) >= p_CAST_CONTEXT.BEGIN_DATE
         AND STATUS_NAME.STATUS_NAME = B.STATUS_NAME
         AND STATUS_NAME.IS_ACTIVE = 1
         AND C.CASE_ID = p_CAST_CONTEXT.CALENDAR_CASE_ID
         AND C.ACCOUNT_ID = A.ACCOUNT_ID
         AND C.CALENDAR_TYPE = 'Settlement'
         AND C.BEGIN_DATE <= p_CAST_CONTEXT.END_DATE
         AND NVL(C.END_DATE,p_CAST_CONTEXT.END_DATE) >= p_CAST_CONTEXT.BEGIN_DATE
         AND D.CALENDAR_ID = C.CALENDAR_ID
         AND D.BEGIN_DATE <= p_CAST_CONTEXT.END_DATE
         AND NVL(D.END_DATE,p_CAST_CONTEXT.END_DATE) >= p_CAST_CONTEXT.BEGIN_DATE
         AND E.ACCOUNT_ID = A.ACCOUNT_ID
         AND F.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
         AND F.SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
         AND F.AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE
         AND F.PROVIDER_SERVICE_ID = G.PROVIDER_SERVICE_ID
         AND F.ACCOUNT_SERVICE_ID = E.ACCOUNT_SERVICE_ID
         AND (p_CAST_CONTEXT.EDC_ID = g_ALL OR G.EDC_ID = p_CAST_CONTEXT.EDC_ID)
         AND (p_CAST_CONTEXT.ESP_ID = g_ALL OR G.ESP_ID = p_CAST_CONTEXT.ESP_ID)
         AND H.SERVICE_ID = F.SERVICE_ID
         AND H.BEGIN_DATE <= TRUNC(p_CAST_CONTEXT.END_DATE)
          AND H.END_DATE >= TRUNC(p_CAST_CONTEXT.BEGIN_DATE)
         AND H.BILL_CODE = GA.BILL_CONSUMPTION
         AND H.CONSUMPTION_CODE = GA.ACTUAL_CONSUMPTION
         AND UPPER(H.UNIT_OF_MEASUREMENT) = UPPER(GA.DEFAULT_UNIT_OF_MEASUREMENT)
      UNION ALL SELECT DISTINCT G.PROFILE_ID, I.ACCOUNT_SERVICE_ID, I.PROVIDER_SERVICE_ID, I.SERVICE_DELIVERY_ID, K.BEGIN_DATE, K.END_DATE, K.CONSUMPTION_ID
      FROM ACCOUNT A, ACCOUNT_STATUS B, ACCOUNT_STATUS_NAME STATUS_NAME, ACCOUNT_SERVICE_LOCATION C, SERVICE_LOCATION_METER D, METER E, ACCOUNT_STATUS_NAME MSN, METER_CALENDAR F, CALENDAR_PROFILE G, ACCOUNT_SERVICE H, SERVICE I, PROVIDER_SERVICE J, SERVICE_CONSUMPTION K
      WHERE (p_CAST_CONTEXT.ACCOUNT_ID = g_ALL OR A.ACCOUNT_ID = p_CAST_CONTEXT.ACCOUNT_ID)
         AND UPPER(SUBSTR(A.ACCOUNT_MODEL_OPTION,1,1)) = 'M'
            AND A.IS_SUB_AGGREGATE = 0
         AND B.ACCOUNT_ID = A.ACCOUNT_ID
         AND B.BEGIN_DATE <= p_CAST_CONTEXT.END_DATE
         AND NVL(B.END_DATE,p_CAST_CONTEXT.END_DATE) >= p_CAST_CONTEXT.BEGIN_DATE
         AND STATUS_NAME.STATUS_NAME = B.STATUS_NAME
         AND STATUS_NAME.IS_ACTIVE = 1
         AND C.ACCOUNT_ID = A.ACCOUNT_ID
         AND C.BEGIN_DATE <= p_CAST_CONTEXT.END_DATE
         AND NVL(C.END_DATE,p_CAST_CONTEXT.END_DATE) >= p_CAST_CONTEXT.BEGIN_DATE
         AND D.SERVICE_LOCATION_ID = C.SERVICE_LOCATION_ID
         AND D.BEGIN_DATE <= p_CAST_CONTEXT.END_DATE
         AND NVL(D.END_DATE,p_CAST_CONTEXT.END_DATE) >= p_CAST_CONTEXT.BEGIN_DATE
         AND E.METER_ID = D.METER_ID
         AND MSN.STATUS_NAME = E.METER_STATUS
         AND MSN.IS_ACTIVE = 1
         AND A.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
         AND UPPER(SUBSTR(E.METER_TYPE,1,1)) = 'P'
         AND F.CASE_ID = p_CAST_CONTEXT.CALENDAR_CASE_ID
         AND F.METER_ID = E.METER_ID
         AND F.CALENDAR_TYPE = 'Settlement'
         AND G.CALENDAR_ID = F.CALENDAR_ID
         AND G.BEGIN_DATE <= p_CAST_CONTEXT.END_DATE
         AND NVL(G.END_DATE,p_CAST_CONTEXT.END_DATE) >= p_CAST_CONTEXT.BEGIN_DATE
         AND H.METER_ID = F.METER_ID
         AND I.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
         AND I.SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
         AND I.AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE
         AND I.PROVIDER_SERVICE_ID = J.PROVIDER_SERVICE_ID
         AND I.ACCOUNT_SERVICE_ID = H.ACCOUNT_SERVICE_ID
         AND (p_CAST_CONTEXT.EDC_ID = g_ALL OR J.EDC_ID = p_CAST_CONTEXT.EDC_ID)
         AND (p_CAST_CONTEXT.ESP_ID = g_ALL OR J.ESP_ID = p_CAST_CONTEXT.ESP_ID)
         AND K.SERVICE_ID = I.SERVICE_ID
         AND K.BEGIN_DATE <= TRUNC(p_CAST_CONTEXT.END_DATE)
          AND K.END_DATE >= TRUNC(p_CAST_CONTEXT.BEGIN_DATE)
         AND K.BILL_CODE = GA.BILL_CONSUMPTION
         AND K.CONSUMPTION_CODE = GA.ACTUAL_CONSUMPTION
         AND UPPER(K.UNIT_OF_MEASUREMENT) = UPPER(GA.DEFAULT_UNIT_OF_MEASUREMENT)
   ORDER BY 1,2,3,4;

CURSOR c_CONSUMPTION_SEGMENT IS
   SELECT SERVICE_CONSUMPTION_TYPE(A.ACCOUNT_SERVICE_ID, A.PROVIDER_SERVICE_ID, A.SERVICE_DELIVERY_ID, B.BEGIN_DATE, B.END_DATE, B.TEMPLATE_ID, B.PERIOD_ID, B.BILLED_USAGE) AS CS_TYPE
   FROM SERVICE A, SERVICE_CONSUMPTION B
   WHERE A.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
      AND A.SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
      AND A.AS_OF_DATE = g_LOW_DATE
      AND A.PROVIDER_SERVICE_ID = v_PROVIDER_SERVICE_ID
      AND A.ACCOUNT_SERVICE_ID = v_ACCOUNT_SERVICE_ID
      AND A.SERVICE_DELIVERY_ID = v_SERVICE_DELIVERY_ID
      AND B.SERVICE_ID = A.SERVICE_ID
      AND B.BEGIN_DATE <= TRUNC(p_CAST_CONTEXT.END_DATE)
       AND B.END_DATE >= TRUNC(p_CAST_CONTEXT.BEGIN_DATE)
      AND B.BILL_CODE = GA.BILL_CONSUMPTION
      AND B.CONSUMPTION_CODE = GA.ACTUAL_CONSUMPTION
      AND UPPER(B.UNIT_OF_MEASUREMENT) = UPPER(GA.DEFAULT_UNIT_OF_MEASUREMENT);

   PROCEDURE ALLOCATE_PREVIOUS_RESULTS IS
      BEGIN
         IF v_ACCOUNT_SERVICE_ID > 0 AND v_PROFILE_ID > 0 THEN

            --Cache the settlement profile over the date range.
            FP.GET_SETTLEMENT_PROFILE(p_CAST_CONTEXT, v_PROFILE_ID, v_EARLIEST_BEGIN_DATE, v_LATEST_END_DATE, v_PROFILE);

            -- Loop over each of the consumption segments and allocate the billed usage to the account and provider using the profile.
            FOR v_CONSUMPTION_SEGMENT IN c_CONSUMPTION_SEGMENT LOOP
                 BILLED_USAGE_ALLOCATION_v55(p_CAST_CONTEXT, v_CONSUMPTION_SEGMENT.CS_TYPE, v_PROFILE, v_PROFILE_INTERVAL, v_USAGE_ALLOCATION, v_USAGE_ALLOCATION_XREF);
            END LOOP;

            ASSIGN_SERVICE_USAGE(p_CAST_CONTEXT, v_ACCOUNT_SERVICE_ID, v_PROVIDER_SERVICE_ID, v_SERVICE_DELIVERY_ID, v_PROFILE_INTERVAL, v_USAGE_ALLOCATION);
            DELETE_ACTUAL_SERVICE(p_CAST_CONTEXT, v_ACCOUNT_SERVICE_ID, v_PROVIDER_SERVICE_ID, v_SERVICE_DELIVERY_ID);
            STORE_SERVICE_STATE(p_CAST_CONTEXT);
            STORE_SERVICE_LOAD(p_CAST_CONTEXT);

            -- Commit incremental work in multi-day runs to reduce roll-back overhead.
            IF p_CAST_CONTEXT.INCREMENTAL_COMMIT = 1 THEN COMMIT; END IF;
             IF LOGS.IS_DEBUG_ENABLED THEN
               LOGS.LOG_DEBUG('TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED) || ', PROVIDER_SERVICE_ID=' || TO_CHAR(v_PROVIDER_SERVICE_ID) || ', ACCOUNT_SERVICE_ID=' || TO_CHAR(v_ACCOUNT_SERVICE_ID) || ', SERVICE_DELIVERY_ID=' || TO_CHAR(v_SERVICE_DELIVERY_ID)|| ', PROFILE_ID=' || TO_CHAR(v_PROFILE_ID) || ', USAGE_ALLOCATION.COUNT=' || TO_CHAR(v_USAGE_ALLOCATION.COUNT));
               v_ELAPSED := DBMS_UTILITY.GET_TIME;
            END IF;
         END IF;
   END ALLOCATE_PREVIOUS_RESULTS;

BEGIN

-- Option to only Rollup the cast detail to summary level.
   IF p_CAST_CONTEXT.ACCOUNT_PROCESS_MODE = g_SUMMARY_ONLY THEN
      SET_SERVICE_OBLIGATION(p_CAST_CONTEXT);
      RETURN;
   END IF;

   INITIALIZE_SERVICE;
   CX.INITIALIZE_CACHE(p_CAST_CONTEXT);

   SELECT COUNT(A.PROFILE_ID)
   INTO V_PROGRESS_COUNT
   FROM (SELECT DISTINCT D.PROFILE_ID, F.ACCOUNT_SERVICE_ID, F.PROVIDER_SERVICE_ID, F.SERVICE_DELIVERY_ID, H.BEGIN_DATE, H.END_DATE, H.CONSUMPTION_ID
      FROM ACCOUNT A, ACCOUNT_STATUS B, ACCOUNT_STATUS_NAME STATUS_NAME, ACCOUNT_CALENDAR C, CALENDAR_PROFILE D, ACCOUNT_SERVICE E, SERVICE F, PROVIDER_SERVICE G, SERVICE_CONSUMPTION H
      WHERE (p_CAST_CONTEXT.ACCOUNT_ID = g_ALL OR A.ACCOUNT_ID = p_CAST_CONTEXT.ACCOUNT_ID)
         AND UPPER(SUBSTR(A.ACCOUNT_MODEL_OPTION,1,1)) = 'A'
         AND A.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
         AND A.IS_SUB_AGGREGATE = 0
         AND UPPER(SUBSTR(A.ACCOUNT_METER_TYPE,1,1)) = 'P'
         AND B.ACCOUNT_ID = A.ACCOUNT_ID
         AND B.BEGIN_DATE <= p_CAST_CONTEXT.END_DATE
         AND NVL(B.END_DATE,p_CAST_CONTEXT.END_DATE) >= p_CAST_CONTEXT.BEGIN_DATE
         AND STATUS_NAME.STATUS_NAME = B.STATUS_NAME
         AND STATUS_NAME.IS_ACTIVE = 1
         AND C.CASE_ID = p_CAST_CONTEXT.CALENDAR_CASE_ID
         AND C.ACCOUNT_ID = A.ACCOUNT_ID
         AND C.CALENDAR_TYPE = 'Settlement'
         AND C.BEGIN_DATE <= p_CAST_CONTEXT.END_DATE
         AND NVL(C.END_DATE,p_CAST_CONTEXT.END_DATE) >= p_CAST_CONTEXT.BEGIN_DATE
         AND D.CALENDAR_ID = C.CALENDAR_ID
         AND D.BEGIN_DATE <= p_CAST_CONTEXT.END_DATE
         AND NVL(D.END_DATE,p_CAST_CONTEXT.END_DATE) >= p_CAST_CONTEXT.BEGIN_DATE
         AND E.ACCOUNT_ID = A.ACCOUNT_ID
         AND F.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
         AND F.SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
         AND F.AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE
         AND F.PROVIDER_SERVICE_ID = G.PROVIDER_SERVICE_ID
         AND F.ACCOUNT_SERVICE_ID = E.ACCOUNT_SERVICE_ID
         AND (p_CAST_CONTEXT.EDC_ID = g_ALL OR G.EDC_ID = p_CAST_CONTEXT.EDC_ID)
         AND (p_CAST_CONTEXT.ESP_ID = g_ALL OR G.ESP_ID = p_CAST_CONTEXT.ESP_ID)
         AND H.SERVICE_ID = F.SERVICE_ID
         AND H.BEGIN_DATE <= TRUNC(p_CAST_CONTEXT.END_DATE)
         AND H.END_DATE >= TRUNC(p_CAST_CONTEXT.BEGIN_DATE)
         AND H.BILL_CODE = GA.BILL_CONSUMPTION
         AND H.CONSUMPTION_CODE = GA.ACTUAL_CONSUMPTION
         AND UPPER(H.UNIT_OF_MEASUREMENT) = UPPER(GA.DEFAULT_UNIT_OF_MEASUREMENT)
      UNION ALL SELECT DISTINCT G.PROFILE_ID, I.ACCOUNT_SERVICE_ID, I.PROVIDER_SERVICE_ID, I.SERVICE_DELIVERY_ID, K.BEGIN_DATE, K.END_DATE, K.CONSUMPTION_ID
      FROM ACCOUNT A, ACCOUNT_STATUS B, ACCOUNT_STATUS_NAME STATUS_NAME, ACCOUNT_SERVICE_LOCATION C, SERVICE_LOCATION_METER D, METER E, ACCOUNT_STATUS_NAME MSN, METER_CALENDAR F, CALENDAR_PROFILE G, ACCOUNT_SERVICE H, SERVICE I, PROVIDER_SERVICE J, SERVICE_CONSUMPTION K
      WHERE (p_CAST_CONTEXT.ACCOUNT_ID = g_ALL OR A.ACCOUNT_ID = p_CAST_CONTEXT.ACCOUNT_ID)
         AND UPPER(SUBSTR(A.ACCOUNT_MODEL_OPTION,1,1)) = 'M'
         AND A.IS_SUB_AGGREGATE = 0
         AND B.ACCOUNT_ID = A.ACCOUNT_ID
         AND B.BEGIN_DATE <= p_CAST_CONTEXT.END_DATE
         AND NVL(B.END_DATE,p_CAST_CONTEXT.END_DATE) >= p_CAST_CONTEXT.BEGIN_DATE
         AND STATUS_NAME.STATUS_NAME = B.STATUS_NAME
         AND STATUS_NAME.IS_ACTIVE = 1
         AND C.ACCOUNT_ID = A.ACCOUNT_ID
         AND C.BEGIN_DATE <= p_CAST_CONTEXT.END_DATE
         AND NVL(C.END_DATE,p_CAST_CONTEXT.END_DATE) >= p_CAST_CONTEXT.BEGIN_DATE
         AND D.SERVICE_LOCATION_ID = C.SERVICE_LOCATION_ID
         AND D.BEGIN_DATE <= p_CAST_CONTEXT.END_DATE
         AND NVL(D.END_DATE,p_CAST_CONTEXT.END_DATE) >= p_CAST_CONTEXT.BEGIN_DATE
         AND E.METER_ID = D.METER_ID
         AND MSN.STATUS_NAME = E.METER_STATUS
         AND MSN.IS_ACTIVE = 1
         AND A.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
         AND UPPER(SUBSTR(E.METER_TYPE,1,1)) = 'P'
         AND F.CASE_ID = p_CAST_CONTEXT.CALENDAR_CASE_ID
         AND F.METER_ID = E.METER_ID
         AND F.CALENDAR_TYPE = 'Settlement'
         AND G.CALENDAR_ID = F.CALENDAR_ID
         AND G.BEGIN_DATE <= p_CAST_CONTEXT.END_DATE
         AND NVL(G.END_DATE,p_CAST_CONTEXT.END_DATE) >= p_CAST_CONTEXT.BEGIN_DATE
         AND H.METER_ID = F.METER_ID
         AND I.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
         AND I.SCENARIO_ID = p_CAST_CONTEXT.SCENARIO_ID
         AND I.AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE
         AND I.PROVIDER_SERVICE_ID = J.PROVIDER_SERVICE_ID
         AND I.ACCOUNT_SERVICE_ID = H.ACCOUNT_SERVICE_ID
         AND (p_CAST_CONTEXT.EDC_ID = g_ALL OR J.EDC_ID = p_CAST_CONTEXT.EDC_ID)
         AND (p_CAST_CONTEXT.ESP_ID = g_ALL OR J.ESP_ID = p_CAST_CONTEXT.ESP_ID)
         AND K.SERVICE_ID = I.SERVICE_ID
         AND K.BEGIN_DATE <= TRUNC(p_CAST_CONTEXT.END_DATE)
         AND K.END_DATE >= TRUNC(p_CAST_CONTEXT.BEGIN_DATE)
         AND K.BILL_CODE = GA.BILL_CONSUMPTION
         AND K.CONSUMPTION_CODE = GA.ACTUAL_CONSUMPTION
         AND UPPER(K.UNIT_OF_MEASUREMENT) = UPPER(GA.DEFAULT_UNIT_OF_MEASUREMENT)) A;

    LOGS.INIT_PROCESS_PROGRESS(p_TOTAL_WORK => V_PROGRESS_COUNT + 1, p_CAN_TERMINATE => TRUE);
    DELETE_SERVICE_NON_INTERVAL(p_CAST_CONTEXT);
   FOR v_CONSUMPTION IN c_CONSUMPTION LOOP
   --If these are the same record, then do the allocation.
         IF v_ACCOUNT_SERVICE_ID = v_CONSUMPTION.ACCOUNT_SERVICE_ID
               AND v_PROVIDER_SERVICE_ID = v_CONSUMPTION.PROVIDER_SERVICE_ID
               AND v_SERVICE_DELIVERY_ID = v_CONSUMPTION.SERVICE_DELIVERY_ID
               AND v_PROFILE_ID = v_CONSUMPTION.PROFILE_ID THEN
            v_EARLIEST_BEGIN_DATE := LEAST(v_EARLIEST_BEGIN_DATE, v_CONSUMPTION.BEGIN_DATE);
            v_LATEST_END_DATE := GREATEST(v_LATEST_END_DATE, v_CONSUMPTION.END_DATE);
         ELSE
            ALLOCATE_PREVIOUS_RESULTS;
            v_USAGE_ALLOCATION.DELETE;
            v_USAGE_ALLOCATION_XREF.DELETE;
            v_ACCOUNT_SERVICE_ID := v_CONSUMPTION.ACCOUNT_SERVICE_ID;
            v_PROVIDER_SERVICE_ID := v_CONSUMPTION.PROVIDER_SERVICE_ID;
            v_SERVICE_DELIVERY_ID := v_CONSUMPTION.SERVICE_DELIVERY_ID;
            v_EARLIEST_BEGIN_DATE := v_CONSUMPTION.BEGIN_DATE;
            v_LATEST_END_DATE := v_CONSUMPTION.END_DATE;
            IF NOT v_PROFILE_ID = v_CONSUMPTION.PROFILE_ID THEN
               v_PROFILE_ID := v_CONSUMPTION.PROFILE_ID;
               v_PROFILE_INTERVAL := FP.GET_PROFILE_INTERVAL(v_PROFILE_ID);
            END IF;
         END IF;
      LOGS.INCREMENT_PROCESS_PROGRESS();
   END LOOP; --FOR v_CONSUMPTION IN c_CONSUMPTION LOOP
   ALLOCATE_PREVIOUS_RESULTS;
   LOGS.INCREMENT_PROCESS_PROGRESS();

   IF p_CAST_CONTEXT.ACCOUNT_ID < 0 THEN
      SET_SERVICE_OBLIGATION(p_CAST_CONTEXT);
      p_CAST_CONTEXT.SERVICE_DATE := p_CAST_CONTEXT.BEGIN_DATE;
      WHILE p_CAST_CONTEXT.SERVICE_DATE <= p_CAST_CONTEXT.END_DATE LOOP
           CS.PUT_PROCESS_STATUS(p_CAST_CONTEXT.PROCESS_NAME, p_CAST_CONTEXT.SERVICE_DATE, p_CAST_CONTEXT.OUTPUT_AS_OF_DATE, 'Pending', SYSDATE);
           p_CAST_CONTEXT.SERVICE_DATE := p_CAST_CONTEXT.SERVICE_DATE + 1;
      END LOOP;
   END IF;
   CX.RELEASE_CACHE;
   LOGS.LOG_DEBUG('CONSUMPTION_ALLOCATION_REQUEST TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED));
EXCEPTION
   WHEN OTHERS THEN
      BEGIN
         CX.RELEASE_CACHE;
      EXCEPTION
         WHEN OTHERS THEN
            ERRS.LOG_AND_CONTINUE();
      END;
      ERRS.LOG_AND_RAISE();
END CONSUMPTION_ALLOCATION_REQ_V55;
--@@End Implementation Override --

PROCEDURE ALLOCATION_LOGIC_END AS
-- End Allocation Caching Logic
BEGIN
	NULL;
END ALLOCATION_LOGIC_END;
----------------------------------------------------------------------------------------------------
PROCEDURE CAST_SERVICE_REQUEST
	(
	p_REQUEST_TYPE IN CHAR,
	p_REQUEST_MODE IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_MODEL_ID IN NUMBER,
	p_PROCESS_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_PROFILE_BEGIN_DATE IN DATE,
	p_PROFILE_AS_OF_DATE IN DATE,
	p_APPLY_USAGE_FACTOR IN NUMBER,
	p_APPLY_UFE IN NUMBER,
	p_APPLY_UFE_OTHER IN NUMBER,
	p_APPLY_EXTERNAL_FORECAST IN NUMBER,
	p_REQUESTOR IN VARCHAR,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

-- Generate the forecast or backcast for the specified scenario and time period.
-- When account_id = -1 cast all accounts, else cast the specified account.
-- When account id < 0 and not -1, it flags the last account for multiple account requests.

v_CAST_CONTEXT CAST_CONTEXT_TYPE := NEW_CAST_CONTEXT;
v_PROCESS_NAME VARCHAR2(64);
v_MESSAGE	VARCHAR2(4000);
v_STATUS	NUMBER;

BEGIN
	SAVEPOINT BEGIN_CAST_SERVICE_REQUEST;

	v_PROCESS_NAME := GET_PROCESS_NAME(p_REQUEST_TYPE, p_REQUEST_MODE);
	LOGS.START_PROCESS(v_PROCESS_NAME,p_BEGIN_DATE, p_END_DATE, p_TRACE_ON => p_TRACE_ON);
   ASSERT(v_PROCESS_NAME <> 'Forecast', 'Forecast Request Type Is Disabled.'); --@@Implementation Override--

	LOGS.SET_PROCESS_TARGET_PARAMETER('REQUEST_TYPE',p_REQUEST_TYPE);
	LOGS.SET_PROCESS_TARGET_PARAMETER('REQUEST_MODE', TO_CHAR(p_REQUEST_MODE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('SCENARIO_ID', TO_CHAR(p_SCENARIO_ID));
	LOGS.SET_PROCESS_TARGET_PARAMETER('MODEL_ID', TO_CHAR(p_MODEL_ID));
	LOGS.SET_PROCESS_TARGET_PARAMETER('PROCESS_ID', TO_CHAR(p_PROCESS_ID));
	LOGS.SET_PROCESS_TARGET_PARAMETER('EDC_ID', TO_CHAR(p_EDC_ID));
	LOGS.SET_PROCESS_TARGET_PARAMETER('ESP_ID', TO_CHAR(p_ESP_ID));
	LOGS.SET_PROCESS_TARGET_PARAMETER('ACCOUNT_ID', TO_CHAR(p_ACCOUNT_ID));
	LOGS.SET_PROCESS_TARGET_PARAMETER('INPUT_AS_OF_DATE', TEXT_UTIL.TO_CHAR_DATE(p_INPUT_AS_OF_DATE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('OUTPUT_AS_OF_DATE', TEXT_UTIL.TO_CHAR_DATE(p_OUTPUT_AS_OF_DATE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('PROFILE_BEGIN_DATE', TEXT_UTIL.TO_CHAR_DATE(p_PROFILE_BEGIN_DATE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('PROFILE_AS_OF_DATE', TEXT_UTIL.TO_CHAR_DATE(p_PROFILE_AS_OF_DATE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('APPLY_USAGE_FACTOR', TO_CHAR(p_APPLY_USAGE_FACTOR));
	LOGS.SET_PROCESS_TARGET_PARAMETER('APPLY_UFE', TO_CHAR(p_APPLY_UFE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('APPLY_UFE_OTHER', TO_CHAR(p_APPLY_UFE_OTHER));
	LOGS.SET_PROCESS_TARGET_PARAMETER('APPLY_EXTERNAL_FORECAST', TO_CHAR(p_APPLY_EXTERNAL_FORECAST));
	LOGS.SET_PROCESS_TARGET_PARAMETER('REQUESTOR', p_REQUESTOR);
	LOGS.SET_PROCESS_TARGET_PARAMETER('TRACE_ON', p_TRACE_ON);

	INITIALIZE_CAST_CONTEXT(p_REQUEST_TYPE, p_REQUEST_MODE, p_SCENARIO_ID, p_MODEL_ID, p_EDC_ID, p_ESP_ID, p_ACCOUNT_ID, p_BEGIN_DATE, p_END_DATE, p_INPUT_AS_OF_DATE, p_OUTPUT_AS_OF_DATE, p_PROFILE_BEGIN_DATE,
		p_PROFILE_AS_OF_DATE, p_APPLY_USAGE_FACTOR, p_APPLY_UFE, p_APPLY_UFE_OTHER, p_APPLY_EXTERNAL_FORECAST, p_REQUESTOR, p_TRACE_ON, v_CAST_CONTEXT);

	IF NOT CAN_WRITE(v_CAST_CONTEXT.MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(v_CAST_CONTEXT.MODULE_NAME);
	END IF;

	IF v_CAST_CONTEXT.REQUEST_TYPE = 'A' THEN
		CONSUMPTION_ALLOCATION_REQ_V55(v_CAST_CONTEXT); --@@Implementation Override--
	ELSIF v_CAST_CONTEXT.REQUEST_MODE = GA.STATEMENT_MODE THEN
		FINANCIAL_POSITION_REQUEST(v_CAST_CONTEXT, v_STATUS, v_MESSAGE);
		ERRS.VALIDATE_STATUS('FS.FINANCIAL_POSITION_REQUEST', v_STATUS, v_MESSAGE);
	ELSE
		--If this is a long Term run, first run the LT Profile Generation.
		IF v_CAST_CONTEXT.RUN_MODE IN (GA.WEEK_MODE, GA.MONTH_MODE) THEN
			CREATE_LONG_TERM_PROFILES(p_MODEL_ID, v_CAST_CONTEXT.RUN_MODE, p_BEGIN_DATE, p_END_DATE, LOCAL_TIME_ZONE, v_STATUS, v_CAST_CONTEXT.TRACE_ON = 1);
			IF NVL(v_STATUS,GA.SUCCESS) <> GA.SUCCESS THEN
				LOGS.LOG_ERROR('CREATE_LONG_TERM_PROFILES status indicates error: '||v_STATUS);
			END IF;
		END IF;

		v_CAST_CONTEXT.SERVICE_DATE := v_CAST_CONTEXT.BEGIN_DATE;
		v_CAST_CONTEXT.PROFILE_DATE := v_CAST_CONTEXT.PROFILE_BEGIN_DATE;

		FP.RELEASE_SETTLEMENT_STATS();

		IF v_CAST_CONTEXT.REQUEST_TYPE = 'S' THEN
			CAST_SETTLEMENT_MODEL(v_CAST_CONTEXT);
		ELSIF v_CAST_CONTEXT.REQUEST_MODE IN(GA.STANDARD_MODE, GA.ACCOUNT_GROUP_MODE) THEN
			CAST_SERVICE_MODEL(v_CAST_CONTEXT);
		END IF;

		-- This will always get done regardless of whether the user terminated. Observerd by pbm - 2/25/2008
		FP.SET_SETTLEMENT_PROFILE_STATS(v_CAST_CONTEXT, p_PROFILE_AS_OF_DATE);

		CX.RELEASE_CACHE;

	END IF;

	LOGS.STOP_PROCESS(p_MESSAGE, p_STATUS);
	COMMIT;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.ABORT_PROCESS(p_SAVEPOINT_NAME => 'BEGIN_CAST_SERVICE_REQUEST');

END CAST_SERVICE_REQUEST;
----------------------------------------------------------------------------------------------------
PROCEDURE CAST_SERVICE_REQUEST
	(
	p_REQUEST_TYPE IN CHAR,
	p_REQUEST_MODE IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_MODEL_ID IN NUMBER,
	p_PROCESS_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_PROFILE_BEGIN_DATE IN DATE,
	p_PROFILE_AS_OF_DATE IN DATE,
	p_APPLY_USAGE_FACTOR IN NUMBER,
	p_APPLY_UFE IN NUMBER,
	p_APPLY_UFE_OTHER IN NUMBER,
	p_APPLY_EXTERNAL_FORECAST IN NUMBER,
	p_REQUESTOR IN VARCHAR,
	p_TRACE_ON IN NUMBER
	) AS

v_STATUS NUMBER;
v_MESSAGE VARCHAR(128);

BEGIN

	CAST_SERVICE_REQUEST(p_REQUEST_TYPE, p_REQUEST_MODE, p_SCENARIO_ID, p_MODEL_ID, p_PROCESS_ID, p_EDC_ID, p_ESP_ID, p_ACCOUNT_ID, p_BEGIN_DATE, p_END_DATE, p_INPUT_AS_OF_DATE, p_OUTPUT_AS_OF_DATE,
		p_PROFILE_BEGIN_DATE, p_PROFILE_AS_OF_DATE, p_APPLY_USAGE_FACTOR, p_APPLY_UFE, p_APPLY_UFE_OTHER, p_APPLY_EXTERNAL_FORECAST, p_REQUESTOR, p_TRACE_ON, v_STATUS, v_MESSAGE);

END CAST_SERVICE_REQUEST;
----------------------------------------------------------------------------------------------------
PROCEDURE RUN_CAST_SERVICE_REQUEST
	(
	p_REQUEST_TYPE IN CHAR,
	p_REQUEST_MODE IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_MODEL_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_PROFILE_BEGIN_DATE IN DATE,
	p_PROFILE_AS_OF_DATE IN DATE,
	p_APPLY_USAGE_FACTOR IN NUMBER,
	p_APPLY_UFE IN NUMBER,
	p_APPLY_UFE_OTHER IN NUMBER,
	p_APPLY_EXTERNAL_FORECAST IN NUMBER,
	p_SCHEDULE_RUN IN NUMBER,
	p_RUN_AT IN DATE,
	p_REQUESTOR IN VARCHAR,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

-- Run a Cast Request. -- Forecast, Backcast, Settlement Profile

DUMMY VARCHAR2(64);
v_WHAT VARCHAR(512);
v_PROCESS_ID NUMBER;
v_MODULE_NAME VARCHAR2(16);
v_VB_DEFAULT_DATE	CONSTANT DATE := DATE '2000-02-13';
v_REQUEST_TYPE CHARACTER := UPPER(SUBSTR(p_REQUEST_TYPE,1,1));

BEGIN
    -- The two return arguments were returning NULL values and as a result, the code in VB was failing.
    -- Hence returning dummy values.
    p_STATUS	:=	CONSTANTS.LITERAL_ONE;
    p_MESSAGE	:=	CONSTANTS.LITERAL_ONE;

	SELECT DECODE(v_REQUEST_TYPE,'F','FORECASTING','SETTLEMENT') INTO v_MODULE_NAME FROM DUAL;
	IF NOT CAN_WRITE(v_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(v_MODULE_NAME);
	END IF;

    -- SFDC 105553 - When the 'Generate Settlement Profiles' window in the VB module is closed,
    -- the settlement profile is being calculated for begin and end date of 2000-02-13.
    -- The following logic will ignore these dates for a settlement profile run (or request type 'S').
    IF v_REQUEST_TYPE = 'S' AND (TRUNC(p_BEGIN_DATE) = v_VB_DEFAULT_DATE OR TRUNC(p_END_DATE) = v_VB_DEFAULT_DATE) THEN
        LOGS.LOG_DEBUG('Settlement Profile run ignored for Begin Date - ' || TO_CHAR(p_BEGIN_DATE, 'DD-MON-YYYY') ||
                                                        ' End Date - ' || TO_CHAR(p_END_DATE, 'DD-MON-YYYY'));
        RETURN;
    END IF;

	IF p_SCHEDULE_RUN = 1 THEN
		v_WHAT := 'FS.CAST_SERVICE_REQUEST(''' ||  p_REQUEST_TYPE || ''',' || TO_CHAR(p_REQUEST_MODE) || ','
			|| TO_CHAR(p_SCENARIO_ID) || ',' || TO_CHAR(p_MODEL_ID) || ','
			|| 'NULL' || ',' || TO_CHAR(p_EDC_ID) || ','
			|| TO_CHAR(p_ESP_ID) || ',' || TO_CHAR(p_ACCOUNT_ID) || ','
			|| 'TO_DATE(''' || TO_CHAR(p_BEGIN_DATE, 'DD-MON-YYYY') || ''',''DD-MON-YYYY''),'
			|| 'TO_DATE(''' || TO_CHAR(p_END_DATE, 'DD-MON-YYYY') || ''',''DD-MON-YYYY''),'
			|| 'TO_DATE(''' || TO_CHAR(p_INPUT_AS_OF_DATE, 'DD-MON-YYYY HH24:MI:SS') || ''',''DD-MON-YYYY HH24:MI:SS''),'
			|| 'TO_DATE(''' || TO_CHAR(p_OUTPUT_AS_OF_DATE, 'DD-MON-YYYY HH24:MI:SS') || ''',''DD-MON-YYYY HH24:MI:SS''),'
			|| 'TO_DATE(''' || TO_CHAR(p_PROFILE_BEGIN_DATE, 'DD-MON-YYYY HH24:MI:SS') || ''',''DD-MON-YYYY HH24:MI:SS''),'
			|| 'TO_DATE(''' || TO_CHAR(p_PROFILE_AS_OF_DATE, 'DD-MON-YYYY HH24:MI:SS') || ''',''DD-MON-YYYY HH24:MI:SS''),'
			|| TO_CHAR(p_APPLY_USAGE_FACTOR) || ','
			|| TO_CHAR(p_APPLY_UFE) || ','
			|| TO_CHAR(p_APPLY_UFE_OTHER) || ','
			|| TO_CHAR(p_APPLY_EXTERNAL_FORECAST) || ',''' || p_REQUESTOR || ''',' || TO_CHAR(p_TRACE_ON) || ');' ;
		IF LOGS.IS_DEBUG_ENABLED THEN
    		LOGS.LOG_DEBUG('SCHEDULE CAST_SERVICE_REQUEST TO RUN AT= ' || TEXT_UTIL.TO_CHAR_DATE(p_RUN_AT));
    		LOGS.LOG_DEBUG('WHAT=' || SUBSTR(v_WHAT,1,250));
		END IF;
		DUMMY := START_BACKGROUND_JOB(v_WHAT, p_RUN_AT);
	ELSE
		CAST_SERVICE_REQUEST(p_REQUEST_TYPE, p_REQUEST_MODE, p_SCENARIO_ID, p_MODEL_ID, v_PROCESS_ID, p_EDC_ID, p_ESP_ID, p_ACCOUNT_ID, p_BEGIN_DATE, p_END_DATE, p_INPUT_AS_OF_DATE, p_OUTPUT_AS_OF_DATE, p_PROFILE_BEGIN_DATE,
			                                       p_PROFILE_AS_OF_DATE, p_APPLY_USAGE_FACTOR, p_APPLY_UFE, p_APPLY_UFE_OTHER, p_APPLY_EXTERNAL_FORECAST, p_REQUESTOR, p_TRACE_ON, p_STATUS, p_MESSAGE);
	END IF;
END RUN_CAST_SERVICE_REQUEST;
----------------------------------------------------------------------------------------------------
PROCEDURE CAST_DELETE_REQUEST
	(
	p_REQUEST_TYPE IN VARCHAR,
	p_SCENARIO_ID IN NUMBER,
	p_MODEL_ID IN NUMBER,
	p_ACCOUNT_TYPE IN CHAR,
	p_METER_TYPE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_REQUESTOR IN VARCHAR,
	p_RECALC_TOTALS IN NUMBER := 0,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

v_MODULE_NAME VARCHAR(32);
v_REQUEST_TYPE CHAR(1) := UPPER(SUBSTR(p_REQUEST_TYPE,1,1));
v_ACCOUNT_TYPE CHAR(1);
v_IS_AGGREGATE_ACCOUNT NUMBER(1);
v_METER_TYPE CHAR(1) := UPPER(SUBSTR(p_METER_TYPE,1,1));
v_CUT_BEGIN_DATE DATE;
v_CUT_END_DATE DATE;
v_BLOCK_BEGIN_DATE DATE;
v_BLOCK_END_DATE DATE;
v_AS_OF_DATE DATE := LOW_DATE;
v_DAYS NUMBER(9);
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;
v_PROCESS_NAME VARCHAR2(32);
v_EVENT_TEXT VARCHAR2(512);

BEGIN

	SELECT DECODE(v_REQUEST_TYPE,'F','FORECASTING','SETTLEMENT') INTO v_MODULE_NAME FROM DUAL;
	IF NOT CAN_DELETE(v_MODULE_NAME) THEN
		ERRS.RAISE_NO_DELETE_MODULE(v_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK';

	SELECT DECODE(UPPER(SUBSTR(p_ACCOUNT_TYPE,1,1)),'A',1,0) INTO v_IS_AGGREGATE_ACCOUNT FROM DUAL;
	SELECT DECODE(UPPER(SUBSTR(p_ACCOUNT_TYPE,1,1)),'A','A','N','N',g_WILD_CARD) INTO v_ACCOUNT_TYPE FROM DUAL;

	IF (GA.VERSION_FORECAST AND p_REQUEST_TYPE = 'F') OR (GA.VERSION_BACKCAST AND p_REQUEST_TYPE = 'B') THEN
		v_AS_OF_DATE := CORRECTED_AS_OF_DATE(p_AS_OF_DATE, v_MODULE_NAME);
	ELSE
		v_AS_OF_DATE := LOW_DATE;
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('CAST_DELETE_REQUEST');
		LOGS.LOG_DEBUG('SCENARIO_ID=' || TO_CHAR(p_SCENARIO_ID));
		LOGS.LOG_DEBUG('MODEL_ID=' || TO_CHAR(p_MODEL_ID));
		LOGS.LOG_DEBUG('ACCOUNT_TYPE=' || p_ACCOUNT_TYPE);
		LOGS.LOG_DEBUG('METER_TYPE=' || p_METER_TYPE);
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TO_CHAR(p_END_DATE));
		LOGS.LOG_DEBUG('AS_OF_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_AS_OF_DATE));
		LOGS.LOG_DEBUG('REQUESTOR=' || p_REQUESTOR);
		LOGS.LOG_DEBUG('IS_AGGREGATE_ACCOUNT=' || TO_CHAR(v_IS_AGGREGATE_ACCOUNT));
		LOGS.LOG_DEBUG('ALTERED ACCOUNT_TYPE=' || v_ACCOUNT_TYPE);
	END IF;

	v_DAYS := TO_NUMBER(MODEL_VALUE_AT_KEY(p_MODEL_ID,	'Forecasting',	'Delete', 'Days Per Transaction'));
	v_DAYS := NVL(v_DAYS, TRUNC(p_END_DATE) - TRUNC(p_BEGIN_DATE) + 2);
	v_BLOCK_BEGIN_DATE := TRUNC(p_BEGIN_DATE);
	v_BLOCK_END_DATE := LEAST(v_BLOCK_BEGIN_DATE + v_DAYS, TRUNC(p_END_DATE));

	WHILE v_BLOCK_BEGIN_DATE <= TRUNC(p_END_DATE) LOOP

		UT.CUT_DATE_RANGE(p_MODEL_ID, v_BLOCK_BEGIN_DATE, v_BLOCK_END_DATE, LOCAL_TIME_ZONE, v_CUT_BEGIN_DATE, v_CUT_END_DATE);

		DELETE SERVICE_STATE
		WHERE SERVICE_ID IN
			(SELECT DISTINCT SERVICE_ID
			FROM SERVICE
			WHERE MODEL_ID = p_MODEL_ID
				AND SCENARIO_ID = p_SCENARIO_ID
				AND AS_OF_DATE = v_AS_OF_DATE)
			AND SERVICE_CODE = v_REQUEST_TYPE
			AND SERVICE_DATE BETWEEN v_BLOCK_BEGIN_DATE AND v_BLOCK_END_DATE
			AND (v_ACCOUNT_TYPE = g_WILD_CARD OR IS_AGGREGATE_ACCOUNT = v_IS_AGGREGATE_ACCOUNT)
			AND (v_METER_TYPE = g_WILD_CARD OR METER_TYPE = v_METER_TYPE);

		v_PROCESS_NAME := GET_PROCESS_NAME(v_REQUEST_TYPE, GA.STANDARD_MODE);
		DELETE PROCESS_STATUS
		WHERE PROCESS_NAME = v_PROCESS_NAME
			AND PROCESS_DATE BETWEEN v_BLOCK_BEGIN_DATE AND v_BLOCK_END_DATE
			AND PROCESS_AS_OF_DATE = v_AS_OF_DATE;

		IF v_ACCOUNT_TYPE = g_WILD_CARD AND v_METER_TYPE = g_WILD_CARD THEN

			DELETE SERVICE_OBLIGATION_LOAD
			WHERE SERVICE_OBLIGATION_ID IN
				(SELECT DISTINCT SERVICE_OBLIGATION_ID
				FROM SERVICE_OBLIGATION
				WHERE MODEL_ID = p_MODEL_ID
					AND SCENARIO_ID = p_SCENARIO_ID
					AND AS_OF_DATE = v_AS_OF_DATE)
				AND SERVICE_CODE = v_REQUEST_TYPE
				AND LOAD_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE;

			DELETE EDC_SYSTEM_UFE_LOAD
			WHERE MODEL_ID = p_MODEL_ID
				AND SCENARIO_ID = p_SCENARIO_ID
				AND AS_OF_DATE = v_AS_OF_DATE
				AND SERVICE_CODE = v_REQUEST_TYPE
				AND LOAD_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE;
		END IF;

		IF p_REQUEST_TYPE = 'B' THEN
			IF GA.ENABLE_CUSTOMER_MODEL THEN
-- 				UPDATE CUSTOMER_CONSUMPTION_REBILL
-- 				SET SETTLEMENT_DATE = NULL
-- 				WHERE SETTLEMENT_DATE BETWEEN v_BLOCK_BEGIN_DATE AND v_BLOCK_END_DATE;
--
-- 				UPDATE CUSTOMER_CONSUMPTION
-- 				SET SETTLEMENT_DATE = NULL
-- 				WHERE SETTLEMENT_DATE BETWEEN v_BLOCK_BEGIN_DATE AND v_BLOCK_END_DATE;

				v_EVENT_TEXT := 'Backast deleted and Settled Consumption unmarked';
			ELSE
			v_EVENT_TEXT := 'Backcast deleted';
			END IF;
		ELSE
			v_EVENT_TEXT := 'Forecast deleted';
		END IF;

		v_EVENT_TEXT := v_EVENT_TEXT || ' from ' || TEXT_UTIL.TO_CHAR_DATE(v_CUT_BEGIN_DATE) || ' and ' || TEXT_UTIL.TO_CHAR_DATE(v_CUT_END_DATE) || '.';
		LOGS.LOG_NOTICE(v_EVENT_TEXT);

		v_BLOCK_BEGIN_DATE := v_BLOCK_END_DATE + 1;
		v_BLOCK_END_DATE := LEAST(v_BLOCK_BEGIN_DATE + v_DAYS, TRUNC(p_END_DATE));

	END LOOP;

	--RECALC TOTALS
	IF NOT p_RECALC_TOTALS = 0 THEN
	   RUN_CAST_SERVICE_REQUEST(p_REQUEST_TYPE,
	   		0, --REQUEST MODE
			p_SCENARIO_ID,
			p_MODEL_ID,
			g_ALL, --EDC ID
			g_ALL, --ESP ID
			-5, --SUMMARY ONLY
			p_BEGIN_DATE,
			p_END_DATE,
			p_AS_OF_DATE, --INPUT AS OF DATE
			p_AS_OF_DATE, --OUTPUT AS OF DATE
			p_BEGIN_DATE, --PROFILE BEGIN DATE
			p_AS_OF_DATE, --PROFILE AS OF DATE
			1, --APPLY USAGE FACTOR
			1, --APPLY UFE
			1, --APPLY UFE OTHER
			0, --APPLY EXTERNAL FORECAST
			0, --SCHEDULE RUN
			NULL, --RUN AT
			p_REQUESTOR,
			0, --TRACE ON
			p_STATUS,p_MESSAGE);
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('CAST_DELETE_REQUEST ELAPSED TIME='  || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED));
	END IF;


END CAST_DELETE_REQUEST;
----------------------------------------------------------------------------------
PROCEDURE COMPOSITE_PROFILE_FOR_CALENDAR
	(
	p_STATION_ID IN NUMBER,
	p_CALENDAR_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_COMPOSITE_PROFILE IN OUT NOCOPY GA.NUMBER_TABLE,
	p_TRACE_ON BOOLEAN DEFAULT FALSE,
	p_PARAMETER_CODE CHAR DEFAULT 'F'
	) AS

v_CAST_CONTEXT CAST_CONTEXT_TYPE := NEW_CAST_CONTEXT;
v_PROFILE_TYPE CHAR(1);
v_PROFILE_SOURCE_DATE DATE;

BEGIN

	FW.RELEASE_WEATHER;

	v_CAST_CONTEXT.RUN_MODE := GA.HOUR_MODE;
	v_CAST_CONTEXT.REQUEST_TYPE := 'X';
	v_CAST_CONTEXT.WEATHER_PARAMETER_CODE := p_PARAMETER_CODE;
	v_CAST_CONTEXT.WEATHER_CASE_ID := GA.BASE_CASE_ID;
	v_CAST_CONTEXT.SERVICE_DATE := TRUNC(p_SERVICE_DATE);
	v_CAST_CONTEXT.PROFILE_DATE := TRUNC(p_SERVICE_DATE);
	v_CAST_CONTEXT.PROFILE_AS_OF_DATE := CORRECTED_AS_OF_DATE(CURRENT_VERSION_DATE, 'Profiling');
	v_CAST_CONTEXT.DAY_TYPE := g_ANY_DAY;
	v_CAST_CONTEXT.MODEL_ID := GA.DEFAULT_MODEL;
	v_CAST_CONTEXT.SCENARIO_USE_DAY_TYPE := 0;
	v_CAST_CONTEXT.CALENDAR_CASE_ID := GA.BASE_CASE_ID;
	v_CAST_CONTEXT.OUTPUT_AS_OF_DATE := LOW_DATE;
	v_CAST_CONTEXT.SCENARIO_ID := GA.BASE_SCENARIO_ID;

	IF p_TRACE_ON THEN
		v_CAST_CONTEXT.TRACE_ON := 1;
		v_CAST_CONTEXT.DETAIL_TRACE_ON := 1;
	ELSE
		v_CAST_CONTEXT.TRACE_ON := CONSTANTS.NOT_ASSIGNED;
		v_CAST_CONTEXT.DETAIL_TRACE_ON := CONSTANTS.NOT_ASSIGNED;
	END IF;

	FP.COMPOSITE_PROFILE_FOR_CALENDAR(v_CAST_CONTEXT, p_STATION_ID, p_CALENDAR_ID, p_EDC_ID, FALSE, v_PROFILE_TYPE, v_PROFILE_SOURCE_DATE, p_COMPOSITE_PROFILE);

END COMPOSITE_PROFILE_FOR_CALENDAR;
----------------------------------------------------------------------------------------------------
PROCEDURE COMPOSITE_PROFILE_FOR_CALENDAR
	(
	p_CALENDAR_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATION_ID IN NUMBER,
	p_COMPOSITE_PROFILE OUT VARCHAR
	) AS

v_PROFILE GA.NUMBER_TABLE;
v_INDEX BINARY_INTEGER;
v_DELIM CHAR(1) := ',';
v_COMPOSITE_PROFILE VARCHAR(4000) := '';
v_VALUE NUMBER;
v_CALENDAR_ID NUMBER;

BEGIN

	IF NOT CAN_READ('PROFILING') THEN
		ERRS.RAISE_NO_READ_MODULE('PROFILING');
	END IF;

	v_CALENDAR_ID := ABS(p_CALENDAR_ID);

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('COMPOSITE_PROFILE_FOR_CALENDAR');
		LOGS.LOG_DEBUG('CALENDAR_ID=' || TO_CHAR(v_CALENDAR_ID));
		LOGS.LOG_DEBUG('SERVICE_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_SERVICE_DATE));
		LOGS.LOG_DEBUG('STATION_ID=' || TO_CHAR(p_STATION_ID));
		LOGS.LOG_DEBUG('@<hour>=<profile value>');
	END IF;

	COMPOSITE_PROFILE_FOR_CALENDAR(p_STATION_ID, v_CALENDAR_ID, CONSTANTS.NOT_ASSIGNED, p_SERVICE_DATE, v_PROFILE);

	IF v_PROFILE.COUNT > 0 THEN
		FOR v_INDEX IN v_PROFILE.FIRST..v_PROFILE.LAST LOOP
			IF v_PROFILE.EXISTS(v_INDEX) THEN
				v_VALUE := ROUND(v_PROFILE(v_INDEX));
			ELSE
				v_VALUE := 0;
			END IF;
			IF v_INDEX = v_PROFILE.LAST THEN
					v_DELIM := ' ';
			END IF;
			v_COMPOSITE_PROFILE := v_COMPOSITE_PROFILE || TO_CHAR(v_VALUE) || v_DELIM;
		END LOOP;
	END IF;

	p_COMPOSITE_PROFILE := RTRIM(v_COMPOSITE_PROFILE);

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('COMPOSITE_PROFILE=' || v_COMPOSITE_PROFILE);
	END IF;

END COMPOSITE_PROFILE_FOR_CALENDAR;
----------------------------------------------------------------------------------------------------
PROCEDURE MONITOR_REQUEST
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PROFILE_AS_OF_DATE IN DATE,
	p_USAGE_AS_OF_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

-- Generate load profile monitoring information by account.

v_ELAPSED NUMBER;

BEGIN

	IF NOT CAN_WRITE('PROFILING') THEN
		ERRS.RAISE_NO_WRITE_MODULE('PROFILING');
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK';

	IF LOGS.IS_DEBUG_ENABLED THEN
		v_ELAPSED := DBMS_UTILITY.GET_TIME;
		LOGS.LOG_DEBUG('MONITOR_REQUEST BEGIN AT ' || TEXT_UTIL.TO_CHAR_DATE(SYSDATE));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE));
		LOGS.LOG_DEBUG('PROFILE_AS_OF_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_PROFILE_AS_OF_DATE));
		LOGS.LOG_DEBUG('USAGE_AS_OF_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_USAGE_AS_OF_DATE));
	END IF;

	IF GA.ENABLE_EXTERNAL_METER_ACCESS THEN
		XS.CACHE_USAGE(p_BEGIN_DATE, p_END_DATE, p_USAGE_AS_OF_DATE, p_STATUS);
	END IF;

	FP.MONITOR_MODEL(p_BEGIN_DATE, p_END_DATE, p_PROFILE_AS_OF_DATE, p_USAGE_AS_OF_DATE);

	IF GA.ENABLE_EXTERNAL_METER_ACCESS THEN
		XS.RELEASE_USAGE;
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		v_ELAPSED := DBMS_UTILITY.GET_TIME - v_ELAPSED;
		LOGS.LOG_DEBUG('MONITOR_REQUEST END AT ' || TEXT_UTIL.TO_CHAR_DATE(SYSDATE));
		LOGS.LOG_DEBUG('ELAPSED TIME=' || TO_CHAR(v_ELAPSED));
	END IF;


END MONITOR_REQUEST;
----------------------------------------------------------------------------------------------------
PROCEDURE MONITOR_PROFILE_REQUEST
	(
	p_CALENDAR_TYPE IN VARCHAR,
	p_ACCOUNT_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PROFILE_AS_OF_DATE IN DATE,
	p_USAGE_AS_OF_DATE IN DATE,
	p_DAY_SELECTION IN CHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the settlement load profile for this account/meter over the time period.

v_PROFILE_ID NUMBER;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_CALENDAR_TYPE CHAR(1);
v_SERVICE_LOCATION_ID NUMBER;
v_PROFILE_AS_OF_DATE DATE;

BEGIN

	IF NOT CAN_WRITE('PROFILING') THEN -- Required to be able to write, not just read.
		ERRS.RAISE_NO_WRITE_MODULE('PROFILING');
	END IF;

	p_STATUS := GA.SUCCESS;
	SELECT UPPER(SUBSTR(p_CALENDAR_TYPE,1,1)) INTO v_CALENDAR_TYPE FROM DUAL;

	v_PROFILE_ID := FP.GET_PROFILE_ID(p_ACCOUNT_ID, p_METER_ID, TRUNC(p_BEGIN_DATE), v_CALENDAR_TYPE);
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	IF v_CALENDAR_TYPE = 'M' AND v_PROFILE_ID = CONSTANTS.NOT_ASSIGNED THEN
		v_SERVICE_LOCATION_ID := CS.GET_SERVICE_LOCATION_ID(p_ACCOUNT_ID, TRUNC(p_BEGIN_DATE));

		IF GA.ENABLE_EXTERNAL_METER_ACCESS THEN
			XS.CACHE_USAGE(p_ACCOUNT_ID, v_SERVICE_LOCATION_ID, p_METER_ID, 0, v_BEGIN_DATE, v_END_DATE, SYSDATE, p_STATUS);
		END IF;

		OPEN p_CURSOR FOR
			SELECT DISTINCT FROM_CUT(C.LOAD_DATE, LOCAL_TIME_ZONE) "LOAD_DATE", C.LOAD_VAL    -- CF - WJC - 1 Jul 03 - Use From_Cut()
			FROM ACCOUNT_SERVICE A, SERVICE B, SERVICE_LOAD C
			WHERE A.ACCOUNT_ID = p_ACCOUNT_ID
				AND A.SERVICE_LOCATION_ID = v_SERVICE_LOCATION_ID
				AND A.METER_ID = p_METER_ID
				AND A.AGGREGATE_ID = 0
				AND B.MODEL_ID = GA.DEFAULT_MODEL
				AND B.SCENARIO_ID = GA.BASE_SCENARIO_ID
				AND B.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM SERVICE
					WHERE MODEL_ID = B.MODEL_ID
						AND SCENARIO_ID = B.SCENARIO_ID
						AND ACCOUNT_SERVICE_ID = B.ACCOUNT_SERVICE_ID
						AND PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
						AND SERVICE_DELIVERY_ID = B.SERVICE_DELIVERY_ID
						AND AS_OF_DATE <= p_USAGE_AS_OF_DATE)
				AND B.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
				AND B.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
				AND B.SERVICE_DELIVERY_ID = B.SERVICE_DELIVERY_ID
				AND C.SERVICE_ID = B.SERVICE_ID
				AND C.SERVICE_CODE = GA.FORECAST_SERVICE
				AND C.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND C.LOAD_CODE = GA.STANDARD
				AND INSTR(p_DAY_SELECTION, TO_CHAR(FROM_CUT(C.LOAD_DATE, LOCAL_TIME_ZONE), 'D')) > 0
			ORDER BY 1;
	ELSE
		v_PROFILE_AS_OF_DATE := CS.GET_PROFILE_AS_OF_DATE(v_PROFILE_ID, p_PROFILE_AS_OF_DATE);
        FP.GET_LOAD_PROFILE_POINTS
            	(
            	v_PROFILE_ID,
            	p_BEGIN_DATE,
            	p_END_DATE,
            	0,         --Just want date range points, so p_ALL_DATES = 0,
            	LOCAL_TIME_ZONE,
            	v_PROFILE_AS_OF_DATE,
            	g_DEFAULT_POINT_INDEX,
            	0,          --Just want one POINT_INDEX, so p_ALL_INDEXES=0,
                p_DAY_SELECTION,
            	p_STATUS,
            	p_CURSOR
            	);
	END IF;


END MONITOR_PROFILE_REQUEST;
----------------------------------------------------------------------------------------------------
PROCEDURE SIMILAR_DAY_TYPE
	(
	p_EDC_ID IN NUMBER,
	p_FORECAST_DATE IN DATE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_HISTORICAL_DATE OUT DATE,
	p_STATUS OUT NUMBER
	) AS
BEGIN
	  FP.SIMILAR_DAY_TYPE(p_EDC_ID,p_FORECAST_DATE,p_BEGIN_DATE,p_END_DATE,p_HISTORICAL_DATE,p_STATUS);
END;
----------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNT_PROFILE_ENERGY
	(
	p_ACCOUNT_IDENT IN VARCHAR,
	p_IDENT_TYPE IN CHAR,
	p_FORECAST_OR_SETTLEMENT IN VARCHAR,
	p_PARAMETER_CODE IN CHAR, --F or A for Weather Parameter Code.  F used to be used always.
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_ENERGY OUT NUMBER,
	p_STATUS OUT NUMBER
	) AS

v_ACCOUNT_ID NUMBER;
v_STATION_ID NUMBER;
v_CALENDAR_ID NUMBER;
v_EDC_ID NUMBER;
v_ENERGY NUMBER := 0;
v_SERVICE_DATE DATE;
v_PROFILE_TABLE GA.NUMBER_TABLE;
v_INDEX BINARY_INTEGER;

BEGIN

	IF NOT CAN_READ('PUBLIC') THEN
		ERRS.RAISE_NO_READ_MODULE('PUBLIC');
	END IF;

	 v_ACCOUNT_ID := CS.GET_ACCOUNT_ID(p_ACCOUNT_IDENT, p_IDENT_TYPE);
	 IF v_ACCOUNT_ID <= 0 THEN
		p_ENERGY := NULL;
	 	p_STATUS := v_ACCOUNT_ID;
	 	RETURN;
	END IF;

	v_SERVICE_DATE := TRUNC(p_BEGIN_DATE);

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('ACCOUNT_ID=' || TO_CHAR(v_ACCOUNT_ID));
	END IF;

	WHILE v_SERVICE_DATE <= TRUNC(p_END_DATE) LOOP

		v_STATION_ID := FW.GET_STATION_FOR_ACCOUNT(v_ACCOUNT_ID, v_SERVICE_DATE);
		v_CALENDAR_ID := FP.GET_ACCOUNT_CALENDAR_ID(v_ACCOUNT_ID, v_SERVICE_DATE, p_FORECAST_OR_SETTLEMENT);
		v_EDC_ID := GET_EDC_FOR_ACCOUNT(v_ACCOUNT_ID, v_SERVICE_DATE);

		COMPOSITE_PROFILE_FOR_CALENDAR(v_STATION_ID, v_CALENDAR_ID, v_EDC_ID, v_SERVICE_DATE, v_PROFILE_TABLE, p_TRACE_ON = g_ON, p_PARAMETER_CODE);

		IF LOGS.IS_DEBUG_ENABLED THEN
		   LOGS.LOG_DEBUG('SERVICE_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_SERVICE_DATE));
		   LOGS.LOG_DEBUG('STATION_ID=' || TO_CHAR(v_STATION_ID));
		   LOGS.LOG_DEBUG('CALENDAR_ID=' || TO_CHAR(v_CALENDAR_ID));
		   LOGS.LOG_DEBUG('COUNT=' || TO_CHAR(v_PROFILE_TABLE.COUNT));
		END IF;

		FOR v_INDEX IN v_PROFILE_TABLE.FIRST..v_PROFILE_TABLE.LAST LOOP
			v_ENERGY := v_ENERGY + v_PROFILE_TABLE(v_INDEX);
		END LOOP;

		v_PROFILE_TABLE.DELETE;
		FW.RELEASE_WEATHER;
		v_SERVICE_DATE := v_SERVICE_DATE + 1;

	END LOOP;

	p_ENERGY := v_ENERGY;
	p_STATUS := GA.SUCCESS;


END ACCOUNT_PROFILE_ENERGY;
----------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNT_PROFILE_ENERGY
	(
	p_ACCOUNT_NAME IN VARCHAR,
	p_FORECAST_OR_SETTLEMENT IN VARCHAR,
	p_PARAMETER_CODE IN CHAR, --F or A for Weather Parameter Code.  F used to be used always.
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_ENERGY OUT NUMBER,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	ACCOUNT_PROFILE_ENERGY(p_ACCOUNT_NAME, 'N', p_FORECAST_OR_SETTLEMENT, p_PARAMETER_CODE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TRACE_ON, p_ENERGY, p_STATUS);

END ACCOUNT_PROFILE_ENERGY;
----------------------------------------------------------------------------------------------------
PROCEDURE METER_PROFILE_ENERGY
	(
	p_ACCOUNT_IDENT IN VARCHAR,
	p_METER_ID  NUMBER,
	p_IDENT_TYPE IN CHAR,
	p_FORECAST_OR_SETTLEMENT IN VARCHAR,
	p_PARAMETER_CODE IN CHAR, --F or A for Weather Parameter Code.  F used to be used always.
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_ENERGY OUT NUMBER,
	p_STATUS OUT NUMBER
	) AS
v_ACCOUNT_ID NUMBER;
v_STATION_ID NUMBER;
v_CALENDAR_ID NUMBER;
v_EDC_ID NUMBER;
v_ENERGY NUMBER := 0;
v_SERVICE_DATE DATE;
v_PROFILE_TABLE GA.NUMBER_TABLE;
v_INDEX BINARY_INTEGER;
BEGIN
	IF NOT CAN_READ('PUBLIC') THEN
		ERRS.RAISE_NO_READ_MODULE('PUBLIC');
	END IF;

	 v_ACCOUNT_ID := CS.GET_ACCOUNT_ID(p_ACCOUNT_IDENT, p_IDENT_TYPE);
	 IF v_ACCOUNT_ID <= 0 THEN
		p_ENERGY := NULL;
	 	p_STATUS := v_ACCOUNT_ID;
	 	RETURN;
	END IF;
	v_SERVICE_DATE := TRUNC(p_BEGIN_DATE);
	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('ACCOUNT_ID=' || TO_CHAR(v_ACCOUNT_ID));
	END IF;
	WHILE v_SERVICE_DATE <= TRUNC(p_END_DATE) LOOP
		v_STATION_ID := FW.GET_STATION_FOR_ACCOUNT(v_ACCOUNT_ID, v_SERVICE_DATE);
		v_CALENDAR_ID := FP.GET_METER_CALENDAR_ID(p_METER_ID, v_SERVICE_DATE, 'F');
		v_EDC_ID := GET_EDC_FOR_ACCOUNT(v_ACCOUNT_ID, v_SERVICE_DATE);
		COMPOSITE_PROFILE_FOR_CALENDAR(v_STATION_ID, v_CALENDAR_ID, v_EDC_ID, v_SERVICE_DATE, v_PROFILE_TABLE, p_TRACE_ON = g_ON, p_PARAMETER_CODE);
		IF LOGS.IS_DEBUG_ENABLED THEN
		   LOGS.LOG_DEBUG('SERVICE_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_SERVICE_DATE));
		   LOGS.LOG_DEBUG('STATION_ID=' || TO_CHAR(v_STATION_ID));
		   LOGS.LOG_DEBUG('CALENDAR_ID=' || TO_CHAR(v_CALENDAR_ID));
		   LOGS.LOG_DEBUG('COUNT=' || TO_CHAR(v_PROFILE_TABLE.COUNT));
		END IF;
		FOR v_INDEX IN v_PROFILE_TABLE.FIRST..v_PROFILE_TABLE.LAST LOOP
			v_ENERGY := v_ENERGY + v_PROFILE_TABLE(v_INDEX);
		END LOOP;
		v_PROFILE_TABLE.DELETE;
		FW.RELEASE_WEATHER;
		v_SERVICE_DATE := v_SERVICE_DATE + 1;
	END LOOP;
	p_ENERGY := v_ENERGY;
	p_STATUS := GA.SUCCESS;
	END METER_PROFILE_ENERGY;
----------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNT_PROFILE
	(
	p_ACCOUNT_IDENT IN VARCHAR,
	p_IDENT_TYPE IN CHAR,
	p_FORECAST_OR_SETTLEMENT IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_PROFILE OUT GA.NUMBER_TABLE,
	p_STATUS OUT NUMBER
	) AS

v_ACCOUNT_ID NUMBER(9);
v_CALENDAR_ID NUMBER(9);
v_EDC_ID NUMBER(9);
v_STATION_ID NUMBER(9);
v_SERVICE_DATE DATE := TRUNC(p_BEGIN_DATE);
v_COMPOSITE_PROFILE GA.NUMBER_TABLE;
v_CAST_CONTEXT CAST_CONTEXT_TYPE := NEW_CAST_CONTEXT;
v_PROFILE_TYPE CHAR(1);
v_PROFILE_SOURCE_DATE DATE;
v_INDEX BINARY_INTEGER;

BEGIN

	v_CAST_CONTEXT.RUN_MODE := GA.HOUR_MODE;
	v_CAST_CONTEXT.REQUEST_TYPE := UPPER(SUBSTR(p_FORECAST_OR_SETTLEMENT,1,1));
	SELECT DECODE(v_CAST_CONTEXT.REQUEST_TYPE, GA.FORECAST_SERVICE, GA.FORECAST_SERVICE, GA.ACTUAL_SERVICE) INTO v_CAST_CONTEXT.WEATHER_PARAMETER_CODE FROM DUAL;
	v_CAST_CONTEXT.PROFILE_AS_OF_DATE := p_AS_OF_DATE;
	v_CAST_CONTEXT.DAY_TYPE := g_ANY_DAY;
	v_CAST_CONTEXT.MODEL_ID := GA.DEFAULT_MODEL;

	IF p_TRACE_ON > 0 THEN
		v_CAST_CONTEXT.TRACE_ON := 1;
		IF p_TRACE_ON > 1 THEN
			v_CAST_CONTEXT.DETAIL_TRACE_ON := 1;
		END IF;
	ELSE
		v_CAST_CONTEXT.TRACE_ON := CONSTANTS.NOT_ASSIGNED;
		v_CAST_CONTEXT.DETAIL_TRACE_ON := CONSTANTS.NOT_ASSIGNED;
	END IF;

	 v_ACCOUNT_ID := CS.GET_ACCOUNT_ID(p_ACCOUNT_IDENT, p_IDENT_TYPE);
	 IF NOT v_ACCOUNT_ID > CONSTANTS.NOT_ASSIGNED THEN
		p_STATUS := v_ACCOUNT_ID;
		RETURN;
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('ACCOUNT_ID=' || TO_CHAR(v_ACCOUNT_ID));
	END IF;

	WHILE v_SERVICE_DATE <= TRUNC(p_END_DATE) LOOP

		v_STATION_ID := FW.GET_STATION_FOR_ACCOUNT(v_ACCOUNT_ID, v_SERVICE_DATE);
		v_CALENDAR_ID := FP.GET_ACCOUNT_CALENDAR_ID(v_ACCOUNT_ID, v_SERVICE_DATE, p_FORECAST_OR_SETTLEMENT);
		v_EDC_ID := GET_EDC_FOR_ACCOUNT(v_ACCOUNT_ID, v_SERVICE_DATE);

		v_CAST_CONTEXT.SERVICE_DATE := v_SERVICE_DATE;
		v_CAST_CONTEXT.PROFILE_DATE := v_SERVICE_DATE;

		FP.COMPOSITE_PROFILE_FOR_CALENDAR(v_CAST_CONTEXT, v_STATION_ID, v_CALENDAR_ID, v_EDC_ID, FALSE, v_PROFILE_TYPE, v_PROFILE_SOURCE_DATE, v_COMPOSITE_PROFILE);

		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG('SERVICE_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_SERVICE_DATE));
			LOGS.LOG_DEBUG('STATION_ID=' || TO_CHAR(v_STATION_ID));
			LOGS.LOG_DEBUG('CALENDAR_ID=' || TO_CHAR(v_CALENDAR_ID));
			LOGS.LOG_DEBUG('COMPOSITE_PROFILE.COUNT=' || TO_CHAR(v_COMPOSITE_PROFILE.COUNT));
		END IF;

		FOR v_INDEX IN v_COMPOSITE_PROFILE.FIRST..v_COMPOSITE_PROFILE.LAST LOOP
			p_PROFILE(p_PROFILE.COUNT + 1) := v_COMPOSITE_PROFILE(v_INDEX);
		END LOOP;

		v_COMPOSITE_PROFILE.DELETE;
		FW.RELEASE_WEATHER;
		v_SERVICE_DATE := v_SERVICE_DATE + 1;

	END LOOP;

	p_STATUS := GA.SUCCESS;


END ACCOUNT_PROFILE;
----------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNT_PROFILE
	(
	p_ACCOUNT_NAME IN VARCHAR,
	p_FORECAST_OR_SETTLEMENT IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_PROFILE OUT GA.NUMBER_TABLE,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	ACCOUNT_PROFILE(p_ACCOUNT_NAME, 'N', p_FORECAST_OR_SETTLEMENT, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TRACE_ON, p_PROFILE, p_STATUS);

END ACCOUNT_PROFILE;
----------------------------------------------------------------------------------------------------
PROCEDURE METER_PROFILE
	(
	p_ACCOUNT_IDENT IN VARCHAR,
	p_METER_ID  NUMBER,
	p_IDENT_TYPE IN CHAR,
	p_FORECAST_OR_SETTLEMENT IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_PROFILE OUT GA.NUMBER_TABLE,
	p_STATUS OUT NUMBER
	) AS
v_ACCOUNT_ID NUMBER;
v_STATION_ID NUMBER;
v_CALENDAR_ID NUMBER;
v_EDC_ID NUMBER;
--v_ENERGY NUMBER := 0;
v_SERVICE_DATE DATE;
v_PROFILE_TABLE GA.NUMBER_TABLE;
v_INDEX BINARY_INTEGER;
BEGIN
	IF NOT CAN_READ('PUBLIC') THEN
		ERRS.RAISE_NO_READ_MODULE('PUBLIC');
	END IF;

	v_ACCOUNT_ID := CS.GET_ACCOUNT_ID(p_ACCOUNT_IDENT, p_IDENT_TYPE);
	IF v_ACCOUNT_ID <= 0 THEN
	 	p_STATUS := v_ACCOUNT_ID;
	 	RETURN;
	END IF;
	v_SERVICE_DATE := TRUNC(p_BEGIN_DATE);
	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('ACCOUNT_ID=' || TO_CHAR(v_ACCOUNT_ID));
	END IF;
	WHILE v_SERVICE_DATE <= TRUNC(p_END_DATE) LOOP
		v_STATION_ID := FW.GET_STATION_FOR_ACCOUNT(v_ACCOUNT_ID, v_SERVICE_DATE);
		v_CALENDAR_ID := FP.GET_METER_CALENDAR_ID(p_METER_ID, v_SERVICE_DATE, 'F');
		v_EDC_ID := GET_EDC_FOR_ACCOUNT(v_ACCOUNT_ID, v_SERVICE_DATE);
		COMPOSITE_PROFILE_FOR_CALENDAR(v_STATION_ID, v_CALENDAR_ID, v_EDC_ID, v_SERVICE_DATE, v_PROFILE_TABLE);
		IF LOGS.IS_DEBUG_ENABLED THEN
		   LOGS.LOG_DEBUG('SERVICE_DATE=' || TEXT_UTIL.TO_CHAR_DATE(v_SERVICE_DATE));
		   LOGS.LOG_DEBUG('STATION_ID=' || TO_CHAR(v_STATION_ID));
		   LOGS.LOG_DEBUG('CALENDAR_ID=' || TO_CHAR(v_CALENDAR_ID));
		   LOGS.LOG_DEBUG('COUNT=' || TO_CHAR(v_PROFILE_TABLE.COUNT));
		END IF;
		FOR v_INDEX IN v_PROFILE_TABLE.FIRST..v_PROFILE_TABLE.LAST LOOP
			p_PROFILE(p_PROFILE.COUNT + 1) := v_PROFILE_TABLE(v_INDEX);
		END LOOP;
		v_PROFILE_TABLE.DELETE;
		FW.RELEASE_WEATHER;
		v_SERVICE_DATE := v_SERVICE_DATE + 1;
	END LOOP;

	p_STATUS := GA.SUCCESS;

END METER_PROFILE;
----------------------------------------------------------------------------------------------------
PROCEDURE PROFILE_FROM_CALENDAR
	(
	p_CALENDAR_ID IN NUMBER,
	p_STATION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_ENERGY OUT NUMBER,
	p_DEMAND OUT NUMBER,
	p_PROFILE OUT GA.NUMBER_TABLE
	) AS

v_SERVICE_DATE DATE := TRUNC(p_BEGIN_DATE);
v_INDEX BINARY_INTEGER;
v_PROFILE_TABLE GA.NUMBER_TABLE;

BEGIN

	IF NOT CAN_READ('PROFILING') THEN
		ERRS.RAISE_NO_READ_MODULE('PROFILING');
	END IF;

	p_STATUS := GA.SUCCESS;
	p_ENERGY := 0;
	p_DEMAND := 0;
	p_PROFILE.DELETE;

	WHILE v_SERVICE_DATE <= TRUNC(p_END_DATE) LOOP
		COMPOSITE_PROFILE_FOR_CALENDAR(ABS(p_STATION_ID), p_CALENDAR_ID, CONSTANTS.NOT_ASSIGNED, v_SERVICE_DATE, v_PROFILE_TABLE);
		FOR v_INDEX IN v_PROFILE_TABLE.FIRST..v_PROFILE_TABLE.LAST LOOP
			IF v_PROFILE_TABLE.EXISTS(v_INDEX) THEN
				p_PROFILE(p_PROFILE.COUNT + 1) := v_PROFILE_TABLE(v_INDEX);
				p_ENERGY := p_ENERGY + v_PROFILE_TABLE(v_INDEX);
				IF v_PROFILE_TABLE(v_INDEX) > p_DEMAND THEN
					p_DEMAND := v_PROFILE_TABLE(v_INDEX);
				END IF;
			ELSE
				p_PROFILE(p_PROFILE.COUNT + 1) := 0;
			END IF;
		END LOOP;
		v_SERVICE_DATE := v_SERVICE_DATE + 1;
		v_PROFILE_TABLE.DELETE;
	END LOOP;


END PROFILE_FROM_CALENDAR;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_PROJECTION_ID
	(
	p_CALENDAR_ID IN NUMBER,
	p_PROJECTION_TYPE IN VARCHAR,
	p_TEMPLATE_ID IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_PROJECTION_ID OUT NUMBER
	) AS

BEGIN

	SELECT PROJECTION_ID
	INTO p_PROJECTION_ID
	FROM CALENDAR_PROJECTION
	WHERE CALENDAR_ID = p_CALENDAR_ID
		AND PROJECTION_TYPE = p_PROJECTION_TYPE
		AND TEMPLATE_ID = p_TEMPLATE_ID
		AND AS_OF_DATE = p_AS_OF_DATE;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		SELECT OID.NEXTVAL INTO p_PROJECTION_ID FROM DUAL;
		INSERT INTO CALENDAR_PROJECTION(PROJECTION_ID, CALENDAR_ID, PROJECTION_TYPE, TEMPLATE_ID, AS_OF_DATE, ENTRY_DATE)
		VALUES(p_PROJECTION_ID, p_CALENDAR_ID, p_PROJECTION_TYPE, p_TEMPLATE_ID, p_AS_OF_DATE, SYSDATE);

END GET_PROJECTION_ID;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_PROJECTION_PATTERN
	(
	p_PROJECTION_ID IN NUMBER,
	p_PROJECTION_DATE IN DATE,
	p_WEEKDAY_COUNT IN NUMBER,
	p_WEEKDAY IN GA.NUMBER_TABLE,
	p_WEEKEND_COUNT IN NUMBER,
	p_WEEKEND IN GA.NUMBER_TABLE
	) AS

v_INDEX BINARY_INTEGER;
v_PROJECTION_DATE DATE;

BEGIN

-- Insert the Weekend Profile Pattern.
	IF p_WEEKDAY.COUNT > 0 THEN
		v_PROJECTION_DATE := TRUNC(p_PROJECTION_DATE, 'MONTH');
		FOR v_INDEX IN p_WEEKDAY.FIRST..p_WEEKDAY.LAST LOOP
			IF GA.DEFAULT_MODEL = GA.ELECTRIC_MODEL THEN
				v_PROJECTION_DATE := ADD_HOURS_TO_DATE(v_PROJECTION_DATE, 1);
			END IF;
			INSERT INTO PROJECTION_PATTERN(PROJECTION_ID, PERIOD_ID, PROJECTION_DATE, ENERGY, DEMAND)
			VALUES(p_PROJECTION_ID, -1, v_PROJECTION_DATE, p_WEEKDAY(v_INDEX) / p_WEEKDAY_COUNT, p_WEEKDAY(v_INDEX) / p_WEEKDAY_COUNT);
		END LOOP;
	END IF;

-- Insert the Weekday Profile Pattern.
	IF p_WEEKDAY.COUNT > 0 THEN
		v_PROJECTION_DATE := TRUNC(p_PROJECTION_DATE, 'MONTH');
		FOR v_INDEX IN p_WEEKEND.FIRST..p_WEEKEND.LAST LOOP
			IF GA.DEFAULT_MODEL = GA.ELECTRIC_MODEL THEN
				v_PROJECTION_DATE := ADD_HOURS_TO_DATE(v_PROJECTION_DATE, 1);
			END IF;
			INSERT INTO PROJECTION_PATTERN(PROJECTION_ID, PERIOD_ID, PROJECTION_DATE, ENERGY, DEMAND)
			VALUES(p_PROJECTION_ID, -2, v_PROJECTION_DATE, p_WEEKEND(v_INDEX) / p_WEEKEND_COUNT, p_WEEKEND(v_INDEX) / p_WEEKEND_COUNT);
		END LOOP;
	END IF;

END PUT_PROJECTION_PATTERN;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_PROJECTION_PATTERN
	(
	p_PROJECTION_ID IN NUMBER,
	p_PROJECTION_DATE IN DATE,
	p_PROJECTION IN PROJECTION_TABLE,
	p_TOU_PERIODS IN TOU_TABLE
	) AS

BEGIN

-- Rollup the energy to the TOU Periods.
	INSERT INTO PROJECTION_PATTERN(PROJECTION_ID, PERIOD_ID, PROJECTION_DATE, ENERGY, DEMAND)
		SELECT p_PROJECTION_ID, A.PERIOD_ID, p_PROJECTION_DATE, SUM(Y), MAX(Y)
		FROM TABLE(CAST(p_TOU_PERIODS AS TOU_TABLE)) A,
			TABLE(CAST(p_PROJECTION AS PROJECTION_TABLE)) B
		WHERE A.DAY_NAME IN(TO_CHAR(p_PROJECTION_DATE,'Dy'), 'Hol')
			AND B.HOUR = A.HOUR
		GROUP BY p_PROJECTION_ID, A.PERIOD_ID, p_PROJECTION_DATE;


END PUT_PROJECTION_PATTERN;
----------------------------------------------------------------------------------------------------
PROCEDURE PROJECTION_PATTERN_BY_DAY
	(
	p_PROJECTION_ID IN NUMBER,
	p_PROJECTION_DATE IN DATE,
	p_PROFILE IN GA.NUMBER_TABLE,
	p_TOU_PERIODS IN TOU_TABLE
	) AS

v_INDEX BINARY_INTEGER;
v_PROJECTION PROJECTION_TABLE :=  PROJECTION_TABLE();

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PROJECTION_PATTERN_BY_DAY');
	END IF;

	v_PROJECTION.EXTEND(p_PROFILE.COUNT);

	FOR v_INDEX IN p_PROFILE.FIRST..p_PROFILE.LAST LOOP
		v_PROJECTION(v_INDEX) := PROJECTION_TYPE(v_INDEX, 0, p_PROFILE(v_INDEX));
	END LOOP;

	PUT_PROJECTION_PATTERN(p_PROJECTION_ID, p_PROJECTION_DATE, v_PROJECTION, p_TOU_PERIODS);

END PROJECTION_PATTERN_BY_DAY;
----------------------------------------------------------------------------------------------------
PROCEDURE PROJECTION_PATTERN_BY_MONTH
	(
	p_PROJECTION_ID IN NUMBER,
	p_PROJECTION_DATE IN DATE,
	p_PROFILE IN GA.NUMBER_TABLE,
	p_WEEKDAY_COUNT IN OUT NUMBER,
	p_WEEKDAY IN OUT NOCOPY GA.NUMBER_TABLE,
	p_WEEKEND_COUNT IN OUT NUMBER,
	p_WEEKEND IN OUT NOCOPY GA.NUMBER_TABLE
	) AS

v_INDEX BINARY_INTEGER;

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PROJECTION_PATTERN_BY_MONTH');
	END IF;

-- Accumulate the profiles over the Weekday and Weekend day types.
	IF UPPER(TO_CHAR(p_PROJECTION_DATE, 'DY')) IN ('SAT','SUN') THEN
		FOR v_INDEX IN p_PROFILE.FIRST..p_PROFILE.LAST LOOP
			IF p_WEEKEND.EXISTS(v_INDEX) THEN
				p_WEEKEND(v_INDEX) := p_WEEKEND(v_INDEX) + p_PROFILE(v_INDEX);
			ELSE
				p_WEEKEND(v_INDEX) := p_PROFILE(v_INDEX);
			END IF;
		END LOOP;
		p_WEEKEND_COUNT := p_WEEKEND_COUNT + 1;
	ELSE
		FOR v_INDEX IN p_PROFILE.FIRST..p_PROFILE.LAST LOOP
			IF p_WEEKDAY.EXISTS(v_INDEX) THEN
				p_WEEKDAY(v_INDEX) := p_WEEKDAY(v_INDEX) + p_PROFILE(v_INDEX);
			ELSE
				p_WEEKDAY(v_INDEX) := p_PROFILE(v_INDEX);
			END IF;
		END LOOP;
		p_WEEKDAY_COUNT := p_WEEKDAY_COUNT + 1;
	END IF;

	IF p_PROJECTION_DATE = LAST_DAY(p_PROJECTION_DATE) THEN
		PUT_PROJECTION_PATTERN(p_PROJECTION_ID, TRUNC(p_PROJECTION_DATE,'MONTH'), p_WEEKDAY_COUNT, p_WEEKDAY, p_WEEKEND_COUNT, p_WEEKEND);
		p_WEEKDAY.DELETE;
		p_WEEKEND.DELETE;
		p_WEEKDAY_COUNT := 0;
		p_WEEKEND_COUNT := 0;
	END IF;

END PROJECTION_PATTERN_BY_MONTH;
----------------------------------------------------------------------------------------------------
PROCEDURE PROJECTION_FROM_CALENDAR
	(
	p_CALENDAR_ID IN NUMBER,
	p_STATION_ID IN NUMBER,
	p_TEMPLATE_IDS IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

v_ELASPSED NUMBER;
v_PROJECTION_DATE DATE := TRUNC(p_BEGIN_DATE, 'MONTH');
v_PROFILE GA.NUMBER_TABLE;
v_PROFILE_TEMP GA.NUMBER_TABLE;
v_DAY_ID NUMBER;
v_MONTH_ID NUMBER;
v_WEEKDAY GA.NUMBER_TABLE;
v_WEEKEND GA.NUMBER_TABLE;
v_WEEKDAY_COUNT NUMBER(2) := 0;
v_WEEKEND_COUNT NUMBER(2) := 0;
v_TOU_PERIODS TOU_TABLE := TOU_TABLE();
v_TEMPLATE_IDS GA.STRING_TABLE;
v_INDEX BINARY_INTEGER;
v_HAVE_PROJECTION_TEMPLATE BOOLEAN := FALSE;
v_TOU_INDEX BINARY_INTEGER;
v_NUM_TO_AGGREGATE BINARY_INTEGER;
v_INDEX_TEMP BINARY_INTEGER;
v_AGGREGATE_COUNT BINARY_INTEGER;

BEGIN

	IF NOT CAN_READ('QUOTE MANAGEMENT') THEN
		ERRS.RAISE_NO_READ_MODULE('QUOTE MANAGEMENT');
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK';
	v_ELASPSED := DBMS_UTILITY.GET_TIME;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PROJECTION_FROM_CALENDAR BEGIN AT ' || TEXT_UTIL.TO_CHAR_DATE(SYSDATE));
		LOGS.LOG_DEBUG('CALENDAR_ID=' || TO_CHAR(p_CALENDAR_ID));
		LOGS.LOG_DEBUG('STATION_ID=' || TO_CHAR(p_STATION_ID));
		LOGS.LOG_DEBUG('TEMPLATE_IDS=' || p_TEMPLATE_IDS);
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TO_CHAR(TRUNC(p_END_DATE)));
		LOGS.LOG_DEBUG('AS_OF_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_AS_OF_DATE));
	END IF;

-- Make certain the default Template is Projected.
	IF p_TEMPLATE_IDS IS NOT NULL THEN
		UT.TOKENS_FROM_STRING(p_TEMPLATE_IDS, ';', v_TEMPLATE_IDS);
		FOR v_INDEX IN v_TEMPLATE_IDS.FIRST..v_TEMPLATE_IDS.LAST LOOP
			IF v_TEMPLATE_IDS(v_iNDEX) = g_PROJECTION_TEMPLATE THEN
				v_HAVE_PROJECTION_TEMPLATE := TRUE;
				EXIT;
			END IF;
		END LOOP;
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
	  IF v_HAVE_PROJECTION_TEMPLATE THEN
		LOGS.LOG_DEBUG('v_HAVE_PROJECTION_TEMPLATE = TRUE');
	  ELSE
		LOGS.LOG_DEBUG('v_HAVE_PROJECTION_TEMPLATE = FALSE');
	  END IF;
	  LOGS.LOG_DEBUG('v_TEMPLATE_IDS.COUNT = '||TO_CHAR(v_TEMPLATE_IDS.COUNT));
	  LOGS.LOG_DEBUG('g_PROJECTION_TEMPLATE= '||TO_CHAR(g_PROJECTION_TEMPLATE));
	END IF;


	IF NOT v_HAVE_PROJECTION_TEMPLATE THEN
		v_TEMPLATE_IDS(v_TEMPLATE_IDS.COUNT + 1) := g_PROJECTION_TEMPLATE;
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PROJECTION_FROM_CALENDAR BEGIN AT ' || TEXT_UTIL.TO_CHAR_DATE(SYSDATE));
		LOGS.LOG_DEBUG('CALENDAR_ID=' || TO_CHAR(p_CALENDAR_ID));
		LOGS.LOG_DEBUG('STATION_ID=' || TO_CHAR(p_STATION_ID));
		LOGS.LOG_DEBUG('TEMPLATE_IDS=' || p_TEMPLATE_IDS);
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TO_CHAR(TRUNC(p_END_DATE)));
		LOGS.LOG_DEBUG('AS_OF_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_AS_OF_DATE));
	END IF;

	GET_PROJECTION_ID(p_CALENDAR_ID, 'MONTH', CONSTANTS.NOT_ASSIGNED, p_AS_OF_DATE, v_MONTH_ID);

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('MONTH PROJECTION ID= ' || TO_CHAR(v_MONTH_ID));
	END IF;


	DELETE PROJECTION_PATTERN
	WHERE PROJECTION_ID IN
		(SELECT DISTINCT PROJECTION_ID
		FROM CALENDAR_PROJECTION
		WHERE CALENDAR_ID = p_CALENDAR_ID
			AND AS_OF_DATE = p_AS_OF_DATE)
		AND PERIOD_ID = PERIOD_ID
		AND PROJECTION_DATE BETWEEN TRUNC(p_BEGIN_DATE, 'MONTH') AND LAST_DAY(p_END_DATE);

	WHILE v_PROJECTION_DATE <= LAST_DAY(p_END_DATE) LOOP

		COMPOSITE_PROFILE_FOR_CALENDAR(p_STATION_ID, p_CALENDAR_ID, CONSTANTS.NOT_ASSIGNED, v_PROJECTION_DATE, v_PROFILE);
      	-- aggregate sub-hourly profiles to hourly
        IF v_PROFILE.COUNT IN (48,96) THEN
        	v_NUM_TO_AGGREGATE := v_PROFILE.COUNT/24;
            v_INDEX := v_PROFILE.FIRST;
            v_INDEX_TEMP := 1;
            v_AGGREGATE_COUNT := 0;
            v_PROFILE_TEMP.DELETE;
            WHILE v_PROFILE.EXISTS(v_INDEX) LOOP
				IF v_AGGREGATE_COUNT = v_NUM_TO_AGGREGATE THEN
                	v_INDEX_TEMP := v_INDEX_TEMP+1;
                    v_AGGREGATE_COUNT := 0;
                END IF;
                IF v_PROFILE_TEMP.EXISTS(v_INDEX_TEMP) THEN
	                v_PROFILE_TEMP(v_INDEX_TEMP) := v_PROFILE_TEMP(v_INDEX_TEMP) + v_PROFILE(v_INDEX);
                ELSE
	                v_PROFILE_TEMP(v_INDEX_TEMP) := v_PROFILE(v_INDEX);
                END IF;
                v_AGGREGATE_COUNT := v_AGGREGATE_COUNT+1;
            	v_INDEX := v_PROFILE.NEXT(v_INDEX);
            END LOOP;
            -- copy hourly profile values to our profile table
            v_PROFILE := v_PROFILE_TEMP;
        END IF;

		FOR v_INDEX IN v_TEMPLATE_IDS.FIRST..v_TEMPLATE_IDS.LAST LOOP
			CU.GET_TOU_PERIODS(v_TEMPLATE_IDS(v_INDEX), v_PROJECTION_DATE, v_TOU_PERIODS);
			IF LOGS.IS_DEBUG_ENABLED THEN
				FOR v_TOU_INDEX IN v_TOU_PERIODS.FIRST..v_TOU_PERIODS.LAST LOOP
					LOGS.LOG_DEBUG(v_TOU_PERIODS(v_TOU_INDEX).DAY_NAME || ',' || TO_CHAR(v_TOU_PERIODS(v_TOU_INDEX).PERIOD_ID) || ',' || TO_CHAR(v_TOU_PERIODS(v_TOU_INDEX).HOUR));
				END LOOP;
			END IF;
			GET_PROJECTION_ID(p_CALENDAR_ID, 'DAY', v_TEMPLATE_IDS(v_INDEX), p_AS_OF_DATE, v_DAY_ID);
			PROJECTION_PATTERN_BY_DAY(v_DAY_ID, v_PROJECTION_DATE, v_PROFILE, v_TOU_PERIODS);
		END LOOP;

		PROJECTION_PATTERN_BY_MONTH(v_MONTH_ID, v_PROJECTION_DATE, v_PROFILE, v_WEEKDAY_COUNT, v_WEEKDAY, v_WEEKEND_COUNT, v_WEEKEND);

		v_PROJECTION_DATE := v_PROJECTION_DATE + 1;

		v_PROFILE.DELETE;

	END LOOP;

	v_ELASPSED := DBMS_UTILITY.GET_TIME - v_ELASPSED;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('PROJECTION_FROM_CALENDAR END AT ' || TEXT_UTIL.TO_CHAR_DATE(SYSDATE));
		LOGS.LOG_DEBUG('ELAPSED TIME=' || TO_CHAR(v_ELASPSED));
	END IF;


END PROJECTION_FROM_CALENDAR;
----------------------------------------------------------------------------------------------------
PROCEDURE WRF_PROFILE_PROJECTION
	(
	p_PROFILE_ID IN NUMBER,
	p_PROJECTION_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_WRF_VAR_1 IN OUT NOCOPY GA.NUMBER_TABLE,
	p_WRF_VAR_2 IN OUT NOCOPY GA.NUMBER_TABLE,
	p_WRF_PROFILE IN OUT NOCOPY GA.NUMBER_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

v_CAST_CONTEXT CAST_CONTEXT_TYPE := NEW_CAST_CONTEXT;
BEGIN
	  FW.WRF_PROFILE_PROJECTION(v_CAST_CONTEXT,p_PROFILE_ID,p_PROJECTION_DATE,p_AS_OF_DATE,p_TRACE_ON,p_WRF_VAR_1,p_WRF_VAR_2,p_WRF_PROFILE,p_STATUS,p_MESSAGE);
END WRF_PROFILE_PROJECTION;
--------------------------------------------------------------------------------------------------
PROCEDURE SERVICE_VALIDATION_REQUEST
	(
	p_MODEL_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_HISTORICAL IN NUMBER,
	p_AVERAGE IN NUMBER,
	p_MOST_RECENT IN NUMBER,
	p_ESP_IDS IN VARCHAR,
	p_REQUESTOR IN VARCHAR,
	p_TRACE IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

v_SERVICE_DATE DATE := TRUNC(p_SERVICE_DATE);
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;
v_REQUEST_TYPE VARCHAR(3);

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('SERVICE_VALIDATION_REQUEST BEGIN AT ' || TEXT_UTIL.TO_CHAR_DATE(SYSDATE));
		LOGS.LOG_DEBUG('MODEL_ID=' || TO_CHAR(p_MODEL_ID));
		LOGS.LOG_DEBUG('SERVICE_DATE=' || TO_CHAR(v_SERVICE_DATE));
		LOGS.LOG_DEBUG('AS_OF_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_AS_OF_DATE));
		LOGS.LOG_DEBUG('HISTORICAL=' || TO_CHAR(p_HISTORICAL));
		LOGS.LOG_DEBUG('AVERAGE=' || TO_CHAR(p_AVERAGE));
		LOGS.LOG_DEBUG('MOST_RECENT=' || TO_CHAR(p_MOST_RECENT));
		LOGS.LOG_DEBUG('ESP_IDS=' || p_ESP_IDS);
		LOGS.LOG_DEBUG('REQUEST_TYPE=' || v_REQUEST_TYPE);
	END IF;

	SELECT DECODE(p_HISTORICAL,1,'H','') || DECODE(p_AVERAGE,1,'A','') || DECODE(p_MOST_RECENT,1,'R','') INTO v_REQUEST_TYPE FROM DUAL;

	FP.GET_SERVICE_VALIDATION(p_MODEL_ID, v_SERVICE_DATE, p_AS_OF_DATE, v_REQUEST_TYPE, p_ESP_IDS);
	FP.PUT_VALIDATION_BEST_FIT(v_SERVICE_DATE);

	v_ELAPSED := DBMS_UTILITY.GET_TIME - v_ELAPSED;
	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('SERVICE_VALIDATION_REQUEST END AT ' || TEXT_UTIL.TO_CHAR_DATE(SYSDATE));
		LOGS.LOG_DEBUG('ELAPSED TIME=' || TO_CHAR(v_ELAPSED));
	END IF;


END SERVICE_VALIDATION_REQUEST;
----------------------------------------------------------------------------------------------------
PROCEDURE STORE_SERVICE_LOAD
	(
	p_SERVICE_ID IN NUMBER,
	p_SERVICE_CODE IN CHAR,
	p_LOAD_CODE IN CHAR,
	p_LOAD_DATE IN GA.DATE_TABLE,
	p_LOAD_VAL IN GA.FLOAT_TABLE,
	p_TX_LOSS IN GA.FACTOR_TABLE,
	p_DX_LOSS IN GA.FACTOR_TABLE,
	p_UE_LOSS IN GA.FACTOR_TABLE
	) AS

v_INDEX BINARY_INTEGER;
v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

	v_BEGIN_DATE := p_LOAD_DATE(p_LOAD_DATE.FIRST);
	v_END_DATE := p_LOAD_DATE(p_LOAD_DATE.LAST);

	DELETE SERVICE_LOAD
	WHERE SERVICE_ID = p_SERVICE_ID
		AND SERVICE_CODE = p_SERVICE_CODE
		AND LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND LOAD_CODE = p_LOAD_CODE;

	FORALL v_INDEX IN 1..p_LOAD_DATE.COUNT
		INSERT INTO SERVICE_LOAD(SERVICE_ID, SERVICE_CODE, LOAD_DATE, LOAD_CODE, LOAD_VAL, TX_LOSS_VAL, DX_LOSS_VAL, UE_LOSS_VAL)
		VALUES (p_SERVICE_ID, p_SERVICE_CODE, p_LOAD_DATE(v_INDEX), p_LOAD_CODE, p_LOAD_VAL(v_INDEX), p_TX_LOSS(v_INDEX),  p_DX_LOSS(v_INDEX), p_UE_LOSS(v_INDEX));

END STORE_SERVICE_LOAD;
----------------------------------------------------------------------------------------------------
PROCEDURE ACCEPT_EXTERNAL_CAST
	(
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,	--USE GA.BASE_SCENARIO_ID FOR OLD BEHAVIOR.
	p_ACCOUNT_IDENTIFIER IN VARCHAR,
	p_ACCOUNT_IDENTIFIER_TYPE IN CHAR,
	p_SERVICE_DATE IN DATE,
	p_INPUT_AS_OF_DATE IN DATE,
	p_OUTPUT_AS_OF_DATE IN DATE,
	p_CAST IN GA.NUMBER_TABLE,
	p_MINUTE_INTERVAL IN NUMBER,
	p_APPLY_USAGE_FACTOR IN NUMBER,
	p_APPLY_TD_LOSSES IN NUMBER,
	p_APPLY_UFE IN NUMBER,
	p_APPLY_UFE_OTHER IN NUMBER,
	p_APPLY_TO_INTERNAL IN NUMBER,
	p_REQUESTOR IN VARCHAR,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

v_SERVICE_DATE DATE := TRUNC(p_SERVICE_DATE);
v_ACCOUNT_ID NUMBER;
v_SERVICE_LOCATION_ID NUMBER;
v_USAGE_FACTOR NUMBER;
v_APPLY_UFE_CODE NUMBER(1);
v_LOAD_CODE CHAR(1);
v_SERVICE SERVICE%ROWTYPE;
v_PROVIDER_SERVICE PROVIDER_SERVICE%ROWTYPE;
v_SERVICE_STATE SERVICE_STATE%ROWTYPE;
v_LOAD_DATE GA.DATE_TABLE;
v_LOAD_VAL GA.FLOAT_TABLE;
v_TX_LOSS GA.FACTOR_TABLE;
v_DX_LOSS GA.FACTOR_TABLE;
v_UE_LOSS GA.FACTOR_TABLE;
v_INDEX BINARY_INTEGER;
v_REQUEST_TYPE CHAR(1) := UPPER(SUBSTR(p_REQUEST_TYPE,1,1));
v_ELAPSED NUMBER := DBMS_UTILITY.GET_TIME;

BEGIN

	IF NOT CAN_WRITE('FORECASTING') THEN
		ERRS.RAISE_NO_WRITE_MODULE('FORECASTING');
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK';

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('ACCEPT_EXTERNAL_CAST BEGIN AT ' || TEXT_UTIL.TO_CHAR_DATE(SYSDATE));
		LOGS.LOG_DEBUG('REQUEST_TYPE=' || v_REQUEST_TYPE);
		LOGS.LOG_DEBUG('MODEL_ID=' || TO_CHAR(p_MODEL_ID));
		LOGS.LOG_DEBUG('ACCOUNT_IDENTIFIER=' || p_ACCOUNT_IDENTIFIER);
		LOGS.LOG_DEBUG('ACCOUNT_IDENTIFIER_TYPE=' || p_ACCOUNT_IDENTIFIER_TYPE);
		LOGS.LOG_DEBUG('SERVICE_DATE=' || TO_CHAR(v_SERVICE_DATE));
		LOGS.LOG_DEBUG('INPUT_AS_OF_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_INPUT_AS_OF_DATE));
		LOGS.LOG_DEBUG('OUTPUT_AS_OF_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_OUTPUT_AS_OF_DATE));
		LOGS.LOG_DEBUG('MINUTE_INTERVAL=' || TO_CHAR(p_MINUTE_INTERVAL));
		LOGS.LOG_DEBUG('APPLY_USAGE_FACTOR=' || TO_CHAR(p_APPLY_USAGE_FACTOR));
		LOGS.LOG_DEBUG('APPLY_TD_LOSSES=' || TO_CHAR(p_APPLY_TD_LOSSES));
		LOGS.LOG_DEBUG('APPLY_UFE=' || TO_CHAR(p_APPLY_UFE));
		LOGS.LOG_DEBUG('APPLY_UFE_OTHER=' || TO_CHAR(p_APPLY_UFE_OTHER));
		LOGS.LOG_DEBUG('APPLY_TO_INTERNAL=' || TO_CHAR(p_APPLY_TO_INTERNAL));
		LOGS.LOG_DEBUG('REQUESTOR=' || p_REQUESTOR);
	END IF;

	IF UPPER(p_ACCOUNT_IDENTIFIER_TYPE) = 'X' THEN
	   ID.ID_FOR_ACCOUNT_EXTERNAL_IDENT(p_ACCOUNT_IDENTIFIER, FALSE, v_ACCOUNT_ID);
	ELSE
	   ID.ID_FOR_ACCOUNT(p_ACCOUNT_IDENTIFIER, FALSE, v_ACCOUNT_ID);
	END IF;

	IF v_ACCOUNT_ID <= 0 THEN
		ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY , 'ACCOUNT with External Identifier = ' || p_ACCOUNT_IDENTIFIER);
	END IF;

	IF p_APPLY_UFE = 0 THEN
		v_APPLY_UFE_CODE := 0;
	ELSE
		v_APPLY_UFE_CODE := 1;
		IF p_APPLY_UFE_OTHER = 1 THEN
			v_APPLY_UFE_CODE := 2;
		END IF;
	END IF;

	v_SERVICE_LOCATION_ID := CS.GET_SERVICE_LOCATION_ID(v_ACCOUNT_ID, v_SERVICE_DATE);

	v_SERVICE_STATE := CS.GET_SERVICE_STATE(p_MODEL_ID, p_SCENARIO_ID, v_ACCOUNT_ID, v_SERVICE_LOCATION_ID, CONSTANTS.NOT_ASSIGNED, CONSTANTS.NOT_ASSIGNED, v_REQUEST_TYPE, v_SERVICE_DATE, p_OUTPUT_AS_OF_DATE, CONSTANTS.NOT_ASSIGNED, v_APPLY_UFE_CODE, p_REQUESTOR);

	v_SERVICE_STATE.IS_EXTERNAL_FORECAST := 1;
	v_SERVICE_STATE.BASIS_AS_OF_DATE := p_INPUT_AS_OF_DATE;
	v_SERVICE_STATE.PROFILE_TYPE := g_EXTERNAL_PROFILE;
	v_SERVICE_STATE.PROFILE_ZERO_COUNT := 0;

	IF p_APPLY_USAGE_FACTOR = 1 THEN
		IF GA.USAGE_FACTOR_PER_UNIT_OPTION THEN
			v_USAGE_FACTOR := 1.0 + v_SERVICE_STATE.USAGE_FACTOR;
		ELSE
			v_USAGE_FACTOR := v_SERVICE_STATE.USAGE_FACTOR;
		END IF;
	ELSE
		v_USAGE_FACTOR := 1;
		v_SERVICE_STATE.USAGE_FACTOR := 1.0;
	END IF;

	IF p_CAST.COUNT > 0 THEN
		CS.PUT_SERVICE_STATE(v_SERVICE_STATE);
		v_INDEX := p_CAST.FIRST;
		WHILE v_INDEX <= p_CAST.LAST LOOP
			v_SERVICE_DATE := ADD_MINUTES_TO_DATE(v_SERVICE_DATE, p_MINUTE_INTERVAL);
			v_LOAD_DATE(v_LOAD_DATE.COUNT + 1) := v_SERVICE_DATE;
			v_LOAD_VAL(v_LOAD_VAL.COUNT + 1) := p_CAST(v_INDEX)  * v_USAGE_FACTOR;
			v_TX_LOSS(v_TX_LOSS.COUNT + 1) := 0;
			v_DX_LOSS(v_DX_LOSS.COUNT + 1) := 0;
			v_UE_LOSS(v_UE_LOSS.COUNT + 1) := 0;
			IF p_CAST(v_INDEX) = 0 THEN
				v_SERVICE_STATE.PROFILE_ZERO_COUNT := v_SERVICE_STATE.PROFILE_ZERO_COUNT + 1;
			END IF;
			v_INDEX := p_CAST.NEXT(v_INDEX);
		END LOOP;

		IF p_APPLY_TD_LOSSES = 1 THEN
			v_SERVICE := CS.GET_SERVICE(v_SERVICE_STATE.SERVICE_ID);
			v_PROVIDER_SERVICE := CS.GET_PROVIDER_SERVICE(v_SERVICE.PROVIDER_SERVICE_ID);
			FS.APPLY_LOSS_FACTORS(v_SERVICE.ACCOUNT_SERVICE_ID, v_PROVIDER_SERVICE.EDC_ID, TRUNC(p_SERVICE_DATE), v_LOAD_VAL, v_TX_LOSS, v_DX_LOSS, v_UE_LOSS, TRUE);
		END IF;

		SELECT DECODE(p_APPLY_TO_INTERNAL, 1, GA.STANDARD, GA.EXTERNAL) INTO v_LOAD_CODE FROM DUAL;

		STORE_SERVICE_LOAD(v_SERVICE.SERVICE_ID, p_REQUEST_TYPE, v_LOAD_CODE, v_LOAD_DATE, v_LOAD_VAL, v_TX_LOSS, v_DX_LOSS, v_UE_LOSS);

	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('ACCEPT_EXTERNAL_CAST END AT ' || TEXT_UTIL.TO_CHAR_DATE(SYSDATE));
		LOGS.LOG_DEBUG('ELAPSED TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED));
	END IF;


END ACCEPT_EXTERNAL_CAST;
----------------------------------------------------------------------------------------------------
PROCEDURE CREATE_LONG_TERM_PROFILES
	(
	p_MODEL_ID IN NUMBER,
	p_RUN_MODE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_TRACE_ON BOOLEAN DEFAULT FALSE
	) AS

v_CAST_CONTEXT CAST_CONTEXT_TYPE := NEW_CAST_CONTEXT;
v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

	v_CAST_CONTEXT.RUN_MODE := GA.HOUR_MODE;
	v_CAST_CONTEXT.REQUEST_TYPE := 'X';
	v_CAST_CONTEXT.WEATHER_PARAMETER_CODE := 'F';
	v_CAST_CONTEXT.WEATHER_CASE_ID := GA.BASE_CASE_ID;
	v_CAST_CONTEXT.DAY_TYPE := g_ANY_DAY;
	v_CAST_CONTEXT.MODEL_ID := p_MODEL_ID;

	IF p_RUN_MODE = GA.WEEK_MODE THEN
		v_BEGIN_DATE := TRUNC(p_BEGIN_DATE, 'DAY');
		v_END_DATE := TRUNC(p_END_DATE, 'DAY') + 6;
	ELSIF p_RUN_MODE = GA.MONTH_MODE THEN
		v_BEGIN_DATE := TRUNC(p_BEGIN_DATE, 'MONTH');
		v_END_DATE := LAST_DAY(TRUNC(p_END_DATE, 'MONTH'));
	ELSE
		v_BEGIN_DATE := TRUNC(p_BEGIN_DATE);
		v_END_DATE := TRUNC(p_END_DATE);
	END IF;

	v_CAST_CONTEXT.OUTPUT_AS_OF_DATE := LOW_DATE;
	v_CAST_CONTEXT.BEGIN_DATE := v_BEGIN_DATE;
	v_CAST_CONTEXT.END_DATE := v_END_DATE;
	v_CAST_CONTEXT.PROFILE_BEGIN_DATE := v_BEGIN_DATE;
	v_CAST_CONTEXT.PROFILE_AS_OF_DATE := CORRECTED_AS_OF_DATE(SYSDATE,'Profiling');
	v_CAST_CONTEXT.SERVICE_DATE := v_CAST_CONTEXT.BEGIN_DATE;
	v_CAST_CONTEXT.PROFILE_DATE := v_CAST_CONTEXT.PROFILE_BEGIN_DATE;

	IF p_TRACE_ON THEN
		v_CAST_CONTEXT.TRACE_ON := 1;
		v_CAST_CONTEXT.DETAIL_TRACE_ON := 1;
	ELSE
		v_CAST_CONTEXT.TRACE_ON := CONSTANTS.NOT_ASSIGNED;
		v_CAST_CONTEXT.DETAIL_TRACE_ON := CONSTANTS.NOT_ASSIGNED;
	END IF;

	FL.CREATE_LONG_TERM_PROFILES(v_CAST_CONTEXT, p_RUN_MODE, p_TIME_ZONE, p_STATUS);

END CREATE_LONG_TERM_PROFILES;
----------------------------------------------------------------------------------------------------
PROCEDURE ALLOCATE_SERVICE_OBL_UFE
	(
	p_EDC_IDs IN NUMBER_COLLECTION,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SERVICE_CODE IN VARCHAR2
	) AS

	v_BEGIN_DATE DATE;
	v_END_DATE DATE;

	v_SYS_IDS NUMBER_COLLECTION;

BEGIN

	UT.CUT_DATE_RANGE(CONSTANTS.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE,
		v_BEGIN_DATE, v_END_DATE);

	-- which systems are we dealing with?
	SELECT DISTINCT EDC.EDC_SYSTEM_LOAD_ID
	BULK COLLECT INTO v_SYS_IDS
	FROM ENERGY_DISTRIBUTION_COMPANY EDC,
		TABLE(CAST(p_EDC_IDs AS NUMBER_COLLECTION)) IDS
	WHERE EDC.EDC_ID = IDS.COLUMN_VALUE;

	MERGE INTO SERVICE_OBLIGATION_LOAD OBL_LOAD
		-- WE ONLY UPDATE SERVICE_OBLIGATION_LOAD for those EDCs passed into the procedure, but we still
		-- calculate using all EDCs which belong to the system load
	USING(SELECT CASE WHEN x.COLUMN_VALUE IS NOT NULL
					THEN SO.SERVICE_OBLIGATION_ID ELSE NULL
					END AS SERVICE_OBLIGATION_ID,
			SLO.LOAD_DATE,
			SLO.LOAD_CODE,
			SLO.LOAD_VAL + SLO.TX_LOSS_VAL + SLO.DX_LOSS_VAL AS LOAD,
			SUM(NVL(SLO.LOAD_VAL,0) + NVL(SLO.TX_LOSS_VAL,0) + NVL(SLO.DX_LOSS_VAL,0))
				OVER (PARTITION BY SL.SYSTEM_LOAD_ID, SLO.LOAD_DATE, SLO.LOAD_CODE) AS TOTAL_LOAD,
			SL.SYSTEM_LOAD
		FROM (SELECT S.SYSTEM_LOAD_ID,
						AL.LOAD_DATE,
						SUM(NVL(AL.LOAD_VAL,0) * DECODE(SLA.OPERATION_CODE, 'A', 1, 'S', -1, 1)) AS SYSTEM_LOAD
				FROM AREA_LOAD AL,
					SYSTEM_LOAD S,
					SYSTEM_LOAD_AREA SLA,
					TABLE(CAST(v_SYS_IDS AS NUMBER_COLLECTION)) IDS
				WHERE SLA.SYSTEM_LOAD_ID = S.SYSTEM_LOAD_ID
					AND AL.AREA_ID = SLA.AREA_ID
					AND AL.CASE_ID = GA.BASE_CASE_ID
					AND AL.LOAD_CODE = DECODE(p_SERVICE_CODE, 'F', 'F', 'B', 'F', 'A', 'A', 'F')
					AND AL.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
					AND S.SYSTEM_LOAD_ID = IDS.COLUMN_VALUE
				GROUP BY S.SYSTEM_LOAD_ID,
					AL.LOAD_DATE) SL,
			ENERGY_DISTRIBUTION_COMPANY EDC,
			PROVIDER_SERVICE PS,
			SERVICE_OBLIGATION SO,
			SERVICE_OBLIGATION_LOAD SLO,
			TABLE(CAST(p_EDC_IDs AS NUMBER_COLLECTION)) x
		WHERE EDC.EDC_SYSTEM_LOAD_ID = SL.SYSTEM_LOAD_ID
				-- include all EDCs which belong to these system loads
			AND x.COLUMN_VALUE (+) = EDC.EDC_ID
				-- x is used as a signal as to whether the EDC was selected for the data exchange
			AND PS.EDC_ID = EDC.EDC_ID
			AND SO.PROVIDER_SERVICE_ID = PS.PROVIDER_SERVICE_ID
			AND SO.MODEL_ID = CONSTANTS.ELECTRIC_MODEL
			AND SO.SCENARIO_ID = GA.BASE_SCENARIO_ID
			AND SL.SYSTEM_LOAD_ID = EDC.EDC_SYSTEM_LOAD_ID
			AND SLO.SERVICE_OBLIGATION_ID = SO.SERVICE_OBLIGATION_ID
			AND SLO.SERVICE_CODE = p_SERVICE_CODE
			AND SLO.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND SL.LOAD_DATE = SLO.LOAD_DATE) LOAD
		ON (OBL_LOAD.SERVICE_OBLIGATION_ID = LOAD.SERVICE_OBLIGATION_ID
			AND OBL_LOAD.SERVICE_CODE = p_SERVICE_CODE
			AND OBL_LOAD.LOAD_DATE = LOAD.LOAD_DATE
			AND OBL_LOAD.LOAD_CODE = LOAD.LOAD_CODE)
		WHEN MATCHED THEN
			UPDATE SET OBL_LOAD.UFE_LOAD_VAL = CASE WHEN LOAD.TOTAL_LOAD = 0 THEN 0
													ELSE ((LOAD.SYSTEM_LOAD - LOAD.TOTAL_LOAD) *
														(LOAD.LOAD / LOAD.TOTAL_LOAD)) END;


END ALLOCATE_SERVICE_OBL_UFE;
----------------------------------------------------------------------------------------------------
PROCEDURE AGGREGATE_ANC_SVC
(
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2
) AS
	v_CUT_BEGIN_DATE DATE;
	v_CUT_END_DATE DATE;
	v_CAST_CONTEXT CAST_CONTEXT_TYPE := FS.NEW_CAST_CONTEXT;
	v_SERVICE_MODEL SERVICE_MODEL_TABLE := SERVICE_MODEL_TABLE();
	v_INDEX BINARY_INTEGER;
	v_ACCOUNT_SERVICE_ID ACCOUNT_SERVICE.ACCOUNT_SERVICE_ID%TYPE;
	v_PROVIDER_SERVICE_ID PROVIDER_SERVICE.PROVIDER_SERVICE_ID%TYPE;
	v_SERVICE_DELIVERY_ID SERVICE_DELIVERY.SERVICE_DELIVERY_ID%TYPE;
	v_SERVICE_OBLIGATION_ID SERVICE_OBLIGATION.SERVICE_DELIVERY_ID%TYPE;
	v_SCHEDULE_GROUP_ID SCHEDULE_GROUP.SCHEDULE_GROUP_ID%TYPE;
	v_SERVICE_IDS ID_TABLE := ID_TABLE();
	v_FINISH_MESSAGE PROCESS_LOG.PROCESS_FINISH_TEXT%TYPE;
	v_ANC_SVC_UNIT ANCILLARY_SERVICE.ANCILLARY_SERVICE_UNIT%TYPE;
	v_COMMODITY_UNIT IT_COMMODITY.COMMODITY_UNIT%TYPE;
	v_STATUS NUMBER(9);

BEGIN
	LOGS.START_PROCESS('Aggregate Ancillary Service');

	LOGS.SET_PROCESS_TARGET_PARAMETER('ANCILLARY_SERVICE_ID', TEXT_UTIL.TO_CHAR_ENTITY(p_ANCILLARY_SERVICE_ID, EC.ED_ANCILLARY_SERVICE, TRUE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('BEGIN_DATE', TEXT_UTIL.TO_CHAR_TIME(p_BEGIN_DATE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('END_DATE', TEXT_UTIL.TO_CHAR_TIME(p_END_DATE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('TIME_ZONE', p_TIME_ZONE);

	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, p_BEGIN_DATE, p_END_DATE);

	UT.CUT_DATE_RANGE(GA.DEFAULT_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE,
		v_CUT_BEGIN_DATE, v_CUT_END_DATE);

	-- Intialize the cast context
	INITIALIZE_CAST_CONTEXT
			(NULL, -- p_REQUEST_TYPE,
			 GA.ANCILLARY_SERVICE_MODE, -- p_REQUEST_MODE,
			 GA.BASE_SCENARIO_ID,
			 GA.DEFAULT_MODEL,
			 -1, -- p_EDC_ID,
			 -1, -- p_ESP_ID,
			 -1, -- p_ACCOUNT_ID,
			 p_BEGIN_DATE,
			 p_END_DATE,
			 CONSTANTS.LOW_DATE, -- p_INPUT_AS_OF_DATE,
			 CONSTANTS.LOW_DATE, -- p_OUTPUT_AS_OF_DATE,
			 NULL, -- p_PROFILE_BEGIN_DATE,
			 NULL, -- p_PROFILE_AS_OF_DATE,
			 0, -- p_APPLY_USAGE_FACTOR,
			 0, -- p_APPLY_UFE,
			 0, -- p_APPLY_UFE_OTHER,
			 0, -- p_APPLY_EXTERNAL_FORECAST,
			 NULL, -- p_REQUESTOR,
			 0, -- p_TRACE_ON,
			 v_CAST_CONTEXT);

	-- Delete records from the SERVICE_OBLIGATION_ANC_SVC table
	DELETE_SVC_OBLIGATION_ANC_SVC(v_CAST_CONTEXT, p_ANCILLARY_SERVICE_ID);

	-- Select All Aggregate, Account, and Meter Model Accounts active over the Begin and End time period.
	CX.SELECT_SERVICE_MODEL(v_CAST_CONTEXT, v_SERVICE_MODEL);

	-- Synchronize the Account Service and Provider Service Relationships to the Service Model.
	CX.SYNC_SERVICE_MODEL(v_SERVICE_MODEL, v_CAST_CONTEXT.DETAIL_TRACE_ON = g_ON);

	CX.INITIALIZE_CACHE(v_CAST_CONTEXT);

	v_INDEX := v_SERVICE_MODEL.FIRST;
	WHILE v_INDEX <= v_SERVICE_MODEL.LAST LOOP
		v_ACCOUNT_SERVICE_ID := v_SERVICE_MODEL(v_INDEX).ACCOUNT_SERVICE_ID;
		v_PROVIDER_SERVICE_ID := v_SERVICE_MODEL(v_INDEX).PROVIDER_SERVICE_ID;
		-- Get Schedule Group
		v_SCHEDULE_GROUP_ID := CX.GET_SCHEDULE_GROUP_ID(v_ACCOUNT_SERVICE_ID, v_CAST_CONTEXT.SERVICE_DATE);

		-- Get Service Delivery
		v_SERVICE_DELIVERY_ID := CX.GET_SERVICE_DELIVERY_ID(v_SERVICE_MODEL(v_INDEX).POOL_ID,
																v_SERVICE_MODEL(v_INDEX).SERVICE_POINT_ID,
																CX.GET_SERVICE_ZONE_ID(v_SERVICE_MODEL(v_INDEX).SERVICE_LOCATION_ID, v_SCHEDULE_GROUP_ID),
																v_SCHEDULE_GROUP_ID,
																CX.GET_SCHEDULE_COORDINATOR_ID(v_SERVICE_MODEL(v_INDEX).EDC_ID, v_SCHEDULE_GROUP_ID),
																CX.GET_ESP_SUPPLY_TYPE(v_SERVICE_MODEL(v_INDEX).ESP_ID),
																CX.GET_PSE_IS_BUG(v_SERVICE_MODEL(v_INDEX).PSE_ID),
																v_SERVICE_MODEL(v_INDEX).IS_WHOLESALE,
																CX.GET_IS_AGGREGATE_POOL(v_SERVICE_MODEL(v_INDEX).POOL_ID));

		-- Save the Service IDs
		v_SERVICE_IDS.EXTEND();
		v_SERVICE_IDS(v_SERVICE_IDS.LAST) := ID_TYPE(CX.GET_SERVICE_ID(v_CAST_CONTEXT, v_PROVIDER_SERVICE_ID, v_ACCOUNT_SERVICE_ID, v_SERVICE_DELIVERY_ID));


		v_SERVICE_OBLIGATION_ID := CX.GET_SERVICE_OBLIGATION_ID(v_CAST_CONTEXT, v_PROVIDER_SERVICE_ID, v_SERVICE_DELIVERY_ID);

		v_INDEX := v_SERVICE_MODEL.NEXT(v_INDEX);
	END LOOP;

	-- Get the Ancillary Service Unit and IT Commodity Unit
	SELECT ASRV.ANCILLARY_SERVICE_UNIT, C.COMMODITY_UNIT
	INTO v_ANC_SVC_UNIT, v_COMMODITY_UNIT
	FROM ANCILLARY_SERVICE ASRV, IT_COMMODITY C
	WHERE ASRV.ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID
		AND C.COMMODITY_ID(+) = ASRV.IT_COMMODITY_ID;

	-- Populate the Service Load Obligation Anc Srv
	INSERT INTO SERVICE_OBLIGATION_ANC_SVC
	SELECT SERVICE_OBLIGATION_ID,
		p_ANCILLARY_SERVICE_ID AS ANCILLARY_SERVICE_ID,
		CUT_DATE,
		SUM(UT.CONVERT_UNIT_OF_MEASURE(v_ANC_SVC_UNIT, SERVICE_VAL, v_COMMODITY_UNIT)) AS SERVICE_VAL
	FROM
		(-- All Accounts except aggregate
		SELECT DISTINCT ASVC.ACCOUNT_ID AS ID,
			SO.SERVICE_OBLIGATION_ID,
			SDT.CUT_DATE,
			CASE WHEN SDT.CUT_DATE BETWEEN AAS.BEGIN_DATE AND NVL(AAS.END_DATE, CONSTANTS.HIGH_DATE) THEN AAS.SERVICE_VAL ELSE 0 END SERVICE_VAL
		FROM TABLE(CAST(v_SERVICE_IDS AS ID_TABLE)) X,
			SERVICE SVC,
			SERVICE_OBLIGATION SO,
			PROVIDER_SERVICE PS,
			ENERGY_DISTRIBUTION_COMPANY EDC,
			ENERGY_SERVICE_PROVIDER ESP,
			PURCHASING_SELLING_ENTITY PSE,
			ACCOUNT_SERVICE ASVC,
			ACCOUNT_ANCILLARY_SERVICE AAS,
			SYSTEM_DATE_TIME SDT
		WHERE X.ID = SVC.SERVICE_ID
			AND SO.MODEL_ID = SVC.MODEL_ID
			AND SO.SCENARIO_ID = SVC.SCENARIO_ID
			AND SO.AS_OF_DATE = CONSTANTS.LOW_DATE
			AND SO.PROVIDER_SERVICE_ID = SVC.PROVIDER_SERVICE_ID
			AND SO.SERVICE_DELIVERY_ID = SVC.SERVICE_DELIVERY_ID
			AND PS.PROVIDER_SERVICE_ID = SVC.PROVIDER_SERVICE_ID
			AND EDC.EDC_ID = PS.EDC_ID
			AND UPPER(SUBSTR(EDC.EDC_STATUS,1,1)) = 'A'
			AND ESP.ESP_ID = PS.ESP_ID
			AND UPPER(SUBSTR(ESP.ESP_STATUS,1,1)) = 'A'
			AND PSE.PSE_ID = PS.PSE_ID
			AND UPPER(SUBSTR(PSE.PSE_STATUS,1,1)) = 'A'
			AND ASVC.ACCOUNT_SERVICE_ID = SVC.ACCOUNT_SERVICE_ID
			AND AAS.ACCOUNT_ID = ASVC.ACCOUNT_ID
			AND ASVC.AGGREGATE_ID = 0
			AND AAS.BEGIN_DATE <= p_END_DATE
			AND NVL(AAS.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND AAS.ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID
			AND SDT.TIME_ZONE = p_TIME_ZONE
			AND SDT.DATA_INTERVAL_TYPE = 1
			AND SDT.DAY_TYPE = '1'
			AND SDT.MINIMUM_INTERVAL_NUMBER >= GET_INTERVAL_NUMBER('DD')
			AND SDT.CUT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
		-- Meters
		UNION ALL
		SELECT ASVC.METER_ID AS ID,
			SO.SERVICE_OBLIGATION_ID,
			SDT.CUT_DATE,
			CASE WHEN SDT.CUT_DATE BETWEEN MAS.BEGIN_DATE AND NVL(MAS.END_DATE, CONSTANTS.HIGH_DATE) THEN MAS.SERVICE_VAL ELSE 0 END SERVICE_VAL
		FROM TABLE(CAST(v_SERVICE_IDS AS ID_TABLE)) X,
			SERVICE SVC,
			SERVICE_OBLIGATION SO,
			PROVIDER_SERVICE PS,
			ENERGY_DISTRIBUTION_COMPANY EDC,
			ENERGY_SERVICE_PROVIDER ESP,
			PURCHASING_SELLING_ENTITY PSE,
			ACCOUNT_SERVICE ASVC,
			METER_ANCILLARY_SERVICE MAS,
			SYSTEM_DATE_TIME SDT
		WHERE X.ID = SVC.SERVICE_ID
			AND SO.MODEL_ID = SVC.MODEL_ID
			AND SO.SCENARIO_ID = SVC.SCENARIO_ID
			AND SO.AS_OF_DATE = CONSTANTS.LOW_DATE
			AND SO.PROVIDER_SERVICE_ID = SVC.PROVIDER_SERVICE_ID
			AND SO.SERVICE_DELIVERY_ID = SVC.SERVICE_DELIVERY_ID
			AND PS.PROVIDER_SERVICE_ID = SVC.PROVIDER_SERVICE_ID
			AND EDC.EDC_ID = PS.EDC_ID
			AND UPPER(SUBSTR(EDC.EDC_STATUS,1,1)) = 'A'
			AND ESP.ESP_ID = PS.ESP_ID
			AND UPPER(SUBSTR(ESP.ESP_STATUS,1,1)) = 'A'
			AND PSE.PSE_ID = PS.PSE_ID
			AND UPPER(SUBSTR(PSE.PSE_STATUS,1,1)) = 'A'
			AND ASVC.ACCOUNT_SERVICE_ID = SVC.ACCOUNT_SERVICE_ID
			AND MAS.METER_ID = ASVC.METER_ID
			AND ASVC.METER_ID <> 0
			AND MAS.BEGIN_DATE <= p_END_DATE
			AND NVL(MAS.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND MAS.ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID
			AND SDT.TIME_ZONE = p_TIME_ZONE
			AND SDT.DATA_INTERVAL_TYPE = 1
			AND SDT.DAY_TYPE = '1'
			AND SDT.MINIMUM_INTERVAL_NUMBER >= GET_INTERVAL_NUMBER('DD')
			AND SDT.CUT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
		UNION ALL
		-- Aggregate Accounts
		SELECT ASVC.AGGREGATE_ID AS ID,
			SO.SERVICE_OBLIGATION_ID,
			SDT.CUT_DATE,
			CASE WHEN SDT.CUT_DATE = AGGAS.SERVICE_DATE THEN AGGAS.SERVICE_VAL ELSE 0 END SERVICE_VAL
		FROM TABLE(CAST(v_SERVICE_IDS AS ID_TABLE)) X,
			SERVICE SVC,
			SERVICE_OBLIGATION SO,
			PROVIDER_SERVICE PS,
			ENERGY_DISTRIBUTION_COMPANY EDC,
			ENERGY_SERVICE_PROVIDER ESP,
			PURCHASING_SELLING_ENTITY PSE,
			ACCOUNT_SERVICE ASVC,
			AGGREGATE_ANCILLARY_SERVICE AGGAS,
			SYSTEM_DATE_TIME SDT
		WHERE X.ID = SVC.SERVICE_ID
			AND SO.MODEL_ID = SVC.MODEL_ID
			AND SO.SCENARIO_ID = SVC.SCENARIO_ID
			AND SO.AS_OF_DATE = CONSTANTS.LOW_DATE
			AND SO.PROVIDER_SERVICE_ID = SVC.PROVIDER_SERVICE_ID
			AND SO.SERVICE_DELIVERY_ID = SVC.SERVICE_DELIVERY_ID
			AND PS.PROVIDER_SERVICE_ID = SVC.PROVIDER_SERVICE_ID
			AND EDC.EDC_ID = PS.EDC_ID
			AND UPPER(SUBSTR(EDC.EDC_STATUS,1,1)) = 'A'
			AND ESP.ESP_ID = PS.ESP_ID
			AND UPPER(SUBSTR(ESP.ESP_STATUS,1,1)) = 'A'
			AND PSE.PSE_ID = PS.PSE_ID
			AND UPPER(SUBSTR(PSE.PSE_STATUS,1,1)) = 'A'
			AND ASVC.ACCOUNT_SERVICE_ID = SVC.ACCOUNT_SERVICE_ID
			AND AGGAS.AGGREGATE_ID = ASVC.AGGREGATE_ID
			AND ASVC.AGGREGATE_ID <> 0
			AND AGGAS.SERVICE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
			AND AGGAS.ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID
			AND SDT.TIME_ZONE = p_TIME_ZONE
			AND SDT.DATA_INTERVAL_TYPE = 1
			AND SDT.DAY_TYPE = '1'
			AND SDT.MINIMUM_INTERVAL_NUMBER >= GET_INTERVAL_NUMBER('DD')
			AND SDT.CUT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE) VAL
		GROUP BY SERVICE_OBLIGATION_ID, p_ANCILLARY_SERVICE_ID, CUT_DATE;

	LOGS.STOP_PROCESS(v_FINISH_MESSAGE,v_STATUS);
EXCEPTION
	WHEN OTHERS THEN
		ERRS.ABORT_PROCESS();
END AGGREGATE_ANC_SVC;
----------------------------------------------------------------------------------------------------
PROCEDURE ENSURE_SERVICE_DETAILS
	(
	p_REQUEST_TYPE IN CHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER_COLLECTION,
	p_CUT_BEGIN IN DATE,
	p_CUT_END IN DATE,
	p_AS_OF_DATE IN DATE
	) AS

	v_BEGIN DATE;
	v_LAST DATE;
	v_PROCESS_ID NUMBER(9);

	v_STATUS NUMBER(9);
	v_MESSAGE VARCHAR2(2000);

BEGIN
    $if $$UNIT_TEST_MODE = 1 $THEN
        IF UNIT_TEST_UTIL.g_CURRENT_TEST_PROCEDURE IN ('TEST_LOAD_MANAGEMENT_UI.T_GET_LD_DTL_ENS_SRV_DTL',
                                                        'TEST_LOAD_MANAGEMENT_UI.T_LD_DTL_ATTB_SUB_ENS_DTL') THEN
            INSERT INTO RTO_WORK(WORK_DATA)
            SELECT 'REQUEST_TYPE=' || p_REQUEST_TYPE || ',' ||
                'MODEL_ID=' || TO_CHAR(p_MODEL_ID) || ',' ||
                'SCENARIO_ID=' || TO_CHAR(p_SCENARIO_ID) || ',' ||
                'EDC_ID=' || TEXT_UTIL.TO_CHAR_ENTITY(p_EDC_ID, EC.ED_EDC) || ',' ||
                'ESP_ID=' || TEXT_UTIL.TO_CHAR_ENTITY(p_ESP_ID, EC.ED_ESP) || ',' ||
                'ACCOUNT_ID=' || TEXT_UTIL.TO_CHAR_ENTITY_LIST(p_ACCOUNT_ID, EC.ED_ACCOUNT) || ',' ||
	            'BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_CUT_BEGIN) || ',' ||
                'END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_CUT_END) || ',' ||
                'AS_OF_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_AS_OF_DATE)
            FROM DUAL;
            RETURN;
        END IF;
    $end

	IF p_ACCOUNT_ID IS NULL OR p_ACCOUNT_ID.COUNT = 0 THEN
		RETURN;
	END IF;

	FOR v_IDX IN p_ACCOUNT_ID.FIRST .. p_ACCOUNT_ID.LAST LOOP
		v_LAST := NULL;
		v_BEGIN := NULL;

		FOR v_REC IN (SELECT STATE.SERVICE_DATE
						FROM SERVICE_STATE STATE,
							ACCOUNT_SERVICE ACCT,
							SERVICE S,
							PROVIDER_SERVICE PS
						WHERE S.MODEL_ID = p_MODEL_ID
							AND S.SCENARIO_ID = p_SCENARIO_ID
							AND S.AS_OF_DATE = p_AS_OF_DATE
							AND ACCT.ACCOUNT_ID = p_ACCOUNT_ID(v_IDX)
							AND (PS.EDC_ID = p_EDC_ID OR p_EDC_ID = CONSTANTS.ALL_ID)
							AND (PS.ESP_ID = p_ESP_ID OR p_ESP_ID = CONSTANTS.ALL_ID)
							AND S.ACCOUNT_SERVICE_ID = ACCT.ACCOUNT_SERVICE_ID
							AND S.PROVIDER_SERVICE_ID = PS.PROVIDER_SERVICE_ID
							AND STATE.SERVICE_ID = S.SERVICE_ID
							AND STATE.SERVICE_CODE = p_REQUEST_TYPE
							AND STATE.HAS_DETAILS = 0
							AND STATE.SERVICE_DATE BETWEEN TRUNC(FROM_CUT(p_CUT_BEGIN, GA.LOCAL_TIME_ZONE))
											AND TRUNC(FROM_CUT(p_CUT_END, GA.LOCAL_TIME_ZONE))
						ORDER BY STATE.SERVICE_DATE ASC) LOOP

			IF v_LAST IS NOT NULL AND v_REC.SERVICE_DATE > v_LAST + 1 THEN
				FS.CAST_SERVICE_REQUEST(p_REQUEST_TYPE,
										GA.STANDARD_MODE,
										p_SCENARIO_ID,
										p_MODEL_ID,
										LOGS.CURRENT_PROCESS_ID,
										p_EDC_ID,
										p_ESP_ID,
										p_ACCOUNT_ID(v_IDX),
										v_BEGIN,
										v_LAST,
										CONSTANTS.HIGH_DATE,
										p_AS_OF_DATE,
										v_BEGIN,
										CONSTANTS.HIGH_DATE,
										1,
										0,
										0,
										0,
										SECURITY_CONTROLS.CURRENT_USER || '@' || SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA'),
										0,
										v_STATUS,
										v_MESSAGE);

				IF v_STATUS <> GA.SUCCESS AND v_MESSAGE IS NOT NULL THEN
					v_MESSAGE := SUBSTR(
									CASE WHEN v_STATUS = LOGS.c_LEVEL_FATAL THEN
											'The child Forecast process aborted.'
										 WHEN v_STATUS >= LOGS.c_LEVEL_ERROR THEN
											'The child Forecast process encountered errors.'
										 WHEN v_STATUS >= LOGS.c_LEVEL_WARN THEN
											'The child Forecast process encountered warnings.'
										 WHEN v_STATUS >= LOGS.c_LEVEL_NOTICE THEN
											'The child Forecast process encountered notices.'
										 ELSE
											'The child Forecast process completed successfully.'
										 END,
									1, 4000);
					LOGS.LOG_EVENT(v_STATUS, v_MESSAGE);
				END IF;

				v_LAST := NULL;
				v_BEGIN := NULL;
			END IF;

			IF v_BEGIN IS NULL THEN
				v_BEGIN := v_REC.SERVICE_DATE;
			END IF;

			v_LAST := v_REC.SERVICE_DATE;

		END LOOP;

		-- MAKE SURE WE HAVE AT LEAST ONE SERVICE_STATE RECORD
		IF v_BEGIN IS NOT NULL AND v_LAST IS NOT NULL THEN

			FS.CAST_SERVICE_REQUEST(p_REQUEST_TYPE,
									GA.STANDARD_MODE,
									p_SCENARIO_ID,
									p_MODEL_ID,
									LOGS.CURRENT_PROCESS_ID,
									p_EDC_ID,
									p_ESP_ID,
									p_ACCOUNT_ID(v_IDX),
									v_BEGIN,
									v_LAST,
									CONSTANTS.HIGH_DATE,
									p_AS_OF_DATE,
									v_BEGIN,
									CONSTANTS.HIGH_DATE,
									1,
									0,
									0,
									0,
									SECURITY_CONTROLS.CURRENT_USER || '@' || SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA'),
									0,
									v_STATUS,
									v_MESSAGE);

			IF v_STATUS <> GA.SUCCESS AND v_MESSAGE IS NOT NULL THEN
				v_MESSAGE := SUBSTR(
								CASE WHEN v_STATUS = LOGS.c_LEVEL_FATAL THEN
										'The child Forecast process aborted.'
									 WHEN v_STATUS >= LOGS.c_LEVEL_ERROR THEN
										'The child Forecast process encountered errors.'
									 WHEN v_STATUS >= LOGS.c_LEVEL_WARN THEN
										'The child Forecast process encountered warnings.'
									 WHEN v_STATUS >= LOGS.c_LEVEL_NOTICE THEN
										'The child Forecast process encountered notices.'
									 ELSE
										'The child Forecast process completed successfully.'
									 END,
								1, 4000);
				LOGS.LOG_EVENT(v_STATUS, v_MESSAGE);
			END IF;

		END IF;

	END LOOP;

END ENSURE_SERVICE_DETAILS;
----------------------------------------------------------------------------------------------------
PROCEDURE REAPPLY_LOSS_FACTORS
	(
	p_BEGIN_DATE     IN  DATE,
	p_END_DATE       IN  DATE,
   p_TRACE_ON       IN  NUMBER,
   p_MESSAGE        OUT VARCHAR2,
   p_PROCESS_ID     OUT VARCHAR2,
   p_PROCESS_STATUS OUT NUMBER
	) IS
   c_PROCEDURE_NAME CONSTANT VARCHAR(30) := 'REAPPLY_LOSS_FACTORS';
   c_ELECTRIC_MODEL CONSTANT NUMBER(1) := CONSTANTS.ELECTRIC_MODEL;
   c_GAS_MODEL      CONSTANT NUMBER(1) := CONSTANTS.GAS_MODEL;
   v_ACCOUNT_CNT             NUMBER := 0;
   v_LOAD_DATE               GA.DATE_TABLE;
   v_LOAD_VAL                GA.FLOAT_TABLE;
   v_TX_LOSS_VAL             GA.FACTOR_TABLE;
   v_DX_LOSS_VAL             GA.FACTOR_TABLE;
   v_UE_LOSS_VAL             GA.FACTOR_TABLE;
   v_BEGIN_DATE              DATE := p_BEGIN_DATE;
   v_END_DATE                DATE := p_END_DATE;
   v_CUT_BEGIN_DATE          DATE := NULL;
   v_CUT_END_DATE            DATE := NULL;
   v_ACCOUNT_NAME            ACCOUNT.ACCOUNT_NAME%TYPE := NULL;
   v_FAULT_CACHE             BOOLEAN := TRUE;

BEGIN
  	-- Set the Transaction SETPOINT
	SAVEPOINT SP_REAPPLY_LOSS_FACTORS;

   LOGS.START_PROCESS(p_PROCESS_NAME => 'Calculate Loss Factors from Service Load',p_TRACE_ON => p_TRACE_ON);
   p_PROCESS_ID := LOGS.CURRENT_PROCESS_ID;

   UT.CUT_DATE_RANGE(p_MODEL_ID       => c_ELECTRIC_MODEL,
                     p_BEGIN_DATE     => v_BEGIN_DATE,
                     p_END_DATE       => v_END_DATE,
                     p_TIME_ZONE      => LOCAL_TIME_ZONE,
                     p_CUT_BEGIN_DATE => v_CUT_BEGIN_DATE,
                     p_CUT_END_DATE   => v_CUT_END_DATE);

   LOGS.LOG_DEBUG(gc_PACKAGE_NAME||'.'||c_PROCEDURE_NAME);
   LOGS.LOG_DEBUG('START: Calculate Loss Factors from Service Load...');
   LOGS.LOG_DEBUG('p_BEGIN_DATE = '||TO_CHAR(p_BEGIN_DATE, 'YYYY-MM-DD HH24:MI'));
   LOGS.LOG_DEBUG('p_END_DATE = '||TO_CHAR(p_END_DATE, 'YYYY-MM-DD HH24:MI'));
   LOGS.LOG_DEBUG('v_CUT_BEGIN_DATE = '||TO_CHAR(v_CUT_BEGIN_DATE, 'YYYY-MM-DD HH24:MI'));
   LOGS.LOG_DEBUG('v_CUT_END_DATE = '||TO_CHAR(v_CUT_END_DATE, 'YYYY-MM-DD HH24:MI'));

   SELECT COUNT(*) INTO v_ACCOUNT_CNT
     FROM (SELECT DISTINCT
                  S.ACCOUNT_SERVICE_ID AS ACCOUNT_SERVICE_ID,
                  EDC.EDC_ID           AS EDC_ID,
                  SL.SERVICE_ID        AS SERVICE_ID,
                  SL.SERVICE_CODE      AS SERVICE_CODE,
                  (CASE
                       WHEN S.MODEL_ID = c_ELECTRIC_MODEL THEN v_CUT_BEGIN_DATE
                       WHEN S.MODEL_ID = c_GAS_MODEL      THEN v_BEGIN_DATE
                       ELSE v_BEGIN_DATE
                   END)                AS BEGIN_SERVICE_DATE,
                  (CASE
                       WHEN S.MODEL_ID = c_ELECTRIC_MODEL THEN v_CUT_END_DATE
                       WHEN S.MODEL_ID = c_GAS_MODEL      THEN v_END_DATE
                       ELSE v_END_DATE
                   END)                AS END_SERVICE_DATE,
                  SL.LOAD_CODE         AS LOAD_CODE
             FROM SERVICE         S,
                  ACCOUNT_SERVICE ACT,
                  ACCOUNT_EDC     EDC,
                  SERVICE_LOAD    SL
            WHERE ACT.ACCOUNT_SERVICE_ID  = S.ACCOUNT_SERVICE_ID
              AND EDC.ACCOUNT_ID  = ACT.ACCOUNT_ID
              AND SL.SERVICE_ID   = S.SERVICE_ID
              AND SL.SERVICE_CODE = 'A'
              AND ((S.MODEL_ID = c_ELECTRIC_MODEL AND SL.LOAD_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE)
                    OR
                   (S.MODEL_ID = c_GAS_MODEL AND SL.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE))
              AND SL.LOAD_CODE    = 1) TBL;

   LOGS.INIT_PROCESS_PROGRESS(p_TOTAL_WORK => v_ACCOUNT_CNT);
   LOGS.LOG_DEBUG('v_ACCOUNT_CNT = '||TO_CHAR(v_ACCOUNT_CNT));

   -- Only process further if records exist.
   IF v_ACCOUNT_CNT >= 1 THEN
      FOR c_ACT_SRV IN (SELECT DISTINCT
                               S.ACCOUNT_SERVICE_ID AS ACCOUNT_SERVICE_ID,
                               ACT.ACCOUNT_ID       AS ACCOUNT_ID,
                               EDC.EDC_ID           AS EDC_ID,
                               SL.SERVICE_ID        AS SERVICE_ID,
                               SL.SERVICE_CODE      AS SERVICE_CODE,
                               (CASE
                                   WHEN S.MODEL_ID = c_ELECTRIC_MODEL THEN v_CUT_BEGIN_DATE
                                   WHEN S.MODEL_ID = c_GAS_MODEL      THEN v_BEGIN_DATE
                                   ELSE v_BEGIN_DATE
                                END) AS BEGIN_SERVICE_DATE,
                               (CASE
                                   WHEN S.MODEL_ID = c_ELECTRIC_MODEL THEN v_CUT_END_DATE
                                   WHEN S.MODEL_ID = c_GAS_MODEL      THEN v_END_DATE
                                   ELSE v_END_DATE
                                END) AS END_SERVICE_DATE,
                               SL.LOAD_CODE         AS LOAD_CODE
                          FROM SERVICE         S,
                               ACCOUNT_SERVICE ACT,
                               ACCOUNT_EDC     EDC,
                               SERVICE_LOAD    SL
                         WHERE ACT.ACCOUNT_SERVICE_ID  = S.ACCOUNT_SERVICE_ID
                           AND EDC.ACCOUNT_ID  = ACT.ACCOUNT_ID
                           AND SL.SERVICE_ID   = S.SERVICE_ID
                           AND SL.SERVICE_CODE = 'A'
                           AND ((S.MODEL_ID = c_ELECTRIC_MODEL AND SL.LOAD_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE)
                                OR
                                (S.MODEL_ID = c_GAS_MODEL AND SL.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE))
                           AND SL.LOAD_CODE    = 1
                         ORDER BY 1,6) LOOP

        IF LOGS.IS_DEBUG_ENABLED THEN
          v_ACCOUNT_NAME := EI.GET_ENTITY_NAME(p_ENTITY_DOMAIN_ID => -170,
                                               p_ENTITY_ID => c_ACT_SRV.ACCOUNT_ID);
          LOGS.LOG_DEBUG('================================'||gc_CRLF||
                         'ACCOUNT NAME       = '||v_ACCOUNT_NAME||gc_CRLF||
                         'ACCOUNT_SERVICE_ID = '||TO_CHAR(c_ACT_SRV.ACCOUNT_SERVICE_ID)||gc_CRLF||
                         'EDC_ID             = '||TO_CHAR(c_ACT_SRV.EDC_ID)||gc_CRLF||
                         'SERVICE_ID         = '||TO_CHAR(c_ACT_SRV.SERVICE_ID)||gc_CRLF||
                         'SERVICE_CODE       = '||c_ACT_SRV.SERVICE_CODE||gc_CRLF||
                         'BEGIN_SERVICE_DATE = '||TO_CHAR(c_ACT_SRV.BEGIN_SERVICE_DATE, 'YYYY-MM-DD')||gc_CRLF||
                         'END_SERVICE_DATE   = '||TO_CHAR(c_ACT_SRV.END_SERVICE_DATE, 'YYYY-MM-DD')||gc_CRLF||
                         'LOAD_CODE          = '||c_ACT_SRV.LOAD_CODE||gc_CRLF);
        END IF;

        -- Reset the collections after each parent record.
        v_LOAD_VAL.DELETE;
        v_TX_LOSS_VAL.DELETE;
        v_DX_LOSS_VAL.DELETE;
        v_UE_LOSS_VAL.DELETE;

        -- Processing
        BEGIN
          SELECT LOAD_DATE,
                 LOAD_VAL,
                 TX_LOSS_VAL,
                 DX_LOSS_VAL,
                 UE_LOSS_VAL
            BULK COLLECT INTO
                 v_LOAD_DATE,
                 v_LOAD_VAL,
                 v_TX_LOSS_VAL,
                 v_DX_LOSS_VAL,
                 v_UE_LOSS_VAL
            FROM SERVICE_LOAD
           WHERE SERVICE_ID   = c_ACT_SRV.SERVICE_ID
             AND SERVICE_CODE = c_ACT_SRV.SERVICE_CODE
             AND LOAD_DATE BETWEEN c_ACT_SRV.BEGIN_SERVICE_DATE AND c_ACT_SRV.END_SERVICE_DATE
             AND LOAD_CODE    = c_ACT_SRV.LOAD_CODE
           ORDER BY LOAD_DATE;

          LOGS.LOG_DEBUG('v_LOAD_VAL.COUNT = '||TO_CHAR(v_LOAD_VAL.COUNT));

          IF v_LOAD_VAL.COUNT >= 1 THEN
            LOGS.LOG_DEBUG('Calling FS.APPLY_LOSS_FACTORS(...)');
            FS.APPLY_LOSS_FACTORS(p_ACCOUNT_SERVICE_ID => c_ACT_SRV.ACCOUNT_SERVICE_ID,
                                  p_EDC_ID => c_ACT_SRV.EDC_ID,
                                  p_SERVICE_DATE => c_ACT_SRV.BEGIN_SERVICE_DATE,
                                  p_LOAD => v_LOAD_VAL,
                                  p_TX_LOSS => v_TX_LOSS_VAL,
                                  p_DX_LOSS => v_DX_LOSS_VAL,
                                  p_UE_LOAD => v_UE_LOSS_VAL,
                                  p_FAULT_CACHE => v_FAULT_CACHE);

            LOGS.LOG_DEBUG('Calling FS.STORE_ACTUAL_SERVICE_LOSSES(...)');
            STORE_ACTUAL_SERVICE_LOSSES(p_SERVICE_ID => c_ACT_SRV.SERVICE_ID,
                                        p_LOAD_DATE => v_LOAD_DATE,
                                        p_TX_LOSS => v_TX_LOSS_VAL,
                                        p_DX_LOSS => v_DX_LOSS_VAL,
                                        p_UE_LOSS => v_UE_LOSS_VAL);

          END IF;--IF v_LOAD_VAL.COUNT >= 1 THEN
      EXCEPTION
         WHEN NO_DATA_FOUND THEN
            LOGS.LOG_INFO(p_EVENT_TEXT => 'No Data Found for the following SERVICE_LOAD record'||gc_CRLF||
                                          'ACCOUNT NAME = '||v_ACCOUNT_NAME||gc_CRLF||
                                          'SERVICE_ID   = '||TO_CHAR(c_ACT_SRV.SERVICE_ID)||gc_CRLF||
                                          'SERVICE_CODE   = '||c_ACT_SRV.SERVICE_CODE||gc_CRLF||
                                          'LOAD_DATE  BETWEEN '||TO_CHAR(c_ACT_SRV.BEGIN_SERVICE_DATE,'YYYY-MM-DD')||' AND '||TO_CHAR((c_ACT_SRV.END_SERVICE_DATE),'YYYY-MM-DD')||gc_CRLF||
                                          'LOAD_CODE   = '||TO_CHAR(c_ACT_SRV.LOAD_CODE)||gc_CRLF);
      END;--Processing

      LOGS.INCREMENT_PROCESS_PROGRESS;

      END LOOP;--FOR c_ACT_SRV IN () LOOP

      COMMIT;

   END IF;--IF v_ACCOUNT_CNT >= 1 THEN

   LOGS.LOG_DEBUG('Process completed processing ' || TO_CHAR(v_ACCOUNT_CNT) || ' account(s).');
   p_MESSAGE := 'Process completed processing ' || TO_CHAR(v_ACCOUNT_CNT) || ' account(s).';
   LOGS.STOP_PROCESS(p_MESSAGE, p_PROCESS_STATUS);

   EXCEPTION
      WHEN OTHERS THEN
         ROLLBACK TO SP_REAPPLY_LOSS_FACTORS;
         ERRS.ABORT_PROCESS;
END REAPPLY_LOSS_FACTORS;


----------------------------------------------------------------------------------------------------
END FS;
/

