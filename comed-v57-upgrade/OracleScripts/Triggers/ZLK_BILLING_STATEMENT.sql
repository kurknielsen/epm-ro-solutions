CREATE OR REPLACE TRIGGER ZLK_BILLING_STATEMENT
	BEFORE INSERT OR DELETE OR UPDATE
	ON BILLING_STATEMENT
	FOR EACH ROW
DECLARE
	v_LOCK_STATE CHAR(1);
BEGIN
	IF UPDATING THEN
	
		-- attempts to set LOCK_STATE to NULL will silently do nothing
		:new.LOCK_STATE := NVL(:new.LOCK_STATE, :old.LOCK_STATE);
	
		-- did key columns change? If so, we need to check old and new
		-- lock states
		IF NOT ((:new.ENTITY_ID IS NULL AND :old.ENTITY_ID IS NULL) OR :new.ENTITY_ID = :old.ENTITY_ID) OR
		   NOT ((:new.PRODUCT_ID IS NULL AND :old.PRODUCT_ID IS NULL) OR :new.PRODUCT_ID = :old.PRODUCT_ID) OR
		   NOT ((:new.COMPONENT_ID IS NULL AND :old.COMPONENT_ID IS NULL) OR :new.COMPONENT_ID = :old.COMPONENT_ID) OR
		   NOT ((:new.STATEMENT_TYPE IS NULL AND :old.STATEMENT_TYPE IS NULL) OR :new.STATEMENT_TYPE = :old.STATEMENT_TYPE) OR
		   NOT ((:new.STATEMENT_STATE IS NULL AND :old.STATEMENT_STATE IS NULL) OR :new.STATEMENT_STATE = :old.STATEMENT_STATE) OR
		   NOT ((:new.STATEMENT_DATE IS NULL AND :old.STATEMENT_DATE IS NULL) OR :new.STATEMENT_DATE = :old.STATEMENT_DATE) THEN
		
			SECURITY_CONTROLS.ENFORCE_LOCK_STATE(:old.LOCK_STATE);
		
			-- query for new lock state
			SELECT MIN(LOCK_STATE)
			INTO v_LOCK_STATE
			FROM BILLING_STATEMENT_LOCK_SUMMARY
			WHERE ENTITY_ID = :new.ENTITY_ID
				  AND PRODUCT_ID = :new.PRODUCT_ID
				  AND COMPONENT_ID = :new.COMPONENT_ID
				  AND STATEMENT_TYPE = :new.STATEMENT_TYPE
				  AND STATEMENT_STATE = :new.STATEMENT_STATE
				  AND BEGIN_DATE <= :new.STATEMENT_DATE
				  AND END_DATE >= :new.STATEMENT_DATE;
		
			SECURITY_CONTROLS.ENFORCE_LOCK_STATE(v_LOCK_STATE);
			:new.LOCK_STATE := NVL(v_LOCK_STATE,'U');
		
		-- only do something if this is not a no-op update
		ELSIF NOT ((:new.STATEMENT_END_DATE IS NULL AND :old.STATEMENT_END_DATE IS NULL) OR :new.STATEMENT_END_DATE = :old.STATEMENT_END_DATE) OR
			  NOT ((:new.IN_DISPUTE IS NULL AND :old.IN_DISPUTE IS NULL) OR :new.IN_DISPUTE = :old.IN_DISPUTE) OR
			  NOT ((:new.CHARGE_INTERVAL IS NULL AND :old.CHARGE_INTERVAL IS NULL) OR :new.CHARGE_INTERVAL = :old.CHARGE_INTERVAL) OR
			  NOT ((:new.CHARGE_VIEW_TYPE IS NULL AND :old.CHARGE_VIEW_TYPE IS NULL) OR :new.CHARGE_VIEW_TYPE = :old.CHARGE_VIEW_TYPE) OR
			  NOT ((:new.ENTITY_TYPE IS NULL AND :old.ENTITY_TYPE IS NULL) OR :new.ENTITY_TYPE = :old.ENTITY_TYPE) OR
			  NOT ((:new.CHARGE_QUANTITY IS NULL AND :old.CHARGE_QUANTITY IS NULL) OR :new.CHARGE_QUANTITY = :old.CHARGE_QUANTITY) OR
			  NOT ((:new.CHARGE_RATE IS NULL AND :old.CHARGE_RATE IS NULL) OR :new.CHARGE_RATE = :old.CHARGE_RATE) OR
			  NOT ((:new.CHARGE_AMOUNT IS NULL AND :old.CHARGE_AMOUNT IS NULL) OR :new.CHARGE_AMOUNT = :old.CHARGE_AMOUNT) OR
			  NOT ((:new.BILL_QUANTITY IS NULL AND :old.BILL_QUANTITY IS NULL) OR :new.BILL_QUANTITY = :old.BILL_QUANTITY) OR
			  NOT ((:new.BILL_AMOUNT IS NULL AND :old.BILL_AMOUNT IS NULL) OR :new.BILL_AMOUNT = :old.BILL_AMOUNT) OR
			  NOT ((:new.PRIOR_PERIOD_QUANTITY IS NULL AND :old.PRIOR_PERIOD_QUANTITY IS NULL) OR :new.PRIOR_PERIOD_QUANTITY = :old.PRIOR_PERIOD_QUANTITY) OR
			  NOT ((:new.CHARGE_ID IS NULL AND :old.CHARGE_ID IS NULL) OR :new.CHARGE_ID = :old.CHARGE_ID) THEN
		
			SECURITY_CONTROLS.ENFORCE_LOCK_STATE(:new.LOCK_STATE);

		ELSE
			-- no-op update? then make sure entry date is not changed
			:new.ENTRY_DATE := :old.ENTRY_DATE;
				
		END IF;
		
	ELSIF INSERTING THEN
	
		-- query for lock state
		SELECT MIN(LOCK_STATE)
		INTO v_LOCK_STATE
		FROM BILLING_STATEMENT_LOCK_SUMMARY
		WHERE ENTITY_ID = :new.ENTITY_ID
			  AND PRODUCT_ID = :new.PRODUCT_ID
			  AND COMPONENT_ID = :new.COMPONENT_ID
			  AND STATEMENT_TYPE = :new.STATEMENT_TYPE
			  AND STATEMENT_STATE = :new.STATEMENT_STATE
			  AND BEGIN_DATE <= :new.STATEMENT_DATE
			  AND END_DATE >= :new.STATEMENT_DATE;
	
		SECURITY_CONTROLS.ENFORCE_LOCK_STATE(v_LOCK_STATE);
		:new.LOCK_STATE := NVL(v_LOCK_STATE,'U');
	
	ELSE -- must be DELETING
	
		SECURITY_CONTROLS.ENFORCE_LOCK_STATE(:old.LOCK_STATE);
	
	END IF;

END ZLK_BILLING_STATEMENT;
/
