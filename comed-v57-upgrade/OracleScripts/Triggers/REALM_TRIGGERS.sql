-- Revision: $Revision: 1.14 $
CREATE OR REPLACE TRIGGER ZREALM_ACCOUNT
	AFTER INSERT OR UPDATE OR DELETE ON ACCOUNT
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC ACCOUNT%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -170, :old.ACCOUNT_ID, :old.ACCOUNT_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.ACCOUNT_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -170);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.ACCOUNT_ID := :new.ACCOUNT_ID;
		v_REC.ACCOUNT_NAME := :new.ACCOUNT_NAME;
		v_REC.ACCOUNT_ALIAS := :new.ACCOUNT_ALIAS;
		v_REC.ACCOUNT_DESC := :new.ACCOUNT_DESC;
		v_REC.ACCOUNT_DUNS_NUMBER := :new.ACCOUNT_DUNS_NUMBER;
		v_REC.ACCOUNT_EXTERNAL_IDENTIFIER := :new.ACCOUNT_EXTERNAL_IDENTIFIER;
		v_REC.ACCOUNT_MODEL_OPTION := :new.ACCOUNT_MODEL_OPTION;
		v_REC.ACCOUNT_SIC_CODE := :new.ACCOUNT_SIC_CODE;
		v_REC.ACCOUNT_METER_TYPE := :new.ACCOUNT_METER_TYPE;
		v_REC.ACCOUNT_METER_EXT_IDENTIFIER := :new.ACCOUNT_METER_EXT_IDENTIFIER;
		v_REC.ACCOUNT_DISPLAY_NAME := :new.ACCOUNT_DISPLAY_NAME;
		v_REC.ACCOUNT_BILL_OPTION := :new.ACCOUNT_BILL_OPTION;
		v_REC.ACCOUNT_ROLLUP_ID := :new.ACCOUNT_ROLLUP_ID;
		v_REC.IS_EXTERNAL_INTERVAL_USAGE := :new.IS_EXTERNAL_INTERVAL_USAGE;
		v_REC.IS_EXTERNAL_BILLED_USAGE := :new.IS_EXTERNAL_BILLED_USAGE;
		v_REC.IS_AGGREGATE_ACCOUNT := :new.IS_AGGREGATE_ACCOUNT;
		v_REC.IS_UFE_PARTICIPANT := :new.IS_UFE_PARTICIPANT;
		v_REC.IS_CREATE_SETTLEMENT_PROFILE := :new.IS_CREATE_SETTLEMENT_PROFILE;
		v_REC.IS_EXTERNAL_FORECAST := :new.IS_EXTERNAL_FORECAST;
		v_REC.IS_SUB_AGGREGATE := :new.IS_SUB_AGGREGATE;
		v_REC.TX_SERVICE_TYPE_ID := :new.TX_SERVICE_TYPE_ID;
		v_REC.USE_TOU_USAGE_FACTOR := :new.USE_TOU_USAGE_FACTOR;
		v_REC.MODEL_ID := :new.MODEL_ID;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_ACCOUNT_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -170 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.ACCOUNT_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_ACCOUNT_GROUP
	AFTER INSERT OR UPDATE OR DELETE ON ACCOUNT_GROUP
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC ACCOUNT_GROUP%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -260, :old.ACCOUNT_GROUP_ID, :old.ACCOUNT_GROUP_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.ACCOUNT_GROUP_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -260);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.ACCOUNT_GROUP_ID := :new.ACCOUNT_GROUP_ID;
		v_REC.ACCOUNT_GROUP_NAME := :new.ACCOUNT_GROUP_NAME;
		v_REC.ACCOUNT_GROUP_ALIAS := :new.ACCOUNT_GROUP_ALIAS;
		v_REC.ACCOUNT_GROUP_DESC := :new.ACCOUNT_GROUP_DESC;
		v_REC.EXTERNAL_IDENTIFIER := :new.EXTERNAL_IDENTIFIER;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_ACCOUNT_GROUP_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -260 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.ACCOUNT_GROUP_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_ANCILLARY_SERVICE
	AFTER INSERT OR UPDATE OR DELETE ON ANCILLARY_SERVICE
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC ANCILLARY_SERVICE%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -320, :old.ANCILLARY_SERVICE_ID, :old.ANCILLARY_SERVICE_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.ANCILLARY_SERVICE_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -320);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.ANCILLARY_SERVICE_ID := :new.ANCILLARY_SERVICE_ID;
		v_REC.ANCILLARY_SERVICE_NAME := :new.ANCILLARY_SERVICE_NAME;
		v_REC.ANCILLARY_SERVICE_ALIAS := :new.ANCILLARY_SERVICE_ALIAS;
		v_REC.ANCILLARY_SERVICE_DESC := :new.ANCILLARY_SERVICE_DESC;
		v_REC.ANCILLARY_SERVICE_TYPE := :new.ANCILLARY_SERVICE_TYPE;
		v_REC.PROVIDER_CATEGORY := :new.PROVIDER_CATEGORY;
		v_REC.PROVIDER_ID := :new.PROVIDER_ID;
		v_REC.TRANSACTION_TYPE := :new.TRANSACTION_TYPE;
		v_REC.IT_COMMODITY_ID := :new.IT_COMMODITY_ID;
		v_REC.ROUNDING_PREFERENCE := :new.ROUNDING_PREFERENCE;
		v_REC.MINIMUM_SCHEDULE_AMT := :new.MINIMUM_SCHEDULE_AMT;
		v_REC.ANCILLARY_SERVICE_UNIT := :new.ANCILLARY_SERVICE_UNIT;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_ANCILLARY_SERVICE_FIELDS_M( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -320 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.ANCILLARY_SERVICE_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_AREA
	AFTER INSERT OR UPDATE OR DELETE ON AREA
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC AREA%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -510, :old.AREA_ID, :old.AREA_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.AREA_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -510);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.AREA_ID := :new.AREA_ID;
		v_REC.AREA_NAME := :new.AREA_NAME;
		v_REC.AREA_ALIAS := :new.AREA_ALIAS;
		v_REC.AREA_DESC := :new.AREA_DESC;
		v_REC.AREA_INTERVAL := :new.AREA_INTERVAL;
		v_REC.PROJECTION_PERIOD := :new.PROJECTION_PERIOD;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_AREA_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -510 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.AREA_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_BILL_CYCLE
	AFTER INSERT OR UPDATE OR DELETE ON BILL_CYCLE
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC BILL_CYCLE%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -410, :old.BILL_CYCLE_ID, :old.BILL_CYCLE_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.BILL_CYCLE_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -410);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.BILL_CYCLE_ID := :new.BILL_CYCLE_ID;
		v_REC.BILL_CYCLE_NAME := :new.BILL_CYCLE_NAME;
		v_REC.BILL_CYCLE_ALIAS := :new.BILL_CYCLE_ALIAS;
		v_REC.BILL_CYCLE_DESC := :new.BILL_CYCLE_DESC;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_BILL_CYCLE_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -410 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.BILL_CYCLE_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_BILL_PARTY
	AFTER INSERT OR UPDATE OR DELETE ON BILL_PARTY
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC BILL_PARTY%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -250, :old.BILL_PARTY_ID, :old.BILL_PARTY_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.BILL_PARTY_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -250);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.BILL_PARTY_ID := :new.BILL_PARTY_ID;
		v_REC.BILL_PARTY_NAME := :new.BILL_PARTY_NAME;
		v_REC.BILL_PARTY_ALIAS := :new.BILL_PARTY_ALIAS;
		v_REC.BILL_PARTY_DESC := :new.BILL_PARTY_DESC;
		v_REC.BILL_PARTY_STATUS := :new.BILL_PARTY_STATUS;
		v_REC.EXTERNAL_IDENTIFIER := :new.EXTERNAL_IDENTIFIER;
		v_REC.IS_INVOICE_DETAIL := :new.IS_INVOICE_DETAIL;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_BILL_PARTY_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -250 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.BILL_PARTY_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_CA
	AFTER INSERT OR UPDATE OR DELETE ON CONTROL_AREA
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC CONTROL_AREA%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -150, :old.CA_ID, :old.CA_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.CA_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -150);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.CA_ID := :new.CA_ID;
		v_REC.CA_NAME := :new.CA_NAME;
		v_REC.CA_ALIAS := :new.CA_ALIAS;
		v_REC.CA_DESC := :new.CA_DESC;
		v_REC.CA_NERC_CODE := :new.CA_NERC_CODE;
		v_REC.CA_STATUS := :new.CA_STATUS;
		v_REC.CA_DUNS_NUMBER := :new.CA_DUNS_NUMBER;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_CA_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -150 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.CA_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_CALC_PROCESS
	AFTER INSERT OR UPDATE OR DELETE ON CALCULATION_PROCESS
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC CALCULATION_PROCESS%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -1020, :old.CALC_PROCESS_ID, :old.CALC_PROCESS_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.CALC_PROCESS_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -1020);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.CALC_PROCESS_ID := :new.CALC_PROCESS_ID;
		v_REC.CALC_PROCESS_NAME := :new.CALC_PROCESS_NAME;
		v_REC.CALC_PROCESS_ALIAS := :new.CALC_PROCESS_ALIAS;
		v_REC.CALC_PROCESS_DESC := :new.CALC_PROCESS_DESC;
		v_REC.CALC_PROCESS_CATEGORY := :new.CALC_PROCESS_CATEGORY;
		v_REC.TIME_ZONE := :new.TIME_ZONE;
		v_REC.PROCESS_INTERVAL := :new.PROCESS_INTERVAL;
		v_REC.WEEK_BEGIN := :new.WEEK_BEGIN;
		v_REC.CONTEXT_DOMAIN_ID := :new.CONTEXT_DOMAIN_ID;
		v_REC.CONTEXT_REALM_ID := :new.CONTEXT_REALM_ID;
		v_REC.CONTEXT_GROUP_ID := :new.CONTEXT_GROUP_ID;
		v_REC.CONTEXT_NAME := :new.CONTEXT_NAME;
		v_REC.IS_STATEMENT_TYPE_SPECIFIC := :new.IS_STATEMENT_TYPE_SPECIFIC;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_CALC_PROCESS_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -1020 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.CALC_PROCESS_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_CALENDAR
	AFTER INSERT OR UPDATE OR DELETE ON CALENDAR
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC CALENDAR%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -1100, :old.CALENDAR_ID, :old.CALENDAR_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.CALENDAR_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -1100);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.CALENDAR_ID := :new.CALENDAR_ID;
		v_REC.CALENDAR_NAME := :new.CALENDAR_NAME;
		v_REC.CALENDAR_ALIAS := :new.CALENDAR_ALIAS;
		v_REC.CALENDAR_DESC := :new.CALENDAR_DESC;
		v_REC.ASSIGNMENT_TYPE := :new.ASSIGNMENT_TYPE;
		v_REC.HAS_ADJUSTMENTS := :new.HAS_ADJUSTMENTS;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_CALENDAR_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -1100 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.CALENDAR_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_CASE_LABEL
	AFTER INSERT OR UPDATE OR DELETE ON CASE_LABEL
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC CASE_LABEL%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -870, :old.CASE_ID, :old.CASE_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.CASE_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -870);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.CASE_ID := :new.CASE_ID;
		v_REC.CASE_NAME := :new.CASE_NAME;
		v_REC.CASE_ALIAS := :new.CASE_ALIAS;
		v_REC.CASE_DESC := :new.CASE_DESC;
		v_REC.CASE_CATEGORY := :new.CASE_CATEGORY;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_CASE_LABEL_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -870 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.CASE_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_CATEGORY
	AFTER INSERT OR UPDATE OR DELETE ON CATEGORY
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC CATEGORY%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -590, :old.CATEGORY_ID, :old.CATEGORY_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.CATEGORY_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -590);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.CATEGORY_ID := :new.CATEGORY_ID;
		v_REC.CATEGORY_NAME := :new.CATEGORY_NAME;
		v_REC.CATEGORY_ALIAS := :new.CATEGORY_ALIAS;
		v_REC.CATEGORY_DESC := :new.CATEGORY_DESC;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_CATEGORY_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -590 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.CATEGORY_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_COMPONENT
	AFTER INSERT OR UPDATE OR DELETE ON COMPONENT
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC COMPONENT%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -630, :old.COMPONENT_ID, :old.COMPONENT_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.COMPONENT_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -630);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.COMPONENT_ID := :new.COMPONENT_ID;
		v_REC.COMPONENT_NAME := :new.COMPONENT_NAME;
		v_REC.COMPONENT_ALIAS := :new.COMPONENT_ALIAS;
		v_REC.COMPONENT_DESC := :new.COMPONENT_DESC;
		v_REC.COMPONENT_ENTITY := :new.COMPONENT_ENTITY;
		v_REC.CHARGE_TYPE := :new.CHARGE_TYPE;
		v_REC.RATE_STRUCTURE := :new.RATE_STRUCTURE;
		v_REC.RATE_INTERVAL := :new.RATE_INTERVAL;
		v_REC.IS_REBILL := :new.IS_REBILL;
		v_REC.IS_TAXED := :new.IS_TAXED;
		v_REC.IS_CUSTOM_CHARGE := :new.IS_CUSTOM_CHARGE;
		v_REC.IS_CREDIT_CHARGE := :new.IS_CREDIT_CHARGE;
		v_REC.IS_INCLUDE_TX_LOSS := :new.IS_INCLUDE_TX_LOSS;
		v_REC.IS_INCLUDE_DX_LOSS := :new.IS_INCLUDE_DX_LOSS;
		v_REC.TEMPLATE_ID := :new.TEMPLATE_ID;
		v_REC.MARKET_PRICE_ID := :new.MARKET_PRICE_ID;
		v_REC.SERVICE_POINT_ID := :new.SERVICE_POINT_ID;
		v_REC.MODEL_ID := :new.MODEL_ID;
		v_REC.EVENT_ID := :new.EVENT_ID;
		v_REC.COMPONENT_REFERENCE := :new.COMPONENT_REFERENCE;
		v_REC.INVOICE_GROUP_ID := :new.INVOICE_GROUP_ID;
		v_REC.INVOICE_GROUP_ORDER := :new.INVOICE_GROUP_ORDER;
		v_REC.COMPUTATION_ORDER := :new.COMPUTATION_ORDER;
		v_REC.QUANTITY_UNIT := :new.QUANTITY_UNIT;
		v_REC.CURRENCY_UNIT := :new.CURRENCY_UNIT;
		v_REC.QUANTITY_TYPE := :new.QUANTITY_TYPE;
		v_REC.EXTERNAL_IDENTIFIER := :new.EXTERNAL_IDENTIFIER;
		v_REC.COMPONENT_CATEGORY := :new.COMPONENT_CATEGORY;
		v_REC.GL_DEBIT_ACCOUNT := :new.GL_DEBIT_ACCOUNT;
		v_REC.GL_CREDIT_ACCOUNT := :new.GL_CREDIT_ACCOUNT;
		v_REC.FIRM_NON_FIRM := :new.FIRM_NON_FIRM;
		v_REC.EXCLUDE_FROM_INVOICE := :new.EXCLUDE_FROM_INVOICE;
		v_REC.EXCLUDE_FROM_INVOICE_TOTAL := :new.EXCLUDE_FROM_INVOICE_TOTAL;
		v_REC.IMBALANCE_TYPE := :new.IMBALANCE_TYPE;
		v_REC.ACCUMULATION_PERIOD := :new.ACCUMULATION_PERIOD;
		v_REC.BASE_COMPONENT_ID := :new.BASE_COMPONENT_ID;
		v_REC.BASE_LIMIT_ID := :new.BASE_LIMIT_ID;
		v_REC.MARKET_TYPE := :new.MARKET_TYPE;
		v_REC.MARKET_PRICE_TYPE := :new.MARKET_PRICE_TYPE;
		v_REC.WHICH_INTERVAL := :new.WHICH_INTERVAL;
		v_REC.LMP_PRICE_CALC := :new.LMP_PRICE_CALC;
		v_REC.LMP_INCLUDE_EXT := :new.LMP_INCLUDE_EXT;
		v_REC.LMP_INCLUDE_SALES := :new.LMP_INCLUDE_SALES;
		v_REC.CHARGE_WHEN := :new.CHARGE_WHEN;
		v_REC.BILATERALS_SIGN := :new.BILATERALS_SIGN;
		v_REC.LMP_COMMODITY_ID := :new.LMP_COMMODITY_ID;
		v_REC.LMP_BASE_COMMODITY_ID := :new.LMP_BASE_COMMODITY_ID;
		v_REC.USE_ZONAL_PRICE := :new.USE_ZONAL_PRICE;
		v_REC.ALTERNATE_PRICE := :new.ALTERNATE_PRICE;
		v_REC.ALTERNATE_PRICE_FUNCTION := :new.ALTERNATE_PRICE_FUNCTION;
		v_REC.EXCLUDE_FROM_BILLING_EXPORT := :new.EXCLUDE_FROM_BILLING_EXPORT;
		v_REC.IS_DEFAULT_TEMPLATE := :new.IS_DEFAULT_TEMPLATE;
		v_REC.KWH_MULTIPLIER := :new.KWH_MULTIPLIER;
		v_REC.ANCILLARY_SERVICE_ID := :new.ANCILLARY_SERVICE_ID;
		v_REC.APPLY_RATE_FOR := :new.APPLY_RATE_FOR;
		v_REC.LOSS_ADJ_TYPE := :new.LOSS_ADJ_TYPE;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_COMPONENT_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -630 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.COMPONENT_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_CONDITIONAL_FORMAT
	AFTER INSERT OR UPDATE OR DELETE ON CONDITIONAL_FORMAT
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC CONDITIONAL_FORMAT%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -980, :old.CONDITIONAL_FORMAT_ID, :old.CONDITIONAL_FORMAT_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.CONDITIONAL_FORMAT_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -980);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.CONDITIONAL_FORMAT_ID := :new.CONDITIONAL_FORMAT_ID;
		v_REC.CONDITIONAL_FORMAT_NAME := :new.CONDITIONAL_FORMAT_NAME;
		v_REC.CONDITIONAL_FORMAT_ALIAS := :new.CONDITIONAL_FORMAT_ALIAS;
		v_REC.CONDITIONAL_FORMAT_DESC := :new.CONDITIONAL_FORMAT_DESC;
		v_REC.CONDITIONAL_FORMAT_MODULE := :new.CONDITIONAL_FORMAT_MODULE;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_CONDITIONAL_FORMAT_FIELDS_( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -980 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.CONDITIONAL_FORMAT_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_CONTACT
	AFTER INSERT OR UPDATE OR DELETE ON CONTACT
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC CONTACT%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -570, :old.CONTACT_ID, :old.CONTACT_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.CONTACT_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -570);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.CONTACT_ID := :new.CONTACT_ID;
		v_REC.CONTACT_NAME := :new.CONTACT_NAME;
		v_REC.CONTACT_ALIAS := :new.CONTACT_ALIAS;
		v_REC.CONTACT_DESC := :new.CONTACT_DESC;
		v_REC.CONTACT_STATUS := :new.CONTACT_STATUS;
		v_REC.EMAIL_ADDRESS := :new.EMAIL_ADDRESS;
		v_REC.FIRST_NAME := :new.FIRST_NAME;
		v_REC.MIDDLE_NAME := :new.MIDDLE_NAME;
		v_REC.LAST_NAME := :new.LAST_NAME;
		v_REC.SALUTATION := :new.SALUTATION;
		v_REC.TITLE := :new.TITLE;
		v_REC.EXTERNAL_IDENTIFIER := :new.EXTERNAL_IDENTIFIER;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_CONTACT_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -570 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.CONTACT_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_CONTRACT
	AFTER INSERT OR UPDATE OR DELETE ON SERVICE_CONTRACT
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC SERVICE_CONTRACT%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -240, :old.CONTRACT_ID, :old.CONTRACT_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.CONTRACT_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -240);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.CONTRACT_ID := :new.CONTRACT_ID;
		v_REC.CONTRACT_NAME := :new.CONTRACT_NAME;
		v_REC.CONTRACT_ALIAS := :new.CONTRACT_ALIAS;
		v_REC.CONTRACT_DESC := :new.CONTRACT_DESC;
		v_REC.EXTERNAL_IDENTIFIER := :new.EXTERNAL_IDENTIFIER;
		v_REC.BEGIN_DATE := :new.BEGIN_DATE;
		v_REC.END_DATE := :new.END_DATE;
		v_REC.IS_ESTIMATED_END_DATE := :new.IS_ESTIMATED_END_DATE;
		v_REC.IS_EVERGREEN := :new.IS_EVERGREEN;
		v_REC.IS_INTERRUPTIBLE := :new.IS_INTERRUPTIBLE;
		v_REC.EXPECTED_RENEWAL_PCT := :new.EXPECTED_RENEWAL_PCT;
		v_REC.NEXT_ACTION_DATE := :new.NEXT_ACTION_DATE;
		v_REC.NOTIFICATION_REQUIREMENTS := :new.NOTIFICATION_REQUIREMENTS;
		v_REC.CURTAILMENT_ABILITY := :new.CURTAILMENT_ABILITY;
		v_REC.PENALTY_CLAUSES := :new.PENALTY_CLAUSES;
		v_REC.PRICING_MODEL := :new.PRICING_MODEL;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_CONTRACT_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -240 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.CONTRACT_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_CONTRACT_LIMIT
	AFTER INSERT OR UPDATE OR DELETE ON CONTRACT_LIMIT
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC CONTRACT_LIMIT%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -660, :old.LIMIT_ID, :old.LIMIT_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.LIMIT_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -660);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.LIMIT_ID := :new.LIMIT_ID;
		v_REC.LIMIT_NAME := :new.LIMIT_NAME;
		v_REC.LIMIT_ALIAS := :new.LIMIT_ALIAS;
		v_REC.LIMIT_DESC := :new.LIMIT_DESC;
		v_REC.LIMIT_TYPE := :new.LIMIT_TYPE;
		v_REC.LIMIT_MEASURE := :new.LIMIT_MEASURE;
		v_REC.LIMIT_INTERVAL := :new.LIMIT_INTERVAL;
		v_REC.LIMIT_IS_SEASONABLE := :new.LIMIT_IS_SEASONABLE;
		v_REC.TEMPLATE_ID := :new.TEMPLATE_ID;
		v_REC.PERIOD_ID := :new.PERIOD_ID;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_CONTRACT_LIMIT_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -660 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.LIMIT_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_CUSTOMER
	AFTER INSERT OR UPDATE OR DELETE ON CUSTOMER
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC CUSTOMER%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -560, :old.CUSTOMER_ID, :old.CUSTOMER_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.CUSTOMER_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -560);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.CUSTOMER_ID := :new.CUSTOMER_ID;
		v_REC.CUSTOMER_NAME := :new.CUSTOMER_NAME;
		v_REC.CUSTOMER_ALIAS := :new.CUSTOMER_ALIAS;
		v_REC.CUSTOMER_DESC := :new.CUSTOMER_DESC;
		v_REC.CUSTOMER_IDENTIFIER := :new.CUSTOMER_IDENTIFIER;
		v_REC.CUSTOMER_STATUS := :new.CUSTOMER_STATUS;
		v_REC.CUSTOMER_IS_ACTIVE := :new.CUSTOMER_IS_ACTIVE;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_CUSTOMER_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -560 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.CUSTOMER_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_DATA_LOCK_GROUP
	AFTER INSERT OR UPDATE OR DELETE ON DATA_LOCK_GROUP
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC DATA_LOCK_GROUP%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -1090, :old.DATA_LOCK_GROUP_ID, :old.DATA_LOCK_GROUP_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.DATA_LOCK_GROUP_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -1090);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.DATA_LOCK_GROUP_ID := :new.DATA_LOCK_GROUP_ID;
		v_REC.DATA_LOCK_GROUP_NAME := :new.DATA_LOCK_GROUP_NAME;
		v_REC.DATA_LOCK_GROUP_ALIAS := :new.DATA_LOCK_GROUP_ALIAS;
		v_REC.DATA_LOCK_GROUP_DESC := :new.DATA_LOCK_GROUP_DESC;
		v_REC.DATA_LOCK_GROUP_INTERVAL := :new.DATA_LOCK_GROUP_INTERVAL;
		v_REC.IS_AUTOMATIC := :new.IS_AUTOMATIC;
		v_REC.AUTOLOCK_DATE_FORMULA := :new.AUTOLOCK_DATE_FORMULA;
		v_REC.LOCK_LIMIT_DATE_FORMULA := :new.LOCK_LIMIT_DATE_FORMULA;
		v_REC.LOCK_STATE := :new.LOCK_STATE;
		v_REC.LAST_PROCESSED_INTERVAL := :new.LAST_PROCESSED_INTERVAL;
		v_REC.TIME_ZONE := :new.TIME_ZONE;
		v_REC.WEEK_BEGIN := :new.WEEK_BEGIN;
		-- use record
		v_MAP := IO_UTIL.GET_DATA_LOCK_GROUP_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -1090 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.DATA_LOCK_GROUP_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_DER
	AFTER INSERT OR UPDATE OR DELETE ON DISTRIBUTED_ENERGY_RESOURCE
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC DISTRIBUTED_ENERGY_RESOURCE%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -1130, :old.DER_ID, :old.DER_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.DER_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -1130);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.DER_ID := :new.DER_ID;
		v_REC.DER_NAME := :new.DER_NAME;
		v_REC.DER_ALIAS := :new.DER_ALIAS;
		v_REC.DER_DESC := :new.DER_DESC;
		v_REC.SERVICE_LOCATION_ID := :new.SERVICE_LOCATION_ID;
		v_REC.DER_TYPE_ID := :new.DER_TYPE_ID;
		v_REC.EXTERNAL_SYSTEM_ID := :new.EXTERNAL_SYSTEM_ID;
		v_REC.EXTERNAL_IDENTIFIER := :new.EXTERNAL_IDENTIFIER;
		v_REC.BEGIN_DATE := :new.BEGIN_DATE;
		v_REC.END_DATE := :new.END_DATE;
		v_REC.SERIAL_NUMBER := :new.SERIAL_NUMBER;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_DER_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -1130 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.DER_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_DER_TYPE
	AFTER INSERT OR UPDATE OR DELETE ON DER_TYPE
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC DER_TYPE%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -1120, :old.DER_TYPE_ID, :old.DER_TYPE_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.DER_TYPE_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -1120);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.DER_TYPE_ID := :new.DER_TYPE_ID;
		v_REC.DER_TYPE_NAME := :new.DER_TYPE_NAME;
		v_REC.DER_TYPE_ALIAS := :new.DER_TYPE_ALIAS;
		v_REC.DER_TYPE_DESC := :new.DER_TYPE_DESC;
		v_REC.DER_TYPE_FUNCTION := :new.DER_TYPE_FUNCTION;
		v_REC.DER_TYPE_CATEGORY := :new.DER_TYPE_CATEGORY;
		v_REC.DEFAULT_FAILURE_PCT := :new.DEFAULT_FAILURE_PCT;
		v_REC.USE_DEFAULT_FAIL_PCT := :new.USE_DEFAULT_FAIL_PCT;
		v_REC.EXTERNAL_IDENTIFIER := :new.EXTERNAL_IDENTIFIER;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_DER_TYPE_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -1120 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.DER_TYPE_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_DR_EVENT
	AFTER INSERT OR UPDATE OR DELETE ON DR_EVENT
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC DR_EVENT%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -1160, :old.EVENT_ID, :old.EVENT_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.EVENT_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -1160);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.EVENT_ID := :new.EVENT_ID;
		v_REC.EVENT_NAME := :new.EVENT_NAME;
		v_REC.EVENT_ALIAS := :new.EVENT_ALIAS;
		v_REC.EVENT_DESC := :new.EVENT_DESC;
		v_REC.VPP_ID := :new.VPP_ID;
		v_REC.EVENT_STATUS := :new.EVENT_STATUS;
		v_REC.START_TIME := :new.START_TIME;
		v_REC.STOP_TIME := :new.STOP_TIME;
		v_REC.EVENT_TYPE := :new.EVENT_TYPE;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_DR_EVENT_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -1160 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.EVENT_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_EDC
	AFTER INSERT OR UPDATE OR DELETE ON ENERGY_DISTRIBUTION_COMPANY
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC ENERGY_DISTRIBUTION_COMPANY%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -100, :old.EDC_ID, :old.EDC_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.EDC_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -100);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.EDC_ID := :new.EDC_ID;
		v_REC.EDC_NAME := :new.EDC_NAME;
		v_REC.EDC_ALIAS := :new.EDC_ALIAS;
		v_REC.EDC_DESC := :new.EDC_DESC;
		v_REC.EDC_STATUS := :new.EDC_STATUS;
		v_REC.EDC_DUNS_NUMBER := :new.EDC_DUNS_NUMBER;
		v_REC.EDC_EXTERNAL_IDENTIFIER := :new.EDC_EXTERNAL_IDENTIFIER;
		v_REC.EDC_SETTLEMENT_AGENT_NAME := :new.EDC_SETTLEMENT_AGENT_NAME;
		v_REC.EDC_LOSS_FACTOR_OPTION := :new.EDC_LOSS_FACTOR_OPTION;
		v_REC.EDC_SYSTEM_LOAD_ID := :new.EDC_SYSTEM_LOAD_ID;
		v_REC.EDC_MARKET_PRICE_ID := :new.EDC_MARKET_PRICE_ID;
		v_REC.EDC_HOLIDAY_SET_ID := :new.EDC_HOLIDAY_SET_ID;
		v_REC.EDC_SC_ID := :new.EDC_SC_ID;
		v_REC.EDC_EXCLUDE_LOAD_SCHEDULE := :new.EDC_EXCLUDE_LOAD_SCHEDULE;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_EDC_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -100 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.EDC_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_ENTITY_DOMAIN
	AFTER INSERT OR UPDATE OR DELETE ON ENTITY_DOMAIN
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC ENTITY_DOMAIN%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -830, :old.ENTITY_DOMAIN_ID, :old.ENTITY_DOMAIN_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.ENTITY_DOMAIN_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -830);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.ENTITY_DOMAIN_ID := :new.ENTITY_DOMAIN_ID;
		v_REC.ENTITY_DOMAIN_NAME := :new.ENTITY_DOMAIN_NAME;
		v_REC.ENTITY_DOMAIN_ALIAS := :new.ENTITY_DOMAIN_ALIAS;
		v_REC.ENTITY_DOMAIN_DESC := :new.ENTITY_DOMAIN_DESC;
		v_REC.ENTITY_DOMAIN_TABLE := :new.ENTITY_DOMAIN_TABLE;
		v_REC.ENTITY_DOMAIN_TABLE_ALIAS := :new.ENTITY_DOMAIN_TABLE_ALIAS;
		v_REC.ENTITY_DOMAIN_CATEGORY := :new.ENTITY_DOMAIN_CATEGORY;
		v_REC.DISPLAY_NAME := :new.DISPLAY_NAME;
		v_REC.INCLUDE_CONTACT_ADDRESS := :new.INCLUDE_CONTACT_ADDRESS;
		v_REC.INCLUDE_ENTITY_ATTRIBUTE := :new.INCLUDE_ENTITY_ATTRIBUTE;
		v_REC.INCLUDE_EXTERNAL_IDENTIFIER := :new.INCLUDE_EXTERNAL_IDENTIFIER;
		v_REC.INCLUDE_GROUPS := :new.INCLUDE_GROUPS;
		v_REC.INCLUDE_NOTES := :new.INCLUDE_NOTES;
		v_REC.IS_PSEUDO := :new.IS_PSEUDO;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_ENTITY_DOMAIN_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -830 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.ENTITY_DOMAIN_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_ENTITY_GROUP
	AFTER INSERT OR UPDATE OR DELETE ON ENTITY_GROUP
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC ENTITY_GROUP%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -1010, :old.ENTITY_GROUP_ID, :old.ENTITY_GROUP_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.ENTITY_GROUP_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -1010);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.ENTITY_GROUP_ID := :new.ENTITY_GROUP_ID;
		v_REC.ENTITY_GROUP_NAME := :new.ENTITY_GROUP_NAME;
		v_REC.ENTITY_GROUP_ALIAS := :new.ENTITY_GROUP_ALIAS;
		v_REC.ENTITY_GROUP_DESC := :new.ENTITY_GROUP_DESC;
		v_REC.ENTITY_DOMAIN_ID := :new.ENTITY_DOMAIN_ID;
		v_REC.PARENT_GROUP_ID := :new.PARENT_GROUP_ID;
		v_REC.IS_MATRIX := :new.IS_MATRIX;
		v_REC.GROUP_CATEGORY := :new.GROUP_CATEGORY;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_ENTITY_GROUP_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -1010 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.ENTITY_GROUP_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_ESP
	AFTER INSERT OR UPDATE OR DELETE ON ENERGY_SERVICE_PROVIDER
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC ENERGY_SERVICE_PROVIDER%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -110, :old.ESP_ID, :old.ESP_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.ESP_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -110);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.ESP_ID := :new.ESP_ID;
		v_REC.ESP_NAME := :new.ESP_NAME;
		v_REC.ESP_ALIAS := :new.ESP_ALIAS;
		v_REC.ESP_DESC := :new.ESP_DESC;
		v_REC.ESP_EXTERNAL_IDENTIFIER := :new.ESP_EXTERNAL_IDENTIFIER;
		v_REC.ESP_DUNS_NUMBER := :new.ESP_DUNS_NUMBER;
		v_REC.ESP_STATUS := :new.ESP_STATUS;
		v_REC.ESP_TYPE := :new.ESP_TYPE;
		v_REC.ESP_EXCLUDE_LOAD_SCHEDULE := :new.ESP_EXCLUDE_LOAD_SCHEDULE;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_ESP_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -110 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.ESP_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_ETAG
	AFTER INSERT OR UPDATE OR DELETE ON ETAG
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC ETAG%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -970, :old.ETAG_ID, :old.ETAG_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.ETAG_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -970);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.ETAG_ID := :new.ETAG_ID;
		v_REC.ETAG_NAME := :new.ETAG_NAME;
		v_REC.ETAG_ALIAS := :new.ETAG_ALIAS;
		v_REC.ETAG_DESC := :new.ETAG_DESC;
		v_REC.TAG_IDENT := :new.TAG_IDENT;
		v_REC.GCA_CODE := :new.GCA_CODE;
		v_REC.PSE_CODE := :new.PSE_CODE;
		v_REC.TAG_CODE := :new.TAG_CODE;
		v_REC.LCA_CODE := :new.LCA_CODE;
		v_REC.EXTERNAL_IDENTIFIER := :new.EXTERNAL_IDENTIFIER;
		v_REC.ETAG_STATUS := :new.ETAG_STATUS;
		v_REC.SECURITY_KEY := :new.SECURITY_KEY;
		v_REC.WSCC_PRESCHEDULE_FLAG := :new.WSCC_PRESCHEDULE_FLAG;
		v_REC.TEST_FLAG := :new.TEST_FLAG;
		v_REC.TRANSACTION_TYPE := :new.TRANSACTION_TYPE;
		v_REC.NOTES := :new.NOTES;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_ETAG_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -970 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.ETAG_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_EXTERNAL_SYSTEM
	AFTER INSERT OR UPDATE OR DELETE ON EXTERNAL_SYSTEM
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC EXTERNAL_SYSTEM%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -1000, :old.EXTERNAL_SYSTEM_ID, :old.EXTERNAL_SYSTEM_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.EXTERNAL_SYSTEM_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -1000);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.EXTERNAL_SYSTEM_ID := :new.EXTERNAL_SYSTEM_ID;
		v_REC.EXTERNAL_SYSTEM_NAME := :new.EXTERNAL_SYSTEM_NAME;
		v_REC.EXTERNAL_SYSTEM_ALIAS := :new.EXTERNAL_SYSTEM_ALIAS;
		v_REC.EXTERNAL_SYSTEM_DESC := :new.EXTERNAL_SYSTEM_DESC;
		v_REC.EXTERNAL_SYSTEM_TYPE := :new.EXTERNAL_SYSTEM_TYPE;
		v_REC.EXTERNAL_SYSTEM_DISPLAY_NAME := :new.EXTERNAL_SYSTEM_DISPLAY_NAME;
		v_REC.IS_ENABLED := :new.IS_ENABLED;
		v_REC.EXTERNAL_ACCOUNT_DOMAIN_ID := :new.EXTERNAL_ACCOUNT_DOMAIN_ID;
		v_REC.HAS_UNAME_PWD_CREDENTIALS := :new.HAS_UNAME_PWD_CREDENTIALS;
		v_REC.NUMBER_OF_CERTIFICATES := :new.NUMBER_OF_CERTIFICATES;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_EXTERNAL_SYSTEM_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -1000 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.EXTERNAL_SYSTEM_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_EXTERNAL_TRANSACTION
	AFTER INSERT OR UPDATE OR DELETE ON INTERCHANGE_TRANSACTION_EXT
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC INTERCHANGE_TRANSACTION_EXT%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -850, :old.TRANSACTION_ID, :old.TRANSACTION_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.TRANSACTION_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -850);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.TRANSACTION_ID := :new.TRANSACTION_ID;
		v_REC.TRANSACTION_NAME := :new.TRANSACTION_NAME;
		v_REC.TRANSACTION_ALIAS := :new.TRANSACTION_ALIAS;
		v_REC.TRANSACTION_DESC := :new.TRANSACTION_DESC;
		v_REC.TRANSACTION_TYPE := :new.TRANSACTION_TYPE;
		v_REC.TRANSACTION_CODE := :new.TRANSACTION_CODE;
		v_REC.TRANSACTION_IDENTIFIER := :new.TRANSACTION_IDENTIFIER;
		v_REC.IS_FIRM := :new.IS_FIRM;
		v_REC.IS_IMPORT_SCHEDULE := :new.IS_IMPORT_SCHEDULE;
		v_REC.IS_EXPORT_SCHEDULE := :new.IS_EXPORT_SCHEDULE;
		v_REC.IS_BALANCE_TRANSACTION := :new.IS_BALANCE_TRANSACTION;
		v_REC.IS_BID_OFFER := :new.IS_BID_OFFER;
		v_REC.IS_EXCLUDE_FROM_POSITION := :new.IS_EXCLUDE_FROM_POSITION;
		v_REC.IS_IMPORT_EXPORT := :new.IS_IMPORT_EXPORT;
		v_REC.IS_DISPATCHABLE := :new.IS_DISPATCHABLE;
		v_REC.TRANSACTION_INTERVAL := :new.TRANSACTION_INTERVAL;
		v_REC.EXTERNAL_INTERVAL := :new.EXTERNAL_INTERVAL;
		v_REC.ETAG_CODE := :new.ETAG_CODE;
		v_REC.BEGIN_DATE := :new.BEGIN_DATE;
		v_REC.END_DATE := :new.END_DATE;
		v_REC.PURCHASER_ID := :new.PURCHASER_ID;
		v_REC.SELLER_ID := :new.SELLER_ID;
		v_REC.CONTRACT_ID := :new.CONTRACT_ID;
		v_REC.SC_ID := :new.SC_ID;
		v_REC.POR_ID := :new.POR_ID;
		v_REC.POD_ID := :new.POD_ID;
		v_REC.COMMODITY_ID := :new.COMMODITY_ID;
		v_REC.SERVICE_TYPE_ID := :new.SERVICE_TYPE_ID;
		v_REC.TX_TRANSACTION_ID := :new.TX_TRANSACTION_ID;
		v_REC.PATH_ID := :new.PATH_ID;
		v_REC.LINK_TRANSACTION_ID := :new.LINK_TRANSACTION_ID;
		v_REC.EDC_ID := :new.EDC_ID;
		v_REC.PSE_ID := :new.PSE_ID;
		v_REC.ESP_ID := :new.ESP_ID;
		v_REC.POOL_ID := :new.POOL_ID;
		v_REC.SCHEDULE_GROUP_ID := :new.SCHEDULE_GROUP_ID;
		v_REC.MARKET_PRICE_ID := :new.MARKET_PRICE_ID;
		v_REC.ZOR_ID := :new.ZOR_ID;
		v_REC.ZOD_ID := :new.ZOD_ID;
		v_REC.SOURCE_ID := :new.SOURCE_ID;
		v_REC.SINK_ID := :new.SINK_ID;
		v_REC.RESOURCE_ID := :new.RESOURCE_ID;
		v_REC.AGREEMENT_TYPE := :new.AGREEMENT_TYPE;
		v_REC.APPROVAL_TYPE := :new.APPROVAL_TYPE;
		v_REC.LOSS_OPTION := :new.LOSS_OPTION;
		v_REC.TRAIT_CATEGORY := :new.TRAIT_CATEGORY;
		v_REC.TP_ID := :new.TP_ID;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_EXTERNAL_TRANSACTION_FIELD( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -850 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.TRANSACTION_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_GEOGRAPHY
	AFTER INSERT OR UPDATE OR DELETE ON GEOGRAPHY
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC GEOGRAPHY%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -820, :old.GEOGRAPHY_ID, :old.GEOGRAPHY_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.GEOGRAPHY_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -820);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.GEOGRAPHY_ID := :new.GEOGRAPHY_ID;
		v_REC.GEOGRAPHY_NAME := :new.GEOGRAPHY_NAME;
		v_REC.GEOGRAPHY_ALIAS := :new.GEOGRAPHY_ALIAS;
		v_REC.GEOGRAPHY_DESC := :new.GEOGRAPHY_DESC;
		v_REC.GEOGRAPHY_TYPE := :new.GEOGRAPHY_TYPE;
		v_REC.PARENT_GEOGRAPHY_ID := :new.PARENT_GEOGRAPHY_ID;
		v_REC.DISPLAY_NAME := :new.DISPLAY_NAME;
		v_REC.ABBREVIATION := :new.ABBREVIATION;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_GEOGRAPHY_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -820 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.GEOGRAPHY_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_GROWTH_PATTERN
	AFTER INSERT OR UPDATE OR DELETE ON GROWTH_PATTERN
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC GROWTH_PATTERN%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -1110, :old.PATTERN_ID, :old.PATTERN_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.PATTERN_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -1110);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.PATTERN_ID := :new.PATTERN_ID;
		v_REC.PATTERN_NAME := :new.PATTERN_NAME;
		v_REC.PATTERN_ALIAS := :new.PATTERN_ALIAS;
		v_REC.PATTERN_DESC := :new.PATTERN_DESC;
		v_REC.JAN_PCT := :new.JAN_PCT;
		v_REC.FEB_PCT := :new.FEB_PCT;
		v_REC.MAR_PCT := :new.MAR_PCT;
		v_REC.APR_PCT := :new.APR_PCT;
		v_REC.MAY_PCT := :new.MAY_PCT;
		v_REC.JUN_PCT := :new.JUN_PCT;
		v_REC.JUL_PCT := :new.JUL_PCT;
		v_REC.AUG_PCT := :new.AUG_PCT;
		v_REC.SEP_PCT := :new.SEP_PCT;
		v_REC.OCT_PCT := :new.OCT_PCT;
		v_REC.NOV_PCT := :new.NOV_PCT;
		v_REC.DEC_PCT := :new.DEC_PCT;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_GROWTH_PATTERN_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -1110 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.PATTERN_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_HEAT_RATE_CURVE
	AFTER INSERT OR UPDATE OR DELETE ON HEAT_RATE_CURVE
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC HEAT_RATE_CURVE%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -950, :old.HEAT_RATE_CURVE_ID, :old.HEAT_RATE_CURVE_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.HEAT_RATE_CURVE_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -950);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.HEAT_RATE_CURVE_ID := :new.HEAT_RATE_CURVE_ID;
		v_REC.HEAT_RATE_CURVE_NAME := :new.HEAT_RATE_CURVE_NAME;
		v_REC.HEAT_RATE_CURVE_ALIAS := :new.HEAT_RATE_CURVE_ALIAS;
		v_REC.HEAT_RATE_CURVE_DESC := :new.HEAT_RATE_CURVE_DESC;
		v_REC.STATION_ID := :new.STATION_ID;
		v_REC.PARAMETER_1_ID := :new.PARAMETER_1_ID;
		v_REC.PARAMETER_1_ROUND_TO_NEAREST := :new.PARAMETER_1_ROUND_TO_NEAREST;
		v_REC.PARAMETER_1_ROUNDING_STYLE := :new.PARAMETER_1_ROUNDING_STYLE;
		v_REC.PARAMETER_2_ID := :new.PARAMETER_2_ID;
		v_REC.PARAMETER_2_ROUND_TO_NEAREST := :new.PARAMETER_2_ROUND_TO_NEAREST;
		v_REC.PARAMETER_2_ROUNDING_STYLE := :new.PARAMETER_2_ROUNDING_STYLE;
		v_REC.PARAMETER_3_ID := :new.PARAMETER_3_ID;
		v_REC.PARAMETER_3_ROUND_TO_NEAREST := :new.PARAMETER_3_ROUND_TO_NEAREST;
		v_REC.PARAMETER_3_ROUNDING_STYLE := :new.PARAMETER_3_ROUNDING_STYLE;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_HEAT_RATE_CURVE_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -950 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.HEAT_RATE_CURVE_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_HOLIDAY
	AFTER INSERT OR UPDATE OR DELETE ON HOLIDAY
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC HOLIDAY%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -770, :old.HOLIDAY_ID, :old.HOLIDAY_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.HOLIDAY_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -770);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.HOLIDAY_ID := :new.HOLIDAY_ID;
		v_REC.HOLIDAY_NAME := :new.HOLIDAY_NAME;
		v_REC.HOLIDAY_ALIAS := :new.HOLIDAY_ALIAS;
		v_REC.HOLIDAY_DESC := :new.HOLIDAY_DESC;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_HOLIDAY_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -770 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.HOLIDAY_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_HOLIDAY_SET
	AFTER INSERT OR UPDATE OR DELETE ON HOLIDAY_SET
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC HOLIDAY_SET%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -780, :old.HOLIDAY_SET_ID, :old.HOLIDAY_SET_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.HOLIDAY_SET_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -780);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.HOLIDAY_SET_ID := :new.HOLIDAY_SET_ID;
		v_REC.HOLIDAY_SET_NAME := :new.HOLIDAY_SET_NAME;
		v_REC.HOLIDAY_SET_ALIAS := :new.HOLIDAY_SET_ALIAS;
		v_REC.HOLIDAY_SET_DESC := :new.HOLIDAY_SET_DESC;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_HOLIDAY_SET_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -780 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.HOLIDAY_SET_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_INTERCHANGE_CONTRACT
	AFTER INSERT OR UPDATE OR DELETE ON INTERCHANGE_CONTRACT
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC INTERCHANGE_CONTRACT%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -650, :old.CONTRACT_ID, :old.CONTRACT_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.CONTRACT_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -650);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.CONTRACT_ID := :new.CONTRACT_ID;
		v_REC.CONTRACT_NAME := :new.CONTRACT_NAME;
		v_REC.CONTRACT_ALIAS := :new.CONTRACT_ALIAS;
		v_REC.CONTRACT_DESC := :new.CONTRACT_DESC;
		v_REC.CONTRACT_STATUS := :new.CONTRACT_STATUS;
		v_REC.BEGIN_DATE := :new.BEGIN_DATE;
		v_REC.END_DATE := :new.END_DATE;
		v_REC.IS_EVERGREEN := :new.IS_EVERGREEN;
		v_REC.CONTRACT_TYPE := :new.CONTRACT_TYPE;
		v_REC.BILLING_ENTITY_ID := :new.BILLING_ENTITY_ID;
		v_REC.PURCHASER_ID := :new.PURCHASER_ID;
		v_REC.SELLER_ID := :new.SELLER_ID;
		v_REC.SOURCE_ID := :new.SOURCE_ID;
		v_REC.SINK_ID := :new.SINK_ID;
		v_REC.POR_ID := :new.POR_ID;
		v_REC.POD_ID := :new.POD_ID;
		v_REC.SC_ID := :new.SC_ID;
		v_REC.AGREEMENT_TYPE := :new.AGREEMENT_TYPE;
		v_REC.APPROVAL_TYPE := :new.APPROVAL_TYPE;
		v_REC.MARKET_TYPE := :new.MARKET_TYPE;
		v_REC.LOSS_OPTION := :new.LOSS_OPTION;
		v_REC.CONTRACT_FILE_NAME := :new.CONTRACT_FILE_NAME;
		v_REC.PIPELINE_ID := :new.PIPELINE_ID;
		v_REC.PIPELINE_TARIFF_TYPE := :new.PIPELINE_TARIFF_TYPE;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_INTERCHANGE_CONTRACT_FIELD( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -650 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.CONTRACT_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_INVOICE_GROUP
	AFTER INSERT OR UPDATE OR DELETE ON INVOICE_GROUP
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC INVOICE_GROUP%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -640, :old.INVOICE_GROUP_ID, :old.INVOICE_GROUP_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.INVOICE_GROUP_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -640);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.INVOICE_GROUP_ID := :new.INVOICE_GROUP_ID;
		v_REC.INVOICE_GROUP_NAME := :new.INVOICE_GROUP_NAME;
		v_REC.INVOICE_GROUP_ALIAS := :new.INVOICE_GROUP_ALIAS;
		v_REC.INVOICE_GROUP_DESC := :new.INVOICE_GROUP_DESC;
		v_REC.DISPLAY_ORDER := :new.DISPLAY_ORDER;
		v_REC.SHOW_TITLE_ON_INVOICE := :new.SHOW_TITLE_ON_INVOICE;
		v_REC.SHOW_SUBTOTAL_ON_INVOICE := :new.SHOW_SUBTOTAL_ON_INVOICE;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_INVOICE_GROUP_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -640 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.INVOICE_GROUP_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_IT_COMMODITY
	AFTER INSERT OR UPDATE OR DELETE ON IT_COMMODITY
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC IT_COMMODITY%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -330, :old.COMMODITY_ID, :old.COMMODITY_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.COMMODITY_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -330);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.COMMODITY_ID := :new.COMMODITY_ID;
		v_REC.COMMODITY_NAME := :new.COMMODITY_NAME;
		v_REC.COMMODITY_ALIAS := :new.COMMODITY_ALIAS;
		v_REC.COMMODITY_DESC := :new.COMMODITY_DESC;
		v_REC.COMMODITY_TYPE := :new.COMMODITY_TYPE;
		v_REC.COMMODITY_UNIT := :new.COMMODITY_UNIT;
		v_REC.COMMODITY_UNIT_FORMAT := :new.COMMODITY_UNIT_FORMAT;
		v_REC.COMMODITY_PRICE_UNIT := :new.COMMODITY_PRICE_UNIT;
		v_REC.COMMODITY_PRICE_FORMAT := :new.COMMODITY_PRICE_FORMAT;
		v_REC.IS_VIRTUAL := :new.IS_VIRTUAL;
		v_REC.MARKET_TYPE := :new.MARKET_TYPE;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_IT_COMMODITY_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -330 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.COMMODITY_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_JOB_THREAD
	AFTER INSERT OR UPDATE OR DELETE ON JOB_THREAD
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC JOB_THREAD%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -1070, :old.JOB_THREAD_ID, :old.JOB_THREAD_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.JOB_THREAD_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -1070);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.JOB_THREAD_ID := :new.JOB_THREAD_ID;
		v_REC.JOB_THREAD_NAME := :new.JOB_THREAD_NAME;
		v_REC.JOB_THREAD_ALIAS := :new.JOB_THREAD_ALIAS;
		v_REC.JOB_THREAD_DESC := :new.JOB_THREAD_DESC;
		v_REC.JOB_CLASS := :new.JOB_CLASS;
		v_REC.IS_SNOOZED := :new.IS_SNOOZED;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_JOB_THREAD_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -1070 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.JOB_THREAD_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_LOAD_PROFILE
	AFTER INSERT OR UPDATE OR DELETE ON LOAD_PROFILE
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC LOAD_PROFILE%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -840, :old.PROFILE_ID, :old.PROFILE_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.PROFILE_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -840);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.PROFILE_LIBRARY_ID := :new.PROFILE_LIBRARY_ID;
		v_REC.PROFILE_ID := :new.PROFILE_ID;
		v_REC.PROFILE_NAME := :new.PROFILE_NAME;
		v_REC.PROFILE_ALIAS := :new.PROFILE_ALIAS;
		v_REC.PROFILE_DESC := :new.PROFILE_DESC;
		v_REC.PROFILE_TYPE := :new.PROFILE_TYPE;
		v_REC.PROFILE_OPERATION := :new.PROFILE_OPERATION;
		v_REC.PROFILE_ORIGIN := :new.PROFILE_ORIGIN;
		v_REC.PROFILE_RATE_CLASS := :new.PROFILE_RATE_CLASS;
		v_REC.PROFILE_DAY_TYPE := :new.PROFILE_DAY_TYPE;
		v_REC.PROFILE_ACCOUNT_REF := :new.PROFILE_ACCOUNT_REF;
		v_REC.PROFILE_METER_REF := :new.PROFILE_METER_REF;
		v_REC.PROFILE_SIC_CODE := :new.PROFILE_SIC_CODE;
		v_REC.PROFILE_SEASON := :new.PROFILE_SEASON;
		v_REC.PROFILE_SYSTEM_LOAD := :new.PROFILE_SYSTEM_LOAD;
		v_REC.PROFILE_ADJUSTMENT_OPTION := :new.PROFILE_ADJUSTMENT_OPTION;
		v_REC.PROFILE_STATION_ID := :new.PROFILE_STATION_ID;
		v_REC.PROFILE_TEMPLATE_ID := :new.PROFILE_TEMPLATE_ID;
		v_REC.PROFILE_SOURCE_BEGIN_DATE := :new.PROFILE_SOURCE_BEGIN_DATE;
		v_REC.PROFILE_SOURCE_END_DATE := :new.PROFILE_SOURCE_END_DATE;
		v_REC.PROFILE_SOURCE_ID := :new.PROFILE_SOURCE_ID;
		v_REC.PROFILE_INTERVAL := :new.PROFILE_INTERVAL;
		v_REC.PROFILE_SOURCE_VERSION := :new.PROFILE_SOURCE_VERSION;
		v_REC.PROFILE_BREAKPOINT_INTERVAL := :new.PROFILE_BREAKPOINT_INTERVAL;
		v_REC.IS_EXTERNAL_PROFILE := :new.IS_EXTERNAL_PROFILE;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_LOAD_PROFILE_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -840 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.PROFILE_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_LOAD_PROFILE_LIBRARY
	AFTER INSERT OR UPDATE OR DELETE ON LOAD_PROFILE_LIBRARY
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC LOAD_PROFILE_LIBRARY%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -1200, :old.PROFILE_LIBRARY_ID, :old.PROFILE_LIBRARY_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.PROFILE_LIBRARY_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -1200);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.PROFILE_LIBRARY_ID := :new.PROFILE_LIBRARY_ID;
		v_REC.PROFILE_LIBRARY_NAME := :new.PROFILE_LIBRARY_NAME;
		v_REC.PROFILE_LIBRARY_ALIAS := :new.PROFILE_LIBRARY_ALIAS;
		v_REC.PROFILE_LIBRARY_DESC := :new.PROFILE_LIBRARY_DESC;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_LOAD_PROFILE_LIBRARY_FIELD( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -1200 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.PROFILE_LIBRARY_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_LOSS_FACTOR
	AFTER INSERT OR UPDATE OR DELETE ON LOSS_FACTOR
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC LOSS_FACTOR%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -1080, :old.LOSS_FACTOR_ID, :old.LOSS_FACTOR_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.LOSS_FACTOR_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -1080);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.LOSS_FACTOR_ID := :new.LOSS_FACTOR_ID;
		v_REC.LOSS_FACTOR_NAME := :new.LOSS_FACTOR_NAME;
		v_REC.LOSS_FACTOR_ALIAS := :new.LOSS_FACTOR_ALIAS;
		v_REC.LOSS_FACTOR_DESC := :new.LOSS_FACTOR_DESC;
		v_REC.EXTERNAL_IDENTIFIER := :new.EXTERNAL_IDENTIFIER;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_LOSS_FACTOR_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -1080 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.LOSS_FACTOR_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_MARKET_PRICE
	AFTER INSERT OR UPDATE OR DELETE ON MARKET_PRICE
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC MARKET_PRICE%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -610, :old.MARKET_PRICE_ID, :old.MARKET_PRICE_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.MARKET_PRICE_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -610);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.MARKET_PRICE_ID := :new.MARKET_PRICE_ID;
		v_REC.MARKET_PRICE_NAME := :new.MARKET_PRICE_NAME;
		v_REC.MARKET_PRICE_ALIAS := :new.MARKET_PRICE_ALIAS;
		v_REC.MARKET_PRICE_DESC := :new.MARKET_PRICE_DESC;
		v_REC.MARKET_PRICE_TYPE := :new.MARKET_PRICE_TYPE;
		v_REC.MARKET_PRICE_INTERVAL := :new.MARKET_PRICE_INTERVAL;
		v_REC.MARKET_TYPE := :new.MARKET_TYPE;
		v_REC.COMMODITY_ID := :new.COMMODITY_ID;
		v_REC.SERVICE_POINT_TYPE := :new.SERVICE_POINT_TYPE;
		v_REC.EXTERNAL_IDENTIFIER := :new.EXTERNAL_IDENTIFIER;
		v_REC.EDC_ID := :new.EDC_ID;
		v_REC.SC_ID := :new.SC_ID;
		v_REC.POD_ID := :new.POD_ID;
		v_REC.ZOD_ID := :new.ZOD_ID;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_MARKET_PRICE_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -610 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.MARKET_PRICE_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_MEASUREMENT_SOURCE
	AFTER INSERT OR UPDATE OR DELETE ON MEASUREMENT_SOURCE
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC MEASUREMENT_SOURCE%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -1040, :old.MEASUREMENT_SOURCE_ID, :old.MEASUREMENT_SOURCE_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.MEASUREMENT_SOURCE_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -1040);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.MEASUREMENT_SOURCE_ID := :new.MEASUREMENT_SOURCE_ID;
		v_REC.MEASUREMENT_SOURCE_NAME := :new.MEASUREMENT_SOURCE_NAME;
		v_REC.MEASUREMENT_SOURCE_ALIAS := :new.MEASUREMENT_SOURCE_ALIAS;
		v_REC.MEASUREMENT_SOURCE_DESC := :new.MEASUREMENT_SOURCE_DESC;
		v_REC.MEASUREMENT_SOURCE_TYPE := :new.MEASUREMENT_SOURCE_TYPE;
		v_REC.MEASUREMENT_SOURCE_INTERVAL := :new.MEASUREMENT_SOURCE_INTERVAL;
		v_REC.METER_TYPE := :new.METER_TYPE;
		v_REC.BEGIN_DATE := :new.BEGIN_DATE;
		v_REC.END_DATE := :new.END_DATE;
		v_REC.EXTERNAL_SYSTEM_ID := :new.EXTERNAL_SYSTEM_ID;
		v_REC.EXTERNAL_IDENTIFIER := :new.EXTERNAL_IDENTIFIER;
		v_REC.PRECISION := :new.PRECISION;
		v_REC.UOM := :new.UOM;
		v_REC.POLLING_TIME := :new.POLLING_TIME;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_MEASUREMENT_SOURCE_FIELDS_( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -1040 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.MEASUREMENT_SOURCE_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_METER
	AFTER INSERT OR UPDATE OR DELETE ON METER
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC METER%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -190, :old.METER_ID, :old.METER_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.METER_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -190);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.MRSP_ID := :new.MRSP_ID;
		v_REC.METER_ID := :new.METER_ID;
		v_REC.METER_NAME := :new.METER_NAME;
		v_REC.METER_ALIAS := :new.METER_ALIAS;
		v_REC.METER_DESC := :new.METER_DESC;
		v_REC.METER_EXTERNAL_IDENTIFIER := :new.METER_EXTERNAL_IDENTIFIER;
		v_REC.METER_STATUS := :new.METER_STATUS;
		v_REC.METER_INTERVAL := :new.METER_INTERVAL;
		v_REC.METER_TYPE := :new.METER_TYPE;
		v_REC.METER_UNIT := :new.METER_UNIT;
		v_REC.IS_EXTERNAL_INTERVAL_USAGE := :new.IS_EXTERNAL_INTERVAL_USAGE;
		v_REC.IS_EXTERNAL_BILLED_USAGE := :new.IS_EXTERNAL_BILLED_USAGE;
		v_REC.IS_EXTERNAL_FORECAST := :new.IS_EXTERNAL_FORECAST;
		v_REC.USE_TOU_USAGE_FACTOR := :new.USE_TOU_USAGE_FACTOR;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_METER_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -190 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.METER_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_MRSP
	AFTER INSERT OR UPDATE OR DELETE ON METER_READING_SERVICE_PROVIDER
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC METER_READING_SERVICE_PROVIDER%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -120, :old.MRSP_ID, :old.MRSP_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.MRSP_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -120);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.MRSP_ID := :new.MRSP_ID;
		v_REC.MRSP_NAME := :new.MRSP_NAME;
		v_REC.MRSP_ALIAS := :new.MRSP_ALIAS;
		v_REC.MRSP_DESC := :new.MRSP_DESC;
		v_REC.MRSP_DUNS_NUMBER := :new.MRSP_DUNS_NUMBER;
		v_REC.MRSP_STATUS := :new.MRSP_STATUS;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_MRSP_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -120 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.MRSP_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_OASIS_NODE
	AFTER INSERT OR UPDATE OR DELETE ON OASIS_NODE
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC OASIS_NODE%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -990, :old.OASIS_NODE_ID, :old.OASIS_NODE_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.OASIS_NODE_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -990);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.OASIS_NODE_ID := :new.OASIS_NODE_ID;
		v_REC.OASIS_NODE_NAME := :new.OASIS_NODE_NAME;
		v_REC.OASIS_NODE_ALIAS := :new.OASIS_NODE_ALIAS;
		v_REC.OASIS_NODE_DESC := :new.OASIS_NODE_DESC;
		v_REC.URL := :new.URL;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_OASIS_NODE_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -990 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.OASIS_NODE_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_PATH
	AFTER INSERT OR UPDATE OR DELETE ON TX_PATH
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC TX_PATH%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -350, :old.PATH_ID, :old.PATH_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.PATH_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -350);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.PATH_ID := :new.PATH_ID;
		v_REC.PATH_NAME := :new.PATH_NAME;
		v_REC.PATH_ALIAS := :new.PATH_ALIAS;
		v_REC.PATH_DESC := :new.PATH_DESC;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_PATH_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -350 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.PATH_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_PERIOD
	AFTER INSERT OR UPDATE OR DELETE ON PERIOD
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC PERIOD%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -790, :old.PERIOD_ID, :old.PERIOD_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.PERIOD_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -790);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.PERIOD_ID := :new.PERIOD_ID;
		v_REC.PERIOD_NAME := :new.PERIOD_NAME;
		v_REC.PERIOD_ALIAS := :new.PERIOD_ALIAS;
		v_REC.PERIOD_DESC := :new.PERIOD_DESC;
		v_REC.PERIOD_COLOR := :new.PERIOD_COLOR;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_PERIOD_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -790 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.PERIOD_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_PIPELINE
	AFTER INSERT OR UPDATE OR DELETE ON PIPELINE
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC PIPELINE%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -290, :old.PIPELINE_ID, :old.PIPELINE_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.PIPELINE_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -290);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.PIPELINE_ID := :new.PIPELINE_ID;
		v_REC.PIPELINE_NAME := :new.PIPELINE_NAME;
		v_REC.PIPELINE_ALIAS := :new.PIPELINE_ALIAS;
		v_REC.PIPELINE_DESC := :new.PIPELINE_DESC;
		v_REC.PIPELINE_STATUS := :new.PIPELINE_STATUS;
		v_REC.EXTERNAL_IDENTIFIER := :new.EXTERNAL_IDENTIFIER;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_PIPELINE_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -290 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.PIPELINE_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_POOL
	AFTER INSERT OR UPDATE OR DELETE ON POOL
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC POOL%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -230, :old.POOL_ID, :old.POOL_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.POOL_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -230);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.POOL_ID := :new.POOL_ID;
		v_REC.POOL_NAME := :new.POOL_NAME;
		v_REC.POOL_ALIAS := :new.POOL_ALIAS;
		v_REC.POOL_DESC := :new.POOL_DESC;
		v_REC.POOL_EXTERNAL_IDENTIFIER := :new.POOL_EXTERNAL_IDENTIFIER;
		v_REC.POOL_STATUS := :new.POOL_STATUS;
		v_REC.POOL_CATEGORY := :new.POOL_CATEGORY;
		v_REC.POOL_EXCLUDE_LOAD_SCHEDULE := :new.POOL_EXCLUDE_LOAD_SCHEDULE;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_POOL_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -230 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.POOL_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_PORTFOLIO
	AFTER INSERT OR UPDATE OR DELETE ON PORTFOLIO
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC PORTFOLIO%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -720, :old.PORTFOLIO_ID, :old.PORTFOLIO_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.PORTFOLIO_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -720);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.PORTFOLIO_ID := :new.PORTFOLIO_ID;
		v_REC.PORTFOLIO_NAME := :new.PORTFOLIO_NAME;
		v_REC.PORTFOLIO_ALIAS := :new.PORTFOLIO_ALIAS;
		v_REC.PORTFOLIO_DESC := :new.PORTFOLIO_DESC;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_PORTFOLIO_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -720 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.PORTFOLIO_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_PRODUCT
	AFTER INSERT OR UPDATE OR DELETE ON PRODUCT
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC PRODUCT%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -620, :old.PRODUCT_ID, :old.PRODUCT_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.PRODUCT_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -620);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.PRODUCT_ID := :new.PRODUCT_ID;
		v_REC.PRODUCT_NAME := :new.PRODUCT_NAME;
		v_REC.PRODUCT_ALIAS := :new.PRODUCT_ALIAS;
		v_REC.PRODUCT_DESC := :new.PRODUCT_DESC;
		v_REC.PRODUCT_EXTERNAL_IDENTIFIER := :new.PRODUCT_EXTERNAL_IDENTIFIER;
		v_REC.PRODUCT_CATEGORY := :new.PRODUCT_CATEGORY;
		v_REC.BEGIN_DATE := :new.BEGIN_DATE;
		v_REC.END_DATE := :new.END_DATE;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_PRODUCT_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -620 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.PRODUCT_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_PROGRAM
	AFTER INSERT OR UPDATE OR DELETE ON PROGRAM
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC PROGRAM%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -1140, :old.PROGRAM_ID, :old.PROGRAM_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.PROGRAM_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -1140);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.PROGRAM_ID := :new.PROGRAM_ID;
		v_REC.PROGRAM_NAME := :new.PROGRAM_NAME;
		v_REC.PROGRAM_ALIAS := :new.PROGRAM_ALIAS;
		v_REC.PROGRAM_DESC := :new.PROGRAM_DESC;
		v_REC.EXTERNAL_IDENTIFIER := :new.EXTERNAL_IDENTIFIER;
		v_REC.PROGRAM_TYPE := :new.PROGRAM_TYPE;
		v_REC.PROGRAM_INTERVAL := :new.PROGRAM_INTERVAL;
		v_REC.CUSTOMER_TYPE := :new.CUSTOMER_TYPE;
		v_REC.MAX_DURATION_HOUR := :new.MAX_DURATION_HOUR;
		v_REC.MAX_DURATION_MINUTE := :new.MAX_DURATION_MINUTE;
		v_REC.MIN_OFF_TIME_HOUR := :new.MIN_OFF_TIME_HOUR;
		v_REC.MIN_OFF_TIME_MINUTE := :new.MIN_OFF_TIME_MINUTE;
		v_REC.DEGREE_INCREASE := :new.DEGREE_INCREASE;
		v_REC.DEGREE_DECREASE := :new.DEGREE_DECREASE;
		v_REC.ALLOW_CUSTOMER_OVERRIDE := :new.ALLOW_CUSTOMER_OVERRIDE;
		v_REC.DEFAULT_OPT_OUT_PCT := :new.DEFAULT_OPT_OUT_PCT;
		v_REC.DEFAULT_OVERRIDE_PCT := :new.DEFAULT_OVERRIDE_PCT;
		v_REC.USE_DEFAULT_OPT_OUT_OVERRIDE := :new.USE_DEFAULT_OPT_OUT_OVERRIDE;
		v_REC.VALIDATION_METHOD := :new.VALIDATION_METHOD;
		v_REC.TRANSACTION_ID := :new.TRANSACTION_ID;
		v_REC.COMPONENT_ID := :new.COMPONENT_ID;
		v_REC.SIGNAL_TYPE := :new.SIGNAL_TYPE;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_PROGRAM_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -1140 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.PROGRAM_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_PROXY_DAY_METHOD
	AFTER INSERT OR UPDATE OR DELETE ON PROXY_DAY_METHOD
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC PROXY_DAY_METHOD%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -1190, :old.PROXY_DAY_METHOD_ID, :old.PROXY_DAY_METHOD_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.PROXY_DAY_METHOD_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -1190);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.PROXY_DAY_METHOD_ID := :new.PROXY_DAY_METHOD_ID;
		v_REC.PROXY_DAY_METHOD_NAME := :new.PROXY_DAY_METHOD_NAME;
		v_REC.PROXY_DAY_METHOD_ALIAS := :new.PROXY_DAY_METHOD_ALIAS;
		v_REC.PROXY_DAY_METHOD_DESC := :new.PROXY_DAY_METHOD_DESC;
		v_REC.TEMPLATE_ID := :new.TEMPLATE_ID;
		v_REC.COMPARATIVE_VALUE := :new.COMPARATIVE_VALUE;
		v_REC.STATION_ID := :new.STATION_ID;
		v_REC.PARAMETER_ID := :new.PARAMETER_ID;
		v_REC.SYSTEM_LOAD_ID := :new.SYSTEM_LOAD_ID;
		v_REC.LOOKUP_TIME_HORIZON := :new.LOOKUP_TIME_HORIZON;
		v_REC.TIME_HORIZON_SHIFT := :new.TIME_HORIZON_SHIFT;
		v_REC.LOOKUP_CANDIDATE_LIMIT := :new.LOOKUP_CANDIDATE_LIMIT;
		v_REC.CANDIDATE_DELTA_THRESHOLD := :new.CANDIDATE_DELTA_THRESHOLD;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		v_REC.HOLIDAY_SET_ID := :new.HOLIDAY_SET_ID;
		-- use record
		v_MAP := IO_UTIL.GET_PROXY_DAY_METHOD_FIELDS_MA( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -1190 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.PROXY_DAY_METHOD_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_PSE
	AFTER INSERT OR UPDATE OR DELETE ON PURCHASING_SELLING_ENTITY
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC PURCHASING_SELLING_ENTITY%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -160, :old.PSE_ID, :old.PSE_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.PSE_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -160);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.PSE_ID := :new.PSE_ID;
		v_REC.PSE_NAME := :new.PSE_NAME;
		v_REC.PSE_ALIAS := :new.PSE_ALIAS;
		v_REC.PSE_DESC := :new.PSE_DESC;
		v_REC.PSE_NERC_CODE := :new.PSE_NERC_CODE;
		v_REC.PSE_STATUS := :new.PSE_STATUS;
		v_REC.PSE_DUNS_NUMBER := :new.PSE_DUNS_NUMBER;
		v_REC.PSE_BANK := :new.PSE_BANK;
		v_REC.PSE_ACH_NUMBER := :new.PSE_ACH_NUMBER;
		v_REC.PSE_TYPE := :new.PSE_TYPE;
		v_REC.PSE_EXTERNAL_IDENTIFIER := :new.PSE_EXTERNAL_IDENTIFIER;
		v_REC.PSE_IS_RETAIL_AGGREGATOR := :new.PSE_IS_RETAIL_AGGREGATOR;
		v_REC.PSE_IS_BACKUP_GENERATION := :new.PSE_IS_BACKUP_GENERATION;
		v_REC.PSE_EXCLUDE_LOAD_SCHEDULE := :new.PSE_EXCLUDE_LOAD_SCHEDULE;
		v_REC.IS_BILLING_ENTITY := :new.IS_BILLING_ENTITY;
		v_REC.TIME_ZONE := :new.TIME_ZONE;
		v_REC.STATEMENT_INTERVAL := :new.STATEMENT_INTERVAL;
		v_REC.INVOICE_INTERVAL := :new.INVOICE_INTERVAL;
		v_REC.WEEK_BEGIN := :new.WEEK_BEGIN;
		v_REC.INVOICE_LINE_ITEM_OPTION := :new.INVOICE_LINE_ITEM_OPTION;
		v_REC.INVOICE_EMAIL_SUBJECT := :new.INVOICE_EMAIL_SUBJECT;
		v_REC.INVOICE_EMAIL_PRIORITY := :new.INVOICE_EMAIL_PRIORITY;
		v_REC.INVOICE_EMAIL_BODY := :new.INVOICE_EMAIL_BODY;
		v_REC.INVOICE_EMAIL_BODY_MIME_TYPE := :new.INVOICE_EMAIL_BODY_MIME_TYPE;
		v_REC.SCHEDULE_NAME_PREFIX := :new.SCHEDULE_NAME_PREFIX;
		v_REC.SCHEDULE_FORMAT := :new.SCHEDULE_FORMAT;
		v_REC.SCHEDULE_INTERVAL := :new.SCHEDULE_INTERVAL;
		v_REC.LOAD_ROUNDING_PREFERENCE := :new.LOAD_ROUNDING_PREFERENCE;
		v_REC.LOSS_ROUNDING_PREFERENCE := :new.LOSS_ROUNDING_PREFERENCE;
		v_REC.CREATE_TX_LOSS_SCHEDULE := :new.CREATE_TX_LOSS_SCHEDULE;
		v_REC.CREATE_DX_LOSS_SCHEDULE := :new.CREATE_DX_LOSS_SCHEDULE;
		v_REC.CREATE_UFE_SCHEDULE := :new.CREATE_UFE_SCHEDULE;
		v_REC.MINIMUM_SCHEDULE_AMT := :new.MINIMUM_SCHEDULE_AMT;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_PSE_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -160 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.PSE_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_QUOTE_REQUEST
	AFTER INSERT OR UPDATE OR DELETE ON QUOTE_REQUEST
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC QUOTE_REQUEST%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -220, :old.QUOTE_ID, :old.QUOTE_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.QUOTE_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -220);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.QUOTE_ID := :new.QUOTE_ID;
		v_REC.QUOTE_NAME := :new.QUOTE_NAME;
		v_REC.QUOTE_ALIAS := :new.QUOTE_ALIAS;
		v_REC.QUOTE_DESC := :new.QUOTE_DESC;
		v_REC.CAMPAIGN_NAME := :new.CAMPAIGN_NAME;
		v_REC.CUSTOMER_NAME := :new.CUSTOMER_NAME;
		v_REC.CUSTOMER_TYPE := :new.CUSTOMER_TYPE;
		v_REC.CUSTOMER_REP_NAME := :new.CUSTOMER_REP_NAME;
		v_REC.EDC_ID := :new.EDC_ID;
		v_REC.SERVICE_POINT_ID := :new.SERVICE_POINT_ID;
		v_REC.CUSTOMER_CLASS := :new.CUSTOMER_CLASS;
		v_REC.EDC_ACCOUNT_NUMBER := :new.EDC_ACCOUNT_NUMBER;
		v_REC.QUOTE_EFFECTIVE_DATE := :new.QUOTE_EFFECTIVE_DATE;
		v_REC.QUOTE_EXPIRATION_DATE := :new.QUOTE_EXPIRATION_DATE;
		v_REC.SERVICE_BEGIN_DATE := :new.SERVICE_BEGIN_DATE;
		v_REC.SERVICE_END_DATE := :new.SERVICE_END_DATE;
		v_REC.QUOTE_TYPE := :new.QUOTE_TYPE;
		v_REC.QUOTE_STATUS := :new.QUOTE_STATUS;
		v_REC.STATION_ID := :new.STATION_ID;
		v_REC.NUMBER_OF_CUSTOMERS := :new.NUMBER_OF_CUSTOMERS;
		v_REC.SIGNING_PROBABILITY := :new.SIGNING_PROBABILITY;
		v_REC.QUOTE_NOTES := :new.QUOTE_NOTES;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_QUOTE_REQUEST_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -220 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.QUOTE_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_REACTOR_PROCEDURE
	AFTER INSERT OR UPDATE OR DELETE ON REACTOR_PROCEDURE
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC REACTOR_PROCEDURE%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -1060, :old.REACTOR_PROCEDURE_ID, :old.REACTOR_PROCEDURE_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.REACTOR_PROCEDURE_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -1060);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.REACTOR_PROCEDURE_ID := :new.REACTOR_PROCEDURE_ID;
		v_REC.REACTOR_PROCEDURE_NAME := :new.REACTOR_PROCEDURE_NAME;
		v_REC.REACTOR_PROCEDURE_ALIAS := :new.REACTOR_PROCEDURE_ALIAS;
		v_REC.REACTOR_PROCEDURE_DESC := :new.REACTOR_PROCEDURE_DESC;
		v_REC.TABLE_ID := :new.TABLE_ID;
		v_REC.PROCEDURE_NAME := :new.PROCEDURE_NAME;
		v_REC.JOB_THREAD_ID := :new.JOB_THREAD_ID;
		v_REC.JOB_COMMENTS := :new.JOB_COMMENTS;
		v_REC.CALL_ORDER := :new.CALL_ORDER;
		v_REC.SKIP_WHEN_FORMULA := :new.SKIP_WHEN_FORMULA;
		v_REC.TIME_ZONE := :new.TIME_ZONE;
		v_REC.IS_IMMEDIATE := :new.IS_IMMEDIATE;
		v_REC.IS_ENABLED := :new.IS_ENABLED;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_REACTOR_PROCEDURE_FIELDS_M( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -1060 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.REACTOR_PROCEDURE_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_RESOURCE_GROUP
	AFTER INSERT OR UPDATE OR DELETE ON SUPPLY_RESOURCE_GROUP
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC SUPPLY_RESOURCE_GROUP%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -750, :old.RESOURCE_GROUP_ID, :old.RESOURCE_GROUP_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.RESOURCE_GROUP_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -750);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.RESOURCE_GROUP_ID := :new.RESOURCE_GROUP_ID;
		v_REC.RESOURCE_GROUP_NAME := :new.RESOURCE_GROUP_NAME;
		v_REC.RESOURCE_GROUP_ALIAS := :new.RESOURCE_GROUP_ALIAS;
		v_REC.RESOURCE_GROUP_DESC := :new.RESOURCE_GROUP_DESC;
		v_REC.SERVICE_ZONE_ID := :new.SERVICE_ZONE_ID;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_RESOURCE_GROUP_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -750 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.RESOURCE_GROUP_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_SC
	AFTER INSERT OR UPDATE OR DELETE ON SCHEDULE_COORDINATOR
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC SCHEDULE_COORDINATOR%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -130, :old.SC_ID, :old.SC_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.SC_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -130);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.SC_ID := :new.SC_ID;
		v_REC.SC_NAME := :new.SC_NAME;
		v_REC.SC_ALIAS := :new.SC_ALIAS;
		v_REC.SC_DESC := :new.SC_DESC;
		v_REC.SC_NERC_CODE := :new.SC_NERC_CODE;
		v_REC.SC_DUNS_NUMBER := :new.SC_DUNS_NUMBER;
		v_REC.SC_STATUS := :new.SC_STATUS;
		v_REC.SC_EXTERNAL_IDENTIFIER := :new.SC_EXTERNAL_IDENTIFIER;
		v_REC.SC_SCHEDULE_NAME_PREFIX := :new.SC_SCHEDULE_NAME_PREFIX;
		v_REC.SC_SCHEDULE_FORMAT := :new.SC_SCHEDULE_FORMAT;
		v_REC.SC_SCHEDULE_INTERVAL := :new.SC_SCHEDULE_INTERVAL;
		v_REC.SC_LOAD_ROUNDING_PREFERENCE := :new.SC_LOAD_ROUNDING_PREFERENCE;
		v_REC.SC_LOSS_ROUNDING_PREFERENCE := :new.SC_LOSS_ROUNDING_PREFERENCE;
		v_REC.SC_CREATE_TX_LOSS_SCHEDULE := :new.SC_CREATE_TX_LOSS_SCHEDULE;
		v_REC.SC_CREATE_DX_LOSS_SCHEDULE := :new.SC_CREATE_DX_LOSS_SCHEDULE;
		v_REC.SC_CREATE_UFE_SCHEDULE := :new.SC_CREATE_UFE_SCHEDULE;
		v_REC.SC_MARKET_PRICE_ID := :new.SC_MARKET_PRICE_ID;
		v_REC.SC_MINIMUM_SCHEDULE_AMT := :new.SC_MINIMUM_SCHEDULE_AMT;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_SC_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -130 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.SC_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_SCENARIO
	AFTER INSERT OR UPDATE OR DELETE ON SCENARIO
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC SCENARIO%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -860, :old.SCENARIO_ID, :old.SCENARIO_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.SCENARIO_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -860);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.SCENARIO_ID := :new.SCENARIO_ID;
		v_REC.SCENARIO_NAME := :new.SCENARIO_NAME;
		v_REC.SCENARIO_ALIAS := :new.SCENARIO_ALIAS;
		v_REC.SCENARIO_DESC := :new.SCENARIO_DESC;
		v_REC.SCENARIO_CATEGORY := :new.SCENARIO_CATEGORY;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_SCENARIO_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -860 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.SCENARIO_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_SCHEDULE_GROUP
	AFTER INSERT OR UPDATE OR DELETE ON SCHEDULE_GROUP
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC SCHEDULE_GROUP%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -480, :old.SCHEDULE_GROUP_ID, :old.SCHEDULE_GROUP_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.SCHEDULE_GROUP_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -480);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.SCHEDULE_GROUP_ID := :new.SCHEDULE_GROUP_ID;
		v_REC.SCHEDULE_GROUP_NAME := :new.SCHEDULE_GROUP_NAME;
		v_REC.SCHEDULE_GROUP_ALIAS := :new.SCHEDULE_GROUP_ALIAS;
		v_REC.SCHEDULE_GROUP_DESC := :new.SCHEDULE_GROUP_DESC;
		v_REC.SERVICE_ZONE_ID := :new.SERVICE_ZONE_ID;
		v_REC.SC_ID := :new.SC_ID;
		v_REC.SERVICE_POINT_ID := :new.SERVICE_POINT_ID;
		v_REC.METER_TYPE := :new.METER_TYPE;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_SCHEDULE_GROUP_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -480 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.SCHEDULE_GROUP_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_SEASON
	AFTER INSERT OR UPDATE OR DELETE ON SEASON
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC SEASON%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -800, :old.SEASON_ID, :old.SEASON_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.SEASON_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -800);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.SEASON_ID := :new.SEASON_ID;
		v_REC.SEASON_NAME := :new.SEASON_NAME;
		v_REC.SEASON_ALIAS := :new.SEASON_ALIAS;
		v_REC.SEASON_DESC := :new.SEASON_DESC;
		v_REC.BEGIN_DATE := :new.BEGIN_DATE;
		v_REC.END_DATE := :new.END_DATE;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_SEASON_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -800 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.SEASON_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_SEGMENT
	AFTER INSERT OR UPDATE OR DELETE ON TX_SEGMENT
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC TX_SEGMENT%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -360, :old.SEGMENT_ID, :old.SEGMENT_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.SEGMENT_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -360);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.SEGMENT_ID := :new.SEGMENT_ID;
		v_REC.SEGMENT_NAME := :new.SEGMENT_NAME;
		v_REC.SEGMENT_ALIAS := :new.SEGMENT_ALIAS;
		v_REC.SEGMENT_DESC := :new.SEGMENT_DESC;
		v_REC.POR_ID := :new.POR_ID;
		v_REC.POD_ID := :new.POD_ID;
		v_REC.MW_LIMIT_1 := :new.MW_LIMIT_1;
		v_REC.MW_LIMIT_2 := :new.MW_LIMIT_2;
		v_REC.MW_LIMIT_3 := :new.MW_LIMIT_3;
		v_REC.LOSS_FACTOR := :new.LOSS_FACTOR;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_SEGMENT_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -360 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.SEGMENT_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_SERVICE_AREA
	AFTER INSERT OR UPDATE OR DELETE ON SERVICE_AREA
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC SERVICE_AREA%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -490, :old.SERVICE_AREA_ID, :old.SERVICE_AREA_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.SERVICE_AREA_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -490);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.SERVICE_AREA_ID := :new.SERVICE_AREA_ID;
		v_REC.SERVICE_AREA_NAME := :new.SERVICE_AREA_NAME;
		v_REC.SERVICE_AREA_ALIAS := :new.SERVICE_AREA_ALIAS;
		v_REC.SERVICE_AREA_DESC := :new.SERVICE_AREA_DESC;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_SERVICE_AREA_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -490 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.SERVICE_AREA_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_SERVICE_LOCATION
	AFTER INSERT OR UPDATE OR DELETE ON SERVICE_LOCATION
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC SERVICE_LOCATION%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -180, :old.SERVICE_LOCATION_ID, :old.SERVICE_LOCATION_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.SERVICE_LOCATION_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -180);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.SERVICE_LOCATION_ID := :new.SERVICE_LOCATION_ID;
		v_REC.SERVICE_LOCATION_NAME := :new.SERVICE_LOCATION_NAME;
		v_REC.SERVICE_LOCATION_ALIAS := :new.SERVICE_LOCATION_ALIAS;
		v_REC.SERVICE_LOCATION_DESC := :new.SERVICE_LOCATION_DESC;
		v_REC.LATITUDE := :new.LATITUDE;
		v_REC.LONGITUDE := :new.LONGITUDE;
		v_REC.TIME_ZONE := :new.TIME_ZONE;
		v_REC.EXTERNAL_IDENTIFIER := :new.EXTERNAL_IDENTIFIER;
		v_REC.IS_EXTERNAL_BILLED_USAGE := :new.IS_EXTERNAL_BILLED_USAGE;
		v_REC.IS_METER_ALLOCATION := :new.IS_METER_ALLOCATION;
		v_REC.SERVICE_POINT_ID := :new.SERVICE_POINT_ID;
		v_REC.WEATHER_STATION_ID := :new.WEATHER_STATION_ID;
		v_REC.BUSINESS_ROLLUP_ID := :new.BUSINESS_ROLLUP_ID;
		v_REC.GEOGRAPHIC_ROLLUP_ID := :new.GEOGRAPHIC_ROLLUP_ID;
		v_REC.SQUARE_FOOTAGE := :new.SQUARE_FOOTAGE;
		v_REC.ANNUAL_CONSUMPTION := :new.ANNUAL_CONSUMPTION;
		v_REC.SUMMER_CONSUMPTION := :new.SUMMER_CONSUMPTION;
		v_REC.SERVICE_ZONE_ID := :new.SERVICE_ZONE_ID;
		v_REC.SUB_STATION_ID := :new.SUB_STATION_ID;
		v_REC.FEEDER_ID := :new.FEEDER_ID;
		v_REC.FEEDER_SEGMENT_ID := :new.FEEDER_SEGMENT_ID;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_SERVICE_LOCATION_FIELDS_MA( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -180 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.SERVICE_LOCATION_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_SERVICE_POINT
	AFTER INSERT OR UPDATE OR DELETE ON SERVICE_POINT
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC SERVICE_POINT%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -210, :old.SERVICE_POINT_ID, :old.SERVICE_POINT_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.SERVICE_POINT_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -210);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.SERVICE_POINT_ID := :new.SERVICE_POINT_ID;
		v_REC.SERVICE_POINT_NAME := :new.SERVICE_POINT_NAME;
		v_REC.SERVICE_POINT_ALIAS := :new.SERVICE_POINT_ALIAS;
		v_REC.SERVICE_POINT_DESC := :new.SERVICE_POINT_DESC;
		v_REC.SERVICE_POINT_TYPE := :new.SERVICE_POINT_TYPE;
		v_REC.TP_ID := :new.TP_ID;
		v_REC.CA_ID := :new.CA_ID;
		v_REC.EDC_ID := :new.EDC_ID;
		v_REC.ROLLUP_ID := :new.ROLLUP_ID;
		v_REC.SERVICE_REGION_ID := :new.SERVICE_REGION_ID;
		v_REC.SERVICE_AREA_ID := :new.SERVICE_AREA_ID;
		v_REC.SERVICE_ZONE_ID := :new.SERVICE_ZONE_ID;
		v_REC.TIME_ZONE := :new.TIME_ZONE;
		v_REC.LATITUDE := :new.LATITUDE;
		v_REC.LONGITUDE := :new.LONGITUDE;
		v_REC.EXTERNAL_IDENTIFIER := :new.EXTERNAL_IDENTIFIER;
		v_REC.IS_INTERCONNECT := :new.IS_INTERCONNECT;
		v_REC.NODE_TYPE := :new.NODE_TYPE;
		v_REC.SERVICE_POINT_NERC_CODE := :new.SERVICE_POINT_NERC_CODE;
		v_REC.PIPELINE_ID := :new.PIPELINE_ID;
		v_REC.MILE_MARKER := :new.MILE_MARKER;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_SERVICE_POINT_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -210 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.SERVICE_POINT_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_SERVICE_REGION
	AFTER INSERT OR UPDATE OR DELETE ON SERVICE_REGION
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC SERVICE_REGION%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -340, :old.SERVICE_REGION_ID, :old.SERVICE_REGION_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.SERVICE_REGION_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -340);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.SERVICE_REGION_ID := :new.SERVICE_REGION_ID;
		v_REC.SERVICE_REGION_NAME := :new.SERVICE_REGION_NAME;
		v_REC.SERVICE_REGION_ALIAS := :new.SERVICE_REGION_ALIAS;
		v_REC.SERVICE_REGION_DESC := :new.SERVICE_REGION_DESC;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_SERVICE_REGION_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -340 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.SERVICE_REGION_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_SERVICE_TYPE
	AFTER INSERT OR UPDATE OR DELETE ON TX_SERVICE_TYPE
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC TX_SERVICE_TYPE%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -370, :old.SERVICE_TYPE_ID, :old.SERVICE_TYPE_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.SERVICE_TYPE_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -370);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.SERVICE_TYPE_ID := :new.SERVICE_TYPE_ID;
		v_REC.SERVICE_TYPE_NAME := :new.SERVICE_TYPE_NAME;
		v_REC.SERVICE_TYPE_ALIAS := :new.SERVICE_TYPE_ALIAS;
		v_REC.SERVICE_TYPE_DESC := :new.SERVICE_TYPE_DESC;
		v_REC.SERVICE_TYPE_CATEGORY := :new.SERVICE_TYPE_CATEGORY;
		v_REC.IS_FIRM := :new.IS_FIRM;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_SERVICE_TYPE_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -370 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.SERVICE_TYPE_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_SERVICE_ZONE
	AFTER INSERT OR UPDATE OR DELETE ON SERVICE_ZONE
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC SERVICE_ZONE%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -500, :old.SERVICE_ZONE_ID, :old.SERVICE_ZONE_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.SERVICE_ZONE_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -500);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.SERVICE_ZONE_ID := :new.SERVICE_ZONE_ID;
		v_REC.SERVICE_ZONE_NAME := :new.SERVICE_ZONE_NAME;
		v_REC.SERVICE_ZONE_ALIAS := :new.SERVICE_ZONE_ALIAS;
		v_REC.SERVICE_ZONE_DESC := :new.SERVICE_ZONE_DESC;
		v_REC.EXTERNAL_IDENTIFIER := :new.EXTERNAL_IDENTIFIER;
		v_REC.MARKET_PRICE_ID := :new.MARKET_PRICE_ID;
		v_REC.CONTROL_AREA_ID := :new.CONTROL_AREA_ID;
		v_REC.TIME_ZONE := :new.TIME_ZONE;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_SERVICE_ZONE_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -500 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.SERVICE_ZONE_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_SETTLEMENT_TYPE
	AFTER INSERT OR UPDATE OR DELETE ON SETTLEMENT_TYPE
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC SETTLEMENT_TYPE%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -880, :old.SETTLEMENT_TYPE_ID, :old.SETTLEMENT_TYPE_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.SETTLEMENT_TYPE_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -880);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.SETTLEMENT_TYPE_ID := :new.SETTLEMENT_TYPE_ID;
		v_REC.SETTLEMENT_TYPE_NAME := :new.SETTLEMENT_TYPE_NAME;
		v_REC.SETTLEMENT_TYPE_ALIAS := :new.SETTLEMENT_TYPE_ALIAS;
		v_REC.SETTLEMENT_TYPE_DESC := :new.SETTLEMENT_TYPE_DESC;
		v_REC.SETTLEMENT_TYPE_ORDER := :new.SETTLEMENT_TYPE_ORDER;
		v_REC.SERVICE_CODE := :new.SERVICE_CODE;
		v_REC.SCENARIO_ID := :new.SCENARIO_ID;
		v_REC.STATEMENT_TYPE_ID := :new.STATEMENT_TYPE_ID;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_SETTLEMENT_TYPE_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -880 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.SETTLEMENT_TYPE_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_STATEMENT_TYPE
	AFTER INSERT OR UPDATE OR DELETE ON STATEMENT_TYPE
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC STATEMENT_TYPE%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -740, :old.STATEMENT_TYPE_ID, :old.STATEMENT_TYPE_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.STATEMENT_TYPE_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -740);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.STATEMENT_TYPE_ID := :new.STATEMENT_TYPE_ID;
		v_REC.STATEMENT_TYPE_NAME := :new.STATEMENT_TYPE_NAME;
		v_REC.STATEMENT_TYPE_ALIAS := :new.STATEMENT_TYPE_ALIAS;
		v_REC.STATEMENT_TYPE_DESC := :new.STATEMENT_TYPE_DESC;
		v_REC.STATEMENT_TYPE_ORDER := :new.STATEMENT_TYPE_ORDER;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_STATEMENT_TYPE_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -740 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.STATEMENT_TYPE_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_SUB_STATION
	AFTER INSERT OR UPDATE OR DELETE ON TX_SUB_STATION
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC TX_SUB_STATION%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -380, :old.SUB_STATION_ID, :old.SUB_STATION_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.SUB_STATION_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -380);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.SUB_STATION_ID := :new.SUB_STATION_ID;
		v_REC.SUB_STATION_NAME := :new.SUB_STATION_NAME;
		v_REC.SUB_STATION_ALIAS := :new.SUB_STATION_ALIAS;
		v_REC.SUB_STATION_DESC := :new.SUB_STATION_DESC;
		v_REC.SUB_STATION_TYPE := :new.SUB_STATION_TYPE;
		v_REC.EXTERNAL_IDENTIFIER := :new.EXTERNAL_IDENTIFIER;
		v_REC.BEGIN_DATE := :new.BEGIN_DATE;
		v_REC.END_DATE := :new.END_DATE;
		v_REC.SERVICE_ZONE_ID := :new.SERVICE_ZONE_ID;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_SUB_STATION_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -380 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.SUB_STATION_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_SUB_STATION_METER
	AFTER INSERT OR UPDATE OR DELETE ON TX_SUB_STATION_METER
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC TX_SUB_STATION_METER%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -390, :old.METER_ID, :old.METER_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.METER_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -390);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.METER_ID := :new.METER_ID;
		v_REC.METER_NAME := :new.METER_NAME;
		v_REC.METER_ALIAS := :new.METER_ALIAS;
		v_REC.METER_DESC := :new.METER_DESC;
		v_REC.EXTERNAL_IDENTIFIER := :new.EXTERNAL_IDENTIFIER;
		v_REC.BEGIN_DATE := :new.BEGIN_DATE;
		v_REC.END_DATE := :new.END_DATE;
		v_REC.METER_TYPE := :new.METER_TYPE;
		v_REC.METER_SUB_TYPE := :new.METER_SUB_TYPE;
		v_REC.METER_CATEGORY := :new.METER_CATEGORY;
		v_REC.REF_METER_ID := :new.REF_METER_ID;
		v_REC.SUB_STATION_ID := :new.SUB_STATION_ID;
		v_REC.SERVICE_POINT_ID := :new.SERVICE_POINT_ID;
		v_REC.TRUNCATE_CARRY_FWD := :new.TRUNCATE_CARRY_FWD;
		v_REC.QUALITY_RATING := :new.QUALITY_RATING;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_SUB_STATION_METER_FIELDS_M( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -390 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.METER_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_SUB_STATION_METER_POINT
	AFTER INSERT OR UPDATE OR DELETE ON TX_SUB_STATION_METER_POINT
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC TX_SUB_STATION_METER_POINT%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -1030, :old.METER_POINT_ID, :old.METER_POINT_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.METER_POINT_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -1030);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.METER_POINT_ID := :new.METER_POINT_ID;
		v_REC.METER_POINT_NAME := :new.METER_POINT_NAME;
		v_REC.METER_POINT_ALIAS := :new.METER_POINT_ALIAS;
		v_REC.METER_POINT_DESC := :new.METER_POINT_DESC;
		v_REC.EXTERNAL_IDENTIFIER := :new.EXTERNAL_IDENTIFIER;
		v_REC.METER_POINT_CATEGORY := :new.METER_POINT_CATEGORY;
		v_REC.RETAIL_METER_ID := :new.RETAIL_METER_ID;
		v_REC.SUB_STATION_METER_ID := :new.SUB_STATION_METER_ID;
		v_REC.METER_POINT_INTERVAL := :new.METER_POINT_INTERVAL;
		v_REC.BEGIN_DATE := :new.BEGIN_DATE;
		v_REC.END_DATE := :new.END_DATE;
		v_REC.UOM := :new.UOM;
		v_REC.OPERATION_CODE := :new.OPERATION_CODE;
		v_REC.DIRECTION := :new.DIRECTION;
		v_REC.TOLERANCE := :new.TOLERANCE;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_SUB_STATION_METER_POINT_FI( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -1030 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.METER_POINT_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_SUPPLY_RESOURCE
	AFTER INSERT OR UPDATE OR DELETE ON SUPPLY_RESOURCE
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC SUPPLY_RESOURCE%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -670, :old.RESOURCE_ID, :old.RESOURCE_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.RESOURCE_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -670);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.RESOURCE_ID := :new.RESOURCE_ID;
		v_REC.RESOURCE_NAME := :new.RESOURCE_NAME;
		v_REC.RESOURCE_ALIAS := :new.RESOURCE_ALIAS;
		v_REC.RESOURCE_DESC := :new.RESOURCE_DESC;
		v_REC.RESOURCE_GROUP_ID := :new.RESOURCE_GROUP_ID;
		v_REC.SERVICE_POINT_ID := :new.SERVICE_POINT_ID;
		v_REC.HEAT_RATE_CURVE_ID := :new.HEAT_RATE_CURVE_ID;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_SUPPLY_RESOURCE_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -670 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.RESOURCE_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_SYSTEM_ACTION
	AFTER INSERT OR UPDATE OR DELETE ON SYSTEM_ACTION
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC SYSTEM_ACTION%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -890, :old.ACTION_ID, :old.ACTION_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.ACTION_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -890);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.ACTION_ID := :new.ACTION_ID;
		v_REC.ACTION_NAME := :new.ACTION_NAME;
		v_REC.ACTION_ALIAS := :new.ACTION_ALIAS;
		v_REC.ACTION_DESC := :new.ACTION_DESC;
		v_REC.ENTITY_DOMAIN_ID := :new.ENTITY_DOMAIN_ID;
		v_REC.MODULE := :new.MODULE;
		v_REC.ACTION_TYPE := :new.ACTION_TYPE;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_SYSTEM_ACTION_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -890 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.ACTION_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_SYSTEM_ALERT
	AFTER INSERT OR UPDATE OR DELETE ON SYSTEM_ALERT
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC SYSTEM_ALERT%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -960, :old.ALERT_ID, :old.ALERT_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.ALERT_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -960);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.ALERT_ID := :new.ALERT_ID;
		v_REC.ALERT_NAME := :new.ALERT_NAME;
		v_REC.ALERT_ALIAS := :new.ALERT_ALIAS;
		v_REC.ALERT_DESC := :new.ALERT_DESC;
		v_REC.ALERT_TYPE := :new.ALERT_TYPE;
		v_REC.ALERT_CATEGORY := :new.ALERT_CATEGORY;
		v_REC.ALERT_DURATION := :new.ALERT_DURATION;
		v_REC.IS_EMAIL_ALERT := :new.IS_EMAIL_ALERT;
		v_REC.IS_EMAIL_FIRST_ACK := :new.IS_EMAIL_FIRST_ACK;
		v_REC.ALERT_EMAIL_PRIORITY := :new.ALERT_EMAIL_PRIORITY;
		v_REC.ALERT_EMAIL_SUBJECT := :new.ALERT_EMAIL_SUBJECT;
		v_REC.ACK_EMAIL_PRIORITY := :new.ACK_EMAIL_PRIORITY;
		v_REC.ACK_EMAIL_SUBJECT := :new.ACK_EMAIL_SUBJECT;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_SYSTEM_ALERT_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -960 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.ALERT_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_SYSTEM_EVENT
	AFTER INSERT OR UPDATE OR DELETE ON SYSTEM_EVENT
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC SYSTEM_EVENT%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -520, :old.EVENT_ID, :old.EVENT_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.EVENT_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -520);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.EVENT_ID := :new.EVENT_ID;
		v_REC.EVENT_NAME := :new.EVENT_NAME;
		v_REC.EVENT_ALIAS := :new.EVENT_ALIAS;
		v_REC.EVENT_DESC := :new.EVENT_DESC;
		v_REC.EVENT_TYPE := :new.EVENT_TYPE;
		v_REC.EVENT_CATEGORY := :new.EVENT_CATEGORY;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_SYSTEM_EVENT_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -520 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.EVENT_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_SYSTEM_LOAD
	AFTER INSERT OR UPDATE OR DELETE ON SYSTEM_LOAD
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC SYSTEM_LOAD%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -530, :old.SYSTEM_LOAD_ID, :old.SYSTEM_LOAD_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.SYSTEM_LOAD_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -530);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.SYSTEM_LOAD_ID := :new.SYSTEM_LOAD_ID;
		v_REC.SYSTEM_LOAD_NAME := :new.SYSTEM_LOAD_NAME;
		v_REC.SYSTEM_LOAD_ALIAS := :new.SYSTEM_LOAD_ALIAS;
		v_REC.SYSTEM_LOAD_DESC := :new.SYSTEM_LOAD_DESC;
		v_REC.SYSTEM_LOAD_INTERVAL := :new.SYSTEM_LOAD_INTERVAL;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_SYSTEM_LOAD_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -530 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.SYSTEM_LOAD_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_SYSTEM_TABLE
	AFTER INSERT OR UPDATE OR DELETE ON SYSTEM_TABLE
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC SYSTEM_TABLE%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -1050, :old.TABLE_ID, :old.TABLE_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.TABLE_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -1050);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.TABLE_ID := :new.TABLE_ID;
		v_REC.TABLE_NAME := :new.TABLE_NAME;
		v_REC.TABLE_ALIAS := :new.TABLE_ALIAS;
		v_REC.TABLE_DESC := :new.TABLE_DESC;
		v_REC.DB_TABLE_NAME := :new.DB_TABLE_NAME;
		v_REC.MIRROR_TABLE_NAME := :new.MIRROR_TABLE_NAME;
		v_REC.ENTITY_DOMAIN_ID := :new.ENTITY_DOMAIN_ID;
		v_REC.KEY_CONSTRAINT_NAME := :new.KEY_CONSTRAINT_NAME;
		v_REC.ENTITY_ID_COLUMN_NAME := :new.ENTITY_ID_COLUMN_NAME;
		v_REC.DATE1_COLUMN_NAME := :new.DATE1_COLUMN_NAME;
		v_REC.DATE2_COLUMN_NAME := :new.DATE2_COLUMN_NAME;
		v_REC.IS_REACTIVE := :new.IS_REACTIVE;
		v_REC.LOCK_SUMMARY_TABLE_NAME := :new.LOCK_SUMMARY_TABLE_NAME;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_SYSTEM_TABLE_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -1050 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.TABLE_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_TEMPLATE
	AFTER INSERT OR UPDATE OR DELETE ON TEMPLATE
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC TEMPLATE%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -810, :old.TEMPLATE_ID, :old.TEMPLATE_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.TEMPLATE_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -810);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.TEMPLATE_ID := :new.TEMPLATE_ID;
		v_REC.TEMPLATE_NAME := :new.TEMPLATE_NAME;
		v_REC.TEMPLATE_ALIAS := :new.TEMPLATE_ALIAS;
		v_REC.TEMPLATE_DESC := :new.TEMPLATE_DESC;
		v_REC.IS_DAY_TYPE := :new.IS_DAY_TYPE;
		v_REC.IS_DST_OBSERVANT := :new.IS_DST_OBSERVANT;
		v_REC.VALIDATION_MESSAGE := :new.VALIDATION_MESSAGE;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_TEMPLATE_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -810 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.TEMPLATE_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_TP
	AFTER INSERT OR UPDATE OR DELETE ON TRANSMISSION_PROVIDER
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC TRANSMISSION_PROVIDER%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -140, :old.TP_ID, :old.TP_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.TP_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -140);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.TP_ID := :new.TP_ID;
		v_REC.TP_NAME := :new.TP_NAME;
		v_REC.TP_ALIAS := :new.TP_ALIAS;
		v_REC.TP_DESC := :new.TP_DESC;
		v_REC.TP_NERC_CODE := :new.TP_NERC_CODE;
		v_REC.TP_STATUS := :new.TP_STATUS;
		v_REC.TP_DUNS_NUMBER := :new.TP_DUNS_NUMBER;
		v_REC.OASIS_NODE_ID := :new.OASIS_NODE_ID;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_TP_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -140 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.TP_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_TRANSACTION
	AFTER INSERT OR UPDATE OR DELETE ON INTERCHANGE_TRANSACTION
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC INTERCHANGE_TRANSACTION%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -200, :old.TRANSACTION_ID, :old.TRANSACTION_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.TRANSACTION_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -200);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.TRANSACTION_ID := :new.TRANSACTION_ID;
		v_REC.TRANSACTION_NAME := :new.TRANSACTION_NAME;
		v_REC.TRANSACTION_ALIAS := :new.TRANSACTION_ALIAS;
		v_REC.TRANSACTION_DESC := :new.TRANSACTION_DESC;
		v_REC.TRANSACTION_TYPE := :new.TRANSACTION_TYPE;
		v_REC.TRANSACTION_CODE := :new.TRANSACTION_CODE;
		v_REC.TRANSACTION_IDENTIFIER := :new.TRANSACTION_IDENTIFIER;
		v_REC.IS_FIRM := :new.IS_FIRM;
		v_REC.IS_IMPORT_SCHEDULE := :new.IS_IMPORT_SCHEDULE;
		v_REC.IS_EXPORT_SCHEDULE := :new.IS_EXPORT_SCHEDULE;
		v_REC.IS_BALANCE_TRANSACTION := :new.IS_BALANCE_TRANSACTION;
		v_REC.IS_BID_OFFER := :new.IS_BID_OFFER;
		v_REC.IS_EXCLUDE_FROM_POSITION := :new.IS_EXCLUDE_FROM_POSITION;
		v_REC.IS_IMPORT_EXPORT := :new.IS_IMPORT_EXPORT;
		v_REC.IS_DISPATCHABLE := :new.IS_DISPATCHABLE;
		v_REC.TRANSACTION_INTERVAL := :new.TRANSACTION_INTERVAL;
		v_REC.EXTERNAL_INTERVAL := :new.EXTERNAL_INTERVAL;
		v_REC.ETAG_CODE := :new.ETAG_CODE;
		v_REC.BEGIN_DATE := :new.BEGIN_DATE;
		v_REC.END_DATE := :new.END_DATE;
		v_REC.PURCHASER_ID := :new.PURCHASER_ID;
		v_REC.SELLER_ID := :new.SELLER_ID;
		v_REC.CONTRACT_ID := :new.CONTRACT_ID;
		v_REC.SC_ID := :new.SC_ID;
		v_REC.POR_ID := :new.POR_ID;
		v_REC.POD_ID := :new.POD_ID;
		v_REC.COMMODITY_ID := :new.COMMODITY_ID;
		v_REC.SERVICE_TYPE_ID := :new.SERVICE_TYPE_ID;
		v_REC.TX_TRANSACTION_ID := :new.TX_TRANSACTION_ID;
		v_REC.PATH_ID := :new.PATH_ID;
		v_REC.LINK_TRANSACTION_ID := :new.LINK_TRANSACTION_ID;
		v_REC.EDC_ID := :new.EDC_ID;
		v_REC.PSE_ID := :new.PSE_ID;
		v_REC.ESP_ID := :new.ESP_ID;
		v_REC.POOL_ID := :new.POOL_ID;
		v_REC.SCHEDULE_GROUP_ID := :new.SCHEDULE_GROUP_ID;
		v_REC.MARKET_PRICE_ID := :new.MARKET_PRICE_ID;
		v_REC.ZOR_ID := :new.ZOR_ID;
		v_REC.ZOD_ID := :new.ZOD_ID;
		v_REC.SOURCE_ID := :new.SOURCE_ID;
		v_REC.SINK_ID := :new.SINK_ID;
		v_REC.RESOURCE_ID := :new.RESOURCE_ID;
		v_REC.AGREEMENT_TYPE := :new.AGREEMENT_TYPE;
		v_REC.APPROVAL_TYPE := :new.APPROVAL_TYPE;
		v_REC.LOSS_OPTION := :new.LOSS_OPTION;
		v_REC.TRAIT_CATEGORY := :new.TRAIT_CATEGORY;
		v_REC.TP_ID := :new.TP_ID;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_TRANSACTION_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -200 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.TRANSACTION_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_TRANSACTION_TRAIT_GROUP
	AFTER INSERT OR UPDATE OR DELETE ON TRANSACTION_TRAIT_GROUP
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC TRANSACTION_TRAIT_GROUP%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -680, :old.TRAIT_GROUP_ID, :old.TRAIT_GROUP_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.TRAIT_GROUP_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -680);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.TRAIT_GROUP_ID := :new.TRAIT_GROUP_ID;
		v_REC.TRAIT_GROUP_NAME := :new.TRAIT_GROUP_NAME;
		v_REC.TRAIT_GROUP_ALIAS := :new.TRAIT_GROUP_ALIAS;
		v_REC.TRAIT_GROUP_DESC := :new.TRAIT_GROUP_DESC;
		v_REC.TRAIT_GROUP_INTERVAL := :new.TRAIT_GROUP_INTERVAL;
		v_REC.TRAIT_GROUP_TYPE := :new.TRAIT_GROUP_TYPE;
		v_REC.SC_ID := :new.SC_ID;
		v_REC.TRAIT_CATEGORY := :new.TRAIT_CATEGORY;
		v_REC.DISPLAY_NAME := :new.DISPLAY_NAME;
		v_REC.DISPLAY_ORDER := :new.DISPLAY_ORDER;
		v_REC.IS_SERIES := :new.IS_SERIES;
		v_REC.IS_SPARSE := :new.IS_SPARSE;
		v_REC.IS_STATEMENT_TYPE_SPECIFIC := :new.IS_STATEMENT_TYPE_SPECIFIC;
		v_REC.DEFAULT_NUMBER_OF_SETS := :new.DEFAULT_NUMBER_OF_SETS;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_TRANSACTION_TRAIT_GROUP_FI( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -680 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.TRAIT_GROUP_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_TX_FEEDER
	AFTER INSERT OR UPDATE OR DELETE ON TX_FEEDER
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC TX_FEEDER%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -1170, :old.FEEDER_ID, :old.FEEDER_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.FEEDER_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -1170);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.FEEDER_ID := :new.FEEDER_ID;
		v_REC.FEEDER_NAME := :new.FEEDER_NAME;
		v_REC.FEEDER_ALIAS := :new.FEEDER_ALIAS;
		v_REC.FEEDER_DESC := :new.FEEDER_DESC;
		v_REC.EXTERNAL_IDENTIFIER := :new.EXTERNAL_IDENTIFIER;
		v_REC.SUB_STATION_ID := :new.SUB_STATION_ID;
		v_REC.BEGIN_DATE := :new.BEGIN_DATE;
		v_REC.END_DATE := :new.END_DATE;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_TX_FEEDER_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -1170 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.FEEDER_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_TX_FEEDER_SEGMENT
	AFTER INSERT OR UPDATE OR DELETE ON TX_FEEDER_SEGMENT
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC TX_FEEDER_SEGMENT%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -1180, :old.FEEDER_SEGMENT_ID, :old.FEEDER_SEGMENT_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.FEEDER_SEGMENT_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -1180);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.FEEDER_SEGMENT_ID := :new.FEEDER_SEGMENT_ID;
		v_REC.FEEDER_SEGMENT_NAME := :new.FEEDER_SEGMENT_NAME;
		v_REC.FEEDER_SEGMENT_ALIAS := :new.FEEDER_SEGMENT_ALIAS;
		v_REC.FEEDER_SEGMENT_DESC := :new.FEEDER_SEGMENT_DESC;
		v_REC.EXTERNAL_IDENTIFIER := :new.EXTERNAL_IDENTIFIER;
		v_REC.FEEDER_ID := :new.FEEDER_ID;
		v_REC.BEGIN_DATE := :new.BEGIN_DATE;
		v_REC.END_DATE := :new.END_DATE;
		v_REC.PRIORITY := :new.PRIORITY;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_TX_FEEDER_SEGMENT_FIELDS_M( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -1180 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.FEEDER_SEGMENT_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_VPP
	AFTER INSERT OR UPDATE OR DELETE ON VIRTUAL_POWER_PLANT
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC VIRTUAL_POWER_PLANT%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -1150, :old.VPP_ID, :old.VPP_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.VPP_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -1150);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.VPP_ID := :new.VPP_ID;
		v_REC.VPP_NAME := :new.VPP_NAME;
		v_REC.VPP_ALIAS := :new.VPP_ALIAS;
		v_REC.VPP_DESC := :new.VPP_DESC;
		v_REC.EXTERNAL_IDENTIFIER := :new.EXTERNAL_IDENTIFIER;
		v_REC.STATUS_NAME := :new.STATUS_NAME;
		v_REC.SERVICE_ZONE_ID := :new.SERVICE_ZONE_ID;
		v_REC.PROGRAM_ID := :new.PROGRAM_ID;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_VPP_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -1150 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.VPP_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_WEATHER_PARAMETER
	AFTER INSERT OR UPDATE OR DELETE ON WEATHER_PARAMETER
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC WEATHER_PARAMETER%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -540, :old.PARAMETER_ID, :old.PARAMETER_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.PARAMETER_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -540);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.PARAMETER_ID := :new.PARAMETER_ID;
		v_REC.PARAMETER_NAME := :new.PARAMETER_NAME;
		v_REC.PARAMETER_ALIAS := :new.PARAMETER_ALIAS;
		v_REC.PARAMETER_DESC := :new.PARAMETER_DESC;
		v_REC.PARAMETER_CATEGORY := :new.PARAMETER_CATEGORY;
		v_REC.PARAMETER_INTERVAL := :new.PARAMETER_INTERVAL;
		v_REC.PARAMETER_MEASUREMENT := :new.PARAMETER_MEASUREMENT;
		v_REC.PROJECTION_PERIOD := :new.PROJECTION_PERIOD;
		v_REC.IS_COMPOSITE := :new.IS_COMPOSITE;
		v_REC.IS_CALCULATE := :new.IS_CALCULATE;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_WEATHER_PARAMETER_FIELDS_M( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -540 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.PARAMETER_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

CREATE OR REPLACE TRIGGER ZREALM_WEATHER_STATION
	AFTER INSERT OR UPDATE OR DELETE ON WEATHER_STATION
	FOR EACH ROW
DECLARE
	v_MAP UT.STRING_MAP;
	v_REALMS ID_TABLE;
    v_REC WEATHER_STATION%ROWTYPE;
BEGIN
	IF DELETING THEN
		SECURITY_CONTROLS.BURY_ENTITY( -550, :old.STATION_ID, :old.STATION_NAME );
	END IF;
	-- clean out old references
	IF DELETING OR UPDATING THEN
		DELETE FROM SYSTEM_REALM_ENTITY A WHERE A.ENTITY_ID = :old.STATION_ID AND EXISTS (SELECT 1 FROM SYSTEM_REALM R WHERE R.REALM_ID = A.REALM_ID AND R.ENTITY_DOMAIN_ID = -550);
	END IF;
	-- now build the set of new references
	IF INSERTING OR UPDATING THEN
		-- build record
		v_REC.STATION_ID := :new.STATION_ID;
		v_REC.STATION_NAME := :new.STATION_NAME;
		v_REC.STATION_ALIAS := :new.STATION_ALIAS;
		v_REC.STATION_DESC := :new.STATION_DESC;
		v_REC.TIME_ZONE := :new.TIME_ZONE;
		v_REC.IS_COMPOSITE := :new.IS_COMPOSITE;
		v_REC.ENTRY_DATE := :new.ENTRY_DATE;
		-- use record
		v_MAP := IO_UTIL.GET_WEATHER_STATION_FIELDS_MAP( v_REC );
		v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS ( v_MAP, -550 );

		INSERT INTO SYSTEM_REALM_ENTITY ( REALM_ID, ENTITY_ID, ENTRY_DATE )
		SELECT X.ID, :new.STATION_ID, SYSDATE
		FROM TABLE(CAST(v_REALMS AS ID_TABLE)) X
		-- No need to add rows for the 'All Data' realm 
        WHERE X.ID <> SD.g_ALL_DATA_REALM_ID;
	END IF;
END;
/

