CREATE OR REPLACE TRIGGER HOLIDAY_OBSERVANCE_CHANGE
  AFTER UPDATE OR INSERT OR DELETE ON HOLIDAY_OBSERVANCE  
  FOR EACH ROW
BEGIN

	MERGE INTO TEMPLATE_DATES TD
		USING (SELECT TD.TIME_ZONE,
					TD.TEMPLATE_ID,
					TD.HOLIDAY_SET_ID,
					TD.LOCAL_DATE,
					TD.CUT_BEGIN_DATE,
					TD.CUT_END_DATE,
					TGT.DAY_TYPE_ID AS NEW_DAY_TYPE_ID
				FROM TEMPLATE_DATES TD,
					TEMPLATE_DAY_TYPE SRC,
					TEMPLATE_DAY_TYPE TGT,
					(SELECT HSCHED.HOLIDAY_SET_ID, :NEW.HOLIDAY_DATE AS HOLIDAY_DATE
						FROM HOLIDAY_SCHEDULE HSCHED
						WHERE HSCHED.HOLIDAY_ID = :NEW.HOLIDAY_ID
						
						UNION
						
					 -- THE ALL HOLIDAYS HOLIDAY SET OBSERVES ALL HOLIDAYS
					 SELECT CONSTANTS.ALL_HOLIDAYS_HOLIDAY_SET AS HOLIDAY_SET_ID,
					 		:NEW.HOLIDAY_DATE AS HOLIDAY_DATE
						FROM DUAL) HOL
						-- WE CAN'T DEAL JUST WITH THE HOLIDAY IN QUESTION, BECAUSE IT'S 
						-- POSSIBLE THERE'S ANOTHER HOLIDAY ON THE SAME DATE
				WHERE TD.LOCAL_DATE IN (:OLD.HOLIDAY_DATE, :NEW.HOLIDAY_DATE)
					AND HOL.HOLIDAY_SET_ID (+) = TD.HOLIDAY_SET_ID
					AND HOL.HOLIDAY_DATE (+) = TD.LOCAL_DATE
					AND SRC.DAY_TYPE_ID = TD.DAY_TYPE_ID
					AND TGT.TEMPLATE_ID = SRC.TEMPLATE_ID
					AND TGT.SEASON_ID = SRC.SEASON_ID
					AND TGT.DST_TYPE = SRC.DST_TYPE
					AND TGT.DAY_NAME = (CASE WHEN HOL.HOLIDAY_SET_ID IS NOT NULL THEN
											'Hol'
											ELSE TO_CHAR(TD.LOCAL_DATE, 'Dy') END)) UPD
		ON (UPD.TIME_ZONE = TD.TIME_ZONE
			AND UPD.TEMPLATE_ID = TD.TEMPLATE_ID
			AND UPD.HOLIDAY_SET_ID = TD.HOLIDAY_SET_ID
			AND UPD.LOCAL_DATE = TD.LOCAL_DATE)
		WHEN MATCHED THEN
			UPDATE SET TD.DAY_TYPE_ID = UPD.NEW_DAY_TYPE_ID;  

END HOLIDAY_OBSERVANCE_CHANGE;
/
