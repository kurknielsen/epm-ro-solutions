CREATE OR REPLACE PACKAGE BODY MM_SEM_SETTLEMENT_PARSE IS
----------------------------------------------------------------------------------------
TYPE RECORD_TYPE_COUNTS IS TABLE OF BINARY_INTEGER INDEX BY VARCHAR2(1);
----------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
	RETURN '$Revision: 1.1 $';
END WHAT_VERSION;
----------------------------------------------------------------------------------------
PROCEDURE UPDATE_RECORD_TYPE_COUNT
	(
	p_RECORD_TYPE IN VARCHAR2,
	p_RECORD_TYPE_COUNTS IN OUT NOCOPY RECORD_TYPE_COUNTS
	) AS
BEGIN
	IF p_RECORD_TYPE_COUNTS.EXISTS(p_RECORD_TYPE) THEN
		p_RECORD_TYPE_COUNTS(p_RECORD_TYPE) := p_RECORD_TYPE_COUNTS(p_RECORD_TYPE)+1;
	ELSE
		p_RECORD_TYPE_COUNTS(p_RECORD_TYPE) := 1;
	END IF;
END UPDATE_RECORD_TYPE_COUNT;
----------------------------------------------------------------------------------------
PROCEDURE LOG_UNKNOWN_RECORD_TYPES
	(
	p_RECORD_TYPE_COUNTS IN RECORD_TYPE_COUNTS,
	p_LOGGER IN OUT NOCOPY MM_LOGGER_ADAPTER
	) AS
v_FIRST BOOLEAN := TRUE;
v_MSG VARCHAR2(4000) := 'Report file contained unknown record types: ';
v_IDX VARCHAR2(1);
BEGIN
	v_IDX := p_RECORD_TYPE_COUNTS.FIRST;
	WHILE p_RECORD_TYPE_COUNTS.EXISTS(v_IDX) LOOP
		IF NOT v_FIRST THEN
			v_MSG := v_MSG||', ';
		ELSE
			v_FIRST := FALSE;
		END IF;

		v_MSG := p_RECORD_TYPE_COUNTS(v_IDX)||' '''||v_IDX||''' record(s)';
		v_IDX := p_RECORD_TYPE_COUNTS.NEXT(v_IDX);
	END LOOP;

	IF NOT v_FIRST THEN -- something to log?
		p_LOGGER.LOG_WARN( v_MSG );
	END IF;
END LOG_UNKNOWN_RECORD_TYPES;
----------------------------------------------------------------------------------------
PROCEDURE VALIDATE_TRAILER_RECORD_COUNT
	(
	p_ELEMENTS IN PARSE_UTIL.STRING_TABLE,
	p_OBSERVED_RECORD_COUNT IN BINARY_INTEGER,
	p_LOGGER IN OUT NOCOPY MM_LOGGER_ADAPTER
	) AS
v_REC_COUNT BINARY_INTEGER;
BEGIN
	v_REC_COUNT := TO_NUMBER(p_ELEMENTS(2));

	IF v_REC_COUNT <> p_OBSERVED_RECORD_COUNT THEN
		p_LOGGER.LOG_ERROR('Trailer record indicates '||v_REC_COUNT||' record(s), but observed '||p_OBSERVED_RECORD_COUNT||' record(s)');
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		p_LOGGER.LOG_ERROR('Could not parse record count from Trailer record!');

END VALIDATE_TRAILER_RECORD_COUNT;
----------------------------------------------------------------------------------------
PROCEDURE PARSE_GP_REPORT_H
	(
	p_ELEMENTS IN PARSE_UTIL.STRING_TABLE,
	p_WORK_ID IN NUMBER,
	p_LOGGER IN OUT NOCOPY MM_LOGGER_ADAPTER
	) AS
v_REC SEM_GP_SETTLEMENT_H_TEMP%ROWTYPE;
BEGIN
    v_REC.WORK_ID := p_WORK_ID;
    v_REC.FILE_VERSION := p_ELEMENTS(2);
    v_REC.REP_TIMESTAMP := TO_DATE(p_ELEMENTS(3), MM_SEM_UTIL.g_TIMESTAMP_FORMAT);
    v_REC.STATEMENT_TYPE := p_ELEMENTS(4);
    v_REC.SETTLEMENT_DAY := TO_DATE(p_ELEMENTS(5), MM_SEM_UTIL.g_DATE_FORMAT);

	INSERT INTO SEM_GP_SETTLEMENT_H_TEMP VALUES v_REC;
END PARSE_GP_REPORT_H;
----------------------------------------------------------------------------------------
PROCEDURE PARSE_GP_REPORT_D
	(
	p_ELEMENTS IN PARSE_UTIL.STRING_TABLE,
	p_WORK_ID IN NUMBER,
	p_LOGGER IN OUT NOCOPY MM_LOGGER_ADAPTER
	) AS
v_REC SEM_GP_SETTLEMENT_D_TEMP%ROWTYPE;
BEGIN
    v_REC.WORK_ID := p_WORK_ID;
    v_REC.DELIVERY_DATE := NVL(TO_DATE(p_ELEMENTS(2), MM_SEM_UTIL.g_DATE_FORMAT), LOW_DATE);
    v_REC.DELIVERY_HOUR := NVL(p_ELEMENTS(3), 0);
    v_REC.RESOLUTION := NVL(p_ELEMENTS(4), 40);
    v_REC.VARIABLE_TYPE := NVL(p_ELEMENTS(5), '?');
    v_REC.VARIABLE_NAME := NVL(p_ELEMENTS(6), '?');
    v_REC.RESOURCE_NAME := NVL(p_ELEMENTS(7), '?');
    v_REC.JURISDICTION := NVL(p_ELEMENTS(8), '?');
    v_REC.UNIT := p_ELEMENTS(9);
    v_REC.VALUE1 := p_ELEMENTS(10);
    v_REC.VALUE2 := CASE WHEN p_ELEMENTS.EXISTS(11) THEN p_ELEMENTS(11) ELSE NULL END;

	INSERT INTO SEM_GP_SETTLEMENT_D_TEMP VALUES v_REC;
END PARSE_GP_REPORT_D;
----------------------------------------------------------------------------------------
FUNCTION PARSE_GENERAL_PUBLIC_REPORT
	(
	p_REPORT IN CLOB,
	p_LOGGER IN OUT NOCOPY MM_LOGGER_ADAPTER
	) RETURN NUMBER IS

v_WORK_ID	NUMBER;
v_LINES 	PARSE_UTIL.BIG_STRING_TABLE_MP;
v_ELEMENTS 	PARSE_UTIL.STRING_TABLE;
v_IDX 		BINARY_INTEGER;
v_REC_TYPE	CHAR(1);
v_FOUND_T	BOOLEAN := FALSE;
v_REC_COUNT	BINARY_INTEGER := 0;
v_INVALID_REC_COUNT RECORD_TYPE_COUNTS;

BEGIN
	UT.GET_RTO_WORK_ID(v_WORK_ID);

	PARSE_UTIL.PARSE_CLOB_INTO_LINES(p_REPORT, v_LINES);
	v_IDX := v_LINES.FIRST;
	WHILE v_LINES.EXISTS(v_IDX) LOOP

		v_REC_COUNT := v_REC_COUNT+1;

		IF TRIM(v_LINES(v_IDX)) IS NOT NULL THEN -- ignore blank lines
			IF v_FOUND_T THEN
				p_LOGGER.LOG_ERROR('Invalid records encountered after report Trailer Record');
			END IF;

			PARSE_UTIL.PARSE_DELIMITED_STRING(v_LINES(v_IDX), ',', v_ELEMENTS);

			v_REC_TYPE := SUBSTR(v_ELEMENTS(1),1,1);

			CASE v_REC_TYPE
			WHEN 'H' THEN
				PARSE_GP_REPORT_H(v_ELEMENTS, v_WORK_ID, p_LOGGER);
			WHEN 'D' THEN
				PARSE_GP_REPORT_D(v_ELEMENTS, v_WORK_ID, p_LOGGER);
			WHEN 'T' THEN
				VALIDATE_TRAILER_RECORD_COUNT(v_ELEMENTS, v_REC_COUNT, p_LOGGER);
				v_FOUND_T := TRUE;
			ELSE
				UPDATE_RECORD_TYPE_COUNT(v_REC_TYPE, v_INVALID_REC_COUNT);
			END CASE;
		END IF;

		v_IDX := v_LINES.NEXT(v_IDX);
	END LOOP;

	LOG_UNKNOWN_RECORD_TYPES(v_INVALID_REC_COUNT, p_LOGGER);

	RETURN v_WORK_ID;

END PARSE_GENERAL_PUBLIC_REPORT;
----------------------------------------------------------------------------------------
PROCEDURE PARSE_STATEMENT_H
	(
	p_ELEMENTS IN PARSE_UTIL.STRING_TABLE,
	p_WORK_ID IN NUMBER,
	p_LOGGER IN OUT NOCOPY MM_LOGGER_ADAPTER
	) AS
v_REC SEM_STATEMENT_H_TEMP%ROWTYPE;
BEGIN
    v_REC.WORK_ID := p_WORK_ID;
    v_REC.FILE_VERSION := p_ELEMENTS(2);
    v_REC.ENTITY := p_ELEMENTS(3);
    v_REC.REP_TIMESTAMP := TO_DATE(p_ELEMENTS(4), MM_SEM_UTIL.g_TIMESTAMP_FORMAT);
    v_REC.FILE_NO := p_ELEMENTS(5);
    v_REC.PARTICIPANT := p_ELEMENTS(6);
    v_REC.STATEMENT_NO := p_ELEMENTS(7);
    v_REC.STATEMENT_TYPE := p_ELEMENTS(8);
    v_REC.MARKET := p_ELEMENTS(9);
    v_REC.MKT_SEGMENT := p_ELEMENTS(10);
    v_REC.JOB_ID := p_ELEMENTS(11);
    v_REC.JOB_VERSION := p_ELEMENTS(12);
    v_REC.JOB_TIMESTAMP := TO_DATE(p_ELEMENTS(13), MM_SEM_UTIL.g_TIMESTAMP_FORMAT);
    v_REC.SETTLEMENT_DAY := TO_DATE(p_ELEMENTS(14), MM_SEM_UTIL.g_DATE_FORMAT);

	INSERT INTO SEM_STATEMENT_H_TEMP VALUES v_REC;
END PARSE_STATEMENT_H;
----------------------------------------------------------------------------------------
PROCEDURE PARSE_STATEMENT_S
	(
	p_ELEMENTS IN PARSE_UTIL.STRING_TABLE,
	p_WORK_ID IN NUMBER,
	p_LOGGER IN OUT NOCOPY MM_LOGGER_ADAPTER
	) AS
v_REC SEM_STATEMENT_S_TEMP%ROWTYPE;
BEGIN
    v_REC.WORK_ID := p_WORK_ID;
    v_REC.PRODUCT := NVL(p_ELEMENTS(2),'?');
    v_REC.PRODUCT_DESC := p_ELEMENTS(3);
    v_REC.DELIVERY_DAY := NVL(TO_DATE(p_ELEMENTS(4), MM_SEM_UTIL.g_DATE_FORMAT), LOW_DATE);
    v_REC.PAY_OR_CHARGE := p_ELEMENTS(5);
    v_REC.TOTAL_QUANTITY := p_ELEMENTS(6);
    v_REC.UNIT := p_ELEMENTS(7);
    v_REC.TOTAL_AMOUNT := p_ELEMENTS(8);
    v_REC.CURRENCY := p_ELEMENTS(9);

	INSERT INTO SEM_STATEMENT_S_TEMP VALUES v_REC;
END PARSE_STATEMENT_S;
----------------------------------------------------------------------------------------
PROCEDURE PARSE_STATEMENT_D
	(
	p_ELEMENTS IN PARSE_UTIL.STRING_TABLE,
	p_WORK_ID IN NUMBER,
	p_LOGGER IN OUT NOCOPY MM_LOGGER_ADAPTER,
    p_LINE IN VARCHAR2
	) AS
v_REC SEM_STATEMENT_D_TEMP%ROWTYPE;
BEGIN

    IF p_ELEMENTS.COUNT NOT IN (19, 20) THEN
        p_LOGGER.LOG_ERROR('Expected 19 or 20 elements for the detail line, but '
            || p_ELEMENTS.COUNT || ' were found.');
        p_LOGGER.LOG_ATTACHMENT('Line', CONSTANTS.MIME_TYPE_TEXT, p_LINE);
        RETURN;
    END IF;

    v_REC.WORK_ID := p_WORK_ID;
    v_REC.PRODUCT := NVL(p_ELEMENTS(2), '?');
    v_REC.REC_ORDER := p_ELEMENTS(3);
    v_REC.PAY_OR_CHARGE := p_ELEMENTS(4);
    v_REC.OPERATION_DATE := NVL(TO_DATE(p_ELEMENTS(5), MM_SEM_UTIL.g_DATE_FORMAT), LOW_DATE);
    v_REC.OPERATION_HOUR := NVL(p_ELEMENTS(6), 0);
    v_REC.OPERATION_MIN := NVL(p_ELEMENTS(7), 0);
    v_REC.RESOLUTION := NVL(p_ELEMENTS(8), 40);
    -- skip PDA element
    v_REC.COMMENTS := p_ELEMENTS(10);
    v_REC.RESOURCE_NAME := NVL(p_ELEMENTS(11),'?');
    v_REC.LOCATION_NAME := NVL(p_ELEMENTS(12),'?');
    -- skip INTERNAL_ZONE element
    v_REC.JURISDICTION := p_ELEMENTS(14);
    v_REC.CONTRACT := p_ELEMENTS(15);

    -- 19 ELEMENTS, THEN WE'RE DEALING WITH A PRE- 1.8 SEM STATEMENT DETAIL RECORD
    IF p_ELEMENTS.COUNT = 19 THEN

        v_REC.QUANTITY := p_ELEMENTS(16);
        v_REC.UNIT := p_ELEMENTS(17);
        v_REC.AMOUNT := p_ELEMENTS(18);
        v_REC.CURRENCY := p_ELEMENTS(19);

    -- 20 ELEMENTS, THEN WE'RE DEALING WITH A POST-1.8 SEM STATEMENT DETAIL RECORD
    -- THIS WILL HAVE THE INTERCONNECTOR FIELD
    ELSIF p_ELEMENTS.COUNT = 20 THEN
        v_REC.INTERCONNECTOR := p_ELEMENTS(16);
        v_REC.QUANTITY := p_ELEMENTS(17);
        v_REC.UNIT := p_ELEMENTS(18);
        v_REC.AMOUNT := p_ELEMENTS(19);
        v_REC.CURRENCY := p_ELEMENTS(20);
    END IF;

	INSERT INTO SEM_STATEMENT_D_TEMP VALUES v_REC;
END PARSE_STATEMENT_D;
----------------------------------------------------------------------------------------
FUNCTION PARSE_STATEMENT_REPORT
	(
	p_REPORT IN CLOB,
	p_LOGGER IN OUT NOCOPY MM_LOGGER_ADAPTER
	) RETURN NUMBER IS

v_WORK_ID	NUMBER;
v_LINES 	PARSE_UTIL.BIG_STRING_TABLE_MP;
v_ELEMENTS 	PARSE_UTIL.STRING_TABLE;
v_IDX 		BINARY_INTEGER;
v_REC_TYPE	CHAR(1);
v_FOUND_T	BOOLEAN := FALSE;
v_REC_COUNT	BINARY_INTEGER := 0;
v_INVALID_REC_COUNT RECORD_TYPE_COUNTS;

BEGIN
	UT.GET_RTO_WORK_ID(v_WORK_ID);

	PARSE_UTIL.PARSE_CLOB_INTO_LINES(p_REPORT, v_LINES);
	v_IDX := v_LINES.FIRST;
	WHILE v_LINES.EXISTS(v_IDX) LOOP

		v_REC_COUNT := v_REC_COUNT+1;

		IF TRIM(v_LINES(v_IDX)) IS NOT NULL THEN -- ignore blank lines
			IF v_FOUND_T THEN
				p_LOGGER.LOG_ERROR('Invalid records encountered after report Trailer Record');
			END IF;

			PARSE_UTIL.PARSE_DELIMITED_STRING(v_LINES(v_IDX), ',', v_ELEMENTS);

			v_REC_TYPE := SUBSTR(v_ELEMENTS(1),1,1);
			
			CASE v_REC_TYPE
			WHEN 'H' THEN
				PARSE_STATEMENT_H(v_ELEMENTS, v_WORK_ID, p_LOGGER);
			WHEN 'S' THEN
				PARSE_STATEMENT_S(v_ELEMENTS, v_WORK_ID, p_LOGGER);
			WHEN 'D' THEN
				PARSE_STATEMENT_D(v_ELEMENTS, v_WORK_ID, p_LOGGER, v_LINES(v_IDX));
			WHEN 'T' THEN
				VALIDATE_TRAILER_RECORD_COUNT(v_ELEMENTS, v_REC_COUNT, p_LOGGER);
				v_FOUND_T := TRUE;
			ELSE
				UPDATE_RECORD_TYPE_COUNT(v_REC_TYPE, v_INVALID_REC_COUNT);
			END CASE;
		END IF;

		v_IDX := v_LINES.NEXT(v_IDX);
	END LOOP;

	LOG_UNKNOWN_RECORD_TYPES(v_INVALID_REC_COUNT, p_LOGGER);

	RETURN v_WORK_ID;

END PARSE_STATEMENT_REPORT;
----------------------------------------------------------------------------------------
PROCEDURE PARSE_MP_INFO_H
	(
	p_ELEMENTS IN PARSE_UTIL.STRING_TABLE,
	p_WORK_ID IN NUMBER,
	p_LOGGER IN OUT NOCOPY MM_LOGGER_ADAPTER
	) AS
v_REC SEM_MP_INFO_H_TEMP%ROWTYPE;
BEGIN
    v_REC.WORK_ID := p_WORK_ID;
    v_REC.FILE_VERSION := p_ELEMENTS(2);
    v_REC.ENTITY := p_ELEMENTS(3);
    v_REC.REP_TIMESTAMP := TO_DATE(p_ELEMENTS(4), MM_SEM_UTIL.g_TIMESTAMP_FORMAT);
    v_REC.FILE_NO := p_ELEMENTS(5);
    v_REC.PARTICIPANT := p_ELEMENTS(6);
    v_REC.STATEMENT_TYPE := p_ELEMENTS(7);
    v_REC.SETTLEMENT_DAY := TO_DATE(p_ELEMENTS(8), MM_SEM_UTIL.g_DATE_FORMAT);

	INSERT INTO SEM_MP_INFO_H_TEMP VALUES v_REC;
END PARSE_MP_INFO_H;

----------------------------------------------------------------------------------------
PROCEDURE PARSE_MP_INFO_S	(
	p_ELEMENTS IN PARSE_UTIL.STRING_TABLE,
	p_WORK_ID  IN NUMBER,
	p_LOGGER   IN OUT NOCOPY MM_LOGGER_ADAPTER)
AS
   v_REC SEM_MP_INFO_S_TEMP%ROWTYPE;
BEGIN
   v_REC.WORK_ID          := p_WORK_ID;
   v_REC.MARKET_CID       := p_ELEMENTS(2);
   v_REC.PRODUCT_CID      := p_ELEMENTS(3);
   v_REC.JOB_ID           := TO_NUMBER(p_ELEMENTS(4));
   v_REC.JOB_VERSION      := TO_NUMBER(p_ELEMENTS(5));
   v_REC.JOB_TYPE         := p_ELEMENTS(6);
   v_REC.MARKET_TIMESTAMP := TO_DATE(p_ELEMENTS(7), MM_SEM_UTIL.g_TIMESTAMP_FORMAT);

   INSERT INTO SEM_MP_INFO_S_TEMP VALUES v_REC;
END PARSE_MP_INFO_S;

----------------------------------------------------------------------------------------
PROCEDURE PARSE_MP_INFO_D
	(
	p_ELEMENTS IN PARSE_UTIL.STRING_TABLE,
	p_WORK_ID IN NUMBER,
	p_LOGGER IN OUT NOCOPY MM_LOGGER_ADAPTER
	) AS
v_REC SEM_MP_INFO_D_TEMP%ROWTYPE;
BEGIN
    v_REC.WORK_ID := p_WORK_ID;
    v_REC.DELIVERY_DATE := NVL(TO_DATE(p_ELEMENTS(2), MM_SEM_UTIL.g_DATE_FORMAT), LOW_DATE);
    v_REC.DELIVERY_HOUR := NVL(p_ELEMENTS(3), 0);
    v_REC.RESOLUTION := NVL(p_ELEMENTS(4), 40);
	-- skip PDA element
    v_REC.VARIABLE_TYPE := NVL(p_ELEMENTS(6), '?');
    v_REC.VARIABLE_NAME := NVL(p_ELEMENTS(7), '?');
    v_REC.RESOURCE_NAME := NVL(p_ELEMENTS(8), '?');
    v_REC.LOCATION_NAME := NVL(p_ELEMENTS(9), '?');
    v_REC.CONTRACT := p_ELEMENTS(10);
    v_REC.UNIT := p_ELEMENTS(11);
    v_REC.VALUE1 := p_ELEMENTS(12);
    v_REC.VALUE2 := CASE WHEN p_ELEMENTS.EXISTS(13) THEN p_ELEMENTS(13) ELSE NULL END;

	INSERT INTO SEM_MP_INFO_D_TEMP VALUES v_REC;
END PARSE_MP_INFO_D;
----------------------------------------------------------------------------------------
FUNCTION PARSE_PARTICIPANT_INFO_REPORT
	(
	p_REPORT IN CLOB,
	p_LOGGER IN OUT NOCOPY MM_LOGGER_ADAPTER
	) RETURN NUMBER IS

v_WORK_ID	NUMBER;
v_LINES 	PARSE_UTIL.BIG_STRING_TABLE_MP;
v_ELEMENTS 	PARSE_UTIL.STRING_TABLE;
v_IDX 		BINARY_INTEGER;
v_REC_TYPE	CHAR(1);
v_FOUND_T	BOOLEAN := FALSE;
v_REC_COUNT	BINARY_INTEGER := 0;
v_INVALID_REC_COUNT RECORD_TYPE_COUNTS;

BEGIN
	UT.GET_RTO_WORK_ID(v_WORK_ID);

	PARSE_UTIL.PARSE_CLOB_INTO_LINES(p_REPORT, v_LINES);
	v_IDX := v_LINES.FIRST;
	WHILE v_LINES.EXISTS(v_IDX) LOOP

		v_REC_COUNT := v_REC_COUNT+1;

		IF TRIM(v_LINES(v_IDX)) IS NOT NULL THEN -- ignore blank lines
			IF v_FOUND_T THEN
				p_LOGGER.LOG_ERROR('Invalid records encountered after report Trailer Record');
			END IF;

			PARSE_UTIL.PARSE_DELIMITED_STRING(v_LINES(v_IDX), ',', v_ELEMENTS);

			v_REC_TYPE := SUBSTR(v_ELEMENTS(1),1,1);

			CASE v_REC_TYPE
			WHEN 'H' THEN
				PARSE_MP_INFO_H(v_ELEMENTS, v_WORK_ID, p_LOGGER);
			WHEN 'S' THEN
				PARSE_MP_INFO_S(v_ELEMENTS, v_WORK_ID, p_LOGGER);
			WHEN 'D' THEN
				PARSE_MP_INFO_D(v_ELEMENTS, v_WORK_ID, p_LOGGER);
			WHEN 'T' THEN
				VALIDATE_TRAILER_RECORD_COUNT(v_ELEMENTS, v_REC_COUNT, p_LOGGER);
				v_FOUND_T := TRUE;
			ELSE
				UPDATE_RECORD_TYPE_COUNT(v_REC_TYPE, v_INVALID_REC_COUNT);
			END CASE;
		END IF;

		v_IDX := v_LINES.NEXT(v_IDX);
	END LOOP;

	LOG_UNKNOWN_RECORD_TYPES(v_INVALID_REC_COUNT, p_LOGGER);

	RETURN v_WORK_ID;

END PARSE_PARTICIPANT_INFO_REPORT;
----------------------------------------------------------------------------------------
PROCEDURE PARSE_SRA_H
	(
	p_ELEMENTS IN PARSE_UTIL.STRING_TABLE,
	p_WORK_ID IN NUMBER,
	p_LOGGER IN OUT NOCOPY MM_LOGGER_ADAPTER
	) AS
v_REC SEM_SRA_H_TEMP%ROWTYPE;
BEGIN
    v_REC.WORK_ID := p_WORK_ID;
    v_REC.FILE_VERSION := p_ELEMENTS(2);
    v_REC.ENTITY := p_ELEMENTS(3);
    v_REC.REP_TIMESTAMP := TO_DATE(p_ELEMENTS(4), MM_SEM_UTIL.g_TIMESTAMP_FORMAT);
    v_REC.PARTICIPANT := p_ELEMENTS(5);
    v_REC.STATEMENT_TYPE := p_ELEMENTS(6);
    v_REC.BEGIN_DATE := TO_DATE(p_ELEMENTS(7), MM_SEM_UTIL.g_DATE_FORMAT);
    v_REC.END_DATE := TO_DATE(p_ELEMENTS(8), MM_SEM_UTIL.g_DATE_FORMAT);

	INSERT INTO SEM_SRA_H_TEMP VALUES v_REC;
END PARSE_SRA_H;
----------------------------------------------------------------------------------------
PROCEDURE PARSE_SRA_D
	(
	p_ELEMENTS IN PARSE_UTIL.STRING_TABLE,
	p_WORK_ID IN NUMBER,
	p_LOGGER IN OUT NOCOPY MM_LOGGER_ADAPTER
	) AS
v_REC SEM_SRA_D_TEMP%ROWTYPE;
BEGIN
    v_REC.WORK_ID := p_WORK_ID;
    v_REC.REALLOCATION_NAME := NVL(p_ELEMENTS(2),'?');
    v_REC.TRADING_INTERVAL := NVL(TO_DATE(p_ELEMENTS(3), MM_SEM_UTIL.g_TIMESTAMP_FORMAT), LOW_DATE);
    v_REC.DST_FLAG := NVL(p_ELEMENTS(4), 0);
	v_REC.COUNTERPARTY := NVL(p_ELEMENTS(5), '?');
    v_REC.UNIT := p_ELEMENTS(6);
    v_REC.AMOUNT := p_ELEMENTS(7);
    v_REC.VALIDITY := p_ELEMENTS(8);
    v_REC.REASON := p_ELEMENTS(9);

	INSERT INTO SEM_SRA_D_TEMP VALUES v_REC;
END PARSE_SRA_D;
----------------------------------------------------------------------------------------
FUNCTION PARSE_REALLOCATION_REPORT
	(
	p_REPORT IN CLOB,
	p_LOGGER IN OUT NOCOPY MM_LOGGER_ADAPTER
	) RETURN NUMBER IS

v_WORK_ID	NUMBER;
v_LINES 	PARSE_UTIL.BIG_STRING_TABLE_MP;
v_ELEMENTS 	PARSE_UTIL.STRING_TABLE;
v_IDX 		BINARY_INTEGER;
v_REC_TYPE	CHAR(1);
v_FOUND_T	BOOLEAN := FALSE;
v_REC_COUNT	BINARY_INTEGER := 0;
v_INVALID_REC_COUNT RECORD_TYPE_COUNTS;

BEGIN
	UT.GET_RTO_WORK_ID(v_WORK_ID);

	PARSE_UTIL.PARSE_CLOB_INTO_LINES(p_REPORT, v_LINES);
	v_IDX := v_LINES.FIRST;
	WHILE v_LINES.EXISTS(v_IDX) LOOP

		v_REC_COUNT := v_REC_COUNT+1;

		IF TRIM(v_LINES(v_IDX)) IS NOT NULL THEN -- ignore blank lines
			IF v_FOUND_T THEN
				p_LOGGER.LOG_ERROR('Invalid records encountered after report Trailer Record');
			END IF;

			PARSE_UTIL.PARSE_DELIMITED_STRING(v_LINES(v_IDX), ',', v_ELEMENTS);

			v_REC_TYPE := SUBSTR(v_ELEMENTS(1),1,1);

			CASE v_REC_TYPE
			WHEN 'H' THEN
				PARSE_SRA_H(v_ELEMENTS, v_WORK_ID, p_LOGGER);
			WHEN 'D' THEN
				PARSE_SRA_D(v_ELEMENTS, v_WORK_ID, p_LOGGER);
			WHEN 'T' THEN
				VALIDATE_TRAILER_RECORD_COUNT(v_ELEMENTS, v_REC_COUNT, p_LOGGER);
				v_FOUND_T := TRUE;
			ELSE
				UPDATE_RECORD_TYPE_COUNT(v_REC_TYPE, v_INVALID_REC_COUNT);
			END CASE;
		END IF;

		v_IDX := v_LINES.NEXT(v_IDX);
	END LOOP;

	LOG_UNKNOWN_RECORD_TYPES(v_INVALID_REC_COUNT, p_LOGGER);

	RETURN v_WORK_ID;

END PARSE_REALLOCATION_REPORT;

----------------------------------------------------------------------------------------
PROCEDURE INS_SEM_MP_INFO_FILES(p_REC IN OUT SEM_MP_INFO_FILES%ROWTYPE)
IS
BEGIN
   LOGS.LOG_INFO('Saving the unprocessed PIR file. No associated Statement was found.');
   INSERT INTO SEM_MP_INFO_FILES VALUES p_REC;
END INS_SEM_MP_INFO_FILES;
----------------------------------------------------------------------------------------
PROCEDURE DEL_SEM_MP_INFO_FILES(p_IMPORT_FILE_ID IN SEM_MP_INFO_FILES.IMPORT_FILE_ID%TYPE)
IS
BEGIN
   LOGS.LOG_INFO('Removing the processed PIR file. The associated Statement was found and the file has been processed.');
   DELETE FROM SEM_MP_INFO_FILES WHERE IMPORT_FILE_ID = p_IMPORT_FILE_ID;
END DEL_SEM_MP_INFO_FILES;
----------------------------------------------------------------------------------------

END MM_SEM_SETTLEMENT_PARSE;
/
