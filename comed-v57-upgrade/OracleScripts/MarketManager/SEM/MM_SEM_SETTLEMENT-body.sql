CREATE OR REPLACE PACKAGE BODY MM_SEM_SETTLEMENT IS
----------------------------------------------------------------------------------------

g_MARKET_NAMES UT.STRING_MAP;
g_MARKET_INTERVALS UT.STRING_MAP;

-- XML namespaces
g_INVOICE_NAMESPACE CONSTANT VARCHAR2(128) := 'http://tempuri.org/InvoiceSet.xsd';
g_INVOICE_XPATH_NS CONSTANT VARCHAR2(128) := 'xmlns="'||g_INVOICE_NAMESPACE||'"';
--g_INVOICE_XPATH_NS_A CONSTANT VARCHAR2(128) := 'xmlns:a="'||g_INVOICE_NAMESPACE||'"';
g_DIR_LIST_NAMESPACE CONSTANT VARCHAR2(128) := NULL;

-- Constants for data resolution
g_RES_30_MIN CONSTANT NUMBER(2) := 30;
g_RES_HOUR CONSTANT NUMBER(2) := 31;
g_RES_DAY CONSTANT NUMBER(2) := 32;
g_RES_WEEK CONSTANT NUMBER(2) := 33;
g_RES_MONTH CONSTANT NUMBER(2) := 34;
g_RES_UNKNOWN CONSTANT NUMBER(2) := 40;

-- Other constants
g_DEFAULT_ENTITY_NAME CONSTANT VARCHAR2(16) := 'SEM';
g_DEFAULT_MARKET_NAME CONSTANT VARCHAR2(16) := g_ENERGY_MARKET_NAME;
g_TPD CONSTANT NUMBER := 0.5;

-- Constants for Alert Types
g_ALERT_TYPE_SETTL VARCHAR2(32) := 'Settlement';
g_ALERT_NAME_SETTL_REP VARCHAR2(32) := 'Settlement Report';
g_ALERT_NAME_SETTL_PIR VARCHAR2(32) := 'Participant Information Report';
g_ALERT_NAME_SETTL_RAR  VARCHAR2(32) := 'Reallocation Agreement Report';
g_ALERT_NAME_SETTL_INV VARCHAR2(32) := 'Invoice';
g_ALERT_NAME_SETTL_CREDIT VARCHAR2(32) := 'Credit Cover Report';

-- BILLING Statuses
g_IMPORTING_REVIEW_STATUS CONSTANT VARCHAR2(32) := 'Importing...';
g_IMPORTED_REVIEW_STATUS CONSTANT VARCHAR2(32) := 'Imported';

g_ITER_NAME_AGREEMENT_TYPE	CONSTANT VARCHAR2(32) := 'Agreement_Type';
g_ITER_NAME_SERVICE_POINT	CONSTANT VARCHAR2(32) := 'Service_Point';

g_NULL_CURRENCY CONSTANT VARCHAR(8) := '/';

$IF $$UNIT_TEST_MODE <> 1 OR $$UNIT_TEST_MODE IS NULL $THEN
   TYPE CONVERSION_RATE_ARRAY IS VARRAY(2) OF MARKET_PRICE_VALUE.PRICE%TYPE;
$END

-- Commodity Aliases
g_ENERGY_ALIAS CONSTANT VARCHAR2(16) := 'Energy';
g_CAPACITY_ALIAS CONSTANT VARCHAR2(16) := 'Capacity';

-- associative array to cache "hardwired" values in components
TYPE ASSOC_ARR IS TABLE OF VARCHAR2(255) INDEX BY VARCHAR2(255);
g_COMP_DET_CONSTANTS_CACHE ASSOC_ARR;

-- used to cache filename processed for settlement download groups
g_WORK_ID_FOR_DL_GROUPS NUMBER;


g_TRACE_ON BOOLEAN := FALSE;

----------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
    RETURN '$Revision: 1.29 $';
END WHAT_VERSION;
----------------------------------------------------------------------------------------
FUNCTION GET_SETTLEMENT_DATE
	(
	p_DAY IN DATE,
	p_HOUR_ENDING IN NUMBER,
	p_MINUTE_STARTING IN NUMBER,
	p_RESOLUTION IN NUMBER
	) RETURN DATE IS
v_RET DATE := p_DAY;
BEGIN
	-- half-hourly data
	IF p_RESOLUTION = g_RES_30_MIN THEN
		--Jan 16, 2009, LD - BZ 18044 - long day charge amount intervals add'l in wrong timeslots
		--use the MM_SEM_UTIL.GET_SCHEDULE_DATE API to get the schedule data based on day, hour and interval
		IF p_MINUTE_STARTING = 0 THEN
			v_RET := MM_SEM_UTIL.GET_SCHEDULE_DATE(p_DAY, p_HOUR_ENDING, 1); --first 30-minute interval
		ELSE
			v_RET := MM_SEM_UTIL.GET_SCHEDULE_DATE(p_DAY, p_HOUR_ENDING, 2); --second 30-minute interval
		END IF;
	-- hourly interval data
	ELSIF p_RESOLUTION = g_RES_HOUR THEN
		v_RET := MM_SEM_UTIL.GET_SCHEDULE_DATE(p_DAY, p_HOUR_ENDING, 0);
	--greater interval? then pass hour as zero
	ELSE
		v_RET := MM_SEM_UTIL.GET_SCHEDULE_DATE(p_DAY, 0, 0);

	END IF;

	RETURN v_RET;
END GET_SETTLEMENT_DATE;
----------------------------------------------------------------------------------------
FUNCTION GET_EXTERNAL_CHARGE_AMOUNT
    (
    p_CHARGE_ID IN NUMBER,
    p_CHARGE_DATE IN DATE,
    p_RESOURCE_NAME IN VARCHAR2,
    p_CONTRACT IN VARCHAR2 := NULL
    ) RETURN NUMBER IS
v_CHG_AMOUNT SEM_DETAIL_CHARGE.CHARGE_AMOUNT%TYPE;
BEGIN
    IF p_CONTRACT IS NOT NULL THEN
        SELECT NVL(SUM(CHARGE_AMOUNT),0) INTO v_CHG_AMOUNT
        FROM SEM_DETAIL_CHARGE
        WHERE CHARGE_DATE   		 = p_CHARGE_DATE
            AND CHARGE_ID     		 = p_CHARGE_ID
            AND UPPER(TRIM(CONTRACT)) = UPPER(TRIM(p_CONTRACT));
    ELSE
        SELECT NVL(SUM(CHARGE_AMOUNT),0) INTO v_CHG_AMOUNT
        FROM SEM_DETAIL_CHARGE
        WHERE CHARGE_DATE   = p_CHARGE_DATE
            AND CHARGE_ID     = p_CHARGE_ID
            AND RESOURCE_NAME = p_RESOURCE_NAME;
    END IF;

    -- mcr 2/22/2010 bz_23510
    -- Added SUM() to above code.  Although LOCATION_NAME and REC_ORDER are part
    -- of the PK, they are not considered in this rollup summary value.

    RETURN v_CHG_AMOUNT;
END GET_EXTERNAL_CHARGE_AMOUNT;
-----------------------------------------------------------------------------------------
PROCEDURE PUT_CURRENCY_UNIT_FOR_PSE
	(
	 p_BILLING_ENTITY_ID       BILLING_STATEMENT.ENTITY_ID%TYPE,
     p_NEW_CURRENCY_UNIT       VARCHAR2,
     p_LOGGER IN OUT NOCOPY MM_LOGGER_ADAPTER
	) IS
    v_ATTRIBUTE_ID             NUMBER;
    v_MAPPED_CURRENCY_UNIT     SYSTEM_DICTIONARY.SETTING_NAME%TYPE;
    v_PSE_CURRENCY_UNIT        SYSTEM_DICTIONARY.SETTING_NAME%TYPE;
    v_CURRENCY_ATTR_ID         VARCHAR(64) := 'Currency';
	v_PSE_ID 				   PSE.PSE_ID%TYPE;

BEGIN

	  SELECT PARTICIPANT_PSE_ID INTO v_PSE_ID
    	FROM SEM_SETTLEMENT_ENTITY
       WHERE SETTLEMENT_PSE_ID = p_BILLING_ENTITY_ID;

      ID.ID_FOR_ENTITY_ATTRIBUTE(v_CURRENCY_ATTR_ID, EC.ED_PSE, 'String', v_ATTRIBUTE_ID);
      IF v_ATTRIBUTE_ID <= 0 THEN
          RAISE_APPLICATION_ERROR(-20106,'COULD NOT GET ATTRIBUTE ID FOR: ' || v_CURRENCY_ATTR_ID);
      END IF;

      -- Get the current currency unit
      v_PSE_CURRENCY_UNIT := RO.GET_ENTITY_ATTRIBUTE(v_CURRENCY_ATTR_ID, EC.ED_PSE, v_PSE_ID, LOW_DATE);

      --Check if any Currency Mapping exists in the SYSTEM DICTIONARY
      v_MAPPED_CURRENCY_UNIT := GET_DICTIONARY_VALUE(p_NEW_CURRENCY_UNIT,
                                                      0,
                                                      'MarketExchange',
                                                      'SEM',
                                                      'Settlement',
                                                      'Currency Map');

      -- Add currency unit only if none is found for PSE
      IF v_PSE_CURRENCY_UNIT IS NULL THEN
          v_PSE_CURRENCY_UNIT := NVL(v_MAPPED_CURRENCY_UNIT, p_NEW_CURRENCY_UNIT);

         RO.PUT_ENTITY_ATTRIBUTE(p_ATTRIBUTE_NAME   =>  v_CURRENCY_ATTR_ID,
                                 p_ENTITY_DOMAIN_ID => EC.ED_PSE,
                                 p_OWNER_ENTITY_ID  => v_PSE_ID,
                                 p_ATTRIBUTE_TYPE   => 'String',
                                 p_ATTRIBUTE_VAL    => v_PSE_CURRENCY_UNIT,
                                 p_BEGIN_DATE       => LOW_DATE,
                                 p_END_DATE         => HIGH_DATE);

      ELSE
         -- Log a warning message if new currency unit or the mapped current unit
         -- does not match PSE's currency unit.
         IF v_PSE_CURRENCY_UNIT <> NVL(v_MAPPED_CURRENCY_UNIT, p_NEW_CURRENCY_UNIT) THEN
            p_LOGGER.LOG_WARN('Incompatible currency unit ' || p_NEW_CURRENCY_UNIT ||
                               ' found for '||TEXT_UTIL.TO_CHAR_ENTITY(v_PSE_ID,EC.ED_PSE,TRUE) || '.');
         END IF;
      END IF;

END PUT_CURRENCY_UNIT_FOR_PSE;
----------------------------------------------------------------------------------------
FUNCTION GET_INVOICE_INTERVAL
	(
	p_MARKET_NAME IN VARCHAR2
	) RETURN VARCHAR2 IS
v_RET VARCHAR2(32);
BEGIN
	IF g_MARKET_INTERVALS.EXISTS(p_MARKET_NAME) THEN
		v_RET := SUBSTR(g_MARKET_INTERVALS(p_MARKET_NAME),1,32);
	ELSE
		v_RET := 'Week';
	END IF;
	RETURN v_RET;
END GET_INVOICE_INTERVAL;
----------------------------------------------------------------------------------------
FUNCTION GET_ENTITY_ID
	(
	p_PARTICIPANT IN VARCHAR2,
	p_MARKET IN VARCHAR2 := g_DEFAULT_MARKET_NAME
	) RETURN NUMBER IS
v_EXT_IDENT VARCHAR2(512);
v_RET NUMBER;
v_ENTITY_INTERVAL VARCHAR2(32);
BEGIN
	v_EXT_IDENT := g_DEFAULT_ENTITY_NAME||':'||p_PARTICIPANT||':'||p_MARKET;

	BEGIN
		v_RET := EI.GET_ID_FROM_IDENTIFIER_EXTSYS(v_EXT_IDENT, EC.ED_PSE, EC.ES_SEM);
	EXCEPTION
		WHEN MSGCODES.e_ERR_NO_SUCH_ENTRY THEN

			SAVEPOINT BEFORE_PUT_PSE;

			v_ENTITY_INTERVAL := GET_INVOICE_INTERVAL(p_MARKET);

			-- not found? create it
			IO.PUT_PSE(
				v_RET,--O_OID,
				v_EXT_IDENT,--P_PSE_NAME,
				v_EXT_IDENT,--P_PSE_ALIAS,
				v_EXT_IDENT,--P_PSE_DESC,
				0,--P_PSE_ID,
				NULL,--P_PSE_NERC_CODE,
				'Active',--P_PSE_STATUS,
				NULL,--P_PSE_DUNS_NUMBER,
				NULL,--P_PSE_BANK,
				NULL,--P_PSE_ACH_NUMBER,
				'IPP',--P_PSE_TYPE,
				v_EXT_IDENT,--P_PSE_EXTERNAL_IDENTIFIER,
				0,--P_PSE_IS_RETAIL_AGGREGATOR,
				0,--P_PSE_IS_BACKUP_GENERATION,
				0,--P_PSE_EXCLUDE_LOAD_SCHEDULE,
				1,--P_IS_BILLING_ENTITY,
				MM_SEM_UTIL.g_TZ,--P_TIME_ZONE,
				'Day',--P_STATEMENT_INTERVAL,
				v_ENTITY_INTERVAL,--P_INVOICE_INTERVAL,
				MM_SEM_UTIL.g_WEEK_BEGIN,--P_WEEK_BEGIN,
				'By Component',--P_INVOICE_LINE_ITEM_OPTION
			   NULL,
			   NULL,
			   NULL,
			   NULL,
			   NULL,
			   NULL,
			   NULL,
			   NULL,
			   NULL,
			   NULL,
			   NULL,
			   NULL,
			   NULL);

			IF v_RET <= 0 THEN
				RAISE_APPLICATION_ERROR(-20000, 'Error#' || v_RET || ': Could not create PSE (for bill entity = '||v_EXT_IDENT||')');
			ELSE
				-- save external identifier, too
				BEGIN
					EI.PUT_EXTERNAL_SYSTEM_IDENTIFIER(EC.ES_SEM, EC.ED_PSE, v_RET, v_EXT_IDENT);
				EXCEPTION
					WHEN OTHERS THEN
						ROLLBACK TO BEFORE_PUT_PSE; -- undo the creation of the PSE
						RAISE;
				END;
			END IF;

	END;

    RETURN v_RET;

END GET_ENTITY_ID;
-----------------------------------------------------------------------------------------
PROCEDURE CHECK_IF_STATEMENT_LOADED
	(
	p_REPORT			IN CLOB,
	p_FILE_NAME			IN VARCHAR2,
	p_PARTICIPANT		IN VARCHAR2,
	p_SETTLEMENT_DAY	IN DATE,
	p_WORK_ID           IN NUMBER,
	p_PSE_ID			OUT NUMBER,
	p_STATEMENT_TYPE_ID	OUT SEM_STATEMENT_JOB.STATEMENT_TYPE_ID%TYPE,
	p_MP_FILE_REC		OUT SEM_MP_INFO_FILES%ROWTYPE
	) IS

BEGIN
   -- Get first summary record for one of these segments
	SELECT SEM_MP_INFO_SEQ.NEXTVAL,
		p_REPORT,
		CURRENT_TIMESTAMP,
		p_FILE_NAME,
		p_PARTICIPANT,
		p_SETTLEMENT_DAY,
		S.MARKET_CID,
		S.JOB_VERSION,
		S.JOB_ID
	INTO p_MP_FILE_REC
	FROM SEM_MP_INFO_S_TEMP S
	WHERE WORK_ID = p_WORK_ID
		AND PRODUCT_CID IN ('ENGEXG',
						  'CAPEXG',
						  'MOEXG',
						  'FMOEXG')
		AND ROWNUM = 1;

	-- Get the PSE associated with the file being processed.
	p_PSE_ID := GET_ENTITY_ID(p_PARTICIPANT, p_MP_FILE_REC.MARKET);

	-- get statement type ID
	SELECT MAX(SSJ.STATEMENT_TYPE_ID)
	INTO p_STATEMENT_TYPE_ID
	FROM SEM_STATEMENT_JOB SSJ
	WHERE SSJ.BILLING_ENTITY_ID = p_PSE_ID
		AND SSJ.STATEMENT_DATE  = p_SETTLEMENT_DAY
		AND SSJ.JOB_ID          = p_MP_FILE_REC.JOB_ID
		AND SSJ.JOB_VERSION     = p_MP_FILE_REC.JOB_VERSION;

END CHECK_IF_STATEMENT_LOADED;
-----------------------------------------------------------------------------------------
FUNCTION FETCH_CONVERSION_RATE
	(
	p_DATE IN DATE,
	p_LOGGER IN OUT NOCOPY MM_LOGGER_ADAPTER,
	p_FROM_EURO IN BOOLEAN := TRUE
	) RETURN NUMBER IS
v_RET NUMBER;
v_PRICE_ID NUMBER;
BEGIN
	IF p_FROM_EURO THEN
		v_PRICE_ID := MM_SEM_UTIL.GET_MARKET_PRICE_ID('Trading Day Exchange Rate: Euro to Pound',
			                                          NULL, NULL, FALSE);
		IF NVL(v_PRICE_ID,-1) <= 0 THEN
			p_LOGGER.LOG_WARN('Could not find Trading Day Exchange Rate for converting Euros to Pounds');
			RETURN NULL;
		END IF;
	ELSE
		v_PRICE_ID := MM_SEM_UTIL.GET_MARKET_PRICE_ID('Trading Day Exchange Rate: Pound to Euro',
			                                          NULL, NULL, FALSE);
		IF NVL(v_PRICE_ID,-1) <= 0 THEN
			p_LOGGER.LOG_WARN('Could not find Trading Day Exchange Rate for converting Pounds to Euros');
			RETURN NULL;
		END IF;
	END IF;

	SELECT MAX(PRICE)
	  INTO v_RET
	  FROM MARKET_PRICE_VALUE
	 WHERE MARKET_PRICE_ID = v_PRICE_ID
		AND PRICE_CODE = 'A'
		AND PRICE_DATE = TRUNC(p_DATE)
		AND AS_OF_DATE = LOW_DATE;

	RETURN v_RET;

END FETCH_CONVERSION_RATE;
-----------------------------------------------------------------------------------------
FUNCTION DETERMINE_CONVERSION_RATE_HOUR
	(
	p_CHARGE_DATE IN DATE,
	p_EXCHANGE_RATE CONVERSION_RATE_ARRAY
	) RETURN NUMBER IS
v_HOUR NUMBER;
BEGIN

	v_HOUR := MM_SEM_UTIL.GET_HOUR_FROM_DATE(p_CHARGE_DATE);
    IF v_HOUR <= 6 OR v_HOUR = 25 THEN
    	RETURN p_EXCHANGE_RATE(1);
    ELSE
    	RETURN p_EXCHANGE_RATE(2);
    END IF;

END DETERMINE_CONVERSION_RATE_HOUR;
-----------------------------------------------------------------------------------------
FUNCTION DETERMINE_CONVERSION_RATE
	(
	p_PSE_CURRENCY IN NUMBER, --0 for Euro, 1 for GBP
	p_DATE IN DATE,
	p_LOGGER IN OUT NOCOPY MM_LOGGER_ADAPTER
	) RETURN CONVERSION_RATE_ARRAY IS

v_EXCHANGE_RATE CONVERSION_RATE_ARRAY := CONVERSION_RATE_ARRAY();

BEGIN

	--PIR publishes rates only in Euro, therefore we are supposed to convert
	--the rates coming in PIR only for PSEs that have a GBP currency
	--If PSE currency is Euro then no conversion is needed.

	IF p_PSE_CURRENCY = 1 THEN
			--Get the exchange rate for the previous day.
			--This rate is going to be used for the first 6 hours of the settlement day
			v_EXCHANGE_RATE.EXTEND;
		v_EXCHANGE_RATE(v_EXCHANGE_RATE.LAST) := FETCH_CONVERSION_RATE(TRUNC(p_DATE)-1, p_LOGGER);
		IF v_EXCHANGE_RATE(v_EXCHANGE_RATE.LAST) IS NULL THEN
				p_LOGGER.LOG_WARN('No value found for '||TO_CHAR(p_DATE - 1,'YYYY-MM-DD')||' for Trading Day Exchange Rate (Euro to Pound)');
			END IF;

		-- This rate is used for the remaining 18 hours of the day
			v_EXCHANGE_RATE.EXTEND;
		v_EXCHANGE_RATE(v_EXCHANGE_RATE.LAST) := FETCH_CONVERSION_RATE(TRUNC(p_DATE), p_LOGGER);
		IF v_EXCHANGE_RATE(v_EXCHANGE_RATE.LAST) IS NULL THEN
				p_LOGGER.LOG_WARN('No value found for '||TO_CHAR(p_DATE,'YYYY-MM-DD')||' for Trading Day Exchange Rate (Euro to Pound)');
			END IF;
	ELSE
		--Return two rates of 1 in case of a PSE with a Euro currency
		v_EXCHANGE_RATE := CONVERSION_RATE_ARRAY(1,1);
	END IF;

	RETURN v_EXCHANGE_RATE;

END DETERMINE_CONVERSION_RATE;
-----------------------------------------------------------------------------------------
FUNCTION VALIDATE_STATEMENT_TYPE
	(
      p_REPORT_STATEMENT_TYPE_ID IN STATEMENT_TYPE.STATEMENT_TYPE_ID%TYPE,
      p_FILE_STATEMENT_TYPE IN VARCHAR2,
	  p_LOGGER IN OUT NOCOPY MM_LOGGER_ADAPTER
	) RETURN BOOLEAN IS
    v_REPORT_STATEMENT_TYPE VARCHAR2(32);
BEGIN

	v_REPORT_STATEMENT_TYPE := EI.GET_ENTITY_IDENTIFIER_EXTSYS(EC.ED_STATEMENT_TYPE, p_REPORT_STATEMENT_TYPE_ID, EC.ES_SEM, MM_SEM_UTIL.g_STATEMENT_TYPE_SETTLEMENT, 1);

   IF LENGTH(v_REPORT_STATEMENT_TYPE) >= 1 AND LENGTH(p_FILE_STATEMENT_TYPE) >= 1
   		AND SUBSTR(v_REPORT_STATEMENT_TYPE, 1, 1) = SUBSTR(p_FILE_STATEMENT_TYPE, 1, 1) THEN
      RETURN TRUE;
   ELSE
	  p_LOGGER.LOG_WARN('Settlement type code in report header ('||p_FILE_STATEMENT_TYPE||') differs from that specified in file name ('||v_REPORT_STATEMENT_TYPE||'). Using value specified in report header.');
      RETURN FALSE;
   END IF;
END VALIDATE_STATEMENT_TYPE;
----------------------------------------------------------------------------------------
PROCEDURE PRIOR_BILLING_STATEMENT(p_PRIOR_CHARGE_ID IN NUMBER,
								  p_BILLING_STATEMENT IN OUT BILLING_STATEMENT%ROWTYPE,
								  p_MKT_SEGMENT IN SEM_STATEMENT_H_TEMP.MKT_SEGMENT%TYPE) AS
	v_STATEMENT_EXTID EXTERNAL_SYSTEM_IDENTIFIER.EXTERNAL_IDENTIFIER%TYPE;
BEGIN
	v_STATEMENT_EXTID := EI.GET_ENTITY_IDENTIFIER_EXTSYS(EC.ED_STATEMENT_TYPE,
														 p_BILLING_STATEMENT.STATEMENT_TYPE,
														 EC.ES_SEM,
														 MM_SEM_UTIL.g_STATEMENT_TYPE_SETTLEMENT,
														 1);

	-- BZ 17123: IPCC charges (currency charges) always have bill amount = charge amount, regardless of revision
	IF GA.APPLY_PRIOR_BILL_CHARGES AND NOT p_PRIOR_CHARGE_ID = PC.g_NOT_ASSIGNED AND
	   v_STATEMENT_EXTID NOT IN
	   (MM_SEM_UTIL.g_EXTID_SETTLEMENT_P, MM_SEM_UTIL.g_EXTID_SETTLEMENT_F) AND
	   p_MKT_SEGMENT NOT LIKE '%IPCC' THEN

		SELECT CHARGE_QUANTITY, CHARGE_AMOUNT
		  INTO p_BILLING_STATEMENT.BILL_QUANTITY, p_BILLING_STATEMENT.BILL_AMOUNT
		  FROM BILLING_STATEMENT
		 WHERE CHARGE_ID = p_PRIOR_CHARGE_ID
			   AND STATEMENT_STATE = p_BILLING_STATEMENT.STATEMENT_STATE;
		p_BILLING_STATEMENT.BILL_QUANTITY := p_BILLING_STATEMENT.CHARGE_QUANTITY -
											 p_BILLING_STATEMENT.BILL_QUANTITY;
		p_BILLING_STATEMENT.BILL_AMOUNT   := p_BILLING_STATEMENT.CHARGE_AMOUNT -
											 p_BILLING_STATEMENT.BILL_AMOUNT;
	ELSE
		p_BILLING_STATEMENT.BILL_QUANTITY := p_BILLING_STATEMENT.CHARGE_QUANTITY;
		p_BILLING_STATEMENT.BILL_AMOUNT   := p_BILLING_STATEMENT.CHARGE_AMOUNT;
	END IF;

EXCEPTION
	WHEN NO_DATA_FOUND OR MSGCODES.e_ERR_NO_SUCH_ENTRY THEN
		p_BILLING_STATEMENT.BILL_QUANTITY := p_BILLING_STATEMENT.CHARGE_QUANTITY;
		p_BILLING_STATEMENT.BILL_AMOUNT   := p_BILLING_STATEMENT.CHARGE_AMOUNT;

END PRIOR_BILLING_STATEMENT;
---------------------------------------------------------------------------------------------------
FUNCTION GET_PRODUCT_ID
	(
	p_MARKET IN VARCHAR2
	) RETURN NUMBER IS
v_RET NUMBER;
BEGIN

	BEGIN
		v_RET := EI.GET_ID_FROM_IDENTIFIER_EXTSYS(p_MARKET, EC.ED_PRODUCT, EC.ES_SEM);
	EXCEPTION WHEN MSGCODES.e_ERR_NO_SUCH_ENTRY THEN

		SAVEPOINT BEFORE_PUT_PRODUCT;

		-- not found? create it
		IO.PUT_PRODUCT(
            v_RET,--O_OID,
            'SEM '||p_MARKET,--P_PRODUCT_NAME,
            'SEM '||p_MARKET,--P_PRODUCT_ALIAS,
            'SEM '||p_MARKET,--P_PRODUCT_DESC,
            0,--P_PRODUCT_ID,
            p_MARKET,--P_PRODUCT_EXTERNAL_IDENTIFIER,
			p_MARKET,--P_PRODUCT_CATEGORY
			LOW_DATE,--P_BEGIN_DATE
			HIGH_DATE--P_END_DATE
			);

		IF v_RET <= 0 THEN
			RAISE_APPLICATION_ERROR(-20000, 'Error#' || v_RET || ': Could not create product (for market = '||p_MARKET||')');
		ELSE
			-- save external identifier, too
			BEGIN
				EI.PUT_EXTERNAL_SYSTEM_IDENTIFIER(EC.ES_SEM, EC.ED_PRODUCT, v_RET, p_MARKET);
			EXCEPTION
				WHEN OTHERS THEN
					ROLLBACK TO BEFORE_PUT_PRODUCT; -- undo the creation of the product
					RAISE;
			END;
		END IF;

	END;

    RETURN v_RET;

END GET_PRODUCT_ID;
----------------------------------------------------------------------------------------
FUNCTION GET_COMPONENT_ID
	(
	p_CHARGE_CODE IN VARCHAR2,
	p_CHARGE_DESC IN VARCHAR2
	) RETURN NUMBER IS
v_EXT_IDENT VARCHAR2(512);
v_RET NUMBER;
BEGIN
    v_EXT_IDENT := p_CHARGE_CODE;

	BEGIN
		v_RET := EI.GET_ID_FROM_IDENTIFIER_EXTSYS(v_EXT_IDENT, EC.ED_COMPONENT, EC.ES_SEM);
	EXCEPTION WHEN MSGCODES.e_ERR_NO_SUCH_ENTRY THEN

		SAVEPOINT BEFORE_PUT_COMPONENT;

		-- not found? create it
		IO.PUT_COMPONENT(
            v_RET,--O_OID,
            p_CHARGE_CODE,--P_COMPONENT_NAME,
            v_EXT_IDENT,--P_COMPONENT_ALIAS,
            p_CHARGE_DESC,--P_COMPONENT_DESC,
            0,--P_COMPONENT_ID,
            'PSE',--P_COMPONENT_ENTITY,
            'SEM',--P_CHARGE_TYPE,
            'SEM',--P_RATE_STRUCTURE,
            '30 Minute',--P_RATE_INTERVAL,
            0,--P_IS_REBILL,
            0,--P_IS_TAXED,
            0,--P_IS_CUSTOM_CHARGE,
            0,--P_IS_CREDIT_CHARGE,
            0,--P_IS_INCLUDE_TX_LOSS,
            0,--P_IS_INCLUDE_DX_LOSS,
            0,--P_TEMPLATE_ID,
            0,--P_MARKET_PRICE_ID,
            0,--P_SERVICE_POINT_ID,
            0,--P_MODEL_ID,
            0,--P_EVENT_ID,
            NULL,--P_COMPONENT_REFERENCE,
            0,--P_INVOICE_GROUP_ID,
            0,--P_INVOICE_GROUP_ORDER,
            0,--P_COMPUTATION_ORDER,
            NULL,--P_QUANTITY_UNIT,
            NULL,--P_CURRENCY_UNIT,
            NULL,--P_QUANTITY_TYPE,
            v_EXT_IDENT,--P_EXTERNAL_IDENTIFIER,
            NULL, --P_COMPONENT_CATEGORY,
            NULL,--P_GL_DEBIT_ACCOUNT,
            NULL,--P_GL_CREDIT_ACCOUNT,
            NULL,--P_FIRM_NON_FIRM,
            0,--P_EXCLUDE_FROM_INVOICE,
            0,--P_EXCLUDE_FROM_INVOICE_TOTAL,
            NULL,--P_IMBALANCE_TYPE,
            NULL,--P_ACCUMULATION_PERIOD,
            0,--P_BASE_COMPONENT_ID,
            0,--P_BASE_LIMIT_ID,
            NULL,--P_MARKET_TYPE,
            NULL,--P_MARKET_PRICE_TYPE,
            'First',--P_WHICH_INTERVAL,
            NULL,--P_LMP_PRICE_CALC,
            0,--P_LMP_INCLUDE_EXT,
            0,--P_LMP_INCLUDE_SALES,
            NULL,--P_CHARGE_WHEN,
            1,--P_BILATERALS_SIGN,
            0,--P_LMP_COMMODITY_ID,
            0,--P_LMP_BASE_COMMODITY_ID,
            0,--P_USE_ZONAL_PRICE,
            NULL,--P_ALTERNATE_PRICE,
            NULL,--P_ALTERNATE_PRICE_FUNCTION
			0, -- p_EXCLUDE_FROM_BILLING_EXPORT,
			NULL, -- p_IS_DEFAULT_TEMPLATE
			NULL, -- p_KWH_MULTIPLIER
			NULL, -- p_ANCILLARY_SERVICE_ID
            NULL, -- p_APPLY_RATE_FOR
			NULL); -- p_LOSS_ADJ_TYPE

		IF v_RET <= 0 THEN
			RAISE_APPLICATION_ERROR(-20000, 'Error#' || v_RET || ': Could not create component (for charge type = '||v_EXT_IDENT||')');
		ELSE
			-- save external identifier, too
			BEGIN
				EI.PUT_EXTERNAL_SYSTEM_IDENTIFIER(EC.ES_SEM, EC.ED_COMPONENT, v_RET, v_EXT_IDENT);
			EXCEPTION
				WHEN OTHERS THEN
					ROLLBACK TO BEFORE_PUT_COMPONENT; -- undo the creation of the component
					RAISE;
			END;
		END IF;

	END;

    RETURN v_RET;

END GET_COMPONENT_ID;
----------------------------------------------------------------------------------------------------
FUNCTION GET_VAT_COMPONENT
(
    p_DATE DATE,
    p_BILLING_ENTITY_ID NUMBER
)
RETURN VARCHAR IS
v_INTERVAL PSE.INVOICE_INTERVAL%TYPE;
v_VAT_COMPONENT VARCHAR2(16);
BEGIN
    IF MM_SEM_UTIL.USING_CROSS_BORDER_VAT_FORMAT(p_DATE, p_BILLING_ENTITY_ID) THEN
        SELECT MAX(INVOICE_INTERVAL)
        INTO v_INTERVAL
        FROM PSE
        WHERE PSE.PSE_ID = p_BILLING_ENTITY_ID;
        v_VAT_COMPONENT := CASE WHEN v_INTERVAL = MM_SEM_UTIL.c_INVOICE_INTERVAL_MONTH THEN MM_SEM_UTIL.c_VAT_MONTHLY_CHARGE_NAME
                                WHEN v_INTERVAL = MM_SEM_UTIL.c_INVOICE_INTERVAL_WEEK THEN MM_SEM_UTIL.c_VAT_WEEKLY_CHARGE_NAME END;

    ELSE
        v_VAT_COMPONENT := MM_SEM_UTIL.c_VAT_BLENDED_CHARGE_NAME;
    END IF;
    RETURN v_VAT_COMPONENT;
END GET_VAT_COMPONENT;
----------------------------------------------------------------------------------------
PROCEDURE INIT_COMP_DET_CONSTANTS_CACHE(p_SETTLEMENT_DATE IN DATE) IS
	-- initialize cache of "hardwired" variables in charge components.
	-- from UNIMPEX, we get ENGTOL, MWTOL, DOG, PUG, and UREG (BZ 15486)
	-- from CPEX we get VOLL_Euro (we aren't currently using this)
	CURSOR c_ASSOC_ARRAY IS
		SELECT VARIABLE_NAME, FORMULA
		FROM COMPONENT_FORMULA_VARIABLE CFV, COMPONENT C
		WHERE (C.COMPONENT_ID =
			  EI.GET_ID_FROM_IDENTIFIER_EXTSYS('UNIMPEX', EC.ED_COMPONENT, EC.ES_SEM) OR
			  C.COMPONENT_ID =
			  EI.GET_ID_FROM_IDENTIFIER_EXTSYS('CPEX', EC.ED_COMPONENT, EC.ES_SEM))
		AND CFV.COMPONENT_ID = C.COMPONENT_ID
		AND CFV.SUB_COMPONENT_TYPE = '?'
		AND CFV.SUB_COMPONENT_ID = 0
		AND p_SETTLEMENT_DATE BETWEEN CFV.BEGIN_DATE AND NVL(CFV.END_DATE, HIGH_DATE)
		AND VARIABLE_NAME IN ('MWTOL', 'ENGTOL', 'DOG', 'PUG', 'UREG', 'VOLL_Euro');

BEGIN
	FOR r IN c_ASSOC_ARRAY LOOP
		g_COMP_DET_CONSTANTS_CACHE(r.VARIABLE_NAME) := r.FORMULA;
	END LOOP;
END INIT_COMP_DET_CONSTANTS_CACHE;
----------------------------------------------------------------------------------------
FUNCTION CHECK_MARKET_NAME
	(
	p_MARKET_NAME IN VARCHAR2,
	p_ALLOWED_MARKETS IN STRING_COLLECTION
	) RETURN BOOLEAN IS
v_COUNT BINARY_INTEGER;
BEGIN
	-- Finally, make sure the specified market is valid
	SELECT COUNT(1)
	INTO v_COUNT
	FROM TABLE(CAST(p_ALLOWED_MARKETS AS STRING_COLLECTION)) X
	WHERE UPPER(X.COLUMN_VALUE) = p_MARKET_NAME;

	IF v_COUNT = 0 THEN
		RETURN FALSE;
	ELSE
		RETURN TRUE;
	END IF;
END CHECK_MARKET_NAME;
----------------------------------------------------------------------------------------
PROCEDURE CHECK_MARKET_NAME
	(
	p_MARKET_NAME IN VARCHAR2,
	p_LOGGER IN OUT NOCOPY MM_LOGGER_ADAPTER
	) IS
BEGIN
	IF NOT CHECK_MARKET_NAME(p_MARKET_NAME, g_MARKETS) THEN
		p_LOGGER.LOG_WARN('Encountered unrecognized market name: '||p_MARKET_NAME);
	END IF;
END CHECK_MARKET_NAME;
----------------------------------------------------------------------------------------
PROCEDURE CLEANUP_SETTLEMENT_WORK
	(
	p_WORK_ID IN NUMBER
	) AS
BEGIN
	-- doing deletes instead of the truncate statements because
	-- truncate does an implicit commit...
	DELETE SEM_STATEMENT_H_TEMP WHERE WORK_ID = p_WORK_ID;
	DELETE SEM_STATEMENT_S_TEMP WHERE WORK_ID = p_WORK_ID;
	DELETE SEM_STATEMENT_D_TEMP WHERE WORK_ID = p_WORK_ID;

	DELETE SEM_MP_INFO_H_TEMP WHERE WORK_ID = p_WORK_ID;
	DELETE SEM_MP_INFO_S_TEMP WHERE WORK_ID = p_WORK_ID;
	DELETE SEM_MP_INFO_D_TEMP WHERE WORK_ID = p_WORK_ID;

	DELETE SEM_SRA_H_TEMP WHERE WORK_ID = p_WORK_ID;
	DELETE SEM_SRA_D_TEMP WHERE WORK_ID = p_WORK_ID;
END CLEANUP_SETTLEMENT_WORK;
----------------------------------------------------------------------------------------
FUNCTION GET_MARKET_FROM_FILE_NAME
	(
	p_FILE_NAME IN VARCHAR2,
	p_FILE_TYPE IN VARCHAR2,
	p_ALLOWED_MARKETS IN STRING_COLLECTION := NULL
	) RETURN VARCHAR2 IS
v_ALLOWED_MARKETS STRING_COLLECTION;
v_MKT VARCHAR2(4);
v_FILE_TYPE VARCHAR2(32);
v_POS1 BINARY_INTEGER;
v_POS2 BINARY_INTEGER;
BEGIN
	IF p_ALLOWED_MARKETS IS NULL THEN
		v_ALLOWED_MARKETS := g_MARKETS;
	ELSE
		v_ALLOWED_MARKETS := p_ALLOWED_MARKETS;
	END IF;

	v_POS1 := INSTR(p_FILE_NAME,'_');
	IF v_POS1 = 0 OR v_POS1 > 4 THEN
		MM_SEM_UTIL.RAISE_ERR(g_INVALID_FILENAME_ERR_NO, 'File name does not indicate a valid market and file type');
	END IF;

	v_MKT := UPPER(SUBSTR(p_FILE_NAME,1,v_POS1-1));

	v_POS2 := INSTR(p_FILE_NAME,'_',v_POS1+1);
	IF v_POS2 = 0 THEN
		MM_SEM_UTIL.RAISE_ERR(g_INVALID_FILENAME_ERR_NO, 'File name does not indicate a valid market and file type');
	END IF;

	v_FILE_TYPE := SUBSTR(p_FILE_NAME,v_POS1+1,v_POS2-v_POS1-1);
	IF UPPER(v_FILE_TYPE) != UPPER(p_FILE_TYPE) THEN
		MM_SEM_UTIL.RAISE_ERR(g_INVALID_FILENAME_ERR_NO, 'File name indicates wrong file type: expecting '||p_FILE_TYPE||' but found '||v_FILE_TYPE);
	END IF;

	IF NOT CHECK_MARKET_NAME(v_MKT, v_ALLOWED_MARKETS) THEN
		MM_SEM_UTIL.RAISE_ERR(g_INVALID_FILENAME_ERR_NO, 'File name indicates incorrect market: '||v_MKT);
	END IF;

	RETURN v_MKT;

END GET_MARKET_FROM_FILE_NAME;
----------------------------------------------------------------------------------------
PROCEDURE PUT_DETAIL_CHARGE
	(
	p_REC IN SEM_DETAIL_CHARGE%ROWTYPE
	) IS
BEGIN
	UPDATE SEM_DETAIL_CHARGE
		SET ROW = p_REC
	 WHERE CHARGE_ID     = p_REC.CHARGE_ID
		AND CHARGE_DATE   = p_REC.CHARGE_DATE
		AND RESOLUTION    = p_REC.RESOLUTION
		AND RESOURCE_NAME = p_REC.RESOURCE_NAME
		AND LOCATION_NAME = p_REC.LOCATION_NAME
		AND REC_ORDER     = p_REC.REC_ORDER;

	IF SQL%NOTFOUND THEN
		INSERT INTO SEM_DETAIL_CHARGE VALUES p_REC;
	END IF;
END PUT_DETAIL_CHARGE;
----------------------------------------------------------------------------------------
PROCEDURE PUT_VAT_BLENDED_CHARGE
	(
	p_ENTITY_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_STATEMENT_DATE IN DATE,
	p_STATEMENT_END_DATE IN DATE,
	p_TAXED_PRODUCT_ID IN NUMBER
	) AS

	v_BS BILLING_STATEMENT%ROWTYPE;
	v_FORMULA_CHARGE FORMULA_CHARGE%ROWTYPE;
	v_ITERATOR_NAME FORMULA_CHARGE_ITERATOR_NAME%ROWTYPE;
	v_ITERATOR FORMULA_CHARGE_ITERATOR%ROWTYPE;
	v_COMPONENT_ID NUMBER(9);
	v_PRODUCT_ID NUMBER(9);

	v_DEL_ITERATOR_IDS ID_TABLE := ID_TABLE();
	v_TAX_RATE NUMBER;

	v_ITERATOR_NAMES	  CALC_ENGINE.ITERATOR_VALS := CALC_ENGINE.ITERATOR_VALS(NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
	v_ITERATOR_VALS		  CALC_ENGINE.ITERATOR_VALS := CALC_ENGINE.ITERATOR_VALS(NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
CURSOR c_COMPONENTS IS
	SELECT COMPONENT_NAME,
		A.COMPONENT_ID,
		C.CHARGE_AMOUNT,
		C.BILL_AMOUNT
	FROM COMPONENT A, PRODUCT_COMPONENT B, BILLING_STATEMENT C
	WHERE B.PRODUCT_ID = p_TAXED_PRODUCT_ID
		AND p_STATEMENT_DATE BETWEEN B.BEGIN_DATE AND NVL(B.END_DATE, p_STATEMENT_DATE)
		AND A.COMPONENT_ID = B.COMPONENT_ID
		AND C.ENTITY_ID = p_ENTITY_ID
		AND C.PRODUCT_ID = p_TAXED_PRODUCT_ID
		AND C.COMPONENT_ID = B.COMPONENT_ID
		AND C.STATEMENT_TYPE = p_STATEMENT_TYPE
		AND C.STATEMENT_STATE = p_STATEMENT_STATE
		AND C.STATEMENT_DATE = p_STATEMENT_DATE
		AND C.AS_OF_DATE = LOW_DATE;
BEGIN
	-- Find the Product and Component ID of the Tax Charge.
	v_COMPONENT_ID := GET_COMPONENT_ID(MM_SEM_UTIL.c_VAT_BLENDED_CHARGE_NAME, MM_SEM_UTIL.c_VAT_BLENDED_CHARGE_NAME || ' Charge Component generated by MarketManager');

	v_TAX_RATE := NVL(MM_SEM_SHADOW_BILL.GET_TAX_RATE(p_STATEMENT_DATE, p_ENTITY_ID),0);

	BEGIN
		SELECT PRODUCT_ID INTO v_PRODUCT_ID
		FROM PRODUCT_COMPONENT
		WHERE COMPONENT_ID = v_COMPONENT_ID
			AND p_STATEMENT_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE, p_STATEMENT_DATE);
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			MM_SEM_UTIL.RAISE_ERR(-20000, 'VAT Component does not exist, or is missing a Product association in the PRODUCT_COMPONENT table for ' || TO_CHAR(p_STATEMENT_DATE, 'YYYY-MM-DD') || '.');
		WHEN TOO_MANY_ROWS THEN
			MM_SEM_UTIL.RAISE_ERR(-20000, 'VAT Component has multiple Product associations in the PRODUCT_COMPONENT table for ' || TO_CHAR(p_STATEMENT_DATE, 'YYYY-MM-DD') || '.');
	END;

	-- See if a Tax charge already exists on this statement.
	BEGIN
		SELECT *
		INTO v_BS
		FROM BILLING_STATEMENT
		WHERE ENTITY_ID = p_ENTITY_ID
			AND PRODUCT_ID = v_PRODUCT_ID
			AND COMPONENT_ID = v_COMPONENT_ID
			AND STATEMENT_TYPE = p_STATEMENT_TYPE
			AND STATEMENT_STATE = p_STATEMENT_STATE
			AND STATEMENT_DATE = p_STATEMENT_DATE
			AND AS_OF_DATE = LOW_DATE;

		-- If we found a charge ID, delete any existing detail rows for this product.
		-- The value of ITERATOR1 is the Component Name of the Component.
		-- So we are deleting tax data for all components that relate to the Taxed Product.
		DELETE FORMULA_CHARGE_ITERATOR A
		WHERE CHARGE_ID = v_BS.CHARGE_ID
			AND ITERATOR1 IN
				(SELECT COMPONENT_NAME
				FROM COMPONENT A, PRODUCT_COMPONENT B
				WHERE B.PRODUCT_ID = p_TAXED_PRODUCT_ID
                    AND A.COMPONENT_ID = B.COMPONENT_ID
					AND p_STATEMENT_DATE BETWEEN B.BEGIN_DATE AND NVL(B.END_DATE, p_STATEMENT_DATE))
		RETURNING ID_TYPE(ITERATOR_ID)
		BULK COLLECT INTO v_DEL_ITERATOR_IDS;

		IF v_DEL_ITERATOR_IDS.COUNT > 0 THEN
			DELETE FORMULA_CHARGE A
			WHERE CHARGE_ID = v_BS.CHARGE_ID
				AND ITERATOR_ID IN (SELECT X.ID FROM TABLE(CAST(v_DEL_ITERATOR_IDS AS ID_TABLE)) X);
		END IF;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			-- Add a Billing Statement record for the TAX component.
			v_BS.ENTITY_ID := p_ENTITY_ID;
			v_BS.PRODUCT_ID := v_PRODUCT_ID;
			v_BS.COMPONENT_ID := v_COMPONENT_ID;
			v_BS.STATEMENT_TYPE := p_STATEMENT_TYPE;
			v_BS.STATEMENT_STATE := p_STATEMENT_STATE;
			v_BS.STATEMENT_DATE := p_STATEMENT_DATE;
			v_BS.AS_OF_DATE := LOW_DATE;
			v_BS.STATEMENT_END_DATE := p_STATEMENT_END_DATE;
			v_BS.BASIS_AS_OF_DATE := LOW_DATE;
			v_BS.CHARGE_INTERVAL := 'Day';
			v_BS.ENTITY_TYPE := 'PSE';
			v_BS.CHARGE_VIEW_TYPE := 'FORMULA';

			SELECT BID.NEXTVAL INTO v_BS.CHARGE_ID FROM DUAL;

			-- Insert the initial billing statement record.
			PC.PUT_BILLING_STATEMENT(v_BS);
	END;

	v_ITERATOR_NAME.CHARGE_ID := v_BS.CHARGE_ID;
	v_ITERATOR.CHARGE_ID := v_BS.CHARGE_ID;
	v_FORMULA_CHARGE.CHARGE_ID := v_BS.CHARGE_ID;
	v_FORMULA_CHARGE.CHARGE_DATE := p_STATEMENT_DATE;

	-- Row type of table FORMULA_CHARGE.
	v_ITERATOR_NAME.ITERATOR_NAME1 := 'ChargeType';
	v_ITERATOR_NAME.ITERATOR_NAME2 := NULL;
	v_ITERATOR_NAME.ITERATOR_NAME3 := NULL;
	v_ITERATOR_NAME.ITERATOR_NAME4 := NULL;
	v_ITERATOR_NAME.ITERATOR_NAME5 := NULL;
	PC.PUT_FORMULA_ITERATOR_NAMES(v_ITERATOR_NAME);

	-- Collection of Iterator Names.
	v_ITERATOR_NAMES(1)  := v_ITERATOR_NAME.ITERATOR_NAME1;

	-- For each Component related to the Taxed Product
	FOR v_TAXED_COMP IN c_COMPONENTS LOOP

		-- Row type of table FORMULA_CHARGE_ITERATOR.
		v_ITERATOR.ITERATOR1 := v_TAXED_COMP.COMPONENT_NAME;
		v_ITERATOR.ITERATOR2 := NULL;
		v_ITERATOR.ITERATOR3 := NULL;
		v_ITERATOR.ITERATOR4 := NULL;
		v_ITERATOR.ITERATOR5 := NULL;

		-- Collection of Iterator Values.
		v_ITERATOR_VALS(1)  := v_ITERATOR.ITERATOR1;

		-- Get the Iterator ID. If a row already exists, get that ID. Else create a new one.
	   	CALC_ENGINE.GET_FORMULA_CHARGE_ITERATOR_ID(v_ITERATOR_NAME.CHARGE_ID, v_ITERATOR_NAMES, v_ITERATOR_VALS, v_ITERATOR.ITERATOR_ID);

		v_FORMULA_CHARGE.ITERATOR_ID := v_ITERATOR.ITERATOR_ID;

		-- Get the tax rate for the component and calculate the bill and charge amounts.
		v_FORMULA_CHARGE.CHARGE_QUANTITY := v_TAXED_COMP.CHARGE_AMOUNT;
		v_FORMULA_CHARGE.CHARGE_RATE := v_TAX_RATE;
		v_FORMULA_CHARGE.CHARGE_AMOUNT := v_FORMULA_CHARGE.CHARGE_RATE * v_FORMULA_CHARGE.CHARGE_QUANTITY;
		v_FORMULA_CHARGE.BILL_QUANTITY := v_TAXED_COMP.BILL_AMOUNT;
		v_FORMULA_CHARGE.BILL_AMOUNT := v_FORMULA_CHARGE.CHARGE_RATE * v_FORMULA_CHARGE.BILL_QUANTITY;
		PC.PUT_FORMULA_CHARGE(v_FORMULA_CHARGE);

    END LOOP;

	-- Set the total in the Billing Statement record to be the total Tax so far.
	SELECT SUM(B.CHARGE_AMOUNT), SUM(B.BILL_AMOUNT)
	INTO v_BS.CHARGE_AMOUNT, v_BS.BILL_AMOUNT
	FROM FORMULA_CHARGE B
	WHERE B.CHARGE_ID = v_BS.CHARGE_ID
		AND B.CHARGE_DATE = p_STATEMENT_DATE;

	-- Update the Billing Statement record with the new Charge Amount.
	PC.PUT_BILLING_STATEMENT(v_BS);

END PUT_VAT_BLENDED_CHARGE;
----------------------------------------------------------------------------------------
PROCEDURE PUT_VAT_CHARGE
	(
	p_INVOICE IN INVOICE%ROWTYPE
	) AS

	v_BS BILLING_STATEMENT%ROWTYPE;
	v_FORMULA_CHARGE FORMULA_CHARGE%ROWTYPE;
	v_ITERATOR_NAME FORMULA_CHARGE_ITERATOR_NAME%ROWTYPE;
	v_ITERATOR FORMULA_CHARGE_ITERATOR%ROWTYPE;
	v_COMPONENT_ID NUMBER(9);
	v_PRODUCT_ID NUMBER(9);

    v_VAT_CHARGE_NAME VARCHAR2(16);

	v_ITERATOR_NAMES	  CALC_ENGINE.ITERATOR_VALS := CALC_ENGINE.ITERATOR_VALS(NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
	v_ITERATOR_VALS		  CALC_ENGINE.ITERATOR_VALS := CALC_ENGINE.ITERATOR_VALS(NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);

	v_CHARGE_DATE DATE; -- used to adjust BILLING_STATEMENT.BEGIN_DATE by one second for lining up formula charge drill-down compare

CURSOR c_COMPONENTS IS
	SELECT SLI.LINE_ITEM_NAME AS COMPONENT_NAME,
		   SLI.TAX_AMOUNT,
		   SLI.AMOUNT AS CHARGE_AMOUNT,
           SLI.TAX_PERCENT_TEXT
	FROM SEM_INVOICE_LINE_ITEM SLI
	WHERE SLI.INVOICE_ID = p_INVOICE.INVOICE_ID;
BEGIN
	-- Find the Product and Component ID of the Tax Charge.
    v_VAT_CHARGE_NAME := GET_VAT_COMPONENT(p_INVOICE.END_DATE, p_INVOICE.ENTITY_ID);
    v_COMPONENT_ID := GET_COMPONENT_ID(v_VAT_CHARGE_NAME, v_VAT_CHARGE_NAME || 'Charge Component generated by MarketManager');

	BEGIN
		SELECT PRODUCT_ID INTO v_PRODUCT_ID
		FROM PRODUCT_COMPONENT
		WHERE COMPONENT_ID = v_COMPONENT_ID
			AND p_INVOICE.END_DATE > BEGIN_DATE
			AND p_INVOICE.BEGIN_DATE < NVL(END_DATE, HIGH_DATE);
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			MM_SEM_UTIL.RAISE_ERR(-20000, 'VAT Component does not exist, or is missing a Product association in the PRODUCT_COMPONENT table for ' || TEXT_UTIL.TO_CHAR_DATE_RANGE(p_INVOICE.BEGIN_DATE, p_INVOICE.END_DATE) || '.');
		WHEN TOO_MANY_ROWS THEN
			MM_SEM_UTIL.RAISE_ERR(-20000, 'VAT Component has multiple Product associations in the PRODUCT_COMPONENT table for ' || TEXT_UTIL.TO_CHAR_DATE_RANGE(p_INVOICE.BEGIN_DATE, p_INVOICE.END_DATE) || '.');
	END;

	-- Delete existing VAT record in BILLING_STATEMENT if it exists
	DELETE FROM BILLING_STATEMENT
    WHERE ENTITY_ID = p_INVOICE.ENTITY_ID
    AND PRODUCT_ID = v_PRODUCT_ID
    AND COMPONENT_ID = v_COMPONENT_ID
    AND STATEMENT_TYPE = p_INVOICE.STATEMENT_TYPE
    AND STATEMENT_STATE = p_INVOICE.STATEMENT_STATE
    AND STATEMENT_DATE = p_INVOICE.BEGIN_DATE
    AND STATEMENT_END_DATE = p_INVOICE.END_DATE
    AND AS_OF_DATE = LOW_DATE;

    -- Add a Billing Statement record for the TAX component.
    v_BS.ENTITY_ID := p_INVOICE.ENTITY_ID;
    v_BS.PRODUCT_ID := v_PRODUCT_ID;
    v_BS.COMPONENT_ID := v_COMPONENT_ID;
    v_BS.STATEMENT_TYPE := p_INVOICE.STATEMENT_TYPE;
    v_BS.STATEMENT_STATE := p_INVOICE.STATEMENT_STATE;
    v_BS.STATEMENT_DATE := p_INVOICE.END_DATE;
    v_BS.AS_OF_DATE := LOW_DATE;
    v_BS.STATEMENT_END_DATE := p_INVOICE.END_DATE;
    v_BS.BASIS_AS_OF_DATE := LOW_DATE;
    v_BS.CHARGE_INTERVAL := 'Week';
    v_BS.ENTITY_TYPE := 'PSE';
    v_BS.CHARGE_VIEW_TYPE := 'FORMULA';

    SELECT BID.NEXTVAL INTO v_BS.CHARGE_ID FROM DUAL;

    -- Insert the initial billing statement record.
    PC.PUT_BILLING_STATEMENT(v_BS);

	v_ITERATOR_NAME.CHARGE_ID := v_BS.CHARGE_ID;
	v_ITERATOR.CHARGE_ID := v_BS.CHARGE_ID;
	v_FORMULA_CHARGE.CHARGE_ID := v_BS.CHARGE_ID;
	v_CHARGE_DATE := TRUNC(p_INVOICE.BEGIN_DATE, 'DD') + 0.00001;   -- jbc, 2013-06-26
	v_FORMULA_CHARGE.CHARGE_DATE := v_CHARGE_DATE; --p_INVOICE.BEGIN_DATE;  -- jbc, 2013-06-26
	v_FORMULA_CHARGE.PERIOD_END_DATE := p_INVOICE.END_DATE;

	-- Row type of table FORMULA_CHARGE.
	v_ITERATOR_NAME.ITERATOR_NAME1 := 'ChargeType';
	PC.PUT_FORMULA_ITERATOR_NAMES(v_ITERATOR_NAME);

	-- Collection of Iterator Names.
	v_ITERATOR_NAMES(1)  := v_ITERATOR_NAME.ITERATOR_NAME1;

	-- For each Component related to the Taxed Product
	FOR v_TAXED_COMP IN c_COMPONENTS LOOP

		-- Row type of table FORMULA_CHARGE_ITERATOR.
		v_ITERATOR.ITERATOR1 := v_TAXED_COMP.COMPONENT_NAME;
		v_ITERATOR.ITERATOR2 := NULL;
		v_ITERATOR.ITERATOR3 := NULL;
		v_ITERATOR.ITERATOR4 := NULL;
		v_ITERATOR.ITERATOR5 := NULL;

		-- Collection of Iterator Values.
		v_ITERATOR_VALS(1)  := v_ITERATOR.ITERATOR1;

		-- Get the Iterator ID. If a row already exists, get that ID. Else create a new one.
	   	CALC_ENGINE.GET_FORMULA_CHARGE_ITERATOR_ID(v_ITERATOR_NAME.CHARGE_ID, v_ITERATOR_NAMES, v_ITERATOR_VALS, v_ITERATOR.ITERATOR_ID);

		v_FORMULA_CHARGE.ITERATOR_ID := v_ITERATOR.ITERATOR_ID;

		-- Get the tax rate for the component and calculate the bill and charge amounts.
		v_FORMULA_CHARGE.CHARGE_QUANTITY := v_TAXED_COMP.CHARGE_AMOUNT;
		v_FORMULA_CHARGE.CHARGE_RATE := CASE WHEN v_TAXED_COMP.CHARGE_AMOUNT = 0 THEN NULL ELSE UT.GET_RATE_FOR_PERCENT_STRING(v_TAXED_COMP.TAX_PERCENT_TEXT) END;
		v_FORMULA_CHARGE.CHARGE_AMOUNT := CASE WHEN GA.ENABLE_REVERSE_SIGN_INVOICES THEN
                                				-1 * v_TAXED_COMP.TAX_AMOUNT
                                			ELSE
                                				v_TAXED_COMP.TAX_AMOUNT
                                			END;
		v_FORMULA_CHARGE.BILL_QUANTITY := v_TAXED_COMP.CHARGE_AMOUNT;
		v_FORMULA_CHARGE.BILL_AMOUNT := v_FORMULA_CHARGE.CHARGE_AMOUNT;

		PC.PUT_FORMULA_CHARGE(v_FORMULA_CHARGE);

    END LOOP;

	-- Set the total in the Billing Statement record to be the total Tax so far.
	SELECT SUM(B.CHARGE_AMOUNT), SUM(B.BILL_AMOUNT)
	INTO v_BS.CHARGE_AMOUNT, v_BS.BILL_AMOUNT
	FROM FORMULA_CHARGE B
	WHERE B.CHARGE_ID = v_BS.CHARGE_ID
		AND B.CHARGE_DATE = v_CHARGE_DATE --p_INVOICE.BEGIN_DATE  -- jbc, 2013-06-26
		AND B.PERIOD_END_DATE = p_INVOICE.END_DATE;

	-- Update the Billing Statement record with the new Charge Amount.
	PC.PUT_BILLING_STATEMENT(v_BS);

END PUT_VAT_CHARGE;
----------------------------------------------------------------------------------------
PROCEDURE FIX_BILLING_STATEMENT_VALUES
	(
	p_CHARGE_ID IN NUMBER
	) AS
v_CHARGE_QTY	BILLING_STATEMENT.CHARGE_QUANTITY%TYPE;
BEGIN
	SELECT NVL(SUM(CHARGE_QUANTITY),0)
	INTO v_CHARGE_QTY
	FROM FORMULA_CHARGE
	WHERE CHARGE_ID = p_CHARGE_ID;

	IF v_CHARGE_QTY <> 0 THEN
		UPDATE BILLING_STATEMENT SET
			CHARGE_QUANTITY = v_CHARGE_QTY,
			BILL_QUANTITY = BILL_QUANTITY + v_CHARGE_QTY - CHARGE_QUANTITY,
			CHARGE_RATE = CHARGE_AMOUNT/v_CHARGE_QTY
		WHERE CHARGE_ID = p_CHARGE_ID
			AND CHARGE_QUANTITY = 0;
	END IF;
END FIX_BILLING_STATEMENT_VALUES;
----------------------------------------------------------------------------------------
PROCEDURE EXTRACT_CCEX_CHARGE
    (
    p_STATEMENT_ID IN NUMBER,
    p_CHARGE_ID IN NUMBER,
    p_ENTITY_ID IN NUMBER,
	p_PSE_CURRENCY IN NUMBER,
    p_ERROR_UNIT IN BOOLEAN
    ) IS
CURSOR c_CHG_DETAIL(v_NAME IN VARCHAR2) IS
    SELECT S.CHARGE_DATE, S.RESOURCE_NAME,
           S.VALUE "ND_VAL", T.VALUE "CPDP_VAL", NDA.VALUE "NDA_VAL",
		   SNDLF.VALUE "SNDLF_VAL"
    FROM SEM_MP_INFO S, SEM_MP_INFO T, SEM_MP_INFO NDA, SEM_MP_INFO SNDLF
    WHERE S.STATEMENT_ID = p_STATEMENT_ID
    AND S.VARIABLE_TYPE = v_NAME
    AND T.STATEMENT_ID = p_STATEMENT_ID
    AND T.VARIABLE_TYPE = 'CPDP'
    AND T.CHARGE_DATE = S.CHARGE_DATE
	AND NDA.STATEMENT_ID(+) = p_STATEMENT_ID
	AND NDA.VARIABLE_TYPE(+) = 'NDA'
	AND NDA.CHARGE_DATE(+) = S.CHARGE_DATE
	AND NDA.RESOURCE_NAME(+) = S.RESOURCE_NAME
	AND SNDLF.STATEMENT_ID(+) = p_STATEMENT_ID
	AND SNDLF.VARIABLE_TYPE(+) = 'SNDLF'
	AND SNDLF.CHARGE_DATE(+) = S.CHARGE_DATE
	AND SNDLF.RESOURCE_NAME(+) = S.RESOURCE_NAME
    ORDER BY CHARGE_DATE, RESOURCE_NAME;
TYPE ITERATOR_ID_MAP IS TABLE OF NUMBER(2) INDEX BY VARCHAR2(32);
v_VAR_NAME VARCHAR2(8);
v_CHG_AMOUNT SEM_DETAIL_CHARGE.CHARGE_AMOUNT%TYPE;
v_FORMULA_CHARGE FORMULA_CHARGE%ROWTYPE;
v_FORMULA_CHARGE_VAR FORMULA_CHARGE_VARIABLE%ROWTYPE;
v_ITERATOR_NAME FORMULA_CHARGE_ITERATOR_NAME%ROWTYPE;
v_ITERATOR FORMULA_CHARGE_ITERATOR%ROWTYPE;
v_ITERATOR_ID_MAP ITERATOR_ID_MAP;
v_ITERATOR_ID NUMBER(3) := 0;
v_EXCH_RATE_ID MARKET_PRICE.MARKET_PRICE_ID%TYPE;
v_RATE NUMBER;
BEGIN
    UPDATE BILLING_STATEMENT
    SET CHARGE_VIEW_TYPE = 'FORMULA'
    WHERE CHARGE_ID = p_CHARGE_ID;

    v_ITERATOR_NAME.CHARGE_ID := p_CHARGE_ID;
    v_ITERATOR.CHARGE_ID := p_CHARGE_ID;
    v_FORMULA_CHARGE_VAR.CHARGE_ID := p_CHARGE_ID;
    v_FORMULA_CHARGE.CHARGE_ID := p_CHARGE_ID;

    v_ITERATOR_NAME.ITERATOR_NAME1 := g_ITER_NAME_SERVICE_POINT;
    PC.PUT_FORMULA_ITERATOR_NAMES(v_ITERATOR_NAME);

    IF p_ERROR_UNIT = FALSE THEN
		v_VAR_NAME := 'NDLF';
	ELSE
        v_VAR_NAME := 'NDLFESU';
 	END IF;

    FOR v_CHG_DETAIL IN C_CHG_DETAIL(v_VAR_NAME) LOOP
		--Get the Annual Capacity Exchange Rate
        v_EXCH_RATE_ID := MM_SEM_UTIL.GET_MARKET_PRICE_ID('Annual Capacity Exchange Rate: Euro to Pound',
                                                        NULL, NULL, FALSE);
        IF v_EXCH_RATE_ID IS NOT NULL THEN
            BEGIN
                SELECT PRICE INTO v_RATE
                FROM MARKET_PRICE_VALUE
                WHERE MARKET_PRICE_ID = v_EXCH_RATE_ID
                AND PRICE_DATE = TRUNC(v_CHG_DETAIL.CHARGE_DATE, 'MM')
                AND PRICE_CODE = 'A';

				--BZ 16245 - LD - Do not convert CCEX val for ROI participants
				IF p_PSE_CURRENCY = 0 THEN v_RATE := 1; END IF;
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    v_RATE := 0;
            END;
        ELSE
            v_RATE := 0;
        END IF;

        IF v_ITERATOR_ID_MAP.EXISTS(v_CHG_DETAIL.RESOURCE_NAME) THEN
            v_ITERATOR.ITERATOR_ID := v_ITERATOR_ID_MAP(v_CHG_DETAIL.RESOURCE_NAME);
        ELSE
            v_ITERATOR.ITERATOR_ID := v_ITERATOR_ID + 1;
            v_ITERATOR_ID_MAP(v_CHG_DETAIL.RESOURCE_NAME) := v_ITERATOR.ITERATOR_ID;
            v_ITERATOR_ID := v_ITERATOR_ID + 1;
        END IF;

        v_ITERATOR.ITERATOR1 := v_CHG_DETAIL.RESOURCE_NAME;
        PC.PUT_FORMULA_ITERATOR(v_ITERATOR);

        v_FORMULA_CHARGE_VAR.ITERATOR_ID := v_ITERATOR.ITERATOR_ID;
        v_FORMULA_CHARGE_VAR.CHARGE_DATE := v_CHG_DETAIL.CHARGE_DATE;
		v_FORMULA_CHARGE_VAR.VARIABLE_NAME := CASE v_VAR_NAME WHEN 'ND' THEN 'NDLF' ELSE v_VAR_NAME END;
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_CHG_DETAIL.ND_VAL;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

        v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'AnnualExchangeRate';
		v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_RATE;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

        v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'CPDP';
		v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_CHG_DETAIL.CPDP_VAL;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

		-- NDA
		v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'NDA';
		v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_CHG_DETAIL.NDA_VAL;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

		-- SNDLF
		v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'SNDLF';
		v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_CHG_DETAIL.SNDLF_VAL;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);


        v_CHG_AMOUNT := GET_EXTERNAL_CHARGE_AMOUNT(p_CHARGE_ID,
                                                    v_CHG_DETAIL.CHARGE_DATE,
                                                    v_CHG_DETAIL.RESOURCE_NAME);

        v_FORMULA_CHARGE.ITERATOR_ID := v_ITERATOR.ITERATOR_ID;
        v_FORMULA_CHARGE.CHARGE_DATE := v_CHG_DETAIL.CHARGE_DATE;
        v_FORMULA_CHARGE.CHARGE_QUANTITY := NVL(v_CHG_DETAIL.SNDLF_VAL, v_CHG_DETAIL.ND_VAL); --(SP BZ28159 changed from NDLF to SNDLF)
		v_FORMULA_CHARGE.CHARGE_RATE := v_CHG_DETAIL.CPDP_VAL * v_RATE;
        v_FORMULA_CHARGE.CHARGE_AMOUNT := v_CHG_AMOUNT;
        PC.PUT_FORMULA_CHARGE(v_FORMULA_CHARGE);
    END LOOP;

END EXTRACT_CCEX_CHARGE;
----------------------------------------------------------------------------------------
PROCEDURE EXTRACT_ENCEX_CHARGE
    (
    p_STATEMENT_ID IN NUMBER,
    p_CHARGE_ID IN NUMBER,
    p_ENTITY_ID IN NUMBER,
	p_CONVERSION_RATE IN CONVERSION_RATE_ARRAY,
    p_ERROR_UNIT IN BOOLEAN
    ) IS
CURSOR c_CHG_DETAIL(v_NAME IN VARCHAR2) IS
    SELECT S.CHARGE_DATE, S.RESOURCE_NAME,
            S.VALUE "NDLF_VAL", T.VALUE "SMP_VAL", U.VALUE "MD_VAL",
 		 	NDA.VALUE "NDA_VAL", SNDLF.VALUE "SNDLF_VAL"
    FROM SEM_MP_INFO S, SEM_MP_INFO T, SEM_MP_INFO U,  SEM_MP_INFO NDA,
		 SEM_MP_INFO SNDLF
    WHERE S.STATEMENT_ID = p_STATEMENT_ID
    AND S.VARIABLE_TYPE = v_NAME
    AND T.STATEMENT_ID(+) = p_STATEMENT_ID
    AND T.VARIABLE_TYPE(+) = 'SMP'
    AND T.CHARGE_DATE(+) = S.CHARGE_DATE
	AND U.STATEMENT_ID(+) = p_STATEMENT_ID
    AND U.VARIABLE_TYPE(+) = 'MD'
    AND U.CHARGE_DATE(+) = S.CHARGE_DATE
	AND U.RESOURCE_NAME(+) = S.RESOURCE_NAME
	AND NDA.STATEMENT_ID(+) = p_STATEMENT_ID
	AND NDA.VARIABLE_TYPE(+) = 'NDA'
	-- Added NDA and SNDLF
	AND NDA.CHARGE_DATE(+) = S.CHARGE_DATE
	AND NDA.RESOURCE_NAME(+) = S.RESOURCE_NAME
	AND SNDLF.STATEMENT_ID(+) = p_STATEMENT_ID
	AND SNDLF.VARIABLE_TYPE(+) = 'SNDLF'
	AND SNDLF.CHARGE_DATE(+) = S.CHARGE_DATE
	AND SNDLF.RESOURCE_NAME(+) = S.RESOURCE_NAME
    ORDER BY CHARGE_DATE, RESOURCE_NAME;
TYPE ITERATOR_ID_MAP IS TABLE OF NUMBER(2) INDEX BY VARCHAR2(32);
v_FORMULA_CHARGE FORMULA_CHARGE%ROWTYPE;
v_FORMULA_CHARGE_VAR FORMULA_CHARGE_VARIABLE%ROWTYPE;
v_ITERATOR_NAME FORMULA_CHARGE_ITERATOR_NAME%ROWTYPE;
v_ITERATOR FORMULA_CHARGE_ITERATOR%ROWTYPE;
v_ITERATOR_ID_MAP ITERATOR_ID_MAP;
v_ITERATOR_ID NUMBER(3) := 0;
v_VAR_NAME VARCHAR2(8);
v_CHG_AMOUNT SEM_DETAIL_CHARGE.CHARGE_AMOUNT%TYPE;
v_RATE NUMBER;
BEGIN
    UPDATE BILLING_STATEMENT
    SET CHARGE_VIEW_TYPE = 'FORMULA'
    WHERE CHARGE_ID = p_CHARGE_ID;

    v_ITERATOR_NAME.CHARGE_ID := p_CHARGE_ID;
    v_ITERATOR.CHARGE_ID := p_CHARGE_ID;
    v_FORMULA_CHARGE_VAR.CHARGE_ID := p_CHARGE_ID;
    v_FORMULA_CHARGE.CHARGE_ID := p_CHARGE_ID;

    v_ITERATOR_NAME.ITERATOR_NAME1 := g_ITER_NAME_SERVICE_POINT;

    PC.PUT_FORMULA_ITERATOR_NAMES(v_ITERATOR_NAME);

    IF p_ERROR_UNIT = FALSE THEN
		v_VAR_NAME := 'NDLF';
	ELSE
        v_VAR_NAME := 'NDLFESU';
 	END IF;


    FOR v_CHG_DETAIL IN C_CHG_DETAIL(v_VAR_NAME) LOOP
    	--Determine the exchange rate based on the hour of the day
		v_RATE := DETERMINE_CONVERSION_RATE_HOUR(v_CHG_DETAIL.CHARGE_DATE, p_CONVERSION_RATE);

        IF v_ITERATOR_ID_MAP.EXISTS(v_CHG_DETAIL.RESOURCE_NAME) THEN
            v_ITERATOR.ITERATOR_ID := v_ITERATOR_ID_MAP(v_CHG_DETAIL.RESOURCE_NAME);
        ELSE
            v_ITERATOR.ITERATOR_ID := v_ITERATOR_ID + 1;
            v_ITERATOR_ID_MAP(v_CHG_DETAIL.RESOURCE_NAME) := v_ITERATOR.ITERATOR_ID;
            v_ITERATOR_ID := v_ITERATOR_ID + 1;
        END IF;

        v_ITERATOR.ITERATOR1 := v_CHG_DETAIL.RESOURCE_NAME;
        PC.PUT_FORMULA_ITERATOR(v_ITERATOR);

        v_FORMULA_CHARGE_VAR.ITERATOR_ID := v_ITERATOR.ITERATOR_ID;
        v_FORMULA_CHARGE_VAR.CHARGE_DATE := v_CHG_DETAIL.CHARGE_DATE;

		-- NDLF
		v_FORMULA_CHARGE_VAR.VARIABLE_NAME := CASE v_VAR_NAME WHEN 'ND' THEN 'NDLF' ELSE v_VAR_NAME END;
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_CHG_DETAIL.NDLF_VAL;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

		-- SMP, exchanged to currency of user
		v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'SMP';
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_CHG_DETAIL.SMP_VAL * v_RATE;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

		--- MD
		v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'MD';
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_CHG_DETAIL.MD_VAL;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

		--- NDA
		v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'NDA';
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_CHG_DETAIL.NDA_VAL;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

		--- SNDLF
		v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'SNDLF';
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_CHG_DETAIL.SNDLF_VAL;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

        v_CHG_AMOUNT := GET_EXTERNAL_CHARGE_AMOUNT(p_CHARGE_ID,
                                                    v_CHG_DETAIL.CHARGE_DATE,
                                                    v_CHG_DETAIL.RESOURCE_NAME);

        v_FORMULA_CHARGE.ITERATOR_ID := v_ITERATOR.ITERATOR_ID;
        v_FORMULA_CHARGE.CHARGE_DATE := v_CHG_DETAIL.CHARGE_DATE;
        v_FORMULA_CHARGE.CHARGE_QUANTITY := NVL(v_CHG_DETAIL.SNDLF_VAL, v_CHG_DETAIL.NDLF_VAL); --(SP BZ28159 changed from NDLF to SNDLF)
        v_FORMULA_CHARGE.CHARGE_RATE := v_CHG_DETAIL.SMP_VAL * v_RATE;
        v_FORMULA_CHARGE.CHARGE_AMOUNT := v_CHG_AMOUNT;
        PC.PUT_FORMULA_CHARGE(v_FORMULA_CHARGE);
    END LOOP;

END EXTRACT_ENCEX_CHARGE;
----------------------------------------------------------------------------------------
PROCEDURE EXTRACT_ENPEX_CHARGE
    (
    p_STATEMENT_ID IN NUMBER,
    p_CHARGE_ID IN NUMBER,
    p_ENTITY_ID IN NUMBER,
	p_CONVERSION_RATE IN CONVERSION_RATE_ARRAY,
    p_INTERCONNECT IN BOOLEAN,
	p_GATE IN BOOLEAN
    ) IS

CURSOR c_CHG_DETAIL(v_NAME IN VARCHAR2, v_DQ_NAME IN VARCHAR2) IS
   
SELECT CHARGE_DATE, RESOURCE_NAME, CONTRACT, MAX(MSQ_VAL) MSQ_VAL, MAX(SMP_VAL) SMP_VAL, MAX(DQ_VAL) DQ_VAL FROM
(
    SELECT S.CHARGE_DATE, S.RESOURCE_NAME, S.CONTRACT,
            S.VALUE "MSQ_VAL", T.VALUE "SMP_VAL", NULL "DQ_VAL"
    FROM SEM_MP_INFO S, SEM_MP_INFO T
    WHERE S.STATEMENT_ID = p_STATEMENT_ID
    AND S.VARIABLE_TYPE = v_NAME
    AND T.STATEMENT_ID = p_STATEMENT_ID
    AND T.VARIABLE_TYPE = 'SMP'
    AND T.CHARGE_DATE = S.CHARGE_DATE
UNION ALL
    SELECT S.CHARGE_DATE, S.RESOURCE_NAME, S.CONTRACT,
            NULL "MSQ_VAL", T.VALUE "SMP_VAL", S.VALUE "DQ_VAL"
    FROM SEM_MP_INFO S, SEM_MP_INFO T
    WHERE S.STATEMENT_ID = p_STATEMENT_ID
    AND S.VARIABLE_TYPE = v_DQ_NAME
    AND T.STATEMENT_ID = p_STATEMENT_ID
    AND T.VARIABLE_TYPE = 'SMP'
    AND T.CHARGE_DATE = S.CHARGE_DATE
) GROUP BY CHARGE_DATE, RESOURCE_NAME, CONTRACT
    ORDER BY CHARGE_DATE, RESOURCE_NAME, CONTRACT;
	 
TYPE ITERATOR_ID_MAP IS TABLE OF NUMBER(2) INDEX BY VARCHAR2(100);
v_FORMULA_CHARGE FORMULA_CHARGE%ROWTYPE;
v_FORMULA_CHARGE_VAR FORMULA_CHARGE_VARIABLE%ROWTYPE;
v_ITERATOR_NAME FORMULA_CHARGE_ITERATOR_NAME%ROWTYPE;
v_ITERATOR FORMULA_CHARGE_ITERATOR%ROWTYPE;
v_ITERATOR_ID_MAP ITERATOR_ID_MAP;
v_ITERATOR_ID NUMBER(3) := 0;
v_TLAF SEM_LOSS_FACTOR.LOSS_FACTOR%TYPE;
v_CHG_AMOUNT SEM_DETAIL_CHARGE.CHARGE_AMOUNT%TYPE;
v_VAR_NAME SEM_MP_INFO.VARIABLE_TYPE%TYPE;
v_DQ_NAME SEM_MP_INFO.VARIABLE_TYPE%TYPE;
v_SERV_PT_NAME SERVICE_POINT.SERVICE_POINT_NAME%TYPE;
v_GATE_WINDOW  STATEMENT_TYPE.STATEMENT_TYPE_NAME%TYPE;
v_RATE NUMBER;
v_ITERATOR_KEY VARCHAR2(100);
BEGIN
    UPDATE BILLING_STATEMENT
    SET CHARGE_VIEW_TYPE = 'FORMULA'
    WHERE CHARGE_ID = p_CHARGE_ID;

	IF p_INTERCONNECT AND p_GATE THEN
        v_VAR_NAME := 'MSQIUG';
        v_DQ_NAME := 'DQIUG';
	ELSIF p_INTERCONNECT AND NOT p_GATE THEN
        v_VAR_NAME := 'MSQIU';
        v_DQ_NAME := 'DQIU';
    ELSIF NOT p_INTERCONNECT AND NOT p_GATE THEN
        v_VAR_NAME := 'MSQ';
        v_DQ_NAME := 'DQ';
    END IF;

    v_ITERATOR_NAME.CHARGE_ID := p_CHARGE_ID;
    v_ITERATOR.CHARGE_ID := p_CHARGE_ID;
    v_FORMULA_CHARGE_VAR.CHARGE_ID := p_CHARGE_ID;
    v_FORMULA_CHARGE.CHARGE_ID := p_CHARGE_ID;

    v_ITERATOR_NAME.ITERATOR_NAME1 := g_ITER_NAME_SERVICE_POINT;
    v_ITERATOR_NAME.ITERATOR_NAME2 := CASE p_GATE WHEN TRUE THEN g_ITER_NAME_AGREEMENT_TYPE ELSE NULL END;
    v_ITERATOR_NAME.ITERATOR_NAME3 := NULL;
    v_ITERATOR_NAME.ITERATOR_NAME4 := NULL;
    v_ITERATOR_NAME.ITERATOR_NAME5 := NULL;
    PC.PUT_FORMULA_ITERATOR_NAMES(v_ITERATOR_NAME);

    FOR v_CHG_DETAIL IN C_CHG_DETAIL(v_VAR_NAME, v_DQ_NAME) LOOP
        --Determine the exchange rate based on the hour of the day
        v_RATE := DETERMINE_CONVERSION_RATE_HOUR(v_CHG_DETAIL.CHARGE_DATE, p_CONVERSION_RATE);

        IF p_INTERCONNECT AND p_GATE THEN
          MM_SEM_UTIL.GET_GATE_INTERCONNECT(v_CHG_DETAIL.CONTRACT, v_GATE_WINDOW, v_SERV_PT_NAME);
        ELSIF p_INTERCONNECT AND NOT p_GATE THEN
          MM_SEM_UTIL.GET_GATE_INTERCONNECT(MM_SEM_UTIL.g_INTERCONNECT_I_NIMOYLE, v_GATE_WINDOW, v_SERV_PT_NAME);
          ELSIF NOT p_INTERCONNECT AND NOT p_GATE THEN
                v_SERV_PT_NAME := v_CHG_DETAIL.RESOURCE_NAME;
        END IF;

        v_ITERATOR_KEY := CASE WHEN p_GATE THEN v_CHG_DETAIL.CONTRACT ELSE v_SERV_PT_NAME END;
        IF v_ITERATOR_ID_MAP.EXISTS(v_ITERATOR_KEY) THEN
            v_ITERATOR.ITERATOR_ID := v_ITERATOR_ID_MAP(v_ITERATOR_KEY);
        ELSE
            v_ITERATOR.ITERATOR_ID := v_ITERATOR_ID + 1;
            v_ITERATOR_ID_MAP(v_ITERATOR_KEY) := v_ITERATOR.ITERATOR_ID;
            v_ITERATOR_ID := v_ITERATOR_ID + 1;
        END IF;
        v_ITERATOR.ITERATOR1 := v_SERV_PT_NAME;
    		v_ITERATOR.ITERATOR2 := CASE p_GATE WHEN TRUE THEN v_GATE_WINDOW ELSE NULL END;
    		v_ITERATOR.ITERATOR3 := NULL;
    		v_ITERATOR.ITERATOR4 := NULL;
    		v_ITERATOR.ITERATOR5 := NULL;
            PC.PUT_FORMULA_ITERATOR(v_ITERATOR);

            v_TLAF := MM_SEM_SHADOW_BILL.GET_TLAF(v_CHG_DETAIL.CHARGE_DATE,
                                                    v_SERV_PT_NAME, p_ENTITY_ID);

            v_FORMULA_CHARGE_VAR.ITERATOR_ID := v_ITERATOR.ITERATOR_ID;
            v_FORMULA_CHARGE_VAR.CHARGE_DATE := v_CHG_DETAIL.CHARGE_DATE;
            v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'MSQ';
            v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_CHG_DETAIL.MSQ_VAL;
            PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
            v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'DQ';
            v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_CHG_DETAIL.DQ_VAL;
            PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
            v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'SMP';
            v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_CHG_DETAIL.SMP_VAL * v_RATE;
            PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
            v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'TLAF';
            v_FORMULA_CHARGE_VAR.VARIABLE_VAL := NVL(v_TLAF,1);
            PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

            v_CHG_AMOUNT := GET_EXTERNAL_CHARGE_AMOUNT(p_CHARGE_ID,
                                                    v_CHG_DETAIL.CHARGE_DATE,
                                                    v_CHG_DETAIL.RESOURCE_NAME,
                                                    v_CHG_DETAIL.CONTRACT);

            v_FORMULA_CHARGE.ITERATOR_ID := v_ITERATOR.ITERATOR_ID;
            v_FORMULA_CHARGE.CHARGE_DATE := v_CHG_DETAIL.CHARGE_DATE;
            v_FORMULA_CHARGE.CHARGE_QUANTITY := v_CHG_DETAIL.MSQ_VAL * g_TPD * NVL(v_TLAF,1);
            v_FORMULA_CHARGE.CHARGE_RATE := v_CHG_DETAIL.SMP_VAL * v_RATE;
            v_FORMULA_CHARGE.CHARGE_AMOUNT := v_CHG_AMOUNT;
            PC.PUT_FORMULA_CHARGE(v_FORMULA_CHARGE);
    END LOOP;

END EXTRACT_ENPEX_CHARGE;
----------------------------------------------------------------------------------------
PROCEDURE EXTRACT_IMPCEX_CHARGE
    (
    p_STATEMENT_ID IN NUMBER,
    p_CHARGE_ID IN NUMBER,
    p_ENTITY_ID IN NUMBER,
	p_CONVERSION_RATE IN CONVERSION_RATE_ARRAY,
    p_ERROR_UNIT IN BOOLEAN
    ) IS
CURSOR c_CHG_DETAIL(v_NAME IN VARCHAR2) IS
    SELECT S.CHARGE_DATE, S.RESOURCE_NAME, S.VALUE "NDLF_VAL",
		   NDA.VALUE "NDA_VAL", SNDLF.VALUE "SNDLF_VAL"
    FROM SEM_MP_INFO S, SEM_MP_INFO NDA, SEM_MP_INFO SNDLF
    WHERE S.STATEMENT_ID = p_STATEMENT_ID
    AND S.VARIABLE_TYPE = v_NAME
	AND NDA.STATEMENT_ID(+) = p_STATEMENT_ID
    AND NDA.VARIABLE_TYPE(+) = 'NDA'
    AND NDA.CHARGE_DATE(+) = S.CHARGE_DATE
    AND SNDLF.STATEMENT_ID(+) = p_STATEMENT_ID
    AND SNDLF.VARIABLE_TYPE(+) = 'SNDLF'
    AND SNDLF.CHARGE_DATE(+) = S.CHARGE_DATE
    ORDER BY CHARGE_DATE, RESOURCE_NAME;
TYPE ITERATOR_ID_MAP IS TABLE OF NUMBER(2) INDEX BY VARCHAR2(32);
v_FORMULA_CHARGE FORMULA_CHARGE%ROWTYPE;
v_FORMULA_CHARGE_VAR FORMULA_CHARGE_VARIABLE%ROWTYPE;
v_ITERATOR_NAME FORMULA_CHARGE_ITERATOR_NAME%ROWTYPE;
v_ITERATOR FORMULA_CHARGE_ITERATOR%ROWTYPE;
v_ITERATOR_ID_MAP ITERATOR_ID_MAP;
v_ITERATOR_ID NUMBER(3) := 0;
v_IMP_VAL MARKET_PRICE_VALUE.PRICE%TYPE;
v_VAR_NAME VARCHAR2(8);
v_MKT_PRICE MARKET_PRICE.MARKET_PRICE_ID%TYPE;
v_CHG_AMOUNT SEM_DETAIL_CHARGE.CHARGE_AMOUNT%TYPE;
v_RATE NUMBER;
BEGIN
    UPDATE BILLING_STATEMENT
    SET CHARGE_VIEW_TYPE = 'FORMULA'
    WHERE CHARGE_ID = p_CHARGE_ID;

    v_ITERATOR_NAME.CHARGE_ID := p_CHARGE_ID;
    v_ITERATOR.CHARGE_ID := p_CHARGE_ID;
    v_FORMULA_CHARGE_VAR.CHARGE_ID := p_CHARGE_ID;
    v_FORMULA_CHARGE.CHARGE_ID := p_CHARGE_ID;

	v_ITERATOR_NAME.ITERATOR_NAME1 := g_ITER_NAME_SERVICE_POINT;

   PC.PUT_FORMULA_ITERATOR_NAMES(v_ITERATOR_NAME);

    IF p_ERROR_UNIT = FALSE THEN
		v_VAR_NAME := 'NDLF';
	ELSE
        v_VAR_NAME := 'NDLFESU';
 	END IF;

    v_MKT_PRICE := MM_SEM_UTIL.GET_MARKET_PRICE_ID('Annual Imperfection Price',
                                                        NULL, NULL, FALSE);

    FOR v_CHG_DETAIL IN C_CHG_DETAIL(v_VAR_NAME) LOOP
		--Determine the exchange rate based on the hour of the day
		v_RATE := DETERMINE_CONVERSION_RATE_HOUR(v_CHG_DETAIL.CHARGE_DATE, p_CONVERSION_RATE);

        IF v_MKT_PRICE IS NOT NULL THEN
            BEGIN
                SELECT PRICE INTO v_IMP_VAL
                FROM MARKET_PRICE_VALUE
                WHERE MARKET_PRICE_ID = v_MKT_PRICE
                AND PRICE_DATE = TRUNC(v_CHG_DETAIL.CHARGE_DATE, 'MM')
                AND PRICE_CODE = 'A';
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    v_IMP_VAL := 0;
            END;
        ELSE
            v_IMP_VAL := 0;
        END IF;

        IF v_ITERATOR_ID_MAP.EXISTS(v_CHG_DETAIL.RESOURCE_NAME) THEN
            v_ITERATOR.ITERATOR_ID := v_ITERATOR_ID_MAP(v_CHG_DETAIL.RESOURCE_NAME);
        ELSE
            v_ITERATOR.ITERATOR_ID := v_ITERATOR_ID + 1;
            v_ITERATOR_ID_MAP(v_CHG_DETAIL.RESOURCE_NAME) := v_ITERATOR.ITERATOR_ID;
            v_ITERATOR_ID := v_ITERATOR_ID + 1;
        END IF;

        v_ITERATOR.ITERATOR1 := v_CHG_DETAIL.RESOURCE_NAME;
        PC.PUT_FORMULA_ITERATOR(v_ITERATOR);

        v_FORMULA_CHARGE_VAR.ITERATOR_ID := v_ITERATOR.ITERATOR_ID;
        v_FORMULA_CHARGE_VAR.CHARGE_DATE := v_CHG_DETAIL.CHARGE_DATE;

		-- NDLF
		v_FORMULA_CHARGE_VAR.VARIABLE_NAME := CASE v_VAR_NAME WHEN 'ND' THEN 'NDLF' ELSE v_VAR_NAME END;
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_CHG_DETAIL.NDLF_VAL;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

		-- IMPF
        v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'IMPF';
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := 1;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

		-- IMP
        v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'IMP';
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_IMP_VAL * v_RATE;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

		-- NDA
        v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'NDA';
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_CHG_DETAIL.NDA_VAL;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

		-- SNDLF
        v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'SNDLF';
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_CHG_DETAIL.SNDLF_VAL;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

        v_CHG_AMOUNT := GET_EXTERNAL_CHARGE_AMOUNT(p_CHARGE_ID,
                                                    v_CHG_DETAIL.CHARGE_DATE,
                                                    v_CHG_DETAIL.RESOURCE_NAME);

        v_FORMULA_CHARGE.ITERATOR_ID := v_ITERATOR.ITERATOR_ID;
        v_FORMULA_CHARGE.CHARGE_DATE := v_CHG_DETAIL.CHARGE_DATE;
        v_FORMULA_CHARGE.CHARGE_QUANTITY := NVL(v_CHG_DETAIL.SNDLF_VAL, v_CHG_DETAIL.NDLF_VAL) * 1; --IMPF; --(SP BZ28159 changed from NDLF to SNDLF)
        v_FORMULA_CHARGE.CHARGE_RATE := v_IMP_VAL * v_RATE;
        v_FORMULA_CHARGE.CHARGE_AMOUNT := v_CHG_AMOUNT;
        PC.PUT_FORMULA_CHARGE(v_FORMULA_CHARGE);
    END LOOP;

END EXTRACT_IMPCEX_CHARGE;
----------------------------------------------------------------------------------------
PROCEDURE EXTRACT_VMOC_EX_CHARGE
    (
    p_STATEMENT_ID IN NUMBER,
    p_CHARGE_ID IN NUMBER,
    p_ENTITY_ID IN NUMBER,
	p_CONVERSION_RATE IN CONVERSION_RATE_ARRAY,
    p_ERROR_UNIT IN BOOLEAN
    ) IS
CURSOR c_CHG_DETAIL(v_NAME IN VARCHAR2) IS
    SELECT S.CHARGE_DATE, S.RESOURCE_NAME,
           S.VALUE "NDLF_VAL", T.VALUE "VMOP", NDA.VALUE "NDA_VAL",
		   SNDLF.VALUE "SNDLF_VAL"
    FROM SEM_MP_INFO S, SEM_MP_INFO T, SEM_MP_INFO NDA, SEM_MP_INFO SNDLF
    WHERE S.STATEMENT_ID = p_STATEMENT_ID
    AND S.VARIABLE_TYPE = v_NAME
    AND T.STATEMENT_ID(+) = S.STATEMENT_ID
    AND T.VARIABLE_TYPE(+) = 'VMOP'
    AND NDA.STATEMENT_ID(+) = S.STATEMENT_ID
    AND NDA.VARIABLE_TYPE(+) = 'NDA'
	AND NDA.CHARGE_DATE(+) = S.CHARGE_DATE
	AND NDA.RESOURCE_NAME(+) = S.RESOURCE_NAME
    AND SNDLF.STATEMENT_ID(+) = S.STATEMENT_ID
    AND SNDLF.VARIABLE_TYPE(+) = 'SNDLF'
	AND SNDLF.CHARGE_DATE(+) = S.CHARGE_DATE
	AND SNDLF.RESOURCE_NAME(+) = S.RESOURCE_NAME
    ORDER BY CHARGE_DATE, RESOURCE_NAME;
TYPE ITERATOR_ID_MAP IS TABLE OF NUMBER(2) INDEX BY VARCHAR2(32);
v_FORMULA_CHARGE FORMULA_CHARGE%ROWTYPE;
v_FORMULA_CHARGE_VAR FORMULA_CHARGE_VARIABLE%ROWTYPE;
v_ITERATOR_NAME FORMULA_CHARGE_ITERATOR_NAME%ROWTYPE;
v_ITERATOR FORMULA_CHARGE_ITERATOR%ROWTYPE;
v_ITERATOR_ID_MAP ITERATOR_ID_MAP;
v_ITERATOR_ID NUMBER(3) := 0;
v_VAR_NAME VARCHAR2(8);
v_MKT_PRICE_ID MARKET_PRICE.MARKET_PRICE_ID%TYPE;
v_CHG_AMOUNT SEM_DETAIL_CHARGE.CHARGE_AMOUNT%TYPE;
v_RATE NUMBER;
BEGIN
    UPDATE BILLING_STATEMENT
    SET CHARGE_VIEW_TYPE = 'FORMULA'
    WHERE CHARGE_ID = p_CHARGE_ID;

    v_ITERATOR_NAME.CHARGE_ID := p_CHARGE_ID;
    v_ITERATOR.CHARGE_ID := p_CHARGE_ID;
    v_FORMULA_CHARGE_VAR.CHARGE_ID := p_CHARGE_ID;
    v_FORMULA_CHARGE.CHARGE_ID := p_CHARGE_ID;

    v_ITERATOR_NAME.ITERATOR_NAME1 := g_ITER_NAME_SERVICE_POINT;
    PC.PUT_FORMULA_ITERATOR_NAMES(v_ITERATOR_NAME);

    IF p_ERROR_UNIT = FALSE THEN
		v_VAR_NAME := 'NDLF';
	ELSE
        v_VAR_NAME := 'NDLFESU';
 	END IF;

    v_MKT_PRICE_ID := MM_SEM_UTIL.GET_MARKET_PRICE_ID('Annual Variable Market Operator Price',
                                                        'Market Result', 'Month', TRUE);

    FOR v_CHG_DETAIL IN C_CHG_DETAIL(v_VAR_NAME) LOOP
	    --Determine the exchange rate based on the hour of the day
		v_RATE := DETERMINE_CONVERSION_RATE_HOUR(v_CHG_DETAIL.CHARGE_DATE, p_CONVERSION_RATE);
        IF v_ITERATOR_ID_MAP.EXISTS(v_CHG_DETAIL.RESOURCE_NAME) THEN
            v_ITERATOR.ITERATOR_ID := v_ITERATOR_ID_MAP(v_CHG_DETAIL.RESOURCE_NAME);
        ELSE
            v_ITERATOR.ITERATOR_ID := v_ITERATOR_ID + 1;
            v_ITERATOR_ID_MAP(v_CHG_DETAIL.RESOURCE_NAME) := v_ITERATOR.ITERATOR_ID;
            v_ITERATOR_ID := v_ITERATOR_ID + 1;
        END IF;

	    v_ITERATOR.ITERATOR1 := v_CHG_DETAIL.RESOURCE_NAME;
        PC.PUT_FORMULA_ITERATOR(v_ITERATOR);

        v_FORMULA_CHARGE_VAR.ITERATOR_ID := v_ITERATOR.ITERATOR_ID;
        v_FORMULA_CHARGE_VAR.CHARGE_DATE := v_CHG_DETAIL.CHARGE_DATE;
		v_FORMULA_CHARGE_VAR.VARIABLE_NAME := CASE v_VAR_NAME WHEN 'ND' THEN 'NDLF' ELSE v_VAR_NAME END;
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_CHG_DETAIL.NDLF_VAL;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

        v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'VMOP';
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := NVL(v_CHG_DETAIL.VMOP,0) * v_RATE;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

        v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'NDA';
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_CHG_DETAIL.NDA_VAL;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

        v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'SNDLF';
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_CHG_DETAIL.SNDLF_VAL;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

        v_CHG_AMOUNT := GET_EXTERNAL_CHARGE_AMOUNT(p_CHARGE_ID,
                                                    v_CHG_DETAIL.CHARGE_DATE,
                                                    v_CHG_DETAIL.RESOURCE_NAME);

        v_FORMULA_CHARGE.ITERATOR_ID := v_ITERATOR.ITERATOR_ID;
        v_FORMULA_CHARGE.CHARGE_DATE := v_CHG_DETAIL.CHARGE_DATE;
        v_FORMULA_CHARGE.CHARGE_QUANTITY := NVL(v_CHG_DETAIL.SNDLF_VAL, v_CHG_DETAIL.NDLF_VAL);  --(SP BZ28159 changed from NDLF to SNDLF)
        v_FORMULA_CHARGE.CHARGE_RATE := v_CHG_DETAIL.VMOP * v_RATE;
        v_FORMULA_CHARGE.CHARGE_AMOUNT := v_CHG_AMOUNT;
        PC.PUT_FORMULA_CHARGE(v_FORMULA_CHARGE);
    END LOOP;

END EXTRACT_VMOC_EX_CHARGE;
----------------------------------------------------------------------------------------
PROCEDURE EXTRACT_FMOC_EX_CHARGE
    (
    p_CHARGE_ID IN NUMBER,
    p_INTERCONNECT IN BOOLEAN,
	p_GATE IN BOOLEAN
    ) IS
CURSOR c_CHG_DETAIL IS
    SELECT S.CHARGE_DATE,
           S.RESOURCE_NAME,
		   S.CONTRACT,
           NVL(SUM(S.CHARGE_AMOUNT),0) AS CHARGE_AMOUNT
      FROM SEM_DETAIL_CHARGE S
     WHERE S.CHARGE_ID = p_CHARGE_ID
     GROUP BY S.CHARGE_DATE,
              S.RESOURCE_NAME,
			  S.CONTRACT
     ORDER BY S.CHARGE_DATE, S.CONTRACT;

TYPE ITERATOR_ID_MAP IS TABLE OF NUMBER(2) INDEX BY VARCHAR2(100);
v_FORMULA_CHARGE FORMULA_CHARGE%ROWTYPE;
v_ITERATOR_NAME FORMULA_CHARGE_ITERATOR_NAME%ROWTYPE;
v_ITERATOR FORMULA_CHARGE_ITERATOR%ROWTYPE;
v_ITERATOR_ID_MAP ITERATOR_ID_MAP;
v_ITERATOR_ID NUMBER(3) := 0;
v_SERV_PT_NAME SERVICE_POINT.SERVICE_POINT_NAME%TYPE;
v_GATE_WINDOW  STATEMENT_TYPE.STATEMENT_TYPE_NAME%TYPE;
v_ITERATOR_KEY VARCHAR2(100);
BEGIN
    UPDATE BILLING_STATEMENT
    SET CHARGE_VIEW_TYPE = 'FORMULA'
    WHERE CHARGE_ID = p_CHARGE_ID;

    v_ITERATOR_NAME.CHARGE_ID := p_CHARGE_ID;
    v_ITERATOR.CHARGE_ID := p_CHARGE_ID;
    v_FORMULA_CHARGE.CHARGE_ID := p_CHARGE_ID;

    v_ITERATOR_NAME.ITERATOR_NAME1 := g_ITER_NAME_SERVICE_POINT;
    v_ITERATOR_NAME.ITERATOR_NAME2 := CASE p_GATE WHEN TRUE THEN g_ITER_NAME_AGREEMENT_TYPE ELSE NULL END;
    v_ITERATOR_NAME.ITERATOR_NAME3 := NULL;
    v_ITERATOR_NAME.ITERATOR_NAME4 := NULL;
    v_ITERATOR_NAME.ITERATOR_NAME5 := NULL;
    PC.PUT_FORMULA_ITERATOR_NAMES(v_ITERATOR_NAME);

    FOR v_CHG_DETAIL IN C_CHG_DETAIL LOOP
        IF p_INTERCONNECT AND p_GATE THEN
          MM_SEM_UTIL.GET_GATE_INTERCONNECT(v_CHG_DETAIL.CONTRACT, v_GATE_WINDOW, v_SERV_PT_NAME);
        ELSIF p_INTERCONNECT AND NOT p_GATE THEN
          MM_SEM_UTIL.GET_GATE_INTERCONNECT(MM_SEM_UTIL.g_INTERCONNECT_I_NIMOYLE, v_GATE_WINDOW, v_SERV_PT_NAME);
        ELSIF NOT p_INTERCONNECT AND NOT p_GATE THEN
          v_SERV_PT_NAME := v_CHG_DETAIL.RESOURCE_NAME;
        END IF;

        v_ITERATOR_KEY := CASE WHEN p_GATE THEN v_CHG_DETAIL.CONTRACT ELSE v_SERV_PT_NAME END;
        IF v_ITERATOR_ID_MAP.EXISTS(v_ITERATOR_KEY) THEN
            v_ITERATOR.ITERATOR_ID := v_ITERATOR_ID_MAP(v_ITERATOR_KEY);
        ELSE
            v_ITERATOR.ITERATOR_ID := v_ITERATOR_ID + 1;
            v_ITERATOR_ID_MAP(v_ITERATOR_KEY) := v_ITERATOR.ITERATOR_ID;
            v_ITERATOR_ID := v_ITERATOR_ID + 1;
        END IF;
        v_ITERATOR.ITERATOR1 := v_SERV_PT_NAME;
    		v_ITERATOR.ITERATOR2 := CASE p_GATE WHEN TRUE THEN v_GATE_WINDOW ELSE NULL END;
    		v_ITERATOR.ITERATOR3 := NULL;
    		v_ITERATOR.ITERATOR4 := NULL;
    		v_ITERATOR.ITERATOR5 := NULL;
            PC.PUT_FORMULA_ITERATOR(v_ITERATOR);

            v_FORMULA_CHARGE.ITERATOR_ID := v_ITERATOR.ITERATOR_ID;
            v_FORMULA_CHARGE.CHARGE_DATE := v_CHG_DETAIL.CHARGE_DATE;
            v_FORMULA_CHARGE.CHARGE_QUANTITY := v_CHG_DETAIL.CHARGE_AMOUNT;
            v_FORMULA_CHARGE.CHARGE_RATE := 1;
            v_FORMULA_CHARGE.CHARGE_AMOUNT := v_CHG_DETAIL.CHARGE_AMOUNT;
            PC.PUT_FORMULA_CHARGE(v_FORMULA_CHARGE);
    END LOOP;

END EXTRACT_FMOC_EX_CHARGE;
----------------------------------------------------------------------------------------
PROCEDURE EXTRACT_CPEX_CHARGE
    (
    p_STATEMENT_ID IN NUMBER,
    p_CHARGE_ID IN NUMBER,
    p_ENTITY_ID IN NUMBER,
    p_INTERCONNECT IN BOOLEAN,
	p_GATE IN BOOLEAN
    ) IS
v_STR_MSQ_OR_MSQIU SEM_MP_INFO.VARIABLE_TYPE%TYPE;
CURSOR c_CHG_DETAIL(v_NAME IN VARCHAR2) IS
    -- F26.U5 - Change - Added MSQ for import of external PIR statements
    SELECT S.CHARGE_DATE, S.RESOURCE_NAME,
            S.VALUE "EA_VAL", S.CONTRACT, T.VALUE "SMP_VAL",
            U.VALUE "CPGP_VAL", V.VALUE "VCGP_VAL",
            W.VALUE "FCGP_VAL", X.VALUE "ECGP_VAL",
            MSQ.VALUE "MSQ_VAL"
    FROM SEM_MP_INFO S, SEM_MP_INFO T,
            SEM_MP_INFO U, SEM_MP_INFO V,
            SEM_MP_INFO W, SEM_MP_INFO X,
            SEM_MP_INFO MSQ
    WHERE S.STATEMENT_ID(+) = p_STATEMENT_ID
    AND S.VARIABLE_TYPE(+) = v_NAME
    AND T.STATEMENT_ID(+) = p_STATEMENT_ID
    AND T.VARIABLE_TYPE(+) = 'SMP'
    AND T.CHARGE_DATE(+) = S.CHARGE_DATE
    AND U.STATEMENT_ID = p_STATEMENT_ID
    AND U.VARIABLE_TYPE = 'CPGP'
    AND U.CHARGE_DATE = S.CHARGE_DATE
    AND V.STATEMENT_ID = p_STATEMENT_ID
    AND V.VARIABLE_TYPE = 'VCPGP'
    AND V.CHARGE_DATE = S.CHARGE_DATE
    AND W.STATEMENT_ID = p_STATEMENT_ID
    AND W.VARIABLE_TYPE = 'FCGP'
    AND W.CHARGE_DATE = S.CHARGE_DATE
    AND X.STATEMENT_ID = p_STATEMENT_ID
    AND X.VARIABLE_TYPE = 'ECGP'
    AND X.CHARGE_DATE = S.CHARGE_DATE
    -- F26.U5 - Some PIRs may not have MSQ values in them. So, outer-join.
    AND MSQ.STATEMENT_ID(+) = p_STATEMENT_ID
    AND MSQ.VARIABLE_TYPE(+) = v_STR_MSQ_OR_MSQIU
    AND MSQ.CHARGE_DATE(+) = S.CHARGE_DATE
    AND MSQ.RESOURCE_NAME(+) = S.RESOURCE_NAME
	AND NVL(MSQ.CONTRACT(+), CONSTANTS.UNDEFINED_ATTRIBUTE) = NVL(S.CONTRACT, CONSTANTS.UNDEFINED_ATTRIBUTE)
    ORDER BY CHARGE_DATE, RESOURCE_NAME, CONTRACT;
TYPE ITERATOR_ID_MAP IS TABLE OF NUMBER(2) INDEX BY VARCHAR2(100);
v_FORMULA_CHARGE FORMULA_CHARGE%ROWTYPE;
v_FORMULA_CHARGE_VAR FORMULA_CHARGE_VARIABLE%ROWTYPE;
v_ITERATOR_NAME FORMULA_CHARGE_ITERATOR_NAME%ROWTYPE;
v_ITERATOR FORMULA_CHARGE_ITERATOR%ROWTYPE;
v_ITERATOR_ID_MAP ITERATOR_ID_MAP;
v_ITERATOR_ID NUMBER(3) := 0;
v_TLAF SEM_LOSS_FACTOR.LOSS_FACTOR%TYPE;
v_CPEAL NUMBER;
v_CHG_AMOUNT SEM_DETAIL_CHARGE.CHARGE_AMOUNT%TYPE;
v_VAR_NAME SEM_MP_INFO.VARIABLE_TYPE%TYPE;
v_SERV_PT_NAME SERVICE_POINT.SERVICE_POINT_NAME%TYPE;
v_GATE_WINDOW  STATEMENT_TYPE.STATEMENT_TYPE_NAME%TYPE;
v_EXCH_RATE_ID MARKET_PRICE.MARKET_PRICE_ID%TYPE;
v_RATE NUMBER;
v_ITERATOR_KEY VARCHAR2(100);
BEGIN

    UPDATE BILLING_STATEMENT
    SET CHARGE_VIEW_TYPE = 'FORMULA'
    WHERE CHARGE_ID = p_CHARGE_ID;

    v_ITERATOR_NAME.CHARGE_ID := p_CHARGE_ID;
    v_ITERATOR.CHARGE_ID := p_CHARGE_ID;
    v_FORMULA_CHARGE_VAR.CHARGE_ID := p_CHARGE_ID;
    v_FORMULA_CHARGE.CHARGE_ID := p_CHARGE_ID;

    v_ITERATOR_NAME.ITERATOR_NAME1 := g_ITER_NAME_SERVICE_POINT;
    v_ITERATOR_NAME.ITERATOR_NAME2 := CASE p_GATE WHEN TRUE THEN g_ITER_NAME_AGREEMENT_TYPE ELSE NULL END;

    PC.PUT_FORMULA_ITERATOR_NAMES(v_ITERATOR_NAME);

    IF p_INTERCONNECT AND p_GATE THEN
        v_VAR_NAME := 'EAIUG';
		v_STR_MSQ_OR_MSQIU := 'MSQIUG';
	ELSIF p_INTERCONNECT AND NOT p_GATE THEN
        v_VAR_NAME := 'EAIU';
		v_STR_MSQ_OR_MSQIU := 'MSQIU';
	ELSIF NOT p_INTERCONNECT AND NOT p_GATE THEN
        v_VAR_NAME := 'EA';
		v_STR_MSQ_OR_MSQIU := 'MSQ';
    END IF;


    FOR v_CHG_DETAIL IN C_CHG_DETAIL(v_VAR_NAME) LOOP
		--Get the Annual Capacity Exchange Rate
         IF MM_SEM_SHADOW_BILL.GET_JURISDICTION(p_ENTITY_ID, v_CHG_DETAIL.CHARGE_DATE) = MM_SEM_UTIL.c_SEM_JURIDICTION_ROI THEN 
           v_RATE := 1;
        ELSE 
          v_EXCH_RATE_ID := MM_SEM_UTIL.GET_MARKET_PRICE_ID('Annual Capacity Exchange Rate: Euro to Pound',
                                                        NULL, NULL, FALSE);
          IF v_EXCH_RATE_ID IS NOT NULL THEN
             BEGIN
                SELECT PRICE INTO v_RATE
                FROM MARKET_PRICE_VALUE
                WHERE MARKET_PRICE_ID = v_EXCH_RATE_ID
                AND PRICE_DATE = TRUNC(v_CHG_DETAIL.CHARGE_DATE, 'MM')
                AND PRICE_CODE = 'A';
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    v_RATE := 0;
            END;
          ELSE
            v_RATE := 0;
          END IF;
        END IF;  

        IF p_INTERCONNECT AND p_GATE THEN
          MM_SEM_UTIL.GET_GATE_INTERCONNECT(v_CHG_DETAIL.CONTRACT, v_GATE_WINDOW, v_SERV_PT_NAME);
        ELSIF p_INTERCONNECT AND NOT p_GATE THEN
          MM_SEM_UTIL.GET_GATE_INTERCONNECT(MM_SEM_UTIL.g_INTERCONNECT_I_NIMOYLE, v_GATE_WINDOW, v_SERV_PT_NAME);
        ELSIF NOT p_INTERCONNECT AND NOT p_GATE THEN
                v_SERV_PT_NAME := v_CHG_DETAIL.RESOURCE_NAME;
        END IF;
        v_ITERATOR_KEY := CASE WHEN p_GATE THEN v_CHG_DETAIL.CONTRACT ELSE v_SERV_PT_NAME END;
        IF v_ITERATOR_ID_MAP.EXISTS(v_ITERATOR_KEY) THEN
            v_ITERATOR.ITERATOR_ID := v_ITERATOR_ID_MAP(v_ITERATOR_KEY);
        ELSE
            v_ITERATOR.ITERATOR_ID := v_ITERATOR_ID + 1;
            v_ITERATOR_ID_MAP(v_ITERATOR_KEY) := v_ITERATOR.ITERATOR_ID;
            v_ITERATOR_ID := v_ITERATOR_ID + 1;
        END IF;
        v_ITERATOR.ITERATOR1 := v_SERV_PT_NAME;
    		v_ITERATOR.ITERATOR2 := CASE p_GATE WHEN TRUE THEN v_GATE_WINDOW ELSE NULL END;
    		v_ITERATOR.ITERATOR3 := NULL;
    		v_ITERATOR.ITERATOR4 := NULL;
    		v_ITERATOR.ITERATOR5 := NULL;
            PC.PUT_FORMULA_ITERATOR(v_ITERATOR);

            v_CHG_AMOUNT := GET_EXTERNAL_CHARGE_AMOUNT(p_CHARGE_ID,
                                                    v_CHG_DETAIL.CHARGE_DATE,
                                                    v_CHG_DETAIL.RESOURCE_NAME,
                                                    v_CHG_DETAIL.CONTRACT);

            v_TLAF := MM_SEM_SHADOW_BILL.GET_TLAF(v_CHG_DETAIL.CHARGE_DATE,
                                                        v_SERV_PT_NAME, p_ENTITY_ID);

            v_CPEAL := 0.5 * v_CHG_DETAIL.EA_VAL * v_TLAF;

            v_FORMULA_CHARGE_VAR.ITERATOR_ID := v_ITERATOR.ITERATOR_ID;
            v_FORMULA_CHARGE_VAR.CHARGE_DATE := v_CHG_DETAIL.CHARGE_DATE;
            v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'AnnualExchangeRate';
            v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_RATE;
            PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
            v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'SMP';
            v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_CHG_DETAIL.SMP_VAL * v_RATE;
            PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
            v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'VOLL';
            --External source for VOLL unavailable - so set to NULL. If it were available,
            --we could solve for CPPF and CPGPF here
            v_FORMULA_CHARGE_VAR.VARIABLE_VAL := NULL;
            PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
            v_FORMULA_CHARGE_VAR.VARIABLE_NAME := v_VAR_NAME;
            v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_CHG_DETAIL.EA_VAL;
            PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
            v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'TLAF';
            v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_TLAF;
            PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
            v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'CPEAL';
            v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_CPEAL;
            PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
            v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'CPGPrice';
            v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_CHG_DETAIL.CPGP_VAL;
            PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
            v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'CPGP';
            v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_CHG_DETAIL.CPGP_VAL * v_RATE;
            PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
            v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'VCGP';
            v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_CHG_DETAIL.VCGP_VAL * v_RATE;
            PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
            v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'FCGP';
            v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_CHG_DETAIL.FCGP_VAL * v_RATE;
            PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
            v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'ECGP';
            v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_CHG_DETAIL.ECGP_VAL * v_RATE;
            PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
            v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'CPGPF';
            --External source for CPGPF unavailable - so set to NULL.
            v_FORMULA_CHARGE_VAR.VARIABLE_VAL := NULL;
            PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

            --External source for MSQ may be unavailable - so set to NULL.
            v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'MSQ';
            v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_CHG_DETAIL.MSQ_VAL;
            PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

            v_FORMULA_CHARGE.ITERATOR_ID := v_ITERATOR.ITERATOR_ID;
            v_FORMULA_CHARGE.CHARGE_DATE := v_CHG_DETAIL.CHARGE_DATE;
            v_FORMULA_CHARGE.CHARGE_QUANTITY := v_CHG_AMOUNT;
            v_FORMULA_CHARGE.CHARGE_RATE := 1;
            v_FORMULA_CHARGE.CHARGE_AMOUNT := v_CHG_AMOUNT;
            PC.PUT_FORMULA_CHARGE(v_FORMULA_CHARGE);
    END LOOP;

END EXTRACT_CPEX_CHARGE;
---------------------------------------------------------------------------------------
PROCEDURE EXTRACT_CONPEX_CHARGE
    (
    p_STATEMENT_ID IN NUMBER,
    p_CHARGE_ID IN NUMBER,
    p_ENTITY_ID IN NUMBER,
    p_INTERCONNECT IN BOOLEAN,
	p_GATE IN BOOLEAN
    ) IS

CURSOR c_CHG_DETAIL(v_NAME1 IN VARCHAR2, v_NAME2 IN VARCHAR2) IS
    SELECT S.CHARGE_DATE, S.RESOURCE_NAME, S.CONTRACT,
            S.VALUE "MSQ_VAL", T.VALUE "DQ_VAL"
    FROM SEM_MP_INFO S, SEM_MP_INFO T
    WHERE S.STATEMENT_ID = p_STATEMENT_ID
    AND S.VARIABLE_TYPE = v_NAME1
    AND T.STATEMENT_ID = p_STATEMENT_ID
    AND T.VARIABLE_TYPE = v_NAME2
    AND T.CHARGE_DATE = S.CHARGE_DATE
    AND NVL(T.RESOURCE_NAME, CONSTANTS.UNDEFINED_ATTRIBUTE) = NVL(S.RESOURCE_NAME, CONSTANTS.UNDEFINED_ATTRIBUTE)
    AND NVL(T.CONTRACT, CONSTANTS.UNDEFINED_ATTRIBUTE) = NVL(S.CONTRACT, CONSTANTS.UNDEFINED_ATTRIBUTE)
    ORDER BY CHARGE_DATE, RESOURCE_NAME, CONTRACT;
TYPE ITERATOR_ID_MAP IS TABLE OF NUMBER(2) INDEX BY VARCHAR2(100);
v_FORMULA_CHARGE FORMULA_CHARGE%ROWTYPE;
v_FORMULA_CHARGE_VAR FORMULA_CHARGE_VARIABLE%ROWTYPE;
v_ITERATOR_NAME FORMULA_CHARGE_ITERATOR_NAME%ROWTYPE;
v_ITERATOR FORMULA_CHARGE_ITERATOR%ROWTYPE;
v_ITERATOR_ID_MAP ITERATOR_ID_MAP;
v_ITERATOR_ID NUMBER(3) := 0;
v_TLAF SEM_LOSS_FACTOR.LOSS_FACTOR%TYPE;
v_CHG_AMOUNT SEM_DETAIL_CHARGE.CHARGE_AMOUNT%TYPE;
v_VAR_NAME1 SEM_MP_INFO.VARIABLE_TYPE%TYPE;
v_VAR_NAME2 SEM_MP_INFO.VARIABLE_TYPE%TYPE;
v_SERV_PT_NAME SERVICE_POINT.SERVICE_POINT_NAME%TYPE;
v_GATE_WINDOW  STATEMENT_TYPE.STATEMENT_TYPE_NAME%TYPE;
v_ITERATOR_KEY VARCHAR2(100);
BEGIN
    UPDATE BILLING_STATEMENT
    SET CHARGE_VIEW_TYPE = 'FORMULA'
    WHERE CHARGE_ID = p_CHARGE_ID;

	IF p_INTERCONNECT AND p_GATE THEN
        v_VAR_NAME1 := 'MSQIUG';
        v_VAR_NAME2 := 'DQIUG';
	ELSIF p_INTERCONNECT AND NOT p_GATE THEN
        v_VAR_NAME1 := 'MSQIU';
        v_VAR_NAME2 := 'DQIU';
    ELSIF NOT p_INTERCONNECT AND NOT p_GATE THEN
        v_VAR_NAME1 := 'MSQ';
        v_VAR_NAME2 := 'DQ';
    END IF;

    v_ITERATOR_NAME.CHARGE_ID := p_CHARGE_ID;
    v_ITERATOR.CHARGE_ID := p_CHARGE_ID;
    v_FORMULA_CHARGE_VAR.CHARGE_ID := p_CHARGE_ID;
    v_FORMULA_CHARGE.CHARGE_ID := p_CHARGE_ID;

    v_ITERATOR_NAME.ITERATOR_NAME1 := g_ITER_NAME_SERVICE_POINT;
    v_ITERATOR_NAME.ITERATOR_NAME2 := CASE p_GATE WHEN TRUE THEN g_ITER_NAME_AGREEMENT_TYPE ELSE NULL END;
    v_ITERATOR_NAME.ITERATOR_NAME3 := NULL;
    v_ITERATOR_NAME.ITERATOR_NAME4 := NULL;
    v_ITERATOR_NAME.ITERATOR_NAME5 := NULL;
    PC.PUT_FORMULA_ITERATOR_NAMES(v_ITERATOR_NAME);

    FOR v_CHG_DETAIL IN C_CHG_DETAIL(v_VAR_NAME1, v_VAR_NAME2) LOOP
        IF p_INTERCONNECT AND p_GATE THEN
          MM_SEM_UTIL.GET_GATE_INTERCONNECT(v_CHG_DETAIL.CONTRACT, v_GATE_WINDOW, v_SERV_PT_NAME);
        ELSIF p_INTERCONNECT AND NOT p_GATE THEN
          MM_SEM_UTIL.GET_GATE_INTERCONNECT(MM_SEM_UTIL.g_INTERCONNECT_I_NIMOYLE, v_GATE_WINDOW, v_SERV_PT_NAME);
          ELSIF NOT p_INTERCONNECT AND NOT p_GATE THEN
                v_SERV_PT_NAME := v_CHG_DETAIL.RESOURCE_NAME;
        END IF;

        v_ITERATOR_KEY := CASE WHEN p_GATE THEN v_CHG_DETAIL.CONTRACT ELSE v_SERV_PT_NAME END;
        IF v_ITERATOR_ID_MAP.EXISTS(v_ITERATOR_KEY) THEN
            v_ITERATOR.ITERATOR_ID := v_ITERATOR_ID_MAP(v_ITERATOR_KEY);
        ELSE
            v_ITERATOR.ITERATOR_ID := v_ITERATOR_ID + 1;
            v_ITERATOR_ID_MAP(v_ITERATOR_KEY) := v_ITERATOR.ITERATOR_ID;
            v_ITERATOR_ID := v_ITERATOR_ID + 1;
        END IF;
        v_ITERATOR.ITERATOR1 := v_SERV_PT_NAME;
    		v_ITERATOR.ITERATOR2 := CASE p_GATE WHEN TRUE THEN v_GATE_WINDOW ELSE NULL END;
    		v_ITERATOR.ITERATOR3 := NULL;
    		v_ITERATOR.ITERATOR4 := NULL;
    		v_ITERATOR.ITERATOR5 := NULL;
        PC.PUT_FORMULA_ITERATOR(v_ITERATOR);

        v_TLAF := MM_SEM_SHADOW_BILL.GET_TLAF(v_CHG_DETAIL.CHARGE_DATE,
                                                v_SERV_PT_NAME, p_ENTITY_ID);

        v_FORMULA_CHARGE_VAR.ITERATOR_ID := v_ITERATOR.ITERATOR_ID;
        v_FORMULA_CHARGE_VAR.CHARGE_DATE := v_CHG_DETAIL.CHARGE_DATE;
        v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'MSQ';
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_CHG_DETAIL.MSQ_VAL;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
        v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'DQ';
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_CHG_DETAIL.DQ_VAL;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
        v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'TLAF';
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := NVL(v_TLAF,1);
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
        v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'DQLF';
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := NVL(v_TLAF,1) * v_CHG_DETAIL.DQ_VAL;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
        v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'MSQLF';
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := NVL(v_TLAF,1) * v_CHG_DETAIL.MSQ_VAL;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
        v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'DOP';
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := NULL;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
        v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'DNLC';
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := NULL;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
        v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'MOP';
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := NULL;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
        v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'MNLC';
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := NULL;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
        v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'DQCC';
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := NULL;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
        v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'MSQCCC';
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := NULL;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
        v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'DSUC';
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := NULL;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
        v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'MSUC';
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := NULL;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
        --if we get the values for all determinants, multiply MSQ/DQ by TPD

        v_CHG_AMOUNT := GET_EXTERNAL_CHARGE_AMOUNT(p_CHARGE_ID,
                                                v_CHG_DETAIL.CHARGE_DATE,
                                                v_CHG_DETAIL.RESOURCE_NAME,
                                                v_CHG_DETAIL.CONTRACT);

        v_FORMULA_CHARGE.ITERATOR_ID := v_ITERATOR.ITERATOR_ID;
        v_FORMULA_CHARGE.CHARGE_DATE := v_CHG_DETAIL.CHARGE_DATE;
        v_FORMULA_CHARGE.CHARGE_QUANTITY := v_CHG_AMOUNT;
        v_FORMULA_CHARGE.CHARGE_RATE := 1;
        v_FORMULA_CHARGE.CHARGE_AMOUNT := v_CHG_AMOUNT;
        PC.PUT_FORMULA_CHARGE(v_FORMULA_CHARGE);
    END LOOP;

END EXTRACT_CONPEX_CHARGE;
----------------------------------------------------------------------------------------
PROCEDURE EXTRACT_MWPEX_CHARGE
    (
    p_STATEMENT_ID IN NUMBER,
    p_CHARGE_ID IN NUMBER,
    p_ENTITY_ID IN NUMBER,
	p_CONVERSION_RATE IN CONVERSION_RATE_ARRAY,
    p_INTERCONNECT IN BOOLEAN,
	p_GATE IN BOOLEAN
    ) IS

CURSOR c_CHG_DETAIL(v_NAME IN VARCHAR2) IS
    SELECT S.CHARGE_DATE, S.RESOURCE_NAME, S.CONTRACT,
            S.VALUE "MSQ_VAL", T.VALUE "SMP_VAL"
    FROM SEM_MP_INFO S, SEM_MP_INFO T
    WHERE S.STATEMENT_ID = p_STATEMENT_ID
    AND S.VARIABLE_TYPE = v_NAME
    AND T.STATEMENT_ID = p_STATEMENT_ID
    AND T.VARIABLE_TYPE = 'SMP'
    AND T.CHARGE_DATE = S.CHARGE_DATE
    ORDER BY CHARGE_DATE, RESOURCE_NAME, CONTRACT;
TYPE ITERATOR_ID_MAP IS TABLE OF NUMBER(2) INDEX BY VARCHAR2(100);
v_FORMULA_CHARGE FORMULA_CHARGE%ROWTYPE;
v_FORMULA_CHARGE_VAR FORMULA_CHARGE_VARIABLE%ROWTYPE;
v_ITERATOR_NAME FORMULA_CHARGE_ITERATOR_NAME%ROWTYPE;
v_ITERATOR FORMULA_CHARGE_ITERATOR%ROWTYPE;
v_ITERATOR_ID_MAP ITERATOR_ID_MAP;
v_ITERATOR_ID NUMBER(3) := 0;
v_TLAF SEM_LOSS_FACTOR.LOSS_FACTOR%TYPE;
v_CHG_AMOUNT SEM_DETAIL_CHARGE.CHARGE_AMOUNT%TYPE;
v_VAR_NAME SEM_MP_INFO.VARIABLE_TYPE%TYPE;
v_SERV_PT_NAME SERVICE_POINT.SERVICE_POINT_NAME%TYPE;
v_GATE_WINDOW  STATEMENT_TYPE.STATEMENT_TYPE_NAME%TYPE;
v_RATE NUMBER;
v_ITERATOR_KEY VARCHAR2(100);
BEGIN
    UPDATE BILLING_STATEMENT
    SET CHARGE_VIEW_TYPE = 'FORMULA'
    WHERE CHARGE_ID = p_CHARGE_ID;

    IF p_INTERCONNECT AND p_GATE THEN
        v_VAR_NAME := 'MSQIUG';
	ELSIF p_INTERCONNECT AND NOT p_GATE THEN
        v_VAR_NAME := 'MSQIU';
	ELSIF NOT p_INTERCONNECT AND NOT p_GATE THEN
        v_VAR_NAME := 'MSQ';
    END IF;

    v_ITERATOR_NAME.CHARGE_ID := p_CHARGE_ID;
    v_ITERATOR.CHARGE_ID := p_CHARGE_ID;
    v_FORMULA_CHARGE_VAR.CHARGE_ID := p_CHARGE_ID;
    v_FORMULA_CHARGE.CHARGE_ID := p_CHARGE_ID;

    v_ITERATOR_NAME.ITERATOR_NAME1 := g_ITER_NAME_SERVICE_POINT;
    v_ITERATOR_NAME.ITERATOR_NAME2 := CASE p_GATE WHEN TRUE THEN g_ITER_NAME_AGREEMENT_TYPE ELSE NULL END;
    v_ITERATOR_NAME.ITERATOR_NAME3 := NULL;
    v_ITERATOR_NAME.ITERATOR_NAME4 := NULL;
    v_ITERATOR_NAME.ITERATOR_NAME5 := NULL;
    PC.PUT_FORMULA_ITERATOR_NAMES(v_ITERATOR_NAME);

    FOR v_CHG_DETAIL IN C_CHG_DETAIL(v_VAR_NAME) LOOP
      --Determine the exchange rate based on the hour of the day
      v_RATE := DETERMINE_CONVERSION_RATE_HOUR(v_CHG_DETAIL.CHARGE_DATE, p_CONVERSION_RATE);

      IF p_INTERCONNECT AND p_GATE THEN
        MM_SEM_UTIL.GET_GATE_INTERCONNECT(v_CHG_DETAIL.CONTRACT, v_GATE_WINDOW, v_SERV_PT_NAME);
      ELSIF p_INTERCONNECT AND NOT p_GATE THEN
        MM_SEM_UTIL.GET_GATE_INTERCONNECT(MM_SEM_UTIL.g_INTERCONNECT_I_NIMOYLE, v_GATE_WINDOW, v_SERV_PT_NAME);
        ELSIF NOT p_INTERCONNECT AND NOT p_GATE THEN
              v_SERV_PT_NAME := v_CHG_DETAIL.RESOURCE_NAME;
      END IF;

        v_ITERATOR_KEY := CASE WHEN p_GATE THEN v_CHG_DETAIL.CONTRACT ELSE v_SERV_PT_NAME END;
        IF v_ITERATOR_ID_MAP.EXISTS(v_ITERATOR_KEY) THEN
            v_ITERATOR.ITERATOR_ID := v_ITERATOR_ID_MAP(v_ITERATOR_KEY);
        ELSE
            v_ITERATOR.ITERATOR_ID := v_ITERATOR_ID + 1;
            v_ITERATOR_ID_MAP(v_ITERATOR_KEY) := v_ITERATOR.ITERATOR_ID;
            v_ITERATOR_ID := v_ITERATOR_ID + 1;
        END IF;
        v_ITERATOR.ITERATOR1 := v_SERV_PT_NAME;
    		v_ITERATOR.ITERATOR2 := CASE p_GATE WHEN TRUE THEN v_GATE_WINDOW ELSE NULL END;
    		v_ITERATOR.ITERATOR3 := NULL;
    		v_ITERATOR.ITERATOR4 := NULL;
    		v_ITERATOR.ITERATOR5 := NULL;
            PC.PUT_FORMULA_ITERATOR(v_ITERATOR);

            v_TLAF := MM_SEM_SHADOW_BILL.GET_TLAF(v_CHG_DETAIL.CHARGE_DATE,
                                                    v_SERV_PT_NAME, p_ENTITY_ID);

            v_FORMULA_CHARGE_VAR.ITERATOR_ID := v_ITERATOR.ITERATOR_ID;
            v_FORMULA_CHARGE_VAR.CHARGE_DATE := v_CHG_DETAIL.CHARGE_DATE;
            v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'MSQ';
            v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_CHG_DETAIL.MSQ_VAL;
            PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
            v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'SMP';
            v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_CHG_DETAIL.SMP_VAL * v_RATE;
            PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
            v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'TLAF';
            v_FORMULA_CHARGE_VAR.VARIABLE_VAL := NVL(v_TLAF,1);
            PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
            v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'MSQLF';
            v_FORMULA_CHARGE_VAR.VARIABLE_VAL := NVL(v_TLAF,1) * v_CHG_DETAIL.MSQ_VAL;
            PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
            v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'MOP';
            v_FORMULA_CHARGE_VAR.VARIABLE_VAL := NULL;
            PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
            v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'MNLC';
            v_FORMULA_CHARGE_VAR.VARIABLE_VAL := NULL;
            PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
            v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'MSQCCC';
            v_FORMULA_CHARGE_VAR.VARIABLE_VAL := NULL;
            PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);
            --if we get the values for all determinants, multiply MSQ by TPD

            v_CHG_AMOUNT := GET_EXTERNAL_CHARGE_AMOUNT(p_CHARGE_ID,
                                                    v_CHG_DETAIL.CHARGE_DATE,
                                                    v_CHG_DETAIL.RESOURCE_NAME,
                                                    v_CHG_DETAIL.CONTRACT);

            v_FORMULA_CHARGE.ITERATOR_ID := v_ITERATOR.ITERATOR_ID;
            v_FORMULA_CHARGE.CHARGE_DATE := v_CHG_DETAIL.CHARGE_DATE;
            v_FORMULA_CHARGE.CHARGE_QUANTITY := v_CHG_AMOUNT;
            v_FORMULA_CHARGE.CHARGE_RATE := 1;
            v_FORMULA_CHARGE.CHARGE_AMOUNT := v_CHG_AMOUNT;
            PC.PUT_FORMULA_CHARGE(v_FORMULA_CHARGE);
    END LOOP;

END EXTRACT_MWPEX_CHARGE;
----------------------------------------------------------------------------------------
PROCEDURE EXTRACT_UNIMPEX_CHARGE
	(
	p_STATEMENT_ID IN NUMBER,
	p_CHARGE_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_CONVERSION_RATE IN CONVERSION_RATE_ARRAY
	) IS

CURSOR c_CHG_DETAIL IS
    SELECT S.CHARGE_DATE,
	       S.RESOURCE_NAME,
           S.VALUE "DQ_VAL",
		   T.VALUE "SMP_VAL",
		   V.VALUE "AO_VAL"
    FROM SEM_MP_INFO S,
	     SEM_MP_INFO T,
		 SEM_MP_INFO V
    WHERE S.STATEMENT_ID = p_STATEMENT_ID
      AND S.VARIABLE_TYPE = 'DQ'
      AND T.STATEMENT_ID = p_STATEMENT_ID
      AND T.VARIABLE_TYPE = 'SMP'
      AND T.CHARGE_DATE = S.CHARGE_DATE
	  AND V.STATEMENT_ID = p_STATEMENT_ID
      AND V.VARIABLE_TYPE = 'MG' ---for external side this is Meter Generation data, stored in PIR
      AND V.CHARGE_DATE = S.CHARGE_DATE
      AND V.RESOURCE_NAME = S.RESOURCE_NAME
    ORDER BY CHARGE_DATE, RESOURCE_NAME;

TYPE ITERATOR_ID_MAP IS TABLE OF NUMBER(2) INDEX BY VARCHAR2(32);
v_FORMULA_CHARGE 		FORMULA_CHARGE%ROWTYPE;
v_FORMULA_CHARGE_VAR 	FORMULA_CHARGE_VARIABLE%ROWTYPE;
v_ITERATOR_NAME 		FORMULA_CHARGE_ITERATOR_NAME%ROWTYPE;
v_ITERATOR 				FORMULA_CHARGE_ITERATOR%ROWTYPE;
v_ITERATOR_ID_MAP 		ITERATOR_ID_MAP;
v_ITERATOR_ID 			NUMBER(3) := 0;
v_TLAF 					SEM_LOSS_FACTOR.LOSS_FACTOR%TYPE;
--v_DOP                   NUMBER;
--c_ENGTOL                NUMBER := 0.1;
--c_MWTOL                 NUMBER := 1;
v_AOLF                  NUMBER;
v_DQLF                  NUMBER;
v_SMP                   NUMBER;
v_CHG_AMOUNT SEM_DETAIL_CHARGE.CHARGE_AMOUNT%TYPE;
v_RATE NUMBER;

BEGIN
    UPDATE BILLING_STATEMENT
       SET CHARGE_VIEW_TYPE = 'FORMULA'
     WHERE CHARGE_ID = p_CHARGE_ID;

    v_ITERATOR_NAME.CHARGE_ID := p_CHARGE_ID;
    v_ITERATOR.CHARGE_ID := p_CHARGE_ID;
    v_FORMULA_CHARGE_VAR.CHARGE_ID := p_CHARGE_ID;
    v_FORMULA_CHARGE.CHARGE_ID := p_CHARGE_ID;

    v_ITERATOR_NAME.ITERATOR_NAME1 := g_ITER_NAME_SERVICE_POINT;
    v_ITERATOR_NAME.ITERATOR_NAME2 := NULL;
    v_ITERATOR_NAME.ITERATOR_NAME3 := NULL;
    v_ITERATOR_NAME.ITERATOR_NAME4 := NULL;
    v_ITERATOR_NAME.ITERATOR_NAME5 := NULL;
    PC.PUT_FORMULA_ITERATOR_NAMES(v_ITERATOR_NAME);

    FOR v_CHG_DETAIL IN C_CHG_DETAIL LOOP
		--Determine the exchange rate based on the hour of the day
		v_RATE := DETERMINE_CONVERSION_RATE_HOUR(v_CHG_DETAIL.CHARGE_DATE, p_CONVERSION_RATE);

        IF v_ITERATOR_ID_MAP.EXISTS(v_CHG_DETAIL.RESOURCE_NAME) THEN
            v_ITERATOR.ITERATOR_ID := v_ITERATOR_ID_MAP(v_CHG_DETAIL.RESOURCE_NAME);
        ELSE
            v_ITERATOR.ITERATOR_ID := v_ITERATOR_ID + 1;
            v_ITERATOR_ID_MAP(v_CHG_DETAIL.RESOURCE_NAME) := v_ITERATOR.ITERATOR_ID;
            v_ITERATOR_ID := v_ITERATOR_ID + 1;
        END IF;
        v_ITERATOR.ITERATOR1 := v_CHG_DETAIL.RESOURCE_NAME;
        v_ITERATOR.ITERATOR2 := NULL;
		v_ITERATOR.ITERATOR3 := NULL;
		v_ITERATOR.ITERATOR4 := NULL;
		v_ITERATOR.ITERATOR5 := NULL;
        PC.PUT_FORMULA_ITERATOR(v_ITERATOR);

        v_TLAF := MM_SEM_SHADOW_BILL.GET_TLAF(v_CHG_DETAIL.CHARGE_DATE,
                                              v_CHG_DETAIL.RESOURCE_NAME,
											  p_ENTITY_ID);

        v_FORMULA_CHARGE_VAR.ITERATOR_ID := v_ITERATOR.ITERATOR_ID;
        v_FORMULA_CHARGE_VAR.CHARGE_DATE := v_CHG_DETAIL.CHARGE_DATE;

		v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'DQ';
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_CHG_DETAIL.DQ_VAL;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

        v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'SMP';
		v_SMP := v_CHG_DETAIL.SMP_VAL;
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_SMP * v_RATE;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

		v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'ActualOutput';
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_CHG_DETAIL.AO_VAL;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

        v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'TLAF';
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := NVL(v_TLAF,1);
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

		v_DQLF := NVL(v_CHG_DETAIL.DQ_VAL, 0) * v_TLAF;
		v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'DQLF';
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_DQLF;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

		v_AOLF := NVL(v_CHG_DETAIL.AO_VAL,0) * v_TLAF;
		v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'AOLF';
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_AOLF;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

		v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'ENGTOL';
        --External source for ENGTOL unavailable - so set to value from component
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := g_COMP_DET_CONSTANTS_CACHE('ENGTOL');
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

		v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'MWTOL';
        --External source for MWTOL unavailable - so set to value from component
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := g_COMP_DET_CONSTANTS_CACHE('MWTOL');
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

		v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'DOG';
        --External source for DOG unavailable - so set to value from component
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := g_COMP_DET_CONSTANTS_CACHE('DOG');
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

		v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'PUG';
        --External source for PUG unavailable - so set to value from component;
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := g_COMP_DET_CONSTANTS_CACHE('PUG');
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

		v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'UREG';
        --External source for RegCap unavailable - so set to value from component
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := g_COMP_DET_CONSTANTS_CACHE('UREG');
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);


        v_CHG_AMOUNT := GET_EXTERNAL_CHARGE_AMOUNT(p_CHARGE_ID,
                                                    v_CHG_DETAIL.CHARGE_DATE,
                                                    v_CHG_DETAIL.RESOURCE_NAME);

        v_FORMULA_CHARGE.ITERATOR_ID := v_ITERATOR.ITERATOR_ID;
        v_FORMULA_CHARGE.CHARGE_DATE := v_CHG_DETAIL.CHARGE_DATE;
        v_FORMULA_CHARGE.CHARGE_QUANTITY := v_CHG_AMOUNT;
        v_FORMULA_CHARGE.CHARGE_RATE := 1;
        v_FORMULA_CHARGE.CHARGE_AMOUNT := v_CHG_AMOUNT;
        PC.PUT_FORMULA_CHARGE(v_FORMULA_CHARGE);

    END LOOP;

END EXTRACT_UNIMPEX_CHARGE;
----------------------------------------------------------------------------------------
PROCEDURE EXTRACT_TCHAREX_CHARGE
	(
	p_STATEMENT_ID IN NUMBER,
	p_CHARGE_ID    IN NUMBER,
	p_ENTITY_ID    IN NUMBER
	) IS

CURSOR c_CHG_DETAIL IS
    SELECT S.CHARGE_DATE,
	       S.RESOURCE_NAME,
           S.VALUE "MG_VAL"
    FROM SEM_MP_INFO S
    WHERE S.STATEMENT_ID = p_STATEMENT_ID
      AND S.VARIABLE_TYPE = 'MG'
    ORDER BY CHARGE_DATE, RESOURCE_NAME;

TYPE ITERATOR_ID_MAP IS TABLE OF NUMBER(2) INDEX BY VARCHAR2(32);
v_FORMULA_CHARGE 		FORMULA_CHARGE%ROWTYPE;
v_FORMULA_CHARGE_VAR 	FORMULA_CHARGE_VARIABLE%ROWTYPE;
v_ITERATOR_NAME 		FORMULA_CHARGE_ITERATOR_NAME%ROWTYPE;
v_ITERATOR 				FORMULA_CHARGE_ITERATOR%ROWTYPE;
v_ITERATOR_ID_MAP 		ITERATOR_ID_MAP;
v_ITERATOR_ID 			NUMBER(3) := 0;
v_TLAF 					SEM_LOSS_FACTOR.LOSS_FACTOR%TYPE;
v_CHG_AMOUNT SEM_DETAIL_CHARGE.CHARGE_AMOUNT%TYPE;

BEGIN
    UPDATE BILLING_STATEMENT
       SET CHARGE_VIEW_TYPE = 'FORMULA'
     WHERE CHARGE_ID = p_CHARGE_ID;

    v_ITERATOR_NAME.CHARGE_ID := p_CHARGE_ID;
    v_ITERATOR.CHARGE_ID := p_CHARGE_ID;
    v_FORMULA_CHARGE_VAR.CHARGE_ID := p_CHARGE_ID;
    v_FORMULA_CHARGE.CHARGE_ID := p_CHARGE_ID;

    v_ITERATOR_NAME.ITERATOR_NAME1 := g_ITER_NAME_SERVICE_POINT;
    v_ITERATOR_NAME.ITERATOR_NAME2 := NULL;
    v_ITERATOR_NAME.ITERATOR_NAME3 := NULL;
    v_ITERATOR_NAME.ITERATOR_NAME4 := NULL;
    v_ITERATOR_NAME.ITERATOR_NAME5 := NULL;
    PC.PUT_FORMULA_ITERATOR_NAMES(v_ITERATOR_NAME);

    FOR v_CHG_DETAIL IN C_CHG_DETAIL LOOP

        IF v_ITERATOR_ID_MAP.EXISTS(v_CHG_DETAIL.RESOURCE_NAME) THEN
            v_ITERATOR.ITERATOR_ID := v_ITERATOR_ID_MAP(v_CHG_DETAIL.RESOURCE_NAME);
        ELSE
            v_ITERATOR.ITERATOR_ID := v_ITERATOR_ID + 1;
            v_ITERATOR_ID_MAP(v_CHG_DETAIL.RESOURCE_NAME) := v_ITERATOR.ITERATOR_ID;
            v_ITERATOR_ID := v_ITERATOR_ID + 1;
        END IF;
        v_ITERATOR.ITERATOR1 := v_CHG_DETAIL.RESOURCE_NAME;
        v_ITERATOR.ITERATOR2 := NULL;
		v_ITERATOR.ITERATOR3 := NULL;
		v_ITERATOR.ITERATOR4 := NULL;
		v_ITERATOR.ITERATOR5 := NULL;
        PC.PUT_FORMULA_ITERATOR(v_ITERATOR);

        v_TLAF := MM_SEM_SHADOW_BILL.GET_TLAF(v_CHG_DETAIL.CHARGE_DATE,
                                              v_CHG_DETAIL.RESOURCE_NAME,
											  p_ENTITY_ID);

        v_FORMULA_CHARGE_VAR.ITERATOR_ID := v_ITERATOR.ITERATOR_ID;
        v_FORMULA_CHARGE_VAR.CHARGE_DATE := v_CHG_DETAIL.CHARGE_DATE;

		v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'MG';
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_CHG_DETAIL.MG_VAL;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

        v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'TariffRate';
        --External source for Tariff Rate unavailable - so set to NULL;
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := NULL;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

        v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'TLAF';
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := NVL(v_TLAF,1);
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

        v_CHG_AMOUNT := GET_EXTERNAL_CHARGE_AMOUNT(p_CHARGE_ID,
                                                    v_CHG_DETAIL.CHARGE_DATE,
                                                    v_CHG_DETAIL.RESOURCE_NAME);

		v_FORMULA_CHARGE.ITERATOR_ID := v_ITERATOR.ITERATOR_ID;
        v_FORMULA_CHARGE.CHARGE_DATE := v_CHG_DETAIL.CHARGE_DATE;
        v_FORMULA_CHARGE.CHARGE_QUANTITY := v_CHG_DETAIL.MG_VAL * NVL(v_TLAF,1);
        --External source for Tariff Rate unavailable - so set to NULL;
        v_FORMULA_CHARGE.CHARGE_RATE := NULL;
        v_FORMULA_CHARGE.CHARGE_AMOUNT := v_CHG_AMOUNT;
        PC.PUT_FORMULA_CHARGE(v_FORMULA_CHARGE);

    END LOOP;
END EXTRACT_TCHAREX_CHARGE;
----------------------------------------------------------------------------------------
PROCEDURE EXTRACT_CURRENCY_CHARGE
    (
    p_CHARGE_ID IN NUMBER
    ) IS
CURSOR c_CHG_DETAIL IS
    SELECT S.CHARGE_DATE,
           NVL(SUM(S.CHARGE_AMOUNT),0) AS CHARGE_AMOUNT
      FROM SEM_DETAIL_CHARGE S
     WHERE S.CHARGE_ID = p_CHARGE_ID
     GROUP BY S.CHARGE_DATE;

v_FORMULA_CHARGE FORMULA_CHARGE%ROWTYPE;
BEGIN
    UPDATE BILLING_STATEMENT
    SET CHARGE_VIEW_TYPE = 'FORMULA'
    WHERE CHARGE_ID = p_CHARGE_ID;

    FOR v_CHG_DETAIL IN c_CHG_DETAIL LOOP
        v_FORMULA_CHARGE.CHARGE_ID := p_CHARGE_ID;
        v_FORMULA_CHARGE.ITERATOR_ID := 0;
        v_FORMULA_CHARGE.CHARGE_DATE := v_CHG_DETAIL.CHARGE_DATE;
        v_FORMULA_CHARGE.CHARGE_QUANTITY := v_CHG_DETAIL.CHARGE_AMOUNT;
        v_FORMULA_CHARGE.CHARGE_RATE := 1;
        v_FORMULA_CHARGE.CHARGE_AMOUNT := v_CHG_DETAIL.CHARGE_AMOUNT;
        PC.PUT_FORMULA_CHARGE(v_FORMULA_CHARGE);
    END LOOP;

END EXTRACT_CURRENCY_CHARGE;
-------------------------------------------------------------------------------------
PROCEDURE EXTRACT_BILL_PERIOD_CURR_COST
    (
    p_CHARGE_DATE IN DATE,
    p_CHARGE_AMOUNT IN NUMBER
    ) IS
v_MARKET_PRICE_ID MARKET_PRICE.MARKET_PRICE_ID%TYPE;
v_STATUS NUMBER;
v_MESSAGE VARCHAR2(512);
v_START_DATE DATE;
BEGIN
    v_MARKET_PRICE_ID := MM_SEM_UTIL.GET_MARKET_PRICE_ID('Total Bill Period Currency Cost',
                                                                    'Market Result',
                                                                    'Day',
                                                                    TRUE);

    v_START_DATE := p_CHARGE_DATE - 6;

    WHILE v_START_DATE <= p_CHARGE_DATE LOOP

    MM_UTIL.PUT_MARKET_PRICE_VALUE(v_MARKET_PRICE_ID,
                                        v_START_DATE,
                                    'A', --Actual
                                    p_CHARGE_AMOUNT,
                                    0,
                                    v_STATUS,
                                    v_MESSAGE);
        v_START_DATE := v_START_DATE + 1;
    END LOOP;

END EXTRACT_BILL_PERIOD_CURR_COST;
-------------------------------------------------------------------------------------
PROCEDURE EXTRACT_SETTL_DETERMINANTS
    (
    p_STATEMENT_ID IN NUMBER
    ) IS
TYPE MP_ARRAY IS VARRAY(5) OF VARCHAR2(64);
TYPE TXN_ARRAY IS VARRAY(6) OF VARCHAR2(64);
v_MP_DETERMINANTS MP_ARRAY :=
    MP_ARRAY('CPDP-Capacity Payments Demand Price',
            'CPGP-Capacity Payments Generation Price',
            'ECGP-Ex-Post Capacity Payments Generation Price',
            'FCGP-Fixed Capacity Payments Generation Price',
            'VCPGP-Variable Capacity Payments Generation Price');

--LD, 09-18-2007, per MPUD v4.3 the NDLFJ variable name have been modified to read NDLFESU
v_TXN_DETERMINANTS TXN_ARRAY := TXN_ARRAY('DQ-Dispatch Quantity',
                                  'DQIU-Dispatch Quantity',
                                  'DQIUG-Dispatch Quantity',
                                  'NDLFESU-Loss Adjusted Net Demand ESU',
                                  'EA-Eligible Availability',
								  'MSQ-Market Schedule');

CURSOR c_DET_DETAIL(v_VAR_TYPE IN VARCHAR2) IS
	SELECT *
	FROM SEM_MP_INFO
	WHERE STATEMENT_ID = p_STATEMENT_ID
    AND VARIABLE_TYPE = v_VAR_TYPE
    ORDER BY CHARGE_DATE;
v_MARKET_PRICE_ID MARKET_PRICE.MARKET_PRICE_ID%TYPE;
v_TXN_ID INTERCHANGE_TRANSACTION.TRANSACTION_ID%TYPE;
v_STATUS NUMBER;
v_MESSAGE VARCHAR2(512);
v_STATEMENT_TYPE SEM_MP_STATEMENT.STATEMENT_TYPE%TYPE;
v_TRANSACTION_TYPE INTERCHANGE_TRANSACTION.TRANSACTION_TYPE%TYPE;
v_COMMODITY_NAME IT_COMMODITY.COMMODITY_NAME%TYPE;
v_SERV_PT_NAME SERVICE_POINT.SERVICE_POINT_NAME%TYPE;
--------------------------------------------------------
v_PRICE_CODE MARKET_PRICE_VALUE.PRICE_CODE%TYPE;
v_STATEMENT_TYPE_EXT_IDENT VARCHAR2(32);
v_ENTITY_ID NUMBER(9);
v_MARKET SEM_SETTLEMENT_ENTITY.MARKET_NAME%TYPE;
v_TXN_IDENT INTERCHANGE_TRANSACTION.TRANSACTION_IDENTIFIER%TYPE;
v_TXN_DETERMINANT_NAME VARCHAR2(64);
v_TXN_DETERMINANT_DESC VARCHAR2(64);
v_TRANSACTION_NAME INTERCHANGE_TRANSACTION.TRANSACTION_NAME%TYPE;
v_GATE_WINDOW INTERCHANGE_TRANSACTION.AGREEMENT_TYPE%TYPE;

BEGIN
	SELECT STATEMENT_TYPE, ENTITY_ID
    INTO v_STATEMENT_TYPE, v_ENTITY_ID
	FROM SEM_MP_STATEMENT
    WHERE STATEMENT_ID = p_STATEMENT_ID;

    -- Look up the market for based on the statement being processed.
    BEGIN
        SELECT SSE.MARKET_NAME
        INTO v_MARKET
        FROM SEM_SETTLEMENT_ENTITY SSE
        WHERE SSE.SETTLEMENT_PSE_ID = v_ENTITY_ID;
    EXCEPTION
      WHEN no_data_found THEN
         -- default to NULL
         v_MARKET := NULL;
    END;

	--BZ 14928 - populate the price prices with a price code that is based on the PIR's statement type
	--if PIR's statement type was Indicative then price code P, otherwise A
	v_STATEMENT_TYPE_EXT_IDENT := EI.GET_ENTITY_IDENTIFIER_EXTSYS(EC.ED_STATEMENT_TYPE, v_STATEMENT_TYPE, EC.ES_SEM, MM_SEM_UTIL.g_STATEMENT_TYPE_SETTLEMENT, 1);
	v_PRICE_CODE := CASE WHEN v_STATEMENT_TYPE_EXT_IDENT = 'P' THEN 'P' ELSE 'A' END;

    FOR I IN v_MP_DETERMINANTS.FIRST .. v_MP_DETERMINANTS.LAST LOOP
		-- assume that if we can't find this in system settings, then we need to populate the price (BZ 15487)
		IF NVL(GET_DICTIONARY_VALUE(v_MP_DETERMINANTS(I),
								   0,
								   'MarketExchange',
								   'SEM',
								   'UsePIRForInternal'), 1) = 1 THEN

			FOR v_DET_DETAIL IN
				c_DET_DETAIL(SUBSTR(v_MP_DETERMINANTS(I), 1, INSTR(v_MP_DETERMINANTS(I),'-')-1)) LOOP
					v_MARKET_PRICE_ID := MM_SEM_UTIL.GET_MARKET_PRICE_ID(SUBSTR(v_MP_DETERMINANTS(I),
																		INSTR(v_MP_DETERMINANTS(I),'-')+1),
																		'User Defined',
																		'30 Minute',
																		TRUE);
					MM_UTIL.PUT_MARKET_PRICE_VALUE(v_MARKET_PRICE_ID,
													v_DET_DETAIL.CHARGE_DATE,
													v_PRICE_CODE, --'P' if Indicative PIR, 'A' if Initial or else
													v_DET_DETAIL.VALUE,
													0,
													v_STATUS,
													v_MESSAGE);

			END LOOP;
		END IF;
    END LOOP;

    FOR I IN v_TXN_DETERMINANTS.FIRST .. v_TXN_DETERMINANTS.LAST LOOP
		v_GATE_WINDOW := NULL;
		-- assume that if we can't find this in system settings, then we need to populate the transaction (BZ 15487)
		IF NVL(GET_DICTIONARY_VALUE(v_TXN_DETERMINANTS(I),
								   0,
								   'MarketExchange',
								   'SEM',
								   'UsePIRForInternal'), 1) = 1 THEN
            v_TXN_DETERMINANT_NAME := SUBSTR(v_TXN_DETERMINANTS(I), 1, INSTR(v_TXN_DETERMINANTS(I),'-')-1);
            v_TXN_DETERMINANT_DESC := SUBSTR(v_TXN_DETERMINANTS(I), INSTR(v_TXN_DETERMINANTS(I),'-')+1);
			FOR v_DET_DETAIL IN c_DET_DETAIL(v_TXN_DETERMINANT_NAME) LOOP
				IF v_TXN_DETERMINANT_NAME = 'DQ' THEN
					v_TRANSACTION_TYPE := 'Dispatch Instr.';
					v_COMMODITY_NAME := 'Power';
					v_SERV_PT_NAME := v_DET_DETAIL.RESOURCE_NAME;
                    v_TXN_IDENT := v_TXN_DETERMINANT_NAME || ':' || v_SERV_PT_NAME;
                    v_TRANSACTION_NAME := 'SEM:' || v_TXN_DETERMINANT_DESC || ':' || v_SERV_PT_NAME;
				ELSIF v_TXN_DETERMINANT_NAME = 'DQIU' THEN
					v_TRANSACTION_TYPE := 'Dispatch Instr.';
					v_COMMODITY_NAME := 'Power';
					IF v_DET_DETAIL.RESOURCE_NAME = '?' THEN
						--the pir is not providing the resource name for the interconnector unit
						--so its name must be retrieved here
						MM_SEM_UTIL.GET_GATE_INTERCONNECT(MM_SEM_UTIL.g_INTERCONNECT_I_NIMOYLE, v_GATE_WINDOW, v_SERV_PT_NAME);
					END IF;
				  v_TXN_IDENT := v_TXN_DETERMINANT_NAME || ':' || v_SERV_PT_NAME;
				  v_TRANSACTION_NAME := 'SEM:' || v_TXN_DETERMINANT_DESC || ':' || v_SERV_PT_NAME;
				ELSIF v_TXN_DETERMINANT_NAME = 'DQIUG' THEN
					v_TRANSACTION_TYPE := 'Dispatch Instr.';
					v_COMMODITY_NAME := 'Power';
					IF v_DET_DETAIL.RESOURCE_NAME = '?' THEN
					  --the pir is not providing the resource name for the interconnector unit
					  --so its name must be retrieved here
					  MM_SEM_UTIL.GET_GATE_INTERCONNECT(v_DET_DETAIL.CONTRACT, v_GATE_WINDOW, v_SERV_PT_NAME);
					END IF;
					v_TXN_IDENT := v_TXN_DETERMINANT_NAME || ':' || v_SERV_PT_NAME || ':' || v_GATE_WINDOW;
					v_TRANSACTION_NAME := 'SEM:' || v_TXN_DETERMINANT_DESC || ':' || v_SERV_PT_NAME || ':' || v_GATE_WINDOW;
				ELSIF v_TXN_DETERMINANT_NAME = 'NDLFESU' THEN
					v_TRANSACTION_TYPE := 'Net Demand';
					v_COMMODITY_NAME := 'Energy';
					v_SERV_PT_NAME := v_DET_DETAIL.RESOURCE_NAME;
                    v_TXN_IDENT := v_TXN_DETERMINANT_NAME || ':' || v_SERV_PT_NAME;
                    v_TRANSACTION_NAME := 'SEM:' || v_TXN_DETERMINANT_DESC || ':' || v_SERV_PT_NAME;
				ELSIF v_TXN_DETERMINANT_NAME = 'EA' THEN
					v_TRANSACTION_TYPE := 'Eligible Avail.';
					v_COMMODITY_NAME := 'Capacity';
					v_SERV_PT_NAME := v_DET_DETAIL.RESOURCE_NAME;
                    v_TXN_IDENT := v_TXN_DETERMINANT_NAME || ':' || v_SERV_PT_NAME;
                    v_TRANSACTION_NAME := 'SEM:' || v_TXN_DETERMINANT_DESC || ':' || v_SERV_PT_NAME;
				ELSIF v_TXN_DETERMINANT_NAME = 'MSQ' THEN
					v_TRANSACTION_TYPE := 'Generation' || CASE v_MARKET WHEN 'CA' THEN ' ' || 'CA' ELSE NULL END;
					v_COMMODITY_NAME := 'Energy';
					v_SERV_PT_NAME := v_DET_DETAIL.RESOURCE_NAME;
                    v_TXN_IDENT := v_TXN_DETERMINANT_NAME
                                            || CASE v_MARKET WHEN 'CA' THEN '_CA' ELSE NULL END
                                            || ':' || v_SERV_PT_NAME;
                    v_TRANSACTION_NAME := v_SERV_PT_NAME || ':' ||
                                            v_TXN_DETERMINANT_DESC ||
                                            CASE v_MARKET WHEN 'CA' THEN ' ' || 'CA' ELSE NULL END;
				    -- see the corresponding code in MM_SEM_PIR_IMPORT.PUT_DETAIL_PIR
					-- Since the PIR copy expects transaction with EA, do the same when
					-- populating the transactions on import when using UsePIRForInternal flag
					v_GATE_WINDOW := MM_SEM_UTIL.g_EXTID_MKT_SCHED_EA_ABR;
				END IF;

				-- look based on the parameters we have
				-- [BZ 30586] add the gate window to the initial lookup
				v_TXN_ID := MM_SEM_UTIL.GET_TRANSACTION_ID(v_TRANSACTION_TYPE, v_SERV_PT_NAME, v_COMMODITY_NAME, v_GATE_WINDOW);
				IF v_TXN_ID IS NULL THEN
					-- can't find it? Look the old way, and create if necessary.
					v_TXN_ID := MM_SEM_UTIL.GET_TRANSACTION_ID(p_TRANSACTION_TYPE    => v_TRANSACTION_TYPE,
												   p_RESOURCE_NAME       => v_SERV_PT_NAME,
												   p_CREATE_IF_NOT_FOUND => TRUE,
												   p_AGREEMENT_TYPE => v_GATE_WINDOW,
												   p_TRANSACTION_NAME    => v_TRANSACTION_NAME,
												   p_EXTERNAL_IDENTIFIER => v_TXN_IDENT,
												   p_ACCOUNT_NAME => '%',
												   p_COMMODITY => v_COMMODITY_NAME);
				END IF;

				ITJ.PUT_IT_SCHEDULE(p_TRANSACTION_ID => v_TXN_ID,
									p_SCHEDULE_TYPE  => v_STATEMENT_TYPE,
									p_SCHEDULE_STATE => GA.INTERNAL_STATE,
									p_SCHEDULE_DATE  => v_DET_DETAIL.CHARGE_DATE,
									p_AS_OF_DATE     => LOW_DATE,
									p_AMOUNT         => v_DET_DETAIL.VALUE,
									p_PRICE          => NULL,
									p_STATUS         => v_STATUS);

			END LOOP;
		END IF;
    END LOOP;

END EXTRACT_SETTL_DETERMINANTS;
----------------------------------------------------------------------------------------
PROCEDURE EXTRACT_CHARGE
    (
    p_CHARGE_NAME IN VARCHAR2,
    p_STATEMENT_ID IN NUMBER,
    p_CHARGE_ID IN NUMBER,
    p_ENTITY_ID IN NUMBER,
    p_PSE_CURRENCY IN NUMBER,
    p_CONVERSION_RATE IN CONVERSION_RATE_ARRAY,
    p_CHARGE_DATE IN DATE,
    p_CHARGE_AMOUNT IN NUMBER
    ) IS
BEGIN
    CASE p_CHARGE_NAME
    WHEN 'CCEX' THEN
        EXTRACT_CCEX_CHARGE(p_STATEMENT_ID, p_CHARGE_ID, p_ENTITY_ID,	p_PSE_CURRENCY, FALSE);
    WHEN 'CCJEX' THEN
        EXTRACT_CCEX_CHARGE(p_STATEMENT_ID, p_CHARGE_ID, p_ENTITY_ID, p_PSE_CURRENCY, TRUE);
    WHEN 'ENCEX' THEN
        EXTRACT_ENCEX_CHARGE(p_STATEMENT_ID, p_CHARGE_ID, p_ENTITY_ID, p_CONVERSION_RATE, FALSE);
    WHEN 'ENCJEX' THEN
        EXTRACT_ENCEX_CHARGE(p_STATEMENT_ID, p_CHARGE_ID, p_ENTITY_ID, p_CONVERSION_RATE, TRUE);
    WHEN 'IMPCEX' THEN
        EXTRACT_IMPCEX_CHARGE(p_STATEMENT_ID, p_CHARGE_ID, p_ENTITY_ID, p_CONVERSION_RATE, FALSE);
    WHEN 'IMPCJEX' THEN
        EXTRACT_IMPCEX_CHARGE(p_STATEMENT_ID, p_CHARGE_ID, p_ENTITY_ID, p_CONVERSION_RATE, TRUE);
    WHEN 'FMOC_EX' THEN
        EXTRACT_FMOC_EX_CHARGE(p_CHARGE_ID, FALSE, FALSE);
    WHEN 'FMOCSUP_EX' THEN
        EXTRACT_FMOC_EX_CHARGE(p_CHARGE_ID, FALSE, FALSE);
    WHEN 'FMOCGEN_EX' THEN
        EXTRACT_FMOC_EX_CHARGE(p_CHARGE_ID, FALSE, FALSE);        
    WHEN 'FMOCIU_EX' THEN
        EXTRACT_FMOC_EX_CHARGE(p_CHARGE_ID, TRUE, FALSE);
    WHEN 'FMOCIUG_EX' THEN
        EXTRACT_FMOC_EX_CHARGE(p_CHARGE_ID, TRUE, TRUE);
    WHEN 'VMOC_EX' THEN
        EXTRACT_VMOC_EX_CHARGE(p_STATEMENT_ID, p_CHARGE_ID, p_ENTITY_ID, p_CONVERSION_RATE, FALSE);
    WHEN 'VMOCJ_EX' THEN
        EXTRACT_VMOC_EX_CHARGE(p_STATEMENT_ID, p_CHARGE_ID, p_ENTITY_ID, p_CONVERSION_RATE, TRUE);
    WHEN 'CPEX' THEN
        EXTRACT_CPEX_CHARGE(p_STATEMENT_ID, p_CHARGE_ID, p_ENTITY_ID, FALSE, FALSE);
    WHEN 'CPIUEX' THEN
        EXTRACT_CPEX_CHARGE(p_STATEMENT_ID, p_CHARGE_ID, p_ENTITY_ID, TRUE, FALSE);
    WHEN 'CPIUGEX' THEN
        EXTRACT_CPEX_CHARGE(p_STATEMENT_ID, p_CHARGE_ID, p_ENTITY_ID, TRUE, TRUE);
    WHEN 'ENPEX' THEN
        EXTRACT_ENPEX_CHARGE(p_STATEMENT_ID, p_CHARGE_ID, p_ENTITY_ID, p_CONVERSION_RATE, FALSE, FALSE);
    WHEN 'ENPIUEX' THEN
        EXTRACT_ENPEX_CHARGE(p_STATEMENT_ID, p_CHARGE_ID, p_ENTITY_ID, p_CONVERSION_RATE, TRUE, FALSE);
    WHEN 'ENPIUGEX' THEN
        EXTRACT_ENPEX_CHARGE(p_STATEMENT_ID, p_CHARGE_ID, p_ENTITY_ID, p_CONVERSION_RATE, TRUE, TRUE);
    WHEN 'CONPEX' THEN
        EXTRACT_CONPEX_CHARGE(p_STATEMENT_ID, p_CHARGE_ID, p_ENTITY_ID, FALSE, FALSE);
    WHEN 'CONPIUEX' THEN
        EXTRACT_CONPEX_CHARGE(p_STATEMENT_ID, p_CHARGE_ID, p_ENTITY_ID, TRUE, FALSE);
    WHEN 'CONPIUGEX' THEN
        EXTRACT_CONPEX_CHARGE(p_STATEMENT_ID, p_CHARGE_ID, p_ENTITY_ID, TRUE, TRUE);
    WHEN 'UNIMPEX' THEN
        EXTRACT_UNIMPEX_CHARGE(p_STATEMENT_ID, p_CHARGE_ID, p_ENTITY_ID, p_CONVERSION_RATE);
     WHEN 'MWPEX' THEN
        EXTRACT_MWPEX_CHARGE(p_STATEMENT_ID, p_CHARGE_ID, p_ENTITY_ID, p_CONVERSION_RATE, FALSE, FALSE);
    WHEN 'MWPIUEX' THEN
        EXTRACT_MWPEX_CHARGE(p_STATEMENT_ID, p_CHARGE_ID, p_ENTITY_ID, p_CONVERSION_RATE, TRUE, FALSE);
    WHEN 'MWPIUGEX' THEN
        EXTRACT_MWPEX_CHARGE(p_STATEMENT_ID, p_CHARGE_ID, p_ENTITY_ID, p_CONVERSION_RATE, TRUE, TRUE);
    WHEN 'CC_PCPEX' THEN
        EXTRACT_CURRENCY_CHARGE(p_CHARGE_ID);
    WHEN 'CC_PENEX' THEN
        EXTRACT_CURRENCY_CHARGE(p_CHARGE_ID);
    WHEN 'INTEREST' THEN
        --EXTRACT_INTEREST_CHARGE(p_STATEMENT_ID, v_CHARGE_ID.CHARGE_ID);
        NULL;
    WHEN 'TCHAREX' THEN
        EXTRACT_TCHAREX_CHARGE(p_STATEMENT_ID, p_CHARGE_ID, p_ENTITY_ID);
    WHEN 'IPCC_PEN' THEN
        EXTRACT_BILL_PERIOD_CURR_COST(p_CHARGE_DATE, p_CHARGE_AMOUNT);
    ELSE
        NULL;
    END CASE;
END EXTRACT_CHARGE;
----------------------------------------------------------------------------------------
PROCEDURE EXTRACT_CHARGE_DETAILS
    (
    p_STATEMENT_ID IN NUMBER,
    p_ENTITY_ID IN NUMBER,
    p_STATEMENT_TYPE IN NUMBER,
    p_SETTLEMENT_DAY IN DATE,
	  p_LOGGER IN OUT MM_LOGGER_ADAPTER
    ) IS
v_EXT_IDENT EXTERNAL_SYSTEM_IDENTIFIER.EXTERNAL_IDENTIFIER%TYPE;
v_PSE_CURRENCY NUMBER;
v_CONVERSION_RATE CONVERSION_RATE_ARRAY;

CURSOR c_CHARGE_IDS IS
    SELECT COMPONENT_ID, CHARGE_ID
    FROM BILLING_STATEMENT
    WHERE ENTITY_ID = p_ENTITY_ID
    AND STATEMENT_TYPE = p_STATEMENT_TYPE
    AND STATEMENT_STATE = GA.EXTERNAL_STATE
    AND STATEMENT_DATE = p_SETTLEMENT_DAY;

BEGIN

    FOR v_CHARGE_ID IN c_CHARGE_IDS LOOP
		  v_EXT_IDENT := EI.GET_ENTITY_IDENTIFIER_EXTSYS(EC.ED_COMPONENT, v_CHARGE_ID.COMPONENT_ID,
                                        EC.ES_SEM, EI.g_DEFAULT_IDENTIFIER_TYPE, 1);

		  --Get the currency that was registered with that Participant (0 for Euro and 1 for GBP)
		  v_PSE_CURRENCY := MM_SEM_SHADOW_BILL.GET_CURRENCY(p_ENTITY_ID, p_SETTLEMENT_DAY);

		  --Get the exchange rate for the day if necessary
		  v_CONVERSION_RATE := DETERMINE_CONVERSION_RATE(v_PSE_CURRENCY, p_SETTLEMENT_DAY, p_LOGGER);

		  EXTRACT_CHARGE(v_EXT_IDENT, p_STATEMENT_ID, v_CHARGE_ID.CHARGE_ID, p_ENTITY_ID, v_PSE_CURRENCY, v_CONVERSION_RATE, NULL, NULL);

		  -- Fix quantity values in summary table now that they've been extracted from PIR
		  FIX_BILLING_STATEMENT_VALUES(v_CHARGE_ID.CHARGE_ID);
    END LOOP;

    COMMIT;

END EXTRACT_CHARGE_DETAILS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_SEM_STATEMENT_JOB
	(
	p_REC IN OUT SEM_STATEMENT_JOB%ROWTYPE
	) AS
BEGIN

	IF g_TRACE_ON THEN
		UT.DEBUG_TRACE('PUT_SEM_STATEMENT_JOB: ' ||
 			  TO_CHAR(p_REC.BILLING_ENTITY_ID) || ', ' ||
			  TO_CHAR(p_REC.STATEMENT_TYPE_ID) || ', ' ||
			  TO_CHAR(p_REC.STATEMENT_STATE) || ', ' ||
			  TO_CHAR(p_REC.STATEMENT_DATE) || ', ' ||
			  TO_CHAR(p_REC.AS_OF_DATE) || ', ' ||
			  TO_CHAR(p_REC.JOB_ID) || ', ' ||
			  TO_CHAR(p_REC.JOB_VERSION) || ', ' ||
			  TO_CHAR(p_REC.STATEMENT_NUMBER) || ', ' ||
			  TO_CHAR(p_REC.FILE_NUMBER));
	END IF;--IF g_TRACE_ON THEN

   MERGE INTO SEM_STATEMENT_JOB SSJ
      USING (SELECT p_REC.BILLING_ENTITY_ID AS BILLING_ENTITY_ID,
                    p_REC.STATEMENT_TYPE_ID AS STATEMENT_TYPE_ID,
                    p_REC.STATEMENT_STATE   AS STATEMENT_STATE,
                    p_REC.STATEMENT_DATE    AS STATEMENT_DATE,
                    p_REC.AS_OF_DATE        AS AS_OF_DATE,
                    p_REC.JOB_ID            AS JOB_ID,
                    p_REC.JOB_VERSION       AS JOB_VERSION,
                    p_REC.STATEMENT_NUMBER  AS STATEMENT_NUMBER,
                    p_REC.FILE_NUMBER       AS FILE_NUMBER
               FROM DUAL ) B
      ON (SSJ.BILLING_ENTITY_ID = B.BILLING_ENTITY_ID AND
          SSJ.STATEMENT_TYPE_ID = B.STATEMENT_TYPE_ID AND
          SSJ.STATEMENT_STATE   = B.STATEMENT_STATE   AND
          SSJ.STATEMENT_DATE    = B.STATEMENT_DATE    AND
          SSJ.AS_OF_DATE        = B.AS_OF_DATE		  AND
		  SSJ.JOB_ID			= B.JOB_ID)
    WHEN MATCHED THEN
       UPDATE SET SSJ.JOB_VERSION      = B.JOB_VERSION,
                  SSJ.STATEMENT_NUMBER = B.STATEMENT_NUMBER,
                  SSJ.FILE_NUMBER      = B.FILE_NUMBER
    WHEN NOT MATCHED THEN
       INSERT (SSJ.BILLING_ENTITY_ID,
               SSJ.STATEMENT_TYPE_ID,
               SSJ.STATEMENT_STATE,
               SSJ.STATEMENT_DATE,
               SSJ.AS_OF_DATE,
               SSJ.JOB_ID,
               SSJ.JOB_VERSION,
               SSJ.STATEMENT_NUMBER,
               SSJ.FILE_NUMBER)
       VALUES (B.BILLING_ENTITY_ID,
               B.STATEMENT_TYPE_ID,
               B.STATEMENT_STATE,
               B.STATEMENT_DATE,
               B.AS_OF_DATE,
               B.JOB_ID,
               B.JOB_VERSION,
               B.STATEMENT_NUMBER,
               B.FILE_NUMBER);

END PUT_SEM_STATEMENT_JOB;
-----------------------------------------------------------------------------------------
FUNCTION GET_BILLING_STATEMENT_NOTES
    (
    p_HEAD_REC IN SEM_STATEMENT_H_TEMP%ROWTYPE
    ) RETURN VARCHAR2 IS

    v_RESULT VARCHAR2(500);

BEGIN

    v_RESULT := 'Job ID: ' || TO_CHAR(p_HEAD_REC.JOB_ID) || '; ' ||
					'Job Version: ' || TO_CHAR(p_HEAD_REC.JOB_VERSION) || '; ' ||
					'Statement No: ' || TO_CHAR(p_HEAD_REC.STATEMENT_NO) || '; ' ||
					'File No: ' || TO_CHAR(p_HEAD_REC.FILE_NO) || '; ' ||
                    'Market Segment: ' || TO_CHAR(p_HEAD_REC.MKT_SEGMENT);

    RETURN v_RESULT;

END GET_BILLING_STATEMENT_NOTES;
-----------------------------------------------------------------------------------------
PROCEDURE IMPORT_STATEMENT_REPORT
	(
	p_REPORT IN CLOB,
	p_LOGGER IN OUT NOCOPY MM_LOGGER_ADAPTER,
	p_STATEMENT_TYPE IN NUMBER
	) IS
v_WORK_ID NUMBER;
v_H_REC SEM_STATEMENT_H_TEMP%ROWTYPE;
v_BS_REC BILLING_STATEMENT%ROWTYPE;
v_CHARGE_REC SEM_DETAIL_CHARGE%ROWTYPE;
v_ACCUM_AMT NUMBER;
v_ACCUM_QTY NUMBER;
v_PRIOR_CHARGE_ID NUMBER;
v_STATEMENT_ID SEM_MP_STATEMENT.STATEMENT_ID%TYPE;
v_PSE_CURRENCY NUMBER;
v_CONVERSION_RATE CONVERSION_RATE_ARRAY;
v_STMT_JOB_REC SEM_STATEMENT_JOB%ROWTYPE;
v_IMPORT_FILE_IDs	NUMBER_COLLECTION;
v_NOTES BILLING_STATEMENT_STATUS.NOTES%TYPE;

CURSOR c_S_RECs IS
	SELECT PRODUCT, PRODUCT_DESC, DELIVERY_DAY,
		UNIT, CURRENCY,
		SUM(TOTAL_QUANTITY) as TOTAL_QUANTITY,
		SUM(TOTAL_AMOUNT) as TOTAL_AMOUNT
	FROM SEM_STATEMENT_S_TEMP
	WHERE WORK_ID = v_WORK_ID
	GROUP BY PRODUCT, PRODUCT_DESC, DELIVERY_DAY,
		UNIT, CURRENCY;
CURSOR c_D_RECs(p_PRODUCT IN VARCHAR2) IS
	SELECT *
	FROM SEM_STATEMENT_D_TEMP
	WHERE WORK_ID = v_WORK_ID
		AND PRODUCT = p_PRODUCT;
BEGIN
	p_LOGGER.EXCHANGE_NAME := 'Import statement report';
	v_WORK_ID := MM_SEM_SETTLEMENT_PARSE.PARSE_STATEMENT_REPORT(p_REPORT, p_LOGGER);

	-- Get header record
	SELECT *
	INTO v_H_REC
	FROM SEM_STATEMENT_H_TEMP
	WHERE WORK_ID = v_WORK_ID;

	-- initialize values that are "hardwired" in charge components
	-- (this happens both here and in IMPORT_PARTICIPANT_INFO_REPORT)
	INIT_COMP_DET_CONSTANTS_CACHE(v_H_REC.SETTLEMENT_DAY);

    --Validate the settlement type code in the file name
    --with the settlement type code in the file content
    IF VALIDATE_STATEMENT_TYPE(p_STATEMENT_TYPE, v_H_REC.STATEMENT_TYPE, p_LOGGER) THEN
       v_BS_REC.STATEMENT_TYPE := p_STATEMENT_TYPE;
    ELSE
       v_BS_REC.STATEMENT_TYPE := MM_UTIL.DETERMINE_STATEMENT_TYPE(v_H_REC.STATEMENT_TYPE, NULL,
	   		EC.ES_SEM, MM_SEM_UTIL.g_STATEMENT_TYPE_SETTLEMENT);
    END IF;

	CHECK_MARKET_NAME(v_H_REC.MARKET, p_LOGGER);

	-- Use header record to populate fields in BILLING_STATEMENT
    v_BS_REC.ENTITY_ID := GET_ENTITY_ID(v_H_REC.PARTICIPANT,v_H_REC.MARKET);
	v_BS_REC.PRODUCT_ID := GET_PRODUCT_ID(v_H_REC.MKT_SEGMENT);
	v_BS_REC.STATEMENT_STATE := MM_SEM_UTIL.g_STATEMENT_STATE;
	v_BS_REC.STATEMENT_DATE := v_H_REC.SETTLEMENT_DAY;
	v_BS_REC.STATEMENT_END_DATE := v_BS_REC.STATEMENT_DATE;
	v_BS_REC.AS_OF_DATE := LOW_DATE;
	v_BS_REC.BASIS_AS_OF_DATE := LOW_DATE;
	v_BS_REC.CHARGE_INTERVAL := '30 Minute';
	v_BS_REC.ENTITY_TYPE := 'PSE';
	v_BS_REC.CHARGE_VIEW_TYPE := 'FORMULA';
	v_BS_REC.ENTRY_DATE := v_H_REC.REP_TIMESTAMP;

	-- Clear out the old records for this Product.
	DELETE BILLING_STATEMENT
	WHERE ENTITY_ID = v_BS_REC.ENTITY_ID
		AND PRODUCT_ID = v_BS_REC.PRODUCT_ID
		AND STATEMENT_TYPE = v_BS_REC.STATEMENT_TYPE
		AND STATEMENT_STATE = v_BS_REC.STATEMENT_STATE
		AND STATEMENT_DATE = v_BS_REC.STATEMENT_DATE;

	-- Loop through summary records
	FOR v_S_REC IN c_S_RECs LOOP

		-- Use summary record to populate remaining fields in BILLING_STATEMENT
        v_BS_REC.COMPONENT_ID := GET_COMPONENT_ID(v_S_REC.PRODUCT, v_S_REC.PRODUCT_DESC);

		v_BS_REC.CHARGE_QUANTITY := v_S_REC.TOTAL_QUANTITY;
		v_BS_REC.CHARGE_AMOUNT := v_S_REC.TOTAL_AMOUNT;
		v_BS_REC.CHARGE_RATE := CASE v_S_REC.TOTAL_QUANTITY
								WHEN 0 THEN NULL
								ELSE v_S_REC.TOTAL_AMOUNT / v_S_REC.TOTAL_QUANTITY
								END;
		PC.GET_CHARGE_ID(v_BS_REC);

		v_PRIOR_CHARGE_ID := PC.GET_PRIOR_CHARGE_ID(v_BS_REC);
		-- can't use the "standard" call to PC here, since we're dealing with externals
		PRIOR_BILLING_STATEMENT(v_PRIOR_CHARGE_ID, v_BS_REC, v_H_REC.MKT_SEGMENT);

		-- One row in BILLING_STATEMENT per summary row
		PC.PUT_BILLING_STATEMENT(v_BS_REC);

        v_NOTES := GET_BILLING_STATEMENT_NOTES(v_H_REC);

		-- Update the BILLING_STATEMENT_STATUS table
		UPDATE BILLING_STATEMENT_STATUS SET
			REVIEW_STATUS = g_IMPORTING_REVIEW_STATUS,
			ENTRY_DATE = SYSDATE,
			NOTES = v_NOTES
		WHERE ENTITY_ID = v_BS_REC.ENTITY_ID
			AND STATEMENT_TYPE = v_BS_REC.STATEMENT_TYPE
			AND STATEMENT_STATE = v_BS_REC.STATEMENT_STATE
			AND STATEMENT_DATE = v_BS_REC.STATEMENT_DATE
			AND AS_OF_DATE = v_BS_REC.AS_OF_DATE;

      -- Populate the SEM_STATEMENT_JOB table
      v_STMT_JOB_REC.BILLING_ENTITY_ID := v_BS_REC.ENTITY_ID;
      v_STMT_JOB_REC.STATEMENT_TYPE_ID := v_BS_REC.STATEMENT_TYPE;
      v_STMT_JOB_REC.STATEMENT_STATE   := v_BS_REC.STATEMENT_STATE;
      v_STMT_JOB_REC.STATEMENT_DATE    := v_BS_REC.STATEMENT_DATE;
      v_STMT_JOB_REC.AS_OF_DATE        := v_BS_REC.AS_OF_DATE;
      v_STMT_JOB_REC.JOB_ID            := v_H_REC.JOB_ID;
      v_STMT_JOB_REC.JOB_VERSION       := v_H_REC.JOB_VERSION;
      v_STMT_JOB_REC.STATEMENT_NUMBER  := v_H_REC.STATEMENT_NO;
      v_STMT_JOB_REC.FILE_NUMBER       := v_H_REC.FILE_NO;

      PUT_SEM_STATEMENT_JOB(v_STMT_JOB_REC);

		-- now get determinants from detail records and store to SEM_DETAIL_CHARGE
		v_ACCUM_AMT := 0;
		v_ACCUM_QTY := 0;
		v_CHARGE_REC.CHARGE_ID := v_BS_REC.CHARGE_ID;
		FOR v_D_REC IN c_D_RECs(v_S_REC.PRODUCT) LOOP
			v_CHARGE_REC.CHARGE_DATE := GET_SETTLEMENT_DATE(v_D_REC.OPERATION_DATE, v_D_REC.OPERATION_HOUR, v_D_REC.OPERATION_MIN, v_D_REC.RESOLUTION);
			v_CHARGE_REC.RESOLUTION := v_D_REC.RESOLUTION;
            v_CHARGE_REC.RESOURCE_NAME := v_D_REC.RESOURCE_NAME;
            v_CHARGE_REC.LOCATION_NAME := v_D_REC.LOCATION_NAME;
            v_CHARGE_REC.REC_ORDER := v_D_REC.REC_ORDER;
            v_CHARGE_REC.PAY_OR_CHARGE := v_D_REC.PAY_OR_CHARGE;
            v_CHARGE_REC.COMMENTS := v_D_REC.COMMENTS;
            v_CHARGE_REC.JURISDICTION := v_D_REC.JURISDICTION;
            v_CHARGE_REC.CONTRACT := v_D_REC.CONTRACT;
            v_CHARGE_REC.INTERCONNECTOR := v_D_REC.INTERCONNECTOR;
            v_CHARGE_REC.CHARGE_QUANTITY := v_D_REC.QUANTITY;
            v_CHARGE_REC.QUANTITY_UNIT := v_D_REC.UNIT;
            v_CHARGE_REC.CHARGE_AMOUNT := v_D_REC.AMOUNT;
            v_CHARGE_REC.AMOUNT_UNIT := v_D_REC.CURRENCY;

			v_ACCUM_AMT := v_ACCUM_AMT + v_D_REC.AMOUNT;
			v_ACCUM_QTY := v_ACCUM_QTY + v_D_REC.QUANTITY;

			PUT_DETAIL_CHARGE(v_CHARGE_REC);
		END LOOP;

		-- now validate totals
		IF v_ACCUM_AMT <> v_S_REC.TOTAL_AMOUNT THEN
	        p_LOGGER.LOG_WARN('Statement summary record for '||v_S_REC.PRODUCT||' indicates total amount of '||v_S_REC.TOTAL_AMOUNT||' but detail records indicate '||v_ACCUM_AMT);
		END IF;
		IF v_ACCUM_QTY <> v_S_REC.TOTAL_QUANTITY THEN
	        p_LOGGER.LOG_WARN('Statement summary record for '||v_S_REC.PRODUCT||' indicates total quantity of '||v_S_REC.TOTAL_QUANTITY||' but detail records indicate '||v_ACCUM_QTY);
		END IF;

        --extract charge details, if PIR imported
        BEGIN
            SELECT STATEMENT_ID
            INTO v_STATEMENT_ID
            FROM SEM_MP_STATEMENT
            WHERE ENTITY_ID = v_BS_REC.ENTITY_ID
            AND STATEMENT_TYPE = v_BS_REC.STATEMENT_TYPE
            AND STATEMENT_DATE = v_BS_REC.STATEMENT_DATE;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                v_STATEMENT_ID := 0;
        END;

		--Get the currency that was registered with that Participant (0 for Euro and 1 for GBP)
		v_PSE_CURRENCY := MM_SEM_SHADOW_BILL.GET_CURRENCY(v_BS_REC.ENTITY_ID, v_H_REC.SETTLEMENT_DAY);

		--Get the exchage rate for the day if necessary
		v_CONVERSION_RATE := DETERMINE_CONVERSION_RATE(v_PSE_CURRENCY, v_BS_REC.STATEMENT_DATE, p_LOGGER);

    IF v_STATEMENT_ID > 0 
       OR v_S_REC.PRODUCT IN('IPCC_PEN','FMOC_EX','FMOCIU_EX','FMOCIUG_EX','FMOCSUP_EX','FMOCGEN_EX') THEN

        EXTRACT_CHARGE(v_S_REC.PRODUCT, v_STATEMENT_ID, v_BS_REC.CHARGE_ID, v_BS_REC.ENTITY_ID, v_PSE_CURRENCY, v_CONVERSION_RATE, v_BS_REC.STATEMENT_DATE, v_BS_REC.CHARGE_AMOUNT);

        -- Fix quantity values in summary table now that they've been extracted from PIR
        FIX_BILLING_STATEMENT_VALUES(v_BS_REC.CHARGE_ID);
    END IF;
	END LOOP;

	-- Update amounts on the Tax Charge for this Product, only if it is before the cross border VAT
    -- switch
    IF NOT MM_SEM_UTIL.USING_CROSS_BORDER_VAT_FORMAT(v_H_REC.SETTLEMENT_DAY,v_BS_REC.ENTITY_ID) THEN

	    PUT_VAT_BLENDED_CHARGE(v_BS_REC.ENTITY_ID, v_BS_REC.STATEMENT_TYPE, v_BS_REC.STATEMENT_STATE,
		    v_BS_REC.STATEMENT_DATE, v_BS_REC.STATEMENT_END_DATE, v_BS_REC.PRODUCT_ID);

    END IF;

    -- Update the BILLING_STATEMENT_STATUS table
    UPDATE BILLING_STATEMENT_STATUS SET
        REVIEW_STATUS = g_IMPORTED_REVIEW_STATUS,
        ENTRY_DATE = SYSDATE
    WHERE ENTITY_ID = v_BS_REC.ENTITY_ID
        AND STATEMENT_TYPE = v_BS_REC.STATEMENT_TYPE
        AND STATEMENT_STATE = v_BS_REC.STATEMENT_STATE
        AND STATEMENT_DATE = v_BS_REC.STATEMENT_DATE
        AND AS_OF_DATE = v_BS_REC.AS_OF_DATE;

	-- 27.apr.2009, jbc: currency hasn't been specified in the statement since go-live;
	-- no need to try to do this or log these warnings
	/*
	IF v_UNIT_MISMATCH THEN
        p_LOGGER.LOG_WARN('Statement report specifies currency unit of '||
        	               v_STATEMENT_CURRENCY_UNIT||' but at least one line item indicated different unit.');
    END IF;
	*/

	CLEANUP_SETTLEMENT_WORK(v_WORK_ID);
	-- Done!

	SELECT IMPORT_FILE_ID
	BULK COLLECT INTO v_IMPORT_FILE_IDs
	FROM SEM_MP_INFO_FILES
	WHERE PARTICIPANT = v_H_REC.PARTICIPANT
		AND FILE_DATE = v_H_REC.SETTLEMENT_DAY
		AND MARKET = v_H_REC.MARKET
		AND JOB_VERSION = v_H_REC.JOB_VERSION
		AND JOB_ID = v_H_REC.JOB_ID;

	IF v_IMPORT_FILE_IDs.COUNT > 0 THEN
		DECLARE
			v_STATUS NUMBER;
			v_MESSAGE VARCHAR2(32767);
		BEGIN
			IMPORT_UNPROCESSED_PIRS(v_IMPORT_FILE_IDs, NULL, p_LOGGER.LOG_TYPE, p_LOGGER.TRACE_ON, v_STATUS, v_MESSAGE);
			IF v_STATUS <> GA.SUCCESS THEN
				p_LOGGER.LOG_ERROR('Processing of corresponding unprocessed PIRs failed: '||v_MESSAGE);
			END IF;
		END;
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		p_LOGGER.LOG_ERROR('Error importing statement report: '||MM_SEM_UTIL.ERROR_STACKTRACE);
		CLEANUP_SETTLEMENT_WORK(v_WORK_ID);
		RAISE;
END IMPORT_STATEMENT_REPORT;
----------------------------------------------------------------------------------------
PROCEDURE IMPORT_PARTICIPANT_INFO_REPORT
    (
	p_FILE_NAME      IN VARCHAR2,
	p_REPORT         IN CLOB,
	p_LOGGER         IN OUT NOCOPY MM_LOGGER_ADAPTER,
	p_STATEMENT_TYPE IN NUMBER,
	p_FORCE			 IN BOOLEAN := FALSE
    ) IS

v_WORK_ID        NUMBER;
v_H_REC          SEM_MP_INFO_H_TEMP%ROWTYPE;
v_REC            SEM_MP_INFO%ROWTYPE;
v_STATEMENT_TYPE NUMBER;
v_ENTITY_ID      NUMBER;
v_FILE_REC       SEM_MP_INFO_FILES%ROWTYPE;

CURSOR C_D_RECS IS
SELECT * FROM SEM_MP_INFO_D_TEMP WHERE WORK_ID = v_WORK_ID;
BEGIN
	p_LOGGER.EXCHANGE_NAME := 'Import participant info report';
	v_WORK_ID := MM_SEM_SETTLEMENT_PARSE.PARSE_PARTICIPANT_INFO_REPORT(p_REPORT, p_LOGGER);

	SELECT * INTO v_H_REC FROM SEM_MP_INFO_H_TEMP WHERE WORK_ID = v_WORK_ID;

	-- Check to see if the statement record has been loaded.
	-- Returns a boolean value:
	--    true  = settlement statement loaded
	--    false = no associated settlement statement.

	CHECK_IF_STATEMENT_LOADED(p_REPORT, p_FILE_NAME, v_H_REC.PARTICIPANT, v_H_REC.SETTLEMENT_DAY, v_WORK_ID, v_ENTITY_ID, v_STATEMENT_TYPE, v_FILE_REC);

	IF p_FORCE THEN
		v_STATEMENT_TYPE := p_STATEMENT_TYPE;
	END IF;

	-- no statement type for importing PIR? don't process it
	IF v_STATEMENT_TYPE IS NULL THEN

		MM_SEM_SETTLEMENT_PARSE.INS_SEM_MP_INFO_FILES(p_REC => v_FILE_REC);

	ELSE
		-- Settlement statement was found.
		-- initialize values that are "hardwired" in charge components
		-- (this happens both here and in IMPORT_STATEMENT_REPORT)
		INIT_COMP_DET_CONSTANTS_CACHE(v_H_REC.SETTLEMENT_DAY);

		-- delete existing record - foreign keys will cause cascading delete
		-- to cleanup SEM_MP_INFO
		DELETE SEM_MP_STATEMENT
		WHERE ENTITY_ID = v_ENTITY_ID
			  AND STATEMENT_TYPE = v_STATEMENT_TYPE
			  AND STATEMENT_DATE = v_H_REC.SETTLEMENT_DAY;
		-- create new record
		SELECT BID.NEXTVAL INTO v_REC.STATEMENT_ID FROM DUAL;
		INSERT INTO SEM_MP_STATEMENT
			(STATEMENT_ID, ENTITY_ID, STATEMENT_TYPE, STATEMENT_DATE, ENTRY_DATE)
		VALUES
			(v_REC.STATEMENT_ID, v_ENTITY_ID, v_STATEMENT_TYPE, v_H_REC.SETTLEMENT_DAY, v_H_REC.REP_TIMESTAMP);

		-- Then import detail records into SEM_MP_INFO
		FOR v_D_REC IN C_D_RECS LOOP

			v_REC.RESOLUTION := v_D_REC.RESOLUTION;
			v_REC.RESOURCE_NAME := v_D_REC.RESOURCE_NAME;
			v_REC.LOCATION_NAME := v_D_REC.LOCATION_NAME;

			-- need to always convert variable type ND to NDLF
			IF v_D_REC.VARIABLE_TYPE = 'ND' THEN
				v_REC.VARIABLE_TYPE := 'NDLF';
			ELSE
				v_REC.VARIABLE_TYPE := v_D_REC.VARIABLE_TYPE;
			END IF;

			v_REC.VARIABLE_NAME := v_D_REC.VARIABLE_NAME;
			v_REC.CONTRACT := v_D_REC.CONTRACT;
			v_REC.UNIT := v_D_REC.UNIT;
			-- half-hourly data? then insert two records - one for each 30-minute interval in the hour
			IF v_REC.RESOLUTION = G_RES_30_MIN THEN
				-- first 30-minute interval
				v_REC.CHARGE_DATE := MM_SEM_UTIL.GET_SCHEDULE_DATE(v_D_REC.DELIVERY_DATE, v_D_REC.DELIVERY_HOUR, 1);
				v_REC.VALUE := v_D_REC.VALUE1;

				INSERT INTO SEM_MP_INFO VALUES v_REC;

				-- second 30-minute interval
				v_REC.CHARGE_DATE := MM_SEM_UTIL.GET_SCHEDULE_DATE(v_D_REC.DELIVERY_DATE, v_D_REC.DELIVERY_HOUR, 2);
				v_REC.VALUE := v_D_REC.VALUE2;

				INSERT INTO SEM_MP_INFO VALUES v_REC;
			ELSE
				-- hourly or greater interval? then pass hour as zero
				IF v_D_REC.RESOLUTION > G_RES_HOUR THEN
					v_REC.CHARGE_DATE := MM_SEM_UTIL.GET_SCHEDULE_DATE(v_D_REC.DELIVERY_DATE, 0, 0);
				ELSE
					v_REC.CHARGE_DATE := MM_SEM_UTIL.GET_SCHEDULE_DATE(v_D_REC.DELIVERY_DATE, v_D_REC.DELIVERY_HOUR, 0);
				END IF;

				v_REC.VALUE := v_D_REC.VALUE1;

				INSERT INTO SEM_MP_INFO VALUES v_REC;
			END IF;

		END LOOP;

		EXTRACT_SETTL_DETERMINANTS(v_REC.STATEMENT_ID);

		EXTRACT_CHARGE_DETAILS(v_REC.STATEMENT_ID, v_ENTITY_ID, v_STATEMENT_TYPE, v_H_REC.SETTLEMENT_DAY, p_LOGGER);

	END IF;

	CLEANUP_SETTLEMENT_WORK(v_WORK_ID);
	-- Done!

EXCEPTION
	WHEN OTHERS THEN
		p_LOGGER.LOG_ERROR('Error importing participant info report: ' || MM_SEM_UTIL.ERROR_STACKTRACE);
		CLEANUP_SETTLEMENT_WORK(v_WORK_ID);
		RAISE;
END IMPORT_PARTICIPANT_INFO_REPORT;
----------------------------------------------------------------------------------------
FUNCTION CONVERT_SRA_AMOUNT
	(
	p_AMOUNT IN NUMBER,
	p_FROM_PARTICIPANT_NAME IN VARCHAR2,
	p_TO_PARTICIPANT_NAME IN VARCHAR2,
	p_DATE IN DATE,
	p_TRADING_DAY IN DATE,
	p_LOGGER IN OUT NOCOPY MM_LOGGER_ADAPTER
	) RETURN NUMBER IS
v_FROM_PSE_ID NUMBER(9) := MM_SEM_UTIL.GET_PSE_ID(p_FROM_PARTICIPANT_NAME, TRUE);
v_TO_PSE_ID NUMBER(9) := MM_SEM_UTIL.GET_PSE_ID(p_TO_PARTICIPANT_NAME, TRUE);
v_FROM_CURRENCY NUMBER(1) := MM_SEM_SHADOW_BILL.GET_CURRENCY(v_FROM_PSE_ID, p_DATE, 1);
v_TO_CURRENCY NUMBER(1) := MM_SEM_SHADOW_BILL.GET_CURRENCY(v_TO_PSE_ID, p_DATE, 1);
BEGIN
	IF v_FROM_CURRENCY = v_TO_CURRENCY THEN
		-- nothing to convert
		RETURN p_AMOUNT;
	ELSE
		RETURN p_AMOUNT * NVL(FETCH_CONVERSION_RATE(p_TRADING_DAY, p_LOGGER, v_FROM_CURRENCY=0),1);
	END IF;
END CONVERT_SRA_AMOUNT;
----------------------------------------------------------------------------------------
PROCEDURE IMPORT_REALLOCATION_REPORT
	(
	p_FILE_NAME IN VARCHAR2,
	p_REPORT IN CLOB,
	p_LOGGER IN OUT NOCOPY MM_LOGGER_ADAPTER,
	p_STATEMENT_TYPE IN NUMBER
	) IS
v_WORK_ID NUMBER;
v_H_REC SEM_SRA_H_TEMP%ROWTYPE;
v_REC SEM_SRA%ROWTYPE;
v_MKT VARCHAR2(8);

v_COMMODITY_ID NUMBER(9);
v_TXN_ID NUMBER := NULL;
v_CUR_TRADING_DAY DATE;
v_PREV_TRADING_DAY DATE := LOW_DATE;
v_START_HR NUMBER;
v_START_INT NUMBER;
v_AMOUNT NUMBER;
v_TOTAL_SRAs NUMBER := 0;
v_SRA_IS_REJECTED_VAL NUMBER;
v_BS_REC BILLING_STATEMENT%ROWTYPE;
v_COMPONENT_ID NUMBER(9);
v_PRODUCT_ID   NUMBER(9);
v_FORMULA_CHARGE      FORMULA_CHARGE%ROWTYPE;
v_FORMULA_CHARGE_VAR  FORMULA_CHARGE_VARIABLE%ROWTYPE;
v_ITERATOR_NAME       FORMULA_CHARGE_ITERATOR_NAME%ROWTYPE;
v_ITERATOR            FORMULA_CHARGE_ITERATOR%ROWTYPE;
v_ITERATOR_NAMES	  CALC_ENGINE.ITERATOR_VALS := CALC_ENGINE.ITERATOR_VALS(NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
v_ITERATOR_VALS		  CALC_ENGINE.ITERATOR_VALS := CALC_ENGINE.ITERATOR_VALS(NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);

CURSOR c_D_RECS IS
	SELECT *
	FROM SEM_SRA_D_TEMP
	WHERE WORK_ID = v_WORK_ID
	ORDER BY TRADING_INTERVAL;
BEGIN
	p_LOGGER.EXCHANGE_NAME := 'Import reallocation agreements report';
	v_WORK_ID := MM_SEM_SETTLEMENT_PARSE.PARSE_REALLOCATION_REPORT(p_REPORT, p_LOGGER);

	BEGIN
		v_MKT := GET_MARKET_FROM_FILE_NAME(p_FILE_NAME, 'RAR', STRING_COLLECTION(g_ENERGY_MARKET_NAME,g_CAPACITY_MARKET_NAME));
	EXCEPTION
		WHEN x_INVALID_FILENAME THEN
			-- for now, default to Energy if a file is uploaded from which
			-- the market cannot be deciphered
			v_MKT := g_ENERGY_MARKET_NAME;
	END;

	-- Get header record
	SELECT *
	INTO v_H_REC
	FROM SEM_SRA_H_TEMP
	WHERE WORK_ID = v_WORK_ID;

    --Validate the settlement type code in the file name
    --with the settlement type code in the file content
    IF VALIDATE_STATEMENT_TYPE(p_STATEMENT_TYPE, v_H_REC.STATEMENT_TYPE, p_LOGGER) THEN
       v_REC.STATEMENT_TYPE := p_STATEMENT_TYPE;
    ELSE
       v_REC.STATEMENT_TYPE := MM_UTIL.DETERMINE_STATEMENT_TYPE(v_H_REC.STATEMENT_TYPE,
	   								NULL, EC.ES_SEM, MM_SEM_UTIL.g_STATEMENT_TYPE_SETTLEMENT);
    END IF;

	v_REC.ENTITY_ID := GET_ENTITY_ID(v_H_REC.PARTICIPANT,v_MKT);
    v_REC.BEGIN_DATE := v_H_REC.BEGIN_DATE;
    v_REC.END_DATE := v_H_REC.END_DATE;

	DELETE SEM_SRA WHERE ENTITY_ID = v_REC.ENTITY_ID
					AND STATEMENT_TYPE = v_REC.STATEMENT_TYPE
					AND BEGIN_DATE = v_REC.BEGIN_DATE;

	-- Find the Product/Component ID of the REALLOC Charge.
	v_COMPONENT_ID := GET_COMPONENT_ID('REALLOC', 'REALLOC Charge Component generated by MarketManager');
	BEGIN
		SELECT PRODUCT_ID INTO v_PRODUCT_ID
		FROM PRODUCT_COMPONENT
		WHERE COMPONENT_ID = v_COMPONENT_ID
			AND v_REC.END_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE, v_REC.END_DATE);
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			MM_SEM_UTIL.RAISE_ERR(-20000, 'REALLOC Component does not exist, or is missing a Product association in the PRODUCT_COMPONENT table for ' || TO_CHAR(v_REC.END_DATE, 'YYYY-MM-DD') || '.');
		WHEN TOO_MANY_ROWS THEN
			MM_SEM_UTIL.RAISE_ERR(-20000, 'REALLOC Component has multiple Product associations in the PRODUCT_COMPONENT table for ' || TO_CHAR(v_REC.END_DATE, 'YYYY-MM-DD') || '.');
	END;

	BEGIN
		SELECT *
		INTO v_BS_REC
		FROM BILLING_STATEMENT
		WHERE ENTITY_ID = v_REC.ENTITY_ID
			AND PRODUCT_ID = v_PRODUCT_ID
			AND COMPONENT_ID = v_COMPONENT_ID
			AND STATEMENT_TYPE = v_REC.STATEMENT_TYPE
			AND STATEMENT_STATE = MM_SEM_UTIL.g_STATEMENT_STATE
			AND STATEMENT_DATE = v_REC.END_DATE
			AND AS_OF_DATE = LOW_DATE;

		-- If we found a charge ID, delete any existing detail rows for this product.
		DELETE FORMULA_CHARGE_ITERATOR A
         WHERE CHARGE_ID = v_BS_REC.CHARGE_ID;

        DELETE FORMULA_CHARGE A
         WHERE CHARGE_ID = v_BS_REC.CHARGE_ID;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			-- Add a Billing Statement record for the REALLOC component.
			v_BS_REC.ENTITY_ID := v_REC.ENTITY_ID;
			v_BS_REC.PRODUCT_ID := v_PRODUCT_ID;
			v_BS_REC.COMPONENT_ID := v_COMPONENT_ID;
			v_BS_REC.STATEMENT_TYPE := v_REC.STATEMENT_TYPE;
			v_BS_REC.STATEMENT_STATE := MM_SEM_UTIL.g_STATEMENT_STATE;
			v_BS_REC.STATEMENT_DATE := v_REC.END_DATE;
			v_BS_REC.STATEMENT_END_DATE := CASE v_MKT
											WHEN g_ENERGY_MARKET_NAME THEN
												v_BS_REC.STATEMENT_DATE
											ELSE
												LAST_DAY(TRUNC(v_BS_REC.STATEMENT_DATE, 'MM'))
										   END;
			v_BS_REC.AS_OF_DATE := LOW_DATE;
			v_BS_REC.BASIS_AS_OF_DATE := LOW_DATE;
			v_BS_REC.CHARGE_INTERVAL := 'Day';
			v_BS_REC.ENTITY_TYPE := 'PSE';
			v_BS_REC.CHARGE_VIEW_TYPE := 'FORMULA';

			SELECT BID.NEXTVAL INTO v_BS_REC.CHARGE_ID FROM DUAL;

			-- Insert the initial billing statement record.
			PC.PUT_BILLING_STATEMENT(v_BS_REC);
	END;

	v_ITERATOR_NAME.CHARGE_ID := v_BS_REC.CHARGE_ID;
	v_ITERATOR.CHARGE_ID := v_BS_REC.CHARGE_ID;
	v_FORMULA_CHARGE.CHARGE_ID := v_BS_REC.CHARGE_ID;
	v_FORMULA_CHARGE.CHARGE_DATE := v_REC.END_DATE;
	v_FORMULA_CHARGE_VAR.CHARGE_ID := v_BS_REC.CHARGE_ID;

	-- Row type of table FORMULA_CHARGE.
	v_ITERATOR_NAME.ITERATOR_NAME1 := 'Start Time';
	v_ITERATOR_NAME.ITERATOR_NAME2 := 'Counterparty';
	v_ITERATOR_NAME.ITERATOR_NAME3 := 'Agreement Name';
	v_ITERATOR_NAME.ITERATOR_NAME4 := NULL;
	v_ITERATOR_NAME.ITERATOR_NAME5 := NULL;
	PC.PUT_FORMULA_ITERATOR_NAMES(v_ITERATOR_NAME);

	-- Collection of Iterator Names.
	v_ITERATOR_NAMES(1)  := v_ITERATOR_NAME.ITERATOR_NAME1;
	v_ITERATOR_NAMES(2)  := v_ITERATOR_NAME.ITERATOR_NAME2;
	v_ITERATOR_NAMES(3)  := v_ITERATOR_NAME.ITERATOR_NAME3;

	-- Get detail records - use info from header and detail record to
	-- create entries into SEM_SRA table
	FOR v_D_REC IN c_D_RECS LOOP
        v_REC.AGREEMENT_NAME := v_D_REC.REALLOCATION_NAME;
		v_REC.COUNTERPARTY_ID := MM_SEM_UTIL.GET_PSE_ID(v_D_REC.COUNTERPARTY, TRUE);
        v_REC.CHARGE_DATE := TO_CUT(TRUNC(v_D_REC.TRADING_INTERVAL,'MI'), MM_SEM_UTIL.g_TZ) + v_D_REC.DST_FLAG/24;
	    v_REC.UNIT := v_D_REC.UNIT;

		--v_REC.IS_VALID := CASE WHEN v_D_REC.VALIDITY = 'Y' THEN 1 ELSE 0 END;
		CASE v_D_REC.VALIDITY
		 WHEN 'Y' THEN
		 	v_REC.IS_VALID := 1;
			v_SRA_IS_REJECTED_VAL := 0;
		 ELSE
		 	v_REC.IS_VALID := 0;
			v_SRA_IS_REJECTED_VAL := 1;
	    END CASE;

        v_REC.REASON_INVALID := v_D_REC.REASON;
        v_REC.ENTRY_DATE := v_H_REC.REP_TIMESTAMP;
		-- charge date is stored interval-beginning: add 30 minutes to get interval-ending
		v_CUR_TRADING_DAY := MM_SEM_UTIL.GET_TRADING_DAY(v_REC.CHARGE_DATE+1/48);
		IF v_CUR_TRADING_DAY <> v_PREV_TRADING_DAY THEN
			-- Reset SRA package each trading day - usually MM_SEM_SRA.GET_TRANSACTION_ID
			-- (called below) will never return the same transaction ID in two different
			-- calls. But resetting the package, allows transaction IDs to be re-used from
			-- one day to the next
			MM_SEM_SRA_OFFER.RESET_FOR_PARSE;
			v_PREV_TRADING_DAY := v_CUR_TRADING_DAY;
		END IF;

		-- The most important field:
		v_REC.SRA_AMOUNT := v_D_REC.AMOUNT;

		-- Insert this record
		INSERT INTO SEM_SRA VALUES v_REC;

		---------------------------------
		--Import the SRA
		---------------------------------
		v_COMMODITY_ID := EI.GET_ID_FROM_ALIAS(CASE WHEN v_MKT = g_ENERGY_MARKET_NAME THEN g_ENERGY_ALIAS ELSE g_CAPACITY_ALIAS END,
        								       EC.ED_IT_COMMODITY);
		-- charge date is stored interval-beginning: add 30 minutes to get interval-ending
		v_START_HR := MM_SEM_UTIL.GET_HOUR_FROM_DATE(v_REC.CHARGE_DATE+1/48);
		v_START_INT := MM_SEM_UTIL.GET_INTERVAL_FROM_DATE(v_REC.CHARGE_DATE+1/48);
		-- use the sign of the SRA to determine direction (whether current participant is credited vs. debited party
	   	IF v_D_REC.AMOUNT > 0 THEN
			-- positive amount indicates participant is the debited party - which means the participant is the seller and submitting account
			v_AMOUNT := v_REC.SRA_AMOUNT; -- we already converted this value to participant's currency
			v_TXN_ID := MM_SEM_SRA_OFFER.GET_TRANSACTION_ID(v_CUR_TRADING_DAY,
        											v_START_HR,
        											v_START_INT,
        											v_D_REC.COUNTERPARTY, --PURCHASER_NAME
        											v_COMMODITY_ID,
        											v_D_REC.REALLOCATION_NAME, --AGREEMENT_NAME
        											v_H_REC.PARTICIPANT, --ACCOUNT_NAME
         											v_AMOUNT);
		ELSE
			-- negative amount indicates participant is the credited party - which means the participant is the purchaser
			-- convert to counter-party's currency
			v_AMOUNT := -CONVERT_SRA_AMOUNT(v_D_REC.AMOUNT,
											v_H_REC.PARTICIPANT,
											v_D_REC.COUNTERPARTY,
											TRUNC(v_D_REC.TRADING_INTERVAL-1/86400),
											v_CUR_TRADING_DAY,
											p_LOGGER);
			v_TXN_ID := MM_SEM_SRA_OFFER.GET_TRANSACTION_ID(v_CUR_TRADING_DAY,
        											v_START_HR,
        											v_START_INT,
        											v_H_REC.PARTICIPANT, --PURCHASER_NAME
        											v_COMMODITY_ID,
        											v_D_REC.REALLOCATION_NAME, --AGREEMENT_NAME
        											v_D_REC.COUNTERPARTY, --ACCOUNT_NAME
        											v_AMOUNT);
	   END IF;

	   IF v_TXN_ID <= 0 THEN
	   		p_LOGGER.LOG_ERROR('Failed to determine Transaction ID for SRA ('||v_D_REC.AMOUNT||' for '||v_MKT||': '||v_D_REC.REALLOCATION_NAME||'@'||v_D_REC.COUNTERPARTY||')');
	   ELSE
	   		MM_SEM_SRA_OFFER.IMPORT_SRA(v_TXN_ID,
										v_CUR_TRADING_DAY,
        								v_START_HR,
        								v_START_INT,
										NULL, -- Ext ID - we don't have it in this file
										v_AMOUNT,
										MM_SEM_UTIL.g_TI_SRA_VAL_STAT_REJECTED,
										v_SRA_IS_REJECTED_VAL,
										p_LOGGER);
       END IF;

	   IF v_REC.IS_VALID = 1 THEN
	   	   -- track total SRAs to put into charge amount field of
		   -- BILLING_STATEMENT summary record
		   v_TOTAL_SRAs := v_TOTAL_SRAs+v_REC.SRA_AMOUNT;

	   ---------------------------------
	   --Populate FORMULA_CHARGE* tables
	   ---------------------------------

		-- Row type of table FORMULA_CHARGE_ITERATOR.
		v_ITERATOR.ITERATOR1 := TRIM(SUBSTR(FROM_CUT_AS_HED(v_REC.CHARGE_DATE, MM_SEM_UTIL.g_TZ, 'MI30'),12));
		v_ITERATOR.ITERATOR2 := EI.GET_ENTITY_NAME(EC.ED_PSE, v_REC.COUNTERPARTY_ID);
		v_ITERATOR.ITERATOR3 := v_REC.AGREEMENT_NAME;
		v_ITERATOR.ITERATOR4 := NULL;
		v_ITERATOR.ITERATOR5 := NULL;

		-- Collection of Iterator Values.
		v_ITERATOR_VALS(1)  := v_ITERATOR.ITERATOR1;
		v_ITERATOR_VALS(2)  := v_ITERATOR.ITERATOR2;
		v_ITERATOR_VALS(3)  := v_ITERATOR.ITERATOR3;

		-- Get the Iterator ID. If a row already exists, get that ID. Else create a new one.
	   	CALC_ENGINE.GET_FORMULA_CHARGE_ITERATOR_ID(v_ITERATOR_NAME.CHARGE_ID, v_ITERATOR_NAMES, v_ITERATOR_VALS, v_ITERATOR.ITERATOR_ID);

		v_FORMULA_CHARGE.ITERATOR_ID := v_ITERATOR.ITERATOR_ID;

		v_FORMULA_CHARGE_VAR.ITERATOR_ID := v_ITERATOR.ITERATOR_ID;
        v_FORMULA_CHARGE_VAR.CHARGE_DATE := v_BS_REC.STATEMENT_DATE + 1/86400;

		v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'MonetaryValue';
		-- Negate value since statements use opposite sign convention of invoices
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := -v_REC.SRA_AMOUNT;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

		v_FORMULA_CHARGE_VAR.VARIABLE_NAME := 'IsValid';
        v_FORMULA_CHARGE_VAR.VARIABLE_VAL := v_REC.IS_VALID;
        PC.PUT_FORMULA_CHARGE_VAR(v_FORMULA_CHARGE_VAR);

		--LD - BZ 15808: The details screen needs should show the charge_date of all agreements
    --               and not the statement date
    v_FORMULA_CHARGE.CHARGE_DATE := v_REC.CHARGE_DATE;
        v_FORMULA_CHARGE.CHARGE_QUANTITY := 1;
        v_FORMULA_CHARGE.CHARGE_RATE := -v_REC.SRA_AMOUNT;
        v_FORMULA_CHARGE.CHARGE_AMOUNT := -v_REC.SRA_AMOUNT;
        PC.PUT_FORMULA_CHARGE(v_FORMULA_CHARGE);
     END IF;
  END LOOP;

  v_BS_REC.CHARGE_RATE := 1;
  -- Negate value since statements use opposite sign convention of invoices
  v_BS_REC.CHARGE_QUANTITY := -v_TOTAL_SRAs;
  v_BS_REC.BILL_QUANTITY := -v_TOTAL_SRAs;
  v_BS_REC.CHARGE_AMOUNT := -v_TOTAL_SRAs;
  v_BS_REC.BILL_AMOUNT := -v_TOTAL_SRAs;
  -- Update this record with the total amount
  PC.PUT_BILLING_STATEMENT(v_BS_REC);

  CLEANUP_SETTLEMENT_WORK(v_WORK_ID);
  -- Done!

EXCEPTION
  WHEN OTHERS THEN
    p_LOGGER.LOG_ERROR('Error importing reallocation agreements report: '||MM_SEM_UTIL.ERROR_STACKTRACE);
    CLEANUP_SETTLEMENT_WORK(v_WORK_ID);
    RAISE;
END IMPORT_REALLOCATION_REPORT;
----------------------------------------------------------------------------------------
PROCEDURE IMPORT_CANCELLED_SRA_REPORT
(
  p_FILE_NAME IN VARCHAR2,
  p_REPORT IN CLOB,
  p_LOGGER IN OUT NOCOPY MM_LOGGER_ADAPTER
)IS
  v_LINES PARSE_UTIL.BIG_STRING_TABLE_MP;
  c_COMMA CONSTANT VARCHAR2(1) := ',';
  v_COLUMNS PARSE_UTIL.STRING_TABLE;
  c_TIMESTAMP_FORMAT   CONSTANT VARCHAR2(24) := 'YYYY-MM-DD HH24:MI:SS';
  c_DATE_FORMAT     CONSTANT VARCHAR2(24) := 'YYYY-MM-DD';
  v_FILE_ID NUMBER;
  v_DELIVERY_DATE DATE;
  TYPE t_MARKET_TYPE IS TABLE OF VARCHAR2(32) INDEX BY VARCHAR2(1);
  v_MARKET_TYPE t_MARKET_TYPE;
  v_TXN_ID INTERCHANGE_TRANSACTION.TRANSACTION_ID%TYPE;
  v_LOGGER MM_LOGGER_ADAPTER;
  v_PREV_DELIVERY_DATE DATE := CONSTANTS.LOW_DATE;
BEGIN
  -- Load the market type for lookup -- currently only ENERGY and CAPACITY
  v_MARKET_TYPE('E') := 'Energy';
  v_MARKET_TYPE('C') := 'Capacity';

  -- Load CSV contents into a string map
  PARSE_UTIL.PARSE_CLOB_INTO_LINES(p_REPORT, v_LINES);

  -- Does the file have at least one line?
  FOR I IN 1..v_LINES.COUNT LOOP
    -- Tokenize each row
    PARSE_UTIL.TOKENS_FROM_STRING(v_LINES(I), c_COMMA, v_COLUMNS);

    -- if it is header row
    IF v_COLUMNS(1) = 'H' THEN
      BEGIN
        -- Get the FILE_ID if the data already exists and this processing is actually an update to old data
        SELECT A.FILE_ID
        INTO v_FILE_ID
        FROM SEM_CANCELLED_SRA_HEADER A
        WHERE A.CODE_PARTICIPANT_CID = v_COLUMNS(5)
        AND   A.TRANSACTION_CID = v_COLUMNS(6);
      EXCEPTION
        -- if this is fresh data being processed, then generate the next ID for the FILE_ID using the sequence
        WHEN NO_DATA_FOUND THEN
          SELECT SEM_CANCELLED_SRA_SEQ.NEXTVAL
          INTO v_FILE_ID
          FROM DUAL;
      END;

      -- Now merge the HEADER data
      MERGE INTO SEM_CANCELLED_SRA_HEADER A
      USING (SELECT v_FILE_ID    "FILE_ID",
              v_COLUMNS(1) "RECORD_TYPE",
              v_COLUMNS(2) "VERSION",
              v_COLUMNS(3) "MARKET_OPERATOR",
              TO_DATE(v_COLUMNS(4), c_TIMESTAMP_FORMAT) "RECORD_TIMESTAMP",
              v_COLUMNS(5) "CODE_PARTICIPANT_CID",
              TO_NUMBER(v_COLUMNS(6)) "TRANSACTION_CID"
           FROM DUAL) B
      ON (A.FILE_ID = B.FILE_ID)
      WHEN MATCHED THEN
        UPDATE SET A.RECORD_TYPE      = B.RECORD_TYPE,
               A.VERSION        = B.VERSION,
               A.MARKET_OPERATOR  = B.MARKET_OPERATOR,
               A.RECORD_TIMESTAMP = B.RECORD_TIMESTAMP
      WHEN NOT MATCHED THEN
        INSERT (A.FILE_ID,
            A.RECORD_TYPE,
            A.VERSION,
            A.MARKET_OPERATOR,
            A.RECORD_TIMESTAMP,
            A.CODE_PARTICIPANT_CID,
            A.TRANSACTION_CID
            )
        VALUES(B.FILE_ID,
             B.RECORD_TYPE,
             B.VERSION,
             B.MARKET_OPERATOR,
             B.RECORD_TIMESTAMP,
             B.CODE_PARTICIPANT_CID,
             B.TRANSACTION_CID
        );
    -- Now merge the DETAIL data
    ELSIF v_COLUMNS(1) = 'D' THEN
      IF I = 2 THEN -- Per MPUD, this file will always have 1 HEADER record and 1 OR MORE DETAIL records
        -- First delete any existing records here so that it is clean-slate (tabula rasa)
        DELETE FROM SEM_CANCELLED_SRA_DETAIL A
        WHERE A.FILE_ID = v_FILE_ID;
      END IF;

      -- Get the DELIVERY_DATE as-is from the raw file import
      v_DELIVERY_DATE := TO_DATE(v_COLUMNS(5), c_DATE_FORMAT);

      INSERT INTO SEM_CANCELLED_SRA_DETAIL A (
          A.FILE_ID,
          A.RECORD_TYPE,
          A.PARTICIPANT_NAME,
          A.PARTICIPANT_NAME_CREDIT,
          A.REALLOC_TYPE,
          A.DELIVERY_DATE,
          A.DELIVERY_HOUR,
          A.DELIVERY_INTERVAL,
          A.MONETARY_VALUE,
          A.REALLOC_AGREEMENT_NAME,
          A.CANCEL_FLAG
          )
      VALUES( v_FILE_ID,
          v_COLUMNS(1),
          v_COLUMNS(2),
          v_COLUMNS(3),
          v_COLUMNS(4),
          v_DELIVERY_DATE,
          TO_NUMBER(v_COLUMNS(6)),
          TO_NUMBER(v_COLUMNS(7)),
          v_COLUMNS(8),
          v_COLUMNS(9),
          v_COLUMNS(10)
      );

      -- VERY IMPORTANT: This functionality is commented out until further clarification is obtained from the market.
      BEGIN
        -- Reset SRA package each trading day - usually MM_SEM_SRA.GET_TRANSACTION_ID
        -- (called below) will never return the same transaction ID in two different
        -- calls. But resetting the package, allows transaction IDs to be re-used from
        -- one day to the next
        IF v_DELIVERY_DATE <> v_PREV_DELIVERY_DATE THEN
          MM_SEM_SRA_OFFER.RESET_FOR_PARSE;
          v_PREV_DELIVERY_DATE := v_DELIVERY_DATE;
        END IF;

        -- This is where the SRA transactions must be reconciled with
        v_TXN_ID := MM_SEM_SRA_OFFER.GET_TRANSACTION_ID(v_DELIVERY_DATE,    -- Assumption: This is TRADING_DAY
                          TO_NUMBER(v_COLUMNS(6)),    -- Start Hour
                          TO_NUMBER(v_COLUMNS(7)),    -- Start Int
                          v_COLUMNS(3),
                          EI.GET_ID_FROM_NAME(v_MARKET_TYPE(UPPER(v_COLUMNS(4))), EC.ED_IT_COMMODITY),
                          v_COLUMNS(9),
                          v_COLUMNS(2),
                          TO_NUMBER(v_COLUMNS(8))
                           );
        -- Import SRA
        MM_SEM_SRA_OFFER.IMPORT_SRA(v_TXN_ID,                   -- p_TRANSACTION_ID
                        v_DELIVERY_DATE,             -- p_TRADING_DATE
                      TO_NUMBER(v_COLUMNS(6)),          -- p_START_HOUR
                      TO_NUMBER(v_COLUMNS(7)),           -- p_START_INT
                      NULL,                     -- p_EXT_ID
                      TO_NUMBER(v_COLUMNS(8)),           -- p_SRA_AMOUNT
											MM_SEM_UTIL.g_TI_SRA_VAL_STAT_REJECTED,	-- p_VALIDITY_INDEX
                      1,                      -- p_VALIDITY_STATUS 
                      v_LOGGER                  -- p_LOGGER
                       );
        LOGS.LOG_INFO('SRA Transaction ' || EI.GET_ENTITY_NAME(EC.ED_TRANSACTION, v_TXN_ID) ||
                ' modified.');
      EXCEPTION
        WHEN OTHERS THEN
          LOGS.LOG_ERROR('SRA Transaction/Import SRA failed due to errors.');

      END;            
    END IF;
  END LOOP;
END IMPORT_CANCELLED_SRA_REPORT;
----------------------------------------------------------------------------------------------------
PROCEDURE VALIDATE_INVOICE_DATES
  (
  p_BEGIN_DATE IN OUT DATE,
  p_END_DATE IN OUT DATE,
  p_MARKET_NAME IN VARCHAR2,
  p_LOGGER IN OUT NOCOPY MM_LOGGER_ADAPTER
  ) AS
v_ENTITY_INTERVAL VARCHAR2(8) := GET_INVOICE_INTERVAL(p_MARKET_NAME);
v_BEGIN_DATE1 DATE;
v_END_DATE1 DATE;
v_BEGIN_DATE2 DATE;
BEGIN

  v_BEGIN_DATE1 := DATE_UTIL.BEGIN_DATE_FOR_INTERVAL(p_BEGIN_DATE, v_ENTITY_INTERVAL, MM_SEM_UTIL.g_WEEK_BEGIN);
  v_END_DATE1 := DATE_UTIL.END_DATE_FOR_INTERVAL(v_BEGIN_DATE1, v_ENTITY_INTERVAL, MM_SEM_UTIL.g_WEEK_BEGIN);

  v_BEGIN_DATE2 := DATE_UTIL.BEGIN_DATE_FOR_INTERVAL(p_END_DATE, v_ENTITY_INTERVAL, MM_SEM_UTIL.g_WEEK_BEGIN);

  IF v_BEGIN_DATE1 <> v_BEGIN_DATE2 THEN
    p_LOGGER.LOG_WARN('Invoice Job records span more than one '||LOWER(v_ENTITY_INTERVAL)||' ('||
            TO_CHAR(p_BEGIN_DATE,'YYYY-MM-DD')||' -> '||TO_CHAR(p_END_DATE,'YYYY-MM-DD')||')');
  END IF;

  -- "fix up" the interval to be precisely one invoice period
  p_BEGIN_DATE := v_BEGIN_DATE1;
  p_END_DATE := v_END_DATE1;

END VALIDATE_INVOICE_DATES;
--------------------------------------------------------------------------------
FUNCTION GET_PREV_INVOICE_ID(p_INVOICE_REC IN INVOICE%ROWTYPE)
RETURN NUMBER IS
   v_RET                  NUMBER := 0;
   v_PREV_STATEMENT_TYPE  STATEMENT_TYPE.STATEMENT_TYPE_ID%TYPE;
BEGIN

   -- Get the previous statement_type based on the current invoice
   WITH T AS (SELECT ST.STATEMENT_TYPE_NAME,
                     ST.STATEMENT_TYPE_ID,
                     NVL(LAG (ST.STATEMENT_TYPE_ID)
                         OVER (ORDER BY ST.STATEMENT_TYPE_ORDER),0)
                     AS PREV_STATEMENT_TYPE_ID
                FROM STATEMENT_TYPE ST)
   SELECT T.PREV_STATEMENT_TYPE_ID INTO v_PREV_STATEMENT_TYPE
     FROM T,
          INVOICE I
    WHERE I.INVOICE_ID        = p_INVOICE_REC.INVOICE_ID
      AND T.STATEMENT_TYPE_ID = I.STATEMENT_TYPE;

   -- Get the previous invoice id
   SELECT NVL(INVOICE_ID,0) INTO v_RET
     FROM INVOICE
    WHERE ENTITY_ID       = p_INVOICE_REC.ENTITY_ID
      AND STATEMENT_STATE = MM_SEM_UTIL.g_STATEMENT_STATE
      AND STATEMENT_TYPE  = v_PREV_STATEMENT_TYPE
      AND BEGIN_DATE      = p_INVOICE_REC.BEGIN_DATE
      AND END_DATE        = p_INVOICE_REC.END_DATE;

   RETURN v_RET;

   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         RETURN 0;
END GET_PREV_INVOICE_ID;


--------------------------------------------------------------------------------
FUNCTION GET_PREV_INV_LINE_ITEM_AMT(p_PREV_INVOICE_ID IN INVOICE_LINE_ITEM.INVOICE_ID%TYPE,
                                    p_EXT_IDENT       IN INVOICE_LINE_ITEM.LINE_ITEM_NAME%TYPE)
RETURN NUMBER IS
   v_RET NUMBER := 0;
BEGIN

   IF p_PREV_INVOICE_ID = 0 THEN

      v_RET := 0;

   ELSE--IF p_PREV_INVOICE_ID = 0

      -- The following components don't need to previous values
      -- they are relative to the current invoice only, therefore
      -- returning a zero previous value.
      IF p_EXT_IDENT IN ('INTEREST',
                         'CC_PENEX',
                         'CC_PCPEX') THEN
         v_RET := 0;

      ELSE--IF p_EXT_IDENT

         SELECT NVL(LINE_ITEM_AMOUNT,0) INTO v_RET
           FROM INVOICE_LINE_ITEM
          WHERE INVOICE_ID     = p_PREV_INVOICE_ID
            AND LINE_ITEM_NAME = p_EXT_IDENT;

      END IF;--IF p_EXT_IDENT

   END IF;--IF p_PREV_INVOICE_ID = 0

   RETURN v_RET;

   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         RETURN 0;
END GET_PREV_INV_LINE_ITEM_AMT;
----------------------------------------------------------------------------------------
PROCEDURE IMPORT_INVOICE_REPORT
  (
  p_IMPORT_SOURCE IN BINARY_INTEGER,
  p_REPORT IN CLOB,
  p_LOGGER IN OUT NOCOPY MM_LOGGER_ADAPTER
  ) IS
c_UNTAXED          CONSTANT VARCHAR2(10) := CONSTANTS.UNTAXED_STRING;
v_XML              XMLTYPE;
v_INVOICE_REC      INVOICE%ROWTYPE;
v_SEM_INVOICE_REC  SEM_INVOICE%ROWTYPE;
v_LINE_REC         INVOICE_LINE_ITEM%ROWTYPE;
v_SEM_LINE_REC     SEM_INVOICE_LINE_ITEM%ROWTYPE;
v_PARTICIPANT      VARCHAR2(120);
v_MARKET_NAME      VARCHAR2(120);
v_BEGIN_DATE       DATE;
v_END_DATE         DATE;

v_TOTAL_UNIT       VARCHAR2(18);
v_UNIT_MISMATCH    BOOLEAN := FALSE;

v_TOTAL            NUMBER;
v_PREV_TOTAL       NUMBER;

v_ACCUM_TOTAL      NUMBER := 0;
v_ACCUM_PREV_TOTAL NUMBER := 0;

v_PREV_INVOICE_ID  NUMBER := 0;

v_TAX_AMOUNT       NUMBER := 0;
v_PREV_TAX_AMOUNT  NUMBER := 0;

v_ENTITY_ID        NUMBER;
v_PARMS            UT.STRING_MAP;

    CURSOR c_LINE_ITEMS IS
        SELECT EXTRACTVALUE(VALUE(T), '/Body/Invoice_number', g_INVOICE_XPATH_NS) as INVOICE_NUMBER,
            EXTRACTVALUE(VALUE(T), '/Body/Bill_heading', g_INVOICE_XPATH_NS) as BILL_HEADING,
            EXTRACTVALUE(VALUE(T), '/Body/Charge_description', g_INVOICE_XPATH_NS) as CHARGE_DESCRIPTION,
            EXTRACTVALUE(VALUE(T), '/Body/Charge_id', g_INVOICE_XPATH_NS) AS ACTUAL_CHARGE_ID,
            NVL(S.VALUE, EXTRACTVALUE(VALUE(T), '/Body/Charge_id', g_INVOICE_XPATH_NS)) AS MAPPED_CHARGE_ID,
            EXTRACTVALUE(VALUE(T), '/Body/Quantity', g_INVOICE_XPATH_NS) as QUANTITY,
            EXTRACTVALUE(VALUE(T), '/Body/Qty_unit', g_INVOICE_XPATH_NS) as QTY_UNIT,
            EXTRACTVALUE(VALUE(T), '/Body/Amount', g_INVOICE_XPATH_NS) as AMOUNT,
            EXTRACTVALUE(VALUE(T), '/Body/Amount_unit', g_INVOICE_XPATH_NS) as AMOUNT_UNIT,
            EXTRACTVALUE(VALUE(T), '/Body/Bill_order', g_INVOICE_XPATH_NS) as BILL_ORDER,
            EXTRACTVALUE(VALUE(T), '/Body/Charge_type', g_INVOICE_XPATH_NS) as CHARGE_TYPE,
            EXTRACTVALUE(VALUE(T), '/Body/Tax_amount', g_INVOICE_XPATH_NS) as TAX_AMOUNT,
            EXTRACTVALUE(VALUE(T), '/Body/Tax_vartype_code', g_INVOICE_XPATH_NS) as TAX_VARTYPE_CODE,
            EXTRACTVALUE(VALUE(T), '/Body/Tax_vartype_name', g_INVOICE_XPATH_NS) as TAX_VARTYPE_NAME,
            EXTRACTVALUE(VALUE(T), '/Body/Tax_pay_or_charge', g_INVOICE_XPATH_NS) as TAX_PAY_OR_CHARGE,
            NVL(EXTRACTVALUE(VALUE(T), '/Body/Tax_percent_text', g_INVOICE_XPATH_NS),c_UNTAXED) as TAX_PERCENT_TEXT,
            NVL(EXTRACTVALUE(VALUE(T), '/Body/Prev_amount', g_INVOICE_XPATH_NS),0) as PREV_AMOUNT,
            EXTRACTVALUE(VALUE(T), '/Body/Prev_tax_amount', g_INVOICE_XPATH_NS) as PREV_TAX_AMOUNT
        FROM TABLE(XMLSEQUENCE(EXTRACT(v_XML, '/InvoiceSet/InvoiceElement/Body', g_INVOICE_XPATH_NS))) T,
            SYSTEM_DICTIONARY S
        WHERE S.MODEL_ID(+) = CONSTANTS.GLOBAL_MODEL
            AND S.MODULE(+) = 'MarketExchange'
            AND S.KEY1(+) = 'SEM'
            AND S.KEY2(+) = 'Settlement'
            AND S.KEY3(+) = 'Invoice Charge ID to Component Map'
            AND S.SETTING_NAME(+) = EXTRACTVALUE(VALUE(T), '/Body/Charge_id', g_INVOICE_XPATH_NS)
        ORDER BY MAPPED_CHARGE_ID;

    v_LINE_ITEM_AMOUNT INVOICE_LINE_ITEM.LINE_ITEM_QUANTITY%TYPE := 0;
    v_LINE_ITEM_QUANTITY INVOICE_LINE_ITEM.LINE_ITEM_AMOUNT%TYPE := 0;
    v_PREV_CHARGE_ID SEM_INVOICE_LINE_ITEM.CHARGE_ID%TYPE := NULL;

    v_PREV_LINE_ITEM c_LINE_ITEMS%ROWTYPE;

    v_LINE_ITEMS_NET_AMOUNT SEM_INVOICE_TAX_SUM.NET_AMOUNT%TYPE;
    v_LINE_ITEMS_TAX_TOTAL_AMOUNT SEM_INVOICE_TAX_SUM.TAX_TOTAL_AMOUNT%TYPE;

    ---------------------------
    -- This function returns the maximum order statement type id by searching the
    -- SEM_STATEMENT_JOBS table for matching job id, job version, and statement number
    -- for its constituent jobs
    FUNCTION GET_STATEMENT_TYPE_ID
       (
        p_ENTITY_ID  NUMBER,
        p_XML        XMLTYPE
        )
    RETURN NUMBER IS
    v_STATEMENT_TYPE_ID STATEMENT_TYPE.STATEMENT_TYPE_ID%TYPE;
    BEGIN
    BEGIN
      SELECT DISTINCT
                FIRST_VALUE(S.STATEMENT_TYPE_ID) OVER (ORDER BY S.STATEMENT_TYPE_ORDER DESC) AS STATEMENT_TYPE_ID
        INTO v_STATEMENT_TYPE_ID
        FROM SEM_STATEMENT_JOB SSJ,
                STATEMENT_TYPE    S,
            (SELECT EXTRACTVALUE(VALUE(T), '/Job/Job_id',g_INVOICE_XPATH_NS)        AS JOB_ID,
                    EXTRACTVALUE(VALUE(T), '/Job/Job_version',g_INVOICE_XPATH_NS)   AS JOB_VERSION,
                        EXTRACTVALUE(VALUE(T), '/Job/Statement_id', g_INVOICE_XPATH_NS) AS STATEMENT_NUMBER,
                        TO_DATE(EXTRACTVALUE(VALUE(T), '/Job/Settlement_day', g_INVOICE_XPATH_NS), MM_SEM_UTIL.g_DATE_FORMAT) AS STATEMENT_DATE
               FROM TABLE(XMLSEQUENCE(EXTRACT(p_XML, '/InvoiceSet/InvoiceElement/Job', g_INVOICE_XPATH_NS))) T) X
          WHERE SSJ.BILLING_ENTITY_ID = p_ENTITY_ID
            AND SSJ.STATEMENT_DATE    = X.STATEMENT_DATE
            AND SSJ.JOB_ID            = X.JOB_ID
            AND SSJ.JOB_VERSION       = X.JOB_VERSION
            AND SSJ.STATEMENT_NUMBER  = X.STATEMENT_NUMBER
            AND SSJ.STATEMENT_TYPE_ID = S.STATEMENT_TYPE_ID;

    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        p_LOGGER.LOG_WARN('Unable to find matching settlement type code for the invoice. Invoice was imported with F settlement type code.');
        v_STATEMENT_TYPE_ID := MM_UTIL.DETERMINE_STATEMENT_TYPE('F', NULL,
                      EC.ES_SEM, MM_SEM_UTIL.g_STATEMENT_TYPE_SETTLEMENT);
    END;

    RETURN v_STATEMENT_TYPE_ID;

  EXCEPTION
    WHEN OTHERS THEN
      p_LOGGER.LOG_ERROR('Unable to find matching statement type for the invoice.');
      RAISE;
    END GET_STATEMENT_TYPE_ID;
    ---------------------------

BEGIN
  p_LOGGER.EXCHANGE_NAME := 'Import invoice report';

  v_XML := PARSE_UTIL.CREATE_XML_SAFE(p_REPORT);

  -- Get information for invoice
    SELECT EXTRACTVALUE(VALUE(T), '/InvoiceElement/Receiver_id', g_INVOICE_XPATH_NS),
            EXTRACTVALUE(VALUE(T), '/InvoiceElement/Market_name', g_INVOICE_XPATH_NS),
            EXTRACTVALUE(VALUE(T), '/InvoiceElement/Unit', g_INVOICE_XPATH_NS)
  INTO v_PARTICIPANT, v_MARKET_NAME, v_TOTAL_UNIT
    FROM TABLE(XMLSEQUENCE(EXTRACT(v_XML, '/InvoiceSet/InvoiceElement', g_INVOICE_XPATH_NS))) T;

  IF g_MARKET_NAMES.EXISTS(v_MARKET_NAME) THEN -- find abbreviation for the market
    v_MARKET_NAME := g_MARKET_NAMES(v_MARKET_NAME);
    CHECK_MARKET_NAME(v_MARKET_NAME, p_LOGGER);
  ELSE
    p_LOGGER.LOG_WARN('Invoice indicates unrecognized market name: '||v_MARKET_NAME);
  END IF;

  -- Determine invoice date range
    SELECT MIN(TO_DATE(EXTRACTVALUE(VALUE(T), '/Job/Settlement_day', g_INVOICE_XPATH_NS), MM_SEM_UTIL.g_DATE_FORMAT)),
            MAX(TO_DATE(EXTRACTVALUE(VALUE(T), '/Job/Settlement_day', g_INVOICE_XPATH_NS), MM_SEM_UTIL.g_DATE_FORMAT))
  INTO v_BEGIN_DATE, v_END_DATE
    FROM TABLE(XMLSEQUENCE(EXTRACT(v_XML, '/InvoiceSet/InvoiceElement/Job', g_INVOICE_XPATH_NS))) T;

  VALIDATE_INVOICE_DATES(v_BEGIN_DATE, v_END_DATE, v_MARKET_NAME, p_LOGGER);

  -- Get the invoice
   v_ENTITY_ID := GET_ENTITY_ID(v_PARTICIPANT, p_MARKET => v_MARKET_NAME);
  PC.GET_INVOICE(v_ENTITY_ID,
              'PSE',
                  GET_STATEMENT_TYPE_ID(v_ENTITY_ID, v_XML),
                  MM_SEM_UTIL.g_STATEMENT_STATE,
              v_BEGIN_DATE,
                  v_END_DATE,
                  LOW_DATE,
                  v_INVOICE_REC);

    -- Update the Currency Unit for a first available currency
    PUT_CURRENCY_UNIT_FOR_PSE(v_ENTITY_ID, v_TOTAL_UNIT, p_LOGGER);

  -- some cleanup of invoice header items...
  v_INVOICE_REC.INVOICE_SUB_LEDGER_NUMBER := NULL;
  v_INVOICE_REC.BILLING_STATE_CODE := NULL;
  v_INVOICE_REC.BILLING_POSTAL_CODE := NULL;
  v_INVOICE_REC.BILLING_COUNTRY_CODE := NULL;
  v_INVOICE_REC.INVOICE_SECONDARY_CONTACT := NULL;
  v_INVOICE_REC.INVOICE_SECONDARY_PHONE := NULL;
  v_INVOICE_REC.PAY_CHECK_CONTACT := NULL;
  v_INVOICE_REC.PAY_CHECK_STREET := NULL;
  v_INVOICE_REC.PAY_CHECK_CITY := NULL;
  v_INVOICE_REC.PAY_CHECK_STATE_CODE := NULL;
  v_INVOICE_REC.PAY_CHECK_POSTAL_CODE := NULL;
  v_INVOICE_REC.PAY_CHECK_COUNTRY_CODE := NULL;
  v_INVOICE_REC.PAY_ELECTRONIC_DEBIT_NAME := NULL;
  v_INVOICE_REC.PAY_ELECTRONIC_DEBIT_NBR := NULL;
  v_INVOICE_REC.PAY_ELECTRONIC_CREDIT_NAME := NULL;
  v_INVOICE_REC.PAY_ELECTRONIC_CREDIT_NBR := NULL;

  -- Update invoice header info from XML invoice
    SELECT  v_INVOICE_REC.INVOICE_ID,
            EXTRACTVALUE(VALUE(T), '/InvoiceElement/Invoice_number', g_INVOICE_XPATH_NS) as INVOICE_NUMBER,
      EXTRACTVALUE(VALUE(T), '/InvoiceElement/Sender_addr1', g_INVOICE_XPATH_NS) as SENDER_ADDR1,
            EXTRACTVALUE(VALUE(T), '/InvoiceElement/Sender_addr2', g_INVOICE_XPATH_NS) as SENDER_ADDR2,
            EXTRACTVALUE(VALUE(T), '/InvoiceElement/Sender_tel', g_INVOICE_XPATH_NS) as SENDER_TEL,
            EXTRACTVALUE(VALUE(T), '/InvoiceElement/Sender_fax', g_INVOICE_XPATH_NS) as SENDER_FAX,
            EXTRACTVALUE(VALUE(T), '/InvoiceElement/Sender_taxid', g_INVOICE_XPATH_NS) as SENDER_TAXID,
            EXTRACTVALUE(VALUE(T), '/InvoiceElement/Receiver_name', g_INVOICE_XPATH_NS) as RECEIVER_NAME,
            EXTRACTVALUE(VALUE(T), '/InvoiceElement/Receiver_addr1', g_INVOICE_XPATH_NS) as RECEIVER_ADDR1,
            EXTRACTVALUE(VALUE(T), '/InvoiceElement/Receiver_addr2', g_INVOICE_XPATH_NS) as RECEIVER_ADDR2,
            EXTRACTVALUE(VALUE(T), '/InvoiceElement/Receiver_gl_number', g_INVOICE_XPATH_NS) as RECEIVER_GL_NUMBER,
            EXTRACTVALUE(VALUE(T), '/InvoiceElement/Invoice_type', g_INVOICE_XPATH_NS) as INVOICE_TYPE,
            TO_DATE(EXTRACTVALUE(VALUE(T), '/InvoiceElement/Due_date', g_INVOICE_XPATH_NS), MM_SEM_UTIL.g_DATE_FORMAT) as DUE_DATE,
            EXTRACTVALUE(VALUE(T), '/InvoiceElement/Inv_heading', g_INVOICE_XPATH_NS) as INV_HEADING,
            EXTRACTVALUE(VALUE(T), '/InvoiceElement/Inv_comment', g_INVOICE_XPATH_NS) as INV_COMMENT,
            EXTRACTVALUE(VALUE(T), '/InvoiceElement/Signature1', g_INVOICE_XPATH_NS) as SIGNATURE1,
            EXTRACTVALUE(VALUE(T), '/InvoiceElement/Unit', g_INVOICE_XPATH_NS) as UNIT,
            TO_DATE(EXTRACTVALUE(VALUE(T), '/InvoiceElement/Invoice_date', g_INVOICE_XPATH_NS), MM_SEM_UTIL.g_DATE_FORMAT) as INVOICE_DATE,
            EXTRACTVALUE(VALUE(T), '/InvoiceElement/Invoice_calendar_id', g_INVOICE_XPATH_NS) as INVOICE_CALENDAR_ID,
            EXTRACTVALUE(VALUE(T), '/InvoiceElement/Invoice_amount', g_INVOICE_XPATH_NS) as INVOICE_AMOUNT,
            EXTRACTVALUE(VALUE(T), '/InvoiceElement/Market_name', g_INVOICE_XPATH_NS) as MARKET_NAME,
            EXTRACTVALUE(VALUE(T), '/InvoiceElement/Bill_period_name', g_INVOICE_XPATH_NS) as BILL_PERIOD_NAME,
            EXTRACTVALUE(VALUE(T), '/InvoiceElement/Receiver_id', g_INVOICE_XPATH_NS) AS RECEIVER_ID,
            EXTRACTVALUE(VALUE(T), '/InvoiceElement/First_amount', g_INVOICE_XPATH_NS) as FIRST_AMOUNT,
      EXTRACTVALUE(VALUE(T), '/InvoiceElement/Exchange_rate', g_INVOICE_XPATH_NS) as EXCHANGE_RATE,
            EXTRACTVALUE(VALUE(T), '/InvoiceElement/VAT_jurisdiction', g_INVOICE_XPATH_NS) as VAT_JURISDICTION,
            EXTRACTVALUE(VALUE(T), '/InvoiceElement/Version', g_INVOICE_XPATH_NS) AS VERSION,
            p_LOGGER.LAST_EVENT_ID -- Use last event ID - which will be the invoice download
                                 -- or NULL if we are doing file import
    INTO
            v_SEM_INVOICE_REC
    FROM TABLE(XMLSEQUENCE(EXTRACT(v_XML, '/InvoiceSet/InvoiceElement', g_INVOICE_XPATH_NS))) T;

   -- Store the invoice header info into the INVOICE table
   v_INVOICE_REC.INVOICE_NUMBER := v_SEM_INVOICE_REC.INVOICE_NUMBER;
  v_INVOICE_REC.BILLING_CONTACT := v_SEM_INVOICE_REC.RECEIVER_NAME;
   v_INVOICE_REC.BILLING_STREET := v_SEM_INVOICE_REC.RECEIVER_STREET;
   v_INVOICE_REC.BILLING_CITY := v_SEM_INVOICE_REC.RECEIVER_CITY;
  v_INVOICE_REC.PAY_CHECK_CONTACT := v_SEM_INVOICE_REC.RECEIVER_GL;
   v_INVOICE_REC.INVOICE_PRIMARY_CONTACT := v_SEM_INVOICE_REC.SIGNATURE1;
  v_INVOICE_REC.INVOICE_PRIMARY_PHONE := v_SEM_INVOICE_REC.SENDER_PHONE;
  v_INVOICE_REC.INVOICE_SECONDARY_PHONE := v_SEM_INVOICE_REC.SENDER_FAX;
   v_INVOICE_REC.PAYMENT_DUE_DATE := v_SEM_INVOICE_REC.DUE_DATE;
   v_INVOICE_REC.INVOICE_TERMS := v_SEM_INVOICE_REC.INV_COMMENT;
  v_TOTAL_UNIT := v_SEM_INVOICE_REC.UNIT;
  v_INVOICE_REC.INVOICE_DATE := v_SEM_INVOICE_REC.INVOICE_DATE;
  v_TOTAL := v_SEM_INVOICE_REC.INVOICE_AMOUNT;
  v_PREV_TOTAL := v_SEM_INVOICE_REC.FIRST_AMOUNT;

  -- Save changes to invoice header
  PC.PUT_INVOICE(v_INVOICE_REC);

   -- Get the previous invoice_id, used to lookup previous invoice amounts
   v_PREV_INVOICE_ID := GET_PREV_INVOICE_ID(v_INVOICE_REC);

  -- Save SEM info for the invoice
  UPDATE SEM_INVOICE SET ROW = v_SEM_INVOICE_REC
  WHERE INVOICE_ID = v_SEM_INVOICE_REC.INVOICE_ID;

  IF SQL%NOTFOUND THEN
    INSERT INTO SEM_INVOICE VALUES v_SEM_INVOICE_REC;
  END IF;


  -- Now get invoice job info and store into SEM_INVOICE_JOB
  DELETE SEM_INVOICE_JOB WHERE INVOICE_ID = v_INVOICE_REC.INVOICE_ID;

  INSERT INTO SEM_INVOICE_JOB A
    (A.INVOICE_ID, A.JOB_ID, A.JOB_NAME, A.SETTLEMENT_DAY, A.JOB_NUMBER,
     A.JOB_VERSION, A.JOB_STATE, A.JOB_STATUS, A.TRUE_UP_BASED_ON,
     A.STATEMENT_ID, A.GLOBAL_PARTICIPANT_NAME)
     SELECT v_INVOICE_REC.INVOICE_ID,
             EXTRACTVALUE(VALUE(T), '/Job/Job_id', g_INVOICE_XPATH_NS) as JOB_ID,
             EXTRACTVALUE(VALUE(T), '/Job/Job_name', g_INVOICE_XPATH_NS) as JOB_NAME,
             TO_DATE(EXTRACTVALUE(VALUE(T), '/Job/Settlement_day', g_INVOICE_XPATH_NS), MM_SEM_UTIL.g_DATE_FORMAT) as SETTLEMENT_DAY,
             EXTRACTVALUE(VALUE(T), '/Job/Job_number', g_INVOICE_XPATH_NS) as JOB_NUMBER,
             EXTRACTVALUE(VALUE(T), '/Job/Job_version', g_INVOICE_XPATH_NS) as JOB_VERSION,
             EXTRACTVALUE(VALUE(T), '/Job/Job_state', g_INVOICE_XPATH_NS) as JOB_STATE,
             EXTRACTVALUE(VALUE(T), '/Job/Job_status', g_INVOICE_XPATH_NS) as JOB_STATUS,
             EXTRACTVALUE(VALUE(T), '/Job/True_up_based_on', g_INVOICE_XPATH_NS) as TRUE_UP_BASED_ON,
             EXTRACTVALUE(VALUE(T), '/Job/Statement_id', g_INVOICE_XPATH_NS) as STATEMENT_ID,
             EXTRACTVALUE(VALUE(T), '/Job/Global_participant_no', g_INVOICE_XPATH_NS) as GLOBAL_PARTICIPANT_NO
        FROM TABLE(XMLSEQUENCE(EXTRACT(v_XML, '/InvoiceSet/InvoiceElement/Job', g_INVOICE_XPATH_NS))) T;

  -- Clear out existing line items
  DELETE INVOICE_LINE_ITEM WHERE INVOICE_ID = v_INVOICE_REC.INVOICE_ID;
  DELETE SEM_INVOICE_LINE_ITEM WHERE INVOICE_ID = v_INVOICE_REC.INVOICE_ID;

  -- Now get the line items and store into INVOICE_LINE_ITEM
  v_LINE_REC.INVOICE_ID         := v_INVOICE_REC.INVOICE_ID;
  v_LINE_REC.STATEMENT_TYPE     := v_INVOICE_REC.STATEMENT_TYPE;
  v_LINE_REC.BEGIN_DATE         := v_INVOICE_REC.BEGIN_DATE;
  v_LINE_REC.END_DATE           := v_INVOICE_REC.END_DATE;
  v_LINE_REC.PRODUCT_ID         := 0;
  v_LINE_REC.ACCOUNT_SERVICE_ID := 0;
  v_LINE_REC.LINE_ITEM_CATEGORY := v_MARKET_NAME;
   v_LINE_REC.DEFAULT_DISPLAY    := 'BILL';
  v_LINE_REC.LINE_ITEM_OPTION   := 'BY COMPONENT';

    v_ACCUM_TOTAL      := 0;
    v_ACCUM_PREV_TOTAL := 0;
    FOR v_LINE_ITEM IN c_LINE_ITEMS LOOP
        -- Get the line items and store into SEM_INVOICE_LINE_ITEM
        v_SEM_LINE_REC.INVOICE_ID         := v_INVOICE_REC.INVOICE_ID;
        v_SEM_LINE_REC.LINE_ITEM_NAME     := v_LINE_ITEM.ACTUAL_CHARGE_ID;
        v_SEM_LINE_REC.BILL_HEADING       := v_LINE_ITEM.BILL_HEADING;
        v_SEM_LINE_REC.CHARGE_DESCRIPTION := v_LINE_ITEM.CHARGE_DESCRIPTION;
        v_SEM_LINE_REC.CHARGE_ID          := v_LINE_ITEM.ACTUAL_CHARGE_ID;
        v_SEM_LINE_REC.QUANTITY           := v_LINE_ITEM.QUANTITY;
        v_SEM_LINE_REC.QTY_UNIT           := v_LINE_ITEM.QTY_UNIT;
        v_SEM_LINE_REC.AMOUNT             := v_LINE_ITEM.AMOUNT;
        v_SEM_LINE_REC.AMOUNT_UNIT        := v_LINE_ITEM.AMOUNT_UNIT;
        v_SEM_LINE_REC.BILL_ORDER         := v_LINE_ITEM.BILL_ORDER;
        v_SEM_LINE_REC.CHARGE_TYPE        := v_LINE_ITEM.CHARGE_TYPE;
        v_SEM_LINE_REC.TAX_AMOUNT         := v_LINE_ITEM.TAX_AMOUNT;
        v_SEM_LINE_REC.TAX_VARTYPE_CODE   := v_LINE_ITEM.TAX_VARTYPE_CODE;
        v_SEM_LINE_REC.TAX_VARTYPE_NAME   := v_LINE_ITEM.TAX_VARTYPE_NAME;
        v_SEM_LINE_REC.TAX_PAY_OR_CHARGE  := v_LINE_ITEM.TAX_PAY_OR_CHARGE;
        v_SEM_LINE_REC.TAX_PERCENT_TEXT   := v_LINE_ITEM.TAX_PERCENT_TEXT;
        v_SEM_LINE_REC.PREV_AMOUNT        := v_LINE_ITEM.PREV_AMOUNT;
        v_SEM_LINE_REC.PREV_TAX_AMOUNT    := v_LINE_ITEM.PREV_TAX_AMOUNT;

        IF v_LINE_ITEM.INVOICE_NUMBER <> v_INVOICE_REC.INVOICE_NUMBER THEN
            p_LOGGER.LOG_WARN('InvoiceElement node has invoice_number of '||v_INVOICE_REC.INVOICE_NUMBER||' but Body (line item) node has '||v_LINE_ITEM.INVOICE_NUMBER);
        END IF;

        -- Check if the currency unit is compatible for the line item
        IF v_LINE_ITEM.AMOUNT_UNIT <> v_TOTAL_UNIT THEN
            v_UNIT_MISMATCH := TRUE;
        END IF;

        v_ACCUM_TOTAL := v_ACCUM_TOTAL + v_LINE_REC.LINE_ITEM_BILL_AMOUNT;

        v_ACCUM_PREV_TOTAL := v_ACCUM_PREV_TOTAL + NVL(GET_PREV_INV_LINE_ITEM_AMT(v_PREV_INVOICE_ID,
                                                              v_LINE_REC.LINE_ITEM_NAME),0);

    -- capture the tax information
    v_TAX_AMOUNT := v_TAX_AMOUNT + NVL(v_LINE_ITEM.TAX_AMOUNT, 0);
    v_PREV_TAX_AMOUNT := v_PREV_TAX_AMOUNT + NVL(v_LINE_ITEM.PREV_TAX_AMOUNT, 0);

        INSERT INTO SEM_INVOICE_LINE_ITEM VALUES v_SEM_LINE_REC;

        -- ROLL UP INVOICE_LINE_ITEM BY CHARGE ID, SO KEEP A ROLLING TOTAL OF QUANTITY AND AMOUNT AND SAVE THEM
        -- FOR EACH CHARGE ID TYPE
        IF v_PREV_CHARGE_ID IS NOT NULL AND v_PREV_CHARGE_ID <> v_LINE_ITEM.MAPPED_CHARGE_ID THEN
            -- Fill in the data for the line item
            v_LINE_REC.LINE_ITEM_NAME        := v_PREV_CHARGE_ID;
            v_LINE_REC.COMPONENT_ID          := GET_COMPONENT_ID(v_PREV_CHARGE_ID, v_PREV_LINE_ITEM.CHARGE_DESCRIPTION);
            v_LINE_REC.OTHER_ID              := v_PREV_LINE_ITEM.CHARGE_TYPE + v_PREV_LINE_ITEM.BILL_ORDER*10;
            v_LINE_REC.OTHER_DATA            := v_PREV_LINE_ITEM.BILL_HEADING;
            v_LINE_REC.LINE_ITEM_QUANTITY    := v_LINE_ITEM_QUANTITY;
            v_LINE_REC.LINE_ITEM_AMOUNT      := NVL(v_LINE_ITEM_AMOUNT,0) + NVL(GET_PREV_INV_LINE_ITEM_AMT(v_PREV_INVOICE_ID,
                                                                                                         v_LINE_REC.LINE_ITEM_NAME),0);
            v_LINE_REC.LINE_ITEM_BILL_AMOUNT := v_LINE_ITEM_AMOUNT;


            PC.PUT_INVOICE_LINE_ITEM(v_LINE_REC);

            -- RESET OUR RUNNING TOTALS OF LINE ITEM AMOUNT AND QUANTITY
            v_LINE_ITEM_AMOUNT := 0;
            v_LINE_ITEM_QUANTITY := 0;
        END IF;

        v_PREV_CHARGE_ID := v_LINE_ITEM.MAPPED_CHARGE_ID;
        v_PREV_LINE_ITEM := v_LINE_ITEM;

        v_LINE_ITEM_AMOUNT := v_LINE_ITEM_AMOUNT + v_LINE_ITEM.AMOUNT;
        v_LINE_ITEM_QUANTITY := v_LINE_ITEM_QUANTITY + v_LINE_ITEM.QUANTITY;
  END LOOP;


    -- PUT THE LAST CHARGE_ID
    -- Fill in the data for the line item
    v_LINE_REC.LINE_ITEM_NAME        := v_PREV_CHARGE_ID;
    v_LINE_REC.COMPONENT_ID          := GET_COMPONENT_ID(v_PREV_CHARGE_ID, v_PREV_LINE_ITEM.CHARGE_DESCRIPTION);
    v_LINE_REC.OTHER_ID              := v_PREV_LINE_ITEM.CHARGE_TYPE + v_PREV_LINE_ITEM.BILL_ORDER*10;
    v_LINE_REC.OTHER_DATA            := v_PREV_LINE_ITEM.BILL_HEADING;
    v_LINE_REC.LINE_ITEM_QUANTITY    := v_LINE_ITEM_QUANTITY;
    v_LINE_REC.LINE_ITEM_AMOUNT      := NVL(v_LINE_ITEM_AMOUNT,0) + NVL(GET_PREV_INV_LINE_ITEM_AMT(v_PREV_INVOICE_ID,
                                                                                                 v_LINE_REC.LINE_ITEM_NAME),0);
    v_LINE_REC.LINE_ITEM_BILL_AMOUNT := v_LINE_ITEM_AMOUNT;


    PC.PUT_INVOICE_LINE_ITEM(v_LINE_REC);


  -- Store the tax line item
  v_LINE_REC.OTHER_ID := 0;
  v_LINE_REC.LINE_ITEM_QUANTITY := 0;
  v_LINE_REC.LINE_ITEM_NAME := 'VAT: Tax';
    v_LINE_REC.COMPONENT_ID := GET_COMPONENT_ID(GET_VAT_COMPONENT(v_END_DATE, v_ENTITY_ID),'Tax');
  v_LINE_REC.OTHER_DATA := 'Tax';

  v_LINE_REC.LINE_ITEM_AMOUNT := v_TAX_AMOUNT + NVL(GET_PREV_INV_LINE_ITEM_AMT(v_PREV_INVOICE_ID,
                                                                                v_LINE_REC.LINE_ITEM_NAME),0);


  v_ACCUM_TOTAL := v_ACCUM_TOTAL + v_TAX_AMOUNT;

  v_LINE_REC.LINE_ITEM_BILL_AMOUNT := v_TAX_AMOUNT;

   v_ACCUM_PREV_TOTAL := v_ACCUM_PREV_TOTAL + v_PREV_TAX_AMOUNT;

  PC.PUT_INVOICE_LINE_ITEM(v_LINE_REC);

  IF MM_SEM_UTIL.USING_CROSS_BORDER_VAT_FORMAT(v_END_DATE, v_ENTITY_ID) THEN
    PUT_VAT_CHARGE(v_INVOICE_REC);
  END IF;

    IF MM_SEM_UTIL.USING_CROSS_BORDER_VAT_FORMAT(v_END_DATE, v_ENTITY_ID) THEN
        -- IMPORT TAX_SUMs
        -- DELETE EXISTING SEM_INVOICE_TAX records
        DELETE FROM SEM_INVOICE_TAX_SUM S WHERE S.INVOICE_ID = v_INVOICE_REC.INVOICE_ID;

        INSERT INTO SEM_INVOICE_TAX_SUM A
         (A.INVOICE_ID, A.TAX_PERCENT_TEXT, A.TAX_PAY_OR_CHARGE, A.NET_AMOUNT, A.TAX_TOTAL_AMOUNT, A.GROSS_AMOUNT)
        SELECT v_INVOICE_REC.INVOICE_ID,
             NVL(EXTRACTVALUE(VALUE(T), '/Tax_Sum/Tax_rate_text', g_INVOICE_XPATH_NS),c_UNTAXED) as TAX_PERCENT_TEXT,
       EXTRACTVALUE(VALUE(T), '/Tax_Sum/Tax_pay_or_charge', g_INVOICE_XPATH_NS) as TAX_PAY_OR_CHARGE,
             EXTRACTVALUE(VALUE(T), '/Tax_Sum/Net_amount', g_INVOICE_XPATH_NS) as NET_AMOUNT,
             EXTRACTVALUE(VALUE(T), '/Tax_Sum/Tax_total_amount', g_INVOICE_XPATH_NS) as TAX_TOTAL_AMOUNT,
             EXTRACTVALUE(VALUE(T), '/Tax_Sum/Gross_amount', g_INVOICE_XPATH_NS) as GROSS_AMOUNT
        FROM TABLE(XMLSEQUENCE(EXTRACT(v_XML, '/InvoiceSet/InvoiceElement/Tax_Sum', g_INVOICE_XPATH_NS))) T;

        -- VALIDATE THE TAX SUMS
        FOR v_REC IN (SELECT NVL(T.TAX_PERCENT_TEXT,c_UNTAXED) AS TAX_PERCENT_TEXT,
                             T.NET_AMOUNT                      AS NET_AMOUNT,
                             T.TAX_TOTAL_AMOUNT                AS TAX_TOTAL_AMOUNT
                        FROM SEM_INVOICE_TAX_SUM T
                       WHERE T.INVOICE_ID = v_INVOICE_REC.INVOICE_ID) LOOP

            SELECT SUM(SLI.AMOUNT) AS AMOUNT, SUM(SLI.TAX_AMOUNT) AS TAX_AMOUNT
            INTO v_LINE_ITEMS_NET_AMOUNT, v_LINE_ITEMS_TAX_TOTAL_AMOUNT
            FROM SEM_INVOICE_LINE_ITEM SLI
            WHERE SLI.INVOICE_ID = v_INVOICE_REC.Invoice_ID
                AND NVL(SLI.TAX_PERCENT_TEXT,c_UNTAXED) = NVL(v_REC.TAX_PERCENT_TEXT,c_UNTAXED)
                AND SLI.TAX_VARTYPE_CODE <> 'TAX';

            IF v_LINE_ITEMS_NET_AMOUNT <> v_REC.NET_AMOUNT OR v_LINE_ITEMS_TAX_TOTAL_AMOUNT <> v_REC.TAX_TOTAL_AMOUNT THEN
                p_LOGGER.LOG_WARN('Tax_Sum node specifies a net amount of ' || v_REC.NET_AMOUNT || ' and a tax total of '
                    || v_REC.TAX_TOTAL_AMOUNT || ' for tax rate ' || v_REC.TAX_PERCENT_TEXT || ' but the actual values from '
                        || 'the invoice line items of the Invoice are ' || v_LINE_ITEMS_NET_AMOUNT || ' and '
                        || v_LINE_ITEMS_TAX_TOTAL_AMOUNT || ' respectively.');
            END IF;

        END LOOP;
    END IF;

  -- Finally, validate totals
  IF v_UNIT_MISMATCH THEN
        p_LOGGER.LOG_WARN('InvoiceElement node specifies currency unit of '||
          v_TOTAL_UNIT||' but at least one line item indicated different unit. '||
          'Cannot validate invoice totals ('||v_TOTAL||' vs. '||v_ACCUM_TOTAL||', '||
                            v_PREV_TOTAL||' vs. '||v_ACCUM_PREV_TOTAL||')');
  ELSE
    IF v_ACCUM_TOTAL <> v_TOTAL THEN
          p_LOGGER.LOG_WARN('InvoiceElement node indicates total of '||v_TOTAL||' but Body (line item) node indicates '||v_ACCUM_TOTAL);
    END IF;

    IF v_ACCUM_PREV_TOTAL <> v_PREV_TOTAL AND v_ACCUM_PREV_TOTAL <> 0 THEN
          p_LOGGER.LOG_WARN('InvoiceElement node indicates previous total of '||v_PREV_TOTAL||' but Body (line item) node indicates '||v_ACCUM_PREV_TOTAL);
    END IF;
  END IF;

  -- Done!
  v_PARMS(g_HOOK_PARM_INVOICE_ID) := v_INVOICE_REC.INVOICE_ID;
  v_PARMS(g_HOOK_PARM_IMPORT_SOURCE) := p_IMPORT_SOURCE;
  XS.POST_MARKET_EXCHANGE(EC.ES_SEM, p_LOGGER.EXCHANGE_NAME, v_PARMS, p_REPORT, p_LOGGER);

EXCEPTION
  WHEN OTHERS THEN
    p_LOGGER.LOG_ERROR('Error importing invoice report: '||MM_SEM_UTIL.ERROR_STACKTRACE);
    RAISE;
END IMPORT_INVOICE_REPORT;
----------------------------------------------------------------------------------------
FUNCTION GET_GP_RPT_TYPE_FROM_FILE_NAME(p_FILE_NAME IN VARCHAR2) RETURN VARCHAR2 IS
  v_TOKS GA.STRING_TABLE;
  v_RPT_TYPE VARCHAR2(3);
BEGIN
-- MFR, MGR, and MIR reports all have the file format <Market>_MFR_<Type>_<Settlement Date>.csv
-- Where:
-- *  <Market> - Market abbreviation
-- *  <Type> - Settlement type code
-- *  <Settlement Date> - date in "YYYY-MM-DD"
-- e.g.: EN_MFR_P_2007-11-01.csv
-- (from MPUD 5.3, p123)
  UT.TOKENS_FROM_STRING(p_FILE_NAME, '_', v_TOKS);
  v_RPT_TYPE := v_TOKS(2);
  RETURN v_RPT_TYPE;
END GET_GP_RPT_TYPE_FROM_FILE_NAME;
----------------------------------------------------------------------------------------
PROCEDURE IMPORT_GENERAL_PUBLIC_REPORT
  (
  p_FILE_NAME IN VARCHAR2,
  p_REPORT IN CLOB,
  p_LOGGER IN OUT NOCOPY MM_LOGGER_ADAPTER,
  p_STATEMENT_TYPE IN NUMBER
  ) IS
v_WORK_ID NUMBER;
v_H_REC SEM_GP_SETTLEMENT_H_TEMP%ROWTYPE;
v_REC SEM_GP_SETTLEMENT%ROWTYPE;
v_STATEMENT_TYPE NUMBER;
v_MKT VARCHAR2(8);
v_RPT_TYPE VARCHAR2(8);
v_BEGIN_DATE DATE;
v_END_DATE DATE;

CURSOR c_D_RECS IS
  SELECT *
  FROM SEM_GP_SETTLEMENT_D_TEMP
  WHERE WORK_ID = v_WORK_ID;
BEGIN
  p_LOGGER.EXCHANGE_NAME := 'Import GP settlement report';
  v_WORK_ID := MM_SEM_SETTLEMENT_PARSE.PARSE_GENERAL_PUBLIC_REPORT(p_REPORT, p_LOGGER);

  v_RPT_TYPE := GET_GP_RPT_TYPE_FROM_FILE_NAME(p_FILE_NAME);
  BEGIN
    v_MKT := GET_MARKET_FROM_FILE_NAME(p_FILE_NAME, v_RPT_TYPE);
  EXCEPTION
    WHEN x_INVALID_FILENAME THEN
      -- for now, default to Energy if a file is uploaded from which
      -- the market cannot be deciphered
      v_MKT := g_ENERGY_MARKET_NAME;
  END;

  -- Get header info
  SELECT *
  INTO v_H_REC
  FROM SEM_GP_SETTLEMENT_H_TEMP
  WHERE WORK_ID = v_WORK_ID;

    --Validate the settlement type code in the file name
    --with the settlement type code in the file content
    IF VALIDATE_STATEMENT_TYPE(p_STATEMENT_TYPE, v_H_REC.STATEMENT_TYPE, p_LOGGER) THEN
       v_STATEMENT_TYPE := p_STATEMENT_TYPE;
    ELSE
       v_STATEMENT_TYPE := MM_UTIL.DETERMINE_STATEMENT_TYPE(v_H_REC.STATEMENT_TYPE, NULL, EC.ES_SEM, MM_SEM_UTIL.g_STATEMENT_TYPE_SETTLEMENT);
    END IF;

  -- clear out old data
  UT.CUT_DATE_RANGE(v_H_REC.SETTLEMENT_DAY, v_H_REC.SETTLEMENT_DAY, MM_SEM_UTIL.g_TZ, v_BEGIN_DATE, v_END_DATE);
  DELETE FROM SEM_GP_SETTLEMENT WHERE STATEMENT_TYPE = v_STATEMENT_TYPE
  AND REPORT_TYPE = v_RPT_TYPE
  AND MARKET = v_MKT
  AND CHARGE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE;

  -- Then import detail records into SEM_GP_SETTLEMENT
  FOR v_D_REC IN c_D_RECS LOOP

        v_REC.STATEMENT_TYPE := v_STATEMENT_TYPE;
        v_REC.REPORT_TYPE := v_RPT_TYPE;
        v_REC.MARKET := v_MKT;
        v_REC.RESOLUTION := v_D_REC.RESOLUTION;
        v_REC.RESOURCE_NAME := v_D_REC.RESOURCE_NAME;
        v_REC.JURISDICTION := v_D_REC.JURISDICTION;
        v_REC.VARIABLE_TYPE := v_D_REC.VARIABLE_TYPE;
        v_REC.VARIABLE_NAME := v_D_REC.VARIABLE_NAME;
        v_REC.UNIT := v_D_REC.UNIT;
    -- half-hourly data? then insert two records - one for each 30-minute interval in the hour
    IF v_REC.RESOLUTION  = g_RES_30_MIN THEN
      -- first 30-minute interval
      v_REC.CHARGE_DATE := MM_SEM_UTIL.GET_SCHEDULE_DATE(v_D_REC.DELIVERY_DATE, v_D_REC.DELIVERY_HOUR, 1);
          v_REC.VALUE := v_D_REC.VALUE1;

      INSERT INTO SEM_GP_SETTLEMENT VALUES v_REC;

      -- second 30-minute interval
      v_REC.CHARGE_DATE := MM_SEM_UTIL.GET_SCHEDULE_DATE(v_D_REC.DELIVERY_DATE, v_D_REC.DELIVERY_HOUR, 2);
          v_REC.VALUE := v_D_REC.VALUE2;

      INSERT INTO SEM_GP_SETTLEMENT VALUES v_REC;
    ELSE
      -- hourly or greater interval? then pass hour as zero
      IF v_D_REC.RESOLUTION > g_RES_HOUR THEN
        v_REC.CHARGE_DATE := MM_SEM_UTIL.GET_SCHEDULE_DATE(v_D_REC.DELIVERY_DATE, 0, 0);
      ELSE
        v_REC.CHARGE_DATE := MM_SEM_UTIL.GET_SCHEDULE_DATE(v_D_REC.DELIVERY_DATE, v_D_REC.DELIVERY_HOUR, 0);
      END IF;

          v_REC.VALUE := v_D_REC.VALUE1;

      INSERT INTO SEM_GP_SETTLEMENT VALUES v_REC;
    END IF;

  END LOOP;

  CLEANUP_SETTLEMENT_WORK(v_WORK_ID);
  -- Done!

EXCEPTION
  WHEN OTHERS THEN
    p_LOGGER.LOG_ERROR('Error importing GP settlement report: '||MM_SEM_UTIL.ERROR_STACKTRACE);
    CLEANUP_SETTLEMENT_WORK(v_WORK_ID);
    RAISE;
END IMPORT_GENERAL_PUBLIC_REPORT;
----------------------------------------------------------------------------------------
FUNCTION GET_AVAIL_REPORTS
  (
  p_DATE IN DATE,
  p_CRED IN MEX_CREDENTIALS,
  p_LOGGER IN OUT NOCOPY MM_LOGGER_ADAPTER
  ) RETURN STRING_COLLECTION IS
v_REQUEST   VARCHAR2(4000);
v_RESULT  MEX_Result;
v_RET    STRING_COLLECTION;
v_XML    XMLTYPE;
BEGIN
  p_LOGGER.EXCHANGE_NAME := 'Download settlement report listing';

  v_REQUEST := '<?xml version="1.0" encoding="UTF-8" ?><directory date="'||TO_CHAR(p_DATE,MM_SEM_UTIL.g_DATE_FORMAT)||'" />';
  v_RESULT := MEX_Switchboard.Invoke(MM_SEM_UTIL.g_MEX_MARKET, MM_SEM_UTIL.g_MEX_ACTION_SETTLEMENT_DIRL, p_LOGGER, p_CRED,
                    p_REQUEST_CONTENTTYPE => 'text/xml', p_REQUEST => v_REQUEST);

  IF v_RESULT.STATUS_CODE <> MEX_Switchboard.c_Status_Success THEN
    RETURN NULL; -- this indicates failure - MEX_Switchboard.Invoke will have already logged error message
  ELSE
    v_XML := XMLTYPE.CREATEXML(v_RESULT.RESPONSE);
    -- parse file names from the response
      SELECT EXTRACTVALUE(VALUE(T), '/file/@name', g_DIR_LIST_NAMESPACE)
    BULK COLLECT INTO v_RET
      FROM TABLE(XMLSEQUENCE(EXTRACT(v_XML, '/directory_file_list/file', g_DIR_LIST_NAMESPACE))) T;

    RETURN v_RET;
  END IF;

  -- Raise Alert
  MM_SEM_UTIL.RAISE_ALERTS(p_TYPE => g_ALERT_TYPE_SETTL,
                           p_NAME => 'Directory List',
                           p_LOGGER => p_LOGGER,
                           p_MSG => 'Complete download of settlement report listing');


EXCEPTION
  WHEN OTHERS THEN
    p_LOGGER.LOG_ERROR('Error downloading settlement report listing: '||MM_SEM_UTIL.ERROR_STACKTRACE);
        MM_SEM_UTIL.RAISE_ALERTS(p_TYPE => g_ALERT_TYPE_SETTL,
                               p_NAME => 'Directory List',
                               p_LOGGER => p_LOGGER,
                               p_MSG => 'Error downloading settlement report listing: '||MM_SEM_UTIL.ERROR_STACKTRACE,
                               p_FATAL => TRUE);
    RAISE;

END GET_AVAIL_REPORTS;
----------------------------------------------------------------------------------------
-- As per MPUD4.0, report name will named as follows:
-- Statement Report - "segment"_"type"_"participant name"_"date".CSV
--                    or "segment"_"type"_"participant name"_"date"("n").csv
-- Participant Information Report - "Market"_PIR_"Participant"_"Type"_"Settlement Date".csv
-- Reallocation Agreement Report - "Market"_RAR_"Participant"_"Type"_"Date".csv
-- Invoice - INV_"Invoice Number"_"Participant"_"Invoice Date".xml
--
-- 29.nov.2007,jbc:
-- Per MPUD5, general public reports are named
-- <market>_<report type>_<statement type>_YYYY-MM-DD.csv
-- where <market> is EN or CA, <report_type> is MGR, MFR, or MIR, and <statement type> is P or F.
-- Fixes BZ 15120.
--
-- This procedure will parse and validate the report name to retrieve the statement type
-- and the version number.
PROCEDURE PARSE_AND_VALIDATE_REP_NAME
  (
  p_REPORT_NAME IN VARCHAR2,
  p_REPORT_TYPE OUT BINARY_INTEGER,
    p_REPORT_STATEMENT_TYPE_ID OUT STATEMENT_TYPE.STATEMENT_TYPE_ID%TYPE,
    p_IS_VALID_REPORT_NAME OUT BOOLEAN,
    p_LOGGER IN OUT NOCOPY MM_LOGGER_ADAPTER
  ) AS
    v_TOKS GA.STRING_TABLE;
    v_REV_TOKS GA.STRING_TABLE;
    v_REPORT_STATEMENT_TYPE VARCHAR2(32);
    v_VERSION_NUMBER VARCHAR2(32) := NULL;
    v_DATE_FORMAT VARCHAR(10) := 'YYYY-MM-DD';

    ------------------------------------------------
    FUNCTION IS_VALID_TYPE
    (
        p_TYPE    IN VARCHAR2
    ) RETURN BOOLEAN IS
    BEGIN
       IF LENGTH(p_TYPE) = 1 AND UPPER(p_TYPE) IN ('P','F') THEN
          RETURN TRUE;
       ELSE
          p_LOGGER.LOG_ERROR('File name <' || p_REPORT_NAME|| '> indicates wrong Settlement Type code, expecting P or F but found ' || p_TYPE || '.');
          RETURN FALSE;
       END IF;
    END IS_VALID_TYPE;
    ------------------------------------------------
    FUNCTION IS_VALID_REVISION
    (
        p_REVISION    IN VARCHAR2
    ) RETURN BOOLEAN IS
    v_REV NUMBER;
    BEGIN
        BEGIN
            v_REV := TO_NUMBER(p_REVISION);
        EXCEPTION
            WHEN OTHERS THEN
                p_LOGGER.LOG_ERROR('File name <' || p_REPORT_NAME|| '> indicates invalid verison number.');
                RETURN FALSE;
        END;
        RETURN TRUE;
    END IS_VALID_REVISION;
    ------------------------------------------------

BEGIN
    p_IS_VALID_REPORT_NAME := FALSE;
  UT.TOKENS_FROM_STRING(p_REPORT_NAME, '_', v_TOKS);

    -- Get information from the report name and validate
    IF UPPER(v_TOKS(1)) = 'INV' THEN
        p_REPORT_TYPE := g_INVOICE_REPORT;
        v_REPORT_STATEMENT_TYPE := MM_SEM_UTIL.g_EXTID_SETTLEMENT_F;
        p_IS_VALID_REPORT_NAME := TRUE;
    ELSIF UPPER(v_TOKS(1)) = 'CCR' THEN
        p_REPORT_TYPE := g_CREDIT_REPORT;
        v_REPORT_STATEMENT_TYPE := MM_SEM_UTIL.g_EXTID_SETTLEMENT_F;
        p_IS_VALID_REPORT_NAME := TRUE;
    ELSIF UPPER(v_TOKS(2)) = 'PIR' THEN
        p_REPORT_TYPE := g_PARTICIPANT_INFO_REPORT;

        --Market Participant name can have an underscore,
        --Retrieve the statement type code second to last from the file name
        v_REPORT_STATEMENT_TYPE := v_TOKS(v_TOKS.LAST-1);

        -- 2-apr-2008, jbc: Workaround for market brain-deadedness. If a PIR has a revision number
        -- at the end (like EN_PIR_PT_500031_F_2007-11-04(1).CSV), then that should get treated as a
        -- resettlement PIR, and imported into the corresponding revision statement type. The code to get
        -- the revision number is the same as is used for the statement report. Fix for BZ 15582.
        --p_IS_VALID_REPORT_NAME := IS_VALID_TYPE(v_REPORT_STATEMENT_TYPE);
        UT.TOKENS_FROM_STRING(v_TOKS(v_TOKS.LAST), '.', v_REV_TOKS);
        IF LENGTH(v_REV_TOKS(1)) > LENGTH(v_DATE_FORMAT) THEN
            v_VERSION_NUMBER := SUBSTR(v_REV_TOKS(1),INSTR(v_REV_TOKS(1),'(')+1, INSTR(v_REV_TOKS(1),')') - INSTR(v_REV_TOKS(1),'(') - 1);
            p_IS_VALID_REPORT_NAME := IS_VALID_TYPE(v_REPORT_STATEMENT_TYPE) AND IS_VALID_REVISION(v_VERSION_NUMBER);
        ELSE
            p_IS_VALID_REPORT_NAME := IS_VALID_TYPE(v_REPORT_STATEMENT_TYPE);
        END IF;
    ELSIF UPPER(v_TOKS(2)) = 'RAR' THEN
        p_REPORT_TYPE := g_REALLOCATION_REPORT;

        --Market Participant name can have an underscore,
        --Retrieve the statement type code second to last from the file name
        v_REPORT_STATEMENT_TYPE := v_TOKS(v_TOKS.LAST-1);

        p_IS_VALID_REPORT_NAME := TRUE;
    ELSIF UPPER(v_TOKS(2)) IN ('MFR', 'MGR', 'MIR') THEN
        p_REPORT_TYPE := g_GENERAL_PUBLIC_REPORT;
        v_REPORT_STATEMENT_TYPE := v_TOKS(v_TOKS.LAST-1);
        --Get the Revision number
        UT.TOKENS_FROM_STRING(v_TOKS(v_TOKS.LAST), '.', v_REV_TOKS);
        IF LENGTH(v_REV_TOKS(1)) > LENGTH(v_DATE_FORMAT) THEN
          v_VERSION_NUMBER := SUBSTR(v_REV_TOKS(1),INSTR(v_REV_TOKS(1),'(')+1, INSTR(v_REV_TOKS(1),')') - INSTR(v_REV_TOKS(1),'(') - 1);
          p_IS_VALID_REPORT_NAME := IS_VALID_TYPE(v_REPORT_STATEMENT_TYPE) AND IS_VALID_REVISION(v_VERSION_NUMBER);
        ELSE
          p_IS_VALID_REPORT_NAME := IS_VALID_TYPE(v_REPORT_STATEMENT_TYPE);
        END IF;
  -- Is this Cancelled Reallaction Report?
  ELSIF UPPER(v_TOKS(1)) = 'CRR' THEN
    p_REPORT_TYPE := c_CANCELLED_SRA_REPORT;
    p_IS_VALID_REPORT_NAME := TRUE;
    -- For Statement, first token 'Segment' should match the Product's external system Identifier.
    ELSIF EI.GET_ID_FROM_IDENTIFIER_EXTSYS(UPPER(v_TOKS(1)), EC.ED_PRODUCT, EC.ES_SEM, EI.g_DEFAULT_IDENTIFIER_TYPE, 1) IS NOT NULL THEN
        p_REPORT_TYPE := g_STATEMENT_REPORT;
        v_REPORT_STATEMENT_TYPE := v_TOKS(2);
        --Get the Revision number
        UT.TOKENS_FROM_STRING(v_TOKS(v_TOKS.LAST), '.', v_REV_TOKS);
        IF LENGTH(v_REV_TOKS(1)) > LENGTH(v_DATE_FORMAT) THEN
            v_VERSION_NUMBER := SUBSTR(v_REV_TOKS(1),INSTR(v_REV_TOKS(1),'(')+1, INSTR(v_REV_TOKS(1),')') - INSTR(v_REV_TOKS(1),'(') - 1);
            p_IS_VALID_REPORT_NAME := IS_VALID_TYPE(v_REPORT_STATEMENT_TYPE) AND IS_VALID_REVISION(v_VERSION_NUMBER);
        ELSE
            p_IS_VALID_REPORT_NAME := IS_VALID_TYPE(v_REPORT_STATEMENT_TYPE);
        END IF;
    -- Ignore Cancellation SRA report
    ELSE
        p_REPORT_TYPE := g_UNKNOWN_REPORT;
        p_IS_VALID_REPORT_NAME := FALSE;
    END IF;

    -- Get the statement type id only if the report name is valid
    IF p_IS_VALID_REPORT_NAME AND p_REPORT_TYPE <> c_CANCELLED_SRA_REPORT THEN
       p_REPORT_STATEMENT_TYPE_ID := MM_UTIL.DETERMINE_STATEMENT_TYPE(v_REPORT_STATEMENT_TYPE, v_VERSION_NUMBER, EC.ES_SEM, MM_SEM_UTIL.g_STATEMENT_TYPE_SETTLEMENT);
    END IF;
END PARSE_AND_VALIDATE_REP_NAME;
----------------------------------------------------------------------------------------
FUNCTION GET_REPORT_CONTENTS
  (
  p_DATE IN DATE,
  p_REPORT_NAME IN VARCHAR2,
  p_CRED IN MEX_CREDENTIALS,
  p_LOGGER IN OUT NOCOPY MM_LOGGER_ADAPTER
  ) RETURN CLOB IS
v_REQUEST   VARCHAR2(4000);
v_RESULT  MEX_Result;
BEGIN
  p_LOGGER.EXCHANGE_NAME := SUBSTR('Download settlement report '||p_REPORT_NAME,1,64);

  v_REQUEST := '<?xml version="1.0" encoding="UTF-8" ?><file name="'||p_REPORT_NAME||'" date="'||TO_CHAR(p_DATE,MM_SEM_UTIL.g_DATE_FORMAT)||'" />';
  v_RESULT := MEX_Switchboard.Invoke(MM_SEM_UTIL.g_MEX_MARKET, MM_SEM_UTIL.g_MEX_ACTION_SETTLEMENT_FILE, p_LOGGER, p_CRED,
                    p_REQUEST_CONTENTTYPE => 'text/xml', p_REQUEST => v_REQUEST);

  IF v_RESULT.STATUS_CODE <> MEX_Switchboard.c_Status_Success THEN
    RETURN NULL; -- this indicates failure - MEX_Switchboard.Invoke will have already logged error message
  ELSE
    RETURN v_RESULT.RESPONSE;
  END IF;
END GET_REPORT_CONTENTS;
----------------------------------------------------------------------------------------
FUNCTION GET_CCR_REVISION(p_FILE_NAME IN VARCHAR2) RETURN NUMBER IS
v_RET NUMBER(3) := 0;
BEGIN

  --extract first the (x) and then the x version number
  v_RET := NVL(REGEXP_SUBSTR((REGEXP_SUBSTR(p_FILE_NAME, '\([0-9]+\)')), '[0-9]+'), 0);

  --update the SEM_CCR_VERSION_INFO table with this version
  MERGE INTO SEM_CCR_VERSION_INFO S
    USING (SELECT v_RET VERSION_ID,
                  CASE v_RET WHEN 0 THEN 'Base' ELSE 'Version ' || TO_CHAR(v_RET) END VERSION_NAME
        FROM DUAL) A
    ON (A.VERSION_ID = S.VERSION_ID AND A.VERSION_NAME = S.VERSION_NAME)
    WHEN NOT MATCHED THEN
      INSERT
        (VERSION_ID,
         VERSION_NAME)
      VALUES
        (v_RET,
         CASE v_RET WHEN 0 THEN 'Base' ELSE 'Version ' || TO_CHAR(v_RET) END);

  RETURN v_RET;

END GET_CCR_REVISION;
--------------------------------------------------------------------------------------------
PROCEDURE IMPORT_CREDIT_REPORT
    (
  p_REPORT IN CLOB,
  p_REPORT_NAME IN VARCHAR2,
  p_LOGGER IN OUT NOCOPY MM_LOGGER_ADAPTER
    ) IS

v_IDX BINARY_INTEGER;
v_REC_TYPE  CHAR(2);
v_LINES   PARSE_UTIL.BIG_STRING_TABLE_MP;
v_ELEMENTS   PARSE_UTIL.STRING_TABLE;
v_TABLE_REC SEM_TYPE3_CREDIT_COVER_REPORT%ROWTYPE;
v_D2_TABLE_REC SEM_CREDIT_CALC_EXTERNAL%ROWTYPE;
v_PUBLICATION_DATE DATE;
v_VERSION_NUMBER NUMBER(3);
c_DATE_FORMAT_V3 VARCHAR2(10) := 'YYYY-MM-DD';
c_TIMESTAMP_FORMAT_V3 CONSTANT VARCHAR2(24) := 'YYYY-MM-DD HH24:MI:SS';
c_DATE_FORMAT_V2 VARCHAR2(10) := 'DD/MM/YYYY';
c_TIMESTAMP_FORMAT_V2 CONSTANT VARCHAR2(24) := 'DD/MM/YYYY HH24:MI';
v_DATE_FORMAT   VARCHAR2(10);
v_TIMESTAMP_FORMAT VARCHAR2(24);
v_VERSION_LAYOUT NUMBER(3);
v_CODE_PARTICIPANT_ID VARCHAR2(100);

BEGIN
  ----BZ 17535 - Download the Type 3 CCR with other settlement reports rather than MPI
  --get the version number out of the report name
  v_VERSION_NUMBER := GET_CCR_REVISION(p_REPORT_NAME);

  --Get the Code Participant Id from the file name and not from the header
  --get first the _PT_xxxxxx_ and then PT_xxxxxx
  v_CODE_PARTICIPANT_ID := REGEXP_SUBSTR(p_REPORT_NAME,'_[^_]+_[^_]+_');
  v_CODE_PARTICIPANT_ID := SUBSTR(v_CODE_PARTICIPANT_ID, 2, length(v_CODE_PARTICIPANT_ID)-2);

  --if version 002 and this is a revised CCR report,
  --then the revision number is attached at the end of code part id; PT_xxxxxx(z)
  --remove revision number (z) from code participant id
  --version 003 has the revision number attached after the date
  IF INSTR(v_CODE_PARTICIPANT_ID, '(') > 0  THEN
    v_CODE_PARTICIPANT_ID := SUBSTR(v_CODE_PARTICIPANT_ID, 1, INSTR(v_CODE_PARTICIPANT_ID, '(') -1);
  END IF;

    BEGIN
        v_TABLE_REC.ENTITY_GROUP_ID := EI.GET_ID_FROM_IDENTIFIER_EXTSYS(v_CODE_PARTICIPANT_ID, EC.ED_ENTITY_GROUP, EC.ES_SEM);
    EXCEPTION
    WHEN OTHERS THEN
        LOGS.LOG_INFO_MORE_DETAIL('Entity Group ' || v_CODE_PARTICIPANT_ID || ' does not exist.');
        RETURN;
    END;

  PARSE_UTIL.PARSE_CLOB_INTO_LINES(p_REPORT, v_LINES);
  v_IDX := v_LINES.FIRST;
  WHILE v_LINES.EXISTS(v_IDX) LOOP
      IF TRIM(v_LINES(v_IDX)) IS NOT NULL THEN -- ignore blank lines
        PARSE_UTIL.PARSE_DELIMITED_STRING(v_LINES(v_IDX), ',', v_ELEMENTS);
        v_REC_TYPE := v_ELEMENTS(1);

        CASE v_REC_TYPE
        /*******************************************************************
         H
        *******************************************************************/
        WHEN 'H' THEN
        --Parse the version layout out of the header (field 2)
        --and set the date and timestamp per version (DD/MM/YYYY in 002 or YYYY-MM-DD for 003 or 004).
        BEGIN
          v_VERSION_LAYOUT := TO_NUMBER(v_ELEMENTS(2));
          IF v_VERSION_LAYOUT = 2 THEN
            v_DATE_FORMAT := c_DATE_FORMAT_V2;
            v_TIMESTAMP_FORMAT := c_TIMESTAMP_FORMAT_V2;
          ELSIF v_VERSION_LAYOUT = 3 OR v_VERSION_LAYOUT = 4 THEN
            v_DATE_FORMAT := c_DATE_FORMAT_V3;
            v_TIMESTAMP_FORMAT := c_TIMESTAMP_FORMAT_V3;
          ELSE
            --wrong version number for the file layout.
            --this number is expected to be 002 or 003
            p_LOGGER.LOG_ERROR('Header Record (H) contained unknown file version layout "'
                       || v_VERSION_LAYOUT || '"; expected "002" or "003". Process aborted.');
            EXIT;
          END IF;
        EXCEPTION
          WHEN OTHERS THEN
            MM_SEM_UTIL.RAISE_ERR(-20000, 'Header Record (H): Invalid number "' ||v_ELEMENTS(2)|| '" for file version layout;'
                             ||' expected 002, 003, or 004. Process aborted.');
        END;

        v_TABLE_REC.ASSESSMENT_DATE := TO_DATE(v_ELEMENTS(6), v_DATE_FORMAT);
        v_TABLE_REC.STATEMENT_STATE := GA.EXTERNAL_STATE;

        --DELETE records for this date/entity_group_id/statement_state/version
        DELETE FROM SEM_TYPE3_CREDIT_COVER_REPORT
        WHERE ASSESSMENT_DATE = v_TABLE_REC.ASSESSMENT_DATE
          AND ENTITY_GROUP_ID = v_TABLE_REC.ENTITY_GROUP_ID
          AND STATEMENT_STATE = v_TABLE_REC.STATEMENT_STATE
          AND VERSION = v_VERSION_NUMBER;

        DELETE SEM_CREDIT_CALC_EXTERNAL
        WHERE ASSESSMENT_DATE = v_TABLE_REC.ASSESSMENT_DATE
          AND ENTITY_GROUP_ID = v_TABLE_REC.ENTITY_GROUP_ID
          AND VERSION = v_VERSION_NUMBER;

        --maintain multiple versions of CCR issued for a particular date
        v_PUBLICATION_DATE := TO_DATE(v_ELEMENTS(4), v_TIMESTAMP_FORMAT);

        /*******************************************************************
         S
        *******************************************************************/
        WHEN 'S' THEN
          v_TABLE_REC.RECORD_TYPE := v_REC_TYPE;
          v_TABLE_REC.PSE_ID := 0;

          IF v_VERSION_LAYOUT = 2 THEN
            v_TABLE_REC.UNIT_TYPE := v_ELEMENTS(3);
            v_TABLE_REC.CURRENCY := v_ELEMENTS(5);
            v_TABLE_REC.REQD_CREDIT_COVER := TO_NUMBER(v_ELEMENTS(6));
            v_TABLE_REC.POSTED_CREDIT_COVER := TO_NUMBER(v_ELEMENTS(7));
            v_TABLE_REC.WARNING_LIMIT := TO_NUMBER(v_ELEMENTS(8));
            v_TABLE_REC.WARNING_LIMIT_REACHED := v_ELEMENTS(9);
            v_TABLE_REC.BREACH_AMOUNT := TO_NUMBER(v_ELEMENTS(10));
          ELSIF v_VERSION_LAYOUT = 3 THEN
            --even the Status has been dropped out of v003
            --it is still part of the PK in SEM_TYPE3_CREDIT_COVER_REPORT table
            --so we need to write non-null values
            v_TABLE_REC.UNIT_TYPE := 'NULL';
            v_TABLE_REC.CURRENCY := v_ELEMENTS(3);
            v_TABLE_REC.REQD_CREDIT_COVER := TO_NUMBER(v_ELEMENTS(4));
            v_TABLE_REC.POSTED_CREDIT_COVER := TO_NUMBER(v_ELEMENTS(5));
            v_TABLE_REC.WARNING_LIMIT := TO_NUMBER(v_ELEMENTS(6));
            v_TABLE_REC.WARNING_LIMIT_REACHED := v_ELEMENTS(7);
            v_TABLE_REC.BREACH_AMOUNT := TO_NUMBER(v_ELEMENTS(8));
          ELSIF v_VERSION_LAYOUT = 4 THEN
            -- fields that remain the same/in the same position from v003 to v004
            -- not sure if the following was meant to be NULL without quotes
            -- keeping status quo
            v_TABLE_REC.UNIT_TYPE := 'NULL';
            -- fields that have changed position for v004
            v_TABLE_REC.CURRENCY := v_ELEMENTS(5);
            v_TABLE_REC.REQD_CREDIT_COVER := TO_NUMBER(v_ELEMENTS(7));
            v_TABLE_REC.POSTED_CREDIT_COVER := TO_NUMBER(v_ELEMENTS(6));
            v_TABLE_REC.BREACH_AMOUNT := TO_NUMBER(v_ELEMENTS(4));
            -- fields that have been removed
            -- WARNING_LIMIT AND WARNING_LIMIT_REACHED have been removed in v004
            -- new fields in v004
            v_TABLE_REC.CCIN_BREACH_FLAG := v_ELEMENTS(3);
            v_TABLE_REC.ACC := TO_NUMBER(v_ELEMENTS(8));
          END IF;

          v_TABLE_REC.MARKET := 'NULL';
          v_TABLE_REC.TIME_STAMP := v_PUBLICATION_DATE;
          v_TABLE_REC.VERSION := v_VERSION_NUMBER;

          INSERT INTO SEM_TYPE3_CREDIT_COVER_REPORT VALUES v_TABLE_REC;

        /*******************************************************************
         D0
        *******************************************************************/
        WHEN 'D0' THEN
          v_TABLE_REC.RECORD_TYPE := v_REC_TYPE;
          v_TABLE_REC.PSE_ID := EI.GET_ID_FROM_IDENTIFIER_EXTSYS(v_CODE_PARTICIPANT_ID, EC.ED_PSE, EC.ES_SEM);
          v_TABLE_REC.UNIT_TYPE := v_ELEMENTS(3);
          v_TABLE_REC.CURRENCY := v_ELEMENTS(4);
          v_TABLE_REC.REQD_CREDIT_COVER := TO_NUMBER(v_ELEMENTS(5));
          v_TABLE_REC.INVOICES_NOT_PAID := TO_NUMBER(v_ELEMENTS(6));
          v_TABLE_REC.SETTLMENT_NOT_INVOICED := TO_NUMBER(v_ELEMENTS(7));
          v_TABLE_REC.UNDEFINED_EXPOSURE := TO_NUMBER(v_ELEMENTS(8));
          IF v_VERSION_LAYOUT < 4 THEN
            v_TABLE_REC.REALLOCATIONS := TO_NUMBER(v_ELEMENTS(9));
            v_TABLE_REC.FIXED_CREDIT_COVER := TO_NUMBER(v_ELEMENTS(10));
            IF v_VERSION_LAYOUT = 3 THEN
              v_TABLE_REC.ADJUSTMENT_AMOUNT := TO_NUMBER(v_ELEMENTS(11));
            END IF;
          ELSIF v_VERSION_LAYOUT = 4 THEN
            -- these fields have been moved for v004
            v_TABLE_REC.REALLOCATIONS := TO_NUMBER(v_ELEMENTS(10));
            v_TABLE_REC.FIXED_CREDIT_COVER := TO_NUMBER(v_ELEMENTS(11));
            v_TABLE_REC.ADJUSTMENT_AMOUNT := TO_NUMBER(v_ELEMENTS(12));
            -- these fields are new for v004
            v_TABLE_REC.INTCONN_TRADED_AMT := TO_NUMBER(v_ELEMENTS(9));
          END IF;

          v_TABLE_REC.POSTED_CREDIT_COVER := NULL;
          v_TABLE_REC.WARNING_LIMIT := NULL;
          v_TABLE_REC.WARNING_LIMIT_REACHED := NULL;
          v_TABLE_REC.BREACH_AMOUNT := NULL;
          v_TABLE_REC.MARKET := 'NULL';
          v_TABLE_REC.Version := v_VERSION_NUMBER;

          INSERT INTO SEM_TYPE3_CREDIT_COVER_REPORT VALUES v_TABLE_REC;

        /*******************************************************************
         D1
        *******************************************************************/
        WHEN 'D1' THEN
          v_TABLE_REC.RECORD_TYPE := v_REC_TYPE;
          v_TABLE_REC.PSE_ID := EI.GET_ID_FROM_IDENTIFIER_EXTSYS(v_ELEMENTS(2), EC.ED_PSE, EC.ES_SEM);
          v_TABLE_REC.UNIT_TYPE := v_ELEMENTS(3);
          IF v_VERSION_LAYOUT = 2 THEN
            v_TABLE_REC.CURRENCY := v_ELEMENTS(4);
            v_TABLE_REC.MARKET := v_ELEMENTS(5);
            v_TABLE_REC.INVOICES_NOT_PAID := TO_NUMBER(v_ELEMENTS(6));
            v_TABLE_REC.SETTLMENT_NOT_INVOICED := TO_NUMBER(v_ELEMENTS(7));
            v_TABLE_REC.UNDEFINED_EXPOSURE := TO_NUMBER(v_ELEMENTS(8));
            v_TABLE_REC.REALLOCATIONS := TO_NUMBER(v_ELEMENTS(9));
            v_TABLE_REC.FIXED_CREDIT_COVER := CASE v_TABLE_REC.MARKET WHEN 'CA' THEN NULL ELSE TO_NUMBER(v_ELEMENTS(10)) END;
          ELSIF v_VERSION_LAYOUT = 3 THEN
            --BZ 17921 - Capture the Status information
            v_TABLE_REC.STATUS := v_ELEMENTS(4);
            v_TABLE_REC.CURRENCY := v_ELEMENTS(5);
            v_TABLE_REC.MARKET := v_ELEMENTS(6);
            v_TABLE_REC.INVOICES_NOT_PAID := TO_NUMBER(v_ELEMENTS(7));
            v_TABLE_REC.SETTLMENT_NOT_INVOICED := TO_NUMBER(v_ELEMENTS(8));
            v_TABLE_REC.UNDEFINED_EXPOSURE := TO_NUMBER(v_ELEMENTS(9));
            v_TABLE_REC.REALLOCATIONS := TO_NUMBER(v_ELEMENTS(10));
            v_TABLE_REC.FIXED_CREDIT_COVER := NULL;
          ELSIF v_VERSION_LAYOUT = 4 THEN
            v_TABLE_REC.STATUS := v_ELEMENTS(4);
            v_TABLE_REC.CURRENCY := v_ELEMENTS(5);
            v_TABLE_REC.MARKET := v_ELEMENTS(6);
            v_TABLE_REC.INVOICES_NOT_PAID := TO_NUMBER(v_ELEMENTS(7));
            v_TABLE_REC.SETTLMENT_NOT_INVOICED := TO_NUMBER(v_ELEMENTS(8));
            v_TABLE_REC.UNDEFINED_EXPOSURE := TO_NUMBER(v_ELEMENTS(9));
            -- these fields have been moved for v004
            v_TABLE_REC.REALLOCATIONS := TO_NUMBER(v_ELEMENTS(11));
            v_TABLE_REC.FIXED_CREDIT_COVER := NULL;
            -- these fields are new for v004
            v_TABLE_REC.INTCONN_TRADED_AMT := TO_NUMBER(v_ELEMENTS(10));
          END IF;

          v_TABLE_REC.REQD_CREDIT_COVER := NULL;
          v_TABLE_REC.VERSION := v_VERSION_NUMBER;

          INSERT INTO SEM_TYPE3_CREDIT_COVER_REPORT VALUES v_TABLE_REC;

        /*******************************************************************
         D2
        *******************************************************************/
        WHEN 'D2' THEN
          v_D2_TABLE_REC.ASSESSMENT_DATE := v_TABLE_REC.ASSESSMENT_DATE;
          v_D2_TABLE_REC.ENTITY_GROUP_ID := v_TABLE_REC.ENTITY_GROUP_ID;
          v_D2_TABLE_REC.CREDIT_MARKET := v_ELEMENTS(2);

          IF v_VERSION_LAYOUT < 4 THEN
            v_D2_TABLE_REC.UNDEFINED_PERIOD := TO_NUMBER(v_ELEMENTS(3));
            v_D2_TABLE_REC.ANALYSIS_PERCENTILE_PARAM := TO_NUMBER(v_ELEMENTS(4));
            v_D2_TABLE_REC.HIST_ASSESSMENT_PERIOD := TO_NUMBER(v_ELEMENTS(5));
            --BZ17922- Credit Assessment Price needs to be populated for all markets
            v_D2_TABLE_REC.CREDIT_ASSESSMENT_PRICE :=  TO_NUMBER(v_ELEMENTS(6));
          ELSIF v_VERSION_LAYOUT = 4 THEN
            v_D2_TABLE_REC.UNDEFINED_PERIOD := NULL;
            v_D2_TABLE_REC.UDEF_PERIOD_GEN := TO_NUMBER(v_ELEMENTS(3));
            v_D2_TABLE_REC.UDEF_PERIOD_SUPP := TO_NUMBER(v_ELEMENTS(4));
            v_D2_TABLE_REC.FORECAST_PRICE := TO_NUMBER(v_ELEMENTS(5));
            v_D2_TABLE_REC.CREDIT_ASSESSMENT_PRICE :=  TO_NUMBER(v_ELEMENTS(6));
            v_D2_TABLE_REC.ECPI :=  TO_NUMBER(v_ELEMENTS(7));
          END IF;

          IF v_VERSION_LAYOUT = 2 THEN
            v_D2_TABLE_REC.CAPACITY_ADJUSTMENT_FACTOR :=  CASE v_D2_TABLE_REC.CREDIT_MARKET WHEN 'CA' THEN NULL ELSE TO_NUMBER(v_ELEMENTS(7)) END;
          END IF;

          v_D2_TABLE_REC.TIME_STAMP := v_PUBLICATION_DATE;
          v_D2_TABLE_REC.VERSION := v_VERSION_NUMBER;

          INSERT INTO SEM_CREDIT_CALC_EXTERNAL VALUES v_D2_TABLE_REC;

        WHEN 'T' THEN
          NULL;
        ELSE
          NULL;
        END CASE;
      END IF;
    v_IDX := v_LINES.NEXT(v_IDX);
  END LOOP;

  COMMIT;
END IMPORT_CREDIT_REPORT;
--------------------------------------------------------------------------------------------
FUNCTION IS_CREDENTIAL_IN_DL_GROUP(p_CRED IN MEX_CREDENTIALS) RETURN BOOLEAN IS
  v_COUNT NUMBER;
BEGIN
  -- return true if this credential matches any download group meeting all of the criteria:
  --  - INCLUDE_IN_DL = 1
  --  - EXTERNAL_ACCOUNT_NAME is <ALL> or matches the external account name of the credential
  SELECT COUNT(*)
  INTO v_COUNT
  FROM SEM_DOWNLOAD_GROUP
  WHERE INCLUDE_IN_DL = 1
  AND EXTERNAL_ACCOUNT_NAME IN (p_CRED.EXTERNAL_ACCOUNT_NAME, '<ALL>');

  RETURN v_COUNT>0;
END IS_CREDENTIAL_IN_DL_GROUP;
----------------------------------------------------------------------------------------
FUNCTION ADD_REV_TO_FILENAME(
   p_FILENAME       IN VARCHAR2,
   p_STATEMENT_TYPE IN STATEMENT_TYPE.STATEMENT_TYPE_ID%TYPE,
   p_DL_GROUP_NAME  IN VARCHAR2
) RETURN VARCHAR2 IS
  v_NEW_FILENAME    VARCHAR2(128);
  v_REVISION_CID    VARCHAR2(32);
  v_STMNT_TYPE_ID   SEM_DOWNLOAD_GROUP.PIR_STATEMENT_TYPE_ID%TYPE;
BEGIN
  /*
        0. handle cases where we don't need to change the filename
        1. find the revision ID from the statement type for this d/l group
        2. look up the external ID for the statement type
        3. strip off the first character, and add the rest to the end of
            the file name (minus the extension)
        4. return the new filename
    */

  -- don't change the filename unless the statement type of the download group is F
  IF MM_SEM_UTIL.g_EXTID_SETTLEMENT_F !=
     EI.GET_ENTITY_IDENTIFIER_EXTSYS(EC.ED_STATEMENT_TYPE,
                             p_STATEMENT_TYPE,
                             EC.ES_SEM,
                             MM_SEM_UTIL.g_STATEMENT_TYPE_SETTLEMENT) THEN
    RETURN p_FILENAME;
  END IF;

  -- don't change the filename if we're not worrying about revised PIRs
  SELECT PIR_STATEMENT_TYPE_ID
    INTO v_STMNT_TYPE_ID
    FROM SEM_DOWNLOAD_GROUP
    WHERE GROUP_NAME = p_DL_GROUP_NAME;

  IF v_STMNT_TYPE_ID IS NULL THEN
    RETURN p_FILENAME;
  END IF;

  -- find the external identifier of the PIR statement type
  v_REVISION_CID := EI.GET_ENTITY_IDENTIFIER_EXTSYS(EC.ED_STATEMENT_TYPE,
                                        v_STMNT_TYPE_ID,
                                        EC.ES_SEM,
                                        MM_SEM_UTIL.g_STATEMENT_TYPE_SETTLEMENT);

  -- add the '(n)' part of the identifier to the filename
  v_NEW_FILENAME := SUBSTR(p_FILENAME, 1, INSTR(p_FILENAME, '.') - 1)
                || SUBSTR(v_REVISION_CID, 2)
                || SUBSTR(p_FILENAME, INSTR(p_FILENAME, '.'));

  RETURN v_NEW_FILENAME;

END ADD_REV_TO_FILENAME;
----------------------------------------------------------------------------------------
FUNCTION GET_DL_GROUP_FOR_REPORT(p_REPORT_FILE_NAME IN VARCHAR2,
                 p_REPORT_TYPE IN VARCHAR2,
                 p_STATEMENT_TYPE_ID IN NUMBER,
                 p_EXTERNAL_ACCOUNT_NAME IN VARCHAR2) RETURN VARCHAR2 IS
  v_MARKET_TYPE VARCHAR2(128);
  v_REPORT_TYPE_ABBR VARCHAR2(32);
  v_TOKS GA.STRING_TABLE;
  v_GROUP_NAME  SEM_DOWNLOAD_GROUP.GROUP_NAME%TYPE;
BEGIN
  -- map the report type we get from the filename (p_REPORT_TYPE) to the value in the download groups table (v_REPORT_TYPE)
  UT.TOKENS_FROM_STRING(p_REPORT_FILE_NAME, '_', v_TOKS);
  IF p_REPORT_TYPE = g_STATEMENT_REPORT THEN
    --Jan 14, 2009, LD - Bug reported by PPB and Supply that Settlement Download Groups functionality is
    --not working for statement reports downloads
    --the report type for Statement reports needs to be 'Statement' and not 'STMNT'
    v_REPORT_TYPE_ABBR := 'Statement';
  ELSIF p_REPORT_TYPE IN
      (g_PARTICIPANT_INFO_REPORT, g_REALLOCATION_REPORT, g_GENERAL_PUBLIC_REPORT) THEN
    v_REPORT_TYPE_ABBR := UPPER(v_TOKS(2));
  ELSE
    v_REPORT_TYPE_ABBR := UPPER(v_TOKS(1));
  END IF;

  -- we only care about the market type for statements, PIRs, RARs, and GP reports
  v_MARKET_TYPE := NULL;
  IF p_REPORT_TYPE IN (g_STATEMENT_REPORT, g_PARTICIPANT_INFO_REPORT, g_REALLOCATION_REPORT,
    g_GENERAL_PUBLIC_REPORT) THEN
    -- we can get the market type from the first two letters of the filename
    BEGIN
      SELECT SETTING_NAME
      INTO v_MARKET_TYPE
      FROM SYSTEM_DICTIONARY
      WHERE MODULE = 'MarketExchange'
      AND KEY1 = 'SEM'
      AND KEY2 = 'Settlement'
      AND KEY3 = 'Invoice Markets'
      AND UPPER(SUBSTR(VALUE, 1, 2)) = UPPER(SUBSTR(p_REPORT_FILE_NAME, 1, 2));
    EXCEPTION WHEN NO_DATA_FOUND THEN
      NULL;
    END;
  END IF;

  -- now we can get the first group name with conditions satisfying the report
  BEGIN
    IF p_REPORT_TYPE = g_INVOICE_REPORT THEN
      SELECT GROUP_NAME
      INTO v_GROUP_NAME
      FROM SEM_DOWNLOAD_GROUP
      WHERE INCLUDE_IN_DL = 1
      AND REPORT_TYPE = 'Invoice'
      AND EXTERNAL_ACCOUNT_NAME IN (p_EXTERNAL_ACCOUNT_NAME, '<ALL>')
      AND ROWNUM = 1;
    ELSE
      SELECT GROUP_NAME
      INTO v_GROUP_NAME
      FROM SEM_DOWNLOAD_GROUP
      WHERE INCLUDE_IN_DL = 1
      AND REPORT_TYPE IN (v_REPORT_TYPE_ABBR, '<ALL>')
      AND NVL(STATEMENT_TYPE_ID, p_STATEMENT_TYPE_ID) = p_STATEMENT_TYPE_ID
      AND EXTERNAL_ACCOUNT_NAME IN (p_EXTERNAL_ACCOUNT_NAME, '<ALL>')
      AND MARKET_TYPE IN (v_MARKET_TYPE, '<ALL>')
      AND ROWNUM = 1;
    END IF;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      v_GROUP_NAME := NULL;
  END;

  RETURN v_GROUP_NAME;
END GET_DL_GROUP_FOR_REPORT;
----------------------------------------------------------------------------------------
PROCEDURE DOWNLOAD_SETTLEMENT_REPORTS
  (
  p_BEGIN_DATE IN DATE,
  p_END_DATE IN DATE,
  p_FORCE_DOWNLOAD IN BOOLEAN,
  p_CRED IN MEX_CREDENTIALS,
  p_LOGGER IN OUT NOCOPY MM_LOGGER_ADAPTER,
  p_USE_DL_GROUPS IN NUMBER
  ) AS

v_REPORTS STRING_COLLECTION;
v_IDX BINARY_INTEGER;
v_REPORT CLOB;
v_RPT_TYPE BINARY_INTEGER;
v_STATEMENT_TYPE STATEMENT_TYPE.STATEMENT_TYPE_ID%TYPE;
v_DATE DATE := TRUNC(p_BEGIN_DATE);
v_ALERT_NAME VARCHAR2(32);
v_VALID_REPORT_NAME BOOLEAN;
v_DOWNLOAD_IT BOOLEAN;
v_COUNT BINARY_INTEGER;
v_PARMS UT.STRING_MAP;
v_IMPORT_SOURCE BINARY_INTEGER;
v_DOWNLOAD_GROUP_NAME SEM_DOWNLOAD_GROUP.GROUP_NAME%TYPE;
v_RTO_WORK_SEQ NUMBER(9);

BEGIN
  -- notify any hooks
   p_LOGGER.EXCHANGE_NAME := 'Downloading Settlement Files';
  XS.PRE_MARKET_EXCHANGE(EC.ES_SEM, p_LOGGER.EXCHANGE_NAME, UT.c_EMPTY_MAP, NULL, p_LOGGER);

  IF p_FORCE_DOWNLOAD OR p_USE_DL_GROUPS = 1 THEN
    v_IMPORT_SOURCE := g_IMPORT_SOURCE_FORCED_QUERY;
  ELSE
    v_IMPORT_SOURCE := g_IMPORT_SOURCE_QUERY;
  END IF;

  IF p_USE_DL_GROUPS = 1 THEN
    SELECT MAX(WORK_SEQ)+1
    INTO v_RTO_WORK_SEQ
    FROM RTO_WORK
    WHERE WORK_ID = g_WORK_ID_FOR_DL_GROUPS;
  ELSE
    v_RTO_WORK_SEQ := 1;
  END IF;

  -- loop through date range and download all files that have not yet been downloaded
  WHILE v_DATE <= p_END_DATE LOOP
    v_REPORTS := GET_AVAIL_REPORTS(v_DATE, p_CRED, p_LOGGER);

    IF v_REPORTS IS NOT NULL THEN -- if it is null then error occurred and GET_AVAIL_REPORTS logged it
                    -- so keep going
        v_IDX := v_REPORTS.FIRST;
        WHILE v_REPORTS.EXISTS(v_IDX) LOOP
        PARSE_AND_VALIDATE_REP_NAME(v_REPORTS(v_IDX), v_RPT_TYPE, v_STATEMENT_TYPE, v_VALID_REPORT_NAME, p_LOGGER);

        v_DOWNLOAD_IT := v_VALID_REPORT_NAME AND NVL(v_RPT_TYPE,g_UNKNOWN_REPORT) IN (g_STATEMENT_REPORT, g_PARTICIPANT_INFO_REPORT, g_REALLOCATION_REPORT, g_INVOICE_REPORT, g_CREDIT_REPORT, g_GENERAL_PUBLIC_REPORT, c_CANCELLED_SRA_REPORT);

        v_DOWNLOAD_GROUP_NAME := NULL;
        IF p_USE_DL_GROUPS = 1 AND v_DOWNLOAD_IT THEN
          v_DOWNLOAD_GROUP_NAME := GET_DL_GROUP_FOR_REPORT(v_REPORTS(v_IDX), v_RPT_TYPE, v_STATEMENT_TYPE, p_CRED.EXTERNAL_ACCOUNT_NAME);
          v_DOWNLOAD_IT := v_DOWNLOAD_IT AND v_DOWNLOAD_GROUP_NAME IS NOT NULL;
        END IF;

        IF NOT v_DOWNLOAD_IT THEN
          IF p_USE_DL_GROUPS = 0 THEN
            p_LOGGER.LOG_WARN('Unknown settlement report type: '||v_REPORTS(v_IDX));
          ELSE
            p_LOGGER.LOG_DEBUG('Report matches no d/l group: ' || v_REPORTS(v_IDX));
          END IF;
        ELSIF NOT p_FORCE_DOWNLOAD THEN
          IF p_USE_DL_GROUPS = 0 THEN
            -- only download it if we have not already
            SELECT COUNT(1)
            INTO v_COUNT
            FROM SEM_SETTLEMENT_DOWNLOADS
            WHERE STATEMENT_DATE = v_DATE
              AND FILE_NAME = UPPER(v_REPORTS(v_IDX));
          ELSE
            -- download groups should always download it, but only download it once
            SELECT COUNT(1)
            INTO v_COUNT
            FROM RTO_WORK
            WHERE WORK_ID = g_WORK_ID_FOR_DL_GROUPS
            AND WORK_DATA = UPPER(v_REPORTS(v_IDX));
          END IF;

          v_DOWNLOAD_IT := v_DOWNLOAD_IT AND v_COUNT = 0;
          IF v_COUNT <> 0 THEN
            LOGS.LOG_INFO_MORE_DETAIL('Skipping file "'||v_REPORTS(v_IDX)||'" - it has already been downloaded');
          END IF;
        END IF;

        IF v_DOWNLOAD_IT THEN

          v_REPORT := GET_REPORT_CONTENTS(v_DATE, v_REPORTS(v_IDX), p_CRED, p_LOGGER);

          IF v_REPORT IS NOT NULL THEN -- if it is null then error occurred and GET_REPORT_CONTENTS logged it
                         -- so keep going

            IF v_DOWNLOAD_GROUP_NAME IS NOT NULL AND (v_RPT_TYPE = g_PARTICIPANT_INFO_REPORT OR
                                                            v_RPT_TYPE = g_GENERAL_PUBLIC_REPORT ) THEN
              v_REPORTS(v_IDX) := ADD_REV_TO_FILENAME(v_REPORTS(v_IDX), v_STATEMENT_TYPE, v_DOWNLOAD_GROUP_NAME);
              PARSE_AND_VALIDATE_REP_NAME(v_REPORTS(v_IDX), v_RPT_TYPE, v_STATEMENT_TYPE, v_VALID_REPORT_NAME, p_LOGGER);
            END IF;

            v_PARMS(g_HOOK_PARM_SETTLEMENT_FILE) := v_REPORTS(v_IDX);
            XS.PRE_MARKET_EXCHANGE(EC.ES_SEM, p_LOGGER.EXCHANGE_NAME, v_PARMS, v_REPORT, p_LOGGER);

            -- insert into our download history
            UPDATE SEM_SETTLEMENT_DOWNLOADS
              SET ENTRY_DATE = SYSDATE,
                EVENT_ID = p_LOGGER.LAST_EVENT_ID
            WHERE STATEMENT_DATE = v_DATE
              AND FILE_NAME = UPPER(v_REPORTS(v_IDX));
            IF SQL%NOTFOUND THEN
              INSERT INTO SEM_SETTLEMENT_DOWNLOADS (STATEMENT_DATE, FILE_NAME, EVENT_ID, ENTRY_DATE)
              VALUES (v_DATE, UPPER(v_REPORTS(v_IDX)), p_LOGGER.LAST_EVENT_ID, SYSDATE);
            END IF;

            -- cache the filename so we only get it once
            IF p_USE_DL_GROUPS = 1 THEN
              UT.POST_RTO_WORK(g_WORK_ID_FOR_DL_GROUPS, v_RTO_WORK_SEQ, UPPER(v_REPORTS(v_IDX)));
              v_RTO_WORK_SEQ := v_RTO_WORK_SEQ + 1;
            END IF;

            BEGIN

              CASE v_RPT_TYPE
              WHEN g_STATEMENT_REPORT THEN
                v_ALERT_NAME := g_ALERT_NAME_SETTL_REP;
                IMPORT_STATEMENT_REPORT(v_REPORT, p_LOGGER, v_STATEMENT_TYPE);
              WHEN g_PARTICIPANT_INFO_REPORT THEN
                v_ALERT_NAME := g_ALERT_NAME_SETTL_PIR;
                IMPORT_PARTICIPANT_INFO_REPORT(v_REPORTS(v_IDX), v_REPORT, p_LOGGER, v_STATEMENT_TYPE);
              WHEN g_REALLOCATION_REPORT THEN
                v_ALERT_NAME := g_ALERT_NAME_SETTL_RAR;
                IMPORT_REALLOCATION_REPORT(v_REPORTS(v_IDX), v_REPORT, p_LOGGER, v_STATEMENT_TYPE);
              WHEN g_INVOICE_REPORT THEN
                v_ALERT_NAME := g_ALERT_NAME_SETTL_INV;
                IMPORT_INVOICE_REPORT(v_IMPORT_SOURCE, v_REPORT, p_LOGGER);
              WHEN g_CREDIT_REPORT THEN
                v_ALERT_NAME := g_ALERT_NAME_SETTL_CREDIT;
                IMPORT_CREDIT_REPORT(v_REPORT, v_REPORTS(v_IDX), p_LOGGER);
              WHEN g_GENERAL_PUBLIC_REPORT THEN
                IMPORT_GENERAL_PUBLIC_REPORT(v_REPORTS(v_IDX), v_REPORT, p_LOGGER, v_STATEMENT_TYPE);
              WHEN c_CANCELLED_SRA_REPORT THEN
                IMPORT_CANCELLED_SRA_REPORT(v_REPORTS(v_IDX), v_REPORT, p_LOGGER);
              END CASE;

              COMMIT; -- commit after each report
              SAVEPOINT BEFORE_IMPORT; -- and then redefine savepoint

              -- Raise Alert
              MM_SEM_UTIL.RAISE_ALERTS(p_TYPE => g_ALERT_TYPE_SETTL,
                         p_NAME => v_ALERT_NAME,
                         p_LOGGER => p_LOGGER,
                         p_MSG => 'Complete download of ' || v_ALERT_NAME);
            EXCEPTION
              WHEN OTHERS THEN
                -- error message will have already been logged by above procedures
                -- so just rollback any updates from unsuccessful import
                ROLLBACK TO BEFORE_IMPORT;
                 -- Raise Alert
                MM_SEM_UTIL.RAISE_ALERTS(p_TYPE => g_ALERT_TYPE_SETTL,
                     p_NAME => v_ALERT_NAME,
                     p_LOGGER => p_LOGGER,
                     p_MSG => 'Error downloading ' || v_ALERT_NAME,
                     p_FATAL => TRUE);
            END;
          END IF;

        END IF;

          v_IDX := v_REPORTS.NEXT(v_IDX);
        END LOOP;
    END IF;

    v_DATE := v_DATE+1;
  END LOOP;

  -- notify any hooks
   p_LOGGER.EXCHANGE_NAME := 'Downloading Settlement Files';
  XS.POST_MARKET_EXCHANGE(EC.ES_SEM, p_LOGGER.EXCHANGE_NAME, UT.c_EMPTY_MAP, NULL, p_LOGGER);

END DOWNLOAD_SETTLEMENT_REPORTS;
----------------------------------------------------------------------------------------
PROCEDURE DOWNLOAD_SETTLEMENT_REPORTS
  (
  p_BEGIN_DATE IN DATE,
  p_END_DATE IN DATE,
  p_FORCE_DOWNLOADS IN NUMBER,
  p_USE_DL_GROUPS IN NUMBER := 0,
  p_LOG_TYPE IN NUMBER,
  p_TRACE_ON IN NUMBER,
  p_STATUS  OUT NUMBER,
  p_MESSAGE OUT VARCHAR2
  ) AS

v_CREDS MM_CREDENTIALS_SET;
v_CRED MEX_CREDENTIALS;
v_LOGGER MM_LOGGER_ADAPTER;
v_DUMMY VARCHAR2(512);
v_USE_DL_GROUPS NUMBER(1) := NVL(p_USE_DL_GROUPS, 0);

BEGIN
  SAVEPOINT BEFORE_IMPORT;

  -- download settlement reports for all market participant accounts
  MM_UTIL.INIT_MEX(EC.ES_SEM, 'Query Settlement', NULL, p_LOG_TYPE, p_TRACE_ON, v_CREDS, v_LOGGER);
  MM_UTIL.START_EXCHANGE(FALSE, v_LOGGER);

  IF NOT v_CREDS.HAS_NEXT THEN
    p_STATUS := GA.GENERAL_EXCEPTION;
    p_MESSAGE := 'No credentials found for SEM. Nothing can be downloaded';
    v_LOGGER.LOG_WARN(p_MESSAGE);

    MM_UTIL.STOP_EXCHANGE(v_LOGGER, p_STATUS, p_MESSAGE, v_DUMMY);
  ELSE

    UT.GET_RTO_WORK_ID(g_WORK_ID_FOR_DL_GROUPS);

    WHILE v_CREDS.HAS_NEXT LOOP
      v_CRED := v_CREDS.GET_NEXT;
      v_LOGGER.EXTERNAL_ACCOUNT_NAME := v_CRED.EXTERNAL_ACCOUNT_NAME;
      IF v_USE_DL_GROUPS = 0 OR (v_USE_DL_GROUPS = 1 AND IS_CREDENTIAL_IN_DL_GROUP(v_CRED)) THEN
                -- Establish savepoint for each participant
                SAVEPOINT BEFORE_IMPORT;
        DOWNLOAD_SETTLEMENT_REPORTS(p_BEGIN_DATE, p_END_DATE, NVL(p_FORCE_DOWNLOADS,0) <> 0, v_CRED, v_LOGGER, v_USE_DL_GROUPS);
      END IF;
    END LOOP;

    UT.PURGE_RTO_WORK(g_WORK_ID_FOR_DL_GROUPS);

    p_STATUS := GA.SUCCESS;
    p_MESSAGE := v_LOGGER.GET_END_MESSAGE();

    MM_UTIL.STOP_EXCHANGE(v_LOGGER, p_STATUS, p_MESSAGE, p_MESSAGE);
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    p_STATUS := SQLCODE;
    p_MESSAGE := MM_SEM_UTIL.ERROR_STACKTRACE;
        MM_UTIL.STOP_EXCHANGE(v_LOGGER, p_STATUS, p_MESSAGE, v_DUMMY);
    ROLLBACK TO BEFORE_IMPORT;

END DOWNLOAD_SETTLEMENT_REPORTS;
----------------------------------------------------------------------------------------
FUNCTION EXTRACT_FILE_NAME
  (
  p_FILE_PATH IN VARCHAR2
  ) RETURN VARCHAR2 IS
v_POS1 BINARY_INTEGER;
v_POS2 BINARY_INTEGER;
BEGIN
  v_POS1 := INSTR(p_FILE_PATH,'/',-1);
  v_POS2 := INSTR(p_FILE_PATH,'\',-1);
  IF v_POS2 > v_POS1 THEN
    v_POS1 := v_POS2;
  END IF;

  IF v_POS1 = 0 THEN
    RETURN UPPER(p_FILE_PATH);
  ELSE
    RETURN UPPER(SUBSTR(p_FILE_PATH,v_POS1+1));
  END IF;
END EXTRACT_FILE_NAME;
----------------------------------------------------------------------------------------
PROCEDURE IMPORT_STATEMENT_CLOB
  (
    p_IMPORT_FILE_PATH IN VARCHAR2,
    p_IMPORT_FILE IN OUT NOCOPY CLOB,
  p_LOG_TYPE IN NUMBER,
  p_TRACE_ON IN NUMBER,
  p_STATUS  OUT NUMBER,
    p_MESSAGE OUT VARCHAR2
  ) AS
v_LOGGER MM_LOGGER_ADAPTER;
v_RPT_TYPE BINARY_INTEGER;
v_VALID_REPORT_NAME BOOLEAN := FALSE;
v_STATEMENT_TYPE_ID STATEMENT_TYPE.STATEMENT_TYPE_ID%TYPE;
v_FILENAME VARCHAR2(256);
v_PARMS UT.STRING_MAP;
v_DUMMY VARCHAR2(512);

BEGIN
  SAVEPOINT BEFORE_IMPORT;

  v_LOGGER := MM_UTIL.GET_LOGGER(EC.ES_SEM, NULL, 'Import Statement', NULL, p_LOG_TYPE, p_TRACE_ON);
  MM_UTIL.START_EXCHANGE(TRUE, v_LOGGER);

  v_FILENAME := EXTRACT_FILE_NAME(p_IMPORT_FILE_PATH);
    PARSE_AND_VALIDATE_REP_NAME(v_FILENAME, v_RPT_TYPE, v_STATEMENT_TYPE_ID, v_VALID_REPORT_NAME, v_LOGGER);

    IF v_VALID_REPORT_NAME  THEN
    -- Check if file is Statement report
    IF v_RPT_TYPE = g_STATEMENT_REPORT THEN
      v_PARMS(g_HOOK_PARM_SETTLEMENT_FILE) := v_FILENAME;
      XS.PRE_MARKET_EXCHANGE(EC.ES_SEM, v_LOGGER.EXCHANGE_NAME, v_PARMS, p_IMPORT_FILE, v_LOGGER);

       IMPORT_STATEMENT_REPORT(p_IMPORT_FILE, v_LOGGER, v_STATEMENT_TYPE_ID);

       p_STATUS := GA.SUCCESS;
       p_MESSAGE := 'Import Complete.';
    ELSE
       v_LOGGER.LOG_ERROR('File is not a Statement report.');
       p_STATUS := GA.GENERAL_EXCEPTION;
       p_MESSAGE := 'Import Unsuccessful.';
       ROLLBACK TO BEFORE_IMPORT;
    END IF;
    ELSE
       p_STATUS := GA.GENERAL_EXCEPTION;
       p_MESSAGE := 'Import Unsuccessful.';
       ROLLBACK TO BEFORE_IMPORT;
    END IF;

    MM_UTIL.STOP_EXCHANGE(v_LOGGER, p_STATUS, p_MESSAGE, p_MESSAGE);
  p_MESSAGE := p_MESSAGE||' See event log for details.';

EXCEPTION
  WHEN OTHERS THEN
    p_STATUS := SQLCODE;
    p_MESSAGE := MM_SEM_UTIL.ERROR_STACKTRACE;
        MM_UTIL.STOP_EXCHANGE(v_LOGGER, p_STATUS, p_MESSAGE, v_DUMMY);
    ROLLBACK TO BEFORE_IMPORT;

END IMPORT_STATEMENT_CLOB;
----------------------------------------------------------------------------------------
PROCEDURE IMPORT_PIR_CLOB_INTERNAL
  (
  p_LOGGER IN OUT NOCOPY MM_LOGGER_ADAPTER,
    p_IMPORT_FILE_PATH IN VARCHAR2,
    p_IMPORT_FILE IN OUT NOCOPY CLOB,
  p_STATUS  OUT NUMBER,
    p_MESSAGE OUT VARCHAR2,
    p_STATEMENT_TYPE_ID IN NUMBER := NULL
  ) AS
v_RPT_TYPE BINARY_INTEGER;
v_VALID_REPORT_NAME BOOLEAN := FALSE;
v_STATEMENT_TYPE_ID STATEMENT_TYPE.STATEMENT_TYPE_ID%TYPE;
v_FILENAME VARCHAR2(256);
v_PARMS UT.STRING_MAP;
BEGIN

  v_FILENAME := EXTRACT_FILE_NAME(p_IMPORT_FILE_PATH);
    PARSE_AND_VALIDATE_REP_NAME(v_FILENAME, v_RPT_TYPE, v_STATEMENT_TYPE_ID, v_VALID_REPORT_NAME, p_LOGGER);

  -- If an override statement type has been provided then use that one.
  IF p_STATEMENT_TYPE_ID IS NOT NULL THEN
    v_STATEMENT_TYPE_ID := p_STATEMENT_TYPE_ID;
  END IF;

    IF v_VALID_REPORT_NAME THEN
    -- Check if file is Participant Information report
    IF v_RPT_TYPE = g_PARTICIPANT_INFO_REPORT THEN
      v_PARMS(g_HOOK_PARM_SETTLEMENT_FILE) := v_FILENAME;
      XS.PRE_MARKET_EXCHANGE(EC.ES_SEM, p_LOGGER.EXCHANGE_NAME, v_PARMS, p_IMPORT_FILE, p_LOGGER);

       IMPORT_PARTICIPANT_INFO_REPORT(v_FILENAME, p_IMPORT_FILE, p_LOGGER, v_STATEMENT_TYPE_ID,
                         -- if statement type ID specified, force importing into that statement type
                         p_STATEMENT_TYPE_ID IS NOT NULL);
    ELSE
       p_LOGGER.LOG_ERROR('File is not a Participant Information report.');
       ERRS.RAISE(MSGCODES.c_ERR_GENERAL, 'Import Unsuccessful.');
    END IF;
    ELSE
     ERRS.RAISE(MSGCODES.c_ERR_GENERAL, 'Import Unsuccessful.');
    END IF;

END IMPORT_PIR_CLOB_INTERNAL;
----------------------------------------------------------------------------------------
PROCEDURE IMPORT_PARTICIPANT_INFO_CLOB
  (
    p_IMPORT_FILE_PATH IN VARCHAR2,
    p_IMPORT_FILE IN OUT NOCOPY CLOB,
  p_LOG_TYPE IN NUMBER,
  p_TRACE_ON IN NUMBER,
  p_STATUS  OUT NUMBER,
    p_MESSAGE OUT VARCHAR2
  ) AS

v_LOGGER MM_LOGGER_ADAPTER;
v_DUMMY VARCHAR2(512);

BEGIN
  SAVEPOINT BEFORE_IMPORT;

  v_LOGGER := MM_UTIL.GET_LOGGER(EC.ES_SEM, NULL, 'Import PIR', NULL, p_LOG_TYPE, p_TRACE_ON);
  MM_UTIL.START_EXCHANGE(TRUE, v_LOGGER);

  IMPORT_PIR_CLOB_INTERNAL(v_LOGGER, p_IMPORT_FILE_PATH, p_IMPORT_FILE, p_STATUS, p_MESSAGE);

  MM_UTIL.STOP_EXCHANGE(v_LOGGER, p_STATUS, p_MESSAGE, p_MESSAGE);
  p_MESSAGE := p_MESSAGE||' See event log for details.';

EXCEPTION
  WHEN OTHERS THEN
    p_STATUS := SQLCODE;
    p_MESSAGE := MM_SEM_UTIL.ERROR_STACKTRACE;
    MM_UTIL.STOP_EXCHANGE(v_LOGGER, p_STATUS, p_MESSAGE, v_DUMMY);
    ROLLBACK TO BEFORE_IMPORT;

END IMPORT_PARTICIPANT_INFO_CLOB;
----------------------------------------------------------------------------------------
PROCEDURE IMPORT_UNPROCESSED_PIRS
  (
  p_IMPORT_FILE_ID   IN NUMBER_COLLECTION,
  p_STATEMENT_TYPE_ID  IN NUMBER,
  p_LOG_TYPE      IN NUMBER,
  p_TRACE_ON      IN NUMBER,
  p_STATUS        OUT NUMBER,
    p_MESSAGE       OUT VARCHAR2
  ) AS

v_LOGGER MM_LOGGER_ADAPTER;
v_DUMMY VARCHAR2(512);
CURSOR v_FILES IS
  SELECT SMIF.*
  FROM SEM_MP_INFO_FILES SMIF,
    TABLE(CAST(p_IMPORT_FILE_ID AS NUMBER_COLLECTION)) X
  WHERE SMIF.IMPORT_FILE_ID = X.COLUMN_VALUE;

BEGIN
  SAVEPOINT BEFORE_IMPORT;

  v_LOGGER := MM_UTIL.GET_LOGGER(EC.ES_SEM, NULL, 'Import Unprocessed PIRs', NULL, p_LOG_TYPE, p_TRACE_ON);
  MM_UTIL.START_EXCHANGE(TRUE, v_LOGGER);

  FOR v_REC IN v_FILES LOOP

    -- process the file
    MM_SEM_SETTLEMENT.IMPORT_PIR_CLOB_INTERNAL(v_LOGGER, v_REC.FILE_NAME, v_REC.IMPORT_FILE, p_STATUS, p_MESSAGE, p_STATEMENT_TYPE_ID);

    ERRS.VALIDATE_STATUS('MM_SEM_SETTLEMENT.IMPORT_PARTICIPANT_INFO_CLOB', p_STATUS, p_MESSAGE);
    MM_SEM_SETTLEMENT_PARSE.DEL_SEM_MP_INFO_FILES(v_REC.IMPORT_FILE_ID);

  END LOOP;

  MM_UTIL.STOP_EXCHANGE(v_LOGGER, p_STATUS, p_MESSAGE, p_MESSAGE);
  p_MESSAGE := p_MESSAGE||' See event log for details.';

EXCEPTION
  WHEN OTHERS THEN
    p_STATUS := SQLCODE;
    p_MESSAGE := MM_SEM_UTIL.ERROR_STACKTRACE;
    MM_UTIL.STOP_EXCHANGE(v_LOGGER, p_STATUS, p_MESSAGE, v_DUMMY);
    ROLLBACK TO BEFORE_IMPORT;


END IMPORT_UNPROCESSED_PIRS;
----------------------------------------------------------------------------------------
PROCEDURE IMPORT_REALLOCATIONS_CLOB
  (
    p_IMPORT_FILE_PATH IN VARCHAR2,
    p_IMPORT_FILE IN OUT NOCOPY CLOB,
  p_LOG_TYPE IN NUMBER,
  p_TRACE_ON IN NUMBER,
  p_STATUS  OUT NUMBER,
    p_MESSAGE OUT VARCHAR2
  ) AS
v_LOGGER MM_LOGGER_ADAPTER;
v_RPT_TYPE BINARY_INTEGER;
v_VALID_REPORT_NAME BOOLEAN := FALSE;
v_STATEMENT_TYPE_ID STATEMENT_TYPE.STATEMENT_TYPE_ID%TYPE;
v_FILENAME VARCHAR2(256);
v_PARMS UT.STRING_MAP;
v_DUMMY VARCHAR2(512);

BEGIN
  SAVEPOINT BEFORE_IMPORT;

  v_LOGGER := MM_UTIL.GET_LOGGER(EC.ES_SEM, NULL, 'Import RAR', NULL, p_LOG_TYPE, p_TRACE_ON);
    MM_UTIL.START_EXCHANGE(TRUE, v_LOGGER);


  v_FILENAME := EXTRACT_FILE_NAME(p_IMPORT_FILE_PATH);
    PARSE_AND_VALIDATE_REP_NAME(v_FILENAME, v_RPT_TYPE, v_STATEMENT_TYPE_ID, v_VALID_REPORT_NAME, v_LOGGER);

    IF v_VALID_REPORT_NAME THEN
    -- Check if file is Reallocation Agreement report
    IF v_RPT_TYPE = g_REALLOCATION_REPORT THEN
      v_PARMS(g_HOOK_PARM_SETTLEMENT_FILE) := v_FILENAME;
      XS.PRE_MARKET_EXCHANGE(EC.ES_SEM, v_LOGGER.EXCHANGE_NAME, v_PARMS, p_IMPORT_FILE, v_LOGGER);

       IMPORT_REALLOCATION_REPORT(v_FILENAME, p_IMPORT_FILE, v_LOGGER, v_STATEMENT_TYPE_ID);

       p_STATUS := GA.SUCCESS;
       p_MESSAGE := 'Import Complete.';
      ELSE
       v_LOGGER.LOG_ERROR('File is not a Reallocation Agreement report.');
       p_STATUS := GA.GENERAL_EXCEPTION;
       p_MESSAGE := 'Import Unsuccessful.';
       ROLLBACK TO BEFORE_IMPORT;
    END IF;
    ELSE
       p_STATUS := GA.GENERAL_EXCEPTION;
       p_MESSAGE := 'Import Unsuccessful.';
       ROLLBACK TO BEFORE_IMPORT;
    END IF;

    MM_UTIL.STOP_EXCHANGE(v_LOGGER, p_STATUS, p_MESSAGE, p_MESSAGE);
  p_MESSAGE := p_MESSAGE||' See event log for details.';

EXCEPTION
  WHEN OTHERS THEN
    p_STATUS := SQLCODE;
    p_MESSAGE := MM_SEM_UTIL.ERROR_STACKTRACE;
        MM_UTIL.STOP_EXCHANGE(v_LOGGER, p_STATUS, p_MESSAGE, v_DUMMY);
    ROLLBACK TO BEFORE_IMPORT;

END IMPORT_REALLOCATIONS_CLOB;
----------------------------------------------------------------------------------------
PROCEDURE IMPORT_INVOICE_CLOB
  (
    p_IMPORT_FILE_PATH IN VARCHAR2,
    p_IMPORT_FILE IN OUT NOCOPY CLOB,
  p_LOG_TYPE IN NUMBER,
  p_TRACE_ON IN NUMBER,
  p_STATUS  OUT NUMBER,
    p_MESSAGE OUT VARCHAR2
  ) AS
v_LOGGER MM_LOGGER_ADAPTER;
v_RPT_TYPE BINARY_INTEGER;
v_VALID_REPORT_NAME BOOLEAN := FALSE;
v_STATEMENT_TYPE_ID STATEMENT_TYPE.STATEMENT_TYPE_ID%TYPE;
v_FILENAME VARCHAR2(256);
v_PARMS UT.STRING_MAP;
v_DUMMY VARCHAR2(512);

BEGIN
  SAVEPOINT BEFORE_IMPORT;

  v_LOGGER := MM_UTIL.GET_LOGGER(EC.ES_SEM, NULL, 'Import Invoice', NULL, p_LOG_TYPE, p_TRACE_ON);
  MM_UTIL.START_EXCHANGE(TRUE, v_LOGGER);

  v_FILENAME := EXTRACT_FILE_NAME(p_IMPORT_FILE_PATH);
    PARSE_AND_VALIDATE_REP_NAME(v_FILENAME, v_RPT_TYPE, v_STATEMENT_TYPE_ID, v_VALID_REPORT_NAME, v_LOGGER);

    IF v_VALID_REPORT_NAME THEN
    -- Check if file is Invoice
    IF v_RPT_TYPE  = g_INVOICE_REPORT THEN
      v_PARMS(g_HOOK_PARM_SETTLEMENT_FILE) := v_FILENAME;
      XS.PRE_MARKET_EXCHANGE(EC.ES_SEM, v_LOGGER.EXCHANGE_NAME, v_PARMS, p_IMPORT_FILE, v_LOGGER);

       IMPORT_INVOICE_REPORT(g_IMPORT_SOURCE_FILE, p_IMPORT_FILE, v_LOGGER);

         p_STATUS := GA.SUCCESS;
         p_MESSAGE := 'Import Complete.';
      ELSE
       v_LOGGER.LOG_ERROR('File is not an Invoice.');
         p_STATUS := GA.GENERAL_EXCEPTION;
            p_MESSAGE := 'Import Unsuccessful.';
            ROLLBACK TO BEFORE_IMPORT;
    END IF;
    ELSE
           p_STATUS := GA.GENERAL_EXCEPTION;
         p_MESSAGE := 'Import Unsuccessful.';
           ROLLBACK TO BEFORE_IMPORT;
    END IF;

    MM_UTIL.STOP_EXCHANGE(v_LOGGER, p_STATUS, p_MESSAGE, p_MESSAGE);
  p_MESSAGE := p_MESSAGE||' See event log for details.';

EXCEPTION
  WHEN OTHERS THEN
    p_STATUS := SQLCODE;
    p_MESSAGE := MM_SEM_UTIL.ERROR_STACKTRACE;
      MM_UTIL.STOP_EXCHANGE(v_LOGGER, p_STATUS, p_MESSAGE, v_DUMMY);
    ROLLBACK TO BEFORE_IMPORT;

END IMPORT_INVOICE_CLOB;
----------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------
PROCEDURE IMPORT_GP_REPORT_CLOB
  (
    p_IMPORT_FILE_PATH IN VARCHAR2,
    p_IMPORT_FILE IN OUT NOCOPY CLOB,
  p_LOG_TYPE IN NUMBER,
  p_TRACE_ON IN NUMBER,
  p_STATUS  OUT NUMBER,
    p_MESSAGE OUT VARCHAR2
  ) AS
v_LOGGER MM_LOGGER_ADAPTER;
v_RPT_TYPE BINARY_INTEGER;
v_VALID_REPORT_NAME BOOLEAN := FALSE;
v_STATEMENT_TYPE_ID STATEMENT_TYPE.STATEMENT_TYPE_ID%TYPE;
v_FILENAME VARCHAR2(256);
v_PARMS UT.STRING_MAP;
v_DUMMY VARCHAR2(512);

BEGIN
  SAVEPOINT BEFORE_IMPORT;

  v_LOGGER := MM_UTIL.GET_LOGGER(EC.ES_SEM, NULL, 'Import GP Settlement Report', NULL, p_LOG_TYPE, p_TRACE_ON);
  MM_UTIL.START_EXCHANGE(TRUE, v_LOGGER);

  v_FILENAME := EXTRACT_FILE_NAME(p_IMPORT_FILE_PATH);
    PARSE_AND_VALIDATE_REP_NAME(v_FILENAME, v_RPT_TYPE, v_STATEMENT_TYPE_ID, v_VALID_REPORT_NAME, v_LOGGER);

    IF v_VALID_REPORT_NAME THEN
    -- Check if file is Participant Information report
    IF v_RPT_TYPE = g_GENERAL_PUBLIC_REPORT THEN
      v_PARMS(g_HOOK_PARM_SETTLEMENT_FILE) := v_FILENAME;
      XS.PRE_MARKET_EXCHANGE(EC.ES_SEM, v_LOGGER.EXCHANGE_NAME, v_PARMS, p_IMPORT_FILE, v_LOGGER);

       IMPORT_GENERAL_PUBLIC_REPORT(v_FILENAME, p_IMPORT_FILE, v_LOGGER, v_STATEMENT_TYPE_ID);

       p_STATUS := GA.SUCCESS;
       p_MESSAGE := 'Import Complete.';
    ELSE
       v_LOGGER.LOG_ERROR('File is not an MIR, MGR, or MFR report.');
       p_STATUS := GA.GENERAL_EXCEPTION;
       p_MESSAGE := 'Import Unsuccessful.';
       ROLLBACK TO BEFORE_IMPORT;
    END IF;
    ELSE
       p_STATUS := GA.GENERAL_EXCEPTION;
       p_MESSAGE := 'Import Unsuccessful.';
       ROLLBACK TO BEFORE_IMPORT;
    END IF;

    MM_UTIL.STOP_EXCHANGE(v_LOGGER, p_STATUS, p_MESSAGE, p_MESSAGE);
  p_MESSAGE := p_MESSAGE||' See event log for details.';

EXCEPTION
  WHEN OTHERS THEN
    p_STATUS := SQLCODE;
    p_MESSAGE := MM_SEM_UTIL.ERROR_STACKTRACE;
    MM_UTIL.STOP_EXCHANGE(v_LOGGER, p_STATUS, p_MESSAGE, v_DUMMY);
    ROLLBACK TO BEFORE_IMPORT;

END IMPORT_GP_REPORT_CLOB;
----------------------------------------------------------------------------------------
PROCEDURE GET_CHARGE_DETAIL
  (
  p_CALLING_MODULE IN VARCHAR,
  p_MODEL_ID IN NUMBER,
    p_CHARGE_VIEW_TYPE IN VARCHAR2,
  p_ENTITY_ID IN NUMBER,
  p_COMPONENT_ID IN NUMBER,
  p_WORK_ID IN NUMBER,
  p_TIME_ZONE IN VARCHAR,
  p_AS_OF_DATE IN DATE,
  p_BAND_KEYWORD OUT VARCHAR,
  p_HAS_SUBTOTALS OUT NUMBER,
    p_SHOW_BILL_AMOUNT IN NUMBER,
    p_SHOW_CHARGE_AMOUNT IN NUMBER,
  p_STATUS OUT NUMBER,
  p_CURSOR IN OUT REF_CURSOR
  ) AS

v_CHARGE_TYPE VARCHAR(32);

BEGIN
  -- Get details for drill-down into a component. If the returned cursor has
  -- "bands" make sure the corresponding fields are all adjacent, all begin
  -- with p_BAND_KEYWORD, and a column exists called p_BAND_KEYWORD||'_NUMBER';
  -- otherwise set p_BAND_KEYWORD to empty string. If the cursor only has
  -- sub-totals (i.e. more than one row per charge date), then set
  -- p_HAS_SUBTOTALS to 1.
  --
  -- If SHOW_BILL_AMOUNT is zero, then any fields with bill quantities and amounts
  -- should be all null. If SHOW_CHARGE_AMOUNT is zero, then any fields with charge
  -- quantities and amounts should be all null. The grid configuration can then be
  -- setup so that these columns are all hide when null - and the UI will then
  -- properly respect the settings of the Show Bill Amounts and Show Charge Amounts
  -- checkboxes.

  p_STATUS := GA.SUCCESS;
  SELECT CHARGE_TYPE INTO v_CHARGE_TYPE
  FROM COMPONENT
  WHERE COMPONENT_ID = p_COMPONENT_ID;

  IF p_CHARGE_VIEW_TYPE = 'SEM Detail' THEN
    OPEN p_CURSOR FOR
      SELECT FROM_CUT_AS_HED(A.CHARGE_DATE, p_TIME_ZONE, CASE WHEN A.RESOLUTION >= 32 THEN 'DD' ELSE 'MI5' END) as CHARGE_DATE,
          A.RESOLUTION,
          A.RESOURCE_NAME,
          A.LOCATION_NAME,
          A.REC_ORDER,
          A.PAY_OR_CHARGE,
          A.COMMENTS,
          A.JURISDICTION,
          A.CONTRACT,
                    A.INTERCONNECTOR,
          A.CHARGE_QUANTITY,
          A.QUANTITY_UNIT,
          A.CHARGE_AMOUNT,
          A.AMOUNT_UNIT,
          B.DISPUTE_STATUS
      FROM (SELECT A.CHARGE_DATE,
          A.RESOLUTION,
          A.RESOURCE_NAME,
          A.LOCATION_NAME,
          A.REC_ORDER,
          A.PAY_OR_CHARGE,
          A.COMMENTS,
          A.JURISDICTION,
          A.CONTRACT,
                    A.INTERCONNECTOR,
          A.CHARGE_QUANTITY,
          A.QUANTITY_UNIT,
          A.CHARGE_AMOUNT,
          A.AMOUNT_UNIT,
            S.ENTITY_ID,
            S.STATEMENT_TYPE,
            S.STATEMENT_STATE,
                    S.STATEMENT_DATE,
            S.PRODUCT_ID,
            S.COMPONENT_ID
          FROM RTO_WORK X, BILLING_STATEMENT S, SEM_DETAIL_CHARGE A
          WHERE X.WORK_ID = p_WORK_ID
            AND S.CHARGE_ID = X.WORK_XID
          AND A.CHARGE_ID = S.CHARGE_ID) A,
          BILLING_CHARGE_DISPUTE B
        WHERE B.ENTITY_ID (+)= A.ENTITY_ID
          AND B.PRODUCT_ID (+)= A.PRODUCT_ID
          AND B.COMPONENT_ID (+)= A.COMPONENT_ID
          AND B.STATEMENT_TYPE (+)= A.STATEMENT_TYPE
          AND B.STATEMENT_STATE (+)= A.STATEMENT_STATE
                AND B.STATEMENT_DATE (+)= A.STATEMENT_DATE
          AND B.DISPUTE_DATE (+)= A.CHARGE_DATE
      ORDER BY A.CHARGE_DATE, A.RESOLUTION, A.RESOURCE_NAME, A.LOCATION_NAME;
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    p_STATUS := SQLCODE;

END GET_CHARGE_DETAIL;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_INVOICE_REPORT_RECORDS
  (
    p_INVOICE_CATEGORY IN VARCHAR,
    p_INVOICE_ID IN NUMBER,
  p_STATUS OUT NUMBER,
    p_SOMETHING_DONE IN OUT BOOLEAN,
  p_CURSOR IN OUT REF_CURSOR
    ) AS

BEGIN
  -- Custom query to include extra fields found in SEM invoice template
    OPEN p_CURSOR FOR
      SELECT TO_CHAR(A.BEGIN_DATE, MM_SEM_UTIL.g_DATE_FORMAT)||' - '||TO_CHAR(A.END_DATE, MM_SEM_UTIL.g_DATE_FORMAT) AS INVOICE_MONTH,
        TO_CHAR(TRUNC(A.INVOICE_DATE), MM_SEM_UTIL.g_DATE_FORMAT) AS INVOICE_DATE,
          A.INVOICE_NUMBER, A.INVOICE_SUB_LEDGER_NUMBER,
          A.BILLING_CONTACT, A.BILLING_PHONE, A.BILLING_FAX, A.BILLING_STREET, A.BILLING_CITY, A.BILLING_STATE_CODE, A.BILLING_POSTAL_CODE, A.BILLING_COUNTRY_CODE,
          A.INVOICE_TERMS, A.INVOICE_PRIMARY_CONTACT, A.INVOICE_PRIMARY_PHONE, A.INVOICE_SECONDARY_CONTACT, A.INVOICE_SECONDARY_PHONE,
          A.PAY_CHECK_CONTACT, A.PAY_CHECK_STREET, A.PAY_CHECK_CITY, A.PAY_CHECK_STATE_CODE, A.PAY_CHECK_POSTAL_CODE, A.PAY_CHECK_COUNTRY_CODE,
          A.PAY_ELECTRONIC_DEBIT_NAME, A.PAY_ELECTRONIC_DEBIT_NBR, A.PAY_ELECTRONIC_CREDIT_NAME, A.PAY_ELECTRONIC_CREDIT_NBR,
          A.INVOICE_STATUS,
          TO_CHAR(TRUNC(A.PAYMENT_DUE_DATE), MM_SEM_UTIL.g_DATE_FORMAT) AS PAYMENT_DUE_DATE,
        A.PAYMENT_DUE_DATE AS PAYMENT_DUE_DATE_DT,
          B.LINE_ITEM_NAME,
          DECODE(UPPER(C.CHARGE_TYPE), 'TAX', 'T', 'C') AS LINE_ITEM_TYPE,
          DECODE(UPPER(C.CHARGE_TYPE), 'TAX', 6, 5) AS LINE_ITEM_GROUP_ORDER, D.INVOICE_GROUP_NAME,
                NVL(C.INVOICE_GROUP_ORDER,0) AS INVOICE_GROUP_ORDER,
          TO_CHAR(B.LINE_ITEM_QUANTITY) AS LINE_ITEM_QUANTITY, TO_CHAR(B.LINE_ITEM_RATE) AS LINE_ITEM_RATE,
                TO_CHAR(DECODE(UPPER(NVL(B.DEFAULT_DISPLAY,'CHARGE')),'BILL',ROUND(B.LINE_ITEM_BILL_AMOUNT,4),ROUND(B.LINE_ITEM_AMOUNT,4))) AS LINE_ITEM_AMOUNT,
          TO_CHAR(NVL(C.EXCLUDE_FROM_INVOICE_TOTAL,0)) AS EXCLUDE_FROM_INVOICE_TOTAL,
          TO_CHAR(NVL(D.SHOW_TITLE_ON_INVOICE,0)) AS SHOW_TITLE_ON_INVOICE,
          TO_CHAR(NVL(D.SHOW_SUBTOTAL_ON_INVOICE,0)) AS SHOW_SUBTOTAL_ON_INVOICE,
                NVL(D.DISPLAY_ORDER,0) AS INVOICE_GROUP_DISPLAY_ORDER,
        NVL(U.USER_DISPLAY_NAME, U.USER_NAME) AS APPROVED_BY,
          TO_CHAR(TRUNC(A.APPROVED_WHEN), MM_SEM_UTIL.g_DATE_FORMAT) AS APPROVED_WHEN,
        A.APPROVED_WHEN AS APPROVED_WHEN_DT,
        SI.SENDER_TAX_ID, SI.SENDER_STREET, SI.SENDER_CITY,
        SI.RECEIVER_GL,
        NVL(SI.INVOICE_TYPE, '1') as INVOICE_TYPE,
        NVL(SI.INVOICE_HEADER,'Final invoice for Week '||TO_CHAR(A.END_DATE,'WW YYYY')) as INVOICE_HEADER,
        NVL(SI.UNIT, CASE WHEN MM_SEM_SHADOW_BILL.GET_CURRENCY(A.ENTITY_ID,A.END_DATE) = 0 THEN 'EUR' ELSE 'GBP' END) as UNIT,
        SI.CALENDAR_ID,
        NVL(SI.INVOICE_AMOUNT,SUM(B.LINE_ITEM_AMOUNT) OVER (PARTITION BY 1)) as INVOICE_AMOUNT,
        NVL(SI.FIRST_AMOUNT,SUM(CASE WHEN B.LINE_ITEM_AMOUNT = B.LINE_ITEM_BILL_AMOUNT THEN B.LINE_ITEM_AMOUNT ELSE B.LINE_ITEM_AMOUNT - NVL(B.LINE_ITEM_BILL_AMOUNT,0) END) OVER (PARTITION BY 1)) as FIRST_AMOUNT,
        NVL(SI.MARKET_NAME,SEV.MARKET_NAME) as MARKET_NAME,
        NVL(SI.BILL_PERIOD_NAME,'Week '||TO_CHAR(A.END_DATE,'WW YYYY')) as BILL_PERIOD_NAME,
        NVL(SI.RECEIVER_ID,EI.GET_ENTITY_NAME(EC.ED_PSE,SEV.PARTICIPANT_PSE_ID)) as RECEIVER_ID,
        COALESCE(SIL.BILL_HEADING, MAX(SIL.BILL_HEADING) OVER (PARTITION BY 1), 'Charges for period Week '||TO_CHAR(A.END_DATE,'WW YYYY')) as BILL_HEADING,
        NVL(SIL.CHARGE_DESCRIPTION, C.COMPONENT_DESC) as CHARGE_DESCRIPTION,
        NVL(SIL.CHARGE_ID, C.COMPONENT_NAME) as CHARGE_ID,
        NVL(SIL.QUANTITY, B.LINE_ITEM_QUANTITY) as QUANTITY,
        NVL(SIL.QTY_UNIT, CASE WHEN C.QUANTITY_UNIT='?' THEN NULL ELSE C.QUANTITY_UNIT END) as QTY_UNIT,
        COALESCE(SIL.AMOUNT_UNIT, MAX(SIL.AMOUNT_UNIT) OVER (PARTITION BY 1), CASE WHEN MM_SEM_SHADOW_BILL.GET_CURRENCY(A.ENTITY_ID,A.BEGIN_DATE) = 0 THEN 'EUR' ELSE 'GBP' END) as AMOUNT_UNIT,
        SIL.BILL_ORDER,
        NVL(SIL.CHARGE_TYPE, MAX(SIL.CHARGE_TYPE) OVER (PARTITION BY 1)) CHARGE_TYPE,
        NVL(SIL.PREV_AMOUNT, B.LINE_ITEM_AMOUNT - NVL(B.LINE_ITEM_BILL_AMOUNT,0)) PREV_AMOUNT
      FROM INVOICE A,
        INVOICE_LINE_ITEM B,
          COMPONENT C,
          INVOICE_GROUP D,
        SEM_INVOICE SI,
        SEM_INVOICE_LINE_ITEM SIL,
        SEM_SETTLEMENT_ENTITY SEV,
        APPLICATION_USER U
      WHERE A.INVOICE_ID = p_INVOICE_ID
        AND B.INVOICE_ID = A.INVOICE_ID
                AND NVL(B.LINE_ITEM_CATEGORY,' ') LIKE p_INVOICE_CATEGORY
        AND C.COMPONENT_ID(+) = B.COMPONENT_ID
        AND D.INVOICE_GROUP_ID(+) = C.INVOICE_GROUP_ID
        AND SI.INVOICE_ID(+) = A.INVOICE_ID
        AND SIL.INVOICE_ID(+) = B.INVOICE_ID
        AND SIL.LINE_ITEM_NAME(+) = B.LINE_ITEM_NAME
        AND SEV.SETTLEMENT_PSE_ID(+) = A.ENTITY_ID
        AND U.USER_ID (+) = A.APPROVED_BY_ID
      UNION ALL
      SELECT TO_CHAR(A.BEGIN_DATE, MM_SEM_UTIL.g_DATE_FORMAT)||' - '||TO_CHAR(A.END_DATE, MM_SEM_UTIL.g_DATE_FORMAT) AS INVOICE_MONTH,
        TO_CHAR(TRUNC(A.INVOICE_DATE), MM_SEM_UTIL.g_DATE_FORMAT) AS INVOICE_DATE,
          A.INVOICE_NUMBER, A.INVOICE_SUB_LEDGER_NUMBER,
        A.BILLING_CONTACT, A.BILLING_PHONE, A.BILLING_FAX, A.BILLING_STREET, A.BILLING_CITY, A.BILLING_STATE_CODE, A.BILLING_POSTAL_CODE, A.BILLING_COUNTRY_CODE,
        A.INVOICE_TERMS, A.INVOICE_PRIMARY_CONTACT, A.INVOICE_PRIMARY_PHONE, A.INVOICE_SECONDARY_CONTACT, A.INVOICE_SECONDARY_PHONE,
        A.PAY_CHECK_CONTACT, A.PAY_CHECK_STREET, A.PAY_CHECK_CITY, A.PAY_CHECK_STATE_CODE, A.PAY_CHECK_POSTAL_CODE, A.PAY_CHECK_COUNTRY_CODE,
        A.PAY_ELECTRONIC_DEBIT_NAME, A.PAY_ELECTRONIC_DEBIT_NBR, A.PAY_ELECTRONIC_CREDIT_NAME, A.PAY_ELECTRONIC_CREDIT_NBR,
        A.INVOICE_STATUS,
        TO_CHAR(TRUNC(A.PAYMENT_DUE_DATE), MM_SEM_UTIL.g_DATE_FORMAT) AS PAYMENT_DUE_DATE,
        A.PAYMENT_DUE_DATE AS PAYMENT_DUE_DATE_DT,
        B.LINE_ITEM_NAME,
        B.LINE_ITEM_TYPE,
        DECODE(B.LINE_ITEM_TYPE, 'B', 1, 'P', 2, 'A', 3, 'F', 4, 'M', 7, 'X', 8, 99)  AS LINE_ITEM_GROUP_ORDER, C.INVOICE_GROUP_NAME,
                NVL(B.INVOICE_GROUP_ORDER,0) AS INVOICE_GROUP_ORDER,
        TO_CHAR(B.LINE_ITEM_QUANTITY) AS LINE_ITEM_QUANTITY, TO_CHAR(B.LINE_ITEM_RATE) AS LINE_ITEM_RATE,
                TO_CHAR(DECODE(UPPER(NVL(B.DEFAULT_DISPLAY,'CHARGE')),'BILL',B.LINE_ITEM_BILL_AMOUNT,B.LINE_ITEM_AMOUNT)) AS LINE_ITEM_AMOUNT,
        TO_CHAR(NVL(B.EXCLUDE_FROM_INVOICE_TOTAL,0)) AS EXCLUDE_FROM_INVOICE_TOTAL,
          TO_CHAR(NVL(C.SHOW_TITLE_ON_INVOICE,0)) AS SHOW_TITLE_ON_INVOICE,
          TO_CHAR(NVL(C.SHOW_SUBTOTAL_ON_INVOICE,0)) AS SHOW_SUBTOTAL_ON_INVOICE,
                NVL(C.DISPLAY_ORDER,0) AS INVOICE_GROUP_DISPLAY_ORDER,
        NVL(U.USER_DISPLAY_NAME, U.USER_NAME) AS APPROVED_BY,
          TO_CHAR(TRUNC(A.APPROVED_WHEN), MM_SEM_UTIL.g_DATE_FORMAT) AS APPROVED_WHEN,
        A.APPROVED_WHEN AS APPROVED_WHEN_DT,
        SI.SENDER_TAX_ID, SI.SENDER_STREET, SI.SENDER_CITY,
        SI.RECEIVER_GL,
        NVL(SI.INVOICE_TYPE, '1') as INVOICE_TYPE,
        NVL(SI.INVOICE_HEADER,'Final invoice for Week '||TO_CHAR(A.END_DATE,'WW YYYY')) as INVOICE_HEADER,
        NVL(SI.UNIT, CASE WHEN MM_SEM_SHADOW_BILL.GET_CURRENCY(A.ENTITY_ID,A.END_DATE) = 0 THEN 'EUR' ELSE 'GBP' END) as UNIT,
        SI.CALENDAR_ID,
        NVL(SI.INVOICE_AMOUNT,NULL) as INVOICE_AMOUNT,
        NVL(SI.FIRST_AMOUNT, NULL) as FIRST_AMOUNT,
        NVL(SI.MARKET_NAME,SEV.MARKET_NAME) as MARKET_NAME,
        NVL(SI.BILL_PERIOD_NAME,'Week '||TO_CHAR(A.END_DATE,'WW YYYY')) as BILL_PERIOD_NAME,
        NVL(SI.RECEIVER_ID,EI.GET_ENTITY_NAME(EC.ED_PSE,SEV.PARTICIPANT_PSE_ID)) as RECEIVER_ID,
        COALESCE(SIL.BILL_HEADING, MAX(SIL.BILL_HEADING) OVER (PARTITION BY 1), 'Charges for period Week '||TO_CHAR(A.END_DATE,'WW YYYY')) as BILL_HEADING,
        NVL(SIL.CHARGE_DESCRIPTION, B.LINE_ITEM_NAME) as CHARGE_DESCRIPTION,
        SIL.CHARGE_ID,
        NVL(SIL.QUANTITY, B.LINE_ITEM_QUANTITY) as QUANTITY,
        SIL.QTY_UNIT,
        COALESCE(SIL.AMOUNT_UNIT, MAX(SIL.AMOUNT_UNIT) OVER (PARTITION BY 1), CASE WHEN MM_SEM_SHADOW_BILL.GET_CURRENCY(A.ENTITY_ID,A.BEGIN_DATE) = 0 THEN 'EUR' ELSE 'GBP' END) as AMOUNT_UNIT,
        SIL.BILL_ORDER,
        NVL(SIL.CHARGE_TYPE, MAX(SIL.CHARGE_TYPE) OVER (PARTITION BY 1)) CHARGE_TYPE,
        NVL(SIL.PREV_AMOUNT, B.LINE_ITEM_AMOUNT - NVL(B.LINE_ITEM_BILL_AMOUNT,0)) PREV_AMOUNT
      FROM INVOICE A,
                            (SELECT *
                              FROM INVOICE I, INVOICE_USER_LINE_ITEM IULI
                              WHERE I.INVOICE_ID = p_INVOICE_ID
                                      AND IULI.ENTITY_ID = I.ENTITY_ID
                                      AND IULI.STATEMENT_TYPE = I.STATEMENT_TYPE
                                      AND IULI.STATEMENT_STATE = I.STATEMENT_STATE
                                      AND IULI.BEGIN_DATE = I.BEGIN_DATE
                                      AND NVL(IULI.LINE_ITEM_CATEGORY,' ') LIKE p_INVOICE_CATEGORY) B,
                INVOICE_GROUP C,
        SEM_INVOICE SI,
        SEM_INVOICE_LINE_ITEM SIL,
        SEM_SETTLEMENT_ENTITY SEV,
        APPLICATION_USER U
      WHERE A.INVOICE_ID = p_INVOICE_ID
        AND C.INVOICE_GROUP_ID(+) = B.INVOICE_GROUP_ID
        AND SI.INVOICE_ID(+) = B.INVOICE_ID
        AND SIL.INVOICE_ID(+) = B.INVOICE_ID
        AND SIL.LINE_ITEM_NAME(+) = B.LINE_ITEM_NAME
        AND SEV.SETTLEMENT_PSE_ID(+) = A.ENTITY_ID
        AND U.USER_ID (+) = A.APPROVED_BY_ID
      ORDER BY INVOICE_GROUP_DISPLAY_ORDER ASC,
          INVOICE_GROUP_NAME ASC,
          INVOICE_GROUP_ORDER ASC,
              LINE_ITEM_GROUP_ORDER ASC,
          LINE_ITEM_NAME ASC;

    p_SOMETHING_DONE := TRUE;

END GET_INVOICE_REPORT_RECORDS;
----------------------------------------------------------------------------------------------------
PROCEDURE CALC_BILLS_FOR_OPERATING_DATE(p_OPERATING_DATE IN DATE) IS
  v_PSE_IDS             NUMBER_COLLECTION;
  v_STATUS              NUMBER;
  v_MESSAGE            VARCHAR2(512);
  v_MESSAGE_DESC            VARCHAR2(512);
  v_PLOG_ID             NUMBER;
  v_SETTLEMENT_PSE_NAME PSE.PSE_NAME%TYPE;
  v_PLOG_STATUS         NUMBER;

  CURSOR c IS
    SELECT C.PUBLICATION_DATE,
         C.BEGIN_DATE,
         C.END_DATE,
         C.PUBLICATION_TYPE,
         C.MARKET,
         C.RUN_IDENTIFIER,
         SSE.SETTLEMENT_PSE_ID,
         SSE.PARTICIPANT_PSE_ID,
         SSE.MARKET_NAME
    FROM SEM_SETTLEMENT_CALENDAR C,
       (SELECT SETTLEMENT_PSE_ID,
           PARTICIPANT_PSE_ID,
           MARKET_NAME,
           CASE MARKET_NAME
             WHEN 'EN' THEN
              MM_SEM_SETTLEMENT_CALENDAR.c_MARKET_ENERGY
             WHEN 'MO' THEN
              MM_SEM_SETTLEMENT_CALENDAR.c_MARKET_VMOC
             WHEN 'CA' THEN
              MM_SEM_SETTLEMENT_CALENDAR.c_MARKET_CAPACITY
             WHEN 'FMO' THEN
              MM_SEM_SETTLEMENT_CALENDAR.c_MARKET_FMOC
             ELSE
              NULL
           END CALENDAR_MARKET_NAME
        FROM SEM_SETTLEMENT_ENTITY) SSE
    WHERE C.PUBLICATION_DATE = p_OPERATING_DATE
    AND C.MARKET = SSE.CALENDAR_MARKET_NAME
    ORDER BY C.BEGIN_DATE, SSE.PARTICIPANT_PSE_ID;

  CURSOR c_STATEMENT_TYPES(v_ITEM_DETAIL_TYPE IN VARCHAR2) IS
    SELECT STATEMENT_TYPE_ID, STATEMENT_TYPE_NAME
    FROM STATEMENT_TYPE
    WHERE STATEMENT_TYPE_NAME LIKE
        (SELECT '%' || S.STATEMENT_TYPE_NAME
         FROM STATEMENT_TYPE S, EXTERNAL_SYSTEM_IDENTIFIER E
         WHERE S.STATEMENT_TYPE_ID = E.ENTITY_ID
         AND E.EXTERNAL_SYSTEM_ID = 1000
         AND E.IDENTIFIER_TYPE = 'Settlement Statements'
         AND E.EXTERNAL_IDENTIFIER = v_ITEM_DETAIL_TYPE);

BEGIN
  -- initiate process log
  v_PLOG_ID := PLOG.LOG_PROCESS_START(p_PROCESS_NAME => TO_CHAR(p_OPERATING_DATE, 'YYYY-MM-DD') ||
                              ' Oper day bill calc');

  FOR r IN c LOOP
    -- loop over all the statement types related to this item detail type (which will be F, P, F(1), and the like)
    -- this will include Initial and SMO Initial, for instance
    FOR r_STATEMENT_TYPE IN c_STATEMENT_TYPES(r.RUN_IDENTIFIER) LOOP
      -- log process event start with pse name, market type, statement type, and statement date (and if invoice is being generated)

      SELECT r.SETTLEMENT_PSE_ID BULK COLLECT INTO v_PSE_IDS FROM DUAL;
      SELECT PSE_NAME INTO v_SETTLEMENT_PSE_NAME FROM PSE WHERE PSE_ID = r.SETTLEMENT_PSE_ID;

      v_MESSAGE_DESC := v_SETTLEMENT_PSE_NAME || ': ' || r_STATEMENT_TYPE.STATEMENT_TYPE_NAME;
      v_MESSAGE_DESC := v_MESSAGE_DESC || ' - ' || TO_CHAR(r.BEGIN_DATE, 'YYYY-MM-DD');
      IF r.BEGIN_DATE <> r.END_DATE THEN
        v_MESSAGE_DESC := v_MESSAGE_DESC || ' to ' || TO_CHAR(r.END_DATE, 'YYYY-MM-DD');
      END IF;
      v_MESSAGE_DESC := v_MESSAGE_DESC || ' - ' || r.PUBLICATION_TYPE;

      v_PLOG_STATUS := PLOG.LOG_PROCESS_EVENT(p_PROCESS_ID          => v_PLOG_ID,
                          p_SEVERITY_LEVEL      => PLOG.c_SEV_OK,
                          p_PROCEDURE_NAME      => NULL,
                          p_STEP_NAME           => NULL,
                          p_SOURCE              => NULL,
                          p_MESSAGE             => 'Bill calc initiation',
                          p_MESSAGE_DESCRIPTION => v_MESSAGE_DESC);


      PC.BILLING_STATEMENT_REQUEST(p_CALLING_MODULE   => 'Billing',
                    p_MODEL_ID       => GA.ELECTRIC_MODEL,
                    p_PSE_IDS       => v_PSE_IDS,
                    p_PRODUCT_ID     => -1,
                    p_COMPONENT_ID     => -1,
                    p_SCHEDULE_TYPE   => r_STATEMENT_TYPE.Statement_Type_Id,
                                  p_STATEMENT_TYPE   => r_STATEMENT_TYPE.Statement_Type_Id,
                                  p_BEGIN_DATE     => r.BEGIN_DATE,
                                  p_END_DATE       => r.END_DATE,
                                  p_INPUT_AS_OF_DATE   => NULL,
                                  p_OUTPUT_AS_OF_DATE => NULL,
                                  p_GENERATE_INVOICE   => CASE UPPER(r.PUBLICATION_TYPE) WHEN 'INVOICE' THEN 1 ELSE 0 END,
                                  p_TRACE_ON       => 0,
                                  p_PROCESS_STATUS   => v_STATUS,
                                  p_MESSAGE       => v_MESSAGE);

      v_PLOG_STATUS := PLOG.LOG_PROCESS_EVENT(p_PROCESS_ID          => v_PLOG_ID,
                          p_SEVERITY_LEVEL      => PLOG.c_SEV_OK,
                          p_PROCEDURE_NAME      => NULL,
                          p_STEP_NAME           => NULL,
                          p_SOURCE              => NULL,
                          p_MESSAGE             => 'Bill calc completed',
                          p_MESSAGE_DESCRIPTION => v_MESSAGE_DESC || ': ' || v_MESSAGE);
    END LOOP;
  END LOOP;
  v_PLOG_STATUS := PLOG.LOG_PROCESS_END(p_PROCESS_ID           => v_PLOG_ID,
                      p_RETURN_CODE          => NULL,
                      p_EXTENDED_RETURN_CODE => NULL,
                      p_MESSAGE              => NULL,
                      p_MESSAGE_DESCRIPTION  => NULL);
END CALC_BILLS_FOR_OPERATING_DATE;
----------------------------------------------------------------------------------------------------
PROCEDURE DL_SETTLEMENT_BY_OP_DATE(p_OPERATING_DATE IN DATE,
                    p_FORCE_DOWNLOADS IN NUMBER,
                    p_LOG_TYPE IN NUMBER,
                    p_TRACE_ON IN NUMBER,
                    p_STATUS OUT NUMBER,
                    p_MESSAGE OUT VARCHAR2) IS
  CURSOR c_CALENDAR IS
    SELECT C.PUBLICATION_DATE,
         C.BEGIN_DATE,
         C.END_DATE,
         C.PUBLICATION_TYPE,
         C.MARKET,
         C.RUN_IDENTIFIER
    FROM SEM_SETTLEMENT_CALENDAR C
    WHERE C.PUBLICATION_DATE = TRUNC(p_OPERATING_DATE, 'DD')
    ORDER BY C.BEGIN_DATE;

BEGIN
  FOR r IN c_CALENDAR LOOP
    DOWNLOAD_SETTLEMENT_REPORTS(r.BEGIN_DATE,
                  r.END_DATE,
                  p_FORCE_DOWNLOADS,
                  0,
                  p_LOG_TYPE,
                  p_TRACE_ON,
                  p_STATUS,
                  p_MESSAGE);
  END LOOP;
END DL_SETTLEMENT_BY_OP_DATE;
----------------------------------------------------------------------------------------------------
PROCEDURE IMPORT_CREDIT_CLOB
  (
  p_IMPORT_FILE_PATH IN VARCHAR2,
    p_IMPORT_FILE IN OUT NOCOPY CLOB,
  p_LOG_TYPE IN NUMBER,
  p_TRACE_ON IN NUMBER,
  p_STATUS  OUT NUMBER,
    p_MESSAGE OUT VARCHAR2
  ) AS
v_LOGGER MM_LOGGER_ADAPTER;
v_RPT_TYPE BINARY_INTEGER;
v_VALID_REPORT_NAME BOOLEAN := FALSE;
v_STATEMENT_TYPE_ID STATEMENT_TYPE.STATEMENT_TYPE_ID%TYPE;
v_FILENAME VARCHAR2(256);
v_PARMS UT.STRING_MAP;
v_DUMMY VARCHAR2(512);

BEGIN
  SAVEPOINT BEFORE_IMPORT;

  v_LOGGER := MM_UTIL.GET_LOGGER(EC.ES_SEM, NULL, 'Import Credit Cover Report', NULL, p_LOG_TYPE, p_TRACE_ON);
    MM_UTIL.START_EXCHANGE(TRUE, v_LOGGER);

  v_FILENAME := EXTRACT_FILE_NAME(p_IMPORT_FILE_PATH);
    PARSE_AND_VALIDATE_REP_NAME(v_FILENAME, v_RPT_TYPE, v_STATEMENT_TYPE_ID, v_VALID_REPORT_NAME, v_LOGGER);

    IF v_VALID_REPORT_NAME THEN
    -- Check if file is Credit report
    IF v_RPT_TYPE = g_CREDIT_REPORT THEN
      v_PARMS(g_HOOK_PARM_SETTLEMENT_FILE) := v_FILENAME;
      XS.PRE_MARKET_EXCHANGE(EC.ES_SEM, v_LOGGER.EXCHANGE_NAME, v_PARMS, p_IMPORT_FILE, v_LOGGER);

      IMPORT_CREDIT_REPORT(p_IMPORT_FILE, v_FILENAME, v_LOGGER);

      p_STATUS := GA.SUCCESS;
      p_MESSAGE := 'Import Complete.';
    ELSE
        v_LOGGER.LOG_ERROR('File is not a Credit Cover Report.');
        p_STATUS := GA.GENERAL_EXCEPTION;
        p_MESSAGE := 'Import Unsuccessful.';
        ROLLBACK TO BEFORE_IMPORT;
    END IF;
    ELSE
       p_STATUS := GA.GENERAL_EXCEPTION;
       p_MESSAGE := 'Import Unsuccessful.';
       ROLLBACK TO BEFORE_IMPORT;
    END IF;

    MM_UTIL.STOP_EXCHANGE(v_LOGGER, p_STATUS, p_MESSAGE, p_MESSAGE);
  p_MESSAGE := p_MESSAGE||' See event log for details.';

EXCEPTION
  WHEN OTHERS THEN
    p_STATUS := SQLCODE;
    p_MESSAGE := MM_SEM_UTIL.ERROR_STACKTRACE;
      MM_UTIL.STOP_EXCHANGE(v_LOGGER, p_STATUS, p_MESSAGE, v_DUMMY);
    ROLLBACK TO BEFORE_IMPORT;
END IMPORT_CREDIT_CLOB;
-------------------------------------------------------------------------------------------
FUNCTION GET_LOWEST_PART_ACCT_ID(p_LOGGER IN OUT NOCOPY MM_LOGGER_ADAPTER) RETURN STRING_COLLECTION IS
v_RET STRING_COLLECTION;

BEGIN

  SELECT ES.EXTERNAL_IDENTIFIER
  BULK COLLECT INTO v_RET
      FROM ENTITY_GROUP EG, EXTERNAL_SYSTEM_IDENTIFIER ES
     WHERE EG.GROUP_CATEGORY = MM_SEM_CREDIT_SHADOW.c_ENTITY_GROUP_CATEGORY --'SEM Credit'
       AND EG.ENTITY_GROUP_ID = ES.ENTITY_ID
       AND ES.EXTERNAL_SYSTEM_ID = EC.ES_SEM;

  RETURN v_RET;

EXCEPTION
  WHEN NO_DATA_FOUND THEN
    p_LOGGER.LOG_ERROR('Cannot get External Identifier for Entity Group  - Check settings in Entity Manager');
    RAISE;
  WHEN OTHERS THEN
    RAISE;
END GET_LOWEST_PART_ACCT_ID;
-------------------------------------------------------------------------------------------
PROCEDURE BUILD_TYPE3_CREDIT_COVER_REQ
(
    p_PARTICIPANT_NAME IN VARCHAR2,
    p_USER_NAME        IN VARCHAR2,
    p_TRADE_DATE       IN DATE,
    p_REQUEST_TYPE     IN VARCHAR2,
    p_FILE_NAME        IN VARCHAR2,
    p_XML_REQUEST_BODY OUT XMLTYPE
) IS
    v_TRADE_DATE VARCHAR2(10);
    v_USER_NAME  VARCHAR2(32);
BEGIN
    v_TRADE_DATE := TO_CHAR(TRUNC(p_TRADE_DATE), 'YYYY-MM-DD');
    v_USER_NAME  := NVL(p_USER_NAME, '?');

    --for Directory Listing the request_type = "LIST_REPORTS"
    --for specific report download the request_type = "REPORT" and the report_request tag
    -- has one more attribute: file_name

    SELECT XMLELEMENT("market_report",
                      XMLATTRIBUTES('MARKET_REPORT' AS "application_type",
                                    p_PARTICIPANT_NAME AS "participant_name",
                                    v_USER_NAME AS "user_name",
                                    'NORMAL' AS "mode"),
                      XMLELEMENT("report_request",
                                 XMLATTRIBUTES('DOWNLOAD' AS "action",
                                               p_REQUEST_TYPE AS "request_type",
                                               'MARKET' AS "report_type",
                                               CASE UPPER(p_REQUEST_TYPE)
                                                   WHEN 'REPORT' THEN p_FILE_NAME
                                                   ELSE NULL
                                               END "file_name",
                                               'ADHOC' AS "report_sub_type",
                                               'ADHOC' AS "periodicity",
                                               v_TRADE_DATE AS "trade_date",
                                               'false' AS "multiple_messages",
                                               '1.0' AS "version_no")))
    INTO p_XML_REQUEST_BODY
    FROM DUAL;

END BUILD_TYPE3_CREDIT_COVER_REQ;
-------------------------------------------------------------------------------------------
FUNCTION FETCH_CREDIT_COVER
(
    p_DATE       IN DATE,
    p_ACCOUNT    IN VARCHAR2,
  p_FETCH_LIST IN BOOLEAN,
  p_FILE_NAME  IN VARCHAR2,
    p_CRED       IN MEX_CREDENTIALS,
    p_LOGGER     IN OUT NOCOPY MM_LOGGER_ADAPTER
) RETURN CLOB IS

    v_RESULT       MEX_RESULT;
    v_REQUEST_XML  XMLTYPE;
    v_REQUEST_CLOB CLOB := NULL;
    v_TAG          VARCHAR2(256);
  v_REQUEST_TYPE VARCHAR2(14);
BEGIN

    DBMS_LOB.CREATETEMPORARY(v_REQUEST_CLOB, TRUE);
    DBMS_LOB.OPEN(v_REQUEST_CLOB, DBMS_LOB.LOB_READWRITE);

  --fetch directoy listing or report contents
  IF p_FETCH_LIST THEN
    v_REQUEST_TYPE := 'LIST_REPORTS';
  ELSE
    v_REQUEST_TYPE := 'REPORT';
  END IF;

    -- This tag is not in the XMLTYPE to prevent Oracle from trying to validate
    -- the doc against the specified XSD
    v_TAG := '<file_exchange xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="mi_file_exchange_sem.xsd">';
    DBMS_LOB.WRITEAPPEND(v_REQUEST_CLOB, LENGTH(v_TAG), v_TAG);

    --Build the rest of the request
    BUILD_TYPE3_CREDIT_COVER_REQ(p_ACCOUNT, p_CRED.USERNAME, p_DATE, v_REQUEST_TYPE, p_FILE_NAME, v_REQUEST_XML);

    -- Add this XML to the request CLOB
    DBMS_LOB.APPEND(v_REQUEST_CLOB, v_REQUEST_XML.GETCLOBVAL());
    -- And stick the trailing close-tag
    v_TAG := '</file_exchange>';
    DBMS_LOB.WRITEAPPEND(v_REQUEST_CLOB, LENGTH(v_TAG), v_TAG);
    DBMS_LOB.CLOSE(v_REQUEST_CLOB);

    IF MM_SEM_UTIL.g_TEST THEN
        p_LOGGER.LOG_START('test.' || MM_SEM_UTIL.g_MEX_MARKET, MM_SEM_UTIL.g_MEX_ACTION_SETTLEMENT_DIRL);
        p_LOGGER.LOG_ATTACHMENT('Request Body', 'text/xml', v_REQUEST_CLOB);
        p_LOGGER.LOG_STOP(0, 'Success');
    RETURN NULL;
    ELSE
        --Invoke the MEX Switchboard
        v_RESULT := MEX_SWITCHBOARD.Invoke(p_Market              => MM_SEM_UTIL.g_MEX_MARKET,
                                           p_Action              => MM_SEM_UTIL.g_MEX_ACTION_REPORTS,
                                           p_Logger              => p_LOGGER,
                                           p_Cred                => p_CRED,
                                           p_Request_ContentType => 'text/xml',
                                           p_Request             => v_REQUEST_CLOB);

        IF v_RESULT.STATUS_CODE <> MEX_Switchboard.c_Status_Success THEN
            RETURN NULL; -- this indicates failure - MEX_Switchboard.Invoke will have already logged error message
        ELSE
            RETURN v_RESULT.RESPONSE;
        END IF;
    END IF;

    IF v_REQUEST_CLOB IS NOT NULL THEN
        IF DBMS_LOB.ISOPEN(v_REQUEST_CLOB) <> 0 THEN
            DBMS_LOB.CLOSE(v_REQUEST_CLOB);
        END IF;
        DBMS_LOB.FREETEMPORARY(v_REQUEST_CLOB);
    END IF;

EXCEPTION
    WHEN OTHERS THEN
        IF v_REQUEST_CLOB IS NOT NULL THEN
            IF DBMS_LOB.ISOPEN(v_REQUEST_CLOB) <> 0 THEN
                DBMS_LOB.CLOSE(v_REQUEST_CLOB);
            END IF;
            DBMS_LOB.FREETEMPORARY(v_REQUEST_CLOB);
        END IF;
    p_LOGGER.LOG_ERROR('Error downloading credit cover report listing: '||MM_SEM_UTIL.ERROR_STACKTRACE);
    RAISE;

END FETCH_CREDIT_COVER;
--------------------------------------------------------------------------------------------
PROCEDURE QUERY_CREDIT_COVER
(
    p_BEGIN_DATE   IN DATE,
  p_END_DATE     IN DATE,
    p_LOG_TYPE     IN NUMBER,
    p_TRACE_ON     IN NUMBER,
    p_STATUS       OUT NUMBER,
    p_MESSAGE      OUT VARCHAR2
) AS

    v_RESPONSE_CLOB CLOB;
    v_LOGGER        MM_LOGGER_ADAPTER;
    v_CRED          MEX_CREDENTIALS;
  v_DATE          DATE;
  v_DUMMY         VARCHAR2(512);
  v_ACCOUNTS      STRING_COLLECTION;
  v_REPORTS       STRING_COLLECTION;
  v_IDX           BINARY_INTEGER;
  v_JDX           BINARY_INTEGER;
  v_ACCOUNT_NAME  VARCHAR2(64);
  v_XML           XMLTYPE;
  v_REPORT_NAME   VARCHAR2(64);
  c_DATE_FORMAT_V3 VARCHAR2(10) := 'YYYY-MM-DD';
  c_DATE_FORMAT_V2 VARCHAR2(10) := 'DD-MM-YYYY';
  v_DATE_FORMAT   VARCHAR2(10);
  v_REPORT_DATE   VARCHAR2(10);
BEGIN

  v_LOGGER := MM_UTIL.GET_LOGGER(EC.ES_SEM, NULL, 'Query Credit Report Type3', 'Query Credit Report Type3', p_LOG_TYPE, p_TRACE_ON);
  MM_UTIL.START_EXCHANGE(FALSE, v_LOGGER);

  --The report's file_name is dependent on the participant name which is the
  --lowest numbered Participant Account ID for the Code Participant
  v_ACCOUNTS := GET_LOWEST_PART_ACCT_ID(v_LOGGER);

  v_IDX := v_ACCOUNTS.FIRST;
  WHILE v_ACCOUNTS.EXISTS(v_IDX) LOOP
    v_ACCOUNT_NAME := v_ACCOUNTS(v_IDX);
        BEGIN
            -- ignore the returned logger - we already have a logger we can use
            MM_UTIL.INIT_MEX(EC.ES_SEM,
                             v_ACCOUNT_NAME,
                             'Query Credit Report Type3',
                             'Query Credit Report Type3',
                             p_LOG_TYPE,
                             p_TRACE_ON,
                             v_CRED,
                             v_LOGGER);
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                v_LOGGER.LOG_ERROR('No external credentials available for "' || v_ACCOUNT_NAME ||
                           '. Credit Cover Type3 request not submitted.');
                v_CRED := NULL;
        END;

      IF v_CRED IS NOT NULL OR MM_SEM_UTIL.g_TEST THEN -- no credentials? no need to proceed
        v_DATE := TRUNC(p_BEGIN_DATE);

        --Loop over dates
        WHILE v_DATE <= p_END_DATE LOOP
          --fetch directory listing first
          v_RESPONSE_CLOB := FETCH_CREDIT_COVER(v_DATE, v_ACCOUNT_NAME, TRUE, NULL, v_CRED, v_LOGGER);
          IF v_RESPONSE_CLOB IS NOT NULL THEN
            --retrieve the list of files
          v_XML := XMLTYPE.CREATEXML(v_RESPONSE_CLOB);
          -- parse file names from the response
              SELECT EXTRACTVALUE(VALUE(T), '/report_item/@file_name', g_DIR_LIST_NAMESPACE)
            BULK COLLECT INTO v_REPORTS
              FROM TABLE(XMLSEQUENCE(EXTRACT(v_XML, '//report_response/report_item', g_DIR_LIST_NAMESPACE))) T;

            v_JDX := v_REPORTS.FIRST;
            --loop over the list of CCR reports and make specific report download
          --skip any files that are not for the requested day
              WHILE v_REPORTS.EXISTS(v_JDX) LOOP
            v_REPORT_NAME := v_REPORTS(v_JDX);

            --In version 002 the date in the file name is in DD_MM_YYYY format,
            --whereas in version 003 the date is of the form YYYY-MM-DD.
            --get the right date format and convert it to date using that format.
            v_REPORT_DATE :=  SUBSTR(SUBSTR(v_REPORT_NAME,-14),1,10);
            IF REGEXP_SUBSTR(v_REPORT_DATE, '([0-9]{4})-([0-9]{2})-([0-9]{2})') IS NOT NULL THEN
              v_DATE_FORMAT := c_DATE_FORMAT_V3; --YYYY-MM-DD
            ELSIF REGEXP_SUBSTR(v_REPORT_DATE, '([0-9]{4})-([0-9]{2})-([0-9]{2})') IS NOT NULL THEN
              v_DATE_FORMAT := c_DATE_FORMAT_V2; --DD-MM-YYYY
            ELSE
              v_DATE_FORMAT := NULL; --wrong date format
            END IF;

            IF v_DATE_FORMAT IS NOT NULL THEN
              IF v_DATE = TO_DATE(v_REPORT_DATE,v_DATE_FORMAT) THEN
                v_LOGGER.LOG_INFO('Importing file "'||v_REPORT_NAME||'".');
                v_RESPONSE_CLOB := FETCH_CREDIT_COVER(v_DATE, v_ACCOUNT_NAME, FALSE, v_REPORTS(v_JDX), v_CRED, v_LOGGER);
                IF v_RESPONSE_CLOB IS NOT NULL THEN
                  -- import the report
                  IMPORT_CREDIT_REPORT(v_RESPONSE_CLOB, v_REPORT_NAME, v_LOGGER);
                END IF;
                COMMIT;
              ELSE
                v_LOGGER.LOG_INFO('Skipping file "'||v_REPORT_NAME||'" - not in requested date range.');
              END IF;
            ELSE
              v_LOGGER.LOG_INFO('Date format ' || v_REPORT_DATE || ' in "'||v_REPORT_NAME||'" cannot be parsed; file skipped.');
            END IF;
              v_JDX := v_REPORTS.NEXT(v_JDX);
              END LOOP;--end over CCR reports

          END IF;

          v_DATE := v_DATE + 1;
        END LOOP; --end over dates

      END IF;

    v_IDX := v_ACCOUNTS.NEXT(v_IDX);
    END LOOP;--end over accounts

  v_LOGGER.EXCHANGE_NAME := 'Downloading Credit Cover Reports';

  p_STATUS := GA.SUCCESS;
  p_MESSAGE := v_LOGGER.GET_END_MESSAGE();
  MM_UTIL.STOP_EXCHANGE(v_LOGGER, p_STATUS, p_MESSAGE, p_MESSAGE);

EXCEPTION
    WHEN OTHERS THEN
    p_STATUS := SQLCODE;
    p_MESSAGE := MM_SEM_UTIL.ERROR_STACKTRACE;

    MM_UTIL.STOP_EXCHANGE(v_LOGGER, p_STATUS, p_MESSAGE, v_DUMMY);

END QUERY_CREDIT_COVER;
----------------------------------------------------------------------------------------------------
PROCEDURE IMPORT_CANCELLED_SRA_CLOB
  (
    p_IMPORT_FILE_PATH IN VARCHAR2,
    p_IMPORT_FILE IN OUT NOCOPY CLOB,
  p_LOG_TYPE IN NUMBER,
  p_TRACE_ON IN NUMBER,
  p_STATUS  OUT NUMBER,
    p_MESSAGE OUT VARCHAR2
  ) AS
v_LOGGER MM_LOGGER_ADAPTER;
v_RPT_TYPE BINARY_INTEGER;
v_VALID_REPORT_NAME BOOLEAN := FALSE;
v_STATEMENT_TYPE_ID STATEMENT_TYPE.STATEMENT_TYPE_ID%TYPE;
v_FILENAME VARCHAR2(256);
v_DUMMY VARCHAR2(512);

BEGIN
  SAVEPOINT BEFORE_IMPORT;

  v_LOGGER := MM_UTIL.GET_LOGGER(EC.ES_SEM, NULL, 'Import Cancelled SRA', NULL, p_LOG_TYPE, p_TRACE_ON);
    MM_UTIL.START_EXCHANGE(TRUE, v_LOGGER);


  v_FILENAME := EXTRACT_FILE_NAME(p_IMPORT_FILE_PATH);
    PARSE_AND_VALIDATE_REP_NAME(v_FILENAME, v_RPT_TYPE, v_STATEMENT_TYPE_ID, v_VALID_REPORT_NAME, v_LOGGER);

    IF v_VALID_REPORT_NAME THEN
    -- Check if file is Reallocation Agreement report
    IF v_RPT_TYPE = c_CANCELLED_SRA_REPORT THEN
       IMPORT_CANCELLED_SRA_REPORT(v_FILENAME, p_IMPORT_FILE, v_LOGGER);
       p_STATUS := GA.SUCCESS;
       p_MESSAGE := 'Import Complete.';
      ELSE
       v_LOGGER.LOG_ERROR('File is not a Cancelled SRA report.');
       p_STATUS := GA.GENERAL_EXCEPTION;
       p_MESSAGE := 'Import Unsuccessful.';
       ROLLBACK TO BEFORE_IMPORT;
    END IF;
    ELSE
       p_STATUS := GA.GENERAL_EXCEPTION;
       p_MESSAGE := 'Import Unsuccessful.';
       ROLLBACK TO BEFORE_IMPORT;
    END IF;

    MM_UTIL.STOP_EXCHANGE(v_LOGGER, p_STATUS, p_MESSAGE, p_MESSAGE);
  p_MESSAGE := p_MESSAGE||' See event log for details.';

EXCEPTION
  WHEN OTHERS THEN
    p_STATUS := SQLCODE;
    p_MESSAGE := MM_SEM_UTIL.ERROR_STACKTRACE;
        MM_UTIL.STOP_EXCHANGE(v_LOGGER, p_STATUS, p_MESSAGE, v_DUMMY);
    ROLLBACK TO BEFORE_IMPORT;

END IMPORT_CANCELLED_SRA_CLOB;
----------------------------------------------------------------------------------------------------
BEGIN
  -- init the intervals map
  g_MARKET_INTERVALS(g_ENERGY_MARKET_NAME) := 'Week';
  g_MARKET_INTERVALS(g_VARIABLE_MOC_MARKET_NAME) := 'Week';
  g_MARKET_INTERVALS(g_CAPACITY_MARKET_NAME) := 'Month';
  g_MARKET_INTERVALS(g_FIXED_MOC_MARKET_NAME) := 'Month';

  -- initialize the map of Invoice Market Names to market abbreviations
  FOR v_REC IN (SELECT SETTING_NAME, VALUE
           FROM SYSTEM_DICTIONARY
           WHERE MODEL_ID = 0 -- global
              AND MODULE = 'MarketExchange'
           AND KEY1 = 'SEM'
           AND KEY2 = 'Settlement'
           AND KEY3 = 'Invoice Markets') LOOP
    g_MARKET_NAMES(v_REC.SETTING_NAME) := v_REC.VALUE;
  END LOOP;

  IF g_MARKET_NAMES.COUNT = 0 THEN
    -- fill w/ defaults
    g_MARKET_NAMES('Energy Market') := 'EN';
    g_MARKET_NAMES('Capacity Market') := 'CA';
    g_MARKET_NAMES('Fixed Market Operator Charge') := 'FMO';
    g_MARKET_NAMES('Variable Market Operator Charge') := 'MO';
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    -- fill w/ defaults
    g_MARKET_NAMES('Energy Market') := 'EN';
    g_MARKET_NAMES('Capacity Market') := 'CA';
    g_MARKET_NAMES('Fixed Market Operator Charge') := 'FMO';
    g_MARKET_NAMES('Variable Market Operator Charge') := 'MO';
END MM_SEM_SETTLEMENT;
/
