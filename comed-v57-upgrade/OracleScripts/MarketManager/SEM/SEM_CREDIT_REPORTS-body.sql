CREATE OR REPLACE PACKAGE BODY SEM_CREDIT_REPORTS IS

	g_NOT_ASSIGNED CONSTANT NUMBER(1) := 0;
	g_ALL CONSTANT NUMBER(2) := -1;
	g_ALL_STRING VARCHAR2(8) := '<ALL>';
----------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
	RETURN '$Revision: 1.8 $';
END WHAT_VERSION;
----------------------------------------------------------------------------------------
PROCEDURE GET_CREDIT_SUMMARY_PARTY_RPT
	(
	p_ENTITY_GROUP_ID IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CURSOR IN OUT REF_CURSOR
	) AS
	v_BEGIN_DATE DATE := TRUNC(p_BEGIN_DATE);
	v_END_DATE DATE := TRUNC(p_END_DATE);
BEGIN

	OPEN p_CURSOR FOR
		SELECT PTY.ASSESSMENT_DATE,
			EG.ENTITY_GROUP_NAME,
			PTY.PARTICIPANT_STATUS,
			PTY.ENTITY_GROUP_ID,
			PTY.CURRENCY,
			PTY.GROSS_CC "GROSS_CC",
			PTY.REQD_CREDIT_COVER "REQD_CREDIT_COVER",
			PTY.NET_CC_ALL_SRAS "NET_CC_ALL_SRAS",
			PTY.POSTED_CREDIT_COVER "POSTED_CREDIT_COVER",
			PTY.INVOICES_NOT_PAID "INVOICES_NOT_PAID",
			PTY.SETTLEMENT_NOT_INVOICED "SETTLEMENT_NOT_INVOICED",
			NVL(PTY.INTCONN_TRADED_AMT,0) "INTCONN_TRADED_AMT",
			PTY.UNDEFINED_EXPOSURE "UNDEFINED_EXPOSURE",
			PTY.FIXED_CREDIT_REQT "FIXED_CREDIT_REQT",
			PTY.WARNING_LIMIT "WARNING_LIMIT",
			PTY.CALCULATED_DATE "CALCULATED_DATE",
			RO.GET_ENTITY_ATTRIBUTE(MM_SEM_CREDIT_SHADOW.c_ATTR_TRADE_LIMIT, EC.ED_ENTITY_GROUP, PTY.ENTITY_GROUP_ID, PTY.ASSESSMENT_DATE) "TRADE_LIMIT",
			RO.GET_ENTITY_ATTRIBUTE(MM_SEM_CREDIT_SHADOW.c_ATTR_COST_OF_POSTING, EC.ED_ENTITY_GROUP, PTY.ENTITY_GROUP_ID, PTY.ASSESSMENT_DATE) "PCT_COST_OF_POSTING"
		FROM SEM_CREDIT_RESULT PTY, ENTITY_GROUP EG
		WHERE PTY.ASSESSMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND PTY.STATEMENT_TYPE_ID = p_STATEMENT_TYPE
			AND PTY.STATEMENT_STATE = p_STATEMENT_STATE
			AND PTY.PSE_ID = g_NOT_ASSIGNED
			AND EG.ENTITY_GROUP_ID = PTY.ENTITY_GROUP_ID
			AND (p_ENTITY_GROUP_ID = g_ALL OR EG.ENTITY_GROUP_ID = p_ENTITY_GROUP_ID)
		ORDER BY 1,2;

END GET_CREDIT_SUMMARY_PARTY_RPT;
----------------------------------------------------------------------------------------
PROCEDURE GET_CREDIT_SUMMARY_PSE_RPT
	(
	p_ENTITY_GROUP_ID IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CURSOR IN OUT REF_CURSOR
	) AS
	v_BEGIN_DATE DATE := TRUNC(p_BEGIN_DATE);
	v_END_DATE DATE := TRUNC(p_END_DATE);
BEGIN

	OPEN p_CURSOR FOR
		SELECT ASSESSMENT_DATE,
			B.PSE_NAME,
			A.CREDIT_MARKET,
			PARTICIPANT_STATUS,
			CURRENCY,
			REQD_CREDIT_COVER "REQD_CREDIT_COVER",
			POSTED_CREDIT_COVER "POSTED_CREDIT_COVER",
			INVOICES_NOT_PAID "INVOICES_NOT_PAID",
			SETTLEMENT_NOT_INVOICED "SETTLEMENT_NOT_INVOICED",
			NVL(A.INTCONN_TRADED_AMT,0) "INTCONN_TRADED_AMT",
			UNDEFINED_EXPOSURE "UNDEFINED_EXPOSURE",
			FIXED_CREDIT_REQT "FIXED_CREDIT_REQT",
			SRAS_TOTAL - SRAS_SUBMITTED "SRAS_PENDING",
			SRAS_SUBMITTED "SRAS_SUBMITTED",
			WARNING_LIMIT,
			BREACH_AMOUNT "BREACH_AMOUNT",
			CALCULATED_DATE,
			B.PSE_ID
		FROM SEM_CREDIT_RESULT A, PURCHASING_SELLING_ENTITY B
		WHERE ASSESSMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND STATEMENT_TYPE_ID = p_STATEMENT_TYPE
			AND STATEMENT_STATE = p_STATEMENT_STATE
			AND A.PSE_ID > g_NOT_ASSIGNED
			AND B.PSE_ID = A.PSE_ID
			AND (p_ENTITY_GROUP_ID = g_ALL OR A.ENTITY_GROUP_ID = p_ENTITY_GROUP_ID)
		ORDER BY 1,2,3 DESC;

END GET_CREDIT_SUMMARY_PSE_RPT;
----------------------------------------------------------------------------------------
PROCEDURE GET_CREDIT_SUMMARY_ALL_RPT
	(
	p_ENTITY_GROUP_ID IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CURSOR IN OUT REF_CURSOR
	) AS
	v_BEGIN_DATE DATE := TRUNC(p_BEGIN_DATE);
	v_END_DATE DATE := TRUNC(p_END_DATE);
BEGIN

	OPEN p_CURSOR FOR
		--GET THE ENTITY GROUP ROWS
		SELECT ASSESSMENT_DATE,
			B.ENTITY_GROUP_NAME,
			'<Total>' "PSE_NAME",
			CREDIT_MARKET,
			PARTICIPANT_STATUS,
			CURRENCY,
			REQD_CREDIT_COVER "COL_REQD_CREDIT_COVER", --Columns renamed for Conditional Format logic in UI.
			POSTED_CREDIT_COVER "COL_POSTED_CREDIT_COVER",
			INVOICES_NOT_PAID "INVOICES_NOT_PAID",
			SETTLEMENT_NOT_INVOICED "SETTLEMENT_NOT_INVOICED",
			UNDEFINED_EXPOSURE "UNDEFINED_EXPOSURE",
			FIXED_CREDIT_REQT "FIXED_CREDIT_REQT",
			SRAS_TOTAL - SRAS_SUBMITTED "SRAS_PENDING",
			SRAS_SUBMITTED "SRAS_SUBMITTED",
			WARNING_LIMIT "COL_WARNING_LIMIT",
			BREACH_AMOUNT "BREACH_AMOUNT",
			CALCULATED_DATE,
			A.ENTITY_GROUP_ID,
			'Y' "IS_PARTY"
		FROM SEM_CREDIT_RESULT A, ENTITY_GROUP B
		WHERE ASSESSMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND STATEMENT_TYPE_ID = p_STATEMENT_TYPE
			AND STATEMENT_STATE = p_STATEMENT_STATE
			AND PSE_ID = g_NOT_ASSIGNED
			AND B.ENTITY_GROUP_ID = A.ENTITY_GROUP_ID
			AND (p_ENTITY_GROUP_ID = g_ALL OR B.ENTITY_GROUP_ID = p_ENTITY_GROUP_ID)

		UNION ALL

		--GET THE PSE ROWS
		SELECT ASSESSMENT_DATE,
			E.ENTITY_GROUP_NAME,
			B.PSE_NAME,
			A.CREDIT_MARKET,
			PARTICIPANT_STATUS,
			CURRENCY,
			REQD_CREDIT_COVER "COL_REQD_CREDIT_COVER",
			POSTED_CREDIT_COVER "COL_POSTED_CREDIT_COVER",
			INVOICES_NOT_PAID "INVOICES_NOT_PAID",
			SETTLEMENT_NOT_INVOICED "SETTLEMENT_NOT_INVOICED",
			UNDEFINED_EXPOSURE "UNDEFINED_EXPOSURE",
			FIXED_CREDIT_REQT "FIXED_CREDIT_REQT",
			SRAS_TOTAL - SRAS_SUBMITTED "SRAS_PENDING",
			SRAS_SUBMITTED "SRAS_SUBMITTED",
			WARNING_LIMIT "COL_WARNING_LIMIT",
			BREACH_AMOUNT "BREACH_AMOUNT",
			CALCULATED_DATE,
			A.ENTITY_GROUP_ID,
			'N' "IS_PARTY"
		FROM SEM_CREDIT_RESULT A, PURCHASING_SELLING_ENTITY B, ENTITY_GROUP E
		WHERE ASSESSMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND STATEMENT_TYPE_ID = p_STATEMENT_TYPE
			AND STATEMENT_STATE = p_STATEMENT_STATE
			AND A.PSE_ID > g_NOT_ASSIGNED
			AND B.PSE_ID = A.PSE_ID
			AND (p_ENTITY_GROUP_ID = g_ALL OR A.ENTITY_GROUP_ID = p_ENTITY_GROUP_ID)
			AND E.ENTITY_GROUP_ID = A.ENTITY_GROUP_ID

		ORDER BY 1,2,3;

END GET_CREDIT_SUMMARY_ALL_RPT;
----------------------------------------------------------------------------------------
PROCEDURE GET_CREDIT_CALC_EXTERNAL_RPT
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CURSOR IN OUT REF_CURSOR
	) AS
	v_BEGIN_DATE DATE := TRUNC(p_BEGIN_DATE);
	v_END_DATE DATE := TRUNC(p_END_DATE);
BEGIN
	OPEN p_CURSOR FOR
		SELECT ASSESSMENT_DATE,
			CREDIT_MARKET,
			UNDEFINED_PERIOD,
			ANALYSIS_PERCENTILE_PARAM,
			HIST_ASSESSMENT_PERIOD,
			CREDIT_ASSESSMENT_PRICE,
			CAPACITY_ADJUSTMENT_FACTOR
		FROM SEM_CREDIT_CALC_EXTERNAL
		WHERE ASSESSMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		ORDER BY 1, 2 DESC;

END GET_CREDIT_CALC_EXTERNAL_RPT;
----------------------------------------------------------------------------------------
PROCEDURE GET_YEARLY_INPUTS_RPT
	(
	p_CURSOR IN OUT REF_CURSOR
	) AS
BEGIN

	OPEN p_CURSOR FOR
		SELECT *
		FROM SEM_CREDIT_INPUT_YEARLY A
		ORDER BY BEGIN_DATE;

END GET_YEARLY_INPUTS_RPT;
----------------------------------------------------------------------------------------
PROCEDURE PUT_YEARLY_INPUTS_RPT
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ANALYSIS_PERCENTILE_PARAM IN NUMBER,
	p_FIXED_CREDIT_REQT_SUP IN NUMBER,
	p_FIXED_CREDIT_REQT_GEN IN NUMBER,
	p_VAR_MO_PRICE IN NUMBER,
	p_IMPERFECTIONS_PRICE IN NUMBER,
	p_HIST_ASSESSMENT_PERIOD_EN IN NUMBER,
	p_HIST_ASSESSMENT_PERIOD_CA IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE
	) AS
	v_BEGIN_DATE DATE := TRUNC(p_BEGIN_DATE);
	v_END_DATE DATE := TRUNC(p_END_DATE);
BEGIN

	UPDATE SEM_CREDIT_INPUT_YEARLY
	SET END_DATE = v_END_DATE,
		ANALYSIS_PERCENTILE_PARAM = p_ANALYSIS_PERCENTILE_PARAM,
		FIXED_CREDIT_REQT_SUP = p_FIXED_CREDIT_REQT_SUP,
		FIXED_CREDIT_REQT_GEN = p_FIXED_CREDIT_REQT_GEN,
		VAR_MO_PRICE = p_VAR_MO_PRICE,
		IMPERFECTIONS_PRICE = p_IMPERFECTIONS_PRICE,
		HIST_ASSESSMENT_PERIOD_EN = p_HIST_ASSESSMENT_PERIOD_EN,
		HIST_ASSESSMENT_PERIOD_CA = p_HIST_ASSESSMENT_PERIOD_CA
	WHERE BEGIN_DATE = p_OLD_BEGIN_DATE;

	IF SQL%NOTFOUND THEN
		INSERT INTO SEM_CREDIT_INPUT_YEARLY(
			BEGIN_DATE,
			END_DATE,
			ANALYSIS_PERCENTILE_PARAM,
			FIXED_CREDIT_REQT_SUP,
			FIXED_CREDIT_REQT_GEN,
			VAR_MO_PRICE,
			IMPERFECTIONS_PRICE,
			HIST_ASSESSMENT_PERIOD_EN,
			HIST_ASSESSMENT_PERIOD_CA)
		VALUES (
			v_BEGIN_DATE,
			v_END_DATE,
			p_ANALYSIS_PERCENTILE_PARAM,
			p_FIXED_CREDIT_REQT_SUP,
			p_FIXED_CREDIT_REQT_GEN,
			p_VAR_MO_PRICE,
			p_IMPERFECTIONS_PRICE,
			p_HIST_ASSESSMENT_PERIOD_EN,
			p_HIST_ASSESSMENT_PERIOD_CA);
	END IF;

END PUT_YEARLY_INPUTS_RPT;
----------------------------------------------------------------------------------------
PROCEDURE CREATE_CREDIT_ATTRIBUTES IS
-- Creates all the Entity Attributes that are used in this package.
	v_ID NUMBER(9);
BEGIN

	ID.ID_FOR_ENTITY_ATTRIBUTE(MM_SEM_CREDIT_SHADOW.c_ATTR_DAYS_TO_PAY_INVOICE, EC.ED_PSE, 'Number', TRUE, v_ID);
	ID.ID_FOR_ENTITY_ATTRIBUTE(MM_SEM_CREDIT_SHADOW.c_ATTR_SUP_SUSP_PERIOD, EC.ED_SC, 'Number', TRUE, v_ID);
	ID.ID_FOR_ENTITY_ATTRIBUTE(MM_SEM_CREDIT_SHADOW.c_ATTR_SUP_SUSP_PERIOD_TYPE, EC.ED_SC, 'String', TRUE, v_ID);
	ID.ID_FOR_ENTITY_ATTRIBUTE(MM_SEM_CREDIT_SHADOW.c_ATTR_GEN_SUSP_PERIOD, EC.ED_SC, 'Number', TRUE, v_ID);
	ID.ID_FOR_ENTITY_ATTRIBUTE(MM_SEM_CREDIT_SHADOW.c_ATTR_GEN_SUSP_PERIOD_TYPE, EC.ED_SC, 'String', TRUE, v_ID);
	ID.ID_FOR_ENTITY_ATTRIBUTE(MM_SEM_CREDIT_SHADOW.c_ATTR_PARTY_CURRENCY, EC.ED_ENTITY_GROUP, 'String', TRUE, v_ID);
	ID.ID_FOR_ENTITY_ATTRIBUTE(MM_SEM_CREDIT_SHADOW.c_ATTR_WARNING_LIMIT, EC.ED_ENTITY_GROUP, 'Number', TRUE, v_ID);
	ID.ID_FOR_ENTITY_ATTRIBUTE(MM_SEM_CREDIT_SHADOW.c_ATTR_PSE_STATUS, EC.ED_PSE, 'String', TRUE, v_ID);
	ID.ID_FOR_ENTITY_ATTRIBUTE(MM_SEM_CREDIT_SHADOW.c_ATTR_TRADE_LIMIT, EC.ED_ENTITY_GROUP, 'Number', TRUE, v_ID);
	ID.ID_FOR_ENTITY_ATTRIBUTE(MM_SEM_CREDIT_SHADOW.c_ATTR_INITIAL_CREDIT_PRICE, EC.ED_SC, 'Number', TRUE, v_ID);
	ID.ID_FOR_ENTITY_ATTRIBUTE(MM_SEM_CREDIT_SHADOW.c_ATTR_INITIAL_CAP_PRICE, EC.ED_SC, 'Number', TRUE, v_ID);
	ID.ID_FOR_ENTITY_ATTRIBUTE(MM_SEM_CREDIT_SHADOW.c_ATTR_INITIAL_ENERGY_PRICE, EC.ED_SC, 'Number', TRUE, v_ID);
	ID.ID_FOR_ENTITY_ATTRIBUTE(MM_SEM_CREDIT_SHADOW.c_ATTR_COST_OF_POSTING, EC.ED_ENTITY_GROUP, 'Number', TRUE, v_ID);

EXCEPTION
	WHEN OTHERS THEN
		RAISE_APPLICATION_ERROR(-20000, 'Unable to create Entity Attributes for SEM Credit in MM_SEM_CREDIT_SHADOW.CREATE_CREDIT_ATTRIBUTES.  Error(' || SQLCODE || ') ' || SQLERRM);
END CREATE_CREDIT_ATTRIBUTES;
-----------------------------------------------------------------------------------------------------------------

PROCEDURE GET_ATTRIBUTE_INPUTS_RPT
	(
	p_ENTITY_TYPE IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CURSOR IN OUT REF_CURSOR
	) AS
	v_ENTITY_DOMAIN_ID NUMBER(9);
	v_SC_ID NUMBER(9);
BEGIN
	--Be sure all the Entity Attributes exist.
	CREATE_CREDIT_ATTRIBUTES;

	IF p_ENTITY_TYPE = 'Party' THEN
		v_ENTITY_DOMAIN_ID := EC.ED_ENTITY_GROUP;

		OPEN p_CURSOR FOR
		SELECT A.ENTITY_GROUP_NAME "ENTITY_NAME",
			B.ATTRIBUTE_NAME,
			NVL(C.BEGIN_DATE, DATE '2000-01-01') "ATTRIBUTE_BEGIN_DATE",
			C.END_DATE "ATTRIBUTE_END_DATE",
			C.ATTRIBUTE_VAL,
			A.ENTITY_GROUP_ID "OWNER_ENTITY_ID",
			B.ATTRIBUTE_ID
		FROM ENTITY_GROUP A, ENTITY_ATTRIBUTE B, TEMPORAL_ENTITY_ATTRIBUTE C
		WHERE A.GROUP_CATEGORY = MM_SEM_CREDIT_SHADOW.c_ENTITY_GROUP_CATEGORY
			AND B.ENTITY_DOMAIN_ID = v_ENTITY_DOMAIN_ID
			AND B.ATTRIBUTE_NAME LIKE 'SEM:Credit:%'
			AND C.OWNER_ENTITY_ID = A.ENTITY_GROUP_ID
			AND C.ATTRIBUTE_ID = B.ATTRIBUTE_ID
			AND C.BEGIN_DATE <= p_END_DATE
			AND NVL(C.END_DATE, p_END_DATE) >= p_BEGIN_DATE
		UNION ALL
		--Do a cartesian merge to get an attribute for each entity.
		SELECT DISTINCT A.ENTITY_GROUP_NAME "ENTITY_NAME",
			B.ATTRIBUTE_NAME,
			DATE '2000-01-01' "ATTRIBUTE_BEGIN_DATE",
			NULL "ATTRIBUTE_END_DATE",
			NULL "ATTRIBUTE_VAL",
			A.ENTITY_GROUP_ID "OWNER_ENTITY_ID",
			B.ATTRIBUTE_ID
		FROM ENTITY_GROUP A, ENTITY_ATTRIBUTE B
		WHERE A.GROUP_CATEGORY = MM_SEM_CREDIT_SHADOW.c_ENTITY_GROUP_CATEGORY
			AND B.ENTITY_DOMAIN_ID = v_ENTITY_DOMAIN_ID
			AND B.ATTRIBUTE_NAME LIKE 'SEM:Credit:%'
			AND NOT EXISTS
				(SELECT 1 FROM TEMPORAL_ENTITY_ATTRIBUTE
				WHERE ATTRIBUTE_ID = B.ATTRIBUTE_ID
				AND OWNER_ENTITY_ID = A.ENTITY_GROUP_ID
				AND BEGIN_DATE <= p_END_DATE AND NVL(END_DATE, p_END_DATE) >= p_BEGIN_DATE)
		ORDER BY 1,2,3;

	ELSIF p_ENTITY_TYPE = 'Participant' THEN
		v_ENTITY_DOMAIN_ID := EC.ED_PSE;

		OPEN p_CURSOR FOR
		SELECT A.PSE_NAME "ENTITY_NAME",
			B.ATTRIBUTE_NAME,
			NVL(C.BEGIN_DATE, DATE '2000-01-01') "ATTRIBUTE_BEGIN_DATE",
			C.END_DATE "ATTRIBUTE_END_DATE",
			C.ATTRIBUTE_VAL,
			A.PSE_ID "OWNER_ENTITY_ID",
			B.ATTRIBUTE_ID
		FROM PURCHASING_SELLING_ENTITY A, ENTITY_ATTRIBUTE B, TEMPORAL_ENTITY_ATTRIBUTE C,
			ENTITY_GROUP EG, ENTITY_GROUP_ASSIGNMENT EGA
		WHERE EG.GROUP_CATEGORY = MM_SEM_CREDIT_SHADOW.c_ENTITY_GROUP_CATEGORY
			AND EGA.ENTITY_GROUP_ID = EG.ENTITY_GROUP_ID
			AND A.PSE_ID = EGA.ENTITY_ID
			AND B.ENTITY_DOMAIN_ID = v_ENTITY_DOMAIN_ID
			AND B.ATTRIBUTE_NAME LIKE 'SEM:Credit:%'
			AND C.OWNER_ENTITY_ID = A.PSE_ID
			AND C.ATTRIBUTE_ID = B.ATTRIBUTE_ID
			AND C.BEGIN_DATE <= p_END_DATE
			AND NVL(C.END_DATE, p_END_DATE) >= p_BEGIN_DATE
		UNION ALL
		--Do a cartesian merge to get an attribute for each entity.
		SELECT DISTINCT A.PSE_NAME "ENTITY_NAME",
			B.ATTRIBUTE_NAME,
			DATE '2000-01-01' "ATTRIBUTE_BEGIN_DATE",
			NULL "ATTRIBUTE_END_DATE",
			NULL "ATTRIBUTE_VAL",
			A.PSE_ID "OWNER_ENTITY_ID",
			B.ATTRIBUTE_ID
		FROM PURCHASING_SELLING_ENTITY A, ENTITY_ATTRIBUTE B,
			ENTITY_GROUP EG, ENTITY_GROUP_ASSIGNMENT EGA
		WHERE EG.GROUP_CATEGORY = MM_SEM_CREDIT_SHADOW.c_ENTITY_GROUP_CATEGORY
			AND EGA.ENTITY_GROUP_ID = EG.ENTITY_GROUP_ID
			AND A.PSE_ID = EGA.ENTITY_ID
			AND B.ENTITY_DOMAIN_ID = v_ENTITY_DOMAIN_ID
			AND B.ATTRIBUTE_NAME LIKE 'SEM:Credit:%'
			AND NOT EXISTS
				(SELECT 1 FROM TEMPORAL_ENTITY_ATTRIBUTE
				WHERE ATTRIBUTE_ID = B.ATTRIBUTE_ID
				AND OWNER_ENTITY_ID = A.PSE_ID
				AND BEGIN_DATE <= p_END_DATE AND NVL(END_DATE, p_END_DATE) >= p_BEGIN_DATE)
		ORDER BY 1,2,3;

	ELSIF p_ENTITY_TYPE = 'SC' THEN
		v_ENTITY_DOMAIN_ID := EC.ED_SC;
		v_SC_ID := MM_SEM_UTIL.SEM_SC_ID;

		OPEN p_CURSOR FOR
		SELECT A.SC_NAME "ENTITY_NAME",
			B.ATTRIBUTE_NAME,
			NVL(C.BEGIN_DATE, DATE '2000-01-01') "ATTRIBUTE_BEGIN_DATE",
			C.END_DATE "ATTRIBUTE_END_DATE",
			C.ATTRIBUTE_VAL,
			A.SC_ID "OWNER_ENTITY_ID",
			B.ATTRIBUTE_ID
		FROM SCHEDULE_COORDINATOR A, ENTITY_ATTRIBUTE B, TEMPORAL_ENTITY_ATTRIBUTE C
		WHERE A.SC_ID = v_SC_ID
			AND B.ENTITY_DOMAIN_ID = v_ENTITY_DOMAIN_ID
			AND B.ATTRIBUTE_NAME LIKE 'SEM:Credit:%'
			AND C.OWNER_ENTITY_ID = A.SC_ID
			AND C.ATTRIBUTE_ID = B.ATTRIBUTE_ID
			AND C.BEGIN_DATE <= p_END_DATE
			AND NVL(C.END_DATE, p_END_DATE) >= p_BEGIN_DATE
		UNION ALL
		--Do a cartesian merge to get an attribute for each entity.
		SELECT DISTINCT A.SC_NAME "ENTITY_NAME",
			B.ATTRIBUTE_NAME,
			DATE '2000-01-01' "ATTRIBUTE_BEGIN_DATE",
			NULL "ATTRIBUTE_END_DATE",
			NULL "ATTRIBUTE_VAL",
			A.SC_ID "OWNER_ENTITY_ID",
			B.ATTRIBUTE_ID
		FROM SCHEDULE_COORDINATOR A, ENTITY_ATTRIBUTE B
		WHERE A.SC_ID = v_SC_ID
			AND B.ENTITY_DOMAIN_ID = v_ENTITY_DOMAIN_ID
			AND B.ATTRIBUTE_NAME LIKE 'SEM:Credit:%'
			AND NOT EXISTS
				(SELECT 1 FROM TEMPORAL_ENTITY_ATTRIBUTE
				WHERE ATTRIBUTE_ID = B.ATTRIBUTE_ID
				AND OWNER_ENTITY_ID = A.SC_ID
				AND BEGIN_DATE <= p_END_DATE AND NVL(END_DATE, p_END_DATE) >= p_BEGIN_DATE)
		ORDER BY 1,2,3;
	END IF;

END GET_ATTRIBUTE_INPUTS_RPT;
----------------------------------------------------------------------------------------
PROCEDURE PUT_ATTRIBUTE_INPUTS_RPT
	(
	p_ATTRIBUTE_ID IN NUMBER,
	p_OWNER_ENTITY_ID IN NUMBER,
	p_ATTRIBUTE_VAL IN VARCHAR2,
	p_ATTRIBUTE_BEGIN_DATE IN DATE,
	p_ATTRIBUTE_END_DATE IN DATE,
	p_OLD_ATTRIBUTE_ID IN NUMBER,
	p_OLD_OWNER_ENTITY_ID IN NUMBER,
	p_OLD_ATTRIBUTE_BEGIN_DATE IN DATE
	) AS
BEGIN

	UT.PUT_TEMPORAL_DATA_UI('TEMPORAL_ENTITY_ATTRIBUTE',
		p_ATTRIBUTE_BEGIN_DATE,
		p_ATTRIBUTE_END_DATE,
		p_OLD_ATTRIBUTE_BEGIN_DATE,
		TRUE,
		'OWNER_ENTITY_ID',
		UT.GET_LITERAL_FOR_NUMBER(p_OWNER_ENTITY_ID),
		UT.GET_LITERAL_FOR_NUMBER(p_OLD_OWNER_ENTITY_ID),
		TRUE,
		'ATTRIBUTE_ID',
		UT.GET_LITERAL_FOR_NUMBER(p_ATTRIBUTE_ID),
		UT.GET_LITERAL_FOR_NUMBER(p_OLD_ATTRIBUTE_ID),
		TRUE,
		'ATTRIBUTE_VAL',
		UT.GET_LITERAL_FOR_STRING(p_ATTRIBUTE_VAL)
		);

END PUT_ATTRIBUTE_INPUTS_RPT;
----------------------------------------------------------------------------------------
PROCEDURE DEL_ATTRIBUTE_INPUTS_RPT
	(
	p_ATTRIBUTE_ID IN NUMBER,
	p_OWNER_ENTITY_ID IN NUMBER,
	p_ATTRIBUTE_BEGIN_DATE IN DATE
	) AS
BEGIN
	DELETE TEMPORAL_ENTITY_ATTRIBUTE
	WHERE OWNER_ENTITY_ID = p_OWNER_ENTITY_ID
		AND ATTRIBUTE_ID = p_ATTRIBUTE_ID
		AND BEGIN_DATE = p_ATTRIBUTE_BEGIN_DATE;

END DEL_ATTRIBUTE_INPUTS_RPT;
----------------------------------------------------------------------------------------
PROCEDURE GET_ATTRIBUTE_LIST
	(
	p_ENTITY_TYPE IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS
	v_ENTITY_DOMAIN_ID NUMBER(9);
	-- The p_STATUS parameter appears to be necessary in order for the UI to
	-- send in the proper value for p_ENTITY_TYPE.
BEGIN
	p_STATUS := GA.SUCCESS;

	IF p_ENTITY_TYPE = 'Party' THEN
		v_ENTITY_DOMAIN_ID := EC.ED_ENTITY_GROUP;
	ELSIF p_ENTITY_TYPE = 'Participant' THEN
		v_ENTITY_DOMAIN_ID := EC.ED_PSE;
	ELSIF p_ENTITY_TYPE = 'SC' THEN
		v_ENTITY_DOMAIN_ID := EC.ED_SC;
	END IF;

	OPEN p_CURSOR FOR
		SELECT ATTRIBUTE_NAME, ATTRIBUTE_ID
		FROM ENTITY_ATTRIBUTE A
		WHERE A.ENTITY_DOMAIN_ID = v_ENTITY_DOMAIN_ID
			AND A.ATTRIBUTE_NAME LIKE 'SEM:Credit:%'
		ORDER BY 1;
END GET_ATTRIBUTE_LIST;
----------------------------------------------------------------------------------------
PROCEDURE GET_PARTY_LIST
	(
	p_INCLUDE_ALL IN NUMBER,
	p_STATUS OUT NUMBER, -- THIS IS NECESSARY SO THE SPECIAL COMBOS WILL WORK.
	p_CURSOR IN OUT REF_CURSOR
	) AS
BEGIN
	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT ENTITY_GROUP_NAME, ENTITY_GROUP_ID
		FROM ENTITY_GROUP A
		WHERE A.GROUP_CATEGORY = MM_SEM_CREDIT_SHADOW.c_ENTITY_GROUP_CATEGORY
	UNION ALL
		SELECT g_ALL_STRING, -1
		FROM DUAL
		WHERE p_INCLUDE_ALL = 1
		ORDER BY 1;

END GET_PARTY_LIST;
----------------------------------------------------------------------------------------
PROCEDURE GET_PARTICIPANT_PSE_LIST
	(
	p_INCLUDE_ALL IN NUMBER,
	p_STATUS OUT NUMBER, -- THIS IS NECESSARY SO THE SPECIAL COMBOS WILL WORK.
	p_CURSOR IN OUT REF_CURSOR
	) AS
BEGIN
	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT DISTINCT A.PSE_NAME, A.PSE_ID
		FROM PURCHASING_SELLING_ENTITY A, ENTITY_GROUP B, ENTITY_GROUP_ASSIGNMENT C
		WHERE B.GROUP_CATEGORY = MM_SEM_CREDIT_SHADOW.c_ENTITY_GROUP_CATEGORY
			AND C.ENTITY_GROUP_ID = B.ENTITY_GROUP_ID
			AND A.PSE_ID = C.ENTITY_ID
	UNION ALL
		SELECT '<ALL>', -1
		FROM DUAL
		WHERE p_INCLUDE_ALL = 1
		ORDER BY 1;

END GET_PARTICIPANT_PSE_LIST;
----------------------------------------------------------------------------------------
PROCEDURE GET_CALC_CURRENCY_RPT
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATEMENT_TYPE IN NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS
BEGIN

	OPEN p_CURSOR FOR
	SELECT *
	FROM SEM_CREDIT_CALC_CURRENCY A
	WHERE A.ASSESSMENT_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
		AND A.STATEMENT_TYPE_ID = p_STATEMENT_TYPE
	ORDER BY ASSESSMENT_DATE, CURRENCY;

END GET_CALC_CURRENCY_RPT;
----------------------------------------------------------------------------------------
PROCEDURE GET_CALC_PSE_RPT
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATEMENT_TYPE IN NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS
BEGIN

	--Note: These are always in Euros.  There is a note to that effect on the UI.

	OPEN p_CURSOR FOR
	SELECT ASSESSMENT_DATE,
		B.PSE_NAME,
		CREDIT_MARKET,
		CREDIT_ASSESSMENT_VOLUME,
		CAPACITY_ADJUSTMENT_FACTOR,
		AVERAGE_HIST_SETTLEMENT,
		STD_DEVIATION_HIST_SETTLEMENT,
		DAYS_TO_PAY_INVOICE,
		NOT_PAID_BEGIN_DATE,
		NOT_PAID_END_DATE,
		NOT_INVOICED_BEGIN_DATE,
		NOT_INVOICED_END_DATE,
		HIST_ASSESSMENT_PERIOD,
		HIST_ASSESSMENT_BEGIN_DATE,
		HIST_ASSESSMENT_END_DATE,
		UNDEFINED_PERIOD,
		UNDEFINED_PERIOD_BEGIN_DATE,
		UNDEFINED_PERIOD_END_DATE
	FROM SEM_CREDIT_CALC_PSE A, PURCHASING_SELLING_ENTITY B
	WHERE A.ASSESSMENT_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
		AND A.STATEMENT_TYPE_ID = p_STATEMENT_TYPE
		AND A.PSE_ID = B.PSE_ID
	ORDER BY 1,2,3;

END GET_CALC_PSE_RPT;
----------------------------------------------------------------------------------------
PROCEDURE CREATE_UNIT_FCAST_TXNS
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	) AS

CURSOR c_PARTICIPANTS IS
	SELECT DISTINCT B.ENTITY_ID "PSE_ID", POD_ID, P.PSE_EXTERNAL_IDENTIFIER, SP.SERVICE_POINT_NAME
	FROM ENTITY_GROUP_ASSIGNMENT B, ENTITY_GROUP C, SEM_SERVICE_POINT_PSE D,
		PURCHASING_SELLING_ENTITY P, SERVICE_POINT SP
	WHERE p_BEGIN_DATE <= NVL(B.END_DATE, p_END_DATE)
		AND p_END_DATE >= B.BEGIN_DATE
		AND B.ENTITY_GROUP_ID = C.ENTITY_GROUP_ID
		AND C.GROUP_CATEGORY = MM_SEM_CREDIT_SHADOW.c_ENTITY_GROUP_CATEGORY
		AND D.PSE_ID = B.ENTITY_ID
		AND p_BEGIN_DATE <= NVL(D.END_DATE, p_END_DATE)
		AND p_END_DATE >= D.BEGIN_DATE
		AND P.PSE_ID = D.PSE_ID
		AND SP.SERVICE_POINT_ID = D.POD_ID
	--Add in the MOYLE interconnector if we have a nomination there.
	UNION ALL
	SELECT DISTINCT B.ENTITY_ID "PSE_ID", IT.POD_ID, P.PSE_EXTERNAL_IDENTIFIER, SP.SERVICE_POINT_NAME
	FROM ENTITY_GROUP_ASSIGNMENT B, ENTITY_GROUP C, SEM_SETTLEMENT_ENTITY SSE, PURCHASING_SELLING_ENTITY P,
		INTERCHANGE_TRANSACTION IT, INTERCHANGE_CONTRACT IC, SERVICE_POINT SP
	WHERE p_BEGIN_DATE <= NVL(B.END_DATE, p_END_DATE)
		AND p_END_DATE >= B.BEGIN_DATE
		AND B.ENTITY_GROUP_ID = C.ENTITY_GROUP_ID
		AND C.GROUP_CATEGORY = MM_SEM_CREDIT_SHADOW.c_ENTITY_GROUP_CATEGORY
		AND P.PSE_ID = B.ENTITY_ID
		AND SSE.PARTICIPANT_PSE_ID = B.ENTITY_ID
		AND IC.BILLING_ENTITY_ID = SSE.SETTLEMENT_PSE_ID
		AND IT.CONTRACT_ID = IC.CONTRACT_ID
		AND IT.TRANSACTION_TYPE = 'Nomination'
		AND SP.SERVICE_POINT_ID = IT.POD_ID
	;

v_TXN INTERCHANGE_TRANSACTION%ROWTYPE;
v_TXN_ID NUMBER(9);
BEGIN

	v_TXN.TRANSACTION_DESC := 'Forecast Demand/Forecast Output Transaction created for Credit Cover Shadow calculations.';
	v_TXN.TRANSACTION_TYPE := 'Unit Forecast';
	v_TXN.TRANSACTION_INTERVAL := '30 Minute';
	v_TXN.BEGIN_DATE := DATE '2000-01-01';
	v_TXN.END_DATE := DATE '2020-12-31';
	v_TXN.TRANSACTION_ID := 0;

	FOR v_PART IN c_PARTICIPANTS LOOP
		v_TXN.TRANSACTION_NAME := 'SEM:Credit:' || v_PART.PSE_EXTERNAL_IDENTIFIER || ':' || v_PART.SERVICE_POINT_NAME || ':Unit Forecast';
		v_TXN.TRANSACTION_IDENTIFIER := v_TXN.TRANSACTION_NAME;
		v_TXN.PSE_ID := v_PART.PSE_ID;
		v_TXN.PURCHASER_ID := v_TXN.PSE_ID;
		v_TXN.SELLER_ID := v_TXN.PSE_ID;
		v_TXN.POD_ID := v_PART.POD_ID;

		MM_UTIL.PUT_TRANSACTION(v_TXN_ID, v_TXN, GA.INTERNAL_STATE, 'Active');
	END LOOP;

END CREATE_UNIT_FCAST_TXNS;
----------------------------------------------------------------------------------------
PROCEDURE GET_UNIT_FORECAST_RPT
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATEMENT_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_CURSOR IN OUT REF_CURSOR
	) AS
	v_MIN_INTERVAL_NUM NUMBER := GET_INTERVAL_NUMBER('30 Minute');
	v_BEGIN_DATE DATE;
	v_END_DATE DATE;
BEGIN

	--Use the Statement Type passed in so we can have different scenarios.
	UT.CUT_DATE_RANGE(1, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	OPEN p_CURSOR FOR
		SELECT TRANSACTION_NAME,
			X.TRANSACTION_ID,
			SCHEDULE_DATE_STR,
			AMOUNT,
			CUT_DATE_SCHEDULING
		FROM
			(SELECT TRANSACTION_ID, TRANSACTION_NAME, CUT_DATE_SCHEDULING, SDT.NO_ROLLUP_YYYY_MM_DD "SCHEDULE_DATE_STR"
			FROM INTERCHANGE_TRANSACTION A, SYSTEM_DATE_TIME SDT
			WHERE A.TRANSACTION_TYPE = 'Unit Forecast'
				AND p_BEGIN_DATE <= A.END_DATE
				AND p_END_DATE >= A.BEGIN_DATE
				AND SDT.TIME_ZONE = p_TIME_ZONE
				AND SDT.DATA_INTERVAL_TYPE = 1
				AND SDT.DAY_TYPE = '1'
				AND SDT.CUT_DATE_SCHEDULING BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND SDT.MINIMUM_INTERVAL_NUMBER >= v_MIN_INTERVAL_NUM
			)X, IT_SCHEDULE B
		WHERE B.TRANSACTION_ID(+) = X.TRANSACTION_ID
			AND B.SCHEDULE_TYPE(+) = p_STATEMENT_TYPE
			AND B.SCHEDULE_STATE(+) = GA.INTERNAL_STATE
			AND B.SCHEDULE_DATE(+) = X.CUT_DATE_SCHEDULING
			AND B.AS_OF_DATE(+) = c_LOW_DATE
		ORDER BY 1,2;

END GET_UNIT_FORECAST_RPT;
----------------------------------------------------------------------------------------
PROCEDURE PUT_UNIT_FORECAST_RPT
	(
	p_TRANSACTION_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_CUT_DATE_SCHEDULING IN DATE,
	p_AMOUNT IN NUMBER,
	p_STATUS OUT NUMBER
	) AS
BEGIN
	--Use the Statement Type passed in so we can have different scenarios.
	ITJ.PUT_IT_SCHEDULE(p_TRANSACTION_ID, p_STATEMENT_TYPE, p_CUT_DATE_SCHEDULING, c_LOW_DATE, p_AMOUNT, NULL, p_STATUS);
END PUT_UNIT_FORECAST_RPT;
----------------------------------------------------------------------------------------
PROCEDURE GET_POSTED_CREDIT_COVER_RPT
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_CURSOR IN OUT REF_CURSOR
	) AS
BEGIN

	--Posted Credit Cover is entered in its party's native currency.
	OPEN p_CURSOR FOR
		SELECT ENTITY_GROUP_NAME,
			X.CUT_DATE "ASSESSMENT_DAY",
			POSTED_CREDIT_COVER,
			X.ENTITY_GROUP_ID,
			MM_SEM_CREDIT_SHADOW.GET_PARTY_CURRENCY(X.ENTITY_GROUP_ID, X.CUT_DATE) "CURRENCY"
		FROM
			(SELECT ENTITY_GROUP_NAME, ENTITY_GROUP_ID, SDT.CUT_DATE
			FROM ENTITY_GROUP EG, SYSTEM_DATE_TIME SDT
			WHERE EG.GROUP_CATEGORY = MM_SEM_CREDIT_SHADOW.c_ENTITY_GROUP_CATEGORY
				AND SDT.TIME_ZONE = p_TIME_ZONE
				AND SDT.DATA_INTERVAL_TYPE = 2
				AND SDT.DAY_TYPE = '1'
				AND SDT.CUT_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
			) X, SEM_CREDIT_INPUT_ENTITY_GROUP A
		WHERE A.ASSESSMENT_DAY(+) = X.CUT_DATE
			AND A.ENTITY_GROUP_ID(+) = X.ENTITY_GROUP_ID
		ORDER BY 1,2;

END GET_POSTED_CREDIT_COVER_RPT;
----------------------------------------------------------------------------------------
PROCEDURE PUT_POSTED_CREDIT_COVER_RPT
	(
	p_ENTITY_GROUP_ID IN NUMBER,
	p_ASSESSMENT_DAY IN DATE,
	p_POSTED_CREDIT_COVER IN NUMBER
	) AS
BEGIN
	UPDATE SEM_CREDIT_INPUT_ENTITY_GROUP
	SET POSTED_CREDIT_COVER = p_POSTED_CREDIT_COVER
	WHERE ASSESSMENT_DAY = p_ASSESSMENT_DAY
		AND ENTITY_GROUP_ID = p_ENTITY_GROUP_ID;

	IF SQL%NOTFOUND THEN
		INSERT INTO SEM_CREDIT_INPUT_ENTITY_GROUP (
			ASSESSMENT_DAY,
			ENTITY_GROUP_ID,
			POSTED_CREDIT_COVER)
		VALUES (
			p_ASSESSMENT_DAY,
			p_ENTITY_GROUP_ID,
			p_POSTED_CREDIT_COVER);
	END IF;

END PUT_POSTED_CREDIT_COVER_RPT;
----------------------------------------------------------------------------------------
PROCEDURE GET_TEST_ONLY_BILL_DATA_RPT
	(
	p_ENTITY_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_CURSOR IN OUT REF_CURSOR
	) AS
BEGIN

OPEN p_CURSOR FOR
	SELECT SDT.CUT_DATE, BS.BILL_AMOUNT, BS.CHARGE_ID
	FROM BILLING_STATEMENT BS, SYSTEM_DATE_TIME SDT
	WHERE SDT.TIME_ZONE = p_TIME_ZONE
		AND SDT.DATA_INTERVAL_TYPE = 2
		AND SDT.DAY_TYPE = '1'
		AND SDT.CUT_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
		AND BS.ENTITY_ID(+) = p_ENTITY_ID
		AND BS.PRODUCT_ID(+) = p_PRODUCT_ID
		AND BS.COMPONENT_ID(+) = p_COMPONENT_ID
		AND BS.STATEMENT_TYPE(+) = p_STATEMENT_TYPE
		AND BS.STATEMENT_STATE(+) = p_STATEMENT_STATE
		AND BS.STATEMENT_DATE(+) = SDT.CUT_DATE
	ORDER BY 1;

END GET_TEST_ONLY_BILL_DATA_RPT;
----------------------------------------------------------------------------------------
PROCEDURE PUT_TEST_ONLY_BILL_DATA_RPT
	(
	p_ENTITY_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_STATEMENT_STATE IN NUMBER,
	p_CUT_DATE IN DATE,
	p_BILL_AMOUNT IN NUMBER
	) AS
	v_BS BILLING_STATEMENT%ROWTYPE;
BEGIN
	v_BS.ENTITY_ID := p_ENTITY_ID;
	v_BS.PRODUCT_ID := p_PRODUCT_ID;
	v_BS.COMPONENT_ID := p_COMPONENT_ID;
	v_BS.STATEMENT_TYPE := p_STATEMENT_TYPE;
	v_BS.STATEMENT_STATE := p_STATEMENT_STATE;
	v_BS.STATEMENT_DATE := p_CUT_DATE;
	v_BS.AS_OF_DATE := c_LOW_DATE;
	v_BS.STATEMENT_END_DATE := p_CUT_DATE;
	v_BS.CHARGE_AMOUNT := p_BILL_AMOUNT;
	v_BS.BILL_AMOUNT := p_BILL_AMOUNT;

	PC.GET_CHARGE_ID(v_BS);
	PC.PUT_BILLING_STATEMENT(v_BS);

END PUT_TEST_ONLY_BILL_DATA_RPT;
----------------------------------------------------------------------------------------
PROCEDURE GET_SEM_EXPOSURE_PERIOD_RPT
	(
	p_STATEMENT_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CURSOR IN OUT REF_CURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
	SELECT ASSESSMENT_DATE,
		PSE_NAME,
		CREDIT_MARKET,
		NVL(NOT_INVOICED_END_DATE - COALESCE(NOT_PAID_BEGIN_DATE, NOT_INVOICED_BEGIN_DATE) + 1,0) "ACTUAL_PERIOD",
		NVL(UNDEFINED_PERIOD_END_DATE - UNDEFINED_PERIOD_BEGIN_DATE + 1,0) "UNDEF_PERIOD"
	FROM SEM_CREDIT_CALC_PSE A, PURCHASING_SELLING_ENTITY P
	WHERE ASSESSMENT_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
		AND STATEMENT_TYPE_ID = p_STATEMENT_TYPE
		AND P.PSE_ID = A.PSE_ID
	ORDER BY 1,2,3 DESC;

END GET_SEM_EXPOSURE_PERIOD_RPT;
----------------------------------------------------------------------------------------
PROCEDURE GET_DAILY_BILLING_DATA_RPT
	(
	p_ASSESSMENT_DATE IN DATE,
	p_STATEMENT_TYPE IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_CREDIT_MARKET IN VARCHAR2,
	p_CREDIT_CATEGORY IN VARCHAR2,
	p_RANGE_BEGIN_DATE OUT VARCHAR2,
	p_RANGE_END_DATE OUT VARCHAR2,
	p_ASSESSMENT_DATE_LBL OUT VARCHAR2,
	p_CURSOR OUT SYS_REFCURSOR
	) AS
BEGIN
	p_ASSESSMENT_DATE_LBL := TO_CHAR(p_ASSESSMENT_DATE, c_LABEL_DATE_FORMAT);

	SELECT TO_CHAR(
		CASE p_CREDIT_CATEGORY
			WHEN MM_SEM_CREDIT_SHADOW.c_CATEGORY_INV_NOT_PAID THEN NOT_PAID_BEGIN_DATE
			WHEN MM_SEM_CREDIT_SHADOW.c_CATEGORY_STMT_NOT_INV THEN NOT_INVOICED_BEGIN_DATE
			WHEN MM_SEM_CREDIT_SHADOW.c_CATEGORY_UNDEF THEN HIST_ASSESSMENT_BEGIN_DATE
		END
		,c_LABEL_DATE_FORMAT),
		TO_CHAR(
		CASE p_CREDIT_CATEGORY
			WHEN MM_SEM_CREDIT_SHADOW.c_CATEGORY_INV_NOT_PAID THEN NOT_PAID_END_DATE
			WHEN MM_SEM_CREDIT_SHADOW.c_CATEGORY_STMT_NOT_INV THEN NOT_INVOICED_END_DATE
			WHEN MM_SEM_CREDIT_SHADOW.c_CATEGORY_UNDEF THEN HIST_ASSESSMENT_END_DATE
		END
		,c_LABEL_DATE_FORMAT)
	INTO p_RANGE_BEGIN_DATE, p_RANGE_END_DATE
	FROM SEM_CREDIT_CALC_PSE
	WHERE ASSESSMENT_DATE = p_ASSESSMENT_DATE
		AND STATEMENT_TYPE_ID = p_STATEMENT_TYPE
		AND PSE_ID = p_PSE_ID
		AND CREDIT_MARKET = p_CREDIT_MARKET;

	-- Get the best available billing data for each day of the range.
	OPEN p_CURSOR FOR
		SELECT DLY.STATEMENT_DATE,
			DLY.BEST_STATEMENT_TYPE,
			ST.STATEMENT_TYPE_NAME,
			DLY.BEST_STATEMENT_STATE,
			CASE DLY.BEST_STATEMENT_STATE WHEN 1 THEN 'Internal' ELSE 'External' END "STATEMENT_STATE_NAME",
			DLY.ENTITY_ID "PSE_ID",
			P.PSE_NAME,
			DLY.BILL_AMOUNT,
			DLY.NATIVE_CURRENCY,
			DLY.EXCHANGE_RATE_POUND_TO_EURO,
			DLY.EURO_BILL_AMOUNT,
			DLY.VMOP,
			DLY.NDLF,
			CASE WHEN p_CREDIT_CATEGORY = MM_SEM_CREDIT_SHADOW.c_CATEGORY_UNDEF THEN DLY.EURO_BILL_AMOUNT
			     ELSE DLY.BILL_AMOUNT END  +
    				(SELECT NVL(SUM(SRA.IS_ACCEPTED * SRA.SRA_AMOUNT),0)
				FROM SEM_CREDIT_DAILY_SRA SRA
				WHERE SRA.ASSESSMENT_DATE = p_ASSESSMENT_DATE
					AND SRA.STATEMENT_TYPE_ID = p_STATEMENT_TYPE
					AND SRA.PSE_ID = p_PSE_ID
					AND SRA.CREDIT_MARKET = p_CREDIT_MARKET
					AND SRA.CREDIT_CATEGORY = p_CREDIT_CATEGORY
					AND SRA.STATEMENT_DATE = DLY.STATEMENT_DATE
					AND SSE.MARKET_NAME IN ('EN', 'CA')
    				) "BILL_AMOUNT_INCLUDING_SRA"
		FROM SEM_CREDIT_DAILY_STMT DLY, STATEMENT_TYPE ST, PURCHASING_SELLING_ENTITY P,
			SEM_SETTLEMENT_ENTITY SSE
		WHERE DLY.ASSESSMENT_DATE = p_ASSESSMENT_DATE
			AND DLY.STATEMENT_TYPE_ID = p_STATEMENT_TYPE
			AND DLY.PSE_ID = p_PSE_ID
			AND DLY.CREDIT_MARKET = p_CREDIT_MARKET
			AND DLY.CREDIT_CATEGORY = p_CREDIT_CATEGORY
			AND ST.STATEMENT_TYPE_ID = DLY.BEST_STATEMENT_TYPE
			AND P.PSE_ID = DLY.ENTITY_ID
			AND SSE.SETTLEMENT_PSE_ID = DLY.ENTITY_ID
		ORDER BY DLY.STATEMENT_DATE, P.PSE_NAME;

END GET_DAILY_BILLING_DATA_RPT;
----------------------------------------------------------------------------------------
PROCEDURE GET_DAILY_SRA_DATA_RPT
	(
	p_ASSESSMENT_DATE IN DATE,
	p_STATEMENT_TYPE IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_CREDIT_MARKET IN VARCHAR2,
	p_CREDIT_CATEGORY IN VARCHAR2,
	p_RANGE_BEGIN_DATE OUT VARCHAR2,
	p_RANGE_END_DATE OUT VARCHAR2,
	p_ASSESSMENT_DATE_LBL OUT VARCHAR2,
	p_CURSOR OUT SYS_REFCURSOR
	) AS
BEGIN
	p_ASSESSMENT_DATE_LBL := TO_CHAR(p_ASSESSMENT_DATE, c_LABEL_DATE_FORMAT);

	SELECT TO_CHAR(
		CASE p_CREDIT_CATEGORY
			WHEN MM_SEM_CREDIT_SHADOW.c_CATEGORY_INV_NOT_PAID THEN NOT_PAID_BEGIN_DATE
			ELSE NVL(NOT_INVOICED_BEGIN_DATE, UNDEFINED_PERIOD_BEGIN_DATE)
		END
		,c_LABEL_DATE_FORMAT),
		TO_CHAR(
		CASE p_CREDIT_CATEGORY
			WHEN MM_SEM_CREDIT_SHADOW.c_CATEGORY_INV_NOT_PAID THEN NOT_PAID_END_DATE
			ELSE UNDEFINED_PERIOD_END_DATE
		END
		,c_LABEL_DATE_FORMAT)
	INTO p_RANGE_BEGIN_DATE, p_RANGE_END_DATE
	FROM SEM_CREDIT_CALC_PSE
	WHERE ASSESSMENT_DATE = p_ASSESSMENT_DATE
		AND STATEMENT_TYPE_ID = p_STATEMENT_TYPE
		AND PSE_ID = p_PSE_ID
		AND CREDIT_MARKET = p_CREDIT_MARKET;

	-- Get the SRA data for the range.
	OPEN p_CURSOR FOR
		SELECT DLY.STATEMENT_DATE,
			DLY.TRANSACTION_ID,
			T.TRANSACTION_NAME,
			DLY.IS_ACCEPTED,
			DLY.RAW_SRA_AMOUNT,
			DLY.NATIVE_CURRENCY,
			DLY.EXCHANGE_RATE,
			DLY.IS_ACCEPTED * DLY.SRA_AMOUNT "ACCEPTED_SRAS",
			CASE DLY.IS_ACCEPTED WHEN 1 THEN 0 ELSE 1 END * DLY.SRA_AMOUNT "PENDING_SRAS"
		FROM SEM_CREDIT_DAILY_SRA DLY, INTERCHANGE_TRANSACTION T
		WHERE DLY.ASSESSMENT_DATE = p_ASSESSMENT_DATE
			AND DLY.STATEMENT_TYPE_ID = p_STATEMENT_TYPE
			AND DLY.PSE_ID = p_PSE_ID
			AND DLY.CREDIT_MARKET = p_CREDIT_MARKET
			AND DLY.CREDIT_CATEGORY = p_CREDIT_CATEGORY
			AND T.TRANSACTION_ID = DLY.TRANSACTION_ID
		ORDER BY DLY.STATEMENT_DATE, T.TRANSACTION_NAME;

END GET_DAILY_SRA_DATA_RPT;
----------------------------------------------------------------------------------------
PROCEDURE GET_DAILY_UNDEF_ADJ_RPT
	(
	p_ASSESSMENT_DATE IN DATE,
	p_STATEMENT_TYPE IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_CREDIT_MARKET IN VARCHAR2,
	p_RANGE_BEGIN_DATE OUT VARCHAR2,
	p_RANGE_END_DATE OUT VARCHAR2,
	p_ASSESSMENT_DATE_LBL OUT VARCHAR2,
	p_EXPOSURE_PERIOD OUT NUMBER,
	p_CURSOR OUT SYS_REFCURSOR
	) AS
BEGIN
	p_ASSESSMENT_DATE_LBL := TO_CHAR(p_ASSESSMENT_DATE, c_LABEL_DATE_FORMAT);

	SELECT TO_CHAR(UNDEFINED_PERIOD_BEGIN_DATE
		,c_LABEL_DATE_FORMAT),
		TO_CHAR(UNDEFINED_PERIOD_END_DATE
		,c_LABEL_DATE_FORMAT),
		UNDEFINED_PERIOD_END_DATE - UNDEFINED_PERIOD_BEGIN_DATE + 1
	INTO p_RANGE_BEGIN_DATE, p_RANGE_END_DATE, p_EXPOSURE_PERIOD
	FROM SEM_CREDIT_CALC_PSE
	WHERE ASSESSMENT_DATE = p_ASSESSMENT_DATE
		AND STATEMENT_TYPE_ID = p_STATEMENT_TYPE
		AND PSE_ID = p_PSE_ID
		AND CREDIT_MARKET = p_CREDIT_MARKET;

	-- Get the Undefined Period data for the range.
	OPEN p_CURSOR FOR
		SELECT DLY.STATEMENT_DATE,
			DLY.FORECAST_VOLUME,
			DLY.CAPACITY_ADJ_FACTOR,
			DLY.ASSESSMENT_PRICE,
			DLY.VAT_RATE,
			DLY.FORECAST_VOLUME * NVL(DLY.CAPACITY_ADJ_FACTOR, 1) * DLY.ASSESSMENT_PRICE * (1+DLY.VAT_RATE) "DAILY_UNDEFINED_TOTAL"
		FROM SEM_CREDIT_DAILY_UNDEF_ADJ DLY
		WHERE DLY.ASSESSMENT_DATE = p_ASSESSMENT_DATE
			AND DLY.STATEMENT_TYPE_ID = p_STATEMENT_TYPE
			AND DLY.PSE_ID = p_PSE_ID
			AND DLY.CREDIT_MARKET = p_CREDIT_MARKET
		ORDER BY DLY.STATEMENT_DATE;

END GET_DAILY_UNDEF_ADJ_RPT;
----------------------------------------------------------------------------------------
PROCEDURE GET_DAILY_UNDEF_STD_RPT
	(
	p_ASSESSMENT_DATE IN DATE,
	p_STATEMENT_TYPE IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_CREDIT_MARKET IN VARCHAR2,
	p_AVG_SAMPLE OUT NUMBER,
	p_STDDEV_SAMPLE OUT NUMBER,
	p_ANPP OUT NUMBER,
	p_TOTAL_UNDEFINED OUT NUMBER,
	p_EXPOSURE_PERIOD OUT NUMBER,
	p_CURSOR OUT SYS_REFCURSOR
	) AS
BEGIN

	SELECT UNDEFINED_PERIOD_END_DATE - UNDEFINED_PERIOD_BEGIN_DATE + 1
	INTO p_EXPOSURE_PERIOD
	FROM SEM_CREDIT_CALC_PSE
	WHERE ASSESSMENT_DATE = p_ASSESSMENT_DATE
		AND STATEMENT_TYPE_ID = p_STATEMENT_TYPE
		AND PSE_ID = p_PSE_ID
		AND CREDIT_MARKET = p_CREDIT_MARKET;

	SELECT ROUND(AVG(SAMPLE_AMOUNT),4), ROUND(STDDEV(SAMPLE_AMOUNT),4)
	INTO p_AVG_SAMPLE, p_STDDEV_SAMPLE
	FROM SEM_CREDIT_DAILY_UNDEF_STD DLY
	WHERE DLY.ASSESSMENT_DATE = p_ASSESSMENT_DATE
		AND DLY.STATEMENT_TYPE_ID = p_STATEMENT_TYPE
		AND DLY.PSE_ID = p_PSE_ID
		AND DLY.CREDIT_MARKET = p_CREDIT_MARKET;

	SELECT ANALYSIS_PERCENTILE_PARAM
	INTO p_ANPP
	FROM SEM_CREDIT_CALC_CURRENCY
	WHERE ASSESSMENT_DATE = p_ASSESSMENT_DATE
		AND STATEMENT_TYPE_ID = p_STATEMENT_TYPE
		AND CURRENCY = MM_SEM_CREDIT_SHADOW.c_CURRENCY_EURO;

	p_TOTAL_UNDEFINED := p_AVG_SAMPLE + p_ANPP * p_STDDEV_SAMPLE;

	-- Get the Undefined Period sample data for the range.
	OPEN p_CURSOR FOR
		SELECT DLY.SAMPLE_BEGIN_DATE,
			DLY.SAMPLE_END_DATE,
			DLY.SAMPLE_AMOUNT
		FROM SEM_CREDIT_DAILY_UNDEF_STD DLY
		WHERE DLY.ASSESSMENT_DATE = p_ASSESSMENT_DATE
			AND DLY.STATEMENT_TYPE_ID = p_STATEMENT_TYPE
			AND DLY.PSE_ID = p_PSE_ID
			AND DLY.CREDIT_MARKET = p_CREDIT_MARKET
		ORDER BY DLY.SAMPLE_BEGIN_DATE;

END GET_DAILY_UNDEF_STD_RPT;
----------------------------------------------------------------------------------------
FUNCTION GET_EXCHANGE_MARKET_PRICE_ID
	(
	p_FROM_CURRENCY IN VARCHAR2,
	p_TO_CURRENCY IN VARCHAR2
	) RETURN NUMBER IS
BEGIN
	IF p_FROM_CURRENCY = p_TO_CURRENCY THEN
		RETURN -1;
	ELSIF p_FROM_CURRENCY = MM_SEM_CREDIT_SHADOW.c_CURRENCY_EURO THEN
		RETURN MM_SEM_UTIL.GET_MARKET_PRICE_ID('Trading Day Exchange Rate: Euro to Pound', 'Commodity Price', 'Day', FALSE);
	ELSE
		RETURN MM_SEM_UTIL.GET_MARKET_PRICE_ID('Trading Day Exchange Rate: Pound to Euro', 'Commodity Price', 'Day', FALSE);
	END IF;
END GET_EXCHANGE_MARKET_PRICE_ID;
----------------------------------------------------------------------------------------
PROCEDURE GET_SRA_FORECAST_RPT
	(
	p_PSE_ID IN NUMBER,
	p_CREDIT_MARKET IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATEMENT_TYPE IN NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

	g_STMT_INITIAL NUMBER := EI.GET_ID_FROM_IDENTIFIER_EXTSYS(MM_SEM_UTIL.g_EXTID_SETTLEMENT_F, EC.ED_STATEMENT_TYPE, EC.ES_SEM, MM_SEM_UTIL.g_STATEMENT_TYPE_SETTLEMENT);
	g_STMT_INDIC NUMBER := EI.GET_ID_FROM_IDENTIFIER_EXTSYS(MM_SEM_UTIL.g_EXTID_SETTLEMENT_P, EC.ED_STATEMENT_TYPE, EC.ES_SEM, MM_SEM_UTIL.g_STATEMENT_TYPE_SETTLEMENT);
	v_ENTITY_ID_1 NUMBER;
	v_ENTITY_ID_2 NUMBER;
	v_MIN_INTERVAL_NUMBER NUMBER(3);
	v_BEGIN_DATE DATE;
	v_END_DATE DATE;
	v_TO_CURRENCY VARCHAR2(3) := MM_SEM_CREDIT_SHADOW.GET_PSE_CURRENCY(p_PSE_ID, p_BEGIN_DATE);
	v_COMMODITY_ID NUMBER(9);
BEGIN
	MM_SEM_CREDIT_SHADOW.GET_BILLING_STMT_ENTITIES(p_PSE_ID, p_CREDIT_MARKET, v_ENTITY_ID_1, v_ENTITY_ID_2);
	v_MIN_INTERVAL_NUMBER := GET_INTERVAL_NUMBER('DD');

	--SRAs are stored by Commodity, for Energy or Capacity.
	v_COMMODITY_ID := EI.GET_ID_FROM_ALIAS(CASE p_CREDIT_MARKET WHEN MM_SEM_CREDIT_SHADOW.c_MARKET_EN THEN MM_SEM_CREDIT_SHADOW.c_COMMODITY_ALIAS_ENERGY ELSE MM_SEM_CREDIT_SHADOW.c_COMMODITY_ALIAS_CAPACITY END, EC.ED_IT_COMMODITY);

    -- BZ 30498, jbc: don't use SYSTEM_DATE_TIME to determine week start, since it depends on database INTL8N setttings
	v_BEGIN_DATE := DATE_UTIL.BEGIN_DATE_FOR_INTERVAL(p_BEGIN_DATE,
													  CASE WHEN p_CREDIT_MARKET='EN' THEN DATE_UTIL.c_ABBR_WEEK ELSE DATE_UTIL.c_ABBR_MONTH END,
													  DATE_UTIL.c_WEEK_BEGIN_SUNDAY);
	v_END_DATE := DATE_UTIL.END_DATE_FOR_INTERVAL(DATE_UTIL.BEGIN_DATE_FOR_INTERVAL(p_END_DATE,
													  	CASE WHEN p_CREDIT_MARKET='EN' THEN DATE_UTIL.c_ABBR_WEEK ELSE DATE_UTIL.c_ABBR_MONTH END,
													  	DATE_UTIL.c_WEEK_BEGIN_SUNDAY),
													  CASE WHEN p_CREDIT_MARKET='EN' THEN DATE_UTIL.c_ABBR_WEEK ELSE DATE_UTIL.c_ABBR_MONTH END,
													  DATE_UTIL.c_WEEK_BEGIN_SUNDAY);

	--Get the main report cursor.  Note that several fields shown on the report are formula columns based on these values.
	OPEN p_CURSOR FOR
	SELECT CFG.PERIOD_NAME,
		CFG.SORT_ORDER,
		MIN_STATEMENT_DATE "BILLING_PERIOD_BEGIN",
		MAX_STATEMENT_DATE "BILLING_PERIOD_END",
		MM_SEM_CREDIT_SHADOW.ADD_DAYS(
			CASE CFG.IS_RELATIVE_TO_PERIOD_BEGIN WHEN 1 THEN MIN_STATEMENT_DATE ELSE MAX_STATEMENT_DATE END,
			CFG.DAYS_UNTIL_POSTED,
			CFG.DAY_TYPE) "POST_ON_DATE",
		GROSS_BILL,
		CFG.MULTIPLIER,
		v_TO_CURRENCY "UNIT",
		--Get the Submitted SRAs for the billing period converted to the PSE's native currency.
		(SELECT SUM(CASE WHEN p_PSE_ID = PURCHASER_ID THEN -1 ELSE 1 END
					* TO_NUMBER(SRA.TRAIT_VAL)
					* NVL((SELECT EXCH.PRICE
						FROM MARKET_PRICE_VALUE EXCH
						WHERE EXCH.MARKET_PRICE_ID(+) = Z.EXCH_MARKET_PRICE_ID
							AND EXCH.PRICE_CODE(+) = 'A'
							AND EXCH.PRICE_DATE(+) = SRA.SCHEDULE_DATE - 1/86400
							AND EXCH.AS_OF_DATE(+) = c_LOW_DATE), 1)
					* CASE WHEN GREATEST(NVL(REJ.TRAIT_VAL, 0), NVL(CAN.TRAIT_VAL,0)) = 1 THEN 0 ELSE 1 END
					)
		FROM
			(SELECT DISTINCT T.TRANSACTION_ID,
				T.PURCHASER_ID,
				GET_EXCHANGE_MARKET_PRICE_ID(MM_SEM_CREDIT_SHADOW.GET_PSE_CURRENCY(T.PURCHASER_ID, p_BEGIN_DATE), v_TO_CURRENCY) "EXCH_MARKET_PRICE_ID"
			FROM INTERCHANGE_TRANSACTION T
			WHERE T.TRANSACTION_TYPE = 'SRA'
				AND T.COMMODITY_ID = v_COMMODITY_ID
				AND p_PSE_ID IN (T.PURCHASER_ID, T.SELLER_ID)
				AND v_BEGIN_DATE <= T.END_DATE
				AND v_END_DATE >= T.BEGIN_DATE
			) Z, IT_TRAIT_SCHEDULE SRA, IT_TRAIT_SCHEDULE_STATUS ITSS, IT_TRAIT_SCHEDULE REJ, IT_TRAIT_SCHEDULE CAN
		WHERE SRA.TRANSACTION_ID = Z.TRANSACTION_ID
			AND SRA.SCHEDULE_STATE = GA.INTERNAL_STATE
			AND SRA.SCHEDULE_DATE BETWEEN Y.MIN_STATEMENT_DATE + 1/86400 AND Y.MAX_STATEMENT_DATE + 1/86400
			AND SRA.TRAIT_GROUP_ID = MM_SEM_UTIL.g_TG_SRA_VALUE
			AND SRA.TRAIT_INDEX = 1
			AND SRA.SET_NUMBER = 1
			AND ITSS.TRANSACTION_ID = SRA.TRANSACTION_ID
			AND ITSS.SCHEDULE_DATE = SRA.SCHEDULE_DATE
			AND ITSS.SUBMIT_STATUS = 'Submitted'
			AND ITSS.MARKET_STATUS = 'Accepted'
			AND REJ.TRANSACTION_ID(+) = SRA.TRANSACTION_ID
			AND REJ.SCHEDULE_STATE(+) = GA.INTERNAL_STATE
			AND REJ.SCHEDULE_DATE(+) = SRA.SCHEDULE_DATE
			AND REJ.TRAIT_GROUP_ID(+) = MM_SEM_UTIL.g_TG_SRA_VALIDITY_STATUS
			AND REJ.TRAIT_INDEX(+) = MM_SEM_UTIL.g_TI_SRA_VAL_STAT_REJECTED
			AND REJ.SET_NUMBER(+) = 1
			AND REJ.STATEMENT_TYPE_ID(+) = 0
			AND CAN.TRANSACTION_ID(+) = SRA.TRANSACTION_ID
			AND CAN.SCHEDULE_STATE(+) = GA.INTERNAL_STATE
			AND CAN.SCHEDULE_DATE(+) = SRA.SCHEDULE_DATE
			AND CAN.TRAIT_GROUP_ID(+) = MM_SEM_UTIL.g_TG_SRA_VALIDITY_STATUS
			AND CAN.TRAIT_INDEX(+) = MM_SEM_UTIL.g_TI_SRA_VAL_STAT_CANCELLED
			AND CAN.SET_NUMBER(+) = 1
			AND CAN.STATEMENT_TYPE_ID(+) = 0) "SUBMITTED_SRAS"
	FROM
		--Get the "Best Available" Billing Statement data, not including SRAs.
		--(SELECT CASE p_CREDIT_MARKET WHEN 'EN' THEN SDT.LOCAL_WEEK_TRUNC_DATE ELSE SDT.LOCAL_MONTH_TRUNC_DATE END "BILLING_PERIOD_DATE",
		(SELECT CASE p_CREDIT_MARKET WHEN 'EN' THEN DATE_UTIL.BEGIN_DATE_FOR_INTERVAL(STATEMENT_DATE, DATE_UTIL.c_ABBR_WEEK, DATE_UTIL.c_WEEK_BEGIN_SUNDAY) ELSE SDT.LOCAL_MONTH_TRUNC_DATE END "BILLING_PERIOD_DATE",
			MIN(CUT_DATE) "MIN_STATEMENT_DATE",
			MAX(CUT_DATE) "MAX_STATEMENT_DATE",
			SUM(GROSS_DAILY_CHARGE) "GROSS_BILL"
			FROM
			(SELECT X.STATEMENT_DATE,
					X.ENTITY_ID,
					X.STATEMENT_TYPE,
					X.STATEMENT_STATE,
					SUM(X.BILL_AMOUNT) GROSS_DAILY_CHARGE
				FROM
					(SELECT BILL_AMOUNT,
						C.COMPONENT_ID,
						STATEMENT_DATE,
						STATEMENT_STATE,
						STATEMENT_TYPE,
						ENTITY_ID,
						CASE WHEN STATEMENT_STATE = 2 AND STATEMENT_TYPE = g_STMT_INITIAL THEN 1
							WHEN STATEMENT_STATE = 2 AND STATEMENT_TYPE = g_STMT_INDIC THEN 2
							WHEN STATEMENT_STATE = 1 AND STATEMENT_TYPE = p_STATEMENT_TYPE THEN 5
							ELSE 9 END "PRIORITY",
						MIN(CASE WHEN STATEMENT_STATE = 2 AND STATEMENT_TYPE = g_STMT_INITIAL THEN 1
							WHEN STATEMENT_STATE = 2 AND STATEMENT_TYPE = g_STMT_INDIC THEN 2
							WHEN STATEMENT_STATE = 1 AND STATEMENT_TYPE = p_STATEMENT_TYPE THEN 5
							ELSE 9 END) OVER (PARTITION BY STATEMENT_DATE) "BEST_PRIORITY"
					FROM BILLING_STATEMENT B, COMPONENT C
					WHERE ENTITY_ID IN (v_ENTITY_ID_1, v_ENTITY_ID_2)
						AND ((STATEMENT_TYPE IN (g_STMT_INITIAL, g_STMT_INDIC) AND STATEMENT_STATE = 2)
							OR (STATEMENT_TYPE = p_STATEMENT_TYPE AND STATEMENT_STATE = 1))
						AND STATEMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
						AND AS_OF_DATE = c_LOW_DATE
						AND C.COMPONENT_ID = B.COMPONENT_ID
						--Exclude the REALLOC component since we add SRAs in separately.
						AND C.EXTERNAL_IDENTIFIER <> MM_SEM_CREDIT_SHADOW.c_EXCLUDED_COMPONENT_IDENT) X
				WHERE PRIORITY = BEST_PRIORITY
				GROUP BY STATEMENT_DATE, ENTITY_ID, STATEMENT_TYPE, STATEMENT_STATE) A, SYSTEM_DATE_TIME SDT
			WHERE SDT.TIME_ZONE = 'EDT'
				AND SDT.DAY_TYPE = '1'
				AND SDT.DATA_INTERVAL_TYPE = 2
				AND SDT.CUT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND SDT.MINIMUM_INTERVAL_NUMBER >= v_MIN_INTERVAL_NUMBER
				AND SDT.CUT_DATE = A.STATEMENT_DATE(+)
			-- GROUP BY CASE p_CREDIT_MARKET WHEN 'EN' THEN SDT.LOCAL_WEEK_TRUNC_DATE ELSE SDT.LOCAL_MONTH_TRUNC_DATE END) Y,
			GROUP BY CASE p_CREDIT_MARKET WHEN 'EN' THEN DATE_UTIL.BEGIN_DATE_FOR_INTERVAL(STATEMENT_DATE, DATE_UTIL.c_ABBR_WEEK, DATE_UTIL.c_WEEK_BEGIN_SUNDAY) ELSE SDT.LOCAL_MONTH_TRUNC_DATE END) Y,
		SEM_SRA_FORECAST_CONFIG CFG
	WHERE CFG.CREDIT_MARKET = p_CREDIT_MARKET
	ORDER BY CFG.SORT_ORDER, BILLING_PERIOD_DATE;

END GET_SRA_FORECAST_RPT;
----------------------------------------------------------------------------------------
PROCEDURE GET_SRA_FORECAST_CONFIG_RPT
	(
	p_CURSOR IN OUT REF_CURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT * FROM SEM_SRA_FORECAST_CONFIG
		ORDER BY SORT_ORDER, PERIOD_NAME, CREDIT_MARKET;

END GET_SRA_FORECAST_CONFIG_RPT;
----------------------------------------------------------------------------------------
PROCEDURE PUT_SRA_FORECAST_CONFIG_RPT
	(
	p_PERIOD_NAME IN VARCHAR2,
	p_CREDIT_MARKET IN VARCHAR2,
	p_SORT_ORDER IN NUMBER,
	p_MULTIPLIER IN NUMBER,
	p_DAYS_UNTIL_POSTED IN NUMBER,
	p_DAY_TYPE IN VARCHAR2,
	p_IS_RELATIVE_TO_PERIOD_BEGIN IN NUMBER,
	p_OLD_PERIOD_NAME IN VARCHAR2,
	p_OLD_CREDIT_MARKET IN VARCHAR2
	) AS
BEGIN

	--Try to update existing record.
	UPDATE SEM_SRA_FORECAST_CONFIG
	SET PERIOD_NAME = p_PERIOD_NAME,
		CREDIT_MARKET = p_CREDIT_MARKET,
		SORT_ORDER = p_SORT_ORDER,
		MULTIPLIER = p_MULTIPLIER,
		DAYS_UNTIL_POSTED = p_DAYS_UNTIL_POSTED,
		DAY_TYPE = p_DAY_TYPE,
		IS_RELATIVE_TO_PERIOD_BEGIN = p_IS_RELATIVE_TO_PERIOD_BEGIN
	WHERE PERIOD_NAME = p_OLD_PERIOD_NAME
		AND CREDIT_MARKET = p_OLD_CREDIT_MARKET;

	--Insert if we did not find a record.
	IF SQL%NOTFOUND THEN
		INSERT INTO SEM_SRA_FORECAST_CONFIG (
			PERIOD_NAME,
			CREDIT_MARKET,
			SORT_ORDER,
			MULTIPLIER,
			DAYS_UNTIL_POSTED,
			DAY_TYPE,
			IS_RELATIVE_TO_PERIOD_BEGIN)
		VALUES (
			p_PERIOD_NAME,
			p_CREDIT_MARKET,
			p_SORT_ORDER,
			p_MULTIPLIER,
			p_DAYS_UNTIL_POSTED,
			p_DAY_TYPE,
			p_IS_RELATIVE_TO_PERIOD_BEGIN);
	END IF;

END PUT_SRA_FORECAST_CONFIG_RPT;
----------------------------------------------------------------------------------------
PROCEDURE DEL_SRA_FORECAST_CONFIG_RPT
	(
	p_PERIOD_NAME IN VARCHAR2,
	p_CREDIT_MARKET IN VARCHAR2
	) AS
BEGIN
	DELETE SEM_SRA_FORECAST_CONFIG
	WHERE PERIOD_NAME = p_PERIOD_NAME
		AND CREDIT_MARKET = p_CREDIT_MARKET;
END DEL_SRA_FORECAST_CONFIG_RPT;
----------------------------------------------------------------------------------------
PROCEDURE GET_TYPE3_CREDIT_SUM_PARTY_RPT
(
    p_STATEMENT_STATE IN NUMBER,
    p_ENTITY_GROUP_ID IN NUMBER,
    p_VERSION_ID      IN NUMBER,
    p_BEGIN_DATE      IN DATE,
    p_END_DATE        IN DATE,
    p_CURSOR          IN OUT REF_CURSOR
) AS
    v_BEGIN_DATE DATE := TRUNC(p_BEGIN_DATE);
    v_END_DATE   DATE := TRUNC(p_END_DATE);
	c_BEST_AVAIL_CCR_VERSION NUMBER(3) := -1;
BEGIN
	--BZ 17535 - Download the Type 3 CCR with other settlement reports rather than MPI
	--New filter 'CCR Versions' added to the report - default setting for the filter is 'Best Available'
	--if this option is selected then display the latest CCR (any version higher than Base)
	--for any selected date
    IF p_VERSION_ID = c_BEST_AVAIL_CCR_VERSION THEN
        OPEN p_CURSOR FOR
			SELECT CASE X.VERSION WHEN 0 THEN 'Base' ELSE TO_CHAR(X.VERSION) END VERSION,
           		T.ASSESSMENT_DATE,
           		EG.ENTITY_GROUP_NAME,
           		T.CURRENCY,
				T.REQD_CREDIT_COVER,
           		T.POSTED_CREDIT_COVER,
           		T.WARNING_LIMIT,
           		T.WARNING_LIMIT_REACHED,
           		T.BREACH_AMOUNT,
				T.ACC AS ACC,
				T.CCIN_BREACH_FLAG AS CCIN_BREACH_FLAG,
				X.TIME_STAMP TIME_STAMP
    		FROM (SELECT PTY.ASSESSMENT_DATE,
	             		 PTY.ENTITY_GROUP_ID,
						 MAX(PTY.VERSION) VERSION,
                         MAX(PTY.TIME_STAMP) TIME_STAMP
          		  FROM SEM_TYPE3_CREDIT_COVER_REPORT PTY
                  WHERE PTY.ASSESSMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		          GROUP BY PTY.ASSESSMENT_DATE, PTY.ENTITY_GROUP_ID
		          ) X,
                SEM_TYPE3_CREDIT_COVER_REPORT T,
				ENTITY_GROUP EG
    		WHERE X.ENTITY_GROUP_ID = EG.ENTITY_GROUP_ID
			AND T.ENTITY_GROUP_ID = EG.ENTITY_GROUP_ID
			AND (p_ENTITY_GROUP_ID = g_ALL OR EG.ENTITY_GROUP_ID = p_ENTITY_GROUP_ID)
			AND X.ASSESSMENT_DATE = T.ASSESSMENT_DATE
			AND TRIM(T.RECORD_TYPE) = 'S'
   		 	AND T.STATEMENT_STATE = GA.EXTERNAL_STATE
    		AND T.VERSION = X.VERSION
    		AND T.TIME_STAMP = X.TIME_STAMP
			ORDER BY 2, 3;

	ELSE
        OPEN p_CURSOR FOR
            SELECT CASE PTY.VERSION WHEN 0 THEN 'Base' ELSE TO_CHAR(PTY.VERSION) END VERSION,
                   PTY.ASSESSMENT_DATE,
                   EG.ENTITY_GROUP_NAME,
                   PTY.CURRENCY,
                   PTY.REQD_CREDIT_COVER,
                   PTY.POSTED_CREDIT_COVER,
                   PTY.WARNING_LIMIT,
                   PTY.WARNING_LIMIT_REACHED,
                   PTY.BREACH_AMOUNT,
				   PTY.ACC AS ACC,
				   PTY.CCIN_BREACH_FLAG AS CCIN_BREACH_FLAG,
				           PTY.TIME_STAMP TIME_STAMP
            FROM SEM_TYPE3_CREDIT_COVER_REPORT PTY, ENTITY_GROUP EG
            WHERE PTY.ASSESSMENT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
            AND PTY.STATEMENT_STATE = p_STATEMENT_STATE
            AND PTY.VERSION = p_VERSION_ID
            AND EG.ENTITY_GROUP_ID = PTY.ENTITY_GROUP_ID
            AND TRIM(PTY.RECORD_TYPE) = 'S'
            AND (p_ENTITY_GROUP_ID = g_ALL OR EG.ENTITY_GROUP_ID = p_ENTITY_GROUP_ID)
            ORDER BY 1, 2;
    END IF;

END GET_TYPE3_CREDIT_SUM_PARTY_RPT;
----------------------------------------------------------------------------------------
PROCEDURE GET_TYPE3_CREDIT_PSE_RPT
	(
	p_VERSION IN VARCHAR2,
	p_TIME_STAMP IN DATE,
	p_ASSESMENT_DATE IN DATE,
	p_ENTITY_GROUP_NAME IN VARCHAR2,
    p_STATEMENT_STATE IN NUMBER,
	p_ENTITY_GROUP_ID IN NUMBER,
	p_DETAIL_TYPE IN VARCHAR2,
	p_CURSOR IN OUT REF_CURSOR
	) AS
	v_CURRENT_DATE DATE := TRUNC(p_ASSESMENT_DATE);
    v_ENTITY_GROUP_ID ENTITY_GROUP.ENTITY_GROUP_ID%TYPE;
	v_VERSION NUMBER(3);
BEGIN

	----BZ 17535 - Download the Type 3 CCR with other settlement reports rather than MPI
	--Version and Time Stamp are now displayed in the summary grid.
	--The values for 'Best Available' are determined from the values of the Version and Time_Stamp
    SELECT ENTITY_GROUP_ID
    INTO v_ENTITY_GROUP_ID
    FROM ENTITY_GROUP
    WHERE ENTITY_GROUP_NAME = TRIM(p_ENTITY_GROUP_NAME);

	IF p_VERSION = 'Base' THEN
		v_VERSION := 0;
	ELSE
		v_VERSION := TO_NUMBER(p_VERSION);
	END IF;

    CASE TRIM(p_DETAIL_TYPE)

    WHEN 'Detail_Level_1' THEN
	--BZ 17921 - Display Status information in Detail Level 1 records
	OPEN p_CURSOR FOR
        SELECT PTY.ASSESSMENT_DATE,
            P.PSE_NAME,
            PTY.UNIT_TYPE,
            PTY.STATUS,
            PTY.CURRENCY,
            PTY.MARKET,
            PTY.REQD_CREDIT_COVER,
            PTY.INVOICES_NOT_PAID,
            PTY.SETTLMENT_NOT_INVOICED,
            PTY.UNDEFINED_EXPOSURE,
            PTY.REALLOCATIONS,
            PTY.INTCONN_TRADED_AMT,
            PTY.FIXED_CREDIT_COVER
        FROM SEM_TYPE3_CREDIT_COVER_REPORT PTY, ENTITY_GROUP EG, PSE P
        WHERE PTY.ASSESSMENT_DATE = v_CURRENT_DATE
          AND PTY.STATEMENT_STATE = p_STATEMENT_STATE
          AND EG.ENTITY_GROUP_ID = PTY.ENTITY_GROUP_ID
          AND TRIM(PTY.RECORD_TYPE) ='D1'
          AND EG.ENTITY_GROUP_ID = v_ENTITY_GROUP_ID
          AND PTY.PSE_ID = P.PSE_ID
          AND PTY.VERSION = v_VERSION
          AND PTY.TIME_STAMP = p_TIME_STAMP
        ORDER BY ASSESSMENT_DATE,PSE_NAME,MARKET;

    WHEN 'Detail_Level_0' THEN
	--version 003 added Adjustment Amount field for the Detail Level 0 records
	OPEN p_CURSOR FOR
        SELECT PTY.ASSESSMENT_DATE,
            P.PSE_NAME,
            PTY.UNIT_TYPE,
            PTY.CURRENCY,
            NULL "MARKET",
            PTY.REQD_CREDIT_COVER,
            PTY.INVOICES_NOT_PAID,
            PTY.SETTLMENT_NOT_INVOICED,
            PTY.UNDEFINED_EXPOSURE,
            PTY.REALLOCATIONS,
            PTY.FIXED_CREDIT_COVER,
			PTY.INTCONN_TRADED_AMT,
			PTY.ADJUSTMENT_AMOUNT
        FROM SEM_TYPE3_CREDIT_COVER_REPORT PTY, ENTITY_GROUP EG, PSE P
        WHERE PTY.ASSESSMENT_DATE = v_CURRENT_DATE
			AND PTY.STATEMENT_STATE = p_STATEMENT_STATE
            AND EG.ENTITY_GROUP_ID = PTY.ENTITY_GROUP_ID
            AND TRIM(PTY.RECORD_TYPE) ='D0'
            AND EG.ENTITY_GROUP_ID = v_ENTITY_GROUP_ID
            AND PTY.PSE_ID = P.PSE_ID
			AND PTY.VERSION = v_VERSION
			AND PTY.TIME_STAMP = p_TIME_STAMP
        ORDER BY 1,2;

    WHEN 'Detail_Level_2' THEN

	OPEN p_CURSOR FOR
        SELECT D2.ASSESSMENT_DATE,
            D2.CREDIT_MARKET,
            D2.UNDEFINED_PERIOD,
            D2.CREDIT_ASSESSMENT_PRICE,
			D2.UDEF_PERIOD_GEN,
			D2.UDEF_PERIOD_SUPP,
			D2.FORECAST_PRICE,
			D2.ECPI,
            D2.CAPACITY_ADJUSTMENT_FACTOR
        FROM SEM_CREDIT_CALC_EXTERNAL D2, ENTITY_GROUP EG
        WHERE D2.ASSESSMENT_DATE = v_CURRENT_DATE
            AND EG.ENTITY_GROUP_ID = D2.ENTITY_GROUP_ID
            AND EG.ENTITY_GROUP_ID = v_ENTITY_GROUP_ID
			AND D2.VERSION = v_VERSION
			AND D2.TIME_STAMP = p_TIME_STAMP
        ORDER BY 1,2;

    ELSE NULL;

    END CASE;

END GET_TYPE3_CREDIT_PSE_RPT;
----------------------------------------------------------------------------------------
PROCEDURE GET_TYPE3_CREDIT_VERSION
(
    p_STATUS OUT NUMBER,
    p_CURSOR IN OUT REF_CURSOR
) AS
BEGIN

    OPEN p_CURSOR FOR
        SELECT VERSION_NAME, VERSION_ID
        FROM SEM_CCR_VERSION_INFO
        ORDER BY 2;

END GET_TYPE3_CREDIT_VERSION;

-----------------------------------------------------------------------------------------
PROCEDURE GET_SEM_ACC_SUMMARY_PARTY_RPT
(
    p_ENTITY_GROUP_ID   IN NUMBER,
    p_SELECTED_RUN_TYPE IN VARCHAR2,
    p_BEGIN_DATE        IN DATE,
    p_END_DATE          IN DATE,
    p_TIME_ZONE         IN VARCHAR2,
    p_CURSOR            IN OUT GA.REFCURSOR
) AS
BEGIN
    OPEN p_CURSOR FOR
		WITH RUN_TYPES AS
			  -- Fetch the Run Types that match the filter criteria
             (SELECT ESI.EXTERNAL_IDENTIFIER    AS STATEMENT_TYPE_IDENT,
                     STY.STATEMENT_TYPE_ORDER   AS STATEMENT_TYPE_ORDER
                FROM EXTERNAL_SYSTEM_IDENTIFIER ESI,
                     STATEMENT_TYPE             STY
               WHERE STY.STATEMENT_TYPE_ID      = ESI.ENTITY_ID
                 AND ((ESI.EXTERNAL_IDENTIFIER  = p_SELECTED_RUN_TYPE) OR (p_SELECTED_RUN_TYPE = g_ALL_STRING))
                 AND ESI.IDENTIFIER_TYPE        = MM_SEM_UTIL.g_STATEMENT_TYPE_RUN_TYPE
                 AND ESI.ENTITY_DOMAIN_ID       = EC.ED_STATEMENT_TYPE
                 AND ESI.EXTERNAL_SYSTEM_ID     = EC.ES_SEM
             ),
		     PARTY AS
			  -- Fetch the Parties
             (SELECT ESI.EXTERNAL_IDENTIFIER    AS PARTY_IDENT,
                     EG.ENTITY_GROUP_ID         AS ENTITY_GROUP_ID
                FROM EXTERNAL_SYSTEM_IDENTIFIER	ESI,
                     ENTITY_GROUP               EG
               WHERE EG.ENTITY_GROUP_ID         = ESI.ENTITY_ID
                 AND ((ESI.ENTITY_ID  = p_ENTITY_GROUP_ID) OR (p_ENTITY_GROUP_ID = CONSTANTS.ALL_ID))
                 AND ESI.ENTITY_DOMAIN_ID       = EC.ED_ENTITY_GROUP
                 AND ESI.EXTERNAL_SYSTEM_ID     = EC.ES_SEM
             )
        SELECT SCAS.CODE_PARTICIPANT_NAME   AS CODE_PARTICIPANT_NAME,
               SUBSTR(TO_CHAR(SCAS.TRADE_DATE, MM_SEM_UTIL.g_DATE_FORMAT),1,10) AS DISPLAY_TRADE_DATE,
               SCAS.TRADE_DATE              AS TRADE_DATE,
               RT.STATEMENT_TYPE_ORDER      AS STATEMENT_TYPE_ORDER,
               SCAS.RUN_TYPE                AS RUN_TYPE,
               SCAS.ACC_BALANCE             AS ACC,
               SCAS.POSTED_CREDIT_COVER     AS POSTED_CC,
               SCAS.G_REQ_CREDIT_COVER + SCAS.S_REQ_CREDIT_COVER    AS RCC,
               SCAS.ACC_ID                  AS ACC_ID,
               SUBSTR(TO_CHAR(SCAS.E_LAST_SETTLEDAY, MM_SEM_UTIL.g_DATE_FORMAT),1,10) AS E_LAST_SETTLEMENTDAY,
               SUBSTR(TO_CHAR(SCAS.C_LAST_SETTLEDAY, MM_SEM_UTIL.g_DATE_FORMAT),1,10) AS C_LAST_SETTLEMENTDAY
          FROM SEM_CREDIT_ACC_SUMMARY SCAS,
               RUN_TYPES              RT,
               PARTY                  P
         WHERE UPPER(TRIM(SCAS.CODE_PARTICIPANT_NAME)) = UPPER(TRIM(P.PARTY_IDENT))
           AND UPPER(TRIM(SCAS.RUN_TYPE)) = UPPER(TRIM(RT.STATEMENT_TYPE_IDENT))
           AND TRUNC(SCAS.TRADE_DATE) BETWEEN p_BEGIN_DATE AND p_END_DATE
        ORDER BY SCAS.CODE_PARTICIPANT_NAME, SCAS.TRADE_DATE, SCAS.RUN_TYPE;
END GET_SEM_ACC_SUMMARY_PARTY_RPT;
-----------------------------------------------------------------------------------------
PROCEDURE GET_SEM_ACC_REPORT_DETAIL
(
    p_CODE_PARTICIPANT_NAME IN VARCHAR2,
    p_SELECTED_RUN_TYPE     IN VARCHAR2,
    p_TRADE_DATE            IN DATE,
    p_TIME_ZONE             IN VARCHAR2,
    p_DETAIL_TYPE           IN VARCHAR2,
    p_CURSOR                IN OUT GA.REFCURSOR
) AS
    v_SUMM_ATTRIBUTE_NAMES STRING_COLLECTION := STRING_COLLECTION('ACC', 'POSTED_ACC', 'RCC_GEN',
                                                                  'RCC_SUP', 'FIXED_CC', 'ETEV_TOTAL',
                                                                  'CTEV_TOTAL', 'ECPI');
BEGIN
    CASE TRIM(p_DETAIL_TYPE)
        WHEN 'Summary' THEN
            OPEN p_CURSOR FOR
                WITH RUN_TYPES AS
                      -- Fetch the Run Types that match the filter criteria
                     (SELECT ESI.EXTERNAL_IDENTIFIER    AS STATEMENT_TYPE_IDENT,
                             STY.STATEMENT_TYPE_ORDER   AS STATEMENT_TYPE_ORDER
                        FROM EXTERNAL_SYSTEM_IDENTIFIER ESI,
                             STATEMENT_TYPE             STY
                       WHERE STY.STATEMENT_TYPE_ID      = ESI.ENTITY_ID
                         AND ((ESI.EXTERNAL_IDENTIFIER  = p_SELECTED_RUN_TYPE) OR (p_SELECTED_RUN_TYPE = g_ALL_STRING))
                         AND ESI.IDENTIFIER_TYPE        = MM_SEM_UTIL.g_STATEMENT_TYPE_RUN_TYPE
                         AND ESI.ENTITY_DOMAIN_ID       = EC.ED_STATEMENT_TYPE
                         AND ESI.EXTERNAL_SYSTEM_ID     = EC.ES_SEM
                     )
                    SELECT RT.STATEMENT_TYPE_ORDER,
                           X.RUN_TYPE,
                           CASE X.ATTRIBUTE_NAME
                               WHEN 'ACC' THEN 'ACC'
                               WHEN 'POSTED_ACC' THEN 'Posted CC'
                               WHEN 'RCC_GEN' THEN 'RCC (Gen)'
                               WHEN 'RCC_SUP' THEN 'RCC (Sup)'
                               WHEN 'FIXED_CC' THEN 'Fixed CC'
                               WHEN 'ETEV_TOTAL' THEN 'ETEV (Total)'
                               WHEN 'CTEV_TOTAL' THEN 'CTEV (Total)'
                               WHEN 'ECPI' THEN 'ECPI'
                               END AS ATTRIBUTE_NAME,
                           CASE X.ATTRIBUTE_NAME
                               WHEN 'ACC' THEN X.ACC_BALANCE
                               WHEN 'POSTED_ACC' THEN X.POSTED_CREDIT_COVER
                               WHEN 'RCC_GEN' THEN X.G_REQ_CREDIT_COVER
                               WHEN 'RCC_SUP' THEN X.S_REQ_CREDIT_COVER
                               WHEN 'FIXED_CC' THEN X.FIXED_CREDIT_COVER
                               WHEN 'ETEV_TOTAL' THEN X.ETEV
                               WHEN 'CTEV_TOTAL' THEN X.CTEV
                               WHEN 'ECPI' THEN X.ECPI
                               END AS ATTRIBUTE_VALUE,
                           CASE X.ATTRIBUTE_NAME
                               WHEN 'ACC' THEN 1
                               WHEN 'POSTED_ACC' THEN 2
                               WHEN 'RCC_GEN' THEN 3
                               WHEN 'RCC_SUP' THEN 4
                               WHEN 'FIXED_CC' THEN 5
                               WHEN 'ETEV_TOTAL' THEN 6
                               WHEN 'CTEV_TOTAL' THEN 7
                               WHEN 'ECPI' THEN 8
                               END AS ATTRIBUTE_ORDER
                      FROM (SELECT SCAS.*,
                                   ATTRIBUTE_NAMES.COLUMN_VALUE AS ATTRIBUTE_NAME
                              FROM SEM_CREDIT_ACC_SUMMARY       SCAS,
                                   TABLE(CAST(v_SUMM_ATTRIBUTE_NAMES AS STRING_COLLECTION)) ATTRIBUTE_NAMES,
                                   EXTERNAL_SYSTEM_IDENTIFIER	ESI,
                                   ENTITY_GROUP                 EG
                             WHERE TRUNC(SCAS.TRADE_DATE)     = TRUNC(p_TRADE_DATE)
                               AND UPPER(TRIM(SCAS.CODE_PARTICIPANT_NAME)) = UPPER(TRIM(ESI.EXTERNAL_IDENTIFIER))
                               AND UPPER(TRIM(ESI.EXTERNAL_IDENTIFIER))    = UPPER(TRIM(p_CODE_PARTICIPANT_NAME))
                               AND ESI.ENTITY_DOMAIN_ID       = EC.ED_ENTITY_GROUP
                               AND ESI.EXTERNAL_SYSTEM_ID     = EC.ES_SEM
                               AND EG.ENTITY_GROUP_ID         = ESI.ENTITY_ID
                           )X,
                           RUN_TYPES RT
                     WHERE UPPER(TRIM(X.RUN_TYPE)) = UPPER(TRIM(RT.STATEMENT_TYPE_IDENT))
                    ORDER BY STATEMENT_TYPE_ORDER, ATTRIBUTE_ORDER;
         WHEN 'Interval' THEN
            OPEN p_CURSOR FOR
                WITH RUN_TYPES AS
                      -- Fetch the Run Types that match the filter criteria
                     (SELECT ESI.EXTERNAL_IDENTIFIER    AS STATEMENT_TYPE_IDENT,
                             STY.STATEMENT_TYPE_ORDER   AS STATEMENT_TYPE_ORDER
                        FROM EXTERNAL_SYSTEM_IDENTIFIER ESI,
                             STATEMENT_TYPE             STY
                       WHERE STY.STATEMENT_TYPE_ID      = ESI.ENTITY_ID
                         AND ((ESI.EXTERNAL_IDENTIFIER  = p_SELECTED_RUN_TYPE) OR (p_SELECTED_RUN_TYPE = g_ALL_STRING))
                         AND ESI.IDENTIFIER_TYPE        = MM_SEM_UTIL.g_STATEMENT_TYPE_RUN_TYPE
                         AND ESI.ENTITY_DOMAIN_ID       = EC.ED_STATEMENT_TYPE
                         AND ESI.EXTERNAL_SYSTEM_ID     = EC.ES_SEM
                     )
                    SELECT FROM_CUT_AS_HED(SCAI.DELIVERY_DATE, p_TIME_ZONE, DATE_UTIL.c_ABBR_30MIN)   AS TRADE_INTERVAL,
                           RT.STATEMENT_TYPE_ORDER,
                           SCAS.RUN_TYPE        AS RUN_TYPE,
                           SCAI.ETEV            AS ETEV,
                           SCAI.CTEV            AS CTEV
                      FROM SEM_CREDIT_ACC_INTERVAL SCAI,
                           SEM_CREDIT_ACC_SUMMARY  SCAS,
                           RUN_TYPES               RT,
                           EXTERNAL_SYSTEM_IDENTIFIER	ESI,
                           ENTITY_GROUP                 EG
                     WHERE SCAS.ACC_ID = SCAI.ACC_ID
                       AND TRUNC(SCAS.TRADE_DATE)     = TRUNC(p_TRADE_DATE)
                       AND UPPER(TRIM(SCAS.CODE_PARTICIPANT_NAME)) = UPPER(TRIM(ESI.EXTERNAL_IDENTIFIER))
                       AND UPPER(TRIM(ESI.EXTERNAL_IDENTIFIER))    = UPPER(TRIM(p_CODE_PARTICIPANT_NAME))
                       AND ESI.ENTITY_DOMAIN_ID       = EC.ED_ENTITY_GROUP
                       AND ESI.EXTERNAL_SYSTEM_ID     = EC.ES_SEM
                       AND EG.ENTITY_GROUP_ID         = ESI.ENTITY_ID
                       AND UPPER(TRIM(SCAS.RUN_TYPE))  = UPPER(TRIM(RT.STATEMENT_TYPE_IDENT))
                    ORDER BY TRADE_INTERVAL, STATEMENT_TYPE_ORDER;
        END CASE;
END GET_SEM_ACC_REPORT_DETAIL;
-----------------------------------------------------------------------------------------
END SEM_CREDIT_REPORTS;
/
