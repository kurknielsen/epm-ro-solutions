--THIS SCRIPT POPULATES THE SYSTEM_DATE_TIME FOR EDT AFTER
-- THE ON_PEAK HOUR END HAS BEEN ADJUSTED TO 23. CALLED BY
-- SETUPMARKET.SQL
--SEE THE BOTTOM OF THIS SCRIPT FOR THE ACTUAL PROCEDURE CALL.
DECLARE

PROCEDURE POPULATE_SYSTEM_DATE_TIME
	(
	p_LOCAL_TIME_ZONE VARCHAR2 := LOCAL_TIME_ZONE,
	p_CUT_TIME_ZONE VARCHAR2 := CUT_TIME_ZONE,
	p_MINIMUM_INTERVAL VARCHAR2 := 'HH',
	p_BEGIN_YEAR NUMBER := 2000,
	p_END_YEAR NUMBER := 2020,
	p_EDC_ID NUMBER := 0,
	p_FISCAL_YEAR_END_DATE DATE := '30-SEP-1900',
	p_TIME_CUSTOM_FORMAT VARCHAR2 := 'HH24:MI',
	p_DATE_CUSTOM_FORMAT VARCHAR2 := 'MM/DD/YYYY',
	p_WEEKEND_CUSTOM_FORMAT VARCHAR2 := ' WE ',
	p_WEEKDAY_CUSTOM_FORMAT VARCHAR2 := ' WD '
	) AS

	--==========================================
	--	CONSTANTS -- DO NOT CHANGE
	--==========================================
	c_TIME_YYYY_MM_DD VARCHAR2(32) := 'HH24:MI';
	c_DATE_YYYY_MM_DD VARCHAR2(16) := 'YYYY-MM-DD';
	c_WEEKEND_YYYY_MM_DD VARCHAR2(16) := ' WE ';
	c_WEEKDAY_YYYY_MM_DD VARCHAR2(16) := ' WD ';
	c_DAYLIGHT_SUFFIX CHAR(1) := 'd';
	c_STANDARD_SUFFIX CHAR(1) := 's';

	--==========================================
	--	CONSTANTS SORT OF FROM GA PACKAGE
	--==========================================
	g_SECOND NUMBER(4,4) := .0001;

	--DAY TYPES
	g_DAYTYPE_STANDARD CHAR(1) := '1';
	g_DAYTYPE_WEEKDAY CHAR(1) := '2';
	g_DAYTYPE_WEEKEND CHAR(1) := '3';

	--SCENARIO ROLLUP TYPES
	g_ROLLUP_HOURLY NUMBER(1) := 0;
	g_ROLLUP_DAILY NUMBER(1) := 1;
	g_ROLLUP_WEEKLY NUMBER(1) := 2;
	g_ROLLUP_MONTHLY NUMBER(1) := 3;

	--DATA INTERVAL TYPES
	g_DATA_HOURLY NUMBER(1) := 1;
	g_DATA_DAILY NUMBER(1) := 2;

	--==========================================
	--	VARIABLES
	--==========================================
	v_CUR_DATE DATE;

	--==========================================
	--	INNER PROCEDURE
	--==========================================
	PROCEDURE INSERT_SYSTEM_DATE_TIME
		(
		p_TIME_ZONE IN VARCHAR2,
		p_DATA_INTERVAL_TYPE IN NUMBER,
		p_DAY_TYPE IN CHAR,
		p_CUT_DATE IN DATE,
		p_LOCAL_DATE IN DATE,
		p_STANDARD_DATE IN DATE,
		p_CUT_DATE_SCHEDULING IN DATE,
		p_MINIMUM_INTERVAL_NUMBER IN NUMBER,
		p_CUT_MINUTE IN NUMBER,
		p_CUT_HOUR IN NUMBER,
		p_CUT_DAY_IN_WEEK IN NUMBER,
		p_CUT_DAY_ABBR IN VARCHAR2,
		p_CUT_DAY_IN_MONTH IN NUMBER,
		p_CUT_WEEK_IN_YEAR IN NUMBER,
		p_CUT_MONTH IN NUMBER,
		p_CUT_QUARTER IN NUMBER,
		p_CUT_YEAR IN NUMBER,
		p_CUT_FISCAL_YEAR IN NUMBER,
		p_LOCAL_HOUR_TRUNC_DATE IN DATE,
		p_LOCAL_DAY_TRUNC_DATE IN DATE,
		p_LOCAL_WEEK_TRUNC_DATE IN DATE,
		p_LOCAL_MONTH_TRUNC_DATE IN DATE,
		p_LOCAL_QUARTER_TRUNC_DATE IN DATE,
		p_LOCAL_YEAR_TRUNC_DATE IN DATE,
		p_LOCAL_FISCAL_YEAR_TRUNC_DATE IN DATE,
		p_NO_ROLLUP_YYYY_MM_DD IN VARCHAR2,
		p_HOUR_YYYY_MM_DD IN VARCHAR2,
		p_DAY_YYYY_MM_DD IN VARCHAR2,
		p_WEEK_YYYY_MM_DD IN VARCHAR2,
		p_MONTH_YYYY_MM_DD IN VARCHAR2,
		p_QUARTER_YYYY_MM_DD IN VARCHAR2,
		p_YEAR_YYYY_MM_DD IN VARCHAR2,
		p_FISCAL_YEAR_YYYY_MM_DD IN VARCHAR2,
		p_NO_ROLLUP_CUSTOM_STRING IN VARCHAR2,
		p_HOUR_CUSTOM_STRING IN VARCHAR2,
		p_DAY_CUSTOM_STRING IN VARCHAR2,
		p_WEEK_CUSTOM_STRING IN VARCHAR2,
		p_MONTH_CUSTOM_STRING IN VARCHAR2,
		p_QUARTER_CUSTOM_STRING IN VARCHAR2,
		p_YEAR_CUSTOM_STRING IN VARCHAR2,
		p_FISCAL_YEAR_CUSTOM_STRING IN VARCHAR2,
		p_IS_IN_DST_RANGE IN NUMBER,
		p_IS_DST_SPRING_AHEAD_HOUR IN NUMBER,
		p_IS_DST_SPRING_AHEAD_DAY IN NUMBER,
		p_IS_DST_FALL_BACK_HOUR IN NUMBER,
		p_IS_DST_FALL_BACK_DAY IN NUMBER,
		p_IS_ON_PEAK IN NUMBER
		) IS
	BEGIN

		INSERT INTO SYSTEM_DATE_TIME(TIME_ZONE, DATA_INTERVAL_TYPE, DAY_TYPE, CUT_DATE, LOCAL_DATE, STANDARD_DATE, CUT_DATE_SCHEDULING, MINIMUM_INTERVAL_NUMBER, CUT_MINUTE, CUT_HOUR, CUT_DAY_IN_WEEK, CUT_DAY_ABBR, CUT_DAY_IN_MONTH, CUT_WEEK_IN_YEAR, CUT_MONTH, CUT_QUARTER, CUT_YEAR, CUT_FISCAL_YEAR, LOCAL_HOUR_TRUNC_DATE, LOCAL_DAY_TRUNC_DATE, LOCAL_WEEK_TRUNC_DATE, LOCAL_MONTH_TRUNC_DATE, LOCAL_QUARTER_TRUNC_DATE, LOCAL_YEAR_TRUNC_DATE, LOCAL_FISCAL_YEAR_TRUNC_DATE, NO_ROLLUP_YYYY_MM_DD, HOUR_YYYY_MM_DD, DAY_YYYY_MM_DD, WEEK_YYYY_MM_DD, MONTH_YYYY_MM_DD, QUARTER_YYYY_MM_DD, YEAR_YYYY_MM_DD, FISCAL_YEAR_YYYY_MM_DD, NO_ROLLUP_CUSTOM_STRING, HOUR_CUSTOM_STRING, DAY_CUSTOM_STRING, WEEK_CUSTOM_STRING, MONTH_CUSTOM_STRING, QUARTER_CUSTOM_STRING, YEAR_CUSTOM_STRING, FISCAL_YEAR_CUSTOM_STRING, IS_IN_DST_RANGE, IS_DST_SPRING_AHEAD_HOUR, IS_DST_SPRING_AHEAD_DAY, IS_DST_FALL_BACK_HOUR, IS_DST_FALL_BACK_DAY, IS_ON_PEAK)
		VALUES(p_TIME_ZONE, p_DATA_INTERVAL_TYPE, p_DAY_TYPE, p_CUT_DATE, p_LOCAL_DATE, p_STANDARD_DATE, p_CUT_DATE_SCHEDULING, p_MINIMUM_INTERVAL_NUMBER, p_CUT_MINUTE, p_CUT_HOUR, p_CUT_DAY_IN_WEEK, p_CUT_DAY_ABBR, p_CUT_DAY_IN_MONTH, p_CUT_WEEK_IN_YEAR, p_CUT_MONTH, p_CUT_QUARTER, p_CUT_YEAR, p_CUT_FISCAL_YEAR, p_LOCAL_HOUR_TRUNC_DATE, p_LOCAL_DAY_TRUNC_DATE, p_LOCAL_WEEK_TRUNC_DATE, p_LOCAL_MONTH_TRUNC_DATE, p_LOCAL_QUARTER_TRUNC_DATE, p_LOCAL_YEAR_TRUNC_DATE, p_LOCAL_FISCAL_YEAR_TRUNC_DATE, p_NO_ROLLUP_YYYY_MM_DD, p_HOUR_YYYY_MM_DD, p_DAY_YYYY_MM_DD, p_WEEK_YYYY_MM_DD, p_MONTH_YYYY_MM_DD, p_QUARTER_YYYY_MM_DD, p_YEAR_YYYY_MM_DD, p_FISCAL_YEAR_YYYY_MM_DD, p_NO_ROLLUP_CUSTOM_STRING, p_HOUR_CUSTOM_STRING, p_DAY_CUSTOM_STRING, p_WEEK_CUSTOM_STRING, p_MONTH_CUSTOM_STRING, p_QUARTER_CUSTOM_STRING, p_YEAR_CUSTOM_STRING, p_FISCAL_YEAR_CUSTOM_STRING, p_IS_IN_DST_RANGE, p_IS_DST_SPRING_AHEAD_HOUR, p_IS_DST_SPRING_AHEAD_DAY, p_IS_DST_FALL_BACK_HOUR, p_IS_DST_FALL_BACK_DAY, p_IS_ON_PEAK);

	END INSERT_SYSTEM_DATE_TIME;

	-- -------------------------------------------------------

	FUNCTION GET_FISCAL_YEAR_DATE
		(
		p_DATE IN DATE
		) RETURN DATE IS
	BEGIN
		--IF WE ARE STILL WITHIN THE FISCAL YEAR, DO NOT ADD A YEAR.
		IF TO_CHAR(p_DATE,'MMDD') <= TO_CHAR(p_FISCAL_YEAR_END_DATE,'MMDD') THEN
			RETURN p_DATE;
		--IF WE ARE IN THE NEXT FISCAL YEAR, ADD A YEAR.
		ELSE
			RETURN ADD_MONTHS(p_DATE, 12);
		END IF;
	END GET_FISCAL_YEAR_DATE;

	-- -------------------------------------------------------

	FUNCTION GET_MINIMUM_INTERVAL_NUMBER
		(
		p_DATE IN DATE
		) RETURN NUMBER IS
		v_MINIMUM_INTERVAL NUMBER(2);
		v_MINUTES NUMBER(2) := TO_NUMBER(TO_CHAR(p_DATE, 'MI'));
	BEGIN
		
		IF TRUNC(p_DATE, 'YY') = p_DATE THEN
			v_MINIMUM_INTERVAL := GET_INTERVAL_NUMBER('YY');
		ELSIF TRUNC(p_DATE, 'Q') = p_DATE THEN
			v_MINIMUM_INTERVAL := GET_INTERVAL_NUMBER('Q');
		ELSIF TRUNC(p_DATE, 'MM') = p_DATE THEN
			v_MINIMUM_INTERVAL := GET_INTERVAL_NUMBER('MM');
		ELSIF TRUNC(p_DATE, 'DY') = p_DATE THEN
			v_MINIMUM_INTERVAL := GET_INTERVAL_NUMBER('DY');
		ELSIF TRUNC(p_DATE, 'DD') = p_DATE THEN
			v_MINIMUM_INTERVAL := GET_INTERVAL_NUMBER('DD');
		ELSIF v_MINUTES = 0 THEN
			v_MINIMUM_INTERVAL := GET_INTERVAL_NUMBER('HH');
		ELSIF v_MINUTES = 30 THEN
			v_MINIMUM_INTERVAL := GET_INTERVAL_NUMBER('MI30');
		ELSIF v_MINUTES IN (15, 45) THEN
			v_MINIMUM_INTERVAL := GET_INTERVAL_NUMBER('MI15');
		ELSIF MOD(v_MINUTES, 10) = 0 THEN
			v_MINIMUM_INTERVAL := GET_INTERVAL_NUMBER('MI10');
		ELSE   
			v_MINIMUM_INTERVAL := GET_INTERVAL_NUMBER('MI5');
		END IF;

		RETURN v_MINIMUM_INTERVAL;

	END GET_MINIMUM_INTERVAL_NUMBER;

	-- -------------------------------------------------------

	PROCEDURE ADD_HOURLY_ROW
		(
		p_DAY_TYPE IN CHAR,
		p_DATE IN DATE
		) IS

		v_LOCAL_DATE DATE;
		v_STANDARD_DATE DATE;
        v_DST_SPRING_AHEAD_DATE DATE;
        v_DST_FALL_BACK_DATE DATE;
		v_IS_IN_DST_RANGE NUMBER(1);
		v_IS_DST_SPRING_AHEAD_HOUR NUMBER(1);
		v_IS_DST_SPRING_AHEAD_DAY NUMBER(1);
		v_IS_DST_FALL_BACK_HOUR NUMBER(1);
		v_IS_DST_FALL_BACK_DAY NUMBER(1);
		v_GETS_DOUBLE_COLON NUMBER(1);
		v_IS_HOLIDAY NUMBER(1) := 0;
		--==========================================
		--	INNER INNER PROCEDURE
		--==========================================
		PROCEDURE SET_DST_STATISTICS
			(
			p_CUT_DATE IN DATE
			) IS
			v_STANDARD_TIME_ZONE SYSTEM_TIME_ZONE.STANDARD_TIME_ZONE%TYPE;
            v_LOCAL_DATE_MINUS_ONE_SEC DATE;
			v_PREV_LOCAL_DATE DATE;
		BEGIN
			SELECT STANDARD_TIME_ZONE INTO v_STANDARD_TIME_ZONE FROM SYSTEM_TIME_ZONE WHERE TIME_ZONE = p_LOCAL_TIME_ZONE;

			--SET INITIAL VALUES
			v_IS_DST_SPRING_AHEAD_DAY := 0;
			v_IS_DST_SPRING_AHEAD_HOUR := 0;
			v_IS_DST_FALL_BACK_DAY := 0;
			v_IS_DST_FALL_BACK_HOUR := 0;
			v_IS_IN_DST_RANGE := 0;
			v_GETS_DOUBLE_COLON := 0;
			v_STANDARD_DATE := NEW_TIME(p_CUT_DATE, p_CUT_TIME_ZONE, v_STANDARD_TIME_ZONE);
			v_LOCAL_DATE := v_STANDARD_DATE;
            v_LOCAL_DATE_MINUS_ONE_SEC := ADD_SECONDS_TO_DATE(v_LOCAL_DATE, -1);

			--ADJUST IF WE OBSERVE DST.
			--Special daytypes do not get shifted for DST.
			IF (NOT v_STANDARD_TIME_ZONE = p_LOCAL_TIME_ZONE) AND p_DAY_TYPE = g_DAYTYPE_STANDARD THEN
				
                v_DST_SPRING_AHEAD_DATE := DST_SPRING_AHEAD_DATE(v_STANDARD_DATE);
				v_DST_FALL_BACK_DATE := DST_FALL_BACK_DATE(v_STANDARD_DATE);
   
                
			v_PREV_LOCAL_DATE := v_LOCAL_DATE;
            IF TRUNC(v_LOCAL_DATE, 'HH') >= v_DST_SPRING_AHEAD_DATE AND v_LOCAL_DATE <= v_DST_FALL_BACK_DATE THEN
                  
                    -- Fix for mismatch between SystemDateTime and DateAlignedGrids - PBM 3/29/2005
                    -- Remove this condition if we revert back to the correct way of handling the FALL_BACK date
                 IF v_LOCAL_DATE <= (v_DST_FALL_BACK_DATE - 1/24) THEN
						v_IS_IN_DST_RANGE := 1;
                        v_LOCAL_DATE := NEW_TIME(v_LOCAL_DATE, v_STANDARD_TIME_ZONE, p_LOCAL_TIME_ZONE);
                        v_LOCAL_DATE_MINUS_ONE_SEC := ADD_SECONDS_TO_DATE(v_LOCAL_DATE, -1);
					    IF v_LOCAL_DATE = v_DST_FALL_BACK_DATE THEN
								v_IS_DST_FALL_BACK_HOUR := 1;
								v_GETS_DOUBLE_COLON := 1;
				        END IF;
			     ELSE
				        IF v_LOCAL_DATE = v_DST_FALL_BACK_DATE THEN
								v_IS_DST_FALL_BACK_HOUR := 0;
						ELSE
								v_GETS_DOUBLE_COLON := 1;
						END IF;
						v_LOCAL_DATE := ADD_SECONDS_TO_DATE(v_LOCAL_DATE, 1);
				 END IF;

			END IF;                
                
				IF TRUNC(v_LOCAL_DATE_MINUS_ONE_SEC, 'DD') = TRUNC(v_DST_SPRING_AHEAD_DATE, 'DD') THEN
					v_IS_DST_SPRING_AHEAD_DAY := 1;
					IF TRUNC(v_LOCAL_DATE, 'HH') = v_DST_SPRING_AHEAD_DATE THEN
						v_IS_DST_SPRING_AHEAD_HOUR := 1;
					END IF;
				ELSIF TRUNC(v_LOCAL_DATE_MINUS_ONE_SEC, 'DD') = TRUNC(v_DST_FALL_BACK_DATE, 'DD') THEN
					v_IS_DST_FALL_BACK_DAY := 1;
				END IF;

			END IF;
		END SET_DST_STATISTICS;

		--==========================================
		--	INNER INNER PROCEDURE
		--==========================================
		FUNCTION GET_HOURLY_FORMATTED_DATE
			(
			p_DATE IN DATE,
			p_DAY_TYPE IN CHAR,
			p_INTERVAL IN VARCHAR2,
			p_DATE_FORMAT IN VARCHAR2,
			p_TIME_FORMAT IN VARCHAR2,
			p_WEEKDAY_ABBR IN VARCHAR2,
			p_WEEKEND_ABBR IN VARCHAR2,
			p_IS_FOR_SORT IN NUMBER
			) RETURN VARCHAR2 IS

			v_DATE DATE := p_DATE;
			v_DATE_STRING VARCHAR2(32);
			v_TIME_STRING VARCHAR2(16);
			v_SUFFIX VARCHAR2(4);
			v_TIME_FORMAT VARCHAR2(32) := p_TIME_FORMAT;
		BEGIN

			-- If this is 24:00, it belongs in the previous day.
			IF TO_CHAR(v_DATE,'HH24:MI') = '00:00' THEN
				v_DATE := v_DATE - 1;
				v_TIME_FORMAT := REPLACE(REPLACE(p_TIME_FORMAT,'HH24','"24"'),'HH','"24"');
			END IF;

			-- If the local date has a sub-hourly specification then roll it to the next hour.
			IF TO_NUMBER(TO_CHAR(v_DATE,'MI')) <> 0 AND (p_INTERVAL = 'HH') THEN
				v_DATE := TRUNC(ADD_HOURS_TO_DATE(v_DATE,1), 'HH');
			END IF;
			
			-- Get appropriate dst suffix
			IF (v_IS_DST_SPRING_AHEAD_DAY = 1 OR v_IS_DST_FALL_BACK_DAY = 1) AND p_INTERVAL IN ('MI15','HH') THEN
				
                -- Fix for mismatch between SystemDateTime and DateAlignedGrids - PBM 3/29/2005
                -- Remove this condition if we revert back to the correct way of handling the FALL_BACK date                    
				IF v_IS_IN_DST_RANGE = 1 THEN
					IF v_DATE = v_DST_FALL_BACK_DATE THEN
						v_DATE := v_DATE-1/24;
						v_SUFFIX := c_STANDARD_SUFFIX;
					ELSE
						v_SUFFIX := c_DAYLIGHT_SUFFIX;
					END IF;
				ELSE
					v_SUFFIX := c_STANDARD_SUFFIX;
				END IF;
                
			ELSE
				v_SUFFIX := ' ';
			END IF;

			-- Get Time String.  Shift 0 to 24.
			IF p_INTERVAL IN ('DD','MM','Q','YY','DY') THEN
				v_TIME_STRING := LPAD(' ', LENGTH(p_TIME_FORMAT) - 1, ' ');
			ELSIF v_IS_DST_FALL_BACK_DAY = 1 AND p_IS_FOR_SORT = 1 THEN
				--PUT THE SUFFIX BEFORE THE TIME.
				v_TIME_STRING := v_SUFFIX || TO_CHAR(v_DATE,v_TIME_FORMAT);
			ELSE
				v_TIME_STRING := TO_CHAR(v_DATE,v_TIME_FORMAT) || v_SUFFIX;
			END IF;

			IF v_GETS_DOUBLE_COLON = 1 THEN
				v_TIME_STRING := REPLACE(v_TIME_STRING,'01:','01::');
			ELSIF v_SUFFIX = c_STANDARD_SUFFIX THEN
				v_TIME_STRING := REPLACE(v_TIME_STRING,'01:00s','01::00s');
			END IF;

			IF NOT SUBSTR(p_INTERVAL,1,2) = 'MI' THEN
				v_DATE := TRUNC(v_DATE,p_INTERVAL);
			END IF;

			IF p_DAY_TYPE = g_DAYTYPE_STANDARD THEN
				v_DATE_STRING := TO_CHAR(v_DATE, p_DATE_FORMAT) || ' ' || v_TIME_STRING;
			ELSIF p_DAY_TYPE = g_DAYTYPE_WEEKDAY THEN --WEEKDAY
				v_DATE_STRING := TO_CHAR(v_DATE, p_DATE_FORMAT)  || p_WEEKDAY_ABBR || v_TIME_STRING;
			ELSIF p_DAY_TYPE = g_DAYTYPE_WEEKEND THEN --WEEKEND
				v_DATE_STRING := TO_CHAR(v_DATE, p_DATE_FORMAT)  || p_WEEKEND_ABBR || v_TIME_STRING;
			END IF;

			RETURN v_DATE_STRING;
		END GET_HOURLY_FORMATTED_DATE;


	BEGIN -- ADD_HOURLY_ROW
		SET_DST_STATISTICS(p_DATE);
		IF IS_HOLIDAY(TRUNC(v_LOCAL_DATE - g_SECOND, 'DD'),p_EDC_ID) THEN
			v_IS_HOLIDAY := 1;
		END IF;
		INSERT_SYSTEM_DATE_TIME(p_LOCAL_TIME_ZONE, -- TIME_ZONE
			g_DATA_HOURLY, 				-- DATA_INTERVAL_TYPE
			p_DAY_TYPE, 	-- DAY_TYPE
			p_DATE, 		-- CUT_DATE
			v_LOCAL_DATE, --LOCAL_DATE
			v_STANDARD_DATE, --STANDARD_DATE
			p_DATE, 		-- CUT_DATE_SCHEDULING
			GET_MINIMUM_INTERVAL_NUMBER(p_DATE),	--MINIMUM_INTERVAL_NUMBER
			TO_NUMBER(TO_CHAR(p_DATE,'MI')), 	-- CUT_MINUTE
			TO_NUMBER(TO_CHAR(p_DATE,'HH24')), 	-- CUT_HOUR
			TO_NUMBER(TO_CHAR(p_DATE - g_SECOND,'D')), 	-- CUT_DAY_IN_WEEK
			TO_CHAR(p_DATE - g_SECOND,'DY'), 				-- CUT_DAY_ABBR
			TO_NUMBER(TO_CHAR(p_DATE - g_SECOND,'DD')), 	-- CUT_DAY_IN_MONTH
			TO_NUMBER(TO_CHAR(p_DATE - g_SECOND,'WW')), 	-- CUT_WEEK
			TO_NUMBER(TO_CHAR(p_DATE - g_SECOND,'MM')), 	-- CUT_MONTH
			TO_NUMBER(TO_CHAR(p_DATE - g_SECOND,'Q')), 		-- CUT_QUARTER
			TO_NUMBER(TO_CHAR(p_DATE - g_SECOND,'YYYY')), 	-- CUT_YEAR
			TO_NUMBER(TO_CHAR(GET_FISCAL_YEAR_DATE(p_DATE - g_SECOND),'YYYY')), 	-- CUT_FISCAL_YEAR
			TRUNC(v_LOCAL_DATE, 'HH'), -- LOCAL_HOUR_TRUNC_DATE
			TRUNC(v_LOCAL_DATE - g_SECOND, 'DD'), -- LOCAL_DAY_TRUNC_DATE
			TRUNC(v_LOCAL_DATE - g_SECOND, 'DY'), -- LOCAL_WEEK_TRUNC_DATE
			TRUNC(v_LOCAL_DATE - g_SECOND, 'MM'), -- LOCAL_MONTH_TRUNC_DATE
			TRUNC(v_LOCAL_DATE - g_SECOND, 'Q'), -- LOCAL_QUARTER_TRUNC_DATE
			TRUNC(v_LOCAL_DATE - g_SECOND, 'YY'), -- LOCAL_YEAR_TRUNC_DATE
			TRUNC(GET_FISCAL_YEAR_DATE(v_LOCAL_DATE - g_SECOND), 'YY'), -- LOCAL_FISCAL_YEAR_TRUNC_DATE
			GET_HOURLY_FORMATTED_DATE(v_LOCAL_DATE,p_DAY_TYPE,'MI15',c_DATE_YYYY_MM_DD,c_TIME_YYYY_MM_DD,c_WEEKDAY_YYYY_MM_DD,c_WEEKEND_YYYY_MM_DD,0),
			GET_HOURLY_FORMATTED_DATE(v_LOCAL_DATE,p_DAY_TYPE,'HH',c_DATE_YYYY_MM_DD,c_TIME_YYYY_MM_DD,c_WEEKDAY_YYYY_MM_DD,c_WEEKEND_YYYY_MM_DD,0),
			GET_HOURLY_FORMATTED_DATE(v_LOCAL_DATE,p_DAY_TYPE,'DD',c_DATE_YYYY_MM_DD,c_TIME_YYYY_MM_DD,c_WEEKDAY_YYYY_MM_DD,c_WEEKEND_YYYY_MM_DD,0),
			GET_HOURLY_FORMATTED_DATE(v_LOCAL_DATE,p_DAY_TYPE,'DY',c_DATE_YYYY_MM_DD,c_TIME_YYYY_MM_DD,c_WEEKDAY_YYYY_MM_DD,c_WEEKEND_YYYY_MM_DD,0),
			GET_HOURLY_FORMATTED_DATE(v_LOCAL_DATE,p_DAY_TYPE,'MM',c_DATE_YYYY_MM_DD,c_TIME_YYYY_MM_DD,c_WEEKDAY_YYYY_MM_DD,c_WEEKEND_YYYY_MM_DD,0),
			GET_HOURLY_FORMATTED_DATE(v_LOCAL_DATE,p_DAY_TYPE,'Q',c_DATE_YYYY_MM_DD,c_TIME_YYYY_MM_DD,c_WEEKDAY_YYYY_MM_DD,c_WEEKEND_YYYY_MM_DD,0),
			GET_HOURLY_FORMATTED_DATE(v_LOCAL_DATE,p_DAY_TYPE,'YY',c_DATE_YYYY_MM_DD,c_TIME_YYYY_MM_DD,c_WEEKDAY_YYYY_MM_DD,c_WEEKEND_YYYY_MM_DD,0),
			GET_HOURLY_FORMATTED_DATE(GET_FISCAL_YEAR_DATE(v_LOCAL_DATE - g_SECOND) + g_SECOND,p_DAY_TYPE,'YY',c_DATE_YYYY_MM_DD,c_TIME_YYYY_MM_DD,c_WEEKDAY_YYYY_MM_DD,c_WEEKEND_YYYY_MM_DD,0),
			GET_HOURLY_FORMATTED_DATE(v_LOCAL_DATE,p_DAY_TYPE,'MI15',p_DATE_CUSTOM_FORMAT,p_TIME_CUSTOM_FORMAT,p_WEEKDAY_CUSTOM_FORMAT,p_WEEKEND_CUSTOM_FORMAT,0),
			GET_HOURLY_FORMATTED_DATE(v_LOCAL_DATE,p_DAY_TYPE,'HH',p_DATE_CUSTOM_FORMAT,p_TIME_CUSTOM_FORMAT,p_WEEKDAY_CUSTOM_FORMAT,p_WEEKEND_CUSTOM_FORMAT,0),
			GET_HOURLY_FORMATTED_DATE(v_LOCAL_DATE,p_DAY_TYPE,'DD',p_DATE_CUSTOM_FORMAT,p_TIME_CUSTOM_FORMAT,p_WEEKDAY_CUSTOM_FORMAT,p_WEEKEND_CUSTOM_FORMAT,0),
			GET_HOURLY_FORMATTED_DATE(v_LOCAL_DATE,p_DAY_TYPE,'DY',p_DATE_CUSTOM_FORMAT,p_TIME_CUSTOM_FORMAT,p_WEEKDAY_CUSTOM_FORMAT,p_WEEKEND_CUSTOM_FORMAT,0),
			GET_HOURLY_FORMATTED_DATE(v_LOCAL_DATE,p_DAY_TYPE,'MM',p_DATE_CUSTOM_FORMAT,p_TIME_CUSTOM_FORMAT,p_WEEKDAY_CUSTOM_FORMAT,p_WEEKEND_CUSTOM_FORMAT,0),
			GET_HOURLY_FORMATTED_DATE(v_LOCAL_DATE,p_DAY_TYPE,'Q',p_DATE_CUSTOM_FORMAT,p_TIME_CUSTOM_FORMAT,p_WEEKDAY_CUSTOM_FORMAT,p_WEEKEND_CUSTOM_FORMAT,0),
			GET_HOURLY_FORMATTED_DATE(v_LOCAL_DATE,p_DAY_TYPE,'YY',p_DATE_CUSTOM_FORMAT,p_TIME_CUSTOM_FORMAT,p_WEEKDAY_CUSTOM_FORMAT,p_WEEKEND_CUSTOM_FORMAT,0),
			GET_HOURLY_FORMATTED_DATE(GET_FISCAL_YEAR_DATE(v_LOCAL_DATE - g_SECOND) + g_SECOND,p_DAY_TYPE,'YY',p_DATE_CUSTOM_FORMAT,p_TIME_CUSTOM_FORMAT,p_WEEKDAY_CUSTOM_FORMAT,p_WEEKEND_CUSTOM_FORMAT,0),
			v_IS_IN_DST_RANGE,				-- IS_IN_DST_RANGE
			v_IS_DST_SPRING_AHEAD_HOUR,		-- IS_DST_SPRING_AHEAD_HOUR
			v_IS_DST_SPRING_AHEAD_DAY,		-- IS_DST_SPRING_AHEAD_DAY
			v_IS_DST_FALL_BACK_HOUR,		-- IS_DST_FALL_BACK_HOUR
			v_IS_DST_FALL_BACK_DAY,			-- IS_DST_FALL_BACK_DAY
			IS_DAY_INTERVAL_OF_TYPE(-11, v_LOCAL_DATE, v_IS_HOLIDAY)	-- IS_ON_PEAK
			);

	END ADD_HOURLY_ROW;


	-- -------------------------------------------------------

	PROCEDURE ADD_DAILY_ROW
		(
		p_DAY_TYPE IN CHAR,
		p_DATE IN DATE
		) IS

		v_LOCAL_DATE DATE;
		v_FISCAL_YEAR_DATE DATE;

		--==========================================
		--	INNER INNER PROCEDURE
		--==========================================
		FUNCTION GET_DAILY_FORMATTED_DATE
			(
			p_DATE IN DATE,
			p_DAY_TYPE IN CHAR,
			p_INTERVAL IN VARCHAR2,
			p_DATE_FORMAT IN VARCHAR2,
			p_WEEKDAY_ABBR IN VARCHAR2,
			p_WEEKEND_ABBR IN VARCHAR2,
			p_IS_FOR_SORT IN NUMBER
			) RETURN VARCHAR2 IS
			v_DATE_STRING VARCHAR2(32);
		BEGIN

			v_DATE_STRING := TO_CHAR(TRUNC(p_DATE, p_INTERVAL),p_DATE_FORMAT);

			RETURN v_DATE_STRING;
		END GET_DAILY_FORMATTED_DATE;


	BEGIN -- ADD_DAILY_ROW
		v_LOCAL_DATE := p_DATE;
		v_FISCAL_YEAR_DATE := GET_FISCAL_YEAR_DATE(p_DATE);
		INSERT_SYSTEM_DATE_TIME(p_LOCAL_TIME_ZONE, -- TIME_ZONE
			g_DATA_DAILY, 				-- DATA_INTERVAL_TYPE
			g_DAYTYPE_STANDARD, 			-- DAY_TYPE
			v_LOCAL_DATE, -- CUT_DATE
			v_LOCAL_DATE, -- LOCAL_DATE
			v_LOCAL_DATE, -- STANDARD_DATE
			v_LOCAL_DATE + 1/86400,	-- CUT_DATE_SCHEDULING
			GET_MINIMUM_INTERVAL_NUMBER(v_LOCAL_DATE),	--MINIMUM_INTERVAL_NUMBER
			TO_NUMBER(TO_CHAR(p_DATE,'MI')), 	-- CUT_MINUTE
			TO_NUMBER(TO_CHAR(p_DATE,'HH24')), 	-- CUT_HOUR
			TO_NUMBER(TO_CHAR(p_DATE,'D')), 	-- CUT_DAY_IN_WEEK
			TO_CHAR(p_DATE,'DY'), 				-- CUT_DAY_ABBR
			TO_NUMBER(TO_CHAR(p_DATE,'DD')), 	-- CUT_DAY_IN_MONTH
			TO_NUMBER(TO_CHAR(p_DATE,'WW')), 	-- CUT_WEEK
			TO_NUMBER(TO_CHAR(p_DATE,'MM')), 	-- CUT_MONTH
			TO_NUMBER(TO_CHAR(p_DATE,'Q')), 	-- CUT_QUARTER
			TO_NUMBER(TO_CHAR(p_DATE,'YYYY')), 	-- CUT_YEAR
			TO_NUMBER(TO_CHAR(v_FISCAL_YEAR_DATE,'YYYY')), 	-- CUT_FISCAL_YEAR
			TRUNC(v_LOCAL_DATE, 'HH'), -- LOCAL_HOUR_TRUNC_DATE
			TRUNC(v_LOCAL_DATE, 'DD'), -- LOCAL_DAY_TRUNC_DATE
			TRUNC(v_LOCAL_DATE, 'DY'), -- LOCAL_WEEK_TRUNC_DATE
			TRUNC(v_LOCAL_DATE, 'MM'), -- LOCAL_MONTH_TRUNC_DATE
			TRUNC(v_LOCAL_DATE, 'Q'),  -- LOCAL_QUARTER_TRUNC_DATE
			TRUNC(v_LOCAL_DATE, 'YY'), -- LOCAL_YEAR_TRUNC_DATE
			TRUNC(v_FISCAL_YEAR_DATE, 'YY'), -- LOCAL_FISCAL_YEAR_TRUNC_DATE
			GET_DAILY_FORMATTED_DATE(p_DATE,p_DAY_TYPE,'DD',c_DATE_YYYY_MM_DD,c_WEEKDAY_YYYY_MM_DD,c_WEEKEND_YYYY_MM_DD,0),
			GET_DAILY_FORMATTED_DATE(p_DATE,p_DAY_TYPE,'DD',c_DATE_YYYY_MM_DD,c_WEEKDAY_YYYY_MM_DD,c_WEEKEND_YYYY_MM_DD,0),
			GET_DAILY_FORMATTED_DATE(p_DATE,p_DAY_TYPE,'DD',c_DATE_YYYY_MM_DD,c_WEEKDAY_YYYY_MM_DD,c_WEEKEND_YYYY_MM_DD,0),
			GET_DAILY_FORMATTED_DATE(p_DATE,p_DAY_TYPE,'DY',c_DATE_YYYY_MM_DD,c_WEEKDAY_YYYY_MM_DD,c_WEEKEND_YYYY_MM_DD,0),
			GET_DAILY_FORMATTED_DATE(p_DATE,p_DAY_TYPE,'MM',c_DATE_YYYY_MM_DD,c_WEEKDAY_YYYY_MM_DD,c_WEEKEND_YYYY_MM_DD,0),
			GET_DAILY_FORMATTED_DATE(p_DATE,p_DAY_TYPE,'Q',c_DATE_YYYY_MM_DD,c_WEEKDAY_YYYY_MM_DD,c_WEEKEND_YYYY_MM_DD,0),
			GET_DAILY_FORMATTED_DATE(p_DATE,p_DAY_TYPE,'YY',c_DATE_YYYY_MM_DD,c_WEEKDAY_YYYY_MM_DD,c_WEEKEND_YYYY_MM_DD,0),
			GET_DAILY_FORMATTED_DATE(v_FISCAL_YEAR_DATE,p_DAY_TYPE,'YY',c_DATE_YYYY_MM_DD,c_WEEKDAY_YYYY_MM_DD,c_WEEKEND_YYYY_MM_DD,0),
			GET_DAILY_FORMATTED_DATE(p_DATE,p_DAY_TYPE,'DD',p_DATE_CUSTOM_FORMAT,p_WEEKDAY_CUSTOM_FORMAT,p_WEEKEND_CUSTOM_FORMAT,0),
			GET_DAILY_FORMATTED_DATE(p_DATE,p_DAY_TYPE,'DD',p_DATE_CUSTOM_FORMAT,p_WEEKDAY_CUSTOM_FORMAT,p_WEEKEND_CUSTOM_FORMAT,0),
			GET_DAILY_FORMATTED_DATE(p_DATE,p_DAY_TYPE,'DD',p_DATE_CUSTOM_FORMAT,p_WEEKDAY_CUSTOM_FORMAT,p_WEEKEND_CUSTOM_FORMAT,0),
			GET_DAILY_FORMATTED_DATE(p_DATE,p_DAY_TYPE,'DY',p_DATE_CUSTOM_FORMAT,p_WEEKDAY_CUSTOM_FORMAT,p_WEEKEND_CUSTOM_FORMAT,0),
			GET_DAILY_FORMATTED_DATE(p_DATE,p_DAY_TYPE,'MM',p_DATE_CUSTOM_FORMAT,p_WEEKDAY_CUSTOM_FORMAT,p_WEEKEND_CUSTOM_FORMAT,0),
			GET_DAILY_FORMATTED_DATE(p_DATE,p_DAY_TYPE,'Q',p_DATE_CUSTOM_FORMAT,p_WEEKDAY_CUSTOM_FORMAT,p_WEEKEND_CUSTOM_FORMAT,0),
			GET_DAILY_FORMATTED_DATE(p_DATE,p_DAY_TYPE,'YY',p_DATE_CUSTOM_FORMAT,p_WEEKDAY_CUSTOM_FORMAT,p_WEEKEND_CUSTOM_FORMAT,0),
			GET_DAILY_FORMATTED_DATE(v_FISCAL_YEAR_DATE,p_DAY_TYPE,'YY',p_DATE_CUSTOM_FORMAT,p_WEEKDAY_CUSTOM_FORMAT,p_WEEKEND_CUSTOM_FORMAT,0),
			0,		-- IS_IN_DST_RANGE
			0,		-- IS_DST_SPRING_AHEAD_DAY
			0,		-- IS_DST_SPRING_AHEAD_HOUR
			0,		-- IS_DST_FALL_BACK_DAY
			0,		-- IS_DST_FALL_BACK_HOUR
			0		-- IS_ON_PEAK
			);

	END ADD_DAILY_ROW;

	-- -------------------------------------------------------

	PROCEDURE ADD_SCENARIO_MULTIPLIERS
		(
		p_SCENARIO_ROLLUP_TYPE IN NUMBER,
		p_DATE IN DATE
		) IS
		v_WEEKDAY_MULTIPLIER SYSTEM_DATE_TIME_SCENARIO.SCENARIO_MULTIPLIER%TYPE;
		v_WEEKEND_MULTIPLIER SYSTEM_DATE_TIME_SCENARIO.SCENARIO_MULTIPLIER%TYPE;
		--==========================================
		--	INNER INNER PROCEDURE
		--==========================================
		PROCEDURE INSERT_SYSTEM_DATE_TIME_SCEN
			(
			p_DAY_TYPE IN CHAR,
			p_ROLLUP_DATE IN DATE,
			p_SCENARIO_ROLLUP_TYPE IN NUMBER,
			p_SCENARIO_MULTIPLIER IN NUMBER
			) IS
		BEGIN
			INSERT INTO SYSTEM_DATE_TIME_SCENARIO(DAY_TYPE, ROLLUP_DATE, SCENARIO_ROLLUP_TYPE, SCENARIO_MULTIPLIER)
			VALUES(p_DAY_TYPE, p_ROLLUP_DATE, p_SCENARIO_ROLLUP_TYPE, p_SCENARIO_MULTIPLIER);
		END INSERT_SYSTEM_DATE_TIME_SCEN;
	BEGIN


		--HOURLY OR DAILY MODE.  JUST MULTIPLY BY 1 FOR JOINS.
		IF p_SCENARIO_ROLLUP_TYPE IN (g_ROLLUP_HOURLY, g_ROLLUP_DAILY) THEN
			INSERT_SYSTEM_DATE_TIME_SCEN(g_DAYTYPE_STANDARD, p_DATE, p_SCENARIO_ROLLUP_TYPE, 1);
		ELSE
			--WEEKLY MODE.  NOT SURE WHAT TO MULTIPLY BY FOR NOW. NEEDS TO BE FIXED LATER.
			IF p_SCENARIO_ROLLUP_TYPE = g_ROLLUP_WEEKLY THEN
				v_WEEKDAY_MULTIPLIER := 0;
				v_WEEKEND_MULTIPLIER := 0;
			--MONTHLY MODE.  MULTIPLY BY NUMBER OF DAYTYPE IN MONTH.
			ELSIF p_SCENARIO_ROLLUP_TYPE = g_ROLLUP_MONTHLY THEN
				v_WEEKDAY_MULTIPLIER := WEEK_DAYS_IN_RANGE(p_DATE, LAST_DAY(p_DATE));
				v_WEEKEND_MULTIPLIER := LAST_DAY(p_DATE) - p_DATE - v_WEEKDAY_MULTIPLIER + 1;
			END IF;

			INSERT_SYSTEM_DATE_TIME_SCEN(g_DAYTYPE_WEEKDAY, p_DATE, p_SCENARIO_ROLLUP_TYPE, v_WEEKDAY_MULTIPLIER);
			INSERT_SYSTEM_DATE_TIME_SCEN(g_DAYTYPE_WEEKEND, p_DATE, p_SCENARIO_ROLLUP_TYPE, v_WEEKEND_MULTIPLIER);
		END IF;

	END ADD_SCENARIO_MULTIPLIERS;

BEGIN --MAIN------------------------------------------------------------------------

	--REMOVE EXISTING VALUES
	DELETE SYSTEM_DATE_TIME
	WHERE TIME_ZONE = p_LOCAL_TIME_ZONE
		AND CUT_YEAR BETWEEN p_BEGIN_YEAR AND p_END_YEAR;

	DELETE SYSTEM_DATE_TIME_SCENARIO
	WHERE ROLLUP_DATE BETWEEN TO_DATE('1-JAN-' || TO_CHAR(p_BEGIN_YEAR)) AND TO_DATE('1-JAN-' || TO_CHAR(p_END_YEAR + 1));


	--HOURLY AND SUBHOURLY DATA INTERVALS
	v_CUR_DATE := ADVANCE_DATE(TO_DATE('1-JAN-' || TO_CHAR(p_BEGIN_YEAR)), p_MINIMUM_INTERVAL);
	WHILE v_CUR_DATE <= TO_DATE('1-JAN-' || TO_CHAR(p_END_YEAR + 1)) LOOP

		--STANDARD DAYTYPE ALL HOURS
		ADD_HOURLY_ROW(g_DAYTYPE_STANDARD, v_CUR_DATE);

		--WEEKDAY AND WEEKEND ARE ONLY USED FOR FIRST DAY OF MONTH OR WEEK.
		IF TRUNC(v_CUR_DATE,'DY') = TRUNC(v_CUR_DATE - g_SECOND) OR TRUNC(v_CUR_DATE,'MM') = TRUNC(v_CUR_DATE - g_SECOND) THEN
			ADD_HOURLY_ROW(g_DAYTYPE_WEEKDAY, v_CUR_DATE);
			ADD_HOURLY_ROW(g_DAYTYPE_WEEKEND, v_CUR_DATE);

			--ADD MULTIPLIERS ONLY AT THE DAY LEVEL
			IF TRUNC(v_CUR_DATE) = v_CUR_DATE THEN
				--ADD WEEK-MODE SCENARIO MULTIPLIERS FOR FIRST DAY OF WEEK.
				IF TRUNC(v_CUR_DATE,'DY') = TRUNC(v_CUR_DATE - g_SECOND) THEN
					ADD_SCENARIO_MULTIPLIERS(g_ROLLUP_WEEKLY, v_CUR_DATE - 1);
				END IF;
				--ADD MONTH-MODE SCENARIO MULTIPLIERS FOR FIRST DAY OF MONTH.
				IF TRUNC(v_CUR_DATE,'MM') = TRUNC(v_CUR_DATE - g_SECOND) THEN
					ADD_SCENARIO_MULTIPLIERS(g_ROLLUP_MONTHLY, v_CUR_DATE -1);
				END IF;
			END IF;
		END IF;

		IF TRUNC(v_CUR_DATE) = v_CUR_DATE AND v_CUR_DATE <= TO_DATE('1-JAN-' || TO_CHAR(p_END_YEAR + 1)) THEN
			--ADD HOUR-MODE SCENARIO MULTIPLIERS FOR EVERY DAY.
			ADD_SCENARIO_MULTIPLIERS(g_ROLLUP_HOURLY, v_CUR_DATE - 1);
			ADD_SCENARIO_MULTIPLIERS(g_ROLLUP_DAILY, v_CUR_DATE - 1);

			--ADD DAILY DATA
			ADD_DAILY_ROW(g_DAYTYPE_STANDARD, v_CUR_DATE - 1);
		END IF;

		v_CUR_DATE := ADVANCE_DATE(v_CUR_DATE, p_MINIMUM_INTERVAL);
	END LOOP;
	
END POPULATE_SYSTEM_DATE_TIME;

-- -------------------------------------------------------

PROCEDURE POPULATE_FOR_TIME_ZONE
	(
	p_LOCAL_TIME_ZONE IN VARCHAR2,
	p_MIN_INTERVAL IN VARCHAR2,
	p_BEGIN_YEAR IN NUMBER,
	p_END_YEAR IN NUMBER
	) AS
v_YR BINARY_INTEGER;
BEGIN
	FOR v_YR IN p_BEGIN_YEAR..p_END_YEAR LOOP
		POPULATE_SYSTEM_DATE_TIME(p_LOCAL_TIME_ZONE, CUT_TIME_ZONE, p_MIN_INTERVAL, v_YR, v_YR);
		-- do commits after every year to prevent undo buffer from getting too big
		COMMIT;
	END LOOP;
END POPULATE_FOR_TIME_ZONE;

-- -------------------------------------------------------

PROCEDURE POPULATE
	(
	p_TIME_ZONEs IN VARCHAR2 := LOCAL_TIME_ZONE,
	p_MIN_INTERVAL IN VARCHAR2 := 'HH',
	p_BEGIN_YEAR IN NUMBER := 2000,
	p_END_YEAR IN NUMBER := 2020
	) AS
v_TZs GA.STRING_TABLE;
v_IDX BINARY_INTEGER;
BEGIN
	UT.TOKENS_FROM_STRING(p_TIME_ZONEs, ',', v_TZs);
	v_IDX := v_TZs.FIRST;
	WHILE v_TZs.EXISTS(v_IDX) LOOP
		POPULATE_FOR_TIME_ZONE (v_TZs(v_IDX), p_MIN_INTERVAL, p_BEGIN_YEAR, p_END_YEAR);
		v_IDX := v_TZs.NEXT(v_IDX);
	END LOOP;
END POPULATE;

---------MAIN CALL TO PROCEDURE-------------------------------------------------
BEGIN
-- no parameters will populate just local time zone from 2000 to 2020 for hour interval
--	POPULATE();
-- to override, pass comma-separated list of time zones, interval, and begin and end years:

-- sample arguments
POPULATE('EDT', 'MI30', 2006, 2010);

 --POPULATE('&1', '&2', &3, &4);
	--COMMIT;
END;
/