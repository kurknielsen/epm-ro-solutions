CREATE OR REPLACE PACKAGE BODY MM_PJM_EMKT IS

	g_RVW_STATUS_ACCEPTED CONSTANT VARCHAR2(16) := 'Accepted';
	g_SUBMIT_STATUS_PENDING CONSTANT VARCHAR2(16) := 'Pending';
	g_MKT_STATUS_PENDING CONSTANT VARCHAR2(16) := 'Pending';

	TYPE t_ARRAY IS VARRAY(100) OF VARCHAR2(32);
	l_MKT_RESULTS_RESOURCE_TYPES t_ARRAY := t_ARRAY('Generation', 'Demand',
														'Virtual', 'LoadResponse');
	l_MKT_PRICE_RESOURCE_TYPES   t_ARRAY := t_ARRAY('Generation', 'Demand',
														'LoadResponse');

    -- used by MARKET_EXCHANGE, 'QUERY MESSAGES'
    g_MARKET_MESSAGE_ALERT VARCHAR2(256) := 'Market Message';

	-- initialized in package init code
	g_EMKT_GEN_ATTR ENTITY_ATTRIBUTE.ATTRIBUTE_ID%TYPE;
	g_EMKT_LOAD_ATTR ENTITY_ATTRIBUTE.ATTRIBUTE_ID%TYPE;

---------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
     RETURN '$Revision: 1.3 $';
END WHAT_VERSION;
---------------------------------------------------------------------------------------------------
FUNCTION PACKAGE_NAME RETURN VARCHAR IS
BEGIN
     RETURN 'MM_PJM_EMKT';
END PACKAGE_NAME;
---------------------------------------------------------------------------------------------------
FUNCTION GET_TRAIT_GROUP_ID
	(
	p_TRAIT_GROUP_NAME IN VARCHAR2
	) RETURN NUMBER IS
	l_TRAIT_ID NUMBER;
BEGIN

	SELECT A.TRAIT_GROUP_ID
	INTO l_TRAIT_ID
	FROM TRANSACTION_TRAIT_GROUP A
	WHERE A.TRAIT_GROUP_NAME = p_TRAIT_GROUP_NAME;

	RETURN l_TRAIT_ID;
END GET_TRAIT_GROUP_ID;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_TRAIT_VALUE
	(
	p_DATE IN DATE,
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_TRAIT_VALUE IN VARCHAR2,
	p_TRAIT_NAME IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_ERROR_MESSAGE OUT VARCHAR2
	) AS
	l_TRAIT_ID NUMBER(9);
BEGIN
	p_STATUS := GA.SUCCESS;

	l_TRAIT_ID := GET_TRAIT_GROUP_ID('PJM ' || p_TRAIT_NAME);
	TG.PUT_IT_TRAIT_SCHEDULE(p_TRANSACTION_ID, p_SCHEDULE_STATE, 0, p_DATE, l_TRAIT_ID, 1, 1, p_TRAIT_VALUE, CUT_TIME_ZONE);

END PUT_TRAIT_VALUE;
-------------------------------------------------------------------------------------
FUNCTION GET_RESOURCE_FOR_LOC
   (
   p_LOCATION_NAME IN VARCHAR2
   ) RETURN SUPPLY_RESOURCE%ROWTYPE IS
   l_SERVICE_POINT_ID NUMBER(9);
   v_RESOURCE SUPPLY_RESOURCE%ROWTYPE;
  BEGIN

  	SELECT A.* INTO v_RESOURCE
           FROM SUPPLY_RESOURCE A,
                SERVICE_POINT B
           WHERE B.EXTERNAL_IDENTIFIER=p_LOCATION_NAME
                 AND A.SERVICE_POINT_ID=B.SERVICE_POINT_ID;

   RETURN v_RESOURCE;

  -- IF THE RESOURCE DOES NOT EXIST THEN CREATE A NEW WITH THE SAME NAME AS THE SERVICE POINT
   EXCEPTION
   WHEN NO_DATA_FOUND THEN
        l_SERVICE_POINT_ID := MM_PJM_UTIL.ID_FOR_SERVICE_POINT_PNODE(p_LOCATION_NAME);
        SELECT SERVICE_POINT_NAME INTO v_RESOURCE.RESOURCE_NAME
               FROM SERVICE_POINT
               WHERE SERVICE_POINT.SERVICE_POINT_ID=l_SERVICE_POINT_ID;

        IO.PUT_SUPPLY_RESOURCE(v_RESOURCE.RESOURCE_ID,
                        v_RESOURCE.RESOURCE_NAME,
                        v_RESOURCE.RESOURCE_NAME,
                        v_RESOURCE.RESOURCE_NAME,
                        0,
                        0,
                        l_SERVICE_POINT_ID,
                        0);

        SELECT * INTO v_RESOURCE
               FROM SUPPLY_RESOURCE A
               WHERE A.RESOURCE_ID=v_RESOURCE.RESOURCE_ID;

         RETURN v_RESOURCE;

  END GET_RESOURCE_FOR_LOC;
---------------------------------------------------------------------------------------------------
FUNCTION GET_MARKET_PRICE_ID
    (
    p_MARKET_PRICE_NAME IN VARCHAR2,
    p_EXT_ID IN VARCHAR2 := NULL,
    p_COMMODITY_ID IN NUMBER := 0
    ) RETURN NUMBER IS
	v_MARKET_PRICE_ID NUMBER(9);
    v_EXT_ID VARCHAR2(64);
BEGIN
	ID.ID_FOR_MARKET_PRICE(p_MARKET_PRICE_NAME, FALSE, v_MARKET_PRICE_ID);
    IF p_EXT_ID IS NULL THEN
        v_EXT_ID := p_MARKET_PRICE_NAME;
    ELSE
        v_EXT_ID := p_EXT_ID;
    END IF;

	IF v_MARKET_PRICE_ID < 0 THEN
		IO.PUT_MARKET_PRICE(v_MARKET_PRICE_ID, p_MARKET_PRICE_NAME, SUBSTR(p_MARKET_PRICE_NAME,32), 'Generated by PJM Import', 0,
				'Market Clearing Price', 'Hour', '?', p_COMMODITY_ID, '?', v_EXT_ID, 0, EI.GET_ID_FROM_IDENTIFIER_EXTSYS('PJM', EC.ED_SC, EC.ES_PJM), 0, 0);
	END IF;

	RETURN v_MARKET_PRICE_ID;
END GET_MARKET_PRICE_ID;
---------------------------------------------------------------------------------------------------
FUNCTION GET_EXT_ID_FOR_SERVICE_POINT(p_SERVICE_POINT_ID IN NUMBER) RETURN VARCHAR2 IS
		v_LOCATION_NAME SERVICE_POINT.EXTERNAL_IDENTIFIER%TYPE;
BEGIN
		SELECT EXTERNAL_IDENTIFIER
			INTO v_LOCATION_NAME
			FROM SERVICE_POINT
		 WHERE SERVICE_POINT_ID = p_SERVICE_POINT_ID;

		RETURN v_LOCATION_NAME;
END GET_EXT_ID_FOR_SERVICE_POINT;
-------------------------------------------------------------------------------------
FUNCTION GET_EXT_ID_FOR_RESOURCE_NAME(p_RESOURCE_NAME IN NUMBER)
		RETURN VARCHAR2 IS
		v_EXT_ID SERVICE_POINT.EXTERNAL_IDENTIFIER%TYPE;
	BEGIN
		SELECT S.EXTERNAL_IDENTIFIER
			INTO v_EXT_ID
			FROM SERVICE_POINT S, SUPPLY_RESOURCE R
		 WHERE R.RESOURCE_NAME = p_RESOURCE_NAME
			 AND R.SERVICE_POINT_ID = S.SERVICE_POINT_ID;

		RETURN v_EXT_ID;
END GET_EXT_ID_FOR_RESOURCE_NAME;
-------------------------------------------------------------------------------------
FUNCTION GET_EXT_ID_FOR_TRANSACTION(p_TRANSACTION_ID IN NUMBER) RETURN VARCHAR2 IS
		v_LOCATION_NAME VARCHAR2(128);
BEGIN
    IF p_TRANSACTION_ID IS NULL THEN
      RETURN NULL;
    END IF;

		SELECT SP.EXTERNAL_IDENTIFIER
			INTO v_LOCATION_NAME
			FROM INTERCHANGE_TRANSACTION IT, SUPPLY_RESOURCE SR, SERVICE_POINT SP
		 WHERE IT.TRANSACTION_ID = p_TRANSACTION_ID AND
					 IT.RESOURCE_ID = SR.RESOURCE_ID AND
					 SP.SERVICE_POINT_ID = SR.SERVICE_POINT_ID;

		RETURN v_LOCATION_NAME;
EXCEPTION WHEN NO_DATA_FOUND THEN
    RETURN NULL;
END GET_EXT_ID_FOR_TRANSACTION;
-------------------------------------------------------------------------------------
FUNCTION GET_PORTFOLIO_EXT_ID(p_PORTFOLIO_ID IN NUMBER) RETURN VARCHAR2 IS
		v_PORTFOLIO_NAME VARCHAR2(128);
BEGIN
		SELECT PORTFOLIO_NAME
			INTO v_PORTFOLIO_NAME
			FROM PORTFOLIO
		 WHERE PORTFOLIO_ID = p_PORTFOLIO_ID;

		RETURN v_PORTFOLIO_NAME;
END GET_PORTFOLIO_EXT_ID;
-------------------------------------------------------------------------------------
FUNCTION GET_EXT_ID_FOR_TEMPLATE_NAME(p_TEMPLATE_NAME IN VARCHAR2)
		RETURN VARCHAR2 IS
BEGIN
		RETURN SUBSTR(p_TEMPLATE_NAME, 1, INSTR(p_TEMPLATE_NAME, ' ', -1));
END GET_EXT_ID_FOR_TEMPLATE_NAME;
-------------------------------------------------------------------------------------
FUNCTION GET_SCHEDULE_FOR_TEMPLATE_NAME(p_TEMPLATE_NAME IN VARCHAR2)
		RETURN VARCHAR2 IS
BEGIN
		RETURN SUBSTR(p_TEMPLATE_NAME, INSTR(p_TEMPLATE_NAME, ' ', -1));
END GET_SCHEDULE_FOR_TEMPLATE_NAME;
-------------------------------------------------------------------------------------
PROCEDURE PJM_PNODES_RPT
	(
	p_MODEL_ID      IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE    IN DATE,
	p_END_DATE      IN DATE,
	p_AS_OF_DATE    IN DATE,
	p_TIME_ZONE     IN VARCHAR2,
	p_NOTUSED_ID1   IN NUMBER,
	p_NOTUSED_ID2   IN NUMBER,
	p_NOTUSED_ID3   IN NUMBER,
	p_REPORT_NAME   IN VARCHAR2,
	p_NODE_TYPE     IN VARCHAR2,
	p_STATUS        OUT NUMBER,
	p_CURSOR        IN OUT REF_CURSOR
	) IS
BEGIN
	p_STATUS := GA.SUCCESS;

  	OPEN p_CURSOR FOR
  		SELECT 0 DUMMY, 0 ADD_SVC_POINT, P.NODENAME, P.NODETYPE, P.PNODEID
  			FROM PJM_EMKT_PNODES P
  		 WHERE P.PNODEID NOT IN
  					 (SELECT PNODEID
  							FROM PJM_EMKT_PNODES, SERVICE_POINT
  						 WHERE TO_CHAR(PJM_EMKT_PNODES.PNODEID) = SERVICE_POINT.EXTERNAL_IDENTIFIER)
  		 AND (UPPER(P.NODETYPE) = UPPER(p_NODE_TYPE) OR p_NODE_TYPE = '<All>')
  		 ORDER BY P.NODETYPE, P.NODENAME;
END PJM_PNODES_RPT;
------------------------------------------------------------------------------------
PROCEDURE PUT_PJM_PNODES_RPT
	(
	p_NODENAME IN VARCHAR2,
	p_NODETYPE IN VARCHAR2,
	p_PNODEID IN VARCHAR2,
	p_ADD_SVC_POINT IN NUMBER,
	p_STATUS OUT NUMBER
	) IS
	v_SERVICE_POINT_ID SERVICE_POINT.SERVICE_POINT_ID%TYPE;
BEGIN
	p_STATUS := GA.SUCCESS;
	IF p_ADD_SVC_POINT = 1 THEN
		v_SERVICE_POINT_ID := MM_PJM_UTIL.CREATE_SERVICE_POINT(p_NODENAME || ' (PJM)', TO_CHAR(ROUND(TO_NUMBER(p_PNODEID), 0)), p_NODETYPE);
	END IF;

END PUT_PJM_PNODES_RPT;
-------------------------------------------------------------------------------------
PROCEDURE GEN_NAMES_RPT
	(
	p_STATUS        OUT NUMBER,
	p_CURSOR        IN OUT REF_CURSOR
	) IS
	v_ATTRIBUTE_ID NUMBER(9);
BEGIN
	p_STATUS := GA.SUCCESS;
	ID.ID_FOR_ENTITY_ATTRIBUTE('PJM_PNODEID', EC.ED_SUPPLY_RESOURCE, 'String', FALSE, v_ATTRIBUTE_ID);
	IF v_ATTRIBUTE_ID > 0 THEN
  	OPEN p_CURSOR FOR
  		SELECT RESOURCE_ID, RESOURCE_NAME, B.ATTRIBUTE_VAL PJM_CID, S.SERVICE_POINT_ID FROM
		SUPPLY_RESOURCE A, TEMPORAL_ENTITY_ATTRIBUTE B, SERVICE_POINT S
		WHERE B.OWNER_ENTITY_ID = A.RESOURCE_ID
		AND B.ATTRIBUTE_ID = v_ATTRIBUTE_ID
		AND NVL(A.SERVICE_POINT_ID, 0) = S.SERVICE_POINT_ID
		ORDER BY RESOURCE_NAME;
	ELSE
		OPEN p_CURSOR FOR
			SELECT NULL FROM DUAL;
	END IF;
END GEN_NAMES_RPT;
------------------------------------------------------------------------------------
PROCEDURE PUT_GEN_NAMES_RPT
	(
	p_RESOURCE_ID IN VARCHAR2,
	p_RESOURCE_NAME IN VARCHAR2,
	p_PJM_CID IN VARCHAR2,
	p_SERVICE_POINT_ID IN VARCHAR2,
	p_OLD_RESOURCE_ID IN VARCHAR2,
	p_OLD_RESOURCE_NAME IN VARCHAR2,
	p_OLD_PJM_CID IN VARCHAR2,
	p_OLD_SERVICE_POINT_ID IN VARCHAR2,
	p_STATUS OUT NUMBER
	) IS
BEGIN
	p_STATUS := GA.SUCCESS;
	BEGIN
		UPDATE SUPPLY_RESOURCE SET RESOURCE_NAME=p_RESOURCE_NAME WHERE RESOURCE_NAME=p_OLD_RESOURCE_NAME;
		UPDATE SUPPLY_RESOURCE SET SERVICE_POINT_ID = p_SERVICE_POINT_ID WHERE RESOURCE_ID=p_RESOURCE_ID;
	EXCEPTION WHEN OTHERS THEN
		p_STATUS := SQLCODE;
	END;
END PUT_GEN_NAMES_RPT;
-------------------------------------------------------------------------------------
PROCEDURE IMPORT_NODE_LIST(v_RECORDS       IN MEX_PJM_EMKT_NODE_TBL,
						p_IS_BID_NODE_LIST IN BOOLEAN,
						 P_STATUS        OUT NUMBER,
						 P_ERROR_MESSAGE OUT VARCHAR2) AS
	v_IDX      BINARY_INTEGER;
	v_PNODE_ID PJM_EMKT_PNODES.PNODEID%TYPE;
    v_ZONE_ID SERVICE_POINT.SERVICE_POINT_ID%TYPE;
	v_ID NUMBER(9);
BEGIN
	p_STATUS := GA.SUCCESS;
	v_IDX    := v_RECORDS.FIRST;
	WHILE v_RECORDS.EXISTS(v_IDX) LOOP
		MERGE INTO PJM_EMKT_PNODES P USING DUAL ON (P.PNODEID=v_RECORDS(v_IDX).PNODEID)
		WHEN MATCHED THEN
			UPDATE SET P.NODENAME=v_RECORDS(v_IDX).NODENAME
		WHEN NOT MATCHED THEN
		INSERT
			(NODENAME, NODETYPE, PNODEID, CANSUBMITFIXED, CANSUBMITPRICESENSITIVE, CANSUBMITINCREMENT, CANSUBMITDECREMENT, ZONE)
		VALUES
			(v_RECORDS(v_IDX).NODENAME, v_RECORDS(v_IDX).NODETYPE, v_RECORDS(v_IDX).PNODEID, v_RECORDS(v_IDX).CANSUBMITFIXED,
			v_RECORDS(v_IDX).CANSUBMITPRICESENSITIVE, v_RECORDS(v_IDX).CANSUBMITINCREMENT, v_RECORDS(v_IDX).CANSUBMITDECREMENT, null);

		--update service zones
		IF UPPER(v_RECORDS(v_IDX).NODETYPE) = 'ZONE' THEN
    		BEGIN
    			SELECT SERVICE_ZONE_ID INTO v_ZONE_ID
    			FROM SERVICE_ZONE WHERE SERVICE_ZONE_NAME = v_RECORDS(v_IDX).NODENAME;
    		EXCEPTION
            	WHEN NO_DATA_FOUND THEN
                IO.PUT_SERVICE_ZONE(v_ZONE_ID,
                                  v_RECORDS(v_IDX).NODENAME,
                                  v_RECORDS(v_IDX).NODENAME,
                                  'PJM Zone',
                                  0,
								  NULL,
                                  0,
								  0,
								  NULL);
            END;
      	END IF;

		-- if we're processing the bid node list, then create a service point from this node
		IF p_IS_BID_NODE_LIST THEN
			v_ID := MM_PJM_UTIL.ID_FOR_SERVICE_POINT_PNODE(TO_CHAR(v_RECORDS(v_IDX).PNODEID));
		END IF;
		v_IDX := v_RECORDS.NEXT(v_IDX);
	END LOOP;

EXCEPTION
	WHEN OTHERS THEN
		P_STATUS        := SQLCODE;
		P_ERROR_MESSAGE := PACKAGE_NAME || '.IMPORT_NODE_LIST: ' || UT.GET_FULL_ERRM;
END IMPORT_NODE_LIST;

------------------------------------------------------------------------------------

PROCEDURE QUERY_NODE_LIST
	(
	p_CRED				IN mex_credentials,
	p_BID_NODES_ONLY IN BOOLEAN,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_LOG_ONLY IN NUMBER,
	p_STATUS OUT NUMBER,
	p_ERROR_MESSAGE OUT VARCHAR2,
	p_LOGGER IN OUT	mm_logger_adapter
	) AS

	v_RECORDS   MEX_PJM_EMKT_NODE_TBL;

	v_NODE_TYPE	VARCHAR2(20);

BEGIN

	P_STATUS    := GA.SUCCESS;

	--set the PARAMETER_MAP
	IF p_BID_NODES_ONLY = TRUE THEN
		v_NODE_TYPE := 'BidNodes';
	ELSE
		v_NODE_TYPE := 'NodeList';
	END IF;

	MEX_PJM_EMKT.FETCH_NODE_LIST(p_CRED, P_LOG_ONLY, v_NODE_TYPE, p_BEGIN_DATE, p_END_DATE, V_RECORDS, P_STATUS, P_ERROR_MESSAGE, p_LOGGER);
	IF P_STATUS >= 0 THEN
		IMPORT_NODE_LIST(V_RECORDS, p_BID_NODES_ONLY, P_STATUS, P_ERROR_MESSAGE);
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		P_STATUS        := SQLCODE;
		P_ERROR_MESSAGE := PACKAGE_NAME || '.QUERY_NODE_LIST: ' || UT.GET_FULL_ERRM;

END QUERY_NODE_LIST;

-----------------------------------------------------------------------

PROCEDURE IMPORT_MARKET_RESULTS
	(
	p_ACCOUNT_NAME      IN VARCHAR2,
	p_RECORDS       IN MEX_PJM_EMKT_MKT_RESULTS_TBL,
	P_STATUS        OUT NUMBER,
	P_ERROR_MESSAGE OUT VARCHAR2) AS

	v_IDX BINARY_INTEGER;
	v_PNODE_ID VARCHAR2(32);
	v_RESOURCE_TYPE VARCHAR2(32);

	v_TXN_IDS MEX_PJM.PARAMETER_MAP;
	v_MAX_PS_BID_QTY NUMBER;
	v_SCHEDULE_DATE DATE;
	v_DEMAND_MW IT_SCHEDULE.AMOUNT%TYPE;
	v_BOS_VAL NUMBER;
	v_MESSAGE VARCHAR2(4000);
	v_PCT_OWNERSHIP NUMBER;
	v_USE_PRICE_SENS_DEMAND NUMBER(1);

	PROCEDURE GET_MKT_RESULTS_TXNS
		(
		p_ACCOUNT_NAME      IN VARCHAR2,
		p_RESOURCE_TYPE IN VARCHAR2,
		p_PNODE_ID IN VARCHAR2,
		p_PMAP OUT MEX_PJM.PARAMETER_MAP
		) IS
	BEGIN

		p_PMAP('Generation') := NULL;
		p_PMAP('Fixed') := NULL;
		p_PMAP('PriceSens') := NULL;
		p_PMAP('Inc') := NULL;
		p_PMAP('Dec') := NULL;

		IF p_RESOURCE_TYPE = 'Generation' THEN
            MM_PJM_EMKT_UTIL.GET_TRANSACTION_ID(p_ACCOUNT_NAME, p_PNODE_ID, 'Generation', MM_PJM_UTIL.g_COMM_DA_ENERGY, 0, 0, TRUE, p_PMAP('Generation'), v_MESSAGE, NULL, MM_PJM_EMKT_UTIL.g_PJM_GEN_UNIT_DATA_TXN_TYPE, NULL);
		ELSIF p_RESOURCE_TYPE = 'LoadResponse' THEN
			p_PMAP('LoadResponse') := NULL;
		ELSIF p_RESOURCE_TYPE = 'Demand' THEN
			-- get the fixed demand transaction
			MM_PJM_EMKT_UTIL.GET_TRANSACTION_ID(p_ACCOUNT_NAME, p_PNODE_ID, 'Load', MM_PJM_UTIL.g_COMM_DA_ENERGY, 0, 1, TRUE, p_PMAP('Fixed'), v_MESSAGE);

			-- now the price-sensitive demand transaction
			MM_PJM_EMKT_UTIL.GET_TRANSACTION_ID(p_ACCOUNT_NAME, p_PNODE_ID, 'Load', MM_PJM_UTIL.g_COMM_DA_ENERGY, 0, 0, TRUE, p_PMAP('PriceSens'), v_MESSAGE);
		ELSE
			-- p_RESOURCE_TYPE = 'Virtual'
			-- inc offer transaction
			MM_PJM_EMKT_UTIL.GET_TRANSACTION_ID(p_ACCOUNT_NAME, p_PNODE_ID, 'Generation', MM_PJM_UTIL.g_COMM_VIRTUAL, 0, 0, TRUE, p_PMAP('Inc'), v_MESSAGE);

			-- dec offer transaction
			MM_PJM_EMKT_UTIL.GET_TRANSACTION_ID(p_ACCOUNT_NAME, p_PNODE_ID, 'Load', MM_PJM_UTIL.g_COMM_VIRTUAL, 0, 0, TRUE, p_PMAP('Dec'), v_MESSAGE);
		END IF;

		IF LOGS.IS_DEBUG_ENABLED = TRUE THEN
			LOGS.LOG_DEBUG(TO_CHAR(SYSDATE, 'HH24:MI:SS MM/DD') || ': mkt results txns');
			LOGS.LOG_DEBUG('Generation: ' || p_pmap('Generation'));
			LOGS.LOG_DEBUG('Fixed: ' || p_pmap('Fixed'));
			LOGS.LOG_DEBUG('PriceSens: ' || p_pmap('PriceSens'));
			LOGS.LOG_DEBUG('Inc: ' || p_pmap('Inc'));
			LOGS.LOG_DEBUG('Dec: ' || p_pmap('Dec'));
		END IF;
	END GET_MKT_RESULTS_TXNS;

BEGIN
	p_STATUS := GA.SUCCESS;
	v_IDX    := p_RECORDS.FIRST;
	WHILE p_RECORDS.EXISTS(v_IDX) LOOP
		-- get the transaction for this location
		IF v_PNODE_ID IS NULL OR v_PNODE_ID <> p_RECORDS(v_IDX).LOCATION_NAME OR v_RESOURCE_TYPE <> p_RECORDS(v_IDX).RESOURCE_TYPE THEN
			v_PNODE_ID      := p_RECORDS(v_IDX).LOCATION_NAME;
			v_RESOURCE_TYPE := p_RECORDS(v_IDX).RESOURCE_TYPE;
			GET_MKT_RESULTS_TXNS(p_ACCOUNT_NAME, v_RESOURCE_TYPE, v_PNODE_ID, v_TXN_IDS);
		END IF;

		v_SCHEDULE_DATE := p_RECORDS(v_IDX).RESPONSE_DAY; -- THIS DATE HAS ALREADY BEEN ADJUSTED TO CUT.

		IF v_RESOURCE_TYPE = 'Virtual' THEN
			-- inc offer
			IF v_TXN_IDS('Inc') IS NOT NULL THEN
				MM_PJM_EMKT_UTIL.PUT_MARKET_RESULTS(v_TXN_IDS('Inc'),
													 v_SCHEDULE_DATE,
													 1,
													 p_RECORDS(v_IDX).PRICE,
													 p_RECORDS(v_IDX).INC_AMOUNT,
													 p_STATUS,
													 P_ERROR_MESSAGE);
			END IF;
			-- dec bid
			IF v_TXN_IDS('Dec') IS NOT NULL THEN
				MM_PJM_EMKT_UTIL.PUT_MARKET_RESULTS(v_TXN_IDS('Dec'),
													 v_SCHEDULE_DATE,
													 1,
													 p_RECORDS(v_IDX).PRICE,
													 p_RECORDS(v_IDX).DEC_AMOUNT,
													 p_STATUS,
													 P_ERROR_MESSAGE);
			END IF;

		ELSIF v_RESOURCE_TYPE = 'Generation' THEN
			-- Generation
			IF v_TXN_IDS('Generation') IS NOT NULL THEN
				--Get the percent ownership of the POD by the current Txn's Contract.
				v_PCT_OWNERSHIP := MM_PJM_UTIL.GET_SERVICE_POINT_OWNERSHIP(v_TXN_IDS('Generation'), v_SCHEDULE_DATE);

				--IT_SCHEDULE gets the Amount adjusted by percent ownership.
				MM_PJM_EMKT_UTIL.PUT_MARKET_RESULTS(v_TXN_IDS('Generation'), v_SCHEDULE_DATE, 1, p_RECORDS(v_IDX).PRICE, p_RECORDS(v_IDX).AMOUNT * v_PCT_OWNERSHIP / 100, p_STATUS,p_ERROR_MESSAGE);

				--Store a Trait with the original Amount before any ownership percentages.
				TG.PUT_IT_TRAIT_SCHEDULE(v_TXN_IDS('Generation'), 1, 0, v_SCHEDULE_DATE, MM_PJM_UTIL.g_TG_OUT_ACTUAL_GEN_MKT_RESULT, 1, 1, p_RECORDS(v_IDX).AMOUNT, CUT_TIME_ZONE);

				--Store a Trait with the Schedule number that PJM used.
				TG.PUT_IT_TRAIT_SCHEDULE(v_TXN_IDS('Generation'), 1, 0, v_SCHEDULE_DATE, MM_PJM_UTIL.g_TG_MR_ACTIVE_SCHEDULE, 1, 1, p_RECORDS(v_IDX).SCHEDULE_ID, CUT_TIME_ZONE);
			END IF;

        ELSIF v_RESOURCE_TYPE = 'Demand' THEN
			v_DEMAND_MW := p_RECORDS(v_IDX).AMOUNT;

			--Use a System Dictionary Flag to tell whether or not to ignore Price-Sens Demand Bids.
			v_USE_PRICE_SENS_DEMAND := NVL(GET_DICTIONARY_VALUE('Use Price-Sensitive Demand Bids', 0, 'MarketExchange', 'PJM'),0);

			IF v_USE_PRICE_SENS_DEMAND = 1 THEN
				IF v_TXN_IDS('Fixed') IS NOT NULL THEN
					BEGIN
						SELECT B.QUANTITY
							INTO v_BOS_VAL
							FROM BID_OFFER_SET B
						 WHERE B.TRANSACTION_ID = v_TXN_IDS('Fixed')
							 AND B.SCHEDULE_STATE = 1
							 AND B.SCHEDULE_DATE = v_SCHEDULE_DATE
							 AND B.SET_NUMBER = 1;
					EXCEPTION
						WHEN NO_DATA_FOUND THEN
							v_BOS_VAL := NULL;
					END;
					IF v_BOS_VAL IS NULL OR ROUND(v_BOS_VAL,1) <= v_DEMAND_MW THEN
						v_DEMAND_MW := v_DEMAND_MW - NVL(v_BOS_VAL, 0);
						MM_PJM_EMKT_UTIL.PUT_MARKET_RESULTS(v_TXN_IDS('Fixed'),
														 v_SCHEDULE_DATE,
														 1,
														 p_RECORDS(v_IDX).PRICE,
														 NVL(v_BOS_VAL, v_DEMAND_MW),
														 p_STATUS,
														 P_ERROR_MESSAGE);
			        END IF;
				END IF;
				IF v_TXN_IDS('PriceSens') IS NOT NULL THEN
					BEGIN
						SELECT B.QUANTITY
							INTO v_BOS_VAL
							FROM BID_OFFER_SET B
						 WHERE B.TRANSACTION_ID = v_TXN_IDS('PriceSens')
							 AND B.SCHEDULE_STATE = 1
							 AND B.SCHEDULE_DATE = v_SCHEDULE_DATE
							 AND B.SET_NUMBER = 1;
					EXCEPTION
						WHEN NO_DATA_FOUND THEN
							v_BOS_VAL := NULL;
					END;
			        IF v_BOS_VAL IS NULL THEN
			          -- this catches the case when only a fixed demand
			          -- bid's been submitted
			          v_DEMAND_MW := 0;
					ELSE
						-- there was a price-sensitive demand submittal: did it clear completely?
						-- post an alarm if the cleared price-sensitive demand is greater than zero
						-- but less than the maximum price-sensitive bid
						-- 22-dec-2005, jbc: alarm if cleared p/s demand is less than the max p/s bid
						--IF v_DEMAND_MW > 0 THEN

							v_MAX_PS_BID_QTY := MM_UTIL.GET_MAX_PS_DEMAND(v_TXN_IDS('PriceSens'), v_SCHEDULE_DATE);
							IF v_MAX_PS_BID_QTY > v_DEMAND_MW THEN
								MM_UTIL.POST_PART_CLEARED_DEMAND_ALERT(v_TXN_IDS('PriceSens'), v_MAX_PS_BID_QTY, v_DEMAND_MW, 'PJM');
							END IF;
						--END IF;
			        END IF;
					MM_PJM_EMKT_UTIL.PUT_MARKET_RESULTS(v_TXN_IDS('PriceSens'),
												 v_SCHEDULE_DATE,
												 1,
												 p_RECORDS(v_IDX).PRICE,
												 v_DEMAND_MW,
												 p_STATUS,
												 p_ERROR_MESSAGE);
				END IF;
			ELSE
				IF v_TXN_IDS('Fixed') IS NOT NULL THEN
					MM_PJM_EMKT_UTIL.PUT_MARKET_RESULTS(v_TXN_IDS('Fixed'),
						v_SCHEDULE_DATE,
						1,
						p_RECORDS(v_IDX).PRICE,
						v_DEMAND_MW,
						p_STATUS,
						P_ERROR_MESSAGE);
				END IF;
			END IF;

      END IF;
		v_IDX := p_RECORDS.NEXT(v_IDX);
    END LOOP;

  COMMIT;
EXCEPTION
	WHEN OTHERS THEN
		P_STATUS        := SQLCODE;
		P_ERROR_MESSAGE := PACKAGE_NAME || '.IMPORT_MARKET_RESULTS: ' || UT.GET_FULL_ERRM;
END IMPORT_MARKET_RESULTS;

------------------------------------------------------------------------------------

 PROCEDURE QUERY_MARKET_RESULTS
  	(
	p_CRED				IN mex_credentials,
	p_REQUEST_DATE  IN DATE,
	p_LOG_ONLY      IN NUMBER,
	p_STATUS        OUT NUMBER,
	p_ERROR_MESSAGE OUT VARCHAR2,
	p_LOGGER IN OUT	mm_logger_adapter
	) AS

    v_RECORDS   MEX_PJM_EMKT_MKT_RESULTS_TBL;
	v_GEN_PORTFOLIO_NAME VARCHAR2(64);
	v_EMKT_GEN  NUMBER;
	v_EMKT_LOAD NUMBER;
BEGIN

    p_STATUS    := GA.SUCCESS;

	IF MM_PJM_UTIL.HAS_ESUITE_ACCESS(g_EMKT_GEN_ATTR, p_CRED.EXTERNAL_ACCOUNT_NAME)
		OR MM_PJM_UTIL.HAS_ESUITE_ACCESS(g_EMKT_LOAD_ATTR, p_CRED.EXTERNAL_ACCOUNT_NAME) THEN

		v_GEN_PORTFOLIO_NAME := MM_PJM_EMKT_UTIL.GET_GEN_PORTFOLIO_NAME(p_CRED.EXTERNAL_ACCOUNT_NAME);

		MEX_PJM_EMKT.FETCH_MARKET_RESULTS(
			p_CRED, p_LOG_ONLY, p_REQUEST_DATE, v_EMKT_GEN, v_EMKT_LOAD,
			MEX_PJM_EMKT.g_LOC_TYPE_PORTFOLIO, v_GEN_PORTFOLIO_NAME,
			MEX_PJM_EMKT.g_LOC_TYPE_ALL, MEX_PJM_EMKT.g_LOC_TYPE_ALL,
			v_RECORDS, p_STATUS, p_ERROR_MESSAGE, p_LOGGER);

	  IF p_STATUS >= 0 THEN
		IMPORT_MARKET_RESULTS(p_CRED.EXTERNAL_ACCOUNT_NAME, v_RECORDS, p_STATUS, p_ERROR_MESSAGE);
	  END IF;
	END IF;

EXCEPTION
		WHEN OTHERS THEN
			p_STATUS        := SQLCODE;
      p_ERROR_MESSAGE := PACKAGE_NAME || '.QUERY_MARKET_RESULTS: ' ||
                         UT.GET_FULL_ERRM;
END QUERY_MARKET_RESULTS;
------------------------------------------------------------------------------------
PROCEDURE IMPORT_MARKET_RESULTS_FILE
	(
	p_CLOB IN CLOB,
	p_ISO_ACCOUNT_NAME IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR2
	) AS
    v_RECORDS MEX_PJM_EMKT_MKT_RESULTS_TBL := MEX_PJM_EMKT_MKT_RESULTS_TBL();
BEGIN
		--FOR DEBUGGING PURPOSES.
		MEX_PJM_EMKT.PARSE_MARKET_RESULTS(XMLTYPE.CREATEXML(p_CLOB), v_RECORDS, p_STATUS, p_MESSAGE);
		IF p_STATUS >= 0 THEN
			IMPORT_MARKET_RESULTS(p_ISO_ACCOUNT_NAME, v_RECORDS, p_STATUS, p_MESSAGE);
		END IF;

END IMPORT_MARKET_RESULTS_FILE;
------------------------------------------------------------------------------------

PROCEDURE PUT_MARKET_MESSAGE(p_MESSAGE_DATE        IN DATE,
													 p_REALM               IN VARCHAR2,
													 p_EFFECTIVE_DATE      IN DATE,
													 p_TERMINATION_DATE    IN DATE,
													 p_PRIORITY            IN NUMBER,
													 p_MESSAGE_SOURCE      IN VARCHAR2,
													 p_MESSAGE_DESTINATION IN VARCHAR2,
													 p_TEXT                IN VARCHAR2) AS
    v_MSG_ID NUMBER(9);

BEGIN

    -- has this message already been logged?
    -- a value of 0 means no

    v_MSG_ID := MEX_UTIL.GET_MARKET_MESSAGE_ID(
                p_REALM,
                p_EFFECTIVE_DATE,
                p_TERMINATION_DATE,
                p_PRIORITY,
                p_TEXT);

	MEX_UTIL.INSERT_MARKET_MESSAGE('PJM', p_MESSAGE_DATE, p_REALM, p_EFFECTIVE_DATE,
									p_TERMINATION_DATE, p_PRIORITY, p_MESSAGE_SOURCE,
									p_MESSAGE_DESTINATION, p_TEXT);


    -- send notification if this is the first time logged
    IF v_MSG_ID = 0 THEN
		ALERTS.TRIGGER_ALERTS(g_MARKET_MESSAGE_ALERT, LOGS.c_Level_Notice, p_TEXT);
	END IF;

    COMMIT;

END PUT_MARKET_MESSAGE;
-------------------------------------------------------------------------------------
PROCEDURE IMPORT_MESSAGES(v_RECORDS       IN MEX_PJM_EMKT_MESSAGES_TBL,
														P_STATUS        OUT NUMBER,
														P_ERROR_MESSAGE OUT VARCHAR2) AS
		v_IDX BINARY_INTEGER;
BEGIN
		p_STATUS := GA.SUCCESS;
		v_IDX    := v_RECORDS.FIRST;
		WHILE v_RECORDS.EXISTS(v_IDX) LOOP
			PUT_MARKET_MESSAGE(SYSDATE,
                v_RECORDS(v_IDX).MESSAGE_REALM,
                v_RECORDS(v_IDX).EFFECTIVE_TIME,
                v_RECORDS(v_IDX).TERMINATION_TIME,
                v_RECORDS(v_IDX).MESSAGE_PRIORITY,
                'eMKT',
                NULL,
                v_RECORDS(v_IDX).MESSAGE_TEXT);
                v_IDX := v_RECORDS.NEXT(v_IDX);
		END LOOP;
	EXCEPTION
		WHEN OTHERS THEN
			P_STATUS        := SQLCODE;
			P_ERROR_MESSAGE := PACKAGE_NAME || '.IMPORT_MESSAGES: ' || UT.GET_FULL_ERRM;
END IMPORT_MESSAGES;
-------------------------------------------------------------------------------------
PROCEDURE QUERY_MESSAGES(p_CRED				IN mex_credentials,
						 P_LOG_ONLY         IN NUMBER,
                         P_STATUS           OUT NUMBER,
                         P_ERROR_MESSAGE    OUT VARCHAR2,
						 p_LOGGER IN OUT	mm_logger_adapter
						 ) AS

    --Handle Query and Response for 'Messages'
    V_RECORDS   MEX_PJM_EMKT_MESSAGES_TBL;

BEGIN

    P_STATUS    := GA.SUCCESS;

      MEX_PJM_EMKT.FETCH_MESSAGES(p_CRED, P_LOG_ONLY, V_RECORDS, P_STATUS, P_ERROR_MESSAGE, p_LOGGER);

	  IF P_STATUS >= 0 THEN
        IMPORT_MESSAGES(V_RECORDS, P_STATUS, P_ERROR_MESSAGE);
      END IF;

EXCEPTION
    WHEN OTHERS THEN
      P_STATUS        := SQLCODE;
      P_ERROR_MESSAGE := PACKAGE_NAME || '.QUERY_MESSAGES: ' || UT.GET_FULL_ERRM;

END QUERY_MESSAGES;
-------------------------------------------------------------------------------------
PROCEDURE UPDATE_PORTFOLIO(p_PORTFOLIO_ID IN NUMBER,
														 p_ACTION       IN VARCHAR2,
														 p_SUBMIT_XML   OUT XMLTYPE) AS
/*******************************************************************************************************/
/*******************************************************************************************************/
/***********************           This query has not been MEXified              ***********************/
/*******************************************************************************************************/
/*******************************************************************************************************/

		--p_ACTION = Remove: delete the portfolio at PJM
		--p_ACTION = Update: delete the portfolio at PJM, then create it based on MM's definition
		--p_ACTION = Create: create the portfolio based on the MM definition
BEGIN

		IF p_ACTION = 'Remove' THEN
			SELECT XMLELEMENT("Portfolios",
												XMLELEMENT("Portfolio",
																		XMLATTRIBUTES(A.PORTFOLIO_NAME AS "name",
																									 'Remove' AS "action")))
				INTO p_SUBMIT_XML
				FROM PORTFOLIO A
			 WHERE A.PORTFOLIO_ID = p_PORTFOLIO_ID;
		ELSE
			SELECT XMLELEMENT("Portfolios",
												CASE p_ACTION
													 WHEN 'Update' THEN
														XMLELEMENT("Portfolio",
																			 XMLATTRIBUTES(A.PORTFOLIO_NAME AS "name",
																											'Remove' AS "action"))
												 END,
												XMLELEMENT("Portfolio",
																		XMLATTRIBUTES(A.PORTFOLIO_NAME AS "name",
																									 'Create' AS "action"),
																		XMLAGG(XMLELEMENT("LocationName",
																											 C.EXTERNAL_IDENTIFIER))))
				INTO p_SUBMIT_XML
				FROM PORTFOLIO A, PORTFOLIO_SERVICE_POINT B, SERVICE_POINT C
			 WHERE A.PORTFOLIO_ID = p_PORTFOLIO_ID AND
						 B.PORTFOLIO_ID = A.PORTFOLIO_ID AND
						 C.SERVICE_POINT_ID = B.SERVICE_POINT_ID
			 GROUP BY A.PORTFOLIO_NAME;
		END IF;

END UPDATE_PORTFOLIO;

-------------------------------------------------------------------------------------
PROCEDURE PUT_PORTFOLIO_MEMBER(p_PORTFOLIO_NAME IN VARCHAR2,
																 p_LOCATION_ID    IN VARCHAR2,
																 p_LOCATION_TYPE  IN VARCHAR2,
																 p_STATUS         OUT NUMBER,
																 p_ERROR_MESSAGE  OUT VARCHAR2) AS
		l_PORTFOLIO_ID     PORTFOLIO.PORTFOLIO_ID%TYPE;
		l_SERVICE_POINT_ID SERVICE_POINT.SERVICE_POINT_ID%TYPE;
		l_COUNT            NUMBER;
BEGIN
		-- add the portfolio
		IO.PUT_PORTFOLIO(o_OID => l_PORTFOLIO_ID,
										 p_PORTFOLIO_NAME => p_PORTFOLIO_NAME,
										 p_PORTFOLIO_ALIAS => '?', p_PORTFOLIO_DESC => '?',
										 p_PORTFOLIO_ID => 0);
		-- get the service point ID for this location ID
		SELECT SP.SERVICE_POINT_ID
			INTO l_SERVICE_POINT_ID
			FROM SERVICE_POINT SP
		 WHERE SP.EXTERNAL_IDENTIFIER = p_LOCATION_ID;

		-- add the member to the portfolio (if needed)
		SELECT COUNT(*)
			INTO l_COUNT
			FROM PORTFOLIO_SERVICE_POINT PSP
		 WHERE PSP.PORTFOLIO_ID = l_PORTFOLIO_ID AND
					 PSP.SERVICE_POINT_ID = l_SERVICE_POINT_ID;
		IF l_COUNT = 0 THEN
			INSERT INTO PORTFOLIO_SERVICE_POINT
			VALUES
				(l_PORTFOLIO_ID, l_SERVICE_POINT_ID);
		END IF;
	EXCEPTION
		WHEN OTHERS THEN
			p_STATUS        := SQLCODE;
			p_ERROR_MESSAGE := PACKAGE_NAME || '.PUT_PORTFOLIO_MEMBER: ' || UT.GET_FULL_ERRM;
END PUT_PORTFOLIO_MEMBER;

-------------------------------------------------------------------------------------
PROCEDURE IMPORT_PORTFOLIOS(p_RECORDS       IN MEX_PJM_EMKT_PORTFOLIO_TBL,
														p_STATUS        OUT NUMBER,
														p_ERROR_MESSAGE OUT VARCHAR2) AS
	l_PORTFOLIO_ID        PORTFOLIO.PORTFOLIO_ID%TYPE;
	l_SERVICE_POINT_ID    SERVICE_POINT.SERVICE_POINT_ID%TYPE;
	l_COUNT               NUMBER;
	v_IDX                 NUMBER;
	l_LAST_PORTFOLIO_NAME PORTFOLIO.PORTFOLIO_NAME%TYPE;
BEGIN
	p_STATUS := GA.SUCCESS;

	IF p_RECORDS.COUNT = 0 THEN
		RETURN;
	END IF; -- nothing to do

	v_IDX := p_RECORDS.FIRST;
	WHILE p_RECORDS.EXISTS(v_IDX) LOOP
		-- cache the portfolio ID
		IF l_LAST_PORTFOLIO_NAME != p_RECORDS(v_IDX).PORTFOLIO_NAME OR l_LAST_PORTFOLIO_NAME IS NULL THEN
			-- does this portfolio exist?
			BEGIN
				SELECT P.PORTFOLIO_ID
					INTO l_PORTFOLIO_ID
					FROM PORTFOLIO P
				 WHERE P.PORTFOLIO_ALIAS = p_RECORDS(v_IDX).PORTFOLIO_NAME;
			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					-- create the portfolio
					IO.PUT_PORTFOLIO(o_OID             => l_PORTFOLIO_ID,
													 p_PORTFOLIO_NAME  => p_RECORDS(v_IDX).PORTFOLIO_NAME,
													 p_PORTFOLIO_ALIAS => p_RECORDS(v_IDX).PORTFOLIO_NAME,
													 p_PORTFOLIO_DESC  => 'Created by Market Manager via eMarket Query Portfolios action',
													 p_PORTFOLIO_ID    => 0);
					COMMIT;
			END;
			l_LAST_PORTFOLIO_NAME := p_RECORDS(v_IDX).PORTFOLIO_NAME;
		END IF;

		-- does the portfolio member exist?
		BEGIN
			-- get the service point ID for this location ID
			SELECT SP.SERVICE_POINT_ID
				INTO l_SERVICE_POINT_ID
				FROM SERVICE_POINT SP
			 WHERE SP.EXTERNAL_IDENTIFIER = p_RECORDS(v_IDX).LOCATION_NAME;
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				l_SERVICE_POINT_ID := MM_PJM_UTIL.ID_FOR_SERVICE_POINT_PNODE(p_RECORDS(v_IDX).LOCATION_NAME);
		END;

		IF l_SERVICE_POINT_ID IS NOT NULL THEN
			-- add the member to the portfolio (if needed)
			SELECT COUNT(*)
				INTO l_COUNT
				FROM PORTFOLIO_SERVICE_POINT PSP
			 WHERE PSP.PORTFOLIO_ID = l_PORTFOLIO_ID
				 AND PSP.SERVICE_POINT_ID = l_SERVICE_POINT_ID;
			IF l_COUNT = 0 THEN
				INSERT INTO PORTFOLIO_SERVICE_POINT VALUES (l_PORTFOLIO_ID, l_SERVICE_POINT_ID);
			END IF;
		END IF;
		v_IDX := p_RECORDS.NEXT(v_IDX);
	END LOOP;

  COMMIT;
EXCEPTION
	WHEN OTHERS THEN
		p_STATUS        := SQLCODE;
		p_ERROR_MESSAGE := PACKAGE_NAME || '.PUT_PORTFOLIO_MEMBER: ' || UT.GET_FULL_ERRM;
END IMPORT_PORTFOLIOS;

-------------------------------------------------------------------------------------

PROCEDURE QUERY_PORTFOLIOS
	(
	p_CRED	   IN mex_credentials,
	p_LOG_ONLY IN NUMBER,
	p_STATUS   OUT NUMBER,
	p_MESSAGE  OUT VARCHAR2,
	p_LOGGER   IN OUT mm_logger_adapter
	) AS

	v_RECORDS   MEX_PJM_EMKT_PORTFOLIO_TBL;
BEGIN
	p_STATUS := GA.SUCCESS;

	MEX_PJM_EMKT.FETCH_PORTFOLIOS('All', p_CRED, p_LOG_ONLY, v_RECORDS, p_STATUS, p_MESSAGE, p_LOGGER);

	IF p_STATUS >= 0 THEN
		IMPORT_PORTFOLIOS(v_RECORDS, p_STATUS, p_MESSAGE);
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS  := SQLCODE;
		p_MESSAGE := PACKAGE_NAME || '.QUERY_PORTFOLIOS: ' || UT.GET_FULL_ERRM;

END QUERY_PORTFOLIOS;
-----------------------------------------------------------------------
PROCEDURE WEATHER_FORECAST(p_STATION_ID    IN NUMBER,
														 p_FORECAST_DATE IN DATE,
														 p_SUBMIT_XML    OUT XMLTYPE) AS
/*******************************************************************************************************/
/*******************************************************************************************************/
/***********************           This query has not been MEXified              ***********************/
/*******************************************************************************************************/
/*******************************************************************************************************/

		v_DAYTIME_PARAMETER_ID   NUMBER(9);
		v_NIGHTTIME_PARAMETER_ID NUMBER(9);
BEGIN

		SELECT PARAMETER_ID
			INTO v_DAYTIME_PARAMETER_ID
			FROM WEATHER_PARAMETER
		 WHERE PARAMETER_NAME = 'Daytime Temperature';

		SELECT PARAMETER_ID
			INTO v_NIGHTTIME_PARAMETER_ID
			FROM WEATHER_PARAMETER
		 WHERE PARAMETER_NAME = 'Nighttime Temperature';

		SELECT XMLELEMENT("WeatherForecast",
											XMLATTRIBUTES(TO_CHAR(p_FORECAST_DATE, g_DATE_FORMAT) AS
																		 "day"),
											XMLELEMENT("WeatherPoint",
																	XMLATTRIBUTES(A.STATION_NAME AS "name"),
																	XMLFOREST(B.PARAMETER_VAL AS
																						 "DaytimeTemperature",
																						 C.PARAMETER_VAL AS
																							"NighttimeTemperature")))
			INTO p_SUBMIT_XML
			FROM WEATHER_STATION         A,
					 STATION_PARAMETER_VALUE B,
					 STATION_PARAMETER_VALUE C
		 WHERE A.STATION_ID = p_STATION_ID AND B.CASE_ID = GA.BASE_CASE_ID AND
					 B.STATION_ID = p_STATION_ID AND
					 B.PARAMETER_ID = v_DAYTIME_PARAMETER_ID AND
					 B.PARAMETER_DATE = TRUNC(p_FORECAST_DATE) AND
					 C.CASE_ID = GA.BASE_CASE_ID AND C.STATION_ID = p_STATION_ID AND
					 C.PARAMETER_ID = v_NIGHTTIME_PARAMETER_ID AND
					 C.PARAMETER_DATE = TRUNC(p_FORECAST_DATE);

END WEATHER_FORECAST;

-------------------------------------------------------------------------------------

PROCEDURE PUT_MARKET_PRICE_VALUE
		(
		p_MARKET_PRICE_ID IN NUMBER,
		p_PJM_DATE IN DATE,
		p_PRICE IN NUMBER,
		p_STATUS OUT NUMBER,
		p_ERROR_MESSAGE OUT VARCHAR2
		) AS

		v_PRICE_BASIS     NUMBER := NULL;
		v_AS_OF_DATE      DATE := LOW_DATE;
		v_PRICE_CODE      MARKET_PRICE_VALUE.PRICE_CODE%TYPE := 'A';
		v_CUT_DATE DATE := TO_CUT(p_PJM_DATE, MM_PJM_EMKT_UTIL.g_PJM_TIME_ZONE);
BEGIN

		p_STATUS := GA.SUCCESS;

		--DO THE UPDATE OR INSERT.
		UPDATE MARKET_PRICE_VALUE
			 SET PRICE_BASIS = v_PRICE_BASIS, PRICE = p_PRICE
		 WHERE MARKET_PRICE_ID = p_MARKET_PRICE_ID
		 	AND PRICE_CODE = v_PRICE_CODE
			AND PRICE_DATE = v_CUT_DATE
			AND AS_OF_DATE = v_AS_OF_DATE;

		IF SQL%NOTFOUND THEN

			INSERT INTO MARKET_PRICE_VALUE
				(MARKET_PRICE_ID,
				 PRICE_CODE,
				 PRICE_DATE,
				 AS_OF_DATE,
				 PRICE_BASIS,
				 PRICE)
			VALUES
				(p_MARKET_PRICE_ID,
				 v_PRICE_CODE,
				 v_CUT_DATE,
				 v_AS_OF_DATE,
				 v_PRICE_BASIS,
				 p_PRICE);
		END IF;

EXCEPTION
		WHEN OTHERS THEN
			p_STATUS        := SQLCODE;
			p_ERROR_MESSAGE := PACKAGE_NAME || '.PUT_MARKET_PRICE: ' || UT.GET_FULL_ERRM;

END PUT_MARKET_PRICE_VALUE;

---------------------------------------------------------------------------------------------------

/*-------------------------------------------------------------------------------------
The naming convention for these transactions is "<area name> Hourly Demand" (for
forecast and cleared demand MW) and "<area name> Hourly Reserve Req" (for reserve
requirement).

The forecast MW will go into IT_SCHEDULE with a schedule state corresponding to
'Forecast', and the cleared demand MW will go into IT_SCHEDULE for all other
schedule states. Reserve Requirement will go into all 3 states.
-------------------------------------------------------------------------------------*/
PROCEDURE ADD_CONTROL_AREA_DEMAND(p_DATE          IN DATE,
																		p_AREA_NAME     IN VARCHAR2,
																		p_FORECAST_MW   IN NUMBER,
																		p_DEMAND_BID_MW IN NUMBER,
																		p_RESERVE_MW    IN NUMBER,
																		p_STATUS        OUT NUMBER,
																		p_ERROR_MESSAGE OUT VARCHAR2) IS

		l_CA_ID               CONTROL_AREA.CA_ID%TYPE;
		l_HOURLY_DEMAND_TX_ID INTERCHANGE_TRANSACTION.TRANSACTION_ID%TYPE;
		l_RESERVE_REQ_TX_ID   INTERCHANGE_TRANSACTION.TRANSACTION_ID%TYPE;

		TYPE ARRAY IS VARRAY(3) OF STATEMENT_TYPE.STATEMENT_TYPE_ID%TYPE;
		l_HOURLY_DEMAND_MW ARRAY := ARRAY();
		l_RESERVE_REQ_MW   ARRAY := ARRAY();
		I                  BINARY_INTEGER;

    -- this is really really fragile
		CURSOR c_SCHEDULE_TYPES IS
			SELECT S.STATEMENT_TYPE_ID, S.STATEMENT_TYPE_NAME
				FROM STATEMENT_TYPE S
        WHERE S.STATEMENT_TYPE_NAME NOT LIKE 'MISO%'
			 ORDER BY S.STATEMENT_TYPE_ID ASC;

		FUNCTION PUT_TRANSACTION(p_TX_NAME IN VARCHAR2)
			RETURN INTERCHANGE_TRANSACTION.TRANSACTION_ID%TYPE IS
			v_ID     INTERCHANGE_TRANSACTION.TRANSACTION_ID%TYPE;
			v_TX_ROW INTERCHANGE_TRANSACTION%ROWTYPE;
        BEGIN
			v_TX_ROW.Transaction_Name       := p_TX_NAME;
			v_TX_ROW.Transaction_Alias      := p_TX_NAME;
			v_TX_ROW.Transaction_Desc       := 'Created by MarketManager via Demand Summary query';
			v_TX_ROW.Transaction_Identifier := NULL;
			v_TX_ROW.Begin_Date             := TO_DATE('01/01/2003', 'MM/DD/YYYY');
			v_TX_ROW.End_Date               := TO_DATE('12/31/2010', 'MM/DD/YYYY');
			v_TX_ROW.Seller_Id              := NULL;
			v_TX_ROW.Purchaser_Id           := NULL;
			v_TX_ROW.Source_Id              := NULL;
			v_TX_ROW.SINK_Id                := NULL;
            v_TX_ROW.Transaction_Interval := 'Hour';
			v_TX_ROW.COMMODITY_ID := MM_PJM_UTIL.GET_COMMODITY_ID(MM_PJM_UTIL.g_COMM_DA_ENERGY);
			v_TX_ROW.Transaction_Type := 'Load';
			v_TX_ROW.Sc_Id            := EI.GET_ID_FROM_IDENTIFIER_EXTSYS('PJM', EC.ED_SC, EC.ES_PJM);
			v_TX_ROW.Transaction_Id   := 0;
			v_TX_ROW.Contract_Id      := 0;
			MM_UTIL.PUT_TRANSACTION(o_OID                     => v_ID,
															p_INTERCHANGE_TRANSACTION => v_TX_ROW,
															p_SCHEDULE_STATE          => 1,
															p_TRANSACTION_STATUS      => 'Active');

			COMMIT;
            RETURN v_ID;
		END PUT_TRANSACTION;
BEGIN
		p_STATUS := GA.SUCCESS;

		-- create the control area if it doesn't exist
		BEGIN
			SELECT C.CA_ID INTO l_CA_ID FROM CONTROL_AREA C WHERE C.CA_ALIAS = p_AREA_NAME;
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				IO.PUT_CA(o_OID            => l_CA_ID,
									p_CA_NAME        => p_AREA_NAME,
									p_CA_ALIAS       => p_AREA_NAME,
									p_CA_DESC        => 'Created by MarketManager via eMarket Demand Summary query',
									p_CA_ID          => 0,
									p_CA_NERC_CODE   => NULL,
									p_CA_STATUS      => 'Active',
									p_CA_DUNS_NUMBER => NULL);
				COMMIT;
		END;

		-- get the CA Hourly Demand transaction (create it if it doesn't exist)
		BEGIN
			SELECT T.TRANSACTION_ID
				INTO l_HOURLY_DEMAND_TX_ID
				FROM INTERCHANGE_TRANSACTION T
			 WHERE T.TRANSACTION_ALIAS = p_AREA_NAME || ' Hourly Demand';
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				l_HOURLY_DEMAND_TX_ID := PUT_TRANSACTION(p_AREA_NAME || ' Hourly Demand');
		END;

		-- get the CA Hourly Reserve Req transaction (create it if it doesn't exist)
		BEGIN
			SELECT T.TRANSACTION_ID
				INTO l_RESERVE_REQ_TX_ID
				FROM INTERCHANGE_TRANSACTION T
			 WHERE T.TRANSACTION_ALIAS = p_AREA_NAME || ' Hourly Reserve Req';
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				l_RESERVE_REQ_TX_ID := PUT_TRANSACTION(p_AREA_NAME || ' Hourly Reserve Req');
		END;

		I := 1;
		-- fill in the CA Hourly Demand values and
		FOR r_SCHEDULE_TYPE IN c_SCHEDULE_TYPES LOOP
      l_HOURLY_DEMAND_MW.EXTEND();
			l_HOURLY_DEMAND_MW(I) := p_DEMAND_BID_MW;

      l_RESERVE_REQ_MW.EXTEND();
			l_RESERVE_REQ_MW(I) := p_RESERVE_MW;
			I := I + 1;
		END LOOP;
		-- fix the forecast hourly demand
		l_HOURLY_DEMAND_MW(1) := p_FORECAST_MW;

		-- loop over the schedule types and update IT_SCHEDULE
		FOR r_SCHEDULE_TYPE IN c_SCHEDULE_TYPES LOOP
			ITJ.PUT_IT_SCHEDULE(p_TRANSACTION_ID => l_HOURLY_DEMAND_TX_ID,
												 p_SCHEDULE_TYPE  => r_SCHEDULE_TYPE.Statement_Type_Id,
												 p_SCHEDULE_DATE  => p_DATE,
												 p_AS_OF_DATE     => LOW_DATE,
												 p_AMOUNT         => l_HOURLY_DEMAND_MW(r_SCHEDULE_TYPE.Statement_Type_Id),
												 p_PRICE          => NULL,
												 p_STATUS         => p_STATUS);
			ITJ.PUT_IT_SCHEDULE(p_TRANSACTION_ID => l_RESERVE_REQ_TX_ID,
												 p_SCHEDULE_TYPE  => r_SCHEDULE_TYPE.Statement_Type_Id,
												 p_SCHEDULE_DATE  => p_DATE,
												 p_AS_OF_DATE     => LOW_DATE,
												 p_AMOUNT         => l_RESERVE_REQ_MW(r_SCHEDULE_TYPE.Statement_Type_Id),
												 p_PRICE          => NULL,
												 p_STATUS         => p_STATUS);
		END LOOP;

EXCEPTION
		WHEN OTHERS THEN
			p_STATUS        := SQLCODE;
			p_ERROR_MESSAGE := PACKAGE_NAME || '.ADD_CONTROL_AREA_DEMAND: ' || UT.GET_FULL_ERRM;
END ADD_CONTROL_AREA_DEMAND;

-------------------------------------------------------------------------------------
PROCEDURE IMPORT_DEMAND_SUMMARY(v_RECORDS       IN mex_pjm_emkt_demand_summ_tbl,
																	P_STATUS        OUT NUMBER,
																	P_MESSAGE       OUT VARCHAR2) IS
		v_IDX BINARY_INTEGER;
BEGIN
		p_STATUS := GA.SUCCESS;
		v_IDX    := v_RECORDS.FIRST;
		WHILE v_RECORDS.EXISTS(v_IDX) LOOP
			ADD_CONTROL_AREA_DEMAND(p_DATE          => v_RECORDS(v_IDX).DAY + v_RECORDS(v_IDX).HOUR / 24,
															p_AREA_NAME     => v_RECORDS(v_IDX).AREA,
															p_FORECAST_MW   => v_RECORDS(v_IDX).FORECAST_MW,
															p_DEMAND_BID_MW => v_RECORDS(v_IDX).DEMAND_BID_MW,
															p_RESERVE_MW    => v_RECORDS(v_IDX).RESERVE_MW,
															p_STATUS        => P_STATUS,
															p_ERROR_MESSAGE => P_MESSAGE);
      IF p_STATUS >= 0 THEN
        COMMIT;
      END IF;
			v_IDX := v_RECORDS.NEXT(v_IDX);
		END LOOP;
EXCEPTION
		WHEN OTHERS THEN
			p_STATUS  := SQLCODE;
			P_MESSAGE := PACKAGE_NAME || '.IMPORT_DEMAND_SUMMARY: ' || UT.GET_FULL_ERRM;
END IMPORT_DEMAND_SUMMARY;
-------------------------------------------------------------------------------------

PROCEDURE QUERY_DEMAND_SUMMARY(p_CRED				IN mex_credentials,
							   p_BEGIN_DATE  IN DATE,
							   p_END_DATE IN DATE,
							   P_LOG_ONLY      IN NUMBER,
							   P_STATUS        OUT NUMBER,
							   P_ERROR_MESSAGE OUT VARCHAR2,
							   p_LOGGER IN OUT	mm_logger_adapter
							   ) IS

    V_RECORDS   MEX_PJM_EMKT_DEMAND_SUMM_TBL;
BEGIN
    P_STATUS    := GA.SUCCESS;

      MEX_PJM_EMKT.FETCH_DEMAND_SUMMARY(p_CRED, p_LOG_ONLY, p_BEGIN_DATE, P_END_DATE, V_RECORDS, P_STATUS, P_ERROR_MESSAGE, p_LOGGER);
      IF P_STATUS >= 0 THEN
        IMPORT_DEMAND_SUMMARY(v_RECORDS, P_STATUS, P_ERROR_MESSAGE);
      END IF;

EXCEPTION
    WHEN OTHERS THEN
      P_STATUS        := SQLCODE;
			P_ERROR_MESSAGE := PACKAGE_NAME || '.QUERY_DEMAND_SUMMARY: ' || UT.GET_FULL_ERRM;

END QUERY_DEMAND_SUMMARY;

-------------------------------------------------------------------------------------

PROCEDURE PUT_MARKET_PRICE_LMP(p_PRICE_DATE        IN DATE,
																 p_LOCATION_NAME     IN VARCHAR2,
																 p_MARKET_PRICE_TYPE IN VARCHAR2,
																 p_MARKET_TYPE       IN VARCHAR2,
																 p_INTERVAL          IN VARCHAR2,
																 p_PRICE             IN NUMBER,
																 p_STATUS            OUT NUMBER,
																 p_ERROR_MESSAGE     OUT VARCHAR2) AS

		v_SERVICE_P0INT_ROW SERVICE_POINT%ROWTYPE;
        v_SP_ID SERVICE_POINT.SERVICE_POINT_ID%TYPE;
		v_MARKET_PRICE_ID   NUMBER(9);
		v_PRICE_BASIS       NUMBER := NULL;
		v_PRICE_CODE        CHAR(1) := 'A'; --ACTUAL
		v_AS_OF_DATE        DATE := LOW_DATE; --ASSUME GA.VERSION_MARKET_PRICE IS FALSE.  IF NOT, IT SHOULD BE SYSDATE.
BEGIN

		p_STATUS := GA.SUCCESS;

		--GET MARKET PRICE RELATED TO THE GIVEN SERVICE POINT, TYPE, AND INTERVAL.
		BEGIN
			SELECT A.MARKET_PRICE_ID
				INTO v_MARKET_PRICE_ID
				FROM MARKET_PRICE A, SERVICE_POINT B
			 WHERE B.EXTERNAL_IDENTIFIER = p_LOCATION_NAME
				 AND A.POD_ID = B.SERVICE_POINT_ID
				 AND A.MARKET_PRICE_TYPE = p_MARKET_PRICE_TYPE
				 AND UPPER(A.MARKET_PRICE_INTERVAL) = UPPER(p_INTERVAL)
				 AND A.MARKET_TYPE = p_MARKET_TYPE
				 AND ROWNUM = 1; --Just in case it is not unique (should be, but not enforced in DB)
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				-- if a service point exists, create the market price
				BEGIN
					SELECT S.SERVICE_POINT_ID
						INTO v_SP_ID
						FROM SERVICE_POINT S
					 WHERE S.EXTERNAL_IDENTIFIER = p_LOCATION_NAME;
				EXCEPTION
					WHEN NO_DATA_FOUND THEN
						-- look in the PJM_EMKT_PNODES table for the service point
						v_SP_ID := MM_PJM_UTIL.ID_FOR_SERVICE_POINT_PNODE(p_LOCATION_NAME);
				END;

				IF v_SP_ID IS NOT NULL THEN
					-- create a market price for this service point
					SELECT *
						INTO v_SERVICE_P0INT_ROW
						FROM SERVICE_POINT S
					 WHERE S.SERVICE_POINT_ID = v_SP_ID;

					IO.PUT_MARKET_PRICE(o_OID               => v_MARKET_PRICE_ID,
        							p_MARKET_PRICE_NAME     => v_SERVICE_P0INT_ROW.Service_Point_Name,
        							p_MARKET_PRICE_ALIAS    => '?',
        							p_MARKET_PRICE_DESC     => 'Created by MarketManager via eMarket Market Price query',
        							p_MARKET_PRICE_ID       => 0,
        							p_MARKET_PRICE_TYPE     => p_MARKET_PRICE_TYPE,
        							p_MARKET_PRICE_INTERVAL => p_INTERVAL,
        							p_MARKET_TYPE           => p_MARKET_TYPE,
									p_COMMODITY_ID			=> 0,
        							p_SERVICE_POINT_TYPE    => 'Point',
        							p_EXTERNAL_IDENTIFIER   => p_LOCATION_NAME,
        							p_EDC_ID                => 0,
        							p_SC_ID                 => EI.GET_ID_FROM_IDENTIFIER_EXTSYS('PJM', EC.ED_SC, EC.ES_PJM),
        							p_POD_ID                => v_SP_ID,
									p_ZOD_ID				=> 0);
					COMMIT;
-- 16-mar-2009, jbc: MM_PJM_UTIL.ID_FOR_SERVICE_POINT_PNODE handles logging a warning
/*
        ELSE
          -- no service point; need to get all the pnodes again
						LOGS.LOG_WARN('Pnode ' || p_LOCATION_NAME || ' not found. Run the Query Node List action to update the node list.');
*/
				END IF;
		END;

		--DO THE UPDATE OR INSERT.
		UPDATE MARKET_PRICE_VALUE
			 SET PRICE_BASIS = v_PRICE_BASIS, PRICE = p_PRICE
		 WHERE MARKET_PRICE_ID = v_MARKET_PRICE_ID
			 AND PRICE_CODE = v_PRICE_CODE
			 AND PRICE_DATE = p_PRICE_DATE
			 AND AS_OF_DATE = v_AS_OF_DATE;

		IF SQL%NOTFOUND THEN
			INSERT INTO MARKET_PRICE_VALUE
				(MARKET_PRICE_ID, PRICE_CODE, PRICE_DATE, AS_OF_DATE, PRICE_BASIS, PRICE)
			VALUES
				(v_MARKET_PRICE_ID, v_PRICE_CODE, p_PRICE_DATE, v_AS_OF_DATE, v_PRICE_BASIS, p_PRICE);
		END IF;

EXCEPTION
		WHEN OTHERS THEN
			p_STATUS        := SQLCODE;
			p_ERROR_MESSAGE := UT.GET_FULL_ERRM;

END PUT_MARKET_PRICE_LMP;
-------------------------------------------------------------------------------------

PROCEDURE IMPORT_HOURLY_LMP
	(
	P_RECORDS       IN MEX_PJM_EMKT_HOURLY_LMP_TBL,
	P_STATUS        OUT NUMBER,
	P_ERROR_MESSAGE OUT VARCHAR2
	) AS

	V_MARKET_PRICE_INTERVAL VARCHAR2(16) := 'Hour';
	V_MARKET_TYPE           VARCHAR2(16) := MM_PJM_UTIL.g_DAYAHEAD;
	V_LMP_PRICE_TYPE        VARCHAR2(32) := 'Locational Marginal Price';

	v_IDX BINARY_INTEGER;
BEGIN
	p_STATUS := GA.SUCCESS;
	v_IDX    := p_RECORDS.FIRST;
	WHILE p_RECORDS.EXISTS(v_IDX) LOOP
		PUT_MARKET_PRICE_LMP(
			TO_CUT_WITH_OPTIONS(p_RECORDS(v_IDX).DAY + p_RECORDS(v_IDX).HOUR / 24, MM_PJM_UTIL.g_PJM_TIME_ZONE, MM_PJM_UTIL.g_DST_SPRING_AHEAD_OPTION),
	                    p_RECORDS(v_IDX).LOCATION_NAME,
	                    V_LMP_PRICE_TYPE,
	                    V_MARKET_TYPE,
	                    V_MARKET_PRICE_INTERVAL,
	                    p_RECORDS(v_IDX).LMP,
	                    P_STATUS,
	                    P_ERROR_MESSAGE);
		IF p_STATUS >= 0 THEN
			COMMIT;
		END IF;
		v_IDX := p_RECORDS.NEXT(v_IDX);
	END LOOP;
EXCEPTION
	WHEN OTHERS THEN
	P_STATUS        := SQLCODE;
	P_ERROR_MESSAGE := PACKAGE_NAME || '.IMPORT_HOURLY_LMP: ' || UT.GET_FULL_ERRM;
END IMPORT_HOURLY_LMP;
-------------------------------------------------------------------------------------
/*
	17-mar-2009, jbc: this code is deprecated in favor of the public LMP, which is
	published on the same timescale. this code can't handle looking up service points
	when it's handed a generator identifier (which is not in the list of published pnodes).
*/
-------------------------------------------------------------------------------------
PROCEDURE QUERY_HOURLY_LMP
	(
	p_CRED				IN mex_credentials,
	p_BEGIN_DATE IN DATE,
	p_END_DATE   IN DATE,
	P_LOG_ONLY      IN NUMBER,
	P_STATUS        OUT NUMBER,
	P_MESSAGE       OUT VARCHAR2,
	p_LOGGER IN OUT	mm_logger_adapter
	) AS

	V_RECORDS   MEX_PJM_EMKT_HOURLY_LMP_TBL;
BEGIN
    P_STATUS    := GA.SUCCESS;

	MEX_PJM_EMKT.FETCH_HOURLY_LMP(p_CRED, P_LOG_ONLY, p_BEGIN_DATE, p_END_DATE, v_RECORDS, p_STATUS, p_MESSAGE, p_LOGGER);

	IF P_STATUS >= 0 THEN
		IMPORT_HOURLY_LMP(V_RECORDS, P_STATUS, P_MESSAGE);
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		P_STATUS  := SQLCODE;
		P_MESSAGE := PACKAGE_NAME || '.QUERY_HOURLY_LMP: ' || UT.GET_FULL_ERRM;

END QUERY_HOURLY_LMP;
-------------------------------------------------------------------------------------
PROCEDURE IMPORT_REGULATION_BILATERAL
		(
		p_RECORDS IN MEX_PJM_EMKT_REG_BILATERAL_TBL,
		p_STATUS OUT NUMBER,
		p_ERROR_MESSAGE OUT VARCHAR2
		) IS
		v_REC MEX_PJM_EMKT_REG_BILATERAL;
		l_TRANSACTION_ID NUMBER(9);
		v_DATE DATE;
		v_END_DATE DATE;
		v_IDX BINARY_INTEGER;
BEGIN
		IF p_RECORDS.COUNT = 0 THEN
			RETURN;
		END IF; -- nothing to do

		v_IDX := p_RECORDS.FIRST;
		WHILE p_RECORDS.EXISTS(v_IDX) LOOP
			v_REC := p_RECORDS(v_IDX);

			UT.CUT_DAY_INTERVAL_RANGE(1, v_REC.START_DATE, v_REC.END_DATE, MM_PJM_EMKT_UTIL.g_PJM_TIME_ZONE, 60, v_DATE, v_END_DATE);

			SELECT ITX.TRANSACTION_ID
				INTO l_TRANSACTION_ID
				FROM INTERCHANGE_TRANSACTION   ITX,
					IT_COMMODITY A,
						 PURCHASING_SELLING_ENTITY PSE_SELLER,
						 PURCHASING_SELLING_ENTITY PSE_BUYER
			 WHERE ITX.SELLER_ID = PSE_SELLER.PSE_ID
				 AND ITX.PURCHASER_ID = PSE_BUYER.PSE_ID
				 AND A.COMMODITY_NAME = 'Regulation'
				 AND ITX.COMMODITY_ID = A.COMMODITY_ID
				 AND PSE_SELLER.PSE_NAME = v_REC.SELLER
				 AND PSE_BUYER.PSE_NAME = v_REC.BUYER;

			--Loop over each hour in the date range.
			LOOP
				ITJ.PUT_IT_SCHEDULE(l_TRANSACTION_ID, 2, v_DATE, LOW_DATE(), v_REC.MW, NULL, p_STATUS);
				IF p_STATUS < 0 THEN
					RETURN;
				END IF;
				v_DATE := ADVANCE_DATE(v_DATE, 'Hour');
				EXIT WHEN v_DATE > v_END_DATE;
			END LOOP;
    v_IDX := p_RECORDS.NEXT(v_IDX);
		END LOOP;
END IMPORT_REGULATION_BILATERAL;
-------------------------------------------------------------------------------------

PROCEDURE QUERY_REGULATION_BILATERAL
		(
		p_CRED				IN mex_credentials,
		p_REQUEST_DATE  IN DATE,
		p_LOG_ONLY      IN NUMBER,
		p_STATUS        OUT NUMBER,
		p_ERROR_MESSAGE OUT VARCHAR2,
		p_LOGGER IN OUT	mm_logger_adapter
		) AS

    v_RECORDS MEX_PJM_EMKT_REG_BILATERAL_TBL;
	BEGIN

	p_STATUS    := GA.SUCCESS;
	IF MM_PJM_UTIL.HAS_ESUITE_ACCESS(g_EMKT_GEN_ATTR, p_CRED.EXTERNAL_ACCOUNT_NAME) THEN
		MEX_PJM_EMKT.FETCH_REGULATION_BILATERAL(p_CRED, p_LOG_ONLY, p_REQUEST_DATE, v_RECORDS, p_STATUS, p_ERROR_MESSAGE, p_LOGGER);
		IF p_STATUS >= 0 THEN
			IMPORT_REGULATION_BILATERAL(v_RECORDS, p_STATUS, p_ERROR_MESSAGE);
		END IF;
	END IF;


EXCEPTION
		WHEN OTHERS THEN
			p_STATUS        := SQLCODE;
			p_ERROR_MESSAGE := PACKAGE_NAME || '.QUERY_REGULATION_BILATERAL: ' ||
												 UT.GET_FULL_ERRM;

END QUERY_REGULATION_BILATERAL;
-------------------------------------------------------------------------------------
PROCEDURE IMPORT_REGULATION_RESULTS
		(
		p_RECORDS IN MEX_PJM_EMKT_REG_RESULTS_TBL,
		p_STATUS OUT NUMBER,
		p_ERROR_MESSAGE OUT VARCHAR2
		) IS
		v_REC MEX_PJM_EMKT_REG_RESULTS;
		v_MARKET_PRICE_NAME MARKET_PRICE.MARKET_PRICE_NAME%TYPE;
		v_PREV_AREA VARCHAR2(64) := 'INITVAL';
		v_MARKET_PRICE_ID NUMBER(9);
		v_DATE DATE;
		v_IDX BINARY_INTEGER;
		l_XN_ID NUMBER(9);
BEGIN
		IF p_RECORDS.COUNT = 0 THEN
			RETURN;
		END IF; -- nothing to do

		v_IDX := p_RECORDS.FIRST;
		WHILE p_RECORDS.EXISTS(v_IDX) LOOP
			v_REC := p_RECORDS(v_IDX);
			v_DATE := v_REC.RESPONSE_DATE + (v_REC.RESPONSE_HOUR/24);

			IF v_PREV_AREA <> v_REC.AREA_NAME THEN

				SELECT ITX.TRANSACTION_ID--, R.RESOURCE_NAME
					INTO l_XN_ID--, l_RESOURCE_NAME
					FROM IT_COMMODITY A, INTERCHANGE_TRANSACTION ITX, SUPPLY_RESOURCE R, SERVICE_POINT S
				 WHERE A.COMMODITY_NAME = 'Regulation'
					 AND S.EXTERNAL_IDENTIFIER = v_REC.AREA_NAME
					 AND R.SERVICE_POINT_ID = S.SERVICE_POINT_ID
				 	 AND ITX.COMMODITY_ID = A.COMMODITY_ID
					 AND ITX.RESOURCE_ID = R.RESOURCE_ID;

				v_MARKET_PRICE_NAME := v_REC.AREA_NAME || ' RMCP';
				v_MARKET_PRICE_ID := GET_MARKET_PRICE_ID(v_MARKET_PRICE_NAME);

				v_PREV_AREA := v_REC.AREA_NAME;
			END IF;

			PUT_TRAIT_VALUE(v_DATE, l_XN_ID, 2, v_REC.SELF_SCHEDULED_MW, 'RegulationSelfScheduledMW', p_STATUS, p_ERROR_MESSAGE);
			PUT_TRAIT_VALUE(v_DATE, l_XN_ID, 2, v_REC.PROCURED_MW, 'RegulationProcuredMW', p_STATUS, p_ERROR_MESSAGE);
			PUT_TRAIT_VALUE(v_DATE, l_XN_ID, 2, v_REC.TOTAL_MW, 'RegulationTotalMW', p_STATUS, p_ERROR_MESSAGE);
			PUT_TRAIT_VALUE(v_DATE, l_XN_ID, 2, v_REC.REQUIRED_MW, 'RegulationReqdMW', p_STATUS, p_ERROR_MESSAGE);
			PUT_TRAIT_VALUE(v_DATE, l_XN_ID, 2, v_REC.DEFICIENCY_MW, 'RegulationDeficiencyMW', p_STATUS, p_ERROR_MESSAGE);
			PUT_MARKET_PRICE_VALUE(v_MARKET_PRICE_ID, v_DATE, v_REC.MCP, p_STATUS, p_ERROR_MESSAGE);

    v_IDX := p_RECORDS.NEXT(v_IDX);
		END LOOP;
END IMPORT_REGULATION_RESULTS;
-------------------------------------------------------------------------------------
PROCEDURE QUERY_REGULATION_RESULTS
		(
		p_CRED				IN mex_credentials,
		p_REQUEST_DATE IN DATE,
		p_LOG_ONLY IN NUMBER,
		p_STATUS OUT NUMBER,
		p_ERROR_MESSAGE OUT VARCHAR2,
		p_LOGGER IN OUT	mm_logger_adapter
		) AS

    v_RECORDS MEX_PJM_EMKT_REG_RESULTS_TBL;

BEGIN

	p_STATUS    := GA.SUCCESS;

	IF MM_PJM_UTIL.HAS_ESUITE_ACCESS(g_EMKT_GEN_ATTR, p_CRED.EXTERNAL_ACCOUNT_NAME) THEN
		MEX_PJM_EMKT.FETCH_REGULATION_RESULTS(p_CRED, p_LOG_ONLY, p_REQUEST_DATE, v_RECORDS, p_STATUS, p_ERROR_MESSAGE, p_LOGGER);
		IF p_STATUS >= 0 THEN
			IMPORT_REGULATION_RESULTS(v_RECORDS, p_STATUS, p_ERROR_MESSAGE);
		END IF;
	END IF;

	EXCEPTION
		WHEN OTHERS THEN
			p_STATUS        := SQLCODE;
			p_ERROR_MESSAGE := PACKAGE_NAME || '.QUERY_REGULATION_RESULTS: ' ||	UT.GET_FULL_ERRM;
END QUERY_REGULATION_RESULTS;

-------------------------------------------------------------------------------------

PROCEDURE IMPORT_SPIN_RESERVE_BILATERAL
		(
		p_RECORDS IN MEX_PJM_EMKT_SPIN_RSV_BIL_TBL,
		p_STATUS OUT NUMBER,
		p_ERROR_MESSAGE OUT VARCHAR2
		) IS
		v_REC MEX_PJM_EMKT_SPIN_RSV_BIL;
		l_TRANSACTION_ID NUMBER(9);
		v_DATE DATE;
		v_END_DATE DATE;
		v_IDX BINARY_INTEGER;
BEGIN
		IF p_RECORDS.COUNT = 0 THEN
			RETURN;
		END IF; -- nothing to do

		v_IDX := p_RECORDS.FIRST;
		WHILE p_RECORDS.EXISTS(v_IDX) LOOP
			v_REC := p_RECORDS(v_IDX);

			UT.CUT_DAY_INTERVAL_RANGE(1, v_REC.START_DATE, v_REC.END_DATE, MM_PJM_EMKT_UTIL.g_PJM_TIME_ZONE, 60, v_DATE, v_END_DATE);

			SELECT ITX.TRANSACTION_ID
				INTO l_TRANSACTION_ID
				FROM INTERCHANGE_TRANSACTION   ITX,
					IT_COMMODITY A,
						 PURCHASING_SELLING_ENTITY PSE_SELLER,
						 PURCHASING_SELLING_ENTITY PSE_BUYER
			 WHERE ITX.SELLER_ID = PSE_SELLER.PSE_ID
				 AND ITX.PURCHASER_ID = PSE_BUYER.PSE_ID
				 AND A.COMMODITY_NAME = 'Spinning Reserve'
				 AND ITX.COMMODITY_ID = A.COMMODITY_ID
				 AND PSE_SELLER.PSE_NAME = v_REC.SELLER
				 AND PSE_BUYER.PSE_NAME = v_REC.BUYER;

			--Loop over each hour in the date range.
			LOOP
				ITJ.PUT_IT_SCHEDULE(l_TRANSACTION_ID, 2, v_DATE, LOW_DATE(), v_REC.MCP, NULL, p_STATUS);
				IF p_STATUS < 0 THEN
					RETURN;
				END IF;
				v_DATE := ADVANCE_DATE(v_DATE, 'Hour');
				EXIT WHEN v_DATE > v_END_DATE;
			END LOOP;

    v_IDX := p_RECORDS.NEXT(v_IDX);
		END LOOP;
END IMPORT_SPIN_RESERVE_BILATERAL;
-------------------------------------------------------------------------------------

PROCEDURE QUERY_SPIN_RESERVE_BILATERAL
		(
		p_CRED				IN mex_credentials,
		p_REQUEST_DATE  IN DATE,
		p_LOG_ONLY      IN NUMBER,
		p_STATUS        OUT NUMBER,
		p_ERROR_MESSAGE OUT VARCHAR2,
		p_LOGGER IN OUT	mm_logger_adapter
		) AS

    v_RECORDS MEX_PJM_EMKT_SPIN_RSV_BIL_TBL;

BEGIN

	p_STATUS    := GA.SUCCESS;
	  IF MM_PJM_UTIL.HAS_ESUITE_ACCESS(g_EMKT_GEN_ATTR, p_CRED.EXTERNAL_ACCOUNT_NAME) THEN
			MEX_PJM_EMKT.FETCH_SPIN_RESERVE_BIL(p_CRED, p_LOG_ONLY, p_REQUEST_DATE, v_RECORDS, p_STATUS, p_ERROR_MESSAGE, p_LOGGER);
			IF p_STATUS >= 0 THEN
				IMPORT_SPIN_RESERVE_BILATERAL(v_RECORDS, p_STATUS, p_ERROR_MESSAGE);
			END IF;
	  END IF;

	EXCEPTION
		WHEN OTHERS THEN
			p_STATUS        := SQLCODE;
			p_ERROR_MESSAGE := PACKAGE_NAME || '.QUERY_SPIN_RESERVE_BILATERAL: ' ||
												 UT.GET_FULL_ERRM;

END QUERY_SPIN_RESERVE_BILATERAL;
-------------------------------------------------------------------------------------
PROCEDURE IMPORT_SPIN_RESERVE_RESULTS
		(
		p_RECORDS IN MEX_PJM_EMKT_SPIN_RSV_RES_TBL,
		p_STATUS OUT NUMBER,
		p_ERROR_MESSAGE OUT VARCHAR2
		) IS
		v_REC MEX_PJM_EMKT_SPIN_RSV_RES;
		v_MARKET_PRICE_NAME MARKET_PRICE.MARKET_PRICE_NAME%TYPE;
		v_PREV_AREA VARCHAR2(64) := 'INITVAL';
		v_MARKET_PRICE_ID NUMBER(9);
		v_DATE DATE;
		v_IDX BINARY_INTEGER;
		l_XN_ID NUMBER(9);
BEGIN
		IF p_RECORDS.COUNT = 0 THEN
			RETURN;
		END IF; -- nothing to do

		v_IDX := p_RECORDS.FIRST;
		WHILE p_RECORDS.EXISTS(v_IDX) LOOP
			v_REC := p_RECORDS(v_IDX);
			v_DATE := v_REC.RESPONSE_DATE + (v_REC.RESPONSE_HOUR/24);

			IF v_PREV_AREA <> v_REC.AREA_NAME THEN

				SELECT ITX.TRANSACTION_ID--, R.RESOURCE_NAME
					INTO l_XN_ID--, l_RESOURCE_NAME
					FROM IT_COMMODITY A, INTERCHANGE_TRANSACTION ITX, SUPPLY_RESOURCE R, SERVICE_POINT S
				 WHERE A.COMMODITY_NAME = 'Spinning Reserve'
					 AND S.EXTERNAL_IDENTIFIER = v_REC.AREA_NAME
					 AND R.SERVICE_POINT_ID = S.SERVICE_POINT_ID
				 	 AND ITX.COMMODITY_ID = A.COMMODITY_ID
					 AND ITX.RESOURCE_ID = R.RESOURCE_ID;

				v_MARKET_PRICE_NAME := v_REC.AREA_NAME || ' SPMCP';
				v_MARKET_PRICE_ID := GET_MARKET_PRICE_ID(v_MARKET_PRICE_NAME);

				v_PREV_AREA := v_REC.AREA_NAME;
			END IF;

			PUT_TRAIT_VALUE(v_DATE, l_XN_ID, 2, v_REC.REQUIRED_MW,'SpinResReqdMW', p_STATUS, p_ERROR_MESSAGE);
			PUT_TRAIT_VALUE(v_DATE, l_XN_ID, 2, v_REC.TIER_ONE_MW,'SpinResTier1MW', p_STATUS, p_ERROR_MESSAGE);
			PUT_TRAIT_VALUE(v_DATE, l_XN_ID, 2, v_REC.TIER_TWO_MW,'SpinResTier2MW', p_STATUS, p_ERROR_MESSAGE);
			PUT_TRAIT_VALUE(v_DATE, l_XN_ID, 2, v_REC.SELF_SCHEDULED_MW, 'SpinResSelfScheduledMW', p_STATUS, p_ERROR_MESSAGE);
			PUT_TRAIT_VALUE(v_DATE, l_XN_ID, 2, v_REC.TIER_TWO_ASSIGNED_MW, 'SpinResTier2AssignedMW', p_STATUS, p_ERROR_MESSAGE);
			PUT_TRAIT_VALUE(v_DATE, l_XN_ID, 2, v_REC.TOTAL_MW, 'SpinResTotalMW', p_STATUS, p_ERROR_MESSAGE);
			PUT_TRAIT_VALUE(v_DATE, l_XN_ID, 2, v_REC.DEFICIENCY_MW, 'SpinResDeficiencyMW', p_STATUS, p_ERROR_MESSAGE);
			PUT_MARKET_PRICE_VALUE(v_MARKET_PRICE_ID, v_DATE, v_REC.MCP, p_STATUS, p_ERROR_MESSAGE);

    v_IDX := p_RECORDS.NEXT(v_IDX);
		END LOOP;
END IMPORT_SPIN_RESERVE_RESULTS;
-------------------------------------------------------------------------------------

PROCEDURE QUERY_SPIN_RESERVE_RESULTS
		(
		p_CRED				IN mex_credentials,
		p_REQUEST_DATE IN DATE,
		p_LOG_ONLY IN NUMBER,
		p_STATUS OUT NUMBER,
		p_ERROR_MESSAGE OUT VARCHAR2,
		p_LOGGER IN OUT	mm_logger_adapter
		) AS

    v_RECORDS MEX_PJM_EMKT_SPIN_RSV_RES_TBL;

BEGIN

	p_STATUS    := GA.SUCCESS;

	  IF MM_PJM_UTIL.HAS_ESUITE_ACCESS(g_EMKT_GEN_ATTR, p_CRED.EXTERNAL_ACCOUNT_NAME) THEN
			MEX_PJM_EMKT.FETCH_SPIN_RESERVE_RES(p_CRED, P_LOG_ONLY, P_REQUEST_DATE, v_RECORDS, p_STATUS, p_ERROR_MESSAGE, p_LOGGER);
			IF p_STATUS >= 0 THEN
				IMPORT_SPIN_RESERVE_RESULTS(v_RECORDS, p_STATUS, p_ERROR_MESSAGE);
			END IF;
	  END IF;

EXCEPTION
		WHEN OTHERS THEN
			p_STATUS        := SQLCODE;
			p_ERROR_MESSAGE := PACKAGE_NAME || '.QUERY_SPIN_RESERVE_RESULTS: ' ||
												 UT.GET_FULL_ERRM;

END QUERY_SPIN_RESERVE_RESULTS;
-------------------------------------------------------------------------------------

PROCEDURE QUERY_DISTRIBUTION_FACTORS
	(
	p_CRED				IN mex_credentials,
	p_REQUEST_DATE  IN DATE,
	p_LOCATION_TYPE IN VARCHAR2,
	p_LOCATION_NAME IN VARCHAR2,
	p_LOG_ONLY      IN NUMBER,
	p_STATUS        OUT NUMBER,
	p_ERROR_MESSAGE OUT VARCHAR2,
	p_LOGGER IN OUT	mm_logger_adapter
	) AS

		--Handle Query and Response for 'DistributionFactors'
		v_XML_REQUEST          XMLTYPE;
		v_XML_RESPONSE         XMLTYPE;
		v_XML_LOCATION         XMLTYPE;
		v_AGG_SERVICE_POINT_ID NUMBER(9);
		v_SUB_SERVICE_POINT_ID NUMBER(9);

		CURSOR c_XML IS
			SELECT TO_DATE(EXTRACTVALUE(VALUE(T), '//@day', g_PJM_EMKT_NAMESPACE),
										 g_DATE_FORMAT) "RESPONSE_DATE",
						 EXTRACTVALUE(VALUE(U), '//@location', g_PJM_EMKT_NAMESPACE) "AGGREGATE_LOCATION",
						 EXTRACTVALUE(VALUE(V), '//@location', g_PJM_EMKT_NAMESPACE) "BUS_LOCATION",
						 EXTRACTVALUE(VALUE(V), '//@factor', g_PJM_EMKT_NAMESPACE) "FACTOR"
				FROM TABLE(XMLSEQUENCE(EXTRACT(v_XML_RESPONSE, '//DistributionFactors',
																			 g_PJM_EMKT_NAMESPACE))) T,
						 TABLE(XMLSEQUENCE(EXTRACT(VALUE(T), '//AggregateNode',
																			 g_PJM_EMKT_NAMESPACE))) U,
						 TABLE(XMLSEQUENCE(EXTRACT(VALUE(U), '//BusNode',
																			 g_PJM_EMKT_NAMESPACE))) V;

BEGIN
	p_STATUS := GA.SUCCESS;
		CASE
			WHEN UPPER(p_LOCATION_TYPE) = 'ALL' THEN
				SELECT XMLELEMENT("All") INTO v_XML_LOCATION FROM DUAL;
			WHEN UPPER(p_LOCATION_TYPE) = 'LOCATIONNAME' THEN
				SELECT XMLFOREST(p_LOCATION_NAME AS "LocationName")
					INTO v_XML_LOCATION
					FROM DUAL;
			WHEN UPPER(p_LOCATION_TYPE) = 'PORTFOLIONAME' THEN
				SELECT XMLFOREST(p_LOCATION_NAME AS "PortfolioName")
					INTO v_XML_LOCATION
					FROM DUAL;
		END CASE;

		SELECT XMLELEMENT("QueryRequest",
											XMLATTRIBUTES(g_PJM_EMKT_NAMESPACE_NAME AS "xmlns"),
											XMLELEMENT("QueryDistributionFactors",
																	XMLATTRIBUTES(TO_CHAR(p_REQUEST_DATE,
																												 g_DATE_FORMAT) AS "day"),
																	v_XML_LOCATION))
			INTO v_XML_REQUEST
			FROM DUAL;

		-----------------------------------------------------------------------------------
		--Either Submit the QueryRequest to PJM, or debug with a select from XML_TRACE.
		--Uncomment the desired action, and comment the other one.
		--select xml into v_XML_RESPONSE from XML_TRACE WHERE key1 = 'DistributionFactors'; --DEBUG--TEST!!!
		/*RUN_PJM_QUERY('QueryDistributionFactors', p_LOG_ONLY, v_XML_REQUEST,
									 v_XML_RESPONSE, p_ERROR_MESSAGE);
		*/-----------------------------------------------------------------------------------

		FOR v_XML IN c_XML LOOP
			v_AGG_SERVICE_POINT_ID := MM_PJM_UTIL.ID_FOR_SERVICE_POINT_PNODE(v_XML.AGGREGATE_LOCATION);--, 'Aggregate');
			v_SUB_SERVICE_POINT_ID := MM_PJM_UTIL.ID_FOR_SERVICE_POINT_PNODE(v_XML.BUS_LOCATION);--, 'Bus');

			-- TRUNC(SYSDATE) is BEGIN_DATE
			-- END_DATE is NULL
			-- 100 * v_XML.FACTOR is the ALLOCATION_PCT
			EM.PUT_SUB_SERVICE_POINT(v_AGG_SERVICE_POINT_ID, v_SUB_SERVICE_POINT_ID,
															 TRUNC(SYSDATE), NULL, 100 * v_XML.FACTOR,
															 v_SUB_SERVICE_POINT_ID, TRUNC(SYSDATE));

		END LOOP;

EXCEPTION
		WHEN OTHERS THEN
			p_STATUS        := SQLCODE;
			p_ERROR_MESSAGE := PACKAGE_NAME || '.QUERY_DISTRIBUTION_FACTORS: ' ||
												 UT.GET_FULL_ERRM;

END QUERY_DISTRIBUTION_FACTORS;
-------------------------------------------------------------------------------------

PROCEDURE DISTRIBUTION_FACTORS(p_REQUEST_DATE  IN DATE,
																 p_LOG_ONLY      IN NUMBER,
																 p_STATUS        OUT NUMBER,
																 p_ERROR_MESSAGE OUT VARCHAR2) IS
		v_XML_REQUEST  XMLTYPE;
		v_XML_TEMP     XMLTYPE;

		CURSOR c_AGG_NODES IS
			SELECT DISTINCT A.SERVICE_POINT_ID, A.EXTERNAL_IDENTIFIER
				FROM SERVICE_POINT A, SERVICE_POINT B, SERVICE_POINT_AGGREGATE SPA
			 WHERE A.SERVICE_POINT_ID = SPA.SERVICE_POINT_ID AND
						 B.SERVICE_POINT_ID = SPA.SUB_SERVICE_POINT_ID AND
						 B.NODE_TYPE = 'Bus' AND SPA.BEGIN_DATE <= p_REQUEST_DATE AND
						 (SPA.END_DATE >= p_REQUEST_DATE OR SPA.END_DATE IS NULL);
BEGIN
		FOR l_AGG_NODE IN c_AGG_NODES LOOP
			SELECT XMLAGG(XMLELEMENT("BusNode",
															 XMLATTRIBUTES(A.EXTERNAL_IDENTIFIER AS"location",
																							SPA.ALLOCATION_PCT AS "factor")))
				INTO v_XML_TEMP
				FROM SERVICE_POINT A, SERVICE_POINT_AGGREGATE SPA
			 WHERE SPA.SERVICE_POINT_ID = l_AGG_NODE.SERVICE_POINT_ID AND
						 A.SERVICE_POINT_ID = SPA.SUB_SERVICE_POINT_ID AND
						 SPA.BEGIN_DATE <= p_REQUEST_DATE AND
						 (SPA.END_DATE >= p_REQUEST_DATE OR SPA.END_DATE IS NULL);

			SELECT XMLELEMENT("AggregateNode",
												XMLATTRIBUTES(l_AGG_NODE.EXTERNAL_IDENTIFIER AS
																			 "location"), v_XML_TEMP)
				INTO v_XML_TEMP
				FROM DUAL;

			SELECT XMLCONCAT(v_XML_REQUEST, v_XML_TEMP) INTO v_XML_REQUEST FROM DUAL;

		END LOOP;

		-- Distribution Factors aren't associated w/ bids and offers, so don't do anything
		-- with the submit status or the market status returns
		/*RUN_PJM_SUBMIT('DistributionFactors', p_LOG_ONLY, v_XML_REQUEST, NULL,
										l_SUBMIT_STATUS, l_MARKET_STATUS, p_ERROR_MESSAGE);
*/
EXCEPTION
		WHEN OTHERS THEN
			p_STATUS        := SQLCODE;
			p_ERROR_MESSAGE := PACKAGE_NAME || '.DISTRIBUTION_FACTORS: ' || UT.GET_FULL_ERRM;

END DISTRIBUTION_FACTORS;

-------------------------------------------------------------------------------------

PROCEDURE IMPORT_ANCILLARY_SERV_PRICES
		(
		p_RECORDS IN MEX_PJM_EMKT_ANCILLAR_SERV_TBL,
		p_STATUS OUT NUMBER,
		p_ERROR_MESSAGE OUT VARCHAR2
		) IS
		v_REC MEX_PJM_EMKT_ANCILLAR_SERV;
		v_MARKET_PRICE_NAME MARKET_PRICE.MARKET_PRICE_NAME%TYPE;
		v_PREV_MARKET_PRICE_NAME MARKET_PRICE.MARKET_PRICE_NAME%TYPE := 'INITVAL';
		v_MARKET_PRICE_ID NUMBER(9);
		v_DATE DATE;
		v_IDX BINARY_INTEGER;
v_EXT_ID VARCHAR2(64);
v_COMMODITY_ID IT_COMMODITY.COMMODITY_ID%TYPE;
BEGIN
		IF p_RECORDS.COUNT = 0 THEN
			RETURN;
		END IF; -- nothing to do

		v_IDX := p_RECORDS.FIRST;
		WHILE p_RECORDS.EXISTS(v_IDX) LOOP
			v_REC := p_RECORDS(v_IDX);
			IF v_REC.AREA IS NOT NULL THEN
                IF v_REC.SPMCP IS NOT NULL THEN
                    v_MARKET_PRICE_NAME := 'PJM Spin Res MCP: ' || v_REC.AREA;
                    v_EXT_ID := 'PJM:SpinResMCP:' || v_REC.AREA;
                    ID.ID_FOR_COMMODITY('Spinning Reserve', FALSE, v_COMMODITY_ID);
                ELSIF v_REC.RMCP IS NOT NULL THEN
                    v_MARKET_PRICE_NAME := 'PJM Reg MCP: ' || v_REC.AREA;
                    v_EXT_ID := 'PJM:RegMCP:' || v_REC.AREA;
                    ID.ID_FOR_COMMODITY('Regulation', FALSE, v_COMMODITY_ID);
                END IF;

                IF v_MARKET_PRICE_NAME <> v_PREV_MARKET_PRICE_NAME THEN
    				v_MARKET_PRICE_ID := GET_MARKET_PRICE_ID(v_MARKET_PRICE_NAME, v_EXT_ID, v_COMMODITY_ID);
    				v_PREV_MARKET_PRICE_NAME := v_MARKET_PRICE_NAME;
    			END IF;

                v_DATE := v_REC.DAY + (v_REC.HOUR/24);
				IF v_REC.SPMCP IS NOT NULL THEN
					PUT_MARKET_PRICE_VALUE(v_MARKET_PRICE_ID, v_DATE, v_REC.SPMCP, p_STATUS, p_ERROR_MESSAGE);
				ELSIF v_REC.RMCP IS NOT NULL THEN
					PUT_MARKET_PRICE_VALUE(v_MARKET_PRICE_ID, v_DATE, v_REC.RMCP, p_STATUS, p_ERROR_MESSAGE);
				END IF;

            END IF;

		/*	IF v_REC.AREA IS NOT NULL THEN
				IF v_REC.RESERVE_ZONE IS NOT NULL THEN
					v_MARKET_PRICE_NAME := v_REC.AREA || ' ' || v_REC.RESERVE_ZONE || ' Spinning Reserve';
				ELSE
					v_MARKET_PRICE_NAME := v_REC.AREA || ' Spinning Reserve';
				END IF;
				IF v_MARKET_PRICE_NAME <> v_PREV_MARKET_PRICE_NAME THEN
					v_MARKET_PRICE_ID := GET_MARKET_PRICE_ID(v_MARKET_PRICE_NAME);
					v_PREV_MARKET_PRICE_NAME := v_MARKET_PRICE_NAME;
				END IF;

				v_DATE := v_REC.DAY + (v_REC.HOUR/24);
				IF v_REC.SPMCP IS NOT NULL THEN
					PUT_MARKET_PRICE_VALUE(v_MARKET_PRICE_ID, v_DATE, v_REC.SPMCP, p_STATUS, p_ERROR_MESSAGE);
				ELSIF v_REC.RMCP IS NOT NULL THEN
					PUT_MARKET_PRICE_VALUE(v_MARKET_PRICE_ID, v_DATE, v_REC.RMCP, p_STATUS, p_ERROR_MESSAGE);
				END IF;
			END IF;*/

		v_IDX := p_RECORDS.NEXT(v_IDX);
    END LOOP;
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        p_STATUS        := SQLCODE;
        p_ERROR_MESSAGE := 'Error in MM_PJM_EMKT.IMPORT_ANCILLARY_SERV_PRICES: ' || UT.GET_FULL_ERRM;

END IMPORT_ANCILLARY_SERV_PRICES;

-------------------------------------------------------------------------------------

PROCEDURE QUERY_ANCILLARY_SERVICE_PRICES
		(
		p_CRED				IN mex_credentials,
		p_LOG_ONLY			IN NUMBER,
		p_REQUEST_DATE IN DATE,
		p_STATUS OUT NUMBER,
		p_ERROR_MESSAGE OUT VARCHAR2,
		p_LOGGER IN OUT	mm_logger_adapter
		) IS

    v_RECORDS MEX_PJM_EMKT_ANCILLAR_SERV_TBL;

BEGIN

	p_STATUS    := GA.SUCCESS;
	MEX_PJM_EMKT.FETCH_ANCILLARY_SERV(p_CRED, p_LOG_ONLY, p_REQUEST_DATE, v_RECORDS, p_STATUS, p_ERROR_MESSAGE, p_LOGGER);
	IF p_STATUS >= 0 THEN
		IMPORT_ANCILLARY_SERV_PRICES(v_RECORDS, p_STATUS, p_ERROR_MESSAGE);
	END IF;

EXCEPTION
		WHEN OTHERS THEN
		p_STATUS        := SQLCODE;
		p_ERROR_MESSAGE := PACKAGE_NAME || '.QUERY_ANCILLARY_SERVICE_PRICES: ' || UT.GET_FULL_ERRM;

END QUERY_ANCILLARY_SERVICE_PRICES;

-------------------------------------------------------------------------------------
PROCEDURE IMPORT_FIXED_DEMAND
		(
		p_TRANSACTION_ID   IN NUMBER,
		p_ACCOUNT_NAME IN VARCHAR2,
		p_RECORDS IN MEX_PJM_EMKT_FIXED_DEMAND_TBL,
		p_STATUS OUT NUMBER,
		p_ERROR_MESSAGE OUT VARCHAR2
		) AS
		v_TXN_ID       INTERCHANGE_TRANSACTION.TRANSACTION_ID%TYPE;
		v_IDX NUMBER;
		v_LOCATION     SERVICE_POINT.EXTERNAL_IDENTIFIER%TYPE := NULL;
BEGIN
		p_STATUS := GA.SUCCESS;

		IF p_RECORDS.COUNT = 0 THEN
			RETURN;
		END IF; -- nothing to do

		v_IDX := p_RECORDS.FIRST;
		WHILE p_RECORDS.EXISTS(v_IDX) LOOP
			IF v_LOCATION IS NULL OR v_LOCATION <> p_RECORDS(v_IDX).LOCATION THEN
				v_LOCATION := p_RECORDS(v_IDX).LOCATION;
				IF p_TRANSACTION_ID IS NULL THEN
					-- get the fixed demand transaction
					MM_PJM_EMKT_UTIL.GET_TRANSACTION_ID(p_ACCOUNT_NAME, v_LOCATION, 'Load', MM_PJM_UTIL.g_COMM_DA_ENERGY, 0, 1, TRUE, v_TXN_ID, p_ERROR_MESSAGE);
				ELSE
					v_TXN_ID := p_TRANSACTION_ID;
				END IF;
			END IF;
			BO.PUT_BID_OFFER_SET(p_TRANSACTION_ID => v_TXN_ID,
													 p_BID_OFFER_ID   => 0,
													 p_SCHEDULE_STATE => 2,
													 p_SCHEDULE_DATE  => p_RECORDS(v_IDX)
																							.RESPONSE_DATE + TO_NUMBER(p_RECORDS(v_IDX).HOUR) / 24,
													 p_SET_NUMBER     => 1,
													 p_PRICE          => NULL,
													 p_QUANTITY       => p_RECORDS(v_IDX).FIXED_DEMAND,
													 p_OFFER_STATUS   => 'P',
													 p_TIME_ZONE      => MM_PJM_EMKT_UTIL.g_PJM_TIME_ZONE,
													 p_STATUS         => p_STATUS);
			v_IDX := p_RECORDS.NEXT(v_IDX);
		END LOOP;
		COMMIT;
EXCEPTION
		WHEN OTHERS THEN
			p_STATUS        := SQLCODE;
			p_ERROR_MESSAGE := PACKAGE_NAME || '.IMPORT_FIXED_DEMAND: ' || UT.GET_FULL_ERRM;
END IMPORT_FIXED_DEMAND;

-------------------------------------------------------------------------------------

PROCEDURE FIXED_DEMAND_BID(p_TRANSACTION_ID IN NUMBER,
                             p_SCHEDULE_DATE     IN DATE,
							 p_REQUEST_TYPE	  OUT VARCHAR2,
                             p_SUBMIT_XML     OUT XMLTYPE,
                             p_STATUS         OUT NUMBER,
                             p_MESSAGE        OUT VARCHAR2) AS

    v_BEGIN_DATE          DATE;
    v_END_DATE            DATE;
    v_RECORDS             MEX_PJM_EMKT_FIXED_DEMAND_TBL;

BEGIN
    p_STATUS := GA.SUCCESS;

      UT.CUT_DATE_RANGE(p_MODEL_ID       => GA.ELECTRIC_MODEL,
                        p_BEGIN_DATE     => p_SCHEDULE_DATE,
                        p_END_DATE       => p_SCHEDULE_DATE,
												p_TIME_ZONE      => 'EDT',
                        p_CUT_BEGIN_DATE => v_BEGIN_DATE,
                        p_CUT_END_DATE   => v_END_DATE);

        p_REQUEST_TYPE := 'SubmitFixedDemand';

		SELECT MEX_PJM_EMKT_FIXED_DEMAND(
			D.SCHEDULE_DATE,
			F.EXTERNAL_IDENTIFIER,
			NULL, -- Hour will be computed in MEX
			D.QUANTITY)
		BULK COLLECT INTO v_RECORDS
		FROM BID_OFFER_SET D,
			 INTERCHANGE_TRANSACTION E,
			 SERVICE_POINT F
		WHERE E.TRANSACTION_ID = p_TRANSACTION_ID
			AND F.SERVICE_POINT_ID = E.POD_ID
			AND D.TRANSACTION_ID = p_TRANSACTION_ID
			AND D.SCHEDULE_STATE = 1
			AND D.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		ORDER BY D.SCHEDULE_DATE, D.SET_NUMBER;

		IF v_RECORDS.COUNT > 0 THEN
			MEX_PJM_EMKT.GETX_SUBMIT_FIXED_DEMAND(p_RECORDS       => v_RECORDS,
		                                 p_SUBMIT_XML    => p_SUBMIT_XML,
		                                 p_STATUS        => p_STATUS,
		                                 p_MESSAGE       => p_MESSAGE);
		END IF;
END FIXED_DEMAND_BID;
-------------------------------------------------------------------------------------
PROCEDURE IMPORT_DEMAND_BIDS(p_ACCOUNT_NAME IN VARCHAR2,
								p_COPY_INTERNAL IN BOOLEAN,
  														 p_RECORDS             IN MEX_PJM_EMKT_DEMAND_BID_TBL,
  														 p_STATUS              OUT NUMBER,
  														 p_ERROR_MESSAGE       OUT VARCHAR2) AS
  	v_FIXED_TXN_ID INTERCHANGE_TRANSACTION.TRANSACTION_ID%TYPE;
  	v_PS_TXN_ID    INTERCHANGE_TRANSACTION.TRANSACTION_ID%TYPE;
  	v_IDX          NUMBER;
  	v_LOCATION     SERVICE_POINT.EXTERNAL_IDENTIFIER%TYPE := NULL;
    v_SCHEDULE_DATE DATE;
  BEGIN
  	p_STATUS := GA.SUCCESS;

  	IF p_RECORDS.COUNT = 0 THEN
  		RETURN;
  	END IF; -- nothing to do

  	v_IDX := p_RECORDS.FIRST;
  	WHILE p_RECORDS.EXISTS(v_IDX) LOOP
      IF v_LOCATION IS NULL OR v_LOCATION <> p_RECORDS(v_IDX).LOCATION THEN
	      v_LOCATION     := p_RECORDS(v_IDX).LOCATION;

  	    -- get the fixed demand transaction
    	  MM_PJM_EMKT_UTIL.GET_TRANSACTION_ID(p_ACCOUNT_NAME, v_LOCATION, 'Load', MM_PJM_UTIL.g_COMM_DA_ENERGY, 0, 1, TRUE, v_FIXED_TXN_ID, p_ERROR_MESSAGE);

      	-- now the price-sensitive demand transaction
	      MM_PJM_EMKT_UTIL.GET_TRANSACTION_ID(p_ACCOUNT_NAME, v_LOCATION, 'Load', MM_PJM_UTIL.g_COMM_DA_ENERGY, 0, 0, TRUE, v_PS_TXN_ID, p_ERROR_MESSAGE);
      END IF;

			v_SCHEDULE_DATE := p_RECORDS(v_IDX).RESPONSE_DATE; -- THIS DATE HAS ALREADY BEEN ADJUSTED TO CUT.

      IF p_RECORDS(v_IDX).FIXED_DEMAND IS NOT NULL THEN
	      TG.PUT_IT_TRAIT_SCHEDULE(v_FIXED_TXN_ID, GA.EXTERNAL_STATE, 0, v_SCHEDULE_DATE, TG.g_TG_OFFER_CURVE, TG.g_TI_OFFER_QUANTITY, 1, p_RECORDS(v_IDX).FIXED_DEMAND, CUT_TIME_ZONE);
    	  IF p_COPY_INTERNAL THEN
  	  	  TG.PUT_IT_TRAIT_SCHEDULE(v_FIXED_TXN_ID, GA.INTERNAL_STATE, 0, v_SCHEDULE_DATE, TG.g_TG_OFFER_CURVE, TG.g_TI_OFFER_QUANTITY, 1, p_RECORDS(v_IDX).FIXED_DEMAND, CUT_TIME_ZONE);
	      END IF;
			END IF;

  		IF p_RECORDS(v_IDX).SEGMENT_ID IS NOT NULL THEN
			TG.PUT_IT_TRAIT_SCHEDULE(v_PS_TXN_ID, GA.EXTERNAL_STATE, 0, v_SCHEDULE_DATE, TG.g_TG_OFFER_CURVE, TG.g_TI_OFFER_QUANTITY, p_RECORDS(v_IDX).SEGMENT_ID, p_RECORDS(v_IDX).QUANTITY, CUT_TIME_ZONE);
			TG.PUT_IT_TRAIT_SCHEDULE(v_PS_TXN_ID, GA.EXTERNAL_STATE, 0, v_SCHEDULE_DATE, TG.g_TG_OFFER_CURVE, TG.g_TI_OFFER_PRICE, p_RECORDS(v_IDX).SEGMENT_ID, p_RECORDS(v_IDX).PRICE, CUT_TIME_ZONE);

			IF p_COPY_INTERNAL THEN
				TG.PUT_IT_TRAIT_SCHEDULE(v_PS_TXN_ID, GA.INTERNAL_STATE, 0, v_SCHEDULE_DATE, TG.g_TG_OFFER_CURVE, TG.g_TI_OFFER_QUANTITY, p_RECORDS(v_IDX).SEGMENT_ID, p_RECORDS(v_IDX).QUANTITY, CUT_TIME_ZONE);
				TG.PUT_IT_TRAIT_SCHEDULE(v_PS_TXN_ID, GA.INTERNAL_STATE, 0, v_SCHEDULE_DATE, TG.g_TG_OFFER_CURVE, TG.g_TI_OFFER_PRICE, p_RECORDS(v_IDX).SEGMENT_ID, p_RECORDS(v_IDX).PRICE, CUT_TIME_ZONE);
			END IF;
      END IF;
			v_IDX := p_RECORDS.NEXT(v_IDX);
  	END LOOP;
  	COMMIT;
EXCEPTION
  	WHEN OTHERS THEN
  		p_STATUS        := SQLCODE;
  		p_ERROR_MESSAGE := PACKAGE_NAME || '.IMPORT_DEMAND_BIDS: ' || UT.GET_FULL_ERRM;
END IMPORT_DEMAND_BIDS;

-------------------------------------------------------------------------------------

PROCEDURE QUERY_DEMAND_BIDS(p_CRED				IN mex_credentials,
							p_BEGIN_DATE    IN DATE,
							p_END_DATE      IN DATE,
							p_LOCATION_NAME IN VARCHAR2,
							p_COPY_INTERNAL IN BOOLEAN,
							p_LOG_ONLY      IN NUMBER,
							p_STATUS        OUT NUMBER,
							p_ERROR_MESSAGE OUT VARCHAR2,
							p_LOGGER IN OUT	mm_logger_adapter
							) AS

	v_RECORDS   MEX_PJM_EMKT_DEMAND_BID_TBL;

	v_LOCATION_TYPE VARCHAR2(30);
	v_LOCATION_NAME VARCHAR2(30);

BEGIN
		p_STATUS    := GA.SUCCESS;
		IF MM_PJM_UTIL.HAS_ESUITE_ACCESS(g_EMKT_LOAD_ATTR, p_CRED.EXTERNAL_ACCOUNT_NAME) THEN

			IF UPPER(P_LOCATION_NAME) = 'ALL' OR p_LOCATION_NAME IS NULL THEN
				v_LOCATION_TYPE := P_LOCATION_NAME;
				v_LOCATION_NAME := 'All';
			ELSE
				v_LOCATION_TYPE := 'LOCATIONNAME';
				v_LOCATION_NAME := p_LOCATION_NAME;
			END IF;

			MEX_PJM_EMKT.FETCH_DEMAND_BIDS(p_CRED, p_LOG_ONLY, v_LOCATION_TYPE, v_LOCATION_NAME,
										   p_BEGIN_DATE, p_END_DATE, v_RECORDS, p_STATUS, p_ERROR_MESSAGE, p_LOGGER);
			IF p_STATUS >= 0 THEN
				IMPORT_DEMAND_BIDS(p_CRED.EXTERNAL_ACCOUNT_NAME, 	p_COPY_INTERNAL, v_RECORDS, p_STATUS, p_ERROR_MESSAGE);
			END IF;
		END IF;

EXCEPTION
		WHEN OTHERS THEN
			p_STATUS        := SQLCODE;
			p_ERROR_MESSAGE := PACKAGE_NAME || '.QUERY_DEMAND_BIDS: ' || UT.GET_FULL_ERRM;

END QUERY_DEMAND_BIDS;
------------------------------------------------------------------------------------
PROCEDURE IMPORT_DEMAND_BIDS_FILE
	(
	p_CLOB IN CLOB,
	p_ISO_ACCOUNT_NAME IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR2
	) AS
    v_RECORDS MEX_PJM_EMKT_DEMAND_BID_TBL := MEX_PJM_EMKT_DEMAND_BID_TBL();
BEGIN
		--FOR DEBUGGING PURPOSES.
		MEX_PJM_EMKT.PARSE_DEMAND_BIDS(XMLTYPE.CREATEXML(p_CLOB), v_RECORDS, p_STATUS, p_MESSAGE);
		IF p_STATUS >= 0 THEN
			IMPORT_DEMAND_BIDS(p_ISO_ACCOUNT_NAME, FALSE, v_RECORDS, p_STATUS, p_MESSAGE);
		END IF;

END IMPORT_DEMAND_BIDS_FILE;
 --------------------------------------------------------------------
FUNCTION GET_BID_OFFER_TRAIT_VAL
	(
	p_TRAIT_NAME IN VARCHAR2,
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SCHEDULE_DATE IN DATE,
	p_CONVERT_TO_BOOL IN BOOLEAN := FALSE
	) RETURN VARCHAR2 IS

	v_TRAIT_VAL IT_TRAIT_SCHEDULE.TRAIT_VAL%TYPE := NULL;
	v_SCHEDULE_DATE DATE;
	v_TRAIT_ID NUMBER(9);
	v_TRAIT_INTERVAL VARCHAR2(16);
BEGIN

	SELECT TRAIT_GROUP_ID, TRAIT_GROUP_INTERVAL
	INTO v_TRAIT_ID, v_TRAIT_INTERVAL
	FROM TRANSACTION_TRAIT_GROUP
	WHERE TRAIT_GROUP_NAME = p_TRAIT_NAME;

	v_SCHEDULE_DATE := CASE WHEN v_TRAIT_INTERVAL = 'Day' THEN TRUNC(p_SCHEDULE_DATE) + 1/86400 ELSE p_SCHEDULE_DATE END;

	BEGIN
		SELECT B.TRAIT_VAL INTO v_TRAIT_VAL
		FROM BID_OFFER_TRAIT B
		WHERE B.TRANSACTION_ID = p_TRANSACTION_ID
			AND B.SCHEDULE_STATE = p_SCHEDULE_STATE
			AND B.SCHEDULE_DATE = v_SCHEDULE_DATE
			AND B.RESOURCE_TRAIT_ID = v_TRAIT_ID;
	EXCEPTION WHEN NO_DATA_FOUND THEN
		v_TRAIT_VAL := NULL;
	END;

	IF p_CONVERT_TO_BOOL = TRUE THEN
		IF v_TRAIT_VAL = 0 OR v_TRAIT_VAL IS NULL THEN
			v_TRAIT_VAL := 'false';
		ELSE
			v_TRAIT_VAL := 'true';
		END IF;
	END IF;

	RETURN v_TRAIT_VAL;
END GET_BID_OFFER_TRAIT_VAL;

-------------------------------------------------------------------------------------
--TODO: REMOVE TEMPLATE STUFF
-- 	FUNCTION GET_BID_OFFER_TEMPLATE_VAL(p_TRAIT_NAME    IN VARCHAR2,
-- 																			p_TEMPLATE_ID   IN NUMBER,
-- 																			p_INTERVAL_DATE IN DATE) RETURN VARCHAR2 IS
-- 		v_TRAIT_VAL RESOURCE_TEMPLATE_VAL.TRAIT_VAL%TYPE;
-- 	BEGIN
--
-- 		BEGIN
-- 			SELECT A.TRAIT_VAL
-- 				INTO v_TRAIT_VAL
-- 				FROM RESOURCE_TEMPLATE_VAL A, RESOURCE_TRAIT B
-- 			 WHERE B.RESOURCE_TRAIT_NAME = p_TRAIT_NAME AND
-- 						 A.RESOURCE_TEMPLATE_ID = p_TEMPLATE_ID AND
-- 						 A.RESOURCE_TRAIT_ID = B.RESOURCE_TRAIT_ID AND
-- 						 A.INTERVAL_DATE = p_INTERVAL_DATE;
--
-- 		EXCEPTION
-- 			WHEN NO_DATA_FOUND THEN
-- 				v_TRAIT_VAL := NULL;
-- 		END;
--
-- 		RETURN v_TRAIT_VAL;
--
-- 	END GET_BID_OFFER_TEMPLATE_VAL;
-- 	-------------------------------------------------------------------------------------

PROCEDURE IMPORT_VIRTUAL_BIDS(p_COPY_INTERNAL IN BOOLEAN,
                                p_TRANSACTION_ID IN NUMBER,
                                p_RECORDS IN MEX_PJM_EMKT_VIRTUAL_BIDS_TBL,
                                p_ACCOUNT_NAME IN VARCHAR2,
                                p_STATUS OUT NUMBER,
                                p_ERROR_MESSAGE OUT VARCHAR2) AS

	v_IDX NUMBER;
	v_TXN_ID        INTERCHANGE_TRANSACTION.TRANSACTION_ID%TYPE;
	v_LOCATION     SERVICE_POINT.EXTERNAL_IDENTIFIER%TYPE := NULL;
	v_TRANSACTION_TYPE VARCHAR2(32);
    v_SCHEDULE_DATE DATE;
BEGIN
	p_STATUS := GA.SUCCESS;

	IF p_RECORDS.COUNT = 0 THEN
		RETURN;
	END IF; -- nothing to do

	v_IDX := p_RECORDS.FIRST;
	WHILE p_RECORDS.EXISTS(v_IDX) LOOP
        IF p_TRANSACTION_ID IS NOT NULL THEN
    			v_TXN_ID := p_TRANSACTION_ID;
        ELSE
            -- if the location or the inc/dec type is different, we need a new transaction
            IF v_LOCATION IS NULL OR v_LOCATION <> p_RECORDS(v_IDX).LOCATION THEN
                v_LOCATION := p_RECORDS(v_IDX).LOCATION;
                IF p_RECORDS(v_IDX).INC_DEC_TYPE LIKE 'I%' THEN
					v_TRANSACTION_TYPE := 'Generation';
				ELSE
					v_TRANSACTION_TYPE := 'Load';
				END IF;
				MM_PJM_EMKT_UTIL.GET_TRANSACTION_ID(p_ACCOUNT_NAME, p_RECORDS(v_IDX).LOCATION, v_TRANSACTION_TYPE, MM_PJM_UTIL.g_COMM_VIRTUAL, 0, 0, TRUE, v_TXN_ID, p_ERROR_MESSAGE);
    		END IF;
        END IF;
         v_SCHEDULE_DATE := TO_CUT_WITH_OPTIONS(p_RECORDS(v_IDX).RESPONSE_DATE, MM_PJM_EMKT_UTIL.g_PJM_TIME_ZONE,
                                            MM_PJM_UTIL.g_DST_SPRING_AHEAD_OPTION);

    		-- the data is coming back from MEX already in CUT, so we use that time zone here
    		BO.PUT_BID_OFFER_SET(p_TRANSACTION_ID => v_TXN_ID,
												 p_BID_OFFER_ID   => 0,
												 p_SCHEDULE_STATE => MM_PJM_UTIL.g_EXTERNAL_STATE,
												 p_SCHEDULE_DATE  => v_SCHEDULE_DATE,
												 p_SET_NUMBER     => p_RECORDS(v_IDX).SEGMENT_ID,
												 p_PRICE          => p_RECORDS(v_IDX).PRICE,
												 p_QUANTITY       => p_RECORDS(v_IDX).QUANTITY,
												 p_OFFER_STATUS   => 'P',
												 p_TIME_ZONE      => CUT_TIME_ZONE,
												 p_STATUS         => p_STATUS);
        IF p_COPY_INTERNAL THEN
        	BO.PUT_BID_OFFER_SET(p_TRANSACTION_ID => v_TXN_ID,
								 p_BID_OFFER_ID   => 0,
								 p_SCHEDULE_STATE => MM_PJM_UTIL.g_INTERNAL_STATE,
								 p_SCHEDULE_DATE  => v_SCHEDULE_DATE,
								 p_SET_NUMBER     => p_RECORDS(v_IDX).SEGMENT_ID,
								 p_PRICE          => p_RECORDS(v_IDX).PRICE,
								 p_QUANTITY       => p_RECORDS(v_IDX).QUANTITY,
								 p_OFFER_STATUS   => 'P',
								 p_TIME_ZONE      => CUT_TIME_ZONE,
								 p_STATUS         => p_STATUS);
        END IF;
   		v_IDX := p_RECORDS.NEXT(v_IDX);
	END LOOP;
	COMMIT;
EXCEPTION
	WHEN OTHERS THEN
		p_STATUS        := SQLCODE;
		p_ERROR_MESSAGE := PACKAGE_NAME || '.IMPORT_VIRTUAL_BIDS: ' || UT.GET_FULL_ERRM;
END IMPORT_VIRTUAL_BIDS;
-------------------------------------------------------------------------------------

PROCEDURE QUERY_VIRTUAL_BIDS(
							 p_CRED				IN mex_credentials,
							 p_REQUEST_DATE   IN DATE,
                             p_TRANSACTION_ID IN NUMBER,
                             p_LOCATION_NAME  IN VARCHAR2,
                             p_COPY_INTERNAL  IN BOOLEAN,
                             p_LOG_ONLY       IN NUMBER,
                             p_STATUS         OUT NUMBER,
                             p_ERROR_MESSAGE  OUT VARCHAR2,
							 p_LOGGER IN OUT	mm_logger_adapter
							 ) AS

    v_RECORDS   MEX_PJM_EMKT_VIRTUAL_BIDS_TBL;

	v_LOCATION_TYPE VARCHAR2(30);
	v_LOCATION_NAME VARCHAR2(30);
BEGIN
    p_STATUS    := GA.SUCCESS;
	IF MM_PJM_UTIL.HAS_ESUITE_ACCESS(g_EMKT_GEN_ATTR, p_CRED.EXTERNAL_ACCOUNT_NAME)
		OR MM_PJM_UTIL.HAS_ESUITE_ACCESS(g_EMKT_LOAD_ATTR, p_CRED.EXTERNAL_ACCOUNT_NAME) THEN

			IF UPPER(P_LOCATION_NAME) = 'ALL' THEN
				v_LOCATION_TYPE := 'All';
			ELSE
				v_LOCATION_TYPE := 'LOCATIONNAME';
				v_LOCATION_NAME := p_LOCATION_NAME;
			END IF;

			MEX_PJM_EMKT.FETCH_VIRTUAL_BIDS(p_CRED, p_LOG_ONLY, v_LOCATION_TYPE, v_LOCATION_NAME, p_REQUEST_DATE, v_RECORDS, p_STATUS, p_ERROR_MESSAGE, p_LOGGER);
			IF p_STATUS >= 0 THEN
				IMPORT_VIRTUAL_BIDS(p_COPY_INTERNAL,
									p_TRANSACTION_ID,
									v_RECORDS,
									p_CRED.EXTERNAL_ACCOUNT_NAME,
									p_STATUS,
									p_ERROR_MESSAGE);
			END IF;
	END IF;

EXCEPTION
    WHEN OTHERS THEN
        p_STATUS        := SQLCODE;
        p_ERROR_MESSAGE := PACKAGE_NAME || '.QUERY_VIRTUAL_BIDS: ' || UT.GET_FULL_ERRM;

END QUERY_VIRTUAL_BIDS;
-------------------------------------------------------------------------------------
 PROCEDURE VIRTUAL_BID(p_TRANSACTION_ID IN NUMBER,
                        p_IS_INCREMENT   IN BOOLEAN,
                        p_SCHEDULE_STATE IN NUMBER,
                        p_SCHEDULE_DATE  IN DATE,
                        p_TIME_ZONE      IN VARCHAR2,
						p_REQUEST_TYPE	 OUT VARCHAR2,
                        p_SUBMIT_XML     OUT XMLTYPE,
												p_STATUS         OUT NUMBER,
												p_MESSAGE        OUT VARCHAR2) AS

    v_RECORDS             MEX_PJM_EMKT_VIRTUAL_BIDS_TBL;
    v_IS_INCREMENT        VARCHAR2(3);
    v_BEGIN_DATE          DATE;
    v_END_DATE            DATE;
    l_LOCATION            SERVICE_POINT.EXTERNAL_IDENTIFIER%TYPE;

BEGIN

	p_STATUS := MEX_UTIL.g_SUCCESS;
    v_IS_INCREMENT := CASE p_IS_INCREMENT WHEN TRUE THEN 'INC' ELSE 'DEC' END;

    SELECT SVC_PT.EXTERNAL_IDENTIFIER
      INTO l_LOCATION
      FROM SERVICE_POINT SVC_PT, INTERCHANGE_TRANSACTION ITX
     WHERE ITX.TRANSACTION_ID = p_TRANSACTION_ID
       AND ITX.POD_ID = SVC_PT.SERVICE_POINT_ID;

      UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL,
                        p_SCHEDULE_DATE,
                        p_TIME_ZONE,
                        v_BEGIN_DATE,
                        v_END_DATE);

        p_REQUEST_TYPE := 'SubmitVirtualBid';

		SELECT MEX_PJM_EMKT_VIRTUAL_BIDS(D.SCHEDULE_DATE,
			l_LOCATION,
			D.SET_NUMBER,
			D.QUANTITY,
			D.PRICE,
			v_IS_INCREMENT)
		BULK COLLECT INTO v_RECORDS
		FROM BID_OFFER_SET D, INTERCHANGE_TRANSACTION E
		WHERE E.TRANSACTION_ID = p_TRANSACTION_ID
			AND D.TRANSACTION_ID = p_TRANSACTION_ID
			AND D.SCHEDULE_STATE = p_SCHEDULE_STATE
			AND D.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		ORDER BY D.SCHEDULE_DATE, D.SET_NUMBER;

	IF v_RECORDS.COUNT > 0 THEN
		MEX_PJM_EMKT.GETX_SUBMIT_VIRTUAL_BID(p_RECORDS => v_RECORDS,
	                                         p_SUBMIT_XML => p_SUBMIT_XML,
	                                         p_STATUS => P_STATUS,
	                                         p_MESSAGE => p_MESSAGE);

	END IF;

EXCEPTION
		WHEN OTHERS THEN
			p_STATUS  := SQLCODE;
			p_MESSAGE := PACKAGE_NAME || '.VIRTUAL_BID: ' || UT.GET_FULL_ERRM;

END VIRTUAL_BID;

-------------------------------------------------------------------------------------
PROCEDURE PRICE_SENSITIVE_DEMAND_BID(p_TRANSACTION_ID IN NUMBER,
                                     p_SCHEDULE_DATE     IN DATE,
									 p_REQUEST_TYPE	  OUT VARCHAR2,
                                     p_SUBMIT_XML     OUT XMLTYPE,
                                     p_STATUS         OUT NUMBER,
                                     p_MESSAGE        OUT VARCHAR2) AS

  v_BEGIN_DATE          DATE;
  v_END_DATE            DATE;
  v_RECORDS             MEX_PJM_EMKT_PRICE_SEN_DMD_TBL;
BEGIN

  p_STATUS := GA.SUCCESS;

    UT.CUT_DATE_RANGE(p_MODEL_ID       => GA.ELECTRIC_MODEL,
                      p_BEGIN_DATE     => p_SCHEDULE_DATE,
                      p_END_DATE       => p_SCHEDULE_DATE,
                      p_TIME_ZONE      => 'EDT',
                      p_CUT_BEGIN_DATE => v_BEGIN_DATE,
                      p_CUT_END_DATE   => v_END_DATE);

    p_REQUEST_TYPE := 'SubmitPriceSensitiveDemand';

	SELECT MEX_PJM_EMKT_PRICE_SEN_DMD(
		D.SCHEDULE_DATE,
		F.EXTERNAL_IDENTIFIER,
		NULL, -- Hour will be computed in MEX
		D.SET_NUMBER,
		ROUND(D.QUANTITY, 1),
		ROUND(D.PRICE, 2))
	BULK COLLECT INTO v_RECORDS
	FROM BID_OFFER_SET D,
		 INTERCHANGE_TRANSACTION E,
		 SERVICE_POINT F
	WHERE E.TRANSACTION_ID = p_TRANSACTION_ID
		AND F.SERVICE_POINT_ID = E.POD_ID
		AND D.TRANSACTION_ID = p_TRANSACTION_ID
		AND D.SCHEDULE_STATE = 1
		AND D.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
	ORDER BY D.SCHEDULE_DATE, D.SET_NUMBER;

    IF v_RECORDS.COUNT > 0 THEN
      MEX_PJM_EMKT.GETX_SUBMIT_PRICE_SENS_DEMAND(p_RECORDS       => v_RECORDS,
                                                  p_SUBMIT_XML    => p_SUBMIT_XML,
                                                  p_STATUS        => p_STATUS,
                                                  p_MESSAGE       => p_MESSAGE);
    END IF;

END PRICE_SENSITIVE_DEMAND_BID;
-------------------------------------------------------------------------------------
PROCEDURE IMPORT_UNIT_LIST(p_RECORDS             IN MEX_PJM_EMKT_UNIT_DETAIL_TBL,
                           p_STATUS              OUT NUMBER,
                           p_ERROR_MESSAGE       OUT VARCHAR2) IS

    v_RESOURCE_NAME        SUPPLY_RESOURCE.RESOURCE_NAME%TYPE;
    v_RESOURCE_ID          SUPPLY_RESOURCE.RESOURCE_ID%TYPE;
    v_RESOURCE             SUPPLY_RESOURCE%ROWTYPE;
    v_IDX                  BINARY_INTEGER;
    v_PNODEID_ATTRIBUTE_ID NUMBER;
	v_ENTITY_DOMAIN_ID NUMBER(9);
	v_BEGIN_DATE DATE;
BEGIN
	p_STATUS := GA.SUCCESS;

    IF p_RECORDS.COUNT = 0 THEN
        RETURN;
    END IF; -- nothing to do

    v_RESOURCE_NAME := NULL;
    v_IDX           := p_RECORDS.FIRST;
	v_BEGIN_DATE := TRUNC(SYSDATE, 'DD');
    WHILE p_RECORDS.EXISTS(v_IDX) LOOP
        v_RESOURCE_NAME := p_RECORDS(v_IDX).LOCATION;
        v_RESOURCE      := MM_PJM_EMKT_UTIL.GET_RESOURCE_FOR_PJM_PNODEID(v_RESOURCE_NAME);
        v_RESOURCE_ID   := v_RESOURCE.RESOURCE_ID;
        IF v_RESOURCE_ID IS NULL THEN
            IO.PUT_SUPPLY_RESOURCE(v_RESOURCE_ID, v_RESOURCE_NAME, v_RESOURCE_NAME, v_RESOURCE_NAME, 0, 0, 0, 0);

            ID.ID_FOR_ENTITY_ATTRIBUTE('PJM_PNODEID', EC.ED_SUPPLY_RESOURCE, 'String', FALSE, v_PNODEID_ATTRIBUTE_ID);
			ID.ID_FOR_ENTITY_DOMAIN_ALIAS('Resource', v_ENTITY_DOMAIN_ID);

            EM.PUT_ENTITY_ATTRIBUTE_VALUE(p_OWNER_ENTITY_DOMAIN_ID    =>v_ENTITY_DOMAIN_ID,
                                          p_OWNER_ENTITY_ID           =>v_RESOURCE_ID,
                                          p_ATTRIBUTE_ID              =>v_PNODEID_ATTRIBUTE_ID,
                                          p_BEGIN_DATE                =>v_BEGIN_DATE,
                                          p_END_DATE                  =>NULL,
                                          p_ATTRIBUTE_VAL             =>v_RESOURCE_NAME,
                                          p_OLD_OWNER_ENTITY_ID       =>v_RESOURCE_ID,
                                          p_OLD_ATTRIBUTE_ID          =>v_PNODEID_ATTRIBUTE_ID,
                                          p_OLD_BEGIN_DATE            =>v_BEGIN_DATE);

        END IF;
        v_IDX := p_RECORDS.NEXT(v_IDX);
    END LOOP;

END IMPORT_UNIT_LIST;
-------------------------------------------------------------------------------------
PROCEDURE QUERY_UNIT_LIST
	(
	p_CRED				IN mex_credentials,
	p_REQUEST_DATE  IN DATE,
	p_LOCATION_TYPE IN VARCHAR2,
	p_LOCATION_NAME IN VARCHAR2,
	p_LOG_ONLY      IN NUMBER,
	p_STATUS        OUT NUMBER,
	p_ERROR_MESSAGE OUT VARCHAR2,
	p_LOGGER IN OUT	mm_logger_adapter
	) AS

	v_RECORDS MEX_PJM_EMKT_UNIT_DETAIL_TBL;

BEGIN
	p_STATUS    := GA.SUCCESS;

	MEX_PJM_EMKT.FETCH_UNIT_DETAIL(p_CRED, p_LOG_ONLY, p_LOCATION_TYPE, p_LOCATION_NAME, p_REQUEST_DATE, v_RECORDS, p_STATUS, p_ERROR_MESSAGE, p_LOGGER);

	IF p_STATUS >= 0 THEN
		IMPORT_UNIT_LIST(v_RECORDS, p_STATUS, p_ERROR_MESSAGE);
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS        := SQLCODE;
		p_ERROR_MESSAGE := PACKAGE_NAME || '.QUERY_UNIT_LIST: ' || UT.GET_FULL_ERRM;
END QUERY_UNIT_LIST;
-------------------------------------------------------------------------------------
PROCEDURE MARKET_SUBMIT_TRANSACTION_LIST
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_EXCHANGE_TYPE IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR) AS
	v_ACTION VARCHAR2(64) := p_EXCHANGE_TYPE;
	v_ALLOWED_TXNS ID_TABLE := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_BAO_UPDATE );
	v_ALL_TXNS NUMBER(1) := 0;
BEGIN
	--Selects the particular transactions that should show up for each Action Type
	--in the Bid/Offer Action Dialog.

	IF v_ALLOWED_TXNS(1).ID = SD.g_ALL_DATA_ENTITY_ID THEN v_ALL_TXNS := 1; END IF;

	IF v_ACTION = 'INCREMENT OFFER' THEN
		OPEN p_CURSOR FOR
			SELECT TRANSACTION_NAME, A.TRANSACTION_ID
			FROM INTERCHANGE_TRANSACTION A, IT_COMMODITY B, IT_STATUS S
			WHERE A.TRANSACTION_ID > 0
				AND TRANSACTION_TYPE = 'Generation'
				AND B.IS_VIRTUAL = 1
				AND B.COMMODITY_ID = A.COMMODITY_ID
				AND A.SC_ID = EI.GET_ID_FROM_IDENTIFIER_EXTSYS('PJM', EC.ED_SC, EC.ES_PJM)
				AND A.IS_BID_OFFER = 1
				AND A.BEGIN_DATE <= p_END_DATE
				AND A.END_DATE >= p_BEGIN_DATE
                AND S.TRANSACTION_ID = A.TRANSACTION_ID
				AND S.TRANSACTION_IS_ACTIVE = 1
				AND (v_ALL_TXNS = 1 OR A.TRANSACTION_ID IN (SELECT IDS.ID FROM TABLE(CAST(v_ALLOWED_TXNS AS ID_TABLE)) IDS))
			 ORDER BY 1;
	ELSIF v_ACTION = 'DECREMENT BID' THEN
		OPEN p_CURSOR FOR
			SELECT TRANSACTION_NAME, A.TRANSACTION_ID
			FROM INTERCHANGE_TRANSACTION A, IT_COMMODITY B, IT_STATUS S
			WHERE A.TRANSACTION_ID > 0
				AND TRANSACTION_TYPE = 'Load'
				AND B.IS_VIRTUAL = 1
				AND B.COMMODITY_ID = A.COMMODITY_ID
				AND A.SC_ID = EI.GET_ID_FROM_IDENTIFIER_EXTSYS('PJM', EC.ED_SC, EC.ES_PJM)
				AND A.IS_BID_OFFER = 1
				AND A.BEGIN_DATE <= p_END_DATE
				AND A.END_DATE >= p_BEGIN_DATE
                AND S.TRANSACTION_ID = A.TRANSACTION_ID
				AND S.TRANSACTION_IS_ACTIVE = 1
				AND (v_ALL_TXNS = 1 OR A.TRANSACTION_ID IN (SELECT IDS.ID FROM TABLE(CAST(v_ALLOWED_TXNS AS ID_TABLE)) IDS))
			 ORDER BY 1;
	ELSIF v_ACTION LIKE 'SUBMIT SCHEDULE %' OR v_ACTION = 'SUBMIT UNIT SCHEDULE' THEN
		OPEN p_CURSOR FOR
			SELECT B.CONTRACT_NAME || ':' || C.RESOURCE_NAME || ':' || A.TRANSACTION_ALIAS "TRANSACTION_NAME", A.TRANSACTION_ID
			FROM PJM_GEN_TXNS_BY_TYPE A, INTERCHANGE_CONTRACT B, SUPPLY_RESOURCE C, IT_STATUS S
			WHERE PJM_GEN_TXN_TYPE = MM_PJM_EMKT_UTIL.g_PJM_GEN_SCHEDULE_TXN_TYPE
				AND A.BEGIN_DATE <= p_END_DATE
				AND A.END_DATE >= p_BEGIN_DATE
                AND S.TRANSACTION_ID = A.TRANSACTION_ID
				AND S.TRANSACTION_IS_ACTIVE = 1
				AND (v_ALL_TXNS = 1 OR A.TRANSACTION_ID IN (SELECT IDS.ID FROM TABLE(CAST(v_ALLOWED_TXNS AS ID_TABLE)) IDS))
				AND B.CONTRACT_ID = A.CONTRACT_ID
				AND C.RESOURCE_ID = A.RESOURCE_ID
				AND NOT EXISTS (SELECT 1 FROM PJM_SERVICE_POINT_OWNERSHIP WHERE SERVICE_POINT_ID = A.POD_ID AND CONTRACT_ID = A.CONTRACT_ID AND BEGIN_DATE <= p_END_DATE AND NVL(END_DATE, p_END_DATE) >= p_BEGIN_DATE AND IS_SCHEDULER = 0)
			ORDER BY 1;
	ELSIF v_ACTION LIKE 'SUBMIT UNIT %' THEN
		OPEN p_CURSOR FOR
			SELECT B.CONTRACT_NAME || ':' || C.RESOURCE_NAME "TRANSACTION_NAME", A.TRANSACTION_ID
			FROM PJM_GEN_TXNS_BY_TYPE A, INTERCHANGE_CONTRACT B, SUPPLY_RESOURCE C, IT_STATUS S
			WHERE PJM_GEN_TXN_TYPE = MM_PJM_EMKT_UTIL.g_PJM_GEN_UNIT_DATA_TXN_TYPE
			 	AND A.BEGIN_DATE <= p_END_DATE
				AND A.END_DATE >= p_BEGIN_DATE
                AND S.TRANSACTION_ID = A.TRANSACTION_ID
				AND S.TRANSACTION_IS_ACTIVE = 1
				AND (v_ALL_TXNS = 1 OR A.TRANSACTION_ID IN (SELECT IDS.ID FROM TABLE(CAST(v_ALLOWED_TXNS AS ID_TABLE)) IDS))
				AND B.CONTRACT_ID = A.CONTRACT_ID
				AND C.RESOURCE_ID = A.RESOURCE_ID
				AND NOT EXISTS (SELECT 1 FROM PJM_SERVICE_POINT_OWNERSHIP WHERE SERVICE_POINT_ID = A.POD_ID AND CONTRACT_ID = A.CONTRACT_ID AND BEGIN_DATE <= p_END_DATE AND NVL(END_DATE, p_END_DATE) >= p_BEGIN_DATE AND IS_SCHEDULER = 0)
			 ORDER BY 1;
	ELSIF v_ACTION = 'PRICE-SENSITIVE DEMAND BID' THEN
		OPEN p_CURSOR FOR
			SELECT TRANSACTION_NAME, A.TRANSACTION_ID
			FROM INTERCHANGE_TRANSACTION A, IT_COMMODITY B, IT_STATUS S
			WHERE IS_BID_OFFER = 1
				AND A.TRANSACTION_TYPE = 'Load'
				AND A.IS_FIRM = 0
				AND A.SC_ID = EI.GET_ID_FROM_IDENTIFIER_EXTSYS('PJM', EC.ED_SC, EC.ES_PJM)
				AND A.COMMODITY_ID = B.COMMODITY_ID
				AND B.COMMODITY_NAME = MM_PJM_UTIL.g_COMM_DA_ENERGY
				AND A.BEGIN_DATE <= p_END_DATE
				AND A.END_DATE >= p_BEGIN_DATE
                AND S.TRANSACTION_ID = A.TRANSACTION_ID
				AND S.TRANSACTION_IS_ACTIVE = 1
				AND (v_ALL_TXNS = 1 OR A.TRANSACTION_ID IN (SELECT IDS.ID FROM TABLE(CAST(v_ALLOWED_TXNS AS ID_TABLE)) IDS))
			 ORDER BY B.COMMODITY_NAME, A.TRANSACTION_NAME;
	ELSIF v_ACTION = 'FIXED DEMAND BID' THEN
		OPEN p_CURSOR FOR
			SELECT TRANSACTION_NAME, A.TRANSACTION_ID
			FROM INTERCHANGE_TRANSACTION A, IT_COMMODITY B, IT_STATUS S
			WHERE IS_BID_OFFER = 1
				AND A.TRANSACTION_TYPE = 'Load'
				AND A.IS_FIRM = 1
				AND A.SC_ID = EI.GET_ID_FROM_IDENTIFIER_EXTSYS('PJM', EC.ED_SC, EC.ES_PJM)
				AND A.COMMODITY_ID = B.COMMODITY_ID
				AND B.COMMODITY_NAME = MM_PJM_UTIL.g_COMM_DA_ENERGY
				AND A.BEGIN_DATE <= p_END_DATE
				AND A.END_DATE >= p_BEGIN_DATE
                AND S.TRANSACTION_ID = A.TRANSACTION_ID
				AND S.TRANSACTION_IS_ACTIVE = 1
				AND (v_ALL_TXNS = 1 OR A.TRANSACTION_ID IN (SELECT IDS.ID FROM TABLE(CAST(v_ALLOWED_TXNS AS ID_TABLE)) IDS))
			ORDER BY B.COMMODITY_NAME, A.TRANSACTION_NAME;
	ELSIF v_ACTION LIKE 'SUBMIT REGULATION %' THEN
		OPEN p_CURSOR FOR
			SELECT B.CONTRACT_NAME || ':' || C.RESOURCE_NAME "TRANSACTION_NAME", A.TRANSACTION_ID
			FROM PJM_GEN_TXNS_BY_TYPE A, INTERCHANGE_CONTRACT B, SUPPLY_RESOURCE C, IT_STATUS S
			WHERE PJM_GEN_TXN_TYPE = MM_PJM_EMKT_UTIL.g_PJM_GEN_REGULATION_TXN_TYPE
				AND A.BEGIN_DATE <= p_END_DATE
				AND A.END_DATE >= p_BEGIN_DATE
                AND S.TRANSACTION_ID = A.TRANSACTION_ID
				AND S.TRANSACTION_IS_ACTIVE = 1
				AND (v_ALL_TXNS = 1 OR A.TRANSACTION_ID IN (SELECT IDS.ID FROM TABLE(CAST(v_ALLOWED_TXNS AS ID_TABLE)) IDS))
				AND B.CONTRACT_ID = A.CONTRACT_ID
				AND C.RESOURCE_ID = A.RESOURCE_ID
				AND NOT EXISTS (SELECT 1 FROM PJM_SERVICE_POINT_OWNERSHIP WHERE SERVICE_POINT_ID = A.POD_ID AND CONTRACT_ID = A.CONTRACT_ID AND BEGIN_DATE <= p_END_DATE AND NVL(END_DATE, p_END_DATE) >= p_BEGIN_DATE AND IS_SCHEDULER = 0)
			ORDER BY 1;
	ELSIF v_ACTION LIKE 'SUBMIT SPINNING %' THEN
		OPEN p_CURSOR FOR
			SELECT B.CONTRACT_NAME || ':' || C.RESOURCE_NAME "TRANSACTION_NAME", A.TRANSACTION_ID
			FROM PJM_GEN_TXNS_BY_TYPE A, INTERCHANGE_CONTRACT B, SUPPLY_RESOURCE C, IT_STATUS S
			WHERE PJM_GEN_TXN_TYPE = MM_PJM_EMKT_UTIL.g_PJM_GEN_SPIN_RES_TXN_TYPE
				AND A.BEGIN_DATE <= p_END_DATE
				AND A.END_DATE >= p_BEGIN_DATE
                AND S.TRANSACTION_ID = A.TRANSACTION_ID
				AND S.TRANSACTION_IS_ACTIVE = 1
				AND A.AGREEMENT_TYPE = 'Tier2'
				AND (v_ALL_TXNS = 1 OR A.TRANSACTION_ID IN (SELECT IDS.ID FROM TABLE(CAST(v_ALLOWED_TXNS AS ID_TABLE)) IDS))
				AND B.CONTRACT_ID = A.CONTRACT_ID
				AND C.RESOURCE_ID = A.RESOURCE_ID
				AND NOT EXISTS (SELECT 1 FROM PJM_SERVICE_POINT_OWNERSHIP WHERE SERVICE_POINT_ID = A.POD_ID AND CONTRACT_ID = A.CONTRACT_ID AND BEGIN_DATE <= p_END_DATE AND NVL(END_DATE, p_END_DATE) >= p_BEGIN_DATE AND IS_SCHEDULER = 0)
			ORDER BY 1;
	ELSE
		OPEN p_CURSOR FOR
			SELECT TRANSACTION_NAME, A.TRANSACTION_ID
			FROM INTERCHANGE_TRANSACTION A, IT_COMMODITY B, IT_STATUS S
			WHERE IS_BID_OFFER = 1
				AND A.COMMODITY_ID = B.COMMODITY_ID
				AND A.BEGIN_DATE <= p_END_DATE
				AND A.END_DATE >= p_BEGIN_DATE
                AND S.TRANSACTION_ID = A.TRANSACTION_ID
				AND S.TRANSACTION_IS_ACTIVE = 1
				AND (v_ALL_TXNS = 1 OR A.TRANSACTION_ID IN (SELECT IDS.ID FROM TABLE(CAST(v_ALLOWED_TXNS AS ID_TABLE)) IDS))
			ORDER BY B.COMMODITY_NAME, A.TRANSACTION_NAME;
	END IF;

END MARKET_SUBMIT_TRANSACTION_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE SYSTEM_ACTION_USES_HOURS
	(
    p_ACTION IN VARCHAR2,
	p_SHOW_HOURS OUT NUMBER
    ) AS
BEGIN
		--Selects the particular transactions that should show up for each Action Type
		--in the Bid/Offer Action Dialog.

		IF UPPER(p_ACTION) LIKE 'SUBMIT % UPDATE' THEN
            p_SHOW_HOURS := 1;
		ELSE
			p_SHOW_HOURS := 0;
		END IF;

END SYSTEM_ACTION_USES_HOURS;
----------------------------------------------------------------------------------------------------
PROCEDURE MARKET_EXCHANGE_ENTITY_LIST
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_EXCHANGE_TYPE IN VARCHAR,
	p_ENTITY_LABEL OUT VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT REF_CURSOR
	) AS

	--THIS CURSOR SHOULD RETURN DATA IN EITHER NAME, ID FORMAT OR JUST NAME FORMAT.
	--IF NAME AND ID ARE USED, NAME MUST COME BEFORE ID.
	--FOR EXAMPLE, THE FOLLOWING TWO SELECT STATEMENTS WOULD BE VALID.
	--SELECT PSE_NAME, PSE_ID FROM PURCHASING_SELLING_ENTITY;
	--SELECT PSE_NAME FROM PURCHASING_SELLING_ENTITY;
	--THE FIRST ONE WILL RETURN A LIST OF IDS TO DATA_EXCHANGE,
	--AND THE SECOND WILL RETURN A LIST OF NAMES.

	--YOU MUST GIVE A VALUE FOR THE p_ENTITY_LABEL PARAMETER.  IT IS WHAT
	--IS DISPLAYED ON TOP OF THE LIST ON THE DIALOG.
BEGIN
	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT NULL FROM DUAL;

END MARKET_EXCHANGE_ENTITY_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE MARKET_EXCHANGE
	(
	p_BEGIN_DATE            	IN DATE,
	p_END_DATE              	IN DATE,
	p_EXCHANGE_TYPE  			IN VARCHAR2,
	p_ENTITY_LIST           	IN VARCHAR2,
	p_ENTITY_LIST_DELIMITER 	IN CHAR,
	p_LOG_ONLY					IN NUMBER :=0,
	p_LOG_TYPE 					IN NUMBER,
	p_TRACE_ON 					IN NUMBER,
	p_STATUS                	OUT NUMBER,
	p_MESSAGE               	OUT VARCHAR2) AS

	v_ENTITY_STRING_TABLE GA.STRING_TABLE;
	v_INDEX               BINARY_INTEGER;
	v_ENTITY_ID           NUMBER(9);
	v_LOOP_COUNTER        BINARY_INTEGER := 1;
	v_CURRENT_DATE        DATE;
	v_LOOP_OVER_DATES     BOOLEAN := FALSE;
	v_LOG_ONLY            NUMBER(1) := 0;
	v_ACTION              VARCHAR2(64);
	v_NO_SUBMIT           BOOLEAN := FALSE;

	v_CREDS		mm_credentials_set;
	v_CRED		mex_credentials;
	v_LOGGER	mm_logger_adapter;
	v_PROCESS_NAME VARCHAR2(64);
BEGIN

	v_LOG_ONLY := NVL(p_LOG_ONLY,0);
	UT.TOKENS_FROM_STRING(p_ENTITY_LIST, p_ENTITY_LIST_DELIMITER,v_ENTITY_STRING_TABLE);
	v_INDEX := v_ENTITY_STRING_TABLE.FIRST;

	v_ACTION := p_EXCHANGE_TYPE;
	
	IF v_ACTION = g_ET_QUERY_FIXED_DEMAND_BID THEN
		v_PROCESS_NAME := 'PJM:MktGW:' || v_ACTION;
	ELSE 
		v_PROCESS_NAME := 'PJM:EMKT:' || v_ACTION;
	END IF;
	
	MM_UTIL.INIT_MEX(p_EXTERNAL_SYSTEM_ID => EC.ES_PJM,
		p_PROCESS_NAME => v_PROCESS_NAME,
		p_EXCHANGE_NAME => v_ACTION,
		p_LOG_TYPE => p_LOG_TYPE,
		p_TRACE_ON => p_TRACE_ON,
		p_CREDENTIALS => v_CREDS,
		p_LOGGER => v_LOGGER);

	MM_UTIL.START_EXCHANGE(FALSE, v_LOGGER);

	--LOOP OVER ENTITIES
	LOOP
		IF p_ENTITY_LIST IS NULL THEN
			v_ENTITY_ID := NULL;
		ELSE
			v_ENTITY_ID := TO_NUMBER(v_ENTITY_STRING_TABLE(v_INDEX));
		END IF;

		--LOOP OVER DATES
		v_CURRENT_DATE := TRUNC(p_BEGIN_DATE);
		LOOP
		   WHILE v_CREDS.HAS_NEXT LOOP
			  v_CRED := v_CREDS.GET_NEXT;
				CASE v_ACTION
				WHEN g_ET_QUERY_PORTFOLIOS  THEN
					QUERY_PORTFOLIOS(v_CRED, v_LOG_ONLY, p_STATUS, p_MESSAGE, v_LOGGER);
					v_LOOP_OVER_DATES := FALSE;
				/*The following will need to be re-factored to do the XML query and parse results within themselves.
				WHEN g_ET_CREATE_PORTFOLIO THEN
					UPDATE_PORTFOLIO(v_ENTITY_ID, 'Create', v_CURRENT_XML);
					v_LOOP_OVER_DATES := FALSE;
				WHEN g_ET_UPDATE_PORTFOLIO THEN
					UPDATE_PORTFOLIO(v_ENTITY_ID, 'Update', v_CURRENT_XML);
					v_LOOP_OVER_DATES := FALSE;
				WHEN g_ET_REMOVE_PORTFOLIO THEN
					UPDATE_PORTFOLIO(v_ENTITY_ID, 'Remove', v_CURRENT_XML);
					v_LOOP_OVER_DATES := FALSE;
				WHEN g_ET_SUBMIT_WEATHER_FORECAST THEN
					WEATHER_FORECAST(v_ENTITY_ID, v_CURRENT_DATE, v_CURRENT_XML);
					v_LOOP_OVER_DATES := TRUE; */
				WHEN g_ET_QUERY_SCHEDULE_OFFER THEN
					MM_PJM_EMKT_GEN.QUERY_SCHEDULE_OFFER(v_CRED, GA.EXTERNAL_STATE, v_CURRENT_DATE, v_LOG_ONLY, p_STATUS, p_MESSAGE, v_LOGGER);
					v_LOOP_OVER_DATES := TRUE;
					v_NO_SUBMIT       := TRUE;
				WHEN g_ET_QUERY_SCHEDULE_DETAIL THEN
					-- New generation management implementation
					MM_PJM_EMKT_GEN.QUERY_SCHEDULE_DETAIL(v_CRED, GA.EXTERNAL_STATE, v_CURRENT_DATE, v_LOG_ONLY, p_STATUS, p_MESSAGE, v_LOGGER);
					v_LOOP_OVER_DATES := TRUE;
					v_NO_SUBMIT       := TRUE;
				WHEN g_ET_QUERY_SCHEDULE_SELECTION THEN
					MM_PJM_EMKT_GEN.QUERY_SCHEDULE_SELECTION(v_CRED, GA.EXTERNAL_STATE, v_CURRENT_DATE, v_LOG_ONLY, p_STATUS, p_MESSAGE, v_LOGGER);
					v_LOOP_OVER_DATES := TRUE;
					v_NO_SUBMIT       := TRUE;
				WHEN g_ET_QUERY_ANC_SRV_MRKT_PRICES THEN
					QUERY_ANCILLARY_SERVICE_PRICES(v_CRED, v_LOG_ONLY, v_CURRENT_DATE, p_STATUS, p_MESSAGE, v_LOGGER);
					v_LOOP_OVER_DATES := TRUE;
					v_NO_SUBMIT       := TRUE;
				WHEN g_ET_QUERY_MARKET_RESULTS THEN
					QUERY_MARKET_RESULTS(v_CRED, v_CURRENT_DATE, v_LOG_ONLY, p_STATUS, p_MESSAGE, v_LOGGER);
					v_LOOP_OVER_DATES := TRUE;
					v_NO_SUBMIT       := TRUE;
				WHEN g_ET_QUERY_UNIT_DETAIL THEN
					MM_PJM_EMKT_GEN.QUERY_UNIT_DETAIL(v_CRED, GA.EXTERNAL_STATE, v_CURRENT_DATE, v_LOG_ONLY, p_STATUS, p_MESSAGE, v_LOGGER);
					v_LOOP_OVER_DATES := TRUE;
					v_NO_SUBMIT       := TRUE;
				WHEN g_ET_QUERY_UNIT_SCHEDULE  THEN
					MM_PJM_EMKT_GEN.QUERY_UNIT_SCHEDULES(v_CRED, v_LOG_ONLY, p_STATUS, p_MESSAGE, v_LOGGER);
					v_LOOP_OVER_DATES := TRUE;
					v_NO_SUBMIT       := TRUE;
				WHEN g_ET_QUERY_UNIT_UPDATE  THEN
					MM_PJM_EMKT_GEN.QUERY_UNIT_UPDATES(v_CRED, GA.EXTERNAL_STATE, v_CURRENT_DATE, v_LOG_ONLY, p_STATUS, p_MESSAGE, v_LOGGER);
					v_LOOP_OVER_DATES := TRUE;
					v_NO_SUBMIT       := TRUE;
				WHEN g_ET_QUERY_DEMAND_SUMMARY  THEN
					QUERY_DEMAND_SUMMARY(v_CRED, p_BEGIN_DATE, p_END_DATE, v_LOG_ONLY, p_STATUS, p_MESSAGE, v_LOGGER);
					v_LOOP_OVER_DATES := FALSE;
					v_NO_SUBMIT       := TRUE;
				WHEN g_ET_QUERY_DEMAND_BIDS THEN
					QUERY_DEMAND_BIDS(v_CRED, p_BEGIN_DATE, p_END_DATE, 'ALL', FALSE, v_LOG_ONLY, p_STATUS, p_MESSAGE, v_LOGGER);
					v_LOOP_OVER_DATES := FALSE;
					v_NO_SUBMIT := TRUE;
				WHEN g_ET_QUERY_FIXED_DEMAND_BID THEN
					QUERY_DEMAND_BIDS(v_CRED, p_BEGIN_DATE, p_END_DATE, 'ALL', FALSE, v_LOG_ONLY, p_STATUS, p_MESSAGE, v_LOGGER);
					v_LOOP_OVER_DATES := FALSE;
					v_NO_SUBMIT := TRUE;
				WHEN g_ET_QUERY_DEMAND_BIDS_INTERN THEN
					QUERY_DEMAND_BIDS(v_CRED, p_BEGIN_DATE, p_END_DATE, 'ALL', TRUE, v_LOG_ONLY, p_STATUS, p_MESSAGE, v_LOGGER);
					v_LOOP_OVER_DATES := FALSE;
					v_NO_SUBMIT       := TRUE;
				-- 17-mar-2009, jbc: deprecated; see comment in QUERY_HOURLY_LMP
				--WHEN g_ET_QUERY_DAY_AHEAD_LMPS THEN
				--	QUERY_HOURLY_LMP(v_CRED, p_BEGIN_DATE, p_END_DATE, v_LOG_ONLY, p_STATUS, p_MESSAGE, v_LOGGER);
				--	v_LOOP_OVER_DATES := FALSE;
				--	v_NO_SUBMIT       := TRUE;
				WHEN g_ET_QUERY_REGULATION_OFFERS THEN
					MM_PJM_EMKT_GEN.QUERY_REGULATION_OFFER(v_CRED, 2, v_CURRENT_DATE, v_LOG_ONLY, p_STATUS, p_MESSAGE, v_LOGGER);
					v_LOOP_OVER_DATES := TRUE;
					v_NO_SUBMIT := TRUE;
				WHEN g_ET_QUERY_SPIN_RESERVE_OFFERS THEN
					MM_PJM_EMKT_GEN.QUERY_SPIN_RESERVE_OFFER(v_CRED, 2, v_CURRENT_DATE, v_LOG_ONLY, p_STATUS, p_MESSAGE, v_LOGGER);
					v_LOOP_OVER_DATES := TRUE;
					v_NO_SUBMIT := TRUE;
				WHEN g_ET_SUBMIT_DISTRIB_FACTORS THEN
					DISTRIBUTION_FACTORS(v_CURRENT_DATE, v_LOG_ONLY, p_STATUS, p_MESSAGE);
					v_LOOP_OVER_DATES := TRUE;
					v_NO_SUBMIT       := FALSE;
				WHEN g_ET_QUERY_NODE_LIST THEN
					QUERY_NODE_LIST(v_CRED, FALSE, p_BEGIN_DATE, p_END_DATE, v_LOG_ONLY, p_STATUS, p_MESSAGE, v_LOGGER);

					v_LOOP_OVER_DATES := FALSE;
					v_NO_SUBMIT := TRUE;
				WHEN g_ET_QUERY_BID_NODE_LIST THEN
					QUERY_NODE_LIST(v_CRED, TRUE, p_BEGIN_DATE, p_END_DATE, v_LOG_ONLY, p_STATUS, p_MESSAGE, v_LOGGER);
					v_LOOP_OVER_DATES := FALSE;
					v_NO_SUBMIT := TRUE;
				/*These are not fully implemented.
				WHEN 'QUERY REGULATION BILATERALS' THEN
					QUERY_REGULATION_BILATERAL(v_CURRENT_DATE, v_LOG_ONLY, p_STATUS, p_MESSAGE);
					v_LOOP_OVER_DATES := TRUE;
					v_NO_SUBMIT := TRUE;
				WHEN 'QUERY SPINNING RESERVE BILATERALS' THEN
					QUERY_SPIN_RESERVE_BILATERAL(v_CURRENT_DATE, v_LOG_ONLY, p_STATUS, p_MESSAGE);
					v_LOOP_OVER_DATES := TRUE;
					v_NO_SUBMIT := TRUE;
				WHEN 'QUERY REGULATION RESULTS' THEN
					QUERY_REGULATION_RESULTS(v_CURRENT_DATE, v_LOG_ONLY, p_STATUS, p_MESSAGE);
					v_LOOP_OVER_DATES := TRUE;
					v_NO_SUBMIT := TRUE;
				WHEN 'QUERY SPINNING RESERVE RESULTS' THEN
					QUERY_SPIN_RESERVE_RESULTS(v_CURRENT_DATE, v_LOG_ONLY, p_STATUS, p_MESSAGE);
					v_LOOP_OVER_DATES := TRUE;
					v_NO_SUBMIT := TRUE; */
				WHEN g_ET_QUERY_SPREG_AWARDS THEN
					MM_PJM_EMKT_GEN.QUERY_SPREG_AWARD(v_CRED, v_CURRENT_DATE, v_LOG_ONLY, p_STATUS, p_MESSAGE, v_LOGGER);
					v_LOOP_OVER_DATES := TRUE;
					v_NO_SUBMIT := TRUE;
				WHEN g_ET_QUERY_MESSAGES THEN
					QUERY_MESSAGES(v_CRED, v_LOG_ONLY, p_STATUS, p_MESSAGE, v_LOGGER);
					v_LOOP_OVER_DATES := FALSE;
					v_NO_SUBMIT := TRUE;
                WHEN g_ET_QUERY_PARAM_LIMITS THEN
                    MM_PJM_EMKT_GEN.QUERY_PARAMETER_LIMITS(v_CRED, GA.EXTERNAL_STATE, v_CURRENT_DATE, v_LOG_ONLY, p_STATUS, p_MESSAGE, v_LOGGER);
					v_LOOP_OVER_DATES := TRUE;
					v_NO_SUBMIT := TRUE;
                WHEN g_ET_QUERY_PARAM_LIMITS_INTERN THEN
                    MM_PJM_EMKT_GEN.QUERY_PARAMETER_LIMITS(v_CRED, GA.INTERNAL_STATE, v_CURRENT_DATE, v_LOG_ONLY, p_STATUS, p_MESSAGE, v_LOGGER);
					v_LOOP_OVER_DATES := TRUE;
					v_NO_SUBMIT := TRUE;
				ELSE
					p_STATUS := -1;
					p_MESSAGE := 'Exchange Type ' || p_EXCHANGE_TYPE || ' not found.';
					v_LOGGER.LOG_ERROR(p_MESSAGE);
					v_NO_SUBMIT := TRUE;
				END CASE;

				IF p_MESSAGE is not NULL THEN
					v_LOGGER.LOG_ERROR(p_MESSAGE);
					p_MESSAGE := NULL;
				END IF;

				-- RUN FOR ONLY ONE SET OF CREDENTIALS
				EXIT WHEN v_ACTION IN (g_ET_QUERY_DEMAND_SUMMARY, g_ET_QUERY_ANC_SRV_MRKT_PRICES, g_ET_QUERY_NODE_LIST);

			END LOOP;

			--MAKE SURE WE DON'T HAVE A RUNAWAY LOOP.
			v_LOOP_COUNTER := v_LOOP_COUNTER + 1;
			IF v_LOOP_COUNTER > 10000 THEN
				RAISE_APPLICATION_ERROR(-20100, 'RUNAWAY LOOP IN MM_PJM_EMKT.MARKET_EXCHANGE');
			END IF;

			EXIT WHEN(NOT v_LOOP_OVER_DATES) OR(v_CURRENT_DATE >= TRUNC(p_END_DATE));
			v_CURRENT_DATE := v_CURRENT_DATE + 1;
		END LOOP;

		EXIT WHEN v_ENTITY_ID IS NULL OR v_INDEX = v_ENTITY_STRING_TABLE.LAST;
		v_INDEX := v_ENTITY_STRING_TABLE.NEXT(v_INDEX);
	END LOOP; -- OVER ENTITIES;

	MM_UTIL.STOP_EXCHANGE(v_LOGGER, p_STATUS, p_MESSAGE, p_MESSAGE);

EXCEPTION
		WHEN OTHERS THEN
			p_MESSAGE := UT.GET_FULL_ERRM;
			p_STATUS := SQLCODE;
			MM_UTIL.STOP_EXCHANGE(v_LOGGER, p_STATUS, p_MESSAGE, p_MESSAGE);
END MARKET_EXCHANGE;
-------------------------------------------------------------------------------------
PROCEDURE QUERY_ALL_BIDS_OF_TYPE
	(
	p_BID_TYPE IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SCHEDULE_STATE IN NUMBER,
	p_LOG_ONLY IN NUMBER,
	p_LOG_TYPE IN NUMBER,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR2
	) AS
	v_CURRENT_DATE DATE;
	v_LOG_ONLY NUMBER(1) := NVL(p_LOG_ONLY, 0);
	v_ALL_BIDS BOOLEAN := UPPER(p_BID_TYPE) = 'ALL';
	v_CREDS MM_CREDENTIALS_SET;
	v_CRED MEX_CREDENTIALS;
	v_LOGGER MM_LOGGER_ADAPTER;
BEGIN

	MM_UTIL.INIT_MEX(p_EXTERNAL_SYSTEM_ID => EC.ES_PJM,
		p_PROCESS_NAME => 'PJM:EMKT',
		p_EXCHANGE_NAME => 'Query All ' || p_BID_TYPE || ' Bids',
		p_LOG_TYPE => p_LOG_TYPE,
		p_TRACE_ON => p_TRACE_ON,
		p_CREDENTIALS => v_CREDS,
		p_LOGGER => v_LOGGER);

	MM_UTIL.START_EXCHANGE(FALSE, v_LOGGER);

	WHILE v_CREDS.HAS_NEXT LOOP
		v_CRED := v_CREDS.GET_NEXT;

		--Do not loop over each day for these queries:
		IF UPPER(p_BID_TYPE) = 'GENERATION' OR v_ALL_BIDS THEN
			--Query Unit Schedules
			MM_PJM_EMKT_GEN.QUERY_UNIT_SCHEDULES(v_CRED, v_LOG_ONLY, p_STATUS, p_MESSAGE, v_LOGGER);
			IF p_MESSAGE IS NOT NULL THEN RETURN; END IF;
		END IF;
		IF UPPER(p_BID_TYPE) = 'DEMAND' OR v_ALL_BIDS THEN
			--Query Demand Bids
			QUERY_DEMAND_BIDS(v_CRED, p_BEGIN_DATE, p_END_DATE, 'ALL', p_SCHEDULE_STATE = 1, v_LOG_ONLY, p_STATUS, p_MESSAGE, v_LOGGER);
			IF p_MESSAGE IS NOT NULL THEN RETURN; END IF;
		END IF;

		--Loop for each day for these queries:
		v_CURRENT_DATE := TRUNC(p_BEGIN_DATE);
		LOOP
			IF UPPER(p_BID_TYPE) IN('GENERATION', 'ROLL_FORWARDS') OR v_ALL_BIDS THEN
				--Query Unit Details
				MM_PJM_EMKT_GEN.QUERY_UNIT_DETAIL(v_CRED, p_SCHEDULE_STATE, v_CURRENT_DATE, v_LOG_ONLY, p_STATUS, p_MESSAGE, v_LOGGER);
				IF p_MESSAGE IS NOT NULL THEN RETURN; END IF;

				--Query Schedule Offer Curves
				MM_PJM_EMKT_GEN.QUERY_SCHEDULE_OFFER(v_CRED, p_SCHEDULE_STATE, v_CURRENT_DATE, v_LOG_ONLY, p_STATUS, p_MESSAGE, v_LOGGER);
				IF p_MESSAGE IS NOT NULL THEN RETURN; END IF;

				--Query Schedule Selection
				MM_PJM_EMKT_GEN.QUERY_SCHEDULE_SELECTION(v_CRED, p_SCHEDULE_STATE, v_CURRENT_DATE, v_LOG_ONLY, p_STATUS, p_MESSAGE, v_LOGGER);
				IF p_MESSAGE IS NOT NULL THEN RETURN; END IF;

				--Query Schedule Details
				MM_PJM_EMKT_GEN.QUERY_SCHEDULE_DETAIL(v_CRED, p_SCHEDULE_STATE, v_CURRENT_DATE, v_LOG_ONLY, p_STATUS, p_MESSAGE, v_LOGGER);
				IF p_MESSAGE IS NOT NULL THEN RETURN; END IF;
			END IF;
			IF UPPER(p_BID_TYPE) = 'GENERATION' OR v_ALL_BIDS THEN
				--Query Hourly Unit Updates
				MM_PJM_EMKT_GEN.QUERY_UNIT_UPDATES(v_CRED, p_SCHEDULE_STATE, v_CURRENT_DATE, v_LOG_ONLY, p_STATUS, p_MESSAGE, v_LOGGER);
				IF p_MESSAGE IS NOT NULL THEN RETURN; END IF;
			END IF;
			IF UPPER(p_BID_TYPE) IN ('AS', 'ROLL_FORWARDS') OR v_ALL_BIDS THEN
				--Query Spin Offers
				MM_PJM_EMKT_GEN.QUERY_SPIN_RESERVE_OFFER(v_CRED, p_SCHEDULE_STATE, v_CURRENT_DATE, v_LOG_ONLY, p_STATUS, p_MESSAGE, v_LOGGER);
				IF p_MESSAGE IS NOT NULL THEN RETURN; END IF;

				--Query Reg Offers
				MM_PJM_EMKT_GEN.QUERY_REGULATION_OFFER(v_CRED, p_SCHEDULE_STATE, v_CURRENT_DATE, v_LOG_ONLY, p_STATUS, p_MESSAGE, v_LOGGER);
				IF p_MESSAGE IS NOT NULL THEN RETURN; END IF;
			END IF;
			IF UPPER(p_BID_TYPE) = 'AS' OR v_ALL_BIDS THEN
				--Query Spin Updates
				MM_PJM_EMKT_GEN.QUERY_SPIN_RESERVE_UPDATE(v_CRED, p_SCHEDULE_STATE, v_CURRENT_DATE, v_LOG_ONLY, p_STATUS, p_MESSAGE, v_LOGGER);
				IF p_MESSAGE IS NOT NULL THEN RETURN; END IF;

				--Query Reg Updates
				MM_PJM_EMKT_GEN.QUERY_REGULATION_UPDATE(v_CRED, p_SCHEDULE_STATE, v_CURRENT_DATE, v_LOG_ONLY, p_STATUS, p_MESSAGE, v_LOGGER);
				IF p_MESSAGE IS NOT NULL THEN RETURN; END IF;
			END IF;
			IF UPPER(p_BID_TYPE) = 'VIRTUAL' OR v_ALL_BIDS THEN
				--Query Virtual Bids (Incs and Decs)
				QUERY_VIRTUAL_BIDS(v_CRED, v_CURRENT_DATE, NULL, 'All', p_SCHEDULE_STATE = 1, v_LOG_ONLY, p_STATUS, p_MESSAGE, v_LOGGER);
				IF p_MESSAGE IS NOT NULL THEN RETURN; END IF;
			END IF;

			EXIT WHEN v_CURRENT_DATE >= TRUNC(p_END_DATE);
			v_CURRENT_DATE := v_CURRENT_DATE + 1;
		END LOOP; --OVER DAYS
	END LOOP; -- OVER CREDENTIALS

	SECURITY_CONTROLS.SET_IS_INTERFACE(FALSE);
	MM_UTIL.STOP_EXCHANGE(v_LOGGER, p_STATUS, p_MESSAGE, p_MESSAGE);

EXCEPTION
		WHEN OTHERS THEN
			p_MESSAGE := UT.GET_FULL_ERRM;
			p_STATUS := SQLCODE;
			MM_UTIL.STOP_EXCHANGE(v_LOGGER, p_STATUS, p_MESSAGE, p_MESSAGE);
END QUERY_ALL_BIDS_OF_TYPE;
----------------------------------------------------------------------------------------------------
PROCEDURE QUERY_BY_TRANSACTION_ID
	(
	p_CRED IN mex_credentials,
	p_TRANSACTION_ID IN INTERCHANGE_TRANSACTION.TRANSACTION_ID%TYPE,
	p_PJM_TRANSACTION_CODE IN VARCHAR,
	p_ACTION IN VARCHAR,
	p_LOG_ONLY IN NUMBER,
	p_STATUS OUT NUMBER,
	p_ERROR_MESSAGE OUT VARCHAR2,
	p_LOGGER IN OUT mm_logger_adapter
	) AS

	v_XML_RESPONSE XMLTYPE;
	v_VIRTUAL_BID_RECORDS MEX_PJM_EMKT_VIRTUAL_BIDS_TBL;
	v_DEMAND_BID_RECORDS MEX_PJM_EMKT_DEMAND_BID_TBL;
	v_FIXED_DEMAND_BID_RECORDS MEX_PJM_EMKT_FIXED_DEMAND_TBL;
	v_ACTION VARCHAR2(128) := p_ACTION;
BEGIN

	p_STATUS := GA.SUCCESS;

	MEX_PJM_EMKT.FETCH_RESPONSE_FOR_TRANSACTION(p_CRED, p_LOG_ONLY, p_PJM_TRANSACTION_CODE, v_XML_RESPONSE, p_STATUS,p_ERROR_MESSAGE, p_LOGGER);

	-- Increment and Decrement do the same thing.
	IF v_ACTION IN ('INCREMENT OFFER', 'DECREMENT BID') THEN v_ACTION := 'VIRTUAL'; END IF;

     -- The response to a successful query by transaction is a message that
     -- contains exactly what was submitted by the transaction.
     CASE v_ACTION
          WHEN 'VIRTUAL' THEN
               v_VIRTUAL_BID_RECORDS := MEX_PJM_EMKT_VIRTUAL_BIDS_TBL();
               MEX_PJM_EMKT.PARSE_VIRTUAL_BIDS(v_XML_RESPONSE,v_VIRTUAL_BID_RECORDS, p_STATUS, p_ERROR_MESSAGE);
               IF p_STATUS = GA.SUCCESS THEN
			      IMPORT_VIRTUAL_BIDS(FALSE,
                                      p_TRANSACTION_ID,
                                      v_VIRTUAL_BID_RECORDS,
                                      p_CRED.EXTERNAL_ACCOUNT_NAME,
                                      p_STATUS,
                                      p_ERROR_MESSAGE);
			   END IF;
          WHEN 'PRICE-SENSITIVE DEMAND BID' THEN
               v_DEMAND_BID_RECORDS := MEX_PJM_EMKT_DEMAND_BID_TBL();
               MEX_PJM_EMKT.PARSE_DEMAND_BIDS(v_XML_RESPONSE,v_DEMAND_BID_RECORDS, p_STATUS, p_ERROR_MESSAGE);
               IF p_STATUS = GA.SUCCESS THEN
			      IMPORT_DEMAND_BIDS(p_CRED.EXTERNAL_ACCOUNT_NAME,
                                     FALSE,
                                     v_DEMAND_BID_RECORDS,
                                     p_STATUS,
                                     p_ERROR_MESSAGE);
			   END IF;
          WHEN 'FIXED DEMAND BID' THEN
               v_FIXED_DEMAND_BID_RECORDS := MEX_PJM_EMKT_FIXED_DEMAND_TBL();
               MEX_PJM_EMKT.PARSE_FIXED_DEMAND(v_XML_RESPONSE,v_FIXED_DEMAND_BID_RECORDS, p_STATUS, p_ERROR_MESSAGE);
               IF p_STATUS = GA.SUCCESS THEN
			      IMPORT_FIXED_DEMAND(p_TRANSACTION_ID,
                                      p_CRED.EXTERNAL_ACCOUNT_NAME,
                                      v_FIXED_DEMAND_BID_RECORDS,
                                      p_STATUS,
                                      p_ERROR_MESSAGE);
			   END IF;
		-- Otherwise, this is a GEN query.
		ELSE
			MM_PJM_EMKT_GEN.IMPORT_BY_TRANSACTION_ID(v_XML_RESPONSE, p_CRED.EXTERNAL_ACCOUNT_NAME, p_TRANSACTION_ID,
				p_ACTION, p_STATUS, p_ERROR_MESSAGE);
	     END CASE;

     IF p_STATUS <> GA.SUCCESS THEN
	 	p_LOGGER.LOG_EXCHANGE_ERROR('Failed to query by Transaction id:' || p_TRANSACTION_ID || ' for ' || p_ACTION || ' Message:' || p_ERROR_MESSAGE);
     END IF;

END QUERY_BY_TRANSACTION_ID;
-------------------------------------------------------------------------------------

PROCEDURE MARKET_SUBMIT(p_BEGIN_DATE IN DATE,
	p_END_DATE 			IN DATE,
	p_EXCHANGE_TYPE 	IN VARCHAR2,
	p_LOG_ONLY 			IN NUMBER := 0,
	p_ENTITY_LIST       IN VARCHAR2,
	p_ENTITY_LIST_DELIMITER 	IN CHAR,
    p_SUBMIT_HOURS   	IN VARCHAR2,
    p_TIME_ZONE       	IN VARCHAR2,
	p_LOG_TYPE			IN NUMBER,
	p_TRACE_ON			IN NUMBER,
	p_STATUS            OUT NUMBER,
	p_MESSAGE           OUT VARCHAR2) AS

    v_TRANSACTION_IDS VARCHAR2(4000);
    v_TRANSACTION_ID INTERCHANGE_TRANSACTION.TRANSACTION_ID%TYPE;
	v_TXN_ID_TABLE ID_TABLE;
	v_TXN_ID_TABLE_COUNT BINARY_INTEGER;
	v_TXN_ID_TABLE_INDEX BINARY_INTEGER;
    v_TIME_ZONE VARCHAR2(3) := MM_PJM_EMKT_UTIL.g_PJM_TIME_ZONE;
    v_CURRENT_DATE DATE := TRUNC(p_BEGIN_DATE);
    v_SUBMIT_XML XMLTYPE;
    v_CURRENT_XML XMLTYPE;
    v_RESPONSE_XML       XMLTYPE;
    v_ACTION VARCHAR2(64) := p_EXCHANGE_TYPE;

    v_PJM_TRANSACTION_CODE XMLTYPE;
	v_UPDATE_STATUS_FOR_TEST BOOLEAN := FALSE;
	v_SUBMIT_MODE NUMBER(1);
	v_HOURS VARCHAR2(128);
	v_STATUS_REC MM_PJM_UTIL.t_STATUS;
	v_WHAT_IS_SUBMITTED VARCHAR2(32);

	v_LOG_ONLY NUMBER(1) :=0;
	v_CRED		mex_credentials;
	v_LOGGER	mm_logger_adapter;
	v_REQUEST_TYPE	 VARCHAR2(30);
	v_DUMMY_MESSAGE VARCHAR2(4000);
	
	v_PROCESS_NAME VARCHAR2(64);

	PROCEDURE UPDATE_STATUS
		(
		p_TRANSACTION_ID IN NUMBER,
		p_SUBMIT_MODE IN NUMBER,
		p_SUBMIT_STATUS  IN VARCHAR2,
		p_MARKET_STATUS  IN VARCHAR2
		) AS
		v_BEGIN_DATE DATE;
		v_END_DATE DATE;
		v_SECONDS VARCHAR2(2);
		v_CURRENT_HOUR NUMBER(2);
		v_SCHEDULE_DATE DATE;
		v_CURRENT_DAY DATE;
		v_INDEX BINARY_INTEGER;
		v_HOUR_STRING_TABLE GA.STRING_TABLE;
        v_IS_FALL_BACK BOOLEAN := FALSE;
        v_NUM BINARY_INTEGER := 0;
	BEGIN
		IF p_SUBMIT_MODE = MM_PJM_EMKT_UTIL.g_SUBMIT_MODE_NO_DATES THEN
			--For NO DATES mode, there is nothing to update.
			RETURN;
		ELSIF p_SUBMIT_MODE = MM_PJM_EMKT_UTIL.g_SUBMIT_MODE_SOME_HOURS AND NOT v_HOURS = MM_PJM_EMKT_UTIL.g_ALL_HOURS THEN
			--For SOME HOURS submissions, we will loop through the selected hours.
			UT.TOKENS_FROM_STRING(v_HOURS, ',', v_HOUR_STRING_TABLE);
			v_INDEX := v_HOUR_STRING_TABLE.FIRST;

			--Loop over DAYS
			v_CURRENT_DAY := TRUNC(p_BEGIN_DATE);

            --cn check if it is the fall back day
            IF TRUNC(DST_FALL_BACK_DATE(v_CURRENT_DAY)) = TRUNC(v_CURRENT_DAY) THEN
                v_IS_FALL_BACK := TRUE;
            END IF;

			WHILE v_CURRENT_DAY <= TRUNC(p_END_DATE) LOOP
				--Loop over HOURS
				LOOP
					v_CURRENT_HOUR  := TO_NUMBER(v_HOUR_STRING_TABLE(v_INDEX));
                    IF v_IS_FALL_BACK AND v_CURRENT_HOUR = 3 THEN
                        v_CURRENT_HOUR := 2;
                        v_NUM := 1;
                    ELSIF v_IS_FALL_BACK AND v_CURRENT_HOUR > 3 THEN
                        v_CURRENT_HOUR := v_CURRENT_HOUR - 1;
                        v_NUM := 0;
                    ELSE
                       v_NUM := 0;
                    END IF;

					v_SCHEDULE_DATE := TO_CUT_WITH_OPTIONS(v_CURRENT_DAY + v_CURRENT_HOUR / 24 + v_NUM/86400,
                                                            p_TIME_ZONE,
                                                            MM_PJM_UTIL.g_DST_SPRING_AHEAD_OPTION);

					UPDATE IT_TRAIT_SCHEDULE_STATUS	SET
						SUBMIT_STATUS = p_SUBMIT_STATUS,
						SUBMITTED_BY_ID = SECURITY_CONTROLS.CURRENT_USER_ID,
						SUBMIT_DATE = SYSDATE,
						MARKET_STATUS = p_MARKET_STATUS,
						MARKET_STATUS_DATE = SYSDATE
					WHERE TRANSACTION_ID = p_TRANSACTION_ID
						AND SCHEDULE_DATE = v_SCHEDULE_DATE;

					EXIT WHEN v_INDEX = v_HOUR_STRING_TABLE.LAST;
					v_INDEX := v_HOUR_STRING_TABLE.NEXT(v_INDEX);
				END LOOP; --OVER HOURS
				v_CURRENT_DAY := v_CURRENT_DAY + 1;
			END LOOP; -- OVER DAYS

		ELSE
			--For DAILY submissions, we want the ones that have an extra second.
			--For HOURLY submissions, we don't want the extra second.
			v_SECONDS := CASE p_SUBMIT_MODE WHEN MM_PJM_EMKT_UTIL.g_SUBMIT_MODE_DAILY THEN '01' ELSE '00' END;
			UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

			UPDATE IT_TRAIT_SCHEDULE_STATUS	SET
				SUBMIT_STATUS = p_SUBMIT_STATUS,
				SUBMITTED_BY_ID = SECURITY_CONTROLS.CURRENT_USER_ID,
				SUBMIT_DATE = SYSDATE,
				MARKET_STATUS = p_MARKET_STATUS,
				MARKET_STATUS_DATE = SYSDATE
			WHERE TRANSACTION_ID = p_TRANSACTION_ID
				AND SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND TO_CHAR(SCHEDULE_DATE, 'SS') = v_SECONDS;
		END IF;

	END UPDATE_STATUS;

BEGIN
	v_STATUS_REC.SUCCEEDED := 0;
	v_STATUS_REC.REJECTED := 0;
	v_STATUS_REC.ERROR := 0;
	
	IF v_ACTION = g_ET_SUBMIT_FIXED_DEMAND_BID THEN
		v_PROCESS_NAME := 'PJM:MktGW:' || v_ACTION;
	ELSE 
		v_PROCESS_NAME := 'PJM:EMKT:' || v_ACTION;
	END IF;

	--Init MEX to get the logger.
	MM_UTIL.INIT_MEX(EC.ES_PJM, NULL, v_PROCESS_NAME, v_ACTION, p_LOG_TYPE, p_TRACE_ON, v_CRED, v_LOGGER);
	MM_UTIL.START_EXCHANGE(FALSE, v_LOGGER);

	v_TRANSACTION_IDS := REPLACE(p_ENTITY_LIST, '''', '');
	UT.ID_TABLE_FROM_STRING(v_TRANSACTION_IDS, p_ENTITY_LIST_DELIMITER, v_TXN_ID_TABLE);
	v_HOURS := REPLACE(p_SUBMIT_HOURS, '''', '');

	IF NVL(p_LOG_ONLY,0) = 1 OR GET_DICTIONARY_VALUE('Is Test Mode', 0, 'MarketExchange', 'PJM') = '1' THEN
		v_LOG_ONLY :=1;
		IF GET_DICTIONARY_VALUE('Update Status In Test Mode', 0, 'MarketExchange', 'PJM') = '1' THEN
			v_UPDATE_STATUS_FOR_TEST := TRUE;
		END IF;
	END IF;

	--LOOP OVER TRANSACTIONS
	v_TXN_ID_TABLE_COUNT := v_TXN_ID_TABLE.COUNT;
	FOR v_TXN_ID_TABLE_INDEX IN 1 .. v_TXN_ID_TABLE_COUNT LOOP
		v_TRANSACTION_ID := v_TXN_ID_TABLE(v_TXN_ID_TABLE_INDEX).ID;

		-- get the external credentials for this transaction
		MM_UTIL.INIT_MEX(p_EXTERNAL_SYSTEM_ID => EC.ES_PJM,
			p_EXTERNAL_ACCOUNT_NAME => MM_UTIL.GET_EXT_ACCOUNT_FOR_TXN(v_TRANSACTION_ID, EC.ES_PJM),
			p_PROCESS_NAME => v_PROCESS_NAME,
			p_EXCHANGE_NAME => v_ACTION,
			p_LOG_TYPE => p_LOG_TYPE,
			p_TRACE_ON => p_TRACE_ON,
			p_CREDENTIALS => v_CRED,
			p_LOGGER => v_LOGGER);


		--LOOP OVER DATE RANGE, ONE DAY AT A TIME
		v_CURRENT_DATE := p_BEGIN_DATE;
		LOOP
			p_STATUS := GA.SUCCESS;

			IF v_ACTION = g_ET_INCREMENT_OFFER THEN
				VIRTUAL_BID(v_TRANSACTION_ID, TRUE, 1, v_CURRENT_DATE, v_TIME_ZONE, v_REQUEST_TYPE, v_CURRENT_XML, p_STATUS, p_MESSAGE);
				v_SUBMIT_MODE := MM_PJM_EMKT_UTIL.g_SUBMIT_MODE_ALL_HOURS;
				v_WHAT_IS_SUBMITTED := 'offers';
			ELSIF v_ACTION = g_ET_DECREMENT_BID THEN
				VIRTUAL_BID(v_TRANSACTION_ID, FALSE, 1, v_CURRENT_DATE, v_TIME_ZONE, v_REQUEST_TYPE, v_CURRENT_XML, p_STATUS, p_MESSAGE);
				v_SUBMIT_MODE := MM_PJM_EMKT_UTIL.g_SUBMIT_MODE_ALL_HOURS;
				v_WHAT_IS_SUBMITTED := 'bids';
			ELSIF v_ACTION = g_ET_PRICE_SENSIT_DEMAND_BID THEN
				PRICE_SENSITIVE_DEMAND_BID(v_TRANSACTION_ID, v_CURRENT_DATE, v_REQUEST_TYPE, v_CURRENT_XML, p_STATUS, p_MESSAGE);
				v_SUBMIT_MODE := MM_PJM_EMKT_UTIL.g_SUBMIT_MODE_ALL_HOURS;
				v_WHAT_IS_SUBMITTED := 'bids';
			ELSIF v_ACTION = g_ET_FIXED_DEMAND_BID THEN
				FIXED_DEMAND_BID(v_TRANSACTION_ID,  v_CURRENT_DATE, v_REQUEST_TYPE, v_CURRENT_XML, p_STATUS, p_MESSAGE);
				v_SUBMIT_MODE := MM_PJM_EMKT_UTIL.g_SUBMIT_MODE_ALL_HOURS;
				v_WHAT_IS_SUBMITTED := 'bids';
			ELSIF v_ACTION = g_ET_SUBMIT_FIXED_DEMAND_BID THEN
				FIXED_DEMAND_BID(v_TRANSACTION_ID,  v_CURRENT_DATE, v_REQUEST_TYPE, v_CURRENT_XML, p_STATUS, p_MESSAGE);
				v_SUBMIT_MODE := MM_PJM_EMKT_UTIL.g_SUBMIT_MODE_ALL_HOURS;
				v_WHAT_IS_SUBMITTED := 'bids';
			ELSE
				MM_PJM_EMKT_GEN.GET_SUBMIT_XML(v_ACTION, v_TRANSACTION_ID, v_CURRENT_DATE, p_SUBMIT_HOURS, v_TIME_ZONE, v_CURRENT_XML, v_SUBMIT_MODE, p_STATUS, p_MESSAGE);
				v_REQUEST_TYPE := REPLACE(INITCAP(v_ACTION),' ','');
				v_WHAT_IS_SUBMITTED := 'offers';
			END IF;

			v_LOGGER.EXCHANGE_NAME := 'MARKET_SUBMIT:' || v_REQUEST_TYPE;

			IF p_MESSAGE IS NOT NULL THEN RETURN; END IF;

			--Concatenate the xml together
			SELECT XMLCONCAT(v_SUBMIT_XML, v_CURRENT_XML) INTO v_SUBMIT_XML FROM DUAL;

			--ONLY GO THROUGH THIS CODE ONCE FOR DATE-INDEPENDENT EXCHANGES.
			EXIT WHEN v_CURRENT_DATE >= TRUNC(p_END_DATE) OR v_SUBMIT_MODE = MM_PJM_EMKT_UTIL.g_SUBMIT_MODE_NO_DATES;
			v_CURRENT_DATE := v_CURRENT_DATE + 1;
		END LOOP; -- OVER DATE RANGE

		--UPDATE SUBMIT STATUS TO PENDING.
		IF v_LOG_ONLY = 0 OR v_UPDATE_STATUS_FOR_TEST THEN
			UPDATE_STATUS(v_TRANSACTION_ID, v_SUBMIT_MODE, g_SUBMIT_STATUS_PENDING, g_MKT_STATUS_PENDING);
		END IF;

		--DO THE SUBMIT.
		MEX_PJM_EMKT.RUN_PJM_SUBMIT(v_CRED, v_LOG_ONLY, v_SUBMIT_XML, v_RESPONSE_XML, p_STATUS,  p_MESSAGE, v_LOGGER);
		v_SUBMIT_XML := NULL;

		IF p_MESSAGE IS NULL THEN
			p_MESSAGE := v_LOGGER.GET_END_MESSAGE;
		END IF;

		--UPDATE SUBMIT STATUS AS DETERMINED BY SUBMIT.
		IF v_LOG_ONLY = 0 THEN
			IF p_MESSAGE IS NULL THEN
				v_STATUS_REC.SUCCEEDED := v_STATUS_REC.SUCCEEDED + 1;
				UPDATE_STATUS(v_TRANSACTION_ID, v_SUBMIT_MODE, 'Submitted', 'Accepted');
			ELSE
				v_STATUS_REC.REJECTED := v_STATUS_REC.REJECTED + 1;
				UPDATE_STATUS(v_TRANSACTION_ID, v_SUBMIT_MODE, 'Submitted', 'Failed');
			END IF;
		ELSIF v_UPDATE_STATUS_FOR_TEST THEN
			UPDATE_STATUS(v_TRANSACTION_ID, v_SUBMIT_MODE, 'Tested', 'Tested');
		END IF;

	END LOOP; -- OVER TRANSACTIONS

	p_MESSAGE := MM_PJM_UTIL.GET_STATUS_MESSAGE(v_STATUS_REC, 'submitted', v_WHAT_IS_SUBMITTED);
	MM_UTIL.STOP_EXCHANGE(v_LOGGER, p_STATUS, p_MESSAGE, v_DUMMY_MESSAGE);

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;
		p_MESSAGE := UT.GET_FULL_ERRM;
		MM_UTIL.STOP_EXCHANGE(v_LOGGER, p_STATUS, p_MESSAGE, p_MESSAGE);
END MARKET_SUBMIT;
----------------------------------------------------------------------------------------------------
BEGIN
  ID.ID_FOR_ENTITY_ATTRIBUTE('PJM: eMKT Gen', EC.ED_INTERCHANGE_CONTRACT, 'String', FALSE, g_EMKT_GEN_ATTR);
  ID.ID_FOR_ENTITY_ATTRIBUTE('PJM: eMKT Load', EC.ED_INTERCHANGE_CONTRACT, 'String', FALSE, g_EMKT_LOAD_ATTR);
END MM_PJM_EMKT;
/
