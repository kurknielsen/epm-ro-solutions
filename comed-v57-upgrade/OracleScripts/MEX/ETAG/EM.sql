CREATE OR REPLACE PACKAGE EM AS

-- ENTITY MANAGER PACKAGE.

TYPE REF_CURSOR IS REF CURSOR;

FUNCTION WHAT_VERSION RETURN VARCHAR;

PROCEDURE TREE_BRANCHES_ENTITY_MANAGER
	(
    p_ENTITY_DOMAIN_ALIAS IN VARCHAR2,
    p_STANDALONE_CAPTION OUT VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE BILL_CYCLE_PERIODS
	(
	p_BILL_CYCLE_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_BILL_CYCLE_PERIOD
	(
	p_BILL_CYCLE_ID IN NUMBER,
	p_BILL_CYCLE_MONTH IN DATE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_BILL_CYCLE_MONTH IN DATE,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE PSE_ESPS
	(
	p_ESP_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_PSE_ESP
	(
	p_ESP_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_PSE_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	P_STATUS OUT NUMBER
	);

PROCEDURE PSE_CUSTOM_INVOICES
	(
	p_PSE_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_PSE_CUSTOM_INVOICE
	(
	p_PSE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_PSE_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	P_STATUS OUT NUMBER
	);

PROCEDURE ESP_POOLS
	(
	p_POOL_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_ESP_POOL
	(
	p_POOL_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
    p_ALLOCATION_PCT IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_ESP_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	P_STATUS OUT NUMBER
	);

PROCEDURE POOL_SUB_POOLS
	(
	p_POOL_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_POOL_SUB_POOL
	(
	p_POOL_ID IN NUMBER,
	p_SUB_POOL_ID IN NUMBER,
	p_ALLOCATION_PCT IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_SUB_POOL_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	P_STATUS OUT NUMBER
	);

PROCEDURE EDC_RATE_CLASSS
	(
	p_EDC_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_EDC_RATE_CLASS
	(
	p_EDC_ID IN NUMBER,
	p_RATE_CLASS IN VARCHAR,
	p_OLD_RATE_CLASS IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE EDC_LOSS_FACTORS
	(
	p_EDC_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_EDC_LOSS_FACTOR
	(
	p_EDC_ID IN NUMBER,
	p_CASE_ID IN NUMBER,
	p_LOSS_FACTOR_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_CASE_ID IN NUMBER,
	p_OLD_LOSS_FACTOR_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE SYSTEM_LOAD_AREAS
	(
	p_SYSTEM_LOAD_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_SYSTEM_LOAD_AREA
	(
	p_SYSTEM_LOAD_ID IN NUMBER,
	p_AREA_ID IN NUMBER,
	p_OPERATION_CODE IN CHAR,
	p_OLD_AREA_ID IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE EDC_CONVERSION_FACTORS
	(
	p_EDC_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_EDC_CONVERSION_FACTOR
	(
	p_EDC_ID IN NUMBER,
	p_SERVICE_AREA_ID IN NUMBER,
	p_FACTOR_CODE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_FACTOR_VAL IN NUMBER,
	p_OLD_SERVICE_AREA_ID IN NUMBER,
	p_OLD_FACTOR_CODE IN CHAR,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE PIPELINE_SEGMENT_FUELS
	(
	p_PIPELINE_SEGMENT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_PIPELINE_SEGMENT_FUEL
	(
	p_PIPELINE_SEGMENT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_FUEL_PCT IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE TRANSPORTATION_LEGS
	(
	p_TRANSPORTATION_PATH_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_TRANSPORTATION_LEG
	(
	p_TRANSPORTATION_PATH_ID IN NUMBER,
	p_PIPELINE_SEGMENT_ID IN NUMBER,
	p_LEG_ORDER IN NUMBER,
	p_OLD_LEG_ORDER IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE SERVICE_POINT_CITY_GATES
	(
	p_SERVICE_POINT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_SERVICE_POINT_CITY_GATE
	(
	p_SERVICE_POINT_ID IN NUMBER,
	p_CITY_GATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ALLOCATION_PCT IN NUMBER,
	p_OLD_CITY_GATE_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	P_STATUS OUT NUMBER
	);

PROCEDURE STATION_PARAMETERS
	(
	p_STATION_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_STATION_PARAMETER
	(
	p_STATION_ID IN NUMBER,
	p_PARAMETER_ID IN NUMBER,
	p_IS_SELECTED IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE STATION_COMPOSITES
	(
	p_STATION_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_STATION_COMPOSITE
	(
	p_STATION_ID IN NUMBER,
	p_COMPOSITE_STATION_ID IN NUMBER,
	p_COMPOSITE_PERCENT IN NUMBER,
	p_IS_SELECTED IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE PARAMETER_COMPOSITES
	(
	p_PARAMETER_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_PARAMETER_COMPOSITE
	(
	p_PARAMETER_ID IN NUMBER,
	p_COMPOSITE_PARAMETER_ID IN NUMBER,
	p_COMPOSITE_COEFFICIENT IN NUMBER,
	p_IS_SELECTED IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE PATH_PROVIDERS
   (
   p_PATH_ID IN NUMBER,
   p_STATUS OUT NUMBER,
   p_CURSOR IN OUT REF_CURSOR
   );

PROCEDURE PUT_PATH_PROVIDER
   (
   p_PATH_ID IN NUMBER,
   p_LEG_NBR IN NUMBER,
   p_CA_ID IN NUMBER,
   p_TP_ID IN NUMBER,
   p_PSE_ID IN NUMBER,
   p_TP_PRODUCT_CODE IN VARCHAR2,
   p_TP_PATH_NAME IN VARCHAR2,
   p_TP_ASSIGNMENT_REF IN VARCHAR2,
   p_TP_PRODUCT_LEVEL IN VARCHAR2,
   p_MISC_INFO IN VARCHAR2,
   p_MISC_REF IN VARCHAR2
   );

PROCEDURE CUSTOMER_AGGREGATE_ACCOUNTS
	(
	p_CUSTOMER_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_CUSTOMER_AGGREGATE_ACCOUNT
	(
	p_CUSTOMER_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_AGGREGATE_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE CONTACT_PHONE_NUMBERS
	(
	p_CONTACT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_CONTACT_PHONE_NUMBER
	(
	p_CONTACT_ID IN NUMBER,
	p_PHONE_TYPE IN VARCHAR,
	p_PHONE_NUMBER IN VARCHAR,
	p_OLD_PHONE_TYPE IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE CUSTOMER_PRODUCTS
	(
	p_CUSTOMER_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_CUSTOMER_PRODUCT
	(
	p_CUSTOMER_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_PRODUCT_TYPE IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_PRODUCT_ID IN NUMBER,
	p_OLD_PRODUCT_TYPE IN VARCHAR,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE CUSTOMER_ANCILLARY_SERVICES
	(
	p_CUSTOMER_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_CUSTOMER_ANCILLARY_SERVICE
	(
	p_CUSTOMER_ID IN NUMBER,
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SERVICE_VAL IN NUMBER,
	p_OLD_ANCILLARY_SERVICE_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE CUSTOMER_BILL_CYCLES
	(
	p_CUSTOMER_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_CUSTOMER_BILL_CYCLE
	(
	p_CUSTOMER_ID IN NUMBER,
	p_BILL_CYCLE_ID IN NUMBER,
	p_BILL_CYCLE_ENTITY IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_BILL_CYCLE_ID IN NUMBER,
	p_OLD_BILL_CYCLE_ENTITY IN VARCHAR,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_DOMAIN_KEYWORD_FROM_ID
	(
    p_DOMAIN_ID IN NUMBER,
    p_DOMAIN_KEYWORD OUT VARCHAR
    );

PROCEDURE GET_DOMAIN_ALIAS_FROM_ID
	(
    p_DOMAIN_ID IN NUMBER,
    p_DOMAIN_ALIAS OUT VARCHAR2
    );
PROCEDURE GET_DOMAIN_NAME_FROM_ID
	(
    p_DOMAIN_ID IN NUMBER,
    p_DOMAIN_NAME OUT VARCHAR
    );

PROCEDURE GET_ENTITY_NAME_FROM_IDs
	(
    p_DOMAIN_ID IN NUMBER,
    p_ENTITY_ID IN NUMBER,
    p_ENTITY_NAME OUT VARCHAR
    );

PROCEDURE TP_CONTRACT_NUMBERS
	(
	p_CONTRACT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_TP_CONTRACT_NUMBER
	(
	p_CONTRACT_ID IN NUMBER,
	p_TP_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CONTRACT_NAME IN VARCHAR2,
	p_CONTRACT_NUMBER IN VARCHAR2,
	p_OLD_TP_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE CONTRACT_COMP_ASSIGNMENTS
	(
	p_CONTRACT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT REF_CURSOR
	);

PROCEDURE PUT_CONTRACT_COMP_ASSIGNMENT
	(
	p_CONTRACT_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_PRODUCT_ID IN NUMBER,
	p_OLD_COMPONENT_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE CONTRACT_PRODUCTS
	(
	p_CONTRACT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT REF_CURSOR
	);

PROCEDURE PUT_CONTRACT_PRODUCT
	(
	p_CONTRACT_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_PRODUCT_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE CONTRACT_PROD_COMPONENTS
	(
	p_CONTRACT_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT REF_CURSOR
	);

PROCEDURE PUT_CONTRACT_PROD_COMPONENT
	(
	p_CONTRACT_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_COMPONENT_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE CONTRACT_NOTES
	(
	p_CONTRACT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_CONTRACT_NOTE
	(
	p_CONTRACT_ID IN NUMBER,
	p_NOTE_TYPE IN VARCHAR,
	p_NOTE_DATE IN DATE,
	p_NOTE_AUTHOR IN VARCHAR,
	p_NOTE_TEXT IN VARCHAR,
	p_OLD_NOTE_TYPE IN VARCHAR,
	p_OLD_NOTE_DATE IN DATE,
	p_OLD_NOTE_AUTHOR IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE CONTRACT_LIMIT_QUANTITYS
	(
	p_CONTRACT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_CONTRACT_LIMIT_QUANTITY
	(
	p_CONTRACT_ID IN NUMBER,
	p_LIMIT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_LIMIT_QUANTITY IN NUMBER,
	p_OLD_LIMIT_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE BILLING_ENTITY_LIST
	(
	p_BILLING_ENTITY_TYPE IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE SCHEDULE_TEMPLATE_LIST
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PIPELINE_ZONE_LIST
	(
	p_PIPELINE_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PIPELINE_POINT_LIST
	(
	p_PIPELINE_ID IN NUMBER,
	p_PIPELINE_ZONE_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE COMPONENT_FOR_PRODUCT_LIST
	(
	p_PRODUCT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE MODEL_LIST
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE LIST_STATEMENT_TYPES
	(
    p_STATUS OUT NUMBER,
    p_CURSOR IN OUT REF_CURSOR
    );

PROCEDURE EDC_SETTLEMENT_AGENT_LIST
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PORTFOLIO_SERVICE_POINTS
	(
	p_PORTFOLIO_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_PORTFOLIO_SERVICE_POINT
	(
	p_PORTFOLIO_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_IS_SELECTED IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE SUB_SERVICE_POINTS
	(
	p_SERVICE_POINT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_SUB_SERVICE_POINT
	(
	p_SERVICE_POINT_ID IN NUMBER,
	p_SUB_SERVICE_POINT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ALLOCATION_PCT IN NUMBER,
	p_OLD_SUB_SERVICE_POINT_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	P_STATUS OUT NUMBER
	);

PROCEDURE SUB_SERVICE_POINT_LIST
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_TRANSACTION
	(
	o_OID OUT NUMBER,
	p_TRANSACTION_NAME IN VARCHAR2,
	p_TRANSACTION_ALIAS IN VARCHAR2,
	p_TRANSACTION_DESC IN VARCHAR2,
	p_TRANSACTION_ID IN NUMBER,
    p_TRANSACTION_STATUS IN VARCHAR2,
	p_TRANSACTION_TYPE IN VARCHAR2,
	p_TRANSACTION_CODE IN CHAR,
	p_TRANSACTION_IDENTIFIER IN VARCHAR2,
	p_IS_FIRM IN NUMBER,
	p_IS_IMPORT_SCHEDULE IN NUMBER,
	p_IS_EXPORT_SCHEDULE IN NUMBER,
	p_IS_BALANCE_TRANSACTION IN NUMBER,
	p_IS_BID_OFFER IN NUMBER,
	p_IS_EXCLUDE_FROM_POSITION IN NUMBER,
    p_IS_IMPORT_EXPORT IN NUMBER,
	p_IS_DISPATCHABLE IN NUMBER,
	p_TRANSACTION_INTERVAL IN VARCHAR2,
	p_EXTERNAL_INTERVAL IN VARCHAR2,
	p_ETAG_CODE IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PURCHASER_ID IN NUMBER,
	p_SELLER_ID IN NUMBER,
	p_CONTRACT_ID IN NUMBER,
	p_SC_ID IN NUMBER,
	p_POR_ID IN NUMBER,
	p_POD_ID IN NUMBER,
	p_SCHEDULER_ID IN NUMBER,
	p_COMMODITY_ID IN NUMBER,
	p_SERVICE_TYPE_ID IN NUMBER,
	p_TX_TRANSACTION_ID IN NUMBER,
	p_PATH_ID IN NUMBER,
	p_LINK_TRANSACTION_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_SCHEDULE_GROUP_ID IN NUMBER,
	p_MARKET_PRICE_ID IN NUMBER,
	p_ZOR_ID IN NUMBER,
	p_ZOD_ID IN NUMBER,
	p_SOURCE_ID IN NUMBER,
	p_SINK_ID IN NUMBER,
	p_RESOURCE_ID IN NUMBER,
    p_AGREEMENT_TYPE IN VARCHAR2,
    p_APPROVAL_TYPE IN VARCHAR2,
    p_LOSS_OPTION IN VARCHAR2,
    p_TRAIT_CATEGORY IN VARCHAR2,
	p_MODEL_ID IN NUMBER,
	p_TP_ID IN NUMBER
	);

PROCEDURE GET_TRANSACTION
	(
	p_TRANSACTION_ID IN NUMBER,
	p_TRANSACTION_NAME OUT VARCHAR2,
	p_TRANSACTION_ALIAS OUT VARCHAR2,
	p_TRANSACTION_DESC OUT VARCHAR2,
    p_TRANSACTION_STATUS OUT VARCHAR2,
	p_TRANSACTION_TYPE OUT VARCHAR2,
	p_TRANSACTION_CODE OUT CHAR,
	p_TRANSACTION_IDENTIFIER OUT VARCHAR2,
	p_IS_FIRM OUT NUMBER,
	p_IS_IMPORT_SCHEDULE OUT NUMBER,
	p_IS_EXPORT_SCHEDULE OUT NUMBER,
	p_IS_BALANCE_TRANSACTION OUT NUMBER,
	p_IS_BID_OFFER OUT NUMBER,
	p_IS_EXCLUDE_FROM_POSITION OUT NUMBER,
    p_IS_IMPORT_EXPORT OUT NUMBER,
	p_IS_DISPATCHABLE OUT NUMBER,
	p_TRANSACTION_INTERVAL OUT VARCHAR2,
	p_EXTERNAL_INTERVAL OUT VARCHAR2,
	p_ETAG_CODE OUT VARCHAR2,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE,
	p_PURCHASER_ID OUT NUMBER,
	p_SELLER_ID OUT NUMBER,
	p_CONTRACT_ID OUT NUMBER,
	p_SC_ID OUT NUMBER,
	p_POR_ID OUT NUMBER,
	p_POD_ID OUT NUMBER,
	p_SCHEDULER_ID OUT NUMBER,
	p_COMMODITY_ID OUT NUMBER,
	p_SERVICE_TYPE_ID OUT NUMBER,
	p_TX_TRANSACTION_ID OUT NUMBER,
	p_PATH_ID OUT NUMBER,
	p_LINK_TRANSACTION_ID OUT NUMBER,
	p_EDC_ID OUT NUMBER,
	p_PSE_ID OUT NUMBER,
	p_ESP_ID OUT NUMBER,
	p_POOL_ID OUT NUMBER,
	p_SCHEDULE_GROUP_ID OUT NUMBER,
	p_MARKET_PRICE_ID OUT NUMBER,
	p_ZOR_ID OUT NUMBER,
	p_ZOD_ID OUT NUMBER,
	p_SOURCE_ID OUT NUMBER,
	p_SINK_ID OUT NUMBER,
	p_RESOURCE_ID OUT NUMBER,
    p_AGREEMENT_TYPE OUT VARCHAR2,
    p_APPROVAL_TYPE OUT VARCHAR2,
    p_LOSS_OPTION OUT VARCHAR2,
    p_TRAIT_CATEGORY OUT VARCHAR2,
	p_MODEL_ID OUT NUMBER,
	p_TP_ID OUT NUMBER
	);

PROCEDURE LIST_TRANSACTIONS
	(
	p_SEARCH_STRING IN VARCHAR,
	p_SEARCH_BY_ALIAS IN NUMBER,
	p_INCLUDE_INACTIVE IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE LIST_GAS_TRANSACTIONS
	(
	p_SEARCH_STRING IN VARCHAR,
	p_SEARCH_BY_ALIAS IN NUMBER,
	p_INCLUDE_INACTIVE IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE BALANCE_TRANSACTIONS
	(
	p_TRANSACTION_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
    );

PROCEDURE PUT_BALANCE_TRANSACTION
	(
    p_TRANSACTION_ID IN NUMBER,
    p_BALANCE_TRANSACTION_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
	p_OLD_BALANCE_TRANSACTION_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	P_STATUS OUT NUMBER
    );

PROCEDURE BALANCING_TRANSACTIONS
	(
	p_TRANSACTION_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
    );

PROCEDURE PUT_BALANCING_TRANSACTION
	(
    p_TRANSACTION_ID IN NUMBER,
    p_BALANCING_TRANSACTION_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
	p_OLD_BALANCING_TRANSACTION_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	P_STATUS OUT NUMBER
    );

PROCEDURE PUT_IT_TRANSPORTATION_PATH
	(
	p_TRANSACTION_ID IN NUMBER,
	p_TRANSPORTATION_PATH_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ALLOCATION IN NUMBER,
	p_IS_PERCENT IN NUMBER,
  p_OLD_TRANSPORTATION_PATH_ID IN NUMBER,
  p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE IT_TRANSPORTATION_PATHS
	(
	p_TRANSACTION_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE BALANCE_SUPPLY_TRANSACTIONS
	(
	p_COMMODITY_ID IN NUMBER,
	p_INTERVAL IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE BALANCE_LOAD_TRANSACTIONS
	(
	p_COMMODITY_ID IN NUMBER,
	p_INTERVAL IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE GET_SHOW_FIND_FOR_ENTITY
	(
	p_MODEL_ID IN NUMBER,
    p_ENTITY_DOMAIN_ALIAS IN VARCHAR2,
    p_VALUE OUT VARCHAR2,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_HOLIDAY_OBSERVANCE
	(
	p_HOLIDAY_ID IN NUMBER,
	p_HOLIDAY_YEAR IN NUMBER,
	p_HOLIDAY_DATE IN DATE,
	p_OLD_HOLIDAY_YEAR IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE HOLIDAY_OBSERVANCES
	(
	p_HOLIDAY_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_HOLIDAY_SET_EDC
	(
	p_HOLIDAY_SET_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_IS_SELECTED IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE HOLIDAY_SET_EDCS
	(
	p_HOLIDAY_SET_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_INCLUDED_HOLIDAY
	(
	p_HOLIDAY_SET_ID IN NUMBER,
	p_HOLIDAY_ID IN NUMBER,
	p_IS_SELECTED IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE INCLUDED_HOLIDAYS
	(
	p_HOLIDAY_SET_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE HOLIDAY_SCHEDULES
	(
	p_HOLIDAY_SET_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_PRODUCT_COMPONENT
	(
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_COMPONENT_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE PRODUCT_COMPONENTS
	(
	p_PRODUCT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_COMPONENT_PERCENTAGE
	(
	p_COMPONENT_ID IN NUMBER,
	p_SUB_COMPONENT_TYPE IN VARCHAR2,
	p_SUB_COMPONENT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PERCENT_VAL IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE COMPONENT_PERCENTAGES
	(
	p_COMPONENT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_MARKET_FORWARD_PRICE
	(
	p_MARKET_PRICE_ID IN NUMBER,
	p_CONTRACT_MONTH IN DATE,
	p_CONTRACT_TYPE IN CHAR,
	p_CONTRACT_DATE IN DATE,
	p_BID_PRICE IN NUMBER,
	p_ASK_PRICE IN NUMBER,
	p_LOW_PRICE IN NUMBER,
	p_HIGH_PRICE IN NUMBER,
	p_OLD_CONTRACT_MONTH IN DATE,
	p_OLD_CONTRACT_TYPE IN CHAR,
	p_OLD_CONTRACT_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE MARKET_FORWARD_PRICES
	(
	p_MARKET_PRICE_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_MARKET_PRICE_COMPOSITE
	(
	p_MARKET_PRICE_ID IN NUMBER,
	p_COMPOSITE_PRICE_ID IN NUMBER,
	p_COMPOSITE_MULTIPLIER IN NUMBER,
	p_COMPOSITE_OPTION IN VARCHAR,
	p_OLD_COMPOSITE_PRICE_ID IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE MARKET_PRICE_COMPOSITES
	(
	p_MARKET_PRICE_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE NON_COMPOSITE_MARKET_PRICES
	(
    p_STATUS OUT NUMBER,
    p_CURSOR IN OUT REF_CURSOR
    );

PROCEDURE GEOGRAPHY_PARENT_LIST
	(
    p_GEOGRAPHY_TYPE IN VARCHAR2,
    p_STATUS OUT NUMBER,
    p_CURSOR IN OUT REF_CURSOR
    );

PROCEDURE PUT_ADDRESS
	(
	o_OID OUT NUMBER,
	p_ADDRESS_NAME IN VARCHAR2,
	p_ADDRESS_ALIAS IN VARCHAR2,
	p_ADDRESS_DESC IN VARCHAR2,
	p_ADDRESS_ID IN NUMBER,
	p_STREET IN VARCHAR2,
    p_CITY IN VARCHAR2,
    p_STATE_CODE IN VARCHAR2,
    p_POSTAL_CODE IN VARCHAR2,
    p_COUNTRY_CODE IN VARCHAR2,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2
    );

PROCEDURE GET_ADDRESS
	(
	p_ADDRESS_ID IN NUMBER,
	p_ADDRESS_NAME OUT VARCHAR2,
	p_ADDRESS_ALIAS OUT VARCHAR2,
	p_ADDRESS_DESC OUT VARCHAR2,
	p_STREET OUT VARCHAR2,
    p_CITY OUT VARCHAR2,
    p_STATE_CODE OUT VARCHAR2,
    p_POSTAL_CODE OUT VARCHAR2,
    p_COUNTRY_CODE OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2
    );

PROCEDURE ADDRESS_GEOGRAPHY_LIST
	(
    p_PARENT_TYPE IN VARCHAR2,
    p_PARENT_NAME IN VARCHAR2,
    p_PARENT_ABBR IN NUMBER,
    p_G_PARENT_TYPE IN VARCHAR2,
    p_G_PARENT_NAME IN VARCHAR2,
    p_G_PARENT_ABBR IN NUMBER,
    p_GG_PARENT_TYPE IN VARCHAR2,
    p_GG_PARENT_NAME IN VARCHAR2,
    p_GG_PARENT_ABBR IN NUMBER,
    p_LIST_TYPE IN VARCHAR2,
    p_LIST_ABBR IN NUMBER,
    p_STATUS OUT NUMBER,
    p_CURSOR IN OUT REF_CURSOR
    );

PROCEDURE ENTITY_ATTRIBUTE_VALUES
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_OWNER_ENTITY_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_ENTITY_ATTRIBUTE
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ATTRIBUTE_NAME IN VARCHAR2,
	p_ATTRIBUTE_ID IN NUMBER,
	p_ATTRIBUTE_TYPE IN VARCHAR2,
	p_ATTRIBUTE_SHOW IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_ENTITY_ATTRIBUTE_VALUE
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_OWNER_ENTITY_ID IN NUMBER,
	p_ATTRIBUTE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ATTRIBUTE_VAL IN VARCHAR2,
	p_OLD_OWNER_ENTITY_ID IN NUMBER,
	p_OLD_ATTRIBUTE_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE ENTITY_CONTACTS_ADDRESSES
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_OWNER_ENTITY_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_ENTITY_CONTACT_ADDRESS
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_OWNER_ENTITY_ID IN NUMBER,
	p_CATEGORY_ID IN NUMBER,
	p_CONTACT_ID IN NUMBER,
	p_ADDRESS_ID IN NUMBER,
	p_OLD_CATEGORY_ID IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE ENTITY_ATTRIBUTES_FOR_DOMAIN
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT REF_CURSOR
	);

PROCEDURE LIST_TEMPLATES
	(
	p_SEARCH_STRING IN VARCHAR,
	p_SEARCH_BY_ALIAS IN NUMBER,
	p_INCLUDE_INACTIVE IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE LIST_DAY_TYPE_TEMPLATES
	(
	p_SEARCH_STRING IN VARCHAR,
	p_SEARCH_BY_ALIAS IN NUMBER,
	p_INCLUDE_INACTIVE IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE DOMAIN_ENTITY_ATTRIBUTES
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_DOMAIN_ENTITY_ATTRIBUTE
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ATTRIBUTE_ID IN NUMBER,
	p_ATTRIBUTE_NAME IN VARCHAR2,
	p_ATTRIBUTE_TYPE IN VARCHAR2,
	p_ATTRIBUTE_SHOW IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE PATH_SEGMENTS
	(
	p_PATH_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_PATH_SEGMENT
	(
	p_PATH_ID IN NUMBER,
	p_SEGMENT_ID IN NUMBER,
	p_SEGMENT_POS IN NUMBER,
	p_OLD_SEGMENT_ID IN NUMBER,
	p_OLD_SEGMENT_POS IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE SYSTEM_ACTION_ROLES
	(
	p_ACTION_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_SYSTEM_ACTION_ROLE
	(
	p_ACTION_ID IN NUMBER,
	p_ROLE_ID IN NUMBER,
	p_REALM_ID IN NUMBER,
	p_OLD_ROLE_ID IN NUMBER,
	p_OLD_REALM_ID IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE MKT_PATH_MKT_SEGS
  (
  p_MARKET_PATH_ID IN NUMBER,
	p_STATUS         OUT NUMBER,
	p_CURSOR         IN OUT REF_CURSOR
  );

PROCEDURE MKT_SEG_PHYS_SEGS
  (
  p_MARKET_SEGMENT_ID IN NUMBER,
	p_STATUS            OUT NUMBER,
	p_CURSOR            IN OUT REF_CURSOR
  );

PROCEDURE PUT_MKT_PATH_MKT_SEG
  (
  p_MARKET_PATH_ID        IN NUMBER,
  p_MARKET_SEGMENT_ID     IN NUMBER,
  p_SEGMENT_ORDER         IN NUMBER,
  p_OLD_MARKET_SEGMENT_ID IN NUMBER,
  p_OLD_SEGMENT_ORDER IN NUMBER,
  p_STATUS                OUT NUMBER
  );

PROCEDURE PUT_MKT_SEG_PHYS_SEG
  (
  p_MARKET_SEGMENT_ID       IN NUMBER,
  p_PHYSICAL_SEGMENT_ID     IN NUMBER,
  p_SEGMENT_ORDER           IN NUMBER,
  p_OLD_PHYSICAL_SEGMENT_ID IN NUMBER,
  p_OLD_SEGMENT_ORDER       IN NUMBER,
  p_STATUS                  OUT NUMBER
  );

PROCEDURE ETAG_DETAILS
	(
	p_TRANSACTION_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
  );

PROCEDURE PUT_ETAG_DETAIL
  (
  p_TRANSACTION_ID IN NUMBER,
    p_ETAG_ID IN NUMBER,
    p_OLD_ETAG_ID  IN NUMBER,
  p_STATUS OUT NUMBER
  );
         
PROCEDURE HEAT_RATE_CURVE_POINTS
	(
	p_HEAT_RATE_CURVE_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE PUT_HEAT_RATE_CURVE_POINT
	(
	p_HEAT_RATE_CURVE_ID IN NUMBER,
	p_PARAMETER_1_VAL IN NUMBER,
	p_PARAMETER_2_VAL IN NUMBER,
	p_PARAMETER_3_VAL IN NUMBER,
	p_AMOUNT IN NUMBER,
	p_OPERATING_MODE IN VARCHAR2,
	p_PRICE IN NUMBER,
	p_OLD_PARAMETER_1_VAL IN NUMBER,
	p_OLD_PARAMETER_2_VAL IN NUMBER,
	p_OLD_PARAMETER_3_VAL IN NUMBER,
	p_OLD_AMOUNT IN NUMBER,
	p_OLD_OPERATING_MODE IN VARCHAR2,
	p_STATUS OUT NUMBER
	);
                  
PROCEDURE TRANSACTION_LIMITS
	(
	p_TRANSACTION_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT REF_CURSOR
	);

PROCEDURE PUT_TRANSACTION_LIMIT
	(
	p_TRANSACTION_ID IN NUMBER,
	p_LIMIT_INTERVAL IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_MIN_TRANSACTION_ID IN NUMBER,
	p_LIMIT_TRANSACTION_ID IN NUMBER,
	p_OLD_LIMIT_INTERVAL IN VARCHAR2,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE SYSTEM_ALERT_ROLES
	(
	p_ALERT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);
	
PROCEDURE PUT_SYSTEM_ALERT_ROLE
	(
	p_ALERT_ID IN NUMBER,
	p_ROLE_ID IN NUMBER,
	p_IS_SELECTED IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE ETAG_MARKET_SEGMENTS
	(
	p_ETAG_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE ETAG_PHYSICAL_SEGMENTS
	(
	p_ETAG_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE ETAG_PROFILES
	(
	p_ETAG_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);

PROCEDURE TRANSACTION_TRAITS
	(
	p_TRAIT_GROUP_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	);
	
PROCEDURE PUT_TRANSACTION_TRAIT
	(
	p_TRAIT_GROUP_ID IN NUMBER,
	p_TRAIT_INDEX IN NUMBER,
	p_SYSTEM_OBJECT_ID IN NUMBER,
	p_DISPLAY_NAME IN VARCHAR2,
	p_DISPLAY_ORDER IN NUMBER,
	p_DATA_TYPE IN VARCHAR2,
	p_FORMAT IN VARCHAR2,
	p_COMBO_LIST IN VARCHAR2,
	p_EDIT_MASK IN VARCHAR2,
	p_STATUS OUT NUMBER
	);

PROCEDURE CONDITIONAL_FORMAT_ITEMS
	(
	p_CONDITIONAL_FORMAT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT REF_CURSOR
	);
    
PROCEDURE PUT_CONDITIONAL_FORMAT_ITEM
	(
	p_CONDITIONAL_FORMAT_ID IN NUMBER,
	p_ITEM_NUMBER IN NUMBER,
	p_COLOR_WHEN_FORMULA IN VARCHAR,
	p_FOREGROUND_COLOR IN NUMBER,
	p_BACKGROUND_COLOR IN NUMBER,
	p_IS_BOLD IN NUMBER,
	p_IS_ITALIC IN NUMBER,
	p_IS_STRIKE_THROUGH IN NUMBER,
	p_IS_UNDERLINE IN NUMBER,
	p_STATUS OUT NUMBER
	);
    
PROCEDURE GET_FORMAT_WITH_ITEMS
	(
	p_CONDITIONAL_FORMAT_NAME IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT REF_CURSOR
	);

g_DOMAIN_NAME VARCHAR(16) := 'Data Setup';
g_SHOW_FIND_IN_TREE VARCHAR(32) := 'Show Find in Tree';
g_ALL NUMBER := -1;

INSUFFICIENT_PRIVILEGES EXCEPTION;
PRAGMA EXCEPTION_INIT(INSUFFICIENT_PRIVILEGES, -1031);
INVALID_DATE_RANGE EXCEPTION;
PRAGMA EXCEPTION_INIT(INVALID_DATE_RANGE, -20999);
INVALID_AGGREGATE_ACCOUNT EXCEPTION;
PRAGMA EXCEPTION_INIT(INVALID_AGGREGATE_ACCOUNT, -20998);
END EM;
/
CREATE OR REPLACE PACKAGE BODY EM AS
---------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
    RETURN '04142004.1';
END WHAT_VERSION;
---------------------------------------------------------------------------------------------------
PROCEDURE NULL_CURSOR
    (
	p_CURSOR IN OUT REF_CURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
		SELECT NULL FROM DUAL;

END NULL_CURSOR;
----------------------------------------------------------------------------------------------------
PROCEDURE TREE_BRANCHES_ENTITY_MANAGER
	(
    p_ENTITY_DOMAIN_ALIAS IN VARCHAR2,
    p_STANDALONE_CAPTION OUT VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

-- Answer the branches for the entity manager tree from the ENTITY_DOMAIN table.

BEGIN
	IF NOT Can_Read(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
    p_STATUS := GA.SUCCESS;

     -- see if entity domain was specified - if so, need to know if it is a stand-alone entity or
     -- not so we know whether to get only selected domain for tree or all domains
	BEGIN
    	IF p_ENTITY_DOMAIN_ALIAS IS NULL THEN
        	p_STANDALONE_CAPTION := NULL;
		ELSE
			SELECT B.ATTRIBUTE_VAL INTO p_STANDALONE_CAPTION
            FROM SYSTEM_OBJECT A, SYSTEM_OBJECT_ATTRIBUTE B
			WHERE A.OBJECT_CATEGORY = 'IO Table'
                AND A.OBJECT_NAME = p_ENTITY_DOMAIN_ALIAS
                AND B.OBJECT_ID = A.OBJECT_ID
                AND B.ATTRIBUTE_ID = 205;
		END IF;
	EXCEPTION
    	WHEN OTHERS THEN
        	p_STANDALONE_CAPTION := NULL;
    END;

	IF p_STANDALONE_CAPTION IS NULL THEN
    	-- not stand-alone?
    	 OPEN p_CURSOR FOR
    	   SELECT ENTITY_DOMAIN_CATEGORY "ENTITY_DOMAIN_DESC",
           			 NVL(DISPLAY_NAME,ENTITY_DOMAIN_NAME) "ENTITY_DOMAIN_NAME",
                     ENTITY_DOMAIN_TABLE_ALIAS "ENTITY_DOMAIN_ALIAS",
                     ENTITY_DOMAIN_ID, ENTITY_DOMAIN_TABLE,
    				 DECODE(C.VALUE,1,1,0) "ENTITY_IS_NUMEROUS",
                     NVL(D.ATTRIBUTE_VAL,0) "ENTITY_FILTER_BY_DATE",
                     E.ATTRIBUTE_VAL "ENTITY_TREE_LIST_PROC"
    		FROM ENTITY_DOMAIN A, SYSTEM_OBJECT B, SYSTEM_DICTIONARY C,
            	SYSTEM_OBJECT_ATTRIBUTE D,
            	SYSTEM_OBJECT_ATTRIBUTE E,
                SYSTEM_OBJECT_ATTRIBUTE F
    		WHERE	ENTITY_DOMAIN_CATEGORY IS NOT NULL
    			AND B.OBJECT_CATEGORY = 'IO Table'
    			AND A.ENTITY_DOMAIN_TABLE_ALIAS = B.OBJECT_NAME
				AND C.MODEL_ID(+) = 0
    			AND C.MODULE(+) = 'Entity Manager'
    			AND C.KEY1(+) = 'Show Find in Tree'
    			AND C.KEY2(+) = '?'
    			AND C.KEY3(+) = '?'
    			AND C.SETTING_NAME(+) = A.ENTITY_DOMAIN_TABLE_ALIAS
                AND D.OBJECT_ID(+) = B.OBJECT_ID
                AND D.ATTRIBUTE_ID(+) = 206 -- filter by date attribute
                AND E.OBJECT_ID(+) = B.OBJECT_ID
                AND E.ATTRIBUTE_ID(+) = 204 -- tree list routine attribute
                AND F.OBJECT_ID(+) = B.OBJECT_ID
                AND F.ATTRIBUTE_ID(+) = 205 -- stand-alone attribute
                AND F.ATTRIBUTE_VAL IS NULL -- only entities that aren't stand-alone
    		ORDER BY 1,2;
	ELSE
    	 OPEN p_CURSOR FOR
    	   SELECT ENTITY_DOMAIN_CATEGORY "ENTITY_DOMAIN_DESC",
           			 NVL(DISPLAY_NAME,ENTITY_DOMAIN_NAME) "ENTITY_DOMAIN_NAME",
                     ENTITY_DOMAIN_TABLE_ALIAS "ENTITY_DOMAIN_ALIAS",
                     ENTITY_DOMAIN_ID, ENTITY_DOMAIN_TABLE,
    				 DECODE(C.VALUE,1,1,0) "ENTITY_IS_NUMEROUS",
                     NVL(D.ATTRIBUTE_VAL,0) "ENTITY_FILTER_BY_DATE",
                     E.ATTRIBUTE_VAL "ENTITY_TREE_LIST_PROC"
    		FROM ENTITY_DOMAIN A, SYSTEM_OBJECT B, SYSTEM_DICTIONARY C,
            	SYSTEM_OBJECT_ATTRIBUTE D,
            	SYSTEM_OBJECT_ATTRIBUTE E
    		WHERE	ENTITY_DOMAIN_CATEGORY IS NOT NULL
    			AND B.OBJECT_CATEGORY = 'IO Table'
                AND B.OBJECT_NAME = p_ENTITY_DOMAIN_ALIAS -- only the selected entity domain
    			AND A.ENTITY_DOMAIN_TABLE_ALIAS = B.OBJECT_NAME
				AND C.MODEL_ID(+) = 0
    			AND C.MODULE(+) = 'Entity Manager'
    			AND C.KEY1(+) = 'Show Find in Tree'
    			AND C.KEY2(+) = '?'
    			AND C.KEY3(+) = '?'
    			AND C.SETTING_NAME(+) = A.ENTITY_DOMAIN_TABLE_ALIAS
                AND D.OBJECT_ID(+) = B.OBJECT_ID
                AND D.ATTRIBUTE_ID(+) = 206 -- filter by date attribute
                AND E.OBJECT_ID(+) = B.OBJECT_ID
                AND E.ATTRIBUTE_ID(+) = 204 -- tree list routine attribute
    		ORDER BY 1,2;
    END IF;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;
END TREE_BRANCHES_ENTITY_MANAGER;
---------------------------------------------------------------------------------------------------
PROCEDURE BILL_CYCLE_PERIODS
	(
	p_BILL_CYCLE_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

-- Answer the CONTRACTs for the given ACCOUNT.

BEGIN
	IF NOT Can_Read(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
    p_STATUS := GA.SUCCESS;

	 OPEN p_CURSOR FOR
	    SELECT BILL_CYCLE_ID, BILL_CYCLE_MONTH, BEGIN_DATE, END_DATE, ENTRY_DATE
		FROM BILL_CYCLE_PERIOD
		WHERE	BILL_CYCLE_ID = p_BILL_CYCLE_ID
		ORDER BY 2,3;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;
END BILL_CYCLE_PERIODS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_BILL_CYCLE_PERIOD
	(
	p_BILL_CYCLE_ID IN NUMBER,
	p_BILL_CYCLE_MONTH IN DATE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_BILL_CYCLE_MONTH IN DATE,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	)AS

CURSOR c_BILL_CYCLE_PERIOD IS
	SELECT *
	FROM BILL_CYCLE_PERIOD
	WHERE BILL_CYCLE_ID = p_BILL_CYCLE_ID
		AND BILL_CYCLE_MONTH = TRUNC(p_BILL_CYCLE_MONTH,'MM')
	ORDER BY BEGIN_DATE DESC;

v_BILL_CYCLE_PERIOD BILL_CYCLE_PERIOD%ROWTYPE;
v_END_DATE DATE;
v_INITIAL BOOLEAN;
BEGIN
	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- UPDATE THE CURRENT BILL PERIOD INTERVAL ASSIGNMENT IF ONE EXISTS
	UPDATE BILL_CYCLE_PERIOD SET
		BILL_CYCLE_MONTH = TRUNC(p_BILL_CYCLE_MONTH,'MM'),
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		ENTRY_DATE = SYSDATE
	WHERE BILL_CYCLE_ID = p_BILL_CYCLE_ID
		AND BILL_CYCLE_MONTH = p_OLD_BILL_CYCLE_MONTH
		AND BEGIN_DATE = p_OLD_BEGIN_DATE;


-- NO UPDATE FOR THIS BILL PERIOD INTERVAL SO INSERT A NEW ONE.
	IF SQL%NOTFOUND THEN
		INSERT INTO BILL_CYCLE_PERIOD (
			BILL_CYCLE_ID,
			BILL_CYCLE_MONTH,
			BEGIN_DATE,
			END_DATE,
			ENTRY_DATE)
		VALUES (
			p_BILL_CYCLE_ID,
			TRUNC(p_BILL_CYCLE_MONTH,'MM'),
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			SYSDATE);
	END IF;

	OPEN c_BILL_CYCLE_PERIOD;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_BILL_CYCLE_PERIOD INTO v_BILL_CYCLE_PERIOD;
		EXIT WHEN c_BILL_CYCLE_PERIOD%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_BILL_CYCLE_PERIOD.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE BILL_CYCLE_PERIOD
		SET END_DATE = GREATEST(v_END_DATE, v_BILL_CYCLE_PERIOD.BEGIN_DATE)
		WHERE BILL_CYCLE_ID = v_BILL_CYCLE_PERIOD.BILL_CYCLE_ID
			AND BILL_CYCLE_MONTH = v_BILL_CYCLE_PERIOD.BILL_CYCLE_MONTH
			AND BEGIN_DATE = v_BILL_CYCLE_PERIOD.BEGIN_DATE;
		v_END_DATE := v_BILL_CYCLE_PERIOD.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_BILL_CYCLE_PERIOD;

	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			p_STATUS := GA.DUPLICATE_ENTITY;
			RETURN;
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
			RETURN;
		WHEN OTHERS THEN
			RAISE;
END PUT_BILL_CYCLE_PERIOD;
------------------------------------------------------------------------------------------------
PROCEDURE PSE_ESPS
	(
	p_ESP_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

-- Answer the CONTRACTs for the given ACCOUNT.

BEGIN
	IF NOT Can_Read(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
    p_STATUS := GA.SUCCESS;

	 OPEN p_CURSOR FOR
	    SELECT PSE_ID, BEGIN_DATE, END_DATE, ENTRY_DATE, ESP_ID
		FROM PSE_ESP A
		WHERE ESP_ID = p_ESP_ID
		ORDER BY 2;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;
END PSE_ESPS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_PSE_ESP
	(
	p_ESP_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_PSE_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	P_STATUS OUT NUMBER
	)
	AS

CURSOR c_PSE_ESP IS
	SELECT *
	FROM PSE_ESP
	WHERE ESP_ID = p_ESP_ID
	ORDER BY BEGIN_DATE DESC;

v_PSE_ESP PSE_ESP%ROWTYPE;
v_END_DATE DATE;
v_INITIAL BOOLEAN;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- UPDATE THE CURRENT ESP SC ASSIGNMENT IF ONE EXISTS

	UPDATE PSE_ESP SET
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		ENTRY_DATE = SYSDATE,
		PSE_ID = p_PSE_ID
	WHERE ESP_ID = p_ESP_ID
		AND PSE_ID = p_OLD_PSE_ID
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS ESP SC COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO PSE_ESP
			(
			ESP_ID,
			PSE_ID,
			BEGIN_DATE,
			END_DATE,
			ENTRY_DATE
			)
		VALUES
			(
			p_ESP_ID,
			p_PSE_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			SYSDATE
			);
	END IF;

	OPEN c_PSE_ESP;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_PSE_ESP INTO v_PSE_ESP;
		EXIT WHEN c_PSE_ESP%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_PSE_ESP.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE PSE_ESP
		SET END_DATE = GREATEST(v_END_DATE, v_PSE_ESP.BEGIN_DATE)
		WHERE ESP_ID = v_PSE_ESP.ESP_ID
			AND PSE_ID = v_PSE_ESP.PSE_ID
			AND BEGIN_DATE = v_PSE_ESP.BEGIN_DATE;
		v_END_DATE := v_PSE_ESP.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_PSE_ESP;

	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			p_STATUS := GA.DUPLICATE_ENTITY;
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		WHEN OTHERS THEN
			RAISE;

END PUT_PSE_ESP;

------------------------------------------------------------------------------------------------
PROCEDURE PSE_CUSTOM_INVOICES
	(
	p_PSE_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

-- Answer the CONTRACTs for the given ACCOUNT.

BEGIN
	IF NOT Can_Read(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
    p_STATUS := GA.SUCCESS;

	 OPEN p_CURSOR FOR
	    SELECT PSE_ID, BEGIN_DATE, END_DATE, ENTRY_DATE
		FROM PSE_CUSTOM_INVOICE A
		WHERE PSE_ID = p_PSE_ID
		ORDER BY 2;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;
END PSE_CUSTOM_INVOICES;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_PSE_CUSTOM_INVOICE
	(
	p_PSE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_PSE_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	P_STATUS OUT NUMBER
	)
	AS

CURSOR c_PSE_CUSTOM_INVOICE IS
	SELECT *
	FROM PSE_CUSTOM_INVOICE
	WHERE PSE_ID = p_PSE_ID
	ORDER BY BEGIN_DATE DESC;

v_PSE_CUSTOM_INVOICE PSE_CUSTOM_INVOICE%ROWTYPE;
v_END_DATE DATE;
v_INITIAL BOOLEAN;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- UPDATE THE CURRENT PSE CUSTOM INVOICE IF ONE EXISTS

	UPDATE PSE_CUSTOM_INVOICE SET
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		ENTRY_DATE = SYSDATE
	WHERE PSE_ID = p_OLD_PSE_ID
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS ESP SC COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO PSE_CUSTOM_INVOICE
			(
			PSE_ID,
			BEGIN_DATE,
			END_DATE,
			ENTRY_DATE
			)
		VALUES
			(
			p_PSE_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			SYSDATE
			);
	END IF;

	OPEN c_PSE_CUSTOM_INVOICE;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_PSE_CUSTOM_INVOICE INTO v_PSE_CUSTOM_INVOICE;
		EXIT WHEN c_PSE_CUSTOM_INVOICE%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_PSE_CUSTOM_INVOICE.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE PSE_CUSTOM_INVOICE
		SET END_DATE = GREATEST(v_END_DATE, v_PSE_CUSTOM_INVOICE.BEGIN_DATE)
		WHERE PSE_ID = v_PSE_CUSTOM_INVOICE.PSE_ID
			AND BEGIN_DATE = v_PSE_CUSTOM_INVOICE.BEGIN_DATE;
		v_END_DATE := v_PSE_CUSTOM_INVOICE.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_PSE_CUSTOM_INVOICE;

	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			p_STATUS := GA.DUPLICATE_ENTITY;
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		WHEN OTHERS THEN
			RAISE;

END PUT_PSE_CUSTOM_INVOICE;

----------------------------------------------------------------------------------------------------
PROCEDURE ESP_POOLS
	(
	p_POOL_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

-- Answer the ESPS FOR THE GIVEN POOL

BEGIN
	IF NOT Can_Read(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
    p_STATUS := GA.SUCCESS;

	 OPEN p_CURSOR FOR
	   SELECT ESP_ID, ALLOCATION_PCT, BEGIN_DATE, END_DATE, ENTRY_DATE, POOL_ID
		FROM ESP_POOL
		WHERE POOL_ID = p_POOL_ID
		ORDER BY 3;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;
END ESP_POOLS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_ESP_POOL
	(
	p_POOL_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_ALLOCATION_PCT IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_ESP_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	P_STATUS OUT NUMBER
	)
	AS

CURSOR c_ESP_POOL IS
	SELECT *
	FROM ESP_POOL
	WHERE POOL_ID = p_POOL_ID
	ORDER BY BEGIN_DATE DESC;

v_ESP_POOL ESP_POOL%ROWTYPE;
v_END_DATE DATE;
v_INITIAL BOOLEAN;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- UPDATE THE CURRENT ESP POOL ASSIGNMENT IF ONE EXISTS

	UPDATE ESP_POOL SET
		ALLOCATION_PCT = p_ALLOCATION_PCT,
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		ENTRY_DATE = SYSDATE,
		ESP_ID = p_ESP_ID
	WHERE POOL_ID = p_POOL_ID
		AND ESP_ID = p_OLD_ESP_ID
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS ESP POOL COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO ESP_POOL
			(
			POOL_ID,
			ESP_ID,
			ALLOCATION_PCT,
			BEGIN_DATE,
			END_DATE,
			ENTRY_DATE
			)
		VALUES
			(
			p_POOL_ID,
			p_ESP_ID,
			p_ALLOCATION_PCT,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			SYSDATE
			);
	END IF;

	OPEN c_ESP_POOL;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_ESP_POOL INTO v_ESP_POOL;
		EXIT WHEN c_ESP_POOL%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_ESP_POOL.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE ESP_POOL
		SET END_DATE = GREATEST(v_END_DATE, v_ESP_POOL.BEGIN_DATE)
		WHERE POOL_ID = v_ESP_POOL.POOL_ID
			AND ESP_ID = v_ESP_POOL.ESP_ID
			AND BEGIN_DATE = v_ESP_POOL.BEGIN_DATE;
		v_END_DATE := v_ESP_POOL.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_ESP_POOL;

	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			p_STATUS := GA.DUPLICATE_ENTITY;
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		WHEN OTHERS THEN
			RAISE;

END PUT_ESP_POOL;
----------------------------------------------------------------------------------------------------
PROCEDURE POOL_SUB_POOLS
	(
	p_POOL_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

-- Answer the Sub-Pools FOR THE GIVEN POOL

BEGIN
	IF NOT Can_Read(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
    p_STATUS := GA.SUCCESS;

	 OPEN p_CURSOR FOR
	   SELECT SUB_POOL_ID, ALLOCATION_PCT, BEGIN_DATE, END_DATE, ENTRY_DATE, POOL_ID
		FROM POOL_SUB_POOL
		WHERE POOL_ID = p_POOL_ID
		ORDER BY 3;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;
END POOL_SUB_POOLS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_POOL_SUB_POOL
	(
	p_POOL_ID IN NUMBER,
	p_SUB_POOL_ID IN NUMBER,
	p_ALLOCATION_PCT IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_SUB_POOL_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	P_STATUS OUT NUMBER
	)
	AS

CURSOR c_SUB_POOL IS
	SELECT *
	FROM POOL_SUB_POOL
	WHERE POOL_ID = p_POOL_ID
	ORDER BY BEGIN_DATE DESC;

v_SUB_POOL POOL_SUB_POOL%ROWTYPE;
v_END_DATE DATE;
v_INITIAL BOOLEAN;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- UPDATE THE CURRENT SUB-POOL ASSIGNMENT IF ONE EXISTS

	UPDATE POOL_SUB_POOL SET
		ALLOCATION_PCT = p_ALLOCATION_PCT,
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		ENTRY_DATE = SYSDATE,
		SUB_POOL_ID = p_SUB_POOL_ID
	WHERE POOL_ID = p_POOL_ID
		AND SUB_POOL_ID = p_OLD_SUB_POOL_ID
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS SUB-POOL COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO POOL_SUB_POOL
			(
			POOL_ID,
			SUB_POOL_ID,
			ALLOCATION_PCT,
			BEGIN_DATE,
			END_DATE,
			ENTRY_DATE
			)
		VALUES
			(
			p_POOL_ID,
			p_SUB_POOL_ID,
			p_ALLOCATION_PCT,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			SYSDATE
			);
	END IF;

	OPEN c_SUB_POOL;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_SUB_POOL INTO v_SUB_POOL;
		EXIT WHEN c_SUB_POOL%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_SUB_POOL.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE POOL_SUB_POOL
		SET END_DATE = GREATEST(v_END_DATE, v_SUB_POOL.BEGIN_DATE)
		WHERE POOL_ID = v_SUB_POOL.POOL_ID
			AND SUB_POOL_ID = v_SUB_POOL.SUB_POOL_ID
			AND BEGIN_DATE = v_SUB_POOL.BEGIN_DATE;
		v_END_DATE := v_SUB_POOL.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_SUB_POOL;

	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			p_STATUS := GA.DUPLICATE_ENTITY;
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		WHEN OTHERS THEN
			RAISE;

END PUT_POOL_SUB_POOL;
----------------------------------------------------------------------------------------------------
PROCEDURE EDC_RATE_CLASSS
	(
	p_EDC_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

-- Answer the ESPS FOR THE GIVEN POOL

BEGIN
	IF NOT Can_Read(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
    p_STATUS := GA.SUCCESS;

	 OPEN p_CURSOR FOR
	    SELECT A.RATE_CLASS, A.EDC_ID
		FROM EDC_RATE_CLASS A
		WHERE EDC_ID = p_EDC_ID
		ORDER BY 1;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;
END EDC_RATE_CLASSS;
---------------------------------------------------------------------------------------------------

PROCEDURE PUT_EDC_RATE_CLASS
	(
	p_EDC_ID IN NUMBER,
	p_RATE_CLASS IN VARCHAR,
	p_OLD_RATE_CLASS IN VARCHAR,
	p_STATUS OUT NUMBER
	)
	AS

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

-- UPDATE THE CURRENT ASSIGNMENT IF ONE EXISTS

	UPDATE EDC_RATE_CLASS SET
		RATE_CLASS = LTRIM(RTRIM(NVL(p_RATE_CLASS,GA.UNDEFINED_ATTRIBUTE)))
	WHERE EDC_ID = p_EDC_ID
		AND LTRIM(RTRIM(UPPER(RATE_CLASS))) = LTRIM(RTRIM(UPPER(p_OLD_RATE_CLASS)));

-- NO ASSIGNMENT UPDATE FOR THIS COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO EDC_RATE_CLASS
			(
			EDC_ID,
			RATE_CLASS
			)
		VALUES
			(
			p_EDC_ID,
			LTRIM(RTRIM(NVL(p_RATE_CLASS,GA.UNDEFINED_ATTRIBUTE)))
			);
	END IF;

	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			p_STATUS := GA.DUPLICATE_ENTITY;
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		WHEN OTHERS THEN
			RAISE;

END PUT_EDC_RATE_CLASS;
---------------------------------------------------------------------------------------------------
PROCEDURE EDC_LOSS_FACTORS
	(
	p_EDC_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

-- Answer the CASE LABELS for the given CATEGORY

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	   SELECT A.CASE_ID, A.BEGIN_DATE, A.END_DATE, A.LOSS_FACTOR_ID, A.ENTRY_DATE, A.EDC_ID
		FROM EDC_LOSS_FACTOR A
		WHERE A.EDC_ID = p_EDC_ID
		ORDER BY 2;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END EDC_LOSS_FACTORS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_EDC_LOSS_FACTOR
	(
	p_EDC_ID IN NUMBER,
	p_CASE_ID IN NUMBER,
	p_LOSS_FACTOR_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_CASE_ID IN NUMBER,
	p_OLD_LOSS_FACTOR_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	)
	AS

CURSOR c_EDC_LOSS_FACTOR IS
	SELECT *
	FROM EDC_LOSS_FACTOR
	WHERE EDC_ID = p_EDC_ID
		AND CASE_ID = p_CASE_ID
	ORDER BY BEGIN_DATE DESC;

v_EDC_LOSS_FACTOR EDC_LOSS_FACTOR%ROWTYPE;
v_END_DATE DATE;
v_INITIAL BOOLEAN;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- UPDATE THE CURRENT EDC LOSS_FACTOR ASSIGNMENT IF ONE EXISTS

	UPDATE EDC_LOSS_FACTOR SET
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		LOSS_FACTOR_ID = p_LOSS_FACTOR_ID,
		CASE_ID = p_CASE_ID,
		ENTRY_DATE = SYSDATE
	WHERE EDC_ID = p_EDC_ID
		AND CASE_ID = p_OLD_CASE_ID
		AND LOSS_FACTOR_ID = p_OLD_LOSS_FACTOR_ID
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS EDC AND LOSS_FACTOR COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO EDC_LOSS_FACTOR
			(
			CASE_ID,
			EDC_ID,
			LOSS_FACTOR_ID,
			BEGIN_DATE,
			END_DATE,
			ENTRY_DATE
			)
		VALUES
			(
			p_CASE_ID,
			p_EDC_ID,
			p_LOSS_FACTOR_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			SYSDATE
			);
	END IF;

	OPEN c_EDC_LOSS_FACTOR;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_EDC_LOSS_FACTOR INTO v_EDC_LOSS_FACTOR;
		EXIT WHEN c_EDC_LOSS_FACTOR%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_EDC_LOSS_FACTOR.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE EDC_LOSS_FACTOR
		SET END_DATE = GREATEST(v_END_DATE, v_EDC_LOSS_FACTOR.BEGIN_DATE)
		WHERE EDC_ID = v_EDC_LOSS_FACTOR.EDC_ID
			AND CASE_ID = v_EDC_LOSS_FACTOR.CASE_ID
			AND LOSS_FACTOR_ID = v_EDC_LOSS_FACTOR.LOSS_FACTOR_ID
			AND BEGIN_DATE = v_EDC_LOSS_FACTOR.BEGIN_DATE;
		v_END_DATE := v_EDC_LOSS_FACTOR.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_EDC_LOSS_FACTOR;

	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			p_STATUS := GA.DUPLICATE_ENTITY;
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		WHEN OTHERS THEN
			RAISE;

END PUT_EDC_LOSS_FACTOR;

---------------------------------------------------------------------------------------------------
PROCEDURE SYSTEM_LOAD_AREAS
	(
	p_SYSTEM_LOAD_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

-- Answer the SYSTEM_LOAD_AREA's for the given SYSTEM_LOAD.

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    p_STATUS := GA.SUCCESS;
	OPEN p_CURSOR FOR
	    SELECT A.SYSTEM_LOAD_ID,
			A.AREA_ID,
			A.OPERATION_CODE
		FROM SYSTEM_LOAD_AREA A
		WHERE A.SYSTEM_LOAD_ID = p_SYSTEM_LOAD_ID;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END SYSTEM_LOAD_AREAS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_SYSTEM_LOAD_AREA
	(
	p_SYSTEM_LOAD_ID IN NUMBER,
	p_AREA_ID IN NUMBER,
	p_OPERATION_CODE IN CHAR,
	p_OLD_AREA_ID IN NUMBER,
	p_STATUS OUT NUMBER
	)
	AS

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

-- UPDATE THE CURRENT ASSIGNMENT IF ONE EXISTS

	UPDATE SYSTEM_LOAD_AREA SET
		AREA_ID = p_AREA_ID,
		OPERATION_CODE = NVL(p_OPERATION_CODE,GA.UNDEFINED_ATTRIBUTE)
	WHERE SYSTEM_LOAD_ID = p_SYSTEM_LOAD_ID
		AND AREA_ID = p_OLD_AREA_ID;

-- NO ASSIGNMENT UPDATE FOR THIS  COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO SYSTEM_LOAD_AREA
			(
			SYSTEM_LOAD_ID,
			AREA_ID,
			OPERATION_CODE
			)
		VALUES
			(
			p_SYSTEM_LOAD_ID,
			p_AREA_ID,
			NVL(p_OPERATION_CODE,GA.UNDEFINED_ATTRIBUTE)
			);
	END IF;


	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			p_STATUS := GA.DUPLICATE_ENTITY;
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		WHEN OTHERS THEN
			RAISE;

END PUT_SYSTEM_LOAD_AREA;
----------------------------------------------------------------------------------------------------
PROCEDURE EDC_CONVERSION_FACTORS
	(
	p_EDC_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

-- Answer the CONTRACTs for the given EDC.

BEGIN
	IF NOT Can_Read(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
    p_STATUS := GA.SUCCESS;

	 OPEN p_CURSOR FOR
	    SELECT A.SERVICE_AREA_ID,
			A.FACTOR_CODE,
			A.BEGIN_DATE,
			A.END_DATE,
			A.FACTOR_VAL,
			A.ENTRY_DATE
		FROM EDC_CONVERSION_FACTOR A
		WHERE	A.EDC_ID = p_EDC_ID
		ORDER BY 4 DESC, 2 ASC;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;
END EDC_CONVERSION_FACTORS;
---------------------------------------------------------------------------------------------------

PROCEDURE PUT_EDC_CONVERSION_FACTOR
	(
	p_EDC_ID IN NUMBER,
	p_SERVICE_AREA_ID IN NUMBER,
	p_FACTOR_CODE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_FACTOR_VAL IN NUMBER,
	p_OLD_SERVICE_AREA_ID IN NUMBER,
	p_OLD_FACTOR_CODE IN CHAR,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	)
	AS

-- CURSOR c_EDC_CONVERSION_FACTOR IS
-- 	SELECT *
-- 	FROM EDC_CONVERSION_FACTOR
-- 	WHERE EDC_ID = p_EDC_ID
-- 			AND SERVICE_AREA_ID = p_SERVICE_AREA_ID
-- 	ORDER BY BEGIN_DATE DESC;
--
-- v_EDC_CONVERSION_FACTOR EDC_CONVERSION_FACTOR%ROWTYPE;
v_END_DATE DATE;
v_INITIAL BOOLEAN;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- UPDATE THE CURRENT EDC_CONVERSION_FACTOR ASSIGNMENT IF ONE EXISTS

	UPDATE EDC_CONVERSION_FACTOR SET
		SERVICE_AREA_ID = p_SERVICE_AREA_ID,
		FACTOR_CODE = p_FACTOR_CODE,
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		FACTOR_VAL = p_FACTOR_VAL,
		ENTRY_DATE = SYSDATE
	WHERE EDC_ID = p_EDC_ID
		AND SERVICE_AREA_ID = p_OLD_SERVICE_AREA_ID
		AND FACTOR_CODE = p_OLD_FACTOR_CODE
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS EDC AND CONVERSION_FACTOR COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO EDC_CONVERSION_FACTOR
			(
			EDC_ID,
			SERVICE_AREA_ID,
			FACTOR_CODE,
			BEGIN_DATE,
			END_DATE,
			FACTOR_VAL,
			ENTRY_DATE
			)
		VALUES
			(
			p_EDC_ID,
			p_SERVICE_AREA_ID,
			p_FACTOR_CODE,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			NVL(p_FACTOR_VAL,0),
			SYSDATE
			);
	END IF;

-- 	OPEN c_EDC_CONVERSION_FACTOR;
-- 	v_INITIAL := TRUE;
-- 	LOOP
-- 		FETCH c_EDC_CONVERSION_FACTOR INTO v_EDC_CONVERSION_FACTOR;
-- 		EXIT WHEN c_EDC_CONVERSION_FACTOR%NOTFOUND;
-- 		IF v_INITIAL THEN
-- 			v_END_DATE := v_EDC_CONVERSION_FACTOR.END_DATE;
-- 			v_INITIAL := FALSE;
-- 		END IF;
-- 		UPDATE EDC_CONVERSION_FACTOR
-- 		SET END_DATE = GREATEST(v_END_DATE, v_EDC_CONVERSION_FACTOR.BEGIN_DATE)
-- 		WHERE EDC_ID = v_EDC_CONVERSION_FACTOR.EDC_ID
-- 			AND SERVICE_AREA_ID = v_EDC_CONVERSION_FACTOR.SERVICE_AREA_ID
--				AND FACTOR_CODE = v_EDC_CONVERSION_FACTOR.FACTOR_CODE
-- 			AND BEGIN_DATE = v_EDC_CONVERSION_FACTOR.BEGIN_DATE;
-- 		v_END_DATE := v_EDC_CONVERSION_FACTOR.BEGIN_DATE - 1;
-- 	END LOOP;
-- 	CLOSE c_EDC_CONVERSION_FACTOR;

	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			p_STATUS := GA.DUPLICATE_ENTITY;
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		WHEN OTHERS THEN
			RAISE;

END PUT_EDC_CONVERSION_FACTOR;
---------------------------------------------------------------------------------------------------
PROCEDURE PIPELINE_SEGMENT_FUELS
	(
	p_PIPELINE_SEGMENT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

BEGIN
	IF NOT Can_Read(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
    p_STATUS := GA.SUCCESS;

	 OPEN p_CURSOR FOR
	 	SELECT BEGIN_DATE, END_DATE, FUEL_PCT, ENTRY_DATE, PIPELINE_SEGMENT_ID
		FROM PIPELINE_SEGMENT_FUEL
		WHERE	PIPELINE_SEGMENT_ID = p_PIPELINE_SEGMENT_ID
		ORDER BY 1;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;
END PIPELINE_SEGMENT_FUELS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_PIPELINE_SEGMENT_FUEL
	(
	p_PIPELINE_SEGMENT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_FUEL_PCT IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	)
	AS

-- CURSOR c_EDC_CONVERSION_FACTOR IS
-- 	SELECT *
-- 	FROM EDC_CONVERSION_FACTOR
-- 	WHERE EDC_ID = p_EDC_ID
-- 			AND SERVICE_AREA_ID = p_SERVICE_AREA_ID
-- 	ORDER BY BEGIN_DATE DESC;
--
-- v_EDC_CONVERSION_FACTOR EDC_CONVERSION_FACTOR%ROWTYPE;
v_END_DATE DATE;
v_INITIAL BOOLEAN;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- UPDATE THE CURRENT SEGMENT_FUEL ASSIGNMENT IF ONE EXISTS

	UPDATE PIPELINE_SEGMENT_FUEL SET
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		FUEL_PCT = NVL(p_FUEL_PCT,0),
		ENTRY_DATE = SYSDATE
	WHERE PIPELINE_SEGMENT_ID = p_PIPELINE_SEGMENT_ID
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO PIPELINE_SEGMENT_FUEL
			(
			PIPELINE_SEGMENT_ID,
			BEGIN_DATE,
			END_DATE,
			FUEL_PCT,
			ENTRY_DATE
			)
		VALUES
			(
			p_PIPELINE_SEGMENT_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			NVL(p_FUEL_PCT,0),
			SYSDATE
			);
	END IF;

-- 	OPEN c_EDC_CONVERSION_FACTOR;
-- 	v_INITIAL := TRUE;
-- 	LOOP
-- 		FETCH c_EDC_CONVERSION_FACTOR INTO v_EDC_CONVERSION_FACTOR;
-- 		EXIT WHEN c_EDC_CONVERSION_FACTOR%NOTFOUND;
-- 		IF v_INITIAL THEN
-- 			v_END_DATE := v_EDC_CONVERSION_FACTOR.END_DATE;
-- 			v_INITIAL := FALSE;
-- 		END IF;
-- 		UPDATE EDC_CONVERSION_FACTOR
-- 		SET END_DATE = GREATEST(v_END_DATE, v_EDC_CONVERSION_FACTOR.BEGIN_DATE)
-- 		WHERE EDC_ID = v_EDC_CONVERSION_FACTOR.EDC_ID
-- 			AND SERVICE_AREA_ID = v_EDC_CONVERSION_FACTOR.SERVICE_AREA_ID
--				AND FACTOR_CODE = v_EDC_CONVERSION_FACTOR.FACTOR_CODE
-- 			AND BEGIN_DATE = v_EDC_CONVERSION_FACTOR.BEGIN_DATE;
-- 		v_END_DATE := v_EDC_CONVERSION_FACTOR.BEGIN_DATE - 1;
-- 	END LOOP;
-- 	CLOSE c_EDC_CONVERSION_FACTOR;

	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			p_STATUS := GA.DUPLICATE_ENTITY;
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		WHEN OTHERS THEN
			RAISE;

END PUT_PIPELINE_SEGMENT_FUEL;
---------------------------------------------------------------------------------------------------
PROCEDURE TRANSPORTATION_LEGS
	(
	p_TRANSPORTATION_PATH_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

BEGIN
	IF NOT Can_Read(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
    p_STATUS := GA.SUCCESS;

	 OPEN p_CURSOR FOR
	 	SELECT A.PIPELINE_SEGMENT_ID, A.LEG_ORDER, A.ENTRY_DATE, A.TRANSPORTATION_PATH_ID
		FROM TRANSPORTATION_LEG A
		WHERE	A.TRANSPORTATION_PATH_ID = p_TRANSPORTATION_PATH_ID;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;
END TRANSPORTATION_LEGS;
---------------------------------------------------------------------------------------------------

PROCEDURE PUT_TRANSPORTATION_LEG
	(
	p_TRANSPORTATION_PATH_ID IN NUMBER,
	p_PIPELINE_SEGMENT_ID IN NUMBER,
	p_LEG_ORDER IN NUMBER,
	p_OLD_LEG_ORDER IN NUMBER,
	p_STATUS OUT NUMBER
	)
	AS

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

-- UPDATE THE CURRENT TRANSPORTATION_LEG ASSIGNMENT IF ONE EXISTS

	UPDATE TRANSPORTATION_LEG SET
		PIPELINE_SEGMENT_ID = p_PIPELINE_SEGMENT_ID,
		LEG_ORDER = NVL(p_LEG_ORDER,0),
		ENTRY_DATE = SYSDATE
	WHERE TRANSPORTATION_PATH_ID = p_TRANSPORTATION_PATH_ID
		AND LEG_ORDER = p_OLD_LEG_ORDER;

-- NO ASSIGNMENT UPDATE FOR THIS COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO TRANSPORTATION_LEG
			(
			TRANSPORTATION_PATH_ID,
			PIPELINE_SEGMENT_ID,
			LEG_ORDER,
			ENTRY_DATE
			)
		VALUES
			(
			p_TRANSPORTATION_PATH_ID,
			p_PIPELINE_SEGMENT_ID,
			NVL(p_LEG_ORDER,0),
			SYSDATE
			);
	END IF;

	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			p_STATUS := GA.DUPLICATE_ENTITY;
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		WHEN OTHERS THEN
			RAISE;

END PUT_TRANSPORTATION_LEG;
---------------------------------------------------------------------------------------------------

PROCEDURE SERVICE_POINT_CITY_GATES
	(
	p_SERVICE_POINT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS


BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

   OPEN p_CURSOR FOR
		SELECT A.BEGIN_DATE,
			 A.END_DATE,
			 A.ALLOCATION_PCT,
			 A.CITY_GATE_ID,
			 A.ENTRY_DATE,
			 A.SERVICE_POINT_ID
		FROM SERVICE_POINT_CITY_GATE A
		WHERE A.SERVICE_POINT_ID = p_SERVICE_POINT_ID
		ORDER BY 1;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END SERVICE_POINT_CITY_GATES;
---------------------------------------------------------------------------------------------------

PROCEDURE PUT_SERVICE_POINT_CITY_GATE
	(
	p_SERVICE_POINT_ID IN NUMBER,
	p_CITY_GATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ALLOCATION_PCT IN NUMBER,
	p_OLD_CITY_GATE_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	P_STATUS OUT NUMBER
	)
	AS

CURSOR c_SERVICE_POINT_CITY_GATE IS
	SELECT *
	FROM SERVICE_POINT_CITY_GATE
	WHERE SERVICE_POINT_ID = p_SERVICE_POINT_ID
	ORDER BY BEGIN_DATE DESC;

v_SERVICE_POINT_CITY_GATE SERVICE_POINT_CITY_GATE%ROWTYPE;
v_END_DATE DATE;
v_INITIAL BOOLEAN;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- UPDATE THE CURRENT CITY_GATE SC ASSIGNMENT IF ONE EXISTS

	UPDATE SERVICE_POINT_CITY_GATE SET
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		ALLOCATION_PCT = NVL(p_ALLOCATION_PCT,0),
		ENTRY_DATE = SYSDATE,
		CITY_GATE_ID = p_CITY_GATE_ID
	WHERE SERVICE_POINT_ID = p_SERVICE_POINT_ID
		AND CITY_GATE_ID = p_OLD_CITY_GATE_ID
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS CITY_GATE SC COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO SERVICE_POINT_CITY_GATE
			(
			SERVICE_POINT_ID,
			CITY_GATE_ID,
			BEGIN_DATE,
			END_DATE,
			ALLOCATION_PCT,
			ENTRY_DATE
			)
		VALUES
			(
			p_SERVICE_POINT_ID,
			p_CITY_GATE_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			NVL(p_ALLOCATION_PCT,0),
			SYSDATE
			);
	END IF;

	OPEN c_SERVICE_POINT_CITY_GATE;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_SERVICE_POINT_CITY_GATE INTO v_SERVICE_POINT_CITY_GATE;
		EXIT WHEN c_SERVICE_POINT_CITY_GATE%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_SERVICE_POINT_CITY_GATE.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE SERVICE_POINT_CITY_GATE
		SET END_DATE = GREATEST(v_END_DATE, v_SERVICE_POINT_CITY_GATE.BEGIN_DATE)
		WHERE SERVICE_POINT_ID = v_SERVICE_POINT_CITY_GATE.SERVICE_POINT_ID
			AND CITY_GATE_ID = v_SERVICE_POINT_CITY_GATE.CITY_GATE_ID
			AND BEGIN_DATE = v_SERVICE_POINT_CITY_GATE.BEGIN_DATE;
		v_END_DATE := v_SERVICE_POINT_CITY_GATE.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_SERVICE_POINT_CITY_GATE;

	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			p_STATUS := GA.DUPLICATE_ENTITY;
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		WHEN OTHERS THEN
			RAISE;

END PUT_SERVICE_POINT_CITY_GATE;

----------------------------------------------------------------------------------------------------

PROCEDURE STATION_PARAMETERS
	(
	p_STATION_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

-- Answer the WEATHER_STATION_PARAMETERS's for the given STATION.

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    p_STATUS := GA.SUCCESS;
	OPEN p_CURSOR FOR
	    SELECT A.PARAMETER_ID,
	    	B.PARAMETER_NAME,
	    	1 "IS_SELECTED",
			A.STATION_ID
		FROM WEATHER_STATION_PARAMETER A, WEATHER_PARAMETER B
		WHERE A.STATION_ID = p_STATION_ID
			AND A.PARAMETER_ID = B.PARAMETER_ID
			AND A.PARAMETER_ID > 0

		UNION

		SELECT PARAMETER_ID,
			PARAMETER_NAME,
			0 "IS_SELECTED",
			p_STATION_ID "STATION_ID"
		FROM WEATHER_PARAMETER
		WHERE NOT PARAMETER_ID IN (SELECT PARAMETER_ID
									FROM WEATHER_STATION_PARAMETER
									WHERE STATION_ID = p_STATION_ID)
			AND PARAMETER_ID > 0

		ORDER BY 3 DESC, 2 ASC;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END STATION_PARAMETERS;
---------------------------------------------------------------------------------------------------


PROCEDURE PUT_STATION_PARAMETER
	(
	p_STATION_ID IN NUMBER,
	p_PARAMETER_ID IN NUMBER,
	p_IS_SELECTED IN NUMBER,
	p_STATUS OUT NUMBER
	)
	AS

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	--DELETE THE CURRENT ASSIGNMENT IF NOT SELECTED.
	IF p_IS_SELECTED = 0 THEN
		DELETE FROM WEATHER_STATION_PARAMETER
		WHERE STATION_ID = p_STATION_ID
			AND PARAMETER_ID = p_PARAMETER_ID;
	ELSE
	-- UPDATE THE CURRENT ACCOUNT ANCILLARY_SERVICE ASSIGNMENT IF ONE EXISTS

		UPDATE WEATHER_STATION_PARAMETER SET
			PARAMETER_ID = p_PARAMETER_ID
		WHERE STATION_ID = p_STATION_ID
			AND PARAMETER_ID = p_PARAMETER_ID;

	-- NO ASSIGNMENT UPDATE FOR THIS ACCOUNT AND ANCILLARY_SERVICE COMBINATION SO INSERT A NEW ASSIGNMENT

		IF SQL%NOTFOUND THEN
			INSERT INTO WEATHER_STATION_PARAMETER
				(
				STATION_ID,
				PARAMETER_ID
				)
			VALUES
				(
				p_STATION_ID,
				p_PARAMETER_ID
				);
		END IF;
	END IF;

	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			p_STATUS := GA.DUPLICATE_ENTITY;
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		WHEN OTHERS THEN
			RAISE;
END PUT_STATION_PARAMETER;
---------------------------------------------------------------------------------------------------

PROCEDURE STATION_COMPOSITES
	(
	p_STATION_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	)  AS

-- Answer the WEATHER_STATION_COMPOSITE's for the given STATION.

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    p_STATUS := GA.SUCCESS;
	OPEN p_CURSOR FOR
	    SELECT A.COMPOSITE_STATION_ID,
	    	B.STATION_NAME "COMPOSITE_STATION_NAME",
	    	A.COMPOSITE_PERCENT,
	    	1 "IS_SELECTED",
			A.STATION_ID
		FROM WEATHER_STATION_COMPOSITE A, WEATHER_STATION B
		WHERE A.STATION_ID = p_STATION_ID
			AND A.COMPOSITE_STATION_ID = B.STATION_ID
			AND A.STATION_ID > 0

		UNION

		SELECT STATION_ID "COMPOSITE_STATION_ID",
			STATION_NAME "COMPOSITE_STATION_NAME",
			0 "COMPOSITE_PERCENT",
			0 "IS_SELECTED",
			p_STATION_ID "STATION_ID"
		FROM WEATHER_STATION
		WHERE IS_COMPOSITE = 0
			AND NOT STATION_ID IN (SELECT COMPOSITE_STATION_ID
									FROM WEATHER_STATION_COMPOSITE
									WHERE STATION_ID = p_STATION_ID)
			AND NOT STATION_ID = p_STATION_ID
			AND STATION_ID > 0

		ORDER BY 4 DESC, 2 ASC;


	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END STATION_COMPOSITES;
---------------------------------------------------------------------------------------------------

PROCEDURE PUT_STATION_COMPOSITE
	(
	p_STATION_ID IN NUMBER,
	p_COMPOSITE_STATION_ID IN NUMBER,
	p_COMPOSITE_PERCENT IN NUMBER,
	p_IS_SELECTED IN NUMBER,
	p_STATUS OUT NUMBER
	)
	AS

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

-- IF THIS ASSIGNMENT IS NOT SELECTED, DELETE IT.
	IF p_IS_SELECTED = 0 THEN
		DELETE FROM WEATHER_STATION_COMPOSITE
		WHERE STATION_ID = p_STATION_ID
			AND COMPOSITE_STATION_ID = p_COMPOSITE_STATION_ID;
	ELSE


	-- UPDATE THE CURRENT ASSIGNMENT IF ONE EXISTS

		UPDATE WEATHER_STATION_COMPOSITE SET
			COMPOSITE_PERCENT = p_COMPOSITE_PERCENT
		WHERE STATION_ID = p_STATION_ID
			AND COMPOSITE_STATION_ID = p_COMPOSITE_STATION_ID;

	-- NO ASSIGNMENT UPDATE FOR THIS ACCOUNT AND ANCILLARY_SERVICE COMBINATION SO INSERT A NEW ASSIGNMENT

		IF SQL%NOTFOUND THEN
			INSERT INTO WEATHER_STATION_COMPOSITE
				(
				STATION_ID,
				COMPOSITE_STATION_ID,
				COMPOSITE_PERCENT
				)
			VALUES
				(
				p_STATION_ID,
				p_COMPOSITE_STATION_ID,
				p_COMPOSITE_PERCENT
				);
		END IF;

	END IF;

	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			p_STATUS := GA.DUPLICATE_ENTITY;
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		WHEN OTHERS THEN
			RAISE;

END PUT_STATION_COMPOSITE;
---------------------------------------------------------------------------------------------------
PROCEDURE PARAMETER_COMPOSITES
	(
	p_PARAMETER_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	)  AS

-- Answer the WEATHER_PARAMETER_COMPOSITE's for the given PARAMETER.

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    p_STATUS := GA.SUCCESS;
	OPEN p_CURSOR FOR
	    SELECT A.COMPOSITE_PARAMETER_ID,
	    	B.PARAMETER_NAME "COMPOSITE_PARAMETER_NAME",
	    	A.COMPOSITE_COEFFICIENT,
	    	1 "IS_SELECTED",
			A.PARAMETER_ID
		FROM WEATHER_PARAMETER_COMPOSITE A, WEATHER_PARAMETER B
		WHERE A.PARAMETER_ID = p_PARAMETER_ID
			AND A.COMPOSITE_PARAMETER_ID = B.PARAMETER_ID
			AND A.PARAMETER_ID > 0

		UNION

		SELECT PARAMETER_ID "COMPOSITE_PARAMETER_ID",
			PARAMETER_NAME "COMPOSITE_PARAMETER_NAME",
			0 "COMPOSITE_COEFFICIENT",
			0 "IS_SELECTED",
			p_PARAMETER_ID "PARAMETER_ID"
		FROM WEATHER_PARAMETER
		WHERE IS_COMPOSITE = 0
			AND NOT PARAMETER_ID IN (SELECT COMPOSITE_PARAMETER_ID
									FROM WEATHER_PARAMETER_COMPOSITE
									WHERE PARAMETER_ID = p_PARAMETER_ID)
			AND NOT PARAMETER_ID = p_PARAMETER_ID
			AND PARAMETER_ID > 0

		ORDER BY 4 DESC, 2 ASC;


	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END PARAMETER_COMPOSITES;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_PARAMETER_COMPOSITE
	(
	p_PARAMETER_ID IN NUMBER,
	p_COMPOSITE_PARAMETER_ID IN NUMBER,
	p_COMPOSITE_COEFFICIENT IN NUMBER,
	p_IS_SELECTED IN NUMBER,
	p_STATUS OUT NUMBER
	)
	AS

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	--DELETE THE EXISTING ASSIGNMENT IF NOT SELECTED.
	IF p_IS_SELECTED = 0 THEN
		DELETE FROM WEATHER_PARAMETER_COMPOSITE
		WHERE PARAMETER_ID = p_PARAMETER_ID
			AND COMPOSITE_PARAMETER_ID = p_COMPOSITE_PARAMETER_ID;

	ELSE
	-- UPDATE THE CURRENT ASSIGNMENT IF ONE EXISTS

		UPDATE WEATHER_PARAMETER_COMPOSITE SET
			COMPOSITE_COEFFICIENT = p_COMPOSITE_COEFFICIENT
		WHERE PARAMETER_ID = p_PARAMETER_ID
			AND COMPOSITE_PARAMETER_ID = p_COMPOSITE_PARAMETER_ID;

	-- NO ASSIGNMENT UPDATE FOR THIS ACCOUNT AND ANCILLARY_SERVICE COMBINATION SO INSERT A NEW ASSIGNMENT

		IF SQL%NOTFOUND THEN
			INSERT INTO WEATHER_PARAMETER_COMPOSITE
				(
				PARAMETER_ID,
				COMPOSITE_PARAMETER_ID,
				COMPOSITE_COEFFICIENT
				)
			VALUES
				(
				p_PARAMETER_ID,
				p_COMPOSITE_PARAMETER_ID,
				p_COMPOSITE_COEFFICIENT
				);
		END IF;
	END IF;

	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			p_STATUS := GA.DUPLICATE_ENTITY;
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		WHEN OTHERS THEN
			RAISE;

END PUT_PARAMETER_COMPOSITE;
----------------------------------------------------------------------------------------------------
PROCEDURE PATH_PROVIDERS
	(
   p_PATH_ID IN NUMBER,
   p_STATUS OUT NUMBER,
   p_CURSOR IN OUT REF_CURSOR
   ) AS
-- ANSWER A RECORDSET CONTAINING THE LEGS FOR THE GIVEN PATH ID
BEGIN

	IF NOT CAN_READ('Scheduling') THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

        p_STATUS := GA.SUCCESS;

        OPEN p_CURSOR FOR
                SELECT PATH_ID,
					 	LEG_NBR,
						CA_ID,
						TP_ID,
						PSE_ID,
						TP_PRODUCT_CODE,
						TP_PATH_NAME,
						TP_ASSIGNMENT_REF,
						TP_PRODUCT_LEVEL,
						MISC_INFO,
						MISC_REF,
						ENTRY_DATE
                FROM PATH_PROVIDER
                WHERE PATH_ID = p_PATH_ID
                ORDER BY LEG_NBR;

        EXCEPTION
                WHEN INSUFFICIENT_PRIVILEGES THEN
                        p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
                WHEN OTHERS THEN
                        p_STATUS := SQLCODE;
END PATH_PROVIDERS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_PATH_PROVIDER
	(
   p_PATH_ID IN NUMBER,
   p_LEG_NBR IN NUMBER,
   p_CA_ID IN NUMBER,
   p_TP_ID IN NUMBER,
   p_PSE_ID IN NUMBER,
   p_TP_PRODUCT_CODE IN VARCHAR2,
   p_TP_PATH_NAME IN VARCHAR2,
   p_TP_ASSIGNMENT_REF IN VARCHAR2,
   p_TP_PRODUCT_LEVEL IN VARCHAR2,
   p_MISC_INFO IN VARCHAR2,
   p_MISC_REF IN VARCHAR2
	) AS
-- CREATE OR UPDATE A PROVIDER_PATH LEG FOR A TX_PATH
v_COUNT NUMBER;
BEGIN

	IF NOT CAN_WRITE('Scheduling') THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

        SELECT COUNT(*)
        INTO v_COUNT
        FROM PATH_PROVIDER
        WHERE PATH_ID = p_PATH_ID AND
              LEG_NBR = p_LEG_NBR;
-- UPDATE EXISTING RECORD
        IF v_COUNT > 0 THEN
                UPDATE PATH_PROVIDER SET
                        PATH_ID = p_PATH_ID,
                        LEG_NBR = p_LEG_NBR,
                        CA_ID = p_CA_ID,
                        TP_ID = p_TP_ID,
                        PSE_ID = p_PSE_ID,
                        TP_PRODUCT_CODE = p_TP_PRODUCT_CODE,
                        TP_PATH_NAME = p_TP_PATH_NAME,
                        TP_ASSIGNMENT_REF = p_TP_ASSIGNMENT_REF,
                        TP_PRODUCT_LEVEL = p_TP_PRODUCT_LEVEL,
                        MISC_INFO = p_MISC_INFO,
                        MISC_REF = p_MISC_REF,
                        ENTRY_DATE = SYSDATE
                WHERE PATH_ID = p_PATH_ID AND
                      LEG_NBR = p_LEG_NBR;
        ELSE
-- INSERT A NEW RECORD
                INSERT INTO PATH_PROVIDER (
                        PATH_ID,
                        LEG_NBR,
                        CA_ID,
                        TP_ID,
                        PSE_ID,
                        TP_PRODUCT_CODE,
                        TP_PATH_NAME,
                        TP_ASSIGNMENT_REF,
                        TP_PRODUCT_LEVEL,
                        MISC_INFO,
                        MISC_REF,
                        ENTRY_DATE)
                VALUES (p_PATH_ID,
                        p_LEG_NBR,
                        p_CA_ID,
                        p_TP_ID,
                        p_PSE_ID,
                        p_TP_PRODUCT_CODE,
                        p_TP_PATH_NAME,
                        p_TP_ASSIGNMENT_REF,
                        p_TP_PRODUCT_LEVEL,
                        p_MISC_INFO,
                        p_MISC_REF,
                        SYSDATE);
	END IF;
	EXCEPTION
		WHEN OTHERS THEN
			RAISE;
END PUT_PATH_PROVIDER;
----------------------------------------------------------------------------------------------------
PROCEDURE CUSTOMER_AGGREGATE_ACCOUNTS
	(
	p_CUSTOMER_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

BEGIN
	IF NOT CAN_READ('Data Setup') THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		  SELECT A.AGGREGATE_ID, B.ACCOUNT_ID, A.BEGIN_DATE, A.END_DATE, B.ESP_ID, B.POOL_ID, C.EDC_RATE_CLASS, C.EDC_STRATA, A.ENTRY_DATE
		  FROM AGGREGATE_ACCOUNT_CUSTOMER A, AGGREGATE_ACCOUNT_ESP B, ACCOUNT_EDC C
		  WHERE CUSTOMER_ID = p_CUSTOMER_ID
		  		AND B.AGGREGATE_ID = A.AGGREGATE_ID
				AND B.BEGIN_DATE <= NVL(A.END_DATE, HIGH_DATE)
				AND NVL(B.END_DATE, HIGH_DATE) >= A.BEGIN_DATE
				AND C.ACCOUNT_ID = B.ACCOUNT_ID
				AND C.BEGIN_DATE <= NVL(A.END_DATE, HIGH_DATE)
				AND NVL(C.END_DATE, HIGH_DATE) >= A.BEGIN_DATE
		  ORDER BY 3;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;
END CUSTOMER_AGGREGATE_ACCOUNTS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_CUSTOMER_AGGREGATE_ACCOUNT
	(
	p_CUSTOMER_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_AGGREGATE_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS
v_AGGREGATE_ID NUMBER(9);
v_END_DATE DATE := NULL_DATE(p_END_DATE);
v_COUNT NUMBER;
v_POOL_ID NUMBER(9) := NVL(p_POOL_ID, 0);
BEGIN

	IF NOT CAN_WRITE('Data Setup') THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

--DETERMINE IF THE AGGREGATE_ID EXISTS.
	SELECT COUNT(*)
		INTO v_COUNT
		FROM AGGREGATE_ACCOUNT_ESP
		WHERE ACCOUNT_ID = p_ACCOUNT_ID
			AND ESP_ID = p_ESP_ID
			AND POOL_ID = v_POOL_ID
			AND BEGIN_DATE <= NVL(v_END_DATE,HIGH_DATE)
			AND NVL(END_DATE,HIGH_DATE) >= p_BEGIN_DATE;

--CREATE IT IF IT DOESN'T.
	IF v_COUNT < 1 THEN
  		 RA.PUT_AGGREGATE_ACCOUNT_ESP(p_ACCOUNT_ID, p_ESP_ID, v_POOL_ID, p_BEGIN_DATE, p_END_DATE, p_ESP_ID, v_POOL_ID, p_BEGIN_DATE, p_STATUS);
	ELSIF v_COUNT > 1 THEN
		 RAISE INVALID_DATE_RANGE;
	END IF;

	SELECT AGGREGATE_ID
	INTO v_AGGREGATE_ID
	FROM AGGREGATE_ACCOUNT_ESP
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND ESP_ID = p_ESP_ID
		AND POOL_ID = v_POOL_ID
		AND BEGIN_DATE <= NVL(v_END_DATE,HIGH_DATE)
		AND NVL(END_DATE, HIGH_DATE) >= p_BEGIN_DATE;

-- UPDATE AN EXISTING RECORD
	UPDATE AGGREGATE_ACCOUNT_CUSTOMER SET
		AGGREGATE_ID = v_AGGREGATE_ID,
		BEGIN_DATE = p_BEGIN_DATE,
		END_DATE = v_END_DATE,
		ENTRY_DATE = SYSDATE
	WHERE CUSTOMER_ID = p_CUSTOMER_ID
		AND AGGREGATE_ID = p_OLD_AGGREGATE_ID
		AND BEGIN_DATE = p_OLD_BEGIN_DATE;

-- IF THE PREVIOUS UPDATE DID NOT FIND A MATCH, THEN INSERT A NEW RECORD.
	IF SQL%NOTFOUND THEN
		INSERT INTO AGGREGATE_ACCOUNT_CUSTOMER (
			AGGREGATE_ID,
			CUSTOMER_ID,
			BEGIN_DATE,
			END_DATE,
			ENTRY_DATE)
		VALUES (
			v_AGGREGATE_ID,
			p_CUSTOMER_ID,
			p_BEGIN_DATE,
			v_END_DATE,
			SYSDATE);
	END IF;

EXCEPTION
	WHEN INSUFFICIENT_PRIVILEGES THEN
		p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		RETURN;
	WHEN NO_DATA_FOUND THEN
		RAISE INVALID_AGGREGATE_ACCOUNT;
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;
		RAISE;

END PUT_CUSTOMER_AGGREGATE_ACCOUNT;
---------------------------------------------------------------------------------------------------
PROCEDURE CONTACT_PHONE_NUMBERS
	(
	p_CONTACT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

-- Answer the AREA_LOAD's for the given AREA.

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    p_STATUS := GA.SUCCESS;
	OPEN p_CURSOR FOR
	   SELECT PHONE_TYPE, PHONE_NUMBER, ENTRY_DATE
		FROM PHONE_NUMBER
		WHERE CONTACT_ID = p_CONTACT_ID
		ORDER BY 1,2;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END CONTACT_PHONE_NUMBERS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_CONTACT_PHONE_NUMBER
	(
	p_CONTACT_ID IN NUMBER,
	p_PHONE_TYPE IN VARCHAR,
	p_PHONE_NUMBER IN VARCHAR,
	p_OLD_PHONE_TYPE IN VARCHAR,
	p_STATUS OUT NUMBER
	)	AS

BEGIN
	p_STATUS := GA.SUCCESS;

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

-- UPDATE THE CURRENT ASSIGNMENT IF ONE EXISTS

	UPDATE PHONE_NUMBER SET
		PHONE_TYPE = p_PHONE_TYPE,
		PHONE_NUMBER = p_PHONE_NUMBER,
		ENTRY_DATE = SYSDATE
	WHERE CONTACT_ID = p_CONTACT_ID
		AND PHONE_TYPE = p_OLD_PHONE_TYPE;

-- NO ASSIGNMENT UPDATE FOR THIS  COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO PHONE_NUMBER
			(
			CONTACT_ID,
			PHONE_TYPE,
			PHONE_NUMBER,
			ENTRY_DATE
			)
		VALUES
			(
			p_CONTACT_ID,
			p_PHONE_TYPE,
			p_PHONE_NUMBER,
			SYSDATE
			);
	END IF;


	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			p_STATUS := GA.DUPLICATE_ENTITY;
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		WHEN OTHERS THEN
			RAISE;

END PUT_CONTACT_PHONE_NUMBER;
----------------------------------------------------------------------------------------------------
PROCEDURE CUSTOMER_PRODUCTS
	(
	p_CUSTOMER_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

BEGIN
	IF NOT CAN_READ('Data Setup') THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		 SELECT PRODUCT_ID, BEGIN_DATE, END_DATE, PRODUCT_TYPE, ENTRY_DATE
		 FROM CUSTOMER_PRODUCT
		 WHERE CUSTOMER_ID = p_CUSTOMER_ID
		 ORDER BY 1;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;
END CUSTOMER_PRODUCTS;
---------------------------------------------------------------------------------------------------

PROCEDURE PUT_CUSTOMER_PRODUCT
	(
	p_CUSTOMER_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_PRODUCT_TYPE IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_PRODUCT_ID IN NUMBER,
	p_OLD_PRODUCT_TYPE IN VARCHAR,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	IF NOT CAN_WRITE('Data Setup') THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

-- UPDATE AN EXISTING RECORD
	UPDATE CUSTOMER_PRODUCT SET
		PRODUCT_ID = p_PRODUCT_ID,
		PRODUCT_TYPE = p_PRODUCT_TYPE,
		BEGIN_DATE = p_BEGIN_DATE,
		END_DATE = p_END_DATE,
		ENTRY_DATE = SYSDATE
	WHERE CUSTOMER_ID = p_CUSTOMER_ID
		AND PRODUCT_ID = p_OLD_PRODUCT_ID
		AND PRODUCT_TYPE = p_OLD_PRODUCT_TYPE
		AND BEGIN_DATE = p_OLD_BEGIN_DATE;

-- IF THE PREVIOUS UPDATE DID NOT FIND A MATCH, THEN INSERT A NEW RECORD.
	IF SQL%NOTFOUND THEN
		INSERT INTO CUSTOMER_PRODUCT (
			CUSTOMER_ID,
			PRODUCT_ID,
			PRODUCT_TYPE,
			BEGIN_DATE,
			END_DATE,
			ENTRY_DATE)
		VALUES (
			p_CUSTOMER_ID,
			p_PRODUCT_ID,
			p_PRODUCT_TYPE,
			p_BEGIN_DATE,
			p_END_DATE,
			SYSDATE);
	END IF;

EXCEPTION
	WHEN INSUFFICIENT_PRIVILEGES THEN
		p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		RETURN;
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;
		RAISE;

END PUT_CUSTOMER_PRODUCT;
---------------------------------------------------------------------------------------------------

PROCEDURE CUSTOMER_ANCILLARY_SERVICES
	(
	p_CUSTOMER_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

BEGIN
	IF NOT CAN_READ('Data Setup') THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		 SELECT ANCILLARY_SERVICE_ID, BEGIN_DATE, END_DATE, SERVICE_VAL, ENTRY_DATE
		 FROM CUSTOMER_ANCILLARY_SERVICE
		 WHERE CUSTOMER_ID = p_CUSTOMER_ID
		 ORDER BY 2;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;
END CUSTOMER_ANCILLARY_SERVICES;
---------------------------------------------------------------------------------------------------

PROCEDURE PUT_CUSTOMER_ANCILLARY_SERVICE
	(
	p_CUSTOMER_ID IN NUMBER,
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SERVICE_VAL IN NUMBER,
	p_OLD_ANCILLARY_SERVICE_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	IF NOT CAN_WRITE('Data Setup') THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

-- UPDATE AN EXISTING RECORD
	UPDATE CUSTOMER_ANCILLARY_SERVICE SET
		ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID,
		BEGIN_DATE = p_BEGIN_DATE,
		END_DATE = p_END_DATE,
		SERVICE_VAL = p_SERVICE_VAL,
		ENTRY_DATE = SYSDATE
	WHERE CUSTOMER_ID = p_CUSTOMER_ID
		AND ANCILLARY_SERVICE_ID = p_OLD_ANCILLARY_SERVICE_ID
		AND BEGIN_DATE = p_OLD_BEGIN_DATE;

-- IF THE PREVIOUS UPDATE DID NOT FIND A MATCH, THEN INSERT A NEW RECORD.
	IF SQL%NOTFOUND THEN
		INSERT INTO CUSTOMER_ANCILLARY_SERVICE (
			CUSTOMER_ID,
			ANCILLARY_SERVICE_ID,
			BEGIN_DATE,
			END_DATE,
			SERVICE_VAL,
			ENTRY_DATE)
		VALUES (
			p_CUSTOMER_ID,
			p_ANCILLARY_SERVICE_ID,
			p_BEGIN_DATE,
			p_END_DATE,
			p_SERVICE_VAL,
			SYSDATE);
	END IF;

EXCEPTION
	WHEN INSUFFICIENT_PRIVILEGES THEN
		p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		RETURN;
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;
		RAISE;

END PUT_CUSTOMER_ANCILLARY_SERVICE;
---------------------------------------------------------------------------------------------------

PROCEDURE CUSTOMER_BILL_CYCLES
	(
	p_CUSTOMER_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

BEGIN
	IF NOT CAN_READ('Data Setup') THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		 SELECT BILL_CYCLE_ID, BILL_CYCLE_ENTITY, BEGIN_DATE, END_DATE, ENTRY_DATE
		 FROM CUSTOMER_BILL_CYCLE
		 WHERE CUSTOMER_ID = p_CUSTOMER_ID
		 ORDER BY 2;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;
END CUSTOMER_BILL_CYCLES;
---------------------------------------------------------------------------------------------------

PROCEDURE PUT_CUSTOMER_BILL_CYCLE
	(
	p_CUSTOMER_ID IN NUMBER,
	p_BILL_CYCLE_ID IN NUMBER,
	p_BILL_CYCLE_ENTITY IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_BILL_CYCLE_ID IN NUMBER,
	p_OLD_BILL_CYCLE_ENTITY IN VARCHAR,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	IF NOT CAN_WRITE('Data Setup') THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

-- UPDATE AN EXISTING RECORD
	UPDATE CUSTOMER_BILL_CYCLE SET
		BILL_CYCLE_ID = p_BILL_CYCLE_ID,
		BILL_CYCLE_ENTITY = p_BILL_CYCLE_ENTITY,
		BEGIN_DATE = p_BEGIN_DATE,
		END_DATE = p_END_DATE,
		ENTRY_DATE = SYSDATE
	WHERE CUSTOMER_ID = p_CUSTOMER_ID
		AND BILL_CYCLE_ID = p_OLD_BILL_CYCLE_ID
		AND BILL_CYCLE_ENTITY = p_OLD_BILL_CYCLE_ENTITY
		AND BEGIN_DATE = p_OLD_BEGIN_DATE;

-- IF THE PREVIOUS UPDATE DID NOT FIND A MATCH, THEN INSERT A NEW RECORD.
	IF SQL%NOTFOUND THEN
		INSERT INTO CUSTOMER_BILL_CYCLE (
			CUSTOMER_ID,
			BILL_CYCLE_ID,
			BILL_CYCLE_ENTITY,
			BEGIN_DATE,
			END_DATE,
			ENTRY_DATE)
		VALUES (
			p_CUSTOMER_ID,
			p_BILL_CYCLE_ID,
			p_BILL_CYCLE_ENTITY,
			p_BEGIN_DATE,
			p_END_DATE,
			SYSDATE);
	END IF;

EXCEPTION
	WHEN INSUFFICIENT_PRIVILEGES THEN
		p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		RETURN;
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;
		RAISE;

END PUT_CUSTOMER_BILL_CYCLE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_DOMAIN_KEYWORD_FROM_ID
	(
    p_DOMAIN_ID IN NUMBER,
    p_DOMAIN_KEYWORD OUT VARCHAR
    ) AS
v_NAME VARCHAR2(64);
BEGIN
	-- get the domain's "keyword" - i.e. the word that is used by the routines that auto-generate
    -- the EN and IO package to create EN.*_LIST, IO.PUT_*, and IO.GET_* routines.
	SELECT RTRIM(LTRIM(UPPER(NVL(B.ALIAS,B.TABLE_NAME))))
    INTO v_NAME
	FROM ENTITY_DOMAIN A, NERO_TABLE_PROPERTY_INDEX B
	WHERE A.ENTITY_DOMAIN_ID = p_DOMAIN_ID
		AND RTRIM(LTRIM(UPPER(A.ENTITY_DOMAIN_TABLE))) = RTRIM(LTRIM(UPPER(B.TABLE_NAME)));

	p_DOMAIN_KEYWORD := v_NAME;

EXCEPTION
	WHEN OTHERS THEN
    	p_DOMAIN_KEYWORD := NULL;
END GET_DOMAIN_KEYWORD_FROM_ID;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_DOMAIN_ALIAS_FROM_ID
	(
    p_DOMAIN_ID IN NUMBER,
    p_DOMAIN_ALIAS OUT VARCHAR2
    ) AS

v_ALIAS VARCHAR2(32);
BEGIN
	-- get the domain's alias from the ENTITY_DOMAIN table
    SELECT ENTITY_DOMAIN_TABLE_ALIAS
    INTO v_ALIAS
    FROM ENTITY_DOMAIN
    WHERE ENTITY_DOMAIN_ID = p_DOMAIN_ID;


    p_DOMAIN_ALIAS := v_ALIAS;

EXCEPTION
	WHEN OTHERS THEN
    	p_DOMAIN_ALIAS := NULL;
END GET_DOMAIN_ALIAS_FROM_ID;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_DOMAIN_NAME_FROM_ID
	(
    p_DOMAIN_ID IN NUMBER,
    p_DOMAIN_NAME OUT VARCHAR
    ) AS
v_NAME VARCHAR2(64);
BEGIN
	-- get the domain's name from the ENTITY_DOMAIN table
    SELECT NVL(DISPLAY_NAME,ENTITY_DOMAIN_NAME) "ENTITY_DOMAIN_NAME"
    INTO v_NAME
    FROM ENTITY_DOMAIN
    WHERE ENTITY_DOMAIN_ID = p_DOMAIN_ID;

    p_DOMAIN_NAME := v_NAME;

EXCEPTION
	WHEN OTHERS THEN
    	p_DOMAIN_NAME := NULL;
END GET_DOMAIN_NAME_FROM_ID;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_ENTITY_NAME_FROM_IDs
	(
    p_DOMAIN_ID IN NUMBER,
    p_ENTITY_ID IN NUMBER,
    p_ENTITY_NAME OUT VARCHAR
    ) AS
v_NAME VARCHAR2(64);
v_TABLE_NAME VARCHAR2(64);
v_ID_FIELD VARCHAR2(64);
v_NAME_FIELD VARCHAR2(64);
BEGIN
	-- get the domain's name from the ENTITY_DOMAIN table
    SELECT A.ENTITY_DOMAIN_TABLE,
    	RTRIM(LTRIM(UPPER(B.PRIMARY_ID_COLUMN)))
    INTO v_TABLE_NAME, v_ID_FIELD
    FROM ENTITY_DOMAIN A, NERO_TABLE_PROPERTY_INDEX B
    WHERE A.ENTITY_DOMAIN_ID = p_DOMAIN_ID
    	AND RTRIM(LTRIM(UPPER(A.ENTITY_DOMAIN_TABLE))) = RTRIM(LTRIM(UPPER(B.TABLE_NAME)));

    v_NAME_FIELD := SUBSTR(v_ID_FIELD,1,LENGTH(v_ID_FIELD)-2)||'NAME';

    EXECUTE IMMEDIATE ('SELECT '||v_NAME_FIELD||' FROM '||v_TABLE_NAME||' WHERE '||v_ID_FIELD||' = '||p_ENTITY_ID)
    	INTO v_NAME;

    p_ENTITY_NAME := v_NAME;

EXCEPTION
	WHEN OTHERS THEN
    	p_ENTITY_NAME := NULL;
END GET_ENTITY_NAME_FROM_IDs;
---------------------------------------------------------------------------------------------------
PROCEDURE TP_CONTRACT_NUMBERS
	(
	p_CONTRACT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

-- Answer the CONTRACTs for the given ACCOUNT.

BEGIN
	IF NOT Can_Read(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
    p_STATUS := GA.SUCCESS;

	 OPEN p_CURSOR FOR
	    SELECT TP_ID, BEGIN_DATE, END_DATE, CONTRACT_NAME, CONTRACT_NUMBER, ENTRY_DATE, CONTRACT_ID
		FROM TP_CONTRACT_NUMBER A
		WHERE CONTRACT_ID = p_CONTRACT_ID
		ORDER BY 2,3;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;
END TP_CONTRACT_NUMBERS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_TP_CONTRACT_NUMBER
	(
	p_CONTRACT_ID IN NUMBER,
	p_TP_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CONTRACT_NAME IN VARCHAR2,
	p_CONTRACT_NUMBER IN VARCHAR2,
	p_OLD_TP_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	)
	AS

CURSOR c_TP_CONTRACT_NUMBER IS
	SELECT *
	FROM TP_CONTRACT_NUMBER
	WHERE CONTRACT_ID = p_CONTRACT_ID
		AND TP_ID = p_TP_ID
	ORDER BY BEGIN_DATE DESC;

v_TP_CONTRACT_NUMBER TP_CONTRACT_NUMBER%ROWTYPE;
v_END_DATE DATE;
v_INITIAL BOOLEAN;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- UPDATE THE CURRENT ACCOUNT PRODUCT ASSIGNMENT IF ONE EXISTS

	UPDATE TP_CONTRACT_NUMBER SET
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		CONTRACT_NAME = p_CONTRACT_NAME,
		CONTRACT_NUMBER = p_CONTRACT_NUMBER,
		TP_ID = p_TP_ID,
		ENTRY_DATE = SYSDATE
	WHERE CONTRACT_ID = p_CONTRACT_ID
		AND TP_ID = p_OLD_TP_ID
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS ACCOUNT AND PRODUCT COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO TP_CONTRACT_NUMBER
			(
			CONTRACT_ID,
			TP_ID,
			BEGIN_DATE,
			END_DATE,
			CONTRACT_NAME,
			CONTRACT_NUMBER,
			ENTRY_DATE
			)
		VALUES
			(
			p_CONTRACT_ID,
			p_TP_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			p_CONTRACT_NAME,
			p_CONTRACT_NUMBER,
			SYSDATE
			);
	END IF;

	OPEN c_TP_CONTRACT_NUMBER;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_TP_CONTRACT_NUMBER INTO v_TP_CONTRACT_NUMBER;
		EXIT WHEN c_TP_CONTRACT_NUMBER%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_TP_CONTRACT_NUMBER.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE TP_CONTRACT_NUMBER
		SET END_DATE = GREATEST(v_END_DATE, v_TP_CONTRACT_NUMBER.BEGIN_DATE)
		WHERE CONTRACT_ID = v_TP_CONTRACT_NUMBER.CONTRACT_ID
			AND TP_ID = v_TP_CONTRACT_NUMBER.TP_ID
			AND BEGIN_DATE = v_TP_CONTRACT_NUMBER.BEGIN_DATE;
		v_END_DATE := v_TP_CONTRACT_NUMBER.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_TP_CONTRACT_NUMBER;

	EXCEPTION
		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END PUT_TP_CONTRACT_NUMBER;
----------------------------------------------------------------------------------------------------
PROCEDURE CONTRACT_PRODUCTS
	(
	p_CONTRACT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT REF_CURSOR
	) AS
BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT PRODUCT_ID, BEGIN_DATE, END_DATE, ENTRY_DATE, CONTRACT_ID
		FROM CONTRACT_PRODUCT A
		WHERE A.CONTRACT_ID = p_CONTRACT_ID
			AND A.BEGIN_DATE <= p_END_DATE
			AND NVL(A.END_DATE,HIGH_DATE) >= p_BEGIN_DATE
		ORDER BY A.BEGIN_DATE, A.END_DATE;

EXCEPTION
	WHEN INSUFFICIENT_PRIVILEGES THEN
		p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END CONTRACT_PRODUCTS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_CONTRACT_PRODUCT
	(
	p_CONTRACT_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_PRODUCT_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS

CURSOR c_CONTRACT_PRODUCT IS
	SELECT *
	FROM CONTRACT_PRODUCT
	WHERE CONTRACT_ID = p_CONTRACT_ID
		AND PRODUCT_ID = p_PRODUCT_ID
	ORDER BY BEGIN_DATE DESC;

v_CONTRACT_PRODUCT CONTRACT_PRODUCT%ROWTYPE;
v_INITIAL BOOLEAN;
v_END_DATE DATE;
v_OLD_END_DATE DATE;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);
	BEGIN
		SELECT NVL(END_DATE,HIGH_DATE) INTO v_OLD_END_DATE FROM CONTRACT_PRODUCT
		WHERE CONTRACT_ID = p_CONTRACT_ID
			AND PRODUCT_ID = p_OLD_PRODUCT_ID
			AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);
	EXCEPTION
		WHEN OTHERS THEN
			v_OLD_END_DATE := NULL;
	END;

-- UPDATE THE CURRENT ASSIGNMENT IF ONE EXISTS

	UPDATE CONTRACT_PRODUCT SET
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		PRODUCT_ID = p_PRODUCT_ID,
		ENTRY_DATE = SYSDATE
	WHERE CONTRACT_ID = p_CONTRACT_ID
		AND PRODUCT_ID = p_OLD_PRODUCT_ID
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS ACCOUNT AND PRODUCT COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO CONTRACT_PRODUCT
			(
			CONTRACT_ID,
			PRODUCT_ID,
			BEGIN_DATE,
			END_DATE,
			ENTRY_DATE
			)
		VALUES
			(
			p_CONTRACT_ID,
			p_PRODUCT_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			SYSDATE
			);
	END IF;

	OPEN c_CONTRACT_PRODUCT;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_CONTRACT_PRODUCT INTO v_CONTRACT_PRODUCT;
		EXIT WHEN c_CONTRACT_PRODUCT%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_CONTRACT_PRODUCT.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE CONTRACT_PRODUCT
		SET END_DATE = LEAST(v_END_DATE, v_CONTRACT_PRODUCT.END_DATE)
		WHERE CONTRACT_ID = v_CONTRACT_PRODUCT.CONTRACT_ID
			AND PRODUCT_ID = v_CONTRACT_PRODUCT.PRODUCT_ID
			AND BEGIN_DATE = v_CONTRACT_PRODUCT.BEGIN_DATE;
		v_END_DATE := v_CONTRACT_PRODUCT.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_CONTRACT_PRODUCT;

	-- make sure we don't have rows in CONTRACT_PRODUCT_COMPONENT laying around associated with rows
	-- in CONTRACT_PRODUCT that no longer exist
	IF NOT (v_OLD_END_DATE IS NULL) THEN
		UPDATE CONTRACT_PRODUCT_COMPONENT SET PRODUCT_ID = p_PRODUCT_ID
			WHERE CONTRACT_ID = p_CONTRACT_ID AND PRODUCT_ID = p_OLD_PRODUCT_ID
				AND BEGIN_DATE <= TRUNC(v_OLD_END_DATE) AND NVL(END_DATE,HIGH_DATE) >= TRUNC(p_OLD_BEGIN_DATE);
	END IF;

	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			p_STATUS := GA.DUPLICATE_ENTITY;
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		WHEN INVALID_DATE_RANGE THEN
			p_STATUS := GA.INVALID_DATE_RANGE;
		WHEN OTHERS THEN
			RAISE;

END PUT_CONTRACT_PRODUCT;
----------------------------------------------------------------------------------------------------
PROCEDURE CONTRACT_PROD_COMPONENTS
	(
	p_CONTRACT_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT REF_CURSOR
	) AS

v_CONTRACT_PROD CONTRACT_PRODUCT%ROWTYPE;
BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

--FIND THE UNIQUE CONTRACT PRODUCT
	SELECT *
	INTO v_CONTRACT_PROD
	FROM CONTRACT_PRODUCT
	WHERE CONTRACT_ID = p_CONTRACT_ID AND
            PRODUCT_ID = p_PRODUCT_ID AND
            BEGIN_DATE = p_BEGIN_DATE;

--SELECT ALL COMPONENTS FOR THAT PRODUCT
	OPEN p_CURSOR FOR
		SELECT CONTRACT_ID, COMPONENT_NAME, PRODUCT_ID, A.COMPONENT_ID, BEGIN_DATE, END_DATE, A.ENTRY_DATE
		FROM CONTRACT_PRODUCT_COMPONENT A,
			 COMPONENT B
		WHERE CONTRACT_ID = p_CONTRACT_ID AND
			PRODUCT_ID = p_PRODUCT_ID AND
			BEGIN_DATE >= v_CONTRACT_PROD.BEGIN_DATE AND
			(END_DATE <= NVL(v_CONTRACT_PROD.END_DATE, END_DATE) OR END_DATE IS NULL)
			AND B.COMPONENT_ID = A.COMPONENT_ID
		ORDER BY BEGIN_DATE;

	EXCEPTION
		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END CONTRACT_PROD_COMPONENTS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_CONTRACT_PROD_COMPONENT
	(
	p_CONTRACT_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_PRODUCT_ID IN NUMBER,
	p_OLD_COMPONENT_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS

CURSOR c_CONTRACT_PROD_COMPONENT IS
	SELECT *
	FROM CONTRACT_PRODUCT_COMPONENT
	WHERE CONTRACT_ID = p_CONTRACT_ID
		AND PRODUCT_ID = p_PRODUCT_ID
		AND COMPONENT_ID = p_COMPONENT_ID
	ORDER BY BEGIN_DATE DESC;

v_CONTRACT_PROD_COMPONENT CONTRACT_PRODUCT_COMPONENT%ROWTYPE;
v_INITIAL BOOLEAN;
v_END_DATE DATE;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- UPDATE THE CURRENT ASSIGNMENT IF ONE EXISTS

	UPDATE CONTRACT_PRODUCT_COMPONENT SET
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		COMPONENT_ID = p_COMPONENT_ID,
		ENTRY_DATE = SYSDATE
	WHERE CONTRACT_ID = p_CONTRACT_ID
		AND PRODUCT_ID = p_OLD_PRODUCT_ID
		AND COMPONENT_ID = p_OLD_COMPONENT_ID
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS ACCOUNT AND PRODUCT COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO CONTRACT_PRODUCT_COMPONENT
			(
			CONTRACT_ID,
			PRODUCT_ID,
			COMPONENT_ID,
			BEGIN_DATE,
			END_DATE,
			ENTRY_DATE
			)
		VALUES
			(
			p_CONTRACT_ID,
			p_PRODUCT_ID,
			p_COMPONENT_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			SYSDATE
			);
	END IF;
--MAKE SURE THAT COMPONENTS DON'T OVERLAP
	OPEN c_CONTRACT_PROD_COMPONENT;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_CONTRACT_PROD_COMPONENT INTO v_CONTRACT_PROD_COMPONENT;
		EXIT WHEN c_CONTRACT_PROD_COMPONENT%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_CONTRACT_PROD_COMPONENT.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		IF NVL(v_END_DATE,HIGH_DATE) < NVL(v_CONTRACT_PROD_COMPONENT.END_DATE,HIGH_DATE) THEN
			UPDATE CONTRACT_PRODUCT_COMPONENT
			SET END_DATE = v_END_DATE
			WHERE CONTRACT_ID = v_CONTRACT_PROD_COMPONENT.CONTRACT_ID
				AND PRODUCT_ID = v_CONTRACT_PROD_COMPONENT.PRODUCT_ID
				AND COMPONENT_ID = v_CONTRACT_PROD_COMPONENT.COMPONENT_ID
				AND BEGIN_DATE = v_CONTRACT_PROD_COMPONENT.BEGIN_DATE;
		END IF;
		v_END_DATE := v_CONTRACT_PROD_COMPONENT.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_CONTRACT_PROD_COMPONENT;

	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			p_STATUS := GA.DUPLICATE_ENTITY;
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		WHEN INVALID_DATE_RANGE THEN
			p_STATUS := GA.INVALID_DATE_RANGE;
		WHEN OTHERS THEN
			RAISE;

END PUT_CONTRACT_PROD_COMPONENT;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_CONTRACT_PROD_COMPONENT
	(
	p_CONTRACT_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_COMPONENT_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS
BEGIN
	PUT_CONTRACT_PROD_COMPONENT(p_CONTRACT_ID,p_PRODUCT_ID,p_COMPONENT_ID,p_BEGIN_DATE,p_END_DATE,p_PRODUCT_ID,p_OLD_COMPONENT_ID,p_OLD_BEGIN_DATE,p_STATUS);
END PUT_CONTRACT_PROD_COMPONENT;
----------------------------------------------------------------------------------------------------
PROCEDURE CONTRACT_COMP_ASSIGNMENTS
	(
	p_CONTRACT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT REF_CURSOR
	) AS
BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT A.PRODUCT_ID, PRODUCT_NAME,
			A.COMPONENT_ID, COMPONENT_NAME,
			A.BEGIN_DATE, A.END_DATE,
			A.ENTRY_DATE
		FROM CONTRACT_PRODUCT_COMPONENT A,
			PRODUCT B,
			COMPONENT C
		WHERE CONTRACT_ID = p_CONTRACT_ID
			AND B.PRODUCT_ID = A.PRODUCT_ID
			AND C.COMPONENT_ID = A.COMPONENT_ID
		ORDER BY A.BEGIN_DATE, A.END_DATE;

EXCEPTION
	WHEN INSUFFICIENT_PRIVILEGES THEN
		p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END CONTRACT_COMP_ASSIGNMENTS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_CONTRACT_COMP_ASSIGNMENT
	(
	p_CONTRACT_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_PRODUCT_ID IN NUMBER,
	p_OLD_COMPONENT_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS
v_COUNT NUMBER;
v_PROD_BEGIN_DATE DATE;
v_PROD_END_DATE DATE;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_FIRST BOOLEAN;
v_OLD_COMPONENT_ID NUMBER;
CURSOR c_COMPS IS
	SELECT COMPONENT_ID,
		GREATEST(BEGIN_DATE,p_BEGIN_DATE) "BEGIN_DATE",
		LEAST(NVL(END_DATE,HIGH_DATE),NVL(p_END_DATE,HIGH_DATE)) "END_DATE"
	FROM PRODUCT_COMPONENT
	WHERE PRODUCT_ID = p_PRODUCT_ID
		AND BEGIN_DATE <= NVL(TRUNC(p_END_DATE),HIGH_DATE)
		AND NVL(END_DATE,HIGH_DATE) >= TRUNC(p_BEGIN_DATE);
BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	SELECT COUNT(*), MIN(BEGIN_DATE), MAX(END_DATE)
	INTO v_COUNT, v_PROD_BEGIN_DATE, v_PROD_END_DATE
	FROM CONTRACT_PRODUCT
	WHERE CONTRACT_ID = p_CONTRACT_ID
		AND PRODUCT_ID = p_PRODUCT_ID;

	IF v_COUNT = 0 THEN
		PUT_CONTRACT_PRODUCT(p_CONTRACT_ID, p_PRODUCT_ID, TRUNC(p_BEGIN_DATE), TRUNC(p_END_DATE), p_PRODUCT_ID, TRUNC(p_BEGIN_DATE), p_STATUS);
	ELSE
    	SELECT LEAST(NVL(MIN(BEGIN_DATE),HIGH_DATE),TRUNC(p_BEGIN_DATE)),
    		GREATEST(NVL(MAX(END_DATE),LOW_DATE),TRUNC(p_END_DATE))
    	INTO v_BEGIN_DATE, v_END_DATE
    	FROM CONTRACT_PRODUCT_COMPONENT
    	WHERE CONTRACT_ID = p_CONTRACT_ID
    		AND PRODUCT_ID = p_PRODUCT_ID;
		-- push date ranges out
    	UPDATE CONTRACT_PRODUCT
    		SET BEGIN_DATE = LEAST(BEGIN_DATE,v_BEGIN_DATE)
    	WHERE CONTRACT_ID = p_CONTRACT_ID
    		AND PRODUCT_ID = p_PRODUCT_ID
			AND BEGIN_DATE = v_PROD_BEGIN_DATE;
    	UPDATE CONTRACT_PRODUCT
    		SET BEGIN_DATE = GREATEST(END_DATE,v_END_DATE)
    	WHERE CONTRACT_ID = p_CONTRACT_ID
    		AND PRODUCT_ID = p_PRODUCT_ID
			AND END_DATE = v_PROD_END_DATE;
	END IF;

	-- insert multiple components if they specified all
	IF p_COMPONENT_ID = g_ALL THEN
		FOR v_COMP IN c_COMPS LOOP
			IF v_FIRST THEN
				v_OLD_COMPONENT_ID := p_OLD_COMPONENT_ID;
				v_FIRST := FALSE;
			ELSE
				v_OLD_COMPONENT_ID := v_COMP.COMPONENT_ID;
			END IF;
			PUT_CONTRACT_PROD_COMPONENT(p_CONTRACT_ID, p_PRODUCT_ID, v_COMP.COMPONENT_ID, TRUNC(v_COMP.BEGIN_DATE), TRUNC(v_COMP.END_DATE), p_OLD_PRODUCT_ID, v_OLD_COMPONENT_ID, TRUNC(p_OLD_BEGIN_DATE), p_STATUS);
		END LOOP;
	ELSE
		PUT_CONTRACT_PROD_COMPONENT(p_CONTRACT_ID, p_PRODUCT_ID, p_COMPONENT_ID, TRUNC(p_BEGIN_DATE), TRUNC(p_END_DATE), p_OLD_PRODUCT_ID, p_OLD_COMPONENT_ID, p_OLD_BEGIN_DATE, p_STATUS);
	END IF;

	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			p_STATUS := GA.DUPLICATE_ENTITY;
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		WHEN INVALID_DATE_RANGE THEN
			p_STATUS := GA.INVALID_DATE_RANGE;
		WHEN OTHERS THEN
			RAISE;
END PUT_CONTRACT_COMP_ASSIGNMENT;
----------------------------------------------------------------------------------------------------
PROCEDURE CONTRACT_NOTES
	(
	p_CONTRACT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS


BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

   OPEN p_CURSOR FOR
		SELECT A.NOTE_TYPE, A.NOTE_DATE, A.NOTE_AUTHOR, A.NOTE_TEXT
		FROM SERVICE_CONTRACT_NOTE A
		WHERE A.CONTRACT_ID = p_CONTRACT_ID
		ORDER BY 1,2,3;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END CONTRACT_NOTES;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_CONTRACT_NOTE
	(
	p_CONTRACT_ID IN NUMBER,
	p_NOTE_TYPE IN VARCHAR,
	p_NOTE_DATE IN DATE,
	p_NOTE_AUTHOR IN VARCHAR,
	p_NOTE_TEXT IN VARCHAR,
	p_OLD_NOTE_TYPE IN VARCHAR,
	p_OLD_NOTE_DATE IN DATE,
	p_OLD_NOTE_AUTHOR IN VARCHAR,
	p_STATUS OUT NUMBER
	)
	AS

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

-- UPDATE THE CURRENT CONTRACT NOTE ASSIGNMENT IF ONE EXISTS

	UPDATE SERVICE_CONTRACT_NOTE SET
		NOTE_TYPE = LTRIM(RTRIM(p_NOTE_TYPE)),
		NOTE_DATE = p_NOTE_DATE,
		NOTE_AUTHOR = LTRIM(RTRIM(p_NOTE_AUTHOR)),
		NOTE_TEXT = LTRIM(RTRIM(p_NOTE_TEXT))
	WHERE CONTRACT_ID = p_CONTRACT_ID
		AND NOTE_TYPE = p_OLD_NOTE_TYPE
		AND NOTE_DATE = p_OLD_NOTE_DATE
		AND NOTE_AUTHOR = p_OLD_NOTE_AUTHOR;

-- NO ASSIGNMENT UPDATE FOR THIS CONTRACT AND BILL_PARTY COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO SERVICE_CONTRACT_NOTE
			(
			CONTRACT_ID,
			NOTE_TYPE,
			NOTE_DATE,
			NOTE_AUTHOR,
			NOTE_TEXT
			)
		VALUES
			(
			p_CONTRACT_ID,
			LTRIM(RTRIM(p_NOTE_TYPE)),
			p_NOTE_DATE,
			LTRIM(RTRIM(p_NOTE_AUTHOR)),
			LTRIM(RTRIM(p_NOTE_TEXT))
			);
	END IF;

	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			p_STATUS := GA.DUPLICATE_ENTITY;
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		WHEN OTHERS THEN
			RAISE;

END PUT_CONTRACT_NOTE;
---------------------------------------------------------------------------------------------------
PROCEDURE CONTRACT_LIMIT_QUANTITYS
	(
	p_CONTRACT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

-- Answer the CONTRACT LIMITs for the given CONTRACT.

BEGIN
	IF NOT Can_Read(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
    p_STATUS := GA.SUCCESS;
	OPEN p_CURSOR FOR
	    SELECT C.LIMIT_ID,
			C.BEGIN_DATE,
			C.END_DATE,
			C.LIMIT_QUANTITY,
			C.ENTRY_DATE
		FROM CONTRACT_LIMIT_QUANTITY C
		WHERE C.CONTRACT_ID = p_CONTRACT_ID
		ORDER BY C.BEGIN_DATE;
	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;
END CONTRACT_LIMIT_QUANTITYS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_CONTRACT_LIMIT_QUANTITY
	(
	p_CONTRACT_ID IN NUMBER,
	p_LIMIT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_LIMIT_QUANTITY IN NUMBER,
	p_OLD_LIMIT_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	)
	AS
v_END_DATE DATE;

BEGIN
	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);
-- UPDATE THE CURRENT LIMIT ASSIGNMENT IF ONE EXISTS
	UPDATE CONTRACT_LIMIT_QUANTITY SET
		LIMIT_ID = p_LIMIT_ID,
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		LIMIT_QUANTITY = NVL(p_LIMIT_QUANTITY,0),
		ENTRY_DATE = SYSDATE
	WHERE CONTRACT_ID = p_CONTRACT_ID
		AND LIMIT_ID = p_OLD_LIMIT_ID
		AND BEGIN_DATE = p_OLD_BEGIN_DATE;

-- NO UPDATE FOR THIS ACCOUNT CONTRACT SO INSERT A NEW ONE.
	IF SQL%NOTFOUND THEN
		INSERT INTO CONTRACT_LIMIT_QUANTITY
			(
			CONTRACT_ID,
			LIMIT_ID,
			BEGIN_DATE,
			END_DATE,
			LIMIT_QUANTITY,
			ENTRY_DATE
			)
		VALUES
			(
			p_CONTRACT_ID,
			p_LIMIT_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			NVL(p_LIMIT_QUANTITY,0),
			SYSDATE
			);
	END IF;

	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			p_STATUS := GA.DUPLICATE_ENTITY;
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		WHEN OTHERS THEN
			RAISE;
END PUT_CONTRACT_LIMIT_QUANTITY;
----------------------------------------------------------------------------------------------------
PROCEDURE BILLING_ENTITY_LIST
	(
	p_BILLING_ENTITY_TYPE IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

-- Answer the COUNTER PARTIES OF THE GIVEN TYPE

BEGIN
	IF NOT Can_Read(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
    p_STATUS := GA.SUCCESS;

	 IF UPPER(p_BILLING_ENTITY_TYPE) = 'PSE' THEN
	 	 OPEN p_CURSOR FOR
		 	 SELECT PSE_NAME, PSE_ID
			 FROM PURCHASING_SELLING_ENTITY
			 WHERE PSE_STATUS = 'Active'
             	AND NVL(IS_BILLING_ENTITY,0) = 1
			 ORDER BY 1;
	 ELSIF UPPER(p_BILLING_ENTITY_TYPE) = 'PIPELINE' THEN
	 	 OPEN p_CURSOR FOR
		 	 SELECT PIPELINE_NAME, PIPELINE_ID
			 FROM PIPELINE
			 WHERE PIPELINE_STATUS = 'Active'
			 ORDER BY 1;
	 ELSIF UPPER(p_BILLING_ENTITY_TYPE) = 'STORAGE' THEN
	 	 OPEN p_CURSOR FOR
		 	 SELECT STORAGE_NAME, STORAGE_ID
			 FROM STORAGE_FACILITY
			 WHERE STORAGE_STATUS = 'Active'
			 ORDER BY 1;
	 END IF;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;
END BILLING_ENTITY_LIST;
---------------------------------------------------------------------------------------------------

PROCEDURE SCHEDULE_TEMPLATE_LIST
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

-- Answer the Schedule Template names

BEGIN
	IF NOT Can_Read(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
    p_STATUS := GA.SUCCESS;

 	 OPEN p_CURSOR FOR
	 		SELECT TEMPLATE_NAME
			FROM SCHEDULE_TEMPLATE
			ORDER BY TEMPLATE_ORDER, TEMPLATE_NAME;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;
END SCHEDULE_TEMPLATE_LIST;
---------------------------------------------------------------------------------------------------
PROCEDURE PIPELINE_ZONE_LIST
	(
	p_PIPELINE_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

-- Answer the Pipeline Zone names

BEGIN
	IF NOT Can_Read(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
    p_STATUS := GA.SUCCESS;

 	 OPEN p_CURSOR FOR
	 		SELECT PIPELINE_ZONE_NAME, PIPELINE_ZONE_ID
			FROM PIPELINE_ZONE
				WHERE PIPELINE_ID = p_PIPELINE_ID
					AND PIPELINE_ZONE_ID > 0
			ORDER BY 1;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;
END PIPELINE_ZONE_LIST;
---------------------------------------------------------------------------------------------------
PROCEDURE PIPELINE_POINT_LIST
	(
	p_PIPELINE_ID IN NUMBER,
	p_PIPELINE_ZONE_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

-- Answer the Pipeline Points w/ names

BEGIN
	IF NOT Can_Read(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
    p_STATUS := GA.SUCCESS;

 	 OPEN p_CURSOR FOR
	 		SELECT PIPELINE_POINT_NAME, PIPELINE_POINT_ID
			FROM PIPELINE_POINT
				WHERE PIPELINE_ID = p_PIPELINE_ID
					AND PIPELINE_ZONE_ID = p_PIPELINE_ZONE_ID
					AND PIPELINE_POINT_ID > 0
			ORDER BY 1;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;
END PIPELINE_POINT_LIST;
---------------------------------------------------------------------------------------------------

PROCEDURE COMPONENT_FOR_PRODUCT_LIST
	(
	p_PRODUCT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

-- Answer the Components assigned to the specified product

BEGIN
	IF NOT Can_Read(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
    p_STATUS := GA.SUCCESS;

	 OPEN p_CURSOR FOR
	 		SELECT COMPONENT_NAME, COMPONENT_ID
			FROM COMPONENT
				 WHERE COMPONENT_ID IN (SELECT COMPONENT_ID
				 		FROM PRODUCT_COMPONENT
						WHERE PRODUCT_ID = p_PRODUCT_ID)
			ORDER BY 1;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;
END COMPONENT_FOR_PRODUCT_LIST;
---------------------------------------------------------------------------------------------------

PROCEDURE MODEL_LIST
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

-- Answer the Models (Electric, Gas)

BEGIN
	IF NOT Can_Read(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
    p_STATUS := GA.SUCCESS;

	 OPEN p_CURSOR FOR
	 		SELECT 'Electric',1 FROM DUAL
			UNION ALL
			SELECT 'Gas',2 FROM DUAL;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;
END MODEL_LIST;
---------------------------------------------------------------------------------------------------
PROCEDURE LIST_STATEMENT_TYPES
	(
    p_STATUS OUT NUMBER,
    p_CURSOR IN OUT REF_CURSOR
    ) AS
v_AVAILABLE_IDS ID_TABLE := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_STATEMENT_TYPE_LIST);
BEGIN
	IF NOT Can_Read(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
    p_STATUS := GA.SUCCESS;

	 OPEN p_CURSOR FOR
 		SELECT A.* FROM STATEMENT_TYPE A, TABLE(CAST(v_AVAILABLE_IDS AS ID_TABLE)) X
			WHERE (X.ID = SD.g_ALL_DATA_ENTITY_ID OR A.STATEMENT_TYPE_ID = X.ID)
		ORDER BY STATEMENT_TYPE_ORDER;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;
END LIST_STATEMENT_TYPES;
---------------------------------------------------------------------------------------------------
PROCEDURE EDC_SETTLEMENT_AGENT_LIST
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

BEGIN
	IF NOT Can_Read(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
    p_STATUS := GA.SUCCESS;

 	 OPEN p_CURSOR FOR
	 		SELECT SETTLEMENT_AGENT_NAME
			FROM EDC_SETTLEMENT_AGENT
			ORDER BY 1;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;
END EDC_SETTLEMENT_AGENT_LIST;
---------------------------------------------------------------------------------------------------
PROCEDURE PORTFOLIO_SERVICE_POINTS
	(
	p_PORTFOLIO_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS


BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    p_STATUS := GA.SUCCESS;
	OPEN p_CURSOR FOR
	    SELECT A.SERVICE_POINT_ID,
	    	B.SERVICE_POINT_NAME,
	    	1 "IS_SELECTED",
			A.PORTFOLIO_ID
		FROM PORTFOLIO_SERVICE_POINT A, SERVICE_POINT B
		WHERE A.PORTFOLIO_ID = p_PORTFOLIO_ID
			AND A.SERVICE_POINT_ID = B.SERVICE_POINT_ID
			AND A.SERVICE_POINT_ID > 0

		UNION

		SELECT SERVICE_POINT_ID,
			SERVICE_POINT_NAME,
			0 "IS_SELECTED",
			p_PORTFOLIO_ID "PORTFOLIO_ID"
		FROM SERVICE_POINT
		WHERE NOT SERVICE_POINT_ID IN (SELECT SERVICE_POINT_ID
									FROM PORTFOLIO_SERVICE_POINT
									WHERE PORTFOLIO_ID = p_PORTFOLIO_ID)
			AND SERVICE_POINT_ID > 0

		ORDER BY 3 DESC, 2 ASC;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END PORTFOLIO_SERVICE_POINTS;
---------------------------------------------------------------------------------------------------


PROCEDURE PUT_PORTFOLIO_SERVICE_POINT
	(
	p_PORTFOLIO_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_IS_SELECTED IN NUMBER,
	p_STATUS OUT NUMBER
	)
	AS

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	--DELETE THE CURRENT ASSIGNMENT IF NOT SELECTED.
	IF p_IS_SELECTED = 0 THEN
		DELETE FROM PORTFOLIO_SERVICE_POINT
		WHERE PORTFOLIO_ID = p_PORTFOLIO_ID
			AND SERVICE_POINT_ID = p_SERVICE_POINT_ID;
	ELSE
	-- UPDATE THE CURRENT ASSIGNMENT IF ONE EXISTS

		UPDATE PORTFOLIO_SERVICE_POINT SET
			SERVICE_POINT_ID = p_SERVICE_POINT_ID
		WHERE PORTFOLIO_ID = p_PORTFOLIO_ID
			AND SERVICE_POINT_ID = p_SERVICE_POINT_ID;

	-- NO ASSIGNMENT UPDATE FOR THIS ACCOUNT AND ANCILLARY_SERVICE COMBINATION SO INSERT A NEW ASSIGNMENT

		IF SQL%NOTFOUND THEN
			INSERT INTO PORTFOLIO_SERVICE_POINT
				(
				PORTFOLIO_ID,
				SERVICE_POINT_ID
				)
			VALUES
				(
				p_PORTFOLIO_ID,
				p_SERVICE_POINT_ID
				);
		END IF;
	END IF;

	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			p_STATUS := GA.DUPLICATE_ENTITY;
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		WHEN OTHERS THEN
			RAISE;
END PUT_PORTFOLIO_SERVICE_POINT;
---------------------------------------------------------------------------------------------------
PROCEDURE SUB_SERVICE_POINTS
	(
	p_SERVICE_POINT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS


BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

   OPEN p_CURSOR FOR
		SELECT A.BEGIN_DATE,
			 A.END_DATE,
			 A.ALLOCATION_PCT,
			 A.SUB_SERVICE_POINT_ID,
			 B.SERVICE_POINT_NAME "SUB_SERVICE_POINT_NAME",
			 A.ENTRY_DATE,
			 A.SERVICE_POINT_ID
		FROM SERVICE_POINT_AGGREGATE A, SERVICE_POINT B
		WHERE A.SERVICE_POINT_ID = p_SERVICE_POINT_ID
			AND A.SUB_SERVICE_POINT_ID = B.SERVICE_POINT_ID
		ORDER BY 5, 1;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END SUB_SERVICE_POINTS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_SUB_SERVICE_POINT
	(
	p_SERVICE_POINT_ID IN NUMBER,
	p_SUB_SERVICE_POINT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ALLOCATION_PCT IN NUMBER,
	p_OLD_SUB_SERVICE_POINT_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	P_STATUS OUT NUMBER
	)
	AS

v_END_DATE DATE;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- UPDATE THE CURRENT AGGREGATE SC ASSIGNMENT IF ONE EXISTS

	UPDATE SERVICE_POINT_AGGREGATE SET
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		ALLOCATION_PCT = NVL(p_ALLOCATION_PCT,0),
		ENTRY_DATE = SYSDATE,
		SUB_SERVICE_POINT_ID = p_SUB_SERVICE_POINT_ID
	WHERE SERVICE_POINT_ID = p_SERVICE_POINT_ID
		AND SUB_SERVICE_POINT_ID = p_OLD_SUB_SERVICE_POINT_ID
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS AGGREGATE SC COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO SERVICE_POINT_AGGREGATE
			(
			SERVICE_POINT_ID,
			SUB_SERVICE_POINT_ID,
			BEGIN_DATE,
			END_DATE,
			ALLOCATION_PCT,
			ENTRY_DATE
			)
		VALUES
			(
			p_SERVICE_POINT_ID,
			p_SUB_SERVICE_POINT_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			NVL(p_ALLOCATION_PCT,0),
			SYSDATE
			);
	END IF;

	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			p_STATUS := GA.DUPLICATE_ENTITY;
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		WHEN OTHERS THEN
			RAISE;

END PUT_SUB_SERVICE_POINT;
----------------------------------------------------------------------------------------------------
PROCEDURE SUB_SERVICE_POINT_LIST
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

-- Answer the list of SERVICE_POINTS available to be Sub Service Points

BEGIN
	IF NOT Can_Read(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
    p_STATUS := GA.SUCCESS;

 	 OPEN p_CURSOR FOR
	 	 SELECT SERVICE_POINT_NAME, SERVICE_POINT_ID
		 FROM SERVICE_POINT
		 WHERE NODE_TYPE IN ('Bus', 'BUS')
		 ORDER BY 1;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;
END SUB_SERVICE_POINT_LIST;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_TRANSACTION
	(
	o_OID OUT NUMBER,
	p_TRANSACTION_NAME IN VARCHAR2,
	p_TRANSACTION_ALIAS IN VARCHAR2,
	p_TRANSACTION_DESC IN VARCHAR2,
	p_TRANSACTION_ID IN NUMBER,
    p_TRANSACTION_STATUS IN VARCHAR2,
	p_TRANSACTION_TYPE IN VARCHAR2,
	p_TRANSACTION_CODE IN CHAR,
	p_TRANSACTION_IDENTIFIER IN VARCHAR2,
	p_IS_FIRM IN NUMBER,
	p_IS_IMPORT_SCHEDULE IN NUMBER,
	p_IS_EXPORT_SCHEDULE IN NUMBER,
	p_IS_BALANCE_TRANSACTION IN NUMBER,
	p_IS_BID_OFFER IN NUMBER,
	p_IS_EXCLUDE_FROM_POSITION IN NUMBER,
    p_IS_IMPORT_EXPORT IN NUMBER,
	p_IS_DISPATCHABLE IN NUMBER,
	p_TRANSACTION_INTERVAL IN VARCHAR2,
	p_EXTERNAL_INTERVAL IN VARCHAR2,
	p_ETAG_CODE IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PURCHASER_ID IN NUMBER,
	p_SELLER_ID IN NUMBER,
	p_CONTRACT_ID IN NUMBER,
	p_SC_ID IN NUMBER,
	p_POR_ID IN NUMBER,
	p_POD_ID IN NUMBER,
	p_SCHEDULER_ID IN NUMBER,
	p_COMMODITY_ID IN NUMBER,
	p_SERVICE_TYPE_ID IN NUMBER,
	p_TX_TRANSACTION_ID IN NUMBER,
	p_PATH_ID IN NUMBER,
	p_LINK_TRANSACTION_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_SCHEDULE_GROUP_ID IN NUMBER,
	p_MARKET_PRICE_ID IN NUMBER,
	p_ZOR_ID IN NUMBER,
	p_ZOD_ID IN NUMBER,
	p_SOURCE_ID IN NUMBER,
	p_SINK_ID IN NUMBER,
	p_RESOURCE_ID IN NUMBER,
    p_AGREEMENT_TYPE IN VARCHAR2,
    p_APPROVAL_TYPE IN VARCHAR2,
    p_LOSS_OPTION IN VARCHAR2,
    p_TRAIT_CATEGORY IN VARCHAR2,
	p_MODEL_ID IN NUMBER,
	p_TP_ID IN NUMBER
	) AS
v_IS_ACTIVE NUMBER(1);
v_STATUS NUMBER;
v_CODE CHAR(1);
BEGIN
	-- get proper transaction code first
    BEGIN
        SELECT SUBSTR(CODE,1,1) INTO v_CODE
        FROM SYSTEM_LABEL
        WHERE MODEL_ID = NVL(p_MODEL_ID,1)
        	AND MODULE = DECODE(NVL(p_MODEL_ID,1),1,'Scheduling',2,'Gas Delivery')
            AND KEY1 = 'TransactionDialog'
            AND KEY2 = 'Combo Lists'
            AND KEY3 = 'Transaction Type'
            AND VALUE = p_TRANSACTION_TYPE
			AND ROWNUM = 1;
	EXCEPTION
    	WHEN NO_DATA_FOUND THEN
        	v_CODE := NULL;
	END;
    -- then put the transaction
	IO.PUT_TRANSACTION(o_OID,p_TRANSACTION_NAME,p_TRANSACTION_ALIAS,p_TRANSACTION_DESC,
		p_TRANSACTION_ID,p_TRANSACTION_TYPE,v_CODE,p_TRANSACTION_IDENTIFIER,
        p_IS_FIRM,p_IS_IMPORT_SCHEDULE,p_IS_EXPORT_SCHEDULE,p_IS_BALANCE_TRANSACTION,
        p_IS_BID_OFFER,p_IS_EXCLUDE_FROM_POSITION,p_IS_IMPORT_EXPORT,p_IS_DISPATCHABLE,p_TRANSACTION_INTERVAL,
        p_EXTERNAL_INTERVAL,p_ETAG_CODE,p_BEGIN_DATE,p_END_DATE,p_PURCHASER_ID,p_SELLER_ID,
        p_CONTRACT_ID,p_SC_ID,p_POR_ID,p_POD_ID,p_SCHEDULER_ID,p_COMMODITY_ID,p_SERVICE_TYPE_ID,
        p_TX_TRANSACTION_ID,p_PATH_ID,p_LINK_TRANSACTION_ID,p_EDC_ID,p_PSE_ID,p_ESP_ID,
        p_POOL_ID,p_SCHEDULE_GROUP_ID,p_MARKET_PRICE_ID,p_ZOR_ID,p_ZOD_ID,p_SOURCE_ID,
        p_SINK_ID,p_RESOURCE_ID,p_AGREEMENT_TYPE,p_APPROVAL_TYPE,p_LOSS_OPTION,p_TRAIT_CATEGORY,NVL(p_MODEL_ID,1), p_TP_ID);
	-- then put the transaction status
	BEGIN
    	SELECT TRANSACTION_IS_ACTIVE INTO v_IS_ACTIVE
        FROM INTERCHANGE_TRANSACTION_STATUS
        WHERE TRANSACTION_STATUS_NAME = p_TRANSACTION_STATUS;
    EXCEPTION
    	WHEN OTHERS THEN
        	v_IS_ACTIVE := 0;
    END;
	IT.PUT_IT_STATUS(o_OID,SYSDATE,p_TRANSACTION_STATUS,v_IS_ACTIVE,v_STATUS);
    IF v_STATUS < 0 THEN
    	ROLLBACK; -- undo the PUTs
        o_OID := v_STATUS;
    END IF;
    -- done!
END PUT_TRANSACTION;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_TRANSACTION
	(
	p_TRANSACTION_ID IN NUMBER,
	p_TRANSACTION_NAME OUT VARCHAR2,
	p_TRANSACTION_ALIAS OUT VARCHAR2,
	p_TRANSACTION_DESC OUT VARCHAR2,
    p_TRANSACTION_STATUS OUT VARCHAR2,
	p_TRANSACTION_TYPE OUT VARCHAR2,
	p_TRANSACTION_CODE OUT CHAR,
	p_TRANSACTION_IDENTIFIER OUT VARCHAR2,
	p_IS_FIRM OUT NUMBER,
	p_IS_IMPORT_SCHEDULE OUT NUMBER,
	p_IS_EXPORT_SCHEDULE OUT NUMBER,
	p_IS_BALANCE_TRANSACTION OUT NUMBER,
	p_IS_BID_OFFER OUT NUMBER,
	p_IS_EXCLUDE_FROM_POSITION OUT NUMBER,
    p_IS_IMPORT_EXPORT OUT NUMBER,
	p_IS_DISPATCHABLE OUT NUMBER,
	p_TRANSACTION_INTERVAL OUT VARCHAR2,
	p_EXTERNAL_INTERVAL OUT VARCHAR2,
	p_ETAG_CODE OUT VARCHAR2,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE,
	p_PURCHASER_ID OUT NUMBER,
	p_SELLER_ID OUT NUMBER,
	p_CONTRACT_ID OUT NUMBER,
	p_SC_ID OUT NUMBER,
	p_POR_ID OUT NUMBER,
	p_POD_ID OUT NUMBER,
	p_SCHEDULER_ID OUT NUMBER,
	p_COMMODITY_ID OUT NUMBER,
	p_SERVICE_TYPE_ID OUT NUMBER,
	p_TX_TRANSACTION_ID OUT NUMBER,
	p_PATH_ID OUT NUMBER,
	p_LINK_TRANSACTION_ID OUT NUMBER,
	p_EDC_ID OUT NUMBER,
	p_PSE_ID OUT NUMBER,
	p_ESP_ID OUT NUMBER,
	p_POOL_ID OUT NUMBER,
	p_SCHEDULE_GROUP_ID OUT NUMBER,
	p_MARKET_PRICE_ID OUT NUMBER,
	p_ZOR_ID OUT NUMBER,
	p_ZOD_ID OUT NUMBER,
	p_SOURCE_ID OUT NUMBER,
	p_SINK_ID OUT NUMBER,
	p_RESOURCE_ID OUT NUMBER,
    p_AGREEMENT_TYPE OUT VARCHAR2,
    p_APPROVAL_TYPE OUT VARCHAR2,
    p_LOSS_OPTION OUT VARCHAR2,
    p_TRAIT_CATEGORY OUT VARCHAR2,
	p_MODEL_ID OUT NUMBER,
	p_TP_ID OUT NUMBER
	) AS
v_IS_ACTIVE NUMBER(1);
v_STATUS NUMBER;
BEGIN
	IO.GET_TRANSACTION(p_TRANSACTION_ID,p_TRANSACTION_NAME,p_TRANSACTION_ALIAS,
    	p_TRANSACTION_DESC,p_TRANSACTION_TYPE,p_TRANSACTION_CODE,p_TRANSACTION_IDENTIFIER,
        p_IS_FIRM,p_IS_IMPORT_SCHEDULE,p_IS_EXPORT_SCHEDULE,p_IS_BALANCE_TRANSACTION,
        p_IS_BID_OFFER,p_IS_EXCLUDE_FROM_POSITION,p_IS_IMPORT_EXPORT,p_IS_DISPATCHABLE,p_TRANSACTION_INTERVAL,
        p_EXTERNAL_INTERVAL,p_ETAG_CODE,p_BEGIN_DATE,p_END_DATE,p_PURCHASER_ID,p_SELLER_ID,
        p_CONTRACT_ID,p_SC_ID,p_POR_ID,p_POD_ID,p_SCHEDULER_ID,p_COMMODITY_ID,p_SERVICE_TYPE_ID,
        p_TX_TRANSACTION_ID,p_PATH_ID,p_LINK_TRANSACTION_ID,p_EDC_ID,p_PSE_ID,p_ESP_ID,
        p_POOL_ID,p_SCHEDULE_GROUP_ID,p_MARKET_PRICE_ID,p_ZOR_ID,p_ZOD_ID,p_SOURCE_ID,
        p_SINK_ID,p_RESOURCE_ID,p_AGREEMENT_TYPE,p_APPROVAL_TYPE,p_LOSS_OPTION,p_TRAIT_CATEGORY,p_MODEL_ID, p_TP_ID);
	IT.GET_IT_STATUS(p_TRANSACTION_ID,SYSDATE,p_TRANSACTION_STATUS,v_IS_ACTIVE,v_STATUS);
END GET_TRANSACTION;
----------------------------------------------------------------------------------------------------
PROCEDURE LIST_TRANSACTIONS
	(
	p_SEARCH_STRING IN VARCHAR,
	p_SEARCH_BY_ALIAS IN NUMBER,
	p_INCLUDE_INACTIVE IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	)
	AS

-- Answer the given entities

BEGIN

--Make sure user has appropriate access.

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

p_STATUS := GA.SUCCESS;

IF p_SEARCH_STRING = '%' OR p_SEARCH_STRING IS NULL THEN

	OPEN p_CURSOR FOR
	SELECT
		A.TRANSACTION_NAME "ENTITY_NAME",
		A.TRANSACTION_ID "ENTITY_ID",
		A.TRANSACTION_ALIAS "ENTITY_ALIAS",
		B.TRANSACTION_STATUS_NAME "ENTITY_STATUS"
	FROM INTERCHANGE_TRANSACTION A,
    	IT_STATUS B
    WHERE A.BEGIN_DATE <= p_END_DATE -- filter by dates
    	AND NVL(A.END_DATE,HIGH_DATE) >= p_BEGIN_DATE
    	AND NVL(A.MODEL_ID,1) <> 2 -- don't get Gas transactions
    	AND B.TRANSACTION_ID = A.TRANSACTION_ID -- join for status
    	AND B.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
        					FROM IT_STATUS
                            WHERE TRANSACTION_ID = B.TRANSACTION_ID
                            	AND AS_OF_DATE <= SYSDATE)
	ORDER BY DECODE(p_SEARCH_BY_ALIAS, 0, TRANSACTION_NAME, TRANSACTION_ALIAS);

ELSE

	OPEN p_CURSOR FOR
	SELECT
		A.TRANSACTION_NAME "ENTITY_NAME",
		A.TRANSACTION_ID "ENTITY_ID",
		A.TRANSACTION_ALIAS "ENTITY_ALIAS",
		B.TRANSACTION_STATUS_NAME "ENTITY_STATUS"
	FROM INTERCHANGE_TRANSACTION A,
    	IT_STATUS B
	WHERE A.BEGIN_DATE <= p_END_DATE -- filter by dates
    	AND NVL(A.END_DATE,HIGH_DATE) >= p_BEGIN_DATE
        AND (p_SEARCH_BY_ALIAS = 1 OR TRANSACTION_NAME LIKE p_SEARCH_STRING)
		AND (p_SEARCH_BY_ALIAS = 0 OR TRANSACTION_ALIAS LIKE p_SEARCH_STRING)
		AND NVL(A.MODEL_ID,1) <> 2 -- don't get Gas transactions
    	AND B.TRANSACTION_ID = A.TRANSACTION_ID -- join for status
    	AND B.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
        					FROM IT_STATUS
                            WHERE TRANSACTION_ID = B.TRANSACTION_ID
                            	AND AS_OF_DATE <= SYSDATE)
	ORDER BY DECODE(p_SEARCH_BY_ALIAS, 0, TRANSACTION_NAME, TRANSACTION_ALIAS);

END IF;

	EXCEPTION
		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END LIST_TRANSACTIONS;
----------------------------------------------------------------------------------------------------
PROCEDURE LIST_GAS_TRANSACTIONS
	(
	p_SEARCH_STRING IN VARCHAR,
	p_SEARCH_BY_ALIAS IN NUMBER,
	p_INCLUDE_INACTIVE IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	)
	AS

-- Answer the given entities

BEGIN

--Make sure user has appropriate access.

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

p_STATUS := GA.SUCCESS;

IF p_SEARCH_STRING = '%' OR p_SEARCH_STRING IS NULL THEN

	OPEN p_CURSOR FOR
	SELECT
		A.TRANSACTION_NAME "ENTITY_NAME",
		A.TRANSACTION_ID "ENTITY_ID",
		A.TRANSACTION_ALIAS "ENTITY_ALIAS",
		B.TRANSACTION_STATUS_NAME "ENTITY_STATUS"
	FROM INTERCHANGE_TRANSACTION A,
    	IT_STATUS B
    WHERE A.BEGIN_DATE <= p_END_DATE -- filter by dates
    	AND NVL(A.END_DATE,HIGH_DATE) >= p_BEGIN_DATE
    	AND NVL(A.MODEL_ID,1) = 2 -- don't get Electric transactions
    	AND B.TRANSACTION_ID = A.TRANSACTION_ID -- join for status
    	AND B.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
        					FROM IT_STATUS
                            WHERE TRANSACTION_ID = B.TRANSACTION_ID
                            	AND AS_OF_DATE <= SYSDATE)
	ORDER BY DECODE(p_SEARCH_BY_ALIAS, 0, TRANSACTION_NAME, TRANSACTION_ALIAS);

ELSE

	OPEN p_CURSOR FOR
	SELECT
		A.TRANSACTION_NAME "ENTITY_NAME",
		A.TRANSACTION_ID "ENTITY_ID",
		A.TRANSACTION_ALIAS "ENTITY_ALIAS",
		B.TRANSACTION_STATUS_NAME "ENTITY_STATUS"
	FROM INTERCHANGE_TRANSACTION A,
    	IT_STATUS B
	WHERE A.BEGIN_DATE <= p_END_DATE -- filter by dates
    	AND NVL(A.END_DATE,HIGH_DATE) >= p_BEGIN_DATE
        AND (p_SEARCH_BY_ALIAS = 1 OR TRANSACTION_NAME LIKE p_SEARCH_STRING)
		AND (p_SEARCH_BY_ALIAS = 0 OR TRANSACTION_ALIAS LIKE p_SEARCH_STRING)
		AND NVL(A.MODEL_ID,1) = 2 -- don't get Electric transactions
    	AND B.TRANSACTION_ID = A.TRANSACTION_ID -- join for status
    	AND B.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
        					FROM IT_STATUS
                            WHERE TRANSACTION_ID = B.TRANSACTION_ID
                            	AND AS_OF_DATE <= SYSDATE)
	ORDER BY DECODE(p_SEARCH_BY_ALIAS, 0, TRANSACTION_NAME, TRANSACTION_ALIAS);

END IF;

	EXCEPTION
		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END LIST_GAS_TRANSACTIONS;
----------------------------------------------------------------------------------------------------
PROCEDURE BALANCE_TRANSACTIONS
	(
	p_TRANSACTION_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
    ) AS
BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

   OPEN p_CURSOR FOR
		SELECT A.TRANSACTION_ID,
        	A.BALANCE_TRANSACTION_ID,
            B.TRANSACTION_NAME "BALANCE_TRANSACTION_NAME",
	        A.BEGIN_DATE,
			A.END_DATE,
			A.ENTRY_DATE
		FROM BALANCE_TRANSACTION A, INTERCHANGE_TRANSACTION B
		WHERE A.TRANSACTION_ID = p_TRANSACTION_ID
        	AND B.TRANSACTION_ID = A.BALANCE_TRANSACTION_ID
		ORDER BY A.BEGIN_DATE, A.ENTRY_DATE;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END BALANCE_TRANSACTIONS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_BALANCE_TRANSACTION
	(
    p_TRANSACTION_ID IN NUMBER,
    p_BALANCE_TRANSACTION_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
	p_OLD_BALANCE_TRANSACTION_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	P_STATUS OUT NUMBER
    ) AS

v_END_DATE DATE;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- UPDATE THE CURRENT BALANCE TRANSACTION ASSIGNMENT IF ONE EXISTS

	UPDATE BALANCE_TRANSACTION SET
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		ENTRY_DATE = SYSDATE,
		BALANCE_TRANSACTION_ID = p_BALANCE_TRANSACTION_ID
	WHERE TRANSACTION_ID = p_TRANSACTION_ID
		AND BALANCE_TRANSACTION_ID = p_OLD_BALANCE_TRANSACTION_ID
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS BALANCE TRANSACTION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO BALANCE_TRANSACTION
			(
			TRANSACTION_ID,
			BALANCE_TRANSACTION_ID,
			BEGIN_DATE,
			END_DATE,
			ENTRY_DATE
			)
		VALUES
			(
			p_TRANSACTION_ID,
			p_BALANCE_TRANSACTION_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			SYSDATE
			);
	END IF;

	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			p_STATUS := GA.DUPLICATE_ENTITY;
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		WHEN OTHERS THEN
			RAISE;

END PUT_BALANCE_TRANSACTION;
----------------------------------------------------------------------------------------------------
PROCEDURE BALANCING_TRANSACTIONS
	(
	p_TRANSACTION_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
    ) AS
BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

   OPEN p_CURSOR FOR
		SELECT A.BALANCE_TRANSACTION_ID "TRANSACTION_ID",
        	A.TRANSACTION_ID "BALANCING_TRANSACTION_ID",
            B.TRANSACTION_NAME "BALANCING_TRANSACTION_NAME",
	        A.BEGIN_DATE,
			A.END_DATE,
			A.ENTRY_DATE
		FROM BALANCE_TRANSACTION A, INTERCHANGE_TRANSACTION B
		WHERE A.BALANCE_TRANSACTION_ID = p_TRANSACTION_ID
        	AND B.TRANSACTION_ID = A.TRANSACTION_ID
		ORDER BY A.BEGIN_DATE, A.ENTRY_DATE;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END BALANCING_TRANSACTIONS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_BALANCING_TRANSACTION
	(
    p_TRANSACTION_ID IN NUMBER,
    p_BALANCING_TRANSACTION_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
	p_OLD_BALANCING_TRANSACTION_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	P_STATUS OUT NUMBER
    ) AS

v_END_DATE DATE;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- UPDATE THE CURRENT BALANCE TRANSACTION ASSIGNMENT IF ONE EXISTS

	UPDATE BALANCE_TRANSACTION SET
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		ENTRY_DATE = SYSDATE,
		TRANSACTION_ID = p_BALANCING_TRANSACTION_ID
	WHERE TRANSACTION_ID = p_OLD_BALANCING_TRANSACTION_ID
		AND BALANCE_TRANSACTION_ID = p_TRANSACTION_ID
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS BALANCE TRANSACTION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO BALANCE_TRANSACTION
			(
			TRANSACTION_ID,
			BALANCE_TRANSACTION_ID,
			BEGIN_DATE,
			END_DATE,
			ENTRY_DATE
			)
		VALUES
			(
			p_BALANCING_TRANSACTION_ID,
			p_TRANSACTION_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			SYSDATE
			);
	END IF;

	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			p_STATUS := GA.DUPLICATE_ENTITY;
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		WHEN OTHERS THEN
			RAISE;

END PUT_BALANCING_TRANSACTION;
----------------------------------------------------------------------------------------------------
PROCEDURE ETAG_DETAILS
	(
	p_TRANSACTION_ID IN NUMBER,
	p_STATUS OUT NUMBER,
    p_CURSOR IN OUT REF_CURSOR
	) AS
	
BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT 
			T.TRANSACTION_ID,
			ETX.ETAG_ID,
			E.TAG_IDENT
		FROM ETAG_TRANSACTION ETX, INTERCHANGE_TRANSACTION T, ETAG E
		WHERE ETX.TRANSACTION_ID = p_TRANSACTION_ID
			AND T.TRANSACTION_ID = ETX.TRANSACTION_ID
			AND E.ETAG_ID = ETX.ETAG_ID;

EXCEPTION
	WHEN INSUFFICIENT_PRIVILEGES THEN
		p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END ETAG_DETAILS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ETAG_DETAIL
	(
	p_TRANSACTION_ID IN NUMBER,
    p_ETAG_ID IN NUMBER,
    p_OLD_ETAG_ID  IN NUMBER,
    p_STATUS OUT NUMBER
	) AS
	
BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	-- UPDATE THE CURRENT ASSIGNMENT IF ONE EXISTS
	UPDATE ETAG_TRANSACTION SET
        ETAG_ID  = p_ETAG_ID
	 WHERE TRANSACTION_ID = p_TRANSACTION_ID
        AND ETAG_ID = p_OLD_ETAG_ID;

	-- NO ASSIGNMENT UPDATE FOR THIS PATH/SEGMENT COMBINATION SO INSERT A NEW ASSIGNMENT
	IF SQL%NOTFOUND THEN
		INSERT INTO ETAG_TRANSACTION
            (
            TRANSACTION_ID,
            ETAG_ID
            )
		VALUES
            (
			p_TRANSACTION_ID,
            p_ETAG_ID
            );
	END IF;

EXCEPTION
	WHEN DUP_VAL_ON_INDEX THEN
		p_STATUS := GA.DUPLICATE_ENTITY;
	WHEN INSUFFICIENT_PRIVILEGES THEN
		p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	WHEN OTHERS THEN
		RAISE;
END PUT_ETAG_DETAIL;
----------------------------------------------------------------------------------------------------
PROCEDURE MKT_PATH_MKT_SEGS(p_MARKET_PATH_ID IN NUMBER,
																			p_STATUS         OUT NUMBER,
																			p_CURSOR         IN OUT REF_CURSOR) AS
BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	OPEN p_CURSOR FOR
		SELECT MARKET_SEGMENT_ID, SEGMENT_ORDER
			FROM MKT_PATH_MKT_SEG
		 WHERE MARKET_PATH_ID = p_MARKET_PATH_ID
		 ORDER BY SEGMENT_ORDER;

	p_STATUS := GA.SUCCESS;

EXCEPTION
	WHEN INSUFFICIENT_PRIVILEGES THEN
		p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END MKT_PATH_MKT_SEGS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_MKT_PATH_MKT_SEG(p_MARKET_PATH_ID        IN NUMBER,
																				 p_MARKET_SEGMENT_ID     IN NUMBER,
																				 p_SEGMENT_ORDER         IN NUMBER,
																				 p_OLD_MARKET_SEGMENT_ID IN NUMBER,
																				 p_OLD_SEGMENT_ORDER     IN NUMBER,
																				 p_STATUS                OUT NUMBER) AS
BEGIN
	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	-- UPDATE THE CURRENT ASSIGNMENT IF ONE EXISTS
	UPDATE MKT_PATH_MKT_SEG
		 SET MARKET_SEGMENT_ID = p_MARKET_SEGMENT_ID,
				 SEGMENT_ORDER     = p_SEGMENT_ORDER
	 WHERE MARKET_PATH_ID = p_MARKET_PATH_ID
		 AND MARKET_SEGMENT_ID = p_OLD_MARKET_SEGMENT_ID
		 AND SEGMENT_ORDER = p_OLD_SEGMENT_ORDER;

	-- NO ASSIGNMENT UPDATE FOR THIS PATH/SEGMENT COMBINATION SO INSERT A NEW ASSIGNMENT
	IF SQL%NOTFOUND THEN
		INSERT INTO MKT_PATH_MKT_SEG
			(MARKET_PATH_ID, MARKET_SEGMENT_ID, SEGMENT_ORDER)
		VALUES
			(p_MARKET_PATH_ID, p_MARKET_SEGMENT_ID, p_SEGMENT_ORDER);
	END IF;

EXCEPTION
	WHEN DUP_VAL_ON_INDEX THEN
		p_STATUS := GA.DUPLICATE_ENTITY;
	WHEN INSUFFICIENT_PRIVILEGES THEN
		p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	WHEN OTHERS THEN
		RAISE;
END PUT_MKT_PATH_MKT_SEG;
----------------------------------------------------------------------------------------------------
PROCEDURE MKT_SEG_PHYS_SEGS(p_MARKET_SEGMENT_ID IN NUMBER,
																	 p_STATUS            OUT NUMBER,
																	 p_CURSOR            IN OUT REF_CURSOR) AS
BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	OPEN p_CURSOR FOR
		SELECT PHYSICAL_SEGMENT_ID, SEGMENT_ORDER
			FROM MKT_SEG_PHYS_SEG
		 WHERE MARKET_SEGMENT_ID = p_MARKET_SEGMENT_ID
		 ORDER BY SEGMENT_ORDER;

	p_STATUS := GA.SUCCESS;

EXCEPTION
	WHEN INSUFFICIENT_PRIVILEGES THEN
		p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END MKT_SEG_PHYS_SEGS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_MKT_SEG_PHYS_SEG(p_MARKET_SEGMENT_ID       IN NUMBER,
																			p_PHYSICAL_SEGMENT_ID     IN NUMBER,
																			p_SEGMENT_ORDER           IN NUMBER,
																			p_OLD_PHYSICAL_SEGMENT_ID IN NUMBER,
																			p_OLD_SEGMENT_ORDER       IN NUMBER,
																			p_STATUS                  OUT NUMBER) AS
BEGIN
	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	-- UPDATE THE CURRENT ASSIGNMENT IF ONE EXISTS
	UPDATE MKT_SEG_PHYS_SEG
		 SET PHYSICAL_SEGMENT_ID = p_PHYSICAL_SEGMENT_ID,
				 SEGMENT_ORDER       = p_SEGMENT_ORDER
	 WHERE MARKET_SEGMENT_ID = p_MARKET_SEGMENT_ID
		 AND PHYSICAL_SEGMENT_ID = p_OLD_PHYSICAL_SEGMENT_ID
		 AND SEGMENT_ORDER = p_OLD_SEGMENT_ORDER;

	-- NO ASSIGNMENT UPDATE FOR THIS MARKET SEGMENT/PHYSICAL SEGMENT COMBINATION SO INSERT A NEW ASSIGNMENT
	IF SQL%NOTFOUND THEN
		INSERT INTO MKT_SEG_PHYS_SEG
			(MARKET_SEGMENT_ID, PHYSICAL_SEGMENT_ID, SEGMENT_ORDER)
		VALUES
			(p_MARKET_SEGMENT_ID, p_PHYSICAL_SEGMENT_ID, p_SEGMENT_ORDER);
	END IF;

EXCEPTION
	WHEN DUP_VAL_ON_INDEX THEN
		p_STATUS := GA.DUPLICATE_ENTITY;
	WHEN INSUFFICIENT_PRIVILEGES THEN
		p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	WHEN OTHERS THEN
		RAISE;
END PUT_MKT_SEG_PHYS_SEG;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_IT_TRANSPORTATION_PATH
	(
	p_TRANSACTION_ID IN NUMBER,
	p_TRANSPORTATION_PATH_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ALLOCATION IN NUMBER,
	p_IS_PERCENT IN NUMBER,
  p_OLD_TRANSPORTATION_PATH_ID IN NUMBER,
  p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	UPDATE IT_TRANSPORTATION_PATH SET
    TRANSPORTATION_PATH_ID = p_TRANSPORTATION_PATH_ID,
		BEGIN_DATE = p_BEGIN_DATE,
		END_DATE = p_END_DATE,
		ALLOCATION = p_ALLOCATION,
		IS_PERCENT= p_IS_PERCENT,
		ENTRY_DATE = SYSDATE
	WHERE TRANSACTION_ID = p_TRANSACTION_ID
		AND TRANSPORTATION_PATH_ID = p_OLD_TRANSPORTATION_PATH_ID
		AND BEGIN_DATE = p_OLD_BEGIN_DATE;

	IF SQL%NOTFOUND THEN
		INSERT INTO IT_TRANSPORTATION_PATH (
			TRANSACTION_ID,
			TRANSPORTATION_PATH_ID,
			BEGIN_DATE,
			END_DATE,
			ALLOCATION,
			IS_PERCENT,
			ENTRY_DATE)
		VALUES (
			p_TRANSACTION_ID,
			p_TRANSPORTATION_PATH_ID,
			p_BEGIN_DATE,
			p_END_DATE,
			p_ALLOCATION,
			p_IS_PERCENT,
			SYSDATE);
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END PUT_IT_TRANSPORTATION_PATH;
----------------------------------------------------------------------------------------------------
PROCEDURE IT_TRANSPORTATION_PATHS
	(
	p_TRANSACTION_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT A.TRANSACTION_ID, A.TRANSPORTATION_PATH_ID, A.BEGIN_DATE, A.END_DATE, A.ALLOCATION, A.IS_PERCENT
		FROM IT_TRANSPORTATION_PATH A
		WHERE A.TRANSACTION_ID = p_TRANSACTION_ID
		ORDER BY BEGIN_DATE;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END IT_TRANSPORTATION_PATHS;
----------------------------------------------------------------------------------------------------
PROCEDURE BALANCE_SUPPLY_TRANSACTIONS
	(
	p_COMMODITY_ID IN NUMBER,
	p_INTERVAL IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT A.TRANSACTION_NAME, A.TRANSACTION_ID
		FROM INTERCHANGE_TRANSACTION A,
			IT_COMMODITY B,
			IT_COMMODITY C
		WHERE A.BEGIN_DATE <= NVL(p_END_DATE,A.BEGIN_DATE)
			AND A.END_DATE >= NVL(p_BEGIN_DATE,A.END_DATE)
			AND A.TRANSACTION_INTERVAL = p_INTERVAL
			AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) IN ('PU','GE')
			AND B.COMMODITY_ID = A.COMMODITY_ID
			AND C.COMMODITY_ID = p_COMMODITY_ID
			AND C.COMMODITY_TYPE = B.COMMODITY_TYPE
		ORDER BY A.TRANSACTION_NAME;
END BALANCE_SUPPLY_TRANSACTIONS;
----------------------------------------------------------------------------------------------------
PROCEDURE BALANCE_LOAD_TRANSACTIONS
	(
	p_COMMODITY_ID IN NUMBER,
	p_INTERVAL IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT A.TRANSACTION_NAME, A.TRANSACTION_ID
		FROM INTERCHANGE_TRANSACTION A,
			IT_COMMODITY B,
			IT_COMMODITY C
		WHERE A.BEGIN_DATE <= NVL(p_END_DATE,A.BEGIN_DATE)
			AND A.END_DATE >= NVL(p_BEGIN_DATE,A.END_DATE)
			AND A.TRANSACTION_INTERVAL = p_INTERVAL
			AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) IN ('LO','SA')
            AND NVL(A.IS_BALANCE_TRANSACTION,0) = 1
			AND B.COMMODITY_ID = A.COMMODITY_ID
			AND C.COMMODITY_ID = p_COMMODITY_ID
			AND C.COMMODITY_TYPE = B.COMMODITY_TYPE
		ORDER BY A.TRANSACTION_NAME;
END BALANCE_LOAD_TRANSACTIONS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SHOW_FIND_FOR_ENTITY
	(
	p_MODEL_ID IN NUMBER,
    p_ENTITY_DOMAIN_ALIAS IN VARCHAR2,
    p_VALUE OUT VARCHAR2,
	p_STATUS OUT NUMBER
	) AS

-- Answer the SYSTEM_DICTIONARY value for the given ENTITY NAME

BEGIN
    p_STATUS := GA.SUCCESS;

	p_VALUE := MODEL_VALUE_AT_KEY(p_MODEL_ID, 'Entity Manager', g_SHOW_FIND_IN_TREE, p_ENTITY_DOMAIN_ALIAS, 0);

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;
            RAISE;
END GET_SHOW_FIND_FOR_ENTITY;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_HOLIDAY_OBSERVANCE
	(
	p_HOLIDAY_ID IN NUMBER,
	p_HOLIDAY_YEAR IN NUMBER,
	p_HOLIDAY_DATE IN DATE,
	p_OLD_HOLIDAY_YEAR IN NUMBER,
	p_STATUS OUT NUMBER
	) AS
BEGIN
	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
-- UPDATE AN EXISTING RECORD
	p_STATUS := GA.SUCCESS;
	UPDATE HOLIDAY_OBSERVANCE SET
		HOLIDAY_DATE = TRUNC(p_HOLIDAY_DATE),
		HOLIDAY_YEAR = p_HOLIDAY_YEAR,
		ENTRY_DATE = SYSDATE
	WHERE HOLIDAY_ID = p_HOLIDAY_ID
		AND HOLIDAY_YEAR = p_OLD_HOLIDAY_YEAR;
-- IF THE PREVIOUS UPDATE DID NOT FIND A MATCH, THEN INSERT A NEW RECORD
	IF SQL%NOTFOUND THEN
		INSERT INTO HOLIDAY_OBSERVANCE (
			HOLIDAY_ID,
			HOLIDAY_YEAR,
			HOLIDAY_DATE,
			ENTRY_DATE)
		VALUES (
			p_HOLIDAY_ID,
			p_HOLIDAY_YEAR,
			TRUNC(p_HOLIDAY_DATE),
			SYSDATE);
	END IF;
	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
			RETURN;
		WHEN OTHERS THEN
			p_STATUS := GA.GENERAL_EXCEPTION;
			RAISE;
END PUT_HOLIDAY_OBSERVANCE;
----------------------------------------------------------------------------------------------------
PROCEDURE HOLIDAY_OBSERVANCES
	(
	p_HOLIDAY_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS
-- ANSWER THE HOLIDAY YEAR AND DATE FOR THE APPROPRIATE HOLIDAY
BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		  SELECT HOLIDAY_YEAR, HOLIDAY_DATE, ENTRY_DATE
		  FROM HOLIDAY_OBSERVANCE
		  WHERE HOLIDAY_ID = p_HOLIDAY_ID
		  ORDER BY HOLIDAY_YEAR;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;
END HOLIDAY_OBSERVANCES;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_HOLIDAY_SET_EDC
	(
	p_HOLIDAY_SET_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_IS_SELECTED IN NUMBER,
	p_STATUS OUT NUMBER
	)
	AS

v_HOLIDAY_SET_ID NUMBER(9);
BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

-- UPDATE THE CURRENT EDC TO BE ASSIGNED OR NOT TO THE SET.

	IF p_IS_SELECTED = 0 THEN
		v_HOLIDAY_SET_ID := 0;
	ELSE
		v_HOLIDAY_SET_ID := p_HOLIDAY_SET_ID;
	END IF;

	UPDATE ENERGY_DISTRIBUTION_COMPANY
	SET EDC_HOLIDAY_SET_ID = v_HOLIDAY_SET_ID
	WHERE EDC_ID = p_EDC_ID;

	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			p_STATUS := GA.DUPLICATE_ENTITY;
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		WHEN OTHERS THEN
			RAISE;
END PUT_HOLIDAY_SET_EDC;
---------------------------------------------------------------------------------------------------

PROCEDURE HOLIDAY_SET_EDCS
	(
	p_HOLIDAY_SET_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

-- Answer the HOLIDAYS for the given SET.

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		  SELECT EDC_ID,
		  		EDC_NAME,
				DECODE(EDC_HOLIDAY_SET_ID, p_HOLIDAY_SET_ID, 1, 0) AS IS_SELECTED
		  FROM ENERGY_DISTRIBUTION_COMPANY
		  WHERE EDC_ID > 0
		  ORDER BY 3 DESC, 2 ASC;


	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END HOLIDAY_SET_EDCS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_INCLUDED_HOLIDAY
	(
	p_HOLIDAY_SET_ID IN NUMBER,
	p_HOLIDAY_ID IN NUMBER,
	p_IS_SELECTED IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	--DELETE THE CURRENT ASSIGNMENT IF NOT SELECTED.
	IF p_IS_SELECTED = 0 THEN
		DELETE FROM HOLIDAY_SCHEDULE
		WHERE HOLIDAY_SET_ID = p_HOLIDAY_SET_ID
			AND HOLIDAY_ID = p_HOLIDAY_ID;
	ELSE

		UPDATE HOLIDAY_SCHEDULE SET
			HOLIDAY_ID = p_HOLIDAY_ID
		WHERE HOLIDAY_SET_ID = p_HOLIDAY_SET_ID
			AND HOLIDAY_ID = p_HOLIDAY_ID;


		IF SQL%NOTFOUND THEN
			INSERT INTO HOLIDAY_SCHEDULE
				(
				HOLIDAY_SET_ID,
				HOLIDAY_ID
				)
			VALUES
				(
				p_HOLIDAY_SET_ID,
				p_HOLIDAY_ID
				);
		END IF;
	END IF;

	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			p_STATUS := GA.DUPLICATE_ENTITY;
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		WHEN OTHERS THEN
			RAISE;
END PUT_INCLUDED_HOLIDAY;
---------------------------------------------------------------------------------------------------
PROCEDURE INCLUDED_HOLIDAYS
	(
	p_HOLIDAY_SET_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

-- Answer the HOLIDAYS for the given SET.

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    p_STATUS := GA.SUCCESS;

	IF p_HOLIDAY_SET_ID = 0 THEN
		OPEN p_CURSOR FOR
			  SELECT HOLIDAY_ID, HOLIDAY_NAME, 0 AS IS_SELECTED
			  FROM HOLIDAY
			  ORDER BY 2 ASC;
	ELSE
		OPEN p_CURSOR FOR
		    SELECT A.HOLIDAY_ID,
		    	B.HOLIDAY_NAME,
		    	1 AS IS_SELECTED
			FROM HOLIDAY_SCHEDULE A, HOLIDAY B
			WHERE A.HOLIDAY_SET_ID = p_HOLIDAY_SET_ID
				AND A.HOLIDAY_ID = B.HOLIDAY_ID

			UNION

			SELECT HOLIDAY_ID,
				HOLIDAY_NAME,
				0 AS IS_SELECTED
			FROM HOLIDAY
			WHERE NOT HOLIDAY_ID IN (SELECT HOLIDAY_ID
										FROM HOLIDAY_SCHEDULE
										WHERE HOLIDAY_SET_ID = p_HOLIDAY_SET_ID)
			ORDER BY 3 DESC, 2 ASC;

	END IF;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END INCLUDED_HOLIDAYS;
---------------------------------------------------------------------------------------------------
PROCEDURE HOLIDAY_SCHEDULES
	(
	p_HOLIDAY_SET_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS
BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		  SELECT B.HOLIDAY_NAME,
				C.HOLIDAY_YEAR,
				TO_CHAR(C.HOLIDAY_DATE, 'MM/DD') "HOLIDAY_DATE"
		  FROM HOLIDAY B, HOLIDAY_OBSERVANCE C, HOLIDAY_SCHEDULE D
		  WHERE D.HOLIDAY_SET_ID = p_HOLIDAY_SET_ID
		  	  AND B.HOLIDAY_ID = D.HOLIDAY_ID
			  AND C.HOLIDAY_ID = B.HOLIDAY_ID
		  ORDER BY 1,2,3;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;
END HOLIDAY_SCHEDULES;
---------------------------------------------------------------------------------------------------

PROCEDURE PUT_PRODUCT_COMPONENT
	(
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
  p_OLD_COMPONENT_ID IN NUMBER,
  p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	UPDATE PRODUCT_COMPONENT SET
    COMPONENT_ID = p_COMPONENT_ID,
		BEGIN_DATE = p_BEGIN_DATE,
		END_DATE = p_END_DATE,
		ENTRY_DATE = SYSDATE
	WHERE PRODUCT_ID = p_PRODUCT_ID
		AND COMPONENT_ID = p_OLD_COMPONENT_ID
		AND BEGIN_DATE = p_OLD_BEGIN_DATE;

	IF SQL%NOTFOUND THEN
		INSERT INTO PRODUCT_COMPONENT (
			PRODUCT_ID,
			COMPONENT_ID,
			BEGIN_DATE,
			END_DATE,
			ENTRY_DATE)
		VALUES (
			p_PRODUCT_ID,
			p_COMPONENT_ID,
			p_BEGIN_DATE,
			p_END_DATE,
			SYSDATE);
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END PUT_PRODUCT_COMPONENT;

----------------------------------------------------------------------------------------------------
PROCEDURE PRODUCT_COMPONENTS
	(
	p_PRODUCT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT A.PRODUCT_ID, A.COMPONENT_ID, A.BEGIN_DATE, A.END_DATE, A.ENTRY_DATE
		FROM PRODUCT_COMPONENT A
		WHERE A.PRODUCT_ID = p_PRODUCT_ID
		ORDER BY BEGIN_DATE;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END PRODUCT_COMPONENTS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_COMPONENT_PERCENTAGE
	(
	p_COMPONENT_ID IN NUMBER,
	p_SUB_COMPONENT_TYPE IN VARCHAR2,
	p_SUB_COMPONENT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PERCENT_VAL IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	)AS
CURSOR c_COMPONENT_PERCENTAGE IS
	SELECT *
	FROM COMPONENT_PERCENTAGE
	WHERE COMPONENT_ID = p_COMPONENT_ID
	ORDER BY BEGIN_DATE DESC;
v_COMPONENT_PERCENTAGE COMPONENT_PERCENTAGE%ROWTYPE;
v_INITIAL BOOLEAN;
v_END_DATE DATE;
BEGIN
	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- UPDATE THE CURRENT RATE ASSIGNMENT IF ONE EXISTS
	UPDATE COMPONENT_PERCENTAGE SET
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		PERCENT_VAL = NVL(p_PERCENT_VAL,0),
		ENTRY_DATE = SYSDATE
	WHERE COMPONENT_ID = p_COMPONENT_ID
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS COMBINATION SO INSERT A NEW ASSIGNMENT
	IF SQL%NOTFOUND THEN
		INSERT INTO COMPONENT_PERCENTAGE
			(
			COMPONENT_ID,
			BEGIN_DATE,
			END_DATE,
			PERCENT_VAL,
			ENTRY_DATE
			)
		VALUES
			(
			p_COMPONENT_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			NVL(p_PERCENT_VAL,0),
			SYSDATE
			);
	END IF;
	OPEN c_COMPONENT_PERCENTAGE;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_COMPONENT_PERCENTAGE INTO v_COMPONENT_PERCENTAGE;
		EXIT WHEN c_COMPONENT_PERCENTAGE%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_COMPONENT_PERCENTAGE.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE COMPONENT_PERCENTAGE
		SET END_DATE = GREATEST(v_END_DATE, v_COMPONENT_PERCENTAGE.BEGIN_DATE)
		WHERE COMPONENT_ID = v_COMPONENT_PERCENTAGE.COMPONENT_ID
			AND BEGIN_DATE = v_COMPONENT_PERCENTAGE.BEGIN_DATE;
		v_END_DATE := v_COMPONENT_PERCENTAGE.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_COMPONENT_PERCENTAGE;
	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			p_STATUS := GA.DUPLICATE_ENTITY;
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		WHEN OTHERS THEN
			RAISE;
END PUT_COMPONENT_PERCENTAGE;
----------------------------------------------------------------------------------------------------
PROCEDURE COMPONENT_PERCENTAGES
	(
	p_COMPONENT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT A.COMPONENT_ID, A.PERCENT_VAL, A.BEGIN_DATE, A.END_DATE, A.ENTRY_DATE
		FROM COMPONENT_PERCENTAGE A
		WHERE A.COMPONENT_ID = p_COMPONENT_ID
		ORDER BY BEGIN_DATE;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END COMPONENT_PERCENTAGES;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_MARKET_FORWARD_PRICE
	(
	p_MARKET_PRICE_ID IN NUMBER,
	p_CONTRACT_MONTH IN DATE,
	p_CONTRACT_TYPE IN CHAR,
	p_CONTRACT_DATE IN DATE,
	p_BID_PRICE IN NUMBER,
	p_ASK_PRICE IN NUMBER,
	p_LOW_PRICE IN NUMBER,
	p_HIGH_PRICE IN NUMBER,
	p_OLD_CONTRACT_MONTH IN DATE,
	p_OLD_CONTRACT_TYPE IN CHAR,
	p_OLD_CONTRACT_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS
BEGIN
	PR.PUT_MARKET_FORWARD_PRICE(p_MARKET_PRICE_ID,p_CONTRACT_MONTH,p_CONTRACT_TYPE,
    						p_CONTRACT_DATE,p_BID_PRICE,p_ASK_PRICE,p_LOW_PRICE,p_HIGH_PRICE,
                            p_OLD_CONTRACT_MONTH,p_OLD_CONTRACT_TYPE,p_OLD_CONTRACT_DATE,p_STATUS);
END PUT_MARKET_FORWARD_PRICE;
----------------------------------------------------------------------------------------------------
PROCEDURE MARKET_FORWARD_PRICES
	(
	p_MARKET_PRICE_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS
-- ANSWER THE APPROPRIATE ENTRIES IN MARKET_FORWARD_PRICE TABLE.
BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT MARKET_PRICE_ID,
		  	 CONTRACT_MONTH,
			 CONTRACT_TYPE,
			 CONTRACT_DATE,
			 BID_PRICE,
			 ASK_PRICE,
			 LOW_PRICE,
			 HIGH_PRICE,
			 ENTRY_DATE
		FROM MARKET_FORWARD_PRICE
	   WHERE MARKET_PRICE_ID = p_MARKET_PRICE_ID
		ORDER BY CONTRACT_MONTH, CONTRACT_DATE, CONTRACT_TYPE;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;
END MARKET_FORWARD_PRICES;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_MARKET_PRICE_COMPOSITE
	(
	p_MARKET_PRICE_ID IN NUMBER,
	p_COMPOSITE_PRICE_ID IN NUMBER,
	p_COMPOSITE_MULTIPLIER IN NUMBER,
	p_COMPOSITE_OPTION IN VARCHAR,
	p_OLD_COMPOSITE_PRICE_ID IN NUMBER,
	p_STATUS OUT NUMBER
	) AS
BEGIN
	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
-- UPDATE AN EXISTING RECORD
	p_STATUS := GA.SUCCESS;
	UPDATE MARKET_PRICE_COMPOSITE SET
		COMPOSITE_MARKET_PRICE_ID = p_COMPOSITE_PRICE_ID,
		COMPOSITE_MULTIPLIER = NVL(p_COMPOSITE_MULTIPLIER,1),
		COMPOSITE_OPTION = NVL(p_COMPOSITE_OPTION,GA.UNDEFINED_ATTRIBUTE)
	WHERE MARKET_PRICE_ID = p_MARKET_PRICE_ID
		AND COMPOSITE_MARKET_PRICE_ID = p_OLD_COMPOSITE_PRICE_ID;
-- IF THE PREVIOUS UPDATE DID NOT FIND A MATCH, THEN INSERT A NEW RECORD
	IF SQL%NOTFOUND THEN
		INSERT INTO MARKET_PRICE_COMPOSITE (
			MARKET_PRICE_ID,
			COMPOSITE_MARKET_PRICE_ID,
			COMPOSITE_MULTIPLIER,
			COMPOSITE_OPTION)
		VALUES (
			p_MARKET_PRICE_ID,
			p_COMPOSITE_PRICE_ID,
			NVL(p_COMPOSITE_MULTIPLIER,1),
			NVL(p_COMPOSITE_OPTION,GA.UNDEFINED_ATTRIBUTE));
	END IF;
	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
			RETURN;
		WHEN OTHERS THEN
			p_STATUS := GA.GENERAL_EXCEPTION;
			RAISE;
END PUT_MARKET_PRICE_COMPOSITE;
----------------------------------------------------------------------------------------------------
PROCEDURE MARKET_PRICE_COMPOSITES
	(
	p_MARKET_PRICE_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS
-- ANSWER THE MARKET_PRICE_ID, NAME, MULTIPLIER, AND OPTION OF THE APPROPRIATE ENTRIES IN MARKET_PRICE_COMPOSITE
BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
    p_STATUS := GA.SUCCESS;
	OPEN p_CURSOR FOR
		SELECT A.COMPOSITE_MARKET_PRICE_ID "COMPOSITE_PRICE_ID",
        	A.COMPOSITE_MULTIPLIER,
			A.COMPOSITE_OPTION,
            B.MARKET_PRICE_NAME AS COMPOSITE_PRICE_NAME
		FROM MARKET_PRICE_COMPOSITE A, MARKET_PRICE B
		WHERE A.MARKET_PRICE_ID = p_MARKET_PRICE_ID
			AND A.COMPOSITE_MARKET_PRICE_ID = B.MARKET_PRICE_ID
		ORDER BY COMPOSITE_PRICE_NAME;
	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;
END MARKET_PRICE_COMPOSITES;
---------------------------------------------------------------------------------------------------
PROCEDURE NON_COMPOSITE_MARKET_PRICES
	(
    p_STATUS OUT NUMBER,
    p_CURSOR IN OUT REF_CURSOR
    ) AS
BEGIN
	p_STATUS := GA.SUCCESS;
	OPEN p_CURSOR FOR
    	SELECT MARKET_PRICE_NAME, MARKET_PRICE_ID
		FROM MARKET_PRICE
        WHERE UPPER(SUBSTR(MARKET_PRICE_TYPE,1,9)) <> 'COMPOSITE'
        ORDER BY 2,1;
EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;
END NON_COMPOSITE_MARKET_PRICES;
---------------------------------------------------------------------------------------------------
PROCEDURE GEOGRAPHY_PARENT_LIST
	(
    p_GEOGRAPHY_TYPE IN VARCHAR2,
    p_STATUS OUT NUMBER,
    p_CURSOR IN OUT REF_CURSOR
    ) AS
BEGIN
	p_STATUS := GA.SUCCESS;
	OPEN p_CURSOR FOR
    	SELECT DISTINCT GEOGRAPHY_NAME, GEOGRAPHY_ID
		FROM GEOGRAPHY A,
        	SYSTEM_LABEL B
        WHERE B.POSITION < (SELECT POSITION FROM SYSTEM_LABEL
        					WHERE MODEL_ID = 0
                            	AND MODULE = 'Product'
                                AND KEY1 = 'Geography'
                                AND KEY2 = 'Geography Types'
                                AND KEY3 = '?'
                                AND UPPER(VALUE) = UPPER(p_GEOGRAPHY_TYPE))
			AND A.GEOGRAPHY_TYPE = B.VALUE
        ORDER BY 2,1;
EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;
END GEOGRAPHY_PARENT_LIST;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_ADDRESS
	(
	o_OID OUT NUMBER,
	p_ADDRESS_NAME IN VARCHAR2,
	p_ADDRESS_ALIAS IN VARCHAR2,
	p_ADDRESS_DESC IN VARCHAR2,
	p_ADDRESS_ID IN NUMBER,
	p_STREET IN VARCHAR2,
    p_CITY IN VARCHAR2,
    p_STATE_CODE IN VARCHAR2,
    p_POSTAL_CODE IN VARCHAR2,
    p_COUNTRY_CODE IN VARCHAR2,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2
    ) AS
v_GEOGRAPHY_ID NUMBER;
BEGIN
	-- translate parameters into a Geography ID
    ID.ID_FOR_GEOGRAPHY(p_CITY,p_STATE_CODE,p_POSTAL_CODE,p_COUNTRY_CODE,TRUE,v_GEOGRAPHY_ID);
    -- store it
	IO.PUT_ADDRESS(o_OID,p_ADDRESS_NAME,p_ADDRESS_ALIAS,p_ADDRESS_DESC,
    				p_ADDRESS_ID,p_STREET,v_GEOGRAPHY_ID,p_EXTERNAL_IDENTIFIER);
END PUT_ADDRESS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_ADDRESS
	(
	p_ADDRESS_ID IN NUMBER,
	p_ADDRESS_NAME OUT VARCHAR2,
	p_ADDRESS_ALIAS OUT VARCHAR2,
	p_ADDRESS_DESC OUT VARCHAR2,
	p_STREET OUT VARCHAR2,
    p_CITY OUT VARCHAR2,
    p_STATE_CODE OUT VARCHAR2,
    p_POSTAL_CODE OUT VARCHAR2,
    p_COUNTRY_CODE OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2
    ) AS
v_GEOGRAPHY_ID NUMBER;
BEGIN
	-- retrieve it
	IO.GET_ADDRESS(p_ADDRESS_ID,p_ADDRESS_NAME,p_ADDRESS_ALIAS,p_ADDRESS_DESC,
    				p_STREET,v_GEOGRAPHY_ID,p_EXTERNAL_IDENTIFIER);
	-- translate Geography ID into parameters
	BEGIN
	    SELECT NVL(DISPLAY_NAME,GEOGRAPHY_NAME) INTO p_CITY
	    FROM GEOGRAPHY
	    WHERE GEOGRAPHY_TYPE = 'City'
		    AND ROWNUM = 1
	    START WITH GEOGRAPHY_ID = v_GEOGRAPHY_ID
	    CONNECT BY PRIOR PARENT_GEOGRAPHY_ID = GEOGRAPHY_ID;
    EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_CITY := NULL;
	END;

	BEGIN
	    SELECT NVL(ABBREVIATION,NVL(DISPLAY_NAME,GEOGRAPHY_NAME)) INTO p_STATE_CODE
	    FROM GEOGRAPHY
	    WHERE GEOGRAPHY_TYPE = 'State/Province'
		    AND ROWNUM = 1
	    START WITH GEOGRAPHY_ID = v_GEOGRAPHY_ID
	    CONNECT BY PRIOR PARENT_GEOGRAPHY_ID = GEOGRAPHY_ID;
    EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_STATE_CODE := NULL;
	END;

	BEGIN
    	SELECT NVL(DISPLAY_NAME,GEOGRAPHY_NAME) INTO p_POSTAL_CODE
	    FROM GEOGRAPHY
	    WHERE GEOGRAPHY_TYPE = 'Postal Code'
		    AND ROWNUM = 1
	    START WITH GEOGRAPHY_ID = v_GEOGRAPHY_ID
	    CONNECT BY PRIOR PARENT_GEOGRAPHY_ID = GEOGRAPHY_ID;
    EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_POSTAL_CODE := NULL;
	END;

	BEGIN
	    SELECT NVL(ABBREVIATION,NVL(DISPLAY_NAME,GEOGRAPHY_NAME)) INTO p_COUNTRY_CODE
	    FROM GEOGRAPHY
	    WHERE GEOGRAPHY_TYPE = 'Country'
		    AND ROWNUM = 1
	    START WITH GEOGRAPHY_ID = v_GEOGRAPHY_ID
	    CONNECT BY PRIOR PARENT_GEOGRAPHY_ID = GEOGRAPHY_ID;
    EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_COUNTRY_CODE := NULL;
	END;
END GET_ADDRESS;
---------------------------------------------------------------------------------------------------
PROCEDURE ADDRESS_GEOGRAPHY_LIST
	(
    p_PARENT_TYPE IN VARCHAR2,
    p_PARENT_NAME IN VARCHAR2,
    p_PARENT_ABBR IN NUMBER,
    p_G_PARENT_TYPE IN VARCHAR2,
    p_G_PARENT_NAME IN VARCHAR2,
    p_G_PARENT_ABBR IN NUMBER,
    p_GG_PARENT_TYPE IN VARCHAR2,
    p_GG_PARENT_NAME IN VARCHAR2,
    p_GG_PARENT_ABBR IN NUMBER,
    p_LIST_TYPE IN VARCHAR2,
    p_LIST_ABBR IN NUMBER,
    p_STATUS OUT NUMBER,
    p_CURSOR IN OUT REF_CURSOR
    ) AS
v_GEOGRAPHY_ID NUMBER := 0;
v_PARENT_TYPE GEOGRAPHY.GEOGRAPHY_TYPE%TYPE;
v_PARENT_NAME GEOGRAPHY.GEOGRAPHY_NAME%TYPE;
v_PARENT_ABBR NUMBER;
BEGIN
	p_STATUS := GA.SUCCESS;

	-- loop through specified ancestors to find first non-zero ID
	FOR v_INDEX IN 1..3 LOOP
		EXIT WHEN v_GEOGRAPHY_ID <> 0;

		CASE v_INDEX
		WHEN 1 THEN
			v_PARENT_TYPE := p_PARENT_TYPE;    v_PARENT_NAME := p_PARENT_NAME;    v_PARENT_ABBR := p_PARENT_ABBR;
		WHEN 2 THEN
			v_PARENT_TYPE := p_G_PARENT_TYPE;  v_PARENT_NAME := p_G_PARENT_NAME;  v_PARENT_ABBR := p_G_PARENT_ABBR;
		WHEN 3 THEN
			v_PARENT_TYPE := p_GG_PARENT_TYPE; v_PARENT_NAME := p_GG_PARENT_NAME; v_PARENT_ABBR := p_GG_PARENT_ABBR;
		END CASE;

        BEGIN
    	    SELECT GEOGRAPHY_ID INTO v_GEOGRAPHY_ID
    	    FROM GEOGRAPHY
    	    WHERE GEOGRAPHY_TYPE = v_PARENT_TYPE
    	    	AND CASE
            		WHEN v_PARENT_ABBR=0 THEN
                    	NVL(DISPLAY_NAME,GEOGRAPHY_NAME)
                    ELSE
                    	NVL(ABBREVIATION,NVL(DISPLAY_NAME,GEOGRAPHY_NAME))
                    END = v_PARENT_NAME
    			AND ROWNUM=1;
    	EXCEPTION
    		WHEN NO_DATA_FOUND THEN
    			v_GEOGRAPHY_ID := 0;
        END;
	END LOOP;

	-- using that ID, enumerate all descendants of the specified type
	IF v_GEOGRAPHY_ID = 0 THEN
		-- ID of zero? then enumerate all of the specified type
		OPEN p_CURSOR FOR
    		SELECT CASE
		       		WHEN p_LIST_ABBR=0 THEN
	                	NVL(DISPLAY_NAME,GEOGRAPHY_NAME)
	                ELSE
	                	NVL(ABBREVIATION,NVL(DISPLAY_NAME,GEOGRAPHY_NAME))
	                END "NAME"
			FROM GEOGRAPHY
	        WHERE GEOGRAPHY_TYPE = p_LIST_TYPE
	        START WITH PARENT_GEOGRAPHY_ID = 0
	        CONNECT BY PRIOR GEOGRAPHY_ID = PARENT_GEOGRAPHY_ID
	        ORDER BY 1;
	ELSE
		OPEN p_CURSOR FOR
    		SELECT CASE
		       		WHEN p_LIST_ABBR=0 THEN
	                	NVL(DISPLAY_NAME,GEOGRAPHY_NAME)
	                ELSE
	                	NVL(ABBREVIATION,NVL(DISPLAY_NAME,GEOGRAPHY_NAME))
	                END "NAME"
			FROM GEOGRAPHY
	        WHERE GEOGRAPHY_TYPE = p_LIST_TYPE
	        START WITH GEOGRAPHY_ID = v_GEOGRAPHY_ID
	        CONNECT BY PRIOR GEOGRAPHY_ID = PARENT_GEOGRAPHY_ID
	        ORDER BY 1;
	END IF;

EXCEPTION
	WHEN OTHERS THEN
    	p_STATUS := SQLCODE;
END ADDRESS_GEOGRAPHY_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE ENTITY_ATTRIBUTE_VALUES
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_OWNER_ENTITY_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS
BEGIN
	p_STATUS := GA.SUCCESS;
	OPEN p_CURSOR FOR
		SELECT A.ATTRIBUTE_ID,
			B.ATTRIBUTE_NAME,
			A.ATTRIBUTE_VAL,
			A.BEGIN_DATE,
			A.END_DATE,
			A.ENTRY_DATE,
			B.ATTRIBUTE_TYPE
		FROM TEMPORAL_ENTITY_ATTRIBUTE A,
			ENTITY_ATTRIBUTE B
		WHERE B.ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID
			AND A.OWNER_ENTITY_ID = p_OWNER_ENTITY_ID
			AND A.ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID
			AND A.ATTRIBUTE_ID = B.ATTRIBUTE_ID
		UNION ALL
		SELECT B.ATTRIBUTE_ID, B.ATTRIBUTE_NAME, NULL "ATTRIBUTE_VAL", NULL "BEGIN_DATE", NULL "END_DATE", NULL "ENTRY_DATE", B.ATTRIBUTE_TYPE
		FROM ENTITY_ATTRIBUTE B
		WHERE B.ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID
			AND B.ATTRIBUTE_SHOW = 1
			AND NOT EXISTS (SELECT 1 FROM TEMPORAL_ENTITY_ATTRIBUTE X
							WHERE X.OWNER_ENTITY_ID = p_OWNER_ENTITY_ID
							AND X.ATTRIBUTE_ID = B.ATTRIBUTE_ID)
		ORDER BY ATTRIBUTE_NAME, BEGIN_DATE;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;
END ENTITY_ATTRIBUTE_VALUES;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ENTITY_ATTRIBUTE
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ATTRIBUTE_NAME IN VARCHAR2,
	p_ATTRIBUTE_ID IN NUMBER,
	p_ATTRIBUTE_TYPE IN VARCHAR2,
	p_ATTRIBUTE_SHOW IN NUMBER,
	p_STATUS OUT NUMBER
	) AS
v_OID NUMBER(9);
BEGIN

	IF NOT CAN_WRITE('Public') THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;
-- FIRST TRY TO UPDATE AN EXISTING ENTITY ATTRIBUTE FOR THE OWNING ENTITY
	IF p_ATTRIBUTE_ID > 0 THEN
		UPDATE ENTITY_ATTRIBUTE SET
			ATTRIBUTE_NAME = p_ATTRIBUTE_NAME,
			ATTRIBUTE_TYPE = p_ATTRIBUTE_TYPE,
			ATTRIBUTE_SHOW = p_ATTRIBUTE_SHOW,
			ENTRY_DATE = SYSDATE
		WHERE ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID
			AND ATTRIBUTE_ID = p_ATTRIBUTE_ID;
	ELSE

-- IF THE UPDATE FAILED TO FIND AN EXISTING ENTITY THEN INSERT A NEW ENTITY
		SELECT OID.NEXTVAL INTO v_OID FROM DUAL;
		INSERT INTO ENTITY_ATTRIBUTE (
			ENTITY_DOMAIN_ID,
			ATTRIBUTE_NAME,
			ATTRIBUTE_ID,
			ATTRIBUTE_TYPE,
			ATTRIBUTE_SHOW,
			ENTRY_DATE)
		VALUES (
			p_ENTITY_DOMAIN_ID,
			p_ATTRIBUTE_NAME,
			v_OID,
			p_ATTRIBUTE_TYPE,
			p_ATTRIBUTE_SHOW,
			SYSDATE);
	END IF;
	EXCEPTION
		WHEN INVALID_DATE_RANGE THEN
			p_STATUS := GA.INVALID_DATE_RANGE;
		WHEN DUP_VAL_ON_INDEX THEN
			p_STATUS := GA.DUPLICATE_ENTITY;
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		WHEN OTHERS THEN
			RAISE;
END PUT_ENTITY_ATTRIBUTE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ENTITY_ATTRIBUTE_VALUE
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_OWNER_ENTITY_ID IN NUMBER,
	p_ATTRIBUTE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ATTRIBUTE_VAL IN VARCHAR2,
	p_OLD_OWNER_ENTITY_ID IN NUMBER,
	p_OLD_ATTRIBUTE_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS
v_END_DATE DATE;
BEGIN

	IF NOT CAN_WRITE('Public') THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	v_END_DATE := NULL_DATE(p_END_DATE);
	p_STATUS := GA.SUCCESS;
-- FIRST TRY TO UPDATE AN EXISTING TEMPORAL ENTITY ATTRIBUTE FOR THE OWNING ENTITY
	UPDATE TEMPORAL_ENTITY_ATTRIBUTE SET
		OWNER_ENTITY_ID = p_OWNER_ENTITY_ID,
		ATTRIBUTE_ID = p_ATTRIBUTE_ID,
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		ATTRIBUTE_VAL = NVL(p_ATTRIBUTE_VAL,GA.UNDEFINED_ATTRIBUTE),
		ENTRY_DATE = SYSDATE
	WHERE OWNER_ENTITY_ID = p_OLD_OWNER_ENTITY_ID AND
		ATTRIBUTE_ID = p_OLD_ATTRIBUTE_ID AND
		BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE) AND
		ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID;

-- IF THE UPDATE FAILED TO FIND AN EXISTING TEMPORAL ENTITY THEN INSERT A NEW TEMPORAL ENTITY
	IF SQL%NOTFOUND THEN
		INSERT INTO TEMPORAL_ENTITY_ATTRIBUTE (
			ENTITY_DOMAIN_ID,
			OWNER_ENTITY_ID,
			ATTRIBUTE_ID,
			BEGIN_DATE,
			END_DATE,
			ATTRIBUTE_VAL,
			ENTRY_DATE)
		VALUES (
			p_ENTITY_DOMAIN_ID,
			p_OWNER_ENTITY_ID,
			p_ATTRIBUTE_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			NVL(p_ATTRIBUTE_VAL,0),
			SYSDATE);
	END IF;
	EXCEPTION
		WHEN INVALID_DATE_RANGE THEN
			p_STATUS := GA.INVALID_DATE_RANGE;
		WHEN DUP_VAL_ON_INDEX THEN
			p_STATUS := GA.DUPLICATE_ENTITY;
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		WHEN OTHERS THEN
			RAISE;
END PUT_ENTITY_ATTRIBUTE_VALUE;
----------------------------------------------------------------------------------------------------
PROCEDURE ENTITY_CONTACTS_ADDRESSES
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_OWNER_ENTITY_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS
BEGIN
	p_STATUS := GA.SUCCESS;
	OPEN p_CURSOR FOR
		SELECT A.CATEGORY_ID,
			A.CATEGORY_NAME,
			B.CONTACT_ID,
			C.ADDRESS_ID,
			GREATEST(B.ENTRY_DATE,C.ENTRY_DATE) "ENTRY_DATE"
		FROM CATEGORY A,
			ENTITY_DOMAIN_CONTACT B,
			ENTITY_DOMAIN_ADDRESS C
		WHERE B.ENTITY_DOMAIN_ID(+) = p_ENTITY_DOMAIN_ID
			AND B.OWNER_ENTITY_ID(+) = p_OWNER_ENTITY_ID
			AND B.CATEGORY_ID(+) = A.CATEGORY_ID
			AND C.ENTITY_DOMAIN_ID(+) = p_ENTITY_DOMAIN_ID
			AND C.OWNER_ENTITY_ID(+) = p_OWNER_ENTITY_ID
			AND C.CATEGORY_ID(+) = A.CATEGORY_ID
		ORDER BY 1,2;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;
END ENTITY_CONTACTS_ADDRESSES;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ENTITY_CONTACT_ADDRESS
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_OWNER_ENTITY_ID IN NUMBER,
	p_CATEGORY_ID IN NUMBER,
	p_CONTACT_ID IN NUMBER,
	p_ADDRESS_ID IN NUMBER,
	p_OLD_CATEGORY_ID IN NUMBER,
	p_STATUS OUT NUMBER
	) AS
-- CREATE OR REPLACE AN ENTITY_DOMAIN_ADDRESS RECORD

BEGIN

	IF NOT CAN_WRITE('Data Setup') THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

-- First save the Contact
	IF p_CONTACT_ID = 0 OR p_CONTACT_ID IS NULL THEN
    -- CLEAR AN EXISTING ENTRY
		DELETE ENTITY_DOMAIN_CONTACT
		WHERE ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID
		  AND OWNER_ENTITY_ID = p_OWNER_ENTITY_ID
		  AND CATEGORY_ID = p_OLD_CATEGORY_ID;
	ELSE
    -- UPDATE AN EXISTING RECORD
    	UPDATE ENTITY_DOMAIN_CONTACT SET
    		CATEGORY_ID = p_CATEGORY_ID,
    		CONTACT_ID = p_CONTACT_ID,
    		ENTRY_DATE = SYSDATE
    	WHERE ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID
    	  AND OWNER_ENTITY_ID = p_OWNER_ENTITY_ID
    	  AND CATEGORY_ID = p_OLD_CATEGORY_ID;

    -- IF THE PREVIOUS UPDATE DID NOT FIND A MATCH, THEN INSERT A NEW RECORD.
    	IF SQL%NOTFOUND THEN
    		INSERT INTO ENTITY_DOMAIN_CONTACT (
    			ENTITY_DOMAIN_ID,
    			OWNER_ENTITY_ID,
    			CATEGORY_ID,
    			CONTACT_ID,
    			ENTRY_DATE)
    		VALUES (
    			p_ENTITY_DOMAIN_ID,
    			p_OWNER_ENTITY_ID,
    			p_CATEGORY_ID,
    			p_CONTACT_ID,
    			SYSDATE);
    	END IF;
	END IF;

-- Then save the Address
	IF p_ADDRESS_ID = 0 OR p_CONTACT_ID IS NULL THEN
    -- CLEAR AN EXISTING ENTRY
		DELETE ENTITY_DOMAIN_ADDRESS
		WHERE ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID
		  AND OWNER_ENTITY_ID = p_OWNER_ENTITY_ID
		  AND CATEGORY_ID = p_OLD_CATEGORY_ID;
	ELSE
    -- UPDATE AN EXISTING RECORD
    	UPDATE ENTITY_DOMAIN_ADDRESS SET
    		CATEGORY_ID = p_CATEGORY_ID,
    		ADDRESS_ID = p_ADDRESS_ID,
    		ENTRY_DATE = SYSDATE
    	WHERE ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID
    	  AND OWNER_ENTITY_ID = p_OWNER_ENTITY_ID
    	  AND CATEGORY_ID = p_OLD_CATEGORY_ID;

    -- IF THE PREVIOUS UPDATE DID NOT FIND A MATCH, THEN INSERT A NEW RECORD.
    	IF SQL%NOTFOUND THEN
    		INSERT INTO ENTITY_DOMAIN_ADDRESS (
    			ENTITY_DOMAIN_ID,
    			OWNER_ENTITY_ID,
    			CATEGORY_ID,
    			ADDRESS_ID,
    			ENTRY_DATE)
    		VALUES (
    			p_ENTITY_DOMAIN_ID,
    			p_OWNER_ENTITY_ID,
    			p_CATEGORY_ID,
    			p_ADDRESS_ID,
    			SYSDATE);
    	END IF;
	END IF;

EXCEPTION
	WHEN INSUFFICIENT_PRIVILEGES THEN
		p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		RETURN;
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;
END PUT_ENTITY_CONTACT_ADDRESS;
---------------------------------------------------------------------------------------------------
PROCEDURE ENTITY_ATTRIBUTES_FOR_DOMAIN
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT REF_CURSOR
	) AS
BEGIN
	p_STATUS := GA.SUCCESS;
	OPEN p_CURSOR FOR
		SELECT ATTRIBUTE_NAME, ATTRIBUTE_ID, ATTRIBUTE_TYPE, ATTRIBUTE_SHOW
		FROM ENTITY_ATTRIBUTE
		WHERE ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID
		ORDER BY 1;
EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;
END ENTITY_ATTRIBUTES_FOR_DOMAIN;
---------------------------------------------------------------------------------------------------
PROCEDURE LIST_TEMPLATES
	(
	p_SEARCH_STRING IN VARCHAR,
	p_SEARCH_BY_ALIAS IN NUMBER,
	p_INCLUDE_INACTIVE IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	)
	AS

-- Answer the given entities

BEGIN

--Make sure user has appropriate access.

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

p_STATUS := GA.SUCCESS;

IF p_SEARCH_STRING = '%' OR p_SEARCH_STRING IS NULL THEN

	OPEN p_CURSOR FOR
	SELECT
		A.TEMPLATE_NAME "ENTITY_NAME",
		A.TEMPLATE_ID "ENTITY_ID",
		A.TEMPLATE_ALIAS "ENTITY_ALIAS",
		'Active' "ENTITY_STATUS"
	FROM TEMPLATE A
    WHERE NVL(A.IS_DAY_TYPE,0) = 0 --GET ONLY TOU TEMPLATES.
	ORDER BY DECODE(p_SEARCH_BY_ALIAS, 0, TEMPLATE_NAME, TEMPLATE_ALIAS);

ELSE

	OPEN p_CURSOR FOR
	SELECT
		A.TEMPLATE_NAME "ENTITY_NAME",
		A.TEMPLATE_ID "ENTITY_ID",
		A.TEMPLATE_ALIAS "ENTITY_ALIAS",
		'Active' "ENTITY_STATUS"
	FROM TEMPLATE A
	WHERE (p_SEARCH_BY_ALIAS = 1 OR TEMPLATE_NAME LIKE p_SEARCH_STRING)
		AND (p_SEARCH_BY_ALIAS = 0 OR TEMPLATE_ALIAS LIKE p_SEARCH_STRING)
		AND NVL(A.IS_DAY_TYPE,0) = 0
	ORDER BY DECODE(p_SEARCH_BY_ALIAS, 0, TEMPLATE_NAME, TEMPLATE_ALIAS);

END IF;

	EXCEPTION
		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END LIST_TEMPLATES;
----------------------------------------------------------------------------------------------------
PROCEDURE LIST_DAY_TYPE_TEMPLATES
	(
	p_SEARCH_STRING IN VARCHAR,
	p_SEARCH_BY_ALIAS IN NUMBER,
	p_INCLUDE_INACTIVE IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	)
	AS

-- Answer the given entities

BEGIN

--Make sure user has appropriate access.

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

p_STATUS := GA.SUCCESS;

IF p_SEARCH_STRING = '%' OR p_SEARCH_STRING IS NULL THEN

	OPEN p_CURSOR FOR
	SELECT
		A.TEMPLATE_NAME "ENTITY_NAME",
		A.TEMPLATE_ID "ENTITY_ID",
		A.TEMPLATE_ALIAS "ENTITY_ALIAS",
		'Active' "ENTITY_STATUS"
	FROM TEMPLATE A
    WHERE A.IS_DAY_TYPE = 1 --GET DAY_TYPE TEMPLATES ONLY.
	ORDER BY DECODE(p_SEARCH_BY_ALIAS, 0, TEMPLATE_NAME, TEMPLATE_ALIAS);

ELSE

	OPEN p_CURSOR FOR
	SELECT
		A.TEMPLATE_NAME "ENTITY_NAME",
		A.TEMPLATE_ID "ENTITY_ID",
		A.TEMPLATE_ALIAS "ENTITY_ALIAS",
		'Active' "ENTITY_STATUS"
	FROM TEMPLATE A
	WHERE (p_SEARCH_BY_ALIAS = 1 OR TEMPLATE_NAME LIKE p_SEARCH_STRING)
		AND (p_SEARCH_BY_ALIAS = 0 OR TEMPLATE_ALIAS LIKE p_SEARCH_STRING)
		AND A.IS_DAY_TYPE = 1
	ORDER BY DECODE(p_SEARCH_BY_ALIAS, 0, TEMPLATE_NAME, TEMPLATE_ALIAS);

END IF;

	EXCEPTION
		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END LIST_DAY_TYPE_TEMPLATES;
----------------------------------------------------------------------------------------------------
PROCEDURE DOMAIN_ENTITY_ATTRIBUTES
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

-- Answer the CONTRACTs for the given ACCOUNT.

BEGIN
	IF NOT Can_Read('Public') THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
    p_STATUS := GA.SUCCESS;

	 OPEN p_CURSOR FOR
	    SELECT ATTRIBUTE_ID, ATTRIBUTE_NAME, ATTRIBUTE_TYPE, ATTRIBUTE_SHOW
		FROM ENTITY_ATTRIBUTE
		WHERE ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID
		ORDER BY 2;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;
END DOMAIN_ENTITY_ATTRIBUTES;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_DOMAIN_ENTITY_ATTRIBUTE
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ATTRIBUTE_ID IN NUMBER,
	p_ATTRIBUTE_NAME IN VARCHAR2,
	p_ATTRIBUTE_TYPE IN VARCHAR2,
	p_ATTRIBUTE_SHOW IN NUMBER,
	p_STATUS OUT NUMBER
	)
	AS
v_ATTRIBUTE_ID NUMBER(9) := NVL(p_ATTRIBUTE_ID, 0);
BEGIN

	p_STATUS := GA.SUCCESS;

	SP.PUT_ENTITY_ATTRIBUTE(v_ATTRIBUTE_ID, p_ENTITY_DOMAIN_ID, p_ATTRIBUTE_NAME, v_ATTRIBUTE_ID, p_ATTRIBUTE_TYPE, p_ATTRIBUTE_SHOW);

END PUT_DOMAIN_ENTITY_ATTRIBUTE;
----------------------------------------------------------------------------------------------------
PROCEDURE PATH_SEGMENTS
	(
	p_PATH_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	   SELECT A.SEGMENT_POS, A.SEGMENT_ID
		FROM TX_PATH_SEGMENT A
		WHERE A.PATH_ID = p_PATH_ID
		ORDER BY 1;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END PATH_SEGMENTS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_PATH_SEGMENT
	(
	p_PATH_ID IN NUMBER,
	p_SEGMENT_ID IN NUMBER,
	p_SEGMENT_POS IN NUMBER,
	p_OLD_SEGMENT_ID IN NUMBER,
	p_OLD_SEGMENT_POS IN NUMBER,
	p_STATUS OUT NUMBER
	)
	AS

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

-- UPDATE THE CURRENT SSIGNMENT IF ONE EXISTS

	UPDATE TX_PATH_SEGMENT SET
		SEGMENT_ID = p_SEGMENT_ID,
		SEGMENT_POS = p_SEGMENT_POS
	WHERE PATH_ID = p_PATH_ID
		AND SEGMENT_ID = p_OLD_SEGMENT_ID
		AND SEGMENT_POS = p_OLD_SEGMENT_POS;

-- NO ASSIGNMENT UPDATE FOR THIS COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO TX_PATH_SEGMENT
			(
			PATH_ID,
			SEGMENT_ID,
			SEGMENT_POS
			)
		VALUES
			(
			p_PATH_ID,
			p_SEGMENT_ID,
			p_SEGMENT_POS
			);
	END IF;

	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			p_STATUS := GA.DUPLICATE_ENTITY;
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		WHEN OTHERS THEN
			RAISE;

END PUT_PATH_SEGMENT;

---------------------------------------------------------------------------------------------------
PROCEDURE SYSTEM_ACTION_ROLES
	(
	p_ACTION_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	   SELECT A.ROLE_ID, A.REALM_ID
		FROM SYSTEM_ACTION_ROLE A
		WHERE A.ACTION_ID = p_ACTION_ID
		ORDER BY 1;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END SYSTEM_ACTION_ROLES;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_SYSTEM_ACTION_ROLE
	(
	p_ACTION_ID IN NUMBER,
	p_ROLE_ID IN NUMBER,
	p_REALM_ID IN NUMBER,
	p_OLD_ROLE_ID IN NUMBER,
	p_OLD_REALM_ID IN NUMBER,
	p_STATUS OUT NUMBER
	)
	AS

BEGIN

	IF NOT GB.g_IS_ADMIN THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

-- UPDATE THE CURRENT ASSIGNMENT IF ONE EXISTS

	UPDATE SYSTEM_ACTION_ROLE SET
		ROLE_ID = p_ROLE_ID,
		REALM_ID = p_REALM_ID,
		ENTRY_DATE = SYSDATE
	WHERE ACTION_ID = p_ACTION_ID
		AND ROLE_ID = p_OLD_ROLE_ID
		AND REALM_ID = p_OLD_REALM_ID;

-- NO ASSIGNMENT UPDATE FOR THIS COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO SYSTEM_ACTION_ROLE
			(
			ACTION_ID,
			ROLE_ID,
			REALM_ID,
			ENTRY_DATE
			)
		VALUES
			(
			p_ACTION_ID,
			p_ROLE_ID,
			p_REALM_ID,
			SYSDATE
			);
	END IF;

	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			p_STATUS := GA.DUPLICATE_ENTITY;
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		WHEN OTHERS THEN
			RAISE;

END PUT_SYSTEM_ACTION_ROLE;

---------------------------------------------------------------------------------------------------
PROCEDURE HEAT_RATE_CURVE_POINTS
	(
	p_HEAT_RATE_CURVE_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	   SELECT A.PARAMETER_1_VAL, A.PARAMETER_2_VAL, A.PARAMETER_3_VAL, 
	   		A.AMOUNT, A.OPERATING_MODE, A.PRICE, A.ENTRY_DATE
		FROM HEAT_RATE_CURVE_POINT A
		WHERE A.HEAT_RATE_CURVE_ID = p_HEAT_RATE_CURVE_ID
		ORDER BY 1;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END HEAT_RATE_CURVE_POINTS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_HEAT_RATE_CURVE_POINT
	(
	p_HEAT_RATE_CURVE_ID IN NUMBER,
	p_PARAMETER_1_VAL IN NUMBER,
	p_PARAMETER_2_VAL IN NUMBER,
	p_PARAMETER_3_VAL IN NUMBER,
	p_AMOUNT IN NUMBER,
	p_OPERATING_MODE IN VARCHAR2,
	p_PRICE IN NUMBER,
	p_OLD_PARAMETER_1_VAL IN NUMBER,
	p_OLD_PARAMETER_2_VAL IN NUMBER,
	p_OLD_PARAMETER_3_VAL IN NUMBER,
	p_OLD_AMOUNT IN NUMBER,
	p_OLD_OPERATING_MODE IN VARCHAR2,
	p_STATUS OUT NUMBER
	)
	AS

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

-- UPDATE THE CURRENT SSIGNMENT IF ONE EXISTS

	UPDATE HEAT_RATE_CURVE_POINT SET
		PARAMETER_1_VAL = p_PARAMETER_1_VAL,
		PARAMETER_2_VAL = p_PARAMETER_2_VAL,
		PARAMETER_3_VAL = p_PARAMETER_3_VAL,
		AMOUNT = p_AMOUNT,
		OPERATING_MODE = p_OPERATING_MODE,
		PRICE = p_PRICE,
		ENTRY_DATE = SYSDATE
	WHERE HEAT_RATE_CURVE_ID = p_HEAT_RATE_CURVE_ID
		AND PARAMETER_1_VAL = p_OLD_PARAMETER_1_VAL
		AND PARAMETER_2_VAL = p_OLD_PARAMETER_2_VAL
		AND PARAMETER_3_VAL = p_OLD_PARAMETER_3_VAL
		AND AMOUNT = p_OLD_AMOUNT
		AND OPERATING_MODE = p_OLD_OPERATING_MODE		;

-- NO ASSIGNMENT UPDATE FOR THIS COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO HEAT_RATE_CURVE_POINT
			(
			HEAT_RATE_CURVE_ID, 
			PARAMETER_1_VAL, 
			PARAMETER_2_VAL, 
			PARAMETER_3_VAL, 
			AMOUNT, 
			OPERATING_MODE, 
			PRICE, 
			ENTRY_DATE
			)
		VALUES
			(
			p_HEAT_RATE_CURVE_ID, 
			p_PARAMETER_1_VAL, 
			p_PARAMETER_2_VAL, 
			p_PARAMETER_3_VAL, 
			p_AMOUNT, 
			p_OPERATING_MODE, 
			p_PRICE, 
			SYSDATE
			);
	END IF;

	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			p_STATUS := GA.DUPLICATE_ENTITY;
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		WHEN OTHERS THEN
			RAISE;

END PUT_HEAT_RATE_CURVE_POINT;

---------------------------------------------------------------------------------------------------
PROCEDURE TRANSACTION_LIMITS
	(
	p_TRANSACTION_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT REF_CURSOR
	) AS
BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT A.BEGIN_DATE,
			A.END_DATE,
			A.LIMIT_INTERVAL,
			A.MIN_TRANSACTION_ID,
			A.LIMIT_TRANSACTION_ID,
			A.ENTRY_DATE
		FROM INTERCHANGE_TRANSACTION_LIMIT A
		WHERE A.TRANSACTION_ID = p_TRANSACTION_ID
		ORDER BY A.BEGIN_DATE, A.END_DATE;

EXCEPTION
	WHEN INSUFFICIENT_PRIVILEGES THEN
		p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END TRANSACTION_LIMITS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_TRANSACTION_LIMIT
	(
	p_TRANSACTION_ID IN NUMBER,
	p_LIMIT_INTERVAL IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_MIN_TRANSACTION_ID IN NUMBER,
	p_LIMIT_TRANSACTION_ID IN NUMBER,
	p_OLD_LIMIT_INTERVAL IN VARCHAR2,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS
BEGIN
	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	UPDATE INTERCHANGE_TRANSACTION_LIMIT
	SET LIMIT_INTERVAL = p_LIMIT_INTERVAL,
		BEGIN_DATE = p_BEGIN_DATE,
		END_DATE = NULL_DATE(p_END_DATE),
		MIN_TRANSACTION_ID = p_MIN_TRANSACTION_ID,
		LIMIT_TRANSACTION_ID = p_LIMIT_TRANSACTION_ID,
		ENTRY_DATE = SYSDATE
	WHERE TRANSACTION_ID = p_TRANSACTION_ID
		AND LIMIT_INTERVAL = p_OLD_LIMIT_INTERVAL
		AND BEGIN_DATE = p_OLD_BEGIN_DATE;

	IF SQL%NOTFOUND THEN
		INSERT INTO INTERCHANGE_TRANSACTION_LIMIT (
			TRANSACTION_ID, 
			LIMIT_INTERVAL, 
			BEGIN_DATE, 
			END_DATE, 
			MIN_TRANSACTION_ID, 
			LIMIT_TRANSACTION_ID, 
			ENTRY_DATE)
		VALUES (
			p_TRANSACTION_ID,
			p_LIMIT_INTERVAL,
			p_BEGIN_DATE,
			NULL_DATE(p_END_DATE),
			p_MIN_TRANSACTION_ID,
			p_LIMIT_TRANSACTION_ID,
			SYSDATE);
	END IF;

EXCEPTION
	WHEN INSUFFICIENT_PRIVILEGES THEN
		p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END PUT_TRANSACTION_LIMIT;
----------------------------------------------------------------------------------------------------
PROCEDURE SYSTEM_ALERT_ROLES
	(
	p_ALERT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

-- Answer the WEATHER_STATION_PARAMETERS's for the given STATION.

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    p_STATUS := GA.SUCCESS;
	OPEN p_CURSOR FOR
	    SELECT A.ROLE_ID,
	    	B.ROLE_NAME,
	    	1 "IS_SELECTED",
			A.ALERT_ID "ALERT_ID"
		FROM SYSTEM_ALERT_ROLE A, RETAIL_OFFICE_ROLE B
		WHERE A.ALERT_ID = p_ALERT_ID
			AND A.ROLE_ID = B.ROLE_ID
			AND A.ROLE_ID > 0

		UNION

		SELECT ROLE_ID,
			ROLE_NAME,
			0 "IS_SELECTED",
			p_ALERT_ID "SYSTEM_ALERT_ID"
		FROM RETAIL_OFFICE_ROLE
		WHERE NOT ROLE_ID IN (SELECT ROLE_ID
									FROM SYSTEM_ALERT_ROLE
									WHERE ALERT_ID = p_ALERT_ID)
			AND ROLE_ID > 0

		ORDER BY 3 DESC, 2 ASC;

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END SYSTEM_ALERT_ROLES;
---------------------------------------------------------------------------------------------------

PROCEDURE PUT_SYSTEM_ALERT_ROLE
	(
	p_ALERT_ID IN NUMBER,
	p_ROLE_ID IN NUMBER,
	p_IS_SELECTED IN NUMBER,
	p_STATUS OUT NUMBER
	)
	AS

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	--DELETE THE CURRENT ASSIGNMENT IF NOT SELECTED.
	IF p_IS_SELECTED = 0 THEN
		DELETE FROM SYSTEM_ALERT_ROLE
		WHERE ALERT_ID = p_ALERT_ID
			AND ROLE_ID = p_ROLE_ID;
	ELSE
	-- UPDATE THE CURRENT ACCOUNT ASSIGNMENT IF ONE EXISTS

		UPDATE SYSTEM_ALERT_ROLE SET
			ROLE_ID = p_ROLE_ID
		WHERE ALERT_ID = p_ALERT_ID
			AND ROLE_ID = p_ROLE_ID;

	-- NO ASSIGNMENT UPDATE FOR THIS ACCOUNT AND COMBINATION SO INSERT A NEW ASSIGNMENT

		IF SQL%NOTFOUND THEN
			INSERT INTO SYSTEM_ALERT_ROLE
				(
				ALERT_ID,
				ROLE_ID
				)
			VALUES
				(
				p_ALERT_ID,
				p_ROLE_ID
				);
		END IF;
	END IF;

	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			p_STATUS := GA.DUPLICATE_ENTITY;
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		WHEN OTHERS THEN
			RAISE;
END PUT_SYSTEM_ALERT_ROLE;
---------------------------------------------------------------------------------------------------

PROCEDURE ETAG_MARKET_SEGMENTS
	(
	p_ETAG_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

	-- Return Market Segment cursor

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
        SELECT 
    		MARKET_SEGMENT_NID  MARKET_SEGMENT_ID,
    		PS.TAG_CODE "PSE",
            PD.CODE "PRODUCT CODE",
    		NULL  "CONTRACT",  -- CONTRACT_NUMBER_LIST_ID
    		NULL  "MISC",  -- MISC_INFO_LIST_ID
    		CURRENT_CORRECTION_NID  CURRENT_CORRECTION_ID 
        FROM ETAG_MARKET_SEGMENT MS, TSIN_PSE_REGISTRY PS, TSIN_PRODUCT_REGISTRY PD
        WHERE ETAG_ID = p_ETAG_ID -- 100 -- 
			AND PS.TAGGING_ENTITY_ID(+) = MS.PSE_CODE
			AND PD.PRODUCTID(+) = MS.ENERGY_PRODUCT_REF
    	ORDER BY MARKET_SEGMENT_NID;
				
		
EXCEPTION
    WHEN INSUFFICIENT_PRIVILEGES THEN
    	p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END ETAG_MARKET_SEGMENTS;
----------------------------------------------------------------------------------------------------
PROCEDURE ETAG_PHYSICAL_SEGMENTS
	(
	p_ETAG_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

	-- Return Physical Segment cursor
BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
        -- Resource (Generation or Load) Segment
		SELECT 
    		RS.MARKET_SEGMENT_NID  MARKET_SEGMENT_ID,
    		RS.PHYSICAL_SEGMENT_NID  PHYSICAL_SEGMENT_ID,
    		RS.SEGMENT_TYPE,
			NULL  "CA",  --
			NULL  "TP",  --
			PS.TAG_CODE  "PSE",
			NULL  "POR_CODE",  --
			NULL  "POD_CODE",  --
    		NULL  "CONTRACT",  -- CONTRACT_NUMBER_LIST_ID
    		NULL  "MISC",  -- MISC_INFO_LIST_ID
    		RS.CURRENT_CORRECTION_NID  CURRENT_CORRECTION_ID 
        FROM ETAG_RESOURCE_SEGMENT RS, ETAG_MARKET_SEGMENT MS, TSIN_PSE_REGISTRY PS  -- , ETAG_RESOURCE R
        WHERE RS.ETAG_ID = p_ETAG_ID -- 100 -- 
			AND MS.MARKET_SEGMENT_NID = RS.MARKET_SEGMENT_NID
			AND PS.TAGGING_ENTITY_ID(+) = MS.PSE_CODE
		UNION 
        --Transmission Segment
        SELECT 
    		TS.MARKET_SEGMENT_NID  MARKET_SEGMENT_ID,
    		TS.PHYSICAL_SEGMENT_NID  PHYSICAL_SEGMENT_ID,
    		TS.SEGMENT_TYPE,
			NULL  "CA",  --
			NULL  "TP",  --
			PS.TAG_CODE  "PSE",  --
            POR.POINTNAME POR_CODE,
			POD.POINTNAME POD_CODE,
    		NULL  "CONTRACT",  -- CONTRACT_NUMBER_LIST_ID
    		NULL  "MISC",  -- MISC_INFO_LIST_ID
    		TS.CURRENT_CORRECTION_NID  CURRENT_CORRECTION_ID 
        FROM ETAG_TRANSMISSION_SEGMENT TS, ETAG_MARKET_SEGMENT MS, TSIN_PSE_REGISTRY PS,  TSIN_POR_POD_POINT POR,  TSIN_POR_POD_POINT POD
        WHERE TS.ETAG_ID = p_ETAG_ID -- 100 -- 
			AND PS.TAGGING_ENTITY_ID(+) = MS.PSE_CODE
			AND MS.MARKET_SEGMENT_NID = TS.MARKET_SEGMENT_NID
			AND POR.PORPODPOINTID(+) = TS.POR_CODE 
			AND POD.PORPODPOINTID(+) = TS.POD_CODE 
    	ORDER BY MARKET_SEGMENT_ID,PHYSICAL_SEGMENT_ID;
		
		
EXCEPTION
    WHEN INSUFFICIENT_PRIVILEGES THEN
    	p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END ETAG_PHYSICAL_SEGMENTS;
----------------------------------------------------------------------------------------------------
PROCEDURE ETAG_PROFILES
	(
	p_ETAG_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
        SELECT 
    		P.PARENT_TYPE "USED BY",
            P.PROFILE_STYLE "USE TYPE",
    		P.PARENT_NID "PARENT ID",
    		V.START_DATE,
    		V.END_DATE,
    		V.MW_LEVEL MW  
        FROM ETAG_PROFILE P, ETAG_PROFILE_VALUE V 
        WHERE  ETAG_ID = p_ETAG_ID -- 100 -- 
            AND P.PROFILE_KEY_ID = V.PROFILE_KEY_ID 
    	ORDER BY V.START_DATE;

EXCEPTION
    WHEN INSUFFICIENT_PRIVILEGES THEN
    	p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END ETAG_PROFILES;
----------------------------------------------------------------------------------------------------
PROCEDURE TRANSACTION_TRAITS
	(
	p_TRAIT_GROUP_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT REF_CURSOR
	) AS
BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
        SELECT 
			A.DISPLAY_NAME,
			A.DISPLAY_ORDER,
			A.DATA_TYPE,
			A.FORMAT,
			A.COMBO_LIST,
			A.EDIT_MASK,
			A.TRAIT_GROUP_ID,
			A.TRAIT_INDEX,
			A.SYSTEM_OBJECT_ID
        FROM TRANSACTION_TRAIT_ATTRIBUTES A
        WHERE TRAIT_GROUP_ID = p_TRAIT_GROUP_ID 
    	ORDER BY A.DISPLAY_ORDER;

EXCEPTION
    WHEN INSUFFICIENT_PRIVILEGES THEN
    	p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END TRANSACTION_TRAITS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_TRANSACTION_TRAIT
	(
	p_TRAIT_GROUP_ID IN NUMBER,
	p_TRAIT_INDEX IN NUMBER,
	p_SYSTEM_OBJECT_ID IN NUMBER,
	p_DISPLAY_NAME IN VARCHAR2,
	p_DISPLAY_ORDER IN NUMBER,
	p_DATA_TYPE IN VARCHAR2,
	p_FORMAT IN VARCHAR2,
	p_COMBO_LIST IN VARCHAR2,
	p_EDIT_MASK IN VARCHAR2,
	p_STATUS OUT NUMBER
	) AS
	v_SYSTEM_OBJECT_ID NUMBER(9);
	v_PARENT_OBJECT_ID NUMBER(9);
	v_TRAIT_INDEX NUMBER(3);
	v_OBJECT_NAME SYSTEM_OBJECT.OBJECT_NAME%TYPE;
	
	PROCEDURE UPDATE_TRAIT_ATTRIBUTES
		(
		p_OBJECT_ID IN NUMBER
		) AS
	BEGIN
		SO.PUT_SYSTEM_OBJECT_ATTRIBUTE(p_OBJECT_ID, 3, p_FORMAT, p_STATUS);
		SO.PUT_SYSTEM_OBJECT_ATTRIBUTE(p_OBJECT_ID, 4, p_DATA_TYPE, p_STATUS);
		SO.PUT_SYSTEM_OBJECT_ATTRIBUTE(p_OBJECT_ID, 5, p_COMBO_LIST, p_STATUS);
		SO.PUT_SYSTEM_OBJECT_ATTRIBUTE(p_OBJECT_ID, 6, p_EDIT_MASK, p_STATUS);
	END UPDATE_TRAIT_ATTRIBUTES;
	
	PROCEDURE UPSERT_TRAIT
		(
		p_TRAIT_GROUP_ID IN NUMBER, 
		p_TRAIT_INDEX IN NUMBER, 
		p_SYSTEM_OBJECT_ID IN NUMBER
		) AS
	--Insert/Update the row into the Trait table.
	BEGIN
		INSERT INTO TRANSACTION_TRAIT(TRAIT_GROUP_ID, TRAIT_INDEX, SYSTEM_OBJECT_ID, ENTRY_DATE)
		VALUES(p_TRAIT_GROUP_ID, p_TRAIT_INDEX, p_SYSTEM_OBJECT_ID, SYSDATE);
	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			UPDATE TRANSACTION_TRAIT
			SET SYSTEM_OBJECT_ID = p_SYSTEM_OBJECT_ID
			WHERE TRAIT_GROUP_ID = p_TRAIT_GROUP_ID
				AND TRAIT_INDEX = p_TRAIT_INDEX;
	END UPSERT_TRAIT;
		
BEGIN
-- 	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
-- 		RAISE INSUFFICIENT_PRIVILEGES;
-- 	END IF;

	p_STATUS := GA.SUCCESS;
	
	--Get the ID for the parent module.
	SO.ID_FOR_SYSTEM_OBJECT(0, 'Transaction Traits', 0, 'Module', 'Default', TRUE, v_PARENT_OBJECT_ID);

	--See if the Trait already exists.
	SELECT NVL(MAX(SYSTEM_OBJECT_ID),0)
	INTO v_SYSTEM_OBJECT_ID
	FROM TRANSACTION_TRAIT
	WHERE TRAIT_GROUP_ID = p_TRAIT_GROUP_ID
		AND TRAIT_INDEX = p_TRAIT_INDEX; 
		
	--If we didn't get it the first time, try looking for the name incase
	--it was orphaned.
	IF v_SYSTEM_OBJECT_ID <= 0 THEN
		SELECT NVL(MAX(OBJECT_ID),0)
		INTO v_SYSTEM_OBJECT_ID
		FROM SYSTEM_OBJECT A, TRANSACTION_TRAIT_GROUP B
		WHERE B.TRAIT_GROUP_ID = p_TRAIT_GROUP_ID
			AND A.OBJECT_NAME = B.TRAIT_GROUP_NAME || '.' || p_TRAIT_INDEX;
		
		--Try inserting the trait, or updating its system_object_id
		UPSERT_TRAIT(p_TRAIT_GROUP_ID, p_TRAIT_INDEX, v_SYSTEM_OBJECT_ID);
				
	END IF;	
		
	IF v_SYSTEM_OBJECT_ID > 0 THEN
	
		--If so, update its attributes.
		UPDATE_TRAIT_ATTRIBUTES(p_SYSTEM_OBJECT_ID);
		
		--And update its display properties.
		UPDATE SYSTEM_OBJECT
		SET OBJECT_DISPLAY_NAME = p_DISPLAY_NAME,
			OBJECT_ORDER = p_DISPLAY_ORDER
		WHERE OBJECT_ID = p_SYSTEM_OBJECT_ID;
	
	ELSE
		--Get the next index for this group.
		IF p_TRAIT_INDEX > 0 THEN
			v_TRAIT_INDEX := p_TRAIT_INDEX;
		ELSE
			SELECT NVL(MAX(TRAIT_INDEX),0) + 1
			INTO v_TRAIT_INDEX
			FROM TRANSACTION_TRAIT
			WHERE TRAIT_GROUP_ID = p_TRAIT_GROUP_ID;
		END IF;
				
		--Create a new System Object.
		SELECT TRAIT_GROUP_NAME || '.' || TO_CHAR(v_TRAIT_INDEX)
		INTO v_OBJECT_NAME
		FROM TRANSACTION_TRAIT_GROUP
		WHERE TRAIT_GROUP_ID = p_TRAIT_GROUP_ID;
		
		SO.PUT_SYSTEM_OBJECT(v_SYSTEM_OBJECT_ID, 0, v_PARENT_OBJECT_ID, v_OBJECT_NAME, 0, 'Column', 'Default', NULL, 'Transaction Type Configuration Object', p_DISPLAY_NAME, p_DISPLAY_ORDER, 0, NULL);
		
		--Update its attributes.
		UPDATE_TRAIT_ATTRIBUTES(v_SYSTEM_OBJECT_ID);
		
		UPSERT_TRAIT(p_TRAIT_GROUP_ID, v_TRAIT_INDEX, v_SYSTEM_OBJECT_ID);
		
	END IF;
	
EXCEPTION
    WHEN INSUFFICIENT_PRIVILEGES THEN
    	p_STATUS := GA.INSUFFICIENT_PRIVILEGES;

END PUT_TRANSACTION_TRAIT;
----------------------------------------------------------------------------------------------------
PROCEDURE CONDITIONAL_FORMAT_ITEMS
	(
	p_CONDITIONAL_FORMAT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT REF_CURSOR
	) AS
BEGIN
	
	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT *
		FROM CONDITIONAL_FORMAT_ITEM A
		WHERE A.CONDITIONAL_FORMAT_ID = p_CONDITIONAL_FORMAT_ID
        ORDER BY A.ITEM_NUMBER;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END CONDITIONAL_FORMAT_ITEMS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_CONDITIONAL_FORMAT_ITEM
	(
	p_CONDITIONAL_FORMAT_ID IN NUMBER,
    p_ITEM_NUMBER IN NUMBER,
    p_COLOR_WHEN_FORMULA IN VARCHAR,
    p_FOREGROUND_COLOR IN NUMBER,
    p_BACKGROUND_COLOR IN NUMBER,
    p_IS_BOLD IN NUMBER,
    p_IS_ITALIC IN NUMBER,
    p_IS_STRIKE_THROUGH IN NUMBER,
    p_IS_UNDERLINE IN NUMBER,
	p_STATUS OUT NUMBER
	) AS
BEGIN
	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	UPDATE CONDITIONAL_FORMAT_ITEM A SET
        A.COLOR_WHEN_FORMULA = p_COLOR_WHEN_FORMULA,
        A.FOREGROUND_COLOR = p_FOREGROUND_COLOR,
        A.BACKGROUND_COLOR = p_BACKGROUND_COLOR,
        A.IS_BOLD = p_IS_BOLD,
        A.IS_ITALIC = p_IS_ITALIC,
        A.IS_STRIKE_THROUGH = p_IS_STRIKE_THROUGH,
        A.IS_UNDERLINE = p_IS_UNDERLINE
	 WHERE A.CONDITIONAL_FORMAT_ID = p_CONDITIONAL_FORMAT_ID
     AND A.ITEM_NUMBER = p_ITEM_NUMBER;

	IF SQL%NOTFOUND THEN
		INSERT INTO CONDITIONAL_FORMAT_ITEM
            (
            CONDITIONAL_FORMAT_ID,
            ITEM_NUMBER,
            COLOR_WHEN_FORMULA,
            FOREGROUND_COLOR,
            BACKGROUND_COLOR,
            IS_BOLD,
            IS_ITALIC,
            IS_STRIKE_THROUGH,
            IS_UNDERLINE
            )
		VALUES
            (
			p_CONDITIONAL_FORMAT_ID,
            p_ITEM_NUMBER,
            p_COLOR_WHEN_FORMULA,
            p_FOREGROUND_COLOR,
            p_BACKGROUND_COLOR,
            p_IS_BOLD,
            p_IS_ITALIC,
            p_IS_STRIKE_THROUGH,
            p_IS_UNDERLINE
            );
	END IF;

EXCEPTION
	WHEN DUP_VAL_ON_INDEX THEN
		p_STATUS := GA.DUPLICATE_ENTITY;
	WHEN INSUFFICIENT_PRIVILEGES THEN
		p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	WHEN OTHERS THEN
		RAISE;

END PUT_CONDITIONAL_FORMAT_ITEM;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_FORMAT_WITH_ITEMS
	(
	p_CONDITIONAL_FORMAT_NAME IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT REF_CURSOR
	) AS
BEGIN
	
	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT A.CONDITIONAL_FORMAT_ID,
            A.CONDITIONAL_FORMAT_NAME,
            B.COLOR_WHEN_FORMULA,
            B.FOREGROUND_COLOR,
            B.BACKGROUND_COLOR,
            B.IS_BOLD,
            B.IS_ITALIC,
            B.IS_STRIKE_THROUGH,
            B.IS_UNDERLINE
		FROM CONDITIONAL_FORMAT A, CONDITIONAL_FORMAT_ITEM B
		WHERE B.CONDITIONAL_FORMAT_ID = A.CONDITIONAL_FORMAT_ID
        AND A.CONDITIONAL_FORMAT_NAME = p_CONDITIONAL_FORMAT_NAME
        ORDER BY B.ITEM_NUMBER;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END GET_FORMAT_WITH_ITEMS;
----------------------------------------------------------------------------------------------------
END EM;
/
