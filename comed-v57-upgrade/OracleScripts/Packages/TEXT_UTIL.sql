CREATE OR REPLACE PACKAGE TEXT_UTIL IS
--Revision $Revision: 1.7 $

  -- Author  : JHUMPHRIES
  -- Created : 1/22/2008 9:47:35 PM
  -- Purpose : Function for converting values to readable text

-- TO_CHAR methods for converting IDs and lists to readable strings

FUNCTION TO_CHAR_STRING_LIST
	(
	p_STRINGS IN STRING_COLLECTION,
	p_INCLUDE_BRACKETS IN BOOLEAN := TRUE
	) RETURN VARCHAR2;
FUNCTION TO_CHAR_STRING_LIST
	(
	p_STRINGS IN GA.STRING_TABLE,
	p_INCLUDE_BRACKETS IN BOOLEAN := TRUE
	) RETURN VARCHAR2;
FUNCTION TO_CHAR_2D_STRING_LIST
	(
	p_TWO_DIMENSIONAL_STRING_LIST IN STRING_COLLECTION_COLLECTION
	) RETURN VARCHAR2;
FUNCTION TO_CHAR_NUMBER_LIST
	(
	p_NUMBERS IN NUMBER_COLLECTION,
	p_INCLUDE_BRACKETS IN BOOLEAN := TRUE
	) RETURN VARCHAR2;
FUNCTION TO_CHAR_2D_NUMBER_LIST
	(
	p_TWO_DIMENSIONAL_NUMBER_LIST IN NUMBER_COLLECTION_COLLECTION
	) RETURN VARCHAR2;

-- These use EI.GET_ENTITY_NAME
FUNCTION TO_CHAR_ENTITY
	(
	p_ENTITY_ID IN NUMBER,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_INCLUDE_DOMAIN IN BOOLEAN := FALSE,
	p_EXTERNAL_SYSTEM_ID IN NUMBER := NULL,
	p_IDENTIFIER_TYPE IN VARCHAR2 := ''
	) RETURN VARCHAR2;
FUNCTION TO_CHAR_ENTITY_LIST
	(
	p_ENTITIES IN NUMBER_COLLECTION,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_INCLUDE_DOMAIN IN BOOLEAN := FALSE,
	p_INCLUDE_BRACKETS IN BOOLEAN := TRUE
	) RETURN VARCHAR2;
FUNCTION TO_CHAR_ENTITY_LIST
	(
	p_ENTITIES IN ID_TABLE,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_INCLUDE_DOMAIN IN BOOLEAN := FALSE,
	p_INCLUDE_BRACKETS IN BOOLEAN := TRUE
	) RETURN VARCHAR2;
FUNCTION TO_CLOB_ENTITY_LIST
	(
	p_ENTITIES IN ID_TABLE,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_INCLUDE_DOMAIN IN BOOLEAN := FALSE,
	p_INITIAL_TEXT IN VARCHAR2 := NULL
	) RETURN CLOB;

FUNCTION TO_CLOB_ENTITY_LIST
	(
	p_ENTITIES IN NUMBER_COLLECTION,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_INCLUDE_DOMAIN IN BOOLEAN := FALSE,
	p_INITIAL_TEXT IN VARCHAR2 := NULL
	) RETURN CLOB;
-- These use consistent date format specified in System Dictionary
FUNCTION TO_CHAR_DATE
	(
	p_DATE IN DATE,
	p_SHOW_NULL_KEYWORD IN BOOLEAN := TRUE,
	p_HIDE_HIGH_LOW_DATES IN BOOLEAN := FALSE
	) RETURN VARCHAR2;
FUNCTION TO_CHAR_DATE_LIST
	(
	p_DATES IN DATE_COLLECTION,
	p_INCLUDE_BRACKETS IN BOOLEAN := TRUE,
	p_SHOW_NULL_KEYWORD IN BOOLEAN := TRUE,
	p_HIDE_HIGH_LOW_DATES IN BOOLEAN := FALSE
	) RETURN VARCHAR2;
FUNCTION TO_CHAR_DATE_RANGE
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SHOW_NULL_KEYWORD IN BOOLEAN := TRUE,
	p_HIDE_HIGH_LOW_DATES IN BOOLEAN := FALSE
	) RETURN VARCHAR2;
FUNCTION TO_CHAR_DATE_RANGE
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SHOW_NULL_KEYWORD IN NUMBER,
	p_HIDE_HIGH_LOW_DATES IN NUMBER
	) RETURN VARCHAR2;
FUNCTION TO_CHAR_2D_DATE_LIST
	(
	p_TWO_DIMENSIONAL_DATE_LIST IN DATE_COLLECTION_COLLECTION
	) RETURN VARCHAR2;
FUNCTION TO_CHAR_2D_TIME_LIST
	(
	p_TWO_DIMENSIONAL_TIME_LIST IN DATE_COLLECTION_COLLECTION
	) RETURN VARCHAR2;
FUNCTION TO_CHAR_TIME
	(
	p_TIME IN DATE
	) RETURN VARCHAR2;
FUNCTION TO_CHAR_TIME_LIST
	(
	p_TIMES IN DATE_COLLECTION,
	p_INCLUDE_BRACKETS IN BOOLEAN := TRUE
	) RETURN VARCHAR2;
FUNCTION TO_CHAR_TIME
	(
	p_TIME IN TIMESTAMP
	) RETURN VARCHAR2;
FUNCTION TO_CHAR_TIME
	(
	p_TIME IN TIMESTAMP WITH TIME ZONE
	) RETURN VARCHAR2;
    
FUNCTION TO_CHAR_BOOLEAN
    (
    p_BOOLEAN IN BOOLEAN
    ) RETURN VARCHAR2;

FUNCTION STRING_FROM_STRING_COLLECTION
	(
	p_STRINGS IN STRING_COLLECTION
	) RETURN VARCHAR2;

FUNCTION FIX_STRING_FOR_CSV(
	p_STRING		IN 	VARCHAR2
	) RETURN VARCHAR2;
END TEXT_UTIL;
/
CREATE OR REPLACE PACKAGE BODY TEXT_UTIL IS
----------------------------------------------------------------------------------------------------
g_DATE_FORMAT VARCHAR2(32);
g_TIME_FORMAT VARCHAR2(32);
g_TIMESTAMP_FORMAT VARCHAR2(32);
g_TIMESTAMP_TZ_FORMAT VARCHAR2(32);
----------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR2 IS
BEGIN
    RETURN '$Revision: 1.7 $';
END WHAT_VERSION;
----------------------------------------------------------------------------------------------------
FUNCTION APPEND
(
p_ORIGINAL_VAL VARCHAR2,
p_APPEND_VAL VARCHAR2
) RETURN VARCHAR2 AS
v_NEW_VAL VARCHAR2(4000);
BEGIN
	IF p_ORIGINAL_VAL IS NULL THEN
		v_NEW_VAL := SUBSTR(p_APPEND_VAL, 1, 4000);
	ELSIF p_APPEND_VAL IS NULL THEN
		v_NEW_VAL := SUBSTR(p_ORIGINAL_VAL, 1, 4000);
	ELSIF LENGTH(p_ORIGINAL_VAL) + LENGTH(p_APPEND_VAL) < 4000 THEN
		v_NEW_VAL := p_ORIGINAL_VAL || p_APPEND_VAL;
	ELSIF LENGTH(p_ORIGINAL_VAL) < 4000 THEN
		-- Append as much of the p_APPEND_VAL as you can to the p_NEW_VAL string
		v_NEW_VAL:=p_ORIGINAL_VAL||SUBSTR(p_APPEND_VAL,1,(4000-LENGTH(p_ORIGINAL_VAL)));
	ELSE
		v_NEW_VAL := SUBSTR(p_ORIGINAL_VAL, 1, 4000);
	END IF;

	RETURN v_NEW_VAL;
END APPEND;
----------------------------------------------------------------------------------------------------
FUNCTION TO_CHAR_STRING_LIST
	(
	p_STRINGS IN STRING_COLLECTION,
	p_INCLUDE_BRACKETS IN BOOLEAN := TRUE
	) RETURN VARCHAR2 IS
v_IDX PLS_INTEGER;
v_RET VARCHAR2(4000);
v_FIRST BOOLEAN := TRUE;
BEGIN
	IF p_INCLUDE_BRACKETS THEN
		v_RET := '[';
	END IF;
	IF p_STRINGS IS NOT NULL THEN
		v_IDX := p_STRINGS.FIRST;
		WHILE p_STRINGS.EXISTS(v_IDX) LOOP
			IF v_FIRST THEN
				v_FIRST := FALSE;
			ELSE
				v_RET := APPEND(v_RET,',');
			END IF;

			v_RET := APPEND(v_RET, UT.GET_LITERAL_FOR_STRING(p_STRINGS(v_IDX)) ||' ');
			v_IDX := p_STRINGS.NEXT(v_IDX);
		END LOOP;
	END IF;
	IF p_INCLUDE_BRACKETS THEN
		v_RET := APPEND(v_RET,']');
	END IF;

	RETURN v_RET;
END TO_CHAR_STRING_LIST;
----------------------------------------------------------------------------------------------------

FUNCTION STRING_FROM_STRING_COLLECTION
	(
	p_STRINGS IN STRING_COLLECTION
	) RETURN VARCHAR2 IS
v_IDX PLS_INTEGER;
v_RET VARCHAR2(4000);
v_FIRST BOOLEAN := TRUE;
BEGIN

	IF p_STRINGS IS NOT NULL THEN
		v_IDX := p_STRINGS.FIRST;
		WHILE p_STRINGS.EXISTS(v_IDX) LOOP
			IF v_FIRST THEN
				v_FIRST := FALSE;
			ELSE
				v_RET := APPEND(v_RET,',');
			END IF;

			v_RET := APPEND(v_RET, p_STRINGS(v_IDX));
			v_IDX := p_STRINGS.NEXT(v_IDX);
		END LOOP;
	END IF;
	
	RETURN v_RET;

END STRING_FROM_STRING_COLLECTION;
----------------------------------------------------------------------------------------------------
FUNCTION TO_CHAR_STRING_LIST
	(
	p_STRINGS IN GA.STRING_TABLE,
	p_INCLUDE_BRACKETS IN BOOLEAN := TRUE
	) RETURN VARCHAR2 IS
v_IDX PLS_INTEGER;
v_RET VARCHAR2(4000);
v_FIRST BOOLEAN := TRUE;
BEGIN
	IF p_INCLUDE_BRACKETS THEN
		v_RET := '[';
	END IF;
	IF p_STRINGS IS NOT NULL THEN
		v_IDX := p_STRINGS.FIRST;
		WHILE p_STRINGS.EXISTS(v_IDX) LOOP
			IF v_FIRST THEN
				v_FIRST := FALSE;
			ELSE
				v_RET := APPEND(v_RET,',');
			END IF;
			v_RET := APPEND(v_RET, UT.GET_LITERAL_FOR_STRING(p_STRINGS(v_IDX)) || ' ');
			v_IDX := p_STRINGS.NEXT(v_IDX);
		END LOOP;
	END IF;
	IF p_INCLUDE_BRACKETS THEN
		v_RET := APPEND(v_RET,']');
	END IF;

	RETURN v_RET;
END TO_CHAR_STRING_LIST;
----------------------------------------------------------------------------------------------------
FUNCTION TO_CHAR_2D_STRING_LIST
	(
	p_TWO_DIMENSIONAL_STRING_LIST IN STRING_COLLECTION_COLLECTION
	) RETURN VARCHAR2 IS
v_IDX PLS_INTEGER;
v_RET VARCHAR2(4000);
v_FIRST BOOLEAN := TRUE;
BEGIN
	v_RET := '[';
	IF p_TWO_DIMENSIONAL_STRING_LIST IS NOT NULL THEN
		v_IDX := p_TWO_DIMENSIONAL_STRING_LIST.FIRST;
		WHILE p_TWO_DIMENSIONAL_STRING_LIST.EXISTS(v_IDX) LOOP
			IF v_FIRST THEN
				v_FIRST := FALSE;
			ELSE
				v_RET := APPEND(v_RET,',');
			END IF;
			v_RET := APPEND(v_RET, TO_CHAR_STRING_LIST(p_TWO_DIMENSIONAL_STRING_LIST(v_IDX)));
			v_IDX := p_TWO_DIMENSIONAL_STRING_LIST.NEXT(v_IDX);
		END LOOP;
	END IF;
	v_RET := APPEND(v_RET,']');
	RETURN v_RET;
END TO_CHAR_2D_STRING_LIST;
----------------------------------------------------------------------------------------------------
FUNCTION TO_CHAR_NUMBER_LIST
	(
	p_NUMBERS IN NUMBER_COLLECTION,
	p_INCLUDE_BRACKETS IN BOOLEAN := TRUE
	) RETURN VARCHAR2 IS
v_IDX PLS_INTEGER;
v_RET VARCHAR2(4000);
v_FIRST BOOLEAN := TRUE;
BEGIN
	IF p_INCLUDE_BRACKETS THEN
		v_RET := '[';
	END IF;
	IF p_NUMBERS IS NOT NULL THEN
		v_IDX := p_NUMBERS.FIRST;
		WHILE p_NUMBERS.EXISTS(v_IDX) LOOP
			IF v_FIRST THEN
				v_FIRST := FALSE;
			ELSE
				v_RET := APPEND(v_RET,',');
			END IF;
			v_RET := APPEND(v_RET, UT.GET_LITERAL_FOR_NUMBER(p_NUMBERS(v_IDX))||' ');
			v_IDX := p_NUMBERS.NEXT(v_IDX);
		END LOOP;
	END IF;

	IF p_INCLUDE_BRACKETS THEN
		v_RET := APPEND(v_RET,']');
	END IF;

	RETURN v_RET;
END TO_CHAR_NUMBER_LIST;
----------------------------------------------------------------------------------------------------
FUNCTION TO_CHAR_2D_NUMBER_LIST
	(
	p_TWO_DIMENSIONAL_NUMBER_LIST IN NUMBER_COLLECTION_COLLECTION
	) RETURN VARCHAR2 IS
v_IDX PLS_INTEGER;
v_RET VARCHAR2(4000);
v_FIRST BOOLEAN := TRUE;
BEGIN
	v_RET := '[';
	IF p_TWO_DIMENSIONAL_NUMBER_LIST IS NOT NULL THEN
		v_IDX := p_TWO_DIMENSIONAL_NUMBER_LIST.FIRST;
		WHILE p_TWO_DIMENSIONAL_NUMBER_LIST.EXISTS(v_IDX) LOOP
			IF v_FIRST THEN
				v_FIRST := FALSE;
			ELSE
				v_RET := APPEND(v_RET,',');
			END IF;
			v_RET := APPEND(v_RET, TO_CHAR_NUMBER_LIST(p_TWO_DIMENSIONAL_NUMBER_LIST(v_IDX)));
			v_IDX := p_TWO_DIMENSIONAL_NUMBER_LIST.NEXT(v_IDX);
		END LOOP;
	END IF;
	v_RET := APPEND(v_RET,']');
	RETURN v_RET;
END TO_CHAR_2D_NUMBER_LIST;
----------------------------------------------------------------------------------------------------
FUNCTION TO_CHAR_ENTITY
	(
	p_ENTITY_ID IN NUMBER,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_INCLUDE_DOMAIN IN BOOLEAN := FALSE,
	p_EXTERNAL_SYSTEM_ID IN NUMBER := NULL,
	p_IDENTIFIER_TYPE IN VARCHAR2 := ''
	) RETURN VARCHAR2 IS
v_PREFIX VARCHAR2(256);
BEGIN
	IF p_INCLUDE_DOMAIN THEN
		v_PREFIX := TO_CHAR_ENTITY(p_ENTITY_DOMAIN_ID, EC.ED_ENTITY_DOMAIN, FALSE)||': ';
	END IF;
	IF p_ENTITY_ID IS NULL THEN
		RETURN v_PREFIX||'NULL';
	ELSIF p_ENTITY_ID = CONSTANTS.ALL_ID THEN
		RETURN v_PREFIX||'All';
	ELSE
		BEGIN
			IF p_EXTERNAL_SYSTEM_ID IS NOT NULL THEN
				RETURN v_PREFIX||EI.GET_ENTITY_IDENTIFIER_EXTSYS(p_ENTITY_DOMAIN_ID, p_ENTITY_ID, p_EXTERNAL_SYSTEM_ID, p_IDENTIFIER_TYPE);
			ELSE
				RETURN v_PREFIX||EI.GET_ENTITY_NAME(p_ENTITY_DOMAIN_ID, p_ENTITY_ID);
			END IF;
		EXCEPTION
			WHEN MSGCODES.e_ERR_NO_SUCH_ENTRY THEN
				RETURN v_PREFIX||'?{'||p_ENTITY_ID||'}';
		END;
	END IF;
END TO_CHAR_ENTITY;
----------------------------------------------------------------------------------------------------
FUNCTION TO_CHAR_ENTITY_LIST
	(
	p_ENTITIES IN NUMBER_COLLECTION,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_INCLUDE_DOMAIN IN BOOLEAN := FALSE,
	p_INCLUDE_BRACKETS IN BOOLEAN := TRUE
	) RETURN VARCHAR2 IS
v_IDX PLS_INTEGER;
v_RET VARCHAR2(4000);
v_FIRST BOOLEAN := TRUE;
BEGIN
	IF p_INCLUDE_DOMAIN THEN
		v_RET := TO_CHAR_ENTITY(p_ENTITY_DOMAIN_ID, EC.ED_ENTITY_DOMAIN, FALSE)||':';
	END IF;
	IF p_INCLUDE_BRACKETS THEN
		v_RET := v_RET||'[';
	END IF;

	IF p_ENTITIES IS NOT NULL THEN
		v_IDX := p_ENTITIES.FIRST;
		WHILE p_ENTITIES.EXISTS(v_IDX) LOOP
			IF v_FIRST THEN
				v_FIRST := FALSE;
			ELSE
				v_RET := APPEND(v_RET,',');
			END IF;
			v_RET := APPEND(v_RET, TO_CHAR_ENTITY(p_ENTITIES(v_IDX), p_ENTITY_DOMAIN_ID, FALSE));
			v_IDX := p_ENTITIES.NEXT(v_IDX);
		END LOOP;
	END IF;

	IF p_INCLUDE_BRACKETS THEN
		v_RET := APPEND(v_RET,']');
	END IF;

	RETURN v_RET;
END TO_CHAR_ENTITY_LIST;
----------------------------------------------------------------------------------------------------
FUNCTION TO_CHAR_ENTITY_LIST
	(
	p_ENTITIES IN ID_TABLE,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_INCLUDE_DOMAIN IN BOOLEAN := FALSE,
	p_INCLUDE_BRACKETS IN BOOLEAN := TRUE
	) RETURN VARCHAR2 IS
v_RET VARCHAR2(4000);
v_NUM_COLL NUMBER_COLLECTION;
BEGIN
	UT.NUMBER_COLL_FROM_ID_TABLE(p_ENTITIES, v_NUM_COLL);
	v_RET := TO_CHAR_ENTITY_LIST(v_NUM_COLL,p_ENTITY_DOMAIN_ID,p_INCLUDE_DOMAIN,p_INCLUDE_BRACKETS);
	RETURN v_RET;
END TO_CHAR_ENTITY_LIST;
----------------------------------------------------------------------------------------------------
FUNCTION TO_CLOB_ENTITY_LIST
	(
	p_ENTITIES IN ID_TABLE,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_INCLUDE_DOMAIN IN BOOLEAN := FALSE,
	p_INITIAL_TEXT IN VARCHAR2 := NULL
	) RETURN CLOB IS
v_RET CLOB;
v_NUM_COLL NUMBER_COLLECTION;

BEGIN
	UT.NUMBER_COLL_FROM_ID_TABLE(p_ENTITIES, v_NUM_COLL);
    v_RET := TO_CLOB_ENTITY_LIST(v_NUM_COLL,p_ENTITY_DOMAIN_ID,p_INCLUDE_DOMAIN,p_INITIAL_TEXT);

	RETURN v_RET;
END TO_CLOB_ENTITY_LIST;
----------------------------------------------------------------------------------------------------
FUNCTION TO_CLOB_ENTITY_LIST
	(
	p_ENTITIES IN NUMBER_COLLECTION,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_INCLUDE_DOMAIN IN BOOLEAN := FALSE,
	p_INITIAL_TEXT IN VARCHAR2 := NULL
	) RETURN CLOB IS
v_IDX PLS_INTEGER;
v_RET CLOB;

	PROCEDURE APPEND(p_STR IN VARCHAR2) IS
	BEGIN
		DBMS_LOB.WRITEAPPEND(v_RET, LENGTH(p_STR || UTL_TCP.CRLF), p_STR || UTL_TCP.CRLF);
	END APPEND;

BEGIN

	DBMS_LOB.CREATETEMPORARY(v_RET, TRUE);
	DBMS_LOB.OPEN(v_RET, DBMS_LOB.LOB_READWRITE);

	IF p_INITIAL_TEXT IS NOT NULL THEN
		APPEND(p_INITIAL_TEXT);
	END IF;
	IF p_INCLUDE_DOMAIN THEN
		APPEND(TO_CHAR_ENTITY(p_ENTITY_DOMAIN_ID, EC.ED_ENTITY_DOMAIN, FALSE)||':');
	END IF;

	IF p_ENTITIES IS NOT NULL THEN
		v_IDX := p_ENTITIES.FIRST;
		WHILE p_ENTITIES.EXISTS(v_IDX) LOOP
			APPEND(TO_CHAR_ENTITY(p_ENTITIES(v_IDX), p_ENTITY_DOMAIN_ID, FALSE));
			v_IDX := p_ENTITIES.NEXT(v_IDX);
		END LOOP;
	END IF;

	DBMS_LOB.CLOSE(v_RET);
	RETURN v_RET;

EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			IF DBMS_LOB.ISOPEN(v_RET)<>0 THEN
				DBMS_LOB.CLOSE(v_RET);
			END IF;
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE('Error closing LOB');
		END;
		ERRS.LOG_AND_RAISE;
END TO_CLOB_ENTITY_LIST;
----------------------------------------------------------------------------------------------------
FUNCTION TO_CHAR_DATE
	(
	p_DATE IN DATE,
	p_SHOW_NULL_KEYWORD IN BOOLEAN := TRUE,
	p_HIDE_HIGH_LOW_DATES IN BOOLEAN := FALSE
	) RETURN VARCHAR2 IS
v_DATE DATE;
BEGIN
	IF p_HIDE_HIGH_LOW_DATES AND (p_DATE = CONSTANTS.LOW_DATE OR p_DATE = CONSTANTS.HIGH_DATE) THEN
		v_DATE := NULL;
	ELSE
		v_DATE := p_DATE;
	END IF;

	IF v_DATE IS NULL  AND p_SHOW_NULL_KEYWORD THEN
		RETURN 'NULL';
	ELSE
		RETURN TO_CHAR(v_DATE, g_DATE_FORMAT);
	END IF;
END TO_CHAR_DATE;
----------------------------------------------------------------------------------------------------
FUNCTION TO_CHAR_DATE_LIST
	(
	p_DATES IN DATE_COLLECTION,
	p_INCLUDE_BRACKETS IN BOOLEAN := TRUE,
	p_SHOW_NULL_KEYWORD IN BOOLEAN := TRUE,
	p_HIDE_HIGH_LOW_DATES IN BOOLEAN := FALSE
	) RETURN VARCHAR2 IS
v_IDX PLS_INTEGER;
v_RET VARCHAR2(4000);
v_FIRST BOOLEAN := TRUE;
BEGIN
	IF p_INCLUDE_BRACKETS THEN
		v_RET := '[';
	END IF;
	IF p_DATES IS NOT NULL THEN
		v_IDX := p_DATES.FIRST;
		WHILE p_DATES.EXISTS(v_IDX) LOOP
			IF v_FIRST THEN
				v_FIRST := FALSE;
			ELSE
				v_RET := APPEND(v_RET,',');
			END IF;
			v_RET := APPEND(v_RET, TO_CHAR_DATE(p_DATES(v_IDX), p_SHOW_NULL_KEYWORD, p_HIDE_HIGH_LOW_DATES)||' ');
			v_IDX := p_DATES.NEXT(v_IDX);
		END LOOP;
	END IF;

	IF p_INCLUDE_BRACKETS THEN
		v_RET := APPEND(v_RET,']');
	END IF;

	RETURN v_RET;
END TO_CHAR_DATE_LIST;
----------------------------------------------------------------------------------------------------
FUNCTION TO_CHAR_DATE_RANGE
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SHOW_NULL_KEYWORD IN BOOLEAN := TRUE,
	p_HIDE_HIGH_LOW_DATES IN BOOLEAN := FALSE
	) RETURN VARCHAR2 IS
BEGIN
	RETURN TO_CHAR_DATE(p_BEGIN_DATE, p_SHOW_NULL_KEYWORD, p_HIDE_HIGH_LOW_DATES) || ' -> ' || TO_CHAR_DATE(p_END_DATE, p_SHOW_NULL_KEYWORD, p_HIDE_HIGH_LOW_DATES);
END TO_CHAR_DATE_RANGE;
----------------------------------------------------------------------------------------------------
FUNCTION TO_CHAR_DATE_RANGE
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SHOW_NULL_KEYWORD IN NUMBER,
	p_HIDE_HIGH_LOW_DATES IN NUMBER
	) RETURN VARCHAR2 IS
BEGIN
	RETURN TO_CHAR_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, UT.BOOLEAN_FROM_NUMBER(p_SHOW_NULL_KEYWORD), UT.BOOLEAN_FROM_NUMBER(p_HIDE_HIGH_LOW_DATES));
END TO_CHAR_DATE_RANGE;
----------------------------------------------------------------------------------------------------
FUNCTION TO_CHAR_2D_DATE_LIST
	(
	p_TWO_DIMENSIONAL_DATE_LIST IN DATE_COLLECTION_COLLECTION
	) RETURN VARCHAR2 IS
v_IDX PLS_INTEGER;
v_RET VARCHAR2(4000);
v_FIRST BOOLEAN := TRUE;
BEGIN
	v_RET := '[';
	IF p_TWO_DIMENSIONAL_DATE_LIST IS NOT NULL THEN
		v_IDX := p_TWO_DIMENSIONAL_DATE_LIST.FIRST;
		WHILE p_TWO_DIMENSIONAL_DATE_LIST.EXISTS(v_IDX) LOOP
			IF v_FIRST THEN
				v_FIRST := FALSE;
			ELSE
				v_RET := APPEND(v_RET,',');
			END IF;
			v_RET := APPEND(v_RET,  TO_CHAR_DATE_LIST(p_TWO_DIMENSIONAL_DATE_LIST(v_IDX)));
			v_IDX := p_TWO_DIMENSIONAL_DATE_LIST.NEXT(v_IDX);
		END LOOP;
	END IF;
	v_RET := APPEND(v_RET,']');
	RETURN v_RET;
END TO_CHAR_2D_DATE_LIST;
----------------------------------------------------------------------------------------------------
FUNCTION TO_CHAR_2D_TIME_LIST
	(
	p_TWO_DIMENSIONAL_TIME_LIST IN DATE_COLLECTION_COLLECTION
	) RETURN VARCHAR2 IS
v_IDX PLS_INTEGER;
v_RET VARCHAR2(4000);
v_FIRST BOOLEAN := TRUE;
BEGIN
	v_RET := '[';
	IF p_TWO_DIMENSIONAL_TIME_LIST IS NOT NULL THEN
		v_IDX := p_TWO_DIMENSIONAL_TIME_LIST.FIRST;
		WHILE p_TWO_DIMENSIONAL_TIME_LIST.EXISTS(v_IDX) LOOP
			IF v_FIRST THEN
				v_FIRST := FALSE;
			ELSE
				v_RET := APPEND(v_RET,',');
			END IF;
			v_RET := APPEND(v_RET,TO_CHAR_TIME_LIST(p_TWO_DIMENSIONAL_TIME_LIST(v_IDX)));
			v_IDX := p_TWO_DIMENSIONAL_TIME_LIST.NEXT(v_IDX);
		END LOOP;
	END IF;
	v_RET := APPEND(v_RET,']');
	RETURN v_RET;
END TO_CHAR_2D_TIME_LIST;
----------------------------------------------------------------------------------------------------
FUNCTION TO_CHAR_TIME
	(
	p_TIME IN DATE
	) RETURN VARCHAR2 IS
BEGIN
	IF p_TIME IS NULL THEN
		RETURN 'NULL';
	ELSE
		RETURN TO_CHAR(p_TIME, g_TIME_FORMAT);
	END IF;
END TO_CHAR_TIME;
----------------------------------------------------------------------------------------------------
FUNCTION TO_CHAR_TIME_LIST
	(
	p_TIMES IN DATE_COLLECTION,
	p_INCLUDE_BRACKETS IN BOOLEAN := TRUE
	) RETURN VARCHAR2 IS
v_IDX PLS_INTEGER;
v_RET VARCHAR2(4000);
v_FIRST BOOLEAN := TRUE;
BEGIN
	IF p_INCLUDE_BRACKETS THEN
		v_RET := '[';
	END IF;
	IF p_TIMES IS NOT NULL THEN
		v_IDX := p_TIMES.FIRST;
		WHILE p_TIMES.EXISTS(v_IDX) LOOP
			IF v_FIRST THEN
				v_FIRST := FALSE;
			ELSE
				v_RET := APPEND(v_RET,',');
			END IF;
			v_RET := APPEND(v_RET, TO_CHAR_TIME(p_TIMES(v_IDX))||' ');
			v_IDX := p_TIMES.NEXT(v_IDX);
		END LOOP;
	END IF;

	IF p_INCLUDE_BRACKETS THEN
		v_RET := APPEND(v_RET,']');
	END IF;

	RETURN v_RET;
END TO_CHAR_TIME_LIST;
----------------------------------------------------------------------------------------------------
FUNCTION TO_CHAR_TIME
	(
	p_TIME IN TIMESTAMP
	) RETURN VARCHAR2 IS
BEGIN
	IF p_TIME IS NULL THEN
		RETURN 'NULL';
	ELSE
		RETURN TO_CHAR(p_TIME, g_TIMESTAMP_FORMAT);
	END IF;
END TO_CHAR_TIME;
----------------------------------------------------------------------------------------------------
FUNCTION TO_CHAR_TIME
	(
	p_TIME IN TIMESTAMP WITH TIME ZONE
	) RETURN VARCHAR2 IS
BEGIN
	IF p_TIME IS NULL THEN
		RETURN 'NULL';
	ELSE
		RETURN TO_CHAR(p_TIME, g_TIMESTAMP_TZ_FORMAT);
	END IF;
END TO_CHAR_TIME;
----------------------------------------------------------------------------------------------------
FUNCTION TO_CHAR_BOOLEAN
    (
    p_BOOLEAN IN BOOLEAN
    ) RETURN VARCHAR2 IS
    
BEGIN

    IF p_BOOLEAN THEN
        RETURN 'TRUE';
    ELSE
        RETURN 'FALSE';
    END IF;
    
END TO_CHAR_BOOLEAN;
----------------------------------------------------------------------------------------------------
FUNCTION FIX_STRING_FOR_CSV(
	p_STRING		IN 	VARCHAR2
	) RETURN VARCHAR2 AS
	v_FIXED_STRING 		VARCHAR2(32767);
BEGIN
	v_FIXED_STRING := REPLACE(p_STRING, '"', '""');

	IF (INSTR(v_FIXED_STRING, ',') > 0 OR INSTR(v_FIXED_STRING, '"') > 0) THEN
		v_FIXED_STRING := '"' || v_FIXED_STRING || '"';
	END IF;

	RETURN v_FIXED_STRING;
END FIX_STRING_FOR_CSV;
----------------------------------------------------------------------------------------------------
BEGIN
	g_DATE_FORMAT := NVL(GET_DICTIONARY_VALUE('Date Format', 0, 'System','Logging'), 'YYYY-MM-DD');
	g_TIME_FORMAT := NVL(GET_DICTIONARY_VALUE('Time Format', 0, 'System','Logging'), 'YYYY-MM-DD HH24:MI:SS');
	g_TIMESTAMP_FORMAT := NVL(GET_DICTIONARY_VALUE('Timestamp Format', 0, 'System','Logging'), 'YYYY-MM-DD HH24:MI:SSXFF');
	g_TIMESTAMP_TZ_FORMAT := NVL(GET_DICTIONARY_VALUE('Timestamp with Time Zone Format', 0, 'System','Logging'), 'YYYY-MM-DD HH24:MI:SSXFF TZR');
END TEXT_UTIL;
/
