CREATE OR REPLACE PACKAGE IT AS
--Revision $Revision: 1.162 $

-- Interchange transaction package.

FUNCTION WHAT_VERSION RETURN VARCHAR;

PROCEDURE READ_INTERCHANGE_TRANSACTION
	(
	p_TRANSACTION_ID IN NUMBER,
	p_VIEW_BEGIN IN DATE,
	p_VIEW_END IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TRANSACTION_NAME OUT VARCHAR,
	p_TRANSACTION_ALIAS OUT VARCHAR,
	p_TRANSACTION_DESC OUT VARCHAR,
	p_TRANSACTION_TYPE OUT VARCHAR,
	p_TRANSACTION_IDENTIFIER OUT VARCHAR,
	p_IS_FIRM OUT VARCHAR,
	p_IS_IMPORT_SCHEDULE OUT VARCHAR,
	p_IS_EXPORT_SCHEDULE OUT VARCHAR,
	p_TRANSACTION_STATUS OUT VARCHAR,
	p_TRANSACTION_INTERVAL OUT VARCHAR,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE,
	p_PURCHASER OUT VARCHAR,
	p_SELLER OUT VARCHAR,
	p_CONTRACT OUT VARCHAR,
	p_SC OUT VARCHAR,
	p_POR OUT VARCHAR,
	p_POD OUT VARCHAR,
	p_SCHEDULER OUT VARCHAR,
	p_COMMODITY OUT VARCHAR,
	p_SERVICE_TYPE OUT VARCHAR,
	p_COMMODITY_TYPE OUT VARCHAR,
	p_COMMODITY_UNIT OUT VARCHAR,
	p_COMMODITY_UNIT_FORMAT OUT VARCHAR,
	p_COMMODITY_PRICE_UNIT OUT VARCHAR,
	p_COMMODITY_PRICE_FORMAT OUT VARCHAR,
	p_TP_CONTRACT_NUM OUT VARCHAR,
	p_TP_CONTRACT_NAME OUT VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE SCHEDULE_FILL
	(
	p_TRANSACTION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_AMOUNT IN VARCHAR,
	p_PRICE IN VARCHAR,
	p_TEMPLATE IN VARCHAR,
	p_BEGIN_HOUR IN NUMBER,
	p_END_HOUR IN NUMBER,
	p_INCLUDE_HOLIDAYS IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATUS OUT NUMBER,
	p_TO_WORK IN BOOLEAN := FALSE,
	p_WORK_ID IN NUMBER := 0,
    p_USE_INTERVAL IN VARCHAR2 := NULL,
    p_AMOUNT2 IN NUMBER := NULL
	);

PROCEDURE GET_SCHEDULE_FILL_RECORDS
	(
	p_TRANSACTION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_AMOUNT IN VARCHAR,
	p_PRICE IN VARCHAR,
	p_TEMPLATE IN VARCHAR,
	p_BEGIN_HOUR IN NUMBER,
	p_END_HOUR IN NUMBER,
	p_INCLUDE_HOLIDAYS IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE SCHEDULE_UPDATE_REQUEST
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_ARGUMENTS IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_IT_SCHEDULE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_AMOUNT IN NUMBER,
	p_PRICE IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_IT_SCHEDULE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SCHEDULE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_AMOUNT IN NUMBER,
	p_PRICE IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE SCHEDULE_COPY_REQUEST
	(
	p_SRC_TRANSACTION_ID IN NUMBER,
	p_SRC_BEGIN_DATE IN DATE,
	p_SRC_END_DATE IN DATE,
	p_SRC_AS_OF_DATE IN DATE,
	p_SRC_SCHEDULE_TYPE IN NUMBER,
	p_SRC_EXTERNAL IN NUMBER,
	p_TRG_TRANSACTION_IDs IN VARCHAR2,
	p_TRG_BEGIN_DATE IN DATE,
	p_TRG_END_DATE IN DATE,
	p_TRG_AS_OF_DATE IN DATE,
	p_TRG_SCHEDULE_TYPE IN NUMBER,
	p_TRG_EXTERNAL IN NUMBER,
	p_TRG_DELETE IN NUMBER,
    p_COPY_AMOUNT IN NUMBER,
	p_COPY_PRICE IN NUMBER,
	p_COPY_BID_OFFER_AMOUNT IN NUMBER,
	p_COPY_BID_OFFER_PRICE IN NUMBER,
	p_TIME_ZONE IN CHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_TRANSACTION_IDENTIFIER
	(
	p_TRANSACTION_ID IN NUMBER,
	p_TRANSACTION_IDENTIFIER IN VARCHAR
	);

PROCEDURE PUT_TRANSACTION_COMMODITY
	(
	p_TRANSACTION_ID IN NUMBER,
	p_COMMODITY_NAME IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_TRANSACTION_DATE_RANGE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	);

PROCEDURE SET_TRANSACTION_DATE_RANGE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE SCHEDULE_TEMPLATE_REQUEST
	(
	p_METHOD_OPTION IN VARCHAR,
	p_TEMPLATE_NAME IN VARCHAR,
	p_START_HOUR_END IN NUMBER,
	p_STOP_HOUR_END IN NUMBER,
	p_INTERIOR_PERIOD IN NUMBER,
	p_DAY_OF_WEEK IN VARCHAR,
	p_INCLUDE_HOLIDAYS IN NUMBER,
	p_TEMPLATE_ORDER IN NUMBER,
	p_OLD_TEMPLATE_NAME IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_TP_CONTRACT_NUMBER
	(
	p_CONTRACT_ID IN NUMBER,
	p_TP_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CONTRACT_NAME IN VARCHAR2,
	p_CONTRACT_NUMBER IN VARCHAR2,
	p_OLD_TP_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE TRIM_IT_SCHEDULE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER
	) ;

PROCEDURE IMPORT_EXPORT_TRANSACTION
	(
	p_OPERATION IN VARCHAR,
	p_TRANSACTION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_VERSION_ID IN NUMBER,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE IMPORT_EXPORT_NAMES
	(
	p_OPERATION IN VARCHAR,
	p_FORMAT IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) ;

PROCEDURE FILE_EXPORT_REQUEST
	(
	p_FILE_FORMAT IN VARCHAR,
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PJM_EXPORT_DATA
	(
	p_TRANSACTION_IDS IN VARCHAR2,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_AS_OF_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE IMPORT_SPPXML_RECORDS
	(
	p_DATES IN VARCHAR2,
	p_NAMES IN VARCHAR2,
	p_TYPES IN VARCHAR2,
	p_MWS IN VARCHAR2,
	p_PRICES IN VARCHAR2,
	p_SCHEDULE_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_AS_OF_DATE IN DATE,
	p_NUM OUT NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_TRANSACTION_TYPE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_TYPE OUT VARCHAR2
	);

PROCEDURE POD_NAMES
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE POR_NAMES
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PURCHASER_NAMES
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PSE_NAMES
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE CA_NAMES
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE SELLER_NAMES
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE EDC_NAMES
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE TP_NAMES
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE SERVICE_TYPE_NAMES
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE SERVICE_ZONE_NAMES
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);
/*
PROCEDURE BALANCE_TRANSACTION_NAMES
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE BALANCE_SALE_NAMES
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE BALANCE_SUPPLY_NAMES
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);
*/
PROCEDURE GET_SCHEDULER_TREE
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
    p_IS_BID_OFFER IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE GET_IT_SCHEDULE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INCLUDE_EXTERNAL IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE GET_TRANSACTION_TOTALS
    (
    p_SCHEDULE_TYPE1 IN NUMBER,
    p_SCHEDULE_STATE1 IN NUMBER,
    p_SCHEDULE_TYPE2 IN NUMBER,
    p_SCHEDULE_STATE2 IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_TRANSACTION_IDS IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE GET_IT_STATUS
	(
	p_TRANSACTION_ID IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_TRANSACTION_STATUS_NAME OUT VARCHAR,
	p_TRANSACTION_IS_ACTIVE OUT NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_IT_STATUS
	(
	p_TRANSACTION_ID IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_TRANSACTION_STATUS_NAME IN VARCHAR,
	p_TRANSACTION_IS_ACTIVE IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE IT_STATUS_LIST
	(
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE IT_STATUS_NAME_LIST
	(
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE DATE_RANGE
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_MINUTES IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE GET_PHYSICAL_POSITION
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_COMMODITY_TYPE IN VARCHAR,
	p_SCHEDULE_TYPE IN NUMBER,
	p_PORPOD_TYPE IN VARCHAR,
	p_POD_ID IN NUMBER,
	p_POR_ID IN NUMBER,
	p_PURCHASER_ID IN NUMBER,
	p_SELLER_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_TP_ID IN NUMBER,
	p_ROLLUP_ID_1 IN NUMBER,
	p_ROLLUP_ID_2 IN NUMBER,
	p_ROLLUP_ID_3 IN NUMBER,
	p_ROLLUP_ID_4 IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE GET_NET_INTERCHANGE
    (
	p_CA_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE GET_LOAD_DIFFERENTIAL_FOR_EDC
	(
	p_PSE_ID_LIST IN VARCHAR2,
	p_SCHEDULE_TYPE IN NUMBER,
    p_SCHEDULE_STATE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_AS_OF_DATE IN DATE,
	p_DATE_ADJ IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_LOAD_DIFFERENTIAL_FOR_ESP
	(
	p_EDC_ID_LIST IN VARCHAR2,
	p_SCHEDULE_TYPE IN NUMBER,
    p_SCHEDULE_STATE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_AS_OF_DATE IN DATE,
	p_DATE_ADJ IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE ENTITY_ATTRIBUTES
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE POSITION_ROLLUPS
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PUT_TRANSACTION_POD
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER
	);

PROCEDURE PUT_TRANSACTION_POR
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER
	);

PROCEDURE PUT_TRANSACTION_PURCHASER
	(
	p_TRANSACTION_ID IN NUMBER,
	p_PSE_ID IN NUMBER
	) ;

PROCEDURE PUT_TRANSACTION_SELLER
	(
	p_TRANSACTION_ID IN NUMBER,
	p_PSE_ID IN NUMBER
	);

PROCEDURE COMPARE_TRANSACTION_STATE
	(
	p_TRANSACTION_ID IN NUMBER,
    p_SCHEDULE_TYPE1 IN NUMBER,
    p_SCHEDULE_STATE1 IN NUMBER,
    p_SCHEDULE_TYPE2 IN NUMBER,
    p_SCHEDULE_STATE2 IN NUMBER,
	p_CONTRACT_NAME IN VARCHAR,
	p_CONTRACT_NUMBER IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE TRANSACTION_ID_FOR_CONTRACT
	(
	p_CONTRACTS IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE GET_SUB_STATION_TREE
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_SUB_STATION_DATA
	(
	p_ENTITY_ID IN NUMBER,
	p_LEVEL IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_INTERVAL IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE PUT_SUB_STATION_VALUE
	(
	p_ENTITY_ID IN NUMBER,
	p_AMOUNT IN NUMBER,
	p_DATE IN DATE,
    p_SCHEDULE_TYPE IN NUMBER,
    p_AS_OF_DATE IN DATE,
    p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_SUB_STATION_VALUES
	(
	p_ENTITY_ID IN NUMBER,
	p_LEVEL IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_INTERVAL IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE ACCEPT_SERVICE_POINT_SCHEDULE
	(
	p_SERVICE_POINT_ID IN NUMBER,
	p_TRANSACTION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_INTERVAL IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_SRC_AS_OF_DATE IN DATE,
	p_TRG_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_DEFAULT_SP_TRANSACTION
	(
	p_SERVICE_POINT_ID IN NUMBER,
	p_INTERVAL IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_TRANSACTION_NAME OUT VARCHAR2,
	p_TRANSACTION_ID OUT NUMBER
	);

PROCEDURE IMPORT_SUB_STATIONS
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SRC_AS_OF_DATE IN DATE,
	p_TRG_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER
	);
/*
PROCEDURE CLEAN_BALANCE_TRANS_SCHEDULES
	(
	p_ROWS_REMOVED OUT NUMBER
	);

PROCEDURE GET_BALANCE_TRANS_HEADERS
	(
	p_BALANCE_TRANSACTION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_BALANCE_SUPPLY_HEADERS
	(
	p_TRANSACTION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_BALANCE_TRANS_DATES
	(
	p_BALANCE_TRANSACTION_ID IN NUMBER,
	p_SUPPLY_TRANSACTION_IDs IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SCHEDULE_TYPE IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_BALANCE_TRANS_CONTRACTS
	(
	p_BALANCE_TRANSACTION_ID IN NUMBER,
	p_SUPPLY_TRANSACTION_IDs IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
    p_INTERVAL IN VARCHAR2,
	p_SCHEDULE_TYPE IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_BALANCE_TRANS_SCHEDULES
	(
	p_BALANCE_TRANSACTION_ID IN NUMBER,
	p_SUPPLY_TRANSACTION_IDs IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SCHEDULE_TYPE IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_BALANCE_TRANS_ASSIGNED
	(
	p_BALANCE_TRANSACTION_ID IN NUMBER,
	p_SUPPLY_TRANSACTION_IDs IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SCHEDULE_TYPE IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_BALANCE_SUPPLY_ASSIGNED
	(
	p_SUPPLY_TRANSACTION_ID IN NUMBER,
	p_BALANCE_TRANSACTION_IDs IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SCHEDULE_TYPE IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_BALANCE_TRANS_PRICES
	(
	p_BALANCE_TRANSACTION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SCHEDULE_TYPE IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_BALANCE_LOAD_ASSIGNED
	(
	p_BALANCE_TRANSACTION_IDs IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SCHEDULE_TYPE IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE PUT_BALANCE_TRANS_DATA
	(
	p_TRANSACTION_ID IN NUMBER,
	p_BALANCE_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_ARGUMENTS IN VARCHAR,
	p_UPDATE_DEMAND IN NUMBER,
	p_STATUS OUT NUMBER
	);

-- PROCEDURE GET_BALANCE_TRANS_TERMS (
-- 	p_TRANSACTION_ID IN NUMBER,
-- 	p_TRANSACTION_ID_LIST IN VARCHAR2,
-- 	p_BEGIN_DATE IN DATE,
-- 	p_END_DATE IN DATE,
-- 	p_STATUS OUT NUMBER,
-- 	p_CURSOR OUT GA.REFCURSOR
-- 	);

PROCEDURE GET_BALANCE_TRANS_INTERVALS (
	p_BALANCE_TRANSACTION_ID IN NUMBER,
	p_TRANSACTION_ID IN NUMBER,
	p_INTERVAL IN VARCHAR2,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);
*/
PROCEDURE APPLY_EXTERNAL_SCHEDULE (
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_TP_CONTRACT_LOAD_SCHEDULES
    (
	p_PSE_IDS IN VARCHAR,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE GET_SERVICE_ZONE_LOAD
	(
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_LOAD_DETAIL IN NUMBER,
	p_PURCHASE_DETAIL IN NUMBER,
	p_SALE_DETAIL IN NUMBER,
	p_GENERATION_DETAIL IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_SERVICE_ZONE_SUPPLY
	(
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_LOAD_DETAIL IN NUMBER,
	p_PURCHASE_DETAIL IN NUMBER,
	p_SALE_DETAIL IN NUMBER,
	p_GENERATION_DETAIL IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_MARKET_PRICE_FOR_ZONE
	(
	p_SERVICE_ZONE_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE SCHEDULE_COMPARISON
	(
	p_TRANSACTION_ID IN NUMBER,
	p_COMPARISON_MODE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE SCHEDULE_TEMPLATE_NAMES
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE SCHEDULER_SCHEDULE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PUT_IT_SCHEDULE_FOR_HOUR
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SCHEDULE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_AMOUNT IN NUMBER,
	p_PRICE IN NUMBER,
	p_MINUTES IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_ENERGY_SUMMARY
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
    p_SCHEDULE_TYPE IN NUMBER,
    p_INTERVAL IN VARCHAR2,
    p_TEMPLATE_ID IN NUMBER,
    p_ENTITY_TYPE IN VARCHAR2,
    p_ENTITY_IDs IN VARCHAR2,
    p_STATUS OUT NUMBER,
    p_CURSOR IN OUT GA.REFCURSOR
    );

FUNCTION IS_HOLIDAY_S
	(
	p_DATE IN DATE,
	p_EDC_ID IN NUMBER DEFAULT 0
	) RETURN NUMBER DETERMINISTIC;

g_ALL NUMBER(2) := -1;
g_NOT_ASSIGNED NUMBER(1) := 0;
g_TRACE_ON BOOLEAN := FALSE;
g_LINEFEED CHAR(1) := CHR(10);
g_COMMA CHAR(1) := ',';
g_DOUBLE_QUOTE CHAR(1) := '"';
g_CLOSE_BRACE CHAR(1) := '}';
g_MODULE_NAME VARCHAR(16) := 'SCHEDULING';
g_INTERNAL_STATE NUMBER(1) := 1;
g_EXTERNAL_STATE NUMBER(1) := 2;
g_ELECTRIC_MODEL NUMBER(1) := 1;
g_SECOND NUMBER(6,5) :=  .00001;
g_REDIRECT_SCHEDULER BOOLEAN := FALSE;


INSUFFICIENT_PRIVILEGES EXCEPTION;
PRAGMA EXCEPTION_INIT(INSUFFICIENT_PRIVILEGES, -1031);

INVALID_DATE_RANGE EXCEPTION;
PRAGMA EXCEPTION_INIT(INVALID_DATE_RANGE, -20999);

END IT;
/
CREATE OR REPLACE PACKAGE BODY IT AS
----------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
    RETURN '$Revision: 1.162 $';
END WHAT_VERSION;
----------------------------------------------------------------------------------------------------
PROCEDURE NULL_CURSOR
    (
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
		SELECT NULL FROM DUAL;

END NULL_CURSOR;
----------------------------------------------------------------------------------------------------
FUNCTION SUPPLY_SCHEDULE_TYPE
    (
	p_SCHEDULE_TYPE IN NUMBER
	) RETURN NUMBER IS

BEGIN

	IF GA.ENABLE_SUPPLY_SCHEDULE_TYPES THEN
	    RETURN p_SCHEDULE_TYPE;
	ELSE
	    RETURN g_NOT_ASSIGNED;
	END IF;

END SUPPLY_SCHEDULE_TYPE;
---------------------------------------------------------------------------------------------------
FUNCTION DOUBLE_QUOTE
    (
	p_STRING IN VARCHAR
	) RETURN VARCHAR IS

BEGIN

	IF LENGTH(p_STRING) > 0 THEN
	    RETURN g_DOUBLE_QUOTE || p_STRING || g_DOUBLE_QUOTE;
	ELSE
	    RETURN '';
	END IF;

END DOUBLE_QUOTE;
---------------------------------------------------------------------------------------------------
FUNCTION REMOVE_DOUBLE_QUOTE
    (
	p_STRING IN VARCHAR
	) RETURN VARCHAR IS

BEGIN

	RETURN LTRIM(RTRIM(p_STRING, g_DOUBLE_QUOTE), g_DOUBLE_QUOTE);

END REMOVE_DOUBLE_QUOTE;
---------------------------------------------------------------------------------------------------
FUNCTION RIGHT_JUSTIFY
    (
	p_STRING IN VARCHAR,
	p_LENGTH IN NUMBER
	) RETURN VARCHAR IS

v_STRING VARCHAR(32);

BEGIN

	v_STRING := '                ' || p_STRING;
	RETURN SUBSTR(v_STRING, LENGTH(v_STRING) - (p_LENGTH - 1));

END RIGHT_JUSTIFY;
---------------------------------------------------------------------------------------------------
FUNCTION GET_TP_CONTRACT_NUMBER
    (
	p_TRANSACTION_ID IN NUMBER,
	p_SERVICE_DATE IN DATE
	) RETURN VARCHAR IS

v_CONTRACT_NUMBER VARCHAR(32);

BEGIN

	SELECT CONTRACT_NUMBER
	INTO v_CONTRACT_NUMBER
	FROM INTERCHANGE_TRANSACTION A,
	    TP_CONTRACT_NUMBER B
	WHERE A.TRANSACTION_ID = p_TRANSACTION_ID
        AND B.CONTRACT_ID = A.CONTRACT_ID
		AND TRUNC(p_SERVICE_DATE) BETWEEN B.BEGIN_DATE AND NVL(B.END_DATE, p_SERVICE_DATE)
		AND ROWNUM = 1;

	RETURN v_CONTRACT_NUMBER;

	EXCEPTION
	    WHEN NO_DATA_FOUND THEN
		    RETURN 'NO CONTRACT NUMBER DEFINED';

END GET_TP_CONTRACT_NUMBER;
---------------------------------------------------------------------------------------------------
FUNCTION GET_CONTRACT_ID
    (
	p_TRANSACTION_ID IN NUMBER
	) RETURN NUMBER IS

v_CONTRACT_ID NUMBER(9);

BEGIN

	SELECT CONTRACT_ID
	INTO v_CONTRACT_ID
	FROM INTERCHANGE_TRANSACTION
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

	RETURN v_CONTRACT_ID;

EXCEPTION
    WHEN OTHERS THEN
	    RETURN g_NOT_ASSIGNED;

END GET_CONTRACT_ID;
---------------------------------------------------------------------------------------------------
FUNCTION GET_PSE_NERC_CODE
	(
	p_PSE_ID IN NUMBER
	) RETURN VARCHAR IS

-- Answer the PSE NERC code for the specified PSE Id.

v_PSE_NERC_CODE VARCHAR(32);

BEGIN

	SELECT DECODE(NVL(PSE_NERC_CODE,'?'), '?', PSE_ALIAS, PSE_NERC_CODE)
	INTO v_PSE_NERC_CODE
	FROM PURCHASING_SELLING_ENTITY
	WHERE PSE_ID = p_PSE_ID;

	RETURN v_PSE_NERC_CODE;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			RETURN '';
		WHEN OTHERS THEN
			RAISE;

END GET_PSE_NERC_CODE;
----------------------------------------------------------------------------------------------------
FUNCTION GET_TP_NERC_CODE
	(
	p_TP_ID IN NUMBER
	) RETURN VARCHAR IS

-- Answer the TP NERC code for the specified TP Id.

v_TP_NERC_CODE VARCHAR(32);

BEGIN

	SELECT DECODE(NVL(TP_NERC_CODE,'?'), '?', TP_ALIAS, TP_NERC_CODE)
	INTO v_TP_NERC_CODE
	FROM TRANSMISSION_PROVIDER
	WHERE TP_ID = p_TP_ID;

	RETURN v_TP_NERC_CODE;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			RETURN '';
		WHEN OTHERS THEN
			RAISE;

END GET_TP_NERC_CODE;
----------------------------------------------------------------------------------------------------
FUNCTION GET_CA_NERC_CODE
	(
	p_CA_ID IN NUMBER
	) RETURN VARCHAR IS

-- Answer the CA NERC code for the specified CA Id.

v_CA_NERC_CODE VARCHAR(32);

BEGIN

	SELECT DECODE(NVL(CA_NERC_CODE,'?'), '?', CA_ALIAS, CA_NERC_CODE)
	INTO v_CA_NERC_CODE
	FROM CONTROL_AREA
	WHERE CA_ID = p_CA_ID;

	RETURN v_CA_NERC_CODE;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			RETURN '';
		WHEN OTHERS THEN
			RAISE;

END GET_CA_NERC_CODE;
----------------------------------------------------------------------------------------------------
FUNCTION GET_PSE_ID_USING_NERC_CODE
	(
	p_PSE_NERC_CODE IN VARCHAR
	) RETURN NUMBER IS

-- Answer the PSE id using the specified NERC code.

v_PSE_ID NUMBER;

BEGIN

    IF p_PSE_NERC_CODE IS NULL THEN
	    RETURN 0;
	END IF;

    v_PSE_ID := ID.ID_FOR_PSE_NERC_CODE(p_PSE_NERC_CODE);
	IF NOT v_PSE_ID  > 0 THEN
	    ID.ID_FOR_PSE(p_PSE_NERC_CODE, FALSE, v_PSE_ID);
		IF v_PSE_ID = GA.NO_DATA_FOUND THEN
	        ID.ID_FOR_PSE(p_PSE_NERC_CODE, TRUE, v_PSE_ID);
			UPDATE PURCHASING_SELLING_ENTITY
			SET PSE_NERC_CODE = p_PSE_NERC_CODE
			WHERE PSE_ID = v_PSE_ID;
		ELSIF v_PSE_ID < 0 THEN
        	v_PSE_ID := 0;
		END IF;
	END IF;

	RETURN v_PSE_ID;

	EXCEPTION
		WHEN OTHERS THEN
			RETURN 0;

END GET_PSE_ID_USING_NERC_CODE;
----------------------------------------------------------------------------------------------------
FUNCTION GET_TP_ID_USING_NERC_CODE
	(
	p_TP_NERC_CODE IN VARCHAR
	) RETURN NUMBER IS

-- Answer the PSE id using the specified NERC code.

v_TP_ID NUMBER;

BEGIN

    IF p_TP_NERC_CODE IS NULL THEN
	    RETURN 0;
	END IF;

	v_TP_ID := ID.ID_FOR_TP_NERC_CODE(p_TP_NERC_CODE);
	IF NOT v_TP_ID  > 0 THEN
	    ID.ID_FOR_TP(p_TP_NERC_CODE, FALSE, v_TP_ID);
		IF v_TP_ID = GA.NO_DATA_FOUND THEN
	        ID.ID_FOR_TP(p_TP_NERC_CODE, TRUE, v_TP_ID);
			UPDATE TRANSMISSION_PROVIDER
			SET TP_NERC_CODE = p_TP_NERC_CODE
			WHERE TP_ID = v_TP_ID;
		ELSIF v_TP_ID < 0 THEN
        	v_TP_ID := 0;
		END IF;
	END IF;

	RETURN v_TP_ID;

	EXCEPTION
		WHEN OTHERS THEN
			RETURN 0;

END GET_TP_ID_USING_NERC_CODE;
----------------------------------------------------------------------------------------------------
FUNCTION GET_CA_ID_USING_NERC_CODE
	(
	p_CA_NERC_CODE IN VARCHAR
	) RETURN NUMBER IS

-- Answer the CA id using the specified NERC code.

v_CA_ID NUMBER;

BEGIN

    IF p_CA_NERC_CODE IS NULL THEN
	    RETURN 0;
	END IF;

    v_CA_ID := ID.ID_FOR_CA_NERC_CODE(p_CA_NERC_CODE);
	IF NOT v_CA_ID  > 0 THEN
	    ID.ID_FOR_CA(p_CA_NERC_CODE, FALSE, v_CA_ID);
		IF v_CA_ID = GA.NO_DATA_FOUND THEN
	        ID.ID_FOR_CA(p_CA_NERC_CODE, TRUE, v_CA_ID);
			UPDATE CONTROL_AREA
			SET CA_NERC_CODE = p_CA_NERC_CODE
			WHERE CA_ID = v_CA_ID;
		ELSIF v_CA_ID < 0 THEN
        	v_CA_ID := 0;
		END IF;
	END IF;

	RETURN v_CA_ID;

	EXCEPTION
		WHEN OTHERS THEN
			RETURN 0;

END GET_CA_ID_USING_NERC_CODE;
----------------------------------------------------------------------------------------------------
FUNCTION GET_SERVICE_POINT_NAME
	(
	p_SERVICE_POINT_ID IN NUMBER
	) RETURN VARCHAR IS

-- Answer the Service Point name for the specified Service Point Id.

v_SERVICE_POINT_NAME VARCHAR(32);

BEGIN

	SELECT SERVICE_POINT_NAME
	INTO v_SERVICE_POINT_NAME
	FROM SERVICE_POINT
	WHERE SERVICE_POINT_ID = p_SERVICE_POINT_ID;

	RETURN v_SERVICE_POINT_NAME;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			RETURN '';
		WHEN OTHERS THEN
			RAISE;

END GET_SERVICE_POINT_NAME;
----------------------------------------------------------------------------------------------------
FUNCTION GET_SERVICE_POINT_EDC_ALIAS
	(
	p_SERVICE_POINT_ID IN NUMBER
	) RETURN VARCHAR IS
-- Answer the Service Point name for the specified Service Point Id.
v_EDC_ALIAS VARCHAR(32);
BEGIN
	SELECT A.EDC_ALIAS
	INTO v_EDC_ALIAS
	FROM ENERGY_DISTRIBUTION_COMPANY A,
		 SERVICE_POINT B
	WHERE B.SERVICE_POINT_ID = p_SERVICE_POINT_ID
		  AND A.EDC_ID = B.EDC_ID;
	RETURN v_EDC_ALIAS;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			RETURN '';
		WHEN OTHERS THEN
			RAISE;
END GET_SERVICE_POINT_EDC_ALIAS;
----------------------------------------------------------------------------------------------------
FUNCTION GET_SERVICE_POINT_CA_ID
	(
	p_SERVICE_POINT_ID IN NUMBER
	) RETURN NUMBER IS

-- Answer the Service Point name for the specified Service Point Id.

v_CA_ID NUMBER;

BEGIN

	SELECT CA_ID
	INTO v_CA_ID
	FROM SERVICE_POINT
	WHERE SERVICE_POINT_ID = p_SERVICE_POINT_ID;

	RETURN v_CA_ID;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			RETURN g_NOT_ASSIGNED;
		WHEN OTHERS THEN
			RAISE;

END GET_SERVICE_POINT_CA_ID;
----------------------------------------------------------------------------------------------------
FUNCTION GET_TRANSACTION_INTERVAL
    (
	p_TRANSACTION_ID IN NUMBER
	) RETURN VARCHAR IS

v_INTERVAL CHAR(2) := 'XX';

BEGIN

	SELECT DECODE(UPPER(SUBSTR(TRANSACTION_INTERVAL,1,2)),'DA','DD','WE','WW','MO','MM','QU','QQ','YE','YY','XX')
	INTO v_INTERVAL
	FROM INTERCHANGE_TRANSACTION
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

	RETURN v_INTERVAL;

EXCEPTION
	WHEN OTHERS THEN
		RETURN 'XX';

END GET_TRANSACTION_INTERVAL;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_TRANSACTION_MINUTES
    (
	p_TRANSACTION_ID IN NUMBER,
	p_INTERNAL_MINUTES OUT NUMBER,
	p_EXTERNAL_MINUTES OUT NUMBER
	) AS

BEGIN

	SELECT DECODE(UPPER(TRANSACTION_INTERVAL), '5 MINUTE', 5,'10 MINUTE', 10,'15 MINUTE', 15,'20 MINUTE', 20,'30 MINUTE', 30, 60),
		DECODE(UPPER(NVL(EXTERNAL_INTERVAL,TRANSACTION_INTERVAL)), '5 MINUTE', 5,'10 MINUTE', 10,'15 MINUTE', 15,'20 MINUTE', 20,'30 MINUTE', 30, 60)
	INTO p_INTERNAL_MINUTES, p_EXTERNAL_MINUTES
	FROM INTERCHANGE_TRANSACTION
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

EXCEPTION
	WHEN OTHERS THEN
		p_INTERNAL_MINUTES := 60;
		p_EXTERNAL_MINUTES := 60;

END GET_TRANSACTION_MINUTES;
---------------------------------------------------------------------------------------------------
FUNCTION GET_TRANSACTION_MINUTES
    (
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_USE_LEAST_INTERVAL IN BOOLEAN DEFAULT FALSE
	) RETURN NUMBER IS

v_INTERNAL_MINUTES NUMBER(2);
v_EXTERNAL_MINUTES NUMBER(2);

BEGIN

	GET_TRANSACTION_MINUTES(p_TRANSACTION_ID, v_INTERNAL_MINUTES, v_EXTERNAL_MINUTES);

	IF p_USE_LEAST_INTERVAL THEN
		RETURN LEAST(v_INTERNAL_MINUTES, v_EXTERNAL_MINUTES);
	ELSE
		IF p_SCHEDULE_STATE = g_INTERNAL_STATE THEN
			RETURN v_INTERNAL_MINUTES;
		ELSIF p_SCHEDULE_STATE = g_EXTERNAL_STATE THEN
			RETURN v_EXTERNAL_MINUTES;
		ELSE
		RETURN GREATEST(v_INTERNAL_MINUTES, v_EXTERNAL_MINUTES);
		END IF;
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		RETURN 60;

END GET_TRANSACTION_MINUTES;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_SCHEDULE
	(
	p_TRANSACTION_IDS IN VARCHAR,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
    p_TIME_ZONE IN VARCHAR,
	p_SCHEDULE IN OUT NOCOPY CONTRACT_SCHEDULE_TABLE,
	p_ROLL_UP_BY_CONTRACT IN NUMBER := 1
	) AS

v_SCHEDULE_DATE DATE;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_SYSDATE DATE := SYSDATE;
v_LOW_DATE DATE := LOW_DATE;
v_INDEX BINARY_INTEGER;
v_MINUTES NUMBER(2);
v_MINUTE_DIVISOR NUMBER;
v_WORK_ID NUMBER;
v_TABLE GA.STRING_TABLE;
v_INDEX BINARY_INTEGER;
v_CONTRACT_ID NUMBER(9);
v_TRANSACTION_ID NUMBER(9);
v_SEQUENCE NUMBER(9) := 0;

BEGIN

	UT.GET_RTO_WORK_ID(v_WORK_ID);
	UT.TOKENS_FROM_STRING(p_TRANSACTION_IDS, ';', v_TABLE);
	FOR v_INDEX IN v_TABLE.FIRST..v_TABLE.LAST LOOP
		v_TRANSACTION_ID := TO_NUMBER(v_TABLE(v_INDEX));
		v_MINUTES := GET_TRANSACTION_MINUTES(v_TRANSACTION_ID, p_SCHEDULE_STATE);
		UT.CUT_DAY_INTERVAL_RANGE(g_ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_MINUTES, v_BEGIN_DATE, v_END_DATE);
		v_MINUTE_DIVISOR := v_MINUTES * 60 / 86400;
		v_SCHEDULE_DATE := v_BEGIN_DATE;
		v_CONTRACT_ID := GET_CONTRACT_ID(v_TRANSACTION_ID);
--Make Certain There is a Value for Every Interval.
		WHILE v_SCHEDULE_DATE <= v_END_DATE LOOP
			v_SEQUENCE := v_SEQUENCE + 1;
	    	UT.POST_RTO_WORK(v_WORK_ID, v_SEQUENCE, v_TRANSACTION_ID, v_SCHEDULE_DATE, TO_CHAR(v_CONTRACT_ID));
			COMMIT;
			v_SCHEDULE_DATE := ADD_MINUTES_TO_DATE(v_SCHEDULE_DATE, v_MINUTES);
		END LOOP;

	END LOOP;
	v_TABLE.DELETE;

	IF GA.VERSION_SCHEDULE THEN
		SELECT CONTRACT_SCHEDULE_TYPE(TO_NUMBER(B.WORK_DATA), CASE WHEN p_ROLL_UP_BY_CONTRACT = 1 THEN 0 ELSE B.WORK_XID END, B.WORK_DATE, A.AMOUNT)
		BULK COLLECT INTO p_SCHEDULE
		FROM IT_SCHEDULE A, RTO_WORK B
		WHERE B.WORK_ID = v_WORK_ID
			AND A.TRANSACTION_ID = B.WORK_XID
			AND A.SCHEDULE_TYPE = p_SCHEDULE_TYPE
			AND A.SCHEDULE_STATE = p_SCHEDULE_STATE
			AND A.SCHEDULE_DATE (+) = B.WORK_DATE
			AND A.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM IT_SCHEDULE
				WHERE TRANSACTION_ID = A.TRANSACTION_ID
					AND SCHEDULE_TYPE = A.SCHEDULE_TYPE
					AND SCHEDULE_STATE = A.SCHEDULE_STATE
					AND SCHEDULE_DATE = A.SCHEDULE_DATE
					AND AS_OF_DATE <= v_SYSDATE);
	ELSE
		SELECT CONTRACT_SCHEDULE_TYPE(TO_NUMBER(B.WORK_DATA), CASE WHEN p_ROLL_UP_BY_CONTRACT = 1 THEN 0 ELSE B.WORK_XID END, B.WORK_DATE, A.AMOUNT)
		BULK COLLECT INTO p_SCHEDULE
		FROM IT_SCHEDULE A, RTO_WORK B
		WHERE B.WORK_ID = v_WORK_ID
			AND A.TRANSACTION_ID = B.WORK_XID
			AND A.SCHEDULE_TYPE = p_SCHEDULE_TYPE
			AND A.SCHEDULE_STATE = p_SCHEDULE_STATE
			AND A.SCHEDULE_DATE (+) = B.WORK_DATE
			AND A.AS_OF_DATE = v_LOW_DATE;
	END IF;

	UT.PURGE_RTO_WORK(v_WORK_ID);

EXCEPTION
	WHEN OTHERS THEN
		  UT.PURGE_RTO_WORK(v_WORK_ID);
		  RAISE;
END GET_SCHEDULE;
--------------------------------------------------------------------------------------------------
PROCEDURE TRACE_SCHEDULE
    (
	p_NAME IN VARCHAR,
	p_SCHEDULE IN CONTRACT_SCHEDULE_TABLE
	) AS

v_INDEX BINARY_INTEGER;

BEGIN

	UT.DEBUG_TRACE('TRACE ' || p_NAME);
	IF p_SCHEDULE.COUNT = 0 THEN
	    UT.DEBUG_TRACE('<schedule empty>');
	ELSE
	    FOR v_INDEX IN p_SCHEDULE.FIRST..p_SCHEDULE.LAST LOOP
		    UT.DEBUG_TRACE(TO_CHAR(v_INDEX) || ',' || TO_CHAR(p_SCHEDULE(v_INDEX).CONTRACT_ID) || ',' || TO_CHAR(p_SCHEDULE(v_INDEX).TRANSACTION_ID) || ',' || UT.TRACE_DATE(p_SCHEDULE(v_INDEX).SCHEDULE_DATE) || ',' || TO_CHAR(p_SCHEDULE(v_INDEX).SCHEDULE_VAL));
		END LOOP;
	END IF;

END TRACE_SCHEDULE;
---------------------------------------------------------------------------------------------------
PROCEDURE COERCE_DATE_RANGE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_USE_LEAST_INTERVAL IN BOOLEAN,
	p_COERCED_BEGIN_DATE OUT DATE,
	p_COERCED_END_DATE OUT DATE,
	p_FORMAT OUT VARCHAR,
	p_MINUTES OUT NUMBER
	) AS

v_INTERVAL CHAR(2);

BEGIN

	v_INTERVAL := GET_TRANSACTION_INTERVAL(p_TRANSACTION_ID);
	p_MINUTES := GET_TRANSACTION_MINUTES(p_TRANSACTION_ID, p_SCHEDULE_STATE, p_USE_LEAST_INTERVAL);

-- Coerce the date range to allow weekly, monthly, and yearly transactions in scope to show up.
	IF v_INTERVAL IN ('DD','WW','MM','QQ','YY') THEN
		IF v_INTERVAL = 'DD' THEN
		   p_COERCED_BEGIN_DATE := TRUNC(p_BEGIN_DATE);
		ELSIF v_INTERVAL = 'WW' THEN
		   p_COERCED_BEGIN_DATE := TRUNC(p_BEGIN_DATE) - 6;
		ELSIF v_INTERVAL = 'MM' THEN
		   p_COERCED_BEGIN_DATE := ADD_MONTHS(TRUNC(p_BEGIN_DATE),-1) + 1;
		ELSIF v_INTERVAL = 'QQ' THEN
		   p_COERCED_BEGIN_DATE := ADD_MONTHS(TRUNC(p_BEGIN_DATE),-3) + 1;
		ELSIF v_INTERVAL = 'YY' THEN
		   p_COERCED_BEGIN_DATE := ADD_MONTHS(TRUNC(p_BEGIN_DATE),-12) + 1;
		END IF;
		p_COERCED_END_DATE := ADD_SECONDS_TO_DATE(TRUNC(p_END_DATE), 1);
		p_FORMAT := v_INTERVAL;
	ELSE
		UT.CUT_DAY_INTERVAL_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_MINUTES, p_COERCED_BEGIN_DATE, p_COERCED_END_DATE);
		IF v_INTERVAL = 'XX' THEN
			IF p_MINUTES = 60 THEN
			   p_FORMAT := NULL;
			ELSE
				p_FORMAT := 'MI' || p_MINUTES;
			END IF;
		END IF;
	END IF;

	IF g_TRACE_ON THEN
		UT.DEBUG_TRACE('COERCE_DATE_RANGE');
		UT.DEBUG_TRACE('COERCED_BEGIN_DATE=' || UT.TRACE_DATE(p_COERCED_BEGIN_DATE));
		UT.DEBUG_TRACE('COERCED_END_DATE=' || UT.TRACE_DATE(p_COERCED_END_DATE));
		UT.DEBUG_TRACE('FORMAT=' || p_FORMAT);
		UT.DEBUG_TRACE('MINUTES=' || TO_CHAR(p_MINUTES));
	END IF;

END COERCE_DATE_RANGE;
---------------------------------------------------------------------------
PROCEDURE GET_ENTITY_PHONE_NUMBERS
    (
	p_ENTITY_ID IN NUMBER,
	p_ENTITY_DOMAIN_ALIAS IN VARCHAR,
	p_CATEGORY_NAME IN VARCHAR,
	p_WORK_PHONE OUT VARCHAR,
	p_HOME_PHONE OUT VARCHAR,
	p_FAX_PHONE OUT VARCHAR,
	p_CELL_PHONE OUT VARCHAR
	) AS

v_CONTACT_NAME VARCHAR(32);
v_CONTACT_ALIAS VARCHAR(32);
v_EMAIL_ADDRESS VARCHAR(64);
v_COUNTRY_CODE VARCHAR(16);
v_STATUS NUMBER;

BEGIN

    RO.GET_ENTITY_CONTACT(p_ENTITY_ID, p_ENTITY_DOMAIN_ALIAS, p_CATEGORY_NAME, v_CONTACT_NAME,
		v_CONTACT_ALIAS, p_WORK_PHONE, p_HOME_PHONE, p_FAX_PHONE, p_CELL_PHONE, v_EMAIL_ADDRESS, v_STATUS);

END GET_ENTITY_PHONE_NUMBERS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_ENTITY_PHONE_NUMBERS
    (
	p_ENTITY_ID IN NUMBER,
	p_ENTITY_DOMAIN_ALIAS IN VARCHAR,
	p_CATEGORY_NAME IN VARCHAR,
	p_CONTACT_NAME IN VARCHAR,
	p_WORK_PHONE IN VARCHAR,
	p_HOME_PHONE IN VARCHAR,
	p_FAX_PHONE IN VARCHAR,
	p_CELL_PHONE IN VARCHAR
	) AS

v_STATUS NUMBER;

BEGIN

    RO.PUT_ENTITY_CONTACT(p_ENTITY_ID, p_ENTITY_DOMAIN_ALIAS, p_CATEGORY_NAME, p_CONTACT_NAME,
		p_WORK_PHONE, p_HOME_PHONE, p_FAX_PHONE, p_CELL_PHONE, NULL, v_STATUS);

END PUT_ENTITY_PHONE_NUMBERS;
---------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_TRANSACTION_PATH
	(
	p_TRANSACTION_PATH IN TRANSACTION_PATH%ROWTYPE,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	UPDATE TRANSACTION_PATH SET
	    CA_ID = p_TRANSACTION_PATH.CA_ID,
		TP_ID = p_TRANSACTION_PATH.TP_ID,
		PSE_ID = p_TRANSACTION_PATH.PSE_ID,
		TP_PRODUCT_CODE = p_TRANSACTION_PATH.TP_PRODUCT_CODE,
		TP_PATH_NAME = p_TRANSACTION_PATH.TP_PATH_NAME,
		TP_ASSIGNMENT_REF = p_TRANSACTION_PATH.TP_ASSIGNMENT_REF,
		TP_PRODUCT_LEVEL = p_TRANSACTION_PATH.TP_PRODUCT_LEVEL,
		MISC_INFO = p_TRANSACTION_PATH.MISC_INFO,
		MISC_REF = p_TRANSACTION_PATH.MISC_REF
	WHERE TRANSACTION_ID = p_TRANSACTION_PATH.TRANSACTION_ID
		AND LEG_NBR = p_TRANSACTION_PATH.LEG_NBR;

	IF SQL%NOTFOUND THEN
		INSERT INTO TRANSACTION_PATH (
	        TRANSACTION_ID,
			LEG_NBR,
			CA_ID,
			TP_ID,
			PSE_ID,
			TP_PRODUCT_CODE,
			TP_PATH_NAME,
			TP_ASSIGNMENT_REF,
			TP_PRODUCT_LEVEL,
			MISC_INFO,
			MISC_REF)
		VALUES (
	        p_TRANSACTION_PATH.TRANSACTION_ID,
	        p_TRANSACTION_PATH.LEG_NBR,
	        p_TRANSACTION_PATH.CA_ID,
			p_TRANSACTION_PATH.TP_ID,
			p_TRANSACTION_PATH.PSE_ID,
			p_TRANSACTION_PATH.TP_PRODUCT_CODE,
			p_TRANSACTION_PATH.TP_PATH_NAME,
			p_TRANSACTION_PATH.TP_ASSIGNMENT_REF,
			p_TRANSACTION_PATH.TP_PRODUCT_LEVEL,
			p_TRANSACTION_PATH.MISC_INFO,
			p_TRANSACTION_PATH.MISC_REF);
	END IF;

	p_STATUS := GA.SUCCESS;

	EXCEPTION
		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END PUT_TRANSACTION_PATH;
----------------------------------------------------------------------------------------------------
PROCEDURE ZERO_FILL_IT_SCHEDULE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_PRICE IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

v_AS_OF_DATE DATE;
--ONLY FILL THE VALUE IF THERE IS NO EXISTING VALUE.
BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;
	IF GA.VERSION_SCHEDULE THEN
		v_AS_OF_DATE := CORRECTED_AS_OF_DATE(p_AS_OF_DATE);
	ELSE
		v_AS_OF_DATE := LOW_DATE;
	END IF;

	UPDATE IT_SCHEDULE SET
		AMOUNT = AMOUNT
	WHERE TRANSACTION_ID = p_TRANSACTION_ID
		AND SCHEDULE_TYPE = p_SCHEDULE_TYPE
		AND SCHEDULE_STATE = g_INTERNAL_STATE
		AND SCHEDULE_DATE = p_SCHEDULE_DATE
		AND AS_OF_DATE = v_AS_OF_DATE;

	IF SQL%NOTFOUND THEN
		INSERT INTO IT_SCHEDULE (
			TRANSACTION_ID,
			SCHEDULE_TYPE,
			SCHEDULE_STATE,
			SCHEDULE_DATE,
			AS_OF_DATE,
			AMOUNT,
			PRICE)
		VALUES (
			p_TRANSACTION_ID,
			p_SCHEDULE_TYPE,
			g_INTERNAL_STATE,
			p_SCHEDULE_DATE,
			v_AS_OF_DATE,
			0,
			p_PRICE);
	END IF;

	EXCEPTION
		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END ZERO_FILL_IT_SCHEDULE;
----------------------------------------------------------------------------------------------------
PROCEDURE READ_INTERCHANGE_TRANSACTION
	(
	p_TRANSACTION_ID IN NUMBER,
	p_VIEW_BEGIN IN DATE,
	p_VIEW_END IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TRANSACTION_NAME OUT VARCHAR,
	p_TRANSACTION_ALIAS OUT VARCHAR,
	p_TRANSACTION_DESC OUT VARCHAR,
	p_TRANSACTION_TYPE OUT VARCHAR,
	p_TRANSACTION_IDENTIFIER OUT VARCHAR,
	p_IS_FIRM OUT VARCHAR,
	p_IS_IMPORT_SCHEDULE OUT VARCHAR,
	p_IS_EXPORT_SCHEDULE OUT VARCHAR,
	p_TRANSACTION_STATUS OUT VARCHAR,
	p_TRANSACTION_INTERVAL OUT VARCHAR,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE,
	p_PURCHASER OUT VARCHAR,
	p_SELLER OUT VARCHAR,
	p_CONTRACT OUT VARCHAR,
	p_SC OUT VARCHAR,
	p_POR OUT VARCHAR,
	p_POD OUT VARCHAR,
	p_SCHEDULER OUT VARCHAR,
	p_COMMODITY OUT VARCHAR,
	p_SERVICE_TYPE OUT VARCHAR,
	p_COMMODITY_TYPE OUT VARCHAR,
	p_COMMODITY_UNIT OUT VARCHAR,
	p_COMMODITY_UNIT_FORMAT OUT VARCHAR,
	p_COMMODITY_PRICE_UNIT OUT VARCHAR,
	p_COMMODITY_PRICE_FORMAT OUT VARCHAR,
	p_TP_CONTRACT_NUM OUT VARCHAR,
	p_TP_CONTRACT_NAME OUT VARCHAR,
	p_STATUS OUT NUMBER
	) AS

-- Answer the singleton instance of the entity identified by the specified oid
-- Otherwise answer empty string values if the entity cannot be found

v_TRANSACTION INTERCHANGE_TRANSACTION%ROWTYPE;
v_COMMODITY IT_COMMODITY%ROWTYPE;
v_EMPTY_STRING VARCHAR(1) := ' ';

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

-- Select an existing record
	SELECT *
	INTO v_TRANSACTION
	FROM INTERCHANGE_TRANSACTION
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

-- Set the output parameters of the procedure
	p_TRANSACTION_NAME := v_TRANSACTION.TRANSACTION_NAME;
	p_TRANSACTION_ALIAS := v_TRANSACTION.TRANSACTION_ALIAS;
	p_TRANSACTION_DESC := v_TRANSACTION.TRANSACTION_DESC;
	p_TRANSACTION_TYPE := v_TRANSACTION.TRANSACTION_TYPE;
	p_TRANSACTION_IDENTIFIER := v_TRANSACTION.TRANSACTION_IDENTIFIER;
	SELECT DECODE(v_TRANSACTION.IS_FIRM,0,'No',1,'Yes','No') INTO p_IS_FIRM FROM DUAL;
	SELECT DECODE(v_TRANSACTION.IS_IMPORT_SCHEDULE,0,'No',1,'Yes','No') INTO p_IS_IMPORT_SCHEDULE FROM DUAL;
	SELECT DECODE(v_TRANSACTION.IS_EXPORT_SCHEDULE,0,'No',1,'Yes','No') INTO p_IS_EXPORT_SCHEDULE FROM DUAL;
	p_TRANSACTION_INTERVAL := v_TRANSACTION.TRANSACTION_INTERVAL;
	p_BEGIN_DATE := v_TRANSACTION.BEGIN_DATE;
	p_END_DATE := v_TRANSACTION.END_DATE;
	BEGIN
		SELECT TRANSACTION_STATUS_NAME
		INTO p_TRANSACTION_STATUS
		FROM IT_STATUS
		WHERE TRANSACTION_ID = p_TRANSACTION_ID
			AND AS_OF_DATE = IT_STATUS_AS_OF_DATE(TRANSACTION_ID, p_AS_OF_DATE);
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_TRANSACTION_STATUS := v_EMPTY_STRING;
	END;
	BEGIN
		SELECT PSE_NAME
		INTO p_PURCHASER
		FROM PURCHASING_SELLING_ENTITY
		WHERE PSE_ID = v_TRANSACTION.PURCHASER_ID;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_PURCHASER := v_EMPTY_STRING;
	END;
	BEGIN
		SELECT PSE_NAME
		INTO p_SELLER
		FROM PURCHASING_SELLING_ENTITY
		WHERE PSE_ID = v_TRANSACTION.SELLER_ID;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_SELLER := v_EMPTY_STRING;
	END;
	BEGIN
		SELECT CONTRACT_NAME
		INTO p_CONTRACT
		FROM INTERCHANGE_CONTRACT
		WHERE CONTRACT_ID = v_TRANSACTION.CONTRACT_ID;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_CONTRACT := v_EMPTY_STRING;
	END;
	BEGIN
		SELECT SC_NAME
		INTO p_SC
		FROM SCHEDULE_COORDINATOR
		WHERE SC_ID = v_TRANSACTION.SC_ID;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_SC := v_EMPTY_STRING;
	END;
	BEGIN
		SELECT SERVICE_TYPE_NAME
		INTO p_SERVICE_TYPE
		FROM TX_SERVICE_TYPE
		WHERE SERVICE_TYPE_ID = v_TRANSACTION.SERVICE_TYPE_ID;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_SERVICE_TYPE := v_EMPTY_STRING;
	END;
	BEGIN
		SELECT SERVICE_POINT_NAME
		INTO p_POR
		FROM SERVICE_POINT
		WHERE SERVICE_POINT_ID = v_TRANSACTION.POR_ID;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_POR := v_EMPTY_STRING;
	END;
	BEGIN
		SELECT SERVICE_POINT_NAME
		INTO p_POD
		FROM SERVICE_POINT
		WHERE SERVICE_POINT_ID = v_TRANSACTION.POD_ID;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_POD := v_EMPTY_STRING;
	END;
	BEGIN
		SELECT SCHEDULER_NAME
		INTO p_SCHEDULER
		FROM SCHEDULER
		WHERE SCHEDULER_ID = v_TRANSACTION.SCHEDULER_ID;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_SCHEDULER := v_EMPTY_STRING;
	END;
	BEGIN
		SELECT *
		INTO v_COMMODITY
		FROM IT_COMMODITY
		WHERE COMMODITY_ID = v_TRANSACTION.COMMODITY_ID;
		p_COMMODITY := v_COMMODITY.COMMODITY_NAME;
		p_COMMODITY_TYPE := NVL(v_COMMODITY.COMMODITY_TYPE,v_EMPTY_STRING);
		p_COMMODITY_UNIT := NVL(v_COMMODITY.COMMODITY_UNIT,v_EMPTY_STRING);
		p_COMMODITY_UNIT_FORMAT := NVL(v_COMMODITY.COMMODITY_UNIT_FORMAT,v_EMPTY_STRING);
		p_COMMODITY_PRICE_UNIT := NVL(v_COMMODITY.COMMODITY_PRICE_UNIT,v_EMPTY_STRING);
		p_COMMODITY_PRICE_FORMAT := NVL(v_COMMODITY.COMMODITY_PRICE_FORMAT,v_EMPTY_STRING);
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_COMMODITY := v_EMPTY_STRING;
			p_COMMODITY_TYPE := v_EMPTY_STRING;
			p_COMMODITY_UNIT := v_EMPTY_STRING;
			p_COMMODITY_UNIT_FORMAT := v_EMPTY_STRING;
			p_COMMODITY_PRICE_UNIT := v_EMPTY_STRING;
			p_COMMODITY_PRICE_FORMAT := v_EMPTY_STRING;
	END;
	BEGIN
		SELECT NVL(CONTRACT_NUMBER,v_EMPTY_STRING), NVL(CONTRACT_NAME,v_EMPTY_STRING)
		INTO p_TP_CONTRACT_NUM, p_TP_CONTRACT_NAME
		FROM TP_CONTRACT_NUMBER
		WHERE CONTRACT_ID = v_TRANSACTION.CONTRACT_ID
			AND p_VIEW_BEGIN BETWEEN BEGIN_DATE AND NVL(END_DATE, HIGH_DATE)
			AND ROWNUM = 1;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_TP_CONTRACT_NUM := v_EMPTY_STRING;
			p_TP_CONTRACT_NAME := v_EMPTY_STRING;
	END;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		p_TRANSACTION_NAME := v_EMPTY_STRING;
		p_TRANSACTION_ALIAS := v_EMPTY_STRING;
		p_TRANSACTION_DESC := v_EMPTY_STRING;
		p_TRANSACTION_TYPE := v_EMPTY_STRING;
		p_TRANSACTION_IDENTIFIER := v_EMPTY_STRING;
		p_IS_FIRM := v_EMPTY_STRING;
		p_IS_IMPORT_SCHEDULE := v_EMPTY_STRING;
		p_IS_EXPORT_SCHEDULE := v_EMPTY_STRING;
		p_TRANSACTION_STATUS := v_EMPTY_STRING;
		p_TRANSACTION_INTERVAL := v_EMPTY_STRING;
		p_BEGIN_DATE := TRUNC(SYSDATE);
		p_END_DATE := TRUNC(SYSDATE);
		p_PURCHASER := v_EMPTY_STRING;
		p_SELLER := v_EMPTY_STRING;
		p_CONTRACT := v_EMPTY_STRING;
		p_SC := v_EMPTY_STRING;
		p_POR := v_EMPTY_STRING;
		p_POD := v_EMPTY_STRING;
		p_SCHEDULER := v_EMPTY_STRING;
		p_COMMODITY := v_EMPTY_STRING;
		p_SERVICE_TYPE := v_EMPTY_STRING;
		p_COMMODITY_TYPE := v_EMPTY_STRING;
		p_COMMODITY_UNIT := v_EMPTY_STRING;
		p_COMMODITY_UNIT_FORMAT := v_EMPTY_STRING;
		p_COMMODITY_PRICE_UNIT := v_EMPTY_STRING;
		p_COMMODITY_PRICE_FORMAT := v_EMPTY_STRING;
		p_TP_CONTRACT_NUM := v_EMPTY_STRING;
		p_TP_CONTRACT_NAME := v_EMPTY_STRING;
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END READ_INTERCHANGE_TRANSACTION;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_IT_SCHEDULE_TO_WORK
	(
    p_WORK_ID IN NUMBER,
    p_WORK_SEQ IN NUMBER,
    p_TRANSACTION_ID IN NUMBER,
    p_WORK_DATE IN DATE,
    p_AMOUNT IN NUMBER,
    p_PRICE IN NUMBER,
    p_AMOUNT2 IN NUMBER DEFAULT NULL
    ) AS
v_AMOUNT VARCHAR2(16);
v_PRICE VARCHAR2(16);
v_AMOUNT2 VARCHAR2(16);
BEGIN
	v_AMOUNT := SUBSTR(TO_CHAR(NVL(p_AMOUNT,0),'999999999D999'),1,14);
	v_PRICE := SUBSTR(TO_CHAR(NVL(p_PRICE,0),'999999999D999'),1,14);
    IF p_AMOUNT2 IS NULL THEN
    	v_AMOUNT2 := NULL;
    ELSE
    	v_AMOUNT2 := SUBSTR(TO_CHAR(NVL(p_AMOUNT2,0),'999999999D999'),1,14);
	END IF;
	UT.POST_RTO_WORK(p_WORK_ID, p_WORK_SEQ, p_TRANSACTION_ID, p_WORK_DATE, v_AMOUNT||v_PRICE||v_AMOUNT2);
END PUT_IT_SCHEDULE_TO_WORK;
----------------------------------------------------------------------------------------------------
PROCEDURE SCHEDULE_FILL
	(
	p_TRANSACTION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_AMOUNT IN VARCHAR,
	p_PRICE IN VARCHAR,
	p_TEMPLATE IN VARCHAR,
	p_BEGIN_HOUR IN NUMBER,
	p_END_HOUR IN NUMBER,
	p_INCLUDE_HOLIDAYS IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATUS OUT NUMBER,
	p_TO_WORK IN BOOLEAN := FALSE,
	p_WORK_ID IN NUMBER := 0,
    p_USE_INTERVAL IN VARCHAR2 := NULL,
    p_AMOUNT2 IN NUMBER := NULL
	) AS

v_SCHEDULE_DATE DATE;
v_SCHEDULE_END_DATE DATE;
v_DAY CHAR(3);
v_HOUR NUMBER;
v_SECONDS NUMBER;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_TIME_ZONE VARCHAR(3);
v_TRANSACTION_INTERVAL NUMBER;
v_CUT_DATE DATE;
v_ANY_DAY BOOLEAN;
v_WEEK_DAY BOOLEAN;
v_WEEK_END BOOLEAN;
v_MON BOOLEAN;
v_TUE BOOLEAN;
v_WED BOOLEAN;
v_THU BOOLEAN;
v_FRI BOOLEAN;
v_SAT BOOLEAN;
v_SUN BOOLEAN;
v_ALL BOOLEAN;
v_ON BOOLEAN;
v_OFF BOOLEAN;
v_DELETE BOOLEAN;
v_YES CHAR(1) := '1';
v_COUNT NUMBER;
v_AMOUNT NUMBER;
v_PRICE NUMBER;
v_NEW_AMOUNT NUMBER;
v_NEW_PRICE NUMBER;
v_DAY_SCHEDULE BOOLEAN;
v_SEEN_FALL_BACK_HOUR BOOLEAN := FALSE;
v_DAYLIGHT_SAVINGS BOOLEAN := FALSE;
v_SPRING_AHEAD_DATE DATE;
v_FALL_BACK_DATE DATE;
v_CURRENT_TIME_ZONE VARCHAR(3);
v_STD_TIME_ZONE VARCHAR(3);
v_DST_TIME_ZONE VARCHAR(3);
v_ADVANCE_DATE BOOLEAN := TRUE;
v_HOUR_OF_DAY NUMBER(2);
v_DATE DATE;
v_INTERVAL VARCHAR(16);
v_INCLUDE_DAY BOOLEAN;
v_TRANSACTION_TYPE CHAR(2);
v_SCHEDULE_TYPE NUMBER(9);
v_EDC_ID NUMBER(9);
v_HOLIDAY_DATE DATE;
v_AUDIT_TYPE NUMBER;
v_SAVE_AUDIT_ENABLE BOOLEAN := SECURITY_CONTROLS.IS_AUDIT_ENABLED;

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	IF NOT SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_TXN_UPDATE, p_TRANSACTION_ID) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	IF g_TRACE_ON THEN
	    UT.DEBUG_TRACE('TRANSACTION_ID=' || TO_CHAR(p_TRANSACTION_ID));
		UT.DEBUG_TRACE('BEGIN_DATE=' || UT.TRACE_DATE(p_BEGIN_DATE));
		UT.DEBUG_TRACE('END_DATE=' || UT.TRACE_DATE(p_END_DATE));
		UT.DEBUG_TRACE('TIME_ZONE=' || p_TIME_ZONE);
		UT.DEBUG_TRACE('AMOUNT=' || p_AMOUNT);
		UT.DEBUG_TRACE('PRICE=' || p_PRICE);
		UT.DEBUG_TRACE('TEMPLATE=' || p_TEMPLATE);
		UT.DEBUG_TRACE('BEGIN_HOUR=' || TO_CHAR(p_BEGIN_HOUR));
		UT.DEBUG_TRACE('END_HOUR=' || TO_CHAR(p_END_HOUR));
		UT.DEBUG_TRACE('INCLUDE_HOLIDAYS=' || TO_CHAR(p_INCLUDE_HOLIDAYS));
	END IF;

    IF NOT p_TO_WORK THEN -- no need to audit entries to work table
		SELECT DECODE(NVL(MODEL_VALUE_AT_KEY(0,'Audit Trail','Scheduling','ScheduleFillBehavior',0),'0'),'1',1,'2',2,0)
        INTO v_AUDIT_TYPE
        FROM DUAL;
	ELSE
    	v_AUDIT_TYPE := 0;
	END IF;

	SELECT BEGIN_DATE,END_DATE,UPPER(TRIM(TRANSACTION_INTERVAL)),UPPER(SUBSTR(TRANSACTION_TYPE,1,2))
	INTO v_BEGIN_DATE, v_END_DATE, v_INTERVAL, v_TRANSACTION_TYPE
	FROM INTERCHANGE_TRANSACTION
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;
    -- can only specify an interval when putting schedule to RTO_WORK - not to IT_SCHEDULE
    IF NVL(LENGTH(p_USE_INTERVAL),0) > 0 AND p_TO_WORK THEN
    	v_INTERVAL := UPPER(p_USE_INTERVAL);
    END IF;
	IF NVL(LENGTH(v_INTERVAL),0) = 0 THEN
		p_STATUS := -1;
		RETURN;
	END IF;
	p_STATUS := 0;
	IF p_BEGIN_DATE < v_BEGIN_DATE THEN
		p_STATUS := -2;
	END IF;
	IF p_END_DATE > v_END_DATE THEN
		p_STATUS := -3;
	END IF;
	IF p_BEGIN_DATE > v_END_DATE OR p_END_DATE < v_BEGIN_DATE THEN
		p_STATUS := -4;
		RETURN;
	END IF;
	v_AMOUNT := LTRIM(RTRIM(p_AMOUNT));
	v_PRICE := LTRIM(RTRIM(p_PRICE));
	v_TIME_ZONE := LTRIM(RTRIM(p_TIME_ZONE));
	v_CURRENT_TIME_ZONE := v_TIME_ZONE;
	v_SCHEDULE_DATE := TRUNC(GREATEST(p_BEGIN_DATE,v_BEGIN_DATE));
	v_SCHEDULE_END_DATE := TRUNC(LEAST(p_END_DATE,v_END_DATE)) + 1;
	SELECT NVL(EDC_ID,0) INTO v_EDC_ID FROM INTERCHANGE_TRANSACTION WHERE TRANSACTION_ID = p_TRANSACTION_ID;

	IF GA.ENABLE_SUPPLY_SCHEDULE_TYPES THEN
		v_SCHEDULE_TYPE := p_SCHEDULE_TYPE;
	ELSE
		-- 'Retail Load' and 'Load' Schedules get types, others (supply schedules) get zero
		SELECT DECODE(v_TRANSACTION_TYPE,'RE',p_SCHEDULE_TYPE,'LO',p_SCHEDULE_TYPE,0) INTO v_SCHEDULE_TYPE FROM DUAL;
	END IF;

	IF SUBSTR(v_TIME_ZONE,2,1) = 'D' THEN
		v_DAYLIGHT_SAVINGS := TRUE;
		v_SPRING_AHEAD_DATE := TRUNC(DST_SPRING_AHEAD_DATE(v_SCHEDULE_DATE));
		v_FALL_BACK_DATE := TRUNC(DST_FALL_BACK_DATE(v_SCHEDULE_DATE));
		v_STD_TIME_ZONE := STD_TIME_ZONE(v_TIME_ZONE);
		v_DST_TIME_ZONE := DST_TIME_ZONE(v_TIME_ZONE);
	ELSE
		v_DAYLIGHT_SAVINGS := FALSE;
		v_SPRING_AHEAD_DATE := NULL;
		v_FALL_BACK_DATE := NULL;
		v_STD_TIME_ZONE := NULL;
		v_DST_TIME_ZONE := NULL;
	END IF;
	IF v_INTERVAL IN ('DAY','WEEK','MONTH','QUARTER','YEAR') THEN
		v_DAY_SCHEDULE := TRUE;
		IF v_INTERVAL = 'MONTH' THEN
			v_SCHEDULE_DATE := ADD_SECONDS_TO_DATE(TRUNC(v_SCHEDULE_DATE,'MONTH'), 1);
		ELSIF v_INTERVAL = 'QUARTER' THEN
			v_SCHEDULE_DATE := ADD_SECONDS_TO_DATE(TRUNC(v_SCHEDULE_DATE,'Q'), 1);
		ELSIF v_INTERVAL = 'YEAR' THEN
			v_SCHEDULE_DATE := ADD_SECONDS_TO_DATE(TRUNC(v_SCHEDULE_DATE,'YEAR'), 1);
		ELSIF v_INTERVAL = 'WEEK' THEN
			v_SCHEDULE_DATE := ADD_SECONDS_TO_DATE(TRUNC(v_SCHEDULE_DATE,'DY'), 1);
		ELSE
			v_SCHEDULE_DATE := ADD_SECONDS_TO_DATE(TRUNC(v_SCHEDULE_DATE), 1);
		END IF;
	ELSE
		v_DAY_SCHEDULE := FALSE;
		v_SCHEDULE_DATE := ADVANCE_DATE(v_SCHEDULE_DATE, v_INTERVAL);
	END IF;
-- Decode the VB template
	v_ANY_DAY := SUBSTR(p_TEMPLATE,1,1) = v_YES;
	v_WEEK_DAY := SUBSTR(p_TEMPLATE,2,1) = v_YES;
	v_WEEK_END := SUBSTR(p_TEMPLATE,3,1) = v_YES;
	v_MON := SUBSTR(p_TEMPLATE,4,1) = v_YES;
	v_TUE := SUBSTR(p_TEMPLATE,5,1) = v_YES;
	v_WED := SUBSTR(p_TEMPLATE,6,1) = v_YES;
	v_THU := SUBSTR(p_TEMPLATE,7,1) = v_YES;
	v_FRI := SUBSTR(p_TEMPLATE,8,1) = v_YES;
	v_SAT := SUBSTR(p_TEMPLATE,9,1) = v_YES;
	v_SUN := SUBSTR(p_TEMPLATE,10,1) = v_YES;
	v_ALL := SUBSTR(p_TEMPLATE,11,1) = v_YES;
	v_ON := SUBSTR(p_TEMPLATE,12,1) = v_YES;
	v_OFF := SUBSTR(p_TEMPLATE,13,1) = v_YES;
	v_DELETE := SUBSTR(p_TEMPLATE,14,1) = v_YES;

    -- initial audit stuff
    IF v_AUDIT_TYPE > 0 THEN
    	DECLARE
        	v_VALS VARCHAR2(128);
            v_DAYS VARCHAR2(64) := '';
		BEGIN
        	v_VALS := TO_CHAR(p_BEGIN_DATE,'YYYY/MM/DD')||' - '||TO_CHAR(p_END_DATE,'YYYY/MM/DD')||', ';
            IF v_ALL THEN
            	v_VALS := v_VALS||'All Hours '||p_TIME_ZONE||', ';
            ELSE
            	v_VALS := v_VALS||'Hours '||p_BEGIN_HOUR||' to '||p_END_HOUR||' '||p_TIME_ZONE||' ';
                IF v_ON THEN
                	v_VALS := v_VALS||'On, ';
				ELSE -- v_OFF
                	v_VALS := v_VALS||'Off, ';
				END IF;
            END IF;
            IF v_ANY_DAY THEN v_DAYS := v_DAYS||'-Any'; END IF;
            IF v_WEEK_DAY THEN v_DAYS := v_DAYS||'-WD'; END IF;
            IF v_WEEK_END THEN v_DAYS := v_DAYS||'-WE'; END IF;
            IF v_MON THEN v_DAYS := v_DAYS||'-Mon'; END IF;
            IF v_TUE THEN v_DAYS := v_DAYS||'-Tue'; END IF;
            IF v_WED THEN v_DAYS := v_DAYS||'-Wed'; END IF;
            IF v_THU THEN v_DAYS := v_DAYS||'-Thu'; END IF;
            IF v_FRI THEN v_DAYS := v_DAYS||'-Fri'; END IF;
            IF v_SAT THEN v_DAYS := v_DAYS||'-Sat'; END IF;
            IF v_SUN THEN v_DAYS := v_DAYS||'-Sun'; END IF;
            IF p_INCLUDE_HOLIDAYS <> 0 THEN v_DAYS := v_DAYS||'-Hol'; END IF;
            v_VALS := v_VALS||SUBSTR(v_DAYS,2)||', Values: '||p_AMOUNT||', '||p_PRICE;

            IF v_AUDIT_TYPE = 1 THEN
             	SECURITY_CONTROLS.POST_TO_ENTITY_AUDIT_TRAIL(-200, p_TRANSACTION_ID, p_BEGIN_DATE, p_END_DATE, '?', p_SCHEDULE_TYPE, 1, 'IT_SCHEDULE', 'AMOUNT, PRICE', SYSDATE, 'BEGIN SCHEDULE FILL', NULL, NULL, '*', NULL, v_VALS);
            ELSIF v_AUDIT_TYPE = 2 THEN
				SECURITY_CONTROLS.SET_IS_AUDIT_ENABLED(FALSE); -- temporarily disable
             	SECURITY_CONTROLS.POST_TO_ENTITY_AUDIT_TRAIL(-200, p_TRANSACTION_ID, p_BEGIN_DATE, p_END_DATE, '?', p_SCHEDULE_TYPE, 1, 'IT_SCHEDULE', 'AMOUNT, PRICE', SYSDATE, 'SCHEDULE FILL', NULL, NULL, '*', NULL, v_VALS);
            END IF;
		END;
    END IF;

-- Delete any existing records if the option is specified.
	IF v_DELETE AND NOT p_TO_WORK THEN
		DELETE IT_SCHEDULE
		WHERE TRANSACTION_ID = p_TRANSACTION_ID
			AND SCHEDULE_TYPE = p_SCHEDULE_TYPE
			AND SCHEDULE_STATE = g_INTERNAL_STATE
			AND SCHEDULE_DATE BETWEEN TO_CUT(v_SCHEDULE_DATE,v_TIME_ZONE)
			AND TO_CUT(v_SCHEDULE_END_DATE,v_TIME_ZONE);
	END IF;
	v_COUNT := 0;
-- Loop over the intervals of the specified time period.
	WHILE v_SCHEDULE_DATE <= v_SCHEDULE_END_DATE LOOP
		v_NEW_AMOUNT := NULL;
		v_NEW_PRICE := NULL;
		v_DAY := SUBSTR(TO_CHAR(TO_HED_AS_DATE(v_SCHEDULE_DATE), 'DAY'), 1, 3);
        -- add 59 minutes to make sure we get hour as hour-ending
		v_HOUR := TO_NUMBER(TO_CHAR(v_SCHEDULE_DATE+59/(24*60), 'HH24'));
		IF v_HOUR = 0 THEN
		   v_HOUR := 24;
		END IF;
-- Determine if the schedule date is a holiday and whether to include.
	  	v_INCLUDE_DAY := TRUE;
    	IF p_INCLUDE_HOLIDAYS = 0 THEN
			IF v_DAY_SCHEDULE THEN
				v_HOLIDAY_DATE := TRUNC(v_SCHEDULE_DATE);
			ELSE
				v_HOLIDAY_DATE := TRUNC(v_SCHEDULE_DATE - 1/24);
			END IF;

			IF IS_HOLIDAY(v_HOLIDAY_DATE, v_EDC_ID) THEN
		    	v_INCLUDE_DAY := FALSE;
			END IF;
		END IF;

		IF v_DAY_SCHEDULE THEN
		    IF v_INTERVAL = 'DAY' THEN
			    IF v_INCLUDE_DAY AND (v_ANY_DAY
			        OR (v_WEEK_DAY AND v_DAY IN ('MON','TUE','WED','THU','FRI'))
					OR (v_WEEK_END AND v_DAY IN ('SAT','SUN'))
					OR (v_MON AND v_DAY = 'MON')
					OR (v_TUE AND v_DAY = 'TUE')
					OR (v_WED AND v_DAY = 'WED')
					OR (v_THU AND v_DAY = 'THU')
					OR (v_FRI AND v_DAY = 'FRI')
					OR (v_SAT AND v_DAY = 'SAT')
					OR (v_SUN AND v_DAY = 'SUN')) THEN
				        v_NEW_AMOUNT := v_AMOUNT;
						v_NEW_PRICE := v_PRICE;
				END IF;
			ELSE
				v_NEW_AMOUNT := v_AMOUNT;
				v_NEW_PRICE := v_PRICE;
			END IF;
		ELSIF v_INCLUDE_DAY AND (v_ANY_DAY
			OR (v_WEEK_DAY AND v_DAY IN ('MON','TUE','WED','THU','FRI'))
			OR (v_WEEK_END AND v_DAY IN ('SAT','SUN'))
			OR (v_MON AND v_DAY = 'MON')
			OR (v_TUE AND v_DAY = 'TUE')
			OR (v_WED AND v_DAY = 'WED')
			OR (v_THU AND v_DAY = 'THU')
			OR (v_FRI AND v_DAY = 'FRI')
			OR (v_SAT AND v_DAY = 'SAT')
			OR (v_SUN AND v_DAY = 'SUN')) THEN
				IF v_ALL
					OR (v_ON AND v_HOUR BETWEEN p_BEGIN_HOUR AND p_END_HOUR)
					OR (v_OFF AND v_HOUR NOT BETWEEN p_BEGIN_HOUR AND p_END_HOUR) THEN
						v_NEW_AMOUNT := v_AMOUNT;
						v_NEW_PRICE := v_PRICE;
				END IF;
		END IF;
-- Determine the proper date and time zone for the schedule date
		v_ADVANCE_DATE := TRUE;
		IF v_DAYLIGHT_SAVINGS THEN
			v_CURRENT_TIME_ZONE := v_STD_TIME_ZONE;
			v_DATE := TRUNC(v_SCHEDULE_DATE);
			IF v_DATE BETWEEN v_SPRING_AHEAD_DATE AND v_FALL_BACK_DATE THEN
				v_CURRENT_TIME_ZONE := v_DST_TIME_ZONE;
				IF v_DATE = v_SPRING_AHEAD_DATE THEN
					v_HOUR_OF_DAY := TO_NUMBER(TO_CHAR(v_SCHEDULE_DATE,'HH24'));
					IF v_HOUR_OF_DAY < 2 THEN
						v_CURRENT_TIME_ZONE := v_STD_TIME_ZONE;
					ELSE
						IF v_HOUR_OF_DAY = 2 THEN
							v_SCHEDULE_DATE := ADD_SECONDS_TO_DATE(v_SCHEDULE_DATE, 3600);
						END IF;
						v_CURRENT_TIME_ZONE := v_DST_TIME_ZONE;
					END IF;
				ELSIF v_DATE = v_FALL_BACK_DATE THEN
					v_HOUR_OF_DAY := TO_NUMBER(TO_CHAR(v_SCHEDULE_DATE,'HH24'));
					v_CURRENT_TIME_ZONE := v_STD_TIME_ZONE;
					IF v_HOUR_OF_DAY <= 2 THEN
						IF v_HOUR_OF_DAY = 2 AND NOT v_SEEN_FALL_BACK_HOUR THEN
								v_ADVANCE_DATE := FALSE;
								v_SEEN_FALL_BACK_HOUR := TRUE;
								v_CURRENT_TIME_ZONE := v_DST_TIME_ZONE;
							END IF;
						IF v_HOUR_OF_DAY < 2 THEN
							v_CURRENT_TIME_ZONE := v_DST_TIME_ZONE;
						END IF;
					END IF;
				END IF;
			END IF;
		END IF;
-- Update an existing schedule or insert a new schedule.
   		IF NOT (v_NEW_AMOUNT IS NULL AND v_NEW_PRICE IS NULL) THEN
			IF v_DAY_SCHEDULE THEN
				v_CUT_DATE := FROM_HED(TO_CHAR(TRUNC(v_SCHEDULE_DATE),'YYYY-MM-DD'), NULL);
			ELSE
				-- Use CUT date to store to database.
				v_CUT_DATE := TO_CUT(v_SCHEDULE_DATE,v_CURRENT_TIME_ZONE);
			END IF;
			IF p_TO_WORK THEN
            	PUT_IT_SCHEDULE_TO_WORK(p_WORK_ID, v_COUNT, p_TRANSACTION_ID, v_CUT_DATE, v_NEW_AMOUNT, v_NEW_PRICE, p_AMOUNT2);
			ELSE
				PUT_IT_SCHEDULE(p_TRANSACTION_ID, v_SCHEDULE_TYPE, v_CUT_DATE, p_AS_OF_DATE, v_NEW_AMOUNT, v_NEW_PRICE, p_STATUS);
			END IF;
		END IF;
		IF v_ADVANCE_DATE THEN
			v_SCHEDULE_DATE := ADVANCE_DATE(v_SCHEDULE_DATE, v_INTERVAL);
		END IF;
	END LOOP;

	-- finish audit stuff
	IF v_AUDIT_TYPE = 1 THEN
  		SECURITY_CONTROLS.POST_TO_ENTITY_AUDIT_TRAIL(-200, p_TRANSACTION_ID, p_BEGIN_DATE, p_END_DATE, '?', p_SCHEDULE_TYPE, 1, 'IT_SCHEDULE', '*', SYSDATE, 'END SCHEDULE FILL', NULL, NULL, '*', NULL, NULL);
	END IF;
  	SECURITY_CONTROLS.SET_IS_AUDIT_ENABLED(v_SAVE_AUDIT_ENABLE); -- make sure to restore this value

	EXCEPTION
		WHEN OTHERS THEN
        	SECURITY_CONTROLS.SET_IS_AUDIT_ENABLED(v_SAVE_AUDIT_ENABLE); -- make sure to restore this value
			p_STATUS := SQLCODE;

END SCHEDULE_FILL;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SCHEDULE_FILL_RECORDS
	(
	p_TRANSACTION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_AMOUNT IN VARCHAR,
	p_PRICE IN VARCHAR,
	p_TEMPLATE IN VARCHAR,
	p_BEGIN_HOUR IN NUMBER,
	p_END_HOUR IN NUMBER,
	p_INCLUDE_HOLIDAYS IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_WORK_ID NUMBER;
v_FMT VARCHAR2(8);
BEGIN
	UT.GET_RTO_WORK_ID(v_WORK_ID);

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	SCHEDULE_FILL (p_TRANSACTION_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE, p_AMOUNT, p_PRICE, p_TEMPLATE,
			   p_BEGIN_HOUR, p_END_HOUR, p_INCLUDE_HOLIDAYS, p_SCHEDULE_TYPE, p_STATUS, TRUE, v_WORK_ID);
	IF p_STATUS < 0 THEN
		NULL_CURSOR(p_CURSOR);
		RETURN;
	END IF;

	SELECT DECODE(UPPER(SUBSTR(TRANSACTION_INTERVAL,1,2)),'5 ','MI5','10','MI5','15','MI5','20','MI5','30','MI5','HO','HH','DA','DD','WE','DD','MO','DD','QU','DD','YE','DD')
    INTO v_FMT
    FROM INTERCHANGE_TRANSACTION
    WHERE TRANSACTION_ID = p_TRANSACTION_ID;

	OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(WORK_DATE,p_TIME_ZONE,v_FMT) "DATE",
			SUBSTR(WORK_DATA,1,14) "AMOUNT"
		FROM RTO_WORK
		WHERE WORK_ID = v_WORK_ID
		ORDER BY 1;

	UT.PURGE_RTO_WORK(v_WORK_ID);

	EXCEPTION
		WHEN OTHERS THEN
			UT.PURGE_RTO_WORK(v_WORK_ID);
			p_STATUS := SQLCODE;

END GET_SCHEDULE_FILL_RECORDS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_IT_SCHEDULE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SCHEDULE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_AMOUNT IN NUMBER,
	p_PRICE IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

v_AS_OF_DATE DATE;
v_ADD NUMBER;
BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;
	IF GA.VERSION_SCHEDULE THEN
		v_AS_OF_DATE := CORRECTED_AS_OF_DATE(p_AS_OF_DATE);
	ELSE
		v_AS_OF_DATE := LOW_DATE;
	END IF;

    UPDATE IT_SCHEDULE SET
        AMOUNT = NVL(p_AMOUNT, AMOUNT),
        PRICE = NVL(p_PRICE, PRICE)
    WHERE TRANSACTION_ID = p_TRANSACTION_ID
        AND SCHEDULE_TYPE = p_SCHEDULE_TYPE
        AND SCHEDULE_STATE = DECODE(p_SCHEDULE_STATE,2,2,1)
        AND SCHEDULE_DATE = p_SCHEDULE_DATE
        AND AS_OF_DATE = v_AS_OF_DATE;

    IF SQL%NOTFOUND THEN
	    INSERT INTO IT_SCHEDULE (
            TRANSACTION_ID,
            SCHEDULE_TYPE,
            SCHEDULE_STATE,
            SCHEDULE_DATE,
            AS_OF_DATE,
            AMOUNT,
            PRICE)
	    VALUES (
            p_TRANSACTION_ID,
            p_SCHEDULE_TYPE,
            DECODE(p_SCHEDULE_STATE,2,2,1),
            p_SCHEDULE_DATE,
            v_AS_OF_DATE,
            p_AMOUNT,
            p_PRICE);
	END IF;

	EXCEPTION
		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END PUT_IT_SCHEDULE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_IT_SCHEDULE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_AMOUNT IN NUMBER,
	p_PRICE IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	PUT_IT_SCHEDULE(p_TRANSACTION_ID, p_SCHEDULE_TYPE, g_INTERNAL_STATE, p_SCHEDULE_DATE, p_AS_OF_DATE, p_AMOUNT, p_PRICE, p_STATUS);

END PUT_IT_SCHEDULE;
----------------------------------------------------------------------------------------------------
PROCEDURE COPY_IT_SCHEDULE
	(
	p_SRC_TRANSACTION_ID IN NUMBER,
	p_SRC_BEGIN_DATE IN DATE,
	p_SRC_END_DATE IN DATE,
	p_SRC_AS_OF_DATE IN DATE,
	p_SRC_SCHEDULE_TYPE IN NUMBER,
	p_SRC_SCHEDULE_STATE IN NUMBER,
	p_TRG_TRANSACTION_ID IN NUMBER,
	p_TRG_BEGIN_DATE IN DATE,
	p_TRG_END_DATE IN DATE,
	p_TRG_AS_OF_DATE IN DATE,
	p_TRG_SCHEDULE_TYPE IN NUMBER,
	p_TRG_SCHEDULE_STATE IN NUMBER,
	p_TRG_DELETE IN NUMBER,
	p_COPY_AMOUNT IN NUMBER,
	p_COPY_PRICE IN NUMBER,
	p_STATUS OUT NUMBER
	) AS
v_FIRST BOOLEAN;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_TRG_DATE DATE;
v_SRC_TRG_DIFF NUMBER;
v_SRC_BEGIN_END_DIFF NUMBER;
CURSOR c_SCHEDULE IS
	SELECT SCHEDULE_DATE,
		DECODE(p_COPY_AMOUNT,1,AMOUNT,NULL) "AMOUNT",
		DECODE(p_COPY_PRICE,1,PRICE,NULL) "PRICE"
	FROM IT_SCHEDULE
	WHERE TRANSACTION_ID = p_SRC_TRANSACTION_ID
		AND SCHEDULE_TYPE = p_SRC_SCHEDULE_TYPE
		AND SCHEDULE_STATE = p_SRC_SCHEDULE_STATE
		AND SCHEDULE_DATE BETWEEN p_SRC_BEGIN_DATE AND p_SRC_END_DATE
		AND AS_OF_DATE = SCHEDULE_AS_OF_DATE(TRANSACTION_ID, SCHEDULE_TYPE, SCHEDULE_STATE, SCHEDULE_DATE, p_SRC_AS_OF_DATE);
v_SCHEDULE c_SCHEDULE%ROWTYPE;

BEGIN
	p_STATUS := GA.SUCCESS;
	v_SRC_BEGIN_END_DIFF := p_SRC_END_DATE - p_SRC_BEGIN_DATE;
	v_TRG_DATE := p_TRG_BEGIN_DATE;
	v_BEGIN_DATE := p_TRG_BEGIN_DATE;
	v_END_DATE := p_TRG_BEGIN_DATE + v_SRC_BEGIN_END_DIFF;
	-- update target's begin and end dates to make sure they accomodate the new data
	UPDATE INTERCHANGE_TRANSACTION
	SET BEGIN_DATE = LEAST(BEGIN_DATE,TRUNC(p_TRG_BEGIN_DATE)),
		END_DATE = GREATEST(END_DATE,TRUNC(ADD_SECONDS_TO_DATE(p_TRG_END_DATE,-1)))
	WHERE TRANSACTION_ID = p_TRG_TRANSACTION_ID;
	-- loop through, auto-wrapping in case where target dates further apart than source dates
	WHILE v_BEGIN_DATE <= p_TRG_END_DATE LOOP
		-- update target/source delta for this iteration
		v_SRC_TRG_DIFF := v_BEGIN_DATE - p_SRC_BEGIN_DATE;
		v_FIRST := TRUE;
		OPEN c_SCHEDULE;
		LOOP
			IF v_FIRST THEN
				-- delete here, after cursor is opened, in case delete would wipe out
				-- entries we need for copy (in case of overlapping dates copied into
				-- the same schedule as source)
				IF p_TRG_DELETE = 1 THEN
					DECLARE
						v_TRG_END DATE;
					BEGIN
						SELECT LEAST(v_END_DATE,p_TRG_END_DATE) INTO v_TRG_END FROM DUAL;
						DELETE FROM IT_SCHEDULE
						WHERE TRANSACTION_ID = p_TRG_TRANSACTION_ID
							AND SCHEDULE_TYPE = p_TRG_SCHEDULE_TYPE
							AND SCHEDULE_STATE = p_TRG_SCHEDULE_STATE
							AND SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_TRG_END;
					END;
				END IF;
				v_FIRST := FALSE;
			END IF;
			FETCH c_SCHEDULE INTO v_SCHEDULE;
			EXIT WHEN c_SCHEDULE%NOTFOUND;
			v_TRG_DATE := v_SCHEDULE.SCHEDULE_DATE + v_SRC_TRG_DIFF;
			EXIT WHEN v_TRG_DATE > p_TRG_END_DATE;
			PUT_IT_SCHEDULE(p_TRG_TRANSACTION_ID, p_TRG_SCHEDULE_TYPE, p_TRG_SCHEDULE_STATE, v_TRG_DATE, p_TRG_AS_OF_DATE, v_SCHEDULE.AMOUNT, v_SCHEDULE.PRICE, p_STATUS);
			IF p_STATUS < 0 THEN
				ROLLBACK;
				RETURN;
			END IF;
		END LOOP;
		CLOSE c_SCHEDULE;
		-- set our dates for the next iteration/section
		v_BEGIN_DATE := ADD_SECONDS_TO_DATE(v_END_DATE,1);
		v_END_DATE := v_BEGIN_DATE + v_SRC_BEGIN_END_DIFF;
	END LOOP;

EXCEPTION
	WHEN OTHERS THEN
		ROLLBACK;
		p_STATUS := SQLCODE;
END COPY_IT_SCHEDULE;
----------------------------------------------------------------------------------------------------
PROCEDURE SCHEDULE_COPY
	(
	p_SRC_TRANSACTION_ID IN NUMBER,
	p_SRC_BEGIN_DATE IN DATE,
	p_SRC_END_DATE IN DATE,
	p_SRC_AS_OF_DATE IN DATE,
	p_SRC_SCHEDULE_TYPE IN NUMBER,
	p_SRC_EXTERNAL IN NUMBER,
	p_TRG_TRANSACTION_ID IN NUMBER,
	p_TRG_BEGIN_DATE IN DATE,
	p_TRG_END_DATE IN DATE,
	p_TRG_AS_OF_DATE IN DATE,
	p_TRG_SCHEDULE_TYPE IN NUMBER,
	p_TRG_EXTERNAL IN NUMBER,
	p_TRG_DELETE IN NUMBER,
	p_COPY_AMOUNT IN NUMBER,
	p_COPY_PRICE IN NUMBER,
	p_COPY_BID_OFFER_AMOUNT IN NUMBER,
	p_COPY_BID_OFFER_PRICE IN NUMBER,
	p_STATUS OUT NUMBER
	) AS
v_SRC_STATE NUMBER(1);
v_TRG_STATE NUMBER(1);
BEGIN

	SELECT DECODE(p_SRC_EXTERNAL,1,g_EXTERNAL_STATE,g_INTERNAL_STATE)
	INTO v_SRC_STATE FROM DUAL;
	SELECT DECODE(p_TRG_EXTERNAL,1,g_EXTERNAL_STATE,g_INTERNAL_STATE)
	INTO v_TRG_STATE FROM DUAL;

	COPY_IT_SCHEDULE (p_SRC_TRANSACTION_ID,p_SRC_BEGIN_DATE,p_SRC_END_DATE,
			p_SRC_AS_OF_DATE,p_SRC_SCHEDULE_TYPE,v_SRC_STATE,
			p_TRG_TRANSACTION_ID,p_TRG_BEGIN_DATE,p_TRG_END_DATE,
			p_TRG_AS_OF_DATE,p_TRG_SCHEDULE_TYPE,v_TRG_STATE,
			p_TRG_DELETE,p_COPY_AMOUNT,p_COPY_PRICE,p_STATUS);
	IF p_STATUS <> GA.SUCCESS THEN
		RETURN;
	END IF;

	BO.COPY_BIDS_AND_OFFERS(p_SRC_TRANSACTION_ID,p_SRC_BEGIN_DATE,p_SRC_END_DATE,v_SRC_STATE,
			p_TRG_TRANSACTION_ID,p_TRG_BEGIN_DATE,p_TRG_END_DATE,v_TRG_STATE,p_TRG_AS_OF_DATE,
			p_TRG_DELETE,p_COPY_BID_OFFER_AMOUNT,p_COPY_BID_OFFER_PRICE,p_STATUS);

EXCEPTION
	WHEN OTHERS THEN
		ROLLBACK;
		p_STATUS := SQLCODE;

END SCHEDULE_COPY;
----------------------------------------------------------------------------------------------------
PROCEDURE SCHEDULE_COPY_REQUEST
	(
	p_SRC_TRANSACTION_ID IN NUMBER,
	p_SRC_BEGIN_DATE IN DATE,
	p_SRC_END_DATE IN DATE,
	p_SRC_AS_OF_DATE IN DATE,
	p_SRC_SCHEDULE_TYPE IN NUMBER,
	p_SRC_EXTERNAL IN NUMBER,
	p_TRG_TRANSACTION_IDs IN VARCHAR2,
	p_TRG_BEGIN_DATE IN DATE,
	p_TRG_END_DATE IN DATE,
	p_TRG_AS_OF_DATE IN DATE,
	p_TRG_SCHEDULE_TYPE IN NUMBER,
	p_TRG_EXTERNAL IN NUMBER,
	p_TRG_DELETE IN NUMBER,
    p_COPY_AMOUNT IN NUMBER,
	p_COPY_PRICE IN NUMBER,
	p_COPY_BID_OFFER_AMOUNT IN NUMBER,
	p_COPY_BID_OFFER_PRICE IN NUMBER,
	p_TIME_ZONE IN CHAR,
	p_STATUS OUT NUMBER
	) AS

v_IDs_TABLE GA.STRING_TABLE;
v_SRC_BEGIN_DATE DATE;
v_SRC_END_DATE DATE;
v_TRG_BEGIN_DATE DATE;
v_TRG_END_DATE DATE;

BEGIN
	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	UT.CUT_DATE_RANGE (p_SRC_BEGIN_DATE, p_SRC_END_DATE, p_TIME_ZONE, v_SRC_BEGIN_DATE, v_SRC_END_DATE);
	UT.CUT_DATE_RANGE (p_TRG_BEGIN_DATE, p_TRG_END_DATE, p_TIME_ZONE, v_TRG_BEGIN_DATE, v_TRG_END_DATE);

	p_STATUS := GA.SUCCESS;
	UT.TOKENS_FROM_STRING(p_TRG_TRANSACTION_IDs, ';', v_IDs_TABLE);

	FOR v_INDEX IN v_IDs_TABLE.FIRST..v_IDs_TABLE.LAST LOOP
		SCHEDULE_COPY(p_SRC_TRANSACTION_ID, v_SRC_BEGIN_DATE, v_SRC_END_DATE, p_SRC_AS_OF_DATE, p_SRC_SCHEDULE_TYPE, p_SRC_EXTERNAL,
				v_IDs_TABLE(v_INDEX), v_TRG_BEGIN_DATE, v_TRG_END_DATE, p_TRG_AS_OF_DATE, p_TRG_SCHEDULE_TYPE, p_TRG_EXTERNAL, p_TRG_DELETE,
				p_COPY_AMOUNT, p_COPY_PRICE, p_COPY_BID_OFFER_AMOUNT, p_COPY_BID_OFFER_PRICE, p_STATUS);
	END LOOP;

	EXCEPTION
		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END SCHEDULE_COPY_REQUEST;
----------------------------------------------------------------------------------------------------
PROCEDURE SCHEDULE_UPDATE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_DATE IN VARCHAR,
	p_TIME IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_AMOUNT IN VARCHAR,
	p_PRICE IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_AMOUNT NUMBER;
v_PRICE NUMBER;
v_CUT_DATE DATE;

BEGIN

	p_STATUS := GA.SUCCESS;

	IF TRIM(p_AMOUNT) IS NULL THEN
		v_AMOUNT := NULL;
	ELSE
		BEGIN
			v_AMOUNT := TO_NUMBER(TRIM(p_AMOUNT));
		EXCEPTION
			WHEN OTHERS THEN
				-- in case it is an issue with regional settings, swap commas and periods
				-- and try again
				v_AMOUNT := TO_NUMBER( REPLACE(REPLACE(REPLACE(TRIM(p_AMOUNT),'.','?'), ',', '.'),'?',',') );
		END;
	END IF;

	IF TRIM(p_PRICE) IS NULL THEN
		v_PRICE := NULL;
	ELSE
		BEGIN
			v_PRICE := TO_NUMBER(TRIM(p_PRICE));
		EXCEPTION
			WHEN OTHERS THEN
				-- in case it is an issue with regional settings, swap commas and periods
				-- and try again
				v_PRICE := TO_NUMBER( REPLACE(REPLACE(REPLACE(TRIM(p_PRICE),'.','?'), ',', '.'),'?',',') );
		END;
	END IF;

	IF RTRIM(LTRIM(p_TIME)) = '' OR p_TIME IS NULL THEN
		v_CUT_DATE := FROM_HED(p_DATE, p_TIME);
	ELSE
		v_CUT_DATE := DATE_TIME_AS_CUT(p_DATE, p_TIME, p_TIME_ZONE);
	END IF;

	PUT_IT_SCHEDULE(p_TRANSACTION_ID, p_SCHEDULE_TYPE, p_SCHEDULE_STATE, v_CUT_DATE, p_AS_OF_DATE, v_AMOUNT, v_PRICE, p_STATUS);

	EXCEPTION
		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END SCHEDULE_UPDATE;
----------------------------------------------------------------------------------------------------
PROCEDURE SCHEDULE_UPDATE_REQUEST
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_ARGUMENTS IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_ARGUMENTS_TABLE GA.STRING_TABLE;
v_VALUES_TABLE GA.STRING_TABLE;
v_INDEX NUMBER;
v_SCHEDULE_TYPE NUMBER;
v_AUDIT_TYPE NUMBER;
v_SAVE_AUDIT_ENABLE BOOLEAN := SECURITY_CONTROLS.IS_AUDIT_ENABLED;
v_VALS VARCHAR2(4000) := '';
BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	IF NOT SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_TXN_UPDATE, p_TRANSACTION_ID) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	SELECT DECODE(NVL(MODEL_VALUE_AT_KEY(0,'Audit Trail','Scheduling','ScheduleUpdateBehavior',0),'0'),'1',1,'2',2,0)
    INTO v_AUDIT_TYPE
    FROM DUAL;

    -- initial audit stuff
    IF v_AUDIT_TYPE = 1 THEN
     	SECURITY_CONTROLS.POST_TO_ENTITY_AUDIT_TRAIL(-200, p_TRANSACTION_ID, LOW_DATE, LOW_DATE, '?', p_SCHEDULE_TYPE, p_SCHEDULE_STATE, 'IT_SCHEDULE', 'AMOUNT, PRICE', SYSDATE, 'BEGIN EDIT MULTIPLE', NULL, NULL, '*', NULL, v_VALS);
	ELSIF v_AUDIT_TYPE = 2 THEN
    	SECURITY_CONTROLS.SET_IS_AUDIT_ENABLED(FALSE);
	END IF;

	IF GA.ENABLE_SUPPLY_SCHEDULE_TYPES THEN
		v_SCHEDULE_TYPE := p_SCHEDULE_TYPE;
	ELSE
		-- 'Retail Load' and 'Load' Schedules get types, others (supply schedules) get zero
		SELECT DECODE(UPPER(SUBSTR(TRANSACTION_TYPE,1,2)),'RE',p_SCHEDULE_TYPE,'LO',p_SCHEDULE_TYPE,0)
		INTO v_SCHEDULE_TYPE
		FROM INTERCHANGE_TRANSACTION
		WHERE TRANSACTION_ID = p_TRANSACTION_ID;
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.TOKENS_FROM_STRING(p_ARGUMENTS, ';', v_ARGUMENTS_TABLE);

	FOR v_INDEX IN v_ARGUMENTS_TABLE.FIRST..v_ARGUMENTS_TABLE.LAST LOOP
		IF LENGTH(v_ARGUMENTS_TABLE(v_INDEX)) > 0 THEN
			-- jbh - tab-separated - used to be comma-separated, but commas are used as decimal points
			-- with European number settings, so we need an unambiguous separator
			UT.TOKENS_FROM_STRING(v_ARGUMENTS_TABLE(v_INDEX), CHR(9), v_VALUES_TABLE);
			SCHEDULE_UPDATE(p_TRANSACTION_ID, v_SCHEDULE_TYPE, p_SCHEDULE_STATE, v_VALUES_TABLE(1), v_VALUES_TABLE(2),
				p_AS_OF_DATE, p_TIME_ZONE, v_VALUES_TABLE(3), v_VALUES_TABLE(4), p_STATUS);
		END IF;
        -- collect audit info if necessary
    	IF v_AUDIT_TYPE = 2 THEN
        	DECLARE
				v_VAL VARCHAR2(64);
			BEGIN
            	v_VAL := ' | '||v_VALUES_TABLE(1)||' '||v_VALUES_TABLE(2)||' '||p_TIME_ZONE||' => '||v_VALUES_TABLE(3)||', '||v_VALUES_TABLE(4);
            	IF LENGTH(v_VALS) + LENGTH(v_VAL) > 4000 THEN
                	-- flush to audit trail if necessary (can only store 4k of values in one record)
		      		SECURITY_CONTROLS.POST_TO_ENTITY_AUDIT_TRAIL(-200, p_TRANSACTION_ID, LOW_DATE, LOW_DATE, '?', p_SCHEDULE_TYPE, p_SCHEDULE_STATE, 'IT_SCHEDULE', 'AMOUNT, PRICE', SYSDATE, 'EDIT MULTIPLE', NULL, NULL, '*', NULL, SUBSTR(v_VALS,4));
                    v_VALS := v_VAL;
                ELSE
                	v_VALS := v_VALS||v_VAL;
				END IF;
            END;
    	END IF;
	END LOOP;

	-- finish audit stuff
	IF v_AUDIT_TYPE = 1 THEN
  		SECURITY_CONTROLS.POST_TO_ENTITY_AUDIT_TRAIL(-200, p_TRANSACTION_ID, LOW_DATE, LOW_DATE, '?', p_SCHEDULE_TYPE, p_SCHEDULE_STATE, 'IT_SCHEDULE', '*', SYSDATE, 'END EDIT MULTIPLE', NULL, NULL, '*', NULL, NULL);
	ELSIF v_AUDIT_TYPE = 2 THEN
  		SECURITY_CONTROLS.POST_TO_ENTITY_AUDIT_TRAIL(-200, p_TRANSACTION_ID, LOW_DATE, LOW_DATE, '?', p_SCHEDULE_TYPE, p_SCHEDULE_STATE, 'IT_SCHEDULE', 'AMOUNT, PRICE', SYSDATE, 'EDIT MULTIPLE', NULL, NULL, '*', NULL, SUBSTR(v_VALS,4));
	END IF;
  	SECURITY_CONTROLS.SET_IS_AUDIT_ENABLED(v_SAVE_AUDIT_ENABLE); -- make sure to restore this value

	EXCEPTION
		WHEN OTHERS THEN
		  	SECURITY_CONTROLS.SET_IS_AUDIT_ENABLED(v_SAVE_AUDIT_ENABLE); -- make sure to restore this value
			p_STATUS := SQLCODE;

END SCHEDULE_UPDATE_REQUEST;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_TRANSACTION_DATE_RANGE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	) AS

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	UPDATE INTERCHANGE_TRANSACTION SET
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(p_END_DATE),
		ENTRY_DATE = SYSDATE
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

END PUT_TRANSACTION_DATE_RANGE;
----------------------------------------------------------------------------------------------------
PROCEDURE SET_TRANSACTION_DATE_RANGE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	UPDATE INTERCHANGE_TRANSACTION SET
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		ENTRY_DATE = SYSDATE
	WHERE TRANSACTION_ID = p_TRANSACTION_ID
		AND TRUNC(p_BEGIN_DATE) < BEGIN_DATE;

	UPDATE INTERCHANGE_TRANSACTION SET
		END_DATE = TRUNC(p_END_DATE),
		ENTRY_DATE = SYSDATE
	WHERE TRANSACTION_ID = p_TRANSACTION_ID
		AND TRUNC(p_END_DATE) > END_DATE;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END SET_TRANSACTION_DATE_RANGE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_TRANSACTION_IDENTIFIER
	(
	p_TRANSACTION_ID IN NUMBER,
	p_TRANSACTION_IDENTIFIER IN VARCHAR
	) AS

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	UPDATE INTERCHANGE_TRANSACTION SET
		TRANSACTION_IDENTIFIER = p_TRANSACTION_IDENTIFIER,
		ENTRY_DATE = SYSDATE
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

END PUT_TRANSACTION_IDENTIFIER;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_TRANSACTION_COMMODITY
	(
	p_TRANSACTION_ID IN NUMBER,
	p_COMMODITY_NAME IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_COMMODITY_ID NUMBER;

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	ID.ID_FOR_COMMODITY(p_COMMODITY_NAME, FALSE, v_COMMODITY_ID);
	IF v_COMMODITY_ID > 0 THEN
		UPDATE INTERCHANGE_TRANSACTION SET
			COMMODITY_ID = v_COMMODITY_ID,
			ENTRY_DATE = SYSDATE
		WHERE TRANSACTION_ID = p_TRANSACTION_ID;
	END IF;

	EXCEPTION
		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END PUT_TRANSACTION_COMMODITY;
----------------------------------------------------------------------------------------------------
PROCEDURE SCHEDULE_TEMPLATE_REQUEST
	(
	p_METHOD_OPTION IN VARCHAR,
	p_TEMPLATE_NAME IN VARCHAR,
	p_START_HOUR_END IN NUMBER,
	p_STOP_HOUR_END IN NUMBER,
	p_INTERIOR_PERIOD IN NUMBER,
	p_DAY_OF_WEEK IN VARCHAR,
	p_INCLUDE_HOLIDAYS IN NUMBER,
	p_TEMPLATE_ORDER IN NUMBER,
	p_OLD_TEMPLATE_NAME IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_START_HOUR_END NUMBER(2);
v_STOP_HOUR_END NUMBER(2);

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	IF UPPER(SUBSTR(p_METHOD_OPTION,1,1)) = 'M' THEN -- Modify; Insert or Update
		v_START_HOUR_END := GREATEST(LEAST(NVL(p_START_HOUR_END, 1), 24), 1);
		v_STOP_HOUR_END := GREATEST(LEAST(GREATEST(NVL(p_STOP_HOUR_END, 24), 1), 24), v_START_HOUR_END);

-- Try to update an existing record
		UPDATE SCHEDULE_TEMPLATE SET
			TEMPLATE_NAME = LTRIM(RTRIM(p_TEMPLATE_NAME)),
			START_HOUR_END = v_START_HOUR_END,
			STOP_HOUR_END = v_STOP_HOUR_END,
			INTERIOR_PERIOD = NVL(p_INTERIOR_PERIOD,1),
			DAY_OF_WEEK = LTRIM(RTRIM(NVL(p_DAY_OF_WEEK,'1111111'))),
			INCLUDE_HOLIDAYS = NVL(p_INCLUDE_HOLIDAYS,1),
			TEMPLATE_ORDER = NVL(p_TEMPLATE_ORDER,999)
		WHERE TEMPLATE_NAME = LTRIM(RTRIM(p_OLD_TEMPLATE_NAME));

-- If the previous update did not find a match, then insert a new record.

		IF SQL%NOTFOUND THEN
			INSERT INTO SCHEDULE_TEMPLATE (
				TEMPLATE_NAME,
				START_HOUR_END,
				STOP_HOUR_END,
				INTERIOR_PERIOD,
				DAY_OF_WEEK,
				INCLUDE_HOLIDAYS,
				TEMPLATE_ORDER)
			VALUES (
				LTRIM(RTRIM(p_TEMPLATE_NAME)),
				v_START_HOUR_END,
				v_STOP_HOUR_END,
				NVL(p_INTERIOR_PERIOD,1),
				LTRIM(RTRIM(NVL(p_DAY_OF_WEEK,'1111111'))),
				NVL(p_INCLUDE_HOLIDAYS,1),
				NVL(p_TEMPLATE_ORDER,999));
		END IF;

	ELSIF UPPER(SUBSTR(p_METHOD_OPTION,1,1)) = 'D' THEN -- Delete
		DELETE SCHEDULE_TEMPLATE WHERE TEMPLATE_NAME = LTRIM(RTRIM(p_TEMPLATE_NAME));
	END IF;

	EXCEPTION
		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END SCHEDULE_TEMPLATE_REQUEST;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_TP_CONTRACT_NUMBER
	(
	p_CONTRACT_ID IN NUMBER,
	p_TP_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CONTRACT_NAME IN VARCHAR2,
	p_CONTRACT_NUMBER IN VARCHAR2,
	p_OLD_TP_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	)
	AS

CURSOR c_TP_CONTRACT_NUMBER IS
	SELECT *
	FROM TP_CONTRACT_NUMBER
	WHERE CONTRACT_ID = p_CONTRACT_ID
		AND TP_ID = p_TP_ID
	ORDER BY BEGIN_DATE DESC;

v_TP_CONTRACT_NUMBER TP_CONTRACT_NUMBER%ROWTYPE;
v_END_DATE DATE;
v_INITIAL BOOLEAN;

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- UPDATE THE CURRENT ACCOUNT PRODUCT ASSIGNMENT IF ONE EXISTS

	UPDATE TP_CONTRACT_NUMBER SET
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		CONTRACT_NAME = p_CONTRACT_NAME,
		CONTRACT_NUMBER = p_CONTRACT_NUMBER,
		TP_ID = p_TP_ID,
		ENTRY_DATE = SYSDATE
	WHERE CONTRACT_ID = p_CONTRACT_ID
		AND TP_ID = p_OLD_TP_ID
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS ACCOUNT AND PRODUCT COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO TP_CONTRACT_NUMBER
			(
			CONTRACT_ID,
			TP_ID,
			BEGIN_DATE,
			END_DATE,
			CONTRACT_NAME,
			CONTRACT_NUMBER,
			ENTRY_DATE
			)
		VALUES
			(
			p_CONTRACT_ID,
			p_TP_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			p_CONTRACT_NAME,
			p_CONTRACT_NUMBER,
			SYSDATE
			);
	END IF;

	OPEN c_TP_CONTRACT_NUMBER;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_TP_CONTRACT_NUMBER INTO v_TP_CONTRACT_NUMBER;
		EXIT WHEN c_TP_CONTRACT_NUMBER%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_TP_CONTRACT_NUMBER.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE TP_CONTRACT_NUMBER
		SET END_DATE = GREATEST(v_END_DATE, v_TP_CONTRACT_NUMBER.BEGIN_DATE)
		WHERE CONTRACT_ID = v_TP_CONTRACT_NUMBER.CONTRACT_ID
			AND TP_ID = v_TP_CONTRACT_NUMBER.TP_ID
			AND BEGIN_DATE = v_TP_CONTRACT_NUMBER.BEGIN_DATE;
		v_END_DATE := v_TP_CONTRACT_NUMBER.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_TP_CONTRACT_NUMBER;

	EXCEPTION
		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END PUT_TP_CONTRACT_NUMBER;
----------------------------------------------------------------------------------------------------
PROCEDURE TRIM_IT_SCHEDULE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

-- Remove any schedule data outside the modified begin and end dates of the transaction.
-- This includes any versions and schedule type.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_INTERVAL VARCHAR2(16);

BEGIN

	IF NOT CAN_DELETE(g_MODULE_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;
	SELECT BEGIN_DATE, END_DATE, UPPER(TRANSACTION_INTERVAL) INTO v_BEGIN_DATE, v_END_DATE, v_INTERVAL
	FROM INTERCHANGE_TRANSACTION
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;
	IF v_INTERVAL = 'HOUR' THEN
		v_BEGIN_DATE := BEGIN_HOUR_ENDING_CUT_DAY(p_BEGIN_DATE, p_TIME_ZONE);
		v_END_DATE := ADD_MINUTES_TO_DATE(END_HOUR_ENDING_CUT_DAY(p_END_DATE, p_TIME_ZONE), -60);
	ELSE
		IF v_INTERVAL = 'MONTH' THEN
			v_BEGIN_DATE := TRUNC(v_BEGIN_DATE,'MONTH');
		ELSIF v_INTERVAL = 'QUARTER' THEN
			v_BEGIN_DATE := TRUNC(v_BEGIN_DATE,'Q');
		ELSIF v_INTERVAL = 'YEAR' THEN
			v_BEGIN_DATE := TRUNC(v_BEGIN_DATE,'YEAR');
		ELSIF v_INTERVAL = 'WEEK' THEN
			v_BEGIN_DATE := TRUNC(v_BEGIN_DATE,'DY');
		ELSE
			v_BEGIN_DATE := TRUNC(v_BEGIN_DATE);
		END IF;
		v_END_DATE := ADD_MINUTES_TO_DATE(TRUNC(v_END_DATE+1),-1);
	END IF;

	DELETE IT_SCHEDULE
	WHERE TRANSACTION_ID = p_TRANSACTION_ID
	    AND SCHEDULE_DATE NOT BETWEEN v_BEGIN_DATE AND v_END_DATE;

	EXCEPTION
		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END TRIM_IT_SCHEDULE;
----------------------------------------------------------------------------------------------------
PROCEDURE IMPORT_EXPORT_TRANSACTION
	(
	p_OPERATION IN VARCHAR,
	p_TRANSACTION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_VERSION_ID IN NUMBER,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

-- Handle an import or export request for transaction schedules.
-- This is a stub procedure that is installation dependent.
-- Operation is either "IMPORT" OR "EXPORT".

BEGIN

	IF (UPPER(SUBSTR(p_OPERATION,1,1)) = 'I' AND NOT CAN_WRITE(g_MODULE_NAME)) OR NOT CAN_READ(g_MODULE_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    XS.IMPORT_EXPORT_TRANSACTION(p_OPERATION, p_TRANSACTION_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE, p_STATUS);

	EXCEPTION
		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END IMPORT_EXPORT_TRANSACTION;
----------------------------------------------------------------------------------------------------
PROCEDURE IMPORT_EXPORT_NAMES
	(
	p_OPERATION IN VARCHAR,
	p_FORMAT IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the transaction names that have either their import or export flags set.
-- Operation is either "IMPORT" OR "EXPORT".
v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	IF UPPER(SUBSTR(p_OPERATION,1,1)) = 'I' THEN
		OPEN p_CURSOR FOR
			SELECT DISTINCT TRANSACTION_NAME, A.TRANSACTION_ID
			FROM INTERCHANGE_TRANSACTION A, IT_SCHEDULE B
			WHERE B.TRANSACTION_ID = A.TRANSACTION_ID
				AND SCHEDULE_TYPE = SCHEDULE_TYPE
				AND SCHEDULE_STATE = g_INTERNAL_STATE
				AND SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND IS_IMPORT_SCHEDULE  = 1
			ORDER BY TRANSACTION_NAME;
	ELSIF UPPER(p_FORMAT) = 'ETAG' THEN
    	OPEN p_CURSOR FOR
			SELECT DISTINCT TRANSACTION_NAME, A.TRANSACTION_ID
			FROM INTERCHANGE_TRANSACTION A, IT_SCHEDULE B
			WHERE B.TRANSACTION_ID = A.TRANSACTION_ID
				AND SCHEDULE_TYPE= SCHEDULE_TYPE
				AND SCHEDULE_STATE = g_INTERNAL_STATE
				AND SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND IS_EXPORT_SCHEDULE  = 1
				AND NOT ETAG_CODE = '?'
			ORDER BY TRANSACTION_NAME;
	ELSE
    	OPEN p_CURSOR FOR
	    	SELECT DISTINCT TRANSACTION_NAME, A.TRANSACTION_ID
			FROM INTERCHANGE_TRANSACTION A, IT_SCHEDULE B
			WHERE B.TRANSACTION_ID = A.TRANSACTION_ID
				AND SCHEDULE_TYPE= SCHEDULE_TYPE
				AND SCHEDULE_STATE = g_INTERNAL_STATE
				AND SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND IS_EXPORT_SCHEDULE  = 1
			ORDER BY TRANSACTION_NAME;
	END IF;

	EXCEPTION
		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END IMPORT_EXPORT_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE FILE_EXPORT_PJM_FORMAT
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- PJM file export request for transaction schedules.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_WORK_ID NUMBER;
v_SCHEDULE_DATE VARCHAR(32);
v_AMOUNT NUMBER;
v_BEGIN_HOUR NUMBER(2);
v_END_HOUR NUMBER(2);

CURSOR c_SCHEDULE IS
    SELECT FROM_CUT_AS_HED(SCHEDULE_DATE, p_TIME_ZONE), AMOUNT
	FROM IT_SCHEDULE
	WHERE TRANSACTION_ID = p_TRANSACTION_ID
		AND SCHEDULE_TYPE = p_SCHEDULE_TYPE
		AND SCHEDULE_STATE = g_INTERNAL_STATE
		AND SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND AS_OF_DATE = SCHEDULE_AS_OF_DATE(TRANSACTION_ID, SCHEDULE_TYPE, SCHEDULE_STATE, SCHEDULE_DATE, p_AS_OF_DATE)
	ORDER BY 1;

BEGIN

	p_STATUS := GA.SUCCESS;

	UT.GET_RTO_WORK_ID(v_WORK_ID);
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	UT.POST_RTO_WORK(v_WORK_ID, 1, '*INTSCH*');
	UT.POST_RTO_WORK(v_WORK_ID, 2, GET_TP_CONTRACT_NUMBER(p_TRANSACTION_ID, TRUNC(p_BEGIN_DATE)));
	UT.POST_RTO_WORK(v_WORK_ID, 3, TO_CHAR(p_BEGIN_DATE, 'MM/DD/YYYY'));
	UT.POST_RTO_WORK(v_WORK_ID, 4, TO_CHAR(p_END_DATE, 'MM/DD/YYYY'));

	OPEN c_SCHEDULE;
	LOOP
	    FETCH c_SCHEDULE INTO v_SCHEDULE_DATE, v_AMOUNT;
		EXIT WHEN c_SCHEDULE%NOTFOUND;
	END LOOP;
	CLOSE c_SCHEDULE;

	EXCEPTION
		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END FILE_EXPORT_PJM_FORMAT;
----------------------------------------------------------------------------------------------------
PROCEDURE FILE_EXPORT_MEC_FORMAT
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- MEC file export request for transaction schedules.

TYPE SCHEDULE_RECORD IS RECORD (SCHEDULE_DATE VARCHAR(16), POR NUMBER, POD NUMBER);
TYPE SCHEDULE_TABLE IS TABLE OF SCHEDULE_RECORD;

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_WORK_ID NUMBER;
v_BEGIN_HOUR NUMBER(2);
v_END_HOUR NUMBER(2);
v_POD_ID NUMBER;
v_POR_ID NUMBER;
v_LINK_TRANSACTION_ID NUMBER;
v_SCHEDULE_DATE GA.DATE_TABLE;
v_POR_AMOUNT GA.NUMBER_TABLE;
v_POD_AMOUNT GA.NUMBER_TABLE;
v_INDEX BINARY_INTEGER;
v_POD_TOTAL NUMBER := 0;
v_POR_TOTAL NUMBER := 0;
v_COUNT PLS_INTEGER;
v_BUFFER VARCHAR(64);
v_TZ_BEGIN_DATE DATE;

CURSOR c_ENERGY IS
    SELECT SCHEDULE_DATE, AMOUNT
	FROM IT_SCHEDULE
	WHERE TRANSACTION_ID = p_TRANSACTION_ID
	    AND SCHEDULE_TYPE = p_SCHEDULE_TYPE
		AND SCHEDULE_STATE = g_INTERNAL_STATE
		AND SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND AS_OF_DATE = SCHEDULE_AS_OF_DATE(TRANSACTION_ID, SCHEDULE_TYPE, SCHEDULE_STATE, SCHEDULE_DATE, p_AS_OF_DATE);

CURSOR c_LOSS IS
    SELECT SCHEDULE_DATE, AMOUNT
	FROM IT_SCHEDULE
	WHERE TRANSACTION_ID = v_LINK_TRANSACTION_ID
	    AND SCHEDULE_TYPE = p_SCHEDULE_TYPE
		AND SCHEDULE_STATE = g_INTERNAL_STATE
		AND SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND AS_OF_DATE = SCHEDULE_AS_OF_DATE(TRANSACTION_ID, SCHEDULE_TYPE, SCHEDULE_STATE, SCHEDULE_DATE, p_AS_OF_DATE);

BEGIN

	p_STATUS := GA.SUCCESS;
	UT.GET_RTO_WORK_ID(v_WORK_ID);
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

    v_TZ_BEGIN_DATE := NEW_TIME(TRUNC(p_BEGIN_DATE),CUT_TIME_ZONE,p_TIME_ZONE);

	SELECT POR_ID, POD_ID, LINK_TRANSACTION_ID
	INTO v_POR_ID, v_POD_ID, v_LINK_TRANSACTION_ID
	FROM INTERCHANGE_TRANSACTION
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

	IF g_TRACE_ON THEN
		UT.DEBUG_TRACE('FILE_EXPORT_MEC_FORMAT');
		UT.DEBUG_TRACE('BEGIN_DATE=' || UT.TRACE_DATE(v_BEGIN_DATE));
		UT.DEBUG_TRACE('END_DATE=' || UT.TRACE_DATE(v_END_DATE));
		UT.DEBUG_TRACE('WORK_ID=' || TO_CHAR(v_WORK_ID));
		UT.DEBUG_TRACE('LINK_TRANSACTION_ID=' || TO_CHAR(v_LINK_TRANSACTION_ID));
		UT.DEBUG_TRACE('POR_ID=' || TO_CHAR(v_POR_ID));
		UT.DEBUG_TRACE('POD_ID=' || TO_CHAR(v_POD_ID));
	END IF;

	UT.POST_RTO_WORK(v_WORK_ID, 1, '*RETAIL*');
	UT.POST_RTO_WORK(v_WORK_ID, 2, TO_CHAR(p_BEGIN_DATE, 'MMDDYYYY'));
	UT.POST_RTO_WORK(v_WORK_ID, 3, GET_SERVICE_POINT_EDC_ALIAS(v_POD_ID));
	UT.POST_RTO_WORK(v_WORK_ID, 4, GET_SERVICE_POINT_NAME(v_POD_ID));
	SELECT COUNT(TRANSACTION_ID) INTO v_COUNT
	FROM INTERCHANGE_TRANSACTION
	WHERE LINK_TRANSACTION_ID = p_TRANSACTION_ID;
	v_BUFFER := STD_TIME_ZONE(p_TIME_ZONE);
	IF v_COUNT > 0 THEN
		v_BUFFER := v_BUFFER || '           LOSS  ';
	ELSE
		v_BUFFER := v_BUFFER || '           POR   ';
		IF v_LINK_TRANSACTION_ID <> 0 THEN
			v_BUFFER := v_BUFFER || '    POD';
		END IF;
	END IF;
	UT.POST_RTO_WORK(v_WORK_ID, 5, v_BUFFER);

	FOR v_ENERGY IN c_ENERGY LOOP
		v_INDEX := ROUND((v_ENERGY.SCHEDULE_DATE - v_TZ_BEGIN_DATE) / GA.HOUR_DIVISOR);
		v_SCHEDULE_DATE(v_INDEX) := v_ENERGY.SCHEDULE_DATE;
		v_POR_AMOUNT(v_INDEX) := v_ENERGY.AMOUNT;
		v_POD_AMOUNT(v_INDEX) := v_ENERGY.AMOUNT;
		v_POR_TOTAL := v_POR_TOTAL + v_ENERGY.AMOUNT;
	END LOOP;

	v_POD_TOTAL := v_POR_TOTAL;
	FOR v_LOSS IN c_LOSS LOOP
		v_INDEX := ROUND((v_LOSS.SCHEDULE_DATE - v_TZ_BEGIN_DATE) / GA.HOUR_DIVISOR);
        v_POR_AMOUNT(v_INDEX) := v_POD_AMOUNT(v_INDEX) + v_LOSS.AMOUNT;
		v_POR_TOTAL := v_POR_TOTAL + v_LOSS.AMOUNT;
	END LOOP;

 	IF v_SCHEDULE_DATE.COUNT > 0 THEN
		v_COUNT := 6;
        v_INDEX := v_SCHEDULE_DATE.FIRST;
		WHILE v_SCHEDULE_DATE.EXISTS(v_INDEX) LOOP
	    	v_BUFFER := RIGHT_JUSTIFY(SUBSTR(FROM_CUT_AS_HED(v_SCHEDULE_DATE(v_INDEX), p_TIME_ZONE),11,15),10) ||
		    	RIGHT_JUSTIFY(TO_CHAR(v_POR_AMOUNT(v_INDEX)),10);
			IF v_LINK_TRANSACTION_ID > 0 THEN
		    	v_BUFFER := v_BUFFER || RIGHT_JUSTIFY(TO_CHAR(v_POD_AMOUNT(v_INDEX)),10);
			END IF;
			UT.POST_RTO_WORK(v_WORK_ID, v_COUNT, v_BUFFER);
			v_COUNT := v_COUNT + 1;
			IF g_TRACE_ON THEN
				UT.DEBUG_TRACE(v_BUFFER);
			END IF;
            v_INDEX := v_SCHEDULE_DATE.NEXT(v_INDEX);
		END LOOP;
	END IF;

    v_BUFFER := 'TOT       ' || RIGHT_JUSTIFY(TO_CHAR(v_POR_TOTAL),10);
	IF v_LINK_TRANSACTION_ID > 0 THEN
	    v_BUFFER := v_BUFFER || RIGHT_JUSTIFY(TO_CHAR(v_POD_TOTAL),10);
	END IF;
	UT.POST_RTO_WORK(v_WORK_ID, v_COUNT, v_BUFFER);

	OPEN p_CURSOR FOR
	    SELECT WORK_DATA FROM RTO_WORK WHERE WORK_ID = v_WORK_ID ORDER BY WORK_SEQ;

	UT.PURGE_RTO_WORK(v_WORK_ID);

	EXCEPTION
		WHEN OTHERS THEN
			UT.PURGE_RTO_WORK(v_WORK_ID);
			p_STATUS := SQLCODE;
			RAISE;

END FILE_EXPORT_MEC_FORMAT;
----------------------------------------------------------------------------------------------------
PROCEDURE FILE_EXPORT_REQUEST
	(
	p_FILE_FORMAT IN VARCHAR,
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Handle a file export request for transaction schedules.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	g_TRACE_ON := p_TRACE_ON = 1;
	p_STATUS := GA.SUCCESS;

	IF g_TRACE_ON THEN
		UT.DEBUG_TRACE('FILE_EXPORT_REQUEST');
		UT.DEBUG_TRACE('FILE_FORMAT=' || p_FILE_FORMAT);
		UT.DEBUG_TRACE('TRANSACTION_ID=' || TO_CHAR(p_TRANSACTION_ID));
		UT.DEBUG_TRACE('SCHEDULE_TYPE=' || TO_CHAR(p_SCHEDULE_TYPE));
		UT.DEBUG_TRACE('BEGIN_DATE =' || UT.TRACE_DATE(p_BEGIN_DATE ));
		UT.DEBUG_TRACE('END_DATE =' || UT.TRACE_DATE(p_END_DATE ));
		UT.DEBUG_TRACE('AS_OF_DATE =' || UT.TRACE_DATE(p_AS_OF_DATE ));
		UT.DEBUG_TRACE('TIME_ZONE=' || p_TIME_ZONE);
		COMMIT;
	END IF;

	IF UPPER(SUBSTR(p_FILE_FORMAT,1,3)) = 'MEC' THEN
		FILE_EXPORT_MEC_FORMAT(p_TRANSACTION_ID, p_SCHEDULE_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE, p_STATUS, p_CURSOR);
	ELSE
		p_STATUS := -999;
		OPEN p_CURSOR FOR SELECT NULL FROM DUAL;
	END IF;

	EXCEPTION
		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END FILE_EXPORT_REQUEST;
----------------------------------------------------------------------------------------------------
PROCEDURE PJM_EXPORT_DATA
	(
	p_TRANSACTION_IDS IN VARCHAR2,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_AS_OF_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_FORECAST_SCHEDULE CONTRACT_SCHEDULE_TABLE := CONTRACT_SCHEDULE_TABLE();
v_FINAL_SCHEDULE CONTRACT_SCHEDULE_TABLE := CONTRACT_SCHEDULE_TABLE();
v_DICT_VAL VARCHAR2(32);
v_AMOUNT NUMBER := 0;
v_INDEX BINARY_INTEGER;
v_SOMETHING_DONE BOOLEAN := FALSE;
v_USE_EXT_ID BOOLEAN := FALSE;

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	g_TRACE_ON := p_TRACE_ON = 1;
	v_USE_EXT_ID := NVL(MODEL_VALUE_AT_KEY(1, 'Scheduling', 'PJM Export', 'Use External ID') = '1',FALSE);

	p_STATUS := GA.SUCCESS;
	IF p_SCHEDULE_TYPE = 3 THEN
		GET_SCHEDULE(p_TRANSACTION_IDS, 1, g_INTERNAL_STATE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, 'EDT', v_FORECAST_SCHEDULE, CASE WHEN v_USE_EXT_ID THEN 0 ELSE 1 END);
		GET_SCHEDULE(p_TRANSACTION_IDS, 3, g_INTERNAL_STATE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, 'EDT', v_FINAL_SCHEDULE, CASE WHEN v_USE_EXT_ID THEN 0 ELSE 1 END);
		IF g_TRACE_ON THEN
			TRACE_SCHEDULE('FORECAST SCHEDULE', v_FORECAST_SCHEDULE);
			TRACE_SCHEDULE('FINAL SCHEDULE', v_FINAL_SCHEDULE);
		END IF;

		IF v_USE_EXT_ID THEN
			OPEN p_CURSOR FOR
				SELECT C.TRANSACTION_IDENTIFIER "CONTRACT_NUMBER", ROUND(SUM((A.SCHEDULE_VAL - B.SCHEDULE_VAL) * 1000)) "AMOUNT", TO_HED_AS_DATE(FROM_CUT(A.SCHEDULE_DATE, 'EDT')) "DATE"
				FROM TABLE(CAST(v_FORECAST_SCHEDULE AS CONTRACT_SCHEDULE_TABLE)) A,
					TABLE(CAST(v_FINAL_SCHEDULE AS CONTRACT_SCHEDULE_TABLE)) B,
				    INTERCHANGE_TRANSACTION C
				WHERE B.SCHEDULE_DATE = A.SCHEDULE_DATE
					AND B.CONTRACT_ID = A.CONTRACT_ID
					AND B.TRANSACTION_ID = A.TRANSACTION_ID
					AND C.TRANSACTION_ID = A.TRANSACTION_ID
				GROUP BY C.TRANSACTION_IDENTIFIER, TO_HED_AS_DATE(FROM_CUT(A.SCHEDULE_DATE, 'EDT'))
				ORDER BY 1,3;
		ELSE
			OPEN p_CURSOR FOR
				SELECT C.CONTRACT_NUMBER, ROUND(SUM((A.SCHEDULE_VAL - B.SCHEDULE_VAL) * 1000)) "AMOUNT", TO_HED_AS_DATE(FROM_CUT(A.SCHEDULE_DATE, 'EDT')) "DATE"
				FROM TABLE(CAST(v_FORECAST_SCHEDULE AS CONTRACT_SCHEDULE_TABLE)) A,
					TABLE(CAST(v_FINAL_SCHEDULE AS CONTRACT_SCHEDULE_TABLE)) B,
				    TP_CONTRACT_NUMBER C
				WHERE B.SCHEDULE_DATE = A.SCHEDULE_DATE
					AND B.CONTRACT_ID = A.CONTRACT_ID
					AND B.TRANSACTION_ID = A.TRANSACTION_ID
					AND C.CONTRACT_ID = A.CONTRACT_ID
					AND TRUNC(B.SCHEDULE_DATE) BETWEEN C.BEGIN_DATE AND NVL(C.END_DATE, B.SCHEDULE_DATE)
				GROUP BY C.CONTRACT_NUMBER, TO_HED_AS_DATE(FROM_CUT(A.SCHEDULE_DATE, 'EDT'))
				ORDER BY 1,3;
		END IF;

		-- call this stub to allow project code to do something special w/ these numbers if necessary
		XS.PJM_EXPORT_DATA_MISC (p_SCHEDULE_TYPE, p_BEGIN_DATE, p_END_DATE, 'EDT', p_AS_OF_DATE, p_CURSOR, v_SOMETHING_DONE);

		IF v_SOMETHING_DONE THEN
			-- re-open cursor if XS did something w/ data that could invalidate the recordset for GUI
    		IF v_USE_EXT_ID THEN
    			OPEN p_CURSOR FOR
    				SELECT C.TRANSACTION_IDENTIFIER "CONTRACT_NUMBER", ROUND(SUM((A.SCHEDULE_VAL - B.SCHEDULE_VAL) * 1000)) "AMOUNT", TO_HED_AS_DATE(FROM_CUT(A.SCHEDULE_DATE, 'EDT')) "DATE"
    				FROM TABLE(CAST(v_FORECAST_SCHEDULE AS CONTRACT_SCHEDULE_TABLE)) A,
    					TABLE(CAST(v_FINAL_SCHEDULE AS CONTRACT_SCHEDULE_TABLE)) B,
    				    INTERCHANGE_TRANSACTION C
    				WHERE B.SCHEDULE_DATE = A.SCHEDULE_DATE
    					AND B.CONTRACT_ID = A.CONTRACT_ID
    					AND B.TRANSACTION_ID = A.TRANSACTION_ID
    					AND C.TRANSACTION_ID = A.TRANSACTION_ID
    				GROUP BY C.TRANSACTION_IDENTIFIER, TO_HED_AS_DATE(FROM_CUT(A.SCHEDULE_DATE, 'EDT'))
    				ORDER BY 1,3;
    		ELSE
    			OPEN p_CURSOR FOR
    				SELECT C.CONTRACT_NUMBER, ROUND(SUM((A.SCHEDULE_VAL - B.SCHEDULE_VAL) * 1000)) "AMOUNT", TO_HED_AS_DATE(FROM_CUT(A.SCHEDULE_DATE, 'EDT')) "DATE"
    				FROM TABLE(CAST(v_FORECAST_SCHEDULE AS CONTRACT_SCHEDULE_TABLE)) A,
    					TABLE(CAST(v_FINAL_SCHEDULE AS CONTRACT_SCHEDULE_TABLE)) B,
    				    TP_CONTRACT_NUMBER C
    				WHERE B.SCHEDULE_DATE = A.SCHEDULE_DATE
    					AND B.CONTRACT_ID = A.CONTRACT_ID
    					AND B.TRANSACTION_ID = A.TRANSACTION_ID
    					AND C.CONTRACT_ID = A.CONTRACT_ID
    					AND TRUNC(B.SCHEDULE_DATE) BETWEEN C.BEGIN_DATE AND NVL(C.END_DATE, B.SCHEDULE_DATE)
    				GROUP BY C.CONTRACT_NUMBER, TO_HED_AS_DATE(FROM_CUT(A.SCHEDULE_DATE, 'EDT'))
    				ORDER BY 1,3;
    		END IF;
		END IF;
	ELSE
		GET_SCHEDULE(p_TRANSACTION_IDS, p_SCHEDULE_TYPE, g_INTERNAL_STATE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, 'EDT', v_FORECAST_SCHEDULE, CASE WHEN v_USE_EXT_ID THEN 0 ELSE 1 END);
		IF g_TRACE_ON THEN
			TRACE_SCHEDULE('SCHEDULE', v_FORECAST_SCHEDULE);
		END IF;
		v_INDEX := v_FORECAST_SCHEDULE.FIRST;
		WHILE v_INDEX <= v_FORECAST_SCHEDULE.LAST LOOP
			v_AMOUNT := v_AMOUNT + v_FORECAST_SCHEDULE(v_INDEX).SCHEDULE_VAL;
			v_INDEX := v_FORECAST_SCHEDULE.NEXT(v_INDEX);
		END LOOP;

        GET_MODEL_VALUE_AT_KEY(1,'Scheduling','PJM Export','Allow All Zeroes',0,v_DICT_VAL);
        IF v_AMOUNT > 0 OR v_DICT_VAL = '1' OR v_DICT_VAL = 'Y' THEN
    		IF v_USE_EXT_ID THEN
    			OPEN p_CURSOR FOR
    				SELECT B.TRANSACTION_IDENTIFIER "CONTRACT_NUMBER", SUM(A.SCHEDULE_VAL) "AMOUNT", TO_HED_AS_DATE(FROM_CUT(A.SCHEDULE_DATE, 'EDT')) "DATE"
    				FROM TABLE(CAST(v_FORECAST_SCHEDULE AS CONTRACT_SCHEDULE_TABLE)) A,
    				    INTERCHANGE_TRANSACTION B
    				WHERE B.TRANSACTION_ID = A.TRANSACTION_ID
    				GROUP BY B.TRANSACTION_IDENTIFIER, TO_HED_AS_DATE(FROM_CUT(A.SCHEDULE_DATE, 'EDT'))
    				ORDER BY 1,3;
    		ELSE
    			OPEN p_CURSOR FOR
    				SELECT B.CONTRACT_NUMBER, SUM(A.SCHEDULE_VAL) "AMOUNT", TO_HED_AS_DATE(FROM_CUT(A.SCHEDULE_DATE, 'EDT')) "DATE"
    				FROM TABLE(CAST(v_FORECAST_SCHEDULE AS CONTRACT_SCHEDULE_TABLE)) A,
    				    TP_CONTRACT_NUMBER B
    				WHERE B.CONTRACT_ID = A.CONTRACT_ID
    					AND TRUNC(A.SCHEDULE_DATE) BETWEEN B.BEGIN_DATE AND NVL(B.END_DATE, A.SCHEDULE_DATE)
    				GROUP BY B.CONTRACT_NUMBER, TO_HED_AS_DATE(FROM_CUT(A.SCHEDULE_DATE, 'EDT'))
    				ORDER BY 1,3;
    		END IF;

			-- call this stub to allow project code to do something special w/ these numbers if necessary
			XS.PJM_EXPORT_DATA_MISC (p_SCHEDULE_TYPE, p_BEGIN_DATE, p_END_DATE, 'EDT', p_AS_OF_DATE, p_CURSOR, v_SOMETHING_DONE);

			IF v_SOMETHING_DONE THEN
				-- re-open cursor if XS did something w/ data that could invalidate the recordset for GUI
        		IF v_USE_EXT_ID THEN
        			OPEN p_CURSOR FOR
        				SELECT B.TRANSACTION_IDENTIFIER "CONTRACT_NUMBER", SUM(A.SCHEDULE_VAL) "AMOUNT", TO_HED_AS_DATE(FROM_CUT(A.SCHEDULE_DATE, 'EDT')) "DATE"
        				FROM TABLE(CAST(v_FORECAST_SCHEDULE AS CONTRACT_SCHEDULE_TABLE)) A,
        				    INTERCHANGE_TRANSACTION B
        				WHERE B.TRANSACTION_ID = A.TRANSACTION_ID
        				GROUP BY B.TRANSACTION_IDENTIFIER, TO_HED_AS_DATE(FROM_CUT(A.SCHEDULE_DATE, 'EDT'))
        				ORDER BY 1,3;
        		ELSE
        			OPEN p_CURSOR FOR
        				SELECT B.CONTRACT_NUMBER, SUM(A.SCHEDULE_VAL) "AMOUNT", TO_HED_AS_DATE(FROM_CUT(A.SCHEDULE_DATE, 'EDT')) "DATE"
        				FROM TABLE(CAST(v_FORECAST_SCHEDULE AS CONTRACT_SCHEDULE_TABLE)) A,
        				    TP_CONTRACT_NUMBER B
        				WHERE B.CONTRACT_ID = A.CONTRACT_ID
        					AND TRUNC(A.SCHEDULE_DATE) BETWEEN B.BEGIN_DATE AND NVL(B.END_DATE, A.SCHEDULE_DATE)
        				GROUP BY B.CONTRACT_NUMBER, TO_HED_AS_DATE(FROM_CUT(A.SCHEDULE_DATE, 'EDT'))
        				ORDER BY 1,3;
        		END IF;
			END IF;
		ELSE
        	-- otherwise return empty recordset
        	OPEN p_CURSOR FOR
				SELECT NULL "CONTRACT_NUMBER", NULL "AMOUNT", NULL "DATE"
                FROM DUAL WHERE 0 = 1;
		END IF;
	END IF;


EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;
    	IF p_STATUS > 0 THEN
        	p_STATUS := -p_STATUS;
        END IF;

END PJM_EXPORT_DATA;
----------------------------------------------------------------------------------------------------
PROCEDURE IMPORT_SPPXML_RECORDS
	(
	p_DATES IN VARCHAR2,
	p_NAMES IN VARCHAR2,
	p_TYPES IN VARCHAR2,
	p_MWS IN VARCHAR2,
	p_PRICES IN VARCHAR2,
	p_SCHEDULE_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_AS_OF_DATE IN DATE,
	p_NUM OUT NUMBER,
	p_STATUS OUT NUMBER
	) AS

v_DATES	GA.STRING_TABLE;
v_NAMES	GA.STRING_TABLE;
v_TYPES	GA.STRING_TABLE;
v_MWS		GA.STRING_TABLE;
v_PRICES	GA.STRING_TABLE;
v_ID		NUMBER;
v_LASTNAME	VARCHAR2(64);
v_CURTYPE	VARCHAR2(16);
v_DATE	DATE;
v_STR		VARCHAR2(13);
v_DATESTR	VARCHAR2(10);
v_TIMESTR	VARCHAR2(6);

BEGIN

	p_NUM := 0;
	IF NOT CAN_READ(g_MODULE_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
	p_STATUS := GA.SUCCESS;

	UT.TOKENS_FROM_STRING(p_DATES, ';', v_DATES);
	UT.TOKENS_FROM_STRING(p_NAMES, ';', v_NAMES);
	UT.TOKENS_FROM_STRING(p_TYPES, ';', v_TYPES);
	UT.TOKENS_FROM_STRING(p_MWS, ';', v_MWS);
	UT.TOKENS_FROM_STRING(p_PRICES, ';', v_PRICES);
	v_LASTNAME := ' ';
	v_ID := 0;
	FOR v_INDEX IN v_DATES.FIRST..v_DATES.LAST LOOP
		-- Get TRANSACTION ID, create new one if necessary
		IF SUBSTR(v_NAMES(v_INDEX),1,64) <> v_LASTNAME THEN
			v_ID := 0;
			SELECT DECODE(UPPER(SUBSTR(v_TYPES(v_INDEX),1,3)),'GEN','Generation','CLD','Load','PUR','Purchase','SAL','Sale','PAS','Pass-Thru','Generation')
				INTO v_CURTYPE
				FROM DUAL;
			ID.ID_FOR_TRANSACTION(SUBSTR(v_NAMES(v_INDEX),1,64),v_CURTYPE,TRUE,v_ID);
			v_LASTNAME := SUBSTR(v_NAMES(v_INDEX),1,64);
		END IF;
		IF v_ID > 0 THEN
			v_STR := SUBSTR(v_DATES(v_INDEX),1,13);
			v_DATESTR := SUBSTR(v_STR,1,4)||'-'||SUBSTR(v_STR,5,2)||'-'||SUBSTR(v_STR,7,2);
			v_TIMESTR := SUBSTR(v_STR,9,2)||':'||SUBSTR(v_STR,11);
			v_DATE := DATE_TIME_AS_CUT(v_DATESTR,v_TIMESTR,p_TIME_ZONE);
			-- Extend Date Range if necessary
			UPDATE INTERCHANGE_TRANSACTION SET
				BEGIN_DATE = TRUNC(v_DATE),
				ENTRY_DATE = SYSDATE
			WHERE TRANSACTION_ID = v_ID
				AND TRUNC(v_DATE) < BEGIN_DATE;
			UPDATE INTERCHANGE_TRANSACTION SET
				END_DATE = TRUNC(v_DATE),
				ENTRY_DATE = SYSDATE
			WHERE TRANSACTION_ID = v_ID
				AND TRUNC(v_DATE) > END_DATE;
			-- Put schedule values
			PUT_IT_SCHEDULE (v_ID, p_SCHEDULE_TYPE, v_DATE, p_AS_OF_DATE, v_MWS(v_INDEX), v_PRICES(v_INDEX), p_STATUS);
			IF p_STATUS >= 0 THEN
				p_NUM := p_NUM + 1;
			END IF;
		END IF;
	END LOOP;
	v_DATES.DELETE;
	v_NAMES.DELETE;
	v_TYPES.DELETE;
	v_MWS.DELETE;
	v_PRICES.DELETE;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END IMPORT_SPPXML_RECORDS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_TRANSACTION_TYPE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_TYPE OUT VARCHAR2
	) AS

BEGIN

	SELECT DECODE(UPPER(SUBSTR(TRANSACTION_TYPE,1,2)),'PA','PAS','LO','CLD','GE','GEN','PU','PUR','SA','SAL','???') INTO p_TYPE
	FROM INTERCHANGE_TRANSACTION
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

EXCEPTION
	WHEN OTHERS THEN
		p_TYPE := '???';

END GET_TRANSACTION_TYPE;
----------------------------------------------------------------------------------------------------
PROCEDURE POD_NAMES
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of POD service points associated with trasactions.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT B.SERVICE_POINT_NAME, B.SERVICE_POINT_ID
		FROM (SELECT DISTINCT POD_ID FROM INTERCHANGE_TRANSACTION WHERE BEGIN_DATE <= p_END_DATE AND END_DATE >= p_BEGIN_DATE) A,
			SERVICE_POINT B
		WHERE B.SERVICE_POINT_ID = A.POD_ID
		ORDER BY SERVICE_POINT_NAME;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END POD_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE POR_NAMES
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of POR service points associated with trasactions.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT B.SERVICE_POINT_NAME, B.SERVICE_POINT_ID
		FROM (SELECT DISTINCT POR_ID FROM INTERCHANGE_TRANSACTION WHERE BEGIN_DATE <= p_END_DATE AND END_DATE >= p_BEGIN_DATE) A,
			SERVICE_POINT B
		WHERE B.SERVICE_POINT_ID = A.POR_ID
		ORDER BY SERVICE_POINT_NAME;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END POR_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE PURCHASER_NAMES
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of PSE that are a purchasing party to the transaction.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT PSE_NAME, PSE_ID
		FROM (SELECT DISTINCT PURCHASER_ID FROM INTERCHANGE_TRANSACTION WHERE BEGIN_DATE <= p_END_DATE AND END_DATE >= p_BEGIN_DATE) A,
			PURCHASING_SELLING_ENTITY B
		WHERE B.PSE_ID = A.PURCHASER_ID
		ORDER BY PSE_NAME;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END PURCHASER_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE SELLER_NAMES
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of PSE that are a selling party to the transaction.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT PSE_NAME, PSE_ID
		FROM (SELECT DISTINCT SELLER_ID FROM INTERCHANGE_TRANSACTION WHERE BEGIN_DATE <= p_END_DATE AND END_DATE >= p_BEGIN_DATE) A,
			PURCHASING_SELLING_ENTITY B
		WHERE B.PSE_ID = A.SELLER_ID
		ORDER BY PSE_NAME;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END SELLER_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_NAMES
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of PSE that are a purchasing party to the transaction.

BEGIN

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT DISTINCT PSE_NAME, PSE_ID
		FROM
			(SELECT DISTINCT PURCHASER_ID
			FROM INTERCHANGE_TRANSACTION
			WHERE BEGIN_DATE <= p_END_DATE AND END_DATE >= p_BEGIN_DATE
			UNION
			SELECT DISTINCT SELLER_ID
			FROM INTERCHANGE_TRANSACTION
			WHERE BEGIN_DATE <= p_END_DATE AND END_DATE >= p_BEGIN_DATE
			) A,
			PURCHASING_SELLING_ENTITY B
		WHERE B.PSE_ID = A.PURCHASER_ID
		ORDER BY PSE_NAME;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END PSE_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE CA_NAMES
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of CA that are a party to the transaction.

BEGIN

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT DISTINCT B.CA_NAME, B.CA_ID
		FROM
			(SELECT DISTINCT B.CA_ID
			FROM INTERCHANGE_TRANSACTION A,
				SERVICE_POINT B
			WHERE A.BEGIN_DATE <= p_END_DATE AND A.END_DATE >= p_BEGIN_DATE
				AND B.SERVICE_POINT_ID IN(A.POR_ID, A.POD_ID)
				AND B.CA_ID > 0	) A,
			CONTROL_AREA B
		WHERE B.CA_ID = A.CA_ID
		ORDER BY CA_NAME;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END CA_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE EDC_NAMES
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of PSE that are a selling party to the transaction.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT B.EDC_NAME, B.EDC_ID
		FROM (SELECT DISTINCT B.EDC_ID
				FROM INTERCHANGE_TRANSACTION A, SERVICE_POINT B
				WHERE A.BEGIN_DATE <= p_END_DATE AND A.END_DATE >= p_BEGIN_DATE
					AND A.POD_ID = B.SERVICE_POINT_ID) A,
			ENERGY_DISTRIBUTION_COMPANY B
		WHERE B.EDC_ID = A.EDC_ID
		ORDER BY B.EDC_NAME;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END EDC_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE TP_NAMES
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of PSE that are a selling party to the transaction.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT B.TP_NAME, B.TP_ID
		FROM (SELECT DISTINCT B.TP_ID
				FROM INTERCHANGE_TRANSACTION A, SERVICE_POINT B
				WHERE A.BEGIN_DATE <= p_END_DATE AND A.END_DATE >= p_BEGIN_DATE
					AND A.POD_ID = B.SERVICE_POINT_ID) A,
			TRANSMISSION_PROVIDER B
		WHERE B.TP_ID = A.TP_ID
		ORDER BY B.TP_NAME;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END TP_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE SERVICE_TYPE_NAMES
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of PSE that are a selling party to the transaction.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT B.SERVICE_TYPE_NAME, B.SERVICE_TYPE_ID
		FROM (SELECT DISTINCT SERVICE_TYPE_ID FROM INTERCHANGE_TRANSACTION WHERE BEGIN_DATE <= p_END_DATE AND END_DATE >= p_BEGIN_DATE) A,
			TX_SERVICE_TYPE B
		WHERE B.SERVICE_TYPE_ID = A.SERVICE_TYPE_ID
		ORDER BY B.SERVICE_TYPE_NAME;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END SERVICE_TYPE_NAMES;
---------------------------------------------------------------------------------------------------

PROCEDURE SERVICE_ZONE_NAMES(
    p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of PSE that are a selling party to the transaction.

BEGIN

	IF NOT Can_Read(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    p_STATUS := Ga.SUCCESS;

	OPEN p_CURSOR FOR
		 SELECT DISTINCT B.SERVICE_ZONE_NAME "SERVICE_ZONE_NAME",
		 DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'LO', A.ZOR_ID, 'SA', A.ZOR_ID, 'PU', A.ZOD_ID, 'GE', A.ZOD_ID) "SERVICE_ZONE_ID"
		FROM INTERCHANGE_TRANSACTION A, SERVICE_ZONE B
		WHERE B.SERVICE_ZONE_ID = DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'LO', A.ZOR_ID, 'SA', A.ZOR_ID, 'PU', A.ZOD_ID, 'GE', A.ZOD_ID)
		ORDER BY B.SERVICE_ZONE_NAME;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END SERVICE_ZONE_NAMES;
---------------------------------------------------------------------------------------------------
/*
PROCEDURE BALANCE_TRANSACTION_NAMES
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT TRANSACTION_NAME, TRANSACTION_ID
		FROM INTERCHANGE_TRANSACTION
		WHERE BEGIN_DATE <= p_END_DATE
			AND END_DATE >= p_BEGIN_DATE
			AND IS_BALANCE_TRANSACTION = 1
			AND UPPER(SUBSTR(TRANSACTION_TYPE,1,2)) IN ('RE','LO')
		ORDER BY 1, 2;

	EXCEPTION
		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END BALANCE_TRANSACTION_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE BALANCE_SALE_NAMES
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT TRANSACTION_NAME, TRANSACTION_ID
		FROM INTERCHANGE_TRANSACTION
		WHERE BEGIN_DATE <= p_END_DATE
			AND END_DATE >= p_BEGIN_DATE
			AND IS_BALANCE_TRANSACTION = 1
			AND UPPER(SUBSTR(TRANSACTION_TYPE,1,2)) = 'SA'
		ORDER BY 1, 2;

	EXCEPTION
		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END BALANCE_SALE_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE BALANCE_SUPPLY_NAMES
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT DISTINCT TRANSACTION_NAME, A.TRANSACTION_ID
		FROM BALANCE_TRANSACTION A, INTERCHANGE_TRANSACTION B
		WHERE A.BEGIN_DATE <= p_END_DATE
			AND NVL(A.END_DATE,HIGH_DATE) >= p_BEGIN_DATE
			AND B.TRANSACTION_ID = A.TRANSACTION_ID
			AND B.BEGIN_DATE <= p_END_DATE
			AND B.END_DATE >= p_BEGIN_DATE
		ORDER BY 1, 2;

	EXCEPTION
		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END BALANCE_SUPPLY_NAMES;
*/
---------------------------------------------------------------------------------------------------
PROCEDURE CUSTOM_SCHEDULER_TREE_FIELD
	(
    p_CUSTOM_FIELD IN VARCHAR2,
    p_SQL_SELECT IN OUT VARCHAR2,
    p_SQL_FROM IN OUT VARCHAR2,
    p_SQL_WHERE IN OUT VARCHAR2
    ) AS
v_FLD CHAR(1) := SUBSTR(UPPER(p_CUSTOM_FIELD),1,1);
BEGIN
	IF v_FLD IS NULL THEN
    	p_SQL_SELECT := p_SQL_SELECT||' NULL, ';
	ELSIF v_FLD = '0' THEN
    	-- schedule coordinator
        p_SQL_SELECT := p_SQL_SELECT||' C.SC_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' SCHEDULE_COORDINATOR C, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND C.SC_ID(+) = A.SC_ID ';
    ELSIF v_FLD = '1' THEN
    	-- transaction type
        p_SQL_SELECT := p_SQL_SELECT||' A.TRANSACTION_TYPE, ';
    ELSIF v_FLD = '2' THEN
    	-- transaction category
        p_SQL_SELECT := p_SQL_SELECT||' DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)),''PU'',''Transaction'',''SA'',''Transaction'',''PA'',''Transaction'',''LO'',''Load'',''RE'',''Load'',A.TRANSACTION_TYPE), ';
    ELSIF v_FLD = '3' THEN
    	-- commodity
        p_SQL_SELECT := p_SQL_SELECT||' D.COMMODITY_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' IT_COMMODITY D, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND D.COMMODITY_ID(+) = A.COMMODITY_ID ';
    ELSIF v_FLD = '4' THEN
    	-- commodity type
        p_SQL_SELECT := p_SQL_SELECT||' E.COMMODITY_TYPE, ';
        p_SQL_FROM := p_SQL_FROM||' IT_COMMODITY E, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND E.COMMODITY_ID(+) = A.COMMODITY_ID ';
    ELSIF v_FLD = '5' THEN
    	-- pod
        p_SQL_SELECT := p_SQL_SELECT||' F.SERVICE_POINT_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' SERVICE_POINT F, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND F.SERVICE_POINT_ID(+) = A.POD_ID ';
    ELSIF v_FLD = '6' THEN
    	-- pod type
        p_SQL_SELECT := p_SQL_SELECT||' G.SERVICE_POINT_TYPE, ';
        p_SQL_FROM := p_SQL_FROM||' SERVICE_POINT G, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND G.SERVICE_POINT_ID(+) = A.POD_ID ';
    ELSIF v_FLD = '7' THEN
    	-- por
        p_SQL_SELECT := p_SQL_SELECT||' H.SERVICE_POINT_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' SERVICE_POINT H, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND H.SERVICE_POINT_ID(+) = A.POR_ID ';
    ELSIF v_FLD = '8' THEN
    	-- por type
        p_SQL_SELECT := p_SQL_SELECT||' I.SERVICE_POINT_TYPE, ';
        p_SQL_FROM := p_SQL_FROM||' SERVICE_POINT I, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND I.SERVICE_POINT_ID(+) = A.POR_ID ';
    ELSIF v_FLD = '9' THEN
    	-- zod
        p_SQL_SELECT := p_SQL_SELECT||' J.SERVICE_ZONE_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' SERVICE_ZONE J, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND J.SERVICE_ZONE_ID(+) = A.ZOD_ID ';
    ELSIF v_FLD = 'A' THEN
    	-- zor
        p_SQL_SELECT := p_SQL_SELECT||' K.SERVICE_ZONE_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' SERVICE_ZONE K, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND K.SERVICE_ZONE_ID(+) = A.ZOR_ID ';
    ELSIF v_FLD = 'B' THEN
    	-- source
        p_SQL_SELECT := p_SQL_SELECT||' L.SERVICE_POINT_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' SERVICE_POINT L, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND L.SERVICE_POINT_ID(+) = A.SOURCE_ID ';
    ELSIF v_FLD = 'C' THEN
    	-- sink
        p_SQL_SELECT := p_SQL_SELECT||' M.SERVICE_POINT_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' SERVICE_POINT M, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND M.SERVICE_POINT_ID(+) = A.SINK_ID ';
    ELSIF v_FLD = 'D' THEN
    	-- schedule group
        p_SQL_SELECT := p_SQL_SELECT||' N.SCHEDULE_GROUP_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' SCHEDULE_GROUP N, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND N.SCHEDULE_GROUP_ID(+) = A.SCHEDULE_GROUP_ID ';
    ELSIF v_FLD = 'E' THEN
    	-- resource
        p_SQL_SELECT := p_SQL_SELECT||' O.RESOURCE_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' SUPPLY_RESOURCE O, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND O.RESOURCE_ID(+) = A.RESOURCE_ID ';
    ELSIF v_FLD = 'F' THEN
    	-- resource group
        p_SQL_SELECT := p_SQL_SELECT||' Q.RESOURCE_GROUP_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' SUPPLY_RESOURCE P, SUPPLY_RESOURCE_GROUP Q ';
        p_SQL_WHERE := p_SQL_WHERE||' AND P.RESOURCE_ID(+) = A.RESOURCE_ID ';
        p_SQL_WHERE := p_SQL_WHERE||' AND Q.RESOURCE_GROUP_ID(+) = P.RESOURCE_GROUP_ID ';
    ELSIF v_FLD = 'G' THEN
    	-- contract
        p_SQL_SELECT := p_SQL_SELECT||' R.CONTRACT_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' INTERCHANGE_CONTRACT R, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND R.CONTRACT_ID(+) = A.CONTRACT_ID ';
    ELSIF v_FLD = 'H' THEN
    	-- billing entity
        p_SQL_SELECT := p_SQL_SELECT||' T.PSE_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' INTERCHANGE_CONTRACT S, PURCHASING_SELLING_ENTITY T, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND S.CONTRACT_ID(+) = A.CONTRACT_ID ';
        p_SQL_WHERE := p_SQL_WHERE||' AND T.PSE_ID(+) = S.BILLING_ENTITY_ID ';
    ELSIF v_FLD = 'I' THEN
    	-- tp contract name
        p_SQL_SELECT := p_SQL_SELECT||' U.CONTRACT_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' TP_CONTRACT_NUMBER U, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND U.CONTRACT_ID(+) = A.CONTRACT_ID ';
        p_SQL_WHERE := p_SQL_WHERE||' AND U.BEGIN_DATE(+) <= SYSDATE ';
        p_SQL_WHERE := p_SQL_WHERE||' AND U.END_DATE(+) >= SYSDATE ';
    ELSIF v_FLD = 'J' THEN
    	-- tp contract number
        p_SQL_SELECT := p_SQL_SELECT||' V.CONTRACT_NUMBER, ';
        p_SQL_FROM := p_SQL_FROM||' TP_CONTRACT_NUMBER V, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND V.CONTRACT_ID(+) = A.CONTRACT_ID ';
        p_SQL_WHERE := p_SQL_WHERE||' AND V.BEGIN_DATE(+) <= SYSDATE ';
        p_SQL_WHERE := p_SQL_WHERE||' AND V.END_DATE(+) >= SYSDATE ';
    ELSIF v_FLD = 'K' THEN
    	-- purchaser
        p_SQL_SELECT := p_SQL_SELECT||' W.PSE_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' PURCHASING_SELLING_ENTITY W, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND W.PSE_ID(+) = A.PURCHASER_ID ';
    ELSIF v_FLD = 'L' THEN
    	-- seller
        p_SQL_SELECT := p_SQL_SELECT||' X.PSE_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' PURCHASING_SELLING_ENTITY X, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND X.PSE_ID(+) = A.SELLER_ID ';
    ELSIF v_FLD = 'M' THEN
    	-- scheduler
        p_SQL_SELECT := p_SQL_SELECT||' Y.SCHEDULER_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' SCHEDULER Y, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND Y.SCHEDULER_ID(+) = A.SCHEDULER_ID ';
    ELSIF v_FLD = 'N' THEN
    	-- agreement type
        p_SQL_SELECT := p_SQL_SELECT||' A.AGREEMENT_TYPE, ';
    ELSIF v_FLD = 'O' THEN
    	-- approval type
        p_SQL_SELECT := p_SQL_SELECT||' A.APPROVAL_TYPE, ';
    ELSIF v_FLD = 'P' THEN
    	-- external id
        p_SQL_SELECT := p_SQL_SELECT||' A.TRANSACTION_IDENTIFIER, ';
    ELSIF v_FLD = 'Q' THEN
    	-- is firm
        p_SQL_SELECT := p_SQL_SELECT||' DECODE(A.IS_FIRM,1,''Firm'',''Non-Firm''), ';
    ELSIF v_FLD = 'R' THEN
    	-- is import/export
        p_SQL_SELECT := p_SQL_SELECT||' DECODE(A.IS_IMPORT_EXPORT,1,''Export/Import'',NULL), ';
    ELSIF v_FLD = 'S' THEN
    	-- interval
        p_SQL_SELECT := p_SQL_SELECT||' A.TRANSACTION_INTERVAL, ';
    ELSE
    	-- unrecognized? ignore
    	p_SQL_SELECT := p_SQL_SELECT||' NULL, ';
    END IF;
END CUSTOM_SCHEDULER_TREE_FIELD;
---------------------------------------------------------------------------------------------------
PROCEDURE CUSTOM_SCHEDULER_TREE
    (
    p_CUSTOM_FIELDS IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
    p_IS_BID_OFFER IN NUMBER,
	p_ALLOWED_TXNS IN ID_TABLE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
v_SQL_SELECT VARCHAR2(1000) := '';
v_SQL_FROM VARCHAR2(1000) := '';
v_SQL_WHERE VARCHAR2(1000) := '';
v_SQL VARCHAR2(4000);
BEGIN
	p_STATUS := GA.SUCCESS;

    FOR v_INDEX IN 1..3 LOOP
    	CUSTOM_SCHEDULER_TREE_FIELD(SUBSTR(p_CUSTOM_FIELDS,v_INDEX,1),v_SQL_SELECT,v_SQL_FROM,v_SQL_WHERE);
    END LOOP;

    v_SQL := 'SELECT '||v_SQL_SELECT||
				' A.TRANSACTION_NAME,'||
				' A.TRANSACTION_ID,'||
				' B.TRANSACTION_IS_ACTIVE'||
			' FROM '||v_SQL_FROM||
            	' INTERCHANGE_TRANSACTION A, IT_STATUS B , TABLE(CAST( :1 AS ID_TABLE)) IDS' ||
			' WHERE A.BEGIN_DATE <= :2'||
				' AND A.END_DATE >= :3'||
                ' AND (:4 = 0 OR A.IS_BID_OFFER = 1)'||
				' AND B.TRANSACTION_ID = A.TRANSACTION_ID'||
				' AND B.AS_OF_DATE ='||
					' (SELECT MAX(AS_OF_DATE)'||
					' FROM IT_STATUS'||
					' WHERE TRANSACTION_ID = B.TRANSACTION_ID'||
						' AND AS_OF_DATE <= :5)'||
				v_SQL_WHERE||
				' AND (IDS.ID = :6 OR A.TRANSACTION_ID = IDS.ID)' ||
			' ORDER BY 1,2,3,4';

    -- execute query dynamically
	OPEN p_CURSOR FOR
    	v_SQL USING p_ALLOWED_TXNS, p_END_DATE, p_BEGIN_DATE, p_IS_BID_OFFER, p_AS_OF_DATE, SD.g_ALL_DATA_ENTITY_ID;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;
END CUSTOM_SCHEDULER_TREE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_SCHEDULER_TREE
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
    p_IS_BID_OFFER IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the scheduler tree for all transactions within the specified temporal scope.

v_SCHEDULER_TREE_HIERARCHY VARCHAR2(32) := NVL(MODEL_VALUE_AT_KEY(GA.ELECTRIC_MODEL,'Scheduling','Scheduler Tree','Hierarchy'),'A');
v_SCHEDULER_TREE_TYPE CHAR(1) := SUBSTR(v_SCHEDULER_TREE_HIERARCHY,1,1);
v_ALLOWED_TXNS ID_TABLE := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_TXN_SELECT);
BEGIN


	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    p_STATUS := GA.SUCCESS;

	IF v_SCHEDULER_TREE_TYPE = 'A' THEN
		OPEN p_CURSOR FOR
			SELECT DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)),'PU','Transaction','SA','Transaction','PA','Transaction','LO','Load','RE','Load',A.TRANSACTION_TYPE) AS TRANSACTION_TYPE,
				B.COMMODITY_NAME,
				C.SERVICE_POINT_TYPE,
				A.TRANSACTION_NAME,
				A.TRANSACTION_ID,
				D.TRANSACTION_IS_ACTIVE
			FROM INTERCHANGE_TRANSACTION A, IT_COMMODITY B, SERVICE_POINT C, IT_STATUS D,
				TABLE(CAST(v_ALLOWED_TXNS AS ID_TABLE)) X
			WHERE BEGIN_DATE <= p_END_DATE
				AND END_DATE >= p_BEGIN_DATE
                AND (p_IS_BID_OFFER = 0 OR IS_BID_OFFER = 1)
				AND B.COMMODITY_ID = A.COMMODITY_ID
				AND C.SERVICE_POINT_ID = A.POD_ID
				AND D.TRANSACTION_ID = A.TRANSACTION_ID
				AND D.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM IT_STATUS
					WHERE TRANSACTION_ID = D.TRANSACTION_ID
						AND AS_OF_DATE <= p_AS_OF_DATE)
				AND (X.ID = SD.g_ALL_DATA_ENTITY_ID OR A.TRANSACTION_ID = X.ID)
			ORDER BY 1 DESC, 2 ASC, 3 ASC, 4 ASC;
	ELSIF v_SCHEDULER_TREE_TYPE = 'B' THEN
		OPEN p_CURSOR FOR
			SELECT C.SC_NAME,
				DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)),'PU','Transaction','SA','Transaction','PA','Transaction','LO','Load','RE','Load',A.TRANSACTION_TYPE) AS TRANSACTION_TYPE,
				B.COMMODITY_NAME,
				A.TRANSACTION_NAME,
				A.TRANSACTION_ID,
				D.TRANSACTION_IS_ACTIVE
			FROM INTERCHANGE_TRANSACTION A, IT_COMMODITY B, SCHEDULE_COORDINATOR C, IT_STATUS D,
				TABLE(CAST(v_ALLOWED_TXNS AS ID_TABLE)) X
			WHERE BEGIN_DATE <= p_END_DATE
				AND END_DATE >= p_BEGIN_DATE
                AND (p_IS_BID_OFFER = 0 OR IS_BID_OFFER = 1)
				AND B.COMMODITY_ID = A.COMMODITY_ID
				AND C.SC_ID = A.SC_ID
				AND D.TRANSACTION_ID = A.TRANSACTION_ID
				AND D.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM IT_STATUS
					WHERE TRANSACTION_ID = D.TRANSACTION_ID
						AND AS_OF_DATE <= p_AS_OF_DATE)
				AND (X.ID = SD.g_ALL_DATA_ENTITY_ID OR A.TRANSACTION_ID = X.ID)
			ORDER BY 1 ASC, 2 DESC, 3 ASC, 4 ASC;
	ELSIF v_SCHEDULER_TREE_TYPE = 'C' THEN
		OPEN p_CURSOR FOR
			SELECT C.SC_NAME,
				NVL(F.RESOURCE_GROUP_NAME, 'Not Assigned'),
				B.COMMODITY_NAME,
				A.TRANSACTION_NAME,
				A.TRANSACTION_ID,
				D.TRANSACTION_IS_ACTIVE
			FROM INTERCHANGE_TRANSACTION A, IT_COMMODITY B, SCHEDULE_COORDINATOR C, IT_STATUS D, SUPPLY_RESOURCE E, SUPPLY_RESOURCE_GROUP F,
				TABLE(CAST(v_ALLOWED_TXNS AS ID_TABLE)) X
			WHERE BEGIN_DATE <= p_END_DATE
				AND END_DATE >= p_BEGIN_DATE
                AND (p_IS_BID_OFFER = 0 OR IS_BID_OFFER = 1)
				AND B.COMMODITY_ID = A.COMMODITY_ID
				AND C.SC_ID = A.SC_ID
				AND D.TRANSACTION_ID = A.TRANSACTION_ID
				AND D.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM IT_STATUS
					WHERE TRANSACTION_ID = D.TRANSACTION_ID
						AND AS_OF_DATE <= p_AS_OF_DATE)
				AND E.RESOURCE_ID(+) = A.RESOURCE_ID
				AND F.RESOURCE_GROUP_ID(+) = E.RESOURCE_GROUP_ID
				AND A.TRANSACTION_ID IN (SELECT X.ID FROM TABLE(CAST(v_ALLOWED_TXNS AS ID_TABLE))X)
				AND (X.ID = SD.g_ALL_DATA_ENTITY_ID OR A.TRANSACTION_ID = X.ID)
			ORDER BY 1 ASC, 2 ASC, 3 DESC, 4 ASC;
	ELSIF v_SCHEDULER_TREE_TYPE = '*' THEN
    	CUSTOM_SCHEDULER_TREE(SUBSTR(v_SCHEDULER_TREE_HIERARCHY,2),p_BEGIN_DATE,p_END_DATE,p_AS_OF_DATE,p_IS_BID_OFFER,v_ALLOWED_TXNS,p_STATUS,p_CURSOR);
--	ELSIF v_SCHEDULER_TREE_TYPE = 'X' THEN
--    	XS.GET_SCHEDULER_TREE (p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_IS_BID_OFFER, p_STATUS, p_CURSOR);
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END GET_SCHEDULER_TREE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_IT_SCHEDULE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INCLUDE_EXTERNAL IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the schedule's detailed data for the specified selection criteria.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_FORMAT VARCHAR(4);
v_MINUTES NUMBER(6);
v_SCHEDULE_TYPE NUMBER(9) := SUPPLY_SCHEDULE_TYPE(p_SCHEDULE_TYPE);

BEGIN

	IF g_REDIRECT_SCHEDULER THEN
		SCHEDULER_SCHEDULE(p_TRANSACTION_ID, p_SCHEDULE_TYPE, g_EXTERNAL_STATE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE, p_STATUS, p_CURSOR);
		RETURN;
	END IF;

	IF g_TRACE_ON THEN
	    UT.DEBUG_TRACE('GET_IT_SCHEDULE');
	    UT.DEBUG_TRACE('TRANSACTION_ID=' || TO_CHAR(p_TRANSACTION_ID));
	    UT.DEBUG_TRACE('SCHEDULE_TYPE=' || TO_CHAR(p_SCHEDULE_TYPE));
		UT.DEBUG_TRACE('BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE));
		UT.DEBUG_TRACE('END_DATE=' || TO_CHAR(p_END_DATE));
		UT.DEBUG_TRACE('AS_OF_DATE=' || UT.TRACE_DATE(p_END_DATE));
		UT.DEBUG_TRACE('TIME_ZONE=' || p_TIME_ZONE);
		UT.DEBUG_TRACE('INCLUDE_EXTERNAL=' || TO_CHAR(p_INCLUDE_EXTERNAL));
		UT.DEBUG_TRACE('SCHEDULE_TYPE=' || TO_CHAR(v_SCHEDULE_TYPE));
	END IF;

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    p_STATUS := GA.SUCCESS;

	COERCE_DATE_RANGE(p_TRANSACTION_ID, g_INTERNAL_STATE, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, FALSE, v_BEGIN_DATE, v_END_DATE, v_FORMAT, v_MINUTES);

	IF p_INCLUDE_EXTERNAL = 1 THEN
	 	OPEN p_CURSOR FOR
	 		SELECT DISTINCT FROM_CUT_AS_HED (C.SCHEDULE_DATE, p_TIME_ZONE, v_FORMAT, GA.ELECTRIC_MODEL) "SCHEDULE_DATE",
	 			A.AMOUNT "AMOUNT", A.PRICE "PRICE", A.AMOUNT * A.PRICE "COST",
	 			B.AMOUNT "EXT_AMOUNT", B.PRICE "EXT_PRICE", B.AMOUNT * B.PRICE "EXT_COST"
	 		FROM IT_SCHEDULE A, IT_SCHEDULE B, IT_SCHEDULE C
	 		WHERE C.TRANSACTION_ID = p_TRANSACTION_ID
				AND C.SCHEDULE_TYPE IN (v_SCHEDULE_TYPE, p_SCHEDULE_TYPE)
				AND C.SCHEDULE_STATE = C.SCHEDULE_STATE
				AND C.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
	 			AND C.AS_OF_DATE = SCHEDULE_AS_OF_DATE (C.TRANSACTION_ID, C.SCHEDULE_TYPE, C.SCHEDULE_STATE, C.SCHEDULE_DATE, p_AS_OF_DATE)
				AND A.TRANSACTION_ID (+) = p_TRANSACTION_ID
	 			AND A.SCHEDULE_TYPE (+) = C.SCHEDULE_TYPE
	 			AND A.SCHEDULE_STATE (+) = g_INTERNAL_STATE
	 			AND A.SCHEDULE_DATE (+) = C.SCHEDULE_DATE
	 			AND A.AS_OF_DATE (+) = C.AS_OF_DATE
	 			AND B.TRANSACTION_ID (+) = p_TRANSACTION_ID
	 			AND B.SCHEDULE_TYPE (+) = C.SCHEDULE_TYPE
	 			AND B.SCHEDULE_STATE (+) = g_EXTERNAL_STATE
	 			AND B.SCHEDULE_DATE (+) = C.SCHEDULE_DATE
	 			AND B.AS_OF_DATE (+) = C.AS_OF_DATE
	 		ORDER BY 1;
	ELSE
	 	OPEN p_CURSOR FOR
			SELECT FROM_CUT_AS_HED (A.SCHEDULE_DATE, p_TIME_ZONE, v_FORMAT, GA.ELECTRIC_MODEL) "SCHEDULE_DATE",
	 			A.AMOUNT "AMOUNT", A.PRICE "PRICE", A.AMOUNT * A.PRICE "COST",
	 			NULL "EXT_AMOUNT", NULL "EXT_PRICE", NULL "EXT_COST"
			FROM IT_SCHEDULE A
			WHERE A.TRANSACTION_ID = p_TRANSACTION_ID
				AND A.SCHEDULE_TYPE IN (v_SCHEDULE_TYPE, p_SCHEDULE_TYPE)
				AND A.SCHEDULE_STATE = g_INTERNAL_STATE
				AND A.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND A.AS_OF_DATE = SCHEDULE_AS_OF_DATE (A.TRANSACTION_ID, A.SCHEDULE_TYPE, A.SCHEDULE_STATE, A.SCHEDULE_DATE, p_AS_OF_DATE)
			ORDER BY 1;
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END GET_IT_SCHEDULE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_STATE_AND_TYPE_FROM_MODE
    (
	p_COMPARISON_MODE IN NUMBER,
	p_ALPHA_SCHEDULE_STATE OUT NUMBER,
	p_BETA_SCHEDULE_STATE OUT NUMBER,
	p_ALPHA_SCHEDULE_TYPE OUT NUMBER,
	p_BETA_SCHEDULE_TYPE OUT NUMBER
	) AS
-- COMPARISON MODE:
-- 1 - Forecast-Preliminary
-- 2 - Forecast-Final
-- 3 - Preliminary-Final
-- 4 - Forecast-External
-- 5 - Preliminary-External
-- 6 - Final-External

BEGIN

	--SET UP SCHEDULE STATES DEPENDING ON COMPARISON MODE
	p_ALPHA_SCHEDULE_STATE := g_INTERNAL_STATE;
	IF p_COMPARISON_MODE IN (1,2,3) THEN
		p_BETA_SCHEDULE_STATE := g_INTERNAL_STATE;
	ELSE
		p_BETA_SCHEDULE_STATE := g_EXTERNAL_STATE;
	END IF;

	--SET UP SCHEDULE TYPES DEPENDING ON COMPARISON MODE
	IF p_COMPARISON_MODE = 1 THEN
		p_ALPHA_SCHEDULE_TYPE := 1; --FORECAST
		p_BETA_SCHEDULE_TYPE := 2; --PRELIMINARY
	ELSIF p_COMPARISON_MODE = 2 THEN
		p_ALPHA_SCHEDULE_TYPE := 1; --FORECAST
		p_BETA_SCHEDULE_TYPE := 3; --FINAL
	ELSIF p_COMPARISON_MODE = 3 THEN
		p_ALPHA_SCHEDULE_TYPE := 2; --PRELIMINARY
		p_BETA_SCHEDULE_TYPE := 3; --FINAL
	ELSIF p_COMPARISON_MODE = 4 THEN
		p_ALPHA_SCHEDULE_TYPE := 1; --FORECAST
		p_BETA_SCHEDULE_TYPE := 1; --FORECAST
	ELSIF p_COMPARISON_MODE = 5 THEN
		p_ALPHA_SCHEDULE_TYPE := 2; --PRELIMINARY
		p_BETA_SCHEDULE_TYPE := 2; --PRELIMINARY
	ELSIF p_COMPARISON_MODE = 6 THEN
		p_ALPHA_SCHEDULE_TYPE := 3; --FINAL
		p_BETA_SCHEDULE_TYPE := 3; --FINAL
	END IF;

END GET_STATE_AND_TYPE_FROM_MODE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_TRANSACTION_TOTALS
    (
    p_SCHEDULE_TYPE1 IN NUMBER,
    p_SCHEDULE_STATE1 IN NUMBER,
    p_SCHEDULE_TYPE2 IN NUMBER,
    p_SCHEDULE_STATE2 IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_TRANSACTION_IDS IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the schedulers for the specified selection criteria.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_WORK_ID NUMBER;
v_TABLE GA.STRING_TABLE;
v_INDEX BINARY_INTEGER;
v_INTERVAL VARCHAR2(16);
v_TRUNC_INTERVAL VARCHAR2(16);
v_ALPHA_SCHEDULE_STATE NUMBER;
v_BETA_SCHEDULE_STATE NUMBER;
v_ALPHA_SCHEDULE_TYPE NUMBER;
v_BETA_SCHEDULE_TYPE NUMBER;

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	UT.GET_RTO_WORK_ID(v_WORK_ID);
	UT.TOKENS_FROM_STRING(p_TRANSACTION_IDS, ';', v_TABLE);

	FOR v_INDEX IN v_TABLE.FIRST..v_TABLE.LAST LOOP
		UT.POST_RTO_WORK(v_WORK_ID, NULL, TO_NUMBER(v_TABLE(v_INDEX)));
	END LOOP;
	v_TABLE.DELETE;

--	GET_STATE_AND_TYPE_FROM_MODE(p_COMPARISON_MODE, v_ALPHA_SCHEDULE_STATE, v_BETA_SCHEDULE_STATE, v_ALPHA_SCHEDULE_TYPE, v_BETA_SCHEDULE_TYPE);
	v_ALPHA_SCHEDULE_TYPE := p_SCHEDULE_TYPE1;
    v_ALPHA_SCHEDULE_STATE := p_SCHEDULE_STATE1;
	v_BETA_SCHEDULE_TYPE := p_SCHEDULE_TYPE2;
    v_BETA_SCHEDULE_STATE := p_SCHEDULE_STATE2;

	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	IF GA.VERSION_SCHEDULE THEN
		OPEN p_CURSOR FOR
			SELECT A.TRANSACTION_ID,
				A.TRANSACTION_NAME "Name",
				A.CONTRACT_NAME "Contract Name",
				A.CONTRACT_NUMBER "Contract Number",
				SUM(NVL(A.INTERNAL_AMOUNT,0)) "Alpha",
				SUM(NVL(A.EXTERNAL_AMOUNT,0)) "Beta",
				SUM(NVL(A.INTERNAL_AMOUNT,0)) - SUM(NVL(A.EXTERNAL_AMOUNT,0)) "Delta",
				ROUND(DECODE(SUM(NVL(A.INTERNAL_AMOUNT,0)),0,NULL,(SUM(NVL(A.INTERNAL_AMOUNT,0))-SUM(NVL(A.EXTERNAL_AMOUNT,0)))*100/SUM(NVL(A.INTERNAL_AMOUNT,0))),16) "Delta_Pct"
			FROM
				(SELECT DISTINCT B.SCHEDULE_DATE, B.TRANSACTION_ID,
					E.TRANSACTION_NAME, F.CONTRACT_NAME,
					F.CONTRACT_NUMBER, C.AMOUNT "INTERNAL_AMOUNT", D.AMOUNT "EXTERNAL_AMOUNT"
				FROM RTO_WORK A, IT_SCHEDULE B, IT_SCHEDULE C, IT_SCHEDULE D, INTERCHANGE_TRANSACTION E, TP_CONTRACT_NUMBER F
				WHERE A.WORK_ID = v_WORK_ID
					AND B.TRANSACTION_ID = A.WORK_XID
					AND B.SCHEDULE_TYPE IN (0, v_ALPHA_SCHEDULE_TYPE, v_BETA_SCHEDULE_TYPE)
					AND B.SCHEDULE_STATE IN (v_ALPHA_SCHEDULE_STATE, v_BETA_SCHEDULE_STATE)
					AND B.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
					AND B.AS_OF_DATE = SCHEDULE_AS_OF_DATE(B.TRANSACTION_ID, B.SCHEDULE_TYPE, B.SCHEDULE_STATE, B.SCHEDULE_DATE, p_AS_OF_DATE)
					AND C.TRANSACTION_ID(+) = B.TRANSACTION_ID
					AND C.SCHEDULE_TYPE(+) = v_ALPHA_SCHEDULE_TYPE
					AND C.SCHEDULE_STATE(+) = v_ALPHA_SCHEDULE_STATE
					AND C.SCHEDULE_DATE(+) = B.SCHEDULE_DATE
					AND C.AS_OF_DATE(+) = SCHEDULE_AS_OF_DATE(C.TRANSACTION_ID, C.SCHEDULE_TYPE, C.SCHEDULE_STATE, C.SCHEDULE_DATE, p_AS_OF_DATE)
					AND D.TRANSACTION_ID(+) = B.TRANSACTION_ID
					AND D.SCHEDULE_TYPE(+) = v_BETA_SCHEDULE_TYPE
					AND D.SCHEDULE_STATE(+) = v_BETA_SCHEDULE_STATE
					AND D.SCHEDULE_DATE(+) = B.SCHEDULE_DATE
					AND C.AS_OF_DATE(+) = SCHEDULE_AS_OF_DATE(D.TRANSACTION_ID, D.SCHEDULE_TYPE, D.SCHEDULE_STATE, D.SCHEDULE_DATE, p_AS_OF_DATE)
					AND E.TRANSACTION_ID = B.TRANSACTION_ID
					AND F.CONTRACT_ID(+) = E.CONTRACT_ID
					AND CUT_DATE_BETWEEN(B.SCHEDULE_DATE, F.BEGIN_DATE, F.END_DATE, 'EDT') = 'Y') A
			GROUP BY A.TRANSACTION_ID, A.TRANSACTION_NAME, A.CONTRACT_NAME, A.CONTRACT_NUMBER
			ORDER BY 1;
	ELSE
		OPEN p_CURSOR FOR
			SELECT A.TRANSACTION_ID,
				A.TRANSACTION_NAME "Name",
				A.CONTRACT_NAME "Contract Name",
				A.CONTRACT_NUMBER "Contract Number",
				SUM(NVL(A.INTERNAL_AMOUNT,0)) "Alpha",
				SUM(NVL(A.EXTERNAL_AMOUNT,0)) "Beta",
				SUM(NVL(A.INTERNAL_AMOUNT,0)) - SUM(NVL(A.EXTERNAL_AMOUNT,0)) "Delta",
				ROUND(DECODE(SUM(NVL(A.INTERNAL_AMOUNT,0)),0,NULL,(SUM(NVL(A.INTERNAL_AMOUNT,0))-SUM(NVL(A.EXTERNAL_AMOUNT,0)))*100/SUM(NVL(A.INTERNAL_AMOUNT,0))),16) "Delta_Pct"
			FROM
				(SELECT DISTINCT B.SCHEDULE_DATE, B.TRANSACTION_ID,
					E.TRANSACTION_NAME, F.CONTRACT_NAME,
					F.CONTRACT_NUMBER, C.AMOUNT "INTERNAL_AMOUNT", D.AMOUNT "EXTERNAL_AMOUNT"
				FROM RTO_WORK A, IT_SCHEDULE B, IT_SCHEDULE C, IT_SCHEDULE D, INTERCHANGE_TRANSACTION E, TP_CONTRACT_NUMBER F
				WHERE A.WORK_ID = v_WORK_ID
					AND B.TRANSACTION_ID = A.WORK_XID
					AND B.SCHEDULE_TYPE IN (0, v_ALPHA_SCHEDULE_TYPE, v_BETA_SCHEDULE_TYPE)
					AND B.SCHEDULE_STATE IN (v_ALPHA_SCHEDULE_STATE, v_BETA_SCHEDULE_STATE)
					AND B.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
					AND B.AS_OF_DATE = LOW_DATE
					AND C.TRANSACTION_ID(+) = B.TRANSACTION_ID
					AND C.SCHEDULE_TYPE(+) = v_ALPHA_SCHEDULE_TYPE
					AND C.SCHEDULE_STATE(+) = v_ALPHA_SCHEDULE_STATE
					AND C.SCHEDULE_DATE(+) = B.SCHEDULE_DATE
					AND C.AS_OF_DATE(+) = B.AS_OF_DATE
					AND D.TRANSACTION_ID(+) = B.TRANSACTION_ID
					AND D.SCHEDULE_TYPE(+) = v_BETA_SCHEDULE_TYPE
					AND D.SCHEDULE_STATE(+) = v_BETA_SCHEDULE_STATE
					AND D.SCHEDULE_DATE(+) = B.SCHEDULE_DATE
					AND D.AS_OF_DATE(+) = B.AS_OF_DATE
					AND E.TRANSACTION_ID = B.TRANSACTION_ID
					AND F.CONTRACT_ID(+) = E.CONTRACT_ID
					AND CUT_DATE_BETWEEN(B.SCHEDULE_DATE, F.BEGIN_DATE, F.END_DATE, 'EDT') = 'Y') A
			GROUP BY A.TRANSACTION_ID, A.TRANSACTION_NAME, A.CONTRACT_NAME, A.CONTRACT_NUMBER
			ORDER BY 1;
	END IF;

	UT.PURGE_RTO_WORK(v_WORK_ID);

EXCEPTION
	WHEN OTHERS THEN
		UT.PURGE_RTO_WORK(v_WORK_ID);
		p_STATUS := SQLCODE;

END GET_TRANSACTION_TOTALS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_TP_CONTRACT_LOAD_SCHEDULES
    (
	p_PSE_IDS IN VARCHAR,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the schedulers for the specified selection criteria.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_WORK_ID NUMBER;
v_TABLE GA.STRING_TABLE;
v_INDEX BINARY_INTEGER;

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	IF NOT UPPER(SUBSTR(p_PSE_IDS,1,5)) = '<ALL>' THEN

		UT.GET_RTO_WORK_ID(v_WORK_ID);
		UT.TOKENS_FROM_STRING(p_PSE_IDS, ';', v_TABLE);

		FOR v_INDEX IN v_TABLE.FIRST..v_TABLE.LAST LOOP
			UT.POST_RTO_WORK(v_WORK_ID, NULL, TO_NUMBER(v_TABLE(v_INDEX)));
		END LOOP;
		v_TABLE.DELETE;

		IF GA.VERSION_SCHEDULE THEN
			OPEN p_CURSOR FOR
				SELECT A.TRANSACTION_NAME, A.TRANSACTION_ID, D.CONTRACT_NAME, D.CONTRACT_NUMBER, D.BEGIN_DATE, D.END_DATE, FROM_CUT_AS_HED(E.SCHEDULE_DATE, p_TIME_ZONE) "SCHEDULE_DATE", E.AMOUNT "AMOUNT"
				FROM INTERCHANGE_TRANSACTION A, RTO_WORK B, INTERCHANGE_CONTRACT C, TP_CONTRACT_NUMBER D,  IT_SCHEDULE E
				WHERE NVL(A.BEGIN_DATE, LOW_DATE) <= TRUNC(p_END_DATE)
					AND NVL(A.END_DATE, HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
					AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) = 'LO'
					AND B.WORK_ID = v_WORK_ID
					AND (A.PURCHASER_ID = B.WORK_XID OR A.SELLER_ID = B.WORK_XID)
					AND C.CONTRACT_ID = A.CONTRACT_ID
					AND C.BEGIN_DATE <= TRUNC(p_END_DATE)
					AND NVL(C.END_DATE, NVL(A.END_DATE, HIGH_DATE)) >= TRUNC(p_BEGIN_DATE)
					AND D.CONTRACT_ID = C.CONTRACT_ID
					AND D.BEGIN_DATE >= C.BEGIN_DATE
					AND NVL(D.END_DATE, NVL(C.END_DATE, NVL(A.END_DATE, HIGH_DATE))) <= NVL(C.END_DATE, NVL(A.END_DATE, HIGH_DATE))
					AND E.TRANSACTION_ID = A.TRANSACTION_ID
					AND (E.SCHEDULE_TYPE = 0 OR E.SCHEDULE_TYPE = p_SCHEDULE_TYPE)
					AND E.SCHEDULE_STATE = g_INTERNAL_STATE
					AND E.SCHEDULE_DATE BETWEEN GREATEST(v_BEGIN_DATE, BEGIN_CUT_DAY_INTERVAL(D.BEGIN_DATE, p_TIME_ZONE)) AND LEAST(v_END_DATE, END_CUT_DAY_INTERVAL(NVL(D.END_DATE, v_END_DATE), p_TIME_ZONE))
					AND E.AS_OF_DATE =
						(SELECT MAX(AS_OF_DATE)
						FROM IT_SCHEDULE
						WHERE TRANSACTION_ID = E.TRANSACTION_ID
							AND SCHEDULE_TYPE = E.SCHEDULE_TYPE
							AND SCHEDULE_STATE = E.SCHEDULE_STATE
							AND SCHEDULE_DATE = E.SCHEDULE_DATE
							AND AS_OF_DATE <= p_AS_OF_DATE)
				ORDER BY A.TRANSACTION_NAME, A.TRANSACTION_ID, D.BEGIN_DATE, D.CONTRACT_NAME, D.CONTRACT_NUMBER, E.SCHEDULE_DATE;
		ELSE
			OPEN p_CURSOR FOR
				SELECT A.TRANSACTION_NAME, A.TRANSACTION_ID, D.CONTRACT_NAME, D.CONTRACT_NUMBER, D.BEGIN_DATE, D.END_DATE, FROM_CUT_AS_HED(E.SCHEDULE_DATE, p_TIME_ZONE) "SCHEDULE_DATE", E.AMOUNT "AMOUNT"
				FROM INTERCHANGE_TRANSACTION A, RTO_WORK B, INTERCHANGE_CONTRACT C, TP_CONTRACT_NUMBER D,  IT_SCHEDULE E
				WHERE NVL(A.BEGIN_DATE, LOW_DATE) <= TRUNC(p_END_DATE)
					AND NVL(A.END_DATE, HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
					AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) = 'LO'
					AND B.WORK_ID = v_WORK_ID
					AND (A.PURCHASER_ID = B.WORK_XID OR A.SELLER_ID = B.WORK_XID)
					AND C.CONTRACT_ID = A.CONTRACT_ID
					AND C.BEGIN_DATE <= TRUNC(p_END_DATE)
					AND NVL(C.END_DATE, NVL(A.END_DATE, HIGH_DATE)) >= TRUNC(p_BEGIN_DATE)
					AND D.CONTRACT_ID = C.CONTRACT_ID
					AND D.BEGIN_DATE >= C.BEGIN_DATE
					AND NVL(D.END_DATE, NVL(C.END_DATE, NVL(A.END_DATE, HIGH_DATE))) <= NVL(C.END_DATE, NVL(A.END_DATE, HIGH_DATE))
					AND E.TRANSACTION_ID = A.TRANSACTION_ID
					AND (E.SCHEDULE_TYPE = 0 OR E.SCHEDULE_TYPE = p_SCHEDULE_TYPE)
					AND E.SCHEDULE_STATE = g_INTERNAL_STATE
					AND E.SCHEDULE_DATE BETWEEN GREATEST(v_BEGIN_DATE, BEGIN_CUT_DAY_INTERVAL(D.BEGIN_DATE, p_TIME_ZONE)) AND LEAST(v_END_DATE, END_CUT_DAY_INTERVAL(NVL(D.END_DATE, v_END_DATE), p_TIME_ZONE))
					AND E.AS_OF_DATE = LOW_DATE
				ORDER BY A.TRANSACTION_NAME, A.TRANSACTION_ID, D.BEGIN_DATE, D.CONTRACT_NAME, D.CONTRACT_NUMBER, E.SCHEDULE_DATE;
		END IF;
		UT.PURGE_RTO_WORK(v_WORK_ID);
	ELSE
		IF GA.VERSION_SCHEDULE THEN
			OPEN p_CURSOR FOR
				SELECT A.TRANSACTION_NAME, A.TRANSACTION_ID, C.CONTRACT_NAME, C.CONTRACT_NUMBER, C.BEGIN_DATE, C.END_DATE, FROM_CUT_AS_HED(D.SCHEDULE_DATE, p_TIME_ZONE) "SCHEDULE_DATE", D.AMOUNT "AMOUNT"
				FROM INTERCHANGE_TRANSACTION A, INTERCHANGE_CONTRACT B, TP_CONTRACT_NUMBER C,  IT_SCHEDULE D
				WHERE NVL(A.BEGIN_DATE, LOW_DATE) <= TRUNC(p_END_DATE)
					AND NVL(A.END_DATE, HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
					AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) = 'LO'
					AND B.CONTRACT_ID = A.CONTRACT_ID
					AND B.BEGIN_DATE <= TRUNC(p_END_DATE)
					AND NVL(B.END_DATE, NVL(A.END_DATE, HIGH_DATE)) >= TRUNC(p_BEGIN_DATE)
					AND C.CONTRACT_ID = B.CONTRACT_ID
					AND C.BEGIN_DATE >= B.BEGIN_DATE
					AND NVL(C.END_DATE, NVL(B.END_DATE, NVL(A.END_DATE, HIGH_DATE))) <= NVL(B.END_DATE, NVL(A.END_DATE, HIGH_DATE))
					AND D.TRANSACTION_ID = A.TRANSACTION_ID
					AND (D.SCHEDULE_TYPE = 0 OR D.SCHEDULE_TYPE = p_SCHEDULE_TYPE)
					AND D.SCHEDULE_STATE = g_INTERNAL_STATE
					AND D.SCHEDULE_DATE BETWEEN GREATEST(v_BEGIN_DATE, BEGIN_CUT_DAY_INTERVAL(C.BEGIN_DATE, p_TIME_ZONE)) AND LEAST(v_END_DATE, END_CUT_DAY_INTERVAL(NVL(C.END_DATE, v_END_DATE), p_TIME_ZONE))
					AND D.AS_OF_DATE =
						(SELECT MAX(AS_OF_DATE)
						FROM IT_SCHEDULE
						WHERE TRANSACTION_ID = D.TRANSACTION_ID
							AND SCHEDULE_TYPE = D.SCHEDULE_TYPE
							AND SCHEDULE_STATE = D.SCHEDULE_STATE
							AND SCHEDULE_DATE = D.SCHEDULE_DATE
							AND AS_OF_DATE <= p_AS_OF_DATE)
				ORDER BY A.TRANSACTION_NAME, A.TRANSACTION_ID, C.BEGIN_DATE, C.CONTRACT_NAME, C.CONTRACT_NUMBER, D.SCHEDULE_DATE;
		ELSE
			OPEN p_CURSOR FOR
				SELECT A.TRANSACTION_NAME, A.TRANSACTION_ID, C.CONTRACT_NAME, C.CONTRACT_NUMBER, C.BEGIN_DATE, C.END_DATE, FROM_CUT_AS_HED(D.SCHEDULE_DATE, p_TIME_ZONE) "SCHEDULE_DATE", D.AMOUNT "AMOUNT"
				FROM INTERCHANGE_TRANSACTION A, INTERCHANGE_CONTRACT B, TP_CONTRACT_NUMBER C,  IT_SCHEDULE D
				WHERE NVL(A.BEGIN_DATE, LOW_DATE) <= TRUNC(p_END_DATE)
					AND NVL(A.END_DATE, HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
					AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) = 'LO'
					AND B.CONTRACT_ID = A.CONTRACT_ID
					AND B.BEGIN_DATE <= TRUNC(p_END_DATE)
					AND NVL(B.END_DATE, NVL(A.END_DATE, HIGH_DATE)) >= TRUNC(p_BEGIN_DATE)
					AND C.CONTRACT_ID = B.CONTRACT_ID
					AND C.BEGIN_DATE >= B.BEGIN_DATE
					AND NVL(C.END_DATE, NVL(B.END_DATE, NVL(A.END_DATE, HIGH_DATE))) <= NVL(B.END_DATE, NVL(A.END_DATE, HIGH_DATE))
					AND D.TRANSACTION_ID = A.TRANSACTION_ID
					AND (D.SCHEDULE_TYPE = 0 OR D.SCHEDULE_TYPE = p_SCHEDULE_TYPE)
					AND D.SCHEDULE_STATE = g_INTERNAL_STATE
					AND D.SCHEDULE_DATE BETWEEN GREATEST(v_BEGIN_DATE, BEGIN_CUT_DAY_INTERVAL(C.BEGIN_DATE, p_TIME_ZONE)) AND LEAST(v_END_DATE, END_CUT_DAY_INTERVAL(NVL(C.END_DATE, v_END_DATE), p_TIME_ZONE))
					AND D.AS_OF_DATE = LOW_DATE
				ORDER BY A.TRANSACTION_NAME, A.TRANSACTION_ID, C.BEGIN_DATE, C.CONTRACT_NAME, C.CONTRACT_NUMBER, D.SCHEDULE_DATE;
		END IF;
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		UT.PURGE_RTO_WORK(v_WORK_ID);
		p_STATUS := SQLCODE;

END GET_TP_CONTRACT_LOAD_SCHEDULES;
---------------------------------------------------------------------------------------------------
PROCEDURE DATE_RANGE
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_MINUTES IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer a date range of local date and times.
--DEPRECATED.  USE UT.DATE_RANGE INSTEAD.
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_WORK_ID NUMBER;

BEGIN

    p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	UT.GET_RTO_WORK_ID(v_WORK_ID);
	UT.POST_RTO_WORK_DATE_RANGE(v_WORK_ID, v_BEGIN_DATE, v_END_DATE, p_MINUTES);

	OPEN p_CURSOR FOR
	    SELECT FROM_CUT_AS_HED(WORK_DATE, p_TIME_ZONE)
		FROM RTO_WORK
		WHERE WORK_ID = v_WORK_ID
		ORDER BY 1;

	UT.PURGE_RTO_WORK(v_WORK_ID);

	EXCEPTION
	    WHEN OTHERS THEN
			UT.PURGE_RTO_WORK(v_WORK_ID);
		    p_STATUS := SQLCODE;

END DATE_RANGE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_PHYSICAL_POSITION
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_COMMODITY_TYPE IN VARCHAR,
	p_SCHEDULE_TYPE IN NUMBER,
	p_PORPOD_TYPE IN VARCHAR,
	p_POD_ID IN NUMBER,
	p_POR_ID IN NUMBER,
	p_PURCHASER_ID IN NUMBER,
	p_SELLER_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_TP_ID IN NUMBER,
	p_ROLLUP_ID_1 IN NUMBER,
	p_ROLLUP_ID_2 IN NUMBER,
	p_ROLLUP_ID_3 IN NUMBER,
	p_ROLLUP_ID_4 IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the physical position based upon the specified filtering criteria.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_INTERVAL_CODE NUMBER;
v_HED_INTERVAL VARCHAR2(8);

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
    SELECT DECODE(UPPER(SUBSTR(p_INTERVAL,1,2)),'5 ',1,'10',2,'15',3,'30',4,'HO',5,'DA',6,'WE',7,'MO',8,'QU',9,'YE',10,0)
    INTO v_INTERVAL_CODE FROM DUAL;
    SELECT DECODE(UPPER(SUBSTR(p_INTERVAL,1,2)),'5 ','MI5','10','MI10','15','MI15','30','MI30','HO','HH','DA','DD','WE','DY','MO','MM','QU','QQ','YE','YY','HH')
    INTO v_HED_INTERVAL FROM DUAL;

	OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(SCHEDULE_DATE, p_TIME_ZONE, v_HED_INTERVAL),
			SUM(LOAD),
			SUM(GENERATION),
			SUM(PURCHASE_AMOUNT),
			SUM(SALE_AMOUNT),
			SUM(PASS_THRU_AMOUNT)
		FROM PHYSICAL_POSITION A,
		     IT_STATUS B,
		     SERVICE_POINT C
		WHERE A.COMMODITY_TYPE = p_COMMODITY_TYPE
			AND DECODE(UPPER(SUBSTR(A.TRANSACTION_INTERVAL,1,2)),'5 ',1,'10',2,'15',3,'30',4,'HO',5,'DA',6,'WE',7,'MO',8,'QU',9,'YE',10,0) <= v_INTERVAL_CODE
			AND A.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND (A.SCHEDULE_TYPE = 0 OR A.SCHEDULE_TYPE = p_SCHEDULE_TYPE)
			AND (p_POR_ID = g_ALL OR A.POR_ID = p_POR_ID)
			AND (p_POD_ID = g_ALL OR A.POD_ID = p_POD_ID)
			AND C.SERVICE_POINT_ID = A.POR_ID
			AND (UPPER(p_PORPOD_TYPE) = '<ALL>' OR UPPER(A.SERVICE_POINT_TYPE) = UPPER(p_PORPOD_TYPE) OR UPPER(C.SERVICE_POINT_TYPE) = UPPER(p_PORPOD_TYPE))
			AND (p_PURCHASER_ID = g_ALL OR A.PURCHASER_ID = p_PURCHASER_ID)
			AND (p_SELLER_ID = g_ALL OR A.SELLER_ID = p_SELLER_ID)
			AND (p_EDC_ID = g_ALL OR A.EDC_ID = p_EDC_ID)
			AND (p_TP_ID = g_ALL OR A.TP_ID = p_TP_ID)
			AND (p_ROLLUP_ID_1 = g_ALL OR A.ROLLUP_ID_1 = p_ROLLUP_ID_1)
			AND (p_ROLLUP_ID_2 = g_ALL OR A.ROLLUP_ID_2 = p_ROLLUP_ID_2)
			AND (p_ROLLUP_ID_3 = g_ALL OR A.ROLLUP_ID_3 = p_ROLLUP_ID_3)
			AND (p_ROLLUP_ID_4 = g_ALL OR A.ROLLUP_ID_4 = p_ROLLUP_ID_4)
			AND A.AS_OF_DATE = SCHEDULE_AS_OF_DATE (A.TRANSACTION_ID, A.SCHEDULE_TYPE, A.SCHEDULE_STATE, A.SCHEDULE_DATE, p_AS_OF_DATE)
			AND B.TRANSACTION_ID = A.TRANSACTION_ID
			AND B.AS_OF_DATE = IT_STATUS_AS_OF_DATE (B.TRANSACTION_ID, p_AS_OF_DATE)
			AND B.TRANSACTION_IS_ACTIVE = 1
			AND A.SCHEDULE_STATE = g_INTERNAL_STATE
		GROUP BY FROM_CUT_AS_HED(SCHEDULE_DATE, p_TIME_ZONE, v_HED_INTERVAL)
		ORDER BY 1;

  	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END GET_PHYSICAL_POSITION;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_NET_INTERCHANGE
    (
	p_CA_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    p_STATUS := GA.SUCCESS;

	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	OPEN p_CURSOR FOR
		SELECT DECODE(D.IS_INTERCONNECT,1,D.SERVICE_POINT_NAME,C.SERVICE_POINT_NAME) "SERVICE_POINT_NAME",
			DECODE(D.IS_INTERCONNECT,1,D.SERVICE_POINT_ID,C.SERVICE_POINT_ID) "SERVICE_POINT_ID",
			FROM_CUT_AS_HED(E.SCHEDULE_DATE, p_TIME_ZONE),
			SUM(E.AMOUNT * (DECODE(D.IS_INTERCONNECT,1,DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)),'LO',1,'SA',1,-1),
				DECODE(C.IS_INTERCONNECT,1,DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)),'LO',-1,'SA',-1,1),0)))) "NET_AMOUNT"
		FROM INTERCHANGE_TRANSACTION A,
			IT_COMMODITY B,
			SERVICE_POINT C,
			SERVICE_POINT D,
			IT_SCHEDULE E
		WHERE A.BEGIN_DATE <= v_END_DATE
			AND A.END_DATE >= v_BEGIN_DATE
			AND UPPER(A.TRANSACTION_INTERVAL) = 'HOUR'
			AND B.COMMODITY_ID = A.COMMODITY_ID
			AND UPPER(B.COMMODITY_TYPE) = 'ENERGY'
			AND C.SERVICE_POINT_ID = A.POR_ID
			AND D.SERVICE_POINT_ID = A.POD_ID
			AND ((p_CA_ID = g_ALL AND (C.IS_INTERCONNECT = 1 OR D.IS_INTERCONNECT = 1)) OR (C.CA_ID = p_CA_ID AND C.IS_INTERCONNECT = 1) OR (D.CA_ID = p_CA_ID AND D.IS_INTERCONNECT = 1))
			AND E.TRANSACTION_ID =A.TRANSACTION_ID
			AND E.SCHEDULE_TYPE IN (0, p_SCHEDULE_TYPE)
			AND E.SCHEDULE_STATE = g_INTERNAL_STATE
			AND E.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND E.AS_OF_DATE = SCHEDULE_AS_OF_DATE(E.TRANSACTION_ID, E.SCHEDULE_TYPE, E.SCHEDULE_STATE, E.SCHEDULE_DATE, p_AS_OF_DATE)
		GROUP BY DECODE(D.IS_INTERCONNECT,1,D.SERVICE_POINT_NAME,C.SERVICE_POINT_NAME),
			DECODE(D.IS_INTERCONNECT,1,D.SERVICE_POINT_ID,C.SERVICE_POINT_ID),
			E.SCHEDULE_DATE
		ORDER BY 1,3;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END GET_NET_INTERCHANGE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_LOAD_DIFFERENTIAL_FOR_EDC
	(
	p_PSE_ID_LIST IN VARCHAR2,
	p_SCHEDULE_TYPE IN NUMBER,
    p_SCHEDULE_STATE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_AS_OF_DATE IN DATE,
	p_DATE_ADJ IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

v_WORK_ID NUMBER;
v_IDs_TABLE GA.STRING_TABLE;
v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN
	UT.GET_RTO_WORK_ID (v_WORK_ID);

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
	p_STATUS := GA.SUCCESS;
	IF p_SCHEDULE_TYPE < 0 THEN
		-- if -1 schedule type then return empty recordset
		OPEN p_CURSOR FOR
			SELECT 1 FROM DUAL WHERE 1 < 0;
		RETURN;
	END IF;
	UT.TOKENS_FROM_STRING(p_PSE_ID_LIST, ';', v_IDs_TABLE);
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	FOR v_INDEX IN v_IDs_TABLE.FIRST..v_IDs_TABLE.LAST LOOP
		UT.POST_RTO_WORK (v_WORK_ID, 0, TO_NUMBER(v_IDs_TABLE(v_INDEX)));
	END LOOP;

	OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(D.SCHEDULE_DATE+p_DATE_ADJ,p_TIME_ZONE) "DATE",
			B.PSE_NAME,
			B.PSE_ID,
			SUM(D.AMOUNT) "AMOUNT"
		FROM RTO_WORK A,
			PURCHASING_SELLING_ENTITY B,
			INTERCHANGE_TRANSACTION C,
			IT_SCHEDULE D
		WHERE WORK_ID = v_WORK_ID
			AND B.PSE_ID = WORK_XID
			AND UPPER(SUBSTR(C.TRANSACTION_TYPE,1,2)) IN ('LO', 'RE') -- 'Load' or 'Retail Load'
			AND (C.PURCHASER_ID = B.PSE_ID OR C.SELLER_ID = B.PSE_ID)
			AND D.TRANSACTION_ID = C.TRANSACTION_ID
			AND D.SCHEDULE_TYPE = p_SCHEDULE_TYPE
			AND D.SCHEDULE_STATE = p_SCHEDULE_STATE
			AND D.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND D.AS_OF_DATE = SCHEDULE_AS_OF_DATE(D.TRANSACTION_ID, D.SCHEDULE_TYPE, D.SCHEDULE_STATE, D.SCHEDULE_DATE, p_AS_OF_DATE)
		GROUP BY FROM_CUT_AS_HED(D.SCHEDULE_DATE+p_DATE_ADJ,p_TIME_ZONE), B.PSE_NAME, B.PSE_ID
		ORDER BY 1, 2, 3;

	UT.PURGE_RTO_WORK (v_WORK_ID);

	EXCEPTION
		WHEN OTHERS THEN
			UT.PURGE_RTO_WORK (v_WORK_ID);
			p_STATUS := SQLCODE;

END GET_LOAD_DIFFERENTIAL_FOR_EDC;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_LOAD_DIFFERENTIAL_FOR_ESP
	(
	p_EDC_ID_LIST IN VARCHAR2,
	p_SCHEDULE_TYPE IN NUMBER,
    p_SCHEDULE_STATE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_AS_OF_DATE IN DATE,
	p_DATE_ADJ IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

v_WORK_ID NUMBER;
v_IDs_TABLE GA.STRING_TABLE;
v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN
	UT.GET_RTO_WORK_ID (v_WORK_ID);

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;
	p_STATUS := GA.SUCCESS;
	IF p_SCHEDULE_TYPE < 0 THEN
		-- if -1 schedule type then return empty recordset
		OPEN p_CURSOR FOR
			SELECT 1 FROM DUAL WHERE 1 < 0;
		RETURN;
	END IF;
	UT.TOKENS_FROM_STRING(p_EDC_ID_LIST, ';', v_IDs_TABLE);
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	FOR v_INDEX IN v_IDs_TABLE.FIRST..v_IDs_TABLE.LAST LOOP
		UT.POST_RTO_WORK (v_WORK_ID, 0, TO_NUMBER(v_IDs_TABLE(v_INDEX)));
	END LOOP;

	OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(E.SCHEDULE_DATE+p_DATE_ADJ,p_TIME_ZONE) "DATE",
			B.EDC_NAME "PSE_NAME",
			B.EDC_ID "PSE_ID",
			SUM(E.AMOUNT) "AMOUNT"
		FROM RTO_WORK A,
			ENERGY_DISTRIBUTION_COMPANY B,
			SERVICE_POINT C,
			INTERCHANGE_TRANSACTION D,
			IT_SCHEDULE E
		WHERE WORK_ID = v_WORK_ID
			AND B.EDC_ID = WORK_XID
			AND C.EDC_ID = B.EDC_ID
			AND UPPER(SUBSTR(D.TRANSACTION_TYPE,1,2)) IN ('LO', 'RE') -- 'Load' or 'Retail Load'
			AND (D.POR_ID = C.SERVICE_POINT_ID OR D.POD_ID = C.SERVICE_POINT_ID)
			AND E.TRANSACTION_ID = D.TRANSACTION_ID
			AND E.SCHEDULE_TYPE = p_SCHEDULE_TYPE
			AND E.SCHEDULE_STATE = p_SCHEDULE_STATE
			AND E.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND E.AS_OF_DATE = SCHEDULE_AS_OF_DATE(E.TRANSACTION_ID, E.SCHEDULE_TYPE, E.SCHEDULE_STATE, E.SCHEDULE_DATE, p_AS_OF_DATE)
		GROUP BY FROM_CUT_AS_HED(E.SCHEDULE_DATE+p_DATE_ADJ,p_TIME_ZONE), B.EDC_NAME, B.EDC_ID
		ORDER BY 1, 2, 3;

	UT.PURGE_RTO_WORK (v_WORK_ID);

	EXCEPTION
		WHEN OTHERS THEN
			UT.PURGE_RTO_WORK (v_WORK_ID);
			p_STATUS := SQLCODE;

END GET_LOAD_DIFFERENTIAL_FOR_ESP;
---------------------------------------------------------------------------------------------------
PROCEDURE ENTITY_ATTRIBUTES
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of Entity Attributes that are available as a filter of transactions.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT DISTINCT A.ATTRIBUTE_NAME,
			A.ATTRIBUTE_ID,
			B.ATTRIBUTE_VAL
		FROM ENTITY_ATTRIBUTE A,
			TEMPORAL_ENTITY_ATTRIBUTE B,
			INTERCHANGE_TRANSACTION C
		WHERE A.ENTITY_DOMAIN_ID = -200
			AND UPPER(SUBSTR(A.ATTRIBUTE_TYPE,1,1)) = 'S'
			AND B.ATTRIBUTE_ID = A.ATTRIBUTE_ID
			AND B.OWNER_ENTITY_ID = C.TRANSACTION_ID
			AND C.BEGIN_DATE <= p_END_DATE AND C.END_DATE >= p_BEGIN_DATE
		ORDER BY A.ATTRIBUTE_NAME, B.ATTRIBUTE_VAL;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END ENTITY_ATTRIBUTES;
---------------------------------------------------------------------------------------------------
PROCEDURE POSITION_ROLLUPS
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names and IDs of Rollups linked to INTERCHANGE_TRANSACTIONS that lie in the given date range

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT DISTINCT C.ROLLUP_1, C.ROLLUP_ID_1,
			C.ROLLUP_2, C.ROLLUP_ID_2,
			C.ROLLUP_3, C.ROLLUP_ID_3,
			C.ROLLUP_4, C.ROLLUP_ID_4
		FROM INTERCHANGE_TRANSACTION A,
			SERVICE_POINT B,
			RTO_ROLLUP_HIERARCHY C
		WHERE A.POD_ID = B.SERVICE_POINT_ID
			AND B.ROLLUP_ID = C.ROLLUP_ID_1
		ORDER BY 1, 3, 5, 7;

	EXCEPTION
	    WHEN OTHERS THEN
		    p_STATUS := SQLCODE;

END POSITION_ROLLUPS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_TRANSACTION_POD
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER
	) AS

BEGIN

	UPDATE INTERCHANGE_TRANSACTION SET
		POD_ID = p_SERVICE_POINT_ID,
		ENTRY_DATE = SYSDATE
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

END PUT_TRANSACTION_POD;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_TRANSACTION_POR
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER
	) AS

BEGIN

	UPDATE INTERCHANGE_TRANSACTION SET
		POR_ID = p_SERVICE_POINT_ID,
		ENTRY_DATE = SYSDATE
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

END PUT_TRANSACTION_POR;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_TRANSACTION_PURCHASER
	(
	p_TRANSACTION_ID IN NUMBER,
	p_PSE_ID IN NUMBER
	) AS

BEGIN

	UPDATE INTERCHANGE_TRANSACTION SET
		PURCHASER_ID = p_PSE_ID,
		ENTRY_DATE = SYSDATE
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

END PUT_TRANSACTION_PURCHASER;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_TRANSACTION_SELLER
	(
	p_TRANSACTION_ID IN NUMBER,
	p_PSE_ID IN NUMBER
	) AS

BEGIN

	UPDATE INTERCHANGE_TRANSACTION SET
		SELLER_ID = p_PSE_ID,
		ENTRY_DATE = SYSDATE
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

END PUT_TRANSACTION_SELLER;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_IT_STATUS
	(
	p_TRANSACTION_ID IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_TRANSACTION_STATUS_NAME OUT VARCHAR,
	p_TRANSACTION_IS_ACTIVE OUT NUMBER,
	p_STATUS OUT NUMBER
	) AS

v_AS_OF_DATE DATE := LOW_DATE;

BEGIN
	p_STATUS := GA.SUCCESS;

	IF GA.VERSION_SCHEDULE THEN
		BEGIN
			SELECT MAX(AS_OF_DATE)
			INTO v_AS_OF_DATE
			FROM IT_STATUS
			WHERE TRANSACTION_ID = p_TRANSACTION_ID
				AND AS_OF_DATE <= p_AS_OF_DATE;

			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					v_AS_OF_DATE := p_AS_OF_DATE;
				WHEN OTHERS THEN
					RAISE;
		END;
	END IF;

	SELECT TRANSACTION_STATUS_NAME, TRANSACTION_IS_ACTIVE
		INTO p_TRANSACTION_STATUS_NAME, p_TRANSACTION_IS_ACTIVE
	FROM IT_STATUS
	WHERE TRANSACTION_ID = p_TRANSACTION_ID
		AND AS_OF_DATE = v_AS_OF_DATE;

	EXCEPTION
		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END GET_IT_STATUS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_IT_STATUS
	(
	p_TRANSACTION_ID IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_TRANSACTION_STATUS_NAME IN VARCHAR,
	p_TRANSACTION_IS_ACTIVE IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

v_AS_OF_DATE DATE;

BEGIN
	p_STATUS := GA.SUCCESS;

	IF GA.VERSION_SCHEDULE THEN
		v_AS_OF_DATE := CORRECTED_AS_OF_DATE(p_AS_OF_DATE);
	ELSE
		v_AS_OF_DATE := LOW_DATE;
	END IF;

	UPDATE IT_STATUS
	SET TRANSACTION_STATUS_NAME = p_TRANSACTION_STATUS_NAME,
		TRANSACTION_IS_ACTIVE = p_TRANSACTION_IS_ACTIVE
	WHERE TRANSACTION_ID = p_TRANSACTION_ID
		AND AS_OF_DATE = v_AS_OF_DATE;

	IF SQL%NOTFOUND THEN
		INSERT INTO IT_STATUS (
			TRANSACTION_ID,
			AS_OF_DATE,
			TRANSACTION_STATUS_NAME,
			TRANSACTION_IS_ACTIVE)
		VALUES (
			p_TRANSACTION_ID,
			v_AS_OF_DATE,
			p_TRANSACTION_STATUS_NAME,
			p_TRANSACTION_IS_ACTIVE);
	END IF;

	EXCEPTION
		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END PUT_IT_STATUS;
----------------------------------------------------------------------------------------------------
PROCEDURE IT_STATUS_LIST
	(
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT TRANSACTION_STATUS_NAME, TRANSACTION_IS_ACTIVE
        FROM INTERCHANGE_TRANSACTION_STATUS
        ORDER BY TRANSACTION_STATUS_NAME;
END IT_STATUS_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE IT_STATUS_NAME_LIST
	(
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT TRANSACTION_STATUS_NAME FROM INTERCHANGE_TRANSACTION_STATUS ORDER BY TRANSACTION_STATUS_NAME;
END IT_STATUS_NAME_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE COMPARE_TRANSACTION_STATE
	(
	p_TRANSACTION_ID IN NUMBER,
    p_SCHEDULE_TYPE1 IN NUMBER,
    p_SCHEDULE_STATE1 IN NUMBER,
    p_SCHEDULE_TYPE2 IN NUMBER,
    p_SCHEDULE_STATE2 IN NUMBER,
	p_CONTRACT_NAME IN VARCHAR,
	p_CONTRACT_NUMBER IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_ALPHA_SCHEDULE_STATE NUMBER;
v_BETA_SCHEDULE_STATE NUMBER;
v_ALPHA_SCHEDULE_TYPE NUMBER;
v_BETA_SCHEDULE_TYPE NUMBER;
v_INTERVAL VARCHAR2(16);

-- COMPARISON MODE:
-- 1 - Forecast-Preliminary
-- 2 - Forecast-Final
-- 3 - Preliminary-Final
-- 4 - Forecast-External
-- 5 - Preliminary-External
-- 6 - Final-External

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

--	GET_STATE_AND_TYPE_FROM_MODE(p_COMPARISON_MODE, v_ALPHA_SCHEDULE_STATE, v_BETA_SCHEDULE_STATE, v_ALPHA_SCHEDULE_TYPE, v_BETA_SCHEDULE_TYPE);
	v_ALPHA_SCHEDULE_TYPE := p_SCHEDULE_TYPE1;
    v_ALPHA_SCHEDULE_STATE := p_SCHEDULE_STATE1;
	v_BETA_SCHEDULE_TYPE := p_SCHEDULE_TYPE2;
    v_BETA_SCHEDULE_STATE := p_SCHEDULE_STATE2;

	SELECT DECODE(UPPER(SUBSTR(TRANSACTION_INTERVAL,1,2)),'5 ','MI5','10','MI5','15','MI5','20','MI5','30','MI5','HO','HH','DA','DD','WE','DD','MO','DD','QU','DD','YE','DD')
	INTO v_INTERVAL
	FROM INTERCHANGE_TRANSACTION
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

	IF GA.VERSION_SCHEDULE THEN
		OPEN p_CURSOR FOR
			SELECT DISTINCT SUBSTR(FROM_CUT_AS_HED(C.SCHEDULE_DATE, p_TIME_ZONE, v_INTERVAL),1,10)  "Date",
				SUBSTR(FROM_CUT_AS_HED(C.SCHEDULE_DATE, p_TIME_ZONE, v_INTERVAL),12) "Time",
				D.AMOUNT "Alpha",
				E.AMOUNT "Beta",
				NVL(D.AMOUNT,0) - NVL(E.AMOUNT,0) "Difference",
				ROUND(DECODE(NVL(D.AMOUNT,0),0,NULL,(NVL(D.AMOUNT,0)-NVL(E.AMOUNT,0))*100/D.AMOUNT),16) "Difference_Pct"
			FROM INTERCHANGE_TRANSACTION A, TP_CONTRACT_NUMBER B, IT_SCHEDULE C, IT_SCHEDULE D, IT_SCHEDULE E
			WHERE A.TRANSACTION_ID = p_TRANSACTION_ID
				AND B.CONTRACT_ID(+) = A.CONTRACT_ID
				AND B.CONTRACT_NAME(+) = p_CONTRACT_NAME
				AND B.CONTRACT_NUMBER(+) = p_CONTRACT_NUMBER
				AND B.BEGIN_DATE(+) <= TRUNC(p_END_DATE)
				AND NVL(B.END_DATE(+), HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
				AND C.TRANSACTION_ID = A.TRANSACTION_ID
				AND C.SCHEDULE_TYPE  IN (v_ALPHA_SCHEDULE_TYPE, v_BETA_SCHEDULE_TYPE)
				AND C.SCHEDULE_STATE IN (v_ALPHA_SCHEDULE_STATE, v_BETA_SCHEDULE_STATE)
				AND C.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND CUT_DATE_BETWEEN(C.SCHEDULE_DATE, B.BEGIN_DATE, B.END_DATE, p_TIME_ZONE) = 'Y'
				AND C.AS_OF_DATE = SCHEDULE_AS_OF_DATE(C.TRANSACTION_ID, C.SCHEDULE_TYPE, C.SCHEDULE_STATE, C.SCHEDULE_DATE, p_AS_OF_DATE)
				AND D.TRANSACTION_ID(+) = C.TRANSACTION_ID
				AND D.SCHEDULE_TYPE(+) = v_ALPHA_SCHEDULE_TYPE
				AND D.SCHEDULE_STATE(+) = v_ALPHA_SCHEDULE_STATE
				AND D.SCHEDULE_DATE(+) = C.SCHEDULE_DATE
				AND D.AS_OF_DATE(+) = SCHEDULE_AS_OF_DATE(C.TRANSACTION_ID, v_ALPHA_SCHEDULE_TYPE, v_ALPHA_SCHEDULE_STATE, C.SCHEDULE_DATE, p_AS_OF_DATE)
				AND E.TRANSACTION_ID(+) = C.TRANSACTION_ID
				AND E.SCHEDULE_TYPE(+) = v_BETA_SCHEDULE_TYPE
				AND E.SCHEDULE_STATE(+) = v_BETA_SCHEDULE_STATE
				AND E.SCHEDULE_DATE(+) = C.SCHEDULE_DATE
				AND E.AS_OF_DATE(+) = SCHEDULE_AS_OF_DATE(C.TRANSACTION_ID, v_BETA_SCHEDULE_TYPE, v_BETA_SCHEDULE_STATE, C.SCHEDULE_DATE, p_AS_OF_DATE)
			ORDER BY 1, 2;
	ELSE
		OPEN p_CURSOR FOR
			SELECT DISTINCT SUBSTR(FROM_CUT_AS_HED(C.SCHEDULE_DATE, p_TIME_ZONE, v_INTERVAL),1,10)  "Date",
				SUBSTR(FROM_CUT_AS_HED(C.SCHEDULE_DATE, p_TIME_ZONE, v_INTERVAL),12) "Time",
				D.AMOUNT "Alpha",
				E.AMOUNT "Beta",
				NVL(D.AMOUNT,0) - NVL(E.AMOUNT,0) "Difference",
				ROUND(DECODE(NVL(D.AMOUNT,0),0,NULL,(NVL(D.AMOUNT,0)-NVL(E.AMOUNT,0))*100/D.AMOUNT),16) "Difference_Pct"
			FROM INTERCHANGE_TRANSACTION A, TP_CONTRACT_NUMBER B, IT_SCHEDULE C, IT_SCHEDULE D, IT_SCHEDULE E
			WHERE A.TRANSACTION_ID = p_TRANSACTION_ID
				AND B.CONTRACT_ID(+) = A.CONTRACT_ID
				AND B.CONTRACT_NAME(+) = p_CONTRACT_NAME
				AND B.CONTRACT_NUMBER(+) = p_CONTRACT_NUMBER
				AND B.BEGIN_DATE(+) <= TRUNC(p_END_DATE)
				AND NVL(B.END_DATE(+), HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
				AND C.TRANSACTION_ID = A.TRANSACTION_ID
				AND C.SCHEDULE_TYPE IN (v_ALPHA_SCHEDULE_TYPE, v_BETA_SCHEDULE_TYPE)
				AND C.SCHEDULE_STATE IN (v_ALPHA_SCHEDULE_STATE, v_BETA_SCHEDULE_STATE)
				AND C.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND CUT_DATE_BETWEEN(C.SCHEDULE_DATE, B.BEGIN_DATE, B.END_DATE, p_TIME_ZONE) = 'Y'
				AND C.AS_OF_DATE = LOW_DATE
				AND D.TRANSACTION_ID(+) = C.TRANSACTION_ID
				AND D.SCHEDULE_TYPE(+) = v_ALPHA_SCHEDULE_TYPE
				AND D.SCHEDULE_STATE(+) = v_ALPHA_SCHEDULE_STATE
				AND D.SCHEDULE_DATE(+) = C.SCHEDULE_DATE
				AND D.AS_OF_DATE(+) = C.AS_OF_DATE
				AND E.TRANSACTION_ID(+) = C.TRANSACTION_ID
				AND E.SCHEDULE_TYPE(+) = v_BETA_SCHEDULE_TYPE
				AND E.SCHEDULE_STATE(+) = v_BETA_SCHEDULE_STATE
				AND E.SCHEDULE_DATE(+) = C.SCHEDULE_DATE
				AND E.AS_OF_DATE(+) = C.AS_OF_DATE
			ORDER BY 1, 2;
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END COMPARE_TRANSACTION_STATE;
----------------------------------------------------------------------------------------------------
PROCEDURE TRANSACTION_ID_FOR_CONTRACT
	(
	p_CONTRACTS IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_CONTRACTS GA.STRING_TABLE;
v_WORK_ID NUMBER;
v_INDEX BINARY_INTEGER;

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	UT.TOKENS_FROM_STRING(p_CONTRACTS, ',', v_CONTRACTS);
	UT.GET_RTO_WORK_ID(v_WORK_ID);

	FOR v_INDEX IN v_CONTRACTS.FIRST..v_CONTRACTS.LAST LOOP
		IF v_CONTRACTS.EXISTS(v_INDEX) THEN
			UT.POST_RTO_WORK(v_WORK_ID, v_INDEX, UPPER(v_CONTRACTS(v_INDEX)));
		END IF;
	END LOOP;

	OPEN p_CURSOR FOR
		SELECT DISTINCT A.CONTRACT_NUMBER, C.TRANSACTION_ID
		FROM TP_CONTRACT_NUMBER A,
			INTERCHANGE_CONTRACT B,
			INTERCHANGE_TRANSACTION C
		WHERE UPPER(A.CONTRACT_NUMBER) IN (SELECT WORK_DATA FROM RTO_WORK WHERE WORK_ID = v_WORK_ID)
			AND B.CONTRACT_ID = A.CONTRACT_ID
			AND C.CONTRACT_ID = B.CONTRACT_ID;

	UT.PURGE_RTO_WORK(v_WORK_ID);

EXCEPTION
	WHEN INSUFFICIENT_PRIVILEGES THEN
		p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	WHEN OTHERS THEN
		UT.PURGE_RTO_WORK(v_WORK_ID);
		p_STATUS := SQLCODE;

END TRANSACTION_ID_FOR_CONTRACT;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SUB_STATION_TREE
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	-- JBH 05/12/05 - Always show tree hierarchy regardless of whether
	-- meter values exist or not
	OPEN p_CURSOR FOR
		SELECT DISTINCT SERVICE_POINT_NAME, A.SERVICE_POINT_ID,
			SUB_STATION_NAME, B.SUB_STATION_ID,
			METER_NAME, C.METER_ID
		FROM SERVICE_POINT A,
			TX_SUB_STATION B,
			TX_SUB_STATION_METER C
--			TX_SUB_STATION_METER_VALUE D
		WHERE A.SERVICE_POINT_ID = B.SERVICE_POINT_ID
			AND C.SUB_STATION_ID = B.SUB_STATION_ID
--			AND D.METER_ID = C.METER_ID
--			AND D.METER_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE+1-1/86400
		ORDER BY 1, 2, 3, 4, 5, 6;

EXCEPTION
	WHEN INSUFFICIENT_PRIVILEGES THEN
		p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END GET_SUB_STATION_TREE;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SUB_STATION_VALUES
	(
	p_ENTITY_ID IN NUMBER,
	p_LEVEL IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_INTERVAL IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_INTERVAL VARCHAR2(16);
v_BEGIN_DATE DATE;
v_END_DATE DATE;
BEGIN
	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    IF p_ENTITY_ID IS NULL THEN
		NULL_CURSOR(p_CURSOR);
		RETURN;
	END IF;

	p_STATUS := GA.SUCCESS;

	v_INTERVAL := UPPER(p_INTERVAL);
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	IF v_INTERVAL = 'HOUR' OR SUBSTR(v_INTERVAL,1,6) = 'MINUTE' THEN
		v_INTERVAL := '?';
	ELSIF v_INTERVAL = 'DAY' THEN
		v_INTERVAL := 'DD';
	ELSIF v_INTERVAL = 'WEEK' THEN
		v_INTERVAL := 'DY';
	ELSIF v_INTERVAL = 'QUARTER' THEN
		v_INTERVAL := 'Q';
	-- else leave interval as it is
	END IF;

	-- SUBSTATIONS By Service Point
    IF p_LEVEL = 1 THEN
		OPEN p_CURSOR FOR
			SELECT DECODE(v_INTERVAL,'?',
					FROM_CUT_AS_HED(METER_DATE, p_TIME_ZONE),
					TO_CHAR(TRUNC(FROM_CUT(METER_DATE-1/86400,p_TIME_ZONE),v_INTERVAL),'YYYY-MM-DD      ')) "DATE",
				SUB_STATION_NAME "ENTITY_NAME", A.SUB_STATION_ID "ENTITY_ID",
				SUM(DECODE(OPERATION_CODE,'S',-1,1)*METER_VAL) "AMOUNT"
			FROM TX_SUB_STATION A,
				TX_SUB_STATION_METER B,
				TX_SUB_STATION_METER_VALUE C
			WHERE A.SERVICE_POINT_ID = p_ENTITY_ID
				AND B.SUB_STATION_ID = A.SUB_STATION_ID
				AND C.METER_ID = B.METER_ID
				AND C.METER_CODE = DECODE(p_SCHEDULE_TYPE,1,'F',2,'P',3,'A','X')
				AND C.METER_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND C.AS_OF_DATE = (SELECT MAX(X.AS_OF_DATE)
							  FROM TX_SUB_STATION_METER_VALUE X
							  WHERE X.METER_ID = C.METER_ID
								AND X.METER_UNIT = C.METER_UNIT
								AND X.METER_CODE = C.METER_CODE
								AND X.METER_DATE = C.METER_DATE
								AND X.AS_OF_DATE <= p_AS_OF_DATE)
			GROUP BY DECODE(v_INTERVAL,'?',FROM_CUT_AS_HED(METER_DATE,p_TIME_ZONE),TO_CHAR(TRUNC(FROM_CUT(METER_DATE-1/86400,p_TIME_ZONE),v_INTERVAL),'YYYY-MM-DD      ')),
                SUB_STATION_NAME, A.SUB_STATION_ID
			ORDER BY 3, 1, 2;
	-- SUBSTATION METERS By Substaion
    ELSIF p_LEVEL = 2 THEN
        OPEN p_CURSOR FOR
            SELECT DECODE(v_INTERVAL,'?',
					FROM_CUT_AS_HED(METER_DATE, p_TIME_ZONE),
					TO_CHAR(TRUNC(FROM_CUT(METER_DATE-1/86400,p_TIME_ZONE),v_INTERVAL),'YYYY-MM-DD      ')) "DATE",
                METER_NAME "ENTITY_NAME", A.METER_ID "ENTITY_ID",
                DECODE(OPERATION_CODE,'A','Add','S','Subtract')OPERATION_CODE,
                SUM(METER_VAL) "AMOUNT"
            FROM TX_SUB_STATION_METER A,
                TX_SUB_STATION_METER_VALUE B
            WHERE A.SUB_STATION_ID = p_ENTITY_ID
				AND B.METER_ID = A.METER_ID
				AND B.METER_CODE = DECODE(p_SCHEDULE_TYPE,1,'F',2,'P',3,'A','X')
				AND B.METER_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND B.AS_OF_DATE = (SELECT MAX(X.AS_OF_DATE)
							  FROM TX_SUB_STATION_METER_VALUE X
							  WHERE X.METER_ID = B.METER_ID
								AND X.METER_UNIT = B.METER_UNIT
								AND X.METER_CODE = B.METER_CODE
								AND X.METER_DATE = B.METER_DATE
								AND X.AS_OF_DATE <= p_AS_OF_DATE)
            GROUP BY DECODE(v_INTERVAL,'?',FROM_CUT_AS_HED(METER_DATE,p_TIME_ZONE),TO_CHAR(TRUNC(FROM_CUT(METER_DATE-1/86400,p_TIME_ZONE),v_INTERVAL),'YYYY-MM-DD      ')),
                METER_NAME, A.METER_ID, OPERATION_CODE
            ORDER BY 3, 1, 2;
	-- SUBSTATION METER By MeterId
    ELSE
		OPEN p_CURSOR FOR
			SELECT DECODE(v_INTERVAL,'?',
					FROM_CUT_AS_HED(METER_DATE, p_TIME_ZONE),
					TO_CHAR(TRUNC(FROM_CUT(METER_DATE-1/86400,p_TIME_ZONE),v_INTERVAL),'YYYY-MM-DD      ')) "DATE",
                METER_NAME "ENTITY_NAME", A.METER_ID "ENTITY_ID",
				SUM(DECODE(OPERATION_CODE,'S',-1,1)*METER_VAL) "AMOUNT"
			FROM TX_SUB_STATION_METER A,
				TX_SUB_STATION_METER_VALUE B
			WHERE A.METER_ID = p_ENTITY_ID
				AND B.METER_ID = A.METER_ID
				AND B.METER_CODE = DECODE(p_SCHEDULE_TYPE,1,'F',2,'P',3,'A','X')
				AND B.METER_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND B.AS_OF_DATE = (SELECT MAX(X.AS_OF_DATE)
							  FROM TX_SUB_STATION_METER_VALUE X
							  WHERE X.METER_ID = B.METER_ID
								AND X.METER_UNIT = B.METER_UNIT
								AND X.METER_CODE = B.METER_CODE
								AND X.METER_DATE = B.METER_DATE
								AND X.AS_OF_DATE <= p_AS_OF_DATE)
			GROUP BY DECODE(v_INTERVAL,'?',FROM_CUT_AS_HED(METER_DATE,p_TIME_ZONE),TO_CHAR(TRUNC(FROM_CUT(METER_DATE-1/86400,p_TIME_ZONE),v_INTERVAL),'YYYY-MM-DD      ')),
                METER_NAME, A.METER_ID
			ORDER BY 3, 1, 2;
	END IF;

EXCEPTION
	WHEN INSUFFICIENT_PRIVILEGES THEN
		p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END GET_SUB_STATION_VALUES;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_SUB_STATION_VALUE
	(
	p_ENTITY_ID IN NUMBER,
	p_AMOUNT IN NUMBER,
	p_DATE IN DATE,
    p_SCHEDULE_TYPE IN NUMBER,
    p_AS_OF_DATE IN DATE,
    p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

    v_DATE_STRING VARCHAR(64);
    v_METER_CODE CHAR(1);
    v_METER_UNIT CHAR(1);
    v_AMOUNT NUMBER(9);
    v_SUB_STATION_DATE DATE;
    v_AS_OF_DATE DATE;
BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
	   RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    p_STATUS := GA.SUCCESS;

-- Since this Sub_Station_Meter_Value may be the aggregate of multiple Meter Codes,
-- just use the meter code that corresponds to the sign of the value.

    IF GA.VERSION_SCHEDULE THEN
		v_AS_OF_DATE := CORRECTED_AS_OF_DATE(p_AS_OF_DATE);
	ELSE
		v_AS_OF_DATE := LOW_DATE;
	END IF;

    v_AMOUNT := ABS(p_AMOUNT);

    v_DATE_STRING := TO_CHAR(P_DATE, 'MM-DD-YYYY HH24:MI:SS');

    v_SUB_STATION_DATE := TO_CUT(P_DATE, P_TIME_ZONE);

    v_DATE_STRING := TO_CHAR(v_SUB_STATION_DATE, 'MM-DD-YYYY HH24:MI:SS');

-- Get the first Meter Unit.

    BEGIN
        SELECT MAX(METER_UNIT) into V_METER_UNIT
        FROM TX_SUB_STATION_METER_VALUE
        WHERE METER_ID = P_ENTITY_ID
        AND METER_DATE = v_SUB_STATION_DATE
        GROUP BY METER_ID;
    EXCEPTION
		WHEN OTHERS THEN
        V_METER_UNIT := '?';
    END;

-- Delete existing records,

	Delete from tx_sub_station_meter_value
    where METER_ID = P_ENTITY_ID
    AND METER_DATE = v_SUB_STATION_DATE;

-- Insert new record
    insert into tx_sub_station_meter_value
      (meter_id, meter_unit, meter_code, meter_date, as_of_date, meter_val)
    values
      (P_ENTITY_ID, V_METER_UNIT, DECODE(p_SCHEDULE_TYPE,1,'F',2,'P',3,'A','X'), v_SUB_STATION_DATE, v_AS_OF_DATE, V_AMOUNT);

	EXCEPTION
		WHEN INSUFFICIENT_PRIVILEGES THEN
			p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END PUT_SUB_STATION_VALUE;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SUB_STATION_DATA
	(
	p_ENTITY_ID IN NUMBER,
	p_LEVEL IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_INTERVAL IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_INTERVAL VARCHAR2(16);
v_BEGIN_DATE DATE;
v_END_DATE DATE;
BEGIN
	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	v_INTERVAL := UPPER(p_INTERVAL);
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	IF v_INTERVAL = 'HOUR' OR SUBSTR(v_INTERVAL,1,6) = 'MINUTE' THEN
		v_INTERVAL := '?';
	ELSIF v_INTERVAL = 'DAY' THEN
		v_INTERVAL := 'DD';
	ELSIF v_INTERVAL = 'WEEK' THEN
		v_INTERVAL := 'DY';
	ELSIF v_INTERVAL = 'QUARTER' THEN
		v_INTERVAL := 'Q';
	-- else leave interval as it is
	END IF;

	IF p_LEVEL = 0 THEN
		OPEN p_CURSOR FOR
			SELECT DECODE(v_INTERVAL,'?',
					FROM_CUT_AS_HED(METER_DATE, p_TIME_ZONE),
					TO_CHAR(TRUNC(FROM_CUT(METER_DATE-1/86400,p_TIME_ZONE),v_INTERVAL),'YYYY-MM-DD      ')) "DATE",
				SERVICE_POINT_NAME "ENTITY_NAME", A.SERVICE_POINT_ID "ENTITY_ID",
				SUM(DECODE(OPERATION_CODE,'S',-1,1)*METER_VAL) "AMOUNT"
			FROM SERVICE_POINT A,
				TX_SUB_STATION B,
				TX_SUB_STATION_METER C,
				TX_SUB_STATION_METER_VALUE D
			WHERE (p_ENTITY_ID = g_ALL OR A.SERVICE_POINT_ID = p_ENTITY_ID)
				AND B.SERVICE_POINT_ID = A.SERVICE_POINT_ID
				AND C.SUB_STATION_ID = B.SUB_STATION_ID
				AND D.METER_ID = C.METER_ID
				AND D.METER_CODE = DECODE(p_SCHEDULE_TYPE,1,'F',2,'P',3,'A','X')
				AND D.METER_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND D.AS_OF_DATE = (SELECT MAX(X.AS_OF_DATE)
							  FROM TX_SUB_STATION_METER_VALUE X
							  WHERE X.METER_ID = D.METER_ID
								AND X.METER_UNIT = D.METER_UNIT
								AND X.METER_CODE = D.METER_CODE
								AND X.METER_DATE = D.METER_DATE
								AND X.AS_OF_DATE <= p_AS_OF_DATE)
			GROUP BY DECODE(v_INTERVAL,'?',FROM_CUT_AS_HED(METER_DATE,p_TIME_ZONE),TO_CHAR(TRUNC(FROM_CUT(METER_DATE-1/86400,p_TIME_ZONE),v_INTERVAL),'YYYY-MM-DD      ')),
				SERVICE_POINT_NAME, A.SERVICE_POINT_ID
			ORDER BY 1, 2;
	ELSIF p_LEVEL = 1 THEN
		OPEN p_CURSOR FOR
			SELECT DECODE(v_INTERVAL,'?',
					FROM_CUT_AS_HED(METER_DATE, p_TIME_ZONE),
					TO_CHAR(TRUNC(FROM_CUT(METER_DATE-1/86400,p_TIME_ZONE),v_INTERVAL),'YYYY-MM-DD      ')) "DATE",
				SUB_STATION_NAME "ENTITY_NAME", A.SUB_STATION_ID "ENTITY_ID",
				SUM(DECODE(OPERATION_CODE,'S',-1,1)*METER_VAL) "AMOUNT"
			FROM TX_SUB_STATION A,
				TX_SUB_STATION_METER B,
				TX_SUB_STATION_METER_VALUE C
			WHERE A.SERVICE_POINT_ID = p_ENTITY_ID
				AND B.SUB_STATION_ID = A.SUB_STATION_ID
				AND C.METER_ID = B.METER_ID
				AND C.METER_CODE = DECODE(p_SCHEDULE_TYPE,1,'F',2,'P',3,'A','X')
				AND C.METER_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND C.AS_OF_DATE = (SELECT MAX(X.AS_OF_DATE)
							  FROM TX_SUB_STATION_METER_VALUE X
							  WHERE X.METER_ID = C.METER_ID
								AND X.METER_UNIT = C.METER_UNIT
								AND X.METER_CODE = C.METER_CODE
								AND X.METER_DATE = C.METER_DATE
								AND X.AS_OF_DATE <= p_AS_OF_DATE)
			GROUP BY DECODE(v_INTERVAL,'?',FROM_CUT_AS_HED(METER_DATE,p_TIME_ZONE),TO_CHAR(TRUNC(FROM_CUT(METER_DATE-1/86400,p_TIME_ZONE),v_INTERVAL),'YYYY-MM-DD      ')),
				SUB_STATION_NAME, A.SUB_STATION_ID
			ORDER BY 1, 2;
	ELSIF p_LEVEL = 2 THEN
		OPEN p_CURSOR FOR
			SELECT DECODE(v_INTERVAL,'?',
					FROM_CUT_AS_HED(METER_DATE, p_TIME_ZONE),
					TO_CHAR(TRUNC(FROM_CUT(METER_DATE-1/86400,p_TIME_ZONE),v_INTERVAL),'YYYY-MM-DD      ')) "DATE",
				METER_NAME "ENTITY_NAME", A.METER_ID "ENTITY_ID",
				OPERATION_CODE,
				SUM(METER_VAL) "AMOUNT"
			FROM TX_SUB_STATION_METER A,
				TX_SUB_STATION_METER_VALUE B
			WHERE A.SUB_STATION_ID = p_ENTITY_ID
				AND B.METER_ID = A.METER_ID
				AND B.METER_CODE = DECODE(p_SCHEDULE_TYPE,1,'F',2,'P',3,'A','X')
				AND B.METER_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND B.AS_OF_DATE = (SELECT MAX(X.AS_OF_DATE)
							  FROM TX_SUB_STATION_METER_VALUE X
							  WHERE X.METER_ID = B.METER_ID
								AND X.METER_UNIT = B.METER_UNIT
								AND X.METER_CODE = B.METER_CODE
								AND X.METER_DATE = B.METER_DATE
								AND X.AS_OF_DATE <= p_AS_OF_DATE)
			GROUP BY DECODE(v_INTERVAL,'?',FROM_CUT_AS_HED(METER_DATE,p_TIME_ZONE),TO_CHAR(TRUNC(FROM_CUT(METER_DATE-1/86400,p_TIME_ZONE),v_INTERVAL),'YYYY-MM-DD      ')),
				METER_NAME, A.METER_ID, OPERATION_CODE
			ORDER BY 1, 2;
	ELSE
		OPEN p_CURSOR FOR
			SELECT DECODE(v_INTERVAL,'?',
					FROM_CUT_AS_HED(METER_DATE, p_TIME_ZONE),
					TO_CHAR(TRUNC(FROM_CUT(METER_DATE-1/86400,p_TIME_ZONE),v_INTERVAL),'YYYY-MM-DD      ')) "DATE",
				METER_NAME "ENTITY_NAME", A.METER_ID "ENTITY_ID",
				SUM(METER_VAL) "AMOUNT"
			FROM TX_SUB_STATION_METER A,
				TX_SUB_STATION_METER_VALUE B
			WHERE A.METER_ID = p_ENTITY_ID
				AND B.METER_ID = A.METER_ID
				AND B.METER_CODE = DECODE(p_SCHEDULE_TYPE,1,'F',2,'P',3,'A','X')
				AND B.METER_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND B.AS_OF_DATE = (SELECT MAX(X.AS_OF_DATE)
							  FROM TX_SUB_STATION_METER_VALUE X
							  WHERE X.METER_ID = B.METER_ID
								AND X.METER_UNIT = B.METER_UNIT
								AND X.METER_CODE = B.METER_CODE
								AND X.METER_DATE = B.METER_DATE
								AND X.AS_OF_DATE <= p_AS_OF_DATE)
			GROUP BY DECODE(v_INTERVAL,'?',FROM_CUT_AS_HED(METER_DATE,p_TIME_ZONE),TO_CHAR(TRUNC(FROM_CUT(METER_DATE-1/86400,p_TIME_ZONE),v_INTERVAL),'YYYY-MM-DD      ')),
				METER_NAME, A.METER_ID
			ORDER BY 1, 2;
	END IF;

EXCEPTION
	WHEN INSUFFICIENT_PRIVILEGES THEN
		p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END GET_SUB_STATION_DATA;
----------------------------------------------------------------------------------------------------
PROCEDURE ACCEPT_SERVICE_POINT_SCHEDULE
	(
	p_SERVICE_POINT_ID IN NUMBER,
	p_TRANSACTION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_INTERVAL IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_SRC_AS_OF_DATE IN DATE,
	p_TRG_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS
v_CURSOR GA.REFCURSOR;
v_DATE VARCHAR(32);
v_ENTITY_NAME VARCHAR2(32);
v_ENTITY_ID NUMBER(9);
v_AMOUNT NUMBER;
BEGIN
	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	GET_SUB_STATION_DATA (p_SERVICE_POINT_ID, 0, p_BEGIN_DATE, p_END_DATE, p_SCHEDULE_TYPE,
				    p_INTERVAL, p_TIME_ZONE, p_SRC_AS_OF_DATE, p_STATUS, v_CURSOR);
	UPDATE INTERCHANGE_TRANSACTION SET BEGIN_DATE = p_BEGIN_DATE WHERE TRANSACTION_ID = p_TRANSACTION_ID AND BEGIN_DATE > p_BEGIN_DATE;
	UPDATE INTERCHANGE_TRANSACTION SET END_DATE = p_END_DATE WHERE TRANSACTION_ID = p_TRANSACTION_ID AND END_DATE < p_END_DATE;
	IF p_STATUS >= 0 THEN
		LOOP
			FETCH v_CURSOR INTO v_DATE, v_ENTITY_NAME, v_ENTITY_ID, v_AMOUNT;
			EXIT WHEN v_CURSOR%NOTFOUND;
			SCHEDULE_UPDATE(p_TRANSACTION_ID, p_SCHEDULE_TYPE, g_INTERNAL_STATE,
					    LTRIM(RTRIM(SUBSTR(v_DATE,1,11))), LTRIM(RTRIM(SUBSTR(v_DATE,12))),
					    p_TRG_AS_OF_DATE, p_TIME_ZONE, v_AMOUNT/1000, NULL, p_STATUS); -- Amount is in KWH, needs to be MWH, so divide by 1000
			IF p_STATUS < 0 THEN
				ROLLBACK;
				EXIT;
			END IF;
		END LOOP;
	END IF;
	CLOSE v_CURSOR;

EXCEPTION
	WHEN INSUFFICIENT_PRIVILEGES THEN
		p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END ACCEPT_SERVICE_POINT_SCHEDULE;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_DEFAULT_SP_TRANSACTION
	(
	p_SERVICE_POINT_ID IN NUMBER,
	p_INTERVAL IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_TRANSACTION_NAME OUT VARCHAR2,
	p_TRANSACTION_ID OUT NUMBER
	) AS
-- return default transaction for this service point for accepting sub-station meters as schedules
-- default meaning if there is only one such schedule, then use it
BEGIN
	IF NOT CAN_READ(g_MODULE_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	SELECT TRANSACTION_NAME, TRANSACTION_ID
	INTO p_TRANSACTION_NAME, p_TRANSACTION_ID
	FROM INTERCHANGE_TRANSACTION
	WHERE POD_ID = p_SERVICE_POINT_ID
		AND TRANSACTION_INTERVAL = p_INTERVAL
		AND UPPER(TRANSACTION_TYPE) LIKE '%LOAD%';

EXCEPTION
	WHEN INSUFFICIENT_PRIVILEGES THEN
		p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END GET_DEFAULT_SP_TRANSACTION;
----------------------------------------------------------------------------------------------------
PROCEDURE IMPORT_SUB_STATIONS
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SRC_AS_OF_DATE IN DATE,
	p_TRG_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	XS.IMPORT_SUB_STATIONS (p_BEGIN_DATE, p_END_DATE, p_SCHEDULE_TYPE, p_SRC_AS_OF_DATE, p_TRG_AS_OF_DATE, p_STATUS);

END IMPORT_SUB_STATIONS;
----------------------------------------------------------------------------------------------------
/*
PROCEDURE CLEAN_BALANCE_TRANS_SCHEDULES
	(
	p_ROWS_REMOVED OUT NUMBER
	) AS
BEGIN
	-- Cleanup by deleting rows from BALANCE_TRANSACTION_SCHEDULES that have no corresponding
	-- association in the BALANCE_TRANSACTION table
	DELETE FROM BALANCE_TRANSACTION_SCHEDULE A
	WHERE 0 = (SELECT COUNT(*) FROM BALANCE_TRANSACTION B
				WHERE B.TRANSACTION_ID = A.TRANSACTION_ID
					AND B.BALANCE_TRANSACTION_ID = A.BALANCE_TRANSACTION_ID
					AND A.SCHEDULE_DATE BETWEEN B.BEGIN_DATE AND NVL(B.END_DATE,HIGH_DATE));
	p_ROWS_REMOVED := SQL%ROWCOUNT;

EXCEPTION
	WHEN OTHERS THEN
		ROLLBACK;
		p_ROWS_REMOVED := SQLCODE;
		IF p_ROWS_REMOVED > 0 THEN
			p_ROWS_REMOVED := -p_ROWS_REMOVED;
		END IF;

END CLEAN_BALANCE_TRANS_SCHEDULES;
----------------------------------------------------------------------------------------------------
FUNCTION GET_BALANCE_DONT_USE_TERMS
	(
	p_TRANSACTION_ID IN NUMBER
	)
	RETURN NUMBER IS
	v_IS_DISPATCHABLE NUMBER(1);
BEGIN
	--RETURN NVL(TO_NUMBER(MODEL_VALUE_AT_KEY(1,'Scheduling','Load Balancing','DontUseTermLimits',0)),0);
	SELECT NVL(IS_DISPATCHABLE, 0)
	INTO v_IS_DISPATCHABLE
	FROM INTERCHANGE_TRANSACTION
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

	RETURN v_IS_DISPATCHABLE;
EXCEPTION
	WHEN OTHERS THEN
    	RETURN 0;
END GET_BALANCE_DONT_USE_TERMS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_BALANCE_TRANS_HEADERS
	(
	p_BALANCE_TRANSACTION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
--v_NO_TERMS NUMBER;
BEGIN
	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

--    v_NO_TERMS := GET_BALANCE_DONT_USE_TERMS();

--     IF v_NO_TERMS = 0 THEN
--     	OPEN p_CURSOR FOR
--     		SELECT B.TRANSACTION_NAME,
--     			B.TRANSACTION_ID,
-- 				B.IS_DISPATCHABLE
--     		FROM BALANCE_TRANSACTION A,
--     			INTERCHANGE_TRANSACTION B,
-- 				INTERCHANGE_TRANSACTION_LIMIT C
--     		WHERE A.BALANCE_TRANSACTION_ID = p_BALANCE_TRANSACTION_ID
--     			AND A.BEGIN_DATE <= p_END_DATE
--     			AND NVL(A.END_DATE,HIGH_DATE) >= p_BEGIN_DATE
--     			AND B.TRANSACTION_ID = A.TRANSACTION_ID
--     			AND B.BEGIN_DATE <= p_END_DATE
--     			AND NVL(B.END_DATE,HIGH_DATE) >= p_BEGIN_DATE
-- 				AND C.TRANSACTION_ID = B.TRANSACTION_ID
-- 				AND C.BEGIN_DATE <= p_END_DATE
-- 				AND NVL(C.END_DATE, HIGH_DATE) >= p_BEGIN_DATE
--      			AND DECODE(UPPER(SUBSTR(C.LIMIT_INTERVAL,1,2)),'HO',1,'DA',2,'WE',3,'MO',4,'QU',5,'YE',6,0) >=
--      				DECODE(UPPER(SUBSTR(B.TRANSACTION_INTERVAL,1,2)),'HO',1,'DA',2,'WE',3,'MO',4,'QU',5,'YE',6,0)
--     		ORDER BY B.TRANSACTION_NAME;
--     ELSE
    	OPEN p_CURSOR FOR
    		SELECT B.TRANSACTION_NAME,
    			B.TRANSACTION_ID,
				DECODE(NVL(B.IS_DISPATCHABLE, 0),0,1,0) "USE_TERMS"
    		FROM BALANCE_TRANSACTION A,
    			INTERCHANGE_TRANSACTION B
    		WHERE A.BALANCE_TRANSACTION_ID = p_BALANCE_TRANSACTION_ID
    			AND A.BEGIN_DATE <= p_END_DATE
    			AND NVL(A.END_DATE,HIGH_DATE) >= p_BEGIN_DATE
    			AND B.TRANSACTION_ID = A.TRANSACTION_ID
    			AND B.BEGIN_DATE <= p_END_DATE
    			AND NVL(B.END_DATE,HIGH_DATE) >= p_BEGIN_DATE
    		ORDER BY B.TRANSACTION_NAME;
--    END IF;
	p_STATUS := GA.SUCCESS;

EXCEPTION
	WHEN INSUFFICIENT_PRIVILEGES THEN
		p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END GET_BALANCE_TRANS_HEADERS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_BALANCE_SUPPLY_HEADERS
	(
	p_TRANSACTION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;


--    IF v_NO_TERMS = 1 THEN
		OPEN p_CURSOR FOR
			SELECT B.TRANSACTION_NAME,
				B.TRANSACTION_ID,
				DECODE(NVL(C.IS_DISPATCHABLE, 0),0,1,0) "USE_TERMS"
    		FROM BALANCE_TRANSACTION A,
    			INTERCHANGE_TRANSACTION B,
				INTERCHANGE_TRANSACTION C
    		WHERE A.TRANSACTION_ID = p_TRANSACTION_ID
    			AND A.BEGIN_DATE <= p_END_DATE
    			AND NVL(A.END_DATE,HIGH_DATE) >= p_BEGIN_DATE
				AND C.TRANSACTION_ID = A.TRANSACTION_ID
    			AND B.TRANSACTION_ID = A.BALANCE_TRANSACTION_ID
    			AND UPPER(SUBSTR(B.TRANSACTION_TYPE,1,2)) IN ('RE','LO')
    			AND B.BEGIN_DATE <= p_END_DATE
    			AND NVL(B.END_DATE,HIGH_DATE) >= p_BEGIN_DATE
    		ORDER BY B.TRANSACTION_NAME;
--     ELSE
-- 		OPEN p_CURSOR FOR
-- 			SELECT B.TRANSACTION_NAME,
-- 				B.TRANSACTION_ID
--     		FROM BALANCE_TRANSACTION A,
--     			INTERCHANGE_TRANSACTION B,
-- 				INTERCHANGE_TRANSACTION C,
-- 				INTERCHANGE_TRANSACTION_LIMIT D
--     		WHERE A.TRANSACTION_ID = p_TRANSACTION_ID
--     			AND A.BEGIN_DATE <= p_END_DATE
--     			AND NVL(A.END_DATE,HIGH_DATE) >= p_BEGIN_DATE
--     			AND B.TRANSACTION_ID = A.BALANCE_TRANSACTION_ID
--     			AND UPPER(SUBSTR(B.TRANSACTION_TYPE,1,2)) IN ('RE','LO')
--     			AND B.BEGIN_DATE <= p_END_DATE
--     			AND NVL(B.END_DATE,HIGH_DATE) >= p_BEGIN_DATE
--     			AND C.TRANSACTION_ID = A.TRANSACTION_ID
--     			AND C.BEGIN_DATE <= p_END_DATE
--     			AND NVL(C.END_DATE,HIGH_DATE) >= p_BEGIN_DATE
--     			AND D.TRANSACTION_ID = C.TRANSACTION_ID
-- 				AND D.BEGIN_DATE <= p_END_DATE
-- 				AND NVL(D.END_DATE, HIGH_DATE) >= p_BEGIN_DATE
--      			AND DECODE(UPPER(SUBSTR(D.LIMIT_INTERVAL,1,2)),'HO',1,'DA',2,'WE',3,'MO',4,'QU',5,'YE',6,0) >=
--      				DECODE(UPPER(SUBSTR(C.TRANSACTION_INTERVAL,1,2)),'HO',1,'DA',2,'WE',3,'MO',4,'QU',5,'YE',6,0)
-- --    		GROUP BY B.TRANSACTION_NAME, B.TRANSACTION_ID, C.CONTRACT_NAME, C.CONTRACT_ID
-- --    		HAVING SUM(D.TERM_LIMIT) > 0
--     		ORDER BY B.TRANSACTION_NAME;
-- 	END IF;

	p_STATUS := GA.SUCCESS;

EXCEPTION
	WHEN INSUFFICIENT_PRIVILEGES THEN
		p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END GET_BALANCE_SUPPLY_HEADERS;
----------------------------------------------------------------------------------------------------
PROCEDURE FILL_BALANCE_TRANS_DATES (
	p_TRANSACTION_ID IN NUMBER,
	p_TRANSACTION_ID_LIST IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
    p_SCHEDULE_TYPE IN NUMBER,
    p_AS_OF_DATE IN DATE,
	p_WORK_ID OUT NUMBER,
    p_INTERVAL IN VARCHAR2 --p_INTERVAL currently not used.
	) AS
v_TABLE GA.STRING_TABLE;
v_TEMPLATE SCHEDULE_TEMPLATE%ROWTYPE;
v_FILL_TEMPLATE VARCHAR2(14);
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_SINGLE_BEGIN DATE;
v_SINGLE_END DATE;
v_SCHEDULE_BEGIN DATE;
v_SCHEDULE_END DATE;
v_TERM_BEGIN DATE := p_BEGIN_DATE;
v_TERM_END DATE := p_END_DATE;
v_CUT_BEGIN DATE;
v_CUT_END DATE;
v_STATUS NUMBER;
v_SINGLE_BALANCE NUMBER;
v_SUPPLY_ID NUMBER;
v_NO_TERMS NUMBER;
v_INIT_SUCCESS BOOLEAN := TRUE;
v_FORMAT VARCHAR2(16) := '999999999D999';


	---------------------------------

	FUNCTION INITIALIZE RETURN BOOLEAN IS
		v_COUNT_LOAD NUMBER;
		v_COUNT_SUPPLY NUMBER;
		v_SUCCESS BOOLEAN := TRUE;
	BEGIN

		UT.GET_RTO_WORK_ID(p_WORK_ID);

		-- determine if the situation is one balance transaction and many supplies
		-- or one supply and many balance transactions
		SELECT COUNT(*) INTO v_COUNT_LOAD
		FROM BALANCE_TRANSACTION
		WHERE BALANCE_TRANSACTION_ID = p_TRANSACTION_ID;

		SELECT COUNT(*) INTO v_COUNT_SUPPLY
		FROM BALANCE_TRANSACTION
		WHERE TRANSACTION_ID = p_TRANSACTION_ID;

		IF v_COUNT_LOAD > 0 THEN
			v_SINGLE_BALANCE := 1;
		ELSIF v_COUNT_SUPPLY > 0 THEN
			v_SINGLE_BALANCE := 0;
		ELSE
			v_SUCCESS := FALSE;
			RETURN v_SUCCESS;
		END IF;

		BEGIN
			SELECT BEGIN_DATE, END_DATE INTO v_SINGLE_BEGIN, v_SINGLE_END
			FROM INTERCHANGE_TRANSACTION
			WHERE TRANSACTION_ID = p_TRANSACTION_ID;
		EXCEPTION
			WHEN OTHERS THEN
				v_SINGLE_BEGIN := p_BEGIN_DATE;
				v_SINGLE_END := p_END_DATE;
		END;

		RETURN v_SUCCESS;
	END INITIALIZE;

	---------------------------------

	PROCEDURE SET_DATE_RANGES
		(
		p_SUPPLY_TXN_ID IN NUMBER DEFAULT NULL
		) AS
	BEGIN

		v_SCHEDULE_BEGIN := p_BEGIN_DATE;
		v_SCHEDULE_END := p_END_DATE;

		--GET SCHEDULE DATE RANGE
		IF v_SINGLE_BALANCE = 1 THEN
			BEGIN
				SELECT GREATEST(A.BEGIN_DATE,B.BEGIN_DATE), LEAST(NVL(A.END_DATE,HIGH_DATE),NVL(B.END_DATE,HIGH_DATE))
				INTO v_SCHEDULE_BEGIN, v_SCHEDULE_END
				FROM INTERCHANGE_TRANSACTION A,
					BALANCE_TRANSACTION B
				WHERE A.TRANSACTION_ID = p_SUPPLY_TXN_ID
					AND B.TRANSACTION_ID = p_SUPPLY_TXN_ID
					AND B.BALANCE_TRANSACTION_ID = p_TRANSACTION_ID;
			EXCEPTION
				WHEN OTHERS THEN
					NULL;  -- JUST USE DEFAULTS.
			END;
		END IF;

		--GET NARROWEST DATE RANGE.
		v_BEGIN_DATE := GREATEST(p_BEGIN_DATE, v_SINGLE_BEGIN, v_SCHEDULE_BEGIN, v_TERM_BEGIN);
		v_END_DATE := LEAST(p_END_DATE, v_SINGLE_END, v_SCHEDULE_END, NVL(v_TERM_END,HIGH_DATE));
        UT.CUT_DATE_RANGE(v_BEGIN_DATE, v_END_DATE, p_TIME_ZONE, v_CUT_BEGIN, v_CUT_END);

	END SET_DATE_RANGES;

	---------------------------------

	PROCEDURE FILL_NO_TERMS
		(
		p_SUPPLY_TXN_ID IN NUMBER
		) AS

	CURSOR c_SCHEDULES(vID IN NUMBER, vBEGIN IN DATE, vEND IN DATE) IS
		SELECT SCHEDULE_DATE,
	    	AMOUNT,
	        PRICE
		FROM IT_SCHEDULE A
	    WHERE TRANSACTION_ID = vID
	    	AND SCHEDULE_TYPE = p_SCHEDULE_TYPE
	        AND SCHEDULE_STATE = g_INTERNAL_STATE
	        AND SCHEDULE_DATE BETWEEN vBEGIN AND vEND
	        AND AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
	        					FROM IT_SCHEDULE
	                            WHERE TRANSACTION_ID = A.TRANSACTION_ID
	                            	AND SCHEDULE_TYPE = A.SCHEDULE_TYPE
	                                AND SCHEDULE_STATE = A.SCHEDULE_STATE
	                                AND SCHEDULE_DATE = A.SCHEDULE_DATE
	                                AND AS_OF_DATE <= p_AS_OF_DATE);
	BEGIN

		SET_DATE_RANGES();

		--Schedule Amount is the Limit, 0 is the Min
		FOR v_SCHEDULE IN c_SCHEDULES(p_SUPPLY_TXN_ID, v_CUT_BEGIN, v_CUT_END) LOOP
			UT.POST_RTO_WORK(p_WORK_ID, 0, p_SUPPLY_TXN_ID, v_SCHEDULE.SCHEDULE_DATE,
				SUBSTR(TO_CHAR(NVL(v_SCHEDULE.AMOUNT,0),v_FORMAT),1,14)||
				SUBSTR(TO_CHAR(NVL(v_SCHEDULE.PRICE,0),v_FORMAT),1,14)||
				SUBSTR(TO_CHAR(0,v_FORMAT),1,14));
		END LOOP;

	END FILL_NO_TERMS;

	---------------------------------

	PROCEDURE FILL_USING_TERMS
		(
		p_SUPPLY_TXN_ID IN NUMBER
		) AS

	CURSOR c_TERMS(vID IN NUMBER) IS
		SELECT BEGIN_DATE, END_DATE, MIN_TRANSACTION_ID, LIMIT_TRANSACTION_ID
		FROM INTERCHANGE_TRANSACTION_LIMIT
		WHERE TRANSACTION_ID = vID
			AND BEGIN_DATE <= p_END_DATE
			AND NVL(END_DATE, HIGH_DATE) >= p_BEGIN_DATE;


	CURSOR c_LIM_SCHEDULES(vMIN IN NUMBER, vLIM IN NUMBER, vBEGIN IN DATE, vEND IN DATE) IS
		SELECT LIM.SCHEDULE_DATE,
	    	LIM.AMOUNT "TERM_LIMIT",
			MIN.AMOUNT "TERM_MIN",
	        NVL(LIM.PRICE,MIN.PRICE) "TERM_PRICE"
		FROM SYSTEM_DATE_TIME A,
			IT_SCHEDULE LIM, IT_SCHEDULE MIN
	    WHERE A.TIME_ZONE = p_TIME_ZONE
			AND A.DATA_INTERVAL_TYPE = 1
			AND A.DAY_TYPE = 1
			AND A.CUT_DATE BETWEEN vBEGIN AND vEND
		 	AND LIM.TRANSACTION_ID(+) = vLIM
	    	AND LIM.SCHEDULE_TYPE(+) = p_SCHEDULE_TYPE
	        AND LIM.SCHEDULE_STATE(+) = g_INTERNAL_STATE
	        AND LIM.SCHEDULE_DATE(+) = A.CUT_DATE_SCHEDULING
	        AND LIM.AS_OF_DATE(+) = SCHEDULE_AS_OF_DATE(vLIM, p_SCHEDULE_TYPE, g_INTERNAL_STATE, A.CUT_DATE_SCHEDULING, p_AS_OF_DATE)
		 	AND MIN.TRANSACTION_ID(+) = vMIN
	    	AND MIN.SCHEDULE_TYPE(+) = p_SCHEDULE_TYPE
	        AND MIN.SCHEDULE_STATE(+) = g_INTERNAL_STATE
	        AND MIN.SCHEDULE_DATE(+) = A.CUT_DATE_SCHEDULING
	        AND MIN.AS_OF_DATE(+) = SCHEDULE_AS_OF_DATE(vMIN, p_SCHEDULE_TYPE, g_INTERNAL_STATE, A.CUT_DATE_SCHEDULING, p_AS_OF_DATE);
	BEGIN

		FOR v_TERMS IN c_TERMS(p_SUPPLY_TXN_ID) LOOP
			v_TERM_BEGIN := v_TERMS.BEGIN_DATE;
			v_TERM_END := v_TERMS.END_DATE;
			SET_DATE_RANGES();

			--Limit Schedule Amount is the Limit, Min Schedule Amount is the Min.
			FOR v_LIM_SCHEDULE IN c_LIM_SCHEDULES(v_TERMS.MIN_TRANSACTION_ID, v_TERMS.LIMIT_TRANSACTION_ID, v_CUT_BEGIN, v_CUT_END) LOOP
				UT.POST_RTO_WORK(p_WORK_ID, 0, p_SUPPLY_TXN_ID, v_LIM_SCHEDULE.SCHEDULE_DATE,
					SUBSTR(TO_CHAR(NVL(v_LIM_SCHEDULE.TERM_LIMIT,0),v_FORMAT),1,14)||
					SUBSTR(TO_CHAR(NVL(v_LIM_SCHEDULE.TERM_PRICE,0),v_FORMAT),1,14)||
					SUBSTR(TO_CHAR(NVL(v_LIM_SCHEDULE.TERM_MIN,0),v_FORMAT),1,14));
			END LOOP;

		END LOOP;
	END FILL_USING_TERMS;

	---------------------------------

BEGIN --MAIN---------------------------------------

	v_INIT_SUCCESS := INITIALIZE();
	IF NOT v_INIT_SUCCESS THEN RETURN; END IF;

	-- SINGLE SUPPLY -- NO NEED TO LOOP OVER TXNS.
    IF v_SINGLE_BALANCE = 0 THEN
		v_SUPPLY_ID := p_TRANSACTION_ID;
    	v_NO_TERMS := GET_BALANCE_DONT_USE_TERMS(v_SUPPLY_ID);

		IF v_NO_TERMS = 1 THEN --No Terms
			FILL_NO_TERMS(v_SUPPLY_ID);
		ELSE --Using Terms
			FILL_USING_TERMS(v_SUPPLY_ID);
		END IF;

	--THIS IS NOT A SINGLE SUPPLY.  LOOP OVER TRANSACTIONS.
	ELSE
		-- Parse list of Transaction IDs
		UT.TOKENS_FROM_STRING(p_TRANSACTION_ID_LIST, ';', v_TABLE);
    	FOR v_INDEX IN v_TABLE.FIRST..v_TABLE.LAST LOOP
			v_SUPPLY_ID:= v_TABLE(v_INDEX);
    		v_NO_TERMS := GET_BALANCE_DONT_USE_TERMS(v_SUPPLY_ID);
		    IF v_NO_TERMS = 1 THEN -- No Terms
				FILL_NO_TERMS(v_SUPPLY_ID);
	    	ELSE --Using Terms
				FILL_USING_TERMS(v_SUPPLY_ID);
			END IF;
		END LOOP;
		v_TABLE.DELETE;
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		UT.PURGE_RTO_WORK(p_WORK_ID);
		p_WORK_ID := SQLCODE;

END FILL_BALANCE_TRANS_DATES;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_BALANCE_TRANS_DATES
	(
	p_BALANCE_TRANSACTION_ID IN NUMBER,
	p_SUPPLY_TRANSACTION_IDs IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
    p_SCHEDULE_TYPE IN NUMBER,
    p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_WORK_ID NUMBER;
v_FMT VARCHAR2(8);
BEGIN
	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	--Make sure we have data in the SYSTEM_DATE_TIME table.  Return an error if not.
	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, p_BEGIN_DATE, p_END_DATE, p_STATUS);
	IF p_STATUS < 0 THEN
		NULL_CURSOR(p_CURSOR);
		RETURN;
	END IF;

	FILL_BALANCE_TRANS_DATES(p_BALANCE_TRANSACTION_ID, p_SUPPLY_TRANSACTION_IDs, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_SCHEDULE_TYPE, p_AS_OF_DATE, v_WORK_ID, '%');
	IF v_WORK_ID < 0 THEN
		p_STATUS := v_WORK_ID;
		NULL_CURSOR(p_CURSOR);
		RETURN;
	END IF;

	SELECT DECODE(UPPER(SUBSTR(TRANSACTION_INTERVAL,1,2)),'5 ','MI5','10','MI5','15','MI5','20','MI5','30','MI5','HO','HH','DA','DD','WE','DD','MO','DD','QU','DD','YE','DD')
    INTO v_FMT
    FROM INTERCHANGE_TRANSACTION
    WHERE TRANSACTION_ID = p_BALANCE_TRANSACTION_ID;

	OPEN p_CURSOR FOR
		SELECT DISTINCT FROM_CUT_AS_HED(WORK_DATE,p_TIME_ZONE,v_FMT) "DATE",
        	WORK_DATE "CUT_DATE",
        	WORK_XID "TRANSACTION_ID"
		FROM RTO_WORK
		WHERE WORK_ID = v_WORK_ID
		ORDER BY WORK_DATE;

	UT.PURGE_RTO_WORK(v_WORK_ID);
	p_STATUS := GA.SUCCESS;

EXCEPTION
	WHEN OTHERS THEN
		IF v_WORK_ID >= 0 THEN
			UT.PURGE_RTO_WORK(v_WORK_ID);
		END IF;
		p_STATUS := SQLCODE;

END GET_BALANCE_TRANS_DATES;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_BALANCE_TRANS_CONTRACTS
	(
	p_BALANCE_TRANSACTION_ID IN NUMBER,
	p_SUPPLY_TRANSACTION_IDs IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
    p_INTERVAL IN VARCHAR2,
    p_SCHEDULE_TYPE IN NUMBER,
    p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_WORK_ID NUMBER;
v_INTERVAL VARCHAR2(16);
v_INTERVAL_DIFF NUMBER;
v_FMT VARCHAR2(8);
BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	--Make sure we have data in the SYSTEM_DATE_TIME table.  Return an error if not.
	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, p_BEGIN_DATE, p_END_DATE, p_STATUS);
	IF p_STATUS < 0 THEN
		NULL_CURSOR(p_CURSOR);
		RETURN;
	END IF;


	SELECT TRANSACTION_INTERVAL INTO v_INTERVAL
	FROM INTERCHANGE_TRANSACTION A
	WHERE A.TRANSACTION_ID = p_BALANCE_TRANSACTION_ID;


--Right now we are only handling intervals that are hourly (and equal to the transaction's interval).
--So this is commented out so we just return if we try to get any other intervals -- they shouldn't exist.
--This can be addressed later if we decide to support multiple intervals.
	-- null interval means use transaction's interval
	IF TRIM(p_INTERVAL) IS NOT NULL THEN
-- 		-- explicit intervals should exclude transaction's interval
-- 		SELECT DECODE(UPPER(SUBSTR(p_INTERVAL,1,2)),'5 ',0,'10',1,'15',2,'30',3,'HO',4,'DA',5,'WE',6,'MO',7,'QU',8,'YE',9,-1) -
-- 			DECODE(UPPER(SUBSTR(v_INTERVAL,1,2)),'5 ',0,'10',1,'15',2,'30',3,'HO',4,'DA',5,'WE',6,'MO',7,'QU',8,'YE',9,-1)
-- 		INTO v_INTERVAL_DIFF
-- 		FROM DUAL;
--
-- 		IF v_INTERVAL_DIFF > 0 THEN
-- 			v_INTERVAL := TRIM(p_INTERVAL);
-- 		ELSE
			-- specified interval was less than or equal to transaction's interval - skip it
		   OPEN p_CURSOR FOR SELECT NULL FROM DUAL WHERE 0=1; -- open empty recordset
		   RETURN;
--5.5.0.6330		END IF;
	END IF;


	FILL_BALANCE_TRANS_DATES(p_BALANCE_TRANSACTION_ID, p_SUPPLY_TRANSACTION_IDs, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_SCHEDULE_TYPE, p_AS_OF_DATE, v_WORK_ID, v_INTERVAL);

	IF v_WORK_ID < 0 THEN
		p_STATUS := v_WORK_ID;
		NULL_CURSOR(p_CURSOR);
		RETURN;
	END IF;

	v_INTERVAL := UPPER(SUBSTR(v_INTERVAL,1,2));
	SELECT DECODE(v_INTERVAL,'5 ','MI5','10','MI5','15','MI5','20','MI5','30','MI5','HO','HH','DA','DD','WE','DY','MO','MM','QU','Q','YE','YY')
    INTO v_FMT
    FROM DUAL;


--    IF TRIM(p_INTERVAL) IS NULL THEN
    	-- using transaction's interval? then order first by supply transaction id
    	OPEN p_CURSOR FOR
    		SELECT B.TRANSACTION_ID,
    			FROM_CUT_AS_HED(WORK_DATE,p_TIME_ZONE,v_FMT) "DATE",
	        	WORK_DATE "CUT_DATE",
    			SUM(A.TERM_LIMIT) "TERM_LIMIT",
    			SUM(A.TERM_MIN) "TERM_MIN",
    			SUM(A.TERM_PRICE) "TERM_PRICE"
    		FROM (SELECT WORK_XID "TRANSACTION_ID",
            			WORK_DATE "WORK_DATE",
            			TO_NUMBER(TRIM(SUBSTR(WORK_DATA,1,14))) "TERM_LIMIT",
            			TO_NUMBER(TRIM(SUBSTR(WORK_DATA,15,14))) "TERM_PRICE",
            			TO_NUMBER(TRIM(SUBSTR(WORK_DATA,29,14))) "TERM_MIN"
            		FROM RTO_WORK
                    WHERE WORK_ID = v_WORK_ID) A,
    			INTERCHANGE_TRANSACTION B
    		WHERE B.TRANSACTION_ID = A.TRANSACTION_ID
    			AND A.WORK_DATE BETWEEN (B.BEGIN_DATE+1/86400) AND
    				(NVL(B.END_DATE,HIGH_DATE)+1)
    		GROUP BY B.TRANSACTION_ID, FROM_CUT_AS_HED(WORK_DATE,p_TIME_ZONE,v_FMT), WORK_DATE
    		ORDER BY B.TRANSACTION_ID, WORK_DATE;
--     ELSE
--     	-- specific interval specified? then order first by date
--     	OPEN p_CURSOR FOR
--     		SELECT B.TRANSACTION_ID,
--     			FROM_CUT_AS_HED(WORK_DATE,p_TIME_ZONE,v_FMT) "DATE",
-- 	        	WORK_DATE "CUT_DATE",
--     			SUM(A.TERM_LIMIT) "TERM_LIMIT",
--     			SUM(A.TERM_MIN) "TERM_MIN",
--     			SUM(A.TERM_PRICE) "TERM_PRICE"
--     		FROM (SELECT WORK_XID "TRANSACTION_ID",
--             			WORK_DATE "WORK_DATE",
--             			TO_NUMBER(TRIM(SUBSTR(WORK_DATA,1,14))) "TERM_LIMIT",
--             			TO_NUMBER(TRIM(SUBSTR(WORK_DATA,15,14))) "TERM_PRICE",
--             			TO_NUMBER(TRIM(SUBSTR(WORK_DATA,29,14))) "TERM_MIN"
--             		FROM RTO_WORK
--                     WHERE WORK_ID = v_WORK_ID) A,
--     			INTERCHANGE_TRANSACTION B
--     		WHERE B.TRANSACTION_ID = A.TRANSACTION_ID
--     			AND A.WORK_DATE BETWEEN (B.BEGIN_DATE+1/86400) AND
--     				(NVL(B.END_DATE,HIGH_DATE)+1)
--     		GROUP BY B.TRANSACTION_ID, FROM_CUT_AS_HED(WORK_DATE,p_TIME_ZONE,v_FMT), WORK_DATE
--     		ORDER BY WORK_DATE, B.TRANSACTION_ID;
-- 	END IF;

	UT.PURGE_RTO_WORK(v_WORK_ID);

	p_STATUS := GA.SUCCESS;


EXCEPTION
	WHEN OTHERS THEN
		IF v_WORK_ID >= 0 THEN
			UT.PURGE_RTO_WORK(v_WORK_ID);
		END IF;
		p_STATUS := SQLCODE;

END GET_BALANCE_TRANS_CONTRACTS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_BALANCE_TRANS_SCHEDULES
	(
	p_BALANCE_TRANSACTION_ID IN NUMBER,
	p_SUPPLY_TRANSACTION_IDs IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SCHEDULE_TYPE IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_FMT VARCHAR2(8);
v_SCHEDULE_TYPE NUMBER := SUPPLY_SCHEDULE_TYPE(p_SCHEDULE_TYPE);

v_DISPATCHABLE_SUPPLY_IDS ID_TABLE := ID_TABLE();
v_OTHER_TXN_IDS ID_TABLE := ID_TABLE();

	---------------------------

	PROCEDURE INITIALIZE AS
	BEGIN

		IF NOT CAN_READ(g_MODULE_NAME) THEN
			NULL_CURSOR(p_CURSOR);
			RAISE INSUFFICIENT_PRIVILEGES;
		END IF;

		-- get timezone adjusted begin and end dates
		UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

		SELECT DECODE(UPPER(SUBSTR(TRANSACTION_INTERVAL,1,2)),'5 ','MI5','10','MI5','15','MI5','20','MI5','30','MI5','HO','HH','DA','DD','WE','DD','MO','DD','QU','DD','YE','DD')
	    INTO v_FMT
	    FROM INTERCHANGE_TRANSACTION
	    WHERE TRANSACTION_ID = p_BALANCE_TRANSACTION_ID;
	END INITIALIZE;

	---------------------------
	PROCEDURE POPULATE_ID_TABLES AS
		v_COUNT_SUPPLY NUMBER;
		v_ALL_SUPPLY_IDS ID_TABLE;
		v_IS_DISPATCHABLE BOOLEAN;
	BEGIN

		--Determine whether the list of p_SUPPLY_TRANSACTION_IDs is
		--really supply transactions or demand transactions.
    	SELECT COUNT(*) INTO v_COUNT_SUPPLY
    	FROM BALANCE_TRANSACTION
    	WHERE TRANSACTION_ID = p_BALANCE_TRANSACTION_ID;

		-- p_SUPPLY_TRANSACTION_IDS List is actually Demand transactions, despite the name,
		-- so there is only one supply transaction.
    	IF v_COUNT_SUPPLY > 0 THEN

			-- Determine whether the supply transaction is dispatchable.
			v_IS_DISPATCHABLE := GET_BALANCE_DONT_USE_TERMS(p_BALANCE_TRANSACTION_ID) = 1;

			-- If it is, then put them into their separate tables.
			IF v_IS_DISPATCHABLE THEN
				v_DISPATCHABLE_SUPPLY_IDS.EXTEND;
				v_DISPATCHABLE_SUPPLY_IDS(v_DISPATCHABLE_SUPPLY_IDS.LAST) := ID_TYPE(p_BALANCE_TRANSACTION_ID);
				UT.ID_TABLE_FROM_STRING(p_SUPPLY_TRANSACTION_IDS,';',v_OTHER_TXN_IDS);
			-- Otherwise, lump them all together in the 'other' id table.
			ELSE
				UT.ID_TABLE_FROM_STRING(TO_CHAR(p_BALANCE_TRANSACTION_ID) || ';' || p_SUPPLY_TRANSACTION_IDS, ';', v_OTHER_TXN_IDS);
			END IF;

		-- The name is accurate.  There are multiple supply transactions.
		-- Divide them into the two buckets of dispatchable supply and other.
		ELSE
			UT.ID_TABLE_FROM_STRING(p_SUPPLY_TRANSACTION_IDS, ';', v_ALL_SUPPLY_IDS);

			SELECT ID_TYPE(A.TRANSACTION_ID)
			BULK COLLECT INTO v_DISPATCHABLE_SUPPLY_IDS
			FROM INTERCHANGE_TRANSACTION A, TABLE(CAST(v_ALL_SUPPLY_IDS AS ID_TABLE)) B
			WHERE A.TRANSACTION_ID = B.ID
				AND NVL(A.IS_DISPATCHABLE, 0) = 1;

			SELECT ID_TYPE(A.TRANSACTION_ID)
			BULK COLLECT INTO v_OTHER_TXN_IDS
			FROM INTERCHANGE_TRANSACTION A, TABLE(CAST(v_ALL_SUPPLY_IDS AS ID_TABLE)) B
			WHERE (A.TRANSACTION_ID = B.ID AND NVL(A.IS_DISPATCHABLE, 0) = 0)
				OR A.TRANSACTION_ID = p_BALANCE_TRANSACTION_ID;

			v_ALL_SUPPLY_IDS.DELETE;
		END IF;

	EXCEPTION
		WHEN OTHERS THEN
			v_ALL_SUPPLY_IDS.DELETE;
			RAISE;
	END POPULATE_ID_TABLES;
	---------------------------

	PROCEDURE CLEANUP AS
	BEGIN
		v_OTHER_TXN_IDS.DELETE;
		v_DISPATCHABLE_SUPPLY_IDS.DELETE;
	END CLEANUP;

	---------------------------

BEGIN ---------MAIN-----------------------

	INITIALIZE;

	POPULATE_ID_TABLES;

	-- Demand transactions always pull from IT_SCHEDULE.
	-- Transactions using terms (not Dispatchable) always pull from IT_SCHEDULE.
	-- The two above make up the v_OTHER_TXN_IDS table.

	-- Supply Transaction that are Dispatchable "scheduled" amount is not
	-- what's in IT_SCHEDULE but instead
	-- the sum of all assigned from BALANCE_TRANSACTION_SCHEDULE
	-- These ids are in the v_DISPATCHABLE_SUPPLY_IDS table.

	OPEN p_CURSOR FOR

		-- DEMAND AND NON-DISPATCHABLE SUPPLY
		SELECT TRANSACTION_ID,
			FROM_CUT_AS_HED(SCHEDULE_DATE,p_TIME_ZONE,v_FMT) "DATE",
			AMOUNT,
			PRICE
		FROM TABLE(CAST(v_OTHER_TXN_IDS AS ID_TABLE)) A,
			IT_SCHEDULE B
		WHERE B.TRANSACTION_ID = A.ID
			AND B.SCHEDULE_TYPE IN (v_SCHEDULE_TYPE, p_SCHEDULE_TYPE)
			AND B.SCHEDULE_STATE = g_INTERNAL_STATE
			AND B.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND B.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
						FROM IT_SCHEDULE
						WHERE TRANSACTION_ID = B.TRANSACTION_ID
							AND SCHEDULE_TYPE = B.SCHEDULE_TYPE
							AND SCHEDULE_STATE = B.SCHEDULE_STATE
							AND SCHEDULE_DATE = B.SCHEDULE_DATE
							AND AS_OF_DATE <= p_AS_OF_DATE)

		UNION ALL

		-- DISPATCHABLE SUPPLY
		SELECT TRANSACTION_ID,
			FROM_CUT_AS_HED(SCHEDULE_DATE,p_TIME_ZONE,v_FMT) "DATE",
			SUM(AMOUNT) "AMOUNT",
			0 "PRICE"
		FROM TABLE(CAST(v_DISPATCHABLE_SUPPLY_IDS AS ID_TABLE)) A,
			BALANCE_TRANSACTION_SCHEDULE B
		WHERE B.TRANSACTION_ID = A.ID
			AND B.SCHEDULE_TYPE IN (v_SCHEDULE_TYPE, p_SCHEDULE_TYPE)
			AND B.SCHEDULE_STATE = g_INTERNAL_STATE
			AND B.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND B.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
						FROM BALANCE_TRANSACTION_SCHEDULE
						WHERE TRANSACTION_ID = B.TRANSACTION_ID
							AND BALANCE_TRANSACTION_ID = B.BALANCE_TRANSACTION_ID
							AND SCHEDULE_TYPE = B.SCHEDULE_TYPE
							AND SCHEDULE_STATE = B.SCHEDULE_STATE
							AND SCHEDULE_DATE = B.SCHEDULE_DATE
							AND AS_OF_DATE <= p_AS_OF_DATE)
		GROUP BY TRANSACTION_ID,FROM_CUT_AS_HED(SCHEDULE_DATE,p_TIME_ZONE,v_FMT),0

		ORDER BY 1, 2;

	CLEANUP;
	p_STATUS := GA.SUCCESS;

EXCEPTION
	WHEN OTHERS THEN
		CLEANUP;
		p_STATUS := SQLCODE;
END GET_BALANCE_TRANS_SCHEDULES;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_BALANCE_TRANS_ASSIGNED
	(
	p_BALANCE_TRANSACTION_ID IN NUMBER,
	p_SUPPLY_TRANSACTION_IDs IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SCHEDULE_TYPE IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_WORK_ID NUMBER;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_FMT VARCHAR2(8);
v_SCHEDULE_TYPE NUMBER := SUPPLY_SCHEDULE_TYPE(p_SCHEDULE_TYPE);
v_TABLE GA.STRING_TABLE;
BEGIN
	UT.GET_RTO_WORK_ID(v_WORK_ID);

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	-- get timezone adjusted begin and end dates
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	UT.TOKENS_FROM_STRING(p_SUPPLY_TRANSACTION_IDs, ';', v_TABLE);
	FOR v_INDEX IN v_TABLE.FIRST..v_TABLE.LAST LOOP
		UT.POST_RTO_WORK(v_WORK_ID, v_INDEX, v_TABLE(v_INDEX), NULL, NULL);
	END LOOP;
	v_TABLE.DELETE;

	SELECT DECODE(UPPER(SUBSTR(TRANSACTION_INTERVAL,1,2)),'5 ','MI5','10','MI5','15','MI5','20','MI5','30','MI5','HO','HH','DA','DD','WE','DD','MO','DD','QU','DD','YE','DD')
    INTO v_FMT
    FROM INTERCHANGE_TRANSACTION
    WHERE TRANSACTION_ID = p_BALANCE_TRANSACTION_ID;

	OPEN p_CURSOR FOR
		SELECT TRANSACTION_ID,
			FROM_CUT_AS_HED(SCHEDULE_DATE,p_TIME_ZONE,v_FMT) "DATE",
			AMOUNT
		FROM RTO_WORK A,
			BALANCE_TRANSACTION_SCHEDULE B
		WHERE	A.WORK_ID = v_WORK_ID
			AND B.TRANSACTION_ID = A.WORK_XID
			AND B.BALANCE_TRANSACTION_ID = p_BALANCE_TRANSACTION_ID
			AND B.SCHEDULE_TYPE IN (v_SCHEDULE_TYPE, p_SCHEDULE_TYPE)
			AND B.SCHEDULE_STATE = g_INTERNAL_STATE
			AND B.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND B.AS_OF_DATE = (SELECT MAX(AS_OF_DATE) FROM BALANCE_TRANSACTION_SCHEDULE X
							WHERE X.TRANSACTION_ID = B.TRANSACTION_ID
								AND X.BALANCE_TRANSACTION_ID = B.BALANCE_TRANSACTION_ID
								AND X.SCHEDULE_TYPE = B.SCHEDULE_TYPE
								AND X.SCHEDULE_STATE = B.SCHEDULE_STATE
								AND X.SCHEDULE_DATE = B.SCHEDULE_DATE
								AND X.AS_OF_DATE <= p_AS_OF_DATE)
		ORDER BY 1, 2;

	UT.PURGE_RTO_WORK(v_WORK_ID);
	p_STATUS := GA.SUCCESS;

	EXCEPTION
		WHEN OTHERS THEN
			UT.PURGE_RTO_WORK(v_WORK_ID);
			p_STATUS := SQLCODE;

END GET_BALANCE_TRANS_ASSIGNED;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_BALANCE_SUPPLY_ASSIGNED
	(
	p_SUPPLY_TRANSACTION_ID IN NUMBER,
	p_BALANCE_TRANSACTION_IDs IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SCHEDULE_TYPE IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_WORK_ID NUMBER;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_FMT VARCHAR2(8);
v_SCHEDULE_TYPE NUMBER := SUPPLY_SCHEDULE_TYPE(p_SCHEDULE_TYPE);
v_TABLE GA.STRING_TABLE;
BEGIN
	UT.GET_RTO_WORK_ID(v_WORK_ID);

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	-- get timezone adjusted begin and end dates
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	UT.TOKENS_FROM_STRING(p_BALANCE_TRANSACTION_IDs, ';', v_TABLE);
	FOR v_INDEX IN v_TABLE.FIRST..v_TABLE.LAST LOOP
		UT.POST_RTO_WORK(v_WORK_ID, v_INDEX, v_TABLE(v_INDEX), NULL, NULL);
	END LOOP;
	v_TABLE.DELETE;

	SELECT DECODE(UPPER(SUBSTR(TRANSACTION_INTERVAL,1,2)),'5 ','MI5','10','MI5','15','MI5','20','MI5','30','MI5','HO','HH','DA','DD','WE','DD','MO','DD','QU','DD','YE','DD')
    INTO v_FMT
    FROM INTERCHANGE_TRANSACTION
    WHERE TRANSACTION_ID = p_SUPPLY_TRANSACTION_ID;

	OPEN p_CURSOR FOR
		SELECT BALANCE_TRANSACTION_ID "TRANSACTION_ID",
			FROM_CUT_AS_HED(SCHEDULE_DATE,p_TIME_ZONE,v_FMT) "DATE",
			AMOUNT
		FROM RTO_WORK A,
			BALANCE_TRANSACTION_SCHEDULE B
		WHERE	A.WORK_ID = v_WORK_ID
			AND B.TRANSACTION_ID = p_SUPPLY_TRANSACTION_ID
			AND B.BALANCE_TRANSACTION_ID = A.WORK_XID
			AND B.SCHEDULE_TYPE IN (v_SCHEDULE_TYPE, p_SCHEDULE_TYPE)
			AND B.SCHEDULE_STATE = g_INTERNAL_STATE
			AND B.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND B.AS_OF_DATE = (SELECT MAX(AS_OF_DATE) FROM BALANCE_TRANSACTION_SCHEDULE X
							WHERE X.TRANSACTION_ID = B.TRANSACTION_ID
								AND X.BALANCE_TRANSACTION_ID = B.BALANCE_TRANSACTION_ID
								AND X.SCHEDULE_TYPE = B.SCHEDULE_TYPE
								AND X.SCHEDULE_STATE = B.SCHEDULE_STATE
								AND X.SCHEDULE_DATE = B.SCHEDULE_DATE
								AND X.AS_OF_DATE <= p_AS_OF_DATE)
		ORDER BY 1, 2;

	UT.PURGE_RTO_WORK(v_WORK_ID);
	p_STATUS := GA.SUCCESS;

	EXCEPTION
		WHEN OTHERS THEN
			UT.PURGE_RTO_WORK(v_WORK_ID);
			p_STATUS := SQLCODE;

END GET_BALANCE_SUPPLY_ASSIGNED;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_BALANCE_TRANS_PRICES
	(
	p_BALANCE_TRANSACTION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SCHEDULE_TYPE IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_MARKET_PRICE_ID NUMBER;
v_FWD_PRICE_WORK_ID NUMBER;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_FMT VARCHAR2(8);
v_INTERVAL_BEGIN_DATE DATE;
BEGIN
	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	-- get timezone adjusted begin and end dates
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	v_INTERVAL_BEGIN_DATE := BEGIN_CUT_DAY_INTERVAL(p_BEGIN_DATE, p_TIME_ZONE);

	-- Get Forward prices
	SELECT NVL(MARKET_PRICE_ID,0) INTO v_MARKET_PRICE_ID
	FROM INTERCHANGE_TRANSACTION
	WHERE TRANSACTION_ID = p_BALANCE_TRANSACTION_ID;
	CU.GET_HOURLY_FORWARD_PRICES (v_MARKET_PRICE_ID, v_INTERVAL_BEGIN_DATE , v_END_DATE, v_FWD_PRICE_WORK_ID);

	SELECT DECODE(UPPER(SUBSTR(TRANSACTION_INTERVAL,1,2)),'5 ','MI5','10','MI5','15','MI5','20','MI5','30','MI5','HO','HH','DA','DD','WE','DD','MO','DD','QU','DD','YE','DD')
    INTO v_FMT
    FROM INTERCHANGE_TRANSACTION
    WHERE TRANSACTION_ID = p_BALANCE_TRANSACTION_ID;

	OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(A.WORK_DATE,p_TIME_ZONE,v_FMT) "DATE",
			NVL(B.PRICE,0) "PRICE",
			A.WORK_DATA "FWD_PRICE"
		FROM RTO_WORK A,
			(SELECT PRICE_DATE,
				PRICE
			FROM MARKET_PRICE_VALUE
			WHERE MARKET_PRICE_ID = v_MARKET_PRICE_ID
				AND PRICE_CODE = DECODE(p_SCHEDULE_TYPE,1,'F',2,'P',3,'A','X')
				AND PRICE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND AS_OF_DATE = MARKET_PRICE_AS_OF_DATE(MARKET_PRICE_ID, PRICE_CODE, PRICE_DATE, p_AS_OF_DATE)) B
		WHERE A.WORK_ID = v_FWD_PRICE_WORK_ID
			AND B.PRICE_DATE (+)= A.WORK_DATE
		ORDER BY 1;

	UT.PURGE_RTO_WORK(v_FWD_PRICE_WORK_ID);
	p_STATUS := GA.SUCCESS;

	EXCEPTION
		WHEN OTHERS THEN
			UT.PURGE_RTO_WORK(v_FWD_PRICE_WORK_ID);
			p_STATUS := SQLCODE;

END GET_BALANCE_TRANS_PRICES;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_BALANCE_LOAD_ASSIGNED
	(
	p_BALANCE_TRANSACTION_IDs IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SCHEDULE_TYPE IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_WORK_ID NUMBER;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_AN_ID NUMBER;
v_FMT VARCHAR2(8);
v_SCHEDULE_TYPE NUMBER := SUPPLY_SCHEDULE_TYPE(p_SCHEDULE_TYPE);
v_TABLE GA.STRING_TABLE;
BEGIN
	UT.GET_RTO_WORK_ID(v_WORK_ID);

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	-- get timezone adjusted begin and end dates
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	UT.TOKENS_FROM_STRING(p_BALANCE_TRANSACTION_IDs, ';', v_TABLE);
	FOR v_INDEX IN v_TABLE.FIRST..v_TABLE.LAST LOOP
    	v_AN_ID := v_TABLE(v_INDEX);
		UT.POST_RTO_WORK(v_WORK_ID, v_INDEX, v_AN_ID, NULL, NULL);
	END LOOP;
	v_TABLE.DELETE;

	SELECT DECODE(UPPER(SUBSTR(TRANSACTION_INTERVAL,1,2)),'5 ','MI5','10','MI5','15','MI5','20','MI5','30','MI5','HO','HH','DA','DD','WE','DD','MO','DD','QU','DD','YE','DD')
    INTO v_FMT
    FROM INTERCHANGE_TRANSACTION
    WHERE TRANSACTION_ID = v_AN_ID;

	OPEN p_CURSOR FOR
		SELECT BALANCE_TRANSACTION_ID "TRANSACTION_ID",
			FROM_CUT_AS_HED(SCHEDULE_DATE,p_TIME_ZONE,v_FMT) "DATE",
			SUM(AMOUNT) "AMOUNT"
		FROM RTO_WORK A,
			BALANCE_TRANSACTION_SCHEDULE B
		WHERE	A.WORK_ID = v_WORK_ID
			AND B.BALANCE_TRANSACTION_ID = A.WORK_XID
			AND B.SCHEDULE_TYPE IN (v_SCHEDULE_TYPE, p_SCHEDULE_TYPE)
			AND B.SCHEDULE_STATE = g_INTERNAL_STATE
			AND B.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND B.AS_OF_DATE = (SELECT MAX(AS_OF_DATE) FROM BALANCE_TRANSACTION_SCHEDULE X
							WHERE X.TRANSACTION_ID = B.TRANSACTION_ID
								AND X.BALANCE_TRANSACTION_ID = B.BALANCE_TRANSACTION_ID
								AND X.SCHEDULE_TYPE = B.SCHEDULE_TYPE
								AND X.SCHEDULE_STATE = B.SCHEDULE_STATE
								AND X.SCHEDULE_DATE = B.SCHEDULE_DATE
								AND X.AS_OF_DATE <= p_AS_OF_DATE)
		GROUP BY BALANCE_TRANSACTION_ID, FROM_CUT_AS_HED(SCHEDULE_DATE,p_TIME_ZONE,v_FMT)
		ORDER BY 1, 2;

	UT.PURGE_RTO_WORK(v_WORK_ID);
	p_STATUS := GA.SUCCESS;

	EXCEPTION
		WHEN OTHERS THEN
			UT.PURGE_RTO_WORK(v_WORK_ID);
			p_STATUS := SQLCODE;

END GET_BALANCE_LOAD_ASSIGNED;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_BALANCE_TRANS_DATA
	(
	p_TRANSACTION_ID IN NUMBER,
	p_BALANCE_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_ARGUMENTS IN VARCHAR,
	p_UPDATE_DEMAND IN NUMBER,
	p_STATUS OUT NUMBER
	) AS
v_ARGUMENTS_TABLE GA.STRING_TABLE;
v_VALUES_TABLE GA.STRING_TABLE;
v_SCHEDULE_TYPE NUMBER;
v_NO_TERMS NUMBER;
BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    v_NO_TERMS := GET_BALANCE_DONT_USE_TERMS(p_TRANSACTION_ID);

	IF GA.ENABLE_SUPPLY_SCHEDULE_TYPES THEN
		v_SCHEDULE_TYPE := p_SCHEDULE_TYPE;
	ELSE
		-- 'Retail Load' and 'Load' Schedules get types, others (supply schedules) get zero
		SELECT DECODE(UPPER(SUBSTR(TRANSACTION_TYPE,1,2)),'RE',p_SCHEDULE_TYPE,'LO',p_SCHEDULE_TYPE,0)
		INTO v_SCHEDULE_TYPE
		FROM INTERCHANGE_TRANSACTION
		WHERE TRANSACTION_ID = p_TRANSACTION_ID;
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.TOKENS_FROM_STRING(p_ARGUMENTS, ';', v_ARGUMENTS_TABLE);

	FOR v_INDEX IN v_ARGUMENTS_TABLE.FIRST..v_ARGUMENTS_TABLE.LAST LOOP
		IF LENGTH(v_ARGUMENTS_TABLE(v_INDEX)) > 0 THEN
			UT.TOKENS_FROM_STRING(v_ARGUMENTS_TABLE(v_INDEX), ',', v_VALUES_TABLE);
            -- no contract terms used? then don't update IT_SCHEDULE.AMOUNT for supply schedules
            IF v_NO_TERMS = 1 THEN
            	v_VALUES_TABLE(3) := NULL;
			END IF;
			SCHEDULE_UPDATE(p_TRANSACTION_ID, v_SCHEDULE_TYPE, g_INTERNAL_STATE, v_VALUES_TABLE(1), v_VALUES_TABLE(2),
				p_AS_OF_DATE, p_TIME_ZONE, v_VALUES_TABLE(3), v_VALUES_TABLE(4), p_STATUS, TRUE, v_VALUES_TABLE(5), p_BALANCE_TRANSACTION_ID);
			IF p_UPDATE_DEMAND = 1 THEN
				-- if update demand, then the values table should have an additional entry for
				-- the demand value
				SCHEDULE_UPDATE(p_BALANCE_TRANSACTION_ID, v_SCHEDULE_TYPE, g_INTERNAL_STATE, v_VALUES_TABLE(1), v_VALUES_TABLE(2),
					p_AS_OF_DATE, p_TIME_ZONE, v_VALUES_TABLE(6), NULL, p_STATUS);
			END IF;
		END IF;
	END LOOP;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;
END PUT_BALANCE_TRANS_DATA;
----------------------------------------------------------------------------------------------------
-- PROCEDURE GET_BALANCE_TRANS_TERMS (
-- 	p_TRANSACTION_ID IN NUMBER,
-- 	p_TRANSACTION_ID_LIST IN VARCHAR2,
-- 	p_BEGIN_DATE IN DATE,
-- 	p_END_DATE IN DATE,
-- 	p_STATUS OUT NUMBER,
-- 	p_CURSOR OUT GA.REFCURSOR
-- 	) AS
-- v_WORK_ID NUMBER;
-- v_TABLE GA.STRING_TABLE;
-- v_COUNT NUMBER;
-- v_ID NUMBER;
-- BEGIN
-- 	UT.GET_RTO_WORK_ID(v_WORK_ID);
--
-- 	IF NOT CAN_READ(g_MODULE_NAME) THEN
-- 		NULL_CURSOR(p_CURSOR);
-- 		RAISE INSUFFICIENT_PRIVILEGES;
-- 	END IF;
--
-- 	v_COUNT := 0;
-- 	UT.TOKENS_FROM_STRING(p_TRANSACTION_ID_LIST, ';', v_TABLE);
-- 	FOR v_INDEX IN v_TABLE.FIRST..v_TABLE.LAST LOOP
-- 		v_ID := v_TABLE(v_INDEX);
-- 		v_COUNT := v_COUNT + 1;
-- 		UT.POST_RTO_WORK(v_WORK_ID, v_INDEX, v_TABLE(v_INDEX), NULL, NULL);
-- 	END LOOP;
-- 	v_TABLE.DELETE;
--
-- 	IF v_COUNT = 1 AND v_ID = p_TRANSACTION_ID THEN
-- 		-- just get terms for the one supply transaction
-- 		OPEN p_CURSOR FOR
-- 			SELECT TERM_INTERVAL,
-- 				GREATEST(C.BEGIN_DATE,B.BEGIN_DATE) "BEGIN_DATE",
-- 				LEAST(NVL(C.END_DATE,HIGH_DATE),NVL(B.END_DATE,HIGH_DATE)) "END_DATE",
-- 				A.TRANSACTION_ID,
-- 				TERM_LIMIT,
-- 				TERM_MIN,
-- 				TERM_PRICE,
--                 DECODE(UPPER(SUBSTR(C.TERM_INTERVAL,1,2)),'5 ',0,'10',1,'15',2,'30',3,'HO',4,'DA',5,'WE',6,'MO',7,'QU',8,'YE',9,-1)
-- 			FROM INTERCHANGE_TRANSACTION A,
-- 				INTERCHANGE_CONTRACT B,
-- 				INTERCHANGE_CONTRACT_TERM C,
-- 				IT_COMMODITY D,
-- 				IT_COMMODITY E
-- 			WHERE	A.TRANSACTION_ID = p_TRANSACTION_ID
-- 				AND B.CONTRACT_ID = A.CONTRACT_ID
-- 				AND C.CONTRACT_ID = B.CONTRACT_ID
-- 				AND D.COMMODITY_ID = A.COMMODITY_ID
-- 				AND E.COMMODITY_ID = C.COMMODITY_ID
-- 				AND D.COMMODITY_TYPE = E.COMMODITY_TYPE
-- 				AND C.BEGIN_DATE <= p_END_DATE AND NVL(C.END_DATE,HIGH_DATE) >= p_BEGIN_DATE
-- 				AND DECODE(UPPER(SUBSTR(C.TERM_INTERVAL,1,2)),'5 ',0,'10',1,'15',2,'30',3,'HO',4,'DA',5,'WE',6,'MO',7,'QU',8,'YE',9,-1) >
-- 					DECODE(UPPER(SUBSTR(A.TRANSACTION_INTERVAL,1,2)),'5 ',0,'10',1,'15',2,'30',3,'HO',4,'DA',5,'WE',6,'MO',7,'QU',8,'YE',9,-1)
-- 			ORDER BY 8, 2, 3, 4;
-- 	ELSE
-- 		-- get terms for all supply transactions listed
-- 		OPEN p_CURSOR FOR
-- 			SELECT TERM_INTERVAL,
-- 				GREATEST(E.BEGIN_DATE,D.BEGIN_DATE) "BEGIN_DATE",
-- 				LEAST(NVL(E.END_DATE,HIGH_DATE),NVL(D.END_DATE,HIGH_DATE)) "END_DATE",
-- 				C.TRANSACTION_ID,
-- 				TERM_LIMIT,
-- 				TERM_MIN,
-- 				TERM_PRICE,
--                 DECODE(UPPER(SUBSTR(E.TERM_INTERVAL,1,2)),'5 ',0,'10',1,'15',2,'30',3,'HO',4,'DA',5,'WE',6,'MO',7,'QU',8,'YE',9,-1)
-- 			FROM RTO_WORK A,
-- 				BALANCE_TRANSACTION B,
-- 				INTERCHANGE_TRANSACTION C,
-- 				INTERCHANGE_CONTRACT D,
-- 				INTERCHANGE_CONTRACT_TERM E,
-- 				IT_COMMODITY F,
-- 				IT_COMMODITY G
-- 			WHERE	A.WORK_ID = v_WORK_ID
-- 				AND B.BALANCE_TRANSACTION_ID = p_TRANSACTION_ID
-- 				AND B.TRANSACTION_ID = A.WORK_XID
-- 				AND C.TRANSACTION_ID = B.TRANSACTION_ID
-- 				AND D.CONTRACT_ID = C.CONTRACT_ID
-- 				AND E.CONTRACT_ID = D.CONTRACT_ID
-- 				AND F.COMMODITY_ID = C.COMMODITY_ID
-- 				AND G.COMMODITY_ID = E.COMMODITY_ID
-- 				AND F.COMMODITY_TYPE = G.COMMODITY_TYPE
-- 				AND E.BEGIN_DATE <= p_END_DATE AND NVL(E.END_DATE,HIGH_DATE) >= p_BEGIN_DATE
-- 				AND DECODE(UPPER(SUBSTR(E.TERM_INTERVAL,1,2)),'5 ',0,'10',1,'15',2,'30',3,'HO',4,'DA',5,'WE',6,'MO',7,'QU',8,'YE',9,-1) >
-- 					DECODE(UPPER(SUBSTR(C.TRANSACTION_INTERVAL,1,2)),'5 ',0,'10',1,'15',2,'30',3,'HO',4,'DA',5,'WE',6,'MO',7,'QU',8,'YE',9,-1)
-- 			ORDER BY 8, 2, 3, 4;
-- 	END IF;
-- 	UT.PURGE_RTO_WORK(v_WORK_ID);
-- 	p_STATUS := GA.SUCCESS;
--
-- 	EXCEPTION
-- 		WHEN OTHERS THEN
-- 			UT.PURGE_RTO_WORK(v_WORK_ID);
-- 			p_STATUS := SQLCODE;
--
-- END GET_BALANCE_TRANS_TERMS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_BALANCE_TRANS_INTERVALS (
	p_BALANCE_TRANSACTION_ID IN NUMBER,
	p_TRANSACTION_ID IN NUMBER,
	p_INTERVAL IN VARCHAR2,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_INTERVAL VARCHAR2(16);
BEGIN
	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	SELECT DECODE(UPPER(SUBSTR(p_INTERVAL,1,2)),'5 ','MI5','10','MI10','15','MI15','30','MI30','HO','HH','DA','DD','WE','DY','MO','MM','QU','Q','YE','YY','?') INTO v_INTERVAL FROM DUAL;

	OPEN p_CURSOR FOR
		SELECT PC.HED_TRUNC(A.SCHEDULE_DATE,v_INTERVAL) "DATE",
			SUM(A.AMOUNT) "SCHEDULED",
			SUM(B.AMOUNT) "ASSIGNED"
		FROM (SELECT SCHEDULE_DATE, AMOUNT
			FROM IT_SCHEDULE A
			WHERE TRANSACTION_ID = p_TRANSACTION_ID
				AND SCHEDULE_TYPE = p_SCHEDULE_TYPE
				AND SCHEDULE_STATE = g_INTERNAL_STATE
				AND SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND AS_OF_DATE = (SELECT MAX(AS_OF_DATE) FROM IT_SCHEDULE X
							WHERE X.TRANSACTION_ID = A.TRANSACTION_ID
								AND X.SCHEDULE_TYPE = A.SCHEDULE_TYPE
								AND X.SCHEDULE_STATE = A.SCHEDULE_STATE
								AND X.SCHEDULE_DATE = A.SCHEDULE_DATE
								AND X.AS_OF_DATE <= p_AS_OF_DATE)) A,
			(SELECT SCHEDULE_DATE, AMOUNT
			FROM BALANCE_TRANSACTION_SCHEDULE A
			WHERE TRANSACTION_ID = p_TRANSACTION_ID
				AND BALANCE_TRANSACTION_ID = p_BALANCE_TRANSACTION_ID
				AND SCHEDULE_TYPE = p_SCHEDULE_TYPE
				AND SCHEDULE_STATE = g_INTERNAL_STATE
				AND SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND AS_OF_DATE = (SELECT MAX(AS_OF_DATE) FROM BALANCE_TRANSACTION_SCHEDULE X
							WHERE X.TRANSACTION_ID = A.TRANSACTION_ID
								AND X.BALANCE_TRANSACTION_ID = A.BALANCE_TRANSACTION_ID
								AND X.SCHEDULE_TYPE = A.SCHEDULE_TYPE
								AND X.SCHEDULE_STATE = A.SCHEDULE_STATE
								AND X.SCHEDULE_DATE = A.SCHEDULE_DATE
								AND X.AS_OF_DATE <= p_AS_OF_DATE)) B
		WHERE B.SCHEDULE_DATE (+)= A.SCHEDULE_DATE
		GROUP BY PC.HED_TRUNC(A.SCHEDULE_DATE,v_INTERVAL)
		ORDER BY 1;

	p_STATUS := GA.SUCCESS;

	EXCEPTION
		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END GET_BALANCE_TRANS_INTERVALS;
*/
----------------------------------------------------------------------------------------------------
PROCEDURE APPLY_EXTERNAL_SCHEDULE (
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS
BEGIN
	-- perform a schedule copy for the specified time period and transaction - from external to internal
	SCHEDULE_COPY_REQUEST(p_TRANSACTION_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_SCHEDULE_TYPE, 1,
				p_TRANSACTION_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_SCHEDULE_TYPE, 0, 1,
				1, 0, 0, 0, p_TIME_ZONE, p_STATUS);
END APPLY_EXTERNAL_SCHEDULE;
----------------------------------------------------------------------------------------------------

PROCEDURE GET_SERVICE_ZONE_LOAD
   (
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_LOAD_DETAIL IN NUMBER,
	p_PURCHASE_DETAIL IN NUMBER,
	p_SALE_DETAIL IN NUMBER,
	p_GENERATION_DETAIL IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_SCHEDULE_TYPE NUMBER(9) := SUPPLY_SCHEDULE_TYPE(p_SCHEDULE_TYPE);
BEGIN

	IF NOT Can_Read(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := Ga.SUCCESS;

	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

  	IF Ga.VERSION_SCHEDULE THEN
		OPEN p_CURSOR FOR
			SELECT DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'LO', DECODE(p_LOAD_DETAIL,1,A.TRANSACTION_NAME,'LOAD_SUMMARY'), 'UNKNOWN') "TRANSACTION_NAME",
				A.TRANSACTION_TYPE "TRANSACTION_TYPE",
				FROM_CUT_AS_HED(B.SCHEDULE_DATE, p_TIME_ZONE, p_INTERVAL) "SCHEDULE_DATE",
				SUM(B.AMOUNT) "VALUE"
			FROM INTERCHANGE_TRANSACTION A, IT_SCHEDULE B
			WHERE NVL(A.BEGIN_DATE, Low_Date) <= TRUNC(p_END_DATE)
				AND NVL(A.END_DATE, High_Date) >= TRUNC(p_BEGIN_DATE)
				AND p_SERVICE_ZONE_ID = DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'LO', A.ZOR_ID, g_NOT_ASSIGNED)
				AND B.TRANSACTION_ID = A.TRANSACTION_ID
				AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) = 'LO'
				AND B.SCHEDULE_TYPE IN (v_SCHEDULE_TYPE, p_SCHEDULE_TYPE)
				AND B.SCHEDULE_STATE = p_SCHEDULE_STATE
				AND B.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND B.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM IT_SCHEDULE
					WHERE TRANSACTION_ID = B.TRANSACTION_ID
						AND SCHEDULE_TYPE = B.SCHEDULE_TYPE
						AND SCHEDULE_STATE = B.SCHEDULE_STATE
						AND SCHEDULE_DATE = B.SCHEDULE_DATE
						AND AS_OF_DATE <= p_AS_OF_DATE)
			GROUP BY DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'LO', DECODE(p_LOAD_DETAIL,1,A.TRANSACTION_NAME,'LOAD_SUMMARY'), 'UNKNOWN'),
				A.TRANSACTION_TYPE, FROM_CUT_AS_HED(B.SCHEDULE_DATE, p_TIME_ZONE, p_INTERVAL)
			ORDER BY 2,1,3;
	ELSE
		OPEN p_CURSOR FOR
			SELECT DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'LO', DECODE(p_LOAD_DETAIL,1,A.TRANSACTION_NAME,'LOAD_SUMMARY'), 'UNKNOWN') "TRANSACTION_NAME",
				A.TRANSACTION_TYPE "TRANSACTION_TYPE",
				FROM_CUT_AS_HED(B.SCHEDULE_DATE, p_TIME_ZONE, p_INTERVAL) "SCHEDULE_DATE",
				SUM(B.AMOUNT) "VALUE"
			FROM INTERCHANGE_TRANSACTION A, IT_SCHEDULE B
			WHERE NVL(A.BEGIN_DATE, Low_Date) <= TRUNC(p_END_DATE)
				AND NVL(A.END_DATE, High_Date) >= TRUNC(p_BEGIN_DATE)
				AND p_SERVICE_ZONE_ID = DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'LO', A.ZOR_ID, g_NOT_ASSIGNED)
				AND B.TRANSACTION_ID = A.TRANSACTION_ID
				AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) = 'LO'
				AND B.SCHEDULE_TYPE IN (v_SCHEDULE_TYPE, p_SCHEDULE_TYPE)
				AND B.SCHEDULE_STATE = p_SCHEDULE_STATE
				AND B.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND B.AS_OF_DATE =Low_Date
			GROUP BY DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'LO', DECODE(p_LOAD_DETAIL,1,A.TRANSACTION_NAME,'LOAD_SUMMARY'), 'UNKNOWN'),
				A.TRANSACTION_TYPE, FROM_CUT_AS_HED(B.SCHEDULE_DATE, p_TIME_ZONE, p_INTERVAL)
			ORDER BY 2,1,3;
	END IF;


EXCEPTION
	WHEN INSUFFICIENT_PRIVILEGES THEN
		p_STATUS := Ga.INSUFFICIENT_PRIVILEGES;
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END GET_SERVICE_ZONE_LOAD;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SERVICE_ZONE_SUPPLY
   (
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_LOAD_DETAIL IN NUMBER,
	p_PURCHASE_DETAIL IN NUMBER,
	p_SALE_DETAIL IN NUMBER,
	p_GENERATION_DETAIL IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_SCHEDULE_TYPE NUMBER(9) := SUPPLY_SCHEDULE_TYPE(p_SCHEDULE_TYPE);

BEGIN

	IF NOT Can_Read(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := Ga.SUCCESS;

	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

  	IF Ga.VERSION_SCHEDULE THEN
		OPEN p_CURSOR FOR
			SELECT DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'SA', DECODE(p_SALE_DETAIL,1,A.TRANSACTION_NAME,'SALE_SUMMARY'), 'PU', DECODE(p_PURCHASE_DETAIL,1,A.TRANSACTION_NAME,'PURCHASE_SUMMARY'), 'GE', DECODE(p_GENERATION_DETAIL,1,A.TRANSACTION_NAME,'GENERATION_SUMMARY'), 'UNKNOWN') "TRANSACTION_NAME",
				A.TRANSACTION_TYPE "TRANSACTION_TYPE",
				FROM_CUT_AS_HED(B.SCHEDULE_DATE, p_TIME_ZONE, p_INTERVAL) "SCHEDULE_DATE",
				SUM(B.AMOUNT) "VALUE"
			FROM INTERCHANGE_TRANSACTION A, IT_SCHEDULE B
			WHERE NVL(A.BEGIN_DATE, Low_Date) <= TRUNC(p_END_DATE)
				AND NVL(A.END_DATE, High_Date) >= TRUNC(p_BEGIN_DATE)
				AND p_SERVICE_ZONE_ID = DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'SA', A.ZOR_ID, 'PU', A.ZOD_ID, 'GE', A.ZOD_ID, g_NOT_ASSIGNED)
				AND B.TRANSACTION_ID = A.TRANSACTION_ID
				AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) <> 'LO'
				AND B.SCHEDULE_TYPE IN (v_SCHEDULE_TYPE, p_SCHEDULE_TYPE)
				AND B.SCHEDULE_STATE = p_SCHEDULE_STATE
				AND B.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND B.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM IT_SCHEDULE
					WHERE TRANSACTION_ID = B.TRANSACTION_ID
						AND SCHEDULE_TYPE = B.SCHEDULE_TYPE
						AND SCHEDULE_STATE = B.SCHEDULE_STATE
						AND SCHEDULE_DATE = B.SCHEDULE_DATE
						AND AS_OF_DATE <= p_AS_OF_DATE)
			GROUP BY DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'SA', DECODE(p_SALE_DETAIL,1,A.TRANSACTION_NAME,'SALE_SUMMARY'), 'PU', DECODE(p_PURCHASE_DETAIL,1,A.TRANSACTION_NAME,'PURCHASE_SUMMARY'), 'GE', DECODE(p_GENERATION_DETAIL,1,A.TRANSACTION_NAME,'GENERATION_SUMMARY'), 'UNKNOWN'),
				A.TRANSACTION_TYPE, FROM_CUT_AS_HED(B.SCHEDULE_DATE, p_TIME_ZONE, p_INTERVAL)
			ORDER BY 2,1,3;
	ELSE
		OPEN p_CURSOR FOR
			 SELECT DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'SA', DECODE(p_SALE_DETAIL,1,A.TRANSACTION_NAME,'SALE_SUMMARY'), 'PU', DECODE(p_PURCHASE_DETAIL,1,A.TRANSACTION_NAME,'PURCHASE_SUMMARY'), 'GE', DECODE(p_GENERATION_DETAIL,1,A.TRANSACTION_NAME,'GENERATION_SUMMARY'), 'UNKNOWN') "TRANSACTION_NAME",
				A.TRANSACTION_TYPE "TRANSACTION_TYPE",
				FROM_CUT_AS_HED(B.SCHEDULE_DATE, p_TIME_ZONE, p_INTERVAL) "SCHEDULE_DATE",
				SUM(B.AMOUNT) "VALUE"
			FROM INTERCHANGE_TRANSACTION A, IT_SCHEDULE B
			WHERE NVL(A.BEGIN_DATE, Low_Date) <= TRUNC(p_END_DATE)
				AND NVL(A.END_DATE, High_Date) >= TRUNC(p_BEGIN_DATE)
				AND p_SERVICE_ZONE_ID = DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'SA', A.ZOR_ID, 'PU', A.ZOD_ID, 'GE', A.ZOD_ID, g_NOT_ASSIGNED)
				AND B.TRANSACTION_ID = A.TRANSACTION_ID
				AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) <> 'LO'
				AND B.SCHEDULE_TYPE IN (v_SCHEDULE_TYPE, p_SCHEDULE_TYPE)
				AND B.SCHEDULE_STATE = p_SCHEDULE_STATE
				AND B.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND B.AS_OF_DATE =Low_Date
			GROUP BY DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'SA', DECODE(p_SALE_DETAIL,1,A.TRANSACTION_NAME,'SALE_SUMMARY'), 'PU', DECODE(p_PURCHASE_DETAIL,1,A.TRANSACTION_NAME,'PURCHASE_SUMMARY'), 'GE', DECODE(p_GENERATION_DETAIL,1,A.TRANSACTION_NAME,'GENERATION_SUMMARY'), 'UNKNOWN'),
				A.TRANSACTION_TYPE, FROM_CUT_AS_HED(B.SCHEDULE_DATE, p_TIME_ZONE, p_INTERVAL)
			ORDER BY 2,1,3;
	END IF;

EXCEPTION
	WHEN INSUFFICIENT_PRIVILEGES THEN
		p_STATUS := Ga.INSUFFICIENT_PRIVILEGES;
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END GET_SERVICE_ZONE_SUPPLY;
------------------------------------------------------------------------------------------------------------
PROCEDURE GET_MARKET_PRICE_FOR_ZONE
	(
	p_SERVICE_ZONE_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_MARKET_PRICE_INTERVAL VARCHAR2(16);
BEGIN

	IF NOT Can_Read(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := Ga.SUCCESS;

	--DETERMINE THE INTERVAL OF THE MARKET PRICE
	SELECT DECODE(UPPER(MARKET_PRICE_INTERVAL),'15 MINUTE','MI15','30 MINUTE','MI30','DAY','DD','WEEK','DY','MONTH','MM','QUARTER','Q','YEAR','YY','')
	INTO v_MARKET_PRICE_INTERVAL
	FROM MARKET_PRICE A, SERVICE_ZONE B
	WHERE B.SERVICE_ZONE_ID = p_SERVICE_ZONE_ID
		AND B.MARKET_PRICE_ID = A.MARKET_PRICE_ID;


	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	--RETURN NOTHING IF THIS IS NOT THE RIGHT INTERVAL.
	IF NOT UPPER(p_INTERVAL) = UPPER(v_MARKET_PRICE_INTERVAL) THEN
		NULL_CURSOR(p_CURSOR);
  	ELSIF GA.VERSION_SCHEDULE THEN
		OPEN p_CURSOR FOR
			SELECT A.MARKET_PRICE_NAME,
				   FROM_CUT_AS_HED(B.PRICE_DATE, p_TIME_ZONE, p_INTERVAL) "PRICE_DATE",
				   B.PRICE
			FROM MARKET_PRICE A, MARKET_PRICE_VALUE B, SERVICE_ZONE C
			WHERE C.SERVICE_ZONE_ID = p_SERVICE_ZONE_ID
				AND C.MARKET_PRICE_ID = A.MARKET_PRICE_ID
				AND B.MARKET_PRICE_ID = A.MARKET_PRICE_ID
				AND B.PRICE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		      AND B.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM MARKET_PRICE_VALUE
					WHERE MARKET_PRICE_ID = A.MARKET_PRICE_ID
					AND AS_OF_DATE <= p_AS_OF_DATE)
			ORDER BY 2, 3;
	ELSE
		  OPEN p_CURSOR FOR
		  	 SELECT A.MARKET_PRICE_NAME,
				   FROM_CUT_AS_HED(B.PRICE_DATE, p_TIME_ZONE, p_INTERVAL) "PRICE_DATE",
				   B.PRICE
			FROM MARKET_PRICE A, MARKET_PRICE_VALUE B, SERVICE_ZONE C
			WHERE C.SERVICE_ZONE_ID = p_SERVICE_ZONE_ID
				AND C.MARKET_PRICE_ID = A.MARKET_PRICE_ID
				AND B.MARKET_PRICE_ID = A.MARKET_PRICE_ID
				AND B.PRICE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		      AND B.AS_OF_DATE = LOW_DATE
			ORDER BY 2, 3;
	END IF;

EXCEPTION
	WHEN INSUFFICIENT_PRIVILEGES THEN
		p_STATUS := Ga.INSUFFICIENT_PRIVILEGES;
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END GET_MARKET_PRICE_FOR_ZONE;
------------------------------------------------------------------------------------------------------------
PROCEDURE GET_SCHEDULE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SCHEDULE IN OUT NOCOPY SCHEDULE_STATE_TABLE
	) AS

-- p_BEGIN_DATE and p_END_DATE are CUT dates.

v_AS_OF_DATE DATE;

BEGIN
	IF GA.VERSION_SCHEDULE THEN
		v_AS_OF_DATE := CORRECTED_AS_OF_DATE(p_AS_OF_DATE);
		SELECT SCHEDULE_STATE_TYPE(A.TRANSACTION_ID, A.SCHEDULE_TYPE, A.SCHEDULE_STATE, A.SCHEDULE_DATE, A.AMOUNT, A.PRICE)
		BULK COLLECT INTO p_SCHEDULE
		FROM IT_SCHEDULE A
		WHERE A.TRANSACTION_ID = p_TRANSACTION_ID
			AND A.SCHEDULE_TYPE = p_SCHEDULE_TYPE
			AND A.SCHEDULE_STATE = p_SCHEDULE_STATE
			AND A.SCHEDULE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
			AND A.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM IT_SCHEDULE
				WHERE TRANSACTION_ID = A.TRANSACTION_ID
					AND SCHEDULE_TYPE = A.SCHEDULE_TYPE
					AND SCHEDULE_STATE = A.SCHEDULE_STATE
					AND SCHEDULE_DATE = A.SCHEDULE_DATE
					AND AS_OF_DATE <= v_AS_OF_DATE);
	ELSE
		v_AS_OF_DATE := LOW_DATE;
		SELECT SCHEDULE_STATE_TYPE(A.TRANSACTION_ID, A.SCHEDULE_TYPE, A.SCHEDULE_STATE, A.SCHEDULE_DATE, A.AMOUNT, A.PRICE)
		BULK COLLECT INTO p_SCHEDULE
		FROM IT_SCHEDULE A
		WHERE A.TRANSACTION_ID = p_TRANSACTION_ID
			AND A.SCHEDULE_TYPE = p_SCHEDULE_TYPE
			AND A.SCHEDULE_STATE = p_SCHEDULE_STATE
			AND A.SCHEDULE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
			AND AS_OF_DATE = v_AS_OF_DATE;
	END IF;

END GET_SCHEDULE;
------------------------------------------------------------------------------------------------------------
PROCEDURE SCHEDULE_COMPARISON_FILL
	(
	p_SCHEDULE IN OUT NOCOPY SCHEDULE_COMPARE_TABLE
	) AS

-- no longer used from GUI.  It used to be the Schedule Comparison View.
v_INDEX BINARY_INTEGER;
v_IDX BINARY_INTEGER;
v_START BINARY_INTEGER;
v_QUANTITY NUMBER;
v_PRICE NUMBER;
v_COUNT NUMBER;
v_RESET BOOLEAN;

BEGIN

	IF g_TRACE_ON THEN
	    UT.DEBUG_TRACE('SCHEDULE_COMPARISON_FILL');
	    UT.DEBUG_TRACE('SCHEDULE.COUNT=' || TO_CHAR(p_SCHEDULE.COUNT));
	    UT.DEBUG_TRACE('ALPHA');
	END IF;

	v_INDEX := p_SCHEDULE.FIRST;
	v_RESET := TRUE;
	WHILE v_INDEX <= p_SCHEDULE.LAST LOOP
		IF v_RESET THEN
			v_START := v_INDEX;
			v_RESET := FALSE;
		END IF;
		IF p_SCHEDULE(v_INDEX).ALPHA_SCHEDULE_QUANTITY IS NOT NULL THEN
			v_RESET := TRUE;
			IF NOT v_START = v_INDEX THEN
				v_COUNT := v_INDEX - v_START + 1;
				v_QUANTITY := p_SCHEDULE(v_INDEX).ALPHA_SCHEDULE_QUANTITY / v_COUNT;
				v_PRICE := p_SCHEDULE(v_INDEX).ALPHA_SCHEDULE_PRICE;
				IF g_TRACE_ON THEN
				    UT.DEBUG_TRACE('START=' || TO_CHAR(v_START));
				    UT.DEBUG_TRACE('STOP=' || TO_CHAR(v_INDEX));
				    UT.DEBUG_TRACE('COUNT=' || TO_CHAR(v_COUNT));
				    UT.DEBUG_TRACE('QUANTITY=' || TO_CHAR(v_QUANTITY));
				    UT.DEBUG_TRACE('PRICE=' || TO_CHAR(v_PRICE));
				END IF;
				FOR v_IDX IN v_START..v_INDEX LOOP
					p_SCHEDULE(v_IDX).ALPHA_SCHEDULE_QUANTITY := v_QUANTITY;
					p_SCHEDULE(v_IDX).ALPHA_SCHEDULE_PRICE := v_PRICE;
				END LOOP;
			END IF;
		END IF;
		v_INDEX := p_SCHEDULE.NEXT(v_INDEX);
	END LOOP;

	IF g_TRACE_ON THEN
	    UT.DEBUG_TRACE('BETA');
	END IF;

	v_INDEX := p_SCHEDULE.FIRST;
	v_RESET := TRUE;
	WHILE v_INDEX <= p_SCHEDULE.LAST LOOP
		IF v_RESET THEN
			v_START := v_INDEX;
			v_RESET := FALSE;
		END IF;
		IF p_SCHEDULE(v_INDEX).BETA_SCHEDULE_QUANTITY IS NOT NULL THEN
			v_RESET := TRUE;
			IF NOT v_START = v_INDEX THEN
				v_COUNT := v_INDEX - v_START + 1;
				v_QUANTITY := p_SCHEDULE(v_INDEX).BETA_SCHEDULE_QUANTITY / v_COUNT;
				v_PRICE := p_SCHEDULE(v_INDEX).BETA_SCHEDULE_PRICE;
				IF g_TRACE_ON THEN
				    UT.DEBUG_TRACE('START=' || TO_CHAR(v_START));
				    UT.DEBUG_TRACE('STOP=' || TO_CHAR(v_INDEX));
				    UT.DEBUG_TRACE('COUNT=' || TO_CHAR(v_COUNT));
				    UT.DEBUG_TRACE('QUANTITY=' || TO_CHAR(v_QUANTITY));
				    UT.DEBUG_TRACE('PRICE=' || TO_CHAR(v_PRICE));
				END IF;
				FOR v_IDX IN v_START..v_INDEX LOOP
					p_SCHEDULE(v_IDX).BETA_SCHEDULE_QUANTITY := v_QUANTITY;
					p_SCHEDULE(v_IDX).BETA_SCHEDULE_PRICE := v_PRICE;
				END LOOP;
			END IF;
		END IF;
		v_INDEX := p_SCHEDULE.NEXT(v_INDEX);
	END LOOP;

END SCHEDULE_COMPARISON_FILL;
------------------------------------------------------------------------------------------------------------
PROCEDURE SCHEDULE_COMPARISON
	(
	p_TRANSACTION_ID IN NUMBER,
	p_COMPARISON_MODE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- COMPARISON MODE:
-- 1 - Forecast-Preliminary
-- 2 - Forecast-Final
-- 3 - Preliminary-Final
-- 4 - Forecast-External
-- 5 - Preliminary-External
-- 6 - Final-External

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_SCHEDULE_DATE DATE;
v_FORMAT VARCHAR(4);
v_MINUTES NUMBER(6);
v_COUNT NUMBER(6) := 0;
v_INDEX BINARY_INTEGER;
v_DELTA_INDEX BINARY_INTEGER;
v_ALPHA_SCHEDULE SCHEDULE_STATE_TABLE := SCHEDULE_STATE_TABLE();
v_BETA_SCHEDULE SCHEDULE_STATE_TABLE := SCHEDULE_STATE_TABLE();
v_DELTA_SCHEDULE SCHEDULE_COMPARE_TABLE := SCHEDULE_COMPARE_TABLE();

-- no longer used from GUI.  It used to be the Schedule Comparison View.

BEGIN

	IF g_TRACE_ON THEN
		UT.TRUNCATE_TRACE;
	    UT.DEBUG_TRACE('SCHEDULE_COMPARISON');
	    UT.DEBUG_TRACE('TRANSACTION_ID=' || TO_CHAR(p_TRANSACTION_ID));
	    UT.DEBUG_TRACE('COMPARISON_MODE=' || TO_CHAR(p_COMPARISON_MODE));
		UT.DEBUG_TRACE('BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE));
		UT.DEBUG_TRACE('END_DATE=' || TO_CHAR(p_END_DATE));
		UT.DEBUG_TRACE('AS_OF_DATE=' || UT.TRACE_DATE(p_END_DATE));
		UT.DEBUG_TRACE('TIME_ZONE=' || p_TIME_ZONE);
	END IF;

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;
	COERCE_DATE_RANGE(p_TRANSACTION_ID, g_INTERNAL_STATE, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_COMPARISON_MODE > 3, v_BEGIN_DATE, v_END_DATE, v_FORMAT, v_MINUTES);
	v_SCHEDULE_DATE := v_BEGIN_DATE;

	WHILE v_SCHEDULE_DATE <= v_END_DATE LOOP
		v_COUNT := v_COUNT + 1;
		v_SCHEDULE_DATE := ADD_MINUTES_TO_DATE(v_SCHEDULE_DATE, v_MINUTES);
	END LOOP;

	v_DELTA_SCHEDULE.EXTEND(v_COUNT);
	v_DELTA_INDEX := v_DELTA_SCHEDULE.FIRST;
	v_SCHEDULE_DATE := v_BEGIN_DATE;
	WHILE v_DELTA_INDEX <= v_DELTA_SCHEDULE.LAST LOOP
		v_DELTA_SCHEDULE(v_DELTA_INDEX) := SCHEDULE_COMPARE_TYPE(v_SCHEDULE_DATE, NULL, NULL, NULL, NULL);
		v_SCHEDULE_DATE := ADD_MINUTES_TO_DATE(v_SCHEDULE_DATE, v_MINUTES);
		v_DELTA_INDEX := v_DELTA_SCHEDULE.NEXT(v_DELTA_INDEX);
	END LOOP;

	IF g_TRACE_ON THEN
	    UT.DEBUG_TRACE('DELTA_SCHEDULE.COUNT=' || TO_CHAR(v_DELTA_SCHEDULE.COUNT));
	END IF;

	IF p_COMPARISON_MODE IN (1,2,4) THEN
		GET_SCHEDULE(p_TRANSACTION_ID, 1, g_INTERNAL_STATE, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, v_ALPHA_SCHEDULE);
	ELSIF p_COMPARISON_MODE IN (3,5) THEN
		GET_SCHEDULE(p_TRANSACTION_ID, 2, g_INTERNAL_STATE, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, v_ALPHA_SCHEDULE);
	ELSE
		GET_SCHEDULE(p_TRANSACTION_ID, 3, g_INTERNAL_STATE, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, v_ALPHA_SCHEDULE);
	END IF;

	IF p_COMPARISON_MODE = 1 THEN
		GET_SCHEDULE(p_TRANSACTION_ID, 2, g_INTERNAL_STATE, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, v_BETA_SCHEDULE);
	ELSIF p_COMPARISON_MODE IN (2,3) THEN
		GET_SCHEDULE(p_TRANSACTION_ID, 3, g_INTERNAL_STATE, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, v_BETA_SCHEDULE);
	ELSE
		GET_SCHEDULE(p_TRANSACTION_ID, p_COMPARISON_MODE - 3, g_EXTERNAL_STATE, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, v_BETA_SCHEDULE);
	END IF;

	IF g_TRACE_ON THEN
	    UT.DEBUG_TRACE('ALPHA_SCHEDULE.COUNT=' || TO_CHAR(v_ALPHA_SCHEDULE.COUNT));
	END IF;

	v_INDEX := v_ALPHA_SCHEDULE.FIRST;
	WHILE v_INDEX <= v_ALPHA_SCHEDULE.LAST LOOP
		v_DELTA_INDEX := v_DELTA_SCHEDULE.FIRST;
		WHILE v_DELTA_INDEX <= v_DELTA_SCHEDULE.LAST LOOP
			IF v_ALPHA_SCHEDULE(v_INDEX).SCHEDULE_DATE = v_DELTA_SCHEDULE(v_DELTA_INDEX).SCHEDULE_DATE THEN
				v_DELTA_SCHEDULE(v_DELTA_INDEX).ALPHA_SCHEDULE_QUANTITY := v_ALPHA_SCHEDULE(v_INDEX).SCHEDULE_QUANTITY;
				v_DELTA_SCHEDULE(v_DELTA_INDEX).ALPHA_SCHEDULE_PRICE := v_ALPHA_SCHEDULE(v_INDEX).SCHEDULE_PRICE;
				EXIT;
			END IF;
			v_DELTA_INDEX := v_DELTA_SCHEDULE.NEXT(v_DELTA_INDEX);
		END LOOP;
		v_INDEX := v_ALPHA_SCHEDULE.NEXT(v_INDEX);
	END LOOP;

	IF g_TRACE_ON THEN
	    UT.DEBUG_TRACE('BETA_SCHEDULE.COUNT=' || TO_CHAR(v_BETA_SCHEDULE.COUNT));
	END IF;

	v_INDEX := v_BETA_SCHEDULE.FIRST;
	WHILE v_INDEX <= v_BETA_SCHEDULE.LAST LOOP
		v_DELTA_INDEX := v_DELTA_SCHEDULE.FIRST;
		WHILE v_DELTA_INDEX <= v_DELTA_SCHEDULE.LAST LOOP
			IF v_BETA_SCHEDULE(v_INDEX).SCHEDULE_DATE = v_DELTA_SCHEDULE(v_DELTA_INDEX).SCHEDULE_DATE THEN
				v_DELTA_SCHEDULE(v_DELTA_INDEX).BETA_SCHEDULE_QUANTITY := v_BETA_SCHEDULE(v_INDEX).SCHEDULE_QUANTITY;
				v_DELTA_SCHEDULE(v_DELTA_INDEX).BETA_SCHEDULE_PRICE := v_BETA_SCHEDULE(v_INDEX).SCHEDULE_PRICE;
				EXIT;
			END IF;
			v_DELTA_INDEX := v_DELTA_SCHEDULE.NEXT(v_DELTA_INDEX);
		END LOOP;
		v_INDEX := v_BETA_SCHEDULE.NEXT(v_INDEX);
	END LOOP;

	SCHEDULE_COMPARISON_FILL(v_DELTA_SCHEDULE);

	OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(A.SCHEDULE_DATE, p_TIME_ZONE, v_FORMAT, GA.ELECTRIC_MODEL) "SCHEDULE_DATE",
			A.ALPHA_SCHEDULE_QUANTITY,
			A.ALPHA_SCHEDULE_PRICE,
			A.ALPHA_SCHEDULE_QUANTITY * A.ALPHA_SCHEDULE_PRICE "ALPHA_COST_REVENUE",
			A.BETA_SCHEDULE_QUANTITY,
			A.BETA_SCHEDULE_PRICE,
			A.BETA_SCHEDULE_QUANTITY * A.BETA_SCHEDULE_PRICE "BETA_COST_REVENUE"
		FROM TABLE(CAST(v_DELTA_SCHEDULE AS SCHEDULE_COMPARE_TABLE)) A
		ORDER BY 1;

EXCEPTION
	WHEN INSUFFICIENT_PRIVILEGES THEN
		p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;
END SCHEDULE_COMPARISON;
---------------------------------------------------------------------------------------------------
PROCEDURE SCHEDULE_TEMPLATE_NAMES
    (
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the names of PSE that are a purchasing party to the transaction.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		  SELECT TEMPLATE_NAME
		  FROM SCHEDULE_TEMPLATE
		  ORDER BY TEMPLATE_ORDER;

EXCEPTION
	WHEN INSUFFICIENT_PRIVILEGES THEN
		p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END SCHEDULE_TEMPLATE_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE SCHEDULER_SCHEDULE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the schedule's detailed data for the specified selection criteria.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_SCHEDULE_DATE DATE;
v_FORMAT VARCHAR(4);
v_MINUTES NUMBER(6);
v_COUNT NUMBER(6) := 0;
v_INDEX BINARY_INTEGER;
v_ALPHA_INDEX BINARY_INTEGER;
v_SCHEDULE SCHEDULE_STATE_TABLE := SCHEDULE_STATE_TABLE();
v_ALPHA_SCHEDULE SCHEDULE_STATE_TABLE := SCHEDULE_STATE_TABLE();

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		NULL_CURSOR(p_CURSOR);
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	IF g_TRACE_ON THEN
		UT.TRUNCATE_TRACE;
	    UT.DEBUG_TRACE('SCHEDULER_SCHEDULE');
	    UT.DEBUG_TRACE('TRANSACTION_ID=' || TO_CHAR(p_TRANSACTION_ID));
	    UT.DEBUG_TRACE('SCHEDULE_TYPE=' || TO_CHAR(p_SCHEDULE_TYPE));
	    UT.DEBUG_TRACE('SCHEDULE_STATE=' || TO_CHAR(p_SCHEDULE_TYPE));
		UT.DEBUG_TRACE('BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE));
		UT.DEBUG_TRACE('END_DATE=' || TO_CHAR(p_END_DATE));
		UT.DEBUG_TRACE('AS_OF_DATE=' || UT.TRACE_DATE(p_END_DATE));
		UT.DEBUG_TRACE('TIME_ZONE=' || p_TIME_ZONE);
	END IF;

	COERCE_DATE_RANGE(p_TRANSACTION_ID, p_SCHEDULE_STATE, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, FALSE, v_BEGIN_DATE, v_END_DATE, v_FORMAT, v_MINUTES);
	v_SCHEDULE_DATE := v_BEGIN_DATE;

	WHILE v_SCHEDULE_DATE <= v_END_DATE LOOP
		v_COUNT := v_COUNT + 1;
		v_SCHEDULE_DATE := ADD_MINUTES_TO_DATE(v_SCHEDULE_DATE, v_MINUTES);
	END LOOP;

	IF g_TRACE_ON THEN
	    UT.DEBUG_TRACE('SCHEDULE COUNT=' || TO_CHAR(v_COUNT));
	END IF;

	v_SCHEDULE.EXTEND(v_COUNT);
	v_INDEX := v_SCHEDULE.FIRST;
	v_SCHEDULE_DATE := v_BEGIN_DATE;
	WHILE v_INDEX <= v_SCHEDULE.LAST LOOP
		v_SCHEDULE(v_INDEX) := SCHEDULE_STATE_TYPE(p_TRANSACTION_ID, p_SCHEDULE_TYPE, p_SCHEDULE_STATE, v_SCHEDULE_DATE, 0, 0);
		v_SCHEDULE_DATE := ADD_MINUTES_TO_DATE(v_SCHEDULE_DATE, v_MINUTES);
		v_INDEX := v_SCHEDULE.NEXT(v_INDEX);
	END LOOP;

	GET_SCHEDULE(p_TRANSACTION_ID, p_SCHEDULE_TYPE, p_SCHEDULE_STATE, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, v_ALPHA_SCHEDULE);

	IF g_TRACE_ON THEN
	    UT.DEBUG_TRACE('ALPHA_SCHEDULE.COUNT=' || TO_CHAR(v_ALPHA_SCHEDULE.COUNT));
	END IF;

	v_ALPHA_INDEX := v_ALPHA_SCHEDULE.FIRST;
	WHILE v_ALPHA_INDEX <= v_ALPHA_SCHEDULE.LAST LOOP
		v_INDEX := v_SCHEDULE.FIRST;
		WHILE v_INDEX <= v_SCHEDULE.LAST LOOP
			IF v_ALPHA_SCHEDULE(v_ALPHA_INDEX).SCHEDULE_DATE = v_SCHEDULE(v_INDEX).SCHEDULE_DATE THEN
				v_SCHEDULE(v_INDEX).SCHEDULE_QUANTITY := v_ALPHA_SCHEDULE(v_ALPHA_INDEX).SCHEDULE_QUANTITY;
				v_SCHEDULE(v_INDEX).SCHEDULE_PRICE := v_ALPHA_SCHEDULE(v_ALPHA_INDEX).SCHEDULE_PRICE;
				EXIT;
			END IF;
			v_INDEX := v_SCHEDULE.NEXT(v_INDEX);
		END LOOP;
		v_ALPHA_INDEX := v_ALPHA_SCHEDULE.NEXT(v_ALPHA_INDEX);
	END LOOP;

	OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(A.SCHEDULE_DATE, p_TIME_ZONE, v_FORMAT, GA.ELECTRIC_MODEL) "SCHEDULE_DATE",
			A.SCHEDULE_QUANTITY "AMOUNT",
			A.SCHEDULE_PRICE "PRICE",
			A.SCHEDULE_QUANTITY * A.SCHEDULE_PRICE "COST",
 			NULL "EXT_AMOUNT",
			NULL "EXT_PRICE",
			NULL "EXT_COST"
		FROM TABLE(CAST(v_SCHEDULE AS SCHEDULE_STATE_TABLE)) A
		ORDER BY 1;

EXCEPTION
	WHEN INSUFFICIENT_PRIVILEGES THEN
		p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END SCHEDULER_SCHEDULE;
---------------------------------------------------------------------------
PROCEDURE PUT_IT_SCHEDULE_FOR_HOUR
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SCHEDULE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_AMOUNT IN NUMBER,
	p_PRICE IN NUMBER,
	p_MINUTES IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_END_DATE DATE;
v_SCHEDULE_DATE DATE;
v_LOOP_COUNTER NUMBER(5) := 0;
--EXPANDS AND STORES AN HOUR OF DATA TO THE INTERVAL SPECIFIED.
BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	p_STATUS := GA.SUCCESS;

	v_END_DATE := TO_CUT(p_SCHEDULE_DATE, p_TIME_ZONE);
	v_SCHEDULE_DATE := ADD_MINUTES_TO_DATE(v_END_DATE, p_MINUTES - 60);

	WHILE v_SCHEDULE_DATE <= v_END_DATE LOOP
		PUT_IT_SCHEDULE(p_TRANSACTION_ID, p_SCHEDULE_TYPE, p_SCHEDULE_STATE, v_SCHEDULE_DATE, p_AS_OF_DATE, p_AMOUNT, p_PRICE, p_STATUS);
		v_SCHEDULE_DATE := ADD_MINUTES_TO_DATE(v_SCHEDULE_DATE, p_MINUTES);

		--MAKE SURE WE AREN'T LOOPING FOREVER
		v_LOOP_COUNTER := v_LOOP_COUNTER + 1;
		IF v_LOOP_COUNTER > 1000 THEN
			RAISE_APPLICATION_ERROR(-20901,'RUNAWAY LOOP IN IT.PUT_IT_SCHEDULE_FOR_HOUR PROCEDURE');
		END IF;
	END LOOP;

EXCEPTION
	WHEN INSUFFICIENT_PRIVILEGES THEN
		p_STATUS := GA.INSUFFICIENT_PRIVILEGES;
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;
END PUT_IT_SCHEDULE_FOR_HOUR;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_ENERGY_SUMMARY
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
    p_SCHEDULE_TYPE IN NUMBER,
    p_INTERVAL IN VARCHAR2,
    p_TEMPLATE_ID IN NUMBER,
    p_ENTITY_TYPE IN VARCHAR2,
    p_ENTITY_IDs IN VARCHAR2,
    p_STATUS OUT NUMBER,
    p_CURSOR IN OUT GA.REFCURSOR
    ) AS
v_INTERVAL VARCHAR2(16) := NVL(GET_INTERVAL_ABBREVIATION(p_INTERVAL),'HH');
v_BEGIN_DATE DATE;
v_BEGIN_DATE_SDT DATE;
v_END_DATE DATE;
v_IDs GA.ID_TABLE;
v_IDX BINARY_INTEGER;
v_WORK_ID NUMBER;
BEGIN
	IF NOT CAN_READ(g_MODULE_NAME) THEN
		RAISE INSUFFICIENT_PRIVILEGES;
	END IF;

	--Make sure we have data in the SYSTEM_DATE_TIME table.  Return an error if not.
	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, p_BEGIN_DATE, p_END_DATE, p_STATUS);
	IF p_STATUS < 0 THEN
		NULL_CURSOR(p_CURSOR);
		RETURN;
	END IF;

	-- push list of IDs into rto work table
	UT.GET_RTO_WORK_ID(v_WORK_ID);
    UT.IDS_FROM_STRING(p_ENTITY_IDs,',',v_IDs);
	v_IDX := v_IDs.FIRST;
    WHILE v_IDs.EXISTS(v_IDX) LOOP
		INSERT INTO RTO_WORK (WORK_ID, WORK_XID)
        	VALUES (v_WORK_ID, v_IDs(v_IDX));
		v_IDX := v_IDs.NEXT(v_IDX);
    END LOOP;
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	-- System_Date_Time table does not store daily values a second past midnight, so
	-- in order to capture them we need to tick begin date back a second
	v_BEGIN_DATE_SDT := v_BEGIN_DATE-1/86400;

    IF p_TEMPLATE_ID > 0 THEN
    	OPEN p_CURSOR FOR
    		SELECT SCHEDULE_DATE,
                ENTITY_NAME,
            	ENTITY_ID,
    			0 "IS_TOTAL",
    			PERIOD_NAME,
    			PERIOD_ID,
    			SUM(LOAD) "LOAD",
    			MIN(LOAD_STATISTIC) "MIN_LOAD",
    			MAX(LOAD_STATISTIC) "MAX_LOAD",
    			AVG(LOAD_STATISTIC) "AVG_LOAD",
    			SUM(PURCHASE_AMOUNT-SALE_AMOUNT) "NET_SUPPLY_AMOUNT",
    			SUM(PURCHASE_AMOUNT*PURCHASE_PRICE-SALE_AMOUNT*SALE_PRICE) "NET_SUPPLY_COST",
    			DECODE(NVL(SUM(PURCHASE_AMOUNT-SALE_AMOUNT),0),0,0,SUM(PURCHASE_AMOUNT*PURCHASE_PRICE-SALE_AMOUNT*SALE_PRICE)/SUM(PURCHASE_AMOUNT-SALE_AMOUNT)) "NET_SUPPLY_WACOG",
    			SUM(PURCHASE_AMOUNT) "PURCHASE_AMOUNT",
    			SUM(PURCHASE_AMOUNT*PURCHASE_PRICE) "PURCHASE_COST",
    			DECODE(NVL(SUM(PURCHASE_AMOUNT),0),0,0,SUM(PURCHASE_AMOUNT*PURCHASE_PRICE)/SUM(PURCHASE_AMOUNT)) "PURCHASE_WACOG",
    			SUM(SALE_AMOUNT) "SALE_AMOUNT",
    			SUM(SALE_AMOUNT*SALE_PRICE) "SALE_COST",
    			DECODE(NVL(SUM(SALE_AMOUNT),0),0,0,SUM(SALE_AMOUNT*SALE_PRICE)/SUM(SALE_AMOUNT)) "SALE_WACOG"
    		FROM (SELECT A.ENTITY_ID, A.ENTITY_NAME,
						F.PERIOD_NAME, F.PERIOD_ID,
						CASE v_INTERVAL
							WHEN 'HH' THEN C.HOUR_YYYY_MM_DD
							WHEN 'DD' THEN C.DAY_YYYY_MM_DD
							WHEN 'DY' THEN C.WEEK_YYYY_MM_DD
							WHEN 'MM' THEN C.MONTH_YYYY_MM_DD
							WHEN 'Q' THEN C.QUARTER_YYYY_MM_DD
							WHEN 'YY' THEN C.YEAR_YYYY_MM_DD
							ELSE C.NO_ROLLUP_YYYY_MM_DD
						END "SCHEDULE_DATE",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'LO', B.AMOUNT, 'RE', B.AMOUNT, NULL) "LOAD_STATISTIC",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'LO', NVL(B.AMOUNT,0),'RE', NVL(B.AMOUNT,0), 0) "LOAD",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'PU', NVL(B.AMOUNT,0),0) "PURCHASE_AMOUNT",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'PU', NVL(B.PRICE,0),0) "PURCHASE_PRICE",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'SA', NVL(B.AMOUNT,0),0) "SALE_AMOUNT",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'SA', NVL(B.PRICE,0),0) "SALE_PRICE"
				FROM (SELECT DECODE(UPPER(p_ENTITY_TYPE),'PURCHASER',A.PURCHASER_ID,
                										'SELLER',A.SELLER_ID,
                                                        'POR',A.POR_ID,
                                                        'POD',A.POD_ID,
                                                        'TP',C.TP_ID,
                                                        'EDC',C.EDC_ID) "ENTITY_ID",
    						DECODE(UPPER(p_ENTITY_TYPE),'PURCHASER',E.PSE_NAME,
                										'SELLER',F.PSE_NAME,
                                                        'POR',D.SERVICE_POINT_NAME,
                                                        'POD',C.SERVICE_POINT_ID,
                                                        'TP',G.TP_NAME,
                                                        'EDC',H.EDC_NAME) "ENTITY_NAME",
							A.TRANSACTION_ID,
							A.TRANSACTION_TYPE,
							H.EDC_ID
    					FROM INTERCHANGE_TRANSACTION A,
    						IT_COMMODITY B,
    						SERVICE_POINT C,
    						SERVICE_POINT D,
    						PURCHASING_SELLING_ENTITY E,
    						PURCHASING_SELLING_ENTITY F,
    						TRANSMISSION_PROVIDER G,
    						ENERGY_DISTRIBUTION_COMPANY H
    					WHERE B.COMMODITY_ID = A.COMMODITY_ID
    						AND B.COMMODITY_TYPE = 'Energy'
    						AND C.SERVICE_POINT_ID(+) = A.POD_ID
    						AND D.SERVICE_POINT_ID(+) = A.POR_ID
    						AND E.PSE_ID(+) = A.PURCHASER_ID
    						AND F.PSE_ID(+) = A.SELLER_ID
    						AND G.TP_ID(+) = C.TP_ID
    						AND H.EDC_ID(+) = C.EDC_ID) A,
	   				IT_SCHEDULE B,
	   				SYSTEM_DATE_TIME C,
	    			SEASON_DATES D,
	    			SEASON_TEMPLATE E,
	    			PERIOD F,
	   				RTO_WORK
	       		WHERE RTO_WORK.WORK_ID = v_WORK_ID
	       	        AND A.ENTITY_ID = RTO_WORK.WORK_XID
					AND C.TIME_ZONE = p_TIME_ZONE
					AND C.DATA_INTERVAL_TYPE = 1
					AND C.DAY_TYPE = 1
					AND C.CUT_DATE BETWEEN v_BEGIN_DATE_SDT AND v_END_DATE
					AND B.TRANSACTION_ID = A.TRANSACTION_ID
					AND B.SCHEDULE_TYPE = p_SCHEDULE_TYPE
					AND B.SCHEDULE_STATE = g_INTERNAL_STATE
					AND B.SCHEDULE_DATE = C.CUT_DATE_SCHEDULING
					AND B.SCHEDULE_DATE >= v_BEGIN_DATE
					AND B.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
										FROM IT_SCHEDULE
										WHERE TRANSACTION_ID = B.TRANSACTION_ID
											AND SCHEDULE_TYPE = B.SCHEDULE_TYPE
											AND SCHEDULE_STATE = B.SCHEDULE_STATE
											AND SCHEDULE_DATE = B.SCHEDULE_DATE
											AND AS_OF_DATE <= p_AS_OF_DATE)
	    			AND D.CUT_BEGIN_DATE <= C.CUT_DATE
	    			AND D.CUT_END_DATE >= C.CUT_DATE
	    			AND E.TEMPLATE_ID = p_TEMPLATE_ID
	    			AND E.SEASON_ID = D.SEASON_ID
	    			AND E.DAY_NAME = DECODE(IT.IS_HOLIDAY_S(C.LOCAL_DATE,A.EDC_ID),0,TO_CHAR(C.LOCAL_DATE,'Dy'),'Hol')
	    			AND TO_NUMBER(TO_CHAR(C.LOCAL_DATE-1/24,'HH24'))+1 BETWEEN E.BEGIN_HOUR AND E.END_HOUR
	    			AND F.PERIOD_ID = E.PERIOD_ID)
			GROUP BY SCHEDULE_DATE, ENTITY_ID, ENTITY_NAME, PERIOD_ID, PERIOD_NAME
    		UNION ALL
    		SELECT SCHEDULE_DATE,
                ENTITY_NAME,
            	ENTITY_ID,
    			1 "IS_TOTAL",
    			'Total' "PERIOD_NAME",
    			0 "PERIOD_ID",
    			SUM(LOAD) "LOAD",
    			MIN(LOAD_STATISTIC) "MIN_LOAD",
    			MAX(LOAD_STATISTIC) "MAX_LOAD",
    			AVG(LOAD_STATISTIC) "AVG_LOAD",
    			SUM(PURCHASE_AMOUNT-SALE_AMOUNT) "NET_SUPPLY_AMOUNT",
    			SUM(PURCHASE_AMOUNT*PURCHASE_PRICE-SALE_AMOUNT*SALE_PRICE) "NET_SUPPLY_COST",
    			DECODE(NVL(SUM(PURCHASE_AMOUNT-SALE_AMOUNT),0),0,0,SUM(PURCHASE_AMOUNT*PURCHASE_PRICE-SALE_AMOUNT*SALE_PRICE)/SUM(PURCHASE_AMOUNT-SALE_AMOUNT)) "NET_SUPPLY_WACOG",
    			SUM(PURCHASE_AMOUNT) "PURCHASE_AMOUNT",
    			SUM(PURCHASE_AMOUNT*PURCHASE_PRICE) "PURCHASE_COST",
    			DECODE(NVL(SUM(PURCHASE_AMOUNT),0),0,0,SUM(PURCHASE_AMOUNT*PURCHASE_PRICE)/SUM(PURCHASE_AMOUNT)) "PURCHASE_WACOG",
    			SUM(SALE_AMOUNT) "SALE_AMOUNT",
    			SUM(SALE_AMOUNT*SALE_PRICE) "SALE_COST",
    			DECODE(NVL(SUM(SALE_AMOUNT),0),0,0,SUM(SALE_AMOUNT*SALE_PRICE)/SUM(SALE_AMOUNT)) "SALE_WACOG"
    		FROM (SELECT A.ENTITY_ID, A.ENTITY_NAME,
						CASE v_INTERVAL
							WHEN 'HH' THEN C.HOUR_YYYY_MM_DD
							WHEN 'DD' THEN C.DAY_YYYY_MM_DD
							WHEN 'DY' THEN C.WEEK_YYYY_MM_DD
							WHEN 'MM' THEN C.MONTH_YYYY_MM_DD
							WHEN 'Q' THEN C.QUARTER_YYYY_MM_DD
							WHEN 'YY' THEN C.YEAR_YYYY_MM_DD
							ELSE C.NO_ROLLUP_YYYY_MM_DD
						END "SCHEDULE_DATE",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'LO', B.AMOUNT, 'RE', B.AMOUNT, NULL) "LOAD_STATISTIC",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'LO', NVL(B.AMOUNT,0),'RE', NVL(B.AMOUNT,0), 0) "LOAD",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'PU', NVL(B.AMOUNT,0),0) "PURCHASE_AMOUNT",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'PU', NVL(B.PRICE,0),0) "PURCHASE_PRICE",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'SA', NVL(B.AMOUNT,0),0) "SALE_AMOUNT",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'SA', NVL(B.PRICE,0),0) "SALE_PRICE"
				FROM (SELECT DECODE(UPPER(p_ENTITY_TYPE),'PURCHASER',A.PURCHASER_ID,
                										'SELLER',A.SELLER_ID,
                                                        'POR',A.POR_ID,
                                                        'POD',A.POD_ID,
                                                        'TP',C.TP_ID,
                                                        'EDC',C.EDC_ID) "ENTITY_ID",
    						DECODE(UPPER(p_ENTITY_TYPE),'PURCHASER',E.PSE_NAME,
                										'SELLER',F.PSE_NAME,
                                                        'POR',D.SERVICE_POINT_NAME,
                                                        'POD',C.SERVICE_POINT_ID,
                                                        'TP',G.TP_NAME,
                                                        'EDC',H.EDC_NAME) "ENTITY_NAME",
							A.TRANSACTION_ID,
							A.TRANSACTION_TYPE
    					FROM INTERCHANGE_TRANSACTION A,
    						IT_COMMODITY B,
    						SERVICE_POINT C,
    						SERVICE_POINT D,
    						PURCHASING_SELLING_ENTITY E,
    						PURCHASING_SELLING_ENTITY F,
    						TRANSMISSION_PROVIDER G,
    						ENERGY_DISTRIBUTION_COMPANY H
    					WHERE B.COMMODITY_ID = A.COMMODITY_ID
    						AND B.COMMODITY_TYPE = 'Energy'
    						AND C.SERVICE_POINT_ID(+) = A.POD_ID
    						AND D.SERVICE_POINT_ID(+) = A.POR_ID
    						AND E.PSE_ID(+) = A.PURCHASER_ID
    						AND F.PSE_ID(+) = A.SELLER_ID
    						AND G.TP_ID(+) = C.TP_ID
    						AND H.EDC_ID(+) = C.EDC_ID) A,
	   				IT_SCHEDULE B,
	   				SYSTEM_DATE_TIME C,
	   				RTO_WORK
	       		WHERE RTO_WORK.WORK_ID = v_WORK_ID
	       	        AND A.ENTITY_ID = RTO_WORK.WORK_XID
					AND C.TIME_ZONE = p_TIME_ZONE
					AND C.DATA_INTERVAL_TYPE = 1
					AND C.DAY_TYPE = 1
					AND C.CUT_DATE BETWEEN v_BEGIN_DATE_SDT AND v_END_DATE
					AND B.TRANSACTION_ID = A.TRANSACTION_ID
					AND B.SCHEDULE_TYPE = p_SCHEDULE_TYPE
					AND B.SCHEDULE_STATE = g_INTERNAL_STATE
					AND B.SCHEDULE_DATE = C.CUT_DATE_SCHEDULING
					AND B.SCHEDULE_DATE >= v_BEGIN_DATE
					AND B.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
										FROM IT_SCHEDULE
										WHERE TRANSACTION_ID = B.TRANSACTION_ID
											AND SCHEDULE_TYPE = B.SCHEDULE_TYPE
											AND SCHEDULE_STATE = B.SCHEDULE_STATE
											AND SCHEDULE_DATE = B.SCHEDULE_DATE
											AND AS_OF_DATE <= p_AS_OF_DATE))
			GROUP BY SCHEDULE_DATE, ENTITY_ID, ENTITY_NAME
	    	ORDER BY 4,5,6,1,2,3;
	ELSE
    	OPEN p_CURSOR FOR
    		SELECT SCHEDULE_DATE,
                ENTITY_NAME,
            	ENTITY_ID,
    			1 "IS_TOTAL",
    			'Total' "PERIOD_NAME",
    			0 "PERIOD_ID",
    			SUM(LOAD) "LOAD",
    			MIN(LOAD_STATISTIC) "MIN_LOAD",
    			MAX(LOAD_STATISTIC) "MAX_LOAD",
    			AVG(LOAD_STATISTIC) "AVG_LOAD",
    			SUM(PURCHASE_AMOUNT-SALE_AMOUNT) "NET_SUPPLY_AMOUNT",
    			SUM(PURCHASE_AMOUNT*PURCHASE_PRICE-SALE_AMOUNT*SALE_PRICE) "NET_SUPPLY_COST",
    			DECODE(NVL(SUM(PURCHASE_AMOUNT-SALE_AMOUNT),0),0,0,SUM(PURCHASE_AMOUNT*PURCHASE_PRICE-SALE_AMOUNT*SALE_PRICE)/SUM(PURCHASE_AMOUNT-SALE_AMOUNT)) "NET_SUPPLY_WACOG",
    			SUM(PURCHASE_AMOUNT) "PURCHASE_AMOUNT",
    			SUM(PURCHASE_AMOUNT*PURCHASE_PRICE) "PURCHASE_COST",
    			DECODE(NVL(SUM(PURCHASE_AMOUNT),0),0,0,SUM(PURCHASE_AMOUNT*PURCHASE_PRICE)/SUM(PURCHASE_AMOUNT)) "PURCHASE_WACOG",
    			SUM(SALE_AMOUNT) "SALE_AMOUNT",
    			SUM(SALE_AMOUNT*SALE_PRICE) "SALE_COST",
    			DECODE(NVL(SUM(SALE_AMOUNT),0),0,0,SUM(SALE_AMOUNT*SALE_PRICE)/SUM(SALE_AMOUNT)) "SALE_WACOG"
    		FROM (SELECT A.ENTITY_ID, A.ENTITY_NAME,
						CASE v_INTERVAL
							WHEN 'HH' THEN C.HOUR_YYYY_MM_DD
							WHEN 'DD' THEN C.DAY_YYYY_MM_DD
							WHEN 'DY' THEN C.WEEK_YYYY_MM_DD
							WHEN 'MM' THEN C.MONTH_YYYY_MM_DD
							WHEN 'Q' THEN C.QUARTER_YYYY_MM_DD
							WHEN 'YY' THEN C.YEAR_YYYY_MM_DD
							ELSE C.NO_ROLLUP_YYYY_MM_DD
						END "SCHEDULE_DATE",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'LO', B.AMOUNT, 'RE', B.AMOUNT, NULL) "LOAD_STATISTIC",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'LO', NVL(B.AMOUNT,0),'RE', NVL(B.AMOUNT,0), 0) "LOAD",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'PU', NVL(B.AMOUNT,0),0) "PURCHASE_AMOUNT",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'PU', NVL(B.PRICE,0),0) "PURCHASE_PRICE",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'SA', NVL(B.AMOUNT,0),0) "SALE_AMOUNT",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'SA', NVL(B.PRICE,0),0) "SALE_PRICE"
				FROM (SELECT DECODE(UPPER(p_ENTITY_TYPE),'PURCHASER',A.PURCHASER_ID,
                										'SELLER',A.SELLER_ID,
                                                        'POR',A.POR_ID,
                                                        'POD',A.POD_ID,
                                                        'TP',C.TP_ID,
                                                        'EDC',C.EDC_ID) "ENTITY_ID",
    						DECODE(UPPER(p_ENTITY_TYPE),'PURCHASER',E.PSE_NAME,
                										'SELLER',F.PSE_NAME,
                                                        'POR',D.SERVICE_POINT_NAME,
                                                        'POD',C.SERVICE_POINT_ID,
                                                        'TP',G.TP_NAME,
                                                        'EDC',H.EDC_NAME) "ENTITY_NAME",
							A.TRANSACTION_ID,
							A.TRANSACTION_TYPE
    					FROM INTERCHANGE_TRANSACTION A,
    						IT_COMMODITY B,
    						SERVICE_POINT C,
    						SERVICE_POINT D,
    						PURCHASING_SELLING_ENTITY E,
    						PURCHASING_SELLING_ENTITY F,
    						TRANSMISSION_PROVIDER G,
    						ENERGY_DISTRIBUTION_COMPANY H
    					WHERE B.COMMODITY_ID = A.COMMODITY_ID
    						AND B.COMMODITY_TYPE = 'Energy'
    						AND C.SERVICE_POINT_ID(+) = A.POD_ID
    						AND D.SERVICE_POINT_ID(+) = A.POR_ID
    						AND E.PSE_ID(+) = A.PURCHASER_ID
    						AND F.PSE_ID(+) = A.SELLER_ID
    						AND G.TP_ID(+) = C.TP_ID
    						AND H.EDC_ID(+) = C.EDC_ID) A,
	   				IT_SCHEDULE B,
	   				SYSTEM_DATE_TIME C,
	   				RTO_WORK
	       		WHERE RTO_WORK.WORK_ID = v_WORK_ID
	       	        AND A.ENTITY_ID = RTO_WORK.WORK_XID
					AND C.TIME_ZONE = p_TIME_ZONE
					AND C.DATA_INTERVAL_TYPE = 1
					AND C.DAY_TYPE = 1
					AND C.CUT_DATE BETWEEN v_BEGIN_DATE_SDT AND v_END_DATE
					AND B.TRANSACTION_ID = A.TRANSACTION_ID
					AND B.SCHEDULE_TYPE = p_SCHEDULE_TYPE
					AND B.SCHEDULE_STATE = g_INTERNAL_STATE
					AND B.SCHEDULE_DATE = C.CUT_DATE_SCHEDULING
					AND B.SCHEDULE_DATE >= v_BEGIN_DATE
					AND B.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
										FROM IT_SCHEDULE
										WHERE TRANSACTION_ID = B.TRANSACTION_ID
											AND SCHEDULE_TYPE = B.SCHEDULE_TYPE
											AND SCHEDULE_STATE = B.SCHEDULE_STATE
											AND SCHEDULE_DATE = B.SCHEDULE_DATE
											AND AS_OF_DATE <= p_AS_OF_DATE))
			GROUP BY SCHEDULE_DATE, ENTITY_ID, ENTITY_NAME
	    	ORDER BY 4,5,6,1,2,3;
    END IF;

	p_STATUS := GA.SUCCESS;
	UT.PURGE_RTO_WORK(v_WORK_ID);

EXCEPTION
	WHEN OTHERS THEN
    	UT.PURGE_RTO_WORK(v_WORK_ID);
        p_STATUS := SQLCODE;
END GET_ENERGY_SUMMARY;
---------------------------------------------------------------------------------------------------
FUNCTION IS_HOLIDAY_S
(
	p_DATE IN DATE,
	p_EDC_ID IN NUMBER DEFAULT 0
	) RETURN NUMBER DETERMINISTIC IS
BEGIN
	IF IS_HOLIDAY(p_DATE,p_EDC_ID) THEN
    	RETURN 1;
	ELSE
    	RETURN 0;
	END IF;
END IS_HOLIDAY_S;
---------------------------------------------------------------------------------------------------
END IT;
/
