CREATE OR REPLACE PACKAGE BODY RS AS

c_ACCEPTED_LOAD_SCHED_ATTR CONSTANT VARCHAR2(32) := 'Accepted Load Schedule';
g_USE_PSE_SCHED_CONFIG NUMBER(1);
g_ACCEPT_NON_INCUMBENT_ENTITY NUMBER(1);

-- Schedule Coordinator Type
TYPE v_SC_RECORD IS RECORD
(
	SC_ID 						NUMBER(9) := 0,
 	SC_SCHEDULE_NAME_PREFIX 	VARCHAR2(32),
 	SC_SCHEDULE_FORMAT 			VARCHAR2(32),
 	SC_SCHEDULE_INTERVAL 		VARCHAR2(16),
 	SC_LOAD_ROUNDING_PREFERENCE VARCHAR2(32),
 	SC_LOSS_ROUNDING_PREFERENCE VARCHAR2(32),
 	SC_CREATE_TX_LOSS_SCHEDULE 	NUMBER(1),
 	SC_CREATE_DX_LOSS_SCHEDULE 	NUMBER(1),
 	SC_CREATE_UFE_SCHEDULE 		NUMBER(1),
 	SC_MINIMUM_SCHEDULE_AMT 	NUMBER(8,3)
);

----------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
    RETURN '$Revision: 1.2 $';
END WHAT_VERSION;
----------------------------------------------------------------------------------------------------
FUNCTION SERVICE_IS_VERSIONED
	(
	p_REQUEST_TYPE IN CHAR
	)  RETURN BOOLEAN IS

-- Answer True if the Service is versioned for the specified request type; otherwise answer False.

BEGIN

	RETURN ((p_REQUEST_TYPE = GA.FORECAST_SERVICE AND GA.VERSION_FORECAST)
		OR (p_REQUEST_TYPE = GA.BACKCAST_SERVICE AND GA.VERSION_BACKCAST)
		OR (p_REQUEST_TYPE = GA.ACTUAL_SERVICE AND GA.VERSION_ACTUAL));

END SERVICE_IS_VERSIONED;
---------------------------------------------------------------------------------------------------
FUNCTION AS_OF_DATE_FOR_REQUEST
	(
	p_REQUEST_TYPE IN CHAR,
	p_AS_OF_DATE IN DATE
	)  RETURN DATE IS

-- Answer the Version As Of Date for this request.

v_VERSION_DOMAIN VARCHAR(32);

BEGIN

	SELECT DECODE(UPPER(SUBSTR(p_REQUEST_TYPE,1,1)),
		'F','Forecast',
		'B','Backcast',
		'U','Usage Allocation',
		--g_WILD_CARD,'Usage Allocation',
		'Forecast') INTO v_VERSION_DOMAIN FROM DUAL;

	IF SERVICE_IS_VERSIONED(p_REQUEST_TYPE) THEN
		RETURN CORRECTED_AS_OF_DATE(p_AS_OF_DATE, v_VERSION_DOMAIN);
	ELSE
		RETURN LOW_DATE;
	END IF;

END AS_OF_DATE_FOR_REQUEST;
---------------------------------------------------------------------------------------------------
FUNCTION IS_VERSIONED_REQUEST
	(
	p_REQUEST_TYPE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE
	)  RETURN BOOLEAN IS

-- Answer True if the request is for versioned data; otherwise answer False.

BEGIN

	RETURN (SERVICE_IS_VERSIONED(p_REQUEST_TYPE) AND p_AS_OF_DATE = CURRENT_VERSION_DATE AND NOT TRUNC(p_BEGIN_DATE) = TRUNC(p_END_DATE));

END IS_VERSIONED_REQUEST;
---------------------------------------------------------------------------------------------------
FUNCTION GET_INCUMBENT_ENTITY RETURN INCUMBENT_ENTITY%ROWTYPE IS

-- Answer the Incumbent Entity (ESP,EDC) of this installation;

v_INCUMBENT_ENTITY INCUMBENT_ENTITY%ROWTYPE;

BEGIN

	SELECT * INTO v_INCUMBENT_ENTITY FROM INCUMBENT_ENTITY WHERE ROWNUM = 1;

	RETURN v_INCUMBENT_ENTITY;

	 EXCEPTION
 		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN NULL;

END GET_INCUMBENT_ENTITY;
----------------------------------------------------------------------------------------------------
FUNCTION GET_CONTRACT_ID
    (
	p_BILLING_ENTITY_ID IN NUMBER
	)  RETURN NUMBER IS

-- Answer the interchange contract id associated with the counter party.

v_CONTRACT_ID NUMBER;

BEGIN

	SELECT CONTRACT_ID
	INTO v_CONTRACT_ID
	FROM INTERCHANGE_CONTRACT
	WHERE BILLING_ENTITY_ID = p_BILLING_ENTITY_ID
	    AND ROWNUM = 1;

	RETURN v_CONTRACT_ID;

	 EXCEPTION
 		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN 0;

END GET_CONTRACT_ID;
----------------------------------------------------------------------------------------------------
FUNCTION GET_CONTRACT_ID
    (
	p_CONTRACT_NAME IN VARCHAR
	)  RETURN NUMBER IS

-- Answer the interchange contract id associated with the counter party.

v_CONTRACT_ID NUMBER;

BEGIN

	SELECT CONTRACT_ID
	INTO v_CONTRACT_ID
	FROM INTERCHANGE_CONTRACT
	WHERE CONTRACT_NAME = p_CONTRACT_NAME
	    AND ROWNUM = 1;

	RETURN v_CONTRACT_ID;

	 EXCEPTION
 		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN CONSTANTS.NOT_ASSIGNED;

END GET_CONTRACT_ID;
----------------------------------------------------------------------------------------------------
FUNCTION GET_TRANSACTION_PSE_ID
    (
	p_TRANSACTION_ID IN NUMBER
	)  RETURN NUMBER IS

-- Answer the interchange contract id associated with the counter party.

v_PSE_ID NUMBER;

BEGIN

	SELECT NVL(PSE_ID, CONSTANTS.NOT_ASSIGNED)
	INTO v_PSE_ID
	FROM INTERCHANGE_TRANSACTION
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

	RETURN v_PSE_ID;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN CONSTANTS.NOT_ASSIGNED;
END GET_TRANSACTION_PSE_ID;
----------------------------------------------------------------------------------------------------
FUNCTION GET_PSE_LOAD_CONTRACT_NAME
	(
	p_PSE_ID IN NUMBER,
	p_TRANSACTION_ID IN NUMBER
	)  RETURN VARCHAR IS

v_CONTRACT_NAME VARCHAR(32);

BEGIN

	SELECT SUBSTR(PSE_ALIAS, 1, 27) || ' Load'
	INTO v_CONTRACT_NAME
	FROM PURCHASING_SELLING_ENTITY
	WHERE PSE_ID = p_PSE_ID;

    IF p_PSE_ID = 0 AND p_TRANSACTION_ID > 0 THEN
    	SELECT B.CONTRACT_NAME
        INTO v_CONTRACT_NAME
        FROM INTERCHANGE_TRANSACTION A, INTERCHANGE_CONTRACT B
        WHERE A.TRANSACTION_ID = p_TRANSACTION_ID
        	AND B.CONTRACT_ID = A.CONTRACT_ID;
    END IF;


	RETURN v_CONTRACT_NAME;

 EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN 'Contract Not Assigned Load';

END GET_PSE_LOAD_CONTRACT_NAME;
----------------------------------------------------------------------------------------------------
FUNCTION GET_ESP_FOR_PSE_OF_RECORD
	(
	p_PSE_ID IN NUMBER,
	p_SERVICE_DATE IN DATE
	) RETURN NUMBER IS

-- Answer the first ESP assignment of record for an PSE for the service date;
-- otherwise answer the not_unassigned flag when there is not an assigned PSE.

CURSOR c_PSE_ESP IS
	SELECT ESP_ID
	FROM PSE_ESP
	WHERE PSE_ID = p_PSE_ID
		AND p_SERVICE_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE);

v_ESP_ID NUMBER := CONSTANTS.NOT_ASSIGNED;
v_COUNT PLS_INTEGER := 0;

BEGIN

	FOR v_PSE_ESP IN c_PSE_ESP LOOP
		v_ESP_ID := v_PSE_ESP.ESP_ID;
		v_COUNT := v_COUNT + 1;
	END LOOP;

	IF v_COUNT > 1 THEN
		RETURN CONSTANTS.NOT_ASSIGNED;
	ELSE
		RETURN v_ESP_ID;
	END IF;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN CONSTANTS.NOT_ASSIGNED;

END GET_ESP_FOR_PSE_OF_RECORD;
----------------------------------------------------------------------------------------------------
FUNCTION DECODE_ROUNDING_PREFERENCE
    (
	p_ROUNDING_PREFERENCE IN VARCHAR
	) RETURN CHAR IS

v_ROUNDING_PREFERENCE CHAR(1);

BEGIN

	SELECT DECODE(UPPER(p_ROUNDING_PREFERENCE),
	    'NONE', 'N',
	    'ROUND UP', 'U',
	    'ROUND DOWN', 'D',
	    'ROUND STANDARD', 'S',
	    'CARRY FORWARD ROUND UP', 'C',
	    'CARRY FORWARD ROUND DOWN', 'C',
	    'CARRY FORWARD ROUND STANDARD', 'C',
		'X') INTO v_ROUNDING_PREFERENCE FROM DUAL;

	RETURN v_ROUNDING_PREFERENCE;

END DECODE_ROUNDING_PREFERENCE;
----------------------------------------------------------------------------------------------------
FUNCTION DECODE_CARRY_FORWARD_OPTION
    (
	p_ROUNDING_PREFERENCE IN VARCHAR
	) RETURN CHAR IS

-- Answer the rounding code for the carry forward loss option code in effect for the EDC;

v_CARRY_FORWARD_OPTION CHAR(1);

BEGIN

	SELECT DECODE(UPPER(p_ROUNDING_PREFERENCE),
	    'CARRY FORWARD ROUND UP', 'U',
	    'CARRY FORWARD ROUND DOWN', 'D',
	    'CARRY FORWARD ROUND STANDARD', 'S',
		'X') INTO v_CARRY_FORWARD_OPTION FROM DUAL;

	RETURN v_CARRY_FORWARD_OPTION;

END DECODE_CARRY_FORWARD_OPTION;
----------------------------------------------------------------------------------------------------
FUNCTION GET_DAYS_IN_PATTERN
	(
	p_RUN_MODE IN NUMBER,
	p_LOAD_CODE IN CHAR,
	p_LOAD_DATE IN DATE,
	p_EDC_ID IN NUMBER DEFAULT CONSTANTS.NOT_ASSIGNED
	)  RETURN NUMBER IS

v_DAYS NUMBER(2) := 0;
v_LOAD_DATE DATE;
v_END_DATE DATE;

BEGIN

	v_LOAD_DATE := TRUNC(FROM_CUT(p_LOAD_DATE, LOCAL_TIME_ZONE) - g_SECOND);
	IF p_RUN_MODE = GA.MONTH_MODE THEN
		v_END_DATE := LAST_DAY(v_LOAD_DATE);
	ELSIF p_RUN_MODE = GA.WEEK_MODE THEN
		v_END_DATE := v_LOAD_DATE + 6;
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('GET_DAYS_IN_PATTERN RUN_MODE=' || TO_CHAR(p_RUN_MODE) || ', LOAD_CODE=' || p_LOAD_CODE || ', LOAD_DATE=' || TO_CHAR(v_LOAD_DATE) || ', END_DATE=' || TO_CHAR(v_END_DATE));
	END IF;

	WHILE v_LOAD_DATE <= v_END_DATE LOOP
		IF p_LOAD_CODE = GA.WEEK_DAY AND TO_CHAR(v_LOAD_DATE, 'DY') NOT IN ('SAT','SUN') AND NOT IS_HOLIDAY(v_LOAD_DATE, p_EDC_ID) THEN
			v_DAYS := v_DAYS + 1;
		ELSIF p_LOAD_CODE = GA.WEEK_END AND (TO_CHAR(v_LOAD_DATE, 'DY') IN ('SAT','SUN') OR IS_HOLIDAY(v_LOAD_DATE, p_EDC_ID)) THEN
			v_DAYS := v_DAYS + 1;
		END IF;
		v_LOAD_DATE := v_LOAD_DATE + 1;
	END LOOP;

	RETURN v_DAYS;

END GET_DAYS_IN_PATTERN;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_PROCESS_STATUS
	(
	p_PROCESS_NAME IN VARCHAR,
	p_PROCESS_DATE IN DATE,
	p_PROCESS_STATE IN CHAR,
	p_PROCESS_SYSDATE IN DATE,
	p_PROCESS_AS_OF_DATE IN DATE
	) AS

BEGIN

	UPDATE PROCESS_STATUS
	SET	PROCESS_STATE = p_PROCESS_STATE,
	    PROCESS_SYSDATE = p_PROCESS_SYSDATE
	WHERE PROCESS_NAME = p_PROCESS_NAME
	    AND PROCESS_DATE = p_PROCESS_DATE
		 AND PROCESS_AS_OF_DATE = p_PROCESS_AS_OF_DATE;

	IF SQL%NOTFOUND THEN
		INSERT INTO PROCESS_STATUS (
		    PROCESS_NAME,
			PROCESS_DATE,
			PROCESS_AS_OF_DATE,
			PROCESS_STATE,
			PROCESS_SYSDATE)
		VALUES (
		    p_PROCESS_NAME,
			p_PROCESS_DATE,
			p_PROCESS_AS_OF_DATE,
			p_PROCESS_STATE,
			p_PROCESS_SYSDATE);
	END IF;
END PUT_PROCESS_STATUS;
----------------------------------------------------------------------------------------------------
PROCEDURE ACCEPT_PROCESS_STATUS
	(
	p_REQUEST_TYPE IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE
	) AS

v_SERVICE_DATE DATE;
v_PROCESS_NAME VARCHAR(32);
v_AS_OF_DATE DATE;

BEGIN

	SELECT DECODE(p_REQUEST_TYPE, GA.FORECAST_SERVICE, 'Forecast', GA.BACKCAST_SERVICE, 'Backcast', GA.ACTUAL_SERVICE, 'Usage Allocation', '?') INTO v_PROCESS_NAME FROM DUAL;
	v_AS_OF_DATE := CORRECTED_AS_OF_DATE(p_AS_OF_DATE,v_PROCESS_NAME);
	v_SERVICE_DATE := TRUNC(p_BEGIN_DATE);
	WHILE v_SERVICE_DATE <= TRUNC(p_END_DATE) LOOP
	    PUT_PROCESS_STATUS(v_PROCESS_NAME, v_SERVICE_DATE, 'Accepted', SYSDATE, v_AS_OF_DATE);
		v_SERVICE_DATE := v_SERVICE_DATE + 1;
	END LOOP;
END ACCEPT_PROCESS_STATUS;
----------------------------------------------------------------------------------------------------
PROCEDURE SET_INTERCHANGE_CONTRACT
	(
	p_TRANSACTION_ID IN NUMBER,
	p_CONTRACT_ID IN NUMBER,
	p_CONTRACT_NAME IN VARCHAR,
	p_BILLING_ENTITY_ID IN NUMBER
	) AS

v_COUNT NUMBER(1);

BEGIN

	SELECT COUNT(*)
	INTO v_COUNT
	FROM INTERCHANGE_CONTRACT
	WHERE CONTRACT_NAME = p_CONTRACT_NAME
	 AND CONTRACT_ID = p_CONTRACT_ID;

	IF v_COUNT = 0 THEN
		INSERT INTO INTERCHANGE_CONTRACT (
		    CONTRACT_ID,
			CONTRACT_NAME,
			CONTRACT_ALIAS,
			CONTRACT_DESC,
			BILLING_ENTITY_ID,
			AGREEMENT_TYPE,
			BEGIN_DATE,
			END_DATE,
			IS_EVERGREEN,
			ENTRY_DATE)
		VALUES (
		    p_CONTRACT_ID,
			p_CONTRACT_NAME,
			p_CONTRACT_NAME,
			'Contract created by RetailOffice to support City Gate Load Schedules',
			p_BILLING_ENTITY_ID,
			'Default',
			LOW_DATE,
			HIGH_DATE,
			0,
			SYSDATE);
	END IF;

	UPDATE INTERCHANGE_TRANSACTION SET CONTRACT_ID = p_CONTRACT_ID WHERE TRANSACTION_ID = p_TRANSACTION_ID;

END SET_INTERCHANGE_CONTRACT;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_LOAD_TRANSACTION_ID
    (
	p_MODEL_ID IN NUMBER,
	p_TRANSACTION_NAME IN VARCHAR,
	p_LOAD_OBLIGATION IN LOAD_OBLIGATION%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_LINK_TRANSACTION_ID IN NUMBER,
	p_TRANSACTION_ID OUT NUMBER
	) AS

-- Answer the transaction Id for the specified load transaction.
-- Create an energy commodity  retail transaction if one does not exist.

v_COMMODITY_NAME 	VARCHAR(32);
v_COMMODITY_TYPE 	VARCHAR(16);
v_COMMODITY_UNIT 	VARCHAR(16);
v_COMMODITY_ID 		NUMBER;
v_CONTRACT_ID 		NUMBER;
v_ESP_ID 			NUMBER;
v_SERVICE_POINT_ID	NUMBER := p_LOAD_OBLIGATION.SERVICE_POINT_ID;
v_SERVICE_ZONE_ID	NUMBER := p_LOAD_OBLIGATION.SERVICE_ZONE_ID;

BEGIN

	v_ESP_ID := p_LOAD_OBLIGATION.ESP_ID;
	IF v_ESP_ID = CONSTANTS.NOT_ASSIGNED THEN
		v_ESP_ID := GET_ESP_FOR_PSE_OF_RECORD(p_LOAD_OBLIGATION.PSE_ID, p_BEGIN_DATE);
	END IF;

	SELECT DECODE(p_MODEL_ID, CONSTANTS.GAS_MODEL, 'Gas', 'Retail Load') INTO v_COMMODITY_NAME FROM DUAL;
	SELECT DECODE(p_MODEL_ID, CONSTANTS.GAS_MODEL, 'Gas', 'Energy') INTO v_COMMODITY_TYPE FROM DUAL;
	SELECT DECODE(p_MODEL_ID, CONSTANTS.GAS_MODEL, 'DT', 'MWH') INTO v_COMMODITY_UNIT FROM DUAL;

	BEGIN
		-- first look for transaction by alias
		SELECT TRANSACTION_ID
		INTO p_TRANSACTION_ID
		FROM INTERCHANGE_TRANSACTION
		WHERE TRANSACTION_ALIAS = p_TRANSACTION_NAME;
	EXCEPTION
		-- not found? then use ID package to search by name
		WHEN OTHERS THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			ID.ID_FOR_TRANSACTION(p_TRANSACTION_NAME, 'Load', FALSE, p_TRANSACTION_ID);
	END;
	IF p_TRANSACTION_ID <= 0 THEN
		ID.ID_FOR_TRANSACTION(p_TRANSACTION_NAME, 'Load', TRUE, p_TRANSACTION_ID);
		v_CONTRACT_ID := GET_CONTRACT_ID(p_LOAD_OBLIGATION.PSE_ID);
		ID.ID_FOR_COMMODITY(v_COMMODITY_NAME, FALSE, v_COMMODITY_ID);
		IF v_COMMODITY_ID = GA.NO_DATA_FOUND THEN
			ID.ID_FOR_COMMODITY(v_COMMODITY_NAME, TRUE, v_COMMODITY_ID);
			UPDATE IT_COMMODITY SET
				COMMODITY_TYPE = v_COMMODITY_TYPE,
				COMMODITY_UNIT = v_COMMODITY_UNIT
			WHERE COMMODITY_ID = v_COMMODITY_ID;
		END IF;
		-- If service point and zone are unspecified, but schedule group is specified, load
		-- service point and zone from the schedule group
		IF NVL(v_SERVICE_POINT_ID,CONSTANTS.NOT_ASSIGNED) = CONSTANTS.NOT_ASSIGNED
			AND p_LOAD_OBLIGATION.SCHEDULE_GROUP_ID <> CONSTANTS.NOT_ASSIGNED THEN

			SELECT NVL(MAX(SERVICE_POINT_ID), CONSTANTS.NOT_ASSIGNED)
			INTO v_SERVICE_POINT_ID
			FROM SCHEDULE_GROUP
			WHERE SCHEDULE_GROUP_ID = p_LOAD_OBLIGATION.SCHEDULE_GROUP_ID;
		END IF;
		IF NVL(v_SERVICE_ZONE_ID,CONSTANTS.NOT_ASSIGNED) = CONSTANTS.NOT_ASSIGNED
			AND p_LOAD_OBLIGATION.SCHEDULE_GROUP_ID <> CONSTANTS.NOT_ASSIGNED THEN

			SELECT NVL(MAX(SERVICE_ZONE_ID), CONSTANTS.NOT_ASSIGNED)
			INTO v_SERVICE_ZONE_ID
			FROM SCHEDULE_GROUP
			WHERE SCHEDULE_GROUP_ID = p_LOAD_OBLIGATION.SCHEDULE_GROUP_ID;
		END IF;

		UPDATE INTERCHANGE_TRANSACTION SET
			BEGIN_DATE = TRUNC(p_BEGIN_DATE),
			END_DATE = TRUNC(p_END_DATE),
			TRANSACTION_INTERVAL = p_LOAD_OBLIGATION.OBLIGATION_INTERVAL,
			EXTERNAL_INTERVAL = p_LOAD_OBLIGATION.OBLIGATION_INTERVAL,
			TRANSACTION_CODE = 1,
			CONTRACT_ID = v_CONTRACT_ID,
			COMMODITY_ID = v_COMMODITY_ID,
			PURCHASER_ID = p_LOAD_OBLIGATION.PSE_ID,
			SELLER_ID = p_LOAD_OBLIGATION.PSE_ID,
			POR_ID = v_SERVICE_POINT_ID,
			POD_ID = v_SERVICE_POINT_ID,
			ZOR_ID = v_SERVICE_ZONE_ID,
			ZOD_ID = v_SERVICE_ZONE_ID,
			SC_ID = p_LOAD_OBLIGATION.SC_ID,
			PSE_ID = p_LOAD_OBLIGATION.PSE_ID,
			ESP_ID = v_ESP_ID,
			EDC_ID = p_LOAD_OBLIGATION.EDC_ID,
			POOL_ID = p_LOAD_OBLIGATION.POOL_ID,
			IS_EXPORT_SCHEDULE = 1,
			SCHEDULE_GROUP_ID = p_LOAD_OBLIGATION.SCHEDULE_GROUP_ID,
			LINK_TRANSACTION_ID = p_LINK_TRANSACTION_ID,
			ENTRY_DATE = SYSDATE
		WHERE TRANSACTION_ID = p_TRANSACTION_ID;
	ELSE
		UPDATE INTERCHANGE_TRANSACTION SET
			BEGIN_DATE = TRUNC(p_BEGIN_DATE),
			ENTRY_DATE = SYSDATE
		WHERE TRANSACTION_ID = p_TRANSACTION_ID
			AND TRUNC(p_BEGIN_DATE) < BEGIN_DATE;
		UPDATE INTERCHANGE_TRANSACTION SET
			END_DATE = TRUNC(p_END_DATE),
			ENTRY_DATE = SYSDATE
		WHERE TRANSACTION_ID = p_TRANSACTION_ID
			AND TRUNC(p_END_DATE) > END_DATE;
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('GET_LOAD_TRANSACTION_ID');
		LOGS.LOG_DEBUG('TRANSACTION_NAME=' || p_TRANSACTION_NAME);
		LOGS.LOG_DEBUG('COMMODITY_NAME=' || v_COMMODITY_NAME);
		LOGS.LOG_DEBUG('COMMODITY_TYPE=' || v_COMMODITY_TYPE);
		LOGS.LOG_DEBUG('SC_ID=' || TO_CHAR(p_LOAD_OBLIGATION.SC_ID));
		LOGS.LOG_DEBUG('PSE_ID=' || TO_CHAR(p_LOAD_OBLIGATION.PSE_ID));
		LOGS.LOG_DEBUG('ESP_ID=' || TO_CHAR(p_LOAD_OBLIGATION.ESP_ID));
		LOGS.LOG_DEBUG('POOL_ID=' || TO_CHAR(p_LOAD_OBLIGATION.POOL_ID));
		LOGS.LOG_DEBUG('POR_ID=' || TO_CHAR(p_LOAD_OBLIGATION.SERVICE_POINT_ID));
		LOGS.LOG_DEBUG('ZOR_ID=' || TO_CHAR(p_LOAD_OBLIGATION.SERVICE_ZONE_ID));
		LOGS.LOG_DEBUG('SERVICE_TYPE_ID=' || TO_CHAR(p_LOAD_OBLIGATION.SCHEDULE_GROUP_ID));
		LOGS.LOG_DEBUG('LINK_TRANSACTION_ID=' || TO_CHAR(p_LINK_TRANSACTION_ID));
		LOGS.LOG_DEBUG('TRANSACTION_ID=' || TO_CHAR(p_TRANSACTION_ID));
	END IF;

END GET_LOAD_TRANSACTION_ID;
----------------------------------------------------------------------------------------------------
-- Delete the schedule for one Txn for the specified date range.
PROCEDURE DELETE_LOAD_SCHEDULE_FOR_TXN
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_AS_OF_DATE IN DATE
	) AS
	v_INTERVAL INTERCHANGE_TRANSACTION.TRANSACTION_INTERVAL%TYPE;
	v_BEGIN_DATE DATE;
	v_END_DATE DATE;
BEGIN

	v_INTERVAL := GET_INTERVAL_ABBREVIATION(DATE_UTIL.GET_INTERVAL_FOR_TRANSACTION(p_TRANSACTION_ID));
	DATE_UTIL.CUT_DATE_RANGE_SCHEDULING(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_INTERVAL, v_INTERVAL, v_BEGIN_DATE, v_END_DATE);

	DELETE IT_SCHEDULE
	WHERE TRANSACTION_ID = p_TRANSACTION_ID
		AND SCHEDULE_TYPE = p_SCHEDULE_TYPE
		AND SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE
		AND SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND AS_OF_DATE = p_AS_OF_DATE;

END DELETE_LOAD_SCHEDULE_FOR_TXN;
----------------------------------------------------------------------------------------------------
-- Copy the schedule from LOAD_OBLIGATION_SCHEDULE into IT_SCHEDULE for the specified date range and entity.
PROCEDURE SAVE_SCHEDULE
	(
	p_MODEL_ID IN NUMBER,
	p_OBLIGATION_ID IN NUMBER,
	p_OBLIGATION_TYPE IN VARCHAR2,
	p_OBLIGATION_INTERVAL IN VARCHAR2,
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_AS_OF_DATE IN DATE
	) AS
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_ATLEAST_DAILY NUMBER;
v_EXISTING_COUNT NUMBER;
v_EXISTING_BEGIN_DATE DATE;

BEGIN
	DELETE_LOAD_SCHEDULE_FOR_TXN(p_TRANSACTION_ID, p_SCHEDULE_TYPE, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_AS_OF_DATE);

	--This gets the date range of the Obligation data, not the Scheduling data.
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	v_ATLEAST_DAILY := CASE WHEN INTERVAL_IS_ATLEAST_DAILY(p_OBLIGATION_INTERVAL) THEN 1 ELSE 0 END;

	INSERT INTO IT_SCHEDULE (TRANSACTION_ID, SCHEDULE_TYPE, SCHEDULE_STATE, SCHEDULE_DATE, AS_OF_DATE, AMOUNT)
	SELECT p_TRANSACTION_ID,
		p_SCHEDULE_TYPE,
		CONSTANTS.INTERNAL_STATE,
		CASE WHEN v_ATLEAST_DAILY=1 THEN TRUNC(OBLIGATION_DATE)+1/86400 ELSE OBLIGATION_DATE END,
		p_AS_OF_DATE,
		OBLIGATION_LOAD_VAL
	FROM LOAD_OBLIGATION_SCHEDULE
	WHERE OBLIGATION_ID = p_OBLIGATION_ID
		AND OBLIGATION_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
	   	AND OBLIGATION_TYPE = p_OBLIGATION_TYPE;

	-- Set up the Entity Attribute so we know this data came from the Accept process.
	-- Check to see if there's an existing Accept Load Schedule record that ends one day before the begin date
	SELECT COUNT(*) INTO v_EXISTING_COUNT FROM TEMPORAL_ENTITY_ATTRIBUTE WHERE END_DATE = (p_BEGIN_DATE - 1) AND OWNER_ENTITY_ID = p_TRANSACTION_ID AND ATTRIBUTE_NAME = c_ACCEPTED_LOAD_SCHED_ATTR;
	IF v_EXISTING_COUNT = 1 THEN
		SELECT BEGIN_DATE INTO v_EXISTING_BEGIN_DATE FROM TEMPORAL_ENTITY_ATTRIBUTE WHERE END_DATE = (p_BEGIN_DATE - 1) AND OWNER_ENTITY_ID = p_TRANSACTION_ID AND ATTRIBUTE_NAME = c_ACCEPTED_LOAD_SCHED_ATTR;
		RO.PUT_ENTITY_ATTRIBUTE(c_ACCEPTED_LOAD_SCHED_ATTR, EC.ED_TRANSACTION, p_TRANSACTION_ID, 'Boolean', '1', v_EXISTING_BEGIN_DATE, p_END_DATE);
	ELSE
		RO.PUT_ENTITY_ATTRIBUTE(c_ACCEPTED_LOAD_SCHED_ATTR, EC.ED_TRANSACTION, p_TRANSACTION_ID, 'Boolean', '1', p_BEGIN_DATE, p_END_DATE);
	END IF;

END SAVE_SCHEDULE;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_EDC
	(
	p_EDC_ID IN NUMBER,
	p_EDC OUT ENERGY_DISTRIBUTION_COMPANY%ROWTYPE
	) AS

-- Answer the EDC record for the specified EDC Id;

BEGIN

    SELECT * INTO p_EDC FROM ENERGY_DISTRIBUTION_COMPANY WHERE EDC_ID = p_EDC_ID;

	 EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			p_EDC := NULL;
END GET_EDC;
----------------------------------------------------------------------------------------------------
FUNCTION GET_SCHEDULE_COORDINATOR
	(
	p_SC_ID IN NUMBER
	) RETURN SCHEDULE_COORDINATOR%ROWTYPE IS

-- Answer the SC record for the specified SC Id;

v_SC SCHEDULE_COORDINATOR%ROWTYPE;

BEGIN

    SELECT * INTO v_SC FROM SCHEDULE_COORDINATOR WHERE SC_ID = p_SC_ID;

	RETURN v_SC;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN NULL;

END GET_SCHEDULE_COORDINATOR;
----------------------------------------------------------------------------------------------------
FUNCTION GET_PSE_ALIAS
	(
	p_PSE_ID IN NUMBER
	) RETURN VARCHAR IS

-- Answer the PSE Alias for the specified PSE Id;

v_PSE_ALIAS VARCHAR(32);

BEGIN

	IF p_PSE_ID = g_WHOLESALE THEN
		v_PSE_ALIAS := 'Wholesale';
	ELSE
		SELECT PSE_ALIAS INTO v_PSE_ALIAS FROM PURCHASING_SELLING_ENTITY WHERE PSE_ID = p_PSE_ID AND ROWNUM = 1;
	END IF;

	RETURN v_PSE_ALIAS;

 	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN '';

END GET_PSE_ALIAS;
----------------------------------------------------------------------------------------------------
FUNCTION GET_POOL_ALIAS
	(
	p_POOL_ID IN NUMBER
	) RETURN VARCHAR IS

-- Answer the Pool Alias for the specified Pool Id;

v_POOL_ALIAS VARCHAR(32);

BEGIN

	SELECT POOL_ALIAS INTO v_POOL_ALIAS FROM POOL WHERE POOL_ID = p_POOL_ID;

	RETURN v_POOL_ALIAS;

 	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN '';

END GET_POOL_ALIAS;
----------------------------------------------------------------------------------------------------
FUNCTION GET_SERVICE_POINT_ALIAS
	(
	p_SERVICE_POINT_ID IN NUMBER
	) RETURN VARCHAR IS

-- Answer the SERVICE_POINT Alias for the specified p_SERVICE_POINT_ID;

v_SERVICE_POINT_ALIAS VARCHAR(32);

BEGIN

	SELECT SERVICE_POINT_ALIAS INTO v_SERVICE_POINT_ALIAS FROM SERVICE_POINT WHERE SERVICE_POINT_ID = p_SERVICE_POINT_ID AND ROWNUM = 1;

	RETURN v_SERVICE_POINT_ALIAS;

 	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN '';

END GET_SERVICE_POINT_ALIAS;
----------------------------------------------------------------------------------------------------
FUNCTION GET_SCHEDULE_GROUP_ALIAS
	(
	p_SCHEDULE_GROUP_ID IN NUMBER
	) RETURN VARCHAR IS

-- Answer the SCHEDULE_GROUP Alias for the specified Schedule Group Id;

v_SCHEDULE_GROUP_ALIAS VARCHAR(32);

BEGIN

	SELECT SCHEDULE_GROUP_ALIAS INTO v_SCHEDULE_GROUP_ALIAS FROM SCHEDULE_GROUP WHERE SCHEDULE_GROUP_ID = p_SCHEDULE_GROUP_ID AND ROWNUM = 1;

	RETURN v_SCHEDULE_GROUP_ALIAS;

 	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN '';

END GET_SCHEDULE_GROUP_ALIAS;
----------------------------------------------------------------------------------------------------
FUNCTION GET_SERVICE_TYPE_ALIAS
	(
	p_SERVICE_TYPE_ID IN NUMBER
	) RETURN VARCHAR IS

-- Answer the SERVICE_TYPE Alias for the specified Service Type Id;

v_SERVICE_TYPE_ALIAS VARCHAR(32);

BEGIN

	SELECT SERVICE_TYPE_ALIAS INTO v_SERVICE_TYPE_ALIAS FROM TX_SERVICE_TYPE WHERE SERVICE_TYPE_ID = p_SERVICE_TYPE_ID AND ROWNUM = 1;

	RETURN v_SERVICE_TYPE_ALIAS;

 	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN '';

END GET_SERVICE_TYPE_ALIAS;
----------------------------------------------------------------------------------------------------
FUNCTION GET_SERVICE_ZONE_ALIAS
	(
	p_SERVICE_ZONE_ID IN NUMBER
	) RETURN VARCHAR IS

-- Answer the SERVICE_ZONE Alias for the specified Service Zone Id;

v_SERVICE_ZONE_ALIAS VARCHAR(32);

BEGIN

	SELECT SERVICE_ZONE_ALIAS INTO v_SERVICE_ZONE_ALIAS FROM SERVICE_ZONE WHERE SERVICE_ZONE_ID = p_SERVICE_ZONE_ID;

	RETURN v_SERVICE_ZONE_ALIAS;

 	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN '';

END GET_SERVICE_ZONE_ALIAS;
----------------------------------------------------------------------------------------------------
FUNCTION GET_SERVICE_ZONE_ID
	(
	p_SCHEDULE_GROUP_ID IN NUMBER
	) RETURN NUMBER IS

-- Answer the Service Zone Id Associated with the specified Schedule Group Id;

v_SERVICE_ZONE_ID NUMBER(9);

BEGIN

	SELECT NVL(SERVICE_ZONE_ID, CONSTANTS.NOT_ASSIGNED) INTO v_SERVICE_ZONE_ID FROM SCHEDULE_GROUP WHERE SCHEDULE_GROUP_ID = p_SCHEDULE_GROUP_ID;

	RETURN v_SERVICE_ZONE_ID;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN CONSTANTS.NOT_ASSIGNED;

END GET_SERVICE_ZONE_ID;
----------------------------------------------------------------------------------------------------
FUNCTION GET_TRANSACTION_NAME
	(
	p_TRANSACTION_ID IN NUMBER
	) RETURN VARCHAR IS

-- Answer the TRANSACTION Name for the specified Transaction Id;

v_TRANSACTION_NAME INTERCHANGE_TRANSACTION.TRANSACTION_NAME%TYPE;

BEGIN

	SELECT TRANSACTION_NAME INTO v_TRANSACTION_NAME FROM INTERCHANGE_TRANSACTION WHERE TRANSACTION_ID = p_TRANSACTION_ID AND ROWNUM = 1;

	RETURN v_TRANSACTION_NAME;

 	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN '';

END GET_TRANSACTION_NAME;
----------------------------------------------------------------------------------------------------
FUNCTION MAKE_OBLIGATION_NAME
	(
	p_NAME_PREFIX IN VARCHAR,
	p_PSE_ALIAS IN VARCHAR,
	p_POOL_ALIAS IN VARCHAR,
	p_SERVICE_POINT_ALIAS IN VARCHAR,
	p_SCHEDULE_GROUP_ALIAS IN VARCHAR,
	p_SERVICE_ZONE_ALIAS IN VARCHAR,
	p_OBLIGATION_LOAD_CODE IN CHAR,
	p_RUN_MODE IN NUMBER,
	p_SCHEDULE_FORMAT IN VARCHAR
	) RETURN VARCHAR IS

-- Answer the Load Obligation Name

v_OBLIGATION_NAME VARCHAR(128) := '';
v_SUFFIX CHAR(7);
v_NAME_PREFIX VARCHAR(32) := LTRIM(RTRIM(p_NAME_PREFIX));

BEGIN

-- Form the Root of the Obligation Name using the optional SC Name Prefix with the PSE Alias.
	IF NVL(v_NAME_PREFIX, GA.UNDEFINED_ATTRIBUTE) = GA.UNDEFINED_ATTRIBUTE THEN
		v_OBLIGATION_NAME := p_PSE_ALIAS || '@';
	ELSE
 		v_OBLIGATION_NAME := v_NAME_PREFIX || '-' || p_PSE_ALIAS || '@';
	END IF;

-- Tack on a Qualifier Based Upon the Selected Schedule Format.
	IF p_SCHEDULE_FORMAT IN ('SERVICE POINT','POD') THEN
		v_OBLIGATION_NAME := v_OBLIGATION_NAME || p_SERVICE_POINT_ALIAS;
	ELSIF p_SCHEDULE_FORMAT IN ('POOL','POOL/SUB-POOL') THEN
		v_OBLIGATION_NAME := v_OBLIGATION_NAME || p_POOL_ALIAS;
	ELSIF p_SCHEDULE_FORMAT = 'SCHEDULE GROUP' THEN
		v_OBLIGATION_NAME := v_OBLIGATION_NAME || p_SCHEDULE_GROUP_ALIAS;
	ELSIF p_SCHEDULE_FORMAT = 'SERVICE ZONE' THEN
		v_OBLIGATION_NAME := v_OBLIGATION_NAME || p_SERVICE_ZONE_ALIAS;
	END IF;

-- Add A Suffix to Denote a Weekday or Weekend Pattern Schedule for Monthly and Weekly Long-Term Forecasts.
	IF p_OBLIGATION_LOAD_CODE IN (GA.WEEK_DAY, GA.WEEK_END) THEN
		IF p_OBLIGATION_LOAD_CODE = GA.WEEK_DAY AND p_RUN_MODE = GA.WEEK_MODE THEN
			v_SUFFIX := '(WK-WD)';
		ELSIF p_OBLIGATION_LOAD_CODE = GA.WEEK_END AND p_RUN_MODE = GA.WEEK_MODE THEN
			v_SUFFIX :=  '(WK-WE)';
		ELSIF p_OBLIGATION_LOAD_CODE = GA.WEEK_DAY AND p_RUN_MODE = GA.MONTH_MODE THEN
			v_SUFFIX := '(MO-WD)';
		ELSIF p_OBLIGATION_LOAD_CODE = GA.WEEK_END AND p_RUN_MODE = GA.MONTH_MODE THEN
			v_SUFFIX := '(MO-WE)';
		END IF;
		IF LENGTH(v_OBLIGATION_NAME) > 57 THEN
			v_OBLIGATION_NAME := SUBSTR(v_OBLIGATION_NAME, 1, 57) || v_SUFFIX;
		ELSE
			v_OBLIGATION_NAME := v_OBLIGATION_NAME || v_SUFFIX;
		END IF;
	END IF;

	v_OBLIGATION_NAME := SUBSTR(v_OBLIGATION_NAME, 1, LEAST(LENGTH(v_OBLIGATION_NAME), 64));

	RETURN v_OBLIGATION_NAME;

END MAKE_OBLIGATION_NAME;
----------------------------------------------------------------------------------------------------
FUNCTION APPLY_ROUNDING_AND_MINIMUM
	(
	p_AMOUNT IN NUMBER,
	p_ROUNDING_PREFERENCE IN CHAR,
	p_MINIMUM_SCHEDULE_AMT IN NUMBER,
	p_ENFORCE_MINIMUM_RULE IN BOOLEAN DEFAULT TRUE
	) RETURN NUMBER IS

v_VALUE NUMBER;
v_PRECISION NUMBER(2);
v_OFFSET NUMBER;
v_AMT_PRECISION NUMBER(2);
BEGIN

-- Determine the amount of precision requested in the schedule amount.
	IF NVL(INSTR(TO_CHAR(p_MINIMUM_SCHEDULE_AMT),'.'),0) = 0 THEN
		v_PRECISION := 0;
	ELSE
		v_PRECISION := LENGTH(TO_CHAR(p_MINIMUM_SCHEDULE_AMT)) -  INSTR(TO_CHAR(p_MINIMUM_SCHEDULE_AMT),'.');
	END IF;

-- Perform Rounding: Standard, Up, Down, and Accumulate(X), else use the value as calculated.
	IF p_ROUNDING_PREFERENCE = 'S' THEN
		v_VALUE := ROUND(p_AMOUNT, v_PRECISION);
	ELSIF p_ROUNDING_PREFERENCE = 'U' THEN
		-- Find the amount's precision
		IF NVL(INSTR(TO_CHAR(p_AMOUNT),'.'),0) = 0 THEN
			v_AMT_PRECISION := 0;
		ELSE
			v_AMT_PRECISION := LENGTH(TO_CHAR(p_AMOUNT)) -  INSTR(TO_CHAR(p_AMOUNT),'.');
		END IF;

		-- Get the offset to round up a value (if req precision is 0.001 and the amount is 1.0111,
		-- then add .0005 to get 1.0116, so that we get an answer: 1.012)
		IF v_AMT_PRECISION <= v_PRECISION THEN
			v_OFFSET := 0;
		ELSE
			v_OFFSET := 5/(10 ** (v_PRECISION + 1));
		END IF;

		v_VALUE := ROUND(p_AMOUNT + v_OFFSET, v_PRECISION);
	ELSIF p_ROUNDING_PREFERENCE = 'D' THEN
		v_VALUE := TRUNC(p_AMOUNT, v_PRECISION);
	ELSIF p_ROUNDING_PREFERENCE = 'X' THEN
		IF p_AMOUNT >= 1.0 THEN
			v_VALUE := 1.0;
		ELSE
			v_VALUE := 0;
		END IF;
	ELSE
		v_VALUE := p_AMOUNT;
	END IF;

	IF p_ENFORCE_MINIMUM_RULE THEN
		IF GA.ENABLE_ZERO_MINIMUM_SCHEDULE AND p_AMOUNT <= 0 THEN
			v_VALUE := 0;
		ELSE
			v_VALUE := GREATEST(v_VALUE, NVL(p_MINIMUM_SCHEDULE_AMT,0));
		END IF;
	END IF;

	IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
	    LOGS.LOG_DEBUG_DETAIL('APPLY_ROUNDING_AND_MINIMUM PREFERENCE=' || p_ROUNDING_PREFERENCE || ', PRECISION=' || TO_CHAR(v_PRECISION) || ', BEFORE=' || TO_CHAR(p_AMOUNT) || ', AFTER=' || TO_CHAR(v_VALUE));
	END IF;

	RETURN v_VALUE;

END APPLY_ROUNDING_AND_MINIMUM;
----------------------------------------------------------------------------------------------------
PROCEDURE APPLY_CARRY_FORWARD
	(
	p_ROUNDING_PREFERENCE IN CHAR,
	p_DATE_SCHEDULE IN GA.DATE_TABLE,
	p_LOAD_SCHEDULE IN OUT NOCOPY GA.FLOAT_TABLE,
	p_LOSS_SCHEDULE IN OUT NOCOPY GA.FLOAT_TABLE
	) AS

-- Modify a Load and Loss Schedule to reflect a Carry Forward of the Losses.
-- The Carry Forward amount is accomodated between the Schedules.
-- This method is employed by Comed/MEC.

v_INDEX BINARY_INTEGER;
v_LOAD_VAL NUMBER;
v_LOSS_VAL NUMBER;
v_LOSS_FACTOR NUMBER(16,6);
v_CUMULATIVE_LOSS NUMBER := 0;
v_PRIOR_CUMULATIVE_LOSS NUMBER := 0;
v_CARRY_FORWARD_OPTION CHAR(1);

BEGIN

	v_CARRY_FORWARD_OPTION := DECODE_CARRY_FORWARD_OPTION(p_ROUNDING_PREFERENCE);

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('APPLY_CARRY_FORWARD');
	    LOGS.LOG_DEBUG('CARRY_FORWARD_OPTION=' || v_CARRY_FORWARD_OPTION);
	    LOGS.LOG_DEBUG('<original load>,<loss factor>,<cumulative loss>,<load>,<loss>@<index>');
	END IF;

	v_INDEX := p_LOAD_SCHEDULE.FIRST;
	WHILE v_INDEX <= p_LOAD_SCHEDULE.LAST LOOP
-- Determine the Loss Factor from the Load and Loss amounts.
		SELECT DECODE(p_LOAD_SCHEDULE(v_INDEX), 0, 0, p_LOSS_SCHEDULE(v_INDEX) / p_LOAD_SCHEDULE(v_INDEX)) INTO v_LOSS_FACTOR FROM DUAL;
		v_LOAD_VAL := ROUND(GREATEST(p_LOAD_SCHEDULE(v_INDEX) / (1 + v_LOSS_FACTOR), 1));
		v_PRIOR_CUMULATIVE_LOSS := v_CUMULATIVE_LOSS;
		v_CUMULATIVE_LOSS := v_CUMULATIVE_LOSS + v_LOAD_VAL * v_LOSS_FACTOR;
		v_LOSS_VAL := ROUND(v_CUMULATIVE_LOSS) - ROUND(v_PRIOR_CUMULATIVE_LOSS);
-- Different handling on Carry Forward Round Up for last hour of each day
		IF v_CARRY_FORWARD_OPTION = 'U'  AND (v_INDEX = p_LOAD_SCHEDULE.LAST OR (v_INDEX <> p_LOAD_SCHEDULE.FIRST AND NOT TO_CHAR(FROM_CUT(p_DATE_SCHEDULE(v_INDEX), LOCAL_TIME_ZONE) - 0.00001,'DAY') = TO_CHAR(FROM_CUT(p_DATE_SCHEDULE(v_INDEX - 1), LOCAL_TIME_ZONE) - 0.00001,'DAY'))) THEN
			IF v_LOSS_VAL = 0 AND v_CUMULATIVE_LOSS >= .1 THEN
				v_LOSS_VAL := 1;
			END IF;
			v_CUMULATIVE_LOSS := 0;
			v_PRIOR_CUMULATIVE_LOSS := 0;
		END IF;
 		IF LOGS.IS_DEBUG_ENABLED THEN
		    LOGS.LOG_DEBUG(TO_CHAR(p_LOAD_SCHEDULE(v_INDEX)) || ',' || TO_CHAR(v_LOSS_FACTOR) || ',' || TO_CHAR(v_CUMULATIVE_LOSS) || ',' ||
				TO_CHAR(v_LOAD_VAL) || ',' || TO_CHAR(v_LOSS_VAL) || '@' || TO_CHAR(v_INDEX));
		END IF;
		p_LOAD_SCHEDULE(v_INDEX) := v_LOAD_VAL;
		p_LOSS_SCHEDULE(v_INDEX) := v_LOSS_VAL;
		v_INDEX := p_LOAD_SCHEDULE.NEXT(v_INDEX);
	END LOOP;

END APPLY_CARRY_FORWARD;
----------------------------------------------------------------------------------------------------
PROCEDURE APPLY_ROUNDING
	(
	p_ROUNDING_PREFERENCE IN CHAR,
	p_MINIMUM_SCHEDULE_AMT IN NUMBER,
	p_ENFORCE_MINIMUM_RULE IN BOOLEAN,
	p_SCHEDULE IN OUT NOCOPY GA.FLOAT_TABLE
	) AS

v_INDEX BINARY_INTEGER;

BEGIN

	v_INDEX := p_SCHEDULE.FIRST;
	WHILE v_INDEX <= p_SCHEDULE.LAST LOOP
		p_SCHEDULE(v_INDEX) := APPLY_ROUNDING_AND_MINIMUM(p_SCHEDULE(v_INDEX), p_ROUNDING_PREFERENCE, p_MINIMUM_SCHEDULE_AMT, p_ENFORCE_MINIMUM_RULE);
		v_INDEX := p_SCHEDULE.NEXT(v_INDEX);
	END LOOP;

END APPLY_ROUNDING;
----------------------------------------------------------------------------------------------------
PROCEDURE APPLY_ROUNDING_TO_SCHEDULES
	(
	p_SCHEDULE_COORDINATOR IN v_SC_RECORD,
	p_EXCLUDE_UFE_ALLOCATION IN NUMBER,
	p_DT_SCHEDULE IN GA.DATE_TABLE,
	p_LO_SCHEDULE IN OUT NOCOPY GA.FLOAT_TABLE,
	p_TX_SCHEDULE IN OUT NOCOPY GA.FLOAT_TABLE,
	p_DX_SCHEDULE IN OUT NOCOPY GA.FLOAT_TABLE,
	p_UE_SCHEDULE IN OUT NOCOPY GA.FLOAT_TABLE
	) AS

v_LOAD_ROUNDING_PREFERENCE CHAR(1) := DECODE_ROUNDING_PREFERENCE(p_SCHEDULE_COORDINATOR.SC_LOAD_ROUNDING_PREFERENCE);
v_LOSS_ROUNDING_PREFERENCE CHAR(1) := DECODE_ROUNDING_PREFERENCE(p_SCHEDULE_COORDINATOR.SC_LOSS_ROUNDING_PREFERENCE);
v_INDEX BINARY_INTEGER;
v_LOAD NUMBER(16,6);

BEGIN

-- Determine what gets included in the Load Schedule.

	v_INDEX := p_LO_SCHEDULE.FIRST;
	WHILE v_INDEX <= p_LO_SCHEDULE.LAST LOOP
		v_LOAD := 0;
-- Add TX losses to base load adjustment if TX Schedule option is disabled.
		IF p_SCHEDULE_COORDINATOR.SC_CREATE_TX_LOSS_SCHEDULE = 0 THEN
			v_LOAD := v_LOAD + p_TX_SCHEDULE(v_INDEX);
		END IF;
-- Add DX losses to base load adjustment if DX Schedule option is disabled.
		IF p_SCHEDULE_COORDINATOR.SC_CREATE_DX_LOSS_SCHEDULE = 0 THEN
			v_LOAD := v_LOAD + p_DX_SCHEDULE(v_INDEX);
		END IF;
-- Correct to prevent double-counting of UFE.
-- Add UE losses to base load adjustment if UE Schedule option is disabled.
 		IF p_SCHEDULE_COORDINATOR.SC_CREATE_UFE_SCHEDULE = 0 AND p_EXCLUDE_UFE_ALLOCATION = 0 THEN
 			v_LOAD := v_LOAD + p_UE_SCHEDULE(v_INDEX);
 		END IF;
		p_LO_SCHEDULE(v_INDEX) :=  p_LO_SCHEDULE(v_INDEX) + v_LOAD;
		v_INDEX := p_LO_SCHEDULE.NEXT(v_INDEX);
	END LOOP;

-- Special Carry-Forward logic applies for TX Loss Schedule option only enabled.
	IF p_SCHEDULE_COORDINATOR.SC_CREATE_TX_LOSS_SCHEDULE = 1 AND v_LOSS_ROUNDING_PREFERENCE = 'C' THEN
		APPLY_CARRY_FORWARD(p_SCHEDULE_COORDINATOR.SC_LOSS_ROUNDING_PREFERENCE, p_DT_SCHEDULE, p_LO_SCHEDULE, p_TX_SCHEDULE);
		RETURN;
	END IF;

-- Round the Load Schedule.
	APPLY_ROUNDING(v_LOAD_ROUNDING_PREFERENCE, p_SCHEDULE_COORDINATOR.SC_MINIMUM_SCHEDULE_AMT, TRUE, p_LO_SCHEDULE);

-- Round the TX Schedule if Selected.
	IF p_SCHEDULE_COORDINATOR.SC_CREATE_TX_LOSS_SCHEDULE = 1 THEN
		APPLY_ROUNDING(v_LOSS_ROUNDING_PREFERENCE, p_SCHEDULE_COORDINATOR.SC_MINIMUM_SCHEDULE_AMT, TRUE, p_TX_SCHEDULE);
	END IF;

-- Round the DX Schedule if Selected.
	IF p_SCHEDULE_COORDINATOR.SC_CREATE_DX_LOSS_SCHEDULE = 1 THEN
		APPLY_ROUNDING(v_LOSS_ROUNDING_PREFERENCE, p_SCHEDULE_COORDINATOR.SC_MINIMUM_SCHEDULE_AMT, TRUE, p_DX_SCHEDULE);
	END IF;

-- Round the UE Schedule if Selected.
	IF p_SCHEDULE_COORDINATOR.SC_CREATE_UFE_SCHEDULE = 1 THEN
		APPLY_ROUNDING(v_LOSS_ROUNDING_PREFERENCE, p_SCHEDULE_COORDINATOR.SC_MINIMUM_SCHEDULE_AMT, FALSE, p_UE_SCHEDULE);
	END IF;

END APPLY_ROUNDING_TO_SCHEDULES;
----------------------------------------------------------------------------------------------------
PROCEDURE TRACE_SCHEDULES
	(
	p_REQUEST_TYPE IN CHAR,
	p_OBLIGATION_ID IN NUMBER,
	p_SCHEDULE_COORDINATOR IN v_SC_RECORD,
	p_DT_SCHEDULE IN GA.DATE_TABLE,
	p_LO_SCHEDULE IN GA.FLOAT_TABLE,
	p_TX_SCHEDULE IN GA.FLOAT_TABLE,
	p_DX_SCHEDULE IN GA.FLOAT_TABLE,
	p_UE_SCHEDULE IN GA.FLOAT_TABLE,
	p_AJ_SCHEDULE IN GA.FLOAT_TABLE
	) AS

v_INDEX BINARY_INTEGER;

BEGIN

	v_INDEX := p_DT_SCHEDULE.FIRST;
	LOGS.LOG_DEBUG('TRACE_SCHEDULES');
	LOGS.LOG_DEBUG('REQUEST_TYPE=' || p_REQUEST_TYPE);
	LOGS.LOG_DEBUG('OBLIGATION_ID=' || TO_CHAR(p_OBLIGATION_ID));
	LOGS.LOG_DEBUG('SC_ID=' || TO_CHAR(p_SCHEDULE_COORDINATOR.SC_ID));
	LOGS.LOG_DEBUG('SCHEDULE_NAME_PREFIX=' || p_SCHEDULE_COORDINATOR.SC_SCHEDULE_NAME_PREFIX);
	LOGS.LOG_DEBUG('SCHEDULE_FORMAT=' || p_SCHEDULE_COORDINATOR.SC_SCHEDULE_FORMAT);
	LOGS.LOG_DEBUG('SCHEDULE_INTERVAL=' || p_SCHEDULE_COORDINATOR.SC_SCHEDULE_INTERVAL);
	LOGS.LOG_DEBUG('LOAD_ROUNDING_PREFERENCE=' || p_SCHEDULE_COORDINATOR.SC_LOAD_ROUNDING_PREFERENCE);
	LOGS.LOG_DEBUG('LOSS_ROUNDING_PREFERENCE=' || p_SCHEDULE_COORDINATOR.SC_LOSS_ROUNDING_PREFERENCE);
	LOGS.LOG_DEBUG('CREATE_TX_LOSS_SCHEDULE=' || TO_CHAR(p_SCHEDULE_COORDINATOR.SC_CREATE_TX_LOSS_SCHEDULE));
	LOGS.LOG_DEBUG('CREATE_DX_LOSS_SCHEDULE=' || TO_CHAR(p_SCHEDULE_COORDINATOR.SC_CREATE_DX_LOSS_SCHEDULE));
	LOGS.LOG_DEBUG('CREATE_UFE_SCHEDULE=' || TO_CHAR(p_SCHEDULE_COORDINATOR.SC_CREATE_UFE_SCHEDULE));
	LOGS.LOG_DEBUG('MINIMUM_SCHEDULE_AMT=' || TO_CHAR(p_SCHEDULE_COORDINATOR.SC_MINIMUM_SCHEDULE_AMT));
	LOGS.LOG_DEBUG('BEGIN TRACE OF SCHEDULES: <date>,<load>,<tx loss>,<dx loss>,<ufe>,<adjust><index>');

	WHILE v_INDEX <= p_DT_SCHEDULE.LAST LOOP
		LOGS.LOG_DEBUG(UT.TRACE_DATE(p_DT_SCHEDULE(v_INDEX)) || ',' ||
			TO_CHAR(p_LO_SCHEDULE(v_INDEX)) || ',' ||
			TO_CHAR(p_TX_SCHEDULE(v_INDEX)) || ',' ||
			TO_CHAR(p_DX_SCHEDULE(v_INDEX)) || ',' ||
			TO_CHAR(p_UE_SCHEDULE(v_INDEX)) || ',' ||
			TO_CHAR(p_AJ_SCHEDULE(v_INDEX)) || ',' ||
			TO_CHAR(v_INDEX));
			v_INDEX := p_DT_SCHEDULE.NEXT(v_INDEX);
	END LOOP;

	LOGS.LOG_DEBUG('END TRACE OF SCHEDULES');

END TRACE_SCHEDULES;
--------------------------------------------------------------------------------------------------
PROCEDURE CLEAR_SCHEDULES
	(
	p_DT_SCHEDULE IN OUT NOCOPY GA.DATE_TABLE,
	p_LO_SCHEDULE IN OUT NOCOPY GA.FLOAT_TABLE,
	p_TX_SCHEDULE IN OUT NOCOPY GA.FLOAT_TABLE,
	p_DX_SCHEDULE IN OUT NOCOPY GA.FLOAT_TABLE,
	p_UE_SCHEDULE IN OUT NOCOPY GA.FLOAT_TABLE,
	p_AJ_SCHEDULE IN OUT NOCOPY GA.FLOAT_TABLE
	) AS

BEGIN

	p_DT_SCHEDULE.DELETE;
	p_LO_SCHEDULE.DELETE;
	p_TX_SCHEDULE.DELETE;
	p_DX_SCHEDULE.DELETE;
	p_UE_SCHEDULE.DELETE;
	p_AJ_SCHEDULE.DELETE;

END CLEAR_SCHEDULES;
--------------------------------------------------------------------------------------------------
PROCEDURE DELETE_LOAD_OBLIGATION_SCHED
	(
	p_OBLIGATION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	) AS

-- Note that p_BEGIN_DATE and p_END_DATE are CUT dates.

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('DELETE_LOAD_OBLIGATION_SCHED');
		LOGS.LOG_DEBUG('OBLIGATION_ID=' || TO_CHAR(p_OBLIGATION_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' ||  UT.TRACE_DATE(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || UT.TRACE_DATE(p_END_DATE));
	END IF;

	DELETE LOAD_OBLIGATION_SCHEDULE
	WHERE OBLIGATION_ID = p_OBLIGATION_ID
		AND OBLIGATION_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE;

END DELETE_LOAD_OBLIGATION_SCHED;
----------------------------------------------------------------------------------------------------
PROCEDURE SAVE_LOAD_OBLIGATION_SCHEDULES
	(
	p_REQUEST_TYPE IN CHAR,
	p_OBLIGATION_ID IN NUMBER,
	p_SCHEDULE_COORDINATOR IN v_SC_RECORD,
	p_EXCLUDE_UFE_ALLOCATION IN NUMBER,
	p_DT_SCHEDULE IN GA.DATE_TABLE,
	p_LO_SCHEDULE IN GA.FLOAT_TABLE,
	p_TX_SCHEDULE IN GA.FLOAT_TABLE,
	p_DX_SCHEDULE IN GA.FLOAT_TABLE,
	p_UE_SCHEDULE IN GA.FLOAT_TABLE,
	p_AJ_SCHEDULE IN GA.FLOAT_TABLE
	) AS

v_INDEX BINARY_INTEGER;
v_OBLIGATION_TYPE CHAR(1);
v_BEGIN_DATE DATE := HIGH_DATE;
v_END_DATE DATE := LOW_DATE;
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('SAVE_LOAD_OBLIGATION_SCHEDULES');
		TRACE_SCHEDULES(p_REQUEST_TYPE, p_OBLIGATION_ID, p_SCHEDULE_COORDINATOR, p_DT_SCHEDULE, p_LO_SCHEDULE, p_TX_SCHEDULE, p_DX_SCHEDULE, p_UE_SCHEDULE, p_AJ_SCHEDULE);
		LOGS.LOG_DEBUG('SAVING LOAD SCHEDULE');
	END IF;

	v_INDEX := p_DT_SCHEDULE.FIRST;
	WHILE v_INDEX <= p_DT_SCHEDULE.LAST LOOP
		v_BEGIN_DATE := LEAST(p_DT_SCHEDULE(v_INDEX), v_BEGIN_DATE);
		v_END_DATE := GREATEST(p_DT_SCHEDULE(v_INDEX), v_END_DATE);
		v_INDEX := p_DT_SCHEDULE.NEXT(v_INDEX);
	END LOOP;

	v_OBLIGATION_TYPE := 1;
	FORALL v_INDEX IN 1..p_LO_SCHEDULE.COUNT
		INSERT INTO LOAD_OBLIGATION_SCHEDULE(OBLIGATION_ID, OBLIGATION_TYPE, OBLIGATION_DATE, OBLIGATION_LOAD_VAL)
		VALUES (p_OBLIGATION_ID, v_OBLIGATION_TYPE, p_DT_SCHEDULE(v_INDEX), p_LO_SCHEDULE(v_INDEX));

	IF p_SCHEDULE_COORDINATOR.SC_CREATE_TX_LOSS_SCHEDULE = 1 THEN
		v_OBLIGATION_TYPE := 2;
		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG('SAVING TX LOSS SCHEDULE');
		END IF;
		FORALL v_INDEX IN 1..p_TX_SCHEDULE.COUNT
			INSERT INTO LOAD_OBLIGATION_SCHEDULE(OBLIGATION_ID, OBLIGATION_TYPE, OBLIGATION_DATE, OBLIGATION_LOAD_VAL)
			VALUES (p_OBLIGATION_ID, v_OBLIGATION_TYPE, p_DT_SCHEDULE(v_INDEX), p_TX_SCHEDULE(v_INDEX));
	END IF;

	IF p_SCHEDULE_COORDINATOR.SC_CREATE_DX_LOSS_SCHEDULE = 1 THEN
		v_OBLIGATION_TYPE := 3;
		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG('SAVING DX LOSS SCHEDULE');
		END IF;
		FORALL v_INDEX IN 1..p_DX_SCHEDULE.COUNT
			INSERT INTO LOAD_OBLIGATION_SCHEDULE(OBLIGATION_ID, OBLIGATION_TYPE, OBLIGATION_DATE, OBLIGATION_LOAD_VAL)
			VALUES (p_OBLIGATION_ID, v_OBLIGATION_TYPE, p_DT_SCHEDULE(v_INDEX), p_DX_SCHEDULE(v_INDEX));
	END IF;

	IF p_SCHEDULE_COORDINATOR.SC_CREATE_UFE_SCHEDULE = 1 AND p_EXCLUDE_UFE_ALLOCATION = 0 THEN
		v_OBLIGATION_TYPE := 4;
		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG('SAVING UE LOAD SCHEDULE');
		END IF;
		FORALL v_INDEX IN 1..p_UE_SCHEDULE.COUNT
			INSERT INTO LOAD_OBLIGATION_SCHEDULE(OBLIGATION_ID, OBLIGATION_TYPE, OBLIGATION_DATE, OBLIGATION_LOAD_VAL)
			VALUES (p_OBLIGATION_ID, v_OBLIGATION_TYPE, p_DT_SCHEDULE(v_INDEX), p_UE_SCHEDULE(v_INDEX));
	END IF;

	IF GA.ENABLE_BACKCAST_ADJ_SCHEDULES AND p_REQUEST_TYPE = 'B' THEN
		v_OBLIGATION_TYPE := 5;
		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG('SAVING AJUSTMENT LOAD SCHEDULE');
		END IF;
		FORALL v_INDEX IN 1..p_AJ_SCHEDULE.COUNT
			INSERT INTO LOAD_OBLIGATION_SCHEDULE(OBLIGATION_ID, OBLIGATION_TYPE, OBLIGATION_DATE, OBLIGATION_LOAD_VAL)
			VALUES (p_OBLIGATION_ID, v_OBLIGATION_TYPE, p_DT_SCHEDULE(v_INDEX), p_AJ_SCHEDULE(v_INDEX));
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('SAVE_LOAD_OBLIGATION_SCHEDULES ELAPSED TIME='  || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED));
	END IF;

END SAVE_LOAD_OBLIGATION_SCHEDULES;
--------------------------------------------------------------------------------------------------
PROCEDURE PUT_LOAD_OBLIGATION_SCHEDULE
	(
	p_LOAD_OBLIGATION_SCHEDULE IN OUT NOCOPY LOAD_OBLIGATION_SCHEDULE%ROWTYPE
	) AS

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG(TO_CHAR(p_LOAD_OBLIGATION_SCHEDULE.OBLIGATION_ID) || ',' ||
			UT.TRACE_DATE(p_LOAD_OBLIGATION_SCHEDULE.OBLIGATION_DATE) || ',' ||
		    TO_CHAR(p_LOAD_OBLIGATION_SCHEDULE.OBLIGATION_LOAD_VAL));
	END IF;

	INSERT INTO LOAD_OBLIGATION_SCHEDULE (
	    OBLIGATION_ID,
		OBLIGATION_TYPE,
		OBLIGATION_DATE,
		OBLIGATION_LOAD_VAL)
	VALUES (
		p_LOAD_OBLIGATION_SCHEDULE.OBLIGATION_ID,
		p_LOAD_OBLIGATION_SCHEDULE.OBLIGATION_TYPE,
		p_LOAD_OBLIGATION_SCHEDULE.OBLIGATION_DATE,
		p_LOAD_OBLIGATION_SCHEDULE.OBLIGATION_LOAD_VAL);

END PUT_LOAD_OBLIGATION_SCHEDULE;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SCHEDULES
	(
	p_MODEL_ID IN NUMBER,
	p_REQUEST_TYPE IN VARCHAR,
	p_SCENARIO_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Note that p_BEGIN_DATE and p_END_DATE are CUT dates.

v_AS_OF_DATE DATE;
v_REQUEST_TYPE CHAR(1) := UPPER(SUBSTR(p_REQUEST_TYPE,1,1));
v_ENABLE_AGG_POOL NUMBER(1) := UT.NUMBER_FROM_BOOLEAN(GA.ENABLE_AGGREGATE_POOL_MODEL);

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('GET_SCHEDULES');
		LOGS.LOG_DEBUG('MODEL_ID=' || TO_CHAR(p_MODEL_ID));
		LOGS.LOG_DEBUG('REQUEST_TYPE=' || p_REQUEST_TYPE);
		LOGS.LOG_DEBUG('SCENARIO_ID=' || TO_CHAR(p_SCENARIO_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || UT.TRACE_DATE(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || UT.TRACE_DATE(p_END_DATE));
		LOGS.LOG_DEBUG('AS_OF_DATE=' || UT.TRACE_DATE(p_AS_OF_DATE));
	END IF;

	v_AS_OF_DATE := AS_OF_DATE_FOR_REQUEST(v_REQUEST_TYPE, p_AS_OF_DATE);
	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN 0 ELSE SC.SC_ID END AS SC_ID,
			-- If the incumbent type is EDC and this is a wholesale delivery, then use the ¿wholesale¿ indicator for PSE ID
			CASE WHEN IE.INCUMBENT_TYPE = 'EDC' AND SD.IS_WHOLESALE = 1 THEN g_WHOLESALE
				 ELSE PS.PSE_ID
				 END "PSE_ID",
			CASE WHEN g_ACCEPT_NON_INCUMBENT_ENTITY = 0 AND IE.INCUMBENT_TYPE = 'ESP' THEN ESP.ESP_ID
				 ELSE CONSTANTS.NOT_ASSIGNED
				 END "ESP_ID",
			CASE WHEN g_ACCEPT_NON_INCUMBENT_ENTITY = 0 AND (p_MODEL_ID = GA.GAS_MODEL AND UPPER(CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.SCHEDULE_FORMAT ELSE SC.SC_SCHEDULE_FORMAT END) = 'POOL') THEN EDC.EDC_ID
				 ELSE CONSTANTS.NOT_ASSIGNED
				 END "EDC_ID",
			-- Schedule Config fields common to PSE and EDC's SC
			CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.SCHEDULE_NAME_PREFIX ELSE SC.SC_SCHEDULE_NAME_PREFIX END "SC_SCHEDULE_NAME_PREFIX",
			CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.SCHEDULE_FORMAT ELSE SC.SC_SCHEDULE_FORMAT END "SC_SCHEDULE_FORMAT",
			CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.SCHEDULE_INTERVAL ELSE SC.SC_SCHEDULE_INTERVAL END "SC_SCHEDULE_INTERVAL",
			CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.LOAD_ROUNDING_PREFERENCE ELSE SC.SC_LOAD_ROUNDING_PREFERENCE END "SC_LOAD_ROUNDING_PREFERENCE",
			CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.LOSS_ROUNDING_PREFERENCE ELSE SC.SC_LOSS_ROUNDING_PREFERENCE END "SC_LOSS_ROUNDING_PREFERENCE",
			CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.MINIMUM_SCHEDULE_AMT ELSE SC.SC_MINIMUM_SCHEDULE_AMT END "SC_MINIMUM_SCHEDULE_AMT",
			CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.CREATE_TX_LOSS_SCHEDULE ELSE SC.SC_CREATE_TX_LOSS_SCHEDULE END "SC_CREATE_TX_LOSS_SCHEDULE",
			CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.CREATE_DX_LOSS_SCHEDULE ELSE SC.SC_CREATE_DX_LOSS_SCHEDULE END "SC_CREATE_DX_LOSS_SCHEDULE",
			CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.CREATE_UFE_SCHEDULE ELSE SC.SC_CREATE_UFE_SCHEDULE END "SC_CREATE_UFE_SCHEDULE",
			CASE WHEN UPPER(CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.SCHEDULE_FORMAT ELSE SC.SC_SCHEDULE_FORMAT END) = 'POOL' THEN (CASE WHEN v_ENABLE_AGG_POOL=1 THEN NVL(SP.SUB_POOL_ID, SD.POOL_ID) ELSE SD.POOL_ID END) ELSE CONSTANTS.NOT_ASSIGNED END "POOL_ID",
			CASE WHEN UPPER(CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.SCHEDULE_FORMAT ELSE SC.SC_SCHEDULE_FORMAT END) = 'SERVICE POINT' THEN SD.SERVICE_POINT_ID ELSE CONSTANTS.NOT_ASSIGNED END "SERVICE_POINT_ID",
			CASE WHEN UPPER(CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.SCHEDULE_FORMAT ELSE SC.SC_SCHEDULE_FORMAT END) = 'SCHEDULE GROUP' THEN SD.SCHEDULE_GROUP_ID ELSE CONSTANTS.NOT_ASSIGNED END "SCHEDULE_GROUP_ID",
			CASE WHEN UPPER(CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.SCHEDULE_FORMAT ELSE SC.SC_SCHEDULE_FORMAT END) = 'SERVICE ZONE' THEN SD.SERVICE_ZONE_ID ELSE CONSTANTS.NOT_ASSIGNED END "SERVICE_ZONE_ID",
			GA.STANDARD "LOAD_CODE",
			SOL.LOAD_DATE,
			SUM(DECODE(SOL.LOAD_CODE,GA.ADJUSTMENT,0,SOL.LOAD_VAL) * (CASE WHEN v_ENABLE_AGG_POOL=1 THEN NVL(SP.ALLOCATION_PCT,100) / 100 ELSE 1 END)),
			SUM(DECODE(SOL.LOAD_CODE,GA.ADJUSTMENT,0,SOL.TX_LOSS_VAL) * (CASE WHEN v_ENABLE_AGG_POOL=1 THEN NVL(SP.ALLOCATION_PCT,100) / 100 ELSE 1 END)),
			SUM(DECODE(SOL.LOAD_CODE,GA.ADJUSTMENT,0,SOL.DX_LOSS_VAL) * (CASE WHEN v_ENABLE_AGG_POOL=1 THEN NVL(SP.ALLOCATION_PCT,100) / 100 ELSE 1 END)),
			SUM(DECODE(SOL.LOAD_CODE,GA.ADJUSTMENT,0,SOL.UFE_LOAD_VAL) * (CASE WHEN v_ENABLE_AGG_POOL=1 THEN NVL(SP.ALLOCATION_PCT,100) / 100 ELSE 1 END)),
			SUM(DECODE(SOL.LOAD_CODE,GA.ADJUSTMENT,SOL.LOAD_VAL,0) * (CASE WHEN v_ENABLE_AGG_POOL=1 THEN NVL(SP.ALLOCATION_PCT,100) / 100 ELSE 1 END))
		FROM INCUMBENT_ENTITY IE,
			ENERGY_DISTRIBUTION_COMPANY EDC,
			ENERGY_SERVICE_PROVIDER ESP,
			PROVIDER_SERVICE PS,
			SERVICE_OBLIGATION SO,
			SERVICE_DELIVERY SD,
			SCHEDULE_GROUP SG,
			PURCHASING_SELLING_ENTITY P,
			SCHEDULE_COORDINATOR SC,
			POOL_SUB_POOL SP,
			SERVICE_OBLIGATION_LOAD SOL
		WHERE -- When we set 'Allow non-incumbent-entity load' to true
			-- we skip the criteria that forces the schedules to
			-- only include the incumbent entity.
			((g_ACCEPT_NON_INCUMBENT_ENTITY = 0
				AND ((IE.INCUMBENT_TYPE = 'EDC' AND EDC.EDC_ID = IE.INCUMBENT_ID)
					OR (IE.INCUMBENT_TYPE = 'ESP' AND ESP.ESP_ID = IE.INCUMBENT_ID)))
			OR g_ACCEPT_NON_INCUMBENT_ENTITY = 1)
			AND UPPER(SUBSTR(EDC.EDC_STATUS,1,1)) = 'A'
			AND NOT EDC.EDC_EXCLUDE_LOAD_SCHEDULE = 1
			AND UPPER(SUBSTR(ESP.ESP_STATUS,1,1)) = 'A'
			AND NOT ESP.ESP_EXCLUDE_LOAD_SCHEDULE = 1
			AND PS.EDC_ID = EDC.EDC_ID
			AND PS.ESP_ID = ESP.ESP_ID
			AND ((UPPER(SUBSTR(PSE_STATUS,1,1)) = 'A' AND UPPER(SUBSTR(PSE_TYPE,1,1)) = 'M' AND PSE_IS_RETAIL_AGGREGATOR = 1 AND NOT PSE_EXCLUDE_LOAD_SCHEDULE = 1)
				OR PS.PSE_ID = CONSTANTS.NOT_ASSIGNED
				OR SD.IS_WHOLESALE = 1)
			AND SO.MODEL_ID = p_MODEL_ID
			AND SO.SCENARIO_ID = p_SCENARIO_ID
			AND SO.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM SERVICE_OBLIGATION
				WHERE MODEL_ID = SO.MODEL_ID
					AND SCENARIO_ID = SO.SCENARIO_ID
					AND AS_OF_DATE <= v_AS_OF_DATE
					AND PROVIDER_SERVICE_ID = SO.PROVIDER_SERVICE_ID
					AND SERVICE_DELIVERY_ID = SO.SERVICE_DELIVERY_ID)
			AND SO.PROVIDER_SERVICE_ID = PS.PROVIDER_SERVICE_ID
			AND SD.SERVICE_DELIVERY_ID = SO.SERVICE_DELIVERY_ID
			AND (SD.POOL_ID IN (SELECT POOL_ID FROM POOL WHERE UPPER(SUBSTR(POOL_STATUS,1,1)) = 'A' AND NOT POOL_EXCLUDE_LOAD_SCHEDULE = 1) OR SD.POOL_ID = CONSTANTS.NOT_ASSIGNED)
			AND SG.SCHEDULE_GROUP_ID = SD.SCHEDULE_GROUP_ID
			AND P.PSE_ID = PS.PSE_ID
			AND SC.SC_ID = SD.SC_ID
			AND SP.POOL_ID(+) = SD.POOL_ID
			AND SP.BEGIN_DATE(+) <= p_END_DATE
			AND NVL(SP.END_DATE(+), p_END_DATE) >= p_BEGIN_DATE
			AND SOL.SERVICE_OBLIGATION_ID = SO.SERVICE_OBLIGATION_ID
			AND SOL.SERVICE_CODE = v_REQUEST_TYPE
			AND SOL.LOAD_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
			AND SOL.LOAD_CODE IN (GA.STANDARD, GA.ADJUSTMENT)
		GROUP BY CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN 0 ELSE SC.SC_ID END,
			CASE WHEN IE.INCUMBENT_TYPE = 'EDC' AND SD.IS_WHOLESALE = 1 THEN g_WHOLESALE
				 ELSE PS.PSE_ID END,
			CASE WHEN g_ACCEPT_NON_INCUMBENT_ENTITY = 0 AND IE.INCUMBENT_TYPE = 'ESP' THEN ESP.ESP_ID
				 ELSE CONSTANTS.NOT_ASSIGNED END,
			CASE WHEN g_ACCEPT_NON_INCUMBENT_ENTITY = 0 AND (p_MODEL_ID = GA.GAS_MODEL AND UPPER(CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.SCHEDULE_FORMAT ELSE SC.SC_SCHEDULE_FORMAT END) = 'POOL') THEN EDC.EDC_ID
				 ELSE CONSTANTS.NOT_ASSIGNED END,
			CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.SCHEDULE_NAME_PREFIX ELSE SC.SC_SCHEDULE_NAME_PREFIX END,
			CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.SCHEDULE_FORMAT ELSE SC.SC_SCHEDULE_FORMAT END,
			CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.SCHEDULE_INTERVAL ELSE SC.SC_SCHEDULE_INTERVAL END,
			CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.LOAD_ROUNDING_PREFERENCE ELSE SC.SC_LOAD_ROUNDING_PREFERENCE END,
			CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.LOSS_ROUNDING_PREFERENCE ELSE SC.SC_LOSS_ROUNDING_PREFERENCE END,
			CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.MINIMUM_SCHEDULE_AMT ELSE SC.SC_MINIMUM_SCHEDULE_AMT END,
			CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.CREATE_TX_LOSS_SCHEDULE ELSE SC.SC_CREATE_TX_LOSS_SCHEDULE END,
			CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.CREATE_DX_LOSS_SCHEDULE ELSE SC.SC_CREATE_DX_LOSS_SCHEDULE END,
			CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.CREATE_UFE_SCHEDULE ELSE SC.SC_CREATE_UFE_SCHEDULE END,
			CASE WHEN UPPER(CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.SCHEDULE_FORMAT ELSE SC.SC_SCHEDULE_FORMAT END) = 'POOL' THEN (CASE WHEN v_ENABLE_AGG_POOL=1 THEN NVL(SP.SUB_POOL_ID, SD.POOL_ID) ELSE SD.POOL_ID END) ELSE CONSTANTS.NOT_ASSIGNED END,
			CASE WHEN UPPER(CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.SCHEDULE_FORMAT ELSE SC.SC_SCHEDULE_FORMAT END) = 'SERVICE POINT' THEN SD.SERVICE_POINT_ID ELSE CONSTANTS.NOT_ASSIGNED END,
			CASE WHEN UPPER(CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.SCHEDULE_FORMAT ELSE SC.SC_SCHEDULE_FORMAT END) = 'SCHEDULE GROUP' THEN SD.SCHEDULE_GROUP_ID ELSE CONSTANTS.NOT_ASSIGNED END,
			CASE WHEN UPPER(CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.SCHEDULE_FORMAT ELSE SC.SC_SCHEDULE_FORMAT END) = 'SERVICE ZONE' THEN SD.SERVICE_ZONE_ID ELSE CONSTANTS.NOT_ASSIGNED END,
			GA.STANDARD,
			SOL.LOAD_DATE
		ORDER BY 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19;

END GET_SCHEDULES;
----------------------------------------------------------------------------------------------------
PROCEDURE ACCEPT_LOAD_OBLIGATION
	(
	p_MODEL_ID IN NUMBER,
	p_OBLIGATION_NAME IN VARCHAR,
	p_OBLIGATION_ID IN NUMBER,
	p_OBLIGATION_TYPE IN CHAR,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE
	) AS
v_BEGIN_DATE DATE;
v_END_DATE DATE;
BEGIN
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	ACCEPT_LOAD_OBLIGATION_DT(p_MODEL_ID,p_OBLIGATION_NAME,p_OBLIGATION_ID,p_OBLIGATION_TYPE,p_SCHEDULE_TYPE,p_BEGIN_DATE,p_END_DATE,v_BEGIN_DATE,v_END_DATE,p_AS_OF_DATE);
END ACCEPT_LOAD_OBLIGATION;
----------------------------------------------------------------------------------------------------
PROCEDURE ACCEPT_LOAD_OBLIGATION_DT
	(
	p_MODEL_ID IN NUMBER,
	p_OBLIGATION_NAME IN VARCHAR,
	p_OBLIGATION_ID IN NUMBER,
	p_OBLIGATION_TYPE IN CHAR,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_BEGIN_DATETIME IN DATE,
	p_END_DATETIME IN DATE,
	p_AS_OF_DATE IN DATE
	) AS

v_LOAD_TRANSACTION_ID NUMBER(9);
v_LINK_TRANSACTION_ID NUMBER(9);
v_PSE_ID NUMBER(9);
v_TRANSACTION_NAME VARCHAR(64);
v_CONTRACT_ID NUMBER(9);
v_CONTRACT_NAME VARCHAR(32);
v_LOAD_OBLIGATION LOAD_OBLIGATION%ROWTYPE;

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	SELECT * INTO v_LOAD_OBLIGATION FROM LOAD_OBLIGATION WHERE OBLIGATION_ID = p_OBLIGATION_ID;

	v_TRANSACTION_NAME := v_LOAD_OBLIGATION.OBLIGATION_NAME;
	v_LINK_TRANSACTION_ID := CONSTANTS.NOT_ASSIGNED;
	GET_LOAD_TRANSACTION_ID(p_MODEL_ID, v_TRANSACTION_NAME, v_LOAD_OBLIGATION, p_BEGIN_DATE, p_END_DATE, v_LINK_TRANSACTION_ID, v_LOAD_TRANSACTION_ID);
	v_LINK_TRANSACTION_ID := v_LOAD_TRANSACTION_ID;

	SELECT SUBSTR(v_TRANSACTION_NAME || DECODE(p_OBLIGATION_TYPE, 2, g_TX_SUFFIX, 3, g_DX_SUFFIX, 4, g_UE_SUFFIX, 5, g_AJ_SUFFIX, g_NO_SUFFIX),1,64) INTO v_TRANSACTION_NAME FROM DUAL;

	GET_LOAD_TRANSACTION_ID(p_MODEL_ID, v_TRANSACTION_NAME, v_LOAD_OBLIGATION, p_BEGIN_DATE, p_END_DATE, v_LINK_TRANSACTION_ID, v_LOAD_TRANSACTION_ID);

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('ACCEPT_LOAD_OBLIGATION');
		LOGS.LOG_DEBUG('OBLIGATION_ID=' || TO_CHAR(p_OBLIGATION_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || UT.TRACE_DATE(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || UT.TRACE_DATE(p_END_DATE));
		LOGS.LOG_DEBUG('TRANSACTION_NAME=' || v_TRANSACTION_NAME);
		LOGS.LOG_DEBUG('TRANSACTION_ID=' || TO_CHAR(v_LOAD_TRANSACTION_ID));
	END IF;

	IF p_MODEL_ID = GA.GAS_MODEL THEN
		v_PSE_ID := GET_TRANSACTION_PSE_ID(v_LOAD_TRANSACTION_ID);
        v_CONTRACT_NAME := GET_PSE_LOAD_CONTRACT_NAME(v_PSE_ID, v_LOAD_TRANSACTION_ID);
        v_CONTRACT_ID := GET_CONTRACT_ID(v_CONTRACT_NAME);
        IF v_CONTRACT_ID = CONSTANTS.NOT_ASSIGNED THEN
	        v_CONTRACT_ID := v_LOAD_TRANSACTION_ID;
        END IF;
        SET_INTERCHANGE_CONTRACT(v_LOAD_TRANSACTION_ID, v_CONTRACT_ID, v_CONTRACT_NAME, v_PSE_ID);
	END IF;

	SAVE_SCHEDULE(p_MODEL_ID, p_OBLIGATION_ID, p_OBLIGATION_TYPE, v_LOAD_OBLIGATION.OBLIGATION_INTERVAL, v_LOAD_TRANSACTION_ID, p_SCHEDULE_TYPE, p_BEGIN_DATE, p_END_DATE, LOCAL_TIME_ZONE, p_AS_OF_DATE);

END ACCEPT_LOAD_OBLIGATION_DT;
----------------------------------------------------------------------------------------------------
PROCEDURE ACCEPT_OBLIGATION_AS_SCHEDULE
	(
	p_OBLIGATION_ID IN NUMBER,
	p_TRANSACTION_ID IN NUMBER,
	p_OBLIGATION_TYPE IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS

v_TRANSACTION_NAME VARCHAR(64);
v_TRANSACTION_ID NUMBER;
v_LOAD_OBLIGATION LOAD_OBLIGATION%ROWTYPE;

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	SELECT * INTO v_LOAD_OBLIGATION FROM LOAD_OBLIGATION WHERE OBLIGATION_ID = p_OBLIGATION_ID;

	IF p_TRANSACTION_ID = CONSTANTS.NOT_ASSIGNED THEN
		SELECT SUBSTR(v_LOAD_OBLIGATION.OBLIGATION_NAME || DECODE(p_OBLIGATION_TYPE, 2, g_TX_SUFFIX, 3, g_DX_SUFFIX, 4, g_UE_SUFFIX, 5, g_AJ_SUFFIX, g_NO_SUFFIX),1,64) INTO v_TRANSACTION_NAME FROM DUAL;
		GET_LOAD_TRANSACTION_ID(GA.ELECTRIC_MODEL, v_TRANSACTION_NAME, v_LOAD_OBLIGATION, p_BEGIN_DATE, p_END_DATE, CONSTANTS.NOT_ASSIGNED, v_TRANSACTION_ID);
	ELSE
		v_TRANSACTION_ID := p_TRANSACTION_ID;
	END IF;

	SAVE_SCHEDULE(GA.DEFAULT_MODEL, p_OBLIGATION_ID, p_OBLIGATION_TYPE, v_LOAD_OBLIGATION.OBLIGATION_INTERVAL, v_TRANSACTION_ID, p_SCHEDULE_TYPE, p_BEGIN_DATE, p_END_DATE, LOCAL_TIME_ZONE, p_AS_OF_DATE);

	REMOVE_LOAD_OBLIGATION(p_OBLIGATION_ID);


END ACCEPT_OBLIGATION_AS_SCHEDULE;
----------------------------------------------------------------------------------------------------
PROCEDURE REMOVE_LOAD_OBLIGATION
	(
	p_OBLIGATION_ID IN NUMBER
	) AS

BEGIN

	DELETE LOAD_OBLIGATION_SCHEDULE
	WHERE OBLIGATION_ID = p_OBLIGATION_ID;

END REMOVE_LOAD_OBLIGATION;
----------------------------------------------------------------------------------------------------
PROCEDURE DELETE_ZERO_LOAD_OBLIGATION
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	DELETE LOAD_OBLIGATION_SCHEDULE A
	WHERE A.OBLIGATION_ID IN
			(SELECT OBLIGATION_ID
			FROM LOAD_OBLIGATION_SCHEDULE
			WHERE OBLIGATION_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND OBLIGATION_TYPE = 1
			GROUP BY OBLIGATION_ID
			HAVING SUM(OBLIGATION_LOAD_VAL) = 0)
		AND A.OBLIGATION_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND A.OBLIGATION_TYPE = 1;

END DELETE_ZERO_LOAD_OBLIGATION;
----------------------------------------------------------------------------------------------------
-- Delete data for all the txns created by the Accept process.  This is determined by an entity
--  attribute called "Accepted Load Schedule".
PROCEDURE DELETE_LOAD_SCHEDULES
	(
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_AS_OF_DATE IN DATE
	) AS

CURSOR c_LOAD_TXNS IS
	SELECT OWNER_ENTITY_ID AS TRANSACTION_ID,
		T.BEGIN_DATE,
		NVL(T.END_DATE, p_END_DATE) AS END_DATE
	FROM ENTITY_ATTRIBUTE A, TEMPORAL_ENTITY_ATTRIBUTE T
	WHERE A.ENTITY_DOMAIN_ID = EC.ED_TRANSACTION
		AND A.ATTRIBUTE_NAME = c_ACCEPTED_LOAD_SCHED_ATTR
		AND T.ATTRIBUTE_ID = A.ATTRIBUTE_ID
		AND T.BEGIN_DATE <= p_END_DATE
		AND NVL(T.END_DATE, p_END_DATE) >= p_BEGIN_DATE
		AND T.ATTRIBUTE_VAL = '1';

 	v_BEGIN_DATE DATE;
	v_END_DATE DATE;
BEGIN

	FOR v_TXN IN c_LOAD_TXNS LOOP
		v_BEGIN_DATE := GREATEST(p_BEGIN_DATE, v_TXN.BEGIN_DATE);
		v_END_DATE := LEAST(p_END_DATE, v_TXN.END_DATE);
		DELETE_LOAD_SCHEDULE_FOR_TXN(v_TXN.TRANSACTION_ID, p_SCHEDULE_TYPE, v_BEGIN_DATE, v_END_DATE, p_TIME_ZONE, p_AS_OF_DATE);
	END LOOP;

END DELETE_LOAD_SCHEDULES;
----------------------------------------------------------------------------------------------------
PROCEDURE CREATE_INCUMBENT_OBLIGATION
	(
	p_REQUEST_TYPE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_INCUMBENT_ENTITY IN INCUMBENT_ENTITY%ROWTYPE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_EXCLUDE_UFE_ALLOCATION IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_CURSOR GA.REFCURSOR;
v_LOAD_DATE DATE;
v_LAST_LOAD_DATE DATE := LOW_DATE;
v_LO_VAL NUMBER;
v_TX_VAL NUMBER;
v_DX_VAL NUMBER;
v_UE_VAL NUMBER;
v_AJ_VAL NUMBER;
v_DAYS NUMBER(2);
v_PSE_ALIAS VARCHAR(32);
v_POOL_ALIAS VARCHAR(32) := '';
v_SERVICE_POINT_ALIAS VARCHAR(32) := '';
v_SCHEDULE_GROUP_ALIAS VARCHAR(32) := '';
v_SERVICE_ZONE_ALIAS VARCHAR(32) := '';
v_REQUEST_TYPE CHAR(1);
v_CHANGE BOOLEAN;
v_INDEX BINARY_INTEGER;
v_INTERVAL NUMBER(2);
v_MINUTES NUMBER(2);
v_RUN_MODE NUMBER(1);
v_SG_SERVICE_ZONE_ID NUMBER(9);
v_IS_VERSIONED_REQUEST BOOLEAN;
v_DT_SCHEDULE GA.DATE_TABLE;
v_LO_SCHEDULE GA.FLOAT_TABLE;
v_TX_SCHEDULE GA.FLOAT_TABLE;
v_DX_SCHEDULE GA.FLOAT_TABLE;
v_UE_SCHEDULE GA.FLOAT_TABLE;
v_AJ_SCHEDULE GA.FLOAT_TABLE;
v_SCHEDULE_COORDINATOR v_SC_RECORD;
v_LAST_SCHEDULE_COORDINATOR v_SC_RECORD;
v_LOAD_OBLIGATION LOAD_OBLIGATION%ROWTYPE;
v_LAST_LOAD_OBLIGATION LOAD_OBLIGATION%ROWTYPE;

BEGIN
	SAVEPOINT BEFORE_CREATE_OBL;

	p_STATUS := GA.SUCCESS;
	SELECT DECODE(p_REQUEST_TYPE, 'F','F','B','B','U','A','A','A','F') INTO v_REQUEST_TYPE FROM DUAL;
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	BEGIN
		SELECT RUN_MODE INTO v_RUN_MODE FROM LOAD_FORECAST_SCENARIO WHERE SCENARIO_ID = p_SCENARIO_ID;
	EXCEPTION
		--WE DON'T EXPECT A RUN MODE FOR SETTLEMENT.
		WHEN OTHERS THEN
			v_RUN_MODE := GA.HOUR_MODE; --THIS IS OKAY FOR GAS TOO.  IT IS THE DEFAULT.
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
	END;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('CREATE_INCUMBENT_OBLIGATION');
		LOGS.LOG_DEBUG('BEGIN_DATE=' || UT.TRACE_DATE(v_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || UT.TRACE_DATE(v_END_DATE));
		LOGS.LOG_DEBUG('RUN_MODE=' || TO_CHAR(v_RUN_MODE));
		LOGS.LOG_DEBUG('<sc>,<pse>,<esp>,<pool>,<service point>,<schedule group>,<service zone>,<city gate>,<load code>,<date>,<load>,<tx loss>,<dx loss>,<ufe>,<adjust><days>');
	END IF;

	v_IS_VERSIONED_REQUEST := IS_VERSIONED_REQUEST(v_REQUEST_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE);

	GET_SCHEDULES(p_MODEL_ID, v_REQUEST_TYPE, p_SCENARIO_ID, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, p_STATUS, v_CURSOR);

	IF NOT p_STATUS = 0 THEN
	    RETURN;
	END IF;

	v_LAST_LOAD_OBLIGATION.SC_ID := CONSTANTS.ALL_ID;
	v_LAST_LOAD_OBLIGATION.PSE_ID := CONSTANTS.NOT_ASSIGNED;
	v_LAST_LOAD_OBLIGATION.POOL_ID := CONSTANTS.NOT_ASSIGNED;
	v_LAST_LOAD_OBLIGATION.SERVICE_POINT_ID := CONSTANTS.NOT_ASSIGNED;
	v_LAST_LOAD_OBLIGATION.SERVICE_ZONE_ID := CONSTANTS.NOT_ASSIGNED;
	v_LAST_LOAD_OBLIGATION.SCHEDULE_GROUP_ID := CONSTANTS.NOT_ASSIGNED;
	v_LAST_LOAD_OBLIGATION.OBLIGATION_LOAD_CODE := ' ';

	LOOP
		FETCH v_CURSOR INTO v_LOAD_OBLIGATION.SC_ID,
							v_LOAD_OBLIGATION.PSE_ID,
							v_LOAD_OBLIGATION.ESP_ID,
							v_LOAD_OBLIGATION.EDC_ID,
							v_SCHEDULE_COORDINATOR.SC_SCHEDULE_NAME_PREFIX,
							v_SCHEDULE_COORDINATOR.SC_SCHEDULE_FORMAT,
							v_SCHEDULE_COORDINATOR.SC_SCHEDULE_INTERVAL,
							v_SCHEDULE_COORDINATOR.SC_LOAD_ROUNDING_PREFERENCE,
							v_SCHEDULE_COORDINATOR.SC_LOSS_ROUNDING_PREFERENCE,
							v_SCHEDULE_COORDINATOR.SC_MINIMUM_SCHEDULE_AMT,
							v_SCHEDULE_COORDINATOR.SC_CREATE_TX_LOSS_SCHEDULE,
							v_SCHEDULE_COORDINATOR.SC_CREATE_DX_LOSS_SCHEDULE,
							v_SCHEDULE_COORDINATOR.SC_CREATE_UFE_SCHEDULE,
							v_LOAD_OBLIGATION.POOL_ID,
							v_LOAD_OBLIGATION.SERVICE_POINT_ID,
							v_LOAD_OBLIGATION.SCHEDULE_GROUP_ID,
							v_LOAD_OBLIGATION.SERVICE_ZONE_ID,
							v_LOAD_OBLIGATION.OBLIGATION_LOAD_CODE,
							v_LOAD_DATE,
							v_LO_VAL,
							v_TX_VAL,
							v_DX_VAL,
							v_UE_VAL,
							v_AJ_VAL;
		EXIT WHEN v_CURSOR%NOTFOUND;
		v_CHANGE := FALSE;

-- SC change
		IF (g_USE_PSE_SCHED_CONFIG = 0 AND v_LOAD_OBLIGATION.SC_ID <> v_LAST_LOAD_OBLIGATION.SC_ID)
			OR (g_USE_PSE_SCHED_CONFIG = 1 AND v_LOAD_OBLIGATION.PSE_ID <> v_LAST_LOAD_OBLIGATION.PSE_ID) THEN

			IF p_MODEL_ID = GA.ELECTRIC_MODEL THEN
				SELECT DECODE(UPPER(v_SCHEDULE_COORDINATOR.SC_SCHEDULE_INTERVAL),'15 MINUTE',96,'30 MINUTE',48,'HOUR',24,'DAY',1,24) INTO v_INTERVAL FROM DUAL;
				SELECT DECODE(UPPER(v_SCHEDULE_COORDINATOR.SC_SCHEDULE_INTERVAL),'15 MINUTE',15,'30 MINUTE',30,'HOUR',60,'DAY',0,60) INTO v_MINUTES FROM DUAL;
			ELSE
				v_INTERVAL := 1;
				v_MINUTES := 0;
			END IF;
			v_CHANGE := TRUE;
			UT.CUT_DAY_INTERVAL_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, LOCAL_TIME_ZONE, v_MINUTES, v_BEGIN_DATE, v_END_DATE);
			IF LOGS.IS_DEBUG_ENABLED THEN
				LOGS.LOG_DEBUG('SCHEDULE COORDINATOR SCHEDULE INTERVAL=' || v_SCHEDULE_COORDINATOR.SC_SCHEDULE_INTERVAL || ', INTERVAL=' || TO_CHAR(v_INTERVAL) || ', MINUTES=' || TO_CHAR(v_MINUTES) || ', ADJUSTED BEGIN_DATE=' || UT.TRACE_DATE(v_BEGIN_DATE) || ', ADJUSTED END_DATE=' || UT.TRACE_DATE(v_END_DATE));
			END IF;
		END IF;
-- PSE change
		IF NOT v_LOAD_OBLIGATION.PSE_ID = v_LAST_LOAD_OBLIGATION.PSE_ID THEN
			v_PSE_ALIAS := GET_PSE_ALIAS(v_LOAD_OBLIGATION.PSE_ID);
			v_CHANGE := TRUE;
		END IF;
-- Pool change
		IF NOT v_LOAD_OBLIGATION.POOL_ID = v_LAST_LOAD_OBLIGATION.POOL_ID THEN
			v_POOL_ALIAS := GET_POOL_ALIAS(v_LOAD_OBLIGATION.POOL_ID);
			v_CHANGE := TRUE;
		END IF;
-- Service Point change
		IF NOT v_LOAD_OBLIGATION.SERVICE_POINT_ID = v_LAST_LOAD_OBLIGATION.SERVICE_POINT_ID THEN
			v_SERVICE_POINT_ALIAS := GET_SERVICE_POINT_ALIAS(v_LOAD_OBLIGATION.SERVICE_POINT_ID);
			v_CHANGE := TRUE;
		END IF;
-- Service Zone change
		IF UPPER(v_SCHEDULE_COORDINATOR.SC_SCHEDULE_FORMAT) = 'SERVICE ZONE' AND NOT v_LOAD_OBLIGATION.SERVICE_ZONE_ID = v_LAST_LOAD_OBLIGATION.SERVICE_ZONE_ID THEN
			v_SERVICE_ZONE_ALIAS := GET_SERVICE_ZONE_ALIAS(v_LOAD_OBLIGATION.SERVICE_ZONE_ID);
			v_CHANGE := TRUE;
		END IF;
-- Schedule Group change
		IF NOT v_LOAD_OBLIGATION.SCHEDULE_GROUP_ID = v_LAST_LOAD_OBLIGATION.SCHEDULE_GROUP_ID THEN
			v_SCHEDULE_GROUP_ALIAS := GET_SCHEDULE_GROUP_ALIAS(v_LOAD_OBLIGATION.SCHEDULE_GROUP_ID);
			IF UPPER(v_SCHEDULE_COORDINATOR.SC_SCHEDULE_FORMAT) = 'SCHEDULE GROUP' THEN
				v_SG_SERVICE_ZONE_ID := GET_SERVICE_ZONE_ID(v_LOAD_OBLIGATION.SCHEDULE_GROUP_ID);
			END IF;
			v_CHANGE := TRUE;
		END IF;
-- Obligation Load Code Change
		IF NOT v_LOAD_OBLIGATION.OBLIGATION_LOAD_CODE = v_LAST_LOAD_OBLIGATION.OBLIGATION_LOAD_CODE THEN
			v_CHANGE := TRUE;
			v_LAST_LOAD_DATE := LOW_DATE;
		END IF;

-- Determine the Number of Days of the Specific Day Type are Contained in the Pattern.
		IF GA.ENABLE_SCHEDULE_GROSS_UP AND v_RUN_MODE IN (GA.WEEK_MODE,GA.MONTH_MODE) THEN
			IF NOT TRUNC(FROM_CUT(v_LOAD_DATE, LOCAL_TIME_ZONE) - g_SECOND) = TRUNC(FROM_CUT(v_LAST_LOAD_DATE, LOCAL_TIME_ZONE) - g_SECOND) THEN
				v_DAYS := GET_DAYS_IN_PATTERN(v_RUN_MODE, v_LOAD_OBLIGATION.OBLIGATION_LOAD_CODE, v_LOAD_DATE);
			END IF;
		ELSE
			v_DAYS := 1;
		END IF;

		IF UPPER(v_SCHEDULE_COORDINATOR.SC_SCHEDULE_FORMAT) = 'SCHEDULE GROUP' THEN
			v_LOAD_OBLIGATION.SERVICE_ZONE_ID  := v_SG_SERVICE_ZONE_ID;
		END IF;

		IF v_CHANGE THEN
			IF v_DT_SCHEDULE.COUNT > 0 THEN
				APPLY_ROUNDING_TO_SCHEDULES(v_LAST_SCHEDULE_COORDINATOR, p_EXCLUDE_UFE_ALLOCATION, v_DT_SCHEDULE, v_LO_SCHEDULE, v_TX_SCHEDULE, v_DX_SCHEDULE, v_UE_SCHEDULE);
				SAVE_LOAD_OBLIGATION_SCHEDULES(v_REQUEST_TYPE, v_LAST_LOAD_OBLIGATION.OBLIGATION_ID, v_LAST_SCHEDULE_COORDINATOR, p_EXCLUDE_UFE_ALLOCATION, v_DT_SCHEDULE, v_LO_SCHEDULE, v_TX_SCHEDULE, v_DX_SCHEDULE, v_UE_SCHEDULE, v_AJ_SCHEDULE);
				CLEAR_SCHEDULES(v_DT_SCHEDULE, v_LO_SCHEDULE, v_TX_SCHEDULE, v_DX_SCHEDULE, v_UE_SCHEDULE, v_AJ_SCHEDULE);
			END IF;
			v_LOAD_OBLIGATION.OBLIGATION_INTERVAL := v_SCHEDULE_COORDINATOR.SC_SCHEDULE_INTERVAL;
			v_LOAD_OBLIGATION.OBLIGATION_NAME := MAKE_OBLIGATION_NAME(v_SCHEDULE_COORDINATOR.SC_SCHEDULE_NAME_PREFIX, v_PSE_ALIAS, v_POOL_ALIAS, v_SERVICE_POINT_ALIAS, v_SCHEDULE_GROUP_ALIAS, v_SERVICE_ZONE_ALIAS, v_LOAD_OBLIGATION.OBLIGATION_LOAD_CODE, v_RUN_MODE, UPPER(v_SCHEDULE_COORDINATOR.SC_SCHEDULE_FORMAT));
			v_LOAD_OBLIGATION.OBLIGATION_ID := CX.GET_LOAD_OBLIGATION_ID(v_LOAD_OBLIGATION);
		END IF;

		v_INDEX := v_DT_SCHEDULE.COUNT + 1;
		v_DT_SCHEDULE(v_INDEX) := v_LOAD_DATE;
		v_LO_SCHEDULE(v_INDEX) := v_LO_VAL * v_DAYS;
		v_TX_SCHEDULE(v_INDEX) := v_TX_VAL * v_DAYS;
		v_DX_SCHEDULE(v_INDEX) := v_DX_VAL * v_DAYS;
		v_UE_SCHEDULE(v_INDEX) := v_UE_VAL * v_DAYS;
		v_AJ_SCHEDULE(v_INDEX) := v_AJ_VAL * v_DAYS;

		v_LAST_LOAD_OBLIGATION := v_LOAD_OBLIGATION;
		v_LAST_SCHEDULE_COORDINATOR := v_SCHEDULE_COORDINATOR;
		v_LAST_LOAD_DATE := v_LOAD_DATE;

		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG(v_LOAD_OBLIGATION.OBLIGATION_NAME || ',' ||
				TO_CHAR(v_LOAD_OBLIGATION.SC_ID) || ',' || TO_CHAR(v_LOAD_OBLIGATION.PSE_ID) || ',' || TO_CHAR(v_LOAD_OBLIGATION.ESP_ID) || ',' ||
				TO_CHAR(v_LOAD_OBLIGATION.POOL_ID) || ',' || TO_CHAR(v_LOAD_OBLIGATION.SERVICE_POINT_ID) || ',' || TO_CHAR(v_LOAD_OBLIGATION.SCHEDULE_GROUP_ID) || ',' ||
				TO_CHAR(v_LOAD_OBLIGATION.SERVICE_ZONE_ID) || ',' || v_LOAD_OBLIGATION.OBLIGATION_LOAD_CODE || ',' || UT.TRACE_DATE(v_LOAD_DATE) || ',' ||
				TO_CHAR(v_LO_VAL) || ',' || TO_CHAR(v_TX_VAL) || ',' || TO_CHAR(v_DX_VAL) || ',' || TO_CHAR(v_UE_VAL) || ',' || TO_CHAR(v_AJ_VAL) || ',' || TO_CHAR(v_DAYS));
		END IF;

	END LOOP;
	CLOSE v_CURSOR;

	IF v_DT_SCHEDULE.COUNT > 0 THEN
		APPLY_ROUNDING_TO_SCHEDULES(v_LAST_SCHEDULE_COORDINATOR, p_EXCLUDE_UFE_ALLOCATION, v_DT_SCHEDULE, v_LO_SCHEDULE, v_TX_SCHEDULE, v_DX_SCHEDULE, v_UE_SCHEDULE);
		SAVE_LOAD_OBLIGATION_SCHEDULES(v_REQUEST_TYPE, v_LAST_LOAD_OBLIGATION.OBLIGATION_ID, v_LAST_SCHEDULE_COORDINATOR, p_EXCLUDE_UFE_ALLOCATION, v_DT_SCHEDULE, v_LO_SCHEDULE, v_TX_SCHEDULE, v_DX_SCHEDULE, v_UE_SCHEDULE, v_AJ_SCHEDULE);
	END IF;


EXCEPTION
	WHEN OTHERS THEN
		-- CLOSE CURSOR
		BEGIN
			IF v_CURSOR%ISOPEN THEN
				CLOSE v_CURSOR;
			END IF;
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE();
		END;
		ERRS.LOG_AND_RAISE(p_SAVEPOINT_NAME => 'BEFORE_CREATE_OBL');

END CREATE_INCUMBENT_OBLIGATION;
----------------------------------------------------------------------------------------------------
PROCEDURE CREATE_LOAD_OBLIGATION
	(
	p_REQUEST_TYPE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_INCUMBENT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_EXCLUDE_UFE_ALLOCATION IN NUMBER,
	p_EXCLUDE_ZERO_SCHEDULES IN NUMBER,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

v_MODULE_NAME VARCHAR(16) := CASE UPPER(SUBSTR(p_REQUEST_TYPE,1,1)) WHEN 'F' THEN 'FORECASTING' ELSE 'SETTLEMENT' END;
v_AS_OF_DATE DATE;
v_INCUMBENT_ENTITY INCUMBENT_ENTITY%ROWTYPE;

BEGIN

    $if $$UNIT_TEST_MODE = 1 $THEN
        IF UNIT_TEST_UTIL.g_CURRENT_TEST_PROCEDURE = 'TEST_LOAD_MANAGEMENT_UI.T_ACCEPT_CAST_INTO_SCHEDULES' THEN
            INSERT INTO RTO_WORK(WORK_DATA)
            SELECT 'REQUEST_TYPE=' || p_REQUEST_TYPE || ',' ||
                'MODEL_ID=' || TO_CHAR(p_MODEL_ID) || ',' ||
                'SCENARIO_ID=' || TEXT_UTIL.TO_CHAR_ENTITY(p_SCENARIO_ID,EC.ED_SCENARIO) || ',' ||
                'INCUMBENT_ID=' || p_INCUMBENT_ID || ',' ||
	            'BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE) || ',' ||
                'END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE) || ',' ||
                'AS_OF_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_AS_OF_DATE) || ',' || 
                'EXCLUDE_UFE_ALLOCATION=' || TO_CHAR(p_EXCLUDE_UFE_ALLOCATION) || ',' ||
                'EXCLUDE_ZERO_SCHEDULES=' || TO_CHAR(p_EXCLUDE_ZERO_SCHEDULES)
            FROM DUAL;
            RETURN;
        END IF;
    $end

	IF NOT CAN_READ(v_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(v_MODULE_NAME);
	END IF;

	BEGIN
		SAVEPOINT BEFORE_CREATE_OBL;

		v_AS_OF_DATE := CORRECTED_AS_OF_DATE(p_AS_OF_DATE);
		p_STATUS := GA.SUCCESS;
		v_INCUMBENT_ENTITY := GET_INCUMBENT_ENTITY;
		IF NOT p_INCUMBENT_ID = CONSTANTS.NOT_ASSIGNED THEN
			v_INCUMBENT_ENTITY.INCUMBENT_ID := p_INCUMBENT_ID;
		END IF;

		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG('CREATE_LOAD_OBLIGATION');
			LOGS.LOG_DEBUG('REQUEST_TYPE=' || p_REQUEST_TYPE);
			LOGS.LOG_DEBUG('MODEL_ID=' || TO_CHAR(p_MODEL_ID));
			LOGS.LOG_DEBUG('SCENARIO_ID=' || TO_CHAR(p_SCENARIO_ID));
			LOGS.LOG_DEBUG('INCUMBENT_ID=' || TO_CHAR(v_INCUMBENT_ENTITY.INCUMBENT_ID));
			LOGS.LOG_DEBUG('INCUMBENT_TYPE=' || v_INCUMBENT_ENTITY.INCUMBENT_TYPE);
			LOGS.LOG_DEBUG('BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE));
			LOGS.LOG_DEBUG('END_DATE=' || TO_CHAR(p_END_DATE));
			LOGS.LOG_DEBUG('AS_OF_DATE=' || UT.TRACE_DATE(v_AS_OF_DATE));
			LOGS.LOG_DEBUG('EXCLUDE_UFE_ALLOCATION=' || TO_CHAR(p_EXCLUDE_UFE_ALLOCATION));
			LOGS.LOG_DEBUG('EXCLUDE_ZERO_SCHEDULES=' || TO_CHAR(p_EXCLUDE_ZERO_SCHEDULES));
		END IF;

		EXECUTE IMMEDIATE 'TRUNCATE TABLE LOAD_OBLIGATION_SCHEDULE';

		CX.CACHE_LOAD_OBLIGATION;

		CREATE_INCUMBENT_OBLIGATION(p_REQUEST_TYPE, p_MODEL_ID, p_SCENARIO_ID, v_INCUMBENT_ENTITY, TRUNC(p_BEGIN_DATE), TRUNC(p_END_DATE), v_AS_OF_DATE, p_EXCLUDE_UFE_ALLOCATION, p_STATUS);

		IF p_EXCLUDE_ZERO_SCHEDULES = 1 THEN
			DELETE_ZERO_LOAD_OBLIGATION(TRUNC(p_BEGIN_DATE), TRUNC(p_END_DATE));
		END IF;

		CX.RELEASE_LOAD_OBLIGATION;

	EXCEPTION
		WHEN OTHERS THEN
			ERRS.LOG_AND_RAISE(p_SAVEPOINT_NAME => 'BEFORE_CREATE_OBL');
	END;
END CREATE_LOAD_OBLIGATION;
----------------------------------------------------------------------------------------------------
PROCEDURE ACCEPT_INCUMBENT_OBLIGATION_DT
	(
	p_REQUEST_TYPE IN VARCHAR,
    p_STATEMENT_TYPE IN NUMBER,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_BEGIN_DATETIME IN DATE,
	p_END_DATETIME IN DATE,
	p_AS_OF_DATE IN DATE,
	p_CAST_AS_OF_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

CURSOR c_LOAD_OBLIGATION IS
	SELECT DISTINCT B.OBLIGATION_ID, B.OBLIGATION_TYPE, A.OBLIGATION_NAME
	FROM LOAD_OBLIGATION A, LOAD_OBLIGATION_SCHEDULE B
	WHERE B.OBLIGATION_ID = A.OBLIGATION_ID
		AND B.OBLIGATION_DATE BETWEEN p_BEGIN_DATETIME AND p_END_DATETIME
	ORDER BY 1,2;

BEGIN
	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	BEGIN
		SAVEPOINT BEFORE_ACCEPT_OBL;

		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG('ACCEPT_INCUMBENT_OBLIGATION');
			LOGS.LOG_DEBUG('STATEMENT_TYPE=' || TO_CHAR(p_STATEMENT_TYPE));
			LOGS.LOG_DEBUG('MODEL_ID=' || TO_CHAR(p_MODEL_ID));
			LOGS.LOG_DEBUG('SCENARIO_ID=' || TO_CHAR(p_SCENARIO_ID));
			LOGS.LOG_DEBUG('BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE));
			LOGS.LOG_DEBUG('END_DATE=' || TO_CHAR(p_END_DATE));
			LOGS.LOG_DEBUG('AS_OF_DATE=' || UT.TRACE_DATE(p_AS_OF_DATE));
			LOGS.LOG_DEBUG('CAST_AS_OF_DATE=' || UT.TRACE_DATE(p_CAST_AS_OF_DATE));
		END IF;

		p_STATUS := GA.SUCCESS;

		IF GA.ENABLE_LOAD_SCHEDULE_DELETE THEN
			DELETE_LOAD_SCHEDULES(p_STATEMENT_TYPE, p_BEGIN_DATE, p_END_DATE, LOCAL_TIME_ZONE, p_AS_OF_DATE);
		END IF;

		FOR v_LOAD_OBLIGATION IN c_LOAD_OBLIGATION LOOP
			ACCEPT_LOAD_OBLIGATION_DT(p_MODEL_ID, v_LOAD_OBLIGATION.OBLIGATION_NAME, v_LOAD_OBLIGATION.OBLIGATION_ID, v_LOAD_OBLIGATION.OBLIGATION_TYPE, p_STATEMENT_TYPE, p_BEGIN_DATE, p_END_DATE, p_BEGIN_DATETIME, p_END_DATETIME, p_AS_OF_DATE);
		END LOOP;

		ACCEPT_PROCESS_STATUS(p_REQUEST_TYPE, p_BEGIN_DATETIME, p_END_DATETIME, p_CAST_AS_OF_DATE);

		IF p_STATUS = GA.SUCCESS THEN
			XS.PUBLISH_OBLIGATION(p_REQUEST_TYPE, p_MODEL_ID, p_BEGIN_DATETIME, p_END_DATETIME, p_AS_OF_DATE, p_CAST_AS_OF_DATE, p_TRACE_ON, p_STATUS);
		END IF;

	EXCEPTION
		WHEN OTHERS THEN
			ERRS.LOG_AND_RAISE(p_SAVEPOINT_NAME => 'BEFORE_ACCEPT_OBL');
	END;

END ACCEPT_INCUMBENT_OBLIGATION_DT;
----------------------------------------------------------------------------------------------------
PROCEDURE ACCEPT_INCUMBENT_OBLIGATION_EX
	(
	p_REQUEST_TYPE IN VARCHAR,
    p_STATEMENT_TYPE IN NUMBER,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_CAST_AS_OF_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER
	) AS
v_BEGIN_DATE DATE;
v_END_DATE DATE;
BEGIN
    $if $$UNIT_TEST_MODE = 1 $THEN
        IF UNIT_TEST_UTIL.g_CURRENT_TEST_PROCEDURE = 'TEST_LOAD_MANAGEMENT_UI.T_ACCEPT_CAST_INTO_SCHEDULES' THEN
            INSERT INTO RTO_WORK(WORK_DATA)
            SELECT 'REQUEST_TYPE=' || p_REQUEST_TYPE || ',' ||
                'STATEMENT_TYPE=' || TEXT_UTIL.TO_CHAR_ENTITY(p_STATEMENT_TYPE,EC.ED_STATEMENT_TYPE) || ',' ||
                'MODEL_ID=' || TO_CHAR(p_MODEL_ID) || ',' ||
                'SCENARIO_ID=' || TEXT_UTIL.TO_CHAR_ENTITY(p_SCENARIO_ID,EC.ED_SCENARIO) || ',' ||
	            'BEGIN_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE) || ',' ||
                'END_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE) || ',' ||
                'AS_OF_DATE=' || TEXT_UTIL.TO_CHAR_DATE(p_AS_OF_DATE) || ',' || 
                'CAST_AS_OF_DATE='  || TEXT_UTIL.TO_CHAR_DATE(p_CAST_AS_OF_DATE)
            FROM DUAL;
            RETURN;
        END IF;
    $end
    
	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	ACCEPT_INCUMBENT_OBLIGATION_DT(p_REQUEST_TYPE, p_STATEMENT_TYPE, p_MODEL_ID, p_SCENARIO_ID, p_BEGIN_DATE, p_END_DATE, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, p_CAST_AS_OF_DATE, p_TRACE_ON, p_STATUS);
END ACCEPT_INCUMBENT_OBLIGATION_EX;
----------------------------------------------------------------------------------------------------
PROCEDURE ACCEPT_INCUMBENT_OBLIGATION
	(
	p_REQUEST_TYPE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_CAST_AS_OF_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER
	) AS
v_SCHEDULE_TYPE NUMBER(9);
BEGIN
	SELECT DECODE(p_REQUEST_TYPE, 'F',1,'B',2,'U',3,'A',3,1) INTO v_SCHEDULE_TYPE FROM DUAL;
    ACCEPT_INCUMBENT_OBLIGATION_EX(p_REQUEST_TYPE,v_SCHEDULE_TYPE,p_MODEL_ID,p_SCENARIO_ID,
    							p_BEGIN_DATE,p_END_DATE,p_AS_OF_DATE,p_CAST_AS_OF_DATE,
                                p_TRACE_ON,p_STATUS);
END ACCEPT_INCUMBENT_OBLIGATION;
----------------------------------------------------------------------------------------------------
PROCEDURE SELECT_INCUMBENT_OBLIGATION
	(
	p_REQUEST_TYPE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_MIN_INTERVAL OUT VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_MODULE_NAME VARCHAR(16);
v_MIN_FORMAT VARCHAR(16);
v_MINUTES NUMBER(6);

BEGIN

	SELECT DECODE(UPPER(SUBSTR(p_REQUEST_TYPE,1,1)),'F','FORECASTING','SETTLEMENT') INTO v_MODULE_NAME FROM DUAL;
	IF NOT CAN_READ(v_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(v_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

-- Always use the smallest interval (only hour and day are accounted for here).
	SELECT MIN(DECODE(UPPER(OBLIGATION_INTERVAL),'15 MINUTE',15,'30 MINUTE',30,'HOUR',60,'DAY',1440,60)) INTO v_MINUTES FROM LOAD_OBLIGATION;
	SELECT DECODE(v_MINUTES,15,'MI15',30,'MI30',1440,'DD','') INTO v_MIN_FORMAT FROM DUAL;
	SELECT DECODE(v_MINUTES,15,'MI15',30,'MI30',1440,'Day','Hour') INTO p_MIN_INTERVAL FROM DUAL;

	UT.CUT_DATE_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	OPEN p_CURSOR FOR
		SELECT A.OBLIGATION_NAME || DECODE(B.OBLIGATION_TYPE, 2, g_TX_SUFFIX, 3, g_DX_SUFFIX, 4, g_UE_SUFFIX, 5, g_AJ_SUFFIX, g_NO_SUFFIX) "OBLIGATION_NAME",
			B.OBLIGATION_ID,
			FROM_CUT_AS_HED(B.OBLIGATION_DATE, p_TIME_ZONE, v_MIN_FORMAT, p_MODEL_ID, A.OBLIGATION_LOAD_CODE) "OBLIGATION_DATE",
			B.OBLIGATION_LOAD_VAL,
			A.OBLIGATION_INTERVAL
		FROM LOAD_OBLIGATION A, LOAD_OBLIGATION_SCHEDULE B
		WHERE B.OBLIGATION_ID = A.OBLIGATION_ID
			AND B.OBLIGATION_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		ORDER BY 1,3;


END SELECT_INCUMBENT_OBLIGATION;
----------------------------------------------------------------------------------------------------
PROCEDURE SELECT_LOAD_OBLIGATION
	(
	p_OBLIGATION_ID IN NUMBER,
	p_OBLIGATION_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	OPEN p_CURSOR FOR
		SELECT A.OBLIGATION_NAME || DECODE(p_OBLIGATION_TYPE, 2, g_TX_SUFFIX, 3, g_DX_SUFFIX, 4, g_UE_SUFFIX, 5, g_AJ_SUFFIX, g_NO_SUFFIX) "OBLIGATION_NAME",
			FROM_CUT_AS_HED(B.OBLIGATION_DATE, p_TIME_ZONE) AS OBLIGATION_DATE,
			B.OBLIGATION_LOAD_VAL
		FROM LOAD_OBLIGATION A, LOAD_OBLIGATION_SCHEDULE B
		WHERE A.OBLIGATION_ID = p_OBLIGATION_ID
			AND B.OBLIGATION_ID = A.OBLIGATION_ID
			AND B.OBLIGATION_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		    AND B.OBLIGATION_TYPE = p_OBLIGATION_TYPE
		ORDER BY 2;


END SELECT_LOAD_OBLIGATION;
----------------------------------------------------------------------------------------------------
PROCEDURE SAVE_LOAD_OBLIGATION
	(
	p_OBLIGATION_ID IN NUMBER,
	p_OBLIGATION_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_DATA_TRIPLES IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_STRING_TABLE GA.STRING_TABLE;
v_LINE_TABLE GA.STRING_TABLE;
v_DATE VARCHAR(16);
v_TIME VARCHAR(16);
v_INDEX BINARY_INTEGER;
v_LOAD_OBLIGATION_SCHEDULE LOAD_OBLIGATION_SCHEDULE%ROWTYPE;

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;
	UT.TOKENS_FROM_STRING(p_DATA_TRIPLES,';', v_STRING_TABLE);
	v_LOAD_OBLIGATION_SCHEDULE.OBLIGATION_ID := p_OBLIGATION_ID;
	v_LOAD_OBLIGATION_SCHEDULE.OBLIGATION_TYPE := p_OBLIGATION_TYPE;
	v_INDEX := v_STRING_TABLE.FIRST;

 	LOOP
		UT.TOKENS_FROM_STRING(v_STRING_TABLE(v_INDEX),',', v_LINE_TABLE);
		v_DATE := SUBSTR(LTRIM(v_LINE_TABLE(1)),1,10);
		v_TIME := RTRIM(SUBSTR(LTRIM(v_LINE_TABLE(1)),12));
		v_LOAD_OBLIGATION_SCHEDULE.OBLIGATION_DATE := DATE_TIME_AS_CUT(v_DATE, v_TIME, p_TIME_ZONE);
		v_LOAD_OBLIGATION_SCHEDULE.OBLIGATION_LOAD_VAL := TO_NUMBER(v_LINE_TABLE(2));
		PUT_LOAD_OBLIGATION_SCHEDULE(v_LOAD_OBLIGATION_SCHEDULE);
		EXIT WHEN v_INDEX = v_STRING_TABLE.LAST;
		v_INDEX := v_STRING_TABLE.NEXT(v_INDEX);
	END LOOP;


END SAVE_LOAD_OBLIGATION;
----------------------------------------------------------------------------------------------------
FUNCTION GET_ANC_SVC_TXN_ALIAS
(
	p_NAME_PREFIX IN VARCHAR2,
	p_PSE_ALIAS IN VARCHAR2,
	p_POOL_ALIAS IN VARCHAR2,
	p_SERVICE_POINT_ALIAS IN VARCHAR2,
	p_SCHEDULE_GROUP_ALIAS IN VARCHAR2,
	p_SERVICE_ZONE_ALIAS IN VARCHAR2,
	p_SCHEDULE_FORMAT IN VARCHAR2,
	p_ANCILLARY_SERVICE_ALIAS IN VARCHAR2
) RETURN VARCHAR2 AS

	v_OBLIGATION_NAME VARCHAR(128) := '';
	v_NAME_PREFIX VARCHAR(32) := LTRIM(RTRIM(p_NAME_PREFIX));
BEGIN
-- Form the Root of the Obligation Name using the optional SC Name Prefix with the PSE Alias.
	IF NVL(v_NAME_PREFIX, GA.UNDEFINED_ATTRIBUTE) = GA.UNDEFINED_ATTRIBUTE THEN
		v_OBLIGATION_NAME := p_PSE_ALIAS || '_' || p_ANCILLARY_SERVICE_ALIAS || '@';
	ELSE
 		v_OBLIGATION_NAME := v_NAME_PREFIX || '-' || p_PSE_ALIAS || '_' || p_ANCILLARY_SERVICE_ALIAS || '@';
	END IF;

-- Tack on a Qualifier Based Upon the Selected Schedule Format.
	IF p_SCHEDULE_FORMAT IN ('SERVICE POINT','POD') THEN
		v_OBLIGATION_NAME := v_OBLIGATION_NAME || p_SERVICE_POINT_ALIAS;
	ELSIF p_SCHEDULE_FORMAT IN ('POOL','POOL/SUB-POOL') THEN
		v_OBLIGATION_NAME := v_OBLIGATION_NAME || p_POOL_ALIAS;
	ELSIF p_SCHEDULE_FORMAT = 'SCHEDULE GROUP' THEN
		v_OBLIGATION_NAME := v_OBLIGATION_NAME || p_SCHEDULE_GROUP_ALIAS;
	ELSIF p_SCHEDULE_FORMAT = 'SERVICE ZONE' THEN
		v_OBLIGATION_NAME := v_OBLIGATION_NAME || p_SERVICE_ZONE_ALIAS;
	END IF;

	v_OBLIGATION_NAME := SUBSTR(v_OBLIGATION_NAME, 1, LEAST(LENGTH(v_OBLIGATION_NAME), 64));

	RETURN v_OBLIGATION_NAME;
END GET_ANC_SVC_TXN_ALIAS;
----------------------------------------------------------------------------------------------------
PROCEDURE ANC_SVC_SCHEDULES
(
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SCHEDULE_TYPE IN NUMBER,
	p_CURSOR OUT t_cur_ANC_SVC_SCHEDULE
) AS
	v_BEGIN_DATE DATE;
	v_END_DATE DATE;
	v_ANC_SVC_ROUND_PREFERENCE ANCILLARY_SERVICE.ROUNDING_PREFERENCE%TYPE;
	v_ANC_SVC_MIN_SCHED_AMT ANCILLARY_SERVICE.MINIMUM_SCHEDULE_AMT%TYPE;
	v_ROUNDING_PREFERENCE CHAR(1);
BEGIN
	UT.CUT_DATE_RANGE(CONSTANTS.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE,
					v_BEGIN_DATE, v_END_DATE);

	-- Get Ancillary Service's Rounding Preference and Min Schedule Amount
	SELECT ROUNDING_PREFERENCE, MINIMUM_SCHEDULE_AMT
	INTO v_ANC_SVC_ROUND_PREFERENCE, v_ANC_SVC_MIN_SCHED_AMT
	FROM ANCILLARY_SERVICE
	WHERE ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID;

	v_ROUNDING_PREFERENCE := DECODE_ROUNDING_PREFERENCE(v_ANC_SVC_ROUND_PREFERENCE);

	OPEN P_CURSOR FOR
		-- Current Schedule
		SELECT SCHED.SCHEDULE_DATE,
			SCHED.TRANSACTION_ALIAS,
			CUR_SCHED.AMOUNT AS CURRENT_AMOUNT,
			SCHED.AMOUNT AS NEW_AMOUNT
		FROM IT_SCHEDULE CUR_SCHED,
			(SELECT NEW_SCHED.*, TRANSACTION_ID
			 FROM INTERCHANGE_TRANSACTION IT,
				-- New Schedule
				(SELECT ANCILLARY_SERVICE_DATE AS SCHEDULE_DATE, SVC.TRANSACTION_TYPE, SVC.IT_COMMODITY_ID,
					GET_ANC_SVC_TXN_ALIAS(NAME_PREFIX, PSE_ALIAS, POOL_ALIAS, SERVICE_POINT_ALIAS, SCHEDULE_GROUP_ALIAS, SERVICE_ZONE_ALIAS, UPPER(SCHEDULE_FORMAT), ANCILLARY_SERVICE_ALIAS) AS TRANSACTION_ALIAS,
					APPLY_ROUNDING_AND_MINIMUM(AMOUNT, v_ROUNDING_PREFERENCE, v_ANC_SVC_MIN_SCHED_AMT) AS AMOUNT
				FROM ANCILLARY_SERVICE SVC,
					(SELECT SO_ASVC.ANCILLARY_SERVICE_ID,
						SO_ASVC.ANCILLARY_SERVICE_DATE,
						SUM(SO_ASVC.ANCILLARY_SERVICE_VALUE) AS AMOUNT,
						P.PSE_ALIAS,
						-- Schedule Config fields common to PSE and EDC's SC
						CASE WHEN g_USE_PSE_SCHED_CONFIG=1 THEN P.SCHEDULE_NAME_PREFIX ELSE SC.SC_SCHEDULE_NAME_PREFIX END AS NAME_PREFIX,
						CASE WHEN g_USE_PSE_SCHED_CONFIG=1 THEN P.SCHEDULE_FORMAT ELSE SC.SC_SCHEDULE_FORMAT END AS SCHEDULE_FORMAT,
						CASE WHEN UPPER(CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.SCHEDULE_FORMAT ELSE SC.SC_SCHEDULE_FORMAT END) = 'POOL' THEN PL.POOL_ALIAS ELSE CONSTANTS.NOT_ASSIGNED_STRING END AS POOL_ALIAS,
						CASE WHEN UPPER(CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.SCHEDULE_FORMAT ELSE SC.SC_SCHEDULE_FORMAT END) = 'SERVICE POINT' THEN SP.SERVICE_POINT_ALIAS ELSE CONSTANTS.NOT_ASSIGNED_STRING END AS SERVICE_POINT_ALIAS,
						CASE WHEN UPPER(CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.SCHEDULE_FORMAT ELSE SC.SC_SCHEDULE_FORMAT END) = 'SCHEDULE GROUP' THEN SG.SCHEDULE_GROUP_ALIAS ELSE CONSTANTS.NOT_ASSIGNED_STRING END AS SCHEDULE_GROUP_ALIAS,
						CASE WHEN UPPER(CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.SCHEDULE_FORMAT ELSE SC.SC_SCHEDULE_FORMAT END) = 'SERVICE ZONE' THEN SZ.SERVICE_ZONE_ALIAS ELSE CONSTANTS.NOT_ASSIGNED_STRING END AS SERVICE_ZONE_ALIAS
					FROM INCUMBENT_ENTITY IE,
						ENERGY_DISTRIBUTION_COMPANY EDC,
						ENERGY_SERVICE_PROVIDER ESP,
						PROVIDER_SERVICE PS,
						SERVICE_OBLIGATION SO,
						SERVICE_DELIVERY SD,
						PURCHASING_SELLING_ENTITY P,
						SCHEDULE_COORDINATOR SC,
						POOL PL,
						SERVICE_POINT SP,
						SERVICE_ZONE SZ,
						SCHEDULE_GROUP SG,
						SERVICE_OBLIGATION_ANC_SVC SO_ASVC
					WHERE -- When we set 'Allow non-incumbent-entity load' to true
						-- we skip the criteria that forces the schedules to
						-- only include the incumbent entity.
						((g_ACCEPT_NON_INCUMBENT_ENTITY = 0
							AND ((IE.INCUMBENT_TYPE = 'EDC' AND EDC.EDC_ID = IE.INCUMBENT_ID)
								OR (IE.INCUMBENT_TYPE = 'ESP' AND ESP.ESP_ID = IE.INCUMBENT_ID)))
						OR g_ACCEPT_NON_INCUMBENT_ENTITY = 1)
						AND UPPER(SUBSTR(EDC.EDC_STATUS,1,1)) = 'A'
						AND UPPER(SUBSTR(ESP.ESP_STATUS,1,1)) = 'A'
						AND PS.EDC_ID = EDC.EDC_ID
						AND PS.ESP_ID = ESP.ESP_ID
						AND SO.MODEL_ID = GA.DEFAULT_MODEL
						AND SO.SCENARIO_ID = GA.BASE_SCENARIO_ID
						AND SO.AS_OF_DATE = CONSTANTS.LOW_DATE
						AND SO.PROVIDER_SERVICE_ID = PS.PROVIDER_SERVICE_ID
						AND SD.SERVICE_DELIVERY_ID = SO.SERVICE_DELIVERY_ID
						AND P.PSE_ID = PS.PSE_ID
						AND SC.SC_ID(+) = SD.SC_ID
						AND PL.POOL_ID(+) = SD.POOL_ID
						AND SP.SERVICE_POINT_ID(+) = SD.SERVICE_POINT_ID
						AND SZ.SERVICE_ZONE_ID(+) = SD.SERVICE_ZONE_ID
						AND SG.SCHEDULE_GROUP_ID(+) = SD.SCHEDULE_GROUP_ID
						AND SO_ASVC.SERVICE_OBLIGATION_ID = SO.SERVICE_OBLIGATION_ID
						AND SO_ASVC.ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID
						AND SO_ASVC.ANCILLARY_SERVICE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
					GROUP BY SO_ASVC.ANCILLARY_SERVICE_ID,
						SO_ASVC.ANCILLARY_SERVICE_DATE,
						P.PSE_ALIAS,
						CASE WHEN g_USE_PSE_SCHED_CONFIG=1 THEN P.SCHEDULE_NAME_PREFIX ELSE SC.SC_SCHEDULE_NAME_PREFIX END,
						CASE WHEN g_USE_PSE_SCHED_CONFIG=1 THEN P.SCHEDULE_FORMAT ELSE SC.SC_SCHEDULE_FORMAT END,
						CASE WHEN UPPER(CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.SCHEDULE_FORMAT ELSE SC.SC_SCHEDULE_FORMAT END) = 'POOL' THEN PL.POOL_ALIAS ELSE CONSTANTS.NOT_ASSIGNED_STRING END,
						CASE WHEN UPPER(CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.SCHEDULE_FORMAT ELSE SC.SC_SCHEDULE_FORMAT END) = 'SERVICE POINT' THEN SP.SERVICE_POINT_ALIAS ELSE CONSTANTS.NOT_ASSIGNED_STRING END,
						CASE WHEN UPPER(CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.SCHEDULE_FORMAT ELSE SC.SC_SCHEDULE_FORMAT END) = 'SCHEDULE GROUP' THEN SG.SCHEDULE_GROUP_ALIAS ELSE CONSTANTS.NOT_ASSIGNED_STRING END,
						CASE WHEN UPPER(CASE WHEN g_USE_PSE_SCHED_CONFIG = 1 THEN P.SCHEDULE_FORMAT ELSE SC.SC_SCHEDULE_FORMAT END) = 'SERVICE ZONE' THEN SZ.SERVICE_ZONE_ALIAS ELSE CONSTANTS.NOT_ASSIGNED_STRING END) SCHED
				WHERE SCHED.ANCILLARY_SERVICE_ID = SVC.ANCILLARY_SERVICE_ID) NEW_SCHED
			WHERE IT.TRANSACTION_ALIAS(+) = NEW_SCHED.TRANSACTION_ALIAS) SCHED
		WHERE CUR_SCHED.TRANSACTION_ID(+) = SCHED.TRANSACTION_ID
			AND CUR_SCHED.SCHEDULE_DATE(+) = SCHED.SCHEDULE_DATE + 1/86400
			AND CUR_SCHED.SCHEDULE_TYPE(+) = p_SCHEDULE_TYPE
			AND CUR_SCHED.SCHEDULE_STATE(+) = CONSTANTS.INTERNAL_STATE
			AND CUR_SCHED.SCHEDULE_DATE(+) BETWEEN v_BEGIN_DATE AND v_END_DATE
		ORDER BY TRANSACTION_ALIAS, SCHEDULE_DATE;

END ANC_SVC_SCHEDULES;
----------------------------------------------------------------------------------------------------
PROCEDURE ACCEPT_ANC_SVC_INTO_SCHEDULES
(
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_SCHEDULE_TYPE IN NUMBER
) AS
	v_CUT_BEGIN_DATE DATE;
	v_CUT_END_DATE DATE;
	v_DEL_BEGIN DATE;
	v_DEL_END DATE;
	c_ANC_SVC_SCHEDULES t_cur_ANC_SVC_SCHEDULE;
	v_REC_ANC_SVC_SCHEDULE t_ANC_SVC_SCHEDULE;

	-- Interchange Transaction variables
	v_OID INTERCHANGE_TRANSACTION.TRANSACTION_ID%TYPE;
	v_TRANSACTION_ID INTERCHANGE_TRANSACTION.TRANSACTION_ID%TYPE;
	v_TXN_NAME INTERCHANGE_TRANSACTION.TRANSACTION_NAME%TYPE;
	v_TXN_TYPE INTERCHANGE_TRANSACTION.TRANSACTION_TYPE%TYPE;
	v_TXN_COMMODITY_ID INTERCHANGE_TRANSACTION.COMMODITY_ID%TYPE;
	v_PREV_TXN_ALIAS VARCHAR2(64) := 'FIRST';

	-- Ancillary Service
	v_ANC_SVC_ALIAS ANCILLARY_SERVICE.ANCILLARY_SERVICE_ALIAS%TYPE;
	v_ANC_SVC_ROUND_PREFERENCE ANCILLARY_SERVICE.ROUNDING_PREFERENCE%TYPE;
	v_ANC_SVC_MIN_SCHED_AMT ANCILLARY_SERVICE.MINIMUM_SCHEDULE_AMT%TYPE;
	v_ROUNDING_PREFERENCE CHAR(1);

	v_STATUS NUMBER;
	v_EXISTING_COUNT NUMBER;
	v_EXISTING_BEGIN_DATE DATE;
	v_ANC_SVC_ACCEPTED_ATTR TEMPORAL_ENTITY_ATTRIBUTE.ATTRIBUTE_NAME%TYPE;
BEGIN
	-- Get Cut Begin and End Date
	UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_CUT_BEGIN_DATE, v_CUT_END_DATE);

	-- Get Ancillary Service's Alias, Transaction Type, Commodity, Rounding Preference and Min Schedule Amount
	SELECT TRANSACTION_TYPE, IT_COMMODITY_ID, ANCILLARY_SERVICE_ALIAS, ROUNDING_PREFERENCE, MINIMUM_SCHEDULE_AMT
	INTO v_TXN_TYPE, v_TXN_COMMODITY_ID, v_ANC_SVC_ALIAS, v_ANC_SVC_ROUND_PREFERENCE, v_ANC_SVC_MIN_SCHED_AMT
	FROM ANCILLARY_SERVICE
	WHERE ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID;

	v_ROUNDING_PREFERENCE := DECODE_ROUNDING_PREFERENCE(v_ANC_SVC_ROUND_PREFERENCE);

	-- Delete schedule data during the specified data range for transactions
	-- that have a value of 'true' for an Entity Attribute name 'Accepted <Ancillary Service> Schedule'
	FOR v_REC IN (SELECT T.OWNER_ENTITY_ID,
						GREATEST(p_BEGIN_DATE, T.BEGIN_DATE) AS BEGIN_DATE,
						LEAST(p_END_DATE, NVL(T.END_DATE, CONSTANTS.HIGH_DATE)) AS END_DATE
					FROM TEMPORAL_ENTITY_ATTRIBUTE T
					WHERE T.ENTITY_DOMAIN_ID = EC.ED_TRANSACTION
						AND T.ATTRIBUTE_NAME = 'Accepted ' || v_ANC_SVC_ALIAS || ' Schedule'
						AND T.ATTRIBUTE_VAL = '1'
						AND T.BEGIN_DATE <= p_END_DATE
						AND NVL(T.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE) LOOP

		UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, v_REC.BEGIN_DATE, v_REC.END_DATE, p_TIME_ZONE, v_DEL_BEGIN, v_DEL_END);

		DELETE FROM IT_SCHEDULE S
		WHERE S.TRANSACTION_ID = v_REC.OWNER_ENTITY_ID
			AND S.SCHEDULE_DATE BETWEEN v_DEL_BEGIN AND v_DEL_END
			AND S.SCHEDULE_TYPE = p_SCHEDULE_TYPE
			AND S.SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE;

	END LOOP;

	-- Loop over the Ancillary Service schedules
	ANC_SVC_SCHEDULES(p_ANCILLARY_SERVICE_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_SCHEDULE_TYPE, c_ANC_SVC_SCHEDULES);

	LOOP
		FETCH c_ANC_SVC_SCHEDULES INTO v_REC_ANC_SVC_SCHEDULE;
		EXIT WHEN c_ANC_SVC_SCHEDULES%NOTFOUND;

		IF v_PREV_TXN_ALIAS <> v_REC_ANC_SVC_SCHEDULE.TRANSACTION_ALIAS THEN
			v_PREV_TXN_ALIAS := v_REC_ANC_SVC_SCHEDULE.TRANSACTION_ALIAS;
			-- Check if the TXN already exists
			SELECT MIN(TRANSACTION_ID) INTO v_TRANSACTION_ID
			FROM INTERCHANGE_TRANSACTION
			WHERE TRANSACTION_ALIAS = v_REC_ANC_SVC_SCHEDULE.TRANSACTION_ALIAS;

			IF v_TRANSACTION_ID IS NULL THEN
				-- Create a unique name if the TRANSACTION_ALIAS does not exist
				v_TRANSACTION_ID := 0;
				v_TXN_NAME := ENTITY_UTIL.RESOLVE_ENTITY_NAME_CONFLICT(v_REC_ANC_SVC_SCHEDULE.TRANSACTION_ALIAS, EC.ED_TRANSACTION);
			ELSE
				v_TXN_NAME := v_REC_ANC_SVC_SCHEDULE.TRANSACTION_ALIAS;
			END IF;

			-- Update or create a new Transaction
			EM.PUT_TRANSACTION(
					v_OID,--O_OID,
					v_TXN_NAME,--P_TRANSACTION_NAME,
					v_REC_ANC_SVC_SCHEDULE.TRANSACTION_ALIAS,--P_TRANSACTION_ALIAS,
					v_REC_ANC_SVC_SCHEDULE.TRANSACTION_ALIAS,--P_TRANSACTION_DESC,
					v_TRANSACTION_ID,--P_TRANSACTION_ID,
					'Active',--P_TRANSACTION_STATUS
					v_TXN_TYPE,
					NULL,--P_TRANSACTION_IDENTIFIER,
					0, -- --P_IS_FIRM,
					0,--P_IS_IMPORT_SCHEDULE,
					0,--P_IS_EXPORT_SCHEDULE,
					0,--P_IS_BALANCE_TRANSACTION,
					0,--P_IS_BID_OFFER,
					0,--P_IS_EXCLUDE_FROM_POSITION,
					0,--P_IS_IMPORT_EXPORT,
					0,--P_IS_DISPATCHABLE,
					'Day',--P_TRANSACTION_INTERVAL,
					NULL,--P_EXTERNAL_INTERVAL,
					NULL,--P_ETAG_CODE,
					p_BEGIN_DATE,--P_BEGIN_DATE,
					p_END_DATE,--p_END_DATE,
					0,--P_PURCHASER_ID,
					0,--P_SELLER_ID,
					0,--P_CONTRACT_ID,
					0,--P_SC_ID,
					0,--P_POR_ID,
					0,--P_POD_ID,
					v_TXN_COMMODITY_ID,-- P_COMMODITY_ID,
					0,--P_SERVICE_TYPE_ID,
					0,--P_TX_TRANSACTION_ID,
					0,--P_PATH_ID,
					0,--P_LINK_TRANSACTION_ID,
					0,--P_EDC_ID,
					NULL, --P_PSE_ID,
					0,--P_ESP_ID,
					0,--P_POOL_ID,
					0,--P_SCHEDULE_GROUP_ID,
					0,--P_MARKET_PRICE_ID,
					0,--P_ZOR_ID,
					0,--P_ZOD_ID,
					0,--P_SOURCE_ID,
					0,--P_SINK_ID,
					0,--P_RESOURCE_ID,
					0,--P_AGREEMENT_TYPE,
					NULL,--P_APPROVAL_TYPE,
					NULL,--P_LOSS_OPTION,
					NULL,--P_TRAIT_CATEGORY,
					0--P_TP_ID
					);

			-- Set the Entity Attribute flag
			-- Check to see if there's an existing Accept Schedule record that ends one day before the begin date
			v_ANC_SVC_ACCEPTED_ATTR := 'Accepted ' || v_ANC_SVC_ALIAS || ' Schedule';
			
			SELECT COUNT(*) INTO v_EXISTING_COUNT FROM TEMPORAL_ENTITY_ATTRIBUTE WHERE END_DATE = (p_BEGIN_DATE - 1) AND OWNER_ENTITY_ID = v_OID AND ATTRIBUTE_NAME = v_ANC_SVC_ACCEPTED_ATTR;
			IF v_EXISTING_COUNT = 1 THEN
				SELECT BEGIN_DATE INTO v_EXISTING_BEGIN_DATE FROM TEMPORAL_ENTITY_ATTRIBUTE WHERE END_DATE = (p_BEGIN_DATE - 1) AND OWNER_ENTITY_ID = v_OID AND ATTRIBUTE_NAME = v_ANC_SVC_ACCEPTED_ATTR;
				RO.PUT_ENTITY_ATTRIBUTE(p_ATTRIBUTE_NAME => v_ANC_SVC_ACCEPTED_ATTR,
									p_ENTITY_DOMAIN_ID => EC.ED_TRANSACTION,
									p_OWNER_ENTITY_ID  => v_OID,
									p_ATTRIBUTE_TYPE   => 'Boolean',
									p_ATTRIBUTE_VAL    => '1',
									p_BEGIN_DATE       => v_EXISTING_BEGIN_DATE,
									p_END_DATE         => p_END_DATE);
			ELSE
				RO.PUT_ENTITY_ATTRIBUTE(p_ATTRIBUTE_NAME => v_ANC_SVC_ACCEPTED_ATTR,
									p_ENTITY_DOMAIN_ID => EC.ED_TRANSACTION,
									p_OWNER_ENTITY_ID  => v_OID,
									p_ATTRIBUTE_TYPE   => 'Boolean',
									p_ATTRIBUTE_VAL    => '1',
									p_BEGIN_DATE       => p_BEGIN_DATE,
									p_END_DATE         => p_END_DATE);
			END IF;

			v_TRANSACTION_ID := v_OID;
		END IF;

		-- Update the IT_SCHEDULE
		ITJ.PUT_IT_SCHEDULE(p_TRANSACTION_ID => v_TRANSACTION_ID,
							p_SCHEDULE_TYPE => p_SCHEDULE_TYPE,
							p_SCHEDULE_STATE => CONSTANTS.INTERNAL_STATE,
							p_SCHEDULE_DATE => v_REC_ANC_SVC_SCHEDULE.SCHEDULE_DATE + 1/86400,
							p_AS_OF_DATE => CONSTANTS.LOW_DATE,
							p_AMOUNT => APPLY_ROUNDING_AND_MINIMUM(v_REC_ANC_SVC_SCHEDULE.NEW_AMOUNT, v_ROUNDING_PREFERENCE, v_ANC_SVC_MIN_SCHED_AMT),
							p_PRICE => NULL,
							p_STATUS => v_STATUS);

		ERRS.VALIDATE_STATUS('ACCEPT_ANC_SVC_INTO_SCHEDULES', v_STATUS);

	END LOOP;

 	CLOSE c_ANC_SVC_SCHEDULES;

EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			IF c_ANC_SVC_SCHEDULES%ISOPEN THEN
				CLOSE c_ANC_SVC_SCHEDULES;
			END IF;
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE;
		END;
		ERRS.LOG_AND_RAISE;
END ACCEPT_ANC_SVC_INTO_SCHEDULES;
----------------------------------------------------------------------------------------------------
BEGIN
	-- Use PSE's Schedule Configuration to accept schedule
	g_USE_PSE_SCHED_CONFIG := UT.NUMBER_FROM_BOOLEAN(UT.BOOLEAN_FROM_STRING(GET_DICTIONARY_VALUE('Use PSE for Schedule Config',0,'Load Management','?','?','?',0)));

	-- Accept Non-Incumbent Entity Load
	g_ACCEPT_NON_INCUMBENT_ENTITY := UT.NUMBER_FROM_BOOLEAN(UT.BOOLEAN_FROM_STRING(GET_DICTIONARY_VALUE('Accept Non-Incumbent Entity Load',0,'Load Management','?','?','?',0)));
END RS;
/
