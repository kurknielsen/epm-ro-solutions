CREATE OR REPLACE PACKAGE IO_UTIL AS
-- Revision: $Revision: 1.14 $

-- Utility package for Entity Input/Output

-- NOTE: This package is AUTO-GENERATED

FUNCTION WHAT_VERSION RETURN VARCHAR;

FUNCTION GET_ACCOUNT_FIELDS_MAP
	(
	p_REC IN ACCOUNT%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION ACCOUNT_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN ACCOUNT%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_ACCOUNT_GROUP_FIELDS_MAP
	(
	p_REC IN ACCOUNT_GROUP%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION ACCOUNT_GROUP_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN ACCOUNT_GROUP%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_ANCILLARY_SERVICE_FIELDS_M
	(
	p_REC IN ANCILLARY_SERVICE%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION ANCILLARY_SERVICE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN ANCILLARY_SERVICE%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_AREA_FIELDS_MAP
	(
	p_REC IN AREA%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION AREA_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN AREA%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_BILL_CYCLE_FIELDS_MAP
	(
	p_REC IN BILL_CYCLE%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION BILL_CYCLE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN BILL_CYCLE%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_BILL_PARTY_FIELDS_MAP
	(
	p_REC IN BILL_PARTY%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION BILL_PARTY_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN BILL_PARTY%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_BREAKPOINT_FIELDS_MAP
	(
	p_REC IN BREAKPOINT%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION GET_CA_FIELDS_MAP
	(
	p_REC IN CONTROL_AREA%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION CA_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN CONTROL_AREA%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_CALC_PROCESS_FIELDS_MAP
	(
	p_REC IN CALCULATION_PROCESS%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION CALC_PROCESS_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN CALCULATION_PROCESS%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_CALENDAR_FIELDS_MAP
	(
	p_REC IN CALENDAR%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION CALENDAR_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN CALENDAR%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_CASE_LABEL_FIELDS_MAP
	(
	p_REC IN CASE_LABEL%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION CASE_LABEL_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN CASE_LABEL%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_CATEGORY_FIELDS_MAP
	(
	p_REC IN CATEGORY%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION CATEGORY_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN CATEGORY%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_COMPONENT_FIELDS_MAP
	(
	p_REC IN COMPONENT%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION COMPONENT_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN COMPONENT%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_CONDITIONAL_FORMAT_FIELDS_
	(
	p_REC IN CONDITIONAL_FORMAT%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION CONDITIONAL_FORMAT_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN CONDITIONAL_FORMAT%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_CONTACT_FIELDS_MAP
	(
	p_REC IN CONTACT%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION CONTACT_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN CONTACT%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_CONTRACT_FIELDS_MAP
	(
	p_REC IN SERVICE_CONTRACT%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION CONTRACT_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SERVICE_CONTRACT%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_CONTRACT_LIMIT_FIELDS_MAP
	(
	p_REC IN CONTRACT_LIMIT%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION CONTRACT_LIMIT_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN CONTRACT_LIMIT%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_CUSTOMER_FIELDS_MAP
	(
	p_REC IN CUSTOMER%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION CUSTOMER_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN CUSTOMER%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_DATA_LOCK_GROUP_FIELDS_MAP
	(
	p_REC IN DATA_LOCK_GROUP%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION DATA_LOCK_GROUP_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN DATA_LOCK_GROUP%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_DER_FIELDS_MAP
	(
	p_REC IN DISTRIBUTED_ENERGY_RESOURCE%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION DER_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN DISTRIBUTED_ENERGY_RESOURCE%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_DER_TYPE_FIELDS_MAP
	(
	p_REC IN DER_TYPE%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION DER_TYPE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN DER_TYPE%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_DR_EVENT_FIELDS_MAP
	(
	p_REC IN DR_EVENT%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION DR_EVENT_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN DR_EVENT%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_EDC_FIELDS_MAP
	(
	p_REC IN ENERGY_DISTRIBUTION_COMPANY%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION EDC_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN ENERGY_DISTRIBUTION_COMPANY%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_ENTITY_DOMAIN_FIELDS_MAP
	(
	p_REC IN ENTITY_DOMAIN%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION ENTITY_DOMAIN_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN ENTITY_DOMAIN%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_ENTITY_GROUP_FIELDS_MAP
	(
	p_REC IN ENTITY_GROUP%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION ENTITY_GROUP_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN ENTITY_GROUP%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_ESP_FIELDS_MAP
	(
	p_REC IN ENERGY_SERVICE_PROVIDER%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION ESP_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN ENERGY_SERVICE_PROVIDER%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_ETAG_FIELDS_MAP
	(
	p_REC IN ETAG%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION ETAG_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN ETAG%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_EXTERNAL_SYSTEM_FIELDS_MAP
	(
	p_REC IN EXTERNAL_SYSTEM%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION EXTERNAL_SYSTEM_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN EXTERNAL_SYSTEM%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_EXTERNAL_TRANSACTION_FIELD
	(
	p_REC IN INTERCHANGE_TRANSACTION_EXT%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION EXTERNAL_TRANSACTION_IS_ALLOWE
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN INTERCHANGE_TRANSACTION_EXT%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_GEOGRAPHY_FIELDS_MAP
	(
	p_REC IN GEOGRAPHY%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION GEOGRAPHY_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN GEOGRAPHY%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_GROWTH_PATTERN_FIELDS_MAP
	(
	p_REC IN GROWTH_PATTERN%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION GROWTH_PATTERN_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN GROWTH_PATTERN%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_HEAT_RATE_CURVE_FIELDS_MAP
	(
	p_REC IN HEAT_RATE_CURVE%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION HEAT_RATE_CURVE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN HEAT_RATE_CURVE%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_HOLIDAY_FIELDS_MAP
	(
	p_REC IN HOLIDAY%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION HOLIDAY_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN HOLIDAY%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_HOLIDAY_SET_FIELDS_MAP
	(
	p_REC IN HOLIDAY_SET%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION HOLIDAY_SET_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN HOLIDAY_SET%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_INTERCHANGE_CONTRACT_FIELD
	(
	p_REC IN INTERCHANGE_CONTRACT%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION INTERCHANGE_CONTRACT_IS_ALLOWE
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN INTERCHANGE_CONTRACT%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_INVOICE_GROUP_FIELDS_MAP
	(
	p_REC IN INVOICE_GROUP%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION INVOICE_GROUP_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN INVOICE_GROUP%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_IT_COMMODITY_FIELDS_MAP
	(
	p_REC IN IT_COMMODITY%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION IT_COMMODITY_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN IT_COMMODITY%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_JOB_THREAD_FIELDS_MAP
	(
	p_REC IN JOB_THREAD%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION JOB_THREAD_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN JOB_THREAD%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_LOAD_PROFILE_FIELDS_MAP
	(
	p_REC IN LOAD_PROFILE%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION LOAD_PROFILE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN LOAD_PROFILE%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_LOAD_PROFILE_LIBRARY_FIELD
	(
	p_REC IN LOAD_PROFILE_LIBRARY%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION LOAD_PROFILE_LIBRARY_IS_ALLOWE
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN LOAD_PROFILE_LIBRARY%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_LOAD_PROFILE_SET_FIELDS_MA
	(
	p_REC IN LOAD_PROFILE_SET%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION GET_LOSS_FACTOR_FIELDS_MAP
	(
	p_REC IN LOSS_FACTOR%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION LOSS_FACTOR_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN LOSS_FACTOR%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_MARKET_PRICE_FIELDS_MAP
	(
	p_REC IN MARKET_PRICE%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION MARKET_PRICE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN MARKET_PRICE%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_MEASUREMENT_SOURCE_FIELDS_
	(
	p_REC IN MEASUREMENT_SOURCE%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION MEASUREMENT_SOURCE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN MEASUREMENT_SOURCE%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_METER_FIELDS_MAP
	(
	p_REC IN METER%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION METER_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN METER%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_MRSP_FIELDS_MAP
	(
	p_REC IN METER_READING_SERVICE_PROVIDER%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION MRSP_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN METER_READING_SERVICE_PROVIDER%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_OASIS_NODE_FIELDS_MAP
	(
	p_REC IN OASIS_NODE%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION OASIS_NODE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN OASIS_NODE%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_PATH_FIELDS_MAP
	(
	p_REC IN TX_PATH%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION PATH_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN TX_PATH%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_PERIOD_FIELDS_MAP
	(
	p_REC IN PERIOD%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION PERIOD_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN PERIOD%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_PIPELINE_FIELDS_MAP
	(
	p_REC IN PIPELINE%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION PIPELINE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN PIPELINE%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_POOL_FIELDS_MAP
	(
	p_REC IN POOL%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION POOL_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN POOL%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_PORTFOLIO_FIELDS_MAP
	(
	p_REC IN PORTFOLIO%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION PORTFOLIO_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN PORTFOLIO%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_POSITION_EVALUATION_FIELDS
	(
	p_REC IN POSITION_ANALYSIS_EVALUATION%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION GET_PRODUCT_FIELDS_MAP
	(
	p_REC IN PRODUCT%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION PRODUCT_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN PRODUCT%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_PROGRAM_FIELDS_MAP
	(
	p_REC IN PROGRAM%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION PROGRAM_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN PROGRAM%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_PROSPECT_SCREEN_FIELDS_MAP
	(
	p_REC IN PROSPECT_SCREEN%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION GET_PROXY_DAY_METHOD_FIELDS_MA
	(
	p_REC IN PROXY_DAY_METHOD%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION PROXY_DAY_METHOD_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN PROXY_DAY_METHOD%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_PSE_FIELDS_MAP
	(
	p_REC IN PURCHASING_SELLING_ENTITY%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION PSE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN PURCHASING_SELLING_ENTITY%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_QUOTE_REQUEST_FIELDS_MAP
	(
	p_REC IN QUOTE_REQUEST%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION QUOTE_REQUEST_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN QUOTE_REQUEST%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_REACTOR_PROCEDURE_FIELDS_M
	(
	p_REC IN REACTOR_PROCEDURE%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION REACTOR_PROCEDURE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN REACTOR_PROCEDURE%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_RESOURCE_GROUP_FIELDS_MAP
	(
	p_REC IN SUPPLY_RESOURCE_GROUP%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION RESOURCE_GROUP_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SUPPLY_RESOURCE_GROUP%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_ROLLUP_FIELDS_MAP
	(
	p_REC IN RTO_ROLLUP%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION GET_SC_FIELDS_MAP
	(
	p_REC IN SCHEDULE_COORDINATOR%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION SC_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SCHEDULE_COORDINATOR%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_SCENARIO_FIELDS_MAP
	(
	p_REC IN SCENARIO%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION SCENARIO_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SCENARIO%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_SCHEDULE_GROUP_FIELDS_MAP
	(
	p_REC IN SCHEDULE_GROUP%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION SCHEDULE_GROUP_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SCHEDULE_GROUP%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_SEASON_FIELDS_MAP
	(
	p_REC IN SEASON%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION SEASON_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SEASON%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_SEGMENT_FIELDS_MAP
	(
	p_REC IN TX_SEGMENT%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION SEGMENT_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN TX_SEGMENT%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_SERVICE_AREA_FIELDS_MAP
	(
	p_REC IN SERVICE_AREA%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION SERVICE_AREA_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SERVICE_AREA%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_SERVICE_LOCATION_FIELDS_MA
	(
	p_REC IN SERVICE_LOCATION%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION SERVICE_LOCATION_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SERVICE_LOCATION%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_SERVICE_POINT_FIELDS_MAP
	(
	p_REC IN SERVICE_POINT%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION SERVICE_POINT_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SERVICE_POINT%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_SERVICE_REGION_FIELDS_MAP
	(
	p_REC IN SERVICE_REGION%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION SERVICE_REGION_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SERVICE_REGION%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_SERVICE_TYPE_FIELDS_MAP
	(
	p_REC IN TX_SERVICE_TYPE%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION SERVICE_TYPE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN TX_SERVICE_TYPE%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_SERVICE_ZONE_FIELDS_MAP
	(
	p_REC IN SERVICE_ZONE%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION SERVICE_ZONE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SERVICE_ZONE%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_SETTLEMENT_TYPE_FIELDS_MAP
	(
	p_REC IN SETTLEMENT_TYPE%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION SETTLEMENT_TYPE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SETTLEMENT_TYPE%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_STATEMENT_TYPE_FIELDS_MAP
	(
	p_REC IN STATEMENT_TYPE%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION STATEMENT_TYPE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN STATEMENT_TYPE%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_SUB_STATION_FIELDS_MAP
	(
	p_REC IN TX_SUB_STATION%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION SUB_STATION_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN TX_SUB_STATION%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_SUB_STATION_METER_FIELDS_M
	(
	p_REC IN TX_SUB_STATION_METER%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION SUB_STATION_METER_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN TX_SUB_STATION_METER%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_SUB_STATION_METER_POINT_FI
	(
	p_REC IN TX_SUB_STATION_METER_POINT%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION SUB_STATION_METER_POINT_IS_ALL
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN TX_SUB_STATION_METER_POINT%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_SUPPLY_RESOURCE_FIELDS_MAP
	(
	p_REC IN SUPPLY_RESOURCE%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION SUPPLY_RESOURCE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SUPPLY_RESOURCE%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_SYSTEM_ACTION_FIELDS_MAP
	(
	p_REC IN SYSTEM_ACTION%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION SYSTEM_ACTION_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SYSTEM_ACTION%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_SYSTEM_ALERT_FIELDS_MAP
	(
	p_REC IN SYSTEM_ALERT%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION SYSTEM_ALERT_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SYSTEM_ALERT%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_SYSTEM_EVENT_FIELDS_MAP
	(
	p_REC IN SYSTEM_EVENT%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION SYSTEM_EVENT_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SYSTEM_EVENT%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_SYSTEM_LOAD_FIELDS_MAP
	(
	p_REC IN SYSTEM_LOAD%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION SYSTEM_LOAD_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SYSTEM_LOAD%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_SYSTEM_REALM_FIELDS_MAP
	(
	p_REC IN SYSTEM_REALM%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION SYSTEM_REALM_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SYSTEM_REALM%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_SYSTEM_TABLE_FIELDS_MAP
	(
	p_REC IN SYSTEM_TABLE%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION SYSTEM_TABLE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SYSTEM_TABLE%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_TEMPLATE_FIELDS_MAP
	(
	p_REC IN TEMPLATE%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION TEMPLATE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN TEMPLATE%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_TP_FIELDS_MAP
	(
	p_REC IN TRANSMISSION_PROVIDER%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION TP_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN TRANSMISSION_PROVIDER%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_TRANSACTION_FIELDS_MAP
	(
	p_REC IN INTERCHANGE_TRANSACTION%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION TRANSACTION_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN INTERCHANGE_TRANSACTION%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_TRANSACTION_TRAIT_GROUP_FI
	(
	p_REC IN TRANSACTION_TRAIT_GROUP%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION TRANSACTION_TRAIT_GROUP_IS_ALL
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN TRANSACTION_TRAIT_GROUP%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_TX_FEEDER_FIELDS_MAP
	(
	p_REC IN TX_FEEDER%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION TX_FEEDER_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN TX_FEEDER%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_TX_FEEDER_SEGMENT_FIELDS_M
	(
	p_REC IN TX_FEEDER_SEGMENT%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION TX_FEEDER_SEGMENT_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN TX_FEEDER_SEGMENT%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_USAGE_WRF_FIELDS_MAP
	(
	p_REC IN USAGE_WRF%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION GET_VPP_FIELDS_MAP
	(
	p_REC IN VIRTUAL_POWER_PLANT%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION VPP_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN VIRTUAL_POWER_PLANT%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_WEATHER_PARAMETER_FIELDS_M
	(
	p_REC IN WEATHER_PARAMETER%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION WEATHER_PARAMETER_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN WEATHER_PARAMETER%ROWTYPE
	) RETURN BOOLEAN;
    
FUNCTION GET_WEATHER_STATION_FIELDS_MAP
	(
	p_REC IN WEATHER_STATION%ROWTYPE
	) RETURN UT.STRING_MAP;

FUNCTION WEATHER_STATION_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN WEATHER_STATION%ROWTYPE
	) RETURN BOOLEAN;
    

END IO_UTIL;
/

CREATE OR REPLACE PACKAGE BODY IO_UTIL AS
---------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
    RETURN '$Revision: 1.14 $';
END WHAT_VERSION;
---------------------------------------------------------------------
FUNCTION GET_ACCOUNT_FIELDS_MAP
	(
	p_REC IN ACCOUNT%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('ACCOUNT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.ACCOUNT_ID);
	v_RET('ACCOUNT_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.ACCOUNT_NAME);
	v_RET('ACCOUNT_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.ACCOUNT_ALIAS);
	v_RET('ACCOUNT_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.ACCOUNT_DESC);
	v_RET('ACCOUNT_DUNS_NUMBER') := UT.GET_LITERAL_FOR_STRING(p_REC.ACCOUNT_DUNS_NUMBER);
	v_RET('ACCOUNT_EXTERNAL_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_REC.ACCOUNT_EXTERNAL_IDENTIFIER);
	v_RET('ACCOUNT_MODEL_OPTION') := UT.GET_LITERAL_FOR_STRING(p_REC.ACCOUNT_MODEL_OPTION);
	v_RET('ACCOUNT_SIC_CODE') := UT.GET_LITERAL_FOR_STRING(p_REC.ACCOUNT_SIC_CODE);
	v_RET('ACCOUNT_METER_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.ACCOUNT_METER_TYPE);
	v_RET('ACCOUNT_METER_EXT_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_REC.ACCOUNT_METER_EXT_IDENTIFIER);
	v_RET('ACCOUNT_DISPLAY_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.ACCOUNT_DISPLAY_NAME);
	v_RET('ACCOUNT_BILL_OPTION') := UT.GET_LITERAL_FOR_STRING(p_REC.ACCOUNT_BILL_OPTION);
	v_RET('ACCOUNT_ROLLUP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.ACCOUNT_ROLLUP_ID);
	v_RET('IS_EXTERNAL_INTERVAL_USAGE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_EXTERNAL_INTERVAL_USAGE);
	v_RET('IS_EXTERNAL_BILLED_USAGE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_EXTERNAL_BILLED_USAGE);
	v_RET('IS_AGGREGATE_ACCOUNT') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_AGGREGATE_ACCOUNT);
	v_RET('IS_UFE_PARTICIPANT') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_UFE_PARTICIPANT);
	v_RET('IS_CREATE_SETTLEMENT_PROFILE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_CREATE_SETTLEMENT_PROFILE);
	v_RET('IS_EXTERNAL_FORECAST') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_EXTERNAL_FORECAST);
	v_RET('IS_SUB_AGGREGATE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_SUB_AGGREGATE);
	v_RET('TX_SERVICE_TYPE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.TX_SERVICE_TYPE_ID);
	v_RET('USE_TOU_USAGE_FACTOR') := UT.GET_LITERAL_FOR_NUMBER(p_REC.USE_TOU_USAGE_FACTOR);
	v_RET('MODEL_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.MODEL_ID);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_ACCOUNT_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION ACCOUNT_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN ACCOUNT%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_ACCOUNT_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_ACCOUNT);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_ACCOUNT, v_REALMS);
END ACCOUNT_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_ACCOUNT_GROUP_FIELDS_MAP
	(
	p_REC IN ACCOUNT_GROUP%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('ACCOUNT_GROUP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.ACCOUNT_GROUP_ID);
	v_RET('ACCOUNT_GROUP_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.ACCOUNT_GROUP_NAME);
	v_RET('ACCOUNT_GROUP_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.ACCOUNT_GROUP_ALIAS);
	v_RET('ACCOUNT_GROUP_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.ACCOUNT_GROUP_DESC);
	v_RET('EXTERNAL_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_REC.EXTERNAL_IDENTIFIER);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_ACCOUNT_GROUP_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION ACCOUNT_GROUP_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN ACCOUNT_GROUP%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_ACCOUNT_GROUP_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_ACCOUNT_GROUP);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_ACCOUNT_GROUP, v_REALMS);
END ACCOUNT_GROUP_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_ANCILLARY_SERVICE_FIELDS_M
	(
	p_REC IN ANCILLARY_SERVICE%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('ANCILLARY_SERVICE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.ANCILLARY_SERVICE_ID);
	v_RET('ANCILLARY_SERVICE_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.ANCILLARY_SERVICE_NAME);
	v_RET('ANCILLARY_SERVICE_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.ANCILLARY_SERVICE_ALIAS);
	v_RET('ANCILLARY_SERVICE_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.ANCILLARY_SERVICE_DESC);
	v_RET('ANCILLARY_SERVICE_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.ANCILLARY_SERVICE_TYPE);
	v_RET('PROVIDER_CATEGORY') := UT.GET_LITERAL_FOR_STRING(p_REC.PROVIDER_CATEGORY);
	v_RET('PROVIDER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PROVIDER_ID);
	v_RET('TRANSACTION_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.TRANSACTION_TYPE);
	v_RET('IT_COMMODITY_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IT_COMMODITY_ID);
	v_RET('ROUNDING_PREFERENCE') := UT.GET_LITERAL_FOR_STRING(p_REC.ROUNDING_PREFERENCE);
	v_RET('MINIMUM_SCHEDULE_AMT') := UT.GET_LITERAL_FOR_NUMBER(p_REC.MINIMUM_SCHEDULE_AMT);
	v_RET('ANCILLARY_SERVICE_UNIT') := UT.GET_LITERAL_FOR_STRING(p_REC.ANCILLARY_SERVICE_UNIT);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_ANCILLARY_SERVICE_FIELDS_M;
---------------------------------------------------------------------
FUNCTION ANCILLARY_SERVICE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN ANCILLARY_SERVICE%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_ANCILLARY_SERVICE_FIELDS_M(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_ANCILLARY_SERVICE);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_ANCILLARY_SERVICE, v_REALMS);
END ANCILLARY_SERVICE_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_AREA_FIELDS_MAP
	(
	p_REC IN AREA%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('AREA_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.AREA_ID);
	v_RET('AREA_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.AREA_NAME);
	v_RET('AREA_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.AREA_ALIAS);
	v_RET('AREA_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.AREA_DESC);
	v_RET('AREA_INTERVAL') := UT.GET_LITERAL_FOR_STRING(p_REC.AREA_INTERVAL);
	v_RET('PROJECTION_PERIOD') := UT.GET_LITERAL_FOR_STRING(p_REC.PROJECTION_PERIOD);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_AREA_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION AREA_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN AREA%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_AREA_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_AREA);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_AREA, v_REALMS);
END AREA_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_BILL_CYCLE_FIELDS_MAP
	(
	p_REC IN BILL_CYCLE%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('BILL_CYCLE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.BILL_CYCLE_ID);
	v_RET('BILL_CYCLE_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.BILL_CYCLE_NAME);
	v_RET('BILL_CYCLE_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.BILL_CYCLE_ALIAS);
	v_RET('BILL_CYCLE_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.BILL_CYCLE_DESC);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_BILL_CYCLE_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION BILL_CYCLE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN BILL_CYCLE%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_BILL_CYCLE_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_BILL_CYCLE);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_BILL_CYCLE, v_REALMS);
END BILL_CYCLE_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_BILL_PARTY_FIELDS_MAP
	(
	p_REC IN BILL_PARTY%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('BILL_PARTY_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.BILL_PARTY_ID);
	v_RET('BILL_PARTY_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.BILL_PARTY_NAME);
	v_RET('BILL_PARTY_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.BILL_PARTY_ALIAS);
	v_RET('BILL_PARTY_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.BILL_PARTY_DESC);
	v_RET('BILL_PARTY_STATUS') := UT.GET_LITERAL_FOR_STRING(p_REC.BILL_PARTY_STATUS);
	v_RET('EXTERNAL_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_REC.EXTERNAL_IDENTIFIER);
	v_RET('IS_INVOICE_DETAIL') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_INVOICE_DETAIL);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_BILL_PARTY_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION BILL_PARTY_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN BILL_PARTY%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_BILL_PARTY_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_BILL_PARTY);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_BILL_PARTY, v_REALMS);
END BILL_PARTY_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_BREAKPOINT_FIELDS_MAP
	(
	p_REC IN BREAKPOINT%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('BREAKPOINT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.BREAKPOINT_ID);
	v_RET('BREAKPOINT_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.BREAKPOINT_NAME);
	v_RET('BREAKPOINT_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.BREAKPOINT_ALIAS);
	v_RET('BREAKPOINT_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.BREAKPOINT_DESC);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_BREAKPOINT_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION GET_CA_FIELDS_MAP
	(
	p_REC IN CONTROL_AREA%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('CA_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.CA_ID);
	v_RET('CA_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.CA_NAME);
	v_RET('CA_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.CA_ALIAS);
	v_RET('CA_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.CA_DESC);
	v_RET('CA_NERC_CODE') := UT.GET_LITERAL_FOR_STRING(p_REC.CA_NERC_CODE);
	v_RET('CA_STATUS') := UT.GET_LITERAL_FOR_STRING(p_REC.CA_STATUS);
	v_RET('CA_DUNS_NUMBER') := UT.GET_LITERAL_FOR_STRING(p_REC.CA_DUNS_NUMBER);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_CA_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION CA_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN CONTROL_AREA%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_CA_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_CA);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_CA, v_REALMS);
END CA_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_CALC_PROCESS_FIELDS_MAP
	(
	p_REC IN CALCULATION_PROCESS%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('CALC_PROCESS_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.CALC_PROCESS_ID);
	v_RET('CALC_PROCESS_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.CALC_PROCESS_NAME);
	v_RET('CALC_PROCESS_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.CALC_PROCESS_ALIAS);
	v_RET('CALC_PROCESS_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.CALC_PROCESS_DESC);
	v_RET('CALC_PROCESS_CATEGORY') := UT.GET_LITERAL_FOR_STRING(p_REC.CALC_PROCESS_CATEGORY);
	v_RET('TIME_ZONE') := UT.GET_LITERAL_FOR_STRING(p_REC.TIME_ZONE);
	v_RET('PROCESS_INTERVAL') := UT.GET_LITERAL_FOR_STRING(p_REC.PROCESS_INTERVAL);
	v_RET('WEEK_BEGIN') := UT.GET_LITERAL_FOR_STRING(p_REC.WEEK_BEGIN);
	v_RET('CONTEXT_DOMAIN_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.CONTEXT_DOMAIN_ID);
	v_RET('CONTEXT_REALM_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.CONTEXT_REALM_ID);
	v_RET('CONTEXT_GROUP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.CONTEXT_GROUP_ID);
	v_RET('CONTEXT_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.CONTEXT_NAME);
	v_RET('IS_STATEMENT_TYPE_SPECIFIC') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_STATEMENT_TYPE_SPECIFIC);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_CALC_PROCESS_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION CALC_PROCESS_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN CALCULATION_PROCESS%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_CALC_PROCESS_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_CALC_PROCESS);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_CALC_PROCESS, v_REALMS);
END CALC_PROCESS_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_CALENDAR_FIELDS_MAP
	(
	p_REC IN CALENDAR%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('CALENDAR_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.CALENDAR_ID);
	v_RET('CALENDAR_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.CALENDAR_NAME);
	v_RET('CALENDAR_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.CALENDAR_ALIAS);
	v_RET('CALENDAR_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.CALENDAR_DESC);
	v_RET('ASSIGNMENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.ASSIGNMENT_TYPE);
	v_RET('HAS_ADJUSTMENTS') := UT.GET_LITERAL_FOR_NUMBER(p_REC.HAS_ADJUSTMENTS);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_CALENDAR_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION CALENDAR_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN CALENDAR%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_CALENDAR_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_CALENDAR);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_CALENDAR, v_REALMS);
END CALENDAR_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_CASE_LABEL_FIELDS_MAP
	(
	p_REC IN CASE_LABEL%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('CASE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.CASE_ID);
	v_RET('CASE_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.CASE_NAME);
	v_RET('CASE_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.CASE_ALIAS);
	v_RET('CASE_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.CASE_DESC);
	v_RET('CASE_CATEGORY') := UT.GET_LITERAL_FOR_STRING(p_REC.CASE_CATEGORY);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_CASE_LABEL_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION CASE_LABEL_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN CASE_LABEL%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_CASE_LABEL_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_CASE_LABEL);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_CASE_LABEL, v_REALMS);
END CASE_LABEL_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_CATEGORY_FIELDS_MAP
	(
	p_REC IN CATEGORY%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('CATEGORY_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.CATEGORY_ID);
	v_RET('CATEGORY_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.CATEGORY_NAME);
	v_RET('CATEGORY_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.CATEGORY_ALIAS);
	v_RET('CATEGORY_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.CATEGORY_DESC);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_CATEGORY_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION CATEGORY_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN CATEGORY%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_CATEGORY_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_CATEGORY);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_CATEGORY, v_REALMS);
END CATEGORY_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_COMPONENT_FIELDS_MAP
	(
	p_REC IN COMPONENT%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.COMPONENT_ID);
	v_RET('COMPONENT_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.COMPONENT_NAME);
	v_RET('COMPONENT_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.COMPONENT_ALIAS);
	v_RET('COMPONENT_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.COMPONENT_DESC);
	v_RET('COMPONENT_ENTITY') := UT.GET_LITERAL_FOR_STRING(p_REC.COMPONENT_ENTITY);
	v_RET('CHARGE_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.CHARGE_TYPE);
	v_RET('RATE_STRUCTURE') := UT.GET_LITERAL_FOR_STRING(p_REC.RATE_STRUCTURE);
	v_RET('RATE_INTERVAL') := UT.GET_LITERAL_FOR_STRING(p_REC.RATE_INTERVAL);
	v_RET('IS_REBILL') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_REBILL);
	v_RET('IS_TAXED') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_TAXED);
	v_RET('IS_CUSTOM_CHARGE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_CUSTOM_CHARGE);
	v_RET('IS_CREDIT_CHARGE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_CREDIT_CHARGE);
	v_RET('IS_INCLUDE_TX_LOSS') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_INCLUDE_TX_LOSS);
	v_RET('IS_INCLUDE_DX_LOSS') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_INCLUDE_DX_LOSS);
	v_RET('TEMPLATE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.TEMPLATE_ID);
	v_RET('MARKET_PRICE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.MARKET_PRICE_ID);
	v_RET('SERVICE_POINT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SERVICE_POINT_ID);
	v_RET('MODEL_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.MODEL_ID);
	v_RET('EVENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.EVENT_ID);
	v_RET('COMPONENT_REFERENCE') := UT.GET_LITERAL_FOR_STRING(p_REC.COMPONENT_REFERENCE);
	v_RET('INVOICE_GROUP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.INVOICE_GROUP_ID);
	v_RET('INVOICE_GROUP_ORDER') := UT.GET_LITERAL_FOR_NUMBER(p_REC.INVOICE_GROUP_ORDER);
	v_RET('COMPUTATION_ORDER') := UT.GET_LITERAL_FOR_NUMBER(p_REC.COMPUTATION_ORDER);
	v_RET('QUANTITY_UNIT') := UT.GET_LITERAL_FOR_STRING(p_REC.QUANTITY_UNIT);
	v_RET('CURRENCY_UNIT') := UT.GET_LITERAL_FOR_STRING(p_REC.CURRENCY_UNIT);
	v_RET('QUANTITY_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.QUANTITY_TYPE);
	v_RET('EXTERNAL_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_REC.EXTERNAL_IDENTIFIER);
	v_RET('COMPONENT_CATEGORY') := UT.GET_LITERAL_FOR_STRING(p_REC.COMPONENT_CATEGORY);
	v_RET('GL_DEBIT_ACCOUNT') := UT.GET_LITERAL_FOR_STRING(p_REC.GL_DEBIT_ACCOUNT);
	v_RET('GL_CREDIT_ACCOUNT') := UT.GET_LITERAL_FOR_STRING(p_REC.GL_CREDIT_ACCOUNT);
	v_RET('FIRM_NON_FIRM') := UT.GET_LITERAL_FOR_STRING(p_REC.FIRM_NON_FIRM);
	v_RET('EXCLUDE_FROM_INVOICE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.EXCLUDE_FROM_INVOICE);
	v_RET('EXCLUDE_FROM_INVOICE_TOTAL') := UT.GET_LITERAL_FOR_NUMBER(p_REC.EXCLUDE_FROM_INVOICE_TOTAL);
	v_RET('IMBALANCE_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.IMBALANCE_TYPE);
	v_RET('ACCUMULATION_PERIOD') := UT.GET_LITERAL_FOR_NUMBER(p_REC.ACCUMULATION_PERIOD);
	v_RET('BASE_COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.BASE_COMPONENT_ID);
	v_RET('BASE_LIMIT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.BASE_LIMIT_ID);
	v_RET('MARKET_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.MARKET_TYPE);
	v_RET('MARKET_PRICE_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.MARKET_PRICE_TYPE);
	v_RET('WHICH_INTERVAL') := UT.GET_LITERAL_FOR_STRING(p_REC.WHICH_INTERVAL);
	v_RET('LMP_PRICE_CALC') := UT.GET_LITERAL_FOR_STRING(p_REC.LMP_PRICE_CALC);
	v_RET('LMP_INCLUDE_EXT') := UT.GET_LITERAL_FOR_NUMBER(p_REC.LMP_INCLUDE_EXT);
	v_RET('LMP_INCLUDE_SALES') := UT.GET_LITERAL_FOR_STRING(p_REC.LMP_INCLUDE_SALES);
	v_RET('CHARGE_WHEN') := UT.GET_LITERAL_FOR_STRING(p_REC.CHARGE_WHEN);
	v_RET('BILATERALS_SIGN') := UT.GET_LITERAL_FOR_NUMBER(p_REC.BILATERALS_SIGN);
	v_RET('LMP_COMMODITY_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.LMP_COMMODITY_ID);
	v_RET('LMP_BASE_COMMODITY_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.LMP_BASE_COMMODITY_ID);
	v_RET('USE_ZONAL_PRICE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.USE_ZONAL_PRICE);
	v_RET('ALTERNATE_PRICE') := UT.GET_LITERAL_FOR_STRING(p_REC.ALTERNATE_PRICE);
	v_RET('ALTERNATE_PRICE_FUNCTION') := UT.GET_LITERAL_FOR_STRING(p_REC.ALTERNATE_PRICE_FUNCTION);
	v_RET('EXCLUDE_FROM_BILLING_EXPORT') := UT.GET_LITERAL_FOR_NUMBER(p_REC.EXCLUDE_FROM_BILLING_EXPORT);
	v_RET('IS_DEFAULT_TEMPLATE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_DEFAULT_TEMPLATE);
	v_RET('KWH_MULTIPLIER') := UT.GET_LITERAL_FOR_NUMBER(p_REC.KWH_MULTIPLIER);
	v_RET('ANCILLARY_SERVICE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.ANCILLARY_SERVICE_ID);
	v_RET('APPLY_RATE_FOR') := UT.GET_LITERAL_FOR_STRING(p_REC.APPLY_RATE_FOR);
	v_RET('LOSS_ADJ_TYPE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.LOSS_ADJ_TYPE);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_COMPONENT_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION COMPONENT_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN COMPONENT%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_COMPONENT_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_COMPONENT);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_COMPONENT, v_REALMS);
END COMPONENT_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_CONDITIONAL_FORMAT_FIELDS_
	(
	p_REC IN CONDITIONAL_FORMAT%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('CONDITIONAL_FORMAT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.CONDITIONAL_FORMAT_ID);
	v_RET('CONDITIONAL_FORMAT_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.CONDITIONAL_FORMAT_NAME);
	v_RET('CONDITIONAL_FORMAT_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.CONDITIONAL_FORMAT_ALIAS);
	v_RET('CONDITIONAL_FORMAT_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.CONDITIONAL_FORMAT_DESC);
	v_RET('CONDITIONAL_FORMAT_MODULE') := UT.GET_LITERAL_FOR_STRING(p_REC.CONDITIONAL_FORMAT_MODULE);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_CONDITIONAL_FORMAT_FIELDS_;
---------------------------------------------------------------------
FUNCTION CONDITIONAL_FORMAT_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN CONDITIONAL_FORMAT%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_CONDITIONAL_FORMAT_FIELDS_(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_CONDITIONAL_FORMAT);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_CONDITIONAL_FORMAT, v_REALMS);
END CONDITIONAL_FORMAT_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_CONTACT_FIELDS_MAP
	(
	p_REC IN CONTACT%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('CONTACT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.CONTACT_ID);
	v_RET('CONTACT_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.CONTACT_NAME);
	v_RET('CONTACT_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.CONTACT_ALIAS);
	v_RET('CONTACT_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.CONTACT_DESC);
	v_RET('CONTACT_STATUS') := UT.GET_LITERAL_FOR_STRING(p_REC.CONTACT_STATUS);
	v_RET('EMAIL_ADDRESS') := UT.GET_LITERAL_FOR_STRING(p_REC.EMAIL_ADDRESS);
	v_RET('FIRST_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.FIRST_NAME);
	v_RET('MIDDLE_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.MIDDLE_NAME);
	v_RET('LAST_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.LAST_NAME);
	v_RET('SALUTATION') := UT.GET_LITERAL_FOR_STRING(p_REC.SALUTATION);
	v_RET('TITLE') := UT.GET_LITERAL_FOR_STRING(p_REC.TITLE);
	v_RET('EXTERNAL_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_REC.EXTERNAL_IDENTIFIER);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_CONTACT_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION CONTACT_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN CONTACT%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_CONTACT_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_CONTACT);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_CONTACT, v_REALMS);
END CONTACT_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_CONTRACT_FIELDS_MAP
	(
	p_REC IN SERVICE_CONTRACT%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('CONTRACT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.CONTRACT_ID);
	v_RET('CONTRACT_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.CONTRACT_NAME);
	v_RET('CONTRACT_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.CONTRACT_ALIAS);
	v_RET('CONTRACT_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.CONTRACT_DESC);
	v_RET('EXTERNAL_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_REC.EXTERNAL_IDENTIFIER);
	v_RET('BEGIN_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.BEGIN_DATE);
	v_RET('END_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.END_DATE);
	v_RET('IS_ESTIMATED_END_DATE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_ESTIMATED_END_DATE);
	v_RET('IS_EVERGREEN') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_EVERGREEN);
	v_RET('IS_INTERRUPTIBLE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_INTERRUPTIBLE);
	v_RET('EXPECTED_RENEWAL_PCT') := UT.GET_LITERAL_FOR_NUMBER(p_REC.EXPECTED_RENEWAL_PCT);
	v_RET('NEXT_ACTION_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.NEXT_ACTION_DATE);
	v_RET('NOTIFICATION_REQUIREMENTS') := UT.GET_LITERAL_FOR_STRING(p_REC.NOTIFICATION_REQUIREMENTS);
	v_RET('CURTAILMENT_ABILITY') := UT.GET_LITERAL_FOR_STRING(p_REC.CURTAILMENT_ABILITY);
	v_RET('PENALTY_CLAUSES') := UT.GET_LITERAL_FOR_STRING(p_REC.PENALTY_CLAUSES);
	v_RET('PRICING_MODEL') := UT.GET_LITERAL_FOR_STRING(p_REC.PRICING_MODEL);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_CONTRACT_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION CONTRACT_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SERVICE_CONTRACT%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_CONTRACT_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_CONTRACT);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_CONTRACT, v_REALMS);
END CONTRACT_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_CONTRACT_LIMIT_FIELDS_MAP
	(
	p_REC IN CONTRACT_LIMIT%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('LIMIT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.LIMIT_ID);
	v_RET('LIMIT_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.LIMIT_NAME);
	v_RET('LIMIT_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.LIMIT_ALIAS);
	v_RET('LIMIT_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.LIMIT_DESC);
	v_RET('LIMIT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.LIMIT_TYPE);
	v_RET('LIMIT_MEASURE') := UT.GET_LITERAL_FOR_STRING(p_REC.LIMIT_MEASURE);
	v_RET('LIMIT_INTERVAL') := UT.GET_LITERAL_FOR_STRING(p_REC.LIMIT_INTERVAL);
	v_RET('LIMIT_IS_SEASONABLE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.LIMIT_IS_SEASONABLE);
	v_RET('TEMPLATE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.TEMPLATE_ID);
	v_RET('PERIOD_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PERIOD_ID);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_CONTRACT_LIMIT_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION CONTRACT_LIMIT_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN CONTRACT_LIMIT%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_CONTRACT_LIMIT_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_CONTRACT_LIMIT);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_CONTRACT_LIMIT, v_REALMS);
END CONTRACT_LIMIT_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_CUSTOMER_FIELDS_MAP
	(
	p_REC IN CUSTOMER%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('CUSTOMER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.CUSTOMER_ID);
	v_RET('CUSTOMER_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.CUSTOMER_NAME);
	v_RET('CUSTOMER_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.CUSTOMER_ALIAS);
	v_RET('CUSTOMER_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.CUSTOMER_DESC);
	v_RET('CUSTOMER_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_REC.CUSTOMER_IDENTIFIER);
	v_RET('CUSTOMER_STATUS') := UT.GET_LITERAL_FOR_STRING(p_REC.CUSTOMER_STATUS);
	v_RET('CUSTOMER_IS_ACTIVE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.CUSTOMER_IS_ACTIVE);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_CUSTOMER_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION CUSTOMER_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN CUSTOMER%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_CUSTOMER_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_CUSTOMER);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_CUSTOMER, v_REALMS);
END CUSTOMER_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_DATA_LOCK_GROUP_FIELDS_MAP
	(
	p_REC IN DATA_LOCK_GROUP%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('DATA_LOCK_GROUP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.DATA_LOCK_GROUP_ID);
	v_RET('DATA_LOCK_GROUP_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.DATA_LOCK_GROUP_NAME);
	v_RET('DATA_LOCK_GROUP_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.DATA_LOCK_GROUP_ALIAS);
	v_RET('DATA_LOCK_GROUP_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.DATA_LOCK_GROUP_DESC);
	v_RET('DATA_LOCK_GROUP_INTERVAL') := UT.GET_LITERAL_FOR_STRING(p_REC.DATA_LOCK_GROUP_INTERVAL);
	v_RET('IS_AUTOMATIC') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_AUTOMATIC);
	v_RET('AUTOLOCK_DATE_FORMULA') := UT.GET_LITERAL_FOR_STRING(p_REC.AUTOLOCK_DATE_FORMULA);
	v_RET('LOCK_LIMIT_DATE_FORMULA') := UT.GET_LITERAL_FOR_STRING(p_REC.LOCK_LIMIT_DATE_FORMULA);
	v_RET('LOCK_STATE') := UT.GET_LITERAL_FOR_STRING(p_REC.LOCK_STATE);
	v_RET('LAST_PROCESSED_INTERVAL') := UT.GET_LITERAL_FOR_DATE(p_REC.LAST_PROCESSED_INTERVAL);
	v_RET('TIME_ZONE') := UT.GET_LITERAL_FOR_STRING(p_REC.TIME_ZONE);
	v_RET('WEEK_BEGIN') := UT.GET_LITERAL_FOR_STRING(p_REC.WEEK_BEGIN);
    
	RETURN v_RET;
END GET_DATA_LOCK_GROUP_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION DATA_LOCK_GROUP_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN DATA_LOCK_GROUP%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_DATA_LOCK_GROUP_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_DATA_LOCK_GROUP);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_DATA_LOCK_GROUP, v_REALMS);
END DATA_LOCK_GROUP_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_DER_FIELDS_MAP
	(
	p_REC IN DISTRIBUTED_ENERGY_RESOURCE%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('DER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.DER_ID);
	v_RET('DER_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.DER_NAME);
	v_RET('DER_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.DER_ALIAS);
	v_RET('DER_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.DER_DESC);
	v_RET('SERVICE_LOCATION_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SERVICE_LOCATION_ID);
	v_RET('DER_TYPE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.DER_TYPE_ID);
	v_RET('EXTERNAL_SYSTEM_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.EXTERNAL_SYSTEM_ID);
	v_RET('EXTERNAL_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_REC.EXTERNAL_IDENTIFIER);
	v_RET('BEGIN_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.BEGIN_DATE);
	v_RET('END_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.END_DATE);
	v_RET('SERIAL_NUMBER') := UT.GET_LITERAL_FOR_STRING(p_REC.SERIAL_NUMBER);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_DER_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION DER_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN DISTRIBUTED_ENERGY_RESOURCE%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_DER_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_DER);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_DER, v_REALMS);
END DER_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_DER_TYPE_FIELDS_MAP
	(
	p_REC IN DER_TYPE%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('DER_TYPE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.DER_TYPE_ID);
	v_RET('DER_TYPE_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.DER_TYPE_NAME);
	v_RET('DER_TYPE_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.DER_TYPE_ALIAS);
	v_RET('DER_TYPE_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.DER_TYPE_DESC);
	v_RET('DER_TYPE_FUNCTION') := UT.GET_LITERAL_FOR_STRING(p_REC.DER_TYPE_FUNCTION);
	v_RET('DER_TYPE_CATEGORY') := UT.GET_LITERAL_FOR_STRING(p_REC.DER_TYPE_CATEGORY);
	v_RET('DEFAULT_FAILURE_PCT') := UT.GET_LITERAL_FOR_NUMBER(p_REC.DEFAULT_FAILURE_PCT);
	v_RET('USE_DEFAULT_FAIL_PCT') := UT.GET_LITERAL_FOR_NUMBER(p_REC.USE_DEFAULT_FAIL_PCT);
	v_RET('EXTERNAL_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_REC.EXTERNAL_IDENTIFIER);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_DER_TYPE_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION DER_TYPE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN DER_TYPE%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_DER_TYPE_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_DER_TYPE);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_DER_TYPE, v_REALMS);
END DER_TYPE_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_DR_EVENT_FIELDS_MAP
	(
	p_REC IN DR_EVENT%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('EVENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.EVENT_ID);
	v_RET('EVENT_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.EVENT_NAME);
	v_RET('EVENT_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.EVENT_ALIAS);
	v_RET('EVENT_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.EVENT_DESC);
	v_RET('VPP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.VPP_ID);
	v_RET('EVENT_STATUS') := UT.GET_LITERAL_FOR_STRING(p_REC.EVENT_STATUS);
	v_RET('START_TIME') := UT.GET_LITERAL_FOR_DATE(p_REC.START_TIME);
	v_RET('STOP_TIME') := UT.GET_LITERAL_FOR_DATE(p_REC.STOP_TIME);
	v_RET('EVENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.EVENT_TYPE);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_DR_EVENT_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION DR_EVENT_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN DR_EVENT%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_DR_EVENT_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_DR_EVENT);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_DR_EVENT, v_REALMS);
END DR_EVENT_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_EDC_FIELDS_MAP
	(
	p_REC IN ENERGY_DISTRIBUTION_COMPANY%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('EDC_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.EDC_ID);
	v_RET('EDC_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.EDC_NAME);
	v_RET('EDC_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.EDC_ALIAS);
	v_RET('EDC_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.EDC_DESC);
	v_RET('EDC_STATUS') := UT.GET_LITERAL_FOR_STRING(p_REC.EDC_STATUS);
	v_RET('EDC_DUNS_NUMBER') := UT.GET_LITERAL_FOR_STRING(p_REC.EDC_DUNS_NUMBER);
	v_RET('EDC_EXTERNAL_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_REC.EDC_EXTERNAL_IDENTIFIER);
	v_RET('EDC_SETTLEMENT_AGENT_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.EDC_SETTLEMENT_AGENT_NAME);
	v_RET('EDC_LOSS_FACTOR_OPTION') := UT.GET_LITERAL_FOR_STRING(p_REC.EDC_LOSS_FACTOR_OPTION);
	v_RET('EDC_SYSTEM_LOAD_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.EDC_SYSTEM_LOAD_ID);
	v_RET('EDC_MARKET_PRICE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.EDC_MARKET_PRICE_ID);
	v_RET('EDC_HOLIDAY_SET_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.EDC_HOLIDAY_SET_ID);
	v_RET('EDC_SC_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.EDC_SC_ID);
	v_RET('EDC_EXCLUDE_LOAD_SCHEDULE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.EDC_EXCLUDE_LOAD_SCHEDULE);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_EDC_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION EDC_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN ENERGY_DISTRIBUTION_COMPANY%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_EDC_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_EDC);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_EDC, v_REALMS);
END EDC_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_ENTITY_DOMAIN_FIELDS_MAP
	(
	p_REC IN ENTITY_DOMAIN%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('ENTITY_DOMAIN_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.ENTITY_DOMAIN_ID);
	v_RET('ENTITY_DOMAIN_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.ENTITY_DOMAIN_NAME);
	v_RET('ENTITY_DOMAIN_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.ENTITY_DOMAIN_ALIAS);
	v_RET('ENTITY_DOMAIN_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.ENTITY_DOMAIN_DESC);
	v_RET('ENTITY_DOMAIN_TABLE') := UT.GET_LITERAL_FOR_STRING(p_REC.ENTITY_DOMAIN_TABLE);
	v_RET('ENTITY_DOMAIN_TABLE_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.ENTITY_DOMAIN_TABLE_ALIAS);
	v_RET('ENTITY_DOMAIN_CATEGORY') := UT.GET_LITERAL_FOR_STRING(p_REC.ENTITY_DOMAIN_CATEGORY);
	v_RET('DISPLAY_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.DISPLAY_NAME);
	v_RET('INCLUDE_CONTACT_ADDRESS') := UT.GET_LITERAL_FOR_NUMBER(p_REC.INCLUDE_CONTACT_ADDRESS);
	v_RET('INCLUDE_ENTITY_ATTRIBUTE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.INCLUDE_ENTITY_ATTRIBUTE);
	v_RET('INCLUDE_EXTERNAL_IDENTIFIER') := UT.GET_LITERAL_FOR_NUMBER(p_REC.INCLUDE_EXTERNAL_IDENTIFIER);
	v_RET('INCLUDE_GROUPS') := UT.GET_LITERAL_FOR_NUMBER(p_REC.INCLUDE_GROUPS);
	v_RET('INCLUDE_NOTES') := UT.GET_LITERAL_FOR_NUMBER(p_REC.INCLUDE_NOTES);
	v_RET('IS_PSEUDO') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_PSEUDO);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_ENTITY_DOMAIN_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION ENTITY_DOMAIN_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN ENTITY_DOMAIN%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_ENTITY_DOMAIN_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_ENTITY_DOMAIN);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_ENTITY_DOMAIN, v_REALMS);
END ENTITY_DOMAIN_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_ENTITY_GROUP_FIELDS_MAP
	(
	p_REC IN ENTITY_GROUP%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('ENTITY_GROUP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.ENTITY_GROUP_ID);
	v_RET('ENTITY_GROUP_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.ENTITY_GROUP_NAME);
	v_RET('ENTITY_GROUP_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.ENTITY_GROUP_ALIAS);
	v_RET('ENTITY_GROUP_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.ENTITY_GROUP_DESC);
	v_RET('ENTITY_DOMAIN_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.ENTITY_DOMAIN_ID);
	v_RET('PARENT_GROUP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PARENT_GROUP_ID);
	v_RET('IS_MATRIX') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_MATRIX);
	v_RET('GROUP_CATEGORY') := UT.GET_LITERAL_FOR_STRING(p_REC.GROUP_CATEGORY);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_ENTITY_GROUP_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION ENTITY_GROUP_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN ENTITY_GROUP%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_ENTITY_GROUP_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_ENTITY_GROUP);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_ENTITY_GROUP, v_REALMS);
END ENTITY_GROUP_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_ESP_FIELDS_MAP
	(
	p_REC IN ENERGY_SERVICE_PROVIDER%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('ESP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.ESP_ID);
	v_RET('ESP_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.ESP_NAME);
	v_RET('ESP_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.ESP_ALIAS);
	v_RET('ESP_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.ESP_DESC);
	v_RET('ESP_EXTERNAL_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_REC.ESP_EXTERNAL_IDENTIFIER);
	v_RET('ESP_DUNS_NUMBER') := UT.GET_LITERAL_FOR_STRING(p_REC.ESP_DUNS_NUMBER);
	v_RET('ESP_STATUS') := UT.GET_LITERAL_FOR_STRING(p_REC.ESP_STATUS);
	v_RET('ESP_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.ESP_TYPE);
	v_RET('ESP_EXCLUDE_LOAD_SCHEDULE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.ESP_EXCLUDE_LOAD_SCHEDULE);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_ESP_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION ESP_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN ENERGY_SERVICE_PROVIDER%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_ESP_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_ESP);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_ESP, v_REALMS);
END ESP_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_ETAG_FIELDS_MAP
	(
	p_REC IN ETAG%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('ETAG_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.ETAG_ID);
	v_RET('ETAG_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.ETAG_NAME);
	v_RET('ETAG_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.ETAG_ALIAS);
	v_RET('ETAG_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.ETAG_DESC);
	v_RET('TAG_IDENT') := UT.GET_LITERAL_FOR_STRING(p_REC.TAG_IDENT);
	v_RET('GCA_CODE') := UT.GET_LITERAL_FOR_STRING(p_REC.GCA_CODE);
	v_RET('PSE_CODE') := UT.GET_LITERAL_FOR_STRING(p_REC.PSE_CODE);
	v_RET('TAG_CODE') := UT.GET_LITERAL_FOR_STRING(p_REC.TAG_CODE);
	v_RET('LCA_CODE') := UT.GET_LITERAL_FOR_STRING(p_REC.LCA_CODE);
	v_RET('EXTERNAL_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_REC.EXTERNAL_IDENTIFIER);
	v_RET('ETAG_STATUS') := UT.GET_LITERAL_FOR_STRING(p_REC.ETAG_STATUS);
	v_RET('SECURITY_KEY') := UT.GET_LITERAL_FOR_STRING(p_REC.SECURITY_KEY);
	v_RET('WSCC_PRESCHEDULE_FLAG') := UT.GET_LITERAL_FOR_STRING(p_REC.WSCC_PRESCHEDULE_FLAG);
	v_RET('TEST_FLAG') := UT.GET_LITERAL_FOR_STRING(p_REC.TEST_FLAG);
	v_RET('TRANSACTION_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.TRANSACTION_TYPE);
	v_RET('NOTES') := UT.GET_LITERAL_FOR_STRING(p_REC.NOTES);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_ETAG_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION ETAG_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN ETAG%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_ETAG_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_ETAG);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_ETAG, v_REALMS);
END ETAG_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_EXTERNAL_SYSTEM_FIELDS_MAP
	(
	p_REC IN EXTERNAL_SYSTEM%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('EXTERNAL_SYSTEM_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.EXTERNAL_SYSTEM_ID);
	v_RET('EXTERNAL_SYSTEM_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.EXTERNAL_SYSTEM_NAME);
	v_RET('EXTERNAL_SYSTEM_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.EXTERNAL_SYSTEM_ALIAS);
	v_RET('EXTERNAL_SYSTEM_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.EXTERNAL_SYSTEM_DESC);
	v_RET('EXTERNAL_SYSTEM_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.EXTERNAL_SYSTEM_TYPE);
	v_RET('EXTERNAL_SYSTEM_DISPLAY_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.EXTERNAL_SYSTEM_DISPLAY_NAME);
	v_RET('IS_ENABLED') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_ENABLED);
	v_RET('EXTERNAL_ACCOUNT_DOMAIN_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.EXTERNAL_ACCOUNT_DOMAIN_ID);
	v_RET('HAS_UNAME_PWD_CREDENTIALS') := UT.GET_LITERAL_FOR_NUMBER(p_REC.HAS_UNAME_PWD_CREDENTIALS);
	v_RET('NUMBER_OF_CERTIFICATES') := UT.GET_LITERAL_FOR_NUMBER(p_REC.NUMBER_OF_CERTIFICATES);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_EXTERNAL_SYSTEM_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION EXTERNAL_SYSTEM_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN EXTERNAL_SYSTEM%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_EXTERNAL_SYSTEM_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_EXTERNAL_SYSTEM);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_EXTERNAL_SYSTEM, v_REALMS);
END EXTERNAL_SYSTEM_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_EXTERNAL_TRANSACTION_FIELD
	(
	p_REC IN INTERCHANGE_TRANSACTION_EXT%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('TRANSACTION_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.TRANSACTION_ID);
	v_RET('TRANSACTION_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.TRANSACTION_NAME);
	v_RET('TRANSACTION_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.TRANSACTION_ALIAS);
	v_RET('TRANSACTION_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.TRANSACTION_DESC);
	v_RET('TRANSACTION_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.TRANSACTION_TYPE);
	v_RET('TRANSACTION_CODE') := UT.GET_LITERAL_FOR_STRING(p_REC.TRANSACTION_CODE);
	v_RET('TRANSACTION_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_REC.TRANSACTION_IDENTIFIER);
	v_RET('IS_FIRM') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_FIRM);
	v_RET('IS_IMPORT_SCHEDULE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_IMPORT_SCHEDULE);
	v_RET('IS_EXPORT_SCHEDULE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_EXPORT_SCHEDULE);
	v_RET('IS_BALANCE_TRANSACTION') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_BALANCE_TRANSACTION);
	v_RET('IS_BID_OFFER') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_BID_OFFER);
	v_RET('IS_EXCLUDE_FROM_POSITION') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_EXCLUDE_FROM_POSITION);
	v_RET('IS_IMPORT_EXPORT') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_IMPORT_EXPORT);
	v_RET('IS_DISPATCHABLE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_DISPATCHABLE);
	v_RET('TRANSACTION_INTERVAL') := UT.GET_LITERAL_FOR_STRING(p_REC.TRANSACTION_INTERVAL);
	v_RET('EXTERNAL_INTERVAL') := UT.GET_LITERAL_FOR_STRING(p_REC.EXTERNAL_INTERVAL);
	v_RET('ETAG_CODE') := UT.GET_LITERAL_FOR_STRING(p_REC.ETAG_CODE);
	v_RET('BEGIN_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.BEGIN_DATE);
	v_RET('END_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.END_DATE);
	v_RET('PURCHASER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PURCHASER_ID);
	v_RET('SELLER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SELLER_ID);
	v_RET('CONTRACT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.CONTRACT_ID);
	v_RET('SC_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SC_ID);
	v_RET('POR_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.POR_ID);
	v_RET('POD_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.POD_ID);
	v_RET('COMMODITY_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.COMMODITY_ID);
	v_RET('SERVICE_TYPE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SERVICE_TYPE_ID);
	v_RET('TX_TRANSACTION_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.TX_TRANSACTION_ID);
	v_RET('PATH_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PATH_ID);
	v_RET('LINK_TRANSACTION_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.LINK_TRANSACTION_ID);
	v_RET('EDC_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.EDC_ID);
	v_RET('PSE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PSE_ID);
	v_RET('ESP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.ESP_ID);
	v_RET('POOL_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.POOL_ID);
	v_RET('SCHEDULE_GROUP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SCHEDULE_GROUP_ID);
	v_RET('MARKET_PRICE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.MARKET_PRICE_ID);
	v_RET('ZOR_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.ZOR_ID);
	v_RET('ZOD_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.ZOD_ID);
	v_RET('SOURCE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SOURCE_ID);
	v_RET('SINK_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SINK_ID);
	v_RET('RESOURCE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.RESOURCE_ID);
	v_RET('AGREEMENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.AGREEMENT_TYPE);
	v_RET('APPROVAL_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.APPROVAL_TYPE);
	v_RET('LOSS_OPTION') := UT.GET_LITERAL_FOR_STRING(p_REC.LOSS_OPTION);
	v_RET('TRAIT_CATEGORY') := UT.GET_LITERAL_FOR_STRING(p_REC.TRAIT_CATEGORY);
	v_RET('TP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.TP_ID);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_EXTERNAL_TRANSACTION_FIELD;
---------------------------------------------------------------------
FUNCTION EXTERNAL_TRANSACTION_IS_ALLOWE
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN INTERCHANGE_TRANSACTION_EXT%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_EXTERNAL_TRANSACTION_FIELD(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_EXTERNAL_TRANSACTION);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_EXTERNAL_TRANSACTION, v_REALMS);
END EXTERNAL_TRANSACTION_IS_ALLOWE;
---------------------------------------------------------------------
FUNCTION GET_GEOGRAPHY_FIELDS_MAP
	(
	p_REC IN GEOGRAPHY%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('GEOGRAPHY_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.GEOGRAPHY_ID);
	v_RET('GEOGRAPHY_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.GEOGRAPHY_NAME);
	v_RET('GEOGRAPHY_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.GEOGRAPHY_ALIAS);
	v_RET('GEOGRAPHY_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.GEOGRAPHY_DESC);
	v_RET('GEOGRAPHY_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.GEOGRAPHY_TYPE);
	v_RET('PARENT_GEOGRAPHY_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PARENT_GEOGRAPHY_ID);
	v_RET('DISPLAY_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.DISPLAY_NAME);
	v_RET('ABBREVIATION') := UT.GET_LITERAL_FOR_STRING(p_REC.ABBREVIATION);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_GEOGRAPHY_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION GEOGRAPHY_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN GEOGRAPHY%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_GEOGRAPHY_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_GEOGRAPHY);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_GEOGRAPHY, v_REALMS);
END GEOGRAPHY_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_GROWTH_PATTERN_FIELDS_MAP
	(
	p_REC IN GROWTH_PATTERN%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('PATTERN_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PATTERN_ID);
	v_RET('PATTERN_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.PATTERN_NAME);
	v_RET('PATTERN_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.PATTERN_ALIAS);
	v_RET('PATTERN_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.PATTERN_DESC);
	v_RET('JAN_PCT') := UT.GET_LITERAL_FOR_NUMBER(p_REC.JAN_PCT);
	v_RET('FEB_PCT') := UT.GET_LITERAL_FOR_NUMBER(p_REC.FEB_PCT);
	v_RET('MAR_PCT') := UT.GET_LITERAL_FOR_NUMBER(p_REC.MAR_PCT);
	v_RET('APR_PCT') := UT.GET_LITERAL_FOR_NUMBER(p_REC.APR_PCT);
	v_RET('MAY_PCT') := UT.GET_LITERAL_FOR_NUMBER(p_REC.MAY_PCT);
	v_RET('JUN_PCT') := UT.GET_LITERAL_FOR_NUMBER(p_REC.JUN_PCT);
	v_RET('JUL_PCT') := UT.GET_LITERAL_FOR_NUMBER(p_REC.JUL_PCT);
	v_RET('AUG_PCT') := UT.GET_LITERAL_FOR_NUMBER(p_REC.AUG_PCT);
	v_RET('SEP_PCT') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SEP_PCT);
	v_RET('OCT_PCT') := UT.GET_LITERAL_FOR_NUMBER(p_REC.OCT_PCT);
	v_RET('NOV_PCT') := UT.GET_LITERAL_FOR_NUMBER(p_REC.NOV_PCT);
	v_RET('DEC_PCT') := UT.GET_LITERAL_FOR_NUMBER(p_REC.DEC_PCT);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_GROWTH_PATTERN_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION GROWTH_PATTERN_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN GROWTH_PATTERN%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_GROWTH_PATTERN_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_GROWTH_PATTERN);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_GROWTH_PATTERN, v_REALMS);
END GROWTH_PATTERN_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_HEAT_RATE_CURVE_FIELDS_MAP
	(
	p_REC IN HEAT_RATE_CURVE%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('HEAT_RATE_CURVE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.HEAT_RATE_CURVE_ID);
	v_RET('HEAT_RATE_CURVE_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.HEAT_RATE_CURVE_NAME);
	v_RET('HEAT_RATE_CURVE_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.HEAT_RATE_CURVE_ALIAS);
	v_RET('HEAT_RATE_CURVE_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.HEAT_RATE_CURVE_DESC);
	v_RET('STATION_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.STATION_ID);
	v_RET('PARAMETER_1_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PARAMETER_1_ID);
	v_RET('PARAMETER_1_ROUND_TO_NEAREST') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PARAMETER_1_ROUND_TO_NEAREST);
	v_RET('PARAMETER_1_ROUNDING_STYLE') := UT.GET_LITERAL_FOR_STRING(p_REC.PARAMETER_1_ROUNDING_STYLE);
	v_RET('PARAMETER_2_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PARAMETER_2_ID);
	v_RET('PARAMETER_2_ROUND_TO_NEAREST') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PARAMETER_2_ROUND_TO_NEAREST);
	v_RET('PARAMETER_2_ROUNDING_STYLE') := UT.GET_LITERAL_FOR_STRING(p_REC.PARAMETER_2_ROUNDING_STYLE);
	v_RET('PARAMETER_3_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PARAMETER_3_ID);
	v_RET('PARAMETER_3_ROUND_TO_NEAREST') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PARAMETER_3_ROUND_TO_NEAREST);
	v_RET('PARAMETER_3_ROUNDING_STYLE') := UT.GET_LITERAL_FOR_STRING(p_REC.PARAMETER_3_ROUNDING_STYLE);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_HEAT_RATE_CURVE_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION HEAT_RATE_CURVE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN HEAT_RATE_CURVE%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_HEAT_RATE_CURVE_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_HEAT_RATE_CURVE);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_HEAT_RATE_CURVE, v_REALMS);
END HEAT_RATE_CURVE_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_HOLIDAY_FIELDS_MAP
	(
	p_REC IN HOLIDAY%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('HOLIDAY_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.HOLIDAY_ID);
	v_RET('HOLIDAY_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.HOLIDAY_NAME);
	v_RET('HOLIDAY_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.HOLIDAY_ALIAS);
	v_RET('HOLIDAY_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.HOLIDAY_DESC);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_HOLIDAY_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION HOLIDAY_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN HOLIDAY%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_HOLIDAY_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_HOLIDAY);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_HOLIDAY, v_REALMS);
END HOLIDAY_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_HOLIDAY_SET_FIELDS_MAP
	(
	p_REC IN HOLIDAY_SET%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('HOLIDAY_SET_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.HOLIDAY_SET_ID);
	v_RET('HOLIDAY_SET_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.HOLIDAY_SET_NAME);
	v_RET('HOLIDAY_SET_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.HOLIDAY_SET_ALIAS);
	v_RET('HOLIDAY_SET_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.HOLIDAY_SET_DESC);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_HOLIDAY_SET_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION HOLIDAY_SET_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN HOLIDAY_SET%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_HOLIDAY_SET_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_HOLIDAY_SET);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_HOLIDAY_SET, v_REALMS);
END HOLIDAY_SET_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_INTERCHANGE_CONTRACT_FIELD
	(
	p_REC IN INTERCHANGE_CONTRACT%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('CONTRACT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.CONTRACT_ID);
	v_RET('CONTRACT_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.CONTRACT_NAME);
	v_RET('CONTRACT_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.CONTRACT_ALIAS);
	v_RET('CONTRACT_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.CONTRACT_DESC);
	v_RET('CONTRACT_STATUS') := UT.GET_LITERAL_FOR_STRING(p_REC.CONTRACT_STATUS);
	v_RET('BEGIN_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.BEGIN_DATE);
	v_RET('END_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.END_DATE);
	v_RET('IS_EVERGREEN') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_EVERGREEN);
	v_RET('CONTRACT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.CONTRACT_TYPE);
	v_RET('BILLING_ENTITY_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.BILLING_ENTITY_ID);
	v_RET('PURCHASER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PURCHASER_ID);
	v_RET('SELLER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SELLER_ID);
	v_RET('SOURCE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SOURCE_ID);
	v_RET('SINK_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SINK_ID);
	v_RET('POR_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.POR_ID);
	v_RET('POD_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.POD_ID);
	v_RET('SC_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SC_ID);
	v_RET('AGREEMENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.AGREEMENT_TYPE);
	v_RET('APPROVAL_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.APPROVAL_TYPE);
	v_RET('MARKET_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.MARKET_TYPE);
	v_RET('LOSS_OPTION') := UT.GET_LITERAL_FOR_STRING(p_REC.LOSS_OPTION);
	v_RET('CONTRACT_FILE_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.CONTRACT_FILE_NAME);
	v_RET('PIPELINE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PIPELINE_ID);
	v_RET('PIPELINE_TARIFF_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.PIPELINE_TARIFF_TYPE);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_INTERCHANGE_CONTRACT_FIELD;
---------------------------------------------------------------------
FUNCTION INTERCHANGE_CONTRACT_IS_ALLOWE
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN INTERCHANGE_CONTRACT%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_INTERCHANGE_CONTRACT_FIELD(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_INTERCHANGE_CONTRACT);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_INTERCHANGE_CONTRACT, v_REALMS);
END INTERCHANGE_CONTRACT_IS_ALLOWE;
---------------------------------------------------------------------
FUNCTION GET_INVOICE_GROUP_FIELDS_MAP
	(
	p_REC IN INVOICE_GROUP%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('INVOICE_GROUP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.INVOICE_GROUP_ID);
	v_RET('INVOICE_GROUP_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.INVOICE_GROUP_NAME);
	v_RET('INVOICE_GROUP_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.INVOICE_GROUP_ALIAS);
	v_RET('INVOICE_GROUP_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.INVOICE_GROUP_DESC);
	v_RET('DISPLAY_ORDER') := UT.GET_LITERAL_FOR_NUMBER(p_REC.DISPLAY_ORDER);
	v_RET('SHOW_TITLE_ON_INVOICE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SHOW_TITLE_ON_INVOICE);
	v_RET('SHOW_SUBTOTAL_ON_INVOICE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SHOW_SUBTOTAL_ON_INVOICE);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_INVOICE_GROUP_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION INVOICE_GROUP_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN INVOICE_GROUP%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_INVOICE_GROUP_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_INVOICE_GROUP);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_INVOICE_GROUP, v_REALMS);
END INVOICE_GROUP_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_IT_COMMODITY_FIELDS_MAP
	(
	p_REC IN IT_COMMODITY%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('COMMODITY_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.COMMODITY_ID);
	v_RET('COMMODITY_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.COMMODITY_NAME);
	v_RET('COMMODITY_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.COMMODITY_ALIAS);
	v_RET('COMMODITY_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.COMMODITY_DESC);
	v_RET('COMMODITY_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.COMMODITY_TYPE);
	v_RET('COMMODITY_UNIT') := UT.GET_LITERAL_FOR_STRING(p_REC.COMMODITY_UNIT);
	v_RET('COMMODITY_UNIT_FORMAT') := UT.GET_LITERAL_FOR_STRING(p_REC.COMMODITY_UNIT_FORMAT);
	v_RET('COMMODITY_PRICE_UNIT') := UT.GET_LITERAL_FOR_STRING(p_REC.COMMODITY_PRICE_UNIT);
	v_RET('COMMODITY_PRICE_FORMAT') := UT.GET_LITERAL_FOR_STRING(p_REC.COMMODITY_PRICE_FORMAT);
	v_RET('IS_VIRTUAL') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_VIRTUAL);
	v_RET('MARKET_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.MARKET_TYPE);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_IT_COMMODITY_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION IT_COMMODITY_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN IT_COMMODITY%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_IT_COMMODITY_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_IT_COMMODITY);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_IT_COMMODITY, v_REALMS);
END IT_COMMODITY_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_JOB_THREAD_FIELDS_MAP
	(
	p_REC IN JOB_THREAD%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('JOB_THREAD_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.JOB_THREAD_ID);
	v_RET('JOB_THREAD_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.JOB_THREAD_NAME);
	v_RET('JOB_THREAD_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.JOB_THREAD_ALIAS);
	v_RET('JOB_THREAD_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.JOB_THREAD_DESC);
	v_RET('JOB_CLASS') := UT.GET_LITERAL_FOR_STRING(p_REC.JOB_CLASS);
	v_RET('IS_SNOOZED') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_SNOOZED);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_JOB_THREAD_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION JOB_THREAD_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN JOB_THREAD%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_JOB_THREAD_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_JOB_THREAD);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_JOB_THREAD, v_REALMS);
END JOB_THREAD_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_LOAD_PROFILE_FIELDS_MAP
	(
	p_REC IN LOAD_PROFILE%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('PROFILE_LIBRARY_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PROFILE_LIBRARY_ID);
	v_RET('PROFILE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PROFILE_ID);
	v_RET('PROFILE_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.PROFILE_NAME);
	v_RET('PROFILE_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.PROFILE_ALIAS);
	v_RET('PROFILE_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.PROFILE_DESC);
	v_RET('PROFILE_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.PROFILE_TYPE);
	v_RET('PROFILE_OPERATION') := UT.GET_LITERAL_FOR_STRING(p_REC.PROFILE_OPERATION);
	v_RET('PROFILE_ORIGIN') := UT.GET_LITERAL_FOR_STRING(p_REC.PROFILE_ORIGIN);
	v_RET('PROFILE_RATE_CLASS') := UT.GET_LITERAL_FOR_STRING(p_REC.PROFILE_RATE_CLASS);
	v_RET('PROFILE_DAY_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.PROFILE_DAY_TYPE);
	v_RET('PROFILE_ACCOUNT_REF') := UT.GET_LITERAL_FOR_STRING(p_REC.PROFILE_ACCOUNT_REF);
	v_RET('PROFILE_METER_REF') := UT.GET_LITERAL_FOR_STRING(p_REC.PROFILE_METER_REF);
	v_RET('PROFILE_SIC_CODE') := UT.GET_LITERAL_FOR_STRING(p_REC.PROFILE_SIC_CODE);
	v_RET('PROFILE_SEASON') := UT.GET_LITERAL_FOR_STRING(p_REC.PROFILE_SEASON);
	v_RET('PROFILE_SYSTEM_LOAD') := UT.GET_LITERAL_FOR_STRING(p_REC.PROFILE_SYSTEM_LOAD);
	v_RET('PROFILE_ADJUSTMENT_OPTION') := UT.GET_LITERAL_FOR_STRING(p_REC.PROFILE_ADJUSTMENT_OPTION);
	v_RET('PROFILE_STATION_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PROFILE_STATION_ID);
	v_RET('PROFILE_TEMPLATE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PROFILE_TEMPLATE_ID);
	v_RET('PROFILE_SOURCE_BEGIN_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.PROFILE_SOURCE_BEGIN_DATE);
	v_RET('PROFILE_SOURCE_END_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.PROFILE_SOURCE_END_DATE);
	v_RET('PROFILE_SOURCE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PROFILE_SOURCE_ID);
	v_RET('PROFILE_INTERVAL') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PROFILE_INTERVAL);
	v_RET('PROFILE_SOURCE_VERSION') := UT.GET_LITERAL_FOR_DATE(p_REC.PROFILE_SOURCE_VERSION);
	v_RET('PROFILE_BREAKPOINT_INTERVAL') := UT.GET_LITERAL_FOR_STRING(p_REC.PROFILE_BREAKPOINT_INTERVAL);
	v_RET('IS_EXTERNAL_PROFILE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_EXTERNAL_PROFILE);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_LOAD_PROFILE_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION LOAD_PROFILE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN LOAD_PROFILE%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_LOAD_PROFILE_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_LOAD_PROFILE);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_LOAD_PROFILE, v_REALMS);
END LOAD_PROFILE_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_LOAD_PROFILE_LIBRARY_FIELD
	(
	p_REC IN LOAD_PROFILE_LIBRARY%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('PROFILE_LIBRARY_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PROFILE_LIBRARY_ID);
	v_RET('PROFILE_LIBRARY_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.PROFILE_LIBRARY_NAME);
	v_RET('PROFILE_LIBRARY_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.PROFILE_LIBRARY_ALIAS);
	v_RET('PROFILE_LIBRARY_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.PROFILE_LIBRARY_DESC);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_LOAD_PROFILE_LIBRARY_FIELD;
---------------------------------------------------------------------
FUNCTION LOAD_PROFILE_LIBRARY_IS_ALLOWE
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN LOAD_PROFILE_LIBRARY%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_LOAD_PROFILE_LIBRARY_FIELD(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_LOAD_PROFILE_LIBRARY);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_LOAD_PROFILE_LIBRARY, v_REALMS);
END LOAD_PROFILE_LIBRARY_IS_ALLOWE;
---------------------------------------------------------------------
FUNCTION GET_LOAD_PROFILE_SET_FIELDS_MA
	(
	p_REC IN LOAD_PROFILE_SET%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('PROFILE_SET_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PROFILE_SET_ID);
	v_RET('PROFILE_SET_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.PROFILE_SET_NAME);
	v_RET('PROFILE_SET_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.PROFILE_SET_ALIAS);
	v_RET('PROFILE_SET_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.PROFILE_SET_DESC);
	v_RET('PROFILE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PROFILE_ID);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_LOAD_PROFILE_SET_FIELDS_MA;
---------------------------------------------------------------------
FUNCTION GET_LOSS_FACTOR_FIELDS_MAP
	(
	p_REC IN LOSS_FACTOR%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('LOSS_FACTOR_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.LOSS_FACTOR_ID);
	v_RET('LOSS_FACTOR_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.LOSS_FACTOR_NAME);
	v_RET('LOSS_FACTOR_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.LOSS_FACTOR_ALIAS);
	v_RET('LOSS_FACTOR_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.LOSS_FACTOR_DESC);
	v_RET('EXTERNAL_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_REC.EXTERNAL_IDENTIFIER);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_LOSS_FACTOR_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION LOSS_FACTOR_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN LOSS_FACTOR%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_LOSS_FACTOR_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_LOSS_FACTOR);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_LOSS_FACTOR, v_REALMS);
END LOSS_FACTOR_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_MARKET_PRICE_FIELDS_MAP
	(
	p_REC IN MARKET_PRICE%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('MARKET_PRICE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.MARKET_PRICE_ID);
	v_RET('MARKET_PRICE_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.MARKET_PRICE_NAME);
	v_RET('MARKET_PRICE_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.MARKET_PRICE_ALIAS);
	v_RET('MARKET_PRICE_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.MARKET_PRICE_DESC);
	v_RET('MARKET_PRICE_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.MARKET_PRICE_TYPE);
	v_RET('MARKET_PRICE_INTERVAL') := UT.GET_LITERAL_FOR_STRING(p_REC.MARKET_PRICE_INTERVAL);
	v_RET('MARKET_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.MARKET_TYPE);
	v_RET('COMMODITY_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.COMMODITY_ID);
	v_RET('SERVICE_POINT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.SERVICE_POINT_TYPE);
	v_RET('EXTERNAL_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_REC.EXTERNAL_IDENTIFIER);
	v_RET('EDC_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.EDC_ID);
	v_RET('SC_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SC_ID);
	v_RET('POD_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.POD_ID);
	v_RET('ZOD_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.ZOD_ID);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_MARKET_PRICE_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION MARKET_PRICE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN MARKET_PRICE%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_MARKET_PRICE_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_MARKET_PRICE);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_MARKET_PRICE, v_REALMS);
END MARKET_PRICE_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_MEASUREMENT_SOURCE_FIELDS_
	(
	p_REC IN MEASUREMENT_SOURCE%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('MEASUREMENT_SOURCE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.MEASUREMENT_SOURCE_ID);
	v_RET('MEASUREMENT_SOURCE_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.MEASUREMENT_SOURCE_NAME);
	v_RET('MEASUREMENT_SOURCE_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.MEASUREMENT_SOURCE_ALIAS);
	v_RET('MEASUREMENT_SOURCE_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.MEASUREMENT_SOURCE_DESC);
	v_RET('MEASUREMENT_SOURCE_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.MEASUREMENT_SOURCE_TYPE);
	v_RET('MEASUREMENT_SOURCE_INTERVAL') := UT.GET_LITERAL_FOR_STRING(p_REC.MEASUREMENT_SOURCE_INTERVAL);
	v_RET('METER_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.METER_TYPE);
	v_RET('BEGIN_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.BEGIN_DATE);
	v_RET('END_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.END_DATE);
	v_RET('EXTERNAL_SYSTEM_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.EXTERNAL_SYSTEM_ID);
	v_RET('EXTERNAL_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_REC.EXTERNAL_IDENTIFIER);
	v_RET('PRECISION') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PRECISION);
	v_RET('UOM') := UT.GET_LITERAL_FOR_STRING(p_REC.UOM);
	v_RET('POLLING_TIME') := UT.GET_LITERAL_FOR_NUMBER(p_REC.POLLING_TIME);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_MEASUREMENT_SOURCE_FIELDS_;
---------------------------------------------------------------------
FUNCTION MEASUREMENT_SOURCE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN MEASUREMENT_SOURCE%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_MEASUREMENT_SOURCE_FIELDS_(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_MEASUREMENT_SOURCE);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_MEASUREMENT_SOURCE, v_REALMS);
END MEASUREMENT_SOURCE_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_METER_FIELDS_MAP
	(
	p_REC IN METER%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('MRSP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.MRSP_ID);
	v_RET('METER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.METER_ID);
	v_RET('METER_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.METER_NAME);
	v_RET('METER_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.METER_ALIAS);
	v_RET('METER_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.METER_DESC);
	v_RET('METER_EXTERNAL_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_REC.METER_EXTERNAL_IDENTIFIER);
	v_RET('METER_STATUS') := UT.GET_LITERAL_FOR_STRING(p_REC.METER_STATUS);
	v_RET('METER_INTERVAL') := UT.GET_LITERAL_FOR_STRING(p_REC.METER_INTERVAL);
	v_RET('METER_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.METER_TYPE);
	v_RET('METER_UNIT') := UT.GET_LITERAL_FOR_STRING(p_REC.METER_UNIT);
	v_RET('IS_EXTERNAL_INTERVAL_USAGE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_EXTERNAL_INTERVAL_USAGE);
	v_RET('IS_EXTERNAL_BILLED_USAGE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_EXTERNAL_BILLED_USAGE);
	v_RET('IS_EXTERNAL_FORECAST') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_EXTERNAL_FORECAST);
	v_RET('USE_TOU_USAGE_FACTOR') := UT.GET_LITERAL_FOR_NUMBER(p_REC.USE_TOU_USAGE_FACTOR);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_METER_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION METER_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN METER%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_METER_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_METER);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_METER, v_REALMS);
END METER_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_MRSP_FIELDS_MAP
	(
	p_REC IN METER_READING_SERVICE_PROVIDER%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('MRSP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.MRSP_ID);
	v_RET('MRSP_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.MRSP_NAME);
	v_RET('MRSP_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.MRSP_ALIAS);
	v_RET('MRSP_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.MRSP_DESC);
	v_RET('MRSP_DUNS_NUMBER') := UT.GET_LITERAL_FOR_STRING(p_REC.MRSP_DUNS_NUMBER);
	v_RET('MRSP_STATUS') := UT.GET_LITERAL_FOR_STRING(p_REC.MRSP_STATUS);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_MRSP_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION MRSP_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN METER_READING_SERVICE_PROVIDER%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_MRSP_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_MRSP);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_MRSP, v_REALMS);
END MRSP_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_OASIS_NODE_FIELDS_MAP
	(
	p_REC IN OASIS_NODE%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('OASIS_NODE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.OASIS_NODE_ID);
	v_RET('OASIS_NODE_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.OASIS_NODE_NAME);
	v_RET('OASIS_NODE_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.OASIS_NODE_ALIAS);
	v_RET('OASIS_NODE_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.OASIS_NODE_DESC);
	v_RET('URL') := UT.GET_LITERAL_FOR_STRING(p_REC.URL);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_OASIS_NODE_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION OASIS_NODE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN OASIS_NODE%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_OASIS_NODE_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_OASIS_NODE);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_OASIS_NODE, v_REALMS);
END OASIS_NODE_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_PATH_FIELDS_MAP
	(
	p_REC IN TX_PATH%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('PATH_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PATH_ID);
	v_RET('PATH_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.PATH_NAME);
	v_RET('PATH_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.PATH_ALIAS);
	v_RET('PATH_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.PATH_DESC);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_PATH_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION PATH_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN TX_PATH%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_PATH_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_PATH);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_PATH, v_REALMS);
END PATH_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_PERIOD_FIELDS_MAP
	(
	p_REC IN PERIOD%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('PERIOD_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PERIOD_ID);
	v_RET('PERIOD_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.PERIOD_NAME);
	v_RET('PERIOD_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.PERIOD_ALIAS);
	v_RET('PERIOD_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.PERIOD_DESC);
	v_RET('PERIOD_COLOR') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PERIOD_COLOR);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_PERIOD_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION PERIOD_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN PERIOD%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_PERIOD_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_PERIOD);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_PERIOD, v_REALMS);
END PERIOD_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_PIPELINE_FIELDS_MAP
	(
	p_REC IN PIPELINE%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('PIPELINE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PIPELINE_ID);
	v_RET('PIPELINE_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.PIPELINE_NAME);
	v_RET('PIPELINE_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.PIPELINE_ALIAS);
	v_RET('PIPELINE_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.PIPELINE_DESC);
	v_RET('PIPELINE_STATUS') := UT.GET_LITERAL_FOR_STRING(p_REC.PIPELINE_STATUS);
	v_RET('EXTERNAL_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_REC.EXTERNAL_IDENTIFIER);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_PIPELINE_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION PIPELINE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN PIPELINE%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_PIPELINE_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_PIPELINE);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_PIPELINE, v_REALMS);
END PIPELINE_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_POOL_FIELDS_MAP
	(
	p_REC IN POOL%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('POOL_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.POOL_ID);
	v_RET('POOL_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.POOL_NAME);
	v_RET('POOL_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.POOL_ALIAS);
	v_RET('POOL_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.POOL_DESC);
	v_RET('POOL_EXTERNAL_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_REC.POOL_EXTERNAL_IDENTIFIER);
	v_RET('POOL_STATUS') := UT.GET_LITERAL_FOR_STRING(p_REC.POOL_STATUS);
	v_RET('POOL_CATEGORY') := UT.GET_LITERAL_FOR_STRING(p_REC.POOL_CATEGORY);
	v_RET('POOL_EXCLUDE_LOAD_SCHEDULE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.POOL_EXCLUDE_LOAD_SCHEDULE);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_POOL_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION POOL_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN POOL%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_POOL_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_POOL);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_POOL, v_REALMS);
END POOL_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_PORTFOLIO_FIELDS_MAP
	(
	p_REC IN PORTFOLIO%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('PORTFOLIO_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PORTFOLIO_ID);
	v_RET('PORTFOLIO_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.PORTFOLIO_NAME);
	v_RET('PORTFOLIO_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.PORTFOLIO_ALIAS);
	v_RET('PORTFOLIO_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.PORTFOLIO_DESC);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_PORTFOLIO_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION PORTFOLIO_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN PORTFOLIO%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_PORTFOLIO_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_PORTFOLIO);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_PORTFOLIO, v_REALMS);
END PORTFOLIO_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_POSITION_EVALUATION_FIELDS
	(
	p_REC IN POSITION_ANALYSIS_EVALUATION%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('EVALUATION_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.EVALUATION_ID);
	v_RET('EVALUATION_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.EVALUATION_NAME);
	v_RET('EVALUATION_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.EVALUATION_ALIAS);
	v_RET('EVALUATION_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.EVALUATION_DESC);
	v_RET('BEGIN_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.BEGIN_DATE);
	v_RET('END_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.END_DATE);
	v_RET('MARKET_PRICE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.MARKET_PRICE_ID);
	v_RET('LAST_RUN_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.LAST_RUN_DATE);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_POSITION_EVALUATION_FIELDS;
---------------------------------------------------------------------
FUNCTION GET_PRODUCT_FIELDS_MAP
	(
	p_REC IN PRODUCT%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('PRODUCT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PRODUCT_ID);
	v_RET('PRODUCT_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.PRODUCT_NAME);
	v_RET('PRODUCT_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.PRODUCT_ALIAS);
	v_RET('PRODUCT_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.PRODUCT_DESC);
	v_RET('PRODUCT_EXTERNAL_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_REC.PRODUCT_EXTERNAL_IDENTIFIER);
	v_RET('PRODUCT_CATEGORY') := UT.GET_LITERAL_FOR_STRING(p_REC.PRODUCT_CATEGORY);
	v_RET('BEGIN_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.BEGIN_DATE);
	v_RET('END_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.END_DATE);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_PRODUCT_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION PRODUCT_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN PRODUCT%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_PRODUCT_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_PRODUCT);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_PRODUCT, v_REALMS);
END PRODUCT_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_PROGRAM_FIELDS_MAP
	(
	p_REC IN PROGRAM%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('PROGRAM_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PROGRAM_ID);
	v_RET('PROGRAM_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.PROGRAM_NAME);
	v_RET('PROGRAM_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.PROGRAM_ALIAS);
	v_RET('PROGRAM_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.PROGRAM_DESC);
	v_RET('EXTERNAL_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_REC.EXTERNAL_IDENTIFIER);
	v_RET('PROGRAM_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.PROGRAM_TYPE);
	v_RET('PROGRAM_INTERVAL') := UT.GET_LITERAL_FOR_STRING(p_REC.PROGRAM_INTERVAL);
	v_RET('CUSTOMER_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.CUSTOMER_TYPE);
	v_RET('MAX_DURATION_HOUR') := UT.GET_LITERAL_FOR_NUMBER(p_REC.MAX_DURATION_HOUR);
	v_RET('MAX_DURATION_MINUTE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.MAX_DURATION_MINUTE);
	v_RET('MIN_OFF_TIME_HOUR') := UT.GET_LITERAL_FOR_NUMBER(p_REC.MIN_OFF_TIME_HOUR);
	v_RET('MIN_OFF_TIME_MINUTE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.MIN_OFF_TIME_MINUTE);
	v_RET('DEGREE_INCREASE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.DEGREE_INCREASE);
	v_RET('DEGREE_DECREASE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.DEGREE_DECREASE);
	v_RET('ALLOW_CUSTOMER_OVERRIDE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.ALLOW_CUSTOMER_OVERRIDE);
	v_RET('DEFAULT_OPT_OUT_PCT') := UT.GET_LITERAL_FOR_NUMBER(p_REC.DEFAULT_OPT_OUT_PCT);
	v_RET('DEFAULT_OVERRIDE_PCT') := UT.GET_LITERAL_FOR_NUMBER(p_REC.DEFAULT_OVERRIDE_PCT);
	v_RET('USE_DEFAULT_OPT_OUT_OVERRIDE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.USE_DEFAULT_OPT_OUT_OVERRIDE);
	v_RET('VALIDATION_METHOD') := UT.GET_LITERAL_FOR_STRING(p_REC.VALIDATION_METHOD);
	v_RET('TRANSACTION_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.TRANSACTION_ID);
	v_RET('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.COMPONENT_ID);
	v_RET('SIGNAL_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.SIGNAL_TYPE);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_PROGRAM_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION PROGRAM_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN PROGRAM%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_PROGRAM_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_PROGRAM);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_PROGRAM, v_REALMS);
END PROGRAM_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_PROSPECT_SCREEN_FIELDS_MAP
	(
	p_REC IN PROSPECT_SCREEN%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('SCREEN_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SCREEN_ID);
	v_RET('SCREEN_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.SCREEN_NAME);
	v_RET('SCREEN_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.SCREEN_ALIAS);
	v_RET('SCREEN_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.SCREEN_DESC);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_PROSPECT_SCREEN_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION GET_PROXY_DAY_METHOD_FIELDS_MA
	(
	p_REC IN PROXY_DAY_METHOD%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('PROXY_DAY_METHOD_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PROXY_DAY_METHOD_ID);
	v_RET('PROXY_DAY_METHOD_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.PROXY_DAY_METHOD_NAME);
	v_RET('PROXY_DAY_METHOD_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.PROXY_DAY_METHOD_ALIAS);
	v_RET('PROXY_DAY_METHOD_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.PROXY_DAY_METHOD_DESC);
	v_RET('TEMPLATE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.TEMPLATE_ID);
	v_RET('COMPARATIVE_VALUE') := UT.GET_LITERAL_FOR_STRING(p_REC.COMPARATIVE_VALUE);
	v_RET('STATION_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.STATION_ID);
	v_RET('PARAMETER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PARAMETER_ID);
	v_RET('SYSTEM_LOAD_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SYSTEM_LOAD_ID);
	v_RET('LOOKUP_TIME_HORIZON') := UT.GET_LITERAL_FOR_NUMBER(p_REC.LOOKUP_TIME_HORIZON);
	v_RET('TIME_HORIZON_SHIFT') := UT.GET_LITERAL_FOR_NUMBER(p_REC.TIME_HORIZON_SHIFT);
	v_RET('LOOKUP_CANDIDATE_LIMIT') := UT.GET_LITERAL_FOR_NUMBER(p_REC.LOOKUP_CANDIDATE_LIMIT);
	v_RET('CANDIDATE_DELTA_THRESHOLD') := UT.GET_LITERAL_FOR_NUMBER(p_REC.CANDIDATE_DELTA_THRESHOLD);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
	v_RET('HOLIDAY_SET_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.HOLIDAY_SET_ID);
    
	RETURN v_RET;
END GET_PROXY_DAY_METHOD_FIELDS_MA;
---------------------------------------------------------------------
FUNCTION PROXY_DAY_METHOD_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN PROXY_DAY_METHOD%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_PROXY_DAY_METHOD_FIELDS_MA(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_PROXY_DAY_METHOD);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_PROXY_DAY_METHOD, v_REALMS);
END PROXY_DAY_METHOD_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_PSE_FIELDS_MAP
	(
	p_REC IN PURCHASING_SELLING_ENTITY%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('PSE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PSE_ID);
	v_RET('PSE_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.PSE_NAME);
	v_RET('PSE_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.PSE_ALIAS);
	v_RET('PSE_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.PSE_DESC);
	v_RET('PSE_NERC_CODE') := UT.GET_LITERAL_FOR_STRING(p_REC.PSE_NERC_CODE);
	v_RET('PSE_STATUS') := UT.GET_LITERAL_FOR_STRING(p_REC.PSE_STATUS);
	v_RET('PSE_DUNS_NUMBER') := UT.GET_LITERAL_FOR_STRING(p_REC.PSE_DUNS_NUMBER);
	v_RET('PSE_BANK') := UT.GET_LITERAL_FOR_STRING(p_REC.PSE_BANK);
	v_RET('PSE_ACH_NUMBER') := UT.GET_LITERAL_FOR_STRING(p_REC.PSE_ACH_NUMBER);
	v_RET('PSE_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.PSE_TYPE);
	v_RET('PSE_EXTERNAL_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_REC.PSE_EXTERNAL_IDENTIFIER);
	v_RET('PSE_IS_RETAIL_AGGREGATOR') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PSE_IS_RETAIL_AGGREGATOR);
	v_RET('PSE_IS_BACKUP_GENERATION') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PSE_IS_BACKUP_GENERATION);
	v_RET('PSE_EXCLUDE_LOAD_SCHEDULE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PSE_EXCLUDE_LOAD_SCHEDULE);
	v_RET('IS_BILLING_ENTITY') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_BILLING_ENTITY);
	v_RET('TIME_ZONE') := UT.GET_LITERAL_FOR_STRING(p_REC.TIME_ZONE);
	v_RET('STATEMENT_INTERVAL') := UT.GET_LITERAL_FOR_STRING(p_REC.STATEMENT_INTERVAL);
	v_RET('INVOICE_INTERVAL') := UT.GET_LITERAL_FOR_STRING(p_REC.INVOICE_INTERVAL);
	v_RET('WEEK_BEGIN') := UT.GET_LITERAL_FOR_STRING(p_REC.WEEK_BEGIN);
	v_RET('INVOICE_LINE_ITEM_OPTION') := UT.GET_LITERAL_FOR_STRING(p_REC.INVOICE_LINE_ITEM_OPTION);
	v_RET('INVOICE_EMAIL_SUBJECT') := UT.GET_LITERAL_FOR_STRING(p_REC.INVOICE_EMAIL_SUBJECT);
	v_RET('INVOICE_EMAIL_PRIORITY') := UT.GET_LITERAL_FOR_NUMBER(p_REC.INVOICE_EMAIL_PRIORITY);
	v_RET('INVOICE_EMAIL_BODY') := UT.GET_LITERAL_FOR_STRING(p_REC.INVOICE_EMAIL_BODY);
	v_RET('INVOICE_EMAIL_BODY_MIME_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.INVOICE_EMAIL_BODY_MIME_TYPE);
	v_RET('SCHEDULE_NAME_PREFIX') := UT.GET_LITERAL_FOR_STRING(p_REC.SCHEDULE_NAME_PREFIX);
	v_RET('SCHEDULE_FORMAT') := UT.GET_LITERAL_FOR_STRING(p_REC.SCHEDULE_FORMAT);
	v_RET('SCHEDULE_INTERVAL') := UT.GET_LITERAL_FOR_STRING(p_REC.SCHEDULE_INTERVAL);
	v_RET('LOAD_ROUNDING_PREFERENCE') := UT.GET_LITERAL_FOR_STRING(p_REC.LOAD_ROUNDING_PREFERENCE);
	v_RET('LOSS_ROUNDING_PREFERENCE') := UT.GET_LITERAL_FOR_STRING(p_REC.LOSS_ROUNDING_PREFERENCE);
	v_RET('CREATE_TX_LOSS_SCHEDULE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.CREATE_TX_LOSS_SCHEDULE);
	v_RET('CREATE_DX_LOSS_SCHEDULE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.CREATE_DX_LOSS_SCHEDULE);
	v_RET('CREATE_UFE_SCHEDULE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.CREATE_UFE_SCHEDULE);
	v_RET('MINIMUM_SCHEDULE_AMT') := UT.GET_LITERAL_FOR_NUMBER(p_REC.MINIMUM_SCHEDULE_AMT);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_PSE_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION PSE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN PURCHASING_SELLING_ENTITY%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_PSE_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_PSE);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_PSE, v_REALMS);
END PSE_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_QUOTE_REQUEST_FIELDS_MAP
	(
	p_REC IN QUOTE_REQUEST%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('QUOTE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.QUOTE_ID);
	v_RET('QUOTE_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.QUOTE_NAME);
	v_RET('QUOTE_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.QUOTE_ALIAS);
	v_RET('QUOTE_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.QUOTE_DESC);
	v_RET('CAMPAIGN_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.CAMPAIGN_NAME);
	v_RET('CUSTOMER_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.CUSTOMER_NAME);
	v_RET('CUSTOMER_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.CUSTOMER_TYPE);
	v_RET('CUSTOMER_REP_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.CUSTOMER_REP_NAME);
	v_RET('EDC_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.EDC_ID);
	v_RET('SERVICE_POINT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SERVICE_POINT_ID);
	v_RET('CUSTOMER_CLASS') := UT.GET_LITERAL_FOR_STRING(p_REC.CUSTOMER_CLASS);
	v_RET('EDC_ACCOUNT_NUMBER') := UT.GET_LITERAL_FOR_STRING(p_REC.EDC_ACCOUNT_NUMBER);
	v_RET('QUOTE_EFFECTIVE_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.QUOTE_EFFECTIVE_DATE);
	v_RET('QUOTE_EXPIRATION_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.QUOTE_EXPIRATION_DATE);
	v_RET('SERVICE_BEGIN_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.SERVICE_BEGIN_DATE);
	v_RET('SERVICE_END_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.SERVICE_END_DATE);
	v_RET('QUOTE_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.QUOTE_TYPE);
	v_RET('QUOTE_STATUS') := UT.GET_LITERAL_FOR_STRING(p_REC.QUOTE_STATUS);
	v_RET('STATION_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.STATION_ID);
	v_RET('NUMBER_OF_CUSTOMERS') := UT.GET_LITERAL_FOR_NUMBER(p_REC.NUMBER_OF_CUSTOMERS);
	v_RET('SIGNING_PROBABILITY') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SIGNING_PROBABILITY);
	v_RET('QUOTE_NOTES') := UT.GET_LITERAL_FOR_STRING(p_REC.QUOTE_NOTES);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_QUOTE_REQUEST_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION QUOTE_REQUEST_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN QUOTE_REQUEST%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_QUOTE_REQUEST_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_QUOTE_REQUEST);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_QUOTE_REQUEST, v_REALMS);
END QUOTE_REQUEST_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_REACTOR_PROCEDURE_FIELDS_M
	(
	p_REC IN REACTOR_PROCEDURE%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('REACTOR_PROCEDURE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.REACTOR_PROCEDURE_ID);
	v_RET('REACTOR_PROCEDURE_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.REACTOR_PROCEDURE_NAME);
	v_RET('REACTOR_PROCEDURE_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.REACTOR_PROCEDURE_ALIAS);
	v_RET('REACTOR_PROCEDURE_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.REACTOR_PROCEDURE_DESC);
	v_RET('TABLE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.TABLE_ID);
	v_RET('PROCEDURE_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.PROCEDURE_NAME);
	v_RET('JOB_THREAD_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.JOB_THREAD_ID);
	v_RET('JOB_COMMENTS') := UT.GET_LITERAL_FOR_STRING(p_REC.JOB_COMMENTS);
	v_RET('CALL_ORDER') := UT.GET_LITERAL_FOR_NUMBER(p_REC.CALL_ORDER);
	v_RET('SKIP_WHEN_FORMULA') := UT.GET_LITERAL_FOR_STRING(p_REC.SKIP_WHEN_FORMULA);
	v_RET('TIME_ZONE') := UT.GET_LITERAL_FOR_STRING(p_REC.TIME_ZONE);
	v_RET('IS_IMMEDIATE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_IMMEDIATE);
	v_RET('IS_ENABLED') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_ENABLED);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_REACTOR_PROCEDURE_FIELDS_M;
---------------------------------------------------------------------
FUNCTION REACTOR_PROCEDURE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN REACTOR_PROCEDURE%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_REACTOR_PROCEDURE_FIELDS_M(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_REACTOR_PROCEDURE);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_REACTOR_PROCEDURE, v_REALMS);
END REACTOR_PROCEDURE_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_RESOURCE_GROUP_FIELDS_MAP
	(
	p_REC IN SUPPLY_RESOURCE_GROUP%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('RESOURCE_GROUP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.RESOURCE_GROUP_ID);
	v_RET('RESOURCE_GROUP_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.RESOURCE_GROUP_NAME);
	v_RET('RESOURCE_GROUP_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.RESOURCE_GROUP_ALIAS);
	v_RET('RESOURCE_GROUP_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.RESOURCE_GROUP_DESC);
	v_RET('SERVICE_ZONE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SERVICE_ZONE_ID);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_RESOURCE_GROUP_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION RESOURCE_GROUP_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SUPPLY_RESOURCE_GROUP%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_RESOURCE_GROUP_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_RESOURCE_GROUP);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_RESOURCE_GROUP, v_REALMS);
END RESOURCE_GROUP_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_ROLLUP_FIELDS_MAP
	(
	p_REC IN RTO_ROLLUP%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('ROLLUP_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.ROLLUP_NAME);
	v_RET('ROLLUP_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.ROLLUP_ALIAS);
	v_RET('ROLLUP_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.ROLLUP_DESC);
	v_RET('ROLLUP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.ROLLUP_ID);
	v_RET('ROLLUP_CATEGORY') := UT.GET_LITERAL_FOR_STRING(p_REC.ROLLUP_CATEGORY);
	v_RET('ROLLUP_LEVEL') := UT.GET_LITERAL_FOR_NUMBER(p_REC.ROLLUP_LEVEL);
	v_RET('ROLLUP_PARENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.ROLLUP_PARENT_ID);
	v_RET('ROLLUP_CHILDREN') := UT.GET_LITERAL_FOR_NUMBER(p_REC.ROLLUP_CHILDREN);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_ROLLUP_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION GET_SC_FIELDS_MAP
	(
	p_REC IN SCHEDULE_COORDINATOR%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('SC_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SC_ID);
	v_RET('SC_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.SC_NAME);
	v_RET('SC_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.SC_ALIAS);
	v_RET('SC_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.SC_DESC);
	v_RET('SC_NERC_CODE') := UT.GET_LITERAL_FOR_STRING(p_REC.SC_NERC_CODE);
	v_RET('SC_DUNS_NUMBER') := UT.GET_LITERAL_FOR_STRING(p_REC.SC_DUNS_NUMBER);
	v_RET('SC_STATUS') := UT.GET_LITERAL_FOR_STRING(p_REC.SC_STATUS);
	v_RET('SC_EXTERNAL_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_REC.SC_EXTERNAL_IDENTIFIER);
	v_RET('SC_SCHEDULE_NAME_PREFIX') := UT.GET_LITERAL_FOR_STRING(p_REC.SC_SCHEDULE_NAME_PREFIX);
	v_RET('SC_SCHEDULE_FORMAT') := UT.GET_LITERAL_FOR_STRING(p_REC.SC_SCHEDULE_FORMAT);
	v_RET('SC_SCHEDULE_INTERVAL') := UT.GET_LITERAL_FOR_STRING(p_REC.SC_SCHEDULE_INTERVAL);
	v_RET('SC_LOAD_ROUNDING_PREFERENCE') := UT.GET_LITERAL_FOR_STRING(p_REC.SC_LOAD_ROUNDING_PREFERENCE);
	v_RET('SC_LOSS_ROUNDING_PREFERENCE') := UT.GET_LITERAL_FOR_STRING(p_REC.SC_LOSS_ROUNDING_PREFERENCE);
	v_RET('SC_CREATE_TX_LOSS_SCHEDULE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SC_CREATE_TX_LOSS_SCHEDULE);
	v_RET('SC_CREATE_DX_LOSS_SCHEDULE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SC_CREATE_DX_LOSS_SCHEDULE);
	v_RET('SC_CREATE_UFE_SCHEDULE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SC_CREATE_UFE_SCHEDULE);
	v_RET('SC_MARKET_PRICE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SC_MARKET_PRICE_ID);
	v_RET('SC_MINIMUM_SCHEDULE_AMT') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SC_MINIMUM_SCHEDULE_AMT);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_SC_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION SC_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SCHEDULE_COORDINATOR%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_SC_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_SC);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_SC, v_REALMS);
END SC_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_SCENARIO_FIELDS_MAP
	(
	p_REC IN SCENARIO%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('SCENARIO_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SCENARIO_ID);
	v_RET('SCENARIO_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.SCENARIO_NAME);
	v_RET('SCENARIO_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.SCENARIO_ALIAS);
	v_RET('SCENARIO_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.SCENARIO_DESC);
	v_RET('SCENARIO_CATEGORY') := UT.GET_LITERAL_FOR_STRING(p_REC.SCENARIO_CATEGORY);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_SCENARIO_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION SCENARIO_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SCENARIO%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_SCENARIO_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_SCENARIO);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_SCENARIO, v_REALMS);
END SCENARIO_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_SCHEDULE_GROUP_FIELDS_MAP
	(
	p_REC IN SCHEDULE_GROUP%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('SCHEDULE_GROUP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SCHEDULE_GROUP_ID);
	v_RET('SCHEDULE_GROUP_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.SCHEDULE_GROUP_NAME);
	v_RET('SCHEDULE_GROUP_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.SCHEDULE_GROUP_ALIAS);
	v_RET('SCHEDULE_GROUP_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.SCHEDULE_GROUP_DESC);
	v_RET('SERVICE_ZONE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SERVICE_ZONE_ID);
	v_RET('SC_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SC_ID);
	v_RET('SERVICE_POINT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SERVICE_POINT_ID);
	v_RET('METER_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.METER_TYPE);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_SCHEDULE_GROUP_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION SCHEDULE_GROUP_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SCHEDULE_GROUP%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_SCHEDULE_GROUP_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_SCHEDULE_GROUP);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_SCHEDULE_GROUP, v_REALMS);
END SCHEDULE_GROUP_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_SEASON_FIELDS_MAP
	(
	p_REC IN SEASON%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('SEASON_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SEASON_ID);
	v_RET('SEASON_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.SEASON_NAME);
	v_RET('SEASON_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.SEASON_ALIAS);
	v_RET('SEASON_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.SEASON_DESC);
	v_RET('BEGIN_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.BEGIN_DATE);
	v_RET('END_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.END_DATE);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_SEASON_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION SEASON_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SEASON%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_SEASON_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_SEASON);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_SEASON, v_REALMS);
END SEASON_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_SEGMENT_FIELDS_MAP
	(
	p_REC IN TX_SEGMENT%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('SEGMENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SEGMENT_ID);
	v_RET('SEGMENT_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.SEGMENT_NAME);
	v_RET('SEGMENT_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.SEGMENT_ALIAS);
	v_RET('SEGMENT_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.SEGMENT_DESC);
	v_RET('POR_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.POR_ID);
	v_RET('POD_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.POD_ID);
	v_RET('MW_LIMIT_1') := UT.GET_LITERAL_FOR_STRING(p_REC.MW_LIMIT_1);
	v_RET('MW_LIMIT_2') := UT.GET_LITERAL_FOR_STRING(p_REC.MW_LIMIT_2);
	v_RET('MW_LIMIT_3') := UT.GET_LITERAL_FOR_STRING(p_REC.MW_LIMIT_3);
	v_RET('LOSS_FACTOR') := UT.GET_LITERAL_FOR_NUMBER(p_REC.LOSS_FACTOR);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_SEGMENT_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION SEGMENT_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN TX_SEGMENT%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_SEGMENT_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_SEGMENT);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_SEGMENT, v_REALMS);
END SEGMENT_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_SERVICE_AREA_FIELDS_MAP
	(
	p_REC IN SERVICE_AREA%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('SERVICE_AREA_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SERVICE_AREA_ID);
	v_RET('SERVICE_AREA_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.SERVICE_AREA_NAME);
	v_RET('SERVICE_AREA_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.SERVICE_AREA_ALIAS);
	v_RET('SERVICE_AREA_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.SERVICE_AREA_DESC);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_SERVICE_AREA_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION SERVICE_AREA_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SERVICE_AREA%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_SERVICE_AREA_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_SERVICE_AREA);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_SERVICE_AREA, v_REALMS);
END SERVICE_AREA_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_SERVICE_LOCATION_FIELDS_MA
	(
	p_REC IN SERVICE_LOCATION%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('SERVICE_LOCATION_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SERVICE_LOCATION_ID);
	v_RET('SERVICE_LOCATION_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.SERVICE_LOCATION_NAME);
	v_RET('SERVICE_LOCATION_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.SERVICE_LOCATION_ALIAS);
	v_RET('SERVICE_LOCATION_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.SERVICE_LOCATION_DESC);
	v_RET('LATITUDE') := UT.GET_LITERAL_FOR_STRING(p_REC.LATITUDE);
	v_RET('LONGITUDE') := UT.GET_LITERAL_FOR_STRING(p_REC.LONGITUDE);
	v_RET('TIME_ZONE') := UT.GET_LITERAL_FOR_STRING(p_REC.TIME_ZONE);
	v_RET('EXTERNAL_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_REC.EXTERNAL_IDENTIFIER);
	v_RET('IS_EXTERNAL_BILLED_USAGE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_EXTERNAL_BILLED_USAGE);
	v_RET('IS_METER_ALLOCATION') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_METER_ALLOCATION);
	v_RET('SERVICE_POINT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SERVICE_POINT_ID);
	v_RET('WEATHER_STATION_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.WEATHER_STATION_ID);
	v_RET('BUSINESS_ROLLUP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.BUSINESS_ROLLUP_ID);
	v_RET('GEOGRAPHIC_ROLLUP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.GEOGRAPHIC_ROLLUP_ID);
	v_RET('SQUARE_FOOTAGE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SQUARE_FOOTAGE);
	v_RET('ANNUAL_CONSUMPTION') := UT.GET_LITERAL_FOR_NUMBER(p_REC.ANNUAL_CONSUMPTION);
	v_RET('SUMMER_CONSUMPTION') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SUMMER_CONSUMPTION);
	v_RET('SERVICE_ZONE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SERVICE_ZONE_ID);
	v_RET('SUB_STATION_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SUB_STATION_ID);
	v_RET('FEEDER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.FEEDER_ID);
	v_RET('FEEDER_SEGMENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.FEEDER_SEGMENT_ID);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_SERVICE_LOCATION_FIELDS_MA;
---------------------------------------------------------------------
FUNCTION SERVICE_LOCATION_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SERVICE_LOCATION%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_SERVICE_LOCATION_FIELDS_MA(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_SERVICE_LOCATION);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_SERVICE_LOCATION, v_REALMS);
END SERVICE_LOCATION_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_SERVICE_POINT_FIELDS_MAP
	(
	p_REC IN SERVICE_POINT%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('SERVICE_POINT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SERVICE_POINT_ID);
	v_RET('SERVICE_POINT_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.SERVICE_POINT_NAME);
	v_RET('SERVICE_POINT_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.SERVICE_POINT_ALIAS);
	v_RET('SERVICE_POINT_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.SERVICE_POINT_DESC);
	v_RET('SERVICE_POINT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.SERVICE_POINT_TYPE);
	v_RET('TP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.TP_ID);
	v_RET('CA_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.CA_ID);
	v_RET('EDC_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.EDC_ID);
	v_RET('ROLLUP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.ROLLUP_ID);
	v_RET('SERVICE_REGION_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SERVICE_REGION_ID);
	v_RET('SERVICE_AREA_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SERVICE_AREA_ID);
	v_RET('SERVICE_ZONE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SERVICE_ZONE_ID);
	v_RET('TIME_ZONE') := UT.GET_LITERAL_FOR_STRING(p_REC.TIME_ZONE);
	v_RET('LATITUDE') := UT.GET_LITERAL_FOR_STRING(p_REC.LATITUDE);
	v_RET('LONGITUDE') := UT.GET_LITERAL_FOR_STRING(p_REC.LONGITUDE);
	v_RET('EXTERNAL_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_REC.EXTERNAL_IDENTIFIER);
	v_RET('IS_INTERCONNECT') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_INTERCONNECT);
	v_RET('NODE_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.NODE_TYPE);
	v_RET('SERVICE_POINT_NERC_CODE') := UT.GET_LITERAL_FOR_STRING(p_REC.SERVICE_POINT_NERC_CODE);
	v_RET('PIPELINE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PIPELINE_ID);
	v_RET('MILE_MARKER') := UT.GET_LITERAL_FOR_NUMBER(p_REC.MILE_MARKER);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_SERVICE_POINT_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION SERVICE_POINT_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SERVICE_POINT%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_SERVICE_POINT_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_SERVICE_POINT);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_SERVICE_POINT, v_REALMS);
END SERVICE_POINT_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_SERVICE_REGION_FIELDS_MAP
	(
	p_REC IN SERVICE_REGION%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('SERVICE_REGION_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SERVICE_REGION_ID);
	v_RET('SERVICE_REGION_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.SERVICE_REGION_NAME);
	v_RET('SERVICE_REGION_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.SERVICE_REGION_ALIAS);
	v_RET('SERVICE_REGION_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.SERVICE_REGION_DESC);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_SERVICE_REGION_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION SERVICE_REGION_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SERVICE_REGION%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_SERVICE_REGION_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_SERVICE_REGION);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_SERVICE_REGION, v_REALMS);
END SERVICE_REGION_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_SERVICE_TYPE_FIELDS_MAP
	(
	p_REC IN TX_SERVICE_TYPE%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('SERVICE_TYPE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SERVICE_TYPE_ID);
	v_RET('SERVICE_TYPE_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.SERVICE_TYPE_NAME);
	v_RET('SERVICE_TYPE_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.SERVICE_TYPE_ALIAS);
	v_RET('SERVICE_TYPE_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.SERVICE_TYPE_DESC);
	v_RET('SERVICE_TYPE_CATEGORY') := UT.GET_LITERAL_FOR_STRING(p_REC.SERVICE_TYPE_CATEGORY);
	v_RET('IS_FIRM') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_FIRM);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_SERVICE_TYPE_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION SERVICE_TYPE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN TX_SERVICE_TYPE%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_SERVICE_TYPE_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_SERVICE_TYPE);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_SERVICE_TYPE, v_REALMS);
END SERVICE_TYPE_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_SERVICE_ZONE_FIELDS_MAP
	(
	p_REC IN SERVICE_ZONE%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('SERVICE_ZONE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SERVICE_ZONE_ID);
	v_RET('SERVICE_ZONE_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.SERVICE_ZONE_NAME);
	v_RET('SERVICE_ZONE_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.SERVICE_ZONE_ALIAS);
	v_RET('SERVICE_ZONE_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.SERVICE_ZONE_DESC);
	v_RET('EXTERNAL_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_REC.EXTERNAL_IDENTIFIER);
	v_RET('MARKET_PRICE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.MARKET_PRICE_ID);
	v_RET('CONTROL_AREA_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.CONTROL_AREA_ID);
	v_RET('TIME_ZONE') := UT.GET_LITERAL_FOR_STRING(p_REC.TIME_ZONE);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_SERVICE_ZONE_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION SERVICE_ZONE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SERVICE_ZONE%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_SERVICE_ZONE_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_SERVICE_ZONE);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_SERVICE_ZONE, v_REALMS);
END SERVICE_ZONE_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_SETTLEMENT_TYPE_FIELDS_MAP
	(
	p_REC IN SETTLEMENT_TYPE%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('SETTLEMENT_TYPE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SETTLEMENT_TYPE_ID);
	v_RET('SETTLEMENT_TYPE_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.SETTLEMENT_TYPE_NAME);
	v_RET('SETTLEMENT_TYPE_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.SETTLEMENT_TYPE_ALIAS);
	v_RET('SETTLEMENT_TYPE_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.SETTLEMENT_TYPE_DESC);
	v_RET('SETTLEMENT_TYPE_ORDER') := UT.GET_LITERAL_FOR_STRING(p_REC.SETTLEMENT_TYPE_ORDER);
	v_RET('SERVICE_CODE') := UT.GET_LITERAL_FOR_STRING(p_REC.SERVICE_CODE);
	v_RET('SCENARIO_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SCENARIO_ID);
	v_RET('STATEMENT_TYPE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.STATEMENT_TYPE_ID);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_SETTLEMENT_TYPE_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION SETTLEMENT_TYPE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SETTLEMENT_TYPE%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_SETTLEMENT_TYPE_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_SETTLEMENT_TYPE);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_SETTLEMENT_TYPE, v_REALMS);
END SETTLEMENT_TYPE_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_STATEMENT_TYPE_FIELDS_MAP
	(
	p_REC IN STATEMENT_TYPE%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('STATEMENT_TYPE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.STATEMENT_TYPE_ID);
	v_RET('STATEMENT_TYPE_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.STATEMENT_TYPE_NAME);
	v_RET('STATEMENT_TYPE_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.STATEMENT_TYPE_ALIAS);
	v_RET('STATEMENT_TYPE_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.STATEMENT_TYPE_DESC);
	v_RET('STATEMENT_TYPE_ORDER') := UT.GET_LITERAL_FOR_NUMBER(p_REC.STATEMENT_TYPE_ORDER);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_STATEMENT_TYPE_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION STATEMENT_TYPE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN STATEMENT_TYPE%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_STATEMENT_TYPE_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_STATEMENT_TYPE);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_STATEMENT_TYPE, v_REALMS);
END STATEMENT_TYPE_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_SUB_STATION_FIELDS_MAP
	(
	p_REC IN TX_SUB_STATION%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('SUB_STATION_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SUB_STATION_ID);
	v_RET('SUB_STATION_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.SUB_STATION_NAME);
	v_RET('SUB_STATION_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.SUB_STATION_ALIAS);
	v_RET('SUB_STATION_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.SUB_STATION_DESC);
	v_RET('SUB_STATION_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.SUB_STATION_TYPE);
	v_RET('EXTERNAL_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_REC.EXTERNAL_IDENTIFIER);
	v_RET('BEGIN_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.BEGIN_DATE);
	v_RET('END_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.END_DATE);
	v_RET('SERVICE_ZONE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SERVICE_ZONE_ID);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_SUB_STATION_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION SUB_STATION_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN TX_SUB_STATION%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_SUB_STATION_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_SUB_STATION);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_SUB_STATION, v_REALMS);
END SUB_STATION_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_SUB_STATION_METER_FIELDS_M
	(
	p_REC IN TX_SUB_STATION_METER%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('METER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.METER_ID);
	v_RET('METER_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.METER_NAME);
	v_RET('METER_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.METER_ALIAS);
	v_RET('METER_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.METER_DESC);
	v_RET('EXTERNAL_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_REC.EXTERNAL_IDENTIFIER);
	v_RET('BEGIN_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.BEGIN_DATE);
	v_RET('END_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.END_DATE);
	v_RET('METER_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.METER_TYPE);
	v_RET('METER_SUB_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.METER_SUB_TYPE);
	v_RET('METER_CATEGORY') := UT.GET_LITERAL_FOR_STRING(p_REC.METER_CATEGORY);
	v_RET('REF_METER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.REF_METER_ID);
	v_RET('SUB_STATION_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SUB_STATION_ID);
	v_RET('SERVICE_POINT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SERVICE_POINT_ID);
	v_RET('TRUNCATE_CARRY_FWD') := UT.GET_LITERAL_FOR_NUMBER(p_REC.TRUNCATE_CARRY_FWD);
	v_RET('QUALITY_RATING') := UT.GET_LITERAL_FOR_STRING(p_REC.QUALITY_RATING);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_SUB_STATION_METER_FIELDS_M;
---------------------------------------------------------------------
FUNCTION SUB_STATION_METER_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN TX_SUB_STATION_METER%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_SUB_STATION_METER_FIELDS_M(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_SUB_STATION_METER);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_SUB_STATION_METER, v_REALMS);
END SUB_STATION_METER_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_SUB_STATION_METER_POINT_FI
	(
	p_REC IN TX_SUB_STATION_METER_POINT%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('METER_POINT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.METER_POINT_ID);
	v_RET('METER_POINT_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.METER_POINT_NAME);
	v_RET('METER_POINT_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.METER_POINT_ALIAS);
	v_RET('METER_POINT_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.METER_POINT_DESC);
	v_RET('EXTERNAL_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_REC.EXTERNAL_IDENTIFIER);
	v_RET('METER_POINT_CATEGORY') := UT.GET_LITERAL_FOR_STRING(p_REC.METER_POINT_CATEGORY);
	v_RET('RETAIL_METER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.RETAIL_METER_ID);
	v_RET('SUB_STATION_METER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SUB_STATION_METER_ID);
	v_RET('METER_POINT_INTERVAL') := UT.GET_LITERAL_FOR_STRING(p_REC.METER_POINT_INTERVAL);
	v_RET('BEGIN_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.BEGIN_DATE);
	v_RET('END_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.END_DATE);
	v_RET('UOM') := UT.GET_LITERAL_FOR_STRING(p_REC.UOM);
	v_RET('OPERATION_CODE') := UT.GET_LITERAL_FOR_STRING(p_REC.OPERATION_CODE);
	v_RET('DIRECTION') := UT.GET_LITERAL_FOR_STRING(p_REC.DIRECTION);
	v_RET('TOLERANCE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.TOLERANCE);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_SUB_STATION_METER_POINT_FI;
---------------------------------------------------------------------
FUNCTION SUB_STATION_METER_POINT_IS_ALL
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN TX_SUB_STATION_METER_POINT%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_SUB_STATION_METER_POINT_FI(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_SUB_STATION_METER_POINT);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_SUB_STATION_METER_POINT, v_REALMS);
END SUB_STATION_METER_POINT_IS_ALL;
---------------------------------------------------------------------
FUNCTION GET_SUPPLY_RESOURCE_FIELDS_MAP
	(
	p_REC IN SUPPLY_RESOURCE%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('RESOURCE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.RESOURCE_ID);
	v_RET('RESOURCE_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.RESOURCE_NAME);
	v_RET('RESOURCE_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.RESOURCE_ALIAS);
	v_RET('RESOURCE_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.RESOURCE_DESC);
	v_RET('RESOURCE_GROUP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.RESOURCE_GROUP_ID);
	v_RET('SERVICE_POINT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SERVICE_POINT_ID);
	v_RET('HEAT_RATE_CURVE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.HEAT_RATE_CURVE_ID);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_SUPPLY_RESOURCE_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION SUPPLY_RESOURCE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SUPPLY_RESOURCE%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_SUPPLY_RESOURCE_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_SUPPLY_RESOURCE);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_SUPPLY_RESOURCE, v_REALMS);
END SUPPLY_RESOURCE_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_SYSTEM_ACTION_FIELDS_MAP
	(
	p_REC IN SYSTEM_ACTION%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('ACTION_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.ACTION_ID);
	v_RET('ACTION_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.ACTION_NAME);
	v_RET('ACTION_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.ACTION_ALIAS);
	v_RET('ACTION_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.ACTION_DESC);
	v_RET('ENTITY_DOMAIN_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.ENTITY_DOMAIN_ID);
	v_RET('MODULE') := UT.GET_LITERAL_FOR_STRING(p_REC.MODULE);
	v_RET('ACTION_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.ACTION_TYPE);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_SYSTEM_ACTION_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION SYSTEM_ACTION_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SYSTEM_ACTION%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_SYSTEM_ACTION_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_SYSTEM_ACTION);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_SYSTEM_ACTION, v_REALMS);
END SYSTEM_ACTION_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_SYSTEM_ALERT_FIELDS_MAP
	(
	p_REC IN SYSTEM_ALERT%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('ALERT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.ALERT_ID);
	v_RET('ALERT_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.ALERT_NAME);
	v_RET('ALERT_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.ALERT_ALIAS);
	v_RET('ALERT_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.ALERT_DESC);
	v_RET('ALERT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.ALERT_TYPE);
	v_RET('ALERT_CATEGORY') := UT.GET_LITERAL_FOR_STRING(p_REC.ALERT_CATEGORY);
	v_RET('ALERT_DURATION') := UT.GET_LITERAL_FOR_NUMBER(p_REC.ALERT_DURATION);
	v_RET('IS_EMAIL_ALERT') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_EMAIL_ALERT);
	v_RET('IS_EMAIL_FIRST_ACK') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_EMAIL_FIRST_ACK);
	v_RET('ALERT_EMAIL_PRIORITY') := UT.GET_LITERAL_FOR_NUMBER(p_REC.ALERT_EMAIL_PRIORITY);
	v_RET('ALERT_EMAIL_SUBJECT') := UT.GET_LITERAL_FOR_STRING(p_REC.ALERT_EMAIL_SUBJECT);
	v_RET('ACK_EMAIL_PRIORITY') := UT.GET_LITERAL_FOR_NUMBER(p_REC.ACK_EMAIL_PRIORITY);
	v_RET('ACK_EMAIL_SUBJECT') := UT.GET_LITERAL_FOR_STRING(p_REC.ACK_EMAIL_SUBJECT);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_SYSTEM_ALERT_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION SYSTEM_ALERT_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SYSTEM_ALERT%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_SYSTEM_ALERT_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_SYSTEM_ALERT);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_SYSTEM_ALERT, v_REALMS);
END SYSTEM_ALERT_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_SYSTEM_EVENT_FIELDS_MAP
	(
	p_REC IN SYSTEM_EVENT%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('EVENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.EVENT_ID);
	v_RET('EVENT_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.EVENT_NAME);
	v_RET('EVENT_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.EVENT_ALIAS);
	v_RET('EVENT_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.EVENT_DESC);
	v_RET('EVENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.EVENT_TYPE);
	v_RET('EVENT_CATEGORY') := UT.GET_LITERAL_FOR_STRING(p_REC.EVENT_CATEGORY);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_SYSTEM_EVENT_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION SYSTEM_EVENT_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SYSTEM_EVENT%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_SYSTEM_EVENT_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_SYSTEM_EVENT);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_SYSTEM_EVENT, v_REALMS);
END SYSTEM_EVENT_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_SYSTEM_LOAD_FIELDS_MAP
	(
	p_REC IN SYSTEM_LOAD%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('SYSTEM_LOAD_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SYSTEM_LOAD_ID);
	v_RET('SYSTEM_LOAD_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.SYSTEM_LOAD_NAME);
	v_RET('SYSTEM_LOAD_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.SYSTEM_LOAD_ALIAS);
	v_RET('SYSTEM_LOAD_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.SYSTEM_LOAD_DESC);
	v_RET('SYSTEM_LOAD_INTERVAL') := UT.GET_LITERAL_FOR_STRING(p_REC.SYSTEM_LOAD_INTERVAL);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_SYSTEM_LOAD_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION SYSTEM_LOAD_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SYSTEM_LOAD%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_SYSTEM_LOAD_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_SYSTEM_LOAD);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_SYSTEM_LOAD, v_REALMS);
END SYSTEM_LOAD_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_SYSTEM_REALM_FIELDS_MAP
	(
	p_REC IN SYSTEM_REALM%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('REALM_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.REALM_ID);
	v_RET('REALM_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.REALM_NAME);
	v_RET('REALM_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.REALM_ALIAS);
	v_RET('REALM_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.REALM_DESC);
	v_RET('ENTITY_DOMAIN_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.ENTITY_DOMAIN_ID);
	v_RET('REALM_CALC_TYPE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.REALM_CALC_TYPE);
	v_RET('CUSTOM_QUERY') := UT.GET_LITERAL_FOR_STRING(p_REC.CUSTOM_QUERY);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_SYSTEM_REALM_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION SYSTEM_REALM_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SYSTEM_REALM%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_SYSTEM_REALM_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_SYSTEM_REALM);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_SYSTEM_REALM, v_REALMS);
END SYSTEM_REALM_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_SYSTEM_TABLE_FIELDS_MAP
	(
	p_REC IN SYSTEM_TABLE%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('TABLE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.TABLE_ID);
	v_RET('TABLE_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.TABLE_NAME);
	v_RET('TABLE_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.TABLE_ALIAS);
	v_RET('TABLE_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.TABLE_DESC);
	v_RET('DB_TABLE_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.DB_TABLE_NAME);
	v_RET('MIRROR_TABLE_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.MIRROR_TABLE_NAME);
	v_RET('ENTITY_DOMAIN_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.ENTITY_DOMAIN_ID);
	v_RET('KEY_CONSTRAINT_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.KEY_CONSTRAINT_NAME);
	v_RET('ENTITY_ID_COLUMN_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.ENTITY_ID_COLUMN_NAME);
	v_RET('DATE1_COLUMN_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.DATE1_COLUMN_NAME);
	v_RET('DATE2_COLUMN_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.DATE2_COLUMN_NAME);
	v_RET('IS_REACTIVE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_REACTIVE);
	v_RET('LOCK_SUMMARY_TABLE_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.LOCK_SUMMARY_TABLE_NAME);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_SYSTEM_TABLE_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION SYSTEM_TABLE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN SYSTEM_TABLE%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_SYSTEM_TABLE_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_SYSTEM_TABLE);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_SYSTEM_TABLE, v_REALMS);
END SYSTEM_TABLE_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_TEMPLATE_FIELDS_MAP
	(
	p_REC IN TEMPLATE%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('TEMPLATE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.TEMPLATE_ID);
	v_RET('TEMPLATE_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.TEMPLATE_NAME);
	v_RET('TEMPLATE_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.TEMPLATE_ALIAS);
	v_RET('TEMPLATE_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.TEMPLATE_DESC);
	v_RET('IS_DAY_TYPE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_DAY_TYPE);
	v_RET('IS_DST_OBSERVANT') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_DST_OBSERVANT);
	v_RET('VALIDATION_MESSAGE') := UT.GET_LITERAL_FOR_STRING(p_REC.VALIDATION_MESSAGE);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_TEMPLATE_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION TEMPLATE_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN TEMPLATE%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_TEMPLATE_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_TEMPLATE);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_TEMPLATE, v_REALMS);
END TEMPLATE_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_TP_FIELDS_MAP
	(
	p_REC IN TRANSMISSION_PROVIDER%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('TP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.TP_ID);
	v_RET('TP_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.TP_NAME);
	v_RET('TP_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.TP_ALIAS);
	v_RET('TP_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.TP_DESC);
	v_RET('TP_NERC_CODE') := UT.GET_LITERAL_FOR_STRING(p_REC.TP_NERC_CODE);
	v_RET('TP_STATUS') := UT.GET_LITERAL_FOR_STRING(p_REC.TP_STATUS);
	v_RET('TP_DUNS_NUMBER') := UT.GET_LITERAL_FOR_STRING(p_REC.TP_DUNS_NUMBER);
	v_RET('OASIS_NODE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.OASIS_NODE_ID);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_TP_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION TP_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN TRANSMISSION_PROVIDER%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_TP_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_TP);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_TP, v_REALMS);
END TP_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_TRANSACTION_FIELDS_MAP
	(
	p_REC IN INTERCHANGE_TRANSACTION%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('TRANSACTION_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.TRANSACTION_ID);
	v_RET('TRANSACTION_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.TRANSACTION_NAME);
	v_RET('TRANSACTION_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.TRANSACTION_ALIAS);
	v_RET('TRANSACTION_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.TRANSACTION_DESC);
	v_RET('TRANSACTION_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.TRANSACTION_TYPE);
	v_RET('TRANSACTION_CODE') := UT.GET_LITERAL_FOR_STRING(p_REC.TRANSACTION_CODE);
	v_RET('TRANSACTION_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_REC.TRANSACTION_IDENTIFIER);
	v_RET('IS_FIRM') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_FIRM);
	v_RET('IS_IMPORT_SCHEDULE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_IMPORT_SCHEDULE);
	v_RET('IS_EXPORT_SCHEDULE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_EXPORT_SCHEDULE);
	v_RET('IS_BALANCE_TRANSACTION') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_BALANCE_TRANSACTION);
	v_RET('IS_BID_OFFER') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_BID_OFFER);
	v_RET('IS_EXCLUDE_FROM_POSITION') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_EXCLUDE_FROM_POSITION);
	v_RET('IS_IMPORT_EXPORT') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_IMPORT_EXPORT);
	v_RET('IS_DISPATCHABLE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_DISPATCHABLE);
	v_RET('TRANSACTION_INTERVAL') := UT.GET_LITERAL_FOR_STRING(p_REC.TRANSACTION_INTERVAL);
	v_RET('EXTERNAL_INTERVAL') := UT.GET_LITERAL_FOR_STRING(p_REC.EXTERNAL_INTERVAL);
	v_RET('ETAG_CODE') := UT.GET_LITERAL_FOR_STRING(p_REC.ETAG_CODE);
	v_RET('BEGIN_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.BEGIN_DATE);
	v_RET('END_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.END_DATE);
	v_RET('PURCHASER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PURCHASER_ID);
	v_RET('SELLER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SELLER_ID);
	v_RET('CONTRACT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.CONTRACT_ID);
	v_RET('SC_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SC_ID);
	v_RET('POR_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.POR_ID);
	v_RET('POD_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.POD_ID);
	v_RET('COMMODITY_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.COMMODITY_ID);
	v_RET('SERVICE_TYPE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SERVICE_TYPE_ID);
	v_RET('TX_TRANSACTION_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.TX_TRANSACTION_ID);
	v_RET('PATH_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PATH_ID);
	v_RET('LINK_TRANSACTION_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.LINK_TRANSACTION_ID);
	v_RET('EDC_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.EDC_ID);
	v_RET('PSE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PSE_ID);
	v_RET('ESP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.ESP_ID);
	v_RET('POOL_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.POOL_ID);
	v_RET('SCHEDULE_GROUP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SCHEDULE_GROUP_ID);
	v_RET('MARKET_PRICE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.MARKET_PRICE_ID);
	v_RET('ZOR_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.ZOR_ID);
	v_RET('ZOD_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.ZOD_ID);
	v_RET('SOURCE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SOURCE_ID);
	v_RET('SINK_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SINK_ID);
	v_RET('RESOURCE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.RESOURCE_ID);
	v_RET('AGREEMENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.AGREEMENT_TYPE);
	v_RET('APPROVAL_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.APPROVAL_TYPE);
	v_RET('LOSS_OPTION') := UT.GET_LITERAL_FOR_STRING(p_REC.LOSS_OPTION);
	v_RET('TRAIT_CATEGORY') := UT.GET_LITERAL_FOR_STRING(p_REC.TRAIT_CATEGORY);
	v_RET('TP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.TP_ID);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_TRANSACTION_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION TRANSACTION_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN INTERCHANGE_TRANSACTION%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_TRANSACTION_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_TRANSACTION);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_TRANSACTION, v_REALMS);
END TRANSACTION_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_TRANSACTION_TRAIT_GROUP_FI
	(
	p_REC IN TRANSACTION_TRAIT_GROUP%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('TRAIT_GROUP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.TRAIT_GROUP_ID);
	v_RET('TRAIT_GROUP_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.TRAIT_GROUP_NAME);
	v_RET('TRAIT_GROUP_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.TRAIT_GROUP_ALIAS);
	v_RET('TRAIT_GROUP_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.TRAIT_GROUP_DESC);
	v_RET('TRAIT_GROUP_INTERVAL') := UT.GET_LITERAL_FOR_STRING(p_REC.TRAIT_GROUP_INTERVAL);
	v_RET('TRAIT_GROUP_TYPE') := UT.GET_LITERAL_FOR_STRING(p_REC.TRAIT_GROUP_TYPE);
	v_RET('SC_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SC_ID);
	v_RET('TRAIT_CATEGORY') := UT.GET_LITERAL_FOR_STRING(p_REC.TRAIT_CATEGORY);
	v_RET('DISPLAY_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.DISPLAY_NAME);
	v_RET('DISPLAY_ORDER') := UT.GET_LITERAL_FOR_NUMBER(p_REC.DISPLAY_ORDER);
	v_RET('IS_SERIES') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_SERIES);
	v_RET('IS_SPARSE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_SPARSE);
	v_RET('IS_STATEMENT_TYPE_SPECIFIC') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_STATEMENT_TYPE_SPECIFIC);
	v_RET('DEFAULT_NUMBER_OF_SETS') := UT.GET_LITERAL_FOR_NUMBER(p_REC.DEFAULT_NUMBER_OF_SETS);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_TRANSACTION_TRAIT_GROUP_FI;
---------------------------------------------------------------------
FUNCTION TRANSACTION_TRAIT_GROUP_IS_ALL
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN TRANSACTION_TRAIT_GROUP%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_TRANSACTION_TRAIT_GROUP_FI(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_TRANSACTION_TRAIT_GROUP);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_TRANSACTION_TRAIT_GROUP, v_REALMS);
END TRANSACTION_TRAIT_GROUP_IS_ALL;
---------------------------------------------------------------------
FUNCTION GET_TX_FEEDER_FIELDS_MAP
	(
	p_REC IN TX_FEEDER%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('FEEDER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.FEEDER_ID);
	v_RET('FEEDER_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.FEEDER_NAME);
	v_RET('FEEDER_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.FEEDER_ALIAS);
	v_RET('FEEDER_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.FEEDER_DESC);
	v_RET('EXTERNAL_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_REC.EXTERNAL_IDENTIFIER);
	v_RET('SUB_STATION_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SUB_STATION_ID);
	v_RET('BEGIN_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.BEGIN_DATE);
	v_RET('END_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.END_DATE);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_TX_FEEDER_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION TX_FEEDER_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN TX_FEEDER%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_TX_FEEDER_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_TX_FEEDER);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_TX_FEEDER, v_REALMS);
END TX_FEEDER_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_TX_FEEDER_SEGMENT_FIELDS_M
	(
	p_REC IN TX_FEEDER_SEGMENT%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('FEEDER_SEGMENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.FEEDER_SEGMENT_ID);
	v_RET('FEEDER_SEGMENT_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.FEEDER_SEGMENT_NAME);
	v_RET('FEEDER_SEGMENT_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.FEEDER_SEGMENT_ALIAS);
	v_RET('FEEDER_SEGMENT_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.FEEDER_SEGMENT_DESC);
	v_RET('EXTERNAL_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_REC.EXTERNAL_IDENTIFIER);
	v_RET('FEEDER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.FEEDER_ID);
	v_RET('BEGIN_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.BEGIN_DATE);
	v_RET('END_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.END_DATE);
	v_RET('PRIORITY') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PRIORITY);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_TX_FEEDER_SEGMENT_FIELDS_M;
---------------------------------------------------------------------
FUNCTION TX_FEEDER_SEGMENT_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN TX_FEEDER_SEGMENT%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_TX_FEEDER_SEGMENT_FIELDS_M(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_TX_FEEDER_SEGMENT);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_TX_FEEDER_SEGMENT, v_REALMS);
END TX_FEEDER_SEGMENT_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_USAGE_WRF_FIELDS_MAP
	(
	p_REC IN USAGE_WRF%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('WRF_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.WRF_ID);
	v_RET('WRF_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.WRF_NAME);
	v_RET('WRF_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.WRF_ALIAS);
	v_RET('WRF_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.WRF_DESC);
	v_RET('STATION_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.STATION_ID);
	v_RET('PARAMETER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PARAMETER_ID);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_USAGE_WRF_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION GET_VPP_FIELDS_MAP
	(
	p_REC IN VIRTUAL_POWER_PLANT%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('VPP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.VPP_ID);
	v_RET('VPP_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.VPP_NAME);
	v_RET('VPP_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.VPP_ALIAS);
	v_RET('VPP_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.VPP_DESC);
	v_RET('EXTERNAL_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_REC.EXTERNAL_IDENTIFIER);
	v_RET('STATUS_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.STATUS_NAME);
	v_RET('SERVICE_ZONE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.SERVICE_ZONE_ID);
	v_RET('PROGRAM_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PROGRAM_ID);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_VPP_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION VPP_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN VIRTUAL_POWER_PLANT%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_VPP_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_VPP);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_VPP, v_REALMS);
END VPP_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_WEATHER_PARAMETER_FIELDS_M
	(
	p_REC IN WEATHER_PARAMETER%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('PARAMETER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.PARAMETER_ID);
	v_RET('PARAMETER_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.PARAMETER_NAME);
	v_RET('PARAMETER_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.PARAMETER_ALIAS);
	v_RET('PARAMETER_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.PARAMETER_DESC);
	v_RET('PARAMETER_CATEGORY') := UT.GET_LITERAL_FOR_STRING(p_REC.PARAMETER_CATEGORY);
	v_RET('PARAMETER_INTERVAL') := UT.GET_LITERAL_FOR_STRING(p_REC.PARAMETER_INTERVAL);
	v_RET('PARAMETER_MEASUREMENT') := UT.GET_LITERAL_FOR_STRING(p_REC.PARAMETER_MEASUREMENT);
	v_RET('PROJECTION_PERIOD') := UT.GET_LITERAL_FOR_STRING(p_REC.PROJECTION_PERIOD);
	v_RET('IS_COMPOSITE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_COMPOSITE);
	v_RET('IS_CALCULATE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_CALCULATE);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_WEATHER_PARAMETER_FIELDS_M;
---------------------------------------------------------------------
FUNCTION WEATHER_PARAMETER_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN WEATHER_PARAMETER%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_WEATHER_PARAMETER_FIELDS_M(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_WEATHER_PARAMETER);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_WEATHER_PARAMETER, v_REALMS);
END WEATHER_PARAMETER_IS_ALLOWED;
---------------------------------------------------------------------
FUNCTION GET_WEATHER_STATION_FIELDS_MAP
	(
	p_REC IN WEATHER_STATION%ROWTYPE
	) RETURN UT.STRING_MAP IS
-- Answer a map (table of varchar2 index by varchar2) whose keys
-- are column names and whose values are PL/SQL literal representations
v_RET UT.STRING_MAP;
BEGIN
	v_RET('STATION_ID') := UT.GET_LITERAL_FOR_NUMBER(p_REC.STATION_ID);
	v_RET('STATION_NAME') := UT.GET_LITERAL_FOR_STRING(p_REC.STATION_NAME);
	v_RET('STATION_ALIAS') := UT.GET_LITERAL_FOR_STRING(p_REC.STATION_ALIAS);
	v_RET('STATION_DESC') := UT.GET_LITERAL_FOR_STRING(p_REC.STATION_DESC);
	v_RET('TIME_ZONE') := UT.GET_LITERAL_FOR_STRING(p_REC.TIME_ZONE);
	v_RET('IS_COMPOSITE') := UT.GET_LITERAL_FOR_NUMBER(p_REC.IS_COMPOSITE);
	v_RET('ENTRY_DATE') := UT.GET_LITERAL_FOR_DATE(p_REC.ENTRY_DATE);
    
	RETURN v_RET;
END GET_WEATHER_STATION_FIELDS_MAP;
---------------------------------------------------------------------
FUNCTION WEATHER_STATION_IS_ALLOWED
	(
	p_ACTION_NAME IN VARCHAR2,
	p_REC IN WEATHER_STATION%ROWTYPE
	) RETURN BOOLEAN IS
v_MAP UT.STRING_MAP;
v_REALMS ID_TABLE;
BEGIN
	v_MAP := GET_WEATHER_STATION_FIELDS_MAP(p_REC);
	v_REALMS := SD.GET_REALMS_FOR_ENTITY_FIELDS(v_MAP, EC.ED_WEATHER_STATION);
	RETURN SD.IS_ALLOWED_FOR_REALMS(p_ACTION_NAME, EC.ED_WEATHER_STATION, v_REALMS);
END WEATHER_STATION_IS_ALLOWED;
---------------------------------------------------------------------
END IO_UTIL;
/
