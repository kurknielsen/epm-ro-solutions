CREATE OR REPLACE PACKAGE BODY POPULATE_SYSTEM_DATE_TIME IS
---------------------------------------------------------------------------------------------------

--==========================================
--	CONSTANTS -- DO NOT CHANGE
--==========================================
c_TIME_YYYY_MM_DD VARCHAR2(32) := 'HH24:MI';
c_DATE_YYYY_MM_DD VARCHAR2(16) := 'YYYY-MM-DD';
c_WEEKEND_YYYY_MM_DD VARCHAR2(16) := ' WE ';
c_WEEKDAY_YYYY_MM_DD VARCHAR2(16) := ' WD ';
c_DAYLIGHT_SUFFIX CHAR(1) := 'd';
c_STANDARD_SUFFIX CHAR(1) := 's';

c_SECOND NUMBER := 1/86400;

--DAY TYPES
c_DAYTYPE_STANDARD CHAR(1) := GA.STANDARD;
c_DAYTYPE_WEEKDAY CHAR(1) := GA.WEEK_DAY;
c_DAYTYPE_WEEKEND CHAR(1) := GA.WEEK_END;

--SCENARIO ROLLUP TYPES
c_ROLLUP_HOURLY NUMBER(1) := 0;
c_ROLLUP_DAILY NUMBER(1) := 1;
c_ROLLUP_WEEKLY NUMBER(1) := 2;
c_ROLLUP_MONTHLY NUMBER(1) := 3;

--DATA INTERVAL TYPES
c_DATA_HOURLY NUMBER(1) := 1;
c_DATA_DAILY NUMBER(1) := 2;

--==========================================
--	PACKAGE VARIABLES -- Initialized below
--==========================================
g_FISCAL_YEAR_END_DATE DATE;
g_TIME_CUSTOM_FORMAT VARCHAR2(32);
g_DATE_CUSTOM_FORMAT VARCHAR2(32);
g_WEEKEND_CUSTOM_FORMAT VARCHAR2(32);
g_WEEKDAY_CUSTOM_FORMAT VARCHAR2(32);
g_MINIMUM_INTERVAL VARCHAR2(16);

g_INTERVAL_TYPES STRING_COLLECTION := STRING_COLLECTION(DATE_UTIL.c_NAME_HOUR, DATE_UTIL.c_NAME_30MIN, DATE_UTIL.c_NAME_15MIN, DATE_UTIL.c_NAME_10MIN, DATE_UTIl.c_NAME_5MIN);

c_DST_INTV_MAP_ACTION_NONE BINARY_INTEGER := 0;
c_DST_INTV_MAP_ACTION_DROP BINARY_INTEGER := 1;
c_DST_INTV_MAP_ACTION_EXPAND BINARY_INTEGER := 2;

c_DROP_EXPAND_SINGLE_INTERVAL BINARY_INTEGER := 1;
c_DROP_EXPAND_DOUBLE_INTERVAL BINARY_INTEGER := 2;

---------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR2 IS
BEGIN
    RETURN '$Revision: 1.4 $';
END WHAT_VERSION;
---------------------------------------------------------------------------------------------------
PROCEDURE POPULATE_DST_TYPE AS

	v_CURR_DATE DATE;
	v_END_DATE DATE;

	v_FB_DAY DATE;
	v_SA_DAY DATE;
	v_NEXT_FB_DAY DATE;


	v_BEGIN_WINDOW NUMBER(2);
	v_END_WINDOW NUMBER(2);

BEGIN

	BEGIN
		v_BEGIN_WINDOW := TO_NUMBER( GET_DICTIONARY_VALUE('Past Window',
															CONSTANTS.GLOBAL_MODEL,
															'System',
															'Fill DST Type',
															CONSTANTS.UNDEFINED_ATTRIBUTE) );
	EXCEPTION
		WHEN VALUE_ERROR THEN
			v_BEGIN_WINDOW := NULL;
	END;

	BEGIN
		v_END_WINDOW := TO_NUMBER( GET_DICTIONARY_VALUE('Future Window',
															CONSTANTS.GLOBAL_MODEL,
															'System',
															'Fill DST Type',
															CONSTANTS.UNDEFINED_ATTRIBUTE) );
	EXCEPTION
		WHEN VALUE_ERROR THEN
			v_END_WINDOW := NULL;
	END;

	-- START JAN 1ST, 30 YEARS INTO THE PAST BY DEFAULT
	IF v_BEGIN_WINDOW IS NULL THEN
		v_BEGIN_WINDOW := 30;
	END IF;

	-- END JAN 1ST, 30 YEARS INTO THE FUTURE BY DEFAULT
	IF v_END_WINDOW IS NULL THEN
		v_END_WINDOW := 30;
	END IF;

    v_CURR_DATE := TO_DATE((TO_NUMBER(TO_CHAR(SYSDATE, 'YYYY')) - v_BEGIN_WINDOW) || '-01-01', 'YYYY-MM-DD');
	v_END_DATE := TO_DATE((TO_NUMBER(TO_CHAR(SYSDATE, 'YYYY')) + v_END_WINDOW) || '-01-01', 'YYYY-MM-DD');

	-- CLEAR OUT DST_TYPE FIRST
	DELETE FROM DST_TYPE;

	WHILE v_CURR_DATE <= v_END_DATE LOOP

		v_FB_DAY := TRUNC(DST_FALL_BACK_DATE(v_CURR_DATE - 1));
		v_SA_DAY := TRUNC(DST_SPRING_AHEAD_DATE(v_CURR_DATE));
		v_NEXT_FB_DAY := TRUNC(DST_FALL_BACK_DATE(v_CURR_DATE));

		-- INSERT FALL BACK DAY FOR LAST YEAR
		INSERT INTO DST_TYPE (DST_TYPE, BEGIN_DATE, END_DATE)
		VALUES (CONSTANTS.DST_TYPE_FALL_BACK, v_FB_DAY, v_FB_DAY);

		-- INSERT STANDARD TIME PERIOD
		INSERT INTO DST_TYPE (DST_TYPE, BEGIN_DATE, END_DATE)
		VALUES (CONSTANTS.DST_TYPE_NONE, v_FB_DAY + 1, v_SA_DAY - 1);

		-- INSERT SPRING AHEAD DAY FOR THIS YEAR
		INSERT INTO DST_TYPE (DST_TYPE, BEGIN_DATE, END_DATE)
		VALUES (CONSTANTS.DST_TYPE_SPRING_AHEAD, v_SA_DAY, v_SA_DAY);

		-- INSERT SPRING AHEAD DAY FOR THIS YEAR
		INSERT INTO DST_TYPE (DST_TYPE, BEGIN_DATE, END_DATE)
		VALUES (CONSTANTS.DST_TYPE_DST_PERIOD, v_SA_DAY+1, v_NEXT_FB_DAY - 1);

		v_CURR_DATE := ADD_MONTHS(v_CURR_DATE, 12);
	END LOOP;

END POPULATE_DST_TYPE;
---------------------------------------------------------------------------------------------------
PROCEDURE INSERT_SYSTEM_DATE_TIME
	(
	p_TIME_ZONE IN VARCHAR2,
	p_DATA_INTERVAL_TYPE IN NUMBER,
	p_DAY_TYPE IN CHAR,
	p_CUT_DATE IN DATE,
	p_LOCAL_DATE IN DATE,
	p_STANDARD_DATE IN DATE,
	p_CUT_DATE_SCHEDULING IN DATE,
	p_MINIMUM_INTERVAL_NUMBER IN NUMBER,
	p_CUT_MINUTE IN NUMBER,
	p_CUT_HOUR IN NUMBER,
	p_CUT_DAY_IN_WEEK IN NUMBER,
	p_CUT_DAY_ABBR IN VARCHAR2,
	p_CUT_DAY_IN_MONTH IN NUMBER,
	p_CUT_WEEK_IN_YEAR IN NUMBER,
	p_CUT_MONTH IN NUMBER,
	p_CUT_QUARTER IN NUMBER,
	p_CUT_YEAR IN NUMBER,
	p_CUT_FISCAL_YEAR IN NUMBER,
	p_LOCAL_HOUR_TRUNC_DATE IN DATE,
	p_LOCAL_DAY_TRUNC_DATE IN DATE,
	p_LOCAL_WEEK_TRUNC_DATE IN DATE,
	p_LOCAL_MONTH_TRUNC_DATE IN DATE,
	p_LOCAL_QUARTER_TRUNC_DATE IN DATE,
	p_LOCAL_YEAR_TRUNC_DATE IN DATE,
	p_LOCAL_FISCAL_YEAR_TRUNC_DATE IN DATE,
	p_NO_ROLLUP_YYYY_MM_DD IN VARCHAR2,
	p_MI15_YYYY_MM_DD IN VARCHAR2,
	p_MI30_YYYY_MM_DD IN VARCHAR2,
	p_HOUR_YYYY_MM_DD IN VARCHAR2,
	p_DAY_YYYY_MM_DD IN VARCHAR2,
	p_WEEK_YYYY_MM_DD IN VARCHAR2,
	p_MONTH_YYYY_MM_DD IN VARCHAR2,
	p_QUARTER_YYYY_MM_DD IN VARCHAR2,
	p_YEAR_YYYY_MM_DD IN VARCHAR2,
	p_FISCAL_YEAR_YYYY_MM_DD IN VARCHAR2,
	p_NO_ROLLUP_CUSTOM_STRING IN VARCHAR2,
	p_HOUR_CUSTOM_STRING IN VARCHAR2,
	p_DAY_CUSTOM_STRING IN VARCHAR2,
	p_WEEK_CUSTOM_STRING IN VARCHAR2,
	p_MONTH_CUSTOM_STRING IN VARCHAR2,
	p_QUARTER_CUSTOM_STRING IN VARCHAR2,
	p_YEAR_CUSTOM_STRING IN VARCHAR2,
	p_FISCAL_YEAR_CUSTOM_STRING IN VARCHAR2,
	p_IS_IN_DST_RANGE IN NUMBER,
	p_IS_DST_SPRING_AHEAD_HOUR IN NUMBER,
	p_IS_DST_SPRING_AHEAD_DAY IN NUMBER,
	p_IS_DST_FALL_BACK_HOUR IN NUMBER,
	p_IS_DST_FALL_BACK_DAY IN NUMBER,
	p_IS_ON_PEAK IN NUMBER
	) IS
BEGIN

	INSERT INTO SYSTEM_DATE_TIME(TIME_ZONE, DATA_INTERVAL_TYPE, DAY_TYPE, CUT_DATE, LOCAL_DATE, STANDARD_DATE, CUT_DATE_SCHEDULING, MINIMUM_INTERVAL_NUMBER, CUT_MINUTE, CUT_HOUR, CUT_DAY_IN_WEEK, CUT_DAY_ABBR, CUT_DAY_IN_MONTH, CUT_WEEK_IN_YEAR, CUT_MONTH, CUT_QUARTER, CUT_YEAR, CUT_FISCAL_YEAR, LOCAL_HOUR_TRUNC_DATE, LOCAL_DAY_TRUNC_DATE, LOCAL_WEEK_TRUNC_DATE, LOCAL_MONTH_TRUNC_DATE, LOCAL_QUARTER_TRUNC_DATE, LOCAL_YEAR_TRUNC_DATE, LOCAL_FISCAL_YEAR_TRUNC_DATE, NO_ROLLUP_YYYY_MM_DD, MI15_YYYY_MM_DD, MI30_YYYY_MM_DD, HOUR_YYYY_MM_DD, DAY_YYYY_MM_DD, WEEK_YYYY_MM_DD, MONTH_YYYY_MM_DD, QUARTER_YYYY_MM_DD, YEAR_YYYY_MM_DD, FISCAL_YEAR_YYYY_MM_DD, NO_ROLLUP_CUSTOM_STRING, HOUR_CUSTOM_STRING, DAY_CUSTOM_STRING, WEEK_CUSTOM_STRING, MONTH_CUSTOM_STRING, QUARTER_CUSTOM_STRING, YEAR_CUSTOM_STRING, FISCAL_YEAR_CUSTOM_STRING, IS_IN_DST_RANGE, IS_DST_SPRING_AHEAD_HOUR, IS_DST_SPRING_AHEAD_DAY, IS_DST_FALL_BACK_HOUR, IS_DST_FALL_BACK_DAY, IS_ON_PEAK)
	VALUES(p_TIME_ZONE, p_DATA_INTERVAL_TYPE, p_DAY_TYPE, p_CUT_DATE, p_LOCAL_DATE, p_STANDARD_DATE, p_CUT_DATE_SCHEDULING, p_MINIMUM_INTERVAL_NUMBER, p_CUT_MINUTE, p_CUT_HOUR, p_CUT_DAY_IN_WEEK, p_CUT_DAY_ABBR, p_CUT_DAY_IN_MONTH, p_CUT_WEEK_IN_YEAR, p_CUT_MONTH, p_CUT_QUARTER, p_CUT_YEAR, p_CUT_FISCAL_YEAR, p_LOCAL_HOUR_TRUNC_DATE, p_LOCAL_DAY_TRUNC_DATE, p_LOCAL_WEEK_TRUNC_DATE, p_LOCAL_MONTH_TRUNC_DATE, p_LOCAL_QUARTER_TRUNC_DATE, p_LOCAL_YEAR_TRUNC_DATE, p_LOCAL_FISCAL_YEAR_TRUNC_DATE, p_NO_ROLLUP_YYYY_MM_DD, p_MI15_YYYY_MM_DD, p_MI30_YYYY_MM_DD,p_HOUR_YYYY_MM_DD, p_DAY_YYYY_MM_DD, p_WEEK_YYYY_MM_DD, p_MONTH_YYYY_MM_DD, p_QUARTER_YYYY_MM_DD, p_YEAR_YYYY_MM_DD, p_FISCAL_YEAR_YYYY_MM_DD, p_NO_ROLLUP_CUSTOM_STRING, p_HOUR_CUSTOM_STRING, p_DAY_CUSTOM_STRING, p_WEEK_CUSTOM_STRING, p_MONTH_CUSTOM_STRING, p_QUARTER_CUSTOM_STRING, p_YEAR_CUSTOM_STRING, p_FISCAL_YEAR_CUSTOM_STRING, p_IS_IN_DST_RANGE, p_IS_DST_SPRING_AHEAD_HOUR, p_IS_DST_SPRING_AHEAD_DAY, p_IS_DST_FALL_BACK_HOUR, p_IS_DST_FALL_BACK_DAY, p_IS_ON_PEAK);

END INSERT_SYSTEM_DATE_TIME;
---------------------------------------------------------------------------------------------------
FUNCTION GET_FISCAL_YEAR_DATE
	(
	p_DATE IN DATE
	) RETURN DATE IS
BEGIN
	--IF WE ARE STILL WITHIN THE FISCAL YEAR, DO NOT ADD A YEAR.
	IF TO_CHAR(p_DATE,'MMDD') <= TO_CHAR(g_FISCAL_YEAR_END_DATE,'MMDD') THEN
		RETURN p_DATE;
	--IF WE ARE IN THE NEXT FISCAL YEAR, ADD A YEAR.
	ELSE
		RETURN ADD_MONTHS(p_DATE, 12);
	END IF;
END GET_FISCAL_YEAR_DATE;
---------------------------------------------------------------------------------------------------
FUNCTION GET_MINIMUM_INTERVAL_NUMBER
	(
	p_DATE IN DATE
	) RETURN NUMBER IS
	v_MINIMUM_INTERVAL NUMBER(2);
	v_MINUTES NUMBER(2) := TO_NUMBER(TO_CHAR(p_DATE, 'MI'));
BEGIN

	IF TRUNC(p_DATE, 'YY') = p_DATE THEN
		v_MINIMUM_INTERVAL := GET_INTERVAL_NUMBER('YY');
	ELSIF TRUNC(p_DATE, 'Q') = p_DATE THEN
		v_MINIMUM_INTERVAL := GET_INTERVAL_NUMBER('Q');
	ELSIF TRUNC(p_DATE, 'MM') = p_DATE THEN
		v_MINIMUM_INTERVAL := GET_INTERVAL_NUMBER('MM');
	ELSIF TRUNC(p_DATE, 'DY') = p_DATE THEN
		v_MINIMUM_INTERVAL := GET_INTERVAL_NUMBER('DY');
	ELSIF TRUNC(p_DATE, 'DD') = p_DATE THEN
		v_MINIMUM_INTERVAL := GET_INTERVAL_NUMBER('DD');
	ELSIF v_MINUTES = 0 THEN
		v_MINIMUM_INTERVAL := GET_INTERVAL_NUMBER('HH');
	ELSIF v_MINUTES = 30 THEN
		v_MINIMUM_INTERVAL := GET_INTERVAL_NUMBER('MI30');
	ELSIF v_MINUTES IN (15, 45) THEN
		v_MINIMUM_INTERVAL := GET_INTERVAL_NUMBER('MI15');
	ELSIF MOD(v_MINUTES, 10) = 0 THEN
		v_MINIMUM_INTERVAL := GET_INTERVAL_NUMBER('MI10');
	ELSE
		v_MINIMUM_INTERVAL := GET_INTERVAL_NUMBER('MI5');
	END IF;

	RETURN v_MINIMUM_INTERVAL;

END GET_MINIMUM_INTERVAL_NUMBER;
---------------------------------------------------------------------------------------------------
PROCEDURE ADD_DAILY_ROW
	(
	p_TIME_ZONE IN VARCHAR2,
	p_DATE IN DATE
	) IS

	v_LOCAL_DATE DATE;
	v_FISCAL_YEAR_DATE DATE;

	--======================================================================================
	FUNCTION GET_DAILY_FORMATTED_DATE
		(
		p_DATE IN DATE,
		p_INTERVAL IN VARCHAR2,
		p_DATE_FORMAT IN VARCHAR2
		) RETURN VARCHAR2 IS
	BEGIN
		RETURN TO_CHAR(TRUNC(p_DATE, p_INTERVAL),p_DATE_FORMAT);
	END GET_DAILY_FORMATTED_DATE;
	--======================================================================================

BEGIN
	v_LOCAL_DATE := p_DATE;
	v_FISCAL_YEAR_DATE := GET_FISCAL_YEAR_DATE(p_DATE);
	INSERT_SYSTEM_DATE_TIME(p_TIME_ZONE, -- TIME_ZONE
		c_DATA_DAILY, 				-- DATA_INTERVAL_TYPE
		c_DAYTYPE_STANDARD, 			-- DAY_TYPE
		v_LOCAL_DATE, -- CUT_DATE
		v_LOCAL_DATE, -- LOCAL_DATE
		v_LOCAL_DATE, -- STANDARD_DATE
		v_LOCAL_DATE + 1/86400,	-- CUT_DATE_SCHEDULING
		GET_MINIMUM_INTERVAL_NUMBER(v_LOCAL_DATE),	--MINIMUM_INTERVAL_NUMBER
		TO_NUMBER(TO_CHAR(p_DATE,'MI')), 	-- CUT_MINUTE
		TO_NUMBER(TO_CHAR(p_DATE,'HH24')), 	-- CUT_HOUR
		TO_NUMBER(TO_CHAR(p_DATE,'D')), 	-- CUT_DAY_IN_WEEK
		TO_CHAR(p_DATE,'DY'), 				-- CUT_DAY_ABBR
		TO_NUMBER(TO_CHAR(p_DATE,'DD')), 	-- CUT_DAY_IN_MONTH
		TO_NUMBER(TO_CHAR(p_DATE,'WW')), 	-- CUT_WEEK
		TO_NUMBER(TO_CHAR(p_DATE,'MM')), 	-- CUT_MONTH
		TO_NUMBER(TO_CHAR(p_DATE,'Q')), 	-- CUT_QUARTER
		TO_NUMBER(TO_CHAR(p_DATE,'YYYY')), 	-- CUT_YEAR
		TO_NUMBER(TO_CHAR(v_FISCAL_YEAR_DATE,'YYYY')), 	-- CUT_FISCAL_YEAR
		TRUNC(v_LOCAL_DATE, 'HH'), -- LOCAL_HOUR_TRUNC_DATE
		TRUNC(v_LOCAL_DATE, 'DD'), -- LOCAL_DAY_TRUNC_DATE
		TRUNC(v_LOCAL_DATE, 'DY'), -- LOCAL_WEEK_TRUNC_DATE
		TRUNC(v_LOCAL_DATE, 'MM'), -- LOCAL_MONTH_TRUNC_DATE
		TRUNC(v_LOCAL_DATE, 'Q'),  -- LOCAL_QUARTER_TRUNC_DATE
		TRUNC(v_LOCAL_DATE, 'YY'), -- LOCAL_YEAR_TRUNC_DATE
		TRUNC(v_FISCAL_YEAR_DATE, 'YY'), -- LOCAL_FISCAL_YEAR_TRUNC_DATE
		GET_DAILY_FORMATTED_DATE(p_DATE,'DD',c_DATE_YYYY_MM_DD), -- p_NO_ROLLUP_YYYY_MM_DD
		GET_DAILY_FORMATTED_DATE(p_DATE,'DD',c_DATE_YYYY_MM_DD), --p_MI15_YYYY_MM_DD
		GET_DAILY_FORMATTED_DATE(p_DATE,'DD',c_DATE_YYYY_MM_DD), --p_MI30_YYYY_MM_DD
		GET_DAILY_FORMATTED_DATE(p_DATE,'DD',c_DATE_YYYY_MM_DD), --p_HOUR_YYYY_MM_DD
		GET_DAILY_FORMATTED_DATE(p_DATE,'DD',c_DATE_YYYY_MM_DD), --p_DAY_YYYY_MM_DD
		GET_DAILY_FORMATTED_DATE(p_DATE,'DY',c_DATE_YYYY_MM_DD),
		GET_DAILY_FORMATTED_DATE(p_DATE,'MM',c_DATE_YYYY_MM_DD),
		GET_DAILY_FORMATTED_DATE(p_DATE,'Q',c_DATE_YYYY_MM_DD),
		GET_DAILY_FORMATTED_DATE(p_DATE,'YY',c_DATE_YYYY_MM_DD),
		GET_DAILY_FORMATTED_DATE(v_FISCAL_YEAR_DATE,'YY',c_DATE_YYYY_MM_DD),
		GET_DAILY_FORMATTED_DATE(p_DATE,'DD',g_DATE_CUSTOM_FORMAT),
		GET_DAILY_FORMATTED_DATE(p_DATE,'DD',g_DATE_CUSTOM_FORMAT),
		GET_DAILY_FORMATTED_DATE(p_DATE,'DD',g_DATE_CUSTOM_FORMAT),
		GET_DAILY_FORMATTED_DATE(p_DATE,'DY',g_DATE_CUSTOM_FORMAT),
		GET_DAILY_FORMATTED_DATE(p_DATE,'MM',g_DATE_CUSTOM_FORMAT),
		GET_DAILY_FORMATTED_DATE(p_DATE,'Q',g_DATE_CUSTOM_FORMAT),
		GET_DAILY_FORMATTED_DATE(p_DATE,'YY',g_DATE_CUSTOM_FORMAT),
		GET_DAILY_FORMATTED_DATE(v_FISCAL_YEAR_DATE,'YY',g_DATE_CUSTOM_FORMAT),
		0,		-- IS_IN_DST_RANGE
		0,		-- IS_DST_SPRING_AHEAD_DAY
		0,		-- IS_DST_SPRING_AHEAD_HOUR
		0,		-- IS_DST_FALL_BACK_DAY
		0,		-- IS_DST_FALL_BACK_HOUR
		0		-- IS_ON_PEAK
		);

END ADD_DAILY_ROW;
---------------------------------------------------------------------------------------------------
PROCEDURE ADD_SCENARIO_MULTIPLIERS
	(
	p_SCENARIO_ROLLUP_TYPE IN NUMBER,
	p_DATE IN DATE
	) IS

	v_WEEKDAY_MULTIPLIER SYSTEM_DATE_TIME_SCENARIO.SCENARIO_MULTIPLIER%TYPE;
	v_WEEKEND_MULTIPLIER SYSTEM_DATE_TIME_SCENARIO.SCENARIO_MULTIPLIER%TYPE;

	--======================================================================================
	PROCEDURE INSERT_SYSTEM_DATE_TIME_SCEN
		(
		p_DAY_TYPE IN CHAR,
		p_ROLLUP_DATE IN DATE,
		p_SCENARIO_ROLLUP_TYPE IN NUMBER,
		p_SCENARIO_MULTIPLIER IN NUMBER
		) IS
	BEGIN
		INSERT INTO SYSTEM_DATE_TIME_SCENARIO(DAY_TYPE, ROLLUP_DATE, SCENARIO_ROLLUP_TYPE, SCENARIO_MULTIPLIER)
		VALUES(p_DAY_TYPE, p_ROLLUP_DATE, p_SCENARIO_ROLLUP_TYPE, p_SCENARIO_MULTIPLIER);
	END INSERT_SYSTEM_DATE_TIME_SCEN;
	--======================================================================================
BEGIN


	--HOURLY OR DAILY MODE.  JUST MULTIPLY BY 1 FOR JOINS.
	IF p_SCENARIO_ROLLUP_TYPE IN (c_ROLLUP_HOURLY, c_ROLLUP_DAILY) THEN
		INSERT_SYSTEM_DATE_TIME_SCEN(c_DAYTYPE_STANDARD, p_DATE, p_SCENARIO_ROLLUP_TYPE, 1);
	ELSE
		--WEEKLY MODE.  NOT SURE WHAT TO MULTIPLY BY FOR NOW. NEEDS TO BE FIXED LATER.
		IF p_SCENARIO_ROLLUP_TYPE = c_ROLLUP_WEEKLY THEN
			v_WEEKDAY_MULTIPLIER := 0;
			v_WEEKEND_MULTIPLIER := 0;
		--MONTHLY MODE.  MULTIPLY BY NUMBER OF DAYTYPE IN MONTH.
		ELSIF p_SCENARIO_ROLLUP_TYPE = c_ROLLUP_MONTHLY THEN
			v_WEEKDAY_MULTIPLIER := WEEK_DAYS_IN_RANGE(p_DATE, LAST_DAY(p_DATE));
			v_WEEKEND_MULTIPLIER := LAST_DAY(p_DATE) - p_DATE - v_WEEKDAY_MULTIPLIER + 1;
		END IF;

		INSERT_SYSTEM_DATE_TIME_SCEN(c_DAYTYPE_WEEKDAY, p_DATE, p_SCENARIO_ROLLUP_TYPE, v_WEEKDAY_MULTIPLIER);
		INSERT_SYSTEM_DATE_TIME_SCEN(c_DAYTYPE_WEEKEND, p_DATE, p_SCENARIO_ROLLUP_TYPE, v_WEEKEND_MULTIPLIER);
	END IF;

END ADD_SCENARIO_MULTIPLIERS;
---------------------------------------------------------------------------------------------------
PROCEDURE ADD_HOURLY_ROW
	(
	p_TIME_ZONE IN VARCHAR2,
	p_DAY_TYPE IN CHAR,
	p_DATE IN DATE,
	p_EDC_ID IN NUMBER
	) IS

	v_LOCAL_DATE				DATE;
	v_STANDARD_DATE				DATE;
	v_DST_SPRING_AHEAD_DATE 	DATE;
	v_DST_FALL_BACK_DATE 		DATE;
	v_IS_IN_DST_RANGE 			NUMBER(1);
	v_IS_DST_SPRING_AHEAD_HOUR	NUMBER(1);
	v_IS_DST_SPRING_AHEAD_DAY	NUMBER(1);
	v_IS_DST_FALL_BACK_HOUR		NUMBER(1);
	v_IS_DST_FALL_BACK_DAY		NUMBER(1);
	v_GETS_DOUBLE_COLON			NUMBER(1);
	v_IS_HOLIDAY				NUMBER(1) := 0;

	--======================================================================================
	PROCEDURE SET_DST_STATISTICS
		(
		p_CUT_DATE IN DATE
		) IS
		v_STANDARD_TIME_ZONE SYSTEM_TIME_ZONE.STANDARD_TIME_ZONE%TYPE;
		v_LOCAL_DATE_MINUS_ONE_SEC DATE;
    
	BEGIN
		SELECT STANDARD_TIME_ZONE INTO v_STANDARD_TIME_ZONE FROM SYSTEM_TIME_ZONE WHERE TIME_ZONE = p_TIME_ZONE;

		--SET INITIAL VALUES
		v_IS_DST_SPRING_AHEAD_DAY := 0;
		v_IS_DST_SPRING_AHEAD_HOUR := 0;
		v_IS_DST_FALL_BACK_DAY := 0;
		v_IS_DST_FALL_BACK_HOUR := 0;
		v_IS_IN_DST_RANGE := 0;
		v_GETS_DOUBLE_COLON := 0;

		v_STANDARD_DATE := FROM_TZ(CAST(p_CUT_DATE AS TIMESTAMP), RO_TZ_OFFSET(GA.CUT_TIME_ZONE)) AT TIME ZONE RO_TZ_OFFSET(v_STANDARD_TIME_ZONE);

		v_LOCAL_DATE := v_STANDARD_DATE;
		v_LOCAL_DATE_MINUS_ONE_SEC := ADD_SECONDS_TO_DATE(v_LOCAL_DATE, -1);

		--ADJUST IF WE OBSERVE DST.
		--Special daytypes do not get shifted for DST.
		IF (NOT v_STANDARD_TIME_ZONE = p_TIME_ZONE) AND p_DAY_TYPE = c_DAYTYPE_STANDARD THEN

			v_DST_SPRING_AHEAD_DATE := DST_SPRING_AHEAD_DATE(v_STANDARD_DATE);
			v_DST_FALL_BACK_DATE := DST_FALL_BACK_DATE(v_STANDARD_DATE);


		IF TRUNC(v_LOCAL_DATE, 'HH') >= v_DST_SPRING_AHEAD_DATE AND v_LOCAL_DATE <= v_DST_FALL_BACK_DATE THEN

				-- Fix for mismatch between SystemDateTime and DateAlignedGrids - PBM 3/29/2005
				-- Remove this condition if we revert back to the correct way of handling the FALL_BACK date
			 IF v_LOCAL_DATE <= (v_DST_FALL_BACK_DATE - 1/24) THEN
					v_IS_IN_DST_RANGE := 1;

					v_LOCAL_DATE := FROM_TZ(CAST(v_LOCAL_DATE AS TIMESTAMP), RO_TZ_OFFSET(v_STANDARD_TIME_ZONE)) AT TIME ZONE RO_TZ_OFFSET(p_TIME_ZONE);

					v_LOCAL_DATE_MINUS_ONE_SEC := ADD_SECONDS_TO_DATE(v_LOCAL_DATE, -1);
					IF v_LOCAL_DATE = v_DST_FALL_BACK_DATE THEN
							v_IS_DST_FALL_BACK_HOUR := 1;
							v_GETS_DOUBLE_COLON := 1;
					END IF;
			 ELSE
					IF v_LOCAL_DATE = v_DST_FALL_BACK_DATE THEN
							v_IS_DST_FALL_BACK_HOUR := 0;
					ELSE
							v_GETS_DOUBLE_COLON := 1;
					END IF;
					v_LOCAL_DATE := ADD_SECONDS_TO_DATE(v_LOCAL_DATE, 1);
			 END IF;

		END IF;

			IF TRUNC(v_LOCAL_DATE_MINUS_ONE_SEC, 'DD') = TRUNC(v_DST_SPRING_AHEAD_DATE, 'DD') THEN
				v_IS_DST_SPRING_AHEAD_DAY := 1;
				IF TRUNC(v_LOCAL_DATE, 'HH') = v_DST_SPRING_AHEAD_DATE THEN
					v_IS_DST_SPRING_AHEAD_HOUR := 1;
				END IF;
			ELSIF TRUNC(v_LOCAL_DATE_MINUS_ONE_SEC, 'DD') = TRUNC(v_DST_FALL_BACK_DATE, 'DD') THEN
				v_IS_DST_FALL_BACK_DAY := 1;
			END IF;

		END IF;
	END SET_DST_STATISTICS;
	--======================================================================================
	FUNCTION GET_HOURLY_FORMATTED_DATE
		(
		p_DATE IN DATE,
		p_DAY_TYPE IN CHAR,
		p_INTERVAL IN VARCHAR2,
		p_DATE_FORMAT IN VARCHAR2,
		p_TIME_FORMAT IN VARCHAR2,
		p_WEEKDAY_ABBR IN VARCHAR2,
		p_WEEKEND_ABBR IN VARCHAR2,
		p_IS_FOR_SORT IN NUMBER
		) RETURN VARCHAR2 IS

		v_DATE DATE := p_DATE;
		v_DATE_STRING VARCHAR2(32);
		v_TIME_STRING VARCHAR2(16);
		v_SUFFIX VARCHAR2(4);
		v_TIME_FORMAT VARCHAR2(32) := p_TIME_FORMAT;

		v_NUM_MIN NUMBER := TO_NUMBER(TO_CHAR(p_DATE, 'MI'));
		v_ADD_MIN NUMBER;

        v_FALL_BACK_HOUR_MINUS1 CONSTANT VARCHAR2(2) := TO_CHAR(CAST(TO_CHAR(DST_FALL_BACK_DATE(SYSDATE), 'HH24') AS NUMBER) - 1);

	BEGIN

		-- If the local date has a sub-hourly specification then roll it to the next hour.
		IF TO_NUMBER(TO_CHAR(v_DATE,'MI')) <> 0 AND (p_INTERVAL = 'HH') THEN
			v_DATE := TRUNC(ADD_HOURS_TO_DATE(v_DATE,1), 'HH');
		END IF;

		IF p_INTERVAL = 'MI15' THEN
			v_ADD_MIN := TRUNC((v_NUM_MIN + 14)/15, 0)*15 - v_NUM_MIN;
		ELSIF p_INTERVAL = 'MI30' THEN
			v_ADD_MIN := TRUNC((v_NUM_MIN + 29)/30, 0)*30 - v_NUM_MIN;
		ELSE
			v_ADD_MIN := 0;
		END IF;

		v_DATE := v_DATE + v_ADD_MIN/1440;

		-- If this is 24:00, it belongs in the previous day.
		IF TO_CHAR(v_DATE,'HH24:MI') = '00:00' THEN
			v_DATE := v_DATE - 1;
			v_TIME_FORMAT := REPLACE(REPLACE(p_TIME_FORMAT,'HH24','"24"'),'HH','"24"');
		END IF;

		-- Get appropriate dst suffix
		IF (v_IS_DST_SPRING_AHEAD_DAY = 1 OR v_IS_DST_FALL_BACK_DAY = 1) AND p_INTERVAL IN ('MI5', 'MI15','MI30','HH') THEN

			-- Fix for mismatch between SystemDateTime and DateAlignedGrids - PBM 3/29/2005
			-- Remove this condition if we revert back to the correct way of handling the FALL_BACK date
			IF v_IS_IN_DST_RANGE = 1 THEN
				IF v_DATE = v_DST_FALL_BACK_DATE THEN
					v_DATE := v_DATE-1/24;
					v_SUFFIX := c_STANDARD_SUFFIX;
				ELSE
					v_SUFFIX := c_DAYLIGHT_SUFFIX;
				END IF;
			ELSE
				v_SUFFIX := c_STANDARD_SUFFIX;
			END IF;

		ELSE
			v_SUFFIX := ' ';
		END IF;

		-- PUSH THE ROLLUP HOUR TO 3 IF IT IS DST SPRING AHEAD DAY
		IF TO_NUMBER(TO_CHAR(v_DATE, 'MI')) = 0 AND TRUNC(v_DATE, 'HH') = v_DST_SPRING_AHEAD_DATE THEN
			v_DATE := v_DATE + 1/24;
			-- MAKE THE SUFFIX DAYLIGHT
			v_SUFFIX := c_DAYLIGHT_SUFFIX;
		END IF;

		-- Get Time String.  Shift 0 to 24.
		IF p_INTERVAL IN ('DD','MM','Q','YY','DY') THEN
			v_TIME_STRING := LPAD(' ', LENGTH(p_TIME_FORMAT) - 1, ' ');
		ELSIF v_IS_DST_FALL_BACK_DAY = 1 AND p_IS_FOR_SORT = 1 THEN
			--PUT THE SUFFIX BEFORE THE TIME.
			v_TIME_STRING := v_SUFFIX || TO_CHAR(v_DATE,v_TIME_FORMAT);
		ELSE
			v_TIME_STRING := TO_CHAR(v_DATE,v_TIME_FORMAT) || v_SUFFIX;
		END IF;

		IF v_GETS_DOUBLE_COLON = 1 THEN
			v_TIME_STRING := REPLACE(v_TIME_STRING,'0' || v_FALL_BACK_HOUR_MINUS1 || ':','0' || v_FALL_BACK_HOUR_MINUS1 || '::');
		ELSIF v_SUFFIX = c_STANDARD_SUFFIX THEN
			v_TIME_STRING := REPLACE(v_TIME_STRING,'0' || v_FALL_BACK_HOUR_MINUS1 || ':00s','0' || v_FALL_BACK_HOUR_MINUS1 || '::00s');
		END IF;

		IF NOT SUBSTR(p_INTERVAL,1,2) = 'MI' THEN
			v_DATE := TRUNC(v_DATE,p_INTERVAL);
		END IF;

		IF p_DAY_TYPE = c_DAYTYPE_STANDARD THEN
			v_DATE_STRING := TO_CHAR(v_DATE, p_DATE_FORMAT) || ' ' || v_TIME_STRING;
		ELSIF p_DAY_TYPE = c_DAYTYPE_WEEKDAY THEN --WEEKDAY
			v_DATE_STRING := TO_CHAR(v_DATE, p_DATE_FORMAT)  || p_WEEKDAY_ABBR || v_TIME_STRING;
		ELSIF p_DAY_TYPE = c_DAYTYPE_WEEKEND THEN --WEEKEND
			v_DATE_STRING := TO_CHAR(v_DATE, p_DATE_FORMAT)  || p_WEEKEND_ABBR || v_TIME_STRING;
		END IF;

		RETURN v_DATE_STRING;
	END GET_HOURLY_FORMATTED_DATE;
	--======================================================================================

BEGIN -- ADD_HOURLY_ROW
	SET_DST_STATISTICS(p_DATE);

	IF IS_HOLIDAY(TRUNC(v_LOCAL_DATE - c_SECOND, 'DD'),p_EDC_ID) THEN
		v_IS_HOLIDAY := 1;
	END IF;

	INSERT_SYSTEM_DATE_TIME(p_TIME_ZONE, -- TIME_ZONE
		c_DATA_HOURLY, 				-- DATA_INTERVAL_TYPE
		p_DAY_TYPE, 	-- DAY_TYPE
		p_DATE, 		-- CUT_DATE
		v_LOCAL_DATE, --LOCAL_DATE
		v_STANDARD_DATE, --STANDARD_DATE
		p_DATE, 		-- CUT_DATE_SCHEDULING
		GET_MINIMUM_INTERVAL_NUMBER(p_DATE),	--MINIMUM_INTERVAL_NUMBER
		TO_NUMBER(TO_CHAR(p_DATE,'MI')), 	-- CUT_MINUTE
		TO_NUMBER(TO_CHAR(p_DATE,'HH24')), 	-- CUT_HOUR
		TO_NUMBER(TO_CHAR(p_DATE - c_SECOND,'D')), 	-- CUT_DAY_IN_WEEK
		TO_CHAR(p_DATE - c_SECOND,'DY'), 				-- CUT_DAY_ABBR
		TO_NUMBER(TO_CHAR(p_DATE - c_SECOND,'DD')), 	-- CUT_DAY_IN_MONTH
		TO_NUMBER(TO_CHAR(p_DATE - c_SECOND,'WW')), 	-- CUT_WEEK
		TO_NUMBER(TO_CHAR(p_DATE - c_SECOND,'MM')), 	-- CUT_MONTH
		TO_NUMBER(TO_CHAR(p_DATE - c_SECOND,'Q')), 		-- CUT_QUARTER
		TO_NUMBER(TO_CHAR(p_DATE - c_SECOND,'YYYY')), 	-- CUT_YEAR
		TO_NUMBER(TO_CHAR(GET_FISCAL_YEAR_DATE(p_DATE - c_SECOND),'YYYY')), 	-- CUT_FISCAL_YEAR
		TRUNC(v_LOCAL_DATE, 'HH'), -- LOCAL_HOUR_TRUNC_DATE
		TRUNC(v_LOCAL_DATE - c_SECOND, 'DD'), -- LOCAL_DAY_TRUNC_DATE
		TRUNC(v_LOCAL_DATE - c_SECOND, 'DY'), -- LOCAL_WEEK_TRUNC_DATE
		TRUNC(v_LOCAL_DATE - c_SECOND, 'MM'), -- LOCAL_MONTH_TRUNC_DATE
		TRUNC(v_LOCAL_DATE - c_SECOND, 'Q'), -- LOCAL_QUARTER_TRUNC_DATE
		TRUNC(v_LOCAL_DATE - c_SECOND, 'YY'), -- LOCAL_YEAR_TRUNC_DATE
		TRUNC(GET_FISCAL_YEAR_DATE(v_LOCAL_DATE - c_SECOND), 'YY'), -- LOCAL_FISCAL_YEAR_TRUNC_DATE


		GET_HOURLY_FORMATTED_DATE(v_LOCAL_DATE,p_DAY_TYPE,'MI5',c_DATE_YYYY_MM_DD,c_TIME_YYYY_MM_DD,c_WEEKDAY_YYYY_MM_DD,c_WEEKEND_YYYY_MM_DD,0), --p_NO_ROLLUP_YYYY_MM_DD

		GET_HOURLY_FORMATTED_DATE(v_LOCAL_DATE,p_DAY_TYPE,'MI15',c_DATE_YYYY_MM_DD,c_TIME_YYYY_MM_DD,c_WEEKDAY_YYYY_MM_DD,c_WEEKEND_YYYY_MM_DD,0), --p_MI15_YYYY_MM_DD
		GET_HOURLY_FORMATTED_DATE(v_LOCAL_DATE,p_DAY_TYPE,'MI30',c_DATE_YYYY_MM_DD,c_TIME_YYYY_MM_DD,c_WEEKDAY_YYYY_MM_DD,c_WEEKEND_YYYY_MM_DD,0), --p_MI30_YYYY_MM_DD

		GET_HOURLY_FORMATTED_DATE(v_LOCAL_DATE,p_DAY_TYPE,'HH',c_DATE_YYYY_MM_DD,c_TIME_YYYY_MM_DD,c_WEEKDAY_YYYY_MM_DD,c_WEEKEND_YYYY_MM_DD,0), --p_HOUR_YYYY_MM_DD
		GET_HOURLY_FORMATTED_DATE(v_LOCAL_DATE,p_DAY_TYPE,'DD',c_DATE_YYYY_MM_DD,c_TIME_YYYY_MM_DD,c_WEEKDAY_YYYY_MM_DD,c_WEEKEND_YYYY_MM_DD,0),
		GET_HOURLY_FORMATTED_DATE(v_LOCAL_DATE,p_DAY_TYPE,'DY',c_DATE_YYYY_MM_DD,c_TIME_YYYY_MM_DD,c_WEEKDAY_YYYY_MM_DD,c_WEEKEND_YYYY_MM_DD,0),
		GET_HOURLY_FORMATTED_DATE(v_LOCAL_DATE,p_DAY_TYPE,'MM',c_DATE_YYYY_MM_DD,c_TIME_YYYY_MM_DD,c_WEEKDAY_YYYY_MM_DD,c_WEEKEND_YYYY_MM_DD,0),
		GET_HOURLY_FORMATTED_DATE(v_LOCAL_DATE,p_DAY_TYPE,'Q',c_DATE_YYYY_MM_DD,c_TIME_YYYY_MM_DD,c_WEEKDAY_YYYY_MM_DD,c_WEEKEND_YYYY_MM_DD,0),
		GET_HOURLY_FORMATTED_DATE(v_LOCAL_DATE,p_DAY_TYPE,'YY',c_DATE_YYYY_MM_DD,c_TIME_YYYY_MM_DD,c_WEEKDAY_YYYY_MM_DD,c_WEEKEND_YYYY_MM_DD,0),
		GET_HOURLY_FORMATTED_DATE(GET_FISCAL_YEAR_DATE(v_LOCAL_DATE - c_SECOND) + c_SECOND,p_DAY_TYPE,'YY',c_DATE_YYYY_MM_DD,c_TIME_YYYY_MM_DD,c_WEEKDAY_YYYY_MM_DD,c_WEEKEND_YYYY_MM_DD,0),
		GET_HOURLY_FORMATTED_DATE(v_LOCAL_DATE,p_DAY_TYPE,'MI15',g_DATE_CUSTOM_FORMAT,g_TIME_CUSTOM_FORMAT,g_WEEKDAY_CUSTOM_FORMAT,g_WEEKEND_CUSTOM_FORMAT,0),
		GET_HOURLY_FORMATTED_DATE(v_LOCAL_DATE,p_DAY_TYPE,'HH',g_DATE_CUSTOM_FORMAT,g_TIME_CUSTOM_FORMAT,g_WEEKDAY_CUSTOM_FORMAT,g_WEEKEND_CUSTOM_FORMAT,0),
		GET_HOURLY_FORMATTED_DATE(v_LOCAL_DATE,p_DAY_TYPE,'DD',g_DATE_CUSTOM_FORMAT,g_TIME_CUSTOM_FORMAT,g_WEEKDAY_CUSTOM_FORMAT,g_WEEKEND_CUSTOM_FORMAT,0),
		GET_HOURLY_FORMATTED_DATE(v_LOCAL_DATE,p_DAY_TYPE,'DY',g_DATE_CUSTOM_FORMAT,g_TIME_CUSTOM_FORMAT,g_WEEKDAY_CUSTOM_FORMAT,g_WEEKEND_CUSTOM_FORMAT,0),
		GET_HOURLY_FORMATTED_DATE(v_LOCAL_DATE,p_DAY_TYPE,'MM',g_DATE_CUSTOM_FORMAT,g_TIME_CUSTOM_FORMAT,g_WEEKDAY_CUSTOM_FORMAT,g_WEEKEND_CUSTOM_FORMAT,0),
		GET_HOURLY_FORMATTED_DATE(v_LOCAL_DATE,p_DAY_TYPE,'Q',g_DATE_CUSTOM_FORMAT,g_TIME_CUSTOM_FORMAT,g_WEEKDAY_CUSTOM_FORMAT,g_WEEKEND_CUSTOM_FORMAT,0),
		GET_HOURLY_FORMATTED_DATE(v_LOCAL_DATE,p_DAY_TYPE,'YY',g_DATE_CUSTOM_FORMAT,g_TIME_CUSTOM_FORMAT,g_WEEKDAY_CUSTOM_FORMAT,g_WEEKEND_CUSTOM_FORMAT,0),
		GET_HOURLY_FORMATTED_DATE(GET_FISCAL_YEAR_DATE(v_LOCAL_DATE - c_SECOND) + c_SECOND,p_DAY_TYPE,'YY',g_DATE_CUSTOM_FORMAT,g_TIME_CUSTOM_FORMAT,g_WEEKDAY_CUSTOM_FORMAT,g_WEEKEND_CUSTOM_FORMAT,0),
		v_IS_IN_DST_RANGE,				-- IS_IN_DST_RANGE
		v_IS_DST_SPRING_AHEAD_HOUR,		-- IS_DST_SPRING_AHEAD_HOUR
		v_IS_DST_SPRING_AHEAD_DAY,		-- IS_DST_SPRING_AHEAD_DAY
		v_IS_DST_FALL_BACK_HOUR,		-- IS_DST_FALL_BACK_HOUR
		v_IS_DST_FALL_BACK_DAY,			-- IS_DST_FALL_BACK_DAY
		IS_DAY_INTERVAL_OF_TYPE(-11, v_LOCAL_DATE, v_IS_HOLIDAY)	-- IS_ON_PEAK
		);

END ADD_HOURLY_ROW;
---------------------------------------------------------------------------------------------------
PROCEDURE POPULATE
	(
	p_TIME_ZONE			IN VARCHAR2,
	p_MINIMUM_INTERVAL	IN VARCHAR2,
	p_BEGIN_DATE		IN DATE,
	p_END_DATE			IN DATE,
	p_EDC_ID			IN NUMBER
	) AS

v_BEGIN_DATE	DATE := ADVANCE_DATE(TRUNC(p_BEGIN_DATE), p_MINIMUM_INTERVAL);
v_END_DATE		DATE := TRUNC(p_END_DATE)+1;
v_CUR_DATE 		DATE;

BEGIN

	--REMOVE EXISTING VALUES
	DELETE SYSTEM_DATE_TIME
	WHERE TIME_ZONE = p_TIME_ZONE
		AND DATA_INTERVAL_TYPE = c_DATA_HOURLY
		AND CUT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE;
	DELETE SYSTEM_DATE_TIME
	WHERE TIME_ZONE = p_TIME_ZONE
		AND DATA_INTERVAL_TYPE = c_DATA_DAILY
		AND CUT_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE);

	DELETE SYSTEM_DATE_TIME_SCENARIO
	WHERE ROLLUP_DATE BETWEEN TRUNC(v_BEGIN_DATE) AND v_END_DATE;

	--HOURLY AND SUBHOURLY DATA INTERVALS
	v_CUR_DATE := v_BEGIN_DATE;
	WHILE v_CUR_DATE <= v_END_DATE LOOP

		--STANDARD DAYTYPE ALL HOURS
		ADD_HOURLY_ROW(p_TIME_ZONE, c_DAYTYPE_STANDARD, v_CUR_DATE, p_EDC_ID);

		--WEEKDAY AND WEEKEND ARE ONLY USED FOR FIRST DAY OF MONTH OR WEEK.
		IF TRUNC(v_CUR_DATE,'DY') = TRUNC(v_CUR_DATE - c_SECOND) OR TRUNC(v_CUR_DATE,'MM') = TRUNC(v_CUR_DATE - c_SECOND) THEN
			ADD_HOURLY_ROW(p_TIME_ZONE, c_DAYTYPE_WEEKDAY, v_CUR_DATE, p_EDC_ID);
			ADD_HOURLY_ROW(p_TIME_ZONE, c_DAYTYPE_WEEKEND, v_CUR_DATE, p_EDC_ID);

			--ADD MULTIPLIERS ONLY AT THE DAY LEVEL
			IF TRUNC(v_CUR_DATE) = v_CUR_DATE THEN
				--ADD WEEK-MODE SCENARIO MULTIPLIERS FOR FIRST DAY OF WEEK.
				IF TRUNC(v_CUR_DATE,'DY') = TRUNC(v_CUR_DATE - c_SECOND) THEN
					ADD_SCENARIO_MULTIPLIERS(c_ROLLUP_WEEKLY, v_CUR_DATE - 1);
				END IF;
				--ADD MONTH-MODE SCENARIO MULTIPLIERS FOR FIRST DAY OF MONTH.
				IF TRUNC(v_CUR_DATE,'MM') = TRUNC(v_CUR_DATE - c_SECOND) THEN
					ADD_SCENARIO_MULTIPLIERS(c_ROLLUP_MONTHLY, v_CUR_DATE -1);
				END IF;
			END IF;
		END IF;

		IF TRUNC(v_CUR_DATE) = v_CUR_DATE THEN
			--ADD HOUR-MODE SCENARIO MULTIPLIERS FOR EVERY DAY.
			ADD_SCENARIO_MULTIPLIERS(c_ROLLUP_HOURLY, v_CUR_DATE - 1);
			ADD_SCENARIO_MULTIPLIERS(c_ROLLUP_DAILY, v_CUR_DATE - 1);

			--ADD DAILY DATA
			ADD_DAILY_ROW(p_TIME_ZONE, v_CUR_DATE - 1);
		END IF;

		v_CUR_DATE := ADVANCE_DATE(v_CUR_DATE, p_MINIMUM_INTERVAL);

	END LOOP;

END POPULATE;
---------------------------------------------------------------------------------------------------
PROCEDURE RUN
	(
	p_BEGIN_DATE		IN DATE,
	p_END_DATE			IN DATE,
	p_TIME_ZONES		IN STRING_COLLECTION := STRING_COLLECTION(GA.LOCAL_TIME_ZONE),
	p_EDC_ID			IN NUMBER := NULL,
	p_PROCESS_ID		OUT VARCHAR2,
	p_PROCESS_STATUS	OUT NUMBER,
	p_MESSAGE			OUT VARCHAR2
	) AS

v_IDX			PLS_INTEGER;
v_YR			PLS_INTEGER;
v_BEGIN_YR		PLS_INTEGER := TO_NUMBER(TO_CHAR(p_BEGIN_DATE,'YYYY'));
v_END_YR		PLS_INTEGER := TO_NUMBER(TO_CHAR(p_END_DATE,'YYYY'));
v_BEGIN_DATE	DATE;
v_END_DATE		DATE;
v_INTERVAL		VARCHAR2(16) := NVL(GET_INTERVAL_ABBREVIATION(g_MINIMUM_INTERVAL), 'HH');
v_EDC_ID		NUMBER(9);

BEGIN
	SAVEPOINT BEFORE_POPULATE_SDT;

	LOGS.START_PROCESS('Populate System-Date-Time Table', p_BEGIN_DATE, p_END_DATE);
	LOGS.SET_PROCESS_TARGET_PARAMETER('Time Zones', TEXT_UTIL.TO_CHAR_STRING_LIST(p_TIME_ZONES));

	ASSERT(p_BEGIN_DATE IS NOT NULL, 'Begin Date cannot be null', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_END_DATE IS NOT NULL, 'End Date cannot be null', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_END_DATE >= p_BEGIN_DATE, 'Begin Date cannot be before End Date', MSGCODES.c_ERR_DATE_RANGE);
	ASSERT(p_TIME_ZONES IS NOT NULL, 'You must specify at least one Time Zone', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_TIME_ZONES.COUNT > 0, 'You must specify at least one Time Zone', MSGCODES.c_ERR_ARGUMENT);

	LOGS.INIT_PROCESS_PROGRESS('Populating...', p_TIME_ZONES.COUNT * (v_END_YR - v_BEGIN_YR + 1) + 2);

	POPULATE_DST_TYPE;
	LOGS.INCREMENT_PROCESS_PROGRESS;

	POPULATE_SYSTEM_DAY_INFO;
	LOGS.INCREMENT_PROCESS_PROGRESS;

	IF p_EDC_ID IS NULL THEN
		--GET INCUMBENT EDC IF AVAILABLE
		SELECT NVL(MAX(INCUMBENT_ID),0) -- use Not Assigned if no incumbent EDC
		INTO v_EDC_ID
		FROM INCUMBENT_ENTITY
		WHERE INCUMBENT_TYPE = 'EDC';
	ELSE
		v_EDC_ID := p_EDC_ID;
	END IF;

	-- Start populating
	v_IDX := p_TIME_ZONES.FIRST;
	WHILE p_TIME_ZONES.EXISTS(v_IDX) LOOP

		v_YR := v_BEGIN_YR;

		WHILE v_YR <= v_END_YR LOOP
			v_BEGIN_DATE := GREATEST(TO_DATE('1/1/'||v_YR, 'MM/DD/YYYY'), p_BEGIN_DATE);
			v_END_DATE := LEAST(TO_DATE('12/31/'||v_YR, 'MM/DD/YYYY'), p_END_DATE);

			POPULATE(p_TIME_ZONES(v_IDX),
					  v_INTERVAL,
					  v_BEGIN_DATE,
					  v_END_DATE,
					  v_EDC_ID);
			COMMIT; -- commit once per year per time zone
			SAVEPOINT BEFORE_POPULATE_SDT; -- immediately redefine savepoint

			v_YR := v_YR+1;
			LOGS.INCREMENT_PROCESS_PROGRESS;
		END LOOP;

		v_IDX := p_TIME_ZONES.NEXT(v_IDX);
	END LOOP;

	-- Finished!
	p_PROCESS_ID := LOGS.CURRENT_PROCESS_ID;
	LOGS.STOP_PROCESS(p_MESSAGE, p_PROCESS_STATUS);
	COMMIT;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.ABORT_PROCESS(p_SAVEPOINT_NAME => 'BEFORE_POPULATE_SDT');

END RUN;
---------------------------------------------------------------------------------------------------
PROCEDURE TIME_ZONE_LIST
	(
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT TIME_ZONE
		FROM SYSTEM_TIME_ZONE
        WHERE NVL(ENABLED,0) <> 0
		ORDER BY 1;
END TIME_ZONE_LIST;
---------------------------------------------------------------------------------------------------
FUNCTION GET_SETTING
	(
	p_SETTING_NAME IN VARCHAR2,
	p_DEFAULT_VAL IN VARCHAR2
	) RETURN VARCHAR2 IS
BEGIN
	RETURN NVL(GET_DICTIONARY_VALUE(p_SETTING_NAME, CONSTANTS.GLOBAL_MODEL, 'System', 'System-Date-Time'), p_DEFAULT_VAL);
END GET_SETTING;
---------------------------------------------------------------------------------------------------
PROCEDURE MAP_INTERVALS(p_INTERVAL_TYPE VARCHAR2, p_SRC_DST_TYPE NUMBER, p_TGT_DST_TYPE NUMBER) IS
    v_DST_INTV_MAP_ACTION BINARY_INTEGER;
    v_NUM_OF_INTVS_TO_DROP_EXPAND BINARY_INTEGER;
    v_DST_HOUR BINARY_INTEGER := CAST(TO_CHAR(DST_FALL_BACK_DATE(SYSDATE), 'HH24') AS NUMBER);
    v_DST_HOUR_S BINARY_INTEGER := CAST(TO_CHAR(DST_SPRING_AHEAD_DATE(SYSDATE), 'HH24') AS NUMBER);
    v_NUMS_INTV_IN_HOUR NUMBER;
    v_TGT_INTV NUMBER;
    v_TOTAL_SRC_INTERVALS NUMBER;
    v_SRC_INTV_COUNT NUMBER;
    --======================================================================
    PROCEDURE PUT_DST_INTERVAL_MAP
        (
        p_INTERVAL_TYPE VARCHAR2,
        p_SRC_INTERVAL NUMBER,
        p_TGT_INTERVAL NUMBER,
        p_SRC_DST_TYPE NUMBER,
        p_TGT_DST_TYPE NUMBER
        ) IS
    BEGIN
        INSERT INTO DST_INTERVAL_MAP(INTERVAL, SRC_INTERVAL, TGT_INTERVAL, SRC_DST_TYPE, TGT_DST_TYPE)
        VALUES (p_INTERVAL_TYPE, p_SRC_INTERVAL/24, p_TGT_INTERVAL/24, p_SRC_DST_TYPE, p_TGT_DST_TYPE);
    END PUT_DST_INTERVAL_MAP;
    --======================================================================
BEGIN

    v_NUMS_INTV_IN_HOUR := CASE p_INTERVAL_TYPE WHEN DATE_UTIL.c_NAME_HOUR THEN 1
                                                WHEN DATE_UTIL.c_NAME_30MIN THEN 2
                                                WHEN DATE_UTIL.c_NAME_15MIN THEN 4
                                                WHEN DATE_UTIL.c_NAME_10MIN THEN 6
                                                WHEN DATE_UTIl.c_NAME_5MIN THEN 12 END;
    v_TOTAL_SRC_INTERVALS :=  CASE p_SRC_DST_TYPE WHEN CONSTANTS.DST_TYPE_SPRING_AHEAD THEN 23 WHEN CONSTANTS.DST_TYPE_DST_PERIOD THEN 24 WHEN CONSTANTS.DST_TYPE_FALL_BACK THEN 25 END;

    -- Transitioning when Source day and Target day are the same
    IF p_SRC_DST_TYPE = p_TGT_DST_TYPE THEN
        v_DST_INTV_MAP_ACTION := c_DST_INTV_MAP_ACTION_NONE;
     -- Transitioning from Standard Day to Short Day or Long Day to Standard Day
    ELSIF (p_SRC_DST_TYPE=CONSTANTS.DST_TYPE_DST_PERIOD AND p_TGT_DST_TYPE=CONSTANTS.DST_TYPE_SPRING_AHEAD)
            OR (p_SRC_DST_TYPE=CONSTANTS.DST_TYPE_FALL_BACK AND p_TGT_DST_TYPE=CONSTANTS.DST_TYPE_DST_PERIOD) THEN
        v_DST_INTV_MAP_ACTION := c_DST_INTV_MAP_ACTION_DROP;
        v_NUM_OF_INTVS_TO_DROP_EXPAND := c_DROP_EXPAND_SINGLE_INTERVAL;
    -- Transitioning from Long Day to Short Day
    ELSIF (p_SRC_DST_TYPE=CONSTANTS.DST_TYPE_FALL_BACK AND p_TGT_DST_TYPE=CONSTANTS.DST_TYPE_SPRING_AHEAD)THEN
        v_DST_INTV_MAP_ACTION := c_DST_INTV_MAP_ACTION_DROP;
        v_NUM_OF_INTVS_TO_DROP_EXPAND := c_DROP_EXPAND_DOUBLE_INTERVAL;
    -- Transitioning from Short Day to Standard Day or Standard Day to Long Day
    ELSIF (p_SRC_DST_TYPE=CONSTANTS.DST_TYPE_DST_PERIOD AND p_TGT_DST_TYPE=CONSTANTS.DST_TYPE_FALL_BACK)
        OR (p_SRC_DST_TYPE=CONSTANTS.DST_TYPE_SPRING_AHEAD AND p_TGT_DST_TYPE=CONSTANTS.DST_TYPE_DST_PERIOD) THEN
        v_DST_INTV_MAP_ACTION := c_DST_INTV_MAP_ACTION_EXPAND;
        v_NUM_OF_INTVS_TO_DROP_EXPAND := c_DROP_EXPAND_SINGLE_INTERVAL;
    -- Transitioning from Short Day to Long Day
    ELSIF (p_SRC_DST_TYPE=CONSTANTS.DST_TYPE_SPRING_AHEAD AND p_TGT_DST_TYPE=CONSTANTS.DST_TYPE_FALL_BACK)THEN
        v_DST_INTV_MAP_ACTION := c_DST_INTV_MAP_ACTION_EXPAND;
        v_NUM_OF_INTVS_TO_DROP_EXPAND := c_DROP_EXPAND_DOUBLE_INTERVAL;
    END IF;

    v_TGT_INTV := 1/v_NUMS_INTV_IN_HOUR;
    v_SRC_INTV_COUNT := 1;
    WHILE v_SRC_INTV_COUNT <= v_TOTAL_SRC_INTERVALS * v_NUMS_INTV_IN_HOUR
    LOOP
        -- Same Day Type
        IF v_DST_INTV_MAP_ACTION = c_DST_INTV_MAP_ACTION_NONE THEN
            PUT_DST_INTERVAL_MAP(p_INTERVAL_TYPE, v_SRC_INTV_COUNT/v_NUMS_INTV_IN_HOUR, v_TGT_INTV, p_SRC_DST_TYPE, p_TGT_DST_TYPE);
            v_TGT_INTV := v_TGT_INTV + 1/v_NUMS_INTV_IN_HOUR;
        -- Standard to Short day or Long to Standard or Long to Short
        ELSIF v_DST_INTV_MAP_ACTION = c_DST_INTV_MAP_ACTION_DROP THEN
            -- Drop one interval
            IF v_NUM_OF_INTVS_TO_DROP_EXPAND = c_DROP_EXPAND_SINGLE_INTERVAL THEN
                -- Skip source intervals which are > 1 and <= 2
                IF v_SRC_INTV_COUNT/v_NUMS_INTV_IN_HOUR <= v_DST_HOUR_S-1 OR v_SRC_INTV_COUNT/v_NUMS_INTV_IN_HOUR > v_DST_HOUR_S THEN
                    PUT_DST_INTERVAL_MAP(p_INTERVAL_TYPE, v_SRC_INTV_COUNT/v_NUMS_INTV_IN_HOUR, v_TGT_INTV, p_SRC_DST_TYPE, p_TGT_DST_TYPE);
                    v_TGT_INTV := v_TGT_INTV + 1/v_NUMS_INTV_IN_HOUR;
                END IF;
            -- Drop two intervals
            ELSIF v_NUM_OF_INTVS_TO_DROP_EXPAND = c_DROP_EXPAND_DOUBLE_INTERVAL THEN
                -- Skip source intervals which are > 1 and <= 3
                IF v_SRC_INTV_COUNT/v_NUMS_INTV_IN_HOUR <= v_DST_HOUR_S-1 OR v_SRC_INTV_COUNT/v_NUMS_INTV_IN_HOUR > v_DST_HOUR_S+1 THEN
                    PUT_DST_INTERVAL_MAP(p_INTERVAL_TYPE, v_SRC_INTV_COUNT/v_NUMS_INTV_IN_HOUR, v_TGT_INTV, p_SRC_DST_TYPE, p_TGT_DST_TYPE);
                    v_TGT_INTV := v_TGT_INTV + 1/v_NUMS_INTV_IN_HOUR;
                END IF;
            END IF;
         ELSIF v_DST_INTV_MAP_ACTION = c_DST_INTV_MAP_ACTION_EXPAND THEN
            -- Expand
            IF v_NUM_OF_INTVS_TO_DROP_EXPAND = c_DROP_EXPAND_SINGLE_INTERVAL THEN
                -- Expand intervals > 1 and <= 2 by one
                IF v_SRC_INTV_COUNT/v_NUMS_INTV_IN_HOUR > v_DST_HOUR-1 AND v_SRC_INTV_COUNT/v_NUMS_INTV_IN_HOUR <= v_DST_HOUR THEN
                    PUT_DST_INTERVAL_MAP(p_INTERVAL_TYPE, v_SRC_INTV_COUNT/v_NUMS_INTV_IN_HOUR, v_TGT_INTV, p_SRC_DST_TYPE, p_TGT_DST_TYPE);
                    v_TGT_INTV := v_TGT_INTV + 1/v_NUMS_INTV_IN_HOUR;
                    PUT_DST_INTERVAL_MAP(p_INTERVAL_TYPE, v_SRC_INTV_COUNT/v_NUMS_INTV_IN_HOUR, v_TGT_INTV, p_SRC_DST_TYPE, p_TGT_DST_TYPE);
                    v_TGT_INTV := v_TGT_INTV + 1/v_NUMS_INTV_IN_HOUR;
                ELSE
                    PUT_DST_INTERVAL_MAP(p_INTERVAL_TYPE, v_SRC_INTV_COUNT/v_NUMS_INTV_IN_HOUR, v_TGT_INTV, p_SRC_DST_TYPE, p_TGT_DST_TYPE);
                    v_TGT_INTV := v_TGT_INTV + 1/v_NUMS_INTV_IN_HOUR;
                END IF;
            ELSIF v_NUM_OF_INTVS_TO_DROP_EXPAND = c_DROP_EXPAND_DOUBLE_INTERVAL THEN
                -- Expand intervals > 1 and <= 2 by two
                IF v_SRC_INTV_COUNT/v_NUMS_INTV_IN_HOUR > v_DST_HOUR-1 AND v_SRC_INTV_COUNT/v_NUMS_INTV_IN_HOUR <= v_DST_HOUR THEN
                    PUT_DST_INTERVAL_MAP(p_INTERVAL_TYPE, v_SRC_INTV_COUNT/v_NUMS_INTV_IN_HOUR, v_TGT_INTV, p_SRC_DST_TYPE, p_TGT_DST_TYPE);
                    v_TGT_INTV := v_TGT_INTV + 1/v_NUMS_INTV_IN_HOUR;
                    PUT_DST_INTERVAL_MAP(p_INTERVAL_TYPE, v_SRC_INTV_COUNT/v_NUMS_INTV_IN_HOUR, v_TGT_INTV, p_SRC_DST_TYPE, p_TGT_DST_TYPE);
                    v_TGT_INTV := v_TGT_INTV + 1/v_NUMS_INTV_IN_HOUR;
                    PUT_DST_INTERVAL_MAP(p_INTERVAL_TYPE, v_SRC_INTV_COUNT/v_NUMS_INTV_IN_HOUR, v_TGT_INTV, p_SRC_DST_TYPE, p_TGT_DST_TYPE);
                    v_TGT_INTV := v_TGT_INTV + 1/v_NUMS_INTV_IN_HOUR;
                ELSE
                    PUT_DST_INTERVAL_MAP(p_INTERVAL_TYPE, v_SRC_INTV_COUNT/v_NUMS_INTV_IN_HOUR, v_TGT_INTV, p_SRC_DST_TYPE, p_TGT_DST_TYPE);
                    v_TGT_INTV := v_TGT_INTV + 1/v_NUMS_INTV_IN_HOUR;
                END IF;
            END IF;

        END IF;

        v_SRC_INTV_COUNT := v_SRC_INTV_COUNT + 1;
    END LOOP;
END MAP_INTERVALS;
----------------------------------------------------------------------------------------
PROCEDURE POPULATE_DST_INTERVAL_MAP IS
BEGIN
    EXECUTE IMMEDIATE 'TRUNCATE TABLE DST_INTERVAL_MAP';

    -- 0 - NO DST Adjustment (24 Hours), 1 - Short Day (23 Hours),
    -- 2 - DST Period (24 Hours), 3 - Long Day (25 Hours)
    FOR v_IDX IN 1..g_INTERVAL_TYPES.COUNT LOOP
        FOR v_SRC_IDX IN CONSTANTS.DST_TYPE_SPRING_AHEAD..CONSTANTS.DST_TYPE_FALL_BACK
        LOOP
            FOR v_TGT_IDX IN CONSTANTS.DST_TYPE_SPRING_AHEAD..CONSTANTS.DST_TYPE_FALL_BACK
            LOOP
                MAP_INTERVALS(g_INTERVAL_TYPES(v_IDX), v_SRC_IDX, v_TGT_IDX);
            END LOOP;
        END LOOP;
    END LOOP;

    -- No DST Adjustment type is same as DST Period type
    INSERT INTO DST_INTERVAL_MAP (INTERVAL, SRC_DST_TYPE, TGT_DST_TYPE, SRC_INTERVAL, TGT_INTERVAL)
    SELECT INTERVAL,
           CASE WHEN SRC_DST_TYPE = CONSTANTS.DST_TYPE_DST_PERIOD THEN CONSTANTS.DST_TYPE_NONE ELSE SRC_DST_TYPE END,
           CASE WHEN TGT_DST_TYPE = CONSTANTS.DST_TYPE_DST_PERIOD THEN CONSTANTS.DST_TYPE_NONE ELSE TGT_DST_TYPE END,
           SRC_INTERVAL,
           TGT_INTERVAL
    FROM DST_INTERVAL_MAP
    WHERE SRC_DST_TYPE = CONSTANTS.DST_TYPE_DST_PERIOD
        OR TGT_DST_TYPE = CONSTANTS.DST_TYPE_DST_PERIOD;

	-- NEED TO CREATE NONE->DST PERIOD AND DST PERIOD-> NONE MAPS
	INSERT INTO DST_INTERVAL_MAP (INTERVAL, SRC_DST_TYPE, TGT_DST_TYPE, SRC_INTERVAL, TGT_INTERVAL)
	SELECT INTERVAL,
		   CONSTANTS.DST_TYPE_NONE,
		   CONSTANTS.DST_TYPE_DST_PERIOD,
		   SRC_INTERVAL,
		   TGT_INTERVAL
	FROM DST_INTERVAL_MAP
	WHERE SRC_DST_TYPE = CONSTANTS.DST_TYPE_DST_PERIOD
		AND TGT_DST_TYPE = CONSTANTS.DST_TYPE_DST_PERIOD;

	INSERT INTO DST_INTERVAL_MAP (INTERVAL, SRC_DST_TYPE, TGT_DST_TYPE, SRC_INTERVAL, TGT_INTERVAL)
	SELECT INTERVAL,
		   CONSTANTS.DST_TYPE_DST_PERIOD,
		   CONSTANTS.DST_TYPE_NONE,
		   SRC_INTERVAL,
		   TGT_INTERVAL
	FROM DST_INTERVAL_MAP
	WHERE SRC_DST_TYPE = CONSTANTS.DST_TYPE_DST_PERIOD
		AND TGT_DST_TYPE = CONSTANTS.DST_TYPE_DST_PERIOD;

    COMMIT;

END POPULATE_DST_INTERVAL_MAP;
---------------------------------------------------------------------------------------------------
PROCEDURE POPULATE_SYSTEM_DAY_INFO AS

	v_BEGIN_DATE DATE;
	v_END_DATE DATE;


	v_BEGIN_WINDOW NUMBER(2);
	v_END_WINDOW NUMBER(2);

BEGIN

	-- FIRST, GENERATE DST_INTERVAL_MAP
	POPULATE_DST_INTERVAL_MAP;

	BEGIN
		v_BEGIN_WINDOW := TO_NUMBER( GET_DICTIONARY_VALUE('Past Window',
															CONSTANTS.GLOBAL_MODEL,
															'System',
															'Fill System Day Info',
															CONSTANTS.UNDEFINED_ATTRIBUTE) );
	EXCEPTION
		WHEN VALUE_ERROR THEN
			v_BEGIN_WINDOW := NULL;
	END;

	BEGIN
		v_END_WINDOW := TO_NUMBER( GET_DICTIONARY_VALUE('Future Window',
															CONSTANTS.GLOBAL_MODEL,
															'System',
															'Fill System Day Info',
															CONSTANTS.UNDEFINED_ATTRIBUTE) );
	EXCEPTION
		WHEN VALUE_ERROR THEN
			v_END_WINDOW := NULL;
	END;

	-- START JAN 1ST, 10 YEARS INTO THE PAST BY DEFAULT
	IF v_BEGIN_WINDOW IS NULL THEN
		v_BEGIN_WINDOW := 10;
	END IF;

	-- END DEC 31ST, 20 YEARS INTO THE FUTURE BY DEFAULT
	IF v_END_WINDOW IS NULL THEN
		v_END_WINDOW := 20;
	END IF;

    v_BEGIN_DATE := TO_DATE((TO_NUMBER(TO_CHAR(SYSDATE, 'YYYY')) - v_BEGIN_WINDOW) || '-01-01', 'YYYY-MM-DD');
	v_END_DATE := TO_DATE((TO_NUMBER(TO_CHAR(SYSDATE, 'YYYY')) + v_END_WINDOW) || '-12-31', 'YYYY-MM-DD');

	DELETE FROM SYSTEM_DAY_INFO;

	INSERT INTO SYSTEM_DAY_INFO (TIME_ZONE, LOCAL_DATE, DST_TYPE, CUT_BEGIN_DATE, CUT_END_DATE)
	SELECT STZ.TIME_ZONE,
			DATES.DT AS LOCAL_DATE,
			DST.DST_TYPE,
			TO_CUT(DATES.DT, STZ.TIME_ZONE) AS CUT_BEGIN_DATE,
			TO_CUT(DATES.DT + 1, STZ.TIME_ZONE) AS CUT_END_DATE
		FROM DST_TYPE DST,
			(SELECT v_BEGIN_DATE + (LEVEL-1) AS DT
				FROM DUAL
				CONNECT BY LEVEL <= (v_END_DATE - v_BEGIN_DATE + 1)) DATES,
			SYSTEM_TIME_ZONE STZ
		WHERE DATES.DT BETWEEN DST.BEGIN_DATE AND DST.END_DATE;

END POPULATE_SYSTEM_DAY_INFO;
---------------------------------------------------------------------------------------------------
BEGIN

	-- Load values from System Dictionary

	DECLARE
		v_FISCAL_YEAR_END_DATE VARCHAR2(16);
	BEGIN
		v_FISCAL_YEAR_END_DATE := GET_SETTING('Fiscal Year End', '09/30');
		g_FISCAL_YEAR_END_DATE := TO_DATE(v_FISCAL_YEAR_END_DATE||'/2000', 'MM/DD/YYYY');
	EXCEPTION
		WHEN OTHERS THEN
			g_FISCAL_YEAR_END_DATE := DATE '2000-09-30';
	END;

	g_TIME_CUSTOM_FORMAT := GET_SETTING('Custom Format - Time', 'HH24:MI');
	g_DATE_CUSTOM_FORMAT := GET_SETTING('Custom Format - Date', 'MM/DD/YYYY');
	g_WEEKEND_CUSTOM_FORMAT := GET_SETTING('Custom Format - Weekend', ' WE ');
	g_WEEKDAY_CUSTOM_FORMAT := GET_SETTING('Custom Format - Weekday', ' WD ');
	g_MINIMUM_INTERVAL := GET_SETTING('Minimum Interval', 'MI15');

END POPULATE_SYSTEM_DATE_TIME;
/
