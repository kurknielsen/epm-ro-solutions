CREATE OR REPLACE PACKAGE RA AS
--Revision $Revision: 1.96 $

-- RETAIL ACCOUNT PACKAGE.

FUNCTION WHAT_VERSION RETURN VARCHAR;


PROCEDURE PUT_ACCOUNT_EDC
	(
	p_ACCOUNT_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_EDC_ACCOUNT_NUMBER IN VARCHAR,
	p_EDC_RATE_CLASS IN VARCHAR,
	p_EDC_STRATA IN VARCHAR,
	p_OLD_EDC_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_ACCOUNT_EDC
	(
	p_ACCOUNT_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_EDC_ACCOUNT_NUMBER IN VARCHAR,
	p_EDC_RATE_CLASS IN VARCHAR,
	p_OLD_EDC_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_ACCOUNT_ESP
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ESP_ACCOUNT_NUMBER IN VARCHAR,
	p_OLD_ESP_ID IN NUMBER,
	p_OLD_POOL_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE ACCOUNT_PRODUCTS
	(
	p_ACCOUNT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PUT_ACCOUNT_PRODUCT
	(
	p_CASE_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_PRODUCT_TYPE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_CASE_ID IN NUMBER,
	p_OLD_PRODUCT_ID IN NUMBER,
	p_OLD_PRODUCT_TYPE IN CHAR,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE ACCOUNT_CALENDARS
	(
	p_ACCOUNT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PUT_ACCOUNT_CALENDAR
	(
	p_CASE_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_CALENDAR_ID IN NUMBER,
	p_CALENDAR_TYPE IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_CASE_ID IN NUMBER,
	p_OLD_CALENDAR_ID IN NUMBER,
	p_OLD_CALENDAR_TYPE IN VARCHAR,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_ACCOUNT_SERVICE_LOCATION
	(
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_EDC_IDENTIFIER IN VARCHAR,
	p_ESP_IDENTIFIER IN VARCHAR,
	p_OLD_SERVICE_LOCATION_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE ACCOUNT_USAGE_FACTORS
	(
	p_ACCOUNT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PUT_ACCOUNT_USAGE_FACTOR
	(
	p_CASE_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_FACTOR_VAL IN NUMBER,
	p_OLD_CASE_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE ACCOUNT_LOSS_FACTORS
	(
	p_ACCOUNT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PUT_ACCOUNT_LOSS_FACTOR
	(
	p_CASE_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_LOSS_FACTOR_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_CASE_ID IN NUMBER,
	p_OLD_LOSS_FACTOR_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE CONTRACT_LIMIT_QUANTITIES
	(
	p_CONTRACT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PUT_CONTRACT_LIMIT_QUANTITY
	(
	p_CONTRACT_ID IN NUMBER,
	p_LIMIT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_LIMIT_QUANTITY IN NUMBER,
	p_OLD_LIMIT_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE ACCOUNT_CONTRACTS
	(
	p_ACCOUNT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE CONTRACT_ASSIGNMENTS
	(
	p_CONTRACT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PUT_CONTRACT_ASSIGNMENT
	(
	p_CONTRACT_ID IN NUMBER,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_OWNER_ENTITY_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ENTITY_NAME IN VARCHAR,
	p_OLD_CONTRACT_ID IN NUMBER,
	p_OLD_ENTITY_DOMAIN_ID IN NUMBER,
	p_OLD_OWNER_ENTITY_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE BILL_CYCLE_PERIODS
	(
	p_BILL_CYCLE_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PUT_BILL_CYCLE_PERIOD
	(
	p_BILL_CYCLE_ID IN NUMBER,
	p_BILL_CYCLE_MONTH IN DATE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_BILL_CYCLE_MONTH IN DATE,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_PSE_ESP
	(
	p_ESP_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_PSE_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	P_STATUS OUT NUMBER
	);

PROCEDURE PUT_ESP_POOL
	(
	p_POOL_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_ESP_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	P_STATUS OUT NUMBER
	);

PROCEDURE PUT_EDC_RATE_CLASS
	(
	p_EDC_ID IN NUMBER,
	p_RATE_CLASS IN VARCHAR,
	p_OLD_RATE_CLASS IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_AGGREGATE_ACCOUNT
	(
	p_AGGREGATE_ID IN NUMBER,
	p_DATE IN DATE,
	p_VALUE IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE NAVIGATE_ACCOUNT_ENTITY
	(
	p_SOURCE_ID IN NUMBER,
	p_DIRECTION IN VARCHAR,
	p_DESTINATION_ID OUT NUMBER,
	p_FIRST_OR_LAST OUT VARCHAR
	);

PROCEDURE NAVIGATE_CONTRACT_ENTITY
	(
	p_SOURCE_ID IN NUMBER,
	p_DIRECTION IN VARCHAR,
	p_DESTINATION_ID OUT NUMBER,
	p_FIRST_OR_LAST OUT VARCHAR
	);

PROCEDURE PUT_ACCOUNT_ANCILLARY_SERVICE
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SERVICE_VAL IN NUMBER,
	p_OLD_ANCILLARY_SERVICE_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_AGGREGATE_ACCOUNT_ESP
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_ESP_ID IN NUMBER,
	p_OLD_POOL_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE EDC_LOSS_FACTORS
	(
	p_EDC_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PUT_EDC_LOSS_FACTOR
	(
	p_CASE_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_LOSS_FACTOR_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_CASE_ID IN NUMBER,
	p_OLD_LOSS_FACTOR_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_ACCOUNT_METER
	(
	p_ACCOUNT_ID IN NUMBER,
	p_METER_NAME IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_USAGE_FACTOR IN NUMBER,
	p_OLD_METER_NAME IN VARCHAR,
	p_STATUS OUT NUMBER
	);


PROCEDURE SYSTEM_LOAD_AREAS
	(
	p_SYSTEM_LOAD_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PUT_SYSTEM_LOAD_AREA
	(
	p_SYSTEM_LOAD_ID IN NUMBER,
	p_AREA_ID IN NUMBER,
	p_OPERATION_CODE IN CHAR,
	p_OLD_AREA_ID IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_ENABLE_ESP_POOL_ASSIGNMENT
	(
	p_ENABLE_ESP_POOL_ASSIGNMENT OUT NUMBER
	);

PROCEDURE TERMINATE_ACCOUNT_USAGE_FACTOR
	(
	p_ACCOUNT_ID IN NUMBER,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE ACCOUNT_IMPORT_COLUMN_HEADERS
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PUT_ACCOUNT_SCHEDULE_GROUP
	(
	p_ACCOUNT_ID IN NUMBER,
	p_SCHEDULE_GROUP_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_SCHEDULE_GROUP_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE ACCOUNT_GROWTHS
	(
	p_ACCOUNT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PUT_ACCOUNT_GROWTH
	(
	p_CASE_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_PATTERN_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_GROWTH_PCT IN NUMBER,
	p_OLD_CASE_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_ACCOUNT_STATUS
	(
	p_ACCOUNT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ACCOUNT_STATUS_NAME IN VARCHAR,
	p_ACCOUNT_IS_ACTIVE IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_ACCOUNT_STATUS_NAME
	(
	p_ACCOUNT_STATUS_NAME IN VARCHAR2,
	p_IS_ACTIVE IN NUMBER
	);

PROCEDURE ACCOUNT_STATUSES
	(
	p_ACCOUNT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE ACCOUNT_STATUS_NAMES
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PUT_EDC_CONVERSION_FACTOR
	(
	p_EDC_ID IN NUMBER,
	p_SERVICE_AREA_ID IN NUMBER,
	p_FACTOR_CODE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_FACTOR_VAL IN NUMBER,
	p_OLD_SERVICE_AREA_ID IN NUMBER,
	p_OLD_FACTOR_CODE IN CHAR,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE EDC_CONVERSION_FACTORS
	(
	p_EDC_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE ACCOUNT_GROUP_CATEGORIES
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE ACCOUNT_ACCOUNT_GROUPS
	(
	p_ACCOUNT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PUT_ACCOUNT_GROUP_ASSIGNMENT
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ACCOUNT_GROUP_ID IN NUMBER,
	p_ASSIGNMENT_CATEGORY IN VARCHAR,
	p_OLD_ACCOUNT_GROUP_ID IN NUMBER,
	p_OLD_ASSIGNMENT_CATEGORY IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE ACCOUNT_BILL_CYCLES
	(
	p_ACCOUNT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PUT_ACCOUNT_BILL_CYCLE
	(
	p_ACCOUNT_ID IN NUMBER,
	p_BILL_CYCLE_ID IN NUMBER,
	p_BILL_CYCLE_ENTITY IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_BILL_CYCLE_ID IN NUMBER,
	p_OLD_BILL_CYCLE_ENTITY IN VARCHAR,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE ACCOUNT_BILL_PARTIES
	(
	p_ACCOUNT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PUT_ACCOUNT_BILL_PARTY
	(
	p_ACCOUNT_ID IN NUMBER,
	p_BILL_PARTY_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_BILL_PARTY_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE SERVICE_CONTRACT_NOTE_TYPES
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE SERVICE_CONTRACT_NOTE_AUTHORS
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

g_DOMAIN_NAME VARCHAR(16) := 'Data Setup';
g_TRACE_TARGET CHAR(1) := 'T';

END RA;
/
CREATE OR REPLACE PACKAGE BODY RA AS
----------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
    RETURN '$Revision: 1.96 $';
END WHAT_VERSION;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_EDC
	(
	p_ACCOUNT_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_EDC_ACCOUNT_NUMBER IN VARCHAR,
	p_EDC_RATE_CLASS IN VARCHAR,
	p_EDC_STRATA IN VARCHAR,
	p_OLD_EDC_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS

CURSOR c_ACCOUNT_EDC IS
	SELECT *
	FROM ACCOUNT_EDC
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
	ORDER BY BEGIN_DATE DESC;

v_ACCOUNT_EDC ACCOUNT_EDC%ROWTYPE;
v_END_DATE DATE;
v_INITIAL BOOLEAN;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- UPDATE THE CURRENT ACCOUNT EDC ASSIGNMENT IF ONE EXISTS

	UPDATE ACCOUNT_EDC SET
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		EDC_ACCOUNT_NUMBER = NVL(p_EDC_ACCOUNT_NUMBER,GA.UNDEFINED_ATTRIBUTE),
		EDC_RATE_CLASS = NVL(p_EDC_RATE_CLASS,GA.UNDEFINED_ATTRIBUTE),
		EDC_STRATA = NVL(p_EDC_STRATA,GA.UNDEFINED_ATTRIBUTE),
		EDC_ID = p_EDC_ID,
		ENTRY_DATE = SYSDATE
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND EDC_ID = p_OLD_EDC_ID
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS ACCOUNT AND EDC COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO ACCOUNT_EDC (
			ACCOUNT_ID,
			EDC_ID,
			BEGIN_DATE,
			END_DATE,
			EDC_ACCOUNT_NUMBER,
			EDC_RATE_CLASS,
			EDC_STRATA,
			ENTRY_DATE)
		VALUES (
			p_ACCOUNT_ID,
			p_EDC_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			NVL(p_EDC_ACCOUNT_NUMBER,GA.UNDEFINED_ATTRIBUTE),
			NVL(p_EDC_RATE_CLASS,GA.UNDEFINED_ATTRIBUTE),
			NVL(p_EDC_STRATA,GA.UNDEFINED_ATTRIBUTE),
			SYSDATE);
	END IF;

	OPEN c_ACCOUNT_EDC;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_ACCOUNT_EDC INTO v_ACCOUNT_EDC;
		EXIT WHEN c_ACCOUNT_EDC%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_ACCOUNT_EDC.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE ACCOUNT_EDC
		SET END_DATE = GREATEST(v_END_DATE, v_ACCOUNT_EDC.BEGIN_DATE)
		WHERE ACCOUNT_ID = v_ACCOUNT_EDC.ACCOUNT_ID
			AND EDC_ID = v_ACCOUNT_EDC.EDC_ID
			AND BEGIN_DATE = v_ACCOUNT_EDC.BEGIN_DATE;
		v_END_DATE := v_ACCOUNT_EDC.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_ACCOUNT_EDC;

END PUT_ACCOUNT_EDC;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_EDC
	(
	p_ACCOUNT_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_EDC_ACCOUNT_NUMBER IN VARCHAR,
	p_EDC_RATE_CLASS IN VARCHAR,
	p_OLD_EDC_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	PUT_ACCOUNT_EDC(p_ACCOUNT_ID, p_EDC_ID, p_BEGIN_DATE, p_END_DATE, p_EDC_ACCOUNT_NUMBER, p_EDC_RATE_CLASS, '?', p_OLD_EDC_ID, p_OLD_BEGIN_DATE, p_STATUS);

END PUT_ACCOUNT_EDC;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_ESP
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ESP_ACCOUNT_NUMBER IN VARCHAR,
	p_OLD_ESP_ID IN NUMBER,
	p_OLD_POOL_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS

v_END_DATE DATE;
v_INSERT BOOLEAN := FALSE;
v_HIGH_DATE DATE;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := Null_Date(p_END_DATE);
	v_HIGH_DATE := HIGH_DATE;


-- UPDATE THE CURRENT ACCOUNT ESP ASSIGNMENT IF ONE EXISTS

	UPDATE ACCOUNT_ESP SET
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		ESP_ACCOUNT_NUMBER = NVL(p_ESP_ACCOUNT_NUMBER,GA.UNDEFINED_ATTRIBUTE),
		ESP_ID = p_ESP_ID,
		POOL_ID = p_POOL_ID,
		ENTRY_DATE = SYSDATE
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND ESP_ID = p_OLD_ESP_ID
		AND POOL_ID = p_OLD_POOL_ID
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS ACCOUNT AND ESP COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		v_INSERT := TRUE;
	END IF;

	UPDATE ACCOUNT_ESP
	  SET END_DATE = TRUNC(p_BEGIN_DATE) - 1
	  WHERE ACCOUNT_ID = p_ACCOUNT_ID
	  	AND NVL(TRUNC(END_DATE),v_HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
		AND BEGIN_DATE < TRUNC(p_BEGIN_DATE);

	UPDATE ACCOUNT_ESP
	  SET BEGIN_DATE = TRUNC(p_END_DATE) + 1
	  WHERE ACCOUNT_ID = p_ACCOUNT_ID
	  	AND BEGIN_DATE <= NVL(TRUNC(p_END_DATE),v_HIGH_DATE)
		AND NVL(TRUNC(END_DATE),v_HIGH_DATE) > NVL(TRUNC(p_END_DATE),v_HIGH_DATE);

	IF v_INSERT THEN

	    DELETE FROM ACCOUNT_ESP
	      WHERE ACCOUNT_ID = p_ACCOUNT_ID
	        AND BEGIN_DATE >= TRUNC(p_BEGIN_DATE)
		    AND NVL(TRUNC(END_DATE),v_HIGH_DATE) <= NVL(TRUNC(p_END_DATE),v_HIGH_DATE);

		INSERT INTO ACCOUNT_ESP
			(
			ACCOUNT_ID,
			ESP_ID,
			POOL_ID,
			BEGIN_DATE,
			END_DATE,
			ESP_ACCOUNT_NUMBER,
			ENTRY_DATE
			)
		VALUES
			(
			p_ACCOUNT_ID,
			p_ESP_ID,
			p_POOL_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			NVL(p_ESP_ACCOUNT_NUMBER,GA.UNDEFINED_ATTRIBUTE),
			SYSDATE
			);
	ELSE
	  DELETE FROM ACCOUNT_ESP
	      WHERE ACCOUNT_ID = p_ACCOUNT_ID
	        AND BEGIN_DATE > TRUNC(p_BEGIN_DATE)
		    AND NVL(TRUNC(END_DATE),v_HIGH_DATE) <= NVL(TRUNC(p_END_DATE),v_HIGH_DATE);
	END IF;

END PUT_ACCOUNT_ESP;
----------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNT_PRODUCTS
	(
	p_ACCOUNT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS


BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

   OPEN p_CURSOR FOR
		SELECT B.CASE_NAME,
			 A.CASE_ID,
			 A.BEGIN_DATE,
			 A.END_DATE,
			 A.PRODUCT_TYPE,
			 A.PRODUCT_ID,
			 C.PRODUCT_NAME,
			 A.ENTRY_DATE
		FROM ACCOUNT_PRODUCT A, CASE_LABEL B, PRODUCT C
		WHERE A.ACCOUNT_ID = p_ACCOUNT_ID
			AND B.CASE_ID = A.CASE_ID
			AND C.PRODUCT_ID = A.PRODUCT_ID
		ORDER BY 1;


END ACCOUNT_PRODUCTS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_PRODUCT
	(
	p_CASE_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_PRODUCT_TYPE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_CASE_ID IN NUMBER,
	p_OLD_PRODUCT_ID IN NUMBER,
	p_OLD_PRODUCT_TYPE IN CHAR,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	)
	AS

CURSOR c_ACCOUNT_PRODUCT IS
	SELECT *
	FROM ACCOUNT_PRODUCT
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND CASE_ID = p_CASE_ID
		AND PRODUCT_TYPE = p_PRODUCT_TYPE
	ORDER BY BEGIN_DATE DESC;

v_ACCOUNT_PRODUCT ACCOUNT_PRODUCT%ROWTYPE;
v_END_DATE DATE;
v_INITIAL BOOLEAN;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- UPDATE THE CURRENT ACCOUNT PRODUCT ASSIGNMENT IF ONE EXISTS

	UPDATE ACCOUNT_PRODUCT SET
		CASE_ID = p_CASE_ID,
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		PRODUCT_ID = p_PRODUCT_ID,
		PRODUCT_TYPE = NVL(p_PRODUCT_TYPE,GA.UNDEFINED_ATTRIBUTE),
		ENTRY_DATE = SYSDATE
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND CASE_ID = p_OLD_CASE_ID
		AND PRODUCT_ID = p_OLD_PRODUCT_ID
		AND PRODUCT_TYPE = p_OLD_PRODUCT_TYPE
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS ACCOUNT AND PRODUCT COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO ACCOUNT_PRODUCT
			(
			CASE_ID,
			ACCOUNT_ID,
			PRODUCT_ID,
			PRODUCT_TYPE,
			BEGIN_DATE,
			END_DATE,
			ENTRY_DATE
			)
		VALUES
			(
			p_CASE_ID,
			p_ACCOUNT_ID,
			p_PRODUCT_ID,
			NVL(p_PRODUCT_TYPE,GA.UNDEFINED_ATTRIBUTE),
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			SYSDATE
			);
	END IF;

	OPEN c_ACCOUNT_PRODUCT;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_ACCOUNT_PRODUCT INTO v_ACCOUNT_PRODUCT;
		EXIT WHEN c_ACCOUNT_PRODUCT%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_ACCOUNT_PRODUCT.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE ACCOUNT_PRODUCT
		SET END_DATE = GREATEST(v_END_DATE, v_ACCOUNT_PRODUCT.BEGIN_DATE)
		WHERE ACCOUNT_ID = v_ACCOUNT_PRODUCT.ACCOUNT_ID
			AND CASE_ID = v_ACCOUNT_PRODUCT.CASE_ID
			AND PRODUCT_ID = v_ACCOUNT_PRODUCT.PRODUCT_ID
			AND PRODUCT_TYPE = v_ACCOUNT_PRODUCT.PRODUCT_TYPE
			AND BEGIN_DATE = v_ACCOUNT_PRODUCT.BEGIN_DATE;
		v_END_DATE := v_ACCOUNT_PRODUCT.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_ACCOUNT_PRODUCT;

END PUT_ACCOUNT_PRODUCT;
----------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNT_CALENDARS
	(
	p_ACCOUNT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS


BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

   OPEN p_CURSOR FOR
		SELECT B.CASE_NAME,
			 A.CASE_ID,
			 A.BEGIN_DATE,
			 A.END_DATE,
			 A.CALENDAR_TYPE,
			 A.CALENDAR_ID,
			 C.CALENDAR_NAME,
			 A.ENTRY_DATE
		FROM ACCOUNT_CALENDAR A, CASE_LABEL B, CALENDAR C
		WHERE A.ACCOUNT_ID = p_ACCOUNT_ID
			AND B.CASE_ID = A.CASE_ID
			AND C.CALENDAR_ID = A.CALENDAR_ID
		ORDER BY 1;


END ACCOUNT_CALENDARS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_CALENDAR
	(
	p_CASE_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_CALENDAR_ID IN NUMBER,
	p_CALENDAR_TYPE IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_CASE_ID IN NUMBER,
	p_OLD_CALENDAR_ID IN NUMBER,
	p_OLD_CALENDAR_TYPE IN VARCHAR,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	)
	AS

CURSOR c_ACCOUNT_CALENDAR IS
	SELECT *
	FROM ACCOUNT_CALENDAR
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND CASE_ID = p_CASE_ID
		AND CALENDAR_TYPE = LTRIM(RTRIM(p_CALENDAR_TYPE))
	ORDER BY BEGIN_DATE DESC;

v_LAST_ACCOUNT_CALENDAR ACCOUNT_CALENDAR%ROWTYPE;
v_LAST_ACCOUNT_CALENDAR_ID NUMBER;
v_END_DATE DATE;
v_INITIAL BOOLEAN;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- Delete any existing assignments for this calendar that are completely over-ridden by this assignment.

	DELETE ACCOUNT_CALENDAR
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND CASE_ID = p_CASE_ID
		AND CALENDAR_TYPE = LTRIM(RTRIM(p_CALENDAR_TYPE))
		AND TRUNC(p_BEGIN_DATE) <= BEGIN_DATE
		AND NVL(v_END_DATE, HIGH_DATE) >= NVL(END_DATE, HIGH_DATE);

	BEGIN
		SELECT * INTO v_LAST_ACCOUNT_CALENDAR
		FROM ACCOUNT_CALENDAR
		WHERE ACCOUNT_ID = p_ACCOUNT_ID
			AND CASE_ID = p_CASE_ID
			AND CALENDAR_ID = p_CALENDAR_ID
			AND CALENDAR_TYPE = p_CALENDAR_TYPE
			AND BEGIN_DATE <= p_BEGIN_DATE
			AND BEGIN_DATE =
				(SELECT MAX(BEGIN_DATE)
				FROM ACCOUNT_CALENDAR
				WHERE ACCOUNT_ID = p_ACCOUNT_ID
					AND CASE_ID = p_CASE_ID  --Need CASE_ID in subquery
					AND CALENDAR_ID = p_CALENDAR_ID
					AND CALENDAR_TYPE = p_CALENDAR_TYPE);

		v_LAST_ACCOUNT_CALENDAR_ID := v_LAST_ACCOUNT_CALENDAR.CALENDAR_ID;
	EXCEPTION
		WHEN OTHERS THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			v_LAST_ACCOUNT_CALENDAR_ID := -1;
	END;

	IF(v_LAST_ACCOUNT_CALENDAR_ID = p_CALENDAR_ID) THEN
		UPDATE ACCOUNT_CALENDAR
		SET END_DATE = p_END_DATE
		WHERE ACCOUNT_ID = p_ACCOUNT_ID
			AND CALENDAR_ID = p_CALENDAR_ID
			AND CALENDAR_TYPE = p_CALENDAR_TYPE
			AND CASE_ID = p_CASE_ID
			AND BEGIN_DATE = v_LAST_ACCOUNT_CALENDAR.BEGIN_DATE;
	ELSE
		INSERT INTO ACCOUNT_CALENDAR(
			CASE_ID,
			ACCOUNT_ID,
			CALENDAR_ID,
			CALENDAR_TYPE,
			BEGIN_DATE,
			END_DATE,
			ENTRY_DATE)
		VALUES(
			p_CASE_ID,
			p_ACCOUNT_ID,
			p_CALENDAR_ID,
			LTRIM(RTRIM(p_CALENDAR_TYPE)),
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			SYSDATE);
	END IF;

	v_INITIAL := TRUE;
	FOR v_ACCOUNT_CALENDAR IN c_ACCOUNT_CALENDAR LOOP
		IF v_INITIAL THEN
			v_END_DATE := v_ACCOUNT_CALENDAR.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE ACCOUNT_CALENDAR
		SET END_DATE = GREATEST(v_END_DATE, v_ACCOUNT_CALENDAR.BEGIN_DATE)
		WHERE ACCOUNT_ID = v_ACCOUNT_CALENDAR.ACCOUNT_ID
			AND CASE_ID = v_ACCOUNT_CALENDAR.CASE_ID
			AND CALENDAR_ID = v_ACCOUNT_CALENDAR.CALENDAR_ID
			AND CALENDAR_TYPE = v_ACCOUNT_CALENDAR.CALENDAR_TYPE
			AND BEGIN_DATE = v_ACCOUNT_CALENDAR.BEGIN_DATE;
		v_END_DATE := v_ACCOUNT_CALENDAR.BEGIN_DATE - 1;
	END LOOP;

END PUT_ACCOUNT_CALENDAR;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_SERVICE_LOCATION
	(
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_EDC_IDENTIFIER IN VARCHAR,
	p_ESP_IDENTIFIER IN VARCHAR,
	p_OLD_SERVICE_LOCATION_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	)
	AS

CURSOR c_ACCOUNT_SERVICE_LOCATION IS
	SELECT *
	FROM ACCOUNT_SERVICE_LOCATION
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
	ORDER BY BEGIN_DATE DESC;

v_ACCOUNT_SERVICE_LOCATION ACCOUNT_SERVICE_LOCATION%ROWTYPE;
v_END_DATE DATE;
v_INITIAL BOOLEAN;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- UPDATE THE CURRENT ACCOUNT SERVICE_LOCATION ASSIGNMENT IF ONE EXISTS

	UPDATE ACCOUNT_SERVICE_LOCATION SET
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID,
		EDC_IDENTIFIER = p_EDC_IDENTIFIER,
		ESP_IDENTIFIER = p_ESP_IDENTIFIER,
		ENTRY_DATE = SYSDATE
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND SERVICE_LOCATION_ID = p_OLD_SERVICE_LOCATION_ID
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS ACCOUNT AND SERVICE_LOCATION COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO ACCOUNT_SERVICE_LOCATION
			(
			ACCOUNT_ID,
			SERVICE_LOCATION_ID,
			BEGIN_DATE,
			END_DATE,
			EDC_IDENTIFIER,
			ESP_IDENTIFIER,
			ENTRY_DATE
			)
		VALUES
			(
			p_ACCOUNT_ID,
			p_SERVICE_LOCATION_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			NVL(p_EDC_IDENTIFIER,GA.UNDEFINED_ATTRIBUTE),
			NVL(p_ESP_IDENTIFIER,GA.UNDEFINED_ATTRIBUTE),
			SYSDATE
			);
	END IF;

	OPEN c_ACCOUNT_SERVICE_LOCATION;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_ACCOUNT_SERVICE_LOCATION INTO v_ACCOUNT_SERVICE_LOCATION;
		EXIT WHEN c_ACCOUNT_SERVICE_LOCATION%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_ACCOUNT_SERVICE_LOCATION.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE ACCOUNT_SERVICE_LOCATION
		SET END_DATE = GREATEST(v_END_DATE, v_ACCOUNT_SERVICE_LOCATION.BEGIN_DATE)
		WHERE ACCOUNT_ID = v_ACCOUNT_SERVICE_LOCATION.ACCOUNT_ID
			AND SERVICE_LOCATION_ID = v_ACCOUNT_SERVICE_LOCATION.SERVICE_LOCATION_ID
			AND BEGIN_DATE = v_ACCOUNT_SERVICE_LOCATION.BEGIN_DATE;
		v_END_DATE := v_ACCOUNT_SERVICE_LOCATION.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_ACCOUNT_SERVICE_LOCATION;

END PUT_ACCOUNT_SERVICE_LOCATION;
----------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNT_USAGE_FACTORS
	(
	p_ACCOUNT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS


BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

   OPEN p_CURSOR FOR
		SELECT B.CASE_NAME,
			 A.CASE_ID,
			 A.BEGIN_DATE,
			 A.END_DATE,
			 A.FACTOR_VAL,
			 A.ENTRY_DATE
		FROM ACCOUNT_USAGE_FACTOR A, CASE_LABEL B
		WHERE A.ACCOUNT_ID = p_ACCOUNT_ID
			AND B.CASE_ID = A.CASE_ID
		ORDER BY 1;


END ACCOUNT_USAGE_FACTORS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_USAGE_FACTOR
	(
	p_CASE_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_FACTOR_VAL IN NUMBER,
	p_OLD_CASE_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	)
	AS

CURSOR c_ACCOUNT_USAGE_FACTOR IS
	SELECT *
	FROM ACCOUNT_USAGE_FACTOR
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND CASE_ID = p_CASE_ID
	ORDER BY BEGIN_DATE DESC;

v_ACCOUNT_USAGE_FACTOR ACCOUNT_USAGE_FACTOR%ROWTYPE;
v_END_DATE DATE;
v_INITIAL BOOLEAN;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- UPDATE THE CURRENT ACCOUNT USAGE_FACTOR ASSIGNMENT IF ONE EXISTS

	UPDATE ACCOUNT_USAGE_FACTOR SET
		CASE_ID = p_CASE_ID,
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		FACTOR_VAL = p_FACTOR_VAL,
		ENTRY_DATE = SYSDATE
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND CASE_ID = p_OLD_CASE_ID
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS ACCOUNT AND USAGE_FACTOR COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO ACCOUNT_USAGE_FACTOR
			(
			CASE_ID,
			ACCOUNT_ID,
			BEGIN_DATE,
			END_DATE,
			FACTOR_VAL,
			ENTRY_DATE
			)
		VALUES
			(
			p_CASE_ID,
			p_ACCOUNT_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			p_FACTOR_VAL,
			SYSDATE
			);
	END IF;

	OPEN c_ACCOUNT_USAGE_FACTOR;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_ACCOUNT_USAGE_FACTOR INTO v_ACCOUNT_USAGE_FACTOR;
		EXIT WHEN c_ACCOUNT_USAGE_FACTOR%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_ACCOUNT_USAGE_FACTOR.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE ACCOUNT_USAGE_FACTOR
		SET END_DATE = GREATEST(v_END_DATE, v_ACCOUNT_USAGE_FACTOR.BEGIN_DATE)
		WHERE ACCOUNT_ID = v_ACCOUNT_USAGE_FACTOR.ACCOUNT_ID
			AND CASE_ID = v_ACCOUNT_USAGE_FACTOR.CASE_ID
			AND BEGIN_DATE = v_ACCOUNT_USAGE_FACTOR.BEGIN_DATE;
		v_END_DATE := v_ACCOUNT_USAGE_FACTOR.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_ACCOUNT_USAGE_FACTOR;

END PUT_ACCOUNT_USAGE_FACTOR;
----------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNT_LOSS_FACTORS
	(
	p_ACCOUNT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS


BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

   OPEN p_CURSOR FOR
		SELECT B.CASE_NAME,
			 A.CASE_ID,
			 A.BEGIN_DATE,
			 A.END_DATE,
			 A.LOSS_FACTOR_ID,
			 C.LOSS_FACTOR_NAME,
			 A.ENTRY_DATE
		FROM ACCOUNT_LOSS_FACTOR A, CASE_LABEL B, LOSS_FACTOR C
		WHERE A.ACCOUNT_ID = p_ACCOUNT_ID
			AND B.CASE_ID = A.CASE_ID
			AND C.LOSS_FACTOR_ID = A.LOSS_FACTOR_ID
		ORDER BY 1;


END ACCOUNT_LOSS_FACTORS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_LOSS_FACTOR
	(
	p_CASE_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_LOSS_FACTOR_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_CASE_ID IN NUMBER,
	p_OLD_LOSS_FACTOR_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	)
	AS

CURSOR c_ACCOUNT_LOSS_FACTOR IS
	SELECT *
	FROM ACCOUNT_LOSS_FACTOR
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND CASE_ID = p_CASE_ID
	ORDER BY BEGIN_DATE DESC;

v_ACCOUNT_LOSS_FACTOR ACCOUNT_LOSS_FACTOR%ROWTYPE;
v_END_DATE DATE;
v_INITIAL BOOLEAN;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- UPDATE THE CURRENT ACCOUNT LOSS_FACTOR ASSIGNMENT IF ONE EXISTS

	UPDATE ACCOUNT_LOSS_FACTOR SET
		CASE_ID = p_CASE_ID,
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		LOSS_FACTOR_ID = p_LOSS_FACTOR_ID,
		ENTRY_DATE = SYSDATE
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND CASE_ID = p_OLD_CASE_ID
		AND LOSS_FACTOR_ID = p_OLD_LOSS_FACTOR_ID
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS ACCOUNT AND LOSS_FACTOR COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO ACCOUNT_LOSS_FACTOR
			(
			CASE_ID,
			ACCOUNT_ID,
			LOSS_FACTOR_ID,
			BEGIN_DATE,
			END_DATE,
			ENTRY_DATE
			)
		VALUES
			(
			p_CASE_ID,
			p_ACCOUNT_ID,
			p_LOSS_FACTOR_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			SYSDATE
			);
	END IF;

	OPEN c_ACCOUNT_LOSS_FACTOR;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_ACCOUNT_LOSS_FACTOR INTO v_ACCOUNT_LOSS_FACTOR;
		EXIT WHEN c_ACCOUNT_LOSS_FACTOR%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_ACCOUNT_LOSS_FACTOR.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE ACCOUNT_LOSS_FACTOR
		SET END_DATE = GREATEST(v_END_DATE, v_ACCOUNT_LOSS_FACTOR.BEGIN_DATE)
		WHERE ACCOUNT_ID = v_ACCOUNT_LOSS_FACTOR.ACCOUNT_ID
			AND CASE_ID = v_ACCOUNT_LOSS_FACTOR.CASE_ID
			AND LOSS_FACTOR_ID = v_ACCOUNT_LOSS_FACTOR.LOSS_FACTOR_ID
			AND BEGIN_DATE = v_ACCOUNT_LOSS_FACTOR.BEGIN_DATE;
		v_END_DATE := v_ACCOUNT_LOSS_FACTOR.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_ACCOUNT_LOSS_FACTOR;


END PUT_ACCOUNT_LOSS_FACTOR;
----------------------------------------------------------------------------------------------------

PROCEDURE CONTRACT_LIMIT_QUANTITIES
	(
	p_CONTRACT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the CONTRACT LIMITs for the given CONTRACT.

BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;
    p_STATUS := GA.SUCCESS;
	OPEN p_CURSOR FOR
	    SELECT C.LIMIT_ID,
			L.LIMIT_NAME,
			C.BEGIN_DATE,
			C.END_DATE,
			C.LIMIT_QUANTITY,
			C.ENTRY_DATE
		FROM CONTRACT_LIMIT_QUANTITY C, CONTRACT_LIMIT L
		WHERE C.CONTRACT_ID = p_CONTRACT_ID
			AND L.LIMIT_ID = C.LIMIT_ID
		ORDER BY LIMIT_NAME,C.BEGIN_DATE;
	END CONTRACT_LIMIT_QUANTITIES;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_CONTRACT_LIMIT_QUANTITY
	(
	p_CONTRACT_ID IN NUMBER,
	p_LIMIT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_LIMIT_QUANTITY IN NUMBER,
	p_OLD_LIMIT_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	)
	AS
v_END_DATE DATE;

BEGIN
	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;
	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);
-- UPDATE THE CURRENT LIMIT ASSIGNMENT IF ONE EXISTS
	UPDATE CONTRACT_LIMIT_QUANTITY SET
		LIMIT_ID = p_LIMIT_ID,
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		LIMIT_QUANTITY = NVL(p_LIMIT_QUANTITY,0),
		ENTRY_DATE = SYSDATE
	WHERE CONTRACT_ID = p_CONTRACT_ID
		AND LIMIT_ID = p_OLD_LIMIT_ID
		AND BEGIN_DATE = p_OLD_BEGIN_DATE;

-- NO UPDATE FOR THIS ACCOUNT CONTRACT SO INSERT A NEW ONE.
	IF SQL%NOTFOUND THEN
		INSERT INTO CONTRACT_LIMIT_QUANTITY
			(
			CONTRACT_ID,
			LIMIT_ID,
			BEGIN_DATE,
			END_DATE,
			LIMIT_QUANTITY,
			ENTRY_DATE
			)
		VALUES
			(
			p_CONTRACT_ID,
			p_LIMIT_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			NVL(p_LIMIT_QUANTITY,0),
			SYSDATE
			);
	END IF;

	END PUT_CONTRACT_LIMIT_QUANTITY;
----------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNT_CONTRACTS
	(
	p_ACCOUNT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the CONTRACTs for the given ACCOUNT.

BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;
    p_STATUS := GA.SUCCESS;

	 OPEN p_CURSOR FOR
	    SELECT A.CONTRACT_ID,
			B.CONTRACT_NAME,
			A.BEGIN_DATE,
			A.END_DATE,
			A.ENTRY_DATE
		FROM CONTRACT_ASSIGNMENT A, SERVICE_CONTRACT B
		WHERE	A.ENTITY_DOMAIN_ID = EC.ED_ACCOUNT
			AND A.OWNER_ENTITY_ID = p_ACCOUNT_ID
			AND A.CONTRACT_ID = B.CONTRACT_ID
		ORDER BY 2,3;

	END ACCOUNT_CONTRACTS;
---------------------------------------------------------------------------------------------------
PROCEDURE CONTRACT_ASSIGNMENTS
	(
	p_CONTRACT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the ENTITIEs for the given CONTRACT.

BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;
    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT A.ENTITY_DOMAIN_ID,
		 	NVL(B.DISPLAY_NAME,B.ENTITY_DOMAIN_NAME) "ENTITY_DOMAIN_NAME",
			A.OWNER_ENTITY_ID,
			A.ENTITY_NAME,
			A.BEGIN_DATE,
			A.END_DATE,
			A.ENTRY_DATE
		FROM CONTRACT_ASSIGNMENT A, ENTITY_DOMAIN B
		WHERE A.CONTRACT_ID = p_CONTRACT_ID
			AND A.ENTITY_DOMAIN_ID = B.ENTITY_DOMAIN_ID
		ORDER BY 1,2,3;


END CONTRACT_ASSIGNMENTS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_CONTRACT_ASSIGNMENT
	(
	p_CONTRACT_ID IN NUMBER,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_OWNER_ENTITY_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ENTITY_NAME IN VARCHAR,
	p_OLD_CONTRACT_ID IN NUMBER,
	p_OLD_ENTITY_DOMAIN_ID IN NUMBER,
	p_OLD_OWNER_ENTITY_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	)
	AS
v_END_DATE DATE;
BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;
	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);
-- UPDATE THE CURRENT CONTACT ENTITY ASSIGNMENT IF ONE EXISTS
	UPDATE CONTRACT_ASSIGNMENT SET
		CONTRACT_ID = p_CONTRACT_ID,
		ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID,
		OWNER_ENTITY_ID = p_OWNER_ENTITY_ID,
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		ENTITY_NAME = LTRIM(RTRIM(p_ENTITY_NAME)),
		ENTRY_DATE = SYSDATE
	WHERE CONTRACT_ID = p_OLD_CONTRACT_ID
		AND ENTITY_DOMAIN_ID = p_OLD_ENTITY_DOMAIN_ID
		AND OWNER_ENTITY_ID = p_OLD_OWNER_ENTITY_ID
		AND BEGIN_DATE = p_OLD_BEGIN_DATE;

-- NO UPDATE FOR THIS CONTRACT SO INSERT A NEW ONE.
	IF SQL%NOTFOUND THEN
		INSERT INTO CONTRACT_ASSIGNMENT
			(
			CONTRACT_ID,
			ENTITY_DOMAIN_ID,
			OWNER_ENTITY_ID,
			BEGIN_DATE,
			END_DATE,
			ENTITY_NAME,
			ENTRY_DATE
			)
		VALUES
			(
			p_CONTRACT_ID,
			p_ENTITY_DOMAIN_ID,
			p_OWNER_ENTITY_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			LTRIM(RTRIM(p_ENTITY_NAME)),
			SYSDATE
			);
	END IF;

	END PUT_CONTRACT_ASSIGNMENT;
----------------------------------------------------------------------------------------------------
PROCEDURE BILL_CYCLE_PERIODS
	(
	p_BILL_CYCLE_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the CONTRACTs for the given ACCOUNT.

BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;
    p_STATUS := GA.SUCCESS;

	 OPEN p_CURSOR FOR
	    SELECT BILL_CYCLE_ID, BILL_CYCLE_MONTH, BEGIN_DATE, END_DATE, ENTRY_DATE
		FROM BILL_CYCLE_PERIOD
		WHERE	BILL_CYCLE_ID = p_BILL_CYCLE_ID
		ORDER BY 2,3;

	END BILL_CYCLE_PERIODS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_BILL_CYCLE_PERIOD
	(
	p_BILL_CYCLE_ID IN NUMBER,
	p_BILL_CYCLE_MONTH IN DATE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_BILL_CYCLE_MONTH IN DATE,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	)AS

v_END_DATE DATE;
BEGIN
	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;
	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- UPDATE THE CURRENT BILL PERIOD INTERVAL ASSIGNMENT IF ONE EXISTS
	UPDATE BILL_CYCLE_PERIOD SET
		BILL_CYCLE_MONTH = TRUNC(p_BILL_CYCLE_MONTH,'MM'),
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		ENTRY_DATE = SYSDATE
	WHERE BILL_CYCLE_ID = p_BILL_CYCLE_ID
		AND BILL_CYCLE_MONTH = p_OLD_BILL_CYCLE_MONTH
		AND BEGIN_DATE = p_OLD_BEGIN_DATE;


-- NO UPDATE FOR THIS BILL PERIOD INTERVAL SO INSERT A NEW ONE.
	IF SQL%NOTFOUND THEN
		INSERT INTO BILL_CYCLE_PERIOD (
			BILL_CYCLE_ID,
			BILL_CYCLE_MONTH,
			BEGIN_DATE,
			END_DATE,
			ENTRY_DATE)
		VALUES (
			p_BILL_CYCLE_ID,
			TRUNC(p_BILL_CYCLE_MONTH,'MM'),
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			SYSDATE);
	END IF;

END PUT_BILL_CYCLE_PERIOD;
------------------------------------------------------------------------------------------------
PROCEDURE PUT_PSE_ESP
	(
	p_ESP_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_PSE_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	P_STATUS OUT NUMBER
	)
	AS

CURSOR c_PSE_ESP IS
	SELECT *
	FROM PSE_ESP
	WHERE ESP_ID = p_ESP_ID
	ORDER BY BEGIN_DATE DESC;

v_PSE_ESP PSE_ESP%ROWTYPE;
v_END_DATE DATE;
v_INITIAL BOOLEAN;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- UPDATE THE CURRENT ESP SC ASSIGNMENT IF ONE EXISTS

	UPDATE PSE_ESP SET
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		ENTRY_DATE = SYSDATE,
		PSE_ID = p_PSE_ID
	WHERE ESP_ID = p_ESP_ID
		AND PSE_ID = p_OLD_PSE_ID
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS ESP SC COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO PSE_ESP
			(
			ESP_ID,
			PSE_ID,
			BEGIN_DATE,
			END_DATE,
			ENTRY_DATE
			)
		VALUES
			(
			p_ESP_ID,
			p_PSE_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			SYSDATE
			);
	END IF;

	OPEN c_PSE_ESP;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_PSE_ESP INTO v_PSE_ESP;
		EXIT WHEN c_PSE_ESP%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_PSE_ESP.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE PSE_ESP
		SET END_DATE = GREATEST(v_END_DATE, v_PSE_ESP.BEGIN_DATE)
		WHERE ESP_ID = v_PSE_ESP.ESP_ID
			AND PSE_ID = v_PSE_ESP.PSE_ID
			AND BEGIN_DATE = v_PSE_ESP.BEGIN_DATE;
		v_END_DATE := v_PSE_ESP.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_PSE_ESP;


END PUT_PSE_ESP;

----------------------------------------------------------------------------------------------------

PROCEDURE PUT_ESP_POOL
	(
	p_POOL_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_ESP_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	P_STATUS OUT NUMBER
	)
	AS

CURSOR c_ESP_POOL IS
	SELECT *
	FROM ESP_POOL
	WHERE POOL_ID = p_POOL_ID
	ORDER BY BEGIN_DATE DESC;

v_ESP_POOL ESP_POOL%ROWTYPE;
v_END_DATE DATE;
v_INITIAL BOOLEAN;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- UPDATE THE CURRENT ESP SC ASSIGNMENT IF ONE EXISTS

	UPDATE ESP_POOL SET
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		ENTRY_DATE = SYSDATE,
		ESP_ID = p_ESP_ID
	WHERE POOL_ID = p_POOL_ID
		AND ESP_ID = p_OLD_ESP_ID
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS ESP SC COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO ESP_POOL
			(
			POOL_ID,
			ESP_ID,
			BEGIN_DATE,
			END_DATE,
			ENTRY_DATE
			)
		VALUES
			(
			p_POOL_ID,
			p_ESP_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			SYSDATE
			);
	END IF;

	OPEN c_ESP_POOL;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_ESP_POOL INTO v_ESP_POOL;
		EXIT WHEN c_ESP_POOL%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_ESP_POOL.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE ESP_POOL
		SET END_DATE = GREATEST(v_END_DATE, v_ESP_POOL.BEGIN_DATE)
		WHERE POOL_ID = v_ESP_POOL.POOL_ID
			AND ESP_ID = v_ESP_POOL.ESP_ID
			AND BEGIN_DATE = v_ESP_POOL.BEGIN_DATE;
		v_END_DATE := v_ESP_POOL.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_ESP_POOL;


END PUT_ESP_POOL;

----------------------------------------------------------------------------------------------------

PROCEDURE PUT_EDC_RATE_CLASS
	(
	p_EDC_ID IN NUMBER,
	p_RATE_CLASS IN VARCHAR,
	p_OLD_RATE_CLASS IN VARCHAR,
	p_STATUS OUT NUMBER
	)
	AS

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

-- UPDATE THE CURRENT ASSIGNMENT IF ONE EXISTS

	UPDATE EDC_RATE_CLASS SET
		RATE_CLASS = LTRIM(RTRIM(NVL(p_RATE_CLASS,GA.UNDEFINED_ATTRIBUTE)))
	WHERE EDC_ID = p_EDC_ID
		AND LTRIM(RTRIM(UPPER(RATE_CLASS))) = LTRIM(RTRIM(UPPER(p_OLD_RATE_CLASS)));

-- NO ASSIGNMENT UPDATE FOR THIS COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO EDC_RATE_CLASS
			(
			EDC_ID,
			RATE_CLASS
			)
		VALUES
			(
			p_EDC_ID,
			LTRIM(RTRIM(NVL(p_RATE_CLASS,GA.UNDEFINED_ATTRIBUTE)))
			);
	END IF;


END PUT_EDC_RATE_CLASS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_AGGREGATE_ACCOUNT
	(
	p_AGGREGATE_ID IN NUMBER,
	p_DATE IN DATE,
	p_VALUE IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

v_AS_OF_DATE DATE;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	IF GA.VERSION_AGGREGATE_ACCOUNT_SVC THEN
		v_AS_OF_DATE := SYSDATE;
	ELSE
		v_AS_OF_DATE := LOW_DATE;
	END IF;

-- UPDATE THE CURRENT ASSIGNMENT IF ONE EXISTS
	UPDATE AGGREGATE_ACCOUNT_SERVICE A SET
		SERVICE_ACCOUNTS = p_VALUE
	WHERE AGGREGATE_ID = p_AGGREGATE_ID
		AND SERVICE_DATE = p_DATE
		AND AS_OF_DATE =
			(SELECT AS_OF_DATE
			FROM AGGREGATE_ACCOUNT_SERVICE
			WHERE AGGREGATE_ID = A.AGGREGATE_ID
				AND SERVICE_DATE = A.SERVICE_DATE
				AND AS_OF_DATE <= v_AS_OF_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS COMBINATION SO INSERT A NEW ASSIGNMENT
	IF SQL%NOTFOUND THEN
		INSERT INTO AGGREGATE_ACCOUNT_SERVICE
			(
			AGGREGATE_ID,
			SERVICE_DATE,
			AS_OF_DATE,
			SERVICE_ACCOUNTS
			)
		VALUES
			(
			p_AGGREGATE_ID,
			p_DATE,
			v_AS_OF_DATE,
			p_VALUE
			);
	END IF;

	END PUT_AGGREGATE_ACCOUNT;
---------------------------------------------------------------------------------------------------
PROCEDURE NAVIGATE_ACCOUNT_ENTITY
	(
	p_SOURCE_ID IN NUMBER,
	p_DIRECTION IN VARCHAR,
	p_DESTINATION_ID OUT NUMBER,
	p_FIRST_OR_LAST OUT VARCHAR
	) AS

-- Navigate thru the retail account by name sort order.
-- 	  NEXT - next account in sort order; if last record then return self.
-- 	  PRIOR - prior account name in sort order; if first record then return self.
--	  FIRST - first account name in sort order.
--	  LAST - last account name in sort order.

v_DIRECTION VARCHAR(16);
v_TMP_ID NUMBER(9);
v_TMP VARCHAR(16);

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

--FIRST_OR_LAST RETURNS 'FIRST' IF THIS IS THE FIRST RECORD, OR 'LAST' IF THIS IS THE LAST RECORD.
	p_FIRST_OR_LAST := '';

	BEGIN
		v_DIRECTION := UPPER(LTRIM(RTRIM(p_DIRECTION)));
		IF v_DIRECTION = 'NEXT' THEN
	 		SELECT ACCOUNT_ID
			INTO p_DESTINATION_ID
			FROM ACCOUNT A
			WHERE A.ACCOUNT_NAME || TO_CHAR(A.ACCOUNT_ID) =
				(
				SELECT DISTINCT MIN(B.ACCOUNT_NAME || TO_CHAR(B.ACCOUNT_ID))
				FROM ACCOUNT B
				WHERE B.ACCOUNT_NAME || TO_CHAR(B.ACCOUNT_ID) >
					(
					SELECT C.ACCOUNT_NAME || TO_CHAR(C.ACCOUNT_ID)
					FROM ACCOUNT C
					WHERE C.ACCOUNT_ID = p_SOURCE_ID
					)
				);


		ELSIF v_DIRECTION = 'PRIOR' THEN
		 	SELECT ACCOUNT_ID
			INTO p_DESTINATION_ID
			FROM ACCOUNT A
			WHERE A.ACCOUNT_NAME || TO_CHAR(A.ACCOUNT_ID) =
				(
				SELECT DISTINCT MAX(B.ACCOUNT_NAME || TO_CHAR(B.ACCOUNT_ID))
				FROM ACCOUNT B
				WHERE B.ACCOUNT_NAME || TO_CHAR(B.ACCOUNT_ID) <
					(
					SELECT C.ACCOUNT_NAME || TO_CHAR(C.ACCOUNT_ID)
					FROM ACCOUNT C
					WHERE C.ACCOUNT_ID = p_SOURCE_ID
					)
				);


		ELSIF v_DIRECTION = 'FIRST' THEN
		 	SELECT ACCOUNT_ID
			INTO p_DESTINATION_ID
			FROM ACCOUNT A
			WHERE A.ACCOUNT_NAME || TO_CHAR(A.ACCOUNT_ID) =
				(
				SELECT DISTINCT MIN(B.ACCOUNT_NAME || TO_CHAR(B.ACCOUNT_ID))
				FROM ACCOUNT B
				)
			AND ROWNUM = 1;

		ELSIF v_DIRECTION = 'LAST' THEN
	 		SELECT ACCOUNT_ID
			INTO p_DESTINATION_ID
			FROM ACCOUNT A
			WHERE A.ACCOUNT_NAME || TO_CHAR(A.ACCOUNT_ID) =
				(
				SELECT DISTINCT MAX(B.ACCOUNT_NAME || TO_CHAR(B.ACCOUNT_ID))
				FROM ACCOUNT B
				)
			AND ROWNUM = 1;

		END IF;

		EXCEPTION
		 	WHEN NO_DATA_FOUND THEN
				ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
				p_DESTINATION_ID := p_SOURCE_ID;
			WHEN TOO_MANY_ROWS THEN
                ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
				p_DESTINATION_ID := p_SOURCE_ID;
		END;

		IF v_DIRECTION = 'FIRST' THEN
			p_FIRST_OR_LAST := 'FIRST';
		ELSIF v_DIRECTION = 'LAST' THEN
			p_FIRST_OR_LAST := 'LAST';
		ELSIF v_DIRECTION = 'PRIOR' THEN
			NAVIGATE_ACCOUNT_ENTITY(0,'FIRST',v_TMP_ID,v_TMP);
			IF p_DESTINATION_ID = v_TMP_ID THEN
				p_FIRST_OR_LAST := 'FIRST';
			END IF;
		ELSIF v_DIRECTION = 'NEXT' THEN
			NAVIGATE_ACCOUNT_ENTITY(0,'LAST',v_TMP_ID,v_TMP);
			IF p_DESTINATION_ID = v_TMP_ID THEN
				p_FIRST_OR_LAST := 'LAST';
			END IF;
		END IF;



END NAVIGATE_ACCOUNT_ENTITY;
---------------------------------------------------------------------------------------------------
PROCEDURE NAVIGATE_CONTRACT_ENTITY
	(
	p_SOURCE_ID IN NUMBER,
	p_DIRECTION IN VARCHAR,
	p_DESTINATION_ID OUT NUMBER,
	p_FIRST_OR_LAST OUT VARCHAR
	) AS

-- Navigate thru the retail account by name sort order.
-- 	  NEXT - next account in sort order; if last record then return self.
-- 	  PRIOR - prior account name in sort order; if first record then return self.
--	  FIRST - first account name in sort order.
--	  LAST - last account name in sort order.

v_DIRECTION VARCHAR(16);
v_TMP_ID NUMBER(9);
v_TMP VARCHAR(16);

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

--FIRST_OR_LAST RETURNS 'FIRST' IF THIS IS THE FIRST RECORD, OR 'LAST' IF THIS IS THE LAST RECORD.
	p_FIRST_OR_LAST := '';

	BEGIN
		v_DIRECTION := UPPER(LTRIM(RTRIM(p_DIRECTION)));
		IF v_DIRECTION = 'NEXT' THEN
	 		SELECT CONTRACT_ID
			INTO p_DESTINATION_ID
			FROM SERVICE_CONTRACT A
			WHERE A.CONTRACT_NAME || TO_CHAR(A.CONTRACT_ID) =
				(
				SELECT DISTINCT MIN(B.CONTRACT_NAME || TO_CHAR(B.CONTRACT_ID))
				FROM SERVICE_CONTRACT B
				WHERE B.CONTRACT_NAME || TO_CHAR(B.CONTRACT_ID) >
					(
					SELECT C.CONTRACT_NAME || TO_CHAR(C.CONTRACT_ID)
					FROM SERVICE_CONTRACT C
					WHERE C.CONTRACT_ID = p_SOURCE_ID
					)
				);


		ELSIF v_DIRECTION = 'PRIOR' THEN
		 	SELECT CONTRACT_ID
			INTO p_DESTINATION_ID
			FROM SERVICE_CONTRACT A
			WHERE A.CONTRACT_NAME || TO_CHAR(A.CONTRACT_ID) =
				(
				SELECT DISTINCT MAX(B.CONTRACT_NAME || TO_CHAR(B.CONTRACT_ID))
				FROM SERVICE_CONTRACT B
				WHERE B.CONTRACT_NAME || TO_CHAR(B.CONTRACT_ID) <
					(
					SELECT C.CONTRACT_NAME || TO_CHAR(C.CONTRACT_ID)
					FROM SERVICE_CONTRACT C
					WHERE C.CONTRACT_ID = p_SOURCE_ID
					)
				);


		ELSIF v_DIRECTION = 'FIRST' THEN
		 	SELECT CONTRACT_ID
			INTO p_DESTINATION_ID
			FROM SERVICE_CONTRACT A
			WHERE A.CONTRACT_NAME || TO_CHAR(A.CONTRACT_ID) =
				(
				SELECT DISTINCT MIN(B.CONTRACT_NAME || TO_CHAR(B.CONTRACT_ID))
				FROM SERVICE_CONTRACT B
				)
			AND ROWNUM = 1;

		ELSIF v_DIRECTION = 'LAST' THEN
	 		SELECT CONTRACT_ID
			INTO p_DESTINATION_ID
			FROM SERVICE_CONTRACT A
			WHERE A.CONTRACT_NAME || TO_CHAR(A.CONTRACT_ID) =
				(
				SELECT DISTINCT MAX(B.CONTRACT_NAME || TO_CHAR(B.CONTRACT_ID))
				FROM SERVICE_CONTRACT B
				)
			AND ROWNUM = 1;

		END IF;

		EXCEPTION
		 	WHEN NO_DATA_FOUND THEN
				ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
				p_DESTINATION_ID := p_SOURCE_ID;
			WHEN TOO_MANY_ROWS THEN
				ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
				p_DESTINATION_ID := p_SOURCE_ID;
		END;

		IF v_DIRECTION = 'FIRST' THEN
			p_FIRST_OR_LAST := 'FIRST';
		ELSIF v_DIRECTION = 'LAST' THEN
			p_FIRST_OR_LAST := 'LAST';
		ELSIF v_DIRECTION = 'PRIOR' THEN
			NAVIGATE_CONTRACT_ENTITY(0,'FIRST',v_TMP_ID,v_TMP);
			IF p_DESTINATION_ID = v_TMP_ID THEN
				p_FIRST_OR_LAST := 'FIRST';
			END IF;
		ELSIF v_DIRECTION = 'NEXT' THEN
			NAVIGATE_CONTRACT_ENTITY(0,'LAST',v_TMP_ID,v_TMP);
			IF p_DESTINATION_ID = v_TMP_ID THEN
				p_FIRST_OR_LAST := 'LAST';
			END IF;
		END IF;



END NAVIGATE_CONTRACT_ENTITY;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_ANCILLARY_SERVICE
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SERVICE_VAL IN NUMBER,
	p_OLD_ANCILLARY_SERVICE_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	)
	AS

CURSOR c_ACCOUNT_ANCILLARY_SERVICE IS
	SELECT *
	FROM ACCOUNT_ANCILLARY_SERVICE
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
	ORDER BY BEGIN_DATE DESC;

v_ACCOUNT_ANCILLARY_SERVICE ACCOUNT_ANCILLARY_SERVICE%ROWTYPE;
v_END_DATE DATE;
v_INITIAL BOOLEAN;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- UPDATE THE CURRENT ACCOUNT ANCILLARY_SERVICE ASSIGNMENT IF ONE EXISTS

	UPDATE ACCOUNT_ANCILLARY_SERVICE SET
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID,
		SERVICE_VAL = p_SERVICE_VAL,
		ENTRY_DATE = SYSDATE
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND ANCILLARY_SERVICE_ID = p_OLD_ANCILLARY_SERVICE_ID
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS ACCOUNT AND ANCILLARY_SERVICE COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO ACCOUNT_ANCILLARY_SERVICE
			(
			ACCOUNT_ID,
			ANCILLARY_SERVICE_ID,
			BEGIN_DATE,
			END_DATE,
			SERVICE_VAL,
			ENTRY_DATE
			)
		VALUES
			(
			p_ACCOUNT_ID,
			p_ANCILLARY_SERVICE_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			NVL(p_SERVICE_VAL,0),
			SYSDATE
			);
	END IF;

	OPEN c_ACCOUNT_ANCILLARY_SERVICE;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_ACCOUNT_ANCILLARY_SERVICE INTO v_ACCOUNT_ANCILLARY_SERVICE;
		EXIT WHEN c_ACCOUNT_ANCILLARY_SERVICE%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_ACCOUNT_ANCILLARY_SERVICE.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE ACCOUNT_ANCILLARY_SERVICE
		SET END_DATE = GREATEST(v_END_DATE, v_ACCOUNT_ANCILLARY_SERVICE.BEGIN_DATE)
		WHERE ACCOUNT_ID = v_ACCOUNT_ANCILLARY_SERVICE.ACCOUNT_ID
			AND ANCILLARY_SERVICE_ID = v_ACCOUNT_ANCILLARY_SERVICE.ANCILLARY_SERVICE_ID
			AND BEGIN_DATE = v_ACCOUNT_ANCILLARY_SERVICE.BEGIN_DATE;
		v_END_DATE := v_ACCOUNT_ANCILLARY_SERVICE.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_ACCOUNT_ANCILLARY_SERVICE;


END PUT_ACCOUNT_ANCILLARY_SERVICE;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_AGGREGATE_ACCOUNT_ESP
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_ESP_ID IN NUMBER,
	p_OLD_POOL_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	)
	AS

v_AGGREGATE_ID NUMBER;
v_COUNT NUMBER;

CURSOR c_AGGREGATE_ACCOUNT_ESP IS
	SELECT *
	FROM AGGREGATE_ACCOUNT_ESP
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
	AND ESP_ID = p_ESP_ID
	AND POOL_ID = p_POOL_ID
	ORDER BY BEGIN_DATE DESC;

v_AGGREGATE_ACCOUNT_ESP AGGREGATE_ACCOUNT_ESP%ROWTYPE;
v_PREV_END_DATE DATE;
v_PREV_BEGIN_DATE DATE;
v_INITIAL BOOLEAN;
v_END_DATE DATE;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- DETERMINE IF THE AGGREGATE_ACCOUNT_ID NEEDS TO BE CHANGED
	SELECT COUNT(*)
		INTO v_COUNT
		FROM AGGREGATE_ACCOUNT_ESP
		WHERE ACCOUNT_ID = p_ACCOUNT_ID
			AND ESP_ID = p_ESP_ID
			AND POOL_ID = p_POOL_ID;

	--IF THIS COMBINATION DOES NOT EXIST, THEN CREATE ANOTHER AGGREGATE_ID.
	--OTHERWISE, USE THE AGGREGATE_ID FOR THE EXISTING COMBINATION.
	IF v_COUNT = 0 THEN
		SELECT OID.NEXTVAL INTO v_AGGREGATE_ID FROM DUAL;
	ELSE
		SELECT MAX(AGGREGATE_ID)
			INTO v_AGGREGATE_ID
			FROM AGGREGATE_ACCOUNT_ESP
			WHERE ACCOUNT_ID = p_ACCOUNT_ID
				AND ESP_ID = p_ESP_ID
				AND POOL_ID = p_POOL_ID;
	END IF;


-- UPDATE THE CURRENT ACCOUNT ESP ASSIGNMENT IF ONE EXISTS

	UPDATE AGGREGATE_ACCOUNT_ESP SET
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		ESP_ID = p_ESP_ID,
		POOL_ID = p_POOL_ID,
		AGGREGATE_ID = v_AGGREGATE_ID,
		ENTRY_DATE = SYSDATE
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND ESP_ID = p_OLD_ESP_ID
		AND POOL_ID = p_OLD_POOL_ID
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS ACCOUNT AND ESP COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO AGGREGATE_ACCOUNT_ESP
			(
			ACCOUNT_ID,
			ESP_ID,
			POOL_ID,
			BEGIN_DATE,
			END_DATE,
			AGGREGATE_ID,
			ENTRY_DATE
			)
		VALUES
			(
			p_ACCOUNT_ID,
			p_ESP_ID,
			p_POOL_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			v_AGGREGATE_ID,
			SYSDATE
			);
	END IF;

	--MAKE SURE THERE'S NO OVERLAP.
	OPEN c_AGGREGATE_ACCOUNT_ESP;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_AGGREGATE_ACCOUNT_ESP INTO v_AGGREGATE_ACCOUNT_ESP;
		EXIT WHEN c_AGGREGATE_ACCOUNT_ESP%NOTFOUND;
		IF v_INITIAL THEN
			v_PREV_END_DATE := NVL(v_AGGREGATE_ACCOUNT_ESP.END_DATE,HIGH_DATE);
			v_PREV_BEGIN_DATE := v_AGGREGATE_ACCOUNT_ESP.BEGIN_DATE;
			v_INITIAL := FALSE;
		ELSIF v_AGGREGATE_ACCOUNT_ESP.BEGIN_DATE < v_PREV_END_DATE THEN
			DELETE FROM AGGREGATE_ACCOUNT_ESP WHERE
					 ACCOUNT_ID = v_AGGREGATE_ACCOUNT_ESP.ACCOUNT_ID AND
					 ESP_ID = v_AGGREGATE_ACCOUNT_ESP.ESP_ID AND
					 POOL_ID = v_AGGREGATE_ACCOUNT_ESP.POOL_ID AND
					 BEGIN_DATE = v_PREV_BEGIN_DATE;
			UPDATE AGGREGATE_ACCOUNT_ESP
			SET BEGIN_DATE = LEAST(v_PREV_BEGIN_DATE,v_AGGREGATE_ACCOUNT_ESP.BEGIN_DATE),
				 END_DATE = DECODE(GREATEST(v_PREV_END_DATE, NVL(v_AGGREGATE_ACCOUNT_ESP.END_DATE,HIGH_DATE)),HIGH_DATE,NULL,GREATEST(v_PREV_END_DATE, NVL(v_AGGREGATE_ACCOUNT_ESP.END_DATE,HIGH_DATE)))
			WHERE ACCOUNT_ID = v_AGGREGATE_ACCOUNT_ESP.ACCOUNT_ID
				AND ESP_ID = v_AGGREGATE_ACCOUNT_ESP.ESP_ID
				AND POOL_ID = v_AGGREGATE_ACCOUNT_ESP.POOL_ID
				AND BEGIN_DATE = v_AGGREGATE_ACCOUNT_ESP.BEGIN_DATE;
			v_PREV_BEGIN_DATE := LEAST(v_PREV_BEGIN_DATE,v_AGGREGATE_ACCOUNT_ESP.BEGIN_DATE);
			v_PREV_END_DATE := GREATEST(v_PREV_END_DATE, NVL(v_AGGREGATE_ACCOUNT_ESP.END_DATE,HIGH_DATE));
		ELSE
			v_PREV_BEGIN_DATE := v_AGGREGATE_ACCOUNT_ESP.BEGIN_DATE;
			v_PREV_END_DATE := NVL(v_AGGREGATE_ACCOUNT_ESP.END_DATE,HIGH_DATE);
		END IF;
	END LOOP;
	CLOSE c_AGGREGATE_ACCOUNT_ESP;



END PUT_AGGREGATE_ACCOUNT_ESP;
----------------------------------------------------------------------------------------------------
PROCEDURE EDC_LOSS_FACTORS
	(
	p_EDC_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the CASE LABELS for the given CATEGORY

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	   SELECT B.CASE_NAME, A.CASE_ID, A.BEGIN_DATE, A.END_DATE, C.LOSS_FACTOR_NAME, A.LOSS_FACTOR_ID, A.ENTRY_DATE
		FROM EDC_LOSS_FACTOR A, CASE_LABEL B, LOSS_FACTOR C
		WHERE A.EDC_ID = p_EDC_ID
			AND B.CASE_ID = A.CASE_ID
			AND C.LOSS_FACTOR_ID = A.LOSS_FACTOR_ID
		ORDER BY 1;


END EDC_LOSS_FACTORS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_EDC_LOSS_FACTOR
	(
	p_CASE_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_LOSS_FACTOR_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_CASE_ID IN NUMBER,
	p_OLD_LOSS_FACTOR_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	)
	AS

CURSOR c_EDC_LOSS_FACTOR IS
	SELECT *
	FROM EDC_LOSS_FACTOR
	WHERE EDC_ID = p_EDC_ID
		AND CASE_ID = p_CASE_ID
	ORDER BY BEGIN_DATE DESC;

v_EDC_LOSS_FACTOR EDC_LOSS_FACTOR%ROWTYPE;
v_END_DATE DATE;
v_INITIAL BOOLEAN;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- UPDATE THE CURRENT EDC LOSS_FACTOR ASSIGNMENT IF ONE EXISTS

	UPDATE EDC_LOSS_FACTOR SET
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		LOSS_FACTOR_ID = p_LOSS_FACTOR_ID,
		CASE_ID = p_CASE_ID,
		ENTRY_DATE = SYSDATE
	WHERE EDC_ID = p_EDC_ID
		AND CASE_ID = p_OLD_CASE_ID
		AND LOSS_FACTOR_ID = p_OLD_LOSS_FACTOR_ID
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS EDC AND LOSS_FACTOR COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO EDC_LOSS_FACTOR
			(
			CASE_ID,
			EDC_ID,
			LOSS_FACTOR_ID,
			BEGIN_DATE,
			END_DATE,
			ENTRY_DATE
			)
		VALUES
			(
			p_CASE_ID,
			p_EDC_ID,
			p_LOSS_FACTOR_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			SYSDATE
			);
	END IF;

	OPEN c_EDC_LOSS_FACTOR;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_EDC_LOSS_FACTOR INTO v_EDC_LOSS_FACTOR;
		EXIT WHEN c_EDC_LOSS_FACTOR%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_EDC_LOSS_FACTOR.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE EDC_LOSS_FACTOR
		SET END_DATE = GREATEST(v_END_DATE, v_EDC_LOSS_FACTOR.BEGIN_DATE)
		WHERE EDC_ID = v_EDC_LOSS_FACTOR.EDC_ID
			AND CASE_ID = v_EDC_LOSS_FACTOR.CASE_ID
			AND LOSS_FACTOR_ID = v_EDC_LOSS_FACTOR.LOSS_FACTOR_ID
			AND BEGIN_DATE = v_EDC_LOSS_FACTOR.BEGIN_DATE;
		v_END_DATE := v_EDC_LOSS_FACTOR.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_EDC_LOSS_FACTOR;


END PUT_EDC_LOSS_FACTOR;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_METER
	(
	p_ACCOUNT_ID IN NUMBER,
	p_METER_NAME IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_USAGE_FACTOR IN NUMBER,
	p_OLD_METER_NAME IN VARCHAR,
	p_STATUS OUT NUMBER
	)
	AS

v_END_DATE DATE;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- UPDATE THE CURRENT ACCOUNT AND METER ASSIGNMENT IF ONE EXISTS

	UPDATE ACCOUNT_METER SET
		METER_NAME = LTRIM(RTRIM(p_METER_NAME)),
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		USAGE_FACTOR = NVL(p_USAGE_FACTOR,0),
		ENTRY_DATE = SYSDATE
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND UPPER(METER_NAME) = LTRIM(RTRIM(UPPER(p_OLD_METER_NAME)));

-- NO ASSIGNMENT UPDATE FOR THIS  COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO ACCOUNT_METER
			(
			ACCOUNT_ID,
			METER_NAME,
			BEGIN_DATE,
			END_DATE,
			USAGE_FACTOR,
			ENTRY_DATE
			)
		VALUES
			(
			p_ACCOUNT_ID,
			LTRIM(RTRIM(p_METER_NAME)),
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			NVL(p_USAGE_FACTOR,0),
			SYSDATE
			);
	END IF;



END PUT_ACCOUNT_METER;
----------------------------------------------------------------------------------------------------
PROCEDURE SYSTEM_LOAD_AREAS
	(
	p_SYSTEM_LOAD_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the SYSTEM_LOAD_AREA's for the given SYSTEM_LOAD.

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;
	OPEN p_CURSOR FOR
	    SELECT A.SYSTEM_LOAD_ID,
	    	B.AREA_NAME,
			A.AREA_ID,
			A.OPERATION_CODE
		FROM SYSTEM_LOAD_AREA A, AREA B
		WHERE A.SYSTEM_LOAD_ID = p_SYSTEM_LOAD_ID
			AND A.AREA_ID = B.AREA_ID
		ORDER BY AREA_NAME;


END SYSTEM_LOAD_AREAS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_SYSTEM_LOAD_AREA
	(
	p_SYSTEM_LOAD_ID IN NUMBER,
	p_AREA_ID IN NUMBER,
	p_OPERATION_CODE IN CHAR,
	p_OLD_AREA_ID IN NUMBER,
	p_STATUS OUT NUMBER
	)
	AS

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

-- UPDATE THE CURRENT ASSIGNMENT IF ONE EXISTS

	UPDATE SYSTEM_LOAD_AREA SET
		AREA_ID = p_AREA_ID,
		OPERATION_CODE = NVL(p_OPERATION_CODE,GA.UNDEFINED_ATTRIBUTE)
	WHERE SYSTEM_LOAD_ID = p_SYSTEM_LOAD_ID
		AND AREA_ID = p_OLD_AREA_ID;

-- NO ASSIGNMENT UPDATE FOR THIS  COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO SYSTEM_LOAD_AREA
			(
			SYSTEM_LOAD_ID,
			AREA_ID,
			OPERATION_CODE
			)
		VALUES
			(
			p_SYSTEM_LOAD_ID,
			p_AREA_ID,
			NVL(p_OPERATION_CODE,GA.UNDEFINED_ATTRIBUTE)
			);
	END IF;



END PUT_SYSTEM_LOAD_AREA;

----------------------------------------------------------------------------------------------------

PROCEDURE TERMINATE_ACCOUNT_USAGE_FACTOR
	(
	p_ACCOUNT_ID IN NUMBER,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

-- TERMINATE THE CURRENT ACCOUNT USAGE_FACTOR ASSIGNMENT IF ONE EXISTS

	UPDATE ACCOUNT_USAGE_FACTOR A SET
		END_DATE = TRUNC(p_END_DATE),
		ENTRY_DATE = SYSDATE
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND CASE_ID = GA.BASE_CASE_ID
		AND BEGIN_DATE =
			(SELECT MAX(BEGIN_DATE)
			FROM ACCOUNT_USAGE_FACTOR
			WHERE ACCOUNT_ID = A.ACCOUNT_ID
			AND BEGIN_DATE <= p_END_DATE
			AND (END_DATE IS NULL OR END_DATE >= p_END_DATE));


END TERMINATE_ACCOUNT_USAGE_FACTOR;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_ENABLE_ESP_POOL_ASSIGNMENT
	(
	p_ENABLE_ESP_POOL_ASSIGNMENT OUT NUMBER
	) AS

BEGIN
	IF GA.ENABLE_ESP_POOL_ASSIGNMENT THEN
		p_ENABLE_ESP_POOL_ASSIGNMENT := 1;
	ELSE
		p_ENABLE_ESP_POOL_ASSIGNMENT := 0;
	END IF;

	EXCEPTION
		WHEN OTHERS THEN
			  ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			  p_ENABLE_ESP_POOL_ASSIGNMENT := 1;
END GET_ENABLE_ESP_POOL_ASSIGNMENT;
----------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNT_IMPORT_COLUMN_HEADERS
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the valid column headers for the account import.

BEGIN

    p_STATUS := GA.SUCCESS;
	OPEN p_CURSOR FOR
		SELECT SUBSTR(TEXT, INSTR(TEXT, '''') + 1, INSTR(TEXT, '''', 1, 2) - INSTR(TEXT, '''') - 1)
		FROM USER_SOURCE
		WHERE NAME = 'RA'
		AND TYPE = 'PACKAGE BODY'
		AND INSTR(TEXT, 'IF v_CURRENT_HEADER =') > 0
		AND INSTR(TEXT, '--') < 1
		AND LINE >
			 	(SELECT MIN(LINE)
				FROM USER_SOURCE
				WHERE NAME = 'RA'
				AND TYPE = 'PACKAGE BODY'
				AND INSTR(TEXT, 'ACCOUNT_IMPORT_REQUEST') > 0)
		AND LINE <
			   (SELECT MIN(LINE)
				FROM USER_SOURCE
				WHERE NAME = 'RA'
				AND TYPE = 'PACKAGE BODY'
				AND INSTR(TEXT, 'END ACCOUNT_IMPORT_REQUEST') > 0);


END ACCOUNT_IMPORT_COLUMN_HEADERS;
---------------------------------------------------------------------------------------------------

PROCEDURE PUT_ACCOUNT_SCHEDULE_GROUP
	(
	p_ACCOUNT_ID IN NUMBER,
	p_SCHEDULE_GROUP_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_SCHEDULE_GROUP_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	)
	AS

CURSOR c_ACCOUNT_SCHEDULE_GROUP IS
	SELECT *
	FROM ACCOUNT_SCHEDULE_GROUP
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
	ORDER BY BEGIN_DATE DESC;

v_ACCOUNT_SCHEDULE_GROUP ACCOUNT_SCHEDULE_GROUP%ROWTYPE;
v_END_DATE DATE;
v_INITIAL BOOLEAN;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- UPDATE THE CURRENT ACCOUNT SCHEDULE_GROUP ASSIGNMENT IF ONE EXISTS

	UPDATE ACCOUNT_SCHEDULE_GROUP SET
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		SCHEDULE_GROUP_ID = p_SCHEDULE_GROUP_ID,
		ENTRY_DATE = SYSDATE
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND SCHEDULE_GROUP_ID = p_OLD_SCHEDULE_GROUP_ID
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS ACCOUNT AND SCHEDULE_GROUP COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO ACCOUNT_SCHEDULE_GROUP
			(
			ACCOUNT_ID,
			SCHEDULE_GROUP_ID,
			BEGIN_DATE,
			END_DATE,
			ENTRY_DATE
			)
		VALUES
			(
			p_ACCOUNT_ID,
			p_SCHEDULE_GROUP_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			SYSDATE
			);
	END IF;

	OPEN c_ACCOUNT_SCHEDULE_GROUP;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_ACCOUNT_SCHEDULE_GROUP INTO v_ACCOUNT_SCHEDULE_GROUP;
		EXIT WHEN c_ACCOUNT_SCHEDULE_GROUP%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_ACCOUNT_SCHEDULE_GROUP.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE ACCOUNT_SCHEDULE_GROUP
		SET END_DATE = GREATEST(v_END_DATE, v_ACCOUNT_SCHEDULE_GROUP.BEGIN_DATE)
		WHERE ACCOUNT_ID = v_ACCOUNT_SCHEDULE_GROUP.ACCOUNT_ID
			AND SCHEDULE_GROUP_ID = v_ACCOUNT_SCHEDULE_GROUP.SCHEDULE_GROUP_ID
			AND BEGIN_DATE = v_ACCOUNT_SCHEDULE_GROUP.BEGIN_DATE;
		v_END_DATE := v_ACCOUNT_SCHEDULE_GROUP.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_ACCOUNT_SCHEDULE_GROUP;


END PUT_ACCOUNT_SCHEDULE_GROUP;
----------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNT_GROWTHS
	(
	p_ACCOUNT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the CASE LABELS for the given CATEGORY

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	   SELECT B.CASE_NAME, A.CASE_ID, A.BEGIN_DATE, A.END_DATE, C.PATTERN_NAME, A.PATTERN_ID, A.GROWTH_PCT, A.ENTRY_DATE
		FROM ACCOUNT_GROWTH A, CASE_LABEL B, GROWTH_PATTERN C
		WHERE A.ACCOUNT_ID = p_ACCOUNT_ID
			AND B.CASE_ID = A.CASE_ID
			AND C.PATTERN_ID = A.PATTERN_ID
		ORDER BY 1;


END ACCOUNT_GROWTHS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_GROWTH
	(
	p_CASE_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_PATTERN_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_GROWTH_PCT IN NUMBER,
	p_OLD_CASE_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	)
	AS

CURSOR c_ACCOUNT_GROWTH IS
	SELECT *
	FROM ACCOUNT_GROWTH
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
			AND CASE_ID = p_CASE_ID
	ORDER BY BEGIN_DATE DESC;

v_ACCOUNT_GROWTH ACCOUNT_GROWTH%ROWTYPE;
v_END_DATE DATE;
v_INITIAL BOOLEAN;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- UPDATE THE CURRENT ACCOUNT GROWTH_FACTOR ASSIGNMENT IF ONE EXISTS

	UPDATE ACCOUNT_GROWTH SET
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		CASE_ID = p_CASE_ID,
		PATTERN_ID = p_PATTERN_ID,
		GROWTH_PCT = p_GROWTH_PCT,
		ENTRY_DATE = SYSDATE
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND CASE_ID = p_OLD_CASE_ID
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS ACCOUNT AND GROWTH_FACTOR COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO ACCOUNT_GROWTH
			(
			CASE_ID,
			ACCOUNT_ID,
			PATTERN_ID,
			BEGIN_DATE,
			END_DATE,
			GROWTH_PCT,
			ENTRY_DATE
			)
		VALUES
			(
			p_CASE_ID,
			p_ACCOUNT_ID,
			p_PATTERN_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			NVL(p_GROWTH_PCT,0),
			SYSDATE
			);
	END IF;

	OPEN c_ACCOUNT_GROWTH;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_ACCOUNT_GROWTH INTO v_ACCOUNT_GROWTH;
		EXIT WHEN c_ACCOUNT_GROWTH%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_ACCOUNT_GROWTH.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE ACCOUNT_GROWTH
		SET END_DATE = GREATEST(v_END_DATE, v_ACCOUNT_GROWTH.BEGIN_DATE)
		WHERE ACCOUNT_ID = v_ACCOUNT_GROWTH.ACCOUNT_ID
			AND CASE_ID = v_ACCOUNT_GROWTH.CASE_ID
			AND BEGIN_DATE = v_ACCOUNT_GROWTH.BEGIN_DATE;
		v_END_DATE := v_ACCOUNT_GROWTH.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_ACCOUNT_GROWTH;


END PUT_ACCOUNT_GROWTH;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_STATUS
	(
	p_ACCOUNT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ACCOUNT_STATUS_NAME IN VARCHAR,
	p_ACCOUNT_IS_ACTIVE IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	)
	AS

CURSOR c_ACCOUNT_STATUS IS
	SELECT *
	FROM ACCOUNT_STATUS
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
	ORDER BY BEGIN_DATE DESC;

v_ACCOUNT_STATUS ACCOUNT_STATUS%ROWTYPE;
v_END_DATE DATE;
v_INITIAL BOOLEAN;
v_ACCOUNT_STATUS_NAME VARCHAR2(16) := LTRIM(RTRIM(NVL(p_ACCOUNT_STATUS_NAME,GA.UNDEFINED_ATTRIBUTE)));

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

	PUT_ACCOUNT_STATUS_NAME ( v_ACCOUNT_STATUS_NAME, p_ACCOUNT_IS_ACTIVE);

-- UPDATE THE CURRENT ACCOUNT STATUS ASSIGNMENT IF ONE EXISTS

	UPDATE ACCOUNT_STATUS SET
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		STATUS_NAME = v_ACCOUNT_STATUS_NAME,
		ENTRY_DATE = SYSDATE
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS ACCOUNT AND STATUS COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO ACCOUNT_STATUS
			(
			ACCOUNT_ID,
			BEGIN_DATE,
			END_DATE,
			STATUS_NAME,
			ENTRY_DATE
			)
		VALUES
			(
			p_ACCOUNT_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			v_ACCOUNT_STATUS_NAME,
			SYSDATE
			);
	END IF;

	OPEN c_ACCOUNT_STATUS;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_ACCOUNT_STATUS INTO v_ACCOUNT_STATUS;
		EXIT WHEN c_ACCOUNT_STATUS%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_ACCOUNT_STATUS.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE ACCOUNT_STATUS
		SET END_DATE = GREATEST(v_END_DATE, v_ACCOUNT_STATUS.BEGIN_DATE)
		WHERE ACCOUNT_ID = v_ACCOUNT_STATUS.ACCOUNT_ID
			AND BEGIN_DATE = v_ACCOUNT_STATUS.BEGIN_DATE;
		v_END_DATE := v_ACCOUNT_STATUS.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_ACCOUNT_STATUS;


END PUT_ACCOUNT_STATUS;
---------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNT_STATUSES
	(
	p_ACCOUNT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the CONTRACTs for the given ACCOUNT.

BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;
    p_STATUS := GA.SUCCESS;

	 OPEN p_CURSOR FOR
	    SELECT NAMES.STATUS_NAME,
		 	NAMES.IS_ACTIVE,
			STATUS.BEGIN_DATE,
			STATUS.END_DATE,
			STATUS.ENTRY_DATE
		FROM ACCOUNT_STATUS STATUS,
			ACCOUNT_STATUS_NAME NAMES
		WHERE STATUS.ACCOUNT_ID = p_ACCOUNT_ID
			AND NAMES.STATUS_NAME = STATUS.STATUS_NAME
		ORDER BY 3;

	END ACCOUNT_STATUSES;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_STATUS_NAME
	(
	p_ACCOUNT_STATUS_NAME IN VARCHAR2,
	p_IS_ACTIVE IN NUMBER
	) AS

BEGIN

	UPDATE ACCOUNT_STATUS_NAME
	SET IS_ACTIVE = p_IS_ACTIVE
	WHERE STATUS_NAME = p_ACCOUNT_STATUS_NAME;

	IF SQL%NOTFOUND THEN
			INSERT INTO ACCOUNT_STATUS_NAME (STATUS_NAME, IS_ACTIVE)
			VALUES ( p_ACCOUNT_STATUS_NAME, p_IS_ACTIVE);
	END IF;

END PUT_ACCOUNT_STATUS_NAME;
---------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNT_STATUS_NAMES
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer DISTINCT ACCOUNT STATUS NAMES

BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;
    p_STATUS := GA.SUCCESS;

	 OPEN p_CURSOR FOR
	    SELECT STATUS_NAME
		FROM ACCOUNT_STATUS_NAME
		ORDER BY 1;

	END ACCOUNT_STATUS_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_EDC_CONVERSION_FACTOR
	(
	p_EDC_ID IN NUMBER,
	p_SERVICE_AREA_ID IN NUMBER,
	p_FACTOR_CODE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_FACTOR_VAL IN NUMBER,
	p_OLD_SERVICE_AREA_ID IN NUMBER,
	p_OLD_FACTOR_CODE IN CHAR,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	)
	AS

v_END_DATE DATE;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- UPDATE THE CURRENT EDC_CONVERSION_FACTOR ASSIGNMENT IF ONE EXISTS

	UPDATE EDC_CONVERSION_FACTOR SET
		SERVICE_AREA_ID = p_SERVICE_AREA_ID,
		FACTOR_CODE = p_FACTOR_CODE,
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		FACTOR_VAL = p_FACTOR_VAL,
		ENTRY_DATE = SYSDATE
	WHERE EDC_ID = p_EDC_ID
		AND SERVICE_AREA_ID = p_OLD_SERVICE_AREA_ID
		AND FACTOR_CODE = p_OLD_FACTOR_CODE
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS EDC AND CONVERSION_FACTOR COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO EDC_CONVERSION_FACTOR
			(
			EDC_ID,
			SERVICE_AREA_ID,
			FACTOR_CODE,
			BEGIN_DATE,
			END_DATE,
			FACTOR_VAL,
			ENTRY_DATE
			)
		VALUES
			(
			p_EDC_ID,
			p_SERVICE_AREA_ID,
			p_FACTOR_CODE,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			NVL(p_FACTOR_VAL,0),
			SYSDATE
			);
	END IF;

END PUT_EDC_CONVERSION_FACTOR;
---------------------------------------------------------------------------------------------------
PROCEDURE EDC_CONVERSION_FACTORS
	(
	p_EDC_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the CONTRACTs for the given EDC.

BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;
    p_STATUS := GA.SUCCESS;

	 OPEN p_CURSOR FOR
	    SELECT A.SERVICE_AREA_ID,
			B.SERVICE_AREA_NAME,
			A.FACTOR_CODE,
			A.BEGIN_DATE,
			A.END_DATE,
			A.FACTOR_VAL,
			A.ENTRY_DATE
		FROM EDC_CONVERSION_FACTOR A, SERVICE_AREA B
		WHERE	A.EDC_ID = p_EDC_ID
			AND A.SERVICE_AREA_ID = B.SERVICE_AREA_ID
		ORDER BY 4 DESC, 2 ASC;

	END EDC_CONVERSION_FACTORS;
---------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNT_GROUP_CATEGORIES
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the DISTINCT ACCOUNT_GROUPS CATEGORIES

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;
	OPEN p_CURSOR FOR
	    SELECT DISTINCT ASSIGNMENT_CATEGORY
		FROM ACCOUNT_GROUP_ASSIGNMENT
		ORDER BY 1;


END ACCOUNT_GROUP_CATEGORIES;
---------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNT_ACCOUNT_GROUPS
	(
	p_ACCOUNT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the ACCOUNT_GROUPS FOR THE GIVEN ACCOUNT.

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;
	OPEN p_CURSOR FOR
	    SELECT A.ACCOUNT_GROUP_ID,
	    	B.ACCOUNT_GROUP_NAME,
			A.ASSIGNMENT_CATEGORY
		FROM ACCOUNT_GROUP_ASSIGNMENT A, ACCOUNT_GROUP B
		WHERE A.ACCOUNT_ID = p_ACCOUNT_ID
			AND A.ACCOUNT_GROUP_ID = B.ACCOUNT_GROUP_ID
			AND A.ACCOUNT_GROUP_ID > 0
		ORDER BY 2,3;


END ACCOUNT_ACCOUNT_GROUPS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_GROUP_ASSIGNMENT
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ACCOUNT_GROUP_ID IN NUMBER,
	p_ASSIGNMENT_CATEGORY IN VARCHAR,
	p_OLD_ACCOUNT_GROUP_ID IN NUMBER,
	p_OLD_ASSIGNMENT_CATEGORY IN VARCHAR,
	p_STATUS OUT NUMBER
	)
	AS

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

-- UPDATE THE CURRENT ACCOUNT ANCILLARY_SERVICE ASSIGNMENT IF ONE EXISTS

	UPDATE ACCOUNT_GROUP_ASSIGNMENT SET
		ACCOUNT_GROUP_ID = p_ACCOUNT_GROUP_ID,
		ASSIGNMENT_CATEGORY = p_ASSIGNMENT_CATEGORY
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND ACCOUNT_GROUP_ID = p_OLD_ACCOUNT_GROUP_ID
		AND ASSIGNMENT_CATEGORY = p_OLD_ASSIGNMENT_CATEGORY;

-- NO ASSIGNMENT UPDATE FOR THIS ACCOUNT AND ANCILLARY_SERVICE COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO ACCOUNT_GROUP_ASSIGNMENT
			(
			ACCOUNT_ID,
			ACCOUNT_GROUP_ID,
			ASSIGNMENT_CATEGORY
			)
		VALUES
			(
			p_ACCOUNT_ID,
			p_ACCOUNT_GROUP_ID,
			p_ASSIGNMENT_CATEGORY
			);
	END IF;

	END PUT_ACCOUNT_GROUP_ASSIGNMENT;
---------------------------------------------------------------------------------------------------

PROCEDURE ACCOUNT_BILL_CYCLES
	(
	p_ACCOUNT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS


BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

   OPEN p_CURSOR FOR
		SELECT A.BEGIN_DATE,
			 A.END_DATE,
			 A.BILL_CYCLE_ENTITY,
			 A.BILL_CYCLE_ID,
			 C.BILL_CYCLE_NAME,
			 A.ENTRY_DATE
		FROM ACCOUNT_BILL_CYCLE A, BILL_CYCLE C
		WHERE A.ACCOUNT_ID = p_ACCOUNT_ID
			AND C.BILL_CYCLE_ID = A.BILL_CYCLE_ID
		ORDER BY 1;


END ACCOUNT_BILL_CYCLES;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_BILL_CYCLE
	(
	p_ACCOUNT_ID IN NUMBER,
	p_BILL_CYCLE_ID IN NUMBER,
	p_BILL_CYCLE_ENTITY IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_BILL_CYCLE_ID IN NUMBER,
	p_OLD_BILL_CYCLE_ENTITY IN VARCHAR,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	)
	AS

CURSOR c_ACCOUNT_BILL_CYCLE IS
	SELECT *
	FROM ACCOUNT_BILL_CYCLE
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND BILL_CYCLE_ENTITY = p_BILL_CYCLE_ENTITY
	ORDER BY BEGIN_DATE DESC;

v_ACCOUNT_BILL_CYCLE ACCOUNT_BILL_CYCLE%ROWTYPE;
v_END_DATE DATE;
v_INITIAL BOOLEAN;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- UPDATE THE CURRENT ACCOUNT BILL_CYCLE ASSIGNMENT IF ONE EXISTS

	UPDATE ACCOUNT_BILL_CYCLE SET
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		BILL_CYCLE_ID = p_BILL_CYCLE_ID,
		BILL_CYCLE_ENTITY = NVL(p_BILL_CYCLE_ENTITY,0),
		ENTRY_DATE = SYSDATE
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND BILL_CYCLE_ID = p_OLD_BILL_CYCLE_ID
		AND BILL_CYCLE_ENTITY = p_OLD_BILL_CYCLE_ENTITY
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS ACCOUNT AND BILL_CYCLE COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO ACCOUNT_BILL_CYCLE
			(
			ACCOUNT_ID,
			BILL_CYCLE_ID,
			BILL_CYCLE_ENTITY,
			BEGIN_DATE,
			END_DATE,
			ENTRY_DATE
			)
		VALUES
			(
			p_ACCOUNT_ID,
			p_BILL_CYCLE_ID,
			NVL(p_BILL_CYCLE_ENTITY,0),
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			SYSDATE
			);
	END IF;

	OPEN c_ACCOUNT_BILL_CYCLE;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_ACCOUNT_BILL_CYCLE INTO v_ACCOUNT_BILL_CYCLE;
		EXIT WHEN c_ACCOUNT_BILL_CYCLE%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_ACCOUNT_BILL_CYCLE.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE ACCOUNT_BILL_CYCLE
		SET END_DATE = GREATEST(v_END_DATE, v_ACCOUNT_BILL_CYCLE.BEGIN_DATE)
		WHERE ACCOUNT_ID = v_ACCOUNT_BILL_CYCLE.ACCOUNT_ID
			AND BILL_CYCLE_ID = v_ACCOUNT_BILL_CYCLE.BILL_CYCLE_ID
			AND BILL_CYCLE_ENTITY = v_ACCOUNT_BILL_CYCLE.BILL_CYCLE_ENTITY
			AND BEGIN_DATE = v_ACCOUNT_BILL_CYCLE.BEGIN_DATE;
		v_END_DATE := v_ACCOUNT_BILL_CYCLE.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_ACCOUNT_BILL_CYCLE;


END PUT_ACCOUNT_BILL_CYCLE;
----------------------------------------------------------------------------------------------------

PROCEDURE ACCOUNT_BILL_PARTIES
	(
	p_ACCOUNT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS


BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

   OPEN p_CURSOR FOR
		SELECT A.BEGIN_DATE,
			 A.END_DATE,
			 A.BILL_PARTY_ID,
			 C.BILL_PARTY_NAME,
			 A.ENTRY_DATE
		FROM ACCOUNT_BILL_PARTY A, BILL_PARTY C
		WHERE A.ACCOUNT_ID = p_ACCOUNT_ID
			AND C.BILL_PARTY_ID = A.BILL_PARTY_ID
		ORDER BY 1;


END ACCOUNT_BILL_PARTIES;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_BILL_PARTY
	(
	p_ACCOUNT_ID IN NUMBER,
	p_BILL_PARTY_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_BILL_PARTY_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	)
	AS

CURSOR c_ACCOUNT_BILL_PARTY IS
	SELECT *
	FROM ACCOUNT_BILL_PARTY
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
	ORDER BY BEGIN_DATE DESC;

v_ACCOUNT_BILL_PARTY ACCOUNT_BILL_PARTY%ROWTYPE;
v_END_DATE DATE;
v_INITIAL BOOLEAN;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- UPDATE THE CURRENT ACCOUNT BILL_PARTY ASSIGNMENT IF ONE EXISTS

	UPDATE ACCOUNT_BILL_PARTY SET
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		BILL_PARTY_ID = p_BILL_PARTY_ID,
		ENTRY_DATE = SYSDATE
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND BILL_PARTY_ID = p_OLD_BILL_PARTY_ID
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS ACCOUNT AND BILL_PARTY COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO ACCOUNT_BILL_PARTY
			(
			ACCOUNT_ID,
			BILL_PARTY_ID,
			BEGIN_DATE,
			END_DATE,
			ENTRY_DATE
			)
		VALUES
			(
			p_ACCOUNT_ID,
			p_BILL_PARTY_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			SYSDATE
			);
	END IF;

	OPEN c_ACCOUNT_BILL_PARTY;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_ACCOUNT_BILL_PARTY INTO v_ACCOUNT_BILL_PARTY;
		EXIT WHEN c_ACCOUNT_BILL_PARTY%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_ACCOUNT_BILL_PARTY.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE ACCOUNT_BILL_PARTY
		SET END_DATE = GREATEST(v_END_DATE, v_ACCOUNT_BILL_PARTY.BEGIN_DATE)
		WHERE ACCOUNT_ID = v_ACCOUNT_BILL_PARTY.ACCOUNT_ID
			AND BILL_PARTY_ID = v_ACCOUNT_BILL_PARTY.BILL_PARTY_ID
			AND BEGIN_DATE = v_ACCOUNT_BILL_PARTY.BEGIN_DATE;
		v_END_DATE := v_ACCOUNT_BILL_PARTY.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_ACCOUNT_BILL_PARTY;


END PUT_ACCOUNT_BILL_PARTY;
----------------------------------------------------------------------------------------------------
PROCEDURE SERVICE_CONTRACT_NOTE_TYPES
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS


BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

   OPEN p_CURSOR FOR
		SELECT DISTINCT A.NOTE_TYPE
		FROM ENTITY_NOTE A
		WHERE A.ENTITY_DOMAIN_ID = EC.ED_CONTRACT
		ORDER BY 1;


END SERVICE_CONTRACT_NOTE_TYPES;
---------------------------------------------------------------------------------------------------
PROCEDURE SERVICE_CONTRACT_NOTE_AUTHORS
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS


BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

   OPEN p_CURSOR FOR
		SELECT DISTINCT B.USER_NAME AS NOTE_AUTHOR
		FROM ENTITY_NOTE A,
			APPLICATION_USER B
		WHERE A.ENTITY_DOMAIN_ID = EC.ED_CONTRACT
			AND B.USER_ID = A.NOTE_AUTHOR_ID
		ORDER BY 1;


END SERVICE_CONTRACT_NOTE_AUTHORS;
----------------------------------------------------------------------------------------------------

END RA;
/
