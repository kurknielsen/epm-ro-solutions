CREATE OR REPLACE PACKAGE RO AS
--Revision $Revision: 1.70 $

-- RETAIL OFFICE PUBLIC API PACKAGE

FUNCTION WHAT_VERSION RETURN VARCHAR;


PROCEDURE IS_EDC_DUNS_NUMBER
	(
	p_EDC_DUNS_NUMBER IN VARCHAR,
	p_EXISTS OUT BOOLEAN
	);

PROCEDURE IS_ESP_DUNS_NUMBER
	(
	p_ESP_DUNS_NUMBER IN VARCHAR,
	p_EXISTS OUT BOOLEAN
	);

PROCEDURE IS_ACCOUNT_EXTERNAL_IDENTIFIER
	(
	p_ACCOUNT_EXTERNAL_IDENTIFIER IN VARCHAR,
	p_EXISTS OUT BOOLEAN
	);

PROCEDURE IS_SERVICE_LOCATION
	(
	p_SERVICE_LOCATION_NAME IN VARCHAR,
	p_EXISTS OUT BOOLEAN
	);

PROCEDURE IS_EDC_RATE_CLASS
	(
	p_EDC_DUNS_NUMBER IN VARCHAR,
	p_EDC_RATE_CLASS IN VARCHAR,
	p_EXISTS OUT BOOLEAN
	);

PROCEDURE NEW_EDC_RATE_CLASS
	(
	p_EDC_DUNS_NUMBER IN VARCHAR,
	p_EDC_RATE_CLASS IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_AGGREGATE_ACCOUNT_GROWTH
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SERVICE_ACCOUNTS IN NUMBER,
	p_GROWTH_PCT IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE RENAME_ENTITY
	(
	p_ENTITY_TYPE IN VARCHAR,
	p_OLD_NAME IN VARCHAR,
	p_NEW_NAME IN VARCHAR,
	p_NEW_ALIAS IN VARCHAR,
	p_NEW_DESC IN VARCHAR,
	p_ENTITY_QUALIFIER IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_AGGREGATE_ACCOUNT_SERVICE
	(
	p_CASE_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SERVICE_ACCOUNTS IN NUMBER,
	p_USAGE_FACTOR IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_AGGREGATE_ACCOUNT_SERVICE
	(
	p_CASE_ID IN NUMBER,
	p_ACCOUNT_NAME IN VARCHAR,
	p_ESP_NAME IN VARCHAR,
	p_SERVICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SERVICE_ACCOUNTS IN NUMBER,
	p_USAGE_FACTOR IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_ESP_ACCOUNT_NUMBER
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ESP_ACCOUNT_NUMBER IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_ACCOUNT_SIC_CODE
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ACCOUNT_SIC_CODE IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_ACCOUNT_ALIAS
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ACCOUNT_ALIAS IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_SERVICE_LOCATION_ALIAS
	(
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_SERVICE_LOCATION_ALIAS IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_METER_ALIAS
	(
	p_METER_ID IN NUMBER,
	p_METER_ALIAS IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_ENTITY_ATTRIBUTE
	(
	p_ATTRIBUTE_NAME IN VARCHAR,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_OWNER_ENTITY_ID IN NUMBER,
	p_ATTRIBUTE_TYPE IN VARCHAR,
	p_ATTRIBUTE_VAL IN VARCHAR,
	p_BEGIN_DATE IN DATE := LOW_DATE,
	p_END_DATE IN DATE := HIGH_DATE
	);

PROCEDURE PUT_ENTITY_ATTRIBUTE
	(
	p_ATTRIBUTE_NAME IN VARCHAR,
	p_ENTITY_DOMAIN_ALIAS IN VARCHAR,
	p_ATTRIBUTE_TYPE IN VARCHAR,
	p_OWNER_ENTITY_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ATTRIBUTE_VAL IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_ENTITY_ADDRESS
	(
	p_ENTITY_ID IN NUMBER,
	p_ENTITY_DOMAIN_ALIAS IN VARCHAR,
	p_CATEGORY_NAME IN VARCHAR,
	p_STREET IN VARCHAR,
	p_STREET2 IN VARCHAR,
	p_CITY IN VARCHAR,
	p_STATE_CODE IN VARCHAR,
	p_POSTAL_CODE IN VARCHAR,
	p_COUNTRY_CODE IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_ENTITY_CONTACT
	(
	p_ENTITY_ID IN NUMBER,
	p_ENTITY_DOMAIN_ALIAS IN VARCHAR,
	p_CATEGORY_NAME IN VARCHAR,
	p_CONTACT_NAME IN VARCHAR,
	p_WORK_PHONE IN VARCHAR,
	p_HOME_PHONE IN VARCHAR,
	p_FAX_PHONE IN VARCHAR,
	p_CELL_PHONE IN VARCHAR,
	p_EMAIL_ADDRESS IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_ENTITY_CONTACT
	(
	p_ENTITY_ID IN NUMBER,
	p_ENTITY_DOMAIN_ALIAS IN VARCHAR,
	p_CATEGORY_NAME IN VARCHAR,
	p_CONTACT_NAME OUT VARCHAR,
	p_CONTACT_ALIAS OUT VARCHAR,
	p_WORK_PHONE OUT VARCHAR,
	p_HOME_PHONE OUT VARCHAR,
	p_FAX_PHONE OUT VARCHAR,
	p_CELL_PHONE OUT VARCHAR,
	p_EMAIL_ADDRESS OUT VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_ENTITY_ADDRESS
	(
	p_ENTITY_ID IN NUMBER,
	p_ENTITY_DOMAIN_ALIAS IN VARCHAR,
	p_CATEGORY_NAME IN VARCHAR,
	p_STREET OUT VARCHAR,
	p_CITY OUT VARCHAR,
	p_STATE_CODE OUT VARCHAR,
	p_POSTAL_CODE OUT VARCHAR,
	p_COUNTRY_CODE OUT VARCHAR,
	p_STATUS OUT NUMBER
	);

FUNCTION GET_ENTITY_ATTRIBUTE
	(
	p_ATTRIBUTE_NAME IN VARCHAR,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_OWNER_ENTITY_ID IN NUMBER,
	p_DATE IN DATE
	) RETURN VARCHAR2;

PROCEDURE GET_ENTITY_ATTRIBUTE
	(
	p_ATTRIBUTE_NAME IN VARCHAR,
	p_ENTITY_DOMAIN_ALIAS IN VARCHAR,
	p_OWNER_ENTITY_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_ATTRIBUTE_VAL OUT VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_MARKET_PRICE_VALUE
	(
	p_MARKET_PRICE_NAME IN VARCHAR,
	p_PRICE_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_PRICE_CODE IN CHAR,
	p_PRICE_BASIS IN NUMBER,
	p_PRICE IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_SERVICE_LOCATION_ESP_IDENT
	(
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_ESP_IDENTIFIER IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_METER_ESP_IDENT
	(
	p_METER_ID IN NUMBER,
	p_ESP_IDENTIFIER IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_SERVICE_LOCATION
	(
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_SERVICE_LOCATION_NAME IN VARCHAR,
	p_SERVICE_LOCATION_ALIAS IN VARCHAR,
	p_SERVICE_LOCATION_DESC IN VARCHAR,
	p_LATITUDE IN VARCHAR,
	p_LONGITUDE IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_BILL_CYCLE_NAME IN VARCHAR,
	p_SERVICE_POINT_NAME IN VARCHAR,
	p_WEATHER_STATION_NAME IN VARCHAR,
	p_BUSINESS_ROLLUP_NAME IN VARCHAR,
	p_GEOGRAPHIC_ROLLUP_NAME IN VARCHAR,
	p_CREATE_IF_NOT_FOUND IN BOOLEAN,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_METER
	(
	p_METER_ID IN NUMBER,
	p_METER_NAME IN VARCHAR,
	p_METER_ALIAS IN VARCHAR,
	p_METER_DESC IN VARCHAR,
	p_METER_EXTERNAL_IDENTIFIER IN VARCHAR,
	p_METER_STATUS IN VARCHAR,
	p_METER_INTERVAL IN VARCHAR,
	p_METER_TYPE IN VARCHAR,
	p_METER_UNIT IN VARCHAR,
	p_IS_EXTERNAL_INTERVAL_USAGE IN NUMBER,
	p_IS_EXTERNAL_BILLED_USAGE IN NUMBER,
	p_CREATE_IF_NOT_FOUND IN BOOLEAN,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_AREA_LOAD
	(
	p_AREA_ID IN NUMBER,
	p_LOAD_DATE IN DATE,
	p_LOAD_CODE IN CHAR,
	p_LOAD_VAL IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_AREA_LOAD_VALUES
	(
	p_AREA_NAME IN VARCHAR,
	p_LOAD_DATE IN VARCHAR,
	p_LOAD_CODE IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_DATE_FORMAT IN VARCHAR DEFAULT 'DD-MON-YYYY',
	p_INTERVAL IN VARCHAR DEFAULT 3600,
	p_LOAD_VALUES IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_AREA_LOAD_VALUES
	(
	p_AREA_ID IN NUMBER,
	p_LOAD_DATE IN DATE,
	p_LOAD_CODE IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_LOAD_VALUES IN OUT NOCOPY GA.NUMBER_TABLE
	);

PROCEDURE PUT_TABLE_ATTRIBUTE
    (
    p_TABLE_NAME IN VARCHAR,
    p_ATTRIBUTE IN VARCHAR,
    p_CRITERIA IN VARCHAR,
    p_MESSAGE OUT VARCHAR,
    p_STATUS OUT NUMBER
    );

PROCEDURE PUT_EXTERNAL_FORECAST
	(
	p_SERVICE_ID IN NUMBER,
	p_LOAD_DATE IN DATE,
	p_LOAD_VAL IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_EXTERNAL_FORECAST
	(
	p_SERVICE_ID IN NUMBER,
	p_LOAD_DATE IN DATE,
	p_LOAD_VAL IN NUMBER,
	p_APPLY_LOSSES IN BOOLEAN,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_SAMPLE_ID
	(
	p_SAMPLE_NAME IN VARCHAR,
	p_SAMPLE_ID OUT NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_SAMPLE_USAGE
	(
	p_SAMPLE_NAME IN VARCHAR,
	p_SAMPLE_ALIAS IN VARCHAR,
	p_SAMPLE_DESC IN VARCHAR,
	p_METER_NUMBER IN VARCHAR,
	p_ACCOUNT_NUMBER IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_SAMPLE_INTERVAL IN VARCHAR,
	p_SAMPLE_TYPE IN VARCHAR,
	p_SAMPLE_UNIT IN VARCHAR,
	p_SAMPLE_IS_EXTERNAL IN NUMBER,
	p_SAMPLE_ID OUT NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_SAMPLE_INTERVAL_USAGE
	(
	p_SAMPLE_ID IN NUMBER,
	p_SAMPLE_DATE IN DATE,
	p_USAGE IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_MARKET_PRICE_VALUES
	(
	p_EXTERNAL_IDENTIFIER IN VARCHAR,
	p_PRICE_CODE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_DATE_FORMAT IN VARCHAR,
	p_DATA_VALUES IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_ACCOUNT_MODEL_OPTION
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ACCOUNT_MODEL_OPTION IN VARCHAR
	);

PROCEDURE PUT_AGGREGATE_ACCOUNT_OPTION
	(
	p_ACCOUNT_ID IN NUMBER,
	p_AGGREGATE_ACCOUNT_OPTION IN NUMBER
	);

PROCEDURE PUT_EDC_ALIAS
	(
	p_EDC_ID IN NUMBER,
	p_EDC_ALIAS IN VARCHAR
	);

PROCEDURE PUT_EDC_DUNS_NUMBER
	(
	p_EDC_ID IN NUMBER,
	p_EDC_DUNS_NUMBER IN VARCHAR
	);

PROCEDURE PUT_ACCOUNT_EDC
	(
	p_ACCOUNT_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_EDC_ACCOUNT_NUMBER IN VARCHAR := NULL,
	p_EDC_RATE_CLASS IN VARCHAR := NULL,
	p_EDC_STRATA IN VARCHAR := NULL
	);

PROCEDURE PUT_ACCOUNT_SERVICE_LOCATION
	(
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_EDC_IDENTIFIER IN VARCHAR := NULL,
	p_ESP_IDENTIFIER IN VARCHAR := NULL
	);

PROCEDURE PUT_ACCOUNT_CALENDAR
	(
	p_ACCOUNT_ID IN NUMBER,
	p_CALENDAR_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_CALENDAR_TYPE IN VARCHAR
	);

PROCEDURE PUT_SL_WEATHER_AND_POINT
	(
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_WEATHER_STATION_NAME IN VARCHAR,
	p_SERVICE_POINT_NAME IN VARCHAR
	);

PROCEDURE BUG_MARKET_PRICE_AND_BASIS
	(
	p_REQUEST_TYPE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE GET_EDC_EXTERNAL_ID
	(
	p_EDC_DUNS_NUMBER IN VARCHAR,
	p_EDC_EXTERNAL_IDENT OUT VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_EDC_ID
	(
	p_EDC_DUNS_NUMBER IN VARCHAR,
	p_EDC_ID OUT NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_EDC_NAME
	(
	p_EDC_ID IN  NUMBER,
	p_EDC_NAME OUT VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_ESP_ID
	(
	p_ESP_DUNS_NUMBER IN VARCHAR,
	p_ESP_ID OUT NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_AGGREGATE_USAGE_FACTOR
	(
	p_ACCOUNT_ID NUMBER,
	p_ESP_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_USAGE_FACTOR OUT NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_LATEST_AGG_USAGE_FACTOR
	(
	p_ACCOUNT_ID NUMBER,
	p_ESP_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_USAGE_FACTOR OUT NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_AGGREGATE_ANCILLARY_SVC
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SERVICE_VAL IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_AGGREGATE_ACCOUNT_CUSTOMER
	(
	p_CUSTOMER_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_INCUMBENT_ID
	(
	p_INCUMBENT_TYPE IN VARCHAR,
	p_INCUMBENT_ID OUT  NUMBER
	);

PROCEDURE GET_ACCOUNT_NAME
	(
	p_ACCOUNT_ID IN  NUMBER,
	p_ACCOUNT_NAME OUT VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_ACCOUNT_NAME
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ACCOUNT_NAME IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_ESP_NAME
	(
	p_ESP_ID IN  NUMBER,
	p_ESP_NAME OUT VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_ATTRIBUTE_ID
	(
	p_ATTRIBUTE_NAME IN VARCHAR,
	p_ATTRIBUTE_ID OUT  NUMBER
	);

PROCEDURE GET_CUSTOMER_ATTRIBUTE
	(
	p_CUSTOMER_ID IN  NUMBER,
	p_ATTRIBUTE_ID IN  NUMBER,
	p_BEGIN_DATE IN DATE,
	p_ATTRIBUTE_VAL OUT VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_CUSTOMER_ATTRIBUTE
	(
	p_CUSTOMER_ID IN NUMBER,
	p_ATTRIBUTE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ATTRIBUTE_VAL IN VARCHAR,
	P_OLD_ATTRIBUTE_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE CUSTOMER_TO_AGGREGATE_ACCOUNT
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE SYNC_STATION_PARAMETER
	(
	p_STATION_PARAMETER_SYNC IN STATION_PARAMETER_SYNC_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	);

PROCEDURE SYNC_ACCOUNT
	(
	p_ACCOUNT_IDENTIFIER_TYPE IN CHAR,
	p_ACCOUNT_SYNC IN ACCOUNT_SYNC_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	);

PROCEDURE SYNC_ESP
	(
	p_ESP_IDENTIFIER_TYPE IN CHAR,
	p_ESP_SYNC IN ESP_SYNC_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	);

PROCEDURE SYNC_AREA_LOAD
	(
	p_AREA_LOAD_SYNC IN AREA_LOAD_SYNC_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	);

PROCEDURE SYNC_ACCOUNT_USAGE_FACTOR
	(
	p_ACCOUNT_IDENTIFIER_TYPE IN CHAR,
	p_SYNC_BEGIN_DATE IN DATE,
	p_SYNC_END_DATE IN DATE,
	p_ACCOUNT_USG_FACTOR_SYNC IN ACCOUNT_USG_FACTOR_SYNC_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	);

PROCEDURE SYNC_ACCOUNT_LOSS_FACTOR
	(
	p_ACCOUNT_IDENTIFIER_TYPE IN CHAR,
	p_SYNC_BEGIN_DATE IN DATE,
	p_SYNC_END_DATE IN DATE,
	p_ACCOUNT_LOSS_FACTOR_SYNC IN ACCOUNT_LOSS_FACTOR_SYNC_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	);

PROCEDURE SYNC_ACCOUNT_CALENDAR
	(
	p_ACCOUNT_IDENTIFIER_TYPE IN CHAR,
	p_SYNC_BEGIN_DATE IN DATE,
	p_SYNC_END_DATE IN DATE,
	p_ACCOUNT_CALENDAR_SYNC IN ACCOUNT_CALENDAR_SYNC_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	);

PROCEDURE SYNC_ACCOUNT_EDC
	(
	p_ACCOUNT_IDENTIFIER_TYPE IN CHAR,
	p_EDC_IDENTIFIER_TYPE IN CHAR,
	p_SYNC_BEGIN_DATE IN DATE,
	p_SYNC_END_DATE IN DATE,
	p_ACCOUNT_EDC_SYNC IN ACCOUNT_EDC_SYNC_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	);

PROCEDURE SYNC_AGGREGATE_SERVICE
	(
	p_ACCOUNT_IDENTIFIER_TYPE IN CHAR,
	p_ESP_IDENTIFIER_TYPE IN CHAR,
	p_SYNC_BEGIN_DATE IN DATE,
	p_SYNC_END_DATE IN DATE,
	p_SERVICE_SYNC IN SERVICE_SYNC_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	);

PROCEDURE SYNC_ACCOUNT_SERVICE
	(
	p_ACCOUNT_IDENTIFIER_TYPE IN CHAR,
	p_ESP_IDENTIFIER_TYPE IN CHAR,
	p_SYNC_BEGIN_DATE IN DATE,
	p_SYNC_END_DATE IN DATE,
	p_SERVICE_SYNC IN SERVICE_SYNC_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	);

PROCEDURE SYNC_ACCOUNT_USAGE_FACTOR
	(
	p_ACCOUNT_IDENTIFIER_TYPE IN CHAR,
	p_SYNC_BEGIN_DATE IN DATE,
	p_SYNC_END_DATE IN DATE,
	p_SERVICE_SYNC IN SERVICE_SYNC_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	);

PROCEDURE SYNC_ACCOUNT_ANCILLARY_SERVICE
	(
	p_ACCOUNT_IDENTIFIER_TYPE IN CHAR,
	p_SYNC_BEGIN_DATE IN DATE,
	p_SYNC_END_DATE IN DATE,
	p_ANCILLARY_SERVICE_SYNC IN ANCILLARY_SERVICE_SYNC_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	);

PROCEDURE SYNC_AGGREGATE_ANCILLARY_SVC
	(
	p_ACCOUNT_IDENTIFIER_TYPE IN CHAR,
	p_ESP_IDENTIFIER_TYPE IN CHAR,
	p_SYNC_BEGIN_DATE IN DATE,
	p_SYNC_END_DATE IN DATE,
	p_ANCILLARY_SERVICE_SYNC IN ANCILLARY_SERVICE_SYNC_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	);

PROCEDURE SYNC_HOLIDAY_OBSERVANCE
	(
	p_SYNC_BEGIN_DATE IN DATE,
	p_SYNC_END_DATE IN DATE,
	p_HOLIDAY_OBSERVANCE_SYNC IN HOLIDAY_OBSERVANCE_SYNC_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	);

PROCEDURE RETRIEVE_EXT_FORECAST_IDENT
	(
	p_MODEL_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_ACCOUNT_IDENTIFIER_TYPE IN CHAR,
	p_ESP_IDENTIFIER_TYPE IN CHAR,
	p_EXT_FORECAST_IDENT IN OUT NOCOPY EXT_FORECAST_IDENT_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	);

PROCEDURE RETRIEVE_ACCOUNT_ESP_SERVICE
	(
	p_MODEL_ID IN NUMBER,
	p_ACCOUNT_MODEL_OPTION IN VARCHAR,
	p_SERVICE_DATE IN DATE,
	p_ACCOUNT_IDENTIFIER_TYPE IN CHAR,
	p_ESP_IDENTIFIER_TYPE IN CHAR,
	p_ACCOUNT_ESP_SERVICE IN OUT NOCOPY ACCOUNT_ESP_SERVICE_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	);

PROCEDURE GET_POOL_NAME
	 (
	p_POOL_ID IN  NUMBER,
	p_POOL_NAME OUT VARCHAR,
	p_STATUS OUT NUMBER
	);

TYPE ACCOUNT_SERVICE_RECORD IS RECORD(SERVICE_ACCOUNTS NUMBER, USAGE_FACTOR NUMBER);
TYPE ACCOUNT_SERVICE_TABLE IS TABLE OF ACCOUNT_SERVICE_RECORD INDEX BY BINARY_INTEGER;

END RO;
/
CREATE OR REPLACE PACKAGE BODY RO AS
---------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
    RETURN '$Revision: 1.70 $';
END WHAT_VERSION;
----------------------------------------------------------------------------------------------------
PROCEDURE NULL_CURSOR
    (
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
		SELECT NULL FROM DUAL;

END NULL_CURSOR;
---------------------------------------------------------------------------------------------------
FUNCTION GET_CONTACT_ID
	(
	p_CONTACT_NAME IN VARCHAR2,
	p_EMAIL_ADDRESS IN VARCHAR2
	) RETURN NUMBER IS

v_CONTACT_ID NUMBER(9);
v_UNDEFINED CHAR(1) := '?';

BEGIN

	SELECT CONTACT_ID
	INTO v_CONTACT_ID
	FROM CONTACT
	WHERE CONTACT_NAME = LTRIM(RTRIM(NVL(p_CONTACT_NAME,v_UNDEFINED)));

	RETURN v_CONTACT_ID;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		SELECT OID.NEXTVAL INTO v_CONTACT_ID FROM DUAL;
		INSERT INTO CONTACT (
			CONTACT_ID,
			CONTACT_NAME,
			CONTACT_ALIAS,
			CONTACT_DESC,
			EMAIL_ADDRESS,
			FIRST_NAME,
			MIDDLE_NAME,
			LAST_NAME,
			SALUTATION,
			ENTRY_DATE)
		VALUES (
			v_CONTACT_ID,
			LTRIM(RTRIM(NVL(p_CONTACT_NAME,v_UNDEFINED))),
			GA.UNDEFINED_ATTRIBUTE,
			GA.UNDEFINED_ATTRIBUTE,
			LTRIM(RTRIM(NVL(p_EMAIL_ADDRESS,v_UNDEFINED))),
			GA.UNDEFINED_ATTRIBUTE,
			GA.UNDEFINED_ATTRIBUTE,
			GA.UNDEFINED_ATTRIBUTE,
			GA.UNDEFINED_ATTRIBUTE,
			SYSDATE);
		RETURN v_CONTACT_ID;
END GET_CONTACT_ID;
---------------------------------------------------------------------------------------------------
PROCEDURE ID_FOR_AGGREGATE_ACCOUNT_ESP
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_AGGREGATE_ID OUT NUMBER,
	p_STATUS OUT NUMBER
	) AS

-- Answer the internal id associated with the specified aggregate account and esp ids.

CURSOR c_AGGREGATE_ACCOUNT_ESP IS
	SELECT *
	FROM AGGREGATE_ACCOUNT_ESP
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND ESP_ID = p_ESP_ID
		AND POOL_ID = p_POOL_ID
	ORDER BY BEGIN_DATE DESC;

v_END_DATE DATE;
v_INITIAL BOOLEAN;

BEGIN

	p_STATUS := GA.SUCCESS;

	BEGIN
	    SELECT AGGREGATE_ID
		INTO p_AGGREGATE_ID
		FROM AGGREGATE_ACCOUNT_ESP
		WHERE ACCOUNT_ID = p_ACCOUNT_ID
		    AND ESP_ID = p_ESP_ID
			AND POOL_ID = p_POOL_ID
			AND p_SERVICE_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE);

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		    SELECT OID.NEXTVAL INTO p_AGGREGATE_ID FROM DUAL;
		    INSERT INTO AGGREGATE_ACCOUNT_ESP(
			    ACCOUNT_ID,
				ESP_ID,
				POOL_ID,
				BEGIN_DATE,
				END_DATE,
				AGGREGATE_ID,
				ENTRY_DATE)
			VALUES(
			    p_ACCOUNT_ID,
				p_ESP_ID,
				p_POOL_ID,
				TRUNC(p_SERVICE_DATE),
				NULL,
				p_AGGREGATE_ID,
				SYSDATE);

		v_INITIAL := TRUE;
		FOR v_AGGREGATE_ACCOUNT_ESP IN c_AGGREGATE_ACCOUNT_ESP LOOP
			IF v_INITIAL THEN
				v_END_DATE := v_AGGREGATE_ACCOUNT_ESP.END_DATE;
				v_INITIAL := FALSE;
			END IF;
			UPDATE AGGREGATE_ACCOUNT_ESP
			SET END_DATE = GREATEST(v_END_DATE, v_AGGREGATE_ACCOUNT_ESP.BEGIN_DATE)
			WHERE ACCOUNT_ID = p_ACCOUNT_ID
			    AND ESP_ID = p_ESP_ID
				AND POOL_ID = p_POOL_ID
				AND BEGIN_DATE = v_AGGREGATE_ACCOUNT_ESP.BEGIN_DATE;
			v_END_DATE := v_AGGREGATE_ACCOUNT_ESP.BEGIN_DATE - 1;
		END LOOP;
				END;


END ID_FOR_AGGREGATE_ACCOUNT_ESP;
----------------------------------------------------------------------------------------------------
PROCEDURE ID_FOR_AGGREGATE_ACCOUNT_ESP
	(
	p_ACCOUNT_NAME IN VARCHAR,
	p_ESP_NAME IN VARCHAR,
	p_SERVICE_DATE IN DATE,
	p_AGGREGATE_ID OUT NUMBER,
	p_STATUS OUT NUMBER
	) AS

-- Answer the internal id associated with the specified aggregate account name.

v_ACCOUNT_ID NUMBER;
v_ESP_ID NUMBER;

BEGIN

	ID.ID_FOR_ACCOUNT(p_ACCOUNT_NAME,	FALSE,	v_ACCOUNT_ID);
	ID.ID_FOR_ESP(p_ESP_NAME,	FALSE,	v_ESP_ID);

	IF v_ACCOUNT_ID <= 0 OR v_ESP_ID <= 0 THEN
		p_AGGREGATE_ID := 0;
	    p_STATUS := GA.NO_DATA_FOUND;
		RETURN;
	END IF;

	ID_FOR_AGGREGATE_ACCOUNT_ESP(v_ACCOUNT_ID, v_ESP_ID, CONSTANTS.NOT_ASSIGNED, p_SERVICE_DATE, p_AGGREGATE_ID, p_STATUS);

END ID_FOR_AGGREGATE_ACCOUNT_ESP;
----------------------------------------------------------------------------------------------------
PROCEDURE STREET_FOR_ADDRESS
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_OWNER_ENTITY_ID IN NUMBER,
	p_CATEGORY_ID IN NUMBER,
	p_STREET OUT VARCHAR
	) AS

-- ANSWER THE STREET ASSOCIATED WITH THE SPECIFIED ADDRESS OWNER

BEGIN

	SELECT STREET
	INTO p_STREET
	FROM ENTITY_DOMAIN_ADDRESS A
	WHERE A.ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID
		AND A.OWNER_ENTITY_ID = p_OWNER_ENTITY_ID
		AND A.CATEGORY_ID = p_CATEGORY_ID;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		p_STREET := NULL;
END STREET_FOR_ADDRESS;
---------------------------------------------------------------------------------------------------
PROCEDURE IS_EDC_DUNS_NUMBER
	(
	p_EDC_DUNS_NUMBER IN VARCHAR,
	p_EXISTS OUT BOOLEAN
	) AS

-- ANSWER TRUE IF THE SPECIFIED EDC DUNS NUMBER IS ASSOCIATED WITH AN EXISTING EDC ENTITY

v_EDC_DUNS_NUMBER ENERGY_DISTRIBUTION_COMPANY.EDC_DUNS_NUMBER%TYPE;

BEGIN

	SELECT EDC_DUNS_NUMBER
	INTO v_EDC_DUNS_NUMBER
	FROM ENERGY_DISTRIBUTION_COMPANY
	WHERE EDC_DUNS_NUMBER = LTRIM(RTRIM(p_EDC_DUNS_NUMBER));

	p_EXISTS := TRUE;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			p_EXISTS := FALSE;
		WHEN TOO_MANY_ROWS THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			p_EXISTS := TRUE;

END IS_EDC_DUNS_NUMBER;
----------------------------------------------------------------------------------------------------
PROCEDURE IS_ESP_DUNS_NUMBER
	(
	p_ESP_DUNS_NUMBER IN VARCHAR,
	p_EXISTS OUT BOOLEAN
	) AS

-- ANSWER TRUE IF THE SPECIFIED ESP DUNS NUMBER IS ASSOCIATED WITH AN EXISTING ESP ENTITY

v_ESP_DUNS_NUMBER ENERGY_SERVICE_PROVIDER.ESP_DUNS_NUMBER%TYPE;

BEGIN

	SELECT ESP_DUNS_NUMBER
	INTO v_ESP_DUNS_NUMBER
	FROM ENERGY_SERVICE_PROVIDER
	WHERE ESP_DUNS_NUMBER = LTRIM(RTRIM(p_ESP_DUNS_NUMBER));

	p_EXISTS := TRUE;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			p_EXISTS := FALSE;
		WHEN TOO_MANY_ROWS THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			p_EXISTS := TRUE;

END IS_ESP_DUNS_NUMBER;
----------------------------------------------------------------------------------------------------
PROCEDURE IS_ACCOUNT_EXTERNAL_IDENTIFIER
	(
	p_ACCOUNT_EXTERNAL_IDENTIFIER IN VARCHAR,
	p_EXISTS OUT BOOLEAN
	) AS

-- ANSWER TRUE IF THE SPECIFIED ACCOUNT EXTERNAL IDENTIFIER IS ASSOCIATED WITH AN EXISTING RETAIL ACCOUNT ENTITY

v_ACCOUNT_EXTERNAL_IDENTIFIER ACCOUNT.ACCOUNT_EXTERNAL_IDENTIFIER%TYPE;

BEGIN

	SELECT ACCOUNT_EXTERNAL_IDENTIFIER
	INTO v_ACCOUNT_EXTERNAL_IDENTIFIER
	FROM ACCOUNT
	WHERE ACCOUNT_EXTERNAL_IDENTIFIER = LTRIM(RTRIM(p_ACCOUNT_EXTERNAL_IDENTIFIER));

	p_EXISTS := TRUE;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			p_EXISTS := FALSE;
		WHEN TOO_MANY_ROWS THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			p_EXISTS := TRUE;

END IS_ACCOUNT_EXTERNAL_IDENTIFIER;
----------------------------------------------------------------------------------------------------
PROCEDURE IS_SERVICE_LOCATION
	(
	p_SERVICE_LOCATION_NAME IN VARCHAR,
	p_EXISTS OUT BOOLEAN
	) AS

-- ANSWER TRUE IF THE SPECIFIED NAME IS ASSOCIATED WITH AN EXISTING SERVICE LOCATION ENTITY

v_SERVICE_LOCATION_NAME SERVICE_LOCATION.SERVICE_LOCATION_NAME%TYPE;

BEGIN

	SELECT SERVICE_LOCATION_NAME
	INTO v_SERVICE_LOCATION_NAME
	FROM SERVICE_LOCATION
	WHERE SERVICE_LOCATION_NAME = LTRIM(RTRIM(p_SERVICE_LOCATION_NAME));

	p_EXISTS := TRUE;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			p_EXISTS := FALSE;
		WHEN TOO_MANY_ROWS THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			p_EXISTS := TRUE;

END IS_SERVICE_LOCATION;
----------------------------------------------------------------------------------------------------
PROCEDURE IS_EDC_RATE_CLASS
	(
	p_EDC_DUNS_NUMBER IN VARCHAR,
	p_EDC_RATE_CLASS IN VARCHAR,
	p_EXISTS OUT BOOLEAN
	) AS

-- ANSWER TRUE IF THE SPECIFIED RATE CLASS IS ASSOCIATED WITH AN EXISTING EDC ENTITY

v_RATE_CLASS EDC_RATE_CLASS.RATE_CLASS%TYPE;

BEGIN

	SELECT RATE_CLASS
	INTO v_RATE_CLASS
	FROM EDC_RATE_CLASS A
	WHERE A.EDC_ID =
		(
		SELECT X.EDC_ID
		FROM ENERGY_DISTRIBUTION_COMPANY X
		WHERE X.EDC_DUNS_NUMBER = LTRIM(RTRIM(p_EDC_DUNS_NUMBER))
		)
		AND A.RATE_CLASS = LTRIM(RTRIM(p_EDC_RATE_CLASS));

	p_EXISTS := TRUE;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			p_EXISTS := FALSE;
		WHEN TOO_MANY_ROWS THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			p_EXISTS := TRUE;

END IS_EDC_RATE_CLASS;
----------------------------------------------------------------------------------------------------
PROCEDURE NEW_EDC_RATE_CLASS
	(
	p_EDC_DUNS_NUMBER IN VARCHAR,
	p_EDC_RATE_CLASS IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

-- CREATE A NEW RATE CLASS ASSOCIATED WITH AN EXISTING EDC ENTITY

v_EDC_ID NUMBER;

BEGIN

	SELECT EDC_ID
	INTO v_EDC_ID
	FROM ENERGY_DISTRIBUTION_COMPANY
	WHERE EDC_DUNS_NUMBER = LTRIM(RTRIM(p_EDC_DUNS_NUMBER));

	INSERT INTO EDC_RATE_CLASS (EDC_ID,RATE_CLASS) VALUES(v_EDC_ID,LTRIM(RTRIM(p_EDC_RATE_CLASS)));

	p_STATUS := GA.SUCCESS;

END NEW_EDC_RATE_CLASS;
----------------------------------------------------------------------------------------------------
PROCEDURE RENAME_ENTITY
	(
	p_ENTITY_TYPE IN VARCHAR,
	p_OLD_NAME IN VARCHAR,
	p_NEW_NAME IN VARCHAR,
	p_NEW_ALIAS IN VARCHAR,
	p_NEW_DESC IN VARCHAR,
	p_ENTITY_QUALIFIER IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

-- Rename an existing entity identified by old name to new name.

v_ENTITY_ID NUMBER;
v_ENTITY_TYPE VARCHAR(32);

BEGIN

    v_ENTITY_TYPE := UPPER(LTRIM(RTRIM(p_ENTITY_TYPE)));
	p_STATUS := GA.SUCCESS;

	IF v_ENTITY_TYPE = 'ACCOUNT' THEN
	    ID.ID_FOR_ACCOUNT(p_OLD_NAME, FALSE, v_ENTITY_ID);
		IF v_ENTITY_ID > 0 THEN
		    UPDATE ACCOUNT
			SET ACCOUNT_NAME = LTRIM(RTRIM(p_NEW_NAME)),
			    ACCOUNT_ALIAS = NVL(LTRIM(RTRIM(p_NEW_ALIAS)),ACCOUNT_ALIAS),
			    ACCOUNT_DESC = NVL(LTRIM(RTRIM(p_NEW_DESC)),ACCOUNT_DESC),
				ENTRY_DATE = SYSDATE
			WHERE ACCOUNT_ID = v_ENTITY_ID;
		ELSE
		    p_STATUS := GA.NO_DATA_FOUND;
		END IF;
	ELSIF v_ENTITY_TYPE = 'CALENDAR' THEN
	    ID.ID_FOR_CALENDAR(p_OLD_NAME, FALSE, v_ENTITY_ID);
		IF v_ENTITY_ID > 0 THEN
		    UPDATE CALENDAR
			SET CALENDAR_NAME = LTRIM(RTRIM(p_NEW_NAME)),
			    CALENDAR_ALIAS = NVL(LTRIM(RTRIM(p_NEW_ALIAS)),CALENDAR_ALIAS),
			    CALENDAR_DESC = NVL(LTRIM(RTRIM(p_NEW_DESC)),CALENDAR_DESC),
				ENTRY_DATE = SYSDATE
			WHERE CALENDAR_ID = v_ENTITY_ID;
		ELSE
		    p_STATUS := GA.NO_DATA_FOUND;
		END IF;
	ELSIF v_ENTITY_TYPE = 'PROFILE' THEN
	    ID.ID_FOR_LOAD_PROFILE(p_ENTITY_QUALIFIER, p_OLD_NAME, FALSE, v_ENTITY_ID);
		IF v_ENTITY_ID > 0 THEN
		    UPDATE LOAD_PROFILE
			SET PROFILE_NAME = LTRIM(RTRIM(p_NEW_NAME)),
			    PROFILE_ALIAS = NVL(LTRIM(RTRIM(p_NEW_ALIAS)),PROFILE_ALIAS),
			    PROFILE_DESC = NVL(LTRIM(RTRIM(p_NEW_DESC)),PROFILE_DESC),
				ENTRY_DATE = SYSDATE
			WHERE PROFILE_ID = v_ENTITY_ID;
		ELSE
		    p_STATUS := GA.NO_DATA_FOUND;
		END IF;
	END IF;


END RENAME_ENTITY;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_AGGREGATE_ACCOUNT_SERVICE
	(
	p_AGGREGATE_ACCOUNT_SERVICE IN OUT AGGREGATE_ACCOUNT_SERVICE%ROWTYPE,
	p_STATUS OUT NUMBER
	) AS

-- Insert or update the service accounts associated with an aggregate account.


BEGIN

	p_STATUS := GA.SUCCESS;

	IF NOT GA.VERSION_AGGREGATE_ACCOUNT_SVC THEN
		p_AGGREGATE_ACCOUNT_SERVICE.AS_OF_DATE := LOW_DATE;
	END IF;

	UPDATE AGGREGATE_ACCOUNT_SERVICE
	SET SERVICE_ACCOUNTS = DECODE(p_AGGREGATE_ACCOUNT_SERVICE.SERVICE_ACCOUNTS, NULL, SERVICE_ACCOUNTS, p_AGGREGATE_ACCOUNT_SERVICE.SERVICE_ACCOUNTS),
	    USAGE_FACTOR = DECODE(p_AGGREGATE_ACCOUNT_SERVICE.USAGE_FACTOR, NULL, USAGE_FACTOR, p_AGGREGATE_ACCOUNT_SERVICE.USAGE_FACTOR)
	WHERE CASE_ID = p_AGGREGATE_ACCOUNT_SERVICE.CASE_ID
		AND AGGREGATE_ID = p_AGGREGATE_ACCOUNT_SERVICE.AGGREGATE_ID
	    AND SERVICE_DATE = p_AGGREGATE_ACCOUNT_SERVICE.SERVICE_DATE
	    AND AS_OF_DATE = p_AGGREGATE_ACCOUNT_SERVICE.AS_OF_DATE;

	IF SQL%NOTFOUND THEN
	    INSERT INTO AGGREGATE_ACCOUNT_SERVICE(
			CASE_ID,
		    AGGREGATE_ID,
			SERVICE_DATE,
			AS_OF_DATE,
			SERVICE_ACCOUNTS,
			USAGE_FACTOR)
		VALUES(
			p_AGGREGATE_ACCOUNT_SERVICE.CASE_ID,
		    p_AGGREGATE_ACCOUNT_SERVICE.AGGREGATE_ID,
			p_AGGREGATE_ACCOUNT_SERVICE.SERVICE_DATE,
			p_AGGREGATE_ACCOUNT_SERVICE.AS_OF_DATE,
			p_AGGREGATE_ACCOUNT_SERVICE.SERVICE_ACCOUNTS,
			p_AGGREGATE_ACCOUNT_SERVICE.USAGE_FACTOR);
	END IF;


END PUT_AGGREGATE_ACCOUNT_SERVICE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_AGGREGATE_ACCOUNT_SERVICE
	(
	p_CASE_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SERVICE_ACCOUNTS IN NUMBER,
	p_USAGE_FACTOR IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

-- Insert or update the service accounts associated with an aggregate account.

v_AGGREGATE_ACCOUNT_SERVICE AGGREGATE_ACCOUNT_SERVICE%ROWTYPE;
v_AGGREGATE_ID NUMBER;
v_SERVICE_DATE DATE;

BEGIN

	p_STATUS := GA.SUCCESS;
	v_SERVICE_DATE := TRUNC(p_SERVICE_DATE);
	ID_FOR_AGGREGATE_ACCOUNT_ESP(p_ACCOUNT_ID, p_ESP_ID, p_POOL_ID, v_SERVICE_DATE, v_AGGREGATE_ID, p_STATUS);

	IF NOT p_STATUS = GA.SUCCESS THEN
		RETURN;
	END IF;

	v_AGGREGATE_ACCOUNT_SERVICE.CASE_ID := p_CASE_ID;
	v_AGGREGATE_ACCOUNT_SERVICE.SERVICE_DATE := v_SERVICE_DATE;
	v_AGGREGATE_ACCOUNT_SERVICE.AS_OF_DATE := p_AS_OF_DATE;
	v_AGGREGATE_ACCOUNT_SERVICE.AGGREGATE_ID := v_AGGREGATE_ID;
	v_AGGREGATE_ACCOUNT_SERVICE.SERVICE_ACCOUNTS := p_SERVICE_ACCOUNTS;
	v_AGGREGATE_ACCOUNT_SERVICE.USAGE_FACTOR  := p_USAGE_FACTOR;

	PUT_AGGREGATE_ACCOUNT_SERVICE(v_AGGREGATE_ACCOUNT_SERVICE, p_STATUS);


END PUT_AGGREGATE_ACCOUNT_SERVICE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_AGGREGATE_ACCOUNT_SERVICE
	(
	p_CASE_ID IN NUMBER,
	p_ACCOUNT_NAME IN VARCHAR,
	p_ESP_NAME IN VARCHAR,
	p_SERVICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SERVICE_ACCOUNTS IN NUMBER,
	p_USAGE_FACTOR IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

-- Insert or update the service accounts associated with an aggregate account.

v_AGGREGATE_ACCOUNT_SERVICE AGGREGATE_ACCOUNT_SERVICE%ROWTYPE;
v_AGGREGATE_ID NUMBER;
v_SERVICE_DATE DATE;

BEGIN

	p_STATUS := GA.SUCCESS;
	v_SERVICE_DATE := TRUNC(p_SERVICE_DATE);
	ID_FOR_AGGREGATE_ACCOUNT_ESP(p_ACCOUNT_NAME, p_ESP_NAME, v_SERVICE_DATE, v_AGGREGATE_ID, p_STATUS);
	IF NOT p_STATUS = GA.SUCCESS THEN
		RETURN;
	END IF;

	v_AGGREGATE_ACCOUNT_SERVICE.CASE_ID := p_CASE_ID;
	v_AGGREGATE_ACCOUNT_SERVICE.SERVICE_DATE := v_SERVICE_DATE;
	v_AGGREGATE_ACCOUNT_SERVICE.AS_OF_DATE := p_AS_OF_DATE;
	v_AGGREGATE_ACCOUNT_SERVICE.AGGREGATE_ID := v_AGGREGATE_ID;
	v_AGGREGATE_ACCOUNT_SERVICE.SERVICE_ACCOUNTS := p_SERVICE_ACCOUNTS;
	v_AGGREGATE_ACCOUNT_SERVICE.USAGE_FACTOR  := p_USAGE_FACTOR;

	PUT_AGGREGATE_ACCOUNT_SERVICE(v_AGGREGATE_ACCOUNT_SERVICE, p_STATUS);


END PUT_AGGREGATE_ACCOUNT_SERVICE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_AGGREGATE_ACCOUNT_GROWTH
	(
	p_AGGREGATE_ACCOUNT_GROWTH IN OUT AGGREGATE_ACCOUNT_GROWTH%ROWTYPE,
	p_STATUS OUT NUMBER
	) AS

-- Insert or update the service account  growth associated with an aggregate account.

BEGIN

	p_STATUS := GA.SUCCESS;

	UPDATE AGGREGATE_ACCOUNT_GROWTH
	SET SERVICE_ACCOUNTS = DECODE(p_AGGREGATE_ACCOUNT_GROWTH.SERVICE_ACCOUNTS, NULL, SERVICE_ACCOUNTS, p_AGGREGATE_ACCOUNT_GROWTH.SERVICE_ACCOUNTS),
	    GROWTH_PCT = DECODE(p_AGGREGATE_ACCOUNT_GROWTH.GROWTH_PCT, NULL, GROWTH_PCT, p_AGGREGATE_ACCOUNT_GROWTH.GROWTH_PCT),
		PATTERN_ID = p_AGGREGATE_ACCOUNT_GROWTH.PATTERN_ID,
		ENTRY_DATE = SYSDATE
	WHERE CASE_ID = p_AGGREGATE_ACCOUNT_GROWTH.CASE_ID
		AND AGGREGATE_ID = p_AGGREGATE_ACCOUNT_GROWTH.AGGREGATE_ID
	    AND BEGIN_DATE = p_AGGREGATE_ACCOUNT_GROWTH.BEGIN_DATE;

	IF SQL%NOTFOUND THEN
	    INSERT INTO AGGREGATE_ACCOUNT_GROWTH(
			CASE_ID,
		    AGGREGATE_ID,
			BEGIN_DATE,
			END_DATE,
			SERVICE_ACCOUNTS,
			GROWTH_PCT,
			PATTERN_ID,
			ENTRY_DATE)
		VALUES(
			p_AGGREGATE_ACCOUNT_GROWTH.CASE_ID,
		    p_AGGREGATE_ACCOUNT_GROWTH.AGGREGATE_ID,
			p_AGGREGATE_ACCOUNT_GROWTH.BEGIN_DATE,
			p_AGGREGATE_ACCOUNT_GROWTH.END_DATE,
			p_AGGREGATE_ACCOUNT_GROWTH.SERVICE_ACCOUNTS,
			p_AGGREGATE_ACCOUNT_GROWTH.GROWTH_PCT,
			p_AGGREGATE_ACCOUNT_GROWTH.PATTERN_ID,
			SYSDATE);
	END IF;


END PUT_AGGREGATE_ACCOUNT_GROWTH;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_AGGREGATE_ACCOUNT_GROWTH
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SERVICE_ACCOUNTS IN NUMBER,
	p_GROWTH_PCT IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

-- Insert or update the service accounts associated with an aggregate account.

v_AGGREGATE_ACCOUNT_GROWTH AGGREGATE_ACCOUNT_GROWTH%ROWTYPE;
v_AGGREGATE_ID NUMBER;

BEGIN

	p_STATUS := GA.SUCCESS;

	ID_FOR_AGGREGATE_ACCOUNT_ESP(p_ACCOUNT_ID, p_ESP_ID, p_POOL_ID, p_BEGIN_DATE, v_AGGREGATE_ID, p_STATUS);

	IF NOT p_STATUS = GA.SUCCESS THEN
		RETURN;
	END IF;

	v_AGGREGATE_ACCOUNT_GROWTH.CASE_ID := GA.BASE_CASE_ID;
	v_AGGREGATE_ACCOUNT_GROWTH.BEGIN_DATE := TRUNC(p_BEGIN_DATE);
	v_AGGREGATE_ACCOUNT_GROWTH.END_DATE := TRUNC(p_END_DATE);
	v_AGGREGATE_ACCOUNT_GROWTH.AGGREGATE_ID := v_AGGREGATE_ID;
	v_AGGREGATE_ACCOUNT_GROWTH.SERVICE_ACCOUNTS := p_SERVICE_ACCOUNTS;
	v_AGGREGATE_ACCOUNT_GROWTH.GROWTH_PCT  := p_GROWTH_PCT;
	v_AGGREGATE_ACCOUNT_GROWTH.PATTERN_ID  := 2;
	PUT_AGGREGATE_ACCOUNT_GROWTH(v_AGGREGATE_ACCOUNT_GROWTH, p_STATUS);


END PUT_AGGREGATE_ACCOUNT_GROWTH;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ESP_ACCOUNT_NUMBER
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ESP_ACCOUNT_NUMBER IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

-- Update the ESP account number associated with an existing retail account entity

BEGIN

	UPDATE ACCOUNT_ESP SET
	    ESP_ACCOUNT_NUMBER = p_ESP_ACCOUNT_NUMBER,
	    ENTRY_DATE = SYSDATE
	WHERE ACCOUNT_ID = p_ACCOUNT_ID;

	p_STATUS := GA.SUCCESS;


END PUT_ESP_ACCOUNT_NUMBER;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_SIC_CODE
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ACCOUNT_SIC_CODE IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

-- Update the sic code associated with an existing retail account entity

BEGIN

	UPDATE ACCOUNT
	SET ACCOUNT_SIC_CODE = p_ACCOUNT_SIC_CODE,
	    ENTRY_DATE = SYSDATE
	WHERE ACCOUNT_ID = p_ACCOUNT_ID;

	p_STATUS := GA.SUCCESS;


END PUT_ACCOUNT_SIC_CODE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_ALIAS
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ACCOUNT_ALIAS IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

-- Update the alias associated with an existing retail account entity

BEGIN

	UPDATE ACCOUNT
	SET ACCOUNT_ALIAS = p_ACCOUNT_ALIAS,
	    ENTRY_DATE = SYSDATE
	WHERE ACCOUNT_ID = p_ACCOUNT_ID;

	p_STATUS := GA.SUCCESS;


END PUT_ACCOUNT_ALIAS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_SERVICE_LOCATION_ALIAS
	(
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_SERVICE_LOCATION_ALIAS IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

-- Update the alias associated with an existing service location entity

BEGIN

	UPDATE SERVICE_LOCATION
	SET SERVICE_LOCATION_ALIAS = p_SERVICE_LOCATION_ALIAS,
	    ENTRY_DATE = SYSDATE
	WHERE SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID;

	p_STATUS := GA.SUCCESS;


END PUT_SERVICE_LOCATION_ALIAS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_METER_ALIAS
	(
	p_METER_ID IN NUMBER,
	p_METER_ALIAS IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

-- Update the alias associated with an existing meter entity

BEGIN

	UPDATE METER
	SET METER_ALIAS = p_METER_ALIAS,
	    ENTRY_DATE = SYSDATE
	WHERE METER_ID = p_METER_ID;

	p_STATUS := GA.SUCCESS;


END PUT_METER_ALIAS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_TEMPORAL_ENTITY_ATTRIBUTE
	(
	p_OWNER_ENTITY_ID IN NUMBER,
	p_ATTRIBUTE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ATTRIBUTE_VAL IN VARCHAR
	) AS
BEGIN
	UT.PUT_TEMPORAL_DATA('TEMPORAL_ENTITY_ATTRIBUTE',
						p_BEGIN_DATE, p_END_DATE, TRUE, TRUE,
						'OWNER_ENTITY_ID', UT.GET_LITERAL_FOR_NUMBER(p_OWNER_ENTITY_ID), TRUE,
						'ATTRIBUTE_ID', UT.GET_LITERAL_FOR_NUMBER(p_ATTRIBUTE_ID), TRUE,
						'ATTRIBUTE_VAL', UT.GET_LITERAL_FOR_STRING(p_ATTRIBUTE_VAL), FALSE);
END PUT_TEMPORAL_ENTITY_ATTRIBUTE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ENTITY_ATTRIBUTE
	(
	p_ATTRIBUTE_NAME IN VARCHAR,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_OWNER_ENTITY_ID IN NUMBER,
	p_ATTRIBUTE_TYPE IN VARCHAR,
	p_ATTRIBUTE_VAL IN VARCHAR,
	p_BEGIN_DATE IN DATE := LOW_DATE,
	p_END_DATE IN DATE := HIGH_DATE
	) AS

v_ATTRIBUTE_ID NUMBER;
v_ATTRIBUTE_NAME VARCHAR(64);
v_ATTRIBUTE_TYPE VARCHAR(16);

BEGIN

	v_ATTRIBUTE_NAME := LTRIM(RTRIM(p_ATTRIBUTE_NAME));
	v_ATTRIBUTE_TYPE := INITCAP(LOWER(LTRIM(RTRIM(p_ATTRIBUTE_TYPE))));
	ID.ID_FOR_ENTITY_ATTRIBUTE(v_ATTRIBUTE_NAME, p_ENTITY_DOMAIN_ID, v_ATTRIBUTE_TYPE, v_ATTRIBUTE_ID);

	IF v_ATTRIBUTE_ID <= 0 THEN
		ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY,'Attribute with Name = ' || v_ATTRIBUTE_NAME);
	END IF;

	PUT_TEMPORAL_ENTITY_ATTRIBUTE(p_OWNER_ENTITY_ID, v_ATTRIBUTE_ID, p_BEGIN_DATE, p_END_DATE, p_ATTRIBUTE_VAL);

END PUT_ENTITY_ATTRIBUTE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ENTITY_ATTRIBUTE
	(
	p_ATTRIBUTE_NAME IN VARCHAR,
	p_ENTITY_DOMAIN_ALIAS IN VARCHAR,
	p_ATTRIBUTE_TYPE IN VARCHAR,
	p_OWNER_ENTITY_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ATTRIBUTE_VAL IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_ENTITY_DOMAIN_ID NUMBER;

BEGIN
	ID.ID_FOR_ENTITY_DOMAIN_ALIAS(p_ENTITY_DOMAIN_ALIAS, v_ENTITY_DOMAIN_ID);

	PUT_ENTITY_ATTRIBUTE(p_ATTRIBUTE_NAME, v_ENTITY_DOMAIN_ID, p_ATTRIBUTE_TYPE,
						p_OWNER_ENTITY_ID, p_BEGIN_DATE, p_END_DATE, p_ATTRIBUTE_VAL, p_STATUS);


END PUT_ENTITY_ATTRIBUTE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ENTITY_ADDRESS
	(
	p_ENTITY_ID IN NUMBER,
	p_ENTITY_DOMAIN_ALIAS IN VARCHAR,
	p_CATEGORY_NAME IN VARCHAR,
	p_STREET IN VARCHAR,
	p_STREET2 IN VARCHAR,
	p_CITY IN VARCHAR,
	p_STATE_CODE IN VARCHAR,
	p_POSTAL_CODE IN VARCHAR,
	p_COUNTRY_CODE IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_CATEGORY_ID NUMBER;
v_ENTITY_DOMAIN_ID NUMBER;

BEGIN

	ID.ID_FOR_CATEGORY(LTRIM(RTRIM(p_CATEGORY_NAME)), v_CATEGORY_ID);
	ID.ID_FOR_ENTITY_DOMAIN_ALIAS(UPPER(LTRIM(RTRIM(p_ENTITY_DOMAIN_ALIAS))), v_ENTITY_DOMAIN_ID);

	EM.PUT_ENTITY_DOMAIN_ADDRESS(v_ENTITY_DOMAIN_ID, p_ENTITY_ID, v_CATEGORY_ID, p_STREET, p_STREET2, p_CITY, p_STATE_CODE, p_POSTAL_CODE, p_COUNTRY_CODE, v_CATEGORY_ID);

	p_STATUS := GA.SUCCESS;
END PUT_ENTITY_ADDRESS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ENTITY_CONTACT
	(
	p_ENTITY_ID IN NUMBER,
	p_ENTITY_DOMAIN_ALIAS IN VARCHAR,
	p_CATEGORY_NAME IN VARCHAR,
	p_CONTACT_NAME IN VARCHAR,
	p_WORK_PHONE IN VARCHAR,
	p_HOME_PHONE IN VARCHAR,
	p_FAX_PHONE IN VARCHAR,
	p_CELL_PHONE IN VARCHAR,
	p_EMAIL_ADDRESS IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_ENTITY_DOMAIN_ID NUMBER;
v_CATEGORY_ID NUMBER;
v_CONTACT_ID NUMBER;
v_OID NUMBER;
v_PHONE_NUMBER VARCHAR(32);

BEGIN

	ID.ID_FOR_ENTITY_DOMAIN_ALIAS(UPPER(LTRIM(RTRIM(p_ENTITY_DOMAIN_ALIAS))), v_ENTITY_DOMAIN_ID);
	ID.ID_FOR_CATEGORY(p_CATEGORY_NAME, v_CATEGORY_ID);
	ID.ID_FOR_CONTACT(v_ENTITY_DOMAIN_ID, p_ENTITY_ID, v_CATEGORY_ID, p_CONTACT_NAME, v_CONTACT_ID);

	v_CONTACT_ID := GET_CONTACT_ID(p_CONTACT_NAME, LTRIM(RTRIM(p_EMAIL_ADDRESS)));

	EM.PUT_ENTITY_DOMAIN_CONTACT(v_ENTITY_DOMAIN_ID, p_ENTITY_ID, v_CATEGORY_ID, v_CONTACT_ID, v_CATEGORY_ID, v_CONTACT_ID);

	v_PHONE_NUMBER := LTRIM(RTRIM(p_WORK_PHONE));
	IF v_PHONE_NUMBER IS NOT NULL THEN
		SP.PUT_PHONE_NUMBER(v_OID, v_CONTACT_ID, 'Work', v_PHONE_NUMBER, 'Work');
	END IF;

	v_PHONE_NUMBER := LTRIM(RTRIM(p_HOME_PHONE));
	IF v_PHONE_NUMBER IS NOT NULL THEN
		SP.PUT_PHONE_NUMBER(v_OID, v_CONTACT_ID, 'Home', v_PHONE_NUMBER, 'Home');
	END IF;

	v_PHONE_NUMBER := LTRIM(RTRIM(p_FAX_PHONE));
	IF v_PHONE_NUMBER IS NOT NULL THEN
		SP.PUT_PHONE_NUMBER(v_OID, v_CONTACT_ID, 'Fax', v_PHONE_NUMBER, 'Fax');
	END IF;

	v_PHONE_NUMBER := LTRIM(RTRIM(p_CELL_PHONE));
	IF v_PHONE_NUMBER IS NOT NULL THEN
		SP.PUT_PHONE_NUMBER(v_OID, v_CONTACT_ID, 'Cell', v_PHONE_NUMBER, 'Cell');
	END IF;

	p_STATUS := GA.SUCCESS;
END PUT_ENTITY_CONTACT;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_ENTITY_CONTACT
	(
	p_ENTITY_ID IN NUMBER,
	p_ENTITY_DOMAIN_ALIAS IN VARCHAR,
	p_CATEGORY_NAME IN VARCHAR,
	p_CONTACT_NAME OUT VARCHAR,
	p_CONTACT_ALIAS OUT VARCHAR,
	p_WORK_PHONE OUT VARCHAR,
	p_HOME_PHONE OUT VARCHAR,
	p_FAX_PHONE OUT VARCHAR,
	p_CELL_PHONE OUT VARCHAR,
	p_EMAIL_ADDRESS OUT VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_ENTITY_DOMAIN_ID NUMBER;
v_CATEGORY_ID NUMBER;
v_CONTACT_ID NUMBER;

CURSOR c_PHONES IS
    SELECT PHONE_TYPE, PHONE_NUMBER
	FROM PHONE_NUMBER
	WHERE CONTACT_ID = v_CONTACT_ID;

BEGIN

	p_CONTACT_NAME := GA.UNDEFINED_ATTRIBUTE;
	p_CONTACT_ALIAS := GA.UNDEFINED_ATTRIBUTE;
	p_EMAIL_ADDRESS := GA.UNDEFINED_ATTRIBUTE;
    p_WORK_PHONE := GA.UNDEFINED_ATTRIBUTE;
    p_HOME_PHONE := GA.UNDEFINED_ATTRIBUTE;
    p_FAX_PHONE := GA.UNDEFINED_ATTRIBUTE;
    p_CELL_PHONE := GA.UNDEFINED_ATTRIBUTE;

	ID.ID_FOR_ENTITY_DOMAIN_ALIAS(UPPER(LTRIM(RTRIM(p_ENTITY_DOMAIN_ALIAS))), v_ENTITY_DOMAIN_ID);
	ID.ID_FOR_CATEGORY(p_CATEGORY_NAME, v_CATEGORY_ID);
	ID.ID_FOR_CONTACT(v_ENTITY_DOMAIN_ID, p_ENTITY_ID, v_CATEGORY_ID, v_CONTACT_ID);

	SELECT CONTACT_NAME, CONTACT_ALIAS, EMAIL_ADDRESS
	INTO p_CONTACT_NAME, p_CONTACT_ALIAS, p_EMAIL_ADDRESS
	FROM CONTACT
	WHERE CONTACT_ID = v_CONTACT_ID;

	FOR v_PHONE IN c_PHONES LOOP
		IF v_PHONE.PHONE_TYPE = 'Work' THEN
		    p_WORK_PHONE := v_PHONE.PHONE_NUMBER;
		ELSIF v_PHONE.PHONE_TYPE = 'Home' THEN
		    p_HOME_PHONE := v_PHONE.PHONE_NUMBER;
		ELSIF v_PHONE.PHONE_TYPE = 'Fax' THEN
		    p_FAX_PHONE := v_PHONE.PHONE_NUMBER;
		ELSIF v_PHONE.PHONE_TYPE = 'Cell' THEN
		    p_CELL_PHONE := v_PHONE.PHONE_NUMBER;
		END IF;
	END LOOP;

	p_STATUS := GA.SUCCESS;

END GET_ENTITY_CONTACT;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_ENTITY_ADDRESS
	(
	p_ENTITY_ID IN NUMBER,
	p_ENTITY_DOMAIN_ALIAS IN VARCHAR,
	p_CATEGORY_NAME IN VARCHAR,
	p_STREET OUT VARCHAR,
	p_CITY OUT VARCHAR,
	p_STATE_CODE OUT VARCHAR,
	p_POSTAL_CODE OUT VARCHAR,
	p_COUNTRY_CODE OUT VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_CATEGORY_ID NUMBER;
v_ENTITY_DOMAIN_ID NUMBER;

BEGIN

	p_STATUS := GA.SUCCESS;

	p_STREET := GA.UNDEFINED_ATTRIBUTE;
	p_CITY := GA.UNDEFINED_ATTRIBUTE;
	p_STATE_CODE := GA.UNDEFINED_ATTRIBUTE;
	p_POSTAL_CODE := GA.UNDEFINED_ATTRIBUTE;
	p_COUNTRY_CODE := GA.UNDEFINED_ATTRIBUTE;

	ID.ID_FOR_CATEGORY(LTRIM(RTRIM(p_CATEGORY_NAME)), v_CATEGORY_ID);
	ID.ID_FOR_ENTITY_DOMAIN_ALIAS(UPPER(LTRIM(RTRIM(p_ENTITY_DOMAIN_ALIAS))), v_ENTITY_DOMAIN_ID);

	SELECT A.STREET,
		(SELECT NVL(DISPLAY_NAME,GEOGRAPHY_NAME)
		 FROM GEOGRAPHY
		 WHERE GEOGRAPHY_TYPE = 'City'
			AND ROWNUM = 1
		 START WITH GEOGRAPHY_ID = A.GEOGRAPHY_ID
		 CONNECT BY PRIOR PARENT_GEOGRAPHY_ID = GEOGRAPHY_ID) "CITY",
		(SELECT NVL(ABBREVIATION,NVL(DISPLAY_NAME,GEOGRAPHY_NAME))
		 FROM GEOGRAPHY
		 WHERE GEOGRAPHY_TYPE = 'State/Province'
			AND ROWNUM = 1
		 START WITH GEOGRAPHY_ID = A.GEOGRAPHY_ID
		 CONNECT BY PRIOR PARENT_GEOGRAPHY_ID = GEOGRAPHY_ID) "STATE_CODE",
		(SELECT NVL(DISPLAY_NAME,GEOGRAPHY_NAME)
		 FROM GEOGRAPHY
		 WHERE GEOGRAPHY_TYPE = 'Postal Code'
			AND ROWNUM = 1
		 START WITH GEOGRAPHY_ID = A.GEOGRAPHY_ID
		 CONNECT BY PRIOR PARENT_GEOGRAPHY_ID = GEOGRAPHY_ID) "POSTAL_CODE",
		(SELECT NVL(ABBREVIATION,NVL(DISPLAY_NAME,GEOGRAPHY_NAME))
		 FROM GEOGRAPHY
		 WHERE GEOGRAPHY_TYPE = 'Country'
			AND ROWNUM = 1
		 START WITH GEOGRAPHY_ID = A.GEOGRAPHY_ID
		 CONNECT BY PRIOR PARENT_GEOGRAPHY_ID = GEOGRAPHY_ID) "COUNTRY_CODE"
	INTO p_STREET, p_CITY, p_STATE_CODE, p_POSTAL_CODE, p_COUNTRY_CODE
	FROM ENTITY_DOMAIN_ADDRESS A
	WHERE A.ENTITY_DOMAIN_ID = v_ENTITY_DOMAIN_ID
		AND A.OWNER_ENTITY_ID = p_ENTITY_ID
		AND A.CATEGORY_ID = v_CATEGORY_ID;

END GET_ENTITY_ADDRESS;
----------------------------------------------------------------------------------------------------
FUNCTION GET_ENTITY_ATTRIBUTE
	(
	p_ATTRIBUTE_NAME IN VARCHAR,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_OWNER_ENTITY_ID IN NUMBER,
	p_DATE IN DATE
	) RETURN VARCHAR2 IS

v_ATTRIBUTE_ID NUMBER;
v_ATTRIBUTE_NAME VARCHAR2(64);
v_RET TEMPORAL_ENTITY_ATTRIBUTE.ATTRIBUTE_VAL%TYPE;

BEGIN

	v_ATTRIBUTE_NAME := LTRIM(RTRIM(p_ATTRIBUTE_NAME));
	ID.ID_FOR_ENTITY_ATTRIBUTE(v_ATTRIBUTE_NAME, p_ENTITY_DOMAIN_ID, NULL, FALSE, v_ATTRIBUTE_ID);

	IF v_ATTRIBUTE_ID <= 0 THEN
		ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY,'Attribute with Name = ' || v_ATTRIBUTE_NAME);
	END IF;

	SELECT MAX(DECODE(ATTRIBUTE_VAL, GA.UNDEFINED_ATTRIBUTE, NULL, ATTRIBUTE_VAL))
	INTO v_RET
	FROM TEMPORAL_ENTITY_ATTRIBUTE
	WHERE OWNER_ENTITY_ID = p_OWNER_ENTITY_ID
	    AND ATTRIBUTE_ID = v_ATTRIBUTE_ID
		AND p_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE, p_DATE)
		AND ROWNUM = 1;

	RETURN v_RET;

END GET_ENTITY_ATTRIBUTE;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_ENTITY_ATTRIBUTE
	(
	p_ATTRIBUTE_NAME IN VARCHAR,
	p_ENTITY_DOMAIN_ALIAS IN VARCHAR,
	p_OWNER_ENTITY_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_ATTRIBUTE_VAL OUT VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_ENTITY_DOMAIN_ID NUMBER;

BEGIN

	ID.ID_FOR_ENTITY_DOMAIN_ALIAS(p_ENTITY_DOMAIN_ALIAS, v_ENTITY_DOMAIN_ID);

	p_STATUS := GA.SUCCESS;
	p_ATTRIBUTE_VAL := GET_ENTITY_ATTRIBUTE(p_ATTRIBUTE_NAME, v_ENTITY_DOMAIN_ID, p_OWNER_ENTITY_ID, p_BEGIN_DATE);

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			p_ATTRIBUTE_VAL := GA.UNDEFINED_ATTRIBUTE;
			p_STATUS := GA.NO_DATA_FOUND;

END GET_ENTITY_ATTRIBUTE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_MARKET_PRICE_VALUE
	(
	p_MARKET_PRICE_VALUE IN OUT MARKET_PRICE_VALUE%ROWTYPE,
	p_STATUS OUT NUMBER
	) AS

-- Insert or update the basis and price values associated with a Market Price.

BEGIN

	p_STATUS := GA.SUCCESS;

	IF NOT GA.VERSION_MARKET_PRICE THEN
		p_MARKET_PRICE_VALUE.AS_OF_DATE := LOW_DATE;
	END IF;

	UPDATE MARKET_PRICE_VALUE
	SET PRICE_BASIS = p_MARKET_PRICE_VALUE.PRICE_BASIS,
	    PRICE  = p_MARKET_PRICE_VALUE.PRICE
	WHERE MARKET_PRICE_ID = p_MARKET_PRICE_VALUE.MARKET_PRICE_ID
		AND  PRICE_CODE = p_MARKET_PRICE_VALUE.PRICE_CODE
	    AND PRICE_DATE = p_MARKET_PRICE_VALUE.PRICE_DATE
	    AND AS_OF_DATE = p_MARKET_PRICE_VALUE.AS_OF_DATE;

	IF SQL%NOTFOUND THEN
	    INSERT INTO MARKET_PRICE_VALUE(
		    MARKET_PRICE_ID,
			PRICE_CODE,
			PRICE_DATE,
			AS_OF_DATE,
			PRICE_BASIS,
			PRICE)
		VALUES(
		    p_MARKET_PRICE_VALUE.MARKET_PRICE_ID,
			p_MARKET_PRICE_VALUE.PRICE_CODE,
			p_MARKET_PRICE_VALUE.PRICE_DATE,
			p_MARKET_PRICE_VALUE.AS_OF_DATE,
			p_MARKET_PRICE_VALUE.PRICE_BASIS,
			p_MARKET_PRICE_VALUE.PRICE);
	END IF;


END PUT_MARKET_PRICE_VALUE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_MARKET_PRICE_VALUE
	(
	p_MARKET_PRICE_NAME IN VARCHAR,
	p_PRICE_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_PRICE_CODE IN CHAR,
	p_PRICE_BASIS IN NUMBER,
	p_PRICE IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

-- Insert or update the basis and price values associated with a Market Price.

v_MARKET_PRICE_VALUE MARKET_PRICE_VALUE%ROWTYPE;
BEGIN

	ID.ID_FOR_MARKET_PRICE(p_MARKET_PRICE_NAME, FALSE, v_MARKET_PRICE_VALUE.MARKET_PRICE_ID);

	IF v_MARKET_PRICE_VALUE.MARKET_PRICE_ID <= 0 THEN
	    p_STATUS := v_MARKET_PRICE_VALUE.MARKET_PRICE_ID;
		RETURN;
	END IF;

	p_STATUS := GA.SUCCESS;

	SELECT DECODE(UPPER(SUBSTR(p_PRICE_CODE,1,1)), 'A', 'A', 'F','F','P','P','?') INTO v_MARKET_PRICE_VALUE.PRICE_CODE FROM DUAL;
	v_MARKET_PRICE_VALUE.PRICE_DATE := TO_CUT(p_PRICE_DATE, p_TIME_ZONE);
	v_MARKET_PRICE_VALUE.AS_OF_DATE := SYSDATE;
	v_MARKET_PRICE_VALUE.PRICE_BASIS := p_PRICE_BASIS;
	v_MARKET_PRICE_VALUE.PRICE := p_PRICE;

	PUT_MARKET_PRICE_VALUE(v_MARKET_PRICE_VALUE, p_STATUS);


END PUT_MARKET_PRICE_VALUE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_SERVICE_LOCATION_ESP_IDENT
	(
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_ESP_IDENTIFIER IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

-- Update the ESP identifier associated with an existing service location entity

BEGIN

	UPDATE ACCOUNT_SERVICE_LOCATION SET
	    ESP_IDENTIFIER = p_ESP_IDENTIFIER,
	    ENTRY_DATE = SYSDATE
	WHERE SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID;

	p_STATUS := GA.SUCCESS;


END PUT_SERVICE_LOCATION_ESP_IDENT;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_METER_ESP_IDENT
	(
	p_METER_ID IN NUMBER,
	p_ESP_IDENTIFIER IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

-- Update the ESP identifier associated with an existing meter entity

BEGIN

	UPDATE SERVICE_LOCATION_METER SET
	    ESP_IDENTIFIER = p_ESP_IDENTIFIER,
	    ENTRY_DATE = SYSDATE
	WHERE METER_ID = p_METER_ID;

	p_STATUS := GA.SUCCESS;


END PUT_METER_ESP_IDENT;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_SERVICE_LOCATION
	(
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_SERVICE_LOCATION_NAME IN VARCHAR,
	p_SERVICE_LOCATION_ALIAS IN VARCHAR,
	p_SERVICE_LOCATION_DESC IN VARCHAR,
	p_LATITUDE IN VARCHAR,
	p_LONGITUDE IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_BILL_CYCLE_NAME IN VARCHAR,
	p_SERVICE_POINT_NAME IN VARCHAR,
	p_WEATHER_STATION_NAME IN VARCHAR,
	p_BUSINESS_ROLLUP_NAME IN VARCHAR,
	p_GEOGRAPHIC_ROLLUP_NAME IN VARCHAR,
	p_CREATE_IF_NOT_FOUND IN BOOLEAN,
	p_STATUS OUT NUMBER
	) AS

v_SERVICE_LOCATION_ID NUMBER;
v_SERVICE_POINT_ID NUMBER;
v_WEATHER_STATION_ID NUMBER;

BEGIN

    IF p_SERVICE_LOCATION_ID IS NULL THEN
	    ID.ID_FOR_SERVICE_LOCATION(p_SERVICE_LOCATION_NAME, p_CREATE_IF_NOT_FOUND, v_SERVICE_LOCATION_ID);
	ELSE
		v_SERVICE_LOCATION_ID := p_SERVICE_LOCATION_ID;
	END IF;

	IF v_SERVICE_LOCATION_ID <= 0 THEN
	    p_STATUS := -100;
		RETURN;
	END IF;

    IF p_SERVICE_POINT_NAME IS NOT NULL THEN
	    ID.ID_FOR_SERVICE_POINT(p_SERVICE_POINT_NAME, v_SERVICE_POINT_ID);
		IF v_SERVICE_POINT_ID < 0 THEN
		    v_SERVICE_POINT_ID := NULL;
		END IF;
	ELSE
		v_SERVICE_POINT_ID := NULL;
	END IF;

   IF p_WEATHER_STATION_NAME IS NOT NULL THEN
	   ID.ID_FOR_WEATHER_STATION(p_WEATHER_STATION_NAME, v_WEATHER_STATION_ID);
		IF v_WEATHER_STATION_ID < 0 THEN
		    v_WEATHER_STATION_ID := NULL;
		END IF;
	ELSE
		v_WEATHER_STATION_ID := NULL;
	END IF;

	UPDATE SERVICE_LOCATION SET
	    SERVICE_LOCATION_ALIAS = NVL(p_SERVICE_LOCATION_ALIAS, SERVICE_LOCATION_ALIAS),
	    SERVICE_LOCATION_DESC = NVL(p_SERVICE_LOCATION_DESC, SERVICE_LOCATION_DESC),
	    LATITUDE = NVL(p_LATITUDE, LATITUDE),
	    LONGITUDE = NVL(p_LONGITUDE, LONGITUDE),
	    TIME_ZONE = NVL(p_TIME_ZONE, TIME_ZONE),
	    SERVICE_POINT_ID = NVL(v_SERVICE_POINT_ID, SERVICE_POINT_ID),
	    WEATHER_STATION_ID = NVL(v_WEATHER_STATION_ID, WEATHER_STATION_ID),
		ENTRY_DATE = SYSDATE
	WHERE SERVICE_LOCATION_ID = v_SERVICE_LOCATION_ID;

    p_STATUS := GA.SUCCESS;


END PUT_SERVICE_LOCATION;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_METER
	(
	p_METER_ID IN NUMBER,
	p_METER_NAME IN VARCHAR,
	p_METER_ALIAS IN VARCHAR,
	p_METER_DESC IN VARCHAR,
	p_METER_EXTERNAL_IDENTIFIER IN VARCHAR,
	p_METER_STATUS IN VARCHAR,
	p_METER_INTERVAL IN VARCHAR,
	p_METER_TYPE IN VARCHAR,
	p_METER_UNIT IN VARCHAR,
	p_IS_EXTERNAL_INTERVAL_USAGE IN NUMBER,
	p_IS_EXTERNAL_BILLED_USAGE IN NUMBER,
	p_CREATE_IF_NOT_FOUND IN BOOLEAN,
	p_STATUS OUT NUMBER
	) AS

v_METER_ID NUMBER;

BEGIN

    IF p_METER_ID IS NULL THEN
	    ID.ID_FOR_METER(NULL, p_METER_NAME, p_CREATE_IF_NOT_FOUND, v_METER_ID);
	ELSE
		v_METER_ID := p_METER_ID;
	END IF;

	IF v_METER_ID <= 0 THEN
	    p_STATUS := -100;
		RETURN;
	END IF;

	UPDATE METER SET
	    METER_ALIAS = NVL(p_METER_ALIAS, METER_ALIAS),
	    METER_DESC = NVL(p_METER_DESC, METER_DESC),
	    METER_EXTERNAL_IDENTIFIER = NVL(p_METER_EXTERNAL_IDENTIFIER, METER_EXTERNAL_IDENTIFIER),
	    METER_STATUS = NVL(p_METER_STATUS, METER_STATUS),
	    METER_INTERVAL = NVL(p_METER_INTERVAL, METER_INTERVAL),
	    METER_TYPE = NVL(p_METER_TYPE, METER_TYPE),
	    METER_UNIT = NVL(p_METER_UNIT, METER_UNIT),
	    IS_EXTERNAL_INTERVAL_USAGE = NVL(DECODE(p_IS_EXTERNAL_INTERVAL_USAGE,1,1,0,0,NULL), IS_EXTERNAL_INTERVAL_USAGE),
	    IS_EXTERNAL_BILLED_USAGE = NVL(DECODE(p_IS_EXTERNAL_BILLED_USAGE,1,1,0,0,NULL), IS_EXTERNAL_BILLED_USAGE),
		ENTRY_DATE = SYSDATE
	WHERE METER_ID = v_METER_ID;

    p_STATUS := GA.SUCCESS;


END PUT_METER;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_AREA_LOAD
	(
	p_AREA_ID IN NUMBER,
	p_LOAD_DATE IN DATE,
	p_LOAD_CODE IN CHAR,
	p_LOAD_VAL IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

-- Update the Area Load.

v_AS_OF_DATE DATE;

BEGIN

	IF GA.VERSION_AREA_LOAD THEN
		v_AS_OF_DATE := SYSDATE;
	ELSE
		v_AS_OF_DATE := LOW_DATE;
	END IF;

	UPDATE AREA_LOAD SET
	    LOAD_VAL = p_LOAD_VAL
	WHERE CASE_ID = GA.BASE_CASE_ID
		AND AREA_ID = p_AREA_ID
		AND LOAD_CODE = p_LOAD_CODE
	    	AND LOAD_DATE = p_LOAD_DATE
		AND AS_OF_DATE = v_AS_OF_DATE;

	IF SQL%NOTFOUND THEN
	    INSERT INTO AREA_LOAD(
			CASE_ID,
		   	AREA_ID,
			LOAD_CODE,
			LOAD_DATE,
			AS_OF_DATE,
			LOAD_VAL)
		VALUES(
			GA.BASE_CASE_ID,
			p_AREA_ID,
			p_LOAD_CODE,
			p_LOAD_DATE,
			v_AS_OF_DATE,
			p_LOAD_VAL);
	END IF;

	p_STATUS := GA.SUCCESS;


END PUT_AREA_LOAD;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_AREA_LOAD_VALUES
	(
	p_AREA_NAME IN VARCHAR,
	p_LOAD_DATE IN VARCHAR,
	p_LOAD_CODE IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_DATE_FORMAT IN VARCHAR DEFAULT 'DD-MON-YYYY',
	p_INTERVAL IN VARCHAR DEFAULT 3600,
	p_LOAD_VALUES IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_AREA_ID NUMBER;
v_TIME_ZONE VARCHAR(3);
v_LOCAL_DATE DATE;
v_LOAD_DATE DATE;
v_LOAD_CODE CHAR(1);
v_INTERVAL NUMBER;
v_LOAD_VAL AREA_LOAD.LOAD_VAL%TYPE;
v_STRING_TABLE GA.STRING_TABLE;
v_INDEX BINARY_INTEGER;

BEGIN

	v_LOCAL_DATE := TO_DATE(p_LOAD_DATE, p_DATE_FORMAT);
	v_TIME_ZONE := TIME_ZONE_FOR_DAY(v_LOCAL_DATE, p_TIME_ZONE);

	v_LOAD_DATE := FROM_TZ(CAST(v_LOCAL_DATE AS TIMESTAMP), RO_TZ_OFFSET(v_TIME_ZONE)) AT TIME ZONE RO_TZ_OFFSET(CUT_TIME_ZONE);

	v_INTERVAL := TO_NUMBER(LTRIM(RTRIM(p_INTERVAL)));
	SELECT DECODE(UPPER(SUBSTR(p_LOAD_CODE,1,1)), 'A', 'A', 'F') INTO v_LOAD_CODE FROM DUAL;

	ID.ID_FOR_AREA(p_AREA_NAME, FALSE, v_AREA_ID);

	IF v_AREA_ID <= 0 THEN
	     p_STATUS := -100;
	END IF;

	UT.TOKENS_FROM_STRING(p_LOAD_VALUES,',', v_STRING_TABLE);
	v_INDEX := v_STRING_TABLE.FIRST;

	LOOP
 		v_LOAD_VAL := TO_NUMBER(v_STRING_TABLE(v_INDEX));
		PUT_AREA_LOAD(v_AREA_ID, v_LOAD_DATE, v_LOAD_CODE, v_LOAD_VAL, p_STATUS);
		IF p_STATUS < GA.SUCCESS THEN
			ROLLBACK;
			RETURN;
		END IF;
		EXIT WHEN v_INDEX = v_STRING_TABLE.LAST;
		v_INDEX := v_STRING_TABLE.NEXT(v_INDEX);
		v_LOAD_DATE := ADD_SECONDS_TO_DATE(v_LOAD_DATE, v_INTERVAL);
	END LOOP;


END PUT_AREA_LOAD_VALUES;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_AREA_LOAD_VALUES
	(
	p_AREA_ID IN NUMBER,
	p_LOAD_DATE IN DATE,
	p_LOAD_CODE IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_LOAD_VALUES IN OUT NOCOPY GA.NUMBER_TABLE
	) AS

v_LOAD_DATE DATE;
v_LOAD_CODE CHAR(1);
v_MINUTES NUMBER(2) := 60;
v_STATUS NUMBER;
v_INDEX BINARY_INTEGER;

BEGIN

	v_LOAD_DATE := TO_CUT(p_LOAD_DATE, p_TIME_ZONE);
	SELECT DECODE(UPPER(SUBSTR(p_LOAD_CODE,1,1)), 'A', 'A', 'F') INTO v_LOAD_CODE FROM DUAL;

	IF TRUNC(DST_SPRING_AHEAD_DATE(v_LOAD_DATE)) = TRUNC(p_LOAD_DATE) AND p_LOAD_VALUES.COUNT = 24 THEN
		IF GA.DST_SPRING_AHEAD_OPTION = 'A' THEN
			p_LOAD_VALUES.DELETE(2);
		ELSIF GA.DST_SPRING_AHEAD_OPTION = 'B' THEN
			p_LOAD_VALUES.DELETE(3);
		ELSIF GA.DST_SPRING_AHEAD_OPTION = 'C' THEN
			p_LOAD_VALUES.DELETE(24);
		END IF;
	ELSIF TRUNC(DST_FALL_BACK_DATE(v_LOAD_DATE)) = TRUNC(p_LOAD_DATE) AND p_LOAD_VALUES.COUNT = 24 THEN
		IF GA.DST_FALL_BACK_OPTION = 'A' THEN
			FOR v_INDEX IN REVERSE 3..25 LOOP
				p_LOAD_VALUES(v_INDEX) := p_LOAD_VALUES(v_INDEX-1);
			END LOOP;
		ELSIF GA.DST_FALL_BACK_OPTION = 'B' THEN
			p_LOAD_VALUES(25) := 0;
		END IF;
	END IF;

	FOR v_INDEX IN p_LOAD_VALUES.FIRST..p_LOAD_VALUES.LAST LOOP
		IF p_LOAD_VALUES.EXISTS(v_INDEX) THEN
			PUT_AREA_LOAD(p_AREA_ID, v_LOAD_DATE, v_LOAD_CODE, p_LOAD_VALUES(v_INDEX), v_STATUS);
			v_LOAD_DATE := ADD_MINUTES_TO_DATE(v_LOAD_DATE, v_MINUTES);
		END IF;
	END LOOP;

END PUT_AREA_LOAD_VALUES;
----------------------------------------------------------------------------------------------------
FUNCTION UPDATE_TABLE
    (
	p_TABLE_NAME IN VARCHAR,
	p_ATTRIBUTE IN VARCHAR,
	p_VALUE IN VARCHAR,
	p_CRITERIA IN VARCHAR,
	p_MESSAGE OUT VARCHAR
	) RETURN NUMBER IS

v_CID INTEGER := 0;
v_STRING VARCHAR2(256) := '';
v_ROWS_UPDATED NUMBER := 0;

BEGIN

      v_STRING := 'UPDATE ' || p_TABLE_NAME || ' SET ' || p_ATTRIBUTE || ' = ' || '''' || p_VALUE || ''', ENTRY_DATE = SYSDATE ' || p_CRITERIA;
      v_CID := DBMS_SQL.OPEN_CURSOR;

       DBMS_SQL.PARSE(v_CID, v_STRING ,DBMS_SQL.NATIVE);
       v_ROWS_UPDATED := DBMS_SQL.EXECUTE(v_CID);
       DBMS_SQL.CLOSE_CURSOR(v_CID);

       p_MESSAGE := '';
	   RETURN 0;

       EXCEPTION
          WHEN OTHERS THEN
          DBMS_SQL.CLOSE_CURSOR(v_CID);
          p_MESSAGE := SUBSTR(p_TABLE_NAME || ' ' || p_ATTRIBUTE || ' ' || p_VALUE || ' ' || SQLERRM,1,512);
          RETURN SQLCODE;

END UPDATE_TABLE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_TABLE_ATTRIBUTE
    (
    p_TABLE_NAME IN VARCHAR,
    p_ATTRIBUTE IN VARCHAR,
    p_CRITERIA IN VARCHAR,
    p_MESSAGE OUT VARCHAR,
    p_STATUS OUT NUMBER
    ) AS

/* GENERIC PROCEDURE TO UPDATE TABLES.  TABLE TO BE UPDATED MUST INCLUDE FIELD
             ENTRY_DATE.  FIELDS TO BE UPDATED MUST NOT INCLUDE DATE/TIME STAMP FIELDS.
             FIELDS TO BE UPDATED MAY INCLUDE DATE FIELD WHERE ONLY DATE IS TO BE UPDATED
             AND DATE STRING CAN BE PASSED IN FORMAT DD-MON-YYYY.
             PARM LIST MUST INCLUDE:
                       1)  TABLE_NAME
                       2)  ATTRIBUTE/VALUE PAIRS STRING DELIMITED BY SEMI COLONS
                           'FIELD1;XXX;FIELD2;999;FIELD3;124.5'
                       3)  UPDATE CRITERIA (WHERE CLAUSE).  IF ALL ROWS IN TABLE
                           ARE TO BE UPDATED, LEAVE THIS PARAMETER NULL
                           NOTE EXAMPLE B FOR HANDLING WHERE CLAUSES WHICH NEED TO COMARE
                           AGAINST A CHARACTER STRING INSTEAD OF A NUMERIC VALUE OR AN
                           ATTRIBUTE NAME.  INCORRECT PLACEMENT OF TICK MARKS WILL RESULT
                           IN AN INVALID WHERE STATEMENT
                           A)  'WHERE ACCOUNT_ID = 999'
                           B)  'WHERE FIELD5 = '|| '''YYY''';
                       4)  ERR_MSG -- OUTPUT PARAMETER WITH LENGTH OF 512 FOR POSTING TO
                           APP_EVENT_LOG
                       5)  STATUS FOR TESTING SUCCESS OF OPERATION
*/

v_STRING_TABLE GA.STRING_TABLE;
v_INDEX BINARY_INTEGER;
v_ATTRIBUTE VARCHAR2(30);
v_VALUE VARCHAR2(512);
v_SUCCESS NUMBER;
v_MESSAGE VARCHAR2(512);

BEGIN

    UT.TOKENS_FROM_STRING(p_ATTRIBUTE,';', v_STRING_TABLE);
    v_INDEX := v_STRING_TABLE.FIRST;
    p_STATUS := GA.SUCCESS;

    LOOP
        v_ATTRIBUTE := v_STRING_TABLE(v_INDEX);
        v_VALUE := v_STRING_TABLE(v_INDEX + 1);

        v_SUCCESS  := UPDATE_TABLE(p_TABLE_NAME, v_ATTRIBUTE, v_VALUE, p_CRITERIA, v_MESSAGE);

        IF v_SUCCESS < GA.SUCCESS THEN
            p_STATUS := v_SUCCESS;
            p_MESSAGE := v_MESSAGE;
            ROLLBACK;
            RETURN;
        END IF;

        EXIT WHEN (v_INDEX + 1) = v_STRING_TABLE.LAST;
        v_INDEX := v_INDEX + 2;

    END LOOP;

END PUT_TABLE_ATTRIBUTE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_EXTERNAL_FORECAST
	(
	p_SERVICE_ID IN NUMBER,
	p_LOAD_DATE IN DATE,
	p_LOAD_VAL IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

-- Update the external forecast for an account service.

BEGIN

	UPDATE SERVICE_LOAD SET
	    LOAD_VAL = p_LOAD_VAL
	WHERE SERVICE_ID = p_SERVICE_ID
		AND SERVICE_CODE = GA.FORECAST_SERVICE
	    AND LOAD_DATE = p_LOAD_DATE
		AND LOAD_CODE = GA.EXTERNAL;

	IF SQL%NOTFOUND THEN
	    INSERT INTO SERVICE_LOAD(
		    SERVICE_ID,
			SERVICE_CODE,
			LOAD_DATE,
			LOAD_CODE,
			LOAD_VAL)
		VALUES(
		    p_SERVICE_ID,
			GA.FORECAST_SERVICE,
			p_LOAD_DATE,
			GA.EXTERNAL,
			p_LOAD_VAL);
	END IF;

	p_STATUS := GA.SUCCESS;


END PUT_EXTERNAL_FORECAST;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_EXTERNAL_FORECAST
	(
	p_SERVICE_ID IN NUMBER,
	p_LOAD_DATE IN DATE,
	p_LOAD_VAL IN NUMBER,
	p_APPLY_LOSSES IN BOOLEAN,
	p_STATUS OUT NUMBER
	) AS

-- Update the external forecast for an account service.

v_LOAD_VAL SERVICE_LOAD.LOAD_VAL%TYPE;

BEGIN

	IF p_APPLY_LOSSES THEN
		v_LOAD_VAL := p_LOAD_VAL; -- * GET_TD_LOSS_FACTOR(p_SERVICE_ID);
	ELSE
		v_LOAD_VAL := p_LOAD_VAL;
	END IF;

	PUT_EXTERNAL_FORECAST(p_SERVICE_ID, p_LOAD_DATE, v_LOAD_VAL, p_STATUS);

END PUT_EXTERNAL_FORECAST;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SAMPLE_ID
	(
	p_SAMPLE_NAME IN VARCHAR,
	p_SAMPLE_ID OUT NUMBER,
	p_STATUS OUT NUMBER
	) AS

-- Answer the sample id for the sample usage.

BEGIN

    p_STATUS := GA.SUCCESS;

	SELECT SAMPLE_ID
	INTO p_SAMPLE_ID
	FROM SAMPLE_USAGE
	WHERE SAMPLE_NAME = p_SAMPLE_NAME
	    AND ROWNUM = 1;

	EXCEPTION
	    WHEN NO_DATA_FOUND THEN
			 p_SAMPLE_ID := CONSTANTS.NOT_ASSIGNED;
	    WHEN OTHERS THEN
			 p_SAMPLE_ID := CONSTANTS.NOT_ASSIGNED;
			 p_STATUS := SQLCODE;

END GET_SAMPLE_ID;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_SAMPLE_USAGE
	(
	p_SAMPLE_NAME IN VARCHAR,
	p_SAMPLE_ALIAS IN VARCHAR,
	p_SAMPLE_DESC IN VARCHAR,
	p_METER_NUMBER IN VARCHAR,
	p_ACCOUNT_NUMBER IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_SAMPLE_INTERVAL IN VARCHAR,
	p_SAMPLE_TYPE IN VARCHAR,
	p_SAMPLE_UNIT IN VARCHAR,
	p_SAMPLE_IS_EXTERNAL IN NUMBER,
	p_SAMPLE_ID OUT NUMBER,
	p_STATUS OUT NUMBER
	) AS

-- Update or create a sample usage.

BEGIN

	GET_SAMPLE_ID(p_SAMPLE_NAME, p_SAMPLE_ID, p_STATUS);

	IF NOT p_STATUS = GA.SUCCESS THEN
	    RETURN;
	END IF;

	IF NOT p_SAMPLE_ID = CONSTANTS.NOT_ASSIGNED THEN
	    UPDATE SAMPLE_USAGE SET
	        SAMPLE_NAME = p_SAMPLE_NAME,
			SAMPLE_ALIAS = p_SAMPLE_ALIAS,
			SAMPLE_DESC = p_SAMPLE_DESC,
			METER_NUMBER = p_METER_NUMBER,
			ACCOUNT_NUMBER = p_ACCOUNT_NUMBER,
			TIME_ZONE = p_TIME_ZONE,
			SAMPLE_INTERVAL = p_SAMPLE_INTERVAL,
			SAMPLE_TYPE = p_SAMPLE_TYPE,
			SAMPLE_UNIT = p_SAMPLE_UNIT,
			SAMPLE_IS_EXTERNAL = p_SAMPLE_IS_EXTERNAL,
			ENTRY_DATE = SYSDATE
		WHERE SAMPLE_ID = p_SAMPLE_ID;
	ELSE
	    INSERT INTO SAMPLE_USAGE(
	        SAMPLE_NAME,
			SAMPLE_ALIAS,
			SAMPLE_DESC,
			METER_NUMBER,
			ACCOUNT_NUMBER,
			TIME_ZONE,
			SAMPLE_INTERVAL,
			SAMPLE_TYPE,
			SAMPLE_UNIT,
			SAMPLE_IS_EXTERNAL,
			ENTRY_DATE)
		VALUES(
	        p_SAMPLE_NAME,
			p_SAMPLE_ALIAS,
			p_SAMPLE_DESC,
			p_METER_NUMBER,
			p_ACCOUNT_NUMBER,
			p_TIME_ZONE,
			p_SAMPLE_INTERVAL,
			p_SAMPLE_TYPE,
			p_SAMPLE_UNIT,
			p_SAMPLE_IS_EXTERNAL,
			SYSDATE);
	END IF;

	p_STATUS := GA.SUCCESS;


END PUT_SAMPLE_USAGE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_SAMPLE_INTERVAL_USAGE
	(
	p_SAMPLE_ID IN NUMBER,
	p_SAMPLE_DATE IN DATE,
	p_USAGE IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

-- Update the sample interval usage.

BEGIN

	UPDATE SAMPLE_INTERVAL_USAGE SET
	    USAGE = p_USAGE
	WHERE SAMPLE_ID = p_SAMPLE_ID
	    AND SAMPLE_DATE = p_SAMPLE_DATE;

	IF SQL%NOTFOUND THEN
	    INSERT INTO SAMPLE_INTERVAL_USAGE(
		    SAMPLE_ID,
			SAMPLE_DATE,
			USAGE)
		VALUES(
		    p_SAMPLE_ID,
			p_SAMPLE_DATE,
			p_USAGE);
	END IF;

	p_STATUS := GA.SUCCESS;


END PUT_SAMPLE_INTERVAL_USAGE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_MARKET_PRICE_VALUES
	(
	p_EXTERNAL_IDENTIFIER IN VARCHAR,
	p_PRICE_CODE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_DATE_FORMAT IN VARCHAR,
	p_DATA_VALUES IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

-- Accept market price values for the specified market price and code.
-- The values are comma delimited terminated by a semi-colon: <date>, <basis>, <price>;

v_STRING_TABLE GA.BIG_STRING_TABLE;
v_LINE_TABLE GA.STRING_TABLE;
v_INDEX BINARY_INTEGER;
v_MARKET_PRICE_VALUE MARKET_PRICE_VALUE%ROWTYPE;

BEGIN

	IF NOT CAN_WRITE('PRODUCT') THEN
		ERRS.RAISE_NO_WRITE_MODULE('PRODUCT');
	END IF;

	ID.ID_FOR_MARKET_PRICE_EXT_IDENT(p_EXTERNAL_IDENTIFIER, v_MARKET_PRICE_VALUE.MARKET_PRICE_ID);
	IF v_MARKET_PRICE_VALUE.MARKET_PRICE_ID <= 0 THEN
	    p_STATUS := v_MARKET_PRICE_VALUE.MARKET_PRICE_ID;
		RETURN;
	END IF;

    p_STATUS := GA.SUCCESS;
	UT.TOKENS_FROM_BIG_STRING(p_DATA_VALUES,';', v_STRING_TABLE);

	SELECT DECODE(UPPER(SUBSTR(p_PRICE_CODE,1,1)),'F','F','P','P','A','A','F') INTO v_MARKET_PRICE_VALUE.PRICE_CODE FROM DUAL;
	v_MARKET_PRICE_VALUE.AS_OF_DATE := CORRECTED_AS_OF_DATE(p_AS_OF_DATE);

 	FOR v_INDEX IN v_STRING_TABLE.FIRST..v_STRING_TABLE.LAST LOOP
		UT.TOKENS_FROM_STRING(v_STRING_TABLE(v_INDEX),',', v_LINE_TABLE);
		v_MARKET_PRICE_VALUE.PRICE_DATE := TRUNC(TO_CUT(TO_DATE(v_LINE_TABLE(1), p_DATE_FORMAT), LOCAL_TIME_ZONE),'MI');
		v_MARKET_PRICE_VALUE.PRICE_BASIS := TO_NUMBER(v_LINE_TABLE(2));
		v_MARKET_PRICE_VALUE.PRICE := TO_NUMBER(v_LINE_TABLE(3));
		PUT_MARKET_PRICE_VALUE(v_MARKET_PRICE_VALUE, p_STATUS);
		IF NOT p_STATUS = GA.SUCCESS THEN
			ROLLBACK;
			RETURN;
		END IF;
	END LOOP;


END PUT_MARKET_PRICE_VALUES;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_MODEL_OPTION
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ACCOUNT_MODEL_OPTION IN VARCHAR
	) AS

-- Update the Account Model Option.

BEGIN

	UPDATE ACCOUNT SET
	    ACCOUNT_MODEL_OPTION = DECODE(UPPER(p_ACCOUNT_MODEL_OPTION),'METER','Meter','AGGREGATE','Aggregate','Account'),
	    ENTRY_DATE = SYSDATE
	WHERE ACCOUNT_ID = p_ACCOUNT_ID;


END PUT_ACCOUNT_MODEL_OPTION;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_AGGREGATE_ACCOUNT_OPTION
	(
	p_ACCOUNT_ID IN NUMBER,
	p_AGGREGATE_ACCOUNT_OPTION IN NUMBER
	) AS

-- Update the Aggregate Account Option.

BEGIN

	UPDATE ACCOUNT SET
	    IS_AGGREGATE_ACCOUNT = DECODE(p_AGGREGATE_ACCOUNT_OPTION,1,1,0),
	    ENTRY_DATE = SYSDATE
	WHERE ACCOUNT_ID = p_ACCOUNT_ID;


END PUT_AGGREGATE_ACCOUNT_OPTION;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_EDC_ALIAS
	(
	p_EDC_ID IN NUMBER,
	p_EDC_ALIAS IN VARCHAR
	) AS

-- Update the EDC Alias.

BEGIN

	UPDATE ENERGY_DISTRIBUTION_COMPANY SET
	    EDC_ALIAS = p_EDC_ALIAS,
	    ENTRY_DATE = SYSDATE
	WHERE EDC_ID = p_EDC_ID;


END PUT_EDC_ALIAS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_EDC_DUNS_NUMBER
	(
	p_EDC_ID IN NUMBER,
	p_EDC_DUNS_NUMBER IN VARCHAR
	) AS

-- Update the EDC Duns Number.

BEGIN

	UPDATE ENERGY_DISTRIBUTION_COMPANY SET
	    EDC_DUNS_NUMBER = p_EDC_DUNS_NUMBER,
	    ENTRY_DATE = SYSDATE
	WHERE EDC_ID = p_EDC_ID;


END PUT_EDC_DUNS_NUMBER;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_EDC
	(
	p_ACCOUNT_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_EDC_ACCOUNT_NUMBER IN VARCHAR := NULL,
	p_EDC_RATE_CLASS IN VARCHAR := NULL,
	p_EDC_STRATA IN VARCHAR := NULL
	) AS

-- Update the Account EDC Relationship.

v_EDC_ID NUMBER;
v_STATUS NUMBER;

BEGIN

	BEGIN
		SELECT EDC_ID
		INTO v_EDC_ID
		FROM ACCOUNT_EDC
		WHERE ACCOUNT_ID = p_ACCOUNT_ID
			AND p_SERVICE_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE);
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			v_EDC_ID := 0;
			END;

	IF NOT v_EDC_ID = p_EDC_ID THEN
		RA.PUT_ACCOUNT_EDC(p_ACCOUNT_ID, p_EDC_ID, p_SERVICE_DATE, NULL,
			p_EDC_ACCOUNT_NUMBER, p_EDC_RATE_CLASS, p_EDC_STRATA, p_EDC_ID, p_SERVICE_DATE, v_STATUS);
	END IF;


END PUT_ACCOUNT_EDC;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_SERVICE_LOCATION
	(
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_EDC_IDENTIFIER IN VARCHAR := NULL,
	p_ESP_IDENTIFIER IN VARCHAR := NULL
	) AS

-- Update the Account Service Location Relationship.

v_SERVICE_LOCATION_ID NUMBER;
v_STATUS NUMBER;

BEGIN

	BEGIN
		SELECT SERVICE_LOCATION_ID
		INTO v_SERVICE_LOCATION_ID
		FROM ACCOUNT_SERVICE_LOCATION
		WHERE ACCOUNT_ID = p_ACCOUNT_ID
			AND p_SERVICE_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE);
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			v_SERVICE_LOCATION_ID := 0;
			END;

	IF NOT v_SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID THEN
		RA.PUT_ACCOUNT_SERVICE_LOCATION(p_ACCOUNT_ID, p_SERVICE_LOCATION_ID, p_SERVICE_DATE, NULL,
			p_EDC_IDENTIFIER, p_ESP_IDENTIFIER, p_SERVICE_LOCATION_ID, p_SERVICE_DATE, v_STATUS);
	END IF;


END PUT_ACCOUNT_SERVICE_LOCATION;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_CALENDAR
	(
	p_ACCOUNT_ID IN NUMBER,
	p_CALENDAR_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_CALENDAR_TYPE IN VARCHAR
	) AS

-- Update the Account Calendar Relationship.

v_CALENDAR_ID NUMBER;
v_STATUS NUMBER;

BEGIN

	BEGIN
		SELECT CALENDAR_ID
		INTO v_CALENDAR_ID
		FROM ACCOUNT_CALENDAR
		WHERE CASE_ID = GA.BASE_CASE_ID
			AND ACCOUNT_ID = p_ACCOUNT_ID
			AND p_SERVICE_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE)
			AND CALENDAR_TYPE = INITCAP(p_CALENDAR_TYPE);
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			v_CALENDAR_ID := 0;
			END;

	IF NOT v_CALENDAR_ID = p_CALENDAR_ID THEN
		RA.PUT_ACCOUNT_CALENDAR(GA.BASE_CASE_ID, p_ACCOUNT_ID, p_CALENDAR_ID, p_CALENDAR_TYPE, p_SERVICE_DATE, NULL, GA.BASE_CASE_ID, p_CALENDAR_ID, p_CALENDAR_TYPE, p_SERVICE_DATE, v_STATUS);
	END IF;


END PUT_ACCOUNT_CALENDAR;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_SL_WEATHER_AND_POINT
	(
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_WEATHER_STATION_NAME IN VARCHAR,
	p_SERVICE_POINT_NAME IN VARCHAR
	) AS

-- Update the Service Location Service Point and Weather Station.

v_SERVICE_POINT_ID NUMBER;
v_WEATHER_STATION_ID NUMBER;

BEGIN

	ID.ID_FOR_SERVICE_POINT(p_SERVICE_POINT_NAME, v_SERVICE_POINT_ID);
	ID.ID_FOR_WEATHER_STATION(p_WEATHER_STATION_NAME, v_WEATHER_STATION_ID);

	UPDATE SERVICE_LOCATION SET
		SERVICE_POINT_ID = v_SERVICE_POINT_ID,
		WEATHER_STATION_ID = v_WEATHER_STATION_ID,
		ENTRY_DATE = SYSDATE
	WHERE SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID;


END PUT_SL_WEATHER_AND_POINT;
----------------------------------------------------------------------------------------------------
PROCEDURE BUG_MARKET_PRICE_AND_BASIS
    (
	p_REQUEST_TYPE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the backup generation market price and basis.

v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

    p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	OPEN p_CURSOR FOR
		SELECT D.ESP_NAME, A.ESP_ID, FROM_CUT(A.LOAD_DATE, LOCAL_TIME_ZONE) "LOAD_DATE" , A.LOAD_VAL, C.PRICE
		FROM
			(SELECT B.EDC_ID, B.ESP_ID, D.LOAD_DATE, SUM(D.LOAD_VAL + D.UFE_LOAD_VAL) "LOAD_VAL"
			FROM SERVICE_OBLIGATION A, PROVIDER_SERVICE B, SERVICE_DELIVERY C, SERVICE_OBLIGATION_LOAD D
			WHERE A.MODEL_ID = GA.DEFAULT_MODEL
				AND A.SCENARIO_ID = GA.BASE_SCENARIO_ID
				AND A.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM SERVICE_OBLIGATION
					WHERE MODEL_ID = A.MODEL_ID
						AND SCENARIO_ID = A.SCENARIO_ID
						AND AS_OF_DATE <= p_AS_OF_DATE
						AND PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
						AND SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID)
				AND B.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
				AND C.SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
				AND C.IS_BUG = 1
				AND D.SERVICE_OBLIGATION_ID = A.SERVICE_OBLIGATION_ID
				AND D.SERVICE_CODE = UPPER(SUBSTR(p_REQUEST_TYPE,1,1))
				AND D.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND D.LOAD_CODE = GA.STANDARD
			GROUP BY B.EDC_ID, B.ESP_ID, D.LOAD_DATE) A,
			MARKET_PRICE B, MARKET_PRICE_VALUE C, ENERGY_SERVICE_PROVIDER D
		WHERE B.EDC_ID = A.EDC_ID
			AND UPPER(RTRIM(B.MARKET_PRICE_TYPE)) = 'BACKUP GENERATION'
			AND C.MARKET_PRICE_ID = B.MARKET_PRICE_ID
			AND C.PRICE_CODE = DECODE(UPPER(SUBSTR(p_REQUEST_TYPE,1,1)),'F','F','B','P','U','A','A')
			AND C.PRICE_DATE(+) = A.LOAD_DATE
			AND C.AS_OF_DATE = MARKET_PRICE_AS_OF_DATE(C.MARKET_PRICE_ID, C.PRICE_CODE, C.PRICE_DATE, p_AS_OF_DATE)
			AND D.ESP_ID = A.ESP_ID
		ORDER BY 1,3;


END BUG_MARKET_PRICE_AND_BASIS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_EDC_EXTERNAL_ID
	(
	p_EDC_DUNS_NUMBER IN VARCHAR,
	p_EDC_EXTERNAL_IDENT OUT VARCHAR,
	p_STATUS OUT NUMBER
	) AS

-- Answer the edc external identifier for an edc duns number

BEGIN

    p_STATUS := GA.SUCCESS;

	SELECT EDC_EXTERNAL_IDENTIFIER
	INTO p_EDC_EXTERNAL_IDENT
	FROM ENERGY_DISTRIBUTION_COMPANY
	WHERE EDC_DUNS_NUMBER = p_EDC_DUNS_NUMBER
	    AND ROWNUM = 1;

	EXCEPTION
	    WHEN NO_DATA_FOUND THEN
			 p_EDC_EXTERNAL_IDENT := TO_CHAR(CONSTANTS.NOT_ASSIGNED);
	    WHEN OTHERS THEN
			 p_EDC_EXTERNAL_IDENT := TO_CHAR(CONSTANTS.NOT_ASSIGNED);
			 p_STATUS := SQLCODE;

END GET_EDC_EXTERNAL_ID;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_EDC_ID
	(
	p_EDC_DUNS_NUMBER IN VARCHAR,
	p_EDC_ID OUT NUMBER,
	p_STATUS OUT NUMBER
	) AS

-- Answer the edc id for an edc duns number

BEGIN

    p_STATUS := GA.SUCCESS;

	SELECT EDC_ID
	INTO p_EDC_ID
	FROM ENERGY_DISTRIBUTION_COMPANY
	WHERE EDC_DUNS_NUMBER = p_EDC_DUNS_NUMBER
    AND ROWNUM = 1;

	EXCEPTION
	    WHEN NO_DATA_FOUND THEN
             p_STATUS := GA.NO_DATA_FOUND;
			 p_EDC_ID := CONSTANTS.NOT_ASSIGNED;
	    WHEN OTHERS THEN
			 p_EDC_ID := CONSTANTS.NOT_ASSIGNED;
			 p_STATUS := SQLCODE;

END GET_EDC_ID;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_EDC_NAME
	(
	p_EDC_ID IN  NUMBER,
	p_EDC_NAME OUT VARCHAR,
	p_STATUS OUT NUMBER
	)AS

-- Answer the edc name for an edc id

BEGIN

    p_STATUS := GA.SUCCESS;

	SELECT EDC_NAME
	INTO p_EDC_NAME
	FROM ENERGY_DISTRIBUTION_COMPANY
	WHERE EDC_ID = p_EDC_ID
    AND ROWNUM = 1;

	EXCEPTION
	    WHEN NO_DATA_FOUND THEN
	         p_STATUS := GA.NO_DATA_FOUND;
	    WHEN OTHERS THEN
			 p_STATUS := SQLCODE;

END GET_EDC_NAME;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_ESP_ID
	(
	p_ESP_DUNS_NUMBER IN VARCHAR,
	p_ESP_ID OUT NUMBER,
	p_STATUS OUT NUMBER
	) AS

-- Answer the ESP id for an ESP duns number

BEGIN

    p_STATUS := GA.SUCCESS;

	SELECT ESP_ID
	INTO p_ESP_ID
	FROM ENERGY_SERVICE_PROVIDER
	WHERE ESP_DUNS_NUMBER = p_ESP_DUNS_NUMBER
	    AND ROWNUM = 1;

	EXCEPTION
	    WHEN NO_DATA_FOUND THEN
	         p_STATUS := GA.NO_DATA_FOUND;
			 p_ESP_ID := CONSTANTS.NOT_ASSIGNED;
	    WHEN OTHERS THEN
			 p_ESP_ID := CONSTANTS.NOT_ASSIGNED;
			 p_STATUS := SQLCODE;

END GET_ESP_ID;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_AGGREGATE_USAGE_FACTOR
	(
	p_ACCOUNT_ID NUMBER,
	p_ESP_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_USAGE_FACTOR OUT NUMBER,
	p_STATUS OUT NUMBER
	) AS

v_AGGREGATE_ID AGGREGATE_ACCOUNT_ESP.AGGREGATE_ID%TYPE;
v_AS_OF_DATE DATE;
v_CASE_ID NUMBER;

BEGIN

	p_STATUS := GA.SUCCESS;

	--Must include CASE_ID in all queries where it is part of Primary Key to avoid very slow queries against large tables
	v_CASE_ID := GA.BASE_CASE_ID;    --Base_Case Only for now

	ID_FOR_AGGREGATE_ACCOUNT_ESP(p_ACCOUNT_ID, p_ESP_ID, CONSTANTS.NOT_ASSIGNED, p_SERVICE_DATE, v_AGGREGATE_ID, p_STATUS);


	IF GA.VERSION_AGGREGATE_ACCOUNT_SVC  THEN
		v_AS_OF_DATE := p_AS_OF_DATE;
	ELSE
		v_AS_OF_DATE := LOW_DATE;
	END IF;

	SELECT USAGE_FACTOR
	INTO p_USAGE_FACTOR
	FROM AGGREGATE_ACCOUNT_SERVICE A
	WHERE AGGREGATE_ID = v_AGGREGATE_ID
		AND CASE_ID = v_CASE_ID        --Query is much faster with CASE_ID specified
		AND SERVICE_DATE = p_SERVICE_DATE
		AND AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM AGGREGATE_ACCOUNT_SERVICE A
			WHERE AGGREGATE_ID = v_AGGREGATE_ID    --Don't use A.AGGREGATE_ID here - it is much slower when table is large - wjc
				AND CASE_ID = v_CASE_ID        --Query is much faster with CASE_ID specified in subquery and outer query!!!!
				AND SERVICE_DATE = A.SERVICE_DATE
				AND AS_OF_DATE <= v_AS_OF_DATE);

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_STATUS := GA.NO_DATA_FOUND;
		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END GET_AGGREGATE_USAGE_FACTOR;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_LATEST_AGG_USAGE_FACTOR
	(
	p_ACCOUNT_ID NUMBER,
	p_ESP_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_USAGE_FACTOR OUT NUMBER,
	p_STATUS OUT NUMBER
	) AS

v_AGGREGATE_ID AGGREGATE_ACCOUNT_ESP.AGGREGATE_ID%TYPE;
v_AS_OF_DATE DATE;
v_CASE_ID NUMBER;

CURSOR c_USAGE_FACTOR IS
	SELECT USAGE_FACTOR
	FROM AGGREGATE_ACCOUNT_SERVICE A
	WHERE AGGREGATE_ID = v_AGGREGATE_ID
		AND CASE_ID = v_CASE_ID        --Query is much faster with CASE_ID specified
		AND SERVICE_DATE =
			(SELECT MAX(SERVICE_DATE)
			FROM AGGREGATE_ACCOUNT_SERVICE
			WHERE AGGREGATE_ID = v_AGGREGATE_ID    --Don't use A.AGGREGATE_ID here - it is much slower when table is large - wjc
				AND CASE_ID = v_CASE_ID        --Query is much faster with CASE_ID specified in subquery and outer query!!!!
				AND SERVICE_DATE <= p_SERVICE_DATE
				AND USAGE_FACTOR IS NOT NULL)
		AND AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM AGGREGATE_ACCOUNT_SERVICE
			WHERE AGGREGATE_ID = v_AGGREGATE_ID    --Don't use A.AGGREGATE_ID here - it is much slower when table is large - wjc
				AND CASE_ID = v_CASE_ID        --Query is much faster with CASE_ID specified in subquery and outer query!!!!
				AND SERVICE_DATE = A.SERVICE_DATE
				AND AS_OF_DATE <= v_AS_OF_DATE
				AND USAGE_FACTOR IS NOT NULL)
		AND USAGE_FACTOR IS NOT NULL
	ORDER BY SERVICE_DATE DESC;

BEGIN

	p_STATUS := GA.SUCCESS;

	--Must include CASE_ID in all queries where it is part of Primary Key to avoid very slow queries against large tables
	v_CASE_ID := GA.BASE_CASE_ID;    --Base_Case Only for now

	p_USAGE_FACTOR := 1.0;

	ID_FOR_AGGREGATE_ACCOUNT_ESP(p_ACCOUNT_ID, p_ESP_ID, CONSTANTS.NOT_ASSIGNED ,p_SERVICE_DATE, v_AGGREGATE_ID, p_STATUS);

	IF GA.VERSION_AGGREGATE_ACCOUNT_SVC THEN
		v_AS_OF_DATE := p_AS_OF_DATE;
	ELSE
		v_AS_OF_DATE := LOW_DATE;
	END IF;

	FOR v_USAGE_FACTOR IN c_USAGE_FACTOR LOOP
		p_USAGE_FACTOR := v_USAGE_FACTOR.USAGE_FACTOR;
		EXIT;
	END LOOP;


END GET_LATEST_AGG_USAGE_FACTOR;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_AGGREGATE_ANCILLARY_SVC
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SERVICE_VAL IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

-- Insert or update the ancillary service values associated with an aggregate account.

v_AS_OF_DATE DATE;
v_SERVICE_DATE DATE := TRUNC(p_SERVICE_DATE);
v_AGGREGATE_ID NUMBER;

BEGIN

	ID_FOR_AGGREGATE_ACCOUNT_ESP(p_ACCOUNT_ID, p_ESP_ID, CONSTANTS.NOT_ASSIGNED, v_SERVICE_DATE, v_AGGREGATE_ID, p_STATUS);
	IF NOT p_STATUS = GA.SUCCESS THEN
		RETURN;
	END IF;

	p_STATUS := GA.SUCCESS;
	IF NOT GA.VERSION_AGGREGATE_ACCOUNT_SVC THEN
		v_AS_OF_DATE := LOW_DATE;
	END IF;

	UPDATE AGGREGATE_ANCILLARY_SERVICE
	SET SERVICE_VAL = p_SERVICE_VAL
	WHERE AGGREGATE_ID = v_AGGREGATE_ID
		AND ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID
	    AND SERVICE_DATE = v_SERVICE_DATE
	    AND AS_OF_DATE = v_AS_OF_DATE;

	IF SQL%NOTFOUND THEN
	    INSERT INTO AGGREGATE_ANCILLARY_SERVICE(
			AGGREGATE_ID,
			ANCILLARY_SERVICE_ID,
			SERVICE_DATE,
			AS_OF_DATE,
			SERVICE_VAL)
		VALUES(
			v_AGGREGATE_ID,
			p_ANCILLARY_SERVICE_ID,
			v_SERVICE_DATE,
			v_AS_OF_DATE,
			p_SERVICE_VAL);
	END IF;


END PUT_AGGREGATE_ANCILLARY_SVC;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_AGGREGATE_ACCOUNT_CUSTOMER
	(
	p_CUSTOMER_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS

v_AGGREGATE_CUSTOMER AGGREGATE_CUSTOMER_TABLE := AGGREGATE_CUSTOMER_TABLE(); --initialize table
v_END_DATE DATE;
v_INITIAL BOOLEAN;
v_LOOP BINARY_INTEGER;
v_AGGREGATE_ID NUMBER(9);

BEGIN

	IF NOT CAN_WRITE('Data Setup') THEN
		ERRS.RAISE_NO_WRITE_MODULE('Data Setup');
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

	BEGIN
		SELECT AGGREGATE_ID
		INTO v_AGGREGATE_ID
		FROM AGGREGATE_ACCOUNT_ESP
		WHERE ESP_ID = p_ESP_ID
			AND POOL_ID = p_POOL_ID
			AND ACCOUNT_ID = p_ACCOUNT_ID
			AND BEGIN_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND NVL(TRUNC(p_END_DATE),HIGH_DATE);
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				p_STATUS := GA.NO_DATA_FOUND;
				RETURN;
			WHEN TOO_MANY_ROWS THEN
				p_STATUS := GA.DUPLICATE_ENTITY;
				RETURN;
			WHEN OTHERS THEN
				p_STATUS := SQLCODE;
				RETURN;
	END;



-- Delete Any Existing Assignments For This Customer That Are Completely Over-ridden By This Assignment.
	DELETE AGGREGATE_ACCOUNT_CUSTOMER
	WHERE CUSTOMER_ID = p_CUSTOMER_ID
		AND TRUNC(p_BEGIN_DATE) <= BEGIN_DATE
		AND NVL(v_END_DATE, HIGH_DATE) >= NVL(END_DATE, HIGH_DATE);

-- Update The Current Customer Assignment If One Exists
	UPDATE AGGREGATE_ACCOUNT_CUSTOMER SET
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		ENTRY_DATE = SYSDATE
	WHERE CUSTOMER_ID = p_CUSTOMER_ID
		AND AGGREGATE_ID = v_AGGREGATE_ID;

-- No Assignment Update For This Customer Esp/pool/account Combination So Insert A New Assignment
	IF SQL%NOTFOUND THEN
		INSERT INTO AGGREGATE_ACCOUNT_CUSTOMER(
			CUSTOMER_ID,
			AGGREGATE_ID,
			BEGIN_DATE,
			END_DATE,
			ENTRY_DATE)
		VALUES(
			p_CUSTOMER_ID,
			v_AGGREGATE_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			SYSDATE);
	END IF;

    --Get all AGGREGATE_ACCOUNT_CUSTOMER records for the customer id in BEGIN_DATE DESC order
	SELECT AGGREGATE_CUSTOMER_TYPE(CUSTOMER_ID, AGGREGATE_ID, BEGIN_DATE, END_DATE, ENTRY_DATE)
	BULK COLLECT INTO v_AGGREGATE_CUSTOMER
	FROM AGGREGATE_ACCOUNT_CUSTOMER
	WHERE
		CUSTOMER_ID = p_CUSTOMER_ID AND
		AGGREGATE_ID = v_AGGREGATE_ID AND
		p_BEGIN_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE,p_BEGIN_DATE)
	ORDER BY BEGIN_DATE DESC;

	v_INITIAL := TRUE;

	FOR v_LOOP IN 1..v_AGGREGATE_CUSTOMER.COUNT LOOP
		IF v_INITIAL THEN
			v_END_DATE := v_AGGREGATE_CUSTOMER(v_LOOP).END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE AGGREGATE_ACCOUNT_CUSTOMER
		SET END_DATE = GREATEST(v_END_DATE, v_AGGREGATE_CUSTOMER(v_LOOP).BEGIN_DATE)
		WHERE CUSTOMER_ID = v_AGGREGATE_CUSTOMER(v_LOOP).CUSTOMER_ID
			AND AGGREGATE_ID = v_AGGREGATE_CUSTOMER(v_LOOP).AGGREGATE_ID
			AND BEGIN_DATE = v_AGGREGATE_CUSTOMER(v_LOOP).BEGIN_DATE;
		v_END_DATE := v_AGGREGATE_CUSTOMER(v_LOOP).BEGIN_DATE - 1;
	END LOOP;

	v_AGGREGATE_CUSTOMER.DELETE;

EXCEPTION
	WHEN OTHERS THEN
		IF v_AGGREGATE_CUSTOMER.COUNT > 0 THEN
			v_AGGREGATE_CUSTOMER.DELETE;
		END IF;
		ERRS.LOG_AND_RAISE();

END PUT_AGGREGATE_ACCOUNT_CUSTOMER;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_INCUMBENT_ID
	(
	p_INCUMBENT_TYPE IN VARCHAR,
	p_INCUMBENT_ID OUT  NUMBER
	) AS

-- Answer the imcumbent entity for an entity type

BEGIN

	SELECT INCUMBENT_ID
	INTO p_INCUMBENT_ID
	FROM INCUMBENT_ENTITY
	WHERE INCUMBENT_TYPE = p_INCUMBENT_TYPE;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_INCUMBENT_ID := GA.NO_DATA_FOUND;
		WHEN TOO_MANY_ROWS THEN
			p_INCUMBENT_ID := GA.TOO_MANY_ROWS;
END GET_INCUMBENT_ID;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_ACCOUNT_NAME
	(
	p_ACCOUNT_ID IN  NUMBER,
	p_ACCOUNT_NAME OUT VARCHAR,
	p_STATUS OUT NUMBER
	) AS

-- Answer the acccount name for an account id

BEGIN

	p_STATUS := GA.SUCCESS;

	SELECT ACCOUNT_NAME
	INTO p_ACCOUNT_NAME
	FROM ACCOUNT
	WHERE ACCOUNT_ID = p_ACCOUNT_ID;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_STATUS := GA.NO_DATA_FOUND;
		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END GET_ACCOUNT_NAME;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_NAME
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ACCOUNT_NAME IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

-- Update the NAME associated with an existing retail account entity

v_COUNT NUMBER := 0;

BEGIN

	p_STATUS := GA.SUCCESS;

    SELECT COUNT(ACCOUNT_NAME)
	INTO v_COUNT
	FROM ACCOUNT
	WHERE ACCOUNT_NAME = p_ACCOUNT_NAME;

	IF v_COUNT = 0 THEN
		p_STATUS := GA.NO_DATA_FOUND;
	ELSIF v_COUNT > 1 AND GA.ENFORCE_UNIQUE_NAMES  THEN
		p_STATUS := GA.DUPLICATE_ENTITY;
	ELSE
		UPDATE ACCOUNT
		SET ACCOUNT_NAME = p_ACCOUNT_NAME,
			ENTRY_DATE = SYSDATE
		WHERE ACCOUNT_ID = p_ACCOUNT_ID;
	END IF;


END PUT_ACCOUNT_NAME;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_ESP_NAME
	(
	p_ESP_ID IN  NUMBER,
	p_ESP_NAME OUT VARCHAR,
	p_STATUS OUT NUMBER
	) AS

-- Answer the ESP name for an ESP id

BEGIN

	p_STATUS := GA.SUCCESS;

	SELECT ESP_NAME
	INTO p_ESP_NAME
	FROM ENERGY_SERVICE_PROVIDER
	WHERE ESP_ID = p_ESP_ID;

	EXCEPTION
	    WHEN NO_DATA_FOUND THEN
	         p_STATUS := GA.NO_DATA_FOUND;
	    WHEN OTHERS THEN
			 p_STATUS := SQLCODE;

END GET_ESP_NAME;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_ATTRIBUTE_ID
	(
	p_ATTRIBUTE_NAME IN VARCHAR,
	p_ATTRIBUTE_ID OUT  NUMBER
	) AS

-- Answer the ATTRITUBE_ID for an ATTRIBUTE_NAME

BEGIN

	SELECT ATTRIBUTE_ID
	INTO p_ATTRIBUTE_ID
	FROM ENTITY_ATTRIBUTE A
	WHERE A.ENTITY_DOMAIN_ID = -560
		AND A.ATTRIBUTE_NAME = p_ATTRIBUTE_NAME;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_ATTRIBUTE_ID := GA.NO_DATA_FOUND;
		WHEN TOO_MANY_ROWS THEN
			p_ATTRIBUTE_ID := GA.TOO_MANY_ROWS;
END GET_ATTRIBUTE_ID;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_CUSTOMER_ATTRIBUTE
	(
	p_CUSTOMER_ID IN  NUMBER,
	p_ATTRIBUTE_ID IN  NUMBER,
	p_BEGIN_DATE IN DATE,
	p_ATTRIBUTE_VAL OUT VARCHAR,
	p_STATUS OUT NUMBER
	) AS

-- Answer the ATTRIBUTE_VAL  for a customer_id, attribute_id, and begin_date combination

BEGIN

	p_STATUS := GA.SUCCESS;

	SELECT ATTRIBUTE_VAL
	INTO p_ATTRIBUTE_VAL
	FROM TEMPORAL_ENTITY_ATTRIBUTE
	WHERE OWNER_ENTITY_ID = p_CUSTOMER_ID
		AND ATTRIBUTE_ID = p_ATTRIBUTE_ID
		AND BEGIN_DATE <= p_BEGIN_DATE
		AND ENTITY_DOMAIN_ID = -560
		AND NVL(END_DATE,p_BEGIN_DATE) >= p_BEGIN_DATE;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_STATUS := GA.NO_DATA_FOUND;
		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END GET_CUSTOMER_ATTRIBUTE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_CUSTOMER_ATTRIBUTE
	(
	p_CUSTOMER_ID IN NUMBER,
	p_ATTRIBUTE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ATTRIBUTE_VAL IN VARCHAR,
	P_OLD_ATTRIBUTE_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS


v_END_DATE DATE;
v_INITIAL BOOLEAN;
v_LOOP BINARY_INTEGER;
v_ATTRIBUTE_NAME ENTITY_ATTRIBUTE.ATTRIBUTE_NAME%TYPE;
v_CUSTOMER_ATTRIBUTE CUSTOMER_ATTRIBUTE_TABLE := CUSTOMER_ATTRIBUTE_TABLE(); --initialize table

BEGIN

	IF NOT CAN_WRITE('Data Setup') THEN
		ERRS.RAISE_NO_WRITE_MODULE('Data Setup');
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- Delete Any Existing Attribute Assignments For This Customer That Are Completely Over-ridden By This Assignment.
	DELETE TEMPORAL_ENTITY_ATTRIBUTE
	WHERE OWNER_ENTITY_ID = p_CUSTOMER_ID
		AND ATTRIBUTE_ID = p_ATTRIBUTE_ID
		AND TRUNC(p_BEGIN_DATE) <= BEGIN_DATE
		AND ENTITY_DOMAIN_ID = -560
		AND NVL(v_END_DATE, HIGH_DATE) >= NVL(END_DATE, HIGH_DATE);

-- Update The Current Customer Attribute Assignment If One Exists
   UPDATE TEMPORAL_ENTITY_ATTRIBUTE SET
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		ATTRIBUTE_ID = p_ATTRIBUTE_ID,
		ATTRIBUTE_VAL = p_ATTRIBUTE_VAL
	WHERE OWNER_ENTITY_ID = p_CUSTOMER_ID
		AND ATTRIBUTE_ID = p_OLD_ATTRIBUTE_ID
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- No Attribute Assignment Update For This Customer Attribute Combination So Insert A New Attribute Assignment
	IF SQL%NOTFOUND THEN
		SELECT ATTRIBUTE_NAME INTO v_ATTRIBUTE_NAME FROM ENTITY_ATTRIBUTE WHERE ATTRIBUTE_ID = p_ATTRIBUTE_ID;
		INSERT INTO TEMPORAL_ENTITY_ATTRIBUTE
			(
			OWNER_ENTITY_ID,
			ATTRIBUTE_ID,
			BEGIN_DATE,
			ENTITY_DOMAIN_ID,
			ATTRIBUTE_NAME,
			END_DATE,
			ATTRIBUTE_VAL,
			ENTRY_DATE
			)
		VALUES
			(
			p_CUSTOMER_ID,
			p_ATTRIBUTE_ID,
			TRUNC(p_BEGIN_DATE),
			-560,
			v_ATTRIBUTE_NAME,
			TRUNC(v_END_DATE),
			p_ATTRIBUTE_VAL,
			SYSDATE
			);
	END IF;

--Get all customer_service records for the customer id in BEGIN_DATE DESC order
	SELECT CUSTOMER_ATTRIBUTE_TYPE(OWNER_ENTITY_ID, ATTRIBUTE_ID, BEGIN_DATE, END_DATE, ATTRIBUTE_VAL)
	BULK COLLECT INTO v_CUSTOMER_ATTRIBUTE
	FROM TEMPORAL_ENTITY_ATTRIBUTE
	WHERE OWNER_ENTITY_ID = p_CUSTOMER_ID
    ORDER BY BEGIN_DATE DESC;

	v_INITIAL := TRUE;

	FOR v_LOOP IN 1..v_CUSTOMER_ATTRIBUTE.COUNT LOOP
		IF v_INITIAL THEN
			v_END_DATE := v_CUSTOMER_ATTRIBUTE(v_LOOP).END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE TEMPORAL_ENTITY_ATTRIBUTE
		SET END_DATE = GREATEST(v_END_DATE, v_CUSTOMER_ATTRIBUTE(v_LOOP).BEGIN_DATE)
		WHERE OWNER_ENTITY_ID = v_CUSTOMER_ATTRIBUTE(v_LOOP).CUSTOMER_ID
			AND ATTRIBUTE_ID = v_CUSTOMER_ATTRIBUTE(v_LOOP).ATTRIBUTE_ID
			AND BEGIN_DATE = v_CUSTOMER_ATTRIBUTE(v_LOOP).BEGIN_DATE;
		v_END_DATE := v_CUSTOMER_ATTRIBUTE(v_LOOP).BEGIN_DATE - 1;
	END LOOP;

	v_CUSTOMER_ATTRIBUTE.DELETE;

END PUT_CUSTOMER_ATTRIBUTE;
----------------------------------------------------------------------------------------------------
PROCEDURE CUSTOMER_TO_AGGREGATE_ACCOUNT
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS

-- Update the esp customers of record over the specified begin and end date range.

v_SERVICE_DATE DATE := TRUNC(p_BEGIN_DATE);
v_AS_OF_DATE DATE;

CURSOR c_CUSTOMER_SERVICE IS
	SELECT C.ESP_ID, C.POOL_ID, C.ACCOUNT_ID, COUNT(1) "SERVICE_ACCOUNTS"
	FROM AGGREGATE_ACCOUNT_CUSTOMER A, CUSTOMER B, AGGREGATE_ACCOUNT_ESP C
	WHERE v_SERVICE_DATE BETWEEN A.BEGIN_DATE AND NVL(A.END_DATE, v_SERVICE_DATE)
		AND B.CUSTOMER_ID = A.CUSTOMER_ID
		AND B.CUSTOMER_IS_ACTIVE = 1
		AND C.AGGREGATE_ID = A.AGGREGATE_ID
	GROUP BY C.ESP_ID, C.POOL_ID, C.ACCOUNT_ID;

BEGIN

	IF NOT CAN_WRITE('Data Setup') THEN
		ERRS.RAISE_NO_WRITE_MODULE('Data Setup');
	END IF;

	p_STATUS := GA.SUCCESS;

	IF GA.VERSION_AGGREGATE_ACCOUNT_SVC THEN
		v_AS_OF_DATE := SYSDATE;
	ELSE
		v_AS_OF_DATE := LOW_DATE;
	END IF;
	WHILE v_SERVICE_DATE <= TRUNC(p_END_DATE) LOOP
		DELETE AGGREGATE_ACCOUNT_SERVICE WHERE SERVICE_DATE = v_SERVICE_DATE;
		FOR v_CUSTOMER_SERVICE IN c_CUSTOMER_SERVICE LOOP
			PUT_AGGREGATE_ACCOUNT_SERVICE(GA.BASE_CASE_ID, v_CUSTOMER_SERVICE.ACCOUNT_ID, v_CUSTOMER_SERVICE.ESP_ID, v_CUSTOMER_SERVICE.POOL_ID, v_SERVICE_DATE, v_AS_OF_DATE, v_CUSTOMER_SERVICE.SERVICE_ACCOUNTS, 1, p_STATUS);
		END LOOP;
		v_SERVICE_DATE := v_SERVICE_DATE + 1;
	END LOOP;


END CUSTOMER_TO_AGGREGATE_ACCOUNT;
----------------------------------------------------------------------------------------------------
PROCEDURE SYNC_STATION_PARAMETER
	(
	p_STATION_PARAMETER_SYNC IN STATION_PARAMETER_SYNC_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

-- Sync the weather station parameter with the contents of the date and value pairs.

BEGIN

	IF NOT CAN_WRITE('Data Setup') THEN
		ERRS.RAISE_NO_WRITE_MODULE('Data Setup');
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK';

-- Update any existing weather parameter data.
	UPDATE STATION_PARAMETER_VALUE X
	SET PARAMETER_VAL =
		(SELECT PARAMETER_VAL
		FROM TABLE(CAST(p_STATION_PARAMETER_SYNC AS STATION_PARAMETER_SYNC_TABLE)) A,
			WEATHER_STATION B,
			WEATHER_PARAMETER C
		WHERE B.STATION_NAME = A.STATION_NAME
			AND C.PARAMETER_NAME = A.PARAMETER_NAME
			AND X.STATION_ID = B.STATION_ID
			AND X.PARAMETER_ID = C.PARAMETER_ID
			AND X.PARAMETER_CODE = A.PARAMETER_CODE
			AND X.PARAMETER_DATE = TO_CUT(A.PARAMETER_DATE, DECODE_TIME_ZONE(B.TIME_ZONE)));

-- Introduce new records with a null end date that do not have a corresponding entry in the table.
	INSERT INTO STATION_PARAMETER_VALUE (STATION_ID, PARAMETER_ID, PARAMETER_CODE, PARAMETER_DATE, PARAMETER_VAL)
	SELECT B.STATION_ID, C.PARAMETER_ID, A.PARAMETER_CODE, TO_CUT(A.PARAMETER_DATE, DECODE_TIME_ZONE(B.TIME_ZONE)), A.PARAMETER_VAL
	FROM TABLE(CAST(p_STATION_PARAMETER_SYNC AS STATION_PARAMETER_SYNC_TABLE)) A,
		WEATHER_STATION B,
		WEATHER_PARAMETER C
	WHERE B.STATION_NAME = A.STATION_NAME
		AND C.PARAMETER_NAME = A.PARAMETER_NAME
		AND NOT EXISTS
			(SELECT 1
			FROM STATION_PARAMETER_VALUE
			WHERE STATION_ID = B.STATION_ID
				AND PARAMETER_ID = C.PARAMETER_ID
				AND PARAMETER_CODE = A.PARAMETER_CODE
				AND PARAMETER_DATE = TO_CUT(A.PARAMETER_DATE, DECODE_TIME_ZONE(B.TIME_ZONE)));

-- 	EXCEPTION
-- 		WHEN OTHERS THEN
-- 			p_STATUS := SQLCODE;
-- 			p_MESSAGE := SQLERRM;

END SYNC_STATION_PARAMETER;
----------------------------------------------------------------------------------------------------
PROCEDURE SYNC_RETAIL_ACCOUNT
	(
	p_ACCOUNT_IDENTIFIER_TYPE IN CHAR,
	p_ACCOUNT_SYNC IN ACCOUNT_SYNC_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

-- Synchronize the Retail Accounts.

v_SYSDATE DATE := SYSDATE;

BEGIN

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK';

	UPDATE ACCOUNT A SET
		(ACCOUNT_ALIAS,
		ACCOUNT_EXTERNAL_IDENTIFIER,
		ACCOUNT_DISPLAY_NAME,
		ACCOUNT_MODEL_OPTION,
		MODEL_ID,
		ACCOUNT_SIC_CODE,
		ACCOUNT_METER_TYPE,
		IS_UFE_PARTICIPANT,
		IS_EXTERNAL_INTERVAL_USAGE,
		IS_CREATE_SETTLEMENT_PROFILE,
		IS_EXTERNAL_FORECAST,
		ENTRY_DATE) =
			(SELECT ACCOUNT_ALIAS,
				ACCOUNT_EXTERNAL_IDENTIFIER,
				ACCOUNT_DISPLAY_NAME,
				INITCAP(DECODE(UPPER(ACCOUNT_MODEL_OPTION),'AGGREGATE','AGGREGATE','METER','METER','ACCOUNT')),
				DECODE(MODEL_ID,2,2,1),
				ACCOUNT_SIC_CODE,
				INITCAP(DECODE(UPPER(ACCOUNT_METER_TYPE),'INTERVAL','INTERVAL','PERIOD')),
				DECODE(IS_UFE_PARTICIPANT,1,1,0),
				DECODE(IS_EXTERNAL_INTERVAL_USAGE,1,1,0),
				DECODE(IS_CREATE_SETTLEMENT_PROFILE,1,1,0),
				DECODE(IS_EXTERNAL_FORECAST,1,1,0),
				v_SYSDATE
			FROM TABLE(CAST(p_ACCOUNT_SYNC AS ACCOUNT_SYNC_TABLE)) X
			WHERE DECODE(p_ACCOUNT_IDENTIFIER_TYPE, 'N',X.ACCOUNT_NAME, 'X',X.ACCOUNT_EXTERNAL_IDENTIFIER) = DECODE(p_ACCOUNT_IDENTIFIER_TYPE, 'N',A.ACCOUNT_NAME, 'X',A.ACCOUNT_EXTERNAL_IDENTIFIER)
				AND NOT(X.ACCOUNT_ALIAS = A.ACCOUNT_ALIAS
					AND X.ACCOUNT_EXTERNAL_IDENTIFIER = A.ACCOUNT_EXTERNAL_IDENTIFIER
					AND INITCAP(DECODE(UPPER(X.ACCOUNT_MODEL_OPTION),'AGGREGATE','AGGREGATE','METER','METER','ACCOUNT')) = A.ACCOUNT_MODEL_OPTION
					AND DECODE(X.MODEL_ID,2,2,1) = A.MODEL_ID
					AND X.ACCOUNT_SIC_CODE = A.ACCOUNT_SIC_CODE
					AND INITCAP(DECODE(UPPER(X.ACCOUNT_METER_TYPE),'INTERVAL','INTERVAL','PERIOD')) = A.ACCOUNT_METER_TYPE
					AND DECODE(X.IS_UFE_PARTICIPANT,1,1,0) = A.IS_UFE_PARTICIPANT
					AND DECODE(X.IS_EXTERNAL_INTERVAL_USAGE,1,1,0) = A.IS_EXTERNAL_INTERVAL_USAGE
					AND DECODE(X.IS_CREATE_SETTLEMENT_PROFILE,1,1,0) = A.IS_CREATE_SETTLEMENT_PROFILE
					AND DECODE(X.IS_EXTERNAL_FORECAST,1,1,0) = A.IS_EXTERNAL_FORECAST));

	INSERT INTO ACCOUNT A
		(ACCOUNT_ID,
		ACCOUNT_NAME,
		ACCOUNT_ALIAS,
		ACCOUNT_EXTERNAL_IDENTIFIER,
		ACCOUNT_DISPLAY_NAME,
		ACCOUNT_MODEL_OPTION,
		MODEL_ID,
		ACCOUNT_SIC_CODE,
		ACCOUNT_METER_TYPE,
		IS_UFE_PARTICIPANT,
		IS_EXTERNAL_INTERVAL_USAGE,
		IS_CREATE_SETTLEMENT_PROFILE,
		IS_EXTERNAL_FORECAST,
		ENTRY_DATE)
			(SELECT OID.NEXTVAL,
				ACCOUNT_NAME,
				ACCOUNT_ALIAS,
				ACCOUNT_EXTERNAL_IDENTIFIER,
				ACCOUNT_DISPLAY_NAME,
				INITCAP(DECODE(UPPER(ACCOUNT_MODEL_OPTION),'AGGREGATE','AGGREGATE','METER','METER','ACCOUNT')),
				DECODE(MODEL_ID,2,2,1),
				ACCOUNT_SIC_CODE,
				INITCAP(DECODE(UPPER(ACCOUNT_METER_TYPE),'INTERVAL','INTERVAL','PERIOD')),
				DECODE(IS_UFE_PARTICIPANT,1,1,0),
				DECODE(IS_EXTERNAL_INTERVAL_USAGE,1,1,0),
				DECODE(IS_CREATE_SETTLEMENT_PROFILE,1,1,0),
				DECODE(IS_EXTERNAL_FORECAST,1,1,0),
				v_SYSDATE
			FROM TABLE(CAST(p_ACCOUNT_SYNC AS ACCOUNT_SYNC_TABLE)) X
			WHERE NOT EXISTS
				(SELECT 1
				FROM ACCOUNT Z
				WHERE DECODE(p_ACCOUNT_IDENTIFIER_TYPE, 'N',Z.ACCOUNT_NAME, 'X',Z.ACCOUNT_EXTERNAL_IDENTIFIER) = DECODE(p_ACCOUNT_IDENTIFIER_TYPE, 'N',X.ACCOUNT_NAME, 'X',X.ACCOUNT_EXTERNAL_IDENTIFIER)));

END SYNC_RETAIL_ACCOUNT;
----------------------------------------------------------------------------------------------------
PROCEDURE SYNC_ACCOUNT_SERVICE_LOCATION
	(
	p_ACCOUNT_IDENTIFIER_TYPE IN CHAR,
	p_ACCOUNT_SYNC IN ACCOUNT_SYNC_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

-- Synchronize the Account Service Location Assigments.

v_ACCOUNT_ID NUMBER;
v_SERVICE_LOCATION_ID NUMBER;
v_LAST_SERVICE_LOCATION_NAME VARCHAR(32) := '?';

BEGIN

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK';

	FOR v_INDEX IN p_ACCOUNT_SYNC.FIRST..p_ACCOUNT_SYNC.LAST LOOP

		IF NOT v_LAST_SERVICE_LOCATION_NAME =  p_ACCOUNT_SYNC(v_INDEX).SERVICE_LOCATION_NAME THEN
			ID.ID_FOR_SERVICE_LOCATION(p_ACCOUNT_SYNC(v_INDEX).SERVICE_LOCATION_NAME, v_SERVICE_LOCATION_ID);
			PUT_SERVICE_LOCATION(v_SERVICE_LOCATION_ID,
				p_ACCOUNT_SYNC(v_INDEX).SERVICE_LOCATION_NAME,
				p_ACCOUNT_SYNC(v_INDEX).SERVICE_LOCATION_NAME, -- Alias
				p_ACCOUNT_SYNC(v_INDEX).SERVICE_LOCATION_NAME, -- Desc
				'.','.', -- Latitude and Longitude
				p_ACCOUNT_SYNC(v_INDEX).ACCOUNT_TIME_ZONE,
				p_ACCOUNT_SYNC(v_INDEX).BILL_CYCLE_NAME,
				p_ACCOUNT_SYNC(v_INDEX).SERVICE_POINT_NAME,
				p_ACCOUNT_SYNC(v_INDEX).WEATHER_STATION_NAME,
				CONSTANTS.NOT_ASSIGNED, -- Business Rollup Name
				CONSTANTS.NOT_ASSIGNED, -- Geographic Rollup Name
				TRUE, -- Create if not found
				p_STATUS);
		END IF;

		IF p_ACCOUNT_IDENTIFIER_TYPE = 'N' THEN
			ID.ID_FOR_ACCOUNT(p_ACCOUNT_SYNC(v_INDEX).ACCOUNT_NAME, v_ACCOUNT_ID);
		ELSIF p_ACCOUNT_IDENTIFIER_TYPE = 'X' THEN
			ID.ID_FOR_ACCOUNT_EXTERNAL_IDENT(p_ACCOUNT_SYNC(v_INDEX).ACCOUNT_EXTERNAL_IDENTIFIER, v_ACCOUNT_ID);
		END IF;

		PUT_ACCOUNT_SERVICE_LOCATION(v_ACCOUNT_ID, v_SERVICE_LOCATION_ID, LOW_DATE);

		v_LAST_SERVICE_LOCATION_NAME := p_ACCOUNT_SYNC(v_INDEX).SERVICE_LOCATION_NAME;

	END LOOP;

-- 	EXCEPTION
-- 		WHEN OTHERS THEN
-- 			p_STATUS := SQLCODE;
-- 			p_MESSAGE := SQLERRM;

END SYNC_ACCOUNT_SERVICE_LOCATION;
----------------------------------------------------------------------------------------------------
PROCEDURE SYNC_ACCOUNT
	(
	p_ACCOUNT_IDENTIFIER_TYPE IN CHAR,
	p_ACCOUNT_SYNC IN ACCOUNT_SYNC_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

-- Synchronize the Retail Accounts.

BEGIN

	IF NOT CAN_WRITE('Data Setup') THEN
		ERRS.RAISE_NO_WRITE_MODULE('Data Setup');
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK';

	SYNC_RETAIL_ACCOUNT(p_ACCOUNT_IDENTIFIER_TYPE, p_ACCOUNT_SYNC, p_STATUS, p_MESSAGE);
	SYNC_ACCOUNT_SERVICE_LOCATION(p_ACCOUNT_IDENTIFIER_TYPE, p_ACCOUNT_SYNC, p_STATUS, p_MESSAGE);

-- 	EXCEPTION
-- 		WHEN OTHERS THEN
-- 			p_STATUS := SQLCODE;
-- 			p_MESSAGE := SQLERRM;

END SYNC_ACCOUNT;
----------------------------------------------------------------------------------------------------
PROCEDURE SYNC_ESP
	(
	p_ESP_IDENTIFIER_TYPE IN CHAR,
	p_ESP_SYNC IN ESP_SYNC_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

-- Synchronize the ESPs.

v_SYSDATE DATE := SYSDATE;

BEGIN

	IF NOT CAN_WRITE('Data Setup') THEN
		ERRS.RAISE_NO_WRITE_MODULE('Data Setup');
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK';

	UPDATE ENERGY_SERVICE_PROVIDER A SET
		(ESP_ALIAS,
		ESP_EXTERNAL_IDENTIFIER,
		ESP_DUNS_NUMBER,
		ESP_STATUS,
 		ESP_TYPE,
		ENTRY_DATE) =
			(SELECT ESP_ALIAS,
				ESP_EXTERNAL_IDENTIFIER,
				ESP_DUNS_NUMBER,
				INITCAP(DECODE(UPPER(ESP_STATUS),'ACTIVE','ACTIVE','INACTIVE')),
 				INITCAP(DECODE(UPPER(ESP_TYPE),'DEFAULT','DEFAULT','STANDARD OFFER','STANDARD OFFER','CERTIFIED')),
				v_SYSDATE
			FROM TABLE(CAST(p_ESP_SYNC AS ESP_SYNC_TABLE)) X
			WHERE DECODE(p_ESP_IDENTIFIER_TYPE, 'N',X.ESP_NAME, 'X',X.ESP_EXTERNAL_IDENTIFIER) = DECODE(p_ESP_IDENTIFIER_TYPE, 'N',A.ESP_NAME, 'X',A.ESP_EXTERNAL_IDENTIFIER)
			AND NOT (A.ESP_ALIAS = X.ESP_ALIAS
				AND A.ESP_EXTERNAL_IDENTIFIER = X.ESP_EXTERNAL_IDENTIFIER
				AND A.ESP_DUNS_NUMBER = X.ESP_DUNS_NUMBER
				AND INITCAP(DECODE(UPPER(A.ESP_STATUS),'ACTIVE','ACTIVE','INACTIVE')) = X.ESP_STATUS
				AND INITCAP(DECODE(UPPER(ESP_TYPE),'DEFAULT','DEFAULT','STANDARD OFFER','STANDARD OFFER','CERTIFIED')) = X.ESP_TYPE));

	INSERT INTO ENERGY_SERVICE_PROVIDER A
		(ESP_NAME,
		ESP_ALIAS,
		ESP_EXTERNAL_IDENTIFIER,
		ESP_DUNS_NUMBER,
		ESP_STATUS,
 		ESP_TYPE,
		ENTRY_DATE)
			(SELECT ESP_NAME,
				ESP_ALIAS,
				ESP_EXTERNAL_IDENTIFIER,
				ESP_DUNS_NUMBER,
				INITCAP(DECODE(UPPER(ESP_STATUS),'ACTIVE','ACTIVE','INACTIVE')),
 				INITCAP(DECODE(UPPER(ESP_TYPE),'DEFAULT','DEFAULT','STANDARD OFFER','STANDARD OFFER','CERTIFIED')),
				v_SYSDATE
			FROM TABLE(CAST(p_ESP_SYNC AS ESP_SYNC_TABLE)) X
			WHERE NOT EXISTS
				(SELECT 1
				FROM ENERGY_SERVICE_PROVIDER Z
				WHERE DECODE(p_ESP_IDENTIFIER_TYPE, 'N',Z.ESP_NAME, 'X',Z.ESP_EXTERNAL_IDENTIFIER) = DECODE(p_ESP_IDENTIFIER_TYPE, 'N',X.ESP_NAME, 'X',X.ESP_EXTERNAL_IDENTIFIER)));

-- 	EXCEPTION
-- 		WHEN OTHERS THEN
-- 			p_STATUS := SQLCODE;
-- 			p_MESSAGE := SQLERRM;

END SYNC_ESP;
----------------------------------------------------------------------------------------------------
PROCEDURE SYNC_AREA_LOAD
	(
	p_AREA_LOAD_SYNC IN AREA_LOAD_SYNC_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

-- Update the Area Load with the contents of the date and value pairs.

v_AS_OF_DATE DATE;
v_TIME_ZONE CHAR(3) := LOCAL_TIME_ZONE;

BEGIN

	IF NOT CAN_WRITE('Data Setup') THEN
		ERRS.RAISE_NO_WRITE_MODULE('Data Setup');
	END IF;

	p_STATUS := GA.SUCCESS;

	IF GA.VERSION_AREA_LOAD THEN
		v_AS_OF_DATE := SYSDATE;
	ELSE
		v_AS_OF_DATE := LOW_DATE;
		DELETE AREA_LOAD X
		WHERE EXISTS
			(SELECT 1
			FROM TABLE(CAST(p_AREA_LOAD_SYNC AS AREA_LOAD_SYNC_TABLE)) A,
				AREA B
			WHERE A.AREA_NAME = B.AREA_NAME
				AND X.AREA_ID = B.AREA_ID
				AND X.LOAD_CODE = A.LOAD_CODE
				AND X.LOAD_DATE = TO_CUT(A.LOAD_DATE, v_TIME_ZONE)
				AND X.AS_OF_DATE = v_AS_OF_DATE);
	END IF;

	INSERT INTO AREA_LOAD (AREA_ID, LOAD_CODE, LOAD_DATE, AS_OF_DATE, LOAD_VAL)
	SELECT B.AREA_ID, A.LOAD_CODE, TO_CUT(A.LOAD_DATE, v_TIME_ZONE), v_AS_OF_DATE, A.LOAD_VAL
	FROM TABLE(CAST(p_AREA_LOAD_SYNC AS AREA_LOAD_SYNC_TABLE)) A,
		AREA B
	WHERE A.AREA_NAME = B.AREA_NAME;

-- 	EXCEPTION
-- 		WHEN OTHERS THEN
-- 			p_STATUS := SQLCODE;
-- 			p_MESSAGE := SQLERRM;

END SYNC_AREA_LOAD;
----------------------------------------------------------------------------------------------------
PROCEDURE SYNC_ACCOUNT_USAGE_FACTOR
	(
	p_ACCOUNT_IDENTIFIER_TYPE IN CHAR,
	p_SYNC_BEGIN_DATE IN DATE,
	p_SYNC_END_DATE IN DATE,
	p_ACCOUNT_USG_FACTOR_SYNC IN ACCOUNT_USG_FACTOR_SYNC_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

-- Synchronize Account Usage Factor Relationship.

v_SYSDATE DATE := SYSDATE;

BEGIN

	IF NOT CAN_WRITE('Data Setup') THEN
		ERRS.RAISE_NO_WRITE_MODULE('Data Setup');
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK';

-- Terminate any records that do not have a corresponding entry in the sync file.
	UPDATE ACCOUNT_USAGE_FACTOR X SET
		END_DATE = TRUNC(v_SYSDATE - 1),
		ENTRY_DATE = v_SYSDATE
	WHERE NOT EXISTS
		(SELECT 1
		FROM ACCOUNT A,
			TABLE(CAST(p_ACCOUNT_USG_FACTOR_SYNC AS ACCOUNT_USG_FACTOR_SYNC_TABLE)) B
		WHERE UPPER(A.ACCOUNT_MODEL_OPTION) = 'ACCOUNT'
			AND B.ACCOUNT_IDENTIFIER = DECODE(p_ACCOUNT_IDENTIFIER_TYPE, 'X', A.ACCOUNT_EXTERNAL_IDENTIFIER, A.ACCOUNT_NAME)
			AND X.ACCOUNT_ID = A.ACCOUNT_ID);

-- Terminate any records that have a corresponding entry in the sync file and an end date less than the sync end date.
	UPDATE ACCOUNT_USAGE_FACTOR X
	SET (END_DATE, ENTRY_DATE) =
		(SELECT END_DATE, v_SYSDATE
		FROM ACCOUNT A,
			TABLE(CAST(p_ACCOUNT_USG_FACTOR_SYNC AS ACCOUNT_USG_FACTOR_SYNC_TABLE)) B
		WHERE UPPER(A.ACCOUNT_MODEL_OPTION) = 'ACCOUNT'
			AND B.ACCOUNT_IDENTIFIER = DECODE(p_ACCOUNT_IDENTIFIER_TYPE, 'X', A.ACCOUNT_EXTERNAL_IDENTIFIER, A.ACCOUNT_NAME)
			AND B.END_DATE <= p_SYNC_END_DATE
			AND X.ACCOUNT_ID = A.ACCOUNT_ID)
	WHERE X.BEGIN_DATE <= p_SYNC_END_DATE
		AND NVL(X.END_DATE, p_SYNC_END_DATE) >= p_SYNC_BEGIN_DATE;

-- Introduce new records with a null end date that do not have a corresponding entry in the table.
	INSERT INTO ACCOUNT_USAGE_FACTOR (ACCOUNT_ID, BEGIN_DATE, END_DATE, FACTOR_VAL, ENTRY_DATE)
	SELECT A.ACCOUNT_ID, B.BEGIN_DATE, DECODE(B.END_DATE, p_SYNC_END_DATE, NULL, B.END_DATE), B.FACTOR_VAL, v_SYSDATE
	FROM ACCOUNT A,
		TABLE(CAST(p_ACCOUNT_USG_FACTOR_SYNC AS ACCOUNT_USG_FACTOR_SYNC_TABLE)) B
	WHERE UPPER(A.ACCOUNT_MODEL_OPTION) = 'ACCOUNT'
		AND B.ACCOUNT_IDENTIFIER = DECODE(p_ACCOUNT_IDENTIFIER_TYPE, 'X', A.ACCOUNT_EXTERNAL_IDENTIFIER, A.ACCOUNT_NAME)
		AND NOT EXISTS
			(SELECT 1
			FROM ACCOUNT_USAGE_FACTOR
			WHERE ACCOUNT_ID = A.ACCOUNT_ID
				AND BEGIN_DATE <= p_SYNC_END_DATE
				AND NVL(END_DATE, p_SYNC_END_DATE) >= p_SYNC_BEGIN_DATE);

END SYNC_ACCOUNT_USAGE_FACTOR;
----------------------------------------------------------------------------------------------------
PROCEDURE SYNC_ACCOUNT_LOSS_FACTOR
	(
	p_ACCOUNT_IDENTIFIER_TYPE IN CHAR,
	p_SYNC_BEGIN_DATE IN DATE,
	p_SYNC_END_DATE IN DATE,
	p_ACCOUNT_LOSS_FACTOR_SYNC IN ACCOUNT_LOSS_FACTOR_SYNC_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

-- Synchronize Account Loss Factor Relationship.

v_SYSDATE DATE := SYSDATE;

BEGIN

	IF NOT CAN_WRITE('Data Setup') THEN
		ERRS.RAISE_NO_WRITE_MODULE('Data Setup');
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK';

    -- Terminate any records that do not have a corresponding entry in the sync file.
 	UPDATE ACCOUNT_LOSS_FACTOR X SET
 		END_DATE = TRUNC(v_SYSDATE - 1),
 		ENTRY_DATE = v_SYSDATE
 	WHERE NOT EXISTS
 		(SELECT 1
 		FROM ACCOUNT A,
 			LOSS_FACTOR B,
 			TABLE(CAST(p_ACCOUNT_LOSS_FACTOR_SYNC AS ACCOUNT_LOSS_FACTOR_SYNC_TABLE)) C
 		WHERE UPPER(A.ACCOUNT_MODEL_OPTION) = 'ACCOUNT'
 			AND C.ACCOUNT_IDENTIFIER = DECODE(p_ACCOUNT_IDENTIFIER_TYPE, 'X', A.ACCOUNT_EXTERNAL_IDENTIFIER, A.ACCOUNT_NAME)
 			AND C.LOSS_FACTOR_NAME = B.LOSS_FACTOR_NAME
 			AND X.ACCOUNT_ID = A.ACCOUNT_ID
 			AND X.LOSS_FACTOR_ID = B.LOSS_FACTOR_ID);

    -- Terminate any records that have a corresponding entry in the sync file and an end date less than the sync end date.
 	UPDATE ACCOUNT_LOSS_FACTOR X SET
 		END_DATE = (SELECT END_DATE
					FROM ACCOUNT A,
						LOSS_FACTOR B,
						TABLE(CAST(p_ACCOUNT_LOSS_FACTOR_SYNC AS ACCOUNT_LOSS_FACTOR_SYNC_TABLE)) C
					WHERE UPPER(A.ACCOUNT_MODEL_OPTION) = 'ACCOUNT'
						AND C.ACCOUNT_IDENTIFIER = DECODE(p_ACCOUNT_IDENTIFIER_TYPE, 'X', A.ACCOUNT_EXTERNAL_IDENTIFIER, A.ACCOUNT_NAME)
						AND C.LOSS_FACTOR_NAME = B.LOSS_FACTOR_NAME
						AND C.END_DATE <= p_SYNC_END_DATE
						AND X.ACCOUNT_ID = A.ACCOUNT_ID
						AND X.LOSS_FACTOR_ID = B.LOSS_FACTOR_ID),
		ENTRY_DATE = v_SYSDATE
 	WHERE X.BEGIN_DATE <= p_SYNC_END_DATE
 		AND NVL(X.END_DATE, p_SYNC_END_DATE) >= p_SYNC_BEGIN_DATE;

    -- Introduce new records with a null end date that do not have a corresponding entry in the table.
 	INSERT INTO ACCOUNT_LOSS_FACTOR (ACCOUNT_ID, LOSS_FACTOR_ID, BEGIN_DATE, END_DATE, ENTRY_DATE)
 	SELECT A.ACCOUNT_ID, B.LOSS_FACTOR_ID, C.BEGIN_DATE, DECODE(C.END_DATE, p_SYNC_END_DATE, NULL, C.END_DATE), v_SYSDATE
 	FROM ACCOUNT A,
 		LOSS_FACTOR B,
 		TABLE(CAST(p_ACCOUNT_LOSS_FACTOR_SYNC AS ACCOUNT_LOSS_FACTOR_SYNC_TABLE)) C
 	WHERE UPPER(A.ACCOUNT_MODEL_OPTION) = 'ACCOUNT'
 		AND C.ACCOUNT_IDENTIFIER = DECODE(p_ACCOUNT_IDENTIFIER_TYPE, 'X', A.ACCOUNT_EXTERNAL_IDENTIFIER, A.ACCOUNT_NAME)
 		AND C.LOSS_FACTOR_NAME = B.LOSS_FACTOR_NAME
 		AND NOT EXISTS
 			(SELECT 1
 			FROM ACCOUNT_LOSS_FACTOR
 			WHERE ACCOUNT_ID = A.ACCOUNT_ID
 				AND LOSS_FACTOR_ID = B.LOSS_FACTOR_ID
 				AND BEGIN_DATE <= p_SYNC_END_DATE
 				AND NVL(END_DATE, p_SYNC_END_DATE) >= p_SYNC_BEGIN_DATE);

END SYNC_ACCOUNT_LOSS_FACTOR;
----------------------------------------------------------------------------------------------------
PROCEDURE SYNC_ACCOUNT_CALENDAR
	(
	p_ACCOUNT_IDENTIFIER_TYPE IN CHAR,
	p_SYNC_BEGIN_DATE IN DATE,
	p_SYNC_END_DATE IN DATE,
	p_ACCOUNT_CALENDAR_SYNC IN ACCOUNT_CALENDAR_SYNC_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

-- Synchronize Account Calendar Relationship.

v_SYSDATE DATE := SYSDATE;

BEGIN

	IF NOT CAN_WRITE('Data Setup') THEN
		ERRS.RAISE_NO_WRITE_MODULE('Data Setup');
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK';

-- Terminate any records that do not have a corresponding entry in the sync file.
	UPDATE ACCOUNT_CALENDAR X SET
		END_DATE = TRUNC(v_SYSDATE - 1),
		ENTRY_DATE = v_SYSDATE
	WHERE NOT EXISTS
		(SELECT 1
		FROM ACCOUNT A,
			CALENDAR B,
			TABLE(CAST(p_ACCOUNT_CALENDAR_SYNC AS ACCOUNT_CALENDAR_SYNC_TABLE)) C
		WHERE UPPER(A.ACCOUNT_MODEL_OPTION) = 'ACCOUNT'
			AND C.ACCOUNT_IDENTIFIER = DECODE(p_ACCOUNT_IDENTIFIER_TYPE, 'X', A.ACCOUNT_EXTERNAL_IDENTIFIER, A.ACCOUNT_NAME)
			AND C.CALENDAR_NAME = B.CALENDAR_NAME
			AND X.ACCOUNT_ID = A.ACCOUNT_ID
			AND X.CALENDAR_ID = B.CALENDAR_ID
			AND UPPER(X.CALENDAR_TYPE) = UPPER(C.CALENDAR_TYPE));

-- Terminate any records that have a corresponding entry in the sync file and an end date less than the sync end date.
	UPDATE ACCOUNT_CALENDAR X
	SET (END_DATE, ENTRY_DATE) =
		(SELECT END_DATE, v_SYSDATE
		FROM ACCOUNT A,
			CALENDAR B,
			TABLE(CAST(p_ACCOUNT_CALENDAR_SYNC AS ACCOUNT_CALENDAR_SYNC_TABLE)) C
		WHERE UPPER(A.ACCOUNT_MODEL_OPTION) = 'ACCOUNT'
			AND C.ACCOUNT_IDENTIFIER = DECODE(p_ACCOUNT_IDENTIFIER_TYPE, 'X', A.ACCOUNT_EXTERNAL_IDENTIFIER, A.ACCOUNT_NAME)
			AND C.CALENDAR_NAME = B.CALENDAR_NAME
			AND C.END_DATE <= p_SYNC_END_DATE
			AND X.ACCOUNT_ID = A.ACCOUNT_ID
			AND X.CALENDAR_ID = B.CALENDAR_ID
			AND UPPER(X.CALENDAR_TYPE) = UPPER(C.CALENDAR_TYPE))
	WHERE X.BEGIN_DATE <= p_SYNC_END_DATE
		AND NVL(X.END_DATE, p_SYNC_END_DATE) >= p_SYNC_BEGIN_DATE;

-- Introduce new records with a null end date that do not have a corresponding entry in the table.
	INSERT INTO ACCOUNT_CALENDAR (ACCOUNT_ID, CALENDAR_ID, CALENDAR_TYPE, BEGIN_DATE, END_DATE, ENTRY_DATE)
	SELECT A.ACCOUNT_ID, B.CALENDAR_ID, INITCAP(UPPER(C.CALENDAR_TYPE)), C.BEGIN_DATE, DECODE(C.END_DATE, p_SYNC_END_DATE, NULL, C.END_DATE), v_SYSDATE
	FROM ACCOUNT A,
		CALENDAR B,
		TABLE(CAST(p_ACCOUNT_CALENDAR_SYNC AS ACCOUNT_CALENDAR_SYNC_TABLE)) C
	WHERE UPPER(A.ACCOUNT_MODEL_OPTION) = 'ACCOUNT'
		AND C.ACCOUNT_IDENTIFIER = DECODE(p_ACCOUNT_IDENTIFIER_TYPE, 'X', A.ACCOUNT_EXTERNAL_IDENTIFIER, A.ACCOUNT_NAME)
		AND C.CALENDAR_NAME = B.CALENDAR_NAME
		AND NOT EXISTS
			(SELECT 1
			FROM ACCOUNT_CALENDAR
			WHERE ACCOUNT_ID = A.ACCOUNT_ID
				AND CALENDAR_ID = B.CALENDAR_ID
				AND UPPER(CALENDAR_TYPE) = UPPER(C.CALENDAR_TYPE)
				AND BEGIN_DATE <= p_SYNC_END_DATE
				AND NVL(END_DATE, p_SYNC_END_DATE) >= p_SYNC_BEGIN_DATE);

END SYNC_ACCOUNT_CALENDAR;
----------------------------------------------------------------------------------------------------
PROCEDURE SYNC_ACCOUNT_EDC
	(
	p_ACCOUNT_IDENTIFIER_TYPE IN CHAR,
	p_EDC_IDENTIFIER_TYPE IN CHAR,
	p_SYNC_BEGIN_DATE IN DATE,
	p_SYNC_END_DATE IN DATE,
	p_ACCOUNT_EDC_SYNC IN ACCOUNT_EDC_SYNC_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

-- Synchronize Account EDC Relationship.

v_SYSDATE DATE := SYSDATE;

BEGIN

	IF NOT CAN_WRITE('Data Setup') THEN
		ERRS.RAISE_NO_WRITE_MODULE('Data Setup');
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK';

-- Terminate any records that do not have a corresponding entry in the sync file.
	UPDATE ACCOUNT_EDC X SET
		END_DATE = TRUNC(v_SYSDATE - 1),
		ENTRY_DATE = v_SYSDATE
	WHERE NOT EXISTS
		(SELECT 1
		FROM ACCOUNT A,
			ENERGY_DISTRIBUTION_COMPANY B,
			TABLE(CAST(p_ACCOUNT_EDC_SYNC AS ACCOUNT_EDC_SYNC_TABLE)) C
		WHERE UPPER(SUBSTR(B.EDC_STATUS,1,1)) = 'A'
			AND C.ACCOUNT_IDENTIFIER = DECODE(p_ACCOUNT_IDENTIFIER_TYPE, 'X', A.ACCOUNT_EXTERNAL_IDENTIFIER, A.ACCOUNT_NAME)
			AND C.EDC_IDENTIFIER = DECODE(p_EDC_IDENTIFIER_TYPE, 'X', B.EDC_EXTERNAL_IDENTIFIER, B.EDC_NAME)
			AND X.ACCOUNT_ID = A.ACCOUNT_ID
			AND X.EDC_ID = B.EDC_ID);

-- Terminate any records that have a corresponding entry in the sync file and an end date less than the sync end date.
	UPDATE ACCOUNT_EDC X
	SET (END_DATE, ENTRY_DATE) =
		(SELECT END_DATE, v_SYSDATE
		FROM ACCOUNT A,
			ENERGY_DISTRIBUTION_COMPANY B,
			TABLE(CAST(p_ACCOUNT_EDC_SYNC AS ACCOUNT_EDC_SYNC_TABLE)) C
		WHERE C.ACCOUNT_IDENTIFIER = DECODE(p_ACCOUNT_IDENTIFIER_TYPE, 'X', A.ACCOUNT_EXTERNAL_IDENTIFIER, A.ACCOUNT_NAME)
			AND C.END_DATE <= p_SYNC_END_DATE
			AND C.EDC_IDENTIFIER = DECODE(p_EDC_IDENTIFIER_TYPE, 'X', B.EDC_EXTERNAL_IDENTIFIER, B.EDC_NAME)
			AND X.ACCOUNT_ID = A.ACCOUNT_ID
			AND X.EDC_ID = B.EDC_ID)
	WHERE X.BEGIN_DATE <= p_SYNC_END_DATE
		AND NVL(X.END_DATE, p_SYNC_END_DATE) >= p_SYNC_BEGIN_DATE;

-- Introduce new records with a null end date that do not have a corresponding entry in the table.
	INSERT INTO ACCOUNT_EDC (ACCOUNT_ID, EDC_ID, BEGIN_DATE, END_DATE, EDC_ACCOUNT_NUMBER, EDC_RATE_CLASS, EDC_STRATA, ENTRY_DATE)
	SELECT A.ACCOUNT_ID, B.EDC_ID, C.BEGIN_DATE, DECODE(C.END_DATE, p_SYNC_END_DATE, NULL, C.END_DATE), C.EDC_ACCOUNT_NUMBER, C.EDC_RATE_CLASS, C.EDC_STRATA, v_SYSDATE
	FROM ACCOUNT A,
		ENERGY_DISTRIBUTION_COMPANY B,
		TABLE(CAST(p_ACCOUNT_EDC_SYNC AS ACCOUNT_EDC_SYNC_TABLE)) C
	WHERE UPPER(SUBSTR(B.EDC_STATUS,1,1)) = 'A'
		AND C.ACCOUNT_IDENTIFIER = DECODE(p_ACCOUNT_IDENTIFIER_TYPE, 'X', A.ACCOUNT_EXTERNAL_IDENTIFIER, A.ACCOUNT_NAME)
		AND C.EDC_IDENTIFIER = DECODE(p_EDC_IDENTIFIER_TYPE, 'X', B.EDC_EXTERNAL_IDENTIFIER, B.EDC_NAME)
		AND NOT EXISTS
			(SELECT 1
			FROM ACCOUNT_EDC
			WHERE ACCOUNT_ID = A.ACCOUNT_ID
				AND EDC_ID = B.EDC_ID
				AND BEGIN_DATE <= p_SYNC_END_DATE
				AND NVL(END_DATE, p_SYNC_END_DATE) >= p_SYNC_BEGIN_DATE);

END SYNC_ACCOUNT_EDC;
----------------------------------------------------------------------------------------------------
PROCEDURE SYNC_AGGREGATE_SERVICE
	(
	p_ACCOUNT_IDENTIFIER_TYPE IN CHAR,
	p_ESP_IDENTIFIER_TYPE IN CHAR,
	p_SYNC_BEGIN_DATE IN DATE,
	p_SYNC_END_DATE IN DATE,
	p_SERVICE_SYNC IN SERVICE_SYNC_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

-- Synchronize Aggregate Account ESP Enrollment.

CURSOR c_SYNC IS
	SELECT C.AGGREGATE_ID, D.BEGIN_DATE, D.END_DATE, D.SERVICE_ACCOUNTS, D.USAGE_FACTOR
	FROM ACCOUNT A,
		ENERGY_SERVICE_PROVIDER B,
		AGGREGATE_ACCOUNT_ESP C,
		TABLE(CAST(p_SERVICE_SYNC AS SERVICE_SYNC_TABLE)) D
	WHERE A.IS_AGGREGATE_ACCOUNT = 1
		AND UPPER(SUBSTR(B.ESP_STATUS,1,1)) = 'A'
		AND C.ACCOUNT_ID = A.ACCOUNT_ID
		AND C.ESP_ID = B.ESP_ID
		AND C.BEGIN_DATE <= p_SYNC_END_DATE
		AND NVL(C.END_DATE, p_SYNC_END_DATE) = p_SYNC_BEGIN_DATE
		AND D.ACCOUNT_IDENTIFIER = DECODE(p_ACCOUNT_IDENTIFIER_TYPE,'X',A.ACCOUNT_EXTERNAL_IDENTIFIER, A.ACCOUNT_NAME)
		AND D.ESP_IDENTIFIER = DECODE(p_ESP_IDENTIFIER_TYPE,'X',B.ESP_EXTERNAL_IDENTIFIER, B.ESP_NAME)
	UNION
	SELECT 999999999, LOW_DATE, LOW_DATE, 0, 0 FROM DUAL
	ORDER BY 1,2;

v_INDEX BINARY_INTEGER;
v_LAST_ID NUMBER := 999999999;
v_AGGREGATE_SERVICE_SYNC AGGREGATE_SERVICE_SYNC_TABLE := AGGREGATE_SERVICE_SYNC_TABLE();
v_ACCOUNT_SERVICE ACCOUNT_SERVICE_TABLE;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_SERVICE_DATE DATE;
v_AS_OF_DATE DATE;

BEGIN

	IF NOT CAN_WRITE('Data Setup') THEN
		ERRS.RAISE_NO_WRITE_MODULE('Data Setup');
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK';

	FOR v_SYNC IN c_SYNC LOOP

-- Add the Enrollment for this Aggregate Account and ESP to the internal table.
		IF NOT v_SYNC.AGGREGATE_ID = v_LAST_ID THEN
			IF NOT v_LAST_ID = 999999999 THEN
				FOR v_INDEX IN v_ACCOUNT_SERVICE.FIRST..v_ACCOUNT_SERVICE.LAST LOOP
					IF v_ACCOUNT_SERVICE.EXISTS(v_INDEX) THEN
						v_AGGREGATE_SERVICE_SYNC.EXTEND;
						v_SERVICE_DATE := p_SYNC_BEGIN_DATE + (v_INDEX - 1);
						v_AGGREGATE_SERVICE_SYNC(v_AGGREGATE_SERVICE_SYNC.LAST) := AGGREGATE_SERVICE_SYNC_TYPE(v_LAST_ID, NULL, v_SERVICE_DATE, v_ACCOUNT_SERVICE(v_INDEX).SERVICE_ACCOUNTS, v_ACCOUNT_SERVICE(v_INDEX).USAGE_FACTOR, NULL);
					END IF;
				END LOOP;
				v_ACCOUNT_SERVICE.DELETE;
			END IF;
		END IF;

-- Accumulate the Enrollment for an Aggregate Account and ESP over the sync time period.
		v_BEGIN_DATE := GREATEST(v_SYNC.BEGIN_DATE, p_SYNC_BEGIN_DATE);
		v_END_DATE := LEAST(NVL(v_SYNC.BEGIN_DATE, p_SYNC_END_DATE), p_SYNC_END_DATE);
		v_SERVICE_DATE := v_BEGIN_DATE;
		WHILE v_SERVICE_DATE <= v_END_DATE LOOP
			v_INDEX := p_SYNC_BEGIN_DATE - v_SERVICE_DATE + 1;
			IF v_ACCOUNT_SERVICE.EXISTS(v_INDEX) THEN
				v_ACCOUNT_SERVICE(v_INDEX).SERVICE_ACCOUNTS := v_ACCOUNT_SERVICE(v_INDEX).SERVICE_ACCOUNTS + v_SYNC.SERVICE_ACCOUNTS;
				v_ACCOUNT_SERVICE(v_INDEX).USAGE_FACTOR := v_ACCOUNT_SERVICE(v_INDEX).USAGE_FACTOR + v_SYNC.USAGE_FACTOR;
			ELSE
				v_ACCOUNT_SERVICE(v_INDEX).SERVICE_ACCOUNTS := v_SYNC.SERVICE_ACCOUNTS;
				v_ACCOUNT_SERVICE(v_INDEX).USAGE_FACTOR := v_SYNC.USAGE_FACTOR;
			END IF;
		END LOOP;
		v_LAST_ID := v_SYNC.AGGREGATE_ID;
	END LOOP;

-- Insert the Enrollment into the Aggregate Account Serice table.
-- If versioning is off then delete any existing records so an insert can be done.

	IF GA.VERSION_AGGREGATE_ACCOUNT_SVC THEN
		v_AS_OF_DATE := SYSDATE;
	ELSE
		v_AS_OF_DATE := LOW_DATE;
		DELETE AGGREGATE_ACCOUNT_SERVICE
		WHERE AGGREGATE_ID IN (SELECT DISTINCT X.AGGREGATE_ID FROM TABLE(CAST(v_AGGREGATE_SERVICE_SYNC AS AGGREGATE_SERVICE_SYNC_TABLE)) X)
			AND SERVICE_DATE BETWEEN p_SYNC_BEGIN_DATE AND p_SYNC_END_DATE
			AND AS_OF_DATE = v_AS_OF_DATE;
	END IF;

	INSERT INTO AGGREGATE_ACCOUNT_SERVICE (AGGREGATE_ID, SERVICE_DATE, AS_OF_DATE, SERVICE_ACCOUNTS)
	SELECT X.AGGREGATE_ID, X.SERVICE_DATE, v_AS_OF_DATE, X.SERVICE_ACCOUNTS
	FROM TABLE(CAST(v_AGGREGATE_SERVICE_SYNC AS AGGREGATE_SERVICE_SYNC_TABLE)) X;

END SYNC_AGGREGATE_SERVICE;
----------------------------------------------------------------------------------------------------
PROCEDURE SYNC_ACCOUNT_SERVICE
	(
	p_ACCOUNT_IDENTIFIER_TYPE IN CHAR,
	p_ESP_IDENTIFIER_TYPE IN CHAR,
	p_SYNC_BEGIN_DATE IN DATE,
	p_SYNC_END_DATE IN DATE,
	p_SERVICE_SYNC IN SERVICE_SYNC_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

-- Synchronize Account ESP Relationship.

v_SYSDATE DATE := SYSDATE;

BEGIN

	IF NOT CAN_WRITE('Data Setup') THEN
		ERRS.RAISE_NO_WRITE_MODULE('Data Setup');
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK';

-- Terminate any records that do not have a corresponding entry in the sync file.
	UPDATE ACCOUNT_ESP X SET
		END_DATE = TRUNC(v_SYSDATE - 1),
		ENTRY_DATE = v_SYSDATE
	WHERE NOT EXISTS
		(SELECT 1
		FROM ACCOUNT A,
			ENERGY_SERVICE_PROVIDER B,
			TABLE(CAST(p_SERVICE_SYNC AS SERVICE_SYNC_TABLE)) C
		WHERE UPPER(A.ACCOUNT_MODEL_OPTION) = 'ACCOUNT'
			AND UPPER(SUBSTR(B.ESP_STATUS,1,1)) = 'A'
			AND C.ACCOUNT_IDENTIFIER = DECODE(p_ACCOUNT_IDENTIFIER_TYPE, 'X', A.ACCOUNT_EXTERNAL_IDENTIFIER, A.ACCOUNT_NAME)
			AND C.ESP_IDENTIFIER = DECODE(p_ESP_IDENTIFIER_TYPE, 'X', B.ESP_EXTERNAL_IDENTIFIER, B.ESP_NAME)
			AND X.ACCOUNT_ID = A.ACCOUNT_ID
			AND X.ESP_ID = B.ESP_ID);

-- Terminate any records that have a corresponding entry in the sync file and an end date less than the sync end date.
	UPDATE ACCOUNT_ESP X
	SET (END_DATE, ENTRY_DATE) =
		(SELECT END_DATE, v_SYSDATE
		FROM ACCOUNT A,
			ENERGY_SERVICE_PROVIDER B,
			TABLE(CAST(p_SERVICE_SYNC AS SERVICE_SYNC_TABLE)) C
		WHERE UPPER(A.ACCOUNT_MODEL_OPTION) = 'ACCOUNT'
			AND C.ACCOUNT_IDENTIFIER = DECODE(p_ACCOUNT_IDENTIFIER_TYPE, 'X', A.ACCOUNT_EXTERNAL_IDENTIFIER, A.ACCOUNT_NAME)
			AND C.END_DATE <= p_SYNC_END_DATE
			AND C.ESP_IDENTIFIER = DECODE(p_ESP_IDENTIFIER_TYPE, 'X', B.ESP_EXTERNAL_IDENTIFIER, B.ESP_NAME)
			AND X.ACCOUNT_ID = A.ACCOUNT_ID
			AND X.ESP_ID = B.ESP_ID)
	WHERE X.BEGIN_DATE <= p_SYNC_END_DATE
		AND NVL(X.END_DATE, p_SYNC_END_DATE) >= p_SYNC_BEGIN_DATE;

-- Introduce new records with a null end date that do not have a corresponding entry in the table.
	INSERT INTO ACCOUNT_ESP (ACCOUNT_ID, ESP_ID, BEGIN_DATE, END_DATE, ENTRY_DATE)
	SELECT A.ACCOUNT_ID, B.ESP_ID, C.BEGIN_DATE, DECODE(C.END_DATE, p_SYNC_END_DATE, NULL, C.END_DATE), v_SYSDATE
	FROM ACCOUNT A,
		ENERGY_SERVICE_PROVIDER B,
		TABLE(CAST(p_SERVICE_SYNC AS SERVICE_SYNC_TABLE)) C
	WHERE UPPER(A.ACCOUNT_MODEL_OPTION) = 'ACCOUNT'
		AND UPPER(SUBSTR(B.ESP_STATUS,1,1)) = 'A'
		AND C.ACCOUNT_IDENTIFIER = DECODE(p_ACCOUNT_IDENTIFIER_TYPE, 'X', A.ACCOUNT_EXTERNAL_IDENTIFIER, A.ACCOUNT_NAME)
		AND C.ESP_IDENTIFIER = DECODE(p_ESP_IDENTIFIER_TYPE, 'X', B.ESP_EXTERNAL_IDENTIFIER, B.ESP_NAME)
		AND NOT EXISTS
			(SELECT 1
			FROM ACCOUNT_ESP
			WHERE ACCOUNT_ID = A.ACCOUNT_ID
				AND ESP_ID = B.ESP_ID
				AND BEGIN_DATE <= p_SYNC_END_DATE
				AND NVL(END_DATE, p_SYNC_END_DATE) >= p_SYNC_BEGIN_DATE);

END SYNC_ACCOUNT_SERVICE;
----------------------------------------------------------------------------------------------------
PROCEDURE SYNC_ACCOUNT_USAGE_FACTOR
	(
	p_ACCOUNT_IDENTIFIER_TYPE IN CHAR,
	p_SYNC_BEGIN_DATE IN DATE,
	p_SYNC_END_DATE IN DATE,
	p_SERVICE_SYNC IN SERVICE_SYNC_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

-- Synchronize Account Usage FactorS.

v_SYSDATE DATE := SYSDATE;

BEGIN

	IF NOT CAN_WRITE('Data Setup') THEN
		ERRS.RAISE_NO_WRITE_MODULE('Data Setup');
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK';

-- Terminate any records that do not have a corresponding entry in the sync file.
	UPDATE ACCOUNT_USAGE_FACTOR X SET
		END_DATE = TRUNC(v_SYSDATE - 1),
		ENTRY_DATE = v_SYSDATE
	WHERE NOT EXISTS
		(SELECT 1
		FROM ACCOUNT A,
			TABLE(CAST(p_SERVICE_SYNC AS SERVICE_SYNC_TABLE)) B
		WHERE UPPER(A.ACCOUNT_MODEL_OPTION) = 'ACCOUNT'
			AND B.ACCOUNT_IDENTIFIER = DECODE(p_ACCOUNT_IDENTIFIER_TYPE, 'X', A.ACCOUNT_EXTERNAL_IDENTIFIER, A.ACCOUNT_NAME)
			AND X.ACCOUNT_ID = A.ACCOUNT_ID);

-- Terminate any records that have a corresponding entry in the sync file and an end date less than the sync end date.
	UPDATE ACCOUNT_USAGE_FACTOR X
	SET (END_DATE, ENTRY_DATE) =
		(SELECT END_DATE, v_SYSDATE
		FROM ACCOUNT A,
			TABLE(CAST(p_SERVICE_SYNC AS SERVICE_SYNC_TABLE)) B
		WHERE UPPER(A.ACCOUNT_MODEL_OPTION) = 'ACCOUNT'
			AND B.ACCOUNT_IDENTIFIER = DECODE(p_ACCOUNT_IDENTIFIER_TYPE, 'X', A.ACCOUNT_EXTERNAL_IDENTIFIER, A.ACCOUNT_NAME)
			AND B.END_DATE <= p_SYNC_END_DATE
			AND X.ACCOUNT_ID = A.ACCOUNT_ID)
	WHERE X.BEGIN_DATE <= p_SYNC_END_DATE
		AND NVL(X.END_DATE, p_SYNC_END_DATE) >= p_SYNC_BEGIN_DATE;

-- Introduce new records with a null end date that do not have a corresponding entry in the table.
	INSERT INTO ACCOUNT_USAGE_FACTOR (ACCOUNT_ID, BEGIN_DATE, END_DATE, FACTOR_VAL, ENTRY_DATE)
	SELECT A.ACCOUNT_ID, B.BEGIN_DATE, DECODE(B.END_DATE, p_SYNC_END_DATE, NULL, B.END_DATE), B.USAGE_FACTOR, v_SYSDATE
	FROM ACCOUNT A,
		TABLE(CAST(p_SERVICE_SYNC AS SERVICE_SYNC_TABLE)) B
	WHERE UPPER(A.ACCOUNT_MODEL_OPTION) = 'ACCOUNT'
		AND B.ACCOUNT_IDENTIFIER = DECODE(p_ACCOUNT_IDENTIFIER_TYPE, 'X', A.ACCOUNT_EXTERNAL_IDENTIFIER, A.ACCOUNT_NAME)
		AND NOT EXISTS
			(SELECT 1
			FROM ACCOUNT_USAGE_FACTOR
			WHERE ACCOUNT_ID = A.ACCOUNT_ID
				AND BEGIN_DATE <= p_SYNC_END_DATE
				AND NVL(END_DATE, p_SYNC_END_DATE) >= p_SYNC_BEGIN_DATE);

END SYNC_ACCOUNT_USAGE_FACTOR;
----------------------------------------------------------------------------------------------------
PROCEDURE SYNC_ACCOUNT_ANCILLARY_SERVICE
	(
	p_ACCOUNT_IDENTIFIER_TYPE IN CHAR,
	p_SYNC_BEGIN_DATE IN DATE,
	p_SYNC_END_DATE IN DATE,
	p_ANCILLARY_SERVICE_SYNC IN ANCILLARY_SERVICE_SYNC_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

-- Synchronize Account Ancillary Service RelationshipS.

v_SYSDATE DATE := SYSDATE;

BEGIN

	IF NOT CAN_WRITE('Data Setup') THEN
		ERRS.RAISE_NO_WRITE_MODULE('Data Setup');
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK';

-- Terminate any records that do not have a corresponding entry in the sync file.
	UPDATE ACCOUNT_ANCILLARY_SERVICE X SET
		END_DATE = TRUNC(v_SYSDATE - 1),
		ENTRY_DATE = v_SYSDATE
	WHERE NOT EXISTS
		(SELECT 1
		FROM ACCOUNT A,
			ANCILLARY_SERVICE B,
			TABLE(CAST(p_ANCILLARY_SERVICE_SYNC AS ANCILLARY_SERVICE_SYNC_TABLE)) C
		WHERE UPPER(A.ACCOUNT_MODEL_OPTION) = 'ACCOUNT'
			AND C.ACCOUNT_IDENTIFIER = DECODE(p_ACCOUNT_IDENTIFIER_TYPE, 'X', A.ACCOUNT_EXTERNAL_IDENTIFIER, A.ACCOUNT_NAME)
			AND C.ANCILLARY_SERVICE_NAME = B.ANCILLARY_SERVICE_NAME
			AND X.ACCOUNT_ID = A.ACCOUNT_ID
			AND X.ANCILLARY_SERVICE_ID = B.ANCILLARY_SERVICE_ID);

-- Terminate any records that have a corresponding entry in the sync file and an end date less than the sync end date.
	UPDATE ACCOUNT_ANCILLARY_SERVICE X
	SET (END_DATE, ENTRY_DATE) =
		(SELECT END_DATE, v_SYSDATE
		FROM ACCOUNT A,
			ANCILLARY_SERVICE B,
			TABLE(CAST(p_ANCILLARY_SERVICE_SYNC AS ANCILLARY_SERVICE_SYNC_TABLE)) C
		WHERE UPPER(A.ACCOUNT_MODEL_OPTION) = 'ACCOUNT'
			AND C.ACCOUNT_IDENTIFIER = DECODE(p_ACCOUNT_IDENTIFIER_TYPE, 'X', A.ACCOUNT_EXTERNAL_IDENTIFIER, A.ACCOUNT_NAME)
			AND C.ANCILLARY_SERVICE_NAME = B.ANCILLARY_SERVICE_NAME
			AND C.END_DATE <= p_SYNC_END_DATE
			AND X.ACCOUNT_ID = A.ACCOUNT_ID
			AND X.ANCILLARY_SERVICE_ID = B.ANCILLARY_SERVICE_ID)
	WHERE X.BEGIN_DATE <= p_SYNC_END_DATE
		AND NVL(X.END_DATE, p_SYNC_END_DATE) >= p_SYNC_BEGIN_DATE;

-- Introduce new records with a null end date that do not have a corresponding entry in the table.
	INSERT INTO ACCOUNT_ANCILLARY_SERVICE (ACCOUNT_ID, ANCILLARY_SERVICE_ID, BEGIN_DATE, END_DATE, ENTRY_DATE)
	SELECT A.ACCOUNT_ID, B.ANCILLARY_SERVICE_ID, C.BEGIN_DATE, DECODE(C.END_DATE, p_SYNC_END_DATE, NULL, C.END_DATE), v_SYSDATE
	FROM ACCOUNT A,
		ANCILLARY_SERVICE B,
		TABLE(CAST(p_ANCILLARY_SERVICE_SYNC AS ANCILLARY_SERVICE_SYNC_TABLE)) C
	WHERE UPPER(A.ACCOUNT_MODEL_OPTION) = 'ACCOUNT'
		AND C.ACCOUNT_IDENTIFIER = DECODE(p_ACCOUNT_IDENTIFIER_TYPE, 'X', A.ACCOUNT_EXTERNAL_IDENTIFIER, A.ACCOUNT_NAME)
		AND C.ANCILLARY_SERVICE_NAME = B.ANCILLARY_SERVICE_NAME
		AND NOT EXISTS
			(SELECT 1
			FROM ACCOUNT_ANCILLARY_SERVICE
			WHERE ACCOUNT_ID = A.ACCOUNT_ID
				AND ANCILLARY_SERVICE_ID = B.ANCILLARY_SERVICE_ID
				AND BEGIN_DATE <= p_SYNC_END_DATE
				AND NVL(END_DATE, p_SYNC_END_DATE) >= p_SYNC_BEGIN_DATE);

END SYNC_ACCOUNT_ANCILLARY_SERVICE;
----------------------------------------------------------------------------------------------------
PROCEDURE SYNC_AGGREGATE_ANCILLARY_SVC
	(
	p_ACCOUNT_IDENTIFIER_TYPE IN CHAR,
	p_ESP_IDENTIFIER_TYPE IN CHAR,
	p_SYNC_BEGIN_DATE IN DATE,
	p_SYNC_END_DATE IN DATE,
	p_ANCILLARY_SERVICE_SYNC IN ANCILLARY_SERVICE_SYNC_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

-- Synchronize Aggregate Ancillary Service.

CURSOR c_SYNC IS
	SELECT C.AGGREGATE_ID, E.ANCILLARY_SERVICE_ID, D.BEGIN_DATE, D.END_DATE, D.SERVICE_VAL
	FROM ACCOUNT A,
		ENERGY_SERVICE_PROVIDER B,
		AGGREGATE_ACCOUNT_ESP C,
		TABLE(CAST(p_ANCILLARY_SERVICE_SYNC AS ANCILLARY_SERVICE_SYNC_TABLE)) D,
		ANCILLARY_SERVICE E
	WHERE A.IS_AGGREGATE_ACCOUNT = 1
		AND UPPER(SUBSTR(B.ESP_STATUS,1,1)) = 'A'
		AND C.ACCOUNT_ID = A.ACCOUNT_ID
		AND C.ESP_ID = B.ESP_ID
		AND C.BEGIN_DATE <= p_SYNC_END_DATE
		AND NVL(C.END_DATE, p_SYNC_END_DATE) = p_SYNC_BEGIN_DATE
		AND D.ACCOUNT_IDENTIFIER = DECODE(p_ACCOUNT_IDENTIFIER_TYPE,'X',A.ACCOUNT_EXTERNAL_IDENTIFIER, A.ACCOUNT_NAME)
		AND D.ESP_IDENTIFIER = DECODE(p_ESP_IDENTIFIER_TYPE,'X',B.ESP_EXTERNAL_IDENTIFIER, B.ESP_NAME)
		AND E.ANCILLARY_SERVICE_NAME = D.ANCILLARY_SERVICE_NAME
	UNION
	SELECT 999999999, 999999999, LOW_DATE, LOW_DATE, 0 FROM DUAL
	ORDER BY 1,2,3;

v_INDEX BINARY_INTEGER;
v_LAST_AGGREGATE_ID NUMBER := 999999999;
v_LAST_ANCILLARY_SERVICE_ID NUMBER;
v_AGGREGATE_SERVICE_SYNC AGGREGATE_SERVICE_SYNC_TABLE := AGGREGATE_SERVICE_SYNC_TABLE();
v_ANCILARRY_SERVICE GA.NUMBER_TABLE;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_SERVICE_DATE DATE;
v_AS_OF_DATE DATE;

BEGIN

	IF NOT CAN_WRITE('Data Setup') THEN
		ERRS.RAISE_NO_WRITE_MODULE('Data Setup');
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK';

	FOR v_SYNC IN c_SYNC LOOP

-- Add the Ancillary Service for this Aggregate Account and ESP to the internal table.
		IF NOT v_SYNC.AGGREGATE_ID = v_LAST_AGGREGATE_ID THEN
			IF NOT v_LAST_AGGREGATE_ID = 999999999 THEN
				FOR v_INDEX IN v_ANCILARRY_SERVICE.FIRST..v_ANCILARRY_SERVICE.LAST LOOP
					IF v_ANCILARRY_SERVICE.EXISTS(v_INDEX) THEN
						v_AGGREGATE_SERVICE_SYNC.EXTEND;
						v_SERVICE_DATE := p_SYNC_BEGIN_DATE + (v_INDEX - 1);
						v_AGGREGATE_SERVICE_SYNC(v_AGGREGATE_SERVICE_SYNC.LAST) := AGGREGATE_SERVICE_SYNC_TYPE(v_LAST_AGGREGATE_ID, v_LAST_ANCILLARY_SERVICE_ID, v_SERVICE_DATE, NULL, NULL, v_ANCILARRY_SERVICE(v_INDEX));
					END IF;
				END LOOP;
				v_ANCILARRY_SERVICE.DELETE;
			END IF;
		END IF;

-- Accumulate the Ancillary Service for an Aggregate Account and ESP over the sync time period.
		v_BEGIN_DATE := GREATEST(v_SYNC.BEGIN_DATE, p_SYNC_BEGIN_DATE);
		v_END_DATE := LEAST(NVL(v_SYNC.BEGIN_DATE, p_SYNC_END_DATE), p_SYNC_END_DATE);
		v_SERVICE_DATE := v_BEGIN_DATE;
		WHILE v_SERVICE_DATE <= v_END_DATE LOOP
			v_INDEX := p_SYNC_BEGIN_DATE - v_SERVICE_DATE + 1;
			IF v_ANCILARRY_SERVICE.EXISTS(v_INDEX) THEN
				v_ANCILARRY_SERVICE(v_INDEX) := v_ANCILARRY_SERVICE(v_INDEX) + v_SYNC.SERVICE_VAL;
			ELSE
				v_ANCILARRY_SERVICE(v_INDEX) := v_SYNC.SERVICE_VAL;
			END IF;
		END LOOP;
		v_LAST_AGGREGATE_ID := v_SYNC.AGGREGATE_ID;
		v_LAST_ANCILLARY_SERVICE_ID := v_SYNC.ANCILLARY_SERVICE_ID;
	END LOOP;

-- Insert the Ancillary Service into the Aggregate Ancilarry Serice table.
-- If versioning is off then delete any existing records so an insert can be done.

	IF GA.VERSION_AGGREGATE_ACCOUNT_SVC THEN
		v_AS_OF_DATE := SYSDATE;
	ELSE
		v_AS_OF_DATE := LOW_DATE;
		DELETE AGGREGATE_ANCILLARY_SERVICE
		WHERE AGGREGATE_ID IN (SELECT DISTINCT AGGREGATE_ID FROM TABLE(CAST(v_AGGREGATE_SERVICE_SYNC AS AGGREGATE_SERVICE_SYNC_TABLE)))
			AND ANCILLARY_SERVICE_ID IN (SELECT DISTINCT ANCILLARY_SERVICE_ID FROM TABLE(CAST(v_AGGREGATE_SERVICE_SYNC AS AGGREGATE_SERVICE_SYNC_TABLE)))
			AND SERVICE_DATE BETWEEN p_SYNC_BEGIN_DATE AND p_SYNC_END_DATE
			AND AS_OF_DATE = v_AS_OF_DATE;
	END IF;

	INSERT INTO AGGREGATE_ANCILLARY_SERVICE (AGGREGATE_ID, ANCILLARY_SERVICE_ID, SERVICE_DATE, AS_OF_DATE, SERVICE_VAL)
	SELECT X.AGGREGATE_ID, X.ANCILLARY_SERVICE_ID, X.SERVICE_DATE, v_AS_OF_DATE, X.SERVICE_ACCOUNTS
	FROM TABLE(CAST(v_AGGREGATE_SERVICE_SYNC AS AGGREGATE_SERVICE_SYNC_TABLE)) X;

END SYNC_AGGREGATE_ANCILLARY_SVC;
----------------------------------------------------------------------------------------------------
PROCEDURE SYNC_HOLIDAY_OBSERVANCE
	(
	p_SYNC_BEGIN_DATE IN DATE,
	p_SYNC_END_DATE IN DATE,
	p_HOLIDAY_OBSERVANCE_SYNC IN HOLIDAY_OBSERVANCE_SYNC_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

-- Sync the Holiday Observances.

v_SYSDATE DATE := SYSDATE;
v_HOLIDAY_ID NUMBER;

CURSOR c_HOLIDAYS IS
	SELECT DISTINCT A.HOLIDAY_NAME
	FROM TABLE(CAST(p_HOLIDAY_OBSERVANCE_SYNC AS HOLIDAY_OBSERVANCE_SYNC_TABLE)) A;

BEGIN

	IF NOT CAN_WRITE('Data Setup') THEN
		ERRS.RAISE_NO_WRITE_MODULE('Data Setup');
	END IF;

	p_STATUS := GA.SUCCESS;

	FOR v_HOLIDAYS IN c_HOLIDAYS LOOP
		ID.ID_FOR_LOSS_FACTOR(v_HOLIDAYS.HOLIDAY_NAME, v_HOLIDAY_ID);
	END LOOP;

	DELETE HOLIDAY_OBSERVANCE WHERE HOLIDAY_DATE BETWEEN p_SYNC_BEGIN_DATE AND p_SYNC_END_DATE;

	INSERT INTO HOLIDAY_OBSERVANCE (HOLIDAY_ID, HOLIDAY_YEAR, HOLIDAY_DATE, ENTRY_DATE)
	SELECT B.HOLIDAY_ID, TO_NUMBER(TO_CHAR(A.HOLIDAY_DATE,'YYYY')), A.HOLIDAY_DATE, v_SYSDATE
	FROM TABLE(CAST(p_HOLIDAY_OBSERVANCE_SYNC AS HOLIDAY_OBSERVANCE_SYNC_TABLE)) A,
		HOLIDAY B
	WHERE B.HOLIDAY_NAME = A.HOLIDAY_NAME;

END SYNC_HOLIDAY_OBSERVANCE;
----------------------------------------------------------------------------------------------------
PROCEDURE RETRIEVE_EXT_FORECAST_IDENT
	(
	p_MODEL_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_ACCOUNT_IDENTIFIER_TYPE IN CHAR,
	p_ESP_IDENTIFIER_TYPE IN CHAR,
	p_EXT_FORECAST_IDENT IN OUT NOCOPY EXT_FORECAST_IDENT_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

-- Retrieve all External Forecast Accounts and their ESP of Record.

CURSOR c_ACCOUNT IS
	SELECT DECODE(p_ACCOUNT_IDENTIFIER_TYPE, 'X', A.ACCOUNT_EXTERNAL_IDENTIFIER, A.ACCOUNT_NAME) "ACCOUNT_IDENTIFIER",
		DECODE(p_ESP_IDENTIFIER_TYPE, 'X', C.ESP_EXTERNAL_IDENTIFIER, C.ESP_NAME) "ESP_IDENTIFIER",
		A.ACCOUNT_ID
	FROM ACCOUNT A,
		ACCOUNT_ESP B,
		ENERGY_SERVICE_PROVIDER C
	WHERE A.IS_AGGREGATE_ACCOUNT = 0
		AND A.IS_EXTERNAL_FORECAST = 1
		AND B.ACCOUNT_ID = A.ACCOUNT_ID
		AND p_SERVICE_DATE BETWEEN B.BEGIN_DATE AND NVL(B.END_DATE, p_SERVICE_DATE)
		AND C.ESP_ID = B.ESP_ID
		AND UPPER(SUBSTR(C.ESP_STATUS,1,1)) = 'A';

BEGIN

	IF NOT CAN_READ('Forecasting') THEN
		ERRS.RAISE_NO_READ_MODULE('Forecasting');
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK';

	FOR v_ACCOUNT IN c_ACCOUNT LOOP
		p_EXT_FORECAST_IDENT.EXTEND;
		p_EXT_FORECAST_IDENT(p_EXT_FORECAST_IDENT.LAST) := EXT_FORECAST_IDENT_TYPE(v_ACCOUNT.ACCOUNT_IDENTIFIER, v_ACCOUNT.ESP_IDENTIFIER, v_ACCOUNT.ACCOUNT_ID);
	END LOOP;

END RETRIEVE_EXT_FORECAST_IDENT;
----------------------------------------------------------------------------------------------------
PROCEDURE RETRIEVE_ACCOUNT_ESP_SERVICE
	(
	p_MODEL_ID IN NUMBER,
	p_ACCOUNT_MODEL_OPTION IN VARCHAR,
	p_SERVICE_DATE IN DATE,
	p_ACCOUNT_IDENTIFIER_TYPE IN CHAR,
	p_ESP_IDENTIFIER_TYPE IN CHAR,
	p_ACCOUNT_ESP_SERVICE IN OUT NOCOPY ACCOUNT_ESP_SERVICE_TABLE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

-- Retrieve Service Accounts for all Accounts and their associated ESP of Record.

v_SYSDATE DATE := SYSDATE;

BEGIN

	IF NOT CAN_READ('Forecasting') THEN
		ERRS.RAISE_NO_READ_MODULE('Forecasting');
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK';

	IF UPPER(p_ACCOUNT_MODEL_OPTION) = 'ACCOUNT' THEN
		SELECT ACCOUNT_ESP_SERVICE_TYPE(DECODE(p_ACCOUNT_IDENTIFIER_TYPE, 'X', A.ACCOUNT_EXTERNAL_IDENTIFIER, A.ACCOUNT_NAME),
			DECODE(p_ESP_IDENTIFIER_TYPE, 'X', C.ESP_EXTERNAL_IDENTIFIER, C.ESP_NAME), p_SERVICE_DATE,1)
		BULK COLLECT INTO p_ACCOUNT_ESP_SERVICE
		FROM ACCOUNT A,
			ACCOUNT_ESP B,
			ENERGY_SERVICE_PROVIDER C
		WHERE B.ACCOUNT_ID = A.ACCOUNT_ID
			AND p_SERVICE_DATE BETWEEN B.BEGIN_DATE AND NVL(B.END_DATE, p_SERVICE_DATE)
			AND C.ESP_ID = B.ESP_ID;
	ELSIF UPPER(p_ACCOUNT_MODEL_OPTION) = 'AGGREGATE' THEN
		SELECT ACCOUNT_ESP_SERVICE_TYPE(DECODE(p_ACCOUNT_IDENTIFIER_TYPE, 'X', A.ACCOUNT_EXTERNAL_IDENTIFIER, A.ACCOUNT_NAME),
			DECODE(p_ESP_IDENTIFIER_TYPE, 'X', C.ESP_EXTERNAL_IDENTIFIER, C.ESP_NAME), p_SERVICE_DATE, D.SERVICE_ACCOUNTS)
		BULK COLLECT INTO p_ACCOUNT_ESP_SERVICE
		FROM ACCOUNT A,
			AGGREGATE_ACCOUNT_ESP B,
			ENERGY_SERVICE_PROVIDER C,
			AGGREGATE_ACCOUNT_SERVICE D
		WHERE B.ACCOUNT_ID = A.ACCOUNT_ID
			AND p_SERVICE_DATE BETWEEN B.BEGIN_DATE AND NVL(B.END_DATE, p_SERVICE_DATE)
			AND C.ESP_ID = B.ESP_ID
			AND D.AGGREGATE_ID = B.AGGREGATE_ID
			AND CASE_ID = GA.BASE_CASE_ID        --Query is much faster with CASE_ID specified
			AND D.SERVICE_DATE = TRUNC(p_SERVICE_DATE)
			AND D.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM AGGREGATE_ACCOUNT_SERVICE
				WHERE AGGREGATE_ID = B.AGGREGATE_ID    --Don't use D.AGGREGATE_ID here - it is much slower when table is large - wjc
					AND CASE_ID = GA.BASE_CASE_ID        --Query is much faster with CASE_ID specified in subquery and outer query!!!!
					AND SERVICE_DATE = TRUNC(p_SERVICE_DATE)
					AND AS_OF_DATE <= v_SYSDATE);
		END IF;

END RETRIEVE_ACCOUNT_ESP_SERVICE;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_POOL_NAME
	 (
	p_POOL_ID IN  NUMBER,
	p_POOL_NAME OUT VARCHAR,
	p_STATUS OUT NUMBER
	) AS

-- Answer the POOL name for an POOL id

BEGIN

	p_STATUS := GA.SUCCESS;

	SELECT POOL_NAME
	INTO p_POOL_NAME
	FROM POOL
	WHERE POOL_ID = p_POOL_ID;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		p_STATUS := GA.NO_DATA_FOUND;
	WHEN OTHERS THEN
	p_STATUS := SQLCODE;

END GET_POOL_NAME;
----------------------------------------------------------------------------------------------------
END RO;
/
