CREATE OR REPLACE PACKAGE IO AS
-- Revision: $Revision: 1.122 $

-- Entity Input/Output package

-- NOTE: This package is AUTO-GENERATED

FUNCTION WHAT_VERSION RETURN VARCHAR;

PROCEDURE PUT_ACCOUNT
	(
	o_OID OUT NUMBER,
	p_ACCOUNT_NAME IN VARCHAR2,
	p_ACCOUNT_ALIAS IN VARCHAR2,
	p_ACCOUNT_DESC IN VARCHAR2,
	p_ACCOUNT_ID IN NUMBER,
	p_ACCOUNT_DUNS_NUMBER IN VARCHAR2,
	p_ACCOUNT_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_ACCOUNT_MODEL_OPTION IN VARCHAR2,
	p_ACCOUNT_SIC_CODE IN VARCHAR2,
	p_ACCOUNT_METER_TYPE IN VARCHAR2,
	p_ACCOUNT_METER_EXT_IDENTIFIER IN VARCHAR2,
	p_ACCOUNT_DISPLAY_NAME IN VARCHAR2,
	p_ACCOUNT_BILL_OPTION IN VARCHAR2,
	p_ACCOUNT_ROLLUP_ID IN NUMBER,
	p_IS_EXTERNAL_INTERVAL_USAGE IN NUMBER,
	p_IS_EXTERNAL_BILLED_USAGE IN NUMBER,
	p_IS_AGGREGATE_ACCOUNT IN NUMBER,
	p_IS_UFE_PARTICIPANT IN NUMBER,
	p_IS_CREATE_SETTLEMENT_PROFILE IN NUMBER,
	p_IS_EXTERNAL_FORECAST IN NUMBER,
	p_IS_SUB_AGGREGATE IN NUMBER,
	p_TX_SERVICE_TYPE_ID IN NUMBER,
	p_USE_TOU_USAGE_FACTOR IN NUMBER,
	p_MODEL_ID IN NUMBER
	);

PROCEDURE GET_ACCOUNT
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ACCOUNT_NAME OUT VARCHAR2,
	p_ACCOUNT_ALIAS OUT VARCHAR2,
	p_ACCOUNT_DESC OUT VARCHAR2,
	p_ACCOUNT_DUNS_NUMBER OUT VARCHAR2,
	p_ACCOUNT_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_ACCOUNT_MODEL_OPTION OUT VARCHAR2,
	p_ACCOUNT_SIC_CODE OUT VARCHAR2,
	p_ACCOUNT_METER_TYPE OUT VARCHAR2,
	p_ACCOUNT_METER_EXT_IDENTIFIER OUT VARCHAR2,
	p_ACCOUNT_DISPLAY_NAME OUT VARCHAR2,
	p_ACCOUNT_BILL_OPTION OUT VARCHAR2,
	p_ACCOUNT_ROLLUP_ID OUT NUMBER,
	p_IS_EXTERNAL_INTERVAL_USAGE OUT NUMBER,
	p_IS_EXTERNAL_BILLED_USAGE OUT NUMBER,
	p_IS_AGGREGATE_ACCOUNT OUT NUMBER,
	p_IS_UFE_PARTICIPANT OUT NUMBER,
	p_IS_CREATE_SETTLEMENT_PROFILE OUT NUMBER,
	p_IS_EXTERNAL_FORECAST OUT NUMBER,
	p_IS_SUB_AGGREGATE OUT NUMBER,
	p_TX_SERVICE_TYPE_ID OUT NUMBER,
	p_USE_TOU_USAGE_FACTOR OUT NUMBER,
	p_MODEL_ID OUT NUMBER
	);

PROCEDURE PUT_ACCOUNT_GROUP
	(
	o_OID OUT NUMBER,
	p_ACCOUNT_GROUP_NAME IN VARCHAR2,
	p_ACCOUNT_GROUP_ALIAS IN VARCHAR2,
	p_ACCOUNT_GROUP_DESC IN VARCHAR2,
	p_ACCOUNT_GROUP_ID IN NUMBER,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2
	);

PROCEDURE GET_ACCOUNT_GROUP
	(
	p_ACCOUNT_GROUP_ID IN NUMBER,
	p_ACCOUNT_GROUP_NAME OUT VARCHAR2,
	p_ACCOUNT_GROUP_ALIAS OUT VARCHAR2,
	p_ACCOUNT_GROUP_DESC OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2
	);

PROCEDURE PUT_ANCILLARY_SERVICE
	(
	o_OID OUT NUMBER,
	p_ANCILLARY_SERVICE_NAME IN VARCHAR2,
	p_ANCILLARY_SERVICE_ALIAS IN VARCHAR2,
	p_ANCILLARY_SERVICE_DESC IN VARCHAR2,
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_ANCILLARY_SERVICE_TYPE IN VARCHAR2,
	p_PROVIDER_CATEGORY IN VARCHAR2,
	p_PROVIDER_ID IN NUMBER,
	p_TRANSACTION_TYPE IN VARCHAR2,
	p_IT_COMMODITY_ID IN NUMBER,
	p_ROUNDING_PREFERENCE IN VARCHAR2,
	p_MINIMUM_SCHEDULE_AMT IN NUMBER,
	p_ANCILLARY_SERVICE_UNIT IN VARCHAR2
	);

PROCEDURE GET_ANCILLARY_SERVICE
	(
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_ANCILLARY_SERVICE_NAME OUT VARCHAR2,
	p_ANCILLARY_SERVICE_ALIAS OUT VARCHAR2,
	p_ANCILLARY_SERVICE_DESC OUT VARCHAR2,
	p_ANCILLARY_SERVICE_TYPE OUT VARCHAR2,
	p_PROVIDER_CATEGORY OUT VARCHAR2,
	p_PROVIDER_ID OUT NUMBER,
	p_TRANSACTION_TYPE OUT VARCHAR2,
	p_IT_COMMODITY_ID OUT NUMBER,
	p_ROUNDING_PREFERENCE OUT VARCHAR2,
	p_MINIMUM_SCHEDULE_AMT OUT NUMBER,
	p_ANCILLARY_SERVICE_UNIT OUT VARCHAR2
	);

PROCEDURE PUT_AREA
	(
	o_OID OUT NUMBER,
	p_AREA_NAME IN VARCHAR2,
	p_AREA_ALIAS IN VARCHAR2,
	p_AREA_DESC IN VARCHAR2,
	p_AREA_ID IN NUMBER,
	p_AREA_INTERVAL IN VARCHAR2,
	p_PROJECTION_PERIOD IN VARCHAR2
	);

PROCEDURE GET_AREA
	(
	p_AREA_ID IN NUMBER,
	p_AREA_NAME OUT VARCHAR2,
	p_AREA_ALIAS OUT VARCHAR2,
	p_AREA_DESC OUT VARCHAR2,
	p_AREA_INTERVAL OUT VARCHAR2,
	p_PROJECTION_PERIOD OUT VARCHAR2
	);

PROCEDURE PUT_BILL_CYCLE
	(
	o_OID OUT NUMBER,
	p_BILL_CYCLE_NAME IN VARCHAR2,
	p_BILL_CYCLE_ALIAS IN VARCHAR2,
	p_BILL_CYCLE_DESC IN VARCHAR2,
	p_BILL_CYCLE_ID IN NUMBER
	);

PROCEDURE GET_BILL_CYCLE
	(
	p_BILL_CYCLE_ID IN NUMBER,
	p_BILL_CYCLE_NAME OUT VARCHAR2,
	p_BILL_CYCLE_ALIAS OUT VARCHAR2,
	p_BILL_CYCLE_DESC OUT VARCHAR2
	);

PROCEDURE PUT_BILL_PARTY
	(
	o_OID OUT NUMBER,
	p_BILL_PARTY_NAME IN VARCHAR2,
	p_BILL_PARTY_ALIAS IN VARCHAR2,
	p_BILL_PARTY_DESC IN VARCHAR2,
	p_BILL_PARTY_ID IN NUMBER,
	p_BILL_PARTY_STATUS IN VARCHAR2,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_IS_INVOICE_DETAIL IN NUMBER
	);

PROCEDURE GET_BILL_PARTY
	(
	p_BILL_PARTY_ID IN NUMBER,
	p_BILL_PARTY_NAME OUT VARCHAR2,
	p_BILL_PARTY_ALIAS OUT VARCHAR2,
	p_BILL_PARTY_DESC OUT VARCHAR2,
	p_BILL_PARTY_STATUS OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_IS_INVOICE_DETAIL OUT NUMBER
	);

PROCEDURE PUT_BREAKPOINT
	(
	o_OID OUT NUMBER,
	p_BREAKPOINT_NAME IN VARCHAR2,
	p_BREAKPOINT_ALIAS IN VARCHAR2,
	p_BREAKPOINT_DESC IN VARCHAR2,
	p_BREAKPOINT_ID IN NUMBER
	);

PROCEDURE GET_BREAKPOINT
	(
	p_BREAKPOINT_ID IN NUMBER,
	p_BREAKPOINT_NAME OUT VARCHAR2,
	p_BREAKPOINT_ALIAS OUT VARCHAR2,
	p_BREAKPOINT_DESC OUT VARCHAR2
	);

PROCEDURE PUT_CA
	(
	o_OID OUT NUMBER,
	p_CA_NAME IN VARCHAR2,
	p_CA_ALIAS IN VARCHAR2,
	p_CA_DESC IN VARCHAR2,
	p_CA_ID IN NUMBER,
	p_CA_NERC_CODE IN VARCHAR2,
	p_CA_STATUS IN VARCHAR2,
	p_CA_DUNS_NUMBER IN VARCHAR2
	);

PROCEDURE GET_CA
	(
	p_CA_ID IN NUMBER,
	p_CA_NAME OUT VARCHAR2,
	p_CA_ALIAS OUT VARCHAR2,
	p_CA_DESC OUT VARCHAR2,
	p_CA_NERC_CODE OUT VARCHAR2,
	p_CA_STATUS OUT VARCHAR2,
	p_CA_DUNS_NUMBER OUT VARCHAR2
	);

PROCEDURE PUT_CALC_PROCESS
	(
	o_OID OUT NUMBER,
	p_CALC_PROCESS_NAME IN VARCHAR2,
	p_CALC_PROCESS_ALIAS IN VARCHAR2,
	p_CALC_PROCESS_DESC IN VARCHAR2,
	p_CALC_PROCESS_ID IN NUMBER,
	p_CALC_PROCESS_CATEGORY IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_PROCESS_INTERVAL IN VARCHAR2,
	p_WEEK_BEGIN IN VARCHAR2,
	p_CONTEXT_DOMAIN_ID IN NUMBER,
	p_CONTEXT_REALM_ID IN NUMBER,
	p_CONTEXT_GROUP_ID IN NUMBER,
	p_CONTEXT_NAME IN VARCHAR2,
	p_IS_STATEMENT_TYPE_SPECIFIC IN NUMBER
	);

PROCEDURE GET_CALC_PROCESS
	(
	p_CALC_PROCESS_ID IN NUMBER,
	p_CALC_PROCESS_NAME OUT VARCHAR2,
	p_CALC_PROCESS_ALIAS OUT VARCHAR2,
	p_CALC_PROCESS_DESC OUT VARCHAR2,
	p_CALC_PROCESS_CATEGORY OUT VARCHAR2,
	p_TIME_ZONE OUT VARCHAR2,
	p_PROCESS_INTERVAL OUT VARCHAR2,
	p_WEEK_BEGIN OUT VARCHAR2,
	p_CONTEXT_DOMAIN_ID OUT NUMBER,
	p_CONTEXT_REALM_ID OUT NUMBER,
	p_CONTEXT_GROUP_ID OUT NUMBER,
	p_CONTEXT_NAME OUT VARCHAR2,
	p_IS_STATEMENT_TYPE_SPECIFIC OUT NUMBER
	);

PROCEDURE PUT_CALENDAR
	(
	o_OID OUT NUMBER,
	p_CALENDAR_NAME IN VARCHAR2,
	p_CALENDAR_ALIAS IN VARCHAR2,
	p_CALENDAR_DESC IN VARCHAR2,
	p_CALENDAR_ID IN NUMBER,
	p_ASSIGNMENT_TYPE IN VARCHAR2,
	p_HAS_ADJUSTMENTS IN NUMBER
	);

PROCEDURE GET_CALENDAR
	(
	p_CALENDAR_ID IN NUMBER,
	p_CALENDAR_NAME OUT VARCHAR2,
	p_CALENDAR_ALIAS OUT VARCHAR2,
	p_CALENDAR_DESC OUT VARCHAR2,
	p_ASSIGNMENT_TYPE OUT VARCHAR2,
	p_HAS_ADJUSTMENTS OUT NUMBER
	);

PROCEDURE PUT_CASE_LABEL
	(
	o_OID OUT NUMBER,
	p_CASE_NAME IN VARCHAR2,
	p_CASE_ALIAS IN VARCHAR2,
	p_CASE_DESC IN VARCHAR2,
	p_CASE_ID IN NUMBER,
	p_CASE_CATEGORY IN VARCHAR2
	);

PROCEDURE GET_CASE_LABEL
	(
	p_CASE_ID IN NUMBER,
	p_CASE_NAME OUT VARCHAR2,
	p_CASE_ALIAS OUT VARCHAR2,
	p_CASE_DESC OUT VARCHAR2,
	p_CASE_CATEGORY OUT VARCHAR2
	);

PROCEDURE PUT_CATEGORY
	(
	o_OID OUT NUMBER,
	p_CATEGORY_NAME IN VARCHAR2,
	p_CATEGORY_ALIAS IN VARCHAR2,
	p_CATEGORY_DESC IN VARCHAR2,
	p_CATEGORY_ID IN NUMBER
	);

PROCEDURE GET_CATEGORY
	(
	p_CATEGORY_ID IN NUMBER,
	p_CATEGORY_NAME OUT VARCHAR2,
	p_CATEGORY_ALIAS OUT VARCHAR2,
	p_CATEGORY_DESC OUT VARCHAR2
	);

PROCEDURE PUT_COMPONENT
	(
	o_OID OUT NUMBER,
	p_COMPONENT_NAME IN VARCHAR2,
	p_COMPONENT_ALIAS IN VARCHAR2,
	p_COMPONENT_DESC IN VARCHAR2,
	p_COMPONENT_ID IN NUMBER,
	p_COMPONENT_ENTITY IN VARCHAR2,
	p_CHARGE_TYPE IN VARCHAR2,
	p_RATE_STRUCTURE IN VARCHAR2,
	p_RATE_INTERVAL IN VARCHAR2,
	p_IS_REBILL IN NUMBER,
	p_IS_TAXED IN NUMBER,
	p_IS_CUSTOM_CHARGE IN NUMBER,
	p_IS_CREDIT_CHARGE IN NUMBER,
	p_IS_INCLUDE_TX_LOSS IN NUMBER,
	p_IS_INCLUDE_DX_LOSS IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_MARKET_PRICE_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_MODEL_ID IN NUMBER,
	p_EVENT_ID IN NUMBER,
	p_COMPONENT_REFERENCE IN VARCHAR2,
	p_INVOICE_GROUP_ID IN NUMBER,
	p_INVOICE_GROUP_ORDER IN NUMBER,
	p_COMPUTATION_ORDER IN NUMBER,
	p_QUANTITY_UNIT IN VARCHAR2,
	p_CURRENCY_UNIT IN VARCHAR2,
	p_QUANTITY_TYPE IN VARCHAR2,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_COMPONENT_CATEGORY IN VARCHAR2,
	p_GL_DEBIT_ACCOUNT IN VARCHAR2,
	p_GL_CREDIT_ACCOUNT IN VARCHAR2,
	p_FIRM_NON_FIRM IN VARCHAR2,
	p_EXCLUDE_FROM_INVOICE IN NUMBER,
	p_EXCLUDE_FROM_INVOICE_TOTAL IN NUMBER,
	p_IMBALANCE_TYPE IN VARCHAR2,
	p_ACCUMULATION_PERIOD IN NUMBER,
	p_BASE_COMPONENT_ID IN NUMBER,
	p_BASE_LIMIT_ID IN NUMBER,
	p_MARKET_TYPE IN VARCHAR2,
	p_MARKET_PRICE_TYPE IN VARCHAR2,
	p_WHICH_INTERVAL IN VARCHAR2,
	p_LMP_PRICE_CALC IN VARCHAR2,
	p_LMP_INCLUDE_EXT IN NUMBER,
	p_LMP_INCLUDE_SALES IN VARCHAR2,
	p_CHARGE_WHEN IN VARCHAR2,
	p_BILATERALS_SIGN IN NUMBER,
	p_LMP_COMMODITY_ID IN NUMBER,
	p_LMP_BASE_COMMODITY_ID IN NUMBER,
	p_USE_ZONAL_PRICE IN NUMBER,
	p_ALTERNATE_PRICE IN VARCHAR2,
	p_ALTERNATE_PRICE_FUNCTION IN VARCHAR2,
	p_EXCLUDE_FROM_BILLING_EXPORT IN NUMBER,
	p_IS_DEFAULT_TEMPLATE IN NUMBER,
	p_KWH_MULTIPLIER IN NUMBER,
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_APPLY_RATE_FOR IN VARCHAR2,
	p_LOSS_ADJ_TYPE IN NUMBER
	);

PROCEDURE GET_COMPONENT
	(
	p_COMPONENT_ID IN NUMBER,
	p_COMPONENT_NAME OUT VARCHAR2,
	p_COMPONENT_ALIAS OUT VARCHAR2,
	p_COMPONENT_DESC OUT VARCHAR2,
	p_COMPONENT_ENTITY OUT VARCHAR2,
	p_CHARGE_TYPE OUT VARCHAR2,
	p_RATE_STRUCTURE OUT VARCHAR2,
	p_RATE_INTERVAL OUT VARCHAR2,
	p_IS_REBILL OUT NUMBER,
	p_IS_TAXED OUT NUMBER,
	p_IS_CUSTOM_CHARGE OUT NUMBER,
	p_IS_CREDIT_CHARGE OUT NUMBER,
	p_IS_INCLUDE_TX_LOSS OUT NUMBER,
	p_IS_INCLUDE_DX_LOSS OUT NUMBER,
	p_TEMPLATE_ID OUT NUMBER,
	p_MARKET_PRICE_ID OUT NUMBER,
	p_SERVICE_POINT_ID OUT NUMBER,
	p_MODEL_ID OUT NUMBER,
	p_EVENT_ID OUT NUMBER,
	p_COMPONENT_REFERENCE OUT VARCHAR2,
	p_INVOICE_GROUP_ID OUT NUMBER,
	p_INVOICE_GROUP_ORDER OUT NUMBER,
	p_COMPUTATION_ORDER OUT NUMBER,
	p_QUANTITY_UNIT OUT VARCHAR2,
	p_CURRENCY_UNIT OUT VARCHAR2,
	p_QUANTITY_TYPE OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_COMPONENT_CATEGORY OUT VARCHAR2,
	p_GL_DEBIT_ACCOUNT OUT VARCHAR2,
	p_GL_CREDIT_ACCOUNT OUT VARCHAR2,
	p_FIRM_NON_FIRM OUT VARCHAR2,
	p_EXCLUDE_FROM_INVOICE OUT NUMBER,
	p_EXCLUDE_FROM_INVOICE_TOTAL OUT NUMBER,
	p_IMBALANCE_TYPE OUT VARCHAR2,
	p_ACCUMULATION_PERIOD OUT NUMBER,
	p_BASE_COMPONENT_ID OUT NUMBER,
	p_BASE_LIMIT_ID OUT NUMBER,
	p_MARKET_TYPE OUT VARCHAR2,
	p_MARKET_PRICE_TYPE OUT VARCHAR2,
	p_WHICH_INTERVAL OUT VARCHAR2,
	p_LMP_PRICE_CALC OUT VARCHAR2,
	p_LMP_INCLUDE_EXT OUT NUMBER,
	p_LMP_INCLUDE_SALES OUT VARCHAR2,
	p_CHARGE_WHEN OUT VARCHAR2,
	p_BILATERALS_SIGN OUT NUMBER,
	p_LMP_COMMODITY_ID OUT NUMBER,
	p_LMP_BASE_COMMODITY_ID OUT NUMBER,
	p_USE_ZONAL_PRICE OUT NUMBER,
	p_ALTERNATE_PRICE OUT VARCHAR2,
	p_ALTERNATE_PRICE_FUNCTION OUT VARCHAR2,
	p_EXCLUDE_FROM_BILLING_EXPORT OUT NUMBER,
	p_IS_DEFAULT_TEMPLATE OUT NUMBER,
	p_KWH_MULTIPLIER OUT NUMBER,
	p_ANCILLARY_SERVICE_ID OUT NUMBER,
	p_APPLY_RATE_FOR OUT VARCHAR2,
	p_LOSS_ADJ_TYPE OUT NUMBER
	);

PROCEDURE PUT_CONDITIONAL_FORMAT
	(
	o_OID OUT NUMBER,
	p_CONDITIONAL_FORMAT_NAME IN VARCHAR2,
	p_CONDITIONAL_FORMAT_ALIAS IN VARCHAR2,
	p_CONDITIONAL_FORMAT_DESC IN VARCHAR2,
	p_CONDITIONAL_FORMAT_ID IN NUMBER,
	p_CONDITIONAL_FORMAT_MODULE IN VARCHAR2
	);

PROCEDURE GET_CONDITIONAL_FORMAT
	(
	p_CONDITIONAL_FORMAT_ID IN NUMBER,
	p_CONDITIONAL_FORMAT_NAME OUT VARCHAR2,
	p_CONDITIONAL_FORMAT_ALIAS OUT VARCHAR2,
	p_CONDITIONAL_FORMAT_DESC OUT VARCHAR2,
	p_CONDITIONAL_FORMAT_MODULE OUT VARCHAR2
	);

PROCEDURE PUT_CONTACT
	(
	o_OID OUT NUMBER,
	p_CONTACT_NAME IN VARCHAR2,
	p_CONTACT_ALIAS IN VARCHAR2,
	p_CONTACT_DESC IN VARCHAR2,
	p_CONTACT_ID IN NUMBER,
	p_CONTACT_STATUS IN VARCHAR2,
	p_EMAIL_ADDRESS IN VARCHAR2,
	p_FIRST_NAME IN VARCHAR2,
	p_MIDDLE_NAME IN VARCHAR2,
	p_LAST_NAME IN VARCHAR2,
	p_SALUTATION IN VARCHAR2,
	p_TITLE IN VARCHAR2,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2
	);

PROCEDURE GET_CONTACT
	(
	p_CONTACT_ID IN NUMBER,
	p_CONTACT_NAME OUT VARCHAR2,
	p_CONTACT_ALIAS OUT VARCHAR2,
	p_CONTACT_DESC OUT VARCHAR2,
	p_CONTACT_STATUS OUT VARCHAR2,
	p_EMAIL_ADDRESS OUT VARCHAR2,
	p_FIRST_NAME OUT VARCHAR2,
	p_MIDDLE_NAME OUT VARCHAR2,
	p_LAST_NAME OUT VARCHAR2,
	p_SALUTATION OUT VARCHAR2,
	p_TITLE OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2
	);

PROCEDURE PUT_CONTRACT
	(
	o_OID OUT NUMBER,
	p_CONTRACT_NAME IN VARCHAR2,
	p_CONTRACT_ALIAS IN VARCHAR2,
	p_CONTRACT_DESC IN VARCHAR2,
	p_CONTRACT_ID IN NUMBER,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_IS_ESTIMATED_END_DATE IN NUMBER,
	p_IS_EVERGREEN IN NUMBER,
	p_IS_INTERRUPTIBLE IN NUMBER,
	p_EXPECTED_RENEWAL_PCT IN NUMBER,
	p_NEXT_ACTION_DATE IN DATE,
	p_NOTIFICATION_REQUIREMENTS IN VARCHAR2,
	p_CURTAILMENT_ABILITY IN VARCHAR2,
	p_PENALTY_CLAUSES IN VARCHAR2,
	p_PRICING_MODEL IN VARCHAR2
	);

PROCEDURE GET_CONTRACT
	(
	p_CONTRACT_ID IN NUMBER,
	p_CONTRACT_NAME OUT VARCHAR2,
	p_CONTRACT_ALIAS OUT VARCHAR2,
	p_CONTRACT_DESC OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE,
	p_IS_ESTIMATED_END_DATE OUT NUMBER,
	p_IS_EVERGREEN OUT NUMBER,
	p_IS_INTERRUPTIBLE OUT NUMBER,
	p_EXPECTED_RENEWAL_PCT OUT NUMBER,
	p_NEXT_ACTION_DATE OUT DATE,
	p_NOTIFICATION_REQUIREMENTS OUT VARCHAR2,
	p_CURTAILMENT_ABILITY OUT VARCHAR2,
	p_PENALTY_CLAUSES OUT VARCHAR2,
	p_PRICING_MODEL OUT VARCHAR2
	);

PROCEDURE PUT_CONTRACT_LIMIT
	(
	o_OID OUT NUMBER,
	p_LIMIT_NAME IN VARCHAR2,
	p_LIMIT_ALIAS IN VARCHAR2,
	p_LIMIT_DESC IN VARCHAR2,
	p_LIMIT_ID IN NUMBER,
	p_LIMIT_TYPE IN VARCHAR2,
	p_LIMIT_MEASURE IN VARCHAR2,
	p_LIMIT_INTERVAL IN VARCHAR2,
	p_LIMIT_IS_SEASONABLE IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_PERIOD_ID IN NUMBER
	);

PROCEDURE GET_CONTRACT_LIMIT
	(
	p_LIMIT_ID IN NUMBER,
	p_LIMIT_NAME OUT VARCHAR2,
	p_LIMIT_ALIAS OUT VARCHAR2,
	p_LIMIT_DESC OUT VARCHAR2,
	p_LIMIT_TYPE OUT VARCHAR2,
	p_LIMIT_MEASURE OUT VARCHAR2,
	p_LIMIT_INTERVAL OUT VARCHAR2,
	p_LIMIT_IS_SEASONABLE OUT NUMBER,
	p_TEMPLATE_ID OUT NUMBER,
	p_PERIOD_ID OUT NUMBER
	);

PROCEDURE PUT_CUSTOMER
	(
	o_OID OUT NUMBER,
	p_CUSTOMER_NAME IN VARCHAR2,
	p_CUSTOMER_ALIAS IN VARCHAR2,
	p_CUSTOMER_DESC IN VARCHAR2,
	p_CUSTOMER_ID IN NUMBER,
	p_CUSTOMER_IDENTIFIER IN VARCHAR2,
	p_CUSTOMER_STATUS IN VARCHAR2,
	p_CUSTOMER_IS_ACTIVE IN NUMBER
	);

PROCEDURE GET_CUSTOMER
	(
	p_CUSTOMER_ID IN NUMBER,
	p_CUSTOMER_NAME OUT VARCHAR2,
	p_CUSTOMER_ALIAS OUT VARCHAR2,
	p_CUSTOMER_DESC OUT VARCHAR2,
	p_CUSTOMER_IDENTIFIER OUT VARCHAR2,
	p_CUSTOMER_STATUS OUT VARCHAR2,
	p_CUSTOMER_IS_ACTIVE OUT NUMBER
	);

PROCEDURE PUT_DATA_LOCK_GROUP
	(
	o_OID OUT NUMBER,
	p_DATA_LOCK_GROUP_NAME IN VARCHAR2,
	p_DATA_LOCK_GROUP_ALIAS IN VARCHAR2,
	p_DATA_LOCK_GROUP_DESC IN VARCHAR2,
	p_DATA_LOCK_GROUP_ID IN NUMBER,
	p_DATA_LOCK_GROUP_INTERVAL IN VARCHAR2,
	p_IS_AUTOMATIC IN NUMBER,
	p_AUTOLOCK_DATE_FORMULA IN VARCHAR2,
	p_LOCK_LIMIT_DATE_FORMULA IN VARCHAR2,
	p_LOCK_STATE IN VARCHAR2,
	p_LAST_PROCESSED_INTERVAL IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_WEEK_BEGIN IN VARCHAR2
	);

PROCEDURE GET_DATA_LOCK_GROUP
	(
	p_DATA_LOCK_GROUP_ID IN NUMBER,
	p_DATA_LOCK_GROUP_NAME OUT VARCHAR2,
	p_DATA_LOCK_GROUP_ALIAS OUT VARCHAR2,
	p_DATA_LOCK_GROUP_DESC OUT VARCHAR2,
	p_DATA_LOCK_GROUP_INTERVAL OUT VARCHAR2,
	p_IS_AUTOMATIC OUT NUMBER,
	p_AUTOLOCK_DATE_FORMULA OUT VARCHAR2,
	p_LOCK_LIMIT_DATE_FORMULA OUT VARCHAR2,
	p_LOCK_STATE OUT VARCHAR2,
	p_LAST_PROCESSED_INTERVAL OUT DATE,
	p_TIME_ZONE OUT VARCHAR2,
	p_WEEK_BEGIN OUT VARCHAR2
	);

PROCEDURE PUT_DER
	(
	o_OID OUT NUMBER,
	p_DER_NAME IN VARCHAR2,
	p_DER_ALIAS IN VARCHAR2,
	p_DER_DESC IN VARCHAR2,
	p_DER_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_DER_TYPE_ID IN NUMBER,
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SERIAL_NUMBER IN VARCHAR2
	);

PROCEDURE GET_DER
	(
	p_DER_ID IN NUMBER,
	p_DER_NAME OUT VARCHAR2,
	p_DER_ALIAS OUT VARCHAR2,
	p_DER_DESC OUT VARCHAR2,
	p_SERVICE_LOCATION_ID OUT NUMBER,
	p_DER_TYPE_ID OUT NUMBER,
	p_EXTERNAL_SYSTEM_ID OUT NUMBER,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE,
	p_SERIAL_NUMBER OUT VARCHAR2
	);

PROCEDURE PUT_DER_TYPE
	(
	o_OID OUT NUMBER,
	p_DER_TYPE_NAME IN VARCHAR2,
	p_DER_TYPE_ALIAS IN VARCHAR2,
	p_DER_TYPE_DESC IN VARCHAR2,
	p_DER_TYPE_ID IN NUMBER,
	p_DER_TYPE_FUNCTION IN VARCHAR2,
	p_DER_TYPE_CATEGORY IN VARCHAR2,
	p_DEFAULT_FAILURE_PCT IN NUMBER,
	p_USE_DEFAULT_FAIL_PCT IN NUMBER,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2
	);

PROCEDURE GET_DER_TYPE
	(
	p_DER_TYPE_ID IN NUMBER,
	p_DER_TYPE_NAME OUT VARCHAR2,
	p_DER_TYPE_ALIAS OUT VARCHAR2,
	p_DER_TYPE_DESC OUT VARCHAR2,
	p_DER_TYPE_FUNCTION OUT VARCHAR2,
	p_DER_TYPE_CATEGORY OUT VARCHAR2,
	p_DEFAULT_FAILURE_PCT OUT NUMBER,
	p_USE_DEFAULT_FAIL_PCT OUT NUMBER,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2
	);

PROCEDURE PUT_DR_EVENT
	(
	o_OID OUT NUMBER,
	p_EVENT_NAME IN VARCHAR2,
	p_EVENT_ALIAS IN VARCHAR2,
	p_EVENT_DESC IN VARCHAR2,
	p_EVENT_ID IN NUMBER,
	p_VPP_ID IN NUMBER,
	p_EVENT_STATUS IN VARCHAR2,
	p_START_TIME IN DATE,
	p_STOP_TIME IN DATE,
	p_EVENT_TYPE IN VARCHAR2
	);

PROCEDURE GET_DR_EVENT
	(
	p_EVENT_ID IN NUMBER,
	p_EVENT_NAME OUT VARCHAR2,
	p_EVENT_ALIAS OUT VARCHAR2,
	p_EVENT_DESC OUT VARCHAR2,
	p_VPP_ID OUT NUMBER,
	p_EVENT_STATUS OUT VARCHAR2,
	p_START_TIME OUT DATE,
	p_STOP_TIME OUT DATE,
	p_EVENT_TYPE OUT VARCHAR2
	);

PROCEDURE PUT_EDC
	(
	o_OID OUT NUMBER,
	p_EDC_NAME IN VARCHAR2,
	p_EDC_ALIAS IN VARCHAR2,
	p_EDC_DESC IN VARCHAR2,
	p_EDC_ID IN NUMBER,
	p_EDC_STATUS IN VARCHAR2,
	p_EDC_DUNS_NUMBER IN VARCHAR2,
	p_EDC_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_EDC_SETTLEMENT_AGENT_NAME IN VARCHAR2,
	p_EDC_LOSS_FACTOR_OPTION IN VARCHAR2,
	p_EDC_SYSTEM_LOAD_ID IN NUMBER,
	p_EDC_MARKET_PRICE_ID IN NUMBER,
	p_EDC_HOLIDAY_SET_ID IN NUMBER,
	p_EDC_SC_ID IN NUMBER,
	p_EDC_EXCLUDE_LOAD_SCHEDULE IN NUMBER
	);

PROCEDURE GET_EDC
	(
	p_EDC_ID IN NUMBER,
	p_EDC_NAME OUT VARCHAR2,
	p_EDC_ALIAS OUT VARCHAR2,
	p_EDC_DESC OUT VARCHAR2,
	p_EDC_STATUS OUT VARCHAR2,
	p_EDC_DUNS_NUMBER OUT VARCHAR2,
	p_EDC_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_EDC_SETTLEMENT_AGENT_NAME OUT VARCHAR2,
	p_EDC_LOSS_FACTOR_OPTION OUT VARCHAR2,
	p_EDC_SYSTEM_LOAD_ID OUT NUMBER,
	p_EDC_MARKET_PRICE_ID OUT NUMBER,
	p_EDC_HOLIDAY_SET_ID OUT NUMBER,
	p_EDC_SC_ID OUT NUMBER,
	p_EDC_EXCLUDE_LOAD_SCHEDULE OUT NUMBER
	);

PROCEDURE PUT_ENTITY_DOMAIN
	(
	o_OID OUT NUMBER,
	p_ENTITY_DOMAIN_NAME IN VARCHAR2,
	p_ENTITY_DOMAIN_ALIAS IN VARCHAR2,
	p_ENTITY_DOMAIN_DESC IN VARCHAR2,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ENTITY_DOMAIN_TABLE IN VARCHAR2,
	p_ENTITY_DOMAIN_TABLE_ALIAS IN VARCHAR2,
	p_ENTITY_DOMAIN_CATEGORY IN VARCHAR2,
	p_DISPLAY_NAME IN VARCHAR2,
	p_INCLUDE_CONTACT_ADDRESS IN NUMBER,
	p_INCLUDE_ENTITY_ATTRIBUTE IN NUMBER,
	p_INCLUDE_EXTERNAL_IDENTIFIER IN NUMBER,
	p_INCLUDE_GROUPS IN NUMBER,
	p_INCLUDE_NOTES IN NUMBER,
	p_IS_PSEUDO IN NUMBER
	);

PROCEDURE GET_ENTITY_DOMAIN
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ENTITY_DOMAIN_NAME OUT VARCHAR2,
	p_ENTITY_DOMAIN_ALIAS OUT VARCHAR2,
	p_ENTITY_DOMAIN_DESC OUT VARCHAR2,
	p_ENTITY_DOMAIN_TABLE OUT VARCHAR2,
	p_ENTITY_DOMAIN_TABLE_ALIAS OUT VARCHAR2,
	p_ENTITY_DOMAIN_CATEGORY OUT VARCHAR2,
	p_DISPLAY_NAME OUT VARCHAR2,
	p_INCLUDE_CONTACT_ADDRESS OUT NUMBER,
	p_INCLUDE_ENTITY_ATTRIBUTE OUT NUMBER,
	p_INCLUDE_EXTERNAL_IDENTIFIER OUT NUMBER,
	p_INCLUDE_GROUPS OUT NUMBER,
	p_INCLUDE_NOTES OUT NUMBER,
	p_IS_PSEUDO OUT NUMBER
	);

PROCEDURE PUT_ENTITY_GROUP
	(
	o_OID OUT NUMBER,
	p_ENTITY_GROUP_NAME IN VARCHAR2,
	p_ENTITY_GROUP_ALIAS IN VARCHAR2,
	p_ENTITY_GROUP_DESC IN VARCHAR2,
	p_ENTITY_GROUP_ID IN NUMBER,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_PARENT_GROUP_ID IN NUMBER,
	p_IS_MATRIX IN NUMBER,
	p_GROUP_CATEGORY IN VARCHAR2
	);

PROCEDURE GET_ENTITY_GROUP
	(
	p_ENTITY_GROUP_ID IN NUMBER,
	p_ENTITY_GROUP_NAME OUT VARCHAR2,
	p_ENTITY_GROUP_ALIAS OUT VARCHAR2,
	p_ENTITY_GROUP_DESC OUT VARCHAR2,
	p_ENTITY_DOMAIN_ID OUT NUMBER,
	p_PARENT_GROUP_ID OUT NUMBER,
	p_IS_MATRIX OUT NUMBER,
	p_GROUP_CATEGORY OUT VARCHAR2
	);

PROCEDURE PUT_ESP
	(
	o_OID OUT NUMBER,
	p_ESP_NAME IN VARCHAR2,
	p_ESP_ALIAS IN VARCHAR2,
	p_ESP_DESC IN VARCHAR2,
	p_ESP_ID IN NUMBER,
	p_ESP_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_ESP_DUNS_NUMBER IN VARCHAR2,
	p_ESP_STATUS IN VARCHAR2,
	p_ESP_TYPE IN VARCHAR2,
	p_ESP_EXCLUDE_LOAD_SCHEDULE IN NUMBER
	);

PROCEDURE GET_ESP
	(
	p_ESP_ID IN NUMBER,
	p_ESP_NAME OUT VARCHAR2,
	p_ESP_ALIAS OUT VARCHAR2,
	p_ESP_DESC OUT VARCHAR2,
	p_ESP_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_ESP_DUNS_NUMBER OUT VARCHAR2,
	p_ESP_STATUS OUT VARCHAR2,
	p_ESP_TYPE OUT VARCHAR2,
	p_ESP_EXCLUDE_LOAD_SCHEDULE OUT NUMBER
	);

PROCEDURE PUT_ETAG
	(
	o_OID OUT NUMBER,
	p_ETAG_NAME IN VARCHAR2,
	p_ETAG_ALIAS IN VARCHAR2,
	p_ETAG_DESC IN VARCHAR2,
	p_ETAG_ID IN NUMBER,
	p_TAG_IDENT IN VARCHAR2,
	p_GCA_CODE IN VARCHAR2,
	p_PSE_CODE IN VARCHAR2,
	p_TAG_CODE IN VARCHAR2,
	p_LCA_CODE IN VARCHAR2,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_ETAG_STATUS IN VARCHAR2,
	p_SECURITY_KEY IN VARCHAR2,
	p_WSCC_PRESCHEDULE_FLAG IN VARCHAR2,
	p_TEST_FLAG IN VARCHAR2,
	p_TRANSACTION_TYPE IN VARCHAR2,
	p_NOTES IN VARCHAR2
	);

PROCEDURE GET_ETAG
	(
	p_ETAG_ID IN NUMBER,
	p_ETAG_NAME OUT VARCHAR2,
	p_ETAG_ALIAS OUT VARCHAR2,
	p_ETAG_DESC OUT VARCHAR2,
	p_TAG_IDENT OUT VARCHAR2,
	p_GCA_CODE OUT VARCHAR2,
	p_PSE_CODE OUT VARCHAR2,
	p_TAG_CODE OUT VARCHAR2,
	p_LCA_CODE OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_ETAG_STATUS OUT VARCHAR2,
	p_SECURITY_KEY OUT VARCHAR2,
	p_WSCC_PRESCHEDULE_FLAG OUT VARCHAR2,
	p_TEST_FLAG OUT VARCHAR2,
	p_TRANSACTION_TYPE OUT VARCHAR2,
	p_NOTES OUT VARCHAR2
	);

PROCEDURE PUT_EXTERNAL_SYSTEM
	(
	o_OID OUT NUMBER,
	p_EXTERNAL_SYSTEM_NAME IN VARCHAR2,
	p_EXTERNAL_SYSTEM_ALIAS IN VARCHAR2,
	p_EXTERNAL_SYSTEM_DESC IN VARCHAR2,
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_EXTERNAL_SYSTEM_TYPE IN VARCHAR2,
	p_EXTERNAL_SYSTEM_DISPLAY_NAME IN VARCHAR2,
	p_IS_ENABLED IN NUMBER,
	p_EXTERNAL_ACCOUNT_DOMAIN_ID IN NUMBER,
	p_HAS_UNAME_PWD_CREDENTIALS IN NUMBER,
	p_NUMBER_OF_CERTIFICATES IN NUMBER
	);

PROCEDURE GET_EXTERNAL_SYSTEM
	(
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_EXTERNAL_SYSTEM_NAME OUT VARCHAR2,
	p_EXTERNAL_SYSTEM_ALIAS OUT VARCHAR2,
	p_EXTERNAL_SYSTEM_DESC OUT VARCHAR2,
	p_EXTERNAL_SYSTEM_TYPE OUT VARCHAR2,
	p_EXTERNAL_SYSTEM_DISPLAY_NAME OUT VARCHAR2,
	p_IS_ENABLED OUT NUMBER,
	p_EXTERNAL_ACCOUNT_DOMAIN_ID OUT NUMBER,
	p_HAS_UNAME_PWD_CREDENTIALS OUT NUMBER,
	p_NUMBER_OF_CERTIFICATES OUT NUMBER
	);

PROCEDURE PUT_EXTERNAL_TRANSACTION
	(
	o_OID OUT NUMBER,
	p_TRANSACTION_NAME IN VARCHAR2,
	p_TRANSACTION_ALIAS IN VARCHAR2,
	p_TRANSACTION_DESC IN VARCHAR2,
	p_TRANSACTION_ID IN NUMBER,
	p_TRANSACTION_TYPE IN VARCHAR2,
	p_TRANSACTION_CODE IN VARCHAR2,
	p_TRANSACTION_IDENTIFIER IN VARCHAR2,
	p_IS_FIRM IN NUMBER,
	p_IS_IMPORT_SCHEDULE IN NUMBER,
	p_IS_EXPORT_SCHEDULE IN NUMBER,
	p_IS_BALANCE_TRANSACTION IN NUMBER,
	p_IS_BID_OFFER IN NUMBER,
	p_IS_EXCLUDE_FROM_POSITION IN NUMBER,
	p_IS_IMPORT_EXPORT IN NUMBER,
	p_IS_DISPATCHABLE IN NUMBER,
	p_TRANSACTION_INTERVAL IN VARCHAR2,
	p_EXTERNAL_INTERVAL IN VARCHAR2,
	p_ETAG_CODE IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PURCHASER_ID IN NUMBER,
	p_SELLER_ID IN NUMBER,
	p_CONTRACT_ID IN NUMBER,
	p_SC_ID IN NUMBER,
	p_POR_ID IN NUMBER,
	p_POD_ID IN NUMBER,
	p_COMMODITY_ID IN NUMBER,
	p_SERVICE_TYPE_ID IN NUMBER,
	p_TX_TRANSACTION_ID IN NUMBER,
	p_PATH_ID IN NUMBER,
	p_LINK_TRANSACTION_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_SCHEDULE_GROUP_ID IN NUMBER,
	p_MARKET_PRICE_ID IN NUMBER,
	p_ZOR_ID IN NUMBER,
	p_ZOD_ID IN NUMBER,
	p_SOURCE_ID IN NUMBER,
	p_SINK_ID IN NUMBER,
	p_RESOURCE_ID IN NUMBER,
	p_AGREEMENT_TYPE IN VARCHAR2,
	p_APPROVAL_TYPE IN VARCHAR2,
	p_LOSS_OPTION IN VARCHAR2,
	p_TRAIT_CATEGORY IN VARCHAR2,
	p_TP_ID IN NUMBER
	);

PROCEDURE GET_EXTERNAL_TRANSACTION
	(
	p_TRANSACTION_ID IN NUMBER,
	p_TRANSACTION_NAME OUT VARCHAR2,
	p_TRANSACTION_ALIAS OUT VARCHAR2,
	p_TRANSACTION_DESC OUT VARCHAR2,
	p_TRANSACTION_TYPE OUT VARCHAR2,
	p_TRANSACTION_CODE OUT VARCHAR2,
	p_TRANSACTION_IDENTIFIER OUT VARCHAR2,
	p_IS_FIRM OUT NUMBER,
	p_IS_IMPORT_SCHEDULE OUT NUMBER,
	p_IS_EXPORT_SCHEDULE OUT NUMBER,
	p_IS_BALANCE_TRANSACTION OUT NUMBER,
	p_IS_BID_OFFER OUT NUMBER,
	p_IS_EXCLUDE_FROM_POSITION OUT NUMBER,
	p_IS_IMPORT_EXPORT OUT NUMBER,
	p_IS_DISPATCHABLE OUT NUMBER,
	p_TRANSACTION_INTERVAL OUT VARCHAR2,
	p_EXTERNAL_INTERVAL OUT VARCHAR2,
	p_ETAG_CODE OUT VARCHAR2,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE,
	p_PURCHASER_ID OUT NUMBER,
	p_SELLER_ID OUT NUMBER,
	p_CONTRACT_ID OUT NUMBER,
	p_SC_ID OUT NUMBER,
	p_POR_ID OUT NUMBER,
	p_POD_ID OUT NUMBER,
	p_COMMODITY_ID OUT NUMBER,
	p_SERVICE_TYPE_ID OUT NUMBER,
	p_TX_TRANSACTION_ID OUT NUMBER,
	p_PATH_ID OUT NUMBER,
	p_LINK_TRANSACTION_ID OUT NUMBER,
	p_EDC_ID OUT NUMBER,
	p_PSE_ID OUT NUMBER,
	p_ESP_ID OUT NUMBER,
	p_POOL_ID OUT NUMBER,
	p_SCHEDULE_GROUP_ID OUT NUMBER,
	p_MARKET_PRICE_ID OUT NUMBER,
	p_ZOR_ID OUT NUMBER,
	p_ZOD_ID OUT NUMBER,
	p_SOURCE_ID OUT NUMBER,
	p_SINK_ID OUT NUMBER,
	p_RESOURCE_ID OUT NUMBER,
	p_AGREEMENT_TYPE OUT VARCHAR2,
	p_APPROVAL_TYPE OUT VARCHAR2,
	p_LOSS_OPTION OUT VARCHAR2,
	p_TRAIT_CATEGORY OUT VARCHAR2,
	p_TP_ID OUT NUMBER
	);

PROCEDURE PUT_GEOGRAPHY
	(
	o_OID OUT NUMBER,
	p_GEOGRAPHY_NAME IN VARCHAR2,
	p_GEOGRAPHY_ALIAS IN VARCHAR2,
	p_GEOGRAPHY_DESC IN VARCHAR2,
	p_GEOGRAPHY_ID IN NUMBER,
	p_GEOGRAPHY_TYPE IN VARCHAR2,
	p_PARENT_GEOGRAPHY_ID IN NUMBER,
	p_DISPLAY_NAME IN VARCHAR2,
	p_ABBREVIATION IN VARCHAR2
	);

PROCEDURE GET_GEOGRAPHY
	(
	p_GEOGRAPHY_ID IN NUMBER,
	p_GEOGRAPHY_NAME OUT VARCHAR2,
	p_GEOGRAPHY_ALIAS OUT VARCHAR2,
	p_GEOGRAPHY_DESC OUT VARCHAR2,
	p_GEOGRAPHY_TYPE OUT VARCHAR2,
	p_PARENT_GEOGRAPHY_ID OUT NUMBER,
	p_DISPLAY_NAME OUT VARCHAR2,
	p_ABBREVIATION OUT VARCHAR2
	);

PROCEDURE PUT_GROWTH_PATTERN
	(
	o_OID OUT NUMBER,
	p_PATTERN_NAME IN VARCHAR2,
	p_PATTERN_ALIAS IN VARCHAR2,
	p_PATTERN_DESC IN VARCHAR2,
	p_PATTERN_ID IN NUMBER,
	p_JAN_PCT IN NUMBER,
	p_FEB_PCT IN NUMBER,
	p_MAR_PCT IN NUMBER,
	p_APR_PCT IN NUMBER,
	p_MAY_PCT IN NUMBER,
	p_JUN_PCT IN NUMBER,
	p_JUL_PCT IN NUMBER,
	p_AUG_PCT IN NUMBER,
	p_SEP_PCT IN NUMBER,
	p_OCT_PCT IN NUMBER,
	p_NOV_PCT IN NUMBER,
	p_DEC_PCT IN NUMBER
	);

PROCEDURE GET_GROWTH_PATTERN
	(
	p_PATTERN_ID IN NUMBER,
	p_PATTERN_NAME OUT VARCHAR2,
	p_PATTERN_ALIAS OUT VARCHAR2,
	p_PATTERN_DESC OUT VARCHAR2,
	p_JAN_PCT OUT NUMBER,
	p_FEB_PCT OUT NUMBER,
	p_MAR_PCT OUT NUMBER,
	p_APR_PCT OUT NUMBER,
	p_MAY_PCT OUT NUMBER,
	p_JUN_PCT OUT NUMBER,
	p_JUL_PCT OUT NUMBER,
	p_AUG_PCT OUT NUMBER,
	p_SEP_PCT OUT NUMBER,
	p_OCT_PCT OUT NUMBER,
	p_NOV_PCT OUT NUMBER,
	p_DEC_PCT OUT NUMBER
	);

PROCEDURE PUT_HEAT_RATE_CURVE
	(
	o_OID OUT NUMBER,
	p_HEAT_RATE_CURVE_NAME IN VARCHAR2,
	p_HEAT_RATE_CURVE_ALIAS IN VARCHAR2,
	p_HEAT_RATE_CURVE_DESC IN VARCHAR2,
	p_HEAT_RATE_CURVE_ID IN NUMBER,
	p_STATION_ID IN NUMBER,
	p_PARAMETER_1_ID IN NUMBER,
	p_PARAMETER_1_ROUND_TO_NEAREST IN NUMBER,
	p_PARAMETER_1_ROUNDING_STYLE IN VARCHAR2,
	p_PARAMETER_2_ID IN NUMBER,
	p_PARAMETER_2_ROUND_TO_NEAREST IN NUMBER,
	p_PARAMETER_2_ROUNDING_STYLE IN VARCHAR2,
	p_PARAMETER_3_ID IN NUMBER,
	p_PARAMETER_3_ROUND_TO_NEAREST IN NUMBER,
	p_PARAMETER_3_ROUNDING_STYLE IN VARCHAR2
	);

PROCEDURE GET_HEAT_RATE_CURVE
	(
	p_HEAT_RATE_CURVE_ID IN NUMBER,
	p_HEAT_RATE_CURVE_NAME OUT VARCHAR2,
	p_HEAT_RATE_CURVE_ALIAS OUT VARCHAR2,
	p_HEAT_RATE_CURVE_DESC OUT VARCHAR2,
	p_STATION_ID OUT NUMBER,
	p_PARAMETER_1_ID OUT NUMBER,
	p_PARAMETER_1_ROUND_TO_NEAREST OUT NUMBER,
	p_PARAMETER_1_ROUNDING_STYLE OUT VARCHAR2,
	p_PARAMETER_2_ID OUT NUMBER,
	p_PARAMETER_2_ROUND_TO_NEAREST OUT NUMBER,
	p_PARAMETER_2_ROUNDING_STYLE OUT VARCHAR2,
	p_PARAMETER_3_ID OUT NUMBER,
	p_PARAMETER_3_ROUND_TO_NEAREST OUT NUMBER,
	p_PARAMETER_3_ROUNDING_STYLE OUT VARCHAR2
	);

PROCEDURE PUT_HOLIDAY
	(
	o_OID OUT NUMBER,
	p_HOLIDAY_NAME IN VARCHAR2,
	p_HOLIDAY_ALIAS IN VARCHAR2,
	p_HOLIDAY_DESC IN VARCHAR2,
	p_HOLIDAY_ID IN NUMBER
	);

PROCEDURE GET_HOLIDAY
	(
	p_HOLIDAY_ID IN NUMBER,
	p_HOLIDAY_NAME OUT VARCHAR2,
	p_HOLIDAY_ALIAS OUT VARCHAR2,
	p_HOLIDAY_DESC OUT VARCHAR2
	);

PROCEDURE PUT_HOLIDAY_SET
	(
	o_OID OUT NUMBER,
	p_HOLIDAY_SET_NAME IN VARCHAR2,
	p_HOLIDAY_SET_ALIAS IN VARCHAR2,
	p_HOLIDAY_SET_DESC IN VARCHAR2,
	p_HOLIDAY_SET_ID IN NUMBER
	);

PROCEDURE GET_HOLIDAY_SET
	(
	p_HOLIDAY_SET_ID IN NUMBER,
	p_HOLIDAY_SET_NAME OUT VARCHAR2,
	p_HOLIDAY_SET_ALIAS OUT VARCHAR2,
	p_HOLIDAY_SET_DESC OUT VARCHAR2
	);

PROCEDURE PUT_INTERCHANGE_CONTRACT
	(
	o_OID OUT NUMBER,
	p_CONTRACT_NAME IN VARCHAR2,
	p_CONTRACT_ALIAS IN VARCHAR2,
	p_CONTRACT_DESC IN VARCHAR2,
	p_CONTRACT_ID IN NUMBER,
	p_CONTRACT_STATUS IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_IS_EVERGREEN IN NUMBER,
	p_CONTRACT_TYPE IN VARCHAR2,
	p_BILLING_ENTITY_ID IN NUMBER,
	p_PURCHASER_ID IN NUMBER,
	p_SELLER_ID IN NUMBER,
	p_SOURCE_ID IN NUMBER,
	p_SINK_ID IN NUMBER,
	p_POR_ID IN NUMBER,
	p_POD_ID IN NUMBER,
	p_SC_ID IN NUMBER,
	p_AGREEMENT_TYPE IN VARCHAR2,
	p_APPROVAL_TYPE IN VARCHAR2,
	p_MARKET_TYPE IN VARCHAR2,
	p_LOSS_OPTION IN VARCHAR2,
	p_CONTRACT_FILE_NAME IN VARCHAR2,
	p_PIPELINE_ID IN NUMBER,
	p_PIPELINE_TARIFF_TYPE IN VARCHAR2
	);

PROCEDURE GET_INTERCHANGE_CONTRACT
	(
	p_CONTRACT_ID IN NUMBER,
	p_CONTRACT_NAME OUT VARCHAR2,
	p_CONTRACT_ALIAS OUT VARCHAR2,
	p_CONTRACT_DESC OUT VARCHAR2,
	p_CONTRACT_STATUS OUT VARCHAR2,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE,
	p_IS_EVERGREEN OUT NUMBER,
	p_CONTRACT_TYPE OUT VARCHAR2,
	p_BILLING_ENTITY_ID OUT NUMBER,
	p_PURCHASER_ID OUT NUMBER,
	p_SELLER_ID OUT NUMBER,
	p_SOURCE_ID OUT NUMBER,
	p_SINK_ID OUT NUMBER,
	p_POR_ID OUT NUMBER,
	p_POD_ID OUT NUMBER,
	p_SC_ID OUT NUMBER,
	p_AGREEMENT_TYPE OUT VARCHAR2,
	p_APPROVAL_TYPE OUT VARCHAR2,
	p_MARKET_TYPE OUT VARCHAR2,
	p_LOSS_OPTION OUT VARCHAR2,
	p_CONTRACT_FILE_NAME OUT VARCHAR2,
	p_PIPELINE_ID OUT NUMBER,
	p_PIPELINE_TARIFF_TYPE OUT VARCHAR2
	);

PROCEDURE PUT_INVOICE_GROUP
	(
	o_OID OUT NUMBER,
	p_INVOICE_GROUP_NAME IN VARCHAR2,
	p_INVOICE_GROUP_ALIAS IN VARCHAR2,
	p_INVOICE_GROUP_DESC IN VARCHAR2,
	p_INVOICE_GROUP_ID IN NUMBER,
	p_DISPLAY_ORDER IN NUMBER,
	p_SHOW_TITLE_ON_INVOICE IN NUMBER,
	p_SHOW_SUBTOTAL_ON_INVOICE IN NUMBER
	);

PROCEDURE GET_INVOICE_GROUP
	(
	p_INVOICE_GROUP_ID IN NUMBER,
	p_INVOICE_GROUP_NAME OUT VARCHAR2,
	p_INVOICE_GROUP_ALIAS OUT VARCHAR2,
	p_INVOICE_GROUP_DESC OUT VARCHAR2,
	p_DISPLAY_ORDER OUT NUMBER,
	p_SHOW_TITLE_ON_INVOICE OUT NUMBER,
	p_SHOW_SUBTOTAL_ON_INVOICE OUT NUMBER
	);

PROCEDURE PUT_IT_COMMODITY
	(
	o_OID OUT NUMBER,
	p_COMMODITY_NAME IN VARCHAR2,
	p_COMMODITY_ALIAS IN VARCHAR2,
	p_COMMODITY_DESC IN VARCHAR2,
	p_COMMODITY_ID IN NUMBER,
	p_COMMODITY_TYPE IN VARCHAR2,
	p_COMMODITY_UNIT IN VARCHAR2,
	p_COMMODITY_UNIT_FORMAT IN VARCHAR2,
	p_COMMODITY_PRICE_UNIT IN VARCHAR2,
	p_COMMODITY_PRICE_FORMAT IN VARCHAR2,
	p_IS_VIRTUAL IN NUMBER,
	p_MARKET_TYPE IN VARCHAR2
	);

PROCEDURE GET_IT_COMMODITY
	(
	p_COMMODITY_ID IN NUMBER,
	p_COMMODITY_NAME OUT VARCHAR2,
	p_COMMODITY_ALIAS OUT VARCHAR2,
	p_COMMODITY_DESC OUT VARCHAR2,
	p_COMMODITY_TYPE OUT VARCHAR2,
	p_COMMODITY_UNIT OUT VARCHAR2,
	p_COMMODITY_UNIT_FORMAT OUT VARCHAR2,
	p_COMMODITY_PRICE_UNIT OUT VARCHAR2,
	p_COMMODITY_PRICE_FORMAT OUT VARCHAR2,
	p_IS_VIRTUAL OUT NUMBER,
	p_MARKET_TYPE OUT VARCHAR2
	);

PROCEDURE PUT_JOB_THREAD
	(
	o_OID OUT NUMBER,
	p_JOB_THREAD_NAME IN VARCHAR2,
	p_JOB_THREAD_ALIAS IN VARCHAR2,
	p_JOB_THREAD_DESC IN VARCHAR2,
	p_JOB_THREAD_ID IN NUMBER,
	p_JOB_CLASS IN VARCHAR2,
	p_IS_SNOOZED IN NUMBER
	);

PROCEDURE GET_JOB_THREAD
	(
	p_JOB_THREAD_ID IN NUMBER,
	p_JOB_THREAD_NAME OUT VARCHAR2,
	p_JOB_THREAD_ALIAS OUT VARCHAR2,
	p_JOB_THREAD_DESC OUT VARCHAR2,
	p_JOB_CLASS OUT VARCHAR2,
	p_IS_SNOOZED OUT NUMBER
	);

PROCEDURE PUT_LOAD_PROFILE
	(
	o_OID OUT NUMBER,
	p_PROFILE_LIBRARY_ID IN NUMBER,
	p_PROFILE_NAME IN VARCHAR2,
	p_PROFILE_ALIAS IN VARCHAR2,
	p_PROFILE_DESC IN VARCHAR2,
	p_PROFILE_ID IN NUMBER,
	p_PROFILE_TYPE IN VARCHAR2,
	p_PROFILE_OPERATION IN VARCHAR2,
	p_PROFILE_ORIGIN IN VARCHAR2,
	p_PROFILE_RATE_CLASS IN VARCHAR2,
	p_PROFILE_DAY_TYPE IN VARCHAR2,
	p_PROFILE_ACCOUNT_REF IN VARCHAR2,
	p_PROFILE_METER_REF IN VARCHAR2,
	p_PROFILE_SIC_CODE IN VARCHAR2,
	p_PROFILE_SEASON IN VARCHAR2,
	p_PROFILE_SYSTEM_LOAD IN VARCHAR2,
	p_PROFILE_ADJUSTMENT_OPTION IN VARCHAR2,
	p_PROFILE_STATION_ID IN NUMBER,
	p_PROFILE_TEMPLATE_ID IN NUMBER,
	p_PROFILE_SOURCE_BEGIN_DATE IN DATE,
	p_PROFILE_SOURCE_END_DATE IN DATE,
	p_PROFILE_SOURCE_ID IN NUMBER,
	p_PROFILE_INTERVAL IN NUMBER,
	p_PROFILE_SOURCE_VERSION IN DATE,
	p_PROFILE_BREAKPOINT_INTERVAL IN VARCHAR2,
	p_IS_EXTERNAL_PROFILE IN NUMBER
	);

PROCEDURE GET_LOAD_PROFILE
	(
	p_PROFILE_LIBRARY_ID OUT NUMBER,
	p_PROFILE_ID IN NUMBER,
	p_PROFILE_NAME OUT VARCHAR2,
	p_PROFILE_ALIAS OUT VARCHAR2,
	p_PROFILE_DESC OUT VARCHAR2,
	p_PROFILE_TYPE OUT VARCHAR2,
	p_PROFILE_OPERATION OUT VARCHAR2,
	p_PROFILE_ORIGIN OUT VARCHAR2,
	p_PROFILE_RATE_CLASS OUT VARCHAR2,
	p_PROFILE_DAY_TYPE OUT VARCHAR2,
	p_PROFILE_ACCOUNT_REF OUT VARCHAR2,
	p_PROFILE_METER_REF OUT VARCHAR2,
	p_PROFILE_SIC_CODE OUT VARCHAR2,
	p_PROFILE_SEASON OUT VARCHAR2,
	p_PROFILE_SYSTEM_LOAD OUT VARCHAR2,
	p_PROFILE_ADJUSTMENT_OPTION OUT VARCHAR2,
	p_PROFILE_STATION_ID OUT NUMBER,
	p_PROFILE_TEMPLATE_ID OUT NUMBER,
	p_PROFILE_SOURCE_BEGIN_DATE OUT DATE,
	p_PROFILE_SOURCE_END_DATE OUT DATE,
	p_PROFILE_SOURCE_ID OUT NUMBER,
	p_PROFILE_INTERVAL OUT NUMBER,
	p_PROFILE_SOURCE_VERSION OUT DATE,
	p_PROFILE_BREAKPOINT_INTERVAL OUT VARCHAR2,
	p_IS_EXTERNAL_PROFILE OUT NUMBER
	);

PROCEDURE PUT_LOAD_PROFILE_LIBRARY
	(
	o_OID OUT NUMBER,
	p_PROFILE_LIBRARY_NAME IN VARCHAR2,
	p_PROFILE_LIBRARY_ALIAS IN VARCHAR2,
	p_PROFILE_LIBRARY_DESC IN VARCHAR2,
	p_PROFILE_LIBRARY_ID IN NUMBER
	);

PROCEDURE GET_LOAD_PROFILE_LIBRARY
	(
	p_PROFILE_LIBRARY_ID IN NUMBER,
	p_PROFILE_LIBRARY_NAME OUT VARCHAR2,
	p_PROFILE_LIBRARY_ALIAS OUT VARCHAR2,
	p_PROFILE_LIBRARY_DESC OUT VARCHAR2
	);

PROCEDURE PUT_LOAD_PROFILE_SET
	(
	o_OID OUT NUMBER,
	p_PROFILE_SET_NAME IN VARCHAR2,
	p_PROFILE_SET_ALIAS IN VARCHAR2,
	p_PROFILE_SET_DESC IN VARCHAR2,
	p_PROFILE_SET_ID IN NUMBER,
	p_PROFILE_ID IN NUMBER
	);

PROCEDURE GET_LOAD_PROFILE_SET
	(
	p_PROFILE_SET_ID IN NUMBER,
	p_PROFILE_SET_NAME OUT VARCHAR2,
	p_PROFILE_SET_ALIAS OUT VARCHAR2,
	p_PROFILE_SET_DESC OUT VARCHAR2,
	p_PROFILE_ID OUT NUMBER
	);

PROCEDURE PUT_LOSS_FACTOR
	(
	o_OID OUT NUMBER,
	p_LOSS_FACTOR_NAME IN VARCHAR2,
	p_LOSS_FACTOR_ALIAS IN VARCHAR2,
	p_LOSS_FACTOR_DESC IN VARCHAR2,
	p_LOSS_FACTOR_ID IN NUMBER,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2
	);

PROCEDURE GET_LOSS_FACTOR
	(
	p_LOSS_FACTOR_ID IN NUMBER,
	p_LOSS_FACTOR_NAME OUT VARCHAR2,
	p_LOSS_FACTOR_ALIAS OUT VARCHAR2,
	p_LOSS_FACTOR_DESC OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2
	);

PROCEDURE PUT_MARKET_PRICE
	(
	o_OID OUT NUMBER,
	p_MARKET_PRICE_NAME IN VARCHAR2,
	p_MARKET_PRICE_ALIAS IN VARCHAR2,
	p_MARKET_PRICE_DESC IN VARCHAR2,
	p_MARKET_PRICE_ID IN NUMBER,
	p_MARKET_PRICE_TYPE IN VARCHAR2,
	p_MARKET_PRICE_INTERVAL IN VARCHAR2,
	p_MARKET_TYPE IN VARCHAR2,
	p_COMMODITY_ID IN NUMBER,
	p_SERVICE_POINT_TYPE IN VARCHAR2,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_EDC_ID IN NUMBER,
	p_SC_ID IN NUMBER,
	p_POD_ID IN NUMBER,
	p_ZOD_ID IN NUMBER
	);

PROCEDURE GET_MARKET_PRICE
	(
	p_MARKET_PRICE_ID IN NUMBER,
	p_MARKET_PRICE_NAME OUT VARCHAR2,
	p_MARKET_PRICE_ALIAS OUT VARCHAR2,
	p_MARKET_PRICE_DESC OUT VARCHAR2,
	p_MARKET_PRICE_TYPE OUT VARCHAR2,
	p_MARKET_PRICE_INTERVAL OUT VARCHAR2,
	p_MARKET_TYPE OUT VARCHAR2,
	p_COMMODITY_ID OUT NUMBER,
	p_SERVICE_POINT_TYPE OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_EDC_ID OUT NUMBER,
	p_SC_ID OUT NUMBER,
	p_POD_ID OUT NUMBER,
	p_ZOD_ID OUT NUMBER
	);

PROCEDURE PUT_MEASUREMENT_SOURCE
	(
	o_OID OUT NUMBER,
	p_MEASUREMENT_SOURCE_NAME IN VARCHAR2,
	p_MEASUREMENT_SOURCE_ALIAS IN VARCHAR2,
	p_MEASUREMENT_SOURCE_DESC IN VARCHAR2,
	p_MEASUREMENT_SOURCE_ID IN NUMBER,
	p_MEASUREMENT_SOURCE_TYPE IN VARCHAR2,
	p_MEASUREMENT_SOURCE_INTERVAL IN VARCHAR2,
	p_METER_TYPE IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_PRECISION IN NUMBER,
	p_UOM IN VARCHAR2,
	p_POLLING_TIME IN NUMBER
	);

PROCEDURE GET_MEASUREMENT_SOURCE
	(
	p_MEASUREMENT_SOURCE_ID IN NUMBER,
	p_MEASUREMENT_SOURCE_NAME OUT VARCHAR2,
	p_MEASUREMENT_SOURCE_ALIAS OUT VARCHAR2,
	p_MEASUREMENT_SOURCE_DESC OUT VARCHAR2,
	p_MEASUREMENT_SOURCE_TYPE OUT VARCHAR2,
	p_MEASUREMENT_SOURCE_INTERVAL OUT VARCHAR2,
	p_METER_TYPE OUT VARCHAR2,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE,
	p_EXTERNAL_SYSTEM_ID OUT NUMBER,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_PRECISION OUT NUMBER,
	p_UOM OUT VARCHAR2,
	p_POLLING_TIME OUT NUMBER
	);

PROCEDURE PUT_METER
	(
	o_OID OUT NUMBER,
	p_MRSP_ID IN NUMBER,
	p_METER_NAME IN VARCHAR2,
	p_METER_ALIAS IN VARCHAR2,
	p_METER_DESC IN VARCHAR2,
	p_METER_ID IN NUMBER,
	p_METER_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_METER_STATUS IN VARCHAR2,
	p_METER_INTERVAL IN VARCHAR2,
	p_METER_TYPE IN VARCHAR2,
	p_METER_UNIT IN VARCHAR2,
	p_IS_EXTERNAL_INTERVAL_USAGE IN NUMBER,
	p_IS_EXTERNAL_BILLED_USAGE IN NUMBER,
	p_IS_EXTERNAL_FORECAST IN NUMBER,
	p_USE_TOU_USAGE_FACTOR IN NUMBER
	);

PROCEDURE GET_METER
	(
	p_MRSP_ID OUT NUMBER,
	p_METER_ID IN NUMBER,
	p_METER_NAME OUT VARCHAR2,
	p_METER_ALIAS OUT VARCHAR2,
	p_METER_DESC OUT VARCHAR2,
	p_METER_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_METER_STATUS OUT VARCHAR2,
	p_METER_INTERVAL OUT VARCHAR2,
	p_METER_TYPE OUT VARCHAR2,
	p_METER_UNIT OUT VARCHAR2,
	p_IS_EXTERNAL_INTERVAL_USAGE OUT NUMBER,
	p_IS_EXTERNAL_BILLED_USAGE OUT NUMBER,
	p_IS_EXTERNAL_FORECAST OUT NUMBER,
	p_USE_TOU_USAGE_FACTOR OUT NUMBER
	);

PROCEDURE PUT_MRSP
	(
	o_OID OUT NUMBER,
	p_MRSP_NAME IN VARCHAR2,
	p_MRSP_ALIAS IN VARCHAR2,
	p_MRSP_DESC IN VARCHAR2,
	p_MRSP_ID IN NUMBER,
	p_MRSP_DUNS_NUMBER IN VARCHAR2,
	p_MRSP_STATUS IN VARCHAR2
	);

PROCEDURE GET_MRSP
	(
	p_MRSP_ID IN NUMBER,
	p_MRSP_NAME OUT VARCHAR2,
	p_MRSP_ALIAS OUT VARCHAR2,
	p_MRSP_DESC OUT VARCHAR2,
	p_MRSP_DUNS_NUMBER OUT VARCHAR2,
	p_MRSP_STATUS OUT VARCHAR2
	);

PROCEDURE PUT_OASIS_NODE
	(
	o_OID OUT NUMBER,
	p_OASIS_NODE_NAME IN VARCHAR2,
	p_OASIS_NODE_ALIAS IN VARCHAR2,
	p_OASIS_NODE_DESC IN VARCHAR2,
	p_OASIS_NODE_ID IN NUMBER,
	p_URL IN VARCHAR2
	);

PROCEDURE GET_OASIS_NODE
	(
	p_OASIS_NODE_ID IN NUMBER,
	p_OASIS_NODE_NAME OUT VARCHAR2,
	p_OASIS_NODE_ALIAS OUT VARCHAR2,
	p_OASIS_NODE_DESC OUT VARCHAR2,
	p_URL OUT VARCHAR2
	);

PROCEDURE PUT_PATH
	(
	o_OID OUT NUMBER,
	p_PATH_NAME IN VARCHAR2,
	p_PATH_ALIAS IN VARCHAR2,
	p_PATH_DESC IN VARCHAR2,
	p_PATH_ID IN NUMBER
	);

PROCEDURE GET_PATH
	(
	p_PATH_ID IN NUMBER,
	p_PATH_NAME OUT VARCHAR2,
	p_PATH_ALIAS OUT VARCHAR2,
	p_PATH_DESC OUT VARCHAR2
	);

PROCEDURE PUT_PERIOD
	(
	o_OID OUT NUMBER,
	p_PERIOD_NAME IN VARCHAR2,
	p_PERIOD_ALIAS IN VARCHAR2,
	p_PERIOD_DESC IN VARCHAR2,
	p_PERIOD_ID IN NUMBER,
	p_PERIOD_COLOR IN NUMBER
	);

PROCEDURE GET_PERIOD
	(
	p_PERIOD_ID IN NUMBER,
	p_PERIOD_NAME OUT VARCHAR2,
	p_PERIOD_ALIAS OUT VARCHAR2,
	p_PERIOD_DESC OUT VARCHAR2,
	p_PERIOD_COLOR OUT NUMBER
	);

PROCEDURE PUT_PIPELINE
	(
	o_OID OUT NUMBER,
	p_PIPELINE_NAME IN VARCHAR2,
	p_PIPELINE_ALIAS IN VARCHAR2,
	p_PIPELINE_DESC IN VARCHAR2,
	p_PIPELINE_ID IN NUMBER,
	p_PIPELINE_STATUS IN VARCHAR2,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2
	);

PROCEDURE GET_PIPELINE
	(
	p_PIPELINE_ID IN NUMBER,
	p_PIPELINE_NAME OUT VARCHAR2,
	p_PIPELINE_ALIAS OUT VARCHAR2,
	p_PIPELINE_DESC OUT VARCHAR2,
	p_PIPELINE_STATUS OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2
	);

PROCEDURE PUT_POOL
	(
	o_OID OUT NUMBER,
	p_POOL_NAME IN VARCHAR2,
	p_POOL_ALIAS IN VARCHAR2,
	p_POOL_DESC IN VARCHAR2,
	p_POOL_ID IN NUMBER,
	p_POOL_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_POOL_STATUS IN VARCHAR2,
	p_POOL_CATEGORY IN VARCHAR2,
	p_POOL_EXCLUDE_LOAD_SCHEDULE IN NUMBER
	);

PROCEDURE GET_POOL
	(
	p_POOL_ID IN NUMBER,
	p_POOL_NAME OUT VARCHAR2,
	p_POOL_ALIAS OUT VARCHAR2,
	p_POOL_DESC OUT VARCHAR2,
	p_POOL_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_POOL_STATUS OUT VARCHAR2,
	p_POOL_CATEGORY OUT VARCHAR2,
	p_POOL_EXCLUDE_LOAD_SCHEDULE OUT NUMBER
	);

PROCEDURE PUT_PORTFOLIO
	(
	o_OID OUT NUMBER,
	p_PORTFOLIO_NAME IN VARCHAR2,
	p_PORTFOLIO_ALIAS IN VARCHAR2,
	p_PORTFOLIO_DESC IN VARCHAR2,
	p_PORTFOLIO_ID IN NUMBER
	);

PROCEDURE GET_PORTFOLIO
	(
	p_PORTFOLIO_ID IN NUMBER,
	p_PORTFOLIO_NAME OUT VARCHAR2,
	p_PORTFOLIO_ALIAS OUT VARCHAR2,
	p_PORTFOLIO_DESC OUT VARCHAR2
	);

PROCEDURE PUT_POSITION_EVALUATION
	(
	o_OID OUT NUMBER,
	p_EVALUATION_NAME IN VARCHAR2,
	p_EVALUATION_ALIAS IN VARCHAR2,
	p_EVALUATION_DESC IN VARCHAR2,
	p_EVALUATION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_MARKET_PRICE_ID IN NUMBER,
	p_LAST_RUN_DATE IN DATE
	);

PROCEDURE GET_POSITION_EVALUATION
	(
	p_EVALUATION_ID IN NUMBER,
	p_EVALUATION_NAME OUT VARCHAR2,
	p_EVALUATION_ALIAS OUT VARCHAR2,
	p_EVALUATION_DESC OUT VARCHAR2,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE,
	p_MARKET_PRICE_ID OUT NUMBER,
	p_LAST_RUN_DATE OUT DATE
	);

PROCEDURE PUT_PRODUCT
	(
	o_OID OUT NUMBER,
	p_PRODUCT_NAME IN VARCHAR2,
	p_PRODUCT_ALIAS IN VARCHAR2,
	p_PRODUCT_DESC IN VARCHAR2,
	p_PRODUCT_ID IN NUMBER,
	p_PRODUCT_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_PRODUCT_CATEGORY IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	);

PROCEDURE GET_PRODUCT
	(
	p_PRODUCT_ID IN NUMBER,
	p_PRODUCT_NAME OUT VARCHAR2,
	p_PRODUCT_ALIAS OUT VARCHAR2,
	p_PRODUCT_DESC OUT VARCHAR2,
	p_PRODUCT_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_PRODUCT_CATEGORY OUT VARCHAR2,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE
	);

PROCEDURE PUT_PROGRAM
	(
	o_OID OUT NUMBER,
	p_PROGRAM_NAME IN VARCHAR2,
	p_PROGRAM_ALIAS IN VARCHAR2,
	p_PROGRAM_DESC IN VARCHAR2,
	p_PROGRAM_ID IN NUMBER,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_PROGRAM_TYPE IN VARCHAR2,
	p_PROGRAM_INTERVAL IN VARCHAR2,
	p_CUSTOMER_TYPE IN VARCHAR2,
	p_MAX_DURATION_HOUR IN NUMBER,
	p_MAX_DURATION_MINUTE IN NUMBER,
	p_MIN_OFF_TIME_HOUR IN NUMBER,
	p_MIN_OFF_TIME_MINUTE IN NUMBER,
	p_DEGREE_INCREASE IN NUMBER,
	p_DEGREE_DECREASE IN NUMBER,
	p_ALLOW_CUSTOMER_OVERRIDE IN NUMBER,
	p_DEFAULT_OPT_OUT_PCT IN NUMBER,
	p_DEFAULT_OVERRIDE_PCT IN NUMBER,
	p_USE_DEFAULT_OPT_OUT_OVERRIDE IN NUMBER,
	p_VALIDATION_METHOD IN VARCHAR2,
	p_TRANSACTION_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_SIGNAL_TYPE IN VARCHAR2
	);

PROCEDURE GET_PROGRAM
	(
	p_PROGRAM_ID IN NUMBER,
	p_PROGRAM_NAME OUT VARCHAR2,
	p_PROGRAM_ALIAS OUT VARCHAR2,
	p_PROGRAM_DESC OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_PROGRAM_TYPE OUT VARCHAR2,
	p_PROGRAM_INTERVAL OUT VARCHAR2,
	p_CUSTOMER_TYPE OUT VARCHAR2,
	p_MAX_DURATION_HOUR OUT NUMBER,
	p_MAX_DURATION_MINUTE OUT NUMBER,
	p_MIN_OFF_TIME_HOUR OUT NUMBER,
	p_MIN_OFF_TIME_MINUTE OUT NUMBER,
	p_DEGREE_INCREASE OUT NUMBER,
	p_DEGREE_DECREASE OUT NUMBER,
	p_ALLOW_CUSTOMER_OVERRIDE OUT NUMBER,
	p_DEFAULT_OPT_OUT_PCT OUT NUMBER,
	p_DEFAULT_OVERRIDE_PCT OUT NUMBER,
	p_USE_DEFAULT_OPT_OUT_OVERRIDE OUT NUMBER,
	p_VALIDATION_METHOD OUT VARCHAR2,
	p_TRANSACTION_ID OUT NUMBER,
	p_COMPONENT_ID OUT NUMBER,
	p_SIGNAL_TYPE OUT VARCHAR2
	);

PROCEDURE PUT_PROSPECT_SCREEN
	(
	o_OID OUT NUMBER,
	p_SCREEN_NAME IN VARCHAR2,
	p_SCREEN_ALIAS IN VARCHAR2,
	p_SCREEN_DESC IN VARCHAR2,
	p_SCREEN_ID IN NUMBER
	);

PROCEDURE GET_PROSPECT_SCREEN
	(
	p_SCREEN_ID IN NUMBER,
	p_SCREEN_NAME OUT VARCHAR2,
	p_SCREEN_ALIAS OUT VARCHAR2,
	p_SCREEN_DESC OUT VARCHAR2
	);

PROCEDURE PUT_PROXY_DAY_METHOD
	(
	o_OID OUT NUMBER,
	p_PROXY_DAY_METHOD_NAME IN VARCHAR2,
	p_PROXY_DAY_METHOD_ALIAS IN VARCHAR2,
	p_PROXY_DAY_METHOD_DESC IN VARCHAR2,
	p_PROXY_DAY_METHOD_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_COMPARATIVE_VALUE IN VARCHAR2,
	p_STATION_ID IN NUMBER,
	p_PARAMETER_ID IN NUMBER,
	p_SYSTEM_LOAD_ID IN NUMBER,
	p_LOOKUP_TIME_HORIZON IN NUMBER,
	p_TIME_HORIZON_SHIFT IN NUMBER,
	p_LOOKUP_CANDIDATE_LIMIT IN NUMBER,
	p_CANDIDATE_DELTA_THRESHOLD IN NUMBER,
	p_HOLIDAY_SET_ID IN NUMBER
	);

PROCEDURE GET_PROXY_DAY_METHOD
	(
	p_PROXY_DAY_METHOD_ID IN NUMBER,
	p_PROXY_DAY_METHOD_NAME OUT VARCHAR2,
	p_PROXY_DAY_METHOD_ALIAS OUT VARCHAR2,
	p_PROXY_DAY_METHOD_DESC OUT VARCHAR2,
	p_TEMPLATE_ID OUT NUMBER,
	p_COMPARATIVE_VALUE OUT VARCHAR2,
	p_STATION_ID OUT NUMBER,
	p_PARAMETER_ID OUT NUMBER,
	p_SYSTEM_LOAD_ID OUT NUMBER,
	p_LOOKUP_TIME_HORIZON OUT NUMBER,
	p_TIME_HORIZON_SHIFT OUT NUMBER,
	p_LOOKUP_CANDIDATE_LIMIT OUT NUMBER,
	p_CANDIDATE_DELTA_THRESHOLD OUT NUMBER,
	p_HOLIDAY_SET_ID OUT NUMBER
	);

PROCEDURE PUT_PSE
	(
	o_OID OUT NUMBER,
	p_PSE_NAME IN VARCHAR2,
	p_PSE_ALIAS IN VARCHAR2,
	p_PSE_DESC IN VARCHAR2,
	p_PSE_ID IN NUMBER,
	p_PSE_NERC_CODE IN VARCHAR2,
	p_PSE_STATUS IN VARCHAR2,
	p_PSE_DUNS_NUMBER IN VARCHAR2,
	p_PSE_BANK IN VARCHAR2,
	p_PSE_ACH_NUMBER IN VARCHAR2,
	p_PSE_TYPE IN VARCHAR2,
	p_PSE_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_PSE_IS_RETAIL_AGGREGATOR IN NUMBER,
	p_PSE_IS_BACKUP_GENERATION IN NUMBER,
	p_PSE_EXCLUDE_LOAD_SCHEDULE IN NUMBER,
	p_IS_BILLING_ENTITY IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_STATEMENT_INTERVAL IN VARCHAR2,
	p_INVOICE_INTERVAL IN VARCHAR2,
	p_WEEK_BEGIN IN VARCHAR2,
	p_INVOICE_LINE_ITEM_OPTION IN VARCHAR2,
	p_INVOICE_EMAIL_SUBJECT IN VARCHAR2,
	p_INVOICE_EMAIL_PRIORITY IN NUMBER,
	p_INVOICE_EMAIL_BODY IN VARCHAR2,
	p_INVOICE_EMAIL_BODY_MIME_TYPE IN VARCHAR2,
	p_SCHEDULE_NAME_PREFIX IN VARCHAR2,
	p_SCHEDULE_FORMAT IN VARCHAR2,
	p_SCHEDULE_INTERVAL IN VARCHAR2,
	p_LOAD_ROUNDING_PREFERENCE IN VARCHAR2,
	p_LOSS_ROUNDING_PREFERENCE IN VARCHAR2,
	p_CREATE_TX_LOSS_SCHEDULE IN NUMBER,
	p_CREATE_DX_LOSS_SCHEDULE IN NUMBER,
	p_CREATE_UFE_SCHEDULE IN NUMBER,
	p_MINIMUM_SCHEDULE_AMT IN NUMBER
	);

PROCEDURE GET_PSE
	(
	p_PSE_ID IN NUMBER,
	p_PSE_NAME OUT VARCHAR2,
	p_PSE_ALIAS OUT VARCHAR2,
	p_PSE_DESC OUT VARCHAR2,
	p_PSE_NERC_CODE OUT VARCHAR2,
	p_PSE_STATUS OUT VARCHAR2,
	p_PSE_DUNS_NUMBER OUT VARCHAR2,
	p_PSE_BANK OUT VARCHAR2,
	p_PSE_ACH_NUMBER OUT VARCHAR2,
	p_PSE_TYPE OUT VARCHAR2,
	p_PSE_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_PSE_IS_RETAIL_AGGREGATOR OUT NUMBER,
	p_PSE_IS_BACKUP_GENERATION OUT NUMBER,
	p_PSE_EXCLUDE_LOAD_SCHEDULE OUT NUMBER,
	p_IS_BILLING_ENTITY OUT NUMBER,
	p_TIME_ZONE OUT VARCHAR2,
	p_STATEMENT_INTERVAL OUT VARCHAR2,
	p_INVOICE_INTERVAL OUT VARCHAR2,
	p_WEEK_BEGIN OUT VARCHAR2,
	p_INVOICE_LINE_ITEM_OPTION OUT VARCHAR2,
	p_INVOICE_EMAIL_SUBJECT OUT VARCHAR2,
	p_INVOICE_EMAIL_PRIORITY OUT NUMBER,
	p_INVOICE_EMAIL_BODY OUT VARCHAR2,
	p_INVOICE_EMAIL_BODY_MIME_TYPE OUT VARCHAR2,
	p_SCHEDULE_NAME_PREFIX OUT VARCHAR2,
	p_SCHEDULE_FORMAT OUT VARCHAR2,
	p_SCHEDULE_INTERVAL OUT VARCHAR2,
	p_LOAD_ROUNDING_PREFERENCE OUT VARCHAR2,
	p_LOSS_ROUNDING_PREFERENCE OUT VARCHAR2,
	p_CREATE_TX_LOSS_SCHEDULE OUT NUMBER,
	p_CREATE_DX_LOSS_SCHEDULE OUT NUMBER,
	p_CREATE_UFE_SCHEDULE OUT NUMBER,
	p_MINIMUM_SCHEDULE_AMT OUT NUMBER
	);

PROCEDURE PUT_QUOTE_REQUEST
	(
	o_OID OUT NUMBER,
	p_QUOTE_NAME IN VARCHAR2,
	p_QUOTE_ALIAS IN VARCHAR2,
	p_QUOTE_DESC IN VARCHAR2,
	p_QUOTE_ID IN NUMBER,
	p_CAMPAIGN_NAME IN VARCHAR2,
	p_CUSTOMER_NAME IN VARCHAR2,
	p_CUSTOMER_TYPE IN VARCHAR2,
	p_CUSTOMER_REP_NAME IN VARCHAR2,
	p_EDC_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_CUSTOMER_CLASS IN VARCHAR2,
	p_EDC_ACCOUNT_NUMBER IN VARCHAR2,
	p_QUOTE_EFFECTIVE_DATE IN DATE,
	p_QUOTE_EXPIRATION_DATE IN DATE,
	p_SERVICE_BEGIN_DATE IN DATE,
	p_SERVICE_END_DATE IN DATE,
	p_QUOTE_TYPE IN VARCHAR2,
	p_QUOTE_STATUS IN VARCHAR2,
	p_STATION_ID IN NUMBER,
	p_NUMBER_OF_CUSTOMERS IN NUMBER,
	p_SIGNING_PROBABILITY IN NUMBER,
	p_QUOTE_NOTES IN VARCHAR2
	);

PROCEDURE GET_QUOTE_REQUEST
	(
	p_QUOTE_ID IN NUMBER,
	p_QUOTE_NAME OUT VARCHAR2,
	p_QUOTE_ALIAS OUT VARCHAR2,
	p_QUOTE_DESC OUT VARCHAR2,
	p_CAMPAIGN_NAME OUT VARCHAR2,
	p_CUSTOMER_NAME OUT VARCHAR2,
	p_CUSTOMER_TYPE OUT VARCHAR2,
	p_CUSTOMER_REP_NAME OUT VARCHAR2,
	p_EDC_ID OUT NUMBER,
	p_SERVICE_POINT_ID OUT NUMBER,
	p_CUSTOMER_CLASS OUT VARCHAR2,
	p_EDC_ACCOUNT_NUMBER OUT VARCHAR2,
	p_QUOTE_EFFECTIVE_DATE OUT DATE,
	p_QUOTE_EXPIRATION_DATE OUT DATE,
	p_SERVICE_BEGIN_DATE OUT DATE,
	p_SERVICE_END_DATE OUT DATE,
	p_QUOTE_TYPE OUT VARCHAR2,
	p_QUOTE_STATUS OUT VARCHAR2,
	p_STATION_ID OUT NUMBER,
	p_NUMBER_OF_CUSTOMERS OUT NUMBER,
	p_SIGNING_PROBABILITY OUT NUMBER,
	p_QUOTE_NOTES OUT VARCHAR2
	);

PROCEDURE PUT_REACTOR_PROCEDURE
	(
	o_OID OUT NUMBER,
	p_REACTOR_PROCEDURE_NAME IN VARCHAR2,
	p_REACTOR_PROCEDURE_ALIAS IN VARCHAR2,
	p_REACTOR_PROCEDURE_DESC IN VARCHAR2,
	p_REACTOR_PROCEDURE_ID IN NUMBER,
	p_TABLE_ID IN NUMBER,
	p_PROCEDURE_NAME IN VARCHAR2,
	p_JOB_THREAD_ID IN NUMBER,
	p_JOB_COMMENTS IN VARCHAR2,
	p_CALL_ORDER IN NUMBER,
	p_SKIP_WHEN_FORMULA IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_IS_IMMEDIATE IN NUMBER,
	p_IS_ENABLED IN NUMBER
	);

PROCEDURE GET_REACTOR_PROCEDURE
	(
	p_REACTOR_PROCEDURE_ID IN NUMBER,
	p_REACTOR_PROCEDURE_NAME OUT VARCHAR2,
	p_REACTOR_PROCEDURE_ALIAS OUT VARCHAR2,
	p_REACTOR_PROCEDURE_DESC OUT VARCHAR2,
	p_TABLE_ID OUT NUMBER,
	p_PROCEDURE_NAME OUT VARCHAR2,
	p_JOB_THREAD_ID OUT NUMBER,
	p_JOB_COMMENTS OUT VARCHAR2,
	p_CALL_ORDER OUT NUMBER,
	p_SKIP_WHEN_FORMULA OUT VARCHAR2,
	p_TIME_ZONE OUT VARCHAR2,
	p_IS_IMMEDIATE OUT NUMBER,
	p_IS_ENABLED OUT NUMBER
	);

PROCEDURE PUT_RESOURCE_GROUP
	(
	o_OID OUT NUMBER,
	p_RESOURCE_GROUP_NAME IN VARCHAR2,
	p_RESOURCE_GROUP_ALIAS IN VARCHAR2,
	p_RESOURCE_GROUP_DESC IN VARCHAR2,
	p_RESOURCE_GROUP_ID IN NUMBER,
	p_SERVICE_ZONE_ID IN NUMBER
	);

PROCEDURE GET_RESOURCE_GROUP
	(
	p_RESOURCE_GROUP_ID IN NUMBER,
	p_RESOURCE_GROUP_NAME OUT VARCHAR2,
	p_RESOURCE_GROUP_ALIAS OUT VARCHAR2,
	p_RESOURCE_GROUP_DESC OUT VARCHAR2,
	p_SERVICE_ZONE_ID OUT NUMBER
	);

PROCEDURE PUT_ROLLUP
	(
	o_OID OUT NUMBER,
	p_ROLLUP_NAME IN VARCHAR2,
	p_ROLLUP_ALIAS IN VARCHAR2,
	p_ROLLUP_DESC IN VARCHAR2,
	p_ROLLUP_ID IN NUMBER,
	p_ROLLUP_CATEGORY IN VARCHAR2,
	p_ROLLUP_LEVEL IN NUMBER,
	p_ROLLUP_PARENT_ID IN NUMBER,
	p_ROLLUP_CHILDREN IN NUMBER
	);

PROCEDURE GET_ROLLUP
	(
	p_ROLLUP_NAME OUT VARCHAR2,
	p_ROLLUP_ALIAS OUT VARCHAR2,
	p_ROLLUP_DESC OUT VARCHAR2,
	p_ROLLUP_ID IN NUMBER,
	p_ROLLUP_CATEGORY OUT VARCHAR2,
	p_ROLLUP_LEVEL OUT NUMBER,
	p_ROLLUP_PARENT_ID OUT NUMBER,
	p_ROLLUP_CHILDREN OUT NUMBER
	);

PROCEDURE PUT_SC
	(
	o_OID OUT NUMBER,
	p_SC_NAME IN VARCHAR2,
	p_SC_ALIAS IN VARCHAR2,
	p_SC_DESC IN VARCHAR2,
	p_SC_ID IN NUMBER,
	p_SC_NERC_CODE IN VARCHAR2,
	p_SC_DUNS_NUMBER IN VARCHAR2,
	p_SC_STATUS IN VARCHAR2,
	p_SC_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_SC_SCHEDULE_NAME_PREFIX IN VARCHAR2,
	p_SC_SCHEDULE_FORMAT IN VARCHAR2,
	p_SC_SCHEDULE_INTERVAL IN VARCHAR2,
	p_SC_LOAD_ROUNDING_PREFERENCE IN VARCHAR2,
	p_SC_LOSS_ROUNDING_PREFERENCE IN VARCHAR2,
	p_SC_CREATE_TX_LOSS_SCHEDULE IN NUMBER,
	p_SC_CREATE_DX_LOSS_SCHEDULE IN NUMBER,
	p_SC_CREATE_UFE_SCHEDULE IN NUMBER,
	p_SC_MARKET_PRICE_ID IN NUMBER,
	p_SC_MINIMUM_SCHEDULE_AMT IN NUMBER
	);

PROCEDURE GET_SC
	(
	p_SC_ID IN NUMBER,
	p_SC_NAME OUT VARCHAR2,
	p_SC_ALIAS OUT VARCHAR2,
	p_SC_DESC OUT VARCHAR2,
	p_SC_NERC_CODE OUT VARCHAR2,
	p_SC_DUNS_NUMBER OUT VARCHAR2,
	p_SC_STATUS OUT VARCHAR2,
	p_SC_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_SC_SCHEDULE_NAME_PREFIX OUT VARCHAR2,
	p_SC_SCHEDULE_FORMAT OUT VARCHAR2,
	p_SC_SCHEDULE_INTERVAL OUT VARCHAR2,
	p_SC_LOAD_ROUNDING_PREFERENCE OUT VARCHAR2,
	p_SC_LOSS_ROUNDING_PREFERENCE OUT VARCHAR2,
	p_SC_CREATE_TX_LOSS_SCHEDULE OUT NUMBER,
	p_SC_CREATE_DX_LOSS_SCHEDULE OUT NUMBER,
	p_SC_CREATE_UFE_SCHEDULE OUT NUMBER,
	p_SC_MARKET_PRICE_ID OUT NUMBER,
	p_SC_MINIMUM_SCHEDULE_AMT OUT NUMBER
	);

PROCEDURE PUT_SCENARIO
	(
	o_OID OUT NUMBER,
	p_SCENARIO_NAME IN VARCHAR2,
	p_SCENARIO_ALIAS IN VARCHAR2,
	p_SCENARIO_DESC IN VARCHAR2,
	p_SCENARIO_ID IN NUMBER,
	p_SCENARIO_CATEGORY IN VARCHAR2
	);

PROCEDURE GET_SCENARIO
	(
	p_SCENARIO_ID IN NUMBER,
	p_SCENARIO_NAME OUT VARCHAR2,
	p_SCENARIO_ALIAS OUT VARCHAR2,
	p_SCENARIO_DESC OUT VARCHAR2,
	p_SCENARIO_CATEGORY OUT VARCHAR2
	);

PROCEDURE PUT_SCHEDULE_GROUP
	(
	o_OID OUT NUMBER,
	p_SCHEDULE_GROUP_NAME IN VARCHAR2,
	p_SCHEDULE_GROUP_ALIAS IN VARCHAR2,
	p_SCHEDULE_GROUP_DESC IN VARCHAR2,
	p_SCHEDULE_GROUP_ID IN NUMBER,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_SC_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_METER_TYPE IN VARCHAR2
	);

PROCEDURE GET_SCHEDULE_GROUP
	(
	p_SCHEDULE_GROUP_ID IN NUMBER,
	p_SCHEDULE_GROUP_NAME OUT VARCHAR2,
	p_SCHEDULE_GROUP_ALIAS OUT VARCHAR2,
	p_SCHEDULE_GROUP_DESC OUT VARCHAR2,
	p_SERVICE_ZONE_ID OUT NUMBER,
	p_SC_ID OUT NUMBER,
	p_SERVICE_POINT_ID OUT NUMBER,
	p_METER_TYPE OUT VARCHAR2
	);

PROCEDURE PUT_SEASON
	(
	o_OID OUT NUMBER,
	p_SEASON_NAME IN VARCHAR2,
	p_SEASON_ALIAS IN VARCHAR2,
	p_SEASON_DESC IN VARCHAR2,
	p_SEASON_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	);

PROCEDURE GET_SEASON
	(
	p_SEASON_ID IN NUMBER,
	p_SEASON_NAME OUT VARCHAR2,
	p_SEASON_ALIAS OUT VARCHAR2,
	p_SEASON_DESC OUT VARCHAR2,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE
	);

PROCEDURE PUT_SEGMENT
	(
	o_OID OUT NUMBER,
	p_SEGMENT_NAME IN VARCHAR2,
	p_SEGMENT_ALIAS IN VARCHAR2,
	p_SEGMENT_DESC IN VARCHAR2,
	p_SEGMENT_ID IN NUMBER,
	p_POR_ID IN NUMBER,
	p_POD_ID IN NUMBER,
	p_MW_LIMIT_1 IN VARCHAR2,
	p_MW_LIMIT_2 IN VARCHAR2,
	p_MW_LIMIT_3 IN VARCHAR2,
	p_LOSS_FACTOR IN NUMBER
	);

PROCEDURE GET_SEGMENT
	(
	p_SEGMENT_ID IN NUMBER,
	p_SEGMENT_NAME OUT VARCHAR2,
	p_SEGMENT_ALIAS OUT VARCHAR2,
	p_SEGMENT_DESC OUT VARCHAR2,
	p_POR_ID OUT NUMBER,
	p_POD_ID OUT NUMBER,
	p_MW_LIMIT_1 OUT VARCHAR2,
	p_MW_LIMIT_2 OUT VARCHAR2,
	p_MW_LIMIT_3 OUT VARCHAR2,
	p_LOSS_FACTOR OUT NUMBER
	);

PROCEDURE PUT_SERVICE_AREA
	(
	o_OID OUT NUMBER,
	p_SERVICE_AREA_NAME IN VARCHAR2,
	p_SERVICE_AREA_ALIAS IN VARCHAR2,
	p_SERVICE_AREA_DESC IN VARCHAR2,
	p_SERVICE_AREA_ID IN NUMBER
	);

PROCEDURE GET_SERVICE_AREA
	(
	p_SERVICE_AREA_ID IN NUMBER,
	p_SERVICE_AREA_NAME OUT VARCHAR2,
	p_SERVICE_AREA_ALIAS OUT VARCHAR2,
	p_SERVICE_AREA_DESC OUT VARCHAR2
	);

PROCEDURE PUT_SERVICE_LOCATION
	(
	o_OID OUT NUMBER,
	p_SERVICE_LOCATION_NAME IN VARCHAR2,
	p_SERVICE_LOCATION_ALIAS IN VARCHAR2,
	p_SERVICE_LOCATION_DESC IN VARCHAR2,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_LATITUDE IN VARCHAR2,
	p_LONGITUDE IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_IS_EXTERNAL_BILLED_USAGE IN NUMBER,
	p_IS_METER_ALLOCATION IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_WEATHER_STATION_ID IN NUMBER,
	p_BUSINESS_ROLLUP_ID IN NUMBER,
	p_GEOGRAPHIC_ROLLUP_ID IN NUMBER,
	p_SQUARE_FOOTAGE IN NUMBER,
	p_ANNUAL_CONSUMPTION IN NUMBER,
	p_SUMMER_CONSUMPTION IN NUMBER,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_SUB_STATION_ID IN NUMBER,
	p_FEEDER_ID IN NUMBER,
	p_FEEDER_SEGMENT_ID IN NUMBER
	);

PROCEDURE GET_SERVICE_LOCATION
	(
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_SERVICE_LOCATION_NAME OUT VARCHAR2,
	p_SERVICE_LOCATION_ALIAS OUT VARCHAR2,
	p_SERVICE_LOCATION_DESC OUT VARCHAR2,
	p_LATITUDE OUT VARCHAR2,
	p_LONGITUDE OUT VARCHAR2,
	p_TIME_ZONE OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_IS_EXTERNAL_BILLED_USAGE OUT NUMBER,
	p_IS_METER_ALLOCATION OUT NUMBER,
	p_SERVICE_POINT_ID OUT NUMBER,
	p_WEATHER_STATION_ID OUT NUMBER,
	p_BUSINESS_ROLLUP_ID OUT NUMBER,
	p_GEOGRAPHIC_ROLLUP_ID OUT NUMBER,
	p_SQUARE_FOOTAGE OUT NUMBER,
	p_ANNUAL_CONSUMPTION OUT NUMBER,
	p_SUMMER_CONSUMPTION OUT NUMBER,
	p_SERVICE_ZONE_ID OUT NUMBER,
	p_SUB_STATION_ID OUT NUMBER,
	p_FEEDER_ID OUT NUMBER,
	p_FEEDER_SEGMENT_ID OUT NUMBER
	);

PROCEDURE PUT_SERVICE_POINT
	(
	o_OID OUT NUMBER,
	p_SERVICE_POINT_NAME IN VARCHAR2,
	p_SERVICE_POINT_ALIAS IN VARCHAR2,
	p_SERVICE_POINT_DESC IN VARCHAR2,
	p_SERVICE_POINT_ID IN NUMBER,
	p_SERVICE_POINT_TYPE IN VARCHAR2,
	p_TP_ID IN NUMBER,
	p_CA_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_ROLLUP_ID IN NUMBER,
	p_SERVICE_REGION_ID IN NUMBER,
	p_SERVICE_AREA_ID IN NUMBER,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_LATITUDE IN VARCHAR2,
	p_LONGITUDE IN VARCHAR2,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_IS_INTERCONNECT IN NUMBER,
	p_NODE_TYPE IN VARCHAR2,
	p_SERVICE_POINT_NERC_CODE IN VARCHAR2,
	p_PIPELINE_ID IN NUMBER,
	p_MILE_MARKER IN NUMBER
	);

PROCEDURE GET_SERVICE_POINT
	(
	p_SERVICE_POINT_ID IN NUMBER,
	p_SERVICE_POINT_NAME OUT VARCHAR2,
	p_SERVICE_POINT_ALIAS OUT VARCHAR2,
	p_SERVICE_POINT_DESC OUT VARCHAR2,
	p_SERVICE_POINT_TYPE OUT VARCHAR2,
	p_TP_ID OUT NUMBER,
	p_CA_ID OUT NUMBER,
	p_EDC_ID OUT NUMBER,
	p_ROLLUP_ID OUT NUMBER,
	p_SERVICE_REGION_ID OUT NUMBER,
	p_SERVICE_AREA_ID OUT NUMBER,
	p_SERVICE_ZONE_ID OUT NUMBER,
	p_TIME_ZONE OUT VARCHAR2,
	p_LATITUDE OUT VARCHAR2,
	p_LONGITUDE OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_IS_INTERCONNECT OUT NUMBER,
	p_NODE_TYPE OUT VARCHAR2,
	p_SERVICE_POINT_NERC_CODE OUT VARCHAR2,
	p_PIPELINE_ID OUT NUMBER,
	p_MILE_MARKER OUT NUMBER
	);

PROCEDURE PUT_SERVICE_REGION
	(
	o_OID OUT NUMBER,
	p_SERVICE_REGION_NAME IN VARCHAR2,
	p_SERVICE_REGION_ALIAS IN VARCHAR2,
	p_SERVICE_REGION_DESC IN VARCHAR2,
	p_SERVICE_REGION_ID IN NUMBER
	);

PROCEDURE GET_SERVICE_REGION
	(
	p_SERVICE_REGION_ID IN NUMBER,
	p_SERVICE_REGION_NAME OUT VARCHAR2,
	p_SERVICE_REGION_ALIAS OUT VARCHAR2,
	p_SERVICE_REGION_DESC OUT VARCHAR2
	);

PROCEDURE PUT_SERVICE_TYPE
	(
	o_OID OUT NUMBER,
	p_SERVICE_TYPE_NAME IN VARCHAR2,
	p_SERVICE_TYPE_ALIAS IN VARCHAR2,
	p_SERVICE_TYPE_DESC IN VARCHAR2,
	p_SERVICE_TYPE_ID IN NUMBER,
	p_SERVICE_TYPE_CATEGORY IN VARCHAR2,
	p_IS_FIRM IN NUMBER
	);

PROCEDURE GET_SERVICE_TYPE
	(
	p_SERVICE_TYPE_ID IN NUMBER,
	p_SERVICE_TYPE_NAME OUT VARCHAR2,
	p_SERVICE_TYPE_ALIAS OUT VARCHAR2,
	p_SERVICE_TYPE_DESC OUT VARCHAR2,
	p_SERVICE_TYPE_CATEGORY OUT VARCHAR2,
	p_IS_FIRM OUT NUMBER
	);

PROCEDURE PUT_SERVICE_ZONE
	(
	o_OID OUT NUMBER,
	p_SERVICE_ZONE_NAME IN VARCHAR2,
	p_SERVICE_ZONE_ALIAS IN VARCHAR2,
	p_SERVICE_ZONE_DESC IN VARCHAR2,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_MARKET_PRICE_ID IN NUMBER,
	p_CONTROL_AREA_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR2
	);

PROCEDURE GET_SERVICE_ZONE
	(
	p_SERVICE_ZONE_ID IN NUMBER,
	p_SERVICE_ZONE_NAME OUT VARCHAR2,
	p_SERVICE_ZONE_ALIAS OUT VARCHAR2,
	p_SERVICE_ZONE_DESC OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_MARKET_PRICE_ID OUT NUMBER,
	p_CONTROL_AREA_ID OUT NUMBER,
	p_TIME_ZONE OUT VARCHAR2
	);

PROCEDURE PUT_SETTLEMENT_TYPE
	(
	o_OID OUT NUMBER,
	p_SETTLEMENT_TYPE_NAME IN VARCHAR2,
	p_SETTLEMENT_TYPE_ALIAS IN VARCHAR2,
	p_SETTLEMENT_TYPE_DESC IN VARCHAR2,
	p_SETTLEMENT_TYPE_ID IN NUMBER,
	p_SETTLEMENT_TYPE_ORDER IN VARCHAR2,
	p_SERVICE_CODE IN VARCHAR2,
	p_SCENARIO_ID IN NUMBER,
	p_STATEMENT_TYPE_ID IN NUMBER
	);

PROCEDURE GET_SETTLEMENT_TYPE
	(
	p_SETTLEMENT_TYPE_ID IN NUMBER,
	p_SETTLEMENT_TYPE_NAME OUT VARCHAR2,
	p_SETTLEMENT_TYPE_ALIAS OUT VARCHAR2,
	p_SETTLEMENT_TYPE_DESC OUT VARCHAR2,
	p_SETTLEMENT_TYPE_ORDER OUT VARCHAR2,
	p_SERVICE_CODE OUT VARCHAR2,
	p_SCENARIO_ID OUT NUMBER,
	p_STATEMENT_TYPE_ID OUT NUMBER
	);

PROCEDURE PUT_STATEMENT_TYPE
	(
	o_OID OUT NUMBER,
	p_STATEMENT_TYPE_NAME IN VARCHAR2,
	p_STATEMENT_TYPE_ALIAS IN VARCHAR2,
	p_STATEMENT_TYPE_DESC IN VARCHAR2,
	p_STATEMENT_TYPE_ID IN NUMBER,
	p_STATEMENT_TYPE_ORDER IN NUMBER
	);

PROCEDURE GET_STATEMENT_TYPE
	(
	p_STATEMENT_TYPE_ID IN NUMBER,
	p_STATEMENT_TYPE_NAME OUT VARCHAR2,
	p_STATEMENT_TYPE_ALIAS OUT VARCHAR2,
	p_STATEMENT_TYPE_DESC OUT VARCHAR2,
	p_STATEMENT_TYPE_ORDER OUT NUMBER
	);

PROCEDURE PUT_SUB_STATION
	(
	o_OID OUT NUMBER,
	p_SUB_STATION_NAME IN VARCHAR2,
	p_SUB_STATION_ALIAS IN VARCHAR2,
	p_SUB_STATION_DESC IN VARCHAR2,
	p_SUB_STATION_ID IN NUMBER,
	p_SUB_STATION_TYPE IN VARCHAR2,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SERVICE_ZONE_ID IN NUMBER
	);

PROCEDURE GET_SUB_STATION
	(
	p_SUB_STATION_ID IN NUMBER,
	p_SUB_STATION_NAME OUT VARCHAR2,
	p_SUB_STATION_ALIAS OUT VARCHAR2,
	p_SUB_STATION_DESC OUT VARCHAR2,
	p_SUB_STATION_TYPE OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE,
	p_SERVICE_ZONE_ID OUT NUMBER
	);

PROCEDURE PUT_SUB_STATION_METER
	(
	o_OID OUT NUMBER,
	p_METER_NAME IN VARCHAR2,
	p_METER_ALIAS IN VARCHAR2,
	p_METER_DESC IN VARCHAR2,
	p_METER_ID IN NUMBER,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_METER_TYPE IN VARCHAR2,
	p_METER_SUB_TYPE IN VARCHAR2,
	p_METER_CATEGORY IN VARCHAR2,
	p_REF_METER_ID IN NUMBER,
	p_SUB_STATION_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_TRUNCATE_CARRY_FWD IN NUMBER,
	p_QUALITY_RATING IN VARCHAR2
	);

PROCEDURE GET_SUB_STATION_METER
	(
	p_METER_ID IN NUMBER,
	p_METER_NAME OUT VARCHAR2,
	p_METER_ALIAS OUT VARCHAR2,
	p_METER_DESC OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE,
	p_METER_TYPE OUT VARCHAR2,
	p_METER_SUB_TYPE OUT VARCHAR2,
	p_METER_CATEGORY OUT VARCHAR2,
	p_REF_METER_ID OUT NUMBER,
	p_SUB_STATION_ID OUT NUMBER,
	p_SERVICE_POINT_ID OUT NUMBER,
	p_TRUNCATE_CARRY_FWD OUT NUMBER,
	p_QUALITY_RATING OUT VARCHAR2
	);

PROCEDURE PUT_SUB_STATION_METER_POINT
	(
	o_OID OUT NUMBER,
	p_METER_POINT_NAME IN VARCHAR2,
	p_METER_POINT_ALIAS IN VARCHAR2,
	p_METER_POINT_DESC IN VARCHAR2,
	p_METER_POINT_ID IN NUMBER,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_METER_POINT_CATEGORY IN VARCHAR2,
	p_RETAIL_METER_ID IN NUMBER,
	p_SUB_STATION_METER_ID IN NUMBER,
	p_METER_POINT_INTERVAL IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_UOM IN VARCHAR2,
	p_OPERATION_CODE IN VARCHAR2,
	p_DIRECTION IN VARCHAR2,
	p_TOLERANCE IN NUMBER
	);

PROCEDURE GET_SUB_STATION_METER_POINT
	(
	p_METER_POINT_ID IN NUMBER,
	p_METER_POINT_NAME OUT VARCHAR2,
	p_METER_POINT_ALIAS OUT VARCHAR2,
	p_METER_POINT_DESC OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_METER_POINT_CATEGORY OUT VARCHAR2,
	p_RETAIL_METER_ID OUT NUMBER,
	p_SUB_STATION_METER_ID OUT NUMBER,
	p_METER_POINT_INTERVAL OUT VARCHAR2,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE,
	p_UOM OUT VARCHAR2,
	p_OPERATION_CODE OUT VARCHAR2,
	p_DIRECTION OUT VARCHAR2,
	p_TOLERANCE OUT NUMBER
	);

PROCEDURE PUT_SUPPLY_RESOURCE
	(
	o_OID OUT NUMBER,
	p_RESOURCE_NAME IN VARCHAR2,
	p_RESOURCE_ALIAS IN VARCHAR2,
	p_RESOURCE_DESC IN VARCHAR2,
	p_RESOURCE_ID IN NUMBER,
	p_RESOURCE_GROUP_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_HEAT_RATE_CURVE_ID IN NUMBER
	);

PROCEDURE GET_SUPPLY_RESOURCE
	(
	p_RESOURCE_ID IN NUMBER,
	p_RESOURCE_NAME OUT VARCHAR2,
	p_RESOURCE_ALIAS OUT VARCHAR2,
	p_RESOURCE_DESC OUT VARCHAR2,
	p_RESOURCE_GROUP_ID OUT NUMBER,
	p_SERVICE_POINT_ID OUT NUMBER,
	p_HEAT_RATE_CURVE_ID OUT NUMBER
	);

PROCEDURE PUT_SYSTEM_ACTION
	(
	o_OID OUT NUMBER,
	p_ACTION_NAME IN VARCHAR2,
	p_ACTION_ALIAS IN VARCHAR2,
	p_ACTION_DESC IN VARCHAR2,
	p_ACTION_ID IN NUMBER,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_MODULE IN VARCHAR2,
	p_ACTION_TYPE IN VARCHAR2
	);

PROCEDURE GET_SYSTEM_ACTION
	(
	p_ACTION_ID IN NUMBER,
	p_ACTION_NAME OUT VARCHAR2,
	p_ACTION_ALIAS OUT VARCHAR2,
	p_ACTION_DESC OUT VARCHAR2,
	p_ENTITY_DOMAIN_ID OUT NUMBER,
	p_MODULE OUT VARCHAR2,
	p_ACTION_TYPE OUT VARCHAR2
	);

PROCEDURE PUT_SYSTEM_ALERT
	(
	o_OID OUT NUMBER,
	p_ALERT_NAME IN VARCHAR2,
	p_ALERT_ALIAS IN VARCHAR2,
	p_ALERT_DESC IN VARCHAR2,
	p_ALERT_ID IN NUMBER,
	p_ALERT_TYPE IN VARCHAR2,
	p_ALERT_CATEGORY IN VARCHAR2,
	p_ALERT_DURATION IN NUMBER,
	p_IS_EMAIL_ALERT IN NUMBER,
	p_IS_EMAIL_FIRST_ACK IN NUMBER,
	p_ALERT_EMAIL_PRIORITY IN NUMBER,
	p_ALERT_EMAIL_SUBJECT IN VARCHAR2,
	p_ACK_EMAIL_PRIORITY IN NUMBER,
	p_ACK_EMAIL_SUBJECT IN VARCHAR2
	);

PROCEDURE GET_SYSTEM_ALERT
	(
	p_ALERT_ID IN NUMBER,
	p_ALERT_NAME OUT VARCHAR2,
	p_ALERT_ALIAS OUT VARCHAR2,
	p_ALERT_DESC OUT VARCHAR2,
	p_ALERT_TYPE OUT VARCHAR2,
	p_ALERT_CATEGORY OUT VARCHAR2,
	p_ALERT_DURATION OUT NUMBER,
	p_IS_EMAIL_ALERT OUT NUMBER,
	p_IS_EMAIL_FIRST_ACK OUT NUMBER,
	p_ALERT_EMAIL_PRIORITY OUT NUMBER,
	p_ALERT_EMAIL_SUBJECT OUT VARCHAR2,
	p_ACK_EMAIL_PRIORITY OUT NUMBER,
	p_ACK_EMAIL_SUBJECT OUT VARCHAR2
	);

PROCEDURE PUT_SYSTEM_EVENT
	(
	o_OID OUT NUMBER,
	p_EVENT_NAME IN VARCHAR2,
	p_EVENT_ALIAS IN VARCHAR2,
	p_EVENT_DESC IN VARCHAR2,
	p_EVENT_ID IN NUMBER,
	p_EVENT_TYPE IN VARCHAR2,
	p_EVENT_CATEGORY IN VARCHAR2
	);

PROCEDURE GET_SYSTEM_EVENT
	(
	p_EVENT_ID IN NUMBER,
	p_EVENT_NAME OUT VARCHAR2,
	p_EVENT_ALIAS OUT VARCHAR2,
	p_EVENT_DESC OUT VARCHAR2,
	p_EVENT_TYPE OUT VARCHAR2,
	p_EVENT_CATEGORY OUT VARCHAR2
	);

PROCEDURE PUT_SYSTEM_LOAD
	(
	o_OID OUT NUMBER,
	p_SYSTEM_LOAD_NAME IN VARCHAR2,
	p_SYSTEM_LOAD_ALIAS IN VARCHAR2,
	p_SYSTEM_LOAD_DESC IN VARCHAR2,
	p_SYSTEM_LOAD_ID IN NUMBER,
	p_SYSTEM_LOAD_INTERVAL IN VARCHAR2
	);

PROCEDURE GET_SYSTEM_LOAD
	(
	p_SYSTEM_LOAD_ID IN NUMBER,
	p_SYSTEM_LOAD_NAME OUT VARCHAR2,
	p_SYSTEM_LOAD_ALIAS OUT VARCHAR2,
	p_SYSTEM_LOAD_DESC OUT VARCHAR2,
	p_SYSTEM_LOAD_INTERVAL OUT VARCHAR2
	);

PROCEDURE PUT_SYSTEM_REALM
	(
	o_OID OUT NUMBER,
	p_REALM_NAME IN VARCHAR2,
	p_REALM_ALIAS IN VARCHAR2,
	p_REALM_DESC IN VARCHAR2,
	p_REALM_ID IN NUMBER,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_REALM_CALC_TYPE IN NUMBER,
	p_CUSTOM_QUERY IN VARCHAR2
	);

PROCEDURE GET_SYSTEM_REALM
	(
	p_REALM_ID IN NUMBER,
	p_REALM_NAME OUT VARCHAR2,
	p_REALM_ALIAS OUT VARCHAR2,
	p_REALM_DESC OUT VARCHAR2,
	p_ENTITY_DOMAIN_ID OUT NUMBER,
	p_REALM_CALC_TYPE OUT NUMBER,
	p_CUSTOM_QUERY OUT VARCHAR2
	);

PROCEDURE PUT_SYSTEM_TABLE
	(
	o_OID OUT NUMBER,
	p_TABLE_NAME IN VARCHAR2,
	p_TABLE_ALIAS IN VARCHAR2,
	p_TABLE_DESC IN VARCHAR2,
	p_TABLE_ID IN NUMBER,
	p_DB_TABLE_NAME IN VARCHAR2,
	p_MIRROR_TABLE_NAME IN VARCHAR2,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_KEY_CONSTRAINT_NAME IN VARCHAR2,
	p_ENTITY_ID_COLUMN_NAME IN VARCHAR2,
	p_DATE1_COLUMN_NAME IN VARCHAR2,
	p_DATE2_COLUMN_NAME IN VARCHAR2,
	p_IS_REACTIVE IN NUMBER,
	p_LOCK_SUMMARY_TABLE_NAME IN VARCHAR2
	);

PROCEDURE GET_SYSTEM_TABLE
	(
	p_TABLE_ID IN NUMBER,
	p_TABLE_NAME OUT VARCHAR2,
	p_TABLE_ALIAS OUT VARCHAR2,
	p_TABLE_DESC OUT VARCHAR2,
	p_DB_TABLE_NAME OUT VARCHAR2,
	p_MIRROR_TABLE_NAME OUT VARCHAR2,
	p_ENTITY_DOMAIN_ID OUT NUMBER,
	p_KEY_CONSTRAINT_NAME OUT VARCHAR2,
	p_ENTITY_ID_COLUMN_NAME OUT VARCHAR2,
	p_DATE1_COLUMN_NAME OUT VARCHAR2,
	p_DATE2_COLUMN_NAME OUT VARCHAR2,
	p_IS_REACTIVE OUT NUMBER,
	p_LOCK_SUMMARY_TABLE_NAME OUT VARCHAR2
	);

PROCEDURE PUT_TEMPLATE
	(
	o_OID OUT NUMBER,
	p_TEMPLATE_NAME IN VARCHAR2,
	p_TEMPLATE_ALIAS IN VARCHAR2,
	p_TEMPLATE_DESC IN VARCHAR2,
	p_TEMPLATE_ID IN NUMBER,
	p_IS_DAY_TYPE IN NUMBER,
	p_IS_DST_OBSERVANT IN NUMBER,
	p_VALIDATION_MESSAGE IN VARCHAR2
	);

PROCEDURE GET_TEMPLATE
	(
	p_TEMPLATE_ID IN NUMBER,
	p_TEMPLATE_NAME OUT VARCHAR2,
	p_TEMPLATE_ALIAS OUT VARCHAR2,
	p_TEMPLATE_DESC OUT VARCHAR2,
	p_IS_DAY_TYPE OUT NUMBER,
	p_IS_DST_OBSERVANT OUT NUMBER,
	p_VALIDATION_MESSAGE OUT VARCHAR2
	);

PROCEDURE PUT_TP
	(
	o_OID OUT NUMBER,
	p_TP_NAME IN VARCHAR2,
	p_TP_ALIAS IN VARCHAR2,
	p_TP_DESC IN VARCHAR2,
	p_TP_ID IN NUMBER,
	p_TP_NERC_CODE IN VARCHAR2,
	p_TP_STATUS IN VARCHAR2,
	p_TP_DUNS_NUMBER IN VARCHAR2,
	p_OASIS_NODE_ID IN NUMBER
	);

PROCEDURE GET_TP
	(
	p_TP_ID IN NUMBER,
	p_TP_NAME OUT VARCHAR2,
	p_TP_ALIAS OUT VARCHAR2,
	p_TP_DESC OUT VARCHAR2,
	p_TP_NERC_CODE OUT VARCHAR2,
	p_TP_STATUS OUT VARCHAR2,
	p_TP_DUNS_NUMBER OUT VARCHAR2,
	p_OASIS_NODE_ID OUT NUMBER
	);

PROCEDURE PUT_TRANSACTION
	(
	o_OID OUT NUMBER,
	p_TRANSACTION_NAME IN VARCHAR2,
	p_TRANSACTION_ALIAS IN VARCHAR2,
	p_TRANSACTION_DESC IN VARCHAR2,
	p_TRANSACTION_ID IN NUMBER,
	p_TRANSACTION_TYPE IN VARCHAR2,
	p_TRANSACTION_CODE IN VARCHAR2,
	p_TRANSACTION_IDENTIFIER IN VARCHAR2,
	p_IS_FIRM IN NUMBER,
	p_IS_IMPORT_SCHEDULE IN NUMBER,
	p_IS_EXPORT_SCHEDULE IN NUMBER,
	p_IS_BALANCE_TRANSACTION IN NUMBER,
	p_IS_BID_OFFER IN NUMBER,
	p_IS_EXCLUDE_FROM_POSITION IN NUMBER,
	p_IS_IMPORT_EXPORT IN NUMBER,
	p_IS_DISPATCHABLE IN NUMBER,
	p_TRANSACTION_INTERVAL IN VARCHAR2,
	p_EXTERNAL_INTERVAL IN VARCHAR2,
	p_ETAG_CODE IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PURCHASER_ID IN NUMBER,
	p_SELLER_ID IN NUMBER,
	p_CONTRACT_ID IN NUMBER,
	p_SC_ID IN NUMBER,
	p_POR_ID IN NUMBER,
	p_POD_ID IN NUMBER,
	p_COMMODITY_ID IN NUMBER,
	p_SERVICE_TYPE_ID IN NUMBER,
	p_TX_TRANSACTION_ID IN NUMBER,
	p_PATH_ID IN NUMBER,
	p_LINK_TRANSACTION_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_SCHEDULE_GROUP_ID IN NUMBER,
	p_MARKET_PRICE_ID IN NUMBER,
	p_ZOR_ID IN NUMBER,
	p_ZOD_ID IN NUMBER,
	p_SOURCE_ID IN NUMBER,
	p_SINK_ID IN NUMBER,
	p_RESOURCE_ID IN NUMBER,
	p_AGREEMENT_TYPE IN VARCHAR2,
	p_APPROVAL_TYPE IN VARCHAR2,
	p_LOSS_OPTION IN VARCHAR2,
	p_TRAIT_CATEGORY IN VARCHAR2,
	p_TP_ID IN NUMBER
	);

PROCEDURE GET_TRANSACTION
	(
	p_TRANSACTION_ID IN NUMBER,
	p_TRANSACTION_NAME OUT VARCHAR2,
	p_TRANSACTION_ALIAS OUT VARCHAR2,
	p_TRANSACTION_DESC OUT VARCHAR2,
	p_TRANSACTION_TYPE OUT VARCHAR2,
	p_TRANSACTION_CODE OUT VARCHAR2,
	p_TRANSACTION_IDENTIFIER OUT VARCHAR2,
	p_IS_FIRM OUT NUMBER,
	p_IS_IMPORT_SCHEDULE OUT NUMBER,
	p_IS_EXPORT_SCHEDULE OUT NUMBER,
	p_IS_BALANCE_TRANSACTION OUT NUMBER,
	p_IS_BID_OFFER OUT NUMBER,
	p_IS_EXCLUDE_FROM_POSITION OUT NUMBER,
	p_IS_IMPORT_EXPORT OUT NUMBER,
	p_IS_DISPATCHABLE OUT NUMBER,
	p_TRANSACTION_INTERVAL OUT VARCHAR2,
	p_EXTERNAL_INTERVAL OUT VARCHAR2,
	p_ETAG_CODE OUT VARCHAR2,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE,
	p_PURCHASER_ID OUT NUMBER,
	p_SELLER_ID OUT NUMBER,
	p_CONTRACT_ID OUT NUMBER,
	p_SC_ID OUT NUMBER,
	p_POR_ID OUT NUMBER,
	p_POD_ID OUT NUMBER,
	p_COMMODITY_ID OUT NUMBER,
	p_SERVICE_TYPE_ID OUT NUMBER,
	p_TX_TRANSACTION_ID OUT NUMBER,
	p_PATH_ID OUT NUMBER,
	p_LINK_TRANSACTION_ID OUT NUMBER,
	p_EDC_ID OUT NUMBER,
	p_PSE_ID OUT NUMBER,
	p_ESP_ID OUT NUMBER,
	p_POOL_ID OUT NUMBER,
	p_SCHEDULE_GROUP_ID OUT NUMBER,
	p_MARKET_PRICE_ID OUT NUMBER,
	p_ZOR_ID OUT NUMBER,
	p_ZOD_ID OUT NUMBER,
	p_SOURCE_ID OUT NUMBER,
	p_SINK_ID OUT NUMBER,
	p_RESOURCE_ID OUT NUMBER,
	p_AGREEMENT_TYPE OUT VARCHAR2,
	p_APPROVAL_TYPE OUT VARCHAR2,
	p_LOSS_OPTION OUT VARCHAR2,
	p_TRAIT_CATEGORY OUT VARCHAR2,
	p_TP_ID OUT NUMBER
	);

PROCEDURE PUT_TRANSACTION_TRAIT_GROUP
	(
	o_OID OUT NUMBER,
	p_TRAIT_GROUP_NAME IN VARCHAR2,
	p_TRAIT_GROUP_ALIAS IN VARCHAR2,
	p_TRAIT_GROUP_DESC IN VARCHAR2,
	p_TRAIT_GROUP_ID IN NUMBER,
	p_TRAIT_GROUP_INTERVAL IN VARCHAR2,
	p_TRAIT_GROUP_TYPE IN VARCHAR2,
	p_SC_ID IN NUMBER,
	p_TRAIT_CATEGORY IN VARCHAR2,
	p_DISPLAY_NAME IN VARCHAR2,
	p_DISPLAY_ORDER IN NUMBER,
	p_IS_SERIES IN NUMBER,
	p_IS_SPARSE IN NUMBER,
	p_IS_STATEMENT_TYPE_SPECIFIC IN NUMBER,
	p_DEFAULT_NUMBER_OF_SETS IN NUMBER
	);

PROCEDURE GET_TRANSACTION_TRAIT_GROUP
	(
	p_TRAIT_GROUP_ID IN NUMBER,
	p_TRAIT_GROUP_NAME OUT VARCHAR2,
	p_TRAIT_GROUP_ALIAS OUT VARCHAR2,
	p_TRAIT_GROUP_DESC OUT VARCHAR2,
	p_TRAIT_GROUP_INTERVAL OUT VARCHAR2,
	p_TRAIT_GROUP_TYPE OUT VARCHAR2,
	p_SC_ID OUT NUMBER,
	p_TRAIT_CATEGORY OUT VARCHAR2,
	p_DISPLAY_NAME OUT VARCHAR2,
	p_DISPLAY_ORDER OUT NUMBER,
	p_IS_SERIES OUT NUMBER,
	p_IS_SPARSE OUT NUMBER,
	p_IS_STATEMENT_TYPE_SPECIFIC OUT NUMBER,
	p_DEFAULT_NUMBER_OF_SETS OUT NUMBER
	);

PROCEDURE PUT_TX_FEEDER
	(
	o_OID OUT NUMBER,
	p_FEEDER_NAME IN VARCHAR2,
	p_FEEDER_ALIAS IN VARCHAR2,
	p_FEEDER_DESC IN VARCHAR2,
	p_FEEDER_ID IN NUMBER,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_SUB_STATION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	);

PROCEDURE GET_TX_FEEDER
	(
	p_FEEDER_ID IN NUMBER,
	p_FEEDER_NAME OUT VARCHAR2,
	p_FEEDER_ALIAS OUT VARCHAR2,
	p_FEEDER_DESC OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_SUB_STATION_ID OUT NUMBER,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE
	);

PROCEDURE PUT_TX_FEEDER_SEGMENT
	(
	o_OID OUT NUMBER,
	p_FEEDER_SEGMENT_NAME IN VARCHAR2,
	p_FEEDER_SEGMENT_ALIAS IN VARCHAR2,
	p_FEEDER_SEGMENT_DESC IN VARCHAR2,
	p_FEEDER_SEGMENT_ID IN NUMBER,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_FEEDER_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PRIORITY IN NUMBER
	);

PROCEDURE GET_TX_FEEDER_SEGMENT
	(
	p_FEEDER_SEGMENT_ID IN NUMBER,
	p_FEEDER_SEGMENT_NAME OUT VARCHAR2,
	p_FEEDER_SEGMENT_ALIAS OUT VARCHAR2,
	p_FEEDER_SEGMENT_DESC OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_FEEDER_ID OUT NUMBER,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE,
	p_PRIORITY OUT NUMBER
	);

PROCEDURE PUT_USAGE_WRF
	(
	o_OID OUT NUMBER,
	p_WRF_NAME IN VARCHAR2,
	p_WRF_ALIAS IN VARCHAR2,
	p_WRF_DESC IN VARCHAR2,
	p_WRF_ID IN NUMBER,
	p_STATION_ID IN NUMBER,
	p_PARAMETER_ID IN NUMBER
	);

PROCEDURE GET_USAGE_WRF
	(
	p_WRF_ID IN NUMBER,
	p_WRF_NAME OUT VARCHAR2,
	p_WRF_ALIAS OUT VARCHAR2,
	p_WRF_DESC OUT VARCHAR2,
	p_STATION_ID OUT NUMBER,
	p_PARAMETER_ID OUT NUMBER
	);

PROCEDURE PUT_VPP
	(
	o_OID OUT NUMBER,
	p_VPP_NAME IN VARCHAR2,
	p_VPP_ALIAS IN VARCHAR2,
	p_VPP_DESC IN VARCHAR2,
	p_VPP_ID IN NUMBER,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_STATUS_NAME IN VARCHAR2,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_PROGRAM_ID IN NUMBER
	);

PROCEDURE GET_VPP
	(
	p_VPP_ID IN NUMBER,
	p_VPP_NAME OUT VARCHAR2,
	p_VPP_ALIAS OUT VARCHAR2,
	p_VPP_DESC OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_STATUS_NAME OUT VARCHAR2,
	p_SERVICE_ZONE_ID OUT NUMBER,
	p_PROGRAM_ID OUT NUMBER
	);

PROCEDURE PUT_WEATHER_PARAMETER
	(
	o_OID OUT NUMBER,
	p_PARAMETER_NAME IN VARCHAR2,
	p_PARAMETER_ALIAS IN VARCHAR2,
	p_PARAMETER_DESC IN VARCHAR2,
	p_PARAMETER_ID IN NUMBER,
	p_PARAMETER_CATEGORY IN VARCHAR2,
	p_PARAMETER_INTERVAL IN VARCHAR2,
	p_PARAMETER_MEASUREMENT IN VARCHAR2,
	p_PROJECTION_PERIOD IN VARCHAR2,
	p_IS_COMPOSITE IN NUMBER,
	p_IS_CALCULATE IN NUMBER
	);

PROCEDURE GET_WEATHER_PARAMETER
	(
	p_PARAMETER_ID IN NUMBER,
	p_PARAMETER_NAME OUT VARCHAR2,
	p_PARAMETER_ALIAS OUT VARCHAR2,
	p_PARAMETER_DESC OUT VARCHAR2,
	p_PARAMETER_CATEGORY OUT VARCHAR2,
	p_PARAMETER_INTERVAL OUT VARCHAR2,
	p_PARAMETER_MEASUREMENT OUT VARCHAR2,
	p_PROJECTION_PERIOD OUT VARCHAR2,
	p_IS_COMPOSITE OUT NUMBER,
	p_IS_CALCULATE OUT NUMBER
	);

PROCEDURE PUT_WEATHER_STATION
	(
	o_OID OUT NUMBER,
	p_STATION_NAME IN VARCHAR2,
	p_STATION_ALIAS IN VARCHAR2,
	p_STATION_DESC IN VARCHAR2,
	p_STATION_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_IS_COMPOSITE IN NUMBER
	);

PROCEDURE GET_WEATHER_STATION
	(
	p_STATION_ID IN NUMBER,
	p_STATION_NAME OUT VARCHAR2,
	p_STATION_ALIAS OUT VARCHAR2,
	p_STATION_DESC OUT VARCHAR2,
	p_TIME_ZONE OUT VARCHAR2,
	p_IS_COMPOSITE OUT NUMBER
	);


END IO;
/

CREATE OR REPLACE PACKAGE BODY IO AS
---------------------------------------------------------------------
g_EMPTY_VARCHAR2 CONSTANT VARCHAR2(1) := ' ';
g_EMPTY_NUMBER CONSTANT NUMBER(1) := 0;
g_EMPTY_DATE DATE;
---------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
    RETURN '$Revision: 1.122 $';
END WHAT_VERSION;
---------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT
	(
	o_OID OUT NUMBER,
	p_ACCOUNT_NAME IN VARCHAR2,
	p_ACCOUNT_ALIAS IN VARCHAR2,
	p_ACCOUNT_DESC IN VARCHAR2,
	p_ACCOUNT_ID IN NUMBER,
	p_ACCOUNT_DUNS_NUMBER IN VARCHAR2,
	p_ACCOUNT_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_ACCOUNT_MODEL_OPTION IN VARCHAR2,
	p_ACCOUNT_SIC_CODE IN VARCHAR2,
	p_ACCOUNT_METER_TYPE IN VARCHAR2,
	p_ACCOUNT_METER_EXT_IDENTIFIER IN VARCHAR2,
	p_ACCOUNT_DISPLAY_NAME IN VARCHAR2,
	p_ACCOUNT_BILL_OPTION IN VARCHAR2,
	p_ACCOUNT_ROLLUP_ID IN NUMBER,
	p_IS_EXTERNAL_INTERVAL_USAGE IN NUMBER,
	p_IS_EXTERNAL_BILLED_USAGE IN NUMBER,
	p_IS_AGGREGATE_ACCOUNT IN NUMBER,
	p_IS_UFE_PARTICIPANT IN NUMBER,
	p_IS_CREATE_SETTLEMENT_PROFILE IN NUMBER,
	p_IS_EXTERNAL_FORECAST IN NUMBER,
	p_IS_SUB_AGGREGATE IN NUMBER,
	p_TX_SERVICE_TYPE_ID IN NUMBER,
	p_USE_TOU_USAGE_FACTOR IN NUMBER,
	p_MODEL_ID IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC ACCOUNT%ROWTYPE;
BEGIN

	IF GA.ENFORCE_UNIQUE_NAMES THEN

		SELECT COUNT(*)
		INTO v_COUNT
		FROM ACCOUNT
		WHERE ACCOUNT_NAME = TRIM(p_ACCOUNT_NAME)
			AND (p_ACCOUNT_ID = 0 OR ACCOUNT_ID <> p_ACCOUNT_ID);

		IF v_COUNT > 0 THEN
            -- raise exception that indicates the duplicate entity name
            ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_ACCOUNT, EC.ED_ENTITY_DOMAIN)||': '||p_ACCOUNT_NAME);
		END IF;
	
	END IF;


	v_REC.ACCOUNT_ID := p_ACCOUNT_ID;
	v_REC.ACCOUNT_NAME := TRIM(p_ACCOUNT_NAME);
	v_REC.ACCOUNT_ALIAS := TRIM(NVL(p_ACCOUNT_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ACCOUNT_DESC := TRIM(NVL(p_ACCOUNT_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ACCOUNT_DUNS_NUMBER := TRIM(NVL(p_ACCOUNT_DUNS_NUMBER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ACCOUNT_EXTERNAL_IDENTIFIER := TRIM(NVL(p_ACCOUNT_EXTERNAL_IDENTIFIER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ACCOUNT_MODEL_OPTION := TRIM(NVL(p_ACCOUNT_MODEL_OPTION,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ACCOUNT_SIC_CODE := TRIM(NVL(p_ACCOUNT_SIC_CODE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ACCOUNT_METER_TYPE := TRIM(NVL(p_ACCOUNT_METER_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ACCOUNT_METER_EXT_IDENTIFIER := TRIM(NVL(p_ACCOUNT_METER_EXT_IDENTIFIER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ACCOUNT_DISPLAY_NAME := TRIM(NVL(p_ACCOUNT_DISPLAY_NAME,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ACCOUNT_BILL_OPTION := TRIM(NVL(p_ACCOUNT_BILL_OPTION,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ACCOUNT_ROLLUP_ID := p_ACCOUNT_ROLLUP_ID;
	v_REC.IS_EXTERNAL_INTERVAL_USAGE := p_IS_EXTERNAL_INTERVAL_USAGE;
	v_REC.IS_EXTERNAL_BILLED_USAGE := p_IS_EXTERNAL_BILLED_USAGE;
	v_REC.IS_AGGREGATE_ACCOUNT := p_IS_AGGREGATE_ACCOUNT;
	v_REC.IS_UFE_PARTICIPANT := p_IS_UFE_PARTICIPANT;
	v_REC.IS_CREATE_SETTLEMENT_PROFILE := p_IS_CREATE_SETTLEMENT_PROFILE;
	v_REC.IS_EXTERNAL_FORECAST := p_IS_EXTERNAL_FORECAST;
	v_REC.IS_SUB_AGGREGATE := p_IS_SUB_AGGREGATE;
	v_REC.TX_SERVICE_TYPE_ID := NVL(p_TX_SERVICE_TYPE_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.USE_TOU_USAGE_FACTOR := p_USE_TOU_USAGE_FACTOR;
	v_REC.MODEL_ID := p_MODEL_ID;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_ACCOUNT_ID > 0 OR p_ACCOUNT_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT) 
                 AND IO_UTIL.ACCOUNT_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_ACCOUNT, p_ACCOUNT_ID);
		END IF;

		-- save it!
		UPDATE ACCOUNT
		SET ROW = v_REC
		WHERE ACCOUNT_ID = p_ACCOUNT_ID;
		o_OID := p_ACCOUNT_ID;
        
	ELSIF p_ACCOUNT_ID IS NULL OR p_ACCOUNT_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.ACCOUNT_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_ACCOUNT, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.ACCOUNT_ID := o_OID;
		-- save it!
		INSERT INTO ACCOUNT VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_ACCOUNT_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_ACCOUNT, EC.ED_ENTITY_DOMAIN)||': '||p_ACCOUNT_NAME);
END PUT_ACCOUNT;
---------------------------------------------------------------------
PROCEDURE GET_ACCOUNT
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ACCOUNT_NAME OUT VARCHAR2,
	p_ACCOUNT_ALIAS OUT VARCHAR2,
	p_ACCOUNT_DESC OUT VARCHAR2,
	p_ACCOUNT_DUNS_NUMBER OUT VARCHAR2,
	p_ACCOUNT_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_ACCOUNT_MODEL_OPTION OUT VARCHAR2,
	p_ACCOUNT_SIC_CODE OUT VARCHAR2,
	p_ACCOUNT_METER_TYPE OUT VARCHAR2,
	p_ACCOUNT_METER_EXT_IDENTIFIER OUT VARCHAR2,
	p_ACCOUNT_DISPLAY_NAME OUT VARCHAR2,
	p_ACCOUNT_BILL_OPTION OUT VARCHAR2,
	p_ACCOUNT_ROLLUP_ID OUT NUMBER,
	p_IS_EXTERNAL_INTERVAL_USAGE OUT NUMBER,
	p_IS_EXTERNAL_BILLED_USAGE OUT NUMBER,
	p_IS_AGGREGATE_ACCOUNT OUT NUMBER,
	p_IS_UFE_PARTICIPANT OUT NUMBER,
	p_IS_CREATE_SETTLEMENT_PROFILE OUT NUMBER,
	p_IS_EXTERNAL_FORECAST OUT NUMBER,
	p_IS_SUB_AGGREGATE OUT NUMBER,
	p_TX_SERVICE_TYPE_ID OUT NUMBER,
	p_USE_TOU_USAGE_FACTOR OUT NUMBER,
	p_MODEL_ID OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD ACCOUNT%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM ACCOUNT
	WHERE ACCOUNT_ID = p_ACCOUNT_ID;
    
	-- Set the output parameters
	p_ACCOUNT_NAME := v_RECORD.ACCOUNT_NAME;
	p_ACCOUNT_ALIAS := v_RECORD.ACCOUNT_ALIAS;
	p_ACCOUNT_DESC := v_RECORD.ACCOUNT_DESC;
	p_ACCOUNT_DUNS_NUMBER := v_RECORD.ACCOUNT_DUNS_NUMBER;
	p_ACCOUNT_EXTERNAL_IDENTIFIER := v_RECORD.ACCOUNT_EXTERNAL_IDENTIFIER;
	p_ACCOUNT_MODEL_OPTION := v_RECORD.ACCOUNT_MODEL_OPTION;
	p_ACCOUNT_SIC_CODE := v_RECORD.ACCOUNT_SIC_CODE;
	p_ACCOUNT_METER_TYPE := v_RECORD.ACCOUNT_METER_TYPE;
	p_ACCOUNT_METER_EXT_IDENTIFIER := v_RECORD.ACCOUNT_METER_EXT_IDENTIFIER;
	p_ACCOUNT_DISPLAY_NAME := v_RECORD.ACCOUNT_DISPLAY_NAME;
	p_ACCOUNT_BILL_OPTION := v_RECORD.ACCOUNT_BILL_OPTION;
	p_ACCOUNT_ROLLUP_ID := v_RECORD.ACCOUNT_ROLLUP_ID;
	p_IS_EXTERNAL_INTERVAL_USAGE := v_RECORD.IS_EXTERNAL_INTERVAL_USAGE;
	p_IS_EXTERNAL_BILLED_USAGE := v_RECORD.IS_EXTERNAL_BILLED_USAGE;
	p_IS_AGGREGATE_ACCOUNT := v_RECORD.IS_AGGREGATE_ACCOUNT;
	p_IS_UFE_PARTICIPANT := v_RECORD.IS_UFE_PARTICIPANT;
	p_IS_CREATE_SETTLEMENT_PROFILE := v_RECORD.IS_CREATE_SETTLEMENT_PROFILE;
	p_IS_EXTERNAL_FORECAST := v_RECORD.IS_EXTERNAL_FORECAST;
	p_IS_SUB_AGGREGATE := v_RECORD.IS_SUB_AGGREGATE;
	p_TX_SERVICE_TYPE_ID := v_RECORD.TX_SERVICE_TYPE_ID;
	p_USE_TOU_USAGE_FACTOR := v_RECORD.USE_TOU_USAGE_FACTOR;
	p_MODEL_ID := v_RECORD.MODEL_ID;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_ACCOUNT_NAME := g_EMPTY_VARCHAR2;
		p_ACCOUNT_ALIAS := g_EMPTY_VARCHAR2;
		p_ACCOUNT_DESC := g_EMPTY_VARCHAR2;
		p_ACCOUNT_DUNS_NUMBER := g_EMPTY_VARCHAR2;
		p_ACCOUNT_EXTERNAL_IDENTIFIER := g_EMPTY_VARCHAR2;
		p_ACCOUNT_MODEL_OPTION := g_EMPTY_VARCHAR2;
		p_ACCOUNT_SIC_CODE := g_EMPTY_VARCHAR2;
		p_ACCOUNT_METER_TYPE := g_EMPTY_VARCHAR2;
		p_ACCOUNT_METER_EXT_IDENTIFIER := g_EMPTY_VARCHAR2;
		p_ACCOUNT_DISPLAY_NAME := g_EMPTY_VARCHAR2;
		p_ACCOUNT_BILL_OPTION := g_EMPTY_VARCHAR2;
		p_ACCOUNT_ROLLUP_ID := g_EMPTY_NUMBER;
		p_IS_EXTERNAL_INTERVAL_USAGE := g_EMPTY_NUMBER;
		p_IS_EXTERNAL_BILLED_USAGE := g_EMPTY_NUMBER;
		p_IS_AGGREGATE_ACCOUNT := g_EMPTY_NUMBER;
		p_IS_UFE_PARTICIPANT := g_EMPTY_NUMBER;
		p_IS_CREATE_SETTLEMENT_PROFILE := g_EMPTY_NUMBER;
		p_IS_EXTERNAL_FORECAST := g_EMPTY_NUMBER;
		p_IS_SUB_AGGREGATE := g_EMPTY_NUMBER;
		p_TX_SERVICE_TYPE_ID := g_EMPTY_NUMBER;
		p_USE_TOU_USAGE_FACTOR := g_EMPTY_NUMBER;
		p_MODEL_ID := g_EMPTY_NUMBER;

END GET_ACCOUNT;
---------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_GROUP
	(
	o_OID OUT NUMBER,
	p_ACCOUNT_GROUP_NAME IN VARCHAR2,
	p_ACCOUNT_GROUP_ALIAS IN VARCHAR2,
	p_ACCOUNT_GROUP_DESC IN VARCHAR2,
	p_ACCOUNT_GROUP_ID IN NUMBER,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC ACCOUNT_GROUP%ROWTYPE;
BEGIN


	v_REC.ACCOUNT_GROUP_ID := p_ACCOUNT_GROUP_ID;
	v_REC.ACCOUNT_GROUP_NAME := TRIM(p_ACCOUNT_GROUP_NAME);
	v_REC.ACCOUNT_GROUP_ALIAS := TRIM(NVL(p_ACCOUNT_GROUP_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ACCOUNT_GROUP_DESC := TRIM(NVL(p_ACCOUNT_GROUP_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EXTERNAL_IDENTIFIER := TRIM(NVL(p_EXTERNAL_IDENTIFIER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_ACCOUNT_GROUP_ID > 0 OR p_ACCOUNT_GROUP_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_GROUP_ID, EC.ED_ACCOUNT_GROUP) 
                 AND IO_UTIL.ACCOUNT_GROUP_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_ACCOUNT_GROUP, p_ACCOUNT_GROUP_ID);
		END IF;

		-- save it!
		UPDATE ACCOUNT_GROUP
		SET ROW = v_REC
		WHERE ACCOUNT_GROUP_ID = p_ACCOUNT_GROUP_ID;
		o_OID := p_ACCOUNT_GROUP_ID;
        
	ELSIF p_ACCOUNT_GROUP_ID IS NULL OR p_ACCOUNT_GROUP_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.ACCOUNT_GROUP_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_ACCOUNT_GROUP, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.ACCOUNT_GROUP_ID := o_OID;
		-- save it!
		INSERT INTO ACCOUNT_GROUP VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_ACCOUNT_GROUP_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_ACCOUNT_GROUP, EC.ED_ENTITY_DOMAIN)||': '||p_ACCOUNT_GROUP_NAME);
END PUT_ACCOUNT_GROUP;
---------------------------------------------------------------------
PROCEDURE GET_ACCOUNT_GROUP
	(
	p_ACCOUNT_GROUP_ID IN NUMBER,
	p_ACCOUNT_GROUP_NAME OUT VARCHAR2,
	p_ACCOUNT_GROUP_ALIAS OUT VARCHAR2,
	p_ACCOUNT_GROUP_DESC OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD ACCOUNT_GROUP%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ACCOUNT_GROUP_ID, EC.ED_ACCOUNT_GROUP);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM ACCOUNT_GROUP
	WHERE ACCOUNT_GROUP_ID = p_ACCOUNT_GROUP_ID;
    
	-- Set the output parameters
	p_ACCOUNT_GROUP_NAME := v_RECORD.ACCOUNT_GROUP_NAME;
	p_ACCOUNT_GROUP_ALIAS := v_RECORD.ACCOUNT_GROUP_ALIAS;
	p_ACCOUNT_GROUP_DESC := v_RECORD.ACCOUNT_GROUP_DESC;
	p_EXTERNAL_IDENTIFIER := v_RECORD.EXTERNAL_IDENTIFIER;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_ACCOUNT_GROUP_NAME := g_EMPTY_VARCHAR2;
		p_ACCOUNT_GROUP_ALIAS := g_EMPTY_VARCHAR2;
		p_ACCOUNT_GROUP_DESC := g_EMPTY_VARCHAR2;
		p_EXTERNAL_IDENTIFIER := g_EMPTY_VARCHAR2;

END GET_ACCOUNT_GROUP;
---------------------------------------------------------------------
PROCEDURE PUT_ANCILLARY_SERVICE
	(
	o_OID OUT NUMBER,
	p_ANCILLARY_SERVICE_NAME IN VARCHAR2,
	p_ANCILLARY_SERVICE_ALIAS IN VARCHAR2,
	p_ANCILLARY_SERVICE_DESC IN VARCHAR2,
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_ANCILLARY_SERVICE_TYPE IN VARCHAR2,
	p_PROVIDER_CATEGORY IN VARCHAR2,
	p_PROVIDER_ID IN NUMBER,
	p_TRANSACTION_TYPE IN VARCHAR2,
	p_IT_COMMODITY_ID IN NUMBER,
	p_ROUNDING_PREFERENCE IN VARCHAR2,
	p_MINIMUM_SCHEDULE_AMT IN NUMBER,
	p_ANCILLARY_SERVICE_UNIT IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC ANCILLARY_SERVICE%ROWTYPE;
BEGIN


	v_REC.ANCILLARY_SERVICE_ID := p_ANCILLARY_SERVICE_ID;
	v_REC.ANCILLARY_SERVICE_NAME := TRIM(p_ANCILLARY_SERVICE_NAME);
	v_REC.ANCILLARY_SERVICE_ALIAS := TRIM(NVL(p_ANCILLARY_SERVICE_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ANCILLARY_SERVICE_DESC := TRIM(NVL(p_ANCILLARY_SERVICE_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ANCILLARY_SERVICE_TYPE := TRIM(NVL(p_ANCILLARY_SERVICE_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PROVIDER_CATEGORY := TRIM(NVL(p_PROVIDER_CATEGORY,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PROVIDER_ID := p_PROVIDER_ID;
	v_REC.TRANSACTION_TYPE := TRIM(NVL(p_TRANSACTION_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.IT_COMMODITY_ID := NVL(p_IT_COMMODITY_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.ROUNDING_PREFERENCE := TRIM(NVL(p_ROUNDING_PREFERENCE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.MINIMUM_SCHEDULE_AMT := p_MINIMUM_SCHEDULE_AMT;
	v_REC.ANCILLARY_SERVICE_UNIT := TRIM(NVL(p_ANCILLARY_SERVICE_UNIT,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_ANCILLARY_SERVICE_ID > 0 OR p_ANCILLARY_SERVICE_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ANCILLARY_SERVICE_ID, EC.ED_ANCILLARY_SERVICE) 
                 AND IO_UTIL.ANCILLARY_SERVICE_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_ANCILLARY_SERVICE, p_ANCILLARY_SERVICE_ID);
		END IF;

		-- save it!
		UPDATE ANCILLARY_SERVICE
		SET ROW = v_REC
		WHERE ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID;
		o_OID := p_ANCILLARY_SERVICE_ID;
        
	ELSIF p_ANCILLARY_SERVICE_ID IS NULL OR p_ANCILLARY_SERVICE_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.ANCILLARY_SERVICE_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_ANCILLARY_SERVICE, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.ANCILLARY_SERVICE_ID := o_OID;
		-- save it!
		INSERT INTO ANCILLARY_SERVICE VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_ANCILLARY_SERVICE_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_ANCILLARY_SERVICE, EC.ED_ENTITY_DOMAIN)||': '||p_ANCILLARY_SERVICE_NAME);
END PUT_ANCILLARY_SERVICE;
---------------------------------------------------------------------
PROCEDURE GET_ANCILLARY_SERVICE
	(
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_ANCILLARY_SERVICE_NAME OUT VARCHAR2,
	p_ANCILLARY_SERVICE_ALIAS OUT VARCHAR2,
	p_ANCILLARY_SERVICE_DESC OUT VARCHAR2,
	p_ANCILLARY_SERVICE_TYPE OUT VARCHAR2,
	p_PROVIDER_CATEGORY OUT VARCHAR2,
	p_PROVIDER_ID OUT NUMBER,
	p_TRANSACTION_TYPE OUT VARCHAR2,
	p_IT_COMMODITY_ID OUT NUMBER,
	p_ROUNDING_PREFERENCE OUT VARCHAR2,
	p_MINIMUM_SCHEDULE_AMT OUT NUMBER,
	p_ANCILLARY_SERVICE_UNIT OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD ANCILLARY_SERVICE%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ANCILLARY_SERVICE_ID, EC.ED_ANCILLARY_SERVICE);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM ANCILLARY_SERVICE
	WHERE ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID;
    
	-- Set the output parameters
	p_ANCILLARY_SERVICE_NAME := v_RECORD.ANCILLARY_SERVICE_NAME;
	p_ANCILLARY_SERVICE_ALIAS := v_RECORD.ANCILLARY_SERVICE_ALIAS;
	p_ANCILLARY_SERVICE_DESC := v_RECORD.ANCILLARY_SERVICE_DESC;
	p_ANCILLARY_SERVICE_TYPE := v_RECORD.ANCILLARY_SERVICE_TYPE;
	p_PROVIDER_CATEGORY := v_RECORD.PROVIDER_CATEGORY;
	p_PROVIDER_ID := v_RECORD.PROVIDER_ID;
	p_TRANSACTION_TYPE := v_RECORD.TRANSACTION_TYPE;
	p_IT_COMMODITY_ID := v_RECORD.IT_COMMODITY_ID;
	p_ROUNDING_PREFERENCE := v_RECORD.ROUNDING_PREFERENCE;
	p_MINIMUM_SCHEDULE_AMT := v_RECORD.MINIMUM_SCHEDULE_AMT;
	p_ANCILLARY_SERVICE_UNIT := v_RECORD.ANCILLARY_SERVICE_UNIT;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_ANCILLARY_SERVICE_NAME := g_EMPTY_VARCHAR2;
		p_ANCILLARY_SERVICE_ALIAS := g_EMPTY_VARCHAR2;
		p_ANCILLARY_SERVICE_DESC := g_EMPTY_VARCHAR2;
		p_ANCILLARY_SERVICE_TYPE := g_EMPTY_VARCHAR2;
		p_PROVIDER_CATEGORY := g_EMPTY_VARCHAR2;
		p_PROVIDER_ID := g_EMPTY_NUMBER;
		p_TRANSACTION_TYPE := g_EMPTY_VARCHAR2;
		p_IT_COMMODITY_ID := g_EMPTY_NUMBER;
		p_ROUNDING_PREFERENCE := g_EMPTY_VARCHAR2;
		p_MINIMUM_SCHEDULE_AMT := g_EMPTY_NUMBER;
		p_ANCILLARY_SERVICE_UNIT := g_EMPTY_VARCHAR2;

END GET_ANCILLARY_SERVICE;
---------------------------------------------------------------------
PROCEDURE PUT_AREA
	(
	o_OID OUT NUMBER,
	p_AREA_NAME IN VARCHAR2,
	p_AREA_ALIAS IN VARCHAR2,
	p_AREA_DESC IN VARCHAR2,
	p_AREA_ID IN NUMBER,
	p_AREA_INTERVAL IN VARCHAR2,
	p_PROJECTION_PERIOD IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC AREA%ROWTYPE;
BEGIN


	v_REC.AREA_ID := p_AREA_ID;
	v_REC.AREA_NAME := TRIM(p_AREA_NAME);
	v_REC.AREA_ALIAS := TRIM(NVL(p_AREA_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.AREA_DESC := TRIM(NVL(p_AREA_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.AREA_INTERVAL := TRIM(NVL(p_AREA_INTERVAL,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PROJECTION_PERIOD := TRIM(NVL(p_PROJECTION_PERIOD,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_AREA_ID > 0 OR p_AREA_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_AREA_ID, EC.ED_AREA) 
                 AND IO_UTIL.AREA_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_AREA, p_AREA_ID);
		END IF;

		-- save it!
		UPDATE AREA
		SET ROW = v_REC
		WHERE AREA_ID = p_AREA_ID;
		o_OID := p_AREA_ID;
        
	ELSIF p_AREA_ID IS NULL OR p_AREA_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.AREA_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_AREA, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.AREA_ID := o_OID;
		-- save it!
		INSERT INTO AREA VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_AREA_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_AREA, EC.ED_ENTITY_DOMAIN)||': '||p_AREA_NAME);
END PUT_AREA;
---------------------------------------------------------------------
PROCEDURE GET_AREA
	(
	p_AREA_ID IN NUMBER,
	p_AREA_NAME OUT VARCHAR2,
	p_AREA_ALIAS OUT VARCHAR2,
	p_AREA_DESC OUT VARCHAR2,
	p_AREA_INTERVAL OUT VARCHAR2,
	p_PROJECTION_PERIOD OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD AREA%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_AREA_ID, EC.ED_AREA);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM AREA
	WHERE AREA_ID = p_AREA_ID;
    
	-- Set the output parameters
	p_AREA_NAME := v_RECORD.AREA_NAME;
	p_AREA_ALIAS := v_RECORD.AREA_ALIAS;
	p_AREA_DESC := v_RECORD.AREA_DESC;
	p_AREA_INTERVAL := v_RECORD.AREA_INTERVAL;
	p_PROJECTION_PERIOD := v_RECORD.PROJECTION_PERIOD;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_AREA_NAME := g_EMPTY_VARCHAR2;
		p_AREA_ALIAS := g_EMPTY_VARCHAR2;
		p_AREA_DESC := g_EMPTY_VARCHAR2;
		p_AREA_INTERVAL := g_EMPTY_VARCHAR2;
		p_PROJECTION_PERIOD := g_EMPTY_VARCHAR2;

END GET_AREA;
---------------------------------------------------------------------
PROCEDURE PUT_BILL_CYCLE
	(
	o_OID OUT NUMBER,
	p_BILL_CYCLE_NAME IN VARCHAR2,
	p_BILL_CYCLE_ALIAS IN VARCHAR2,
	p_BILL_CYCLE_DESC IN VARCHAR2,
	p_BILL_CYCLE_ID IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC BILL_CYCLE%ROWTYPE;
BEGIN


	v_REC.BILL_CYCLE_ID := p_BILL_CYCLE_ID;
	v_REC.BILL_CYCLE_NAME := TRIM(p_BILL_CYCLE_NAME);
	v_REC.BILL_CYCLE_ALIAS := TRIM(NVL(p_BILL_CYCLE_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.BILL_CYCLE_DESC := TRIM(NVL(p_BILL_CYCLE_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_BILL_CYCLE_ID > 0 OR p_BILL_CYCLE_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_BILL_CYCLE_ID, EC.ED_BILL_CYCLE) 
                 AND IO_UTIL.BILL_CYCLE_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_BILL_CYCLE, p_BILL_CYCLE_ID);
		END IF;

		-- save it!
		UPDATE BILL_CYCLE
		SET ROW = v_REC
		WHERE BILL_CYCLE_ID = p_BILL_CYCLE_ID;
		o_OID := p_BILL_CYCLE_ID;
        
	ELSIF p_BILL_CYCLE_ID IS NULL OR p_BILL_CYCLE_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.BILL_CYCLE_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_BILL_CYCLE, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.BILL_CYCLE_ID := o_OID;
		-- save it!
		INSERT INTO BILL_CYCLE VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_BILL_CYCLE_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_BILL_CYCLE, EC.ED_ENTITY_DOMAIN)||': '||p_BILL_CYCLE_NAME);
END PUT_BILL_CYCLE;
---------------------------------------------------------------------
PROCEDURE GET_BILL_CYCLE
	(
	p_BILL_CYCLE_ID IN NUMBER,
	p_BILL_CYCLE_NAME OUT VARCHAR2,
	p_BILL_CYCLE_ALIAS OUT VARCHAR2,
	p_BILL_CYCLE_DESC OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD BILL_CYCLE%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_BILL_CYCLE_ID, EC.ED_BILL_CYCLE);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM BILL_CYCLE
	WHERE BILL_CYCLE_ID = p_BILL_CYCLE_ID;
    
	-- Set the output parameters
	p_BILL_CYCLE_NAME := v_RECORD.BILL_CYCLE_NAME;
	p_BILL_CYCLE_ALIAS := v_RECORD.BILL_CYCLE_ALIAS;
	p_BILL_CYCLE_DESC := v_RECORD.BILL_CYCLE_DESC;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_BILL_CYCLE_NAME := g_EMPTY_VARCHAR2;
		p_BILL_CYCLE_ALIAS := g_EMPTY_VARCHAR2;
		p_BILL_CYCLE_DESC := g_EMPTY_VARCHAR2;

END GET_BILL_CYCLE;
---------------------------------------------------------------------
PROCEDURE PUT_BILL_PARTY
	(
	o_OID OUT NUMBER,
	p_BILL_PARTY_NAME IN VARCHAR2,
	p_BILL_PARTY_ALIAS IN VARCHAR2,
	p_BILL_PARTY_DESC IN VARCHAR2,
	p_BILL_PARTY_ID IN NUMBER,
	p_BILL_PARTY_STATUS IN VARCHAR2,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_IS_INVOICE_DETAIL IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC BILL_PARTY%ROWTYPE;
BEGIN


	v_REC.BILL_PARTY_ID := p_BILL_PARTY_ID;
	v_REC.BILL_PARTY_NAME := TRIM(p_BILL_PARTY_NAME);
	v_REC.BILL_PARTY_ALIAS := TRIM(NVL(p_BILL_PARTY_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.BILL_PARTY_DESC := TRIM(NVL(p_BILL_PARTY_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.BILL_PARTY_STATUS := TRIM(NVL(p_BILL_PARTY_STATUS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EXTERNAL_IDENTIFIER := TRIM(NVL(p_EXTERNAL_IDENTIFIER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.IS_INVOICE_DETAIL := p_IS_INVOICE_DETAIL;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_BILL_PARTY_ID > 0 OR p_BILL_PARTY_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_BILL_PARTY_ID, EC.ED_BILL_PARTY) 
                 AND IO_UTIL.BILL_PARTY_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_BILL_PARTY, p_BILL_PARTY_ID);
		END IF;

		-- save it!
		UPDATE BILL_PARTY
		SET ROW = v_REC
		WHERE BILL_PARTY_ID = p_BILL_PARTY_ID;
		o_OID := p_BILL_PARTY_ID;
        
	ELSIF p_BILL_PARTY_ID IS NULL OR p_BILL_PARTY_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.BILL_PARTY_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_BILL_PARTY, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.BILL_PARTY_ID := o_OID;
		-- save it!
		INSERT INTO BILL_PARTY VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_BILL_PARTY_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_BILL_PARTY, EC.ED_ENTITY_DOMAIN)||': '||p_BILL_PARTY_NAME);
END PUT_BILL_PARTY;
---------------------------------------------------------------------
PROCEDURE GET_BILL_PARTY
	(
	p_BILL_PARTY_ID IN NUMBER,
	p_BILL_PARTY_NAME OUT VARCHAR2,
	p_BILL_PARTY_ALIAS OUT VARCHAR2,
	p_BILL_PARTY_DESC OUT VARCHAR2,
	p_BILL_PARTY_STATUS OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_IS_INVOICE_DETAIL OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD BILL_PARTY%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_BILL_PARTY_ID, EC.ED_BILL_PARTY);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM BILL_PARTY
	WHERE BILL_PARTY_ID = p_BILL_PARTY_ID;
    
	-- Set the output parameters
	p_BILL_PARTY_NAME := v_RECORD.BILL_PARTY_NAME;
	p_BILL_PARTY_ALIAS := v_RECORD.BILL_PARTY_ALIAS;
	p_BILL_PARTY_DESC := v_RECORD.BILL_PARTY_DESC;
	p_BILL_PARTY_STATUS := v_RECORD.BILL_PARTY_STATUS;
	p_EXTERNAL_IDENTIFIER := v_RECORD.EXTERNAL_IDENTIFIER;
	p_IS_INVOICE_DETAIL := v_RECORD.IS_INVOICE_DETAIL;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_BILL_PARTY_NAME := g_EMPTY_VARCHAR2;
		p_BILL_PARTY_ALIAS := g_EMPTY_VARCHAR2;
		p_BILL_PARTY_DESC := g_EMPTY_VARCHAR2;
		p_BILL_PARTY_STATUS := g_EMPTY_VARCHAR2;
		p_EXTERNAL_IDENTIFIER := g_EMPTY_VARCHAR2;
		p_IS_INVOICE_DETAIL := g_EMPTY_NUMBER;

END GET_BILL_PARTY;
---------------------------------------------------------------------
PROCEDURE PUT_BREAKPOINT
	(
	o_OID OUT NUMBER,
	p_BREAKPOINT_NAME IN VARCHAR2,
	p_BREAKPOINT_ALIAS IN VARCHAR2,
	p_BREAKPOINT_DESC IN VARCHAR2,
	p_BREAKPOINT_ID IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC BREAKPOINT%ROWTYPE;
BEGIN
	-- Make sure user has access
	IF NOT CAN_WRITE('Data Setup') THEN
        ERRS.RAISE_NO_WRITE_MODULE('Data Setup');
	END IF;



	v_REC.BREAKPOINT_ID := p_BREAKPOINT_ID;
	v_REC.BREAKPOINT_NAME := TRIM(p_BREAKPOINT_NAME);
	v_REC.BREAKPOINT_ALIAS := TRIM(NVL(p_BREAKPOINT_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.BREAKPOINT_DESC := TRIM(NVL(p_BREAKPOINT_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_BREAKPOINT_ID > 0 OR p_BREAKPOINT_ID < -10 THEN

		-- save it!
		UPDATE BREAKPOINT
		SET ROW = v_REC
		WHERE BREAKPOINT_ID = p_BREAKPOINT_ID;
		o_OID := p_BREAKPOINT_ID;
        
	ELSIF p_BREAKPOINT_ID IS NULL OR p_BREAKPOINT_ID = 0 THEN

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.BREAKPOINT_ID := o_OID;
		-- save it!
		INSERT INTO BREAKPOINT VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_BREAKPOINT_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, 'BREAKPOINT: '||p_BREAKPOINT_NAME);
END PUT_BREAKPOINT;
---------------------------------------------------------------------
PROCEDURE GET_BREAKPOINT
	(
	p_BREAKPOINT_ID IN NUMBER,
	p_BREAKPOINT_NAME OUT VARCHAR2,
	p_BREAKPOINT_ALIAS OUT VARCHAR2,
	p_BREAKPOINT_DESC OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD BREAKPOINT%ROWTYPE;
BEGIN
	-- Make sure user has access
	IF NOT CAN_READ('Data Setup') THEN
        ERRS.RAISE_NO_READ_MODULE('Data Setup');
	END IF;

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM BREAKPOINT
	WHERE BREAKPOINT_ID = p_BREAKPOINT_ID;
    
	-- Set the output parameters
	p_BREAKPOINT_NAME := v_RECORD.BREAKPOINT_NAME;
	p_BREAKPOINT_ALIAS := v_RECORD.BREAKPOINT_ALIAS;
	p_BREAKPOINT_DESC := v_RECORD.BREAKPOINT_DESC;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_BREAKPOINT_NAME := g_EMPTY_VARCHAR2;
		p_BREAKPOINT_ALIAS := g_EMPTY_VARCHAR2;
		p_BREAKPOINT_DESC := g_EMPTY_VARCHAR2;

END GET_BREAKPOINT;
---------------------------------------------------------------------
PROCEDURE PUT_CA
	(
	o_OID OUT NUMBER,
	p_CA_NAME IN VARCHAR2,
	p_CA_ALIAS IN VARCHAR2,
	p_CA_DESC IN VARCHAR2,
	p_CA_ID IN NUMBER,
	p_CA_NERC_CODE IN VARCHAR2,
	p_CA_STATUS IN VARCHAR2,
	p_CA_DUNS_NUMBER IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC CONTROL_AREA%ROWTYPE;
BEGIN


	v_REC.CA_ID := p_CA_ID;
	v_REC.CA_NAME := TRIM(p_CA_NAME);
	v_REC.CA_ALIAS := TRIM(NVL(p_CA_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.CA_DESC := TRIM(NVL(p_CA_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.CA_NERC_CODE := TRIM(NVL(p_CA_NERC_CODE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.CA_STATUS := TRIM(NVL(p_CA_STATUS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.CA_DUNS_NUMBER := TRIM(NVL(p_CA_DUNS_NUMBER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_CA_ID > 0 OR p_CA_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_CA_ID, EC.ED_CA) 
                 AND IO_UTIL.CA_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_CA, p_CA_ID);
		END IF;

		-- save it!
		UPDATE CONTROL_AREA
		SET ROW = v_REC
		WHERE CA_ID = p_CA_ID;
		o_OID := p_CA_ID;
        
	ELSIF p_CA_ID IS NULL OR p_CA_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.CA_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_CA, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.CA_ID := o_OID;
		-- save it!
		INSERT INTO CONTROL_AREA VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_CA_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_CA, EC.ED_ENTITY_DOMAIN)||': '||p_CA_NAME);
END PUT_CA;
---------------------------------------------------------------------
PROCEDURE GET_CA
	(
	p_CA_ID IN NUMBER,
	p_CA_NAME OUT VARCHAR2,
	p_CA_ALIAS OUT VARCHAR2,
	p_CA_DESC OUT VARCHAR2,
	p_CA_NERC_CODE OUT VARCHAR2,
	p_CA_STATUS OUT VARCHAR2,
	p_CA_DUNS_NUMBER OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD CONTROL_AREA%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_CA_ID, EC.ED_CA);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM CONTROL_AREA
	WHERE CA_ID = p_CA_ID;
    
	-- Set the output parameters
	p_CA_NAME := v_RECORD.CA_NAME;
	p_CA_ALIAS := v_RECORD.CA_ALIAS;
	p_CA_DESC := v_RECORD.CA_DESC;
	p_CA_NERC_CODE := v_RECORD.CA_NERC_CODE;
	p_CA_STATUS := v_RECORD.CA_STATUS;
	p_CA_DUNS_NUMBER := v_RECORD.CA_DUNS_NUMBER;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_CA_NAME := g_EMPTY_VARCHAR2;
		p_CA_ALIAS := g_EMPTY_VARCHAR2;
		p_CA_DESC := g_EMPTY_VARCHAR2;
		p_CA_NERC_CODE := g_EMPTY_VARCHAR2;
		p_CA_STATUS := g_EMPTY_VARCHAR2;
		p_CA_DUNS_NUMBER := g_EMPTY_VARCHAR2;

END GET_CA;
---------------------------------------------------------------------
PROCEDURE PUT_CALC_PROCESS
	(
	o_OID OUT NUMBER,
	p_CALC_PROCESS_NAME IN VARCHAR2,
	p_CALC_PROCESS_ALIAS IN VARCHAR2,
	p_CALC_PROCESS_DESC IN VARCHAR2,
	p_CALC_PROCESS_ID IN NUMBER,
	p_CALC_PROCESS_CATEGORY IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_PROCESS_INTERVAL IN VARCHAR2,
	p_WEEK_BEGIN IN VARCHAR2,
	p_CONTEXT_DOMAIN_ID IN NUMBER,
	p_CONTEXT_REALM_ID IN NUMBER,
	p_CONTEXT_GROUP_ID IN NUMBER,
	p_CONTEXT_NAME IN VARCHAR2,
	p_IS_STATEMENT_TYPE_SPECIFIC IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC CALCULATION_PROCESS%ROWTYPE;
BEGIN


	v_REC.CALC_PROCESS_ID := p_CALC_PROCESS_ID;
	v_REC.CALC_PROCESS_NAME := TRIM(p_CALC_PROCESS_NAME);
	v_REC.CALC_PROCESS_ALIAS := TRIM(NVL(p_CALC_PROCESS_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.CALC_PROCESS_DESC := TRIM(NVL(p_CALC_PROCESS_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.CALC_PROCESS_CATEGORY := TRIM(NVL(p_CALC_PROCESS_CATEGORY,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.TIME_ZONE := TRIM(NVL(p_TIME_ZONE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PROCESS_INTERVAL := TRIM(NVL(p_PROCESS_INTERVAL,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.WEEK_BEGIN := TRIM(NVL(p_WEEK_BEGIN,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.CONTEXT_DOMAIN_ID := NVL(p_CONTEXT_DOMAIN_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.CONTEXT_REALM_ID := p_CONTEXT_REALM_ID;
	v_REC.CONTEXT_GROUP_ID := p_CONTEXT_GROUP_ID;
	v_REC.CONTEXT_NAME := TRIM(NVL(p_CONTEXT_NAME,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.IS_STATEMENT_TYPE_SPECIFIC := p_IS_STATEMENT_TYPE_SPECIFIC;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_CALC_PROCESS_ID > 0 OR p_CALC_PROCESS_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_CALC_PROCESS_ID, EC.ED_CALC_PROCESS) 
                 AND IO_UTIL.CALC_PROCESS_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_CALC_PROCESS, p_CALC_PROCESS_ID);
		END IF;

		-- save it!
		UPDATE CALCULATION_PROCESS
		SET ROW = v_REC
		WHERE CALC_PROCESS_ID = p_CALC_PROCESS_ID;
		o_OID := p_CALC_PROCESS_ID;
        
	ELSIF p_CALC_PROCESS_ID IS NULL OR p_CALC_PROCESS_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.CALC_PROCESS_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_CALC_PROCESS, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.CALC_PROCESS_ID := o_OID;
		-- save it!
		INSERT INTO CALCULATION_PROCESS VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_CALC_PROCESS_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_CALC_PROCESS, EC.ED_ENTITY_DOMAIN)||': '||p_CALC_PROCESS_NAME);
END PUT_CALC_PROCESS;
---------------------------------------------------------------------
PROCEDURE GET_CALC_PROCESS
	(
	p_CALC_PROCESS_ID IN NUMBER,
	p_CALC_PROCESS_NAME OUT VARCHAR2,
	p_CALC_PROCESS_ALIAS OUT VARCHAR2,
	p_CALC_PROCESS_DESC OUT VARCHAR2,
	p_CALC_PROCESS_CATEGORY OUT VARCHAR2,
	p_TIME_ZONE OUT VARCHAR2,
	p_PROCESS_INTERVAL OUT VARCHAR2,
	p_WEEK_BEGIN OUT VARCHAR2,
	p_CONTEXT_DOMAIN_ID OUT NUMBER,
	p_CONTEXT_REALM_ID OUT NUMBER,
	p_CONTEXT_GROUP_ID OUT NUMBER,
	p_CONTEXT_NAME OUT VARCHAR2,
	p_IS_STATEMENT_TYPE_SPECIFIC OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD CALCULATION_PROCESS%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_CALC_PROCESS_ID, EC.ED_CALC_PROCESS);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM CALCULATION_PROCESS
	WHERE CALC_PROCESS_ID = p_CALC_PROCESS_ID;
    
	-- Set the output parameters
	p_CALC_PROCESS_NAME := v_RECORD.CALC_PROCESS_NAME;
	p_CALC_PROCESS_ALIAS := v_RECORD.CALC_PROCESS_ALIAS;
	p_CALC_PROCESS_DESC := v_RECORD.CALC_PROCESS_DESC;
	p_CALC_PROCESS_CATEGORY := v_RECORD.CALC_PROCESS_CATEGORY;
	p_TIME_ZONE := v_RECORD.TIME_ZONE;
	p_PROCESS_INTERVAL := v_RECORD.PROCESS_INTERVAL;
	p_WEEK_BEGIN := v_RECORD.WEEK_BEGIN;
	p_CONTEXT_DOMAIN_ID := v_RECORD.CONTEXT_DOMAIN_ID;
	p_CONTEXT_REALM_ID := v_RECORD.CONTEXT_REALM_ID;
	p_CONTEXT_GROUP_ID := v_RECORD.CONTEXT_GROUP_ID;
	p_CONTEXT_NAME := v_RECORD.CONTEXT_NAME;
	p_IS_STATEMENT_TYPE_SPECIFIC := v_RECORD.IS_STATEMENT_TYPE_SPECIFIC;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_CALC_PROCESS_NAME := g_EMPTY_VARCHAR2;
		p_CALC_PROCESS_ALIAS := g_EMPTY_VARCHAR2;
		p_CALC_PROCESS_DESC := g_EMPTY_VARCHAR2;
		p_CALC_PROCESS_CATEGORY := g_EMPTY_VARCHAR2;
		p_TIME_ZONE := g_EMPTY_VARCHAR2;
		p_PROCESS_INTERVAL := g_EMPTY_VARCHAR2;
		p_WEEK_BEGIN := g_EMPTY_VARCHAR2;
		p_CONTEXT_DOMAIN_ID := g_EMPTY_NUMBER;
		p_CONTEXT_REALM_ID := g_EMPTY_NUMBER;
		p_CONTEXT_GROUP_ID := g_EMPTY_NUMBER;
		p_CONTEXT_NAME := g_EMPTY_VARCHAR2;
		p_IS_STATEMENT_TYPE_SPECIFIC := g_EMPTY_NUMBER;

END GET_CALC_PROCESS;
---------------------------------------------------------------------
PROCEDURE PUT_CALENDAR
	(
	o_OID OUT NUMBER,
	p_CALENDAR_NAME IN VARCHAR2,
	p_CALENDAR_ALIAS IN VARCHAR2,
	p_CALENDAR_DESC IN VARCHAR2,
	p_CALENDAR_ID IN NUMBER,
	p_ASSIGNMENT_TYPE IN VARCHAR2,
	p_HAS_ADJUSTMENTS IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC CALENDAR%ROWTYPE;
BEGIN


	v_REC.CALENDAR_ID := p_CALENDAR_ID;
	v_REC.CALENDAR_NAME := TRIM(p_CALENDAR_NAME);
	v_REC.CALENDAR_ALIAS := TRIM(NVL(p_CALENDAR_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.CALENDAR_DESC := TRIM(NVL(p_CALENDAR_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ASSIGNMENT_TYPE := TRIM(NVL(p_ASSIGNMENT_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.HAS_ADJUSTMENTS := p_HAS_ADJUSTMENTS;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_CALENDAR_ID > 0 OR p_CALENDAR_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_CALENDAR_ID, EC.ED_CALENDAR) 
                 AND IO_UTIL.CALENDAR_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_CALENDAR, p_CALENDAR_ID);
		END IF;

		-- save it!
		UPDATE CALENDAR
		SET ROW = v_REC
		WHERE CALENDAR_ID = p_CALENDAR_ID;
		o_OID := p_CALENDAR_ID;
        
	ELSIF p_CALENDAR_ID IS NULL OR p_CALENDAR_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.CALENDAR_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_CALENDAR, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.CALENDAR_ID := o_OID;
		-- save it!
		INSERT INTO CALENDAR VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_CALENDAR_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_CALENDAR, EC.ED_ENTITY_DOMAIN)||': '||p_CALENDAR_NAME);
END PUT_CALENDAR;
---------------------------------------------------------------------
PROCEDURE GET_CALENDAR
	(
	p_CALENDAR_ID IN NUMBER,
	p_CALENDAR_NAME OUT VARCHAR2,
	p_CALENDAR_ALIAS OUT VARCHAR2,
	p_CALENDAR_DESC OUT VARCHAR2,
	p_ASSIGNMENT_TYPE OUT VARCHAR2,
	p_HAS_ADJUSTMENTS OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD CALENDAR%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_CALENDAR_ID, EC.ED_CALENDAR);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM CALENDAR
	WHERE CALENDAR_ID = p_CALENDAR_ID;
    
	-- Set the output parameters
	p_CALENDAR_NAME := v_RECORD.CALENDAR_NAME;
	p_CALENDAR_ALIAS := v_RECORD.CALENDAR_ALIAS;
	p_CALENDAR_DESC := v_RECORD.CALENDAR_DESC;
	p_ASSIGNMENT_TYPE := v_RECORD.ASSIGNMENT_TYPE;
	p_HAS_ADJUSTMENTS := v_RECORD.HAS_ADJUSTMENTS;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_CALENDAR_NAME := g_EMPTY_VARCHAR2;
		p_CALENDAR_ALIAS := g_EMPTY_VARCHAR2;
		p_CALENDAR_DESC := g_EMPTY_VARCHAR2;
		p_ASSIGNMENT_TYPE := g_EMPTY_VARCHAR2;
		p_HAS_ADJUSTMENTS := g_EMPTY_NUMBER;

END GET_CALENDAR;
---------------------------------------------------------------------
PROCEDURE PUT_CASE_LABEL
	(
	o_OID OUT NUMBER,
	p_CASE_NAME IN VARCHAR2,
	p_CASE_ALIAS IN VARCHAR2,
	p_CASE_DESC IN VARCHAR2,
	p_CASE_ID IN NUMBER,
	p_CASE_CATEGORY IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC CASE_LABEL%ROWTYPE;
BEGIN


	v_REC.CASE_ID := p_CASE_ID;
	v_REC.CASE_NAME := TRIM(p_CASE_NAME);
	v_REC.CASE_ALIAS := TRIM(NVL(p_CASE_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.CASE_DESC := TRIM(NVL(p_CASE_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.CASE_CATEGORY := TRIM(NVL(p_CASE_CATEGORY,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_CASE_ID > 0 OR p_CASE_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_CASE_ID, EC.ED_CASE_LABEL) 
                 AND IO_UTIL.CASE_LABEL_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_CASE_LABEL, p_CASE_ID);
		END IF;

		-- save it!
		UPDATE CASE_LABEL
		SET ROW = v_REC
		WHERE CASE_ID = p_CASE_ID;
		o_OID := p_CASE_ID;
        
	ELSIF p_CASE_ID IS NULL OR p_CASE_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.CASE_LABEL_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_CASE_LABEL, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.CASE_ID := o_OID;
		-- save it!
		INSERT INTO CASE_LABEL VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_CASE_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_CASE_LABEL, EC.ED_ENTITY_DOMAIN)||': '||p_CASE_NAME);
END PUT_CASE_LABEL;
---------------------------------------------------------------------
PROCEDURE GET_CASE_LABEL
	(
	p_CASE_ID IN NUMBER,
	p_CASE_NAME OUT VARCHAR2,
	p_CASE_ALIAS OUT VARCHAR2,
	p_CASE_DESC OUT VARCHAR2,
	p_CASE_CATEGORY OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD CASE_LABEL%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_CASE_ID, EC.ED_CASE_LABEL);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM CASE_LABEL
	WHERE CASE_ID = p_CASE_ID;
    
	-- Set the output parameters
	p_CASE_NAME := v_RECORD.CASE_NAME;
	p_CASE_ALIAS := v_RECORD.CASE_ALIAS;
	p_CASE_DESC := v_RECORD.CASE_DESC;
	p_CASE_CATEGORY := v_RECORD.CASE_CATEGORY;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_CASE_NAME := g_EMPTY_VARCHAR2;
		p_CASE_ALIAS := g_EMPTY_VARCHAR2;
		p_CASE_DESC := g_EMPTY_VARCHAR2;
		p_CASE_CATEGORY := g_EMPTY_VARCHAR2;

END GET_CASE_LABEL;
---------------------------------------------------------------------
PROCEDURE PUT_CATEGORY
	(
	o_OID OUT NUMBER,
	p_CATEGORY_NAME IN VARCHAR2,
	p_CATEGORY_ALIAS IN VARCHAR2,
	p_CATEGORY_DESC IN VARCHAR2,
	p_CATEGORY_ID IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC CATEGORY%ROWTYPE;
BEGIN


	v_REC.CATEGORY_ID := p_CATEGORY_ID;
	v_REC.CATEGORY_NAME := TRIM(p_CATEGORY_NAME);
	v_REC.CATEGORY_ALIAS := TRIM(NVL(p_CATEGORY_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.CATEGORY_DESC := TRIM(NVL(p_CATEGORY_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_CATEGORY_ID > 0 OR p_CATEGORY_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_CATEGORY_ID, EC.ED_CATEGORY) 
                 AND IO_UTIL.CATEGORY_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_CATEGORY, p_CATEGORY_ID);
		END IF;

		-- save it!
		UPDATE CATEGORY
		SET ROW = v_REC
		WHERE CATEGORY_ID = p_CATEGORY_ID;
		o_OID := p_CATEGORY_ID;
        
	ELSIF p_CATEGORY_ID IS NULL OR p_CATEGORY_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.CATEGORY_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_CATEGORY, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.CATEGORY_ID := o_OID;
		-- save it!
		INSERT INTO CATEGORY VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_CATEGORY_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_CATEGORY, EC.ED_ENTITY_DOMAIN)||': '||p_CATEGORY_NAME);
END PUT_CATEGORY;
---------------------------------------------------------------------
PROCEDURE GET_CATEGORY
	(
	p_CATEGORY_ID IN NUMBER,
	p_CATEGORY_NAME OUT VARCHAR2,
	p_CATEGORY_ALIAS OUT VARCHAR2,
	p_CATEGORY_DESC OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD CATEGORY%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_CATEGORY_ID, EC.ED_CATEGORY);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM CATEGORY
	WHERE CATEGORY_ID = p_CATEGORY_ID;
    
	-- Set the output parameters
	p_CATEGORY_NAME := v_RECORD.CATEGORY_NAME;
	p_CATEGORY_ALIAS := v_RECORD.CATEGORY_ALIAS;
	p_CATEGORY_DESC := v_RECORD.CATEGORY_DESC;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_CATEGORY_NAME := g_EMPTY_VARCHAR2;
		p_CATEGORY_ALIAS := g_EMPTY_VARCHAR2;
		p_CATEGORY_DESC := g_EMPTY_VARCHAR2;

END GET_CATEGORY;
---------------------------------------------------------------------
PROCEDURE PUT_COMPONENT
	(
	o_OID OUT NUMBER,
	p_COMPONENT_NAME IN VARCHAR2,
	p_COMPONENT_ALIAS IN VARCHAR2,
	p_COMPONENT_DESC IN VARCHAR2,
	p_COMPONENT_ID IN NUMBER,
	p_COMPONENT_ENTITY IN VARCHAR2,
	p_CHARGE_TYPE IN VARCHAR2,
	p_RATE_STRUCTURE IN VARCHAR2,
	p_RATE_INTERVAL IN VARCHAR2,
	p_IS_REBILL IN NUMBER,
	p_IS_TAXED IN NUMBER,
	p_IS_CUSTOM_CHARGE IN NUMBER,
	p_IS_CREDIT_CHARGE IN NUMBER,
	p_IS_INCLUDE_TX_LOSS IN NUMBER,
	p_IS_INCLUDE_DX_LOSS IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_MARKET_PRICE_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_MODEL_ID IN NUMBER,
	p_EVENT_ID IN NUMBER,
	p_COMPONENT_REFERENCE IN VARCHAR2,
	p_INVOICE_GROUP_ID IN NUMBER,
	p_INVOICE_GROUP_ORDER IN NUMBER,
	p_COMPUTATION_ORDER IN NUMBER,
	p_QUANTITY_UNIT IN VARCHAR2,
	p_CURRENCY_UNIT IN VARCHAR2,
	p_QUANTITY_TYPE IN VARCHAR2,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_COMPONENT_CATEGORY IN VARCHAR2,
	p_GL_DEBIT_ACCOUNT IN VARCHAR2,
	p_GL_CREDIT_ACCOUNT IN VARCHAR2,
	p_FIRM_NON_FIRM IN VARCHAR2,
	p_EXCLUDE_FROM_INVOICE IN NUMBER,
	p_EXCLUDE_FROM_INVOICE_TOTAL IN NUMBER,
	p_IMBALANCE_TYPE IN VARCHAR2,
	p_ACCUMULATION_PERIOD IN NUMBER,
	p_BASE_COMPONENT_ID IN NUMBER,
	p_BASE_LIMIT_ID IN NUMBER,
	p_MARKET_TYPE IN VARCHAR2,
	p_MARKET_PRICE_TYPE IN VARCHAR2,
	p_WHICH_INTERVAL IN VARCHAR2,
	p_LMP_PRICE_CALC IN VARCHAR2,
	p_LMP_INCLUDE_EXT IN NUMBER,
	p_LMP_INCLUDE_SALES IN VARCHAR2,
	p_CHARGE_WHEN IN VARCHAR2,
	p_BILATERALS_SIGN IN NUMBER,
	p_LMP_COMMODITY_ID IN NUMBER,
	p_LMP_BASE_COMMODITY_ID IN NUMBER,
	p_USE_ZONAL_PRICE IN NUMBER,
	p_ALTERNATE_PRICE IN VARCHAR2,
	p_ALTERNATE_PRICE_FUNCTION IN VARCHAR2,
	p_EXCLUDE_FROM_BILLING_EXPORT IN NUMBER,
	p_IS_DEFAULT_TEMPLATE IN NUMBER,
	p_KWH_MULTIPLIER IN NUMBER,
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_APPLY_RATE_FOR IN VARCHAR2,
	p_LOSS_ADJ_TYPE IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC COMPONENT%ROWTYPE;
BEGIN


	v_REC.COMPONENT_ID := p_COMPONENT_ID;
	v_REC.COMPONENT_NAME := TRIM(p_COMPONENT_NAME);
	v_REC.COMPONENT_ALIAS := TRIM(NVL(p_COMPONENT_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.COMPONENT_DESC := TRIM(NVL(p_COMPONENT_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.COMPONENT_ENTITY := TRIM(NVL(p_COMPONENT_ENTITY,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.CHARGE_TYPE := TRIM(NVL(p_CHARGE_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.RATE_STRUCTURE := TRIM(NVL(p_RATE_STRUCTURE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.RATE_INTERVAL := TRIM(NVL(p_RATE_INTERVAL,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.IS_REBILL := p_IS_REBILL;
	v_REC.IS_TAXED := p_IS_TAXED;
	v_REC.IS_CUSTOM_CHARGE := p_IS_CUSTOM_CHARGE;
	v_REC.IS_CREDIT_CHARGE := p_IS_CREDIT_CHARGE;
	v_REC.IS_INCLUDE_TX_LOSS := p_IS_INCLUDE_TX_LOSS;
	v_REC.IS_INCLUDE_DX_LOSS := p_IS_INCLUDE_DX_LOSS;
	v_REC.TEMPLATE_ID := NVL(p_TEMPLATE_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.MARKET_PRICE_ID := NVL(p_MARKET_PRICE_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.SERVICE_POINT_ID := NVL(p_SERVICE_POINT_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.MODEL_ID := p_MODEL_ID;
	v_REC.EVENT_ID := p_EVENT_ID;
	v_REC.COMPONENT_REFERENCE := TRIM(NVL(p_COMPONENT_REFERENCE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.INVOICE_GROUP_ID := NVL(p_INVOICE_GROUP_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.INVOICE_GROUP_ORDER := p_INVOICE_GROUP_ORDER;
	v_REC.COMPUTATION_ORDER := p_COMPUTATION_ORDER;
	v_REC.QUANTITY_UNIT := TRIM(NVL(p_QUANTITY_UNIT,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.CURRENCY_UNIT := TRIM(NVL(p_CURRENCY_UNIT,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.QUANTITY_TYPE := TRIM(NVL(p_QUANTITY_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EXTERNAL_IDENTIFIER := TRIM(NVL(p_EXTERNAL_IDENTIFIER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.COMPONENT_CATEGORY := TRIM(NVL(p_COMPONENT_CATEGORY,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.GL_DEBIT_ACCOUNT := TRIM(NVL(p_GL_DEBIT_ACCOUNT,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.GL_CREDIT_ACCOUNT := TRIM(NVL(p_GL_CREDIT_ACCOUNT,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.FIRM_NON_FIRM := TRIM(NVL(p_FIRM_NON_FIRM,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EXCLUDE_FROM_INVOICE := p_EXCLUDE_FROM_INVOICE;
	v_REC.EXCLUDE_FROM_INVOICE_TOTAL := p_EXCLUDE_FROM_INVOICE_TOTAL;
	v_REC.IMBALANCE_TYPE := TRIM(NVL(p_IMBALANCE_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ACCUMULATION_PERIOD := p_ACCUMULATION_PERIOD;
	v_REC.BASE_COMPONENT_ID := NVL(p_BASE_COMPONENT_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.BASE_LIMIT_ID := p_BASE_LIMIT_ID;
	v_REC.MARKET_TYPE := TRIM(NVL(p_MARKET_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.MARKET_PRICE_TYPE := TRIM(NVL(p_MARKET_PRICE_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.WHICH_INTERVAL := TRIM(NVL(p_WHICH_INTERVAL,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.LMP_PRICE_CALC := TRIM(NVL(p_LMP_PRICE_CALC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.LMP_INCLUDE_EXT := p_LMP_INCLUDE_EXT;
	v_REC.LMP_INCLUDE_SALES := TRIM(NVL(p_LMP_INCLUDE_SALES,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.CHARGE_WHEN := TRIM(NVL(p_CHARGE_WHEN,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.BILATERALS_SIGN := p_BILATERALS_SIGN;
	v_REC.LMP_COMMODITY_ID := NVL(p_LMP_COMMODITY_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.LMP_BASE_COMMODITY_ID := NVL(p_LMP_BASE_COMMODITY_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.USE_ZONAL_PRICE := p_USE_ZONAL_PRICE;
	v_REC.ALTERNATE_PRICE := TRIM(NVL(p_ALTERNATE_PRICE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ALTERNATE_PRICE_FUNCTION := TRIM(NVL(p_ALTERNATE_PRICE_FUNCTION,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EXCLUDE_FROM_BILLING_EXPORT := p_EXCLUDE_FROM_BILLING_EXPORT;
	v_REC.IS_DEFAULT_TEMPLATE := p_IS_DEFAULT_TEMPLATE;
	v_REC.KWH_MULTIPLIER := p_KWH_MULTIPLIER;
	v_REC.ANCILLARY_SERVICE_ID := p_ANCILLARY_SERVICE_ID;
	v_REC.APPLY_RATE_FOR := TRIM(NVL(p_APPLY_RATE_FOR,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.LOSS_ADJ_TYPE := p_LOSS_ADJ_TYPE;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_COMPONENT_ID > 0 OR p_COMPONENT_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_COMPONENT_ID, EC.ED_COMPONENT) 
                 AND IO_UTIL.COMPONENT_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_COMPONENT, p_COMPONENT_ID);
		END IF;

		-- save it!
		UPDATE COMPONENT
		SET ROW = v_REC
		WHERE COMPONENT_ID = p_COMPONENT_ID;
		o_OID := p_COMPONENT_ID;
        
	ELSIF p_COMPONENT_ID IS NULL OR p_COMPONENT_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.COMPONENT_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_COMPONENT, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.COMPONENT_ID := o_OID;
		-- save it!
		INSERT INTO COMPONENT VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_COMPONENT_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_COMPONENT, EC.ED_ENTITY_DOMAIN)||': '||p_COMPONENT_NAME);
END PUT_COMPONENT;
---------------------------------------------------------------------
PROCEDURE GET_COMPONENT
	(
	p_COMPONENT_ID IN NUMBER,
	p_COMPONENT_NAME OUT VARCHAR2,
	p_COMPONENT_ALIAS OUT VARCHAR2,
	p_COMPONENT_DESC OUT VARCHAR2,
	p_COMPONENT_ENTITY OUT VARCHAR2,
	p_CHARGE_TYPE OUT VARCHAR2,
	p_RATE_STRUCTURE OUT VARCHAR2,
	p_RATE_INTERVAL OUT VARCHAR2,
	p_IS_REBILL OUT NUMBER,
	p_IS_TAXED OUT NUMBER,
	p_IS_CUSTOM_CHARGE OUT NUMBER,
	p_IS_CREDIT_CHARGE OUT NUMBER,
	p_IS_INCLUDE_TX_LOSS OUT NUMBER,
	p_IS_INCLUDE_DX_LOSS OUT NUMBER,
	p_TEMPLATE_ID OUT NUMBER,
	p_MARKET_PRICE_ID OUT NUMBER,
	p_SERVICE_POINT_ID OUT NUMBER,
	p_MODEL_ID OUT NUMBER,
	p_EVENT_ID OUT NUMBER,
	p_COMPONENT_REFERENCE OUT VARCHAR2,
	p_INVOICE_GROUP_ID OUT NUMBER,
	p_INVOICE_GROUP_ORDER OUT NUMBER,
	p_COMPUTATION_ORDER OUT NUMBER,
	p_QUANTITY_UNIT OUT VARCHAR2,
	p_CURRENCY_UNIT OUT VARCHAR2,
	p_QUANTITY_TYPE OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_COMPONENT_CATEGORY OUT VARCHAR2,
	p_GL_DEBIT_ACCOUNT OUT VARCHAR2,
	p_GL_CREDIT_ACCOUNT OUT VARCHAR2,
	p_FIRM_NON_FIRM OUT VARCHAR2,
	p_EXCLUDE_FROM_INVOICE OUT NUMBER,
	p_EXCLUDE_FROM_INVOICE_TOTAL OUT NUMBER,
	p_IMBALANCE_TYPE OUT VARCHAR2,
	p_ACCUMULATION_PERIOD OUT NUMBER,
	p_BASE_COMPONENT_ID OUT NUMBER,
	p_BASE_LIMIT_ID OUT NUMBER,
	p_MARKET_TYPE OUT VARCHAR2,
	p_MARKET_PRICE_TYPE OUT VARCHAR2,
	p_WHICH_INTERVAL OUT VARCHAR2,
	p_LMP_PRICE_CALC OUT VARCHAR2,
	p_LMP_INCLUDE_EXT OUT NUMBER,
	p_LMP_INCLUDE_SALES OUT VARCHAR2,
	p_CHARGE_WHEN OUT VARCHAR2,
	p_BILATERALS_SIGN OUT NUMBER,
	p_LMP_COMMODITY_ID OUT NUMBER,
	p_LMP_BASE_COMMODITY_ID OUT NUMBER,
	p_USE_ZONAL_PRICE OUT NUMBER,
	p_ALTERNATE_PRICE OUT VARCHAR2,
	p_ALTERNATE_PRICE_FUNCTION OUT VARCHAR2,
	p_EXCLUDE_FROM_BILLING_EXPORT OUT NUMBER,
	p_IS_DEFAULT_TEMPLATE OUT NUMBER,
	p_KWH_MULTIPLIER OUT NUMBER,
	p_ANCILLARY_SERVICE_ID OUT NUMBER,
	p_APPLY_RATE_FOR OUT VARCHAR2,
	p_LOSS_ADJ_TYPE OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD COMPONENT%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM COMPONENT
	WHERE COMPONENT_ID = p_COMPONENT_ID;
    
	-- Set the output parameters
	p_COMPONENT_NAME := v_RECORD.COMPONENT_NAME;
	p_COMPONENT_ALIAS := v_RECORD.COMPONENT_ALIAS;
	p_COMPONENT_DESC := v_RECORD.COMPONENT_DESC;
	p_COMPONENT_ENTITY := v_RECORD.COMPONENT_ENTITY;
	p_CHARGE_TYPE := v_RECORD.CHARGE_TYPE;
	p_RATE_STRUCTURE := v_RECORD.RATE_STRUCTURE;
	p_RATE_INTERVAL := v_RECORD.RATE_INTERVAL;
	p_IS_REBILL := v_RECORD.IS_REBILL;
	p_IS_TAXED := v_RECORD.IS_TAXED;
	p_IS_CUSTOM_CHARGE := v_RECORD.IS_CUSTOM_CHARGE;
	p_IS_CREDIT_CHARGE := v_RECORD.IS_CREDIT_CHARGE;
	p_IS_INCLUDE_TX_LOSS := v_RECORD.IS_INCLUDE_TX_LOSS;
	p_IS_INCLUDE_DX_LOSS := v_RECORD.IS_INCLUDE_DX_LOSS;
	p_TEMPLATE_ID := v_RECORD.TEMPLATE_ID;
	p_MARKET_PRICE_ID := v_RECORD.MARKET_PRICE_ID;
	p_SERVICE_POINT_ID := v_RECORD.SERVICE_POINT_ID;
	p_MODEL_ID := v_RECORD.MODEL_ID;
	p_EVENT_ID := v_RECORD.EVENT_ID;
	p_COMPONENT_REFERENCE := v_RECORD.COMPONENT_REFERENCE;
	p_INVOICE_GROUP_ID := v_RECORD.INVOICE_GROUP_ID;
	p_INVOICE_GROUP_ORDER := v_RECORD.INVOICE_GROUP_ORDER;
	p_COMPUTATION_ORDER := v_RECORD.COMPUTATION_ORDER;
	p_QUANTITY_UNIT := v_RECORD.QUANTITY_UNIT;
	p_CURRENCY_UNIT := v_RECORD.CURRENCY_UNIT;
	p_QUANTITY_TYPE := v_RECORD.QUANTITY_TYPE;
	p_EXTERNAL_IDENTIFIER := v_RECORD.EXTERNAL_IDENTIFIER;
	p_COMPONENT_CATEGORY := v_RECORD.COMPONENT_CATEGORY;
	p_GL_DEBIT_ACCOUNT := v_RECORD.GL_DEBIT_ACCOUNT;
	p_GL_CREDIT_ACCOUNT := v_RECORD.GL_CREDIT_ACCOUNT;
	p_FIRM_NON_FIRM := v_RECORD.FIRM_NON_FIRM;
	p_EXCLUDE_FROM_INVOICE := v_RECORD.EXCLUDE_FROM_INVOICE;
	p_EXCLUDE_FROM_INVOICE_TOTAL := v_RECORD.EXCLUDE_FROM_INVOICE_TOTAL;
	p_IMBALANCE_TYPE := v_RECORD.IMBALANCE_TYPE;
	p_ACCUMULATION_PERIOD := v_RECORD.ACCUMULATION_PERIOD;
	p_BASE_COMPONENT_ID := v_RECORD.BASE_COMPONENT_ID;
	p_BASE_LIMIT_ID := v_RECORD.BASE_LIMIT_ID;
	p_MARKET_TYPE := v_RECORD.MARKET_TYPE;
	p_MARKET_PRICE_TYPE := v_RECORD.MARKET_PRICE_TYPE;
	p_WHICH_INTERVAL := v_RECORD.WHICH_INTERVAL;
	p_LMP_PRICE_CALC := v_RECORD.LMP_PRICE_CALC;
	p_LMP_INCLUDE_EXT := v_RECORD.LMP_INCLUDE_EXT;
	p_LMP_INCLUDE_SALES := v_RECORD.LMP_INCLUDE_SALES;
	p_CHARGE_WHEN := v_RECORD.CHARGE_WHEN;
	p_BILATERALS_SIGN := v_RECORD.BILATERALS_SIGN;
	p_LMP_COMMODITY_ID := v_RECORD.LMP_COMMODITY_ID;
	p_LMP_BASE_COMMODITY_ID := v_RECORD.LMP_BASE_COMMODITY_ID;
	p_USE_ZONAL_PRICE := v_RECORD.USE_ZONAL_PRICE;
	p_ALTERNATE_PRICE := v_RECORD.ALTERNATE_PRICE;
	p_ALTERNATE_PRICE_FUNCTION := v_RECORD.ALTERNATE_PRICE_FUNCTION;
	p_EXCLUDE_FROM_BILLING_EXPORT := v_RECORD.EXCLUDE_FROM_BILLING_EXPORT;
	p_IS_DEFAULT_TEMPLATE := v_RECORD.IS_DEFAULT_TEMPLATE;
	p_KWH_MULTIPLIER := v_RECORD.KWH_MULTIPLIER;
	p_ANCILLARY_SERVICE_ID := v_RECORD.ANCILLARY_SERVICE_ID;
	p_APPLY_RATE_FOR := v_RECORD.APPLY_RATE_FOR;
	p_LOSS_ADJ_TYPE := v_RECORD.LOSS_ADJ_TYPE;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_COMPONENT_NAME := g_EMPTY_VARCHAR2;
		p_COMPONENT_ALIAS := g_EMPTY_VARCHAR2;
		p_COMPONENT_DESC := g_EMPTY_VARCHAR2;
		p_COMPONENT_ENTITY := g_EMPTY_VARCHAR2;
		p_CHARGE_TYPE := g_EMPTY_VARCHAR2;
		p_RATE_STRUCTURE := g_EMPTY_VARCHAR2;
		p_RATE_INTERVAL := g_EMPTY_VARCHAR2;
		p_IS_REBILL := g_EMPTY_NUMBER;
		p_IS_TAXED := g_EMPTY_NUMBER;
		p_IS_CUSTOM_CHARGE := g_EMPTY_NUMBER;
		p_IS_CREDIT_CHARGE := g_EMPTY_NUMBER;
		p_IS_INCLUDE_TX_LOSS := g_EMPTY_NUMBER;
		p_IS_INCLUDE_DX_LOSS := g_EMPTY_NUMBER;
		p_TEMPLATE_ID := g_EMPTY_NUMBER;
		p_MARKET_PRICE_ID := g_EMPTY_NUMBER;
		p_SERVICE_POINT_ID := g_EMPTY_NUMBER;
		p_MODEL_ID := g_EMPTY_NUMBER;
		p_EVENT_ID := g_EMPTY_NUMBER;
		p_COMPONENT_REFERENCE := g_EMPTY_VARCHAR2;
		p_INVOICE_GROUP_ID := g_EMPTY_NUMBER;
		p_INVOICE_GROUP_ORDER := g_EMPTY_NUMBER;
		p_COMPUTATION_ORDER := g_EMPTY_NUMBER;
		p_QUANTITY_UNIT := g_EMPTY_VARCHAR2;
		p_CURRENCY_UNIT := g_EMPTY_VARCHAR2;
		p_QUANTITY_TYPE := g_EMPTY_VARCHAR2;
		p_EXTERNAL_IDENTIFIER := g_EMPTY_VARCHAR2;
		p_COMPONENT_CATEGORY := g_EMPTY_VARCHAR2;
		p_GL_DEBIT_ACCOUNT := g_EMPTY_VARCHAR2;
		p_GL_CREDIT_ACCOUNT := g_EMPTY_VARCHAR2;
		p_FIRM_NON_FIRM := g_EMPTY_VARCHAR2;
		p_EXCLUDE_FROM_INVOICE := g_EMPTY_NUMBER;
		p_EXCLUDE_FROM_INVOICE_TOTAL := g_EMPTY_NUMBER;
		p_IMBALANCE_TYPE := g_EMPTY_VARCHAR2;
		p_ACCUMULATION_PERIOD := g_EMPTY_NUMBER;
		p_BASE_COMPONENT_ID := g_EMPTY_NUMBER;
		p_BASE_LIMIT_ID := g_EMPTY_NUMBER;
		p_MARKET_TYPE := g_EMPTY_VARCHAR2;
		p_MARKET_PRICE_TYPE := g_EMPTY_VARCHAR2;
		p_WHICH_INTERVAL := g_EMPTY_VARCHAR2;
		p_LMP_PRICE_CALC := g_EMPTY_VARCHAR2;
		p_LMP_INCLUDE_EXT := g_EMPTY_NUMBER;
		p_LMP_INCLUDE_SALES := g_EMPTY_VARCHAR2;
		p_CHARGE_WHEN := g_EMPTY_VARCHAR2;
		p_BILATERALS_SIGN := g_EMPTY_NUMBER;
		p_LMP_COMMODITY_ID := g_EMPTY_NUMBER;
		p_LMP_BASE_COMMODITY_ID := g_EMPTY_NUMBER;
		p_USE_ZONAL_PRICE := g_EMPTY_NUMBER;
		p_ALTERNATE_PRICE := g_EMPTY_VARCHAR2;
		p_ALTERNATE_PRICE_FUNCTION := g_EMPTY_VARCHAR2;
		p_EXCLUDE_FROM_BILLING_EXPORT := g_EMPTY_NUMBER;
		p_IS_DEFAULT_TEMPLATE := g_EMPTY_NUMBER;
		p_KWH_MULTIPLIER := g_EMPTY_NUMBER;
		p_ANCILLARY_SERVICE_ID := g_EMPTY_NUMBER;
		p_APPLY_RATE_FOR := g_EMPTY_VARCHAR2;
		p_LOSS_ADJ_TYPE := g_EMPTY_NUMBER;

END GET_COMPONENT;
---------------------------------------------------------------------
PROCEDURE PUT_CONDITIONAL_FORMAT
	(
	o_OID OUT NUMBER,
	p_CONDITIONAL_FORMAT_NAME IN VARCHAR2,
	p_CONDITIONAL_FORMAT_ALIAS IN VARCHAR2,
	p_CONDITIONAL_FORMAT_DESC IN VARCHAR2,
	p_CONDITIONAL_FORMAT_ID IN NUMBER,
	p_CONDITIONAL_FORMAT_MODULE IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC CONDITIONAL_FORMAT%ROWTYPE;
BEGIN


	v_REC.CONDITIONAL_FORMAT_ID := p_CONDITIONAL_FORMAT_ID;
	v_REC.CONDITIONAL_FORMAT_NAME := TRIM(p_CONDITIONAL_FORMAT_NAME);
	v_REC.CONDITIONAL_FORMAT_ALIAS := TRIM(NVL(p_CONDITIONAL_FORMAT_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.CONDITIONAL_FORMAT_DESC := TRIM(NVL(p_CONDITIONAL_FORMAT_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.CONDITIONAL_FORMAT_MODULE := TRIM(NVL(p_CONDITIONAL_FORMAT_MODULE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_CONDITIONAL_FORMAT_ID > 0 OR p_CONDITIONAL_FORMAT_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_CONDITIONAL_FORMAT_ID, EC.ED_CONDITIONAL_FORMAT) 
                 AND IO_UTIL.CONDITIONAL_FORMAT_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_CONDITIONAL_FORMAT, p_CONDITIONAL_FORMAT_ID);
		END IF;

		-- save it!
		UPDATE CONDITIONAL_FORMAT
		SET ROW = v_REC
		WHERE CONDITIONAL_FORMAT_ID = p_CONDITIONAL_FORMAT_ID;
		o_OID := p_CONDITIONAL_FORMAT_ID;
        
	ELSIF p_CONDITIONAL_FORMAT_ID IS NULL OR p_CONDITIONAL_FORMAT_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.CONDITIONAL_FORMAT_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_CONDITIONAL_FORMAT, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.CONDITIONAL_FORMAT_ID := o_OID;
		-- save it!
		INSERT INTO CONDITIONAL_FORMAT VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_CONDITIONAL_FORMAT_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_CONDITIONAL_FORMAT, EC.ED_ENTITY_DOMAIN)||': '||p_CONDITIONAL_FORMAT_NAME);
END PUT_CONDITIONAL_FORMAT;
---------------------------------------------------------------------
PROCEDURE GET_CONDITIONAL_FORMAT
	(
	p_CONDITIONAL_FORMAT_ID IN NUMBER,
	p_CONDITIONAL_FORMAT_NAME OUT VARCHAR2,
	p_CONDITIONAL_FORMAT_ALIAS OUT VARCHAR2,
	p_CONDITIONAL_FORMAT_DESC OUT VARCHAR2,
	p_CONDITIONAL_FORMAT_MODULE OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD CONDITIONAL_FORMAT%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_CONDITIONAL_FORMAT_ID, EC.ED_CONDITIONAL_FORMAT);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM CONDITIONAL_FORMAT
	WHERE CONDITIONAL_FORMAT_ID = p_CONDITIONAL_FORMAT_ID;
    
	-- Set the output parameters
	p_CONDITIONAL_FORMAT_NAME := v_RECORD.CONDITIONAL_FORMAT_NAME;
	p_CONDITIONAL_FORMAT_ALIAS := v_RECORD.CONDITIONAL_FORMAT_ALIAS;
	p_CONDITIONAL_FORMAT_DESC := v_RECORD.CONDITIONAL_FORMAT_DESC;
	p_CONDITIONAL_FORMAT_MODULE := v_RECORD.CONDITIONAL_FORMAT_MODULE;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_CONDITIONAL_FORMAT_NAME := g_EMPTY_VARCHAR2;
		p_CONDITIONAL_FORMAT_ALIAS := g_EMPTY_VARCHAR2;
		p_CONDITIONAL_FORMAT_DESC := g_EMPTY_VARCHAR2;
		p_CONDITIONAL_FORMAT_MODULE := g_EMPTY_VARCHAR2;

END GET_CONDITIONAL_FORMAT;
---------------------------------------------------------------------
PROCEDURE PUT_CONTACT
	(
	o_OID OUT NUMBER,
	p_CONTACT_NAME IN VARCHAR2,
	p_CONTACT_ALIAS IN VARCHAR2,
	p_CONTACT_DESC IN VARCHAR2,
	p_CONTACT_ID IN NUMBER,
	p_CONTACT_STATUS IN VARCHAR2,
	p_EMAIL_ADDRESS IN VARCHAR2,
	p_FIRST_NAME IN VARCHAR2,
	p_MIDDLE_NAME IN VARCHAR2,
	p_LAST_NAME IN VARCHAR2,
	p_SALUTATION IN VARCHAR2,
	p_TITLE IN VARCHAR2,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC CONTACT%ROWTYPE;
BEGIN


	v_REC.CONTACT_ID := p_CONTACT_ID;
	v_REC.CONTACT_NAME := TRIM(p_CONTACT_NAME);
	v_REC.CONTACT_ALIAS := TRIM(NVL(p_CONTACT_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.CONTACT_DESC := TRIM(NVL(p_CONTACT_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.CONTACT_STATUS := TRIM(NVL(p_CONTACT_STATUS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EMAIL_ADDRESS := TRIM(NVL(p_EMAIL_ADDRESS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.FIRST_NAME := TRIM(NVL(p_FIRST_NAME,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.MIDDLE_NAME := TRIM(NVL(p_MIDDLE_NAME,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.LAST_NAME := TRIM(NVL(p_LAST_NAME,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SALUTATION := TRIM(NVL(p_SALUTATION,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.TITLE := TRIM(NVL(p_TITLE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EXTERNAL_IDENTIFIER := TRIM(NVL(p_EXTERNAL_IDENTIFIER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_CONTACT_ID > 0 OR p_CONTACT_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_CONTACT_ID, EC.ED_CONTACT) 
                 AND IO_UTIL.CONTACT_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_CONTACT, p_CONTACT_ID);
		END IF;

		-- save it!
		UPDATE CONTACT
		SET ROW = v_REC
		WHERE CONTACT_ID = p_CONTACT_ID;
		o_OID := p_CONTACT_ID;
        
	ELSIF p_CONTACT_ID IS NULL OR p_CONTACT_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.CONTACT_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_CONTACT, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.CONTACT_ID := o_OID;
		-- save it!
		INSERT INTO CONTACT VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_CONTACT_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_CONTACT, EC.ED_ENTITY_DOMAIN)||': '||p_CONTACT_NAME);
END PUT_CONTACT;
---------------------------------------------------------------------
PROCEDURE GET_CONTACT
	(
	p_CONTACT_ID IN NUMBER,
	p_CONTACT_NAME OUT VARCHAR2,
	p_CONTACT_ALIAS OUT VARCHAR2,
	p_CONTACT_DESC OUT VARCHAR2,
	p_CONTACT_STATUS OUT VARCHAR2,
	p_EMAIL_ADDRESS OUT VARCHAR2,
	p_FIRST_NAME OUT VARCHAR2,
	p_MIDDLE_NAME OUT VARCHAR2,
	p_LAST_NAME OUT VARCHAR2,
	p_SALUTATION OUT VARCHAR2,
	p_TITLE OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD CONTACT%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_CONTACT_ID, EC.ED_CONTACT);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM CONTACT
	WHERE CONTACT_ID = p_CONTACT_ID;
    
	-- Set the output parameters
	p_CONTACT_NAME := v_RECORD.CONTACT_NAME;
	p_CONTACT_ALIAS := v_RECORD.CONTACT_ALIAS;
	p_CONTACT_DESC := v_RECORD.CONTACT_DESC;
	p_CONTACT_STATUS := v_RECORD.CONTACT_STATUS;
	p_EMAIL_ADDRESS := v_RECORD.EMAIL_ADDRESS;
	p_FIRST_NAME := v_RECORD.FIRST_NAME;
	p_MIDDLE_NAME := v_RECORD.MIDDLE_NAME;
	p_LAST_NAME := v_RECORD.LAST_NAME;
	p_SALUTATION := v_RECORD.SALUTATION;
	p_TITLE := v_RECORD.TITLE;
	p_EXTERNAL_IDENTIFIER := v_RECORD.EXTERNAL_IDENTIFIER;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_CONTACT_NAME := g_EMPTY_VARCHAR2;
		p_CONTACT_ALIAS := g_EMPTY_VARCHAR2;
		p_CONTACT_DESC := g_EMPTY_VARCHAR2;
		p_CONTACT_STATUS := g_EMPTY_VARCHAR2;
		p_EMAIL_ADDRESS := g_EMPTY_VARCHAR2;
		p_FIRST_NAME := g_EMPTY_VARCHAR2;
		p_MIDDLE_NAME := g_EMPTY_VARCHAR2;
		p_LAST_NAME := g_EMPTY_VARCHAR2;
		p_SALUTATION := g_EMPTY_VARCHAR2;
		p_TITLE := g_EMPTY_VARCHAR2;
		p_EXTERNAL_IDENTIFIER := g_EMPTY_VARCHAR2;

END GET_CONTACT;
---------------------------------------------------------------------
PROCEDURE PUT_CONTRACT
	(
	o_OID OUT NUMBER,
	p_CONTRACT_NAME IN VARCHAR2,
	p_CONTRACT_ALIAS IN VARCHAR2,
	p_CONTRACT_DESC IN VARCHAR2,
	p_CONTRACT_ID IN NUMBER,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_IS_ESTIMATED_END_DATE IN NUMBER,
	p_IS_EVERGREEN IN NUMBER,
	p_IS_INTERRUPTIBLE IN NUMBER,
	p_EXPECTED_RENEWAL_PCT IN NUMBER,
	p_NEXT_ACTION_DATE IN DATE,
	p_NOTIFICATION_REQUIREMENTS IN VARCHAR2,
	p_CURTAILMENT_ABILITY IN VARCHAR2,
	p_PENALTY_CLAUSES IN VARCHAR2,
	p_PRICING_MODEL IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC SERVICE_CONTRACT%ROWTYPE;
BEGIN


	v_REC.CONTRACT_ID := p_CONTRACT_ID;
	v_REC.CONTRACT_NAME := TRIM(p_CONTRACT_NAME);
	v_REC.CONTRACT_ALIAS := TRIM(NVL(p_CONTRACT_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.CONTRACT_DESC := TRIM(NVL(p_CONTRACT_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EXTERNAL_IDENTIFIER := TRIM(NVL(p_EXTERNAL_IDENTIFIER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.BEGIN_DATE := p_BEGIN_DATE;
	v_REC.END_DATE := p_END_DATE;
	v_REC.IS_ESTIMATED_END_DATE := p_IS_ESTIMATED_END_DATE;
	v_REC.IS_EVERGREEN := p_IS_EVERGREEN;
	v_REC.IS_INTERRUPTIBLE := p_IS_INTERRUPTIBLE;
	v_REC.EXPECTED_RENEWAL_PCT := p_EXPECTED_RENEWAL_PCT;
	v_REC.NEXT_ACTION_DATE := p_NEXT_ACTION_DATE;
	v_REC.NOTIFICATION_REQUIREMENTS := TRIM(NVL(p_NOTIFICATION_REQUIREMENTS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.CURTAILMENT_ABILITY := TRIM(NVL(p_CURTAILMENT_ABILITY,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PENALTY_CLAUSES := TRIM(NVL(p_PENALTY_CLAUSES,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PRICING_MODEL := TRIM(NVL(p_PRICING_MODEL,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_CONTRACT_ID > 0 OR p_CONTRACT_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_CONTRACT_ID, EC.ED_CONTRACT) 
                 AND IO_UTIL.CONTRACT_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_CONTRACT, p_CONTRACT_ID);
		END IF;

		-- save it!
		UPDATE SERVICE_CONTRACT
		SET ROW = v_REC
		WHERE CONTRACT_ID = p_CONTRACT_ID;
		o_OID := p_CONTRACT_ID;
        
	ELSIF p_CONTRACT_ID IS NULL OR p_CONTRACT_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.CONTRACT_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_CONTRACT, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.CONTRACT_ID := o_OID;
		-- save it!
		INSERT INTO SERVICE_CONTRACT VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_CONTRACT_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_CONTRACT, EC.ED_ENTITY_DOMAIN)||': '||p_CONTRACT_NAME);
END PUT_CONTRACT;
---------------------------------------------------------------------
PROCEDURE GET_CONTRACT
	(
	p_CONTRACT_ID IN NUMBER,
	p_CONTRACT_NAME OUT VARCHAR2,
	p_CONTRACT_ALIAS OUT VARCHAR2,
	p_CONTRACT_DESC OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE,
	p_IS_ESTIMATED_END_DATE OUT NUMBER,
	p_IS_EVERGREEN OUT NUMBER,
	p_IS_INTERRUPTIBLE OUT NUMBER,
	p_EXPECTED_RENEWAL_PCT OUT NUMBER,
	p_NEXT_ACTION_DATE OUT DATE,
	p_NOTIFICATION_REQUIREMENTS OUT VARCHAR2,
	p_CURTAILMENT_ABILITY OUT VARCHAR2,
	p_PENALTY_CLAUSES OUT VARCHAR2,
	p_PRICING_MODEL OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD SERVICE_CONTRACT%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_CONTRACT_ID, EC.ED_CONTRACT);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM SERVICE_CONTRACT
	WHERE CONTRACT_ID = p_CONTRACT_ID;
    
	-- Set the output parameters
	p_CONTRACT_NAME := v_RECORD.CONTRACT_NAME;
	p_CONTRACT_ALIAS := v_RECORD.CONTRACT_ALIAS;
	p_CONTRACT_DESC := v_RECORD.CONTRACT_DESC;
	p_EXTERNAL_IDENTIFIER := v_RECORD.EXTERNAL_IDENTIFIER;
	p_BEGIN_DATE := v_RECORD.BEGIN_DATE;
	p_END_DATE := v_RECORD.END_DATE;
	p_IS_ESTIMATED_END_DATE := v_RECORD.IS_ESTIMATED_END_DATE;
	p_IS_EVERGREEN := v_RECORD.IS_EVERGREEN;
	p_IS_INTERRUPTIBLE := v_RECORD.IS_INTERRUPTIBLE;
	p_EXPECTED_RENEWAL_PCT := v_RECORD.EXPECTED_RENEWAL_PCT;
	p_NEXT_ACTION_DATE := v_RECORD.NEXT_ACTION_DATE;
	p_NOTIFICATION_REQUIREMENTS := v_RECORD.NOTIFICATION_REQUIREMENTS;
	p_CURTAILMENT_ABILITY := v_RECORD.CURTAILMENT_ABILITY;
	p_PENALTY_CLAUSES := v_RECORD.PENALTY_CLAUSES;
	p_PRICING_MODEL := v_RECORD.PRICING_MODEL;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_CONTRACT_NAME := g_EMPTY_VARCHAR2;
		p_CONTRACT_ALIAS := g_EMPTY_VARCHAR2;
		p_CONTRACT_DESC := g_EMPTY_VARCHAR2;
		p_EXTERNAL_IDENTIFIER := g_EMPTY_VARCHAR2;
		p_BEGIN_DATE := g_EMPTY_DATE;
		p_END_DATE := g_EMPTY_DATE;
		p_IS_ESTIMATED_END_DATE := g_EMPTY_NUMBER;
		p_IS_EVERGREEN := g_EMPTY_NUMBER;
		p_IS_INTERRUPTIBLE := g_EMPTY_NUMBER;
		p_EXPECTED_RENEWAL_PCT := g_EMPTY_NUMBER;
		p_NEXT_ACTION_DATE := g_EMPTY_DATE;
		p_NOTIFICATION_REQUIREMENTS := g_EMPTY_VARCHAR2;
		p_CURTAILMENT_ABILITY := g_EMPTY_VARCHAR2;
		p_PENALTY_CLAUSES := g_EMPTY_VARCHAR2;
		p_PRICING_MODEL := g_EMPTY_VARCHAR2;

END GET_CONTRACT;
---------------------------------------------------------------------
PROCEDURE PUT_CONTRACT_LIMIT
	(
	o_OID OUT NUMBER,
	p_LIMIT_NAME IN VARCHAR2,
	p_LIMIT_ALIAS IN VARCHAR2,
	p_LIMIT_DESC IN VARCHAR2,
	p_LIMIT_ID IN NUMBER,
	p_LIMIT_TYPE IN VARCHAR2,
	p_LIMIT_MEASURE IN VARCHAR2,
	p_LIMIT_INTERVAL IN VARCHAR2,
	p_LIMIT_IS_SEASONABLE IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_PERIOD_ID IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC CONTRACT_LIMIT%ROWTYPE;
BEGIN


	v_REC.LIMIT_ID := p_LIMIT_ID;
	v_REC.LIMIT_NAME := TRIM(p_LIMIT_NAME);
	v_REC.LIMIT_ALIAS := TRIM(NVL(p_LIMIT_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.LIMIT_DESC := TRIM(NVL(p_LIMIT_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.LIMIT_TYPE := TRIM(NVL(p_LIMIT_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.LIMIT_MEASURE := TRIM(NVL(p_LIMIT_MEASURE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.LIMIT_INTERVAL := TRIM(NVL(p_LIMIT_INTERVAL,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.LIMIT_IS_SEASONABLE := p_LIMIT_IS_SEASONABLE;
	v_REC.TEMPLATE_ID := NVL(p_TEMPLATE_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.PERIOD_ID := p_PERIOD_ID;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_LIMIT_ID > 0 OR p_LIMIT_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_LIMIT_ID, EC.ED_CONTRACT_LIMIT) 
                 AND IO_UTIL.CONTRACT_LIMIT_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_CONTRACT_LIMIT, p_LIMIT_ID);
		END IF;

		-- save it!
		UPDATE CONTRACT_LIMIT
		SET ROW = v_REC
		WHERE LIMIT_ID = p_LIMIT_ID;
		o_OID := p_LIMIT_ID;
        
	ELSIF p_LIMIT_ID IS NULL OR p_LIMIT_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.CONTRACT_LIMIT_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_CONTRACT_LIMIT, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.LIMIT_ID := o_OID;
		-- save it!
		INSERT INTO CONTRACT_LIMIT VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_LIMIT_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_CONTRACT_LIMIT, EC.ED_ENTITY_DOMAIN)||': '||p_LIMIT_NAME);
END PUT_CONTRACT_LIMIT;
---------------------------------------------------------------------
PROCEDURE GET_CONTRACT_LIMIT
	(
	p_LIMIT_ID IN NUMBER,
	p_LIMIT_NAME OUT VARCHAR2,
	p_LIMIT_ALIAS OUT VARCHAR2,
	p_LIMIT_DESC OUT VARCHAR2,
	p_LIMIT_TYPE OUT VARCHAR2,
	p_LIMIT_MEASURE OUT VARCHAR2,
	p_LIMIT_INTERVAL OUT VARCHAR2,
	p_LIMIT_IS_SEASONABLE OUT NUMBER,
	p_TEMPLATE_ID OUT NUMBER,
	p_PERIOD_ID OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD CONTRACT_LIMIT%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_LIMIT_ID, EC.ED_CONTRACT_LIMIT);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM CONTRACT_LIMIT
	WHERE LIMIT_ID = p_LIMIT_ID;
    
	-- Set the output parameters
	p_LIMIT_NAME := v_RECORD.LIMIT_NAME;
	p_LIMIT_ALIAS := v_RECORD.LIMIT_ALIAS;
	p_LIMIT_DESC := v_RECORD.LIMIT_DESC;
	p_LIMIT_TYPE := v_RECORD.LIMIT_TYPE;
	p_LIMIT_MEASURE := v_RECORD.LIMIT_MEASURE;
	p_LIMIT_INTERVAL := v_RECORD.LIMIT_INTERVAL;
	p_LIMIT_IS_SEASONABLE := v_RECORD.LIMIT_IS_SEASONABLE;
	p_TEMPLATE_ID := v_RECORD.TEMPLATE_ID;
	p_PERIOD_ID := v_RECORD.PERIOD_ID;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_LIMIT_NAME := g_EMPTY_VARCHAR2;
		p_LIMIT_ALIAS := g_EMPTY_VARCHAR2;
		p_LIMIT_DESC := g_EMPTY_VARCHAR2;
		p_LIMIT_TYPE := g_EMPTY_VARCHAR2;
		p_LIMIT_MEASURE := g_EMPTY_VARCHAR2;
		p_LIMIT_INTERVAL := g_EMPTY_VARCHAR2;
		p_LIMIT_IS_SEASONABLE := g_EMPTY_NUMBER;
		p_TEMPLATE_ID := g_EMPTY_NUMBER;
		p_PERIOD_ID := g_EMPTY_NUMBER;

END GET_CONTRACT_LIMIT;
---------------------------------------------------------------------
PROCEDURE PUT_CUSTOMER
	(
	o_OID OUT NUMBER,
	p_CUSTOMER_NAME IN VARCHAR2,
	p_CUSTOMER_ALIAS IN VARCHAR2,
	p_CUSTOMER_DESC IN VARCHAR2,
	p_CUSTOMER_ID IN NUMBER,
	p_CUSTOMER_IDENTIFIER IN VARCHAR2,
	p_CUSTOMER_STATUS IN VARCHAR2,
	p_CUSTOMER_IS_ACTIVE IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC CUSTOMER%ROWTYPE;
BEGIN


	v_REC.CUSTOMER_ID := p_CUSTOMER_ID;
	v_REC.CUSTOMER_NAME := TRIM(p_CUSTOMER_NAME);
	v_REC.CUSTOMER_ALIAS := TRIM(NVL(p_CUSTOMER_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.CUSTOMER_DESC := TRIM(NVL(p_CUSTOMER_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.CUSTOMER_IDENTIFIER := TRIM(NVL(p_CUSTOMER_IDENTIFIER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.CUSTOMER_STATUS := TRIM(NVL(p_CUSTOMER_STATUS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.CUSTOMER_IS_ACTIVE := p_CUSTOMER_IS_ACTIVE;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_CUSTOMER_ID > 0 OR p_CUSTOMER_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_CUSTOMER_ID, EC.ED_CUSTOMER) 
                 AND IO_UTIL.CUSTOMER_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_CUSTOMER, p_CUSTOMER_ID);
		END IF;

		-- save it!
		UPDATE CUSTOMER
		SET ROW = v_REC
		WHERE CUSTOMER_ID = p_CUSTOMER_ID;
		o_OID := p_CUSTOMER_ID;
        
	ELSIF p_CUSTOMER_ID IS NULL OR p_CUSTOMER_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.CUSTOMER_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_CUSTOMER, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.CUSTOMER_ID := o_OID;
		-- save it!
		INSERT INTO CUSTOMER VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_CUSTOMER_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_CUSTOMER, EC.ED_ENTITY_DOMAIN)||': '||p_CUSTOMER_NAME);
END PUT_CUSTOMER;
---------------------------------------------------------------------
PROCEDURE GET_CUSTOMER
	(
	p_CUSTOMER_ID IN NUMBER,
	p_CUSTOMER_NAME OUT VARCHAR2,
	p_CUSTOMER_ALIAS OUT VARCHAR2,
	p_CUSTOMER_DESC OUT VARCHAR2,
	p_CUSTOMER_IDENTIFIER OUT VARCHAR2,
	p_CUSTOMER_STATUS OUT VARCHAR2,
	p_CUSTOMER_IS_ACTIVE OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD CUSTOMER%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_CUSTOMER_ID, EC.ED_CUSTOMER);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM CUSTOMER
	WHERE CUSTOMER_ID = p_CUSTOMER_ID;
    
	-- Set the output parameters
	p_CUSTOMER_NAME := v_RECORD.CUSTOMER_NAME;
	p_CUSTOMER_ALIAS := v_RECORD.CUSTOMER_ALIAS;
	p_CUSTOMER_DESC := v_RECORD.CUSTOMER_DESC;
	p_CUSTOMER_IDENTIFIER := v_RECORD.CUSTOMER_IDENTIFIER;
	p_CUSTOMER_STATUS := v_RECORD.CUSTOMER_STATUS;
	p_CUSTOMER_IS_ACTIVE := v_RECORD.CUSTOMER_IS_ACTIVE;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_CUSTOMER_NAME := g_EMPTY_VARCHAR2;
		p_CUSTOMER_ALIAS := g_EMPTY_VARCHAR2;
		p_CUSTOMER_DESC := g_EMPTY_VARCHAR2;
		p_CUSTOMER_IDENTIFIER := g_EMPTY_VARCHAR2;
		p_CUSTOMER_STATUS := g_EMPTY_VARCHAR2;
		p_CUSTOMER_IS_ACTIVE := g_EMPTY_NUMBER;

END GET_CUSTOMER;
---------------------------------------------------------------------
PROCEDURE PUT_DATA_LOCK_GROUP
	(
	o_OID OUT NUMBER,
	p_DATA_LOCK_GROUP_NAME IN VARCHAR2,
	p_DATA_LOCK_GROUP_ALIAS IN VARCHAR2,
	p_DATA_LOCK_GROUP_DESC IN VARCHAR2,
	p_DATA_LOCK_GROUP_ID IN NUMBER,
	p_DATA_LOCK_GROUP_INTERVAL IN VARCHAR2,
	p_IS_AUTOMATIC IN NUMBER,
	p_AUTOLOCK_DATE_FORMULA IN VARCHAR2,
	p_LOCK_LIMIT_DATE_FORMULA IN VARCHAR2,
	p_LOCK_STATE IN VARCHAR2,
	p_LAST_PROCESSED_INTERVAL IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_WEEK_BEGIN IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC DATA_LOCK_GROUP%ROWTYPE;
BEGIN


	v_REC.DATA_LOCK_GROUP_ID := p_DATA_LOCK_GROUP_ID;
	v_REC.DATA_LOCK_GROUP_NAME := TRIM(p_DATA_LOCK_GROUP_NAME);
	v_REC.DATA_LOCK_GROUP_ALIAS := TRIM(NVL(p_DATA_LOCK_GROUP_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.DATA_LOCK_GROUP_DESC := TRIM(NVL(p_DATA_LOCK_GROUP_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.DATA_LOCK_GROUP_INTERVAL := TRIM(p_DATA_LOCK_GROUP_INTERVAL);
	v_REC.IS_AUTOMATIC := p_IS_AUTOMATIC;
	v_REC.AUTOLOCK_DATE_FORMULA := TRIM(p_AUTOLOCK_DATE_FORMULA);
	v_REC.LOCK_LIMIT_DATE_FORMULA := TRIM(p_LOCK_LIMIT_DATE_FORMULA);
	v_REC.LOCK_STATE := TRIM(p_LOCK_STATE);
	v_REC.LAST_PROCESSED_INTERVAL := p_LAST_PROCESSED_INTERVAL;
	v_REC.TIME_ZONE := TRIM(p_TIME_ZONE);
	v_REC.WEEK_BEGIN := TRIM(p_WEEK_BEGIN);

	IF p_DATA_LOCK_GROUP_ID > 0 OR p_DATA_LOCK_GROUP_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_DATA_LOCK_GROUP_ID, EC.ED_DATA_LOCK_GROUP) 
                 AND IO_UTIL.DATA_LOCK_GROUP_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_DATA_LOCK_GROUP, p_DATA_LOCK_GROUP_ID);
		END IF;

		-- save it!
		UPDATE DATA_LOCK_GROUP
		SET ROW = v_REC
		WHERE DATA_LOCK_GROUP_ID = p_DATA_LOCK_GROUP_ID;
		o_OID := p_DATA_LOCK_GROUP_ID;
        
	ELSIF p_DATA_LOCK_GROUP_ID IS NULL OR p_DATA_LOCK_GROUP_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.DATA_LOCK_GROUP_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_DATA_LOCK_GROUP, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.DATA_LOCK_GROUP_ID := o_OID;
		-- save it!
		INSERT INTO DATA_LOCK_GROUP VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_DATA_LOCK_GROUP_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_DATA_LOCK_GROUP, EC.ED_ENTITY_DOMAIN)||': '||p_DATA_LOCK_GROUP_NAME);
END PUT_DATA_LOCK_GROUP;
---------------------------------------------------------------------
PROCEDURE GET_DATA_LOCK_GROUP
	(
	p_DATA_LOCK_GROUP_ID IN NUMBER,
	p_DATA_LOCK_GROUP_NAME OUT VARCHAR2,
	p_DATA_LOCK_GROUP_ALIAS OUT VARCHAR2,
	p_DATA_LOCK_GROUP_DESC OUT VARCHAR2,
	p_DATA_LOCK_GROUP_INTERVAL OUT VARCHAR2,
	p_IS_AUTOMATIC OUT NUMBER,
	p_AUTOLOCK_DATE_FORMULA OUT VARCHAR2,
	p_LOCK_LIMIT_DATE_FORMULA OUT VARCHAR2,
	p_LOCK_STATE OUT VARCHAR2,
	p_LAST_PROCESSED_INTERVAL OUT DATE,
	p_TIME_ZONE OUT VARCHAR2,
	p_WEEK_BEGIN OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD DATA_LOCK_GROUP%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_DATA_LOCK_GROUP_ID, EC.ED_DATA_LOCK_GROUP);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM DATA_LOCK_GROUP
	WHERE DATA_LOCK_GROUP_ID = p_DATA_LOCK_GROUP_ID;
    
	-- Set the output parameters
	p_DATA_LOCK_GROUP_NAME := v_RECORD.DATA_LOCK_GROUP_NAME;
	p_DATA_LOCK_GROUP_ALIAS := v_RECORD.DATA_LOCK_GROUP_ALIAS;
	p_DATA_LOCK_GROUP_DESC := v_RECORD.DATA_LOCK_GROUP_DESC;
	p_DATA_LOCK_GROUP_INTERVAL := v_RECORD.DATA_LOCK_GROUP_INTERVAL;
	p_IS_AUTOMATIC := v_RECORD.IS_AUTOMATIC;
	p_AUTOLOCK_DATE_FORMULA := v_RECORD.AUTOLOCK_DATE_FORMULA;
	p_LOCK_LIMIT_DATE_FORMULA := v_RECORD.LOCK_LIMIT_DATE_FORMULA;
	p_LOCK_STATE := v_RECORD.LOCK_STATE;
	p_LAST_PROCESSED_INTERVAL := v_RECORD.LAST_PROCESSED_INTERVAL;
	p_TIME_ZONE := v_RECORD.TIME_ZONE;
	p_WEEK_BEGIN := v_RECORD.WEEK_BEGIN;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_DATA_LOCK_GROUP_NAME := g_EMPTY_VARCHAR2;
		p_DATA_LOCK_GROUP_ALIAS := g_EMPTY_VARCHAR2;
		p_DATA_LOCK_GROUP_DESC := g_EMPTY_VARCHAR2;
		p_DATA_LOCK_GROUP_INTERVAL := g_EMPTY_VARCHAR2;
		p_IS_AUTOMATIC := g_EMPTY_NUMBER;
		p_AUTOLOCK_DATE_FORMULA := g_EMPTY_VARCHAR2;
		p_LOCK_LIMIT_DATE_FORMULA := g_EMPTY_VARCHAR2;
		p_LOCK_STATE := g_EMPTY_VARCHAR2;
		p_LAST_PROCESSED_INTERVAL := g_EMPTY_DATE;
		p_TIME_ZONE := g_EMPTY_VARCHAR2;
		p_WEEK_BEGIN := g_EMPTY_VARCHAR2;

END GET_DATA_LOCK_GROUP;
---------------------------------------------------------------------
PROCEDURE PUT_DER
	(
	o_OID OUT NUMBER,
	p_DER_NAME IN VARCHAR2,
	p_DER_ALIAS IN VARCHAR2,
	p_DER_DESC IN VARCHAR2,
	p_DER_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_DER_TYPE_ID IN NUMBER,
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SERIAL_NUMBER IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC DISTRIBUTED_ENERGY_RESOURCE%ROWTYPE;
BEGIN


	v_REC.DER_ID := p_DER_ID;
	v_REC.DER_NAME := TRIM(p_DER_NAME);
	v_REC.DER_ALIAS := TRIM(NVL(p_DER_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.DER_DESC := TRIM(NVL(p_DER_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SERVICE_LOCATION_ID := p_SERVICE_LOCATION_ID;
	v_REC.DER_TYPE_ID := NVL(p_DER_TYPE_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.EXTERNAL_SYSTEM_ID := NVL(p_EXTERNAL_SYSTEM_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.EXTERNAL_IDENTIFIER := TRIM(NVL(p_EXTERNAL_IDENTIFIER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.BEGIN_DATE := p_BEGIN_DATE;
	v_REC.END_DATE := p_END_DATE;
	v_REC.SERIAL_NUMBER := TRIM(NVL(p_SERIAL_NUMBER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_DER_ID > 0 OR p_DER_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_DER_ID, EC.ED_DER) 
                 AND IO_UTIL.DER_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_DER, p_DER_ID);
		END IF;

		-- save it!
		UPDATE DISTRIBUTED_ENERGY_RESOURCE
		SET ROW = v_REC
		WHERE DER_ID = p_DER_ID;
		o_OID := p_DER_ID;
        
	ELSIF p_DER_ID IS NULL OR p_DER_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.DER_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_DER, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.DER_ID := o_OID;
		-- save it!
		INSERT INTO DISTRIBUTED_ENERGY_RESOURCE VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_DER_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_DER, EC.ED_ENTITY_DOMAIN)||': '||p_DER_NAME);
END PUT_DER;
---------------------------------------------------------------------
PROCEDURE GET_DER
	(
	p_DER_ID IN NUMBER,
	p_DER_NAME OUT VARCHAR2,
	p_DER_ALIAS OUT VARCHAR2,
	p_DER_DESC OUT VARCHAR2,
	p_SERVICE_LOCATION_ID OUT NUMBER,
	p_DER_TYPE_ID OUT NUMBER,
	p_EXTERNAL_SYSTEM_ID OUT NUMBER,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE,
	p_SERIAL_NUMBER OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD DISTRIBUTED_ENERGY_RESOURCE%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_DER_ID, EC.ED_DER);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM DISTRIBUTED_ENERGY_RESOURCE
	WHERE DER_ID = p_DER_ID;
    
	-- Set the output parameters
	p_DER_NAME := v_RECORD.DER_NAME;
	p_DER_ALIAS := v_RECORD.DER_ALIAS;
	p_DER_DESC := v_RECORD.DER_DESC;
	p_SERVICE_LOCATION_ID := v_RECORD.SERVICE_LOCATION_ID;
	p_DER_TYPE_ID := v_RECORD.DER_TYPE_ID;
	p_EXTERNAL_SYSTEM_ID := v_RECORD.EXTERNAL_SYSTEM_ID;
	p_EXTERNAL_IDENTIFIER := v_RECORD.EXTERNAL_IDENTIFIER;
	p_BEGIN_DATE := v_RECORD.BEGIN_DATE;
	p_END_DATE := v_RECORD.END_DATE;
	p_SERIAL_NUMBER := v_RECORD.SERIAL_NUMBER;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_DER_NAME := g_EMPTY_VARCHAR2;
		p_DER_ALIAS := g_EMPTY_VARCHAR2;
		p_DER_DESC := g_EMPTY_VARCHAR2;
		p_SERVICE_LOCATION_ID := g_EMPTY_NUMBER;
		p_DER_TYPE_ID := g_EMPTY_NUMBER;
		p_EXTERNAL_SYSTEM_ID := g_EMPTY_NUMBER;
		p_EXTERNAL_IDENTIFIER := g_EMPTY_VARCHAR2;
		p_BEGIN_DATE := g_EMPTY_DATE;
		p_END_DATE := g_EMPTY_DATE;
		p_SERIAL_NUMBER := g_EMPTY_VARCHAR2;

END GET_DER;
---------------------------------------------------------------------
PROCEDURE PUT_DER_TYPE
	(
	o_OID OUT NUMBER,
	p_DER_TYPE_NAME IN VARCHAR2,
	p_DER_TYPE_ALIAS IN VARCHAR2,
	p_DER_TYPE_DESC IN VARCHAR2,
	p_DER_TYPE_ID IN NUMBER,
	p_DER_TYPE_FUNCTION IN VARCHAR2,
	p_DER_TYPE_CATEGORY IN VARCHAR2,
	p_DEFAULT_FAILURE_PCT IN NUMBER,
	p_USE_DEFAULT_FAIL_PCT IN NUMBER,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC DER_TYPE%ROWTYPE;
BEGIN


	v_REC.DER_TYPE_ID := p_DER_TYPE_ID;
	v_REC.DER_TYPE_NAME := TRIM(p_DER_TYPE_NAME);
	v_REC.DER_TYPE_ALIAS := TRIM(NVL(p_DER_TYPE_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.DER_TYPE_DESC := TRIM(NVL(p_DER_TYPE_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.DER_TYPE_FUNCTION := TRIM(NVL(p_DER_TYPE_FUNCTION,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.DER_TYPE_CATEGORY := TRIM(NVL(p_DER_TYPE_CATEGORY,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.DEFAULT_FAILURE_PCT := p_DEFAULT_FAILURE_PCT;
	v_REC.USE_DEFAULT_FAIL_PCT := p_USE_DEFAULT_FAIL_PCT;
	v_REC.EXTERNAL_IDENTIFIER := TRIM(NVL(p_EXTERNAL_IDENTIFIER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_DER_TYPE_ID > 0 OR p_DER_TYPE_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_DER_TYPE_ID, EC.ED_DER_TYPE) 
                 AND IO_UTIL.DER_TYPE_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_DER_TYPE, p_DER_TYPE_ID);
		END IF;

		-- save it!
		UPDATE DER_TYPE
		SET ROW = v_REC
		WHERE DER_TYPE_ID = p_DER_TYPE_ID;
		o_OID := p_DER_TYPE_ID;
        
	ELSIF p_DER_TYPE_ID IS NULL OR p_DER_TYPE_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.DER_TYPE_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_DER_TYPE, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.DER_TYPE_ID := o_OID;
		-- save it!
		INSERT INTO DER_TYPE VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_DER_TYPE_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_DER_TYPE, EC.ED_ENTITY_DOMAIN)||': '||p_DER_TYPE_NAME);
END PUT_DER_TYPE;
---------------------------------------------------------------------
PROCEDURE GET_DER_TYPE
	(
	p_DER_TYPE_ID IN NUMBER,
	p_DER_TYPE_NAME OUT VARCHAR2,
	p_DER_TYPE_ALIAS OUT VARCHAR2,
	p_DER_TYPE_DESC OUT VARCHAR2,
	p_DER_TYPE_FUNCTION OUT VARCHAR2,
	p_DER_TYPE_CATEGORY OUT VARCHAR2,
	p_DEFAULT_FAILURE_PCT OUT NUMBER,
	p_USE_DEFAULT_FAIL_PCT OUT NUMBER,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD DER_TYPE%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_DER_TYPE_ID, EC.ED_DER_TYPE);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM DER_TYPE
	WHERE DER_TYPE_ID = p_DER_TYPE_ID;
    
	-- Set the output parameters
	p_DER_TYPE_NAME := v_RECORD.DER_TYPE_NAME;
	p_DER_TYPE_ALIAS := v_RECORD.DER_TYPE_ALIAS;
	p_DER_TYPE_DESC := v_RECORD.DER_TYPE_DESC;
	p_DER_TYPE_FUNCTION := v_RECORD.DER_TYPE_FUNCTION;
	p_DER_TYPE_CATEGORY := v_RECORD.DER_TYPE_CATEGORY;
	p_DEFAULT_FAILURE_PCT := v_RECORD.DEFAULT_FAILURE_PCT;
	p_USE_DEFAULT_FAIL_PCT := v_RECORD.USE_DEFAULT_FAIL_PCT;
	p_EXTERNAL_IDENTIFIER := v_RECORD.EXTERNAL_IDENTIFIER;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_DER_TYPE_NAME := g_EMPTY_VARCHAR2;
		p_DER_TYPE_ALIAS := g_EMPTY_VARCHAR2;
		p_DER_TYPE_DESC := g_EMPTY_VARCHAR2;
		p_DER_TYPE_FUNCTION := g_EMPTY_VARCHAR2;
		p_DER_TYPE_CATEGORY := g_EMPTY_VARCHAR2;
		p_DEFAULT_FAILURE_PCT := g_EMPTY_NUMBER;
		p_USE_DEFAULT_FAIL_PCT := g_EMPTY_NUMBER;
		p_EXTERNAL_IDENTIFIER := g_EMPTY_VARCHAR2;

END GET_DER_TYPE;
---------------------------------------------------------------------
PROCEDURE PUT_DR_EVENT
	(
	o_OID OUT NUMBER,
	p_EVENT_NAME IN VARCHAR2,
	p_EVENT_ALIAS IN VARCHAR2,
	p_EVENT_DESC IN VARCHAR2,
	p_EVENT_ID IN NUMBER,
	p_VPP_ID IN NUMBER,
	p_EVENT_STATUS IN VARCHAR2,
	p_START_TIME IN DATE,
	p_STOP_TIME IN DATE,
	p_EVENT_TYPE IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC DR_EVENT%ROWTYPE;
BEGIN


	v_REC.EVENT_ID := p_EVENT_ID;
	v_REC.EVENT_NAME := TRIM(p_EVENT_NAME);
	v_REC.EVENT_ALIAS := TRIM(NVL(p_EVENT_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EVENT_DESC := TRIM(NVL(p_EVENT_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.VPP_ID := NVL(p_VPP_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.EVENT_STATUS := TRIM(NVL(p_EVENT_STATUS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.START_TIME := p_START_TIME;
	v_REC.STOP_TIME := p_STOP_TIME;
	v_REC.EVENT_TYPE := TRIM(NVL(p_EVENT_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_EVENT_ID > 0 OR p_EVENT_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_EVENT_ID, EC.ED_DR_EVENT) 
                 AND IO_UTIL.DR_EVENT_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_DR_EVENT, p_EVENT_ID);
		END IF;

		-- save it!
		UPDATE DR_EVENT
		SET ROW = v_REC
		WHERE EVENT_ID = p_EVENT_ID;
		o_OID := p_EVENT_ID;
        
	ELSIF p_EVENT_ID IS NULL OR p_EVENT_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.DR_EVENT_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_DR_EVENT, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.EVENT_ID := o_OID;
		-- save it!
		INSERT INTO DR_EVENT VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_EVENT_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_DR_EVENT, EC.ED_ENTITY_DOMAIN)||': '||p_EVENT_NAME);
END PUT_DR_EVENT;
---------------------------------------------------------------------
PROCEDURE GET_DR_EVENT
	(
	p_EVENT_ID IN NUMBER,
	p_EVENT_NAME OUT VARCHAR2,
	p_EVENT_ALIAS OUT VARCHAR2,
	p_EVENT_DESC OUT VARCHAR2,
	p_VPP_ID OUT NUMBER,
	p_EVENT_STATUS OUT VARCHAR2,
	p_START_TIME OUT DATE,
	p_STOP_TIME OUT DATE,
	p_EVENT_TYPE OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD DR_EVENT%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_EVENT_ID, EC.ED_DR_EVENT);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM DR_EVENT
	WHERE EVENT_ID = p_EVENT_ID;
    
	-- Set the output parameters
	p_EVENT_NAME := v_RECORD.EVENT_NAME;
	p_EVENT_ALIAS := v_RECORD.EVENT_ALIAS;
	p_EVENT_DESC := v_RECORD.EVENT_DESC;
	p_VPP_ID := v_RECORD.VPP_ID;
	p_EVENT_STATUS := v_RECORD.EVENT_STATUS;
	p_START_TIME := v_RECORD.START_TIME;
	p_STOP_TIME := v_RECORD.STOP_TIME;
	p_EVENT_TYPE := v_RECORD.EVENT_TYPE;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_EVENT_NAME := g_EMPTY_VARCHAR2;
		p_EVENT_ALIAS := g_EMPTY_VARCHAR2;
		p_EVENT_DESC := g_EMPTY_VARCHAR2;
		p_VPP_ID := g_EMPTY_NUMBER;
		p_EVENT_STATUS := g_EMPTY_VARCHAR2;
		p_START_TIME := g_EMPTY_DATE;
		p_STOP_TIME := g_EMPTY_DATE;
		p_EVENT_TYPE := g_EMPTY_VARCHAR2;

END GET_DR_EVENT;
---------------------------------------------------------------------
PROCEDURE PUT_EDC
	(
	o_OID OUT NUMBER,
	p_EDC_NAME IN VARCHAR2,
	p_EDC_ALIAS IN VARCHAR2,
	p_EDC_DESC IN VARCHAR2,
	p_EDC_ID IN NUMBER,
	p_EDC_STATUS IN VARCHAR2,
	p_EDC_DUNS_NUMBER IN VARCHAR2,
	p_EDC_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_EDC_SETTLEMENT_AGENT_NAME IN VARCHAR2,
	p_EDC_LOSS_FACTOR_OPTION IN VARCHAR2,
	p_EDC_SYSTEM_LOAD_ID IN NUMBER,
	p_EDC_MARKET_PRICE_ID IN NUMBER,
	p_EDC_HOLIDAY_SET_ID IN NUMBER,
	p_EDC_SC_ID IN NUMBER,
	p_EDC_EXCLUDE_LOAD_SCHEDULE IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC ENERGY_DISTRIBUTION_COMPANY%ROWTYPE;
BEGIN


	v_REC.EDC_ID := p_EDC_ID;
	v_REC.EDC_NAME := TRIM(p_EDC_NAME);
	v_REC.EDC_ALIAS := TRIM(NVL(p_EDC_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EDC_DESC := TRIM(NVL(p_EDC_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EDC_STATUS := TRIM(NVL(p_EDC_STATUS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EDC_DUNS_NUMBER := TRIM(NVL(p_EDC_DUNS_NUMBER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EDC_EXTERNAL_IDENTIFIER := TRIM(NVL(p_EDC_EXTERNAL_IDENTIFIER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EDC_SETTLEMENT_AGENT_NAME := TRIM(NVL(p_EDC_SETTLEMENT_AGENT_NAME,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EDC_LOSS_FACTOR_OPTION := TRIM(NVL(p_EDC_LOSS_FACTOR_OPTION,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EDC_SYSTEM_LOAD_ID := p_EDC_SYSTEM_LOAD_ID;
	v_REC.EDC_MARKET_PRICE_ID := NVL(p_EDC_MARKET_PRICE_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.EDC_HOLIDAY_SET_ID := NVL(p_EDC_HOLIDAY_SET_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.EDC_SC_ID := NVL(p_EDC_SC_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.EDC_EXCLUDE_LOAD_SCHEDULE := p_EDC_EXCLUDE_LOAD_SCHEDULE;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_EDC_ID > 0 OR p_EDC_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_EDC_ID, EC.ED_EDC) 
                 AND IO_UTIL.EDC_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_EDC, p_EDC_ID);
		END IF;

		-- save it!
		UPDATE ENERGY_DISTRIBUTION_COMPANY
		SET ROW = v_REC
		WHERE EDC_ID = p_EDC_ID;
		o_OID := p_EDC_ID;
        
	ELSIF p_EDC_ID IS NULL OR p_EDC_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.EDC_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_EDC, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.EDC_ID := o_OID;
		-- save it!
		INSERT INTO ENERGY_DISTRIBUTION_COMPANY VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_EDC_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_EDC, EC.ED_ENTITY_DOMAIN)||': '||p_EDC_NAME);
END PUT_EDC;
---------------------------------------------------------------------
PROCEDURE GET_EDC
	(
	p_EDC_ID IN NUMBER,
	p_EDC_NAME OUT VARCHAR2,
	p_EDC_ALIAS OUT VARCHAR2,
	p_EDC_DESC OUT VARCHAR2,
	p_EDC_STATUS OUT VARCHAR2,
	p_EDC_DUNS_NUMBER OUT VARCHAR2,
	p_EDC_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_EDC_SETTLEMENT_AGENT_NAME OUT VARCHAR2,
	p_EDC_LOSS_FACTOR_OPTION OUT VARCHAR2,
	p_EDC_SYSTEM_LOAD_ID OUT NUMBER,
	p_EDC_MARKET_PRICE_ID OUT NUMBER,
	p_EDC_HOLIDAY_SET_ID OUT NUMBER,
	p_EDC_SC_ID OUT NUMBER,
	p_EDC_EXCLUDE_LOAD_SCHEDULE OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD ENERGY_DISTRIBUTION_COMPANY%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_EDC_ID, EC.ED_EDC);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM ENERGY_DISTRIBUTION_COMPANY
	WHERE EDC_ID = p_EDC_ID;
    
	-- Set the output parameters
	p_EDC_NAME := v_RECORD.EDC_NAME;
	p_EDC_ALIAS := v_RECORD.EDC_ALIAS;
	p_EDC_DESC := v_RECORD.EDC_DESC;
	p_EDC_STATUS := v_RECORD.EDC_STATUS;
	p_EDC_DUNS_NUMBER := v_RECORD.EDC_DUNS_NUMBER;
	p_EDC_EXTERNAL_IDENTIFIER := v_RECORD.EDC_EXTERNAL_IDENTIFIER;
	p_EDC_SETTLEMENT_AGENT_NAME := v_RECORD.EDC_SETTLEMENT_AGENT_NAME;
	p_EDC_LOSS_FACTOR_OPTION := v_RECORD.EDC_LOSS_FACTOR_OPTION;
	p_EDC_SYSTEM_LOAD_ID := v_RECORD.EDC_SYSTEM_LOAD_ID;
	p_EDC_MARKET_PRICE_ID := v_RECORD.EDC_MARKET_PRICE_ID;
	p_EDC_HOLIDAY_SET_ID := v_RECORD.EDC_HOLIDAY_SET_ID;
	p_EDC_SC_ID := v_RECORD.EDC_SC_ID;
	p_EDC_EXCLUDE_LOAD_SCHEDULE := v_RECORD.EDC_EXCLUDE_LOAD_SCHEDULE;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_EDC_NAME := g_EMPTY_VARCHAR2;
		p_EDC_ALIAS := g_EMPTY_VARCHAR2;
		p_EDC_DESC := g_EMPTY_VARCHAR2;
		p_EDC_STATUS := g_EMPTY_VARCHAR2;
		p_EDC_DUNS_NUMBER := g_EMPTY_VARCHAR2;
		p_EDC_EXTERNAL_IDENTIFIER := g_EMPTY_VARCHAR2;
		p_EDC_SETTLEMENT_AGENT_NAME := g_EMPTY_VARCHAR2;
		p_EDC_LOSS_FACTOR_OPTION := g_EMPTY_VARCHAR2;
		p_EDC_SYSTEM_LOAD_ID := g_EMPTY_NUMBER;
		p_EDC_MARKET_PRICE_ID := g_EMPTY_NUMBER;
		p_EDC_HOLIDAY_SET_ID := g_EMPTY_NUMBER;
		p_EDC_SC_ID := g_EMPTY_NUMBER;
		p_EDC_EXCLUDE_LOAD_SCHEDULE := g_EMPTY_NUMBER;

END GET_EDC;
---------------------------------------------------------------------
PROCEDURE PUT_ENTITY_DOMAIN
	(
	o_OID OUT NUMBER,
	p_ENTITY_DOMAIN_NAME IN VARCHAR2,
	p_ENTITY_DOMAIN_ALIAS IN VARCHAR2,
	p_ENTITY_DOMAIN_DESC IN VARCHAR2,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ENTITY_DOMAIN_TABLE IN VARCHAR2,
	p_ENTITY_DOMAIN_TABLE_ALIAS IN VARCHAR2,
	p_ENTITY_DOMAIN_CATEGORY IN VARCHAR2,
	p_DISPLAY_NAME IN VARCHAR2,
	p_INCLUDE_CONTACT_ADDRESS IN NUMBER,
	p_INCLUDE_ENTITY_ATTRIBUTE IN NUMBER,
	p_INCLUDE_EXTERNAL_IDENTIFIER IN NUMBER,
	p_INCLUDE_GROUPS IN NUMBER,
	p_INCLUDE_NOTES IN NUMBER,
	p_IS_PSEUDO IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC ENTITY_DOMAIN%ROWTYPE;
BEGIN


	v_REC.ENTITY_DOMAIN_ID := p_ENTITY_DOMAIN_ID;
	v_REC.ENTITY_DOMAIN_NAME := TRIM(p_ENTITY_DOMAIN_NAME);
	v_REC.ENTITY_DOMAIN_ALIAS := TRIM(NVL(p_ENTITY_DOMAIN_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTITY_DOMAIN_DESC := TRIM(NVL(p_ENTITY_DOMAIN_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTITY_DOMAIN_TABLE := TRIM(p_ENTITY_DOMAIN_TABLE);
	v_REC.ENTITY_DOMAIN_TABLE_ALIAS := TRIM(p_ENTITY_DOMAIN_TABLE_ALIAS);
	v_REC.ENTITY_DOMAIN_CATEGORY := TRIM(p_ENTITY_DOMAIN_CATEGORY);
	v_REC.DISPLAY_NAME := TRIM(p_DISPLAY_NAME);
	v_REC.INCLUDE_CONTACT_ADDRESS := p_INCLUDE_CONTACT_ADDRESS;
	v_REC.INCLUDE_ENTITY_ATTRIBUTE := p_INCLUDE_ENTITY_ATTRIBUTE;
	v_REC.INCLUDE_EXTERNAL_IDENTIFIER := p_INCLUDE_EXTERNAL_IDENTIFIER;
	v_REC.INCLUDE_GROUPS := p_INCLUDE_GROUPS;
	v_REC.INCLUDE_NOTES := p_INCLUDE_NOTES;
	v_REC.IS_PSEUDO := p_IS_PSEUDO;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_ENTITY_DOMAIN_ID > 0 OR p_ENTITY_DOMAIN_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ENTITY_DOMAIN_ID, EC.ED_ENTITY_DOMAIN) 
                 AND IO_UTIL.ENTITY_DOMAIN_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_ENTITY_DOMAIN, p_ENTITY_DOMAIN_ID);
		END IF;

		-- save it!
		UPDATE ENTITY_DOMAIN
		SET ROW = v_REC
		WHERE ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID;
		o_OID := p_ENTITY_DOMAIN_ID;
        
	ELSIF p_ENTITY_DOMAIN_ID IS NULL OR p_ENTITY_DOMAIN_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.ENTITY_DOMAIN_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_ENTITY_DOMAIN, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.ENTITY_DOMAIN_ID := o_OID;
		-- save it!
		INSERT INTO ENTITY_DOMAIN VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_ENTITY_DOMAIN_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_ENTITY_DOMAIN, EC.ED_ENTITY_DOMAIN)||': '||p_ENTITY_DOMAIN_NAME);
END PUT_ENTITY_DOMAIN;
---------------------------------------------------------------------
PROCEDURE GET_ENTITY_DOMAIN
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ENTITY_DOMAIN_NAME OUT VARCHAR2,
	p_ENTITY_DOMAIN_ALIAS OUT VARCHAR2,
	p_ENTITY_DOMAIN_DESC OUT VARCHAR2,
	p_ENTITY_DOMAIN_TABLE OUT VARCHAR2,
	p_ENTITY_DOMAIN_TABLE_ALIAS OUT VARCHAR2,
	p_ENTITY_DOMAIN_CATEGORY OUT VARCHAR2,
	p_DISPLAY_NAME OUT VARCHAR2,
	p_INCLUDE_CONTACT_ADDRESS OUT NUMBER,
	p_INCLUDE_ENTITY_ATTRIBUTE OUT NUMBER,
	p_INCLUDE_EXTERNAL_IDENTIFIER OUT NUMBER,
	p_INCLUDE_GROUPS OUT NUMBER,
	p_INCLUDE_NOTES OUT NUMBER,
	p_IS_PSEUDO OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD ENTITY_DOMAIN%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ENTITY_DOMAIN_ID, EC.ED_ENTITY_DOMAIN);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM ENTITY_DOMAIN
	WHERE ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID;
    
	-- Set the output parameters
	p_ENTITY_DOMAIN_NAME := v_RECORD.ENTITY_DOMAIN_NAME;
	p_ENTITY_DOMAIN_ALIAS := v_RECORD.ENTITY_DOMAIN_ALIAS;
	p_ENTITY_DOMAIN_DESC := v_RECORD.ENTITY_DOMAIN_DESC;
	p_ENTITY_DOMAIN_TABLE := v_RECORD.ENTITY_DOMAIN_TABLE;
	p_ENTITY_DOMAIN_TABLE_ALIAS := v_RECORD.ENTITY_DOMAIN_TABLE_ALIAS;
	p_ENTITY_DOMAIN_CATEGORY := v_RECORD.ENTITY_DOMAIN_CATEGORY;
	p_DISPLAY_NAME := v_RECORD.DISPLAY_NAME;
	p_INCLUDE_CONTACT_ADDRESS := v_RECORD.INCLUDE_CONTACT_ADDRESS;
	p_INCLUDE_ENTITY_ATTRIBUTE := v_RECORD.INCLUDE_ENTITY_ATTRIBUTE;
	p_INCLUDE_EXTERNAL_IDENTIFIER := v_RECORD.INCLUDE_EXTERNAL_IDENTIFIER;
	p_INCLUDE_GROUPS := v_RECORD.INCLUDE_GROUPS;
	p_INCLUDE_NOTES := v_RECORD.INCLUDE_NOTES;
	p_IS_PSEUDO := v_RECORD.IS_PSEUDO;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_ENTITY_DOMAIN_NAME := g_EMPTY_VARCHAR2;
		p_ENTITY_DOMAIN_ALIAS := g_EMPTY_VARCHAR2;
		p_ENTITY_DOMAIN_DESC := g_EMPTY_VARCHAR2;
		p_ENTITY_DOMAIN_TABLE := g_EMPTY_VARCHAR2;
		p_ENTITY_DOMAIN_TABLE_ALIAS := g_EMPTY_VARCHAR2;
		p_ENTITY_DOMAIN_CATEGORY := g_EMPTY_VARCHAR2;
		p_DISPLAY_NAME := g_EMPTY_VARCHAR2;
		p_INCLUDE_CONTACT_ADDRESS := g_EMPTY_NUMBER;
		p_INCLUDE_ENTITY_ATTRIBUTE := g_EMPTY_NUMBER;
		p_INCLUDE_EXTERNAL_IDENTIFIER := g_EMPTY_NUMBER;
		p_INCLUDE_GROUPS := g_EMPTY_NUMBER;
		p_INCLUDE_NOTES := g_EMPTY_NUMBER;
		p_IS_PSEUDO := g_EMPTY_NUMBER;

END GET_ENTITY_DOMAIN;
---------------------------------------------------------------------
PROCEDURE PUT_ENTITY_GROUP
	(
	o_OID OUT NUMBER,
	p_ENTITY_GROUP_NAME IN VARCHAR2,
	p_ENTITY_GROUP_ALIAS IN VARCHAR2,
	p_ENTITY_GROUP_DESC IN VARCHAR2,
	p_ENTITY_GROUP_ID IN NUMBER,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_PARENT_GROUP_ID IN NUMBER,
	p_IS_MATRIX IN NUMBER,
	p_GROUP_CATEGORY IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC ENTITY_GROUP%ROWTYPE;
BEGIN


	v_REC.ENTITY_GROUP_ID := p_ENTITY_GROUP_ID;
	v_REC.ENTITY_GROUP_NAME := TRIM(p_ENTITY_GROUP_NAME);
	v_REC.ENTITY_GROUP_ALIAS := TRIM(NVL(p_ENTITY_GROUP_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTITY_GROUP_DESC := TRIM(NVL(p_ENTITY_GROUP_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTITY_DOMAIN_ID := NVL(p_ENTITY_DOMAIN_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.PARENT_GROUP_ID := p_PARENT_GROUP_ID;
	v_REC.IS_MATRIX := p_IS_MATRIX;
	v_REC.GROUP_CATEGORY := TRIM(p_GROUP_CATEGORY);
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_ENTITY_GROUP_ID > 0 OR p_ENTITY_GROUP_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ENTITY_GROUP_ID, EC.ED_ENTITY_GROUP) 
                 AND IO_UTIL.ENTITY_GROUP_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_ENTITY_GROUP, p_ENTITY_GROUP_ID);
		END IF;

		-- save it!
		UPDATE ENTITY_GROUP
		SET ROW = v_REC
		WHERE ENTITY_GROUP_ID = p_ENTITY_GROUP_ID;
		o_OID := p_ENTITY_GROUP_ID;
        
	ELSIF p_ENTITY_GROUP_ID IS NULL OR p_ENTITY_GROUP_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.ENTITY_GROUP_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_ENTITY_GROUP, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.ENTITY_GROUP_ID := o_OID;
		-- save it!
		INSERT INTO ENTITY_GROUP VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_ENTITY_GROUP_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_ENTITY_GROUP, EC.ED_ENTITY_DOMAIN)||': '||p_ENTITY_GROUP_NAME);
END PUT_ENTITY_GROUP;
---------------------------------------------------------------------
PROCEDURE GET_ENTITY_GROUP
	(
	p_ENTITY_GROUP_ID IN NUMBER,
	p_ENTITY_GROUP_NAME OUT VARCHAR2,
	p_ENTITY_GROUP_ALIAS OUT VARCHAR2,
	p_ENTITY_GROUP_DESC OUT VARCHAR2,
	p_ENTITY_DOMAIN_ID OUT NUMBER,
	p_PARENT_GROUP_ID OUT NUMBER,
	p_IS_MATRIX OUT NUMBER,
	p_GROUP_CATEGORY OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD ENTITY_GROUP%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ENTITY_GROUP_ID, EC.ED_ENTITY_GROUP);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM ENTITY_GROUP
	WHERE ENTITY_GROUP_ID = p_ENTITY_GROUP_ID;
    
	-- Set the output parameters
	p_ENTITY_GROUP_NAME := v_RECORD.ENTITY_GROUP_NAME;
	p_ENTITY_GROUP_ALIAS := v_RECORD.ENTITY_GROUP_ALIAS;
	p_ENTITY_GROUP_DESC := v_RECORD.ENTITY_GROUP_DESC;
	p_ENTITY_DOMAIN_ID := v_RECORD.ENTITY_DOMAIN_ID;
	p_PARENT_GROUP_ID := v_RECORD.PARENT_GROUP_ID;
	p_IS_MATRIX := v_RECORD.IS_MATRIX;
	p_GROUP_CATEGORY := v_RECORD.GROUP_CATEGORY;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_ENTITY_GROUP_NAME := g_EMPTY_VARCHAR2;
		p_ENTITY_GROUP_ALIAS := g_EMPTY_VARCHAR2;
		p_ENTITY_GROUP_DESC := g_EMPTY_VARCHAR2;
		p_ENTITY_DOMAIN_ID := g_EMPTY_NUMBER;
		p_PARENT_GROUP_ID := g_EMPTY_NUMBER;
		p_IS_MATRIX := g_EMPTY_NUMBER;
		p_GROUP_CATEGORY := g_EMPTY_VARCHAR2;

END GET_ENTITY_GROUP;
---------------------------------------------------------------------
PROCEDURE PUT_ESP
	(
	o_OID OUT NUMBER,
	p_ESP_NAME IN VARCHAR2,
	p_ESP_ALIAS IN VARCHAR2,
	p_ESP_DESC IN VARCHAR2,
	p_ESP_ID IN NUMBER,
	p_ESP_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_ESP_DUNS_NUMBER IN VARCHAR2,
	p_ESP_STATUS IN VARCHAR2,
	p_ESP_TYPE IN VARCHAR2,
	p_ESP_EXCLUDE_LOAD_SCHEDULE IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC ENERGY_SERVICE_PROVIDER%ROWTYPE;
BEGIN


	v_REC.ESP_ID := p_ESP_ID;
	v_REC.ESP_NAME := TRIM(p_ESP_NAME);
	v_REC.ESP_ALIAS := TRIM(NVL(p_ESP_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ESP_DESC := TRIM(NVL(p_ESP_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ESP_EXTERNAL_IDENTIFIER := TRIM(NVL(p_ESP_EXTERNAL_IDENTIFIER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ESP_DUNS_NUMBER := TRIM(NVL(p_ESP_DUNS_NUMBER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ESP_STATUS := TRIM(NVL(p_ESP_STATUS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ESP_TYPE := TRIM(NVL(p_ESP_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ESP_EXCLUDE_LOAD_SCHEDULE := p_ESP_EXCLUDE_LOAD_SCHEDULE;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_ESP_ID > 0 OR p_ESP_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ESP_ID, EC.ED_ESP) 
                 AND IO_UTIL.ESP_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_ESP, p_ESP_ID);
		END IF;

		-- save it!
		UPDATE ENERGY_SERVICE_PROVIDER
		SET ROW = v_REC
		WHERE ESP_ID = p_ESP_ID;
		o_OID := p_ESP_ID;
        
	ELSIF p_ESP_ID IS NULL OR p_ESP_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.ESP_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_ESP, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.ESP_ID := o_OID;
		-- save it!
		INSERT INTO ENERGY_SERVICE_PROVIDER VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_ESP_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_ESP, EC.ED_ENTITY_DOMAIN)||': '||p_ESP_NAME);
END PUT_ESP;
---------------------------------------------------------------------
PROCEDURE GET_ESP
	(
	p_ESP_ID IN NUMBER,
	p_ESP_NAME OUT VARCHAR2,
	p_ESP_ALIAS OUT VARCHAR2,
	p_ESP_DESC OUT VARCHAR2,
	p_ESP_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_ESP_DUNS_NUMBER OUT VARCHAR2,
	p_ESP_STATUS OUT VARCHAR2,
	p_ESP_TYPE OUT VARCHAR2,
	p_ESP_EXCLUDE_LOAD_SCHEDULE OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD ENERGY_SERVICE_PROVIDER%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ESP_ID, EC.ED_ESP);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM ENERGY_SERVICE_PROVIDER
	WHERE ESP_ID = p_ESP_ID;
    
	-- Set the output parameters
	p_ESP_NAME := v_RECORD.ESP_NAME;
	p_ESP_ALIAS := v_RECORD.ESP_ALIAS;
	p_ESP_DESC := v_RECORD.ESP_DESC;
	p_ESP_EXTERNAL_IDENTIFIER := v_RECORD.ESP_EXTERNAL_IDENTIFIER;
	p_ESP_DUNS_NUMBER := v_RECORD.ESP_DUNS_NUMBER;
	p_ESP_STATUS := v_RECORD.ESP_STATUS;
	p_ESP_TYPE := v_RECORD.ESP_TYPE;
	p_ESP_EXCLUDE_LOAD_SCHEDULE := v_RECORD.ESP_EXCLUDE_LOAD_SCHEDULE;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_ESP_NAME := g_EMPTY_VARCHAR2;
		p_ESP_ALIAS := g_EMPTY_VARCHAR2;
		p_ESP_DESC := g_EMPTY_VARCHAR2;
		p_ESP_EXTERNAL_IDENTIFIER := g_EMPTY_VARCHAR2;
		p_ESP_DUNS_NUMBER := g_EMPTY_VARCHAR2;
		p_ESP_STATUS := g_EMPTY_VARCHAR2;
		p_ESP_TYPE := g_EMPTY_VARCHAR2;
		p_ESP_EXCLUDE_LOAD_SCHEDULE := g_EMPTY_NUMBER;

END GET_ESP;
---------------------------------------------------------------------
PROCEDURE PUT_ETAG
	(
	o_OID OUT NUMBER,
	p_ETAG_NAME IN VARCHAR2,
	p_ETAG_ALIAS IN VARCHAR2,
	p_ETAG_DESC IN VARCHAR2,
	p_ETAG_ID IN NUMBER,
	p_TAG_IDENT IN VARCHAR2,
	p_GCA_CODE IN VARCHAR2,
	p_PSE_CODE IN VARCHAR2,
	p_TAG_CODE IN VARCHAR2,
	p_LCA_CODE IN VARCHAR2,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_ETAG_STATUS IN VARCHAR2,
	p_SECURITY_KEY IN VARCHAR2,
	p_WSCC_PRESCHEDULE_FLAG IN VARCHAR2,
	p_TEST_FLAG IN VARCHAR2,
	p_TRANSACTION_TYPE IN VARCHAR2,
	p_NOTES IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC ETAG%ROWTYPE;
BEGIN


	v_REC.ETAG_ID := p_ETAG_ID;
	v_REC.ETAG_NAME := TRIM(p_ETAG_NAME);
	v_REC.ETAG_ALIAS := TRIM(NVL(p_ETAG_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ETAG_DESC := TRIM(NVL(p_ETAG_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.TAG_IDENT := TRIM(NVL(p_TAG_IDENT,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.GCA_CODE := TRIM(NVL(p_GCA_CODE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PSE_CODE := TRIM(NVL(p_PSE_CODE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.TAG_CODE := TRIM(NVL(p_TAG_CODE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.LCA_CODE := TRIM(NVL(p_LCA_CODE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EXTERNAL_IDENTIFIER := TRIM(NVL(p_EXTERNAL_IDENTIFIER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ETAG_STATUS := TRIM(NVL(p_ETAG_STATUS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SECURITY_KEY := TRIM(NVL(p_SECURITY_KEY,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.WSCC_PRESCHEDULE_FLAG := TRIM(NVL(p_WSCC_PRESCHEDULE_FLAG,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.TEST_FLAG := TRIM(NVL(p_TEST_FLAG,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.TRANSACTION_TYPE := TRIM(NVL(p_TRANSACTION_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.NOTES := TRIM(NVL(p_NOTES,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_ETAG_ID > 0 OR p_ETAG_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ETAG_ID, EC.ED_ETAG) 
                 AND IO_UTIL.ETAG_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_ETAG, p_ETAG_ID);
		END IF;

		-- save it!
		UPDATE ETAG
		SET ROW = v_REC
		WHERE ETAG_ID = p_ETAG_ID;
		o_OID := p_ETAG_ID;
        
	ELSIF p_ETAG_ID IS NULL OR p_ETAG_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.ETAG_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_ETAG, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.ETAG_ID := o_OID;
		-- save it!
		INSERT INTO ETAG VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_ETAG_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_ETAG, EC.ED_ENTITY_DOMAIN)||': '||p_ETAG_NAME);
END PUT_ETAG;
---------------------------------------------------------------------
PROCEDURE GET_ETAG
	(
	p_ETAG_ID IN NUMBER,
	p_ETAG_NAME OUT VARCHAR2,
	p_ETAG_ALIAS OUT VARCHAR2,
	p_ETAG_DESC OUT VARCHAR2,
	p_TAG_IDENT OUT VARCHAR2,
	p_GCA_CODE OUT VARCHAR2,
	p_PSE_CODE OUT VARCHAR2,
	p_TAG_CODE OUT VARCHAR2,
	p_LCA_CODE OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_ETAG_STATUS OUT VARCHAR2,
	p_SECURITY_KEY OUT VARCHAR2,
	p_WSCC_PRESCHEDULE_FLAG OUT VARCHAR2,
	p_TEST_FLAG OUT VARCHAR2,
	p_TRANSACTION_TYPE OUT VARCHAR2,
	p_NOTES OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD ETAG%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ETAG_ID, EC.ED_ETAG);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM ETAG
	WHERE ETAG_ID = p_ETAG_ID;
    
	-- Set the output parameters
	p_ETAG_NAME := v_RECORD.ETAG_NAME;
	p_ETAG_ALIAS := v_RECORD.ETAG_ALIAS;
	p_ETAG_DESC := v_RECORD.ETAG_DESC;
	p_TAG_IDENT := v_RECORD.TAG_IDENT;
	p_GCA_CODE := v_RECORD.GCA_CODE;
	p_PSE_CODE := v_RECORD.PSE_CODE;
	p_TAG_CODE := v_RECORD.TAG_CODE;
	p_LCA_CODE := v_RECORD.LCA_CODE;
	p_EXTERNAL_IDENTIFIER := v_RECORD.EXTERNAL_IDENTIFIER;
	p_ETAG_STATUS := v_RECORD.ETAG_STATUS;
	p_SECURITY_KEY := v_RECORD.SECURITY_KEY;
	p_WSCC_PRESCHEDULE_FLAG := v_RECORD.WSCC_PRESCHEDULE_FLAG;
	p_TEST_FLAG := v_RECORD.TEST_FLAG;
	p_TRANSACTION_TYPE := v_RECORD.TRANSACTION_TYPE;
	p_NOTES := v_RECORD.NOTES;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_ETAG_NAME := g_EMPTY_VARCHAR2;
		p_ETAG_ALIAS := g_EMPTY_VARCHAR2;
		p_ETAG_DESC := g_EMPTY_VARCHAR2;
		p_TAG_IDENT := g_EMPTY_VARCHAR2;
		p_GCA_CODE := g_EMPTY_VARCHAR2;
		p_PSE_CODE := g_EMPTY_VARCHAR2;
		p_TAG_CODE := g_EMPTY_VARCHAR2;
		p_LCA_CODE := g_EMPTY_VARCHAR2;
		p_EXTERNAL_IDENTIFIER := g_EMPTY_VARCHAR2;
		p_ETAG_STATUS := g_EMPTY_VARCHAR2;
		p_SECURITY_KEY := g_EMPTY_VARCHAR2;
		p_WSCC_PRESCHEDULE_FLAG := g_EMPTY_VARCHAR2;
		p_TEST_FLAG := g_EMPTY_VARCHAR2;
		p_TRANSACTION_TYPE := g_EMPTY_VARCHAR2;
		p_NOTES := g_EMPTY_VARCHAR2;

END GET_ETAG;
---------------------------------------------------------------------
PROCEDURE PUT_EXTERNAL_SYSTEM
	(
	o_OID OUT NUMBER,
	p_EXTERNAL_SYSTEM_NAME IN VARCHAR2,
	p_EXTERNAL_SYSTEM_ALIAS IN VARCHAR2,
	p_EXTERNAL_SYSTEM_DESC IN VARCHAR2,
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_EXTERNAL_SYSTEM_TYPE IN VARCHAR2,
	p_EXTERNAL_SYSTEM_DISPLAY_NAME IN VARCHAR2,
	p_IS_ENABLED IN NUMBER,
	p_EXTERNAL_ACCOUNT_DOMAIN_ID IN NUMBER,
	p_HAS_UNAME_PWD_CREDENTIALS IN NUMBER,
	p_NUMBER_OF_CERTIFICATES IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC EXTERNAL_SYSTEM%ROWTYPE;
BEGIN


	v_REC.EXTERNAL_SYSTEM_ID := p_EXTERNAL_SYSTEM_ID;
	v_REC.EXTERNAL_SYSTEM_NAME := TRIM(p_EXTERNAL_SYSTEM_NAME);
	v_REC.EXTERNAL_SYSTEM_ALIAS := TRIM(NVL(p_EXTERNAL_SYSTEM_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EXTERNAL_SYSTEM_DESC := TRIM(NVL(p_EXTERNAL_SYSTEM_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EXTERNAL_SYSTEM_TYPE := TRIM(NVL(p_EXTERNAL_SYSTEM_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EXTERNAL_SYSTEM_DISPLAY_NAME := TRIM(NVL(p_EXTERNAL_SYSTEM_DISPLAY_NAME,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.IS_ENABLED := p_IS_ENABLED;
	v_REC.EXTERNAL_ACCOUNT_DOMAIN_ID := NVL(p_EXTERNAL_ACCOUNT_DOMAIN_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.HAS_UNAME_PWD_CREDENTIALS := p_HAS_UNAME_PWD_CREDENTIALS;
	v_REC.NUMBER_OF_CERTIFICATES := p_NUMBER_OF_CERTIFICATES;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_EXTERNAL_SYSTEM_ID > 0 OR p_EXTERNAL_SYSTEM_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_EXTERNAL_SYSTEM_ID, EC.ED_EXTERNAL_SYSTEM) 
                 AND IO_UTIL.EXTERNAL_SYSTEM_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_EXTERNAL_SYSTEM, p_EXTERNAL_SYSTEM_ID);
		END IF;

		-- save it!
		UPDATE EXTERNAL_SYSTEM
		SET ROW = v_REC
		WHERE EXTERNAL_SYSTEM_ID = p_EXTERNAL_SYSTEM_ID;
		o_OID := p_EXTERNAL_SYSTEM_ID;
        
	ELSIF p_EXTERNAL_SYSTEM_ID IS NULL OR p_EXTERNAL_SYSTEM_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.EXTERNAL_SYSTEM_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_EXTERNAL_SYSTEM, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.EXTERNAL_SYSTEM_ID := o_OID;
		-- save it!
		INSERT INTO EXTERNAL_SYSTEM VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_EXTERNAL_SYSTEM_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_EXTERNAL_SYSTEM, EC.ED_ENTITY_DOMAIN)||': '||p_EXTERNAL_SYSTEM_NAME);
END PUT_EXTERNAL_SYSTEM;
---------------------------------------------------------------------
PROCEDURE GET_EXTERNAL_SYSTEM
	(
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_EXTERNAL_SYSTEM_NAME OUT VARCHAR2,
	p_EXTERNAL_SYSTEM_ALIAS OUT VARCHAR2,
	p_EXTERNAL_SYSTEM_DESC OUT VARCHAR2,
	p_EXTERNAL_SYSTEM_TYPE OUT VARCHAR2,
	p_EXTERNAL_SYSTEM_DISPLAY_NAME OUT VARCHAR2,
	p_IS_ENABLED OUT NUMBER,
	p_EXTERNAL_ACCOUNT_DOMAIN_ID OUT NUMBER,
	p_HAS_UNAME_PWD_CREDENTIALS OUT NUMBER,
	p_NUMBER_OF_CERTIFICATES OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD EXTERNAL_SYSTEM%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_EXTERNAL_SYSTEM_ID, EC.ED_EXTERNAL_SYSTEM);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM EXTERNAL_SYSTEM
	WHERE EXTERNAL_SYSTEM_ID = p_EXTERNAL_SYSTEM_ID;
    
	-- Set the output parameters
	p_EXTERNAL_SYSTEM_NAME := v_RECORD.EXTERNAL_SYSTEM_NAME;
	p_EXTERNAL_SYSTEM_ALIAS := v_RECORD.EXTERNAL_SYSTEM_ALIAS;
	p_EXTERNAL_SYSTEM_DESC := v_RECORD.EXTERNAL_SYSTEM_DESC;
	p_EXTERNAL_SYSTEM_TYPE := v_RECORD.EXTERNAL_SYSTEM_TYPE;
	p_EXTERNAL_SYSTEM_DISPLAY_NAME := v_RECORD.EXTERNAL_SYSTEM_DISPLAY_NAME;
	p_IS_ENABLED := v_RECORD.IS_ENABLED;
	p_EXTERNAL_ACCOUNT_DOMAIN_ID := v_RECORD.EXTERNAL_ACCOUNT_DOMAIN_ID;
	p_HAS_UNAME_PWD_CREDENTIALS := v_RECORD.HAS_UNAME_PWD_CREDENTIALS;
	p_NUMBER_OF_CERTIFICATES := v_RECORD.NUMBER_OF_CERTIFICATES;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_EXTERNAL_SYSTEM_NAME := g_EMPTY_VARCHAR2;
		p_EXTERNAL_SYSTEM_ALIAS := g_EMPTY_VARCHAR2;
		p_EXTERNAL_SYSTEM_DESC := g_EMPTY_VARCHAR2;
		p_EXTERNAL_SYSTEM_TYPE := g_EMPTY_VARCHAR2;
		p_EXTERNAL_SYSTEM_DISPLAY_NAME := g_EMPTY_VARCHAR2;
		p_IS_ENABLED := g_EMPTY_NUMBER;
		p_EXTERNAL_ACCOUNT_DOMAIN_ID := g_EMPTY_NUMBER;
		p_HAS_UNAME_PWD_CREDENTIALS := g_EMPTY_NUMBER;
		p_NUMBER_OF_CERTIFICATES := g_EMPTY_NUMBER;

END GET_EXTERNAL_SYSTEM;
---------------------------------------------------------------------
PROCEDURE PUT_EXTERNAL_TRANSACTION
	(
	o_OID OUT NUMBER,
	p_TRANSACTION_NAME IN VARCHAR2,
	p_TRANSACTION_ALIAS IN VARCHAR2,
	p_TRANSACTION_DESC IN VARCHAR2,
	p_TRANSACTION_ID IN NUMBER,
	p_TRANSACTION_TYPE IN VARCHAR2,
	p_TRANSACTION_CODE IN VARCHAR2,
	p_TRANSACTION_IDENTIFIER IN VARCHAR2,
	p_IS_FIRM IN NUMBER,
	p_IS_IMPORT_SCHEDULE IN NUMBER,
	p_IS_EXPORT_SCHEDULE IN NUMBER,
	p_IS_BALANCE_TRANSACTION IN NUMBER,
	p_IS_BID_OFFER IN NUMBER,
	p_IS_EXCLUDE_FROM_POSITION IN NUMBER,
	p_IS_IMPORT_EXPORT IN NUMBER,
	p_IS_DISPATCHABLE IN NUMBER,
	p_TRANSACTION_INTERVAL IN VARCHAR2,
	p_EXTERNAL_INTERVAL IN VARCHAR2,
	p_ETAG_CODE IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PURCHASER_ID IN NUMBER,
	p_SELLER_ID IN NUMBER,
	p_CONTRACT_ID IN NUMBER,
	p_SC_ID IN NUMBER,
	p_POR_ID IN NUMBER,
	p_POD_ID IN NUMBER,
	p_COMMODITY_ID IN NUMBER,
	p_SERVICE_TYPE_ID IN NUMBER,
	p_TX_TRANSACTION_ID IN NUMBER,
	p_PATH_ID IN NUMBER,
	p_LINK_TRANSACTION_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_SCHEDULE_GROUP_ID IN NUMBER,
	p_MARKET_PRICE_ID IN NUMBER,
	p_ZOR_ID IN NUMBER,
	p_ZOD_ID IN NUMBER,
	p_SOURCE_ID IN NUMBER,
	p_SINK_ID IN NUMBER,
	p_RESOURCE_ID IN NUMBER,
	p_AGREEMENT_TYPE IN VARCHAR2,
	p_APPROVAL_TYPE IN VARCHAR2,
	p_LOSS_OPTION IN VARCHAR2,
	p_TRAIT_CATEGORY IN VARCHAR2,
	p_TP_ID IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC INTERCHANGE_TRANSACTION_EXT%ROWTYPE;
BEGIN


	v_REC.TRANSACTION_ID := p_TRANSACTION_ID;
	v_REC.TRANSACTION_NAME := TRIM(p_TRANSACTION_NAME);
	v_REC.TRANSACTION_ALIAS := TRIM(NVL(p_TRANSACTION_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.TRANSACTION_DESC := TRIM(NVL(p_TRANSACTION_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.TRANSACTION_TYPE := TRIM(NVL(p_TRANSACTION_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.TRANSACTION_CODE := TRIM(NVL(p_TRANSACTION_CODE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.TRANSACTION_IDENTIFIER := TRIM(NVL(p_TRANSACTION_IDENTIFIER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.IS_FIRM := p_IS_FIRM;
	v_REC.IS_IMPORT_SCHEDULE := p_IS_IMPORT_SCHEDULE;
	v_REC.IS_EXPORT_SCHEDULE := p_IS_EXPORT_SCHEDULE;
	v_REC.IS_BALANCE_TRANSACTION := p_IS_BALANCE_TRANSACTION;
	v_REC.IS_BID_OFFER := p_IS_BID_OFFER;
	v_REC.IS_EXCLUDE_FROM_POSITION := p_IS_EXCLUDE_FROM_POSITION;
	v_REC.IS_IMPORT_EXPORT := p_IS_IMPORT_EXPORT;
	v_REC.IS_DISPATCHABLE := p_IS_DISPATCHABLE;
	v_REC.TRANSACTION_INTERVAL := TRIM(NVL(p_TRANSACTION_INTERVAL,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EXTERNAL_INTERVAL := TRIM(NVL(p_EXTERNAL_INTERVAL,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ETAG_CODE := TRIM(NVL(p_ETAG_CODE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.BEGIN_DATE := p_BEGIN_DATE;
	v_REC.END_DATE := p_END_DATE;
	v_REC.PURCHASER_ID := NVL(p_PURCHASER_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.SELLER_ID := NVL(p_SELLER_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.CONTRACT_ID := NVL(p_CONTRACT_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.SC_ID := NVL(p_SC_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.POR_ID := NVL(p_POR_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.POD_ID := NVL(p_POD_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.COMMODITY_ID := NVL(p_COMMODITY_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.SERVICE_TYPE_ID := NVL(p_SERVICE_TYPE_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.TX_TRANSACTION_ID := p_TX_TRANSACTION_ID;
	v_REC.PATH_ID := p_PATH_ID;
	v_REC.LINK_TRANSACTION_ID := p_LINK_TRANSACTION_ID;
	v_REC.EDC_ID := NVL(p_EDC_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.PSE_ID := NVL(p_PSE_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.ESP_ID := NVL(p_ESP_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.POOL_ID := NVL(p_POOL_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.SCHEDULE_GROUP_ID := NVL(p_SCHEDULE_GROUP_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.MARKET_PRICE_ID := NVL(p_MARKET_PRICE_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.ZOR_ID := NVL(p_ZOR_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.ZOD_ID := NVL(p_ZOD_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.SOURCE_ID := NVL(p_SOURCE_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.SINK_ID := NVL(p_SINK_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.RESOURCE_ID := p_RESOURCE_ID;
	v_REC.AGREEMENT_TYPE := TRIM(NVL(p_AGREEMENT_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.APPROVAL_TYPE := TRIM(NVL(p_APPROVAL_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.LOSS_OPTION := TRIM(NVL(p_LOSS_OPTION,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.TRAIT_CATEGORY := TRIM(NVL(p_TRAIT_CATEGORY,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.TP_ID := NVL(p_TP_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_TRANSACTION_ID > 0 OR p_TRANSACTION_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_TRANSACTION_ID, EC.ED_EXTERNAL_TRANSACTION) 
                 AND IO_UTIL.EXTERNAL_TRANSACTION_IS_ALLOWE (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_EXTERNAL_TRANSACTION, p_TRANSACTION_ID);
		END IF;

		-- save it!
		UPDATE INTERCHANGE_TRANSACTION_EXT
		SET ROW = v_REC
		WHERE TRANSACTION_ID = p_TRANSACTION_ID;
		o_OID := p_TRANSACTION_ID;
        
	ELSIF p_TRANSACTION_ID IS NULL OR p_TRANSACTION_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.EXTERNAL_TRANSACTION_IS_ALLOWE (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_EXTERNAL_TRANSACTION, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.TRANSACTION_ID := o_OID;
		-- save it!
		INSERT INTO INTERCHANGE_TRANSACTION_EXT VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_TRANSACTION_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_EXTERNAL_TRANSACTION, EC.ED_ENTITY_DOMAIN)||': '||p_TRANSACTION_NAME);
END PUT_EXTERNAL_TRANSACTION;
---------------------------------------------------------------------
PROCEDURE GET_EXTERNAL_TRANSACTION
	(
	p_TRANSACTION_ID IN NUMBER,
	p_TRANSACTION_NAME OUT VARCHAR2,
	p_TRANSACTION_ALIAS OUT VARCHAR2,
	p_TRANSACTION_DESC OUT VARCHAR2,
	p_TRANSACTION_TYPE OUT VARCHAR2,
	p_TRANSACTION_CODE OUT VARCHAR2,
	p_TRANSACTION_IDENTIFIER OUT VARCHAR2,
	p_IS_FIRM OUT NUMBER,
	p_IS_IMPORT_SCHEDULE OUT NUMBER,
	p_IS_EXPORT_SCHEDULE OUT NUMBER,
	p_IS_BALANCE_TRANSACTION OUT NUMBER,
	p_IS_BID_OFFER OUT NUMBER,
	p_IS_EXCLUDE_FROM_POSITION OUT NUMBER,
	p_IS_IMPORT_EXPORT OUT NUMBER,
	p_IS_DISPATCHABLE OUT NUMBER,
	p_TRANSACTION_INTERVAL OUT VARCHAR2,
	p_EXTERNAL_INTERVAL OUT VARCHAR2,
	p_ETAG_CODE OUT VARCHAR2,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE,
	p_PURCHASER_ID OUT NUMBER,
	p_SELLER_ID OUT NUMBER,
	p_CONTRACT_ID OUT NUMBER,
	p_SC_ID OUT NUMBER,
	p_POR_ID OUT NUMBER,
	p_POD_ID OUT NUMBER,
	p_COMMODITY_ID OUT NUMBER,
	p_SERVICE_TYPE_ID OUT NUMBER,
	p_TX_TRANSACTION_ID OUT NUMBER,
	p_PATH_ID OUT NUMBER,
	p_LINK_TRANSACTION_ID OUT NUMBER,
	p_EDC_ID OUT NUMBER,
	p_PSE_ID OUT NUMBER,
	p_ESP_ID OUT NUMBER,
	p_POOL_ID OUT NUMBER,
	p_SCHEDULE_GROUP_ID OUT NUMBER,
	p_MARKET_PRICE_ID OUT NUMBER,
	p_ZOR_ID OUT NUMBER,
	p_ZOD_ID OUT NUMBER,
	p_SOURCE_ID OUT NUMBER,
	p_SINK_ID OUT NUMBER,
	p_RESOURCE_ID OUT NUMBER,
	p_AGREEMENT_TYPE OUT VARCHAR2,
	p_APPROVAL_TYPE OUT VARCHAR2,
	p_LOSS_OPTION OUT VARCHAR2,
	p_TRAIT_CATEGORY OUT VARCHAR2,
	p_TP_ID OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD INTERCHANGE_TRANSACTION_EXT%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_TRANSACTION_ID, EC.ED_EXTERNAL_TRANSACTION);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM INTERCHANGE_TRANSACTION_EXT
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;
    
	-- Set the output parameters
	p_TRANSACTION_NAME := v_RECORD.TRANSACTION_NAME;
	p_TRANSACTION_ALIAS := v_RECORD.TRANSACTION_ALIAS;
	p_TRANSACTION_DESC := v_RECORD.TRANSACTION_DESC;
	p_TRANSACTION_TYPE := v_RECORD.TRANSACTION_TYPE;
	p_TRANSACTION_CODE := v_RECORD.TRANSACTION_CODE;
	p_TRANSACTION_IDENTIFIER := v_RECORD.TRANSACTION_IDENTIFIER;
	p_IS_FIRM := v_RECORD.IS_FIRM;
	p_IS_IMPORT_SCHEDULE := v_RECORD.IS_IMPORT_SCHEDULE;
	p_IS_EXPORT_SCHEDULE := v_RECORD.IS_EXPORT_SCHEDULE;
	p_IS_BALANCE_TRANSACTION := v_RECORD.IS_BALANCE_TRANSACTION;
	p_IS_BID_OFFER := v_RECORD.IS_BID_OFFER;
	p_IS_EXCLUDE_FROM_POSITION := v_RECORD.IS_EXCLUDE_FROM_POSITION;
	p_IS_IMPORT_EXPORT := v_RECORD.IS_IMPORT_EXPORT;
	p_IS_DISPATCHABLE := v_RECORD.IS_DISPATCHABLE;
	p_TRANSACTION_INTERVAL := v_RECORD.TRANSACTION_INTERVAL;
	p_EXTERNAL_INTERVAL := v_RECORD.EXTERNAL_INTERVAL;
	p_ETAG_CODE := v_RECORD.ETAG_CODE;
	p_BEGIN_DATE := v_RECORD.BEGIN_DATE;
	p_END_DATE := v_RECORD.END_DATE;
	p_PURCHASER_ID := v_RECORD.PURCHASER_ID;
	p_SELLER_ID := v_RECORD.SELLER_ID;
	p_CONTRACT_ID := v_RECORD.CONTRACT_ID;
	p_SC_ID := v_RECORD.SC_ID;
	p_POR_ID := v_RECORD.POR_ID;
	p_POD_ID := v_RECORD.POD_ID;
	p_COMMODITY_ID := v_RECORD.COMMODITY_ID;
	p_SERVICE_TYPE_ID := v_RECORD.SERVICE_TYPE_ID;
	p_TX_TRANSACTION_ID := v_RECORD.TX_TRANSACTION_ID;
	p_PATH_ID := v_RECORD.PATH_ID;
	p_LINK_TRANSACTION_ID := v_RECORD.LINK_TRANSACTION_ID;
	p_EDC_ID := v_RECORD.EDC_ID;
	p_PSE_ID := v_RECORD.PSE_ID;
	p_ESP_ID := v_RECORD.ESP_ID;
	p_POOL_ID := v_RECORD.POOL_ID;
	p_SCHEDULE_GROUP_ID := v_RECORD.SCHEDULE_GROUP_ID;
	p_MARKET_PRICE_ID := v_RECORD.MARKET_PRICE_ID;
	p_ZOR_ID := v_RECORD.ZOR_ID;
	p_ZOD_ID := v_RECORD.ZOD_ID;
	p_SOURCE_ID := v_RECORD.SOURCE_ID;
	p_SINK_ID := v_RECORD.SINK_ID;
	p_RESOURCE_ID := v_RECORD.RESOURCE_ID;
	p_AGREEMENT_TYPE := v_RECORD.AGREEMENT_TYPE;
	p_APPROVAL_TYPE := v_RECORD.APPROVAL_TYPE;
	p_LOSS_OPTION := v_RECORD.LOSS_OPTION;
	p_TRAIT_CATEGORY := v_RECORD.TRAIT_CATEGORY;
	p_TP_ID := v_RECORD.TP_ID;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_TRANSACTION_NAME := g_EMPTY_VARCHAR2;
		p_TRANSACTION_ALIAS := g_EMPTY_VARCHAR2;
		p_TRANSACTION_DESC := g_EMPTY_VARCHAR2;
		p_TRANSACTION_TYPE := g_EMPTY_VARCHAR2;
		p_TRANSACTION_CODE := g_EMPTY_VARCHAR2;
		p_TRANSACTION_IDENTIFIER := g_EMPTY_VARCHAR2;
		p_IS_FIRM := g_EMPTY_NUMBER;
		p_IS_IMPORT_SCHEDULE := g_EMPTY_NUMBER;
		p_IS_EXPORT_SCHEDULE := g_EMPTY_NUMBER;
		p_IS_BALANCE_TRANSACTION := g_EMPTY_NUMBER;
		p_IS_BID_OFFER := g_EMPTY_NUMBER;
		p_IS_EXCLUDE_FROM_POSITION := g_EMPTY_NUMBER;
		p_IS_IMPORT_EXPORT := g_EMPTY_NUMBER;
		p_IS_DISPATCHABLE := g_EMPTY_NUMBER;
		p_TRANSACTION_INTERVAL := g_EMPTY_VARCHAR2;
		p_EXTERNAL_INTERVAL := g_EMPTY_VARCHAR2;
		p_ETAG_CODE := g_EMPTY_VARCHAR2;
		p_BEGIN_DATE := g_EMPTY_DATE;
		p_END_DATE := g_EMPTY_DATE;
		p_PURCHASER_ID := g_EMPTY_NUMBER;
		p_SELLER_ID := g_EMPTY_NUMBER;
		p_CONTRACT_ID := g_EMPTY_NUMBER;
		p_SC_ID := g_EMPTY_NUMBER;
		p_POR_ID := g_EMPTY_NUMBER;
		p_POD_ID := g_EMPTY_NUMBER;
		p_COMMODITY_ID := g_EMPTY_NUMBER;
		p_SERVICE_TYPE_ID := g_EMPTY_NUMBER;
		p_TX_TRANSACTION_ID := g_EMPTY_NUMBER;
		p_PATH_ID := g_EMPTY_NUMBER;
		p_LINK_TRANSACTION_ID := g_EMPTY_NUMBER;
		p_EDC_ID := g_EMPTY_NUMBER;
		p_PSE_ID := g_EMPTY_NUMBER;
		p_ESP_ID := g_EMPTY_NUMBER;
		p_POOL_ID := g_EMPTY_NUMBER;
		p_SCHEDULE_GROUP_ID := g_EMPTY_NUMBER;
		p_MARKET_PRICE_ID := g_EMPTY_NUMBER;
		p_ZOR_ID := g_EMPTY_NUMBER;
		p_ZOD_ID := g_EMPTY_NUMBER;
		p_SOURCE_ID := g_EMPTY_NUMBER;
		p_SINK_ID := g_EMPTY_NUMBER;
		p_RESOURCE_ID := g_EMPTY_NUMBER;
		p_AGREEMENT_TYPE := g_EMPTY_VARCHAR2;
		p_APPROVAL_TYPE := g_EMPTY_VARCHAR2;
		p_LOSS_OPTION := g_EMPTY_VARCHAR2;
		p_TRAIT_CATEGORY := g_EMPTY_VARCHAR2;
		p_TP_ID := g_EMPTY_NUMBER;

END GET_EXTERNAL_TRANSACTION;
---------------------------------------------------------------------
PROCEDURE PUT_GEOGRAPHY
	(
	o_OID OUT NUMBER,
	p_GEOGRAPHY_NAME IN VARCHAR2,
	p_GEOGRAPHY_ALIAS IN VARCHAR2,
	p_GEOGRAPHY_DESC IN VARCHAR2,
	p_GEOGRAPHY_ID IN NUMBER,
	p_GEOGRAPHY_TYPE IN VARCHAR2,
	p_PARENT_GEOGRAPHY_ID IN NUMBER,
	p_DISPLAY_NAME IN VARCHAR2,
	p_ABBREVIATION IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC GEOGRAPHY%ROWTYPE;
BEGIN


	v_REC.GEOGRAPHY_ID := p_GEOGRAPHY_ID;
	v_REC.GEOGRAPHY_NAME := TRIM(p_GEOGRAPHY_NAME);
	v_REC.GEOGRAPHY_ALIAS := TRIM(NVL(p_GEOGRAPHY_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.GEOGRAPHY_DESC := TRIM(NVL(p_GEOGRAPHY_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.GEOGRAPHY_TYPE := TRIM(p_GEOGRAPHY_TYPE);
	v_REC.PARENT_GEOGRAPHY_ID := p_PARENT_GEOGRAPHY_ID;
	v_REC.DISPLAY_NAME := TRIM(p_DISPLAY_NAME);
	v_REC.ABBREVIATION := TRIM(p_ABBREVIATION);
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_GEOGRAPHY_ID > 0 OR p_GEOGRAPHY_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_GEOGRAPHY_ID, EC.ED_GEOGRAPHY) 
                 AND IO_UTIL.GEOGRAPHY_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_GEOGRAPHY, p_GEOGRAPHY_ID);
		END IF;

		-- save it!
		UPDATE GEOGRAPHY
		SET ROW = v_REC
		WHERE GEOGRAPHY_ID = p_GEOGRAPHY_ID;
		o_OID := p_GEOGRAPHY_ID;
        
	ELSIF p_GEOGRAPHY_ID IS NULL OR p_GEOGRAPHY_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.GEOGRAPHY_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_GEOGRAPHY, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.GEOGRAPHY_ID := o_OID;
		-- save it!
		INSERT INTO GEOGRAPHY VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_GEOGRAPHY_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_GEOGRAPHY, EC.ED_ENTITY_DOMAIN)||': '||p_GEOGRAPHY_NAME);
END PUT_GEOGRAPHY;
---------------------------------------------------------------------
PROCEDURE GET_GEOGRAPHY
	(
	p_GEOGRAPHY_ID IN NUMBER,
	p_GEOGRAPHY_NAME OUT VARCHAR2,
	p_GEOGRAPHY_ALIAS OUT VARCHAR2,
	p_GEOGRAPHY_DESC OUT VARCHAR2,
	p_GEOGRAPHY_TYPE OUT VARCHAR2,
	p_PARENT_GEOGRAPHY_ID OUT NUMBER,
	p_DISPLAY_NAME OUT VARCHAR2,
	p_ABBREVIATION OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD GEOGRAPHY%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_GEOGRAPHY_ID, EC.ED_GEOGRAPHY);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM GEOGRAPHY
	WHERE GEOGRAPHY_ID = p_GEOGRAPHY_ID;
    
	-- Set the output parameters
	p_GEOGRAPHY_NAME := v_RECORD.GEOGRAPHY_NAME;
	p_GEOGRAPHY_ALIAS := v_RECORD.GEOGRAPHY_ALIAS;
	p_GEOGRAPHY_DESC := v_RECORD.GEOGRAPHY_DESC;
	p_GEOGRAPHY_TYPE := v_RECORD.GEOGRAPHY_TYPE;
	p_PARENT_GEOGRAPHY_ID := v_RECORD.PARENT_GEOGRAPHY_ID;
	p_DISPLAY_NAME := v_RECORD.DISPLAY_NAME;
	p_ABBREVIATION := v_RECORD.ABBREVIATION;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_GEOGRAPHY_NAME := g_EMPTY_VARCHAR2;
		p_GEOGRAPHY_ALIAS := g_EMPTY_VARCHAR2;
		p_GEOGRAPHY_DESC := g_EMPTY_VARCHAR2;
		p_GEOGRAPHY_TYPE := g_EMPTY_VARCHAR2;
		p_PARENT_GEOGRAPHY_ID := g_EMPTY_NUMBER;
		p_DISPLAY_NAME := g_EMPTY_VARCHAR2;
		p_ABBREVIATION := g_EMPTY_VARCHAR2;

END GET_GEOGRAPHY;
---------------------------------------------------------------------
PROCEDURE PUT_GROWTH_PATTERN
	(
	o_OID OUT NUMBER,
	p_PATTERN_NAME IN VARCHAR2,
	p_PATTERN_ALIAS IN VARCHAR2,
	p_PATTERN_DESC IN VARCHAR2,
	p_PATTERN_ID IN NUMBER,
	p_JAN_PCT IN NUMBER,
	p_FEB_PCT IN NUMBER,
	p_MAR_PCT IN NUMBER,
	p_APR_PCT IN NUMBER,
	p_MAY_PCT IN NUMBER,
	p_JUN_PCT IN NUMBER,
	p_JUL_PCT IN NUMBER,
	p_AUG_PCT IN NUMBER,
	p_SEP_PCT IN NUMBER,
	p_OCT_PCT IN NUMBER,
	p_NOV_PCT IN NUMBER,
	p_DEC_PCT IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC GROWTH_PATTERN%ROWTYPE;
BEGIN


	v_REC.PATTERN_ID := p_PATTERN_ID;
	v_REC.PATTERN_NAME := TRIM(p_PATTERN_NAME);
	v_REC.PATTERN_ALIAS := TRIM(NVL(p_PATTERN_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PATTERN_DESC := TRIM(NVL(p_PATTERN_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.JAN_PCT := p_JAN_PCT;
	v_REC.FEB_PCT := p_FEB_PCT;
	v_REC.MAR_PCT := p_MAR_PCT;
	v_REC.APR_PCT := p_APR_PCT;
	v_REC.MAY_PCT := p_MAY_PCT;
	v_REC.JUN_PCT := p_JUN_PCT;
	v_REC.JUL_PCT := p_JUL_PCT;
	v_REC.AUG_PCT := p_AUG_PCT;
	v_REC.SEP_PCT := p_SEP_PCT;
	v_REC.OCT_PCT := p_OCT_PCT;
	v_REC.NOV_PCT := p_NOV_PCT;
	v_REC.DEC_PCT := p_DEC_PCT;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_PATTERN_ID > 0 OR p_PATTERN_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_PATTERN_ID, EC.ED_GROWTH_PATTERN) 
                 AND IO_UTIL.GROWTH_PATTERN_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_GROWTH_PATTERN, p_PATTERN_ID);
		END IF;

		-- save it!
		UPDATE GROWTH_PATTERN
		SET ROW = v_REC
		WHERE PATTERN_ID = p_PATTERN_ID;
		o_OID := p_PATTERN_ID;
        
	ELSIF p_PATTERN_ID IS NULL OR p_PATTERN_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.GROWTH_PATTERN_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_GROWTH_PATTERN, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.PATTERN_ID := o_OID;
		-- save it!
		INSERT INTO GROWTH_PATTERN VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_PATTERN_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_GROWTH_PATTERN, EC.ED_ENTITY_DOMAIN)||': '||p_PATTERN_NAME);
END PUT_GROWTH_PATTERN;
---------------------------------------------------------------------
PROCEDURE GET_GROWTH_PATTERN
	(
	p_PATTERN_ID IN NUMBER,
	p_PATTERN_NAME OUT VARCHAR2,
	p_PATTERN_ALIAS OUT VARCHAR2,
	p_PATTERN_DESC OUT VARCHAR2,
	p_JAN_PCT OUT NUMBER,
	p_FEB_PCT OUT NUMBER,
	p_MAR_PCT OUT NUMBER,
	p_APR_PCT OUT NUMBER,
	p_MAY_PCT OUT NUMBER,
	p_JUN_PCT OUT NUMBER,
	p_JUL_PCT OUT NUMBER,
	p_AUG_PCT OUT NUMBER,
	p_SEP_PCT OUT NUMBER,
	p_OCT_PCT OUT NUMBER,
	p_NOV_PCT OUT NUMBER,
	p_DEC_PCT OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD GROWTH_PATTERN%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_PATTERN_ID, EC.ED_GROWTH_PATTERN);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM GROWTH_PATTERN
	WHERE PATTERN_ID = p_PATTERN_ID;
    
	-- Set the output parameters
	p_PATTERN_NAME := v_RECORD.PATTERN_NAME;
	p_PATTERN_ALIAS := v_RECORD.PATTERN_ALIAS;
	p_PATTERN_DESC := v_RECORD.PATTERN_DESC;
	p_JAN_PCT := v_RECORD.JAN_PCT;
	p_FEB_PCT := v_RECORD.FEB_PCT;
	p_MAR_PCT := v_RECORD.MAR_PCT;
	p_APR_PCT := v_RECORD.APR_PCT;
	p_MAY_PCT := v_RECORD.MAY_PCT;
	p_JUN_PCT := v_RECORD.JUN_PCT;
	p_JUL_PCT := v_RECORD.JUL_PCT;
	p_AUG_PCT := v_RECORD.AUG_PCT;
	p_SEP_PCT := v_RECORD.SEP_PCT;
	p_OCT_PCT := v_RECORD.OCT_PCT;
	p_NOV_PCT := v_RECORD.NOV_PCT;
	p_DEC_PCT := v_RECORD.DEC_PCT;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_PATTERN_NAME := g_EMPTY_VARCHAR2;
		p_PATTERN_ALIAS := g_EMPTY_VARCHAR2;
		p_PATTERN_DESC := g_EMPTY_VARCHAR2;
		p_JAN_PCT := g_EMPTY_NUMBER;
		p_FEB_PCT := g_EMPTY_NUMBER;
		p_MAR_PCT := g_EMPTY_NUMBER;
		p_APR_PCT := g_EMPTY_NUMBER;
		p_MAY_PCT := g_EMPTY_NUMBER;
		p_JUN_PCT := g_EMPTY_NUMBER;
		p_JUL_PCT := g_EMPTY_NUMBER;
		p_AUG_PCT := g_EMPTY_NUMBER;
		p_SEP_PCT := g_EMPTY_NUMBER;
		p_OCT_PCT := g_EMPTY_NUMBER;
		p_NOV_PCT := g_EMPTY_NUMBER;
		p_DEC_PCT := g_EMPTY_NUMBER;

END GET_GROWTH_PATTERN;
---------------------------------------------------------------------
PROCEDURE PUT_HEAT_RATE_CURVE
	(
	o_OID OUT NUMBER,
	p_HEAT_RATE_CURVE_NAME IN VARCHAR2,
	p_HEAT_RATE_CURVE_ALIAS IN VARCHAR2,
	p_HEAT_RATE_CURVE_DESC IN VARCHAR2,
	p_HEAT_RATE_CURVE_ID IN NUMBER,
	p_STATION_ID IN NUMBER,
	p_PARAMETER_1_ID IN NUMBER,
	p_PARAMETER_1_ROUND_TO_NEAREST IN NUMBER,
	p_PARAMETER_1_ROUNDING_STYLE IN VARCHAR2,
	p_PARAMETER_2_ID IN NUMBER,
	p_PARAMETER_2_ROUND_TO_NEAREST IN NUMBER,
	p_PARAMETER_2_ROUNDING_STYLE IN VARCHAR2,
	p_PARAMETER_3_ID IN NUMBER,
	p_PARAMETER_3_ROUND_TO_NEAREST IN NUMBER,
	p_PARAMETER_3_ROUNDING_STYLE IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC HEAT_RATE_CURVE%ROWTYPE;
BEGIN


	v_REC.HEAT_RATE_CURVE_ID := p_HEAT_RATE_CURVE_ID;
	v_REC.HEAT_RATE_CURVE_NAME := TRIM(p_HEAT_RATE_CURVE_NAME);
	v_REC.HEAT_RATE_CURVE_ALIAS := TRIM(NVL(p_HEAT_RATE_CURVE_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.HEAT_RATE_CURVE_DESC := TRIM(NVL(p_HEAT_RATE_CURVE_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.STATION_ID := NVL(p_STATION_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.PARAMETER_1_ID := NVL(p_PARAMETER_1_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.PARAMETER_1_ROUND_TO_NEAREST := p_PARAMETER_1_ROUND_TO_NEAREST;
	v_REC.PARAMETER_1_ROUNDING_STYLE := TRIM(NVL(p_PARAMETER_1_ROUNDING_STYLE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PARAMETER_2_ID := NVL(p_PARAMETER_2_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.PARAMETER_2_ROUND_TO_NEAREST := p_PARAMETER_2_ROUND_TO_NEAREST;
	v_REC.PARAMETER_2_ROUNDING_STYLE := TRIM(NVL(p_PARAMETER_2_ROUNDING_STYLE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PARAMETER_3_ID := NVL(p_PARAMETER_3_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.PARAMETER_3_ROUND_TO_NEAREST := p_PARAMETER_3_ROUND_TO_NEAREST;
	v_REC.PARAMETER_3_ROUNDING_STYLE := TRIM(NVL(p_PARAMETER_3_ROUNDING_STYLE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_HEAT_RATE_CURVE_ID > 0 OR p_HEAT_RATE_CURVE_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_HEAT_RATE_CURVE_ID, EC.ED_HEAT_RATE_CURVE) 
                 AND IO_UTIL.HEAT_RATE_CURVE_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_HEAT_RATE_CURVE, p_HEAT_RATE_CURVE_ID);
		END IF;

		-- save it!
		UPDATE HEAT_RATE_CURVE
		SET ROW = v_REC
		WHERE HEAT_RATE_CURVE_ID = p_HEAT_RATE_CURVE_ID;
		o_OID := p_HEAT_RATE_CURVE_ID;
        
	ELSIF p_HEAT_RATE_CURVE_ID IS NULL OR p_HEAT_RATE_CURVE_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.HEAT_RATE_CURVE_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_HEAT_RATE_CURVE, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.HEAT_RATE_CURVE_ID := o_OID;
		-- save it!
		INSERT INTO HEAT_RATE_CURVE VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_HEAT_RATE_CURVE_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_HEAT_RATE_CURVE, EC.ED_ENTITY_DOMAIN)||': '||p_HEAT_RATE_CURVE_NAME);
END PUT_HEAT_RATE_CURVE;
---------------------------------------------------------------------
PROCEDURE GET_HEAT_RATE_CURVE
	(
	p_HEAT_RATE_CURVE_ID IN NUMBER,
	p_HEAT_RATE_CURVE_NAME OUT VARCHAR2,
	p_HEAT_RATE_CURVE_ALIAS OUT VARCHAR2,
	p_HEAT_RATE_CURVE_DESC OUT VARCHAR2,
	p_STATION_ID OUT NUMBER,
	p_PARAMETER_1_ID OUT NUMBER,
	p_PARAMETER_1_ROUND_TO_NEAREST OUT NUMBER,
	p_PARAMETER_1_ROUNDING_STYLE OUT VARCHAR2,
	p_PARAMETER_2_ID OUT NUMBER,
	p_PARAMETER_2_ROUND_TO_NEAREST OUT NUMBER,
	p_PARAMETER_2_ROUNDING_STYLE OUT VARCHAR2,
	p_PARAMETER_3_ID OUT NUMBER,
	p_PARAMETER_3_ROUND_TO_NEAREST OUT NUMBER,
	p_PARAMETER_3_ROUNDING_STYLE OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD HEAT_RATE_CURVE%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_HEAT_RATE_CURVE_ID, EC.ED_HEAT_RATE_CURVE);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM HEAT_RATE_CURVE
	WHERE HEAT_RATE_CURVE_ID = p_HEAT_RATE_CURVE_ID;
    
	-- Set the output parameters
	p_HEAT_RATE_CURVE_NAME := v_RECORD.HEAT_RATE_CURVE_NAME;
	p_HEAT_RATE_CURVE_ALIAS := v_RECORD.HEAT_RATE_CURVE_ALIAS;
	p_HEAT_RATE_CURVE_DESC := v_RECORD.HEAT_RATE_CURVE_DESC;
	p_STATION_ID := v_RECORD.STATION_ID;
	p_PARAMETER_1_ID := v_RECORD.PARAMETER_1_ID;
	p_PARAMETER_1_ROUND_TO_NEAREST := v_RECORD.PARAMETER_1_ROUND_TO_NEAREST;
	p_PARAMETER_1_ROUNDING_STYLE := v_RECORD.PARAMETER_1_ROUNDING_STYLE;
	p_PARAMETER_2_ID := v_RECORD.PARAMETER_2_ID;
	p_PARAMETER_2_ROUND_TO_NEAREST := v_RECORD.PARAMETER_2_ROUND_TO_NEAREST;
	p_PARAMETER_2_ROUNDING_STYLE := v_RECORD.PARAMETER_2_ROUNDING_STYLE;
	p_PARAMETER_3_ID := v_RECORD.PARAMETER_3_ID;
	p_PARAMETER_3_ROUND_TO_NEAREST := v_RECORD.PARAMETER_3_ROUND_TO_NEAREST;
	p_PARAMETER_3_ROUNDING_STYLE := v_RECORD.PARAMETER_3_ROUNDING_STYLE;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_HEAT_RATE_CURVE_NAME := g_EMPTY_VARCHAR2;
		p_HEAT_RATE_CURVE_ALIAS := g_EMPTY_VARCHAR2;
		p_HEAT_RATE_CURVE_DESC := g_EMPTY_VARCHAR2;
		p_STATION_ID := g_EMPTY_NUMBER;
		p_PARAMETER_1_ID := g_EMPTY_NUMBER;
		p_PARAMETER_1_ROUND_TO_NEAREST := g_EMPTY_NUMBER;
		p_PARAMETER_1_ROUNDING_STYLE := g_EMPTY_VARCHAR2;
		p_PARAMETER_2_ID := g_EMPTY_NUMBER;
		p_PARAMETER_2_ROUND_TO_NEAREST := g_EMPTY_NUMBER;
		p_PARAMETER_2_ROUNDING_STYLE := g_EMPTY_VARCHAR2;
		p_PARAMETER_3_ID := g_EMPTY_NUMBER;
		p_PARAMETER_3_ROUND_TO_NEAREST := g_EMPTY_NUMBER;
		p_PARAMETER_3_ROUNDING_STYLE := g_EMPTY_VARCHAR2;

END GET_HEAT_RATE_CURVE;
---------------------------------------------------------------------
PROCEDURE PUT_HOLIDAY
	(
	o_OID OUT NUMBER,
	p_HOLIDAY_NAME IN VARCHAR2,
	p_HOLIDAY_ALIAS IN VARCHAR2,
	p_HOLIDAY_DESC IN VARCHAR2,
	p_HOLIDAY_ID IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC HOLIDAY%ROWTYPE;
BEGIN


	v_REC.HOLIDAY_ID := p_HOLIDAY_ID;
	v_REC.HOLIDAY_NAME := TRIM(p_HOLIDAY_NAME);
	v_REC.HOLIDAY_ALIAS := TRIM(NVL(p_HOLIDAY_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.HOLIDAY_DESC := TRIM(NVL(p_HOLIDAY_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_HOLIDAY_ID > 0 OR p_HOLIDAY_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_HOLIDAY_ID, EC.ED_HOLIDAY) 
                 AND IO_UTIL.HOLIDAY_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_HOLIDAY, p_HOLIDAY_ID);
		END IF;

		-- save it!
		UPDATE HOLIDAY
		SET ROW = v_REC
		WHERE HOLIDAY_ID = p_HOLIDAY_ID;
		o_OID := p_HOLIDAY_ID;
        
	ELSIF p_HOLIDAY_ID IS NULL OR p_HOLIDAY_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.HOLIDAY_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_HOLIDAY, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.HOLIDAY_ID := o_OID;
		-- save it!
		INSERT INTO HOLIDAY VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_HOLIDAY_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_HOLIDAY, EC.ED_ENTITY_DOMAIN)||': '||p_HOLIDAY_NAME);
END PUT_HOLIDAY;
---------------------------------------------------------------------
PROCEDURE GET_HOLIDAY
	(
	p_HOLIDAY_ID IN NUMBER,
	p_HOLIDAY_NAME OUT VARCHAR2,
	p_HOLIDAY_ALIAS OUT VARCHAR2,
	p_HOLIDAY_DESC OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD HOLIDAY%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_HOLIDAY_ID, EC.ED_HOLIDAY);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM HOLIDAY
	WHERE HOLIDAY_ID = p_HOLIDAY_ID;
    
	-- Set the output parameters
	p_HOLIDAY_NAME := v_RECORD.HOLIDAY_NAME;
	p_HOLIDAY_ALIAS := v_RECORD.HOLIDAY_ALIAS;
	p_HOLIDAY_DESC := v_RECORD.HOLIDAY_DESC;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_HOLIDAY_NAME := g_EMPTY_VARCHAR2;
		p_HOLIDAY_ALIAS := g_EMPTY_VARCHAR2;
		p_HOLIDAY_DESC := g_EMPTY_VARCHAR2;

END GET_HOLIDAY;
---------------------------------------------------------------------
PROCEDURE PUT_HOLIDAY_SET
	(
	o_OID OUT NUMBER,
	p_HOLIDAY_SET_NAME IN VARCHAR2,
	p_HOLIDAY_SET_ALIAS IN VARCHAR2,
	p_HOLIDAY_SET_DESC IN VARCHAR2,
	p_HOLIDAY_SET_ID IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC HOLIDAY_SET%ROWTYPE;
BEGIN


	v_REC.HOLIDAY_SET_ID := p_HOLIDAY_SET_ID;
	v_REC.HOLIDAY_SET_NAME := TRIM(p_HOLIDAY_SET_NAME);
	v_REC.HOLIDAY_SET_ALIAS := TRIM(NVL(p_HOLIDAY_SET_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.HOLIDAY_SET_DESC := TRIM(NVL(p_HOLIDAY_SET_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_HOLIDAY_SET_ID > 0 OR p_HOLIDAY_SET_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_HOLIDAY_SET_ID, EC.ED_HOLIDAY_SET) 
                 AND IO_UTIL.HOLIDAY_SET_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_HOLIDAY_SET, p_HOLIDAY_SET_ID);
		END IF;

		-- save it!
		UPDATE HOLIDAY_SET
		SET ROW = v_REC
		WHERE HOLIDAY_SET_ID = p_HOLIDAY_SET_ID;
		o_OID := p_HOLIDAY_SET_ID;
        
	ELSIF p_HOLIDAY_SET_ID IS NULL OR p_HOLIDAY_SET_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.HOLIDAY_SET_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_HOLIDAY_SET, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.HOLIDAY_SET_ID := o_OID;
		-- save it!
		INSERT INTO HOLIDAY_SET VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_HOLIDAY_SET_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_HOLIDAY_SET, EC.ED_ENTITY_DOMAIN)||': '||p_HOLIDAY_SET_NAME);
END PUT_HOLIDAY_SET;
---------------------------------------------------------------------
PROCEDURE GET_HOLIDAY_SET
	(
	p_HOLIDAY_SET_ID IN NUMBER,
	p_HOLIDAY_SET_NAME OUT VARCHAR2,
	p_HOLIDAY_SET_ALIAS OUT VARCHAR2,
	p_HOLIDAY_SET_DESC OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD HOLIDAY_SET%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_HOLIDAY_SET_ID, EC.ED_HOLIDAY_SET);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM HOLIDAY_SET
	WHERE HOLIDAY_SET_ID = p_HOLIDAY_SET_ID;
    
	-- Set the output parameters
	p_HOLIDAY_SET_NAME := v_RECORD.HOLIDAY_SET_NAME;
	p_HOLIDAY_SET_ALIAS := v_RECORD.HOLIDAY_SET_ALIAS;
	p_HOLIDAY_SET_DESC := v_RECORD.HOLIDAY_SET_DESC;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_HOLIDAY_SET_NAME := g_EMPTY_VARCHAR2;
		p_HOLIDAY_SET_ALIAS := g_EMPTY_VARCHAR2;
		p_HOLIDAY_SET_DESC := g_EMPTY_VARCHAR2;

END GET_HOLIDAY_SET;
---------------------------------------------------------------------
PROCEDURE PUT_INTERCHANGE_CONTRACT
	(
	o_OID OUT NUMBER,
	p_CONTRACT_NAME IN VARCHAR2,
	p_CONTRACT_ALIAS IN VARCHAR2,
	p_CONTRACT_DESC IN VARCHAR2,
	p_CONTRACT_ID IN NUMBER,
	p_CONTRACT_STATUS IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_IS_EVERGREEN IN NUMBER,
	p_CONTRACT_TYPE IN VARCHAR2,
	p_BILLING_ENTITY_ID IN NUMBER,
	p_PURCHASER_ID IN NUMBER,
	p_SELLER_ID IN NUMBER,
	p_SOURCE_ID IN NUMBER,
	p_SINK_ID IN NUMBER,
	p_POR_ID IN NUMBER,
	p_POD_ID IN NUMBER,
	p_SC_ID IN NUMBER,
	p_AGREEMENT_TYPE IN VARCHAR2,
	p_APPROVAL_TYPE IN VARCHAR2,
	p_MARKET_TYPE IN VARCHAR2,
	p_LOSS_OPTION IN VARCHAR2,
	p_CONTRACT_FILE_NAME IN VARCHAR2,
	p_PIPELINE_ID IN NUMBER,
	p_PIPELINE_TARIFF_TYPE IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC INTERCHANGE_CONTRACT%ROWTYPE;
BEGIN


	v_REC.CONTRACT_ID := p_CONTRACT_ID;
	v_REC.CONTRACT_NAME := TRIM(p_CONTRACT_NAME);
	v_REC.CONTRACT_ALIAS := TRIM(NVL(p_CONTRACT_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.CONTRACT_DESC := TRIM(NVL(p_CONTRACT_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.CONTRACT_STATUS := TRIM(NVL(p_CONTRACT_STATUS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.BEGIN_DATE := p_BEGIN_DATE;
	v_REC.END_DATE := p_END_DATE;
	v_REC.IS_EVERGREEN := p_IS_EVERGREEN;
	v_REC.CONTRACT_TYPE := TRIM(NVL(p_CONTRACT_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.BILLING_ENTITY_ID := NVL(p_BILLING_ENTITY_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.PURCHASER_ID := NVL(p_PURCHASER_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.SELLER_ID := NVL(p_SELLER_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.SOURCE_ID := NVL(p_SOURCE_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.SINK_ID := NVL(p_SINK_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.POR_ID := NVL(p_POR_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.POD_ID := NVL(p_POD_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.SC_ID := NVL(p_SC_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.AGREEMENT_TYPE := TRIM(NVL(p_AGREEMENT_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.APPROVAL_TYPE := TRIM(NVL(p_APPROVAL_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.MARKET_TYPE := TRIM(NVL(p_MARKET_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.LOSS_OPTION := TRIM(NVL(p_LOSS_OPTION,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.CONTRACT_FILE_NAME := TRIM(NVL(p_CONTRACT_FILE_NAME,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PIPELINE_ID := NVL(p_PIPELINE_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.PIPELINE_TARIFF_TYPE := TRIM(NVL(p_PIPELINE_TARIFF_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_CONTRACT_ID > 0 OR p_CONTRACT_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_CONTRACT_ID, EC.ED_INTERCHANGE_CONTRACT) 
                 AND IO_UTIL.INTERCHANGE_CONTRACT_IS_ALLOWE (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_INTERCHANGE_CONTRACT, p_CONTRACT_ID);
		END IF;

		-- save it!
		UPDATE INTERCHANGE_CONTRACT
		SET ROW = v_REC
		WHERE CONTRACT_ID = p_CONTRACT_ID;
		o_OID := p_CONTRACT_ID;
        
	ELSIF p_CONTRACT_ID IS NULL OR p_CONTRACT_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.INTERCHANGE_CONTRACT_IS_ALLOWE (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_INTERCHANGE_CONTRACT, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.CONTRACT_ID := o_OID;
		-- save it!
		INSERT INTO INTERCHANGE_CONTRACT VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_CONTRACT_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_INTERCHANGE_CONTRACT, EC.ED_ENTITY_DOMAIN)||': '||p_CONTRACT_NAME);
END PUT_INTERCHANGE_CONTRACT;
---------------------------------------------------------------------
PROCEDURE GET_INTERCHANGE_CONTRACT
	(
	p_CONTRACT_ID IN NUMBER,
	p_CONTRACT_NAME OUT VARCHAR2,
	p_CONTRACT_ALIAS OUT VARCHAR2,
	p_CONTRACT_DESC OUT VARCHAR2,
	p_CONTRACT_STATUS OUT VARCHAR2,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE,
	p_IS_EVERGREEN OUT NUMBER,
	p_CONTRACT_TYPE OUT VARCHAR2,
	p_BILLING_ENTITY_ID OUT NUMBER,
	p_PURCHASER_ID OUT NUMBER,
	p_SELLER_ID OUT NUMBER,
	p_SOURCE_ID OUT NUMBER,
	p_SINK_ID OUT NUMBER,
	p_POR_ID OUT NUMBER,
	p_POD_ID OUT NUMBER,
	p_SC_ID OUT NUMBER,
	p_AGREEMENT_TYPE OUT VARCHAR2,
	p_APPROVAL_TYPE OUT VARCHAR2,
	p_MARKET_TYPE OUT VARCHAR2,
	p_LOSS_OPTION OUT VARCHAR2,
	p_CONTRACT_FILE_NAME OUT VARCHAR2,
	p_PIPELINE_ID OUT NUMBER,
	p_PIPELINE_TARIFF_TYPE OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD INTERCHANGE_CONTRACT%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_CONTRACT_ID, EC.ED_INTERCHANGE_CONTRACT);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM INTERCHANGE_CONTRACT
	WHERE CONTRACT_ID = p_CONTRACT_ID;
    
	-- Set the output parameters
	p_CONTRACT_NAME := v_RECORD.CONTRACT_NAME;
	p_CONTRACT_ALIAS := v_RECORD.CONTRACT_ALIAS;
	p_CONTRACT_DESC := v_RECORD.CONTRACT_DESC;
	p_CONTRACT_STATUS := v_RECORD.CONTRACT_STATUS;
	p_BEGIN_DATE := v_RECORD.BEGIN_DATE;
	p_END_DATE := v_RECORD.END_DATE;
	p_IS_EVERGREEN := v_RECORD.IS_EVERGREEN;
	p_CONTRACT_TYPE := v_RECORD.CONTRACT_TYPE;
	p_BILLING_ENTITY_ID := v_RECORD.BILLING_ENTITY_ID;
	p_PURCHASER_ID := v_RECORD.PURCHASER_ID;
	p_SELLER_ID := v_RECORD.SELLER_ID;
	p_SOURCE_ID := v_RECORD.SOURCE_ID;
	p_SINK_ID := v_RECORD.SINK_ID;
	p_POR_ID := v_RECORD.POR_ID;
	p_POD_ID := v_RECORD.POD_ID;
	p_SC_ID := v_RECORD.SC_ID;
	p_AGREEMENT_TYPE := v_RECORD.AGREEMENT_TYPE;
	p_APPROVAL_TYPE := v_RECORD.APPROVAL_TYPE;
	p_MARKET_TYPE := v_RECORD.MARKET_TYPE;
	p_LOSS_OPTION := v_RECORD.LOSS_OPTION;
	p_CONTRACT_FILE_NAME := v_RECORD.CONTRACT_FILE_NAME;
	p_PIPELINE_ID := v_RECORD.PIPELINE_ID;
	p_PIPELINE_TARIFF_TYPE := v_RECORD.PIPELINE_TARIFF_TYPE;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_CONTRACT_NAME := g_EMPTY_VARCHAR2;
		p_CONTRACT_ALIAS := g_EMPTY_VARCHAR2;
		p_CONTRACT_DESC := g_EMPTY_VARCHAR2;
		p_CONTRACT_STATUS := g_EMPTY_VARCHAR2;
		p_BEGIN_DATE := g_EMPTY_DATE;
		p_END_DATE := g_EMPTY_DATE;
		p_IS_EVERGREEN := g_EMPTY_NUMBER;
		p_CONTRACT_TYPE := g_EMPTY_VARCHAR2;
		p_BILLING_ENTITY_ID := g_EMPTY_NUMBER;
		p_PURCHASER_ID := g_EMPTY_NUMBER;
		p_SELLER_ID := g_EMPTY_NUMBER;
		p_SOURCE_ID := g_EMPTY_NUMBER;
		p_SINK_ID := g_EMPTY_NUMBER;
		p_POR_ID := g_EMPTY_NUMBER;
		p_POD_ID := g_EMPTY_NUMBER;
		p_SC_ID := g_EMPTY_NUMBER;
		p_AGREEMENT_TYPE := g_EMPTY_VARCHAR2;
		p_APPROVAL_TYPE := g_EMPTY_VARCHAR2;
		p_MARKET_TYPE := g_EMPTY_VARCHAR2;
		p_LOSS_OPTION := g_EMPTY_VARCHAR2;
		p_CONTRACT_FILE_NAME := g_EMPTY_VARCHAR2;
		p_PIPELINE_ID := g_EMPTY_NUMBER;
		p_PIPELINE_TARIFF_TYPE := g_EMPTY_VARCHAR2;

END GET_INTERCHANGE_CONTRACT;
---------------------------------------------------------------------
PROCEDURE PUT_INVOICE_GROUP
	(
	o_OID OUT NUMBER,
	p_INVOICE_GROUP_NAME IN VARCHAR2,
	p_INVOICE_GROUP_ALIAS IN VARCHAR2,
	p_INVOICE_GROUP_DESC IN VARCHAR2,
	p_INVOICE_GROUP_ID IN NUMBER,
	p_DISPLAY_ORDER IN NUMBER,
	p_SHOW_TITLE_ON_INVOICE IN NUMBER,
	p_SHOW_SUBTOTAL_ON_INVOICE IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC INVOICE_GROUP%ROWTYPE;
BEGIN


	v_REC.INVOICE_GROUP_ID := p_INVOICE_GROUP_ID;
	v_REC.INVOICE_GROUP_NAME := TRIM(p_INVOICE_GROUP_NAME);
	v_REC.INVOICE_GROUP_ALIAS := TRIM(NVL(p_INVOICE_GROUP_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.INVOICE_GROUP_DESC := TRIM(NVL(p_INVOICE_GROUP_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.DISPLAY_ORDER := p_DISPLAY_ORDER;
	v_REC.SHOW_TITLE_ON_INVOICE := p_SHOW_TITLE_ON_INVOICE;
	v_REC.SHOW_SUBTOTAL_ON_INVOICE := p_SHOW_SUBTOTAL_ON_INVOICE;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_INVOICE_GROUP_ID > 0 OR p_INVOICE_GROUP_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_INVOICE_GROUP_ID, EC.ED_INVOICE_GROUP) 
                 AND IO_UTIL.INVOICE_GROUP_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_INVOICE_GROUP, p_INVOICE_GROUP_ID);
		END IF;

		-- save it!
		UPDATE INVOICE_GROUP
		SET ROW = v_REC
		WHERE INVOICE_GROUP_ID = p_INVOICE_GROUP_ID;
		o_OID := p_INVOICE_GROUP_ID;
        
	ELSIF p_INVOICE_GROUP_ID IS NULL OR p_INVOICE_GROUP_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.INVOICE_GROUP_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_INVOICE_GROUP, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.INVOICE_GROUP_ID := o_OID;
		-- save it!
		INSERT INTO INVOICE_GROUP VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_INVOICE_GROUP_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_INVOICE_GROUP, EC.ED_ENTITY_DOMAIN)||': '||p_INVOICE_GROUP_NAME);
END PUT_INVOICE_GROUP;
---------------------------------------------------------------------
PROCEDURE GET_INVOICE_GROUP
	(
	p_INVOICE_GROUP_ID IN NUMBER,
	p_INVOICE_GROUP_NAME OUT VARCHAR2,
	p_INVOICE_GROUP_ALIAS OUT VARCHAR2,
	p_INVOICE_GROUP_DESC OUT VARCHAR2,
	p_DISPLAY_ORDER OUT NUMBER,
	p_SHOW_TITLE_ON_INVOICE OUT NUMBER,
	p_SHOW_SUBTOTAL_ON_INVOICE OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD INVOICE_GROUP%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_INVOICE_GROUP_ID, EC.ED_INVOICE_GROUP);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM INVOICE_GROUP
	WHERE INVOICE_GROUP_ID = p_INVOICE_GROUP_ID;
    
	-- Set the output parameters
	p_INVOICE_GROUP_NAME := v_RECORD.INVOICE_GROUP_NAME;
	p_INVOICE_GROUP_ALIAS := v_RECORD.INVOICE_GROUP_ALIAS;
	p_INVOICE_GROUP_DESC := v_RECORD.INVOICE_GROUP_DESC;
	p_DISPLAY_ORDER := v_RECORD.DISPLAY_ORDER;
	p_SHOW_TITLE_ON_INVOICE := v_RECORD.SHOW_TITLE_ON_INVOICE;
	p_SHOW_SUBTOTAL_ON_INVOICE := v_RECORD.SHOW_SUBTOTAL_ON_INVOICE;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_INVOICE_GROUP_NAME := g_EMPTY_VARCHAR2;
		p_INVOICE_GROUP_ALIAS := g_EMPTY_VARCHAR2;
		p_INVOICE_GROUP_DESC := g_EMPTY_VARCHAR2;
		p_DISPLAY_ORDER := g_EMPTY_NUMBER;
		p_SHOW_TITLE_ON_INVOICE := g_EMPTY_NUMBER;
		p_SHOW_SUBTOTAL_ON_INVOICE := g_EMPTY_NUMBER;

END GET_INVOICE_GROUP;
---------------------------------------------------------------------
PROCEDURE PUT_IT_COMMODITY
	(
	o_OID OUT NUMBER,
	p_COMMODITY_NAME IN VARCHAR2,
	p_COMMODITY_ALIAS IN VARCHAR2,
	p_COMMODITY_DESC IN VARCHAR2,
	p_COMMODITY_ID IN NUMBER,
	p_COMMODITY_TYPE IN VARCHAR2,
	p_COMMODITY_UNIT IN VARCHAR2,
	p_COMMODITY_UNIT_FORMAT IN VARCHAR2,
	p_COMMODITY_PRICE_UNIT IN VARCHAR2,
	p_COMMODITY_PRICE_FORMAT IN VARCHAR2,
	p_IS_VIRTUAL IN NUMBER,
	p_MARKET_TYPE IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC IT_COMMODITY%ROWTYPE;
BEGIN


	v_REC.COMMODITY_ID := p_COMMODITY_ID;
	v_REC.COMMODITY_NAME := TRIM(p_COMMODITY_NAME);
	v_REC.COMMODITY_ALIAS := TRIM(NVL(p_COMMODITY_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.COMMODITY_DESC := TRIM(NVL(p_COMMODITY_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.COMMODITY_TYPE := TRIM(NVL(p_COMMODITY_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.COMMODITY_UNIT := TRIM(NVL(p_COMMODITY_UNIT,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.COMMODITY_UNIT_FORMAT := TRIM(NVL(p_COMMODITY_UNIT_FORMAT,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.COMMODITY_PRICE_UNIT := TRIM(NVL(p_COMMODITY_PRICE_UNIT,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.COMMODITY_PRICE_FORMAT := TRIM(NVL(p_COMMODITY_PRICE_FORMAT,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.IS_VIRTUAL := p_IS_VIRTUAL;
	v_REC.MARKET_TYPE := TRIM(NVL(p_MARKET_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_COMMODITY_ID > 0 OR p_COMMODITY_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_COMMODITY_ID, EC.ED_IT_COMMODITY) 
                 AND IO_UTIL.IT_COMMODITY_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_IT_COMMODITY, p_COMMODITY_ID);
		END IF;

		-- save it!
		UPDATE IT_COMMODITY
		SET ROW = v_REC
		WHERE COMMODITY_ID = p_COMMODITY_ID;
		o_OID := p_COMMODITY_ID;
        
	ELSIF p_COMMODITY_ID IS NULL OR p_COMMODITY_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.IT_COMMODITY_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_IT_COMMODITY, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.COMMODITY_ID := o_OID;
		-- save it!
		INSERT INTO IT_COMMODITY VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_COMMODITY_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_IT_COMMODITY, EC.ED_ENTITY_DOMAIN)||': '||p_COMMODITY_NAME);
END PUT_IT_COMMODITY;
---------------------------------------------------------------------
PROCEDURE GET_IT_COMMODITY
	(
	p_COMMODITY_ID IN NUMBER,
	p_COMMODITY_NAME OUT VARCHAR2,
	p_COMMODITY_ALIAS OUT VARCHAR2,
	p_COMMODITY_DESC OUT VARCHAR2,
	p_COMMODITY_TYPE OUT VARCHAR2,
	p_COMMODITY_UNIT OUT VARCHAR2,
	p_COMMODITY_UNIT_FORMAT OUT VARCHAR2,
	p_COMMODITY_PRICE_UNIT OUT VARCHAR2,
	p_COMMODITY_PRICE_FORMAT OUT VARCHAR2,
	p_IS_VIRTUAL OUT NUMBER,
	p_MARKET_TYPE OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD IT_COMMODITY%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_COMMODITY_ID, EC.ED_IT_COMMODITY);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM IT_COMMODITY
	WHERE COMMODITY_ID = p_COMMODITY_ID;
    
	-- Set the output parameters
	p_COMMODITY_NAME := v_RECORD.COMMODITY_NAME;
	p_COMMODITY_ALIAS := v_RECORD.COMMODITY_ALIAS;
	p_COMMODITY_DESC := v_RECORD.COMMODITY_DESC;
	p_COMMODITY_TYPE := v_RECORD.COMMODITY_TYPE;
	p_COMMODITY_UNIT := v_RECORD.COMMODITY_UNIT;
	p_COMMODITY_UNIT_FORMAT := v_RECORD.COMMODITY_UNIT_FORMAT;
	p_COMMODITY_PRICE_UNIT := v_RECORD.COMMODITY_PRICE_UNIT;
	p_COMMODITY_PRICE_FORMAT := v_RECORD.COMMODITY_PRICE_FORMAT;
	p_IS_VIRTUAL := v_RECORD.IS_VIRTUAL;
	p_MARKET_TYPE := v_RECORD.MARKET_TYPE;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_COMMODITY_NAME := g_EMPTY_VARCHAR2;
		p_COMMODITY_ALIAS := g_EMPTY_VARCHAR2;
		p_COMMODITY_DESC := g_EMPTY_VARCHAR2;
		p_COMMODITY_TYPE := g_EMPTY_VARCHAR2;
		p_COMMODITY_UNIT := g_EMPTY_VARCHAR2;
		p_COMMODITY_UNIT_FORMAT := g_EMPTY_VARCHAR2;
		p_COMMODITY_PRICE_UNIT := g_EMPTY_VARCHAR2;
		p_COMMODITY_PRICE_FORMAT := g_EMPTY_VARCHAR2;
		p_IS_VIRTUAL := g_EMPTY_NUMBER;
		p_MARKET_TYPE := g_EMPTY_VARCHAR2;

END GET_IT_COMMODITY;
---------------------------------------------------------------------
PROCEDURE PUT_JOB_THREAD
	(
	o_OID OUT NUMBER,
	p_JOB_THREAD_NAME IN VARCHAR2,
	p_JOB_THREAD_ALIAS IN VARCHAR2,
	p_JOB_THREAD_DESC IN VARCHAR2,
	p_JOB_THREAD_ID IN NUMBER,
	p_JOB_CLASS IN VARCHAR2,
	p_IS_SNOOZED IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC JOB_THREAD%ROWTYPE;
BEGIN


	v_REC.JOB_THREAD_ID := p_JOB_THREAD_ID;
	v_REC.JOB_THREAD_NAME := TRIM(p_JOB_THREAD_NAME);
	v_REC.JOB_THREAD_ALIAS := TRIM(NVL(p_JOB_THREAD_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.JOB_THREAD_DESC := TRIM(NVL(p_JOB_THREAD_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.JOB_CLASS := TRIM(p_JOB_CLASS);
	v_REC.IS_SNOOZED := p_IS_SNOOZED;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_JOB_THREAD_ID > 0 OR p_JOB_THREAD_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_JOB_THREAD_ID, EC.ED_JOB_THREAD) 
                 AND IO_UTIL.JOB_THREAD_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_JOB_THREAD, p_JOB_THREAD_ID);
		END IF;

		-- save it!
		UPDATE JOB_THREAD
		SET ROW = v_REC
		WHERE JOB_THREAD_ID = p_JOB_THREAD_ID;
		o_OID := p_JOB_THREAD_ID;
        
	ELSIF p_JOB_THREAD_ID IS NULL OR p_JOB_THREAD_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.JOB_THREAD_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_JOB_THREAD, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.JOB_THREAD_ID := o_OID;
		-- save it!
		INSERT INTO JOB_THREAD VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_JOB_THREAD_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_JOB_THREAD, EC.ED_ENTITY_DOMAIN)||': '||p_JOB_THREAD_NAME);
END PUT_JOB_THREAD;
---------------------------------------------------------------------
PROCEDURE GET_JOB_THREAD
	(
	p_JOB_THREAD_ID IN NUMBER,
	p_JOB_THREAD_NAME OUT VARCHAR2,
	p_JOB_THREAD_ALIAS OUT VARCHAR2,
	p_JOB_THREAD_DESC OUT VARCHAR2,
	p_JOB_CLASS OUT VARCHAR2,
	p_IS_SNOOZED OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD JOB_THREAD%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_JOB_THREAD_ID, EC.ED_JOB_THREAD);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM JOB_THREAD
	WHERE JOB_THREAD_ID = p_JOB_THREAD_ID;
    
	-- Set the output parameters
	p_JOB_THREAD_NAME := v_RECORD.JOB_THREAD_NAME;
	p_JOB_THREAD_ALIAS := v_RECORD.JOB_THREAD_ALIAS;
	p_JOB_THREAD_DESC := v_RECORD.JOB_THREAD_DESC;
	p_JOB_CLASS := v_RECORD.JOB_CLASS;
	p_IS_SNOOZED := v_RECORD.IS_SNOOZED;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_JOB_THREAD_NAME := g_EMPTY_VARCHAR2;
		p_JOB_THREAD_ALIAS := g_EMPTY_VARCHAR2;
		p_JOB_THREAD_DESC := g_EMPTY_VARCHAR2;
		p_JOB_CLASS := g_EMPTY_VARCHAR2;
		p_IS_SNOOZED := g_EMPTY_NUMBER;

END GET_JOB_THREAD;
---------------------------------------------------------------------
PROCEDURE PUT_LOAD_PROFILE
	(
	o_OID OUT NUMBER,
	p_PROFILE_LIBRARY_ID IN NUMBER,
	p_PROFILE_NAME IN VARCHAR2,
	p_PROFILE_ALIAS IN VARCHAR2,
	p_PROFILE_DESC IN VARCHAR2,
	p_PROFILE_ID IN NUMBER,
	p_PROFILE_TYPE IN VARCHAR2,
	p_PROFILE_OPERATION IN VARCHAR2,
	p_PROFILE_ORIGIN IN VARCHAR2,
	p_PROFILE_RATE_CLASS IN VARCHAR2,
	p_PROFILE_DAY_TYPE IN VARCHAR2,
	p_PROFILE_ACCOUNT_REF IN VARCHAR2,
	p_PROFILE_METER_REF IN VARCHAR2,
	p_PROFILE_SIC_CODE IN VARCHAR2,
	p_PROFILE_SEASON IN VARCHAR2,
	p_PROFILE_SYSTEM_LOAD IN VARCHAR2,
	p_PROFILE_ADJUSTMENT_OPTION IN VARCHAR2,
	p_PROFILE_STATION_ID IN NUMBER,
	p_PROFILE_TEMPLATE_ID IN NUMBER,
	p_PROFILE_SOURCE_BEGIN_DATE IN DATE,
	p_PROFILE_SOURCE_END_DATE IN DATE,
	p_PROFILE_SOURCE_ID IN NUMBER,
	p_PROFILE_INTERVAL IN NUMBER,
	p_PROFILE_SOURCE_VERSION IN DATE,
	p_PROFILE_BREAKPOINT_INTERVAL IN VARCHAR2,
	p_IS_EXTERNAL_PROFILE IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC LOAD_PROFILE%ROWTYPE;
BEGIN


	v_REC.PROFILE_LIBRARY_ID := NVL(p_PROFILE_LIBRARY_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.PROFILE_ID := p_PROFILE_ID;
	v_REC.PROFILE_NAME := TRIM(p_PROFILE_NAME);
	v_REC.PROFILE_ALIAS := TRIM(NVL(p_PROFILE_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PROFILE_DESC := TRIM(NVL(p_PROFILE_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PROFILE_TYPE := TRIM(NVL(p_PROFILE_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PROFILE_OPERATION := TRIM(NVL(p_PROFILE_OPERATION,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PROFILE_ORIGIN := TRIM(NVL(p_PROFILE_ORIGIN,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PROFILE_RATE_CLASS := TRIM(NVL(p_PROFILE_RATE_CLASS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PROFILE_DAY_TYPE := TRIM(NVL(p_PROFILE_DAY_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PROFILE_ACCOUNT_REF := TRIM(NVL(p_PROFILE_ACCOUNT_REF,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PROFILE_METER_REF := TRIM(NVL(p_PROFILE_METER_REF,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PROFILE_SIC_CODE := TRIM(NVL(p_PROFILE_SIC_CODE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PROFILE_SEASON := TRIM(NVL(p_PROFILE_SEASON,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PROFILE_SYSTEM_LOAD := TRIM(NVL(p_PROFILE_SYSTEM_LOAD,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PROFILE_ADJUSTMENT_OPTION := TRIM(NVL(p_PROFILE_ADJUSTMENT_OPTION,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PROFILE_STATION_ID := NVL(p_PROFILE_STATION_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.PROFILE_TEMPLATE_ID := NVL(p_PROFILE_TEMPLATE_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.PROFILE_SOURCE_BEGIN_DATE := p_PROFILE_SOURCE_BEGIN_DATE;
	v_REC.PROFILE_SOURCE_END_DATE := p_PROFILE_SOURCE_END_DATE;
	v_REC.PROFILE_SOURCE_ID := NVL(p_PROFILE_SOURCE_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.PROFILE_INTERVAL := p_PROFILE_INTERVAL;
	v_REC.PROFILE_SOURCE_VERSION := p_PROFILE_SOURCE_VERSION;
	v_REC.PROFILE_BREAKPOINT_INTERVAL := TRIM(NVL(p_PROFILE_BREAKPOINT_INTERVAL,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.IS_EXTERNAL_PROFILE := p_IS_EXTERNAL_PROFILE;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_PROFILE_ID > 0 OR p_PROFILE_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_PROFILE_ID, EC.ED_LOAD_PROFILE) 
                 AND IO_UTIL.LOAD_PROFILE_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_LOAD_PROFILE, p_PROFILE_ID);
		END IF;

		-- save it!
		UPDATE LOAD_PROFILE
		SET ROW = v_REC
		WHERE PROFILE_ID = p_PROFILE_ID;
		o_OID := p_PROFILE_ID;
        
	ELSIF p_PROFILE_ID IS NULL OR p_PROFILE_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.LOAD_PROFILE_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_LOAD_PROFILE, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.PROFILE_ID := o_OID;
		-- save it!
		INSERT INTO LOAD_PROFILE VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_PROFILE_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_LOAD_PROFILE, EC.ED_ENTITY_DOMAIN)||': '||p_PROFILE_NAME);
END PUT_LOAD_PROFILE;
---------------------------------------------------------------------
PROCEDURE GET_LOAD_PROFILE
	(
	p_PROFILE_LIBRARY_ID OUT NUMBER,
	p_PROFILE_ID IN NUMBER,
	p_PROFILE_NAME OUT VARCHAR2,
	p_PROFILE_ALIAS OUT VARCHAR2,
	p_PROFILE_DESC OUT VARCHAR2,
	p_PROFILE_TYPE OUT VARCHAR2,
	p_PROFILE_OPERATION OUT VARCHAR2,
	p_PROFILE_ORIGIN OUT VARCHAR2,
	p_PROFILE_RATE_CLASS OUT VARCHAR2,
	p_PROFILE_DAY_TYPE OUT VARCHAR2,
	p_PROFILE_ACCOUNT_REF OUT VARCHAR2,
	p_PROFILE_METER_REF OUT VARCHAR2,
	p_PROFILE_SIC_CODE OUT VARCHAR2,
	p_PROFILE_SEASON OUT VARCHAR2,
	p_PROFILE_SYSTEM_LOAD OUT VARCHAR2,
	p_PROFILE_ADJUSTMENT_OPTION OUT VARCHAR2,
	p_PROFILE_STATION_ID OUT NUMBER,
	p_PROFILE_TEMPLATE_ID OUT NUMBER,
	p_PROFILE_SOURCE_BEGIN_DATE OUT DATE,
	p_PROFILE_SOURCE_END_DATE OUT DATE,
	p_PROFILE_SOURCE_ID OUT NUMBER,
	p_PROFILE_INTERVAL OUT NUMBER,
	p_PROFILE_SOURCE_VERSION OUT DATE,
	p_PROFILE_BREAKPOINT_INTERVAL OUT VARCHAR2,
	p_IS_EXTERNAL_PROFILE OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD LOAD_PROFILE%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_PROFILE_ID, EC.ED_LOAD_PROFILE);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM LOAD_PROFILE
	WHERE PROFILE_ID = p_PROFILE_ID;
    
	-- Set the output parameters
	p_PROFILE_LIBRARY_ID := v_RECORD.PROFILE_LIBRARY_ID;
	p_PROFILE_NAME := v_RECORD.PROFILE_NAME;
	p_PROFILE_ALIAS := v_RECORD.PROFILE_ALIAS;
	p_PROFILE_DESC := v_RECORD.PROFILE_DESC;
	p_PROFILE_TYPE := v_RECORD.PROFILE_TYPE;
	p_PROFILE_OPERATION := v_RECORD.PROFILE_OPERATION;
	p_PROFILE_ORIGIN := v_RECORD.PROFILE_ORIGIN;
	p_PROFILE_RATE_CLASS := v_RECORD.PROFILE_RATE_CLASS;
	p_PROFILE_DAY_TYPE := v_RECORD.PROFILE_DAY_TYPE;
	p_PROFILE_ACCOUNT_REF := v_RECORD.PROFILE_ACCOUNT_REF;
	p_PROFILE_METER_REF := v_RECORD.PROFILE_METER_REF;
	p_PROFILE_SIC_CODE := v_RECORD.PROFILE_SIC_CODE;
	p_PROFILE_SEASON := v_RECORD.PROFILE_SEASON;
	p_PROFILE_SYSTEM_LOAD := v_RECORD.PROFILE_SYSTEM_LOAD;
	p_PROFILE_ADJUSTMENT_OPTION := v_RECORD.PROFILE_ADJUSTMENT_OPTION;
	p_PROFILE_STATION_ID := v_RECORD.PROFILE_STATION_ID;
	p_PROFILE_TEMPLATE_ID := v_RECORD.PROFILE_TEMPLATE_ID;
	p_PROFILE_SOURCE_BEGIN_DATE := v_RECORD.PROFILE_SOURCE_BEGIN_DATE;
	p_PROFILE_SOURCE_END_DATE := v_RECORD.PROFILE_SOURCE_END_DATE;
	p_PROFILE_SOURCE_ID := v_RECORD.PROFILE_SOURCE_ID;
	p_PROFILE_INTERVAL := v_RECORD.PROFILE_INTERVAL;
	p_PROFILE_SOURCE_VERSION := v_RECORD.PROFILE_SOURCE_VERSION;
	p_PROFILE_BREAKPOINT_INTERVAL := v_RECORD.PROFILE_BREAKPOINT_INTERVAL;
	p_IS_EXTERNAL_PROFILE := v_RECORD.IS_EXTERNAL_PROFILE;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_PROFILE_LIBRARY_ID := g_EMPTY_NUMBER;
		p_PROFILE_NAME := g_EMPTY_VARCHAR2;
		p_PROFILE_ALIAS := g_EMPTY_VARCHAR2;
		p_PROFILE_DESC := g_EMPTY_VARCHAR2;
		p_PROFILE_TYPE := g_EMPTY_VARCHAR2;
		p_PROFILE_OPERATION := g_EMPTY_VARCHAR2;
		p_PROFILE_ORIGIN := g_EMPTY_VARCHAR2;
		p_PROFILE_RATE_CLASS := g_EMPTY_VARCHAR2;
		p_PROFILE_DAY_TYPE := g_EMPTY_VARCHAR2;
		p_PROFILE_ACCOUNT_REF := g_EMPTY_VARCHAR2;
		p_PROFILE_METER_REF := g_EMPTY_VARCHAR2;
		p_PROFILE_SIC_CODE := g_EMPTY_VARCHAR2;
		p_PROFILE_SEASON := g_EMPTY_VARCHAR2;
		p_PROFILE_SYSTEM_LOAD := g_EMPTY_VARCHAR2;
		p_PROFILE_ADJUSTMENT_OPTION := g_EMPTY_VARCHAR2;
		p_PROFILE_STATION_ID := g_EMPTY_NUMBER;
		p_PROFILE_TEMPLATE_ID := g_EMPTY_NUMBER;
		p_PROFILE_SOURCE_BEGIN_DATE := g_EMPTY_DATE;
		p_PROFILE_SOURCE_END_DATE := g_EMPTY_DATE;
		p_PROFILE_SOURCE_ID := g_EMPTY_NUMBER;
		p_PROFILE_INTERVAL := g_EMPTY_NUMBER;
		p_PROFILE_SOURCE_VERSION := g_EMPTY_DATE;
		p_PROFILE_BREAKPOINT_INTERVAL := g_EMPTY_VARCHAR2;
		p_IS_EXTERNAL_PROFILE := g_EMPTY_NUMBER;

END GET_LOAD_PROFILE;
---------------------------------------------------------------------
PROCEDURE PUT_LOAD_PROFILE_LIBRARY
	(
	o_OID OUT NUMBER,
	p_PROFILE_LIBRARY_NAME IN VARCHAR2,
	p_PROFILE_LIBRARY_ALIAS IN VARCHAR2,
	p_PROFILE_LIBRARY_DESC IN VARCHAR2,
	p_PROFILE_LIBRARY_ID IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC LOAD_PROFILE_LIBRARY%ROWTYPE;
BEGIN


	v_REC.PROFILE_LIBRARY_ID := p_PROFILE_LIBRARY_ID;
	v_REC.PROFILE_LIBRARY_NAME := TRIM(p_PROFILE_LIBRARY_NAME);
	v_REC.PROFILE_LIBRARY_ALIAS := TRIM(NVL(p_PROFILE_LIBRARY_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PROFILE_LIBRARY_DESC := TRIM(NVL(p_PROFILE_LIBRARY_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_PROFILE_LIBRARY_ID > 0 OR p_PROFILE_LIBRARY_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_PROFILE_LIBRARY_ID, EC.ED_LOAD_PROFILE_LIBRARY) 
                 AND IO_UTIL.LOAD_PROFILE_LIBRARY_IS_ALLOWE (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_LOAD_PROFILE_LIBRARY, p_PROFILE_LIBRARY_ID);
		END IF;

		-- save it!
		UPDATE LOAD_PROFILE_LIBRARY
		SET ROW = v_REC
		WHERE PROFILE_LIBRARY_ID = p_PROFILE_LIBRARY_ID;
		o_OID := p_PROFILE_LIBRARY_ID;
        
	ELSIF p_PROFILE_LIBRARY_ID IS NULL OR p_PROFILE_LIBRARY_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.LOAD_PROFILE_LIBRARY_IS_ALLOWE (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_LOAD_PROFILE_LIBRARY, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.PROFILE_LIBRARY_ID := o_OID;
		-- save it!
		INSERT INTO LOAD_PROFILE_LIBRARY VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_PROFILE_LIBRARY_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_LOAD_PROFILE_LIBRARY, EC.ED_ENTITY_DOMAIN)||': '||p_PROFILE_LIBRARY_NAME);
END PUT_LOAD_PROFILE_LIBRARY;
---------------------------------------------------------------------
PROCEDURE GET_LOAD_PROFILE_LIBRARY
	(
	p_PROFILE_LIBRARY_ID IN NUMBER,
	p_PROFILE_LIBRARY_NAME OUT VARCHAR2,
	p_PROFILE_LIBRARY_ALIAS OUT VARCHAR2,
	p_PROFILE_LIBRARY_DESC OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD LOAD_PROFILE_LIBRARY%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_PROFILE_LIBRARY_ID, EC.ED_LOAD_PROFILE_LIBRARY);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM LOAD_PROFILE_LIBRARY
	WHERE PROFILE_LIBRARY_ID = p_PROFILE_LIBRARY_ID;
    
	-- Set the output parameters
	p_PROFILE_LIBRARY_NAME := v_RECORD.PROFILE_LIBRARY_NAME;
	p_PROFILE_LIBRARY_ALIAS := v_RECORD.PROFILE_LIBRARY_ALIAS;
	p_PROFILE_LIBRARY_DESC := v_RECORD.PROFILE_LIBRARY_DESC;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_PROFILE_LIBRARY_NAME := g_EMPTY_VARCHAR2;
		p_PROFILE_LIBRARY_ALIAS := g_EMPTY_VARCHAR2;
		p_PROFILE_LIBRARY_DESC := g_EMPTY_VARCHAR2;

END GET_LOAD_PROFILE_LIBRARY;
---------------------------------------------------------------------
PROCEDURE PUT_LOAD_PROFILE_SET
	(
	o_OID OUT NUMBER,
	p_PROFILE_SET_NAME IN VARCHAR2,
	p_PROFILE_SET_ALIAS IN VARCHAR2,
	p_PROFILE_SET_DESC IN VARCHAR2,
	p_PROFILE_SET_ID IN NUMBER,
	p_PROFILE_ID IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC LOAD_PROFILE_SET%ROWTYPE;
BEGIN
	-- Make sure user has access
	IF NOT CAN_WRITE('Data Setup') THEN
        ERRS.RAISE_NO_WRITE_MODULE('Data Setup');
	END IF;



	v_REC.PROFILE_SET_ID := p_PROFILE_SET_ID;
	v_REC.PROFILE_SET_NAME := TRIM(p_PROFILE_SET_NAME);
	v_REC.PROFILE_SET_ALIAS := TRIM(NVL(p_PROFILE_SET_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PROFILE_SET_DESC := TRIM(NVL(p_PROFILE_SET_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PROFILE_ID := p_PROFILE_ID;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_PROFILE_SET_ID > 0 OR p_PROFILE_SET_ID < -10 THEN

		-- save it!
		UPDATE LOAD_PROFILE_SET
		SET ROW = v_REC
		WHERE PROFILE_SET_ID = p_PROFILE_SET_ID;
		o_OID := p_PROFILE_SET_ID;
        
	ELSIF p_PROFILE_SET_ID IS NULL OR p_PROFILE_SET_ID = 0 THEN

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.PROFILE_SET_ID := o_OID;
		-- save it!
		INSERT INTO LOAD_PROFILE_SET VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_PROFILE_SET_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, 'LOAD_PROFILE_SET: '||p_PROFILE_SET_NAME);
END PUT_LOAD_PROFILE_SET;
---------------------------------------------------------------------
PROCEDURE GET_LOAD_PROFILE_SET
	(
	p_PROFILE_SET_ID IN NUMBER,
	p_PROFILE_SET_NAME OUT VARCHAR2,
	p_PROFILE_SET_ALIAS OUT VARCHAR2,
	p_PROFILE_SET_DESC OUT VARCHAR2,
	p_PROFILE_ID OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD LOAD_PROFILE_SET%ROWTYPE;
BEGIN
	-- Make sure user has access
	IF NOT CAN_READ('Data Setup') THEN
        ERRS.RAISE_NO_READ_MODULE('Data Setup');
	END IF;

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM LOAD_PROFILE_SET
	WHERE PROFILE_SET_ID = p_PROFILE_SET_ID;
    
	-- Set the output parameters
	p_PROFILE_SET_NAME := v_RECORD.PROFILE_SET_NAME;
	p_PROFILE_SET_ALIAS := v_RECORD.PROFILE_SET_ALIAS;
	p_PROFILE_SET_DESC := v_RECORD.PROFILE_SET_DESC;
	p_PROFILE_ID := v_RECORD.PROFILE_ID;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_PROFILE_SET_NAME := g_EMPTY_VARCHAR2;
		p_PROFILE_SET_ALIAS := g_EMPTY_VARCHAR2;
		p_PROFILE_SET_DESC := g_EMPTY_VARCHAR2;
		p_PROFILE_ID := g_EMPTY_NUMBER;

END GET_LOAD_PROFILE_SET;
---------------------------------------------------------------------
PROCEDURE PUT_LOSS_FACTOR
	(
	o_OID OUT NUMBER,
	p_LOSS_FACTOR_NAME IN VARCHAR2,
	p_LOSS_FACTOR_ALIAS IN VARCHAR2,
	p_LOSS_FACTOR_DESC IN VARCHAR2,
	p_LOSS_FACTOR_ID IN NUMBER,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC LOSS_FACTOR%ROWTYPE;
BEGIN


	v_REC.LOSS_FACTOR_ID := p_LOSS_FACTOR_ID;
	v_REC.LOSS_FACTOR_NAME := TRIM(p_LOSS_FACTOR_NAME);
	v_REC.LOSS_FACTOR_ALIAS := TRIM(NVL(p_LOSS_FACTOR_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.LOSS_FACTOR_DESC := TRIM(NVL(p_LOSS_FACTOR_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EXTERNAL_IDENTIFIER := TRIM(NVL(p_EXTERNAL_IDENTIFIER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_LOSS_FACTOR_ID > 0 OR p_LOSS_FACTOR_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_LOSS_FACTOR_ID, EC.ED_LOSS_FACTOR) 
                 AND IO_UTIL.LOSS_FACTOR_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_LOSS_FACTOR, p_LOSS_FACTOR_ID);
		END IF;

		-- save it!
		UPDATE LOSS_FACTOR
		SET ROW = v_REC
		WHERE LOSS_FACTOR_ID = p_LOSS_FACTOR_ID;
		o_OID := p_LOSS_FACTOR_ID;
        
	ELSIF p_LOSS_FACTOR_ID IS NULL OR p_LOSS_FACTOR_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.LOSS_FACTOR_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_LOSS_FACTOR, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.LOSS_FACTOR_ID := o_OID;
		-- save it!
		INSERT INTO LOSS_FACTOR VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_LOSS_FACTOR_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_LOSS_FACTOR, EC.ED_ENTITY_DOMAIN)||': '||p_LOSS_FACTOR_NAME);
END PUT_LOSS_FACTOR;
---------------------------------------------------------------------
PROCEDURE GET_LOSS_FACTOR
	(
	p_LOSS_FACTOR_ID IN NUMBER,
	p_LOSS_FACTOR_NAME OUT VARCHAR2,
	p_LOSS_FACTOR_ALIAS OUT VARCHAR2,
	p_LOSS_FACTOR_DESC OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD LOSS_FACTOR%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_LOSS_FACTOR_ID, EC.ED_LOSS_FACTOR);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM LOSS_FACTOR
	WHERE LOSS_FACTOR_ID = p_LOSS_FACTOR_ID;
    
	-- Set the output parameters
	p_LOSS_FACTOR_NAME := v_RECORD.LOSS_FACTOR_NAME;
	p_LOSS_FACTOR_ALIAS := v_RECORD.LOSS_FACTOR_ALIAS;
	p_LOSS_FACTOR_DESC := v_RECORD.LOSS_FACTOR_DESC;
	p_EXTERNAL_IDENTIFIER := v_RECORD.EXTERNAL_IDENTIFIER;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_LOSS_FACTOR_NAME := g_EMPTY_VARCHAR2;
		p_LOSS_FACTOR_ALIAS := g_EMPTY_VARCHAR2;
		p_LOSS_FACTOR_DESC := g_EMPTY_VARCHAR2;
		p_EXTERNAL_IDENTIFIER := g_EMPTY_VARCHAR2;

END GET_LOSS_FACTOR;
---------------------------------------------------------------------
PROCEDURE PUT_MARKET_PRICE
	(
	o_OID OUT NUMBER,
	p_MARKET_PRICE_NAME IN VARCHAR2,
	p_MARKET_PRICE_ALIAS IN VARCHAR2,
	p_MARKET_PRICE_DESC IN VARCHAR2,
	p_MARKET_PRICE_ID IN NUMBER,
	p_MARKET_PRICE_TYPE IN VARCHAR2,
	p_MARKET_PRICE_INTERVAL IN VARCHAR2,
	p_MARKET_TYPE IN VARCHAR2,
	p_COMMODITY_ID IN NUMBER,
	p_SERVICE_POINT_TYPE IN VARCHAR2,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_EDC_ID IN NUMBER,
	p_SC_ID IN NUMBER,
	p_POD_ID IN NUMBER,
	p_ZOD_ID IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC MARKET_PRICE%ROWTYPE;
BEGIN


	v_REC.MARKET_PRICE_ID := p_MARKET_PRICE_ID;
	v_REC.MARKET_PRICE_NAME := TRIM(p_MARKET_PRICE_NAME);
	v_REC.MARKET_PRICE_ALIAS := TRIM(NVL(p_MARKET_PRICE_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.MARKET_PRICE_DESC := TRIM(NVL(p_MARKET_PRICE_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.MARKET_PRICE_TYPE := TRIM(NVL(p_MARKET_PRICE_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.MARKET_PRICE_INTERVAL := TRIM(NVL(p_MARKET_PRICE_INTERVAL,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.MARKET_TYPE := TRIM(NVL(p_MARKET_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.COMMODITY_ID := NVL(p_COMMODITY_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.SERVICE_POINT_TYPE := TRIM(NVL(p_SERVICE_POINT_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EXTERNAL_IDENTIFIER := TRIM(NVL(p_EXTERNAL_IDENTIFIER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EDC_ID := NVL(p_EDC_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.SC_ID := NVL(p_SC_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.POD_ID := NVL(p_POD_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.ZOD_ID := NVL(p_ZOD_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_MARKET_PRICE_ID > 0 OR p_MARKET_PRICE_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_MARKET_PRICE_ID, EC.ED_MARKET_PRICE) 
                 AND IO_UTIL.MARKET_PRICE_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_MARKET_PRICE, p_MARKET_PRICE_ID);
		END IF;

		-- save it!
		UPDATE MARKET_PRICE
		SET ROW = v_REC
		WHERE MARKET_PRICE_ID = p_MARKET_PRICE_ID;
		o_OID := p_MARKET_PRICE_ID;
        
	ELSIF p_MARKET_PRICE_ID IS NULL OR p_MARKET_PRICE_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.MARKET_PRICE_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_MARKET_PRICE, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.MARKET_PRICE_ID := o_OID;
		-- save it!
		INSERT INTO MARKET_PRICE VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_MARKET_PRICE_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_MARKET_PRICE, EC.ED_ENTITY_DOMAIN)||': '||p_MARKET_PRICE_NAME);
END PUT_MARKET_PRICE;
---------------------------------------------------------------------
PROCEDURE GET_MARKET_PRICE
	(
	p_MARKET_PRICE_ID IN NUMBER,
	p_MARKET_PRICE_NAME OUT VARCHAR2,
	p_MARKET_PRICE_ALIAS OUT VARCHAR2,
	p_MARKET_PRICE_DESC OUT VARCHAR2,
	p_MARKET_PRICE_TYPE OUT VARCHAR2,
	p_MARKET_PRICE_INTERVAL OUT VARCHAR2,
	p_MARKET_TYPE OUT VARCHAR2,
	p_COMMODITY_ID OUT NUMBER,
	p_SERVICE_POINT_TYPE OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_EDC_ID OUT NUMBER,
	p_SC_ID OUT NUMBER,
	p_POD_ID OUT NUMBER,
	p_ZOD_ID OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD MARKET_PRICE%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_MARKET_PRICE_ID, EC.ED_MARKET_PRICE);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM MARKET_PRICE
	WHERE MARKET_PRICE_ID = p_MARKET_PRICE_ID;
    
	-- Set the output parameters
	p_MARKET_PRICE_NAME := v_RECORD.MARKET_PRICE_NAME;
	p_MARKET_PRICE_ALIAS := v_RECORD.MARKET_PRICE_ALIAS;
	p_MARKET_PRICE_DESC := v_RECORD.MARKET_PRICE_DESC;
	p_MARKET_PRICE_TYPE := v_RECORD.MARKET_PRICE_TYPE;
	p_MARKET_PRICE_INTERVAL := v_RECORD.MARKET_PRICE_INTERVAL;
	p_MARKET_TYPE := v_RECORD.MARKET_TYPE;
	p_COMMODITY_ID := v_RECORD.COMMODITY_ID;
	p_SERVICE_POINT_TYPE := v_RECORD.SERVICE_POINT_TYPE;
	p_EXTERNAL_IDENTIFIER := v_RECORD.EXTERNAL_IDENTIFIER;
	p_EDC_ID := v_RECORD.EDC_ID;
	p_SC_ID := v_RECORD.SC_ID;
	p_POD_ID := v_RECORD.POD_ID;
	p_ZOD_ID := v_RECORD.ZOD_ID;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_MARKET_PRICE_NAME := g_EMPTY_VARCHAR2;
		p_MARKET_PRICE_ALIAS := g_EMPTY_VARCHAR2;
		p_MARKET_PRICE_DESC := g_EMPTY_VARCHAR2;
		p_MARKET_PRICE_TYPE := g_EMPTY_VARCHAR2;
		p_MARKET_PRICE_INTERVAL := g_EMPTY_VARCHAR2;
		p_MARKET_TYPE := g_EMPTY_VARCHAR2;
		p_COMMODITY_ID := g_EMPTY_NUMBER;
		p_SERVICE_POINT_TYPE := g_EMPTY_VARCHAR2;
		p_EXTERNAL_IDENTIFIER := g_EMPTY_VARCHAR2;
		p_EDC_ID := g_EMPTY_NUMBER;
		p_SC_ID := g_EMPTY_NUMBER;
		p_POD_ID := g_EMPTY_NUMBER;
		p_ZOD_ID := g_EMPTY_NUMBER;

END GET_MARKET_PRICE;
---------------------------------------------------------------------
PROCEDURE PUT_MEASUREMENT_SOURCE
	(
	o_OID OUT NUMBER,
	p_MEASUREMENT_SOURCE_NAME IN VARCHAR2,
	p_MEASUREMENT_SOURCE_ALIAS IN VARCHAR2,
	p_MEASUREMENT_SOURCE_DESC IN VARCHAR2,
	p_MEASUREMENT_SOURCE_ID IN NUMBER,
	p_MEASUREMENT_SOURCE_TYPE IN VARCHAR2,
	p_MEASUREMENT_SOURCE_INTERVAL IN VARCHAR2,
	p_METER_TYPE IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_PRECISION IN NUMBER,
	p_UOM IN VARCHAR2,
	p_POLLING_TIME IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC MEASUREMENT_SOURCE%ROWTYPE;
BEGIN


	v_REC.MEASUREMENT_SOURCE_ID := p_MEASUREMENT_SOURCE_ID;
	v_REC.MEASUREMENT_SOURCE_NAME := TRIM(p_MEASUREMENT_SOURCE_NAME);
	v_REC.MEASUREMENT_SOURCE_ALIAS := TRIM(NVL(p_MEASUREMENT_SOURCE_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.MEASUREMENT_SOURCE_DESC := TRIM(NVL(p_MEASUREMENT_SOURCE_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.MEASUREMENT_SOURCE_TYPE := TRIM(NVL(p_MEASUREMENT_SOURCE_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.MEASUREMENT_SOURCE_INTERVAL := TRIM(NVL(p_MEASUREMENT_SOURCE_INTERVAL,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.METER_TYPE := TRIM(NVL(p_METER_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.BEGIN_DATE := p_BEGIN_DATE;
	v_REC.END_DATE := p_END_DATE;
	v_REC.EXTERNAL_SYSTEM_ID := NVL(p_EXTERNAL_SYSTEM_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.EXTERNAL_IDENTIFIER := TRIM(NVL(p_EXTERNAL_IDENTIFIER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PRECISION := p_PRECISION;
	v_REC.UOM := TRIM(NVL(p_UOM,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.POLLING_TIME := p_POLLING_TIME;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_MEASUREMENT_SOURCE_ID > 0 OR p_MEASUREMENT_SOURCE_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_MEASUREMENT_SOURCE_ID, EC.ED_MEASUREMENT_SOURCE) 
                 AND IO_UTIL.MEASUREMENT_SOURCE_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_MEASUREMENT_SOURCE, p_MEASUREMENT_SOURCE_ID);
		END IF;

		-- save it!
		UPDATE MEASUREMENT_SOURCE
		SET ROW = v_REC
		WHERE MEASUREMENT_SOURCE_ID = p_MEASUREMENT_SOURCE_ID;
		o_OID := p_MEASUREMENT_SOURCE_ID;
        
	ELSIF p_MEASUREMENT_SOURCE_ID IS NULL OR p_MEASUREMENT_SOURCE_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.MEASUREMENT_SOURCE_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_MEASUREMENT_SOURCE, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.MEASUREMENT_SOURCE_ID := o_OID;
		-- save it!
		INSERT INTO MEASUREMENT_SOURCE VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_MEASUREMENT_SOURCE_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_MEASUREMENT_SOURCE, EC.ED_ENTITY_DOMAIN)||': '||p_MEASUREMENT_SOURCE_NAME);
END PUT_MEASUREMENT_SOURCE;
---------------------------------------------------------------------
PROCEDURE GET_MEASUREMENT_SOURCE
	(
	p_MEASUREMENT_SOURCE_ID IN NUMBER,
	p_MEASUREMENT_SOURCE_NAME OUT VARCHAR2,
	p_MEASUREMENT_SOURCE_ALIAS OUT VARCHAR2,
	p_MEASUREMENT_SOURCE_DESC OUT VARCHAR2,
	p_MEASUREMENT_SOURCE_TYPE OUT VARCHAR2,
	p_MEASUREMENT_SOURCE_INTERVAL OUT VARCHAR2,
	p_METER_TYPE OUT VARCHAR2,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE,
	p_EXTERNAL_SYSTEM_ID OUT NUMBER,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_PRECISION OUT NUMBER,
	p_UOM OUT VARCHAR2,
	p_POLLING_TIME OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD MEASUREMENT_SOURCE%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_MEASUREMENT_SOURCE_ID, EC.ED_MEASUREMENT_SOURCE);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM MEASUREMENT_SOURCE
	WHERE MEASUREMENT_SOURCE_ID = p_MEASUREMENT_SOURCE_ID;
    
	-- Set the output parameters
	p_MEASUREMENT_SOURCE_NAME := v_RECORD.MEASUREMENT_SOURCE_NAME;
	p_MEASUREMENT_SOURCE_ALIAS := v_RECORD.MEASUREMENT_SOURCE_ALIAS;
	p_MEASUREMENT_SOURCE_DESC := v_RECORD.MEASUREMENT_SOURCE_DESC;
	p_MEASUREMENT_SOURCE_TYPE := v_RECORD.MEASUREMENT_SOURCE_TYPE;
	p_MEASUREMENT_SOURCE_INTERVAL := v_RECORD.MEASUREMENT_SOURCE_INTERVAL;
	p_METER_TYPE := v_RECORD.METER_TYPE;
	p_BEGIN_DATE := v_RECORD.BEGIN_DATE;
	p_END_DATE := v_RECORD.END_DATE;
	p_EXTERNAL_SYSTEM_ID := v_RECORD.EXTERNAL_SYSTEM_ID;
	p_EXTERNAL_IDENTIFIER := v_RECORD.EXTERNAL_IDENTIFIER;
	p_PRECISION := v_RECORD.PRECISION;
	p_UOM := v_RECORD.UOM;
	p_POLLING_TIME := v_RECORD.POLLING_TIME;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_MEASUREMENT_SOURCE_NAME := g_EMPTY_VARCHAR2;
		p_MEASUREMENT_SOURCE_ALIAS := g_EMPTY_VARCHAR2;
		p_MEASUREMENT_SOURCE_DESC := g_EMPTY_VARCHAR2;
		p_MEASUREMENT_SOURCE_TYPE := g_EMPTY_VARCHAR2;
		p_MEASUREMENT_SOURCE_INTERVAL := g_EMPTY_VARCHAR2;
		p_METER_TYPE := g_EMPTY_VARCHAR2;
		p_BEGIN_DATE := g_EMPTY_DATE;
		p_END_DATE := g_EMPTY_DATE;
		p_EXTERNAL_SYSTEM_ID := g_EMPTY_NUMBER;
		p_EXTERNAL_IDENTIFIER := g_EMPTY_VARCHAR2;
		p_PRECISION := g_EMPTY_NUMBER;
		p_UOM := g_EMPTY_VARCHAR2;
		p_POLLING_TIME := g_EMPTY_NUMBER;

END GET_MEASUREMENT_SOURCE;
---------------------------------------------------------------------
PROCEDURE PUT_METER
	(
	o_OID OUT NUMBER,
	p_MRSP_ID IN NUMBER,
	p_METER_NAME IN VARCHAR2,
	p_METER_ALIAS IN VARCHAR2,
	p_METER_DESC IN VARCHAR2,
	p_METER_ID IN NUMBER,
	p_METER_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_METER_STATUS IN VARCHAR2,
	p_METER_INTERVAL IN VARCHAR2,
	p_METER_TYPE IN VARCHAR2,
	p_METER_UNIT IN VARCHAR2,
	p_IS_EXTERNAL_INTERVAL_USAGE IN NUMBER,
	p_IS_EXTERNAL_BILLED_USAGE IN NUMBER,
	p_IS_EXTERNAL_FORECAST IN NUMBER,
	p_USE_TOU_USAGE_FACTOR IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC METER%ROWTYPE;
BEGIN

	IF GA.ENFORCE_UNIQUE_NAMES THEN

		SELECT COUNT(*)
		INTO v_COUNT
		FROM METER
		WHERE METER_NAME = TRIM(p_METER_NAME)
			AND (p_METER_ID = 0 OR METER_ID <> p_METER_ID)
			AND MRSP_ID = p_MRSP_ID;

		IF v_COUNT > 0 THEN
            -- raise exception that indicates the duplicate entity name
            ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_METER, EC.ED_ENTITY_DOMAIN)||': '||p_METER_NAME);
		END IF;
	
	END IF;


	v_REC.MRSP_ID := NVL(p_MRSP_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.METER_ID := p_METER_ID;
	v_REC.METER_NAME := TRIM(p_METER_NAME);
	v_REC.METER_ALIAS := TRIM(NVL(p_METER_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.METER_DESC := TRIM(NVL(p_METER_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.METER_EXTERNAL_IDENTIFIER := TRIM(NVL(p_METER_EXTERNAL_IDENTIFIER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.METER_STATUS := TRIM(NVL(p_METER_STATUS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.METER_INTERVAL := TRIM(NVL(p_METER_INTERVAL,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.METER_TYPE := TRIM(NVL(p_METER_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.METER_UNIT := TRIM(NVL(p_METER_UNIT,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.IS_EXTERNAL_INTERVAL_USAGE := p_IS_EXTERNAL_INTERVAL_USAGE;
	v_REC.IS_EXTERNAL_BILLED_USAGE := p_IS_EXTERNAL_BILLED_USAGE;
	v_REC.IS_EXTERNAL_FORECAST := p_IS_EXTERNAL_FORECAST;
	v_REC.USE_TOU_USAGE_FACTOR := p_USE_TOU_USAGE_FACTOR;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_METER_ID > 0 OR p_METER_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_METER_ID, EC.ED_METER) 
                 AND IO_UTIL.METER_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_METER, p_METER_ID);
		END IF;

		-- save it!
		UPDATE METER
		SET ROW = v_REC
		WHERE METER_ID = p_METER_ID;
		o_OID := p_METER_ID;
        
	ELSIF p_METER_ID IS NULL OR p_METER_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.METER_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_METER, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.METER_ID := o_OID;
		-- save it!
		INSERT INTO METER VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_METER_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_METER, EC.ED_ENTITY_DOMAIN)||': '||p_METER_NAME);
END PUT_METER;
---------------------------------------------------------------------
PROCEDURE GET_METER
	(
	p_MRSP_ID OUT NUMBER,
	p_METER_ID IN NUMBER,
	p_METER_NAME OUT VARCHAR2,
	p_METER_ALIAS OUT VARCHAR2,
	p_METER_DESC OUT VARCHAR2,
	p_METER_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_METER_STATUS OUT VARCHAR2,
	p_METER_INTERVAL OUT VARCHAR2,
	p_METER_TYPE OUT VARCHAR2,
	p_METER_UNIT OUT VARCHAR2,
	p_IS_EXTERNAL_INTERVAL_USAGE OUT NUMBER,
	p_IS_EXTERNAL_BILLED_USAGE OUT NUMBER,
	p_IS_EXTERNAL_FORECAST OUT NUMBER,
	p_USE_TOU_USAGE_FACTOR OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD METER%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_METER_ID, EC.ED_METER);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM METER
	WHERE METER_ID = p_METER_ID;
    
	-- Set the output parameters
	p_MRSP_ID := v_RECORD.MRSP_ID;
	p_METER_NAME := v_RECORD.METER_NAME;
	p_METER_ALIAS := v_RECORD.METER_ALIAS;
	p_METER_DESC := v_RECORD.METER_DESC;
	p_METER_EXTERNAL_IDENTIFIER := v_RECORD.METER_EXTERNAL_IDENTIFIER;
	p_METER_STATUS := v_RECORD.METER_STATUS;
	p_METER_INTERVAL := v_RECORD.METER_INTERVAL;
	p_METER_TYPE := v_RECORD.METER_TYPE;
	p_METER_UNIT := v_RECORD.METER_UNIT;
	p_IS_EXTERNAL_INTERVAL_USAGE := v_RECORD.IS_EXTERNAL_INTERVAL_USAGE;
	p_IS_EXTERNAL_BILLED_USAGE := v_RECORD.IS_EXTERNAL_BILLED_USAGE;
	p_IS_EXTERNAL_FORECAST := v_RECORD.IS_EXTERNAL_FORECAST;
	p_USE_TOU_USAGE_FACTOR := v_RECORD.USE_TOU_USAGE_FACTOR;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_MRSP_ID := g_EMPTY_NUMBER;
		p_METER_NAME := g_EMPTY_VARCHAR2;
		p_METER_ALIAS := g_EMPTY_VARCHAR2;
		p_METER_DESC := g_EMPTY_VARCHAR2;
		p_METER_EXTERNAL_IDENTIFIER := g_EMPTY_VARCHAR2;
		p_METER_STATUS := g_EMPTY_VARCHAR2;
		p_METER_INTERVAL := g_EMPTY_VARCHAR2;
		p_METER_TYPE := g_EMPTY_VARCHAR2;
		p_METER_UNIT := g_EMPTY_VARCHAR2;
		p_IS_EXTERNAL_INTERVAL_USAGE := g_EMPTY_NUMBER;
		p_IS_EXTERNAL_BILLED_USAGE := g_EMPTY_NUMBER;
		p_IS_EXTERNAL_FORECAST := g_EMPTY_NUMBER;
		p_USE_TOU_USAGE_FACTOR := g_EMPTY_NUMBER;

END GET_METER;
---------------------------------------------------------------------
PROCEDURE PUT_MRSP
	(
	o_OID OUT NUMBER,
	p_MRSP_NAME IN VARCHAR2,
	p_MRSP_ALIAS IN VARCHAR2,
	p_MRSP_DESC IN VARCHAR2,
	p_MRSP_ID IN NUMBER,
	p_MRSP_DUNS_NUMBER IN VARCHAR2,
	p_MRSP_STATUS IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC METER_READING_SERVICE_PROVIDER%ROWTYPE;
BEGIN


	v_REC.MRSP_ID := p_MRSP_ID;
	v_REC.MRSP_NAME := TRIM(p_MRSP_NAME);
	v_REC.MRSP_ALIAS := TRIM(NVL(p_MRSP_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.MRSP_DESC := TRIM(NVL(p_MRSP_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.MRSP_DUNS_NUMBER := TRIM(NVL(p_MRSP_DUNS_NUMBER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.MRSP_STATUS := TRIM(NVL(p_MRSP_STATUS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_MRSP_ID > 0 OR p_MRSP_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_MRSP_ID, EC.ED_MRSP) 
                 AND IO_UTIL.MRSP_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_MRSP, p_MRSP_ID);
		END IF;

		-- save it!
		UPDATE METER_READING_SERVICE_PROVIDER
		SET ROW = v_REC
		WHERE MRSP_ID = p_MRSP_ID;
		o_OID := p_MRSP_ID;
        
	ELSIF p_MRSP_ID IS NULL OR p_MRSP_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.MRSP_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_MRSP, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.MRSP_ID := o_OID;
		-- save it!
		INSERT INTO METER_READING_SERVICE_PROVIDER VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_MRSP_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_MRSP, EC.ED_ENTITY_DOMAIN)||': '||p_MRSP_NAME);
END PUT_MRSP;
---------------------------------------------------------------------
PROCEDURE GET_MRSP
	(
	p_MRSP_ID IN NUMBER,
	p_MRSP_NAME OUT VARCHAR2,
	p_MRSP_ALIAS OUT VARCHAR2,
	p_MRSP_DESC OUT VARCHAR2,
	p_MRSP_DUNS_NUMBER OUT VARCHAR2,
	p_MRSP_STATUS OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD METER_READING_SERVICE_PROVIDER%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_MRSP_ID, EC.ED_MRSP);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM METER_READING_SERVICE_PROVIDER
	WHERE MRSP_ID = p_MRSP_ID;
    
	-- Set the output parameters
	p_MRSP_NAME := v_RECORD.MRSP_NAME;
	p_MRSP_ALIAS := v_RECORD.MRSP_ALIAS;
	p_MRSP_DESC := v_RECORD.MRSP_DESC;
	p_MRSP_DUNS_NUMBER := v_RECORD.MRSP_DUNS_NUMBER;
	p_MRSP_STATUS := v_RECORD.MRSP_STATUS;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_MRSP_NAME := g_EMPTY_VARCHAR2;
		p_MRSP_ALIAS := g_EMPTY_VARCHAR2;
		p_MRSP_DESC := g_EMPTY_VARCHAR2;
		p_MRSP_DUNS_NUMBER := g_EMPTY_VARCHAR2;
		p_MRSP_STATUS := g_EMPTY_VARCHAR2;

END GET_MRSP;
---------------------------------------------------------------------
PROCEDURE PUT_OASIS_NODE
	(
	o_OID OUT NUMBER,
	p_OASIS_NODE_NAME IN VARCHAR2,
	p_OASIS_NODE_ALIAS IN VARCHAR2,
	p_OASIS_NODE_DESC IN VARCHAR2,
	p_OASIS_NODE_ID IN NUMBER,
	p_URL IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC OASIS_NODE%ROWTYPE;
BEGIN


	v_REC.OASIS_NODE_ID := p_OASIS_NODE_ID;
	v_REC.OASIS_NODE_NAME := TRIM(p_OASIS_NODE_NAME);
	v_REC.OASIS_NODE_ALIAS := TRIM(NVL(p_OASIS_NODE_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.OASIS_NODE_DESC := TRIM(NVL(p_OASIS_NODE_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.URL := TRIM(NVL(p_URL,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_OASIS_NODE_ID > 0 OR p_OASIS_NODE_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_OASIS_NODE_ID, EC.ED_OASIS_NODE) 
                 AND IO_UTIL.OASIS_NODE_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_OASIS_NODE, p_OASIS_NODE_ID);
		END IF;

		-- save it!
		UPDATE OASIS_NODE
		SET ROW = v_REC
		WHERE OASIS_NODE_ID = p_OASIS_NODE_ID;
		o_OID := p_OASIS_NODE_ID;
        
	ELSIF p_OASIS_NODE_ID IS NULL OR p_OASIS_NODE_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.OASIS_NODE_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_OASIS_NODE, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.OASIS_NODE_ID := o_OID;
		-- save it!
		INSERT INTO OASIS_NODE VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_OASIS_NODE_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_OASIS_NODE, EC.ED_ENTITY_DOMAIN)||': '||p_OASIS_NODE_NAME);
END PUT_OASIS_NODE;
---------------------------------------------------------------------
PROCEDURE GET_OASIS_NODE
	(
	p_OASIS_NODE_ID IN NUMBER,
	p_OASIS_NODE_NAME OUT VARCHAR2,
	p_OASIS_NODE_ALIAS OUT VARCHAR2,
	p_OASIS_NODE_DESC OUT VARCHAR2,
	p_URL OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD OASIS_NODE%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_OASIS_NODE_ID, EC.ED_OASIS_NODE);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM OASIS_NODE
	WHERE OASIS_NODE_ID = p_OASIS_NODE_ID;
    
	-- Set the output parameters
	p_OASIS_NODE_NAME := v_RECORD.OASIS_NODE_NAME;
	p_OASIS_NODE_ALIAS := v_RECORD.OASIS_NODE_ALIAS;
	p_OASIS_NODE_DESC := v_RECORD.OASIS_NODE_DESC;
	p_URL := v_RECORD.URL;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_OASIS_NODE_NAME := g_EMPTY_VARCHAR2;
		p_OASIS_NODE_ALIAS := g_EMPTY_VARCHAR2;
		p_OASIS_NODE_DESC := g_EMPTY_VARCHAR2;
		p_URL := g_EMPTY_VARCHAR2;

END GET_OASIS_NODE;
---------------------------------------------------------------------
PROCEDURE PUT_PATH
	(
	o_OID OUT NUMBER,
	p_PATH_NAME IN VARCHAR2,
	p_PATH_ALIAS IN VARCHAR2,
	p_PATH_DESC IN VARCHAR2,
	p_PATH_ID IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC TX_PATH%ROWTYPE;
BEGIN


	v_REC.PATH_ID := p_PATH_ID;
	v_REC.PATH_NAME := TRIM(p_PATH_NAME);
	v_REC.PATH_ALIAS := TRIM(NVL(p_PATH_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PATH_DESC := TRIM(NVL(p_PATH_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_PATH_ID > 0 OR p_PATH_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_PATH_ID, EC.ED_PATH) 
                 AND IO_UTIL.PATH_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_PATH, p_PATH_ID);
		END IF;

		-- save it!
		UPDATE TX_PATH
		SET ROW = v_REC
		WHERE PATH_ID = p_PATH_ID;
		o_OID := p_PATH_ID;
        
	ELSIF p_PATH_ID IS NULL OR p_PATH_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.PATH_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_PATH, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.PATH_ID := o_OID;
		-- save it!
		INSERT INTO TX_PATH VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_PATH_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_PATH, EC.ED_ENTITY_DOMAIN)||': '||p_PATH_NAME);
END PUT_PATH;
---------------------------------------------------------------------
PROCEDURE GET_PATH
	(
	p_PATH_ID IN NUMBER,
	p_PATH_NAME OUT VARCHAR2,
	p_PATH_ALIAS OUT VARCHAR2,
	p_PATH_DESC OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD TX_PATH%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_PATH_ID, EC.ED_PATH);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM TX_PATH
	WHERE PATH_ID = p_PATH_ID;
    
	-- Set the output parameters
	p_PATH_NAME := v_RECORD.PATH_NAME;
	p_PATH_ALIAS := v_RECORD.PATH_ALIAS;
	p_PATH_DESC := v_RECORD.PATH_DESC;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_PATH_NAME := g_EMPTY_VARCHAR2;
		p_PATH_ALIAS := g_EMPTY_VARCHAR2;
		p_PATH_DESC := g_EMPTY_VARCHAR2;

END GET_PATH;
---------------------------------------------------------------------
PROCEDURE PUT_PERIOD
	(
	o_OID OUT NUMBER,
	p_PERIOD_NAME IN VARCHAR2,
	p_PERIOD_ALIAS IN VARCHAR2,
	p_PERIOD_DESC IN VARCHAR2,
	p_PERIOD_ID IN NUMBER,
	p_PERIOD_COLOR IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC PERIOD%ROWTYPE;
BEGIN


	v_REC.PERIOD_ID := p_PERIOD_ID;
	v_REC.PERIOD_NAME := TRIM(p_PERIOD_NAME);
	v_REC.PERIOD_ALIAS := TRIM(NVL(p_PERIOD_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PERIOD_DESC := TRIM(NVL(p_PERIOD_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PERIOD_COLOR := p_PERIOD_COLOR;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_PERIOD_ID > 0 OR p_PERIOD_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_PERIOD_ID, EC.ED_PERIOD) 
                 AND IO_UTIL.PERIOD_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_PERIOD, p_PERIOD_ID);
		END IF;

		-- save it!
		UPDATE PERIOD
		SET ROW = v_REC
		WHERE PERIOD_ID = p_PERIOD_ID;
		o_OID := p_PERIOD_ID;
        
	ELSIF p_PERIOD_ID IS NULL OR p_PERIOD_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.PERIOD_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_PERIOD, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.PERIOD_ID := o_OID;
		-- save it!
		INSERT INTO PERIOD VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_PERIOD_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_PERIOD, EC.ED_ENTITY_DOMAIN)||': '||p_PERIOD_NAME);
END PUT_PERIOD;
---------------------------------------------------------------------
PROCEDURE GET_PERIOD
	(
	p_PERIOD_ID IN NUMBER,
	p_PERIOD_NAME OUT VARCHAR2,
	p_PERIOD_ALIAS OUT VARCHAR2,
	p_PERIOD_DESC OUT VARCHAR2,
	p_PERIOD_COLOR OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD PERIOD%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_PERIOD_ID, EC.ED_PERIOD);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM PERIOD
	WHERE PERIOD_ID = p_PERIOD_ID;
    
	-- Set the output parameters
	p_PERIOD_NAME := v_RECORD.PERIOD_NAME;
	p_PERIOD_ALIAS := v_RECORD.PERIOD_ALIAS;
	p_PERIOD_DESC := v_RECORD.PERIOD_DESC;
	p_PERIOD_COLOR := v_RECORD.PERIOD_COLOR;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_PERIOD_NAME := g_EMPTY_VARCHAR2;
		p_PERIOD_ALIAS := g_EMPTY_VARCHAR2;
		p_PERIOD_DESC := g_EMPTY_VARCHAR2;
		p_PERIOD_COLOR := g_EMPTY_NUMBER;

END GET_PERIOD;
---------------------------------------------------------------------
PROCEDURE PUT_PIPELINE
	(
	o_OID OUT NUMBER,
	p_PIPELINE_NAME IN VARCHAR2,
	p_PIPELINE_ALIAS IN VARCHAR2,
	p_PIPELINE_DESC IN VARCHAR2,
	p_PIPELINE_ID IN NUMBER,
	p_PIPELINE_STATUS IN VARCHAR2,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC PIPELINE%ROWTYPE;
BEGIN


	v_REC.PIPELINE_ID := p_PIPELINE_ID;
	v_REC.PIPELINE_NAME := TRIM(p_PIPELINE_NAME);
	v_REC.PIPELINE_ALIAS := TRIM(NVL(p_PIPELINE_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PIPELINE_DESC := TRIM(NVL(p_PIPELINE_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PIPELINE_STATUS := TRIM(NVL(p_PIPELINE_STATUS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EXTERNAL_IDENTIFIER := TRIM(NVL(p_EXTERNAL_IDENTIFIER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_PIPELINE_ID > 0 OR p_PIPELINE_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_PIPELINE_ID, EC.ED_PIPELINE) 
                 AND IO_UTIL.PIPELINE_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_PIPELINE, p_PIPELINE_ID);
		END IF;

		-- save it!
		UPDATE PIPELINE
		SET ROW = v_REC
		WHERE PIPELINE_ID = p_PIPELINE_ID;
		o_OID := p_PIPELINE_ID;
        
	ELSIF p_PIPELINE_ID IS NULL OR p_PIPELINE_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.PIPELINE_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_PIPELINE, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.PIPELINE_ID := o_OID;
		-- save it!
		INSERT INTO PIPELINE VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_PIPELINE_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_PIPELINE, EC.ED_ENTITY_DOMAIN)||': '||p_PIPELINE_NAME);
END PUT_PIPELINE;
---------------------------------------------------------------------
PROCEDURE GET_PIPELINE
	(
	p_PIPELINE_ID IN NUMBER,
	p_PIPELINE_NAME OUT VARCHAR2,
	p_PIPELINE_ALIAS OUT VARCHAR2,
	p_PIPELINE_DESC OUT VARCHAR2,
	p_PIPELINE_STATUS OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD PIPELINE%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_PIPELINE_ID, EC.ED_PIPELINE);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM PIPELINE
	WHERE PIPELINE_ID = p_PIPELINE_ID;
    
	-- Set the output parameters
	p_PIPELINE_NAME := v_RECORD.PIPELINE_NAME;
	p_PIPELINE_ALIAS := v_RECORD.PIPELINE_ALIAS;
	p_PIPELINE_DESC := v_RECORD.PIPELINE_DESC;
	p_PIPELINE_STATUS := v_RECORD.PIPELINE_STATUS;
	p_EXTERNAL_IDENTIFIER := v_RECORD.EXTERNAL_IDENTIFIER;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_PIPELINE_NAME := g_EMPTY_VARCHAR2;
		p_PIPELINE_ALIAS := g_EMPTY_VARCHAR2;
		p_PIPELINE_DESC := g_EMPTY_VARCHAR2;
		p_PIPELINE_STATUS := g_EMPTY_VARCHAR2;
		p_EXTERNAL_IDENTIFIER := g_EMPTY_VARCHAR2;

END GET_PIPELINE;
---------------------------------------------------------------------
PROCEDURE PUT_POOL
	(
	o_OID OUT NUMBER,
	p_POOL_NAME IN VARCHAR2,
	p_POOL_ALIAS IN VARCHAR2,
	p_POOL_DESC IN VARCHAR2,
	p_POOL_ID IN NUMBER,
	p_POOL_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_POOL_STATUS IN VARCHAR2,
	p_POOL_CATEGORY IN VARCHAR2,
	p_POOL_EXCLUDE_LOAD_SCHEDULE IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC POOL%ROWTYPE;
BEGIN


	v_REC.POOL_ID := p_POOL_ID;
	v_REC.POOL_NAME := TRIM(p_POOL_NAME);
	v_REC.POOL_ALIAS := TRIM(NVL(p_POOL_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.POOL_DESC := TRIM(NVL(p_POOL_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.POOL_EXTERNAL_IDENTIFIER := TRIM(NVL(p_POOL_EXTERNAL_IDENTIFIER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.POOL_STATUS := TRIM(NVL(p_POOL_STATUS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.POOL_CATEGORY := TRIM(NVL(p_POOL_CATEGORY,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.POOL_EXCLUDE_LOAD_SCHEDULE := p_POOL_EXCLUDE_LOAD_SCHEDULE;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_POOL_ID > 0 OR p_POOL_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_POOL_ID, EC.ED_POOL) 
                 AND IO_UTIL.POOL_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_POOL, p_POOL_ID);
		END IF;

		-- save it!
		UPDATE POOL
		SET ROW = v_REC
		WHERE POOL_ID = p_POOL_ID;
		o_OID := p_POOL_ID;
        
	ELSIF p_POOL_ID IS NULL OR p_POOL_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.POOL_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_POOL, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.POOL_ID := o_OID;
		-- save it!
		INSERT INTO POOL VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_POOL_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_POOL, EC.ED_ENTITY_DOMAIN)||': '||p_POOL_NAME);
END PUT_POOL;
---------------------------------------------------------------------
PROCEDURE GET_POOL
	(
	p_POOL_ID IN NUMBER,
	p_POOL_NAME OUT VARCHAR2,
	p_POOL_ALIAS OUT VARCHAR2,
	p_POOL_DESC OUT VARCHAR2,
	p_POOL_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_POOL_STATUS OUT VARCHAR2,
	p_POOL_CATEGORY OUT VARCHAR2,
	p_POOL_EXCLUDE_LOAD_SCHEDULE OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD POOL%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_POOL_ID, EC.ED_POOL);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM POOL
	WHERE POOL_ID = p_POOL_ID;
    
	-- Set the output parameters
	p_POOL_NAME := v_RECORD.POOL_NAME;
	p_POOL_ALIAS := v_RECORD.POOL_ALIAS;
	p_POOL_DESC := v_RECORD.POOL_DESC;
	p_POOL_EXTERNAL_IDENTIFIER := v_RECORD.POOL_EXTERNAL_IDENTIFIER;
	p_POOL_STATUS := v_RECORD.POOL_STATUS;
	p_POOL_CATEGORY := v_RECORD.POOL_CATEGORY;
	p_POOL_EXCLUDE_LOAD_SCHEDULE := v_RECORD.POOL_EXCLUDE_LOAD_SCHEDULE;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_POOL_NAME := g_EMPTY_VARCHAR2;
		p_POOL_ALIAS := g_EMPTY_VARCHAR2;
		p_POOL_DESC := g_EMPTY_VARCHAR2;
		p_POOL_EXTERNAL_IDENTIFIER := g_EMPTY_VARCHAR2;
		p_POOL_STATUS := g_EMPTY_VARCHAR2;
		p_POOL_CATEGORY := g_EMPTY_VARCHAR2;
		p_POOL_EXCLUDE_LOAD_SCHEDULE := g_EMPTY_NUMBER;

END GET_POOL;
---------------------------------------------------------------------
PROCEDURE PUT_PORTFOLIO
	(
	o_OID OUT NUMBER,
	p_PORTFOLIO_NAME IN VARCHAR2,
	p_PORTFOLIO_ALIAS IN VARCHAR2,
	p_PORTFOLIO_DESC IN VARCHAR2,
	p_PORTFOLIO_ID IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC PORTFOLIO%ROWTYPE;
BEGIN


	v_REC.PORTFOLIO_ID := p_PORTFOLIO_ID;
	v_REC.PORTFOLIO_NAME := TRIM(p_PORTFOLIO_NAME);
	v_REC.PORTFOLIO_ALIAS := TRIM(NVL(p_PORTFOLIO_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PORTFOLIO_DESC := TRIM(NVL(p_PORTFOLIO_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_PORTFOLIO_ID > 0 OR p_PORTFOLIO_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_PORTFOLIO_ID, EC.ED_PORTFOLIO) 
                 AND IO_UTIL.PORTFOLIO_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_PORTFOLIO, p_PORTFOLIO_ID);
		END IF;

		-- save it!
		UPDATE PORTFOLIO
		SET ROW = v_REC
		WHERE PORTFOLIO_ID = p_PORTFOLIO_ID;
		o_OID := p_PORTFOLIO_ID;
        
	ELSIF p_PORTFOLIO_ID IS NULL OR p_PORTFOLIO_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.PORTFOLIO_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_PORTFOLIO, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.PORTFOLIO_ID := o_OID;
		-- save it!
		INSERT INTO PORTFOLIO VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_PORTFOLIO_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_PORTFOLIO, EC.ED_ENTITY_DOMAIN)||': '||p_PORTFOLIO_NAME);
END PUT_PORTFOLIO;
---------------------------------------------------------------------
PROCEDURE GET_PORTFOLIO
	(
	p_PORTFOLIO_ID IN NUMBER,
	p_PORTFOLIO_NAME OUT VARCHAR2,
	p_PORTFOLIO_ALIAS OUT VARCHAR2,
	p_PORTFOLIO_DESC OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD PORTFOLIO%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_PORTFOLIO_ID, EC.ED_PORTFOLIO);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM PORTFOLIO
	WHERE PORTFOLIO_ID = p_PORTFOLIO_ID;
    
	-- Set the output parameters
	p_PORTFOLIO_NAME := v_RECORD.PORTFOLIO_NAME;
	p_PORTFOLIO_ALIAS := v_RECORD.PORTFOLIO_ALIAS;
	p_PORTFOLIO_DESC := v_RECORD.PORTFOLIO_DESC;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_PORTFOLIO_NAME := g_EMPTY_VARCHAR2;
		p_PORTFOLIO_ALIAS := g_EMPTY_VARCHAR2;
		p_PORTFOLIO_DESC := g_EMPTY_VARCHAR2;

END GET_PORTFOLIO;
---------------------------------------------------------------------
PROCEDURE PUT_POSITION_EVALUATION
	(
	o_OID OUT NUMBER,
	p_EVALUATION_NAME IN VARCHAR2,
	p_EVALUATION_ALIAS IN VARCHAR2,
	p_EVALUATION_DESC IN VARCHAR2,
	p_EVALUATION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_MARKET_PRICE_ID IN NUMBER,
	p_LAST_RUN_DATE IN DATE
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC POSITION_ANALYSIS_EVALUATION%ROWTYPE;
BEGIN
	-- Make sure user has access
	IF NOT CAN_WRITE('Data Setup') THEN
        ERRS.RAISE_NO_WRITE_MODULE('Data Setup');
	END IF;



	v_REC.EVALUATION_ID := p_EVALUATION_ID;
	v_REC.EVALUATION_NAME := TRIM(p_EVALUATION_NAME);
	v_REC.EVALUATION_ALIAS := TRIM(NVL(p_EVALUATION_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EVALUATION_DESC := TRIM(NVL(p_EVALUATION_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.BEGIN_DATE := p_BEGIN_DATE;
	v_REC.END_DATE := p_END_DATE;
	v_REC.MARKET_PRICE_ID := NVL(p_MARKET_PRICE_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.LAST_RUN_DATE := p_LAST_RUN_DATE;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_EVALUATION_ID > 0 OR p_EVALUATION_ID < -10 THEN

		-- save it!
		UPDATE POSITION_ANALYSIS_EVALUATION
		SET ROW = v_REC
		WHERE EVALUATION_ID = p_EVALUATION_ID;
		o_OID := p_EVALUATION_ID;
        
	ELSIF p_EVALUATION_ID IS NULL OR p_EVALUATION_ID = 0 THEN

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.EVALUATION_ID := o_OID;
		-- save it!
		INSERT INTO POSITION_ANALYSIS_EVALUATION VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_EVALUATION_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, 'POSITION_EVALUATION: '||p_EVALUATION_NAME);
END PUT_POSITION_EVALUATION;
---------------------------------------------------------------------
PROCEDURE GET_POSITION_EVALUATION
	(
	p_EVALUATION_ID IN NUMBER,
	p_EVALUATION_NAME OUT VARCHAR2,
	p_EVALUATION_ALIAS OUT VARCHAR2,
	p_EVALUATION_DESC OUT VARCHAR2,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE,
	p_MARKET_PRICE_ID OUT NUMBER,
	p_LAST_RUN_DATE OUT DATE
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD POSITION_ANALYSIS_EVALUATION%ROWTYPE;
BEGIN
	-- Make sure user has access
	IF NOT CAN_READ('Data Setup') THEN
        ERRS.RAISE_NO_READ_MODULE('Data Setup');
	END IF;

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM POSITION_ANALYSIS_EVALUATION
	WHERE EVALUATION_ID = p_EVALUATION_ID;
    
	-- Set the output parameters
	p_EVALUATION_NAME := v_RECORD.EVALUATION_NAME;
	p_EVALUATION_ALIAS := v_RECORD.EVALUATION_ALIAS;
	p_EVALUATION_DESC := v_RECORD.EVALUATION_DESC;
	p_BEGIN_DATE := v_RECORD.BEGIN_DATE;
	p_END_DATE := v_RECORD.END_DATE;
	p_MARKET_PRICE_ID := v_RECORD.MARKET_PRICE_ID;
	p_LAST_RUN_DATE := v_RECORD.LAST_RUN_DATE;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_EVALUATION_NAME := g_EMPTY_VARCHAR2;
		p_EVALUATION_ALIAS := g_EMPTY_VARCHAR2;
		p_EVALUATION_DESC := g_EMPTY_VARCHAR2;
		p_BEGIN_DATE := g_EMPTY_DATE;
		p_END_DATE := g_EMPTY_DATE;
		p_MARKET_PRICE_ID := g_EMPTY_NUMBER;
		p_LAST_RUN_DATE := g_EMPTY_DATE;

END GET_POSITION_EVALUATION;
---------------------------------------------------------------------
PROCEDURE PUT_PRODUCT
	(
	o_OID OUT NUMBER,
	p_PRODUCT_NAME IN VARCHAR2,
	p_PRODUCT_ALIAS IN VARCHAR2,
	p_PRODUCT_DESC IN VARCHAR2,
	p_PRODUCT_ID IN NUMBER,
	p_PRODUCT_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_PRODUCT_CATEGORY IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC PRODUCT%ROWTYPE;
BEGIN


	v_REC.PRODUCT_ID := p_PRODUCT_ID;
	v_REC.PRODUCT_NAME := TRIM(p_PRODUCT_NAME);
	v_REC.PRODUCT_ALIAS := TRIM(NVL(p_PRODUCT_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PRODUCT_DESC := TRIM(NVL(p_PRODUCT_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PRODUCT_EXTERNAL_IDENTIFIER := TRIM(NVL(p_PRODUCT_EXTERNAL_IDENTIFIER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PRODUCT_CATEGORY := TRIM(NVL(p_PRODUCT_CATEGORY,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.BEGIN_DATE := p_BEGIN_DATE;
	v_REC.END_DATE := p_END_DATE;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_PRODUCT_ID > 0 OR p_PRODUCT_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_PRODUCT_ID, EC.ED_PRODUCT) 
                 AND IO_UTIL.PRODUCT_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_PRODUCT, p_PRODUCT_ID);
		END IF;

		-- save it!
		UPDATE PRODUCT
		SET ROW = v_REC
		WHERE PRODUCT_ID = p_PRODUCT_ID;
		o_OID := p_PRODUCT_ID;
        
	ELSIF p_PRODUCT_ID IS NULL OR p_PRODUCT_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.PRODUCT_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_PRODUCT, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.PRODUCT_ID := o_OID;
		-- save it!
		INSERT INTO PRODUCT VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_PRODUCT_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_PRODUCT, EC.ED_ENTITY_DOMAIN)||': '||p_PRODUCT_NAME);
END PUT_PRODUCT;
---------------------------------------------------------------------
PROCEDURE GET_PRODUCT
	(
	p_PRODUCT_ID IN NUMBER,
	p_PRODUCT_NAME OUT VARCHAR2,
	p_PRODUCT_ALIAS OUT VARCHAR2,
	p_PRODUCT_DESC OUT VARCHAR2,
	p_PRODUCT_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_PRODUCT_CATEGORY OUT VARCHAR2,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD PRODUCT%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_PRODUCT_ID, EC.ED_PRODUCT);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM PRODUCT
	WHERE PRODUCT_ID = p_PRODUCT_ID;
    
	-- Set the output parameters
	p_PRODUCT_NAME := v_RECORD.PRODUCT_NAME;
	p_PRODUCT_ALIAS := v_RECORD.PRODUCT_ALIAS;
	p_PRODUCT_DESC := v_RECORD.PRODUCT_DESC;
	p_PRODUCT_EXTERNAL_IDENTIFIER := v_RECORD.PRODUCT_EXTERNAL_IDENTIFIER;
	p_PRODUCT_CATEGORY := v_RECORD.PRODUCT_CATEGORY;
	p_BEGIN_DATE := v_RECORD.BEGIN_DATE;
	p_END_DATE := v_RECORD.END_DATE;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_PRODUCT_NAME := g_EMPTY_VARCHAR2;
		p_PRODUCT_ALIAS := g_EMPTY_VARCHAR2;
		p_PRODUCT_DESC := g_EMPTY_VARCHAR2;
		p_PRODUCT_EXTERNAL_IDENTIFIER := g_EMPTY_VARCHAR2;
		p_PRODUCT_CATEGORY := g_EMPTY_VARCHAR2;
		p_BEGIN_DATE := g_EMPTY_DATE;
		p_END_DATE := g_EMPTY_DATE;

END GET_PRODUCT;
---------------------------------------------------------------------
PROCEDURE PUT_PROGRAM
	(
	o_OID OUT NUMBER,
	p_PROGRAM_NAME IN VARCHAR2,
	p_PROGRAM_ALIAS IN VARCHAR2,
	p_PROGRAM_DESC IN VARCHAR2,
	p_PROGRAM_ID IN NUMBER,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_PROGRAM_TYPE IN VARCHAR2,
	p_PROGRAM_INTERVAL IN VARCHAR2,
	p_CUSTOMER_TYPE IN VARCHAR2,
	p_MAX_DURATION_HOUR IN NUMBER,
	p_MAX_DURATION_MINUTE IN NUMBER,
	p_MIN_OFF_TIME_HOUR IN NUMBER,
	p_MIN_OFF_TIME_MINUTE IN NUMBER,
	p_DEGREE_INCREASE IN NUMBER,
	p_DEGREE_DECREASE IN NUMBER,
	p_ALLOW_CUSTOMER_OVERRIDE IN NUMBER,
	p_DEFAULT_OPT_OUT_PCT IN NUMBER,
	p_DEFAULT_OVERRIDE_PCT IN NUMBER,
	p_USE_DEFAULT_OPT_OUT_OVERRIDE IN NUMBER,
	p_VALIDATION_METHOD IN VARCHAR2,
	p_TRANSACTION_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_SIGNAL_TYPE IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC PROGRAM%ROWTYPE;
BEGIN


	v_REC.PROGRAM_ID := p_PROGRAM_ID;
	v_REC.PROGRAM_NAME := TRIM(p_PROGRAM_NAME);
	v_REC.PROGRAM_ALIAS := TRIM(NVL(p_PROGRAM_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PROGRAM_DESC := TRIM(NVL(p_PROGRAM_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EXTERNAL_IDENTIFIER := TRIM(NVL(p_EXTERNAL_IDENTIFIER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PROGRAM_TYPE := TRIM(NVL(p_PROGRAM_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PROGRAM_INTERVAL := TRIM(NVL(p_PROGRAM_INTERVAL,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.CUSTOMER_TYPE := TRIM(NVL(p_CUSTOMER_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.MAX_DURATION_HOUR := p_MAX_DURATION_HOUR;
	v_REC.MAX_DURATION_MINUTE := p_MAX_DURATION_MINUTE;
	v_REC.MIN_OFF_TIME_HOUR := p_MIN_OFF_TIME_HOUR;
	v_REC.MIN_OFF_TIME_MINUTE := p_MIN_OFF_TIME_MINUTE;
	v_REC.DEGREE_INCREASE := p_DEGREE_INCREASE;
	v_REC.DEGREE_DECREASE := p_DEGREE_DECREASE;
	v_REC.ALLOW_CUSTOMER_OVERRIDE := p_ALLOW_CUSTOMER_OVERRIDE;
	v_REC.DEFAULT_OPT_OUT_PCT := p_DEFAULT_OPT_OUT_PCT;
	v_REC.DEFAULT_OVERRIDE_PCT := p_DEFAULT_OVERRIDE_PCT;
	v_REC.USE_DEFAULT_OPT_OUT_OVERRIDE := p_USE_DEFAULT_OPT_OUT_OVERRIDE;
	v_REC.VALIDATION_METHOD := TRIM(NVL(p_VALIDATION_METHOD,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.TRANSACTION_ID := NVL(p_TRANSACTION_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.COMPONENT_ID := NVL(p_COMPONENT_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.SIGNAL_TYPE := TRIM(NVL(p_SIGNAL_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_PROGRAM_ID > 0 OR p_PROGRAM_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_PROGRAM_ID, EC.ED_PROGRAM) 
                 AND IO_UTIL.PROGRAM_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_PROGRAM, p_PROGRAM_ID);
		END IF;

		-- save it!
		UPDATE PROGRAM
		SET ROW = v_REC
		WHERE PROGRAM_ID = p_PROGRAM_ID;
		o_OID := p_PROGRAM_ID;
        
	ELSIF p_PROGRAM_ID IS NULL OR p_PROGRAM_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.PROGRAM_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_PROGRAM, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.PROGRAM_ID := o_OID;
		-- save it!
		INSERT INTO PROGRAM VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_PROGRAM_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_PROGRAM, EC.ED_ENTITY_DOMAIN)||': '||p_PROGRAM_NAME);
END PUT_PROGRAM;
---------------------------------------------------------------------
PROCEDURE GET_PROGRAM
	(
	p_PROGRAM_ID IN NUMBER,
	p_PROGRAM_NAME OUT VARCHAR2,
	p_PROGRAM_ALIAS OUT VARCHAR2,
	p_PROGRAM_DESC OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_PROGRAM_TYPE OUT VARCHAR2,
	p_PROGRAM_INTERVAL OUT VARCHAR2,
	p_CUSTOMER_TYPE OUT VARCHAR2,
	p_MAX_DURATION_HOUR OUT NUMBER,
	p_MAX_DURATION_MINUTE OUT NUMBER,
	p_MIN_OFF_TIME_HOUR OUT NUMBER,
	p_MIN_OFF_TIME_MINUTE OUT NUMBER,
	p_DEGREE_INCREASE OUT NUMBER,
	p_DEGREE_DECREASE OUT NUMBER,
	p_ALLOW_CUSTOMER_OVERRIDE OUT NUMBER,
	p_DEFAULT_OPT_OUT_PCT OUT NUMBER,
	p_DEFAULT_OVERRIDE_PCT OUT NUMBER,
	p_USE_DEFAULT_OPT_OUT_OVERRIDE OUT NUMBER,
	p_VALIDATION_METHOD OUT VARCHAR2,
	p_TRANSACTION_ID OUT NUMBER,
	p_COMPONENT_ID OUT NUMBER,
	p_SIGNAL_TYPE OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD PROGRAM%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_PROGRAM_ID, EC.ED_PROGRAM);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM PROGRAM
	WHERE PROGRAM_ID = p_PROGRAM_ID;
    
	-- Set the output parameters
	p_PROGRAM_NAME := v_RECORD.PROGRAM_NAME;
	p_PROGRAM_ALIAS := v_RECORD.PROGRAM_ALIAS;
	p_PROGRAM_DESC := v_RECORD.PROGRAM_DESC;
	p_EXTERNAL_IDENTIFIER := v_RECORD.EXTERNAL_IDENTIFIER;
	p_PROGRAM_TYPE := v_RECORD.PROGRAM_TYPE;
	p_PROGRAM_INTERVAL := v_RECORD.PROGRAM_INTERVAL;
	p_CUSTOMER_TYPE := v_RECORD.CUSTOMER_TYPE;
	p_MAX_DURATION_HOUR := v_RECORD.MAX_DURATION_HOUR;
	p_MAX_DURATION_MINUTE := v_RECORD.MAX_DURATION_MINUTE;
	p_MIN_OFF_TIME_HOUR := v_RECORD.MIN_OFF_TIME_HOUR;
	p_MIN_OFF_TIME_MINUTE := v_RECORD.MIN_OFF_TIME_MINUTE;
	p_DEGREE_INCREASE := v_RECORD.DEGREE_INCREASE;
	p_DEGREE_DECREASE := v_RECORD.DEGREE_DECREASE;
	p_ALLOW_CUSTOMER_OVERRIDE := v_RECORD.ALLOW_CUSTOMER_OVERRIDE;
	p_DEFAULT_OPT_OUT_PCT := v_RECORD.DEFAULT_OPT_OUT_PCT;
	p_DEFAULT_OVERRIDE_PCT := v_RECORD.DEFAULT_OVERRIDE_PCT;
	p_USE_DEFAULT_OPT_OUT_OVERRIDE := v_RECORD.USE_DEFAULT_OPT_OUT_OVERRIDE;
	p_VALIDATION_METHOD := v_RECORD.VALIDATION_METHOD;
	p_TRANSACTION_ID := v_RECORD.TRANSACTION_ID;
	p_COMPONENT_ID := v_RECORD.COMPONENT_ID;
	p_SIGNAL_TYPE := v_RECORD.SIGNAL_TYPE;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_PROGRAM_NAME := g_EMPTY_VARCHAR2;
		p_PROGRAM_ALIAS := g_EMPTY_VARCHAR2;
		p_PROGRAM_DESC := g_EMPTY_VARCHAR2;
		p_EXTERNAL_IDENTIFIER := g_EMPTY_VARCHAR2;
		p_PROGRAM_TYPE := g_EMPTY_VARCHAR2;
		p_PROGRAM_INTERVAL := g_EMPTY_VARCHAR2;
		p_CUSTOMER_TYPE := g_EMPTY_VARCHAR2;
		p_MAX_DURATION_HOUR := g_EMPTY_NUMBER;
		p_MAX_DURATION_MINUTE := g_EMPTY_NUMBER;
		p_MIN_OFF_TIME_HOUR := g_EMPTY_NUMBER;
		p_MIN_OFF_TIME_MINUTE := g_EMPTY_NUMBER;
		p_DEGREE_INCREASE := g_EMPTY_NUMBER;
		p_DEGREE_DECREASE := g_EMPTY_NUMBER;
		p_ALLOW_CUSTOMER_OVERRIDE := g_EMPTY_NUMBER;
		p_DEFAULT_OPT_OUT_PCT := g_EMPTY_NUMBER;
		p_DEFAULT_OVERRIDE_PCT := g_EMPTY_NUMBER;
		p_USE_DEFAULT_OPT_OUT_OVERRIDE := g_EMPTY_NUMBER;
		p_VALIDATION_METHOD := g_EMPTY_VARCHAR2;
		p_TRANSACTION_ID := g_EMPTY_NUMBER;
		p_COMPONENT_ID := g_EMPTY_NUMBER;
		p_SIGNAL_TYPE := g_EMPTY_VARCHAR2;

END GET_PROGRAM;
---------------------------------------------------------------------
PROCEDURE PUT_PROSPECT_SCREEN
	(
	o_OID OUT NUMBER,
	p_SCREEN_NAME IN VARCHAR2,
	p_SCREEN_ALIAS IN VARCHAR2,
	p_SCREEN_DESC IN VARCHAR2,
	p_SCREEN_ID IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC PROSPECT_SCREEN%ROWTYPE;
BEGIN
	-- Make sure user has access
	IF NOT CAN_WRITE('Data Setup') THEN
        ERRS.RAISE_NO_WRITE_MODULE('Data Setup');
	END IF;



	v_REC.SCREEN_ID := p_SCREEN_ID;
	v_REC.SCREEN_NAME := TRIM(p_SCREEN_NAME);
	v_REC.SCREEN_ALIAS := TRIM(NVL(p_SCREEN_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SCREEN_DESC := TRIM(NVL(p_SCREEN_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_SCREEN_ID > 0 OR p_SCREEN_ID < -10 THEN

		-- save it!
		UPDATE PROSPECT_SCREEN
		SET ROW = v_REC
		WHERE SCREEN_ID = p_SCREEN_ID;
		o_OID := p_SCREEN_ID;
        
	ELSIF p_SCREEN_ID IS NULL OR p_SCREEN_ID = 0 THEN

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.SCREEN_ID := o_OID;
		-- save it!
		INSERT INTO PROSPECT_SCREEN VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_SCREEN_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, 'PROSPECT_SCREEN: '||p_SCREEN_NAME);
END PUT_PROSPECT_SCREEN;
---------------------------------------------------------------------
PROCEDURE GET_PROSPECT_SCREEN
	(
	p_SCREEN_ID IN NUMBER,
	p_SCREEN_NAME OUT VARCHAR2,
	p_SCREEN_ALIAS OUT VARCHAR2,
	p_SCREEN_DESC OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD PROSPECT_SCREEN%ROWTYPE;
BEGIN
	-- Make sure user has access
	IF NOT CAN_READ('Data Setup') THEN
        ERRS.RAISE_NO_READ_MODULE('Data Setup');
	END IF;

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM PROSPECT_SCREEN
	WHERE SCREEN_ID = p_SCREEN_ID;
    
	-- Set the output parameters
	p_SCREEN_NAME := v_RECORD.SCREEN_NAME;
	p_SCREEN_ALIAS := v_RECORD.SCREEN_ALIAS;
	p_SCREEN_DESC := v_RECORD.SCREEN_DESC;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_SCREEN_NAME := g_EMPTY_VARCHAR2;
		p_SCREEN_ALIAS := g_EMPTY_VARCHAR2;
		p_SCREEN_DESC := g_EMPTY_VARCHAR2;

END GET_PROSPECT_SCREEN;
---------------------------------------------------------------------
PROCEDURE PUT_PROXY_DAY_METHOD
	(
	o_OID OUT NUMBER,
	p_PROXY_DAY_METHOD_NAME IN VARCHAR2,
	p_PROXY_DAY_METHOD_ALIAS IN VARCHAR2,
	p_PROXY_DAY_METHOD_DESC IN VARCHAR2,
	p_PROXY_DAY_METHOD_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_COMPARATIVE_VALUE IN VARCHAR2,
	p_STATION_ID IN NUMBER,
	p_PARAMETER_ID IN NUMBER,
	p_SYSTEM_LOAD_ID IN NUMBER,
	p_LOOKUP_TIME_HORIZON IN NUMBER,
	p_TIME_HORIZON_SHIFT IN NUMBER,
	p_LOOKUP_CANDIDATE_LIMIT IN NUMBER,
	p_CANDIDATE_DELTA_THRESHOLD IN NUMBER,
	p_HOLIDAY_SET_ID IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC PROXY_DAY_METHOD%ROWTYPE;
BEGIN


	v_REC.PROXY_DAY_METHOD_ID := p_PROXY_DAY_METHOD_ID;
	v_REC.PROXY_DAY_METHOD_NAME := TRIM(p_PROXY_DAY_METHOD_NAME);
	v_REC.PROXY_DAY_METHOD_ALIAS := TRIM(NVL(p_PROXY_DAY_METHOD_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PROXY_DAY_METHOD_DESC := TRIM(NVL(p_PROXY_DAY_METHOD_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.TEMPLATE_ID := NVL(p_TEMPLATE_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.COMPARATIVE_VALUE := TRIM(NVL(p_COMPARATIVE_VALUE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.STATION_ID := p_STATION_ID;
	v_REC.PARAMETER_ID := p_PARAMETER_ID;
	v_REC.SYSTEM_LOAD_ID := p_SYSTEM_LOAD_ID;
	v_REC.LOOKUP_TIME_HORIZON := p_LOOKUP_TIME_HORIZON;
	v_REC.TIME_HORIZON_SHIFT := p_TIME_HORIZON_SHIFT;
	v_REC.LOOKUP_CANDIDATE_LIMIT := p_LOOKUP_CANDIDATE_LIMIT;
	v_REC.CANDIDATE_DELTA_THRESHOLD := p_CANDIDATE_DELTA_THRESHOLD;
	v_REC.ENTRY_DATE := SYSDATE;
	v_REC.HOLIDAY_SET_ID := NVL(p_HOLIDAY_SET_ID,CONSTANTS.NOT_ASSIGNED);

	IF p_PROXY_DAY_METHOD_ID > 0 OR p_PROXY_DAY_METHOD_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_PROXY_DAY_METHOD_ID, EC.ED_PROXY_DAY_METHOD) 
                 AND IO_UTIL.PROXY_DAY_METHOD_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_PROXY_DAY_METHOD, p_PROXY_DAY_METHOD_ID);
		END IF;

		-- save it!
		UPDATE PROXY_DAY_METHOD
		SET ROW = v_REC
		WHERE PROXY_DAY_METHOD_ID = p_PROXY_DAY_METHOD_ID;
		o_OID := p_PROXY_DAY_METHOD_ID;
        
	ELSIF p_PROXY_DAY_METHOD_ID IS NULL OR p_PROXY_DAY_METHOD_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.PROXY_DAY_METHOD_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_PROXY_DAY_METHOD, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.PROXY_DAY_METHOD_ID := o_OID;
		-- save it!
		INSERT INTO PROXY_DAY_METHOD VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_PROXY_DAY_METHOD_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_PROXY_DAY_METHOD, EC.ED_ENTITY_DOMAIN)||': '||p_PROXY_DAY_METHOD_NAME);
END PUT_PROXY_DAY_METHOD;
---------------------------------------------------------------------
PROCEDURE GET_PROXY_DAY_METHOD
	(
	p_PROXY_DAY_METHOD_ID IN NUMBER,
	p_PROXY_DAY_METHOD_NAME OUT VARCHAR2,
	p_PROXY_DAY_METHOD_ALIAS OUT VARCHAR2,
	p_PROXY_DAY_METHOD_DESC OUT VARCHAR2,
	p_TEMPLATE_ID OUT NUMBER,
	p_COMPARATIVE_VALUE OUT VARCHAR2,
	p_STATION_ID OUT NUMBER,
	p_PARAMETER_ID OUT NUMBER,
	p_SYSTEM_LOAD_ID OUT NUMBER,
	p_LOOKUP_TIME_HORIZON OUT NUMBER,
	p_TIME_HORIZON_SHIFT OUT NUMBER,
	p_LOOKUP_CANDIDATE_LIMIT OUT NUMBER,
	p_CANDIDATE_DELTA_THRESHOLD OUT NUMBER,
	p_HOLIDAY_SET_ID OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD PROXY_DAY_METHOD%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_PROXY_DAY_METHOD_ID, EC.ED_PROXY_DAY_METHOD);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM PROXY_DAY_METHOD
	WHERE PROXY_DAY_METHOD_ID = p_PROXY_DAY_METHOD_ID;
    
	-- Set the output parameters
	p_PROXY_DAY_METHOD_NAME := v_RECORD.PROXY_DAY_METHOD_NAME;
	p_PROXY_DAY_METHOD_ALIAS := v_RECORD.PROXY_DAY_METHOD_ALIAS;
	p_PROXY_DAY_METHOD_DESC := v_RECORD.PROXY_DAY_METHOD_DESC;
	p_TEMPLATE_ID := v_RECORD.TEMPLATE_ID;
	p_COMPARATIVE_VALUE := v_RECORD.COMPARATIVE_VALUE;
	p_STATION_ID := v_RECORD.STATION_ID;
	p_PARAMETER_ID := v_RECORD.PARAMETER_ID;
	p_SYSTEM_LOAD_ID := v_RECORD.SYSTEM_LOAD_ID;
	p_LOOKUP_TIME_HORIZON := v_RECORD.LOOKUP_TIME_HORIZON;
	p_TIME_HORIZON_SHIFT := v_RECORD.TIME_HORIZON_SHIFT;
	p_LOOKUP_CANDIDATE_LIMIT := v_RECORD.LOOKUP_CANDIDATE_LIMIT;
	p_CANDIDATE_DELTA_THRESHOLD := v_RECORD.CANDIDATE_DELTA_THRESHOLD;
	p_HOLIDAY_SET_ID := v_RECORD.HOLIDAY_SET_ID;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_PROXY_DAY_METHOD_NAME := g_EMPTY_VARCHAR2;
		p_PROXY_DAY_METHOD_ALIAS := g_EMPTY_VARCHAR2;
		p_PROXY_DAY_METHOD_DESC := g_EMPTY_VARCHAR2;
		p_TEMPLATE_ID := g_EMPTY_NUMBER;
		p_COMPARATIVE_VALUE := g_EMPTY_VARCHAR2;
		p_STATION_ID := g_EMPTY_NUMBER;
		p_PARAMETER_ID := g_EMPTY_NUMBER;
		p_SYSTEM_LOAD_ID := g_EMPTY_NUMBER;
		p_LOOKUP_TIME_HORIZON := g_EMPTY_NUMBER;
		p_TIME_HORIZON_SHIFT := g_EMPTY_NUMBER;
		p_LOOKUP_CANDIDATE_LIMIT := g_EMPTY_NUMBER;
		p_CANDIDATE_DELTA_THRESHOLD := g_EMPTY_NUMBER;
		p_HOLIDAY_SET_ID := g_EMPTY_NUMBER;

END GET_PROXY_DAY_METHOD;
---------------------------------------------------------------------
PROCEDURE PUT_PSE
	(
	o_OID OUT NUMBER,
	p_PSE_NAME IN VARCHAR2,
	p_PSE_ALIAS IN VARCHAR2,
	p_PSE_DESC IN VARCHAR2,
	p_PSE_ID IN NUMBER,
	p_PSE_NERC_CODE IN VARCHAR2,
	p_PSE_STATUS IN VARCHAR2,
	p_PSE_DUNS_NUMBER IN VARCHAR2,
	p_PSE_BANK IN VARCHAR2,
	p_PSE_ACH_NUMBER IN VARCHAR2,
	p_PSE_TYPE IN VARCHAR2,
	p_PSE_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_PSE_IS_RETAIL_AGGREGATOR IN NUMBER,
	p_PSE_IS_BACKUP_GENERATION IN NUMBER,
	p_PSE_EXCLUDE_LOAD_SCHEDULE IN NUMBER,
	p_IS_BILLING_ENTITY IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_STATEMENT_INTERVAL IN VARCHAR2,
	p_INVOICE_INTERVAL IN VARCHAR2,
	p_WEEK_BEGIN IN VARCHAR2,
	p_INVOICE_LINE_ITEM_OPTION IN VARCHAR2,
	p_INVOICE_EMAIL_SUBJECT IN VARCHAR2,
	p_INVOICE_EMAIL_PRIORITY IN NUMBER,
	p_INVOICE_EMAIL_BODY IN VARCHAR2,
	p_INVOICE_EMAIL_BODY_MIME_TYPE IN VARCHAR2,
	p_SCHEDULE_NAME_PREFIX IN VARCHAR2,
	p_SCHEDULE_FORMAT IN VARCHAR2,
	p_SCHEDULE_INTERVAL IN VARCHAR2,
	p_LOAD_ROUNDING_PREFERENCE IN VARCHAR2,
	p_LOSS_ROUNDING_PREFERENCE IN VARCHAR2,
	p_CREATE_TX_LOSS_SCHEDULE IN NUMBER,
	p_CREATE_DX_LOSS_SCHEDULE IN NUMBER,
	p_CREATE_UFE_SCHEDULE IN NUMBER,
	p_MINIMUM_SCHEDULE_AMT IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC PURCHASING_SELLING_ENTITY%ROWTYPE;
BEGIN


	v_REC.PSE_ID := p_PSE_ID;
	v_REC.PSE_NAME := TRIM(p_PSE_NAME);
	v_REC.PSE_ALIAS := TRIM(NVL(p_PSE_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PSE_DESC := TRIM(NVL(p_PSE_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PSE_NERC_CODE := TRIM(NVL(p_PSE_NERC_CODE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PSE_STATUS := TRIM(NVL(p_PSE_STATUS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PSE_DUNS_NUMBER := TRIM(NVL(p_PSE_DUNS_NUMBER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PSE_BANK := TRIM(NVL(p_PSE_BANK,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PSE_ACH_NUMBER := TRIM(NVL(p_PSE_ACH_NUMBER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PSE_TYPE := TRIM(NVL(p_PSE_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PSE_EXTERNAL_IDENTIFIER := TRIM(NVL(p_PSE_EXTERNAL_IDENTIFIER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PSE_IS_RETAIL_AGGREGATOR := p_PSE_IS_RETAIL_AGGREGATOR;
	v_REC.PSE_IS_BACKUP_GENERATION := p_PSE_IS_BACKUP_GENERATION;
	v_REC.PSE_EXCLUDE_LOAD_SCHEDULE := p_PSE_EXCLUDE_LOAD_SCHEDULE;
	v_REC.IS_BILLING_ENTITY := p_IS_BILLING_ENTITY;
	v_REC.TIME_ZONE := TRIM(NVL(p_TIME_ZONE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.STATEMENT_INTERVAL := TRIM(NVL(p_STATEMENT_INTERVAL,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.INVOICE_INTERVAL := TRIM(NVL(p_INVOICE_INTERVAL,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.WEEK_BEGIN := TRIM(NVL(p_WEEK_BEGIN,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.INVOICE_LINE_ITEM_OPTION := TRIM(NVL(p_INVOICE_LINE_ITEM_OPTION,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.INVOICE_EMAIL_SUBJECT := TRIM(NVL(p_INVOICE_EMAIL_SUBJECT,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.INVOICE_EMAIL_PRIORITY := p_INVOICE_EMAIL_PRIORITY;
	v_REC.INVOICE_EMAIL_BODY := TRIM(NVL(p_INVOICE_EMAIL_BODY,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.INVOICE_EMAIL_BODY_MIME_TYPE := TRIM(NVL(p_INVOICE_EMAIL_BODY_MIME_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SCHEDULE_NAME_PREFIX := TRIM(NVL(p_SCHEDULE_NAME_PREFIX,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SCHEDULE_FORMAT := TRIM(NVL(p_SCHEDULE_FORMAT,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SCHEDULE_INTERVAL := TRIM(NVL(p_SCHEDULE_INTERVAL,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.LOAD_ROUNDING_PREFERENCE := TRIM(NVL(p_LOAD_ROUNDING_PREFERENCE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.LOSS_ROUNDING_PREFERENCE := TRIM(NVL(p_LOSS_ROUNDING_PREFERENCE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.CREATE_TX_LOSS_SCHEDULE := p_CREATE_TX_LOSS_SCHEDULE;
	v_REC.CREATE_DX_LOSS_SCHEDULE := p_CREATE_DX_LOSS_SCHEDULE;
	v_REC.CREATE_UFE_SCHEDULE := p_CREATE_UFE_SCHEDULE;
	v_REC.MINIMUM_SCHEDULE_AMT := p_MINIMUM_SCHEDULE_AMT;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_PSE_ID > 0 OR p_PSE_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_PSE_ID, EC.ED_PSE) 
                 AND IO_UTIL.PSE_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_PSE, p_PSE_ID);
		END IF;

		-- save it!
		UPDATE PURCHASING_SELLING_ENTITY
		SET ROW = v_REC
		WHERE PSE_ID = p_PSE_ID;
		o_OID := p_PSE_ID;
        
	ELSIF p_PSE_ID IS NULL OR p_PSE_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.PSE_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_PSE, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.PSE_ID := o_OID;
		-- save it!
		INSERT INTO PURCHASING_SELLING_ENTITY VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_PSE_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_PSE, EC.ED_ENTITY_DOMAIN)||': '||p_PSE_NAME);
END PUT_PSE;
---------------------------------------------------------------------
PROCEDURE GET_PSE
	(
	p_PSE_ID IN NUMBER,
	p_PSE_NAME OUT VARCHAR2,
	p_PSE_ALIAS OUT VARCHAR2,
	p_PSE_DESC OUT VARCHAR2,
	p_PSE_NERC_CODE OUT VARCHAR2,
	p_PSE_STATUS OUT VARCHAR2,
	p_PSE_DUNS_NUMBER OUT VARCHAR2,
	p_PSE_BANK OUT VARCHAR2,
	p_PSE_ACH_NUMBER OUT VARCHAR2,
	p_PSE_TYPE OUT VARCHAR2,
	p_PSE_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_PSE_IS_RETAIL_AGGREGATOR OUT NUMBER,
	p_PSE_IS_BACKUP_GENERATION OUT NUMBER,
	p_PSE_EXCLUDE_LOAD_SCHEDULE OUT NUMBER,
	p_IS_BILLING_ENTITY OUT NUMBER,
	p_TIME_ZONE OUT VARCHAR2,
	p_STATEMENT_INTERVAL OUT VARCHAR2,
	p_INVOICE_INTERVAL OUT VARCHAR2,
	p_WEEK_BEGIN OUT VARCHAR2,
	p_INVOICE_LINE_ITEM_OPTION OUT VARCHAR2,
	p_INVOICE_EMAIL_SUBJECT OUT VARCHAR2,
	p_INVOICE_EMAIL_PRIORITY OUT NUMBER,
	p_INVOICE_EMAIL_BODY OUT VARCHAR2,
	p_INVOICE_EMAIL_BODY_MIME_TYPE OUT VARCHAR2,
	p_SCHEDULE_NAME_PREFIX OUT VARCHAR2,
	p_SCHEDULE_FORMAT OUT VARCHAR2,
	p_SCHEDULE_INTERVAL OUT VARCHAR2,
	p_LOAD_ROUNDING_PREFERENCE OUT VARCHAR2,
	p_LOSS_ROUNDING_PREFERENCE OUT VARCHAR2,
	p_CREATE_TX_LOSS_SCHEDULE OUT NUMBER,
	p_CREATE_DX_LOSS_SCHEDULE OUT NUMBER,
	p_CREATE_UFE_SCHEDULE OUT NUMBER,
	p_MINIMUM_SCHEDULE_AMT OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD PURCHASING_SELLING_ENTITY%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_PSE_ID, EC.ED_PSE);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM PURCHASING_SELLING_ENTITY
	WHERE PSE_ID = p_PSE_ID;
    
	-- Set the output parameters
	p_PSE_NAME := v_RECORD.PSE_NAME;
	p_PSE_ALIAS := v_RECORD.PSE_ALIAS;
	p_PSE_DESC := v_RECORD.PSE_DESC;
	p_PSE_NERC_CODE := v_RECORD.PSE_NERC_CODE;
	p_PSE_STATUS := v_RECORD.PSE_STATUS;
	p_PSE_DUNS_NUMBER := v_RECORD.PSE_DUNS_NUMBER;
	p_PSE_BANK := v_RECORD.PSE_BANK;
	p_PSE_ACH_NUMBER := v_RECORD.PSE_ACH_NUMBER;
	p_PSE_TYPE := v_RECORD.PSE_TYPE;
	p_PSE_EXTERNAL_IDENTIFIER := v_RECORD.PSE_EXTERNAL_IDENTIFIER;
	p_PSE_IS_RETAIL_AGGREGATOR := v_RECORD.PSE_IS_RETAIL_AGGREGATOR;
	p_PSE_IS_BACKUP_GENERATION := v_RECORD.PSE_IS_BACKUP_GENERATION;
	p_PSE_EXCLUDE_LOAD_SCHEDULE := v_RECORD.PSE_EXCLUDE_LOAD_SCHEDULE;
	p_IS_BILLING_ENTITY := v_RECORD.IS_BILLING_ENTITY;
	p_TIME_ZONE := v_RECORD.TIME_ZONE;
	p_STATEMENT_INTERVAL := v_RECORD.STATEMENT_INTERVAL;
	p_INVOICE_INTERVAL := v_RECORD.INVOICE_INTERVAL;
	p_WEEK_BEGIN := v_RECORD.WEEK_BEGIN;
	p_INVOICE_LINE_ITEM_OPTION := v_RECORD.INVOICE_LINE_ITEM_OPTION;
	p_INVOICE_EMAIL_SUBJECT := v_RECORD.INVOICE_EMAIL_SUBJECT;
	p_INVOICE_EMAIL_PRIORITY := v_RECORD.INVOICE_EMAIL_PRIORITY;
	p_INVOICE_EMAIL_BODY := v_RECORD.INVOICE_EMAIL_BODY;
	p_INVOICE_EMAIL_BODY_MIME_TYPE := v_RECORD.INVOICE_EMAIL_BODY_MIME_TYPE;
	p_SCHEDULE_NAME_PREFIX := v_RECORD.SCHEDULE_NAME_PREFIX;
	p_SCHEDULE_FORMAT := v_RECORD.SCHEDULE_FORMAT;
	p_SCHEDULE_INTERVAL := v_RECORD.SCHEDULE_INTERVAL;
	p_LOAD_ROUNDING_PREFERENCE := v_RECORD.LOAD_ROUNDING_PREFERENCE;
	p_LOSS_ROUNDING_PREFERENCE := v_RECORD.LOSS_ROUNDING_PREFERENCE;
	p_CREATE_TX_LOSS_SCHEDULE := v_RECORD.CREATE_TX_LOSS_SCHEDULE;
	p_CREATE_DX_LOSS_SCHEDULE := v_RECORD.CREATE_DX_LOSS_SCHEDULE;
	p_CREATE_UFE_SCHEDULE := v_RECORD.CREATE_UFE_SCHEDULE;
	p_MINIMUM_SCHEDULE_AMT := v_RECORD.MINIMUM_SCHEDULE_AMT;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_PSE_NAME := g_EMPTY_VARCHAR2;
		p_PSE_ALIAS := g_EMPTY_VARCHAR2;
		p_PSE_DESC := g_EMPTY_VARCHAR2;
		p_PSE_NERC_CODE := g_EMPTY_VARCHAR2;
		p_PSE_STATUS := g_EMPTY_VARCHAR2;
		p_PSE_DUNS_NUMBER := g_EMPTY_VARCHAR2;
		p_PSE_BANK := g_EMPTY_VARCHAR2;
		p_PSE_ACH_NUMBER := g_EMPTY_VARCHAR2;
		p_PSE_TYPE := g_EMPTY_VARCHAR2;
		p_PSE_EXTERNAL_IDENTIFIER := g_EMPTY_VARCHAR2;
		p_PSE_IS_RETAIL_AGGREGATOR := g_EMPTY_NUMBER;
		p_PSE_IS_BACKUP_GENERATION := g_EMPTY_NUMBER;
		p_PSE_EXCLUDE_LOAD_SCHEDULE := g_EMPTY_NUMBER;
		p_IS_BILLING_ENTITY := g_EMPTY_NUMBER;
		p_TIME_ZONE := g_EMPTY_VARCHAR2;
		p_STATEMENT_INTERVAL := g_EMPTY_VARCHAR2;
		p_INVOICE_INTERVAL := g_EMPTY_VARCHAR2;
		p_WEEK_BEGIN := g_EMPTY_VARCHAR2;
		p_INVOICE_LINE_ITEM_OPTION := g_EMPTY_VARCHAR2;
		p_INVOICE_EMAIL_SUBJECT := g_EMPTY_VARCHAR2;
		p_INVOICE_EMAIL_PRIORITY := g_EMPTY_NUMBER;
		p_INVOICE_EMAIL_BODY := g_EMPTY_VARCHAR2;
		p_INVOICE_EMAIL_BODY_MIME_TYPE := g_EMPTY_VARCHAR2;
		p_SCHEDULE_NAME_PREFIX := g_EMPTY_VARCHAR2;
		p_SCHEDULE_FORMAT := g_EMPTY_VARCHAR2;
		p_SCHEDULE_INTERVAL := g_EMPTY_VARCHAR2;
		p_LOAD_ROUNDING_PREFERENCE := g_EMPTY_VARCHAR2;
		p_LOSS_ROUNDING_PREFERENCE := g_EMPTY_VARCHAR2;
		p_CREATE_TX_LOSS_SCHEDULE := g_EMPTY_NUMBER;
		p_CREATE_DX_LOSS_SCHEDULE := g_EMPTY_NUMBER;
		p_CREATE_UFE_SCHEDULE := g_EMPTY_NUMBER;
		p_MINIMUM_SCHEDULE_AMT := g_EMPTY_NUMBER;

END GET_PSE;
---------------------------------------------------------------------
PROCEDURE PUT_QUOTE_REQUEST
	(
	o_OID OUT NUMBER,
	p_QUOTE_NAME IN VARCHAR2,
	p_QUOTE_ALIAS IN VARCHAR2,
	p_QUOTE_DESC IN VARCHAR2,
	p_QUOTE_ID IN NUMBER,
	p_CAMPAIGN_NAME IN VARCHAR2,
	p_CUSTOMER_NAME IN VARCHAR2,
	p_CUSTOMER_TYPE IN VARCHAR2,
	p_CUSTOMER_REP_NAME IN VARCHAR2,
	p_EDC_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_CUSTOMER_CLASS IN VARCHAR2,
	p_EDC_ACCOUNT_NUMBER IN VARCHAR2,
	p_QUOTE_EFFECTIVE_DATE IN DATE,
	p_QUOTE_EXPIRATION_DATE IN DATE,
	p_SERVICE_BEGIN_DATE IN DATE,
	p_SERVICE_END_DATE IN DATE,
	p_QUOTE_TYPE IN VARCHAR2,
	p_QUOTE_STATUS IN VARCHAR2,
	p_STATION_ID IN NUMBER,
	p_NUMBER_OF_CUSTOMERS IN NUMBER,
	p_SIGNING_PROBABILITY IN NUMBER,
	p_QUOTE_NOTES IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC QUOTE_REQUEST%ROWTYPE;
BEGIN


	v_REC.QUOTE_ID := p_QUOTE_ID;
	v_REC.QUOTE_NAME := TRIM(p_QUOTE_NAME);
	v_REC.QUOTE_ALIAS := TRIM(NVL(p_QUOTE_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.QUOTE_DESC := TRIM(NVL(p_QUOTE_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.CAMPAIGN_NAME := TRIM(NVL(p_CAMPAIGN_NAME,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.CUSTOMER_NAME := TRIM(NVL(p_CUSTOMER_NAME,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.CUSTOMER_TYPE := TRIM(NVL(p_CUSTOMER_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.CUSTOMER_REP_NAME := TRIM(NVL(p_CUSTOMER_REP_NAME,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EDC_ID := NVL(p_EDC_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.SERVICE_POINT_ID := NVL(p_SERVICE_POINT_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.CUSTOMER_CLASS := TRIM(NVL(p_CUSTOMER_CLASS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EDC_ACCOUNT_NUMBER := TRIM(NVL(p_EDC_ACCOUNT_NUMBER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.QUOTE_EFFECTIVE_DATE := p_QUOTE_EFFECTIVE_DATE;
	v_REC.QUOTE_EXPIRATION_DATE := p_QUOTE_EXPIRATION_DATE;
	v_REC.SERVICE_BEGIN_DATE := p_SERVICE_BEGIN_DATE;
	v_REC.SERVICE_END_DATE := p_SERVICE_END_DATE;
	v_REC.QUOTE_TYPE := TRIM(NVL(p_QUOTE_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.QUOTE_STATUS := TRIM(NVL(p_QUOTE_STATUS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.STATION_ID := NVL(p_STATION_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.NUMBER_OF_CUSTOMERS := p_NUMBER_OF_CUSTOMERS;
	v_REC.SIGNING_PROBABILITY := p_SIGNING_PROBABILITY;
	v_REC.QUOTE_NOTES := TRIM(NVL(p_QUOTE_NOTES,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_QUOTE_ID > 0 OR p_QUOTE_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_QUOTE_ID, EC.ED_QUOTE_REQUEST) 
                 AND IO_UTIL.QUOTE_REQUEST_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_QUOTE_REQUEST, p_QUOTE_ID);
		END IF;

		-- save it!
		UPDATE QUOTE_REQUEST
		SET ROW = v_REC
		WHERE QUOTE_ID = p_QUOTE_ID;
		o_OID := p_QUOTE_ID;
        
	ELSIF p_QUOTE_ID IS NULL OR p_QUOTE_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.QUOTE_REQUEST_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_QUOTE_REQUEST, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.QUOTE_ID := o_OID;
		-- save it!
		INSERT INTO QUOTE_REQUEST VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_QUOTE_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_QUOTE_REQUEST, EC.ED_ENTITY_DOMAIN)||': '||p_QUOTE_NAME);
END PUT_QUOTE_REQUEST;
---------------------------------------------------------------------
PROCEDURE GET_QUOTE_REQUEST
	(
	p_QUOTE_ID IN NUMBER,
	p_QUOTE_NAME OUT VARCHAR2,
	p_QUOTE_ALIAS OUT VARCHAR2,
	p_QUOTE_DESC OUT VARCHAR2,
	p_CAMPAIGN_NAME OUT VARCHAR2,
	p_CUSTOMER_NAME OUT VARCHAR2,
	p_CUSTOMER_TYPE OUT VARCHAR2,
	p_CUSTOMER_REP_NAME OUT VARCHAR2,
	p_EDC_ID OUT NUMBER,
	p_SERVICE_POINT_ID OUT NUMBER,
	p_CUSTOMER_CLASS OUT VARCHAR2,
	p_EDC_ACCOUNT_NUMBER OUT VARCHAR2,
	p_QUOTE_EFFECTIVE_DATE OUT DATE,
	p_QUOTE_EXPIRATION_DATE OUT DATE,
	p_SERVICE_BEGIN_DATE OUT DATE,
	p_SERVICE_END_DATE OUT DATE,
	p_QUOTE_TYPE OUT VARCHAR2,
	p_QUOTE_STATUS OUT VARCHAR2,
	p_STATION_ID OUT NUMBER,
	p_NUMBER_OF_CUSTOMERS OUT NUMBER,
	p_SIGNING_PROBABILITY OUT NUMBER,
	p_QUOTE_NOTES OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD QUOTE_REQUEST%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_QUOTE_ID, EC.ED_QUOTE_REQUEST);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM QUOTE_REQUEST
	WHERE QUOTE_ID = p_QUOTE_ID;
    
	-- Set the output parameters
	p_QUOTE_NAME := v_RECORD.QUOTE_NAME;
	p_QUOTE_ALIAS := v_RECORD.QUOTE_ALIAS;
	p_QUOTE_DESC := v_RECORD.QUOTE_DESC;
	p_CAMPAIGN_NAME := v_RECORD.CAMPAIGN_NAME;
	p_CUSTOMER_NAME := v_RECORD.CUSTOMER_NAME;
	p_CUSTOMER_TYPE := v_RECORD.CUSTOMER_TYPE;
	p_CUSTOMER_REP_NAME := v_RECORD.CUSTOMER_REP_NAME;
	p_EDC_ID := v_RECORD.EDC_ID;
	p_SERVICE_POINT_ID := v_RECORD.SERVICE_POINT_ID;
	p_CUSTOMER_CLASS := v_RECORD.CUSTOMER_CLASS;
	p_EDC_ACCOUNT_NUMBER := v_RECORD.EDC_ACCOUNT_NUMBER;
	p_QUOTE_EFFECTIVE_DATE := v_RECORD.QUOTE_EFFECTIVE_DATE;
	p_QUOTE_EXPIRATION_DATE := v_RECORD.QUOTE_EXPIRATION_DATE;
	p_SERVICE_BEGIN_DATE := v_RECORD.SERVICE_BEGIN_DATE;
	p_SERVICE_END_DATE := v_RECORD.SERVICE_END_DATE;
	p_QUOTE_TYPE := v_RECORD.QUOTE_TYPE;
	p_QUOTE_STATUS := v_RECORD.QUOTE_STATUS;
	p_STATION_ID := v_RECORD.STATION_ID;
	p_NUMBER_OF_CUSTOMERS := v_RECORD.NUMBER_OF_CUSTOMERS;
	p_SIGNING_PROBABILITY := v_RECORD.SIGNING_PROBABILITY;
	p_QUOTE_NOTES := v_RECORD.QUOTE_NOTES;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_QUOTE_NAME := g_EMPTY_VARCHAR2;
		p_QUOTE_ALIAS := g_EMPTY_VARCHAR2;
		p_QUOTE_DESC := g_EMPTY_VARCHAR2;
		p_CAMPAIGN_NAME := g_EMPTY_VARCHAR2;
		p_CUSTOMER_NAME := g_EMPTY_VARCHAR2;
		p_CUSTOMER_TYPE := g_EMPTY_VARCHAR2;
		p_CUSTOMER_REP_NAME := g_EMPTY_VARCHAR2;
		p_EDC_ID := g_EMPTY_NUMBER;
		p_SERVICE_POINT_ID := g_EMPTY_NUMBER;
		p_CUSTOMER_CLASS := g_EMPTY_VARCHAR2;
		p_EDC_ACCOUNT_NUMBER := g_EMPTY_VARCHAR2;
		p_QUOTE_EFFECTIVE_DATE := g_EMPTY_DATE;
		p_QUOTE_EXPIRATION_DATE := g_EMPTY_DATE;
		p_SERVICE_BEGIN_DATE := g_EMPTY_DATE;
		p_SERVICE_END_DATE := g_EMPTY_DATE;
		p_QUOTE_TYPE := g_EMPTY_VARCHAR2;
		p_QUOTE_STATUS := g_EMPTY_VARCHAR2;
		p_STATION_ID := g_EMPTY_NUMBER;
		p_NUMBER_OF_CUSTOMERS := g_EMPTY_NUMBER;
		p_SIGNING_PROBABILITY := g_EMPTY_NUMBER;
		p_QUOTE_NOTES := g_EMPTY_VARCHAR2;

END GET_QUOTE_REQUEST;
---------------------------------------------------------------------
PROCEDURE PUT_REACTOR_PROCEDURE
	(
	o_OID OUT NUMBER,
	p_REACTOR_PROCEDURE_NAME IN VARCHAR2,
	p_REACTOR_PROCEDURE_ALIAS IN VARCHAR2,
	p_REACTOR_PROCEDURE_DESC IN VARCHAR2,
	p_REACTOR_PROCEDURE_ID IN NUMBER,
	p_TABLE_ID IN NUMBER,
	p_PROCEDURE_NAME IN VARCHAR2,
	p_JOB_THREAD_ID IN NUMBER,
	p_JOB_COMMENTS IN VARCHAR2,
	p_CALL_ORDER IN NUMBER,
	p_SKIP_WHEN_FORMULA IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_IS_IMMEDIATE IN NUMBER,
	p_IS_ENABLED IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC REACTOR_PROCEDURE%ROWTYPE;
BEGIN


	v_REC.REACTOR_PROCEDURE_ID := p_REACTOR_PROCEDURE_ID;
	v_REC.REACTOR_PROCEDURE_NAME := TRIM(p_REACTOR_PROCEDURE_NAME);
	v_REC.REACTOR_PROCEDURE_ALIAS := TRIM(NVL(p_REACTOR_PROCEDURE_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.REACTOR_PROCEDURE_DESC := TRIM(NVL(p_REACTOR_PROCEDURE_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.TABLE_ID := p_TABLE_ID;
	v_REC.PROCEDURE_NAME := TRIM(p_PROCEDURE_NAME);
	v_REC.JOB_THREAD_ID := p_JOB_THREAD_ID;
	v_REC.JOB_COMMENTS := TRIM(p_JOB_COMMENTS);
	v_REC.CALL_ORDER := p_CALL_ORDER;
	v_REC.SKIP_WHEN_FORMULA := TRIM(p_SKIP_WHEN_FORMULA);
	v_REC.TIME_ZONE := TRIM(p_TIME_ZONE);
	v_REC.IS_IMMEDIATE := p_IS_IMMEDIATE;
	v_REC.IS_ENABLED := p_IS_ENABLED;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_REACTOR_PROCEDURE_ID > 0 OR p_REACTOR_PROCEDURE_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_REACTOR_PROCEDURE_ID, EC.ED_REACTOR_PROCEDURE) 
                 AND IO_UTIL.REACTOR_PROCEDURE_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_REACTOR_PROCEDURE, p_REACTOR_PROCEDURE_ID);
		END IF;

		-- save it!
		UPDATE REACTOR_PROCEDURE
		SET ROW = v_REC
		WHERE REACTOR_PROCEDURE_ID = p_REACTOR_PROCEDURE_ID;
		o_OID := p_REACTOR_PROCEDURE_ID;
        
	ELSIF p_REACTOR_PROCEDURE_ID IS NULL OR p_REACTOR_PROCEDURE_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.REACTOR_PROCEDURE_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_REACTOR_PROCEDURE, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.REACTOR_PROCEDURE_ID := o_OID;
		-- save it!
		INSERT INTO REACTOR_PROCEDURE VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_REACTOR_PROCEDURE_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_REACTOR_PROCEDURE, EC.ED_ENTITY_DOMAIN)||': '||p_REACTOR_PROCEDURE_NAME);
END PUT_REACTOR_PROCEDURE;
---------------------------------------------------------------------
PROCEDURE GET_REACTOR_PROCEDURE
	(
	p_REACTOR_PROCEDURE_ID IN NUMBER,
	p_REACTOR_PROCEDURE_NAME OUT VARCHAR2,
	p_REACTOR_PROCEDURE_ALIAS OUT VARCHAR2,
	p_REACTOR_PROCEDURE_DESC OUT VARCHAR2,
	p_TABLE_ID OUT NUMBER,
	p_PROCEDURE_NAME OUT VARCHAR2,
	p_JOB_THREAD_ID OUT NUMBER,
	p_JOB_COMMENTS OUT VARCHAR2,
	p_CALL_ORDER OUT NUMBER,
	p_SKIP_WHEN_FORMULA OUT VARCHAR2,
	p_TIME_ZONE OUT VARCHAR2,
	p_IS_IMMEDIATE OUT NUMBER,
	p_IS_ENABLED OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD REACTOR_PROCEDURE%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_REACTOR_PROCEDURE_ID, EC.ED_REACTOR_PROCEDURE);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM REACTOR_PROCEDURE
	WHERE REACTOR_PROCEDURE_ID = p_REACTOR_PROCEDURE_ID;
    
	-- Set the output parameters
	p_REACTOR_PROCEDURE_NAME := v_RECORD.REACTOR_PROCEDURE_NAME;
	p_REACTOR_PROCEDURE_ALIAS := v_RECORD.REACTOR_PROCEDURE_ALIAS;
	p_REACTOR_PROCEDURE_DESC := v_RECORD.REACTOR_PROCEDURE_DESC;
	p_TABLE_ID := v_RECORD.TABLE_ID;
	p_PROCEDURE_NAME := v_RECORD.PROCEDURE_NAME;
	p_JOB_THREAD_ID := v_RECORD.JOB_THREAD_ID;
	p_JOB_COMMENTS := v_RECORD.JOB_COMMENTS;
	p_CALL_ORDER := v_RECORD.CALL_ORDER;
	p_SKIP_WHEN_FORMULA := v_RECORD.SKIP_WHEN_FORMULA;
	p_TIME_ZONE := v_RECORD.TIME_ZONE;
	p_IS_IMMEDIATE := v_RECORD.IS_IMMEDIATE;
	p_IS_ENABLED := v_RECORD.IS_ENABLED;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_REACTOR_PROCEDURE_NAME := g_EMPTY_VARCHAR2;
		p_REACTOR_PROCEDURE_ALIAS := g_EMPTY_VARCHAR2;
		p_REACTOR_PROCEDURE_DESC := g_EMPTY_VARCHAR2;
		p_TABLE_ID := g_EMPTY_NUMBER;
		p_PROCEDURE_NAME := g_EMPTY_VARCHAR2;
		p_JOB_THREAD_ID := g_EMPTY_NUMBER;
		p_JOB_COMMENTS := g_EMPTY_VARCHAR2;
		p_CALL_ORDER := g_EMPTY_NUMBER;
		p_SKIP_WHEN_FORMULA := g_EMPTY_VARCHAR2;
		p_TIME_ZONE := g_EMPTY_VARCHAR2;
		p_IS_IMMEDIATE := g_EMPTY_NUMBER;
		p_IS_ENABLED := g_EMPTY_NUMBER;

END GET_REACTOR_PROCEDURE;
---------------------------------------------------------------------
PROCEDURE PUT_RESOURCE_GROUP
	(
	o_OID OUT NUMBER,
	p_RESOURCE_GROUP_NAME IN VARCHAR2,
	p_RESOURCE_GROUP_ALIAS IN VARCHAR2,
	p_RESOURCE_GROUP_DESC IN VARCHAR2,
	p_RESOURCE_GROUP_ID IN NUMBER,
	p_SERVICE_ZONE_ID IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC SUPPLY_RESOURCE_GROUP%ROWTYPE;
BEGIN


	v_REC.RESOURCE_GROUP_ID := p_RESOURCE_GROUP_ID;
	v_REC.RESOURCE_GROUP_NAME := TRIM(p_RESOURCE_GROUP_NAME);
	v_REC.RESOURCE_GROUP_ALIAS := TRIM(NVL(p_RESOURCE_GROUP_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.RESOURCE_GROUP_DESC := TRIM(NVL(p_RESOURCE_GROUP_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SERVICE_ZONE_ID := NVL(p_SERVICE_ZONE_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_RESOURCE_GROUP_ID > 0 OR p_RESOURCE_GROUP_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_RESOURCE_GROUP_ID, EC.ED_RESOURCE_GROUP) 
                 AND IO_UTIL.RESOURCE_GROUP_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_RESOURCE_GROUP, p_RESOURCE_GROUP_ID);
		END IF;

		-- save it!
		UPDATE SUPPLY_RESOURCE_GROUP
		SET ROW = v_REC
		WHERE RESOURCE_GROUP_ID = p_RESOURCE_GROUP_ID;
		o_OID := p_RESOURCE_GROUP_ID;
        
	ELSIF p_RESOURCE_GROUP_ID IS NULL OR p_RESOURCE_GROUP_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.RESOURCE_GROUP_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_RESOURCE_GROUP, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.RESOURCE_GROUP_ID := o_OID;
		-- save it!
		INSERT INTO SUPPLY_RESOURCE_GROUP VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_RESOURCE_GROUP_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_RESOURCE_GROUP, EC.ED_ENTITY_DOMAIN)||': '||p_RESOURCE_GROUP_NAME);
END PUT_RESOURCE_GROUP;
---------------------------------------------------------------------
PROCEDURE GET_RESOURCE_GROUP
	(
	p_RESOURCE_GROUP_ID IN NUMBER,
	p_RESOURCE_GROUP_NAME OUT VARCHAR2,
	p_RESOURCE_GROUP_ALIAS OUT VARCHAR2,
	p_RESOURCE_GROUP_DESC OUT VARCHAR2,
	p_SERVICE_ZONE_ID OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD SUPPLY_RESOURCE_GROUP%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_RESOURCE_GROUP_ID, EC.ED_RESOURCE_GROUP);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM SUPPLY_RESOURCE_GROUP
	WHERE RESOURCE_GROUP_ID = p_RESOURCE_GROUP_ID;
    
	-- Set the output parameters
	p_RESOURCE_GROUP_NAME := v_RECORD.RESOURCE_GROUP_NAME;
	p_RESOURCE_GROUP_ALIAS := v_RECORD.RESOURCE_GROUP_ALIAS;
	p_RESOURCE_GROUP_DESC := v_RECORD.RESOURCE_GROUP_DESC;
	p_SERVICE_ZONE_ID := v_RECORD.SERVICE_ZONE_ID;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_RESOURCE_GROUP_NAME := g_EMPTY_VARCHAR2;
		p_RESOURCE_GROUP_ALIAS := g_EMPTY_VARCHAR2;
		p_RESOURCE_GROUP_DESC := g_EMPTY_VARCHAR2;
		p_SERVICE_ZONE_ID := g_EMPTY_NUMBER;

END GET_RESOURCE_GROUP;
---------------------------------------------------------------------
PROCEDURE PUT_ROLLUP
	(
	o_OID OUT NUMBER,
	p_ROLLUP_NAME IN VARCHAR2,
	p_ROLLUP_ALIAS IN VARCHAR2,
	p_ROLLUP_DESC IN VARCHAR2,
	p_ROLLUP_ID IN NUMBER,
	p_ROLLUP_CATEGORY IN VARCHAR2,
	p_ROLLUP_LEVEL IN NUMBER,
	p_ROLLUP_PARENT_ID IN NUMBER,
	p_ROLLUP_CHILDREN IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC RTO_ROLLUP%ROWTYPE;
BEGIN
	-- Make sure user has access
	IF NOT CAN_WRITE('Data Setup') THEN
        ERRS.RAISE_NO_WRITE_MODULE('Data Setup');
	END IF;



	v_REC.ROLLUP_NAME := TRIM(p_ROLLUP_NAME);
	v_REC.ROLLUP_ALIAS := TRIM(NVL(p_ROLLUP_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ROLLUP_DESC := TRIM(NVL(p_ROLLUP_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ROLLUP_ID := p_ROLLUP_ID;
	v_REC.ROLLUP_CATEGORY := TRIM(NVL(p_ROLLUP_CATEGORY,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ROLLUP_LEVEL := p_ROLLUP_LEVEL;
	v_REC.ROLLUP_PARENT_ID := p_ROLLUP_PARENT_ID;
	v_REC.ROLLUP_CHILDREN := p_ROLLUP_CHILDREN;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_ROLLUP_ID > 0 OR p_ROLLUP_ID < -10 THEN

		-- save it!
		UPDATE RTO_ROLLUP
		SET ROW = v_REC
		WHERE ROLLUP_ID = p_ROLLUP_ID;
		o_OID := p_ROLLUP_ID;
        
	ELSIF p_ROLLUP_ID IS NULL OR p_ROLLUP_ID = 0 THEN

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.ROLLUP_ID := o_OID;
		-- save it!
		INSERT INTO RTO_ROLLUP VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_ROLLUP_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, 'ROLLUP: '||p_ROLLUP_NAME);
END PUT_ROLLUP;
---------------------------------------------------------------------
PROCEDURE GET_ROLLUP
	(
	p_ROLLUP_NAME OUT VARCHAR2,
	p_ROLLUP_ALIAS OUT VARCHAR2,
	p_ROLLUP_DESC OUT VARCHAR2,
	p_ROLLUP_ID IN NUMBER,
	p_ROLLUP_CATEGORY OUT VARCHAR2,
	p_ROLLUP_LEVEL OUT NUMBER,
	p_ROLLUP_PARENT_ID OUT NUMBER,
	p_ROLLUP_CHILDREN OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD RTO_ROLLUP%ROWTYPE;
BEGIN
	-- Make sure user has access
	IF NOT CAN_READ('Data Setup') THEN
        ERRS.RAISE_NO_READ_MODULE('Data Setup');
	END IF;

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM RTO_ROLLUP
	WHERE ROLLUP_ID = p_ROLLUP_ID;
    
	-- Set the output parameters
	p_ROLLUP_NAME := v_RECORD.ROLLUP_NAME;
	p_ROLLUP_ALIAS := v_RECORD.ROLLUP_ALIAS;
	p_ROLLUP_DESC := v_RECORD.ROLLUP_DESC;
	p_ROLLUP_CATEGORY := v_RECORD.ROLLUP_CATEGORY;
	p_ROLLUP_LEVEL := v_RECORD.ROLLUP_LEVEL;
	p_ROLLUP_PARENT_ID := v_RECORD.ROLLUP_PARENT_ID;
	p_ROLLUP_CHILDREN := v_RECORD.ROLLUP_CHILDREN;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_ROLLUP_NAME := g_EMPTY_VARCHAR2;
		p_ROLLUP_ALIAS := g_EMPTY_VARCHAR2;
		p_ROLLUP_DESC := g_EMPTY_VARCHAR2;
		p_ROLLUP_CATEGORY := g_EMPTY_VARCHAR2;
		p_ROLLUP_LEVEL := g_EMPTY_NUMBER;
		p_ROLLUP_PARENT_ID := g_EMPTY_NUMBER;
		p_ROLLUP_CHILDREN := g_EMPTY_NUMBER;

END GET_ROLLUP;
---------------------------------------------------------------------
PROCEDURE PUT_SC
	(
	o_OID OUT NUMBER,
	p_SC_NAME IN VARCHAR2,
	p_SC_ALIAS IN VARCHAR2,
	p_SC_DESC IN VARCHAR2,
	p_SC_ID IN NUMBER,
	p_SC_NERC_CODE IN VARCHAR2,
	p_SC_DUNS_NUMBER IN VARCHAR2,
	p_SC_STATUS IN VARCHAR2,
	p_SC_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_SC_SCHEDULE_NAME_PREFIX IN VARCHAR2,
	p_SC_SCHEDULE_FORMAT IN VARCHAR2,
	p_SC_SCHEDULE_INTERVAL IN VARCHAR2,
	p_SC_LOAD_ROUNDING_PREFERENCE IN VARCHAR2,
	p_SC_LOSS_ROUNDING_PREFERENCE IN VARCHAR2,
	p_SC_CREATE_TX_LOSS_SCHEDULE IN NUMBER,
	p_SC_CREATE_DX_LOSS_SCHEDULE IN NUMBER,
	p_SC_CREATE_UFE_SCHEDULE IN NUMBER,
	p_SC_MARKET_PRICE_ID IN NUMBER,
	p_SC_MINIMUM_SCHEDULE_AMT IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC SCHEDULE_COORDINATOR%ROWTYPE;
BEGIN


	v_REC.SC_ID := p_SC_ID;
	v_REC.SC_NAME := TRIM(p_SC_NAME);
	v_REC.SC_ALIAS := TRIM(NVL(p_SC_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SC_DESC := TRIM(NVL(p_SC_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SC_NERC_CODE := TRIM(NVL(p_SC_NERC_CODE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SC_DUNS_NUMBER := TRIM(NVL(p_SC_DUNS_NUMBER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SC_STATUS := TRIM(NVL(p_SC_STATUS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SC_EXTERNAL_IDENTIFIER := TRIM(NVL(p_SC_EXTERNAL_IDENTIFIER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SC_SCHEDULE_NAME_PREFIX := TRIM(NVL(p_SC_SCHEDULE_NAME_PREFIX,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SC_SCHEDULE_FORMAT := TRIM(NVL(p_SC_SCHEDULE_FORMAT,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SC_SCHEDULE_INTERVAL := TRIM(NVL(p_SC_SCHEDULE_INTERVAL,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SC_LOAD_ROUNDING_PREFERENCE := TRIM(NVL(p_SC_LOAD_ROUNDING_PREFERENCE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SC_LOSS_ROUNDING_PREFERENCE := TRIM(NVL(p_SC_LOSS_ROUNDING_PREFERENCE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SC_CREATE_TX_LOSS_SCHEDULE := p_SC_CREATE_TX_LOSS_SCHEDULE;
	v_REC.SC_CREATE_DX_LOSS_SCHEDULE := p_SC_CREATE_DX_LOSS_SCHEDULE;
	v_REC.SC_CREATE_UFE_SCHEDULE := p_SC_CREATE_UFE_SCHEDULE;
	v_REC.SC_MARKET_PRICE_ID := NVL(p_SC_MARKET_PRICE_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.SC_MINIMUM_SCHEDULE_AMT := p_SC_MINIMUM_SCHEDULE_AMT;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_SC_ID > 0 OR p_SC_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_SC_ID, EC.ED_SC) 
                 AND IO_UTIL.SC_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_SC, p_SC_ID);
		END IF;

		-- save it!
		UPDATE SCHEDULE_COORDINATOR
		SET ROW = v_REC
		WHERE SC_ID = p_SC_ID;
		o_OID := p_SC_ID;
        
	ELSIF p_SC_ID IS NULL OR p_SC_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.SC_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_SC, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.SC_ID := o_OID;
		-- save it!
		INSERT INTO SCHEDULE_COORDINATOR VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_SC_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_SC, EC.ED_ENTITY_DOMAIN)||': '||p_SC_NAME);
END PUT_SC;
---------------------------------------------------------------------
PROCEDURE GET_SC
	(
	p_SC_ID IN NUMBER,
	p_SC_NAME OUT VARCHAR2,
	p_SC_ALIAS OUT VARCHAR2,
	p_SC_DESC OUT VARCHAR2,
	p_SC_NERC_CODE OUT VARCHAR2,
	p_SC_DUNS_NUMBER OUT VARCHAR2,
	p_SC_STATUS OUT VARCHAR2,
	p_SC_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_SC_SCHEDULE_NAME_PREFIX OUT VARCHAR2,
	p_SC_SCHEDULE_FORMAT OUT VARCHAR2,
	p_SC_SCHEDULE_INTERVAL OUT VARCHAR2,
	p_SC_LOAD_ROUNDING_PREFERENCE OUT VARCHAR2,
	p_SC_LOSS_ROUNDING_PREFERENCE OUT VARCHAR2,
	p_SC_CREATE_TX_LOSS_SCHEDULE OUT NUMBER,
	p_SC_CREATE_DX_LOSS_SCHEDULE OUT NUMBER,
	p_SC_CREATE_UFE_SCHEDULE OUT NUMBER,
	p_SC_MARKET_PRICE_ID OUT NUMBER,
	p_SC_MINIMUM_SCHEDULE_AMT OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD SCHEDULE_COORDINATOR%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_SC_ID, EC.ED_SC);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM SCHEDULE_COORDINATOR
	WHERE SC_ID = p_SC_ID;
    
	-- Set the output parameters
	p_SC_NAME := v_RECORD.SC_NAME;
	p_SC_ALIAS := v_RECORD.SC_ALIAS;
	p_SC_DESC := v_RECORD.SC_DESC;
	p_SC_NERC_CODE := v_RECORD.SC_NERC_CODE;
	p_SC_DUNS_NUMBER := v_RECORD.SC_DUNS_NUMBER;
	p_SC_STATUS := v_RECORD.SC_STATUS;
	p_SC_EXTERNAL_IDENTIFIER := v_RECORD.SC_EXTERNAL_IDENTIFIER;
	p_SC_SCHEDULE_NAME_PREFIX := v_RECORD.SC_SCHEDULE_NAME_PREFIX;
	p_SC_SCHEDULE_FORMAT := v_RECORD.SC_SCHEDULE_FORMAT;
	p_SC_SCHEDULE_INTERVAL := v_RECORD.SC_SCHEDULE_INTERVAL;
	p_SC_LOAD_ROUNDING_PREFERENCE := v_RECORD.SC_LOAD_ROUNDING_PREFERENCE;
	p_SC_LOSS_ROUNDING_PREFERENCE := v_RECORD.SC_LOSS_ROUNDING_PREFERENCE;
	p_SC_CREATE_TX_LOSS_SCHEDULE := v_RECORD.SC_CREATE_TX_LOSS_SCHEDULE;
	p_SC_CREATE_DX_LOSS_SCHEDULE := v_RECORD.SC_CREATE_DX_LOSS_SCHEDULE;
	p_SC_CREATE_UFE_SCHEDULE := v_RECORD.SC_CREATE_UFE_SCHEDULE;
	p_SC_MARKET_PRICE_ID := v_RECORD.SC_MARKET_PRICE_ID;
	p_SC_MINIMUM_SCHEDULE_AMT := v_RECORD.SC_MINIMUM_SCHEDULE_AMT;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_SC_NAME := g_EMPTY_VARCHAR2;
		p_SC_ALIAS := g_EMPTY_VARCHAR2;
		p_SC_DESC := g_EMPTY_VARCHAR2;
		p_SC_NERC_CODE := g_EMPTY_VARCHAR2;
		p_SC_DUNS_NUMBER := g_EMPTY_VARCHAR2;
		p_SC_STATUS := g_EMPTY_VARCHAR2;
		p_SC_EXTERNAL_IDENTIFIER := g_EMPTY_VARCHAR2;
		p_SC_SCHEDULE_NAME_PREFIX := g_EMPTY_VARCHAR2;
		p_SC_SCHEDULE_FORMAT := g_EMPTY_VARCHAR2;
		p_SC_SCHEDULE_INTERVAL := g_EMPTY_VARCHAR2;
		p_SC_LOAD_ROUNDING_PREFERENCE := g_EMPTY_VARCHAR2;
		p_SC_LOSS_ROUNDING_PREFERENCE := g_EMPTY_VARCHAR2;
		p_SC_CREATE_TX_LOSS_SCHEDULE := g_EMPTY_NUMBER;
		p_SC_CREATE_DX_LOSS_SCHEDULE := g_EMPTY_NUMBER;
		p_SC_CREATE_UFE_SCHEDULE := g_EMPTY_NUMBER;
		p_SC_MARKET_PRICE_ID := g_EMPTY_NUMBER;
		p_SC_MINIMUM_SCHEDULE_AMT := g_EMPTY_NUMBER;

END GET_SC;
---------------------------------------------------------------------
PROCEDURE PUT_SCENARIO
	(
	o_OID OUT NUMBER,
	p_SCENARIO_NAME IN VARCHAR2,
	p_SCENARIO_ALIAS IN VARCHAR2,
	p_SCENARIO_DESC IN VARCHAR2,
	p_SCENARIO_ID IN NUMBER,
	p_SCENARIO_CATEGORY IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC SCENARIO%ROWTYPE;
BEGIN


	v_REC.SCENARIO_ID := p_SCENARIO_ID;
	v_REC.SCENARIO_NAME := TRIM(p_SCENARIO_NAME);
	v_REC.SCENARIO_ALIAS := TRIM(NVL(p_SCENARIO_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SCENARIO_DESC := TRIM(NVL(p_SCENARIO_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SCENARIO_CATEGORY := TRIM(NVL(p_SCENARIO_CATEGORY,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_SCENARIO_ID > 0 OR p_SCENARIO_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_SCENARIO_ID, EC.ED_SCENARIO) 
                 AND IO_UTIL.SCENARIO_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_SCENARIO, p_SCENARIO_ID);
		END IF;

		-- save it!
		UPDATE SCENARIO
		SET ROW = v_REC
		WHERE SCENARIO_ID = p_SCENARIO_ID;
		o_OID := p_SCENARIO_ID;
        
	ELSIF p_SCENARIO_ID IS NULL OR p_SCENARIO_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.SCENARIO_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_SCENARIO, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.SCENARIO_ID := o_OID;
		-- save it!
		INSERT INTO SCENARIO VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_SCENARIO_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_SCENARIO, EC.ED_ENTITY_DOMAIN)||': '||p_SCENARIO_NAME);
END PUT_SCENARIO;
---------------------------------------------------------------------
PROCEDURE GET_SCENARIO
	(
	p_SCENARIO_ID IN NUMBER,
	p_SCENARIO_NAME OUT VARCHAR2,
	p_SCENARIO_ALIAS OUT VARCHAR2,
	p_SCENARIO_DESC OUT VARCHAR2,
	p_SCENARIO_CATEGORY OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD SCENARIO%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_SCENARIO_ID, EC.ED_SCENARIO);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM SCENARIO
	WHERE SCENARIO_ID = p_SCENARIO_ID;
    
	-- Set the output parameters
	p_SCENARIO_NAME := v_RECORD.SCENARIO_NAME;
	p_SCENARIO_ALIAS := v_RECORD.SCENARIO_ALIAS;
	p_SCENARIO_DESC := v_RECORD.SCENARIO_DESC;
	p_SCENARIO_CATEGORY := v_RECORD.SCENARIO_CATEGORY;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_SCENARIO_NAME := g_EMPTY_VARCHAR2;
		p_SCENARIO_ALIAS := g_EMPTY_VARCHAR2;
		p_SCENARIO_DESC := g_EMPTY_VARCHAR2;
		p_SCENARIO_CATEGORY := g_EMPTY_VARCHAR2;

END GET_SCENARIO;
---------------------------------------------------------------------
PROCEDURE PUT_SCHEDULE_GROUP
	(
	o_OID OUT NUMBER,
	p_SCHEDULE_GROUP_NAME IN VARCHAR2,
	p_SCHEDULE_GROUP_ALIAS IN VARCHAR2,
	p_SCHEDULE_GROUP_DESC IN VARCHAR2,
	p_SCHEDULE_GROUP_ID IN NUMBER,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_SC_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_METER_TYPE IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC SCHEDULE_GROUP%ROWTYPE;
BEGIN


	v_REC.SCHEDULE_GROUP_ID := p_SCHEDULE_GROUP_ID;
	v_REC.SCHEDULE_GROUP_NAME := TRIM(p_SCHEDULE_GROUP_NAME);
	v_REC.SCHEDULE_GROUP_ALIAS := TRIM(NVL(p_SCHEDULE_GROUP_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SCHEDULE_GROUP_DESC := TRIM(NVL(p_SCHEDULE_GROUP_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SERVICE_ZONE_ID := NVL(p_SERVICE_ZONE_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.SC_ID := NVL(p_SC_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.SERVICE_POINT_ID := NVL(p_SERVICE_POINT_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.METER_TYPE := TRIM(NVL(p_METER_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_SCHEDULE_GROUP_ID > 0 OR p_SCHEDULE_GROUP_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_SCHEDULE_GROUP_ID, EC.ED_SCHEDULE_GROUP) 
                 AND IO_UTIL.SCHEDULE_GROUP_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_SCHEDULE_GROUP, p_SCHEDULE_GROUP_ID);
		END IF;

		-- save it!
		UPDATE SCHEDULE_GROUP
		SET ROW = v_REC
		WHERE SCHEDULE_GROUP_ID = p_SCHEDULE_GROUP_ID;
		o_OID := p_SCHEDULE_GROUP_ID;
        
	ELSIF p_SCHEDULE_GROUP_ID IS NULL OR p_SCHEDULE_GROUP_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.SCHEDULE_GROUP_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_SCHEDULE_GROUP, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.SCHEDULE_GROUP_ID := o_OID;
		-- save it!
		INSERT INTO SCHEDULE_GROUP VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_SCHEDULE_GROUP_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_SCHEDULE_GROUP, EC.ED_ENTITY_DOMAIN)||': '||p_SCHEDULE_GROUP_NAME);
END PUT_SCHEDULE_GROUP;
---------------------------------------------------------------------
PROCEDURE GET_SCHEDULE_GROUP
	(
	p_SCHEDULE_GROUP_ID IN NUMBER,
	p_SCHEDULE_GROUP_NAME OUT VARCHAR2,
	p_SCHEDULE_GROUP_ALIAS OUT VARCHAR2,
	p_SCHEDULE_GROUP_DESC OUT VARCHAR2,
	p_SERVICE_ZONE_ID OUT NUMBER,
	p_SC_ID OUT NUMBER,
	p_SERVICE_POINT_ID OUT NUMBER,
	p_METER_TYPE OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD SCHEDULE_GROUP%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_SCHEDULE_GROUP_ID, EC.ED_SCHEDULE_GROUP);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM SCHEDULE_GROUP
	WHERE SCHEDULE_GROUP_ID = p_SCHEDULE_GROUP_ID;
    
	-- Set the output parameters
	p_SCHEDULE_GROUP_NAME := v_RECORD.SCHEDULE_GROUP_NAME;
	p_SCHEDULE_GROUP_ALIAS := v_RECORD.SCHEDULE_GROUP_ALIAS;
	p_SCHEDULE_GROUP_DESC := v_RECORD.SCHEDULE_GROUP_DESC;
	p_SERVICE_ZONE_ID := v_RECORD.SERVICE_ZONE_ID;
	p_SC_ID := v_RECORD.SC_ID;
	p_SERVICE_POINT_ID := v_RECORD.SERVICE_POINT_ID;
	p_METER_TYPE := v_RECORD.METER_TYPE;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_SCHEDULE_GROUP_NAME := g_EMPTY_VARCHAR2;
		p_SCHEDULE_GROUP_ALIAS := g_EMPTY_VARCHAR2;
		p_SCHEDULE_GROUP_DESC := g_EMPTY_VARCHAR2;
		p_SERVICE_ZONE_ID := g_EMPTY_NUMBER;
		p_SC_ID := g_EMPTY_NUMBER;
		p_SERVICE_POINT_ID := g_EMPTY_NUMBER;
		p_METER_TYPE := g_EMPTY_VARCHAR2;

END GET_SCHEDULE_GROUP;
---------------------------------------------------------------------
PROCEDURE PUT_SEASON
	(
	o_OID OUT NUMBER,
	p_SEASON_NAME IN VARCHAR2,
	p_SEASON_ALIAS IN VARCHAR2,
	p_SEASON_DESC IN VARCHAR2,
	p_SEASON_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC SEASON%ROWTYPE;
BEGIN


	v_REC.SEASON_ID := p_SEASON_ID;
	v_REC.SEASON_NAME := TRIM(p_SEASON_NAME);
	v_REC.SEASON_ALIAS := TRIM(NVL(p_SEASON_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SEASON_DESC := TRIM(NVL(p_SEASON_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.BEGIN_DATE := p_BEGIN_DATE;
	v_REC.END_DATE := p_END_DATE;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_SEASON_ID > 0 OR p_SEASON_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_SEASON_ID, EC.ED_SEASON) 
                 AND IO_UTIL.SEASON_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_SEASON, p_SEASON_ID);
		END IF;

		-- save it!
		UPDATE SEASON
		SET ROW = v_REC
		WHERE SEASON_ID = p_SEASON_ID;
		o_OID := p_SEASON_ID;
        
	ELSIF p_SEASON_ID IS NULL OR p_SEASON_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.SEASON_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_SEASON, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.SEASON_ID := o_OID;
		-- save it!
		INSERT INTO SEASON VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_SEASON_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_SEASON, EC.ED_ENTITY_DOMAIN)||': '||p_SEASON_NAME);
END PUT_SEASON;
---------------------------------------------------------------------
PROCEDURE GET_SEASON
	(
	p_SEASON_ID IN NUMBER,
	p_SEASON_NAME OUT VARCHAR2,
	p_SEASON_ALIAS OUT VARCHAR2,
	p_SEASON_DESC OUT VARCHAR2,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD SEASON%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_SEASON_ID, EC.ED_SEASON);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM SEASON
	WHERE SEASON_ID = p_SEASON_ID;
    
	-- Set the output parameters
	p_SEASON_NAME := v_RECORD.SEASON_NAME;
	p_SEASON_ALIAS := v_RECORD.SEASON_ALIAS;
	p_SEASON_DESC := v_RECORD.SEASON_DESC;
	p_BEGIN_DATE := v_RECORD.BEGIN_DATE;
	p_END_DATE := v_RECORD.END_DATE;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_SEASON_NAME := g_EMPTY_VARCHAR2;
		p_SEASON_ALIAS := g_EMPTY_VARCHAR2;
		p_SEASON_DESC := g_EMPTY_VARCHAR2;
		p_BEGIN_DATE := g_EMPTY_DATE;
		p_END_DATE := g_EMPTY_DATE;

END GET_SEASON;
---------------------------------------------------------------------
PROCEDURE PUT_SEGMENT
	(
	o_OID OUT NUMBER,
	p_SEGMENT_NAME IN VARCHAR2,
	p_SEGMENT_ALIAS IN VARCHAR2,
	p_SEGMENT_DESC IN VARCHAR2,
	p_SEGMENT_ID IN NUMBER,
	p_POR_ID IN NUMBER,
	p_POD_ID IN NUMBER,
	p_MW_LIMIT_1 IN VARCHAR2,
	p_MW_LIMIT_2 IN VARCHAR2,
	p_MW_LIMIT_3 IN VARCHAR2,
	p_LOSS_FACTOR IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC TX_SEGMENT%ROWTYPE;
BEGIN


	v_REC.SEGMENT_ID := p_SEGMENT_ID;
	v_REC.SEGMENT_NAME := TRIM(p_SEGMENT_NAME);
	v_REC.SEGMENT_ALIAS := TRIM(NVL(p_SEGMENT_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SEGMENT_DESC := TRIM(NVL(p_SEGMENT_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.POR_ID := NVL(p_POR_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.POD_ID := NVL(p_POD_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.MW_LIMIT_1 := TRIM(NVL(p_MW_LIMIT_1,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.MW_LIMIT_2 := TRIM(NVL(p_MW_LIMIT_2,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.MW_LIMIT_3 := TRIM(NVL(p_MW_LIMIT_3,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.LOSS_FACTOR := p_LOSS_FACTOR;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_SEGMENT_ID > 0 OR p_SEGMENT_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_SEGMENT_ID, EC.ED_SEGMENT) 
                 AND IO_UTIL.SEGMENT_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_SEGMENT, p_SEGMENT_ID);
		END IF;

		-- save it!
		UPDATE TX_SEGMENT
		SET ROW = v_REC
		WHERE SEGMENT_ID = p_SEGMENT_ID;
		o_OID := p_SEGMENT_ID;
        
	ELSIF p_SEGMENT_ID IS NULL OR p_SEGMENT_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.SEGMENT_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_SEGMENT, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.SEGMENT_ID := o_OID;
		-- save it!
		INSERT INTO TX_SEGMENT VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_SEGMENT_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_SEGMENT, EC.ED_ENTITY_DOMAIN)||': '||p_SEGMENT_NAME);
END PUT_SEGMENT;
---------------------------------------------------------------------
PROCEDURE GET_SEGMENT
	(
	p_SEGMENT_ID IN NUMBER,
	p_SEGMENT_NAME OUT VARCHAR2,
	p_SEGMENT_ALIAS OUT VARCHAR2,
	p_SEGMENT_DESC OUT VARCHAR2,
	p_POR_ID OUT NUMBER,
	p_POD_ID OUT NUMBER,
	p_MW_LIMIT_1 OUT VARCHAR2,
	p_MW_LIMIT_2 OUT VARCHAR2,
	p_MW_LIMIT_3 OUT VARCHAR2,
	p_LOSS_FACTOR OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD TX_SEGMENT%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_SEGMENT_ID, EC.ED_SEGMENT);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM TX_SEGMENT
	WHERE SEGMENT_ID = p_SEGMENT_ID;
    
	-- Set the output parameters
	p_SEGMENT_NAME := v_RECORD.SEGMENT_NAME;
	p_SEGMENT_ALIAS := v_RECORD.SEGMENT_ALIAS;
	p_SEGMENT_DESC := v_RECORD.SEGMENT_DESC;
	p_POR_ID := v_RECORD.POR_ID;
	p_POD_ID := v_RECORD.POD_ID;
	p_MW_LIMIT_1 := v_RECORD.MW_LIMIT_1;
	p_MW_LIMIT_2 := v_RECORD.MW_LIMIT_2;
	p_MW_LIMIT_3 := v_RECORD.MW_LIMIT_3;
	p_LOSS_FACTOR := v_RECORD.LOSS_FACTOR;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_SEGMENT_NAME := g_EMPTY_VARCHAR2;
		p_SEGMENT_ALIAS := g_EMPTY_VARCHAR2;
		p_SEGMENT_DESC := g_EMPTY_VARCHAR2;
		p_POR_ID := g_EMPTY_NUMBER;
		p_POD_ID := g_EMPTY_NUMBER;
		p_MW_LIMIT_1 := g_EMPTY_VARCHAR2;
		p_MW_LIMIT_2 := g_EMPTY_VARCHAR2;
		p_MW_LIMIT_3 := g_EMPTY_VARCHAR2;
		p_LOSS_FACTOR := g_EMPTY_NUMBER;

END GET_SEGMENT;
---------------------------------------------------------------------
PROCEDURE PUT_SERVICE_AREA
	(
	o_OID OUT NUMBER,
	p_SERVICE_AREA_NAME IN VARCHAR2,
	p_SERVICE_AREA_ALIAS IN VARCHAR2,
	p_SERVICE_AREA_DESC IN VARCHAR2,
	p_SERVICE_AREA_ID IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC SERVICE_AREA%ROWTYPE;
BEGIN


	v_REC.SERVICE_AREA_ID := p_SERVICE_AREA_ID;
	v_REC.SERVICE_AREA_NAME := TRIM(p_SERVICE_AREA_NAME);
	v_REC.SERVICE_AREA_ALIAS := TRIM(NVL(p_SERVICE_AREA_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SERVICE_AREA_DESC := TRIM(NVL(p_SERVICE_AREA_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_SERVICE_AREA_ID > 0 OR p_SERVICE_AREA_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_SERVICE_AREA_ID, EC.ED_SERVICE_AREA) 
                 AND IO_UTIL.SERVICE_AREA_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_SERVICE_AREA, p_SERVICE_AREA_ID);
		END IF;

		-- save it!
		UPDATE SERVICE_AREA
		SET ROW = v_REC
		WHERE SERVICE_AREA_ID = p_SERVICE_AREA_ID;
		o_OID := p_SERVICE_AREA_ID;
        
	ELSIF p_SERVICE_AREA_ID IS NULL OR p_SERVICE_AREA_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.SERVICE_AREA_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_SERVICE_AREA, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.SERVICE_AREA_ID := o_OID;
		-- save it!
		INSERT INTO SERVICE_AREA VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_SERVICE_AREA_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_SERVICE_AREA, EC.ED_ENTITY_DOMAIN)||': '||p_SERVICE_AREA_NAME);
END PUT_SERVICE_AREA;
---------------------------------------------------------------------
PROCEDURE GET_SERVICE_AREA
	(
	p_SERVICE_AREA_ID IN NUMBER,
	p_SERVICE_AREA_NAME OUT VARCHAR2,
	p_SERVICE_AREA_ALIAS OUT VARCHAR2,
	p_SERVICE_AREA_DESC OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD SERVICE_AREA%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_SERVICE_AREA_ID, EC.ED_SERVICE_AREA);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM SERVICE_AREA
	WHERE SERVICE_AREA_ID = p_SERVICE_AREA_ID;
    
	-- Set the output parameters
	p_SERVICE_AREA_NAME := v_RECORD.SERVICE_AREA_NAME;
	p_SERVICE_AREA_ALIAS := v_RECORD.SERVICE_AREA_ALIAS;
	p_SERVICE_AREA_DESC := v_RECORD.SERVICE_AREA_DESC;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_SERVICE_AREA_NAME := g_EMPTY_VARCHAR2;
		p_SERVICE_AREA_ALIAS := g_EMPTY_VARCHAR2;
		p_SERVICE_AREA_DESC := g_EMPTY_VARCHAR2;

END GET_SERVICE_AREA;
---------------------------------------------------------------------
PROCEDURE PUT_SERVICE_LOCATION
	(
	o_OID OUT NUMBER,
	p_SERVICE_LOCATION_NAME IN VARCHAR2,
	p_SERVICE_LOCATION_ALIAS IN VARCHAR2,
	p_SERVICE_LOCATION_DESC IN VARCHAR2,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_LATITUDE IN VARCHAR2,
	p_LONGITUDE IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_IS_EXTERNAL_BILLED_USAGE IN NUMBER,
	p_IS_METER_ALLOCATION IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_WEATHER_STATION_ID IN NUMBER,
	p_BUSINESS_ROLLUP_ID IN NUMBER,
	p_GEOGRAPHIC_ROLLUP_ID IN NUMBER,
	p_SQUARE_FOOTAGE IN NUMBER,
	p_ANNUAL_CONSUMPTION IN NUMBER,
	p_SUMMER_CONSUMPTION IN NUMBER,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_SUB_STATION_ID IN NUMBER,
	p_FEEDER_ID IN NUMBER,
	p_FEEDER_SEGMENT_ID IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC SERVICE_LOCATION%ROWTYPE;
BEGIN

	IF GA.ENFORCE_UNIQUE_NAMES THEN

		SELECT COUNT(*)
		INTO v_COUNT
		FROM SERVICE_LOCATION
		WHERE SERVICE_LOCATION_NAME = TRIM(p_SERVICE_LOCATION_NAME)
			AND (p_SERVICE_LOCATION_ID = 0 OR SERVICE_LOCATION_ID <> p_SERVICE_LOCATION_ID);

		IF v_COUNT > 0 THEN
            -- raise exception that indicates the duplicate entity name
            ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_SERVICE_LOCATION, EC.ED_ENTITY_DOMAIN)||': '||p_SERVICE_LOCATION_NAME);
		END IF;
	
	END IF;


	v_REC.SERVICE_LOCATION_ID := p_SERVICE_LOCATION_ID;
	v_REC.SERVICE_LOCATION_NAME := TRIM(p_SERVICE_LOCATION_NAME);
	v_REC.SERVICE_LOCATION_ALIAS := TRIM(NVL(p_SERVICE_LOCATION_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SERVICE_LOCATION_DESC := TRIM(NVL(p_SERVICE_LOCATION_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.LATITUDE := TRIM(NVL(p_LATITUDE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.LONGITUDE := TRIM(NVL(p_LONGITUDE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.TIME_ZONE := TRIM(NVL(p_TIME_ZONE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EXTERNAL_IDENTIFIER := TRIM(NVL(p_EXTERNAL_IDENTIFIER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.IS_EXTERNAL_BILLED_USAGE := p_IS_EXTERNAL_BILLED_USAGE;
	v_REC.IS_METER_ALLOCATION := p_IS_METER_ALLOCATION;
	v_REC.SERVICE_POINT_ID := NVL(p_SERVICE_POINT_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.WEATHER_STATION_ID := NVL(p_WEATHER_STATION_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.BUSINESS_ROLLUP_ID := p_BUSINESS_ROLLUP_ID;
	v_REC.GEOGRAPHIC_ROLLUP_ID := p_GEOGRAPHIC_ROLLUP_ID;
	v_REC.SQUARE_FOOTAGE := p_SQUARE_FOOTAGE;
	v_REC.ANNUAL_CONSUMPTION := p_ANNUAL_CONSUMPTION;
	v_REC.SUMMER_CONSUMPTION := p_SUMMER_CONSUMPTION;
	v_REC.SERVICE_ZONE_ID := NVL(p_SERVICE_ZONE_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.SUB_STATION_ID := NVL(p_SUB_STATION_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.FEEDER_ID := NVL(p_FEEDER_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.FEEDER_SEGMENT_ID := NVL(p_FEEDER_SEGMENT_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_SERVICE_LOCATION_ID > 0 OR p_SERVICE_LOCATION_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_SERVICE_LOCATION_ID, EC.ED_SERVICE_LOCATION) 
                 AND IO_UTIL.SERVICE_LOCATION_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_SERVICE_LOCATION, p_SERVICE_LOCATION_ID);
		END IF;

		-- save it!
		UPDATE SERVICE_LOCATION
		SET ROW = v_REC
		WHERE SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID;
		o_OID := p_SERVICE_LOCATION_ID;
        
	ELSIF p_SERVICE_LOCATION_ID IS NULL OR p_SERVICE_LOCATION_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.SERVICE_LOCATION_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_SERVICE_LOCATION, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.SERVICE_LOCATION_ID := o_OID;
		-- save it!
		INSERT INTO SERVICE_LOCATION VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_SERVICE_LOCATION_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_SERVICE_LOCATION, EC.ED_ENTITY_DOMAIN)||': '||p_SERVICE_LOCATION_NAME);
END PUT_SERVICE_LOCATION;
---------------------------------------------------------------------
PROCEDURE GET_SERVICE_LOCATION
	(
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_SERVICE_LOCATION_NAME OUT VARCHAR2,
	p_SERVICE_LOCATION_ALIAS OUT VARCHAR2,
	p_SERVICE_LOCATION_DESC OUT VARCHAR2,
	p_LATITUDE OUT VARCHAR2,
	p_LONGITUDE OUT VARCHAR2,
	p_TIME_ZONE OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_IS_EXTERNAL_BILLED_USAGE OUT NUMBER,
	p_IS_METER_ALLOCATION OUT NUMBER,
	p_SERVICE_POINT_ID OUT NUMBER,
	p_WEATHER_STATION_ID OUT NUMBER,
	p_BUSINESS_ROLLUP_ID OUT NUMBER,
	p_GEOGRAPHIC_ROLLUP_ID OUT NUMBER,
	p_SQUARE_FOOTAGE OUT NUMBER,
	p_ANNUAL_CONSUMPTION OUT NUMBER,
	p_SUMMER_CONSUMPTION OUT NUMBER,
	p_SERVICE_ZONE_ID OUT NUMBER,
	p_SUB_STATION_ID OUT NUMBER,
	p_FEEDER_ID OUT NUMBER,
	p_FEEDER_SEGMENT_ID OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD SERVICE_LOCATION%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_SERVICE_LOCATION_ID, EC.ED_SERVICE_LOCATION);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM SERVICE_LOCATION
	WHERE SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID;
    
	-- Set the output parameters
	p_SERVICE_LOCATION_NAME := v_RECORD.SERVICE_LOCATION_NAME;
	p_SERVICE_LOCATION_ALIAS := v_RECORD.SERVICE_LOCATION_ALIAS;
	p_SERVICE_LOCATION_DESC := v_RECORD.SERVICE_LOCATION_DESC;
	p_LATITUDE := v_RECORD.LATITUDE;
	p_LONGITUDE := v_RECORD.LONGITUDE;
	p_TIME_ZONE := v_RECORD.TIME_ZONE;
	p_EXTERNAL_IDENTIFIER := v_RECORD.EXTERNAL_IDENTIFIER;
	p_IS_EXTERNAL_BILLED_USAGE := v_RECORD.IS_EXTERNAL_BILLED_USAGE;
	p_IS_METER_ALLOCATION := v_RECORD.IS_METER_ALLOCATION;
	p_SERVICE_POINT_ID := v_RECORD.SERVICE_POINT_ID;
	p_WEATHER_STATION_ID := v_RECORD.WEATHER_STATION_ID;
	p_BUSINESS_ROLLUP_ID := v_RECORD.BUSINESS_ROLLUP_ID;
	p_GEOGRAPHIC_ROLLUP_ID := v_RECORD.GEOGRAPHIC_ROLLUP_ID;
	p_SQUARE_FOOTAGE := v_RECORD.SQUARE_FOOTAGE;
	p_ANNUAL_CONSUMPTION := v_RECORD.ANNUAL_CONSUMPTION;
	p_SUMMER_CONSUMPTION := v_RECORD.SUMMER_CONSUMPTION;
	p_SERVICE_ZONE_ID := v_RECORD.SERVICE_ZONE_ID;
	p_SUB_STATION_ID := v_RECORD.SUB_STATION_ID;
	p_FEEDER_ID := v_RECORD.FEEDER_ID;
	p_FEEDER_SEGMENT_ID := v_RECORD.FEEDER_SEGMENT_ID;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_SERVICE_LOCATION_NAME := g_EMPTY_VARCHAR2;
		p_SERVICE_LOCATION_ALIAS := g_EMPTY_VARCHAR2;
		p_SERVICE_LOCATION_DESC := g_EMPTY_VARCHAR2;
		p_LATITUDE := g_EMPTY_VARCHAR2;
		p_LONGITUDE := g_EMPTY_VARCHAR2;
		p_TIME_ZONE := g_EMPTY_VARCHAR2;
		p_EXTERNAL_IDENTIFIER := g_EMPTY_VARCHAR2;
		p_IS_EXTERNAL_BILLED_USAGE := g_EMPTY_NUMBER;
		p_IS_METER_ALLOCATION := g_EMPTY_NUMBER;
		p_SERVICE_POINT_ID := g_EMPTY_NUMBER;
		p_WEATHER_STATION_ID := g_EMPTY_NUMBER;
		p_BUSINESS_ROLLUP_ID := g_EMPTY_NUMBER;
		p_GEOGRAPHIC_ROLLUP_ID := g_EMPTY_NUMBER;
		p_SQUARE_FOOTAGE := g_EMPTY_NUMBER;
		p_ANNUAL_CONSUMPTION := g_EMPTY_NUMBER;
		p_SUMMER_CONSUMPTION := g_EMPTY_NUMBER;
		p_SERVICE_ZONE_ID := g_EMPTY_NUMBER;
		p_SUB_STATION_ID := g_EMPTY_NUMBER;
		p_FEEDER_ID := g_EMPTY_NUMBER;
		p_FEEDER_SEGMENT_ID := g_EMPTY_NUMBER;

END GET_SERVICE_LOCATION;
---------------------------------------------------------------------
PROCEDURE PUT_SERVICE_POINT
	(
	o_OID OUT NUMBER,
	p_SERVICE_POINT_NAME IN VARCHAR2,
	p_SERVICE_POINT_ALIAS IN VARCHAR2,
	p_SERVICE_POINT_DESC IN VARCHAR2,
	p_SERVICE_POINT_ID IN NUMBER,
	p_SERVICE_POINT_TYPE IN VARCHAR2,
	p_TP_ID IN NUMBER,
	p_CA_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_ROLLUP_ID IN NUMBER,
	p_SERVICE_REGION_ID IN NUMBER,
	p_SERVICE_AREA_ID IN NUMBER,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_LATITUDE IN VARCHAR2,
	p_LONGITUDE IN VARCHAR2,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_IS_INTERCONNECT IN NUMBER,
	p_NODE_TYPE IN VARCHAR2,
	p_SERVICE_POINT_NERC_CODE IN VARCHAR2,
	p_PIPELINE_ID IN NUMBER,
	p_MILE_MARKER IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC SERVICE_POINT%ROWTYPE;
BEGIN


	v_REC.SERVICE_POINT_ID := p_SERVICE_POINT_ID;
	v_REC.SERVICE_POINT_NAME := TRIM(p_SERVICE_POINT_NAME);
	v_REC.SERVICE_POINT_ALIAS := TRIM(NVL(p_SERVICE_POINT_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SERVICE_POINT_DESC := TRIM(NVL(p_SERVICE_POINT_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SERVICE_POINT_TYPE := TRIM(NVL(p_SERVICE_POINT_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.TP_ID := NVL(p_TP_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.CA_ID := NVL(p_CA_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.EDC_ID := NVL(p_EDC_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.ROLLUP_ID := p_ROLLUP_ID;
	v_REC.SERVICE_REGION_ID := NVL(p_SERVICE_REGION_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.SERVICE_AREA_ID := NVL(p_SERVICE_AREA_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.SERVICE_ZONE_ID := NVL(p_SERVICE_ZONE_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.TIME_ZONE := TRIM(NVL(p_TIME_ZONE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.LATITUDE := TRIM(NVL(p_LATITUDE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.LONGITUDE := TRIM(NVL(p_LONGITUDE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EXTERNAL_IDENTIFIER := TRIM(NVL(p_EXTERNAL_IDENTIFIER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.IS_INTERCONNECT := p_IS_INTERCONNECT;
	v_REC.NODE_TYPE := TRIM(NVL(p_NODE_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SERVICE_POINT_NERC_CODE := TRIM(NVL(p_SERVICE_POINT_NERC_CODE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PIPELINE_ID := NVL(p_PIPELINE_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.MILE_MARKER := p_MILE_MARKER;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_SERVICE_POINT_ID > 0 OR p_SERVICE_POINT_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_SERVICE_POINT_ID, EC.ED_SERVICE_POINT) 
                 AND IO_UTIL.SERVICE_POINT_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_SERVICE_POINT, p_SERVICE_POINT_ID);
		END IF;

		-- save it!
		UPDATE SERVICE_POINT
		SET ROW = v_REC
		WHERE SERVICE_POINT_ID = p_SERVICE_POINT_ID;
		o_OID := p_SERVICE_POINT_ID;
        
	ELSIF p_SERVICE_POINT_ID IS NULL OR p_SERVICE_POINT_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.SERVICE_POINT_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_SERVICE_POINT, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.SERVICE_POINT_ID := o_OID;
		-- save it!
		INSERT INTO SERVICE_POINT VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_SERVICE_POINT_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_SERVICE_POINT, EC.ED_ENTITY_DOMAIN)||': '||p_SERVICE_POINT_NAME);
END PUT_SERVICE_POINT;
---------------------------------------------------------------------
PROCEDURE GET_SERVICE_POINT
	(
	p_SERVICE_POINT_ID IN NUMBER,
	p_SERVICE_POINT_NAME OUT VARCHAR2,
	p_SERVICE_POINT_ALIAS OUT VARCHAR2,
	p_SERVICE_POINT_DESC OUT VARCHAR2,
	p_SERVICE_POINT_TYPE OUT VARCHAR2,
	p_TP_ID OUT NUMBER,
	p_CA_ID OUT NUMBER,
	p_EDC_ID OUT NUMBER,
	p_ROLLUP_ID OUT NUMBER,
	p_SERVICE_REGION_ID OUT NUMBER,
	p_SERVICE_AREA_ID OUT NUMBER,
	p_SERVICE_ZONE_ID OUT NUMBER,
	p_TIME_ZONE OUT VARCHAR2,
	p_LATITUDE OUT VARCHAR2,
	p_LONGITUDE OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_IS_INTERCONNECT OUT NUMBER,
	p_NODE_TYPE OUT VARCHAR2,
	p_SERVICE_POINT_NERC_CODE OUT VARCHAR2,
	p_PIPELINE_ID OUT NUMBER,
	p_MILE_MARKER OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD SERVICE_POINT%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_SERVICE_POINT_ID, EC.ED_SERVICE_POINT);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM SERVICE_POINT
	WHERE SERVICE_POINT_ID = p_SERVICE_POINT_ID;
    
	-- Set the output parameters
	p_SERVICE_POINT_NAME := v_RECORD.SERVICE_POINT_NAME;
	p_SERVICE_POINT_ALIAS := v_RECORD.SERVICE_POINT_ALIAS;
	p_SERVICE_POINT_DESC := v_RECORD.SERVICE_POINT_DESC;
	p_SERVICE_POINT_TYPE := v_RECORD.SERVICE_POINT_TYPE;
	p_TP_ID := v_RECORD.TP_ID;
	p_CA_ID := v_RECORD.CA_ID;
	p_EDC_ID := v_RECORD.EDC_ID;
	p_ROLLUP_ID := v_RECORD.ROLLUP_ID;
	p_SERVICE_REGION_ID := v_RECORD.SERVICE_REGION_ID;
	p_SERVICE_AREA_ID := v_RECORD.SERVICE_AREA_ID;
	p_SERVICE_ZONE_ID := v_RECORD.SERVICE_ZONE_ID;
	p_TIME_ZONE := v_RECORD.TIME_ZONE;
	p_LATITUDE := v_RECORD.LATITUDE;
	p_LONGITUDE := v_RECORD.LONGITUDE;
	p_EXTERNAL_IDENTIFIER := v_RECORD.EXTERNAL_IDENTIFIER;
	p_IS_INTERCONNECT := v_RECORD.IS_INTERCONNECT;
	p_NODE_TYPE := v_RECORD.NODE_TYPE;
	p_SERVICE_POINT_NERC_CODE := v_RECORD.SERVICE_POINT_NERC_CODE;
	p_PIPELINE_ID := v_RECORD.PIPELINE_ID;
	p_MILE_MARKER := v_RECORD.MILE_MARKER;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_SERVICE_POINT_NAME := g_EMPTY_VARCHAR2;
		p_SERVICE_POINT_ALIAS := g_EMPTY_VARCHAR2;
		p_SERVICE_POINT_DESC := g_EMPTY_VARCHAR2;
		p_SERVICE_POINT_TYPE := g_EMPTY_VARCHAR2;
		p_TP_ID := g_EMPTY_NUMBER;
		p_CA_ID := g_EMPTY_NUMBER;
		p_EDC_ID := g_EMPTY_NUMBER;
		p_ROLLUP_ID := g_EMPTY_NUMBER;
		p_SERVICE_REGION_ID := g_EMPTY_NUMBER;
		p_SERVICE_AREA_ID := g_EMPTY_NUMBER;
		p_SERVICE_ZONE_ID := g_EMPTY_NUMBER;
		p_TIME_ZONE := g_EMPTY_VARCHAR2;
		p_LATITUDE := g_EMPTY_VARCHAR2;
		p_LONGITUDE := g_EMPTY_VARCHAR2;
		p_EXTERNAL_IDENTIFIER := g_EMPTY_VARCHAR2;
		p_IS_INTERCONNECT := g_EMPTY_NUMBER;
		p_NODE_TYPE := g_EMPTY_VARCHAR2;
		p_SERVICE_POINT_NERC_CODE := g_EMPTY_VARCHAR2;
		p_PIPELINE_ID := g_EMPTY_NUMBER;
		p_MILE_MARKER := g_EMPTY_NUMBER;

END GET_SERVICE_POINT;
---------------------------------------------------------------------
PROCEDURE PUT_SERVICE_REGION
	(
	o_OID OUT NUMBER,
	p_SERVICE_REGION_NAME IN VARCHAR2,
	p_SERVICE_REGION_ALIAS IN VARCHAR2,
	p_SERVICE_REGION_DESC IN VARCHAR2,
	p_SERVICE_REGION_ID IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC SERVICE_REGION%ROWTYPE;
BEGIN


	v_REC.SERVICE_REGION_ID := p_SERVICE_REGION_ID;
	v_REC.SERVICE_REGION_NAME := TRIM(p_SERVICE_REGION_NAME);
	v_REC.SERVICE_REGION_ALIAS := TRIM(NVL(p_SERVICE_REGION_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SERVICE_REGION_DESC := TRIM(NVL(p_SERVICE_REGION_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_SERVICE_REGION_ID > 0 OR p_SERVICE_REGION_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_SERVICE_REGION_ID, EC.ED_SERVICE_REGION) 
                 AND IO_UTIL.SERVICE_REGION_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_SERVICE_REGION, p_SERVICE_REGION_ID);
		END IF;

		-- save it!
		UPDATE SERVICE_REGION
		SET ROW = v_REC
		WHERE SERVICE_REGION_ID = p_SERVICE_REGION_ID;
		o_OID := p_SERVICE_REGION_ID;
        
	ELSIF p_SERVICE_REGION_ID IS NULL OR p_SERVICE_REGION_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.SERVICE_REGION_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_SERVICE_REGION, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.SERVICE_REGION_ID := o_OID;
		-- save it!
		INSERT INTO SERVICE_REGION VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_SERVICE_REGION_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_SERVICE_REGION, EC.ED_ENTITY_DOMAIN)||': '||p_SERVICE_REGION_NAME);
END PUT_SERVICE_REGION;
---------------------------------------------------------------------
PROCEDURE GET_SERVICE_REGION
	(
	p_SERVICE_REGION_ID IN NUMBER,
	p_SERVICE_REGION_NAME OUT VARCHAR2,
	p_SERVICE_REGION_ALIAS OUT VARCHAR2,
	p_SERVICE_REGION_DESC OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD SERVICE_REGION%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_SERVICE_REGION_ID, EC.ED_SERVICE_REGION);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM SERVICE_REGION
	WHERE SERVICE_REGION_ID = p_SERVICE_REGION_ID;
    
	-- Set the output parameters
	p_SERVICE_REGION_NAME := v_RECORD.SERVICE_REGION_NAME;
	p_SERVICE_REGION_ALIAS := v_RECORD.SERVICE_REGION_ALIAS;
	p_SERVICE_REGION_DESC := v_RECORD.SERVICE_REGION_DESC;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_SERVICE_REGION_NAME := g_EMPTY_VARCHAR2;
		p_SERVICE_REGION_ALIAS := g_EMPTY_VARCHAR2;
		p_SERVICE_REGION_DESC := g_EMPTY_VARCHAR2;

END GET_SERVICE_REGION;
---------------------------------------------------------------------
PROCEDURE PUT_SERVICE_TYPE
	(
	o_OID OUT NUMBER,
	p_SERVICE_TYPE_NAME IN VARCHAR2,
	p_SERVICE_TYPE_ALIAS IN VARCHAR2,
	p_SERVICE_TYPE_DESC IN VARCHAR2,
	p_SERVICE_TYPE_ID IN NUMBER,
	p_SERVICE_TYPE_CATEGORY IN VARCHAR2,
	p_IS_FIRM IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC TX_SERVICE_TYPE%ROWTYPE;
BEGIN


	v_REC.SERVICE_TYPE_ID := p_SERVICE_TYPE_ID;
	v_REC.SERVICE_TYPE_NAME := TRIM(p_SERVICE_TYPE_NAME);
	v_REC.SERVICE_TYPE_ALIAS := TRIM(NVL(p_SERVICE_TYPE_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SERVICE_TYPE_DESC := TRIM(NVL(p_SERVICE_TYPE_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SERVICE_TYPE_CATEGORY := TRIM(NVL(p_SERVICE_TYPE_CATEGORY,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.IS_FIRM := p_IS_FIRM;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_SERVICE_TYPE_ID > 0 OR p_SERVICE_TYPE_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_SERVICE_TYPE_ID, EC.ED_SERVICE_TYPE) 
                 AND IO_UTIL.SERVICE_TYPE_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_SERVICE_TYPE, p_SERVICE_TYPE_ID);
		END IF;

		-- save it!
		UPDATE TX_SERVICE_TYPE
		SET ROW = v_REC
		WHERE SERVICE_TYPE_ID = p_SERVICE_TYPE_ID;
		o_OID := p_SERVICE_TYPE_ID;
        
	ELSIF p_SERVICE_TYPE_ID IS NULL OR p_SERVICE_TYPE_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.SERVICE_TYPE_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_SERVICE_TYPE, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.SERVICE_TYPE_ID := o_OID;
		-- save it!
		INSERT INTO TX_SERVICE_TYPE VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_SERVICE_TYPE_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_SERVICE_TYPE, EC.ED_ENTITY_DOMAIN)||': '||p_SERVICE_TYPE_NAME);
END PUT_SERVICE_TYPE;
---------------------------------------------------------------------
PROCEDURE GET_SERVICE_TYPE
	(
	p_SERVICE_TYPE_ID IN NUMBER,
	p_SERVICE_TYPE_NAME OUT VARCHAR2,
	p_SERVICE_TYPE_ALIAS OUT VARCHAR2,
	p_SERVICE_TYPE_DESC OUT VARCHAR2,
	p_SERVICE_TYPE_CATEGORY OUT VARCHAR2,
	p_IS_FIRM OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD TX_SERVICE_TYPE%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_SERVICE_TYPE_ID, EC.ED_SERVICE_TYPE);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM TX_SERVICE_TYPE
	WHERE SERVICE_TYPE_ID = p_SERVICE_TYPE_ID;
    
	-- Set the output parameters
	p_SERVICE_TYPE_NAME := v_RECORD.SERVICE_TYPE_NAME;
	p_SERVICE_TYPE_ALIAS := v_RECORD.SERVICE_TYPE_ALIAS;
	p_SERVICE_TYPE_DESC := v_RECORD.SERVICE_TYPE_DESC;
	p_SERVICE_TYPE_CATEGORY := v_RECORD.SERVICE_TYPE_CATEGORY;
	p_IS_FIRM := v_RECORD.IS_FIRM;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_SERVICE_TYPE_NAME := g_EMPTY_VARCHAR2;
		p_SERVICE_TYPE_ALIAS := g_EMPTY_VARCHAR2;
		p_SERVICE_TYPE_DESC := g_EMPTY_VARCHAR2;
		p_SERVICE_TYPE_CATEGORY := g_EMPTY_VARCHAR2;
		p_IS_FIRM := g_EMPTY_NUMBER;

END GET_SERVICE_TYPE;
---------------------------------------------------------------------
PROCEDURE PUT_SERVICE_ZONE
	(
	o_OID OUT NUMBER,
	p_SERVICE_ZONE_NAME IN VARCHAR2,
	p_SERVICE_ZONE_ALIAS IN VARCHAR2,
	p_SERVICE_ZONE_DESC IN VARCHAR2,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_MARKET_PRICE_ID IN NUMBER,
	p_CONTROL_AREA_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC SERVICE_ZONE%ROWTYPE;
BEGIN


	v_REC.SERVICE_ZONE_ID := p_SERVICE_ZONE_ID;
	v_REC.SERVICE_ZONE_NAME := TRIM(p_SERVICE_ZONE_NAME);
	v_REC.SERVICE_ZONE_ALIAS := TRIM(NVL(p_SERVICE_ZONE_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SERVICE_ZONE_DESC := TRIM(NVL(p_SERVICE_ZONE_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EXTERNAL_IDENTIFIER := TRIM(NVL(p_EXTERNAL_IDENTIFIER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.MARKET_PRICE_ID := NVL(p_MARKET_PRICE_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.CONTROL_AREA_ID := NVL(p_CONTROL_AREA_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.TIME_ZONE := TRIM(NVL(p_TIME_ZONE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_SERVICE_ZONE_ID > 0 OR p_SERVICE_ZONE_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_SERVICE_ZONE_ID, EC.ED_SERVICE_ZONE) 
                 AND IO_UTIL.SERVICE_ZONE_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_SERVICE_ZONE, p_SERVICE_ZONE_ID);
		END IF;

		-- save it!
		UPDATE SERVICE_ZONE
		SET ROW = v_REC
		WHERE SERVICE_ZONE_ID = p_SERVICE_ZONE_ID;
		o_OID := p_SERVICE_ZONE_ID;
        
	ELSIF p_SERVICE_ZONE_ID IS NULL OR p_SERVICE_ZONE_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.SERVICE_ZONE_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_SERVICE_ZONE, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.SERVICE_ZONE_ID := o_OID;
		-- save it!
		INSERT INTO SERVICE_ZONE VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_SERVICE_ZONE_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_SERVICE_ZONE, EC.ED_ENTITY_DOMAIN)||': '||p_SERVICE_ZONE_NAME);
END PUT_SERVICE_ZONE;
---------------------------------------------------------------------
PROCEDURE GET_SERVICE_ZONE
	(
	p_SERVICE_ZONE_ID IN NUMBER,
	p_SERVICE_ZONE_NAME OUT VARCHAR2,
	p_SERVICE_ZONE_ALIAS OUT VARCHAR2,
	p_SERVICE_ZONE_DESC OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_MARKET_PRICE_ID OUT NUMBER,
	p_CONTROL_AREA_ID OUT NUMBER,
	p_TIME_ZONE OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD SERVICE_ZONE%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_SERVICE_ZONE_ID, EC.ED_SERVICE_ZONE);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM SERVICE_ZONE
	WHERE SERVICE_ZONE_ID = p_SERVICE_ZONE_ID;
    
	-- Set the output parameters
	p_SERVICE_ZONE_NAME := v_RECORD.SERVICE_ZONE_NAME;
	p_SERVICE_ZONE_ALIAS := v_RECORD.SERVICE_ZONE_ALIAS;
	p_SERVICE_ZONE_DESC := v_RECORD.SERVICE_ZONE_DESC;
	p_EXTERNAL_IDENTIFIER := v_RECORD.EXTERNAL_IDENTIFIER;
	p_MARKET_PRICE_ID := v_RECORD.MARKET_PRICE_ID;
	p_CONTROL_AREA_ID := v_RECORD.CONTROL_AREA_ID;
	p_TIME_ZONE := v_RECORD.TIME_ZONE;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_SERVICE_ZONE_NAME := g_EMPTY_VARCHAR2;
		p_SERVICE_ZONE_ALIAS := g_EMPTY_VARCHAR2;
		p_SERVICE_ZONE_DESC := g_EMPTY_VARCHAR2;
		p_EXTERNAL_IDENTIFIER := g_EMPTY_VARCHAR2;
		p_MARKET_PRICE_ID := g_EMPTY_NUMBER;
		p_CONTROL_AREA_ID := g_EMPTY_NUMBER;
		p_TIME_ZONE := g_EMPTY_VARCHAR2;

END GET_SERVICE_ZONE;
---------------------------------------------------------------------
PROCEDURE PUT_SETTLEMENT_TYPE
	(
	o_OID OUT NUMBER,
	p_SETTLEMENT_TYPE_NAME IN VARCHAR2,
	p_SETTLEMENT_TYPE_ALIAS IN VARCHAR2,
	p_SETTLEMENT_TYPE_DESC IN VARCHAR2,
	p_SETTLEMENT_TYPE_ID IN NUMBER,
	p_SETTLEMENT_TYPE_ORDER IN VARCHAR2,
	p_SERVICE_CODE IN VARCHAR2,
	p_SCENARIO_ID IN NUMBER,
	p_STATEMENT_TYPE_ID IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC SETTLEMENT_TYPE%ROWTYPE;
BEGIN


	v_REC.SETTLEMENT_TYPE_ID := p_SETTLEMENT_TYPE_ID;
	v_REC.SETTLEMENT_TYPE_NAME := TRIM(p_SETTLEMENT_TYPE_NAME);
	v_REC.SETTLEMENT_TYPE_ALIAS := TRIM(NVL(p_SETTLEMENT_TYPE_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SETTLEMENT_TYPE_DESC := TRIM(NVL(p_SETTLEMENT_TYPE_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SETTLEMENT_TYPE_ORDER := TRIM(NVL(p_SETTLEMENT_TYPE_ORDER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SERVICE_CODE := TRIM(NVL(p_SERVICE_CODE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SCENARIO_ID := p_SCENARIO_ID;
	v_REC.STATEMENT_TYPE_ID := NVL(p_STATEMENT_TYPE_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_SETTLEMENT_TYPE_ID > 0 OR p_SETTLEMENT_TYPE_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_SETTLEMENT_TYPE_ID, EC.ED_SETTLEMENT_TYPE) 
                 AND IO_UTIL.SETTLEMENT_TYPE_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_SETTLEMENT_TYPE, p_SETTLEMENT_TYPE_ID);
		END IF;

		-- save it!
		UPDATE SETTLEMENT_TYPE
		SET ROW = v_REC
		WHERE SETTLEMENT_TYPE_ID = p_SETTLEMENT_TYPE_ID;
		o_OID := p_SETTLEMENT_TYPE_ID;
        
	ELSIF p_SETTLEMENT_TYPE_ID IS NULL OR p_SETTLEMENT_TYPE_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.SETTLEMENT_TYPE_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_SETTLEMENT_TYPE, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.SETTLEMENT_TYPE_ID := o_OID;
		-- save it!
		INSERT INTO SETTLEMENT_TYPE VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_SETTLEMENT_TYPE_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_SETTLEMENT_TYPE, EC.ED_ENTITY_DOMAIN)||': '||p_SETTLEMENT_TYPE_NAME);
END PUT_SETTLEMENT_TYPE;
---------------------------------------------------------------------
PROCEDURE GET_SETTLEMENT_TYPE
	(
	p_SETTLEMENT_TYPE_ID IN NUMBER,
	p_SETTLEMENT_TYPE_NAME OUT VARCHAR2,
	p_SETTLEMENT_TYPE_ALIAS OUT VARCHAR2,
	p_SETTLEMENT_TYPE_DESC OUT VARCHAR2,
	p_SETTLEMENT_TYPE_ORDER OUT VARCHAR2,
	p_SERVICE_CODE OUT VARCHAR2,
	p_SCENARIO_ID OUT NUMBER,
	p_STATEMENT_TYPE_ID OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD SETTLEMENT_TYPE%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_SETTLEMENT_TYPE_ID, EC.ED_SETTLEMENT_TYPE);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM SETTLEMENT_TYPE
	WHERE SETTLEMENT_TYPE_ID = p_SETTLEMENT_TYPE_ID;
    
	-- Set the output parameters
	p_SETTLEMENT_TYPE_NAME := v_RECORD.SETTLEMENT_TYPE_NAME;
	p_SETTLEMENT_TYPE_ALIAS := v_RECORD.SETTLEMENT_TYPE_ALIAS;
	p_SETTLEMENT_TYPE_DESC := v_RECORD.SETTLEMENT_TYPE_DESC;
	p_SETTLEMENT_TYPE_ORDER := v_RECORD.SETTLEMENT_TYPE_ORDER;
	p_SERVICE_CODE := v_RECORD.SERVICE_CODE;
	p_SCENARIO_ID := v_RECORD.SCENARIO_ID;
	p_STATEMENT_TYPE_ID := v_RECORD.STATEMENT_TYPE_ID;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_SETTLEMENT_TYPE_NAME := g_EMPTY_VARCHAR2;
		p_SETTLEMENT_TYPE_ALIAS := g_EMPTY_VARCHAR2;
		p_SETTLEMENT_TYPE_DESC := g_EMPTY_VARCHAR2;
		p_SETTLEMENT_TYPE_ORDER := g_EMPTY_VARCHAR2;
		p_SERVICE_CODE := g_EMPTY_VARCHAR2;
		p_SCENARIO_ID := g_EMPTY_NUMBER;
		p_STATEMENT_TYPE_ID := g_EMPTY_NUMBER;

END GET_SETTLEMENT_TYPE;
---------------------------------------------------------------------
PROCEDURE PUT_STATEMENT_TYPE
	(
	o_OID OUT NUMBER,
	p_STATEMENT_TYPE_NAME IN VARCHAR2,
	p_STATEMENT_TYPE_ALIAS IN VARCHAR2,
	p_STATEMENT_TYPE_DESC IN VARCHAR2,
	p_STATEMENT_TYPE_ID IN NUMBER,
	p_STATEMENT_TYPE_ORDER IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC STATEMENT_TYPE%ROWTYPE;
BEGIN


	v_REC.STATEMENT_TYPE_ID := p_STATEMENT_TYPE_ID;
	v_REC.STATEMENT_TYPE_NAME := TRIM(p_STATEMENT_TYPE_NAME);
	v_REC.STATEMENT_TYPE_ALIAS := TRIM(NVL(p_STATEMENT_TYPE_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.STATEMENT_TYPE_DESC := TRIM(NVL(p_STATEMENT_TYPE_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.STATEMENT_TYPE_ORDER := p_STATEMENT_TYPE_ORDER;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_STATEMENT_TYPE_ID > 0 OR p_STATEMENT_TYPE_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_STATEMENT_TYPE_ID, EC.ED_STATEMENT_TYPE) 
                 AND IO_UTIL.STATEMENT_TYPE_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_STATEMENT_TYPE, p_STATEMENT_TYPE_ID);
		END IF;

		-- save it!
		UPDATE STATEMENT_TYPE
		SET ROW = v_REC
		WHERE STATEMENT_TYPE_ID = p_STATEMENT_TYPE_ID;
		o_OID := p_STATEMENT_TYPE_ID;
        
	ELSIF p_STATEMENT_TYPE_ID IS NULL OR p_STATEMENT_TYPE_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.STATEMENT_TYPE_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_STATEMENT_TYPE, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.STATEMENT_TYPE_ID := o_OID;
		-- save it!
		INSERT INTO STATEMENT_TYPE VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_STATEMENT_TYPE_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_STATEMENT_TYPE, EC.ED_ENTITY_DOMAIN)||': '||p_STATEMENT_TYPE_NAME);
END PUT_STATEMENT_TYPE;
---------------------------------------------------------------------
PROCEDURE GET_STATEMENT_TYPE
	(
	p_STATEMENT_TYPE_ID IN NUMBER,
	p_STATEMENT_TYPE_NAME OUT VARCHAR2,
	p_STATEMENT_TYPE_ALIAS OUT VARCHAR2,
	p_STATEMENT_TYPE_DESC OUT VARCHAR2,
	p_STATEMENT_TYPE_ORDER OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD STATEMENT_TYPE%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_STATEMENT_TYPE_ID, EC.ED_STATEMENT_TYPE);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM STATEMENT_TYPE
	WHERE STATEMENT_TYPE_ID = p_STATEMENT_TYPE_ID;
    
	-- Set the output parameters
	p_STATEMENT_TYPE_NAME := v_RECORD.STATEMENT_TYPE_NAME;
	p_STATEMENT_TYPE_ALIAS := v_RECORD.STATEMENT_TYPE_ALIAS;
	p_STATEMENT_TYPE_DESC := v_RECORD.STATEMENT_TYPE_DESC;
	p_STATEMENT_TYPE_ORDER := v_RECORD.STATEMENT_TYPE_ORDER;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_STATEMENT_TYPE_NAME := g_EMPTY_VARCHAR2;
		p_STATEMENT_TYPE_ALIAS := g_EMPTY_VARCHAR2;
		p_STATEMENT_TYPE_DESC := g_EMPTY_VARCHAR2;
		p_STATEMENT_TYPE_ORDER := g_EMPTY_NUMBER;

END GET_STATEMENT_TYPE;
---------------------------------------------------------------------
PROCEDURE PUT_SUB_STATION
	(
	o_OID OUT NUMBER,
	p_SUB_STATION_NAME IN VARCHAR2,
	p_SUB_STATION_ALIAS IN VARCHAR2,
	p_SUB_STATION_DESC IN VARCHAR2,
	p_SUB_STATION_ID IN NUMBER,
	p_SUB_STATION_TYPE IN VARCHAR2,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SERVICE_ZONE_ID IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC TX_SUB_STATION%ROWTYPE;
BEGIN


	v_REC.SUB_STATION_ID := p_SUB_STATION_ID;
	v_REC.SUB_STATION_NAME := TRIM(p_SUB_STATION_NAME);
	v_REC.SUB_STATION_ALIAS := TRIM(NVL(p_SUB_STATION_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SUB_STATION_DESC := TRIM(NVL(p_SUB_STATION_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SUB_STATION_TYPE := TRIM(NVL(p_SUB_STATION_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EXTERNAL_IDENTIFIER := TRIM(NVL(p_EXTERNAL_IDENTIFIER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.BEGIN_DATE := p_BEGIN_DATE;
	v_REC.END_DATE := p_END_DATE;
	v_REC.SERVICE_ZONE_ID := NVL(p_SERVICE_ZONE_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_SUB_STATION_ID > 0 OR p_SUB_STATION_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_SUB_STATION_ID, EC.ED_SUB_STATION) 
                 AND IO_UTIL.SUB_STATION_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_SUB_STATION, p_SUB_STATION_ID);
		END IF;

		-- save it!
		UPDATE TX_SUB_STATION
		SET ROW = v_REC
		WHERE SUB_STATION_ID = p_SUB_STATION_ID;
		o_OID := p_SUB_STATION_ID;
        
	ELSIF p_SUB_STATION_ID IS NULL OR p_SUB_STATION_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.SUB_STATION_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_SUB_STATION, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.SUB_STATION_ID := o_OID;
		-- save it!
		INSERT INTO TX_SUB_STATION VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_SUB_STATION_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_SUB_STATION, EC.ED_ENTITY_DOMAIN)||': '||p_SUB_STATION_NAME);
END PUT_SUB_STATION;
---------------------------------------------------------------------
PROCEDURE GET_SUB_STATION
	(
	p_SUB_STATION_ID IN NUMBER,
	p_SUB_STATION_NAME OUT VARCHAR2,
	p_SUB_STATION_ALIAS OUT VARCHAR2,
	p_SUB_STATION_DESC OUT VARCHAR2,
	p_SUB_STATION_TYPE OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE,
	p_SERVICE_ZONE_ID OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD TX_SUB_STATION%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_SUB_STATION_ID, EC.ED_SUB_STATION);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM TX_SUB_STATION
	WHERE SUB_STATION_ID = p_SUB_STATION_ID;
    
	-- Set the output parameters
	p_SUB_STATION_NAME := v_RECORD.SUB_STATION_NAME;
	p_SUB_STATION_ALIAS := v_RECORD.SUB_STATION_ALIAS;
	p_SUB_STATION_DESC := v_RECORD.SUB_STATION_DESC;
	p_SUB_STATION_TYPE := v_RECORD.SUB_STATION_TYPE;
	p_EXTERNAL_IDENTIFIER := v_RECORD.EXTERNAL_IDENTIFIER;
	p_BEGIN_DATE := v_RECORD.BEGIN_DATE;
	p_END_DATE := v_RECORD.END_DATE;
	p_SERVICE_ZONE_ID := v_RECORD.SERVICE_ZONE_ID;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_SUB_STATION_NAME := g_EMPTY_VARCHAR2;
		p_SUB_STATION_ALIAS := g_EMPTY_VARCHAR2;
		p_SUB_STATION_DESC := g_EMPTY_VARCHAR2;
		p_SUB_STATION_TYPE := g_EMPTY_VARCHAR2;
		p_EXTERNAL_IDENTIFIER := g_EMPTY_VARCHAR2;
		p_BEGIN_DATE := g_EMPTY_DATE;
		p_END_DATE := g_EMPTY_DATE;
		p_SERVICE_ZONE_ID := g_EMPTY_NUMBER;

END GET_SUB_STATION;
---------------------------------------------------------------------
PROCEDURE PUT_SUB_STATION_METER
	(
	o_OID OUT NUMBER,
	p_METER_NAME IN VARCHAR2,
	p_METER_ALIAS IN VARCHAR2,
	p_METER_DESC IN VARCHAR2,
	p_METER_ID IN NUMBER,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_METER_TYPE IN VARCHAR2,
	p_METER_SUB_TYPE IN VARCHAR2,
	p_METER_CATEGORY IN VARCHAR2,
	p_REF_METER_ID IN NUMBER,
	p_SUB_STATION_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_TRUNCATE_CARRY_FWD IN NUMBER,
	p_QUALITY_RATING IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC TX_SUB_STATION_METER%ROWTYPE;
BEGIN


	v_REC.METER_ID := p_METER_ID;
	v_REC.METER_NAME := TRIM(p_METER_NAME);
	v_REC.METER_ALIAS := TRIM(NVL(p_METER_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.METER_DESC := TRIM(NVL(p_METER_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EXTERNAL_IDENTIFIER := TRIM(NVL(p_EXTERNAL_IDENTIFIER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.BEGIN_DATE := p_BEGIN_DATE;
	v_REC.END_DATE := p_END_DATE;
	v_REC.METER_TYPE := TRIM(NVL(p_METER_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.METER_SUB_TYPE := TRIM(NVL(p_METER_SUB_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.METER_CATEGORY := TRIM(NVL(p_METER_CATEGORY,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.REF_METER_ID := NVL(p_REF_METER_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.SUB_STATION_ID := NVL(p_SUB_STATION_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.SERVICE_POINT_ID := NVL(p_SERVICE_POINT_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.TRUNCATE_CARRY_FWD := p_TRUNCATE_CARRY_FWD;
	v_REC.QUALITY_RATING := TRIM(NVL(p_QUALITY_RATING,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_METER_ID > 0 OR p_METER_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_METER_ID, EC.ED_SUB_STATION_METER) 
                 AND IO_UTIL.SUB_STATION_METER_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_SUB_STATION_METER, p_METER_ID);
		END IF;

		-- save it!
		UPDATE TX_SUB_STATION_METER
		SET ROW = v_REC
		WHERE METER_ID = p_METER_ID;
		o_OID := p_METER_ID;
        
	ELSIF p_METER_ID IS NULL OR p_METER_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.SUB_STATION_METER_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_SUB_STATION_METER, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.METER_ID := o_OID;
		-- save it!
		INSERT INTO TX_SUB_STATION_METER VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_METER_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_SUB_STATION_METER, EC.ED_ENTITY_DOMAIN)||': '||p_METER_NAME);
END PUT_SUB_STATION_METER;
---------------------------------------------------------------------
PROCEDURE GET_SUB_STATION_METER
	(
	p_METER_ID IN NUMBER,
	p_METER_NAME OUT VARCHAR2,
	p_METER_ALIAS OUT VARCHAR2,
	p_METER_DESC OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE,
	p_METER_TYPE OUT VARCHAR2,
	p_METER_SUB_TYPE OUT VARCHAR2,
	p_METER_CATEGORY OUT VARCHAR2,
	p_REF_METER_ID OUT NUMBER,
	p_SUB_STATION_ID OUT NUMBER,
	p_SERVICE_POINT_ID OUT NUMBER,
	p_TRUNCATE_CARRY_FWD OUT NUMBER,
	p_QUALITY_RATING OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD TX_SUB_STATION_METER%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_METER_ID, EC.ED_SUB_STATION_METER);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM TX_SUB_STATION_METER
	WHERE METER_ID = p_METER_ID;
    
	-- Set the output parameters
	p_METER_NAME := v_RECORD.METER_NAME;
	p_METER_ALIAS := v_RECORD.METER_ALIAS;
	p_METER_DESC := v_RECORD.METER_DESC;
	p_EXTERNAL_IDENTIFIER := v_RECORD.EXTERNAL_IDENTIFIER;
	p_BEGIN_DATE := v_RECORD.BEGIN_DATE;
	p_END_DATE := v_RECORD.END_DATE;
	p_METER_TYPE := v_RECORD.METER_TYPE;
	p_METER_SUB_TYPE := v_RECORD.METER_SUB_TYPE;
	p_METER_CATEGORY := v_RECORD.METER_CATEGORY;
	p_REF_METER_ID := v_RECORD.REF_METER_ID;
	p_SUB_STATION_ID := v_RECORD.SUB_STATION_ID;
	p_SERVICE_POINT_ID := v_RECORD.SERVICE_POINT_ID;
	p_TRUNCATE_CARRY_FWD := v_RECORD.TRUNCATE_CARRY_FWD;
	p_QUALITY_RATING := v_RECORD.QUALITY_RATING;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_METER_NAME := g_EMPTY_VARCHAR2;
		p_METER_ALIAS := g_EMPTY_VARCHAR2;
		p_METER_DESC := g_EMPTY_VARCHAR2;
		p_EXTERNAL_IDENTIFIER := g_EMPTY_VARCHAR2;
		p_BEGIN_DATE := g_EMPTY_DATE;
		p_END_DATE := g_EMPTY_DATE;
		p_METER_TYPE := g_EMPTY_VARCHAR2;
		p_METER_SUB_TYPE := g_EMPTY_VARCHAR2;
		p_METER_CATEGORY := g_EMPTY_VARCHAR2;
		p_REF_METER_ID := g_EMPTY_NUMBER;
		p_SUB_STATION_ID := g_EMPTY_NUMBER;
		p_SERVICE_POINT_ID := g_EMPTY_NUMBER;
		p_TRUNCATE_CARRY_FWD := g_EMPTY_NUMBER;
		p_QUALITY_RATING := g_EMPTY_VARCHAR2;

END GET_SUB_STATION_METER;
---------------------------------------------------------------------
PROCEDURE PUT_SUB_STATION_METER_POINT
	(
	o_OID OUT NUMBER,
	p_METER_POINT_NAME IN VARCHAR2,
	p_METER_POINT_ALIAS IN VARCHAR2,
	p_METER_POINT_DESC IN VARCHAR2,
	p_METER_POINT_ID IN NUMBER,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_METER_POINT_CATEGORY IN VARCHAR2,
	p_RETAIL_METER_ID IN NUMBER,
	p_SUB_STATION_METER_ID IN NUMBER,
	p_METER_POINT_INTERVAL IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_UOM IN VARCHAR2,
	p_OPERATION_CODE IN VARCHAR2,
	p_DIRECTION IN VARCHAR2,
	p_TOLERANCE IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC TX_SUB_STATION_METER_POINT%ROWTYPE;
BEGIN


	v_REC.METER_POINT_ID := p_METER_POINT_ID;
	v_REC.METER_POINT_NAME := TRIM(p_METER_POINT_NAME);
	v_REC.METER_POINT_ALIAS := TRIM(NVL(p_METER_POINT_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.METER_POINT_DESC := TRIM(NVL(p_METER_POINT_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EXTERNAL_IDENTIFIER := TRIM(NVL(p_EXTERNAL_IDENTIFIER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.METER_POINT_CATEGORY := TRIM(NVL(p_METER_POINT_CATEGORY,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.RETAIL_METER_ID := p_RETAIL_METER_ID;
	v_REC.SUB_STATION_METER_ID := p_SUB_STATION_METER_ID;
	v_REC.METER_POINT_INTERVAL := TRIM(NVL(p_METER_POINT_INTERVAL,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.BEGIN_DATE := p_BEGIN_DATE;
	v_REC.END_DATE := p_END_DATE;
	v_REC.UOM := TRIM(NVL(p_UOM,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.OPERATION_CODE := TRIM(NVL(p_OPERATION_CODE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.DIRECTION := TRIM(NVL(p_DIRECTION,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.TOLERANCE := p_TOLERANCE;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_METER_POINT_ID > 0 OR p_METER_POINT_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_METER_POINT_ID, EC.ED_SUB_STATION_METER_POINT) 
                 AND IO_UTIL.SUB_STATION_METER_POINT_IS_ALL (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_SUB_STATION_METER_POINT, p_METER_POINT_ID);
		END IF;

		-- save it!
		UPDATE TX_SUB_STATION_METER_POINT
		SET ROW = v_REC
		WHERE METER_POINT_ID = p_METER_POINT_ID;
		o_OID := p_METER_POINT_ID;
        
	ELSIF p_METER_POINT_ID IS NULL OR p_METER_POINT_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.SUB_STATION_METER_POINT_IS_ALL (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_SUB_STATION_METER_POINT, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.METER_POINT_ID := o_OID;
		-- save it!
		INSERT INTO TX_SUB_STATION_METER_POINT VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_METER_POINT_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_SUB_STATION_METER_POINT, EC.ED_ENTITY_DOMAIN)||': '||p_METER_POINT_NAME);
END PUT_SUB_STATION_METER_POINT;
---------------------------------------------------------------------
PROCEDURE GET_SUB_STATION_METER_POINT
	(
	p_METER_POINT_ID IN NUMBER,
	p_METER_POINT_NAME OUT VARCHAR2,
	p_METER_POINT_ALIAS OUT VARCHAR2,
	p_METER_POINT_DESC OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_METER_POINT_CATEGORY OUT VARCHAR2,
	p_RETAIL_METER_ID OUT NUMBER,
	p_SUB_STATION_METER_ID OUT NUMBER,
	p_METER_POINT_INTERVAL OUT VARCHAR2,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE,
	p_UOM OUT VARCHAR2,
	p_OPERATION_CODE OUT VARCHAR2,
	p_DIRECTION OUT VARCHAR2,
	p_TOLERANCE OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD TX_SUB_STATION_METER_POINT%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_METER_POINT_ID, EC.ED_SUB_STATION_METER_POINT);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM TX_SUB_STATION_METER_POINT
	WHERE METER_POINT_ID = p_METER_POINT_ID;
    
	-- Set the output parameters
	p_METER_POINT_NAME := v_RECORD.METER_POINT_NAME;
	p_METER_POINT_ALIAS := v_RECORD.METER_POINT_ALIAS;
	p_METER_POINT_DESC := v_RECORD.METER_POINT_DESC;
	p_EXTERNAL_IDENTIFIER := v_RECORD.EXTERNAL_IDENTIFIER;
	p_METER_POINT_CATEGORY := v_RECORD.METER_POINT_CATEGORY;
	p_RETAIL_METER_ID := v_RECORD.RETAIL_METER_ID;
	p_SUB_STATION_METER_ID := v_RECORD.SUB_STATION_METER_ID;
	p_METER_POINT_INTERVAL := v_RECORD.METER_POINT_INTERVAL;
	p_BEGIN_DATE := v_RECORD.BEGIN_DATE;
	p_END_DATE := v_RECORD.END_DATE;
	p_UOM := v_RECORD.UOM;
	p_OPERATION_CODE := v_RECORD.OPERATION_CODE;
	p_DIRECTION := v_RECORD.DIRECTION;
	p_TOLERANCE := v_RECORD.TOLERANCE;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_METER_POINT_NAME := g_EMPTY_VARCHAR2;
		p_METER_POINT_ALIAS := g_EMPTY_VARCHAR2;
		p_METER_POINT_DESC := g_EMPTY_VARCHAR2;
		p_EXTERNAL_IDENTIFIER := g_EMPTY_VARCHAR2;
		p_METER_POINT_CATEGORY := g_EMPTY_VARCHAR2;
		p_RETAIL_METER_ID := g_EMPTY_NUMBER;
		p_SUB_STATION_METER_ID := g_EMPTY_NUMBER;
		p_METER_POINT_INTERVAL := g_EMPTY_VARCHAR2;
		p_BEGIN_DATE := g_EMPTY_DATE;
		p_END_DATE := g_EMPTY_DATE;
		p_UOM := g_EMPTY_VARCHAR2;
		p_OPERATION_CODE := g_EMPTY_VARCHAR2;
		p_DIRECTION := g_EMPTY_VARCHAR2;
		p_TOLERANCE := g_EMPTY_NUMBER;

END GET_SUB_STATION_METER_POINT;
---------------------------------------------------------------------
PROCEDURE PUT_SUPPLY_RESOURCE
	(
	o_OID OUT NUMBER,
	p_RESOURCE_NAME IN VARCHAR2,
	p_RESOURCE_ALIAS IN VARCHAR2,
	p_RESOURCE_DESC IN VARCHAR2,
	p_RESOURCE_ID IN NUMBER,
	p_RESOURCE_GROUP_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_HEAT_RATE_CURVE_ID IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC SUPPLY_RESOURCE%ROWTYPE;
BEGIN


	v_REC.RESOURCE_ID := p_RESOURCE_ID;
	v_REC.RESOURCE_NAME := TRIM(p_RESOURCE_NAME);
	v_REC.RESOURCE_ALIAS := TRIM(NVL(p_RESOURCE_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.RESOURCE_DESC := TRIM(NVL(p_RESOURCE_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.RESOURCE_GROUP_ID := p_RESOURCE_GROUP_ID;
	v_REC.SERVICE_POINT_ID := NVL(p_SERVICE_POINT_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.HEAT_RATE_CURVE_ID := p_HEAT_RATE_CURVE_ID;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_RESOURCE_ID > 0 OR p_RESOURCE_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_RESOURCE_ID, EC.ED_SUPPLY_RESOURCE) 
                 AND IO_UTIL.SUPPLY_RESOURCE_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_SUPPLY_RESOURCE, p_RESOURCE_ID);
		END IF;

		-- save it!
		UPDATE SUPPLY_RESOURCE
		SET ROW = v_REC
		WHERE RESOURCE_ID = p_RESOURCE_ID;
		o_OID := p_RESOURCE_ID;
        
	ELSIF p_RESOURCE_ID IS NULL OR p_RESOURCE_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.SUPPLY_RESOURCE_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_SUPPLY_RESOURCE, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.RESOURCE_ID := o_OID;
		-- save it!
		INSERT INTO SUPPLY_RESOURCE VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_RESOURCE_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_SUPPLY_RESOURCE, EC.ED_ENTITY_DOMAIN)||': '||p_RESOURCE_NAME);
END PUT_SUPPLY_RESOURCE;
---------------------------------------------------------------------
PROCEDURE GET_SUPPLY_RESOURCE
	(
	p_RESOURCE_ID IN NUMBER,
	p_RESOURCE_NAME OUT VARCHAR2,
	p_RESOURCE_ALIAS OUT VARCHAR2,
	p_RESOURCE_DESC OUT VARCHAR2,
	p_RESOURCE_GROUP_ID OUT NUMBER,
	p_SERVICE_POINT_ID OUT NUMBER,
	p_HEAT_RATE_CURVE_ID OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD SUPPLY_RESOURCE%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_RESOURCE_ID, EC.ED_SUPPLY_RESOURCE);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM SUPPLY_RESOURCE
	WHERE RESOURCE_ID = p_RESOURCE_ID;
    
	-- Set the output parameters
	p_RESOURCE_NAME := v_RECORD.RESOURCE_NAME;
	p_RESOURCE_ALIAS := v_RECORD.RESOURCE_ALIAS;
	p_RESOURCE_DESC := v_RECORD.RESOURCE_DESC;
	p_RESOURCE_GROUP_ID := v_RECORD.RESOURCE_GROUP_ID;
	p_SERVICE_POINT_ID := v_RECORD.SERVICE_POINT_ID;
	p_HEAT_RATE_CURVE_ID := v_RECORD.HEAT_RATE_CURVE_ID;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_RESOURCE_NAME := g_EMPTY_VARCHAR2;
		p_RESOURCE_ALIAS := g_EMPTY_VARCHAR2;
		p_RESOURCE_DESC := g_EMPTY_VARCHAR2;
		p_RESOURCE_GROUP_ID := g_EMPTY_NUMBER;
		p_SERVICE_POINT_ID := g_EMPTY_NUMBER;
		p_HEAT_RATE_CURVE_ID := g_EMPTY_NUMBER;

END GET_SUPPLY_RESOURCE;
---------------------------------------------------------------------
PROCEDURE PUT_SYSTEM_ACTION
	(
	o_OID OUT NUMBER,
	p_ACTION_NAME IN VARCHAR2,
	p_ACTION_ALIAS IN VARCHAR2,
	p_ACTION_DESC IN VARCHAR2,
	p_ACTION_ID IN NUMBER,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_MODULE IN VARCHAR2,
	p_ACTION_TYPE IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC SYSTEM_ACTION%ROWTYPE;
BEGIN


	v_REC.ACTION_ID := p_ACTION_ID;
	v_REC.ACTION_NAME := TRIM(p_ACTION_NAME);
	v_REC.ACTION_ALIAS := TRIM(NVL(p_ACTION_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ACTION_DESC := TRIM(NVL(p_ACTION_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTITY_DOMAIN_ID := NVL(p_ENTITY_DOMAIN_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.MODULE := TRIM(NVL(p_MODULE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ACTION_TYPE := TRIM(NVL(p_ACTION_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_ACTION_ID > 0 OR p_ACTION_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACTION_ID, EC.ED_SYSTEM_ACTION) 
                 AND IO_UTIL.SYSTEM_ACTION_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_SYSTEM_ACTION, p_ACTION_ID);
		END IF;

		-- save it!
		UPDATE SYSTEM_ACTION
		SET ROW = v_REC
		WHERE ACTION_ID = p_ACTION_ID;
		o_OID := p_ACTION_ID;
        
	ELSIF p_ACTION_ID IS NULL OR p_ACTION_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.SYSTEM_ACTION_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_SYSTEM_ACTION, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.ACTION_ID := o_OID;
		-- save it!
		INSERT INTO SYSTEM_ACTION VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_ACTION_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_SYSTEM_ACTION, EC.ED_ENTITY_DOMAIN)||': '||p_ACTION_NAME);
END PUT_SYSTEM_ACTION;
---------------------------------------------------------------------
PROCEDURE GET_SYSTEM_ACTION
	(
	p_ACTION_ID IN NUMBER,
	p_ACTION_NAME OUT VARCHAR2,
	p_ACTION_ALIAS OUT VARCHAR2,
	p_ACTION_DESC OUT VARCHAR2,
	p_ENTITY_DOMAIN_ID OUT NUMBER,
	p_MODULE OUT VARCHAR2,
	p_ACTION_TYPE OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD SYSTEM_ACTION%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ACTION_ID, EC.ED_SYSTEM_ACTION);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM SYSTEM_ACTION
	WHERE ACTION_ID = p_ACTION_ID;
    
	-- Set the output parameters
	p_ACTION_NAME := v_RECORD.ACTION_NAME;
	p_ACTION_ALIAS := v_RECORD.ACTION_ALIAS;
	p_ACTION_DESC := v_RECORD.ACTION_DESC;
	p_ENTITY_DOMAIN_ID := v_RECORD.ENTITY_DOMAIN_ID;
	p_MODULE := v_RECORD.MODULE;
	p_ACTION_TYPE := v_RECORD.ACTION_TYPE;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_ACTION_NAME := g_EMPTY_VARCHAR2;
		p_ACTION_ALIAS := g_EMPTY_VARCHAR2;
		p_ACTION_DESC := g_EMPTY_VARCHAR2;
		p_ENTITY_DOMAIN_ID := g_EMPTY_NUMBER;
		p_MODULE := g_EMPTY_VARCHAR2;
		p_ACTION_TYPE := g_EMPTY_VARCHAR2;

END GET_SYSTEM_ACTION;
---------------------------------------------------------------------
PROCEDURE PUT_SYSTEM_ALERT
	(
	o_OID OUT NUMBER,
	p_ALERT_NAME IN VARCHAR2,
	p_ALERT_ALIAS IN VARCHAR2,
	p_ALERT_DESC IN VARCHAR2,
	p_ALERT_ID IN NUMBER,
	p_ALERT_TYPE IN VARCHAR2,
	p_ALERT_CATEGORY IN VARCHAR2,
	p_ALERT_DURATION IN NUMBER,
	p_IS_EMAIL_ALERT IN NUMBER,
	p_IS_EMAIL_FIRST_ACK IN NUMBER,
	p_ALERT_EMAIL_PRIORITY IN NUMBER,
	p_ALERT_EMAIL_SUBJECT IN VARCHAR2,
	p_ACK_EMAIL_PRIORITY IN NUMBER,
	p_ACK_EMAIL_SUBJECT IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC SYSTEM_ALERT%ROWTYPE;
BEGIN


	v_REC.ALERT_ID := p_ALERT_ID;
	v_REC.ALERT_NAME := TRIM(p_ALERT_NAME);
	v_REC.ALERT_ALIAS := TRIM(NVL(p_ALERT_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ALERT_DESC := TRIM(NVL(p_ALERT_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ALERT_TYPE := TRIM(NVL(p_ALERT_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ALERT_CATEGORY := TRIM(NVL(p_ALERT_CATEGORY,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ALERT_DURATION := p_ALERT_DURATION;
	v_REC.IS_EMAIL_ALERT := p_IS_EMAIL_ALERT;
	v_REC.IS_EMAIL_FIRST_ACK := p_IS_EMAIL_FIRST_ACK;
	v_REC.ALERT_EMAIL_PRIORITY := p_ALERT_EMAIL_PRIORITY;
	v_REC.ALERT_EMAIL_SUBJECT := TRIM(NVL(p_ALERT_EMAIL_SUBJECT,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ACK_EMAIL_PRIORITY := p_ACK_EMAIL_PRIORITY;
	v_REC.ACK_EMAIL_SUBJECT := TRIM(NVL(p_ACK_EMAIL_SUBJECT,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_ALERT_ID > 0 OR p_ALERT_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ALERT_ID, EC.ED_SYSTEM_ALERT) 
                 AND IO_UTIL.SYSTEM_ALERT_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_SYSTEM_ALERT, p_ALERT_ID);
		END IF;

		-- save it!
		UPDATE SYSTEM_ALERT
		SET ROW = v_REC
		WHERE ALERT_ID = p_ALERT_ID;
		o_OID := p_ALERT_ID;
        
	ELSIF p_ALERT_ID IS NULL OR p_ALERT_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.SYSTEM_ALERT_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_SYSTEM_ALERT, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.ALERT_ID := o_OID;
		-- save it!
		INSERT INTO SYSTEM_ALERT VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_ALERT_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_SYSTEM_ALERT, EC.ED_ENTITY_DOMAIN)||': '||p_ALERT_NAME);
END PUT_SYSTEM_ALERT;
---------------------------------------------------------------------
PROCEDURE GET_SYSTEM_ALERT
	(
	p_ALERT_ID IN NUMBER,
	p_ALERT_NAME OUT VARCHAR2,
	p_ALERT_ALIAS OUT VARCHAR2,
	p_ALERT_DESC OUT VARCHAR2,
	p_ALERT_TYPE OUT VARCHAR2,
	p_ALERT_CATEGORY OUT VARCHAR2,
	p_ALERT_DURATION OUT NUMBER,
	p_IS_EMAIL_ALERT OUT NUMBER,
	p_IS_EMAIL_FIRST_ACK OUT NUMBER,
	p_ALERT_EMAIL_PRIORITY OUT NUMBER,
	p_ALERT_EMAIL_SUBJECT OUT VARCHAR2,
	p_ACK_EMAIL_PRIORITY OUT NUMBER,
	p_ACK_EMAIL_SUBJECT OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD SYSTEM_ALERT%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ALERT_ID, EC.ED_SYSTEM_ALERT);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM SYSTEM_ALERT
	WHERE ALERT_ID = p_ALERT_ID;
    
	-- Set the output parameters
	p_ALERT_NAME := v_RECORD.ALERT_NAME;
	p_ALERT_ALIAS := v_RECORD.ALERT_ALIAS;
	p_ALERT_DESC := v_RECORD.ALERT_DESC;
	p_ALERT_TYPE := v_RECORD.ALERT_TYPE;
	p_ALERT_CATEGORY := v_RECORD.ALERT_CATEGORY;
	p_ALERT_DURATION := v_RECORD.ALERT_DURATION;
	p_IS_EMAIL_ALERT := v_RECORD.IS_EMAIL_ALERT;
	p_IS_EMAIL_FIRST_ACK := v_RECORD.IS_EMAIL_FIRST_ACK;
	p_ALERT_EMAIL_PRIORITY := v_RECORD.ALERT_EMAIL_PRIORITY;
	p_ALERT_EMAIL_SUBJECT := v_RECORD.ALERT_EMAIL_SUBJECT;
	p_ACK_EMAIL_PRIORITY := v_RECORD.ACK_EMAIL_PRIORITY;
	p_ACK_EMAIL_SUBJECT := v_RECORD.ACK_EMAIL_SUBJECT;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_ALERT_NAME := g_EMPTY_VARCHAR2;
		p_ALERT_ALIAS := g_EMPTY_VARCHAR2;
		p_ALERT_DESC := g_EMPTY_VARCHAR2;
		p_ALERT_TYPE := g_EMPTY_VARCHAR2;
		p_ALERT_CATEGORY := g_EMPTY_VARCHAR2;
		p_ALERT_DURATION := g_EMPTY_NUMBER;
		p_IS_EMAIL_ALERT := g_EMPTY_NUMBER;
		p_IS_EMAIL_FIRST_ACK := g_EMPTY_NUMBER;
		p_ALERT_EMAIL_PRIORITY := g_EMPTY_NUMBER;
		p_ALERT_EMAIL_SUBJECT := g_EMPTY_VARCHAR2;
		p_ACK_EMAIL_PRIORITY := g_EMPTY_NUMBER;
		p_ACK_EMAIL_SUBJECT := g_EMPTY_VARCHAR2;

END GET_SYSTEM_ALERT;
---------------------------------------------------------------------
PROCEDURE PUT_SYSTEM_EVENT
	(
	o_OID OUT NUMBER,
	p_EVENT_NAME IN VARCHAR2,
	p_EVENT_ALIAS IN VARCHAR2,
	p_EVENT_DESC IN VARCHAR2,
	p_EVENT_ID IN NUMBER,
	p_EVENT_TYPE IN VARCHAR2,
	p_EVENT_CATEGORY IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC SYSTEM_EVENT%ROWTYPE;
BEGIN


	v_REC.EVENT_ID := p_EVENT_ID;
	v_REC.EVENT_NAME := TRIM(p_EVENT_NAME);
	v_REC.EVENT_ALIAS := TRIM(NVL(p_EVENT_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EVENT_DESC := TRIM(NVL(p_EVENT_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EVENT_TYPE := TRIM(NVL(p_EVENT_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EVENT_CATEGORY := TRIM(NVL(p_EVENT_CATEGORY,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_EVENT_ID > 0 OR p_EVENT_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_EVENT_ID, EC.ED_SYSTEM_EVENT) 
                 AND IO_UTIL.SYSTEM_EVENT_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_SYSTEM_EVENT, p_EVENT_ID);
		END IF;

		-- save it!
		UPDATE SYSTEM_EVENT
		SET ROW = v_REC
		WHERE EVENT_ID = p_EVENT_ID;
		o_OID := p_EVENT_ID;
        
	ELSIF p_EVENT_ID IS NULL OR p_EVENT_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.SYSTEM_EVENT_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_SYSTEM_EVENT, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.EVENT_ID := o_OID;
		-- save it!
		INSERT INTO SYSTEM_EVENT VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_EVENT_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_SYSTEM_EVENT, EC.ED_ENTITY_DOMAIN)||': '||p_EVENT_NAME);
END PUT_SYSTEM_EVENT;
---------------------------------------------------------------------
PROCEDURE GET_SYSTEM_EVENT
	(
	p_EVENT_ID IN NUMBER,
	p_EVENT_NAME OUT VARCHAR2,
	p_EVENT_ALIAS OUT VARCHAR2,
	p_EVENT_DESC OUT VARCHAR2,
	p_EVENT_TYPE OUT VARCHAR2,
	p_EVENT_CATEGORY OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD SYSTEM_EVENT%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_EVENT_ID, EC.ED_SYSTEM_EVENT);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM SYSTEM_EVENT
	WHERE EVENT_ID = p_EVENT_ID;
    
	-- Set the output parameters
	p_EVENT_NAME := v_RECORD.EVENT_NAME;
	p_EVENT_ALIAS := v_RECORD.EVENT_ALIAS;
	p_EVENT_DESC := v_RECORD.EVENT_DESC;
	p_EVENT_TYPE := v_RECORD.EVENT_TYPE;
	p_EVENT_CATEGORY := v_RECORD.EVENT_CATEGORY;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_EVENT_NAME := g_EMPTY_VARCHAR2;
		p_EVENT_ALIAS := g_EMPTY_VARCHAR2;
		p_EVENT_DESC := g_EMPTY_VARCHAR2;
		p_EVENT_TYPE := g_EMPTY_VARCHAR2;
		p_EVENT_CATEGORY := g_EMPTY_VARCHAR2;

END GET_SYSTEM_EVENT;
---------------------------------------------------------------------
PROCEDURE PUT_SYSTEM_LOAD
	(
	o_OID OUT NUMBER,
	p_SYSTEM_LOAD_NAME IN VARCHAR2,
	p_SYSTEM_LOAD_ALIAS IN VARCHAR2,
	p_SYSTEM_LOAD_DESC IN VARCHAR2,
	p_SYSTEM_LOAD_ID IN NUMBER,
	p_SYSTEM_LOAD_INTERVAL IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC SYSTEM_LOAD%ROWTYPE;
BEGIN


	v_REC.SYSTEM_LOAD_ID := p_SYSTEM_LOAD_ID;
	v_REC.SYSTEM_LOAD_NAME := TRIM(p_SYSTEM_LOAD_NAME);
	v_REC.SYSTEM_LOAD_ALIAS := TRIM(NVL(p_SYSTEM_LOAD_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SYSTEM_LOAD_DESC := TRIM(NVL(p_SYSTEM_LOAD_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SYSTEM_LOAD_INTERVAL := TRIM(NVL(p_SYSTEM_LOAD_INTERVAL,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_SYSTEM_LOAD_ID > 0 OR p_SYSTEM_LOAD_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_SYSTEM_LOAD_ID, EC.ED_SYSTEM_LOAD) 
                 AND IO_UTIL.SYSTEM_LOAD_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_SYSTEM_LOAD, p_SYSTEM_LOAD_ID);
		END IF;

		-- save it!
		UPDATE SYSTEM_LOAD
		SET ROW = v_REC
		WHERE SYSTEM_LOAD_ID = p_SYSTEM_LOAD_ID;
		o_OID := p_SYSTEM_LOAD_ID;
        
	ELSIF p_SYSTEM_LOAD_ID IS NULL OR p_SYSTEM_LOAD_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.SYSTEM_LOAD_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_SYSTEM_LOAD, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.SYSTEM_LOAD_ID := o_OID;
		-- save it!
		INSERT INTO SYSTEM_LOAD VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_SYSTEM_LOAD_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_SYSTEM_LOAD, EC.ED_ENTITY_DOMAIN)||': '||p_SYSTEM_LOAD_NAME);
END PUT_SYSTEM_LOAD;
---------------------------------------------------------------------
PROCEDURE GET_SYSTEM_LOAD
	(
	p_SYSTEM_LOAD_ID IN NUMBER,
	p_SYSTEM_LOAD_NAME OUT VARCHAR2,
	p_SYSTEM_LOAD_ALIAS OUT VARCHAR2,
	p_SYSTEM_LOAD_DESC OUT VARCHAR2,
	p_SYSTEM_LOAD_INTERVAL OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD SYSTEM_LOAD%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_SYSTEM_LOAD_ID, EC.ED_SYSTEM_LOAD);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM SYSTEM_LOAD
	WHERE SYSTEM_LOAD_ID = p_SYSTEM_LOAD_ID;
    
	-- Set the output parameters
	p_SYSTEM_LOAD_NAME := v_RECORD.SYSTEM_LOAD_NAME;
	p_SYSTEM_LOAD_ALIAS := v_RECORD.SYSTEM_LOAD_ALIAS;
	p_SYSTEM_LOAD_DESC := v_RECORD.SYSTEM_LOAD_DESC;
	p_SYSTEM_LOAD_INTERVAL := v_RECORD.SYSTEM_LOAD_INTERVAL;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_SYSTEM_LOAD_NAME := g_EMPTY_VARCHAR2;
		p_SYSTEM_LOAD_ALIAS := g_EMPTY_VARCHAR2;
		p_SYSTEM_LOAD_DESC := g_EMPTY_VARCHAR2;
		p_SYSTEM_LOAD_INTERVAL := g_EMPTY_VARCHAR2;

END GET_SYSTEM_LOAD;
---------------------------------------------------------------------
PROCEDURE PUT_SYSTEM_REALM
	(
	o_OID OUT NUMBER,
	p_REALM_NAME IN VARCHAR2,
	p_REALM_ALIAS IN VARCHAR2,
	p_REALM_DESC IN VARCHAR2,
	p_REALM_ID IN NUMBER,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_REALM_CALC_TYPE IN NUMBER,
	p_CUSTOM_QUERY IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC SYSTEM_REALM%ROWTYPE;
BEGIN


	v_REC.REALM_ID := p_REALM_ID;
	v_REC.REALM_NAME := TRIM(p_REALM_NAME);
	v_REC.REALM_ALIAS := TRIM(NVL(p_REALM_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.REALM_DESC := TRIM(NVL(p_REALM_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTITY_DOMAIN_ID := NVL(p_ENTITY_DOMAIN_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.REALM_CALC_TYPE := p_REALM_CALC_TYPE;
	v_REC.CUSTOM_QUERY := TRIM(NVL(p_CUSTOM_QUERY,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_REALM_ID > 0 OR p_REALM_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_REALM_ID, EC.ED_SYSTEM_REALM) 
                 AND IO_UTIL.SYSTEM_REALM_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_SYSTEM_REALM, p_REALM_ID);
		END IF;

		-- save it!
		UPDATE SYSTEM_REALM
		SET ROW = v_REC
		WHERE REALM_ID = p_REALM_ID;
		o_OID := p_REALM_ID;
        
	ELSIF p_REALM_ID IS NULL OR p_REALM_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.SYSTEM_REALM_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_SYSTEM_REALM, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.REALM_ID := o_OID;
		-- save it!
		INSERT INTO SYSTEM_REALM VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_REALM_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_SYSTEM_REALM, EC.ED_ENTITY_DOMAIN)||': '||p_REALM_NAME);
END PUT_SYSTEM_REALM;
---------------------------------------------------------------------
PROCEDURE GET_SYSTEM_REALM
	(
	p_REALM_ID IN NUMBER,
	p_REALM_NAME OUT VARCHAR2,
	p_REALM_ALIAS OUT VARCHAR2,
	p_REALM_DESC OUT VARCHAR2,
	p_ENTITY_DOMAIN_ID OUT NUMBER,
	p_REALM_CALC_TYPE OUT NUMBER,
	p_CUSTOM_QUERY OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD SYSTEM_REALM%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_REALM_ID, EC.ED_SYSTEM_REALM);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM SYSTEM_REALM
	WHERE REALM_ID = p_REALM_ID;
    
	-- Set the output parameters
	p_REALM_NAME := v_RECORD.REALM_NAME;
	p_REALM_ALIAS := v_RECORD.REALM_ALIAS;
	p_REALM_DESC := v_RECORD.REALM_DESC;
	p_ENTITY_DOMAIN_ID := v_RECORD.ENTITY_DOMAIN_ID;
	p_REALM_CALC_TYPE := v_RECORD.REALM_CALC_TYPE;
	p_CUSTOM_QUERY := v_RECORD.CUSTOM_QUERY;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_REALM_NAME := g_EMPTY_VARCHAR2;
		p_REALM_ALIAS := g_EMPTY_VARCHAR2;
		p_REALM_DESC := g_EMPTY_VARCHAR2;
		p_ENTITY_DOMAIN_ID := g_EMPTY_NUMBER;
		p_REALM_CALC_TYPE := g_EMPTY_NUMBER;
		p_CUSTOM_QUERY := g_EMPTY_VARCHAR2;

END GET_SYSTEM_REALM;
---------------------------------------------------------------------
PROCEDURE PUT_SYSTEM_TABLE
	(
	o_OID OUT NUMBER,
	p_TABLE_NAME IN VARCHAR2,
	p_TABLE_ALIAS IN VARCHAR2,
	p_TABLE_DESC IN VARCHAR2,
	p_TABLE_ID IN NUMBER,
	p_DB_TABLE_NAME IN VARCHAR2,
	p_MIRROR_TABLE_NAME IN VARCHAR2,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_KEY_CONSTRAINT_NAME IN VARCHAR2,
	p_ENTITY_ID_COLUMN_NAME IN VARCHAR2,
	p_DATE1_COLUMN_NAME IN VARCHAR2,
	p_DATE2_COLUMN_NAME IN VARCHAR2,
	p_IS_REACTIVE IN NUMBER,
	p_LOCK_SUMMARY_TABLE_NAME IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC SYSTEM_TABLE%ROWTYPE;
BEGIN


	v_REC.TABLE_ID := p_TABLE_ID;
	v_REC.TABLE_NAME := TRIM(p_TABLE_NAME);
	v_REC.TABLE_ALIAS := TRIM(NVL(p_TABLE_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.TABLE_DESC := TRIM(NVL(p_TABLE_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.DB_TABLE_NAME := TRIM(p_DB_TABLE_NAME);
	v_REC.MIRROR_TABLE_NAME := TRIM(p_MIRROR_TABLE_NAME);
	v_REC.ENTITY_DOMAIN_ID := NVL(p_ENTITY_DOMAIN_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.KEY_CONSTRAINT_NAME := TRIM(p_KEY_CONSTRAINT_NAME);
	v_REC.ENTITY_ID_COLUMN_NAME := TRIM(p_ENTITY_ID_COLUMN_NAME);
	v_REC.DATE1_COLUMN_NAME := TRIM(p_DATE1_COLUMN_NAME);
	v_REC.DATE2_COLUMN_NAME := TRIM(p_DATE2_COLUMN_NAME);
	v_REC.IS_REACTIVE := p_IS_REACTIVE;
	v_REC.LOCK_SUMMARY_TABLE_NAME := TRIM(p_LOCK_SUMMARY_TABLE_NAME);
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_TABLE_ID > 0 OR p_TABLE_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_TABLE_ID, EC.ED_SYSTEM_TABLE) 
                 AND IO_UTIL.SYSTEM_TABLE_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_SYSTEM_TABLE, p_TABLE_ID);
		END IF;

		-- save it!
		UPDATE SYSTEM_TABLE
		SET ROW = v_REC
		WHERE TABLE_ID = p_TABLE_ID;
		o_OID := p_TABLE_ID;
        
	ELSIF p_TABLE_ID IS NULL OR p_TABLE_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.SYSTEM_TABLE_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_SYSTEM_TABLE, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.TABLE_ID := o_OID;
		-- save it!
		INSERT INTO SYSTEM_TABLE VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_TABLE_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_SYSTEM_TABLE, EC.ED_ENTITY_DOMAIN)||': '||p_TABLE_NAME);
END PUT_SYSTEM_TABLE;
---------------------------------------------------------------------
PROCEDURE GET_SYSTEM_TABLE
	(
	p_TABLE_ID IN NUMBER,
	p_TABLE_NAME OUT VARCHAR2,
	p_TABLE_ALIAS OUT VARCHAR2,
	p_TABLE_DESC OUT VARCHAR2,
	p_DB_TABLE_NAME OUT VARCHAR2,
	p_MIRROR_TABLE_NAME OUT VARCHAR2,
	p_ENTITY_DOMAIN_ID OUT NUMBER,
	p_KEY_CONSTRAINT_NAME OUT VARCHAR2,
	p_ENTITY_ID_COLUMN_NAME OUT VARCHAR2,
	p_DATE1_COLUMN_NAME OUT VARCHAR2,
	p_DATE2_COLUMN_NAME OUT VARCHAR2,
	p_IS_REACTIVE OUT NUMBER,
	p_LOCK_SUMMARY_TABLE_NAME OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD SYSTEM_TABLE%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_TABLE_ID, EC.ED_SYSTEM_TABLE);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM SYSTEM_TABLE
	WHERE TABLE_ID = p_TABLE_ID;
    
	-- Set the output parameters
	p_TABLE_NAME := v_RECORD.TABLE_NAME;
	p_TABLE_ALIAS := v_RECORD.TABLE_ALIAS;
	p_TABLE_DESC := v_RECORD.TABLE_DESC;
	p_DB_TABLE_NAME := v_RECORD.DB_TABLE_NAME;
	p_MIRROR_TABLE_NAME := v_RECORD.MIRROR_TABLE_NAME;
	p_ENTITY_DOMAIN_ID := v_RECORD.ENTITY_DOMAIN_ID;
	p_KEY_CONSTRAINT_NAME := v_RECORD.KEY_CONSTRAINT_NAME;
	p_ENTITY_ID_COLUMN_NAME := v_RECORD.ENTITY_ID_COLUMN_NAME;
	p_DATE1_COLUMN_NAME := v_RECORD.DATE1_COLUMN_NAME;
	p_DATE2_COLUMN_NAME := v_RECORD.DATE2_COLUMN_NAME;
	p_IS_REACTIVE := v_RECORD.IS_REACTIVE;
	p_LOCK_SUMMARY_TABLE_NAME := v_RECORD.LOCK_SUMMARY_TABLE_NAME;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_TABLE_NAME := g_EMPTY_VARCHAR2;
		p_TABLE_ALIAS := g_EMPTY_VARCHAR2;
		p_TABLE_DESC := g_EMPTY_VARCHAR2;
		p_DB_TABLE_NAME := g_EMPTY_VARCHAR2;
		p_MIRROR_TABLE_NAME := g_EMPTY_VARCHAR2;
		p_ENTITY_DOMAIN_ID := g_EMPTY_NUMBER;
		p_KEY_CONSTRAINT_NAME := g_EMPTY_VARCHAR2;
		p_ENTITY_ID_COLUMN_NAME := g_EMPTY_VARCHAR2;
		p_DATE1_COLUMN_NAME := g_EMPTY_VARCHAR2;
		p_DATE2_COLUMN_NAME := g_EMPTY_VARCHAR2;
		p_IS_REACTIVE := g_EMPTY_NUMBER;
		p_LOCK_SUMMARY_TABLE_NAME := g_EMPTY_VARCHAR2;

END GET_SYSTEM_TABLE;
---------------------------------------------------------------------
PROCEDURE PUT_TEMPLATE
	(
	o_OID OUT NUMBER,
	p_TEMPLATE_NAME IN VARCHAR2,
	p_TEMPLATE_ALIAS IN VARCHAR2,
	p_TEMPLATE_DESC IN VARCHAR2,
	p_TEMPLATE_ID IN NUMBER,
	p_IS_DAY_TYPE IN NUMBER,
	p_IS_DST_OBSERVANT IN NUMBER,
	p_VALIDATION_MESSAGE IN VARCHAR2
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC TEMPLATE%ROWTYPE;
BEGIN


	v_REC.TEMPLATE_ID := p_TEMPLATE_ID;
	v_REC.TEMPLATE_NAME := TRIM(p_TEMPLATE_NAME);
	v_REC.TEMPLATE_ALIAS := TRIM(NVL(p_TEMPLATE_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.TEMPLATE_DESC := TRIM(NVL(p_TEMPLATE_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.IS_DAY_TYPE := p_IS_DAY_TYPE;
	v_REC.IS_DST_OBSERVANT := p_IS_DST_OBSERVANT;
	v_REC.VALIDATION_MESSAGE := TRIM(NVL(p_VALIDATION_MESSAGE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_TEMPLATE_ID > 0 OR p_TEMPLATE_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_TEMPLATE_ID, EC.ED_TEMPLATE) 
                 AND IO_UTIL.TEMPLATE_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_TEMPLATE, p_TEMPLATE_ID);
		END IF;

		-- save it!
		UPDATE TEMPLATE
		SET ROW = v_REC
		WHERE TEMPLATE_ID = p_TEMPLATE_ID;
		o_OID := p_TEMPLATE_ID;
        
	ELSIF p_TEMPLATE_ID IS NULL OR p_TEMPLATE_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.TEMPLATE_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_TEMPLATE, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.TEMPLATE_ID := o_OID;
		-- save it!
		INSERT INTO TEMPLATE VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_TEMPLATE_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_TEMPLATE, EC.ED_ENTITY_DOMAIN)||': '||p_TEMPLATE_NAME);
END PUT_TEMPLATE;
---------------------------------------------------------------------
PROCEDURE GET_TEMPLATE
	(
	p_TEMPLATE_ID IN NUMBER,
	p_TEMPLATE_NAME OUT VARCHAR2,
	p_TEMPLATE_ALIAS OUT VARCHAR2,
	p_TEMPLATE_DESC OUT VARCHAR2,
	p_IS_DAY_TYPE OUT NUMBER,
	p_IS_DST_OBSERVANT OUT NUMBER,
	p_VALIDATION_MESSAGE OUT VARCHAR2
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD TEMPLATE%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_TEMPLATE_ID, EC.ED_TEMPLATE);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM TEMPLATE
	WHERE TEMPLATE_ID = p_TEMPLATE_ID;
    
	-- Set the output parameters
	p_TEMPLATE_NAME := v_RECORD.TEMPLATE_NAME;
	p_TEMPLATE_ALIAS := v_RECORD.TEMPLATE_ALIAS;
	p_TEMPLATE_DESC := v_RECORD.TEMPLATE_DESC;
	p_IS_DAY_TYPE := v_RECORD.IS_DAY_TYPE;
	p_IS_DST_OBSERVANT := v_RECORD.IS_DST_OBSERVANT;
	p_VALIDATION_MESSAGE := v_RECORD.VALIDATION_MESSAGE;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_TEMPLATE_NAME := g_EMPTY_VARCHAR2;
		p_TEMPLATE_ALIAS := g_EMPTY_VARCHAR2;
		p_TEMPLATE_DESC := g_EMPTY_VARCHAR2;
		p_IS_DAY_TYPE := g_EMPTY_NUMBER;
		p_IS_DST_OBSERVANT := g_EMPTY_NUMBER;
		p_VALIDATION_MESSAGE := g_EMPTY_VARCHAR2;

END GET_TEMPLATE;
---------------------------------------------------------------------
PROCEDURE PUT_TP
	(
	o_OID OUT NUMBER,
	p_TP_NAME IN VARCHAR2,
	p_TP_ALIAS IN VARCHAR2,
	p_TP_DESC IN VARCHAR2,
	p_TP_ID IN NUMBER,
	p_TP_NERC_CODE IN VARCHAR2,
	p_TP_STATUS IN VARCHAR2,
	p_TP_DUNS_NUMBER IN VARCHAR2,
	p_OASIS_NODE_ID IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC TRANSMISSION_PROVIDER%ROWTYPE;
BEGIN


	v_REC.TP_ID := p_TP_ID;
	v_REC.TP_NAME := TRIM(p_TP_NAME);
	v_REC.TP_ALIAS := TRIM(NVL(p_TP_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.TP_DESC := TRIM(NVL(p_TP_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.TP_NERC_CODE := TRIM(NVL(p_TP_NERC_CODE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.TP_STATUS := TRIM(NVL(p_TP_STATUS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.TP_DUNS_NUMBER := TRIM(NVL(p_TP_DUNS_NUMBER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.OASIS_NODE_ID := p_OASIS_NODE_ID;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_TP_ID > 0 OR p_TP_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_TP_ID, EC.ED_TP) 
                 AND IO_UTIL.TP_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_TP, p_TP_ID);
		END IF;

		-- save it!
		UPDATE TRANSMISSION_PROVIDER
		SET ROW = v_REC
		WHERE TP_ID = p_TP_ID;
		o_OID := p_TP_ID;
        
	ELSIF p_TP_ID IS NULL OR p_TP_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.TP_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_TP, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.TP_ID := o_OID;
		-- save it!
		INSERT INTO TRANSMISSION_PROVIDER VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_TP_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_TP, EC.ED_ENTITY_DOMAIN)||': '||p_TP_NAME);
END PUT_TP;
---------------------------------------------------------------------
PROCEDURE GET_TP
	(
	p_TP_ID IN NUMBER,
	p_TP_NAME OUT VARCHAR2,
	p_TP_ALIAS OUT VARCHAR2,
	p_TP_DESC OUT VARCHAR2,
	p_TP_NERC_CODE OUT VARCHAR2,
	p_TP_STATUS OUT VARCHAR2,
	p_TP_DUNS_NUMBER OUT VARCHAR2,
	p_OASIS_NODE_ID OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD TRANSMISSION_PROVIDER%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_TP_ID, EC.ED_TP);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM TRANSMISSION_PROVIDER
	WHERE TP_ID = p_TP_ID;
    
	-- Set the output parameters
	p_TP_NAME := v_RECORD.TP_NAME;
	p_TP_ALIAS := v_RECORD.TP_ALIAS;
	p_TP_DESC := v_RECORD.TP_DESC;
	p_TP_NERC_CODE := v_RECORD.TP_NERC_CODE;
	p_TP_STATUS := v_RECORD.TP_STATUS;
	p_TP_DUNS_NUMBER := v_RECORD.TP_DUNS_NUMBER;
	p_OASIS_NODE_ID := v_RECORD.OASIS_NODE_ID;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_TP_NAME := g_EMPTY_VARCHAR2;
		p_TP_ALIAS := g_EMPTY_VARCHAR2;
		p_TP_DESC := g_EMPTY_VARCHAR2;
		p_TP_NERC_CODE := g_EMPTY_VARCHAR2;
		p_TP_STATUS := g_EMPTY_VARCHAR2;
		p_TP_DUNS_NUMBER := g_EMPTY_VARCHAR2;
		p_OASIS_NODE_ID := g_EMPTY_NUMBER;

END GET_TP;
---------------------------------------------------------------------
PROCEDURE PUT_TRANSACTION
	(
	o_OID OUT NUMBER,
	p_TRANSACTION_NAME IN VARCHAR2,
	p_TRANSACTION_ALIAS IN VARCHAR2,
	p_TRANSACTION_DESC IN VARCHAR2,
	p_TRANSACTION_ID IN NUMBER,
	p_TRANSACTION_TYPE IN VARCHAR2,
	p_TRANSACTION_CODE IN VARCHAR2,
	p_TRANSACTION_IDENTIFIER IN VARCHAR2,
	p_IS_FIRM IN NUMBER,
	p_IS_IMPORT_SCHEDULE IN NUMBER,
	p_IS_EXPORT_SCHEDULE IN NUMBER,
	p_IS_BALANCE_TRANSACTION IN NUMBER,
	p_IS_BID_OFFER IN NUMBER,
	p_IS_EXCLUDE_FROM_POSITION IN NUMBER,
	p_IS_IMPORT_EXPORT IN NUMBER,
	p_IS_DISPATCHABLE IN NUMBER,
	p_TRANSACTION_INTERVAL IN VARCHAR2,
	p_EXTERNAL_INTERVAL IN VARCHAR2,
	p_ETAG_CODE IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PURCHASER_ID IN NUMBER,
	p_SELLER_ID IN NUMBER,
	p_CONTRACT_ID IN NUMBER,
	p_SC_ID IN NUMBER,
	p_POR_ID IN NUMBER,
	p_POD_ID IN NUMBER,
	p_COMMODITY_ID IN NUMBER,
	p_SERVICE_TYPE_ID IN NUMBER,
	p_TX_TRANSACTION_ID IN NUMBER,
	p_PATH_ID IN NUMBER,
	p_LINK_TRANSACTION_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_SCHEDULE_GROUP_ID IN NUMBER,
	p_MARKET_PRICE_ID IN NUMBER,
	p_ZOR_ID IN NUMBER,
	p_ZOD_ID IN NUMBER,
	p_SOURCE_ID IN NUMBER,
	p_SINK_ID IN NUMBER,
	p_RESOURCE_ID IN NUMBER,
	p_AGREEMENT_TYPE IN VARCHAR2,
	p_APPROVAL_TYPE IN VARCHAR2,
	p_LOSS_OPTION IN VARCHAR2,
	p_TRAIT_CATEGORY IN VARCHAR2,
	p_TP_ID IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC INTERCHANGE_TRANSACTION%ROWTYPE;
BEGIN


	v_REC.TRANSACTION_ID := p_TRANSACTION_ID;
	v_REC.TRANSACTION_NAME := TRIM(p_TRANSACTION_NAME);
	v_REC.TRANSACTION_ALIAS := TRIM(NVL(p_TRANSACTION_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.TRANSACTION_DESC := TRIM(NVL(p_TRANSACTION_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.TRANSACTION_TYPE := TRIM(NVL(p_TRANSACTION_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.TRANSACTION_CODE := TRIM(NVL(p_TRANSACTION_CODE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.TRANSACTION_IDENTIFIER := TRIM(NVL(p_TRANSACTION_IDENTIFIER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.IS_FIRM := p_IS_FIRM;
	v_REC.IS_IMPORT_SCHEDULE := p_IS_IMPORT_SCHEDULE;
	v_REC.IS_EXPORT_SCHEDULE := p_IS_EXPORT_SCHEDULE;
	v_REC.IS_BALANCE_TRANSACTION := p_IS_BALANCE_TRANSACTION;
	v_REC.IS_BID_OFFER := p_IS_BID_OFFER;
	v_REC.IS_EXCLUDE_FROM_POSITION := p_IS_EXCLUDE_FROM_POSITION;
	v_REC.IS_IMPORT_EXPORT := p_IS_IMPORT_EXPORT;
	v_REC.IS_DISPATCHABLE := p_IS_DISPATCHABLE;
	v_REC.TRANSACTION_INTERVAL := TRIM(NVL(p_TRANSACTION_INTERVAL,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EXTERNAL_INTERVAL := TRIM(NVL(p_EXTERNAL_INTERVAL,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.ETAG_CODE := TRIM(NVL(p_ETAG_CODE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.BEGIN_DATE := p_BEGIN_DATE;
	v_REC.END_DATE := p_END_DATE;
	v_REC.PURCHASER_ID := NVL(p_PURCHASER_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.SELLER_ID := NVL(p_SELLER_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.CONTRACT_ID := NVL(p_CONTRACT_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.SC_ID := NVL(p_SC_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.POR_ID := NVL(p_POR_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.POD_ID := NVL(p_POD_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.COMMODITY_ID := NVL(p_COMMODITY_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.SERVICE_TYPE_ID := NVL(p_SERVICE_TYPE_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.TX_TRANSACTION_ID := NVL(p_TX_TRANSACTION_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.PATH_ID := p_PATH_ID;
	v_REC.LINK_TRANSACTION_ID := NVL(p_LINK_TRANSACTION_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.EDC_ID := NVL(p_EDC_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.PSE_ID := NVL(p_PSE_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.ESP_ID := NVL(p_ESP_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.POOL_ID := NVL(p_POOL_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.SCHEDULE_GROUP_ID := NVL(p_SCHEDULE_GROUP_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.MARKET_PRICE_ID := NVL(p_MARKET_PRICE_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.ZOR_ID := NVL(p_ZOR_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.ZOD_ID := NVL(p_ZOD_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.SOURCE_ID := NVL(p_SOURCE_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.SINK_ID := NVL(p_SINK_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.RESOURCE_ID := p_RESOURCE_ID;
	v_REC.AGREEMENT_TYPE := TRIM(NVL(p_AGREEMENT_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.APPROVAL_TYPE := TRIM(NVL(p_APPROVAL_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.LOSS_OPTION := TRIM(NVL(p_LOSS_OPTION,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.TRAIT_CATEGORY := TRIM(NVL(p_TRAIT_CATEGORY,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.TP_ID := NVL(p_TP_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_TRANSACTION_ID > 0 OR p_TRANSACTION_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_TRANSACTION_ID, EC.ED_TRANSACTION) 
                 AND IO_UTIL.TRANSACTION_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_TRANSACTION, p_TRANSACTION_ID);
		END IF;

		-- save it!
		UPDATE INTERCHANGE_TRANSACTION
		SET ROW = v_REC
		WHERE TRANSACTION_ID = p_TRANSACTION_ID;
		o_OID := p_TRANSACTION_ID;
        
	ELSIF p_TRANSACTION_ID IS NULL OR p_TRANSACTION_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.TRANSACTION_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_TRANSACTION, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.TRANSACTION_ID := o_OID;
		-- save it!
		INSERT INTO INTERCHANGE_TRANSACTION VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_TRANSACTION_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_TRANSACTION, EC.ED_ENTITY_DOMAIN)||': '||p_TRANSACTION_NAME);
END PUT_TRANSACTION;
---------------------------------------------------------------------
PROCEDURE GET_TRANSACTION
	(
	p_TRANSACTION_ID IN NUMBER,
	p_TRANSACTION_NAME OUT VARCHAR2,
	p_TRANSACTION_ALIAS OUT VARCHAR2,
	p_TRANSACTION_DESC OUT VARCHAR2,
	p_TRANSACTION_TYPE OUT VARCHAR2,
	p_TRANSACTION_CODE OUT VARCHAR2,
	p_TRANSACTION_IDENTIFIER OUT VARCHAR2,
	p_IS_FIRM OUT NUMBER,
	p_IS_IMPORT_SCHEDULE OUT NUMBER,
	p_IS_EXPORT_SCHEDULE OUT NUMBER,
	p_IS_BALANCE_TRANSACTION OUT NUMBER,
	p_IS_BID_OFFER OUT NUMBER,
	p_IS_EXCLUDE_FROM_POSITION OUT NUMBER,
	p_IS_IMPORT_EXPORT OUT NUMBER,
	p_IS_DISPATCHABLE OUT NUMBER,
	p_TRANSACTION_INTERVAL OUT VARCHAR2,
	p_EXTERNAL_INTERVAL OUT VARCHAR2,
	p_ETAG_CODE OUT VARCHAR2,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE,
	p_PURCHASER_ID OUT NUMBER,
	p_SELLER_ID OUT NUMBER,
	p_CONTRACT_ID OUT NUMBER,
	p_SC_ID OUT NUMBER,
	p_POR_ID OUT NUMBER,
	p_POD_ID OUT NUMBER,
	p_COMMODITY_ID OUT NUMBER,
	p_SERVICE_TYPE_ID OUT NUMBER,
	p_TX_TRANSACTION_ID OUT NUMBER,
	p_PATH_ID OUT NUMBER,
	p_LINK_TRANSACTION_ID OUT NUMBER,
	p_EDC_ID OUT NUMBER,
	p_PSE_ID OUT NUMBER,
	p_ESP_ID OUT NUMBER,
	p_POOL_ID OUT NUMBER,
	p_SCHEDULE_GROUP_ID OUT NUMBER,
	p_MARKET_PRICE_ID OUT NUMBER,
	p_ZOR_ID OUT NUMBER,
	p_ZOD_ID OUT NUMBER,
	p_SOURCE_ID OUT NUMBER,
	p_SINK_ID OUT NUMBER,
	p_RESOURCE_ID OUT NUMBER,
	p_AGREEMENT_TYPE OUT VARCHAR2,
	p_APPROVAL_TYPE OUT VARCHAR2,
	p_LOSS_OPTION OUT VARCHAR2,
	p_TRAIT_CATEGORY OUT VARCHAR2,
	p_TP_ID OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD INTERCHANGE_TRANSACTION%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_TRANSACTION_ID, EC.ED_TRANSACTION);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM INTERCHANGE_TRANSACTION
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;
    
	-- Set the output parameters
	p_TRANSACTION_NAME := v_RECORD.TRANSACTION_NAME;
	p_TRANSACTION_ALIAS := v_RECORD.TRANSACTION_ALIAS;
	p_TRANSACTION_DESC := v_RECORD.TRANSACTION_DESC;
	p_TRANSACTION_TYPE := v_RECORD.TRANSACTION_TYPE;
	p_TRANSACTION_CODE := v_RECORD.TRANSACTION_CODE;
	p_TRANSACTION_IDENTIFIER := v_RECORD.TRANSACTION_IDENTIFIER;
	p_IS_FIRM := v_RECORD.IS_FIRM;
	p_IS_IMPORT_SCHEDULE := v_RECORD.IS_IMPORT_SCHEDULE;
	p_IS_EXPORT_SCHEDULE := v_RECORD.IS_EXPORT_SCHEDULE;
	p_IS_BALANCE_TRANSACTION := v_RECORD.IS_BALANCE_TRANSACTION;
	p_IS_BID_OFFER := v_RECORD.IS_BID_OFFER;
	p_IS_EXCLUDE_FROM_POSITION := v_RECORD.IS_EXCLUDE_FROM_POSITION;
	p_IS_IMPORT_EXPORT := v_RECORD.IS_IMPORT_EXPORT;
	p_IS_DISPATCHABLE := v_RECORD.IS_DISPATCHABLE;
	p_TRANSACTION_INTERVAL := v_RECORD.TRANSACTION_INTERVAL;
	p_EXTERNAL_INTERVAL := v_RECORD.EXTERNAL_INTERVAL;
	p_ETAG_CODE := v_RECORD.ETAG_CODE;
	p_BEGIN_DATE := v_RECORD.BEGIN_DATE;
	p_END_DATE := v_RECORD.END_DATE;
	p_PURCHASER_ID := v_RECORD.PURCHASER_ID;
	p_SELLER_ID := v_RECORD.SELLER_ID;
	p_CONTRACT_ID := v_RECORD.CONTRACT_ID;
	p_SC_ID := v_RECORD.SC_ID;
	p_POR_ID := v_RECORD.POR_ID;
	p_POD_ID := v_RECORD.POD_ID;
	p_COMMODITY_ID := v_RECORD.COMMODITY_ID;
	p_SERVICE_TYPE_ID := v_RECORD.SERVICE_TYPE_ID;
	p_TX_TRANSACTION_ID := v_RECORD.TX_TRANSACTION_ID;
	p_PATH_ID := v_RECORD.PATH_ID;
	p_LINK_TRANSACTION_ID := v_RECORD.LINK_TRANSACTION_ID;
	p_EDC_ID := v_RECORD.EDC_ID;
	p_PSE_ID := v_RECORD.PSE_ID;
	p_ESP_ID := v_RECORD.ESP_ID;
	p_POOL_ID := v_RECORD.POOL_ID;
	p_SCHEDULE_GROUP_ID := v_RECORD.SCHEDULE_GROUP_ID;
	p_MARKET_PRICE_ID := v_RECORD.MARKET_PRICE_ID;
	p_ZOR_ID := v_RECORD.ZOR_ID;
	p_ZOD_ID := v_RECORD.ZOD_ID;
	p_SOURCE_ID := v_RECORD.SOURCE_ID;
	p_SINK_ID := v_RECORD.SINK_ID;
	p_RESOURCE_ID := v_RECORD.RESOURCE_ID;
	p_AGREEMENT_TYPE := v_RECORD.AGREEMENT_TYPE;
	p_APPROVAL_TYPE := v_RECORD.APPROVAL_TYPE;
	p_LOSS_OPTION := v_RECORD.LOSS_OPTION;
	p_TRAIT_CATEGORY := v_RECORD.TRAIT_CATEGORY;
	p_TP_ID := v_RECORD.TP_ID;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_TRANSACTION_NAME := g_EMPTY_VARCHAR2;
		p_TRANSACTION_ALIAS := g_EMPTY_VARCHAR2;
		p_TRANSACTION_DESC := g_EMPTY_VARCHAR2;
		p_TRANSACTION_TYPE := g_EMPTY_VARCHAR2;
		p_TRANSACTION_CODE := g_EMPTY_VARCHAR2;
		p_TRANSACTION_IDENTIFIER := g_EMPTY_VARCHAR2;
		p_IS_FIRM := g_EMPTY_NUMBER;
		p_IS_IMPORT_SCHEDULE := g_EMPTY_NUMBER;
		p_IS_EXPORT_SCHEDULE := g_EMPTY_NUMBER;
		p_IS_BALANCE_TRANSACTION := g_EMPTY_NUMBER;
		p_IS_BID_OFFER := g_EMPTY_NUMBER;
		p_IS_EXCLUDE_FROM_POSITION := g_EMPTY_NUMBER;
		p_IS_IMPORT_EXPORT := g_EMPTY_NUMBER;
		p_IS_DISPATCHABLE := g_EMPTY_NUMBER;
		p_TRANSACTION_INTERVAL := g_EMPTY_VARCHAR2;
		p_EXTERNAL_INTERVAL := g_EMPTY_VARCHAR2;
		p_ETAG_CODE := g_EMPTY_VARCHAR2;
		p_BEGIN_DATE := g_EMPTY_DATE;
		p_END_DATE := g_EMPTY_DATE;
		p_PURCHASER_ID := g_EMPTY_NUMBER;
		p_SELLER_ID := g_EMPTY_NUMBER;
		p_CONTRACT_ID := g_EMPTY_NUMBER;
		p_SC_ID := g_EMPTY_NUMBER;
		p_POR_ID := g_EMPTY_NUMBER;
		p_POD_ID := g_EMPTY_NUMBER;
		p_COMMODITY_ID := g_EMPTY_NUMBER;
		p_SERVICE_TYPE_ID := g_EMPTY_NUMBER;
		p_TX_TRANSACTION_ID := g_EMPTY_NUMBER;
		p_PATH_ID := g_EMPTY_NUMBER;
		p_LINK_TRANSACTION_ID := g_EMPTY_NUMBER;
		p_EDC_ID := g_EMPTY_NUMBER;
		p_PSE_ID := g_EMPTY_NUMBER;
		p_ESP_ID := g_EMPTY_NUMBER;
		p_POOL_ID := g_EMPTY_NUMBER;
		p_SCHEDULE_GROUP_ID := g_EMPTY_NUMBER;
		p_MARKET_PRICE_ID := g_EMPTY_NUMBER;
		p_ZOR_ID := g_EMPTY_NUMBER;
		p_ZOD_ID := g_EMPTY_NUMBER;
		p_SOURCE_ID := g_EMPTY_NUMBER;
		p_SINK_ID := g_EMPTY_NUMBER;
		p_RESOURCE_ID := g_EMPTY_NUMBER;
		p_AGREEMENT_TYPE := g_EMPTY_VARCHAR2;
		p_APPROVAL_TYPE := g_EMPTY_VARCHAR2;
		p_LOSS_OPTION := g_EMPTY_VARCHAR2;
		p_TRAIT_CATEGORY := g_EMPTY_VARCHAR2;
		p_TP_ID := g_EMPTY_NUMBER;

END GET_TRANSACTION;
---------------------------------------------------------------------
PROCEDURE PUT_TRANSACTION_TRAIT_GROUP
	(
	o_OID OUT NUMBER,
	p_TRAIT_GROUP_NAME IN VARCHAR2,
	p_TRAIT_GROUP_ALIAS IN VARCHAR2,
	p_TRAIT_GROUP_DESC IN VARCHAR2,
	p_TRAIT_GROUP_ID IN NUMBER,
	p_TRAIT_GROUP_INTERVAL IN VARCHAR2,
	p_TRAIT_GROUP_TYPE IN VARCHAR2,
	p_SC_ID IN NUMBER,
	p_TRAIT_CATEGORY IN VARCHAR2,
	p_DISPLAY_NAME IN VARCHAR2,
	p_DISPLAY_ORDER IN NUMBER,
	p_IS_SERIES IN NUMBER,
	p_IS_SPARSE IN NUMBER,
	p_IS_STATEMENT_TYPE_SPECIFIC IN NUMBER,
	p_DEFAULT_NUMBER_OF_SETS IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC TRANSACTION_TRAIT_GROUP%ROWTYPE;
BEGIN


	v_REC.TRAIT_GROUP_ID := p_TRAIT_GROUP_ID;
	v_REC.TRAIT_GROUP_NAME := TRIM(p_TRAIT_GROUP_NAME);
	v_REC.TRAIT_GROUP_ALIAS := TRIM(NVL(p_TRAIT_GROUP_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.TRAIT_GROUP_DESC := TRIM(NVL(p_TRAIT_GROUP_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.TRAIT_GROUP_INTERVAL := TRIM(NVL(p_TRAIT_GROUP_INTERVAL,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.TRAIT_GROUP_TYPE := TRIM(NVL(p_TRAIT_GROUP_TYPE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SC_ID := NVL(p_SC_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.TRAIT_CATEGORY := TRIM(NVL(p_TRAIT_CATEGORY,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.DISPLAY_NAME := TRIM(NVL(p_DISPLAY_NAME,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.DISPLAY_ORDER := p_DISPLAY_ORDER;
	v_REC.IS_SERIES := p_IS_SERIES;
	v_REC.IS_SPARSE := p_IS_SPARSE;
	v_REC.IS_STATEMENT_TYPE_SPECIFIC := p_IS_STATEMENT_TYPE_SPECIFIC;
	v_REC.DEFAULT_NUMBER_OF_SETS := p_DEFAULT_NUMBER_OF_SETS;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_TRAIT_GROUP_ID > 0 OR p_TRAIT_GROUP_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_TRAIT_GROUP_ID, EC.ED_TRANSACTION_TRAIT_GROUP) 
                 AND IO_UTIL.TRANSACTION_TRAIT_GROUP_IS_ALL (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_TRANSACTION_TRAIT_GROUP, p_TRAIT_GROUP_ID);
		END IF;

		-- save it!
		UPDATE TRANSACTION_TRAIT_GROUP
		SET ROW = v_REC
		WHERE TRAIT_GROUP_ID = p_TRAIT_GROUP_ID;
		o_OID := p_TRAIT_GROUP_ID;
        
	ELSIF p_TRAIT_GROUP_ID IS NULL OR p_TRAIT_GROUP_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.TRANSACTION_TRAIT_GROUP_IS_ALL (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_TRANSACTION_TRAIT_GROUP, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.TRAIT_GROUP_ID := o_OID;
		-- save it!
		INSERT INTO TRANSACTION_TRAIT_GROUP VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_TRAIT_GROUP_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_TRANSACTION_TRAIT_GROUP, EC.ED_ENTITY_DOMAIN)||': '||p_TRAIT_GROUP_NAME);
END PUT_TRANSACTION_TRAIT_GROUP;
---------------------------------------------------------------------
PROCEDURE GET_TRANSACTION_TRAIT_GROUP
	(
	p_TRAIT_GROUP_ID IN NUMBER,
	p_TRAIT_GROUP_NAME OUT VARCHAR2,
	p_TRAIT_GROUP_ALIAS OUT VARCHAR2,
	p_TRAIT_GROUP_DESC OUT VARCHAR2,
	p_TRAIT_GROUP_INTERVAL OUT VARCHAR2,
	p_TRAIT_GROUP_TYPE OUT VARCHAR2,
	p_SC_ID OUT NUMBER,
	p_TRAIT_CATEGORY OUT VARCHAR2,
	p_DISPLAY_NAME OUT VARCHAR2,
	p_DISPLAY_ORDER OUT NUMBER,
	p_IS_SERIES OUT NUMBER,
	p_IS_SPARSE OUT NUMBER,
	p_IS_STATEMENT_TYPE_SPECIFIC OUT NUMBER,
	p_DEFAULT_NUMBER_OF_SETS OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD TRANSACTION_TRAIT_GROUP%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_TRAIT_GROUP_ID, EC.ED_TRANSACTION_TRAIT_GROUP);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM TRANSACTION_TRAIT_GROUP
	WHERE TRAIT_GROUP_ID = p_TRAIT_GROUP_ID;
    
	-- Set the output parameters
	p_TRAIT_GROUP_NAME := v_RECORD.TRAIT_GROUP_NAME;
	p_TRAIT_GROUP_ALIAS := v_RECORD.TRAIT_GROUP_ALIAS;
	p_TRAIT_GROUP_DESC := v_RECORD.TRAIT_GROUP_DESC;
	p_TRAIT_GROUP_INTERVAL := v_RECORD.TRAIT_GROUP_INTERVAL;
	p_TRAIT_GROUP_TYPE := v_RECORD.TRAIT_GROUP_TYPE;
	p_SC_ID := v_RECORD.SC_ID;
	p_TRAIT_CATEGORY := v_RECORD.TRAIT_CATEGORY;
	p_DISPLAY_NAME := v_RECORD.DISPLAY_NAME;
	p_DISPLAY_ORDER := v_RECORD.DISPLAY_ORDER;
	p_IS_SERIES := v_RECORD.IS_SERIES;
	p_IS_SPARSE := v_RECORD.IS_SPARSE;
	p_IS_STATEMENT_TYPE_SPECIFIC := v_RECORD.IS_STATEMENT_TYPE_SPECIFIC;
	p_DEFAULT_NUMBER_OF_SETS := v_RECORD.DEFAULT_NUMBER_OF_SETS;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_TRAIT_GROUP_NAME := g_EMPTY_VARCHAR2;
		p_TRAIT_GROUP_ALIAS := g_EMPTY_VARCHAR2;
		p_TRAIT_GROUP_DESC := g_EMPTY_VARCHAR2;
		p_TRAIT_GROUP_INTERVAL := g_EMPTY_VARCHAR2;
		p_TRAIT_GROUP_TYPE := g_EMPTY_VARCHAR2;
		p_SC_ID := g_EMPTY_NUMBER;
		p_TRAIT_CATEGORY := g_EMPTY_VARCHAR2;
		p_DISPLAY_NAME := g_EMPTY_VARCHAR2;
		p_DISPLAY_ORDER := g_EMPTY_NUMBER;
		p_IS_SERIES := g_EMPTY_NUMBER;
		p_IS_SPARSE := g_EMPTY_NUMBER;
		p_IS_STATEMENT_TYPE_SPECIFIC := g_EMPTY_NUMBER;
		p_DEFAULT_NUMBER_OF_SETS := g_EMPTY_NUMBER;

END GET_TRANSACTION_TRAIT_GROUP;
---------------------------------------------------------------------
PROCEDURE PUT_TX_FEEDER
	(
	o_OID OUT NUMBER,
	p_FEEDER_NAME IN VARCHAR2,
	p_FEEDER_ALIAS IN VARCHAR2,
	p_FEEDER_DESC IN VARCHAR2,
	p_FEEDER_ID IN NUMBER,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_SUB_STATION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC TX_FEEDER%ROWTYPE;
BEGIN


	v_REC.FEEDER_ID := p_FEEDER_ID;
	v_REC.FEEDER_NAME := TRIM(p_FEEDER_NAME);
	v_REC.FEEDER_ALIAS := TRIM(NVL(p_FEEDER_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.FEEDER_DESC := TRIM(NVL(p_FEEDER_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EXTERNAL_IDENTIFIER := TRIM(NVL(p_EXTERNAL_IDENTIFIER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SUB_STATION_ID := NVL(p_SUB_STATION_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.BEGIN_DATE := p_BEGIN_DATE;
	v_REC.END_DATE := p_END_DATE;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_FEEDER_ID > 0 OR p_FEEDER_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_FEEDER_ID, EC.ED_TX_FEEDER) 
                 AND IO_UTIL.TX_FEEDER_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_TX_FEEDER, p_FEEDER_ID);
		END IF;

		-- save it!
		UPDATE TX_FEEDER
		SET ROW = v_REC
		WHERE FEEDER_ID = p_FEEDER_ID;
		o_OID := p_FEEDER_ID;
        
	ELSIF p_FEEDER_ID IS NULL OR p_FEEDER_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.TX_FEEDER_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_TX_FEEDER, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.FEEDER_ID := o_OID;
		-- save it!
		INSERT INTO TX_FEEDER VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_FEEDER_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_TX_FEEDER, EC.ED_ENTITY_DOMAIN)||': '||p_FEEDER_NAME);
END PUT_TX_FEEDER;
---------------------------------------------------------------------
PROCEDURE GET_TX_FEEDER
	(
	p_FEEDER_ID IN NUMBER,
	p_FEEDER_NAME OUT VARCHAR2,
	p_FEEDER_ALIAS OUT VARCHAR2,
	p_FEEDER_DESC OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_SUB_STATION_ID OUT NUMBER,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD TX_FEEDER%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_FEEDER_ID, EC.ED_TX_FEEDER);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM TX_FEEDER
	WHERE FEEDER_ID = p_FEEDER_ID;
    
	-- Set the output parameters
	p_FEEDER_NAME := v_RECORD.FEEDER_NAME;
	p_FEEDER_ALIAS := v_RECORD.FEEDER_ALIAS;
	p_FEEDER_DESC := v_RECORD.FEEDER_DESC;
	p_EXTERNAL_IDENTIFIER := v_RECORD.EXTERNAL_IDENTIFIER;
	p_SUB_STATION_ID := v_RECORD.SUB_STATION_ID;
	p_BEGIN_DATE := v_RECORD.BEGIN_DATE;
	p_END_DATE := v_RECORD.END_DATE;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_FEEDER_NAME := g_EMPTY_VARCHAR2;
		p_FEEDER_ALIAS := g_EMPTY_VARCHAR2;
		p_FEEDER_DESC := g_EMPTY_VARCHAR2;
		p_EXTERNAL_IDENTIFIER := g_EMPTY_VARCHAR2;
		p_SUB_STATION_ID := g_EMPTY_NUMBER;
		p_BEGIN_DATE := g_EMPTY_DATE;
		p_END_DATE := g_EMPTY_DATE;

END GET_TX_FEEDER;
---------------------------------------------------------------------
PROCEDURE PUT_TX_FEEDER_SEGMENT
	(
	o_OID OUT NUMBER,
	p_FEEDER_SEGMENT_NAME IN VARCHAR2,
	p_FEEDER_SEGMENT_ALIAS IN VARCHAR2,
	p_FEEDER_SEGMENT_DESC IN VARCHAR2,
	p_FEEDER_SEGMENT_ID IN NUMBER,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_FEEDER_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PRIORITY IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC TX_FEEDER_SEGMENT%ROWTYPE;
BEGIN


	v_REC.FEEDER_SEGMENT_ID := p_FEEDER_SEGMENT_ID;
	v_REC.FEEDER_SEGMENT_NAME := TRIM(p_FEEDER_SEGMENT_NAME);
	v_REC.FEEDER_SEGMENT_ALIAS := TRIM(NVL(p_FEEDER_SEGMENT_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.FEEDER_SEGMENT_DESC := TRIM(NVL(p_FEEDER_SEGMENT_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EXTERNAL_IDENTIFIER := TRIM(NVL(p_EXTERNAL_IDENTIFIER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.FEEDER_ID := NVL(p_FEEDER_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.BEGIN_DATE := p_BEGIN_DATE;
	v_REC.END_DATE := p_END_DATE;
	v_REC.PRIORITY := p_PRIORITY;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_FEEDER_SEGMENT_ID > 0 OR p_FEEDER_SEGMENT_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_FEEDER_SEGMENT_ID, EC.ED_TX_FEEDER_SEGMENT) 
                 AND IO_UTIL.TX_FEEDER_SEGMENT_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_TX_FEEDER_SEGMENT, p_FEEDER_SEGMENT_ID);
		END IF;

		-- save it!
		UPDATE TX_FEEDER_SEGMENT
		SET ROW = v_REC
		WHERE FEEDER_SEGMENT_ID = p_FEEDER_SEGMENT_ID;
		o_OID := p_FEEDER_SEGMENT_ID;
        
	ELSIF p_FEEDER_SEGMENT_ID IS NULL OR p_FEEDER_SEGMENT_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.TX_FEEDER_SEGMENT_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_TX_FEEDER_SEGMENT, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.FEEDER_SEGMENT_ID := o_OID;
		-- save it!
		INSERT INTO TX_FEEDER_SEGMENT VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_FEEDER_SEGMENT_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_TX_FEEDER_SEGMENT, EC.ED_ENTITY_DOMAIN)||': '||p_FEEDER_SEGMENT_NAME);
END PUT_TX_FEEDER_SEGMENT;
---------------------------------------------------------------------
PROCEDURE GET_TX_FEEDER_SEGMENT
	(
	p_FEEDER_SEGMENT_ID IN NUMBER,
	p_FEEDER_SEGMENT_NAME OUT VARCHAR2,
	p_FEEDER_SEGMENT_ALIAS OUT VARCHAR2,
	p_FEEDER_SEGMENT_DESC OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_FEEDER_ID OUT NUMBER,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE,
	p_PRIORITY OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD TX_FEEDER_SEGMENT%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_FEEDER_SEGMENT_ID, EC.ED_TX_FEEDER_SEGMENT);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM TX_FEEDER_SEGMENT
	WHERE FEEDER_SEGMENT_ID = p_FEEDER_SEGMENT_ID;
    
	-- Set the output parameters
	p_FEEDER_SEGMENT_NAME := v_RECORD.FEEDER_SEGMENT_NAME;
	p_FEEDER_SEGMENT_ALIAS := v_RECORD.FEEDER_SEGMENT_ALIAS;
	p_FEEDER_SEGMENT_DESC := v_RECORD.FEEDER_SEGMENT_DESC;
	p_EXTERNAL_IDENTIFIER := v_RECORD.EXTERNAL_IDENTIFIER;
	p_FEEDER_ID := v_RECORD.FEEDER_ID;
	p_BEGIN_DATE := v_RECORD.BEGIN_DATE;
	p_END_DATE := v_RECORD.END_DATE;
	p_PRIORITY := v_RECORD.PRIORITY;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_FEEDER_SEGMENT_NAME := g_EMPTY_VARCHAR2;
		p_FEEDER_SEGMENT_ALIAS := g_EMPTY_VARCHAR2;
		p_FEEDER_SEGMENT_DESC := g_EMPTY_VARCHAR2;
		p_EXTERNAL_IDENTIFIER := g_EMPTY_VARCHAR2;
		p_FEEDER_ID := g_EMPTY_NUMBER;
		p_BEGIN_DATE := g_EMPTY_DATE;
		p_END_DATE := g_EMPTY_DATE;
		p_PRIORITY := g_EMPTY_NUMBER;

END GET_TX_FEEDER_SEGMENT;
---------------------------------------------------------------------
PROCEDURE PUT_USAGE_WRF
	(
	o_OID OUT NUMBER,
	p_WRF_NAME IN VARCHAR2,
	p_WRF_ALIAS IN VARCHAR2,
	p_WRF_DESC IN VARCHAR2,
	p_WRF_ID IN NUMBER,
	p_STATION_ID IN NUMBER,
	p_PARAMETER_ID IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC USAGE_WRF%ROWTYPE;
BEGIN
	-- Make sure user has access
	IF NOT CAN_WRITE('Data Setup') THEN
        ERRS.RAISE_NO_WRITE_MODULE('Data Setup');
	END IF;



	v_REC.WRF_ID := p_WRF_ID;
	v_REC.WRF_NAME := TRIM(p_WRF_NAME);
	v_REC.WRF_ALIAS := TRIM(NVL(p_WRF_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.WRF_DESC := TRIM(NVL(p_WRF_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.STATION_ID := NVL(p_STATION_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.PARAMETER_ID := NVL(p_PARAMETER_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_WRF_ID > 0 OR p_WRF_ID < -10 THEN

		-- save it!
		UPDATE USAGE_WRF
		SET ROW = v_REC
		WHERE WRF_ID = p_WRF_ID;
		o_OID := p_WRF_ID;
        
	ELSIF p_WRF_ID IS NULL OR p_WRF_ID = 0 THEN

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.WRF_ID := o_OID;
		-- save it!
		INSERT INTO USAGE_WRF VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_WRF_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, 'USAGE_WRF: '||p_WRF_NAME);
END PUT_USAGE_WRF;
---------------------------------------------------------------------
PROCEDURE GET_USAGE_WRF
	(
	p_WRF_ID IN NUMBER,
	p_WRF_NAME OUT VARCHAR2,
	p_WRF_ALIAS OUT VARCHAR2,
	p_WRF_DESC OUT VARCHAR2,
	p_STATION_ID OUT NUMBER,
	p_PARAMETER_ID OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD USAGE_WRF%ROWTYPE;
BEGIN
	-- Make sure user has access
	IF NOT CAN_READ('Data Setup') THEN
        ERRS.RAISE_NO_READ_MODULE('Data Setup');
	END IF;

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM USAGE_WRF
	WHERE WRF_ID = p_WRF_ID;
    
	-- Set the output parameters
	p_WRF_NAME := v_RECORD.WRF_NAME;
	p_WRF_ALIAS := v_RECORD.WRF_ALIAS;
	p_WRF_DESC := v_RECORD.WRF_DESC;
	p_STATION_ID := v_RECORD.STATION_ID;
	p_PARAMETER_ID := v_RECORD.PARAMETER_ID;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_WRF_NAME := g_EMPTY_VARCHAR2;
		p_WRF_ALIAS := g_EMPTY_VARCHAR2;
		p_WRF_DESC := g_EMPTY_VARCHAR2;
		p_STATION_ID := g_EMPTY_NUMBER;
		p_PARAMETER_ID := g_EMPTY_NUMBER;

END GET_USAGE_WRF;
---------------------------------------------------------------------
PROCEDURE PUT_VPP
	(
	o_OID OUT NUMBER,
	p_VPP_NAME IN VARCHAR2,
	p_VPP_ALIAS IN VARCHAR2,
	p_VPP_DESC IN VARCHAR2,
	p_VPP_ID IN NUMBER,
	p_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_STATUS_NAME IN VARCHAR2,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_PROGRAM_ID IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC VIRTUAL_POWER_PLANT%ROWTYPE;
BEGIN


	v_REC.VPP_ID := p_VPP_ID;
	v_REC.VPP_NAME := TRIM(p_VPP_NAME);
	v_REC.VPP_ALIAS := TRIM(NVL(p_VPP_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.VPP_DESC := TRIM(NVL(p_VPP_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.EXTERNAL_IDENTIFIER := TRIM(NVL(p_EXTERNAL_IDENTIFIER,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.STATUS_NAME := TRIM(NVL(p_STATUS_NAME,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.SERVICE_ZONE_ID := NVL(p_SERVICE_ZONE_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.PROGRAM_ID := NVL(p_PROGRAM_ID,CONSTANTS.NOT_ASSIGNED);
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_VPP_ID > 0 OR p_VPP_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_VPP_ID, EC.ED_VPP) 
                 AND IO_UTIL.VPP_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_VPP, p_VPP_ID);
		END IF;

		-- save it!
		UPDATE VIRTUAL_POWER_PLANT
		SET ROW = v_REC
		WHERE VPP_ID = p_VPP_ID;
		o_OID := p_VPP_ID;
        
	ELSIF p_VPP_ID IS NULL OR p_VPP_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.VPP_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_VPP, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.VPP_ID := o_OID;
		-- save it!
		INSERT INTO VIRTUAL_POWER_PLANT VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_VPP_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_VPP, EC.ED_ENTITY_DOMAIN)||': '||p_VPP_NAME);
END PUT_VPP;
---------------------------------------------------------------------
PROCEDURE GET_VPP
	(
	p_VPP_ID IN NUMBER,
	p_VPP_NAME OUT VARCHAR2,
	p_VPP_ALIAS OUT VARCHAR2,
	p_VPP_DESC OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_STATUS_NAME OUT VARCHAR2,
	p_SERVICE_ZONE_ID OUT NUMBER,
	p_PROGRAM_ID OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD VIRTUAL_POWER_PLANT%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_VPP_ID, EC.ED_VPP);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM VIRTUAL_POWER_PLANT
	WHERE VPP_ID = p_VPP_ID;
    
	-- Set the output parameters
	p_VPP_NAME := v_RECORD.VPP_NAME;
	p_VPP_ALIAS := v_RECORD.VPP_ALIAS;
	p_VPP_DESC := v_RECORD.VPP_DESC;
	p_EXTERNAL_IDENTIFIER := v_RECORD.EXTERNAL_IDENTIFIER;
	p_STATUS_NAME := v_RECORD.STATUS_NAME;
	p_SERVICE_ZONE_ID := v_RECORD.SERVICE_ZONE_ID;
	p_PROGRAM_ID := v_RECORD.PROGRAM_ID;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_VPP_NAME := g_EMPTY_VARCHAR2;
		p_VPP_ALIAS := g_EMPTY_VARCHAR2;
		p_VPP_DESC := g_EMPTY_VARCHAR2;
		p_EXTERNAL_IDENTIFIER := g_EMPTY_VARCHAR2;
		p_STATUS_NAME := g_EMPTY_VARCHAR2;
		p_SERVICE_ZONE_ID := g_EMPTY_NUMBER;
		p_PROGRAM_ID := g_EMPTY_NUMBER;

END GET_VPP;
---------------------------------------------------------------------
PROCEDURE PUT_WEATHER_PARAMETER
	(
	o_OID OUT NUMBER,
	p_PARAMETER_NAME IN VARCHAR2,
	p_PARAMETER_ALIAS IN VARCHAR2,
	p_PARAMETER_DESC IN VARCHAR2,
	p_PARAMETER_ID IN NUMBER,
	p_PARAMETER_CATEGORY IN VARCHAR2,
	p_PARAMETER_INTERVAL IN VARCHAR2,
	p_PARAMETER_MEASUREMENT IN VARCHAR2,
	p_PROJECTION_PERIOD IN VARCHAR2,
	p_IS_COMPOSITE IN NUMBER,
	p_IS_CALCULATE IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC WEATHER_PARAMETER%ROWTYPE;
BEGIN


	v_REC.PARAMETER_ID := p_PARAMETER_ID;
	v_REC.PARAMETER_NAME := TRIM(p_PARAMETER_NAME);
	v_REC.PARAMETER_ALIAS := TRIM(NVL(p_PARAMETER_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PARAMETER_DESC := TRIM(NVL(p_PARAMETER_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PARAMETER_CATEGORY := TRIM(NVL(p_PARAMETER_CATEGORY,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PARAMETER_INTERVAL := TRIM(NVL(p_PARAMETER_INTERVAL,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PARAMETER_MEASUREMENT := TRIM(NVL(p_PARAMETER_MEASUREMENT,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.PROJECTION_PERIOD := TRIM(NVL(p_PROJECTION_PERIOD,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.IS_COMPOSITE := p_IS_COMPOSITE;
	v_REC.IS_CALCULATE := p_IS_CALCULATE;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_PARAMETER_ID > 0 OR p_PARAMETER_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_PARAMETER_ID, EC.ED_WEATHER_PARAMETER) 
                 AND IO_UTIL.WEATHER_PARAMETER_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_WEATHER_PARAMETER, p_PARAMETER_ID);
		END IF;

		-- save it!
		UPDATE WEATHER_PARAMETER
		SET ROW = v_REC
		WHERE PARAMETER_ID = p_PARAMETER_ID;
		o_OID := p_PARAMETER_ID;
        
	ELSIF p_PARAMETER_ID IS NULL OR p_PARAMETER_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.WEATHER_PARAMETER_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_WEATHER_PARAMETER, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.PARAMETER_ID := o_OID;
		-- save it!
		INSERT INTO WEATHER_PARAMETER VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_PARAMETER_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_WEATHER_PARAMETER, EC.ED_ENTITY_DOMAIN)||': '||p_PARAMETER_NAME);
END PUT_WEATHER_PARAMETER;
---------------------------------------------------------------------
PROCEDURE GET_WEATHER_PARAMETER
	(
	p_PARAMETER_ID IN NUMBER,
	p_PARAMETER_NAME OUT VARCHAR2,
	p_PARAMETER_ALIAS OUT VARCHAR2,
	p_PARAMETER_DESC OUT VARCHAR2,
	p_PARAMETER_CATEGORY OUT VARCHAR2,
	p_PARAMETER_INTERVAL OUT VARCHAR2,
	p_PARAMETER_MEASUREMENT OUT VARCHAR2,
	p_PROJECTION_PERIOD OUT VARCHAR2,
	p_IS_COMPOSITE OUT NUMBER,
	p_IS_CALCULATE OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD WEATHER_PARAMETER%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_PARAMETER_ID, EC.ED_WEATHER_PARAMETER);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM WEATHER_PARAMETER
	WHERE PARAMETER_ID = p_PARAMETER_ID;
    
	-- Set the output parameters
	p_PARAMETER_NAME := v_RECORD.PARAMETER_NAME;
	p_PARAMETER_ALIAS := v_RECORD.PARAMETER_ALIAS;
	p_PARAMETER_DESC := v_RECORD.PARAMETER_DESC;
	p_PARAMETER_CATEGORY := v_RECORD.PARAMETER_CATEGORY;
	p_PARAMETER_INTERVAL := v_RECORD.PARAMETER_INTERVAL;
	p_PARAMETER_MEASUREMENT := v_RECORD.PARAMETER_MEASUREMENT;
	p_PROJECTION_PERIOD := v_RECORD.PROJECTION_PERIOD;
	p_IS_COMPOSITE := v_RECORD.IS_COMPOSITE;
	p_IS_CALCULATE := v_RECORD.IS_CALCULATE;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_PARAMETER_NAME := g_EMPTY_VARCHAR2;
		p_PARAMETER_ALIAS := g_EMPTY_VARCHAR2;
		p_PARAMETER_DESC := g_EMPTY_VARCHAR2;
		p_PARAMETER_CATEGORY := g_EMPTY_VARCHAR2;
		p_PARAMETER_INTERVAL := g_EMPTY_VARCHAR2;
		p_PARAMETER_MEASUREMENT := g_EMPTY_VARCHAR2;
		p_PROJECTION_PERIOD := g_EMPTY_VARCHAR2;
		p_IS_COMPOSITE := g_EMPTY_NUMBER;
		p_IS_CALCULATE := g_EMPTY_NUMBER;

END GET_WEATHER_PARAMETER;
---------------------------------------------------------------------
PROCEDURE PUT_WEATHER_STATION
	(
	o_OID OUT NUMBER,
	p_STATION_NAME IN VARCHAR2,
	p_STATION_ALIAS IN VARCHAR2,
	p_STATION_DESC IN VARCHAR2,
	p_STATION_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_IS_COMPOSITE IN NUMBER
	) AS
-- Create or replace the specified entity
-- Answer its OID or -1 if duplicate name
v_COUNT BINARY_INTEGER := 0;
v_REC WEATHER_STATION%ROWTYPE;
BEGIN


	v_REC.STATION_ID := p_STATION_ID;
	v_REC.STATION_NAME := TRIM(p_STATION_NAME);
	v_REC.STATION_ALIAS := TRIM(NVL(p_STATION_ALIAS,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.STATION_DESC := TRIM(NVL(p_STATION_DESC,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.TIME_ZONE := TRIM(NVL(p_TIME_ZONE,CONSTANTS.UNDEFINED_ATTRIBUTE));
	v_REC.IS_COMPOSITE := p_IS_COMPOSITE;
	v_REC.ENTRY_DATE := SYSDATE;

	IF p_STATION_ID > 0 OR p_STATION_ID < -10 THEN
		-- Make sure user can update this entity currently and will still be able
		-- to update entity with its new values
		IF NOT ( SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_STATION_ID, EC.ED_WEATHER_STATION) 
                 AND IO_UTIL.WEATHER_STATION_IS_ALLOWED (SD.g_ACTION_UPDATE_ENT, v_REC) ) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_ENT, EC.ED_WEATHER_STATION, p_STATION_ID);
		END IF;

		-- save it!
		UPDATE WEATHER_STATION
		SET ROW = v_REC
		WHERE STATION_ID = p_STATION_ID;
		o_OID := p_STATION_ID;
        
	ELSIF p_STATION_ID IS NULL OR p_STATION_ID = 0 THEN
		-- Make sure user can create this entity
		IF NOT IO_UTIL.WEATHER_STATION_IS_ALLOWED (SD.g_ACTION_CREATE_ENT, v_REC) THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_CREATE_ENT, EC.ED_WEATHER_STATION, NULL);
		END IF;

		SELECT OID.NEXTVAL INTO o_OID FROM DUAL;
		v_REC.STATION_ID := o_OID;
		-- save it!
		INSERT INTO WEATHER_STATION VALUES v_REC;
    
	ELSE
		-- bounce the ID back as an error code
		o_OID := p_STATION_ID;

	END IF;

EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        -- translate exception to have more useful info
        ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_WEATHER_STATION, EC.ED_ENTITY_DOMAIN)||': '||p_STATION_NAME);
END PUT_WEATHER_STATION;
---------------------------------------------------------------------
PROCEDURE GET_WEATHER_STATION
	(
	p_STATION_ID IN NUMBER,
	p_STATION_NAME OUT VARCHAR2,
	p_STATION_ALIAS OUT VARCHAR2,
	p_STATION_DESC OUT VARCHAR2,
	p_TIME_ZONE OUT VARCHAR2,
	p_IS_COMPOSITE OUT NUMBER
	) AS
-- Answer the single entity instance identified by ID
-- Answer NULL output values if entity does not exist
v_RECORD WEATHER_STATION%ROWTYPE;
BEGIN
	-- Make sure user has access
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_STATION_ID, EC.ED_WEATHER_STATION);

	-- Get the record
	SELECT *
	INTO v_RECORD
	FROM WEATHER_STATION
	WHERE STATION_ID = p_STATION_ID;
    
	-- Set the output parameters
	p_STATION_NAME := v_RECORD.STATION_NAME;
	p_STATION_ALIAS := v_RECORD.STATION_ALIAS;
	p_STATION_DESC := v_RECORD.STATION_DESC;
	p_TIME_ZONE := v_RECORD.TIME_ZONE;
	p_IS_COMPOSITE := v_RECORD.IS_COMPOSITE;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
        g_EMPTY_DATE := TRUNC(SYSDATE);
		p_STATION_NAME := g_EMPTY_VARCHAR2;
		p_STATION_ALIAS := g_EMPTY_VARCHAR2;
		p_STATION_DESC := g_EMPTY_VARCHAR2;
		p_TIME_ZONE := g_EMPTY_VARCHAR2;
		p_IS_COMPOSITE := g_EMPTY_NUMBER;

END GET_WEATHER_STATION;
---------------------------------------------------------------------
END IO;
/
