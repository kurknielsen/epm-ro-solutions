CREATE OR REPLACE PACKAGE MESSAGES_UI IS
-- $Revision: 1.3 $

FUNCTION WHAT_VERSION RETURN VARCHAR2;

FUNCTION GET_ABBREVIATED_STRING
	(
	p_STRING IN VARCHAR2,
	p_LIMIT IN NUMBER
	) RETURN VARCHAR2;

-- PULLS DOWN UNRECEIVED MESSAGES FOR THE CURRENT USER 
-- AND MARKS RECEIVED_DATE IF MESSAGES HAVEN¿T BEEN DISABLED FOR THE
-- USER OR FOR THE ENTIRE SYSTEM (VIA USER PREFERENCES AND SYSTEM 
-- DICTIONARY)
-- CURSOR CONTAINS FROM USER NAME, SUBJECT AND FIRST 500 CHARACTERS 
-- OF THE BODY (THE BODY WILL BE STRIPPED OF ANY NEW LINE CHARACTERS
-- AND AN ELLIPSIS WILL BE APPENDED IF THE FULL MESSAGE
-- IS LONGER THAN 500 CHARACTERS)
PROCEDURE POLL_MESSAGES
(
	p_CURSOR OUT GA.REFCURSOR
);

-- PULLS DOWN ALL MESSAGES FOR THE CURRENT USER
-- CURSOR CONTAINS MESSAGE ID, FROM USER NAME 
--    (NVL(USER_DISPLAY_NAME, USER_NAME), SEND_DATE, SUBJECT 
--    AND A 'READ' FLAG
-- GET_MESSAGES WILL ALSO MARKED RECEIVED_DATE FOR ALL MESSAGES 
-- PULLED DOWN
PROCEDURE GET_MESSAGES
(
	p_CURSOR OUT GA.REFCURSOR
);

-- DELETES THE MESSAGES SPECIFIED BY MESSAGE_ID, THROWS A SECURITY
-- EXCEPTION IF ONE OF THE MESSAGES DOES NOT BELONG TO THE CURRENT USER
--  (UNLESS THE CURRENT USER IS THE SUPER USER)
PROCEDURE DELETE_MESSAGES
(
	p_MESSAGE_ID IN NUMBER_COLLECTION
);

-- MARKS READ_DATE FOR ALL MESSAGES SPECIFIED BY MESSAGE_ID. THROWS A 
-- SECURITY EXCEPTION IF ONE OF THE MESSAGES DOES NOT BELONG 
-- TO THE CURRENT USER (UNLESS THE CURRENT USER IS THE SUPER USER)
PROCEDURE MARK_AS_READ
(
	p_MESSAGE_ID IN NUMBER_COLLECTION
);

-- RETURNS THE MESSAGE BODY IN A CLOB AND MARKS READ_DATE FOR THE
-- MESSAGE
PROCEDURE GET_MESSAGE_BODY
(
	p_MESSAGE_ID IN NUMBER,
	p_CONTENTS OUT CLOB
);


END MESSAGES_UI;
/
CREATE OR REPLACE PACKAGE BODY MESSAGES_UI IS
----------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR2 IS
BEGIN
    RETURN '$Revision: 1.3 $';
END WHAT_VERSION;
---------------------------------------------------------------------------------------------------
FUNCTION GET_ABBREVIATED_STRING
	(
	p_STRING IN VARCHAR2,
	p_LIMIT IN NUMBER
	) RETURN VARCHAR2 IS
	
	v_RETURN VARCHAR2(2000);
	
BEGIN

	v_RETURN := REPLACE(p_STRING, UTL_TCP.CRLF, ' ');
	v_RETURN := REPLACE(v_RETURN, CHR(9), ' ');
	v_RETURN := REPLACE(v_RETURN, CHR(10), ' ');
	v_RETURN := REPLACE(v_RETURN, CHR(13), ' ');
	
	IF LENGTH(v_RETURN) > p_LIMIT THEN
		v_RETURN := SUBSTR(v_RETURN, 1, p_LIMIT-3) || '...';
	END IF;
	
	RETURN v_RETURN;

END GET_ABBREVIATED_STRING;
----------------------------------------------------------------------------------------------------
-- PULLS DOWN UNRECEIVED MESSAGES FOR THE CURRENT USER 
-- AND MARKS RECEIVED_DATE IF MESSAGES HAVEN¿T BEEN DISABLED FOR THE
-- USER OR FOR THE ENTIRE SYSTEM (VIA USER PREFERENCES AND SYSTEM 
-- DICTIONARY)
-- CURSOR CONTAINS FROM USER NAME, SUBJECT AND FIRST 500 CHARACTERS 
-- OF THE BODY (THE BODY WILL BE STRIPPED OF ANY NEW LINE CHARACTERS
-- AND AN ELLIPSIS WILL BE APPENDED IF THE FULL MESSAGE
-- IS LONGER THAN 390 CHARACTERS)
PROCEDURE POLL_MESSAGES
	(
	p_CURSOR OUT GA.REFCURSOR
	) AS
	
	v_SETTING_VAL VARCHAR2(10);
	
	v_MESSAGES NUMBER_COLLECTION;

BEGIN

	SP.GET_USER_PREFERENCE('System', 'Messaging', CONSTANTS.UNDEFINED_ATTRIBUTE, 
		CONSTANTS.UNDEFINED_ATTRIBUTE, 'Disable Message Notifications', v_SETTING_VAL);
	
	-- NOT DISABLED? POLL THE MESSAGES
	IF NOT UT.BOOLEAN_FROM_STRING(NVL(v_SETTING_VAL, 'FALSE')) THEN
	
		UPDATE SYSTEM_MESSAGE SM
		SET SM.RECEIVED = SYSDATE
		WHERE SM.TO_USER_ID = SECURITY_CONTROLS.CURRENT_USER_ID
			AND SM.RECEIVED IS NULL
		RETURNING SM.MESSAGE_ID BULK COLLECT INTO v_MESSAGES;
		
		OPEN p_CURSOR FOR
		SELECT NVL(U.USER_DISPLAY_NAME, U.USER_NAME) AS FROM_USER,
			MESSAGES_UI.GET_ABBREVIATED_STRING(SM.SUBJECT, 32) AS SUBJECT,
			MESSAGES_UI.GET_ABBREVIATED_STRING(DBMS_LOB.SUBSTR(SM.BODY, 500, 1), 350) AS BODY
		FROM SYSTEM_MESSAGE SM,
			APPLICATION_USER U,
			TABLE(CAST(v_MESSAGES AS NUMBER_COLLECTION)) X
		WHERE SM.MESSAGE_ID = X.COLUMN_VALUE
			AND U.USER_ID = SM.FROM_USER_ID;
			
	ELSE
		-- CREATE AN EMPTY CURSOR TO PREVENT A 'CURSOR CLOSED' exception
		OPEN p_CURSOR FOR
		SELECT NULL 
		FROM DUAL
		WHERE 1=0;
	
	END IF;

END POLL_MESSAGES;
----------------------------------------------------------------------------------------------------
-- PULLS DOWN ALL MESSAGES FOR THE CURRENT USER
-- CURSOR CONTAINS MESSAGE ID, FROM USER NAME 
--    (NVL(USER_DISPLAY_NAME, USER_NAME), SEND_DATE, SUBJECT 
--    AND A 'READ' FLAG
-- GET_MESSAGES WILL ALSO MARKED RECEIVED_DATE FOR ALL MESSAGES 
-- PULLED DOWN
PROCEDURE GET_MESSAGES
	(
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN

	UPDATE SYSTEM_MESSAGE SM
	SET SM.RECEIVED = SYSDATE
	WHERE SM.TO_USER_ID = SECURITY_CONTROLS.CURRENT_USER_ID
		AND SM.RECEIVED IS NULL;
		
	OPEN p_CURSOR FOR
	SELECT SM.MESSAGE_ID,
		NVL(U.USER_DISPLAY_NAME, U.USER_NAME) AS FROM_USER,
		SM.SUBJECT,
		SM.SEND_DATE,
		SM.OCCURRENCE_ID,
		TO_CHAR(SM.PROCESS_ID) AS PROCESS_ID_STRING,
		CASE WHEN SM.READ IS NULL THEN 0 ELSE 1 END AS READ
	FROM SYSTEM_MESSAGE SM,
		APPLICATION_USER U
	WHERE SM.TO_USER_ID = SECURITY_CONTROLS.CURRENT_USER_ID
		AND U.USER_ID = SM.FROM_USER_ID
	ORDER BY SEND_DATE, FROM_USER;
			
END GET_MESSAGES;
----------------------------------------------------------------------------------------------------
-- DELETES THE MESSAGES SPECIFIED BY MESSAGE_ID, THROWS A SECURITY
-- EXCEPTION IF ONE OF THE MESSAGES DOES NOT BELONG TO THE CURRENT USER
--  (UNLESS THE CURRENT USER IS THE SUPER USER)
PROCEDURE DELETE_MESSAGES
	(
	p_MESSAGE_ID IN NUMBER_COLLECTION
	) AS
	
	v_COUNT NUMBER;

BEGIN

	IF SECURITY_CONTROLS.IS_SUPER_USER = 0 THEN
	
		SELECT COUNT(1)
		INTO v_COUNT
		FROM SYSTEM_MESSAGE SM,
			TABLE(CAST(p_MESSAGE_ID AS NUMBER_COLLECTION)) X
		WHERE SM.MESSAGE_ID = X.COLUMN_VALUE
			AND SM.TO_USER_ID <> SECURITY_CONTROLS.CURRENT_USER_ID;
		
		ASSERT(v_COUNT <= 0, 
			'Users are not authorized to delete messages belonging to other users.',
			MSGCODES.c_ERR_PRIVILEGES);
	END IF;
	
	DELETE FROM SYSTEM_MESSAGE SM
	WHERE SM.MESSAGE_ID IN (SELECT X.COLUMN_VALUE 
								FROM TABLE(CAST(p_MESSAGE_ID AS NUMBER_COLLECTION)) X);

END DELETE_MESSAGES;
----------------------------------------------------------------------------------------------------
-- MARKS READ_DATE FOR ALL MESSAGES SPECIFIED BY MESSAGE_ID. THROWS A 
-- SECURITY EXCEPTION IF ONE OF THE MESSAGES DOES NOT BELONG 
-- TO THE CURRENT USER (UNLESS THE CURRENT USER IS THE SUPER USER)
PROCEDURE MARK_AS_READ
	(
	p_MESSAGE_ID IN NUMBER_COLLECTION
	) AS
	
	v_COUNT NUMBER;

BEGIN

NULL;

	IF SECURITY_CONTROLS.IS_SUPER_USER = 0 THEN
	
		SELECT COUNT(1)
		INTO v_COUNT
		FROM SYSTEM_MESSAGE SM,
			TABLE(CAST(p_MESSAGE_ID AS NUMBER_COLLECTION)) X
		WHERE SM.MESSAGE_ID = X.COLUMN_VALUE
			AND SM.TO_USER_ID <> SECURITY_CONTROLS.CURRENT_USER_ID;
		
		ASSERT(v_COUNT <= 0, 
			'Users are not authorized to modify messages belonging to other users.',
			MSGCODES.c_ERR_PRIVILEGES);
	END IF;
	
	UPDATE SYSTEM_MESSAGE SM
	SET SM.READ = SYSDATE
	WHERE SM.MESSAGE_ID IN (SELECT X.COLUMN_VALUE 
								FROM TABLE(CAST(p_MESSAGE_ID AS NUMBER_COLLECTION)) X);

END MARK_AS_READ;
----------------------------------------------------------------------------------------------------
-- RETURNS THE MESSAGE BODY IN A CLOB AND MARKS READ_DATE FOR THE
-- MESSAGE
PROCEDURE GET_MESSAGE_BODY
	(
	p_MESSAGE_ID IN NUMBER,
	p_CONTENTS OUT CLOB
	) AS
	
	v_COUNT NUMBER;
	
BEGIN

	IF SECURITY_CONTROLS.IS_SUPER_USER = 0 THEN
	
		SELECT COUNT(1)
		INTO v_COUNT
		FROM SYSTEM_MESSAGE SM
		WHERE SM.MESSAGE_ID = p_MESSAGE_ID
			AND SM.TO_USER_ID <> SECURITY_CONTROLS.CURRENT_USER_ID;
		
		ASSERT(v_COUNT <= 0, 
			'Users are not authorized to view messages belonging to other users.',
			MSGCODES.c_ERR_PRIVILEGES);
	END IF;

	SELECT SM.BODY
	INTO p_CONTENTS
	FROM SYSTEM_MESSAGE SM
	WHERE SM.MESSAGE_ID = p_MESSAGE_ID;
	
	UPDATE SYSTEM_MESSAGE SM
	SET SM.READ = SYSDATE
	WHERE SM.MESSAGE_ID = p_MESSAGE_ID;
	

END GET_MESSAGE_BODY;
----------------------------------------------------------------------------------------------------
END MESSAGES_UI;
/
