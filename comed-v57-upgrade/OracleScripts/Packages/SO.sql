CREATE OR REPLACE PACKAGE SO AS
--Revision $Revision: 1.93 $

-- SYSTEM OBJECT PACKAGE.

FUNCTION WHAT_VERSION RETURN VARCHAR;

g_UNLIMITED_DEPTH CONSTANT NUMBER(2) := -1;

-- Enumerates a configuration hierarchy rooted at the specified object.
-- Only objects to which the user has at least view access will be included.
-- The enumeration will only include objects whose category matches one of
-- the specified categories (this list can be left NULL to indicate all
-- categories). The enumeration can, optionally, exclude the specified object
-- and only include its descendants.
-- The return value is a WORK_ID. The enumeration will be found in RTO_WORK:
-- WORK_XID - Object ID
-- WORK_SEQ - Parent Object ID
-- WORK_DATA - Object Name
-- WORK_DATA2 - Object Category
FUNCTION ENUMERATE_HIERARCHY
	(
	p_OBJECT_ID 			IN NUMBER,
	p_DEPTH_LIMIT			IN NUMBER := g_UNLIMITED_DEPTH,
	p_INCLUDE_ROOT			IN BOOLEAN := TRUE,
	p_INCLUDE_HIDDEN		IN BOOLEAN := TRUE,
	p_INCLUDE_HIDDEN_ROOT	IN BOOLEAN := TRUE,
	p_INCLUDED_CATEGORIES	IN STRING_COLLECTION := NULL
	) RETURN NUMBER;

-- Returns current user's effective privilege on the specified object.
-- If the user has view or higher privileges on the object BUT the object
-- is inaccessible (meaning user does not have view or higher privilege on
-- all ancestors) then the return value indicates no privileges.
-- If p_INHERITABLE is true, this returns the maximum inhertiable privilege
-- for the user.
FUNCTION GET_OBJECT_PRIVILEGE
    (
    p_OBJECT_ID IN NUMBER,
	p_INHERITABLE IN BOOLEAN := FALSE
    ) RETURN NUMBER;

PROCEDURE CHECK_OBJECT_PRIVILEGE
	(
	p_OBJECT_ID IN NUMBER,
	p_REQUIRED_PRIV IN NUMBER,
	p_ALL_DESCENDANTS IN BOOLEAN := FALSE,
	p_INHERITABLE IN BOOLEAN := FALSE
	);

PROCEDURE CONFIGURATION_PRIVILEGES_RPT
    (
    p_OBJECT_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    );

PROCEDURE PUT_SYSTEM_OBJECT_PRIVILEGE
    (
    p_OBJECT_ID IN NUMBER,
    P_ROLE_ID IN NUMBER,
    p_PRIVILEGE_ID IN NUMBER,
	p_DO_NOT_INHERIT IN NUMBER,
    p_RESET_CHILD_OBJECTS IN NUMBER,
	p_OLD_PRIVILEGE_ID IN NUMBER,
	p_OLD_DO_NOT_INHERIT IN NUMBER
    );

PROCEDURE DELETE_SYSTEM_OBJECT_PRIVILEGE
    (
    p_OBJECT_ID IN NUMBER,
    P_ROLE_ID IN NUMBER
    );

PROCEDURE PRIVILEGE_VALUES
    (
       p_CURSOR OUT GA.REFCURSOR
    );

PROCEDURE PUT_SYSTEM_OBJECT_ATTRIBUTE
	(
	p_OBJECT_ID IN NUMBER,
	p_ATTRIBUTE_ID IN NUMBER,
	p_ATTRIBUTE_VAL IN VARCHAR,
	P_STATUS OUT NUMBER
	);

PROCEDURE PUT_SYSTEM_OBJECT
	(
	o_OBJECT_ID OUT NUMBER,
	p_OBJECT_ID IN NUMBER,
	p_PARENT_OBJECT_ID IN NUMBER,
	p_OBJECT_NAME IN VARCHAR,
	p_OBJECT_INDEX IN NUMBER,
	p_OBJECT_CATEGORY IN VARCHAR,
	p_OBJECT_TYPE IN VARCHAR,
	p_OBJECT_ALIAS IN VARCHAR,
	p_OBJECT_DESC IN VARCHAR,
	p_OBJECT_DISPLAY_NAME IN VARCHAR,
	p_OBJECT_ORDER IN NUMBER,
	p_OBJECT_IS_HIDDEN IN NUMBER,
	p_ATTRIBUTES IN VARCHAR
	);

PROCEDURE ID_FOR_SYSTEM_OBJECT
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_OBJECT_NAME IN VARCHAR,
	p_OBJECT_INDEX IN NUMBER,
	p_OBJECT_CATEGORY IN VARCHAR,
	p_OBJECT_TYPE IN VARCHAR,
	p_CREATE_IF_NOT_FOUND IN BOOLEAN,
	p_OBJECT_ID OUT NUMBER
	);

PROCEDURE ID_FOR_SYSTEM_OBJECT_E
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_OBJECT_NAME IN VARCHAR,
	p_OBJECT_INDEX IN NUMBER,
	p_OBJECT_CATEGORY IN VARCHAR,
	p_OBJECT_TYPE IN VARCHAR,
	p_CREATE_IF_NOT_FOUND IN NUMBER,
	p_OBJECT_ID OUT NUMBER
	);

PROCEDURE ID_FOR_SYSTEM_VIEW
	(
	p_SYSTEM_VIEW_NAME IN VARCHAR2,
	p_OBJECT_ID OUT NUMBER,
	p_MODULE_NAME OUT VARCHAR2
	);

PROCEDURE SYSTEM_OBJECTS
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_OBJECT_CATEGORY IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE SYSTEM_OBJECT_ATTRIBUTES
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_OBJECT_CATEGORY IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE SYSTEM_OBJECTS_E
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_OBJECT_CATEGORY IN VARCHAR,
    p_OBJECT_INDEX IN NUMBER,
    p_OBJECT_TYPE IN VARCHAR2,
    p_INCLUDE_HIDDEN IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE SYSTEM_OBJECT_ATTRIBUTES_E
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_OBJECT_CATEGORY IN VARCHAR,
    p_OBJECT_INDEX IN NUMBER,
    p_OBJECT_TYPE IN VARCHAR2,
    p_INCLUDE_HIDDEN IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE SYSTEM_OBJECTS_AND_ATTRIBUTES
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_OBJECT_CATEGORY IN VARCHAR,
    p_OBJECT_INDEX IN NUMBER,
    p_OBJECT_TYPE IN VARCHAR2,
    p_INCLUDE_HIDDEN IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
    );

PROCEDURE PUT_SYSTEM_GRID
	(
	p_MODULE_NAME IN VARCHAR,
	p_GRID_NAME IN VARCHAR,
	p_GRID_INDEX IN NUMBER,
	p_GRID_TYPE IN VARCHAR,
	p_GRID_ALIAS IN VARCHAR,
	p_GRID_DESC IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE SYSTEM_GRID_COLS
	(
	p_MODULE_NAME IN VARCHAR,
	p_GRID_NAME IN VARCHAR,
	p_GRID_INDEX IN NUMBER,
	p_GRID_TYPE IN VARCHAR,
	p_GRID_ID OUT NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GENERATE_SYSTEM_GRID_COLS
	(
	p_GRID_ID IN NUMBER,
	p_COL_NAMES IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE GENERATE_SYSTEM_OBJ_CHILDREN
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_CHILD_CATEGORY IN VARCHAR,
	p_OBJECT_NAMES IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_SYSTEM_OBJECT_SCRIPT
	(
	p_MODULE_NAME IN VARCHAR,
    p_CHILD_OBJECT_TYPE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_SYSTEM_OBJECT_SCRIPT_HIER
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_OBJECT_CATEGORY IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_REP_REPOSITORY_SCRIPT
	(
	p_OBJECT_ID IN NUMBER,
	p_PARENT_OBJECT_ID IN NUMBER,
	p_OBJECT_CATEGORY IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_STORED_PROC_PARAMETERS
	(
	p_PACKAGE_NAME IN VARCHAR,
	p_PROCEDURE_NAME IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_STORED_PROC_PARAMETERS_OL
	(
	p_PACKAGE_NAME IN VARCHAR,
	p_PROCEDURE_NAME IN VARCHAR,
	p_OVERLOAD_INDEX IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_STORED_PROC_OVERLOAD_COUNT
	(
	p_PACKAGE_NAME IN VARCHAR,
	p_PROCEDURE_NAME IN VARCHAR,
	p_COUNT OUT NUMBER
	);

PROCEDURE GET_ALL_STORED_PROCS
	(
	p_EXCLUDE_LIST IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_ALL_STORED_PROCS
	(
	p_EXCLUDE_LIST IN VARCHAR2,
	p_IN_PACKAGE_ONLY IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_IO_TABLE_DEFINITION
	(
	p_TABLE_ALIAS IN VARCHAR,
	p_GET_PROCEDURE_NAME OUT VARCHAR,
	p_PUT_PROCEDURE_NAME OUT VARCHAR,
	p_REMOVE_PROCEDURE_NAME OUT VARCHAR,
    p_TREELIST_PROCEDURE_NAME OUT VARCHAR,
    p_USE_DATES OUT NUMBER,
	p_ENTITY_DOMAIN_ID OUT NUMBER,
	p_ENTITY_NAME_LENGTH OUT NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_ENTITY_DOMAIN_ATTRIBUTES
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_DISPLAY_NAME OUT VARCHAR2,
	p_TABLE_ABBREVIATION OUT VARCHAR2,
	p_INCLUDE_ENTITY_ATTRIBUTE OUT NUMBER,
	p_INCLUDE_CONTACT_ADDRESS OUT NUMBER,
	p_INCLUDE_EXTERNAL_IDENTIFIER OUT NUMBER,
	p_INCLUDE_GROUPS OUT NUMBER,
	p_INCLUDE_NOTES OUT NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE GENERATE_IO_TABLE_FIELDS
	(
	p_PARENT_SYSTEM_OBJECT_ID IN NUMBER,
	p_TABLE_ALIAS IN VARCHAR,
	p_TABLE_NAME IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE MODULE_NAMES
	(
	p_CURSOR OUT GA.REFCURSOR,
	p_STATUS OUT NUMBER
	);

PROCEDURE REORDER_IO_FIELDS
	(
    p_IO_TABLE_ID IN NUMBER,
    p_NEW_ORDER IN VARCHAR2
    );

PROCEDURE RENAME_SYSTEM_OBJECT
	(
    p_OBJECT_ID IN NUMBER,
    p_NEW_NAME IN VARCHAR2
    );

PROCEDURE HIDE_SYSTEM_OBJECT
	(
    p_OBJECT_ID IN NUMBER,
    p_OBJECT_IS_HIDDEN IN NUMBER
    );

PROCEDURE GET_GRID_COL_HIERARCHY
	(
	p_MODULE_NAME IN VARCHAR2,
	p_PARENT_OBJECT_ID IN NUMBER,
	p_GRID_NAME IN VARCHAR,
	p_GRID_INDEX IN NUMBER,
	p_GRID_TYPE IN VARCHAR,
	p_GRID_ID OUT NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_IO_TABLE_HIERARCHY
	(
	p_TABLE_ALIAS IN VARCHAR,
	p_PARENT_OBJECT_ID IN NUMBER,
	p_GET_PROCEDURE_NAME OUT VARCHAR,
	p_PUT_PROCEDURE_NAME OUT VARCHAR,
	p_REMOVE_PROCEDURE_NAME OUT VARCHAR,
    p_TREELIST_PROCEDURE_NAME OUT VARCHAR,
    p_USE_DATES OUT NUMBER,
	p_ENTITY_DOMAIN_ID OUT NUMBER,
	p_ENTITY_NAME_LENGTH OUT NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE UPSERT_SYSTEM_OBJECT
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_OBJECT_NAME IN VARCHAR,
	p_OBJECT_CATEGORY IN VARCHAR,
	p_ATTRIBUTES IN VARCHAR,
	p_OBJECT_ID OUT NUMBER
	);

PROCEDURE GET_SYSTEM_VIEW_HIERARCHY
	(
	p_SYSTEM_VIEW_NAME IN VARCHAR2,
	p_MAX_OBJECT_HIERARCHY IN NUMBER,
	p_PARENT_OBJECT_NAME OUT VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_FILTER_HIERARCHY
	(
    p_OBJECT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_DATA_EXCHANGE_HIERARCHY
	(
    p_MODULE_NAME IN VARCHAR2,
	p_DATA_EXCHANGE_TYPE VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_LAYOUT_HIERARCHY
	(
	p_LAYOUT_NAME IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_SHARED_CONFIG
	(
	p_OBJECT_CATEGORY IN VARCHAR2,
	p_OBJECT_NAME IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE PUT_SYSTEM_OBJECT_FOR_SCRIPT
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_OBJECT_NAME IN VARCHAR,
	p_OBJECT_CATEGORY IN VARCHAR,
	p_OBJECT_DISPLAY_NAME IN VARCHAR2,
	p_OBJECT_TAG IN VARCHAR2,
	p_OBJECT_ORDER IN NUMBER,
	p_OBJECT_IS_HIDDEN IN NUMBER,
	p_ATTRIBUTES IN VARCHAR2,
	p_OBJECT_ID OUT NUMBER
	);

PROCEDURE TREE_NODES_CONFIGURATION
	(
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE TREE_NODES_LAYOUTS
	(
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE TREE_NODES_LAYOUT_CONFIG
   (
   	p_LAYOUT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_CONFIG_PARENT_ATTRIBUTES
	(
	p_OBJECT_ID IN NUMBER,
	p_OBJECT_NAME OUT VARCHAR2,
	p_OBJECT_DISPLAY_NAME OUT VARCHAR2,
	p_OBJECT_CATEGORY OUT VARCHAR2,
	p_OBJECT_IS_HIDDEN OUT NUMBER,
	p_OBJECT_DESC OUT VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE PUT_CONFIG_PARENT_ATTRIBUTES
	(
	p_OBJECT_ID IN NUMBER,
	p_OBJECT_NAME IN VARCHAR2,
	p_OBJECT_DISPLAY_NAME IN VARCHAR2,
	p_OBJECT_IS_HIDDEN IN NUMBER,
	p_OBJECT_DESC IN VARCHAR2,
	p_ATTRIBUTES IN VARCHAR2,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_CONFIG_CHILD_LIST
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_CHILD_CATEGORY IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_LAYOUT_CONFIG_CHILD_LIST
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE PUT_LAYOUT_CONFIG
	(
	p_OBJECT_ID IN NUMBER,
	p_OBJECT_IS_HIDDEN IN NUMBER,
	p_OBJECT_DISPLAY_NAME IN VARCHAR2,
	p_OBJECT_ORDER IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_REPORTS_BY_SYS_VIEW
	(
	p_SYS_VIEW_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE PUT_REPOS_REPS_INTO_SYS_VIEW
	(
	p_SYS_VIEW_ID IN NUMBER,
	p_ORIG_REPORT_OBJECT_ID IN NUMBER,
	p_REPORT_OBJECT_ID IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_REPORT_INFO
	(
	p_REPORT_OBJECT_ID IN NUMBER,
	p_OBJECT_NAME OUT VARCHAR2,
	p_OBJECT_DISPLAY_NAME OUT VARCHAR2,
	p_OBJECT_DESC OUT VARCHAR2
	);

PROCEDURE GET_REPOSITORY_REPORTS
	(
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_VALID_REPORT_LIST
	(
	p_ORIG_REPORT_OBJECT_ID IN NUMBER,
	p_SHARED_CONFIG_NAME IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE PUT_CONFIG_CHILDREN
	(
	p_OBJECT_ID IN NUMBER,
	p_PARENT_OBJECT_ID IN NUMBER,
	p_OBJECT_NAME IN VARCHAR2,
	p_OBJECT_CATEGORY IN VARCHAR2,
	p_OBJECT_DISPLAY_NAME IN VARCHAR2,
	p_OBJECT_TAG IN VARCHAR2,
	p_OBJECT_ORDER IN NUMBER,
	p_OBJECT_IS_HIDDEN IN NUMBER,
	p_OBJECT_DESC IN VARCHAR2,
	p_ATTRIBUTES IN VARCHAR2,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_CONFIG_CHILD_ATTRIBUTES
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_CHILD_CATEGORY IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE MOVE_SYSTEM_OBJECT
	(
	p_OBJECT_ID IN NUMBER,
	p_NEW_PARENT_OBJECT_ID IN NUMBER
	);

PROCEDURE COPY_SYSTEM_OBJECT
	(
	p_OBJECT_ID IN NUMBER,
	p_NEW_PARENT_OBJECT_ID IN NUMBER
	);

PROCEDURE IS_VALID_PASTE_OPERATION
	(
	p_OBJECT_ID IN NUMBER,
	p_NEW_PARENT_OBJECT_ID IN NUMBER,
    p_IS_VALID OUT NUMBER
	);

FUNCTION GET_VALID_LAYOUTS
	(
	p_OBJECT_ID IN NUMBER
	) RETURN NUMBER;

PROCEDURE DELETE_SYSTEM_OBJECT
    (
    p_OBJECT_ID IN NUMBER
    );

PROCEDURE GET_HELP_DOCUMENT_NAME
    (
    p_OBJECT_ID IN NUMBER,
	p_HELP_DOCUMENT_NAME OUT VARCHAR2
    );

PROCEDURE GET_SO_HIERARCHY
	(
	p_PARENT_OBJECT_ID IN NUMBER,
    p_INCLUDE_HIDDEN IN NUMBER,
	p_MAX_LEVEL IN NUMBER,
	p_CATEGORIES IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE CONFIGURATION_TREE_TOP
	(
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE CONFIGURATION_TREE
	(
	p_OBJECT_ID IN NUMBER,
	p_CHILD_CATEGORY IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE SEARCH
	(
	p_SEARCH_STRING      IN VARCHAR,
	p_SEARCH_OPTION      IN VARCHAR,
	p_CURSOR             OUT GA.REFCURSOR
	);

PROCEDURE GET_TREE_VALUE_FOR_OBJECT
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_CHILD_CATEGORY IN VARCHAR2,
	p_TREE_VALUE OUT VARCHAR2
	);

PROCEDURE GET_CHART_HIERARCHY
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_CHART_NAME IN VARCHAR,
	p_CHART_INDEX IN NUMBER,
	p_CHART_TYPE IN VARCHAR,
	p_CHART_ID OUT NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

FUNCTION GET_OBJECT_NAME
	(
	p_OBJECT_NAME IN VARCHAR2,
	p_OBJECT_INDEX IN NUMBER,
	p_OBJECT_TYPE IN VARCHAR2,
	p_OBJECT_CATEGORY IN VARCHAR2,
	p_PARENT_OBJECT_ID IN NUMBER
	) RETURN VARCHAR2;

FUNCTION GET_OBJECT_ID_FOR_PATH
	(
	p_OBJECT_PATH IN VARCHAR2
	) RETURN NUMBER;

FUNCTION RESOLVE_OBJECT_ID
	(
	p_OBJECT_ID IN NUMBER
	) RETURN NUMBER;

FUNCTION GET_ATTRIBUTE_VAL
	(
	p_OBJECT_ID IN NUMBER,
	p_ATTRIBUTE_ID IN NUMBER
	) RETURN VARCHAR2;
	
PROCEDURE PATH_FOR_OBJECT_NAME
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_OBJECT_CATEGORY IN VARCHAR2,
	p_OBJECT_NAME IN VARCHAR2,
	p_PATH OUT VARCHAR2
	);
	
PROCEDURE PATH_FOR_OBJECT_ID
	(
	p_OBJECT_ID IN NUMBER,
	p_PATH OUT VARCHAR2
	);
	
PROCEDURE PATH_FOR_SHARED_OBJECT
	(
	p_SOURCE_OBJECT_ID IN NUMBER,
	p_SHARED_OBJECT_NAME IN VARCHAR2,
	p_PATH OUT VARCHAR2
	);

g_PUT_PROC_ATTRIBUTE_ID CONSTANT NUMBER(3) := 201;
g_GET_PROC_ATTRIBUTE_ID CONSTANT NUMBER(3) := 202;
g_DELETE_PROC_ATTRIBUTE_ID CONSTANT NUMBER(3) := 203;
g_TREELIST_PROC_ATTRIBUTE_ID CONSTANT NUMBER(3) := 204;
g_USE_DATES_ATTRIBUTE_ID CONSTANT NUMBER(3) := 206;

-- SYSTEM_OBJECT_PRIVILEGE constants
g_PRIV_NONE CONSTANT NUMBER(1) := 0;
g_PRIV_VIEW CONSTANT NUMBER(1) := 3;
g_PRIV_EDIT CONSTANT NUMBER(1) := 6;
g_PRIV_FULL_CONTROL CONSTANT NUMBER(1) := 9;

g_PRIV_STR_NONE CONSTANT VARCHAR2(16) := 'None';
g_PRIV_STR_VIEW CONSTANT VARCHAR2(16) := 'View';
g_PRIV_STR_EDIT CONSTANT VARCHAR2(16) := 'Edit';
g_PRIV_STR_FULL_CONTROL CONSTANT VARCHAR2(16) := 'Full Control';

g_PRIV_STATUS_NONE CONSTANT NUMBER(1) := 0;
g_PRIV_STATUS_INHERITED CONSTANT NUMBER(1) := 1;
g_PRIV_STATUS_ASSIGNED CONSTANT NUMBER(1) := 2;

END SO;
/
CREATE OR REPLACE PACKAGE BODY SO AS
---------------------------------------------------------------------------------------------------
TYPE SCRIPT_BLOCK_RECORD IS RECORD(CUR_LEVEL NUMBER(3), PARENT_LAYOUT VARCHAR2(16));
TYPE SCRIPT_BLOCK_TABLE IS VARRAY (20) OF SCRIPT_BLOCK_RECORD;

TYPE t_MAP_OF_NUMBERS IS TABLE OF NUMBER INDEX BY VARCHAR2(4000);
--------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
    RETURN '$Revision: 1.93 $';
END WHAT_VERSION;
---------------------------------------------------------------------------------------------------
FUNCTION GET_OBJECT_PRIVILEGE_INFO
	(
	p_OBJECT_ID IN NUMBER,
	p_ROLES IN ID_TABLE := SECURITY_CONTROLS.CURRENT_ROLES
	) RETURN SYSTEM_OBJECT_PRIV_INFO_TBL AS

v_RET	SYSTEM_OBJECT_PRIV_INFO_TBL;

BEGIN

	SELECT SYSTEM_OBJECT_PRIVILEGE_INFO(p_OBJECT_ID, ROLE_ID, MAX(FIRST_EFF_PRIV),
										-- we have actual role privilege? then it is assigned
										CASE WHEN MAX(CASE WHEN OBJECT_ID = p_OBJECT_ID THEN ROLE_PRIVILEGE ELSE NULL END) IS NOT NULL THEN g_PRIV_STATUS_ASSIGNED
											-- if we have no privileges at all or if last assigned ancestor was set to no inherit, then we have no privilege
											 WHEN MAX(FIRST_EFF_PRIV) IS NULL OR MAX(FIRST_NO_INHERIT) = 1 THEN g_PRIV_STATUS_NONE
											 -- otherwise, privilege is inherited
											 ELSE g_PRIV_STATUS_INHERITED
											 END,
										CASE WHEN MIN(EFF_PRIVILEGE) < g_PRIV_VIEW THEN g_PRIV_NONE
											ELSE MAX(FIRST_EFF_PRIV)
											END,
										-- get do_not_inherit value associated with specified object (ignore values for ancestors here)
										NVL(MAX(CASE WHEN OBJECT_ID = p_OBJECT_ID THEN DO_NOT_INHERIT ELSE NULL END),0)
										)
	BULK COLLECT INTO v_RET
	FROM (SELECT OBJECT_ID, ROLE_ID, ROLE_PRIVILEGE, EFF_PRIVILEGE, DO_NOT_INHERIT,
				-- order rows by level and see first non-null privilege - this is the lowest ancestor where there
				-- exists a privilege to inherit
				FIRST_VALUE(EFF_PRIVILEGE IGNORE NULLS) OVER (PARTITION BY ROLE_ID ORDER BY LVL ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) as FIRST_EFF_PRIV,
				FIRST_VALUE(DO_NOT_INHERIT IGNORE NULLS) OVER (PARTITION BY ROLE_ID ORDER BY LVL ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) as FIRST_NO_INHERIT
			FROM (SELECT A.OBJECT_ID, A.ROLE_ID, LEVEL as LVL,
						A.ROLE_PRIVILEGE, A.DO_NOT_INHERIT,
						-- effective privilege is 'none' if no explicit privilege and parent's privilege is set to
						-- 'do not inherit' - OR if no explicit privilege and this is the root of the hierarchy (i.e.
						-- no object from which to inherit)
						NVL(A.ROLE_PRIVILEGE, CASE WHEN LAG(A.DO_NOT_INHERIT) OVER (PARTITION BY A.ROLE_ID ORDER BY LEVEL DESC) = 1
														OR A.OBJECT_ID = 0
													THEN g_PRIV_NONE
													ELSE NULL
													END) as EFF_PRIVILEGE
					FROM (SELECT A.*, C.ROLE_PRIVILEGE, C.DO_NOT_INHERIT
							FROM (SELECT A.*,
										X.ID AS ROLE_ID
									FROM SYSTEM_OBJECT A,
										TABLE(CAST(p_ROLES AS ID_TABLE)) X
									) A,
								SYSTEM_OBJECT_PRIVILEGE C
							WHERE C.ROLE_ID(+) = A.ROLE_ID
								AND C.OBJECT_ID(+) = A.OBJECT_ID
						) A
					START WITH A.OBJECT_ID = p_OBJECT_ID
					CONNECT BY A.OBJECT_ID = PRIOR A.PARENT_OBJECT_ID
						AND A.ROLE_ID = PRIOR A.ROLE_ID
					)
			)
	GROUP BY ROLE_ID;

	RETURN v_RET;

END GET_OBJECT_PRIVILEGE_INFO;
---------------------------------------------------------------------------------------------------
FUNCTION ROLES_THAT_CAN_VIEW_OBJECT
	(
    p_OBJECT_ID IN NUMBER
	) RETURN ID_TABLE IS
v_RET	ID_TABLE;
v_PRIVS	SYSTEM_OBJECT_PRIV_INFO_TBL;
v_IDX 	PLS_INTEGER;
BEGIN

    IF SECURITY_CONTROLS.IS_SUPER_USER() = 1 THEN
		v_RET := ID_TABLE(ID_TYPE(SECURITY_CONTROLS.g_SUPER_USER_ROLE_ID));
	ELSE

		v_RET := ID_TABLE();
		v_PRIVS := GET_OBJECT_PRIVILEGE_INFO(p_OBJECT_ID);

		v_IDX := v_PRIVS.FIRST;
		WHILE v_PRIVS.EXISTS(v_IDX) LOOP
			IF v_PRIVS(v_IDX).EFF_PRIVILEGE >= g_PRIV_VIEW THEN
				v_RET.EXTEND;
				v_RET(v_RET.LAST) := ID_TYPE(v_PRIVS(v_IDX).ROLE_ID);
			END IF;
			v_IDX := v_PRIVS.NEXT(v_IDX);
		END LOOP;
	END IF;

    RETURN v_RET;

END ROLES_THAT_CAN_VIEW_OBJECT;
---------------------------------------------------------------------------------------------------
FUNCTION GET_OBJECT_PRIVILEGE
    (
    p_OBJECT_ID IN NUMBER,
	p_INHERITABLE IN BOOLEAN := FALSE
    ) RETURN NUMBER IS
v_MAX	NUMBER;
v_PRIVS	SYSTEM_OBJECT_PRIV_INFO_TBL;
v_IDX 	PLS_INTEGER;
BEGIN

    IF SECURITY_CONTROLS.IS_SUPER_USER() = 1 THEN
		v_MAX := g_PRIV_FULL_CONTROL;
	ELSE

		v_MAX := g_PRIV_NONE;
		v_PRIVS := GET_OBJECT_PRIVILEGE_INFO(p_OBJECT_ID);

		v_IDX := v_PRIVS.FIRST;
		WHILE v_PRIVS.EXISTS(v_IDX) LOOP
			IF v_PRIVS(v_IDX).EFF_PRIVILEGE > v_MAX
			   AND (NOT p_INHERITABLE OR v_PRIVS(v_IDX).DO_NOT_INHERIT = 0) THEN
				v_MAX := v_PRIVS(v_IDX).EFF_PRIVILEGE;
			END IF;
			v_IDX := v_PRIVS.NEXT(v_IDX);
		END LOOP;
	END IF;

    RETURN v_MAX;

END GET_OBJECT_PRIVILEGE;
---------------------------------------------------------------------------------------------------
FUNCTION PRIVILEGE_IS_AT_LEAST
	(
	p_OBJECT_ID IN NUMBER,
	p_REQUIRED_PRIV IN NUMBER,
	p_ALL_DESCENDANTS IN BOOLEAN := FALSE,
	p_INHERITABLE IN BOOLEAN := FALSE
	) RETURN BOOLEAN AS

v_MIN_PRIV	SYSTEM_OBJECT_PRIVILEGE.ROLE_PRIVILEGE%TYPE;
v_ROLES		ID_TABLE;

BEGIN
	ASSERT(NOT p_ALL_DESCENDANTS OR NOT p_INHERITABLE,
			'Cannot check inheritable object privileges for all descendants');

	IF SECURITY_CONTROLS.IS_SUPER_USER = 1 THEN
		-- super-users are unrestricted
		RETURN TRUE;
	END IF;

	IF NOT p_ALL_DESCENDANTS THEN
		RETURN GET_OBJECT_PRIVILEGE(p_OBJECT_ID, p_INHERITABLE) >= p_REQUIRED_PRIV;
	ELSE
		IF GET_OBJECT_PRIVILEGE(p_OBJECT_ID) < p_REQUIRED_PRIV THEN
			-- no need to check descendants since we don't even have correct
			-- privileges on this object
			RETURN FALSE;
		END IF;
		v_ROLES := ROLES_THAT_CAN_VIEW_OBJECT(p_OBJECT_ID);

		-- query it
		SELECT NVL(MIN(EFF_PRIV), p_REQUIRED_PRIV) -- NULL means not specified in entire subtree, so inherit from object
		INTO v_MIN_PRIV
		FROM (SELECT OBJECT_ID, MAX(CASE WHEN ROLE_PRIVILEGE IS NULL AND PRIOR DO_NOT_INHERIT = 1
											THEN g_PRIV_NONE -- no explicit privilege and not inheriting from parent? then no privilege
											ELSE NVL(ROLE_PRIVILEGE,p_REQUIRED_PRIV)
											END) as EFF_PRIV
				FROM (SELECT A.*, C.ROLE_PRIVILEGE, C.DO_NOT_INHERIT
						FROM (SELECT A.*,
									X.ID AS ROLE_ID
								FROM SYSTEM_OBJECT A,
									TABLE(CAST(v_ROLES AS ID_TABLE)) X
							) A,
							SYSTEM_OBJECT_PRIVILEGE C
						WHERE C.ROLE_ID(+) = A.ROLE_ID
							AND C.OBJECT_ID(+) = A.OBJECT_ID
					) A
				START WITH A.OBJECT_ID = p_OBJECT_ID
				CONNECT BY A.PARENT_OBJECT_ID = PRIOR A.OBJECT_ID
					AND A.ROLE_ID = PRIOR A.ROLE_ID
					-- only continue if last record had appropriate privileges.
					-- this effectively means we stop enumerating the hierarchy after
					-- we encounter a node whose privileges are less than required.
					AND PRIOR NVL(A.ROLE_PRIVILEGE,p_REQUIRED_PRIV) >= p_REQUIRED_PRIV
					-- if prior records privilege is unset, then we must examine
					-- grandparent's privilege record to see if was inherited.
					-- if parent privilege is NULL and grandparent is set to not
					-- inherit, then effective privilege for parent is none and
					-- we can stop enumerating.
					AND ((PRIOR A.ROLE_PRIVILEGE) IS NOT NULL
						 OR NOT EXISTS (SELECT 1
						 				FROM SYSTEM_OBJECT O, SYSTEM_OBJECT_PRIVILEGE P
										WHERE O.OBJECT_ID = A.PARENT_OBJECT_ID
											AND P.OBJECT_ID = O.PARENT_OBJECT_ID
											AND P.ROLE_ID = A.ROLE_ID
											AND P.DO_NOT_INHERIT = 1
						 				))
				GROUP BY OBJECT_ID);

		RETURN v_MIN_PRIV >= p_REQUIRED_PRIV;
	END IF;
END PRIVILEGE_IS_AT_LEAST;
---------------------------------------------------------------------------------------------------
PROCEDURE CHECK_OBJECT_PRIVILEGE
	(
	p_OBJECT_ID IN NUMBER,
	p_REQUIRED_PRIV IN NUMBER,
	p_ALL_DESCENDANTS IN BOOLEAN := FALSE,
	p_INHERITABLE IN BOOLEAN := FALSE
	) AS

	v_AUTH_MSG			VARCHAR(4000);
	v_OBJECT_NAME		SYSTEM_OBJECT.OBJECT_NAME%TYPE;
	v_OBJECT_CATEGORY	SYSTEM_OBJECT.OBJECT_CATEGORY%TYPE;

BEGIN
	IF NOT PRIVILEGE_IS_AT_LEAST(p_OBJECT_ID, p_REQUIRED_PRIV, p_ALL_DESCENDANTS, p_INHERITABLE) THEN
		-- build message
		BEGIN
			SELECT OBJECT_NAME,
				   OBJECT_CATEGORY
			INTO v_OBJECT_NAME,
				 v_OBJECT_CATEGORY
			FROM SYSTEM_OBJECT
			WHERE OBJECT_ID = p_OBJECT_ID;
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
				v_OBJECT_NAME := 'Unknown';
				v_OBJECT_CATEGORY := 'System Object';
		END;
		v_AUTH_MSG := CASE WHEN p_REQUIRED_PRIV = g_PRIV_FULL_CONTROL THEN g_PRIV_STR_FULL_CONTROL
						   WHEN p_REQUIRED_PRIV = g_PRIV_EDIT THEN g_PRIV_STR_EDIT
						   ELSE g_PRIV_STR_VIEW
						   END;

    	v_AUTH_MSG := SUBSTR(CASE WHEN p_INHERITABLE THEN 'Inheritable ' ELSE NULL END
								|| v_AUTH_MSG || ' privileges are required for '
								|| v_OBJECT_CATEGORY || ':' || v_OBJECT_NAME
								|| CASE WHEN p_ALL_DESCENDANTS THEN ' and all of its descendants' ELSE NULL END,
							1, 4000
							);

		-- raise a security exception
		ERRS.RAISE(MSGCODES.c_ERR_PRIVILEGES, v_AUTH_MSG);
	END IF;
END CHECK_OBJECT_PRIVILEGE;
----------------------------------------------------------------------------------------------------
FUNCTION ENUMERATE_HIERARCHY
	(
	p_OBJECT_ID 			IN NUMBER,
	p_DEPTH_LIMIT			IN NUMBER := g_UNLIMITED_DEPTH,
	p_INCLUDE_ROOT			IN BOOLEAN := TRUE,
	p_INCLUDE_HIDDEN		IN BOOLEAN := TRUE,
	p_INCLUDE_HIDDEN_ROOT	IN BOOLEAN := TRUE,
	p_INCLUDED_CATEGORIES	IN STRING_COLLECTION := NULL
	) RETURN NUMBER AS

v_IS_SU					NUMBER(1) := SECURITY_CONTROLS.IS_SUPER_USER;
v_ROLES					ID_TABLE := ROLES_THAT_CAN_VIEW_OBJECT(p_OBJECT_ID);

v_INCLUDE_ROOT			NUMBER(1) := UT.NUMBER_FROM_BOOLEAN(p_INCLUDE_ROOT);
v_INCLUDE_HIDDEN		NUMBER(1) := UT.NUMBER_FROM_BOOLEAN(p_INCLUDE_HIDDEN);
v_INCLUDE_HIDDEN_ROOT	NUMBER(1) := UT.NUMBER_FROM_BOOLEAN(p_INCLUDE_HIDDEN_ROOT);

v_WORK_ID				NUMBER;
v_CATEGORIES 			STRING_COLLECTION := p_INCLUDED_CATEGORIES;

BEGIN
	IF v_ROLES.COUNT = 0 THEN
		RETURN -1;
	END IF;

	UT.GET_RTO_WORK_ID(v_WORK_ID);

	IF v_CATEGORIES IS NULL THEN
		v_CATEGORIES := STRING_COLLECTION('%'); -- null? allow all objects
	END IF;

	INSERT INTO RTO_WORK(WORK_ID, WORK_XID, WORK_SEQ, WORK_DATA, WORK_DATA2)
	SELECT DISTINCT v_WORK_ID, OBJECT_ID, PARENT_OBJECT_ID, OBJECT_NAME, OBJECT_CATEGORY
    FROM (SELECT A.OBJECT_ID, A.PARENT_OBJECT_ID, A.OBJECT_IS_HIDDEN, A.OBJECT_CATEGORY, A.OBJECT_NAME, A.ROLE_ID, C.ROLE_PRIVILEGE, C.DO_NOT_INHERIT
			FROM (SELECT A.OBJECT_ID, A.PARENT_OBJECT_ID, A.OBJECT_IS_HIDDEN, A.OBJECT_CATEGORY, A.OBJECT_NAME,
						X.ID AS ROLE_ID
					FROM SYSTEM_OBJECT A,
						TABLE(CAST(v_ROLES AS ID_TABLE)) X
				) A,
				SYSTEM_OBJECT_PRIVILEGE C
			WHERE C.ROLE_ID(+) = A.ROLE_ID
				AND C.OBJECT_ID(+) = A.OBJECT_ID
		) A
	WHERE v_INCLUDE_ROOT = 1 OR A.OBJECT_ID <> p_OBJECT_ID
	START WITH A.OBJECT_ID = p_OBJECT_ID
		AND (v_INCLUDE_HIDDEN_ROOT = 1 OR NVL(A.OBJECT_IS_HIDDEN,0) = 0)
	CONNECT BY A.PARENT_OBJECT_ID = PRIOR A.OBJECT_ID
		AND A.ROLE_ID = PRIOR A.ROLE_ID
		AND (v_IS_SU = 1
			OR NVL(A.ROLE_PRIVILEGE, CASE WHEN NVL(PRIOR A.DO_NOT_INHERIT,0) = 1
											THEN g_PRIV_NONE -- no inherit parent's view priv
											ELSE g_PRIV_VIEW
											END) >= g_PRIV_VIEW)
		AND EXISTS (SELECT 1 -- restrict objects by category
					FROM TABLE(CAST(v_CATEGORIES as STRING_COLLECTION)) CAT
					WHERE A.OBJECT_CATEGORY LIKE CAT.COLUMN_VALUE)
		AND (p_DEPTH_LIMIT = g_UNLIMITED_DEPTH OR LEVEL <= p_DEPTH_LIMIT+1)
		AND (v_INCLUDE_HIDDEN = 1 OR NVL(A.OBJECT_IS_HIDDEN,0) = 0);

	RETURN v_WORK_ID;

END ENUMERATE_HIERARCHY;
-------------------------------------------------------------------------------
PROCEDURE CLEANUP_WORK AS
BEGIN
	EXECUTE IMMEDIATE 'TRUNCATE TABLE LAYOUT_HIERARCHY_WORK';
EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		NULL; -- ignore errors
END CLEANUP_WORK;
---------------------------------------------------------------------------------------------------
-- This method will get layout hierarchy, starting with a particular starting
-- point object, pruning away all sub-trees that contain no accessible system
-- view objects. It returns a WORK_ID. The work data contains WORK_XID =
-- OBJECT_ID and WORK_DATA = OBJECT's PATH (for ordering)
-------------------------------------------------------------------------------
FUNCTION GET_VALID_LAYOUTS
	(
	p_OBJECT_ID IN NUMBER
	) RETURN NUMBER IS
v_WORK_ID1 NUMBER; -- intermediate work info
v_WORK_ID2 NUMBER; -- result data
BEGIN
	-- Find all allowed layouts
	v_WORK_ID1 := ENUMERATE_HIERARCHY(p_OBJECT_ID, p_INCLUDE_ROOT => p_OBJECT_ID <> 0,
									p_INCLUDE_HIDDEN => FALSE, p_INCLUDED_CATEGORIES => STRING_COLLECTION('Layout'));
	-- Find all allowed system views
	v_WORK_ID2 := ENUMERATE_HIERARCHY(0, p_INCLUDE_ROOT => FALSE,
									p_INCLUDED_CATEGORIES => STRING_COLLECTION('Module', 'System View'));

	CLEANUP_WORK; -- truncate this temp table before we try to populate it

	-- build layout hierarchy work table based on this info:
	INSERT INTO LAYOUT_HIERARCHY_WORK (SYSTEM_VIEW_OBJECT_ID, OBJECT_ID, PATH, DISPLAY_PATH, IS_AGGREGATE)
	SELECT *
	FROM (SELECT B.OBJECT_ID as SYSTEM_VIEW_OBJECT_ID,
				A.OBJECT_ID,
				A.PATH,
				A.DISPLAY_PATH,
				A.IS_AGGREGATE
				-- get hierarchy of allowed layouts
			FROM (SELECT OBJECT_ID,
						PARENT_OBJECT_ID,
						CASE WHEN PANE_TYPE IN ('Aggregate','Splitter') THEN 1 ELSE 0 END as IS_AGGREGATE,
						VIEW_REF,
						-- compute path
						SYS_CONNECT_BY_PATH(TO_CHAR(OBJECT_ORDER,'9999')||
								REPLACE(SUBSTR(NVL(OBJECT_DISPLAY_NAME,OBJECT_NAME),1,16),':','-')||
								TO_CHAR(OBJECT_ID,'999999999'),'::') PATH,
						SYS_CONNECT_BY_PATH(NVL(OBJECT_DISPLAY_NAME,
								INITCAP(REPLACE(OBJECT_NAME, '_', ' '))),'\') DISPLAY_PATH
					FROM (SELECT W.WORK_XID as OBJECT_ID,
								SO.PARENT_OBJECT_ID,
								SO.OBJECT_NAME,
								SO.OBJECT_DISPLAY_NAME,
								SO.OBJECT_ORDER,
								PT.ATTRIBUTE_VAL as PANE_TYPE,
								VR.ATTRIBUTE_VAL as VIEW_REF
							FROM RTO_WORK W, SYSTEM_OBJECT SO, SYSTEM_OBJECT_ATTRIBUTE PT, SYSTEM_OBJECT_ATTRIBUTE VR
							WHERE W.WORK_ID = v_WORK_ID1
								AND SO.OBJECT_ID = W.WORK_XID
								-- get pane type and view reference attributes for each layout
								AND PT.OBJECT_ID(+) = SO.OBJECT_ID
								AND PT.ATTRIBUTE_ID(+) = 701
								AND VR.OBJECT_ID(+) = SO.OBJECT_ID
								AND VR.ATTRIBUTE_ID(+) = 708)
					-- recurse hierarchy of available layouts
					START WITH ( (p_OBJECT_ID = 0 AND PARENT_OBJECT_ID = p_OBJECT_ID)
								OR (p_OBJECT_ID <> 0 AND OBJECT_ID = p_OBJECT_ID) )
					CONNECT BY PARENT_OBJECT_ID = PRIOR OBJECT_ID) A,
				SYSTEM_OBJECT B
			-- find referenced system view - outer join in case there isn't one
			WHERE UPPER(B.OBJECT_NAME(+)) = UPPER(A.VIEW_REF)
				AND B.OBJECT_CATEGORY(+) = 'System View')
	-- filter out references to system views that are not allowed due to privileges
	WHERE SYSTEM_VIEW_OBJECT_ID IS NULL
		OR EXISTS (SELECT 1 FROM RTO_WORK W WHERE W.WORK_ID = v_WORK_ID2 AND W.WORK_XID = SYSTEM_VIEW_OBJECT_ID);

	-- clean-up RTO_WORK entries used so far
	UT.PURGE_RTO_WORK(v_WORK_ID1);
	UT.PURGE_RTO_WORK(v_WORK_ID2);

	-- Finally - prune the layout tree queried in the previous step by
	-- eliminating "empty" aggregate layouts (they may be empty due to
	-- the current user having no access to the child views)

    INSERT INTO RTO_WORK(WORK_ID, WORK_XID, WORK_SEQ, WORK_DATA, WORK_DATA2)
    SELECT v_WORK_ID1, L1.OBJECT_ID, L1.SYSTEM_VIEW_OBJECT_ID, L1.PATH, L1.DISPLAY_PATH
    FROM LAYOUT_HIERARCHY_WORK L1
    WHERE EXISTS (SELECT 1
	                FROM LAYOUT_HIERARCHY_WORK L2
    	            WHERE L2.PATH LIKE L1.PATH || '%'
        	            AND L2.IS_AGGREGATE = 0
            	        AND L1.IS_AGGREGATE = 1
					)
    	OR L1.IS_AGGREGATE = 0;

	-- Done !

	CLEANUP_WORK; -- truncate this temp table now that we're done with it

	RETURN v_WORK_ID1;

EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			CLEANUP_WORK; -- truncate this temp table now that we're done with it
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE();
		END;
		ERRS.LOG_AND_RAISE();

END GET_VALID_LAYOUTS;
-------------------------------------------------------------------------------
PROCEDURE CONFIGURATION_PRIVILEGES_RPT
    (
    p_OBJECT_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS

v_ROLES	ID_TABLE;
v_PRIVS	SYSTEM_OBJECT_PRIV_INFO_TBL := SYSTEM_OBJECT_PRIV_INFO_TBL();

BEGIN

	CHECK_OBJECT_PRIVILEGE(p_OBJECT_ID, g_PRIV_VIEW);

	SELECT ID_TYPE(ROLE_ID)
	BULK COLLECT INTO v_ROLES
	FROM APPLICATION_ROLE;

	v_PRIVS := GET_OBJECT_PRIVILEGE_INFO(p_OBJECT_ID, v_ROLES);

    OPEN P_CURSOR FOR
        SELECT AR.ROLE_ID,
			   AR.ROLE_NAME,
			   NVL(PR.ROLE_PRIVILEGE, g_PRIV_NONE) as PRIVILEGE_ID,
			   NVL(PR.ROLE_PRIVILEGE, g_PRIV_NONE) as ORIG_PRIVILEGE_ID,
			   PR.PRIVILEGE_STAT as PRIVILEGE_STATUS,
			   CASE WHEN NVL(PR.EFF_PRIVILEGE,g_PRIV_NONE) = g_PRIV_NONE THEN 0 ELSE 1 END as ACCESSIBLE,
			   PR.DO_NOT_INHERIT,
			   PR.DO_NOT_INHERIT as ORIG_DO_NOT_INHERIT
		FROM TABLE(CAST(v_PRIVS as SYSTEM_OBJECT_PRIV_INFO_TBL)) PR,
			APPLICATION_ROLE AR
		WHERE AR.ROLE_ID = PR.ROLE_ID
		ORDER BY 4 DESC, 2 ASC;

END CONFIGURATION_PRIVILEGES_RPT;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_SYSTEM_OBJECT_PRIVILEGE
    (
    p_OBJECT_ID IN NUMBER,
    P_ROLE_ID IN NUMBER,
    p_PRIVILEGE_ID IN NUMBER,
	p_DO_NOT_INHERIT IN NUMBER,
    p_RESET_CHILD_OBJECTS IN NUMBER,
	p_OLD_PRIVILEGE_ID IN NUMBER,
	p_OLD_DO_NOT_INHERIT IN NUMBER
    ) AS

v_PRIV		NUMBER(1);

BEGIN
	CHECK_OBJECT_PRIVILEGE(p_OBJECT_ID, g_PRIV_FULL_CONTROL, p_RESET_CHILD_OBJECTS = 1);

	IF P_ROLE_ID = SECURITY_CONTROLS.g_SUPER_USER_ROLE_ID THEN
		v_PRIV := g_PRIV_FULL_CONTROL;
	ELSE
		v_PRIV := p_PRIVILEGE_ID;
	END IF;

	SAVEPOINT BEFORE_OBJ_PRIV_UPDATE;

	-- only update/insert privilege if user changed something
	IF NOT ((p_PRIVILEGE_ID IS NULL AND p_OLD_PRIVILEGE_ID IS NULL) OR p_PRIVILEGE_ID = p_OLD_PRIVILEGE_ID)
   	   OR NOT ((p_DO_NOT_INHERIT IS NULL AND p_OLD_DO_NOT_INHERIT IS NULL) OR p_DO_NOT_INHERIT = p_OLD_DO_NOT_INHERIT) THEN

		--UPDATE THE CURRENT ASSIGNMENT IF ONE EXISTS.
		UPDATE SYSTEM_OBJECT_PRIVILEGE S SET
			S.ROLE_PRIVILEGE = v_PRIV,
			S.DO_NOT_INHERIT = NVL(p_DO_NOT_INHERIT,0),
			S.LAST_UPDATE_DATE = SYSDATE
		WHERE S.OBJECT_ID = p_OBJECT_ID
			AND S.ROLE_ID = P_ROLE_ID;

		-- NO ASSIGNMENT UPDATE FOR THIS COMBINATION SO INSERT A NEW ASSIGNMENT
		IF SQL%NOTFOUND THEN
			INSERT INTO SYSTEM_OBJECT_PRIVILEGE
				(
				OBJECT_ID,
				ROLE_ID,
				ROLE_PRIVILEGE,
				DO_NOT_INHERIT,
				CREATE_DATE
				)
			VALUES
				(
				p_OBJECT_ID,
				P_ROLE_ID,
				v_PRIV,
				NVL(p_DO_NOT_INHERIT,0),
				SYSDATE
				);
		END IF;

	END IF;

    IF p_RESET_CHILD_OBJECTS = 1 THEN
        DELETE
        FROM SYSTEM_OBJECT_PRIVILEGE S
        WHERE S.ROLE_ID = P_ROLE_ID
        AND S.OBJECT_ID IN (SELECT OBJECT_ID
                            FROM SYSTEM_OBJECT
                            START WITH PARENT_OBJECT_ID = p_OBJECT_ID
				            CONNECT BY PRIOR OBJECT_ID = PARENT_OBJECT_ID);
    END IF;

	-- THE NEW PRIVILEGE IS NO LONGER FULL CONTROL, ROLLBACK
	IF NOT PRIVILEGE_IS_AT_LEAST(p_OBJECT_ID, g_PRIV_FULL_CONTROL, p_RESET_CHILD_OBJECTS = 1) THEN
	   ROLLBACK TO BEFORE_OBJ_PRIV_UPDATE;
	   ERRS.RAISE(MSGCODES.c_ERR_ALTER_PRIVS, 'You cannot reduce your own privilege for an object.');
	END IF;

END PUT_SYSTEM_OBJECT_PRIVILEGE;
---------------------------------------------------------------------------------------------------
PROCEDURE DELETE_SYSTEM_OBJECT_PRIVILEGE
    (
    p_OBJECT_ID IN NUMBER,
    P_ROLE_ID IN NUMBER
    ) AS

BEGIN
	CHECK_OBJECT_PRIVILEGE(p_OBJECT_ID, g_PRIV_FULL_CONTROL);

	SAVEPOINT BEFORE_OBJ_PRIV_DELETE;

-- Perform delete
    DELETE
    FROM SYSTEM_OBJECT_PRIVILEGE S
    WHERE S.ROLE_ID = P_ROLE_ID
    AND S.OBJECT_ID = p_OBJECT_ID;

    -- THE NEW PRIVILEGE IS NO LONGER FULL CONTROL, ROLLBACK
    IF NOT PRIVILEGE_IS_AT_LEAST(p_OBJECT_ID, g_PRIV_FULL_CONTROL) THEN
       ROLLBACK TO BEFORE_OBJ_PRIV_DELETE;
	   ERRS.RAISE(MSGCODES.c_ERR_ALTER_PRIVS, 'You cannot reduce your own privilege for an object.');
    END IF;

END DELETE_SYSTEM_OBJECT_PRIVILEGE;
---------------------------------------------------------------------------------------------------
PROCEDURE PRIVILEGE_VALUES
	(
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN

    OPEN p_CURSOR FOR
		  SELECT VALUE PRIVILEGE_NAME, TO_NUMBER(CODE) PRIVILEGE_ID
		  FROM SYSTEM_LABEL
		  WHERE (MODEL_ID = 0)
		  	  AND UPPER(MODULE) = 'SYSTEM'
              AND UPPER(KEY1) = 'PRIVILEGES'
			  AND UPPER(KEY2) = 'VALUES'
			  AND UPPER(KEY3) = '?'
			  AND NVL(IS_HIDDEN,0) = 0
		  ORDER BY POSITION;

END PRIVILEGE_VALUES;
---------------------------------------------------------------------------------------------------
PROCEDURE NULL_CURSOR
    (
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
		SELECT NULL FROM DUAL;

END NULL_CURSOR;
----------------------------------------------------------------------------------------------------
FUNCTION DO_ESCAPE
	(
	p_IN IN VARCHAR2
	) RETURN VARCHAR2 IS
BEGIN
	RETURN REPLACE(REPLACE(REPLACE(p_IN,'`','``'),'~','`0'),'^','`1');
END DO_ESCAPE;
----------------------------------------------------------------------------------------------------
FUNCTION UNESCAPE
	(
	p_IN IN VARCHAR2
	) RETURN VARCHAR2 IS
v_RET VARCHAR2(4000) := '';
v_NEXT VARCHAR2(1);
v_OLD_IDX NUMBER := 0;
v_IDX NUMBER := 1;
BEGIN
	-- tick marks / apostrophes (tilde w/out the shift) are used as the
	-- escape character
	WHILE v_IDX > 0 LOOP
		v_IDX := INSTR(p_IN, '`', v_OLD_IDX+1);
		IF v_IDX > 0 THEN

			v_RET := v_RET || SUBSTR(p_IN, v_OLD_IDX+1, v_IDX-v_OLD_IDX-1);

			v_NEXT := SUBSTR(p_IN, v_IDX+1, 1);
			IF v_NEXT = '`' THEN
				v_RET := v_RET||'`';
				v_IDX := v_IDX + 1;
			ELSIF v_NEXT = '0' THEN
				v_RET := v_RET||'~';
				v_IDX := v_IDX + 1;
			ELSIF v_NEXT = '1' THEN
				v_RET := v_RET||'^';
				v_IDX := v_IDX + 1;
			ELSE
				NULL; -- error?
			END IF;

			v_OLD_IDX := v_IDX;
		END IF;
	END LOOP;
	v_RET := v_RET || SUBSTR(p_IN, v_OLD_IDX+1);

	RETURN v_RET;
END UNESCAPE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_SYSTEM_OBJECT_ATTRIBUTES
	(
	p_OBJECT_ID IN NUMBER,
	p_ATTRIBUTES IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_STRING_TABLE GA.BIG_STRING_TABLE;
v_ATTRIBUTE_STRING GA.BIG_STRING_TABLE;
v_INDEX BINARY_INTEGER;
v_ATTRIBUTE_ID NUMBER(9);
v_ATTRIBUTE_VAL SYSTEM_OBJECT_ATTRIBUTE.ATTRIBUTE_VAL%TYPE;

BEGIN

	CHECK_OBJECT_PRIVILEGE(p_OBJECT_ID, g_PRIV_EDIT);

--CLEAR OUT OLD ATTRIBUTES
	DELETE FROM SYSTEM_OBJECT_ATTRIBUTE
	WHERE OBJECT_ID = p_OBJECT_ID;

--PARSE ATTRIBUTE DATA AND INSERT INTO SYSTEM_ATTRIBUTE TABLE.
	IF p_ATTRIBUTES IS NOT NULL THEN
		UT.TOKENS_FROM_BIG_STRING(p_ATTRIBUTES,'^', v_STRING_TABLE);
	 	FOR v_INDEX IN v_STRING_TABLE.FIRST..v_STRING_TABLE.LAST LOOP
			UT.TOKENS_FROM_BIG_STRING(v_STRING_TABLE(v_INDEX), '~', v_ATTRIBUTE_STRING);
			v_ATTRIBUTE_ID := TO_NUMBER(v_ATTRIBUTE_STRING(1));
			IF v_ATTRIBUTE_STRING.EXISTS(2) THEN
				v_ATTRIBUTE_VAL := v_ATTRIBUTE_STRING(2);

				-- decode the attribute value - in case it included carets or tildes
				v_ATTRIBUTE_VAL := UNESCAPE(v_ATTRIBUTE_VAL);

				INSERT INTO SYSTEM_OBJECT_ATTRIBUTE(
					OBJECT_ID,
					ATTRIBUTE_ID,
					ATTRIBUTE_VAL)
				VALUES(
					p_OBJECT_ID,
					v_ATTRIBUTE_ID,
					v_ATTRIBUTE_VAL);
			END IF;
		END LOOP;
	END IF;

END PUT_SYSTEM_OBJECT_ATTRIBUTES;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_SYSTEM_OBJECT_ATTRIBUTE
	(
	p_OBJECT_ID IN NUMBER,
	p_ATTRIBUTE_ID IN NUMBER,
	p_ATTRIBUTE_VAL IN VARCHAR,
	P_STATUS OUT NUMBER
	)
	AS

BEGIN

	p_STATUS := GA.SUCCESS;

	CHECK_OBJECT_PRIVILEGE(p_OBJECT_ID, g_PRIV_EDIT);

--UPDATE THE CURRENT ASSIGNMENT IF ONE EXISTS.

	UPDATE SYSTEM_OBJECT_ATTRIBUTE SET
		ATTRIBUTE_VAL = p_ATTRIBUTE_VAL
	WHERE OBJECT_ID = p_OBJECT_ID
		AND ATTRIBUTE_ID = p_ATTRIBUTE_ID;

-- NO ASSIGNMENT UPDATE FOR THIS COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO SYSTEM_OBJECT_ATTRIBUTE
			(
			OBJECT_ID,
			ATTRIBUTE_ID,
			ATTRIBUTE_VAL
			)
		VALUES
			(
			p_OBJECT_ID,
			p_ATTRIBUTE_ID,
			p_ATTRIBUTE_VAL
			);
	END IF;

END PUT_SYSTEM_OBJECT_ATTRIBUTE;

----------------------------------------------------------------------------------------------------
PROCEDURE PUT_SYSTEM_OBJECT
	(
	o_OBJECT_ID OUT NUMBER,
	p_OBJECT_ID IN NUMBER,
	p_PARENT_OBJECT_ID IN NUMBER,
	p_OBJECT_NAME IN VARCHAR,
	p_OBJECT_INDEX IN NUMBER,
	p_OBJECT_CATEGORY IN VARCHAR,
	p_OBJECT_TYPE IN VARCHAR,
	p_OBJECT_ALIAS IN VARCHAR,
	p_OBJECT_DESC IN VARCHAR,
	p_OBJECT_DISPLAY_NAME IN VARCHAR,
	p_OBJECT_ORDER IN NUMBER,
	p_OBJECT_IS_HIDDEN IN NUMBER,
	p_ATTRIBUTES IN VARCHAR
	)
	AS


-- CREATE OR REPLACE AN ENTITY
-- ANSWER ITS OBJECT_ID, OR -1 IF THERE IS A DUPLICATE NAME

v_COUNT NUMBER := 0;
v_OBJECT_ID NUMBER := NVL(p_OBJECT_ID,0);
p_STATUS NUMBER;

BEGIN

	-- UPDATE AN EXISTING RECORD THAT HAS AN ASSIGNED OBJECT_ID

	IF v_OBJECT_ID > 0 THEN

		CHECK_OBJECT_PRIVILEGE(p_OBJECT_ID, g_PRIV_EDIT);

		--DETERMINE IF THE SPECIFIED CASE-INSENSITIVE NAME IS CURRENTLY IN USE BY ANOTHER ENTITY
		--SIGNAL A NAME COLLISION EXCEPTION WHEN THE NAME OF THE ENTITY IS CHANGED TO ONE IN USE
		SELECT COUNT(*)
		INTO v_COUNT
		FROM SYSTEM_OBJECT
		WHERE PARENT_OBJECT_ID = p_PARENT_OBJECT_ID
			AND UPPER(OBJECT_NAME) = UPPER(LTRIM(RTRIM(p_OBJECT_NAME)))
			AND OBJECT_INDEX = p_OBJECT_INDEX
			AND UPPER(OBJECT_CATEGORY) = UPPER(LTRIM(RTRIM(p_OBJECT_CATEGORY)))
			AND UPPER(OBJECT_TYPE) = UPPER(LTRIM(RTRIM(p_OBJECT_TYPE)))
			AND OBJECT_ID <> p_OBJECT_ID;

		IF v_COUNT = 0 THEN
			UPDATE SYSTEM_OBJECT SET
            	PARENT_OBJECT_ID = p_PARENT_OBJECT_ID,
            	OBJECT_NAME = LTRIM(RTRIM(p_OBJECT_NAME)),
                OBJECT_INDEX = p_OBJECT_INDEX,
                OBJECT_CATEGORY = LTRIM(RTRIM(p_OBJECT_CATEGORY)),
                OBJECT_TYPE = LTRIM(RTRIM(p_OBJECT_TYPE)),
				OBJECT_ALIAS = LTRIM(RTRIM(p_OBJECT_ALIAS)),
				OBJECT_DESC = LTRIM(RTRIM(p_OBJECT_DESC)),
				OBJECT_DISPLAY_NAME = LTRIM(RTRIM(p_OBJECT_DISPLAY_NAME)),
				OBJECT_ORDER = NVL(p_OBJECT_ORDER,0),
				OBJECT_IS_HIDDEN = NVL(p_OBJECT_IS_HIDDEN,0),
                ENTRY_DATE = SYSDATE
			WHERE OBJECT_ID = p_OBJECT_ID;
			o_OBJECT_ID := p_OBJECT_ID;
		ELSE
			o_OBJECT_ID := GA.DUPLICATE_ENTITY;
			RETURN;
		END IF;

	-- INSERT A NEW RECORD AND ASSIGN IT A UNIQUE OBJECT_ID.
	ELSE

		CHECK_OBJECT_PRIVILEGE(p_PARENT_OBJECT_ID, g_PRIV_EDIT, p_INHERITABLE => TRUE);

		-- DETERMINE IF THE SPECIFIED CASE-INSENSITIVE NAME IS CURRENTLY IN USE BY ANOTHER ENTITY
		-- SIGNAL A NAME COLLISION EXCEPTION WHEN THE SPECIFIED NAME OF THE ENTITY IS ONE IN USE

		SELECT COUNT(*)
		INTO v_COUNT
		FROM SYSTEM_OBJECT
		WHERE PARENT_OBJECT_ID = p_PARENT_OBJECT_ID
			AND UPPER(OBJECT_NAME) = UPPER(LTRIM(RTRIM(p_OBJECT_NAME)))
			AND OBJECT_INDEX = p_OBJECT_INDEX
			AND UPPER(OBJECT_CATEGORY) = UPPER(LTRIM(RTRIM(p_OBJECT_CATEGORY)))
			AND UPPER(OBJECT_TYPE) = UPPER(LTRIM(RTRIM(p_OBJECT_TYPE)));

		-- IF THE COUNT IS ZERO AN ENTITY WAS NOT FOUND, SO INSERT THE NEW ENTITY.
		-- ASSIGN THE NEXT OBJECT IDENTIFICATION (OBJECT_ID) TO THE ENTITY
		IF v_COUNT = 0 THEN
			SELECT MID.NEXTVAL INTO v_OBJECT_ID FROM DUAL;
			INSERT INTO SYSTEM_OBJECT
				(
				OBJECT_ID,
				PARENT_OBJECT_ID,
				OBJECT_NAME,
				OBJECT_INDEX,
				OBJECT_CATEGORY,
				OBJECT_TYPE,
				OBJECT_ALIAS,
				OBJECT_DESC,
				OBJECT_DISPLAY_NAME,
				OBJECT_ORDER,
				OBJECT_IS_HIDDEN,
				ENTRY_DATE
				)
			VALUES
				(
				v_OBJECT_ID,
				p_PARENT_OBJECT_ID,
				LTRIM(RTRIM(p_OBJECT_NAME)),
				NVL(p_OBJECT_INDEX,0),
				LTRIM(RTRIM(p_OBJECT_CATEGORY)),
				LTRIM(RTRIM(p_OBJECT_TYPE)),
				LTRIM(RTRIM(p_OBJECT_ALIAS)),
				LTRIM(RTRIM(p_OBJECT_DESC)),
				LTRIM(RTRIM(p_OBJECT_DISPLAY_NAME)),
				NVL(p_OBJECT_ORDER,0),
				NVL(p_OBJECT_IS_HIDDEN,0),
				SYSDATE);
			o_OBJECT_ID := v_OBJECT_ID;
		ELSE
			o_OBJECT_ID := GA.DUPLICATE_ENTITY;
		END IF;
	END IF;

	--INSERT ATTRIBUTE ASSIGNMENTS AND VALUES.
	IF o_OBJECT_ID > 0 AND LENGTH(p_ATTRIBUTES) > 0 THEN
		PUT_SYSTEM_OBJECT_ATTRIBUTES(o_OBJECT_ID, p_ATTRIBUTES, p_STATUS);
	END IF;

	EXCEPTION
		WHEN DUP_VAL_ON_INDEX THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			o_OBJECT_ID := GA.DUPLICATE_ENTITY;
			RETURN;

END PUT_SYSTEM_OBJECT;
----------------------------------------------------------------------------------------------------
PROCEDURE ID_FOR_SYSTEM_OBJECT
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_OBJECT_NAME IN VARCHAR,
	p_OBJECT_INDEX IN NUMBER,
	p_OBJECT_CATEGORY IN VARCHAR,
	p_OBJECT_TYPE IN VARCHAR,
	p_CREATE_IF_NOT_FOUND IN BOOLEAN,
	p_OBJECT_ID OUT NUMBER
	) AS

-- ANSWER THE INTERNAL ID ASSOCIATED WITH THE SPECIFIED OBJECT NAME

v_OBJECT_NAME SYSTEM_OBJECT.OBJECT_NAME%TYPE;

BEGIN

	v_OBJECT_NAME := LTRIM(RTRIM(p_OBJECT_NAME));
	p_OBJECT_ID := 0;

	IF LENGTH(v_OBJECT_NAME) = 0 THEN
		RETURN;
	END IF;

	BEGIN
		SELECT OBJECT_ID
		INTO p_OBJECT_ID
		FROM SYSTEM_OBJECT
		WHERE PARENT_OBJECT_ID = p_PARENT_OBJECT_ID
			AND UPPER(OBJECT_NAME) = UPPER(v_OBJECT_NAME)
			AND OBJECT_INDEX = p_OBJECT_INDEX
			AND OBJECT_CATEGORY = p_OBJECT_CATEGORY
			AND OBJECT_TYPE = p_OBJECT_TYPE;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			IF p_CREATE_IF_NOT_FOUND THEN
					PUT_SYSTEM_OBJECT(
							p_OBJECT_ID,
							0,
							p_PARENT_OBJECT_ID,
							v_OBJECT_NAME,
							p_OBJECT_INDEX,
							p_OBJECT_CATEGORY,
							p_OBJECT_TYPE,
							SUBSTR(v_OBJECT_NAME || ' ' || p_OBJECT_CATEGORY,1,32), --OBJECT_ALIAS
							'Generated by RetailOffice',					 --OBJECT_DESC
							NULL,		  --OBJECT_DISPLAY_NAME
							0,			  --OBJECT_ORDER
							0, 		  --OBJECT_IS_HIDDEN
							'');		  --ATTRIBUTE LIST
			ELSE
			    p_OBJECT_ID := GA.NO_DATA_FOUND;
			END IF;
	END;

END ID_FOR_SYSTEM_OBJECT;
----------------------------------------------------------------------------------------------------
PROCEDURE ID_FOR_SYSTEM_OBJECT_E
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_OBJECT_NAME IN VARCHAR,
	p_OBJECT_INDEX IN NUMBER,
	p_OBJECT_CATEGORY IN VARCHAR,
	p_OBJECT_TYPE IN VARCHAR,
	p_CREATE_IF_NOT_FOUND IN NUMBER,
	p_OBJECT_ID OUT NUMBER
	) AS
BEGIN
	ID_FOR_SYSTEM_OBJECT(p_PARENT_OBJECT_ID, p_OBJECT_NAME, p_OBJECT_INDEX,
    					p_OBJECT_CATEGORY, p_OBJECT_TYPE, p_CREATE_IF_NOT_FOUND<>0,
                        p_OBJECT_ID);
END ID_FOR_SYSTEM_OBJECT_E;
----------------------------------------------------------------------------------------------------
PROCEDURE ID_FOR_SYSTEM_VIEW
	(
	p_SYSTEM_VIEW_NAME IN VARCHAR2,
	p_OBJECT_ID OUT NUMBER,
	p_MODULE_NAME OUT VARCHAR2
	) AS

-- ANSWER THE INTERNAL ID ASSOCIATED WITH THE SPECIFIED SYSTEM VIEW.
-- ASSUME NAMES ARE UNIQUE ON SYSTEM VIEWS.

BEGIN

	--Grab the object ID and the name of the parent (module)
	BEGIN
		SELECT A.OBJECT_ID, B.OBJECT_NAME
		INTO p_OBJECT_ID, p_MODULE_NAME
		FROM SYSTEM_OBJECT A, SYSTEM_OBJECT B
		WHERE UPPER(A.OBJECT_NAME) = UPPER(p_SYSTEM_VIEW_NAME)
			AND A.OBJECT_CATEGORY = 'System View'
			AND B.OBJECT_ID = A.PARENT_OBJECT_ID
			AND ROWNUM = 1;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			p_OBJECT_ID := -1;
			p_MODULE_NAME := NULL;
			RETURN;
	END;

END ID_FOR_SYSTEM_VIEW;
----------------------------------------------------------------------------------------------------
PROCEDURE SYSTEM_OBJECTS
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_OBJECT_CATEGORY IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	SYSTEM_OBJECTS_E(p_PARENT_OBJECT_ID, p_OBJECT_CATEGORY, -1, NULL, 1, p_STATUS, p_CURSOR);
END SYSTEM_OBJECTS;
----------------------------------------------------------------------------------------------------
PROCEDURE SYSTEM_OBJECTS_E
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_OBJECT_CATEGORY IN VARCHAR,
    p_OBJECT_INDEX IN NUMBER,
    p_OBJECT_TYPE IN VARCHAR2,
    p_INCLUDE_HIDDEN IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
-- ANSWER A RECORDSET CONTAINING CHILD OBJECT INFORMATION FOR THE GIVEN PARENT.
v_WORK_ID	NUMBER;
BEGIN

	p_STATUS := GA.SUCCESS;

	v_WORK_ID := ENUMERATE_HIERARCHY(p_PARENT_OBJECT_ID, 1, FALSE, UT.BOOLEAN_FROM_NUMBER(p_INCLUDE_HIDDEN),
									p_INCLUDED_CATEGORIES => STRING_COLLECTION(p_OBJECT_CATEGORY));

	OPEN p_CURSOR FOR
		SELECT A.OBJECT_ID,
			A.PARENT_OBJECT_ID,
			A.OBJECT_NAME,
			A.OBJECT_INDEX,
			A.OBJECT_CATEGORY,
			A.OBJECT_TYPE,
			A.OBJECT_ALIAS,
			A.OBJECT_DESC,
			NVL(A.OBJECT_DISPLAY_NAME, INITCAP(REPLACE(A.OBJECT_NAME, '_', ' '))) as OBJECT_DISPLAY_NAME,
			A.OBJECT_ORDER as OBJECT_ORDER,
			NVL(A.OBJECT_IS_HIDDEN, 0) as OBJECT_IS_HIDDEN,
			A.ENTRY_DATE
		FROM SYSTEM_OBJECT A,
			RTO_WORK W
        WHERE A.PARENT_OBJECT_ID = p_PARENT_OBJECT_ID
			AND W.WORK_ID = v_WORK_ID
			AND W.WORK_XID = A.OBJECT_ID
          	AND (p_OBJECT_INDEX = -1 OR A.OBJECT_INDEX = p_OBJECT_INDEX)
            AND (p_OBJECT_TYPE IS NULL OR A.OBJECT_TYPE = p_OBJECT_TYPE)
        ORDER BY A.OBJECT_ORDER;

	UT.PURGE_RTO_WORK(v_WORK_ID);

END SYSTEM_OBJECTS_E;
----------------------------------------------------------------------------------------------------
PROCEDURE SYSTEM_OBJECT_ATTRIBUTES
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_OBJECT_CATEGORY IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	SYSTEM_OBJECT_ATTRIBUTES_E(p_PARENT_OBJECT_ID, p_OBJECT_CATEGORY, -1, NULL, 1, p_STATUS, p_CURSOR);
END SYSTEM_OBJECT_ATTRIBUTES;
----------------------------------------------------------------------------------------------------
PROCEDURE SYSTEM_OBJECT_ATTRIBUTES_E
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_OBJECT_CATEGORY IN VARCHAR,
    p_OBJECT_INDEX IN NUMBER,
    p_OBJECT_TYPE IN VARCHAR2,
    p_INCLUDE_HIDDEN IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- CALLED BY OBJECT CONFIG DIALOG.  RETURNS ALL ATTRIBUTES BY OBJECT,
-- INCLUDING ATTRIBUTES THAT ARE NOT ASSIGNED TO THE OBJECT.
v_WORK_ID	NUMBER;

BEGIN

	p_STATUS := GA.SUCCESS;

	v_WORK_ID := ENUMERATE_HIERARCHY(p_PARENT_OBJECT_ID, 1, FALSE, UT.BOOLEAN_FROM_NUMBER(p_INCLUDE_HIDDEN),
									p_INCLUDED_CATEGORIES => STRING_COLLECTION(p_OBJECT_CATEGORY));

	OPEN p_CURSOR FOR
        SELECT 0 "NOT_DEFINED",
			A.OBJECT_ORDER,
			A.OBJECT_ID,
			C.ATTRIBUTE_ID,
			C.ATTRIBUTE_NAME,
			C.ATTRIBUTE_DESC,
			B.ATTRIBUTE_VAL,
			C.ATTRIBUTE_COMBO_LIST,
			C.ATTRIBUTE_IS_BOOLEAN,
			CASE
				WHEN C.ATTRIBUTE_COMBO_LIST IS NULL
					AND NVL(C.ATTRIBUTE_IS_BOOLEAN, 0) = 0 THEN 'BIG TEXT'
				ELSE NULL
				END AS EDIT_TYPE
        FROM SYSTEM_OBJECT A,
			SYSTEM_OBJECT_ATTRIBUTE B,
			SYSTEM_ATTRIBUTE C,
			RTO_WORK W
        WHERE A.PARENT_OBJECT_ID = p_PARENT_OBJECT_ID
			AND W.WORK_ID = v_WORK_ID
			AND W.WORK_XID = A.OBJECT_ID
          	AND (p_OBJECT_INDEX = -1 OR A.OBJECT_INDEX = p_OBJECT_INDEX)
            AND (p_OBJECT_TYPE IS NULL OR A.OBJECT_TYPE = p_OBJECT_TYPE)
			AND p_OBJECT_CATEGORY LIKE C.OBJECT_CATEGORY
			AND B.OBJECT_ID = A.OBJECT_ID
			AND B.ATTRIBUTE_ID = C.ATTRIBUTE_ID
		UNION ALL
		SELECT 1 "NOT_DEFINED",
			A.OBJECT_ORDER,
			A.OBJECT_ID,
			C.ATTRIBUTE_ID,
			C.ATTRIBUTE_NAME,
			C.ATTRIBUTE_DESC,
			NULL "ATTRIBUTE_VAL",
			C.ATTRIBUTE_COMBO_LIST,
			C.ATTRIBUTE_IS_BOOLEAN,
			CASE
				WHEN C.ATTRIBUTE_COMBO_LIST IS NULL
					AND NVL(C.ATTRIBUTE_IS_BOOLEAN, 0) = 0 THEN 'BIG TEXT'
				ELSE NULL
				END "EDIT_TYPE"
        FROM SYSTEM_OBJECT A,
			SYSTEM_ATTRIBUTE C,
			RTO_WORK W
        WHERE A.PARENT_OBJECT_ID = p_PARENT_OBJECT_ID
			AND W.WORK_ID = v_WORK_ID
			AND W.WORK_XID = A.OBJECT_ID
          	AND (p_OBJECT_INDEX = -1 OR A.OBJECT_INDEX = p_OBJECT_INDEX)
            AND (p_OBJECT_TYPE IS NULL OR A.OBJECT_TYPE = p_OBJECT_TYPE)
			AND p_OBJECT_CATEGORY LIKE C.OBJECT_CATEGORY
			AND NOT EXISTS (SELECT ATTRIBUTE_ID
							FROM SYSTEM_OBJECT_ATTRIBUTE
							WHERE OBJECT_ID = A.OBJECT_ID
								AND ATTRIBUTE_ID = C.ATTRIBUTE_ID)
		UNION ALL
		SELECT 1 "NOT_DEFINED",
			NULL "OBJECT_ORDER",
			NULL "OBJECT_ID",
			C.ATTRIBUTE_ID,
			C.ATTRIBUTE_NAME,
			C.ATTRIBUTE_DESC,
			NULL "ATTRIBUTE_VAL",
			C.ATTRIBUTE_COMBO_LIST,
			C.ATTRIBUTE_IS_BOOLEAN,
			CASE
				WHEN C.ATTRIBUTE_COMBO_LIST IS NULL
					AND NVL(C.ATTRIBUTE_IS_BOOLEAN, 0) = 0 THEN 'BIG TEXT'
				ELSE NULL
				END "EDIT_TYPE"
		FROM SYSTEM_ATTRIBUTE C
		WHERE p_OBJECT_CATEGORY LIKE C.OBJECT_CATEGORY
		ORDER BY 1,2,3,5;

	UT.PURGE_RTO_WORK(v_WORK_ID);

END SYSTEM_OBJECT_ATTRIBUTES_E;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_SYSTEM_GRID
	(
	p_MODULE_NAME IN VARCHAR,
	p_GRID_NAME IN VARCHAR,
	p_GRID_INDEX IN NUMBER,
	p_GRID_TYPE IN VARCHAR,
	p_GRID_ALIAS IN VARCHAR,
	p_GRID_DESC IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS
v_MODULE_ID NUMBER(9);
v_GRID_ID NUMBER(9);
--DEPRECATED - ONLY USED IN VB.
BEGIN
	ID_FOR_SYSTEM_OBJECT(0, p_MODULE_NAME, 0, 'Module', 'Default', TRUE, v_MODULE_ID);
	ID_FOR_SYSTEM_OBJECT(v_MODULE_ID, p_GRID_NAME, p_GRID_INDEX, 'Grid', p_GRID_TYPE, TRUE, v_GRID_ID);
	PUT_SYSTEM_OBJECT(v_GRID_ID, v_GRID_ID, v_MODULE_ID, p_GRID_NAME, p_GRID_INDEX, 'Grid', p_GRID_TYPE, p_GRID_ALIAS, p_GRID_DESC, NULL, 0, 0, '');
	p_STATUS := v_GRID_ID;
END PUT_SYSTEM_GRID;
----------------------------------------------------------------------------------------------------
PROCEDURE SYSTEM_OBJECTS_AND_ATTRIBUTES
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_OBJECT_CATEGORY IN VARCHAR,
    p_OBJECT_INDEX IN NUMBER,
    p_OBJECT_TYPE IN VARCHAR2,
    p_INCLUDE_HIDDEN IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- ANSWER A RECORDSET CONTAINING CHILD OBJECT INFORMATION FOR THE GIVEN PARENT.
v_WORK_ID	NUMBER;

BEGIN

	p_STATUS := GA.SUCCESS;

	v_WORK_ID := ENUMERATE_HIERARCHY(p_PARENT_OBJECT_ID, 1, FALSE, UT.BOOLEAN_FROM_NUMBER(p_INCLUDE_HIDDEN),
									p_INCLUDED_CATEGORIES => STRING_COLLECTION(p_OBJECT_CATEGORY));

	OPEN p_CURSOR FOR
		-- get child objects first
        SELECT A.OBJECT_NAME,
			NVL(A.OBJECT_DISPLAY_NAME, INITCAP(REPLACE(A.OBJECT_NAME, '_', ' '))) as OBJECT_DISPLAY_NAME,
			NVL(A.OBJECT_IS_HIDDEN, 0) as OBJECT_IS_HIDDEN,
			A.OBJECT_ORDER as OBJECT_ORDER,
			A.OBJECT_CATEGORY,
			A.OBJECT_ID,
			A.PARENT_OBJECT_ID,
			B.ATTRIBUTE_ID,
			C.ATTRIBUTE_NAME,
			C.ATTRIBUTE_DESC,
			B.ATTRIBUTE_VAL,
			0 as ORDER_ME,-- return child objects first, then parent object
			A.OBJECT_TYPE
        FROM SYSTEM_OBJECT A,
			SYSTEM_OBJECT_ATTRIBUTE B,
			SYSTEM_ATTRIBUTE C,
			RTO_WORK W
        WHERE W.WORK_ID = v_WORK_ID
			AND A.OBJECT_ID = W.WORK_XID
			AND (p_OBJECT_INDEX = -1 OR A.OBJECT_INDEX = p_OBJECT_INDEX)
			AND (p_OBJECT_TYPE IS NULL OR A.OBJECT_TYPE = p_OBJECT_TYPE)
			AND B.OBJECT_ID (+) = A.OBJECT_ID
			AND C.ATTRIBUTE_ID (+) = B.ATTRIBUTE_ID
			AND p_OBJECT_CATEGORY LIKE C.OBJECT_CATEGORY(+)
		UNION ALL
		-- return NULL name for parent object (that's what UI expects)
        SELECT NULL as OBJECT_NAME,
			NVL(A.OBJECT_DISPLAY_NAME, INITCAP(REPLACE(A.OBJECT_NAME, '_', ' '))) as OBJECT_DISPLAY_NAME,
			NVL(A.OBJECT_IS_HIDDEN, 0) as OBJECT_IS_HIDDEN,
			A.OBJECT_ORDER as OBJECT_ORDER,
			A.OBJECT_CATEGORY,
			A.OBJECT_ID,
			A.PARENT_OBJECT_ID,
			B.ATTRIBUTE_ID,
			C.ATTRIBUTE_NAME,
			C.ATTRIBUTE_DESC,
			B.ATTRIBUTE_VAL,
			1 as ORDER_ME,
			A.OBJECT_TYPE
        FROM SYSTEM_OBJECT A,
			SYSTEM_OBJECT_ATTRIBUTE B,
			SYSTEM_ATTRIBUTE C
        WHERE A.OBJECT_ID = p_PARENT_OBJECT_ID
			AND B.OBJECT_ID = A.OBJECT_ID
			AND C.ATTRIBUTE_ID = B.ATTRIBUTE_ID
			AND A.OBJECT_CATEGORY LIKE C.OBJECT_CATEGORY
		ORDER BY ORDER_ME, OBJECT_CATEGORY, OBJECT_ORDER, OBJECT_NAME, ATTRIBUTE_NAME;

	UT.PURGE_RTO_WORK(v_WORK_ID);

END SYSTEM_OBJECTS_AND_ATTRIBUTES;
----------------------------------------------------------------------------------------------------
PROCEDURE SYSTEM_GRID_COLS
	(
	p_MODULE_NAME IN VARCHAR,
	p_GRID_NAME IN VARCHAR,
	p_GRID_INDEX IN NUMBER,
	p_GRID_TYPE IN VARCHAR,
	p_GRID_ID OUT NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- ANSWER A RECORDSET CONTAINING GRID COL INFORMATION FOR THE SPECIFIED GRID.
-- DEPRECATED - ONLY USED IN VB.  JAVA USES GET_SYSTEM_OBJECT_HIERARCHY PROCS.
v_MODULE_ID NUMBER(9);
v_GRID_ID NUMBER(9);
BEGIN

	p_STATUS := GA.SUCCESS;
	ID_FOR_SYSTEM_OBJECT(0, p_MODULE_NAME, 0, 'Module', 'Default', TRUE, v_MODULE_ID);
	ID_FOR_SYSTEM_OBJECT(v_MODULE_ID, p_GRID_NAME, p_GRID_INDEX, 'Grid', p_GRID_TYPE, FALSE, v_GRID_ID);

	IF v_GRID_ID <= 0 THEN
		p_GRID_ID := 0;
		NULL_CURSOR(p_CURSOR);
	ELSE
		p_GRID_ID := v_GRID_ID;
		SYSTEM_OBJECTS_AND_ATTRIBUTES(v_GRID_ID, 'Column', -1, NULL, 1, p_STATUS, p_CURSOR);
	END IF;

END SYSTEM_GRID_COLS;
----------------------------------------------------------------------------------------------------
PROCEDURE GENERATE_SYSTEM_GRID_COLS
	(
	p_GRID_ID IN NUMBER,
	p_COL_NAMES IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_STRING_TABLE GA.STRING_TABLE;
v_INDEX BINARY_INTEGER;
v_COL_NAME SYSTEM_OBJECT.OBJECT_NAME%TYPE;
v_COL_ID NUMBER(9);
BEGIN

GENERATE_SYSTEM_OBJ_CHILDREN(p_GRID_ID, 'Column', p_COL_NAMES, p_STATUS);

END GENERATE_SYSTEM_GRID_COLS;
----------------------------------------------------------------------------------------------------
PROCEDURE GENERATE_SYSTEM_OBJ_CHILDREN
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_CHILD_CATEGORY IN VARCHAR,
	p_OBJECT_NAMES IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_STRING_TABLE GA.STRING_TABLE;
v_INDEX BINARY_INTEGER;
v_OBJ_NAME SYSTEM_OBJECT.OBJECT_NAME%TYPE;
v_COL_ID NUMBER(9);
BEGIN

	ASSERT(p_PARENT_OBJECT_ID IS NOT NULL, 'Parent Object Id must be set, the value was NULL.');
	ASSERT(p_PARENT_OBJECT_ID > 0, 'Parent Object Id must be > 0, the value was ' || p_PARENT_OBJECT_ID || '.');
	ASSERT(p_CHILD_CATEGORY IS NOT NULL, 'Child Category must be set, the value was NULL.');

	UT.TOKENS_FROM_STRING(p_OBJECT_NAMES,',', v_STRING_TABLE);
 	FOR v_INDEX IN v_STRING_TABLE.FIRST..v_STRING_TABLE.LAST LOOP
		v_OBJ_NAME := v_STRING_TABLE(v_INDEX);

		PUT_SYSTEM_OBJECT(
			v_COL_ID,		--OBJECT_ID OUT
			0,					--OBJECT_ID IN
			p_PARENT_OBJECT_ID,		--PARENT_OBJECT_NAME
			v_OBJ_NAME, 	--OBJECT_NAME
			0,					--OBJECT_INDEX
			p_CHILD_CATEGORY,		--OBJECT_CATEGORY
			'Default',		--OBJECT_TYPE
			NULL,				--OBJECT_ALIAS
			NULL,				--OBJECT_DESC
			NULL,	  	 		--OBJECT_DISPLAY_NAME
			v_INDEX - 1,	--OBJECT_ORDER
			0,					--OBJECT_IS_HIDDEN
			''					--ATTRIBUTES
		);
	END LOOP;

END GENERATE_SYSTEM_OBJ_CHILDREN;
----------------------------------------------------------------------------------------------------
FUNCTION GET_SYSTEM_ATTRIBUTE_STRING
	(
	p_COL_ID IN NUMBER
	) RETURN VARCHAR IS

v_ATTRIBUTES VARCHAR(4000) := '';

CURSOR c_COL_ATTRIBUTES IS
SELECT ATTRIBUTE_ID, ATTRIBUTE_VAL
FROM SYSTEM_OBJECT_ATTRIBUTE
WHERE OBJECT_ID = p_COL_ID;

BEGIN

	FOR v_COL_ATTRIBUTES IN c_COL_ATTRIBUTES LOOP
		 v_ATTRIBUTES := v_ATTRIBUTES || v_COL_ATTRIBUTES.ATTRIBUTE_ID ||
		 					'~' || DO_ESCAPE(v_COL_ATTRIBUTES.ATTRIBUTE_VAL) || '^';
	END LOOP;

	--STRIP TRAILING DELIMITER.
	IF LENGTH(v_ATTRIBUTES) > 1 THEN
		v_ATTRIBUTES := SUBSTR(v_ATTRIBUTES,1,LENGTH(v_ATTRIBUTES)-1);
	END IF;
	RETURN v_ATTRIBUTES;

	EXCEPTION
		WHEN OTHERS THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN NULL;

END GET_SYSTEM_ATTRIBUTE_STRING;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SYSTEM_OBJECT_SCRIPT
	(
	p_MODULE_NAME IN VARCHAR,
    p_CHILD_OBJECT_TYPE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

v_WORK_ID NUMBER(9);
v_INDEX BINARY_INTEGER := 0;
v_MODULE_ID NUMBER(9);
v_OBJ_ID NUMBER(9);
v_CHILD_ID NUMBER(9);
v_ATTRIBUTES VARCHAR(4000);
v_COUNT_CHILDREN NUMBER;
v_LAST_CATEGORY VARCHAR(64) := '?';

CURSOR c_SYSTEM_OBJECTS IS
SELECT OBJECT_ID, OBJECT_NAME, OBJECT_INDEX, OBJECT_TYPE,
	OBJECT_ALIAS, OBJECT_DESC, OBJECT_DISPLAY_NAME, OBJECT_ORDER, OBJECT_IS_HIDDEN,
    DECODE(p_CHILD_OBJECT_TYPE,'Grid',OBJECT_NAME,TO_CHAR(OBJECT_INDEX,'0000')) "SORT_FIELD_1",
    DECODE(p_CHILD_OBJECT_TYPE,'Grid',TO_CHAR(OBJECT_INDEX,'0000'),OBJECT_TYPE) "SORT_FIELD_2",
    DECODE(p_CHILD_OBJECT_TYPE,'Grid',OBJECT_TYPE,TO_CHAR(OBJECT_ORDER,'0000')) "SORT_FIELD_3",
    DECODE(p_CHILD_OBJECT_TYPE,'Grid',TO_CHAR(OBJECT_ORDER,'0000'),OBJECT_NAME) "SORT_FIELD_4"
FROM SYSTEM_OBJECT
WHERE PARENT_OBJECT_ID = v_MODULE_ID
	AND OBJECT_CATEGORY = p_CHILD_OBJECT_TYPE
ORDER BY SORT_FIELD_1,SORT_FIELD_2,SORT_FIELD_3,SORT_FIELD_4;

CURSOR c_OBJECT_CHILDREN IS
SELECT OBJECT_ID, OBJECT_NAME, OBJECT_CATEGORY, OBJECT_INDEX, OBJECT_TYPE,
	OBJECT_ALIAS, OBJECT_DESC, OBJECT_DISPLAY_NAME, OBJECT_ORDER, OBJECT_IS_HIDDEN
FROM SYSTEM_OBJECT
WHERE PARENT_OBJECT_ID = v_OBJ_ID
ORDER BY OBJECT_CATEGORY, OBJECT_ORDER;

BEGIN

	p_STATUS := GA.SUCCESS;

	UT.GET_RTO_WORK_ID(v_WORK_ID);

	UT.POST_RTO_WORK(v_WORK_ID,v_INDEX,'DECLARE');
	UT.POST_RTO_WORK(v_WORK_ID,v_INDEX+1,'    p_STATUS NUMBER;');
	UT.POST_RTO_WORK(v_WORK_ID,v_INDEX+2,'    v_OBJ_ID NUMBER(9);');
	UT.POST_RTO_WORK(v_WORK_ID,v_INDEX+3,'    v_MODULE_ID NUMBER(9);');
	UT.POST_RTO_WORK(v_WORK_ID,v_INDEX+4,'    v_CHILD_ID NUMBER(9);');
	UT.POST_RTO_WORK(v_WORK_ID,v_INDEX+5,'BEGIN');
	UT.POST_RTO_WORK(v_WORK_ID,v_INDEX+6,'    SO.ID_FOR_SYSTEM_OBJECT(0,''' || p_MODULE_NAME || ''',0,''Module'',''Default'',TRUE,v_MODULE_ID);');
	v_INDEX := v_INDEX + 7;

	ID_FOR_SYSTEM_OBJECT(0,p_MODULE_NAME,0,'Module','Default',TRUE,v_MODULE_ID);
	FOR v_SYSTEM_OBJECT IN c_SYSTEM_OBJECTS LOOP
		v_OBJ_ID := v_SYSTEM_OBJECT.OBJECT_ID;
		UT.POST_RTO_WORK(v_WORK_ID,v_INDEX,'');
		UT.POST_RTO_WORK(v_WORK_ID,v_INDEX+1,'    SO.ID_FOR_SYSTEM_OBJECT(v_MODULE_ID,''' || v_SYSTEM_OBJECT.OBJECT_NAME || ''',' || TO_CHAR(v_SYSTEM_OBJECT.OBJECT_INDEX) || ','''||p_CHILD_OBJECT_TYPE||''',''' ||
						v_SYSTEM_OBJECT.OBJECT_TYPE || ''',FALSE,v_OBJ_ID);');
		UT.POST_RTO_WORK(v_WORK_ID,v_INDEX+2,'    IF v_OBJ_ID = GA.NO_DATA_FOUND THEN v_OBJ_ID := 0; END IF;');
		v_ATTRIBUTES := GET_SYSTEM_ATTRIBUTE_STRING(v_OBJ_ID);
		UT.POST_RTO_WORK(v_WORK_ID,v_INDEX+3,'    SO.PUT_SYSTEM_OBJECT(v_OBJ_ID,v_OBJ_ID,v_MODULE_ID,''' || v_SYSTEM_OBJECT.OBJECT_NAME || ''','||v_SYSTEM_OBJECT.OBJECT_INDEX||','''||p_CHILD_OBJECT_TYPE||''','''||v_SYSTEM_OBJECT.OBJECT_TYPE||''','||
       				''''||v_SYSTEM_OBJECT.OBJECT_ALIAS||''','''||v_SYSTEM_OBJECT.OBJECT_DESC||''','''||v_SYSTEM_OBJECT.OBJECT_DISPLAY_NAME||''','||TO_CHAR(v_SYSTEM_OBJECT.OBJECT_ORDER)||','||TO_CHAR(v_SYSTEM_OBJECT.OBJECT_IS_HIDDEN) ||','''||v_ATTRIBUTES||''');');
		v_INDEX := v_INDEX + 4;
		SELECT COUNT(*) INTO v_COUNT_CHILDREN
			FROM SYSTEM_OBJECT WHERE PARENT_OBJECT_ID = v_OBJ_ID;
		IF v_COUNT_CHILDREN > 0 THEN
			UT.POST_RTO_WORK(v_WORK_ID,v_INDEX,'    IF v_OBJ_ID > 0 THEN');
			v_INDEX := v_INDEX + 1;
			v_COUNT_CHILDREN := 0;
			FOR v_OBJECT_CHILD IN c_OBJECT_CHILDREN LOOP
            	IF v_OBJECT_CHILD.OBJECT_CATEGORY <> v_LAST_CATEGORY THEN
                	IF v_COUNT_CHILDREN>0 THEN
						UT.POST_RTO_WORK(v_WORK_ID,v_INDEX,'');
	                    v_INDEX := v_INDEX+1;
                    END IF;
                	v_LAST_CATEGORY := v_OBJECT_CHILD.OBJECT_CATEGORY;
                END IF;
				v_CHILD_ID := v_OBJECT_CHILD.OBJECT_ID;
				v_ATTRIBUTES := GET_SYSTEM_ATTRIBUTE_STRING(v_CHILD_ID);
				UT.POST_RTO_WORK(v_WORK_ID,v_INDEX+2,'        SO.PUT_SYSTEM_OBJECT(v_CHILD_ID,0,v_OBJ_ID,'''||v_OBJECT_CHILD.OBJECT_NAME||''','||v_OBJECT_CHILD.OBJECT_INDEX||','''||v_OBJECT_CHILD.OBJECT_CATEGORY||''','''||v_OBJECT_CHILD.OBJECT_TYPE||''','||
	    	   				''''||v_OBJECT_CHILD.OBJECT_ALIAS||''','''||v_OBJECT_CHILD.OBJECT_DESC||''','''||v_OBJECT_CHILD.OBJECT_DISPLAY_NAME||''','||TO_CHAR(v_OBJECT_CHILD.OBJECT_ORDER)||','||TO_CHAR(v_OBJECT_CHILD.OBJECT_IS_HIDDEN) ||','''||v_ATTRIBUTES||''');');
				v_INDEX := v_INDEX + 3;
				v_COUNT_CHILDREN := v_COUNT_CHILDREN+1;
			END LOOP;
			UT.POST_RTO_WORK(v_WORK_ID,v_INDEX,'    END IF;');
			v_INDEX := v_INDEX + 1;
		END IF;
	END LOOP;
	UT.POST_RTO_WORK(v_WORK_ID,v_INDEX,'END;');
	UT.POST_RTO_WORK(v_WORK_ID,v_INDEX+1,'/');
	UT.POST_RTO_WORK(v_WORK_ID,v_INDEX+2,'');

	OPEN p_CURSOR FOR
		  SELECT WORK_DATA
		  FROM RTO_WORK
		  WHERE WORK_ID = v_WORK_ID
		  ORDER BY WORK_SEQ;

	UT.PURGE_RTO_WORK(v_WORK_ID);

EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			UT.PURGE_RTO_WORK(v_WORK_ID);
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE();
		END;
		ERRS.LOG_AND_RAISE();

END GET_SYSTEM_OBJECT_SCRIPT;
----------------------------------------------------------------------------------------------------
-- WORK_XID from the input work data represents OBJECT_IDs to export. Find all
-- database dependancies for these objects and write them output work data.
-- Return the number of rows written to output work data.
FUNCTION GET_REPORT_DEPENDENCIES
	(
	p_WORK_ID_IN IN NUMBER,
	p_WORK_ID_OUT IN NUMBER
	) RETURN NUMBER IS
v_RET NUMBER;
BEGIN
	INSERT INTO RTO_WORK(WORK_ID,WORK_SEQ,WORK_DATA)
		VALUES (p_WORK_ID_OUT,0,'/*');

	 -- next get list of package dependencies
	INSERT INTO RTO_WORK(WORK_ID,WORK_SEQ,WORK_DATA)
	SELECT p_WORK_ID_OUT, ROWNUM, NAME
	FROM (select distinct case
        				when ud.referenced_type = 'PACKAGE BODY' then 'PACKAGE'
        				when ud.referenced_type = 'TYPE BODY' then 'TYPE'
        				else ud.referenced_type
        			end || '::' ||
        			case
        				when ud.referenced_owner = user then null
        				else ud.referenced_owner || '.'
        			end || ud.referenced_name as NAME
        	from user_dependencies ud,
				-- get names of all packages referred to by config attributes
        		 (SELECT DISTINCT CASE
        				WHEN INSTR(ATTRIBUTE_VAL,'|')=1 THEN
        					SUBSTR (ATTRIBUTE_VAL, 2 , INSTR(ATTRIBUTE_VAL,'.') - 2)
        				ELSE
        					SUBSTR (ATTRIBUTE_VAL, 1 , INSTR(ATTRIBUTE_VAL,'.') - 1)
        				END as NAME
        		  FROM (SELECT SOA.ATTRIBUTE_VAL
                		FROM SYSTEM_OBJECT_ATTRIBUTE SOA, RTO_WORK W
                		WHERE W.WORK_ID = p_WORK_ID_IN
        					AND SOA.OBJECT_ID = W.WORK_XID
        					AND SOA.ATTRIBUTE_ID IN (401,404,412,504,301,302,16)
        	          UNION ALL
        	          SELECT SOA2.ATTRIBUTE_VAL
                		FROM SYSTEM_OBJECT_ATTRIBUTE SOA1, SYSTEM_OBJECT_ATTRIBUTE SOA2, RTO_WORK W
                		WHERE W.WORK_ID = p_WORK_ID_IN
        					AND SOA1.OBJECT_ID = W.WORK_XID
        					AND SOA1.ATTRIBUTE_ID = 1006 -- get action type
        					AND SOA1.ATTRIBUTE_VAL IN (0,3,4) -- if it is 'proc', 'warning', or 'drill-down'
        					AND SOA2.OBJECT_ID = W.WORK_XID
        					AND SOA2.ATTRIBUTE_ID = 1007))  V
        	where ud.name = v.name
        		and ud.type in ('PACKAGE','PACKAGE BODY')
				-- determine dependancies for all referred packages
        		and referenced_type in
        			('TABLE','VIEW','FUNCTION','PROCEDURE','PACKAGE','PACKAGE BODY','TYPE','TYPE BODY','SEQUENCE','MATERIALIZED VIEW')
            	and referenced_owner not in ('SYS', 'PUBLIC')
        	order by 1);

	v_RET := SQL%ROWCOUNT+2;

	INSERT INTO RTO_WORK(WORK_ID,WORK_SEQ,WORK_DATA)
		VALUES (p_WORK_ID_OUT,v_RET-1,'*/');

	RETURN v_RET;

END GET_REPORT_DEPENDENCIES;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SYS_OBJ_SCRIPT_WITH_HIER
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_OBJECT_CATEGORY IN VARCHAR2,
	p_FOR_REPOSITORY IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

v_WORK_OBJECT_IDs NUMBER(9);
v_WORK_ID NUMBER(9);
v_WORK_SEQ NUMBER := 0;

v_FIRST_OBJECT SYSTEM_OBJECT%ROWTYPE;
v_CUR_LABEL_NUM NUMBER(3) := 0;
v_BLOCKS SCRIPT_BLOCK_TABLE := SCRIPT_BLOCK_TABLE();
v_CUR_LEVEL NUMBER(3);
v_CUR_BLOCK SCRIPT_BLOCK_RECORD;
v_CUR_LABEL VARCHAR2(16);

CURSOR c_PARENTS IS
	SELECT OBJECT_ID,
            PARENT_OBJECT_ID,
            OBJECT_NAME,
            OBJECT_INDEX,
            OBJECT_CATEGORY,
            OBJECT_TYPE,
            OBJECT_ALIAS,
            OBJECT_DESC,
            OBJECT_DISPLAY_NAME,
            OBJECT_TAG,
            OBJECT_ORDER,
            OBJECT_IS_HIDDEN,
            ENTRY_DATE,
            LEVEL
	FROM SYSTEM_OBJECT A
    WHERE A.OBJECT_ID <> p_PARENT_OBJECT_ID
	START WITH A.OBJECT_ID = p_PARENT_OBJECT_ID
	CONNECT BY PRIOR A.PARENT_OBJECT_ID = A.OBJECT_ID
        AND A.OBJECT_ID <> 0 -- Do not include the TOP LEVEL OBJECT "System" with id = 0
	ORDER BY LEVEL DESC;

	--------------------------------------------------------
	PROCEDURE ADD_LINE
		(
		p_LINE IN VARCHAR2
		) AS
	BEGIN
		UT.POST_RTO_WORK(v_WORK_ID, v_WORK_SEQ,
			LPAD('   ',  v_CUR_LEVEL * 3, ' ') || p_LINE);
		v_WORK_SEQ := v_WORK_SEQ + 1;
	END ADD_LINE;
	----------------------------------------------------------
	PROCEDURE ADD_OBJECT_SCRIPT
		(
		p_OBJECT IN SYSTEM_OBJECT%ROWTYPE,
		p_PARENT_ONLY IN BOOLEAN := FALSE,
		p_OBJECT_CATEGORY IN VARCHAR2 := 'All'
		) AS

		CURSOR c_CHILDREN RETURN SYSTEM_OBJECT%ROWTYPE IS
    		SELECT SO.*
            FROM SYSTEM_OBJECT SO,
				RTO_WORK W
			WHERE W.WORK_ID = v_WORK_OBJECT_IDs
				AND W.WORK_SEQ = p_OBJECT.OBJECT_ID
				AND SO.OBJECT_ID = W.WORK_XID
                AND (p_OBJECT_CATEGORY = 'All' OR SO.OBJECT_CATEGORY = p_OBJECT_CATEGORY)
    	    ORDER BY SO.OBJECT_CATEGORY, SO.OBJECT_ORDER, SO.OBJECT_NAME;

		v_ATTRIBUTE_STRING VARCHAR2(4000) := GET_SYSTEM_ATTRIBUTE_STRING(p_OBJECT.OBJECT_ID);
		v_HAS_CHILDREN BOOLEAN;
		v_SO c_CHILDREN%ROWTYPE;
	BEGIN

		--Our level is the previous block on the stack plus one.
		v_CUR_LEVEL := v_BLOCKS(v_BLOCKS.LAST).CUR_LEVEL + 1;

		--Determine whether this object has children.
		OPEN c_CHILDREN;
		FETCH c_CHILDREN INTO v_SO;
		IF c_CHILDREN%NOTFOUND THEN
			v_HAS_CHILDREN := FALSE;
		ELSE
			v_HAS_CHILDREN := TRUE;
		END IF;
		CLOSE c_CHILDREN;

		IF p_PARENT_ONLY THEN
			--Just recurse to add the child blocks.
			FOR v_CHILDREN IN c_CHILDREN LOOP
				ADD_OBJECT_SCRIPT(v_CHILDREN);
			END LOOP;
		ELSIF v_HAS_CHILDREN OR v_CUR_LEVEL = 1 THEN
			IF v_CUR_LEVEL = 1 THEN
				ADD_LINE('-------------------------------------');
				ADD_LINE('--   ' || p_OBJECT.OBJECT_NAME);
				ADD_LINE('-------------------------------------');
			ELSE

				--Our label name is the last one used plus one.
				v_CUR_LABEL_NUM := v_CUR_LABEL_NUM + 1;
				v_CUR_LABEL := 'L' || TO_CHAR(v_CUR_LABEL_NUM);

				IF v_CUR_LEVEL = 2 THEN --COMMENT DOWN TO THE SECOND LEVEL.
					ADD_LINE('-------------------------------------');
					ADD_LINE('--   ' || p_OBJECT.OBJECT_NAME);
					ADD_LINE('-------------------------------------');
				END IF;
				ADD_LINE('<<' || v_CUR_LABEL || '>>');

				--Declare the new set of variables, initializing the parent
				--to the previous parent label name.
				ADD_LINE('DECLARE');
				ADD_LINE('   v_PARENT_OBJECT_ID NUMBER(9) := ' || v_BLOCKS(v_BLOCKS.LAST).PARENT_LAYOUT || ';');
				ADD_LINE('   v_OBJECT_ID NUMBER(9);');
				ADD_LINE('BEGIN');
			END IF;

				--Add the part to create this system object and its attributes.
				ADD_LINE('   SO.PUT_SYSTEM_OBJECT_FOR_SCRIPT(v_PARENT_OBJECT_ID, ''' || p_OBJECT.OBJECT_NAME || ''', ''' ||
						p_OBJECT.OBJECT_CATEGORY || ''', ''' ||
						p_OBJECT.OBJECT_DISPLAY_NAME || ''', ''' ||
						p_OBJECT.OBJECT_TAG || ''', ' ||
						p_OBJECT.OBJECT_ORDER || ', ' ||
						p_OBJECT.OBJECT_IS_HIDDEN || ', ''' ||
						v_ATTRIBUTE_STRING || ''', v_OBJECT_ID);');

			--Add a block representing this level to the stack.
				v_BLOCKS.EXTEND;
				v_CUR_BLOCK.CUR_LEVEL := v_CUR_LEVEL;
				v_CUR_BLOCK.PARENT_LAYOUT := v_CUR_LABEL || '.v_OBJECT_ID';
				v_BLOCKS(v_BLOCKS.LAST) := v_CUR_BLOCK;

			--Recurse to add the child blocks.
			FOR v_CHILDREN IN c_CHILDREN LOOP
				ADD_OBJECT_SCRIPT(v_CHILDREN);
			END LOOP;

				--Pop this block off the stack.
				v_BLOCKS.TRIM;

				--Our level is the previous block on the stack plus one.
				v_CUR_LEVEL := v_BLOCKS(v_BLOCKS.LAST).CUR_LEVEL + 1;

			IF v_CUR_LEVEL > 1 THEN
				ADD_LINE('END;');
				ADD_LINE(' ');
			END IF;
		--NO CHILDREN - SIMPLY ADD LINE
		ELSE
			ADD_LINE('SO.PUT_SYSTEM_OBJECT_FOR_SCRIPT(v_OBJECT_ID, ''' || p_OBJECT.OBJECT_NAME || ''', ''' ||
					p_OBJECT.OBJECT_CATEGORY || ''', ''' ||
					p_OBJECT.OBJECT_DISPLAY_NAME || ''', ''' ||
					p_OBJECT.OBJECT_TAG || ''', ' ||
					p_OBJECT.OBJECT_ORDER || ', ' ||
					p_OBJECT.OBJECT_IS_HIDDEN || ', ''' ||
					v_ATTRIBUTE_STRING || ''', v_CHILD_OBJECT_ID);');
		END IF;
	END ADD_OBJECT_SCRIPT;
	----------------------------------------------------------

BEGIN

	p_STATUS := GA.SUCCESS;

	CHECK_OBJECT_PRIVILEGE(p_PARENT_OBJECT_ID, g_PRIV_VIEW);
	v_WORK_OBJECT_IDs := ENUMERATE_HIERARCHY(p_PARENT_OBJECT_ID);

    UT.GET_RTO_WORK_ID(v_WORK_ID);

	-- include comments about dependancies for repository - this way
	-- users know which packages and stored procedures need to accompany
	-- the report in the repository
	IF p_FOR_REPOSITORY = 1 THEN
	   	v_WORK_SEQ := GET_REPORT_DEPENDENCIES(v_WORK_OBJECT_IDs,v_WORK_ID);
	END IF;


	IF p_PARENT_OBJECT_ID = 0 THEN
        Select 0, -1, 'Dummy Object', 0, 'Dummy', 'Default', '', '', '', '', 0, 0, 0, SYSDATE INTO v_FIRST_OBJECT FROM Dual;
    ELSE
        --Get the starting object record.
    	SELECT A.* INTO v_FIRST_OBJECT
    	FROM SYSTEM_OBJECT A, RTO_WORK B
		WHERE B.WORK_ID = v_WORK_OBJECT_IDs
			AND B.WORK_XID = p_PARENT_OBJECT_ID
			AND A.OBJECT_ID = B.WORK_XID;
    END IF;

	--Add the first block to the stack.
	v_BLOCKS.EXTEND();
	v_CUR_BLOCK.CUR_LEVEL := 0;
	v_CUR_BLOCK.PARENT_LAYOUT := 'L0';
	v_BLOCKS(v_BLOCKS.LAST) := v_CUR_BLOCK;

	ADD_LINE('DECLARE');
	ADD_LINE('   p_STATUS NUMBER;');
	ADD_LINE('   v_CHILD_OBJECT_ID NUMBER(9);');
	ADD_LINE('BEGIN');
	v_CUR_LABEL := 'L0';
	ADD_LINE('<<L0>>');
	ADD_LINE('DECLARE');
	ADD_LINE('   v_PARENT_OBJECT_ID NUMBER(9) := 0;');
	ADD_LINE('   v_OBJECT_ID NUMBER(9) := 0;');
	ADD_LINE('BEGIN');
	ADD_LINE(' ');

	IF p_FOR_REPOSITORY=1 THEN -- all repository reports have one parent: ReportRepository
		ADD_LINE('SO.ID_FOR_SYSTEM_OBJECT(v_PARENT_OBJECT_ID,''' || 'ReportRepository' || ''',0,''' || 'Module' || ''',''' || 'Default' || ''',TRUE,v_OBJECT_ID);');
		ADD_LINE('v_PARENT_OBJECT_ID := v_OBJECT_ID;');
	ELSE
    	--Add the path to get to the first object.
    	FOR v_PARENTS IN c_PARENTS LOOP
    		ADD_LINE('SO.ID_FOR_SYSTEM_OBJECT(v_PARENT_OBJECT_ID, ''' || v_PARENTS.OBJECT_NAME || ''',' || v_PARENTS.OBJECT_INDEX || ',''' || v_PARENTS.OBJECT_CATEGORY || ''',''' || v_PARENTS.OBJECT_TYPE || ''',TRUE,v_OBJECT_ID);');
    		ADD_LINE('v_PARENT_OBJECT_ID := v_OBJECT_ID;');
    	END LOOP;
	END IF;

	ADD_OBJECT_SCRIPT(v_FIRST_OBJECT, p_PARENT_OBJECT_ID = 0, p_OBJECT_CATEGORY);
	v_CUR_LEVEL := 0;
	ADD_LINE('END;');
	ADD_LINE('END;');
	ADD_LINE('/');

	OPEN p_CURSOR FOR
		  SELECT WORK_DATA
		  FROM RTO_WORK
		  WHERE WORK_ID = v_WORK_ID
		  ORDER BY WORK_SEQ;

	-- clean up!
	UT.PURGE_RTO_WORK(v_WORK_OBJECT_IDs);
	UT.PURGE_RTO_WORK(v_WORK_ID);


EXCEPTION
	WHEN OTHERS THEN
		-- Cleanup Work Object Ids
		BEGIN
			UT.PURGE_RTO_WORK(v_WORK_OBJECT_IDs);
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE();
		END;
		-- Cleanup
		BEGIN
			UT.PURGE_RTO_WORK(v_WORK_ID);
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE();
		END;
		ERRS.LOG_AND_RAISE();

END GET_SYS_OBJ_SCRIPT_WITH_HIER;
----------------------------------------------------------------------------------------------------
/*
*	Called for non-repository create script requests
*/
PROCEDURE GET_SYSTEM_OBJECT_SCRIPT_HIER
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_OBJECT_CATEGORY IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	GET_SYS_OBJ_SCRIPT_WITH_HIER(p_PARENT_OBJECT_ID,
								  p_OBJECT_CATEGORY,
								  0, --for_repository
								  p_STATUS,
								  p_CURSOR);
END GET_SYSTEM_OBJECT_SCRIPT_HIER;
----------------------------------------------------------------------------------------------------
/*
*	return configuration script and dependencies for selected report
*/
PROCEDURE GET_REP_REPOSITORY_SCRIPT
	(
	p_OBJECT_ID IN NUMBER,
	p_PARENT_OBJECT_ID IN NUMBER,
	p_OBJECT_CATEGORY IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	GET_SYS_OBJ_SCRIPT_WITH_HIER(p_PARENT_OBJECT_ID,
								  p_OBJECT_CATEGORY,
								  1, --for_repository
								  p_STATUS,
								  p_CURSOR);
END GET_REP_REPOSITORY_SCRIPT;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_STORED_PROC_PARAMETERS
	(
	p_PACKAGE_NAME IN VARCHAR,
	p_PROCEDURE_NAME IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	GET_STORED_PROC_PARAMETERS_OL(p_PACKAGE_NAME, p_PROCEDURE_NAME, 0, p_STATUS, p_CURSOR);
END GET_STORED_PROC_PARAMETERS;
----------------------------------------------------------------------------------------------------
FUNCTION CAN_ACCESS_PROC
	(
	p_PACKAGE_NAME IN VARCHAR,
	p_PROCEDURE_NAME IN VARCHAR
	) RETURN BOOLEAN IS
v_COUNT PLS_INTEGER;
BEGIN
	-- find matches in the list of excluded objects
	IF p_PACKAGE_NAME IS NULL THEN
		SELECT COUNT(1)
		INTO v_COUNT
		FROM GRANT_EXECUTE_EXCLUSIONS
		WHERE OBJECT_TYPE IN ('PROCEDURE','FUNCTION')
			AND p_PROCEDURE_NAME LIKE OBJECT_NAME;
	ELSE
		SELECT COUNT(1)
		INTO v_COUNT
		FROM GRANT_EXECUTE_EXCLUSIONS
		WHERE OBJECT_TYPE = 'PACKAGE'
			AND p_PACKAGE_NAME LIKE OBJECT_NAME;
	END IF;

	-- if we found no match, then this object is accessible
	RETURN v_COUNT = 0;
END CAN_ACCESS_PROC;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_STORED_PROC_PARAMETERS_OL
	(
	p_PACKAGE_NAME IN VARCHAR,
	p_PROCEDURE_NAME IN VARCHAR,
	p_OVERLOAD_INDEX IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
	v_PARAM_TABLE STORED_PROC_PARAMETER_TABLE;
BEGIN

	p_STATUS := GA.SUCCESS;

	IF NOT CAN_ACCESS_PROC(p_PACKAGE_NAME, p_PROCEDURE_NAME) THEN
		-- empty list if this proc is inaccessible
		OPEN p_CURSOR FOR
			SELECT NULL AS PARAMETER_NAME,
				NULL AS PARAMETER_DIRECTION,
				NULL AS PARAMETER_TYPE,
				NULL AS PARAMETER_SUB_TYPE
			FROM DUAL
			WHERE 0=1;
		RETURN;
	END IF;

	UT.GET_STORED_PROC_PARAMETERS(p_PACKAGE_NAME, p_PROCEDURE_NAME, p_OVERLOAD_INDEX, v_PARAM_TABLE);
	OPEN p_CURSOR FOR
		SELECT X.PARAMETER_NAME, X.PARAMETER_DIRECTION, X.PARAMETER_TYPE, X.PARAMETER_SUB_TYPE
		FROM TABLE(CAST(v_PARAM_TABLE AS STORED_PROC_PARAMETER_TABLE)) X
		ORDER BY X.POSITION;

END GET_STORED_PROC_PARAMETERS_OL;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_STORED_PROC_OVERLOAD_COUNT
	(
	p_PACKAGE_NAME IN VARCHAR,
	p_PROCEDURE_NAME IN VARCHAR,
	p_COUNT OUT NUMBER
	) AS
BEGIN
	IF NOT CAN_ACCESS_PROC(p_PACKAGE_NAME, p_PROCEDURE_NAME) THEN
		-- can't access procedure? just return zero
		p_COUNT := 0;
	END IF;

	UT.GET_STORED_PROC_OVERLOAD_COUNT(p_PACKAGE_NAME, p_PROCEDURE_NAME, p_COUNT);

END GET_STORED_PROC_OVERLOAD_COUNT;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_ALL_STORED_PROCS
	(
	p_EXCLUDE_LIST IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	GET_ALL_STORED_PROCS(p_EXCLUDE_LIST, 1, p_STATUS, p_CURSOR);
END GET_ALL_STORED_PROCS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_ALL_STORED_PROCS
	(
	p_EXCLUDE_LIST IN VARCHAR2,
	p_IN_PACKAGE_ONLY IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

	v_EXCLUDE_PKGS STRING_TABLE;

BEGIN
	p_STATUS := GA.SUCCESS;

	UT.STRING_TABLE_FROM_STRING(p_EXCLUDE_LIST, ',', v_EXCLUDE_PKGS);
  
  IF p_IN_PACKAGE_ONLY = 1 THEN
    OPEN p_CURSOR FOR
    SELECT PROCEDURE_NAME,
           PACKAGE_NAME,
           CASE WHEN PROC_COUNT = 1 THEN 0 ELSE PROC_COUNT END MAX_OVERLOAD
    FROM (
      SELECT UP.PROCEDURE_NAME PROCEDURE_NAME,
             UO.OBJECT_NAME PACKAGE_NAME,
             COUNT(*) PROC_COUNT
      FROM USER_OBJECTS UO,
           USER_PROCEDURES UP
      WHERE UO.OBJECT_TYPE = 'PACKAGE'
        AND UO.OBJECT_ID = UP.OBJECT_ID
        AND UP.PROCEDURE_NAME IS NOT NULL
        AND NOT EXISTS (SELECT 1 FROM GRANT_EXECUTE_EXCLUSIONS X WHERE UO.OBJECT_TYPE = X.OBJECT_TYPE AND UO.OBJECT_NAME LIKE X.OBJECT_NAME)
        AND NOT EXISTS (SELECT 1 FROM TABLE(CAST(v_EXCLUDE_PKGS AS STRING_TABLE)) T WHERE T.STRING_VAL = UO.OBJECT_NAME)
      GROUP BY UO.OBJECT_NAME, UP.PROCEDURE_NAME
    )
    ORDER BY PACKAGE_NAME, PROCEDURE_NAME;
  ELSE
    OPEN p_CURSOR FOR
    SELECT A.OBJECT_NAME PROCEDURE_NAME,
           A.PACKAGE_NAME PACKAGE_NAME,
        NVL(MAX(OVERLOAD),0) MAX_OVERLOAD
      FROM USER_OBJECTS O, USER_ARGUMENTS A
      WHERE O.OBJECT_TYPE IN ('PROCEDURE','FUNCTION','PACKAGE')
              AND A.OBJECT_ID = O.OBJECT_ID
        AND (p_IN_PACKAGE_ONLY = 0 OR A.PACKAGE_NAME IS NOT NULL)
        AND NOT EXISTS (SELECT 1 FROM GRANT_EXECUTE_EXCLUSIONS X WHERE O.OBJECT_TYPE = X.OBJECT_TYPE AND O.OBJECT_NAME LIKE X.OBJECT_NAME)
        AND NOT EXISTS (SELECT 1 FROM TABLE(CAST(v_EXCLUDE_PKGS AS STRING_TABLE)) T WHERE T.STRING_VAL = A.PACKAGE_NAME)
      GROUP BY A.OBJECT_NAME, A.PACKAGE_NAME
      ORDER BY PACKAGE_NAME, PROCEDURE_NAME;
  END IF;

END GET_ALL_STORED_PROCS;
----------------------------------------------------------------------------------------------------
FUNCTION GET_ENTITY_DOMAIN_ID_FOR_NODE
	(
	p_ENTITY_DOMAIN_ALIAS IN VARCHAR
	) RETURN NUMBER IS

v_ENTITY_DOMAIN_ID NUMBER(9);
BEGIN

	SELECT ENTITY_DOMAIN_ID
	INTO v_ENTITY_DOMAIN_ID
	FROM ENTITY_DOMAIN
	WHERE ENTITY_DOMAIN_TABLE_ALIAS = UPPER(LTRIM(RTRIM(p_ENTITY_DOMAIN_ALIAS)));

	RETURN v_ENTITY_DOMAIN_ID;

END GET_ENTITY_DOMAIN_ID_FOR_NODE;
----------------------------------------------------------------------------------------------------
FUNCTION GET_ENTITY_NAME_LENGTH
	(
	p_ENTITY_DOMAIN_ALIAS IN VARCHAR
	) RETURN NUMBER IS

v_ENTITY_NAME_LENGTH NUMBER(3);
BEGIN

	SELECT C.DATA_LENGTH
	INTO v_ENTITY_NAME_LENGTH
	FROM ENTITY_DOMAIN D, NERO_TABLE_PROPERTY_INDEX N, COLS C
	WHERE D.ENTITY_DOMAIN_TABLE_ALIAS = p_ENTITY_DOMAIN_ALIAS
		AND N.TABLE_NAME = D.ENTITY_DOMAIN_TABLE
		AND C.TABLE_NAME = N.TABLE_NAME
		AND C.COLUMN_NAME = SUBSTR(N.PRIMARY_ID_COLUMN,1,LENGTH(N.PRIMARY_ID_COLUMN)-3)||'_NAME';

	RETURN v_ENTITY_NAME_LENGTH;

	EXCEPTION
		WHEN OTHERS THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN 32;

END GET_ENTITY_NAME_LENGTH;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_IO_TABLE_DEFINITION
	(
	p_TABLE_ALIAS IN VARCHAR,
	p_GET_PROCEDURE_NAME OUT VARCHAR,
	p_PUT_PROCEDURE_NAME OUT VARCHAR,
	p_REMOVE_PROCEDURE_NAME OUT VARCHAR,
    p_TREELIST_PROCEDURE_NAME OUT VARCHAR,
    p_USE_DATES OUT NUMBER,
	p_ENTITY_DOMAIN_ID OUT NUMBER,
	p_ENTITY_NAME_LENGTH OUT NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

v_TABLE_ID NUMBER(9);
v_MODULE_ID NUMBER(9);
--DEPRECATED - ONLY INCLUDED FOR BACKWARD COMPATIBILITY
-- WITH VB ENTITY MANAGER.  JAVA USES GET_IO_TABLE_HIERARCHY.

v_PRIV NUMBER(1);

BEGIN

	ID_FOR_SYSTEM_OBJECT(0,'Entity Manager',0,'Module','Default',TRUE,v_MODULE_ID);
	ID_FOR_SYSTEM_OBJECT(v_MODULE_ID, p_TABLE_ALIAS, 0, 'IO Table', 'Default', FALSE, v_TABLE_ID);

	IF v_TABLE_ID <= 0 THEN
		NULL_CURSOR(p_CURSOR);
	ELSE

		v_PRIV := GET_OBJECT_PRIVILEGE(v_TABLE_ID);

		SELECT NVL(MAX(CASE WHEN ATTRIBUTE_ID = g_GET_PROC_ATTRIBUTE_ID THEN ATTRIBUTE_VAL ELSE NULL END), 'EM_GET.' || p_TABLE_ALIAS),
			NVL(MAX(CASE WHEN ATTRIBUTE_ID = g_PUT_PROC_ATTRIBUTE_ID THEN ATTRIBUTE_VAL ELSE NULL END), 'IO.PUT_' || p_TABLE_ALIAS),
			NVL(MAX(CASE WHEN ATTRIBUTE_ID = g_DELETE_PROC_ATTRIBUTE_ID THEN ATTRIBUTE_VAL ELSE NULL END), 'DE.DEL_' || p_TABLE_ALIAS),
			NVL(MAX(CASE WHEN ATTRIBUTE_ID = g_TREELIST_PROC_ATTRIBUTE_ID THEN ATTRIBUTE_VAL ELSE NULL END), 'EN.' || SUBSTR(p_TABLE_ALIAS || '_LIST_FILTER',1,30)),
			NVL(MAX(CASE WHEN ATTRIBUTE_ID = g_USE_DATES_ATTRIBUTE_ID THEN ATTRIBUTE_VAL ELSE NULL END), 0)
		INTO p_GET_PROCEDURE_NAME,
			p_PUT_PROCEDURE_NAME,
			p_REMOVE_PROCEDURE_NAME,
			p_TREELIST_PROCEDURE_NAME,
			p_USE_DATES
		FROM SYSTEM_OBJECT_ATTRIBUTE
		WHERE OBJECT_ID = v_TABLE_ID
			AND v_PRIV >= g_PRIV_VIEW;

		p_ENTITY_DOMAIN_ID := GET_ENTITY_DOMAIN_ID_FOR_NODE(p_TABLE_ALIAS);
		p_ENTITY_NAME_LENGTH := GET_ENTITY_NAME_LENGTH(p_TABLE_ALIAS);

		SYSTEM_OBJECTS_AND_ATTRIBUTES(v_TABLE_ID,NULL,-1,NULL,1,p_STATUS,p_CURSOR);

	END IF;

END GET_IO_TABLE_DEFINITION;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_ENTITY_DOMAIN_ATTRIBUTES
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_DISPLAY_NAME OUT VARCHAR2,
	p_TABLE_ABBREVIATION OUT VARCHAR2,
	p_INCLUDE_ENTITY_ATTRIBUTE OUT NUMBER,
	p_INCLUDE_CONTACT_ADDRESS OUT NUMBER,
	p_INCLUDE_EXTERNAL_IDENTIFIER OUT NUMBER,
	p_INCLUDE_GROUPS OUT NUMBER,
	p_INCLUDE_NOTES OUT NUMBER,
	p_STATUS OUT NUMBER
	) AS
BEGIN
	p_STATUS := GA.SUCCESS;

	SELECT NVL(A.DISPLAY_NAME,A.ENTITY_DOMAIN_NAME),
		SUBSTR(B.PRIMARY_ID_COLUMN,1,LENGTH(TRIM(B.PRIMARY_ID_COLUMN))-3),
		A.INCLUDE_ENTITY_ATTRIBUTE,
		A.INCLUDE_CONTACT_ADDRESS,
		A.INCLUDE_EXTERNAL_IDENTIFIER,
		-- can never have groups of groups - instead use group hierarchy (PARENT_GROUP_ID)
		CASE WHEN A.ENTITY_DOMAIN_ID = EC.ED_ENTITY_GROUP THEN 0 ELSE A.INCLUDE_GROUPS END,
		A.INCLUDE_NOTES
	INTO p_DISPLAY_NAME,
		p_TABLE_ABBREVIATION,
		p_INCLUDE_ENTITY_ATTRIBUTE,
		p_INCLUDE_CONTACT_ADDRESS,
		p_INCLUDE_EXTERNAL_IDENTIFIER,
		p_INCLUDE_GROUPS,
		p_INCLUDE_NOTES
	FROM ENTITY_DOMAIN A,
		NERO_TABLE_PROPERTY_INDEX B
	WHERE A.ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID
		AND TRIM(B.TABLE_NAME) = A.ENTITY_DOMAIN_TABLE
		AND ROWNUM=1;

END GET_ENTITY_DOMAIN_ATTRIBUTES;
----------------------------------------------------------------------------------------------------
PROCEDURE GENERATE_IO_TABLE_FIELDS
	(
	p_PARENT_SYSTEM_OBJECT_ID IN NUMBER,
	p_TABLE_ALIAS IN VARCHAR,
	p_TABLE_NAME IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_INDEX BINARY_INTEGER;
v_IO_FIELD_ID NUMBER(9);
v_IO_TABLE_ID NUMBER(9);
v_FIELD_DISPLAY_NAME SYSTEM_OBJECT.OBJECT_DISPLAY_NAME%TYPE;
v_FIELD_ATTRIBUTES VARCHAR2(4000);
v_FIELD_DATA_TYPE VARCHAR2(16);
v_MAIN_FIELD_ALIAS VARCHAR2(32);
v_ENTITY_NAME VARCHAR(32);
v_IS_TRANSACTION BOOLEAN := p_TABLE_NAME = 'INTERCHANGE_TRANSACTION';
v_IS_ADDRESS BOOLEAN := p_TABLE_NAME = 'ADDRESS';

CURSOR c_IO_COLS IS
	SELECT COLUMN_NAME, DATA_TYPE, DATA_LENGTH, DATA_PRECISION
	FROM COLS
	WHERE TABLE_NAME = p_TABLE_NAME
	AND NOT COLUMN_NAME = v_MAIN_FIELD_ALIAS || 'ID'
	AND NOT COLUMN_NAME = v_MAIN_FIELD_ALIAS || 'NAME'
	AND NOT COLUMN_NAME = v_MAIN_FIELD_ALIAS || 'ALIAS'
	AND NOT COLUMN_NAME = v_MAIN_FIELD_ALIAS || 'DESC'
	AND NOT COLUMN_NAME = 'ENTRY_DATE';

BEGIN

	--SEE IF IO TABLE EXISTS FIRST.  IF NOT, ADD IT.
	ID_FOR_SYSTEM_OBJECT(p_PARENT_SYSTEM_OBJECT_ID,p_TABLE_ALIAS,0,'IO Table','Default',TRUE,v_IO_TABLE_ID);

    --INTERCHANGE_TRANSACTION domains get special attributes
    IF v_IS_TRANSACTION THEN
    	PUT_SYSTEM_OBJECT_ATTRIBUTE(v_IO_TABLE_ID,201,'EM.PUT_TRANSACTION',p_STATUS);
    	PUT_SYSTEM_OBJECT_ATTRIBUTE(v_IO_TABLE_ID,202,'EM.GET_TRANSACTION',p_STATUS);
    	PUT_SYSTEM_OBJECT_ATTRIBUTE(v_IO_TABLE_ID,204,'EM.LIST_'||p_TABLE_ALIAS||'S',p_STATUS);
    	PUT_SYSTEM_OBJECT_ATTRIBUTE(v_IO_TABLE_ID,205,'Interchange Transaction',p_STATUS);
    	PUT_SYSTEM_OBJECT_ATTRIBUTE(v_IO_TABLE_ID,206,'1',p_STATUS);
	ELSIF v_IS_ADDRESS THEN
    	PUT_SYSTEM_OBJECT_ATTRIBUTE(v_IO_TABLE_ID,201,'EM.PUT_ADDRESS',p_STATUS);
    	PUT_SYSTEM_OBJECT_ATTRIBUTE(v_IO_TABLE_ID,202,'EM.GET_ADDRESS',p_STATUS);
    END IF;

	--DETERMINE THE FIELD ALIAS -- IT'S WHAT'S BEFORE _ID OF THE FIRST ROW.
	SELECT NAME
	INTO v_MAIN_FIELD_ALIAS
	FROM (SELECT SUBSTR(COLUMN_NAME,1,LENGTH(COLUMN_NAME)-3) || '_' as NAME
		FROM COLS
		WHERE TABLE_NAME = p_TABLE_NAME
			AND NULLABLE = 'N'
		ORDER BY COLUMN_ID)
	WHERE ROWNUM = 1;

	--DELETE EXISTING FIELDS.
	IF v_IO_TABLE_ID > 0 THEN
		DELETE FROM SYSTEM_OBJECT WHERE PARENT_OBJECT_ID = v_IO_TABLE_ID;

		--LOOP THROUGH EACH COLUMN AND ADD IT.
		v_INDEX := 1;
        -- Add special STATUS attribute for transactions as the first attribute
        IF v_IS_TRANSACTION THEN
			PUT_SYSTEM_OBJECT(
				v_IO_FIELD_ID,		--OBJECT_ID OUT
				0,					--OBJECT_ID IN
				v_IO_TABLE_ID,		--PARENT_OBJECT_ID
				'TRANSACTION_STATUS', 	--OBJECT_NAME
				0,					--OBJECT_INDEX
				'IO Field',		--OBJECT_CATEGORY
				'Default',		--OBJECT_TYPE
				NULL,				--OBJECT_ALIAS
				NULL,				--OBJECT_DESC
				'Status',	  	 		--OBJECT_DISPLAY_NAME
				v_INDEX,	--OBJECT_ORDER
				0,					--OBJECT_IS_HIDDEN
				'102~String^105~16'					--ATTRIBUTES
		 		);
			v_INDEX := v_INDEX + 1;
        END IF;

		FOR v_IO_COLS IN c_IO_COLS LOOP

            -- For ADDRESS - replace GEOGRAPHY_ID with several fields
            IF v_IO_COLS.COLUMN_NAME = 'GEOGRAPHY_ID' THEN
    			PUT_SYSTEM_OBJECT(
    				v_IO_FIELD_ID,		--OBJECT_ID OUT
    				0,					--OBJECT_ID IN
    				v_IO_TABLE_ID,		--PARENT_OBJECT_ID
    				'COUNTRY_CODE', 	--OBJECT_NAME
    				0,					--OBJECT_INDEX
    				'IO Field',		--OBJECT_CATEGORY
    				'Default',		--OBJECT_TYPE
    				NULL,				--OBJECT_ALIAS
    				NULL,				--OBJECT_DESC
    				'Country',	  	 		--OBJECT_DISPLAY_NAME
    				v_INDEX,	--OBJECT_ORDER
    				0,					--OBJECT_IS_HIDDEN
    				'102~String^105~16'					--ATTRIBUTES
    		 		);
    			v_INDEX := v_INDEX + 1;
    			PUT_SYSTEM_OBJECT(
    				v_IO_FIELD_ID,		--OBJECT_ID OUT
    				0,					--OBJECT_ID IN
    				v_IO_TABLE_ID,		--PARENT_OBJECT_ID
    				'STATE_CODE', 	--OBJECT_NAME
    				0,					--OBJECT_INDEX
    				'IO Field',		--OBJECT_CATEGORY
    				'Default',		--OBJECT_TYPE
    				NULL,				--OBJECT_ALIAS
    				NULL,				--OBJECT_DESC
    				'State/Province',	  	 		--OBJECT_DISPLAY_NAME
    				v_INDEX,	--OBJECT_ORDER
    				0,					--OBJECT_IS_HIDDEN
    				'102~String^105~16'					--ATTRIBUTES
    		 		);
    			v_INDEX := v_INDEX + 1;
    			PUT_SYSTEM_OBJECT(
    				v_IO_FIELD_ID,		--OBJECT_ID OUT
    				0,					--OBJECT_ID IN
    				v_IO_TABLE_ID,		--PARENT_OBJECT_ID
    				'CITY', 	--OBJECT_NAME
    				0,					--OBJECT_INDEX
    				'IO Field',		--OBJECT_CATEGORY
    				'Default',		--OBJECT_TYPE
    				NULL,				--OBJECT_ALIAS
    				NULL,				--OBJECT_DESC
    				'City',	  	 		--OBJECT_DISPLAY_NAME
    				v_INDEX,	--OBJECT_ORDER
    				0,					--OBJECT_IS_HIDDEN
    				'102~String^105~16'					--ATTRIBUTES
    		 		);
    			v_INDEX := v_INDEX + 1;
    			PUT_SYSTEM_OBJECT(
    				v_IO_FIELD_ID,		--OBJECT_ID OUT
    				0,					--OBJECT_ID IN
    				v_IO_TABLE_ID,		--PARENT_OBJECT_ID
    				'POSTAL_CODE', 	--OBJECT_NAME
    				0,					--OBJECT_INDEX
    				'IO Field',		--OBJECT_CATEGORY
    				'Default',		--OBJECT_TYPE
    				NULL,				--OBJECT_ALIAS
    				NULL,				--OBJECT_DESC
    				'Postal Code',	  	 		--OBJECT_DISPLAY_NAME
    				v_INDEX,	--OBJECT_ORDER
    				0,					--OBJECT_IS_HIDDEN
    				'102~String^105~16'					--ATTRIBUTES
    		 		);
    			v_INDEX := v_INDEX + 1;
            ELSE

    			--TAKE OFF ALIAS FROM FRONT OF DISPLAY NAME.
    			IF SUBSTR(v_IO_COLS.COLUMN_NAME,1,LENGTH(v_MAIN_FIELD_ALIAS)) = v_MAIN_FIELD_ALIAS  THEN
    				v_FIELD_DISPLAY_NAME := INITCAP(REPLACE(SUBSTR(v_IO_COLS.COLUMN_NAME,LENGTH(v_MAIN_FIELD_ALIAS)+1),'_',' '));
    			ELSE
    				v_FIELD_DISPLAY_NAME := INITCAP(REPLACE(v_IO_COLS.COLUMN_NAME,'_',' '));
    			END IF;

    			--TAKE _ID OFF THE BACK OF THE DISPLAY NAME.
    			IF SUBSTR(v_FIELD_DISPLAY_NAME,-3) = ' Id' THEN
    				v_FIELD_DISPLAY_NAME := SUBSTR(v_FIELD_DISPLAY_NAME,1,LENGTH(v_FIELD_DISPLAY_NAME)-3);
    				--MAKE SOME CORRECTIONS TO ABBREVIATIONS
    				IF v_FIELD_DISPLAY_NAME = 'Sc' THEN
    					v_FIELD_DISPLAY_NAME := 'Schedule Coordinator';
    				ELSIF v_FIELD_DISPLAY_NAME = 'Edc' THEN
    					v_FIELD_DISPLAY_NAME := 'Energy Distribution Company';
    				ELSIF v_FIELD_DISPLAY_NAME = 'Esp' THEN
    					v_FIELD_DISPLAY_NAME := 'Energy Service Provider';
    				ELSIF v_FIELD_DISPLAY_NAME = 'Pse' THEN
    					v_FIELD_DISPLAY_NAME := 'Purchasing-Selling Entity';
    				ELSIF v_FIELD_DISPLAY_NAME = 'Tp' THEN
    					v_FIELD_DISPLAY_NAME := 'Transmission Provider';
    				ELSIF v_FIELD_DISPLAY_NAME = 'Ca' THEN
    					v_FIELD_DISPLAY_NAME := 'Control Area';
    				ELSIF v_FIELD_DISPLAY_NAME IN ('Por','Pod','Zor','Zod') THEN
    					v_FIELD_DISPLAY_NAME := UPPER(v_FIELD_DISPLAY_NAME);
    				END IF;
    			END IF;

    			--DETERMINE DATA TYPE OF FIELD. -- String, Number, Boolean, or Date.
    			IF v_IO_COLS.DATA_TYPE = 'NUMBER' AND v_IO_COLS.DATA_PRECISION = 1 THEN
    				v_FIELD_DATA_TYPE := 'Boolean';
    			ELSIF v_IO_COLS.DATA_TYPE = 'NUMBER' THEN
    				v_FIELD_DATA_TYPE := 'Number';
    			ELSIF v_IO_COLS.DATA_TYPE = 'DATE' THEN
    				v_FIELD_DATA_TYPE := 'Date';
    			ELSE
    				v_FIELD_DATA_TYPE := 'String';
    			END IF;
    			v_FIELD_ATTRIBUTES := '102~' || v_FIELD_DATA_TYPE;

    			--IF THIS IS A STRING, DETERMINE THE MAX LENGTH.
    			IF v_FIELD_DATA_TYPE = 'String' THEN
    				v_FIELD_ATTRIBUTES := v_FIELD_ATTRIBUTES || '^105~' || TO_CHAR(v_IO_COLS.DATA_LENGTH);
    			END IF;

    			--IF THIS IS AN ENTITY COMBO, DETERMINE ITS ENTITY NAME.
    			IF SUBSTR(v_IO_COLS.COLUMN_NAME,-3) = '_ID' AND NOT v_IO_COLS.COLUMN_NAME IN ('PROVIDER_ID', 'MODEL_ID') THEN
    				IF SUBSTR(v_IO_COLS.COLUMN_NAME,1,LENGTH(v_MAIN_FIELD_ALIAS)) = v_MAIN_FIELD_ALIAS THEN
    					v_ENTITY_NAME := SUBSTR(v_IO_COLS.COLUMN_NAME,LENGTH(v_MAIN_FIELD_ALIAS)+1);
    					v_ENTITY_NAME := SUBSTR(v_ENTITY_NAME,1,LENGTH(v_ENTITY_NAME)-3);
    				ELSE
    					v_ENTITY_NAME := SUBSTR(v_IO_COLS.COLUMN_NAME,1,LENGTH(v_IO_COLS.COLUMN_NAME)-3);
    				END IF;

    				--MAKE SOME CORRECTIONS FOR STRANGE NAMES.
    				IF SUBSTR(v_ENTITY_NAME,1,7) = 'PARENT_' THEN
                    	v_ENTITY_NAME := SUBSTR(v_ENTITY_NAME,8);
                    END IF;
    				IF v_ENTITY_NAME IN ('POR', 'POD', 'SOURCE', 'SINK') THEN
    					v_ENTITY_NAME := 'SERVICE_POINT';
    				ELSIF v_ENTITY_NAME IN ('ZOR', 'ZOD') THEN
    					v_ENTITY_NAME := 'SERVICE_ZONE';
    				ELSIF v_ENTITY_NAME IN ('PURCHASER', 'SELLER') THEN
    					v_ENTITY_NAME := 'PSE';
    				ELSIF v_ENTITY_NAME = 'COMMODITY' THEN
    					v_ENTITY_NAME := 'IT_COMMODITY';
    				ELSIF v_ENTITY_NAME = 'CONTRACT' THEN
    					v_ENTITY_NAME := 'INTERCHANGE_CONTRACT';
    				ELSIF v_ENTITY_NAME IN ('PIPELINE_POINT', 'PIPELINE_ZONE', 'RECEIPT_POINT', 'DELIVERY_POINT', 'INJECTION_POINT', 'WITHDRAWAL_POINT', 'RECEIPT_ZONE', 'DELIVERY_ZONE') THEN
    					v_ENTITY_NAME := NULL;
    				ELSIF SUBSTR(v_ENTITY_NAME, -9) = '_PIPELINE' THEN
    					v_ENTITY_NAME := 'PIPELINE';
    				ELSIF SUBSTR(v_ENTITY_NAME, -18) = '_RESOURCE_TEMPLATE' THEN
    					v_ENTITY_NAME := 'RESOURCE_TEMPLATE';
    				ELSIF SUBSTR(v_ENTITY_NAME, -14) = '_RESOURCE_RAMP' THEN
    					v_ENTITY_NAME := 'RESOURCE_RAMP';
    				ELSIF SUBSTR(v_ENTITY_NAME, -12) = '_TRANSACTION' THEN
    					v_ENTITY_NAME := 'TRANSACTION';
    				END IF;

    				IF v_ENTITY_NAME IS NOT NULL THEN
    					v_FIELD_ATTRIBUTES := v_FIELD_ATTRIBUTES || '^104~' || v_ENTITY_NAME;
    				END IF;
    			END IF;

    			--ENTRY_DATE is readonly.
    			IF v_IO_COLS.COLUMN_NAME = 'ENTRY_DATE' THEN
    				v_FIELD_ATTRIBUTES := v_FIELD_ATTRIBUTES || '^101~1';
    			END IF;

    			--Default _STATUS is Active and Inactive.
    			IF SUBSTR(v_IO_COLS.COLUMN_NAME,-7) = '_STATUS' THEN
    				v_FIELD_ATTRIBUTES := v_FIELD_ATTRIBUTES || '^103~Active|Inactive|Pending';
    			END IF;

    			PUT_SYSTEM_OBJECT(
    				v_IO_FIELD_ID,		--OBJECT_ID OUT
    				0,					--OBJECT_ID IN
    				v_IO_TABLE_ID,		--PARENT_OBJECT_ID
    				v_IO_COLS.COLUMN_NAME, 	--OBJECT_NAME
    				0,					--OBJECT_INDEX
    				'IO Field',		--OBJECT_CATEGORY
    				'Default',		--OBJECT_TYPE
    				NULL,				--OBJECT_ALIAS
    				NULL,				--OBJECT_DESC
    				v_FIELD_DISPLAY_NAME,	  	 		--OBJECT_DISPLAY_NAME
    				v_INDEX,	--OBJECT_ORDER
    				0,					--OBJECT_IS_HIDDEN
    				v_FIELD_ATTRIBUTES					--ATTRIBUTES
    		 		);
    			v_INDEX := v_INDEX + 1;
			END IF;
		END LOOP;
	END IF;

END GENERATE_IO_TABLE_FIELDS;
---------------------------------------------------------------------------------------------------
PROCEDURE MODULE_NAMES
	(
	p_CURSOR OUT GA.REFCURSOR,
	p_STATUS OUT NUMBER
	) AS

v_WORK_ID	NUMBER := ENUMERATE_HIERARCHY(0, p_INCLUDED_CATEGORIES => STRING_COLLECTION('Module','System View'));

BEGIN

	OPEN p_CURSOR FOR
    	SELECT DISTINCT W.WORK_DATA as OBJECT_NAME,
				W.WORK_XID as OBJECT_ID
		FROM RTO_WORK W
		WHERE W.WORK_ID = v_WORK_ID
			AND W.WORK_DATA2 = 'System View'
		ORDER BY 1;

	UT.PURGE_RTO_WORK(v_WORK_ID);

END MODULE_NAMES;
----------------------------------------------------------------------------------------------------
PROCEDURE REORDER_IO_FIELDS
	(
    p_IO_TABLE_ID IN NUMBER,
    p_NEW_ORDER IN VARCHAR2
    ) AS
v_TOKEN_TABLE GA.STRING_TABLE;

v_ORDER_TABLE	t_MAP_OF_NUMBERS;
v_HIDDEN_TABLE	t_MAP_OF_NUMBERS;
v_ORDER BINARY_INTEGER;
v_INDEX BINARY_INTEGER;
v_CUR_ORDER BINARY_INTEGER;
v_IS_HIDDEN NUMBER(1);
CURSOR c_IO_FIELDS IS
	SELECT OBJECT_ID, OBJECT_NAME
    FROM SYSTEM_OBJECT
    WHERE PARENT_OBJECT_ID = p_IO_TABLE_ID
    	AND OBJECT_CATEGORY = 'IO Field'
        AND OBJECT_TYPE = 'Default'
	ORDER BY OBJECT_ORDER;
BEGIN

	CHECK_OBJECT_PRIVILEGE(p_IO_TABLE_ID, g_PRIV_EDIT);

	UT.TOKENS_FROM_STRING(p_NEW_ORDER,',',v_TOKEN_TABLE);
    v_ORDER := 0;
    v_INDEX := v_TOKEN_TABLE.FIRST;
    -- collect table of correct column order
    WHILE v_TOKEN_TABLE.EXISTS(v_INDEX) LOOP
    	IF SUBSTR(v_TOKEN_TABLE(v_INDEX),1,1) IN ('-','+') THEN
        	IF SUBSTR(v_TOKEN_TABLE(v_INDEX),1,1) = '-' THEN
				v_HIDDEN_TABLE(SUBSTR(v_TOKEN_TABLE(v_INDEX),2)) := 1; -- is hidden
            ELSE -- '+'
				v_HIDDEN_TABLE(SUBSTR(v_TOKEN_TABLE(v_INDEX),2)) := 0; -- is not hidden
			END IF;
			v_ORDER_TABLE(SUBSTR(v_TOKEN_TABLE(v_INDEX),2)) := v_ORDER;
        ELSE
			v_HIDDEN_TABLE(v_TOKEN_TABLE(v_INDEX)) := NULL;
			v_ORDER_TABLE(v_TOKEN_TABLE(v_INDEX)) := v_ORDER;
        END IF;
        v_ORDER := v_ORDER+1;
    	v_INDEX := v_TOKEN_TABLE.NEXT(v_INDEX);
    END LOOP;
    -- loop through all child fields assigning them proper order and updating the is_hidden column, too
    FOR v_IO_FIELD IN c_IO_FIELDS LOOP
    	IF v_ORDER_TABLE.EXISTS(v_IO_FIELD.OBJECT_NAME) THEN
        	v_CUR_ORDER := v_ORDER_TABLE(v_IO_FIELD.OBJECT_NAME);
            v_IS_HIDDEN := v_HIDDEN_TABLE(v_IO_FIELD.OBJECT_NAME);
        ELSE
        	-- any unspecified columns in p_NEW_ORDER are kept in existing order, but appended to those
            -- that are specified
        	v_CUR_ORDER := v_ORDER;
            v_ORDER := v_ORDER+1;
            v_IS_HIDDEN := NULL;
        END IF;
        UPDATE SYSTEM_OBJECT
        SET OBJECT_ORDER = v_CUR_ORDER,
        	OBJECT_IS_HIDDEN = NVL(v_IS_HIDDEN,OBJECT_IS_HIDDEN)
		WHERE OBJECT_ID = v_IO_FIELD.OBJECT_ID;
    END LOOP;

END REORDER_IO_FIELDS;
----------------------------------------------------------------------------------------------------
PROCEDURE RENAME_SYSTEM_OBJECT
	(
    p_OBJECT_ID IN NUMBER,
    p_NEW_NAME IN VARCHAR2
    ) AS
BEGIN
	CHECK_OBJECT_PRIVILEGE(p_OBJECT_ID, g_PRIV_EDIT);

	UPDATE SYSTEM_OBJECT
    SET OBJECT_DISPLAY_NAME = p_NEW_NAME
    WHERE OBJECT_ID = p_OBJECT_ID;
END RENAME_SYSTEM_OBJECT;
----------------------------------------------------------------------------------------------------
PROCEDURE HIDE_SYSTEM_OBJECT
	(
    p_OBJECT_ID IN NUMBER,
    p_OBJECT_IS_HIDDEN IN NUMBER
    ) AS
BEGIN
	CHECK_OBJECT_PRIVILEGE(p_OBJECT_ID, g_PRIV_EDIT);

    UPDATE SYSTEM_OBJECT
    SET OBJECT_IS_HIDDEN = p_OBJECT_IS_HIDDEN
    WHERE OBJECT_ID = p_OBJECT_ID;
END HIDE_SYSTEM_OBJECT;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SYSTEM_OBJECT_HIERARCHY
	(
	p_PARENT_OBJECT_ID IN NUMBER,
    p_INCLUDE_HIDDEN IN BOOLEAN,
	p_MAX_LEVEL IN NUMBER,
	p_CATEGORIES IN STRING_COLLECTION,
	p_CURSOR OUT GA.REFCURSOR
	) AS

v_WORK_ID	NUMBER;
-- Answer a Hierarchical recordset with information at each level.
BEGIN

	v_WORK_ID := ENUMERATE_HIERARCHY(p_PARENT_OBJECT_ID, p_MAX_LEVEL, TRUE,
									p_INCLUDE_HIDDEN, p_INCLUDE_HIDDEN,	p_CATEGORIES);

	OPEN p_CURSOR FOR
		SELECT SO.OBJECT_NAME,
			NVL(SO.OBJECT_DISPLAY_NAME, INITCAP(REPLACE(SO.OBJECT_NAME, '_', ' '))) "OBJECT_DISPLAY_NAME",
			NVL(SO.OBJECT_IS_HIDDEN, 0) "OBJECT_IS_HIDDEN",
			SO.OBJECT_ORDER "OBJECT_ORDER",
			SO.OBJECT_TYPE,
			SO.OBJECT_CATEGORY,
			SO.OBJECT_ID,
			SO.PARENT_OBJECT_ID,
			SOA.ATTRIBUTE_ID,
			SA.ATTRIBUTE_NAME,
			SA.ATTRIBUTE_DESC,
			SOA.ATTRIBUTE_VAL
		FROM (SELECT SO.*, ROWNUM as ROW_NBR
				FROM RTO_WORK W,
					SYSTEM_OBJECT SO
				START WITH SO.OBJECT_ID = p_PARENT_OBJECT_ID
					AND W.WORK_ID = v_WORK_ID
					AND W.WORK_XID = SO.OBJECT_ID
				CONNECT BY SO.PARENT_OBJECT_ID = PRIOR SO.OBJECT_ID
					AND W.WORK_ID = v_WORK_ID
					AND W.WORK_XID = SO.OBJECT_ID
				ORDER SIBLINGS BY SO.OBJECT_ORDER, NVL(SO.OBJECT_DISPLAY_NAME,SO.OBJECT_NAME), SO.OBJECT_ID) SO,
			SYSTEM_OBJECT_ATTRIBUTE SOA,
			SYSTEM_ATTRIBUTE SA
		WHERE SOA.OBJECT_ID(+) = SO.OBJECT_ID
			AND SA.ATTRIBUTE_ID(+) = SOA.ATTRIBUTE_ID
		ORDER BY SO.ROW_NBR;

	UT.PURGE_RTO_WORK(v_WORK_ID);

END GET_SYSTEM_OBJECT_HIERARCHY;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SO_HIERARCHY
	(
	p_PARENT_OBJECT_ID IN NUMBER,
    p_INCLUDE_HIDDEN IN NUMBER,
	p_MAX_LEVEL IN NUMBER,
	p_CATEGORIES IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	) AS

	v_STRING_COLL STRING_COLLECTION := STRING_COLLECTION();

	BEGIN

	UT.STRING_COLLECTION_FROM_STRING(p_CATEGORIES, ',', v_STRING_COLL);

	GET_SYSTEM_OBJECT_HIERARCHY(p_PARENT_OBJECT_ID,
								p_INCLUDE_HIDDEN = 1,
								p_MAX_LEVEL,
								V_STRING_COLL,
								p_CURSOR);

END GET_SO_HIERARCHY;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_GRID_COL_HIERARCHY
	(
	p_MODULE_NAME IN VARCHAR2,
	p_PARENT_OBJECT_ID IN NUMBER,
	p_GRID_NAME IN VARCHAR,
	p_GRID_INDEX IN NUMBER,
	p_GRID_TYPE IN VARCHAR,
	p_GRID_ID OUT NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- ANSWER A RECORDSET CONTAINING A HIERARCHY STARTING WITH THE OBJECT.
v_GRID_ID NUMBER(9);
v_PARENT_OBJECT_ID NUMBER(9);
BEGIN

	p_STATUS := GA.SUCCESS;

	--Sort out whether we know the module name or the parent object id.
	IF p_PARENT_OBJECT_ID <= 0 THEN
		ID_FOR_SYSTEM_OBJECT(0, p_MODULE_NAME, 0, 'Module', 'Default', TRUE, v_PARENT_OBJECT_ID);
	ELSE
		v_PARENT_OBJECT_ID := p_PARENT_OBJECT_ID;
	END IF;

	ID_FOR_SYSTEM_OBJECT(v_PARENT_OBJECT_ID, p_GRID_NAME, p_GRID_INDEX, 'Grid', p_GRID_TYPE, FALSE, v_GRID_ID);

	IF v_GRID_ID <= 0 THEN
		p_GRID_ID := 0;
		NULL_CURSOR(p_CURSOR);
	ELSE
		p_GRID_ID := v_GRID_ID;
		GET_SYSTEM_OBJECT_HIERARCHY(v_GRID_ID, TRUE, g_UNLIMITED_DEPTH, NULL, p_CURSOR);
	END IF;

END GET_GRID_COL_HIERARCHY;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_IO_TABLE_HIERARCHY
	(
	p_TABLE_ALIAS IN VARCHAR,
	p_PARENT_OBJECT_ID IN NUMBER,
	p_GET_PROCEDURE_NAME OUT VARCHAR,
	p_PUT_PROCEDURE_NAME OUT VARCHAR,
	p_REMOVE_PROCEDURE_NAME OUT VARCHAR,
    p_TREELIST_PROCEDURE_NAME OUT VARCHAR,
    p_USE_DATES OUT NUMBER,
	p_ENTITY_DOMAIN_ID OUT NUMBER,
	p_ENTITY_NAME_LENGTH OUT NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

v_TABLE_ID NUMBER(9);
v_MODULE_ID NUMBER(9);

v_PRIV NUMBER(1);

BEGIN

	ID_FOR_SYSTEM_OBJECT(p_PARENT_OBJECT_ID, p_TABLE_ALIAS, 0, 'IO Table', 'Default', FALSE, v_TABLE_ID);

	IF v_TABLE_ID <= 0 THEN
		NULL_CURSOR(p_CURSOR);
	ELSE

        v_PRIV := GET_OBJECT_PRIVILEGE(v_TABLE_ID);

		SELECT MAX(CASE WHEN ATTRIBUTE_ID = g_GET_PROC_ATTRIBUTE_ID THEN ATTRIBUTE_VAL ELSE NULL END),
			MAX(CASE WHEN ATTRIBUTE_ID = g_PUT_PROC_ATTRIBUTE_ID THEN ATTRIBUTE_VAL ELSE NULL END),
			MAX(CASE WHEN ATTRIBUTE_ID = g_DELETE_PROC_ATTRIBUTE_ID THEN ATTRIBUTE_VAL ELSE NULL END),
			MAX(CASE WHEN ATTRIBUTE_ID = g_TREELIST_PROC_ATTRIBUTE_ID THEN ATTRIBUTE_VAL ELSE NULL END),
			MAX(CASE WHEN ATTRIBUTE_ID = g_USE_DATES_ATTRIBUTE_ID THEN ATTRIBUTE_VAL ELSE NULL END)
		INTO p_GET_PROCEDURE_NAME,
			p_PUT_PROCEDURE_NAME,
			p_REMOVE_PROCEDURE_NAME,
			p_TREELIST_PROCEDURE_NAME,
			p_USE_DATES
		FROM SYSTEM_OBJECT_ATTRIBUTE
		WHERE OBJECT_ID = v_TABLE_ID
			AND v_PRIV >= g_PRIV_VIEW;

		p_ENTITY_DOMAIN_ID := GET_ENTITY_DOMAIN_ID_FOR_NODE(p_TABLE_ALIAS);
		p_ENTITY_NAME_LENGTH := GET_ENTITY_NAME_LENGTH(p_TABLE_ALIAS);

		GET_SYSTEM_OBJECT_HIERARCHY(v_TABLE_ID, TRUE, g_UNLIMITED_DEPTH, NULL, p_CURSOR);

	END IF;

END GET_IO_TABLE_HIERARCHY;
----------------------------------------------------------------------------------------------------
PROCEDURE UPSERT_SYSTEM_OBJECT
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_OBJECT_NAME IN VARCHAR,
	p_OBJECT_CATEGORY IN VARCHAR,
	p_ATTRIBUTES IN VARCHAR,
	p_OBJECT_ID OUT NUMBER
	) AS
BEGIN

	ID_FOR_SYSTEM_OBJECT(p_PARENT_OBJECT_ID, p_OBJECT_NAME, 0, p_OBJECT_CATEGORY, 'Default', FALSE, p_OBJECT_ID);
	PUT_SYSTEM_OBJECT(p_OBJECT_ID, p_OBJECT_ID, p_PARENT_OBJECT_ID, p_OBJECT_NAME, 0, p_OBJECT_CATEGORY, 'Default', NULL, NULL, NULL, 0, 0, p_ATTRIBUTES);

END UPSERT_SYSTEM_OBJECT;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SYSTEM_VIEW_HIERARCHY
	(
	p_SYSTEM_VIEW_NAME IN VARCHAR2,
	p_MAX_OBJECT_HIERARCHY IN NUMBER,
	p_PARENT_OBJECT_NAME OUT VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

v_OBJECT_ID NUMBER(9);
v_CATEGORIES STRING_COLLECTION := STRING_COLLECTION();

BEGIN

	ID_FOR_SYSTEM_VIEW(p_SYSTEM_VIEW_NAME, v_OBJECT_ID, p_PARENT_OBJECT_NAME);

	-- We need to get both Reports and Actions which are
	-- children of the System View
	v_CATEGORIES.EXTEND();
	v_CATEGORIES.EXTEND();
	v_CATEGORIES.EXTEND();

	v_CATEGORIES(1) := 'System View';
	v_CATEGORIES(2) := 'Report';
	v_CATEGORIES(3) := 'Action';

	IF v_OBJECT_ID < 0 THEN
		NULL_CURSOR(p_CURSOR);
	ELSE
		CHECK_OBJECT_PRIVILEGE(v_OBJECT_ID, g_PRIV_VIEW);
        GET_SYSTEM_OBJECT_HIERARCHY(v_OBJECT_ID, FALSE, p_MAX_OBJECT_HIERARCHY, v_CATEGORIES, p_CURSOR);
	END IF;

END GET_SYSTEM_VIEW_HIERARCHY;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_FILTER_HIERARCHY
	(
    p_OBJECT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer a Hierarchical recordset with information at each level.
BEGIN

	p_STATUS := GA.SUCCESS;

    IF p_OBJECT_ID < 0 THEN
		NULL_CURSOR(p_CURSOR);
	ELSE
		GET_SYSTEM_OBJECT_HIERARCHY(p_OBJECT_ID, TRUE, g_UNLIMITED_DEPTH, STRING_COLLECTION('Report', 'Report Filter', 'Action', 'Tree', 'Tree Column'), p_CURSOR);
	END IF;

END GET_FILTER_HIERARCHY;
--------------------------------------------------------------------------------------------------
PROCEDURE GET_CHART_HIERARCHY
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_CHART_NAME IN VARCHAR,
	p_CHART_INDEX IN NUMBER,
	p_CHART_TYPE IN VARCHAR,
	p_CHART_ID OUT NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- ANSWER A RECORDSET CONTAINING A HIERARCHY STARTING WITH THE OBJECT.
BEGIN

	p_STATUS := GA.SUCCESS;

	ID_FOR_SYSTEM_OBJECT(p_PARENT_OBJECT_ID, p_CHART_NAME, p_CHART_INDEX, 'Chart', p_CHART_TYPE, FALSE, p_CHART_ID);

	-- If we don't get a chart with the given name, then look for default chart
	IF p_CHART_ID <=0 THEN
		ID_FOR_SYSTEM_OBJECT(p_PARENT_OBJECT_ID, 'Default', p_CHART_INDEX, 'Chart', p_CHART_TYPE, FALSE, p_CHART_ID);
	END IF;

	-- If nothing is found, return null cursor
	IF p_CHART_ID <= 0 THEN
		p_CHART_ID := 0;
		NULL_CURSOR(p_CURSOR);
	ELSE
		GET_SYSTEM_OBJECT_HIERARCHY(p_CHART_ID, FALSE, g_UNLIMITED_DEPTH, NULL, p_CURSOR);
	END IF;

END GET_CHART_HIERARCHY;
-------------------------------------------------------------------------------------------------------
PROCEDURE GET_DATA_EXCHANGE_HIERARCHY
	(
    p_MODULE_NAME IN VARCHAR2,
	p_DATA_EXCHANGE_TYPE VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

v_MODULE_ID NUMBER(9);
v_WORK_ID	NUMBER;

BEGIN
	p_STATUS := GA.SUCCESS;

	SELECT MAX(S.OBJECT_ID)
	INTO v_MODULE_ID
	FROM SYSTEM_OBJECT S
	WHERE UPPER(S.OBJECT_NAME) = UPPER(p_MODULE_NAME)
	  AND S.OBJECT_CATEGORY = 'Module';

    IF v_MODULE_ID IS NOT NULL AND v_MODULE_ID > 0 THEN

		v_WORK_ID := ENUMERATE_HIERARCHY(v_MODULE_ID, p_INCLUDED_CATEGORIES => STRING_COLLECTION('Action', 'Data Exchange'), p_INCLUDE_HIDDEN => FALSE);

		OPEN p_CURSOR FOR
			SELECT SO.OBJECT_NAME,
				NVL(SO.OBJECT_DISPLAY_NAME, INITCAP(REPLACE(SO.OBJECT_NAME, '_', ' '))) "OBJECT_DISPLAY_NAME",
				NVL(SO.OBJECT_IS_HIDDEN, 0) "OBJECT_IS_HIDDEN",
				SO.OBJECT_ORDER "OBJECT_ORDER",
				SO.OBJECT_TYPE,
				SO.OBJECT_CATEGORY,
				SO.OBJECT_ID,
				SO.PARENT_OBJECT_ID,
				SOA.ATTRIBUTE_ID,
				SA.ATTRIBUTE_NAME,
				SA.ATTRIBUTE_DESC,
				SOA.ATTRIBUTE_VAL
			FROM (SELECT SO.*, ROWNUM as ROW_NBR
					FROM RTO_WORK W,
						SYSTEM_OBJECT SO
					START WITH SO.OBJECT_ID = v_MODULE_ID
						AND W.WORK_ID = v_WORK_ID
						AND W.WORK_XID = SO.OBJECT_ID
					CONNECT BY SO.PARENT_OBJECT_ID = PRIOR SO.OBJECT_ID
						AND W.WORK_ID = v_WORK_ID
						AND W.WORK_XID = SO.OBJECT_ID
						-- filter results so we're only getting data exchanges of specified type
						AND (SO.OBJECT_CATEGORY = 'Action'
							OR (SO.OBJECT_CATEGORY = 'Data Exchange'
								AND EXISTS (SELECT 1
											FROM SYSTEM_OBJECT_ATTRIBUTE SOA
											WHERE SO.OBJECT_ID = SOA.OBJECT_ID
											AND SOA.ATTRIBUTE_ID = 1401
											AND SOA.ATTRIBUTE_VAL = p_DATA_EXCHANGE_TYPE)))
					ORDER SIBLINGS BY SO.OBJECT_ORDER, NVL(SO.OBJECT_DISPLAY_NAME,SO.OBJECT_NAME), SO.OBJECT_ID) SO,
				SYSTEM_OBJECT_ATTRIBUTE SOA,
				SYSTEM_ATTRIBUTE SA
			WHERE SOA.OBJECT_ID(+) = SO.OBJECT_ID
				AND SA.ATTRIBUTE_ID(+) = SOA.ATTRIBUTE_ID
			ORDER BY SO.ROW_NBR;

		UT.PURGE_RTO_WORK(v_WORK_ID);

	END IF;

END GET_DATA_EXCHANGE_HIERARCHY;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_LAYOUT_HIERARCHY
	(
	p_LAYOUT_NAME IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_OBJECT_ID NUMBER;
v_WORK_ID NUMBER;
BEGIN
    BEGIN
		SELECT OBJECT_ID
		INTO v_OBJECT_ID
		FROM SYSTEM_OBJECT
		WHERE PARENT_OBJECT_ID = 0
			AND UPPER(OBJECT_NAME) = UPPER(p_LAYOUT_NAME)
			AND OBJECT_CATEGORY = 'Layout'
			AND ROWNUM = 1;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			NULL_CURSOR(p_CURSOR);
			RETURN;
	END;

	v_WORK_ID := GET_VALID_LAYOUTS(v_OBJECT_ID);

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT A.OBJECT_NAME,
			NVL(A.OBJECT_DISPLAY_NAME, INITCAP(REPLACE(A.OBJECT_NAME, '_', ' '))) "OBJECT_DISPLAY_NAME",
			NVL(A.OBJECT_IS_HIDDEN, 0) "OBJECT_IS_HIDDEN",
			A.OBJECT_ORDER "OBJECT_ORDER",
			A.OBJECT_TYPE,
			A.OBJECT_CATEGORY,
			A.OBJECT_ID,
			A.PARENT_OBJECT_ID,
			B.ATTRIBUTE_ID,
			ATTRIBUTE_NAME,
			ATTRIBUTE_DESC,
			B.ATTRIBUTE_VAL,
			SVP.OBJECT_NAME "MODULE_NAME",
			SVA.ATTRIBUTE_VAL "JAVA_CLASS_NAME"
		FROM RTO_WORK W,
			SYSTEM_OBJECT A,
			SYSTEM_OBJECT_ATTRIBUTE B,
			SYSTEM_ATTRIBUTE C,
			SYSTEM_OBJECT SV,
			SYSTEM_OBJECT SVP,
			SYSTEM_OBJECT_ATTRIBUTE SVA
		WHERE W.WORK_ID = v_WORK_ID
			AND A.OBJECT_ID = W.WORK_XID
			AND B.OBJECT_ID(+) = A.OBJECT_ID
			AND C.ATTRIBUTE_ID(+) = B.ATTRIBUTE_ID
			AND SV.OBJECT_ID(+) = W.WORK_SEQ
			AND SVP.OBJECT_ID(+) = SV.PARENT_OBJECT_ID
			AND SVA.OBJECT_ID(+) = SV.OBJECT_ID
			AND SVA.ATTRIBUTE_ID(+) = 801 -- Java Class Name
		ORDER BY W.WORK_DATA;

	-- make sure to clean up
	UT.PURGE_RTO_WORK(v_WORK_ID);

EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			UT.PURGE_RTO_WORK(v_WORK_ID);
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE();
		END;
		ERRS.LOG_AND_RAISE();

END GET_LAYOUT_HIERARCHY;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SHARED_CONFIG
	(
	p_OBJECT_CATEGORY IN VARCHAR2,
	p_OBJECT_NAME IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_PARENT_OBJECT_ID NUMBER(9);
v_OBJECT_ID NUMBER(9);
v_OBJECT_NAME VARCHAR2(512) := p_OBJECT_NAME;
BEGIN
	-- Shared objects are usually (almost always) children of the "Shared" module
	-- The only exception is that shared Reports can live in the "ReportRepository"
	-- module - but only look there if the object name is prefixed with 'Repository:'
	BEGIN
		IF p_OBJECT_CATEGORY = 'Report' AND SUBSTR(v_OBJECT_NAME,1,11) = 'Repository:' THEN
			v_OBJECT_NAME := SUBSTR(v_OBJECT_NAME,12);
    		SELECT OBJECT_ID
    		INTO v_PARENT_OBJECT_ID
    		FROM SYSTEM_OBJECT
    		WHERE PARENT_OBJECT_ID = 0
    			AND UPPER(OBJECT_NAME) = UPPER('ReportRepository')
    			AND OBJECT_CATEGORY = 'Module'
    			AND ROWNUM = 1;
		ELSE
    		SELECT OBJECT_ID
    		INTO v_PARENT_OBJECT_ID
    		FROM SYSTEM_OBJECT
    		WHERE PARENT_OBJECT_ID = 0
    			AND UPPER(OBJECT_NAME) = UPPER('Shared')
    			AND OBJECT_CATEGORY = 'Module'
    			AND ROWNUM = 1;
		END IF;

		SELECT OBJECT_ID
		INTO v_OBJECT_ID
		FROM SYSTEM_OBJECT
		WHERE PARENT_OBJECT_ID = v_PARENT_OBJECT_ID
			AND UPPER(OBJECT_NAME) = UPPER(v_OBJECT_NAME)
			AND OBJECT_CATEGORY = p_OBJECT_CATEGORY
			AND ROWNUM = 1;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			NULL_CURSOR(p_CURSOR);
			RETURN;
	END;

	GET_SYSTEM_OBJECT_HIERARCHY(v_OBJECT_ID, TRUE, g_UNLIMITED_DEPTH, NULL, p_CURSOR);

END GET_SHARED_CONFIG;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_SYSTEM_OBJECT_FOR_SCRIPT
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_OBJECT_NAME IN VARCHAR,
	p_OBJECT_CATEGORY IN VARCHAR,
	p_OBJECT_DISPLAY_NAME IN VARCHAR2,
	p_OBJECT_TAG IN VARCHAR2,
	p_OBJECT_ORDER IN NUMBER,
	p_OBJECT_IS_HIDDEN IN NUMBER,
	p_ATTRIBUTES IN VARCHAR2,
	p_OBJECT_ID OUT NUMBER
	) AS
v_OBJECT_INDEX NUMBER(1) := 0;
v_OBJECT_ID NUMBER(9);
v_OBJECT_TYPE VARCHAR2(16) := 'Default';
BEGIN

	ID_FOR_SYSTEM_OBJECT(p_PARENT_OBJECT_ID, p_OBJECT_NAME, v_OBJECT_INDEX, p_OBJECT_CATEGORY, v_OBJECT_TYPE, FALSE, v_OBJECT_ID);
	PUT_SYSTEM_OBJECT(v_OBJECT_ID, v_OBJECT_ID, p_PARENT_OBJECT_ID, p_OBJECT_NAME, v_OBJECT_INDEX, p_OBJECT_CATEGORY, v_OBJECT_TYPE, NULL, NULL, p_OBJECT_DISPLAY_NAME, p_OBJECT_ORDER, p_OBJECT_IS_HIDDEN, p_ATTRIBUTES);
	p_OBJECT_ID := v_OBJECT_ID;

END PUT_SYSTEM_OBJECT_FOR_SCRIPT;
----------------------------------------------------------------------------------------------------
PROCEDURE TREE_NODES_CONFIGURATION
   (
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the System Objects available
v_WORK_ID NUMBER;

BEGIN

    p_STATUS := GA.SUCCESS;

	v_WORK_ID := ENUMERATE_HIERARCHY(0);

	OPEN p_CURSOR FOR
		SELECT ROW_NBR,
			OBJECT_ID,
			PARENT_OBJECT_ID,
			OBJECT_CATEGORY,
			CASE WHEN OBJECT_DISPLAY_NAME IS NULL OR (OBJECT_CATEGORY = 'Column' AND SUBSTR(OBJECT_DISPLAY_NAME,1,1) = '=') THEN
					OBJECT_NAME
				WHEN UPPER(OBJECT_DISPLAY_NAME) <> UPPER(OBJECT_NAME) THEN
					OBJECT_DISPLAY_NAME||' ('||OBJECT_NAME||')'
				ELSE
					OBJECT_DISPLAY_NAME
				END as NAME,
            OBJECT_CATEGORY || 's' as CATEGORY_DISPLAY_NAME,
			CASE OBJECT_CATEGORY
				WHEN 'Layout' THEN 'Layouts|Layout'
				WHEN 'Module' THEN
					CASE OBJECT_NAME
						WHEN 'Shared' THEN 'Actions|Action;Charts|Chart;Columns|Column;Grids|Grid;Labels|Label;Layouts|Layout;Reports|Report;Report Filters|Report Filter;IO Tables|IO Table;Trees|Tree'
						WHEN 'ReportRepository' THEN 'Reports|Report'
						ELSE 'System Views|System View;Data Exchanges|Data Exchange'
						END
				WHEN 'Data Exchange' THEN 'Actions|Action'
				WHEN 'System View' THEN 'Reports|Report;Actions|Action'
				WHEN 'Report' THEN 'Report Filters|Report Filter;Grids|Grid;Charts|Chart;Actions|Action;IO Tables|IO Table'
				WHEN 'Grid' THEN 'Columns|Column;Actions|Action;Labels|Label'
				WHEN 'Report Filter' THEN 'Actions|Action;Trees|Tree'
				WHEN 'Action' THEN 'Actions|Action'
				WHEN 'IO Table' THEN 'IO Fields|IO Field;IO SubTabs|IO SubTab;Actions|Action;Grids|Grid'
				WHEN 'Tree' THEN 'Tree Columns|Tree Column;Trees|Tree'
				ELSE NULL
				END as REQUIRED_CHILDREN
		FROM (SELECT SO.OBJECT_ID, SO.PARENT_OBJECT_ID, SO.OBJECT_CATEGORY,
					SO.OBJECT_NAME, SO.OBJECT_DISPLAY_NAME, ROWNUM as ROW_NBR
				FROM RTO_WORK W,
					SYSTEM_OBJECT SO
				START WITH SO.OBJECT_ID = 0
					AND W.WORK_ID = v_WORK_ID
					AND W.WORK_XID = SO.OBJECT_ID
				CONNECT BY SO.PARENT_OBJECT_ID = PRIOR SO.OBJECT_ID
					AND W.WORK_ID = v_WORK_ID
					AND W.WORK_XID = SO.OBJECT_ID
				ORDER SIBLINGS BY SO.OBJECT_ORDER, NVL(SO.OBJECT_DISPLAY_NAME,SO.OBJECT_NAME), SO.OBJECT_ID)
		ORDER BY ROW_NBR;

	UT.PURGE_RTO_WORK(v_WORK_ID);

END TREE_NODES_CONFIGURATION;
----------------------------------------------------------------------------------------------------
PROCEDURE TREE_NODES_LAYOUTS
	(
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_WORK_ID NUMBER;
BEGIN
	v_WORK_ID := GET_VALID_LAYOUTS(0);

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT W.WORK_DATA2 "PATH",
			A.OBJECT_ID,
			A.PARENT_OBJECT_ID,
            CASE WHEN A.PARENT_OBJECT_ID <> 0 AND NOT EXISTS (SELECT 1 FROM SYSTEM_OBJECT WHERE PARENT_OBJECT_ID = A.OBJECT_ID)
				THEN 'leaf'
				ELSE '?'
				END "NODE_TYPE",
			NVL(A.OBJECT_DISPLAY_NAME, INITCAP(REPLACE(A.OBJECT_NAME, '_', ' '))) "NAME",
    		B.ATTRIBUTE_VAL "TYPE",
    		C.ATTRIBUTE_VAL "URL",
    		D.ATTRIBUTE_VAL "TARGET",
    		E.ATTRIBUTE_VAL "EXPAND_MENU_ON_LOAD",
    		F.ATTRIBUTE_VAL "TAB_CONFIG_PATH",
    		A.OBJECT_NAME "LAYOUT_NAME"
    	FROM RTO_WORK W,
			SYSTEM_OBJECT A,
   			SYSTEM_OBJECT_ATTRIBUTE B,
			SYSTEM_OBJECT_ATTRIBUTE C,
			SYSTEM_OBJECT_ATTRIBUTE D,
			SYSTEM_OBJECT_ATTRIBUTE E,
			SYSTEM_OBJECT_ATTRIBUTE F
        WHERE W.WORK_ID = v_WORK_ID
			AND A.OBJECT_ID = W.WORK_XID
			AND B.OBJECT_ID(+) = A.OBJECT_ID
            AND B.ATTRIBUTE_ID(+) = 701
            AND C.OBJECT_ID(+) = A.OBJECT_ID
            AND C.ATTRIBUTE_ID(+) = 709
            AND D.OBJECT_ID(+) = A.OBJECT_ID
            AND D.ATTRIBUTE_ID(+) = 710
            AND E.OBJECT_ID(+) = A.OBJECT_ID
            AND E.ATTRIBUTE_ID(+) = 711
            AND F.OBJECT_ID(+) = A.OBJECT_ID
            AND F.ATTRIBUTE_ID(+) = 703
        ORDER BY W.WORK_DATA;

	-- make sure to clean up
	UT.PURGE_RTO_WORK(v_WORK_ID);

EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			UT.PURGE_RTO_WORK(v_WORK_ID);
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE();
		END;
		ERRS.LOG_AND_RAISE();

END TREE_NODES_LAYOUTS;
---------------------------------------------------------------------------------------------------
PROCEDURE TREE_NODES_LAYOUT_CONFIG
    (
   	p_LAYOUT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

v_WORK_ID NUMBER;

BEGIN

    p_STATUS := GA.SUCCESS;

	v_WORK_ID := ENUMERATE_HIERARCHY(p_LAYOUT_ID, p_INCLUDED_CATEGORIES => STRING_COLLECTION('Layout'));

	OPEN p_CURSOR FOR
		SELECT ROW_NBR,
			OBJECT_ID,
			PARENT_OBJECT_ID,
			OBJECT_CATEGORY,
			CASE WHEN OBJECT_DISPLAY_NAME IS NULL THEN
					OBJECT_NAME
				WHEN UPPER(OBJECT_DISPLAY_NAME) <> UPPER(OBJECT_NAME) THEN
					OBJECT_DISPLAY_NAME||' ('||OBJECT_NAME||')'
				ELSE
					OBJECT_DISPLAY_NAME
				END as NAME,
            OBJECT_CATEGORY || 's' as CATEGORY_DISPLAY_NAME,
			NULL as REQUIRED_CHILDREN
		FROM (SELECT SO.OBJECT_ID, SO.PARENT_OBJECT_ID, SO.OBJECT_CATEGORY,
					SO.OBJECT_NAME, SO.OBJECT_DISPLAY_NAME, ROWNUM as ROW_NBR
				FROM RTO_WORK W,
					SYSTEM_OBJECT SO
				WHERE EXISTS (SELECT 1
    							FROM SYSTEM_OBJECT_ATTRIBUTE SOA
    							WHERE SOA.OBJECT_ID = SO.OBJECT_ID
									AND SOA.ATTRIBUTE_ID = 701
    								AND SOA.ATTRIBUTE_VAL IN ('Aggregate','Splitter')
								)
				START WITH SO.OBJECT_ID = p_LAYOUT_ID
					AND W.WORK_ID = v_WORK_ID
					AND W.WORK_XID = SO.OBJECT_ID
				CONNECT BY SO.PARENT_OBJECT_ID = PRIOR SO.OBJECT_ID
					AND W.WORK_ID = v_WORK_ID
					AND W.WORK_XID = SO.OBJECT_ID
				ORDER SIBLINGS BY SO.OBJECT_ORDER, NVL(SO.OBJECT_DISPLAY_NAME,SO.OBJECT_NAME), SO.OBJECT_ID)
		ORDER BY ROW_NBR;

	UT.PURGE_RTO_WORK(v_WORK_ID);

END TREE_NODES_LAYOUT_CONFIG;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_CONFIG_PARENT_ATTRIBUTES
	(
	p_OBJECT_ID IN NUMBER,
	p_OBJECT_NAME OUT VARCHAR2,
	p_OBJECT_DISPLAY_NAME OUT VARCHAR2,
	p_OBJECT_CATEGORY OUT VARCHAR2,
	p_OBJECT_IS_HIDDEN OUT NUMBER,
	p_OBJECT_DESC OUT VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the config information about one object

BEGIN

	p_STATUS := GA.SUCCESS;

	CHECK_OBJECT_PRIVILEGE(p_OBJECT_ID, g_PRIV_VIEW);

    SELECT OBJECT_NAME, OBJECT_DISPLAY_NAME, OBJECT_DESC,
		NVL(OBJECT_IS_HIDDEN, 0), OBJECT_CATEGORY
	INTO p_OBJECT_NAME, p_OBJECT_DISPLAY_NAME, p_OBJECT_DESC,
		p_OBJECT_IS_HIDDEN, p_OBJECT_CATEGORY
	FROM SYSTEM_OBJECT
	WHERE OBJECT_ID = p_OBJECT_ID;

	OPEN p_CURSOR FOR
		  SELECT 0 "NOT_DEFINED",
		  		p_OBJECT_ID "OBJECT_ID",
		  		C.ATTRIBUTE_ID,
				C.ATTRIBUTE_NAME,
				C.ATTRIBUTE_DESC,
				B.ATTRIBUTE_VAL,
				C.ATTRIBUTE_COMBO_LIST,
				C.ATTRIBUTE_IS_BOOLEAN,
				CASE
					WHEN C.ATTRIBUTE_COMBO_LIST IS NULL
						AND NVL(C.ATTRIBUTE_IS_BOOLEAN, 0) = 0 THEN 'BIG TEXT'
					ELSE NULL
					END AS EDIT_TYPE
		  FROM SYSTEM_OBJECT_ATTRIBUTE B, SYSTEM_ATTRIBUTE C
		  WHERE B.OBJECT_ID = p_OBJECT_ID
			  AND C.ATTRIBUTE_ID = B.ATTRIBUTE_ID
		  UNION ALL
		  SELECT 1 "NOT_DEFINED",
		  		p_OBJECT_ID "OBJECT_ID",
				C.ATTRIBUTE_ID,
				C.ATTRIBUTE_NAME,
				C.ATTRIBUTE_DESC,
				NULL "ATTRIBUTE_VAL",
				C.ATTRIBUTE_COMBO_LIST,
				C.ATTRIBUTE_IS_BOOLEAN,
				CASE
					WHEN C.ATTRIBUTE_COMBO_LIST IS NULL
						AND NVL(C.ATTRIBUTE_IS_BOOLEAN, 0) = 0 THEN 'BIG TEXT'
					ELSE NULL
					END AS EDIT_TYPE
		  FROM SYSTEM_ATTRIBUTE C
		  WHERE p_OBJECT_CATEGORY LIKE C.OBJECT_CATEGORY
			  AND NOT EXISTS (SELECT ATTRIBUTE_ID
			  			 FROM SYSTEM_OBJECT_ATTRIBUTE
						 WHERE OBJECT_ID = p_OBJECT_ID
						 		AND ATTRIBUTE_ID = C.ATTRIBUTE_ID)
		  ORDER BY 1,3,5;

END GET_CONFIG_PARENT_ATTRIBUTES;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_CONFIG_PARENT_ATTRIBUTES
	(
	p_OBJECT_ID IN NUMBER,
	p_OBJECT_NAME IN VARCHAR2,
	p_OBJECT_DISPLAY_NAME IN VARCHAR2,
	p_OBJECT_IS_HIDDEN IN NUMBER,
	p_OBJECT_DESC IN VARCHAR2,
	p_ATTRIBUTES IN VARCHAR2,
	p_STATUS OUT NUMBER
	) AS

-- The parent already exists.  Update what has changed.
BEGIN

	CHECK_OBJECT_PRIVILEGE(p_OBJECT_ID, g_PRIV_EDIT);

	p_STATUS := GA.SUCCESS;

	UPDATE SYSTEM_OBJECT
	SET OBJECT_NAME = p_OBJECT_NAME,
		OBJECT_DISPLAY_NAME = p_OBJECT_DISPLAY_NAME,
		OBJECT_IS_HIDDEN = p_OBJECT_IS_HIDDEN,
		OBJECT_DESC = p_OBJECT_DESC
	WHERE OBJECT_ID = p_OBJECT_ID;

	PUT_SYSTEM_OBJECT_ATTRIBUTES(p_OBJECT_ID, p_ATTRIBUTES, p_STATUS);


END PUT_CONFIG_PARENT_ATTRIBUTES;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_CONFIG_CHILD_LIST
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_CHILD_CATEGORY IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the list of children of the specified category.
v_WORK_ID	NUMBER;

BEGIN

	p_STATUS := GA.SUCCESS;

	v_WORK_ID := ENUMERATE_HIERARCHY(p_PARENT_OBJECT_ID, 1, FALSE, p_INCLUDED_CATEGORIES => STRING_COLLECTION(p_CHILD_CATEGORY));

	OPEN p_CURSOR FOR
        SELECT A.OBJECT_ID,
			A.PARENT_OBJECT_ID,
			A.OBJECT_NAME,
			A.OBJECT_INDEX,
			A.OBJECT_CATEGORY,
			A.OBJECT_TYPE,
			A.OBJECT_ALIAS,
			A.OBJECT_DESC,
			A.OBJECT_DISPLAY_NAME,
			A.OBJECT_TAG,
			A.OBJECT_ORDER,
			A.OBJECT_IS_HIDDEN,
			A.ENTRY_DATE,
			NULL as ATTRIBUTES
        FROM SYSTEM_OBJECT A,
			RTO_WORK W
        WHERE A.PARENT_OBJECT_ID = p_PARENT_OBJECT_ID
			AND W.WORK_ID = v_WORK_ID
			AND W.WORK_XID = A.OBJECT_ID
        ORDER BY OBJECT_ORDER, OBJECT_NAME;

	UT.PURGE_RTO_WORK(v_WORK_ID);

END GET_CONFIG_CHILD_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_LAYOUT_CONFIG_CHILD_LIST
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the list of system view children for the given top level layout.
-- Used to populate the layout configuration grid

-- Answer the list of children of the specified category.
v_WORK_ID	NUMBER;

BEGIN

	p_STATUS := GA.SUCCESS;

	v_WORK_ID := ENUMERATE_HIERARCHY(p_PARENT_OBJECT_ID, 1, FALSE, p_INCLUDED_CATEGORIES => STRING_COLLECTION('Layout'));

	OPEN p_CURSOR FOR
		SELECT L.OBJECT_ID,
			L.OBJECT_IS_HIDDEN,
			L.OBJECT_DISPLAY_NAME,
			L.OBJECT_NAME,
			L.OBJECT_ORDER,
			SV.OBJECT_ID as SYS_VIEW_ID,
			L.SYS_VIEW_NAME
		FROM (SELECT SO.*,
					A1.ATTRIBUTE_VAL as SYS_VIEW_NAME
				FROM SYSTEM_OBJECT SO,
					RTO_WORK W,
					SYSTEM_OBJECT_ATTRIBUTE A1,
					SYSTEM_OBJECT_ATTRIBUTE A2
				WHERE SO.PARENT_OBJECT_ID = p_PARENT_OBJECT_ID
					AND W.WORK_ID = v_WORK_ID
					AND W.WORK_XID = SO.OBJECT_ID
					AND A1.OBJECT_ID = SO.OBJECT_ID
					AND A1.ATTRIBUTE_ID = 708 -- view reference
					AND A2.OBJECT_ID = SO.OBJECT_ID
					AND A2.ATTRIBUTE_ID = 701 -- pane type
					AND A2.ATTRIBUTE_VAL = 'System View') L,
			SYSTEM_OBJECT SV
		WHERE UPPER(SV.OBJECT_NAME) = UPPER(L.SYS_VIEW_NAME)
			AND SV.OBJECT_CATEGORY = 'System View'
        ORDER BY OBJECT_ORDER, OBJECT_DISPLAY_NAME, OBJECT_NAME;

	UT.PURGE_RTO_WORK(v_WORK_ID);

END GET_LAYOUT_CONFIG_CHILD_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_LAYOUT_CONFIG
	(
	p_OBJECT_ID IN NUMBER,
	p_OBJECT_IS_HIDDEN IN NUMBER,
	p_OBJECT_DISPLAY_NAME IN VARCHAR2,
	p_OBJECT_ORDER IN NUMBER,
	p_STATUS OUT NUMBER
	) AS
BEGIN
	CHECK_OBJECT_PRIVILEGE(p_OBJECT_ID, g_PRIV_EDIT);

    UPDATE SYSTEM_OBJECT
		SET OBJECT_IS_HIDDEN = p_OBJECT_IS_HIDDEN,
			OBJECT_DISPLAY_NAME = p_OBJECT_DISPLAY_NAME,
			OBJECT_ORDER = p_OBJECT_ORDER
	WHERE OBJECT_ID = p_OBJECT_ID;

	p_STATUS := GA.SUCCESS;
END PUT_LAYOUT_CONFIG;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_REPORTS_BY_SYS_VIEW
	(
	p_SYS_VIEW_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the list of reports assigned to the given system view.
-- Used to populate the layout configuration drill down grid
v_WORK_ID	NUMBER;

BEGIN

	p_STATUS := GA.SUCCESS;

	v_WORK_ID := ENUMERATE_HIERARCHY(p_SYS_VIEW_ID, 1, FALSE, p_INCLUDED_CATEGORIES => STRING_COLLECTION('Report'));

	OPEN p_CURSOR FOR
        SELECT SO.OBJECT_ID as ORIG_REPORT_OBJECT_ID,
			SO.OBJECT_ID as REPORT_OBJECT_ID,
			SOA.ATTRIBUTE_VAL as SHARED_CONFIG_NAME,
			SO.OBJECT_ORDER,
			SO.OBJECT_DISPLAY_NAME,
			SO.OBJECT_NAME
		FROM SYSTEM_OBJECT SO,
			RTO_WORK W,
			SYSTEM_OBJECT_ATTRIBUTE SOA
		WHERE SO.PARENT_OBJECT_ID = p_SYS_VIEW_ID
			AND W.WORK_ID = v_WORK_ID
			AND W.WORK_XID = SO.OBJECT_ID
			AND SOA.OBJECT_ID(+) = SO.OBJECT_ID
			AND SOA.ATTRIBUTE_ID(+) = -1
		ORDER BY SO.OBJECT_ORDER, SO.OBJECT_DISPLAY_NAME, SO.OBJECT_NAME;

	UT.PURGE_RTO_WORK(v_WORK_ID);

END GET_REPORTS_BY_SYS_VIEW;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_REPOS_REPS_INTO_SYS_VIEW
	(
	p_SYS_VIEW_ID IN NUMBER,
	p_ORIG_REPORT_OBJECT_ID IN NUMBER,
	p_REPORT_OBJECT_ID IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

-- Adds selected report from repository into selected system view by:
--	1. creating new object under the system view
--  2. setting the shared configuration property on the new object to point
--		to the attributes of the repository report

	v_OBJECT_ID NUMBER;
	v_OBJECT_ORDER NUMBER;
	v_OBJ SYSTEM_OBJECT%ROWTYPE;

BEGIN

	p_STATUS := GA.SUCCESS;

	IF p_REPORT_OBJECT_ID <> p_ORIG_REPORT_OBJECT_ID THEN
    	SELECT *
    	INTO v_OBJ
    	FROM SYSTEM_OBJECT
    	WHERE OBJECT_ID = p_REPORT_OBJECT_ID;

    	IF NVL(p_ORIG_REPORT_OBJECT_ID,0) > 0 THEN
    		PUT_SYSTEM_OBJECT_ATTRIBUTE(p_ORIG_REPORT_OBJECT_ID,-1,'Repository:' || v_OBJ.OBJECT_NAME,p_STATUS);
    	ELSE
        	SELECT NVL(MAX(SO.OBJECT_ORDER) + 1,0)
        	INTO v_OBJECT_ORDER
        	FROM SYSTEM_OBJECT SO
        	WHERE SO.PARENT_OBJECT_ID=p_SYS_VIEW_ID
        		AND SO.OBJECT_CATEGORY = 'Report';

        	PUT_SYSTEM_OBJECT(
        					v_OBJECT_ID, -- new object id
        					0, -- current object id
        					p_SYS_VIEW_ID, --parent_object_id
        					v_OBJ.OBJECT_NAME,
        					0, --object_index
        					'Report', --object_category
        					'Default', --object_type
        					v_OBJ.OBJECT_ALIAS,
        					v_OBJ.OBJECT_DESC,
        					v_OBJ.OBJECT_DISPLAY_NAME,
        					v_OBJECT_ORDER,
        					v_OBJ.OBJECT_IS_HIDDEN,
        					'-1~Repository:' || v_OBJ.OBJECT_NAME);
    	END IF;
	END IF;


END PUT_REPOS_REPS_INTO_SYS_VIEW;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_REPORT_INFO
	(
	p_REPORT_OBJECT_ID IN NUMBER,
	p_OBJECT_NAME OUT VARCHAR2,
	p_OBJECT_DISPLAY_NAME OUT VARCHAR2,
	p_OBJECT_DESC OUT VARCHAR2
	) AS
BEGIN
	SELECT OBJECT_NAME, OBJECT_DISPLAY_NAME, OBJECT_DESC
	INTO p_OBJECT_NAME, p_OBJECT_DISPLAY_NAME, p_OBJECT_DESC
	FROM SYSTEM_OBJECT
	WHERE OBJECT_ID = p_REPORT_OBJECT_ID;
END GET_REPORT_INFO;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_REPOSITORY_REPORTS
	(
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the list of reports assigned to the report repository.
-- Used to populate the layout configuration drill down grid
v_REPORT_REPOSITORY_ID	NUMBER(9);
v_WORK_ID				NUMBER;

BEGIN

	p_STATUS := GA.SUCCESS;

	BEGIN
		SELECT OBJECT_ID
		INTO v_REPORT_REPOSITORY_ID
		FROM SYSTEM_OBJECT
		WHERE UPPER(OBJECT_NAME) = UPPER('ReportRepository')
			AND OBJECT_CATEGORY = 'Module'
			AND ROWNUM = 1;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'System_Object with Object_Name = "ReportRepository"');
	END;

	v_WORK_ID := ENUMERATE_HIERARCHY(v_REPORT_REPOSITORY_ID, 1, FALSE, p_INCLUDED_CATEGORIES => STRING_COLLECTION('Report'));

	OPEN p_CURSOR FOR
		SELECT W.WORK_DATA as OBJECT_NAME,
			   W.WORK_XID as OBJECT_ID
		FROM RTO_WORK W
		WHERE W.WORK_ID = v_WORK_ID
		ORDER BY 1;

	UT.PURGE_RTO_WORK(v_WORK_ID);

END GET_REPOSITORY_REPORTS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_VALID_REPORT_LIST
	(
	p_ORIG_REPORT_OBJECT_ID IN NUMBER,
	p_SHARED_CONFIG_NAME IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the list of reports created under the given module.
-- If the report id is null (entering new row), or the report belongs to the repository
-- (shared configuration object not null), retrieve repository reports.
-- Used to populate the layout configuration drill down grid

v_REPORT_REPOSITORY_ID	NUMBER(9);
v_WORK_ID				NUMBER;

BEGIN

	p_STATUS := GA.SUCCESS;

	IF p_ORIG_REPORT_OBJECT_ID IS NULL OR p_SHARED_CONFIG_NAME IS NOT NULL THEN
		BEGIN
			SELECT OBJECT_ID
			INTO v_REPORT_REPOSITORY_ID
			FROM SYSTEM_OBJECT
			WHERE PARENT_OBJECT_ID = 0
				AND OBJECT_CATEGORY = 'Module'
				AND UPPER(OBJECT_NAME) = UPPER('ReportRepository');
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
			   ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'System_Object with Object_Name = "ReportRepository"');
		END;

		v_WORK_ID := ENUMERATE_HIERARCHY(v_REPORT_REPOSITORY_ID, 1, FALSE, p_INCLUDED_CATEGORIES => STRING_COLLECTION('Report'));

		OPEN p_CURSOR FOR
			SELECT SO.OBJECT_NAME,
				 SO.OBJECT_ID
			FROM SYSTEM_OBJECT SO
			WHERE SO.OBJECT_ID = p_ORIG_REPORT_OBJECT_ID
			UNION ALL
			SELECT W.WORK_DATA as OBJECT_NAME,
				W.WORK_XID as OBJECT_ID
			FROM RTO_WORK W
			WHERE W.WORK_ID = v_WORK_ID
			ORDER BY 1;

		UT.PURGE_RTO_WORK(v_WORK_ID);

    ELSE

		OPEN p_CURSOR FOR
			SELECT SO.OBJECT_NAME,
				SO.OBJECT_ID
			FROM SYSTEM_OBJECT SO
			WHERE SO.OBJECT_ID = p_ORIG_REPORT_OBJECT_ID;

    END IF;


END GET_VALID_REPORT_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_CONFIG_CHILDREN
	(
	p_OBJECT_ID IN NUMBER,
	p_PARENT_OBJECT_ID IN NUMBER,
	p_OBJECT_NAME IN VARCHAR2,
	p_OBJECT_CATEGORY IN VARCHAR2,
	p_OBJECT_DISPLAY_NAME IN VARCHAR2,
	p_OBJECT_TAG IN VARCHAR2,
	p_OBJECT_ORDER IN NUMBER,
	p_OBJECT_IS_HIDDEN IN NUMBER,
	p_OBJECT_DESC IN VARCHAR2,
	p_ATTRIBUTES IN VARCHAR2,
	p_STATUS OUT NUMBER
	) AS

-- The parent already exists.  Update what has changed.
BEGIN

	p_STATUS := GA.SUCCESS;

	PUT_SYSTEM_OBJECT(p_STATUS, p_OBJECT_ID, p_PARENT_OBJECT_ID,
		p_OBJECT_NAME, 0, p_OBJECT_CATEGORY, 'Default', NULL,
		p_OBJECT_DESC, p_OBJECT_DISPLAY_NAME, p_OBJECT_ORDER, p_OBJECT_IS_HIDDEN,
		p_ATTRIBUTES);


END PUT_CONFIG_CHILDREN;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_CONFIG_CHILD_ATTRIBUTES
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_CHILD_CATEGORY IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the attributes of all the children of an object

BEGIN

	-- GET_CONFIG_CHILD_ATTRIBUTES is called from Java.
	-- But SYSTEM_OBJECT_ATTRIBUTES_E, called from VB, is the same; so just call through
	SYSTEM_OBJECT_ATTRIBUTES_E(p_PARENT_OBJECT_ID,	p_CHILD_CATEGORY, -1, NULL, 1, p_STATUS, p_CURSOR);

END GET_CONFIG_CHILD_ATTRIBUTES;
----------------------------------------------------------------------------------------------------
PROCEDURE MOVE_SYSTEM_OBJECT
	(
	p_OBJECT_ID IN NUMBER,
	p_NEW_PARENT_OBJECT_ID IN NUMBER
	) AS
BEGIN
	CHECK_OBJECT_PRIVILEGE(p_OBJECT_ID, g_PRIV_EDIT);
	CHECK_OBJECT_PRIVILEGE(p_NEW_PARENT_OBJECT_ID, g_PRIV_EDIT);

	-- TODO query existing child objects - we may need to rename this object
	-- to prevent unique constraint violation!
    UPDATE SYSTEM_OBJECT
		SET PARENT_OBJECT_ID = p_NEW_PARENT_OBJECT_ID
	WHERE OBJECT_ID = p_OBJECT_ID;

END MOVE_SYSTEM_OBJECT;
----------------------------------------------------------------------------------------------------
FUNCTION GET_OBJECT_NAME
	(
	p_OBJECT_NAME IN VARCHAR2,
	p_OBJECT_INDEX IN NUMBER,
	p_OBJECT_TYPE IN VARCHAR2,
	p_OBJECT_CATEGORY IN VARCHAR2,
	p_PARENT_OBJECT_ID IN NUMBER
	) RETURN VARCHAR2 IS
v_NAME VARCHAR2(256) := p_OBJECT_NAME;
v_ATTEMPT BINARY_INTEGER := 0;
v_COUNT BINARY_INTEGER := 1;
BEGIN
	LOOP
		IF v_ATTEMPT > 0 THEN
			v_NAME := p_OBJECT_NAME||' ('||v_ATTEMPT||')';
		END IF;

		SELECT COUNT(1)
		INTO v_COUNT
		FROM SYSTEM_OBJECT
		WHERE PARENT_OBJECT_ID = p_PARENT_OBJECT_ID
			AND UPPER(OBJECT_NAME) = UPPER(v_NAME)
			AND OBJECT_INDEX = p_OBJECT_INDEX
			AND OBJECT_TYPE = p_OBJECT_TYPE
			AND OBJECT_CATEGORY = p_OBJECT_CATEGORY;

		EXIT WHEN v_COUNT = 0;
		v_ATTEMPT := v_ATTEMPT+1;
	END LOOP;

	RETURN v_NAME;
END GET_OBJECT_NAME;
----------------------------------------------------------------------------------------------------
PROCEDURE COPY_SYSTEM_OBJECT
	(
	p_OBJECT IN SYSTEM_OBJECT%ROWTYPE,
	p_NEW_PARENT_OBJECT_ID IN NUMBER,
	p_WORK_ID IN NUMBER
	) AS
v_OBJECT_ID NUMBER(9) := p_OBJECT.OBJECT_ID;
v_OBJECT SYSTEM_OBJECT%ROWTYPE := p_OBJECT;
CURSOR c_CHILDREN RETURN SYSTEM_OBJECT%ROWTYPE IS
    SELECT SO.*
    FROM SYSTEM_OBJECT SO,
    	RTO_WORK W
    WHERE W.WORK_ID = p_WORK_ID
    	AND W.WORK_SEQ = v_OBJECT_ID
    	AND SO.OBJECT_ID = W.WORK_XID
    ORDER BY SO.OBJECT_CATEGORY, SO.OBJECT_ORDER, SO.OBJECT_NAME;

BEGIN

    SELECT NVL(MAX(OBJECT_ORDER),-1)+1
	INTO v_OBJECT.OBJECT_ORDER
	FROM SYSTEM_OBJECT
	WHERE PARENT_OBJECT_ID = p_NEW_PARENT_OBJECT_ID
		AND OBJECT_CATEGORY = v_OBJECT.OBJECT_CATEGORY;

	SELECT MID.NEXTVAL INTO v_OBJECT.OBJECT_ID FROM DUAL;
	v_OBJECT.PARENT_OBJECT_ID := p_NEW_PARENT_OBJECT_ID;
	v_OBJECT.OBJECT_NAME := GET_OBJECT_NAME(v_OBJECT.OBJECT_NAME,
											v_OBJECT.OBJECT_INDEX,
											v_OBJECT.OBJECT_TYPE,
											v_OBJECT.OBJECT_CATEGORY,
											p_NEW_PARENT_OBJECT_ID);

	INSERT INTO SYSTEM_OBJECT VALUES v_OBJECT;

	INSERT INTO SYSTEM_OBJECT_ATTRIBUTE
		(OBJECT_ID, ATTRIBUTE_ID, ATTRIBUTE_VAL)
	SELECT v_OBJECT.OBJECT_ID, A.ATTRIBUTE_ID, A.ATTRIBUTE_VAL
	FROM SYSTEM_OBJECT_ATTRIBUTE A
	WHERE A.OBJECT_ID = v_OBJECT_ID;

	FOR v_CHILD IN c_CHILDREN LOOP
        COPY_SYSTEM_OBJECT(v_CHILD,v_OBJECT.OBJECT_ID,p_WORK_ID);
	END LOOP;

END COPY_SYSTEM_OBJECT;
----------------------------------------------------------------------------------------------------
PROCEDURE COPY_SYSTEM_OBJECT
	(
	p_OBJECT_ID IN NUMBER,
	p_NEW_PARENT_OBJECT_ID IN NUMBER
	) AS
v_OBJECT_REC SYSTEM_OBJECT%ROWTYPE;
v_WORK_OBJECT_IDs NUMBER(9);

BEGIN
	CHECK_OBJECT_PRIVILEGE(p_OBJECT_ID, g_PRIV_VIEW);
	CHECK_OBJECT_PRIVILEGE(p_NEW_PARENT_OBJECT_ID, g_PRIV_EDIT, p_INHERITABLE => TRUE);

	-- dump sub-tree of accessible objects to work table
	v_WORK_OBJECT_IDs := ENUMERATE_HIERARCHY(p_OBJECT_ID);

	SELECT * INTO v_OBJECT_REC
	FROM SYSTEM_OBJECT
	WHERE OBJECT_ID = p_OBJECT_ID;

	-- call proc that will recursively copy every object to new sub-tree
	COPY_SYSTEM_OBJECT(v_OBJECT_REC,p_NEW_PARENT_OBJECT_ID,v_WORK_OBJECT_IDs);

	UT.PURGE_RTO_WORK(v_WORK_OBJECT_IDs);

EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			UT.PURGE_RTO_WORK(v_WORK_OBJECT_IDs);
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE();
		END;
		ERRS.LOG_AND_RAISE();

END COPY_SYSTEM_OBJECT;
----------------------------------------------------------------------------------------------------
PROCEDURE IS_VALID_PASTE_OPERATION
	(
	p_OBJECT_ID IN NUMBER,
	p_NEW_PARENT_OBJECT_ID IN NUMBER,
    p_IS_VALID OUT NUMBER
	) AS

BEGIN

    p_IS_VALID := 1;

END IS_VALID_PASTE_OPERATION;
----------------------------------------------------------------------------------------------------
PROCEDURE DELETE_SYSTEM_OBJECT
    (
    p_OBJECT_ID IN NUMBER
    ) AS
BEGIN

	--Raise an error if we do not have sufficient privileges
	-- on the full sub-tree of the object we are deleting.
	CHECK_OBJECT_PRIVILEGE(p_OBJECT_ID, g_PRIV_EDIT, TRUE);

	--Delete the System Object.
	DELETE SYSTEM_OBJECT
	WHERE OBJECT_ID = p_OBJECT_ID;

END DELETE_SYSTEM_OBJECT;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_HELP_DOCUMENT_NAME
    (
    p_OBJECT_ID IN NUMBER,
	p_HELP_DOCUMENT_NAME OUT VARCHAR2
    ) AS

	v_COUNT NUMBER;
BEGIN

	-- Check if the Object ID is an IO Table
	SELECT COUNT(*) INTO v_COUNT
	FROM SYSTEM_OBJECT
	WHERE object_id = p_OBJECT_ID
		AND OBJECT_CATEGORY = 'IO Table';

	IF v_COUNT > 0 THEN
		SELECT HELP_DOC
		INTO p_HELP_DOCUMENT_NAME
		FROM (SELECT ATTRIBUTE_VAL HELP_DOC
			FROM SYSTEM_OBJECT_ATTRIBUTE
			WHERE OBJECT_ID = p_OBJECT_ID
			AND ATTRIBUTE_ID = -4

			UNION ALL

			SELECT A.ATTRIBUTE_VAL HELP_DOC
			FROM SYSTEM_OBJECT_ATTRIBUTE A, (
				SELECT S.OBJECT_ID, LEVEL AS OBJECT_LEVEL
				FROM SYSTEM_OBJECT S
				START WITH S.OBJECT_ID = p_OBJECT_ID
				CONNECT BY PRIOR S.PARENT_OBJECT_ID = S.OBJECT_ID
				ORDER BY 2) B
			WHERE A.OBJECT_ID = B.OBJECT_ID
			AND A.ATTRIBUTE_ID = -4)
		WHERE ROWNUM = 1;
	ELSE
		SELECT A.ATTRIBUTE_VAL HELP_DOC
		INTO p_HELP_DOCUMENT_NAME
		FROM SYSTEM_OBJECT_ATTRIBUTE A, (
			SELECT S.OBJECT_ID, LEVEL AS OBJECT_LEVEL
			FROM SYSTEM_OBJECT S
			START WITH S.OBJECT_ID = p_OBJECT_ID
			CONNECT BY PRIOR S.PARENT_OBJECT_ID = S.OBJECT_ID
			ORDER BY 2) B
		WHERE A.OBJECT_ID = B.OBJECT_ID
		AND A.ATTRIBUTE_ID = -4
		AND ROWNUM = 1;
	END IF;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		p_HELP_DOCUMENT_NAME := '';


END GET_HELP_DOCUMENT_NAME;
---------------------------------------------------------------------------------------------------
PROCEDURE CONFIGURATION_TREE_TOP
	(
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_CATEGORIES STRING_COLLECTION;
BEGIN

	OPEN p_CURSOR FOR
		SELECT A.OBJECT_ID,
			A.OBJECT_NAME,
			A.OBJECT_CATEGORY,
			CASE WHEN A.OBJECT_DISPLAY_NAME IS NULL OR (A.OBJECT_CATEGORY = 'Column' AND SUBSTR(A.OBJECT_DISPLAY_NAME,1,1) = '=') THEN
				A.OBJECT_NAME
			WHEN UPPER(A.OBJECT_DISPLAY_NAME) <> UPPER(A.OBJECT_NAME) THEN
				A.OBJECT_DISPLAY_NAME||' ('||A.OBJECT_NAME||')'
			ELSE
				A.OBJECT_DISPLAY_NAME
			END AS OBJECT_DISPLAY_NAME,
			A.OBJECT_ORDER,
			L.VALUE AS CHILD_CATEGORY,
			A.OBJECT_ID AS CATEGORY_OBJECT_ID
		FROM SYSTEM_OBJECT A,
			SYSTEM_LABEL L
		WHERE A.PARENT_OBJECT_ID = -1
			AND L.MODEL_ID = 0
			AND L.MODULE = 'System'
			AND L.KEY1 = 'System Objects'
			AND L.KEY2 = 'Allowed Child Objects'
			AND L.KEY3 = 'System' -- Top Parent Category
		ORDER BY OBJECT_ORDER, OBJECT_NAME;

END CONFIGURATION_TREE_TOP;
---------------------------------------------------------------------------------------------------
PROCEDURE CONFIGURATION_TREE
	(
	p_OBJECT_ID IN NUMBER,
	p_CHILD_CATEGORY IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_CHILD_COUNT NUMBER;
v_WORK_ID	 NUMBER;
BEGIN

	SELECT COUNT(L.VALUE)
	INTO v_CHILD_COUNT
	FROM SYSTEM_LABEL L
	WHERE L.MODEL_ID = 0
		AND L.MODULE = 'System'
		AND L.KEY1 = 'System Objects'
		AND L.KEY2 = 'Allowed Child Objects'
		AND L.KEY3 = p_CHILD_CATEGORY;

	v_WORK_ID := ENUMERATE_HIERARCHY(p_OBJECT_ID, 1, FALSE, p_INCLUDED_CATEGORIES => STRING_COLLECTION(p_CHILD_CATEGORY));

	IF v_CHILD_COUNT = 0 THEN
		OPEN p_CURSOR FOR
			SELECT A.OBJECT_ID,
				A.OBJECT_NAME,
				A.OBJECT_CATEGORY,
				CASE WHEN A.OBJECT_DISPLAY_NAME IS NULL OR (A.OBJECT_CATEGORY = 'Column' AND SUBSTR(A.OBJECT_DISPLAY_NAME,1,1) = '=') THEN
					A.OBJECT_NAME
				WHEN UPPER(A.OBJECT_DISPLAY_NAME) <> UPPER(A.OBJECT_NAME) THEN
					A.OBJECT_DISPLAY_NAME||' ('||A.OBJECT_NAME||')'
				ELSE
					A.OBJECT_DISPLAY_NAME
				END AS OBJECT_DISPLAY_NAME,
				A.OBJECT_ORDER,
				1 AS END_RECURSION
			FROM SYSTEM_OBJECT A,
				RTO_WORK W
			WHERE A.PARENT_OBJECT_ID = p_OBJECT_ID
				AND W.WORK_ID = v_WORK_ID
				AND W.WORK_XID = A.OBJECT_ID
			ORDER BY OBJECT_ORDER, OBJECT_NAME;
	ELSE
		OPEN p_CURSOR FOR
			SELECT A.OBJECT_ID,
				A.OBJECT_NAME,
				A.OBJECT_CATEGORY,
				CASE WHEN A.OBJECT_DISPLAY_NAME IS NULL OR (A.OBJECT_CATEGORY = 'Column' AND SUBSTR(A.OBJECT_DISPLAY_NAME,1,1) = '=') THEN
					A.OBJECT_NAME
				WHEN UPPER(A.OBJECT_DISPLAY_NAME) <> UPPER(A.OBJECT_NAME) THEN
					A.OBJECT_DISPLAY_NAME||' ('||A.OBJECT_NAME||')'
				ELSE
					A.OBJECT_DISPLAY_NAME
				END AS OBJECT_DISPLAY_NAME,
				A.OBJECT_ORDER,
				C.OBJECT_CATEGORY AS CHILD_CATEGORY,
				A.OBJECT_ID AS CATEGORY_OBJECT_ID,
				0 AS END_RECURSION
			FROM SYSTEM_OBJECT A,
			    SYSTEM_OBJECT C,
				RTO_WORK W
			WHERE A.PARENT_OBJECT_ID = p_OBJECT_ID
				AND A.OBJECT_ID = C.PARENT_OBJECT_ID
				AND W.WORK_ID = v_WORK_ID
				AND W.WORK_XID = A.OBJECT_ID
			UNION
			SELECT A.OBJECT_ID,
				A.OBJECT_NAME,
				A.OBJECT_CATEGORY,
				CASE WHEN A.OBJECT_DISPLAY_NAME IS NULL OR (A.OBJECT_CATEGORY = 'Column' AND SUBSTR(A.OBJECT_DISPLAY_NAME,1,1) = '=') THEN
					A.OBJECT_NAME
				WHEN UPPER(A.OBJECT_DISPLAY_NAME) <> UPPER(A.OBJECT_NAME) THEN
					A.OBJECT_DISPLAY_NAME||' ('||A.OBJECT_NAME||')'
				ELSE
					A.OBJECT_DISPLAY_NAME
				END AS OBJECT_DISPLAY_NAME,
				A.OBJECT_ORDER,
				L.VALUE AS CHILD_CATEGORY,
				A.OBJECT_ID AS CATEGORY_OBJECT_ID,
				0 AS END_RECURSION
			FROM SYSTEM_OBJECT A,
				RTO_WORK W,
				SYSTEM_LABEL L
			WHERE A.PARENT_OBJECT_ID = p_OBJECT_ID
				AND L.MODEL_ID = 0
				AND L.MODULE = 'System'
				AND L.KEY1 = 'System Objects'
				AND L.KEY2 = 'Allowed Child Objects'
				AND L.KEY3 = CASE WHEN UPPER(A.OBJECT_NAME) = UPPER('Shared') AND A.OBJECT_CATEGORY = 'Module' THEN
								'All'
							WHEN UPPER(A.OBJECT_NAME) = UPPER('ReportRepository') AND A.OBJECT_CATEGORY = 'Module' THEN
							 	'ReportRepository'
							ELSE
								p_CHILD_CATEGORY
							END
				AND W.WORK_ID = v_WORK_ID
				AND W.WORK_XID = A.OBJECT_ID
			ORDER BY OBJECT_ORDER, OBJECT_NAME, CHILD_CATEGORY;
	END IF;

	UT.PURGE_RTO_WORK(v_WORK_ID);

END CONFIGURATION_TREE;
---------------------------------------------------------------------------------------------------
PROCEDURE SEARCH
	(
	p_SEARCH_STRING      IN VARCHAR,
	p_SEARCH_OPTION      IN VARCHAR,
	p_CURSOR             OUT GA.REFCURSOR
	) AS
v_WORK_ID	 NUMBER;
BEGIN
	-- Returns a column named 'TREE_VALUE' in the Find Grid that contains the Formula to the Object
	--  ie. [[0, "Module", 7051, "System View", 7872, "Report", 7873, "Grid", 7875]]

	v_WORK_ID := ENUMERATE_HIERARCHY(0);

	OPEN p_CURSOR FOR
		SELECT A.OBJECT_ID,
			   CASE WHEN A.OBJECT_DISPLAY_NAME IS NULL OR (A.OBJECT_CATEGORY = 'Column' AND SUBSTR(A.OBJECT_DISPLAY_NAME,1,1) = '=') THEN
					A.OBJECT_NAME
				WHEN UPPER(A.OBJECT_DISPLAY_NAME) <> UPPER(A.OBJECT_NAME) THEN
					A.OBJECT_DISPLAY_NAME||' ('||A.OBJECT_NAME||')'
				ELSE
					A.OBJECT_DISPLAY_NAME
				END AS OBJECT_DISPLAY_NAME,
			   A.OBJECT_CATEGORY,
			   B.PATH,
			   REPLACE(B.TREE_VALUE_PATH, '|', ',') AS TREE_VALUE
		FROM SYSTEM_OBJECT A,
		     (SELECT W.WORK_XID AS OBJECT_ID,
			 		 SYS_CONNECT_BY_PATH(REPLACE(WORK_DATA, ' / ', '/'),' / ') AS PATH,
					 '[[0' || SYS_CONNECT_BY_PATH('"' || W.WORK_DATA2 || '",' || W.WORK_XID, '|') || ']]' AS TREE_VALUE_PATH
			  FROM RTO_WORK W
			  START WITH W.WORK_SEQ = 0  -- Start with the first child of the 'System' object
	  		  	AND W.WORK_ID = v_WORK_ID
			  CONNECT BY W.WORK_SEQ = PRIOR W.WORK_XID
	  			AND W.WORK_ID = v_WORK_ID) B
		WHERE A.OBJECT_ID = B.OBJECT_ID
		AND ((p_SEARCH_OPTION = 'By Name' AND A.OBJECT_NAME LIKE p_SEARCH_STRING)
		  OR (p_SEARCH_OPTION = 'By Display Name' AND A.OBJECT_DISPLAY_NAME LIKE p_SEARCH_STRING)
		  OR (p_SEARCH_OPTION = 'By Category' AND A.OBJECT_CATEGORY LIKE p_SEARCH_STRING))
		ORDER BY 3,2;

	UT.PURGE_RTO_WORK(v_WORK_ID);

END SEARCH;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_TREE_VALUE_FOR_OBJECT
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_CHILD_CATEGORY IN VARCHAR2,
	p_TREE_VALUE OUT VARCHAR2
	) AS
v_ROLES	ID_TABLE := ROLES_THAT_CAN_VIEW_OBJECT(p_PARENT_OBJECT_ID);
BEGIN
	-- Returns the TREE_VALUE as a Formula reference to the Object.
	-- The Formula will end with the child category passed in.
	--  ie. [[0, "Module", 7051, "System View", 7872, "Report", 7873, "Grid", 7875, "Column"]]

	IF V_ROLES.COUNT() > 0 AND p_PARENT_OBJECT_ID <> -1 THEN
		SELECT '[[0' || REPLACE(SYS_CONNECT_BY_PATH('"' || S.OBJECT_CATEGORY || '",' || S.OBJECT_ID, '|$%@#'), '|$%@#', ',') || ',"' || p_CHILD_CATEGORY || '"]]' AS PATH
		INTO p_TREE_VALUE
		FROM SYSTEM_OBJECT S
		WHERE S.OBJECT_ID = p_PARENT_OBJECT_ID
		START WITH S.PARENT_OBJECT_ID = 0
		CONNECT BY PRIOR S.OBJECT_ID = S.PARENT_OBJECT_ID;
	END IF;

END GET_TREE_VALUE_FOR_OBJECT;
---------------------------------------------------------------------------------------------------
-- TAKES IN A PATH IN THE FORMAT "Parent Object Category|Parent Object Name/Object Category|Object Name"
-- AND RETURNS THE OBJECT ID FOR THE LAST NODE IN THE PATH
FUNCTION GET_OBJECT_ID_FOR_PATH
	(
	p_OBJECT_PATH IN VARCHAR2
	) RETURN NUMBER IS

	v_PARENT_OBJECT_ID NUMBER(9);
	v_TOKENS STRING_COLLECTION;
	v_ITEM STRING_COLLECTION;

BEGIN

	UT.STRING_COLLECTION_FROM_STRING(p_OBJECT_PATH, '/', v_TOKENS);

	v_PARENT_OBJECT_ID := 0;

	FOR v_IDX IN 1..v_TOKENS.COUNT LOOP
		-- GET THE CURRENT OBJECT CATEGORY AND NAME
		UT.STRING_COLLECTION_FROM_STRING(v_TOKENS(v_IDX), '|', v_ITEM);

		ASSERT(v_ITEM.COUNT = 2, 'The object path must be in the format'
			|| ' "Parent Object Category|Parent Object Name/Object Category|Object Name".',
			MSGCODES.c_ERR_ARGUMENT);

		SO.ID_FOR_SYSTEM_OBJECT(v_PARENT_OBJECT_ID, v_ITEM(2),
			0, v_ITEM(1), 'Default', FALSE, v_PARENT_OBJECT_ID);

		IF v_PARENT_OBJECT_ID = GA.NO_DATA_FOUND THEN
			ERRS.RAISE_BAD_ARGUMENT('OBJECT_PATH', p_OBJECT_PATH,
				'No object was found using the given path.');
		END IF;
	END LOOP;

	RETURN v_PARENT_OBJECT_ID;
END GET_OBJECT_ID_FOR_PATH;
---------------------------------------------------------------------------------------------------
FUNCTION RESOLVE_OBJECT_ID
	(
	p_OBJECT_ID IN NUMBER
	) RETURN NUMBER IS

c_SHARED_OBJ_ATTR_ID	CONSTANT SYSTEM_ATTRIBUTE.ATTRIBUTE_ID%TYPE := -1;

v_SHARED_OBJ	SYSTEM_OBJECT_ATTRIBUTE.ATTRIBUTE_VAL%TYPE;
v_SHARED_OBJ_ID	SYSTEM_OBJECT.OBJECT_ID%TYPE;

BEGIN

	-- see if this object references a shared object
	SELECT MAX(ATTRIBUTE_VAL)
	INTO v_SHARED_OBJ
	FROM SYSTEM_OBJECT_ATTRIBUTE
	WHERE OBJECT_ID = p_OBJECT_ID
		AND ATTRIBUTE_ID = c_SHARED_OBJ_ATTR_ID;

	IF v_SHARED_OBJ IS NOT NULL THEN
		-- look-up shared object ID
		SELECT MAX(SHOBJ.OBJECT_ID)
		INTO v_SHARED_OBJ_ID
		FROM SYSTEM_OBJECT OBJ,
			SYSTEM_OBJECT SHM,
			SYSTEM_OBJECT SHOBJ
		WHERE OBJ.OBJECT_ID = p_OBJECT_ID
			AND SHM.PARENT_OBJECT_ID = 0 -- 'Shared' is a top-level module
			AND UPPER(SHM.OBJECT_NAME) = UPPER('Shared')
			AND SHM.OBJECT_CATEGORY = 'Module'
			AND SHOBJ.PARENT_OBJECT_ID = SHM.OBJECT_ID -- Find object - same category as original object
			AND UPPER(SHOBJ.OBJECT_NAME) = UPPER(v_SHARED_OBJ)
			AND SHOBJ.OBJECT_CATEGORY = OBJ.OBJECT_CATEGORY
			AND ROWNUM=1;

	END IF;

	-- no shared object? then just return specified object ID
	RETURN NVL(v_SHARED_OBJ_ID, p_OBJECT_ID);

END RESOLVE_OBJECT_ID;
---------------------------------------------------------------------------------------------------
FUNCTION GET_ATTRIBUTE_VAL
	(
	p_OBJECT_ID IN NUMBER,
	p_ATTRIBUTE_ID IN NUMBER
	) RETURN VARCHAR2 IS

v_RET		SYSTEM_OBJECT_ATTRIBUTE.ATTRIBUTE_VAL%TYPE;
v_OBJ_ID	SYSTEM_OBJECT.OBJECT_ID%TYPE;

BEGIN

	v_OBJ_ID := RESOLVE_OBJECT_ID(p_OBJECT_ID);

	SELECT MAX(ATTRIBUTE_VAL)
	INTO v_RET
	FROM SYSTEM_OBJECT_ATTRIBUTE
	WHERE OBJECT_ID = v_OBJ_ID
		AND ATTRIBUTE_ID = p_ATTRIBUTE_ID;

	RETURN v_RET;

END GET_ATTRIBUTE_VAL;
---------------------------------------------------------------------------------------------------
PROCEDURE PATH_FOR_OBJECT_ID
	(
	p_OBJECT_ID IN NUMBER,
	p_PATH OUT VARCHAR2
	) AS
	
BEGIN

	SELECT P.PATH
	INTO p_PATH
	FROM (SELECT REVERSE(SYS_CONNECT_BY_PATH(REVERSE(TO_CHAR(O.OBJECT_ID)) || ',"' || REVERSE(O.OBJECT_CATEGORY) || '"','|')) AS PATH, LEVEL
			FROM SYSTEM_OBJECT O
			START WITH O.OBJECT_ID = p_OBJECT_ID
			CONNECT BY O.OBJECT_ID = PRIOR O.PARENT_OBJECT_ID AND O.OBJECT_ID <> 0
			ORDER BY LEVEL DESC) P
	WHERE ROWNUM = 1;

	p_PATH := SUBSTR(p_PATH, 1, LENGTH(p_PATH) -1 ); -- STRING OFF THE TRAILING '|'
	p_PATH := REPLACE(p_PATH, '|', ','); -- REPLACE PIPES WITH COMMAS
	p_PATH := '[[0,' || p_PATH || ']]';

END PATH_FOR_OBJECT_ID;
---------------------------------------------------------------------------------------------------
PROCEDURE PATH_FOR_OBJECT_NAME
	(
	p_PARENT_OBJECT_ID IN NUMBER,
	p_OBJECT_CATEGORY IN VARCHAR2,
	p_OBJECT_NAME IN VARCHAR2,
	p_PATH OUT VARCHAR2
	) AS
	
	v_SHARED_OBJBECT_ID NUMBER(9);
	
BEGIN

	SO.ID_FOR_SYSTEM_OBJECT(p_PARENT_OBJECT_ID,
								p_OBJECT_NAME,
								0,
								p_OBJECT_CATEGORY,
								'Default',
								FALSE,
								v_SHARED_OBJBECT_ID);
								
	PATH_FOR_OBJECT_ID(v_SHARED_OBJBECT_ID, p_PATH);

END PATH_FOR_OBJECT_NAME;
---------------------------------------------------------------------------------------------------
PROCEDURE PATH_FOR_SHARED_OBJECT
	(
	p_SOURCE_OBJECT_ID IN NUMBER,
	p_SHARED_OBJECT_NAME IN VARCHAR2,
	p_PATH OUT VARCHAR2
	) AS
	
	v_SHARED_MODULE_ID NUMBER(9);
	v_OBJECT_CATEGORY SYSTEM_OBJECT.OBJECT_CATEGORY%TYPE;
	
BEGIN

	SELECT OBJECT_ID
	INTO v_SHARED_MODULE_ID
	FROM SYSTEM_OBJECT
	WHERE PARENT_OBJECT_ID = 0
		AND UPPER(OBJECT_NAME) = UPPER('Shared')
		AND OBJECT_CATEGORY = 'Module'
		AND ROWNUM = 1;
	
	SELECT SO.OBJECT_CATEGORY
	INTO v_OBJECT_CATEGORY
	FROM SYSTEM_OBJECT SO
	WHERE SO.OBJECT_ID = p_SOURCE_OBJECT_ID;
		
	PATH_FOR_OBJECT_NAME(v_SHARED_MODULE_ID, 
						v_OBJECT_CATEGORY,
						p_SHARED_OBJECT_NAME,
						p_PATH);

END PATH_FOR_SHARED_OBJECT;
---------------------------------------------------------------------------------------------------
END SO;
/
