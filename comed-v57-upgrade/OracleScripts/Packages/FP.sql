CREATE OR REPLACE PACKAGE FP AS
--Revision $Revision: 1.51 $

-- Forecasting Profile And Service Validation Package

FUNCTION WHAT_VERSION RETURN VARCHAR;

PROCEDURE RELEASE_COMPOSITE_PROFILE;

PROCEDURE RELEASE_SETTLEMENT;

PROCEDURE RELEASE_SETTLEMENT_STATS;

FUNCTION GET_PROFILE_INTERVAL
	(
	p_PROFILE_ID IN NUMBER
	) RETURN NUMBER;

FUNCTION COPY_PROFILE
	(
	p_PROFILE IN GA.NUMBER_TABLE
	) RETURN GA.NUMBER_TABLE;

PROCEDURE SIMILAR_DAY_TYPE
	(
	p_EDC_ID IN NUMBER,
	p_FORECAST_DATE IN DATE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_HISTORICAL_DATE OUT DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE COMPOSITE_PROFILE_FOR_CALENDAR
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_STATION_ID IN NUMBER,
	p_CALENDAR_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_POST_TO_APP_EVENT_LOG IN BOOLEAN,
	p_PROFILE_TYPE OUT CHAR,
	p_PROFILE_SOURCE_DATE OUT DATE,
	p_COMPOSITE_PROFILE IN OUT NOCOPY GA.NUMBER_TABLE
	);

PROCEDURE COMPOSITE_PROFILE_TO_CACHE
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_STATION_ID IN NUMBER,
	p_CALENDAR_ID IN NUMBER,
	p_PROFILE_TYPE IN CHAR,
	p_PROFILE_SOURCE_DATE IN DATE,
	p_COMPOSITE_PROFILE IN GA.NUMBER_TABLE
	);

FUNCTION COMPOSITE_PROFILE_FROM_CACHE
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_STATION_ID IN NUMBER,
	p_CALENDAR_ID IN NUMBER,
	p_PROFILE_TYPE OUT CHAR,
	p_PROFILE_SOURCE_DATE OUT DATE,
	p_COMPOSITE_PROFILE IN OUT NOCOPY GA.NUMBER_TABLE
	) RETURN BOOLEAN;

PROCEDURE CACHE_PROXY_DAY_METHODS
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_PROXY_DAY_METHOD_IDs IN ID_TABLE
	);

PROCEDURE ACTUAL_USAGE_PROFILE
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_ACCOUNT_SERVICE_ID IN NUMBER,
	p_PROVIDER_SERVICE_ID IN NUMBER,
	p_CALENDAR_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_HAS_PROXY_PROFILE OUT BOOLEAN,
	p_PROFILE_SOURCE_DATE OUT DATE,
	p_PROFILE IN OUT NOCOPY GA.NUMBER_TABLE
	);

PROCEDURE PROXY_USAGE_PROFILE
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_PROXY_DAY_METHOD_ID IN NUMBER,
	p_HOLIDAY_SET_ID IN NUMBER,
	p_ACCOUNT_SERVICE_ID IN NUMBER,
	p_PROVIDER_SERVICE_ID IN NUMBER,
	p_CALENDAR_ID IN NUMBER,
	p_HAS_PROXY_PROFILE OUT BOOLEAN,
	p_PROFILE_SOURCE_DATE OUT DATE,
	p_PROFILE IN OUT NOCOPY GA.NUMBER_TABLE
	);

PROCEDURE MONITOR_MODEL
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PROFILE_AS_OF_DATE IN DATE,
	p_USAGE_AS_OF_DATE IN DATE
	);

FUNCTION SETTLEMENT_PROFILE_EXISTS
	(
	p_PROFILE_ID IN NUMBER
	) RETURN BOOLEAN;

PROCEDURE ASSIGN_SETTLEMENT_PROFILE
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_PROFILE_ID IN NUMBER,
	p_USAGE_FACTOR IN NUMBER,
	p_PROFILE IN OUT NOCOPY GA.NUMBER_TABLE
	);

PROCEDURE GET_SETTLEMENT_PROFILE
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_PROFILE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PROFILE IN OUT NOCOPY USAGE_TABLE
	);

FUNCTION GET_ACCOUNT_CALENDAR_ID
	(
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_CALENDAR_TYPE IN VARCHAR
	) RETURN NUMBER;

FUNCTION GET_METER_CALENDAR_ID
	(
	p_METER_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_CALENDAR_TYPE IN VARCHAR
	) RETURN NUMBER;

FUNCTION GET_PROFILE_ID
	(
	p_ACCOUNT_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_CALENDAR_TYPE IN CHAR
	) RETURN NUMBER;

PROCEDURE STORE_SETTLEMENT_PROFILE
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE
	);

PROCEDURE SET_SETTLEMENT_PROFILE_STATS
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_PROFILE_AS_OF_DATE IN DATE
	);

PROCEDURE SETTLEMENT_PROFILE_SETUP
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE
	);

PROCEDURE DELETE_SETTLEMENT_PROFILE
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE
	);

PROCEDURE PUT_VALIDATION_BEST_FIT
	(
	p_SERVICE_DATE IN DATE
	);

PROCEDURE GET_SERVICE_VALIDATION
	(
	p_MODEL_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_REQUEST_TYPE IN VARCHAR,
	p_ESP_IDS IN VARCHAR
	);

PROCEDURE GET_LOAD_PROFILE_POINTS
	(
	p_PROFILE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ALL_DATES IN NUMBER := 0,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_POINT_INDEX IN NUMBER := 1,
	p_ALL_INDEXES IN NUMBER := 0,
	p_DAY_SELECTION IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PUT_LOAD_PROFILE_STATISTICS
	(
	p_PROFILE_ID IN NUMBER,
	p_POINT_INDEX IN NUMBER,
	p_PROFILE_AS_OF_DATE IN DATE
	);

FUNCTION GET_INTERVAL_FOR_CALENDAR
	(
	p_CALENDAR_ID IN NUMBER,
	p_DAY IN DATE
	) RETURN VARCHAR2;

FUNCTION GET_INTERVAL_FOR_ACCOUNT
	(
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_CALENDAR_TYPE IN VARCHAR2 := 'Forecast'
	) RETURN VARCHAR2;

FUNCTION GET_INTERVAL_FOR_METER
	(
	p_METER_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_CALENDAR_TYPE IN VARCHAR2 := 'Forecast'
	) RETURN VARCHAR2;

PROCEDURE ADJUST_TO_STANDARD_PROFILE
	(
	p_PROFILE IN OUT NOCOPY GA.NUMBER_TABLE
	);

--CONSTANTS
g_OFF CONSTANT NUMBER(1) := 0;
g_ON CONSTANT NUMBER(1) := 1;
g_DOMAIN_NAME CONSTANT VARCHAR2(32) := 'Forecasting';
g_LOW_DATE CONSTANT DATE := LOW_DATE;
g_SECOND CONSTANT NUMBER(6,5) :=  .00001;
g_DEFAULT_POINT_INDEX CONSTANT NUMBER(1) := 1;
g_BIG_VAL CONSTANT NUMBER := 9999999999;

g_ACTUAL_USAGE_PROFILE CONSTANT CHAR(1) := 'A';
g_HISTORICAL_PROFILE CONSTANT CHAR(1) := 'H';
g_INDEXED_PROFILE CONSTANT CHAR(1) := 'I';
g_WRF_PROFILE CONSTANT CHAR(1) := 'W';
g_TYPICAL_PROFILE CONSTANT CHAR(1) := 'T';
g_COMPOSITE_PROFILE CONSTANT CHAR(1) := 'C';
g_USAGE_WRF_PROFILE CONSTANT CHAR(1) := 'R';
g_EXTERNAL_PROFILE CONSTANT CHAR(1) := 'E';
g_ZERO_PROFILE CONSTANT CHAR(1) := 'Z';

--VARIABLES
g_OBJECT_NAME CALENDAR.CALENDAR_NAME%TYPE; -- For the calendar name
g_EVENT_TEXT VARCHAR(512);

TYPE VARIANCE_RULE_RECORD IS RECORD(PERCENT NUMBER(8,4), MAGNITUDE NUMBER(14,4));
TYPE VARIANCE_RULE_TABLE IS TABLE OF VARIANCE_RULE_RECORD INDEX BY BINARY_INTEGER;

TYPE INTEGER_COLLECTION IS TABLE OF NUMBER(9)  INDEX BY BINARY_INTEGER;
TYPE DATE_TABLE IS TABLE OF DATE  INDEX BY BINARY_INTEGER;
TYPE FLOAT_COLLECTION IS TABLE OF NUMBER INDEX BY BINARY_INTEGER;

-- Settlement Profile daily accumulation global area.
g_POINT_PROFILE_ID INTEGER_COLLECTION;
g_POINT_DATE DATE_TABLE;
g_POINT_VAL FLOAT_COLLECTION;
g_SETTLEMENT_PROFILE GA.BOOLEAN_TABLE;
g_SETTLEMENT_PROFILE_STATS GA.BOOLEAN_TABLE;

g_ACCOUNT_USAGE ACCOUNT_USAGE_TABLE := ACCOUNT_USAGE_TABLE();
TYPE ACCOUNT_USAGE_INDEX_RECORD IS RECORD(BEGIN_POS PLS_INTEGER, END_POS PLS_INTEGER);
TYPE ACCOUNT_USAGE_INDEX_TABLE IS TABLE OF ACCOUNT_USAGE_INDEX_RECORD INDEX BY BINARY_INTEGER;
g_ACCOUNT_USAGE_INDEX ACCOUNT_USAGE_INDEX_TABLE;

-- Calendar Composite Profile Cache.
TYPE COMPOSITE_PROFILE_INDEX_RECORD IS RECORD (CALENDAR_ID BINARY_INTEGER, STATION_ID BINARY_INTEGER, PROFILE_TYPE CHAR(1), PROFILE_SOURCE_DATE DATE, START_POS BINARY_INTEGER, STOP_POS BINARY_INTEGER);
TYPE COMPOSITE_PROFILE_INDEX_TABLE IS TABLE OF COMPOSITE_PROFILE_INDEX_RECORD INDEX BY BINARY_INTEGER;
g_COMPOSITE_PROFILE_INDEX COMPOSITE_PROFILE_INDEX_TABLE;
g_COMPOSITE_PROFILE_CACHE FLOAT_COLLECTION;

END FP;
/
CREATE OR REPLACE PACKAGE BODY FP AS
----------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
    RETURN '$Revision: 1.51 $';
END WHAT_VERSION;
--------------------------------------------------------------------------------------------------
PROCEDURE RELEASE_COMPOSITE_PROFILE AS
BEGIN
	g_COMPOSITE_PROFILE_INDEX.DELETE;
	g_COMPOSITE_PROFILE_CACHE.DELETE;
END RELEASE_COMPOSITE_PROFILE;
---------------------------------------------------------------------------------------------------
PROCEDURE RELEASE_SETTLEMENT AS
BEGIN
	g_POINT_PROFILE_ID.DELETE;
	g_POINT_DATE.DELETE;
	g_POINT_VAL.DELETE;
	g_SETTLEMENT_PROFILE.DELETE;
END RELEASE_SETTLEMENT;
----------------------------------------------------------------------------------------------------
PROCEDURE RELEASE_SETTLEMENT_STATS AS
BEGIN
	g_SETTLEMENT_PROFILE_STATS.DELETE;
END RELEASE_SETTLEMENT_STATS;
----------------------------------------------------------------------------------------------------
FUNCTION GET_PROFILE_STATUS
	(
	p_PROFILE_ID IN NUMBER,
	p_AS_OF_DATE IN DATE
	) RETURN VARCHAR IS

-- Answer the profile status of the associated profile id.

v_PROFILE_STATUS LOAD_PROFILE_STATISTICS.PROFILE_STATUS%TYPE;

BEGIN

	SELECT UPPER(PROFILE_STATUS)
	INTO v_PROFILE_STATUS
	FROM LOAD_PROFILE_STATISTICS
	WHERE PROFILE_ID = p_PROFILE_ID
		AND AS_OF_DATE = p_AS_OF_DATE;

	RETURN v_PROFILE_STATUS;

 	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN 'NOT_FOUND';

END GET_PROFILE_STATUS;
----------------------------------------------------------------------------------------------------
FUNCTION GET_PROFILE_INTERVAL
	(
	p_PROFILE_ID IN NUMBER
	) RETURN NUMBER IS

-- Answer the profile status of the associated profile id.

v_PROFILE_INTERVAL LOAD_PROFILE.PROFILE_INTERVAL%TYPE;

BEGIN

	SELECT PROFILE_INTERVAL
	INTO v_PROFILE_INTERVAL
	FROM LOAD_PROFILE
	WHERE PROFILE_ID = p_PROFILE_ID;

	RETURN v_PROFILE_INTERVAL;

 	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN 24;

END GET_PROFILE_INTERVAL;
----------------------------------------------------------------------------------------------------
FUNCTION GET_PROFILE_VERSION_ID
	(
	p_AS_OF_DATE IN DATE
	) RETURN NUMBER IS

v_VERSION_ID NUMBER;

BEGIN

	SELECT VERSION_ID
	INTO v_VERSION_ID
	FROM VERSION
	WHERE UPPER(VERSION_DOMAIN) = 'PROFILING'
		AND AS_OF_DATE = p_AS_OF_DATE;

	RETURN v_VERSION_ID;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN CONSTANTS.NOT_ASSIGNED;

END GET_PROFILE_VERSION_ID;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_PROFILE_FROM_TO_DATES
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_PROFILE_ID IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_FROM_DATE OUT DATE,
	p_TO_DATE OUT DATE,
	p_STATUS OUT NUMBER
	) AS

-- Answer the profile from and to dates of the associated profile id.

BEGIN

	p_STATUS := GA.SUCCESS;

	SELECT TRUNC(A.FROM_DATE), TRUNC(A.TO_DATE)
	INTO p_FROM_DATE, p_TO_DATE
	FROM LOAD_PROFILE_STATISTICS A
	WHERE A.PROFILE_ID = p_PROFILE_ID
		AND A.AS_OF_DATE = p_AS_OF_DATE;

 	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_STATUS := GA.NO_DATA_FOUND;
			g_OBJECT_NAME := FW.GET_PROFILE_NAME(p_PROFILE_ID);
			g_EVENT_TEXT := 'No Statistics for Historical Load Profile ' || g_OBJECT_NAME;
			ERRS.LOG_AND_CONTINUE(p_EXTRA_MESSAGE => g_EVENT_TEXT);
 		WHEN OTHERS THEN
			p_STATUS := SQLCODE;

END GET_PROFILE_FROM_TO_DATES;
----------------------------------------------------------------------------------------------------
FUNCTION GET_CALENDAR_NAME
	(
	p_CALENDAR_ID IN NUMBER
	) RETURN VARCHAR IS

-- Answer the calendar name of the associated calendar id.

v_CALENDAR_NAME CALENDAR.CALENDAR_NAME%TYPE;

BEGIN

	SELECT CALENDAR_NAME
	INTO v_CALENDAR_NAME
	FROM CALENDAR
	WHERE CALENDAR_ID = p_CALENDAR_ID
		AND ROWNUM = 1;

	RETURN v_CALENDAR_NAME;

 	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN '';

END GET_CALENDAR_NAME;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_CALENDAR
	(
	p_ACCOUNT_ID IN NUMBER,
	p_CALENDAR_ID IN NUMBER,
	p_CALENDAR_TYPE IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	) AS

BEGIN

	UPDATE ACCOUNT_CALENDAR
	SET	END_DATE = p_END_DATE,
		ENTRY_DATE = SYSDATE
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND CALENDAR_ID = p_CALENDAR_ID
		AND BEGIN_DATE = TRUNC(p_BEGIN_DATE);

	IF SQL%NOTFOUND THEN
		INSERT INTO ACCOUNT_CALENDAR (
			CASE_ID,
			ACCOUNT_ID,
			CALENDAR_ID,
			CALENDAR_TYPE,
			BEGIN_DATE,
			END_DATE,
			ENTRY_DATE)
		VALUES (
			GA.BASE_CASE_ID,
			p_ACCOUNT_ID,
			p_CALENDAR_ID,
			p_CALENDAR_TYPE,
			p_BEGIN_DATE,
			p_END_DATE,
			SYSDATE);
	END IF;

END PUT_ACCOUNT_CALENDAR;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_METER_CALENDAR
	(
	p_METER_ID IN NUMBER,
	p_CALENDAR_ID IN NUMBER,
	p_CALENDAR_TYPE IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	) AS

BEGIN

	UPDATE METER_CALENDAR
	SET	END_DATE = p_END_DATE,
		ENTRY_DATE = SYSDATE
	WHERE CASE_ID = GA.BASE_CASE_ID
	   AND METER_ID = p_METER_ID
		AND CALENDAR_ID = p_CALENDAR_ID
		AND BEGIN_DATE = TRUNC(p_BEGIN_DATE);

	IF SQL%NOTFOUND THEN
		INSERT INTO METER_CALENDAR (
			CASE_ID,
			METER_ID,
			CALENDAR_ID,
			CALENDAR_TYPE,
			BEGIN_DATE,
			END_DATE,
			ENTRY_DATE)
		VALUES (
			GA.BASE_CASE_ID,
			p_METER_ID,
			p_CALENDAR_ID,
			p_CALENDAR_TYPE,
			p_BEGIN_DATE,
			p_END_DATE,
			SYSDATE);
	END IF;

END PUT_METER_CALENDAR;
----------------------------------------------------------------------------------------------------
FUNCTION COPY_PROFILE
	(
	p_PROFILE IN GA.NUMBER_TABLE
	) RETURN GA.NUMBER_TABLE IS

v_PROFILE GA.NUMBER_TABLE;
v_INDEX BINARY_INTEGER;

BEGIN

	v_INDEX := p_PROFILE.FIRST;
	WHILE v_INDEX <= p_PROFILE.LAST LOOP
		v_PROFILE(v_INDEX) := p_PROFILE(v_INDEX);
		v_INDEX := p_PROFILE.NEXT(v_INDEX);
	END LOOP;

	RETURN v_PROFILE;

END COPY_PROFILE;
----------------------------------------------------------------------------------------------------
PROCEDURE TRACE_TABLE
	(
	p_NAME IN VARCHAR,
	p_TABLE IN GA.NUMBER_TABLE
	) AS

v_INDEX BINARY_INTEGER;

BEGIN

	LOGS.LOG_DEBUG('TRACE ' || p_NAME || ',<point>@<index>');

	FOR v_INDEX IN p_TABLE.FIRST..p_TABLE.LAST LOOP
		IF p_TABLE.EXISTS(v_INDEX) THEN
			LOGS.LOG_DEBUG(TO_CHAR(p_TABLE(v_INDEX)) || '@' || TO_CHAR(v_INDEX));
		END IF;
	END LOOP;

END TRACE_TABLE;
---------------------------------------------------------------------------------------------------
PROCEDURE TRACE_ACCOUNT_USAGE_CACHE AS

v_ACCOUNT_SERVICE_INDEX BINARY_INTEGER;
v_INDEX BINARY_INTEGER;

BEGIN

	LOGS.LOG_DEBUG('TRACE_ACCOUNT_USAGE');
	LOGS.LOG_DEBUG('ACCOUNT_USAGE.COUNT=' || TO_CHAR(g_ACCOUNT_USAGE.COUNT));
	LOGS.LOG_DEBUG('ACCOUNT_USAGE_INDEX.COUNT=' || TO_CHAR(g_ACCOUNT_USAGE_INDEX.COUNT));

	IF g_ACCOUNT_USAGE_INDEX.COUNT > 0 THEN
		v_ACCOUNT_SERVICE_INDEX := g_ACCOUNT_USAGE_INDEX.FIRST;
		WHILE v_ACCOUNT_SERVICE_INDEX <= g_ACCOUNT_USAGE_INDEX.LAST LOOP
			LOGS.LOG_DEBUG('ACCOUNT_SERVICE_ID=' || TO_CHAR(v_ACCOUNT_SERVICE_INDEX));
			LOGS.LOG_DEBUG('BEGIN_POS=' || TO_CHAR(g_ACCOUNT_USAGE_INDEX(v_ACCOUNT_SERVICE_INDEX).BEGIN_POS));
			LOGS.LOG_DEBUG('END_POS=' || TO_CHAR(g_ACCOUNT_USAGE_INDEX(v_ACCOUNT_SERVICE_INDEX).END_POS));
			FOR v_INDEX IN g_ACCOUNT_USAGE_INDEX(v_ACCOUNT_SERVICE_INDEX).BEGIN_POS..g_ACCOUNT_USAGE_INDEX(v_ACCOUNT_SERVICE_INDEX).END_POS LOOP
				IF g_ACCOUNT_USAGE.EXISTS(v_INDEX) THEN
					LOGS.LOG_DEBUG(UT.TRACE_DATE(g_ACCOUNT_USAGE(v_INDEX).USAGE_DATE) || ',' || TO_CHAR(g_ACCOUNT_USAGE(v_INDEX).USAGE_VAL));
				END IF;
			END LOOP;
			v_ACCOUNT_SERVICE_INDEX := g_ACCOUNT_USAGE_INDEX.NEXT(v_ACCOUNT_SERVICE_INDEX);
		END LOOP;
	END IF;

END TRACE_ACCOUNT_USAGE_CACHE;
---------------------------------------------------------------------------------------------------
FUNCTION DAY_IN_YEAR
	(
	p_DATE IN DATE
	) RETURN NUMBER IS

-- Answer the day position within the year. Normalize for leap year.

v_DAY NUMBER;

BEGIN

	v_DAY := TO_NUMBER(TO_CHAR(p_DATE, 'DDD'));
	IF MOD(TO_NUMBER(TO_CHAR(p_DATE,'YYYY')), 4) = 0 AND v_DAY > 59 THEN
		v_DAY := v_DAY - 1;
	END IF;

	RETURN 	v_DAY;

END DAY_IN_YEAR;
----------------------------------------------------------------------------------------------------
PROCEDURE CLOSEST_DAY_TYPE
	(
	p_EDC_ID IN NUMBER,
	p_FORECAST_DATE IN DATE,
	p_HISTORICAL_DATE IN DATE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TARGET_DAY_TYPE IN CHAR,
	p_CLOSEST_DATE OUT DATE
	) AS

-- Answer a date that is the closest day in a historical period that is not a holiday.

v_DAY PLS_INTEGER;
v_BACK_DAY PLS_INTEGER;
v_FORWARD_DAY PLS_INTEGER;
v_BACK_DATE DATE;
v_FORWARD_DATE DATE;

BEGIN

-- Look forward and backward a week and determine the closest day type in terms of absolute day distance from the forecast date.
-- Make certain that a holiday is not selected in both directions.

	v_DAY := DAY_IN_YEAR(p_FORECAST_DATE);
	v_BACK_DATE := NEXT_DAY(p_HISTORICAL_DATE - 8, p_TARGET_DAY_TYPE); -- Back up for the prior day type.
	IF v_BACK_DATE < p_BEGIN_DATE THEN -- We backed up too far
		v_BACK_DATE := NEXT_DAY(p_BEGIN_DATE - 1, p_TARGET_DAY_TYPE);
	ELSIF v_BACK_DATE > p_END_DATE THEN -- The forecast date was nowhere near the begin and end dates.
		v_BACK_DATE := NEXT_DAY(p_END_DATE - 7, p_TARGET_DAY_TYPE);
	END IF;
	v_BACK_DAY := DAY_IN_YEAR(v_BACK_DATE);

	v_FORWARD_DATE := NEXT_DAY(p_HISTORICAL_DATE, p_TARGET_DAY_TYPE); -- Forward for the next day type.
	IF v_FORWARD_DATE > p_END_DATE THEN -- We went forward too far
		v_FORWARD_DATE := NEXT_DAY(p_END_DATE - 7, p_TARGET_DAY_TYPE);
	ELSIF v_FORWARD_DATE < p_BEGIN_DATE THEN -- The forecast date was nowhere near the begin and end dates.
		v_FORWARD_DATE := NEXT_DAY(p_BEGIN_DATE - 1, p_TARGET_DAY_TYPE);
	END IF;
	v_FORWARD_DAY := DAY_IN_YEAR(v_FORWARD_DATE);

	IF v_FORWARD_DAY < 10 AND v_DAY > 355 THEN
	   v_FORWARD_DAY := v_FORWARD_DAY + DAY_IN_YEAR(LAST_DAY(p_FORECAST_DATE));
	END IF;

	IF ABS(v_DAY - v_BACK_DAY) < ABS(v_DAY - v_FORWARD_DAY) THEN -- Use the date closest to the target date.
		p_CLOSEST_DATE := v_BACK_DATE;
	ELSE
		p_CLOSEST_DATE := v_FORWARD_DATE;
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('CLOSEST_DAY_TYPE');
		LOGS.LOG_DEBUG('EDC_ID=' || TO_CHAR(p_EDC_ID));
		LOGS.LOG_DEBUG('FORECAST_DATE=' || UT.TRACE_DATE(p_FORECAST_DATE));
		LOGS.LOG_DEBUG('HISTORICAL_DATE=' || UT.TRACE_DATE(p_HISTORICAL_DATE));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || UT.TRACE_DATE(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || UT.TRACE_DATE(p_END_DATE));
		LOGS.LOG_DEBUG('TARGET_DAY_TYPE=' || p_TARGET_DAY_TYPE);
		LOGS.LOG_DEBUG('BACK_DATE=' || UT.TRACE_DATE(v_BACK_DATE) || ', BACK_DAY=' || TO_CHAR(v_BACK_DAY));
		LOGS.LOG_DEBUG('FORWARD_DATE=' || UT.TRACE_DATE(v_FORWARD_DATE) || ', FORWARD_DAY=' || TO_CHAR(v_FORWARD_DAY));
		LOGS.LOG_DEBUG('CLOSEST_DATE=' || UT.TRACE_DATE(p_CLOSEST_DATE));
	END IF;

	--AVOID DST DAYS AND HOLIDAYS
	IF HOLIDAY_DAY_TYPE(p_CLOSEST_DATE, TO_CHAR(v_BACK_DATE,'YYYY'), p_EDC_ID) IS NULL
			AND (NOT TRUNC(DST_FALL_BACK_DATE(p_CLOSEST_DATE)) = TRUNC(p_CLOSEST_DATE))
			AND (NOT TRUNC(DST_SPRING_AHEAD_DATE(p_CLOSEST_DATE)) = TRUNC(p_CLOSEST_DATE)) THEN
		RETURN;
	END IF;

	IF p_CLOSEST_DATE = v_BACK_DATE OR HOLIDAY_DAY_TYPE(v_BACK_DATE, TO_CHAR(v_BACK_DATE,'YYYY'), p_EDC_ID) IS NOT NULL THEN
		v_BACK_DATE := v_BACK_DATE - 7; -- Back up a week.
		IF HOLIDAY_DAY_TYPE(v_BACK_DATE, TO_CHAR(v_BACK_DATE,'YYYY'), p_EDC_ID) IS NOT NULL THEN -- Historical back date is a holiday.
			v_BACK_DATE := v_BACK_DATE - 7; -- Back up another week.
		END IF;
	END IF;

	IF v_BACK_DATE < p_BEGIN_DATE THEN
		v_BACK_DATE := NEXT_DAY(p_END_DATE - 7, p_TARGET_DAY_TYPE);
	END IF;
	v_BACK_DAY := DAY_IN_YEAR(v_BACK_DATE);

	IF p_CLOSEST_DATE = v_FORWARD_DATE OR HOLIDAY_DAY_TYPE(v_FORWARD_DATE, TO_CHAR(v_FORWARD_DATE,'YYYY'), p_EDC_ID) IS NOT NULL THEN
		 v_FORWARD_DATE := v_FORWARD_DATE + 7; -- Foreward a week.
		IF HOLIDAY_DAY_TYPE(v_FORWARD_DATE, TO_CHAR(v_FORWARD_DATE,'YYYY'), p_EDC_ID) IS NOT NULL THEN -- Historical forward date is a holiday.
			v_FORWARD_DATE := v_FORWARD_DATE + 7; -- Foreward another week.
		END IF;
	END IF;

	IF v_FORWARD_DATE > p_END_DATE THEN
		v_FORWARD_DATE := NEXT_DAY(p_BEGIN_DATE, p_TARGET_DAY_TYPE);
	END IF;
	v_FORWARD_DAY := DAY_IN_YEAR(v_FORWARD_DATE);

	IF v_FORWARD_DAY < 10 AND v_DAY > 355 THEN
	   v_FORWARD_DAY := v_FORWARD_DAY + DAY_IN_YEAR(LAST_DAY(p_FORECAST_DATE));
	END IF;


	IF ABS(v_DAY - v_BACK_DAY) < ABS(v_DAY - v_FORWARD_DAY) THEN -- Use the date closest to the target date.
		p_CLOSEST_DATE := v_BACK_DATE;
	ELSE
		p_CLOSEST_DATE := v_FORWARD_DATE;
	END IF;

-- Make certain the date falls within the historical period. Coerce if necessary.

	IF p_CLOSEST_DATE > p_END_DATE THEN
		p_CLOSEST_DATE := NEXT_DAY(p_END_DATE - 7, p_TARGET_DAY_TYPE);
	ELSIF p_CLOSEST_DATE < p_BEGIN_DATE THEN
		p_CLOSEST_DATE := NEXT_DAY(p_BEGIN_DATE - 1, p_TARGET_DAY_TYPE);
	ELSIF p_CLOSEST_DATE NOT BETWEEN p_BEGIN_DATE AND p_END_DATE THEN
		p_CLOSEST_DATE := NULL;
		g_EVENT_TEXT := 'Historical Load Profile Date Range Inconsistency.';
		LOGS.LOG_ERROR(g_EVENT_TEXT);
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('CLOSEST DAY IS A HOLIDAY');
		LOGS.LOG_DEBUG('BACK_DATE=' || UT.TRACE_DATE(v_BACK_DATE) || ', BACK_DAY=' || TO_CHAR(v_BACK_DAY));
		LOGS.LOG_DEBUG('FORWARD_DATE=' || UT.TRACE_DATE(v_FORWARD_DATE) || ', FORWARD_DAY=' || TO_CHAR(v_FORWARD_DAY));
		LOGS.LOG_DEBUG('CLOSEST_DATE=' || UT.TRACE_DATE(p_CLOSEST_DATE));
	END IF;

END CLOSEST_DAY_TYPE;
----------------------------------------------------------------------------------------------------
PROCEDURE SIMILAR_DAY_TYPE
	(
	p_EDC_ID IN NUMBER,
	p_FORECAST_DATE IN DATE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_HISTORICAL_DATE OUT DATE,
	p_STATUS OUT NUMBER
	) AS

-- Answer a date that is the closest day in a historical period that
-- is the same day type as the day type of the forecast period date.
-- Check for the occurrence of a holiday and return a pre-defined entry.

v_HISTORICAL_YEAR CHAR(4);
v_TARGET_DAY_TYPE VARCHAR(9);
v_DAY PLS_INTEGER;
v_BEGIN_YEAR PLS_INTEGER;
v_END_YEAR PLS_INTEGER;
v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

	p_STATUS := GA.SUCCESS;

-- If the actual historical period contains the forecast date, then answer the forecast date as the historical date.
	IF p_FORECAST_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE THEN
		p_HISTORICAL_DATE := p_FORECAST_DATE;
		RETURN;
	END IF;

	v_BEGIN_DATE := p_BEGIN_DATE;
	v_BEGIN_YEAR := TO_NUMBER(TO_CHAR(v_BEGIN_DATE,'YYYY'));
	v_END_DATE := p_END_DATE;
	v_END_YEAR := TO_NUMBER(TO_CHAR(v_END_DATE,'YYYY'));

    -- If the historical period is less than one year, don't forecast outside that range
    IF (v_END_YEAR - v_BEGIN_YEAR > 1) OR
     (v_END_YEAR > v_BEGIN_YEAR AND DAY_IN_YEAR(v_END_DATE) > DAY_IN_YEAR(v_BEGIN_DATE)) THEN
       NULL; -- COVERS MORE THAN A YEAR, CONTINUE AS NORMAL
    ELSE

        IF v_BEGIN_YEAR = v_END_YEAR THEN
            IF DAY_IN_YEAR(p_FORECAST_DATE) BETWEEN DAY_IN_YEAR(v_BEGIN_DATE) AND DAY_IN_YEAR(v_END_DATE) THEN
                NULL; -- INSIDE AVAILABLE DATE RANGE, CONTINUE AS NORMAL

            ELSE
                  p_STATUS := GA.INVALID_DATE_RANGE;
                  RETURN;  -- NOT IN AVAILABLE DATE RANGE, RETURN AND FORECAST 0

            END IF;

        ELSE
              IF DAY_IN_YEAR(p_FORECAST_DATE) BETWEEN DAY_IN_YEAR(v_END_DATE) AND 365 THEN
                 NULL; -- INSIDE DATE RANGE, CONTINUE AS NORMAL

              ELSIF DAY_IN_YEAR(p_FORECAST_DATE) BETWEEN 1 AND DAY_IN_YEAR(v_BEGIN_DATE) THEN
                 NULL; -- INSIDE DATE RANGE, CONTINUE AS NORMAL

              ELSE
                p_STATUS := GA.INVALID_DATE_RANGE;
                RETURN;  -- NOT IN AVAILABLE DATE RANGE, RETURN AND FORECAST 0

              END IF;
        END IF;
    END IF; -- END less than year process logic


	IF v_BEGIN_YEAR = v_END_YEAR THEN
		v_HISTORICAL_YEAR := v_BEGIN_YEAR;
	ELSE
		v_DAY := DAY_IN_YEAR(p_FORECAST_DATE);
		IF v_END_YEAR - v_BEGIN_YEAR > 1 THEN
			v_BEGIN_DATE := TO_DATE('1-JAN-' || TO_CHAR(v_END_YEAR - 1),'DD-MON-YYYY');
		END IF;
		v_BEGIN_YEAR := v_END_YEAR - 1;
		IF v_DAY BETWEEN 1 AND DAY_IN_YEAR(v_END_DATE) THEN
			v_HISTORICAL_YEAR := v_END_YEAR;
		ELSIF v_DAY BETWEEN DAY_IN_YEAR(v_BEGIN_DATE) AND 365 THEN
			v_HISTORICAL_YEAR := v_BEGIN_YEAR;
		ELSE
			p_HISTORICAL_DATE := NULL;
			p_STATUS := GA.INVALID_DATE_RANGE;
			RETURN;
		END IF;
	END IF;

	-- Determine whether this is a holiday and return the corresponding holiday date if so.
	p_HISTORICAL_DATE := HOLIDAY_DAY_TYPE(p_FORECAST_DATE, v_HISTORICAL_YEAR, p_EDC_ID);

	-- If this is a holiday, but it's not in the range, then give up and just find
	-- a similar day.
	IF p_HISTORICAL_DATE IS NOT NULL AND NOT p_HISTORICAL_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE THEN
		p_HISTORICAL_DATE := NULL;
		g_EVENT_TEXT := 'Holiday for ' || TO_CHAR(p_FORECAST_DATE,'DD-MON-YYYY') || 'not found in date range ' || UT.TRACE_DATE(v_BEGIN_DATE) || ' and ' ||UT.TRACE_DATE(v_END_DATE) || ' so a non-holiday day was substitued.';
		LOGS.LOG_WARN(g_EVENT_TEXT);
	END IF;

 	-- If historical date is a date i.e. not null, then this is a holiday: return the holiday date.
 	IF p_HISTORICAL_DATE IS NOT NULL THEN
		RETURN;
	END IF;

	v_TARGET_DAY_TYPE := TO_CHAR(p_FORECAST_DATE, 'DAY');

	BEGIN
		p_HISTORICAL_DATE := TO_DATE(TO_CHAR(p_FORECAST_DATE,'DDD-') || v_HISTORICAL_YEAR, 'DDD-YYYY');
	EXCEPTION
		WHEN ERRS.e_INVALID_DATE THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			p_HISTORICAL_DATE := TO_DATE(TO_CHAR(p_FORECAST_DATE - 1,'DDD-') || v_HISTORICAL_YEAR, 'DDD-YYYY');
	END;

	CLOSEST_DAY_TYPE(p_EDC_ID, p_FORECAST_DATE, p_HISTORICAL_DATE, v_BEGIN_DATE, v_END_DATE, v_TARGET_DAY_TYPE, p_HISTORICAL_DATE);

END SIMILAR_DAY_TYPE;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_DAY_TYPE_PROFILE_POINTS
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_PROFILE_ID IN NUMBER,
	p_HISTORICAL_BEGIN_DATE IN DATE,
	p_HISTORICAL_END_DATE IN DATE,
	p_PROFILE_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_PROFILE_POINT IN OUT NOCOPY PROFILE_POINT_TABLE
	) AS

v_SECOND NUMBER(6,5);

BEGIN
	IF NOT FW.PROFILE_IS_EXTERNAL(p_PROFILE_ID) THEN
    -- Internal Profile
        IF p_CAST_CONTEXT.SCENARIO_USE_DAY_TYPE = g_ON THEN
    		IF p_CAST_CONTEXT.MODEL_ID = GA.ELECTRIC_MODEL THEN
    			v_SECOND := g_SECOND;
    		ELSE
    			v_SECOND := 0.0;
    		END IF;
    		SELECT PROFILE_POINT_TYPE(TO_DATE(TO_CHAR(p_HISTORICAL_BEGIN_DATE,'YYYYMMDD') || TO_CHAR(FROM_CUT(POINT_DATE, p_TIME_ZONE),'HH24:MI'), 'YYYYMMDDHH24:MI'), AVG(POINT_VAL))
    		BULK COLLECT INTO p_PROFILE_POINT
    		FROM LOAD_PROFILE_POINT
    		WHERE PROFILE_ID = p_PROFILE_ID
    			AND POINT_INDEX = g_DEFAULT_POINT_INDEX
    			AND POINT_DATE BETWEEN p_HISTORICAL_BEGIN_DATE AND p_HISTORICAL_END_DATE
    			AND AS_OF_DATE = p_PROFILE_AS_OF_DATE
    			AND DECODE(TO_CHAR(FROM_CUT(POINT_DATE, p_TIME_ZONE) - v_SECOND, 'D'), 7, GA.WEEK_END, 1, GA.WEEK_END, GA.WEEK_DAY) = p_CAST_CONTEXT.DAY_TYPE
    		GROUP BY TO_DATE(TO_CHAR(p_HISTORICAL_BEGIN_DATE,'YYYYMMDD') || TO_CHAR(FROM_CUT(POINT_DATE, p_TIME_ZONE),'HH24:MI'), 'YYYYMMDDHH24:MI');
    	ELSE
    		SELECT PROFILE_POINT_TYPE(TO_DATE(TO_CHAR(p_HISTORICAL_BEGIN_DATE,'YYYYMMDD') || TO_CHAR(FROM_CUT(POINT_DATE, p_TIME_ZONE),'HH24:MI'), 'YYYYMMDDHH24:MI'), AVG(POINT_VAL))
    		BULK COLLECT INTO p_PROFILE_POINT
    		FROM LOAD_PROFILE_POINT
    		WHERE PROFILE_ID = p_PROFILE_ID
    			AND POINT_INDEX = g_DEFAULT_POINT_INDEX
    			AND POINT_DATE BETWEEN p_HISTORICAL_BEGIN_DATE AND p_HISTORICAL_END_DATE
    			AND AS_OF_DATE = p_PROFILE_AS_OF_DATE
    		GROUP BY TO_DATE(TO_CHAR(p_HISTORICAL_BEGIN_DATE,'YYYYMMDD') || TO_CHAR(FROM_CUT(POINT_DATE, p_TIME_ZONE),'HH24:MI'), 'YYYYMMDDHH24:MI');
    	END IF;
	ELSE    --External Profile
    	XS.GET_DAY_TYPE_PROFILE_POINTS
        	(
        	p_CAST_CONTEXT,
        	p_PROFILE_ID,
        	p_HISTORICAL_BEGIN_DATE,
        	p_HISTORICAL_END_DATE,
        	p_PROFILE_AS_OF_DATE,
        	p_TIME_ZONE,
        	p_PROFILE_POINT
        	) ;

	END IF;

END GET_DAY_TYPE_PROFILE_POINTS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_PROFILE_POINTS_TABLE
	(
	p_PROFILE_ID IN NUMBER,
	p_POINT_INDEX IN NUMBER,
	p_CUT_HISTORICAL_BEGIN_DATE IN DATE,
	p_CUT_HISTORICAL_END_DATE IN DATE,
	p_PROFILE_AS_OF_DATE IN DATE,
	p_PROFILE_POINT IN OUT NOCOPY PROFILE_POINT_TABLE
	) AS

BEGIN

	IF NOT FW.PROFILE_IS_EXTERNAL(p_PROFILE_ID) THEN
    	--Internal Profile
        SELECT PROFILE_POINT_TYPE(POINT_DATE, POINT_VAL)
    	BULK COLLECT INTO p_PROFILE_POINT
    	FROM LOAD_PROFILE_POINT
    	WHERE PROFILE_ID = p_PROFILE_ID
    		AND POINT_INDEX = p_POINT_INDEX
    		AND POINT_DATE BETWEEN p_CUT_HISTORICAL_BEGIN_DATE AND p_CUT_HISTORICAL_END_DATE
    		AND AS_OF_DATE = p_PROFILE_AS_OF_DATE;

    ELSE    --External Profile
    	XS.GET_PROFILE_POINTS_TABLE
        	(
        	p_PROFILE_ID,
        	p_POINT_INDEX,
        	p_CUT_HISTORICAL_BEGIN_DATE,
        	p_CUT_HISTORICAL_END_DATE,
        	p_PROFILE_AS_OF_DATE,
        	p_PROFILE_POINT
        	);

    END IF;

END GET_PROFILE_POINTS_TABLE;
----------------------------------------------------------------------------------------------------
PROCEDURE HISTORICAL_DAY_PROFILE
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_PROFILE_ID IN NUMBER,
	p_PROFILE_INTERVAL IN NUMBER,
	p_PROFILE_AS_OF_DATE IN DATE,
	p_EDC_ID IN NUMBER,
	p_PROFILE_SOURCE_DATE OUT DATE,
	p_PROFILE IN OUT NOCOPY GA.NUMBER_TABLE
	) AS

-- Answer the historical profile in effect for the specified forecast date.

v_HISTORICAL_DATE DATE;
v_HISTORICAL_BEGIN_DATE DATE;
v_HISTORICAL_END_DATE DATE;
v_FROM_DATE DATE;
v_TO_DATE DATE;
v_TIME_ZONE VARCHAR(3);
v_INDEX BINARY_INTEGER;
v_INTERVAL BINARY_INTEGER;
v_INTERVAL_NAME VARCHAR2(12);
v_STATUS NUMBER;
v_INTERVAL_DIVISOR NUMBER := FW.INTERVAL_DIVISOR(p_PROFILE_INTERVAL);
v_PROFILE_POINT PROFILE_POINT_TABLE := PROFILE_POINT_TABLE();
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;

BEGIN

	GET_PROFILE_FROM_TO_DATES(p_CAST_CONTEXT, p_PROFILE_ID, p_PROFILE_AS_OF_DATE, v_FROM_DATE, v_TO_DATE, v_STATUS);
	IF NOT v_STATUS = GA.SUCCESS THEN
		FW.FILL_PROFILE(p_PROFILE_INTERVAL, p_PROFILE);
		IF LOGS.IS_DEBUG_ENABLED() THEN
			LOGS.LOG_DEBUG('NO STATISTICS FOUND');
		END IF;
		RETURN;
	END IF;

	--If Long Term, just get the profile for the current date.
	IF p_CAST_CONTEXT.RUN_MODE IN (GA.WEEK_MODE, GA.MONTH_MODE) THEN
		--The profile should be populated for this date.
		IF NOT p_CAST_CONTEXT.PROFILE_DATE BETWEEN v_FROM_DATE AND v_TO_DATE THEN
			FW.FILL_PROFILE(p_PROFILE_INTERVAL, p_PROFILE);
			IF LOGS.IS_DEBUG_ENABLED() THEN
				LOGS.LOG_DEBUG('LONG TERM PROFILE NOT POPULATED FOR THIS DATE RANGE');
			END IF;
			RETURN;
		END IF;
		v_HISTORICAL_DATE := p_CAST_CONTEXT.PROFILE_DATE;
	ELSE
		SIMILAR_DAY_TYPE(p_EDC_ID, p_CAST_CONTEXT.PROFILE_DATE, v_FROM_DATE, v_TO_DATE, v_HISTORICAL_DATE, v_STATUS);
		IF NOT v_STATUS = GA.SUCCESS THEN
			FW.FILL_PROFILE(p_PROFILE_INTERVAL, p_PROFILE);
			IF LOGS.IS_DEBUG_ENABLED() THEN
				LOGS.LOG_DEBUG('HISTORICAL DATE RANGE INCONSISTENCY');
			END IF;
			RETURN;
		END IF;
	END IF;

	IF GA.USE_LOAD_PROFILE_STANDARD_DAY THEN
		v_TIME_ZONE := STD_TIME_ZONE(LOCAL_TIME_ZONE);
	ELSE
		v_TIME_ZONE := TIME_ZONE_FOR_DAY(p_CAST_CONTEXT.PROFILE_DATE, LOCAL_TIME_ZONE);
	END IF;

	SELECT DECODE(p_PROFILE_INTERVAL, 24, 'Hour', 48, '30 Minute', 96,
					'15 Minute', 1, 'Day', 'Hour') INTO v_INTERVAL_NAME FROM DUAL;
	UT.CUT_DAY_INTERVAL_RANGE(p_CAST_CONTEXT.MODEL_ID, v_HISTORICAL_DATE, v_HISTORICAL_DATE, v_TIME_ZONE, v_INTERVAL_NAME, v_HISTORICAL_BEGIN_DATE, v_HISTORICAL_END_DATE);

	IF 	LOGS.IS_DEBUG_ENABLED() THEN
		LOGS.LOG_DEBUG('HISTORICAL_DAY_PROFILE');
		LOGS.LOG_DEBUG('PROFILE_ID='  || TO_CHAR(p_PROFILE_ID));
		LOGS.LOG_DEBUG('PROFILE_AS_OF_DATE=' || UT.TRACE_DATE(p_PROFILE_AS_OF_DATE));
		LOGS.LOG_DEBUG('DAY_TYPE='  || TO_CHAR(p_CAST_CONTEXT.DAY_TYPE));
		LOGS.LOG_DEBUG('FROM_DATE=' || UT.TRACE_DATE(v_FROM_DATE));
		LOGS.LOG_DEBUG('TO_DATE=' || UT.TRACE_DATE(v_TO_DATE));
		LOGS.LOG_DEBUG('HISTORICAL_DATE=' || UT.TRACE_DATE(v_HISTORICAL_DATE));
		LOGS.LOG_DEBUG('HISTORICAL_BEGIN_DATE=' || UT.TRACE_DATE(v_HISTORICAL_BEGIN_DATE));
		LOGS.LOG_DEBUG('HISTORICAL_END_DATE=' || UT.TRACE_DATE(v_HISTORICAL_END_DATE));
	END IF;

	FW.FILL_PROFILE(p_PROFILE_INTERVAL, p_PROFILE);

	--SELECT PROFILE_POINT_TYPE(POINT_DATE, POINT_VAL) BULK COLLECT INTO v_PROFILE_POINT ...
	FP.GET_PROFILE_POINTS_TABLE
    	(
    	p_PROFILE_ID,
    	g_DEFAULT_POINT_INDEX,
    	v_HISTORICAL_BEGIN_DATE,
    	v_HISTORICAL_END_DATE,
    	p_PROFILE_AS_OF_DATE,
    	v_PROFILE_POINT
    	);

    v_INDEX := v_PROFILE_POINT.FIRST;
	WHILE v_INDEX <= v_PROFILE_POINT.LAST LOOP
		v_INTERVAL := ROUND((v_PROFILE_POINT(v_INDEX).POINT_DATE - v_HISTORICAL_BEGIN_DATE) / v_INTERVAL_DIVISOR) + 1;
		p_PROFILE(v_INTERVAL) := v_PROFILE_POINT(v_INDEX).POINT_VAL;
		v_INDEX := v_PROFILE_POINT.NEXT(v_INDEX);
	END LOOP;

	p_PROFILE_SOURCE_DATE := v_HISTORICAL_DATE;

	IF 	LOGS.IS_DEBUG_ENABLED() THEN
		LOGS.LOG_DEBUG('HISTORICAL_DAY_PROFILE ELAPSED TIME='  || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED));
	END IF;

END HISTORICAL_DAY_PROFILE;
----------------------------------------------------------------------------------------------------
PROCEDURE TYPICAL_DAY_PROFILE
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_PROFILE_ID IN NUMBER,
	p_PROFILE_INTERVAL IN NUMBER,
	p_PROFILE_AS_OF_DATE IN DATE,
	p_PROFILE IN OUT NOCOPY GA.NUMBER_TABLE
	) AS

-- Answer the typical day profile in effect for the specified forecast date

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_INDEX BINARY_INTEGER;
v_INTERVAL_DIVISOR NUMBER := FW.INTERVAL_DIVISOR(p_PROFILE_INTERVAL);

CURSOR c_PROFILE IS
	SELECT POINT_DATE, POINT_VAL
	FROM LOAD_PROFILE_POINT
	WHERE PROFILE_ID = p_PROFILE_ID
		AND POINT_INDEX = g_DEFAULT_POINT_INDEX
		AND POINT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND AS_OF_DATE = p_PROFILE_AS_OF_DATE;

BEGIN

	UT.CUT_DAY_INTERVAL_RANGE(p_CAST_CONTEXT.MODEL_ID, LOW_DATE, LOW_DATE, STD_TIME_ZONE(LOCAL_TIME_ZONE), v_BEGIN_DATE, v_END_DATE);
	FW.FILL_PROFILE(p_PROFILE_INTERVAL, p_PROFILE);

	IF LOGS.IS_DEBUG_ENABLED() THEN
		LOGS.LOG_DEBUG('TYPICAL_DAY_PROFILE');
		LOGS.LOG_DEBUG('PROFILE_ID='  || TO_CHAR(p_PROFILE_ID));
		LOGS.LOG_DEBUG('PROFILE_AS_OF_DATE=' || UT.TRACE_DATE(p_PROFILE_AS_OF_DATE));
		LOGS.LOG_DEBUG('BEGIN_DATE='  || UT.TRACE_DATE(v_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE='  || UT.TRACE_DATE(v_END_DATE));
	END IF;

-- Extract the point value associated with each point hour.

	IF NOT FW.PROFILE_IS_EXTERNAL(p_PROFILE_ID) THEN
    	--Internal profile
    	FOR v_PROFILE IN c_PROFILE LOOP
    		v_INDEX := ROUND((v_PROFILE.POINT_DATE - v_BEGIN_DATE) / v_INTERVAL_DIVISOR) + 1;
    		p_PROFILE(v_INDEX) := v_PROFILE.POINT_VAL;
    	END LOOP;

    ELSE    --External profile
    	XS.DAY_PROFILE
        	(
        	p_PROFILE_ID,
        	g_DEFAULT_POINT_INDEX,
        	v_BEGIN_DATE,
        	v_END_DATE,
        	p_PROFILE_AS_OF_DATE,
            v_INTERVAL_DIVISOR,  --for typical day profile
        	p_PROFILE
        	);

    END IF;

END TYPICAL_DAY_PROFILE;
----------------------------------------------------------------------------------------------------
PROCEDURE USAGE_DAY_PROFILE
	(
	p_SERVICE_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_INCLUDE_LOSSES IN BOOLEAN,
	p_PROFILE IN OUT NOCOPY GA.NUMBER_TABLE
	) AS

-- Answer the usage day profile in effect for the specified forecast date
-- Discriminate between versioned and non-versioned usage data.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_HAS_USAGE_DAY_PROFILE BOOLEAN := FALSE;
v_INDEX BINARY_INTEGER;
v_STATUS NUMBER;
v_INCLUDE_LOSSES NUMBER(1) := 0;

CURSOR c_USAGE IS
	SELECT LOAD_DATE, DECODE(v_INCLUDE_LOSSES, 0, LOAD_VAL, LOAD_VAL + TX_LOSS_VAL + DX_LOSS_VAL) "LOAD_VAL"
	FROM SERVICE_LOAD
	WHERE SERVICE_ID = p_SERVICE_ID
		AND SERVICE_CODE = GA.ACTUAL_SERVICE
		AND LOAD_CODE = GA.STANDARD
		AND LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE;

BEGIN

	UT.CUT_DAY_INTERVAL_RANGE(GA.DEFAULT_MODEL, p_SERVICE_DATE, p_SERVICE_DATE, LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	IF p_INCLUDE_LOSSES THEN
		v_INCLUDE_LOSSES := 1;
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('USAGE_DAY_PROFILE');
		LOGS.LOG_DEBUG('SERVICE_ID=' || TO_CHAR(p_SERVICE_ID));
		LOGS.LOG_DEBUG('SERVICE_DATE='  || UT.TRACE_DATE(p_SERVICE_DATE));
		LOGS.LOG_DEBUG('BEGIN_DATE='  || UT.TRACE_DATE(v_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE='  || UT.TRACE_DATE(v_END_DATE));
		LOGS.LOG_DEBUG('INCLUDE_LOSSES='  || UT.TRACE_BOOLEAN(p_INCLUDE_LOSSES));
	END IF;

	IF GA.ENABLE_EXTERNAL_METER_ACCESS THEN
		XS.CACHE_USAGE(p_SERVICE_ID, v_BEGIN_DATE, v_END_DATE, v_STATUS);
	END IF;

	FOR v_USAGE IN c_USAGE LOOP
		IF 	NOT v_HAS_USAGE_DAY_PROFILE THEN
			FW.FILL_PROFILE(v_BEGIN_DATE, v_END_DATE, p_PROFILE);
			v_HAS_USAGE_DAY_PROFILE := TRUE;
		END IF;
		v_INDEX := ROUND((v_USAGE.LOAD_DATE - v_BEGIN_DATE) / GA.HOUR_DIVISOR) + 1;
		p_PROFILE(v_INDEX) := v_USAGE.LOAD_VAL;
	END LOOP;

	IF GA.ENABLE_EXTERNAL_METER_ACCESS THEN
		XS.RELEASE_USAGE(p_SERVICE_ID, v_BEGIN_DATE, v_END_DATE);
	END IF;

END USAGE_DAY_PROFILE;
--------------------------------------------------------------------------------------------------
PROCEDURE DAY_PROFILE
	(
	p_PROFILE_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_PROFILE IN OUT NOCOPY GA.NUMBER_TABLE
	) AS

-- Answer the day profile in effect for the specified date

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_INDEX BINARY_INTEGER;
v_PROFILE_AS_OF_DATE DATE;

CURSOR c_PROFILE IS
	SELECT POINT_DATE, POINT_VAL
	FROM LOAD_PROFILE_POINT A
	WHERE PROFILE_ID = p_PROFILE_ID
		AND POINT_INDEX = g_DEFAULT_POINT_INDEX
		AND POINT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM LOAD_PROFILE_POINT
			WHERE PROFILE_ID = A.PROFILE_ID
				AND POINT_INDEX = A.POINT_INDEX
				AND POINT_DATE = A.POINT_DATE
				AND AS_OF_DATE <= v_PROFILE_AS_OF_DATE);

BEGIN

	UT.CUT_DATE_RANGE(p_SERVICE_DATE, p_SERVICE_DATE, LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	FW.FILL_PROFILE(v_BEGIN_DATE, v_END_DATE, p_PROFILE);
	v_PROFILE_AS_OF_DATE := CS.GET_PROFILE_AS_OF_DATE(p_PROFILE_ID, p_AS_OF_DATE);

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('DAY_PROFILE');
		LOGS.LOG_DEBUG('PROFILE_ID=' || TO_CHAR(p_PROFILE_ID));
		LOGS.LOG_DEBUG('SERVICE_DATE='  || UT.TRACE_DATE(p_SERVICE_DATE));
		LOGS.LOG_DEBUG('BEGIN_DATE='  || UT.TRACE_DATE(v_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE='  || UT.TRACE_DATE(v_END_DATE));
		LOGS.LOG_DEBUG('AS_OF_DATE='  || UT.TRACE_DATE(p_AS_OF_DATE));
		LOGS.LOG_DEBUG('PROFILE_AS_OF_DATE='  || UT.TRACE_DATE(v_PROFILE_AS_OF_DATE));
	END IF;

	IF NOT FW.PROFILE_IS_EXTERNAL(p_PROFILE_ID) THEN
    	--Internal profile
        FOR v_PROFILE IN c_PROFILE LOOP
    		v_INDEX := ROUND((v_PROFILE.POINT_DATE - v_BEGIN_DATE) / GA.HOUR_DIVISOR) + 1;
    		p_PROFILE(v_INDEX) := v_PROFILE.POINT_VAL;
    	END LOOP;

    ELSE    --External profile
    	XS.DAY_PROFILE
        	(
        	p_PROFILE_ID,
        	g_DEFAULT_POINT_INDEX,
        	v_BEGIN_DATE,
        	v_END_DATE,
        	v_PROFILE_AS_OF_DATE,
            GA.HOUR_DIVISOR,  --for the day profile
        	p_PROFILE
        	);

    END IF;

END DAY_PROFILE;
----------------------------------------------------------------------------------------------------
PROCEDURE LOAD_PROFILE_BASE_SEGMENT
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_STATION_ID IN NUMBER,
	p_PROFILE_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_POST_TO_APP_EVENT_LOG IN BOOLEAN,
	p_PROFILE_TYPE IN OUT CHAR,
	p_PROFILE_SOURCE_DATE IN OUT DATE,
	p_COMPOSITE_PROFILE IN OUT NOCOPY GA.NUMBER_TABLE
	) AS

-- Append a load profile to the profile table based upon its operation code.

v_PROFILE_OP_CODE NUMBER;
v_PROFILE_TYPE CHAR(3);
v_PROFILE_ADJUSTMENT_OPTION LOAD_PROFILE.PROFILE_ADJUSTMENT_OPTION%TYPE;
v_PROFILE_NAME LOAD_PROFILE.PROFILE_NAME%TYPE;
v_PROFILE_INTERVAL LOAD_PROFILE.PROFILE_INTERVAL%TYPE;
v_PROFILE_STATUS LOAD_PROFILE_STATISTICS.PROFILE_STATUS%TYPE;
v_POINT_VAL NUMBER;
v_PROFILE GA.NUMBER_TABLE;
v_EFFECTIVE_TEMPERATURE GA.NUMBER_TABLE;
v_WRF_OBSERVATIONS WRF_OBSERVATION_TABLE := WRF_OBSERVATION_TABLE();
v_INDEX BINARY_INTEGER;
v_PROFILE_AS_OF_DATE DATE;

BEGIN

	SELECT DECODE(UPPER(SUBSTR(PROFILE_OPERATION,1,1)),'A',1,'S',2,'M',3,1),
		UPPER(SUBSTR(PROFILE_TYPE,1,3)),
		PROFILE_ADJUSTMENT_OPTION,
		DECODE(PROFILE_INTERVAL,1,1,24,24,48,48,96,96,24) -- default to 24 for undefined/unknown interval type.
	INTO v_PROFILE_OP_CODE, v_PROFILE_TYPE, v_PROFILE_ADJUSTMENT_OPTION, v_PROFILE_INTERVAL
	FROM LOAD_PROFILE
	WHERE PROFILE_ID = p_PROFILE_ID;

	v_PROFILE_AS_OF_DATE := CS.GET_PROFILE_AS_OF_DATE(p_PROFILE_ID, p_CAST_CONTEXT.PROFILE_AS_OF_DATE);
	v_PROFILE_STATUS := GET_PROFILE_STATUS(p_PROFILE_ID, v_PROFILE_AS_OF_DATE);

	IF LOGS.IS_DEBUG_ENABLED() THEN
		LOGS.LOG_DEBUG('LOAD_PROFILE_BASE_SEGMENT');
		LOGS.LOG_DEBUG('STATION_ID=' || TO_CHAR(p_STATION_ID));
		LOGS.LOG_DEBUG('PROFILE_ID=' || TO_CHAR(p_PROFILE_ID));
		LOGS.LOG_DEBUG('PROFILE_AS_OF_DATE=' || UT.TRACE_DATE(v_PROFILE_AS_OF_DATE));
		LOGS.LOG_DEBUG('PROFILE_OP_CODE=' || TO_CHAR(v_PROFILE_OP_CODE));
		LOGS.LOG_DEBUG('PROFILE_TYPE=' || v_PROFILE_TYPE);
		LOGS.LOG_DEBUG('PROFILE_STATUS=' || v_PROFILE_STATUS);
		LOGS.LOG_DEBUG('PROFILE_INTERVAL=' || TO_CHAR(v_PROFILE_INTERVAL));
	END IF;

	p_PROFILE_SOURCE_DATE := NULL;

	IF p_POST_TO_APP_EVENT_LOG AND v_PROFILE_STATUS <> 'PRODUCTION' AND GA.ENABLE_PRODUCTION_PROFILE_MSG AND p_CAST_CONTEXT.CALENDAR_CASE_ID = GA.BASE_CASE_ID THEN
		v_PROFILE_NAME := FW.GET_PROFILE_NAME(p_PROFILE_ID);
		g_EVENT_TEXT := 'Non-Production Profile Assignment to ' || v_PROFILE_NAME || ' on ' || TO_CHAR(p_CAST_CONTEXT.PROFILE_DATE,'MM/DD/YYYY');
		IF GA.ENFORCE_PRODUCTION_PROFILE_USE THEN
			g_EVENT_TEXT := g_EVENT_TEXT || ' (Profile not used)';
		END IF;
		LOGS.LOG_WARN(g_EVENT_TEXT);
	END IF;

	IF v_PROFILE_STATUS <> 'PRODUCTION' AND GA.ENFORCE_PRODUCTION_PROFILE_USE  AND p_CAST_CONTEXT.CALENDAR_CASE_ID = GA.BASE_CASE_ID THEN
		FW.FILL_PROFILE(v_PROFILE_INTERVAL, p_COMPOSITE_PROFILE);
		IF LOGS.IS_DEBUG_ENABLED() THEN
			LOGS.LOG_DEBUG('NON-PRODUCTION PROFILE ASSIGNMENT. ZERO PROFILE SUBSTITUTED.');
		END IF;
		p_PROFILE_TYPE := g_ZERO_PROFILE;
		RETURN;
	END IF;

	IF v_PROFILE_TYPE = 'HIS' THEN -- HIStorical load profile.
		HISTORICAL_DAY_PROFILE(p_CAST_CONTEXT, p_PROFILE_ID, v_PROFILE_INTERVAL, v_PROFILE_AS_OF_DATE, p_EDC_ID, p_PROFILE_SOURCE_DATE, v_PROFILE);
		p_PROFILE_TYPE := g_HISTORICAL_PROFILE;

	ELSIF v_PROFILE_TYPE = 'TYP' THEN -- TYPical day load profile.
		TYPICAL_DAY_PROFILE(p_CAST_CONTEXT, p_PROFILE_ID, v_PROFILE_INTERVAL, v_PROFILE_AS_OF_DATE, v_PROFILE);
		p_PROFILE_TYPE := g_TYPICAL_PROFILE;

	ELSIF v_PROFILE_TYPE = 'WEA' THEN -- WEAther indexed load profile.
		FW.WEATHER_FOR_INDEXED_PROFILE(p_CAST_CONTEXT, p_STATION_ID, v_PROFILE_ADJUSTMENT_OPTION, p_EDC_ID, p_POST_TO_APP_EVENT_LOG, v_EFFECTIVE_TEMPERATURE);
		FW.WEATHER_INDEXED_PROFILE(p_CAST_CONTEXT, p_PROFILE_ID, p_STATION_ID, v_PROFILE_INTERVAL, v_PROFILE_AS_OF_DATE, v_EFFECTIVE_TEMPERATURE, v_PROFILE);
		p_PROFILE_TYPE := g_INDEXED_PROFILE;

	ELSIF v_PROFILE_TYPE = 'WRF' THEN -- Weather Response Function.
		FW.WEATHER_FOR_WRF_PROFILE(p_CAST_CONTEXT, p_STATION_ID, p_PROFILE_ID, p_EDC_ID, p_POST_TO_APP_EVENT_LOG, v_WRF_OBSERVATIONS);
		FW.WRF_PROFILE(p_CAST_CONTEXT, p_PROFILE_ID, v_PROFILE_INTERVAL, v_PROFILE_AS_OF_DATE, v_WRF_OBSERVATIONS, v_PROFILE);
		p_PROFILE_TYPE := g_WRF_PROFILE;

	ELSIF v_PROFILE_TYPE = 'USA' THEN -- Usage WRF Profile.
		FW.USAGE_WRF_PROFILE(p_CAST_CONTEXT, p_PROFILE_ID, v_PROFILE_INTERVAL, v_PROFILE_AS_OF_DATE,v_PROFILE);
		p_PROFILE_TYPE := g_USAGE_WRF_PROFILE;

	END IF;

	v_INDEX := v_PROFILE.FIRST;
	WHILE v_INDEX <= v_PROFILE.LAST LOOP
		IF NOT p_COMPOSITE_PROFILE.EXISTS(v_INDEX) THEN
			p_COMPOSITE_PROFILE(v_INDEX) := 0;
		END IF;
		v_POINT_VAL := v_PROFILE(v_INDEX);
		IF v_POINT_VAL IS NOT NULL THEN
			IF v_PROFILE_OP_CODE = 1 THEN
				p_COMPOSITE_PROFILE(v_INDEX) := p_COMPOSITE_PROFILE(v_INDEX) + v_POINT_VAL;
			ELSIF v_PROFILE_OP_CODE = 2 THEN
				p_COMPOSITE_PROFILE(v_INDEX) := p_COMPOSITE_PROFILE(v_INDEX) - v_POINT_VAL;
			ELSIF v_PROFILE_OP_CODE = 3 THEN
				p_COMPOSITE_PROFILE(v_INDEX) := p_COMPOSITE_PROFILE(v_INDEX) * v_POINT_VAL;
			END IF;
		END IF;
		v_INDEX := v_PROFILE.NEXT(v_INDEX);
	END LOOP;

END LOAD_PROFILE_BASE_SEGMENT;
----------------------------------------------------------------------------------------------------
PROCEDURE LOAD_PROFILE_ADJUSTMENT
	(
	p_CALENDAR_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_PROFILE IN OUT NOCOPY GA.NUMBER_TABLE
	) AS

CURSOR c_CALENDAR_ADJUSTMENT IS
	SELECT ADJ_VAL,
		DECODE(UPPER(SUBSTR(ADJ_OP,1,1)),'A',1,'M',2,1) "ADJ_OP"
	FROM CALENDAR_ADJUSTMENT
	WHERE CALENDAR_ID = p_CALENDAR_ID
		AND p_SERVICE_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE)
	ORDER BY 2;

v_INDEX BINARY_INTEGER;

BEGIN

	IF p_PROFILE.COUNT > 0 THEN
		FOR v_CALENDAR_ADJUSTMENT IN c_CALENDAR_ADJUSTMENT LOOP
			v_INDEX := p_PROFILE.FIRST;
			FOR v_INDEX IN p_PROFILE.FIRST..p_PROFILE.LAST LOOP
				IF v_CALENDAR_ADJUSTMENT.ADJ_OP = 1 THEN
					p_PROFILE(v_INDEX) := p_PROFILE(v_INDEX) + v_CALENDAR_ADJUSTMENT.ADJ_VAL;
				ELSE
					p_PROFILE(v_INDEX) := p_PROFILE(v_INDEX) * v_CALENDAR_ADJUSTMENT.ADJ_VAL;
				END IF;
			END LOOP;
		END LOOP;
	END IF;

END LOAD_PROFILE_ADJUSTMENT;
----------------------------------------------------------------------------------------------------
PROCEDURE COLLECT_CALENDAR_PROFILE_IDS
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_CALENDAR_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_ASSIGNMENT_TYPE IN OUT CALENDAR.ASSIGNMENT_TYPE%TYPE,
	p_HAS_ADJUSTMENTS IN OUT CALENDAR.HAS_ADJUSTMENTS%TYPE,
	p_ASSIGNMENT_COUNT IN OUT PLS_INTEGER,
	p_PROFILE_IDS IN OUT NOCOPY GA.NUMBER_TABLE
	) AS

v_IS_HOLIDAY BOOLEAN;
v_FOUND BOOLEAN := FALSE;
v_FORBIDDEN_STATUS LOAD_PROFILE_STATISTICS.PROFILE_STATUS%TYPE := '(None)';
v_AS_OF_DATE DATE := p_CAST_CONTEXT.PROFILE_AS_OF_DATE;

CURSOR c_CALENDAR_PROFILE IS
	SELECT A.PROFILE_ID
	FROM CALENDAR_PROFILE A, LOAD_PROFILE_STATISTICS S
	WHERE CALENDAR_ID = p_CALENDAR_ID
		AND p_CAST_CONTEXT.PROFILE_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE, p_CAST_CONTEXT.PROFILE_DATE)
		AND S.PROFILE_ID = A.PROFILE_ID
		AND S.AS_OF_DATE = v_AS_OF_DATE
		AND NOT S.PROFILE_STATUS = v_FORBIDDEN_STATUS;

CURSOR c_CALENDAR_PROFILE_LIBRARY IS
	SELECT B.PROFILE_ID, DECODE(C.DAY_NAME,'Hol',0,1) "DAY_NAME_CODE"
	FROM CALENDAR_PROFILE_LIBRARY A, LOAD_PROFILE B, TEMPLATE_SEASON_DAY_NAME C, SEASON D, SEASON_DATES I, LOAD_PROFILE_STATISTICS S
	WHERE A.CALENDAR_ID = p_CALENDAR_ID
		AND p_CAST_CONTEXT.PROFILE_DATE BETWEEN A.BEGIN_DATE AND NVL(A.END_DATE, p_CAST_CONTEXT.PROFILE_DATE)
		AND B.PROFILE_LIBRARY_ID = A.PROFILE_LIBRARY_ID
		AND C.TEMPLATE_ID = B.PROFILE_TEMPLATE_ID
		AND C.DAY_NAME = DATE_DAY_NAME(p_CAST_CONTEXT.PROFILE_DATE, p_EDC_ID)
		AND D.SEASON_ID = C.SEASON_ID
		AND I.SEASON_ID = D.SEASON_ID
        AND p_CAST_CONTEXT.PROFILE_DATE BETWEEN I.BEGIN_DATE AND I.END_DATE  --Replace DATE_IS_WITHIN_SEASON fxn
		AND S.PROFILE_ID = B.PROFILE_ID
		AND S.AS_OF_DATE = v_AS_OF_DATE
		AND NOT S.PROFILE_STATUS = v_FORBIDDEN_STATUS
	ORDER BY DECODE(C.DAY_NAME,'Hol',0,1);

BEGIN

-- Determine the calendar assignment type and whether the calendar has adjustments.
	BEGIN
		SELECT NVL(ASSIGNMENT_TYPE,'B'), NVL(HAS_ADJUSTMENTS,1) INTO p_ASSIGNMENT_TYPE, p_HAS_ADJUSTMENTS FROM CALENDAR WHERE CALENDAR_ID = p_CALENDAR_ID;
	EXCEPTION
		WHEN OTHERS THEN
			p_ASSIGNMENT_TYPE := 'B';
			p_HAS_ADJUSTMENTS := 1;
	END;

-- Do not collect Pending profiles if Production use is enforced.
	IF GA.ENFORCE_PRODUCTION_PROFILE_USE THEN
		v_FORBIDDEN_STATUS := 'Pending';
	END IF;

-- Collect any load profiles assigned using a profile calendar assignment.
	IF p_ASSIGNMENT_TYPE IN ('P','B') THEN
		FOR v_CALENDAR_PROFILE IN c_CALENDAR_PROFILE LOOP
			p_PROFILE_IDS(p_PROFILE_IDS.COUNT + 1) := v_CALENDAR_PROFILE.PROFILE_ID;
		END LOOP;
	END IF;

-- Collect any load profiles assigned using a profile library calendar assignment.
	IF p_ASSIGNMENT_TYPE IN ('L','B') THEN
		FOR v_CALENDAR_PROFILE_LIBRARY IN c_CALENDAR_PROFILE_LIBRARY LOOP
			v_IS_HOLIDAY := v_CALENDAR_PROFILE_LIBRARY.DAY_NAME_CODE = 0 AND IS_HOLIDAY(p_CAST_CONTEXT.PROFILE_DATE, p_EDC_ID);
			IF (v_IS_HOLIDAY OR v_CALENDAR_PROFILE_LIBRARY.DAY_NAME_CODE > 0) AND NOT v_FOUND THEN
				p_PROFILE_IDS(p_PROFILE_IDS.COUNT + 1) := v_CALENDAR_PROFILE_LIBRARY.PROFILE_ID;
				v_FOUND := TRUE; -- only one profile can be in effect for a service date; holiday profile is ordered to come before standard day types.
			END IF;
			IF NOT v_IS_HOLIDAY THEN
				p_ASSIGNMENT_COUNT := p_ASSIGNMENT_COUNT + 1;
			END IF;
		END LOOP;
	END IF;

END COLLECT_CALENDAR_PROFILE_IDS;
----------------------------------------------------------------------------------------------------
PROCEDURE COMPOSITE_PROFILE_FOR_CALENDAR
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_STATION_ID IN NUMBER,
	p_CALENDAR_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_POST_TO_APP_EVENT_LOG IN BOOLEAN,
	p_PROFILE_TYPE OUT CHAR,
	p_PROFILE_SOURCE_DATE OUT DATE,
	p_COMPOSITE_PROFILE IN OUT NOCOPY GA.NUMBER_TABLE
	) AS

-- Construct the composite load profile in effect for the specified calendar and service date.
-- The profile can consist of 0..1 library profile assignment, 0..n calendar profile assignments,
-- and 0..n profile adjustments.

v_COUNT PLS_INTEGER := 0;
v_ASSIGNMENT_TYPE CALENDAR.ASSIGNMENT_TYPE%TYPE := 'N';
v_HAS_ADJUSTMENTS CALENDAR.HAS_ADJUSTMENTS%TYPE := 0;
v_ASSIGNMENT_COUNT PLS_INTEGER := 0;
v_PROFILE_IDS GA.NUMBER_TABLE;
v_INDEX BINARY_INTEGER;

BEGIN

	IF LOGS.IS_DEBUG_ENABLED() THEN
		LOGS.LOG_DEBUG('COMPOSITE_PROFILE_FOR_CALENDAR');
		LOGS.LOG_DEBUG('STATION_ID=' || TO_CHAR(p_STATION_ID));
		LOGS.LOG_DEBUG('CALENDAR_ID=' || TO_CHAR(p_CALENDAR_ID));
		LOGS.LOG_DEBUG('EDC_ID=' || TO_CHAR(p_EDC_ID));
	END IF;

	COLLECT_CALENDAR_PROFILE_IDS(p_CAST_CONTEXT, p_CALENDAR_ID, p_EDC_ID, v_ASSIGNMENT_TYPE, v_HAS_ADJUSTMENTS, v_ASSIGNMENT_COUNT, v_PROFILE_IDS);

	IF LOGS.IS_DEBUG_ENABLED() THEN
		LOGS.LOG_DEBUG('ASSIGNMENT_TYPE=' || v_ASSIGNMENT_TYPE);
		LOGS.LOG_DEBUG('HAS_ADJUSTMENTS=' || v_HAS_ADJUSTMENTS);
		LOGS.LOG_DEBUG('ASSIGNMENT_COUNT=' || TO_CHAR(v_ASSIGNMENT_COUNT));
		LOGS.LOG_DEBUG('PROFILE_IDS COUNT=' || TO_CHAR(v_PROFILE_IDS.COUNT));
	END IF;

	p_COMPOSITE_PROFILE.DELETE;

-- Process any load profiles assigned using a profile calendar or library calendar assignment.
	IF v_PROFILE_IDS.COUNT > 0 THEN
		v_INDEX := v_PROFILE_IDS.FIRST;
		WHILE v_INDEX <= v_PROFILE_IDS.LAST LOOP
			LOAD_PROFILE_BASE_SEGMENT(p_CAST_CONTEXT, p_STATION_ID, v_PROFILE_IDS(v_INDEX), p_EDC_ID, p_POST_TO_APP_EVENT_LOG, p_PROFILE_TYPE, p_PROFILE_SOURCE_DATE, p_COMPOSITE_PROFILE);
			v_INDEX := v_PROFILE_IDS.NEXT(v_INDEX);
		END LOOP;
	END IF;

	IF v_ASSIGNMENT_COUNT > 1 THEN
		IF NOT v_ASSIGNMENT_TYPE = 'B' THEN
			g_OBJECT_NAME := GET_CALENDAR_NAME(p_CALENDAR_ID);
			g_EVENT_TEXT := 'Multiple Profile Assignment to Library Calendar for ' || g_OBJECT_NAME || ' on ' || TO_CHAR(p_CAST_CONTEXT.PROFILE_DATE,'MM/DD/YYYY');
			LOGS.LOG_WARN(g_EVENT_TEXT);
		ELSE
			p_PROFILE_TYPE := g_COMPOSITE_PROFILE;
			p_PROFILE_SOURCE_DATE := NULL;
		END IF;
	END IF;

	IF v_PROFILE_IDS.COUNT = 0 AND p_POST_TO_APP_EVENT_LOG THEN
		g_OBJECT_NAME := GET_CALENDAR_NAME(p_CALENDAR_ID);
		g_EVENT_TEXT := 'No Profile Assignment to Calendar for ' || g_OBJECT_NAME || ' on ' || TO_CHAR(p_CAST_CONTEXT.PROFILE_DATE,'MM/DD/YYYY');
		LOGS.LOG_WARN(g_EVENT_TEXT);
	END IF;

-- Process any load profile adjustments.
	IF v_HAS_ADJUSTMENTS = 1 THEN
		LOAD_PROFILE_ADJUSTMENT(p_CALENDAR_ID, p_CAST_CONTEXT.PROFILE_DATE, p_COMPOSITE_PROFILE);
	END IF;

-- Default the profile to zero values if a profile could not be derived from the model.
	IF p_COMPOSITE_PROFILE.COUNT = 0 THEN
		SELECT DECODE(p_CAST_CONTEXT.MODEL_ID, GA.ELECTRIC_MODEL, 24, 1) INTO v_COUNT FROM DUAL;
		FW.FILL_PROFILE(v_COUNT, p_COMPOSITE_PROFILE);
		IF LOGS.IS_DEBUG_ENABLED() THEN
			LOGS.LOG_DEBUG('ZERO PROFILE DEFAULT FOR CALENDAR=' || TO_CHAR(p_CALENDAR_ID));
		END IF;
	END IF;

	IF LOGS.IS_DEBUG_DETAIL_ENABLED()THEN
		LOGS.LOG_DEBUG_DETAIL('COMPOSITE_PROFILE TRACE...');
		TRACE_TABLE(p_PROFILE_TYPE, p_COMPOSITE_PROFILE);
	END IF;

END COMPOSITE_PROFILE_FOR_CALENDAR;
----------------------------------------------------------------------------------------------------
PROCEDURE COMPOSITE_PROFILE_TO_CACHE
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_STATION_ID IN NUMBER,
	p_CALENDAR_ID IN NUMBER,
	p_PROFILE_TYPE IN CHAR,
	p_PROFILE_SOURCE_DATE IN DATE,
	p_COMPOSITE_PROFILE IN GA.NUMBER_TABLE
	) AS

v_INDEX BINARY_INTEGER;
v_CACHE_INDEX BINARY_INTEGER;
v_PROFILE_INDEX BINARY_INTEGER;

BEGIN

	IF LOGS.IS_DEBUG_DETAIL_ENABLED()THEN
		LOGS.LOG_DEBUG_DETAIL('COMPOSITE_PROFILE_TO_CACHE');
		LOGS.LOG_DEBUG_DETAIL('STATION_ID=' || TO_CHAR(p_STATION_ID));
		LOGS.LOG_DEBUG_DETAIL('CALENDAR_ID=' || TO_CHAR(p_CALENDAR_ID));
		LOGS.LOG_DEBUG_DETAIL('PROFILE_TYPE=' || p_PROFILE_TYPE);
		LOGS.LOG_DEBUG_DETAIL('PROFILE_SOURCE_DATE=' || TO_CHAR(p_PROFILE_SOURCE_DATE));
		LOGS.LOG_DEBUG_DETAIL('COMPOSITE_PROFILE COUNT=' || TO_CHAR(p_COMPOSITE_PROFILE.COUNT));
	END IF;

	v_INDEX := g_COMPOSITE_PROFILE_INDEX.COUNT + 1;

	IF g_COMPOSITE_PROFILE_INDEX.COUNT = 0 THEN
		v_CACHE_INDEX := 1;
	ELSE
		v_CACHE_INDEX := g_COMPOSITE_PROFILE_INDEX(g_COMPOSITE_PROFILE_INDEX.LAST).STOP_POS + 1;
	END IF;

	g_COMPOSITE_PROFILE_INDEX(v_INDEX).STATION_ID := p_STATION_ID;
	g_COMPOSITE_PROFILE_INDEX(v_INDEX).CALENDAR_ID := p_CALENDAR_ID;
	g_COMPOSITE_PROFILE_INDEX(v_INDEX).PROFILE_TYPE := p_PROFILE_TYPE;
	g_COMPOSITE_PROFILE_INDEX(v_INDEX).PROFILE_SOURCE_DATE := p_PROFILE_SOURCE_DATE;
	g_COMPOSITE_PROFILE_INDEX(v_INDEX).START_POS := v_CACHE_INDEX;
	g_COMPOSITE_PROFILE_INDEX(v_INDEX).STOP_POS := 0;

	v_PROFILE_INDEX := p_COMPOSITE_PROFILE.FIRST;
	WHILE v_PROFILE_INDEX <= p_COMPOSITE_PROFILE.LAST LOOP
		g_COMPOSITE_PROFILE_CACHE(v_CACHE_INDEX) := p_COMPOSITE_PROFILE(v_PROFILE_INDEX);
		v_CACHE_INDEX := v_CACHE_INDEX + 1;
		v_PROFILE_INDEX := p_COMPOSITE_PROFILE.NEXT(v_PROFILE_INDEX);
	END LOOP;

	g_COMPOSITE_PROFILE_INDEX(v_INDEX).STOP_POS := v_CACHE_INDEX - 1;

END COMPOSITE_PROFILE_TO_CACHE;
----------------------------------------------------------------------------------------------------
FUNCTION COMPOSITE_PROFILE_FROM_CACHE
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_STATION_ID IN NUMBER,
	p_CALENDAR_ID IN NUMBER,
	p_PROFILE_TYPE OUT CHAR,
	p_PROFILE_SOURCE_DATE OUT DATE,
	p_COMPOSITE_PROFILE IN OUT NOCOPY GA.NUMBER_TABLE
	) RETURN BOOLEAN IS

v_INDEX BINARY_INTEGER;
v_CACHE_INDEX BINARY_INTEGER;

BEGIN

	IF LOGS.IS_DEBUG_DETAIL_ENABLED()THEN
		LOGS.LOG_DEBUG_DETAIL('COMPOSITE_PROFILE_FROM_CACHE');
		LOGS.LOG_DEBUG_DETAIL('STATION_ID=' || TO_CHAR(p_STATION_ID));
		LOGS.LOG_DEBUG_DETAIL('CALENDAR_ID=' || TO_CHAR(p_CALENDAR_ID));
		LOGS.LOG_DEBUG_DETAIL('COMPOSITE_PROFILE_INDEX COUNT=' || TO_CHAR(g_COMPOSITE_PROFILE_INDEX.COUNT));
		LOGS.LOG_DEBUG_DETAIL('COMPOSITE_PROFILE_CACHE COUNT=' || TO_CHAR(g_COMPOSITE_PROFILE_CACHE.COUNT));
	END IF;

	v_INDEX := g_COMPOSITE_PROFILE_INDEX.FIRST;
    p_COMPOSITE_PROFILE.DELETE;
	WHILE v_INDEX <= g_COMPOSITE_PROFILE_INDEX.LAST LOOP
		IF g_COMPOSITE_PROFILE_INDEX(v_INDEX).STATION_ID = p_STATION_ID AND g_COMPOSITE_PROFILE_INDEX(v_INDEX).CALENDAR_ID = p_CALENDAR_ID THEN
			FOR v_CACHE_INDEX IN g_COMPOSITE_PROFILE_INDEX(v_INDEX).START_POS..g_COMPOSITE_PROFILE_INDEX(v_INDEX).STOP_POS LOOP
				p_COMPOSITE_PROFILE(v_CACHE_INDEX - g_COMPOSITE_PROFILE_INDEX(v_INDEX).START_POS + 1) := g_COMPOSITE_PROFILE_CACHE(v_CACHE_INDEX);
			END LOOP;
			p_PROFILE_TYPE := g_COMPOSITE_PROFILE_INDEX(v_INDEX).PROFILE_TYPE;
			p_PROFILE_SOURCE_DATE := g_COMPOSITE_PROFILE_INDEX(v_INDEX).PROFILE_SOURCE_DATE;
			IF LOGS.IS_DEBUG_DETAIL_ENABLED()THEN
				LOGS.LOG_DEBUG_DETAIL('COMPOSITE_PROFILE FOUND IN CACHE');
			END IF;
			RETURN TRUE;
		END IF;
		v_INDEX := g_COMPOSITE_PROFILE_INDEX.NEXT(v_INDEX);
	END LOOP;

	IF LOGS.IS_DEBUG_DETAIL_ENABLED()THEN
		LOGS.LOG_DEBUG_DETAIL('COMPOSITE_PROFILE NOT FOUND IN CACHE');
	END IF;

	RETURN FALSE;

END COMPOSITE_PROFILE_FROM_CACHE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_PROFILE_MONITOR
	(
	p_PROJECTION_DETERMINANT IN PROFILE_MONITOR%ROWTYPE
	) AS

BEGIN

	UPDATE PROFILE_MONITOR
	SET	MONITOR_MAPE = p_PROJECTION_DETERMINANT.MONITOR_MAPE,
		ENTRY_DATE = SYSDATE
	WHERE ACCOUNT_ID = p_PROJECTION_DETERMINANT.ACCOUNT_ID
		AND METER_ID = p_PROJECTION_DETERMINANT.METER_ID
		AND MONITOR_DATE = p_PROJECTION_DETERMINANT.MONITOR_DATE;

	IF SQL%NOTFOUND THEN
		INSERT INTO PROFILE_MONITOR (
			ACCOUNT_ID,
			METER_ID,
			MONITOR_DATE,
			MONITOR_MAPE,
			ENTRY_DATE)
		VALUES (
			p_PROJECTION_DETERMINANT.ACCOUNT_ID,
			p_PROJECTION_DETERMINANT.METER_ID,
			p_PROJECTION_DETERMINANT.MONITOR_DATE,
			p_PROJECTION_DETERMINANT.MONITOR_MAPE,
			SYSDATE);
	END IF;

END PUT_PROFILE_MONITOR;
----------------------------------------------------------------------------------------------------
PROCEDURE SETTLEMENT_PROFILE_CALENDAR
	(
	p_CALENDAR_NAME IN VARCHAR,
	p_CALENDAR_ID OUT NUMBER
	) AS

BEGIN

	SELECT CALENDAR_ID
	INTO p_CALENDAR_ID
	FROM CALENDAR
	WHERE CALENDAR_NAME = p_CALENDAR_NAME;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			IF SQL%NOTFOUND THEN
				SELECT OID.NEXTVAL INTO p_CALENDAR_ID FROM DUAL;
				INSERT INTO CALENDAR(
					CALENDAR_ID,
					CALENDAR_NAME,
					CALENDAR_ALIAS,
					CALENDAR_DESC,
					ENTRY_DATE)
				VALUES(
					p_CALENDAR_ID,
					p_CALENDAR_NAME,
					p_CALENDAR_NAME,
					'RetailOffice Created Settlement Profile Calendar',
					SYSDATE);
			END IF;

END SETTLEMENT_PROFILE_CALENDAR;
----------------------------------------------------------------------------------------------------
PROCEDURE SETTLEMENT_PROFILE_LIBRARY
	(
	p_PROFILE_LIBRARY_NAME IN VARCHAR,
	p_PROFILE_LIBRARY_ID OUT NUMBER
	) AS

BEGIN

	SELECT PROFILE_LIBRARY_ID
	INTO p_PROFILE_LIBRARY_ID
	FROM LOAD_PROFILE_LIBRARY
	WHERE PROFILE_LIBRARY_NAME = p_PROFILE_LIBRARY_NAME;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			IF SQL%NOTFOUND THEN
				SELECT OID.NEXTVAL INTO p_PROFILE_LIBRARY_ID FROM DUAL;
				INSERT INTO LOAD_PROFILE_LIBRARY(
					PROFILE_LIBRARY_ID,
					PROFILE_LIBRARY_NAME,
					PROFILE_LIBRARY_ALIAS,
					PROFILE_LIBRARY_DESC,
					ENTRY_DATE)
				VALUES(
					p_PROFILE_LIBRARY_ID,
					p_PROFILE_LIBRARY_NAME,
					SUBSTR(p_PROFILE_LIBRARY_NAME,1,32),
					'RetailOffice Created Settlement Profile Library',
					SYSDATE);
			END IF;

END SETTLEMENT_PROFILE_LIBRARY;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_SETTLEMENT_PROFILE
	(
	p_PROFILE_NAME IN VARCHAR,
	p_PROFILE_LIBRARY_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_INTERVAL IN NUMBER,
	p_PROFILE_ID OUT NUMBER
	) AS

BEGIN

	SELECT PROFILE_ID
	INTO p_PROFILE_ID
	FROM LOAD_PROFILE
	WHERE PROFILE_NAME = p_PROFILE_NAME;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			IF SQL%NOTFOUND THEN
				SELECT OID.NEXTVAL INTO p_PROFILE_ID FROM DUAL;
				INSERT INTO LOAD_PROFILE(
					PROFILE_LIBRARY_ID,
					PROFILE_ID,
					PROFILE_NAME,
					PROFILE_ALIAS,
					PROFILE_DESC,
					PROFILE_TYPE,
					PROFILE_OPERATION,
					PROFILE_ORIGIN,
					PROFILE_RATE_CLASS,
					PROFILE_DAY_TYPE,
					PROFILE_ACCOUNT_REF,
					PROFILE_METER_REF,
					PROFILE_SIC_CODE,
					PROFILE_SEASON,
					PROFILE_SYSTEM_LOAD,
					PROFILE_ADJUSTMENT_OPTION,
					PROFILE_STATION_ID,
					PROFILE_TEMPLATE_ID,
					PROFILE_SOURCE_BEGIN_DATE,
					PROFILE_SOURCE_END_DATE,
					PROFILE_SOURCE_ID,
					PROFILE_INTERVAL,
					PROFILE_SOURCE_VERSION,
					ENTRY_DATE)
				VALUES(
					p_PROFILE_LIBRARY_ID,
					p_PROFILE_ID,
					p_PROFILE_NAME,
					p_PROFILE_NAME,
					'RetailOffice Created Settlement Profile',
					'Historical',
					'Add',
					'RTO',
					GA.UNDEFINED_ATTRIBUTE,
					GA.UNDEFINED_ATTRIBUTE,
					GA.UNDEFINED_ATTRIBUTE,
					GA.UNDEFINED_ATTRIBUTE,
					GA.UNDEFINED_ATTRIBUTE,
					GA.UNDEFINED_ATTRIBUTE,
					GA.UNDEFINED_ATTRIBUTE,
					'None',
					0,
					0,
					NULL,
					NULL,
					0,
					p_INTERVAL,
					NULL,
					SYSDATE);
			END IF;

END PUT_SETTLEMENT_PROFILE;
----------------------------------------------------------------------------------------------------
PROCEDURE UPDT_CALENDAR_ASSIGNMENT_TYPE
	(
	p_CALENDAR_ID IN NUMBER
	) AS
--Updates CALENDAR.ASSIGNMENT_TYPE based on
--whether the calendar has been assigned to:
--  a Profile:    'P'
--  a Library:   'L'
--  Both:         'B'
--  or Nothing: 'N'

BEGIN

    UPDATE CALENDAR X
    SET X.ASSIGNMENT_TYPE =
        (SELECT DECODE(DECODE(NVL(B.CALENDAR_ID,0),0,0,1) + DECODE(NVL(C.CALENDAR_ID,0),0,0,2),0,'N',1,'P',2,'L',3,'B','?')
        FROM CALENDAR A, CALENDAR_PROFILE B, CALENDAR_PROFILE_LIBRARY C
        WHERE A.CALENDAR_ID = p_CALENDAR_ID
        AND B.CALENDAR_ID(+) = A.CALENDAR_ID
        AND C.CALENDAR_ID(+) = A.CALENDAR_ID
        GROUP BY B.CALENDAR_ID, C.CALENDAR_ID)
    WHERE X.CALENDAR_ID = p_CALENDAR_ID;

END UPDT_CALENDAR_ASSIGNMENT_TYPE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_CALENDAR_PROFILE
	(
	p_CALENDAR_ID IN NUMBER,
	p_PROFILE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	) AS

BEGIN

	UPDATE CALENDAR_PROFILE
	SET	END_DATE = p_END_DATE,
		ENTRY_DATE = SYSDATE
	WHERE CALENDAR_ID = p_CALENDAR_ID
		AND PROFILE_ID = p_PROFILE_ID
		AND BEGIN_DATE = TRUNC(p_BEGIN_DATE);

	IF SQL%NOTFOUND THEN
		INSERT INTO CALENDAR_PROFILE (
			CALENDAR_ID,
			PROFILE_ID,
			BEGIN_DATE,
			END_DATE,
			ENTRY_DATE)
		VALUES (
			p_CALENDAR_ID,
			p_PROFILE_ID,
			p_BEGIN_DATE,
			p_END_DATE,
			SYSDATE);
	END IF;

    --Update CALENDAR.ASSIGNMENT_TYPE
    UPDT_CALENDAR_ASSIGNMENT_TYPE(p_CALENDAR_ID);

END PUT_CALENDAR_PROFILE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_LOAD_PROFILE_STATISTICS
	(
	p_PROFILE_ID IN NUMBER,
	p_POINT_INDEX IN NUMBER,
	p_PROFILE_AS_OF_DATE IN DATE
	) AS

v_FROM_DATE DATE;
v_TO_DATE DATE;
v_PROFILE_MIN NUMBER;
v_PROFILE_MAX NUMBER;
v_PROFILE_SUM NUMBER;
v_PROFILE_COUNT NUMBER;
v_VERSION_ID NUMBER;
v_PROFILE_NZ_MIN NUMBER := 999999999;

BEGIN

	SELECT MIN(POINT_DATE), MAX(POINT_DATE), MIN(POINT_VAL), MIN(DECODE(POINT_VAL,0,999999999,POINT_VAL)), MAX(POINT_VAL), SUM(POINT_VAL), COUNT(*)
	INTO v_FROM_DATE, v_TO_DATE, v_PROFILE_MIN, v_PROFILE_NZ_MIN, v_PROFILE_MAX, v_PROFILE_SUM, v_PROFILE_COUNT
	FROM LOAD_PROFILE_POINT
	WHERE PROFILE_ID = p_PROFILE_ID
		AND POINT_INDEX = p_POINT_INDEX
		AND POINT_DATE = POINT_DATE
		AND AS_OF_DATE = p_PROFILE_AS_OF_DATE;

	UPDATE LOAD_PROFILE_STATISTICS SET
		FROM_DATE = v_FROM_DATE,
		TO_DATE = v_TO_DATE,
		PROFILE_COUNT = v_PROFILE_COUNT,
		PROFILE_MIN = v_PROFILE_MIN,
		PROFILE_NZ_MIN = DECODE(v_PROFILE_NZ_MIN,999999999,0,v_PROFILE_NZ_MIN),
		PROFILE_MAX = v_PROFILE_MAX,
		PROFILE_SUM = v_PROFILE_SUM,
		ENTRY_DATE = SYSDATE
	WHERE PROFILE_ID = p_PROFILE_ID
		AND AS_OF_DATE = p_PROFILE_AS_OF_DATE;

	IF SQL%NOTFOUND THEN
		v_VERSION_ID := GET_PROFILE_VERSION_ID(p_PROFILE_AS_OF_DATE);
		INSERT INTO LOAD_PROFILE_STATISTICS (
			PROFILE_ID,
			AS_OF_DATE,
			FROM_DATE,
			TO_DATE,
			PROFILE_COUNT,
			PROFILE_LOAD_FACTOR,
			PROFILE_MIN,
			PROFILE_NZ_MIN,
			PROFILE_MAX,
			PROFILE_SUM,
			PROFILE_MEAN_APE,
			PROFILE_AVG_DEV_APE,
            PROFILE_TOTAL_ERROR_PCT,
			R_SQUARED_MIN,
			R_SQUARED_MAX,
			R_SQUARED_FAIL_PCT,
			T_STAT_TEMP_FAIL_PCT,
			T_STAT_HUMID_FAIL_PCT,
			T_STAT_WIND_FAIL_PCT,
			PROFILE_STATUS,
			VERSION_ID,
			ENTRY_DATE)
		VALUES (
			p_PROFILE_ID,
			p_PROFILE_AS_OF_DATE,
			v_FROM_DATE,
			v_TO_DATE,
			v_PROFILE_COUNT,
			0, -- PROFILE_LOAD_FACTOR,
			v_PROFILE_MIN,
			DECODE(v_PROFILE_NZ_MIN,999999999,0,v_PROFILE_NZ_MIN), -- PROFILE_NZ_MIN,
			v_PROFILE_MAX,
			v_PROFILE_SUM,
			0, -- PROFILE_MEAN_APE,
			0, -- PROFILE_AVG_DEV_APE,
			0, -- PROFILE_TOTAL_ERROR_PCT,
			0, -- R_SQUARED_MIN,
			0, -- R_SQUARED_MAX,
			0, -- R_SQUARED_FAIL_PCT,
			0, -- T_STAT_TEMP_FAIL_PCT,
			0, -- T_STAT_HUMID_FAIL_PCT,
			0, -- T_STAT_WIND_FAIL_PCT,
			'Production', -- PROFILE_STATUS
			v_VERSION_ID,
			SYSDATE);
	END IF;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);

END PUT_LOAD_PROFILE_STATISTICS;
----------------------------------------------------------------------------------------------------
FUNCTION GET_ACCOUNT_CALENDAR_ID
	(
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_CALENDAR_TYPE IN VARCHAR
	) RETURN NUMBER IS

-- ANSWER THE ACCOUNT ASSIGNED CALENDAR ID ASSIGNMENT FOR THE SPECIFIED DAY
-- ANSWER CONSTANTS.NOT_ASSIGNED WHEN THERE IS NOT AN ASSIGNED CALENDAR.
-- IF A SETTLEMENT CALENDAR DOES NOT EXIST THEN ANSWER THE FORECAST CALENDAR
-- UNLESS THE REQUESTED CALENDAR TYPE IS "X" WHICH IS USED TO DETERMINE EXISTENCE.

v_CALENDAR_ID NUMBER;
v_CALENDAR_TYPE CHAR(1);
v_DOMAIN_NAME VARCHAR(32);

BEGIN

	SELECT DECODE(UPPER(SUBSTR(p_CALENDAR_TYPE,1,1)),'S','S','X','S','P','P','M','M','F') INTO v_CALENDAR_TYPE FROM DUAL;

	SELECT DECODE(UPPER(SUBSTR(p_CALENDAR_TYPE,1,1)),'S','Settlement','Forecasting') INTO v_DOMAIN_NAME FROM DUAL;

	BEGIN
		SELECT CALENDAR_ID
		INTO v_CALENDAR_ID
		FROM ACCOUNT_CALENDAR
		WHERE ACCOUNT_ID = p_ACCOUNT_ID
			AND UPPER(SUBSTR(CALENDAR_TYPE,1,1)) = v_CALENDAR_TYPE
			AND p_SERVICE_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE)
			AND ROWNUM = 1;

	 	EXCEPTION
			WHEN NO_DATA_FOUND THEN
				ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
				IF v_CALENDAR_TYPE = 'S' AND UPPER(SUBSTR(p_CALENDAR_TYPE,1,1)) = 'S' THEN
					v_CALENDAR_ID := GET_ACCOUNT_CALENDAR_ID(p_ACCOUNT_ID, p_SERVICE_DATE, 'F');
				ELSE
					v_CALENDAR_ID := CONSTANTS.NOT_ASSIGNED;
					g_OBJECT_NAME := CS.GET_ACCOUNT_NAME(p_ACCOUNT_ID);
					g_EVENT_TEXT := 'No Calendar Assignment for Account ' || g_OBJECT_NAME || ' on ' || TO_CHAR(p_SERVICE_DATE, 'MM/DD/YYYY');
					LOGS.LOG_WARN(g_EVENT_TEXT);
				END IF;
 		END;

	RETURN v_CALENDAR_ID;

END GET_ACCOUNT_CALENDAR_ID;
----------------------------------------------------------------------------------------------------
FUNCTION GET_METER_CALENDAR_ID
	(
	p_METER_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_CALENDAR_TYPE IN VARCHAR
	) RETURN NUMBER IS

-- Answer the meter assigned calendar id assignment for the specified day,
-- otherwise answer CONSTANTS.NOT_ASSIGNED when there is not an assigned calendar.
-- If a settlement calendar does not exist then answer the forecast calendar
-- unless the requested calendar type is "x" which is used to determine existence.

v_CALENDAR_ID NUMBER;
v_CALENDAR_TYPE CHAR(1);
v_DOMAIN_NAME VARCHAR(32);
BEGIN

	SELECT DECODE(UPPER(SUBSTR(p_CALENDAR_TYPE,1,1)),'S','S','X','S','M','M','F') INTO v_CALENDAR_TYPE FROM DUAL;

	SELECT DECODE(UPPER(SUBSTR(p_CALENDAR_TYPE,1,1)),'S','Settlement','Forecasting') INTO v_DOMAIN_NAME FROM DUAL;

	BEGIN
		SELECT CALENDAR_ID
		INTO v_CALENDAR_ID
		FROM METER_CALENDAR
		WHERE METER_ID = p_METER_ID
			AND UPPER(SUBSTR(CALENDAR_TYPE,1,1)) = v_CALENDAR_TYPE
			AND p_SERVICE_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE)
			AND ROWNUM = 1;

	 	EXCEPTION
			WHEN NO_DATA_FOUND THEN
				ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
				IF v_CALENDAR_TYPE = 'S' AND UPPER(SUBSTR(p_CALENDAR_TYPE,1,1)) = 'S' THEN
					v_CALENDAR_ID := GET_METER_CALENDAR_ID(p_METER_ID, p_SERVICE_DATE, 'Forecast');
				ELSE
					v_CALENDAR_ID := CONSTANTS.NOT_ASSIGNED;
					g_OBJECT_NAME := CS.GET_METER_NAME(p_METER_ID);
					g_EVENT_TEXT := 'No Calendar Assignment for Meter ' || g_OBJECT_NAME || ' on ' || TO_CHAR(p_SERVICE_DATE, 'MM/DD/YYYY');
					LOGS.LOG_WARN(g_EVENT_TEXT);
				END IF;
 		END;

	RETURN v_CALENDAR_ID;

END GET_METER_CALENDAR_ID;
----------------------------------------------------------------------------------------------------
FUNCTION GET_CALENDAR_PROFILE_ID
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_CALENDAR_ID IN NUMBER,
	p_EDC_ID IN NUMBER
	) RETURN NUMBER IS

-- Answer the profile id in effect for the specified calendar and service date.

v_ASSIGNMENT_TYPE CALENDAR.ASSIGNMENT_TYPE%TYPE := 'N';
v_HAS_ADJUSTMENTS CALENDAR.HAS_ADJUSTMENTS%TYPE := 0;
v_ASSIGNMENT_COUNT PLS_INTEGER := 0;
v_PROFILE_IDS GA.NUMBER_TABLE;

BEGIN

	COLLECT_CALENDAR_PROFILE_IDS(p_CAST_CONTEXT, p_CALENDAR_ID, p_EDC_ID, v_ASSIGNMENT_TYPE, v_HAS_ADJUSTMENTS, v_ASSIGNMENT_COUNT, v_PROFILE_IDS);

	IF v_PROFILE_IDS.COUNT > 0 THEN
		RETURN v_PROFILE_IDS(v_PROFILE_IDS.FIRST);
	ELSE
		RETURN CONSTANTS.NOT_ASSIGNED;
	END IF;

END GET_CALENDAR_PROFILE_ID;
----------------------------------------------------------------------------------------------------
FUNCTION GET_CALENDAR_PROFILE_ID
	(
	p_CALENDAR_ID IN NUMBER,
	p_SERVICE_DATE IN DATE
	) RETURN NUMBER IS

-- Answer the profile id in effect for the specified calendar and service date.
-- Select the first entry for multiple entries: the assumption is that the profile
-- is a historical settlement profile and that only one can be in effect.

v_PROFILE_ID NUMBER;

BEGIN

	SELECT PROFILE_ID
	INTO v_PROFILE_ID
	FROM CALENDAR_PROFILE
	WHERE CALENDAR_ID = p_CALENDAR_ID
		AND p_SERVICE_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE)
		AND ROWNUM = 1;

	RETURN v_PROFILE_ID;

 	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN CONSTANTS.NOT_ASSIGNED;

END GET_CALENDAR_PROFILE_ID;
----------------------------------------------------------------------------------------------------
FUNCTION GET_PROFILE_ID
	(
	p_ACCOUNT_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_CALENDAR_TYPE IN CHAR
	) RETURN NUMBER IS

-- Answer the assigned profile id for the account or meter model.

v_PROFILE_ID NUMBER;
v_CALENDAR_ID NUMBER;

BEGIN

	IF p_METER_ID = 0 THEN
		v_CALENDAR_ID := GET_ACCOUNT_CALENDAR_ID(p_ACCOUNT_ID, p_SERVICE_DATE, p_CALENDAR_TYPE);
	ELSE
		v_CALENDAR_ID := GET_METER_CALENDAR_ID(p_METER_ID, p_SERVICE_DATE, p_CALENDAR_TYPE);
	END IF;

	IF v_CALENDAR_ID = CONSTANTS.NOT_ASSIGNED THEN
		v_PROFILE_ID := CONSTANTS.NOT_ASSIGNED;
	ELSE
		v_PROFILE_ID := GET_CALENDAR_PROFILE_ID(v_CALENDAR_ID, p_SERVICE_DATE);
	END IF;

	RETURN v_PROFILE_ID;

END GET_PROFILE_ID;
----------------------------------------------------------------------------------------------------
PROCEDURE STORE_SETTLEMENT_PROFILE
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE
	) AS

v_INDEX BINARY_INTEGER;
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;

BEGIN

	IF g_POINT_PROFILE_ID.COUNT > 0 THEN
		IF LOGS.IS_DEBUG_DETAIL_ENABLED()THEN
			LOGS.LOG_DEBUG_DETAIL('STORE_SETTLEMENT_PROFILE');
			LOGS.LOG_DEBUG_DETAIL('AS_OF_DATE=' || UT.TRACE_DATE(p_CAST_CONTEXT.OUTPUT_AS_OF_DATE));
			LOGS.LOG_DEBUG_DETAIL('<profile id>,<point date>,<point val>,<index>');
			v_INDEX := g_POINT_PROFILE_ID.FIRST;
			WHILE v_INDEX <= g_POINT_PROFILE_ID.LAST LOOP
				LOGS.LOG_DEBUG_DETAIL(TO_CHAR(g_POINT_PROFILE_ID(v_INDEX)) || ',' || UT.TRACE_DATE(g_POINT_DATE(v_INDEX)) || ',' || TO_CHAR(g_POINT_VAL(v_INDEX)) || ',' || TO_CHAR(v_INDEX));
				v_INDEX := g_POINT_PROFILE_ID.NEXT(v_INDEX);
			END LOOP;
		END IF;

		FORALL v_INDEX IN g_POINT_PROFILE_ID.FIRST..g_POINT_PROFILE_ID.LAST
			INSERT INTO LOAD_PROFILE_POINT (PROFILE_ID, POINT_INDEX, POINT_DATE, AS_OF_DATE, POINT_VAL)
			VALUES (g_POINT_PROFILE_ID(v_INDEX), g_DEFAULT_POINT_INDEX, g_POINT_DATE(v_INDEX), p_CAST_CONTEXT.OUTPUT_AS_OF_DATE, g_POINT_VAL(v_INDEX));

		IF LOGS.IS_DEBUG_ENABLED() THEN
			LOGS.LOG_DEBUG('STORE_SETTLEMENT_PROFILE ELAPSED TIME='  || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED));
		END IF;
	ELSE
		IF LOGS.IS_DEBUG_ENABLED() THEN
			LOGS.LOG_DEBUG('STORE_SETTLEMENT_PROFILE: NO PROFILES BUFFERED');
		END IF;
	END IF;

END STORE_SETTLEMENT_PROFILE;
----------------------------------------------------------------------------------------------------
PROCEDURE SET_SETTLEMENT_PROFILE_STATS
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_PROFILE_AS_OF_DATE IN DATE
	) AS

v_INDEX BINARY_INTEGER;
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;

BEGIN

	IF g_SETTLEMENT_PROFILE_STATS.COUNT > 0 THEN
		v_INDEX := g_SETTLEMENT_PROFILE_STATS.FIRST;
		WHILE v_INDEX <= g_SETTLEMENT_PROFILE_STATS.LAST LOOP
			PUT_LOAD_PROFILE_STATISTICS(v_INDEX, g_DEFAULT_POINT_INDEX, p_PROFILE_AS_OF_DATE);
			v_INDEX := g_SETTLEMENT_PROFILE_STATS.NEXT(v_INDEX);
		END LOOP;
		g_SETTLEMENT_PROFILE_STATS.DELETE;

		IF LOGS.IS_DEBUG_ENABLED() THEN
			LOGS.LOG_DEBUG('SETTLEMENT_PROFILE_SETUP ELAPSED TIME='  || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED));
		END IF;
	END IF;

END SET_SETTLEMENT_PROFILE_STATS;
----------------------------------------------------------------------------------------------------
PROCEDURE SETTLEMENT_PROFILE_SETUP
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_PROFILE_LIBRARY_NAME IN VARCHAR,
	p_PROFILE_NAME IN VARCHAR,
	p_ACCOUNT_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_INTERVAL IN NUMBER
	) AS

-- Setup a Calendar, Load Profile Library, and Load Profile to contain a Settlement Profile.

v_CALENDAR_ID NUMBER;
v_PROFILE_LIBRARY_ID NUMBER;
v_PROFILE_ID NUMBER;

BEGIN

	IF LOGS.IS_DEBUG_DETAIL_ENABLED()THEN
		LOGS.LOG_DEBUG_DETAIL('SETTLEMENT_PROFILE_SETUP');
		LOGS.LOG_DEBUG_DETAIL('PROFILE_LIBRARY_NAME='  || p_PROFILE_LIBRARY_NAME);
		LOGS.LOG_DEBUG_DETAIL('PROFILE_NAME='  || p_PROFILE_NAME);
		LOGS.LOG_DEBUG_DETAIL('PROFILE_LIBRARY_NAME='  || p_PROFILE_LIBRARY_NAME);
		LOGS.LOG_DEBUG_DETAIL('ACCOUNT_ID='  || TO_CHAR(p_ACCOUNT_ID));
		LOGS.LOG_DEBUG_DETAIL('METER_ID='  || TO_CHAR(p_METER_ID));
	END IF;

	SETTLEMENT_PROFILE_CALENDAR(p_PROFILE_NAME, v_CALENDAR_ID);
	SETTLEMENT_PROFILE_LIBRARY(p_PROFILE_LIBRARY_NAME, v_PROFILE_LIBRARY_ID);
	PUT_SETTLEMENT_PROFILE(p_PROFILE_NAME, v_PROFILE_LIBRARY_ID, p_ACCOUNT_ID, p_METER_ID, p_INTERVAL, v_PROFILE_ID);

	IF LOGS.IS_DEBUG_DETAIL_ENABLED()THEN
		LOGS.LOG_DEBUG_DETAIL('CALENDAR_ID='  || TO_CHAR(v_CALENDAR_ID));
		LOGS.LOG_DEBUG_DETAIL('PROFILE_LIBRARY_ID='  || TO_CHAR(v_PROFILE_LIBRARY_ID));
		LOGS.LOG_DEBUG_DETAIL('PROFILE_ID='  || TO_CHAR(v_PROFILE_ID));
	END IF;

	IF p_METER_ID = CONSTANTS.NOT_ASSIGNED THEN
		PUT_ACCOUNT_CALENDAR(p_ACCOUNT_ID, v_CALENDAR_ID, 'Settlement', LOW_DATE, NULL);
	ELSE
		PUT_METER_CALENDAR(p_METER_ID, v_CALENDAR_ID, 'Settlement', LOW_DATE, NULL);
	END IF;

	PUT_CALENDAR_PROFILE(v_CALENDAR_ID, v_PROFILE_ID, LOW_DATE, NULL);

END SETTLEMENT_PROFILE_SETUP;
----------------------------------------------------------------------------------------------------
PROCEDURE SETTLEMENT_PROFILE_SETUP
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE
	) AS

-- Setup a Calendar, Load Profile Library, and Load Profile to contain a Settlement Profile.

CURSOR c_SETUP IS
	SELECT E.ACCOUNT_ID, E.METER_ID, A.ACCOUNT_NAME "PROFILE_NAME", D.EDC_NAME, D.EDC_ALIAS
	FROM ACCOUNT A, ACCOUNT_STATUS B, ACCOUNT_STATUS_NAME STATUS_NAME, ACCOUNT_EDC C, ENERGY_DISTRIBUTION_COMPANY D, ACCOUNT_SERVICE E
	WHERE UPPER(SUBSTR(A.ACCOUNT_MODEL_OPTION,1,1)) = 'A'
		AND A.IS_CREATE_SETTLEMENT_PROFILE = 1
        AND A.IS_SUB_AGGREGATE = 0
		AND A.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
		AND B.ACCOUNT_ID = A.ACCOUNT_ID
		AND p_CAST_CONTEXT.SERVICE_DATE BETWEEN B.BEGIN_DATE AND NVL(B.END_DATE, p_CAST_CONTEXT.SERVICE_DATE)
		AND STATUS_NAME.STATUS_NAME = B.STATUS_NAME
		AND STATUS_NAME.IS_ACTIVE = 1
		AND NOT EXISTS
			(SELECT 1
			FROM ACCOUNT_CALENDAR X
			WHERE X.ACCOUNT_ID = B.ACCOUNT_ID
				AND X.CALENDAR_TYPE = 'Settlement'
				AND p_CAST_CONTEXT.SERVICE_DATE BETWEEN X.BEGIN_DATE AND NVL(X.END_DATE, p_CAST_CONTEXT.SERVICE_DATE))
		AND A.ACCOUNT_ID = C.ACCOUNT_ID
		AND p_CAST_CONTEXT.SERVICE_DATE BETWEEN C.BEGIN_DATE AND NVL(C.END_DATE, p_CAST_CONTEXT.SERVICE_DATE)
		AND D.EDC_ID = C.EDC_ID
		AND E.ACCOUNT_ID = A.ACCOUNT_ID
	UNION ALL SELECT C.ACCOUNT_ID, C.METER_ID, F.METER_NAME "PROFILE_NAME", E.EDC_NAME, E.EDC_ALIAS
	FROM ACCOUNT A, ACCOUNT_STATUS B, ACCOUNT_STATUS_NAME STATUS_NAME, ACCOUNT_SERVICE C, ACCOUNT_EDC D, ENERGY_DISTRIBUTION_COMPANY E, METER F
	WHERE UPPER(SUBSTR(A.ACCOUNT_MODEL_OPTION,1,1)) = 'M'
        AND A.IS_SUB_AGGREGATE = 0
		AND A.IS_CREATE_SETTLEMENT_PROFILE = 1
		AND B.ACCOUNT_ID = A.ACCOUNT_ID
		AND p_CAST_CONTEXT.SERVICE_DATE BETWEEN B.BEGIN_DATE AND NVL(B.END_DATE, p_CAST_CONTEXT.SERVICE_DATE)
		AND STATUS_NAME.STATUS_NAME = B.STATUS_NAME
		AND STATUS_NAME.IS_ACTIVE = 1
		AND C.ACCOUNT_ID = B.ACCOUNT_ID
		AND NOT EXISTS
			(SELECT 1
			FROM METER_CALENDAR X
			WHERE X.METER_ID = C.METER_ID
				AND X.CALENDAR_TYPE = 'Settlement'
				AND p_CAST_CONTEXT.SERVICE_DATE BETWEEN X.BEGIN_DATE AND NVL(X.END_DATE, p_CAST_CONTEXT.SERVICE_DATE))
		AND D.ACCOUNT_ID = A.ACCOUNT_ID
		AND p_CAST_CONTEXT.SERVICE_DATE BETWEEN D.BEGIN_DATE AND NVL(D.END_DATE, p_CAST_CONTEXT.SERVICE_DATE)
		AND E.EDC_ID = D.EDC_ID
		AND F.METER_ID = C.METER_ID
		AND A.MODEL_ID = p_CAST_CONTEXT.MODEL_ID;

v_PROFILE_NAME LOAD_PROFILE.PROFILE_NAME%TYPE;
v_PROFILE_LIBRARY_NAME LOAD_PROFILE_LIBRARY.PROFILE_LIBRARY_NAME%TYPE;
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;
v_PROFILE_INTERVAL LOAD_PROFILE.PROFILE_INTERVAL%TYPE;

BEGIN

	FOR v_SETUP IN c_SETUP LOOP
		v_PROFILE_NAME := 'S_' || v_SETUP.PROFILE_NAME;
		IF LENGTH(v_SETUP.EDC_NAME) > LENGTH(v_SETUP.EDC_ALIAS) THEN
			v_PROFILE_LIBRARY_NAME := v_SETUP.EDC_ALIAS || ' Settlement Profiles';
		ELSE
			v_PROFILE_LIBRARY_NAME := v_SETUP.EDC_NAME || ' Settlement Profiles';
		END IF;
		v_PROFILE_LIBRARY_NAME := SUBSTR(v_PROFILE_LIBRARY_NAME, 1, LEAST(LENGTH(v_PROFILE_LIBRARY_NAME), 64));

		IF p_CAST_CONTEXT.MODEL_ID = GA.ELECTRIC_MODEL THEN
			v_PROFILE_INTERVAL := 24;
		ELSIF p_CAST_CONTEXT.MODEL_ID = GA.GAS_MODEL THEN
			v_PROFILE_INTERVAL := 1;
		ELSE
			v_PROFILE_INTERVAL := 0;
		END IF;

		SETTLEMENT_PROFILE_SETUP(p_CAST_CONTEXT, v_PROFILE_LIBRARY_NAME, v_PROFILE_NAME, v_SETUP.ACCOUNT_ID, v_SETUP.METER_ID, v_PROFILE_INTERVAL);
	END LOOP;

	IF LOGS.IS_DEBUG_ENABLED() THEN
		LOGS.LOG_DEBUG('SETTLEMENT_PROFILE_SETUP ELAPSED TIME='  || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED));
	END IF;

END SETTLEMENT_PROFILE_SETUP;
----------------------------------------------------------------------------------------------------
PROCEDURE DELETE_SETTLEMENT_PROFILE
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE
	) AS

v_INDEX BINARY_INTEGER;
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;
v_BEGIN_DATE DATE := HIGH_DATE;
v_END_DATE DATE := LOW_DATE;
v_IDS GA.ID_TABLE;
v_PIDS ID_TABLE := ID_TABLE();

BEGIN

	v_INDEX := g_POINT_PROFILE_ID.FIRST;
	WHILE v_INDEX <= g_POINT_PROFILE_ID.LAST LOOP
		IF NOT v_IDS.EXISTS(g_POINT_PROFILE_ID(v_INDEX)) THEN
			v_IDS(g_POINT_PROFILE_ID(v_INDEX)) := g_POINT_PROFILE_ID(v_INDEX);
		END IF;
		IF g_POINT_DATE(v_INDEX) < v_BEGIN_DATE THEN
			v_BEGIN_DATE := g_POINT_DATE(v_INDEX);
		END IF;
		IF g_POINT_DATE(v_INDEX) > v_END_DATE THEN
			v_END_DATE := g_POINT_DATE(v_INDEX);
		END IF;
		v_INDEX := g_POINT_PROFILE_ID.NEXT(v_INDEX);
	END LOOP;

	v_INDEX := v_IDS.FIRST;
	WHILE v_INDEX <= v_IDS.LAST LOOP
		v_PIDS.EXTEND;
		v_PIDS(v_PIDS.LAST) := ID_TYPE(v_IDS(v_INDEX));
		v_INDEX := v_IDS.NEXT(v_INDEX);
	END LOOP;

	IF LOGS.IS_DEBUG_DETAIL_ENABLED()THEN
		LOGS.LOG_DEBUG_DETAIL('DELETE_SETTLEMENT_PROFILE');
		LOGS.LOG_DEBUG_DETAIL('BEGIN_DATE=' || UT.TRACE_DATE(v_BEGIN_DATE));
		LOGS.LOG_DEBUG_DETAIL('END_DATE=' || UT.TRACE_DATE(v_END_DATE));
		LOGS.LOG_DEBUG_DETAIL('POINT_PROFILE_ID.COUNT=' || TO_CHAR(g_POINT_PROFILE_ID.COUNT));
		LOGS.LOG_DEBUG_DETAIL('POINT_DATE.COUNT=' || TO_CHAR(g_POINT_DATE.COUNT));
		LOGS.LOG_DEBUG_DETAIL('IDS.COUNT=' || TO_CHAR(v_IDS.COUNT));
		LOGS.LOG_DEBUG_DETAIL('PIDS.COUNT=' || TO_CHAR(v_PIDS.COUNT));
		LOGS.LOG_DEBUG_DETAIL('PIDS LIST...');
		v_INDEX := v_PIDS.FIRST;
		WHILE v_INDEX <= v_PIDS.LAST LOOP
			LOGS.LOG_DEBUG_DETAIL(TO_CHAR(v_PIDS(v_INDEX).ID) || '@' || TO_CHAR(v_INDEX));
			v_INDEX := v_PIDS.NEXT(v_INDEX);
		END LOOP;
	END IF;

	v_INDEX := v_PIDS.FIRST;
   WHILE v_INDEX <= v_PIDS.LAST LOOP
		DELETE LOAD_PROFILE_POINT
		WHERE PROFILE_ID = v_PIDS(v_INDEX).ID
			AND POINT_INDEX = g_DEFAULT_POINT_INDEX
			AND POINT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE;
		v_INDEX := v_PIDS.NEXT(v_INDEX);
	END LOOP;


	IF LOGS.IS_DEBUG_DETAIL_ENABLED()THEN
		SELECT COUNT(1)
		INTO v_INDEX
		FROM LOAD_PROFILE_POINT
		WHERE PROFILE_ID IN (SELECT X.ID FROM TABLE(CAST(v_PIDS AS ID_TABLE)) X)
			AND POINT_INDEX = g_DEFAULT_POINT_INDEX
			AND POINT_DATE	BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND AS_OF_DATE = p_CAST_CONTEXT.OUTPUT_AS_OF_DATE;
		LOGS.LOG_DEBUG_DETAIL('DELETE TARGET COUNT=' || TO_CHAR(v_INDEX));
	END IF;

	IF LOGS.IS_DEBUG_ENABLED() THEN
		LOGS.LOG_DEBUG('DELETE_SETTLEMENT_PROFILE ELAPSED TIME='  || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED));
	END IF;

END DELETE_SETTLEMENT_PROFILE;
----------------------------------------------------------------------------------------------------
PROCEDURE ACTUAL_USAGE_PROFILE
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_ACCOUNT_SERVICE_ID IN NUMBER,
	p_PROVIDER_SERVICE_ID IN NUMBER,
	p_CALENDAR_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_HAS_PROXY_PROFILE OUT BOOLEAN,
	p_PROFILE_SOURCE_DATE OUT DATE,
	p_PROFILE IN OUT NOCOPY GA.NUMBER_TABLE
	) AS

-- Answer the Proxy Profile derived from Actual Usage data for the specified Service Date

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_INDEX BINARY_INTEGER;
v_INTERVAL_INDEX BINARY_INTEGER;
v_VALUES_PER_STANDARD_DAY NUMBER(4);
v_VALUES_EXPECTED PLS_INTEGER;
v_INTERVAL VARCHAR2(16);
v_USAGE USAGE_TABLE := USAGE_TABLE();

v_SCENARIO_ID NUMBER(9) := GA.BASE_SCENARIO_ID; -- USE THE BASE USAGE ALLOCATION

BEGIN

	IF LOGS.IS_DEBUG_DETAIL_ENABLED()THEN
		LOGS.LOG_DEBUG_DETAIL('ACTUAL_PROXY_PROFILE');
		LOGS.LOG_DEBUG_DETAIL('ACCOUNT_SERVICE_ID=' || TO_CHAR(p_ACCOUNT_SERVICE_ID));
		LOGS.LOG_DEBUG_DETAIL('PROVIDER_SERVICE_ID=' || TO_CHAR(p_PROVIDER_SERVICE_ID));
	END IF;

    v_INTERVAL := GET_INTERVAL_FOR_CALENDAR(p_CALENDAR_ID, p_SERVICE_DATE);

	IF v_INTERVAL IS NULL THEN
		LOGS.LOG_WARN('Interval for '||TEXT_UTIL.TO_CHAR_ENTITY(p_CALENDAR_ID, EC.ED_CALENDAR, TRUE)||' is not recognized.');
		v_VALUES_EXPECTED := 24;
        v_VALUES_PER_STANDARD_DAY := 24;
		v_INTERVAL := DATE_UTIL.c_NAME_HOUR;
	ELSE
		v_VALUES_EXPECTED := DATE_UTIL.GET_INTERVAL_DIVISOR('Day', v_INTERVAL, p_SERVICE_DATE, GA.LOCAL_TIME_ZONE);
        v_VALUES_PER_STANDARD_DAY := DATE_UTIL.GET_INTERVAL_DIVISOR('Day', v_INTERVAL, p_SERVICE_DATE, CUT_TIME_ZONE);
	END IF;

	UT.CUT_DAY_INTERVAL_RANGE(p_CAST_CONTEXT.MODEL_ID, p_SERVICE_DATE, p_SERVICE_DATE, LOCAL_TIME_ZONE,
		GET_INTERVAL_ABBREVIATION(v_INTERVAL), v_BEGIN_DATE, v_END_DATE);

	IF GA.VERSION_ACTUAL THEN
		SELECT USAGE_TYPE(B.LOAD_DATE, B.LOAD_VAL)
		BULK COLLECT INTO v_USAGE
		FROM SERVICE A, SERVICE_LOAD B
		WHERE A.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
			AND A.SCENARIO_ID = v_SCENARIO_ID
			AND A.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM SERVICE
				WHERE MODEL_ID = A.MODEL_ID
					AND SCENARIO_ID = A.SCENARIO_ID
					AND AS_OF_DATE <= p_CAST_CONTEXT.OUTPUT_AS_OF_DATE
					AND ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
					AND PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID)
			AND A.ACCOUNT_SERVICE_ID = p_ACCOUNT_SERVICE_ID
			AND B.SERVICE_ID = A.SERVICE_ID
			AND B.SERVICE_CODE = GA.ACTUAL_SERVICE
			AND B.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND B.LOAD_CODE = GA.STANDARD;
	ELSE
		SELECT USAGE_TYPE(B.LOAD_DATE, B.LOAD_VAL)
		BULK COLLECT INTO v_USAGE
		FROM SERVICE A, SERVICE_LOAD B
		WHERE A.MODEL_ID = p_CAST_CONTEXT.MODEL_ID
			AND A.SCENARIO_ID = v_SCENARIO_ID
			AND A.AS_OF_DATE = g_LOW_DATE
			AND A.ACCOUNT_SERVICE_ID = p_ACCOUNT_SERVICE_ID
			AND B.SERVICE_ID = A.SERVICE_ID
			AND B.SERVICE_CODE = GA.ACTUAL_SERVICE
			AND B.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND B.LOAD_CODE = GA.STANDARD;
	END IF;

	IF v_USAGE.COUNT = 0 THEN
		p_HAS_PROXY_PROFILE := FALSE;
		p_PROFILE_SOURCE_DATE := NULL;
	ELSE
		IF v_USAGE.COUNT <> v_VALUES_EXPECTED THEN
			LOGS.LOG_WARN('Expected: ' || v_VALUES_EXPECTED || '   Received: ' || v_USAGE.COUNT);
			LOGS.LOG_WARN(TEXT_UTIL.TO_CHAR_DATE(p_SERVICE_DATE) || ' was discarded because it lacks data.');
            p_HAS_PROXY_PROFILE := FALSE;
            p_PROFILE_SOURCE_DATE := NULL;
            v_USAGE.DELETE;
            RETURN;
        END IF;

		-- now fill outbound array with data
		p_PROFILE.DELETE;
		FW.FILL_PROFILE(v_VALUES_EXPECTED, p_PROFILE);
		p_HAS_PROXY_PROFILE := TRUE;
		p_PROFILE_SOURCE_DATE := p_SERVICE_DATE;
		v_INDEX := v_USAGE.FIRST;
		WHILE v_INDEX <= v_USAGE.LAST LOOP
			v_INTERVAL_INDEX := ROUND((v_USAGE(v_INDEX).USAGE_DATE - v_BEGIN_DATE) * v_VALUES_PER_STANDARD_DAY) + 1;
			p_PROFILE(v_INTERVAL_INDEX) := v_USAGE(v_INDEX).USAGE_VAL;
			v_INDEX := v_USAGE.NEXT(v_INDEX);
		END LOOP;
		IF LOGS.IS_DEBUG_DETAIL_ENABLED()THEN
			TRACE_TABLE(g_ACTUAL_USAGE_PROFILE, p_PROFILE);
		END IF;
	END IF;

END ACTUAL_USAGE_PROFILE;
----------------------------------------------------------------------------------------------------
PROCEDURE CHECK_PROXY_DAY_DATA_COMPLETE
	(
	p_SERVICE_DATE IN DATE,
	p_CUT_BEGIN_DATE IN DATE,
	p_CUT_END_DATE IN DATE,
	p_COMPARATIVE_VALUE IN CHAR,
	p_STATION_ID IN NUMBER,
	p_PARAMETER_ID IN NUMBER,
	p_SYSTEM_LOAD_ID IN NUMBER,
	p_WEATHER_CASE_ID IN NUMBER,
	p_PARAMETER_CODE IN CHAR,
	p_AREA_LOAD_CASE_ID IN NUMBER,
	p_LOAD_CODE IN CHAR,
	p_INTERVAL IN VARCHAR2,
	p_IS_DAILY OUT BOOLEAN,
	p_IS_COMPLETE OUT BOOLEAN
	) AS

v_BEGIN_DATE		DATE;
v_END_DATE			DATE;
v_VALUES_EXPECTED	PLS_INTEGER;
v_VALUES_FOUND		PLS_INTEGER;

BEGIN

	-- how many values do we need to find?
	v_VALUES_EXPECTED := DATE_UTIL.GET_INTERVAL_DIVISOR('Day', p_INTERVAL, p_SERVICE_DATE, GA.LOCAL_TIME_ZONE);

	-- see if this comparative value has a full set of data
	IF p_COMPARATIVE_VALUE = 'W' THEN
		IF v_VALUES_EXPECTED = 1 THEN
			-- daily data? just the one date
			v_BEGIN_DATE := p_SERVICE_DATE;
			v_END_DATE := p_SERVICE_DATE;
			p_IS_DAILY := TRUE;
		ELSE
			-- otherwise, it's interval data, so we need CUT date/times
			v_BEGIN_DATE := p_CUT_BEGIN_DATE;
			v_END_DATE := p_CUT_END_DATE;
			p_IS_DAILY := FALSE;
		END IF;

		-- how many values are actually there?
		SELECT COUNT(1)
		INTO v_VALUES_FOUND
		FROM STATION_PARAMETER_VALUE V
		WHERE V.CASE_ID = p_WEATHER_CASE_ID
			AND V.STATION_ID = p_STATION_ID
			AND V.PARAMETER_ID = p_PARAMETER_ID
			AND V.PARAMETER_CODE = p_PARAMETER_CODE
			AND V.PARAMETER_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE;

	ELSE -- v_PDM.COMPARATIVE_VALUE = 'S'

		IF v_VALUES_EXPECTED = 1 THEN
			-- daily data? just the one date
			v_BEGIN_DATE := p_SERVICE_DATE;
			v_END_DATE := p_SERVICE_DATE;
			p_IS_DAILY := TRUE;
		ELSE
			-- otherwise, it's interval data, so we need CUT date/times
			v_BEGIN_DATE := p_CUT_BEGIN_DATE;
			v_END_DATE := p_CUT_END_DATE;
			p_IS_DAILY := FALSE;
		END IF;

		-- how many values are actually there?
		SELECT COUNT(1)
		INTO v_VALUES_FOUND
		FROM (SELECT DISTINCT AL.LOAD_DATE
			  FROM SYSTEM_LOAD_AREA SLA,
					AREA_LOAD AL
			  WHERE SLA.SYSTEM_LOAD_ID = p_SYSTEM_LOAD_ID
				AND AL.CASE_ID = p_AREA_LOAD_CASE_ID
				AND AL.AREA_ID = SLA.AREA_ID
				AND AL.LOAD_CODE = p_LOAD_CODE
				AND AL.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND AL.AS_OF_DATE = CONSTANTS.LOW_DATE);
	END IF;

	p_IS_COMPLETE := v_VALUES_EXPECTED = v_VALUES_FOUND;

END CHECK_PROXY_DAY_DATA_COMPLETE;
----------------------------------------------------------------------------------------------------
FUNCTION PRUNE_PROXY_DAY_METHODS
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_PROXY_DAY_METHOD_IDs IN ID_TABLE
	) RETURN NUMBER_COLLECTION IS

v_COMPARATIVE_VAL		VARCHAR2(21);
v_LAST_COMPARATIVE_VAL	VARCHAR2(21);
v_IS_DAILY				BOOLEAN;
v_KEEP					BOOLEAN;
v_RET					NUMBER_COLLECTION := NUMBER_COLLECTION();
v_CUT_BEGIN_DATE		DATE;
v_CUT_END_DATE			DATE;

CURSOR cur_PDMs IS
	SELECT DISTINCT PDM.PROXY_DAY_METHOD_ID,
		PDM.COMPARATIVE_VALUE,
		PDM.STATION_ID,
		PDM.PARAMETER_ID,
		PDM.SYSTEM_LOAD_ID,
		NVL(WP.PARAMETER_INTERVAL, SL.SYSTEM_LOAD_INTERVAL) AS PDM_INTERVAL
	FROM PROXY_DAY_METHOD PDM,
		TABLE(CAST(p_PROXY_DAY_METHOD_IDs as ID_TABLE)) IDs,
		WEATHER_PARAMETER WP,
		SYSTEM_LOAD SL
	WHERE PDM.PROXY_DAY_METHOD_ID = IDs.ID
		AND WP.PARAMETER_ID (+) = PDM.PARAMETER_ID
		AND SL.SYSTEM_LOAD_ID (+) = PDM.SYSTEM_LOAD_ID
	ORDER BY 2,3,4,5;

BEGIN

	FOR v_PDM IN cur_PDMs LOOP
		UT.CUT_DATE_RANGE(p_CAST_CONTEXT.MODEL_ID, p_CAST_CONTEXT.SERVICE_DATE, p_CAST_CONTEXT.SERVICE_DATE,
			GA.LOCAL_TIME_ZONE, GET_INTERVAL_ABBREVIATION(v_PDM.PDM_INTERVAL), v_CUT_BEGIN_DATE, v_CUT_END_DATE);

		v_COMPARATIVE_VAL := v_PDM.COMPARATIVE_VALUE||':'||
			CASE v_PDM.COMPARATIVE_VALUE WHEN 'W' THEN TO_CHAR(v_PDM.STATION_ID)||':'||TO_CHAR(v_PDM.PARAMETER_ID)
										 ELSE TO_CHAR(v_PDM.SYSTEM_LOAD_ID)
										 END;
		IF v_LAST_COMPARATIVE_VAL IS NULL OR v_COMPARATIVE_VAL <> v_LAST_COMPARATIVE_VAL THEN
			-- do we have a full set of data?
			CHECK_PROXY_DAY_DATA_COMPLETE(p_CAST_CONTEXT.SERVICE_DATE, v_CUT_BEGIN_DATE, v_CUT_END_DATE,
										v_PDM.COMPARATIVE_VALUE, v_PDM.STATION_ID, v_PDM.PARAMETER_ID, v_PDM.SYSTEM_LOAD_ID,
										p_CAST_CONTEXT.WEATHER_CASE_ID, p_CAST_CONTEXT.WEATHER_PARAMETER_CODE,
										p_CAST_CONTEXT.AREA_LOAD_CASE_ID, p_CAST_CONTEXT.SYSTEM_LOAD_CODE, v_PDM.PDM_INTERVAL,
										v_IS_DAILY, v_KEEP);
			v_LAST_COMPARATIVE_VAL := v_COMPARATIVE_VAL;
		END IF;

		IF v_KEEP THEN
			-- we have a full set of data, so add this proxy day method ID to the list
			v_RET.EXTEND();
			v_RET(v_RET.LAST) := v_PDM.PROXY_DAY_METHOD_ID;
		ELSIF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG(TEXT_UTIL.TO_CHAR_ENTITY(v_PDM.PROXY_DAY_METHOD_ID, EC.ED_PROXY_DAY_METHOD, TRUE)
				|| ' was discarded because it did not have a full set of data for ' ||
				TEXT_UTIL.TO_CHAR_DATE(p_CAST_CONTEXT.SERVICE_DATE) || '.');
		END IF;

	END LOOP;

	RETURN v_RET;

END PRUNE_PROXY_DAY_METHODS;
----------------------------------------------------------------------------------------------------
PROCEDURE CALCULATE_CANDIDATE_DELTAS
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE
	) AS

v_LAST_COMPARATIVE_VALUE	PROXY_DAY_METHOD_WORK.COMPARATIVE_VALUE%TYPE;
v_LAST_STATION_ID			PROXY_DAY_METHOD_WORK.STATION_ID%TYPE;
v_LAST_PARAMETER_ID			PROXY_DAY_METHOD_WORK.PARAMETER_ID%TYPE;
v_LAST_SYSTEM_LOAD_ID		PROXY_DAY_METHOD_WORK.SYSTEM_LOAD_ID%TYPE;
v_LAST_DAY					PROXY_DAY_METHOD_WORK.CANDIDATE_DAY%TYPE;
v_LAST_PROXY_DAY_METHOD_ID	PROXY_DAY_METHOD_WORK.PROXY_DAY_METHOD_ID%TYPE;
v_LAST_HOLIDAY_SET_ID		PROXY_DAY_METHOD_WORK.HOLIDAY_SET_ID%TYPE;
v_DELTA						NUMBER;
v_COUNT						PLS_INTEGER;
v_CUT_BEGIN_DATE			DATE;
v_CUT_END_DATE				DATE;
v_BEGIN_DATE				DATE;
v_END_DATE					DATE;
v_SVC_CUT_BEGIN_DATE		DATE;
v_SVC_CUT_END_DATE			DATE;
v_SVC_BEGIN_DATE			DATE;
v_SVC_END_DATE				DATE;
v_IS_DAILY					BOOLEAN;
v_IS_COMPLETE				BOOLEAN;

CURSOR cur_CANDIDATE_EVAL IS
	SELECT *
	FROM PROXY_DAY_METHOD_WORK
	ORDER BY COMPARATIVE_VALUE, STATION_ID, PARAMETER_ID, SYSTEM_LOAD_ID, CANDIDATE_DAY
	FOR UPDATE;

CURSOR cur_CANDIDATE_RETAIN IS
	SELECT *
	FROM PROXY_DAY_METHOD_WORK
	WHERE NVL(LOOKUP_CANDIDATE_LIMIT,0) > 0
	ORDER BY PROXY_DAY_METHOD_ID, HOLIDAY_SET_ID, CANDIDATE_DELTA ASC
	FOR UPDATE;

BEGIN

	UT.CUT_DATE_RANGE(p_CAST_CONTEXT.SERVICE_DATE, p_CAST_CONTEXT.SERVICE_DATE, GA.LOCAL_TIME_ZONE, v_SVC_CUT_BEGIN_DATE, v_SVC_CUT_END_DATE);

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('---------------------------------------------------------------------------------');
		LOGS.LOG_DEBUG('Calculating deltas for proxy day forecast.');
	END IF;

	-- evaluate each candidate
	FOR v_CANDIDATE IN cur_CANDIDATE_EVAL LOOP

		-- if this candidate is for different date or for different comparative values than last
		-- row then calculate the delta
		IF v_LAST_COMPARATIVE_VALUE IS NULL OR v_LAST_COMPARATIVE_VALUE <> v_CANDIDATE.COMPARATIVE_VALUE
		   OR v_LAST_STATION_ID <> v_CANDIDATE.STATION_ID OR v_LAST_PARAMETER_ID <> v_CANDIDATE.PARAMETER_ID
		   OR v_LAST_SYSTEM_LOAD_ID <> v_CANDIDATE.SYSTEM_LOAD_ID OR v_LAST_DAY <> v_CANDIDATE.CANDIDATE_DAY THEN

			IF v_LAST_DAY IS NULL OR v_LAST_DAY <> v_CANDIDATE.CANDIDATE_DAY THEN
				UT.CUT_DATE_RANGE(p_CAST_CONTEXT.MODEL_ID, v_CANDIDATE.CANDIDATE_DAY, v_CANDIDATE.CANDIDATE_DAY,
					GA.LOCAL_TIME_ZONE, GET_INTERVAL_ABBREVIATION(v_CANDIDATE.PDM_INTERVAL), v_CUT_BEGIN_DATE, v_CUT_END_DATE);
			END IF;

		    -- first, check that we have a full set of data for this day
			CHECK_PROXY_DAY_DATA_COMPLETE(v_CANDIDATE.CANDIDATE_DAY, v_CUT_BEGIN_DATE, v_CUT_END_DATE,
											v_CANDIDATE.COMPARATIVE_VALUE, v_CANDIDATE.STATION_ID, v_CANDIDATE.PARAMETER_ID, v_CANDIDATE.SYSTEM_LOAD_ID,
											-- always comparing to base-case actual data
											GA.BASE_CASE_ID, 'A', GA.BASE_CASE_ID, 'A', v_CANDIDATE.PDM_INTERVAL,
											v_IS_DAILY, v_IS_COMPLETE);
			IF v_IS_COMPLETE THEN

				-- determine proper date ranges for querying interval data
				IF v_IS_DAILY THEN
					v_SVC_BEGIN_DATE := p_CAST_CONTEXT.SERVICE_DATE;
					v_SVC_END_DATE := p_CAST_CONTEXT.SERVICE_DATE;
					v_BEGIN_DATE := v_CANDIDATE.CANDIDATE_DAY;
					v_END_DATE := v_CANDIDATE.CANDIDATE_DAY;
				ELSE
					v_SVC_BEGIN_DATE := v_SVC_CUT_BEGIN_DATE;
					v_SVC_END_DATE := v_SVC_CUT_END_DATE;
					v_BEGIN_DATE := v_CUT_BEGIN_DATE;
					v_END_DATE := v_CUT_END_DATE;
				END IF;

				-- now compute the delta - RMS of deltas
				IF v_CANDIDATE.COMPARATIVE_VALUE = 'W' THEN

					-- Compare weather parameter values
					SELECT SQRT(AVG((AD.PARAMETER_VAL - PD.PARAMETER_VAL) * (AD.PARAMETER_VAL - PD.PARAMETER_VAL)))
					INTO v_DELTA
						-- comparing base-case actual data from candidate day...
					FROM (SELECT PI.PARAMETER_VAL,
							PI.PARAMETER_DATE,
							ROWNUM as SEQ
						FROM (SELECT S.PARAMETER_VAL,
									S.PARAMETER_DATE
								FROM STATION_PARAMETER_VALUE S
								WHERE S.CASE_ID = GA.BASE_CASE_ID
									AND S.STATION_ID = v_CANDIDATE.STATION_ID
									AND S.PARAMETER_ID = v_CANDIDATE.PARAMETER_ID
									AND S.PARAMETER_CODE = 'A'
									AND S.PARAMETER_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
								ORDER BY S.PARAMETER_DATE DESC) PI) PD,
						-- ... to data for service date
						(SELECT AI.PARAMETER_VAL,
							AI.PARAMETER_DATE,
							ROWNUM as SEQ
						FROM (SELECT S.PARAMETER_VAL,
									S.PARAMETER_DATE
								FROM STATION_PARAMETER_VALUE S
								WHERE S.CASE_ID = p_CAST_CONTEXT.WEATHER_CASE_ID
									AND S.STATION_ID = v_CANDIDATE.STATION_ID
									AND S.PARAMETER_ID = v_CANDIDATE.PARAMETER_ID
									AND S.PARAMETER_CODE = p_CAST_CONTEXT.WEATHER_PARAMETER_CODE
									AND S.PARAMETER_DATE BETWEEN v_SVC_BEGIN_DATE AND v_SVC_END_DATE
								ORDER BY S.PARAMETER_DATE DESC) AI) AD
					WHERE PD.SEQ = AD.SEQ;

				ELSE -- v_CANDIDATE.COMPARATIVE_VALUE = 'S'

					-- Compare system load values
					SELECT SQRT(AVG((AD.LOAD_VAL - PD.LOAD_VAL) * (AD.LOAD_VAL - PD.LOAD_VAL)))
					INTO v_DELTA
						-- comparing base-case actual data from candidate day...
					FROM (SELECT PI.LOAD_VAL,
							PI.LOAD_DATE,
							ROWNUM as SEQ
						FROM (SELECT AL.LOAD_VAL,
									AL.LOAD_DATE
								FROM SYSTEM_LOAD_AREA SLA,
									AREA_LOAD AL
								WHERE SLA.SYSTEM_LOAD_ID = v_CANDIDATE.SYSTEM_LOAD_ID
									AND AL.CASE_ID = GA.BASE_CASE_ID
									AND AL.AREA_ID = SLA.AREA_ID
									AND AL.LOAD_CODE = 'A'
									AND AL.AS_OF_DATE = CONSTANTS.LOW_DATE
									AND AL.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
								ORDER BY AL.AREA_ID, AL.LOAD_DATE) PI) PD,
						-- ... to data for service date
						(SELECT AI.LOAD_VAL,
							AI.LOAD_DATE,
							ROWNUM as SEQ
						FROM (SELECT AL.LOAD_VAL,
									AL.LOAD_DATE
								FROM SYSTEM_LOAD_AREA SLA,
									AREA_LOAD AL
								WHERE SLA.SYSTEM_LOAD_ID = v_CANDIDATE.SYSTEM_LOAD_ID
									AND AL.CASE_ID = p_CAST_CONTEXT.AREA_LOAD_CASE_ID
									AND AL.AREA_ID = SLA.AREA_ID
									AND AL.LOAD_CODE = p_CAST_CONTEXT.SYSTEM_LOAD_CODE
									AND AL.AS_OF_DATE = CONSTANTS.LOW_DATE
									AND AL.LOAD_DATE BETWEEN v_SVC_BEGIN_DATE AND v_SVC_END_DATE
								ORDER BY AL.AREA_ID, AL.LOAD_DATE) AI) AD
					WHERE PD.SEQ = AD.SEQ;

				END IF;

			ELSE
				v_DELTA := NULL;
			END IF;

			v_LAST_COMPARATIVE_VALUE := v_CANDIDATE.COMPARATIVE_VALUE;
			v_LAST_STATION_ID := v_CANDIDATE.STATION_ID;
			v_LAST_PARAMETER_ID := v_CANDIDATE.PARAMETER_ID;
			v_LAST_SYSTEM_LOAD_ID := v_CANDIDATE.SYSTEM_LOAD_ID;
			v_LAST_DAY := v_CANDIDATE.CANDIDATE_DAY;
		END IF;

		IF v_DELTA IS NULL OR (NVL(v_CANDIDATE.CANDIDATE_DELTA_THRESHOLD,0) > 0 AND v_DELTA > v_CANDIDATE.CANDIDATE_DELTA_THRESHOLD) THEN
			-- not a keeper - either not a full set of data or too great of a variance
			DELETE PROXY_DAY_METHOD_WORK WHERE CURRENT OF cur_CANDIDATE_EVAL;

			IF LOGS.IS_DEBUG_ENABLED THEN
				LOGS.LOG_DEBUG('Discarded ' || TEXT_UTIL.TO_CHAR_DATE(v_CANDIDATE.CANDIDATE_DAY) ||
					' for ' || TEXT_UTIL.TO_CHAR_ENTITY(v_CANDIDATE.PROXY_DAY_METHOD_ID, EC.ED_PROXY_DAY_METHOD, TRUE)
					|| ' because ' || CASE WHEN v_DELTA IS NULL THEN 'it lacked a full day''s data.'
										ELSE 'its delta (' || v_DELTA || ') surpassed the threshhold ('
										|| v_CANDIDATE.CANDIDATE_DELTA_THRESHOLD || '). 'END);
			END IF;
		ELSE
			UPDATE PROXY_DAY_METHOD_WORK SET CANDIDATE_DELTA = v_DELTA WHERE CURRENT OF cur_CANDIDATE_EVAL;
			IF LOGS.IS_DEBUG_ENABLED THEN
				LOGS.LOG_DEBUG('Delta for ' || TEXT_UTIL.TO_CHAR_DATE(v_CANDIDATE.CANDIDATE_DAY) ||
					' for ' || TEXT_UTIL.TO_CHAR_ENTITY(v_CANDIDATE.PROXY_DAY_METHOD_ID, EC.ED_PROXY_DAY_METHOD, TRUE)
					|| ' is ' || v_DELTA || '.');
			END IF;
		END IF;
	END LOOP;

	-- Now only retain the best candidates, up to the proxy day method's limit
	FOR v_CANDIDATE IN cur_CANDIDATE_RETAIN LOOP
		IF v_LAST_PROXY_DAY_METHOD_ID IS NULL OR v_CANDIDATE.PROXY_DAY_METHOD_ID <> v_LAST_PROXY_DAY_METHOD_ID
		   OR v_LAST_HOLIDAY_SET_ID IS NULL OR v_CANDIDATE.HOLIDAY_SET_ID <> v_LAST_HOLIDAY_SET_ID THEN

			v_COUNT := 0;
			v_LAST_PROXY_DAY_METHOD_ID := v_CANDIDATE.PROXY_DAY_METHOD_ID;
			v_LAST_HOLIDAY_SET_ID := v_CANDIDATE.HOLIDAY_SET_ID;
		END IF;

		v_COUNT := v_COUNT+1;
		IF v_COUNT > v_CANDIDATE.LOOKUP_CANDIDATE_LIMIT THEN
			IF LOGS.IS_DEBUG_ENABLED THEN
				LOGS.LOG_DEBUG('Discarded ' || TEXT_UTIL.TO_CHAR_DATE(v_CANDIDATE.CANDIDATE_DAY) ||
					' for ' || TEXT_UTIL.TO_CHAR_ENTITY(v_CANDIDATE.PROXY_DAY_METHOD_ID, EC.ED_PROXY_DAY_METHOD, TRUE)
					|| ' to make the candidate limit.');
			END IF;
			DELETE PROXY_DAY_METHOD_WORK WHERE CURRENT OF cur_CANDIDATE_RETAIN;
		END IF;
	END LOOP;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('Finished calculating deltas and discarding candidate days for proxy day forecast.');
		LOGS.LOG_DEBUG('---------------------------------------------------------------------------------');
	END IF;

END CALCULATE_CANDIDATE_DELTAS;
----------------------------------------------------------------------------------------------------
PROCEDURE CACHE_PROXY_DAY_METHODS
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_PROXY_DAY_METHOD_IDs IN ID_TABLE
	) AS

v_PROXY_DAY_METHOD_IDs	NUMBER_COLLECTION;

v_MAX_LOOKUP			NUMBER;

v_TEMPLATES				NUMBER_COLLECTION;
v_HOLIDAY_SETS			NUMBER_COLLECTION;

BEGIN

	DELETE PROXY_DAY_METHOD_WORK;

	-- discard proxy day methods whose comparative value does not have a
	-- full set of data
	v_PROXY_DAY_METHOD_IDs := PRUNE_PROXY_DAY_METHODS(p_CAST_CONTEXT, p_PROXY_DAY_METHOD_IDs);

	SELECT DISTINCT NVL(EDC.EDC_HOLIDAY_SET_ID, CONSTANTS.NOT_ASSIGNED)
	BULK COLLECT INTO v_HOLIDAY_SETS
	FROM ENERGY_DISTRIBUTION_COMPANY EDC
	WHERE EDC.EDC_ID = p_CAST_CONTEXT.EDC_ID OR p_CAST_CONTEXT.EDC_ID = CONSTANTS.ALL_ID;

	SELECT DISTINCT PDM.TEMPLATE_ID
	BULK COLLECT INTO v_TEMPLATES
	FROM PROXY_DAY_METHOD PDM,
		TABLE(CAST(v_PROXY_DAY_METHOD_IDs as NUMBER_COLLECTION)) IDs
	WHERE PDM.PROXY_DAY_METHOD_ID = IDs.COLUMN_VALUE;

	SELECT MAX(PDM.LOOKUP_TIME_HORIZON)
	INTO v_MAX_LOOKUP
	FROM PROXY_DAY_METHOD PDM,
		TABLE(CAST(v_PROXY_DAY_METHOD_IDs as NUMBER_COLLECTION)) IDs
	WHERE PDM.PROXY_DAY_METHOD_ID = IDs.COLUMN_VALUE;

	SP.CHECK_TEMPLATE_DATES(v_TEMPLATES,
							v_HOLIDAY_SETS,
							GA.LOCAL_TIME_ZONE,
							p_CAST_CONTEXT.SERVICE_DATE - v_MAX_LOOKUP,
                                -- WE START 1 DAY BACK FROM SERVICE_DATE, THEN LOOK AS FAR BACK AS
                                -- MAX(HORIZON + HORIZON_SHIFT)
							p_CAST_CONTEXT.SERVICE_DATE);
                                -- WHILE WE START (AT A MINIMUM) 1 DAY BACK FROM SERVICE_DATE,
                                -- WE STILL NEED TEMPLATE_DATES
                                -- FOR SERVICE_DATE

	-- determine the set of candidates for each	proxy day method
	INSERT INTO PROXY_DAY_METHOD_WORK(PROXY_DAY_METHOD_ID,
								HOLIDAY_SET_ID,
								COMPARATIVE_VALUE,
								STATION_ID,
								PARAMETER_ID,
								SYSTEM_LOAD_ID,
								CANDIDATE_DELTA_THRESHOLD,
								LOOKUP_CANDIDATE_LIMIT,
								CANDIDATE_DAY,
								CANDIDATE_DELTA,
								PDM_INTERVAL)
	SELECT PRX.PROXY_DAY_METHOD_ID,
		PRX.HOLIDAY_SET_ID,
		PRX.COMPARATIVE_VALUE,
		PRX.STATION_ID,
		PRX.PARAMETER_ID,
		PRX.SYSTEM_LOAD_ID,
		PRX.CANDIDATE_DELTA_THRESHOLD,
		PRX.LOOKUP_CANDIDATE_LIMIT,
		TD.LOCAL_DATE,
		NULL,
		NVL(WP.PARAMETER_INTERVAL, SL.SYSTEM_LOAD_INTERVAL)
	FROM (SELECT PDM.PROXY_DAY_METHOD_ID,
				TD.HOLIDAY_SET_ID,
				PDM.TEMPLATE_ID,
				DT.PERIOD_ID,
				PDM.LOOKUP_TIME_HORIZON,
				NVL(PDM.TIME_HORIZON_SHIFT, 1) AS TIME_HORIZON_SHIFT,
				PDM.COMPARATIVE_VALUE,
				PDM.STATION_ID,
				PDM.PARAMETER_ID,
				PDM.SYSTEM_LOAD_ID,
				PDM.CANDIDATE_DELTA_THRESHOLD,
				PDM.LOOKUP_CANDIDATE_LIMIT
			FROM TABLE(CAST(v_PROXY_DAY_METHOD_IDs as NUMBER_COLLECTION)) PDM_IDs,
				TABLE(CAST(v_HOLIDAY_SETS as NUMBER_COLLECTION)) HS_IDs,
				PROXY_DAY_METHOD PDM,
				TEMPLATE_DATES TD,
				TEMPLATE_DAY_TYPE TDT,
				TEMPLATE_DAY_TYPE_PERIOD DT
			WHERE PDM.PROXY_DAY_METHOD_ID = PDM_IDs.COLUMN_VALUE
				AND TD.TEMPLATE_ID = PDM.TEMPLATE_ID
				AND TD.TIME_ZONE = GA.LOCAL_TIME_ZONE
				AND TD.HOLIDAY_SET_ID = HS_IDs.COLUMN_VALUE
				AND TD.LOCAL_DATE = p_CAST_CONTEXT.SERVICE_DATE
				AND TDT.DAY_TYPE_ID = TD.DAY_TYPE_ID
				AND DT.DAY_TYPE_ID = TDT.DAY_TYPE_ID
				AND DT.TIME_STAMP = CONSTANTS.DAY_TYPE_FIRST_INTERVAL) PRX,
		TEMPLATE_DATES TD,
		TEMPLATE_DAY_TYPE TDT,
		TEMPLATE_DAY_TYPE_PERIOD DT,
		WEATHER_PARAMETER WP,
		SYSTEM_LOAD SL
	WHERE TD.TIME_ZONE = GA.LOCAL_TIME_ZONE
		AND TD.HOLIDAY_SET_ID = PRX.HOLIDAY_SET_ID
		AND TD.TEMPLATE_ID = PRX.TEMPLATE_ID
		AND TD.LOCAL_DATE BETWEEN
			(p_CAST_CONTEXT.SERVICE_DATE - PRX.LOOKUP_TIME_HORIZON)
				AND (p_CAST_CONTEXT.SERVICE_DATE - PRX.TIME_HORIZON_SHIFT)
		AND TDT.DAY_TYPE_ID = TD.DAY_TYPE_ID
		AND DT.DAY_TYPE_ID = TDT.DAY_TYPE_ID
		AND DT.TIME_STAMP = CONSTANTS.DAY_TYPE_FIRST_INTERVAL
		AND DT.PERIOD_ID = PRX.PERIOD_ID
		AND WP.PARAMETER_ID (+) = PRX.PARAMETER_ID
		AND SL.SYSTEM_LOAD_ID (+) = PRX.SYSTEM_LOAD_ID;

	-- calculate candidates' variances from service date
	CALCULATE_CANDIDATE_DELTAS(p_CAST_CONTEXT);

END CACHE_PROXY_DAY_METHODS;
----------------------------------------------------------------------------------------------------
FUNCTION HAS_DR_EVENT
	(
	p_ACCOUNT_SERVICE_ID IN NUMBER,
	p_SERVICE_DATE IN DATE
	) RETURN BOOLEAN IS
v_COUNT PLS_INTEGER;
BEGIN
	SELECT MAX(NUM_EVENTS)
	INTO v_COUNT
	FROM (
		SELECT COUNT(1) as NUM_EVENTS
		FROM ACCOUNT_SERVICE ASVC,
			SERVICE_LOCATION SL,
			SERVICE_LOCATION_PROGRAM SLP,
			PROGRAM P,
			VIRTUAL_POWER_PLANT VPP,
			DR_EVENT E
		-- find programs for this service location
		WHERE ASVC.ACCOUNT_SERVICE_ID = p_ACCOUNT_SERVICE_ID
			AND SL.SERVICE_LOCATION_ID = ASVC.SERVICE_LOCATION_ID
			AND SLP.SERVICE_LOCATION_ID = SL.SERVICE_LOCATION_ID
			AND p_SERVICE_DATE BETWEEN SLP.BEGIN_DATE AND NVL(SLP.END_DATE, CONSTANTS.HIGH_DATE)
			AND P.PROGRAM_ID = SLP.PROGRAM_ID
			-- only getting events for peak time rebate and critical peak/tou programs
			AND P.PROGRAM_TYPE IN (DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_PK_TIME_REBATE, DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_CRIT_PRICING)
			AND VPP.SERVICE_ZONE_ID = SL.SERVICE_ZONE_ID
			AND VPP.PROGRAM_ID = P.PROGRAM_ID
			AND E.VPP_ID = VPP.VPP_ID
			AND E.START_TIME < TO_CUT(p_SERVICE_DATE+1, GA.LOCAL_TIME_ZONE)
			AND E.STOP_TIME > TO_CUT(p_SERVICE_DATE, GA.LOCAL_TIME_ZONE)
		UNION ALL
		SELECT COUNT(1)
		FROM ACCOUNT_SERVICE ASVC,
			SERVICE_LOCATION SL,
			DISTRIBUTED_ENERGY_RESOURCE DER,
			DR_EVENT_PARTICIPATION EP,
			DR_EVENT E
		-- find resources for this service location
		WHERE ASVC.ACCOUNT_SERVICE_ID = p_ACCOUNT_SERVICE_ID
			AND SL.SERVICE_LOCATION_ID = ASVC.SERVICE_LOCATION_ID
			AND DER.SERVICE_LOCATION_ID = SL.SERVICE_LOCATION_ID
			AND p_SERVICE_DATE BETWEEN DER.BEGIN_DATE AND NVL(DER.END_DATE, CONSTANTS.HIGH_DATE)
			-- find events where these resources participated
			AND EP.DER_ID = DER.DER_ID
			AND E.EVENT_ID = EP.EVENT_ID
			AND E.START_TIME < TO_CUT(p_SERVICE_DATE+1, GA.LOCAL_TIME_ZONE)
			AND E.STOP_TIME > TO_CUT(p_SERVICE_DATE, GA.LOCAL_TIME_ZONE)
		);

	RETURN v_COUNT > 0;
END HAS_DR_EVENT;
----------------------------------------------------------------------------------------------------
FUNCTION GET_ACCOUNT_SERVICE_LOG_STR
	(
	p_ACCOUNT_SERVICE_ID IN NUMBER
	) RETURN VARCHAR2 IS

		v_ACCOUNT_ID NUMBER(9);
		v_METER_ID NUMBER(9);

	BEGIN

		SELECT SER.ACCOUNT_ID, SER.METER_ID
		INTO v_ACCOUNT_ID, v_METER_ID
		FROM ACCOUNT_SERVICE SER
		WHERE SER.ACCOUNT_SERVICE_ID = p_ACCOUNT_SERVICE_ID;

		IF NVL(v_METER_ID, CONSTANTS.NOT_ASSIGNED) = CONSTANTS.NOT_ASSIGNED THEN
			RETURN TEXT_UTIL.TO_CHAR_ENTITY(v_ACCOUNT_ID, EC.ED_ACCOUNT, TRUE);
		ELSE
			RETURN TEXT_UTIL.TO_CHAR_ENTITY(v_METER_ID, EC.ED_METER, TRUE);
		END IF;

END GET_ACCOUNT_SERVICE_LOG_STR;
----------------------------------------------------------------------------------------------------
PROCEDURE PROXY_USAGE_PROFILE
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_PROXY_DAY_METHOD_ID IN NUMBER,
	p_HOLIDAY_SET_ID IN NUMBER,
	p_ACCOUNT_SERVICE_ID IN NUMBER,
	p_PROVIDER_SERVICE_ID IN NUMBER,
	p_CALENDAR_ID IN NUMBER,
	p_HAS_PROXY_PROFILE OUT BOOLEAN,
	p_PROFILE_SOURCE_DATE OUT DATE,
	p_PROFILE IN OUT NOCOPY GA.NUMBER_TABLE
	) AS

-- Answer the Forecast Proxy Profile derived from actual Usage data for the specified forecast date

CURSOR cur_CANDIDATES IS
	SELECT CANDIDATE_DAY
	FROM PROXY_DAY_METHOD_WORK
	WHERE PROXY_DAY_METHOD_ID = p_PROXY_DAY_METHOD_ID
		AND HOLIDAY_SET_ID = p_HOLIDAY_SET_ID
	ORDER BY CANDIDATE_DELTA ASC, CANDIDATE_DAY DESC;

v_CANDIDATE_DATES DATE_COLLECTION := DATE_COLLECTION();

BEGIN

	FOR v_CANDIDATE IN cur_CANDIDATES LOOP
		IF NOT HAS_DR_EVENT(p_ACCOUNT_SERVICE_ID, v_CANDIDATE.CANDIDATE_DAY) THEN
			v_CANDIDATE_DATES.EXTEND();
			v_CANDIDATE_DATES(v_CANDIDATE_DATES.COUNT) := v_CANDIDATE.CANDIDATE_DAY;
		ELSIF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG('Proxy Day ' ||
				TEXT_UTIL.TO_CHAR_DATE(v_CANDIDATE.CANDIDATE_DAY)
				|| ' was discarded for '
				|| GET_ACCOUNT_SERVICE_LOG_STR(p_ACCOUNT_SERVICE_ID)
				|| ' because the account has a DR event for that day.');
		END IF;
	END LOOP;

	IF GA.ENABLE_EXTERNAL_PROXY_DATA THEN

		XS.PROXY_USAGE_PROFILE(p_CAST_CONTEXT.SERVICE_DATE, p_PROXY_DAY_METHOD_ID,
			p_ACCOUNT_SERVICE_ID, p_PROVIDER_SERVICE_ID, v_CANDIDATE_DATES,
			p_HAS_PROXY_PROFILE, p_PROFILE_SOURCE_DATE, p_PROFILE);

		IF p_HAS_PROXY_PROFILE THEN

			IF LOGS.IS_DEBUG_ENABLED THEN
				LOGS.LOG_DEBUG('External Proxy Usage Profile returned for ' ||
					TEXT_UTIL.TO_CHAR_DATE(p_PROFILE_SOURCE_DATE));

				IF LOGS.IS_DEBUG_DETAIL_ENABLED()THEN
					TRACE_TABLE('External Proxy Usage Profile', p_PROFILE);
				END IF;
			END IF;
			-- FOUND IT, RETURN
			RETURN;
		END IF;

		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG('External Proxy Usage Profile not returned for '
				|| GET_ACCOUNT_SERVICE_LOG_STR(p_ACCOUNT_SERVICE_ID) || ' on any of the supplied'
				|| ' candidate dates.');
		END IF;
	END IF;

	FOR v_INT IN 1..v_CANDIDATE_DATES.COUNT LOOP
		ACTUAL_USAGE_PROFILE(p_CAST_CONTEXT, p_ACCOUNT_SERVICE_ID, p_PROVIDER_SERVICE_ID, p_CALENDAR_ID, v_CANDIDATE_DATES(v_INT), p_HAS_PROXY_PROFILE, p_PROFILE_SOURCE_DATE, p_PROFILE);

		IF p_HAS_PROXY_PROFILE THEN
			IF LOGS.IS_DEBUG_ENABLED THEN
				LOGS.LOG_DEBUG('Usage data for proxy day forecasting was found for '
					|| GET_ACCOUNT_SERVICE_LOG_STR(p_ACCOUNT_SERVICE_ID)
					|| ' on ' || TEXT_UTIL.TO_CHAR_DATE(v_CANDIDATE_DATES(v_INT)) || '. ');
			END IF;
			RETURN; -- got it!
		ELSIF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG('Proxy Day ' || TEXT_UTIL.TO_CHAR_DATE(v_CANDIDATE_DATES(v_INT))
			|| ' was discarded for '
			|| GET_ACCOUNT_SERVICE_LOG_STR(p_ACCOUNT_SERVICE_ID)
			|| ' because a full day''s usage was not found for that date.');
		END IF;
	END LOOP;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('No suitable proxy day was found for '
			|| GET_ACCOUNT_SERVICE_LOG_STR(p_ACCOUNT_SERVICE_ID) || '. ');
	END IF;

	-- got here? no suitable day from candidate list - return no proxy
	p_HAS_PROXY_PROFILE := FALSE;
	p_PROFILE_SOURCE_DATE := NULL;

END PROXY_USAGE_PROFILE;
----------------------------------------------------------------------------------------------------
FUNCTION SETTLEMENT_PROFILE_EXISTS
	(
	p_PROFILE_ID IN NUMBER
	) RETURN BOOLEAN IS
BEGIN
	  RETURN g_SETTLEMENT_PROFILE.EXISTS(p_PROFILE_ID);
EXCEPTION
	WHEN OTHERS THEN RETURN FALSE;
END;
----------------------------------------------------------------------------------------------------
PROCEDURE ADJUST_TO_STANDARD_PROFILE
	(
	p_PROFILE IN OUT NOCOPY GA.NUMBER_TABLE
	) AS

BEGIN

	IF p_PROFILE.COUNT = 23 THEN
		-- SHORT DAY, HOUR
		DATE_UTIL.TRANSFORM_NUMBER_TBL_FOR_DST(p_PROFILE,
												CONSTANTS.DST_TYPE_SPRING_AHEAD,
												CONSTANTS.DST_TYPE_NONE,
												DATE_UTIL.c_NAME_HOUR,
												p_PROFILE);
	ELSIF p_PROFILE.COUNT = 25 THEN
		-- LONG DAY, HOUR
		DATE_UTIL.TRANSFORM_NUMBER_TBL_FOR_DST(p_PROFILE,
												CONSTANTS.DST_TYPE_FALL_BACK,
												CONSTANTS.DST_TYPE_NONE,
												DATE_UTIL.c_NAME_HOUR,
												p_PROFILE);
	ELSIF p_PROFILE.COUNT = 46 THEN
		-- SHORT DAY, 30 MIN
		DATE_UTIL.TRANSFORM_NUMBER_TBL_FOR_DST(p_PROFILE,
												CONSTANTS.DST_TYPE_SPRING_AHEAD,
												CONSTANTS.DST_TYPE_NONE,
												DATE_UTIL.c_NAME_30MIN,
												p_PROFILE);
	ELSIF p_PROFILE.COUNT = 50 THEN
		-- LONG DAY, 30 MIN
		DATE_UTIL.TRANSFORM_NUMBER_TBL_FOR_DST(p_PROFILE,
												CONSTANTS.DST_TYPE_FALL_BACK,
												CONSTANTS.DST_TYPE_NONE,
												DATE_UTIL.c_NAME_30MIN,
												p_PROFILE);
	ELSIF p_PROFILE.COUNT = 92 THEN
		-- SHORT DAY, 15 MIN
		DATE_UTIL.TRANSFORM_NUMBER_TBL_FOR_DST(p_PROFILE,
												CONSTANTS.DST_TYPE_SPRING_AHEAD,
												CONSTANTS.DST_TYPE_NONE,
												DATE_UTIL.c_NAME_15MIN,
												p_PROFILE);
	ELSIF p_PROFILE.COUNT = 100 THEN
		-- LONG DAY, 15 MIN
		DATE_UTIL.TRANSFORM_NUMBER_TBL_FOR_DST(p_PROFILE,
												CONSTANTS.DST_TYPE_FALL_BACK,
												CONSTANTS.DST_TYPE_NONE,
												DATE_UTIL.c_NAME_15MIN,
												p_PROFILE);
	END IF;
	-- NONE OF THESE COUNTS?  THEN THE PROFILE IS ALREADY IN CORRECT TIME

END ADJUST_TO_STANDARD_PROFILE;
----------------------------------------------------------------------------------------------------
PROCEDURE ASSIGN_SETTLEMENT_PROFILE
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_PROFILE_ID IN NUMBER,
	p_USAGE_FACTOR IN NUMBER,
	p_PROFILE IN OUT NOCOPY GA.NUMBER_TABLE
	) AS

-- Save load profile point data.

v_POINT_DATE DATE := TRUNC(p_CAST_CONTEXT.SERVICE_DATE);
v_INDEX BINARY_INTEGER;
v_IDX BINARY_INTEGER;
v_COUNT BINARY_INTEGER;
v_MINUTES NUMBER(4) := 0;
v_INTERVALS NUMBER(3);
v_DST_ACTIVE BOOLEAN := FALSE;
v_HOUR NUMBER(2);
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;

BEGIN

	IF LOGS.IS_DEBUG_DETAIL_ENABLED()THEN
		LOGS.LOG_DEBUG_DETAIL('ASSIGN_SETTLEMENT_PROFILE PROFILE_ID='  || TO_CHAR(p_PROFILE_ID) || ', USAGE_FACTOR=' || TO_CHAR(p_USAGE_FACTOR));
	END IF;

	-- Settlement Logic is expecting the incoming profile to be in standard time, so adjust
	-- in case this is a proxy profile or actual profile from a DST day
	ADJUST_TO_STANDARD_PROFILE(p_PROFILE);

-- Adjust settlement profile to accomodate DST representation options if DST in effect.
-- Zero out the option specified hour (and sub-intervals) for the April transition day,
-- and double hour ending 2:00 (and sub-intervals) for the October transition day.

	IF p_PROFILE.COUNT IN (24, 48, 96) THEN
		v_INTERVALS := (p_PROFILE.COUNT / 24);
		IF UPPER(SUBSTR(LOCAL_TIME_ZONE,2,1)) = 'D' THEN
			IF TRUNC(v_POINT_DATE) = TRUNC(DST_SPRING_AHEAD_DATE(v_POINT_DATE)) THEN
				IF GA.DST_SPRING_AHEAD_OPTION = 'A' THEN
					v_HOUR := 2;
				ELSIF GA.DST_SPRING_AHEAD_OPTION = 'B' THEN
					v_HOUR := 3;
				ELSIF GA.DST_SPRING_AHEAD_OPTION = 'C' THEN
					v_HOUR := 24;
				END IF;
				v_DST_ACTIVE := TRUE;
			END IF;

-- Zero out the appropriate intervals of the profile for the April DST transition day.
			IF v_DST_ACTIVE THEN
				FOR v_INDEX IN 1..v_INTERVALS LOOP
					v_IDX := (v_HOUR)*v_INTERVALS + v_INDEX;
					IF p_PROFILE.EXISTS(v_IDX) THEN
						p_PROFILE(v_IDX) := 0;
					END IF;
				END LOOP;
			END IF;
		END IF;
	END IF;

	v_MINUTES := 1440 / p_PROFILE.COUNT;
	SELECT DECODE(p_CAST_CONTEXT.MODEL_ID, GA.ELECTRIC_MODEL, BEGIN_HOUR_ENDING_CUT_DAY(p_CAST_CONTEXT.SERVICE_DATE, STD_TIME_ZONE(LOCAL_TIME_ZONE), v_MINUTES), p_CAST_CONTEXT.SERVICE_DATE) INTO v_POINT_DATE FROM DUAL;

	v_INDEX := p_PROFILE.FIRST;
	WHILE v_INDEX <= p_PROFILE.LAST LOOP
		v_COUNT := g_POINT_PROFILE_ID.COUNT + 1;
		g_POINT_PROFILE_ID(v_COUNT) := p_PROFILE_ID;
		g_POINT_DATE(v_COUNT) := v_POINT_DATE;
		g_POINT_VAL(v_COUNT) := p_PROFILE(v_INDEX) * p_USAGE_FACTOR;
		v_POINT_DATE := ADD_MINUTES_TO_DATE(v_POINT_DATE, v_MINUTES);
		v_INDEX := p_PROFILE.NEXT(v_INDEX);
	END LOOP;

	g_SETTLEMENT_PROFILE(p_PROFILE_ID) := TRUE;
	g_SETTLEMENT_PROFILE_STATS(p_PROFILE_ID) := TRUE;

	IF LOGS.IS_DEBUG_DETAIL_ENABLED()THEN
		LOGS.LOG_DEBUG_DETAIL('ASSIGN_SETTLEMENT_PROFILE ELAPSED TIME='  || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED));
	END IF;

END ASSIGN_SETTLEMENT_PROFILE;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SETTLEMENT_PROFILE
	(
	p_CAST_CONTEXT IN CAST_CONTEXT_TYPE,
	p_PROFILE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PROFILE IN OUT NOCOPY USAGE_TABLE
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;

BEGIN

	p_PROFILE.DELETE;

	UT.CUT_DATE_RANGE(p_CAST_CONTEXT.MODEL_ID, p_BEGIN_DATE, p_END_DATE, STD_TIME_ZONE(LOCAL_TIME_ZONE), v_BEGIN_DATE, v_END_DATE);

	IF GA.VERSION_PROFILE AND p_CAST_CONTEXT.PROFILE_AS_OF_DATE > g_LOW_DATE THEN
		SELECT USAGE_TYPE(POINT_DATE, POINT_VAL)
		BULK COLLECT INTO p_PROFILE
		FROM LOAD_PROFILE_POINT A
		WHERE PROFILE_ID = p_PROFILE_ID
		    AND POINT_INDEX = g_DEFAULT_POINT_INDEX
			AND POINT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM LOAD_PROFILE_POINT
				WHERE PROFILE_ID = A.PROFILE_ID
					AND POINT_INDEX = A.POINT_INDEX
					AND POINT_DATE = A.POINT_DATE
					AND AS_OF_DATE <= p_CAST_CONTEXT.PROFILE_AS_OF_DATE);
	ELSE
		SELECT USAGE_TYPE(POINT_DATE, POINT_VAL)
		BULK COLLECT INTO p_PROFILE
		FROM LOAD_PROFILE_POINT A
		WHERE PROFILE_ID = p_PROFILE_ID
		    AND POINT_INDEX = g_DEFAULT_POINT_INDEX
			AND POINT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND AS_OF_DATE = g_LOW_DATE;
	END IF;

 	IF LOGS.IS_DEBUG_ENABLED() THEN
		LOGS.LOG_DEBUG('GET_SETTLEMENT_PROFILE TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED) || ', COUNT=' || TO_CHAR(p_PROFILE.COUNT));
	END IF;

END GET_SETTLEMENT_PROFILE;
----------------------------------------------------------------------------------------------------
PROCEDURE MONITOR_PROFILE_MAPE
	(
	p_ACCOUNT_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_PROJECTION_DETERMINANT_TABLE IN GA.NUMBER_TABLE,
	p_SETTLEMENT_TABLE IN GA.NUMBER_TABLE
	) AS

v_INDEX BINARY_INTEGER;
v_MAPE NUMBER;
v_TOTAL_MAPE NUMBER := 0;
v_MONITOR_VAL NUMBER;
v_SETTLEMENT_VAL NUMBER;
v_COUNT NUMBER := 0;
v_PROFILE_MONITOR PROFILE_MONITOR%ROWTYPE;

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('MONITOR_PROFILE_MAPE');
		LOGS.LOG_DEBUG('SERVICE_DATE=' || UT.TRACE_DATE(p_SERVICE_DATE));
		LOGS.LOG_DEBUG('MONITOR_TABLE.COUNT=' || TO_CHAR(p_PROJECTION_DETERMINANT_TABLE.COUNT));
		LOGS.LOG_DEBUG('SETTLEMENT_TABLE.COUNT=' || TO_CHAR(p_SETTLEMENT_TABLE.COUNT));
		LOGS.LOG_DEBUG('<settlement>,<monitor>,<mape>');
	END IF;

	FOR v_INDEX IN 0..p_PROJECTION_DETERMINANT_TABLE.COUNT LOOP
		IF p_PROJECTION_DETERMINANT_TABLE.EXISTS(v_INDEX) THEN
			v_MONITOR_VAL := p_PROJECTION_DETERMINANT_TABLE(v_INDEX);
		ELSE
			v_MONITOR_VAL := 0;
		END IF;
		IF p_SETTLEMENT_TABLE.EXISTS(v_INDEX) THEN
			v_SETTLEMENT_VAL := p_SETTLEMENT_TABLE(v_INDEX);
		ELSE
			v_SETTLEMENT_VAL := 0;
		END IF;
		IF v_MONITOR_VAL <> 0 THEN
			v_MAPE := ABS(v_SETTLEMENT_VAL - v_MONITOR_VAL);
			v_MAPE := v_MAPE / v_MONITOR_VAL;
			v_TOTAL_MAPE := v_TOTAL_MAPE + v_MAPE;
			v_COUNT:= v_COUNT + 1;
		ELSE	--Skip this entry
			v_MAPE := 0;
		END IF;
		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG(TO_CHAR(v_SETTLEMENT_VAL) || ',' || TO_CHAR(v_MONITOR_VAL) || ',' || TO_CHAR(v_MAPE));
		END IF;
	END LOOP;

	v_PROFILE_MONITOR.ACCOUNT_ID := p_ACCOUNT_ID;
	v_PROFILE_MONITOR.METER_ID := p_METER_ID;
	v_PROFILE_MONITOR.MONITOR_DATE := p_SERVICE_DATE;
	IF v_COUNT = 0 THEN
		v_PROFILE_MONITOR.MONITOR_MAPE := 0;
	ELSE
		v_PROFILE_MONITOR.MONITOR_MAPE := LEAST(((v_TOTAL_MAPE / v_COUNT) *100.0),999999.99);
	END IF;


	PUT_PROFILE_MONITOR(v_PROFILE_MONITOR);

END MONITOR_PROFILE_MAPE;
----------------------------------------------------------------------------------------------------
PROCEDURE MONITOR_ACCOUNT_MODEL
	(
	p_ACCOUNT_ID IN NUMBER,
	p_METER_TYPE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PROFILE_AS_OF_DATE IN DATE,
	p_USAGE_AS_OF_DATE IN DATE
	) AS

v_SERVICE_LOCATION_ID NUMBER;
v_SERVICE_DATE DATE;
v_MONITOR_PROFILE_ID NUMBER;
v_SETTLEMENT_PROFILE_ID NUMBER;
v_MONITOR_TABLE GA.NUMBER_TABLE;
v_SETTLEMENT_TABLE GA.NUMBER_TABLE;
v_SERVICE_STATE SERVICE_STATE%ROWTYPE;

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('MONITOR_ACCOUNT_MODEL');
	END IF;

	v_MONITOR_PROFILE_ID := GET_PROFILE_ID(p_ACCOUNT_ID, 0, p_BEGIN_DATE, 'M');

	IF v_MONITOR_PROFILE_ID = CONSTANTS.NOT_ASSIGNED THEN
		IF p_METER_TYPE = 'P' THEN
			RETURN;
		ELSE
			v_SERVICE_LOCATION_ID := CS.GET_SERVICE_LOCATION_ID(p_ACCOUNT_ID, TRUNC(p_BEGIN_DATE));
		END IF;
	END IF;

	v_SETTLEMENT_PROFILE_ID := GET_PROFILE_ID(p_ACCOUNT_ID, 0, p_BEGIN_DATE, 'S');

	v_SERVICE_DATE := TRUNC(p_BEGIN_DATE);
	WHILE v_SERVICE_DATE <= TRUNC(p_END_DATE) LOOP

		IF NOT v_MONITOR_PROFILE_ID = CONSTANTS.NOT_ASSIGNED THEN
			DAY_PROFILE(v_MONITOR_PROFILE_ID, v_SERVICE_DATE, p_PROFILE_AS_OF_DATE, v_MONITOR_TABLE);
		ELSE
			v_SERVICE_STATE := CS.GET_SERVICE_STATE(GA.ELECTRIC_MODEL, GA.BASE_SCENARIO_ID, p_ACCOUNT_ID, v_SERVICE_LOCATION_ID, CONSTANTS.NOT_ASSIGNED, CONSTANTS.NOT_ASSIGNED, GA.ACTUAL_SERVICE, v_SERVICE_DATE, p_USAGE_AS_OF_DATE, CONSTANTS.NOT_ASSIGNED, CONSTANTS.NOT_ASSIGNED, USER);
			USAGE_DAY_PROFILE(v_SERVICE_STATE.SERVICE_ID, v_SERVICE_DATE, FALSE, v_MONITOR_TABLE);
		END IF;

		DAY_PROFILE(v_SETTLEMENT_PROFILE_ID, v_SERVICE_DATE, p_PROFILE_AS_OF_DATE, v_SETTLEMENT_TABLE);

		MONITOR_PROFILE_MAPE(p_ACCOUNT_ID, 0, v_SERVICE_DATE, v_MONITOR_TABLE, v_SETTLEMENT_TABLE);

		v_SERVICE_DATE := v_SERVICE_DATE + 1;

	END LOOP;

END MONITOR_ACCOUNT_MODEL;
----------------------------------------------------------------------------------------------------
PROCEDURE MONITOR_METER_MODEL
	(
	p_ACCOUNT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE
	) AS

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('MONITOR_METER_MODEL');
	END IF;

END MONITOR_METER_MODEL;
----------------------------------------------------------------------------------------------------
PROCEDURE MONITOR_MODEL
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PROFILE_AS_OF_DATE IN DATE,
	p_USAGE_AS_OF_DATE IN DATE
	) AS

-- Monitor the settlement profile against a monitor profile or usage.

CURSOR c_ACCOUNT IS
	SELECT A.ACCOUNT_ID,
		UPPER(SUBSTR(ACCOUNT_MODEL_OPTION,1,1)) "MODEL_OPTION",
		DECODE(UPPER(SUBSTR(ACCOUNT_METER_TYPE,1,1)),'I','I','P') "METER_TYPE"
	FROM ACCOUNT A, ACCOUNT_STATUS B, ACCOUNT_STATUS_NAME STATUS_NAME
	WHERE B.ACCOUNT_ID = A.ACCOUNT_ID
		AND p_BEGIN_DATE BETWEEN B.BEGIN_DATE AND NVL(B.END_DATE, p_BEGIN_DATE)
		AND STATUS_NAME.STATUS_NAME = B.STATUS_NAME
		AND STATUS_NAME.IS_ACTIVE = 1;

v_COUNT PLS_INTEGER := 0;

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('MONITOR_ACCOUNT_MODEL');
	END IF;

	FOR v_ACCOUNT IN c_ACCOUNT LOOP

		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG(TO_CHAR(v_ACCOUNT.ACCOUNT_ID) || ',' || v_ACCOUNT.MODEL_OPTION || ',' || v_ACCOUNT.METER_TYPE);
		END IF;

		IF v_ACCOUNT.MODEL_OPTION = 'A' THEN
			MONITOR_ACCOUNT_MODEL(v_ACCOUNT.ACCOUNT_ID, v_ACCOUNT.METER_TYPE, p_BEGIN_DATE, p_END_DATE, p_PROFILE_AS_OF_DATE, p_USAGE_AS_OF_DATE);
		ELSIF v_ACCOUNT.MODEL_OPTION = 'M' THEN
			MONITOR_METER_MODEL(v_ACCOUNT.ACCOUNT_ID, p_BEGIN_DATE, p_END_DATE, p_USAGE_AS_OF_DATE);
		END IF;

		v_COUNT := v_COUNT + 1;

	END LOOP;

	IF LOGS.IS_DEBUG_ENABLED AND v_COUNT = 0 THEN
		LOGS.LOG_DEBUG('NO ACTIVE ACCOUNTS');
	END IF;

END MONITOR_MODEL;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_BEST_FIT_METHOD
	(
	p_SERVICE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PEAK_BEGIN IN  NUMBER,
	p_PEAK_END IN NUMBER,
	p_NUM_HOURS IN NUMBER,
	p_TOTAL_METHOD OUT CHAR,
	p_PEAK_METHOD OUT CHAR,
	p_HOUR_METHOD OUT CHAR
	) AS

-- Note: p_BEGIN_DATE and p_END_DATE are CUT Dates.

v_HISTORICAL_VAR NUMBER;
v_AVERAGE_VAR NUMBER;
v_MOST_RECENT_VAR NUMBER;
v_LEAST_VAR NUMBER;
v_IDX BINARY_INTEGER;

CURSOR c_HISTORICAL IS
	SELECT POWER(LOAD_VAL - HISTORICAL_VAL,2) AS HISTORICAL_VAR
	FROM SERVICE_VALIDATION_LOAD
	WHERE SERVICE_ID = p_SERVICE_ID
		AND LOAD_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
	ORDER BY 1 DESC;

CURSOR c_AVERAGE IS
	SELECT POWER(LOAD_VAL - AVERAGE_VAL,2) AS AVERAGE_VAR
	FROM SERVICE_VALIDATION_LOAD
	WHERE SERVICE_ID = p_SERVICE_ID
		AND LOAD_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
	ORDER BY 1 DESC;

CURSOR c_MOST_RECENT IS
	SELECT POWER(LOAD_VAL - MOST_RECENT_VAL,2) AS MOST_RECENT_VAR
	FROM SERVICE_VALIDATION_LOAD
	WHERE SERVICE_ID = p_SERVICE_ID
		AND LOAD_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
	ORDER BY 1 DESC;

BEGIN

--Total Best Fit Method.
	SELECT AVG(POWER(LOAD_VAL - HISTORICAL_VAL,2)),
		AVG(POWER(LOAD_VAL - AVERAGE_VAL,2)),
		AVG(POWER(LOAD_VAL - MOST_RECENT_VAL,2))
	INTO v_HISTORICAL_VAR, v_AVERAGE_VAR, v_MOST_RECENT_VAR
	FROM SERVICE_VALIDATION_LOAD
	WHERE SERVICE_ID = p_SERVICE_ID
		AND LOAD_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE;

	v_LEAST_VAR := LEAST(NVL(v_HISTORICAL_VAR, g_BIG_VAL), NVL(v_AVERAGE_VAR, g_BIG_VAL), NVL(v_MOST_RECENT_VAR, g_BIG_VAL));
	IF v_MOST_RECENT_VAR = v_LEAST_VAR THEN
		p_TOTAL_METHOD := 'R';
	ELSIF v_AVERAGE_VAR =  v_LEAST_VAR THEN
		p_TOTAL_METHOD := 'A';
	ELSIF v_HISTORICAL_VAR = v_LEAST_VAR THEN
		p_TOTAL_METHOD := 'H';
	END IF;

	--PEAK BEST FIT METHOD.
	SELECT AVG(POWER(LOAD_VAL - HISTORICAL_VAL,2)),
		AVG(POWER(LOAD_VAL - AVERAGE_VAL,2)),
		AVG(POWER(LOAD_VAL - MOST_RECENT_VAL,2))
	INTO v_HISTORICAL_VAR, v_AVERAGE_VAR, v_MOST_RECENT_VAR
	FROM SERVICE_VALIDATION_LOAD
	WHERE SERVICE_ID = p_SERVICE_ID
		AND LOAD_DATE BETWEEN p_BEGIN_DATE + (p_PEAK_BEGIN / 24) AND p_BEGIN_DATE + (p_PEAK_END / 24);

	v_LEAST_VAR := LEAST(NVL(v_HISTORICAL_VAR, g_BIG_VAL), NVL(v_AVERAGE_VAR, g_BIG_VAL), NVL(v_MOST_RECENT_VAR, g_BIG_VAL));
	IF v_MOST_RECENT_VAR = v_LEAST_VAR THEN
		p_PEAK_METHOD := 'R';
	ELSIF v_AVERAGE_VAR =  v_LEAST_VAR THEN
		p_PEAK_METHOD := 'A';
	ELSIF v_HISTORICAL_VAR = v_LEAST_VAR THEN
		p_PEAK_METHOD := 'H';
	END IF;

--Hour Best Fit Method.
--Historical Variance
	 v_IDX := 0;
	 v_HISTORICAL_VAR := 0;
	 FOR v_HISTORICAL IN c_HISTORICAL LOOP
	 	  EXIT WHEN v_IDX >= p_NUM_HOURS;
		  v_HISTORICAL_VAR := v_HISTORICAL.HISTORICAL_VAR + v_HISTORICAL_VAR;
		  v_IDX := v_IDX + 1;
	 END LOOP;
--Average Variance
	 v_IDX := 0;
	 v_AVERAGE_VAR := 0;
	 FOR v_AVERAGE IN c_AVERAGE LOOP
	 	  EXIT WHEN v_IDX >= p_NUM_HOURS;
		  v_AVERAGE_VAR := v_AVERAGE.AVERAGE_VAR + v_AVERAGE_VAR;
		  v_IDX := v_IDX + 1;
	 END LOOP;
--Most Recent Variance
	 v_IDX := 0;
	 v_MOST_RECENT_VAR := 0;
	 FOR v_MOST_RECENT IN c_MOST_RECENT LOOP
	 	  EXIT WHEN v_IDX >= p_NUM_HOURS;
		  v_MOST_RECENT_VAR := v_MOST_RECENT.MOST_RECENT_VAR + v_MOST_RECENT_VAR;
		  v_IDX := v_IDX + 1;
	 END LOOP;

	v_LEAST_VAR := LEAST(NVL(v_HISTORICAL_VAR, g_BIG_VAL), NVL(v_AVERAGE_VAR, g_BIG_VAL), NVL(v_MOST_RECENT_VAR, g_BIG_VAL));
	IF v_MOST_RECENT_VAR = v_LEAST_VAR THEN
		p_HOUR_METHOD := 'R';
	ELSIF v_AVERAGE_VAR =  v_LEAST_VAR THEN
		p_HOUR_METHOD := 'A';
	ELSIF v_HISTORICAL_VAR = v_LEAST_VAR THEN
		p_HOUR_METHOD := 'H';
	END IF;

END GET_BEST_FIT_METHOD;
--------------------------------------------------------------------------------------------------
PROCEDURE GET_BEST_FIT_VALS
	(
	p_VARIANCE_TEST IN CHAR,
	p_BEST_FIT_METHOD IN CHAR,
	p_SERVICE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_BEST_FIT_VAR OUT NUMBER,
	p_BEST_FIT_PCT OUT NUMBER
	) AS

-- Note: p_BEGIN_DATE and p_END_DATE are CUT Dates.

v_ABS_BEST_FIT_PCT NUMBER;

CURSOR c_BEST_FIT_VALS IS
	SELECT 100 * (LOAD_VAL - DECODE(p_BEST_FIT_METHOD,'H',HISTORICAL_VAL,'A',AVERAGE_VAL,'R',MOST_RECENT_VAL,NULL))/DECODE(LOAD_VAL,0,NULL,LOAD_VAL) AS BEST_FIT_PCT,
		LOAD_VAL - DECODE(p_BEST_FIT_METHOD,'H',HISTORICAL_VAL,'A',AVERAGE_VAL,'R',MOST_RECENT_VAL,NULL) AS BEST_FIT_VAR,
		ABS((LOAD_VAL - DECODE(p_BEST_FIT_METHOD,'H',HISTORICAL_VAL,'A',AVERAGE_VAL,'R',MOST_RECENT_VAL,NULL))/DECODE(LOAD_VAL,0,NULL,LOAD_VAL)) AS ABS_BEST_FIT_PCT
	FROM SERVICE_VALIDATION_LOAD
	WHERE SERVICE_ID = p_SERVICE_ID
		AND LOAD_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
	ORDER BY 3 DESC;

BEGIN

	OPEN c_BEST_FIT_VALS;
	FETCH c_BEST_FIT_VALS INTO p_BEST_FIT_PCT, p_BEST_FIT_VAR, v_ABS_BEST_FIT_PCT;
	CLOSE c_BEST_FIT_VALS;

EXCEPTION
	WHEN OTHERS THEN
		  BEGIN
		  	CLOSE c_BEST_FIT_VALS;
		  EXCEPTION
		  	WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE();
		  END;
		  ERRS.LOG_AND_RAISE();
END GET_BEST_FIT_VALS;
--------------------------------------------------------------------------------------------------
PROCEDURE PUT_VALIDATION_BEST_FIT
	(
	p_SERVICE_DATE IN DATE
	) AS

v_PEAK_BEGIN NUMBER(2);
v_PEAK_END NUMBER(2);
v_NUM_HOURS NUMBER(2);
v_RULE_RECORD VARIANCE_RULE_RECORD;
v_RULE_TABLE VARIANCE_RULE_TABLE;
v_IDX BINARY_INTEGER;

v_TOTAL_RULE_BOOL BOOLEAN;
v_PEAK_RULE_BOOL BOOLEAN;
v_HOUR_RULE_BOOL BOOLEAN;

v_TOTAL_VAR SERVICE_VALIDATION_BEST_FIT.TOTAL_VAR%TYPE;
v_TOTAL_PCT SERVICE_VALIDATION_BEST_FIT.TOTAL_PCT%TYPE;
v_TOTAL_RULE SERVICE_VALIDATION_BEST_FIT.TOTAL_RULE%TYPE;
v_TOTAL_METHOD CHAR(1);
v_PEAK_PCT SERVICE_VALIDATION_BEST_FIT.PEAK_PCT%TYPE;
v_PEAK_VAR SERVICE_VALIDATION_BEST_FIT.PEAK_VAR%TYPE;
v_PEAK_RULE SERVICE_VALIDATION_BEST_FIT.PEAK_RULE%TYPE;
v_PEAK_METHOD CHAR(1);
v_HOUR_PCT SERVICE_VALIDATION_BEST_FIT.HOUR_PCT%TYPE;
v_HOUR_VAR SERVICE_VALIDATION_BEST_FIT.HOUR_VAR%TYPE;
v_HOUR_RULE SERVICE_VALIDATION_BEST_FIT.HOUR_RULE%TYPE;
v_HOUR_METHOD CHAR(1);

v_BEGIN_DATE DATE;
v_END_DATE DATE;

CURSOR c_ENTITY IS
	SELECT DISTINCT SERVICE_ID
	FROM SERVICE_VALIDATION_LOAD
	WHERE LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE;

CURSOR c_RULES IS
	SELECT SUBSTR(VALUE, 1, INSTR(VALUE, ';') - 1) AS PERCENT,
			SUBSTR(VALUE, INSTR(VALUE, ';') + 1, INSTR(VALUE, ';', 1, 2) - INSTR(VALUE, ';') - 1) AS MAGNITUDE
	FROM SYSTEM_DICTIONARY
	WHERE MODEL_ID = 0 AND MODULE = 'Forecasting'
		AND KEY1 = 'Validation' AND KEY2 = '?' AND KEY3 = '?'
		AND SETTING_NAME LIKE 'Rule%'
	ORDER BY SETTING_NAME;

BEGIN

	UT.CUT_DATE_RANGE(TRUNC(p_SERVICE_DATE), LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	v_PEAK_BEGIN := MODEL_VALUE_AT_KEY(0, 'Forecasting', 'Validation', 'Peak Begin Hour');
	v_PEAK_END := MODEL_VALUE_AT_KEY(0, 'Forecasting', 'Validation', 'Peak End Hour');
	v_NUM_HOURS := MODEL_VALUE_AT_KEY(0, 'Forecasting', 'Validation', 'Number of Hours');

	v_IDX := 1;
	OPEN c_RULES;
	LOOP
		FETCH c_RULES INTO v_RULE_RECORD;
		EXIT WHEN c_RULES%NOTFOUND;
		v_RULE_TABLE(v_IDX) := v_RULE_RECORD;
		v_IDX := v_IDX + 1;
	END LOOP;
	CLOSE c_RULES;

	DELETE SERVICE_VALIDATION_BEST_FIT WHERE SERVICE_DATE = p_SERVICE_DATE;

	FOR v_ENTITY IN c_ENTITY LOOP
		 GET_BEST_FIT_METHOD(v_ENTITY.SERVICE_ID, v_BEGIN_DATE, v_END_DATE, v_PEAK_BEGIN, v_PEAK_END, v_NUM_HOURS, v_TOTAL_METHOD, v_PEAK_METHOD, v_HOUR_METHOD);
		 GET_BEST_FIT_VALS('T', v_TOTAL_METHOD, v_ENTITY.SERVICE_ID, v_BEGIN_DATE, v_END_DATE, v_TOTAL_VAR, v_TOTAL_PCT);
		 GET_BEST_FIT_VALS('P', v_PEAK_METHOD, v_ENTITY.SERVICE_ID, v_BEGIN_DATE, v_END_DATE, v_PEAK_VAR, v_PEAK_PCT);
		 GET_BEST_FIT_VALS('H', v_HOUR_METHOD, v_ENTITY.SERVICE_ID, v_BEGIN_DATE + (v_PEAK_BEGIN / 24), v_BEGIN_DATE + (v_PEAK_END / 24), v_HOUR_VAR, v_HOUR_PCT);

--Check Whether these Values Violate the Rules.
		 v_TOTAL_RULE_BOOL := FALSE; v_PEAK_RULE_BOOL := FALSE; v_HOUR_RULE_BOOL := FALSE;
		 FOR v_IDX IN v_RULE_TABLE.FIRST .. v_RULE_TABLE.LAST LOOP
		 	  v_TOTAL_RULE_BOOL := v_TOTAL_RULE_BOOL OR (ABS(v_TOTAL_PCT) >= v_RULE_TABLE(v_IDX).PERCENT AND ABS(v_TOTAL_VAR) >= v_RULE_TABLE(v_IDX).MAGNITUDE);
		 	  v_PEAK_RULE_BOOL := v_PEAK_RULE_BOOL OR (ABS(v_PEAK_PCT) >= v_RULE_TABLE(v_IDX).PERCENT AND ABS(v_PEAK_VAR) >= v_RULE_TABLE(v_IDX).MAGNITUDE);
		 	  v_HOUR_RULE_BOOL := v_HOUR_RULE_BOOL OR (ABS(v_HOUR_PCT) >= v_RULE_TABLE(v_IDX).PERCENT AND ABS(v_HOUR_VAR) >= v_RULE_TABLE(v_IDX).MAGNITUDE);
		 END LOOP;
		 IF v_TOTAL_RULE_BOOL THEN v_TOTAL_RULE := 1; ELSE v_TOTAL_RULE := 0; END IF;
		 IF v_PEAK_RULE_BOOL THEN v_PEAK_RULE := 1; ELSE v_PEAK_RULE := 0; END IF;
		 IF v_HOUR_RULE_BOOL THEN v_HOUR_RULE := 1; ELSE v_HOUR_RULE := 0; END IF;

		 INSERT INTO SERVICE_VALIDATION_BEST_FIT(SERVICE_ID, SERVICE_DATE, TOTAL_VAR, TOTAL_PCT, TOTAL_METHOD, TOTAL_RULE, PEAK_VAR, PEAK_PCT, PEAK_METHOD, PEAK_RULE, HOUR_VAR, HOUR_PCT, HOUR_METHOD, HOUR_RULE)
		 VALUES(v_ENTITY.SERVICE_ID, p_SERVICE_DATE, v_TOTAL_VAR, v_TOTAL_PCT, v_TOTAL_METHOD, v_TOTAL_RULE, v_PEAK_VAR, v_PEAK_PCT, v_PEAK_METHOD, v_PEAK_RULE, v_HOUR_VAR, v_HOUR_PCT, v_HOUR_METHOD, v_HOUR_RULE);

	END LOOP;

END PUT_VALIDATION_BEST_FIT;
----------------------------------------------------------------------------------------------------
PROCEDURE COERCE_SERVICE_VALIDATION
	(
	p_SERVICE_DATE IN DATE,
	p_SERVICE_VALIDATION IN OUT NOCOPY SERVICE_VALIDATION_TABLE
	) AS

v_INDEX BINARY_INTEGER;
v_DST_HOUR NUMBER(2) := 99;

BEGIN

	IF TRUNC(p_SERVICE_DATE) = TRUNC(DST_SPRING_AHEAD_DATE(p_SERVICE_DATE)) THEN
		IF GA.DST_SPRING_AHEAD_OPTION = 'A' THEN
			v_DST_HOUR := 2;
		ELSIF GA.DST_SPRING_AHEAD_OPTION = 'B' THEN
			IF p_SERVICE_VALIDATION.EXISTS(2) THEN
				p_SERVICE_VALIDATION(3).LOAD_VAL := p_SERVICE_VALIDATION(2).LOAD_VAL;
			END IF;
			v_DST_HOUR := 2;
		ELSIF GA.DST_SPRING_AHEAD_OPTION = 'C' THEN
			v_DST_HOUR := 0;
		END IF;
		FOR v_INDEX IN p_SERVICE_VALIDATION.FIRST..p_SERVICE_VALIDATION.LAST LOOP
			IF p_SERVICE_VALIDATION.EXISTS(v_INDEX) THEN
				IF TO_CHAR(p_SERVICE_VALIDATION(v_INDEX).LOAD_DATE, 'HH24') = v_DST_HOUR THEN
					p_SERVICE_VALIDATION.DELETE(v_INDEX);
				ELSE
					p_SERVICE_VALIDATION(v_INDEX).LOAD_DATE := TO_CUT(p_SERVICE_VALIDATION(v_INDEX).LOAD_DATE, LOCAL_TIME_ZONE);
				END IF;
			END IF;
		END LOOP;
	ELSIF TRUNC(p_SERVICE_DATE) = TRUNC(DST_FALL_BACK_DATE(p_SERVICE_DATE)) THEN
		IF GA.DST_FALL_BACK_OPTION = 'A' THEN
			FOR v_INDEX IN p_SERVICE_VALIDATION.FIRST..p_SERVICE_VALIDATION.LAST LOOP
				IF p_SERVICE_VALIDATION.EXISTS(v_INDEX) THEN
					IF TO_CHAR(p_SERVICE_VALIDATION(v_INDEX).LOAD_DATE, 'HH24') = 2 THEN
						p_SERVICE_VALIDATION.EXTEND;
						p_SERVICE_VALIDATION(p_SERVICE_VALIDATION.LAST) := SERVICE_VALIDATION_TYPE(p_SERVICE_VALIDATION(v_INDEX).SERVICE_ID, TO_CUT(p_SERVICE_VALIDATION(v_INDEX).LOAD_DATE, STD_TIME_ZONE(LOCAL_TIME_ZONE)), p_SERVICE_VALIDATION(v_INDEX).LOAD_VAL, p_SERVICE_VALIDATION(v_INDEX).HISTORICAL_VAL, p_SERVICE_VALIDATION(v_INDEX).AVERAGE_VAL,  p_SERVICE_VALIDATION(v_INDEX).MOST_RECENT_VAL);
					END IF;
					p_SERVICE_VALIDATION(v_INDEX).LOAD_DATE := TO_CUT(p_SERVICE_VALIDATION(v_INDEX).LOAD_DATE, LOCAL_TIME_ZONE);
				END IF;
			END LOOP;
		END IF;
	ELSE
		FOR v_INDEX IN p_SERVICE_VALIDATION.FIRST..p_SERVICE_VALIDATION.LAST LOOP
			IF p_SERVICE_VALIDATION.EXISTS(v_INDEX) THEN
				p_SERVICE_VALIDATION(v_INDEX).LOAD_DATE := TO_CUT(p_SERVICE_VALIDATION(v_INDEX).LOAD_DATE, LOCAL_TIME_ZONE);
			END IF;
		END LOOP;
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		FOR v_INDEX IN p_SERVICE_VALIDATION.FIRST..p_SERVICE_VALIDATION.LAST LOOP
			IF p_SERVICE_VALIDATION.EXISTS(v_INDEX) THEN
				LOGS.LOG_DEBUG(TO_CHAR(p_SERVICE_VALIDATION(v_INDEX).SERVICE_ID) || ',' ||
					UT.TRACE_DATE(p_SERVICE_VALIDATION(v_INDEX).LOAD_DATE) || ',' ||
					TO_CHAR(p_SERVICE_VALIDATION(v_INDEX).LOAD_VAL) || ',' ||
					TO_CHAR(p_SERVICE_VALIDATION(v_INDEX).HISTORICAL_VAL) || ',' ||
					TO_CHAR(p_SERVICE_VALIDATION(v_INDEX).AVERAGE_VAL) || ',' ||
					TO_CHAR(p_SERVICE_VALIDATION(v_INDEX).MOST_RECENT_VAL));
			END IF;
		END LOOP;
	END IF;

END COERCE_SERVICE_VALIDATION;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SERVICE_VALIDATION_EXT
	(
	p_MODEL_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_REQUEST_TYPE IN VARCHAR,
	p_WORK_ID IN NUMBER
	) AS

v_STATUS NUMBER;
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_SERVICE_IDENT SERVICE_IDENT_TABLE := SERVICE_IDENT_TABLE();
v_SERVICE_VALIDATION SERVICE_VALIDATION_TABLE := SERVICE_VALIDATION_TABLE();

BEGIN

	SELECT SERVICE_IDENT_TYPE(A.SERVICE_ID, D.ACCOUNT_EXTERNAL_IDENTIFIER, NULL)
	BULK COLLECT INTO v_SERVICE_IDENT
	FROM SERVICE A, SERVICE_STATE B, ACCOUNT_SERVICE C, ACCOUNT D, PROVIDER_SERVICE E, RTO_WORK F, SERVICE_DELIVERY G
	WHERE A.MODEL_ID = p_MODEL_ID
		AND A.SCENARIO_ID = GA.BASE_SCENARIO_ID
		AND A.AS_OF_DATE = p_AS_OF_DATE
		AND B.SERVICE_ID = A.SERVICE_ID
		AND B.SERVICE_CODE = GA.FORECAST_SERVICE
		AND B.SERVICE_DATE = TRUNC(p_SERVICE_DATE)
		AND B.METER_TYPE = 'I'
		AND C.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
		AND D.ACCOUNT_ID = C.ACCOUNT_ID
		AND D.IS_EXTERNAL_INTERVAL_USAGE = 1
		AND E.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
		AND E.ESP_ID = F.WORK_XID
		AND F.WORK_ID = p_WORK_ID
		AND G.SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID;

	IF v_SERVICE_IDENT.COUNT > 0 THEN
		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG('GET_SERVICE_VALIDATION_EXT SERVICE SELECTION ELAPSED TIME= ' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED));
		END IF;
		v_ELAPSED := DBMS_UTILITY.GET_TIME;
		XS.GET_SERVICE_VALIDATION(p_REQUEST_TYPE, p_SERVICE_DATE, p_AS_OF_DATE, v_SERVICE_IDENT, v_SERVICE_VALIDATION, v_STATUS);
		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG('GET_SERVICE_VALIDATION_EXT SERVICE USAGE ELAPSED TIME= ' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED));
		END IF;
		v_SERVICE_IDENT.DELETE;

		COERCE_SERVICE_VALIDATION(p_SERVICE_DATE, v_SERVICE_VALIDATION);

		UT.CUT_DATE_RANGE(p_MODEL_ID, p_SERVICE_DATE, LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
		DELETE SERVICE_VALIDATION_LOAD WHERE SERVICE_ID BETWEEN 1 AND 999999999
			AND LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE;

		INSERT INTO SERVICE_VALIDATION_LOAD (SERVICE_ID, LOAD_DATE, HISTORICAL_VAL, AVERAGE_VAL, MOST_RECENT_VAL)
		SELECT SERVICE_ID, LOAD_DATE, HISTORICAL_VAL, AVERAGE_VAL, MOST_RECENT_VAL
		FROM TABLE(CAST(v_SERVICE_VALIDATION AS SERVICE_VALIDATION_TABLE));

		UPDATE SERVICE_VALIDATION_LOAD X
		SET LOAD_VAL =
			(SELECT LOAD_VAL
			FROM SERVICE_LOAD A
			WHERE A.SERVICE_ID = X.SERVICE_ID
				AND A.SERVICE_CODE = GA.FORECAST_SERVICE
				AND A.LOAD_DATE = X.LOAD_DATE
				AND A.LOAD_CODE = GA.STANDARD)
		WHERE X.SERVICE_ID = X.SERVICE_ID
			AND X.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE;

		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG('GET_SERVICE_VALIDATION_EXT ELAPSED TIME= ' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED));
		END IF;
	END IF;

END GET_SERVICE_VALIDATION_EXT;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SERVICE_VALIDATION_INT
	(
	p_MODEL_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_REQUEST_TYPE IN VARCHAR,
	p_WORK_ID IN NUMBER
	) AS

v_STATUS NUMBER;
v_ELAPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_HISTORICAL_DATE DATE;
v_HISTORICAL_DAY VARCHAR(16);
v_HISTORICAL_BEGIN_DATE DATE;
v_HISTORICAL_END_DATE DATE;
v_SERVICE_TO_COMPARE CHAR(1) := GA.ACTUAL_SERVICE;

BEGIN

	UT.CUT_DATE_RANGE(p_MODEL_ID, p_SERVICE_DATE, LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	DELETE SERVICE_VALIDATION_LOAD WHERE SERVICE_ID BETWEEN 1 AND 999999999
		AND LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE;

-- Base Forecast for period of interest.
	INSERT INTO SERVICE_VALIDATION_LOAD (SERVICE_ID, LOAD_DATE, LOAD_VAL)
	SELECT E.SERVICE_ID, E.LOAD_DATE, E.LOAD_VAL
	FROM SERVICE A, SERVICE_STATE B, PROVIDER_SERVICE C, RTO_WORK D, SERVICE_LOAD E
	WHERE A.MODEL_ID = p_MODEL_ID
		AND A.SCENARIO_ID = GA.BASE_SCENARIO_ID
		AND A.AS_OF_DATE = p_AS_OF_DATE
		AND B.SERVICE_ID = A.SERVICE_ID
		AND B.SERVICE_CODE = GA.FORECAST_SERVICE
		AND B.SERVICE_DATE = TRUNC(p_SERVICE_DATE)
		AND B.METER_TYPE = 'I'
		AND C.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
		AND D.WORK_ID = p_WORK_ID
		AND D.WORK_XID = C.ESP_ID
		AND E.SERVICE_ID = B.SERVICE_ID
		AND E.SERVICE_CODE = B.SERVICE_CODE
		AND E.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND E.LOAD_CODE = GA.STANDARD;

-- Historical: Same Day Type Last Year.

	SIMILAR_DAY_TYPE(CONSTANTS.NOT_ASSIGNED, p_SERVICE_DATE, p_SERVICE_DATE - 300, p_SERVICE_DATE - 400, v_HISTORICAL_DATE, v_STATUS);

	UPDATE SERVICE_VALIDATION_LOAD X
	SET HISTORICAL_VAL =
		(SELECT LOAD_VAL
		FROM SERVICE_LOAD A
		WHERE A.SERVICE_ID = X.SERVICE_ID
			AND A.SERVICE_CODE = v_SERVICE_TO_COMPARE
			AND A.LOAD_DATE BETWEEN v_HISTORICAL_BEGIN_DATE AND v_HISTORICAL_END_DATE
			AND A.LOAD_CODE = GA.STANDARD
			AND TO_CHAR(A.LOAD_DATE, 'HH24:MI') = TO_CHAR(X.LOAD_DATE, 'HH24:MI'))
	WHERE X.SERVICE_ID = X.SERVICE_ID
		AND X.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE;

-- Average: Same Day Type Last Four Weeks Prior to the Service Date.
-- If the Service Date is a Holiday then use the Prior Year Holiday.

	v_HISTORICAL_DAY := DATE_DAY_NAME(p_SERVICE_DATE, CONSTANTS.NOT_ASSIGNED);
	IF UPPER(v_HISTORICAL_DAY) = 'HOL' THEN
		SIMILAR_DAY_TYPE(CONSTANTS.NOT_ASSIGNED, p_SERVICE_DATE, p_SERVICE_DATE -300, p_SERVICE_DATE -400, v_HISTORICAL_DATE, v_STATUS);
		UT.CUT_DATE_RANGE(p_MODEL_ID, v_HISTORICAL_DATE, LOCAL_TIME_ZONE, v_HISTORICAL_BEGIN_DATE, v_HISTORICAL_END_DATE);
	ELSE
		UT.CUT_DATE_RANGE(p_MODEL_ID, p_SERVICE_DATE - 28, p_SERVICE_DATE - 7, LOCAL_TIME_ZONE, v_HISTORICAL_BEGIN_DATE, v_HISTORICAL_END_DATE);
	END IF;

	UPDATE SERVICE_VALIDATION_LOAD X
	SET AVERAGE_VAL =
		(SELECT AVG(LOAD_VAL)
		FROM SERVICE_LOAD A
		WHERE A.SERVICE_ID = X.SERVICE_ID
			AND A.SERVICE_CODE = v_SERVICE_TO_COMPARE
			AND A.LOAD_DATE BETWEEN v_HISTORICAL_BEGIN_DATE AND v_HISTORICAL_END_DATE
			AND A.LOAD_CODE = GA.STANDARD
			AND DATE_DAY_NAME(A.LOAD_DATE, CONSTANTS.NOT_ASSIGNED) = v_HISTORICAL_DAY)
	WHERE X.SERVICE_ID = X.SERVICE_ID
		AND X.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE;

-- Most Recent: Same Day Type Last Two Months of the Current Year.

	v_HISTORICAL_DAY := TO_CHAR(p_SERVICE_DATE, 'DAY');

	UPDATE SERVICE_VALIDATION_LOAD X
	SET MOST_RECENT_VAL =
		(SELECT LOAD_VAL
		FROM SERVICE_LOAD A
		WHERE A.SERVICE_ID = X.SERVICE_ID
			AND A.SERVICE_CODE = v_SERVICE_TO_COMPARE
			AND A.LOAD_DATE =
				(SELECT MAX(LOAD_DATE)
				FROM SERVICE_LOAD
				WHERE SERVICE_ID = A.SERVICE_ID
					AND SERVICE_CODE = A.SERVICE_CODE
					AND LOAD_DATE <= p_SERVICE_DATE + 60
					AND LOAD_CODE = A.LOAD_CODE
					AND TO_CHAR(LOAD_DATE, 'DAY') = v_HISTORICAL_DAY)
			AND A.LOAD_CODE = GA.STANDARD
			AND TO_CHAR(A.LOAD_DATE, 'DAY') = v_HISTORICAL_DAY)
	WHERE X.SERVICE_ID = X.SERVICE_ID
		AND X.LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('GET_SERVICE_VALIDATION_INT ELAPSED TIME= ' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELAPSED));
	END IF;

END GET_SERVICE_VALIDATION_INT;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SERVICE_VALIDATION
	(
	p_MODEL_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_REQUEST_TYPE IN VARCHAR,
	p_ESP_IDS IN VARCHAR
	) AS

v_WORK_ID NUMBER(9);
v_ESP_IDS GA.STRING_TABLE;
v_AS_OF_DATE DATE := CORRECTED_AS_OF_DATE(p_AS_OF_DATE, 'Forecast');

BEGIN

-- Put the ESP Ids Into the Rto_Work Table for Joining.
	UT.TOKENS_FROM_STRING(p_ESP_IDS, ',', v_ESP_IDS);
	UT.GET_RTO_WORK_ID(v_WORK_ID);
	FOR v_INDEX IN v_ESP_IDS.FIRST..v_ESP_IDS.LAST LOOP
		UT.POST_RTO_WORK(v_WORK_ID, NULL, TO_NUMBER(v_ESP_IDS(v_INDEX)));
	END LOOP;

	IF GA.ENABLE_EXTERNAL_METER_ACCESS THEN
		GET_SERVICE_VALIDATION_EXT(p_MODEL_ID, p_SERVICE_DATE, v_AS_OF_DATE, p_REQUEST_TYPE, v_WORK_ID);
	ELSE
		GET_SERVICE_VALIDATION_INT(p_MODEL_ID, p_SERVICE_DATE, v_AS_OF_DATE, p_REQUEST_TYPE, v_WORK_ID);
	END IF;

	UT.PURGE_RTO_WORK(v_WORK_ID);

EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			UT.PURGE_RTO_WORK(v_WORK_ID);
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE();
		END;
		ERRS.LOG_AND_RAISE();
END GET_SERVICE_VALIDATION;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_LOAD_PROFILE_POINTS
	(
	p_PROFILE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ALL_DATES IN NUMBER := 0,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_POINT_INDEX IN NUMBER := 1,
	p_ALL_INDEXES IN NUMBER := 0,
	p_DAY_SELECTION IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the PROFILE_POINTS for the specified Profile, Internal or External

v_IS_EXTERNAL_PROFILE NUMBER := 0;
v_INTERVALS_PER_DAY NUMBER := 0;
v_MODEL_ID NUMBER := GA.ELECTRIC_MODEL;
v_ADJUST NUMBER(6,5) := 1/86400;	--Hourly default: 1 sec Adjustment to get midnite into proper HED day (for Hourly profiles)
v_STD_TIME_ZONE VARCHAR2(8);
v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
	   ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

    IF GA.DEFAULT_MODEL = GA.GAS_MODEL THEN v_INTERVALS_PER_DAY := 1;  END IF;  --Set default

    -- Check if Profile is External
	SELECT  NVL(IS_EXTERNAL_PROFILE,0), NVL(PROFILE_INTERVAL, v_INTERVALS_PER_DAY)
	INTO v_IS_EXTERNAL_PROFILE, v_INTERVALS_PER_DAY
    FROM LOAD_PROFILE
	WHERE PROFILE_ID = p_PROFILE_ID;

	--Set MODEL_ID for CUT_DATE_RANGE based on PROFILE_INTERVAL
    IF v_INTERVALS_PER_DAY <= 1 THEN    --Daily
		v_MODEL_ID := GA.GAS_MODEL;
        v_ADJUST := 0;
	END IF;

    v_STD_TIME_ZONE := STD_TIME_ZONE(p_TIME_ZONE);  --Profile dates should always be referenced to StandardTimeZone to avoid problems with DST periods
    UT.CUT_DATE_RANGE(v_MODEL_ID, p_BEGIN_DATE, p_END_DATE, v_STD_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

    IF v_IS_EXTERNAL_PROFILE = 0 THEN  --Internal
     	IF p_ALL_INDEXES <> 0 THEN  --Return All POINT_INDEXes
    		OPEN p_CURSOR FOR
           	   SELECT  FROM_CUT(POINT_DATE, v_STD_TIME_ZONE) "POINT_DATE",   --Profile dates should always be referenced to StandardTimeZone to avoid problems with DST periods
                        POINT_VAL,
                        POINT_INDEX
                FROM LOAD_PROFILE_POINT
            	WHERE PROFILE_ID = p_PROFILE_ID
                    AND (p_ALL_DATES <> 0 OR POINT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE)
                    AND AS_OF_DATE = p_AS_OF_DATE
                    ORDER BY POINT_INDEX, POINT_DATE;

        ELSE  --Just one POINT_INDEX
         	IF NVL(LENGTH(p_DAY_SELECTION),0) = 0 THEN  -- don't check p_DAY_SELECTION
        		OPEN p_CURSOR FOR
               	   SELECT  FROM_CUT(POINT_DATE, v_STD_TIME_ZONE) "POINT_DATE",   --Profile dates should always be referenced to StandardTimeZone to avoid problems with DST periods
                            POINT_VAL
                    FROM LOAD_PROFILE_POINT
                	WHERE PROFILE_ID = p_PROFILE_ID
                		AND POINT_INDEX = p_POINT_INDEX
                        AND (p_ALL_DATES <> 0 OR POINT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE)
                        AND AS_OF_DATE = p_AS_OF_DATE
                        ORDER BY POINT_DATE;

            ELSE    -- Do check p_DAY_SELECTION
        		OPEN p_CURSOR FOR
               	   SELECT  FROM_CUT(POINT_DATE, v_STD_TIME_ZONE) "POINT_DATE",   --Profile dates should always be referenced to StandardTimeZone to avoid problems with DST periods
                            POINT_VAL
                    FROM LOAD_PROFILE_POINT
                	WHERE PROFILE_ID = p_PROFILE_ID
                		AND POINT_INDEX = p_POINT_INDEX
                        AND (p_ALL_DATES <> 0 OR POINT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE)
                        AND AS_OF_DATE = p_AS_OF_DATE
				        AND INSTR(p_DAY_SELECTION, TO_CHAR(FROM_CUT(POINT_DATE, v_STD_TIME_ZONE), 'D')) > 0
                        ORDER BY POINT_DATE;

            END IF;
        END IF;

    ELSE    --External
        XS.GET_LOAD_PROFILE_POINTS
            	(
            	p_PROFILE_ID,
            	p_BEGIN_DATE,
            	p_END_DATE,
            	p_ALL_DATES,
            	p_TIME_ZONE,
            	p_AS_OF_DATE,
            	p_POINT_INDEX,
            	p_ALL_INDEXES,
                p_DAY_SELECTION,
            	p_STATUS,
            	p_CURSOR
            	);
    END IF;

END GET_LOAD_PROFILE_POINTS;
--------------------------------------------------------------------------
FUNCTION INTERVAL_FROM_CALENDAR_PROFS
	(
	p_CALENDAR_ID IN NUMBER,
	p_DAY IN DATE
	) RETURN VARCHAR2 IS

v_PROFILE_INTERVAL_NUM LOAD_PROFILE.PROFILE_INTERVAL%TYPE;

BEGIN

	-- Try in Calendar Profile.  If there is a production profile, use it first.
	SELECT MAX(PROFILE_INTERVAL)
	INTO v_PROFILE_INTERVAL_NUM
	FROM
		(SELECT L.PROFILE_INTERVAL, CASE S.PROFILE_STATUS WHEN 'Production' THEN 0 ELSE 1 END
		FROM CALENDAR_PROFILE C, LOAD_PROFILE_STATISTICS S, LOAD_PROFILE L
		WHERE C.CALENDAR_ID = p_CALENDAR_ID
			AND p_DAY BETWEEN C.BEGIN_DATE AND NVL(C.END_DATE, CONSTANTS.HIGH_DATE)
			AND C.PROFILE_ID = L.PROFILE_ID
			AND L.PROFILE_ID = S.PROFILE_ID
		ORDER BY 2)
	WHERE ROWNUM = 1;

	-- Try in Calendar Profile Library
	IF v_PROFILE_INTERVAL_NUM IS NULL THEN
		SELECT MAX(PROFILE_INTERVAL)
		INTO v_PROFILE_INTERVAL_NUM
		FROM
			(SELECT L.PROFILE_INTERVAL, CASE S.PROFILE_STATUS WHEN 'Production' THEN 0 ELSE 1 END
			FROM CALENDAR_PROFILE_LIBRARY C, LOAD_PROFILE L, LOAD_PROFILE_STATISTICS S
			WHERE C.CALENDAR_ID = p_CALENDAR_ID
				AND p_DAY BETWEEN C.BEGIN_DATE AND NVL(C.END_DATE, CONSTANTS.HIGH_DATE)
				AND C.PROFILE_LIBRARY_ID = L.PROFILE_LIBRARY_ID
				AND L.PROFILE_ID = S.PROFILE_ID
			ORDER BY 2)
		WHERE ROWNUM = 1;
	END IF;

	IF v_PROFILE_INTERVAL_NUM IS NOT NULL THEN
		-- Return the interval's name.
		RETURN DATE_UTIL.GET_PROFILE_INTERVAL_NAME(v_PROFILE_INTERVAL_NUM);
	ELSE
		RETURN NULL;
	END IF;

END INTERVAL_FROM_CALENDAR_PROFS;
--------------------------------------------------------------------------
FUNCTION GET_DEFAULT_INTERVAL RETURN VARCHAR2 IS
BEGIN
	-- default to Hour for electric, Day for gas
	IF GA.DEFAULT_MODEL = GA.ELECTRIC_MODEL THEN
		RETURN DATE_UTIL.c_NAME_HOUR;
	ELSE
		RETURN DATE_UTIL.c_NAME_DAY;
	END IF;
END GET_DEFAULT_INTERVAL;
--------------------------------------------------------------------------
-- Returns the name of the Interval of the a Profile assigned to this calendar
--   for the specified day.
FUNCTION GET_INTERVAL_FOR_CALENDAR
	(
	p_CALENDAR_ID IN NUMBER,
	p_DAY IN DATE
	) RETURN VARCHAR2 IS

v_RET VARCHAR2(16);

BEGIN

	v_RET := INTERVAL_FROM_CALENDAR_PROFS(p_CALENDAR_ID, p_DAY);

	IF v_RET IS NULL THEN
		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG('Could not determine interval for '||TEXT_UTIL.TO_CHAR_ENTITY(p_CALENDAR_ID,EC.ED_CALENDAR,TRUE)||' on '||
							TEXT_UTIL.TO_CHAR_DATE(p_DAY)||' - no assigned profiles');
		END IF;
		v_RET := GET_DEFAULT_INTERVAL;
	END IF;

	RETURN v_RET;

END GET_INTERVAL_FOR_CALENDAR;
---------------------------------------------------------------------------------------------------
FUNCTION GET_INTERVAL_FOR_ACCOUNT
	(
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_CALENDAR_TYPE IN VARCHAR2 := 'Forecast'
	) RETURN VARCHAR2 IS

v_RET VARCHAR2(16);

BEGIN

	v_RET := INTERVAL_FROM_CALENDAR_PROFS(GET_ACCOUNT_CALENDAR_ID(p_ACCOUNT_ID, p_SERVICE_DATE, p_CALENDAR_TYPE), p_SERVICE_DATE);

	IF v_RET IS NULL THEN
		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG('Could not determine interval for '||TEXT_UTIL.TO_CHAR_ENTITY(p_ACCOUNT_ID,EC.ED_ACCOUNT,TRUE)||' on '||
							TEXT_UTIL.TO_CHAR_DATE(p_SERVICE_DATE)||' using '||p_CALENDAR_TYPE||' calendar');
		END IF;
		v_RET := GET_DEFAULT_INTERVAL;
	END IF;

	RETURN v_RET;

END GET_INTERVAL_FOR_ACCOUNT;
---------------------------------------------------------------------------------------------------
FUNCTION GET_INTERVAL_FOR_METER
	(
	p_METER_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_CALENDAR_TYPE IN VARCHAR2 := 'Forecast'
	) RETURN VARCHAR2 IS

v_RET VARCHAR2(16);

BEGIN

	-- First check the meter's scalar attribute
	SELECT MAX(METER_INTERVAL)
	INTO v_RET
	FROM METER
	WHERE METER_ID = p_METER_ID;

	IF v_RET IS NULL OR v_RET = CONSTANTS.UNDEFINED_ATTRIBUTE THEN
		-- fall-back to calendar
		v_RET := INTERVAL_FROM_CALENDAR_PROFS(GET_METER_CALENDAR_ID(p_METER_ID, p_SERVICE_DATE, p_CALENDAR_TYPE), p_SERVICE_DATE);
	END IF;

	IF v_RET IS NULL THEN
		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG('Could not determine interval for '||TEXT_UTIL.TO_CHAR_ENTITY(p_METER_ID,EC.ED_METER,TRUE)||' on '||
							TEXT_UTIL.TO_CHAR_DATE(p_SERVICE_DATE)||' using '||p_CALENDAR_TYPE||' calendar');
		END IF;
		v_RET := GET_DEFAULT_INTERVAL;
	END IF;

	RETURN v_RET;

END GET_INTERVAL_FOR_METER;
---------------------------------------------------------------------------------------------------
END FP;
/
