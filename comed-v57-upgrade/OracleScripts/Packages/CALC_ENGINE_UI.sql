CREATE OR REPLACE PACKAGE CALC_ENGINE_UI IS
--Revision $Revision: 1.7 $

  -- AUTHOR  : JHUMPHRIES
  -- CREATED : 2/28/2008 8:03:46 AM
  -- PURPOSE : To provide data to the User Interface for the Calculations Run Screen
  -- and the Calculation Intermediate Results screens.

c_SHOW_RUNNING	CONSTANT NUMBER(1) := 1;
c_SHOW_FINISHED	CONSTANT NUMBER(1) := 2;
c_SHOW_ALL 		CONSTANT NUMBER(1) := 3;

FUNCTION WHAT_VERSION RETURN VARCHAR2;

-- Get the list of entities for the specified process. This will query the realm
-- or group that defines the process’s set of context entities. An entity whose ID
-- matches the selected specified entity ID will default as selected. If the specified
-- ID is -1, then all IDs will default to selected. If the process has no context domain
-- then this will return an empty cursor.
PROCEDURE GET_PROCESS_ENTITIES_TO_RUN
	(
	p_CALC_PROCESS_ID IN NUMBER,
	p_SELECTED_ENTITY_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CURSOR OUT GA.REFCURSOR
	);

-- Run the specified process for the specified context entities.
PROCEDURE RUN_SELECTED_PROCESSES
	(
	p_CALC_PROCESS_ID IN NUMBER,
	p_SELECTED_ENTITIES IN NUMBER_COLLECTION,
	p_STATEMENT_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_PROCESS_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR2
	);

-- Get the list of eligible entities for the specified process. This will query the realm
-- or group that defines the process’s set of context entities. If more than one process
-- is specified (since it could be comma-separated list) then return an empty list.
PROCEDURE GET_PROCESS_ENTITIES
	(
	p_CALC_PROCESS_ID IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

-- Get the list of statement types. If no select calculation process is statement-type-specific then
-- no selection is necessary.
PROCEDURE GET_STATEMENT_TYPES
	(
	p_CALC_PROCESS_ID IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

-- Get the list of eligible components for the specified process. This will return all
-- components that are steps in the selected process. If more than one process is
-- specified (since it could be comma-separated list) then return a single entry: <ALL>
PROCEDURE GET_PROCESS_COMPONENTS
	(
	p_CALC_PROCESS_ID IN VARCHAR2,
	p_COMPONENT_CAT IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

-- This will grab a summary of calculation process intermediate results. It queries the
-- CALCULATION_RUN and CALCULATION_RUN_GLOBAL tables. The PROCESS_ID and ENTITY_ID
-- parameters are comma-separated lists of IDs.
PROCEDURE CALCULATION_RUN_SUMMARY
	(
	p_CALC_PROCESS_ID IN VARCHAR2,
	p_ENTITY_ID IN VARCHAR2,
	p_SHOW_WHAT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATEMENT_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	);


-- This will grab details of the calculation steps for a particular run. It queries the
-- CALCULATION_RUN_STEP and CALCULATION_RUN_STEP_PARM tables.
PROCEDURE CALCULATION_RUN_STEPS
	(
	p_CALC_RUN_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

-- This will delete the intermediate results for this calculation run.
PROCEDURE PURGE_CALCULATION_RUNS
	(
	p_CALC_RUN_ID IN NUMBER_COLLECTION,
	p_MESSAGE OUT VARCHAR2
	);

-- This convenience function is used from queries to format the formula charge date
-- for drill-down detail views
FUNCTION GET_FORMULA_CHARGE_DATE_STRING
	(
	p_CHARGE_DATE		IN DATE,
	p_PERIOD_END_DATE	IN DATE,
	p_TIME_ZONE			IN VARCHAR2
	) RETURN VARCHAR2;

-- This will fetch the details from the various FORMULA_CHARGE_* tables. This will call
-- the FORMULA_CHARGE_DETAIL procedure below.
PROCEDURE CALCULATION_RUN_STEP_DETAILS
	(
	p_CHARGE_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_COMPONENT_DESC OUT VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	);

-- This queries the various FORMULA_CHARGE_* tables. It is called by
-- CALC_ENGINE_UI.CALCULATION_RUN_STEP_DETAILS to show details for Calculation Processes.
-- It is called by BSJ.GET_CHARGE_DETAILS to show details for Billing Formula Charges.
PROCEDURE FORMULA_CHARGE_DETAIL
	(
	p_WORK_ID IN NUMBER,
	p_SHOW_BILL_AMOUNT IN NUMBER,
	p_SHOW_CHARGE_AMOUNT IN NUMBER
	);

PROCEDURE FILTERED_PROCESS
	(
	p_CALC_PROCESS_CAT IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE COMPONENT_CATEGORIES
	(
	p_CALC_PROCESS_ID IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE RESULTS_VIEW
	(
	p_CALC_PROCESS_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_INTERVAL IN VARCHAR2,
	p_SHOW_TOTALS IN NUMBER,
	p_SHOW_ONOFF_PEAK IN NUMBER,
	p_COMPONENT_DESC OUT VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	);

END CALC_ENGINE_UI;
/
CREATE OR REPLACE PACKAGE BODY CALC_ENGINE_UI IS
---------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR2 IS
BEGIN
    RETURN '$Revision: 1.7 $';
END WHAT_VERSION;
---------------------------------------------------------------------------------------------------
-- Get the list of entities for the specified process. This will query the realm
-- or group that defines the process’s set of context entities. An entity whose ID
-- matches the selected specified entity ID will default as selected. If the specified
-- ID is -1, then all IDs will default to selected. If the process has no context domain
-- then this will return an empty cursor.
PROCEDURE GET_PROCESS_ENTITIES_TO_RUN
	(
	p_CALC_PROCESS_ID IN NUMBER,
	p_SELECTED_ENTITY_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_ACTION_ID	CALCULATION_PROCESS_SECURITY.SELECT_ACTION_ID%TYPE;
v_DOMAIN_ID	CALCULATION_PROCESS.CONTEXT_DOMAIN_ID%TYPE;
v_REALM_ID	CALCULATION_PROCESS.CONTEXT_REALM_ID%TYPE;
v_GROUP_ID	CALCULATION_PROCESS.CONTEXT_GROUP_ID%TYPE;
v_WORK_ID	RTO_WORK.WORK_ID%TYPE;
BEGIN
	IF NVL(p_CALC_PROCESS_ID,CONSTANTS.NOT_ASSIGNED) = CONSTANTS.NOT_ASSIGNED THEN
		OPEN p_CURSOR FOR
			SELECT NULL FROM DUAL WHERE 1=0;
		RETURN;
	END IF;

	IF NOT SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_CALC_PROCESS_ID, EC.ED_CALC_PROCESS) THEN
		ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_SELECT_ENT, p_CALC_PROCESS_ID, EC.ED_CALC_PROCESS);
	END IF;

	ENTITY_UTIL.GET_CALC_PROCESS_SECURITY_INFO(p_CALC_PROCESS_ID, ENTITY_UTIL.c_ACTION_TYPE_RUN, v_ACTION_ID, v_DOMAIN_ID, v_REALM_ID, v_GROUP_ID);

	IF NVL(v_DOMAIN_ID,0) = 0 THEN
		-- no context domain? then return empty cursor
		OPEN p_CURSOR FOR
			SELECT -1 as ENTITY_ID,
				'<html><i>(No entity selection required)</i></html>' as ENTITY_NAME,
				NULL as SELECTED
			FROM DUAL;
	ELSE
		SD.ENUMERATE_ENTITIES(v_ACTION_ID, v_DOMAIN_ID, v_WORK_ID, v_REALM_ID, v_GROUP_ID,
								p_BEGIN_DATE, p_END_DATE, TRUE);

		OPEN p_CURSOR FOR
			SELECT WORK_XID as ENTITY_ID,
				WORK_DATA as ENTITY_NAME,
				CASE WHEN p_SELECTED_ENTITY_ID in (WORK_XID, CONSTANTS.ALL_ID) THEN 1 ELSE 0 END as SELECTED
			FROM RTO_WORK
			WHERE WORK_ID = v_WORK_ID
				AND WORK_XID <> 0 -- exclude the 'Not Assigned' entities
			ORDER BY 2, 1;

		UT.PURGE_RTO_WORK(v_WORK_ID);
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		UT.PURGE_RTO_WORK(v_WORK_ID);
		ERRS.LOG_AND_RAISE;

END GET_PROCESS_ENTITIES_TO_RUN;
---------------------------------------------------------------------------------------------------
-- Run the specified process for the specified context entities.
PROCEDURE RUN_SELECTED_PROCESSES
	(
	p_CALC_PROCESS_ID IN NUMBER,
	p_SELECTED_ENTITIES IN NUMBER_COLLECTION,
	p_STATEMENT_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_PROCESS_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR2
	) AS
BEGIN
	CALC_ENGINE.RUN_CALC_PROCESS(p_CALC_PROCESS_ID, p_SELECTED_ENTITIES, p_STATEMENT_TYPE,
								p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TRACE_ON,
								p_PROCESS_STATUS, p_MESSAGE);
END RUN_SELECTED_PROCESSES;
---------------------------------------------------------------------------------------------------
-- Get the list of eligible entities for the specified process. This will query the realm
-- or group that defines the process’s set of context entities. If more than one process
-- is specified (since it could be comma-separated list) then return an empty list.
PROCEDURE GET_PROCESS_ENTITIES
	(
	p_CALC_PROCESS_ID IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_CALC_IDs	      NUMBER_COLLECTION;
v_CALC_PROCESS_ID CALCULATION_PROCESS.CALC_PROCESS_ID%TYPE;
v_ACTION_ID	      CALCULATION_PROCESS_SECURITY.SELECT_ACTION_ID%TYPE;
v_DOMAIN_ID	      CALCULATION_PROCESS.CONTEXT_DOMAIN_ID%TYPE;
v_REALM_ID	      CALCULATION_PROCESS.CONTEXT_REALM_ID%TYPE;
v_GROUP_ID	      CALCULATION_PROCESS.CONTEXT_GROUP_ID%TYPE;
v_WORK_ID	      RTO_WORK.WORK_ID%TYPE;
BEGIN
	p_STATUS := GA.SUCCESS;

	v_CALC_IDs := SD.GET_ALLOWED_IDS_FROM_SELECTION(SD.g_ACTION_SELECT_ENT, EC.ED_CALC_PROCESS, p_CALC_PROCESS_ID, ',', FALSE);

	IF v_CALC_IDs.COUNT = 1 AND v_CALC_IDs(v_CALC_IDs.FIRST) <> CONSTANTS.ALL_ID
							AND v_CALC_IDs(v_CALC_IDs.FIRST) <> CONSTANTS.NOT_ASSIGNED THEN
		v_CALC_PROCESS_ID := v_CALC_IDs(v_CALC_IDs.FIRST);

		ENTITY_UTIL.GET_CALC_PROCESS_SECURITY_INFO(v_CALC_PROCESS_ID, ENTITY_UTIL.c_ACTION_TYPE_SELECT, v_ACTION_ID, v_DOMAIN_ID, v_REALM_ID, v_GROUP_ID);

		IF NVL(v_DOMAIN_ID,0) <> 0 THEN
			SD.ENUMERATE_ENTITIES(v_ACTION_ID, v_DOMAIN_ID, v_WORK_ID, v_REALM_ID, v_GROUP_ID,
									p_BEGIN_DATE, p_END_DATE, TRUE);
		END IF;
	END IF;

	IF v_WORK_ID IS NULL THEN
		-- empty result set
		OPEN p_CURSOR FOR
			SELECT NULL as ENTITY_NAME, NULL as ENTITY_ID FROM DUAL;
	ELSE
		-- include entities
		OPEN p_CURSOR FOR
			SELECT WORK_DATA as ENTITY_NAME, WORK_XID as ENTITY_ID
			FROM RTO_WORK
			WHERE WORK_ID = v_WORK_ID
				AND WORK_XID <> 0
			ORDER BY 1;

		UT.PURGE_RTO_WORK(v_WORK_ID);
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		UT.PURGE_RTO_WORK(v_WORK_ID);
		ERRS.LOG_AND_RAISE;

END GET_PROCESS_ENTITIES;
---------------------------------------------------------------------------------------------------
-- Get the list of statement types. If no select calculation process is statement-type-specific then
-- no selection is necessary.
PROCEDURE GET_STATEMENT_TYPES
	(
	p_CALC_PROCESS_ID IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_NEED_STATEMENT_TYPE NUMBER(1) := 0;
v_IDs                 NUMBER_COLLECTION;
BEGIN
	p_STATUS := GA.SUCCESS;

	v_IDS := SD.GET_ALLOWED_IDS_FROM_SELECTION(SD.g_ACTION_SELECT_ENT, EC.ED_CALC_PROCESS, p_CALC_PROCESS_ID, ',', FALSE);

	-- see if any selected process requires a statement type selection
	SELECT MAX(IS_STATEMENT_TYPE_SPECIFIC)
	INTO v_NEED_STATEMENT_TYPE
	FROM CALCULATION_PROCESS CP,
		TABLE(CAST(v_IDs as NUMBER_COLLECTION)) IDs
	WHERE CP.CALC_PROCESS_ID = IDs.COLUMN_VALUE;

	IF NVL(v_NEED_STATEMENT_TYPE,0) = 0 THEN
		-- no statement type needed
		OPEN p_CURSOR FOR
			SELECT '<html><i>No selection necessary</i></html>' as ENTITY_NAME, 0 as ENTITY_ID FROM DUAL;
	ELSE
		EM.LIST_STATEMENT_TYPES(p_CURSOR);
	END IF;

END GET_STATEMENT_TYPES;
---------------------------------------------------------------------------------------------------
-- Get the list of eligible components for the specified process. This will return all
-- components that are steps in the selected process. If more than one process is
-- specified (since it could be comma-separated list) then return a single entry: <ALL>
PROCEDURE GET_PROCESS_COMPONENTS
	(
	p_CALC_PROCESS_ID IN VARCHAR2,
	p_COMPONENT_CAT IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_CALC_IDs	ID_TABLE;
BEGIN
	p_STATUS := GA.SUCCESS;

	UT.ID_TABLE_FROM_STRING(p_CALC_PROCESS_ID, ',', v_CALC_IDs);

	OPEN p_CURSOR FOR
		SELECT DISTINCT C.COMPONENT_NAME, C.COMPONENT_ID
		FROM COMPONENT C,
			CALCULATION_PROCESS_STEP CPS,
			TABLE(CAST(v_CALC_IDs AS ID_TABLE)) IDS
		WHERE CPS.CALC_PROCESS_ID = IDS.ID
			AND C.COMPONENT_ID = CPS.COMPONENT_ID
			AND (C.COMPONENT_CATEGORY = p_COMPONENT_CAT OR p_COMPONENT_CAT = CONSTANTS.ALL_STRING)
		ORDER BY 1;

END GET_PROCESS_COMPONENTS;
---------------------------------------------------------------------------------------------------
-- This will grab a summary of calculation process intermediate results. It queries the
-- CALCULATION_RUN and CALCULATION_RUN_GLOBAL tables. The PROCESS_ID and ENTITY_ID
-- parameters are comma-separated lists of IDs.
PROCEDURE CALCULATION_RUN_SUMMARY
	(
	p_CALC_PROCESS_ID IN VARCHAR2,
	p_ENTITY_ID IN VARCHAR2,
	p_SHOW_WHAT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATEMENT_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_ACTION_ID	CALCULATION_PROCESS_SECURITY.SELECT_ACTION_ID%TYPE;
v_DOMAIN_ID	CALCULATION_PROCESS.CONTEXT_DOMAIN_ID%TYPE;
v_REALM_ID	CALCULATION_PROCESS.CONTEXT_REALM_ID%TYPE;
v_GROUP_ID	CALCULATION_PROCESS.CONTEXT_GROUP_ID%TYPE;
v_CALC_IDs		ID_TABLE;
v_ENTITY_IDs	ID_TABLE;
v_ALL_ENTITIES	BOOLEAN := FALSE;
v_LOCAL_BEGIN_DATE 	DATE;
v_LOCAL_END_DATE	DATE;
v_CUT_BEGIN_DATE	DATE;
v_CUT_END_DATE		DATE;
v_IDX			PLS_INTEGER;
v_JDX			PLS_INTEGER;
v_WORK_ID		NUMBER;
BEGIN
	UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_CUT_BEGIN_DATE, v_CUT_END_DATE);
	UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, GA.CUT_TIME_ZONE, v_LOCAL_BEGIN_DATE, v_LOCAL_END_DATE);

	UT.ID_TABLE_FROM_STRING(p_CALC_PROCESS_ID,',',v_CALC_IDs);
	UT.ID_TABLE_FROM_STRING(p_ENTITY_ID,',',v_ENTITY_IDs);

	UT.GET_RTO_WORK_ID(v_WORK_ID);

	-- see if entity collection contains the ALL ID
	v_IDX := v_ENTITY_IDs.FIRST;
	WHILE v_ENTITY_IDs.EXISTS(v_IDX) LOOP
		IF v_ENTITY_IDs(v_IDX).ID = CONSTANTS.ALL_ID THEN
			v_ALL_ENTITIES := TRUE;
			EXIT;
		END IF;
		v_IDX := v_ENTITY_IDs.NEXT(v_IDX);
	END LOOP;

	-- now gather entities that we'll be examining
	v_IDX := v_CALC_IDs.FIRST;
	WHILE v_CALC_IDs.EXISTS(v_IDX) LOOP
		SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, v_CALC_IDs(v_IDX).ID, EC.ED_CALC_PROCESS);

		ENTITY_UTIL.GET_CALC_PROCESS_SECURITY_INFO(v_CALC_IDs(v_IDX).ID, ENTITY_UTIL.c_ACTION_TYPE_SELECT, v_ACTION_ID, v_DOMAIN_ID, v_REALM_ID, v_GROUP_ID);

		IF NVL(v_DOMAIN_ID,CONSTANTS.NOT_ASSIGNED) = CONSTANTS.NOT_ASSIGNED THEN
			-- no context domain? then user must have full access to specified action
			SD.VERIFY_ACTION_IS_ALLOWED(v_ACTION_ID);
			-- add ID to work table
			INSERT INTO RTO_WORK (WORK_ID, WORK_SEQ, WORK_XID)
						VALUES (v_WORK_ID, v_CALC_IDs(v_IDX).ID, CONSTANTS.NOT_ASSIGNED);
		ELSIF v_ALL_ENTITIES THEN
			-- grab all entities to work table
			INSERT INTO RTO_WORK (WORK_ID, WORK_SEQ, WORK_XID)
			SELECT v_WORK_ID, v_CALC_IDs(v_IDX).ID, IDs.ID
			FROM TABLE(CAST(SD.GET_ALLOWED_ENTITY_ID_TABLE(v_ACTION_ID,v_DOMAIN_ID) AS ID_TABLE)) IDs;
		ELSE
			-- verify security
			v_JDX := v_ENTITY_IDs.FIRST;
			WHILE v_ENTITY_IDs.EXISTS(v_JDX) LOOP
				SD.VERIFY_ENTITY_IS_ALLOWED(v_ACTION_ID, v_ENTITY_IDs(v_JDX).ID, v_DOMAIN_ID);
				v_JDX := v_ENTITY_IDs.NEXT(v_JDX);
			END LOOP;
			-- now that they've all checked out, add to work table
			INSERT INTO RTO_WORK (WORK_ID, WORK_SEQ, WORK_XID)
			SELECT v_WORK_ID, v_CALC_IDs(v_IDX).ID, IDs.ID
			FROM TABLE(CAST(v_ENTITY_IDs AS ID_TABLE)) IDs;
		END IF;
		v_IDX := v_CALC_IDs.NEXT(v_IDX);
	END LOOP;

	OPEN p_CURSOR FOR
		SELECT CR.CALC_RUN_ID,
			CP.CALC_PROCESS_ID,
			CP.CALC_PROCESS_NAME,
			CR.CONTEXT_ENTITY_ID as ENTITY_ID,
			CASE WHEN NVL(CP.CONTEXT_DOMAIN_ID,CONSTANTS.NOT_ASSIGNED) = CONSTANTS.NOT_ASSIGNED THEN NULL
					ELSE ENTITY_NAME_FROM_IDs(CP.CONTEXT_DOMAIN_ID, CR.CONTEXT_ENTITY_ID) END as ENTITY_NAME,
			FROM_CUT_AS_HED(CR.RUN_DATE, p_TIME_ZONE, GET_INTERVAL_ABBREVIATION(CP.PROCESS_INTERVAL)) as RUN_DATE,
			CR.START_TIME,
			NVL(CR.END_TIME, P.PROCESS_STOP_TIME) as END_TIME,
			CASE WHEN CR.END_TIME IS NOT NULL THEN 'Complete'
				 WHEN P.PROCESS_STOP_TIME IS NOT NULL THEN 'Incomplete'
				 ELSE 'Running...' END as STATUS,
			TO_CHAR(CR.PROCESS_ID) as PROCESS_CID,
			U.USER_DISPLAY_NAME,
			CG.GLOBAL_NAME,
			CG.GLOBAL_VAL,
			CASE WHEN CG.ROW_NUMBER IS NULL THEN NULL
				ELSE 'Global #'||CG.ROW_NUMBER
				END as ROW_NUMBER
		FROM CALCULATION_PROCESS CP,
			CALCULATION_RUN CR,
			RTO_WORK W,
			CALCULATION_RUN_GLOBAL CG,
			PROCESS_LOG P,
			APPLICATION_USER U
		WHERE W.WORK_ID = v_WORK_ID
			AND CP.CALC_PROCESS_ID = W.WORK_SEQ
			AND CR.CALC_PROCESS_ID = CP.CALC_PROCESS_ID
			AND (W.WORK_XID = SD.g_ALL_DATA_ENTITY_ID OR NVL(CR.CONTEXT_ENTITY_ID, CONSTANTS.NOT_ASSIGNED) = W.WORK_XID)
			AND (NVL(CP.IS_STATEMENT_TYPE_SPECIFIC, 0) =  0 OR CR.STATEMENT_TYPE_ID = p_STATEMENT_TYPE)
			-- sub-daily run dates are stored in CUT time
			AND ((DATE_UTIL.IS_SUB_DAILY_NUM(CP.PROCESS_INTERVAL)=1 AND CR.RUN_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE)
				-- daily and greater run dates are stored as 1 second past midnight
				OR (DATE_UTIL.IS_SUB_DAILY_NUM(CP.PROCESS_INTERVAL)=0 AND CR.RUN_DATE BETWEEN v_LOCAL_BEGIN_DATE AND v_LOCAL_END_DATE))
			AND (p_SHOW_WHAT_ID = c_SHOW_ALL OR
					(NVL(CR.END_TIME,P.PROCESS_STOP_TIME) IS NULL AND p_SHOW_WHAT_ID = c_SHOW_RUNNING) OR
					(NVL(CR.END_TIME,P.PROCESS_STOP_TIME) IS NOT NULL AND p_SHOW_WHAT_ID = c_SHOW_FINISHED))
			AND CG.CALC_RUN_ID(+) = CR.CALC_RUN_ID
			AND P.PROCESS_ID = CR.PROCESS_ID
			AND U.USER_ID = P.USER_ID
		ORDER BY 3,5,6,14;

	UT.PURGE_RTO_WORK(v_WORK_ID);

EXCEPTION
	WHEN OTHERS THEN
		UT.PURGE_RTO_WORK(v_WORK_ID);
		ERRS.LOG_AND_RAISE;

END CALCULATION_RUN_SUMMARY;
---------------------------------------------------------------------------------------------------
PROCEDURE VALIDATE_SECURITY
	(
	p_CALC_PROCESS_ID IN NUMBER,
	p_CONTEXT_ENTITY_ID IN NUMBER,
	p_ACTION_TYPE IN NUMBER
	) AS
v_ACTION_ID	CALCULATION_PROCESS_SECURITY.SELECT_ACTION_ID%TYPE;
v_DOMAIN_ID	CALCULATION_PROCESS.CONTEXT_DOMAIN_ID%TYPE;
v_REALM_ID	CALCULATION_PROCESS.CONTEXT_REALM_ID%TYPE;
v_GROUP_ID	CALCULATION_PROCESS.CONTEXT_GROUP_ID%TYPE;
BEGIN
	-- get info about this calculation run and verify security permissions
	IF NOT SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_CALC_PROCESS_ID, EC.ED_CALC_PROCESS) THEN
		ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_SELECT_ENT, EC.ED_CALC_PROCESS, p_CALC_PROCESS_ID);
	END IF;

	ENTITY_UTIL.GET_CALC_PROCESS_SECURITY_INFO(p_CALC_PROCESS_ID, p_ACTION_TYPE, v_ACTION_ID, v_DOMAIN_ID, v_REALM_ID, v_GROUP_ID);

	IF NVL(v_DOMAIN_ID,CONSTANTS.NOT_ASSIGNED) = CONSTANTS.NOT_ASSIGNED THEN
		-- no context domain? then user must have full access to specified action
		SD.VERIFY_ACTION_IS_ALLOWED(v_ACTION_ID);
	ELSE
		SD.VERIFY_ENTITY_IS_ALLOWED(v_ACTION_ID, p_CONTEXT_ENTITY_ID, v_DOMAIN_ID);
	END IF;

END VALIDATE_SECURITY;
---------------------------------------------------------------------------------------------------
PROCEDURE VALIDATE_SECURITY
	(
	p_CALC_RUN_ID IN NUMBER,
	p_ACTION_TYPE IN NUMBER
	) AS
v_CALC_ID	CALCULATION_RUN.CALC_PROCESS_ID%TYPE;
v_ENTITY_ID	CALCULATION_RUN.CONTEXT_ENTITY_ID%TYPE;
BEGIN
	-- get info about this calculation run and verify security permissions
	SELECT CALC_PROCESS_ID, CONTEXT_ENTITY_ID
	INTO v_CALC_ID, v_ENTITY_ID
	FROM CALCULATION_RUN
	WHERE CALC_RUN_ID = p_CALC_RUN_ID;

	VALIDATE_SECURITY(v_CALC_ID, v_ENTITY_ID, p_ACTION_TYPE);

END VALIDATE_SECURITY;
---------------------------------------------------------------------------------------------------
-- This will grab details of the calculation steps for a particular run. It queries the
-- CALCULATION_RUN_STEP and CALCULATION_RUN_STEP_PARM tables.
PROCEDURE CALCULATION_RUN_STEPS
	(
	p_CALC_RUN_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	IF p_CALC_RUN_ID IS NULL THEN
		OPEN p_CURSOR FOR SELECT NULL FROM DUAL WHERE 0=1;
		RETURN;
	END IF;

	VALIDATE_SECURITY(p_CALC_RUN_ID, ENTITY_UTIL.c_ACTION_TYPE_SELECT);

	-- now get the data
	OPEN p_CURSOR FOR
		SELECT S.CHARGE_ID,
			S.STEP_NUMBER,
			S.COMPONENT_ID,
			C.COMPONENT_NAME,
			S.START_TIME,
			NVL(S.END_TIME, PL.PROCESS_STOP_TIME) as END_TIME,
			CASE WHEN S.END_TIME IS NOT NULL THEN 'Complete'
				 WHEN PL.PROCESS_STOP_TIME IS NOT NULL THEN 'Incomplete'
				 ELSE 'Running...' END as STATUS,
			P.PARAMETER_NAME,
			P.PARAMETER_VAL,
			CASE WHEN P.ROW_NUMBER IS NULL THEN NULL
				ELSE 'Parm. #'||P.ROW_NUMBER
				END as ROW_NUMBER
		FROM CALCULATION_RUN R,
			PROCESS_LOG PL,
			CALCULATION_RUN_STEP S,
			COMPONENT C,
			CALCULATION_RUN_STEP_PARM P
		WHERE R.CALC_RUN_ID = p_CALC_RUN_ID
			AND PL.PROCESS_ID = R.PROCESS_ID
			AND S.CALC_RUN_ID = p_CALC_RUN_ID
			AND p_COMPONENT_ID IN (CONSTANTS.ALL_ID, S.COMPONENT_ID)
			AND C.COMPONENT_ID = S.COMPONENT_ID
			AND P.CHARGE_ID(+) = S.CHARGE_ID
		ORDER BY 2, 4, 10;

END CALCULATION_RUN_STEPS;
---------------------------------------------------------------------------------------------------
-- This will delete the intermediate results for this calculation run.
PROCEDURE PURGE_CALCULATION_RUNS
	(
	p_CALC_RUN_ID IN NUMBER_COLLECTION,
	p_MESSAGE OUT VARCHAR2
	) AS
v_IDX PLS_INTEGER;
BEGIN
	v_IDX := p_CALC_RUN_ID.FIRST;
	WHILE p_CALC_RUN_ID.EXISTS(v_IDX) LOOP
		VALIDATE_SECURITY(p_CALC_RUN_ID(v_IDX), ENTITY_UTIL.c_ACTION_TYPE_PURGE);
		DELETE CALCULATION_RUN WHERE CALC_RUN_ID = p_CALC_RUN_ID(v_IDX);
		v_IDX := p_CALC_RUN_ID.NEXT(v_IDX);
	END LOOP;

	p_MESSAGE := 'Intermediate results have been purged';

END PURGE_CALCULATION_RUNS;
---------------------------------------------------------------------------------------------------
FUNCTION GET_FORMULA_CHARGE_DATE_STRING
	(
	p_CHARGE_DATE		IN DATE,
	p_PERIOD_END_DATE	IN DATE,
	p_TIME_ZONE			IN VARCHAR2
	) RETURN VARCHAR2 IS
BEGIN
	RETURN FROM_CUT_AS_HED(p_CHARGE_DATE, p_TIME_ZONE, CASE TO_CHAR(p_CHARGE_DATE,'SS') WHEN '01' THEN 'DD' ELSE 'MI5' END, GA.ELECTRIC_MODEL)
			-- for "meter period" charges, there is an optional period end date
			-- so show that if it is present
			|| CASE WHEN p_PERIOD_END_DATE IS NULL THEN NULL
				ELSE ' -> '||FROM_CUT_AS_HED(p_PERIOD_END_DATE, GA.CUT_TIME_ZONE, 'DD', GA.ELECTRIC_MODEL)
				END;
END GET_FORMULA_CHARGE_DATE_STRING;
---------------------------------------------------------------------------------------------------
-- This will fetch the details from the various FORMULA_CHARGE_* tables. This will call
-- the FORMULA_CHARGE_DETAIL procedure below.
PROCEDURE CALCULATION_RUN_STEP_DETAILS
	(
	p_CHARGE_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_COMPONENT_DESC OUT VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_WORK_ID NUMBER;
BEGIN

	SELECT COMP.COMPONENT_DESC INTO p_COMPONENT_DESC
	FROM CALCULATION_RUN_STEP STEP, COMPONENT COMP
	WHERE STEP.CHARGE_ID = p_CHARGE_ID
		AND COMP.COMPONENT_ID = STEP.COMPONENT_ID;

	UT.GET_RTO_WORK_ID(v_WORK_ID);
	INSERT INTO RTO_WORK (WORK_ID, WORK_XID) VALUES (v_WORK_ID, p_CHARGE_ID);

	FORMULA_CHARGE_DETAIL(v_WORK_ID, 0, 0);

	OPEN p_CURSOR FOR
		SELECT GET_FORMULA_CHARGE_DATE_STRING(RECORD_DATE, PERIOD_END_DATE, p_TIME_ZONE) as CHARGE_DATE,
			ITERATOR1_NAME, ITERATOR1_VAL, ITERATOR2_NAME, ITERATOR2_VAL,
			ITERATOR3_NAME, ITERATOR3_VAL, ITERATOR4_NAME, ITERATOR4_VAL,
			ITERATOR5_NAME, ITERATOR5_VAL, ITERATOR6_NAME, ITERATOR6_VAL,
			ITERATOR7_NAME, ITERATOR7_VAL, ITERATOR8_NAME, ITERATOR8_VAL,
			ITERATOR9_NAME, ITERATOR9_VAL, ITERATOR10_NAME, ITERATOR10_VAL,
			VARIABLE_NAME, VARIABLE_VALUE,
			CALC_ORDER, VIEW_ORDER
		FROM FORMULA_CHARGE_DRILL_DOWN_TEMP;

	UT.PURGE_RTO_WORK(v_WORK_ID);
	DELETE FROM FORMULA_CHARGE_DRILL_DOWN_TEMP;

EXCEPTION
	WHEN OTHERS THEN
		UT.PURGE_RTO_WORK(v_WORK_ID);
		DELETE FROM FORMULA_CHARGE_DRILL_DOWN_TEMP;
		ERRS.LOG_AND_RAISE;
END CALCULATION_RUN_STEP_DETAILS;
---------------------------------------------------------------------------------------------------
-- This queries the various FORMULA_CHARGE_* tables. It is called by
-- CALC_ENGINE_UI.CALCULATION_RUN_STEP_DETAILS to show details for Calculation Processes.
-- It is called by BSJ.GET_CHARGE_DETAILS to show details for Billing Formula Charges.
PROCEDURE FORMULA_CHARGE_DETAIL
	(
	p_WORK_ID IN NUMBER,
	p_SHOW_BILL_AMOUNT IN NUMBER,
	p_SHOW_CHARGE_AMOUNT IN NUMBER
	) AS
BEGIN

	INSERT INTO FORMULA_CHARGE_DRILL_DOWN_TEMP
		(RECORD_DATE, PERIOD_END_DATE, ITERATOR1_NAME, ITERATOR1_VAL, ITERATOR2_NAME, ITERATOR2_VAL,
		 ITERATOR3_NAME, ITERATOR3_VAL, ITERATOR4_NAME, ITERATOR4_VAL, ITERATOR5_NAME, ITERATOR5_VAL,
		 ITERATOR6_NAME, ITERATOR6_VAL, ITERATOR7_NAME, ITERATOR7_VAL, ITERATOR8_NAME, ITERATOR8_VAL,
		 ITERATOR9_NAME, ITERATOR9_VAL, ITERATOR10_NAME, ITERATOR10_VAL, VARIABLE_NAME, VARIABLE_VALUE,
		 CALC_ORDER, VIEW_ORDER, CHARGE_QUANTITY, BILL_QUANTITY, CHARGE_RATE, CHARGE_FACTOR,
		 CHARGE_AMOUNT, BILL_AMOUNT, DISPUTE_STATUS)
	SELECT INNER_QUERY.CHARGE_DATE_CUT,
		INNER_QUERY.PERIOD_END_DATE,
		INNER_QUERY.ITERATOR_NAME1,
		INNER_QUERY.ITERATOR1,
		INNER_QUERY.ITERATOR_NAME2,
		INNER_QUERY.ITERATOR2,
		INNER_QUERY.ITERATOR_NAME3,
		INNER_QUERY.ITERATOR3,
		INNER_QUERY.ITERATOR_NAME4,
		INNER_QUERY.ITERATOR4,
		INNER_QUERY.ITERATOR_NAME5,
		INNER_QUERY.ITERATOR5,
		INNER_QUERY.ITERATOR_NAME6,
		INNER_QUERY.ITERATOR6,
		INNER_QUERY.ITERATOR_NAME7,
		INNER_QUERY.ITERATOR7,
		INNER_QUERY.ITERATOR_NAME8,
		INNER_QUERY.ITERATOR8,
		INNER_QUERY.ITERATOR_NAME9,
		INNER_QUERY.ITERATOR9,
		INNER_QUERY.ITERATOR_NAME10,
		INNER_QUERY.ITERATOR10,
		INNER_QUERY.VARIABLE_NAME,
		INNER_QUERY.VARIABLE_VAL,
		INNER_QUERY.ROW_NUMBER AS CALC_ORDER,
		-- THIS IS A LITTLE TOUGH TO READ, BUT ESSENTIALLY WE'RE LOOKING FOR THE PERSISTENT
		-- VARIABLE WITH THE HIGHEST ROW_NUMBER (CALC_ORDER) AND THE LAST NAME (IN THAT ORDER)
		-- IF WE DON'T HAVE SUCH A VARIABLE, THEN WE REVERT TO THE INPUT'S VIEW ORDER
		-- IF THAT IS NULL, THEN IT'S OK TO RETURN NULL AS THE VIEW_ORDER
		NVL((SELECT DISTINCT FIRST_VALUE(VAR.VIEW_ORDER) OVER (ORDER BY VAR.ROW_NUMBER DESC, VAR.VARIABLE_NAME DESC )
							FROM COMPONENT_FORMULA_VARIABLE VAR
							WHERE REGEXP_LIKE(VAR.VARIABLE_NAME, '(^|,)\s*'||INNER_QUERY.VARIABLE_NAME||'\s*($|,)')
								AND VAR.COMPONENT_ID = INNER_QUERY.COMPONENT_ID
								AND TRUNC(INNER_QUERY.CHARGE_DATE - 1/86400) BETWEEN VAR.BEGIN_DATE AND NVL(VAR.END_DATE,CONSTANTS.HIGH_DATE)
								AND VAR.PERSIST_VALUE = 1),
			 	(SELECT DISTINCT INPUT.VIEW_ORDER
					FROM COMPONENT_FORMULA_INPUT INPUT
					WHERE INPUT.INPUT_NAME = INNER_QUERY.VARIABLE_NAME
						AND INPUT.COMPONENT_ID = INNER_QUERY.COMPONENT_ID
						AND TRUNC(INNER_QUERY.CHARGE_DATE - 1/86400) BETWEEN INPUT.BEGIN_DATE AND NVL(INPUT.END_DATE,CONSTANTS.HIGH_DATE)
						AND INPUT.PERSIST_VALUE = 1)) AS VIEW_ORDER,
		CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE INNER_QUERY.CHARGE_QUANTITY END "CHARGE_QUANTITY",
		CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE INNER_QUERY.BILL_QUANTITY END "BILL_QUANTITY",
		INNER_QUERY.CHARGE_RATE,
		INNER_QUERY.CHARGE_FACTOR,
		CASE WHEN p_SHOW_CHARGE_AMOUNT = 0 THEN NULL ELSE INNER_QUERY.CHARGE_AMOUNT END "CHARGE_AMOUNT",
		CASE WHEN p_SHOW_BILL_AMOUNT = 0 THEN NULL ELSE INNER_QUERY.BILL_AMOUNT END "BILL_AMOUNT",
		DISP.DISPUTE_STATUS
	FROM (SELECT FROM_CUT(FORM_CHARGE.CHARGE_DATE, COALESCE(PSE.TIME_ZONE, PROC.TIME_ZONE, GA.LOCAL_TIME_ZONE)) AS CHARGE_DATE,
			FORM_CHARGE.CHARGE_DATE AS CHARGE_DATE_CUT, FORM_CHARGE.PERIOD_END_DATE,
			ITER_NAME.ITERATOR_NAME1, ITER.ITERATOR1,
			ITER_NAME.ITERATOR_NAME2, ITER.ITERATOR2,
			ITER_NAME.ITERATOR_NAME3, ITER.ITERATOR3,
			ITER_NAME.ITERATOR_NAME4, ITER.ITERATOR4,
			ITER_NAME.ITERATOR_NAME5, ITER.ITERATOR5,
			ITER_NAME.ITERATOR_NAME6, ITER.ITERATOR6,
			ITER_NAME.ITERATOR_NAME7, ITER.ITERATOR7,
			ITER_NAME.ITERATOR_NAME8, ITER.ITERATOR8,
			ITER_NAME.ITERATOR_NAME9, ITER.ITERATOR9,
			ITER_NAME.ITERATOR_NAME10, ITER.ITERATOR10,
			FORM_VAR.VARIABLE_NAME, FORM_VAR.VARIABLE_VAL,
			FORM_CHARGE.CHARGE_QUANTITY, FORM_CHARGE.BILL_QUANTITY,
			FORM_CHARGE.CHARGE_RATE, FORM_CHARGE.CHARGE_FACTOR,
			FORM_CHARGE.CHARGE_AMOUNT, FORM_CHARGE.BILL_AMOUNT,
			NVL(BILL_STAT.ENTITY_ID, CALC_RUN.CONTEXT_ENTITY_ID) AS ENTITY_ID,
			NVL(BILL_STAT.STATEMENT_TYPE, CALC_RUN.STATEMENT_TYPE_ID) AS STATEMENT_TYPE,
			BILL_STAT.STATEMENT_STATE,
			NVL(BILL_STAT.STATEMENT_DATE, CALC_RUN.RUN_DATE) AS STATEMENT_DATE,
			BILL_STAT.PRODUCT_ID,
			NVL(BILL_STAT.COMPONENT_ID, CALC_STEP.COMPONENT_ID) AS COMPONENT_ID,
			FORM_VAR.ROW_NUMBER
		FROM BILLING_STATEMENT BILL_STAT,
			CALCULATION_RUN_STEP CALC_STEP,
			CALCULATION_RUN CALC_RUN,
			FORMULA_CHARGE FORM_CHARGE,
			FORMULA_CHARGE_VARIABLE FORM_VAR,
			FORMULA_CHARGE_ITERATOR ITER,
			FORMULA_CHARGE_ITERATOR_NAME ITER_NAME,
			CALCULATION_PROCESS PROC,
			PSE PSE,
			RTO_WORK X
		WHERE X.WORK_ID = p_WORK_ID
			AND BILL_STAT.CHARGE_ID (+) = X.WORK_XID
			AND CALC_STEP.CHARGE_ID (+) = X.WORK_XID
			AND CALC_RUN.CALC_RUN_ID (+) = CALC_STEP.CALC_RUN_ID
			AND ITER_NAME.CHARGE_ID = X.WORK_XID
			AND ITER.CHARGE_ID = ITER_NAME.CHARGE_ID
			AND FORM_CHARGE.CHARGE_ID = ITER.CHARGE_ID
			AND FORM_CHARGE.ITERATOR_ID = ITER.ITERATOR_ID
			AND FORM_VAR.CHARGE_ID(+) = FORM_CHARGE.CHARGE_ID
			AND FORM_VAR.ITERATOR_ID(+) = FORM_CHARGE.ITERATOR_ID
			AND FORM_VAR.CHARGE_DATE(+) = FORM_CHARGE.CHARGE_DATE
			AND PROC.CALC_PROCESS_ID (+) = CALC_RUN.CALC_PROCESS_ID
			AND PSE.PSE_ID (+) = BILL_STAT.ENTITY_ID
			) INNER_QUERY,
		BILLING_CHARGE_DISPUTE DISP
	WHERE DISP.ENTITY_ID (+) = INNER_QUERY.ENTITY_ID
	  AND DISP.PRODUCT_ID (+) = INNER_QUERY.PRODUCT_ID
	  AND DISP.COMPONENT_ID (+) = INNER_QUERY.COMPONENT_ID
	  AND DISP.STATEMENT_TYPE (+) = INNER_QUERY.STATEMENT_TYPE
	  AND DISP.STATEMENT_STATE (+) = INNER_QUERY.STATEMENT_STATE
	  AND DISP.STATEMENT_DATE (+) = INNER_QUERY.STATEMENT_DATE
	  AND DISP.DISPUTE_DATE (+) = INNER_QUERY.CHARGE_DATE_CUT
	  AND NVL(DISP.ITERATOR1(+), CONSTANTS.UNDEFINED_ATTRIBUTE) = NVL(INNER_QUERY.ITERATOR1, CONSTANTS.UNDEFINED_ATTRIBUTE)
	  AND NVL(DISP.ITERATOR2(+), CONSTANTS.UNDEFINED_ATTRIBUTE) = NVL(INNER_QUERY.ITERATOR2, CONSTANTS.UNDEFINED_ATTRIBUTE)
	  AND NVL(DISP.ITERATOR3(+), CONSTANTS.UNDEFINED_ATTRIBUTE) = NVL(INNER_QUERY.ITERATOR3, CONSTANTS.UNDEFINED_ATTRIBUTE)
	  AND NVL(DISP.ITERATOR4(+), CONSTANTS.UNDEFINED_ATTRIBUTE) = NVL(INNER_QUERY.ITERATOR4, CONSTANTS.UNDEFINED_ATTRIBUTE)
	  AND NVL(DISP.ITERATOR5(+), CONSTANTS.UNDEFINED_ATTRIBUTE) = NVL(INNER_QUERY.ITERATOR5, CONSTANTS.UNDEFINED_ATTRIBUTE)
	  AND NVL(DISP.ITERATOR6(+), CONSTANTS.UNDEFINED_ATTRIBUTE) = NVL(INNER_QUERY.ITERATOR6, CONSTANTS.UNDEFINED_ATTRIBUTE)
	  AND NVL(DISP.ITERATOR7(+), CONSTANTS.UNDEFINED_ATTRIBUTE) = NVL(INNER_QUERY.ITERATOR7, CONSTANTS.UNDEFINED_ATTRIBUTE)
	  AND NVL(DISP.ITERATOR8(+), CONSTANTS.UNDEFINED_ATTRIBUTE) = NVL(INNER_QUERY.ITERATOR8, CONSTANTS.UNDEFINED_ATTRIBUTE)
	  AND NVL(DISP.ITERATOR9(+), CONSTANTS.UNDEFINED_ATTRIBUTE) = NVL(INNER_QUERY.ITERATOR9, CONSTANTS.UNDEFINED_ATTRIBUTE)
	  AND NVL(DISP.ITERATOR10(+), CONSTANTS.UNDEFINED_ATTRIBUTE) = NVL(INNER_QUERY.ITERATOR10, CONSTANTS.UNDEFINED_ATTRIBUTE);

END FORMULA_CHARGE_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE FILTERED_PROCESS
	(
	p_CALC_PROCESS_CAT IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
	SELECT PROC.CALC_PROCESS_NAME, PROC.CALC_PROCESS_ID
	FROM CALCULATION_PROCESS PROC
	WHERE PROC.CALC_PROCESS_CATEGORY = p_CALC_PROCESS_CAT
		OR p_CALC_PROCESS_CAT = CONSTANTS.ALL_STRING;

END FILTERED_PROCESS;
---------------------------------------------------------------------------------------------------
PROCEDURE COMPONENT_CATEGORIES
	(
	p_CALC_PROCESS_ID IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	) AS

v_CALC_IDs	ID_TABLE;

BEGIN

	UT.ID_TABLE_FROM_STRING(p_CALC_PROCESS_ID, ',', v_CALC_IDs);

	OPEN p_CURSOR FOR
    	SELECT DISTINCT COMPONENT_CATEGORY
		FROM COMPONENT COMP,
			CALCULATION_PROCESS_STEP STEPS,
			TABLE(CAST(v_CALC_IDS as ID_TABLE)) IDS
		WHERE COMP.COMPONENT_CATEGORY <> '?'
			AND NOT COMP.COMPONENT_CATEGORY IS NULL
			AND COMP.COMPONENT_ENTITY = 'Calc.Process'
			AND STEPS.CALC_PROCESS_ID = IDS.ID
			AND STEPS.COMPONENT_ID = COMP.COMPONENT_ID
		ORDER BY 1;

END COMPONENT_CATEGORIES;
---------------------------------------------------------------------------------------------------
PROCEDURE RESULTS_VIEW
	(
	p_CALC_PROCESS_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_STATEMENT_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_INTERVAL IN VARCHAR2,
	p_SHOW_TOTALS IN NUMBER,
	p_SHOW_ONOFF_PEAK IN NUMBER,
	p_COMPONENT_DESC OUT VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_WORK_ID		NUMBER;
v_CUT			NUMBER(1);
v_BEGIN_DATE	DATE;
v_END_DATE		DATE;
BEGIN

	SELECT COMPONENT_DESC INTO p_COMPONENT_DESC
	FROM COMPONENT
	WHERE COMPONENT_ID = p_COMPONENT_ID;

	UT.GET_RTO_WORK_ID(v_WORK_ID);

	SELECT COUNT(1)
	INTO v_CUT
	FROM CALCULATION_PROCESS CP
	WHERE CP.CALC_PROCESS_ID = p_CALC_PROCESS_ID
		AND SUBSTR(CP.PROCESS_INTERVAL,-4) IN ('Hour', 'nute');

	UT.CUT_DATE_RANGE(CONSTANTS.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE,
						-- NOT sub-daily intervals means process runs are stored as
						-- second-past-midnight in local time, so we don't need to
						-- convert from CUT. Otherwise, we need to convert
						CASE WHEN v_CUT = 0 THEN GA.CUT_TIME_ZONE
								ELSE p_TIME_ZONE
								END,
						v_BEGIN_DATE, v_END_DATE);

	INSERT INTO RTO_WORK (WORK_ID, WORK_XID)
	SELECT v_WORK_ID, CRS.CHARGE_ID
	FROM CALCULATION_RUN CR,
		CALCULATION_RUN_STEP CRS
	WHERE CR.CALC_PROCESS_ID = p_CALC_PROCESS_ID
		AND CR.RUN_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND NVL(CR.STATEMENT_TYPE_ID, CONSTANTS.NOT_ASSIGNED) = p_STATEMENT_TYPE
		AND NVL(CR.CONTEXT_ENTITY_ID, CONSTANTS.NOT_ASSIGNED) = p_ENTITY_ID
		AND CRS.CALC_RUN_ID = CR.CALC_RUN_ID
		AND CRS.COMPONENT_ID = p_COMPONENT_ID;

	-- Query details into work table
	FORMULA_CHARGE_DETAIL(v_WORK_ID, 0, 0);

	-- now open cursor
	OPEN p_CURSOR FOR
		-- get details - sum up variable value by interval
		SELECT 0 as SUMMARY_TYPE,
			TRIM(CASE p_INTERVAL
				WHEN 'Month' THEN SDT.MONTH_YYYY_MM_DD
				WHEN 'Day' THEN SDT.DAY_YYYY_MM_DD
				ELSE SDT.NO_ROLLUP_YYYY_MM_DD
				END) as CHARGE_DATE,
			FC.ITERATOR1_NAME, FC.ITERATOR1_VAL, FC.ITERATOR2_NAME, FC.ITERATOR2_VAL,
			FC.ITERATOR3_NAME, FC.ITERATOR3_VAL, FC.ITERATOR4_NAME, FC.ITERATOR4_VAL,
			FC.ITERATOR5_NAME, FC.ITERATOR5_VAL, FC.ITERATOR6_NAME, FC.ITERATOR6_VAL,
			FC.ITERATOR7_NAME, FC.ITERATOR7_VAL, FC.ITERATOR8_NAME, FC.ITERATOR8_VAL,
			FC.ITERATOR9_NAME, FC.ITERATOR9_VAL, FC.ITERATOR10_NAME, FC.ITERATOR10_VAL,
			FC.VARIABLE_NAME, FC.CALC_ORDER, FC.VIEW_ORDER, SUM(FC.VARIABLE_VALUE) as VARIABLE_VALUE
		FROM FORMULA_CHARGE_DRILL_DOWN_TEMP FC, SYSTEM_DATE_TIME SDT
		WHERE SDT.TIME_ZONE = p_TIME_ZONE
			AND SDT.DATA_INTERVAL_TYPE = CASE WHEN v_CUT = 0 THEN 2 ELSE 1 END
			AND SDT.DAY_TYPE = '1'
			AND SDT.CUT_DATE_SCHEDULING = FC.RECORD_DATE
		GROUP BY TRIM(CASE p_INTERVAL
				WHEN 'Month' THEN SDT.MONTH_YYYY_MM_DD
				WHEN 'Day' THEN SDT.DAY_YYYY_MM_DD
				ELSE SDT.NO_ROLLUP_YYYY_MM_DD
				END),
			FC.ITERATOR1_NAME, FC.ITERATOR1_VAL, FC.ITERATOR2_NAME, FC.ITERATOR2_VAL,
			FC.ITERATOR3_NAME, FC.ITERATOR3_VAL, FC.ITERATOR4_NAME, FC.ITERATOR4_VAL,
			FC.ITERATOR5_NAME, FC.ITERATOR5_VAL, FC.ITERATOR6_NAME, FC.ITERATOR6_VAL,
			FC.ITERATOR7_NAME, FC.ITERATOR7_VAL, FC.ITERATOR8_NAME, FC.ITERATOR8_VAL,
			FC.ITERATOR9_NAME, FC.ITERATOR9_VAL, FC.ITERATOR10_NAME, FC.ITERATOR10_VAL,
			FC.VARIABLE_NAME, FC.CALC_ORDER, FC.VIEW_ORDER
		UNION ALL
		-- add in summary records - use GROUP BY ROLLUP on SDT.IS_ON_PEAK to figure out
		-- total and on/off peak sub-totals
		SELECT CASE WHEN GROUPING(SDT.IS_ON_PEAK) = 1 THEN 1 ELSE 3-SDT.IS_ON_PEAK END as SUMMARY_TYPE,
			'<html><b>'||CASE WHEN GROUPING(SDT.IS_ON_PEAK) = 1 THEN 'Total'
							  WHEN SDT.IS_ON_PEAK = 0 THEN 'Off-Peak' ELSE 'On-Peak'
						  END||'</b></html>' as CHARGE_DATE,
			NULL as ITERATOR1_NAME, NULL as ITERATOR1_VAL, NULL as ITERATOR2_NAME, NULL as ITERATOR2_VAL,
			NULL as ITERATOR3_NAME, NULL as ITERATOR3_VAL, NULL as ITERATOR4_NAME, NULL as ITERATOR4_VAL,
			NULL as ITERATOR5_NAME, NULL as ITERATOR5_VAL, NULL as ITERATOR6_NAME, NULL as ITERATOR6_VAL,
			NULL as ITERATOR7_NAME, NULL as ITERATOR7_VAL, NULL as ITERATOR8_NAME, NULL as ITERATOR8_VAL,
			NULL as ITERATOR9_NAME, NULL as ITERATOR9_VAL, NULL as ITERATOR10_NAME, NULL as ITERATOR10_VAL,
			FC.VARIABLE_NAME, FC.CALC_ORDER, FC.VIEW_ORDER, SUM(VARIABLE_VALUE) as VARIABLE_VALUE
		FROM FORMULA_CHARGE_DRILL_DOWN_TEMP FC, SYSTEM_DATE_TIME SDT
		WHERE (p_SHOW_TOTALS = 1 OR p_SHOW_ONOFF_PEAK = 1)
			AND SDT.TIME_ZONE = p_TIME_ZONE
			AND SDT.DATA_INTERVAL_TYPE = CASE WHEN v_CUT = 0 THEN 2 ELSE 1 END
			AND SDT.DAY_TYPE = '1'
			AND SDT.CUT_DATE_SCHEDULING = FC.RECORD_DATE
		GROUP BY FC.VARIABLE_NAME, FC.CALC_ORDER, FC.VIEW_ORDER, ROLLUP(SDT.IS_ON_PEAK)
		HAVING (p_SHOW_TOTALS = 1 AND GROUPING(SDT.IS_ON_PEAK)=1)
			OR (p_SHOW_ONOFF_PEAK = 1 AND GROUPING(SDT.IS_ON_PEAK)=0);

	UT.PURGE_RTO_WORK(v_WORK_ID);
	DELETE FROM FORMULA_CHARGE_DRILL_DOWN_TEMP;

EXCEPTION
	WHEN OTHERS THEN
		UT.PURGE_RTO_WORK(v_WORK_ID);
		DELETE FROM FORMULA_CHARGE_DRILL_DOWN_TEMP;
		ERRS.LOG_AND_RAISE;
END RESULTS_VIEW;
---------------------------------------------------------------------------------------------------
END CALC_ENGINE_UI;
/
