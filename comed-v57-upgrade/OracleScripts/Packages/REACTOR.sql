CREATE OR REPLACE PACKAGE REACTOR AS
--Revision $Revision: 1.6 $

-- Engine package for the Reactor

FUNCTION WHAT_VERSION RETURN VARCHAR;

FUNCTION GET_STATE RETURN VARCHAR2;

FUNCTION GET_LAST_RUN_DATE_GMT RETURN DATE;

-- Return true if the specified Entity is associated with the
-- specified Reactor Proc for the specified date range.
FUNCTION IS_ENTITY_FOR_REACTOR_PROC
	(
	p_REACTOR_PROCEDURE IN REACTOR_PROCEDURE%ROWTYPE,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_BEGIN_DATE IN DATE := NULL,
	p_END_DATE IN DATE := NULL
	) RETURN BOOLEAN;

-- Generate the procedure calls that need to be made
-- for a changed row in the specified table and entity.
-- The Variable Cache contains the context of the changed row.
PROCEDURE GENERATE_PROCEDURE_CALLS
	(
	p_DB_TABLE_NAME IN VARCHAR2,
	p_KEY_ENTITY_ID IN NUMBER,
	p_KEY_DATE1 IN DATE,
	p_KEY_DATE2 IN DATE,
	p_VARIABLE_CACHE IN OUT NOCOPY UT.STRING_MAP
	);

-- Acquires the Reactor Lock via the MUTEX package.  If the Max Wait
-- is exceeded, an error MSGCODES.n_ERR_LOCK_WAIT_TIME_OUT is raised.
PROCEDURE LOCKDOWN
	(
	p_EXCLUSIVE IN BOOLEAN := FALSE,
	p_TIMEOUT IN INTEGER := MUTEX.c_MAX_WAIT
	);

-- Releases the Reactor Lock via the MUTEX package.
PROCEDURE RELEASE_LOCK;

PROCEDURE REACT;

c_TYPE_BEGIN_DATE CONSTANT VARCHAR2(16) := 'Begin Date';
c_TYPE_END_DATE CONSTANT VARCHAR2(16) := 'End Date';
c_TYPE_KEY CONSTANT VARCHAR2(16) := 'Key';
c_TYPE_NON_KEY CONSTANT VARCHAR2(16) := 'Non-Key';
c_TYPE_LAZY CONSTANT VARCHAR2(16) := 'Lazy';

END REACTOR;
/
CREATE OR REPLACE PACKAGE BODY REACTOR AS

TYPE REACTOR_PROC_TABLE IS TABLE OF REACTOR_PROCEDURE%ROWTYPE;
TYPE FORMULA_RESULT IS RECORD(RESULT_STRING VARCHAR2(4000),
							 	RESULT_STRING_COLLECTION STRING_COLLECTION,
								RESULT_DATE DATE,
								RESULT_DATE_COLLECTION DATE_COLLECTION,
								RESULT_NUMBER NUMBER,
								RESULT_NUMBER_COLLECTION NUMBER_COLLECTION,
								RESULT_LITERAL VARCHAR2(4000));

g_LAST_REACTOR_PROCS REACTOR_PROC_TABLE;
g_LAST_KEY_ENTITY_ID NUMBER(9) := -123;

--Variables for the IS_ENTITY_FOR_REACTOR_PROC function
g_IEFRP_ENTITY_ID NUMBER(9) := -123;
g_IEFRP_ENTITY_DOMAIN_ID NUMBER(9) := -123;
g_IEFRP_SUB_STATION_METER_ID TX_SUB_STATION_METER.METER_ID%TYPE := NULL;
g_IEFRP_SUB_STATION_ID TX_SUB_STATION.SUB_STATION_ID%TYPE := NULL;

g_LOCKDOWN_DISABLED BOOLEAN;

c_SETTING_CURRENT_STATE CONSTANT VARCHAR2(32) := 'Reactor: Current State';
c_SETTING_LAST_RUN CONSTANT VARCHAR2(32) := 'Reactor: GMT Last Completed Run';

c_STR_BEGIN_DATE CONSTANT VARCHAR2(16) := '#{BEGIN_DATE}';
c_STR_END_DATE CONSTANT VARCHAR2(16) := '#{END_DATE}';
c_STR_NON_KEY CONSTANT VARCHAR2(16) := '#{NON-KEY}';

c_STR_LEFT_BRACK CONSTANT VARCHAR2(16) := '#{';
c_STR_RIGHT_BRACK CONSTANT VARCHAR2(16) := '#}';

c_REACTOR_LOCK_NAME CONSTANT VARCHAR2(32) := 'Reactor';
----------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
	RETURN '$Revision: 1.6 $';
END WHAT_VERSION;
----------------------------------------------------------------------------------------------------
PROCEDURE SET_STATE (p_STATE IN VARCHAR2) AS
BEGIN
	SET_SYSTEM_STATE(p_SETTING_NAME => c_SETTING_CURRENT_STATE, p_STRING_VAL => p_STATE);
END SET_STATE;
----------------------------------------------------------------------------------------------------
-- Commit the Exception State in an autonomous transaction so the rollback does not lose it.
PROCEDURE SET_EXCEPTION_STATE AS
	PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
	SET_STATE('Exception');
	COMMIT;
END SET_EXCEPTION_STATE;
----------------------------------------------------------------------------------------------------
FUNCTION GET_STATE RETURN VARCHAR2 IS
BEGIN
	RETURN GET_SYSTEM_STATE_STR(p_SETTING_NAME => c_SETTING_CURRENT_STATE);
END GET_STATE;
----------------------------------------------------------------------------------------------------
FUNCTION GET_LAST_RUN_DATE_GMT RETURN DATE IS
BEGIN
	RETURN GET_SYSTEM_STATE_DATE(p_SETTING_NAME => c_SETTING_LAST_RUN);
END GET_LAST_RUN_DATE_GMT;
----------------------------------------------------------------------------------------------------
FUNCTION EVALUATE_PARAM_FORMULA
	(
	p_PARAM_FORMULA IN VARCHAR2,
	p_PARAM_TYPE IN VARCHAR2,
	p_VARIABLE_CACHE IN OUT NOCOPY UT.STRING_MAP,
	p_ERROR_MSG IN VARCHAR2
	) RETURN FORMULA_RESULT IS

	v_PARAMETER_FML VARCHAR2(4000);

	v_RESULT FORMULA_RESULT;

BEGIN

	v_PARAMETER_FML := FML_UTIL.REBUILD_FORMULA(p_PARAM_FORMULA, p_VARIABLE_CACHE);

	v_PARAMETER_FML := 'BEGIN :1 := '||v_PARAMETER_FML||'; END;';

	BEGIN
		--Get the parameter into the proper result variable according to its type.
		IF p_PARAM_TYPE = 'NUMBER' THEN
			EXECUTE IMMEDIATE v_PARAMETER_FML USING OUT v_RESULT.RESULT_NUMBER;
			v_RESULT.RESULT_LITERAL := UT.GET_LITERAL_FOR_NUMBER(v_RESULT.RESULT_NUMBER);
		ELSIF p_PARAM_TYPE = 'DATE' THEN
			EXECUTE IMMEDIATE v_PARAMETER_FML USING OUT v_RESULT.RESULT_DATE;
			v_RESULT.RESULT_LITERAL := UT.GET_LITERAL_FOR_DATE(v_RESULT.RESULT_DATE);
		ELSIF p_PARAM_TYPE = 'NUMBER_COLLECTION' THEN
			EXECUTE IMMEDIATE v_PARAMETER_FML USING OUT v_RESULT.RESULT_NUMBER_COLLECTION;
			v_RESULT.RESULT_LITERAL := UT.GET_LITERAL_FOR_NUMBER_COLL(v_RESULT.RESULT_NUMBER_COLLECTION);
		ELSIF p_PARAM_TYPE = 'STRING_COLLECTION' THEN
			EXECUTE IMMEDIATE v_PARAMETER_FML USING OUT v_RESULT.RESULT_STRING_COLLECTION;
			v_RESULT.RESULT_LITERAL := UT.GET_LITERAL_FOR_STRING_COLL(v_RESULT.RESULT_STRING_COLLECTION);
		ELSIF p_PARAM_TYPE = 'DATE_COLLECTION' THEN
			EXECUTE IMMEDIATE v_PARAMETER_FML USING OUT v_RESULT.RESULT_DATE_COLLECTION;
			v_RESULT.RESULT_LITERAL := UT.GET_LITERAL_FOR_DATE_COLL(v_RESULT.RESULT_DATE_COLLECTION);
		ELSE
			EXECUTE IMMEDIATE v_PARAMETER_FML USING OUT v_RESULT.RESULT_STRING;
			v_RESULT.RESULT_LITERAL := UT.GET_LITERAL_FOR_STRING(v_RESULT.RESULT_STRING);
		END IF;

	EXCEPTION
		WHEN OTHERS THEN
			ERRS.LOG_AND_RAISE(p_ERROR_MSG);
	END;

	RETURN v_RESULT;

END EVALUATE_PARAM_FORMULA;
----------------------------------------------------------------------------------------------------
FUNCTION IS_ENTITY_FOR_REACTOR_PROC
	(
	p_REACTOR_PROCEDURE IN REACTOR_PROCEDURE%ROWTYPE,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_BEGIN_DATE IN DATE := NULL,
	p_END_DATE IN DATE := NULL
	) RETURN BOOLEAN IS

	CURSOR c_REACTOR_PROC_ENTITIES (p_REACTOR_PROCEDURE_ID IN NUMBER, p_DATE1 IN DATE, p_DATE2 IN DATE) IS
		SELECT *
		FROM REACTOR_PROCEDURE_INPUT
		WHERE REACTOR_PROCEDURE_ID = p_REACTOR_PROCEDURE_ID
			AND NVL(p_DATE1,CONSTANTS.LOW_DATE) <= NVL(END_DATE, CONSTANTS.HIGH_DATE)
			AND NVL(p_DATE2,CONSTANTS.HIGH_DATE) >= BEGIN_DATE;

	v_DAY1 DATE := NULL;
	v_DAY2 DATE := NULL;
	v_INCLUDE BOOLEAN := FALSE;
	v_ENTITY_FOR_DOMAIN NUMBER(9);
BEGIN

	--Get a "daily" date to use for comparing with begin/end date ranges.
	IF p_BEGIN_DATE IS NOT NULL THEN
		v_DAY1 := FROM_CUT(p_BEGIN_DATE, NVL(p_REACTOR_PROCEDURE.TIME_ZONE, LOCAL_TIME_ZONE));
	END IF;
	IF p_END_DATE IS NOT NULL THEN
		v_DAY2 := FROM_CUT(p_END_DATE, NVL(p_REACTOR_PROCEDURE.TIME_ZONE, LOCAL_TIME_ZONE));
	END IF;

	--If this is a Substation Meter Point Data change, we want to check
	--  to see if this Substation Meter Point's Meter or Substation are
	--  assigned to any Reactor Procedures as well.
	--These values are cached incase we are dealing with the same entity multiple times.
	IF p_ENTITY_DOMAIN_ID <> g_IEFRP_ENTITY_DOMAIN_ID OR p_ENTITY_ID <> g_IEFRP_ENTITY_ID THEN
		IF p_ENTITY_DOMAIN_ID = EC.ED_SUB_STATION_METER_POINT THEN
			SELECT P.SUB_STATION_METER_ID, M.SUB_STATION_ID
			INTO g_IEFRP_SUB_STATION_METER_ID, g_IEFRP_SUB_STATION_ID
			FROM TX_SUB_STATION_METER_POINT P, TX_SUB_STATION_METER M
			WHERE P.METER_POINT_ID = p_ENTITY_ID
				AND M.METER_ID(+) = P.SUB_STATION_METER_ID;
		ELSIF p_ENTITY_DOMAIN_ID = EC.ED_SUB_STATION_METER THEN
			SELECT p_ENTITY_ID, M.SUB_STATION_ID
			INTO g_IEFRP_SUB_STATION_METER_ID, g_IEFRP_SUB_STATION_ID
			FROM TX_SUB_STATION_METER M
			WHERE M.METER_ID = p_ENTITY_ID;
		ELSIF p_ENTITY_DOMAIN_ID = EC.ED_SUB_STATION THEN
			g_IEFRP_SUB_STATION_METER_ID := 0;
			g_IEFRP_SUB_STATION_ID := p_ENTITY_ID;
		END IF;
		g_IEFRP_ENTITY_DOMAIN_ID := p_ENTITY_DOMAIN_ID;
		g_IEFRP_ENTITY_ID := p_ENTITY_ID;
	END IF;

	--Look through each entity in this proc.
	FOR v_ENTITY IN c_REACTOR_PROC_ENTITIES(p_REACTOR_PROCEDURE.REACTOR_PROCEDURE_ID, v_DAY1, v_DAY2) LOOP

		v_ENTITY_FOR_DOMAIN := CASE
			WHEN v_ENTITY.ENTITY_DOMAIN_ID = EC.ED_SUB_STATION_METER THEN g_IEFRP_SUB_STATION_METER_ID
			WHEN v_ENTITY.ENTITY_DOMAIN_ID = EC.ED_SUB_STATION THEN g_IEFRP_SUB_STATION_ID
			ELSE p_ENTITY_ID
		END;

		-- See if our entity matches this input's entity.
		IF v_ENTITY.ENTITY_TYPE = 'E' THEN
			v_INCLUDE := v_ENTITY.ENTITY_ID = v_ENTITY_FOR_DOMAIN;
		-- See if our entity is in this input's group.
		ELSIF v_ENTITY.ENTITY_TYPE = 'G' THEN
			v_INCLUDE := SD.IS_MEMBER_OF_ENTITY_GROUP(v_ENTITY_FOR_DOMAIN, v_ENTITY.ENTITY_ID, v_DAY1, v_DAY2, TRUE);
		-- See if our entity is in this input's realm.
		ELSIF v_ENTITY.ENTITY_TYPE = 'R' THEN
			v_INCLUDE := SD.IS_MEMBER_OF_SYSTEM_REALM(v_ENTITY_FOR_DOMAIN, v_ENTITY.ENTITY_ID);
		END IF;

		-- Look no further if this procedure should be included.
		EXIT WHEN v_INCLUDE;
	END LOOP;

	RETURN v_INCLUDE;
END IS_ENTITY_FOR_REACTOR_PROC;
----------------------------------------------------------------------------------------------------
-- Get the list of Reactor Procedure IDs that could be affected
-- by the specified Entity.
FUNCTION GET_REACTOR_PROCEDURES
	(
	p_DB_TABLE_NAME IN VARCHAR2,
	p_KEY_ENTITY_ID IN NUMBER,
	p_KEY_DATE1 IN DATE,
	p_KEY_DATE2 IN DATE
	) RETURN REACTOR_PROC_TABLE AS

	v_TBL_ENTITY_DOMAIN_ID NUMBER(9);
	v_TABLE_ID NUMBER(9);
	v_PROCs REACTOR_PROC_TABLE := REACTOR_PROC_TABLE();

	CURSOR c_REACTOR_PROCS IS
		SELECT *
		FROM REACTOR_PROCEDURE
		WHERE TABLE_ID = v_TABLE_ID
			AND IS_ENABLED = 1;
BEGIN

	SELECT ENTITY_DOMAIN_ID, TABLE_ID
	INTO v_TBL_ENTITY_DOMAIN_ID, v_TABLE_ID
	FROM SYSTEM_TABLE
	WHERE DB_TABLE_NAME = p_DB_TABLE_NAME;

	--Loop through each Reactor Proc, and add it to the list if it contains this entity.
	FOR v_PROC IN c_REACTOR_PROCS LOOP

		IF IS_ENTITY_FOR_REACTOR_PROC(v_PROC, v_TBL_ENTITY_DOMAIN_ID, p_KEY_ENTITY_ID, p_KEY_DATE1, p_KEY_DATE2) THEN
			v_PROCs.EXTEND;
			v_PROCs(v_PROCs.LAST) := v_PROC;
		END IF;

	END LOOP;
	RETURN v_PROCs;

END GET_REACTOR_PROCEDURES;
----------------------------------------------------------------------------------------------------
PROCEDURE EVALUATE_ENTITY_REFS
	(
	p_REACTOR_PROCEDURE_ID IN NUMBER,
	p_VARIABLE_CACHE IN OUT NOCOPY UT.STRING_MAP
	) AS
BEGIN
	FOR v_REF IN (SELECT * FROM REACTOR_PROCEDURE_ENTITY_REF
					 WHERE REACTOR_PROCEDURE_ID = p_REACTOR_PROCEDURE_ID) LOOP
		p_VARIABLE_CACHE(v_REF.REFERENCE_NAME) := UT.GET_LITERAL_FOR_NUMBER(v_REF.ENTITY_ID);
	END LOOP;
END EVALUATE_ENTITY_REFS;
----------------------------------------------------------------------------------------------------
-- Generate the procedure calls that need to be made
-- for a changed row in the specified table and entity.
-- The Variable Cache contains the context of the changed row.
PROCEDURE GENERATE_PROCEDURE_CALLS
	(
	p_DB_TABLE_NAME IN VARCHAR2,
	p_KEY_ENTITY_ID IN NUMBER,
	p_KEY_DATE1 IN DATE,
	p_KEY_DATE2 IN DATE,
	p_VARIABLE_CACHE IN OUT NOCOPY UT.STRING_MAP
	) AS
	v_SKIP_WHEN_FML VARCHAR2(4000);
	v_PARAMETER_FML VARCHAR2(4000);
	v_SKIP BOOLEAN;
	v_SKIP_WHEN_RESULT NUMBER;
	v_RESULT FORMULA_RESULT;
	v_ERR_MSG VARCHAR2(4000);
	v_PARAM_TYPE VARCHAR2(50);
	v_PROC REACTOR_PROCEDURE%ROWTYPE;
	v_PROC_CALL REACTOR_PROCEDURE_LIST_TEMP%ROWTYPE;
	v_FIRST BOOLEAN;
	v_VAL VARCHAR2(4000);
	v_PARAM_DETAILS STORED_PROC_PARAMETER_TABLE;

CURSOR c_PARAMS(p_REACTOR_PROCEDURE_ID IN NUMBER) IS
	SELECT P.*, X.PARAMETER_TYPE AS VARIABLE_TYPE, X.PARAMETER_SUB_TYPE AS VARIABLE_SUB_TYPE
	FROM REACTOR_PROCEDURE_PARAMETER P, TABLE(CAST(v_PARAM_DETAILS AS STORED_PROC_PARAMETER_TABLE)) X
	WHERE REACTOR_PROCEDURE_ID = p_REACTOR_PROCEDURE_ID
		AND X.PARAMETER_NAME = P.PARAMETER_NAME
	ORDER BY PARAMETER_ORDER;
BEGIN

	--Update the list of Reactor Procedures for this entity if it is a new entity.
	IF p_KEY_ENTITY_ID <> g_LAST_KEY_ENTITY_ID THEN
		g_LAST_REACTOR_PROCS := GET_REACTOR_PROCEDURES(p_DB_TABLE_NAME, p_KEY_ENTITY_ID, p_KEY_DATE1, p_KEY_DATE2);
		g_LAST_KEY_ENTITY_ID := p_KEY_ENTITY_ID;
	END IF;

	--For each Reactor Proc associated with this entity...
	FOR i IN 1 .. g_LAST_REACTOR_PROCS.COUNT LOOP
		v_PROC := g_LAST_REACTOR_PROCS(i);

		--Add the Entity Refs to the map before we evaluate any formulas.
		EVALUATE_ENTITY_REFS(v_PROC.REACTOR_PROCEDURE_ID, p_VARIABLE_CACHE);

		--Check the Skip When Formula, and skip this proc if necessary.
		v_SKIP := FALSE;
		IF v_PROC.SKIP_WHEN_FORMULA IS NOT NULL THEN
			IF LOGS.IS_DEBUG_ENABLED THEN
				LOGS.LOG_DEBUG ('Skip When Formula = '||v_PROC.SKIP_WHEN_FORMULA);
			END IF;

			v_SKIP_WHEN_FML := FML_UTIL.REBUILD_FORMULA(v_PROC.SKIP_WHEN_FORMULA, p_VARIABLE_CACHE);
			v_SKIP_WHEN_FML := 'BEGIN :1 := UT.NUMBER_FROM_BOOLEAN('||v_SKIP_WHEN_FML||'); END;';

			IF LOGS.IS_DEBUG_ENABLED THEN
				LOGS.LOG_DEBUG ('Skip When Formula After Processing = '||v_SKIP_WHEN_FML);
			END IF;
			BEGIN
				EXECUTE IMMEDIATE v_SKIP_WHEN_FML USING OUT v_SKIP_WHEN_RESULT;
			EXCEPTION
				WHEN OTHERS THEN
					ERRS.LOG_AND_RAISE('Error evaluating the Skip When Formula: '||UTL_TCP.CRLF||
						v_SKIP_WHEN_FML||UTL_TCP.CRLF||
						' for '||TEXT_UTIL.TO_CHAR_ENTITY(v_PROC.REACTOR_PROCEDURE_ID, EC.ED_REACTOR_PROCEDURE, TRUE));
			END;

			IF LOGS.IS_DEBUG_ENABLED THEN
				LOGS.LOG_DEBUG ('Skip When Formula Result = '||v_SKIP_WHEN_RESULT);
			END IF;
			v_SKIP := UT.BOOLEAN_FROM_NUMBER(v_SKIP_WHEN_RESULT);
		END IF;

		IF NOT v_SKIP THEN
			v_PROC_CALL := NULL;
			v_PROC_CALL.PROCEDURE_CALL := v_PROC.PROCEDURE_NAME||'(';
			v_PROC_CALL.KEY_PROCEDURE_CALL := v_PROC.PROCEDURE_NAME||'(';
			v_PROC_CALL.JOB_THREAD_ID := v_PROC.JOB_THREAD_ID;
			v_PROC_CALL.JOB_COMMENTS := v_PROC.JOB_COMMENTS;
			v_PROC_CALL.CALL_ORDER := v_PROC.CALL_ORDER;
			v_PROC_CALL.IS_IMMEDIATE := v_PROC.IS_IMMEDIATE;
			v_FIRST := TRUE;
			UT.GET_STORED_PROC_PARAMETERS(v_PROC.PROCEDURE_NAME, 0, v_PARAM_DETAILS);

			-- Process each parameter for this procedure
			FOR v_PARAM IN c_PARAMS(v_PROC.REACTOR_PROCEDURE_ID) LOOP
				IF LOGS.IS_DEBUG_ENABLED THEN
					LOGS.LOG_DEBUG ('Parameter "'||v_PARAM.PARAMETER_NAME||'" Formula = '||v_PARAM.PARAMETER_FORMULA);
				END IF;

				v_PARAM_TYPE := CASE v_PARAM.VARIABLE_TYPE
								WHEN 'TABLE' THEN v_PARAM.VARIABLE_SUB_TYPE
								ELSE v_PARAM.VARIABLE_TYPE END;

				--Evaluate the parameter's formula
				IF v_PARAM.PARAMETER_FORMULA IS NULL THEN
					v_PARAMETER_FML := NULL;
				ELSIF v_PARAM.PARAMETER_TYPE = c_TYPE_LAZY THEN
					v_PARAMETER_FML := NULL;
				ELSE
					v_ERR_MSG := 'Error converting parameter '|| v_PARAM.PARAMETER_NAME  ||' to a '
							|| UTL_TCP.CRLF|| v_PARAM_TYPE || ' using the formula '|| v_PARAMETER_FML
							|| UTL_TCP.CRLF|| ' for ' || TEXT_UTIL.TO_CHAR_ENTITY(v_PROC.REACTOR_PROCEDURE_ID,
																	EC.ED_REACTOR_PROCEDURE, TRUE);

					v_RESULT := EVALUATE_PARAM_FORMULA(v_PARAM.PARAMETER_FORMULA,
													v_PARAM_TYPE,
													p_VARIABLE_CACHE,
													v_ERR_MSG);

					IF LOGS.IS_DEBUG_ENABLED THEN
						LOGS.LOG_DEBUG ('Parameter "'||v_PARAM.PARAMETER_NAME||'" Formula Result = '||v_RESULT.RESULT_LITERAL);
					END IF;
				END IF;

				--Add the parameter to the procedure call.
				IF NOT v_FIRST THEN
					v_PROC_CALL.PROCEDURE_CALL := v_PROC_CALL.PROCEDURE_CALL||',';
					v_PROC_CALL.KEY_PROCEDURE_CALL := v_PROC_CALL.KEY_PROCEDURE_CALL||',';
				ELSE
					v_FIRST := FALSE;
				END IF;

				IF v_PARAM.PARAMETER_TYPE = c_TYPE_BEGIN_DATE THEN
					v_VAL := c_STR_BEGIN_DATE;
					v_PROC_CALL.BEGIN_DATE := v_RESULT.RESULT_DATE;
					IF LOGS.IS_DEBUG_ENABLED THEN
						LOGS.LOG_DEBUG ('Begin Date = '||TEXT_UTIL.TO_CHAR_TIME(v_PROC_CALL.BEGIN_DATE));
					END IF;
				ELSIF v_PARAM.PARAMETER_TYPE = c_TYPE_END_DATE THEN
					v_VAL := c_STR_END_DATE;
					v_PROC_CALL.END_DATE := v_RESULT.RESULT_DATE;
					IF LOGS.IS_DEBUG_ENABLED THEN
						LOGS.LOG_DEBUG ('End Date = '||TEXT_UTIL.TO_CHAR_TIME(v_PROC_CALL.END_DATE));
					END IF;
				ELSIF v_PARAM.PARAMETER_TYPE = c_TYPE_KEY THEN
					v_VAL := v_RESULT.RESULT_LITERAL;
				ELSE
					v_VAL := c_STR_NON_KEY;
				END IF;
				v_PROC_CALL.KEY_PROCEDURE_CALL := v_PROC_CALL.KEY_PROCEDURE_CALL||v_PARAM.PARAMETER_NAME||' => '||v_VAL;

				IF v_PARAM.PARAMETER_TYPE = c_TYPE_NON_KEY THEN
					v_VAL := v_RESULT.RESULT_LITERAL;
				ELSIF v_PARAM.PARAMETER_TYPE = c_TYPE_LAZY THEN
					-- THIS IS A LAZY PARAMETER, WE DON'T WANT TO EVALUATE IT UNTIL
					-- IT'S ACTUALLY TIME TO QUEUE THE PROCEDURE, SO JUST STORE THE PARAMETER TYPE
					-- AND FORMULA IN THE PARAM STRING, THEN QUEUE_CALL WILL BE REPSONSIBLE FOR PARSING IT OUT
					v_VAL := c_STR_LEFT_BRACK || v_PARAM_TYPE || '|' || v_PARAM.PARAMETER_FORMULA || c_STR_RIGHT_BRACK;
				END IF;

				v_PROC_CALL.PROCEDURE_CALL := v_PROC_CALL.PROCEDURE_CALL||v_PARAM.PARAMETER_NAME||' => '||v_VAL;

			END LOOP; --PARAMETER LOOP

			v_PROC_CALL.PROCEDURE_CALL := v_PROC_CALL.PROCEDURE_CALL||');';
			v_PROC_CALL.KEY_PROCEDURE_CALL := v_PROC_CALL.KEY_PROCEDURE_CALL||');';

			IF LOGS.IS_DEBUG_ENABLED THEN
				LOGS.LOG_DEBUG ('Inserting Proc Call to '||v_PROC.PROCEDURE_NAME||' into REACTOR_PROCEDURE_LIST_TEMP.');
				LOGS.LOG_DEBUG ('	Key Procedure Call = '||v_PROC_CALL.KEY_PROCEDURE_CALL);
				LOGS.LOG_DEBUG ('	Begin Date = '||TEXT_UTIL.TO_CHAR_TIME(v_PROC_CALL.BEGIN_DATE));
				LOGS.LOG_DEBUG ('	End Date = '||TEXT_UTIL.TO_CHAR_TIME(v_PROC_CALL.END_DATE));
				LOGS.LOG_DEBUG ('	Procedure Call = '||v_PROC_CALL.PROCEDURE_CALL);
			END IF;

			INSERT INTO REACTOR_PROCEDURE_LIST_TEMP VALUES v_PROC_CALL;

			--TODO: Handle Functions, In Out, and Out params.

			--TODO: We are silently ignoring parameter mismatch on name, and always using OL of 1.  maybe log warning.
		END IF;
	END LOOP; -- REACTOR PROC LOOP

END GENERATE_PROCEDURE_CALLS;
----------------------------------------------------------------------------------------------------
-- Acquires the Reactor Lock via the MUTEX package.  If the Max Wait
-- is exceeded, an error MSGCODES.n_ERR_LOCK_WAIT_TIME_OUT is raised.
PROCEDURE LOCKDOWN
	(
	p_EXCLUSIVE IN BOOLEAN := FALSE,
	p_TIMEOUT IN INTEGER := MUTEX.c_MAX_WAIT
	) AS
	DUMMY MUTEX.t_HANDLE;
BEGIN
	IF g_LOCKDOWN_DISABLED THEN
		LOGS.LOG_WARN('The Reactor cannot be locked down due to current System Settings.');
	ELSE
		DUMMY := MUTEX.ACQUIRE(p_MUTEX_NAME => c_REACTOR_LOCK_NAME, p_TIMEOUT => p_TIMEOUT, p_EXCLUSIVE => p_EXCLUSIVE);
	END IF;
END LOCKDOWN;
----------------------------------------------------------------------------------------------------
-- Releases the Reactor Lock via the MUTEX package.
PROCEDURE RELEASE_LOCK AS
BEGIN
	IF g_LOCKDOWN_DISABLED THEN
		LOGS.LOG_WARN('The Reactor cannot be locked down due to current System Settings.');
	ELSE
		MUTEX.RELEASE_BY_NAME(c_REACTOR_LOCK_NAME);
	END IF;
END RELEASE_LOCK;
----------------------------------------------------------------------------------------------------
PROCEDURE QUEUE_CALL
	(
	p_PROCEDURE_CALL IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_JOB_THREAD_ID IN NUMBER,
	p_JOB_COMMENTS IN VARCHAR2,
	p_IS_IMMEDIATE IN NUMBER
	) AS
	v_CALL VARCHAR2(4000);

	v_LEFT_BRACK_POS PLS_INTEGER;
	v_RIGHT_BRACK_POS PLS_INTEGER;
	v_PIPE_POS PLS_INTEGER;
	v_TYPE VARCHAR2(32);
	v_PARAMETER_FML VARCHAR2(4000);
	v_RESULT FORMULA_RESULT;

	v_PARAM_CTX UT.STRING_MAP;

BEGIN
	LOGS.LOG_INFO_DETAIL('PROCEDURE CALL: ' || p_PROCEDURE_CALL);
	--Substitue the begin and end dates into the procedure call.
	v_CALL := REPLACE(p_PROCEDURE_CALL, c_STR_BEGIN_DATE, UT.GET_LITERAL_FOR_DATE(p_BEGIN_DATE));
	v_CALL := REPLACE(v_CALL, c_STR_END_DATE, UT.GET_LITERAL_FOR_DATE(p_END_DATE));

	-- evaluate all the lazy formulas
	v_LEFT_BRACK_POS := INSTR(v_CALL, c_STR_LEFT_BRACK);

	WHILE v_LEFT_BRACK_POS > 0 LOOP
		v_RIGHT_BRACK_POS := INSTR(v_CALL, c_STR_RIGHT_BRACK);
		v_PIPE_POS := INSTR(v_CALL, '|', v_LEFT_BRACK_POS);
		v_TYPE := SUBSTR(v_CALL, v_LEFT_BRACK_POS + 2, v_PIPE_POS - v_LEFT_BRACK_POS - 2);
		v_PARAMETER_FML := SUBSTR(v_CALL, v_PIPE_POS + 1, v_RIGHT_BRACK_POS - v_PIPE_POS - 1);

		v_RESULT := EVALUATE_PARAM_FORMULA(v_PARAMETER_FML, v_TYPE, v_PARAM_CTX,
			'Error converting lazy parameter using the formula ' ||v_PARAMETER_FML
				|| UTL_TCP.CRLF || ' for parameter call: ' || p_PROCEDURE_CALL);

		v_CALL := SUBSTR(v_CALL, 1, v_LEFT_BRACK_POS - 1) || v_RESULT.RESULT_LITERAL ||
					SUBSTR(v_CALL, v_RIGHT_BRACK_POS + 2);

		v_LEFT_BRACK_POS := INSTR(v_CALL, c_STR_LEFT_BRACK);
	END LOOP;

	IF p_IS_IMMEDIATE = 1 THEN
		LOGS.LOG_INFO_DETAIL('The Reactor is about to execute the immediate procedure - ' || v_CALL);
		EXECUTE IMMEDIATE 'BEGIN ' || v_CALL || ' END;';
	ELSE
		--Send it to the process queues!
		JOBS.ENQUEUE_BY_JOB_THREAD(p_JOB_THREAD_ID, v_CALL, p_JOB_COMMENTS);
		LOGS.LOG_INFO_DETAIL('The Reactor has queued a procedure call.');
		LOGS.POST_EVENT_DETAILS('PL/SQL Block', CONSTANTS.MIME_TYPE_TEXT, v_CALL);
	END IF;

END QUEUE_CALL;
----------------------------------------------------------------------------------------------------
FUNCTION PROCESS_PROCEDURE_LIST RETURN BINARY_INTEGER IS

--In this cursor, we want to group together by Key Procedure Call, in order by date,
--  and we want to make sure those groups are ordered by call order.
CURSOR c_LIST IS
	SELECT MIN_CALL_ORDER, KEY_PROCEDURE_CALL, BEGIN_DATE, END_DATE,
		MIN(PROCEDURE_CALL) AS PROCEDURE_CALL,
		MIN(JOB_THREAD_ID) AS JOB_THREAD_ID,
		MIN(JOB_COMMENTS) AS JOB_COMMENTS,
		MIN(IS_IMMEDIATE) AS IS_IMMEDIATE
	 FROM
		(
		SELECT
			MIN(CALL_ORDER) OVER (PARTITION BY KEY_PROCEDURE_CALL) AS MIN_CALL_ORDER,
			KEY_PROCEDURE_CALL,
			BEGIN_DATE,
			CASE WHEN END_DATE IS NULL THEN NULL ELSE GREATEST(BEGIN_DATE, END_DATE) END AS END_DATE,
			PROCEDURE_CALL,
			JOB_THREAD_ID,
			JOB_COMMENTS,
			IS_IMMEDIATE
		FROM REACTOR_PROCEDURE_LIST_TEMP
		)
	GROUP BY MIN_CALL_ORDER, KEY_PROCEDURE_CALL, BEGIN_DATE, END_DATE
	ORDER BY MIN_CALL_ORDER, KEY_PROCEDURE_CALL, BEGIN_DATE NULLS FIRST, END_DATE NULLS LAST;

	v_PREV_REC c_LIST%ROWTYPE;
	v_BEGIN DATE;
	v_END DATE;
	v_COUNT BINARY_INTEGER := 0;

	--Queue the previous record we processed.
	PROCEDURE QUEUE_PREVIOUS AS BEGIN
		IF v_PREV_REC.PROCEDURE_CALL IS NOT NULL THEN
			QUEUE_CALL(v_PREV_REC.PROCEDURE_CALL, v_BEGIN, v_END, v_PREV_REC.JOB_THREAD_ID, v_PREV_REC.JOB_COMMENTS, v_PREV_REC.IS_IMMEDIATE);
			v_COUNT := v_COUNT + 1;
		END IF;
	END QUEUE_PREVIOUS;

BEGIN
	v_PREV_REC.KEY_PROCEDURE_CALL := '~~INIT_VAL~~';

	--Gather the distinct set of changes and queue them
	FOR v_ITEM IN c_LIST LOOP
		--If this is a new Key Proc call, then queue the previous call if we had one.
		IF v_ITEM.KEY_PROCEDURE_CALL <> v_PREV_REC.KEY_PROCEDURE_CALL THEN
			QUEUE_PREVIOUS;
			v_BEGIN := v_ITEM.BEGIN_DATE;
			v_END := v_ITEM.END_DATE;
		--If we are processing the same call, and this date range is not overlapping
		--  the previous, then queue the previous call.
		ELSIF NVL(v_END, CONSTANTS.HIGH_DATE) + 1/86400 < NVL(v_ITEM.BEGIN_DATE, CONSTANTS.LOW_DATE) THEN
			QUEUE_PREVIOUS;
			v_BEGIN := v_ITEM.BEGIN_DATE;
			v_END := v_ITEM.END_DATE;
		--Else, we have an overlapping range on the same Key Proc.  Set the date
		--  ranges appropriately and move to the next row.
		ELSE
			v_BEGIN := CASE WHEN v_BEGIN IS NULL OR v_ITEM.BEGIN_DATE IS NULL THEN NULL ELSE LEAST(v_BEGIN, v_ITEM.BEGIN_DATE) END;
			v_END := CASE WHEN v_END IS NULL OR v_ITEM.END_DATE IS NULL THEN NULL ELSE GREATEST(v_END, v_ITEM.END_DATE) END;
		END IF;

		v_PREV_REC := v_ITEM;
	END LOOP;
	QUEUE_PREVIOUS;

	RETURN v_COUNT;

END PROCESS_PROCEDURE_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE REACT AS
	v_LOCK_TIMEOUT INTEGER;
	v_CONTINUE_ON_TIMEOUT NUMBER(1);
	v_NUM_PROC_CALLS BINARY_INTEGER;
	v_CUR_COUNT BINARY_INTEGER := 0;
	v_COUNT BINARY_INTEGER := 0;

CURSOR c_REACTIVE_TABLES IS
	SELECT T.MIRROR_TABLE_NAME
	FROM SYSTEM_TABLE T
	WHERE T.IS_REACTIVE = 1;
BEGIN

	-- Get the Reactor Lock.
	v_LOCK_TIMEOUT := NVL(GET_DICTIONARY_VALUE('Num Seconds to Wait for Lock', 0, 'System', 'Reactor'), MUTEX.c_MAX_WAIT);
	SET_STATE('Waiting for Lock');

	IF NOT g_LOCKDOWN_DISABLED THEN
		BEGIN
			LOCKDOWN(TRUE, v_LOCK_TIMEOUT);
		EXCEPTION
			WHEN MSGCODES.e_ERR_LOCK_WAIT_TIME_OUT THEN
				v_CONTINUE_ON_TIMEOUT := NVL(GET_DICTIONARY_VALUE('Continue on Lock Timeout', 0, 'System', 'Reactor'), 0);
				IF UT.BOOLEAN_FROM_NUMBER(v_CONTINUE_ON_TIMEOUT) THEN
					LOGS.LOG_NOTICE('Reactor timed out waiting for lock, but is running anyways.');
				ELSE
					LOGS.LOG_NOTICE('Reactor lock timeout occurred.');
					RETURN;
				END IF;
		END;
	END IF;

	SET_STATE('Running');
	EXECUTE IMMEDIATE 'TRUNCATE TABLE REACTOR_PROCEDURE_LIST_TEMP';

	FOR v_TABLE IN c_REACTIVE_TABLES LOOP
		--Queue up all the reactions to the table changes.
		EXECUTE IMMEDIATE 'BEGIN :1 := ZRE_'||SUBSTR(v_TABLE.MIRROR_TABLE_NAME,5)||'; END;' USING OUT v_CUR_COUNT;
		v_COUNT := v_COUNT + v_CUR_COUNT;
	END LOOP;

	--Queue up the distinct set of procedure calls for these changes.
	v_NUM_PROC_CALLS := PROCESS_PROCEDURE_LIST;
	LOGS.LOG_INFO('The Reactor processed '||v_COUNT||' audit records and queued '||v_NUM_PROC_CALLS||' calls to the process queues.');

	IF NOT g_LOCKDOWN_DISABLED THEN
		RELEASE_LOCK;
	END IF;
	SET_SYSTEM_STATE(p_SETTING_NAME => c_SETTING_LAST_RUN, p_DATE_VAL => SYS_EXTRACT_UTC(SYSTIMESTAMP));
	SET_STATE('Sleeping');

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE('The Reactor did not run successfully.');
		BEGIN
			SET_EXCEPTION_STATE;
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE;
		END;
		BEGIN
			RELEASE_LOCK;
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE;
		END;
		RAISE;
END REACT;
----------------------------------------------------------------------------------------------------
BEGIN
	g_LOCKDOWN_DISABLED := UT.BOOLEAN_FROM_STRING(GET_DICTIONARY_VALUE('Disable Lockdown', 0, 'System', 'Reactor'));
END REACTOR;
/
