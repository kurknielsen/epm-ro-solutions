CREATE OR REPLACE PACKAGE BODY ACCOUNTS_METERS IS
----------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR2 IS
BEGIN
    RETURN '$Revision: 1.15 $';
END WHAT_VERSION;
---------------------------------------------------------------------------------------------------
FUNCTION GET_ACCOUNT_SEARCH_OPTION_NAME (p_SEARCH_OPTION IN VARCHAR2) RETURN VARCHAR2 IS
    v_RESULT VARCHAR2(64);
BEGIN
    CASE p_SEARCH_OPTION
        WHEN 'By Alias' THEN
            v_RESULT := 'Account Alias';
        WHEN 'By Display Name' THEN
            v_RESULT := 'Account Display Name';
        WHEN 'By External Identifier' THEN
            v_RESULT := 'Account External Identifier';
        WHEN 'By EDC Account Number' THEN
            v_RESULT := 'EDC Account Number';
		WHEN 'By ESP Account Number' THEN
			v_RESULT := 'ESP Account Number';
		WHEN 'By Account Group Name' THEN
			v_RESULT := 'Account Group Name';
		ELSE
			v_RESULT := 'Account Name';
	END CASE;

    RETURN v_RESULT;
END GET_ACCOUNT_SEARCH_OPTION_NAME;
----------------------------------------------------------------------------------------------------
PROCEDURE SEARCH_ACCOUNTS
    (
    p_SEARCH_STRING IN VARCHAR2,
    p_SEARCH_OPTION IN VARCHAR2,
    p_SEARCH_OPTION_NAME OUT VARCHAR2,
    p_ACCOUNT_IDS OUT NUMBER_COLLECTION
    ) AS

    v_CURSOR GA.REFCURSOR;

    v_SEARCH_NAME VARCHAR2(2000);
    v_ACCOUNT_ID ACCOUNT.ACCOUNT_ID%TYPE;
    v_ACCOUNT_NAME ACCOUNT.ACCOUNT_NAME%TYPE;
    v_ACCOUNT_IS_SA ACCOUNT.IS_SUB_AGGREGATE%TYPE;
    v_ACCOUNT_MODEL ACCOUNT.ACCOUNT_MODEL_OPTION%TYPE;
    v_ACCOUNT_MODEL_ID ACCOUNT.MODEL_ID%TYPE;

BEGIN

    p_ACCOUNT_IDS := NUMBER_COLLECTION();

    IF NVL(p_SEARCH_STRING,'%') = '%' THEN
        p_SEARCH_OPTION_NAME := GET_ACCOUNT_SEARCH_OPTION_NAME(p_SEARCH_OPTION);
        p_ACCOUNT_IDS.EXTEND();
        p_ACCOUNT_IDS(1) := CONSTANTS.ALL_ID;
    ELSE
        ACCOUNT_LIST(p_SEARCH_STRING,
                     p_SEARCH_OPTION,
                     CONSTANTS.SEARCH_TYPE_NORMAL,
                     NULL,
                     CONSTANTS.ALL_STRING,
                     p_SEARCH_OPTION_NAME,
                     v_CURSOR);

        BEGIN
            LOOP
                FETCH v_CURSOR INTO v_SEARCH_NAME, v_ACCOUNT_ID, v_ACCOUNT_NAME, v_ACCOUNT_MODEL,
                    v_ACCOUNT_MODEL_ID, v_ACCOUNT_IS_SA;
                EXIT WHEN v_CURSOR%NOTFOUND;

                p_ACCOUNT_IDS.EXTEND();
                p_ACCOUNT_IDS(p_ACCOUNT_IDS.LAST) := v_ACCOUNT_ID;
            END LOOP;

            CLOSE v_CURSOR;

        EXCEPTION
            WHEN OTHERS THEN
                  BEGIN
                    CLOSE v_CURSOR;
                  EXCEPTION
                    WHEN OTHERS THEN
                        ERRS.LOG_AND_CONTINUE();
                  END;
                  ERRS.LOG_AND_RAISE();
        END;
    END IF;

END SEARCH_ACCOUNTS;
----------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNT_LIST
	(
	p_SEARCH_STRING      IN VARCHAR,
	p_SEARCH_OPTION      IN VARCHAR,
	p_SEARCH_TYPE        IN NUMBER,
	p_FIND_ACCOUNT_ID    IN NUMBER,
	p_ACCOUNT_MODEL_OPTION IN VARCHAR2,
	p_SEARCH_OPTION_NAME OUT VARCHAR2,
	p_CURSOR             OUT GA.REFCURSOR
	) AS
	v_IDS             ID_TABLE;
	v_ACCT_IS_ALLOWED BOOLEAN;
BEGIN

	-- This procedure supports the following search options:
	--      By Name
	--      By Alias
	--      By Display Name
	--      By External Identifier
	--      By EDC Account Number
	--      By ESP Account Number
	--      By Account Group Name

	-- Data Level Security
	v_IDS := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_SELECT_ENT, EC.ED_ACCOUNT);

	-- Set the Search Option Name which is used in the Colummn Display Formula of
	-- the SEARCH_NAME column in the Numerous Find results grid.
    p_SEARCH_OPTION_NAME := GET_ACCOUNT_SEARCH_OPTION_NAME(p_SEARCH_OPTION);

	-- Normal Search
	IF p_SEARCH_TYPE IS NULL OR p_SEARCH_TYPE = CONSTANTS.SEARCH_TYPE_NORMAL THEN
		-- Return all records (no LIKE clause)
		-- We still return the SEARCH_NAME column in case this is a '%' in the Find Dialog.
		IF p_SEARCH_STRING = '%' OR p_SEARCH_STRING IS NULL THEN
			IF p_SEARCH_OPTION IS NULL OR p_SEARCH_OPTION = 'By Name' OR p_SEARCH_OPTION = 'By Alias' OR p_SEARCH_OPTION = 'By Display Name' OR
			   p_SEARCH_OPTION = 'By External Identifier' THEN
				OPEN p_CURSOR FOR
					SELECT CASE p_SEARCH_OPTION
							   WHEN 'By Alias' THEN
								A.ACCOUNT_ALIAS
							   WHEN 'By Display Name' THEN
								A.ACCOUNT_DISPLAY_NAME
							   WHEN 'By External Identifier' THEN
								A.ACCOUNT_EXTERNAL_IDENTIFIER
							   ELSE
								NULL
						   END AS SEARCH_NAME,
						   A.ACCOUNT_ID,
						   A.ACCOUNT_NAME,
						   A.ACCOUNT_MODEL_OPTION,
						   A.MODEL_ID,
                           A.IS_SUB_AGGREGATE
					FROM ACCOUNT A, TABLE(CAST(v_IDS AS ID_TABLE)) X
					WHERE X.ID IN (A.ACCOUNT_ID, SD.g_ALL_DATA_ENTITY_ID)
						AND (A.ACCOUNT_ID != 0)
						AND (A.ACCOUNT_MODEL_OPTION = p_ACCOUNT_MODEL_OPTION OR
								NVL(p_ACCOUNT_MODEL_OPTION, CONSTANTS.ALL_STRING) = CONSTANTS.ALL_STRING)
					ORDER BY SEARCH_NAME, ACCOUNT_NAME;
			ELSIF p_SEARCH_OPTION = 'By EDC Account Number' THEN
				OPEN p_CURSOR FOR
					SELECT DISTINCT B.EDC_ACCOUNT_NUMBER AS SEARCH_NAME,
									A.ACCOUNT_ID,
									A.ACCOUNT_NAME,
									A.ACCOUNT_MODEL_OPTION,
						   			A.MODEL_ID,
                                    A.IS_SUB_AGGREGATE
					FROM ACCOUNT A, TABLE(CAST(v_IDS AS ID_TABLE)) X, ACCOUNT_EDC B
					WHERE X.ID IN (A.ACCOUNT_ID, SD.g_ALL_DATA_ENTITY_ID)
						  AND A.ACCOUNT_ID = B.ACCOUNT_ID
						  AND (A.ACCOUNT_MODEL_OPTION = p_ACCOUNT_MODEL_OPTION OR
								NVL(p_ACCOUNT_MODEL_OPTION, CONSTANTS.ALL_STRING) = CONSTANTS.ALL_STRING)
					ORDER BY SEARCH_NAME;
			ELSIF p_SEARCH_OPTION = 'By ESP Account Number' THEN
				OPEN p_CURSOR FOR
					SELECT DISTINCT B.ESP_ACCOUNT_NUMBER AS SEARCH_NAME,
									A.ACCOUNT_ID,
									A.ACCOUNT_NAME,
									A.ACCOUNT_MODEL_OPTION,
						   			A.MODEL_ID,
                                    A.IS_SUB_AGGREGATE
					FROM ACCOUNT A, TABLE(CAST(v_IDS AS ID_TABLE)) X, ACCOUNT_ESP B
					WHERE X.ID IN (A.ACCOUNT_ID, SD.g_ALL_DATA_ENTITY_ID)
						  AND A.ACCOUNT_ID = B.ACCOUNT_ID
     					  AND (A.ACCOUNT_MODEL_OPTION = p_ACCOUNT_MODEL_OPTION OR
								NVL(p_ACCOUNT_MODEL_OPTION, CONSTANTS.ALL_STRING) = CONSTANTS.ALL_STRING)
					ORDER BY SEARCH_NAME;
			ELSIF p_SEARCH_OPTION = 'By Account Group Name' THEN
				OPEN p_CURSOR FOR
					SELECT DISTINCT C.ACCOUNT_GROUP_NAME AS SEARCH_NAME,
									A.ACCOUNT_ID,
									A.ACCOUNT_NAME,
									A.ACCOUNT_MODEL_OPTION,
						   			A.MODEL_ID,
                                    A.IS_SUB_AGGREGATE
					FROM ACCOUNT A, TABLE(CAST(v_IDS AS ID_TABLE)) X, ACCOUNT_GROUP_ASSIGNMENT B, ACCOUNT_GROUP C
					WHERE X.ID IN (A.ACCOUNT_ID, SD.g_ALL_DATA_ENTITY_ID)
						  AND A.ACCOUNT_ID = B.ACCOUNT_ID
						  AND B.ACCOUNT_GROUP_ID = C.ACCOUNT_GROUP_ID
			              AND (A.ACCOUNT_MODEL_OPTION = p_ACCOUNT_MODEL_OPTION OR
								NVL(p_ACCOUNT_MODEL_OPTION, CONSTANTS.ALL_STRING) = CONSTANTS.ALL_STRING)
					ORDER BY SEARCH_NAME;
			END IF;
		ELSE
			IF p_SEARCH_OPTION IS NULL OR p_SEARCH_OPTION = 'By Name' OR p_SEARCH_OPTION = 'By Alias' OR p_SEARCH_OPTION = 'By Display Name' OR
			   p_SEARCH_OPTION = 'By External Identifier' THEN
				OPEN p_CURSOR FOR
					SELECT CASE p_SEARCH_OPTION
							   WHEN 'By Alias' THEN
								A.ACCOUNT_ALIAS
							   WHEN 'By Display Name' THEN
								A.ACCOUNT_DISPLAY_NAME
							   WHEN 'By External Identifier' THEN
								A.ACCOUNT_EXTERNAL_IDENTIFIER
							   ELSE
								NULL
						   END AS SEARCH_NAME,
						   A.ACCOUNT_ID,
						   A.ACCOUNT_NAME,
						   A.ACCOUNT_MODEL_OPTION,
						   A.MODEL_ID,
                           A.IS_SUB_AGGREGATE
					FROM ACCOUNT A, TABLE(CAST(v_IDS AS ID_TABLE)) X
					WHERE X.ID IN (A.ACCOUNT_ID, SD.g_ALL_DATA_ENTITY_ID)
						  AND ((p_SEARCH_OPTION = 'By Name' AND A.ACCOUNT_NAME LIKE p_SEARCH_STRING) OR
						  (p_SEARCH_OPTION = 'By Alias' AND A.ACCOUNT_ALIAS LIKE p_SEARCH_STRING) OR
						  (p_SEARCH_OPTION = 'By Display Name' AND A.ACCOUNT_DISPLAY_NAME LIKE p_SEARCH_STRING) OR
						  (p_SEARCH_OPTION = 'By External Identifier' AND
						  A.ACCOUNT_EXTERNAL_IDENTIFIER LIKE p_SEARCH_STRING))
						  AND (A.ACCOUNT_ID != 0)
						  AND (A.ACCOUNT_MODEL_OPTION = p_ACCOUNT_MODEL_OPTION OR
								NVL(p_ACCOUNT_MODEL_OPTION, CONSTANTS.ALL_STRING) = CONSTANTS.ALL_STRING)
					ORDER BY SEARCH_NAME, ACCOUNT_NAME;
			ELSIF p_SEARCH_OPTION = 'By ESP Account Number' THEN
				OPEN p_CURSOR FOR
					SELECT DISTINCT B.ESP_ACCOUNT_NUMBER AS SEARCH_NAME,
									A.ACCOUNT_ID,
									A.ACCOUNT_NAME,
									A.ACCOUNT_MODEL_OPTION,
						   			A.MODEL_ID,
                                    A.IS_SUB_AGGREGATE
					FROM ACCOUNT A, TABLE(CAST(v_IDS AS ID_TABLE)) X, ACCOUNT_ESP B
					WHERE X.ID IN (A.ACCOUNT_ID, SD.g_ALL_DATA_ENTITY_ID)
						  AND A.ACCOUNT_ID = B.ACCOUNT_ID
						  AND B.ESP_ACCOUNT_NUMBER LIKE p_SEARCH_STRING
						  AND (A.ACCOUNT_MODEL_OPTION = p_ACCOUNT_MODEL_OPTION OR
								NVL(p_ACCOUNT_MODEL_OPTION, CONSTANTS.ALL_STRING) = CONSTANTS.ALL_STRING)
					ORDER BY SEARCH_NAME;
			ELSIF p_SEARCH_OPTION = 'By EDC Account Number' THEN
				OPEN p_CURSOR FOR
					SELECT DISTINCT B.EDC_ACCOUNT_NUMBER AS SEARCH_NAME,
									A.ACCOUNT_ID,
									A.ACCOUNT_NAME,
									A.ACCOUNT_MODEL_OPTION,
						   			A.MODEL_ID,
                                    A.IS_SUB_AGGREGATE
					FROM ACCOUNT A, TABLE(CAST(v_IDS AS ID_TABLE)) X, ACCOUNT_EDC B
					WHERE X.ID IN (A.ACCOUNT_ID, SD.g_ALL_DATA_ENTITY_ID)
						  AND A.ACCOUNT_ID = B.ACCOUNT_ID
						  AND B.EDC_ACCOUNT_NUMBER LIKE p_SEARCH_STRING
						  AND (A.ACCOUNT_MODEL_OPTION = p_ACCOUNT_MODEL_OPTION OR
								NVL(p_ACCOUNT_MODEL_OPTION, CONSTANTS.ALL_STRING) = CONSTANTS.ALL_STRING)
					ORDER BY SEARCH_NAME;
			ELSIF p_SEARCH_OPTION = 'By Account Group Name' THEN
				OPEN p_CURSOR FOR
					SELECT DISTINCT C.ACCOUNT_GROUP_NAME AS SEARCH_NAME,
									A.ACCOUNT_ID,
									A.ACCOUNT_NAME,
									A.ACCOUNT_MODEL_OPTION,
						   			A.MODEL_ID,
                                    A.IS_SUB_AGGREGATE
					FROM ACCOUNT A, TABLE(CAST(v_IDS AS ID_TABLE)) X, ACCOUNT_GROUP_ASSIGNMENT B, ACCOUNT_GROUP C
					WHERE X.ID IN (A.ACCOUNT_ID, SD.g_ALL_DATA_ENTITY_ID)
						  AND A.ACCOUNT_ID = B.ACCOUNT_ID
						  AND B.ACCOUNT_GROUP_ID = C.ACCOUNT_GROUP_ID
						  AND C.ACCOUNT_GROUP_NAME LIKE p_SEARCH_STRING
						  AND (A.ACCOUNT_MODEL_OPTION = p_ACCOUNT_MODEL_OPTION OR
								NVL(p_ACCOUNT_MODEL_OPTION, CONSTANTS.ALL_STRING) = CONSTANTS.ALL_STRING)
					ORDER BY SEARCH_NAME;
			END IF;
		END IF;
	-- Specific Value
	ELSIF p_SEARCH_TYPE = CONSTANTS.SEARCH_TYPE_BY_VAL THEN
		v_ACCT_IS_ALLOWED := SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_FIND_ACCOUNT_ID, EC.ED_ACCOUNT);
		IF v_ACCT_IS_ALLOWED THEN
			OPEN p_CURSOR FOR
				SELECT A.ACCOUNT_ID, A.ACCOUNT_NAME, A.ACCOUNT_MODEL_OPTION, A.MODEL_ID, A.IS_SUB_AGGREGATE
				FROM ACCOUNT A
				WHERE A.ACCOUNT_ID = p_FIND_ACCOUNT_ID;
		ELSE
			OPEN p_CURSOR FOR
				SELECT NULL FROM DUAL;
		END IF;
	END IF;

END ACCOUNT_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT
	(
	O_OID                          OUT NUMBER,
	p_ACCOUNT_NAME                 IN VARCHAR2,
	p_ACCOUNT_ALIAS                IN VARCHAR2,
	p_ACCOUNT_DESC                 IN VARCHAR2,
	p_ACCOUNT_ID                   IN NUMBER,
	p_ACCOUNT_DUNS_NUMBER          IN VARCHAR2,
	p_ACCOUNT_EXTERNAL_IDENTIFIER  IN VARCHAR2,
	p_ACCOUNT_MODEL_OPTION         IN VARCHAR2,
	p_ACCOUNT_SIC_CODE             IN VARCHAR2,
	p_ACCOUNT_METER_TYPE           IN VARCHAR2,
	p_ACCOUNT_METER_EXT_IDENTIFIER IN VARCHAR2,
	p_ACCOUNT_DISPLAY_NAME         IN VARCHAR2,
	p_ACCOUNT_BILL_OPTION          IN VARCHAR2,
	p_ACCOUNT_ROLLUP_ID            IN NUMBER,
	p_IS_EXTERNAL_INTERVAL_USAGE   IN NUMBER,
	p_IS_EXTERNAL_BILLED_USAGE     IN NUMBER,
	p_IS_AGGREGATE_ACCOUNT         IN NUMBER,
	p_IS_UFE_PARTICIPANT           IN NUMBER,
	p_IS_CREATE_SETTLEMENT_PROFILE IN NUMBER,
	p_IS_EXTERNAL_FORECAST         IN NUMBER,
    p_IS_SUB_AGGREGATE             IN NUMBER,
	p_TX_SERVICE_TYPE_ID           IN NUMBER,
	p_USE_TOU_USAGE_FACTOR         IN NUMBER,
	p_MODEL_ID					   IN NUMBER
	) AS
BEGIN

	IO.PUT_ACCOUNT(O_OID,
				   p_ACCOUNT_NAME,
				   p_ACCOUNT_ALIAS,
				   p_ACCOUNT_DESC,
				   p_ACCOUNT_ID,
				   p_ACCOUNT_DUNS_NUMBER,
				   p_ACCOUNT_EXTERNAL_IDENTIFIER,
				   p_ACCOUNT_MODEL_OPTION,
				   p_ACCOUNT_SIC_CODE,
				   p_ACCOUNT_METER_TYPE,
				   p_ACCOUNT_METER_EXT_IDENTIFIER,
				   p_ACCOUNT_DISPLAY_NAME,
				   p_ACCOUNT_BILL_OPTION,
				   p_ACCOUNT_ROLLUP_ID,
				   p_IS_EXTERNAL_INTERVAL_USAGE,
				   p_IS_EXTERNAL_BILLED_USAGE,
				   p_IS_AGGREGATE_ACCOUNT,
				   p_IS_UFE_PARTICIPANT,
				   p_IS_CREATE_SETTLEMENT_PROFILE,
				   p_IS_EXTERNAL_FORECAST,
                   CASE WHEN p_ACCOUNT_MODEL_OPTION =
                    ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_AGGREGATE THEN
                    0 -- AGGREGATE ACCOUNTS CANNOT BE SUB AGGREGRATE
                   ELSE p_IS_SUB_AGGREGATE END,
				   p_TX_SERVICE_TYPE_ID,
				   p_USE_TOU_USAGE_FACTOR,
				   p_MODEL_ID);

END PUT_ACCOUNT;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SERVICE_LOCATION
	(
	p_ACCOUNT_ID               IN NUMBER,
	p_SERVICE_LOCATION_ID      IN NUMBER,
	p_OLD_SL_BEGIN_DATE        IN DATE,
	p_SERVICE_LOCATION_NAME    OUT VARCHAR2,
	p_SERVICE_LOCATION_ALIAS   OUT VARCHAR2,
	p_SERVICE_LOCATION_DESC    OUT VARCHAR2,
	p_LATITUDE                 OUT VARCHAR2,
	p_LONGITUDE                OUT VARCHAR2,
	p_TIME_ZONE                OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER      OUT VARCHAR2,
	p_IS_EXTERNAL_BILLED_USAGE OUT NUMBER,
	p_IS_METER_ALLOCATION      OUT NUMBER,
	p_SERVICE_POINT_ID         OUT NUMBER,
	p_SERVICE_POINT_DISP       OUT VARCHAR2,
	p_WEATHER_STATION_ID       OUT NUMBER,
	p_WEATHER_STATION_DISP     OUT VARCHAR2,
	p_BUSINESS_ROLLUP_ID       OUT NUMBER,
	p_GEOGRAPHIC_ROLLUP_ID     OUT NUMBER,
	p_SL_BEGIN_DATE            OUT DATE,
	p_SL_END_DATE              OUT DATE,
	p_EDC_IDENTIFIER           OUT VARCHAR2,
	p_ESP_IDENTIFIER           OUT VARCHAR2,
	p_STREET                   OUT VARCHAR2,
	p_STREET2                  OUT VARCHAR2,
	p_CITY                     OUT VARCHAR2,
	p_STATE_CODE               OUT VARCHAR2,
	p_POSTAL_CODE              OUT VARCHAR2,
	p_COUNTRY_CODE             OUT VARCHAR2,
	p_SQUARE_FOOTAGE           OUT NUMBER,
	p_ANNUAL_CONSUMPTION       OUT NUMBER,
	p_SUMMER_CONSUMPTION       OUT NUMBER,
	p_SERVICE_ZONE_ID          OUT NUMBER,
	p_SERVICE_ZONE_DISP        OUT VARCHAR2,
	p_SUB_STATION_ID           OUT NUMBER,
	p_SUB_STATION_DISP         OUT VARCHAR2,
	p_FEEDER_ID                OUT NUMBER,
	p_FEEDER_DISP              OUT VARCHAR2,
	p_FEEDER_SEGMENT_ID        OUT NUMBER,
	p_FEEDER_SEGMENT_DISP      OUT VARCHAR2
	) AS
BEGIN

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	IO.GET_SERVICE_LOCATION(p_SERVICE_LOCATION_ID,
							p_SERVICE_LOCATION_NAME,
							p_SERVICE_LOCATION_ALIAS,
							p_SERVICE_LOCATION_DESC,
							p_LATITUDE,
							p_LONGITUDE,
							p_TIME_ZONE,
							p_EXTERNAL_IDENTIFIER,
							p_IS_EXTERNAL_BILLED_USAGE,
							p_IS_METER_ALLOCATION,
							p_SERVICE_POINT_ID,
							p_WEATHER_STATION_ID,
							p_BUSINESS_ROLLUP_ID,
							p_GEOGRAPHIC_ROLLUP_ID,
							p_SQUARE_FOOTAGE,
							p_ANNUAL_CONSUMPTION,
							p_SUMMER_CONSUMPTION,
							p_SERVICE_ZONE_ID,
							p_SUB_STATION_ID,
							p_FEEDER_ID,
							p_FEEDER_SEGMENT_ID);

	IF p_FEEDER_SEGMENT_ID IS NOT NULL THEN
        p_FEEDER_SEGMENT_DISP := ENTITY_NAME_FROM_IDS(EC.ED_TX_FEEDER_SEGMENT,
                p_FEEDER_SEGMENT_ID );
	ELSE
		p_FEEDER_SEGMENT_DISP := CONSTANTS.NOT_ASSIGNED_STRING;
    END IF;

	IF p_FEEDER_ID IS NOT NULL THEN
        p_FEEDER_DISP := ENTITY_NAME_FROM_IDS(EC.ED_TX_FEEDER,
                p_FEEDER_ID );
	ELSE
		p_FEEDER_DISP := CONSTANTS.NOT_ASSIGNED_STRING;
    END IF;

	IF p_SUB_STATION_ID IS NOT NULL THEN
        p_SUB_STATION_DISP := ENTITY_NAME_FROM_IDS(EC.ED_SUB_STATION,
                p_SUB_STATION_ID );
	ELSE
		p_SUB_STATION_DISP := CONSTANTS.NOT_ASSIGNED_STRING;
    END IF;

	IF p_SERVICE_POINT_ID IS NOT NULL THEN
        p_SERVICE_POINT_DISP := ENTITY_NAME_FROM_IDS(EC.ED_SERVICE_POINT,
                p_SERVICE_POINT_ID );
	ELSE
		p_SERVICE_POINT_DISP := CONSTANTS.NOT_ASSIGNED_STRING;
    END IF;

	IF p_SERVICE_ZONE_ID IS NOT NULL THEN
        p_SERVICE_ZONE_DISP := ENTITY_NAME_FROM_IDS(EC.ED_SERVICE_ZONE,
                p_SERVICE_ZONE_ID );
	ELSE
		p_SERVICE_ZONE_DISP := CONSTANTS.NOT_ASSIGNED_STRING;
    END IF;

	IF p_WEATHER_STATION_ID IS NOT NULL THEN
        p_WEATHER_STATION_DISP := ENTITY_NAME_FROM_IDS(EC.ED_WEATHER_STATION,
                p_WEATHER_STATION_ID );
    END IF;

	SELECT A.BEGIN_DATE, A.END_DATE,
		A.EDC_IDENTIFIER, A.ESP_IDENTIFIER
	INTO p_SL_BEGIN_DATE, p_SL_END_DATE, p_EDC_IDENTIFIER, p_ESP_IDENTIFIER
	FROM ACCOUNT_SERVICE_LOCATION A
	WHERE A.ACCOUNT_ID = p_ACCOUNT_ID
		AND SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
		AND BEGIN_DATE = p_OLD_SL_BEGIN_DATE;

	BEGIN
		SELECT A.STREET, A.STREET2, A.CITY, A.STATE_CODE, A.POSTAL_CODE, A.COUNTRY_CODE
		INTO p_STREET, p_STREET2, p_CITY, p_STATE_CODE, p_POSTAL_CODE, p_COUNTRY_CODE
		FROM ADDRESS_INFO A
		WHERE A.CATEGORY_ID = c_LOCALE_CATEGORY
			AND A.ENTITY_DOMAIN_ID = EC.ED_SERVICE_LOCATION
			AND A.OWNER_ENTITY_ID = P_SERVICE_LOCATION_ID;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			SELECT NULL, NULL, NULL, NULL, NULL, NULL
			INTO p_STREET, p_STREET2, p_CITY, p_STATE_CODE, p_POSTAL_CODE, p_COUNTRY_CODE
			FROM DUAL;
	END;

END GET_SERVICE_LOCATION;
----------------------------------------------------------------------------------------------------
-- AS PART OF THE ACCOUNT MANAGEMENT UPDATE FOR SMART GRID. RIGHT NOW, IO.PUT_SERVICE_LOCATION
-- PROCEDURE IS BEEN CALLED WITH THESE COLUMNS SET TO NULL JUST AS A TEMPORARY FIX
PROCEDURE PUT_SERVICE_LOCATION
	(
	O_OID                      OUT NUMBER,
	p_ACCOUNT_ID               IN NUMBER,
	p_OLD_SL_BEGIN_DATE        IN DATE,
	p_SL_BEGIN_DATE            IN DATE,
	p_SL_END_DATE              IN DATE,
	p_EDC_IDENTIFIER           IN VARCHAR2,
	p_ESP_IDENTIFIER           IN VARCHAR2,
	p_SERVICE_LOCATION_NAME    IN VARCHAR2,
	p_SERVICE_LOCATION_ALIAS   IN VARCHAR2,
	p_SERVICE_LOCATION_DESC    IN VARCHAR2,
	p_SERVICE_LOCATION_ID      IN NUMBER,
	p_LATITUDE                 IN VARCHAR2,
	p_LONGITUDE                IN VARCHAR2,
	p_TIME_ZONE                IN VARCHAR2,
	p_EXTERNAL_IDENTIFIER      IN VARCHAR2,
	p_SERVICE_POINT_ID         IN NUMBER,
	p_WEATHER_STATION_ID       IN NUMBER,
	p_STREET                   IN VARCHAR2,
	p_STREET2                  IN VARCHAR2,
	p_CITY                     IN VARCHAR2,
	p_STATE_CODE               IN VARCHAR2,
	p_POSTAL_CODE              IN VARCHAR2,
	p_COUNTRY_CODE             IN VARCHAR2,
	p_SQUARE_FOOTAGE           IN NUMBER,
	p_ANNUAL_CONSUMPTION       IN NUMBER,
	p_SUMMER_CONSUMPTION       IN NUMBER,
	p_SERVICE_ZONE_ID          IN NUMBER,
	p_SUB_STATION_ID           IN NUMBER,
	p_FEEDER_ID                IN NUMBER,
	p_FEEDER_SEGMENT_ID        IN NUMBER,
	p_MESSAGE				   OUT VARCHAR2
	) AS

	v_SERVICE_ZONE_ID NUMBER(9);
	v_SUB_STATION_ID NUMBER(9);
	v_FEEDER_ID NUMBER(9);
	v_FEEDER_SEGMENT_ID NUMBER(9);

	v_PRIOR_SUB_STATION_ID NUMBER(9);
	v_PRIOR_FEEDER_ID NUMBER(9);
	v_PRIOR_FEEDER_SEGMENT_ID NUMBER(9);

BEGIN

	IF (NVL(p_SQUARE_FOOTAGE, 0) < 0) THEN
		ERRS.RAISE(MSGCODES.c_ERR_ARGUMENT, 'Please enter a non-negative number for Square Footage.');
	ELSIF (NVL(p_ANNUAL_CONSUMPTION, 0) < 0) THEN
		ERRS.RAISE(MSGCODES.c_ERR_ARGUMENT, 'Please enter a non-negative number for Annual Consumption.');
	ELSIF (NVL(p_SUMMER_CONSUMPTION, 0) < 0) THEN
		ERRS.RAISE(MSGCODES.c_ERR_ARGUMENT, 'Please enter a non-negative number for Summer Consumption.');
	END IF;

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	IF NVL(p_SERVICE_LOCATION_ID, CONSTANTS.NOT_ASSIGNED) <> 0 THEN

		SELECT NVL(SL.SUB_STATION_ID, CONSTANTS.NOT_ASSIGNED), NVL(SL.FEEDER_ID, CONSTANTS.NOT_ASSIGNED),
			NVL(SL.FEEDER_SEGMENT_ID, CONSTANTS.NOT_ASSIGNED)
		INTO v_PRIOR_SUB_STATION_ID, v_PRIOR_FEEDER_ID, v_PRIOR_FEEDER_SEGMENT_ID
		FROM SERVICE_LOCATION SL
		WHERE SL.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID;

	END IF;

	IO.PUT_SERVICE_LOCATION(O_OID,
							p_SERVICE_LOCATION_NAME,
							p_SERVICE_LOCATION_ALIAS,
							p_SERVICE_LOCATION_DESC,
							p_SERVICE_LOCATION_ID,
							p_LATITUDE,
							p_LONGITUDE,
							p_TIME_ZONE,
							p_EXTERNAL_IDENTIFIER,
							NULL,
							NULL,
							p_SERVICE_POINT_ID,
							p_WEATHER_STATION_ID,
							NULL,
							NULL,
							p_SQUARE_FOOTAGE,
							p_ANNUAL_CONSUMPTION,
							p_SUMMER_CONSUMPTION,
							p_SERVICE_ZONE_ID,
							p_SUB_STATION_ID,
							p_FEEDER_ID,
							p_FEEDER_SEGMENT_ID);

	EM.PUT_ENTITY_DOMAIN_ADDRESS(EC.ED_SERVICE_LOCATION,
    							O_OID,
    							c_LOCALE_CATEGORY,
								p_STREET,
								p_STREET2,
								p_CITY,
								p_STATE_CODE,
								p_POSTAL_CODE,
								p_COUNTRY_CODE,
    							c_LOCALE_CATEGORY);

	UT.PUT_TEMPORAL_DATA_UI('ACCOUNT_SERVICE_LOCATION',
							p_SL_BEGIN_DATE,
							p_SL_END_DATE,
							p_OLD_SL_BEGIN_DATE,
							TRUE,
							'ACCOUNT_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
							UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
							TRUE,
							'SERVICE_LOCATION_ID',
							UT.GET_LITERAL_FOR_NUMBER(O_OID),
							UT.GET_LITERAL_FOR_NUMBER(p_SERVICE_LOCATION_ID),
							TRUE,
							'EDC_IDENTIFIER',
							UT.GET_LITERAL_FOR_STRING(p_EDC_IDENTIFIER),
							NULL,
							FALSE,
							'ESP_IDENTIFIER',
							UT.GET_LITERAL_FOR_STRING(p_ESP_IDENTIFIER),
							NULL,
							FALSE);

	SELECT SL.SERVICE_ZONE_ID, SL.SUB_STATION_ID, SL.FEEDER_ID, SL.FEEDER_SEGMENT_ID
	INTO v_SERVICE_ZONE_ID, v_SUB_STATION_ID, v_FEEDER_ID, v_FEEDER_SEGMENT_ID
	FROM SERVICE_LOCATION SL
	WHERE SL.SERVICE_LOCATION_ID = O_OID;

	IF p_SERVICE_LOCATION_ID <> 0 AND
		((v_SERVICE_ZONE_ID <> p_SERVICE_ZONE_ID AND (v_PRIOR_SUB_STATION_ID = v_SUB_STATION_ID) )
		OR (v_SUB_STATION_ID <> p_SUB_STATION_ID AND (v_PRIOR_FEEDER_ID = v_FEEDER_ID) )
		OR (v_FEEDER_ID <> p_FEEDER_ID AND v_PRIOR_FEEDER_SEGMENT_ID = v_FEEDER_SEGMENT_ID)) THEN
			p_MESSAGE := 'In order to change a higher-level assignment to the transmission '
				|| 'network, you must first set the lower levels to "Not Assigned."';
	END IF;

END PUT_SERVICE_LOCATION;
----------------------------------------------------------------------------------------------------
PROCEDURE SL_SERVICE_POINT_LIST
	(
	p_SERVICE_ZONE_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN

	IF NVL(p_SERVICE_ZONE_ID, CONSTANTS.NOT_ASSIGNED) != CONSTANTS.NOT_ASSIGNED THEN
		OPEN p_CURSOR FOR
			SELECT SERVICE_POINT_NAME, SERVICE_POINT_ID
			FROM SERVICE_POINT
			WHERE SERVICE_ZONE_ID = p_SERVICE_ZONE_ID
			UNION ALL
			SELECT CONSTANTS.NOT_ASSIGNED_STRING,
				CONSTANTS.NOT_ASSIGNED
			FROM DUAL
			ORDER BY 1;
	ELSE
		OPEN p_CURSOR FOR
			SELECT SERVICE_POINT_NAME, SERVICE_POINT_ID
			FROM SERVICE_POINT
			ORDER BY 1;
	END IF;

END SL_SERVICE_POINT_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE SL_SUB_STATION_LIST
	(
	p_SERVICE_ZONE_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN

	IF NVL(p_SERVICE_ZONE_ID, CONSTANTS.NOT_ASSIGNED) != CONSTANTS.NOT_ASSIGNED THEN
		OPEN p_CURSOR FOR
			SELECT SUB_STATION_NAME, SUB_STATION_ID
			FROM TX_SUB_STATION
			WHERE SERVICE_ZONE_ID = p_SERVICE_ZONE_ID
			UNION ALL
			SELECT CONSTANTS.NOT_ASSIGNED_STRING,
				CONSTANTS.NOT_ASSIGNED
			FROM DUAL
			ORDER BY 1;
	ELSIF NVL(p_SERVICE_POINT_ID, CONSTANTS.NOT_ASSIGNED) != CONSTANTS.NOT_ASSIGNED THEN
		OPEN p_CURSOR FOR
			SELECT TSS.SUB_STATION_NAME, TSS.SUB_STATION_ID
			FROM TX_SUB_STATION TSS, SERVICE_POINT SP
			WHERE TSS.SERVICE_ZONE_ID = SP.SERVICE_ZONE_ID
				AND SP.SERVICE_POINT_ID = p_SERVICE_POINT_ID
			UNION ALL
			SELECT CONSTANTS.NOT_ASSIGNED_STRING,
				CONSTANTS.NOT_ASSIGNED
			FROM DUAL
			ORDER BY 1;
	ELSE
		OPEN p_CURSOR FOR
			SELECT SUB_STATION_NAME, SUB_STATION_ID
			FROM TX_SUB_STATION
			ORDER BY 1;
	END IF;

END SL_SUB_STATION_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE SL_FEEDER_LIST
	(
	p_SERVICE_ZONE_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_SUB_STATION_ID IN NUMBER,
	p_SEARCH_STRING IN VARCHAR,
	p_SEARCH_OPTION IN VARCHAR,
	p_SEARCH_TYPE IN NUMBER,
	p_FIND_VALUE IN VARCHAR2,
	p_INCLUDE_INACTIVE IN NUMBER,
    p_HIDE_NOT_ASSIGNED IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
	v_SEARCH_STRING VARCHAR2(32767);
BEGIN

	IF p_SEARCH_STRING IS NULL THEN
		v_SEARCH_STRING := '%';
	ELSE
		v_SEARCH_STRING := p_SEARCH_STRING;
	END IF;

	-- Normal Search
	IF p_SEARCH_TYPE IS NULL OR p_SEARCH_TYPE = CONSTANTS.SEARCH_TYPE_NORMAL THEN
		IF NVL(p_SUB_STATION_ID, CONSTANTS.NOT_ASSIGNED) != CONSTANTS.NOT_ASSIGNED THEN
			OPEN p_CURSOR FOR
				SELECT TF.FEEDER_NAME,
					TF.FEEDER_ID,
					TF.FEEDER_ALIAS,
					TF.EXTERNAL_IDENTIFIER
				FROM TX_FEEDER TF
				WHERE (TF.SUB_STATION_ID = p_SUB_STATION_ID)
					AND ((p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_NAME AND TF.FEEDER_NAME LIKE v_SEARCH_STRING) OR
						(p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_ALIAS AND TF.FEEDER_ALIAS LIKE v_SEARCH_STRING) OR
						(p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_EXT_IDENT AND TF.EXTERNAL_IDENTIFIER LIKE v_SEARCH_STRING) OR
						(p_SEARCH_OPTION IS NULL))
				UNION ALL
				SELECT CONSTANTS.NOT_ASSIGNED_STRING,
					CONSTANTS.NOT_ASSIGNED,
					CONSTANTS.UNDEFINED_ATTRIBUTE,
					CONSTANTS.UNDEFINED_ATTRIBUTE
				FROM DUAL
				WHERE NVL(p_HIDE_NOT_ASSIGNED,0) = 0
				ORDER BY 1;
		ELSIF NVL(p_SERVICE_ZONE_ID, CONSTANTS.NOT_ASSIGNED) != CONSTANTS.NOT_ASSIGNED THEN
			OPEN p_CURSOR FOR
				SELECT TF.FEEDER_NAME,
					TF.FEEDER_ID,
					TF.FEEDER_ALIAS,
					TF.EXTERNAL_IDENTIFIER
				FROM TX_FEEDER TF, TX_SUB_STATION TSS
				WHERE (TF.SUB_STATION_ID = TSS.SUB_STATION_ID
							AND TSS.SERVICE_ZONE_ID = p_SERVICE_ZONE_ID)
					AND ((p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_NAME AND TF.FEEDER_NAME LIKE v_SEARCH_STRING) OR
						(p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_ALIAS AND TF.FEEDER_ALIAS LIKE v_SEARCH_STRING) OR
						(p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_EXT_IDENT AND TF.EXTERNAL_IDENTIFIER LIKE v_SEARCH_STRING) OR
						(p_SEARCH_OPTION IS NULL))
				UNION ALL
				SELECT CONSTANTS.NOT_ASSIGNED_STRING,
					CONSTANTS.NOT_ASSIGNED,
					CONSTANTS.UNDEFINED_ATTRIBUTE,
					CONSTANTS.UNDEFINED_ATTRIBUTE
				FROM DUAL
				WHERE NVL(p_HIDE_NOT_ASSIGNED,0) = 0
				ORDER BY 1;
		ELSIF NVL(p_SERVICE_POINT_ID, CONSTANTS.NOT_ASSIGNED) != CONSTANTS.NOT_ASSIGNED THEN
			OPEN p_CURSOR FOR
				SELECT TF.FEEDER_NAME,
					TF.FEEDER_ID,
					TF.FEEDER_ALIAS,
					TF.EXTERNAL_IDENTIFIER
				FROM TX_FEEDER TF, TX_SUB_STATION TSS, SERVICE_POINT SP
				WHERE (TF.SUB_STATION_ID = TSS.SUB_STATION_ID
							AND TSS.SERVICE_ZONE_ID = SP.SERVICE_ZONE_ID
							AND SP.SERVICE_POINT_ID = p_SERVICE_POINT_ID)
					AND ((p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_NAME AND TF.FEEDER_NAME LIKE v_SEARCH_STRING) OR
						(p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_ALIAS AND TF.FEEDER_ALIAS LIKE v_SEARCH_STRING) OR
						(p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_EXT_IDENT AND TF.EXTERNAL_IDENTIFIER LIKE v_SEARCH_STRING) OR
						(p_SEARCH_OPTION IS NULL))
				UNION ALL
				SELECT CONSTANTS.NOT_ASSIGNED_STRING,
					CONSTANTS.NOT_ASSIGNED,
					CONSTANTS.UNDEFINED_ATTRIBUTE,
					CONSTANTS.UNDEFINED_ATTRIBUTE
				FROM DUAL
				WHERE NVL(p_HIDE_NOT_ASSIGNED,0) = 0
				ORDER BY 1;
		ELSE
			OPEN p_CURSOR FOR
				SELECT TF.FEEDER_NAME,
					TF.FEEDER_ID,
					TF.FEEDER_ALIAS,
					TF.EXTERNAL_IDENTIFIER
				FROM TX_FEEDER TF
				WHERE ((p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_NAME AND TF.FEEDER_NAME LIKE v_SEARCH_STRING) OR
						(p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_ALIAS AND TF.FEEDER_ALIAS LIKE v_SEARCH_STRING) OR
						(p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_EXT_IDENT AND TF.EXTERNAL_IDENTIFIER LIKE v_SEARCH_STRING) OR
						(p_SEARCH_OPTION IS NULL))
					AND (NVL(p_HIDE_NOT_ASSIGNED,0) = 0 OR TF.FEEDER_ID <> CONSTANTS.NOT_ASSIGNED)
				ORDER BY 1;
		END IF;
	-- Specific Value
	ELSIF p_SEARCH_TYPE = CONSTANTS.SEARCH_TYPE_BY_VAL THEN
		OPEN p_CURSOR FOR
			SELECT FEEDER_ID,
				   FEEDER_NAME
			FROM TX_FEEDER
			WHERE FEEDER_ID = p_FIND_VALUE
			ORDER BY 1;
	END IF;

END SL_FEEDER_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE SL_FEEDER_SEGMENT_LIST
	(
	p_SERVICE_ZONE_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_SUB_STATION_ID IN NUMBER,
	p_FEEDER_ID IN NUMBER,
	p_SEARCH_STRING IN VARCHAR,
	p_SEARCH_OPTION IN VARCHAR,
	p_SEARCH_TYPE IN NUMBER,
	p_FIND_VALUE IN VARCHAR2,
	p_INCLUDE_INACTIVE IN NUMBER,
    p_HIDE_NOT_ASSIGNED IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
	v_SEARCH_STRING VARCHAR2(32767);
BEGIN

	IF p_SEARCH_STRING IS NULL THEN
		v_SEARCH_STRING := '%';
	ELSE
		v_SEARCH_STRING := p_SEARCH_STRING;
	END IF;

	-- Normal Search
	IF p_SEARCH_TYPE IS NULL OR p_SEARCH_TYPE = CONSTANTS.SEARCH_TYPE_NORMAL THEN
		IF NVL(p_FEEDER_ID, CONSTANTS.NOT_ASSIGNED) != CONSTANTS.NOT_ASSIGNED THEN
			OPEN p_CURSOR FOR
				SELECT TFS.FEEDER_SEGMENT_NAME,
					TFS.FEEDER_SEGMENT_ID,
					TFS.FEEDER_SEGMENT_ALIAS,
					TFS.EXTERNAL_IDENTIFIER
				FROM TX_FEEDER_SEGMENT TFS
				WHERE (TFS.FEEDER_ID = p_FEEDER_ID)
					AND ((p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_NAME AND TFS.FEEDER_SEGMENT_NAME LIKE v_SEARCH_STRING) OR
						(p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_ALIAS AND TFS.FEEDER_SEGMENT_ALIAS LIKE v_SEARCH_STRING) OR
						(p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_EXT_IDENT AND TFS.EXTERNAL_IDENTIFIER LIKE v_SEARCH_STRING) OR
						(p_SEARCH_OPTION IS NULL))
				UNION ALL
				SELECT CONSTANTS.NOT_ASSIGNED_STRING,
					CONSTANTS.NOT_ASSIGNED,
					CONSTANTS.UNDEFINED_ATTRIBUTE,
					CONSTANTS.UNDEFINED_ATTRIBUTE
				FROM DUAL
				WHERE NVL(p_HIDE_NOT_ASSIGNED,0) = 0
				ORDER BY 1;
		ELSIF NVL(p_SUB_STATION_ID, CONSTANTS.NOT_ASSIGNED) != CONSTANTS.NOT_ASSIGNED THEN
			OPEN p_CURSOR FOR
				SELECT TFS.FEEDER_SEGMENT_NAME,
					TFS.FEEDER_SEGMENT_ID,
					TFS.FEEDER_SEGMENT_ALIAS,
					TFS.EXTERNAL_IDENTIFIER
				FROM TX_FEEDER_SEGMENT TFS, TX_FEEDER TF
				WHERE (TFS.FEEDER_ID = TF.FEEDER_ID
							AND TF.SUB_STATION_ID = p_SUB_STATION_ID)
					AND ((p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_NAME AND TFS.FEEDER_SEGMENT_NAME LIKE v_SEARCH_STRING) OR
						(p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_ALIAS AND TFS.FEEDER_SEGMENT_ALIAS LIKE v_SEARCH_STRING) OR
						(p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_EXT_IDENT AND TFS.EXTERNAL_IDENTIFIER LIKE v_SEARCH_STRING) OR
						(p_SEARCH_OPTION IS NULL))
				UNION ALL
				SELECT CONSTANTS.NOT_ASSIGNED_STRING,
					CONSTANTS.NOT_ASSIGNED,
					CONSTANTS.UNDEFINED_ATTRIBUTE,
					CONSTANTS.UNDEFINED_ATTRIBUTE
				FROM DUAL
				WHERE NVL(p_HIDE_NOT_ASSIGNED,0) = 0
				ORDER BY 1;
		ELSIF NVL(p_SERVICE_ZONE_ID, CONSTANTS.NOT_ASSIGNED) != CONSTANTS.NOT_ASSIGNED THEN
			OPEN p_CURSOR FOR
				SELECT TFS.FEEDER_SEGMENT_NAME,
					TFS.FEEDER_SEGMENT_ID,
					TFS.FEEDER_SEGMENT_ALIAS,
					TFS.EXTERNAL_IDENTIFIER
				FROM TX_FEEDER_SEGMENT TFS, TX_FEEDER TF, TX_SUB_STATION TSS
				WHERE (TFS.FEEDER_ID = TF.FEEDER_ID
							AND TF.SUB_STATION_ID = TSS.SUB_STATION_ID
							AND TSS.SERVICE_ZONE_ID = p_SERVICE_ZONE_ID)
					AND ((p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_NAME AND TFS.FEEDER_SEGMENT_NAME LIKE v_SEARCH_STRING) OR
						(p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_ALIAS AND TFS.FEEDER_SEGMENT_ALIAS LIKE v_SEARCH_STRING) OR
						(p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_EXT_IDENT AND TFS.EXTERNAL_IDENTIFIER LIKE v_SEARCH_STRING) OR
						(p_SEARCH_OPTION IS NULL))
				UNION ALL
				SELECT CONSTANTS.NOT_ASSIGNED_STRING,
					CONSTANTS.NOT_ASSIGNED,
					CONSTANTS.UNDEFINED_ATTRIBUTE,
					CONSTANTS.UNDEFINED_ATTRIBUTE
				FROM DUAL
				WHERE NVL(p_HIDE_NOT_ASSIGNED,0) = 0
				ORDER BY 1;
		ELSIF NVL(p_SERVICE_POINT_ID, CONSTANTS.NOT_ASSIGNED) != CONSTANTS.NOT_ASSIGNED THEN
			OPEN p_CURSOR FOR
				SELECT TFS.FEEDER_SEGMENT_NAME,
					TFS.FEEDER_SEGMENT_ID,
					TFS.FEEDER_SEGMENT_ALIAS,
					TFS.EXTERNAL_IDENTIFIER
				FROM TX_FEEDER_SEGMENT TFS, TX_FEEDER TF, TX_SUB_STATION TSS, SERVICE_POINT SP
				WHERE (TFS.FEEDER_ID = TF.FEEDER_ID
							AND TF.SUB_STATION_ID = TSS.SUB_STATION_ID
							AND TSS.SERVICE_ZONE_ID = SP.SERVICE_ZONE_ID
							AND SP.SERVICE_POINT_ID = p_SERVICE_POINT_ID)
					AND ((p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_NAME AND TFS.FEEDER_SEGMENT_NAME LIKE v_SEARCH_STRING) OR
						(p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_ALIAS AND TFS.FEEDER_SEGMENT_ALIAS LIKE v_SEARCH_STRING) OR
						(p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_EXT_IDENT AND TFS.EXTERNAL_IDENTIFIER LIKE v_SEARCH_STRING) OR
						(p_SEARCH_OPTION IS NULL))
				UNION ALL
				SELECT CONSTANTS.NOT_ASSIGNED_STRING,
					CONSTANTS.NOT_ASSIGNED,
					CONSTANTS.UNDEFINED_ATTRIBUTE,
					CONSTANTS.UNDEFINED_ATTRIBUTE
				FROM DUAL
				WHERE NVL(p_HIDE_NOT_ASSIGNED,0) = 0
				ORDER BY 1;
		ELSE
			OPEN p_CURSOR FOR
				SELECT TFS.FEEDER_SEGMENT_NAME,
					TFS.FEEDER_SEGMENT_ID,
					TFS.FEEDER_SEGMENT_ALIAS,
					TFS.EXTERNAL_IDENTIFIER
				FROM TX_FEEDER_SEGMENT TFS
				WHERE ((p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_NAME AND TFS.FEEDER_SEGMENT_NAME LIKE v_SEARCH_STRING) OR
						(p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_ALIAS AND TFS.FEEDER_SEGMENT_ALIAS LIKE v_SEARCH_STRING) OR
						(p_SEARCH_OPTION = CONSTANTS.SEARCH_OPTION_BY_EXT_IDENT AND TFS.EXTERNAL_IDENTIFIER LIKE v_SEARCH_STRING) OR
						(p_SEARCH_OPTION IS NULL))
					AND (NVL(p_HIDE_NOT_ASSIGNED,0) = 0 OR TFS.FEEDER_SEGMENT_ID <> CONSTANTS.NOT_ASSIGNED)
				ORDER BY 1;
		END IF;
	-- Specific Value
	ELSIF p_SEARCH_TYPE = CONSTANTS.SEARCH_TYPE_BY_VAL THEN
		OPEN p_CURSOR FOR
			SELECT FEEDER_SEGMENT_NAME,
				   FEEDER_SEGMENT_ID
			FROM TX_FEEDER_SEGMENT
			WHERE FEEDER_SEGMENT_ID = p_FIND_VALUE
			ORDER BY 1;
	END IF;

END SL_FEEDER_SEGMENT_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE SERVICE_LOCATION_LIST
	(
	p_ACCOUNT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE   IN DATE,
	p_SEARCH_STRING      IN VARCHAR,
	p_SEARCH_OPTION      IN VARCHAR,
	p_SEARCH_TYPE        IN NUMBER,
	p_FIND_SERVICE_LOCATION_ID    IN NUMBER,
	p_SEARCH_OPTION_NAME OUT VARCHAR2,
	p_SEARCH_OPTION_NAME_2 OUT VARCHAR2,
	p_CURSOR     IN OUT GA.REFCURSOR
	) AS
BEGIN

	-- This procedure supports the following search options:
	--      By Name
	--      By Alias
	--      By External Identifier
	--      By EDC ID#
	--      By ESP ID#
	--		By Street Address

	-- Data Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);
	p_SEARCH_OPTION_NAME_2 := NULL;

	-- Set the Search Option Name which is used in the Colummn Display Formula of
	-- the SEARCH_NAME column in the Numerous Find results grid.
	CASE p_SEARCH_OPTION
		WHEN 'By Alias' THEN
			p_SEARCH_OPTION_NAME := 'Alias';
		WHEN 'By External Identifier' THEN
			p_SEARCH_OPTION_NAME := 'External Identifier';
		WHEN 'By EDC ID#' THEN
			p_SEARCH_OPTION_NAME := 'EDC ID#';
		WHEN 'By ESP ID#' THEN
			p_SEARCH_OPTION_NAME := 'ESP ID#';
		WHEN 'By Street Address' THEN
			p_SEARCH_OPTION_NAME := 'Street Address';
			p_SEARCH_OPTION_NAME_2 := 'Street Address 2';
		ELSE
			p_SEARCH_OPTION_NAME := 'Name';
	END CASE;

	-- Normal Search
	IF p_SEARCH_TYPE IS NULL OR p_SEARCH_TYPE = CONSTANTS.SEARCH_TYPE_NORMAL THEN
		-- Return all records (no LIKE clause)
		-- We still return the SEARCH_NAME column in case this is a '%' in the Find Dialog.
		IF p_SEARCH_STRING = '%' OR p_SEARCH_STRING IS NULL THEN
			OPEN p_CURSOR FOR
				SELECT S.SERVICE_LOCATION_ID,
					   S.SERVICE_LOCATION_NAME,
					   A.BEGIN_DATE AS SL_BEGIN_DATE,
					   A.END_DATE AS SL_END_DATE,
					   CASE p_SEARCH_OPTION
						   WHEN 'By Alias' THEN
							S.SERVICE_LOCATION_ALIAS
						   WHEN 'By External Identifier' THEN
							S.EXTERNAL_IDENTIFIER
						   WHEN 'By EDC ID#' THEN
						    A.EDC_IDENTIFIER
						   WHEN 'By ESP ID#' THEN
						   	A.ESP_IDENTIFIER
						   WHEN 'By Street Address' THEN
						    ADDR.STREET
						   ELSE
							NULL
					   END AS SEARCH_NAME,
					   CASE WHEN p_SEARCH_OPTION = 'By Street Address' THEN
					   	ADDR.STREET2
					   ELSE
					   	NULL
					   END AS SEARCH_NAME_2
				FROM ACCOUNT_SERVICE_LOCATION A, SERVICE_LOCATION S,
					ADDRESS_INFO ADDR
				WHERE A.SERVICE_LOCATION_ID = S.SERVICE_LOCATION_ID
					  AND A.ACCOUNT_ID = p_ACCOUNT_ID
					  AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					  AND A.BEGIN_DATE <= p_END_DATE
					  AND ADDR.ENTITY_DOMAIN_ID (+) = EC.ED_SERVICE_LOCATION
					  AND ADDR.CATEGORY_ID (+) = c_LOCALE_CATEGORY
					  AND ADDR.OWNER_ENTITY_ID (+) = S.SERVICE_LOCATION_ID
				ORDER BY 5,2,3,4;
		ELSE
			OPEN p_CURSOR FOR
				SELECT S.SERVICE_LOCATION_ID,
					   S.SERVICE_LOCATION_NAME,
					   A.BEGIN_DATE AS SL_BEGIN_DATE,
					   A.END_DATE AS SL_END_DATE,
					   CASE p_SEARCH_OPTION
						   WHEN 'By Alias' THEN
							S.SERVICE_LOCATION_ALIAS
						   WHEN 'By External Identifier' THEN
							S.EXTERNAL_IDENTIFIER
						   WHEN 'By EDC ID#' THEN
						    A.EDC_IDENTIFIER
						   WHEN 'By ESP ID#' THEN
						   	A.ESP_IDENTIFIER
						   WHEN 'By Street Address' THEN
						    ADDR.STREET
						   ELSE
							NULL
					   END AS SEARCH_NAME,
					   CASE WHEN p_SEARCH_OPTION = 'By Street Address' THEN
					   	ADDR.STREET2
					   ELSE
					   	NULL
					   END AS SEARCH_NAME_2
				FROM ACCOUNT_SERVICE_LOCATION A, SERVICE_LOCATION S,
					ADDRESS_INFO ADDR
				WHERE A.SERVICE_LOCATION_ID = S.SERVICE_LOCATION_ID
					  AND A.ACCOUNT_ID = p_ACCOUNT_ID
					  AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					  AND A.BEGIN_DATE <= p_END_DATE
					  AND ADDR.ENTITY_DOMAIN_ID (+) = EC.ED_SERVICE_LOCATION
					  AND ADDR.CATEGORY_ID (+) = c_LOCALE_CATEGORY
					  AND ADDR.OWNER_ENTITY_ID (+) = S.SERVICE_LOCATION_ID
					  AND ((p_SEARCH_OPTION = 'By Name' AND S.SERVICE_LOCATION_NAME LIKE p_SEARCH_STRING) OR
					  (p_SEARCH_OPTION = 'By Alias' AND S.SERVICE_LOCATION_ALIAS LIKE p_SEARCH_STRING) OR
					  (p_SEARCH_OPTION = 'By External Identifier' AND S.EXTERNAL_IDENTIFIER LIKE p_SEARCH_STRING) OR
					  (p_SEARCH_OPTION = 'By EDC ID#' AND A.EDC_IDENTIFIER LIKE p_SEARCH_STRING) OR
					  (p_SEARCH_OPTION = 'By ESP ID#' AND A.ESP_IDENTIFIER LIKE p_SEARCH_STRING) OR
					  (p_SEARCH_OPTION = 'By Street Address' AND (ADDR.STREET || ' ' || ADDR.STREET2) LIKE p_SEARCH_STRING))
				ORDER BY 5,2,3,4;
		END IF;
	-- Specific Value
	ELSIF p_SEARCH_TYPE = CONSTANTS.SEARCH_TYPE_BY_VAL THEN
		OPEN p_CURSOR FOR
			SELECT S.SERVICE_LOCATION_ID,
				   S.SERVICE_LOCATION_NAME,
				   A.BEGIN_DATE AS SL_BEGIN_DATE,
				   A.END_DATE AS SL_END_DATE
			FROM ACCOUNT_SERVICE_LOCATION A, SERVICE_LOCATION S
			WHERE A.SERVICE_LOCATION_ID = S.SERVICE_LOCATION_ID
				  AND A.ACCOUNT_ID = p_ACCOUNT_ID
				  AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
				  AND A.BEGIN_DATE <= p_END_DATE
				  AND A.SERVICE_LOCATION_ID = p_FIND_SERVICE_LOCATION_ID
			ORDER BY 2, 3, 4;
	END IF;

END SERVICE_LOCATION_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE METER_LIST
	(
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE   IN DATE,
	p_SEARCH_STRING      IN VARCHAR,
	p_SEARCH_OPTION      IN VARCHAR,
	p_SEARCH_TYPE        IN NUMBER,
	p_FIND_METER_ID    IN NUMBER,
	p_SEARCH_OPTION_NAME OUT VARCHAR2,
	p_CURSOR     IN OUT GA.REFCURSOR
	) AS
BEGIN

	-- This procedure supports the following search options:
	--      By Name
	--      By Alias
	--      By External Identifier
	--      By EDC ID#
	--      By ESP ID#

	-- Data Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_SERVICE_LOCATION_ID, EC.ED_SERVICE_LOCATION);

	-- Set the Search Option Name which is used in the Colummn Display Formula of
	-- the SEARCH_NAME column in the Numerous Find results grid.
	CASE p_SEARCH_OPTION
		WHEN 'By Alias' THEN
			p_SEARCH_OPTION_NAME := 'Alias';
		WHEN 'By External Identifier' THEN
			p_SEARCH_OPTION_NAME := 'External Identifier';
		WHEN 'By EDC ID#' THEN
			p_SEARCH_OPTION_NAME := 'EDC ID#';
		WHEN 'By ESP ID#' THEN
			p_SEARCH_OPTION_NAME := 'ESP ID#';
		ELSE
			p_SEARCH_OPTION_NAME := 'Name';
	END CASE;

	-- Normal Search
	IF p_SEARCH_TYPE IS NULL OR p_SEARCH_TYPE = CONSTANTS.SEARCH_TYPE_NORMAL THEN
		-- Return all records (no LIKE clause)
		-- We still return the SEARCH_NAME column in case this is a '%' in the Find Dialog.
		IF p_SEARCH_STRING = '%' OR p_SEARCH_STRING IS NULL THEN
			OPEN p_CURSOR FOR
				SELECT CASE p_SEARCH_OPTION
						   WHEN 'By Alias' THEN
							M.METER_ALIAS
						   WHEN 'By External Identifier' THEN
							M.METER_EXTERNAL_IDENTIFIER
						   WHEN 'By EDC ID#' THEN
						    S.EDC_IDENTIFIER
						   WHEN 'By ESP ID#' THEN
						   	S.ESP_IDENTIFIER
						   ELSE
							NULL
					   END AS SEARCH_NAME,
					   M.METER_ID,
					   M.METER_NAME,
					   S.BEGIN_DATE AS METER_BEGIN_DATE,
					   S.END_DATE AS METER_END_DATE
				FROM SERVICE_LOCATION_METER S, METER M
				WHERE S.METER_ID = M.METER_ID
					  AND S.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
					  AND NVL(S.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					  AND S.BEGIN_DATE <= p_END_DATE
				ORDER BY 1,3,4,5;
		ELSE
			OPEN p_CURSOR FOR
				SELECT CASE p_SEARCH_OPTION
						   WHEN 'By Alias' THEN
							M.METER_ALIAS
						   WHEN 'By External Identifier' THEN
							M.METER_EXTERNAL_IDENTIFIER
						   WHEN 'By EDC ID#' THEN
						    S.EDC_IDENTIFIER
						   WHEN 'By ESP ID#' THEN
						   	S.ESP_IDENTIFIER
						   ELSE
							NULL
					   END AS SEARCH_NAME,
					   M.METER_ID,
					   M.METER_NAME,
					   S.BEGIN_DATE AS METER_BEGIN_DATE,
					   S.END_DATE AS METER_END_DATE
				FROM SERVICE_LOCATION_METER S, METER M
				WHERE S.METER_ID = M.METER_ID
					  AND S.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
					  AND NVL(S.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					  AND S.BEGIN_DATE <= p_END_DATE
					  AND ((p_SEARCH_OPTION = 'By Name' AND M.METER_NAME LIKE p_SEARCH_STRING) OR
					  (p_SEARCH_OPTION = 'By Alias' AND M.METER_ALIAS LIKE p_SEARCH_STRING) OR
					  (p_SEARCH_OPTION = 'By External Identifier' AND M.METER_EXTERNAL_IDENTIFIER LIKE p_SEARCH_STRING) OR
					  (p_SEARCH_OPTION = 'By EDC ID#' AND S.EDC_IDENTIFIER LIKE p_SEARCH_STRING) OR
					  (p_SEARCH_OPTION = 'By ESP ID#' AND S.ESP_IDENTIFIER LIKE p_SEARCH_STRING))
				ORDER BY 1,3,4,5;
		END IF;
	-- Specific Value
	ELSIF p_SEARCH_TYPE = CONSTANTS.SEARCH_TYPE_BY_VAL THEN
		OPEN p_CURSOR FOR
			SELECT M.METER_ID, M.METER_NAME, S.BEGIN_DATE AS METER_BEGIN_DATE, S.END_DATE AS METER_END_DATE
			FROM SERVICE_LOCATION_METER S, METER M
			WHERE S.METER_ID = M.METER_ID
				  AND S.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
				  AND NVL(S.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
				  AND S.BEGIN_DATE <= p_END_DATE
				  AND S.METER_ID = p_FIND_METER_ID
			ORDER BY 2, 3, 4;
	END IF;

END METER_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE SEARCH
	(
	p_BEGIN_DATE         IN DATE,
	p_END_DATE           IN DATE,
	p_SEARCH_STRING      IN VARCHAR,
	p_SEARCH_OPTION      IN VARCHAR,
	p_SEARCH_OPTION_NAME OUT VARCHAR,
	p_SEARCH_OPTION_NAME_2 OUT VARCHAR2,
	p_CURSOR             OUT GA.REFCURSOR
	) AS
v_IDS             ID_TABLE;
BEGIN

	-- This procedure must support the following search types:
	--         Account ¿ By Name
	--         Account - By Alias
	--         Account - By Display Name
	--         Account - By External Identifier
	--         Account - By EDC Account Number
	--         Account - By ESP Account Number
	--         Account - By Account Group Name
	-- 		   Service Location - By Name
	--		   Service Location - By Alias
	--		   Service Location - By External Identifier
	--		   Service Location - By EDC ID#
	--		   Service Location - By ESP ID#
	--		   Service Location - By Street Address
	--         Meter - By Name
	--         Meter - By Alias
	--         Meter - By External Identifier
	--         Meter - By EDC ID#
	--         Meter - By ESP ID#
	--		   Resource - By Name
	--		   Resource - By Alias
	--		   Resource - By External Identifier
	--		   Resource - By Serial #

	p_SEARCH_OPTION_NAME_2 := NULL;

	IF REGEXP_INSTR(p_SEARCH_OPTION, '^Account[[:space:]]{1}-[[:space:]]{1}') > 0 THEN

		ACCOUNT_LIST(p_SEARCH_STRING,
					 REGEXP_REPLACE(p_SEARCH_OPTION,'^Account[[:space:]]{1}-[[:space:]]{1}',''),
					 CONSTANTS.SEARCH_TYPE_NORMAL,
					 NULL,
					 NULL,
					 p_SEARCH_OPTION_NAME,
					 p_CURSOR);

	ELSIF REGEXP_INSTR(p_SEARCH_OPTION, '^Service Location[[:space:]]{1}-[[:space:]]{1}') > 0 THEN

		CASE p_SEARCH_OPTION
			WHEN 'Service Location - By Name' THEN
				p_SEARCH_OPTION_NAME := 'Service Location Name';
			WHEN 'Service Location - By Alias' THEN
				p_SEARCH_OPTION_NAME := 'Service Location Alias';
			WHEN 'Service Location - By External Identifier' THEN
				p_SEARCH_OPTION_NAME := 'Service Location External Identifier';
			WHEN 'Service Location - By EDC ID#' THEN
				p_SEARCH_OPTION_NAME := 'Service Location EDC ID#';
			WHEN 'Service Location - By ESP ID#' THEN
				p_SEARCH_OPTION_NAME := 'Service Location ESP ID#';
			WHEN 'Service Location - By Street Address' THEN
				p_SEARCH_OPTION_NAME := 'Street Address';
				p_SEARCH_OPTION_NAME_2 := 'Street Address 2';
		END CASE;

		-- Data Level Security
		v_IDS := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_SELECT_ENT, EC.ED_ACCOUNT);

		IF p_SEARCH_STRING = '%' OR p_SEARCH_STRING IS NULL THEN
			OPEN p_CURSOR FOR
				SELECT CASE p_SEARCH_OPTION
						   WHEN 'Service Location - By Name' THEN
							NULL
						   WHEN 'Service Location - By Alias' THEN
							SL.SERVICE_LOCATION_ALIAS
						   WHEN 'Service Location - By External Identifier' THEN
							SL.EXTERNAL_IDENTIFIER
						   WHEN 'Service Location - By EDC ID#' THEN
							ASL.EDC_IDENTIFIER
						   WHEN 'Service Location - By ESP ID#' THEN
							ASL.ESP_IDENTIFIER
						   WHEN 'Service Location - By Street Address' THEN
						    ADDR.street
					   END AS SEARCH_NAME,
					   CASE WHEN p_SEARCH_OPTION = 'Service Location - By Street Address' THEN
					   	ADDR.street2
					   ELSE
					   	NULL
					   END AS SEARCH_NAME_2,
					   A.ACCOUNT_ID,
					   A.ACCOUNT_NAME,
					   SL.SERVICE_LOCATION_ID,
					   SL.SERVICE_LOCATION_NAME
				FROM ACCOUNT A,
					TABLE(CAST(v_IDS AS ID_TABLE)) X,
					ACCOUNT_SERVICE_LOCATION ASL,
					SERVICE_LOCATION SL,
					ADDRESS_INFO ADDR
				WHERE X.ID IN (A.ACCOUNT_ID, SD.g_ALL_DATA_ENTITY_ID)
					  AND A.ACCOUNT_ID = ASL.ACCOUNT_ID
					  AND ASL.SERVICE_LOCATION_ID = SL.SERVICE_LOCATION_ID
					  AND NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					  AND ASL.BEGIN_DATE <= p_END_DATE
					  AND ADDR.ENTITY_DOMAIN_ID (+) = EC.ED_SERVICE_LOCATION
					  AND ADDR.CATEGORY_ID (+) = c_LOCALE_CATEGORY
					  AND ADDR.owner_entity_id (+) = SL.SERVICE_LOCATION_ID
				ORDER BY SEARCH_NAME, SL.SERVICE_LOCATION_NAME, A.ACCOUNT_NAME;
		ELSE
			OPEN p_CURSOR FOR
				SELECT CASE p_SEARCH_OPTION
						   WHEN 'Service Location - By Name' THEN
							NULL
						   WHEN 'Service Location - By Alias' THEN
							SL.SERVICE_LOCATION_ALIAS
						   WHEN 'Service Location - By External Identifier' THEN
							SL.EXTERNAL_IDENTIFIER
						   WHEN 'Service Location - By EDC ID#' THEN
							ASL.EDC_IDENTIFIER
						   WHEN 'Service Location - By ESP ID#' THEN
							ASL.ESP_IDENTIFIER
						   WHEN 'Service Location - By Street Address' THEN
						    ADDR.STREET
					   END AS SEARCH_NAME,
					   CASE WHEN p_SEARCH_OPTION = 'Service Location - By Street Address' THEN
					   	ADDR.STREET2
					   ELSE
					   	NULL
					   END AS SEARCH_NAME_2,
					   A.ACCOUNT_ID,
					   A.ACCOUNT_NAME,
					   SL.SERVICE_LOCATION_ID,
					   SL.SERVICE_LOCATION_NAME
				FROM ACCOUNT A,
					TABLE(CAST(v_IDS AS ID_TABLE)) X,
					ACCOUNT_SERVICE_LOCATION ASL,
					SERVICE_LOCATION SL,
					ADDRESS_INFO ADDR
				WHERE X.ID IN (A.ACCOUNT_ID, SD.g_ALL_DATA_ENTITY_ID)
					  AND A.ACCOUNT_ID = ASL.ACCOUNT_ID
					  AND ASL.SERVICE_LOCATION_ID = SL.SERVICE_LOCATION_ID
					  AND NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					  AND ASL.BEGIN_DATE <= p_END_DATE
  					  AND ADDR.ENTITY_DOMAIN_ID (+) = EC.ED_SERVICE_LOCATION
					  AND ADDR.CATEGORY_ID (+) = c_LOCALE_CATEGORY
					  AND ADDR.owner_entity_id (+) = SL.SERVICE_LOCATION_ID
					  AND ((p_SEARCH_OPTION = 'Service Location - By Name' AND SL.SERVICE_LOCATION_NAME LIKE p_SEARCH_STRING) OR
					  (p_SEARCH_OPTION = 'Service Location - By Alias' AND SL.SERVICE_LOCATION_ALIAS LIKE p_SEARCH_STRING) OR
					  (p_SEARCH_OPTION = 'Service Location - By External Identifier' AND SL.EXTERNAL_IDENTIFIER LIKE p_SEARCH_STRING) OR
					  (p_SEARCH_OPTION = 'Service Location - By EDC ID#' AND ASL.EDC_IDENTIFIER LIKE p_SEARCH_STRING) OR
					  (p_SEARCH_OPTION = 'Service Location - By ESP ID#' AND ASL.ESP_IDENTIFIER LIKE p_SEARCH_STRING) OR
					  (p_SEARCH_OPTION = 'Service Location - By Street Address' AND (ADDR.STREET || ' ' || ADDR.STREET2) LIKE p_SEARCH_STRING))
				ORDER BY SEARCH_NAME, SL.SERVICE_LOCATION_NAME, A.ACCOUNT_NAME;
		END IF;
	ELSIF REGEXP_INSTR(p_SEARCH_OPTION, '^Meter[[:space:]]{1}-[[:space:]]{1}') > 0 THEN

		CASE p_SEARCH_OPTION
			WHEN 'Meter - By Name' THEN
				p_SEARCH_OPTION_NAME := 'Meter Name';
			WHEN 'Meter - By Alias' THEN
				p_SEARCH_OPTION_NAME := 'Meter Alias';
			WHEN 'Meter - By External Identifier' THEN
				p_SEARCH_OPTION_NAME := 'Meter External Identifier';
			WHEN 'Meter - By EDC ID#' THEN
				p_SEARCH_OPTION_NAME := 'Meter EDC ID#';
			WHEN 'Meter - By ESP ID#' THEN
				p_SEARCH_OPTION_NAME := 'Meter ESP ID#';
		END CASE;

		-- Data Level Security
		v_IDS := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_SELECT_ENT, EC.ED_ACCOUNT);

		IF p_SEARCH_STRING = '%' OR p_SEARCH_STRING IS NULL THEN
			OPEN p_CURSOR FOR
				SELECT CASE p_SEARCH_OPTION
						   WHEN 'Meter - By Name' THEN
							NULL
						   WHEN 'Meter - By Alias' THEN
							M.METER_ALIAS
						   WHEN 'Meter - By External Identifier' THEN
							M.METER_EXTERNAL_IDENTIFIER
						   WHEN 'Meter - By EDC ID#' THEN
							SLM.EDC_IDENTIFIER
						   WHEN 'Meter - By ESP ID#' THEN
							SLM.ESP_IDENTIFIER
					   END AS SEARCH_NAME,
					   M.METER_NAME,
					   M.METER_ID,
					   A.ACCOUNT_ID,
					   A.ACCOUNT_NAME,
					   SL.SERVICE_LOCATION_ID,
					   SL.SERVICE_LOCATION_NAME
				FROM ACCOUNT A, TABLE(CAST(v_IDS AS ID_TABLE)) X, ACCOUNT_SERVICE_LOCATION ASL, SERVICE_LOCATION SL, SERVICE_LOCATION_METER SLM, METER M
				WHERE X.ID IN (A.ACCOUNT_ID, SD.g_ALL_DATA_ENTITY_ID)
					  AND A.ACCOUNT_ID = ASL.ACCOUNT_ID
					  AND ASL.SERVICE_LOCATION_ID = SL.SERVICE_LOCATION_ID
					  AND NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					  AND ASL.BEGIN_DATE <= p_END_DATE
					  AND SLM.SERVICE_LOCATION_ID = SL.SERVICE_LOCATION_ID
					  AND NVL(SLM.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					  AND SLM.BEGIN_DATE <= p_END_DATE
					  AND SLM.METER_ID = M.METER_ID
				ORDER BY SEARCH_NAME, M.METER_NAME, A.ACCOUNT_NAME, SL.SERVICE_LOCATION_NAME;
		ELSE
			OPEN p_CURSOR FOR
				SELECT CASE p_SEARCH_OPTION
						   WHEN 'Meter - By Name' THEN
							NULL
						   WHEN 'Meter - By Alias' THEN
							M.METER_ALIAS
						   WHEN 'Meter - By External Identifier' THEN
							M.METER_EXTERNAL_IDENTIFIER
						   WHEN 'Meter - By EDC ID#' THEN
							SLM.EDC_IDENTIFIER
						   WHEN 'Meter - By ESP ID#' THEN
							SLM.ESP_IDENTIFIER
					   END AS SEARCH_NAME,
					   M.METER_NAME,
					   M.METER_ID,
					   A.ACCOUNT_ID,
					   A.ACCOUNT_NAME,
					   SL.SERVICE_LOCATION_ID,
					   SL.SERVICE_LOCATION_NAME
				FROM ACCOUNT A, TABLE(CAST(v_IDS AS ID_TABLE)) X, ACCOUNT_SERVICE_LOCATION ASL, SERVICE_LOCATION SL, SERVICE_LOCATION_METER SLM, METER M
				WHERE X.ID IN (A.ACCOUNT_ID, SD.g_ALL_DATA_ENTITY_ID)
					  AND A.ACCOUNT_ID = ASL.ACCOUNT_ID
					  AND ASL.SERVICE_LOCATION_ID = SL.SERVICE_LOCATION_ID
					  AND NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					  AND ASL.BEGIN_DATE <= p_END_DATE
					  AND SLM.SERVICE_LOCATION_ID = SL.SERVICE_LOCATION_ID
					  AND NVL(SLM.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					  AND SLM.BEGIN_DATE <= p_END_DATE
					  AND SLM.METER_ID = M.METER_ID
					  AND ((p_SEARCH_OPTION = 'Meter - By Name' AND M.METER_NAME LIKE p_SEARCH_STRING) OR
					  (p_SEARCH_OPTION = 'Meter - By Alias' AND M.METER_ALIAS LIKE p_SEARCH_STRING) OR
					  (p_SEARCH_OPTION = 'Meter - By External Identifier' AND M.METER_EXTERNAL_IDENTIFIER LIKE p_SEARCH_STRING) OR
					  (p_SEARCH_OPTION = 'Meter - By EDC ID#' AND SLM.EDC_IDENTIFIER LIKE p_SEARCH_STRING) OR
					  (p_SEARCH_OPTION = 'Meter - By ESP ID#' AND SLM.ESP_IDENTIFIER LIKE p_SEARCH_STRING))
				ORDER BY SEARCH_NAME, M.METER_NAME, A.ACCOUNT_NAME, SL.SERVICE_LOCATION_NAME;
		END IF;
	ELSIF REGEXP_INSTR(p_SEARCH_OPTION, '^Resource[[:space:]]{1}-[[:space:]]{1}') > 0 THEN

		CASE p_SEARCH_OPTION
			WHEN 'Resource - By Name' THEN
				p_SEARCH_OPTION_NAME := 'Resource Name';
			WHEN 'Resource - By Alias' THEN
				p_SEARCH_OPTION_NAME := 'Resource Alias';
			WHEN 'Resource - By External Identifier' THEN
				p_SEARCH_OPTION_NAME := 'Resource External Identifier';
			WHEN 'Resource - By Serial #' THEN
				p_SEARCH_OPTION_NAME := 'Resource Serial #';
		END CASE;

		-- Data Level Security
		v_IDS := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_SELECT_ENT, EC.ED_ACCOUNT);

		IF p_SEARCH_STRING = '%' OR p_SEARCH_STRING IS NULL THEN
			OPEN p_CURSOR FOR
				SELECT CASE p_SEARCH_OPTION
						   WHEN 'Resource - By Name' THEN
							NULL
						   WHEN 'Resource - By Alias' THEN
							DER.DER_ALIAS
						   WHEN 'Resource - By External Identifier' THEN
							DER.EXTERNAL_IDENTIFIER
						   WHEN 'Resource - By Serial #' THEN
							DER.SERIAL_NUMBER
					   END AS SEARCH_NAME,
					   DER.DER_NAME,
					   DER.DER_ID,
					   A.ACCOUNT_ID,
					   A.ACCOUNT_NAME,
					   SL.SERVICE_LOCATION_ID,
					   SL.SERVICE_LOCATION_NAME
				FROM ACCOUNT A, TABLE(CAST(v_IDS AS ID_TABLE)) X, ACCOUNT_SERVICE_LOCATION ASL, SERVICE_LOCATION SL, DISTRIBUTED_ENERGY_RESOURCE DER
				WHERE X.ID IN (A.ACCOUNT_ID, SD.g_ALL_DATA_ENTITY_ID)
					  AND A.ACCOUNT_ID = ASL.ACCOUNT_ID
					  AND ASL.SERVICE_LOCATION_ID = SL.SERVICE_LOCATION_ID
					  AND NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					  AND ASL.BEGIN_DATE <= p_END_DATE
					  AND DER.SERVICE_LOCATION_ID = SL.SERVICE_LOCATION_ID
				ORDER BY SEARCH_NAME, DER.DER_NAME, A.ACCOUNT_NAME, SL.SERVICE_LOCATION_NAME;
		ELSE
			OPEN p_CURSOR FOR
				SELECT CASE p_SEARCH_OPTION
						   WHEN 'Resource - By Name' THEN
							NULL
						   WHEN 'Resource - By Alias' THEN
							DER.DER_ALIAS
						   WHEN 'Resource - By External Identifier' THEN
							DER.EXTERNAL_IDENTIFIER
						   WHEN 'Resource - By Serial #' THEN
							DER.SERIAL_NUMBER
					   END AS SEARCH_NAME,
					   DER.DER_NAME,
					   DER.DER_ID,
					   A.ACCOUNT_ID,
					   A.ACCOUNT_NAME,
					   SL.SERVICE_LOCATION_ID,
					   SL.SERVICE_LOCATION_NAME
				FROM ACCOUNT A, TABLE(CAST(v_IDS AS ID_TABLE)) X, ACCOUNT_SERVICE_LOCATION ASL, SERVICE_LOCATION SL, DISTRIBUTED_ENERGY_RESOURCE DER
				WHERE X.ID IN (A.ACCOUNT_ID, SD.g_ALL_DATA_ENTITY_ID)
					  AND A.ACCOUNT_ID = ASL.ACCOUNT_ID
					  AND ASL.SERVICE_LOCATION_ID = SL.SERVICE_LOCATION_ID
					  AND NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					  AND ASL.BEGIN_DATE <= p_END_DATE
					  AND DER.SERVICE_LOCATION_ID = SL.SERVICE_LOCATION_ID
					  AND ((p_SEARCH_OPTION = 'Resource - By Name' AND DER.DER_NAME LIKE p_SEARCH_STRING) OR
					  (p_SEARCH_OPTION = 'Resource - By Alias' AND DER.DER_ALIAS LIKE p_SEARCH_STRING) OR
					  (p_SEARCH_OPTION = 'Resource - By External Identifier' AND DER.EXTERNAL_IDENTIFIER LIKE p_SEARCH_STRING) OR
					  (p_SEARCH_OPTION = 'Resource - By Serial #' AND DER.SERIAL_NUMBER LIKE p_SEARCH_STRING))
				ORDER BY SEARCH_NAME, DER.DER_NAME, A.ACCOUNT_NAME, SL.SERVICE_LOCATION_NAME;
		END IF;
	END IF;
END SEARCH;
----------------------------------------------------------------------------------------------------
PROCEDURE ACCOUNT_GROUP_ASSIGNMENTS
	(
	p_ACCOUNT_ID IN NUMBER,
	p_CURSOR     OUT GA.REFCURSOR
	) AS
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	OPEN p_CURSOR FOR
		SELECT A.ACCOUNT_ID, A.ACCOUNT_GROUP_ID, B.ACCOUNT_GROUP_NAME, A.ASSIGNMENT_CATEGORY
		FROM ACCOUNT_GROUP_ASSIGNMENT A, ACCOUNT_GROUP B
		WHERE A.ACCOUNT_GROUP_ID = B.ACCOUNT_GROUP_ID
			  AND A.ACCOUNT_ID = p_ACCOUNT_ID;

END ACCOUNT_GROUP_ASSIGNMENTS;
--------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_GROUP_ASSIGNMENT
	(
	p_ACCOUNT_ID              IN NUMBER,
	p_ACCOUNT_GROUP_ID        IN NUMBER,
	p_ASSIGNMENT_CATEGORY     IN VARCHAR2,
	p_OLD_ACCOUNT_GROUP_ID    IN NUMBER,
	p_OLD_ASSIGNMENT_CATEGORY IN VARCHAR2
	) AS
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	UPDATE ACCOUNT_GROUP_ASSIGNMENT
	SET ACCOUNT_GROUP_ID    = p_ACCOUNT_GROUP_ID,
		ASSIGNMENT_CATEGORY = p_ASSIGNMENT_CATEGORY
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		  AND ACCOUNT_GROUP_ID = p_OLD_ACCOUNT_GROUP_ID
		  AND ASSIGNMENT_CATEGORY = p_OLD_ASSIGNMENT_CATEGORY;

	IF SQL%NOTFOUND THEN
		INSERT INTO ACCOUNT_GROUP_ASSIGNMENT
			(ACCOUNT_ID, ACCOUNT_GROUP_ID, ASSIGNMENT_CATEGORY)
		VALUES
			(p_ACCOUNT_ID, p_ACCOUNT_GROUP_ID, p_ASSIGNMENT_CATEGORY);
	END IF;

END PUT_ACCOUNT_GROUP_ASSIGNMENT;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_ACCOUNT_GROUP_ASSIGNMT
	(
	p_ACCOUNT_ID          IN NUMBER,
	p_ACCOUNT_GROUP_ID    IN NUMBER,
	p_ASSIGNMENT_CATEGORY IN VARCHAR2
	) AS
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	DELETE ACCOUNT_GROUP_ASSIGNMENT
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		  AND ACCOUNT_GROUP_ID = p_ACCOUNT_GROUP_ID
		  AND ASSIGNMENT_CATEGORY = p_ASSIGNMENT_CATEGORY;

END REMOVE_ACCOUNT_GROUP_ASSIGNMT;
--------------------------------------------------------------------------------
FUNCTION IS_ACCOUNT_STATUS_ACTIVE(p_STATUS_NAME IN VARCHAR2) RETURN NUMBER AS
	v_IS_ACTIVE NUMBER;
BEGIN
	SELECT MAX(A.IS_ACTIVE) INTO v_IS_ACTIVE FROM ACCOUNT_STATUS_NAME A WHERE A.STATUS_NAME = p_STATUS_NAME;

	RETURN NVL(v_IS_ACTIVE, 0);
END IS_ACCOUNT_STATUS_ACTIVE;
--------------------------------------------------------------------------------
PROCEDURE ACCOUNT_STATUS_LIST(p_CURSOR OUT GA.REFCURSOR) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT A.STATUS_NAME
		FROM ACCOUNT_STATUS_NAME A
		ORDER BY 1;
END ACCOUNT_STATUS_LIST;
--------------------------------------------------------------------------------
PROCEDURE ACCOUNT_STATUSES
	(
	p_ACCOUNT_ID IN NUMBER,
	p_CURSOR     OUT GA.REFCURSOR
	) AS
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	OPEN p_CURSOR FOR
		SELECT ACCOUNT_ID, BEGIN_DATE, END_DATE, STATUS_NAME, ENTRY_DATE
		FROM ACCOUNT_STATUS
		WHERE ACCOUNT_ID = p_ACCOUNT_ID
		ORDER BY BEGIN_DATE;

END ACCOUNT_STATUSES;
--------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_STATUS
	(
	p_ACCOUNT_ID     IN NUMBER,
	p_BEGIN_DATE     IN DATE,
	p_END_DATE       IN DATE,
	p_STATUS_NAME    IN VARCHAR2,
	p_OLD_BEGIN_DATE IN DATE
	) AS
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

    --Verify CSB is NOT Subdaily
    IF GA.CSB_IS_SUBDAILY THEN
       LOGS.LOG_WARN('Unexpected Daily Status');
    END IF;

	UT.PUT_TEMPORAL_DATA_UI('ACCOUNT_STATUS',
							p_BEGIN_DATE,
							p_END_DATE,
							p_OLD_BEGIN_DATE,
							TRUE,
							'ACCOUNT_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
							UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
							TRUE,
							'STATUS_NAME',
							UT.GET_LITERAL_FOR_STRING(p_STATUS_NAME));

END PUT_ACCOUNT_STATUS;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_ACCOUNT_STATUS
	(
	p_ACCOUNT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE
	) AS
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	--Verify CSB is NOT Subdaily
    IF GA.CSB_IS_SUBDAILY THEN
       ERRS.RAISE(MSGCODES.c_ERR_UNSUPPORTED_OPERATION, 'Unexpected Daily Status');
    END IF;

	DELETE ACCOUNT_STATUS
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		  AND BEGIN_DATE = p_BEGIN_DATE;

END REMOVE_ACCOUNT_STATUS;
--------------------------------------------------------------------------------
PROCEDURE EDC_RATE_CLASSES
	(
	p_EDC_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT A.RATE_CLASS FROM EDC_RATE_CLASS A WHERE A.EDC_ID = p_EDC_ID;
END EDC_RATE_CLASSES;
--------------------------------------------------------------------------------
PROCEDURE ACCOUNT_EDCS
	(
	p_ACCOUNT_ID IN NUMBER,
	p_CURSOR     OUT GA.REFCURSOR
	) AS
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	OPEN p_CURSOR FOR
		SELECT A.ACCOUNT_ID,
			   B.EDC_NAME,
			   A.EDC_ID,
			   A.BEGIN_DATE,
			   A.EDC_ACCOUNT_NUMBER,
			   A.EDC_RATE_CLASS,
			   A.EDC_STRATA,
			   A.END_DATE,
			   A.ENTRY_DATE
		FROM ACCOUNT_EDC A, EDC B
		WHERE A.EDC_ID = B.EDC_ID
			  AND A.ACCOUNT_ID = p_ACCOUNT_ID
		ORDER BY A.BEGIN_DATE, B.EDC_NAME;

END ACCOUNT_EDCS;
--------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_EDC
	(
	p_ACCOUNT_ID         IN NUMBER,
	p_EDC_ID             IN NUMBER,
	p_BEGIN_DATE         IN DATE,
	p_EDC_ACCOUNT_NUMBER IN VARCHAR2,
	p_EDC_RATE_CLASS     IN VARCHAR2,
	p_EDC_STRATA         IN VARCHAR2,
	p_END_DATE           IN DATE,
	p_OLD_EDC_ID         IN NUMBER,
	p_OLD_BEGIN_DATE     IN DATE
	) AS
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	UT.PUT_TEMPORAL_DATA_UI('ACCOUNT_EDC',
							p_BEGIN_DATE,
							p_END_DATE,
							p_OLD_BEGIN_DATE,
							TRUE,
							'ACCOUNT_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
							UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
							TRUE,
							'EDC_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_EDC_ID),
							UT.GET_LITERAL_FOR_NUMBER(p_OLD_EDC_ID),
							TRUE,
							'EDC_ACCOUNT_NUMBER',
							UT.GET_LITERAL_FOR_STRING(p_EDC_ACCOUNT_NUMBER),
							NULL,
							FALSE,
							'EDC_RATE_CLASS',
							UT.GET_LITERAL_FOR_STRING(p_EDC_RATE_CLASS),
							NULL,
							FALSE,
							'EDC_STRATA',
							UT.GET_LITERAL_FOR_STRING(p_EDC_STRATA),
							NULL,
							FALSE);

END PUT_ACCOUNT_EDC;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_ACCOUNT_EDC
	(
	p_ACCOUNT_ID IN NUMBER,
	p_EDC_ID     IN NUMBER,
	p_BEGIN_DATE IN DATE
	) AS
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	DELETE ACCOUNT_EDC
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		  AND EDC_ID = p_EDC_ID
		  AND BEGIN_DATE = p_BEGIN_DATE;

END REMOVE_ACCOUNT_EDC;
--------------------------------------------------------------------------------
PROCEDURE ACCOUNT_ESPS
	(
	p_ACCOUNT_ID IN NUMBER,
	p_CURSOR     OUT GA.REFCURSOR
	) AS
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	OPEN p_CURSOR FOR
		SELECT A.ACCOUNT_ID,
			   B.ESP_NAME,
			   A.ESP_ID,
			   C.POOL_NAME,
			   A.POOL_ID,
			   A.BEGIN_DATE,
			   A.END_DATE,
			   A.ESP_ACCOUNT_NUMBER,
			   A.ENTRY_DATE
		FROM ACCOUNT_ESP A, ESP B, POOL C
		WHERE A.ESP_ID = B.ESP_ID
			  AND A.POOL_ID = C.POOL_ID
			  AND A.ACCOUNT_ID = p_ACCOUNT_ID
		ORDER BY A.BEGIN_DATE, B.ESP_NAME;

END ACCOUNT_ESPS;
--------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_ESP
	(
	p_ACCOUNT_ID         IN NUMBER,
	p_ESP_ID             IN NUMBER,
	p_POOL_ID            IN NUMBER,
	p_BEGIN_DATE         IN DATE,
	p_END_DATE           IN DATE,
	p_ESP_ACCOUNT_NUMBER IN VARCHAR2,
	p_OLD_ESP_ID         IN NUMBER,
	p_OLD_POOL_ID        IN NUMBER,
	p_OLD_BEGIN_DATE     IN DATE
	) AS
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	UT.PUT_TEMPORAL_DATA_UI('ACCOUNT_ESP',
							p_BEGIN_DATE,
							p_END_DATE,
							p_OLD_BEGIN_DATE,
							TRUE,
							'ACCOUNT_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
							UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
							TRUE,
							'ESP_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_ESP_ID),
							UT.GET_LITERAL_FOR_NUMBER(p_OLD_ESP_ID),
							FALSE,
							'POOL_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_POOL_ID),
							UT.GET_LITERAL_FOR_NUMBER(p_OLD_POOL_ID),
							FALSE,
							'ESP_ACCOUNT_NUMBER',
							UT.GET_LITERAL_FOR_STRING(p_ESP_ACCOUNT_NUMBER),
							NULL,
							FALSE);

END PUT_ACCOUNT_ESP;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_ACCOUNT_ESP
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ESP_ID     IN NUMBER,
	p_POOL_ID    IN NUMBER,
	p_BEGIN_DATE IN DATE
	) AS
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

 	--Verify CSB is NOT Subdaily
    IF GA.CSB_IS_SUBDAILY THEN
       ERRS.RAISE(MSGCODES.c_ERR_UNSUPPORTED_OPERATION, 'Unexpected Daily Account-ESP relationship.');
    END IF;

	DELETE ACCOUNT_ESP
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		  AND ESP_ID = p_ESP_ID
		  AND POOL_ID = p_POOL_ID
		  AND BEGIN_DATE = p_BEGIN_DATE;

END REMOVE_ACCOUNT_ESP;
--------------------------------------------------------------------------------
PROCEDURE AGGREGATE_ACCOUNT_ESPS
	(
	p_ACCOUNT_ID IN NUMBER,
	p_CURSOR     OUT GA.REFCURSOR
	) AS
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	OPEN p_CURSOR FOR
		SELECT A.ACCOUNT_ID,
			B.ESP_NAME, A.ESP_ID,
			C.POOL_NAME, A.POOL_ID,
			A.BEGIN_DATE AS AGG_BEGIN_DATE, A.END_DATE AS AGG_END_DATE,
			A.ENTRY_DATE,
			A.AGGREGATE_ID
		FROM AGGREGATE_ACCOUNT_ESP A, ESP B, POOL C
		WHERE A.ESP_ID = B.ESP_ID
			  AND A.POOL_ID = C.POOL_ID
			  AND A.ACCOUNT_ID = p_ACCOUNT_ID
		ORDER BY B.ESP_NAME, A.BEGIN_DATE;

END AGGREGATE_ACCOUNT_ESPS;
--------------------------------------------------------------------------------
PROCEDURE PUT_AGGREGATE_ACCOUNT_ESP
	(
	p_ACCOUNT_ID     IN NUMBER,
	p_ESP_ID         IN NUMBER,
	p_POOL_ID        IN NUMBER,
	p_AGG_BEGIN_DATE IN DATE,
	p_AGG_END_DATE   IN DATE,
	p_OLD_ESP_ID     IN NUMBER,
	p_OLD_POOL_ID    IN NUMBER,
	p_OLD_AGG_BEGIN_DATE IN DATE
	) AS
	v_AGGREGATE_ID AGGREGATE_ACCOUNT_ESP.AGGREGATE_ID%TYPE;
	v_COUNT        NUMBER;
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	-- DETERMINE IF THE AGGREGATE_ACCOUNT_ID NEEDS TO BE CHANGED
	SELECT COUNT(1)
	INTO v_COUNT
	FROM AGGREGATE_ACCOUNT_ESP
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		  AND ESP_ID = p_ESP_ID
		  AND POOL_ID = p_POOL_ID;

	--IF THIS COMBINATION DOES NOT EXIST, THEN CREATE ANOTHER AGGREGATE_ID.
	--OTHERWISE, USE THE AGGREGATE_ID FOR THE EXISTING COMBINATION.
	IF v_COUNT = 0 THEN
		SELECT OID.NEXTVAL INTO v_AGGREGATE_ID FROM DUAL;
	ELSE
		SELECT MAX(AGGREGATE_ID)
		INTO v_AGGREGATE_ID
		FROM AGGREGATE_ACCOUNT_ESP
		WHERE ACCOUNT_ID = p_ACCOUNT_ID
			  AND ESP_ID = p_ESP_ID
			  AND POOL_ID = p_POOL_ID;
	END IF;

	UT.PUT_TEMPORAL_DATA_UI('AGGREGATE_ACCOUNT_ESP',
							p_AGG_BEGIN_DATE,
							p_AGG_END_DATE,
							p_OLD_AGG_BEGIN_DATE,
							TRUE,
							'ACCOUNT_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
							UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
							TRUE,
							'ESP_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_ESP_ID),
							UT.GET_LITERAL_FOR_NUMBER(p_OLD_ESP_ID),
							TRUE,
							'POOL_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_POOL_ID),
							UT.GET_LITERAL_FOR_NUMBER(p_OLD_POOL_ID),
							TRUE,
							'AGGREGATE_ID',
							v_AGGREGATE_ID,
							NULL,
							FALSE);

END PUT_AGGREGATE_ACCOUNT_ESP;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_AGGREGATE_ACCOUNT_ESP
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ESP_ID     IN NUMBER,
	p_POOL_ID    IN NUMBER,
	p_AGG_BEGIN_DATE IN DATE
	) AS
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	DELETE AGGREGATE_ACCOUNT_ESP
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		  AND ESP_ID = p_ESP_ID
		  AND POOL_ID = p_POOL_ID
		  AND BEGIN_DATE = p_AGG_BEGIN_DATE;

END REMOVE_AGGREGATE_ACCOUNT_ESP;
--------------------------------------------------------------------------------
PROCEDURE ACCOUNT_SERVICE_LOCATIONS
	(
	p_ACCOUNT_ID IN NUMBER,
	p_CURSOR     OUT GA.REFCURSOR
	) AS
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	OPEN p_CURSOR FOR
		SELECT A.ACCOUNT_ID,
			   B.SERVICE_LOCATION_NAME,
			   A.SERVICE_LOCATION_ID,
			   A.BEGIN_DATE,
			   A.END_DATE,
			   A.EDC_IDENTIFIER,
			   A.ESP_IDENTIFIER,
			   B.EXTERNAL_IDENTIFIER,
			   B.LATITUDE,
			   B.LONGITUDE,
			   B.TIME_ZONE,
			   C.SERVICE_POINT_NAME,
			   B.SERVICE_POINT_ID,
			   D.STATION_NAME AS WEATHER_STATION_NAME,
			   B.WEATHER_STATION_ID,
			   E.STREET,
			   E.STREET2,
			   E.CITY,
			   E.STATE_CODE,
			   E.POSTAL_CODE,
			   E.COUNTRY_CODE,
			   B.SQUARE_FOOTAGE,
			   B.ANNUAL_CONSUMPTION,
			   B.SUMMER_CONSUMPTION,
			   B.SERVICE_ZONE_ID,
			   B.SUB_STATION_ID,
			   B.FEEDER_ID,
			   B.FEEDER_SEGMENT_ID,
			   A.ENTRY_DATE
		FROM ACCOUNT_SERVICE_LOCATION A, SERVICE_LOCATION B, SERVICE_POINT C, WEATHER_STATION D, ADDRESS_INFO E
		WHERE A.SERVICE_LOCATION_ID = B.SERVICE_LOCATION_ID
			  AND B.SERVICE_POINT_ID = C.SERVICE_POINT_ID (+)
			  AND B.WEATHER_STATION_ID = D.STATION_ID (+)
			  AND A.ACCOUNT_ID = p_ACCOUNT_ID
			  AND E.CATEGORY_ID (+) = c_LOCALE_CATEGORY
			  AND E.ENTITY_DOMAIN_ID (+) = EC.ED_SERVICE_LOCATION
			  AND E.OWNER_ENTITY_ID (+) = B.SERVICE_LOCATION_ID
		ORDER BY A.BEGIN_DATE, B.SERVICE_LOCATION_NAME;

END ACCOUNT_SERVICE_LOCATIONS;
--------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_SERVICE_LOCATION
	(
	p_ACCOUNT_ID              IN NUMBER,
	p_SERVICE_LOCATION_ID     IN NUMBER,
	p_SERVICE_LOCATION_NAME   IN VARCHAR2,
	p_SERVICE_LOCATION_ALIAS  IN VARCHAR2,
	p_SERVICE_LOCATION_DESC   IN VARCHAR2,
	p_BEGIN_DATE              IN DATE,
	p_END_DATE                IN DATE,
	p_EDC_IDENTIFIER          IN VARCHAR2,
	p_ESP_IDENTIFIER          IN VARCHAR2,
	p_LATITUDE                IN VARCHAR2,
	p_LONGITUDE               IN VARCHAR2,
	p_TIME_ZONE               IN VARCHAR2,
	p_EXTERNAL_IDENTIFIER     IN VARCHAR2,
	p_SERVICE_POINT_ID        IN NUMBER,
	p_WEATHER_STATION_ID      IN NUMBER,
	p_STREET                  IN VARCHAR2,
	p_STREET2                 IN VARCHAR2,
	p_CITY                    IN VARCHAR2,
	p_STATE_CODE              IN VARCHAR2,
	p_POSTAL_CODE             IN VARCHAR2,
	p_COUNTRY_CODE            IN VARCHAR2,
	p_SQUARE_FOOTAGE          IN NUMBER,
	p_ANNUAL_CONSUMPTION      IN NUMBER,
	p_SUMMER_CONSUMPTION      IN NUMBER,
	p_SERVICE_ZONE_ID         IN NUMBER,
	p_SUB_STATION_ID          IN NUMBER,
	p_FEEDER_ID               IN NUMBER,
	p_FEEDER_SEGMENT_ID       IN NUMBER,
	p_OLD_BEGIN_DATE          IN DATE,
	p_MESSAGE				  OUT VARCHAR2
	) AS
v_SERVICE_LOCATION_ID SERVICE_LOCATION.SERVICE_LOCATION_ID%TYPE;
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	PUT_SERVICE_LOCATION(v_SERVICE_LOCATION_ID,
		p_ACCOUNT_ID,
		p_OLD_BEGIN_DATE,
		p_BEGIN_DATE,
		p_END_DATE,
		p_EDC_IDENTIFIER,
		p_ESP_IDENTIFIER,
		p_SERVICE_LOCATION_NAME,
		p_SERVICE_LOCATION_ALIAS,
		p_SERVICE_LOCATION_DESC,
		NVL(p_SERVICE_LOCATION_ID, 0),
		p_LATITUDE,
		p_LONGITUDE,
		p_TIME_ZONE,
		p_EXTERNAL_IDENTIFIER,
		p_SERVICE_POINT_ID,
		p_WEATHER_STATION_ID,
		p_STREET,
		p_STREET2,
		p_CITY,
		p_STATE_CODE,
		p_POSTAL_CODE,
		p_COUNTRY_CODE,
		p_SQUARE_FOOTAGE,
		p_ANNUAL_CONSUMPTION,
		p_SUMMER_CONSUMPTION,
		p_SERVICE_ZONE_ID,
		p_SUB_STATION_ID,
		p_FEEDER_ID,
		p_FEEDER_SEGMENT_ID,
		p_MESSAGE);

END PUT_ACCOUNT_SERVICE_LOCATION;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_ACCOUNT_SERVICE_LOC
	(
	p_ACCOUNT_ID          IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_BEGIN_DATE          IN DATE
	) AS
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	DELETE ACCOUNT_SERVICE_LOCATION
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		  AND SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
		  AND BEGIN_DATE = p_BEGIN_DATE;

END REMOVE_ACCOUNT_SERVICE_LOC;

--------------------------------------------------------------------------------
PROCEDURE ACCOUNT_METERS
	(
	p_ACCOUNT_ID IN NUMBER,
	p_CURSOR     OUT GA.REFCURSOR
	) AS
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	OPEN p_CURSOR FOR
		SELECT DISTINCT C.SERVICE_LOCATION_NAME, -- (SP)(BUG 24662) THIS QUERY RETURNED DUPLICATE ENTRIES BECAUSE OF THE JOIN BTWN SERVICE_LOCATION_METER AND ACCOUNT_SERVICE_LOCATION
			   A.SERVICE_LOCATION_ID,
			   A.METER_ID,
			   D.METER_NAME,
			   D.METER_ALIAS,
			   D.METER_DESC,
			   D.METER_EXTERNAL_IDENTIFIER,
			   D.METER_STATUS,
			   D.METER_INTERVAL,
			   D.METER_TYPE,
			   D.METER_UNIT,
			   D.IS_EXTERNAL_INTERVAL_USAGE,
			   D.IS_EXTERNAL_BILLED_USAGE,
			   D.IS_EXTERNAL_FORECAST,
			   E.MODEL_ID,
			   A.BEGIN_DATE AS METER_BEGIN_DATE,
			   A.END_DATE AS METER_END_DATE,
			   A.IS_ESTIMATED_END_DATE,
			   A.EDC_IDENTIFIER,
			   A.ESP_IDENTIFIER,
			   A.NEXT_ACTION_DATE,
			   A.EDC_RATE_CLASS,
			   A.ENTRY_DATE
		FROM SERVICE_LOCATION_METER A, ACCOUNT_SERVICE_LOCATION B, SERVICE_LOCATION C, METER D, ACCOUNT E
		WHERE A.SERVICE_LOCATION_ID = B.SERVICE_LOCATION_ID
			  AND A.SERVICE_LOCATION_ID = C.SERVICE_LOCATION_ID
			  AND A.METER_ID = D.METER_ID
			  AND E.ACCOUNT_ID = B.ACCOUNT_ID
			  AND B.ACCOUNT_ID = P_ACCOUNT_ID
		ORDER BY A.BEGIN_DATE, C.SERVICE_LOCATION_NAME, D.METER_NAME;
END ACCOUNT_METERS;
--------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_METER
	(
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_OLD_METER_BEGIN_DATE IN DATE,
	p_MRSP_ID IN NUMBER,
	p_METER_NAME IN VARCHAR2,
	p_METER_ALIAS IN VARCHAR2,
	p_METER_DESC IN VARCHAR2,
	p_METER_ID IN NUMBER,
	p_METER_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_METER_STATUS IN VARCHAR2,
	p_METER_INTERVAL IN VARCHAR2,
	p_METER_TYPE IN VARCHAR2,
	p_METER_UNIT IN VARCHAR2,
	p_IS_EXTERNAL_INTERVAL_USAGE IN NUMBER,
	p_IS_EXTERNAL_BILLED_USAGE IN NUMBER,
	p_IS_EXTERNAL_FORECAST IN NUMBER,
	p_METER_BEGIN_DATE IN DATE,
	p_METER_END_DATE IN DATE,
	p_IS_ESTIMATED_END_DATE IN NUMBER,
	p_NEXT_ACTION_DATE IN DATE,
	p_EDC_IDENTIFIER IN VARCHAR2,
	p_ESP_IDENTIFIER IN VARCHAR2,
	p_EDC_RATE_CLASS IN VARCHAR2,
	p_USE_TOU_USAGE_FACTOR IN NUMBER,
	p_OLD_SERVICE_LOCATION_ID IN NUMBER
	) AS
v_NEW_METER_ID NUMBER;
BEGIN

	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	IF NOT p_OLD_SERVICE_LOCATION_ID IS NULL AND p_SERVICE_LOCATION_ID <> p_OLD_SERVICE_LOCATION_ID THEN
		-- Trying to reassign meter to a different service location. Delete the old record.
		REMOVE_ACCOUNT_METER(p_ACCOUNT_ID, p_OLD_SERVICE_LOCATION_ID, p_METER_ID, p_OLD_METER_BEGIN_DATE);
	END IF;

	-- Must be inserting a row, Create a New Meter
	PUT_METER(v_NEW_METER_ID,
		p_SERVICE_LOCATION_ID,
		p_OLD_METER_BEGIN_DATE,
		p_MRSP_ID,
		p_METER_NAME,
		p_METER_ALIAS,
		p_METER_DESC,
		NVL(p_METER_ID, 0),
		p_METER_EXTERNAL_IDENTIFIER,
		p_METER_STATUS,
		p_METER_INTERVAL,
		p_METER_TYPE,
		p_METER_UNIT,
		p_IS_EXTERNAL_INTERVAL_USAGE,
		p_IS_EXTERNAL_BILLED_USAGE,
		p_IS_EXTERNAL_FORECAST,
		p_METER_BEGIN_DATE,
		p_METER_END_DATE,
		p_IS_ESTIMATED_END_DATE,
		p_NEXT_ACTION_DATE,
		p_EDC_IDENTIFIER,
		p_ESP_IDENTIFIER,
		p_EDC_RATE_CLASS,
		p_USE_TOU_USAGE_FACTOR);

END PUT_ACCOUNT_METER;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_ACCOUNT_METER
	(
	p_ACCOUNT_ID          IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_METER_ID            IN NUMBER,
	p_METER_BEGIN_DATE      IN DATE
	) AS
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	DELETE SERVICE_LOCATION_METER
	WHERE SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
		  AND METER_ID = p_METER_ID
		  AND BEGIN_DATE = p_METER_BEGIN_DATE;

END REMOVE_ACCOUNT_METER;
--------------------------------------------------------------------------------
PROCEDURE ACCOUNT_CALENDARS
	(
	p_ACCOUNT_ID IN NUMBER,
	p_CURSOR     OUT GA.REFCURSOR
	) AS
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	OPEN p_CURSOR FOR
		SELECT B.CASE_NAME,
			   A.CASE_ID,
			   A.ACCOUNT_ID,
			   C.CALENDAR_NAME,
			   A.CALENDAR_ID,
			   A.CALENDAR_TYPE,
			   A.BEGIN_DATE,
			   A.END_DATE,
			   A.ENTRY_DATE
		FROM ACCOUNT_CALENDAR A, CASE_LABEL B, CALENDAR C
		WHERE A.CASE_ID = B.CASE_ID
			  AND A.CALENDAR_ID = C.CALENDAR_ID
			  AND A.ACCOUNT_ID = p_ACCOUNT_ID
		ORDER BY B.CASE_NAME, A.BEGIN_DATE, A.CALENDAR_TYPE, C.CALENDAR_NAME;

END ACCOUNT_CALENDARS;
--------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_CALENDAR
	(
	p_ACCOUNT_ID        IN NUMBER,
	p_CASE_ID           IN NUMBER,
	p_CALENDAR_TYPE     IN VARCHAR2,
	p_BEGIN_DATE        IN DATE,
	p_END_DATE          IN DATE,
	p_CALENDAR_ID       IN NUMBER,
	p_OLD_CASE_ID       IN NUMBER,
	p_OLD_CALENDAR_TYPE IN VARCHAR2,
	p_OLD_BEGIN_DATE    IN DATE
	) AS
BEGIN
-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	UT.PUT_TEMPORAL_DATA_UI('ACCOUNT_CALENDAR',
							p_BEGIN_DATE,
							p_END_DATE,
							p_OLD_BEGIN_DATE,
							TRUE,
							'ACCOUNT_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
							UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
							TRUE,
							'CASE_ID',
							UT.GET_LITERAL_FOR_NUMBER(NVL(p_CASE_ID, GA.BASE_CASE_ID)),
							UT.GET_LITERAL_FOR_NUMBER(p_OLD_CASE_ID),
							TRUE,
							'CALENDAR_TYPE',
							UT.GET_LITERAL_FOR_STRING(p_CALENDAR_TYPE),
							UT.GET_LITERAL_FOR_STRING(p_OLD_CALENDAR_TYPE),
							TRUE,
							'CALENDAR_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_CALENDAR_ID),
							NULL,
							FALSE);
END PUT_ACCOUNT_CALENDAR;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_ACCOUNT_CALENDAR
	(
	p_CASE_ID       IN NUMBER,
	p_ACCOUNT_ID    IN NUMBER,
	p_CALENDAR_TYPE IN VARCHAR2,
	p_BEGIN_DATE    IN DATE
	) AS
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	DELETE ACCOUNT_CALENDAR
	WHERE CASE_ID = p_CASE_ID
		  AND ACCOUNT_ID = p_ACCOUNT_ID
		  AND CALENDAR_TYPE = p_CALENDAR_TYPE
		  AND BEGIN_DATE = p_BEGIN_DATE;

END REMOVE_ACCOUNT_CALENDAR;
--------------------------------------------------------------------------------
PROCEDURE ACCOUNT_LOSS_FACTORS
	(
	p_ACCOUNT_ID IN NUMBER,
	p_CURSOR     OUT GA.REFCURSOR
	) AS
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	OPEN p_CURSOR FOR
		SELECT A.ACCOUNT_ID, B.CASE_NAME, A.CASE_ID, C.LOSS_FACTOR_NAME, A.LOSS_FACTOR_ID, A.BEGIN_DATE, A.END_DATE, A.ENTRY_DATE
		FROM ACCOUNT_LOSS_FACTOR A, CASE_LABEL B, LOSS_FACTOR C
		WHERE ACCOUNT_ID = P_ACCOUNT_ID
			  AND A.CASE_ID = B.CASE_ID
			  AND A.LOSS_FACTOR_ID = C.LOSS_FACTOR_ID
		ORDER BY B.CASE_NAME, A.BEGIN_DATE, C.LOSS_FACTOR_NAME;
END ACCOUNT_LOSS_FACTORS;
--------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_LOSS_FACTOR
	(
	p_ACCOUNT_ID     IN NUMBER,
	p_CASE_ID        IN NUMBER,
	p_LOSS_FACTOR_ID IN NUMBER,
	p_BEGIN_DATE     IN DATE,
	p_END_DATE       IN DATE,
	p_OLD_CASE_ID    IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE
	) AS
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	UT.PUT_TEMPORAL_DATA_UI('ACCOUNT_LOSS_FACTOR',
							p_BEGIN_DATE,
							p_END_DATE,
							p_OLD_BEGIN_DATE,
							TRUE,
							'ACCOUNT_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
							UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
							TRUE,
							'CASE_ID',
							UT.GET_LITERAL_FOR_NUMBER(NVL(p_CASE_ID, GA.BASE_CASE_ID)),
							UT.GET_LITERAL_FOR_NUMBER(p_OLD_CASE_ID),
							TRUE,
							'LOSS_FACTOR_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_LOSS_FACTOR_ID),
							NULL,
							FALSE);
END PUT_ACCOUNT_LOSS_FACTOR;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_ACCOUNT_LOSS_FACTOR
	(
	p_CASE_ID    IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE
	) AS
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	DELETE ACCOUNT_LOSS_FACTOR
	WHERE CASE_ID = p_CASE_ID
		  AND ACCOUNT_ID = p_ACCOUNT_ID
		  AND BEGIN_DATE = p_BEGIN_DATE;

END REMOVE_ACCOUNT_LOSS_FACTOR;
--------------------------------------------------------------------------------
PROCEDURE ACCOUNT_USAGE_FACTORS
    (
	p_ACCOUNT_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

    OPEN p_CURSOR FOR
        SELECT B.CASE_NAME,
			A.CASE_ID,
            A.ACCOUNT_ID,
            A.BEGIN_DATE,
            A.END_DATE,
            A.FACTOR_VAL,
            C.CALENDAR_NAME AS SOURCE_CALENDAR_NAME,
            CASE WHEN A.SOURCE_BEGIN_DATE IS NOT NULL THEN
                TEXT_UTIL.TO_CHAR_DATE_RANGE(A.SOURCE_BEGIN_DATE, A.SOURCE_END_DATE)
            ELSE NULL END AS SOURCE_DATE_RANGE,
            A.ENTRY_DATE
        FROM ACCOUNT_USAGE_FACTOR A, CASE_LABEL B, CALENDAR C
        WHERE A.ACCOUNT_ID = p_ACCOUNT_ID
		  AND A.CASE_ID = B.CASE_ID
          AND C.CALENDAR_ID (+) = A.SOURCE_CALENDAR_ID
        ORDER BY B.CASE_NAME, A.BEGIN_DATE;

END ACCOUNT_USAGE_FACTORS;
--------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_USAGE_FACTOR
    (
    p_CASE_ID IN NUMBER,
    p_ACCOUNT_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_FACTOR_VAL IN NUMBER,
    p_OLD_CASE_ID IN NUMBER,
    p_OLD_BEGIN_DATE IN DATE
    ) AS
BEGIN
-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	UT.PUT_TEMPORAL_DATA_UI('ACCOUNT_USAGE_FACTOR',
							p_BEGIN_DATE,
							p_END_DATE,
							p_OLD_BEGIN_DATE,
							TRUE,
							'ACCOUNT_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
							UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
							TRUE,
							'CASE_ID',
							UT.GET_LITERAL_FOR_NUMBER(NVL(p_CASE_ID, GA.BASE_CASE_ID)),
							UT.GET_LITERAL_FOR_NUMBER(p_OLD_CASE_ID),
							TRUE,
							'FACTOR_VAL',
							UT.GET_LITERAL_FOR_NUMBER(p_FACTOR_VAL),
							NULL,
							FALSE);

END PUT_ACCOUNT_USAGE_FACTOR;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_ACCOUNT_USAGE_FACTOR
    (
    p_CASE_ID IN NUMBER,
    p_ACCOUNT_ID IN NUMBER,
    p_BEGIN_DATE IN DATE
    ) AS
BEGIN
-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

    DELETE ACCOUNT_USAGE_FACTOR
    WHERE CASE_ID = p_CASE_ID
        AND ACCOUNT_ID = p_ACCOUNT_ID
        AND BEGIN_DATE = p_BEGIN_DATE;

END REMOVE_ACCOUNT_USAGE_FACTOR;
--------------------------------------------------------------------------------
PROCEDURE ACCOUNT_PROGRAMS
    (
    p_ACCOUNT_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

    OPEN p_CURSOR FOR
        SELECT ASL.ACCOUNT_ID,
		    SLP.SERVICE_LOCATION_ID,
		    SL.SERVICE_LOCATION_NAME,
            SLP.PROGRAM_ID,
			P.PROGRAM_NAME,
            SLP.BEGIN_DATE AS SLP_BEGIN_DATE,
            SLP.END_DATE AS SLP_END_DATE,
			GET_ENROLLED_DER(SLP.SERVICE_LOCATION_ID, SLP.PROGRAM_ID, SLP.BEGIN_DATE, SLP.END_DATE) ENROLLED_RESOURCES,
            SLP.AUTO_ENROLL
        FROM SERVICE_LOCATION_PROGRAM SLP, ACCOUNT_SERVICE_LOCATION ASL, SERVICE_LOCATION SL, PROGRAM P
        WHERE SLP.SERVICE_LOCATION_ID = ASL.SERVICE_LOCATION_ID
		    AND ASL.ACCOUNT_ID = p_ACCOUNT_ID
			AND SLP.SERVICE_LOCATION_ID = SL.SERVICE_LOCATION_ID
			AND P.PROGRAM_ID = SLP.PROGRAM_ID
        ORDER BY SLP_BEGIN_DATE,
            P.PROGRAM_NAME;

END ACCOUNT_PROGRAMS;
--------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_PROGRAM
    (
    p_SERVICE_LOCATION_ID IN NUMBER,
    p_PROGRAM_ID IN NUMBER,
    p_SLP_BEGIN_DATE IN DATE,
    p_SLP_END_DATE IN DATE,
    p_AUTO_ENROLL IN NUMBER,
	p_OLD_SERVICE_LOCATION_ID IN NUMBER,
    p_OLD_PROGRAM_ID IN NUMBER,
    p_OLD_SLP_BEGIN_DATE IN DATE
    ) AS
v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
v_COUNT NUMBER(9);
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_SERVICE_LOCATION_ID, EC.ED_SERVICE_LOCATION);

	IF UT.BOOLEAN_FROM_NUMBER(p_AUTO_ENROLL) THEN
		SELECT COUNT(SLP.SERVICE_LOCATION_ID)
		INTO v_COUNT
		FROM SERVICE_LOCATION_PROGRAM SLP
		WHERE SLP.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
			AND SLP.BEGIN_DATE <= NVL(p_SLP_END_DATE, CONSTANTS.HIGH_DATE)
			AND NVL(SLP.END_DATE, CONSTANTS.HIGH_DATE) >= p_SLP_BEGIN_DATE
			AND SLP.AUTO_ENROLL = 1
			AND (SLP.SERVICE_LOCATION_ID != NVL(p_OLD_SERVICE_LOCATION_ID, CONSTANTS.NULL_ID)
				OR SLP.PROGRAM_ID != NVL(p_OLD_PROGRAM_ID, CONSTANTS.NULL_ID)
				OR (p_OLD_SLP_BEGIN_DATE IS NULL OR SLP.BEGIN_DATE != p_OLD_SLP_BEGIN_DATE));

		IF v_COUNT > 0 THEN
			ERRS.RAISE(MSGCODES.c_ERR_DATE_RANGE, 'There cannot be more than one auto-enrolling program available for a Service Location at a time.');
		END IF;
	END IF;

    v_KEY_NEW('SERVICE_LOCATION_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SERVICE_LOCATION_ID);
    v_KEY_OLD('SERVICE_LOCATION_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_SERVICE_LOCATION_ID);
    v_KEY_NEW('PROGRAM_ID') := UT.GET_LITERAL_FOR_NUMBER(p_PROGRAM_ID);
    v_KEY_OLD('PROGRAM_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_PROGRAM_ID);
    v_DATA('AUTO_ENROLL') := UT.GET_LITERAL_FOR_NUMBER(p_AUTO_ENROLL);

    UT.PUT_TEMPORAL_DATA_UI('SERVICE_LOCATION_PROGRAM',
                            p_SLP_BEGIN_DATE,
                            p_SLP_END_DATE,
                            p_OLD_SLP_BEGIN_DATE,
                            FALSE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

	IF p_AUTO_ENROLL = 1 THEN

		FOR v_REC IN
			(SELECT DER.DER_ID, SLP.PROGRAM_ID, GREATEST(SLP.BEGIN_DATE, DER.BEGIN_DATE) AS BEGIN_DATE,
				LEAST(NVL(SLP.END_DATE, CONSTANTS.HIGH_DATE), NVL(DER.END_DATE, CONSTANTS.HIGH_DATE)) AS END_DATE
			FROM DISTRIBUTED_ENERGY_RESOURCE DER, PROGRAM P, PROGRAM_DER_TYPE PDT,
				SERVICE_LOCATION_PROGRAM SLP
			WHERE SLP.PROGRAM_ID = p_PROGRAM_ID
				AND SLP.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
				AND SLP.BEGIN_DATE = p_SLP_BEGIN_DATE
				AND P.PROGRAM_ID = SLP.PROGRAM_ID
				AND DER.DER_TYPE_ID = PDT.DER_TYPE_ID
				AND PDT.PROGRAM_ID = P.PROGRAM_ID
				AND DER.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
				AND DER.BEGIN_DATE <= NVL(SLP.END_DATE, CONSTANTS.HIGH_DATE)
				AND NVL(DER.END_DATE, CONSTANTS.HIGH_DATE) >= SLP.BEGIN_DATE)
		LOOP
			BEGIN
				IF v_REC.END_DATE = CONSTANTS.HIGH_DATE THEN
					v_REC.END_DATE := NULL;
				END IF;

				PUT_PROGRAM_DER(v_REC.DER_ID,
								v_REC.PROGRAM_ID,
								v_REC.BEGIN_DATE,
								v_REC.END_DATE,
								p_SLP_BEGIN_DATE,
								p_SLP_END_DATE,
								1,
								NULL,
								NULL);
			EXCEPTION
				WHEN MSGCODES.e_ERR_DATE_RANGE THEN
					NULL;
			END;
		END LOOP;

	END IF;

END PUT_ACCOUNT_PROGRAM;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_ACCOUNT_PROGRAM
    (
    p_SERVICE_LOCATION_ID IN NUMBER,
    p_PROGRAM_ID IN NUMBER,
    p_SLP_BEGIN_DATE IN DATE
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_SERVICE_LOCATION_ID, EC.ED_SERVICE_LOCATION);

    DELETE SERVICE_LOCATION_PROGRAM
    WHERE SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
        AND PROGRAM_ID = p_PROGRAM_ID
        AND BEGIN_DATE = p_SLP_BEGIN_DATE;

END REMOVE_ACCOUNT_PROGRAM;
--------------------------------------------------------------------------------
PROCEDURE ACCOUNT_SERVICE_LOCATION_LIST
    (
    p_ACCOUNT_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN

    OPEN p_CURSOR FOR
        SELECT SL.SERVICE_LOCATION_NAME,
		    SL.SERVICE_LOCATION_ID
        FROM ACCOUNT_SERVICE_LOCATION ASL, SERVICE_LOCATION SL
        WHERE SL.SERVICE_LOCATION_ID = ASL.SERVICE_LOCATION_ID
		    AND ASL.ACCOUNT_ID = p_ACCOUNT_ID;

END ACCOUNT_SERVICE_LOCATION_LIST;
--------------------------------------------------------------------------------
FUNCTION GET_ENROLLED_DER
    (
    p_SERVICE_LOCATION_ID IN NUMBER,
	p_PROGRAM_ID IN NUMBER,
	p_SLP_BEGIN_DATE IN DATE,
	p_SLP_END_DATE IN DATE
    ) RETURN VARCHAR2 AS
	v_STR_LENGTH NUMBER := 64;
	v_ENROLLED_DER VARCHAR2(64);
	v_CURSOR GA.REFCURSOR;
	v_DER_NAME DISTRIBUTED_ENERGY_RESOURCE.DER_NAME%TYPE;
	v_DER_TYPE_NAME DER_TYPE.DER_TYPE_NAME%TYPE;
BEGIN

    OPEN v_CURSOR FOR
        SELECT DER.DER_NAME,
            DT.DER_TYPE_NAME
        FROM DER_PROGRAM DP, DISTRIBUTED_ENERGY_RESOURCE DER, DER_TYPE DT
        WHERE DP.PROGRAM_ID = p_PROGRAM_ID
			AND DP.BEGIN_DATE >= p_SLP_BEGIN_DATE
			AND NVL(DP.END_DATE, CONSTANTS.HIGH_DATE) <= NVL(p_SLP_END_DATE, CONSTANTS.HIGH_DATE)
			AND DP.DER_ID = DER.DER_ID
			AND DER.DER_TYPE_ID = DT.DER_TYPE_ID
			AND DER.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID;

	LOOP
		FETCH v_CURSOR INTO v_DER_NAME, v_DER_TYPE_NAME;
		EXIT WHEN v_CURSOR%NOTFOUND;
		v_ENROLLED_DER := SUBSTR(v_ENROLLED_DER || v_DER_NAME || ' (' || v_DER_TYPE_NAME || '), ', 1, v_STR_LENGTH);
		EXIT WHEN LENGTH(v_ENROLLED_DER) = v_STR_LENGTH;
	END LOOP;

	CLOSE v_CURSOR;

	IF LENGTH(v_ENROLLED_DER) = v_STR_LENGTH THEN
		v_ENROLLED_DER := SUBSTR(v_ENROLLED_DER, 1, v_STR_LENGTH - 3) || '...';
	ELSIF LENGTH(v_ENROLLED_DER) > 0 THEN
		v_ENROLLED_DER := SUBSTR(v_ENROLLED_DER, 1, LENGTH(v_ENROLLED_DER) - 2);
	ELSE
		v_ENROLLED_DER := 'NA';
	END IF;

	RETURN v_ENROLLED_DER;

EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			IF v_CURSOR IS NOT NULL AND v_CURSOR%ISOPEN THEN
				CLOSE v_CURSOR;
			END IF;
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE('Cannot close cursor');
		END;
		ERRS.LOG_AND_RAISE();
END GET_ENROLLED_DER;
--------------------------------------------------------------------------------
PROCEDURE ACCOUNT_GROWTH_PATTERNS
	(
	p_ACCOUNT_ID IN NUMBER,
	p_CURSOR     OUT GA.REFCURSOR
	) AS
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	OPEN p_CURSOR FOR
		SELECT A.ACCOUNT_ID,
			   C.CASE_NAME,
			   A.CASE_ID,
			   A.BEGIN_DATE,
			   A.END_DATE,
			   G.PATTERN_NAME,
			   A.PATTERN_ID,
			   A.GROWTH_PCT,
			   A.END_DATE,
			   A.ENTRY_DATE
		FROM ACCOUNT_GROWTH A, CASE_LABEL C, GROWTH_PATTERN G
		WHERE A.ACCOUNT_ID = p_ACCOUNT_ID
			AND C.CASE_ID = A.CASE_ID
			AND G.PATTERN_ID = A.PATTERN_ID
		ORDER BY C.CASE_NAME, A.BEGIN_DATE;

END ACCOUNT_GROWTH_PATTERNS;
--------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_GROWTH_PATTERN
	(
	p_CASE_ID            IN NUMBER,
	p_ACCOUNT_ID         IN NUMBER,
	p_BEGIN_DATE         IN DATE,
	p_END_DATE           IN DATE,
	p_PATTERN_ID         IN NUMBER,
	p_GROWTH_PCT         IN NUMBER,
	p_OLD_CASE_ID        IN NUMBER,
	p_OLD_BEGIN_DATE     IN DATE
	) AS
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	UT.PUT_TEMPORAL_DATA_UI('ACCOUNT_GROWTH',
							p_BEGIN_DATE,
							p_END_DATE,
							p_OLD_BEGIN_DATE,
							TRUE,
							'CASE_ID',
							UT.GET_LITERAL_FOR_NUMBER(NVL(p_CASE_ID,GA.BASE_CASE_ID)),
							UT.GET_LITERAL_FOR_NUMBER(p_OLD_CASE_ID),
							TRUE,
							'ACCOUNT_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
							UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
							TRUE,
							'PATTERN_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_PATTERN_ID),
							NULL,
							FALSE,
							'GROWTH_PCT',
							UT.GET_LITERAL_FOR_NUMBER(p_GROWTH_PCT),
							NULL,
							FALSE);

END PUT_ACCOUNT_GROWTH_PATTERN;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_ACCOUNT_GROWTH_PATTERN
	(
	p_CASE_ID    IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE
	) AS
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	DELETE ACCOUNT_GROWTH
	WHERE CASE_ID = p_CASE_ID
		  AND ACCOUNT_ID = p_ACCOUNT_ID
		  AND BEGIN_DATE = p_BEGIN_DATE;

END REMOVE_ACCOUNT_GROWTH_PATTERN;
--------------------------------------------------------------------------------
PROCEDURE AGG_ACCOUNT_GROWTH_PATTERNS
	(
	p_AGGREGATE_ID IN NUMBER,
	p_ACCOUNT_NAME OUT VARCHAR2,
	p_ESP_NAME     OUT VARCHAR2,
	p_POOL_NAME    OUT VARCHAR2,
	p_CURSOR       OUT GA.REFCURSOR
	) AS
v_ACCOUNT_ID	ACCOUNT.ACCOUNT_ID%TYPE;
BEGIN
	-- figure out owner account for security
	SELECT AG.ACCOUNT_ID, AC.ACCOUNT_NAME, ESP.ESP_NAME, P.POOL_NAME
	INTO v_ACCOUNT_ID, p_ACCOUNT_NAME, p_ESP_NAME, p_POOL_NAME
	FROM AGGREGATE_ACCOUNT_ESP AG, ACCOUNT AC, ENERGY_SERVICE_PROVIDER ESP, POOL P
	WHERE AG.AGGREGATE_ID = p_AGGREGATE_ID
		AND AC.ACCOUNT_ID = AG.ACCOUNT_ID
		AND ESP.ESP_ID = AG.ESP_ID
		AND P.POOL_ID = AG.POOL_ID
		AND ROWNUM=1;

	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, v_ACCOUNT_ID, EC.ED_ACCOUNT);

	OPEN p_CURSOR FOR
		SELECT C.CASE_NAME,
			   A.CASE_ID,
			   A.BEGIN_DATE,
			   A.END_DATE,
			   A.SERVICE_ACCOUNTS,
			   G.PATTERN_NAME,
			   A.PATTERN_ID,
			   A.GROWTH_PCT,
			   A.END_DATE,
			   A.ENTRY_DATE
		FROM AGGREGATE_ACCOUNT_GROWTH A, CASE_LABEL C, GROWTH_PATTERN G
		WHERE A.AGGREGATE_ID = p_AGGREGATE_ID
			AND C.CASE_ID = A.CASE_ID
			AND G.PATTERN_ID = A.PATTERN_ID
		ORDER BY C.CASE_NAME, A.BEGIN_DATE;

END AGG_ACCOUNT_GROWTH_PATTERNS;
--------------------------------------------------------------------------------
PROCEDURE PUT_AGG_ACCOUNT_GROWTH_PATTERN
	(
	p_CASE_ID            IN NUMBER,
	p_AGGREGATE_ID       IN NUMBER,
	p_BEGIN_DATE         IN DATE,
	p_END_DATE           IN DATE,
	p_SERVICE_ACCOUNTS   IN NUMBER,
	p_PATTERN_ID         IN NUMBER,
	p_GROWTH_PCT         IN NUMBER,
	p_OLD_CASE_ID        IN NUMBER,
	p_OLD_BEGIN_DATE     IN DATE
	) AS
v_ACCOUNT_ID	ACCOUNT.ACCOUNT_ID%TYPE;
BEGIN
	-- figure out owner account for security
	SELECT ACCOUNT_ID
	INTO v_ACCOUNT_ID
	FROM AGGREGATE_ACCOUNT_ESP
	WHERE AGGREGATE_ID = p_AGGREGATE_ID
		AND ROWNUM=1;

	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, v_ACCOUNT_ID, EC.ED_ACCOUNT);

	UT.PUT_TEMPORAL_DATA_UI('AGGREGATE_ACCOUNT_GROWTH',
							p_BEGIN_DATE,
							p_END_DATE,
							p_OLD_BEGIN_DATE,
							TRUE,
							'CASE_ID',
							UT.GET_LITERAL_FOR_NUMBER(NVL(p_CASE_ID,GA.BASE_CASE_ID)),
							UT.GET_LITERAL_FOR_NUMBER(p_OLD_CASE_ID),
							TRUE,
							'AGGREGATE_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_AGGREGATE_ID),
							UT.GET_LITERAL_FOR_NUMBER(p_AGGREGATE_ID),
							TRUE,
							'SERVICE_ACCOUNTS',
							UT.GET_LITERAL_FOR_NUMBER(p_SERVICE_ACCOUNTS),
							NULL,
							FALSE,
							'PATTERN_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_PATTERN_ID),
							NULL,
							FALSE,
							'GROWTH_PCT',
							UT.GET_LITERAL_FOR_NUMBER(p_GROWTH_PCT),
							NULL,
							FALSE);

END PUT_AGG_ACCOUNT_GROWTH_PATTERN;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_AGG_ACCT_GROWTH_PATTERN
	(
	p_CASE_ID    IN NUMBER,
	p_AGGREGATE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE
	) AS
v_ACCOUNT_ID	ACCOUNT.ACCOUNT_ID%TYPE;
BEGIN
	-- figure out owner account for security
	SELECT ACCOUNT_ID
	INTO v_ACCOUNT_ID
	FROM AGGREGATE_ACCOUNT_ESP
	WHERE AGGREGATE_ID = p_AGGREGATE_ID
		AND ROWNUM=1;

	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, v_ACCOUNT_ID, EC.ED_ACCOUNT);

	DELETE AGGREGATE_ACCOUNT_GROWTH
	WHERE CASE_ID = p_CASE_ID
		  AND AGGREGATE_ID = p_AGGREGATE_ID
		  AND BEGIN_DATE = p_BEGIN_DATE;

END REMOVE_AGG_ACCT_GROWTH_PATTERN;
--------------------------------------------------------------------------------
PROCEDURE ACCOUNT_SCHEDULE_GROUPS
    (
    p_ACCOUNT_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

    OPEN p_CURSOR FOR
        SELECT A.ACCOUNT_ID,
			B.SCHEDULE_GROUP_NAME,
            A.SCHEDULE_GROUP_ID,
            A.BEGIN_DATE,
            A.END_DATE,
            A.ENTRY_DATE
        FROM ACCOUNT_SCHEDULE_GROUP A, SCHEDULE_GROUP B
        WHERE A.ACCOUNT_ID = p_ACCOUNT_ID
		  AND A.SCHEDULE_GROUP_ID = B.SCHEDULE_GROUP_ID
        ORDER BY A.BEGIN_DATE, B.SCHEDULE_GROUP_NAME;

END ACCOUNT_SCHEDULE_GROUPS;
--------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_SCHEDULE_GROUP
    (
    p_ACCOUNT_ID IN NUMBER,
    p_SCHEDULE_GROUP_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_OLD_BEGIN_DATE IN DATE
    ) AS

	v_METER_TYPE SCHEDULE_GROUP.METER_TYPE%TYPE;
	v_ACCT_METER_TYPE ACCOUNT.ACCOUNT_METER_TYPE%TYPE;

BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	SELECT SG.METER_TYPE
	INTO v_METER_TYPE
	FROM SCHEDULE_GROUP SG
	WHERE SG.SCHEDULE_GROUP_ID = p_SCHEDULE_GROUP_ID;

	SELECT A.ACCOUNT_METER_TYPE
	INTO v_ACCT_METER_TYPE
	FROM ACCOUNT A
	WHERE A.ACCOUNT_ID = p_ACCOUNT_ID;

	IF UPPER(NVL(v_METER_TYPE, 'EITHER')) NOT IN (UPPER(v_ACCT_METER_TYPE), 'EITHER', '?') THEN
		ERRS.RAISE(MSGCODES.c_ERR_ARGUMENT, TEXT_UTIL.TO_CHAR_ENTITY(p_ACCOUNT_ID, EC.ED_ACCOUNT, TRUE) ||
			' cannot be assigned to ' || TEXT_UTIL.TO_CHAR_ENTITY(p_SCHEDULE_GROUP_ID, EC.ED_SCHEDULE_GROUP, TRUE) ||
			' because it has a meter type of ' || v_METER_TYPE || '.');
	END IF;

    UT.PUT_TEMPORAL_DATA_UI('ACCOUNT_SCHEDULE_GROUP',
							p_BEGIN_DATE,
							p_END_DATE,
							p_OLD_BEGIN_DATE,
							TRUE,
							'ACCOUNT_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
							UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
							TRUE,
							'SCHEDULE_GROUP_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_SCHEDULE_GROUP_ID),
							NULL,
							FALSE);

END PUT_ACCOUNT_SCHEDULE_GROUP;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_ACCOUNT_SCHEDULE_GROUP
    (
    p_ACCOUNT_ID IN NUMBER,
    p_BEGIN_DATE IN DATE
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

    DELETE ACCOUNT_SCHEDULE_GROUP
    WHERE ACCOUNT_ID = p_ACCOUNT_ID
        AND BEGIN_DATE = p_BEGIN_DATE;

END REMOVE_ACCOUNT_SCHEDULE_GROUP;
--------------------------------------------------------------------------------
PROCEDURE ACCOUNT_ANCILLARY_SERVICES
    (
    p_ACCOUNT_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

    OPEN p_CURSOR FOR
        SELECT A.ACCOUNT_ID,
			B.ANCILLARY_SERVICE_NAME,
            A.ANCILLARY_SERVICE_ID,
            A.BEGIN_DATE,
            A.END_DATE,
            A.SERVICE_VAL,
            A.ENTRY_DATE
        FROM ACCOUNT_ANCILLARY_SERVICE A, ANCILLARY_SERVICE B
        WHERE ACCOUNT_ID = p_ACCOUNT_ID
		  AND A.ANCILLARY_SERVICE_ID = B.ANCILLARY_SERVICE_ID
        ORDER BY B.ANCILLARY_SERVICE_NAME, A.BEGIN_DATE;

END ACCOUNT_ANCILLARY_SERVICES;
--------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_ANCILLARY_SERVICE
    (
    p_ACCOUNT_ID IN NUMBER,
    p_ANCILLARY_SERVICE_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_SERVICE_VAL IN NUMBER,
    p_OLD_ANCILLARY_SERVICE_ID IN NUMBER,
    p_OLD_BEGIN_DATE IN DATE
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

    UT.PUT_TEMPORAL_DATA_UI('ACCOUNT_ANCILLARY_SERVICE',
							p_BEGIN_DATE,
							p_END_DATE,
							p_OLD_BEGIN_DATE,
							TRUE,
							'ACCOUNT_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
							UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
							TRUE,
							'ANCILLARY_SERVICE_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_ANCILLARY_SERVICE_ID),
							UT.GET_LITERAL_FOR_NUMBER(p_OLD_ANCILLARY_SERVICE_ID),
							TRUE,
							'SERVICE_VAL',
							UT.GET_LITERAL_FOR_NUMBER(p_SERVICE_VAL),
							NULL,
							FALSE);

END PUT_ACCOUNT_ANCILLARY_SERVICE;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_ACCOUNT_ANCILLARY_SERV
    (
    p_ACCOUNT_ID IN NUMBER,
    p_ANCILLARY_SERVICE_ID IN NUMBER,
    p_BEGIN_DATE IN DATE
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

    DELETE ACCOUNT_ANCILLARY_SERVICE
    WHERE ACCOUNT_ID = p_ACCOUNT_ID
        AND ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID
        AND BEGIN_DATE = p_BEGIN_DATE;

END REMOVE_ACCOUNT_ANCILLARY_SERV;
--------------------------------------------------------------------------------
PROCEDURE ACCT_ANC_SVC_SUBDAILY
    (
    p_ACCOUNT_ID IN NUMBER,
    p_TIME_ZONE IN VARCHAR,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

    OPEN p_CURSOR FOR
        SELECT A.ACCOUNT_ID,
			B.ANCILLARY_SERVICE_NAME,
            A.ANCILLARY_SERVICE_ID,
            FROM_CUT(A.BEGIN_DATE - 1/86400, p_TIME_ZONE) AS BEGIN_DATE,  -- Take off the second that we added when storing to the database
            FROM_CUT(A.END_DATE, p_TIME_ZONE) AS END_DATE,
            A.SERVICE_VAL,
            A.ENTRY_DATE
        FROM ACCOUNT_ANCILLARY_SERVICE A, ANCILLARY_SERVICE B
        WHERE ACCOUNT_ID = p_ACCOUNT_ID
		  AND A.ANCILLARY_SERVICE_ID = B.ANCILLARY_SERVICE_ID
        ORDER BY B.ANCILLARY_SERVICE_NAME, A.BEGIN_DATE;

END ACCT_ANC_SVC_SUBDAILY;
--------------------------------------------------------------------------------
PROCEDURE PUT_ACCT_ANC_SVC_SUBDAILY
    (
    p_ACCOUNT_ID IN NUMBER,
    p_ANCILLARY_SERVICE_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    P_SERVICE_VAL IN NUMBER,
    p_TIME_ZONE IN VARCHAR,
    p_OLD_ANCILLARY_SERVICE_ID IN NUMBER,
    p_OLD_BEGIN_DATE IN DATE
    ) AS
    v_OLD_BEGIN_DATE DATE;
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

    IF(p_OLD_BEGIN_DATE IS NOT NULL) THEN
        v_OLD_BEGIN_DATE := TO_CUT(p_OLD_BEGIN_DATE, p_TIME_ZONE) + 1/86400; -- Must add a second to because the begin_date is stored +1 second in the database
    END IF;


    UT.PUT_TEMPORAL_DATA_UI_SUBDAY('ACCOUNT_ANCILLARY_SERVICE',
							TO_CUT(p_BEGIN_DATE, p_TIME_ZONE),
							TO_CUT(p_END_DATE, p_TIME_ZONE),
							v_OLD_BEGIN_DATE,
							TRUE,
							'ACCOUNT_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
							UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
							TRUE,
							'ANCILLARY_SERVICE_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_ANCILLARY_SERVICE_ID),
							UT.GET_LITERAL_FOR_NUMBER(p_OLD_ANCILLARY_SERVICE_ID),
							TRUE,
							'SERVICE_VAL',
							UT.GET_LITERAL_FOR_NUMBER(p_SERVICE_VAL),
							NULL,
							FALSE);

END PUT_ACCT_ANC_SVC_SUBDAILY;
--------------------------------------------------------------------------------
PROCEDURE REM_ACCT_ANC_SVC_SUBDAILY
    (
    p_ACCOUNT_ID IN NUMBER,
    p_ANCILLARY_SERVICE_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_TIME_ZONE IN VARCHAR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);


    DELETE ACCOUNT_ANCILLARY_SERVICE
    WHERE ACCOUNT_ID = p_ACCOUNT_ID
        AND ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID
        AND BEGIN_DATE = TO_CUT(p_BEGIN_DATE, p_TIME_ZONE) + 1/86400; -- stored in database a second greater

END REM_ACCT_ANC_SVC_SUBDAILY;
--------------------------------------------------------------------------------
PROCEDURE ACCOUNT_PRODUCTS
    (
    p_ACCOUNT_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

    OPEN p_CURSOR FOR
		SELECT B.CASE_NAME,
			   A.CASE_ID,
			   A.ACCOUNT_ID,
			   C.PRODUCT_NAME,
			   A.PRODUCT_ID,
			   CASE A.PRODUCT_TYPE
				   WHEN 'R' THEN
					'Revenue'
				   WHEN 'C' THEN
					'Cost'
				   WHEN 'B' THEN
					'Billing'
				   ELSE
					NULL
			   END AS PRODUCT_TYPE,
			   A.BEGIN_DATE,
			   A.END_DATE,
			   A.ENTRY_DATE
		FROM ACCOUNT_PRODUCT A, CASE_LABEL B, PRODUCT C
		WHERE A.ACCOUNT_ID = P_ACCOUNT_ID
			  AND A.CASE_ID = B.CASE_ID
			  AND A.PRODUCT_ID = C.PRODUCT_ID
		ORDER BY B.CASE_NAME, A.BEGIN_DATE, A.PRODUCT_TYPE, C.PRODUCT_NAME;
END ACCOUNT_PRODUCTS;
--------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_PRODUCT
    (
    p_CASE_ID IN NUMBER,
    p_ACCOUNT_ID IN NUMBER,
    p_PRODUCT_ID IN NUMBER,
    p_PRODUCT_TYPE IN CHAR,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_OLD_CASE_ID IN NUMBER,
    p_OLD_PRODUCT_TYPE IN CHAR,
    p_OLD_BEGIN_DATE IN DATE
    ) AS
BEGIN
-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	UT.PUT_TEMPORAL_DATA_UI('ACCOUNT_PRODUCT',
							p_BEGIN_DATE,
							p_END_DATE,
							p_OLD_BEGIN_DATE,
							TRUE,
							'ACCOUNT_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
							UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
							TRUE,
							'CASE_ID',
							UT.GET_LITERAL_FOR_NUMBER(NVL(p_CASE_ID, GA.BASE_CASE_ID)),
							UT.GET_LITERAL_FOR_NUMBER(p_OLD_CASE_ID),
							TRUE,
							'PRODUCT_TYPE',
							UT.GET_LITERAL_FOR_STRING(SUBSTR(p_PRODUCT_TYPE,1,1)),
							UT.GET_LITERAL_FOR_STRING(SUBSTR(p_OLD_PRODUCT_TYPE,1,1)),
							TRUE,
							'PRODUCT_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_PRODUCT_ID),
							NULL,
							FALSE);

END PUT_ACCOUNT_PRODUCT;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_ACCOUNT_PRODUCT
    (
    p_CASE_ID IN NUMBER,
    p_ACCOUNT_ID IN NUMBER,
    p_PRODUCT_TYPE IN CHAR,
    p_BEGIN_DATE IN DATE
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

    DELETE ACCOUNT_PRODUCT
    WHERE CASE_ID = p_CASE_ID
        AND ACCOUNT_ID = p_ACCOUNT_ID
        AND PRODUCT_TYPE = SUBSTR(p_PRODUCT_TYPE,1,1)
        AND BEGIN_DATE = p_BEGIN_DATE;

END REMOVE_ACCOUNT_PRODUCT;
--------------------------------------------------------------------------------
PROCEDURE ACCOUNT_BILL_CYCLES
    (
    p_ACCOUNT_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

    OPEN p_CURSOR FOR
        SELECT A.ACCOUNT_ID,
            B.BILL_CYCLE_NAME,
			A.BILL_CYCLE_ID,
            A.BILL_CYCLE_ENTITY,
            A.BEGIN_DATE,
            A.END_DATE,
            A.ENTRY_DATE
        FROM ACCOUNT_BILL_CYCLE A, BILL_CYCLE B
        WHERE A.ACCOUNT_ID = p_ACCOUNT_ID
		  AND A.BILL_CYCLE_ID = B.BILL_CYCLE_ID
        ORDER BY A.BEGIN_DATE, B.BILL_CYCLE_NAME, A.BILL_CYCLE_ENTITY;

END ACCOUNT_BILL_CYCLES;
--------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_BILL_CYCLE
    (
    p_ACCOUNT_ID IN NUMBER,
    p_BILL_CYCLE_ID IN NUMBER,
    p_BILL_CYCLE_ENTITY IN VARCHAR2,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_OLD_BEGIN_DATE IN DATE
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

    UT.PUT_TEMPORAL_DATA_UI('ACCOUNT_BILL_CYCLE',
							p_BEGIN_DATE,
							p_END_DATE,
							p_OLD_BEGIN_DATE,
							TRUE,
							'ACCOUNT_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
							UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
							TRUE,
							'BILL_CYCLE_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_BILL_CYCLE_ID),
							NULL,
							FALSE,
							'BILL_CYCLE_ENTITY',
							UT.GET_LITERAL_FOR_STRING(p_BILL_CYCLE_ENTITY),
							NULL,
							FALSE);

END PUT_ACCOUNT_BILL_CYCLE;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_ACCOUNT_BILL_CYCLE
    (
    p_ACCOUNT_ID IN NUMBER,
    p_BEGIN_DATE IN DATE
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

    DELETE ACCOUNT_BILL_CYCLE
    WHERE ACCOUNT_ID = p_ACCOUNT_ID
        AND BEGIN_DATE = p_BEGIN_DATE;

END REMOVE_ACCOUNT_BILL_CYCLE;
--------------------------------------------------------------------------------
PROCEDURE ACCOUNT_CONTRACTS
    (
    p_ACCOUNT_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

    OPEN p_CURSOR FOR
        SELECT B.CONTRACT_NAME,
		    A.CONTRACT_ID,
            A.OWNER_ENTITY_ID AS ACCOUNT_ID,
            A.BEGIN_DATE,
            A.END_DATE,
            A.ENTRY_DATE
        FROM CONTRACT_ASSIGNMENT A, SERVICE_CONTRACT B
        WHERE A.ENTITY_DOMAIN_ID = EC.ED_ACCOUNT
		  AND A.OWNER_ENTITY_ID = p_ACCOUNT_ID
		  AND A.CONTRACT_ID = B.CONTRACT_ID
        ORDER BY A.BEGIN_DATE, B.CONTRACT_NAME;

END ACCOUNT_CONTRACTS;
--------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_CONTRACT
    (
    p_CONTRACT_ID IN NUMBER,
    p_ACCOUNT_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_OLD_CONTRACT_ID IN NUMBER,
    p_OLD_BEGIN_DATE IN DATE
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	UT.PUT_TEMPORAL_DATA_UI('CONTRACT_ASSIGNMENT',
							p_BEGIN_DATE,
							p_END_DATE,
							p_OLD_BEGIN_DATE,
							TRUE,
							'ENTITY_DOMAIN_ID',
							UT.GET_LITERAL_FOR_NUMBER(EC.ED_ACCOUNT),
							UT.GET_LITERAL_FOR_NUMBER(EC.ED_ACCOUNT),
							TRUE,
							'OWNER_ENTITY_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
							UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
							TRUE,
							'CONTRACT_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_CONTRACT_ID),
							UT.GET_LITERAL_FOR_NUMBER(p_OLD_CONTRACT_ID),
							TRUE);

END PUT_ACCOUNT_CONTRACT;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_ACCOUNT_CONTRACT
    (
    p_ACCOUNT_ID IN NUMBER,
    p_CONTRACT_ID IN NUMBER,
    p_BEGIN_DATE IN DATE
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

    DELETE CONTRACT_ASSIGNMENT
    WHERE ENTITY_DOMAIN_ID = EC.ED_ACCOUNT
        AND CONTRACT_ID = p_CONTRACT_ID
        AND OWNER_ENTITY_ID = p_ACCOUNT_ID
        AND BEGIN_DATE = p_BEGIN_DATE;

END REMOVE_ACCOUNT_CONTRACT;
--------------------------------------------------------------------------------
PROCEDURE ACCOUNT_DERS
    (
    p_ACCOUNT_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

    OPEN p_CURSOR FOR
        SELECT SL.SERVICE_LOCATION_ID,
		    SL.SERVICE_LOCATION_NAME,
			DER.DER_ID,
            DER.DER_NAME,
            DT.DER_TYPE_ID,
			DT.DER_TYPE_NAME,
            DER.BEGIN_DATE AS DER_BEGIN_DATE,
            DER.END_DATE AS DER_END_DATE,
			GET_ENROLLED_PROGRAMS(DER.DER_ID) AS ENROLLED_PROGRAMS
        FROM DISTRIBUTED_ENERGY_RESOURCE DER, ACCOUNT_SERVICE_LOCATION ASL,
		    SERVICE_LOCATION SL, DER_TYPE DT
        WHERE DER.SERVICE_LOCATION_ID = ASL.SERVICE_LOCATION_ID
		    AND ASL.SERVICE_LOCATION_ID = SL.SERVICE_LOCATION_ID
			AND DER.DER_TYPE_ID = DT.DER_TYPE_ID(+)
		    AND ASL.ACCOUNT_ID = p_ACCOUNT_ID;

END ACCOUNT_DERS;
--------------------------------------------------------------------------------
FUNCTION GET_ENROLLED_PROGRAMS
    (
    p_DER_ID IN NUMBER
    ) RETURN VARCHAR2 AS
	v_PROGRAM_IDS NUMBER_COLLECTION;
BEGIN

    SELECT PROGRAM_ID
	BULK COLLECT INTO v_PROGRAM_IDS
    FROM DER_PROGRAM DP
    WHERE DP.DER_ID = p_DER_ID;

	RETURN TEXT_UTIL.TO_CHAR_ENTITY_LIST(v_PROGRAM_IDS, EC.ED_PROGRAM, FALSE, FALSE);

END GET_ENROLLED_PROGRAMS;
--------------------------------------------------------------------------------
PROCEDURE SERVICE_LOCATION_MRSPS
    (
	p_SERVICE_LOCATION_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_SERVICE_LOCATION_ID, EC.ED_SERVICE_LOCATION);

    OPEN p_CURSOR FOR
        SELECT A.SERVICE_LOCATION_ID,
            B.MRSP_NAME,
			A.MRSP_ID,
            A.BEGIN_DATE,
            A.END_DATE,
            A.MRSP_ACCOUNT_NUMBER,
            A.METER_READ_CYCLE,
            A.ENTRY_DATE
        FROM SERVICE_LOCATION_MRSP A, MRSP B
        WHERE A.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
		  AND A.MRSP_ID = B.MRSP_ID
        ORDER BY A.BEGIN_DATE, B.MRSP_NAME;

END SERVICE_LOCATION_MRSPS;
--------------------------------------------------------------------------------
PROCEDURE PUT_SERVICE_LOCATION_MRSP
    (
    p_SERVICE_LOCATION_ID IN NUMBER,
    p_MRSP_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_MRSP_ACCOUNT_NUMBER IN VARCHAR2,
    p_METER_READ_CYCLE IN VARCHAR2,
    p_OLD_MRSP_ID IN NUMBER,
    p_OLD_BEGIN_DATE IN DATE
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_SERVICE_LOCATION_ID, EC.ED_SERVICE_LOCATION);

	UT.PUT_TEMPORAL_DATA_UI('SERVICE_LOCATION_MRSP',
		p_BEGIN_DATE,
		p_END_DATE,
		p_OLD_BEGIN_DATE,
		TRUE,
		'SERVICE_LOCATION_ID',
		UT.GET_LITERAL_FOR_NUMBER(p_SERVICE_LOCATION_ID),
		UT.GET_LITERAL_FOR_NUMBER(p_SERVICE_LOCATION_ID),
		TRUE,
		'MRSP_ID',
		UT.GET_LITERAL_FOR_NUMBER(p_MRSP_ID),
		UT.GET_LITERAL_FOR_NUMBER(p_OLD_MRSP_ID),
		TRUE,
		'MRSP_ACCOUNT_NUMBER', UT.GET_LITERAL_FOR_STRING(p_MRSP_ACCOUNT_NUMBER),NULL,FALSE,
		'METER_READ_CYCLE', UT.GET_LITERAL_FOR_STRING(p_METER_READ_CYCLE),NULL,FALSE);

END PUT_SERVICE_LOCATION_MRSP;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_SERVICE_LOCATION_MRSP
    (
    p_SERVICE_LOCATION_ID IN NUMBER,
    p_MRSP_ID IN NUMBER,
    p_BEGIN_DATE IN DATE
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_SERVICE_LOCATION_ID, EC.ED_SERVICE_LOCATION);

    DELETE SERVICE_LOCATION_MRSP
    WHERE SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
        AND MRSP_ID = p_MRSP_ID
        AND BEGIN_DATE = p_BEGIN_DATE;

END REMOVE_SERVICE_LOCATION_MRSP;
--------------------------------------------------------------------------------
PROCEDURE SERVICE_LOCATION_ACCOUNTS
    (
    p_SERVICE_LOCATION_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_SERVICE_LOCATION_ID, EC.ED_SERVICE_LOCATION);

    OPEN p_CURSOR FOR
        SELECT ACCOUNT_ID AS SL_ACCOUNT_ID,
            BEGIN_DATE,
            END_DATE,
            EDC_IDENTIFIER,
            ESP_IDENTIFIER
        FROM ACCOUNT_SERVICE_LOCATION
        WHERE SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
        ORDER BY BEGIN_DATE,
            ACCOUNT_ID;

END SERVICE_LOCATION_ACCOUNTS;
--------------------------------------------------------------------------------
PROCEDURE PUT_SERVICE_LOCATION_ACCOUNT
    (
    p_SL_ACCOUNT_ID IN NUMBER,
    p_SERVICE_LOCATION_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_EDC_IDENTIFIER IN VARCHAR2,
    p_ESP_IDENTIFIER IN VARCHAR2,
    p_OLD_ACCOUNT_ID IN NUMBER,
    p_OLD_BEGIN_DATE IN DATE
    ) AS
v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_SERVICE_LOCATION_ID, EC.ED_SERVICE_LOCATION);

    v_KEY_NEW('SERVICE_LOCATION_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SERVICE_LOCATION_ID);
    v_KEY_OLD('SERVICE_LOCATION_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SERVICE_LOCATION_ID);
    v_DATA('ACCOUNT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SL_ACCOUNT_ID);
    v_DATA('EDC_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_EDC_IDENTIFIER);
    v_DATA('ESP_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_ESP_IDENTIFIER);

    UT.PUT_TEMPORAL_DATA_UI('ACCOUNT_SERVICE_LOCATION',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

END PUT_SERVICE_LOCATION_ACCOUNT;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_SRVC_LOC_ACCOUNT
    (
    p_SL_ACCOUNT_ID IN NUMBER,
    p_SERVICE_LOCATION_ID IN NUMBER,
    p_BEGIN_DATE IN DATE
    ) AS
	v_COUNT NUMBER;
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_SERVICE_LOCATION_ID, EC.ED_SERVICE_LOCATION);

	SELECT COUNT(SERVICE_LOCATION_ID) INTO v_COUNT
		FROM ACCOUNT_SERVICE_LOCATION
		WHERE SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID;

	IF v_COUNT > 1 THEN
    	DELETE ACCOUNT_SERVICE_LOCATION
    	WHERE ACCOUNT_ID = p_SL_ACCOUNT_ID
        	AND SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
        	AND BEGIN_DATE = p_BEGIN_DATE;
	ELSE
		ERRS.RAISE(MSGCODES.c_ERR_CANNOT_ORPHAN_ENTITY);
	END IF;

END REMOVE_SRVC_LOC_ACCOUNT;
--------------------------------------------------------------------------------
PROCEDURE SERVICE_LOCATION_DERS
    (
    p_SERVICE_LOCATION_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_SERVICE_LOCATION_ID, EC.ED_SERVICE_LOCATION);

    OPEN p_CURSOR FOR
        SELECT D.DER_ID,
            D.DER_NAME,
			D.DER_TYPE_ID,
            T.DER_TYPE_NAME,
            D.BEGIN_DATE,
            D.END_DATE
        FROM DISTRIBUTED_ENERGY_RESOURCE D, DER_TYPE T
        WHERE D.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
		    AND D.DER_TYPE_ID = T.DER_TYPE_ID(+)
        ORDER BY D.BEGIN_DATE, D.DER_NAME;

END SERVICE_LOCATION_DERS;
--------------------------------------------------------------------------------
PROCEDURE COPY_ENTITY
	(
	p_ENTITY_TYPE IN VARCHAR2,
	p_OLD_ACCOUNT_ID IN NUMBER,
	p_ACCOUNT_ID  IN NUMBER,
	p_OLD_SERVICE_LOCATION_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_DER_ID IN NUMBER,
	p_SL_BEGIN_DATE IN DATE,
	p_METER_BEGIN_DATE IN DATE,
	p_NEW_ENTITY_ID OUT NUMBER
	) AS
v_OLD_PARENT_ID 	NUMBER(9);
v_NEW_CHILD_ID 		NUMBER(9);
v_NEW_ENTITY_NAME 	VARCHAR2(1000);
v_ACCOUNT_REC 		ACCOUNT%ROWTYPE;
v_SRV_LOC_REC 		SERVICE_LOCATION%ROWTYPE;
v_METER_REC   		METER%ROWTYPE;
v_DER_REC			DISTRIBUTED_ENERGY_RESOURCE%ROWTYPE;
v_AGG_ID			NUMBER(9);
v_TOU_UF_ID			NUMBER(9);
BEGIN
	IF P_ENTITY_TYPE = 'ACCOUNT' THEN

		IO.GET_ACCOUNT(p_ACCOUNT_ID,
			v_ACCOUNT_REC.ACCOUNT_NAME,
			v_ACCOUNT_REC.ACCOUNT_ALIAS,
			v_ACCOUNT_REC.ACCOUNT_DESC,
			v_ACCOUNT_REC.ACCOUNT_DUNS_NUMBER,
			v_ACCOUNT_REC.ACCOUNT_EXTERNAL_IDENTIFIER,
			v_ACCOUNT_REC.ACCOUNT_MODEL_OPTION,
			v_ACCOUNT_REC.ACCOUNT_SIC_CODE,
			v_ACCOUNT_REC.ACCOUNT_METER_TYPE,
			v_ACCOUNT_REC.ACCOUNT_METER_EXT_IDENTIFIER,
			v_ACCOUNT_REC.ACCOUNT_DISPLAY_NAME,
			v_ACCOUNT_REC.ACCOUNT_BILL_OPTION,
			v_ACCOUNT_REC.ACCOUNT_ROLLUP_ID,
			v_ACCOUNT_REC.IS_EXTERNAL_INTERVAL_USAGE,
			v_ACCOUNT_REC.IS_EXTERNAL_BILLED_USAGE,
			v_ACCOUNT_REC.IS_AGGREGATE_ACCOUNT,
			v_ACCOUNT_REC.IS_UFE_PARTICIPANT,
			v_ACCOUNT_REC.IS_CREATE_SETTLEMENT_PROFILE,
			v_ACCOUNT_REC.IS_EXTERNAL_FORECAST,
            v_ACCOUNT_REC.IS_SUB_AGGREGATE,
			v_ACCOUNT_REC.TX_SERVICE_TYPE_ID,
			v_ACCOUNT_REC.USE_TOU_USAGE_FACTOR,
			v_ACCOUNT_REC.MODEL_ID);

		v_NEW_ENTITY_NAME := ENTITY_UTIL.GET_COPY_OF_ENTITY_NAME(v_ACCOUNT_REC.ACCOUNT_NAME,EC.ED_ACCOUNT);

		IO.PUT_ACCOUNT(p_NEW_ENTITY_ID,
			v_NEW_ENTITY_NAME,
			v_ACCOUNT_REC.ACCOUNT_ALIAS,
			v_ACCOUNT_REC.ACCOUNT_DESC,
			0,
			v_ACCOUNT_REC.ACCOUNT_DUNS_NUMBER,
			v_ACCOUNT_REC.ACCOUNT_EXTERNAL_IDENTIFIER,
			v_ACCOUNT_REC.ACCOUNT_MODEL_OPTION,
			v_ACCOUNT_REC.ACCOUNT_SIC_CODE,
			v_ACCOUNT_REC.ACCOUNT_METER_TYPE,
			v_ACCOUNT_REC.ACCOUNT_METER_EXT_IDENTIFIER,
			v_ACCOUNT_REC.ACCOUNT_DISPLAY_NAME,
			v_ACCOUNT_REC.ACCOUNT_BILL_OPTION,
			v_ACCOUNT_REC.ACCOUNT_ROLLUP_ID,
			v_ACCOUNT_REC.IS_EXTERNAL_INTERVAL_USAGE,
			v_ACCOUNT_REC.IS_EXTERNAL_BILLED_USAGE,
			v_ACCOUNT_REC.IS_AGGREGATE_ACCOUNT,
			v_ACCOUNT_REC.IS_UFE_PARTICIPANT,
			v_ACCOUNT_REC.IS_CREATE_SETTLEMENT_PROFILE,
			v_ACCOUNT_REC.IS_EXTERNAL_FORECAST,
            v_ACCOUNT_REC.IS_SUB_AGGREGATE,
			v_ACCOUNT_REC.TX_SERVICE_TYPE_ID,
			v_ACCOUNT_REC.USE_TOU_USAGE_FACTOR,
			v_ACCOUNT_REC.MODEL_ID);

		--Copy the ACCOUNT_STATUS associative relationship
		INSERT INTO ACCOUNT_STATUS
		  (ACCOUNT_ID, BEGIN_DATE, END_DATE, STATUS_NAME, ENTRY_DATE)
		SELECT p_NEW_ENTITY_ID, BEGIN_DATE, END_DATE, STATUS_NAME, SYSDATE
		FROM ACCOUNT_STATUS
		WHERE ACCOUNT_ID = p_ACCOUNT_ID;

		--Copy the ACCOUNT_EDC associative relationship
		INSERT INTO ACCOUNT_EDC
		  (ACCOUNT_ID, EDC_ID, BEGIN_DATE, EDC_ACCOUNT_NUMBER, EDC_RATE_CLASS, EDC_STRATA, END_DATE, ENTRY_DATE)
		SELECT p_NEW_ENTITY_ID, EDC_ID, BEGIN_DATE, EDC_ACCOUNT_NUMBER, EDC_RATE_CLASS, EDC_STRATA, END_DATE, SYSDATE
		FROM ACCOUNT_EDC
		WHERE ACCOUNT_ID = p_ACCOUNT_ID;

		--Copy the ACCOUNT_ESP associative relationship
		INSERT INTO ACCOUNT_ESP
		  (ACCOUNT_ID, ESP_ID, POOL_ID, BEGIN_DATE, END_DATE, ESP_ACCOUNT_NUMBER, ENTRY_DATE)
		SELECT p_NEW_ENTITY_ID, ESP_ID, POOL_ID, BEGIN_DATE, END_DATE, ESP_ACCOUNT_NUMBER, SYSDATE
		FROM ACCOUNT_ESP
		WHERE ACCOUNT_ID = p_ACCOUNT_ID;

		--Copy the AGGREGATE_ACCOUNT_ESP associative relationship
		FOR v_REC IN (SELECT AGG.ACCOUNT_ID, AGG.ESP_ID, AGG.POOL_ID, AGG.BEGIN_DATE,
							AGG.END_DATE, AGG.AGGREGATE_ID, AGG.ENTRY_DATE
						FROM AGGREGATE_ACCOUNT_ESP AGG
						WHERE AGG.ACCOUNT_ID = p_ACCOUNT_ID) LOOP

			SELECT MAX(AGG.AGGREGATE_ID)
			INTO v_AGG_ID
			FROM AGGREGATE_ACCOUNT_ESP AGG
			WHERE AGG.ACCOUNT_ID = p_NEW_ENTITY_ID
				AND AGG.ESP_ID = v_REC.ESP_ID
				AND AGG.POOL_ID = v_REC.POOL_ID;

			INSERT INTO AGGREGATE_ACCOUNT_ESP (ACCOUNT_ID, ESP_ID, POOL_ID,
				BEGIN_DATE, END_DATE, AGGREGATE_ID, ENTRY_DATE)
			VALUES (p_NEW_ENTITY_ID, v_REC.ESP_ID, v_REC.POOL_ID, v_REC.BEGIN_DATE,
				v_REC.END_DATE, NVL(v_AGG_ID, OID.NEXTVAL), SYSDATE);
		END LOOP;

		--Copy the ACCOUNT_CALENDAR associative relationship
		INSERT INTO ACCOUNT_CALENDAR
		  (CASE_ID, ACCOUNT_ID, CALENDAR_ID, CALENDAR_TYPE, BEGIN_DATE, END_DATE, ENTRY_DATE)
		SELECT CASE_ID, p_NEW_ENTITY_ID, CALENDAR_ID, CALENDAR_TYPE, BEGIN_DATE, END_DATE, SYSDATE
		FROM ACCOUNT_CALENDAR
		WHERE ACCOUNT_ID = p_ACCOUNT_ID;

		--Copy the ACCOUNT_LOSS_FACTOR associative relationship
		INSERT INTO ACCOUNT_LOSS_FACTOR
		  (CASE_ID, ACCOUNT_ID, LOSS_FACTOR_ID, BEGIN_DATE, END_DATE, ENTRY_DATE)
		SELECT CASE_ID, p_NEW_ENTITY_ID, LOSS_FACTOR_ID, BEGIN_DATE, END_DATE, SYSDATE
		FROM ACCOUNT_LOSS_FACTOR
		WHERE ACCOUNT_ID = p_ACCOUNT_ID;

		--Copy the ACCOUNT_USAGE_FACTOR associative relationship
		INSERT INTO ACCOUNT_USAGE_FACTOR
		  (CASE_ID, ACCOUNT_ID, BEGIN_DATE, END_DATE, FACTOR_VAL, ENTRY_DATE)
		SELECT CASE_ID, p_NEW_ENTITY_ID, BEGIN_DATE, END_DATE, FACTOR_VAL, SYSDATE
		FROM ACCOUNT_USAGE_FACTOR
		WHERE ACCOUNT_ID = p_ACCOUNT_ID;

		--Copy the ACCOUNT_SCHEDULE_GROUP associative relationship
		INSERT INTO ACCOUNT_SCHEDULE_GROUP
		  (ACCOUNT_ID, SCHEDULE_GROUP_ID, BEGIN_DATE, END_DATE, ENTRY_DATE)
		SELECT p_NEW_ENTITY_ID, SCHEDULE_GROUP_ID, BEGIN_DATE, END_DATE, SYSDATE
		FROM ACCOUNT_SCHEDULE_GROUP
		WHERE ACCOUNT_ID = p_ACCOUNT_ID;

		--Copy the ACCOUNT_GROUP_ASSIGNMENT associative relationship
		INSERT INTO ACCOUNT_GROUP_ASSIGNMENT
		  (ACCOUNT_ID, ACCOUNT_GROUP_ID, ASSIGNMENT_CATEGORY)
		SELECT p_NEW_ENTITY_ID, ACCOUNT_GROUP_ID, ASSIGNMENT_CATEGORY
		FROM ACCOUNT_GROUP_ASSIGNMENT
		WHERE ACCOUNT_ID = p_ACCOUNT_ID;

		--Copy the ACCOUNT_ANCILLARY_SERVICE associative relationship
		INSERT INTO ACCOUNT_ANCILLARY_SERVICE
		  (ACCOUNT_ID, ANCILLARY_SERVICE_ID, BEGIN_DATE, END_DATE, SERVICE_VAL, ENTRY_DATE)
		SELECT p_NEW_ENTITY_ID, ANCILLARY_SERVICE_ID, BEGIN_DATE, END_DATE, SERVICE_VAL, SYSDATE
		FROM ACCOUNT_ANCILLARY_SERVICE
		WHERE ACCOUNT_ID = p_ACCOUNT_ID;

		--Copy the ACCOUNT_PRODUCT associative relationship
		INSERT INTO ACCOUNT_PRODUCT
		  (CASE_ID, ACCOUNT_ID, PRODUCT_ID, PRODUCT_TYPE, BEGIN_DATE, END_DATE, ENTRY_DATE)
		SELECT CASE_ID, p_NEW_ENTITY_ID, PRODUCT_ID, PRODUCT_TYPE, BEGIN_DATE, END_DATE, SYSDATE
		FROM ACCOUNT_PRODUCT
		WHERE ACCOUNT_ID = p_ACCOUNT_ID;

		--Copy the DATA_VALIDATION_RULE associative relationship
		INSERT INTO DATA_VALIDATION_RULE
			(ENTITY_DOMAIN_ID, ENTITY_ID, BEGIN_DATE, END_DATE, MIN_VAL, MAX_VAL, HOUR_COMPARE, HOUR_VAL, DISALLOW_NEG, ENTRY_DATE)
		SELECT ENTITY_DOMAIN_ID, p_NEW_ENTITY_ID, BEGIN_DATE, END_DATE, MIN_VAL, MAX_VAL, HOUR_COMPARE, HOUR_VAL, DISALLOW_NEG, SYSDATE
		FROM DATA_VALIDATION_RULE A
		WHERE ENTITY_DOMAIN_ID = EC.ED_ACCOUNT
		  AND ENTITY_ID = p_ACCOUNT_ID;

		--Copy the ACCOUNT_BILL_CYCLE associative relationship
		INSERT INTO ACCOUNT_BILL_CYCLE
		  (ACCOUNT_ID, BILL_CYCLE_ID, BILL_CYCLE_ENTITY, BEGIN_DATE, END_DATE, ENTRY_DATE)
		SELECT p_NEW_ENTITY_ID, BILL_CYCLE_ID, BILL_CYCLE_ENTITY, BEGIN_DATE, END_DATE, SYSDATE
		FROM ACCOUNT_BILL_CYCLE
		WHERE ACCOUNT_ID = p_ACCOUNT_ID;

		--Copy the CONTRACT_ASSIGNMENT associative relationship
		INSERT INTO CONTRACT_ASSIGNMENT
		  (CONTRACT_ID, ENTITY_DOMAIN_ID, OWNER_ENTITY_ID, BEGIN_DATE, END_DATE, ENTITY_NAME, ENTRY_DATE)
		SELECT CONTRACT_ID, ENTITY_DOMAIN_ID, p_NEW_ENTITY_ID, BEGIN_DATE, END_DATE, ENTITY_NAME, SYSDATE
		FROM CONTRACT_ASSIGNMENT
		WHERE OWNER_ENTITY_ID = p_ACCOUNT_ID
		  AND ENTITY_DOMAIN_ID = EC.ED_ACCOUNT;

		-- COPY ACCOUNT_TOU_USAGE_FACTOR
		FOR v_REC IN (SELECT ATUF.ACCOUNT_ID, ATUF.CASE_ID, ATUF.BEGIN_DATE, ATUF.END_DATE,
							ATUF.TEMPLATE_ID, ATUF.TOU_USAGE_FACTOR_ID, ATUF.ENTRY_DATE
						FROM ACCOUNT_TOU_USAGE_FACTOR ATUF
						WHERE ATUF.ACCOUNT_ID = p_ACCOUNT_ID ) LOOP

			SELECT OID.NEXTVAL
			INTO v_TOU_UF_ID
			FROM DUAL;

			INSERT INTO ACCOUNT_TOU_USAGE_FACTOR (ACCOUNT_ID, CASE_ID, BEGIN_DATE, END_DATE,
							TEMPLATE_ID, TOU_USAGE_FACTOR_ID, ENTRY_DATE)
			VALUES (p_NEW_ENTITY_ID, v_REC.CASE_ID, v_REC.BEGIN_DATE, v_REC.END_DATE,
					v_REC.TEMPLATE_ID, v_TOU_UF_ID, SYSDATE);

			INSERT INTO ACCOUNT_TOU_USG_FACTOR_PERIOD (TOU_USAGE_FACTOR_ID, PERIOD_ID,
				FACTOR_VAL, ENTRY_DATE)
			SELECT v_TOU_UF_ID, ATUFP.PERIOD_ID, ATUFP.FACTOR_VAL, SYSDATE
			FROM ACCOUNT_TOU_USG_FACTOR_PERIOD ATUFP
			WHERE ATUFP.TOU_USAGE_FACTOR_ID = v_REC.TOU_USAGE_FACTOR_ID;

		END LOOP;

		ENTITY_UTIL.COPY_COMMON_SUBTABS(EC.ED_ACCOUNT,
										p_ACCOUNT_ID,
										p_NEW_ENTITY_ID);

		-- Copy all child SERVICE_LOCATIONS, deep copy
		FOR v_SERV_LOC IN (SELECT * FROM ACCOUNT_SERVICE_LOCATION WHERE ACCOUNT_ID = p_ACCOUNT_ID) LOOP
			COPY_ENTITY('SERVICE_LOCATION', p_ACCOUNT_ID, p_NEW_ENTITY_ID, NULL, v_SERV_LOC.SERVICE_LOCATION_ID, NULL, NULL, v_SERV_LOC.BEGIN_DATE, NULL, v_NEW_CHILD_ID);
		END LOOP;

	ELSIF P_ENTITY_TYPE = 'SERVICE_LOCATION' THEN

		IO.GET_SERVICE_LOCATION(p_SERVICE_LOCATION_ID,
			v_SRV_LOC_REC.SERVICE_LOCATION_NAME,
			v_SRV_LOC_REC.SERVICE_LOCATION_ALIAS,
			v_SRV_LOC_REC.SERVICE_LOCATION_DESC,
			v_SRV_LOC_REC.LATITUDE,
			v_SRV_LOC_REC.LONGITUDE,
			v_SRV_LOC_REC.TIME_ZONE,
			v_SRV_LOC_REC.EXTERNAL_IDENTIFIER,
			v_SRV_LOC_REC.IS_EXTERNAL_BILLED_USAGE,
			v_SRV_LOC_REC.IS_METER_ALLOCATION,
			v_SRV_LOC_REC.SERVICE_POINT_ID,
			v_SRV_LOC_REC.WEATHER_STATION_ID,
			v_SRV_LOC_REC.BUSINESS_ROLLUP_ID,
			v_SRV_LOC_REC.GEOGRAPHIC_ROLLUP_ID,
			v_SRV_LOC_REC.SQUARE_FOOTAGE,
			v_SRV_LOC_REC.ANNUAL_CONSUMPTION,
			v_SRV_LOC_REC.SUMMER_CONSUMPTION,
			v_SRV_LOC_REC.SERVICE_ZONE_ID,
			v_SRV_LOC_REC.SUB_STATION_ID,
			v_SRV_LOC_REC.FEEDER_ID,
			v_SRV_LOC_REC.FEEDER_SEGMENT_ID);

		v_NEW_ENTITY_NAME := ENTITY_UTIL.GET_COPY_OF_ENTITY_NAME(v_SRV_LOC_REC.SERVICE_LOCATION_NAME,EC.ED_SERVICE_LOCATION);

		IO.PUT_SERVICE_LOCATION(p_NEW_ENTITY_ID,
			v_NEW_ENTITY_NAME,
			v_SRV_LOC_REC.SERVICE_LOCATION_ALIAS,
			v_SRV_LOC_REC.SERVICE_LOCATION_DESC,
			0,
			v_SRV_LOC_REC.LATITUDE,
			v_SRV_LOC_REC.LONGITUDE,
			v_SRV_LOC_REC.TIME_ZONE,
			v_SRV_LOC_REC.EXTERNAL_IDENTIFIER,
			v_SRV_LOC_REC.IS_EXTERNAL_BILLED_USAGE,
			v_SRV_LOC_REC.IS_METER_ALLOCATION,
			v_SRV_LOC_REC.SERVICE_POINT_ID,
			v_SRV_LOC_REC.WEATHER_STATION_ID,
			v_SRV_LOC_REC.BUSINESS_ROLLUP_ID,
			v_SRV_LOC_REC.GEOGRAPHIC_ROLLUP_ID,
			v_SRV_LOC_REC.SQUARE_FOOTAGE,
			v_SRV_LOC_REC.ANNUAL_CONSUMPTION,
			v_SRV_LOC_REC.SUMMER_CONSUMPTION,
			v_SRV_LOC_REC.SERVICE_ZONE_ID,
			v_SRV_LOC_REC.SUB_STATION_ID,
			v_SRV_LOC_REC.FEEDER_ID,
			v_SRV_LOC_REC.FEEDER_SEGMENT_ID);

		-- Check the to see if we are being passed an OLD id. This occurs when doing a recursive deep copy.
		v_OLD_PARENT_ID := NVL(p_OLD_ACCOUNT_ID, p_ACCOUNT_ID);

		-- Copy the association to the parent ACCOUNT
		INSERT INTO ACCOUNT_SERVICE_LOCATION
			(ACCOUNT_ID, SERVICE_LOCATION_ID, BEGIN_DATE, END_DATE, EDC_IDENTIFIER, ESP_IDENTIFIER, ENTRY_DATE)
				SELECT p_ACCOUNT_ID, p_NEW_ENTITY_ID, BEGIN_DATE, END_DATE, EDC_IDENTIFIER, ESP_IDENTIFIER, SYSDATE
				FROM ACCOUNT_SERVICE_LOCATION A
				WHERE ACCOUNT_ID = v_OLD_PARENT_ID
				  AND SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
				  AND A.BEGIN_DATE = p_SL_BEGIN_DATE;

		-- Copy the SERVICE_LOCATION_MRSP associative relationship
		INSERT INTO SERVICE_LOCATION_MRSP
		  (SERVICE_LOCATION_ID, MRSP_ID, BEGIN_DATE, END_DATE, MRSP_ACCOUNT_NUMBER, METER_READ_CYCLE, ENTRY_DATE)
		SELECT p_NEW_ENTITY_ID, MRSP_ID, BEGIN_DATE, END_DATE, MRSP_ACCOUNT_NUMBER, METER_READ_CYCLE, SYSDATE
		FROM SERVICE_LOCATION_MRSP
		WHERE SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID;

		ENTITY_UTIL.COPY_COMMON_SUBTABS(EC.ED_SERVICE_LOCATION,
										p_SERVICE_LOCATION_ID,
										p_NEW_ENTITY_ID);

		-- Copy all child METERs, deep copy
		FOR v_METER IN (SELECT * FROM SERVICE_LOCATION_METER WHERE SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID) LOOP
			COPY_ENTITY('METER', p_OLD_ACCOUNT_ID, p_ACCOUNT_ID, p_SERVICE_LOCATION_ID, p_NEW_ENTITY_ID, v_METER.METER_ID, NULL, p_SL_BEGIN_DATE, v_METER.BEGIN_DATE, v_NEW_CHILD_ID);
   		END LOOP;

		FOR v_DER IN (SELECT * FROM DISTRIBUTED_ENERGY_RESOURCE WHERE SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID) LOOP
			COPY_ENTITY('DER', p_OLD_ACCOUNT_ID, p_ACCOUNT_ID, p_SERVICE_LOCATION_ID, p_NEW_ENTITY_ID, NULL, v_DER.DER_ID, p_SL_BEGIN_DATE, NULL, v_NEW_CHILD_ID);
		END LOOP;

	ELSIF P_ENTITY_TYPE = 'METER' THEN

		IO.GET_METER(v_METER_REC.MRSP_ID,
			p_METER_ID,
			v_METER_REC.METER_NAME,
			v_METER_REC.METER_ALIAS,
			v_METER_REC.METER_DESC,
			v_METER_REC.METER_EXTERNAL_IDENTIFIER,
			v_METER_REC.METER_STATUS,
			v_METER_REC.METER_INTERVAL,
			v_METER_REC.METER_TYPE,
			v_METER_REC.METER_UNIT,
			v_METER_REC.IS_EXTERNAL_INTERVAL_USAGE,
			v_METER_REC.IS_EXTERNAL_BILLED_USAGE,
			v_METER_REC.IS_EXTERNAL_FORECAST,
			v_METER_REC.USE_TOU_USAGE_FACTOR);

		v_NEW_ENTITY_NAME := ENTITY_UTIL.GET_COPY_OF_ENTITY_NAME(v_METER_REC.METER_NAME,EC.ED_METER);

		IO.PUT_METER(p_NEW_ENTITY_ID,
			v_METER_REC.MRSP_ID,
			v_NEW_ENTITY_NAME,
			v_METER_REC.METER_ALIAS,
			v_METER_REC.METER_DESC,
			0,
			v_METER_REC.METER_EXTERNAL_IDENTIFIER,
			v_METER_REC.METER_STATUS,
			v_METER_REC.METER_INTERVAL,
			v_METER_REC.METER_TYPE,
			v_METER_REC.METER_UNIT,
			v_METER_REC.IS_EXTERNAL_INTERVAL_USAGE,
			v_METER_REC.IS_EXTERNAL_BILLED_USAGE,
			v_METER_REC.IS_EXTERNAL_FORECAST,
			v_METER_REC.USE_TOU_USAGE_FACTOR);

		-- Check the to see if we are being passed an OLD id. This occurs when doing a recursive deep copy.
		v_OLD_PARENT_ID := NVL(p_OLD_SERVICE_LOCATION_ID, p_SERVICE_LOCATION_ID);

		-- Copy the association to the parent SERVICE_LOCATION
		INSERT INTO SERVICE_LOCATION_METER
			(SERVICE_LOCATION_ID, METER_ID, BEGIN_DATE, END_DATE, IS_ESTIMATED_END_DATE, EDC_IDENTIFIER, ESP_IDENTIFIER, NEXT_ACTION_DATE, EDC_RATE_CLASS, ENTRY_DATE)
		SELECT p_SERVICE_LOCATION_ID, p_NEW_ENTITY_ID, BEGIN_DATE, END_DATE, IS_ESTIMATED_END_DATE, EDC_IDENTIFIER, ESP_IDENTIFIER, NEXT_ACTION_DATE, EDC_RATE_CLASS, SYSDATE
		FROM SERVICE_LOCATION_METER A
		WHERE A.SERVICE_LOCATION_ID = v_OLD_PARENT_ID
		  AND A.METER_ID = p_METER_ID
		  AND A.BEGIN_DATE = p_METER_BEGIN_DATE;

		-- Copy the METER_CALENDAR associative relationship
		INSERT INTO METER_CALENDAR
			(CASE_ID, METER_ID, CALENDAR_ID, CALENDAR_TYPE, BEGIN_DATE, END_DATE, ENTRY_DATE)
		SELECT CASE_ID, p_NEW_ENTITY_ID, CALENDAR_ID, CALENDAR_TYPE, BEGIN_DATE, END_DATE, SYSDATE
		FROM METER_CALENDAR
		WHERE METER_ID = p_METER_ID;

		-- Copy the METER_LOSS_FACTOR associative relationship
		INSERT INTO METER_LOSS_FACTOR
			(CASE_ID, METER_ID, LOSS_FACTOR_ID, BEGIN_DATE, END_DATE, ENTRY_DATE)
		SELECT CASE_ID, p_NEW_ENTITY_ID, LOSS_FACTOR_ID, BEGIN_DATE, END_DATE, SYSDATE
		FROM METER_LOSS_FACTOR
		WHERE METER_ID = p_METER_ID;

		-- Copy the METER_USAGE_FACTOR associative relationship
		INSERT INTO METER_USAGE_FACTOR
			(CASE_ID, METER_ID, BEGIN_DATE, END_DATE, FACTOR_VAL, ENTRY_DATE)
		SELECT CASE_ID, p_NEW_ENTITY_ID, BEGIN_DATE, END_DATE, FACTOR_VAL, SYSDATE
		FROM METER_USAGE_FACTOR
		WHERE METER_ID = p_METER_ID;

		-- Copy the METER_SCHEDULE_GROUP associative relationship
		INSERT INTO METER_SCHEDULE_GROUP
			(METER_ID, BEGIN_DATE, END_DATE, SCHEDULE_GROUP_ID, ENTRY_DATE)
		SELECT p_NEW_ENTITY_ID, BEGIN_DATE, END_DATE, SCHEDULE_GROUP_ID, SYSDATE
		FROM METER_SCHEDULE_GROUP
		WHERE METER_ID = p_METER_ID;

		-- Copy the METER_ANCILLARY_SERVICE associative relationship
		INSERT INTO METER_ANCILLARY_SERVICE
			(METER_ID, ANCILLARY_SERVICE_ID, BEGIN_DATE, END_DATE, SERVICE_VAL, ENTRY_DATE)
		SELECT p_NEW_ENTITY_ID, ANCILLARY_SERVICE_ID, BEGIN_DATE, END_DATE, SERVICE_VAL, SYSDATE
		FROM METER_ANCILLARY_SERVICE
		WHERE METER_ID = p_METER_ID;

		-- Copy the METER_PRODUCT associative relationship
		INSERT INTO METER_PRODUCT
			(CASE_ID, METER_ID, PRODUCT_ID, PRODUCT_TYPE, BEGIN_DATE, END_DATE, ENTRY_DATE)
		SELECT CASE_ID, p_NEW_ENTITY_ID, PRODUCT_ID, PRODUCT_TYPE, BEGIN_DATE, END_DATE, SYSDATE
		FROM METER_PRODUCT
		WHERE METER_ID = p_METER_ID;

		-- Copy the DATA_VALIDATION_RULE associative relationship
		INSERT INTO DATA_VALIDATION_RULE
			(ENTITY_DOMAIN_ID, ENTITY_ID, BEGIN_DATE, END_DATE, MIN_VAL, MAX_VAL, HOUR_COMPARE, HOUR_VAL, DISALLOW_NEG, ENTRY_DATE)
		SELECT ENTITY_DOMAIN_ID, p_NEW_ENTITY_ID, BEGIN_DATE, END_DATE, MIN_VAL, MAX_VAL, HOUR_COMPARE, HOUR_VAL, DISALLOW_NEG, SYSDATE
		FROM DATA_VALIDATION_RULE A
		WHERE ENTITY_DOMAIN_ID = EC.ED_METER
		  AND ENTITY_ID = p_METER_ID;

		-- Copy the  METER_BILL_CYCLE associative relationship
		INSERT INTO METER_BILL_CYCLE
		  (METER_ID, BILL_CYCLE_ID, BILL_CYCLE_ENTITY, BEGIN_DATE, END_DATE, ENTRY_DATE)
		SELECT p_NEW_ENTITY_ID, BILL_CYCLE_ID, BILL_CYCLE_ENTITY, BEGIN_DATE, END_DATE, SYSDATE
		FROM METER_BILL_CYCLE
		WHERE METER_ID = p_METER_ID;

		-- COPY METER_TOU_USAGE_FACTOR
		FOR v_REC IN (SELECT MTUF.METER_ID, MTUF.CASE_ID, MTUF.BEGIN_DATE, MTUF.END_DATE,
							MTUF.TEMPLATE_ID, MTUF.TOU_USAGE_FACTOR_ID, MTUF.ENTRY_DATE
						FROM METER_TOU_USAGE_FACTOR MTUF
						WHERE MTUF.METER_ID = p_METER_ID ) LOOP

			SELECT OID.NEXTVAL
			INTO v_TOU_UF_ID
			FROM DUAL;

			INSERT INTO METER_TOU_USAGE_FACTOR (METER_ID, CASE_ID, BEGIN_DATE, END_DATE,
							TEMPLATE_ID, TOU_USAGE_FACTOR_ID, ENTRY_DATE)
			VALUES (p_NEW_ENTITY_ID, v_REC.CASE_ID, v_REC.BEGIN_DATE, v_REC.END_DATE,
					v_REC.TEMPLATE_ID, v_TOU_UF_ID, SYSDATE);

			INSERT INTO METER_TOU_USAGE_FACTOR_PERIOD (TOU_USAGE_FACTOR_ID, PERIOD_ID,
				FACTOR_VAL, ENTRY_DATE)
			SELECT v_TOU_UF_ID, MTUFP.PERIOD_ID, MTUFP.FACTOR_VAL, SYSDATE
			FROM METER_TOU_USAGE_FACTOR_PERIOD MTUFP
			WHERE MTUFP.TOU_USAGE_FACTOR_ID = v_REC.TOU_USAGE_FACTOR_ID;
		END LOOP;

		ENTITY_UTIL.COPY_COMMON_SUBTABS(EC.ED_METER,
										p_METER_ID,
										p_NEW_ENTITY_ID);

	ELSIF p_ENTITY_TYPE = 'DER' THEN

		IO.GET_DER(p_DER_ID,
			v_DER_REC.DER_NAME,
			v_DER_REC.DER_ALIAS,
			v_DER_REC.DER_DESC,
			v_DER_REC.SERVICE_LOCATION_ID,
			v_DER_REC.DER_TYPE_ID,
			v_DER_REC.EXTERNAL_SYSTEM_ID,
			v_DER_REC.EXTERNAL_IDENTIFIER,
			v_DER_REC.BEGIN_DATE,
			v_DER_REC.END_DATE,
			v_DER_REC.SERIAL_NUMBER);

		v_NEW_ENTITY_NAME := ENTITY_UTIL.GET_COPY_OF_ENTITY_NAME(v_DER_REC.DER_NAME,
								EC.ED_DER);

		IO.PUT_DER(p_NEW_ENTITY_ID,
			v_NEW_ENTITY_NAME,
			v_DER_REC.DER_ALIAS,
			v_DER_REC.DER_DESC,
			0,
			p_SERVICE_LOCATION_ID,
			v_DER_REC.DER_TYPE_ID,
			v_DER_REC.EXTERNAL_SYSTEM_ID,
			v_DER_REC.EXTERNAL_IDENTIFIER,
			v_DER_REC.BEGIN_DATE,
			v_DER_REC.END_DATE,
			v_DER_REC.SERIAL_NUMBER);

		INSERT INTO DER_CALENDAR
			(DER_ID, BEGIN_DATE, END_DATE, CASE_ID, CALENDAR_ID, ENTRY_DATE)
		SELECT p_NEW_ENTITY_ID, BEGIN_DATE, END_DATE, CASE_ID, CALENDAR_ID, ENTRY_DATE
		FROM DER_CALENDAR
		WHERE DER_ID = p_DER_ID;

		INSERT INTO DER_SCALE_FACTOR
			(DER_ID, BEGIN_DATE, END_DATE, CASE_ID, SCALE_FACTOR, ENTRY_DATE)
		SELECT p_NEW_ENTITY_ID, BEGIN_DATE, END_DATE, CASE_ID, SCALE_FACTOR, ENTRY_DATE
		FROM DER_SCALE_FACTOR
		WHERE DER_ID = p_DER_ID;

		INSERT INTO DER_STATUS
			(DER_ID, BEGIN_DATE, END_DATE, STATUS_NAME, ENTRY_DATE)
		SELECT p_NEW_ENTITY_ID, STAT.BEGIN_DATE, STAT.END_DATE, STAT.STATUS_NAME, STAT.ENTRY_DATE
		FROM DER_STATUS STAT
		WHERE STAT.DER_ID = p_DER_ID;

		ENTITY_UTIL.COPY_COMMON_SUBTABS(EC.ED_DER,
										p_DER_ID,
										p_NEW_ENTITY_ID);

	END IF;

END COPY_ENTITY;
--------------------------------------------------------------------------------
PROCEDURE DELETE_ENTITY
	(
	p_ENTITY_TYPE IN VARCHAR2,
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_DER_ID IN NUMBER,
	p_SL_BEGIN_DATE IN DATE,
	p_METER_BEGIN_DATE IN DATE
	) AS
v_COUNT NUMBER(9);
v_STATUS NUMBER(9);
BEGIN
	IF p_ENTITY_TYPE = 'ACCOUNT' THEN
		FOR v_SVC_LOC IN (SELECT *
		                FROM ACCOUNT_SERVICE_LOCATION
						WHERE ACCOUNT_ID = p_ACCOUNT_ID) LOOP
			DELETE_ENTITY('SERVICE_LOCATION', p_ACCOUNT_ID, v_SVC_LOC.SERVICE_LOCATION_ID, NULL, NULL, v_SVC_LOC.BEGIN_DATE, NULL);
   		END LOOP;

		DE.DEL_ACCOUNT(p_ACCOUNT_ID, v_STATUS);
		ERRS.VALIDATE_STATUS('DE.DEL_ACCOUNT', v_STATUS);

	ELSIF p_ENTITY_TYPE = 'SERVICE_LOCATION' THEN
		DELETE FROM ACCOUNT_SERVICE_LOCATION
		WHERE ACCOUNT_ID = p_ACCOUNT_ID
		  AND SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
		  AND BEGIN_DATE = p_SL_BEGIN_DATE;

		SELECT COUNT(1)
		INTO v_COUNT
		FROM ACCOUNT_SERVICE_LOCATION
		WHERE SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID;

		IF v_COUNT = 0 THEN
			FOR v_METER IN (SELECT *
		                FROM SERVICE_LOCATION_METER
						WHERE SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID) LOOP
				DELETE_ENTITY('METER', p_ACCOUNT_ID, p_SERVICE_LOCATION_ID, v_METER.METER_ID, NULL, p_SL_BEGIN_DATE, v_METER.BEGIN_DATE);
   			END LOOP;
			DE.DEL_SERVICE_LOCATION(p_SERVICE_LOCATION_ID, v_STATUS);
			ERRS.VALIDATE_STATUS('DE.DEL_SERVICE_LOCATION', v_STATUS);
		END IF;

	ELSIF p_ENTITY_TYPE = 'METER' THEN
		DELETE FROM SERVICE_LOCATION_METER
		WHERE METER_ID = p_METER_ID
		  AND SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
		  AND BEGIN_DATE = p_METER_BEGIN_DATE;

		SELECT COUNT(1)
		INTO v_COUNT
		FROM SERVICE_LOCATION_METER
		WHERE METER_ID = p_METER_ID;

		IF v_COUNT = 0 THEN
			DE.DEL_METER(p_METER_ID, v_STATUS);
			ERRS.VALIDATE_STATUS('DE.DEL_METER', v_STATUS);
		END IF;
	ELSIF p_ENTITY_TYPE = 'DER' THEN
		DE.DEL_DER(p_DER_ID, v_STATUS);
		ERRS.VALIDATE_STATUS('DE.DEL_DER', v_STATUS);
	END IF;
END DELETE_ENTITY;
---------------------------------------------------------------------
PROCEDURE GET_METER
	(
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_METER_OLD_BEGIN_DATE IN DATE,
	p_METER_ID IN NUMBER, -- Meter parameters
	p_MRSP_ID OUT NUMBER,
	p_METER_NAME OUT VARCHAR2,
	p_METER_ALIAS OUT VARCHAR2,
	p_METER_DESC OUT VARCHAR2,
	p_METER_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_METER_STATUS OUT VARCHAR2,
	p_METER_INTERVAL OUT VARCHAR2,
	p_METER_TYPE OUT VARCHAR2,
	p_METER_UNIT OUT VARCHAR2,
	p_IS_EXTERNAL_INTERVAL_USAGE OUT NUMBER,
	p_IS_EXTERNAL_BILLED_USAGE OUT NUMBER,
	p_IS_EXTERNAL_FORECAST OUT NUMBER,
	p_METER_BEGIN_DATE OUT DATE, -- Service Location Meter parameters
	p_METER_END_DATE OUT DATE,
	p_IS_ESTIMATED_END_DATE OUT NUMBER,
	p_NEXT_ACTION_DATE OUT DATE,
	p_EDC_IDENTIFIER OUT VARCHAR2,
	p_ESP_IDENTIFIER OUT VARCHAR2,
	p_EDC_RATE_CLASS OUT VARCHAR2,
	p_USE_TOU_USAGE_FACTOR OUT NUMBER
	) AS
BEGIN

	-- Get Meter details from the METER table
	IO.GET_METER(p_MRSP_ID,
				p_METER_ID,
				p_METER_NAME,
				p_METER_ALIAS,
				p_METER_DESC,
				p_METER_EXTERNAL_IDENTIFIER,
				p_METER_STATUS,
				p_METER_INTERVAL,
				p_METER_TYPE,
				p_METER_UNIT,
				p_IS_EXTERNAL_INTERVAL_USAGE,
				p_IS_EXTERNAL_BILLED_USAGE,
				p_IS_EXTERNAL_FORECAST,
				p_USE_TOU_USAGE_FACTOR);

	-- Get the Meter details from the SERVICE_LOCATION_METER table
	SELECT BEGIN_DATE,
		END_DATE,
		IS_ESTIMATED_END_DATE,
        EDC_IDENTIFIER,
        ESP_IDENTIFIER,
        NEXT_ACTION_DATE,
        EDC_RATE_CLASS
	INTO p_METER_BEGIN_DATE,
		p_METER_END_DATE,
		p_IS_ESTIMATED_END_DATE,
		p_EDC_IDENTIFIER,
		p_ESP_IDENTIFIER,
		p_NEXT_ACTION_DATE,
		p_EDC_RATE_CLASS
	FROM SERVICE_LOCATION_METER
	WHERE SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
		AND METER_ID = p_METER_ID
		AND BEGIN_DATE = p_METER_OLD_BEGIN_DATE;
END;
---------------------------------------------------------------------
PROCEDURE PUT_METER
	(
	o_OID OUT NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_METER_OLD_BEGIN_DATE IN DATE,
	p_MRSP_ID IN NUMBER, -- Meter parameters
	p_METER_NAME IN VARCHAR2,
	p_METER_ALIAS IN VARCHAR2,
	p_METER_DESC IN VARCHAR2,
	p_METER_ID IN NUMBER,
	p_METER_EXTERNAL_IDENTIFIER IN VARCHAR2,
	p_METER_STATUS IN VARCHAR2,
	p_METER_INTERVAL IN VARCHAR2,
	p_METER_TYPE IN VARCHAR2,
	p_METER_UNIT IN VARCHAR2,
	p_IS_EXTERNAL_INTERVAL_USAGE IN NUMBER,
	p_IS_EXTERNAL_BILLED_USAGE IN NUMBER,
	p_IS_EXTERNAL_FORECAST IN NUMBER,
	p_METER_BEGIN_DATE IN DATE, -- Service Location Meter parameters
	p_METER_END_DATE IN DATE,
	p_IS_ESTIMATED_END_DATE IN NUMBER,
	p_NEXT_ACTION_DATE IN DATE,
	p_EDC_IDENTIFIER IN VARCHAR2,
	p_ESP_IDENTIFIER IN VARCHAR2,
	p_EDC_RATE_CLASS IN VARCHAR2,
	p_USE_TOU_USAGE_FACTOR IN NUMBER
	) AS

	v_MRSP_ID NUMBER;
	v_KEY_NEW UT.STRING_MAP;
	v_KEY_OLD UT.STRING_MAP;
	v_DATA UT.STRING_MAP;
BEGIN
	-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_SERVICE_LOCATION_ID, EC.ED_SERVICE_LOCATION);

	IF p_MRSP_ID IS NULL THEN
		v_MRSP_ID := 0; -- Not Assigned
	ELSE
		v_MRSP_ID := p_MRSP_ID;
	END IF;

	IO.PUT_METER(o_OID,
				v_MRSP_ID,
				p_METER_NAME,
				p_METER_ALIAS,
				p_METER_DESC,
				p_METER_ID,
				p_METER_EXTERNAL_IDENTIFIER,
				p_METER_STATUS,
				p_METER_INTERVAL,
				p_METER_TYPE,
				p_METER_UNIT,
				p_IS_EXTERNAL_INTERVAL_USAGE,
				p_IS_EXTERNAL_BILLED_USAGE,
				p_IS_EXTERNAL_FORECAST,
				p_USE_TOU_USAGE_FACTOR); -- <-- Use the Default Mode

	v_KEY_NEW('SERVICE_LOCATION_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SERVICE_LOCATION_ID);
    v_KEY_OLD('SERVICE_LOCATION_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SERVICE_LOCATION_ID);
	v_KEY_NEW('METER_ID') := UT.GET_LITERAL_FOR_NUMBER(o_OID);
    v_KEY_OLD('METER_ID') := UT.GET_LITERAL_FOR_NUMBER(o_OID);
    v_DATA('IS_ESTIMATED_END_DATE') := UT.GET_LITERAL_FOR_NUMBER(p_IS_ESTIMATED_END_DATE);
	v_DATA('EDC_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_EDC_IDENTIFIER);
	v_DATA('ESP_IDENTIFIER') := UT.GET_LITERAL_FOR_STRING(p_ESP_IDENTIFIER);
	v_DATA('NEXT_ACTION_DATE') := UT.GET_LITERAL_FOR_DATE(p_NEXT_ACTION_DATE);
	v_DATA('EDC_RATE_CLASS') := UT.GET_LITERAL_FOR_STRING(p_EDC_RATE_CLASS);

    UT.PUT_TEMPORAL_DATA_UI('SERVICE_LOCATION_METER',
                            p_METER_BEGIN_DATE,
                            p_METER_END_DATE,
                            p_METER_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA);


END;
--------------------------------------------------------------------------------
PROCEDURE METER_CALENDARS
    (
	p_METER_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
	-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_METER_ID, EC.ED_METER);

    OPEN p_CURSOR FOR
        SELECT CL.CASE_NAME,
			MC.CASE_ID,
            MC.METER_ID,
			C.CALENDAR_NAME,
            MC.CALENDAR_ID,
            MC.CALENDAR_TYPE,
            MC.BEGIN_DATE,
            MC.END_DATE,
            MC.ENTRY_DATE
        FROM METER_CALENDAR MC,
			CASE_LABEL CL,
			CALENDAR C
        WHERE METER_ID = p_METER_ID
			AND CL.CASE_ID = MC.CASE_ID
			AND C.CALENDAR_ID = MC.CALENDAR_ID
        ORDER BY CASE_NAME,
            BEGIN_DATE,
            CALENDAR_TYPE;

END METER_CALENDARS;
--------------------------------------------------------------------------------
PROCEDURE PUT_METER_CALENDAR
    (
    p_METER_ID IN NUMBER,
	p_CASE_ID IN NUMBER,
    p_CALENDAR_ID IN NUMBER,
    p_CALENDAR_TYPE IN VARCHAR2,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_OLD_CASE_ID IN NUMBER,
    p_OLD_CALENDAR_TYPE IN VARCHAR2,
    p_OLD_BEGIN_DATE IN DATE
    ) AS
BEGIN
	-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_METER_ID, EC.ED_METER);

	UT.PUT_TEMPORAL_DATA_UI('METER_CALENDAR',
					p_BEGIN_DATE,
					p_END_DATE,
					p_OLD_BEGIN_DATE,
					TRUE,
					'CASE_ID',
					UT.GET_LITERAL_FOR_NUMBER(NVL(p_CASE_ID, GA.BASE_CASE_ID)),
					UT.GET_LITERAL_FOR_NUMBER(p_OLD_CASE_ID),
					TRUE,
					'METER_ID',
					UT.GET_LITERAL_FOR_NUMBER(p_METER_ID),
					UT.GET_LITERAL_FOR_NUMBER(p_METER_ID),
					TRUE,
					'CALENDAR_TYPE',
					UT.GET_LITERAL_FOR_STRING(p_CALENDAR_TYPE),
					UT.GET_LITERAL_FOR_STRING(p_OLD_CALENDAR_TYPE),
					TRUE,
					'CALENDAR_ID',
					UT.GET_LITERAL_FOR_NUMBER(p_CALENDAR_ID),
					NULL,
					FALSE);

END PUT_METER_CALENDAR;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_METER_CALENDAR
    (
    p_CASE_ID IN NUMBER,
    p_METER_ID IN NUMBER,
    p_CALENDAR_TYPE IN VARCHAR2,
    p_BEGIN_DATE IN DATE
    ) AS
BEGIN
	-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_METER_ID, EC.ED_METER);

    DELETE METER_CALENDAR
    WHERE CASE_ID = p_CASE_ID
        AND METER_ID = p_METER_ID
        AND CALENDAR_TYPE = p_CALENDAR_TYPE
        AND BEGIN_DATE = p_BEGIN_DATE;
END;
--------------------------------------------------------------------------------
PROCEDURE METER_CHANNELS
    (
    p_METER_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_METER_ID, EC.ED_METER);

    OPEN p_CURSOR FOR
        SELECT METER_POINT_ID,
		    METER_POINT_NAME,
			METER_POINT_DESC,
			OPERATION_CODE,
			UOM,
			METER_POINT_INTERVAL
	    FROM TX_SUB_STATION_METER_POINT
        WHERE RETAIL_METER_ID = p_METER_ID;
END;
--------------------------------------------------------------------------------
PROCEDURE PUT_METER_CHANNEL
    (
	o_OID OUT NUMBER,
	p_METER_ID IN NUMBER,
    p_METER_POINT_ID IN NUMBER,
    p_METER_POINT_NAME IN VARCHAR2,
    p_METER_POINT_DESC IN VARCHAR2,
    p_UOM IN VARCHAR2,
    p_OPERATION_CODE IN VARCHAR2,
    p_METER_POINT_INTERVAL IN VARCHAR2
    ) AS
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_METER_POINT_ID, EC.ED_SUB_STATION_METER_POINT);

    IO.PUT_SUB_STATION_METER_POINT(o_OID,
                                   p_METER_POINT_NAME,
                                   NULL,
                                   p_METER_POINT_DESC,
                                   NVL(p_METER_POINT_ID, 0),
                                   NULL,
								   NULL,
								   p_METER_ID,
								   NULL,
								   p_METER_POINT_INTERVAL,
                                   CONSTANTS.LOW_DATE,
                                   NULL,
                                   p_UOM,
                                   SUBSTR(p_OPERATION_CODE, 1, 1),
                                   NULL,
                                   NULL);

END;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_METER_CHANNEL
    (
    p_METER_POINT_ID IN NUMBER
    ) AS
BEGIN
    -- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_DELETE_ENT, p_METER_POINT_ID, EC.ED_SUB_STATION_METER_POINT);

    DELETE TX_SUB_STATION_METER_POINT
    WHERE METER_POINT_ID = p_METER_POINT_ID;
END;
--------------------------------------------------------------------------------
PROCEDURE METER_LOSS_FACTORS
    (
    p_METER_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
	-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_METER_ID, EC.ED_METER);

    OPEN p_CURSOR FOR
        SELECT CL.CASE_NAME,
			MLF.CASE_ID,
			MLF.BEGIN_DATE,
            MLF.END_DATE,
			LF.LOSS_FACTOR_NAME,
            MLF.LOSS_FACTOR_ID,
            MLF.ENTRY_DATE
        FROM METER_LOSS_FACTOR MLF,
			CASE_LABEL CL,
			LOSS_FACTOR LF
        WHERE MLF.METER_ID = p_METER_ID
			AND CL.CASE_ID = MLF.CASE_ID
			AND LF.LOSS_FACTOR_ID = MLF.LOSS_FACTOR_ID
        ORDER BY CASE_NAME, BEGIN_DATE, LOSS_FACTOR_NAME;

END METER_LOSS_FACTORS;
--------------------------------------------------------------------------------
PROCEDURE PUT_METER_LOSS_FACTOR
    (
    p_METER_ID IN NUMBER,
	p_CASE_ID IN NUMBER,
    p_LOSS_FACTOR_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_OLD_CASE_ID IN NUMBER,
    p_OLD_BEGIN_DATE IN DATE
    ) AS
BEGIN
	-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_METER_ID, EC.ED_METER);

	UT.PUT_TEMPORAL_DATA_UI('METER_LOSS_FACTOR',
				p_BEGIN_DATE,
				p_END_DATE,
				p_OLD_BEGIN_DATE,
				TRUE,
				'CASE_ID',
				UT.GET_LITERAL_FOR_NUMBER(NVL(p_CASE_ID, GA.BASE_CASE_ID)),
				UT.GET_LITERAL_FOR_NUMBER(p_OLD_CASE_ID),
				TRUE,
				'METER_ID',
				UT.GET_LITERAL_FOR_NUMBER(p_METER_ID),
				UT.GET_LITERAL_FOR_NUMBER(p_METER_ID),
				TRUE,
				'LOSS_FACTOR_ID',
				UT.GET_LITERAL_FOR_NUMBER(p_LOSS_FACTOR_ID),
				NULL,
				FALSE);

END PUT_METER_LOSS_FACTOR;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_METER_LOSS_FACTOR
    (
    p_CASE_ID IN NUMBER,
    p_METER_ID IN NUMBER,
    p_BEGIN_DATE IN DATE
    ) AS
BEGIN
	-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_METER_ID, EC.ED_METER);

    DELETE METER_LOSS_FACTOR
    WHERE CASE_ID = p_CASE_ID
        AND METER_ID = p_METER_ID
        AND BEGIN_DATE = p_BEGIN_DATE;
END REMOVE_METER_LOSS_FACTOR;
--------------------------------------------------------------------------------
PROCEDURE METER_USAGE_FACTORS
    (
    p_METER_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
	-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_METER_ID, EC.ED_METER);

    OPEN p_CURSOR FOR
        SELECT CL.CASE_NAME,
			MUF.CASE_ID,
            MUF.BEGIN_DATE,
            MUF.END_DATE,
            MUF.FACTOR_VAL,
            C.CALENDAR_NAME AS SOURCE_CALENDAR_NAME,
            CASE WHEN MUF.SOURCE_BEGIN_DATE IS NOT NULL THEN
                TEXT_UTIL.TO_CHAR_DATE_RANGE(MUF.SOURCE_BEGIN_DATE, MUF.SOURCE_END_DATE)
            ELSE NULL END AS SOURCE_DATE_RANGE,
            MUF.ENTRY_DATE
        FROM METER_USAGE_FACTOR MUF,
			CASE_LABEL CL,
            CALENDAR C
        WHERE METER_ID = p_METER_ID
			AND CL.CASE_ID = MUF.CASE_ID
            AND C.CALENDAR_ID (+) = MUF.SOURCE_CALENDAR_ID
        ORDER BY CASE_NAME, BEGIN_DATE;

END METER_USAGE_FACTORS;
--------------------------------------------------------------------------------
PROCEDURE PUT_METER_USAGE_FACTOR
    (
    p_METER_ID IN NUMBER,
    p_CASE_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_FACTOR_VAL IN NUMBER,
    p_OLD_CASE_ID IN NUMBER,
    p_OLD_BEGIN_DATE IN DATE
    ) AS
BEGIN
	-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_METER_ID, EC.ED_METER);

	UT.PUT_TEMPORAL_DATA_UI('METER_USAGE_FACTOR',
				p_BEGIN_DATE,
				p_END_DATE,
				p_OLD_BEGIN_DATE,
				TRUE,
				'CASE_ID',
				UT.GET_LITERAL_FOR_NUMBER(NVL(p_CASE_ID, GA.BASE_CASE_ID)),
				UT.GET_LITERAL_FOR_NUMBER(p_OLD_CASE_ID),
				TRUE,
				'METER_ID',
				UT.GET_LITERAL_FOR_NUMBER(p_METER_ID),
				UT.GET_LITERAL_FOR_NUMBER(p_METER_ID),
				TRUE,
				'FACTOR_VAL',
				UT.GET_LITERAL_FOR_NUMBER(p_FACTOR_VAL),
				NULL,
				FALSE);

END PUT_METER_USAGE_FACTOR;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_METER_USAGE_FACTOR
    (
    p_CASE_ID IN NUMBER,
    p_METER_ID IN NUMBER,
    p_BEGIN_DATE IN DATE
    ) AS
BEGIN
	-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_METER_ID, EC.ED_METER);

    DELETE METER_USAGE_FACTOR
    WHERE CASE_ID = p_CASE_ID
        AND METER_ID = p_METER_ID
        AND BEGIN_DATE = p_BEGIN_DATE;

END REMOVE_METER_USAGE_FACTOR;
--------------------------------------------------------------------------------
PROCEDURE METER_GROWTH_PATTERNS
	(
	p_METER_ID   IN NUMBER,
	p_CURSOR     OUT GA.REFCURSOR
	) AS
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_METER_ID, EC.ED_METER);

	OPEN p_CURSOR FOR
		SELECT A.METER_ID,
			   C.CASE_NAME,
			   A.CASE_ID,
			   A.BEGIN_DATE,
			   A.END_DATE,
			   G.PATTERN_NAME,
			   A.PATTERN_ID,
			   A.GROWTH_PCT,
			   A.END_DATE,
			   A.ENTRY_DATE
		FROM METER_GROWTH A, CASE_LABEL C, GROWTH_PATTERN G
		WHERE A.METER_ID = p_METER_ID
			AND C.CASE_ID = A.CASE_ID
			AND G.PATTERN_ID = A.PATTERN_ID
		ORDER BY C.CASE_NAME, A.BEGIN_DATE;

END METER_GROWTH_PATTERNS;
--------------------------------------------------------------------------------
PROCEDURE PUT_METER_GROWTH_PATTERN
	(
	p_CASE_ID            IN NUMBER,
	p_METER_ID           IN NUMBER,
	p_BEGIN_DATE         IN DATE,
	p_END_DATE           IN DATE,
	p_PATTERN_ID         IN NUMBER,
	p_GROWTH_PCT         IN NUMBER,
	p_OLD_CASE_ID        IN NUMBER,
	p_OLD_BEGIN_DATE     IN DATE
	) AS
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_METER_ID, EC.ED_METER);

	UT.PUT_TEMPORAL_DATA_UI('METER_GROWTH',
							p_BEGIN_DATE,
							p_END_DATE,
							p_OLD_BEGIN_DATE,
							TRUE,
							'CASE_ID',
							UT.GET_LITERAL_FOR_NUMBER(NVL(p_CASE_ID,GA.BASE_CASE_ID)),
							UT.GET_LITERAL_FOR_NUMBER(p_OLD_CASE_ID),
							TRUE,
							'METER_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_METER_ID),
							UT.GET_LITERAL_FOR_NUMBER(p_METER_ID),
							TRUE,
							'PATTERN_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_PATTERN_ID),
							NULL,
							FALSE,
							'GROWTH_PCT',
							UT.GET_LITERAL_FOR_NUMBER(p_GROWTH_PCT),
							NULL,
							FALSE);

END PUT_METER_GROWTH_PATTERN;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_METER_GROWTH_PATTERN
	(
	p_CASE_ID    IN NUMBER,
	p_METER_ID   IN NUMBER,
	p_BEGIN_DATE IN DATE
	) AS
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_METER_ID, EC.ED_METER);

	DELETE METER_GROWTH
	WHERE CASE_ID = p_CASE_ID
		  AND METER_ID = p_METER_ID
		  AND BEGIN_DATE = p_BEGIN_DATE;

END REMOVE_METER_GROWTH_PATTERN;
--------------------------------------------------------------------------------
PROCEDURE METER_SCHEDULE_GROUPS
    (
    p_METER_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
	-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_METER_ID, EC.ED_METER);

    OPEN p_CURSOR FOR
        SELECT SG.SCHEDULE_GROUP_NAME,
			MSG.SCHEDULE_GROUP_ID,
			MSG.BEGIN_DATE,
            MSG.END_DATE,
            MSG.ENTRY_DATE
        FROM METER_SCHEDULE_GROUP MSG,
			SCHEDULE_GROUP SG
        WHERE METER_ID = p_METER_ID
			AND SG.SCHEDULE_GROUP_ID = MSG.SCHEDULE_GROUP_ID
        ORDER BY BEGIN_DATE;

END METER_SCHEDULE_GROUPS;
--------------------------------------------------------------------------------
PROCEDURE PUT_METER_SCHEDULE_GROUP
    (
    p_METER_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_SCHEDULE_GROUP_ID IN NUMBER,
    p_OLD_BEGIN_DATE IN DATE
    ) AS

	v_SG_METER_TYPE SCHEDULE_GROUP.METER_TYPE%TYPE;
	v_M_METER_TYPE METER.METER_TYPE%TYPE;

BEGIN
	-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_METER_ID, EC.ED_METER);

	SELECT M.METER_TYPE
	INTO v_M_METER_TYPE
	FROM METER M
	WHERE M.METER_ID = p_METER_ID;

	SELECT SG.METER_TYPE
	INTO v_SG_METER_TYPE
	FROM SCHEDULE_GROUP SG
	WHERE SG.SCHEDULE_GROUP_ID = p_SCHEDULE_GROUP_ID;

	IF UPPER(NVL(v_SG_METER_TYPE, 'EITHER')) NOT IN (UPPER(v_M_METER_TYPE), '?', 'EITHER') THEN
		ERRS.RAISE(MSGCODES.c_ERR_ARGUMENT, TEXT_UTIL.TO_CHAR_ENTITY(p_METER_ID, EC.ED_METER, TRUE) ||
			' cannot be assigned to ' || TEXT_UTIL.TO_CHAR_ENTITY(p_SCHEDULE_GROUP_ID, EC.ED_SCHEDULE_GROUP, TRUE) ||
			' because the schedule group has a meter type of ' || v_SG_METER_TYPE || ' while the meter''s is ' ||
			v_M_METER_TYPE || '.');
	END IF;

	UT.PUT_TEMPORAL_DATA_UI('METER_SCHEDULE_GROUP',
					p_BEGIN_DATE,
					p_END_DATE,
					p_OLD_BEGIN_DATE,
					TRUE,
					'METER_ID',
					UT.GET_LITERAL_FOR_NUMBER(p_METER_ID),
					UT.GET_LITERAL_FOR_NUMBER(p_METER_ID),
					TRUE,
					'SCHEDULE_GROUP_ID',
					UT.GET_LITERAL_FOR_NUMBER(p_SCHEDULE_GROUP_ID),
					NULL,
					FALSE);

END PUT_METER_SCHEDULE_GROUP;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_METER_SCHEDULE_GROUP
    (
    p_METER_ID IN NUMBER,
    p_BEGIN_DATE IN DATE
    ) AS
BEGIN
	-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_METER_ID, EC.ED_METER);

    DELETE METER_SCHEDULE_GROUP
    WHERE METER_ID = p_METER_ID
        AND BEGIN_DATE = p_BEGIN_DATE;

END REMOVE_METER_SCHEDULE_GROUP;
--------------------------------------------------------------------------------
PROCEDURE METER_ANCILLARY_SERVICES
    (
    p_METER_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
	-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_METER_ID, EC.ED_METER);

    OPEN p_CURSOR FOR
        SELECT A.ANCILLARY_SERVICE_NAME,
            MAS.ANCILLARY_SERVICE_ID,
            MAS.BEGIN_DATE,
            MAS.END_DATE,
            MAS.SERVICE_VAL,
            MAS.ENTRY_DATE
        FROM METER_ANCILLARY_SERVICE MAS,
			ANCILLARY_SERVICE A
        WHERE METER_ID = p_METER_ID
			AND A.ANCILLARY_SERVICE_ID = MAS.ANCILLARY_SERVICE_ID
        ORDER BY ANCILLARY_SERVICE_NAME, BEGIN_DATE;

END METER_ANCILLARY_SERVICES;
--------------------------------------------------------------------------------
PROCEDURE PUT_METER_ANCILLARY_SERVICE
    (
    p_METER_ID IN NUMBER,
    p_ANCILLARY_SERVICE_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_SERVICE_VAL IN NUMBER,
    p_OLD_ANCILLARY_SERVICE_ID IN NUMBER,
    p_OLD_BEGIN_DATE IN DATE
    ) AS
BEGIN
	-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_METER_ID, EC.ED_METER);

	UT.PUT_TEMPORAL_DATA_UI('METER_ANCILLARY_SERVICE',
				p_BEGIN_DATE,
				p_END_DATE,
				p_OLD_BEGIN_DATE,
				TRUE,
				'METER_ID',
				UT.GET_LITERAL_FOR_NUMBER(p_METER_ID),
				UT.GET_LITERAL_FOR_NUMBER(p_METER_ID),
				TRUE,
				'ANCILLARY_SERVICE_ID',
				UT.GET_LITERAL_FOR_STRING(p_ANCILLARY_SERVICE_ID),
				UT.GET_LITERAL_FOR_STRING(p_OLD_ANCILLARY_SERVICE_ID),
				TRUE,
				'SERVICE_VAL',
				UT.GET_LITERAL_FOR_NUMBER(p_SERVICE_VAL),
				NULL,
				FALSE);

END PUT_METER_ANCILLARY_SERVICE;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_METER_ANCILLARY_SERVICE
    (
    p_METER_ID IN NUMBER,
    p_ANCILLARY_SERVICE_ID IN NUMBER,
    p_BEGIN_DATE IN DATE
    ) AS
BEGIN
	-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_METER_ID, EC.ED_METER);

    DELETE METER_ANCILLARY_SERVICE
    WHERE METER_ID = p_METER_ID
        AND ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID
        AND BEGIN_DATE = p_BEGIN_DATE;

END REMOVE_METER_ANCILLARY_SERVICE;
--------------------------------------------------------------------------------
PROCEDURE METER_PRODUCTS
    (
    p_METER_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
	-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_METER_ID, EC.ED_METER);

    OPEN p_CURSOR FOR
        SELECT CL.CASE_NAME,
			MP.CASE_ID,
			CASE MP.PRODUCT_TYPE WHEN 'R' THEN c_PRODUCT_TYPE_REVENUE
								WHEN 'C' THEN c_PRODUCT_TYPE_Cost
								WHEN 'B' THEN c_PRODUCT_TYPE_BILLING END AS PRODUCT_TYPE,
			P.PRODUCT_NAME,
            MP.PRODUCT_ID,
            MP.BEGIN_DATE,
            MP.END_DATE,
            MP.ENTRY_DATE
        FROM METER_PRODUCT MP,
			CASE_LABEL CL,
			PRODUCT P
        WHERE METER_ID = p_METER_ID
			AND CL.CASE_ID = MP.CASE_ID
			AND P.PRODUCT_ID = MP.PRODUCT_ID
        ORDER BY CASE_NAME,
            BEGIN_DATE,
            PRODUCT_TYPE,
			PRODUCT_NAME;

END METER_PRODUCTS;
--------------------------------------------------------------------------------
PROCEDURE PUT_METER_PRODUCT
    (
	p_METER_ID IN NUMBER,
    p_CASE_ID IN NUMBER,
    p_PRODUCT_ID IN NUMBER,
    p_PRODUCT_TYPE IN CHAR,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_OLD_CASE_ID IN NUMBER,
    p_OLD_PRODUCT_TYPE IN CHAR,
    p_OLD_BEGIN_DATE IN DATE
    ) AS
BEGIN
	-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_METER_ID, EC.ED_METER);

	UT.PUT_TEMPORAL_DATA_UI('METER_PRODUCT',
					p_BEGIN_DATE,
					p_END_DATE,
					p_OLD_BEGIN_DATE,
					TRUE,
					'CASE_ID',
					UT.GET_LITERAL_FOR_NUMBER(NVL(p_CASE_ID, GA.BASE_CASE_ID)),
					UT.GET_LITERAL_FOR_NUMBER(p_OLD_CASE_ID),
					TRUE,
					'METER_ID',
					UT.GET_LITERAL_FOR_NUMBER(p_METER_ID),
					UT.GET_LITERAL_FOR_NUMBER(p_METER_ID),
					TRUE,
					'PRODUCT_TYPE',
					UT.GET_LITERAL_FOR_STRING(SUBSTR(p_PRODUCT_TYPE,1,1)),
					UT.GET_LITERAL_FOR_STRING(SUBSTR(p_OLD_PRODUCT_TYPE,1,1)),
					TRUE,
					'PRODUCT_ID',
					UT.GET_LITERAL_FOR_NUMBER(p_PRODUCT_ID),
					NULL,
					FALSE);

END PUT_METER_PRODUCT;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_METER_PRODUCT
    (
    p_CASE_ID IN NUMBER,
    p_METER_ID IN NUMBER,
    p_PRODUCT_TYPE IN CHAR,
    p_BEGIN_DATE IN DATE
    ) AS
BEGIN
	-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_METER_ID, EC.ED_METER);

    DELETE METER_PRODUCT
    WHERE CASE_ID = p_CASE_ID
        AND METER_ID = p_METER_ID
        AND PRODUCT_TYPE = p_PRODUCT_TYPE
        AND BEGIN_DATE = p_BEGIN_DATE;

END REMOVE_METER_PRODUCT;
--------------------------------------------------------------------------------
PROCEDURE METER_BILL_CYCLES
    (
    p_METER_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
	-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_METER_ID, EC.ED_METER);

    OPEN p_CURSOR FOR
        SELECT MBC.BEGIN_DATE,
            MBC.END_DATE,
			MBC.BILL_CYCLE_ENTITY,
			BC.BILL_CYCLE_NAME,
			MBC.BILL_CYCLE_ID,
            MBC.ENTRY_DATE
        FROM METER_BILL_CYCLE MBC,
			BILL_CYCLE BC
        WHERE METER_ID = p_METER_ID
			AND BC.BILL_CYCLE_ID = MBC.BILL_CYCLE_ID
        ORDER BY BEGIN_DATE, BILL_CYCLE_ENTITY, BILL_CYCLE_NAME;

END METER_BILL_CYCLES;
--------------------------------------------------------------------------------
PROCEDURE PUT_METER_BILL_CYCLE
    (
    p_METER_ID IN NUMBER,
    p_BILL_CYCLE_ID IN NUMBER,
    p_BILL_CYCLE_ENTITY IN VARCHAR2,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_OLD_BEGIN_DATE IN DATE
    ) AS
BEGIN
	-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_METER_ID, EC.ED_METER);

	UT.PUT_TEMPORAL_DATA_UI('METER_BILL_CYCLE',
					p_BEGIN_DATE,
					p_END_DATE,
					p_OLD_BEGIN_DATE,
					TRUE,
					'METER_ID',
					UT.GET_LITERAL_FOR_NUMBER(p_METER_ID),
					UT.GET_LITERAL_FOR_NUMBER(p_METER_ID),
					TRUE,
					'BILL_CYCLE_ID',
					UT.GET_LITERAL_FOR_NUMBER(p_BILL_CYCLE_ID),
					NULL,
					FALSE,
					'BILL_CYCLE_ENTITY',
					UT.GET_LITERAL_FOR_STRING(p_BILL_CYCLE_ENTITY),
					NULL,
					FALSE);

END PUT_METER_BILL_CYCLE;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_METER_BILL_CYCLE
    (
    p_METER_ID IN NUMBER,
    p_BEGIN_DATE IN DATE
    ) AS
BEGIN
	-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_METER_ID, EC.ED_METER);

    DELETE METER_BILL_CYCLE
    WHERE METER_ID = p_METER_ID
        AND BEGIN_DATE = p_BEGIN_DATE;

END REMOVE_METER_BILL_CYCLE;
---------------------------------------------------------------------
PROCEDURE PROGRAM_DERS
    (
	p_SERVICE_LOCATION_ID IN NUMBER,
    p_PROGRAM_ID IN NUMBER,
	p_SLP_BEGIN_DATE IN DATE,
	p_SLP_END_DATE IN DATE,
	p_ENROLLMENT_PERIOD OUT VARCHAR2,
	p_PROGRAM_NAME OUT VARCHAR2,
	p_DER_TYPES OUT VARCHAR2,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
	v_DER_TYPE_IDS NUMBER_COLLECTION;
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_PROGRAM_ID, EC.ED_PROGRAM);

	p_ENROLLMENT_PERIOD := TEXT_UTIL.TO_CHAR_DATE_RANGE(p_SLP_BEGIN_DATE, p_SLP_END_DATE, FALSE);

	SELECT P.PROGRAM_NAME
	INTO p_PROGRAM_NAME
	FROM PROGRAM P
	WHERE P.PROGRAM_ID = p_PROGRAM_ID;

	SELECT DT.DER_TYPE_ID
	BULK COLLECT INTO v_DER_TYPE_IDS
	FROM PROGRAM_DER_TYPE PDT, DER_TYPE DT
	WHERE PDT.PROGRAM_ID = p_PROGRAM_ID
		AND PDT.DER_TYPE_ID = DT.DER_TYPE_ID;

	p_DER_TYPES := TEXT_UTIL.TO_CHAR_ENTITY_LIST(v_DER_TYPE_IDS, EC.ED_DER_TYPE, FALSE, FALSE);

    OPEN p_CURSOR FOR
        SELECT DP.DER_ID,
            DER.DER_NAME,
            DT.DER_TYPE_NAME,
			DP.BEGIN_DATE AS DP_BEGIN_DATE,
			DP.END_DATE AS DP_END_DATE,
			DP.COUNT
        FROM DER_PROGRAM DP, DISTRIBUTED_ENERGY_RESOURCE DER, DER_TYPE DT
        WHERE DP.PROGRAM_ID = p_PROGRAM_ID
			AND DP.BEGIN_DATE >= p_SLP_BEGIN_DATE
			AND NVL(DP.END_DATE, CONSTANTS.HIGH_DATE) <= NVL(p_SLP_END_DATE, CONSTANTS.HIGH_DATE)
		    AND DP.DER_ID = DER.DER_ID
			AND DER.DER_TYPE_ID = DT.DER_TYPE_ID
			AND DER.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID;

END PROGRAM_DERS;
--------------------------------------------------------------------------------
PROCEDURE PUT_PROGRAM_DER
    (
    p_DER_ID IN NUMBER,
    p_PROGRAM_ID IN NUMBER,
    p_DP_BEGIN_DATE IN DATE,
	p_DP_END_DATE IN DATE,
	p_SLP_BEGIN_DATE IN DATE,
	p_SLP_END_DATE IN DATE,
	p_COUNT IN NUMBER,
    p_OLD_DER_ID IN NUMBER,
	p_OLD_DP_BEGIN_DATE IN DATE
    ) AS
	v_DER_BEGIN_DATE DATE;
	v_DER_END_DATE DATE;
	v_PROGRAM_ID NUMBER(9);
	v_KEY_NEW UT.STRING_MAP;
	v_KEY_OLD UT.STRING_MAP;
	v_DATA UT.STRING_MAP;

	v_BEGIN_DATE DATE := p_DP_BEGIN_DATE;
	v_END_DATE DATE := p_DP_END_DATE;
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_PROGRAM_ID, EC.ED_PROGRAM);

	BEGIN
		SELECT BEGIN_DATE, END_DATE
		INTO v_DER_BEGIN_DATE, v_DER_END_DATE
		FROM DISTRIBUTED_ENERGY_RESOURCE DER
		WHERE DER_ID = p_DER_ID;

		IF v_BEGIN_DATE IS NULL THEN
			v_BEGIN_DATE := GREATEST(p_SLP_BEGIN_DATE, v_DER_BEGIN_DATE);
		END IF;

		IF v_END_DATE IS NULL THEN
			v_END_DATE := LEAST(NVL(p_SLP_END_DATE, CONSTANTS.HIGH_DATE),
							NVL(v_DER_END_DATE, CONSTANTS.HIGH_DATE));

			IF v_END_DATE = CONSTANTS.HIGH_DATE THEN
				v_END_DATE := NULL;
			END IF;
		END IF;

		IF v_BEGIN_DATE < v_DER_BEGIN_DATE OR NVL(v_END_DATE, CONSTANTS.HIGH_DATE) > NVL(v_DER_END_DATE, CONSTANTS.HIGH_DATE) THEN
			ERRS.RAISE(MSGCODES.c_ERR_DATE_RANGE, 'A Resource cannot be enrolled in a Program during a time outside its lifespan.');
		END IF;

		IF v_BEGIN_DATE < p_SLP_BEGIN_DATE OR NVL(v_END_DATE, CONSTANTS.HIGH_DATE) > NVL(p_SLP_END_DATE, CONSTANTS.HIGH_DATE) THEN
			ERRS.RAISE(MSGCODES.c_ERR_DATE_RANGE, 'A Resource cannot be enrolled in a Program during a time when the Program is not available at the Resource''s Service Location');
		END IF;

		SELECT DP.PROGRAM_ID
		INTO v_PROGRAM_ID
		FROM DER_PROGRAM DP
		WHERE DP.DER_ID = p_DER_ID
			AND v_BEGIN_DATE <= NVL(DP.END_DATE, CONSTANTS.HIGH_DATE)
			AND NVL(v_END_DATE, CONSTANTS.HIGH_DATE) >= DP.BEGIN_DATE
			AND (DP.DER_ID != NVL(p_OLD_DER_ID, CONSTANTS.NULL_ID)
				OR (p_OLD_DP_BEGIN_DATE IS NULL OR DP.BEGIN_DATE != p_OLD_DP_BEGIN_DATE));

		ERRS.RAISE(MSGCODES.c_ERR_DATE_RANGE, 'This Resource is already enrolled for this date range in '||TEXT_UTIL.TO_CHAR_ENTITY(v_PROGRAM_ID, EC.ED_PROGRAM));

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			NULL;
	END;

	v_KEY_NEW('DER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_DER_ID);
    v_KEY_OLD('DER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_DER_ID);
    v_DATA('PROGRAM_ID') := UT.GET_LITERAL_FOR_NUMBER(p_PROGRAM_ID);
	v_DATA('COUNT') := UT.GET_LITERAL_FOR_NUMBER(NVL(p_COUNT, 1));

    UT.PUT_TEMPORAL_DATA_UI('DER_PROGRAM',
                            v_BEGIN_DATE,
                            v_END_DATE,
                            p_OLD_DP_BEGIN_DATE,
                            FALSE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

END PUT_PROGRAM_DER;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_PROGRAM_DER
    (
    p_DER_ID IN NUMBER,
    p_DP_BEGIN_DATE IN DATE
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_DER_ID, EC.ED_DER);

    DELETE DER_PROGRAM
    WHERE DER_ID = p_DER_ID
        AND BEGIN_DATE = p_DP_BEGIN_DATE;

END REMOVE_PROGRAM_DER;
--------------------------------------------------------------------------------
PROCEDURE PROGRAM_DER_LIST
    (
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_PROGRAM_ID IN NUMBER,
	p_SLP_BEGIN_DATE IN DATE,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
    OPEN p_CURSOR FOR
	    SELECT DER.DER_ID, DER.DER_NAME
		FROM DISTRIBUTED_ENERGY_RESOURCE DER, PROGRAM_DER_TYPE PDT,
			SERVICE_LOCATION_PROGRAM SLP
		WHERE DER.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
			AND SLP.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
			AND SLP.PROGRAM_ID = p_PROGRAM_ID
			AND SLP.BEGIN_DATE = p_SLP_BEGIN_DATE
			AND SLP.BEGIN_DATE <= NVL(DER.END_DATE, CONSTANTS.HIGH_DATE)
			AND NVL(SLP.END_DATE, CONSTANTS.HIGH_DATE) >= DER.BEGIN_DATE
			AND SLP.PROGRAM_ID = PDT.PROGRAM_ID
			AND PDT.DER_TYPE_ID = DER.DER_TYPE_ID;
END PROGRAM_DER_LIST;
--------------------------------------------------------------------------------
PROCEDURE GET_TYPE_FOR_DER
    (
	p_DER_ID IN NUMBER,
	p_DER_TYPE_NAME OUT VARCHAR2
	) AS
BEGIN
    SELECT DT.DER_TYPE_NAME INTO p_DER_TYPE_NAME
	FROM DISTRIBUTED_ENERGY_RESOURCE DER, DER_TYPE DT
	WHERE DER.DER_ID = p_DER_ID
	    AND DER.DER_TYPE_ID = DT.DER_TYPE_ID;
END GET_TYPE_FOR_DER;
--------------------------------------------------------------------------------
PROCEDURE DER_PROGRAMS
    (
    p_DER_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_DER_ID, EC.ED_DER);

    OPEN p_CURSOR FOR
        SELECT P.PROGRAM_ID,
			P.PROGRAM_NAME,
			P.EXTERNAL_IDENTIFIER,
            DP.BEGIN_DATE AS DP_BEGIN_DATE,
			DP.END_DATE AS DP_END_DATE,
			DP.COUNT
        FROM DER_PROGRAM DP, PROGRAM P
        WHERE DP.DER_ID = p_DER_ID
			AND DP.PROGRAM_ID = P.PROGRAM_ID
        ORDER BY DP_BEGIN_DATE;

END DER_PROGRAMS;
--------------------------------------------------------------------------------
PROCEDURE PUT_DER_PROGRAM
    (
    p_DER_ID IN NUMBER,
    p_PROGRAM_ID IN NUMBER,
    p_DP_BEGIN_DATE IN DATE,
	p_DP_END_DATE IN DATE,
	p_COUNT IN NUMBER,
    p_OLD_DP_BEGIN_DATE IN DATE
    ) AS
	v_SLP_BEGIN_DATE DATE;
	v_SLP_END_DATE DATE;
BEGIN

	BEGIN
		SELECT SLP.BEGIN_DATE, SLP.END_DATE
		INTO v_SLP_BEGIN_DATE, v_SLP_END_DATE
		FROM SERVICE_LOCATION_PROGRAM SLP, DISTRIBUTED_ENERGY_RESOURCE DER
		WHERE DER.DER_ID = p_DER_ID
			AND DER.SERVICE_LOCATION_ID = SLP.SERVICE_LOCATION_ID
			AND SLP.PROGRAM_ID = p_PROGRAM_ID
			AND SLP.BEGIN_DATE <= p_DP_BEGIN_DATE
			AND NVL(SLP.END_DATE, CONSTANTS.HIGH_DATE) >= NVL(p_DP_END_DATE, CONSTANTS.HIGH_DATE);

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.RAISE(MSGCODES.c_ERR_DATE_RANGE, 'A Resource cannot be enrolled in a Program during a time when the Program is not available at the Resource''s Service Location');
	END;

	PUT_PROGRAM_DER(p_DER_ID,
    				p_PROGRAM_ID,
    				p_DP_BEGIN_DATE,
					p_DP_END_DATE,
					v_SLP_BEGIN_DATE,
					v_SLP_END_DATE,
					p_COUNT,
    				p_DER_ID,
					p_OLD_DP_BEGIN_DATE);

END PUT_DER_PROGRAM;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_DER_PROGRAM
    (
    p_DER_ID IN NUMBER,
    p_DP_BEGIN_DATE IN DATE
    ) AS
BEGIN

	REMOVE_PROGRAM_DER(	p_DER_ID,
    					p_DP_BEGIN_DATE);

END REMOVE_DER_PROGRAM;
--------------------------------------------------------------------------------
PROCEDURE PROGRAM_FOR_DER_LIST
	(
	p_DER_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN

	OPEN p_CURSOR FOR
		SELECT DISTINCT P.PROGRAM_NAME, P.PROGRAM_ID
		FROM SERVICE_LOCATION_PROGRAM SLP, PROGRAM P,
			DISTRIBUTED_ENERGY_RESOURCE DER, PROGRAM_DER_TYPE PDT
		WHERE DER.DER_ID = p_DER_ID
			AND SLP.SERVICE_LOCATION_ID = DER.SERVICE_LOCATION_ID
			AND SLP.PROGRAM_ID = P.PROGRAM_ID
			AND P.PROGRAM_ID = PDT.PROGRAM_ID
			AND PDT.DER_TYPE_ID = DER.DER_TYPE_ID
			AND SLP.BEGIN_DATE < NVL(DER.END_DATE, CONSTANTS.HIGH_DATE)
			AND NVL(SLP.END_DATE, CONSTANTS.HIGH_DATE) > DER.BEGIN_DATE;

END PROGRAM_FOR_DER_LIST;
--------------------------------------------------------------------------------
PROCEDURE DER_ENROLLMENT_PERIOD_LIST
	(
	p_DER_ID IN NUMBER,
	p_PROGRAM_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN

	OPEN p_CURSOR FOR
		SELECT TEXT_UTIL.TO_CHAR_DATE_RANGE(GREATEST(SLP.BEGIN_DATE, DER.BEGIN_DATE),
					LEAST(NVL(SLP.END_DATE, CONSTANTS.HIGH_DATE), NVL(DER.END_DATE, CONSTANTS.HIGH_DATE)), 0, 1)
				AS ENROLLMENT_PERIOD,
			SLP.BEGIN_DATE - CONSTANTS.LOW_DATE AS BEGIN_DATE_ID
		FROM SERVICE_LOCATION_PROGRAM SLP, DISTRIBUTED_ENERGY_RESOURCE DER
		WHERE DER.DER_ID = p_DER_ID
			AND SLP.SERVICE_LOCATION_ID = DER.SERVICE_LOCATION_ID
			AND SLP.PROGRAM_ID = p_PROGRAM_ID
			AND SLP.BEGIN_DATE < NVL(DER.END_DATE, CONSTANTS.HIGH_DATE)
			AND NVL(SLP.END_DATE, CONSTANTS.HIGH_DATE) > DER.BEGIN_DATE;

END DER_ENROLLMENT_PERIOD_LIST;
--************************************************************************
-- Reports
--************************************************************************
PROCEDURE EDC_RATE_CLASS_LIST
	(
	p_EDC_ID ENERGY_DISTRIBUTION_COMPANY.EDC_ID%TYPE,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT DISTINCT E.RATE_CLASS
		FROM EDC_RATE_CLASS E
		WHERE (E.EDC_ID = p_EDC_ID OR p_EDC_ID = CONSTANTS.ALL_ID)
		ORDER BY 1;
END EDC_RATE_CLASS_LIST;
---------------------------------------------------------------------
PROCEDURE RATE_CLASS_LIST
	(
	p_ACCOUNT_ID NUMBER,
	p_BEGIN_DATE DATE,
	p_END_DATE DATE,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT DISTINCT E.RATE_CLASS
		FROM ACCOUNT_EDC AEDC,
			EDC_RATE_CLASS E
		WHERE AEDC.ACCOUNT_ID = p_ACCOUNT_ID
			AND AEDC.BEGIN_DATE <= NVL(p_END_DATE, CONSTANTS.HIGH_DATE) AND NVL(AEDC.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND E.EDC_ID = AEDC.EDC_ID
		ORDER BY 1;
END RATE_CLASS_LIST;
---------------------------------------------------------------------
PROCEDURE CACHE_ACCOUNT_IDS
	(
	p_WORK_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_EDC_ID IN NUMBER,
	p_EDC_RATE_CLASS IN VARCHAR2,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_SCHEDULE_GROUP_ID IN NUMBER
	) AS
BEGIN
	-- For Model Option - Account, we use ACCOUNT_ESP and ACCOUNT_SCHEDULE_GROUP tables
	INSERT INTO RTO_WORK(WORK_ID, WORK_XID)
	SELECT DISTINCT p_WORK_ID, A.ACCOUNT_ID
		FROM ACCOUNT A,
			ACCOUNT_EDC AEDC,
			ACCOUNT_ESP AESP, -- Account ESP
			ACCOUNT_SERVICE_LOCATION ASL,
			SERVICE_LOCATION SL,
			ACCOUNT_SCHEDULE_GROUP G-- Account Schedule Group
		WHERE -- Account
			A.ACCOUNT_MODEL_OPTION NOT IN (c_ACCT_MODEL_OPTION_METER, c_ACCT_MODEL_OPTION_AGGREGATE)
			AND AEDC.ACCOUNT_ID(+) = A.ACCOUNT_ID
			-- Acocunt EDC
			AND (AEDC.EDC_ID = p_EDC_ID OR CONSTANTS.ALL_ID = p_EDC_ID)
			AND AEDC.BEGIN_DATE(+) <= p_END_DATE
			AND NVL(AEDC.END_DATE(+), CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND (AEDC.EDC_RATE_CLASS = p_EDC_RATE_CLASS OR CONSTANTS.ALL_STRING = p_EDC_RATE_CLASS)
			-- Account ESP
			AND AESP.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND (AESP.ESP_ID = p_ESP_ID OR CONSTANTS.ALL_ID = p_ESP_ID)
			AND (AESP.POOL_ID = p_POOL_ID OR CONSTANTS.ALL_ID = p_POOL_ID)
			AND AESP.BEGIN_DATE(+) <= p_END_DATE
			AND NVL(AESP.END_DATE(+), CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			-- Service Location
			AND ASL.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND ASL.BEGIN_DATE(+) <= p_END_DATE
			AND NVL(ASL.END_DATE(+), CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND SL.SERVICE_LOCATION_ID(+) = ASL.SERVICE_LOCATION_ID
			AND (SL.SERVICE_POINT_ID = p_SERVICE_POINT_ID OR CONSTANTS.ALL_ID = p_SERVICE_POINT_ID)
			-- Account Group
			AND G.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND (G.SCHEDULE_GROUP_ID = p_SCHEDULE_GROUP_ID OR CONSTANTS.ALL_ID = p_SCHEDULE_GROUP_ID)
			AND G.BEGIN_DATE(+) <= p_END_DATE
			AND NVL(G.END_DATE(+), CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE;

	-- For Model Option - Aggregate Type, we use AGGREGATE_ESP and ACCOUNT_SCHEDULE_GROUP tables
	INSERT INTO RTO_WORK(WORK_ID, WORK_XID)
	SELECT DISTINCT p_WORK_ID, A.ACCOUNT_ID
		FROM ACCOUNT A,
			ACCOUNT_EDC AEDC,
			AGGREGATE_ACCOUNT_ESP AESP, -- Aggregate ESP
			ACCOUNT_SERVICE_LOCATION ASL,
			SERVICE_LOCATION SL,
			ACCOUNT_SCHEDULE_GROUP G-- Account Schedule Group
		WHERE -- Account
			A.ACCOUNT_MODEL_OPTION = c_ACCT_MODEL_OPTION_AGGREGATE
			-- Aggregate EDC
			AND AEDC.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND (AEDC.EDC_ID = p_EDC_ID OR CONSTANTS.ALL_ID = p_EDC_ID)
			AND AEDC.BEGIN_DATE(+) <= p_END_DATE
			AND NVL(AEDC.END_DATE(+), CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND (AEDC.EDC_RATE_CLASS = p_EDC_RATE_CLASS OR CONSTANTS.ALL_STRING = p_EDC_RATE_CLASS)
			-- Account ESP
			AND AESP.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND (AESP.ESP_ID = p_ESP_ID OR CONSTANTS.ALL_ID = p_ESP_ID)
			AND (AESP.POOL_ID = p_POOL_ID OR CONSTANTS.ALL_ID = p_POOL_ID)
			AND AESP.BEGIN_DATE(+) <= p_END_DATE
			AND NVL(AESP.END_DATE(+), CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			-- Service Location
			AND ASL.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND ASL.BEGIN_DATE(+) <= p_END_DATE
			AND NVL(ASL.END_DATE(+), CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND SL.SERVICE_LOCATION_ID(+) = ASL.SERVICE_LOCATION_ID
			AND (SL.SERVICE_POINT_ID = p_SERVICE_POINT_ID OR CONSTANTS.ALL_ID = p_SERVICE_POINT_ID)
			-- Account Group
			AND G.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND (G.SCHEDULE_GROUP_ID = p_SCHEDULE_GROUP_ID OR CONSTANTS.ALL_ID = p_SCHEDULE_GROUP_ID)
			AND G.BEGIN_DATE(+) <= p_END_DATE
			AND NVL(G.END_DATE(+), CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE;

	-- For Model Option - Meter Type, we use ACCOUNT_ESP and METER_SCHEDULE_GROUP tables
	INSERT INTO RTO_WORK(WORK_ID, WORK_XID)
	SELECT DISTINCT p_WORK_ID, A.ACCOUNT_ID
		FROM ACCOUNT A,
			ACCOUNT_EDC AEDC,
			ACCOUNT_ESP AESP, -- Account ESP
			ACCOUNT_SERVICE_LOCATION ASL,
			SERVICE_LOCATION SL,
			SERVICE_LOCATION_METER SLM,
			METER_SCHEDULE_GROUP G-- Meter Schedule Group
		WHERE -- Account
			A.ACCOUNT_MODEL_OPTION = c_ACCT_MODEL_OPTION_METER
			-- Account EDC
			AND AEDC.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND (AEDC.EDC_ID = p_EDC_ID OR CONSTANTS.ALL_ID = p_EDC_ID)
			AND AEDC.BEGIN_DATE(+) <= p_END_DATE
			AND NVL(AEDC.END_DATE(+), CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND (AEDC.EDC_RATE_CLASS = p_EDC_RATE_CLASS OR CONSTANTS.ALL_STRING = p_EDC_RATE_CLASS)
			-- Account ESP
			AND AESP.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND (AESP.ESP_ID = p_ESP_ID OR CONSTANTS.ALL_ID = p_ESP_ID)
			AND (AESP.POOL_ID = p_POOL_ID OR CONSTANTS.ALL_ID = p_POOL_ID)
			AND AESP.BEGIN_DATE(+) <= p_END_DATE
			AND NVL(AESP.END_DATE(+), CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			-- Service Location
			AND ASL.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND ASL.BEGIN_DATE(+) <= p_END_DATE
			AND NVL(ASL.END_DATE(+), CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND SL.SERVICE_LOCATION_ID(+) = ASL.SERVICE_LOCATION_ID
			AND (SL.SERVICE_POINT_ID = p_SERVICE_POINT_ID OR CONSTANTS.ALL_ID = p_SERVICE_POINT_ID)
			-- Meter Schedule Group
			AND SLM.SERVICE_LOCATION_ID (+) = ASL.SERVICE_LOCATION_ID
			AND SLM.BEGIN_DATE(+) <= NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE)
			AND NVL(SLM.END_DATE(+), CONSTANTS.HIGH_DATE) >= ASL.BEGIN_DATE
			AND G.METER_ID(+) = SLM.METER_ID
			AND (G.SCHEDULE_GROUP_ID = p_SCHEDULE_GROUP_ID OR CONSTANTS.ALL_ID = p_SCHEDULE_GROUP_ID)
			AND G.BEGIN_DATE(+) <= p_END_DATE
			AND NVL(G.END_DATE(+), CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE;

END CACHE_ACCOUNT_IDS;
---------------------------------------------------------------------
PROCEDURE ACTIVE_ACCOUNT_LIST
	(
    p_EFFECTIVE_DATE IN DATE,
	p_EDC_ID IN NUMBER,
	p_EDC_RATE_CLASS IN VARCHAR2,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_SCHEDULE_GROUP_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
		-- For Account Model - Account, we will use the Account ESP, Account Schedule Group,
		-- Account Calendar, Account Loss Factor and Account Usage Factor tables
		 SELECT A.ACCOUNT_ID,
			A.ACCOUNT_NAME,
			A.ACCOUNT_ALIAS,
			A.ACCOUNT_MODEL_OPTION,
			A.ACCOUNT_EXTERNAL_IDENTIFIER,
			S.STATUS_NAME AS ACCOUNT_STATUS_NAME,
			S.BEGIN_DATE AS ACCOUNT_STATUS_BEGIN_DATE,
			S.END_DATE AS ACCCOUNT_STATUS_END_DATE,
			EDC.EDC_NAME,
			AEDC.BEGIN_DATE AS EDC_BEGIN_DATE,
			AEDC.END_DATE AS EDC_END_DATE,
			AEDC.EDC_RATE_CLASS,
			AEDC.EDC_STRATA,
			ESP.ESP_NAME,
			P.POOL_NAME,
			AESP.BEGIN_DATE AS ESP_BEGIN_DATE,
			AESP.END_DATE AS ESP_END_DATE,
			ASL.SERVICE_LOCATION_ID,
			SL.SERVICE_LOCATION_NAME,
			WS.STATION_NAME AS WEATHER_STATION_NAME,
			SP.SERVICE_POINT_NAME,
			NULL AS METER_ID,
			'NA' AS METER_NAME,
			G.SCHEDULE_GROUP_NAME,
			AG.BEGIN_DATE AS SCHEDULE_GROUP_BEGIN_DATE,
			AG.END_DATE AS SCHEDULE_GROUP_END_DATE,
			C.CALENDAR_NAME,
			ACAL.BEGIN_DATE AS CALENDAR_BEGIN_DATE,
			ACAL.END_DATE AS CALENDAR_END_DATE,
			LF.LOSS_FACTOR_NAME,
			ALF.BEGIN_DATE AS LOSS_FACTOR_BEGIN_DATE,
			ALF.END_DATE AS LOSS_FACTOR_END_DATE,
			AUF.FACTOR_VAL AS USAGE_FACTOR_VALUE,
			AUF.BEGIN_DATE AS USAGE_FACTOR_BEGIN_DATE,
			AUF.END_DATE AS USAGE_FACTOR_END_DATE
		FROM ACCOUNT A,
			ACCOUNT_STATUS S,
			ACCOUNT_EDC AEDC,
			ENERGY_DISTRIBUTION_COMPANY EDC,
			ACCOUNT_ESP AESP, -- Account ESP
			ENERGY_SERVICE_PROVIDER ESP,
			POOL P,
			ACCOUNT_SERVICE_LOCATION ASL,
			SERVICE_LOCATION SL,
			WEATHER_STATION WS,
			SERVICE_POINT SP,
			ACCOUNT_SCHEDULE_GROUP AG,
			SCHEDULE_GROUP G,
			ACCOUNT_CALENDAR ACAL,
			CALENDAR C,
			ACCOUNT_LOSS_FACTOR ALF,
			LOSS_FACTOR LF,
			ACCOUNT_USAGE_FACTOR AUF
		WHERE -- Account
			A.ACCOUNT_MODEL_OPTION NOT IN (c_ACCT_MODEL_OPTION_METER, c_ACCT_MODEL_OPTION_AGGREGATE)
			-- Account Status
			AND S.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND p_EFFECTIVE_DATE BETWEEN S.BEGIN_DATE(+) AND NVL(S.END_DATE(+), CONSTANTS.HIGH_DATE)
			-- Account EDC
			AND AEDC.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND (AEDC.EDC_ID = p_EDC_ID OR CONSTANTS.ALL_ID = p_EDC_ID)
			AND (EDC_RATE_CLASS = p_EDC_RATE_CLASS OR CONSTANTS.ALL_STRING = p_EDC_RATE_CLASS)
			AND p_EFFECTIVE_DATE BETWEEN AEDC.BEGIN_DATE(+) AND NVL(AEDC.END_DATE(+), CONSTANTS.HIGH_DATE)
			AND EDC.EDC_ID(+) = AEDC.EDC_ID
			-- Account ESP
			AND AESP.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND p_EFFECTIVE_DATE BETWEEN AESP.BEGIN_DATE(+) AND NVL(AESP.END_DATE(+), CONSTANTS.HIGH_DATE)
			AND (AESP.ESP_ID = p_ESP_ID OR CONSTANTS.ALL_ID = p_ESP_ID)
			AND (AESP.POOL_ID = p_POOL_ID OR CONSTANTS.ALL_ID = p_POOL_ID)
			AND ESP.ESP_ID(+) = AESP.ESP_ID
			AND P.POOL_ID(+) = AESP.POOL_ID
			-- Service Location
			AND ASL.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND p_EFFECTIVE_DATE BETWEEN ASL.BEGIN_DATE(+) AND NVL(ASL.END_DATE(+), CONSTANTS.HIGH_DATE)
			AND SL.SERVICE_LOCATION_ID(+) = ASL.SERVICE_LOCATION_ID
			AND (SL.SERVICE_POINT_ID = p_SERVICE_POINT_ID OR CONSTANTS.ALL_ID = p_SERVICE_POINT_ID)
			AND WS.STATION_ID(+) = SL.WEATHER_STATION_ID
			AND SP.SERVICE_POINT_ID(+) = SL.SERVICE_POINT_ID
			-- Account Group
			AND AG.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND (AG.SCHEDULE_GROUP_ID = p_SCHEDULE_GROUP_ID OR CONSTANTS.ALL_ID = p_SCHEDULE_GROUP_ID)
			AND p_EFFECTIVE_DATE BETWEEN AG.BEGIN_DATE(+) AND NVL(AG.END_DATE(+), CONSTANTS.HIGH_DATE)
			AND G.SCHEDULE_GROUP_ID(+) = AG.SCHEDULE_GROUP_ID
			-- Account Calendar
			AND ACAL.CASE_ID(+) = GA.BASE_CASE_ID
			AND ACAL.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND ACAL.CALENDAR_TYPE(+) = 'Forecast'
			AND p_EFFECTIVE_DATE BETWEEN ACAL.BEGIN_DATE(+) AND NVL(ACAL.END_DATE(+), CONSTANTS.HIGH_DATE)
			AND C.CALENDAR_ID(+) = ACAL.CALENDAR_ID
			-- Account Loss Factor
			AND ALF.CASE_ID(+) = GA.BASE_CASE_ID
			AND ALF.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND p_EFFECTIVE_DATE BETWEEN ALF.BEGIN_DATE(+) AND NVL(ALF.END_DATE(+), CONSTANTS.HIGH_DATE)
			AND LF.LOSS_FACTOR_ID(+) = ALF.LOSS_FACTOR_ID
			-- Account Usage Factor
			AND AUF.CASE_ID(+) = GA.BASE_CASE_ID
			AND AUF.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND p_EFFECTIVE_DATE BETWEEN AUF.BEGIN_DATE(+) AND NVL(AUF.END_DATE(+), CONSTANTS.HIGH_DATE)
		UNION ALL
		-- For Account Model - Aggregate, we will use the Aggregate Account ESP, Account Schedule Group,
		-- Account Calendar, Account Loss Factor and Account Usage Factor tables
		SELECT A.ACCOUNT_ID,
			A.ACCOUNT_NAME,
			A.ACCOUNT_ALIAS,
			A.ACCOUNT_MODEL_OPTION,
			A.ACCOUNT_EXTERNAL_IDENTIFIER,
			S.STATUS_NAME AS ACCOUNT_STATUS_NAME,
			S.BEGIN_DATE AS ACCOUNT_STATUS_BEGIN_DATE,
			S.END_DATE AS ACCCOUNT_STATUS_END_DATE,
			EDC.EDC_NAME,
			AEDC.BEGIN_DATE AS EDC_BEGIN_DATE,
			AEDC.END_DATE AS EDC_END_DATE,
			AEDC.EDC_RATE_CLASS,
			AEDC.EDC_STRATA,
			ESP.ESP_NAME,
			P.POOL_NAME,
			AESP.BEGIN_DATE AS ESP_BEGIN_DATE,
			AESP.END_DATE AS ESP_END_DATE,
			ASL.SERVICE_LOCATION_ID,
			SL.SERVICE_LOCATION_NAME,
			WS.STATION_NAME AS WEATHER_STATION_NAME,
			SP.SERVICE_POINT_NAME,
			NULL AS METER_ID,
			'NA' AS METER_NAME,
			G.SCHEDULE_GROUP_NAME,
			AG.BEGIN_DATE AS SCHEDULE_GROUP_BEGIN_DATE,
			AG.END_DATE AS SCHEDULE_GROUP_END_DATE,
			C.CALENDAR_NAME,
			ACAL.BEGIN_DATE AS CALENDAR_BEGIN_DATE,
			ACAL.END_DATE AS CALENDAR_END_DATE,
			LF.LOSS_FACTOR_NAME,
			ALF.BEGIN_DATE AS LOSS_FACTOR_BEGIN_DATE,
			ALF.END_DATE AS LOSS_FACTOR_END_DATE,
			AUF.FACTOR_VAL AS USAGE_FACTOR_VALUE,
			AUF.BEGIN_DATE AS USAGE_FACTOR_BEGIN_DATE,
			AUF.END_DATE AS USAGE_FACTOR_END_DATE
		FROM ACCOUNT A,
			ACCOUNT_STATUS S,
			ACCOUNT_EDC AEDC,
			ENERGY_DISTRIBUTION_COMPANY EDC,
			AGGREGATE_ACCOUNT_ESP AESP, -- Aggregate ESP
			ENERGY_SERVICE_PROVIDER ESP,
			POOL P,
			ACCOUNT_SERVICE_LOCATION ASL,
			SERVICE_LOCATION SL,
			WEATHER_STATION WS,
			SERVICE_POINT SP,
			ACCOUNT_SCHEDULE_GROUP AG,
			SCHEDULE_GROUP G,
			ACCOUNT_CALENDAR ACAL,
			CALENDAR C,
			ACCOUNT_LOSS_FACTOR ALF,
			LOSS_FACTOR LF,
			ACCOUNT_USAGE_FACTOR AUF
		WHERE -- Account
			A.ACCOUNT_MODEL_OPTION = c_ACCT_MODEL_OPTION_AGGREGATE
			-- Account Status
			AND S.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND p_EFFECTIVE_DATE BETWEEN S.BEGIN_DATE(+) AND NVL(S.END_DATE(+), CONSTANTS.HIGH_DATE)
			-- Account EDC
			AND AEDC.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND (AEDC.EDC_ID = p_EDC_ID OR CONSTANTS.ALL_ID = p_EDC_ID)
			AND (EDC_RATE_CLASS = p_EDC_RATE_CLASS OR CONSTANTS.ALL_STRING = p_EDC_RATE_CLASS)
			AND p_EFFECTIVE_DATE BETWEEN AEDC.BEGIN_DATE(+) AND NVL(AEDC.END_DATE(+), CONSTANTS.HIGH_DATE)
			AND EDC.EDC_ID(+) = AEDC.EDC_ID
			-- Account ESP
			AND AESP.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND (AESP.ESP_ID = p_ESP_ID OR CONSTANTS.ALL_ID = p_ESP_ID)
			AND (AESP.POOL_ID = p_POOL_ID OR CONSTANTS.ALL_ID = p_POOL_ID)
			AND p_EFFECTIVE_DATE BETWEEN AESP.BEGIN_DATE(+) AND NVL(AESP.END_DATE(+), CONSTANTS.HIGH_DATE)
			AND ESP.ESP_ID(+) = AESP.ESP_ID
			AND P.POOL_ID(+) = AESP.POOL_ID
			-- Service Location
			AND ASL.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND p_EFFECTIVE_DATE BETWEEN ASL.BEGIN_DATE(+) AND NVL(ASL.END_DATE(+), CONSTANTS.HIGH_DATE)
			AND SL.SERVICE_LOCATION_ID(+) = ASL.SERVICE_LOCATION_ID
			AND (SL.SERVICE_POINT_ID = p_SERVICE_POINT_ID OR CONSTANTS.ALL_ID = p_SERVICE_POINT_ID)
			AND WS.STATION_ID(+) = SL.WEATHER_STATION_ID
			AND SP.SERVICE_POINT_ID(+) = SL.SERVICE_POINT_ID
			-- Account Group
			AND AG.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND (AG.SCHEDULE_GROUP_ID = p_SCHEDULE_GROUP_ID OR CONSTANTS.ALL_ID = p_SCHEDULE_GROUP_ID)
			AND p_EFFECTIVE_DATE BETWEEN AG.BEGIN_DATE(+) AND NVL(AG.END_DATE(+), CONSTANTS.HIGH_DATE)
			AND G.SCHEDULE_GROUP_ID(+) = AG.SCHEDULE_GROUP_ID
			-- Account Calendar
			AND ACAL.CASE_ID(+) = GA.BASE_CASE_ID
			AND ACAL.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND ACAL.CALENDAR_TYPE(+) = 'Forecast'
			AND p_EFFECTIVE_DATE BETWEEN ACAL.BEGIN_DATE(+) AND NVL(ACAL.END_DATE(+), CONSTANTS.HIGH_DATE)
			AND C.CALENDAR_ID(+) = ACAL.CALENDAR_ID
			-- Account Loss Factor
			AND ALF.CASE_ID(+) = GA.BASE_CASE_ID
			AND ALF.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND p_EFFECTIVE_DATE BETWEEN ALF.BEGIN_DATE(+) AND NVL(ALF.END_DATE(+), CONSTANTS.HIGH_DATE)
			AND LF.LOSS_FACTOR_ID(+) = ALF.LOSS_FACTOR_ID
			-- Account Usage Factor
			AND AUF.CASE_ID(+) = GA.BASE_CASE_ID
			AND AUF.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND p_EFFECTIVE_DATE BETWEEN AUF.BEGIN_DATE(+) AND NVL(AUF.END_DATE(+), CONSTANTS.HIGH_DATE)
		UNION ALL
		-- For Account Model - Meter, we will use the Account ESP, Meter Schedule Group,
		-- Meter Calendar, Meter Loss Factor and Meter Usage Factor tables
		SELECT A.ACCOUNT_ID,
			A.ACCOUNT_NAME,
			A.ACCOUNT_ALIAS,
			A.ACCOUNT_MODEL_OPTION,
			A.ACCOUNT_EXTERNAL_IDENTIFIER,
			S.STATUS_NAME AS ACCOUNT_STATUS_NAME,
			S.BEGIN_DATE AS ACCOUNT_STATUS_BEGIN_DATE,
			S.END_DATE AS ACCCOUNT_STATUS_END_DATE,
			EDC.EDC_NAME,
			AEDC.BEGIN_DATE AS EDC_BEGIN_DATE,
			AEDC.END_DATE AS EDC_END_DATE,
			AEDC.EDC_RATE_CLASS,
			AEDC.EDC_STRATA,
			ESP.ESP_NAME,
			P.POOL_NAME,
			AESP.BEGIN_DATE AS ESP_BEGIN_DATE,
			AESP.END_DATE AS ESP_END_DATE,
			ASL.SERVICE_LOCATION_ID,
			SL.SERVICE_LOCATION_NAME,
			WS.STATION_NAME AS WEATHER_STATION_NAME,
			SP.SERVICE_POINT_NAME,
			SLM.METER_ID AS METER_ID,
			M.METER_NAME,
			G.SCHEDULE_GROUP_NAME,
			MG.BEGIN_DATE AS SCHEDULE_GROUP_BEGIN_DATE,
			MG.END_DATE AS SCHEDULE_GROUP_END_DATE,
			C.CALENDAR_NAME,
			MCAL.BEGIN_DATE AS CALENDAR_BEGIN_DATE,
			MCAL.END_DATE AS CALENDAR_END_DATE,
			LF.LOSS_FACTOR_NAME,
			MLF.BEGIN_DATE AS LOSS_FACTOR_BEGIN_DATE,
			MLF.END_DATE AS LOSS_FACTOR_END_DATE,
			MUF.FACTOR_VAL AS USAGE_FACTOR_VALUE,
			MUF.BEGIN_DATE AS USAGE_FACTOR_BEGIN_DATE,
			MUF.END_DATE AS USAGE_FACTOR_END_DATE
		FROM ACCOUNT A,
			ACCOUNT_STATUS S,
			ACCOUNT_EDC AEDC,
			ENERGY_DISTRIBUTION_COMPANY EDC,
			ACCOUNT_ESP AESP,
			ENERGY_SERVICE_PROVIDER ESP,
			POOL P,
			ACCOUNT_SERVICE_LOCATION ASL,
			SERVICE_LOCATION SL,
			WEATHER_STATION WS,
			SERVICE_POINT SP,
			SERVICE_LOCATION_METER SLM,
			METER M,
			METER_SCHEDULE_GROUP MG, -- Meter Schedule Group
			SCHEDULE_GROUP G,
			METER_CALENDAR MCAL, -- Meter Calendar
			CALENDAR C,
			METER_LOSS_FACTOR MLF, -- Meter Loss Factor
			LOSS_FACTOR LF,
			METER_USAGE_FACTOR MUF -- Meter Usage Factor
		WHERE -- Account
			A.ACCOUNT_MODEL_OPTION = c_ACCT_MODEL_OPTION_METER
			-- Account Status
			AND S.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND p_EFFECTIVE_DATE BETWEEN S.BEGIN_DATE(+) AND NVL(S.END_DATE(+), CONSTANTS.HIGH_DATE)
			-- Account EDC
			AND AEDC.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND (AEDC.EDC_ID = p_EDC_ID OR CONSTANTS.ALL_ID = p_EDC_ID)
			AND (AEDC.EDC_RATE_CLASS = p_EDC_RATE_CLASS OR CONSTANTS.ALL_STRING = p_EDC_RATE_CLASS)
			AND p_EFFECTIVE_DATE BETWEEN AEDC.BEGIN_DATE(+) AND NVL(AEDC.END_DATE(+), CONSTANTS.HIGH_DATE)
			AND EDC.EDC_ID(+) = AEDC.EDC_ID
			-- Account ESP
			AND AESP.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND (AESP.ESP_ID = p_ESP_ID OR CONSTANTS.ALL_ID = p_ESP_ID)
			AND (AESP.POOL_ID = p_POOL_ID OR CONSTANTS.ALL_ID = p_POOL_ID)
			AND p_EFFECTIVE_DATE BETWEEN AESP.BEGIN_DATE(+) AND NVL(AESP.END_DATE(+), CONSTANTS.HIGH_DATE)
			AND ESP.ESP_ID(+) = AESP.ESP_ID
			AND P.POOL_ID(+) = AESP.POOL_ID
			-- Service Location
			AND ASL.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND p_EFFECTIVE_DATE BETWEEN ASL.BEGIN_DATE(+) AND NVL(ASL.END_DATE(+), CONSTANTS.HIGH_DATE)
			AND SL.SERVICE_LOCATION_ID(+) = ASL.SERVICE_LOCATION_ID
			AND (SL.SERVICE_POINT_ID = p_SERVICE_POINT_ID OR CONSTANTS.ALL_ID = p_SERVICE_POINT_ID)
			AND WS.STATION_ID(+) = SL.WEATHER_STATION_ID
			AND SP.SERVICE_POINT_ID(+) = SL.SERVICE_POINT_ID
			AND SLM.SERVICE_LOCATION_ID(+) = ASL.SERVICE_LOCATION_ID
			AND p_EFFECTIVE_DATE BETWEEN SLM.BEGIN_DATE(+) AND NVL(SLM.END_DATE(+), CONSTANTS.HIGH_DATE)
			AND M.METER_ID(+) = SLM.METER_ID
			-- Meter Schedule Group
			AND MG.METER_ID(+) = SLM.METER_ID
			AND (MG.SCHEDULE_GROUP_ID = p_SCHEDULE_GROUP_ID OR CONSTANTS.ALL_ID = p_SCHEDULE_GROUP_ID)
			AND p_EFFECTIVE_DATE BETWEEN MG.BEGIN_DATE(+) AND NVL(MG.END_DATE(+), CONSTANTS.HIGH_DATE)
			AND G.SCHEDULE_GROUP_ID(+) = MG.SCHEDULE_GROUP_ID
			-- Meter Calendar
			AND MCAL.CASE_ID(+) = GA.BASE_CASE_ID
			AND MCAL.METER_ID(+) = SLM.METER_ID
			AND MCAL.CALENDAR_TYPE(+) = 'Forecast'
			AND p_EFFECTIVE_DATE BETWEEN MCAL.BEGIN_DATE(+) AND NVL(MCAL.END_DATE(+), CONSTANTS.HIGH_DATE)
			AND C.CALENDAR_ID(+) = MCAL.CALENDAR_ID
			-- Meter Loss Factor
			AND MLF.CASE_ID(+) = GA.BASE_CASE_ID
			AND MLF.METER_ID(+) = SLM.METER_ID
			AND p_EFFECTIVE_DATE BETWEEN MLF.BEGIN_DATE(+) AND NVL(MLF.END_DATE(+), CONSTANTS.HIGH_DATE)
			AND LF.LOSS_FACTOR_ID(+) = MLF.LOSS_FACTOR_ID
			-- Meter Usage Factor
			AND MUF.CASE_ID(+) = GA.BASE_CASE_ID
			AND MUF.METER_ID(+) = SLM.METER_ID
			AND p_EFFECTIVE_DATE BETWEEN MUF.BEGIN_DATE(+) AND NVL(MUF.END_DATE(+), CONSTANTS.HIGH_DATE)
		ORDER BY 2,3,4,5;
END ACTIVE_ACCOUNT_LIST;
---------------------------------------------------------------------
PROCEDURE ACCOUNT_PROP_ACCOUNT_STATUSES
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_EDC_ID IN NUMBER,
	p_EDC_RATE_CLASS IN VARCHAR2,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_SCHEDULE_GROUP_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
	) AS
v_WORK_ID RTO_WORK.WORK_ID%TYPE;
BEGIN
	UT.GET_RTO_WORK_ID(v_WORK_ID);

	CACHE_ACCOUNT_IDS(v_WORK_ID,
						p_BEGIN_DATE,
						p_END_DATE,
						p_EDC_ID,
						p_EDC_RATE_CLASS,
						p_ESP_ID,
						p_POOL_ID,
						p_SERVICE_POINT_ID,
						p_SCHEDULE_GROUP_ID);

	OPEN p_CURSOR FOR
		SELECT A.ACCOUNT_ID,
			ACCOUNT_NAME,
			ACCOUNT_ALIAS,
			ACCOUNT_EXTERNAL_IDENTIFIER,
			S.BEGIN_DATE,
			S.END_DATE,
			S.STATUS_NAME AS ACCOUNT_STATUS_NAME,
			N.IS_ACTIVE AS ACCOUNT_IS_ACTIVE,
			S.ENTRY_DATE
		FROM RTO_WORK T,
			ACCOUNT A,
			ACCOUNT_STATUS S,
			ACCOUNT_STATUS_NAME N
		WHERE T.WORK_ID = v_WORK_ID
			AND A.ACCOUNT_ID = T.WORK_XID
			AND S.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND N.STATUS_NAME(+) = S.STATUS_NAME
			AND S.BEGIN_DATE(+) <= p_END_DATE
			AND NVL(S.END_DATE(+), CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
		ORDER BY ACCOUNT_NAME,
			ACCOUNT_ALIAS,
			ACCOUNT_EXTERNAL_IDENTIFIER,
			BEGIN_DATE,
			END_DATE,
			S.STATUS_NAME;

	UT.PURGE_RTO_WORK(v_WORK_ID);

END ACCOUNT_PROP_ACCOUNT_STATUSES;
---------------------------------------------------------------------
PROCEDURE ACCOUNT_PROP_ACCOUNT_EDCS
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_EDC_ID IN NUMBER,
	p_EDC_RATE_CLASS IN VARCHAR2,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_SCHEDULE_GROUP_ID IN NUMBER,
   	p_CURSOR OUT GA.REFCURSOR
	) AS
v_WORK_ID RTO_WORK.WORK_ID%TYPE;
BEGIN
	UT.GET_RTO_WORK_ID(v_WORK_ID);

	CACHE_ACCOUNT_IDS(v_WORK_ID,
					p_BEGIN_DATE,
					p_END_DATE,
					p_EDC_ID,
					p_EDC_RATE_CLASS,
					p_ESP_ID,
					p_POOL_ID,
					p_SERVICE_POINT_ID,
					p_SCHEDULE_GROUP_ID);

	OPEN p_CURSOR FOR
		SELECT A.ACCOUNT_ID,
			A.ACCOUNT_NAME,
			A.ACCOUNT_ALIAS,
			A.ACCOUNT_EXTERNAL_IDENTIFIER,
			EDC.EDC_NAME,
			AEDC.BEGIN_DATE,
			AEDC.EDC_ACCOUNT_NUMBER,
			AEDC.EDC_RATE_CLASS,
			AEDC.EDC_STRATA,
			AEDC.END_DATE,
			AEDC.ENTRY_DATE
		FROM RTO_WORK IDS,
			ACCOUNT A,
			ACCOUNT_EDC AEDC,
			ENERGY_DISTRIBUTION_COMPANY EDC
		WHERE IDS.WORK_ID = v_WORK_ID
			AND A.ACCOUNT_ID = IDS.WORK_XID
			AND AEDC.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND AEDC.BEGIN_DATE(+) <= p_END_DATE
			AND NVL(AEDC.END_DATE(+), CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND (AEDC.EDC_ID = p_EDC_ID OR CONSTANTS.ALL_ID = p_EDC_ID)
			AND (AEDC.EDC_RATE_CLASS = p_EDC_RATE_CLASS OR CONSTANTS.ALL_STRING = p_EDC_RATE_CLASS)
			AND EDC.EDC_ID(+) = AEDC.EDC_ID
		ORDER BY ACCOUNT_NAME,
			ACCOUNT_ALIAS,
			ACCOUNT_EXTERNAL_IDENTIFIER,
			EDC_NAME,
			BEGIN_DATE,
			END_DATE;

	UT.PURGE_RTO_WORK(v_WORK_ID);

END ACCOUNT_PROP_ACCOUNT_EDCS;
---------------------------------------------------------------------
PROCEDURE ACCOUNT_PROP_ACCOUNT_ESPS
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_EDC_ID IN NUMBER,
	p_EDC_RATE_CLASS IN VARCHAR2,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_SCHEDULE_GROUP_ID IN NUMBER,
   	p_CURSOR OUT GA.REFCURSOR
	) AS
v_WORK_ID RTO_WORK.WORK_ID%TYPE;
BEGIN
	UT.GET_RTO_WORK_ID(v_WORK_ID);

	CACHE_ACCOUNT_IDS(v_WORK_ID,
			  p_BEGIN_DATE,
			  p_END_DATE,
			  p_EDC_ID,
			  p_EDC_RATE_CLASS,
			  p_ESP_ID,
			  p_POOL_ID,
			  p_SERVICE_POINT_ID,
			  p_SCHEDULE_GROUP_ID);

	OPEN p_CURSOR FOR
		-- Account and Meter Type (or not Aggregate)
		-- Use Account ESP table
		SELECT A.ACCOUNT_ID,
			A.ACCOUNT_NAME,
			A.ACCOUNT_ALIAS,
			A.ACCOUNT_EXTERNAL_IDENTIFIER,
			ESP.ESP_NAME,
			P.POOL_NAME,
			AESP.BEGIN_DATE,
			AESP.END_DATE,
			AESP.ESP_ACCOUNT_NUMBER,
			AESP.ENTRY_DATE
		FROM RTO_WORK IDS,
			ACCOUNT A,
			ACCOUNT_ESP AESP, -- Account ESP
			ENERGY_SERVICE_PROVIDER ESP,
			POOL P
		WHERE IDS.WORK_ID = v_WORK_ID
			AND A.ACCOUNT_ID = IDS.WORK_XID
			AND A.ACCOUNT_MODEL_OPTION <> c_ACCT_MODEL_OPTION_AGGREGATE
			AND AESP.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND AESP.BEGIN_DATE(+) <= p_END_DATE
			AND NVL(AESP.END_DATE(+), CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND (AESP.ESP_ID = p_ESP_ID OR CONSTANTS.ALL_ID = p_ESP_ID)
			AND (AESP.POOL_ID = p_POOL_ID OR CONSTANTS.ALL_ID = p_POOL_ID)
			AND ESP.ESP_ID(+) = AESP.ESP_ID
			AND P.POOL_ID(+) = AESP.POOL_ID
		UNION ALL
		-- Aggregate Type
		-- Use Aggregate Account ESP table
		SELECT A.ACCOUNT_ID,
			A.ACCOUNT_NAME,
			A.ACCOUNT_ALIAS,
			ACCOUNT_EXTERNAL_IDENTIFIER,
			ESP.ESP_NAME,
			P.POOL_NAME,
			AESP.BEGIN_DATE,
			AESP.END_DATE,
			'NA' AS ESP_ACCOUNT_NUMBER,
			AESP.ENTRY_DATE
		FROM RTO_WORK IDS,
			ACCOUNT A,
			AGGREGATE_ACCOUNT_ESP AESP, -- Aggregate ESP
			ENERGY_SERVICE_PROVIDER ESP,
			POOL P
		WHERE IDS.WORK_ID = v_WORK_ID
			AND A.ACCOUNT_ID = IDS.WORK_XID
			AND A.ACCOUNT_MODEL_OPTION IN (c_ACCT_MODEL_OPTION_AGGREGATE)
			AND AESP.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND AESP.BEGIN_DATE(+) <= p_END_DATE
			AND NVL(AESP.END_DATE(+), CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND (AESP.ESP_ID = p_ESP_ID OR CONSTANTS.ALL_ID = p_ESP_ID)
			AND (AESP.POOL_ID = p_POOL_ID OR CONSTANTS.ALL_ID = p_POOL_ID)
			AND ESP.ESP_ID(+) = AESP.ESP_ID
			AND P.POOL_ID(+) = AESP.POOL_ID
		ORDER BY ACCOUNT_NAME,
			ACCOUNT_ALIAS,
			ACCOUNT_EXTERNAL_IDENTIFIER,
			ESP_NAME,
			BEGIN_DATE,
			END_DATE;

	UT.PURGE_RTO_WORK(v_WORK_ID);

END ACCOUNT_PROP_ACCOUNT_ESPS;
---------------------------------------------------------------------
PROCEDURE ACCOUNT_PROP_ACCOUNT_SERV_LOCS
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_EDC_ID IN NUMBER,
	p_EDC_RATE_CLASS IN VARCHAR2,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_SCHEDULE_GROUP_ID IN NUMBER,
   	p_CURSOR OUT GA.REFCURSOR
	) AS
v_WORK_ID RTO_WORK.WORK_ID%TYPE;
BEGIN

	UT.GET_RTO_WORK_ID(v_WORK_ID);

	CACHE_ACCOUNT_IDS(v_WORK_ID,
			  p_BEGIN_DATE,
			  p_END_DATE,
			  p_EDC_ID,
			  p_EDC_RATE_CLASS,
			  p_ESP_ID,
			  p_POOL_ID,
			  p_SERVICE_POINT_ID,
			  p_SCHEDULE_GROUP_ID);

	OPEN p_CURSOR FOR
		SELECT A.ACCOUNT_ID,
			A.ACCOUNT_NAME,
			A.ACCOUNT_ALIAS,
			A.ACCOUNT_EXTERNAL_IDENTIFIER,
			SL.SERVICE_LOCATION_NAME,
			ASL.SERVICE_LOCATION_ID,
			NULL AS METER_ID,
			'NA' AS METER_NAME,
			ASL.BEGIN_DATE,
			ASL.END_DATE,
			SP.SERVICE_POINT_NAME,
			WS.STATION_NAME,
			ASL.EDC_IDENTIFIER,
			ASL.ESP_IDENTIFIER,
			SL.EXTERNAL_IDENTIFIER,
			SL.LATITUDE,
			SL.LONGITUDE,
			SL.TIME_ZONE,
			ASL.ENTRY_DATE
		FROM RTO_WORK IDS,
			ACCOUNT A,
			ACCOUNT_SERVICE_LOCATION ASL,
			SERVICE_LOCATION SL,
			SERVICE_POINT SP,
			WEATHER_STATION WS
		WHERE IDS.WORK_ID = v_WORK_ID
			AND A.ACCOUNT_ID = IDS.WORK_XID
			AND A.ACCOUNT_MODEL_OPTION <> c_ACCT_MODEL_OPTION_METER
			AND ASL.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND SL.SERVICE_LOCATION_ID(+) = ASL.SERVICE_LOCATION_ID
			AND (SL.SERVICE_POINT_ID = p_SERVICE_POINT_ID OR CONSTANTS.ALL_ID = p_SERVICE_POINT_ID)
			AND ASL.BEGIN_DATE(+) <= p_END_DATE
			AND NVL(ASL.END_DATE(+), CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND SP.SERVICE_POINT_ID(+) = SL.SERVICE_POINT_ID
			AND WS.STATION_ID(+) = SL.WEATHER_STATION_ID
		UNION ALL
		SELECT A.ACCOUNT_ID,
			A.ACCOUNT_NAME,
			A.ACCOUNT_ALIAS,
			A.ACCOUNT_EXTERNAL_IDENTIFIER,
			SL.SERVICE_LOCATION_NAME,
			ASL.SERVICE_LOCATION_ID,
			SLM.METER_ID,
			M.METER_NAME,
			ASL.BEGIN_DATE,
			ASL.END_DATE,
			SP.SERVICE_POINT_NAME,
			WS.STATION_NAME,
			ASL.EDC_IDENTIFIER,
			ASL.ESP_IDENTIFIER,
			SL.EXTERNAL_IDENTIFIER,
			SL.LATITUDE,
			SL.LONGITUDE,
			SL.TIME_ZONE,
			ASL.ENTRY_DATE
		FROM RTO_WORK IDS,
			ACCOUNT A,
			ACCOUNT_SERVICE_LOCATION ASL,
			SERVICE_LOCATION SL,
			SERVICE_LOCATION_METER SLM,
			METER M,
			SERVICE_POINT SP,
			WEATHER_STATION WS
		WHERE IDS.WORK_ID = v_WORK_ID
			AND A.ACCOUNT_ID = IDS.WORK_XID
			AND A.ACCOUNT_MODEL_OPTION = c_ACCT_MODEL_OPTION_METER
			AND ASL.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND ASL.BEGIN_DATE(+) <= p_END_DATE
			AND NVL(ASL.END_DATE(+), CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND SL.SERVICE_LOCATION_ID(+) = ASL.SERVICE_LOCATION_ID
			AND (SL.SERVICE_POINT_ID = p_SERVICE_POINT_ID OR CONSTANTS.ALL_ID = p_SERVICE_POINT_ID)
			AND SLM.SERVICE_LOCATION_ID(+) = ASL.SERVICE_LOCATION_ID
			AND SLM.BEGIN_DATE(+) <= NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE)
			AND NVL(SLM.END_DATE(+),CONSTANTS.HIGH_DATE) >= ASL.BEGIN_DATE
			AND M.METER_ID(+) = SLM.METER_ID
			AND SP.SERVICE_POINT_ID(+) = SL.SERVICE_POINT_ID
			AND WS.STATION_ID(+) = SL.WEATHER_STATION_ID
		ORDER BY ACCOUNT_NAME,
			ACCOUNT_ALIAS,
			ACCOUNT_EXTERNAL_IDENTIFIER,
			SERVICE_LOCATION_NAME,
			METER_NAME,
			BEGIN_DATE,
			END_DATE;

	UT.PURGE_RTO_WORK(v_WORK_ID);

END ACCOUNT_PROP_ACCOUNT_SERV_LOCS;
---------------------------------------------------------------------
PROCEDURE ACCOUNT_PROP_CALENDARS
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_EDC_ID IN NUMBER,
	p_EDC_RATE_CLASS IN VARCHAR2,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_SCHEDULE_GROUP_ID IN NUMBER,
   	p_CURSOR OUT GA.REFCURSOR
	) AS
v_WORK_ID RTO_WORK.WORK_ID%TYPE;
BEGIN
	UT.GET_RTO_WORK_ID(v_WORK_ID);

	CACHE_ACCOUNT_IDS(v_WORK_ID,
			  p_BEGIN_DATE,
			  p_END_DATE,
			  p_EDC_ID,
			  p_EDC_RATE_CLASS,
			  p_ESP_ID,
			  p_POOL_ID,
			  p_SERVICE_POINT_ID,
			  p_SCHEDULE_GROUP_ID);

	OPEN p_CURSOR FOR
		-- Account Calendar
		SELECT A.ACCOUNT_ID,
			A.ACCOUNT_NAME,
			A.ACCOUNT_ALIAS,
			A.ACCOUNT_EXTERNAL_IDENTIFIER,
			NULL AS METER_ID,
			'NA' AS METER_NAME,
			NULL AS SERVICE_LOCATION_ID,
			L.CASE_NAME,
			C.CALENDAR_NAME,
			AC.CALENDAR_TYPE,
			AC.BEGIN_DATE,
			AC.END_DATE,
			AC.ENTRY_DATE
		FROM RTO_WORK IDS,
			ACCOUNT A,
			ACCOUNT_CALENDAR AC,
			CASE_LABEL L,
			CALENDAR C
		WHERE IDS.WORK_ID = v_WORK_ID
			AND A.ACCOUNT_ID = IDS.WORK_XID
			AND A.ACCOUNT_MODEL_OPTION <> c_ACCT_MODEL_OPTION_METER
			AND AC.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND AC.BEGIN_DATE(+) <= p_END_DATE
			AND NVL(AC.END_DATE(+), CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND L.CASE_ID(+) = AC.CASE_ID
			AND C.CALENDAR_ID(+) = AC.CALENDAR_ID
		UNION ALL
		-- Meter Calendar
		SELECT A.ACCOUNT_ID,
			A.ACCOUNT_NAME,
			A.ACCOUNT_ALIAS,
			A.ACCOUNT_EXTERNAL_IDENTIFIER,
			SLM.METER_ID,
			M.METER_NAME,
			ASL.SERVICE_LOCATION_ID,
			L.CASE_NAME,
			C.CALENDAR_NAME,
			MC.CALENDAR_TYPE,
			MC.BEGIN_DATE,
			MC.END_DATE,
			MC.ENTRY_DATE
		FROM RTO_WORK IDS,
			ACCOUNT A,
			ACCOUNT_SERVICE_LOCATION ASL,
			SERVICE_LOCATION_METER SLM,
			METER M,
			METER_CALENDAR MC,
			CASE_LABEL L,
			CALENDAR C
		WHERE IDS.WORK_ID = v_WORK_ID
			AND A.ACCOUNT_ID = IDS.WORK_XID
			AND A.ACCOUNT_MODEL_OPTION = c_ACCT_MODEL_OPTION_METER
			AND ASL.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND SLM.SERVICE_LOCATION_ID(+) = ASL.SERVICE_LOCATION_ID
			AND SLM.BEGIN_DATE(+) <= NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE)
            AND NVL(SLM.END_DATE(+), CONSTANTS.HIGH_DATE) >= ASL.BEGIN_DATE
			AND M.METER_ID(+) = SLM.METER_ID
			AND MC.METER_ID(+) = SLM.METER_ID
			AND MC.BEGIN_DATE(+) <= p_END_DATE
			AND NVL(MC.END_DATE(+), CONSTANTS.HIGH_DATE)  >= p_BEGIN_DATE
			AND L.CASE_ID(+) = MC.CASE_ID
			AND C.CALENDAR_ID(+) = MC.CALENDAR_ID
		ORDER BY ACCOUNT_NAME,
			ACCOUNT_ALIAS,
			ACCOUNT_EXTERNAL_IDENTIFIER,
			METER_NAME,
			CASE_NAME,
			CALENDAR_NAME,
			CALENDAR_TYPE,
			BEGIN_DATE,
			END_DATE;

	UT.PURGE_RTO_WORK(v_WORK_ID);

END ACCOUNT_PROP_CALENDARS;
---------------------------------------------------------------------
PROCEDURE ACCOUNT_PROP_LOSS_FACTORS
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_EDC_ID IN NUMBER,
	p_EDC_RATE_CLASS IN VARCHAR2,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_SCHEDULE_GROUP_ID IN NUMBER,
   	p_CURSOR OUT GA.REFCURSOR
	) AS
v_WORK_ID RTO_WORK.WORK_ID%TYPE;
BEGIN
	UT.GET_RTO_WORK_ID(v_WORK_ID);

	CACHE_ACCOUNT_IDS(v_WORK_ID,
			  p_BEGIN_DATE,
			  p_END_DATE,
			  p_EDC_ID,
			  p_EDC_RATE_CLASS,
			  p_ESP_ID,
			  p_POOL_ID,
			  p_SERVICE_POINT_ID,
			  p_SCHEDULE_GROUP_ID);

	OPEN p_CURSOR FOR
		-- Account Loss factor
		SELECT A.ACCOUNT_ID,
			A.ACCOUNT_NAME,
			A.ACCOUNT_ALIAS,
			A.ACCOUNT_EXTERNAL_IDENTIFIER,
			NULL AS METER_ID,
			'NA' AS METER_NAME,
			NULL AS SERVICE_LOCATION_ID,
			L.CASE_NAME,
			LF.LOSS_FACTOR_NAME,
			ALF.BEGIN_DATE,
			ALF.END_DATE,
			ALF.ENTRY_DATE
		FROM RTO_WORK IDS,
			ACCOUNT A,
			ACCOUNT_LOSS_FACTOR ALF,
			CASE_LABEL L,
			LOSS_FACTOR LF
		WHERE IDS.WORK_ID = v_WORK_ID
			AND A.ACCOUNT_ID = IDS.WORK_XID
			AND A.ACCOUNT_MODEL_OPTION <> c_ACCT_MODEL_OPTION_METER
			AND ALF.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND ALF.BEGIN_DATE(+) <= p_END_DATE
			AND NVL(ALF.END_DATE(+), CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND L.CASE_ID(+) = ALF.CASE_ID
			AND LF.LOSS_FACTOR_ID(+) = ALF.LOSS_FACTOR_ID
		UNION ALL
		-- Meter Loss Factor
		SELECT A.ACCOUNT_ID,
			A.ACCOUNT_NAME,
			A.ACCOUNT_ALIAS,
			A.ACCOUNT_EXTERNAL_IDENTIFIER,
			SLM.METER_ID,
			M.METER_NAME,
			ASL.SERVICE_LOCATION_ID,
			L.CASE_NAME,
			LF.LOSS_FACTOR_NAME,
			MLF.BEGIN_DATE,
			MLF.END_DATE,
			MLF.ENTRY_DATE
		FROM RTO_WORK IDS,
			ACCOUNT A,
			ACCOUNT_SERVICE_LOCATION ASL,
			SERVICE_LOCATION_METER SLM,
			METER M,
			METER_LOSS_FACTOR MLF,
			CASE_LABEL L,
			LOSS_FACTOR LF
		WHERE IDS.WORK_ID = v_WORK_ID
			AND A.ACCOUNT_ID = IDS.WORK_XID
			AND A.ACCOUNT_MODEL_OPTION = c_ACCT_MODEL_OPTION_METER
			AND ASL.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND SLM.SERVICE_LOCATION_ID(+) = ASL.SERVICE_LOCATION_ID
			AND SLM.BEGIN_DATE(+) <= NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE)
            AND NVL(SLM.END_DATE(+), CONSTANTS.HIGH_DATE) >= ASL.BEGIN_DATE
			AND M.METER_ID(+) = SLM.METER_ID
			AND MLF.METER_ID(+) = SLM.METER_ID
			AND MLF.BEGIN_DATE(+) <= p_END_DATE
			AND NVL(MLF.END_DATE(+), CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND L.CASE_ID(+) = MLF.CASE_ID
			AND LF.LOSS_FACTOR_ID(+) = MLF.LOSS_FACTOR_ID
		ORDER BY ACCOUNT_NAME,
			ACCOUNT_ALIAS,
			ACCOUNT_EXTERNAL_IDENTIFIER,
			METER_NAME,
			CASE_NAME,
			LOSS_FACTOR_NAME,
			BEGIN_DATE,
			END_DATE;

	UT.PURGE_RTO_WORK(v_WORK_ID);

END ACCOUNT_PROP_LOSS_FACTORS;
---------------------------------------------------------------------
PROCEDURE ACCOUNT_PROP_SCHEDULE_GROUPS
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_EDC_ID IN NUMBER,
	p_EDC_RATE_CLASS IN VARCHAR2,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_SCHEDULE_GROUP_ID IN NUMBER,
   	p_CURSOR OUT GA.REFCURSOR
	) AS
v_WORK_ID RTO_WORK.WORK_ID%TYPE;
BEGIN
	UT.GET_RTO_WORK_ID(v_WORK_ID);

	CACHE_ACCOUNT_IDS(v_WORK_ID,
			  p_BEGIN_DATE,
			  p_END_DATE,
			  p_EDC_ID,
			  p_EDC_RATE_CLASS,
			  p_ESP_ID,
			  p_POOL_ID,
			  p_SERVICE_POINT_ID,
			  p_SCHEDULE_GROUP_ID);

	OPEN p_CURSOR FOR
		-- Account Schedule Groups
		SELECT A.ACCOUNT_ID,
			A.ACCOUNT_NAME,
			A.ACCOUNT_ALIAS,
			A.ACCOUNT_EXTERNAL_IDENTIFIER,
			NULL AS METER_ID,
			'NA' AS METER_NAME,
			NULL AS SERVICE_LOCATION_ID,
			G.SCHEDULE_GROUP_NAME,
			ASG.BEGIN_DATE,
			ASG.END_DATE,
			ASG.ENTRY_DATE
		FROM RTO_WORK IDS,
			ACCOUNT A,
			ACCOUNT_SCHEDULE_GROUP ASG,
			SCHEDULE_GROUP G
		WHERE IDS.WORK_ID = v_WORK_ID
			AND A.ACCOUNT_ID = IDS.WORK_XID
			AND A.ACCOUNT_MODEL_OPTION <> c_ACCT_MODEL_OPTION_METER
			AND ASG.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND (ASG.SCHEDULE_GROUP_ID = p_SCHEDULE_GROUP_ID OR CONSTANTS.ALL_ID = p_SCHEDULE_GROUP_ID)
			AND ASG.BEGIN_DATE(+) <= p_END_DATE
			AND NVL(ASG.END_DATE(+), CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND G.SCHEDULE_GROUP_ID(+) = ASG.SCHEDULE_GROUP_ID
		UNION ALL
		-- Meter Schedule Groups
		SELECT A.ACCOUNT_ID,
			A.ACCOUNT_NAME,
			A.ACCOUNT_ALIAS,
			A.ACCOUNT_EXTERNAL_IDENTIFIER,
			SLM.METER_ID,
			M.METER_NAME,
			ASL.SERVICE_LOCATION_ID,
			G.SCHEDULE_GROUP_NAME,
			MSG.BEGIN_DATE,
			MSG.END_DATE,
			MSG.ENTRY_DATE
		FROM RTO_WORK IDS,
			ACCOUNT A,
			ACCOUNT_SERVICE_LOCATION ASL,
			SERVICE_LOCATION_METER SLM,
			METER M,
			METER_SCHEDULE_GROUP MSG,
			SCHEDULE_GROUP G
		WHERE IDS.WORK_ID = v_WORK_ID
			AND A.ACCOUNT_ID = IDS.WORK_XID
			AND A.ACCOUNT_MODEL_OPTION = c_ACCT_MODEL_OPTION_METER
			AND ASL.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND (MSG.SCHEDULE_GROUP_ID = p_SCHEDULE_GROUP_ID OR CONSTANTS.ALL_ID = p_SCHEDULE_GROUP_ID)
			AND SLM.SERVICE_LOCATION_ID(+) = ASL.SERVICE_LOCATION_ID
			AND SLM.BEGIN_DATE(+) <= NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE)
            AND NVL(SLM.END_DATE(+), CONSTANTS.HIGH_DATE) >= ASL.BEGIN_DATE
			AND M.METER_ID(+) = SLM.METER_ID
			AND MSG.METER_ID(+) = SLM.METER_ID
			AND MSG.BEGIN_DATE(+) <= p_END_DATE
			AND NVL(MSG.END_DATE(+), CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND G.SCHEDULE_GROUP_ID(+) = MSG.SCHEDULE_GROUP_ID
		ORDER BY ACCOUNT_NAME,
			ACCOUNT_ALIAS,
			ACCOUNT_EXTERNAL_IDENTIFIER,
			METER_NAME,
			SCHEDULE_GROUP_NAME,
			BEGIN_DATE,
			END_DATE;

	UT.PURGE_RTO_WORK(v_WORK_ID);

END ACCOUNT_PROP_SCHEDULE_GROUPS;
---------------------------------------------------------------------
PROCEDURE ACCOUNT_PROP_PRODUCTS
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_EDC_ID IN NUMBER,
	p_EDC_RATE_CLASS IN VARCHAR2,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER,
	p_SCHEDULE_GROUP_ID IN NUMBER,
   	p_CURSOR OUT GA.REFCURSOR
	) AS
v_WORK_ID RTO_WORK.WORK_ID%TYPE;
BEGIN
	UT.GET_RTO_WORK_ID(v_WORK_ID);

	CACHE_ACCOUNT_IDS(v_WORK_ID,
			  p_BEGIN_DATE,
			  p_END_DATE,
			  p_EDC_ID,
			  p_EDC_RATE_CLASS,
			  p_ESP_ID,
			  p_POOL_ID,
			  p_SERVICE_POINT_ID,
			  p_SCHEDULE_GROUP_ID);

	OPEN p_CURSOR FOR
		-- Account Products
		SELECT A.ACCOUNT_ID,
			A.ACCOUNT_NAME,
			A.ACCOUNT_ALIAS,
			A.ACCOUNT_EXTERNAL_IDENTIFIER,
			NULL AS METER_ID,
			'NA' AS METER_NAME,
			NULL AS SERVICE_LOCATION_ID,
			L.CASE_NAME,
			CASE AP.PRODUCT_TYPE
				WHEN 'R' THEN c_PRODUCT_TYPE_REVENUE
				WHEN 'C' THEN c_PRODUCT_TYPE_COST
				WHEN 'B' THEN c_PRODUCT_TYPE_BILLING
				END AS PRODUCT_TYPE,
			P.PRODUCT_NAME,
			AP.BEGIN_DATE,
			AP.END_DATE,
			AP.ENTRY_DATE
		FROM RTO_WORK IDS,
			ACCOUNT A,
			ACCOUNT_PRODUCT AP,
			PRODUCT P,
			CASE_LABEL L
		WHERE IDS.WORK_ID = v_WORK_ID
			AND A.ACCOUNT_ID = IDS.WORK_XID
			AND A.ACCOUNT_MODEL_OPTION <> c_ACCT_MODEL_OPTION_METER
			AND AP.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND AP.BEGIN_DATE(+) <= p_END_DATE
			AND NVL(AP.END_DATE(+), CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND P.PRODUCT_ID(+) = AP.PRODUCT_ID
			AND L.CASE_ID(+) = AP.CASE_ID
		UNION ALL
		-- Meter Products
		SELECT A.ACCOUNT_ID,
			A.ACCOUNT_NAME,
			A.ACCOUNT_ALIAS,
			A.ACCOUNT_EXTERNAL_IDENTIFIER,
			SLM.METER_ID,
			M.METER_NAME,
			ASL.SERVICE_LOCATION_ID,
			L.CASE_NAME,
			CASE MP.PRODUCT_TYPE
				WHEN 'R' THEN c_PRODUCT_TYPE_REVENUE
				WHEN 'C' THEN c_PRODUCT_TYPE_COST
				WHEN 'B' THEN c_PRODUCT_TYPE_BILLING
				END AS PRODUCT_TYPE,
			P.PRODUCT_NAME,
			MP.BEGIN_DATE,
			MP.END_DATE,
			MP.ENTRY_DATE
		FROM RTO_WORK IDS,
			ACCOUNT A,
			ACCOUNT_SERVICE_LOCATION ASL,
			SERVICE_LOCATION_METER SLM,
			METER M,
			METER_PRODUCT MP,
			PRODUCT P,
			CASE_LABEL L
		WHERE IDS.WORK_ID = v_WORK_ID
			AND A.ACCOUNT_ID = IDS.WORK_XID
			AND A.ACCOUNT_MODEL_OPTION = c_ACCT_MODEL_OPTION_METER
			AND ASL.ACCOUNT_ID(+) = A.ACCOUNT_ID
			AND SLM.SERVICE_LOCATION_ID(+) = ASL.SERVICE_LOCATION_ID
			AND SLM.BEGIN_DATE(+) <= NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE)
            AND NVL(SLM.END_DATE(+), CONSTANTS.HIGH_DATE) >= ASL.BEGIN_DATE
			AND M.METER_ID(+) = SLM.METER_ID
			AND MP.METER_ID(+) = SLM.METER_ID
			AND MP.BEGIN_DATE(+) <= p_END_DATE
			AND NVL(MP.END_DATE(+), CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND P.PRODUCT_ID(+) = MP.PRODUCT_ID
			AND L.CASE_ID(+) = MP.CASE_ID
		ORDER BY ACCOUNT_NAME,
			ACCOUNT_ALIAS,
			ACCOUNT_EXTERNAL_IDENTIFIER,
			METER_NAME,
			CASE_NAME,
			PRODUCT_TYPE,
			BEGIN_DATE,
			END_DATE;

	UT.PURGE_RTO_WORK(v_WORK_ID);

END ACCOUNT_PROP_PRODUCTS;
--------------------------------------------------------------------------------
PROCEDURE SL_CHILD_FOLDERS
	(
	p_ACCOUNT_ID	IN NUMBER,
	p_SHOW_METERS	IN VARCHAR2,
	p_SHOW_RESOURCES IN VARCHAR2,
	p_CURSOR		OUT GA.REFCURSOR
	) AS

	v_MODEL_OPTION VARCHAR2(16);
	v_MODEL_ID NUMBER(1);
	v_SHOW_METERS NUMBER(1);
	v_SHOW_RESOURCES NUMBER(1);
BEGIN

	IF p_SHOW_METERS IS NOT NULL THEN
		v_SHOW_METERS := UT.NUMBER_FROM_BOOLEAN(UT.BOOLEAN_FROM_STRING(p_SHOW_METERS));
	ELSE
		v_SHOW_METERS := 1;
	END IF;

	IF p_SHOW_RESOURCES IS NOT NULL THEN
		v_SHOW_RESOURCES := UT.NUMBER_FROM_BOOLEAN(UT.BOOLEAN_FROM_STRING(p_SHOW_RESOURCES));
	ELSE
		v_SHOW_RESOURCES := 1;
	END IF;

	SELECT A.ACCOUNT_MODEL_OPTION, A.MODEL_ID
	INTO v_MODEL_OPTION, v_MODEL_ID
	FROM ACCOUNT A
	WHERE A.ACCOUNT_ID = p_ACCOUNT_ID;

	OPEN p_CURSOR FOR
		SELECT 'Meters' AS CHILD_FOLDER,
			'METER' AS ENTITY_TYPE
		FROM DUAL
		WHERE v_MODEL_OPTION IS NOT NULL AND
			NVL(v_MODEL_OPTION, c_ACCT_MODEL_OPTION_ACCOUNT)
				= c_ACCT_MODEL_OPTION_METER AND
				v_SHOW_METERS = 1
		UNION ALL
		SELECT 'Resources' AS CHILD_FOLDER,
			'DER' AS ENTITY_TYPE
		FROM DUAL
		WHERE NVL(v_MODEL_ID, CONSTANTS.GAS_MODEL) = CONSTANTS.ELECTRIC_MODEL AND
			v_SHOW_RESOURCES = 1;

END SL_CHILD_FOLDERS;
--------------------------------------------------------------------------------
PROCEDURE DER_LIST
	(
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE   IN DATE,
	p_SEARCH_STRING      IN VARCHAR,
	p_SEARCH_OPTION      IN VARCHAR,
	p_SEARCH_TYPE        IN NUMBER,
	p_FIND_DER_ID    IN NUMBER,
	p_SEARCH_OPTION_NAME OUT VARCHAR2,
	p_CURSOR     IN OUT GA.REFCURSOR
	) AS
BEGIN

	-- This procedure supports the following search options:
	--      By Name
	--      By Alias
	--      By External Identifier
	--      By Serial #

	-- Data Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_SERVICE_LOCATION_ID, EC.ED_SERVICE_LOCATION);

	-- Set the Search Option Name which is used in the Colummn Display Formula of
	-- the SEARCH_NAME column in the Numerous Find results grid.
	CASE p_SEARCH_OPTION
		WHEN 'By Alias' THEN
			p_SEARCH_OPTION_NAME := 'Alias';
		WHEN 'By External Identifier' THEN
			p_SEARCH_OPTION_NAME := 'External Identifier';
		WHEN 'By Serial #' THEN
			p_SEARCH_OPTION_NAME := 'Serial #';
		ELSE
			p_SEARCH_OPTION_NAME := 'Name';
	END CASE;

	-- Normal Search
	IF p_SEARCH_TYPE IS NULL OR p_SEARCH_TYPE = CONSTANTS.SEARCH_TYPE_NORMAL THEN
		-- Return all records (no LIKE clause)
		-- We still return the SEARCH_NAME column in case this is a '%' in the Find Dialog.
		IF p_SEARCH_STRING = '%' OR p_SEARCH_STRING IS NULL THEN
			OPEN p_CURSOR FOR
				SELECT CASE p_SEARCH_OPTION
						   WHEN 'By Alias' THEN
							DER.DER_ALIAS
						   WHEN 'By External Identifier' THEN
							DER.EXTERNAL_IDENTIFIER
						   WHEN 'By Serial #' THEN
						    DER.SERIAL_NUMBER
						   ELSE
							NULL
					   END AS SEARCH_NAME,
					   DER.DER_ID,
					   DER.DER_NAME
				FROM DISTRIBUTED_ENERGY_RESOURCE DER
				WHERE DER.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
					AND NVL(DER.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND DER.BEGIN_DATE <= p_END_DATE
				ORDER BY 1,3;
		ELSE
			OPEN p_CURSOR FOR
				SELECT CASE p_SEARCH_OPTION
						   WHEN 'By Alias' THEN
							DER.DER_ALIAS
						   WHEN 'By External Identifier' THEN
							DER.EXTERNAL_IDENTIFIER
						   WHEN 'By Serial #' THEN
						    DER.SERIAL_NUMBER
						   ELSE
							NULL
					   END AS SEARCH_NAME,
					   DER.DER_ID,
					   DER.DER_NAME
				FROM DISTRIBUTED_ENERGY_RESOURCE DER
				WHERE DER.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
					AND NVL(DER.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND DER.BEGIN_DATE <= p_END_DATE
					AND ((p_SEARCH_OPTION = 'By Name' AND DER.DER_NAME LIKE p_SEARCH_STRING) OR
					  (p_SEARCH_OPTION = 'By Alias' AND DER.DER_ALIAS LIKE p_SEARCH_STRING) OR
					  (p_SEARCH_OPTION = 'By External Identifier' AND DER.EXTERNAL_IDENTIFIER LIKE p_SEARCH_STRING) OR
					  (p_SEARCH_OPTION = 'By Serial #' AND DER.SERIAL_NUMBER LIKE p_SEARCH_STRING))
				ORDER BY 1,3;
		END IF;
	-- Specific Value
	ELSIF p_SEARCH_TYPE = CONSTANTS.SEARCH_TYPE_BY_VAL THEN
		OPEN p_CURSOR FOR
			SELECT DER.DER_ID, DER.DER_NAME
			FROM DISTRIBUTED_ENERGY_RESOURCE DER
			WHERE DER.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
				AND DER.DER_ID = p_FIND_DER_ID
				AND NVL(DER.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
				AND DER.BEGIN_DATE <= p_END_DATE
			ORDER BY 2;
	END IF;

END DER_LIST;
--------------------------------------------------------------------------------
PROCEDURE GET_DER
(
	p_DER_ID IN NUMBER,
	p_DER_NAME OUT VARCHAR2,
	p_DER_ALIAS OUT VARCHAR2,
	p_DER_DESC OUT VARCHAR2,
	p_EXTERNAL_IDENTIFIER OUT VARCHAR2,
	p_DER_TYPE_ID OUT NUMBER,
	p_DER_TYPE_DISP OUT VARCHAR2,
	p_EXTERNAL_SYSTEM_ID OUT NUMBER,
	p_EXTERNAL_SYSTEM_DISP OUT VARCHAR2,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE,
	p_SERIAL_NUMBER OUT VARCHAR2,
	p_LAST_CALLED OUT DATE,
	p_LAST_STATUS OUT VARCHAR2
) AS

	v_SERVICE_LOCATION_ID NUMBER(9);
	v_SERVICE_LOCATION_DISP VARCHAR2(64);

BEGIN

	EM_GET.DER(p_DER_ID,
				p_DER_NAME,
				p_DER_ALIAS,
				p_DER_DESC,
				v_SERVICE_LOCATION_ID,
				v_SERVICE_LOCATION_DISP,
				p_DER_TYPE_ID,
				p_DER_TYPE_DISP,
				p_EXTERNAL_SYSTEM_ID,
				p_EXTERNAL_SYSTEM_DISP,
				p_EXTERNAL_IDENTIFIER,
				p_BEGIN_DATE,
				p_END_DATE,
				p_SERIAL_NUMBER);

	SELECT MAX(STATUS), MAX(STATUS_DATE)
	INTO p_LAST_STATUS, p_LAST_CALLED
	FROM (SELECT EXCP.EXCEPTION_TYPE AS STATUS, EXCP.EXCEPTION_DATE AS STATUS_DATE
		FROM DR_EVENT EV, DR_EVENT_EXCEPTION EXCP
		WHERE EXCP.DER_ID = p_DER_ID
			AND EV.EVENT_ID = EXCP.EVENT_ID
			AND EV.START_TIME IS NOT NULL
		UNION ALL
		SELECT 'Success' AS STATUS, EV.START_TIME AS STATUS_DATE
		FROM DR_EVENT EV, DR_EVENT_PARTICIPATION PART
		WHERE PART.DER_ID = p_DER_ID
			AND EV.EVENT_ID = PART.EVENT_ID
			AND EV.START_TIME IS NOT NULL
		ORDER BY STATUS_DATE DESC)
	WHERE ROWNUM = 1;

END GET_DER;
--------------------------------------------------------------------------------
PROCEDURE GET_DER_HISTORY
	(
	p_DER_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
	SELECT EV.EVENT_NAME, FROM_CUT(EV.START_TIME, SZ.TIME_ZONE) AS EVENT_DATE, NVL(EXCP.EXCEPTION_TYPE, 'Success') AS STATUS,
		EXCP.EXCEPTION_DATE, NVL(EXCP.ENTRY_DATE, PART.ENTRY_DATE) AS ENTRY_DATE
	FROM DR_EVENT EV, DR_EVENT_EXCEPTION EXCP, DR_EVENT_PARTICIPATION PART,
		VIRTUAL_POWER_PLANT VPP, SERVICE_ZONE SZ
	WHERE EXCP.DER_ID (+) = p_DER_ID
		AND EXCP.EVENT_ID (+) = EV.EVENT_ID
		AND PART.DER_ID (+) = p_DER_ID
		AND PART.EVENT_ID (+) = EV.EVENT_ID
		AND EV.START_TIME IS NOT NULL
		AND (EXCP.DER_ID IS NOT NULL OR PART.DER_ID IS NOT NULL)
		AND VPP.VPP_ID (+) = EV.VPP_ID
		AND SZ.SERVICE_ZONE_ID (+) = VPP.SERVICE_ZONE_ID;

END GET_DER_HISTORY;
--------------------------------------------------------------------------------
PROCEDURE GET_PATH_FOR_SERVICE_LOCATION
	(
	p_ACCOUNT_ID IN OUT NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SERVICE_LOCATION_ID IN NUMBER
	) AS

BEGIN

-- EITHER WE HAVE THE ID FOR SERVICE LOCATION, OR WE HAVE THE ACCOUNT_ID
-- NO OTHER CALL TO GET_PATH_FOR_SERVICE_LOCATION IS VALID

	IF NVL(p_SERVICE_LOCATION_ID, -9) = -9 THEN

		IF p_ACCOUNT_ID IS NULL THEN
			ERRS.RAISE(MSGCODES.c_ERR_GENERAL, 'If a new service location is specified, then you must specify a parent account.');
		END IF;

	ELSE
		-- WE COULD HAVE MORE THAN ONE VALID ACCOUNT PARENTS FOR THIS SERVICE
		-- LOCATION IN THE GIVEN DATE RANGE, PICK THE FIRST ACCOUNT BY NAME
		SELECT MAX(A.ACCOUNT_ID)
		INTO p_ACCOUNT_ID
		FROM ACCOUNT_SERVICE_LOCATION ASL, ACCOUNT A
		WHERE ASL.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
			AND A.ACCOUNT_ID = ASL.ACCOUNT_ID
			AND NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND ASL.BEGIN_DATE <= p_END_DATE
			AND ROWNUM = 1
		ORDER BY A.ACCOUNT_NAME;

	END IF;

END GET_PATH_FOR_SERVICE_LOCATION;
--------------------------------------------------------------------------------
PROCEDURE GET_PATH_FOR_METER
	(
	p_ACCOUNT_ID OUT NUMBER,
	p_SERVICE_LOCATION_ID IN OUT NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_METER_ID IN NUMBER
	) AS

BEGIN

	IF NVL(p_METER_ID, -9) = -9 THEN
		IF p_SERVICE_LOCATION_ID IS NULL THEN
			ERRS.RAISE(MSGCODES.c_ERR_GENERAL, 'If a new meter is specified, then you must specify a parent service location.');
		END IF;

		GET_PATH_FOR_SERVICE_LOCATION(p_ACCOUNT_ID, p_BEGIN_DATE, p_END_DATE, p_SERVICE_LOCATION_ID);
	ELSE
		SELECT MAX(A.ACCOUNT_ID), MAX(SL.SERVICE_LOCATION_ID)
		INTO p_ACCOUNT_ID, p_SERVICE_LOCATION_ID
		FROM ACCOUNT_SERVICE_LOCATION ASL, ACCOUNT A, SERVICE_LOCATION_METER SLM,
			SERVICE_LOCATION SL
		WHERE SLM.METER_ID = p_METER_ID
			AND NVL(SLM.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND SLM.BEGIN_DATE <= p_END_DATE
			AND SL.SERVICE_LOCATION_ID = SLM.SERVICE_LOCATION_ID
			AND ASL.SERVICE_LOCATION_ID = SL.SERVICE_LOCATION_ID
			AND A.ACCOUNT_ID = ASL.ACCOUNT_ID
			AND NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND ASL.BEGIN_DATE <= p_END_DATE
			AND ROWNUM = 1
		ORDER BY A.ACCOUNT_NAME, SL.SERVICE_LOCATION_NAME;
	END IF;

END GET_PATH_FOR_METER;
--------------------------------------------------------------------------------
PROCEDURE GET_PATH_FOR_DER
(
	p_ACCOUNT_ID OUT NUMBER,
	p_SERVICE_LOCATION_ID IN OUT NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_DER_ID IN NUMBER
) AS

BEGIN

	IF NVL(p_DER_ID, -9) = -9 THEN
		IF p_SERVICE_LOCATION_ID IS NULL THEN
			ERRS.RAISE(MSGCODES.c_ERR_GENERAL, 'If a new distributed energy resource is specified, then you must specify a parent service location.');
		END IF;

		GET_PATH_FOR_SERVICE_LOCATION(p_ACCOUNT_ID, p_BEGIN_DATE, p_END_DATE, p_SERVICE_LOCATION_ID);
	ELSE
		SELECT MAX(A.ACCOUNT_ID), MAX(SL.SERVICE_LOCATION_ID)
		INTO p_ACCOUNT_ID, p_SERVICE_LOCATION_ID
		FROM ACCOUNT_SERVICE_LOCATION ASL, ACCOUNT A, SERVICE_LOCATION SL,
			DISTRIBUTED_ENERGY_RESOURCE DER
		WHERE DER.DER_ID = p_DER_ID
			AND NVL(DER.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND DER.BEGIN_DATE <= p_END_DATE
			AND SL.SERVICE_LOCATION_ID = DER.SERVICE_LOCATION_ID
			AND ASL.SERVICE_LOCATION_ID = SL.SERVICE_LOCATION_ID
			AND A.ACCOUNT_ID = ASL.ACCOUNT_ID
			AND NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND ASL.BEGIN_DATE <= p_END_DATE
			AND ROWNUM = 1
		ORDER BY A.ACCOUNT_NAME, SL.SERVICE_LOCATION_NAME;
	END IF;

END GET_PATH_FOR_DER;
--------------------------------------------------------------------------------
PROCEDURE ACCOUNT_EVENT_HISTORY
(
	p_ACCOUNT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
) AS

v_CUT_BEGIN DATE;
v_CUT_END DATE;

BEGIN

	UT.CUT_DATE_RANGE(CONSTANTS.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE,
		v_CUT_BEGIN, v_CUT_END);

	OPEN p_CURSOR FOR
	SELECT P.PROGRAM_ID, P.PROGRAM_NAME, EVT.EVENT_ID, EVT.EVENT_NAME, FROM_CUT(EVT.START_TIME, p_TIME_ZONE) AS START_TIME,
		FROM_CUT(EVT.STOP_TIME, p_TIME_ZONE) AS STOP_TIME,
		CASE WHEN COUNT(FAIL.DER_ID) > 0 THEN
			'Resource Failure'
		WHEN COUNT(OPT.DER_ID) > 0 THEN
			'Opt-out'
		WHEN COUNT(OVER.DER_ID) > 0 THEN
			'Override'
		ELSE
			'Participated'
		END AS PARTICIPATION
	FROM ACCOUNT_SERVICE_LOCATION ASL,
		SERVICE_LOCATION SL,
		DISTRIBUTED_ENERGY_RESOURCE DER,
		DER_PROGRAM DP,
		DR_EVENT EVT,
		DR_EVENT_EXCEPTION FAIL,
		DR_EVENT_EXCEPTION OVER,
		DR_EVENT_EXCEPTION OPT,
		DR_EVENT_PARTICIPATION PART,
		VIRTUAL_POWER_PLANT VPP,
		PROGRAM P
	WHERE ASL.ACCOUNT_ID = p_ACCOUNT_ID
		AND SL.SERVICE_LOCATION_ID = ASL.SERVICE_LOCATION_ID
		AND DER.SERVICE_LOCATION_ID = ASL.SERVICE_LOCATION_ID
		AND DP.DER_ID = DER.DER_ID
		AND DP.BEGIN_DATE <= p_END_DATE
		AND NVL(DP.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
		AND DP.BEGIN_DATE <= NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE)
		AND NVL(DP.END_DATE, CONSTANTS.HIGH_DATE) >= ASL.BEGIN_DATE
		AND VPP.PROGRAM_ID = DP.PROGRAM_ID
		AND VPP.SERVICE_ZONE_ID = SL.SERVICE_ZONE_ID
		AND EVT.VPP_ID = VPP.VPP_ID
		AND NVL(EVT.START_TIME, CONSTANTS.LOW_DATE) <= v_CUT_END
		AND NVL(EVT.STOP_TIME, CONSTANTS.HIGH_DATE) >= v_CUT_BEGIN
		AND P.PROGRAM_ID = VPP.PROGRAM_ID
		AND (FAIL.EVENT_ID = EVT.EVENT_ID OR FAIL.EVENT_ID IS NULL)
		AND FAIL.DER_ID (+) = DER.DER_ID
		AND FAIL.EXCEPTION_TYPE (+) = DEMAND_RESPONSE_UTIL.c_EXCEPTION_TYPE_FAILURE
		AND (OVER.EVENT_ID = EVT.EVENT_ID OR OVER.EVENT_ID IS NULL)
		AND OVER.DER_ID (+) = DER.DER_ID
		AND OVER.EXCEPTION_TYPE (+) = DEMAND_RESPONSE_UTIL.c_EXCEPTION_TYPE_OVERRIDE
		AND (OPT.EVENT_ID = EVT.EVENT_ID OR OPT.EVENT_ID IS NULL)
		AND OPT.DER_ID (+) = DER.DER_ID
		AND OPT.EXCEPTION_TYPE (+) = DEMAND_RESPONSE_UTIL.c_EXCEPTION_TYPE_OPTOUT
		AND (PART.EVENT_ID = EVT.EVENT_ID OR PART.EVENT_ID IS NULL)
		AND PART.DER_ID (+) = DER.DER_ID
		AND (OVER.DER_ID IS NOT NULL OR PART.DER_ID IS NOT NULL OR FAIL.DER_ID IS NOT NULL
			OR OPT.DER_ID IS NOT NULL)
		AND P.PROGRAM_TYPE = DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_DLC
	GROUP BY P.PROGRAM_ID, P.PROGRAM_NAME, EVT.EVENT_ID, EVT.EVENT_NAME,
		EVT.START_TIME, EVT.STOP_TIME

	UNION ALL

	SELECT DISTINCT P.PROGRAM_ID, P.PROGRAM_NAME, EVT.EVENT_ID, EVT.EVENT_NAME, FROM_CUT(EVT.START_TIME, p_TIME_ZONE) AS START_TIME,
		FROM_CUT(EVT.STOP_TIME, p_TIME_ZONE) AS STOP_TIME,
		NULL AS PARTICIPATION
	FROM ACCOUNT_SERVICE_LOCATION ASL,
		SERVICE_LOCATION SL,
		SERVICE_LOCATION_PROGRAM SLP,
		DR_EVENT EVT,
		VIRTUAL_POWER_PLANT VPP,
		PROGRAM P
	WHERE ASL.ACCOUNT_ID = p_ACCOUNT_ID
		AND SL.SERVICE_LOCATION_ID = ASL.SERVICE_LOCATION_ID
		AND SLP.SERVICE_LOCATION_ID = SL.SERVICE_LOCATION_ID
		AND SLP.BEGIN_DATE <= p_END_DATE
		AND NVL(SLP.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
		AND SLP.BEGIN_DATE <= NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE)
		AND NVL(SLP.END_DATE, CONSTANTS.HIGH_DATE) >= ASL.BEGIN_DATE
		AND VPP.PROGRAM_ID = SLP.PROGRAM_ID
		AND VPP.SERVICE_ZONE_ID = SL.SERVICE_ZONE_ID
		AND EVT.VPP_ID = VPP.VPP_ID
		AND NVL(EVT.START_TIME, CONSTANTS.LOW_DATE) <= v_CUT_END
		AND NVL(EVT.STOP_TIME, CONSTANTS.HIGH_DATE) >= v_CUT_BEGIN
		AND P.PROGRAM_ID = VPP.PROGRAM_ID
		AND P.PROGRAM_TYPE IN (DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_PK_TIME_REBATE,
								DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_CRIT_PRICING,
								DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_RT_PRICING)
	ORDER BY 5,4;

END ACCOUNT_EVENT_HISTORY;
--------------------------------------------------------------------------------
PROCEDURE AGG_ANCILLARY_SERVICE_VALS
(
	p_AGGREGATE_ID IN NUMBER,
	p_BEGIN_DATE DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
) AS
	v_CUT_BEGIN_DATE DATE;
	v_CUT_END_DATE DATE;
	v_ACCOUNT_ID ACCOUNT.ACCOUNT_ID%TYPE;
BEGIN
	-- figure out owner account for security
	SELECT ACCOUNT_ID
	INTO v_ACCOUNT_ID
	FROM AGGREGATE_ACCOUNT_ESP
	WHERE AGGREGATE_ID = p_AGGREGATE_ID
		AND ROWNUM=1;

	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, v_ACCOUNT_ID, EC.ED_ACCOUNT);

	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, p_BEGIN_DATE, p_END_DATE);

	-- Get Cut Begin and End Date
	UT.CUT_DATE_RANGE(GA.DEFAULT_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE,
						v_CUT_BEGIN_DATE, v_CUT_END_DATE);

	OPEN p_CURSOR FOR
		SELECT X.CUT_DATE AS SERVICE_DATE,
			p_AGGREGATE_ID AS AGGREGATE_ID,
			X.ANCILLARY_SERVICE_ID,
			X.ANCILLARY_SERVICE_NAME,
			AAS.SERVICE_VAL,
			CASE WHEN AAE.AGGREGATE_ID IS NULL THEN 1 ELSE 0 END AS DISABLED
		FROM
			(SELECT SDT.CUT_DATE,
				SVC.ANCILLARY_SERVICE_ID,
				SVC.ANCILLARY_SERVICE_NAME
			FROM SYSTEM_DATE_TIME SDT,
				ANCILLARY_SERVICE SVC
			WHERE SDT.TIME_ZONE = p_TIME_ZONE
					AND SDT.DATA_INTERVAL_TYPE = 1
					AND SDT.DAY_TYPE = '1'
					AND SDT.MINIMUM_INTERVAL_NUMBER >= GET_INTERVAL_NUMBER('DD')
					AND SDT.CUT_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE) X,
			AGGREGATE_ANCILLARY_SERVICE AAS,
			AGGREGATE_ACCOUNT_ESP AAE
		WHERE AAS.SERVICE_DATE(+) = X.CUT_DATE
			AND AAS.AGGREGATE_ID(+) = p_AGGREGATE_ID
			AND AAS.ANCILLARY_SERVICE_ID(+) = X.ANCILLARY_SERVICE_ID
			AND AAS.AS_OF_DATE(+) = CONSTANTS.LOW_DATE
			AND X.CUT_DATE BETWEEN AAE.BEGIN_DATE(+) AND NVL(AAE.END_DATE(+), CONSTANTS.HIGH_DATE)
			AND	AAE.AGGREGATE_ID(+) = p_AGGREGATE_ID
		ORDER BY 1,4;

END AGG_ANCILLARY_SERVICE_VALS;
--------------------------------------------------------------------------------
PROCEDURE PUT_AGG_ANC_SVC_VAL
(
	p_AGGREGATE_ID IN NUMBER,
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_SERVICE_VAL IN NUMBER
) AS
	v_ACCOUNT_ID	ACCOUNT.ACCOUNT_ID%TYPE;
BEGIN

	-- figure out owner account for security
	SELECT ACCOUNT_ID
	INTO v_ACCOUNT_ID
	FROM AGGREGATE_ACCOUNT_ESP
	WHERE AGGREGATE_ID = p_AGGREGATE_ID
		AND ROWNUM=1;

	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, v_ACCOUNT_ID, EC.ED_ACCOUNT);

	UPDATE AGGREGATE_ANCILLARY_SERVICE
	SET SERVICE_VAL = p_SERVICE_VAL
	WHERE AGGREGATE_ID = p_AGGREGATE_ID
		  AND ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID
		  AND SERVICE_DATE = p_SERVICE_DATE
		  AND AS_OF_DATE = CONSTANTS.LOW_DATE;

	IF SQL%NOTFOUND THEN
		INSERT INTO AGGREGATE_ANCILLARY_SERVICE
			(AGGREGATE_ID, ANCILLARY_SERVICE_ID, SERVICE_DATE, AS_OF_DATE, SERVICE_VAL)
		VALUES
			(p_AGGREGATE_ID, p_ANCILLARY_SERVICE_ID, p_SERVICE_DATE, CONSTANTS.LOW_DATE, p_SERVICE_VAL);
	END IF;

END PUT_AGG_ANC_SVC_VAL;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_AGG_ANC_SVC_VAL
	(
	p_AGGREGATE_ID IN NUMBER,
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_SERVICE_DATE IN DATE
	) AS
	v_ACCOUNT_ID	ACCOUNT.ACCOUNT_ID%TYPE;
BEGIN
	-- figure out owner account for security
	SELECT ACCOUNT_ID
	INTO v_ACCOUNT_ID
	FROM AGGREGATE_ACCOUNT_ESP
	WHERE AGGREGATE_ID = p_AGGREGATE_ID
		AND ROWNUM=1;

	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, v_ACCOUNT_ID, EC.ED_ACCOUNT);

	DELETE AGGREGATE_ANCILLARY_SERVICE
	WHERE  AGGREGATE_ID = p_AGGREGATE_ID
		  AND ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID
		  AND SERVICE_DATE = p_SERVICE_DATE
		  AND AS_OF_DATE = CONSTANTS.LOW_DATE;

END REMOVE_AGG_ANC_SVC_VAL;
--------------------------------------------------------------------------------
FUNCTION GET_TOU_USAGE_DETAILS
	(
	p_TOU_USAGE_FACTOR_ID IN NUMBER,
	p_IS_ACCOUNT IN NUMBER
	) RETURN VARCHAR2 IS

	v_RST VARCHAR2(2000);

BEGIN

	IF p_IS_ACCOUNT = 1 THEN
		FOR v_REC IN (SELECT PER.PERIOD_ID, PER.PERIOD_NAME, AP.FACTOR_VAL, AP.ENTRY_DATE
						FROM ACCOUNT_TOU_USG_FACTOR_PERIOD AP,
							PERIOD PER
						WHERE AP.PERIOD_ID = PER.PERIOD_ID
							AND AP.TOU_USAGE_FACTOR_ID = p_TOU_USAGE_FACTOR_ID
							AND AP.FACTOR_VAL IS NOT NULL
						ORDER BY PER.PERIOD_NAME) LOOP

			IF v_RST IS NOT NULL THEN
				v_RST := v_RST || ', ';
			END IF;

			v_RST := v_RST || v_REC.PERIOD_NAME || ': ' || v_REC.FACTOR_VAL;

		END LOOP;
	ELSE
		FOR v_REC IN (SELECT PER.PERIOD_ID, PER.PERIOD_NAME, MP.FACTOR_VAL, MP.ENTRY_DATE
						FROM METER_TOU_USAGE_FACTOR_PERIOD MP,
							PERIOD PER
						WHERE MP.PERIOD_ID = PER.PERIOD_ID
							AND MP.TOU_USAGE_FACTOR_ID = p_TOU_USAGE_FACTOR_ID
							AND MP.FACTOR_VAL IS NOT NULL
						ORDER BY PER.PERIOD_NAME) LOOP

			IF v_RST IS NOT NULL THEN
				v_RST := v_RST || ', ';
			END IF;

			v_RST := v_RST || v_REC.PERIOD_NAME || ': ' || v_REC.FACTOR_VAL;

		END LOOP;
	END IF;

	RETURN NVL(v_RST, 'No period usage factors have been assigned.');

END GET_TOU_USAGE_DETAILS;
--------------------------------------------------------------------------------
PROCEDURE ACCOUNT_TOU_USAGE_FACTORS
    (
    p_ACCOUNT_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

    OPEN p_CURSOR FOR
        SELECT ACCOUNT_ID,
            CASE_ID,
            BEGIN_DATE,
            END_DATE,
            TEMPLATE_ID,
            TOU_USAGE_FACTOR_ID,
			ACCOUNTS_METERS.GET_TOU_USAGE_DETAILS(TOU_USAGE_FACTOR_ID, 1) AS PERIOD_USAGE_DETAILS,
            ENTRY_DATE
        FROM ACCOUNT_TOU_USAGE_FACTOR
        WHERE ACCOUNT_ID = p_ACCOUNT_ID
        ORDER BY CASE_ID,
            BEGIN_DATE;

END ACCOUNT_TOU_USAGE_FACTORS;
--------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_TOU_USAGE_FACTOR
    (
    p_ACCOUNT_ID IN NUMBER,
    p_CASE_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_TEMPLATE_ID IN NUMBER,
    p_OLD_CASE_ID IN NUMBER,
    p_OLD_BEGIN_DATE IN DATE
    ) AS

v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;

BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

    v_KEY_NEW('ACCOUNT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID);
    v_KEY_OLD('ACCOUNT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID);
    v_KEY_NEW('CASE_ID') := UT.GET_LITERAL_FOR_NUMBER(NVL(p_CASE_ID, GA.BASE_CASE_ID));
    v_KEY_OLD('CASE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_CASE_ID);
    v_DATA('TEMPLATE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_TEMPLATE_ID);

    UT.PUT_TEMPORAL_DATA_UI('ACCOUNT_TOU_USAGE_FACTOR',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            'TOU_USAGE_FACTOR_ID',
                            'OID',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

END PUT_ACCOUNT_TOU_USAGE_FACTOR;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_ACCOUNT_TOU_USG_FACTOR
    (
    p_ACCOUNT_ID IN NUMBER,
    p_CASE_ID IN NUMBER,
    p_BEGIN_DATE IN DATE
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

    DELETE ACCOUNT_TOU_USAGE_FACTOR
    WHERE ACCOUNT_ID = p_ACCOUNT_ID
        AND CASE_ID = p_CASE_ID
        AND BEGIN_DATE = p_BEGIN_DATE;

END REMOVE_ACCOUNT_TOU_USG_FACTOR;
----------------------------------------------------------------------------------------------------
FUNCTION INSERT_ACC_TOU_USAGE_FACTOR
	(
	p_BEGIN_DATE	IN DATE,
	p_END_DATE		IN DATE,
	p_ACCOUNT_ID	IN NUMBER,
	p_TEMPLATE_ID	IN NUMBER
	) RETURN NUMBER IS

	v_ID			ACCOUNT_TOU_USAGE_FACTOR.TOU_USAGE_FACTOR_ID%TYPE;
	v_TEMPLATE_ID	ACCOUNT_TOU_USAGE_FACTOR.TEMPLATE_ID%TYPE;
	v_END_DATE		ACCOUNT_TOU_USAGE_FACTOR.END_DATE%TYPE;
	v_ID2			ACCOUNT_TOU_USAGE_FACTOR.TOU_USAGE_FACTOR_ID%TYPE;

BEGIN
	-- UT temporal data APIs are not sophisticated enough (or perhaps *too* sophisticated)
	-- for this operation. They try to preserve existing records that have same data. In
	-- this table, only data column is Template ID. But we want a new record, even if
	-- existing row for	specified date range exists with same Template ID. Because we need
	-- to store potentially different usage factor values in child table. So we need a new
	-- parent record to make sure we don't effectively overwrite usage factor values for
	-- date periods other than incoming date range.

	-- Get details on entry prior to date range
	SELECT MAX(TOU_USAGE_FACTOR_ID), MAX(TEMPLATE_ID), MAX(NVL(END_DATE,CONSTANTS.HIGH_DATE))
	INTO v_ID, v_TEMPLATE_ID, v_END_DATE
	FROM ACCOUNT_TOU_USAGE_FACTOR
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND CASE_ID = GA.BASE_CASE_ID
		AND (p_BEGIN_DATE-1) BETWEEN BEGIN_DATE AND NVL(END_DATE, CONSTANTS.HIGH_DATE);

	-- Adjust this record to terminate prior to specifed date range
	IF v_ID IS NOT NULL THEN
		UPDATE ACCOUNT_TOU_USAGE_FACTOR SET
			END_DATE = p_BEGIN_DATE-1
		WHERE TOU_USAGE_FACTOR_ID = v_ID;
	END IF;

	-- Only need to look at record after specified date range if there is such a date range (i.e. specified end date is not
	-- high date)
	IF p_END_DATE IS NOT NULL AND p_END_DATE < CONSTANTS.HIGH_DATE THEN
		-- if we already know the ID of record here (because record above extends into this range) then duplicate its
		-- usage factors for the subsequent date range
		IF v_END_DATE IS NOT NULL AND v_END_DATE > p_END_DATE THEN
			SELECT OID.NEXTVAL INTO v_ID2 FROM DUAL;
			-- create new record
			INSERT INTO ACCOUNT_TOU_USAGE_FACTOR
				(ACCOUNT_ID, CASE_ID, BEGIN_DATE, END_DATE, TEMPLATE_ID, TOU_USAGE_FACTOR_ID, ENTRY_DATE)
			VALUES
				(p_ACCOUNT_ID, GA.BASE_CASE_ID, p_END_DATE+1, CASE v_END_DATE WHEN CONSTANTS.HIGH_DATE THEN NULL ELSE v_END_DATE END, v_TEMPLATE_ID, v_ID2, SYSDATE);
			-- and copy the usage factor values
			INSERT INTO ACCOUNT_TOU_USG_FACTOR_PERIOD
				(TOU_USAGE_FACTOR_ID, PERIOD_ID, FACTOR_VAL, ENTRY_DATE)
			SELECT v_ID2, PERIOD_ID, FACTOR_VAL, SYSDATE
			FROM ACCOUNT_TOU_USG_FACTOR_PERIOD
			WHERE TOU_USAGE_FACTOR_ID = v_ID;

		-- otherwise, query for subsequent ID and adjust its date range
		ELSE
			SELECT MAX(TOU_USAGE_FACTOR_ID)
			INTO v_ID
			FROM ACCOUNT_TOU_USAGE_FACTOR
			WHERE ACCOUNT_ID = p_ACCOUNT_ID
				AND CASE_ID = GA.BASE_CASE_ID
				AND (p_END_DATE+1) BETWEEN BEGIN_DATE AND NVL(END_DATE, CONSTANTS.HIGH_DATE);

			IF v_ID IS NOT NULL THEN
				-- push begin date out
				UPDATE ACCOUNT_TOU_USAGE_FACTOR SET
					BEGIN_DATE = p_END_DATE+1
				WHERE TOU_USAGE_FACTOR_ID = v_ID;
			END IF;
		END IF;
	END IF;

	-- If any other record exists for specified date range, delete them as this new date range
	-- overwrites them
	DELETE ACCOUNT_TOU_USAGE_FACTOR
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND CASE_ID = GA.BASE_CASE_ID
		AND BEGIN_DATE >= p_BEGIN_DATE
		AND NVL(END_DATE,CONSTANTS.HIGH_DATE) <= NVL(p_END_DATE, CONSTANTS.HIGH_DATE);

	-- Finally, we can insert the new record
	SELECT OID.NEXTVAL INTO v_ID FROM DUAL;

	INSERT INTO ACCOUNT_TOU_USAGE_FACTOR
		(ACCOUNT_ID, CASE_ID, BEGIN_DATE, END_DATE, TEMPLATE_ID, TOU_USAGE_FACTOR_ID, ENTRY_DATE)
	VALUES
		(p_ACCOUNT_ID, GA.BASE_CASE_ID, p_BEGIN_DATE, p_END_DATE, p_TEMPLATE_ID, v_ID, SYSDATE);

	-- Done!
	RETURN v_ID;

END INSERT_ACC_TOU_USAGE_FACTOR;
--------------------------------------------------------------------------------
PROCEDURE METER_TOU_USAGE_FACTORS
    (
    p_METER_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_METER_ID, EC.ED_METER);

    OPEN p_CURSOR FOR
        SELECT MTUR.METER_ID,
            MTUR.CASE_ID,
            CL.CASE_NAME,
            MTUR.BEGIN_DATE,
            MTUR.END_DATE,
            MTUR.TEMPLATE_ID,
            MTUR.TOU_USAGE_FACTOR_ID,
			ACCOUNTS_METERS.GET_TOU_USAGE_DETAILS(MTUR.TOU_USAGE_FACTOR_ID, 0) AS PERIOD_USAGE_DETAILS,
            MTUR.ENTRY_DATE
        FROM METER_TOU_USAGE_FACTOR MTUR,
			CASE_LABEL CL
        WHERE METER_ID = p_METER_ID
            AND MTUR.CASE_ID = CL.CASE_ID
        ORDER BY CL.CASE_NAME,
            MTUR.BEGIN_DATE;

END METER_TOU_USAGE_FACTORS;
--------------------------------------------------------------------------------
PROCEDURE PUT_METER_TOU_USAGE_FACTOR
    (
    p_METER_ID IN NUMBER,
    p_CASE_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_TEMPLATE_ID IN NUMBER,
    p_OLD_CASE_ID IN NUMBER,
    p_OLD_BEGIN_DATE IN DATE
    ) AS
v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;

BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_METER_ID, EC.ED_METER);

    v_KEY_NEW('METER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_METER_ID);
    v_KEY_OLD('METER_ID') := UT.GET_LITERAL_FOR_NUMBER(p_METER_ID);
    v_KEY_NEW('CASE_ID') := UT.GET_LITERAL_FOR_NUMBER(NVL(p_CASE_ID, GA.BASE_CASE_ID));
    v_KEY_OLD('CASE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_CASE_ID);
    v_DATA('TEMPLATE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_TEMPLATE_ID);

    UT.PUT_TEMPORAL_DATA_UI('METER_TOU_USAGE_FACTOR',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            'TOU_USAGE_FACTOR_ID',
                            'OID',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

END PUT_METER_TOU_USAGE_FACTOR;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_METER_TOU_USAGE_FACTOR
    (
    p_METER_ID IN NUMBER,
    p_CASE_ID IN NUMBER,
    p_BEGIN_DATE IN DATE
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_METER_ID, EC.ED_METER);

    DELETE METER_TOU_USAGE_FACTOR
    WHERE METER_ID = p_METER_ID
        AND CASE_ID = p_CASE_ID
        AND BEGIN_DATE = p_BEGIN_DATE;

END REMOVE_METER_TOU_USAGE_FACTOR;
----------------------------------------------------------------------------------------------------
FUNCTION INSERT_METER_TOU_USAGE_FACTOR
	(
	p_BEGIN_DATE	IN DATE,
	p_END_DATE		IN DATE,
	p_METER_ID		IN NUMBER,
	p_TEMPLATE_ID	IN NUMBER
	) RETURN NUMBER IS

	v_ID			METER_TOU_USAGE_FACTOR.TOU_USAGE_FACTOR_ID%TYPE;
	v_TEMPLATE_ID	METER_TOU_USAGE_FACTOR.TEMPLATE_ID%TYPE;
	v_END_DATE		METER_TOU_USAGE_FACTOR.END_DATE%TYPE;
	v_ID2			METER_TOU_USAGE_FACTOR.TOU_USAGE_FACTOR_ID%TYPE;

BEGIN
	-- UT temporal data APIs are not sophisticated enough (or perhaps *too* sophisticated)
	-- for this operation. They try to preserve existing records that have same data. In
	-- this table, only data column is Template ID. But we want a new record, even if
	-- existing row for	specified date range exists with same Template ID. Because we need
	-- to store potentially different usage factor values in child table. So we need a new
	-- parent record to make sure we don't effectively overwrite usage factor values for
	-- date periods other than incoming date range.

	-- Get details on entry prior to date range
	SELECT MAX(TOU_USAGE_FACTOR_ID), MAX(TEMPLATE_ID), MAX(NVL(END_DATE,CONSTANTS.HIGH_DATE))
	INTO v_ID, v_TEMPLATE_ID, v_END_DATE
	FROM METER_TOU_USAGE_FACTOR
	WHERE METER_ID = p_METER_ID
		AND CASE_ID = GA.BASE_CASE_ID
		AND (p_BEGIN_DATE-1) BETWEEN BEGIN_DATE AND NVL(END_DATE, CONSTANTS.HIGH_DATE);

	-- Adjust this record to terminate prior to specifed date range
	IF v_ID IS NOT NULL THEN
		UPDATE METER_TOU_USAGE_FACTOR SET
			END_DATE = p_BEGIN_DATE-1
		WHERE TOU_USAGE_FACTOR_ID = v_ID;
	END IF;

	-- Only need to look at record after specified date range if there is such a date range (i.e. specified end date is not
	-- high date)
	IF p_END_DATE IS NOT NULL AND p_END_DATE < CONSTANTS.HIGH_DATE THEN
		-- if we already know the ID of record here (because record above extends into this range) then duplicate its
		-- usage factors for the subsequent date range
		IF v_END_DATE IS NOT NULL AND v_END_DATE > p_END_DATE THEN
			SELECT OID.NEXTVAL INTO v_ID2 FROM DUAL;
			-- create new record
			INSERT INTO METER_TOU_USAGE_FACTOR
				(METER_ID, CASE_ID, BEGIN_DATE, END_DATE, TEMPLATE_ID, TOU_USAGE_FACTOR_ID, ENTRY_DATE)
			VALUES
				(p_METER_ID, GA.BASE_CASE_ID, p_END_DATE+1, CASE v_END_DATE WHEN CONSTANTS.HIGH_DATE THEN NULL ELSE v_END_DATE END, v_TEMPLATE_ID, v_ID2, SYSDATE);
			-- and copy the usage factor values
			INSERT INTO METER_TOU_USAGE_FACTOR_PERIOD
				(TOU_USAGE_FACTOR_ID, PERIOD_ID, FACTOR_VAL, ENTRY_DATE)
			SELECT v_ID2, PERIOD_ID, FACTOR_VAL, SYSDATE
			FROM METER_TOU_USAGE_FACTOR_PERIOD
			WHERE TOU_USAGE_FACTOR_ID = v_ID;

		-- otherwise, query for subsequent ID and adjust its date range
		ELSE
			SELECT MAX(TOU_USAGE_FACTOR_ID)
			INTO v_ID
			FROM METER_TOU_USAGE_FACTOR
			WHERE METER_ID = p_METER_ID
				AND CASE_ID = GA.BASE_CASE_ID
				AND (p_END_DATE+1) BETWEEN BEGIN_DATE AND NVL(END_DATE, CONSTANTS.HIGH_DATE);

			IF v_ID IS NOT NULL THEN
				-- push begin date out
				UPDATE METER_TOU_USAGE_FACTOR SET
					BEGIN_DATE = p_END_DATE+1
				WHERE TOU_USAGE_FACTOR_ID = v_ID;
			END IF;
		END IF;
	END IF;

	-- If any other record exists for specified date range, delete them as this new date range
	-- overwrites them
	DELETE METER_TOU_USAGE_FACTOR
	WHERE METER_ID = p_METER_ID
		AND CASE_ID = GA.BASE_CASE_ID
		AND BEGIN_DATE >= p_BEGIN_DATE
		AND NVL(END_DATE,CONSTANTS.HIGH_DATE) <= NVL(p_END_DATE, CONSTANTS.HIGH_DATE);

	-- Finally, we can insert the new record
	SELECT OID.NEXTVAL INTO v_ID FROM DUAL;

	INSERT INTO METER_TOU_USAGE_FACTOR
		(METER_ID, CASE_ID, BEGIN_DATE, END_DATE, TEMPLATE_ID, TOU_USAGE_FACTOR_ID, ENTRY_DATE)
	VALUES
		(p_METER_ID, GA.BASE_CASE_ID, p_BEGIN_DATE, p_END_DATE, p_TEMPLATE_ID, v_ID, SYSDATE);

	-- Done!
	RETURN v_ID;

END INSERT_METER_TOU_USAGE_FACTOR;
--------------------------------------------------------------------------------
PROCEDURE TOU_USAGE_FACTOR_PERIODS
	(
	p_ACCOUNT_MODEL_OPTION IN VARCHAR2,
	p_TOU_USAGE_FACTOR_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN

	IF p_ACCOUNT_MODEL_OPTION = ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_ACCOUNT THEN
		OPEN p_CURSOR FOR
			SELECT PER.PERIOD_ID, PER.PERIOD_NAME, AP.FACTOR_VAL, AP.ENTRY_DATE
			FROM ACCOUNT_TOU_USG_FACTOR_PERIOD AP,
				(SELECT DISTINCT P.PERIOD_ID, P.PERIOD_NAME
					FROM ACCOUNT_TOU_USAGE_FACTOR ATUF,
						SEASON_TEMPLATE ST,
						PERIOD P
					WHERE ATUF.TOU_USAGE_FACTOR_ID = p_TOU_USAGE_FACTOR_ID
						AND ST.TEMPLATE_ID = ATUF.TEMPLATE_ID
						AND P.PERIOD_ID = ST.PERIOD_ID) PER
			WHERE AP.PERIOD_ID (+) = PER.PERIOD_ID
				AND AP.TOU_USAGE_FACTOR_ID (+) = p_TOU_USAGE_FACTOR_ID
			ORDER BY 2 ASC;
	ELSE
		OPEN p_CURSOR FOR
			SELECT PER.PERIOD_ID, PER.PERIOD_NAME, MP.FACTOR_VAL, MP.ENTRY_DATE
			FROM METER_TOU_USAGE_FACTOR_PERIOD MP,
				(SELECT DISTINCT P.PERIOD_ID, P.PERIOD_NAME
					FROM METER_TOU_USAGE_FACTOR MTUF,
						SEASON_TEMPLATE ST,
						PERIOD P
					WHERE MTUF.TOU_USAGE_FACTOR_ID = p_TOU_USAGE_FACTOR_ID
						AND ST.TEMPLATE_ID = MTUF.TEMPLATE_ID
						AND P.PERIOD_ID = ST.PERIOD_ID) PER
			WHERE MP.PERIOD_ID (+) = PER.PERIOD_ID
				AND MP.TOU_USAGE_FACTOR_ID (+) = p_TOU_USAGE_FACTOR_ID
			ORDER BY 2 ASC;
	END IF;

END TOU_USAGE_FACTOR_PERIODS;
--------------------------------------------------------------------------------
PROCEDURE PUT_TOU_USG_FACTOR_PERIOD
	(
	p_ACCOUNT_MODEL_OPTION IN VARCHAR2,
	p_TOU_USAGE_FACTOR_ID IN NUMBER,
	p_PERIOD_ID IN NUMBER,
	p_FACTOR_VAL IN NUMBER
	) AS

BEGIN

	IF p_ACCOUNT_MODEL_OPTION = ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_ACCOUNT THEN
		IF p_FACTOR_VAL IS NOT NULL THEN
			UPDATE ACCOUNT_TOU_USG_FACTOR_PERIOD PER
			SET PER.FACTOR_VAL = p_FACTOR_VAL,
				PER.ENTRY_DATE = SYSDATE
			WHERE PER.TOU_USAGE_FACTOR_ID = p_TOU_USAGE_FACTOR_ID
				AND PER.PERIOD_ID = p_PERIOD_ID;

			IF SQL%NOTFOUND THEN
				INSERT INTO ACCOUNT_TOU_USG_FACTOR_PERIOD (TOU_USAGE_FACTOR_ID, PERIOD_ID,
					FACTOR_VAL, ENTRY_DATE) VALUES (p_TOU_USAGE_FACTOR_ID, p_PERIOD_ID,
					p_FACTOR_VAL, SYSDATE);
			END IF;
		ELSE
			DELETE FROM ACCOUNT_TOU_USG_FACTOR_PERIOD PER
			WHERE PER.TOU_USAGE_FACTOR_ID = p_TOU_USAGE_FACTOR_ID
				AND PER.PERIOD_ID = p_PERIOD_ID;
		END IF;
	ELSE
		IF p_FACTOR_VAL IS NOT NULL THEN
			UPDATE METER_TOU_USAGE_FACTOR_PERIOD PER
			SET PER.FACTOR_VAL = p_FACTOR_VAL,
				PER.ENTRY_DATE = SYSDATE
			WHERE PER.TOU_USAGE_FACTOR_ID = p_TOU_USAGE_FACTOR_ID
				AND PER.PERIOD_ID = p_PERIOD_ID;

			IF SQL%NOTFOUND THEN
				INSERT INTO METER_TOU_USAGE_FACTOR_PERIOD (TOU_USAGE_FACTOR_ID, PERIOD_ID,
					FACTOR_VAL, ENTRY_DATE) VALUES (p_TOU_USAGE_FACTOR_ID, p_PERIOD_ID,
					p_FACTOR_VAL, SYSDATE);
			END IF;
		ELSE
			DELETE FROM METER_TOU_USAGE_FACTOR_PERIOD PER
			WHERE PER.TOU_USAGE_FACTOR_ID = p_TOU_USAGE_FACTOR_ID
				AND PER.PERIOD_ID = p_PERIOD_ID;
		END IF;
	END IF;

END PUT_TOU_USG_FACTOR_PERIOD;
--------------------------------------------------------------------------------
PROCEDURE ACCOUNT_PROXY_DAY_METHODS
	(
	p_ACCOUNT_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

    OPEN p_CURSOR FOR
        SELECT A.ACCOUNT_ID,
            A.PROXY_DAY_METHOD_TYPE,
            A.BEGIN_DATE,
            A.END_DATE,
            A.PROXY_DAY_METHOD_ID,
			P.PROXY_DAY_METHOD_NAME,
            A.ENTRY_DATE
        FROM ACCOUNT_PROXY_DAY_METHOD A,
			PROXY_DAY_METHOD P
        WHERE A.ACCOUNT_ID = p_ACCOUNT_ID
			AND P.PROXY_DAY_METHOD_ID = A.PROXY_DAY_METHOD_ID
        ORDER BY A.BEGIN_DATE,
            A.PROXY_DAY_METHOD_TYPE;

END ACCOUNT_PROXY_DAY_METHODS;
--------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_PROXY_DAY_METHOD
	(
	p_ACCOUNT_ID IN NUMBER,
	p_PROXY_DAY_METHOD_TYPE IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_PROXY_DAY_METHOD_ID IN NUMBER,
	p_OLD_PROXY_DAY_METHOD_TYPE IN VARCHAR2,
	p_OLD_BEGIN_DATE IN DATE
	) AS
v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

    v_KEY_NEW('ACCOUNT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID);
    v_KEY_OLD('ACCOUNT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID);
    v_KEY_NEW('PROXY_DAY_METHOD_TYPE') := UT.GET_LITERAL_FOR_STRING(p_PROXY_DAY_METHOD_TYPE);
    v_KEY_OLD('PROXY_DAY_METHOD_TYPE') := UT.GET_LITERAL_FOR_STRING(p_OLD_PROXY_DAY_METHOD_TYPE);
    v_DATA('PROXY_DAY_METHOD_ID') := UT.GET_LITERAL_FOR_NUMBER(p_PROXY_DAY_METHOD_ID);

    UT.PUT_TEMPORAL_DATA_UI('ACCOUNT_PROXY_DAY_METHOD',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );
END PUT_ACCOUNT_PROXY_DAY_METHOD;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_ACCOUNT_PRXY_DAY_METHOD
	(
	p_ACCOUNT_ID IN NUMBER,
	p_PROXY_DAY_METHOD_TYPE IN VARCHAR2,
	p_BEGIN_DATE IN DATE
	) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

    DELETE ACCOUNT_PROXY_DAY_METHOD
    WHERE ACCOUNT_ID = p_ACCOUNT_ID
        AND PROXY_DAY_METHOD_TYPE = p_PROXY_DAY_METHOD_TYPE
        AND BEGIN_DATE = p_BEGIN_DATE;

END REMOVE_ACCOUNT_PRXY_DAY_METHOD;
--------------------------------------------------------------------------------
PROCEDURE SCHEDULE_GROUP_LIST
	(
	p_METER_TYPE IN VARCHAR2,
	p_ACCOUNT_METER_TYPE IN VARCHAR2,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

	v_METER_TYPES STRING_COLLECTION;

BEGIN

	v_METER_TYPES := STRING_COLLECTION(UPPER(NVL(p_ACCOUNT_METER_TYPE, p_METER_TYPE)), '?', 'EITHER');

	OPEN p_CURSOR FOR
	SELECT SG.SCHEDULE_GROUP_ID, SG.SCHEDULE_GROUP_NAME
	FROM SCHEDULE_GROUP SG
	WHERE UPPER(NVL(SG.METER_TYPE, 'EITHER')) IN (SELECT *
													FROM TABLE(CAST(v_METER_TYPES AS STRING_COLLECTION)))
    ORDER BY SG.SCHEDULE_GROUP_NAME ASC;

END;
--------------------------------------------------------------------------------
PROCEDURE ACCOUNT_SUB_AGG_AGGREGATIONS
    (
    p_ACCOUNT_ID IN NUMBER,
    p_CURSOR IN OUT GA.REFCURSOR
    ) AS

BEGIN

    OPEN p_CURSOR FOR
    SELECT A.AGGREGATE_ID, A.BEGIN_DATE, A.END_DATE, A.ENTRY_DATE
    FROM ACCOUNT_SUB_AGG_AGGREGATION A
    WHERE A.ACCOUNT_ID = p_ACCOUNT_ID;

END ACCOUNT_SUB_AGG_AGGREGATIONS;
--------------------------------------------------------------------------------
PROCEDURE AGGREGATE_LIST
    (
    p_CURSOR IN OUT GA.REFCURSOR
    ) AS

BEGIN

    OPEN p_CURSOR FOR
    SELECT A.ACCOUNT_DISPLAY_NAME || ' (ESP: ' || E.ESP_NAME
         || ', Pool: ' || P.POOL_NAME || ')' AS AGGREGATE_NAME,
            MAX(AAE.AGGREGATE_ID) AS AGGREGATE_ID
    FROM AGGREGATE_ACCOUNT_ESP AAE,
        ACCOUNT A,
        ESP E,
        POOL P
    WHERE AAE.ACCOUNT_ID = A.ACCOUNT_ID
        AND E.ESP_ID = AAE.ESP_ID
        AND P.POOL_ID = AAE.POOL_ID
    GROUP BY A.ACCOUNT_DISPLAY_NAME, E.ESP_NAME, P.POOL_NAME
    ORDER BY 1;

END AGGREGATE_LIST;
--------------------------------------------------------------------------------
PROCEDURE PUT_ACCT_SUB_AGG_AGGREGATION
    (
    p_ACCOUNT_ID IN NUMBER,
    p_AGGREGATE_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_OLD_BEGIN_DATE IN DATE
    ) AS

BEGIN

    UT.PUT_TEMPORAL_DATA_UI('ACCOUNT_SUB_AGG_AGGREGATION',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            'ACCOUNT_ID',
                            UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
                            UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
                            TRUE,
                            'AGGREGATE_ID',
                            UT.GET_LITERAL_FOR_NUMBER(p_AGGREGATE_ID),
                            NULL,
                            FALSE);

END PUT_ACCT_SUB_AGG_AGGREGATION;
--------------------------------------------------------------------------------
PROCEDURE REM_ACCT_SUB_AGG_AGGREGATION
    (
    p_ACCOUNT_ID IN NUMBER,
    p_BEGIN_DATE IN DATE
    ) AS

BEGIN

    DELETE FROM ACCOUNT_SUB_AGG_AGGREGATION A
    WHERE A.ACCOUNT_ID = p_ACCOUNT_ID
        AND A.BEGIN_DATE = p_BEGIN_DATE;

END REM_ACCT_SUB_AGG_AGGREGATION;
--------------------------------------------------------------------------------
PROCEDURE METER_SUB_AGG_AGGREGATIONS
    (
    p_METER_ID IN NUMBER,
    p_CURSOR IN OUT GA.REFCURSOR
    ) AS

BEGIN

    OPEN p_CURSOR FOR
    SELECT M.AGGREGATE_ID, M.BEGIN_DATE, M.END_DATE, M.ENTRY_DATE
    FROM METER_SUB_AGG_AGGREGATION M
    WHERE M.METER_ID = p_METER_ID;

END METER_SUB_AGG_AGGREGATIONS;
--------------------------------------------------------------------------------
PROCEDURE PUT_METER_SUB_AGG_AGGREGATION
    (
    p_METER_ID IN NUMBER,
    p_AGGREGATE_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_OLD_BEGIN_DATE IN DATE
    ) AS

BEGIN

    UT.PUT_TEMPORAL_DATA_UI('METER_SUB_AGG_AGGREGATION',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            'METER_ID',
                            UT.GET_LITERAL_FOR_NUMBER(p_METER_ID),
                            UT.GET_LITERAL_FOR_NUMBER(p_METER_ID),
                            TRUE,
                            'AGGREGATE_ID',
                            UT.GET_LITERAL_FOR_NUMBER(p_AGGREGATE_ID),
                            NULL,
                            FALSE);

END PUT_METER_SUB_AGG_AGGREGATION;
--------------------------------------------------------------------------------
PROCEDURE REM_METER_SUB_AGG_AGGREGATION
    (
    p_METER_ID IN NUMBER,
    p_BEGIN_DATE IN DATE
    ) AS

BEGIN

    DELETE FROM METER_SUB_AGG_AGGREGATION M
    WHERE M.METER_ID = p_METER_ID
        AND M.BEGIN_DATE = p_BEGIN_DATE;

END REM_METER_SUB_AGG_AGGREGATION;
--------------------------------------------------------------------------------
PROCEDURE AGGREGATION_DETAILS
    (
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_MODEL_ID IN NUMBER, -- -1 or 1 or 2 or Null
    p_SHOW_MODEL_ID IN NUMBER,
    p_EDC_ID IN NUMBER, -- -1 or specified EDC Id or Null
    p_SHOW_EDC_ID IN NUMBER,
    p_ESP_ID IN NUMBER, -- -1 or specified ESP Id or Null
    p_SHOW_ESP_ID IN NUMBER,
    p_PSE_ID IN NUMBER, -- -1 or specified PSE id or Null
    p_SHOW_PSE_ID IN NUMBER,
    p_POOL_ID IN NUMBER, -- -1 or specified Pool Id or Null
    p_SHOW_POOL_ID IN NUMBER,
    p_SC_ID IN NUMBER, -- -1 or specified Schedule Coordinator Id or Null
    p_SHOW_SC_ID IN NUMBER,
    p_AGGREGATE_ACCT_STRING IN VARCHAR2, -- Null or Search String
    p_SUB_AGGREGATE_ACCT_STRING IN VARCHAR2, -- Null or Search String
    p_SUB_AGG_SEARCH_BY IN VARCHAR2, -- By Name, By Alias, By Display Name, By External Identifier
    p_SUB_AGG_SEARCH_OPTION IN OUT VARCHAR2,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
    v_ACCOUNT_IDS NUMBER_COLLECTION;
    v_MODEL_ID NUMBER;
    v_SHOW_MODEL_ID NUMBER;
    v_EDC_ID NUMBER;
    v_SHOW_EDC_ID NUMBER;
    v_ESP_ID NUMBER;
    v_SHOW_ESP_ID NUMBER;
    v_PSE_ID NUMBER;
    v_SHOW_PSE_ID NUMBER;
    v_POOL_ID NUMBER;
    v_SHOW_POOL_ID NUMBER;
    v_SC_ID NUMBER;
    v_SHOW_SC_ID NUMBER;
BEGIN
    -- Get the Account Ids
    ACCOUNTS_METERS.SEARCH_ACCOUNTS(p_SUB_AGGREGATE_ACCT_STRING,
                                        p_SUB_AGG_SEARCH_BY,
                                        p_SUB_AGG_SEARCH_OPTION,
                                        v_ACCOUNT_IDS);

    -- Handle Null filter values (when filters are hidden)
    v_MODEL_ID := NVL(p_MODEL_ID, GA.DEFAULT_MODEL);
    v_SHOW_MODEL_ID := NVL(p_SHOW_MODEL_ID, 0);
    v_EDC_ID := NVL(p_EDC_ID, CONSTANTS.ALL_ID);
    v_SHOW_EDC_ID := NVL(p_SHOW_EDC_ID, 0);
    v_ESP_ID := NVL(p_ESP_ID, CONSTANTS.ALL_ID);
    v_SHOW_ESP_ID := NVL(p_SHOW_ESP_ID, 0);
    v_PSE_ID := NVL(p_PSE_ID, CONSTANTS.ALL_ID);
    v_SHOW_PSE_ID := NVL(p_SHOW_PSE_ID, 0);
    v_POOL_ID := NVL(p_POOL_ID, CONSTANTS.ALL_ID);
    v_SHOW_POOL_ID := NVL(p_SHOW_POOL_ID, 0);
    v_SC_ID := NVL(p_SC_ID, CONSTANTS.ALL_ID);
    v_SHOW_SC_ID := NVL(p_SHOW_SC_ID, 0);


    -- In these queries, we look for Aggregate accounts based on the Service, Schedulede Coordinator,
    -- EDC, PSE, ESP, Pool, Aggregate Name and Sub-Agg Search criteria but display Aggregate Account's
    -- Service and EDC, and Sub Agg's PSE, ESP, Pool and SC.
    OPEN p_CURSOR FOR
        -- Sub-Aggregate Accounts with Account Model Option
        SELECT CASE WHEN v_SHOW_MODEL_ID= 1
                    THEN CASE WHEN AGGACCT.MODEL_ID = 1 THEN 'Electric' ELSE 'Gas' END
                    ELSE NULL END AS SERVICE,
            CASE WHEN v_SHOW_EDC_ID= 1 THEN AGGEDC.EDC_NAME ELSE NULL END AS EDC_NAME,
            AGGACCT.ACCOUNT_NAME AS AGG_ACCT_NAME,
            AGGACCT.ACCOUNT_ID AS AGG_ACCT_ID,
            CASE WHEN v_SHOW_PSE_ID= 1 THEN SPSE.PSE_NAME ELSE NULL END AS PSE_NAME,
            CASE WHEN v_SHOW_ESP_ID= 1 THEN SESP.ESP_NAME ELSE NULL END AS ESP_NAME,
            CASE WHEN v_SHOW_POOL_ID= 1 THEN SP.POOL_NAME ELSE NULL END AS POOL_NAME,
            CASE WHEN v_SHOW_SC_ID= 1 THEN SSC.SC_NAME ELSE NULL END AS SC_NAME,
            SACCT.ACCOUNT_NAME AS SUB_AGG_ACCT_NAME,
            SACCT.ACCOUNT_ID AS SUB_AGG_ACCT_ID,
            SACCT.ACCOUNT_ALIAS AS SUB_AGG_ACCT_ALIAS,
            NULL AS METER_NAME,
            NULL AS METER_ALIAS,
            CASE p_SUB_AGG_SEARCH_BY
                WHEN 'By Display Name' THEN SACCT.ACCOUNT_DISPLAY_NAME
                WHEN 'By External Identifier' THEN SACCT.ACCOUNT_EXTERNAL_IDENTIFIER
                ELSE NULL
            END AS SEARCH_FIELD,
            AGGAEDC.EDC_RATE_CLASS AS AGG_EDC_RATE_CLASS,
            AGGAEDC.EDC_STRATA AS AGG_EDC_STRATA,
            SAGG.BEGIN_DATE AS AGGREGATION_BEGIN_DATE,
            SAGG.END_DATE AS AGGREGATION_END_DATE,
            AGGAESP.BEGIN_DATE AS SERVICE_BEGIN_DATE,
            AGGAESP.END_DATE AS SERVICE_END_DATE
        FROM ACCOUNT_SUB_AGG_AGGREGATION SAGG,
            ACCOUNT SACCT,
            ACCOUNT_ESP SAESP,
            ENERGY_SERVICE_PROVIDER SESP,
            POOL SP,
            PSE_ESP SPE,
            PURCHASING_SELLING_ENTITY SPSE,
            ACCOUNT_EDC SAEDC,
            ENERGY_DISTRIBUTION_COMPANY SEDC,
            SCHEDULE_COORDINATOR SSC,
            TABLE(CAST(v_ACCOUNT_IDS AS NUMBER_COLLECTION)) IDS,
            AGGREGATE_ACCOUNT_ESP AGGAESP,
            ACCOUNT AGGACCT,
            PSE_ESP AGGPE,
            ACCOUNT_EDC AGGAEDC,
            ENERGY_DISTRIBUTION_COMPANY AGGEDC,
            SCHEDULE_COORDINATOR AGGSC
        WHERE ---- Sub-Aggregate ----
            SAGG.BEGIN_DATE <= p_END_DATE
            AND NVL(SAGG.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
            AND SACCT.ACCOUNT_ID = SAGG.ACCOUNT_ID
            AND SACCT.IS_SUB_AGGREGATE = 1
            AND (SACCT.ACCOUNT_ID =  IDS.COLUMN_VALUE OR CONSTANTS.ALL_ID = IDS.COLUMN_VALUE)
            AND SACCT.ACCOUNT_MODEL_OPTION = c_ACCT_MODEL_OPTION_ACCOUNT
            -- Sub-Agg's ESP and Pool
            AND SAESP.ACCOUNT_ID(+) = SACCT.ACCOUNT_ID
            AND  ( (SAESP.BEGIN_DATE <= NVL(SAGG.END_DATE, CONSTANTS.HIGH_DATE)
            AND NVL(SAESP.END_DATE, CONSTANTS.HIGH_DATE) >= SAGG.BEGIN_DATE) OR SAESP.BEGIN_DATE IS NULL  )
            AND SESP.ESP_ID(+) = SAESP.ESP_ID
            AND SP.POOL_ID(+) = SAESP.POOL_ID
           -- Sub-Agg's PSE
            AND SPE.ESP_ID(+) = SESP.ESP_ID
            AND  ( (SPE.BEGIN_DATE <= NVL(SAGG.END_DATE, CONSTANTS.HIGH_DATE)
            AND NVL(SPE.END_DATE, CONSTANTS.HIGH_DATE) >= SAGG.BEGIN_DATE) OR SPE.BEGIN_DATE IS NULL )
            AND SPSE.PSE_ID(+) = SPE.PSE_ID
            -- Sub-Agg's SC
            AND SAEDC.ACCOUNT_ID(+) = SACCT.ACCOUNT_ID
            AND  ( (SAEDC.BEGIN_DATE <= NVL(SAGG.END_DATE, CONSTANTS.HIGH_DATE)
            AND NVL(SAEDC.END_DATE, CONSTANTS.HIGH_DATE) >= SAGG.BEGIN_DATE) OR SAEDC.BEGIN_DATE IS NULL )
            AND SEDC.EDC_ID(+) = SAEDC.EDC_ID
            AND SSC.SC_ID(+) = SEDC.EDC_SC_ID
            ---- Aggregate ----
            AND AGGAESP.AGGREGATE_ID = SAGG.AGGREGATE_ID
            AND  ( AGGAESP.BEGIN_DATE <= NVL(SAGG.END_DATE, CONSTANTS.HIGH_DATE)
            AND NVL(AGGAESP.END_DATE, CONSTANTS.HIGH_DATE) >= SAGG.BEGIN_DATE  )
            AND AGGACCT.ACCOUNT_ID = AGGAESP.ACCOUNT_ID
            AND AGGACCT.ACCOUNT_NAME LIKE GUI_UTIL.FIX_SEARCH_STRING(p_AGGREGATE_ACCT_STRING)
            AND AGGACCT.ACCOUNT_MODEL_OPTION = c_ACCT_MODEL_OPTION_AGGREGATE
            -- Agg's Service
            AND (AGGACCT.MODEL_ID = v_MODEL_ID OR CONSTANTS.ALL_ID = v_MODEL_ID)
            -- Agg's ESP
            AND (AGGAESP.ESP_ID = v_ESP_ID OR CONSTANTS.ALL_ID = v_ESP_ID)
            -- Agg's PSE
            AND AGGPE.ESP_ID = AGGAESP.ESP_ID
            AND  ( AGGPE.BEGIN_DATE <= NVL(SAGG.END_DATE, CONSTANTS.HIGH_DATE)
            AND NVL(AGGPE.END_DATE, CONSTANTS.HIGH_DATE) >= SAGG.BEGIN_DATE  )
            AND (AGGPE.PSE_ID = v_PSE_ID OR CONSTANTS.ALL_ID = v_PSE_ID)
            -- Agg's Pool
            AND (AGGAESP.POOL_ID = v_POOL_ID OR CONSTANTS.ALL_ID = v_POOL_ID)
            -- Agg's EDC
            AND AGGAEDC.ACCOUNT_ID = AGGACCT.ACCOUNT_ID
            AND  ( AGGAEDC.BEGIN_DATE <= NVL(SAGG.END_DATE, CONSTANTS.HIGH_DATE)
            AND NVL(AGGAEDC.END_DATE, CONSTANTS.HIGH_DATE) >= SAGG.BEGIN_DATE  )
            AND (AGGAEDC.EDC_ID = v_EDC_ID OR CONSTANTS.ALL_ID = v_EDC_ID)
            AND AGGEDC.EDC_ID = AGGAEDC.EDC_ID
            -- Agg's SC
            AND (AGGEDC.EDC_SC_ID = v_SC_ID OR CONSTANTS.ALL_ID = v_SC_ID)
            AND AGGSC.SC_ID = AGGEDC.EDC_SC_ID
        UNION ALL
        -- Sub-Aggregate Accounts with Meter Model Option
        SELECT CASE WHEN v_SHOW_MODEL_ID= 1
                    THEN CASE WHEN AGGACCT.MODEL_ID = 1 THEN 'Electric' ELSE 'Gas' END
                    ELSE NULL END AS SERVICE,
            CASE WHEN v_SHOW_EDC_ID= 1 THEN AGGEDC.EDC_NAME ELSE NULL END AS EDC_NAME,
            AGGACCT.ACCOUNT_NAME AS AGG_ACCT_NAME,
            AGGACCT.ACCOUNT_ID AS AGG_ACCT_ID,
            CASE WHEN v_SHOW_PSE_ID= 1 THEN SPSE.PSE_NAME ELSE NULL END AS PSE_NAME,
            CASE WHEN v_SHOW_ESP_ID= 1 THEN SESP.ESP_NAME ELSE NULL END AS ESP_NAME,
            CASE WHEN v_SHOW_POOL_ID= 1 THEN SP.POOL_NAME ELSE NULL END AS POOL_NAME,
            CASE WHEN v_SHOW_SC_ID= 1 THEN SSC.SC_NAME ELSE NULL END AS SC_NAME,
            SACCT.ACCOUNT_NAME AS SUB_AGG_ACCT_NAME,
            SACCT.ACCOUNT_ID AS SUB_AGG_ACCT_ID,
            SACCT.ACCOUNT_ALIAS AS SUB_AGG_ACCT_ALIAS,
            SM.METER_NAME AS METER_NAME,
            SM.METER_ALIAS AS METER_ALIAS,
            CASE p_SUB_AGG_SEARCH_BY
                WHEN 'By Display Name' THEN SACCT.ACCOUNT_DISPLAY_NAME
                WHEN 'By External Identifier' THEN SACCT.ACCOUNT_EXTERNAL_IDENTIFIER
                ELSE NULL
            END AS SEARCH_FIELD,
            AGGAEDC.EDC_RATE_CLASS AS AGG_EDC_RATE_CLASS,
            AGGAEDC.EDC_STRATA AS AGG_EDC_STRATA,
            SAGG.BEGIN_DATE AS AGGREGATION_BEGIN_DATE,
            SAGG.END_DATE AS AGGREGATION_END_DATE,
            AGGAESP.BEGIN_DATE AS SERVICE_BEGIN_DATE,
            AGGAESP.END_DATE AS SERVICE_END_DATE
        FROM METER_SUB_AGG_AGGREGATION SAGG,
            SERVICE_LOCATION_METER SSLM,
            METER SM,
            ACCOUNT_SERVICE_LOCATION SASL,
            ACCOUNT SACCT,
            ACCOUNT_ESP SAESP,
            ENERGY_SERVICE_PROVIDER SESP,
            POOL SP,
            PSE_ESP SPE,
            PURCHASING_SELLING_ENTITY SPSE,
            ACCOUNT_EDC SAEDC,
            ENERGY_DISTRIBUTION_COMPANY SEDC,
            SCHEDULE_COORDINATOR SSC,
            TABLE(CAST(v_ACCOUNT_IDS AS NUMBER_COLLECTION)) IDS,
            AGGREGATE_ACCOUNT_ESP AGGAESP,
            ACCOUNT AGGACCT,
            PSE_ESP AGGPE,
            ACCOUNT_EDC AGGAEDC,
            ENERGY_DISTRIBUTION_COMPANY AGGEDC,
            SCHEDULE_COORDINATOR AGGSC
        WHERE ---- Sub-Aggregate ----
            SAGG.BEGIN_DATE <= p_END_DATE
            AND NVL(SAGG.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
            AND SSLM.METER_ID = SAGG.METER_ID
            AND SM.METER_ID = SSLM.METER_ID
            AND  ( SSLM.BEGIN_DATE <= NVL(SAGG.END_DATE, CONSTANTS.HIGH_DATE)
            AND NVL(SSLM.END_DATE, CONSTANTS.HIGH_DATE) >= SAGG.BEGIN_DATE  )
            AND SASL.SERVICE_LOCATION_ID = SSLM.SERVICE_LOCATION_ID
            AND  ( SASL.BEGIN_DATE <= NVL(SAGG.END_DATE, CONSTANTS.HIGH_DATE)
            AND NVL(SASL.END_DATE, CONSTANTS.HIGH_DATE) >= SAGG.BEGIN_DATE  )
            AND SACCT.ACCOUNT_ID = SASL.ACCOUNT_ID
            AND SACCT.IS_SUB_AGGREGATE = 1
            AND (SACCT.ACCOUNT_ID =  IDS.COLUMN_VALUE OR CONSTANTS.ALL_ID = IDS.COLUMN_VALUE)
            AND SACCT.ACCOUNT_MODEL_OPTION = c_ACCT_MODEL_OPTION_METER
            -- Sub-Agg's ESP and Pool
            AND SAESP.ACCOUNT_ID(+) = SACCT.ACCOUNT_ID
            AND  ( (SAESP.BEGIN_DATE <= NVL(SAGG.END_DATE, CONSTANTS.HIGH_DATE)
            AND NVL(SAESP.END_DATE, CONSTANTS.HIGH_DATE) >= SAGG.BEGIN_DATE) OR SAESP.BEGIN_DATE IS NULL  )
            AND SESP.ESP_ID(+) = SAESP.ESP_ID
            AND SP.POOL_ID(+) = SAESP.POOL_ID
           -- Sub-Agg's PSE
            AND SPE.ESP_ID(+) = SESP.ESP_ID
            AND  ( (SPE.BEGIN_DATE <= NVL(SAGG.END_DATE, CONSTANTS.HIGH_DATE)
            AND NVL(SPE.END_DATE, CONSTANTS.HIGH_DATE) >= SAGG.BEGIN_DATE) OR SPE.BEGIN_DATE IS NULL  )
            AND SPSE.PSE_ID(+) = SPE.PSE_ID
            -- Sub-Agg's SC
            AND SAEDC.ACCOUNT_ID(+) = SACCT.ACCOUNT_ID
            AND  ( (SAEDC.BEGIN_DATE <= NVL(SAGG.END_DATE, CONSTANTS.HIGH_DATE)
            AND NVL(SAEDC.END_DATE, CONSTANTS.HIGH_DATE) >= SAGG.BEGIN_DATE) OR SAEDC.BEGIN_DATE IS NULL  )
            AND SEDC.EDC_ID(+) = SAEDC.EDC_ID
            AND SSC.SC_ID(+) = SEDC.EDC_SC_ID
            ---- Aggregate ----
            AND AGGAESP.AGGREGATE_ID = SAGG.AGGREGATE_ID
            AND  ( AGGAESP.BEGIN_DATE <= NVL(SAGG.END_DATE, CONSTANTS.HIGH_DATE)
            AND NVL(AGGAESP.END_DATE, CONSTANTS.HIGH_DATE) >= SAGG.BEGIN_DATE  )
            AND AGGACCT.ACCOUNT_ID = AGGAESP.ACCOUNT_ID
            AND AGGACCT.ACCOUNT_NAME LIKE GUI_UTIL.FIX_SEARCH_STRING(p_AGGREGATE_ACCT_STRING)
            AND AGGACCT.ACCOUNT_MODEL_OPTION = c_ACCT_MODEL_OPTION_AGGREGATE
            -- Agg's Service
            AND (AGGACCT.MODEL_ID = v_MODEL_ID OR CONSTANTS.ALL_ID = v_MODEL_ID)
            -- Agg's ESP
            AND (AGGAESP.ESP_ID = v_ESP_ID OR CONSTANTS.ALL_ID = v_ESP_ID)
            -- Agg's PSE
            AND AGGPE.ESP_ID = AGGAESP.ESP_ID
            AND  ( AGGPE.BEGIN_DATE <= NVL(SAGG.END_DATE, CONSTANTS.HIGH_DATE)
            AND NVL(AGGPE.END_DATE, CONSTANTS.HIGH_DATE) >= SAGG.BEGIN_DATE  )
            AND (AGGPE.PSE_ID = v_PSE_ID OR CONSTANTS.ALL_ID = v_PSE_ID)
            -- Agg's Pool
            AND (AGGAESP.POOL_ID = v_POOL_ID OR CONSTANTS.ALL_ID = v_POOL_ID)
            -- Agg's EDC
            AND AGGAEDC.ACCOUNT_ID = AGGACCT.ACCOUNT_ID
            AND  ( AGGAEDC.BEGIN_DATE <= NVL(SAGG.END_DATE, CONSTANTS.HIGH_DATE)
            AND NVL(AGGAEDC.END_DATE, CONSTANTS.HIGH_DATE) >= SAGG.BEGIN_DATE  )
            AND (AGGAEDC.EDC_ID = v_EDC_ID OR CONSTANTS.ALL_ID = v_EDC_ID)
            AND AGGEDC.EDC_ID = AGGAEDC.EDC_ID
            -- Agg's SC
            AND (AGGEDC.EDC_SC_ID = v_SC_ID OR CONSTANTS.ALL_ID = v_SC_ID)
            AND AGGSC.SC_ID = AGGEDC.EDC_SC_ID
         ORDER BY 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16;
END AGGREGATION_DETAILS;
--------------------------------------------------------------------------------
PROCEDURE GET_CONSUMPTION_RECORDS
    (
    p_SEARCH_STRING         IN VARCHAR2,
    p_SEARCH_OPTION         IN VARCHAR2,
    p_INCLUDE_NON_AGG       IN NUMBER,
    p_INCLUDE_AGG           IN NUMBER,
    p_INCLUDE_SUB_AGG       IN NUMBER,
    p_BEGIN_DATE            IN DATE,
    p_END_DATE              IN DATE,
    p_SETTLEMENT_TYPE_ID    IN NUMBER,
    p_EDC_ID                IN NUMBER,
    p_SHOW_EDC_ID           IN NUMBER,
    p_ESP_ID                IN NUMBER,
    p_SHOW_ESP_ID           IN NUMBER,
    p_PSE_ID                IN NUMBER,
    p_SHOW_PSE_ID           IN NUMBER,
    p_POOL_ID               IN NUMBER,
    p_SHOW_POOL_ID          IN NUMBER,
    p_SC_ID                 IN NUMBER,
    p_SHOW_SC_ID            IN NUMBER,
    p_MODEL_ID              IN NUMBER,
    p_SHOW_MODEL_ID         IN NUMBER,
    p_SEARCH_OPTION_NAME    OUT VARCHAR2,
    p_CURSOR                OUT GA.REFCURSOR
    ) AS

    v_ACCOUNT_IDS NUMBER_COLLECTION;
    v_CONS_CODE SETTLEMENT_TYPE.SERVICE_CODE%TYPE;
    v_SCENARIO_ID SETTLEMENT_TYPE.SCENARIO_ID%TYPE;

    -- NONE OF THE OPTIONAL FILTERS SHOUDL BE ACTIVE WHEN THE OPTIONAL CHECKBOX IS UNCHECKED
    v_EDC_ID NUMBER(9) := NVL(p_EDC_ID,CONSTANTS.ALL_ID);
    v_ESP_ID NUMBER(9) := NVL(p_ESP_ID,CONSTANTS.ALL_ID);
    v_PSE_ID NUMBER(9) := NVL(p_PSE_ID,CONSTANTS.ALL_ID);
    v_POOL_ID NUMBER(9) := NVL(p_POOL_ID,CONSTANTS.ALL_ID);
    v_SC_ID NUMBER(9) := NVL(p_SC_ID,CONSTANTS.ALL_ID);
    v_MODEL_ID NUMBER(9) := NVL(p_MODEL_ID,GA.DEFAULT_MODEL);

BEGIN

    IF p_SETTLEMENT_TYPE_ID = -2 THEN
        v_CONS_CODE := GA.HISTORICAL_SERVICE;
        v_SCENARIO_ID := GA.BASE_SCENARIO_ID;
    ELSE
        SELECT S.SERVICE_CODE, S.SCENARIO_ID
        INTO v_CONS_CODE, v_SCENARIO_ID
        FROM SETTLEMENT_TYPE S
        WHERE S.SETTLEMENT_TYPE_ID = p_SETTLEMENT_TYPE_ID;
    END IF;

    -- CALL TO SEARCH_ACCOUNTS
    SEARCH_ACCOUNTS(p_SEARCH_STRING, p_SEARCH_OPTION, p_SEARCH_OPTION_NAME, v_ACCOUNT_IDS);

	OPEN p_CURSOR FOR
		SELECT DISTINCT
			A.ACCOUNT_NAME,
            A.ACCOUNT_ID,
			CASE NVL(SL.SERVICE_LOCATION_ID, CONSTANTS.NOT_ASSIGNED)
				WHEN CONSTANTS.NOT_ASSIGNED THEN NULL
				ELSE SL.SERVICE_LOCATION_NAME END as SERVICE_LOCATION_NAME,
            SL.SERVICE_LOCATION_ID,
			CASE NVL(M.METER_ID, CONSTANTS.NOT_ASSIGNED)
				WHEN CONSTANTS.NOT_ASSIGNED THEN NULL
				ELSE M.METER_NAME END as METER_NAME,
            M.METER_ID,
			CASE WHEN AAE.AGGREGATE_ID IS NULL THEN
					NULL
				WHEN AAE.ACCOUNT_ID = A.ACCOUNT_ID AND AAE.ESP_ID = ESP.ESP_ID AND AAE.POOL_ID = P.POOL_ID THEN
					'<html><i>Valid</i></html>'
				ELSE -- mismatch!
					(SELECT '<html><b>Account:</b> '||AGA.ACCOUNT_NAME||
							', <b>ESP:</b> '||AGE.ESP_NAME||
							', <b>Pool:</b> '||AGP.POOL_NAME
					 FROM ACCOUNT AGA,
					 	ENERGY_SERVICE_PROVIDER AGE,
						POOL AGP
 					 WHERE AGA.ACCOUNT_ID(+) = AAE.ACCOUNT_ID
					 	AND AGE.ESP_ID(+) = AAE.ESP_ID
						AND AGP.POOL_ID(+) = AAE.POOL_ID)
				END as AGGREGATION,
			A.ACCOUNT_MODEL_OPTION,
			A.IS_SUB_AGGREGATE,
			CASE NVL(SCEN.SCENARIO_ID, CONSTANTS.NOT_ASSIGNED)
				WHEN CONSTANTS.NOT_ASSIGNED THEN NULL
				ELSE SCEN.SCENARIO_NAME END as SCENARIO_NAME,
			CASE WHEN NVL(p_SHOW_EDC_ID,0) = 0  THEN NULL
				ELSE EDC.EDC_NAME END as EDC_NAME,
			CASE WHEN NVL(p_SHOW_ESP_ID,0) = 0  THEN NULL
				ELSE ESP.ESP_NAME END as ESP_NAME,
			CASE WHEN NVL(p_SHOW_PSE_ID,0) = 0  THEN NULL
				ELSE PSE.PSE_NAME END as PSE_NAME,
			CASE WHEN NVL(p_SHOW_POOL_ID,0) = 0  THEN NULL
				ELSE P.POOL_NAME END as POOL_NAME,
			CASE WHEN NVL(p_SHOW_SC_ID,0) = 0  THEN NULL
				ELSE SC.SC_NAME END as SC_NAME,
            CASE WHEN NVL(p_SHOW_MODEL_ID,0) = 0 THEN NULL WHEN S.MODEL_ID = GA.GAS_MODEL THEN 'Gas' ELSE 'Electric' END AS SERVICE,
			CASE NVL(SP.SERVICE_POINT_ID, CONSTANTS.NOT_ASSIGNED)
				WHEN CONSTANTS.NOT_ASSIGNED THEN NULL
				ELSE SP.SERVICE_POINT_NAME END as SERVICE_POINT_NAME,
			CASE NVL(SZ.SERVICE_ZONE_ID, CONSTANTS.NOT_ASSIGNED)
				WHEN CONSTANTS.NOT_ASSIGNED THEN NULL
				ELSE SZ.SERVICE_ZONE_NAME END as SERVICE_ZONE_NAME,
			CASE NVL(SG.SCHEDULE_GROUP_ID, CONSTANTS.NOT_ASSIGNED)
				WHEN CONSTANTS.NOT_ASSIGNED THEN NULL
				ELSE SG.SCHEDULE_GROUP_NAME END as SCHEDULE_GROUP_NAME,
			CASE NVL(T.TEMPLATE_ID, CONSTANTS.NOT_ASSIGNED)
				WHEN CONSTANTS.NOT_ASSIGNED THEN NULL
				ELSE T.TEMPLATE_NAME END as TEMPLATE_NAME,
			CASE NVL(PD.PERIOD_ID, CONSTANTS.NOT_ASSIGNED)
				WHEN CONSTANTS.NOT_ASSIGNED THEN NULL
				ELSE PD.PERIOD_NAME END as PERIOD_NAME,
            CASE p_SEARCH_OPTION_NAME
                WHEN 'Account Alias' THEN A.ACCOUNT_ALIAS
                WHEN 'Account Display Name' THEN A.ACCOUNT_DISPLAY_NAME
                WHEN 'Account External Identifier' THEN A.ACCOUNT_EXTERNAL_IDENTIFIER
                ELSE NULL END AS SEARCH_CRITERIA,
			SCONS.*
		FROM ACCOUNT A,
			ACCOUNT_SERVICE ASVC,
			SERVICE_LOCATION SL,
			METER M,
			AGGREGATE_ACCOUNT_ESP AAE,
			SERVICE S,
			SCENARIO SCEN,
			PROVIDER_SERVICE PS,
			ENERGY_DISTRIBUTION_COMPANY EDC,
			ENERGY_SERVICE_PROVIDER ESP,
			PURCHASING_SELLING_ENTITY PSE,
			SERVICE_DELIVERY SD,
			POOL P,
			SERVICE_POINT SP,
			SERVICE_ZONE SZ,
			SCHEDULE_GROUP SG,
			SCHEDULE_COORDINATOR SC,
			SERVICE_CONSUMPTION SCONS,
			TEMPLATE T,
			PERIOD PD,
            TABLE(CAST(v_ACCOUNT_IDS AS NUMBER_COLLECTION)) ACCTS
		WHERE (p_INCLUDE_NON_AGG = 1 OR A.ACCOUNT_MODEL_OPTION = 'Aggregate')
			AND (p_INCLUDE_AGG = 1 OR A.ACCOUNT_MODEL_OPTION <> 'Aggregate')
			AND (p_INCLUDE_SUB_AGG = 1 OR A.IS_SUB_AGGREGATE = 0)
			AND ASVC.ACCOUNT_ID = A.ACCOUNT_ID
            AND (ASVC.ACCOUNT_ID = ACCTS.COLUMN_VALUE OR ACCTS.COLUMN_VALUE = CONSTANTS.ALL_ID)
			AND SL.SERVICE_LOCATION_ID(+) = ASVC.SERVICE_LOCATION_ID
			AND M.METER_ID(+) = ASVC.METER_ID
			AND AAE.AGGREGATE_ID(+) = ASVC.AGGREGATE_ID
			AND S.ACCOUNT_SERVICE_ID = ASVC.ACCOUNT_SERVICE_ID
			AND S.SCENARIO_ID = v_SCENARIO_ID
			AND SCEN.SCENARIO_ID = S.SCENARIO_ID
			AND PS.PROVIDER_SERVICE_ID = S.PROVIDER_SERVICE_ID
			AND EDC.EDC_ID = NVL(PS.EDC_ID,CONSTANTS.NOT_ASSIGNED)
            AND v_EDC_ID IN (CONSTANTS.ALL_ID, PS.EDC_ID)
			AND ESP.ESP_ID = NVL(PS.ESP_ID,CONSTANTS.NOT_ASSIGNED)
            AND v_ESP_ID IN (CONSTANTS.ALL_ID, PS.ESP_ID)
			AND PSE.PSE_ID = NVL(PS.PSE_ID,CONSTANTS.NOT_ASSIGNED)
            AND v_PSE_ID IN (CONSTANTS.ALL_ID, PS.PSE_ID)
			AND SD.SERVICE_DELIVERY_ID = S.SERVICE_DELIVERY_ID
			AND P.POOL_ID = NVL(SD.POOL_ID,CONSTANTS.NOT_ASSIGNED)
            AND v_POOL_ID IN (CONSTANTS.ALL_ID, SD.POOL_ID)
            AND v_MODEL_ID IN (CONSTANTS.ALL_ID, S.MODEL_ID)
			AND SP.SERVICE_POINT_ID (+) = SD.SERVICE_POINT_ID
			AND SZ.SERVICE_ZONE_ID (+) = SD.SERVICE_ZONE_ID
			AND SG.SCHEDULE_GROUP_ID (+) = SD.SCHEDULE_GROUP_ID
			AND SC.SC_ID = NVL(SD.SC_ID,CONSTANTS.NOT_ASSIGNED)
            AND v_SC_ID IN (CONSTANTS.ALL_ID, SC.SC_ID)
			AND SCONS.SERVICE_ID = S.SERVICE_ID
			AND SCONS.BEGIN_DATE <= p_END_DATE
			AND SCONS.END_DATE >= p_BEGIN_DATE
			AND (SCONS.CONSUMPTION_CODE = v_CONS_CODE)
			AND T.TEMPLATE_ID(+) =  SCONS.TEMPLATE_ID
			AND PD.PERIOD_ID(+) = SCONS.PERIOD_ID
		ORDER BY SC_NAME, EDC_NAME, PSE_NAME, ESP_NAME, POOL_NAME, ACCOUNT_NAME, SERVICE_LOCATION_NAME, METER_NAME,
            SCONS.BEGIN_DATE, SCONS.END_DATE, UNIT_OF_MEASUREMENT, SEARCH_CRITERIA;

END GET_CONSUMPTION_RECORDS;
--------------------------------------------------------------------------------
PROCEDURE ACTUAL_SETTLEMENT_TYPES
    (
    p_CURSOR OUT GA.REFCURSOR
    ) AS

BEGIN
    OPEN p_CURSOR FOR
    SELECT S.SETTLEMENT_TYPE_ID, S.SETTLEMENT_TYPE_NAME
    FROM SETTLEMENT_TYPE S
    WHERE S.SERVICE_CODE = GA.ACTUAL_SERVICE;
END ACTUAL_SETTLEMENT_TYPES;
--------------------------------------------------------------------------------
PROCEDURE GET_ANCILLARY_SERVICE_DETAIL
    (
    p_SEARCH_STRING         IN VARCHAR2,
    p_SEARCH_OPTION         IN VARCHAR2,
    p_INCLUDE_NON_AGG       IN NUMBER,
    p_INCLUDE_AGG           IN NUMBER,
    p_INCLUDE_SUB_AGG       IN NUMBER,
    p_BEGIN_DATE            IN DATE,
    p_END_DATE              IN DATE,
    p_ANCILLARY_SERVICE_ID  IN NUMBER,
    p_EDC_ID                IN NUMBER,
    p_SHOW_EDC_ID           IN NUMBER,
    p_ESP_ID                IN NUMBER,
    p_SHOW_ESP_ID           IN NUMBER,
    p_PSE_ID                IN NUMBER,
    p_SHOW_PSE_ID           IN NUMBER,
    p_POOL_ID               IN NUMBER,
    p_SHOW_POOL_ID          IN NUMBER,
    p_SC_ID                 IN NUMBER,
    p_SHOW_SC_ID            IN NUMBER,
    p_MODEL_ID              IN NUMBER,
    p_SHOW_MODEL_ID         IN NUMBER,
    p_SEARCH_OPTION_NAME    OUT VARCHAR2,
    p_CURSOR                OUT GA.REFCURSOR
    ) AS

    v_ACCOUNT_IDS NUMBER_COLLECTION;

    -- NONE OF THE OPTIONAL FILTERS SHOUDL BE ACTIVE WHEN THE OPTIONAL CHECKBOX IS UNCHECKED
    v_EDC_ID NUMBER(9) := NVL(p_EDC_ID,CONSTANTS.ALL_ID);
    v_ESP_ID NUMBER(9) := NVL(p_ESP_ID,CONSTANTS.ALL_ID);
    v_PSE_ID NUMBER(9) := NVL(p_PSE_ID,CONSTANTS.ALL_ID);
    v_POOL_ID NUMBER(9) := NVL(p_POOL_ID,CONSTANTS.ALL_ID);
    v_SC_ID NUMBER(9) := NVL(p_SC_ID,CONSTANTS.ALL_ID);
    v_MODEL_ID NUMBER(9) := NVL(p_MODEL_ID,GA.DEFAULT_MODEL);
BEGIN

    -- CALL TO SEARCH_ACCOUNTS
    SEARCH_ACCOUNTS(p_SEARCH_STRING, p_SEARCH_OPTION, p_SEARCH_OPTION_NAME, v_ACCOUNT_IDS);

     OPEN p_CURSOR FOR
        SELECT ANC_SRV.ACCOUNT_ID,
            ANC_SRV.ACCOUNT_NAME,
            --ANC_SRV.AS_DATE,
            TO_CHAR(ANC_SRV.AS_DATE, 'YYYY-MM-DD') AS AS_DATE,
            SUM(ANC_SRV.SERVICE_VAL) SERVICE_VAL,
            CASE WHEN NVL(p_SHOW_EDC_ID,0) = 0  THEN NULL
                ELSE EDC.EDC_NAME END as EDC_NAME,
            CASE WHEN NVL(p_SHOW_ESP_ID,0) = 0  THEN NULL
                 ELSE ESP.ESP_NAME END as ESP_NAME,
            CASE WHEN NVL(p_SHOW_PSE_ID,0) = 0  THEN NULL
                 ELSE PSE.PSE_NAME END as PSE_NAME,
            CASE WHEN NVL(p_SHOW_POOL_ID,0) = 0  THEN NULL
                 ELSE P.POOL_NAME END as POOL_NAME,
            CASE WHEN NVL(p_SHOW_SC_ID,0) = 0  THEN NULL
                 ELSE SC.SC_NAME END as SC_NAME,
            CASE WHEN NVL(p_SHOW_MODEL_ID,0) = 0 THEN NULL WHEN ANC_SRV.MODEL_ID = GA.GAS_MODEL THEN 'Gas'
                 ELSE 'Electric' END AS SERVICE
       FROM
        (-- Account Ancillary Service
        SELECT A.ACCOUNT_ID,
             A.ACCOUNT_NAME,
             A.MODEL_ID,
             D.COLUMN_VALUE AS AS_DATE,
             S.SERVICE_VAL,
             E.ESP_ID,
             E.POOL_ID
        FROM ACCOUNT A,
           TABLE(CAST(v_ACCOUNT_IDS AS NUMBER_COLLECTION)) ACCTS,
           TABLE(CAST(DATE_UTIL.DATES_IN_INTERVAL_RANGE(p_BEGIN_DATE, p_END_DATE, CONSTANTS.INTERVAL_DAY) AS DATE_COLLECTION)) D,
           ACCOUNT_ANCILLARY_SERVICE S,
           ACCOUNT_ESP E
        WHERE (p_INCLUDE_NON_AGG = 1 AND A.ACCOUNT_MODEL_OPTION <> 'Aggregate')
            --AND (p_INCLUDE_AGG = 1 OR A.ACCOUNT_MODEL_OPTION <> 'Aggregate')
            AND (p_INCLUDE_SUB_AGG = 1 OR A.IS_SUB_AGGREGATE = 0)
            AND (ACCTS.COLUMN_VALUE = A.ACCOUNT_ID OR ACCTS.COLUMN_VALUE = CONSTANTS.ALL_ID)
            AND S.ACCOUNT_ID = A.ACCOUNT_ID
            AND S.ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID
            AND D.COLUMN_VALUE BETWEEN S.BEGIN_DATE AND NVL(S.END_DATE, CONSTANTS.HIGH_DATE)
            AND E.ACCOUNT_ID = A.ACCOUNT_ID
            AND D.COLUMN_VALUE BETWEEN E.BEGIN_DATE AND NVL(E.END_DATE, CONSTANTS.HIGH_DATE)
        UNION ALL
          -- Meter Ancillary Service
        SELECT A.ACCOUNT_ID,
             A.ACCOUNT_NAME,
             A.MODEL_ID,
             D.COLUMN_VALUE AS AS_DATE,
             S.SERVICE_VAL,
             E.ESP_ID,
             E.POOL_ID
        FROM ACCOUNT A,
           TABLE(CAST(v_ACCOUNT_IDS AS NUMBER_COLLECTION)) ACCTS,
           TABLE(CAST(DATE_UTIL.DATES_IN_INTERVAL_RANGE(p_BEGIN_DATE, p_END_DATE, CONSTANTS.INTERVAL_DAY) AS DATE_COLLECTION)) D,
           ACCOUNT_SERVICE_LOCATION ASL,
           SERVICE_LOCATION_METER SLM,
           METER_ANCILLARY_SERVICE S,
           ACCOUNT_ESP E
        WHERE (p_INCLUDE_NON_AGG = 1 AND A.ACCOUNT_MODEL_OPTION = 'Meter')
            --AND (p_INCLUDE_AGG = 1 OR A.ACCOUNT_MODEL_OPTION <> 'Aggregate')
            AND (p_INCLUDE_SUB_AGG = 1 OR A.IS_SUB_AGGREGATE = 0)
            AND (ACCTS.COLUMN_VALUE = A.ACCOUNT_ID OR ACCTS.COLUMN_VALUE = CONSTANTS.ALL_ID)
            AND ASL.ACCOUNT_ID = A.ACCOUNT_ID
            AND D.COLUMN_VALUE BETWEEN ASL.BEGIN_DATE AND NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE)
            AND SLM.SERVICE_LOCATION_ID = ASL.SERVICE_LOCATION_ID
            AND D.COLUMN_VALUE BETWEEN SLM.BEGIN_DATE AND NVL(SLM.END_DATE, CONSTANTS.HIGH_DATE)
            AND S.METER_ID = SLM.METER_ID
            AND S.ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID
            AND D.COLUMN_VALUE BETWEEN S.BEGIN_DATE AND NVL(S.END_DATE, CONSTANTS.HIGH_DATE)
            AND E.ACCOUNT_ID = A.ACCOUNT_ID
            AND D.COLUMN_VALUE BETWEEN E.BEGIN_DATE AND NVL(E.END_DATE, CONSTANTS.HIGH_DATE)
          UNION ALL
          -- Aggregate Ancillary Service
            SELECT A.ACCOUNT_ID,
                 A.ACCOUNT_NAME,
                 A.MODEL_ID,
                 D.COLUMN_VALUE AS AS_DATE,
                 S.SERVICE_VAL,
                 E.ESP_ID,
                 E.POOL_ID
            FROM ACCOUNT A,
               TABLE(CAST(v_ACCOUNT_IDS AS NUMBER_COLLECTION)) ACCTS,
               TABLE(CAST(DATE_UTIL.DATES_IN_INTERVAL_RANGE(p_BEGIN_DATE, p_END_DATE, CONSTANTS.INTERVAL_DAY) AS DATE_COLLECTION)) D,
               AGGREGATE_ACCOUNT_ESP E,
               AGGREGATE_ANCILLARY_SERVICE S
            WHERE (p_INCLUDE_AGG = 1 AND A.ACCOUNT_MODEL_OPTION = 'Aggregate')
                AND (p_INCLUDE_SUB_AGG = 1 OR A.IS_SUB_AGGREGATE = 0)
                AND (ACCTS.COLUMN_VALUE = A.ACCOUNT_ID OR ACCTS.COLUMN_VALUE = CONSTANTS.ALL_ID)
                AND E.ACCOUNT_ID = A.ACCOUNT_ID
                AND D.COLUMN_VALUE BETWEEN E.BEGIN_DATE AND NVL(E.END_DATE, CONSTANTS.HIGH_DATE)
                AND S.AGGREGATE_ID = E.AGGREGATE_ID
                AND S.ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID
                AND S.SERVICE_DATE = D.COLUMN_VALUE
          ) ANC_SRV,
           ACCOUNT_EDC AEDC,
           ENERGY_DISTRIBUTION_COMPANY EDC,
           SCHEDULE_COORDINATOR SC,
           ENERGY_SERVICE_PROVIDER ESP,
           POOL P,
           PSE_ESP PE,
           PURCHASING_SELLING_ENTITY PSE
     WHERE -- Service
        v_MODEL_ID IN (CONSTANTS.ALL_ID, ANC_SRV.MODEL_ID)
        -- EDC
        AND AEDC.ACCOUNT_ID = ANC_SRV.ACCOUNT_ID
        AND AS_DATE BETWEEN AEDC.BEGIN_DATE AND NVL(AEDC.END_DATE, CONSTANTS.HIGH_DATE)
        AND EDC.EDC_ID = NVL(AEDC.EDC_ID,CONSTANTS.NOT_ASSIGNED)
            AND v_EDC_ID IN (CONSTANTS.ALL_ID, AEDC.EDC_ID)
        -- SC
        AND SC.SC_ID = NVL(EDC.EDC_SC_ID,CONSTANTS.NOT_ASSIGNED)
            AND v_SC_ID IN (CONSTANTS.ALL_ID, EDC.EDC_SC_ID)
        -- ESP
        AND ESP.ESP_ID = NVL(ANC_SRV.ESP_ID,CONSTANTS.NOT_ASSIGNED)
            AND v_ESP_ID IN (CONSTANTS.ALL_ID, ANC_SRV.ESP_ID)
       -- Pool
       AND P.POOL_ID = NVL(ANC_SRV.POOL_ID,CONSTANTS.NOT_ASSIGNED)
            AND v_POOL_ID IN (CONSTANTS.ALL_ID, ANC_SRV.POOL_ID)
       -- PSE
       AND PE.ESP_ID = ESP.ESP_ID
       AND AS_DATE BETWEEN PE.BEGIN_DATE AND NVL(PE.END_DATE, CONSTANTS.HIGH_DATE)
       AND PSE.PSE_ID = NVL(PE.PSE_ID,CONSTANTS.NOT_ASSIGNED)
            AND v_PSE_ID IN (CONSTANTS.ALL_ID, PE.PSE_ID)
     GROUP BY ANC_SRV.ACCOUNT_ID,
            ANC_SRV.ACCOUNT_NAME,
            ANC_SRV.AS_DATE,
            CASE WHEN NVL(p_SHOW_EDC_ID,0) = 0  THEN NULL
                ELSE EDC.EDC_NAME END,
            CASE WHEN NVL(p_SHOW_ESP_ID,0) = 0  THEN NULL
                 ELSE ESP.ESP_NAME END,
            CASE WHEN NVL(p_SHOW_PSE_ID,0) = 0  THEN NULL
                 ELSE PSE.PSE_NAME END,
            CASE WHEN NVL(p_SHOW_POOL_ID,0) = 0  THEN NULL
                 ELSE P.POOL_NAME END,
            CASE WHEN NVL(p_SHOW_SC_ID,0) = 0  THEN NULL
                 ELSE SC.SC_NAME END,
            CASE WHEN NVL(p_SHOW_MODEL_ID,0) = 0 THEN NULL WHEN ANC_SRV.MODEL_ID = GA.GAS_MODEL THEN 'Gas'
                 ELSE 'Electric' END
     ORDER BY SERVICE, SC_NAME, EDC_NAME, PSE_NAME, ESP_NAME, POOL_NAME, ACCOUNT_NAME, AS_DATE;

END GET_ANCILLARY_SERVICE_DETAIL;
--------------------------------------------------------------------------------
PROCEDURE ACCOUNT_STATUSES_SUBDAILY
    (
	p_ACCOUNT_ID IN NUMBER,
	p_CURSOR     OUT GA.REFCURSOR,
 	p_TIME_ZONE  IN VARCHAR2
	) AS

BEGIN
    -- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	-- Must subtract a second because the begin_date is stored +1 second in the database
	OPEN p_CURSOR FOR
		SELECT ACCOUNT_ID,
               FROM_CUT(BEGIN_DATE - 1/86400, p_TIME_ZONE) as BEGIN_DATE,
               FROM_CUT(END_DATE, p_TIME_ZONE) as END_DATE,
               STATUS_NAME,
               ENTRY_DATE
		FROM ACCOUNT_STATUS
		WHERE ACCOUNT_ID = p_ACCOUNT_ID
		ORDER BY BEGIN_DATE;

END ACCOUNT_STATUSES_SUBDAILY;
--------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_STATUS_SUBDAILY
	(
	p_ACCOUNT_ID     IN NUMBER,
	p_BEGIN_DATE     IN DATE,
	p_END_DATE       IN DATE,
	p_STATUS_NAME    IN VARCHAR2,
	p_OLD_BEGIN_DATE IN DATE,
 	p_TIME_ZONE      IN VARCHAR2
	) AS
v_OLD_BEGIN_DATE DATE;
BEGIN
    -- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

    --Verify CSB IS Subdaily
    IF NOT GA.CSB_IS_SUBDAILY THEN
       LOGS.LOG_WARN('Unexpected Subdaily Status');
    END IF;

	-- Must add a second because the begin_date is stored +1 second in the database
    IF(p_OLD_BEGIN_DATE IS NOT NULL) THEN
        v_OLD_BEGIN_DATE := TO_CUT(p_OLD_BEGIN_DATE, p_TIME_ZONE) + 1/86400;
    END IF;

	-- Do not need to add a second to begin_date as that is done in the procedure
    UT.PUT_TEMPORAL_DATA_UI_SUBDAY('ACCOUNT_STATUS',
							TO_CUT(p_BEGIN_DATE, p_TIME_ZONE),
							TO_CUT(p_END_DATE, p_TIME_ZONE),
							v_OLD_BEGIN_DATE,
							TRUE,
							'ACCOUNT_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
							UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
							TRUE,
							'STATUS_NAME',
							UT.GET_LITERAL_FOR_STRING(p_STATUS_NAME));

END PUT_ACCOUNT_STATUS_SUBDAILY;
--------------------------------------------------------------------------------
PROCEDURE REM_ACCOUNT_STATUS_SUBDAILY
	(
	p_ACCOUNT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
 	p_TIME_ZONE  IN VARCHAR2
	) AS
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

    --Verify CSB IS Subdaily
    IF NOT GA.CSB_IS_SUBDAILY THEN
       ERRS.RAISE(MSGCODES.c_ERR_UNSUPPORTED_OPERATION, 'Unexpected Subdaily Status');
    END IF;

	-- Must add a second because the begin_date is stored +1 second in the database
    DELETE ACCOUNT_STATUS
    WHERE ACCOUNT_ID = p_ACCOUNT_ID
        AND BEGIN_DATE = TO_CUT(p_BEGIN_DATE, p_TIME_ZONE) + 1/86400;

END REM_ACCOUNT_STATUS_SUBDAILY;
--------------------------------------------------------------------------------
PROCEDURE ACCOUNT_ESPS_SUBDAILY
	(
	p_ACCOUNT_ID IN NUMBER,
	p_CURSOR     OUT GA.REFCURSOR,
	p_TIME_ZONE  IN VARCHAR2
	) AS
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

	OPEN p_CURSOR FOR
		SELECT A.ACCOUNT_ID,
			   B.ESP_NAME,
			   A.ESP_ID,
			   C.POOL_NAME,
			   A.POOL_ID,
               FROM_CUT(A.BEGIN_DATE - 1/86400, p_TIME_ZONE) as BEGIN_DATE,
               FROM_CUT(A.END_DATE, p_TIME_ZONE) as END_DATE,
			   A.ESP_ACCOUNT_NUMBER,
			   A.ENTRY_DATE
		FROM ACCOUNT_ESP A, ESP B, POOL C
		WHERE A.ESP_ID = B.ESP_ID
			  AND A.POOL_ID = C.POOL_ID
			  AND A.ACCOUNT_ID = p_ACCOUNT_ID
		ORDER BY A.BEGIN_DATE, B.ESP_NAME;

END ACCOUNT_ESPS_SUBDAILY;
--------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_ESP_SUBDAILY
	(
	p_ACCOUNT_ID         IN NUMBER,
	p_ESP_ID             IN NUMBER,
	p_POOL_ID            IN NUMBER,
	p_BEGIN_DATE         IN DATE,
	p_END_DATE           IN DATE,
	p_ESP_ACCOUNT_NUMBER IN VARCHAR2,
	p_OLD_ESP_ID         IN NUMBER,
	p_OLD_POOL_ID        IN NUMBER,
	p_OLD_BEGIN_DATE     IN DATE,
 p_TIME_ZONE          IN VARCHAR2
	) AS
 v_OLD_BEGIN_DATE DATE;
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

    --Verify CSB relationship IS Subdaily
    IF NOT GA.CSB_IS_SUBDAILY THEN
       LOGS.LOG_WARN('Unexpected Subdaily Account-ESP relationship.');
    END IF;

    -- Must add a second because the begin_date is stored +1 second in the database
    IF(p_OLD_BEGIN_DATE IS NOT NULL) THEN
       v_OLD_BEGIN_DATE := TO_CUT(p_OLD_BEGIN_DATE, p_TIME_ZONE) + 1/86400;
    END IF;

	UT.PUT_TEMPORAL_DATA_UI_SUBDAY('ACCOUNT_ESP',
							TO_CUT(p_BEGIN_DATE, p_TIME_ZONE),
							TO_CUT(p_END_DATE, p_TIME_ZONE),
							v_OLD_BEGIN_DATE,
							TRUE,
							'ACCOUNT_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
							UT.GET_LITERAL_FOR_NUMBER(p_ACCOUNT_ID),
							TRUE,
							'ESP_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_ESP_ID),
							UT.GET_LITERAL_FOR_NUMBER(p_OLD_ESP_ID),
							FALSE,
							'POOL_ID',
							UT.GET_LITERAL_FOR_NUMBER(p_POOL_ID),
							UT.GET_LITERAL_FOR_NUMBER(p_OLD_POOL_ID),
							FALSE,
							'ESP_ACCOUNT_NUMBER',
							UT.GET_LITERAL_FOR_STRING(p_ESP_ACCOUNT_NUMBER),
							NULL,
							FALSE);

END PUT_ACCOUNT_ESP_SUBDAILY;
--------------------------------------------------------------------------------
PROCEDURE REMOVE_ACCOUNT_ESP_SUBDAILY
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ESP_ID     IN NUMBER,
	p_POOL_ID    IN NUMBER,
	p_BEGIN_DATE IN DATE,
 p_TIME_ZONE  IN VARCHAR2
	) AS
BEGIN
	-- Data-Level Security
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_ACCOUNT_ID, EC.ED_ACCOUNT);

    --Verify CSB relationship is Subdaily
    IF NOT GA.CSB_IS_SUBDAILY THEN
       ERRS.RAISE(MSGCODES.c_ERR_UNSUPPORTED_OPERATION, 'Unexpected Subdaily Account-ESP relationship.');
    END IF;

	DELETE ACCOUNT_ESP
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		  AND ESP_ID = p_ESP_ID
		  AND POOL_ID = p_POOL_ID
		  AND BEGIN_DATE = TO_CUT(p_BEGIN_DATE, p_TIME_ZONE) + 1/86400;

END REMOVE_ACCOUNT_ESP_SUBDAILY;
--------------------------------------------------------------------------------
END ACCOUNTS_METERS;
/
