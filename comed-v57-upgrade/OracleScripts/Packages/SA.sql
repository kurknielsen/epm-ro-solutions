CREATE OR REPLACE PACKAGE SA AS
--Revision $Revision: 1.37 $

-- Security Admin Package

FUNCTION WHAT_VERSION RETURN VARCHAR;

PROCEDURE IS_VALID_USER
	(
	p_USER_NAME IN VARCHAR,
	p_IS_VALID_USER OUT NUMBER
	);

PROCEDURE USER_HAS_ROLES
	(
	p_USER_NAME IN VARCHAR,
	p_HAS_ROLES OUT NUMBER
	);

PROCEDURE PUT_APPLICATION_USER
	(
    p_USER_ID IN NUMBER,
	p_USER_NAME IN VARCHAR,
	p_USER_DISPLAY_NAME IN VARCHAR,
    p_EMAIL_ADDR IN VARCHAR,
	p_IS_DISABLED IN NUMBER,
	p_IS_SYSTEM_USER IN NUMBER,
	p_MESSAGE OUT VARCHAR2
	);

PROCEDURE REMOVE_APPLICATION_USER
	(
	p_USER_NAME IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_APPLICATION_USERS
	(
    p_STATUS OUT NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    );

PROCEDURE GET_APPLICATION_ROLES
	(
 	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
    );

PROCEDURE REMOVE_APPLICATION_ROLE
	(
	p_ROLE_ID IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_ROLES_FOR_USER
	(
    p_USER_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
    );

PROCEDURE GET_USERS_FOR_ROLE
	(
    p_ROLE_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
    );

PROCEDURE GET_USER_LIST
	(
	p_INCLUDE_ALL IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE PUT_APPLICATION_ROLE
	(
    p_ROLE_ID IN NUMBER,
	p_ROLE_NAME IN VARCHAR,
	p_ROLE_ALIAS IN VARCHAR,
    p_ROLE_DESC IN VARCHAR,
	p_STATUS OUT NUMBER
	);

PROCEDURE PUT_APPLICATION_USER_ROLE
	(
    p_USER_ID IN NUMBER,
	p_USER_NAME IN VARCHAR2,
	p_ROLE_ID IN NUMBER,
	p_ROLE_NAME IN VARCHAR2,
    p_IS_ASSIGNED IN NUMBER,
    p_OLD_IS_ASSIGNED IN NUMBER
    );

PROCEDURE CLONE_APPLICATION_ROLE
	(
    p_ROLE_ID IN NUMBER,
    p_STATUS OUT NUMBER,
    p_MESSAGE OUT VARCHAR2
    );

PROCEDURE GET_EXTERNAL_CREDENTIALS
	(
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_USER_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_EXTERNAL_ACCOUNT_LIST
	(
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_EXTERNAL_ACCOUNT_LIST_ALL
	(
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE PUT_EXTERNAL_CREDENTIAL
	(
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_EXTERNAL_ACCOUNT_NAME IN VARCHAR2,
	p_USER_ID IN NUMBER,
	p_OLD_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_OLD_EXTERNAL_ACCOUNT_NAME IN VARCHAR2,
	p_OLD_USER_ID IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE REMOVE_EXTERNAL_CREDENTIAL
	(
	p_CREDENTIAL_ID IN NUMBER,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_EXT_CREDENTIAL_LOG
	(
	p_CREDENTIAL_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE SEND_EXTERNAL_CREDENTIAL_ALERT;	

PROCEDURE GET_REALMS_BY_ACTION
	(
    p_ROLE_ID IN NUMBER,
    p_ACTION_ID IN NUMBER,
    p_STATUS OUT NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    );

PROCEDURE GET_REALMS_BY_DOMAIN
	(
    p_ROLE_ID IN NUMBER,
    p_ENTITY_DOMAIN_ID IN NUMBER,
    p_STATUS OUT NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    );

PROCEDURE GET_ACTIONS_FOR_ROLE
	(
    p_ROLE_ID IN NUMBER,
    p_STATUS OUT NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    );

PROCEDURE UPDATE_EXTERNAL_CREDENTIAL
	(
	p_CREDENTIAL_ID IN NUMBER,
	p_EXTERNAL_USER_NAME IN VARCHAR2,
	p_EXTERNAL_PASSWORD IN VARCHAR2,
	p_STATUS OUT NUMBER
	);

PROCEDURE GET_CERTIFICATE_LIST
	(
	p_CREDENTIAL_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_CERTIFICATE_TYPE_LIST
	(
	p_NUMBER_OF_CERTIFICATES IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE UPDATE_CERTIFICATE
	(
	p_CREDENTIAL_ID IN NUMBER,
	p_CERTIFICATE_TYPE IN VARCHAR2,
	p_EXPIRATION_DATE IN DATE,
	p_OLD_CERTIFICATE_TYPE IN VARCHAR2,
	p_OLD_EXPIRATION_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE REMOVE_CERTIFICATE
	(
	p_CREDENTIAL_ID IN NUMBER,
	p_OLD_CERTIFICATE_TYPE IN VARCHAR2,
	p_OLD_EXPIRATION_DATE IN DATE,
	p_STATUS OUT NUMBER
	);

PROCEDURE UPLOAD_CERTIFICATE
	(
	p_CREDENTIAL_ID IN NUMBER,
	p_CERTIFICATE_TYPE IN VARCHAR2,
	p_EXPIRATION_DATE IN DATE,
	p_CERT_PASSWORD IN VARCHAR2,
	p_IMPORT_FILE IN BLOB,
	p_STATUS OUT NUMBER
	);

PROCEDURE LIST_CALC_PROCESS_FOR_SECURITY
	(
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE GET_CALC_PROCESS_SECURITY
	(
	p_CALC_PROCESS_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	);

PROCEDURE PUT_CALC_PROCESS_SECURITY
	(
	p_CALC_PROCESS_ID IN NUMBER,
	p_SELECT_ACTION_ID IN NUMBER,
	p_RUN_ACTION_ID IN NUMBER,
	p_PURGE_ACTION_ID IN NUMBER,
	p_LOCK_STATE_ACTION_ID IN NUMBER
	);

PROCEDURE DISABLE_USER
	(
	p_OWNER IN VARCHAR2,
	p_MESSAGE OUT VARCHAR2
	);

PROCEDURE KILL_USER_SESSIONS
	(
	p_OWNER IN VARCHAR2
	);

PROCEDURE KILL_SESSION
	(
	p_SESSION_SID IN NUMBER,
	p_SESSION_SERIALNUM IN NUMBER
	);

PROCEDURE LIST_SESSIONS
	(
	p_CURSOR IN OUT GA.REFCURSOR
	);

FUNCTION GET_USER_DISPLAY_NAME
	(
	p_USER_NAME IN VARCHAR2
	) RETURN VARCHAR2;
    
PROCEDURE GET_UI_SESSION_ID(p_UI_SESSION_ID OUT VARCHAR2);

/*
This procedure validates a UI Session Id and determines if it belongs to 
an authentictated user. It returns the authenticated user id and whether
the session is still valid.
Note: UI Session Ids expire after a set period of time (default is 15 minutes).

p_UI_SESSION_ID - Inbound UI Session Id string to be validated. 
p_IS_VALID - Outbound number (0 or 1) that indicates whether the Session Id is valid.
p_USER_NAME - Outbound string that is the name of the user for this Session Id.
*/
PROCEDURE VALIDATE_UI_SESSION_ID
	(
    p_UI_SESSION_ID IN VARCHAR2, 
    p_IS_VALID OUT NUMBER,
    p_SESSION_USER_NAME OUT VARCHAR2
    );

-- Exception for invalid compiled code (session mgr not configured)
c_ERR_NOT_CONF CONSTANT VARCHAR2(12) := 'ORA-6550';
	n_ERR_NOT_CONF CONSTANT PLS_INTEGER := -6550;
	e_ERR_NOT_CONF EXCEPTION;
	PRAGMA EXCEPTION_INIT(e_ERR_NOT_CONF, -6550);

END SA;
/
CREATE OR REPLACE PACKAGE BODY SA AS
----------------------------------------------------------------------------------------------------
-- Status Codes Returned by the Session Manager Package
c_SESSION_STATUS_OK				CONSTANT NUMBER := 0;
c_SESSION_STATUS_CURR_NOT_VTX	CONSTANT NUMBER := 1;
c_SESSION_STATUS_BAD_SESSION	CONSTANT NUMBER := 2;
c_SESSION_STATUS_PRIV			CONSTANT NUMBER := 3;
c_SESSION_STATUS_OWN_SESSION	CONSTANT NUMBER := 4;

c_DATE_TIME_FORMAT              CONSTANT VARCHAR2(32) := 'YYYY-MM-DD HH24:MI:SS';
c_SESSION_EXPIRATION_TIME       CONSTANT NUMBER       := 15/1440; -- 15 minutes
----------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
    RETURN '$Revision: 1.37 $';
END WHAT_VERSION;
----------------------------------------------------------------------------------------------------
FUNCTION IS_USER_SUPER_USER
	(
	p_USER_ID IN NUMBER
	) RETURN BOOLEAN IS
v_ROLE_ID NUMBER;
BEGIN
	-- Get the role of the user that is being edited.

	SELECT COUNT(1)
	INTO v_ROLE_ID
	FROM APPLICATION_USER_ROLE AUR
	WHERE AUR.USER_ID = p_USER_ID
		AND AUR.ROLE_ID = SECURITY_CONTROLS.g_SUPER_USER_ROLE_ID;

	IF v_ROLE_ID > 0 THEN
		RETURN TRUE;
	ELSE 
		RETURN FALSE;
	END IF;		

END IS_USER_SUPER_USER;	
----------------------------------------------------------------------------------------------------
-- A user is valid for logging into the system as long as it is not disabled,
-- and is not a system user.
PROCEDURE IS_VALID_USER
	(
	p_USER_NAME IN VARCHAR,
	p_IS_VALID_USER OUT NUMBER
	) AS

BEGIN

	SELECT COUNT(A.USER_NAME)
    INTO P_IS_VALID_USER
    FROM APPLICATION_USER A
    WHERE UPPER(A.USER_NAME) = UPPER(p_USER_NAME)
		AND A.IS_DISABLED = 0
		AND A.IS_SYSTEM_USER = 0;

END IS_VALID_USER;
----------------------------------------------------------------------------------------------------
PROCEDURE USER_HAS_ROLES
	(
	p_USER_NAME IN VARCHAR,
	p_HAS_ROLES OUT NUMBER
	) AS
v_NUM_ROLES NUMBER := 0;
BEGIN

	SELECT COUNT(R.ROLE_ID)
    INTO v_NUM_ROLES
    FROM APPLICATION_USER A, APPLICATION_USER_ROLE R
    WHERE UPPER(A.USER_NAME) = UPPER(p_USER_NAME) AND A.USER_ID = R.USER_ID;

  IF v_NUM_ROLES > 0 THEN
     p_HAS_ROLES := 1;
  ELSE
     p_HAS_ROLES := 0;
  END IF;

END USER_HAS_ROLES;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_APPLICATION_USER
	(
    p_USER_ID IN NUMBER,
	p_USER_NAME IN VARCHAR,
	p_USER_DISPLAY_NAME IN VARCHAR,
    p_EMAIL_ADDR IN VARCHAR,
	p_IS_DISABLED IN NUMBER,
	p_IS_SYSTEM_USER IN NUMBER,
	p_MESSAGE OUT VARCHAR2
	) AS

    v_USER_ID NUMBER;
	v_OLD_IS_SYSTEM_USER NUMBER(1);
BEGIN
	SD.VERIFY_ACTION_IS_ALLOWED(SD.g_ACTION_MANAGE_USERS_ROLES);
	IF p_USER_ID IS NOT NULL THEN

		-- See if this is (or is becoming) a Super User.  If it is, only the Super User is allowed to do it.
		SELECT NVL(MAX(IS_SYSTEM_USER),0) INTO v_OLD_IS_SYSTEM_USER FROM APPLICATION_USER WHERE USER_ID = p_USER_ID;
		IF (v_OLD_IS_SYSTEM_USER = 1 OR p_IS_SYSTEM_USER = 1) AND SECURITY_CONTROLS.IS_SUPER_USER = 0 THEN
			ERRS.RAISE(MSGCODES.c_ERR_MODIFY_SYSTEM_USER);
		END IF;

		--Make sure the user is not disabling himself.
		IF p_USER_ID = SECURITY_CONTROLS.CURRENT_USER_ID AND p_IS_DISABLED = 1 THEN
			ERRS.RAISE(MSGCODES.c_ERR_CANNOT_DISABLE_SELF);
		END IF;

		-- WE DO NOT ALLOW USERS TO CHANGE THEIR OWN LOGIN NAME TO PREVENT USERS FROM CHANGING THEIR
		-- NAME AND CREATING A NEW USER WITH THEIR NAME AND NEW PRIVILEGES
	
		-- Only a super user can edit-update another super-user
		IF SECURITY_CONTROLS.IS_SUPER_USER = 0 AND IS_USER_SUPER_USER(p_USER_ID) THEN
			ERRS.RAISE(MSGCODES.c_ERR_MODIFY_SUPERUSER);
		END IF;
		
		IF p_USER_ID = SECURITY_CONTROLS.CURRENT_USER_ID THEN
			UPDATE APPLICATION_USER SET
				USER_DISPLAY_NAME = TRIM(p_USER_DISPLAY_NAME),
				EMAIL_ADDR = TRIM(p_EMAIL_ADDR),
				IS_DISABLED = NVL(p_IS_DISABLED,0),
				IS_SYSTEM_USER = NVL(p_IS_SYSTEM_USER,0),
				ENTRY_DATE = SYSDATE
			WHERE USER_ID = p_USER_ID;

			IF p_USER_NAME <> SECURITY_CONTROLS.CURRENT_USER THEN
				p_MESSAGE := 'You are not allowed to change your own login name.';
			END IF;
		ELSE
          UPDATE APPLICATION_USER SET
				USER_NAME = TRIM(p_USER_NAME),
				USER_DISPLAY_NAME = TRIM(p_USER_DISPLAY_NAME),
				EMAIL_ADDR = TRIM(p_EMAIL_ADDR),
				IS_DISABLED = NVL(p_IS_DISABLED,0),
				IS_SYSTEM_USER = NVL(p_IS_SYSTEM_USER,0),
        		ENTRY_DATE = SYSDATE
        	WHERE USER_ID = p_USER_ID;
		END IF;

      ELSE

		-- See if the IS_SYSTEM_USER flag is being set.  If it is, only the Super User is allowed to do it.
		IF p_IS_SYSTEM_USER = 1 AND SECURITY_CONTROLS.IS_SUPER_USER = 0 THEN
			ERRS.RAISE(MSGCODES.c_ERR_MODIFY_SYSTEM_USER);
		END IF;

		SELECT OID.NEXTVAL INTO v_USER_ID FROM DUAL;
        INSERT INTO APPLICATION_USER (
        	USER_ID,
			USER_NAME,
			USER_DISPLAY_NAME,
			EMAIL_ADDR,
			IS_DISABLED,
			IS_SYSTEM_USER,
			ENTRY_DATE)
		VALUES (
    		v_USER_ID,
			TRIM(p_USER_NAME),
			TRIM(p_USER_DISPLAY_NAME),
			TRIM(p_EMAIL_ADDR),
			NVL(p_IS_DISABLED,0),
			NVL(p_IS_SYSTEM_USER,0),
			SYSDATE);

    END IF;

EXCEPTION
	WHEN DUP_VAL_ON_INDEX THEN
		ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY, 'Application User: '||TRIM(p_USER_NAME));

END PUT_APPLICATION_USER;
----------------------------------------------------------------------------------------------------
FUNCTION PRIVILEGE_FOR_ACCESS_CODE
    (
	p_ACCESS_CODE IN CHAR,
	p_RESOURCE_TYPE IN VARCHAR
	) RETURN VARCHAR IS

BEGIN

	IF p_RESOURCE_TYPE = 'TABLE' OR p_RESOURCE_TYPE = 'VIEW' THEN
        IF p_ACCESS_CODE = 'S' THEN
	        RETURN 'SELECT';
	    ELSIF p_ACCESS_CODE = 'U' THEN
		    RETURN 'SELECT,INSERT,UPDATE';
	    ELSIF p_ACCESS_CODE = 'D' THEN
		    RETURN 'SELECT,INSERT,UPDATE,DELETE';
		END IF;
	END IF;

	IF p_RESOURCE_TYPE = 'PACKAGE' OR p_RESOURCE_TYPE = 'PROCEDURE' THEN
        RETURN 'EXECUTE';
	END IF;

	RETURN NULL;

END PRIVILEGE_FOR_ACCESS_CODE;
---------------------------------------------------------------------------------------------------
PROCEDURE REMOVE_APPLICATION_USER
	(
	p_USER_NAME IN VARCHAR,
	p_STATUS OUT NUMBER
	)
	AS
-- REMOVE THE RECORD SPECIFIED BY THE INPUTS
v_USER_SU NUMBER;
v_USER APPLICATION_USER%ROWTYPE;

BEGIN
	SD.VERIFY_ACTION_IS_ALLOWED(SD.g_ACTION_MANAGE_USERS_ROLES);

	-- NO USER CAN DELETE HIMSELF
    IF p_USER_NAME = SECURITY_CONTROLS.CURRENT_USER THEN
    	ERRS.RAISE(MSGCODES.c_ERR_DELETE_CURRENT);
    END IF;

	SELECT * INTO v_USER FROM APPLICATION_USER WHERE USER_NAME = p_USER_NAME;

	-- NO ONE CAN DELETE A USER WITH AN ID < 100.
	IF v_USER.USER_ID < 100 THEN
		ERRS.RAISE(MSGCODES.c_ERR_CANNOT_DELETE_ENTITY, 'The user "'||p_USER_NAME||'" is a reserved entity and cannot be deleted.');
	END IF;

    -- ONLY SUPER USERS CAN DELETE OTHER SUPER USERS AND SYSTEM USERS.
	IF SECURITY_CONTROLS.IS_SUPER_USER = 0 THEN
		SELECT COUNT(1) INTO v_USER_SU
		FROM APPLICATION_USER_ROLE UR
		WHERE UR.USER_ID = v_USER.USER_ID
			AND UR.ROLE_ID = SECURITY_CONTROLS.g_SUPER_USER_ROLE_ID;

		IF v_USER_SU = 1 THEN
			ERRS.RAISE(MSGCODES.c_ERR_MODIFY_SUPERUSER);
		ELSIF v_USER.IS_SYSTEM_USER = 1 THEN
			ERRS.RAISE(MSGCODES.c_ERR_MODIFY_SYSTEM_USER);
		END IF;
	END IF;

    p_STATUS := GA.SUCCESS;

	DELETE FROM APPLICATION_USER
	WHERE UPPER(USER_NAME) = UPPER(LTRIM(RTRIM(p_USER_NAME)));

	p_STATUS := GA.SUCCESS;

END REMOVE_APPLICATION_USER;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_APPLICATION_USERS
	(
    p_STATUS OUT NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN

    SD.VERIFY_ACTION_IS_ALLOWED(SD.g_ACTION_MANAGE_USERS_ROLES);
    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT USER_ID,USER_NAME, USER_DISPLAY_NAME, EMAIL_ADDR, IS_DISABLED, IS_SYSTEM_USER, ENTRY_DATE FROM APPLICATION_USER ORDER BY USER_NAME;

END GET_APPLICATION_USERS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_APPLICATION_ROLES
	(
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN

	SD.VERIFY_ACTION_IS_ALLOWED(SD.g_ACTION_MANAGE_USERS_ROLES);
    P_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
    	SELECT ROLE_NAME, ROLE_ID, ROLE_ALIAS, ROLE_DESC, ENTRY_DATE FROM APPLICATION_ROLE
    ORDER BY ROLE_NAME;

END GET_APPLICATION_ROLES;
---------------------------------------------------------------------------------------------------
PROCEDURE REMOVE_APPLICATION_ROLE
	(
	p_ROLE_ID IN NUMBER,
	p_STATUS OUT NUMBER
	)
	AS
-- REMOVE THE RECORD SPECIFIED BY THE INPUTS
BEGIN
	SD.VERIFY_ACTION_IS_ALLOWED(SD.g_ACTION_MANAGE_USERS_ROLES);
	IF p_ROLE_ID = SECURITY_CONTROLS.g_SUPER_USER_ROLE_ID THEN
		ERRS.RAISE(MSGCODES.c_ERR_DELETE_SUPERUSER);
	END IF;

	p_STATUS := GA.SUCCESS;

	DELETE FROM APPLICATION_ROLE
	WHERE ROLE_ID = p_ROLE_ID;

END REMOVE_APPLICATION_ROLE;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_ROLES_FOR_USER
	(
    p_USER_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
	SD.VERIFY_ACTION_IS_ALLOWED(SD.g_ACTION_MANAGE_USERS_ROLES);
    p_STATUS := GA.SUCCESS;

	IF p_USER_ID IS NULL THEN
    	OPEN p_CURSOR FOR
    			SELECT 0 "IS_ASSIGNED", A.ROLE_NAME, A.ROLE_DESC, A.ROLE_ID
       			FROM APPLICATION_ROLE A
    			ORDER BY ROLE_NAME;
	ELSE
       	OPEN p_CURSOR FOR
    		SELECT CASE WHEN B.USER_ID IS NULL THEN 0 ELSE 1 END "IS_ASSIGNED",
    			A.ROLE_NAME, A.ROLE_DESC, A.ROLE_ID
    		FROM APPLICATION_ROLE A, APPLICATION_USER_ROLE B
    		WHERE B.ROLE_ID(+) = A.ROLE_ID
    			AND B.USER_ID(+) = p_USER_ID
    		ORDER BY A.ROLE_NAME;
	END IF;

END GET_ROLES_FOR_USER;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_USERS_FOR_ROLE
	(
    p_ROLE_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
	p_STATUS := GA.SUCCESS;

    SD.VERIFY_ACTION_IS_ALLOWED(SD.g_ACTION_MANAGE_USERS_ROLES);
	IF p_ROLE_ID IS NULL THEN
    	OPEN p_CURSOR FOR
    			SELECT 0 "IS_ASSIGNED",A.USER_ID, A.USER_NAME, A.USER_DISPLAY_NAME
       			FROM APPLICATION_USER A
				WHERE A.IS_DISABLED = 0
    			ORDER BY USER_NAME;
	ELSE
       	OPEN p_CURSOR FOR
    		SELECT CASE WHEN B.ROLE_ID IS NULL THEN 0 ELSE 1 END "IS_ASSIGNED",
    			A.USER_ID, A.USER_NAME, A.USER_DISPLAY_NAME
    		FROM APPLICATION_USER A, APPLICATION_USER_ROLE B
    		WHERE B.ROLE_ID(+) = p_ROLE_ID
    			AND B.USER_ID(+) = A.USER_ID
				AND A.IS_DISABLED = 0
    		ORDER BY A.USER_NAME;
	END IF;

END GET_USERS_FOR_ROLE;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_APPLICATION_ROLE
	(
    p_ROLE_ID IN NUMBER,
	p_ROLE_NAME IN VARCHAR,
	p_ROLE_ALIAS IN VARCHAR,
    p_ROLE_DESC IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_ROLE_ID NUMBER(9);
v_COUNT NUMBER;

BEGIN

    SD.VERIFY_ACTION_IS_ALLOWED(SD.g_ACTION_MANAGE_USERS_ROLES);
	-- ATTEMPT TO UPDATE AN EXISTING USER RECORD
	p_STATUS := GA.SUCCESS;

	IF NVL(p_ROLE_ID,0) > 0 THEN
		--MAKE SURE THERE IS NOT A NAME CONFLICT.
		SELECT COUNT(*) INTO v_COUNT
		FROM APPLICATION_ROLE
		WHERE UPPER(ROLE_NAME) = LTRIM(RTRIM(UPPER(p_ROLE_NAME)))
			AND ROLE_ID <> p_ROLE_ID;

		IF v_COUNT > 0 THEN
			ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY , 'APPLICATION_ROLE with ROLE_NAME = "' || p_ROLE_NAME || '"');
		ELSE
			UPDATE APPLICATION_ROLE SET
				ROLE_NAME = LTRIM(RTRIM(p_ROLE_NAME)),
        		ROLE_ALIAS = LTRIM(RTRIM(p_ROLE_ALIAS)),
            	ROLE_DESC = LTRIM(RTRIM(p_ROLE_DESC)),
				ENTRY_DATE = SYSDATE
			WHERE ROLE_ID = p_ROLE_ID;
		END IF;

	-- IF AN EXISTING ROLE RECORD WAS NOT UPDATED THEN INSERT A NEW ROLE RECORD
	ELSE
		--MAKE SURE THERE IS NOT A NAME CONFLICT.
		SELECT COUNT(*) INTO v_COUNT
		FROM APPLICATION_ROLE
		WHERE UPPER(ROLE_NAME) = LTRIM(RTRIM(UPPER(p_ROLE_NAME)));

		IF v_COUNT > 0 THEN
			ERRS.RAISE(MSGCODES.c_ERR_DUP_ENTRY , 'APPLICATION_ROLE with ROLE_NAME = "' || p_ROLE_NAME || '"');
		ELSE
			SELECT OID.NEXTVAL INTO v_ROLE_ID FROM DUAL;
			INSERT INTO APPLICATION_ROLE (
    			ROLE_ID,
            	ROLE_NAME,
                ROLE_ALIAS,
                ROLE_DESC,
                ENTRY_DATE)
            VALUES (
                v_ROLE_ID,
                TRIM(p_ROLE_NAME),
                TRIM(p_ROLE_ALIAS),
                TRIM(p_ROLE_DESC),
                SYSDATE);
			p_STATUS := v_ROLE_ID;
		END IF;
	END IF;

END PUT_APPLICATION_ROLE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_APPLICATION_USER_ROLE
	(
    p_USER_ID IN NUMBER,
	p_USER_NAME IN VARCHAR2,
	p_ROLE_ID IN NUMBER,
	p_ROLE_NAME IN VARCHAR2,
    p_IS_ASSIGNED IN NUMBER,
    p_OLD_IS_ASSIGNED IN NUMBER
    ) AS

v_ROLE_ID NUMBER;
v_USER_ID NUMBER;
v_IS_SYSTEM_USER NUMBER(1);

BEGIN
	IF NVL(p_IS_ASSIGNED,0) = NVL(p_OLD_IS_ASSIGNED,0) THEN
		RETURN; -- nothing to do
	END IF;

	SD.VERIFY_ACTION_IS_ALLOWED(SD.g_ACTION_MANAGE_USERS_ROLES);

	-- resolve role and user IDs
	IF p_ROLE_ID IS NULL THEN
		SELECT A.ROLE_ID INTO v_ROLE_ID
		FROM APPLICATION_ROLE A WHERE A.ROLE_NAME = p_ROLE_NAME;
	ELSE
		v_ROLE_ID := p_ROLE_ID;
	END IF;
	IF p_USER_ID IS NULL THEN
		SELECT USER_ID, IS_SYSTEM_USER INTO v_USER_ID, v_IS_SYSTEM_USER
		FROM APPLICATION_USER WHERE USER_NAME = p_USER_NAME;
	ELSE
		SELECT IS_SYSTEM_USER INTO v_IS_SYSTEM_USER
		FROM APPLICATION_USER WHERE USER_ID = p_USER_ID;
		v_USER_ID := p_USER_ID;
	END IF;

	-- only super users can change their own roles
	IF v_USER_ID = SECURITY_CONTROLS.CURRENT_USER_ID AND SECURITY_CONTROLS.IS_SUPER_USER = 0 THEN
		ERRS.RAISE(MSGCODES.c_ERR_ALTER_PRIVS);
	END IF;

	-- only super users can manage super-user role assignments
	IF v_ROLE_ID = SECURITY_CONTROLS.g_SUPER_USER_ROLE_ID AND SECURITY_CONTROLS.IS_SUPER_USER = 0 THEN
		ERRS.RAISE(MSGCODES.c_ERR_MODIFY_SUPERUSER);
	END IF;

	-- only super users can change the roles of System Users
	IF v_IS_SYSTEM_USER = 1 AND SECURITY_CONTROLS.IS_SUPER_USER = 0 THEN
		ERRS.RAISE(MSGCODES.c_ERR_MODIFY_SYSTEM_USER);
	END IF;

	-- super-users cannot remove themselves from the super-user role
	IF p_IS_ASSIGNED = 0 AND v_ROLE_ID = SECURITY_CONTROLS.g_SUPER_USER_ROLE_ID AND v_USER_ID = SECURITY_CONTROLS.CURRENT_USER_ID THEN
		ERRS.RAISE(MSGCODES.c_ERR_ALTER_PRIVS);
	END IF;

	-- Perform the DML
    IF NVL(p_IS_ASSIGNED,0) = 0 THEN
		-- revoke
		DELETE APPLICATION_USER_ROLE A
		WHERE A.USER_ID = v_USER_ID
	        AND A.ROLE_ID = v_ROLE_ID;
	ELSE
		-- grant
    	INSERT INTO APPLICATION_USER_ROLE
	        (USER_ID, ROLE_ID, ENTRY_DATE)
		VALUES
        	(v_USER_ID, v_ROLE_ID, SYSDATE);
    END IF;

END PUT_APPLICATION_USER_ROLE;
---------------------------------------------------------------------------------------------------------------
PROCEDURE CLONE_APPLICATION_ROLE
	(
    p_ROLE_ID IN NUMBER,
    p_STATUS OUT NUMBER,
    p_MESSAGE OUT VARCHAR2
    ) AS

v_ROLE_ID NUMBER;
v_ROLE_REC APPLICATION_ROLE%ROWTYPE;
v_ROLE_NAME APPLICATION_ROLE.ROLE_NAME%TYPE;
v_IDX BINARY_INTEGER;
v_COUNT BINARY_INTEGER;

BEGIN
	SD.VERIFY_ACTION_IS_ALLOWED(SD.g_ACTION_MANAGE_USERS_ROLES);
	p_STATUS := GA.SUCCESS;
    p_MESSAGE := NULL;

	SELECT * INTO v_ROLE_REC
    FROM APPLICATION_ROLE
    WHERE ROLE_ID = p_ROLE_ID;

    v_ROLE_NAME := 'Copy of ' || v_ROLE_REC.ROLE_NAME;
	v_IDX := 1;
	LOOP
		SELECT COUNT(1) INTO v_COUNT
		FROM APPLICATION_ROLE
		WHERE ROLE_NAME = v_ROLE_NAME;

		EXIT WHEN v_COUNT = 0;

		v_IDX := v_IDX+1;
		v_ROLE_NAME := 'Copy ('||v_IDX||') of ' || v_ROLE_REC.ROLE_NAME;
	END LOOP;

	v_ROLE_REC.ROLE_NAME := v_ROLE_NAME;
    v_ROLE_REC.ROLE_ALIAS := v_ROLE_NAME;

    PUT_APPLICATION_ROLE(0, v_ROLE_REC.ROLE_NAME, v_ROLE_REC.ROLE_ALIAS,v_ROLE_REC.ROLE_DESC, v_ROLE_ID);

    IF v_ROLE_ID > 0 THEN
		-- copy all privileges for specified role

		-- Data-Level Security
		INSERT INTO SYSTEM_ACTION_ROLE
			(ACTION_ID,ROLE_ID,ENTITY_DOMAIN_ID,REALM_ID,ENTRY_DATE)
		SELECT ACTION_ID, v_ROLE_ID, ENTITY_DOMAIN_ID, REALM_ID, SYSDATE
		FROM SYSTEM_ACTION_ROLE
		WHERE ROLE_ID = p_ROLE_ID;

		-- And Configuration-Level Security
		INSERT INTO SYSTEM_OBJECT_PRIVILEGE
			(OBJECT_ID, ROLE_ID, ROLE_PRIVILEGE, DO_NOT_INHERIT, CREATE_DATE, LAST_UPDATE_DATE)
		SELECT OBJECT_ID, v_ROLE_ID, ROLE_PRIVILEGE, DO_NOT_INHERIT, SYSDATE, SYSDATE
		FROM SYSTEM_OBJECT_PRIVILEGE
		WHERE ROLE_ID = p_ROLE_ID;

    ELSE
		p_STATUS := v_ROLE_ID;
    	p_MESSAGE := 'The new role could not be created.';
    END IF;

END CLONE_APPLICATION_ROLE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_REALMS_BY_ACTION
	(
    p_ROLE_ID IN NUMBER,
    p_ACTION_ID IN NUMBER,
    p_STATUS OUT NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS

BEGIN
	p_STATUS := GA.SUCCESS;

    IF p_ACTION_ID <> 0 THEN  /* Action whose Entity_Domain_id = -1 (ALL) */
   		OPEN p_CURSOR FOR
            SELECT p_ROLE_ID "ROLE_ID",
				p_ACTION_ID "ACTION_ID",
				NULL "ACTION_NAME",
				A.ENTITY_DOMAIN_ID,
				A.ENTITY_DOMAIN_NAME,
				B.REALM_ID
            FROM ENTITY_DOMAIN A,
				SYSTEM_ACTION_ROLE B,
				SYSTEM_REALM C
            WHERE A.ENTITY_DOMAIN_ID <> 0 -- skip the 'Not Assigned' domain
				AND NVL(A.IS_PSEUDO, 0) = 0 --- and skip 'pseudo' domains
				AND B.ROLE_ID(+) = p_ROLE_ID
                AND B.ACTION_ID(+) = p_ACTION_ID
                AND B.ENTITY_DOMAIN_ID(+) = A.ENTITY_DOMAIN_ID
				AND C.REALM_ID(+) = B.REALM_ID
            ORDER BY A.ENTITY_DOMAIN_NAME, C.REALM_NAME;
   ELSE /* Action is "Others* - i.e Action where Domain_id != -1 */
        OPEN p_CURSOR FOR
            SELECT p_ROLE_ID "ROLE_ID",
				A.ACTION_ID,
				A.ACTION_NAME,
				C.ENTITY_DOMAIN_ID,
				C.ENTITY_DOMAIN_NAME,
				B.REALM_ID
            FROM SYSTEM_ACTION A,
                SYSTEM_ACTION_ROLE B,
                ENTITY_DOMAIN C,
				SYSTEM_REALM D
            WHERE NVL(A.ENTITY_DOMAIN_ID,0) <> SD.g_ALL_ENTITY_DOMAINS_ID
                AND B.ROLE_ID(+) = p_ROLE_ID
                AND B.ACTION_ID(+) = A.ACTION_ID
                AND C.ENTITY_DOMAIN_ID(+) = A.ENTITY_DOMAIN_ID
				AND D.REALM_ID(+) = B.REALM_ID
            ORDER BY A.ACTION_NAME, C.ENTITY_DOMAIN_NAME, D.REALM_NAME;
   END IF;

END GET_REALMS_BY_ACTION;
--------------------------------------------------------------------------------

PROCEDURE GET_REALMS_BY_DOMAIN
	(
    p_ROLE_ID IN NUMBER,
    p_ENTITY_DOMAIN_ID IN NUMBER,
    p_STATUS OUT NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS

BEGIN
   	p_STATUS := GA.SUCCESS;

   	OPEN p_CURSOR FOR
        SELECT p_ROLE_ID "ROLE_ID",
			SA.ACTION_ID,
            SA.ACTION_NAME,
			p_ENTITY_DOMAIN_ID "ENTITY_DOMAIN_ID",
            SR.REALM_ID
        FROM SYSTEM_ACTION SA,
        	SYSTEM_ACTION_ROLE SAR,
        	SYSTEM_REALM SR
        WHERE SA.ENTITY_DOMAIN_ID IN (SD.g_ALL_ENTITY_DOMAINS_ID, p_ENTITY_DOMAIN_ID)
        	AND SAR.ACTION_ID(+) = SA.ACTION_ID
        	AND SAR.ENTITY_DOMAIN_ID(+) = p_ENTITY_DOMAIN_ID
        	AND SAR.ROLE_ID(+) = p_ROLE_ID
        	AND SR.REALM_ID(+) = SAR.REALM_ID
        ORDER BY 3;

END GET_REALMS_BY_DOMAIN;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_ACTIONS_FOR_ROLE
	(
    p_ROLE_ID IN NUMBER,
    p_STATUS OUT NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
   		SELECT '<HTML><B>Others</B></HTML>', 0, 0 "ORD"
		FROM SYSTEM_ACTION A
        WHERE A.ENTITY_DOMAIN_ID <> SD.g_ALL_ENTITY_DOMAINS_ID
		UNION
	    SELECT A.ACTION_NAME,A.ACTION_ID, 1 "ORD"
    	FROM SYSTEM_ACTION A
        WHERE A.ENTITY_DOMAIN_ID = SD.g_ALL_ENTITY_DOMAINS_ID
		ORDER BY 3, 1;

END GET_ACTIONS_FOR_ROLE;
------------------------------------------------------------------------------------------------------
PROCEDURE LOG_CHANGE
	(
	p_CREDENTIAL_ID IN NUMBER,
	p_MESSAGE IN VARCHAR2
	) AS
v_EXTERNAL_SYSTEM_ID NUMBER(9);
v_EXTERNAL_SYSTEM_NAME EXTERNAL_SYSTEM.EXTERNAL_SYSTEM_NAME%TYPE;
v_EXTERNAL_ACCOUNT_NAME EXTERNAL_CREDENTIALS.EXTERNAL_ACCOUNT_NAME%TYPE;
v_USER_ID EXTERNAL_CREDENTIALS.USER_ID%TYPE;
v_USER_NAME APPLICATION_USER.USER_NAME%TYPE;
BEGIN
	SELECT A.EXTERNAL_SYSTEM_ID, B.EXTERNAL_SYSTEM_NAME, A.EXTERNAL_ACCOUNT_NAME, A.USER_ID
	INTO v_EXTERNAL_SYSTEM_ID, v_EXTERNAL_SYSTEM_NAME, v_EXTERNAL_ACCOUNT_NAME, v_USER_ID
	FROM EXTERNAL_CREDENTIALS A, EXTERNAL_SYSTEM B
	WHERE A.CREDENTIAL_ID = p_CREDENTIAL_ID
		AND B.EXTERNAL_SYSTEM_ID = A.EXTERNAL_SYSTEM_ID;

	IF v_USER_ID IS NOT NULL THEN

        SELECT U.USER_NAME INTO v_USER_NAME
        FROM APPLICATION_USER U
        WHERE U.USER_ID = v_USER_ID;

	ELSE

		v_USER_NAME := 'All Users';

	END IF;

	LOGS.LOG_NOTICE(p_EVENT_TEXT => p_MESSAGE || ' ('||v_USER_NAME||' - '||v_EXTERNAL_SYSTEM_NAME||':'||v_EXTERNAL_ACCOUNT_NAME||')',
					p_SOURCE_NAME =>  v_EXTERNAL_SYSTEM_ID||':'||v_EXTERNAL_ACCOUNT_NAME);
END LOG_CHANGE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_EXTERNAL_CREDENTIALS
	(
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_USER_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_USER_ID APPLICATION_USER.USER_ID%TYPE := p_USER_ID;
v_MANAGE_ALL NUMBER(1) := 1;
BEGIN
	IF NOT SD.GET_ACTION_IS_ALLOWED(SD.g_ACTION_MANAGE_ALL_CREDS) THEN
		v_MANAGE_ALL := 0;
		IF p_USER_ID = CONSTANTS.ALL_ID THEN -- User was trying to query all users, but we can't allow that because
			-- they don't have the appropriate priveleges, so just let them look at themselves
			v_USER_ID := SECURITY_CONTROLS.CURRENT_USER_ID;
		ELSIF p_USER_ID <> SECURITY_CONTROLS.CURRENT_USER_ID THEN
			ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_MANAGE_ALL_CREDS);
		END IF;
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT A.EXTERNAL_SYSTEM_ID,
				EXTERNAL_ACCOUNT_NAME,
				-- Only display the username if managing all users or the user we're looking at isn't the queried one
				CASE WHEN v_MANAGE_ALL = 1
					 THEN NVL(A.USER_ID, CONSTANTS.ALL_ID)
					 ELSE NULL END "USER_ID",
				EXTERNAL_USER_NAME,
				(SELECT COUNT(1) FROM EXTERNAL_CREDENTIALS_CERT X WHERE X.CREDENTIAL_ID = A.CREDENTIAL_ID) "NUM_CERTS",
				A.ENTRY_DATE,
                (SELECT MIN(CERTIFICATE_EXPIRATION_DATE) FROM EXTERNAL_CREDENTIALS_CERT X WHERE X.CREDENTIAL_ID = A.CREDENTIAL_ID) "CERT_EXPR",
				B.HAS_UNAME_PWD_CREDENTIALS,
				B.NUMBER_OF_CERTIFICATES,
				A.CREDENTIAL_ID
		FROM EXTERNAL_CREDENTIALS A, EXTERNAL_SYSTEM B, APPLICATION_USER U
		WHERE p_EXTERNAL_SYSTEM_ID IN (A.EXTERNAL_SYSTEM_ID,CONSTANTS.ALL_ID)
			AND ((v_MANAGE_ALL = 1 AND (A.USER_ID = v_USER_ID OR v_USER_ID = CONSTANTS.ALL_ID))
				OR (v_MANAGE_ALL = 0 AND A.USER_ID = v_USER_ID))
			AND B.EXTERNAL_SYSTEM_ID = A.EXTERNAL_SYSTEM_ID
			AND U.USER_ID (+) = A.USER_ID
			AND NVL(B.IS_ENABLED,0) = 1
		ORDER BY B.EXTERNAL_SYSTEM_NAME, B.EXTERNAL_SYSTEM_ID, A.EXTERNAL_ACCOUNT_NAME, U.USER_DISPLAY_NAME;

END GET_EXTERNAL_CREDENTIALS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_EXTERNAL_ACCOUNT_LIST
	(
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT DISTINCT ESI.EXTERNAL_IDENTIFIER
		FROM EXTERNAL_SYSTEM ES,
			 EXTERNAL_SYSTEM_IDENTIFIER ESI
		WHERE ES.EXTERNAL_SYSTEM_ID = p_EXTERNAL_SYSTEM_ID
			AND ESI.EXTERNAL_SYSTEM_ID = ES.EXTERNAL_SYSTEM_ID
			AND ESI.ENTITY_DOMAIN_ID = ES.EXTERNAL_ACCOUNT_DOMAIN_ID
			AND ESI.IDENTIFIER_TYPE = EI.g_DEFAULT_IDENTIFIER_TYPE
		ORDER BY 1;
END GET_EXTERNAL_ACCOUNT_LIST;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_EXTERNAL_ACCOUNT_LIST_ALL
	(
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT '<ALL>' EXTERNAL_IDENTIFIER
		FROM DUAL
		UNION ALL
		SELECT EXTERNAL_IDENTIFIER
		FROM (SELECT DISTINCT ESI.EXTERNAL_IDENTIFIER
    		FROM EXTERNAL_SYSTEM ES,
    			 EXTERNAL_SYSTEM_IDENTIFIER ESI
    		WHERE ES.EXTERNAL_SYSTEM_ID = p_EXTERNAL_SYSTEM_ID
    			AND ESI.EXTERNAL_SYSTEM_ID = ES.EXTERNAL_SYSTEM_ID
    			AND ESI.ENTITY_DOMAIN_ID = ES.EXTERNAL_ACCOUNT_DOMAIN_ID
    			AND ESI.IDENTIFIER_TYPE = EI.g_DEFAULT_IDENTIFIER_TYPE
			ORDER BY 1);
END GET_EXTERNAL_ACCOUNT_LIST_ALL;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_EXTERNAL_CREDENTIAL
	(
	p_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_EXTERNAL_ACCOUNT_NAME IN VARCHAR2,
	p_USER_ID IN NUMBER,
	p_OLD_EXTERNAL_SYSTEM_ID IN NUMBER,
	p_OLD_EXTERNAL_ACCOUNT_NAME IN VARCHAR2,
	p_OLD_USER_ID IN NUMBER,
	p_STATUS OUT NUMBER
	) AS
v_CRED_ID NUMBER(9);
v_USER_ID EXTERNAL_CREDENTIALS.USER_ID%TYPE := NVL(p_USER_ID,SECURITY_CONTROLS.CURRENT_USER_ID);
v_OLD_USER_ID EXTERNAL_CREDENTIALS.USER_ID%TYPE := NVL(p_OLD_USER_ID,SECURITY_CONTROLS.CURRENT_USER_ID);
BEGIN
	-- verify that this user is allowed to change others' credentials
	IF v_USER_ID <> SECURITY_CONTROLS.CURRENT_USER_ID OR
	   v_OLD_USER_ID <> SECURITY_CONTROLS.CURRENT_USER_ID THEN
		SD.VERIFY_ACTION_IS_ALLOWED(SD.g_ACTION_MANAGE_ALL_CREDS);
	END IF;

	-- A USER_ID VALUE OF  "ALL USERS" is represented in the table as NULL
	IF v_USER_ID = CONSTANTS.ALL_ID THEN
		v_USER_ID := NULL;
	END IF;

	SELECT MAX(CREDENTIAL_ID)
	INTO v_CRED_ID
	FROM EXTERNAL_CREDENTIALS
	WHERE EXTERNAL_SYSTEM_ID = p_OLD_EXTERNAL_SYSTEM_ID
		AND EXTERNAL_ACCOUNT_NAME = p_OLD_EXTERNAL_ACCOUNT_NAME
		AND (USER_ID = v_OLD_USER_ID OR (USER_ID IS NULL AND v_OLD_USER_ID IS NULL));

	IF v_CRED_ID IS NOT NULL THEN
    	UPDATE EXTERNAL_CREDENTIALS SET
    		EXTERNAL_SYSTEM_ID = p_EXTERNAL_SYSTEM_ID,
    		EXTERNAL_ACCOUNT_NAME = NVL(p_EXTERNAL_ACCOUNT_NAME,'?'),
    		USER_ID = v_USER_ID,
    		ENTRY_DATE = SYSDATE
    	WHERE CREDENTIAL_ID = v_CRED_ID;

		LOG_CHANGE(v_CRED_ID,'Updated credentials (possible key change)');
	ELSE
		SELECT OID.NEXTVAL INTO v_CRED_ID FROM DUAL;
		INSERT INTO EXTERNAL_CREDENTIALS
			(CREDENTIAL_ID, EXTERNAL_SYSTEM_ID, EXTERNAL_ACCOUNT_NAME, USER_ID, ENTRY_DATE)
		VALUES
			(v_CRED_ID, p_EXTERNAL_SYSTEM_ID, NVL(p_EXTERNAL_ACCOUNT_NAME,'?'), v_USER_ID, SYSDATE);

		LOG_CHANGE(v_CRED_ID,'Created credentials');
	END IF;

	p_STATUS := GA.SUCCESS;
END PUT_EXTERNAL_CREDENTIAL;
---------------------------------------------------------------------------------------------------
PROCEDURE REMOVE_EXTERNAL_CREDENTIAL
	(
	p_CREDENTIAL_ID IN NUMBER,
	p_STATUS OUT NUMBER
	) AS
v_USER_ID EXTERNAL_CREDENTIALS.USER_ID%TYPE;
BEGIN
	SELECT USER_ID INTO v_USER_ID
	FROM EXTERNAL_CREDENTIALS
	WHERE CREDENTIAL_ID = p_CREDENTIAL_ID;

	-- verify that this user is allowed to change others' credentials
	IF NVL(v_USER_ID,CONSTANTS.ALL_ID) <> SECURITY_CONTROLS.CURRENT_USER_ID THEN
		SD.VERIFY_ACTION_IS_ALLOWED(SD.g_ACTION_MANAGE_ALL_CREDS);
	END IF;

	LOG_CHANGE(p_CREDENTIAL_ID,'Deleted credentials');

	DELETE EXTERNAL_CREDENTIALS
	WHERE CREDENTIAL_ID = p_CREDENTIAL_ID;

	p_STATUS := GA.SUCCESS;
END REMOVE_EXTERNAL_CREDENTIAL;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_EXT_CREDENTIAL_LOG
	(
	p_CREDENTIAL_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_USER_ID   EXTERNAL_CREDENTIALS.USER_ID%TYPE;
v_SOURCE_NAME  VARCHAR2(256);
BEGIN
	SELECT USER_ID, EXTERNAL_SYSTEM_ID||':'||EXTERNAL_ACCOUNT_NAME
	INTO v_USER_ID, v_SOURCE_NAME
	FROM EXTERNAL_CREDENTIALS
	WHERE CREDENTIAL_ID = p_CREDENTIAL_ID;

	IF NVL(v_USER_ID,CONSTANTS.ALL_ID) <> SECURITY_CONTROLS.CURRENT_USER_ID THEN
		SD.VERIFY_ACTION_IS_ALLOWED(SD.g_ACTION_MANAGE_ALL_CREDS);
	END IF;

	OPEN p_CURSOR FOR
		SELECT U.USER_DISPLAY_NAME, E.EVENT_TEXT, E.EVENT_TIMESTAMP,
			TO_CHAR(E.EVENT_ID) as EVENT_ID
		FROM PROCESS_LOG P, PROCESS_LOG_EVENT E, APPLICATION_USER U
		WHERE E.SOURCE_NAME = v_SOURCE_NAME
			AND P.PROCESS_ID = E.PROCESS_ID
			AND U.USER_ID = P.USER_ID
		ORDER BY E.EVENT_TIMESTAMP DESC, E.EVENT_ID DESC;
	p_STATUS := GA.SUCCESS;
END GET_EXT_CREDENTIAL_LOG;
---------------------------------------------------------------------------------------------------
PROCEDURE SEND_EXTERNAL_CREDENTIAL_ALERT AS
  v_COUNT NUMBER;
  CURSOR c_CERT IS
  SELECT ES.EXTERNAL_SYSTEM_NAME, EC.EXTERNAL_ACCOUNT_NAME, ECC.CERTIFICATE_EXPIRATION_DATE
  FROM EXTERNAL_CREDENTIALS_CERT ECC,
       EXTERNAL_CREDENTIALS EC,
       EXTERNAL_SYSTEM ES
  WHERE ECC.CERTIFICATE_EXPIRATION_DATE < TRUNC(SYSDATE) + 30 AND
       ECC.CREDENTIAL_ID = EC.CREDENTIAL_ID AND
       ES.EXTERNAL_SYSTEM_ID = EC.EXTERNAL_SYSTEM_ID;
  
  v_MESSAGE VARCHAR(4000) := 'Update expiring certificates using the External Credentials Report, accessed from the Tools menu.';
BEGIN
	
  SELECT COUNT(DISTINCT CREDENTIAL_ID)
  INTO v_COUNT
  FROM EXTERNAL_CREDENTIALS_CERT
  WHERE CERTIFICATE_EXPIRATION_DATE < TRUNC(SYSDATE) + 30;
  
  IF v_COUNT > 0 THEN
    FOR v_CERT IN c_CERT LOOP
      v_MESSAGE := v_CERT.External_System_Name || ' account ' || 
                v_CERT.EXTERNAL_ACCOUNT_NAME || ' certificate expires ' ||
                TO_CHAR(v_CERT.Certificate_Expiration_Date, 'yyyy-mm-dd') ||
                UTL_TCP.CRLF || v_MESSAGE;
    END LOOP;
    v_MESSAGE := v_MESSAGE || UTL_TCP.CRLF || UTL_TCP.CRLF;
    ALERTS.TRIGGER_ALERTS('Certificate Expiration', 0, v_MESSAGE, 'Other', TRUNC(SYSDATE));
  END IF;
  
END SEND_EXTERNAL_CREDENTIAL_ALERT;
---------------------------------------------------------------------------------------------------
PROCEDURE UPDATE_EXTERNAL_CREDENTIAL
	(
	p_CREDENTIAL_ID IN NUMBER,
	p_EXTERNAL_USER_NAME IN VARCHAR2,
	p_EXTERNAL_PASSWORD IN VARCHAR2,
	p_STATUS OUT NUMBER
	) AS
v_PW EXTERNAL_CREDENTIALS.EXTERNAL_PASSWORD%TYPE := SECURITY_CONTROLS.ENCODE(p_EXTERNAL_PASSWORD);
v_USER_ID EXTERNAL_CREDENTIALS.USER_ID%TYPE;
BEGIN
	SELECT USER_ID INTO v_USER_ID
	FROM EXTERNAL_CREDENTIALS
	WHERE CREDENTIAL_ID = p_CREDENTIAL_ID;

	-- verify that this user is allowed to change others' credentials
	IF NVL(v_USER_ID,CONSTANTS.ALL_ID) <> SECURITY_CONTROLS.CURRENT_USER_ID THEN
		SD.VERIFY_ACTION_IS_ALLOWED(SD.g_ACTION_MANAGE_ALL_CREDS);
	END IF;

	UPDATE EXTERNAL_CREDENTIALS SET
		EXTERNAL_USER_NAME = p_EXTERNAL_USER_NAME,
		EXTERNAL_PASSWORD = v_PW,
		ENTRY_DATE = SYSDATE
	WHERE CREDENTIAL_ID = p_CREDENTIAL_ID;

	LOG_CHANGE(p_CREDENTIAL_ID,'Changed external user-name and password -> '||p_EXTERNAL_USER_NAME);

	p_STATUS := GA.SUCCESS;
END UPDATE_EXTERNAL_CREDENTIAL;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_CERTIFICATE_LIST
	(
	p_CREDENTIAL_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_USER_ID EXTERNAL_CREDENTIALS.USER_ID%TYPE;
BEGIN
	SELECT USER_ID INTO v_USER_ID
	FROM EXTERNAL_CREDENTIALS
	WHERE CREDENTIAL_ID = p_CREDENTIAL_ID;

	-- verify that this user is allowed to change others' credentials
	IF NVL(v_USER_ID,CONSTANTS.ALL_ID) <> SECURITY_CONTROLS.CURRENT_USER_ID THEN
		SD.VERIFY_ACTION_IS_ALLOWED(SD.g_ACTION_MANAGE_ALL_CREDS);
	END IF;


	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT B.CREDENTIAL_ID,
			CASE WHEN C.NUMBER_OF_CERTIFICATES < 2 AND B.CERTIFICATE_TYPE = SECURITY_CONTROLS.g_AUTH_CERT_TYPE
				 THEN NULL
				 ELSE B.CERTIFICATE_TYPE
				 END "CERTIFICATE_TYPE",
			CASE WHEN B.CERTIFICATE_EXPIRATION_DATE = HIGH_DATE THEN NULL
				 ELSE B.CERTIFICATE_EXPIRATION_DATE
				 END "EXPIRATION_DATE",
			B.ENTRY_DATE
		FROM EXTERNAL_CREDENTIALS A, EXTERNAL_CREDENTIALS_CERT B, EXTERNAL_SYSTEM C
		WHERE A.CREDENTIAL_ID = p_CREDENTIAL_ID
			AND B.CREDENTIAL_ID = A.CREDENTIAL_ID
			AND C.EXTERNAL_SYSTEM_ID = A.EXTERNAL_SYSTEM_ID
		ORDER BY CERTIFICATE_EXPIRATION_DATE DESC, CERTIFICATE_TYPE ASC;
END GET_CERTIFICATE_LIST;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_CERTIFICATE_TYPE_LIST
	(
	p_NUMBER_OF_CERTIFICATES IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT NAME
		FROM (SELECT SECURITY_CONTROLS.g_AUTH_CERT_TYPE as NAME, 1 as SEQ
			  FROM DUAL
			  UNION ALL
			  SELECT SECURITY_CONTROLS.g_SIG_CERT_TYPE as NAME, 2 as SEQ
			  FROM DUAL)
		WHERE SEQ <= p_NUMBER_OF_CERTIFICATES
		ORDER BY SEQ;
END GET_CERTIFICATE_TYPE_LIST;
---------------------------------------------------------------------------------------------------
PROCEDURE UPDATE_CERTIFICATE
	(
	p_CREDENTIAL_ID IN NUMBER,
	p_CERTIFICATE_TYPE IN VARCHAR2,
	p_EXPIRATION_DATE IN DATE,
	p_OLD_CERTIFICATE_TYPE IN VARCHAR2,
	p_OLD_EXPIRATION_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS
v_USER_ID EXTERNAL_CREDENTIALS.USER_ID%TYPE;
BEGIN
	SELECT USER_ID INTO v_USER_ID
	FROM EXTERNAL_CREDENTIALS
	WHERE CREDENTIAL_ID = p_CREDENTIAL_ID;

	-- verify that this user is allowed to change others' credentials
	IF NVL(v_USER_ID,CONSTANTS.ALL_ID) <> SECURITY_CONTROLS.CURRENT_USER_ID THEN
		SD.VERIFY_ACTION_IS_ALLOWED(SD.g_ACTION_MANAGE_ALL_CREDS);
	END IF;

	p_STATUS := GA.SUCCESS;

	UPDATE EXTERNAL_CREDENTIALS_CERT SET
		CERTIFICATE_TYPE = p_CERTIFICATE_TYPE,
		CERTIFICATE_EXPIRATION_DATE = NVL(p_EXPIRATION_DATE,HIGH_DATE),
		ENTRY_DATE = SYSDATE
	WHERE CREDENTIAL_ID = p_CREDENTIAL_ID
		AND CERTIFICATE_TYPE = p_OLD_CERTIFICATE_TYPE
		AND CERTIFICATE_EXPIRATION_DATE = NVL(p_OLD_EXPIRATION_DATE,HIGH_DATE);

	LOG_CHANGE(p_CREDENTIAL_ID,'Changed certificate entry: '||p_OLD_CERTIFICATE_TYPE||' -> '||p_CERTIFICATE_TYPE||'; '||
									CASE WHEN p_OLD_EXPIRATION_DATE IS NULL THEN 'null' ELSE TO_CHAR(p_OLD_EXPIRATION_DATE,'YYYY-MM-DD') END||
									' -> '||CASE WHEN p_EXPIRATION_DATE IS NULL THEN 'null' ELSE TO_CHAR(p_EXPIRATION_DATE,'YYYY-MM-DD') END);

	p_STATUS := GA.SUCCESS;
END UPDATE_CERTIFICATE;
---------------------------------------------------------------------------------------------------
PROCEDURE REMOVE_CERTIFICATE
	(
	p_CREDENTIAL_ID IN NUMBER,
	p_OLD_CERTIFICATE_TYPE IN VARCHAR2,
	p_OLD_EXPIRATION_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS
v_CERT_TYPE EXTERNAL_CREDENTIALS_CERT.CERTIFICATE_TYPE%TYPE := NVL(p_OLD_CERTIFICATE_TYPE,SECURITY_CONTROLS.g_AUTH_CERT_TYPE);
BEGIN
	DELETE EXTERNAL_CREDENTIALS_CERT
	WHERE CREDENTIAL_ID = p_CREDENTIAL_ID
		AND CERTIFICATE_TYPE = v_CERT_TYPE
		AND CERTIFICATE_EXPIRATION_DATE = NVL(p_OLD_EXPIRATION_DATE,HIGH_DATE);

	LOG_CHANGE(p_CREDENTIAL_ID,'Removed certificate entry: '||v_CERT_TYPE||'; '||
									CASE WHEN p_OLD_EXPIRATION_DATE IS NULL THEN 'null' ELSE TO_CHAR(p_OLD_EXPIRATION_DATE,'YYYY-MM-DD') END);

	p_STATUS := GA.SUCCESS;
END REMOVE_CERTIFICATE;
---------------------------------------------------------------------------------------------------
PROCEDURE UPLOAD_CERTIFICATE
	(
	p_CREDENTIAL_ID IN NUMBER,
	p_CERTIFICATE_TYPE IN VARCHAR2,
	p_EXPIRATION_DATE IN DATE,
	p_CERT_PASSWORD IN VARCHAR2,
	p_IMPORT_FILE IN BLOB,
	p_STATUS OUT NUMBER
	) AS
v_CLOB CLOB := SECURITY_CONTROLS.ENCODE(p_IMPORT_FILE);
v_PW EXTERNAL_CREDENTIALS_CERT.CERTIFICATE_PASSWORD%TYPE := SECURITY_CONTROLS.ENCODE(p_CERT_PASSWORD);
v_USER_ID EXTERNAL_CREDENTIALS.USER_ID%TYPE;
BEGIN
	SELECT USER_ID INTO v_USER_ID
	FROM EXTERNAL_CREDENTIALS
	WHERE CREDENTIAL_ID = p_CREDENTIAL_ID;

	-- verify that this user is allowed to change others' credentials
	IF NVL(v_USER_ID,CONSTANTS.ALL_ID) <> SECURITY_CONTROLS.CURRENT_USER_ID THEN
		SD.VERIFY_ACTION_IS_ALLOWED(SD.g_ACTION_MANAGE_ALL_CREDS);
	END IF;

	p_STATUS := GA.SUCCESS;

	UPDATE EXTERNAL_CREDENTIALS_CERT SET
		CERTIFICATE_CONTENTS = v_CLOB,
		CERTIFICATE_PASSWORD = v_PW,
		ENTRY_DATE = SYSDATE
	WHERE CREDENTIAL_ID = p_CREDENTIAL_ID
		AND CERTIFICATE_TYPE = NVL(p_CERTIFICATE_TYPE,SECURITY_CONTROLS.g_AUTH_CERT_TYPE)
		AND CERTIFICATE_EXPIRATION_DATE = NVL(p_EXPIRATION_DATE,HIGH_DATE);

	IF SQL%NOTFOUND THEN
		INSERT INTO EXTERNAL_CREDENTIALS_CERT
			(CREDENTIAL_ID, CERTIFICATE_TYPE, CERTIFICATE_EXPIRATION_DATE,
			 CERTIFICATE_CONTENTS, CERTIFICATE_PASSWORD, ENTRY_DATE)
		VALUES
			(p_CREDENTIAL_ID, NVL(p_CERTIFICATE_TYPE,SECURITY_CONTROLS.g_AUTH_CERT_TYPE),
			 NVL(p_EXPIRATION_DATE,HIGH_DATE), v_CLOB, v_PW, SYSDATE);
	END IF;

	LOG_CHANGE(p_CREDENTIAL_ID,'Uploaded certificate: '||p_CERTIFICATE_TYPE||'; '||
									CASE WHEN p_EXPIRATION_DATE IS NULL THEN 'null' ELSE TO_CHAR(p_EXPIRATION_DATE,'YYYY-MM-DD') END);


	IF DBMS_LOB.ISTEMPORARY(v_CLOB)=1 THEN
		DBMS_LOB.FREETEMPORARY(v_CLOB);
	END IF;
END UPLOAD_CERTIFICATE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_USER_LIST
	(
	p_INCLUDE_ALL IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_MANAGE_ALL NUMBER(1) := 1;
v_INCLUDE_ALL NUMBER(1) := p_INCLUDE_ALL;

BEGIN
	IF NOT SD.GET_ACTION_IS_ALLOWED(SD.g_ACTION_MANAGE_ALL_CREDS) THEN
		v_MANAGE_ALL := 0;
		v_INCLUDE_ALL := 0;
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT NVL(U.USER_DISPLAY_NAME, SECURITY_CONTROLS.CURRENT_USER), SECURITY_CONTROLS.CURRENT_USER_ID FROM APPLICATION_USER U
				WHERE U.USER_ID = SECURITY_CONTROLS.CURRENT_USER_ID
		UNION ALL
		SELECT CONSTANTS.ALL_STRING, CONSTANTS.ALL_ID FROM DUAL WHERE v_INCLUDE_ALL = 1
		UNION ALL
		SELECT NVL(USER_DISPLAY_NAME, USER_NAME), USER_ID
		FROM (SELECT USER_NAME, USER_DISPLAY_NAME, USER_ID
				FROM APPLICATION_USER
				WHERE USER_ID <> SECURITY_CONTROLS.CURRENT_USER_ID
					AND v_MANAGE_ALL = 1
				ORDER BY 1);
END GET_USER_LIST;
---------------------------------------------------------------------------------------------------
PROCEDURE LIST_CALC_PROCESS_FOR_SECURITY
	(
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_IDs ID_TABLE := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_CALC_SECURITY, EC.ED_CALC_PROCESS);
BEGIN
	p_STATUS := GA.SUCCESS;

	-- only show processes  which current user can manage
	OPEN p_CURSOR FOR
		-- We include the ALL option to indicate "all processes that the user can manage".
		-- We validate this again in the grid report (below: GET_CALC_PROCESS_SECURITY)
		SELECT CONSTANTS.ALL_STRING as ENTITY_NAME,
			CONSTANTS.ALL_ID as ENTITY_ID
		FROM DUAL
		UNION ALL
		SELECT ENTITY_NAME, ENTITY_ID
		FROM (SELECT CALC_PROCESS_NAME as ENTITY_NAME,
					CALC_PROCESS_ID as ENTITY_ID
				FROM CALCULATION_PROCESS CP, TABLE(CAST(v_IDs as ID_TABLE)) IDs
				WHERE IDs.ID IN (SD.g_ALL_DATA_ENTITY_ID, CP.CALC_PROCESS_ID)
				ORDER BY 1);

END LIST_CALC_PROCESS_FOR_SECURITY;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_CALC_PROCESS_SECURITY
	(
	p_CALC_PROCESS_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_IDs ID_TABLE := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_CALC_SECURITY, EC.ED_CALC_PROCESS);
BEGIN

	OPEN p_CURSOR FOR
		SELECT CP.CALC_PROCESS_NAME,
			CP.CALC_PROCESS_ID,
			CPS.SELECT_ACTION_ID,
			CPS.RUN_ACTION_ID,
			CPS.PURGE_ACTION_ID,
			CPS.LOCK_STATE_ACTION_ID,
			NVL(CP.CONTEXT_DOMAIN_ID,0) as CONTEXT_DOMAIN_ID
		FROM CALCULATION_PROCESS CP,
			TABLE(CAST(v_IDs as ID_TABLE)) IDs,
			CALCULATION_PROCESS_SECURITY CPS
		WHERE IDs.ID IN (SD.g_ALL_DATA_ENTITY_ID, CP.CALC_PROCESS_ID)
			AND p_CALC_PROCESS_ID IN (CONSTANTS.ALL_ID, CP.CALC_PROCESS_ID)
			AND CPS.CALC_PROCESS_ID(+) = CP.CALC_PROCESS_ID
		ORDER BY 1;

END GET_CALC_PROCESS_SECURITY;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_CALC_PROCESS_SECURITY
	(
	p_CALC_PROCESS_ID IN NUMBER,
	p_SELECT_ACTION_ID IN NUMBER,
	p_RUN_ACTION_ID IN NUMBER,
	p_PURGE_ACTION_ID IN NUMBER,
	p_LOCK_STATE_ACTION_ID IN NUMBER
	) AS
BEGIN
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_CALC_SECURITY, p_CALC_PROCESS_ID, EC.ED_CALC_PROCESS);

	UPDATE CALCULATION_PROCESS_SECURITY
		SET SELECT_ACTION_ID = p_SELECT_ACTION_ID,
			RUN_ACTION_ID = p_RUN_ACTION_ID,
			PURGE_ACTION_ID = p_PURGE_ACTION_ID,
			LOCK_STATE_ACTION_ID = p_LOCK_STATE_ACTION_ID
	WHERE CALC_PROCESS_ID = p_CALC_PROCESS_ID;

	IF SQL%NOTFOUND THEN
		INSERT INTO CALCULATION_PROCESS_SECURITY
			(CALC_PROCESS_ID, SELECT_ACTION_ID, RUN_ACTION_ID, PURGE_ACTION_ID, LOCK_STATE_ACTION_ID)
		VALUES
			(p_CALC_PROCESS_ID, p_SELECT_ACTION_ID, p_RUN_ACTION_ID, p_PURGE_ACTION_ID, p_LOCK_STATE_ACTION_ID);
	END IF;
END PUT_CALC_PROCESS_SECURITY;
---------------------------------------------------------------------------------------------------
PROCEDURE CHECK_RESULT
	(
	p_RESULT IN NUMBER
	) AS

BEGIN
	ASSERT(p_RESULT != c_SESSION_STATUS_CURR_NOT_VTX, 'The session used to kill other sessions must be a valid application session.');
	ASSERT(p_RESULT != c_SESSION_STATUS_OWN_SESSION, 'You cannot kill your current session.');

	IF p_RESULT = c_SESSION_STATUS_BAD_SESSION THEN
		ERRS.RAISE(MSGCODES.c_ERR_INVALID_SESSION);
	ELSIF p_RESULT = c_SESSION_STATUS_PRIV THEN
		ERRS.RAISE(MSGCODES.c_ERR_NO_ALTER_SYS_PRIVS);
	ELSE
		ASSERT(p_RESULT = c_SESSION_STATUS_OK, 'Session Manager procedure returned invalid/unknown status code: '||p_RESULT);
	END IF;

END CHECK_RESULT;
---------------------------------------------------------------------------------------------------
  --
  -- LIST ALL THE CURRENT ORACLE SESSIONS IN USE BY RETAIL
  --
PROCEDURE LIST_SESSIONS
	(
	p_CURSOR IN OUT GA.REFCURSOR
	) IS

v_COMMAND varchar2(128);

v_RESULT NUMBER;

BEGIN

	SD.VERIFY_ACTION_IS_ALLOWED(SD.g_ACTION_SELECT_SESSIONS);

	-- Use dynamic sql to ensure it still compiles even when session management is not configured
	v_COMMAND := 'BEGIN :result := SESSION_MGR.LIST_SESSIONS(:curs); END;';
	EXECUTE IMMEDIATE v_COMMAND USING OUT v_RESULT, IN OUT p_CURSOR;

	CHECK_RESULT(v_RESULT);

	EXCEPTION
		WHEN e_ERR_NOT_CONF THEN
			ERRS.RAISE(MSGCODES.c_ERR_NO_SESSION_MGR);

END LIST_SESSIONS;  -- LIST_SESSIONS
---------------------------------------------------------------------------------------------------
  --
  -- KILL THE SPECIFIED SESSION
  --
PROCEDURE KILL_SESSION
	(
	p_SESSION_SID IN NUMBER,
	p_SESSION_SERIALNUM IN NUMBER
	) IS

v_COMMAND varchar2(128);
v_RESULT NUMBER(2);

BEGIN

	ASSERT(p_SESSION_SID IS NOT NULL, 'Required parameter p_SESSION_SID is null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_SESSION_SERIALNUM IS NOT NULL, 'Required parameter p_SESSION_SERIALNUM is null.', MSGCODES.c_ERR_ARGUMENT);

	SD.VERIFY_ACTION_IS_ALLOWED(SD.g_ACTION_KILL_SESSION);

	-- Use dynamic sql to ensure it still compiles even when session management is not configured
	v_COMMAND := 'BEGIN :result := SESSION_MGR.KILL_SESSION(:session, :serialNum); END;';
	EXECUTE IMMEDIATE v_COMMAND USING OUT v_RESULT, IN p_SESSION_SID, IN p_SESSION_SERIALNUM;

	CHECK_RESULT(v_RESULT);

	-- log termination of sessioN
	LOGS.LOG_NOTICE('Terminate Session -- Oracle SID: ' || p_SESSION_SID || ' Oracle Serial#: ' || p_SESSION_SERIALNUM);

	EXCEPTION
		WHEN e_ERR_NOT_CONF THEN
			ERRS.RAISE(MSGCODES.c_ERR_NO_SESSION_MGR);
END KILL_SESSION;  -- KILL_SESSION
---------------------------------------------------------------------------------------------------
  --
  -- Kill all sessions for the specified userInfo that is in the form of:
  --   marketMgrUser@schemaName
  --
PROCEDURE KILL_USER_SESSIONS
	(
	p_OWNER IN VARCHAR2
	)  AS

v_COMMAND varchar2(128);

v_COUNT NUMBER(2);

v_RESULT NUMBER(9);

BEGIN

	ASSERT(p_OWNER IS NOT NULL, 'Required parameter OWNER is null.', MSGCODES.c_ERR_ARGUMENT);

	SD.VERIFY_ACTION_IS_ALLOWED(SD.g_ACTION_KILL_SESSION);

	IF UPPER(SECURITY_CONTROLS.CURRENT_USER) = UPPER(p_OWNER) THEN
		ERRS.RAISE(MSGCODES.c_ERR_INVALID_SESSION, 'You cannot kill your own session.');
	END IF;

	-- Make sure the user exists in the schema
	SELECT COUNT(U.USER_ID) INTO v_COUNT
	FROM APPLICATION_USER U
	WHERE UPPER(U.USER_NAME) = UPPER(p_OWNER);

	IF v_COUNT <= 0 THEN
		ERRS.RAISE(MSGCODES.c_ERR_INVALID_SESSION, 'User: '  || p_OWNER || ' is not a known user.');
	END IF;

	-- Use dynamic sql to ensure it still compiles even when session management is not configured
	v_COMMAND := 'BEGIN :result := SESSION_MGR.KILL_USER_SESSIONS(:user); END;';
	EXECUTE IMMEDIATE v_COMMAND USING OUT v_RESULT, IN p_OWNER;

	CHECK_RESULT(v_RESULT);

	-- log termination of session
	LOGS.LOG_NOTICE('Terminate all sessions for user: ' || p_OWNER);

	EXCEPTION
		WHEN e_ERR_NOT_CONF THEN
			ERRS.RAISE(MSGCODES.c_ERR_NO_SESSION_MGR);

END KILL_USER_SESSIONS;  -- KILL_USER_SESSION
---------------------------------------------------------------------------------------------------
PROCEDURE DISABLE_USER
(
	p_OWNER IN VARCHAR2,
	p_MESSAGE OUT VARCHAR2
) AS

	v_USER APPLICATION_USER%ROWTYPE;

BEGIN

	ASSERT(p_OWNER IS NOT NULL, 'Required parameter OWNER is null.', MSGCODES.c_ERR_ARGUMENT);

	SELECT * INTO v_USER FROM APPLICATION_USER A WHERE A.USER_NAME = p_OWNER;

	-- TESTING TO MAKE SURE WE'RE NOT DISABLING THE CURRENT USER IS HANDLED IN
	-- THE PUT_APPLICATION_USER PROCEDURE
	PUT_APPLICATION_USER(v_USER.USER_ID, p_OWNER, v_USER.USER_DISPLAY_NAME, v_USER.EMAIL_ADDR, 1, v_USER.IS_SYSTEM_USER, p_MESSAGE);

END DISABLE_USER;
---------------------------------------------------------------------------------------------------
FUNCTION GET_USER_DISPLAY_NAME
(
	p_USER_NAME IN VARCHAR2
) RETURN VARCHAR2 IS

	v_RESULT VARCHAR2(512);

BEGIN

	SELECT NVL(A.USER_DISPLAY_NAME, p_USER_NAME) INTO v_RESULT
	FROM APPLICATION_USER A
	WHERE UPPER(A.USER_NAME) = UPPER(p_USER_NAME);

	RETURN v_RESULT;

END GET_USER_DISPLAY_NAME;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_UI_SESSION_ID(p_UI_SESSION_ID OUT VARCHAR2) AS
    v_USER_SESSION_PROCESS_ID   PROCESS_LOG.PROCESS_ID%TYPE;
    v_UI_SESSION_ID             VARCHAR2(512);
BEGIN
    ASSERT(SECURITY_CONTROLS.CURRENT_USER_ID IS NOT NULL, 'The logged in User Id cannot be null.');
    
    -- Create a PIPE delimited SESSION_ID with format: <USER_NAME>|<SID>|<AUDSID>|<User Session PROCESS_ID>
    SELECT MAX(P.PROCESS_ID)
    INTO v_USER_SESSION_PROCESS_ID
    FROM PROCESS_LOG P, V$SESSION S
    WHERE P.SESSION_MACHINE = S.MACHINE
          AND (P.SESSION_PROGRAM = S.PROGRAM OR (P.SESSION_PROGRAM IS NULL AND S.PROGRAM IS NULL))
          AND P.USER_ID = SECURITY_CONTROLS.CURRENT_USER_ID
          AND TRUNC(P.PROCESS_START_TIME) = TRUNC(SYSDATE)
          AND P.PROCESS_TYPE = LOGS.c_PROCESS_TYPE_USER_SESSION
          AND S.SID = SYS_CONTEXT('USERENV', 'SID')                       
          AND S.AUDSID = SYS_CONTEXT('USERENV', 'SESSIONID');

    v_UI_SESSION_ID := SECURITY_CONTROLS.CURRENT_USER || '|' || 
                       SYS_CONTEXT('USERENV', 'SID') || '|' ||
                       SYS_CONTEXT('USERENV', 'SESSIONID') || '|' ||
                       v_USER_SESSION_PROCESS_ID || '|' ||
                       TO_CHAR(SYSDATE, c_DATE_TIME_FORMAT);
    
    p_UI_SESSION_ID := SECURITY_CONTROLS.ENCODE(v_UI_SESSION_ID);

END GET_UI_SESSION_ID;
-------------------------------------------------------------------------------------------------
PROCEDURE VALIDATE_UI_SESSION_ID
	(
    p_UI_SESSION_ID IN VARCHAR2, 
    p_IS_VALID OUT NUMBER,
    p_SESSION_USER_NAME OUT VARCHAR2
    ) AS
    v_USER_SESSION_PROCESS_ID   PROCESS_LOG.PROCESS_ID%TYPE;
    v_SID                       V$SESSION.SID%TYPE;
    v_AUDSID                    V$SESSION.AUDSID%TYPE;
    v_SESSION_DATE_TIME         DATE;
    v_DECRYPTED_UI_SESSION_ID   VARCHAR2(512);
    v_TOKENS                    GA.STRING_TABLE;
    v_IS_VALID_USER             NUMBER(1) := 0;
    v_ORACLE_SESSION_ENTRY      V$SESSION%ROWTYPE;
    v_PROCESS_LOG_ENTRY         PROCESS_LOG%ROWTYPE;
BEGIN
    ASSERT(p_UI_SESSION_ID IS NOT NULL, 'Invalid Session Id. The UI Session Id must not be null.');
    
    v_DECRYPTED_UI_SESSION_ID := SECURITY_CONTROLS.DECODE(p_UI_SESSION_ID);
    
    ASSERT(v_DECRYPTED_UI_SESSION_ID IS NOT NULL, 'Invalid Session Id. The Decrypted UI Session Id was null.');
    
    UT.TOKENS_FROM_STRING(v_DECRYPTED_UI_SESSION_ID,'|',v_TOKENS);
    
    LOGS.LOG_INFO_MORE_DETAIL('Token Count: ' || v_TOKENS.COUNT);
    
    IF v_TOKENS.COUNT = 5 THEN
		
        -- Get User Name from the Session Id
        p_SESSION_USER_NAME := v_TOKENS(1);
        
        -- Validate the User Name against internal APPLICATION_USER tables
        SA.IS_VALID_USER(p_SESSION_USER_NAME, v_IS_VALID_USER);
        
        LOGS.LOG_INFO_MORE_DETAIL('Valid User: ' || v_IS_VALID_USER);
        
        IF v_IS_VALID_USER = 1 THEN
            -- Get the Oracle Session information from the Session Id
            v_SID := TO_NUMBER(v_TOKENS(2));
            v_AUDSID := TO_NUMBER(v_TOKENS(3));
            
            -- Validate the Oracle Session information against V$Session tables.
            -- This does not guarantee that the user is still logged in since Oracle Ids can be reused.
            -- But this is just one step in the validation. A Valid Oracle Session must exist.
            BEGIN
				SELECT *
                INTO v_ORACLE_SESSION_ENTRY
                FROM V$SESSION V
                WHERE V.SID = v_SID
                  AND V.AUDSID = v_AUDSID; 
                  
                LOGS.LOG_INFO_MORE_DETAIL('Valid Oracle Session found.');               
            EXCEPTION
				  WHEN NO_DATA_FOUND THEN
					  -- Not valid, exit immediately
                      p_IS_VALID := 0;
                      RETURN;
            END;
            
            -- Check to see if we have a valid User Session in the Process Log             
            BEGIN
			    v_USER_SESSION_PROCESS_ID := TO_NUMBER(v_TOKENS(4));
                
                SELECT *
                INTO v_PROCESS_LOG_ENTRY
                FROM PROCESS_LOG P
                WHERE P.PROCESS_TYPE = LOGS.c_PROCESS_TYPE_USER_SESSION                     
                      AND P.USER_ID IN (SELECT X.USER_ID
                                        FROM APPLICATION_USER X
                                        WHERE X.USER_NAME = p_SESSION_USER_NAME)
                      AND P.PROCESS_ID = v_USER_SESSION_PROCESS_ID;
                
                LOGS.LOG_INFO_MORE_DETAIL('Valid User Process found.');      
            EXCEPTION
				  WHEN NO_DATA_FOUND THEN
					  -- Not valid, exit immediately
                      p_IS_VALID := 0;
                      RETURN;
            END;      
            /* CANT VALIDATE SYSTEM_SESSION table THE PROCESS_ID is null -pbm */
            -- Now we know that each of the 4 pieces is valid, 
            -- join the User Process to the Oracle Session
            -- using the SYSTEM_SESSION table. 
            -- This table is managed by the Logon/Logoff Triggers.
            /*
            SELECT COUNT(1)
            INTO v_IS_VALID
            FROM SYSTEM_SESSION X
            WHERE X.SESSION_SID = v_ORACLE_SESSION_ENTRY.SID
              AND X.SESSION_AUDSID = v_ORACLE_SESSION_ENTRY.AUDSID
              AND X.CURRENT_PROCESS_ID = v_PROCESS_LOG_ENTRY.PROCESS_ID;
              
            LOGS.LOG_INFO_MORE_DETAIL('Valid System Session count = ' || v_IS_VALID);
            */            
            
            v_SESSION_DATE_TIME := TO_DATE(v_TOKENS(5), c_DATE_TIME_FORMAT);
            
            LOGS.LOG_INFO_MORE_DETAIL('Session Date = ' || v_TOKENS(5));
            
            IF v_SESSION_DATE_TIME > SYSDATE - c_SESSION_EXPIRATION_TIME THEN
			    LOGS.LOG_INFO_MORE_DETAIL('Valid Session Date.');
                p_IS_VALID := 1;
            END IF;
             
        END IF;      
    END IF;

END VALIDATE_UI_SESSION_ID;
-------------------------------------------------------------------------------------------------
END SA;
/
