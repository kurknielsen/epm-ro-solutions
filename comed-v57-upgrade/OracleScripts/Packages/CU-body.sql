CREATE OR REPLACE PACKAGE BODY CU AS
---------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
    RETURN '$Revision: 1.1 $';
END WHAT_VERSION;
----------------------------------------------------------------------------------------------------
FUNCTION NULL_CURSOR RETURN GA.REFCURSOR IS
v_CURSOR GA.REFCURSOR;
BEGIN
	OPEN v_CURSOR FOR SELECT NULL FROM DUAL;
	RETURN v_CURSOR;
END NULL_CURSOR;
----------------------------------------------------------------------------------------------------
FUNCTION INTERVAL_DIVISOR
	(
	p_INTERVAL IN NUMBER
	)  RETURN NUMBER IS

BEGIN

   IF p_INTERVAL IN (1,24,48,96) THEN
      RETURN 1/p_INTERVAL;
   ELSE
      RETURN 1/24;
   END IF;

END INTERVAL_DIVISOR;
---------------------------------------------------------------------------------------------------
FUNCTION COMPONENT_IS_SWING_COMPONENT
	(
	p_COMPONENT_ID IN NUMBER,
	p_SERVICE_DATE IN DATE
	) RETURN BOOLEAN IS

v_COUNT NUMBER(2);

BEGIN

	SELECT COUNT(*)
	INTO v_COUNT
	FROM COMPONENT A
	WHERE A.COMPONENT_ID = p_COMPONENT_ID
		AND UPPER(A.RATE_STRUCTURE) = 'IMBALANCE'
		AND UPPER(A.IMBALANCE_TYPE) = 'SWING';

	RETURN v_COUNT > 0;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN FALSE;

END COMPONENT_IS_SWING_COMPONENT;
---------------------------------------------------------------------------------------------------
FUNCTION PRODUCT_HAS_SWING_COMPONENT
	(
	p_PRODUCT_ID IN NUMBER,
	p_SERVICE_DATE IN DATE
	) RETURN BOOLEAN IS

v_COUNT NUMBER(2);

BEGIN

	SELECT COUNT(*)
	INTO v_COUNT
	FROM PRODUCT_COMPONENT A, COMPONENT B
	WHERE A.PRODUCT_ID = p_PRODUCT_ID
		AND p_SERVICE_DATE BETWEEN A.BEGIN_DATE AND NVL(A.END_DATE, p_SERVICE_DATE)
		AND B.COMPONENT_ID = A.COMPONENT_ID
		AND UPPER(B.RATE_STRUCTURE) = 'IMBALANCE'
		AND UPPER(B.IMBALANCE_TYPE) = 'SWING';

	RETURN v_COUNT > 0;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN FALSE;
END PRODUCT_HAS_SWING_COMPONENT;
---------------------------------------------------------------------------------------------------
FUNCTION GET_CALENDAR_NAME
	(
	p_CALENDAR_ID IN NUMBER
	) RETURN VARCHAR IS

v_CALENDAR_NAME VARCHAR(32);

BEGIN

	SELECT CALENDAR_NAME INTO v_CALENDAR_NAME FROM CALENDAR WHERE CALENDAR_ID = p_CALENDAR_ID;

	RETURN v_CALENDAR_NAME;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN 'UNKNOWN';

END GET_CALENDAR_NAME;
---------------------------------------------------------------------------------------------------
FUNCTION IS_FORWARD_CACHED
    (
	p_MARKET_PRICE_ID NUMBER
	) RETURN BOOLEAN IS

v_COUNT PLS_INTEGER;

BEGIN

	SELECT COUNT(1)
	INTO v_COUNT
	FROM TABLE(CAST(g_FORWARDS AS FORWARD_TABLE)) A
	WHERE A.ENTITY_ID = p_MARKET_PRICE_ID;

	RETURN v_COUNT > 0;

END IS_FORWARD_CACHED;
---------------------------------------------------------------------------------------------------
FUNCTION GET_COMPONENT
    (
	p_COMPONENT_ID IN NUMBER
	) RETURN COMPONENT%ROWTYPE IS

v_COMPONENT COMPONENT%ROWTYPE;

BEGIN

    SELECT *
	INTO v_COMPONENT
	FROM COMPONENT
	WHERE COMPONENT_ID = p_COMPONENT_ID;

	RETURN v_COMPONENT;

	EXCEPTION
		WHEN OTHERS THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN NULL;

END GET_COMPONENT;
---------------------------------------------------------------------------------------------------
FUNCTION GET_TAX_AREA_TAX_RATE
    (
	p_GEOGRAPHY_ID IN NUMBER,
	p_TAX IN OUT NOCOPY TAX_TABLE
	) RETURN NUMBER IS
v_INDEX BINARY_INTEGER;
v_TAX_RATE NUMBER := 0;
v_IS_WITHIN NUMBER(1);
BEGIN

	v_INDEX := p_TAX.FIRST;
	WHILE v_INDEX <= p_TAX.LAST LOOP
    	-- see if the specified geography falls within this tax table entry
        SELECT COUNT(1)
        	INTO v_IS_WITHIN
            FROM (SELECT GEOGRAPHY_ID
		        FROM GEOGRAPHY A
        			START WITH A.GEOGRAPHY_ID = p_GEOGRAPHY_ID
            	    CONNECT BY PRIOR A.PARENT_GEOGRAPHY_ID = A.GEOGRAPHY_ID) A
	        WHERE GEOGRAPHY_ID = p_TAX(v_INDEX).GEOGRAPHY_ID;

      	-- add up all tax rates that this geography falls in
		IF v_IS_WITHIN > 0 THEN
        	v_TAX_RATE := v_TAX_RATE + p_TAX(v_INDEX).TAX_RATE;
		END IF;
		v_INDEX := p_TAX.NEXT(v_INDEX);
	END LOOP;

	RETURN v_TAX_RATE;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN 0;
END GET_TAX_AREA_TAX_RATE;
---------------------------------------------------------------------------------------------------
FUNCTION GET_PRODUCT_TAX_COMPONENT_ID
    (
	p_PRODUCT_ID IN NUMBER,
	p_SERVICE_DATE IN DATE
	) RETURN NUMBER IS

v_COMPONENT_ID NUMBER(9) := CONSTANTS.NOT_ASSIGNED;

BEGIN

	SELECT B.COMPONENT_ID
	INTO v_COMPONENT_ID
	FROM PRODUCT_COMPONENT A, COMPONENT B
	WHERE A.PRODUCT_ID = p_PRODUCT_ID
		AND p_SERVICE_DATE BETWEEN A.BEGIN_DATE AND NVL(A.END_DATE, HIGH_DATE)
		AND B.COMPONENT_ID = A.COMPONENT_ID
		AND UPPER(B.CHARGE_TYPE) = 'TAX'
		AND ROWNUM = 1;

	RETURN v_COMPONENT_ID;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN CONSTANTS.NOT_ASSIGNED;
END GET_PRODUCT_TAX_COMPONENT_ID;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_PRODUCT_TAX_COMPONENT
    (
	p_PRODUCT_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_COMPONENT_ID IN OUT NUMBER,
	p_TAX IN OUT NOCOPY TAX_TABLE
	) AS

BEGIN

	p_COMPONENT_ID := GET_PRODUCT_TAX_COMPONENT_ID(p_PRODUCT_ID, p_SERVICE_DATE);

	IF NOT p_COMPONENT_ID = CONSTANTS.NOT_ASSIGNED THEN
		SELECT TAX_TYPE(A.GEOGRAPHY_ID, B.RATE)
		BULK COLLECT INTO p_TAX
		FROM GEOGRAPHY A, COMPONENT_FLAT_RATE B
		WHERE B.COMPONENT_ID = p_COMPONENT_ID
        	AND B.SUB_COMPONENT_TYPE = 'GEOGRAPHY'
            AND B.SUB_COMPONENT_ID = A.GEOGRAPHY_ID
			AND p_SERVICE_DATE BETWEEN B.BEGIN_DATE AND NVL(B.END_DATE, HIGH_DATE)
		START WITH A.PARENT_GEOGRAPHY_ID = 0
        CONNECT BY PRIOR A.GEOGRAPHY_ID = A.PARENT_GEOGRAPHY_ID;
	END IF;

END GET_PRODUCT_TAX_COMPONENT;
---------------------------------------------------------------------------------------------------
FUNCTION GET_COMPONENT_FACTOR
    (
	p_COMPONENT_ID IN NUMBER,
	p_SERVICE_DATE IN DATE
	) RETURN NUMBER IS

v_FACTOR NUMBER;

BEGIN

	SELECT PERCENT_VAL / 100.0
	INTO v_FACTOR
	FROM COMPONENT_PERCENTAGE
	WHERE COMPONENT_ID = p_COMPONENT_ID
        AND TRUNC(p_SERVICE_DATE) BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE)
		AND ROWNUM = 1;

	RETURN v_FACTOR;

	EXCEPTION
	    WHEN OTHERS THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		    RETURN 1.0;

END GET_COMPONENT_FACTOR;
---------------------------------------------------------------------------------------------------
FUNCTION GET_COMPONENT_FLAT_RATE
    (
	p_COMPONENT_ID IN NUMBER,
	p_QUANTITY IN OUT NUMBER,
	p_SERVICE_DATE IN DATE
	) RETURN NUMBER IS

v_RATE NUMBER;
v_CHARGE_MIN NUMBER;

BEGIN

	SELECT RATE, CHARGE_MIN
	INTO v_RATE, v_CHARGE_MIN
	FROM COMPONENT_FLAT_RATE
	WHERE COMPONENT_ID = p_COMPONENT_ID
    	AND SUB_COMPONENT_TYPE = g_NO_SUB_TYPE
        AND SUB_COMPONENT_ID = CONSTANTS.NOT_ASSIGNED
        AND TRUNC(p_SERVICE_DATE) BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE)
		AND ROWNUM = 1;

	IF v_CHARGE_MIN > p_QUANTITY THEN
		p_QUANTITY := v_CHARGE_MIN;
	END IF;

	RETURN v_RATE;

	EXCEPTION
		WHEN OTHERS THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN 0;

END GET_COMPONENT_FLAT_RATE;
---------------------------------------------------------------------------------------------------
FUNCTION GET_COMPONENT_FLAT_RATE
    (
	p_COMPONENT_ID IN NUMBER,
	p_ACCOUNT_SERVICE_ID IN NUMBER,
	p_QUANTITY IN OUT NUMBER,
	p_SERVICE_DATE IN DATE
	) RETURN NUMBER IS

v_RATE NUMBER;
v_CHARGE_MIN NUMBER;

BEGIN

	SELECT RATE, CHARGE_MIN
	INTO v_RATE, v_CHARGE_MIN
	FROM COMPONENT_FLAT_RATE
	WHERE COMPONENT_ID = p_COMPONENT_ID
        AND SUB_COMPONENT_TYPE = 'ACCOUNT_SERVICE'
        AND SUB_COMPONENT_ID = p_ACCOUNT_SERVICE_ID
        AND TRUNC(p_SERVICE_DATE) BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE)
		AND ROWNUM = 1;

	IF v_CHARGE_MIN > p_QUANTITY THEN
		p_QUANTITY := v_CHARGE_MIN;
	END IF;

	RETURN v_RATE;

	EXCEPTION
		WHEN OTHERS THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN 0;

END GET_COMPONENT_FLAT_RATE;
---------------------------------------------------------------------------------------------------
FUNCTION GET_COMPONENT_TAX_RATE
    (
	p_COMPONENT_ID IN NUMBER,
	p_SERVICE_DATE IN DATE
	) RETURN NUMBER IS

BEGIN

	RETURN 0;

END GET_COMPONENT_TAX_RATE;
---------------------------------------------------------------------------------------------------
FUNCTION GET_COMPONENT_TOU_RATE
    (
	p_COMPONENT_ID IN NUMBER,
	p_PERIOD_ID IN NUMBER,
	p_SERVICE_DATE IN DATE
	) RETURN NUMBER IS

v_RATE NUMBER;

BEGIN

	SELECT RATE
	INTO v_RATE
	FROM COMPONENT_TOU_RATE
	WHERE COMPONENT_ID = p_COMPONENT_ID
    	AND SUB_COMPONENT_TYPE = g_NO_SUB_TYPE
        AND SUB_COMPONENT_ID = CONSTANTS.NOT_ASSIGNED
        AND PERIOD_ID = p_PERIOD_ID
		AND TRUNC(p_SERVICE_DATE) BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE)
		AND ROWNUM = 1;

	RETURN v_RATE;

	EXCEPTION
		WHEN OTHERS THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN 0;

END GET_COMPONENT_TOU_RATE;
---------------------------------------------------------------------------------------------------
FUNCTION GET_COMPONENT_TIERED_RATE
    (
	p_COMPONENT_ID IN NUMBER,
	p_QUANTITY IN OUT NUMBER,
	p_SERVICE_DATE IN DATE,
	p_DEMAND IN NUMBER,
	p_TIERED_RATE IN OUT NOCOPY TIERED_RATE_TABLE
	) RETURN NUMBER IS

v_QUANTITY NUMBER := p_QUANTITY;
v_AMOUNT NUMBER := 0;
v_ASSIGNED NUMBER := 0;
v_BLOCK_QUANTITY NUMBER := 0;
v_INDEX BINARY_INTEGER;

BEGIN

	IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
		LOGS.LOG_DEBUG_DETAIL('GET_COMPONENT_TIERED_RATE COUNT=' || TO_CHAR(p_TIERED_RATE.COUNT));
		IF p_TIERED_RATE.COUNT > 0 THEN
			LOGS.LOG_DEBUG_DETAIL('<index>,<block max>,<charge min>,<rate>');
			v_INDEX := p_TIERED_RATE.FIRST;
			WHILE v_INDEX <= p_TIERED_RATE.LAST LOOP
				LOGS.LOG_DEBUG_DETAIL(TO_CHAR(v_INDEX) || ',' || TO_CHAR(p_TIERED_RATE(v_INDEX).BLOCK_MAX) || ',' || TO_CHAR(p_TIERED_RATE(v_INDEX).CHARGE_MIN) || ',' || TO_CHAR(p_TIERED_RATE(v_INDEX).RATE));
				v_INDEX := p_TIERED_RATE.NEXT(v_INDEX);
			END LOOP;
		END IF;
	END IF;

	IF p_TIERED_RATE.COUNT > 0 THEN
		v_INDEX := p_TIERED_RATE.FIRST;
		WHILE v_INDEX <= p_TIERED_RATE.LAST LOOP
-- If demand hours charge type then adjust the blocks for the demand.
			IF p_DEMAND IS NOT NULL THEN
				p_TIERED_RATE(v_INDEX).BLOCK_MAX := LEAST(p_TIERED_RATE(v_INDEX).BLOCK_MAX * p_DEMAND, 999999999);
				p_TIERED_RATE(v_INDEX).CHARGE_MIN := LEAST(p_TIERED_RATE(v_INDEX).CHARGE_MIN * p_DEMAND, 999999999);
			END IF;
-- Determine the quantity a block can contribute.
			IF v_INDEX = p_TIERED_RATE.FIRST THEN
				v_BLOCK_QUANTITY := p_TIERED_RATE(v_INDEX).BLOCK_MAX;
			ELSE
				v_BLOCK_QUANTITY := p_TIERED_RATE(v_INDEX).BLOCK_MAX - p_TIERED_RATE(v_INDEX - 1).BLOCK_MAX;
			END IF;

-- Assign the quantity contribution for the block.
			IF v_QUANTITY <= v_BLOCK_QUANTITY THEN
				v_QUANTITY := GREATEST(v_QUANTITY, p_TIERED_RATE(v_INDEX).CHARGE_MIN);
				v_AMOUNT := v_AMOUNT + v_QUANTITY * p_TIERED_RATE(v_INDEX).RATE;
				v_ASSIGNED := v_ASSIGNED + v_QUANTITY;
				IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
					LOGS.LOG_DEBUG_DETAIL('index=' || TO_CHAR(v_INDEX) || ', amount=' || TO_CHAR(v_AMOUNT) || ', quantity=' || TO_CHAR(v_QUANTITY) || ', assigned=' || TO_CHAR(v_ASSIGNED) || ', block quantity=' || TO_CHAR(v_BLOCK_QUANTITY));
				END IF;
				EXIT;
			ELSE
				v_AMOUNT := v_AMOUNT + v_BLOCK_QUANTITY * p_TIERED_RATE(v_INDEX).RATE;
				v_QUANTITY := v_QUANTITY - v_BLOCK_QUANTITY;
				v_ASSIGNED := v_ASSIGNED + v_BLOCK_QUANTITY;
				IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
					LOGS.LOG_DEBUG_DETAIL('index=' || TO_CHAR(v_INDEX) || ', amount=' || TO_CHAR(v_AMOUNT) || ', quantity=' || TO_CHAR(v_QUANTITY) || ', assigned=' || TO_CHAR(v_ASSIGNED) || ', block quantity=' || TO_CHAR(v_BLOCK_QUANTITY));
				END IF;
			END IF;
			v_INDEX := p_TIERED_RATE.NEXT(v_INDEX);
		END LOOP;
	END IF;

	IF v_ASSIGNED > 0 THEN
		p_QUANTITY := v_ASSIGNED;
		RETURN v_AMOUNT / p_QUANTITY;
	ELSE
		RETURN 0;
	END IF;

EXCEPTION
		WHEN OTHERS THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN 0;

END GET_COMPONENT_TIERED_RATE;
---------------------------------------------------------------------------------------------------
FUNCTION GET_COMPONENT_TIERED_RATE
    (
	p_COMPONENT_ID IN NUMBER,
	p_QUANTITY IN OUT NUMBER,
	p_SERVICE_DATE IN DATE,
	p_DEMAND IN NUMBER DEFAULT NULL
	) RETURN NUMBER IS

v_TIERED_RATE TIERED_RATE_TABLE := TIERED_RATE_TABLE();

BEGIN

	SELECT TIERED_RATE_TYPE(NVL(BLOCK_MIN,0), NVL(BLOCK_MAX,999999999), NVL(CHARGE_MIN,0), RATE)
	BULK COLLECT INTO v_TIERED_RATE
	FROM COMPONENT_BLOCK_RATE
	WHERE COMPONENT_ID = p_COMPONENT_ID
    	AND SUB_COMPONENT_TYPE = g_NO_SUB_TYPE
        AND SUB_COMPONENT_ID = CONSTANTS.NOT_ASSIGNED
        AND TRUNC(p_SERVICE_DATE) BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE)
	ORDER BY NVL(BLOCK_MIN,0);

	RETURN GET_COMPONENT_TIERED_RATE(p_COMPONENT_ID, p_QUANTITY, p_SERVICE_DATE, p_DEMAND, v_TIERED_RATE);

END GET_COMPONENT_TIERED_RATE;
---------------------------------------------------------------------------------------------------
FUNCTION GET_COMPONENT_TIERED_RATE
    (
	p_COMPONENT_ID IN NUMBER,
	p_ACCOUNT_SERVICE_ID IN NUMBER,
	p_QUANTITY IN OUT NUMBER,
	p_SERVICE_DATE IN DATE,
	p_DEMAND IN NUMBER DEFAULT NULL
	) RETURN NUMBER IS

v_TIERED_RATE TIERED_RATE_TABLE := TIERED_RATE_TABLE();

BEGIN

	SELECT TIERED_RATE_TYPE(NVL(BLOCK_MIN,0), NVL(BLOCK_MAX,999999999), NVL(CHARGE_MIN,0), RATE)
	BULK COLLECT INTO v_TIERED_RATE
	FROM COMPONENT_BLOCK_RATE
	WHERE COMPONENT_ID = p_COMPONENT_ID
        AND SUB_COMPONENT_TYPE = 'ACCOUNT_SERVICE'
        AND SUB_COMPONENT_ID = p_ACCOUNT_SERVICE_ID
        AND TRUNC(p_SERVICE_DATE) BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE)
	ORDER BY NVL(BLOCK_MIN,0);

	RETURN GET_COMPONENT_TIERED_RATE(p_COMPONENT_ID, p_QUANTITY, p_SERVICE_DATE, p_DEMAND, v_TIERED_RATE);

END GET_COMPONENT_TIERED_RATE;
---------------------------------------------------------------------------------------------------
FUNCTION GET_COMPONENT_BLOCK_RATE
    (
	p_COMPONENT_ID IN NUMBER,
	p_QUANTITY IN OUT NUMBER,
	p_SERVICE_DATE IN DATE
	) RETURN NUMBER IS

v_RATE NUMBER;
v_CHARGE_MIN NUMBER;

BEGIN

	SELECT RATE, CHARGE_MIN
	INTO v_RATE, v_CHARGE_MIN
	FROM COMPONENT_BLOCK_RATE
	WHERE COMPONENT_ID = p_COMPONENT_ID
    	AND SUB_COMPONENT_TYPE = g_NO_SUB_TYPE
        AND SUB_COMPONENT_ID = CONSTANTS.NOT_ASSIGNED
        AND TRUNC(p_SERVICE_DATE) BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE)
		AND p_QUANTITY BETWEEN BLOCK_MIN AND BLOCK_MAX
		AND ROWNUM = 1;

	IF v_CHARGE_MIN > p_QUANTITY THEN
		p_QUANTITY := v_CHARGE_MIN;
	END IF;

	RETURN v_RATE;

	EXCEPTION
		WHEN OTHERS THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN 0;

END GET_COMPONENT_BLOCK_RATE;
---------------------------------------------------------------------------------------------------
FUNCTION GET_COMPONENT_BLOCK_RATE
    (
	p_COMPONENT_ID IN NUMBER,
	p_ACCOUNT_SERVICE_ID IN NUMBER,
	p_QUANTITY IN OUT NUMBER,
	p_SERVICE_DATE IN DATE
	) RETURN NUMBER IS

v_RATE NUMBER;
v_CHARGE_MIN NUMBER;

BEGIN

	SELECT RATE, CHARGE_MIN
	INTO v_RATE, v_CHARGE_MIN
	FROM COMPONENT_BLOCK_RATE
	WHERE COMPONENT_ID = p_COMPONENT_ID
        AND SUB_COMPONENT_TYPE = 'ACCOUNT_SERVICE'
        AND SUB_COMPONENT_ID = p_ACCOUNT_SERVICE_ID
        AND TRUNC(p_SERVICE_DATE) BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE)
		AND p_QUANTITY BETWEEN BLOCK_MIN AND BLOCK_MAX
		AND ROWNUM = 1;

	IF v_CHARGE_MIN > p_QUANTITY THEN
		p_QUANTITY := v_CHARGE_MIN;
	END IF;

	RETURN v_RATE;

	EXCEPTION
		WHEN OTHERS THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN 0;

END GET_COMPONENT_BLOCK_RATE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_BILL_CYCLE_PERIOD
    (
	p_BILL_CYCLE_ID IN NUMBER,
	p_BILL_CYCLE_MONTH IN DATE,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE
	) AS

BEGIN

	SELECT BEGIN_DATE, NVL(END_DATE, ADD_MONTHS(p_BEGIN_DATE,1) - 1)
	INTO p_BEGIN_DATE, p_END_DATE
	FROM BILL_CYCLE_PERIOD
	WHERE BILL_CYCLE_ID = p_BILL_CYCLE_ID
        AND BILL_CYCLE_MONTH = TRUNC(p_BILL_CYCLE_MONTH,'MONTH');

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		p_BEGIN_DATE := TRUNC(p_BILL_CYCLE_MONTH, 'MONTH');
		p_END_DATE := LAST_DAY(p_BILL_CYCLE_MONTH);

END GET_BILL_CYCLE_PERIOD;
---------------------------------------------------------------------------------------------------
FUNCTION GET_NEXT_DATE_FOR_INTERVAL
    (
	p_DATE IN DATE,
	p_INTERVAL IN VARCHAR,
	p_BILL_CYCLE_ID IN NUMBER
	) RETURN DATE IS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_INTERVAL CHAR(1);

BEGIN

	v_INTERVAL := UPPER(SUBSTR(p_INTERVAL,1,1));
	IF v_INTERVAL = 'H' THEN
	    RETURN ADD_HOURS_TO_DATE(p_DATE, 1);
	ELSIF v_INTERVAL = 'D' THEN
	    RETURN TRUNC(p_DATE);
	ELSIF v_INTERVAL = 'W' THEN
	    RETURN TRUNC(p_DATE) + 6;
	ELSIF v_INTERVAL = 'M' THEN
	    RETURN LAST_DAY(TRUNC(p_DATE));
	ELSIF v_INTERVAL = 'Y' THEN
	    RETURN LAST_DAY(ADD_MONTHS(TRUNC(p_DATE), 12));
	ELSIF v_INTERVAL = 'C' THEN
		GET_BILL_CYCLE_PERIOD(p_BILL_CYCLE_ID, TRUNC(p_DATE,'MONTH'), v_BEGIN_DATE, v_END_DATE);
		RETURN v_END_DATE;
	END IF;

	RETURN NULL;

END GET_NEXT_DATE_FOR_INTERVAL;
---------------------------------------------------------------------------------------------------
FUNCTION GET_INITIAL_DATE_FOR_INTERVAL
    (
	p_DATE IN DATE,
	p_INTERVAL IN VARCHAR,
	p_BILL_CYCLE_ID IN NUMBER
	) RETURN DATE IS

v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

	IF UPPER(SUBSTR(p_INTERVAL,1,1)) = 'C' THEN
		GET_BILL_CYCLE_PERIOD(p_BILL_CYCLE_ID, TRUNC(p_DATE,'MONTH'), v_BEGIN_DATE, v_END_DATE);
		RETURN v_BEGIN_DATE;
	ELSE
		RETURN TRUNC(p_DATE);
	END IF;

END GET_INITIAL_DATE_FOR_INTERVAL;
---------------------------------------------------------------------------------------------------
FUNCTION GET_PROJECTION_ID
    (
	p_CALENDAR_ID IN NUMBER,
	p_PROJECTION_TYPE IN VARCHAR,
	p_TEMPLATE_ID IN NUMBER,
	p_AS_OF_DATE IN DATE
	) RETURN NUMBER IS

v_PROJECTION_ID NUMBER;

BEGIN

	SELECT PROJECTION_ID
	INTO v_PROJECTION_ID
	FROM CALENDAR_PROJECTION A
	WHERE CALENDAR_ID = p_CALENDAR_ID
		AND PROJECTION_TYPE = p_PROJECTION_TYPE
		AND TEMPLATE_ID = p_TEMPLATE_ID
		AND AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM CALENDAR_PROJECTION
			WHERE CALENDAR_ID = A.CALENDAR_ID
				AND PROJECTION_TYPE = A.PROJECTION_TYPE
				AND TEMPLATE_ID = A.TEMPLATE_ID
				AND AS_OF_DATE <= p_AS_OF_DATE);

	RETURN v_PROJECTION_ID;

EXCEPTION
		WHEN OTHERS THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN CONSTANTS.NOT_ASSIGNED;

END GET_PROJECTION_ID;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_TOU_PERIODS
	(
	p_TEMPLATE_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_TOU_PERIODS IN OUT NOCOPY TOU_TABLE
	) AS

CURSOR c_PERIODS IS
	SELECT TDTP.PERIOD_ID, TDT.DAY_NAME, (TDTP.TIME_STAMP / (1/24)) AS HOUR
	FROM TEMPLATE_DATES TD,
		TEMPLATE_DAY_TYPE_PERIOD TDTP,
		TEMPLATE_DAY_TYPE TDT
	WHERE TD.TEMPLATE_ID = p_TEMPLATE_ID
		AND TD.HOLIDAY_SET_ID = CONSTANTS.NOT_ASSIGNED
		AND TD.LOCAL_DATE = p_SERVICE_DATE
		AND TD.TIME_ZONE = GA.LOCAL_TIME_ZONE
		AND TDTP.DAY_TYPE_ID = TD.DAY_TYPE_ID
		AND TDTP.MINIMUM_INTERVAL_NUMBER >= CONSTANTS.INTERVAL_NUMBER_HOUR
		AND TDT.DAY_TYPE_ID = TD.DAY_TYPE_ID;

BEGIN

	SP.CHECK_TEMPLATE_DATES(p_TEMPLATE_ID,
							CONSTANTS.NOT_ASSIGNED,
							GA.LOCAL_TIME_ZONE,
							p_SERVICE_DATE,
							p_SERVICE_DATE);

	p_TOU_PERIODS.DELETE;
	FOR v_REC IN c_PERIODS LOOP
		p_TOU_PERIODS.EXTEND;
		p_TOU_PERIODS(p_TOU_PERIODS.LAST) := TOU_TYPE(v_REC.PERIOD_ID, 
													v_REC.HOUR, 
													v_REC.DAY_NAME);
	END LOOP;

END GET_TOU_PERIODS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SYSTEM_EVENTS
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_EVENTS IN OUT NOCOPY EVENT_TABLE
	) AS

BEGIN

	SELECT EVENT_TYPE(EVENT_ID, BEGIN_DATE, NVL(END_DATE, p_END_DATE))
	BULK COLLECT INTO p_EVENTS
	FROM SYSTEM_EVENT_OCCURRENCE
	WHERE EVENT_ID > 2
		AND BEGIN_DATE <= p_END_DATE
		AND NVL(END_DATE, p_END_DATE) >= p_BEGIN_DATE;

END GET_SYSTEM_EVENTS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_MARKET_PRICE_FORMULA
    (
	p_COMPONENT_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_RATE_ADDER OUT NUMBER,
	p_RATE_MULTIPLIER OUT NUMBER
	) AS

BEGIN

	SELECT NVL(RATE_ADDER, 0), NVL(RATE_MULTIPLIER, 1.0)
	INTO p_RATE_ADDER, p_RATE_MULTIPLIER
	FROM COMPONENT_MARKET_PRICE
	WHERE COMPONENT_ID = p_COMPONENT_ID
        AND SUB_COMPONENT_TYPE = g_NO_SUB_TYPE
        AND SUB_COMPONENT_ID = CONSTANTS.NOT_ASSIGNED
        AND TRUNC(p_SERVICE_DATE) BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE)
		AND ROWNUM = 1;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		p_RATE_ADDER := 0;
		p_RATE_MULTIPLIER := 1;

END GET_MARKET_PRICE_FORMULA;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_MARKET_PRICE_FORMULA
    (
	p_COMPONENT_ID IN NUMBER,
	p_ACCOUNT_SERVICE_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_RATE_ADDER OUT NUMBER,
	p_RATE_MULTIPLIER OUT NUMBER
	) AS

BEGIN

	SELECT NVL(RATE_ADDER, 0), NVL(RATE_MULTIPLIER, 1.0)
	INTO p_RATE_ADDER, p_RATE_MULTIPLIER
	FROM COMPONENT_MARKET_PRICE B
	WHERE COMPONENT_ID = p_COMPONENT_ID
        AND SUB_COMPONENT_TYPE = 'ACCOUNT_SERVICE'
        AND SUB_COMPONENT_ID = p_ACCOUNT_SERVICE_ID
        AND TRUNC(p_SERVICE_DATE) BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE)
		AND ROWNUM = 1;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		p_RATE_ADDER := 0;
		p_RATE_MULTIPLIER := 1;

END GET_MARKET_PRICE_FORMULA;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_MARKET_FORWARD_PRICE
    (
	p_MARKET_PRICE_ID NUMBER,
	p_FORWARDS IN OUT NOCOPY FORWARD_TABLE
	) AS

-- Get Market Prices and convert from $/MWH to $/KWH.

BEGIN

	SELECT FORWARD_TYPE(A.ENTITY_ID, A.DAY, A.PERIOD_ID, A.FORWARD)
	BULK COLLECT INTO p_FORWARDS
	FROM TABLE(CAST(g_FORWARDS AS FORWARD_TABLE)) A
	WHERE A.ENTITY_ID = p_MARKET_PRICE_ID;

END GET_MARKET_FORWARD_PRICE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_MARKET_PRICE
    (
	p_MARKET_PRICE_ID NUMBER,
	p_PRICE_CODE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_MODEL_ID IN NUMBER,
	p_MARKET_PRICE_TABLE IN OUT GA.NUMBER_TABLE
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_INDEX BINARY_INTEGER;
v_INTERVAL_DIVISOR NUMBER;
v_MARKET_PRICE_INTERVAL NUMBER(2);
v_UNIT_DIVISOR NUMBER(4);

-- Get Market Prices and convert from $/MWH to $/KWH.

CURSOR c_MARKET_PRICE IS
	SELECT PRICE_DATE, PRICE / v_UNIT_DIVISOR "PRICE"
	FROM MARKET_PRICE_VALUE A
	WHERE MARKET_PRICE_ID = p_MARKET_PRICE_ID
		AND PRICE_CODE = p_PRICE_CODE
		AND PRICE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND AS_OF_DATE =
			(SELECT MAX(AS_OF_DATE)
			FROM MARKET_PRICE_VALUE
			WHERE MARKET_PRICE_ID = A.MARKET_PRICE_ID
				AND PRICE_CODE = A.PRICE_CODE
				AND PRICE_DATE = A.PRICE_DATE
				AND AS_OF_DATE <= p_AS_OF_DATE)
	ORDER BY PRICE_DATE;

BEGIN

	IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
		LOGS.LOG_DEBUG_DETAIL('GET_MARKET_PRICE MARKET_PRICE_ID=' || TO_CHAR(p_MARKET_PRICE_ID) || ', PRICE_CODE=' || p_PRICE_CODE || ', BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE) || ', END_DATE=' || TO_CHAR(p_END_DATE));
	END IF;

	p_MARKET_PRICE_TABLE.DELETE;

    -- If there are no dates then no records will be selected - wjc 5/22/03.
	IF p_BEGIN_DATE IS NULL OR p_END_DATE IS NULL THEN
		RETURN;
	END IF;

	SELECT DECODE(UPPER(SUBSTR(MARKET_PRICE_INTERVAL,1,2)), '15', 96, '30', 48, 'HO', 24, 'DA', 1, 'MO', 0, 1) INTO v_MARKET_PRICE_INTERVAL FROM MARKET_PRICE WHERE MARKET_PRICE_ID = p_MARKET_PRICE_ID;
	IF v_MARKET_PRICE_INTERVAL = 0 THEN
		v_MARKET_PRICE_INTERVAL := 1;
		UT.CUT_DAY_INTERVAL_RANGE(p_MODEL_ID, TRUNC(p_BEGIN_DATE,'MONTH'), TRUNC(p_BEGIN_DATE,'MONTH'), LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	ELSE
		UT.CUT_DAY_INTERVAL_RANGE(p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	END IF;

	v_INTERVAL_DIVISOR := INTERVAL_DIVISOR(v_MARKET_PRICE_INTERVAL);
	SELECT DECODE(p_MODEL_ID, GA.ELECTRIC_MODEL, 1000, 1) INTO v_UNIT_DIVISOR FROM DUAL;

    -- Use NVL here to avoid Numeric or Value error if dates are Null - wjc 5/22/03.
	FOR v_INDEX IN 0..NVL(TRUNC((v_END_DATE - v_BEGIN_DATE) / v_INTERVAL_DIVISOR),0) LOOP
		p_MARKET_PRICE_TABLE(v_INDEX) := 0;
	END LOOP;

	FOR v_MARKET_PRICE IN  c_MARKET_PRICE LOOP
		v_INDEX := ROUND((v_MARKET_PRICE.PRICE_DATE - v_BEGIN_DATE) / v_INTERVAL_DIVISOR);
		p_MARKET_PRICE_TABLE(v_INDEX) := v_MARKET_PRICE.PRICE;
	END LOOP;

END GET_MARKET_PRICE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_MARKET_PRICE
    (
	p_MARKET_PRICE_ID NUMBER,
	p_PRICE_CODE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_MARKET_PRICE_TABLE IN OUT GA.NUMBER_TABLE
	) AS

BEGIN

	GET_MARKET_PRICE(p_MARKET_PRICE_ID, p_PRICE_CODE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, GA.DEFAULT_MODEL, p_MARKET_PRICE_TABLE);

END GET_MARKET_PRICE;
---------------------------------------------------------------------------------------------------
FUNCTION GET_MARKET_PRICE
	(
	p_MARKET_PRICE_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_PRICE_CODE IN CHAR DEFAULT 'A'
	) RETURN NUMBER IS

v_MARKET_PRICE GA.NUMBER_TABLE;

BEGIN

	GET_MARKET_PRICE(p_MARKET_PRICE_ID, p_PRICE_CODE, p_SERVICE_DATE, p_SERVICE_DATE, SYSDATE, GA.DEFAULT_MODEL, v_MARKET_PRICE);

	IF v_MARKET_PRICE.COUNT > 0 THEN
		RETURN v_MARKET_PRICE(v_MARKET_PRICE.FIRST);
	ELSE
		RETURN CONSTANTS.NOT_ASSIGNED;
	END IF;

END GET_MARKET_PRICE;
---------------------------------------------------------------------------------------------------
FUNCTION GET_COMPONENT_MARKET_RATE
	(
	p_COMPONENT_ID IN NUMBER,
	p_MARKET_PRICE_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
    p_MARKET_PRICE_TABLE IN OUT GA.NUMBER_TABLE,
	p_PRICE_CODE IN CHAR DEFAULT 'A'
	) RETURN NUMBER IS

v_RATE_ADDER COMPONENT_MARKET_PRICE.RATE_ADDER%TYPE;
v_RATE_MULTIPLIER COMPONENT_MARKET_PRICE.RATE_MULTIPLIER%TYPE;

BEGIN

	GET_MARKET_PRICE_FORMULA(p_COMPONENT_ID, p_SERVICE_DATE, v_RATE_ADDER, v_RATE_MULTIPLIER);
	GET_MARKET_PRICE(p_MARKET_PRICE_ID, p_PRICE_CODE, p_SERVICE_DATE, p_SERVICE_DATE, SYSDATE, GA.DEFAULT_MODEL, p_MARKET_PRICE_TABLE);

	IF p_MARKET_PRICE_TABLE.COUNT > 0 THEN
		RETURN (p_MARKET_PRICE_TABLE(p_MARKET_PRICE_TABLE.FIRST) * v_RATE_MULTIPLIER + v_RATE_ADDER);
	ELSE
		RETURN CONSTANTS.NOT_ASSIGNED;
	END IF;

END GET_COMPONENT_MARKET_RATE;
---------------------------------------------------------------------------------------------------
FUNCTION GET_COMPONENT_MARKET_RATE
	(
	p_COMPONENT_ID IN NUMBER,
	p_MARKET_PRICE_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_PRICE_CODE IN CHAR DEFAULT 'A'
	) RETURN NUMBER IS

v_MARKET_PRICE_TABLE GA.NUMBER_TABLE;
v_RATE_ADDER COMPONENT_MARKET_PRICE.RATE_ADDER%TYPE;
v_RATE_MULTIPLIER COMPONENT_MARKET_PRICE.RATE_MULTIPLIER%TYPE;

BEGIN

	GET_MARKET_PRICE_FORMULA(p_COMPONENT_ID, p_SERVICE_DATE, v_RATE_ADDER, v_RATE_MULTIPLIER);
	GET_MARKET_PRICE(p_MARKET_PRICE_ID, p_PRICE_CODE, p_SERVICE_DATE, p_SERVICE_DATE, SYSDATE, GA.DEFAULT_MODEL, v_MARKET_PRICE_TABLE);

	IF v_MARKET_PRICE_TABLE.COUNT > 0 THEN
		RETURN (v_MARKET_PRICE_TABLE(v_MARKET_PRICE_TABLE.FIRST) * v_RATE_MULTIPLIER + v_RATE_ADDER);
	ELSE
		RETURN CONSTANTS.NOT_ASSIGNED;
	END IF;

END GET_COMPONENT_MARKET_RATE;
---------------------------------------------------------------------------------------------------
FUNCTION GET_COMPONENT_MARKET_RATE
    (
	p_COMPONENT_ID IN NUMBER,
	p_ACCOUNT_SERVICE_ID IN NUMBER,
	p_MARKET_PRICE_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_PRICE_CODE IN CHAR DEFAULT 'A'
	) RETURN NUMBER IS

v_MARKET_PRICE_TABLE GA.NUMBER_TABLE;
v_RATE_ADDER COMPONENT_MARKET_PRICE.RATE_ADDER%TYPE;
v_RATE_MULTIPLIER COMPONENT_MARKET_PRICE.RATE_MULTIPLIER%TYPE;

BEGIN

	GET_MARKET_PRICE_FORMULA(p_COMPONENT_ID, p_ACCOUNT_SERVICE_ID, p_SERVICE_DATE, v_RATE_ADDER, v_RATE_MULTIPLIER);

	GET_MARKET_PRICE(p_MARKET_PRICE_ID, p_PRICE_CODE, p_SERVICE_DATE, p_SERVICE_DATE, SYSDATE, GA.DEFAULT_MODEL, v_MARKET_PRICE_TABLE);

	IF v_MARKET_PRICE_TABLE.COUNT > 0 THEN
		RETURN (v_MARKET_PRICE_TABLE(v_MARKET_PRICE_TABLE.FIRST) * v_RATE_MULTIPLIER + v_RATE_ADDER);
	ELSE
		RETURN CONSTANTS.NOT_ASSIGNED;
	END IF;

END GET_COMPONENT_MARKET_RATE;
---------------------------------------------------------------------------------------------------
FUNCTION GET_COMPONENT_BAND
	(
	p_IMBALANCE_ID IN NUMBER,
	p_BAND_TYPE IN VARCHAR
	) RETURN COMPONENT_BAND_TABLE IS

CURSOR c_COMPONENT_BAND IS
	SELECT *
	FROM COMPONENT_IMBALANCE_BAND A
	WHERE IMBALANCE_ID = p_IMBALANCE_ID
		AND UPPER(SUBSTR(A.BAND_TYPE,1,1)) = UPPER(SUBSTR(p_BAND_TYPE,1,1))
	ORDER BY BAND_NUMBER;

v_BAND COMPONENT_BAND_TABLE;

BEGIN

	FOR v_COMPONENT_BAND IN c_COMPONENT_BAND LOOP
		v_BAND(v_COMPONENT_BAND.BAND_NUMBER) := v_COMPONENT_BAND;
	END LOOP;

	RETURN v_BAND;

END GET_COMPONENT_BAND;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_COMPONENT_BAND_LIMITS
	(
	p_DETERMINANT IN NUMBER,
	p_IS_PERCENT IN BOOLEAN,
	p_INDEX IN BINARY_INTEGER,
	p_BAND IN COMPONENT_BAND_TABLE,
	p_MINIMUM OUT NUMBER,
	p_MAXIMUM OUT NUMBER
	) AS

v_THRESHOLD NUMBER;
v_NEXT_INDEX BINARY_INTEGER;

BEGIN

	p_MINIMUM := NVL(p_BAND(p_INDEX).BAND_MINIMUM, 0);
	v_THRESHOLD := ABS(NVL(p_BAND(p_INDEX).BAND_THRESHOLD, 0));
	IF p_IS_PERCENT THEN
		v_THRESHOLD := p_DETERMINANT * (v_THRESHOLD / 100.0);
	END IF;
	p_MINIMUM := GREATEST(v_THRESHOLD, p_MINIMUM);

	IF p_INDEX = p_BAND.LAST THEN
		p_MAXIMUM := 999999999;
	ELSE
		v_NEXT_INDEX := p_BAND.NEXT(p_INDEX);
		v_THRESHOLD := ABS(NVL(p_BAND(v_NEXT_INDEX).BAND_THRESHOLD, 0));
		IF p_IS_PERCENT THEN
			v_THRESHOLD := p_DETERMINANT * (v_THRESHOLD / 100.0);
		END IF;
		p_MAXIMUM := v_THRESHOLD;
	END IF;

	p_MAXIMUM := GREATEST(p_MAXIMUM, p_MINIMUM);

END GET_COMPONENT_BAND_LIMITS;
---------------------------------------------------------------------------------------------------
PROCEDURE APPLY_SWING_BASE_COMPONENT
	(
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_ACCOUNT_SERVICE_ID IN NUMBER,
	p_CUSTOMER_ID IN NUMBER,
	p_QUANTITY IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_CHARGE_COMPONENTS IN OUT NOCOPY CHARGE_COMPONENT_TABLE
	) AS

v_EFFECTIVE_DATE DATE := p_SERVICE_DATE;
v_CHARGE_TYPE CHAR(1) := 'C';
v_QUANTITY NUMBER := p_QUANTITY;
v_RATE NUMBER(14,6);
v_AMOUNT NUMBER(14,6);
v_FACTOR NUMBER(14,6);
v_BILL_CODE CHAR(1);
v_RATE_STRUCTURE VARCHAR(16) := UPPER(LTRIM(RTRIM(p_COMPONENT.RATE_STRUCTURE)));
v_CUSTOM_CHARGE BOOLEAN := p_COMPONENT.IS_CUSTOM_CHARGE = 1;

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('APPLY_SWING_BASE_COMPONENT');
	    LOGS.LOG_DEBUG('QUANTITY=' || TO_CHAR(p_QUANTITY));
	    LOGS.LOG_DEBUG('SERVICE_DATE=' || UT.TRACE_DATE(p_SERVICE_DATE));
	    LOGS.LOG_DEBUG('RATE_STRUCTURE=' || v_RATE_STRUCTURE);
	END IF;

	IF v_RATE_STRUCTURE = 'FLAT' THEN
		IF v_CUSTOM_CHARGE THEN
			v_RATE := GET_COMPONENT_FLAT_RATE(p_COMPONENT.COMPONENT_ID, p_ACCOUNT_SERVICE_ID, v_QUANTITY, v_EFFECTIVE_DATE);
		ELSE
			v_RATE := GET_COMPONENT_FLAT_RATE(p_COMPONENT.COMPONENT_ID, v_QUANTITY, v_EFFECTIVE_DATE);
		END IF;
	ELSIF v_RATE_STRUCTURE = 'BLOCK' THEN
		IF v_CUSTOM_CHARGE THEN
			v_RATE := GET_COMPONENT_BLOCK_RATE(p_COMPONENT.COMPONENT_ID, p_ACCOUNT_SERVICE_ID, v_QUANTITY, v_EFFECTIVE_DATE);
		ELSE
			v_RATE := GET_COMPONENT_BLOCK_RATE(p_COMPONENT.COMPONENT_ID, v_QUANTITY, v_EFFECTIVE_DATE);
		END IF;
	ELSIF v_RATE_STRUCTURE = 'TIERED' THEN
		IF v_CUSTOM_CHARGE THEN
			v_RATE := GET_COMPONENT_TIERED_RATE(p_COMPONENT.COMPONENT_ID, p_ACCOUNT_SERVICE_ID, v_QUANTITY, v_EFFECTIVE_DATE);
		ELSE
			v_RATE := GET_COMPONENT_TIERED_RATE(p_COMPONENT.COMPONENT_ID, v_QUANTITY, v_EFFECTIVE_DATE);
		END IF;
	ELSIF v_RATE_STRUCTURE = 'MARKET' THEN
		IF v_CUSTOM_CHARGE THEN
			v_RATE := GET_COMPONENT_MARKET_RATE(p_COMPONENT.COMPONENT_ID, p_ACCOUNT_SERVICE_ID, p_COMPONENT.MARKET_PRICE_ID, v_EFFECTIVE_DATE);
		ELSE
			v_RATE := GET_COMPONENT_MARKET_RATE(p_COMPONENT.COMPONENT_ID, p_COMPONENT.MARKET_PRICE_ID, v_EFFECTIVE_DATE);
		END IF;
	ELSE
		v_RATE := 0;
	END IF;

	v_FACTOR := GET_COMPONENT_FACTOR(p_COMPONENT.COMPONENT_ID, v_EFFECTIVE_DATE);
	v_AMOUNT := v_QUANTITY * v_RATE * v_FACTOR;
	p_CHARGE_COMPONENTS.EXTEND;
	p_CHARGE_COMPONENTS(p_CHARGE_COMPONENTS.LAST) := CHARGE_COMPONENT_TYPE(p_PRODUCT_ID, p_COMPONENT.COMPONENT_ID, p_ACCOUNT_SERVICE_ID, p_CUSTOMER_ID, CONSTANTS.NOT_ASSIGNED, v_CHARGE_TYPE, v_EFFECTIVE_DATE, v_EFFECTIVE_DATE, v_EFFECTIVE_DATE, v_QUANTITY, v_RATE, v_AMOUNT, v_FACTOR, CONSTANTS.NOT_ASSIGNED, CONSTANTS.NOT_ASSIGNED, CONSTANTS.NOT_ASSIGNED, v_BILL_CODE);

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG(TO_CHAR(v_EFFECTIVE_DATE) || ',' || TO_CHAR(v_EFFECTIVE_DATE) || ',' || TO_CHAR(v_QUANTITY) || ',' || TO_CHAR(v_RATE) || ',' || TO_CHAR(v_AMOUNT) || ',' || TO_CHAR(v_FACTOR) || ',' || v_BILL_CODE);
	END IF;

END APPLY_SWING_BASE_COMPONENT;
---------------------------------------------------------------------------------------------------
PROCEDURE APPLY_IMBALANCE_CHARGE_BAND
	(
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_ACCOUNT_SERVICE_ID IN NUMBER,
	p_CUSTOMER_ID IN NUMBER,
	p_PLANNED IN NUMBER,
	p_ACTUAL IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_IMBALANCE_FLAG IN VARCHAR,
	p_MARKET_PRICE IN NUMBER,
	p_BAND IN COMPONENT_BAND_TABLE,
	p_COMPONENT_IMBALANCE IN COMPONENT_IMBALANCE%ROWTYPE,
	p_CHARGE_COMPONENTS IN OUT NOCOPY CHARGE_COMPONENT_TABLE
	) AS

v_BASE_QUANTITY NUMBER := 0;
v_MINIMUM NUMBER := 0;
v_MAXIMUM NUMBER := 0;
v_BAND_NUMBER NUMBER := 1;
v_IMBALANCE NUMBER := 0;
v_CHARGE NUMBER := 0;
v_QUANTITY NUMBER := 0;
v_RATE NUMBER;
v_AMOUNT NUMBER;
v_MULTIPLIER NUMBER := 1;
v_IS_PRORATE BOOLEAN;
v_IS_PERCENT BOOLEAN;
v_INDEX BINARY_INTEGER;
v_COMPONENT COMPONENT%ROWTYPE;
v_BASE_COMPONENT_ID NUMBER;

BEGIN

	v_IS_PRORATE := NVL(p_COMPONENT_IMBALANCE.IS_PRORATE, 0) = 1;
	v_IS_PERCENT := NVL(p_COMPONENT_IMBALANCE.IS_PERCENT,0) = 1;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('APPLY_IMBALANCE_CHARGE_BAND');
		LOGS.LOG_DEBUG('PRODUCT_ID=' || TO_CHAR(p_PRODUCT_ID));
		LOGS.LOG_DEBUG('COMPONENT_ID=' || TO_CHAR(p_COMPONENT_ID));
		LOGS.LOG_DEBUG('ACCOUNT_SERVICE_ID=' || TO_CHAR(p_ACCOUNT_SERVICE_ID));
		LOGS.LOG_DEBUG('PLANNED=' || TO_CHAR(p_PLANNED));
		LOGS.LOG_DEBUG('ACTUAL=' || TO_CHAR(p_ACTUAL));
		LOGS.LOG_DEBUG('SERVICE_DATE=' || UT.TRACE_DATE(p_SERVICE_DATE));
		LOGS.LOG_DEBUG('IMBALANCE_FLAG=' || p_IMBALANCE_FLAG);
		LOGS.LOG_DEBUG('MARKET_PRICE=' || TO_CHAR(p_MARKET_PRICE));
		LOGS.LOG_DEBUG('BAND.COUNT=' || TO_CHAR(p_BAND.COUNT));
		LOGS.LOG_DEBUG('IS_PRORATE=' || UT.TRACE_BOOLEAN(v_IS_PRORATE));
		LOGS.LOG_DEBUG('IS_PERCENT=' || UT.TRACE_BOOLEAN(v_IS_PERCENT));
	END IF;

	IF p_BAND.COUNT > 0 THEN
		v_INDEX := p_BAND.FIRST;
		WHILE v_INDEX <= p_BAND.LAST LOOP
			GET_COMPONENT_BAND_LIMITS(p_PLANNED, v_IS_PERCENT, v_INDEX, p_BAND, v_MINIMUM, v_MAXIMUM);
			IF v_INDEX = p_BAND.FIRST THEN
				v_BASE_QUANTITY := LEAST(p_ACTUAL, v_MINIMUM);
				v_IMBALANCE := ROUND(p_ACTUAL - v_BASE_QUANTITY,3);
			END IF;
			IF (SUBSTR(p_IMBALANCE_FLAG,1,1) = 'U' AND v_IMBALANCE >= v_MINIMUM) OR (SUBSTR(p_IMBALANCE_FLAG,1,1) = 'O' AND v_IMBALANCE <= v_MINIMUM)THEN
				v_CHARGE := NVL(p_BAND(v_INDEX).BAND_CHARGE, 0);
				v_QUANTITY := LEAST(v_IMBALANCE, v_MAXIMUM);
				v_MULTIPLIER := NVL(p_BAND(v_INDEX).BAND_MULTIPLIER, 1);
				v_RATE := GREATEST(p_MARKET_PRICE * v_MULTIPLIER, v_CHARGE);
				v_AMOUNT := v_QUANTITY * v_RATE;

				IF LOGS.IS_DEBUG_ENABLED THEN
					LOGS.LOG_DEBUG(TO_CHAR(v_BAND_NUMBER) || ',' || TO_CHAR(v_IMBALANCE) || ',' || TO_CHAR(v_MINIMUM) || ',' || TO_CHAR(v_MAXIMUM) || ',' || TO_CHAR(v_QUANTITY) || ',' || TO_CHAR(v_RATE) || ',' || TO_CHAR(v_MULTIPLIER) || ',' || TO_CHAR(v_AMOUNT));
				END IF;

				IF v_IS_PRORATE OR (NOT v_IS_PRORATE AND v_QUANTITY = v_IMBALANCE) THEN
					p_CHARGE_COMPONENTS.EXTEND;
					p_CHARGE_COMPONENTS(p_CHARGE_COMPONENTS.LAST) := CHARGE_COMPONENT_TYPE(p_PRODUCT_ID, p_COMPONENT_ID, p_ACCOUNT_SERVICE_ID, p_CUSTOMER_ID, CONSTANTS.NOT_ASSIGNED, 'S', p_SERVICE_DATE, p_SERVICE_DATE, p_SERVICE_DATE, v_QUANTITY, v_RATE, v_AMOUNT, v_MULTIPLIER, p_PLANNED, p_ACTUAL, v_BAND_NUMBER, NULL);
					IF (NOT v_IS_PRORATE AND v_QUANTITY = v_IMBALANCE) THEN
						EXIT;
					END IF;
				END IF;
			END IF;

			v_INDEX := p_BAND.NEXT(v_INDEX);
			v_BAND_NUMBER := v_BAND_NUMBER + 1;
			IF v_IS_PRORATE THEN
				v_IMBALANCE := GREATEST(v_IMBALANCE - v_QUANTITY, 0);
			END IF;
		END LOOP;

-- Apply the Base Quantity Charge of the SWING Component.
		SELECT BASE_COMPONENT_ID INTO v_BASE_COMPONENT_ID
	        FROM COMPONENT
	        WHERE COMPONENT_ID = p_COMPONENT_ID;
		v_COMPONENT := GET_COMPONENT(v_BASE_COMPONENT_ID);
		APPLY_SWING_BASE_COMPONENT(p_PRODUCT_ID, v_COMPONENT, p_ACCOUNT_SERVICE_ID, p_CUSTOMER_ID, v_BASE_QUANTITY, p_SERVICE_DATE, p_CHARGE_COMPONENTS);

	END IF;

END APPLY_IMBALANCE_CHARGE_BAND;
---------------------------------------------------------------------------------------------------
PROCEDURE APPLY_IMBALANCE_CHARGE
	(
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_ACCOUNT_SERVICE_ID IN NUMBER,
	p_CUSTOMER_ID IN NUMBER,
	p_PLANNED IN NUMBER,
	p_ACTUAL IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_COMPONENT_IMBALANCE IN COMPONENT_IMBALANCE%ROWTYPE,
	p_CHARGE_COMPONENTS IN OUT NOCOPY CHARGE_COMPONENT_TABLE
	) AS

v_PRICE MARKET_PRICE_VALUE.PRICE%TYPE;
v_BAND COMPONENT_BAND_TABLE;
v_IMBALANCE_FLAG VARCHAR(16);

BEGIN

-- Planned less than Actual results in an Under-Supply Position.
	IF p_PLANNED <= p_ACTUAL THEN
		v_PRICE := GET_MARKET_PRICE(p_COMPONENT_IMBALANCE.UNDER_UNDER_PRICE_ID, p_SERVICE_DATE);
		v_BAND := GET_COMPONENT_BAND(p_COMPONENT_IMBALANCE.IMBALANCE_ID, 'UNDER');
		v_IMBALANCE_FLAG := 'UNDER_SUPPLY';
-- Planned greater than Actual results in an Over-Supply Position.
	ELSE
		v_PRICE := GET_MARKET_PRICE(p_COMPONENT_IMBALANCE.UNDER_OVER_PRICE_ID, p_SERVICE_DATE);
		v_BAND := GET_COMPONENT_BAND(p_COMPONENT_IMBALANCE.IMBALANCE_ID, 'OVER');
		v_IMBALANCE_FLAG := 'OVER_SUPPLY';
	END IF;

	APPLY_IMBALANCE_CHARGE_BAND(p_PRODUCT_ID, p_COMPONENT_ID, p_ACCOUNT_SERVICE_ID, p_CUSTOMER_ID, p_PLANNED, p_ACTUAL, p_SERVICE_DATE, v_IMBALANCE_FLAG, v_PRICE, v_BAND, p_COMPONENT_IMBALANCE, p_CHARGE_COMPONENTS);

END APPLY_IMBALANCE_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE APPLY_COMPONENT_IMBALANCE
	(
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_PLANNED IN NUMBER,
	p_ACTUAL IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_CHARGE_COMPONENTS IN OUT NOCOPY CHARGE_COMPONENT_TABLE
	) AS

v_COMPONENT_IMBALANCE COMPONENT_IMBALANCE%ROWTYPE;
v_IMBALANCE_TYPE COMPONENT.IMBALANCE_TYPE%TYPE;

BEGIN

	SELECT IMBALANCE_TYPE INTO v_IMBALANCE_TYPE
    FROM COMPONENT
    	WHERE COMPONENT_ID = p_COMPONENT_ID;

	SELECT * INTO v_COMPONENT_IMBALANCE
	FROM COMPONENT_IMBALANCE
	WHERE COMPONENT_ID = p_COMPONENT_ID
		AND SUB_COMPONENT_TYPE = g_NO_SUB_TYPE
        AND SUB_COMPONENT_ID = CONSTANTS.NOT_ASSIGNED
		AND TRUNC(p_SERVICE_DATE) BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE)
		AND ROWNUM = 1;

	IF UPPER(v_IMBALANCE_TYPE) = 'SWING' THEN
		APPLY_IMBALANCE_CHARGE(p_PRODUCT_ID, p_COMPONENT_ID, CONSTANTS.NOT_ASSIGNED, CONSTANTS.NOT_ASSIGNED, p_PLANNED, p_ACTUAL, p_SERVICE_DATE, v_COMPONENT_IMBALANCE, p_CHARGE_COMPONENTS);
	END IF;

END APPLY_COMPONENT_IMBALANCE;
---------------------------------------------------------------------------------------------------
PROCEDURE APPLY_COMPONENT_IMBALANCE
    (
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_ACCOUNT_SERVICE_ID IN NUMBER,
	p_PLANNED IN NUMBER,
	p_ACTUAL IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_CHARGE_COMPONENTS IN OUT NOCOPY CHARGE_COMPONENT_TABLE
	) AS

v_COMPONENT_IMBALANCE COMPONENT_IMBALANCE%ROWTYPE;
v_IMBALANCE_TYPE COMPONENT.IMBALANCE_TYPE%TYPE;

BEGIN

	SELECT IMBALANCE_TYPE INTO v_IMBALANCE_TYPE
    FROM COMPONENT
    	WHERE COMPONENT_ID = p_COMPONENT_ID;

	SELECT * INTO v_COMPONENT_IMBALANCE
	FROM COMPONENT_IMBALANCE
	WHERE COMPONENT_ID = p_COMPONENT_ID
		AND SUB_COMPONENT_TYPE = 'ACCOUNT_SERVICE'
        AND SUB_COMPONENT_ID = p_ACCOUNT_SERVICE_ID
		AND TRUNC(p_SERVICE_DATE) BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE)
		AND ROWNUM = 1;

	IF UPPER(v_IMBALANCE_TYPE) = 'SWING' THEN
		APPLY_IMBALANCE_CHARGE(p_PRODUCT_ID, p_COMPONENT_ID, p_ACCOUNT_SERVICE_ID, CONSTANTS.NOT_ASSIGNED, p_PLANNED, p_ACTUAL, p_SERVICE_DATE, v_COMPONENT_IMBALANCE, p_CHARGE_COMPONENTS);
	END IF;

END APPLY_COMPONENT_IMBALANCE;
---------------------------------------------------------------------------------------------------
FUNCTION GET_COMPOSITE_COMPONENT_ID
    (
	p_COMPONENT_ID IN NUMBER,
	p_QUANTITY IN NUMBER,
	p_SERVICE_DATE IN DATE
	) RETURN NUMBER IS

CURSOR c_COMPONENT IS
	SELECT COMPOSITE_COMPONENT_ID "COMPONENT_ID", NVL(BLOCK_MAX, 999999999) "BLOCK_MAX"
	FROM COMPONENT_COMPOSITE
	WHERE COMPONENT_ID = p_COMPONENT_ID
    	AND SUB_COMPONENT_TYPE = g_NO_SUB_TYPE
        AND SUB_COMPONENT_ID = CONSTANTS.NOT_ASSIGNED
        AND TRUNC(p_SERVICE_DATE) BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE)
	ORDER BY NVL(BLOCK_MAX, 999999999);

v_COMPONENT_ID NUMBER(9) := CONSTANTS.NOT_ASSIGNED;

BEGIN

	FOR v_COMPONENT IN c_COMPONENT LOOP
		IF p_QUANTITY <= v_COMPONENT.BLOCK_MAX THEN
			v_COMPONENT_ID := v_COMPONENT.COMPONENT_ID;
			EXIT;
		END IF;
	END LOOP;

	RETURN v_COMPONENT_ID;

END GET_COMPOSITE_COMPONENT_ID;
---------------------------------------------------------------------------------------------------
FUNCTION GET_COMPOSITE_COMPONENT_RATE
    (
	p_COMPONENT_ID IN NUMBER,
	p_CHARGE_TYPE IN CHAR,
	p_PERIOD_ID IN NUMBER,
	p_ENERGY IN OUT NUMBER,
	p_DEMAND IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	) RETURN NUMBER IS

v_COMPONENT_ID NUMBER(9);
v_COMPONENT COMPONENT%ROWTYPE;
v_CHARGE_TYPE CHAR(1);
v_QUANTITY NUMBER(14,6);
v_RATE NUMBER(14,6) := 0.0;
v_RATE_STRUCTURE VARCHAR(16);
v_FACTOR NUMBER(14,9) := 1.0;

BEGIN

	SELECT DECODE(p_CHARGE_TYPE, 'E', p_ENERGY, 'D', p_DEMAND, 'H', p_ENERGY, 'S', 1.0, 0.0) INTO v_QUANTITY FROM DUAL;

	IF p_CHARGE_TYPE = 'H' THEN
		IF p_DEMAND > 0 THEN
			v_QUANTITY := p_ENERGY / p_DEMAND;
		ELSE
			v_QUANTITY := 0;
		END IF;
	END IF;

	v_COMPONENT_ID := GET_COMPOSITE_COMPONENT_ID(p_COMPONENT_ID, v_QUANTITY, p_BEGIN_DATE);
	IF v_COMPONENT_ID = CONSTANTS.NOT_ASSIGNED THEN
		RETURN 0.0;
	END IF;

	v_COMPONENT := GET_COMPONENT(v_COMPONENT_ID);
	v_RATE_STRUCTURE := UPPER(v_COMPONENT.RATE_STRUCTURE);

	SELECT DECODE(UPPER(v_COMPONENT.CHARGE_TYPE), 'ENERGY', 'E', 'PEAK DEMAND', 'D', 'SERVICE', 'S', 'DEMAND HOURS', 'H', '?') INTO v_CHARGE_TYPE FROM DUAL;

	SELECT DECODE(v_CHARGE_TYPE, 'E', p_ENERGY, 'D', p_DEMAND, 'H', p_ENERGY, 'S', 1.0, 0.0) INTO v_QUANTITY FROM DUAL;

	IF v_RATE_STRUCTURE = 'FLAT' THEN
		v_RATE := GET_COMPONENT_FLAT_RATE(v_COMPONENT.COMPONENT_ID, v_QUANTITY, p_BEGIN_DATE);
	ELSIF v_RATE_STRUCTURE = 'BLOCK' THEN
		v_RATE := GET_COMPONENT_BLOCK_RATE(v_COMPONENT.COMPONENT_ID, v_QUANTITY, p_BEGIN_DATE);
	ELSIF v_RATE_STRUCTURE = 'TIERED' THEN
		IF v_CHARGE_TYPE = 'H' THEN
			v_RATE := GET_COMPONENT_TIERED_RATE(v_COMPONENT.COMPONENT_ID, p_ENERGY, p_BEGIN_DATE, p_DEMAND);
		ELSE
			v_RATE := GET_COMPONENT_TIERED_RATE(v_COMPONENT.COMPONENT_ID, v_QUANTITY, p_BEGIN_DATE);
		END IF;
	ELSIF v_RATE_STRUCTURE = 'TIME OF USE' THEN
		v_RATE := GET_COMPONENT_TOU_RATE(v_COMPONENT.COMPONENT_ID, p_PERIOD_ID, p_BEGIN_DATE);
	ELSIF v_RATE_STRUCTURE = 'MARKET' THEN
		v_RATE := GET_COMPONENT_MARKET_RATE(v_COMPONENT.COMPONENT_ID, v_COMPONENT.MARKET_PRICE_ID, p_BEGIN_DATE);
	END IF;

	-- Bugz.4966 - CF APPLY COMPONENT PERCENTAGE TO THE RATE
	v_FACTOR := GET_COMPONENT_FACTOR(v_COMPONENT.COMPONENT_ID, p_BEGIN_DATE);
	v_RATE := v_RATE * v_FACTOR;
	-- LOGS.LOG_DEBUG('APPLYING FACTOR OF '||TO_CHAR(v_FACTOR)||' TO RATE '||TO_CHAR(v_RATE));

	RETURN v_RATE;

END GET_COMPOSITE_COMPONENT_RATE;
---------------------------------------------------------------------------------------------------
FUNCTION GET_COMPOSITE_COMPONENT_QUANT
    (
	p_COMPONENT_ID IN NUMBER,
	p_CHARGE_TYPE IN CHAR,
	p_ENERGY IN OUT NUMBER,
	p_DEMAND IN NUMBER,
	p_BEGIN_DATE IN DATE
	) RETURN NUMBER IS

v_COMPONENT_ID NUMBER(9);
v_COMPONENT COMPONENT%ROWTYPE;
v_CHARGE_TYPE CHAR(1);
v_QUANTITY NUMBER(14,6);

BEGIN

	SELECT DECODE(p_CHARGE_TYPE, 'E', p_ENERGY, 'D', p_DEMAND, 'H', p_ENERGY, 'S', 1.0, 0.0) INTO v_QUANTITY FROM DUAL;

	IF p_CHARGE_TYPE = 'H' THEN
		IF p_DEMAND > 0 THEN
			v_QUANTITY := p_ENERGY / p_DEMAND;
		ELSE
			v_QUANTITY := 0;
		END IF;
	END IF;

	v_COMPONENT_ID := GET_COMPOSITE_COMPONENT_ID(p_COMPONENT_ID, v_QUANTITY, p_BEGIN_DATE);
	IF v_COMPONENT_ID = CONSTANTS.NOT_ASSIGNED THEN
		RETURN 0.0;
	END IF;

	v_COMPONENT := GET_COMPONENT(v_COMPONENT_ID);

	SELECT DECODE(UPPER(v_COMPONENT.CHARGE_TYPE), 'ENERGY', 'E', 'PEAK DEMAND', 'D', 'SERVICE', 'S', 'DEMAND HOURS', 'H', '?') INTO v_CHARGE_TYPE FROM DUAL;

	SELECT DECODE(v_CHARGE_TYPE, 'E', p_ENERGY, 'D', p_DEMAND, 'H', p_ENERGY, 'S', 1.0, 0.0) INTO v_QUANTITY FROM DUAL;

	RETURN v_QUANTITY;

END GET_COMPOSITE_COMPONENT_QUANT;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_PROJECTION_PATTERN
    (
	p_PROJECTION_ID NUMBER,
	p_PROJECTION_TYPE IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TRACE_ON BOOLEAN,
	p_PROJECTION_PATTERN IN OUT NOCOPY PROJECTION_PATTERN_TABLE
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_DATE DATE;

CURSOR c_PATTERN IS
	SELECT PROJECTION_ID,
		PERIOD_ID,
		TRUNC(FROM_CUT(PROJECTION_DATE,LOCAL_TIME_ZONE) - g_SECOND,'MONTH') "PROJECTION_DATE",
		SUM(ENERGY) "ENERGY",
		MAX(DEMAND) "DEMAND"
	FROM PROJECTION_PATTERN
	WHERE PROJECTION_ID = p_PROJECTION_ID
		AND PERIOD_ID = PERIOD_ID
		AND PROJECTION_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
	GROUP BY PROJECTION_ID, PERIOD_ID, TRUNC(FROM_CUT(PROJECTION_DATE,LOCAL_TIME_ZONE) - g_SECOND,'MONTH');

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('GET_PROJECTION_PATTERN');
	END IF;

	IF UPPER(p_PROJECTION_TYPE) = 'DAY' THEN
		SELECT PROJECTION_PATTERN_TYPE(PROJECTION_ID, PERIOD_ID, PROJECTION_DATE, ENERGY, DEMAND)
		BULK COLLECT INTO p_PROJECTION_PATTERN
		FROM PROJECTION_PATTERN
		WHERE PROJECTION_ID = p_PROJECTION_ID
			AND PERIOD_ID = PERIOD_ID
			AND PROJECTION_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE);
	END IF;

-- If the projection pattern is a Month/Hour Pattern then convert to Day pattern..
	IF UPPER(p_PROJECTION_TYPE) = 'MONTH' OR (UPPER(p_PROJECTION_TYPE) = 'DAY' AND p_PROJECTION_PATTERN.COUNT = 0) THEN
		UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
		FOR v_PATTERN IN c_PATTERN LOOP
			v_DATE := v_PATTERN.PROJECTION_DATE;
			WHILE v_DATE <= LAST_DAY(v_PATTERN.PROJECTION_DATE) LOOP
				IF (TO_CHAR(v_DATE,'DY') IN ('SAT','SUN') AND v_PATTERN.PERIOD_ID = -2) OR (TO_CHAR(v_DATE,'DY') NOT IN ('SAT','SUN') AND v_PATTERN.PERIOD_ID = -1) THEN
					p_PROJECTION_PATTERN.EXTEND;
					p_PROJECTION_PATTERN(p_PROJECTION_PATTERN.LAST) := PROJECTION_PATTERN_TYPE(v_PATTERN.PROJECTION_ID, CONSTANTS.ALL_ID, v_DATE, v_PATTERN.ENERGY, v_PATTERN.DEMAND);
				END IF;
				v_DATE := v_DATE + 1;
			END LOOP;
		END LOOP;
	END IF;

END GET_PROJECTION_PATTERN;
---------------------------------------------------------------------------------------------------
PROCEDURE TRACE_DETERMINANTS
    (
	p_NAME IN VARCHAR,
	p_DETERMINANTS IN DETERMINANT_TABLE
	) AS

v_INDEX BINARY_INTEGER;

BEGIN
	IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
		LOGS.LOG_DEBUG('TRACE_DETERMINANTS ' || p_NAME);
		IF p_DETERMINANTS.COUNT > 0 THEN
			LOGS.LOG_DEBUG('<period id>,<begin>,<end>,<bill cycle month>,<determinant_1>,<determinant_2>');
			FOR v_INDEX IN p_DETERMINANTS.FIRST..p_DETERMINANTS.LAST LOOP
				IF p_DETERMINANTS.EXISTS(v_INDEX) THEN
					LOGS.LOG_DEBUG(TO_CHAR(p_DETERMINANTS(v_INDEX).PERIOD_ID) || ',' || TO_CHAR(p_DETERMINANTS(v_INDEX).BEGIN_DATE) || ',' || TO_CHAR(p_DETERMINANTS(v_INDEX).END_DATE)  || ',' || TO_CHAR(p_DETERMINANTS(v_INDEX).BILL_CYCLE_MONTH) || ',' || TO_CHAR(p_DETERMINANTS(v_INDEX).DETERMINANT_1) || ',' || TO_CHAR(p_DETERMINANTS(v_INDEX).DETERMINANT_1));
				END IF;
			END LOOP;
		ELSE
			LOGS.LOG_DEBUG('<No Determinants>');
		END IF;
	END IF;

END TRACE_DETERMINANTS;
-------------------------------------------------------------------------------------------------
PROCEDURE TRACE_CHARGE_COMPONENTS
    (
	p_NAME IN VARCHAR,
	p_CHARGE_COMPONENTS IN CHARGE_COMPONENT_TABLE
	) AS

v_INDEX BINARY_INTEGER;

BEGIN
	IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
		LOGS.LOG_DEBUG('TRACE_CHARGE_COMPONENTS ' || p_NAME);
		IF p_CHARGE_COMPONENTS.COUNT > 0 THEN
			LOGS.LOG_DEBUG('<product id>,<component id>,<period id>,<charge type>,<begin>,<end>,<quantity>,<rate>,<amount>,<factor>,<planned>,<actual>,<band>');
			FOR v_INDEX IN p_CHARGE_COMPONENTS.FIRST..p_CHARGE_COMPONENTS.LAST LOOP
				IF p_CHARGE_COMPONENTS.EXISTS(v_INDEX) THEN
					LOGS.LOG_DEBUG(TO_CHAR(p_CHARGE_COMPONENTS(v_INDEX).PRODUCT_ID) || ',' ||
						TO_CHAR(p_CHARGE_COMPONENTS(v_INDEX).COMPONENT_ID) || ',' ||
						TO_CHAR(p_CHARGE_COMPONENTS(v_INDEX).PERIOD_ID) || ',' ||
						p_CHARGE_COMPONENTS(v_INDEX).CHARGE_TYPE || ',' ||
						TO_CHAR(p_CHARGE_COMPONENTS(v_INDEX).BEGIN_DATE) || ',' ||
						TO_CHAR(p_CHARGE_COMPONENTS(v_INDEX).END_DATE) || ',' ||
						TO_CHAR(p_CHARGE_COMPONENTS(v_INDEX).QUANTITY) || ',' ||
						TO_CHAR(p_CHARGE_COMPONENTS(v_INDEX).RATE) || ',' ||
						TO_CHAR(p_CHARGE_COMPONENTS(v_INDEX).AMOUNT) || ',' ||
						TO_CHAR(p_CHARGE_COMPONENTS(v_INDEX).FACTOR) || ',' ||
						TO_CHAR(p_CHARGE_COMPONENTS(v_INDEX).PLANNED) || ',' ||
						TO_CHAR(p_CHARGE_COMPONENTS(v_INDEX).ACTUAL) || ',' ||
						TO_CHAR(p_CHARGE_COMPONENTS(v_INDEX).BAND_NUMBER));
				END IF;
			END LOOP;
		ELSE
			LOGS.LOG_DEBUG('<No Charge Components>');
		END IF;
	END IF;

END TRACE_CHARGE_COMPONENTS;
-------------------------------------------------------------------------------------------------
PROCEDURE COPY_DETERMINANTS
    (
	p_IN IN DETERMINANT_TABLE,
	p_OUT IN OUT NOCOPY DETERMINANT_TABLE
	) AS

v_INDEX BINARY_INTEGER;

BEGIN

	p_OUT.DELETE;

	IF p_IN.COUNT > 0 THEN
		FOR v_INDEX IN p_IN.FIRST..p_IN.LAST LOOP
			IF p_IN.EXISTS(v_INDEX) THEN
				p_OUT.EXTEND;
				p_OUT(p_OUT.LAST) := DETERMINANT_TYPE(p_IN(v_INDEX).PERIOD_ID, p_IN(v_INDEX).DAY_DATE, p_IN(v_INDEX).DAY_DATE, p_IN(v_INDEX).BILL_CYCLE_MONTH, p_IN(v_INDEX).ENERGY, p_IN(v_INDEX).DEMAND, p_IN(v_INDEX).ENROLLMENT, p_IN(v_INDEX).BILL_CODE, p_IN(v_INDEX).ACCOUNT_SERVICE_ID, p_IN(v_INDEX).CONSUMPTION_ID, p_IN(v_INDEX).CUSTOMER_ID);
			END IF;
		END LOOP;
	END IF;

END COPY_DETERMINANTS;
-------------------------------------------------------------------------------------------------
PROCEDURE GET_PROJECTION_DETERMINANTS
    (
	p_CALENDAR_ID IN NUMBER,
	p_PROJECTION_TYPE IN VARCHAR,
	p_TEMPLATE_ID IN NUMBER,
	p_STATION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TRACE_ON BOOLEAN,
	p_DETERMINANTS IN OUT NOCOPY DETERMINANT_TABLE
	) AS

v_PROJECTION_PATTERN PROJECTION_PATTERN_TABLE := PROJECTION_PATTERN_TABLE();
v_TEMPLATE_ID NUMBER;
v_PROJECTION_ID NUMBER;
v_CALENDAR_NAME VARCHAR(32);

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('GET_PROJECTION_DETERMINANTS');
		LOGS.LOG_DEBUG('CALENDAR_ID=' || TO_CHAR(p_CALENDAR_ID));
		LOGS.LOG_DEBUG('PROJECTION_TYPE=' || p_PROJECTION_TYPE);
		LOGS.LOG_DEBUG('TEMPLATE_ID=' || TO_CHAR(p_TEMPLATE_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TO_CHAR(p_END_DATE));
		LOGS.LOG_DEBUG('AS_OF_DATE=' || UT.TRACE_DATE(p_AS_OF_DATE));
	END IF;

	p_DETERMINANTS.DELETE;

-- Need to add behavior to handle a WRF evaluated for Weather.

-- Coerce the Template ID to be appropriate for the Projection Type.
	IF UPPER(p_PROJECTION_TYPE) = 'DAY' AND p_TEMPLATE_ID = CONSTANTS.NOT_ASSIGNED THEN
		v_TEMPLATE_ID := g_PROJECTION_TEMPLATE;
	ELSIF UPPER(p_PROJECTION_TYPE) = 'MONTH' AND NOT p_TEMPLATE_ID = CONSTANTS.NOT_ASSIGNED THEN
		v_TEMPLATE_ID := CONSTANTS.NOT_ASSIGNED;
	ELSE
		v_TEMPLATE_ID := p_TEMPLATE_ID;
	END IF;

	v_PROJECTION_ID := GET_PROJECTION_ID(p_CALENDAR_ID, p_PROJECTION_TYPE, v_TEMPLATE_ID, p_AS_OF_DATE);

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('Projection TEMPLATE_ID=' || TO_CHAR(v_TEMPLATE_ID));
		LOGS.LOG_DEBUG('PROJECTION_ID=' || TO_CHAR(v_PROJECTION_ID));
	END IF;

	GET_PROJECTION_PATTERN(v_PROJECTION_ID, p_PROJECTION_TYPE, p_BEGIN_DATE, p_END_DATE, LOGS.IS_DEBUG_DETAIL_ENABLED, v_PROJECTION_PATTERN);

-- Non WRF Calendar Projection.
	SELECT DETERMINANT_TYPE(A.PERIOD_ID, A.PROJECTION_DATE, A.PROJECTION_DATE, NULL, A.ENERGY, A.DEMAND, CONSTANTS.NOT_ASSIGNED, 'B', CONSTANTS.NOT_ASSIGNED, CONSTANTS.NOT_ASSIGNED, CONSTANTS.NOT_ASSIGNED)
	BULK COLLECT INTO p_DETERMINANTS
	FROM TABLE(CAST(v_PROJECTION_PATTERN AS PROJECTION_PATTERN_TABLE)) A;

	IF LOGS.IS_DEBUG_ENABLED THEN
		TRACE_DETERMINANTS('PROJECTION_DETERMINANTS', p_DETERMINANTS);
	END IF;

	IF p_DETERMINANTS.COUNT = 0 THEN
		v_CALENDAR_NAME := GET_CALENDAR_NAME(p_CALENDAR_ID);
		ERRS.RAISE(MSGCODES.c_ERR_GENERAL,'MISSING CALENDAR PROJECTION FOR ' || v_CALENDAR_NAME);
	END IF;

END GET_PROJECTION_DETERMINANTS;
-------------------------------------------------------------------------------------------------
PROCEDURE PROJECT_CONSUMPTION
    (
	p_YEAR_DATE IN DATE,
	p_READING IN CONSUMPTION_TYPE,
	p_CONSUMPTION IN OUT NOCOPY CONSUMPTION_TABLE
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_BEGIN DATE;
v_END DATE;
v_CONSUMPTION_DAYS NUMBER(4);
v_ENERGY NUMBER;
v_DEMAND NUMBER;
v_REDUCTION NUMBER;

BEGIN

-- Project the historical consumption to a future time period.
	v_BEGIN_DATE := TO_DATE(TO_CHAR(p_READING.BEGIN_DATE,'DD-MON-') || TO_CHAR(p_YEAR_DATE,'YYYY'), 'DD-MON-YYYY');
	v_CONSUMPTION_DAYS := p_READING.END_DATE - p_READING.BEGIN_DATE + 1;
	v_REDUCTION := 0;

-- If historical data is leap year and consumption period contains FEB-29, then reduce consumption days and amount by one day.
	IF MOD(TO_NUMBER(TO_CHAR(p_READING.BEGIN_DATE,'YYYY')),4) = 0 AND TO_DATE('29-FEB-' || TO_CHAR(p_READING.BEGIN_DATE,'YYYY'), 'DD-MON-YYYY') BETWEEN p_READING.BEGIN_DATE AND p_READING.END_DATE THEN
        -- Bugzilla 4968 - Only adjust for leap year if target is not a leap year
	    IF MOD(TO_NUMBER(TO_CHAR(p_YEAR_DATE,'YYYY')),4) <> 0 THEN
    		v_REDUCTION := p_READING.ENERGY * (1 / v_CONSUMPTION_DAYS);
    		v_CONSUMPTION_DAYS := v_CONSUMPTION_DAYS - 1;
		END IF;
	END IF;
	v_END_DATE := v_BEGIN_DATE + (v_CONSUMPTION_DAYS - 1);
	p_CONSUMPTION.DELETE;

-- If the consumption period end date falls outside the specified year append the energy amount that falls outside to the beginning of the year.
	IF NOT TO_CHAR(v_END_DATE,'YYYY') = TO_CHAR(p_YEAR_DATE,'YYYY') THEN
		p_CONSUMPTION.EXTEND;
		v_BEGIN := p_YEAR_DATE;
		v_END := ADD_MONTHS(v_END_DATE,-12);
		v_ENERGY := (p_READING.ENERGY - v_REDUCTION) * ((v_END - v_BEGIN + 1) / v_CONSUMPTION_DAYS);
		v_DEMAND := p_READING.DEMAND;
		p_CONSUMPTION(p_CONSUMPTION.LAST) := CONSUMPTION_TYPE(v_BEGIN, v_END, p_READING.TEMPLATE_ID, p_READING.PERIOD_ID, v_ENERGY, v_DEMAND);
	END IF;

-- Include the consumption projected to the future dates, making sure the end date falls within the specified year.
	p_CONSUMPTION.EXTEND;
	v_BEGIN := v_BEGIN_DATE;
	v_END := LEAST(v_END_DATE, ADD_MONTHS(p_YEAR_DATE,12) - 1);
	v_ENERGY := (p_READING.ENERGY - v_REDUCTION) * ((v_END - v_BEGIN + 1) / v_CONSUMPTION_DAYS);
	v_DEMAND := p_READING.DEMAND;
	p_CONSUMPTION(p_CONSUMPTION.LAST) := CONSUMPTION_TYPE(v_BEGIN, v_END, p_READING.TEMPLATE_ID, p_READING.PERIOD_ID, v_ENERGY, v_DEMAND);

END PROJECT_CONSUMPTION;
-------------------------------------------------------------------------------------------------
PROCEDURE GET_PRORATED_CONSUMPTION
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_DETERMINANTS IN DETERMINANT_TABLE,
	p_CONSUMPTION IN CONSUMPTION_TABLE,
	p_TRACE_ON IN BOOLEAN,
	p_PRORATION IN OUT NOCOPY DETERMINANT_TABLE
	) AS

v_INDEX BINARY_INTEGER;
v_IDX BINARY_INTEGER;
v_SEG_IDX BINARY_INTEGER;
v_ENERGY NUMBER;
v_DEMAND NUMBER;
v_YEAR_DATE DATE;
v_CONSUMPTION CONSUMPTION_TABLE := CONSUMPTION_TABLE();

BEGIN

	p_PRORATION.DELETE;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('GET_PRORATED_CONSUMPTION');
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TO_CHAR(p_END_DATE));
		LOGS.LOG_DEBUG('DETERMINANTS DATA, COUNT=' || TO_CHAR(p_DETERMINANTS.COUNT));
		LOGS.LOG_DEBUG('CONSUMPTION DATA, COUNT=' || TO_CHAR(p_CONSUMPTION.COUNT));
		LOGS.LOG_DEBUG('<type>,<begin date>,<end date>,<template id>,<period id>,<energy>,<demand>');
	END IF;

-- If there are no determinants then there is nothing useful that can be done here.
	IF p_DETERMINANTS.COUNT = 0 THEN
		RETURN;
	END IF;

-- Make a copy of the orignal input to apply consumption prorations.
	SELECT DETERMINANT_TYPE(A.PERIOD_ID, A.BEGIN_DATE, A.END_DATE, A.BILL_CYCLE_MONTH, A.DETERMINANT_1, A.DETERMINANT_2, A.ENROLLMENT, A.BILL_CODE, A.ACCOUNT_SERVICE_ID, A.CONSUMPTION_ID, CONSTANTS.NOT_ASSIGNED)
	BULK COLLECT INTO p_PRORATION
	FROM TABLE(CAST(p_DETERMINANTS AS DETERMINANT_TABLE)) A;

-- If there is no consumption then there is nothing useful that can be done here.
	IF p_CONSUMPTION.COUNT =  0 THEN
		RETURN;
	END IF;

-- Loop over the consumption entries and apply to the evaluation period.
	FOR v_INDEX IN p_CONSUMPTION.FIRST..p_CONSUMPTION.LAST LOOP

		v_YEAR_DATE := TRUNC(p_BEGIN_DATE, 'YEAR');

		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG('A' || ',' ||
				TO_CHAR(p_CONSUMPTION(v_INDEX).BEGIN_DATE) || ',' ||
				TO_CHAR(p_CONSUMPTION(v_INDEX).END_DATE) || ',' ||
				TO_CHAR(p_CONSUMPTION(v_INDEX).TEMPLATE_ID) || ',' ||
				TO_CHAR(p_CONSUMPTION(v_INDEX).PERIOD_ID) || ',' ||
				TO_CHAR(p_CONSUMPTION(v_INDEX).ENERGY) || ',' ||
				TO_CHAR(p_CONSUMPTION(v_INDEX).DEMAND));
		END IF;

-- Loop over the years of the evaluation period to prorate the actual usage to the profiled usage.
		WHILE v_YEAR_DATE <= TRUNC(p_END_DATE, 'YEAR') LOOP

-- Project the historical consumption onto the future year.
			PROJECT_CONSUMPTION(v_YEAR_DATE, p_CONSUMPTION(v_INDEX), v_CONSUMPTION);

-- Process the projected consumption segments.
			FOR v_SEG_IDX IN v_CONSUMPTION.FIRST..v_CONSUMPTION.LAST LOOP
				IF NOT (v_CONSUMPTION(v_SEG_IDX).BEGIN_DATE > p_END_DATE OR v_CONSUMPTION(v_SEG_IDX).END_DATE < p_BEGIN_DATE) THEN
					IF LOGS.IS_DEBUG_ENABLED THEN
						LOGS.LOG_DEBUG('P' || ',' ||
							TO_CHAR(v_CONSUMPTION(v_SEG_IDX).BEGIN_DATE) || ',' ||
							TO_CHAR(v_CONSUMPTION(v_SEG_IDX).END_DATE) || ',' ||
							TO_CHAR(v_CONSUMPTION(v_SEG_IDX).TEMPLATE_ID) || ',' ||
							TO_CHAR(v_CONSUMPTION(v_SEG_IDX).PERIOD_ID) || ',' ||
							TO_CHAR(v_CONSUMPTION(v_SEG_IDX).ENERGY) || ',' ||
							TO_CHAR(v_CONSUMPTION(v_SEG_IDX).DEMAND));
					END IF;

-- Get the profiled energy matching the consumption period entry_date.
					SELECT SUM(B.DETERMINANT_1), MAX(B.DETERMINANT_2)
					INTO v_ENERGY, v_DEMAND
					FROM TABLE(CAST(p_DETERMINANTS AS DETERMINANT_TABLE)) B
					WHERE B.DAY_DATE() BETWEEN v_CONSUMPTION(v_SEG_IDX).BEGIN_DATE AND v_CONSUMPTION(v_SEG_IDX).END_DATE;

-- Prorate the profile energy to the consumption energy.
					FOR v_IDX IN p_PRORATION.FIRST..p_PRORATION.LAST LOOP
						IF p_PRORATION(v_IDX).DAY_DATE BETWEEN v_CONSUMPTION(v_SEG_IDX).BEGIN_DATE AND v_CONSUMPTION(v_SEG_IDX).END_DATE THEN
							p_PRORATION(v_IDX).ENERGY(p_PRORATION(v_IDX).ENERGY / v_ENERGY * v_CONSUMPTION(v_SEG_IDX).ENERGY);
							p_PRORATION(v_IDX).DEMAND(p_PRORATION(v_IDX).DEMAND / v_DEMAND * v_CONSUMPTION(v_SEG_IDX).DEMAND);
						END IF;
					END LOOP;
				END IF;
			END LOOP;
			v_YEAR_DATE := TRUNC(ADD_MONTHS(v_YEAR_DATE,12),'YEAR');
		END LOOP;
	END LOOP;

	IF LOGS.IS_DEBUG_ENABLED THEN
		TRACE_DETERMINANTS('PRORATED_CONSUMPTION', p_PRORATION);
	END IF;

END GET_PRORATED_CONSUMPTION;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_PRORATED_DETERMINANTS
    (
	p_CALENDAR_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_CONSUMPTION IN CONSUMPTION_TABLE,
	p_TRACE_ON IN BOOLEAN,
	p_DETERMINANTS IN OUT NOCOPY DETERMINANT_TABLE
	) AS

v_INDEX BINARY_INTEGER;
v_IDX BINARY_INTEGER;
v_SEG_IDX BINARY_INTEGER;
v_ENERGY NUMBER;
v_DEMAND NUMBER;
v_YEAR_DATE DATE;
v_CONSUMPTION CONSUMPTION_TABLE := CONSUMPTION_TABLE();
v_PROJECTION_ID NUMBER;
v_TEMPLATE_ID NUMBER;

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('GET_PRORATED_DETERMINANTS');
		LOGS.LOG_DEBUG('CALENDAR_ID=' || TO_CHAR(p_CALENDAR_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TO_CHAR(p_END_DATE));
		LOGS.LOG_DEBUG('AS_OF_DATE=' || UT.TRACE_DATE(p_AS_OF_DATE));
		LOGS.LOG_DEBUG('CONSUMPTION DATA, COUNT=' || TO_CHAR(p_CONSUMPTION.COUNT));
		LOGS.LOG_DEBUG('<type>,<begin date>,<end date>,<template id>,<period id>,<energy>,<demand>');
	END IF;

-- Get the Calendar Projection Determinants for the evaluation period.
	v_TEMPLATE_ID := p_CONSUMPTION(p_CONSUMPTION.FIRST).TEMPLATE_ID;
	IF v_TEMPLATE_ID = CONSTANTS.NOT_ASSIGNED THEN
		v_TEMPLATE_ID := g_PROJECTION_TEMPLATE;
	END IF;
	v_PROJECTION_ID := GET_PROJECTION_ID(p_CALENDAR_ID, 'DAY', v_TEMPLATE_ID, p_AS_OF_DATE);
	p_DETERMINANTS.DELETE;

	SELECT DETERMINANT_TYPE(PERIOD_ID, PROJECTION_DATE, PROJECTION_DATE, NULL, ENERGY, DEMAND, CONSTANTS.NOT_ASSIGNED, 'B', CONSTANTS.NOT_ASSIGNED, CONSTANTS.NOT_ASSIGNED, CONSTANTS.NOT_ASSIGNED)
	BULK COLLECT INTO p_DETERMINANTS
	FROM PROJECTION_PATTERN
	WHERE PROJECTION_ID = v_PROJECTION_ID
		AND PERIOD_ID = PERIOD_ID
		AND PROJECTION_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE;

	IF p_DETERMINANTS.COUNT > 0 THEN

-- Loop over the consumption entries and apply to the evaluation period.
		FOR v_INDEX IN p_CONSUMPTION.FIRST..p_CONSUMPTION.LAST LOOP

			v_YEAR_DATE := TRUNC(p_BEGIN_DATE, 'YEAR');

			IF LOGS.IS_DEBUG_ENABLED THEN
				LOGS.LOG_DEBUG('A' || ',' ||
					TO_CHAR(p_CONSUMPTION(v_INDEX).BEGIN_DATE) || ',' ||
					TO_CHAR(p_CONSUMPTION(v_INDEX).END_DATE) || ',' ||
					TO_CHAR(p_CONSUMPTION(v_INDEX).TEMPLATE_ID) || ',' ||
					TO_CHAR(p_CONSUMPTION(v_INDEX).PERIOD_ID) || ',' ||
					TO_CHAR(p_CONSUMPTION(v_INDEX).ENERGY) || ',' ||
					TO_CHAR(p_CONSUMPTION(v_INDEX).DEMAND));
			END IF;

-- Loop over the years of the evaluation period to prorate the actual usage to the profiled usage.
			WHILE v_YEAR_DATE <= TRUNC(p_END_DATE, 'YEAR') LOOP

-- Project the historical consumption onto the future year.
				PROJECT_CONSUMPTION(v_YEAR_DATE, p_CONSUMPTION(v_INDEX), v_CONSUMPTION);

-- Process the projected consumption segments.
				FOR v_SEG_IDX IN v_CONSUMPTION.FIRST..v_CONSUMPTION.LAST LOOP
					IF NOT (v_CONSUMPTION(v_SEG_IDX).BEGIN_DATE > p_END_DATE OR v_CONSUMPTION(v_SEG_IDX).END_DATE < p_BEGIN_DATE) THEN
						IF LOGS.IS_DEBUG_ENABLED THEN
							LOGS.LOG_DEBUG('P' || ',' ||
								TO_CHAR(v_CONSUMPTION(v_SEG_IDX).BEGIN_DATE) || ',' ||
								TO_CHAR(v_CONSUMPTION(v_SEG_IDX).END_DATE) || ',' ||
								TO_CHAR(v_CONSUMPTION(v_SEG_IDX).TEMPLATE_ID) || ',' ||
								TO_CHAR(v_CONSUMPTION(v_SEG_IDX).PERIOD_ID) || ',' ||
								TO_CHAR(v_CONSUMPTION(v_SEG_IDX).ENERGY) || ',' ||
								TO_CHAR(v_CONSUMPTION(v_SEG_IDX).DEMAND));
						END IF;

-- Get the profiled energy matching the consumption period entry_date.
						SELECT SUM(ENERGY), MAX(DEMAND)
						INTO v_ENERGY, v_DEMAND
						FROM PROJECTION_PATTERN
						WHERE PROJECTION_ID = v_PROJECTION_ID
							AND PERIOD_ID = DECODE(v_CONSUMPTION(v_SEG_IDX).PERIOD_ID, CONSTANTS.NOT_ASSIGNED, PERIOD_ID, v_CONSUMPTION(v_SEG_IDX).PERIOD_ID)
							AND PROJECTION_DATE BETWEEN v_CONSUMPTION(v_SEG_IDX).BEGIN_DATE AND v_CONSUMPTION(v_SEG_IDX).END_DATE;

-- Prorate the profile energy to the consumption energy.
						FOR v_IDX IN p_DETERMINANTS.FIRST..p_DETERMINANTS.LAST LOOP
							IF (p_DETERMINANTS(v_IDX).PERIOD_ID = v_CONSUMPTION(v_SEG_IDX).PERIOD_ID OR v_CONSUMPTION(v_SEG_IDX).PERIOD_ID = CONSTANTS.NOT_ASSIGNED) AND p_DETERMINANTS(v_IDX).DAY_DATE BETWEEN v_CONSUMPTION(v_SEG_IDX).BEGIN_DATE AND v_CONSUMPTION(v_SEG_IDX).END_DATE THEN
								p_DETERMINANTS(v_IDX).ENERGY(p_DETERMINANTS(v_IDX).ENERGY / v_ENERGY * v_CONSUMPTION(v_SEG_IDX).ENERGY);
								p_DETERMINANTS(v_IDX).DEMAND(p_DETERMINANTS(v_IDX).DEMAND / v_DEMAND * v_CONSUMPTION(v_SEG_IDX).DEMAND);
							END IF;
						END LOOP;
					END IF;
				END LOOP;
				v_YEAR_DATE := TRUNC(ADD_MONTHS(v_YEAR_DATE,12),'YEAR');
			END LOOP;
		END LOOP;
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		TRACE_DETERMINANTS('PRORATED_DETERMINANTS', p_DETERMINANTS);
	END IF;

END GET_PRORATED_DETERMINANTS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_CHARGE_QUANTITY
    (
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_PERIOD_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_DETERMINANTS IN DETERMINANT_TABLE,
	p_ENERGY OUT NUMBER,
	p_DEMAND OUT NUMBER,
    p_NEED_PERIOD_IDs IN BOOLEAN := FALSE,
    p_INTERVAL_DETERMINANTS IN BOOLEAN := FALSE
	) AS

-- Quantities are assumed KW,KWH for Electric and Therms for Gas at the Account level.

v_QUANTITY_UNIT COMPONENT.QUANTITY_UNIT%TYPE := UPPER(p_COMPONENT.QUANTITY_UNIT);
v_FACTOR NUMBER(4,3) := 1.0;
v_ADD_SECONDS NUMBER(1) := 0;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
BEGIN

    IF p_COMPONENT.MODEL_ID = GA.ELECTRIC_MODEL THEN
       	v_ADD_SECONDS := -1;
        IF p_INTERVAL_DETERMINANTS THEN
        	UT.CUT_DATE_RANGE(TRUNC(p_BEGIN_DATE),TRUNC(p_END_DATE),LOCAL_TIME_ZONE,v_BEGIN_DATE,v_END_DATE);
        ELSE
	    	v_BEGIN_DATE := TRUNC(p_BEGIN_DATE);
	        v_END_DATE := TRUNC(p_END_DATE);
        END IF;
	    IF v_QUANTITY_UNIT IN ('MW','MWH') THEN
		    v_FACTOR := .001;
	    END IF;
    ELSIF p_COMPONENT.MODEL_ID = GA.GAS_MODEL THEN
    	v_BEGIN_DATE := TRUNC(p_BEGIN_DATE);
        v_END_DATE := TRUNC(p_END_DATE);
	    IF v_QUANTITY_UNIT = 'DT' THEN
		    v_FACTOR := .1;
	    END IF;
    END IF;

    IF NOT p_NEED_PERIOD_IDs OR p_PERIOD_ID = CONSTANTS.ALL_ID THEN
		SELECT SUM(A.DETERMINANT_1 * v_FACTOR), MAX(A.DETERMINANT_2 * v_FACTOR)
		INTO p_ENERGY, p_DEMAND
		FROM TABLE(CAST(p_DETERMINANTS AS DETERMINANT_TABLE)) A
		WHERE (p_PERIOD_ID = CONSTANTS.ALL_ID OR A.PERIOD_ID = p_PERIOD_ID)
			AND A.BEGIN_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE;
	ELSE -- if a specific period is specified, and we need to determine
    	 -- the period IDs for the data, the query is a little more complicated	 
	
		SP.CHECK_TEMPLATE_DATES(p_COMPONENT.TEMPLATE_ID,
							CONSTANTS.NOT_ASSIGNED,
							GA.LOCAL_TIME_ZONE,
							p_BEGIN_DATE,
							p_END_DATE);
		 
		 IF NOT p_INTERVAL_DETERMINANTS  OR p_COMPONENT.MODEL_ID = GA.GAS_MODEL THEN
		 	-- NON-INTERVAL OR GAS_MODEL?  GET JUST THOSE DAYS WHOSE FIRST PERIOD = p_PERIOD
		 	SELECT SUM(A.DETERMINANT_1 * v_FACTOR), MAX(A.DETERMINANT_2 * v_FACTOR)
			INTO p_ENERGY, p_DEMAND
			FROM TABLE(CAST(p_DETERMINANTS AS DETERMINANT_TABLE)) A,
				TEMPLATE_DATES TD,
				TEMPLATE_DAY_TYPE_PERIOD DT
			WHERE TD.TIME_ZONE = GA.LOCAL_TIME_ZONE
				AND TD.TEMPLATE_ID = p_COMPONENT.TEMPLATE_ID
				AND TD.HOLIDAY_SET_ID = CONSTANTS.NOT_ASSIGNED
				AND TD.LOCAL_DATE = A.BEGIN_DATE
				AND A.BEGIN_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND DT.DAY_TYPE_ID = TD.DAY_TYPE_ID
				AND DT.TIME_STAMP = CONSTANTS.DAY_TYPE_FIRST_INTERVAL
				AND DT.PERIOD_ID = p_PERIOD_ID;

		 ELSE
		 
		 	-- OTHERWISE GET THE DETERMINANTS PER INTERVAL WHERE THE FIRST PERIOD = p_PERIOD
		 	SELECT SUM(A.DETERMINANT_1 * v_FACTOR), MAX(A.DETERMINANT_2 * v_FACTOR)
			INTO p_ENERGY, p_DEMAND
			FROM TABLE(CAST(p_DETERMINANTS AS DETERMINANT_TABLE)) A,
				TEMPLATE_DATES TD,
				TEMPLATE_DAY_TYPE_PERIOD DT
			WHERE TD.TIME_ZONE = GA.LOCAL_TIME_ZONE
				AND TD.TEMPLATE_ID = p_COMPONENT.TEMPLATE_ID
				AND TD.HOLIDAY_SET_ID = CONSTANTS.NOT_ASSIGNED
				AND TD.LOCAL_DATE = A.BEGIN_DATE
				AND A.BEGIN_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND DT.DAY_TYPE_ID = TD.DAY_TYPE_ID
				AND DT.TIME_STAMP = A.BEGIN_DATE - TD.CUT_BEGIN_DATE 
				AND DT.PERIOD_ID = p_PERIOD_ID;
		 
		 END IF;
		 
    END IF;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		p_ENERGY := 0;
		p_DEMAND := 0;

END GET_CHARGE_QUANTITY;
-------------------------------------------------------------------------------------------------
PROCEDURE GET_CHARGE_QUANTITY
    (
	p_DETERMINANTS IN DETERMINANT_TABLE,
	p_ENERGY OUT NUMBER,
	p_DEMAND OUT NUMBER
	) AS

BEGIN

	SELECT SUM(A.DETERMINANT_1), MAX(A.DETERMINANT_2)
	INTO p_ENERGY, p_DEMAND
	FROM TABLE(CAST(p_DETERMINANTS AS DETERMINANT_TABLE)) A;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		p_ENERGY := 0;
		p_DEMAND := 0;

END GET_CHARGE_QUANTITY;
-------------------------------------------------------------------------------------------------
PROCEDURE APPLY_CONSUMPTION_CHARGE
	(
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_DETERMINANTS IN DETERMINANT_TABLE,
	p_CHARGE_COMPONENTS IN OUT NOCOPY CHARGE_COMPONENT_TABLE
	) AS

v_INDEX BINARY_INTEGER;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_BILL_CYCLE_MONTH DATE;
v_ACCOUNT_SERVICE_ID NUMBER(9);
v_CHARGE_TYPE CHAR(1) := 'C';
v_QUANTITY NUMBER(14,6);
v_RATE NUMBER(14,6);
v_AMOUNT NUMBER(14,6);
v_FACTOR NUMBER(14,6);
v_BILL_CODE CHAR(1);
v_RATE_STRUCTURE VARCHAR(16) := UPPER(LTRIM(RTRIM(p_COMPONENT.RATE_STRUCTURE)));
v_CUSTOM_CHARGE BOOLEAN := p_COMPONENT.IS_CUSTOM_CHARGE = 1;

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('APPLY_CONSUMPTION_CHARGE COMPONENT_ID=' || TO_CHAR(p_COMPONENT.COMPONENT_ID) || ', CHARGE_TYPE=' || p_COMPONENT.CHARGE_TYPE || ', RATE_STRUCTURE=' || p_COMPONENT.RATE_STRUCTURE || ', RATE_INTERVAL=' || p_COMPONENT.RATE_INTERVAL || ', CUSTOM_CHARGE=' || UT.TRACE_BOOLEAN(v_CUSTOM_CHARGE));
		LOGS.LOG_DEBUG('<begin>,<end>,<bill period month>,<quantity>,<rate>,<amount>,<factor>,<bill code>');
	END IF;

	v_INDEX := p_DETERMINANTS.FIRST;
	WHILE v_INDEX <= p_DETERMINANTS.LAST LOOP

		v_QUANTITY := p_DETERMINANTS(v_INDEX).CONSUMPTION;
		v_BILL_CODE := p_DETERMINANTS(v_INDEX).BILL_CODE;

		v_BEGIN_DATE := p_DETERMINANTS(v_INDEX).BEGIN_DATE;
		v_END_DATE := p_DETERMINANTS(v_INDEX).END_DATE;
		v_BILL_CYCLE_MONTH := p_DETERMINANTS(v_INDEX).BILL_CYCLE_MONTH;
		v_ACCOUNT_SERVICE_ID := p_DETERMINANTS(v_INDEX).ACCOUNT_SERVICE_ID;

		IF v_RATE_STRUCTURE = 'FLAT' THEN
			IF v_CUSTOM_CHARGE THEN
				v_RATE := GET_COMPONENT_FLAT_RATE(p_COMPONENT.COMPONENT_ID, v_ACCOUNT_SERVICE_ID, v_QUANTITY, v_BILL_CYCLE_MONTH);
			ELSE
				v_RATE := GET_COMPONENT_FLAT_RATE(p_COMPONENT.COMPONENT_ID, v_QUANTITY, v_BILL_CYCLE_MONTH);
			END IF;
		ELSIF v_RATE_STRUCTURE = 'BLOCK' THEN
			IF v_CUSTOM_CHARGE THEN
				v_RATE := GET_COMPONENT_BLOCK_RATE(p_COMPONENT.COMPONENT_ID, v_ACCOUNT_SERVICE_ID, v_QUANTITY, v_BILL_CYCLE_MONTH);
			ELSE
				v_RATE := GET_COMPONENT_BLOCK_RATE(p_COMPONENT.COMPONENT_ID, v_QUANTITY, v_BILL_CYCLE_MONTH);
			END IF;
		ELSIF v_RATE_STRUCTURE = 'TIERED' THEN
			IF v_CUSTOM_CHARGE THEN
				v_RATE := GET_COMPONENT_TIERED_RATE(p_COMPONENT.COMPONENT_ID, v_ACCOUNT_SERVICE_ID, v_QUANTITY, v_BILL_CYCLE_MONTH);
			ELSE
				v_RATE := GET_COMPONENT_TIERED_RATE(p_COMPONENT.COMPONENT_ID, v_QUANTITY, v_BILL_CYCLE_MONTH);
			END IF;
		ELSIF v_RATE_STRUCTURE = 'MARKET' THEN
			IF v_CUSTOM_CHARGE THEN
				v_RATE := GET_COMPONENT_MARKET_RATE(p_COMPONENT.COMPONENT_ID, v_ACCOUNT_SERVICE_ID, p_COMPONENT.MARKET_PRICE_ID, v_BILL_CYCLE_MONTH);
			ELSE
				v_RATE := GET_COMPONENT_MARKET_RATE(p_COMPONENT.COMPONENT_ID, p_COMPONENT.MARKET_PRICE_ID, v_BILL_CYCLE_MONTH);
			END IF;
		ELSE
			v_RATE := 0;
		END IF;

		IF v_RATE_STRUCTURE = 'IMBALANCE' THEN
			IF v_CUSTOM_CHARGE THEN
				APPLY_COMPONENT_IMBALANCE(p_PRODUCT_ID, p_COMPONENT.COMPONENT_ID, v_ACCOUNT_SERVICE_ID, p_DETERMINANTS(v_INDEX).PLAN, v_QUANTITY, v_BILL_CYCLE_MONTH, p_CHARGE_COMPONENTS);
			ELSE
				APPLY_COMPONENT_IMBALANCE(p_PRODUCT_ID, p_COMPONENT.COMPONENT_ID, p_DETERMINANTS(v_INDEX).PLAN, v_QUANTITY, v_BILL_CYCLE_MONTH, p_CHARGE_COMPONENTS);
			END IF;
		ELSE
			v_FACTOR := GET_COMPONENT_FACTOR(p_COMPONENT.COMPONENT_ID, v_BILL_CYCLE_MONTH);
			v_AMOUNT := v_QUANTITY * v_RATE * v_FACTOR;
			p_CHARGE_COMPONENTS.EXTEND;
			p_CHARGE_COMPONENTS(p_CHARGE_COMPONENTS.LAST) := CHARGE_COMPONENT_TYPE(p_PRODUCT_ID, p_COMPONENT.COMPONENT_ID, v_ACCOUNT_SERVICE_ID, p_DETERMINANTS(v_INDEX).CUSTOMER_ID, CONSTANTS.NOT_ASSIGNED, v_CHARGE_TYPE, v_BEGIN_DATE, v_END_DATE, v_BILL_CYCLE_MONTH, v_QUANTITY, v_RATE, v_AMOUNT, v_FACTOR, CONSTANTS.NOT_ASSIGNED, CONSTANTS.NOT_ASSIGNED, CONSTANTS.NOT_ASSIGNED, v_BILL_CODE);
		END IF;

		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG(TO_CHAR(v_BEGIN_DATE) || ',' || TO_CHAR(v_END_DATE) || ',' || TO_CHAR(v_BILL_CYCLE_MONTH) || ',' || TO_CHAR(v_QUANTITY) || ',' || TO_CHAR(v_RATE) || ',' || TO_CHAR(v_AMOUNT) || ',' || TO_CHAR(v_FACTOR) || ',' || v_BILL_CODE);
		END IF;

		v_INDEX := p_DETERMINANTS.NEXT(v_INDEX);
	END LOOP;

END APPLY_CONSUMPTION_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE APPLY_PRODUCT_COMPONENT_CHARGE
	(
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_PERIOD_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ENROLLMENT IN NUMBER,
	p_LOSS_FACTOR IN NUMBER,
	p_BILL_CYCLE_ID IN NUMBER,
	p_DETERMINANTS IN DETERMINANT_TABLE,
	p_CHARGE_COMPONENTS IN OUT NOCOPY CHARGE_COMPONENT_TABLE,
    p_NEED_PERIOD_IDs IN BOOLEAN := FALSE,
    p_INTERVAL_DETERMINANTS IN BOOLEAN := FALSE
	) AS

v_CHARGE_TYPE CHAR(1);
v_BEGIN_DATE DATE := TRUNC(p_BEGIN_DATE);
v_END_DATE DATE;
v_QUANTITY NUMBER(16,6);
v_RATE NUMBER(16,6);
v_AMOUNT NUMBER(16,6);
v_FACTOR NUMBER(16,6);
v_ENERGY NUMBER(16,6);
v_DEMAND NUMBER(16,6);
v_RATE_STRUCTURE VARCHAR(16) := UPPER(LTRIM(RTRIM(p_COMPONENT.RATE_STRUCTURE)));

BEGIN

	IF UPPER(p_COMPONENT.CHARGE_TYPE) = 'CONSUMPTION' THEN
		APPLY_CONSUMPTION_CHARGE(p_PRODUCT_ID, p_COMPONENT, p_DETERMINANTS, p_CHARGE_COMPONENTS);
		RETURN;
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('APPLY_PRODUCT_COMPONENT_CHARGE PERIOD_ID=' || TO_CHAR(p_PERIOD_ID) || ', BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE) || ', END_DATE=' || TO_CHAR(p_END_DATE));
		LOGS.LOG_DEBUG('COMPONENT_ID=' || TO_CHAR(p_COMPONENT.COMPONENT_ID) || ', CHARGE_TYPE=' || p_COMPONENT.CHARGE_TYPE || ', RATE_STRUCTURE=' || p_COMPONENT.RATE_STRUCTURE || ', RATE_INTERVAL=' || p_COMPONENT.RATE_INTERVAL || ', UPPER( RATE_STRUCTURE)=' || v_RATE_STRUCTURE);
		LOGS.LOG_DEBUG('<begin>,<end>,<quantity>,<rate>,<amount>,<tax>');
	END IF;

	SELECT DECODE(UPPER(p_COMPONENT.CHARGE_TYPE), 'ENERGY', 'E', 'PEAK DEMAND', 'D', 'SERVICE', 'S', 'DEMAND HOURS', 'H', 'COMMODITY', 'E', 'TRANSPORTATION', 'E', '?') INTO v_CHARGE_TYPE FROM DUAL;
	-- Bugzilla 4967 - Treat transmission and distribution charges as energy if in *WHs
	IF (UPPER(p_COMPONENT.CHARGE_TYPE) = 'TRANSMISSION' OR UPPER(p_COMPONENT.CHARGE_TYPE) = 'DISTRIBUTION') AND (INSTR(UPPER(p_COMPONENT.QUANTITY_UNIT),'WH')>0) THEN
		v_CHARGE_TYPE := 'E';
	END IF;

    v_BEGIN_DATE := GET_INITIAL_DATE_FOR_INTERVAL(v_BEGIN_DATE, p_COMPONENT.RATE_INTERVAL, p_BILL_CYCLE_ID);

	WHILE v_BEGIN_DATE <= p_END_DATE LOOP

		v_END_DATE := GET_NEXT_DATE_FOR_INTERVAL(v_BEGIN_DATE, p_COMPONENT.RATE_INTERVAL, p_BILL_CYCLE_ID);

		IF v_CHARGE_TYPE IN ('E','D','H') THEN
			GET_CHARGE_QUANTITY(p_COMPONENT, p_PERIOD_ID, v_BEGIN_DATE, LEAST(p_END_DATE, v_END_DATE), p_DETERMINANTS, v_ENERGY, v_DEMAND, p_NEED_PERIOD_IDs, p_INTERVAL_DETERMINANTS);
		END IF;

		SELECT DECODE(v_CHARGE_TYPE, 'E', v_ENERGY, 'D', v_DEMAND, 'H', v_ENERGY, 'S', 1.0, 0.0) INTO v_QUANTITY FROM DUAL;
		v_QUANTITY := v_QUANTITY * p_ENROLLMENT * p_LOSS_FACTOR;

		IF v_RATE_STRUCTURE = 'FLAT' THEN
			v_RATE := GET_COMPONENT_FLAT_RATE(p_COMPONENT.COMPONENT_ID, v_QUANTITY, v_BEGIN_DATE);
		ELSIF v_RATE_STRUCTURE = 'BLOCK' THEN
			v_RATE := GET_COMPONENT_BLOCK_RATE(p_COMPONENT.COMPONENT_ID, v_QUANTITY, v_BEGIN_DATE);
		ELSIF v_RATE_STRUCTURE = 'TIERED' THEN
			IF v_CHARGE_TYPE = 'H' THEN
				v_RATE := GET_COMPONENT_TIERED_RATE(p_COMPONENT.COMPONENT_ID, v_ENERGY, v_BEGIN_DATE, v_DEMAND);
			ELSE
				v_RATE := GET_COMPONENT_TIERED_RATE(p_COMPONENT.COMPONENT_ID, v_QUANTITY, v_BEGIN_DATE);
			END IF;
		ELSIF v_RATE_STRUCTURE = 'TIME OF USE' THEN
			v_RATE := GET_COMPONENT_TOU_RATE(p_COMPONENT.COMPONENT_ID, p_PERIOD_ID, v_BEGIN_DATE);
		ELSIF v_RATE_STRUCTURE = 'MARKET' THEN
			v_RATE := GET_COMPONENT_MARKET_RATE(p_COMPONENT.COMPONENT_ID, p_COMPONENT.MARKET_PRICE_ID, v_BEGIN_DATE);
		ELSIF v_RATE_STRUCTURE = 'COMPOSITE' THEN
			v_RATE := GET_COMPOSITE_COMPONENT_RATE(p_COMPONENT.COMPONENT_ID, v_CHARGE_TYPE, p_PERIOD_ID, v_ENERGY, v_DEMAND, v_BEGIN_DATE, v_END_DATE);
-- Re-determine the appropriate v_QUANTITY if the Rate Structure was COMPOSITE, since the resulting selected component may have had a different CHARGE_TYPE.
			v_QUANTITY := GET_COMPOSITE_COMPONENT_QUANT(p_COMPONENT.COMPONENT_ID, v_CHARGE_TYPE, v_ENERGY, v_DEMAND, v_BEGIN_DATE);
		END IF;

		v_FACTOR := GET_COMPONENT_FACTOR(p_COMPONENT.COMPONENT_ID, v_BEGIN_DATE);
		v_AMOUNT := v_QUANTITY * v_RATE * v_FACTOR;
		p_CHARGE_COMPONENTS.EXTEND;
		p_CHARGE_COMPONENTS(p_CHARGE_COMPONENTS.LAST) := CHARGE_COMPONENT_TYPE(p_PRODUCT_ID, p_COMPONENT.COMPONENT_ID, CONSTANTS.NOT_ASSIGNED, CONSTANTS.NOT_ASSIGNED, p_PERIOD_ID, v_CHARGE_TYPE, v_BEGIN_DATE, v_END_DATE, NULL, v_QUANTITY, v_RATE, v_AMOUNT, v_FACTOR, CONSTANTS.NOT_ASSIGNED, CONSTANTS.NOT_ASSIGNED, CONSTANTS.NOT_ASSIGNED, NULL);

		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG(UT.TRACE_DATE(v_BEGIN_DATE) || ',' || UT.TRACE_DATE(v_END_DATE) || ',' || TO_CHAR(v_QUANTITY) || ',' || TO_CHAR(v_RATE) || ',' || TO_CHAR(v_AMOUNT) || ',' || TO_CHAR(v_FACTOR));
		END IF;

		v_BEGIN_DATE := v_END_DATE + 1;

	END LOOP;

END APPLY_PRODUCT_COMPONENT_CHARGE;
---------------------------------------------------------------------------------------------------
PROCEDURE APPLY_PRODUCT_COMPONENT
	(
	p_PRODUCT_ID IN NUMBER,
	p_COMPONENT IN COMPONENT%ROWTYPE,
	p_DETERMINANTS IN DETERMINANT_TABLE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ENROLLMENT IN NUMBER,
	p_LOSS_FACTOR IN NUMBER,
	p_BILL_CYCLE_ID IN NUMBER,
	p_TRACE_ON IN BOOLEAN,
	p_CHARGE_COMPONENTS IN OUT NOCOPY CHARGE_COMPONENT_TABLE,
    p_NEED_PERIOD_IDs IN BOOLEAN := FALSE,
    p_INTERVAL_DETERMINANTS IN BOOLEAN := FALSE
	) AS

v_ELASPSED NUMBER := DBMS_UTILITY.GET_TIME;

CURSOR c_PERIODS IS
	SELECT DISTINCT PERIOD_ID
	FROM SEASON_TEMPLATE
	WHERE TEMPLATE_ID = p_COMPONENT.TEMPLATE_ID;

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('APPLY_PRODUCT_COMPONENT');
		LOGS.LOG_DEBUG('PRODUCT_ID=' || TO_CHAR(p_PRODUCT_ID) || ', COMPONENT_ID=' || TO_CHAR(p_COMPONENT.COMPONENT_ID) || ', BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE) || ', END_DATE=' || TO_CHAR(p_END_DATE));
		LOGS.LOG_DEBUG('ENROLLMENT=' || TO_CHAR(p_ENROLLMENT) || ', LOSS_FACTOR=' || TO_CHAR(p_LOSS_FACTOR));
	END IF;

	p_CHARGE_COMPONENTS.DELETE;

	IF p_DETERMINANTS.COUNT = 0 THEN
		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG('NO DETERMINANTS');
		END IF;
		RETURN;
	END IF;

	IF p_COMPONENT.COMPONENT_ID IS NOT NULL THEN
		IF UPPER(p_COMPONENT.RATE_STRUCTURE) = 'TIME OF USE' THEN
			FOR v_PERIODS IN c_PERIODS LOOP
				APPLY_PRODUCT_COMPONENT_CHARGE(p_PRODUCT_ID, p_COMPONENT, v_PERIODS.PERIOD_ID, p_BEGIN_DATE, p_END_DATE, p_ENROLLMENT, p_LOSS_FACTOR, p_BILL_CYCLE_ID, p_DETERMINANTS, p_CHARGE_COMPONENTS, p_NEED_PERIOD_IDs, p_INTERVAL_DETERMINANTS);
			END LOOP;
		ELSE
			APPLY_PRODUCT_COMPONENT_CHARGE(p_PRODUCT_ID, p_COMPONENT, CONSTANTS.ALL_ID, p_BEGIN_DATE, p_END_DATE, p_ENROLLMENT, p_LOSS_FACTOR, p_BILL_CYCLE_ID, p_DETERMINANTS, p_CHARGE_COMPONENTS, p_NEED_PERIOD_IDs, p_INTERVAL_DETERMINANTS);
		END IF;
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('APPLY_PRODUCT_COMPONENT TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELASPSED));
	END IF;

END APPLY_PRODUCT_COMPONENT;
---------------------------------------------------------------------------------------------------
PROCEDURE APPLY_PRODUCT_COMPONENTS
	(
	p_PRODUCT_ID IN NUMBER,
	p_DETERMINANTS IN DETERMINANT_TABLE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ENROLLMENT IN NUMBER,
	p_LOSS_FACTOR IN NUMBER,
	p_BILL_CYCLE_ID IN NUMBER,
	p_TRACE_ON IN BOOLEAN,
	p_CHARGE_COMPONENTS IN OUT NOCOPY CHARGE_COMPONENT_TABLE
	) AS

v_COMPONENT COMPONENT%ROWTYPE;
v_ELASPSED NUMBER := DBMS_UTILITY.GET_TIME;

CURSOR c_COMPONENTS IS
	SELECT COMPONENT_ID
	FROM PRODUCT_COMPONENT
	WHERE PRODUCT_ID = p_PRODUCT_ID
		AND BEGIN_DATE <= p_END_DATE
		AND NVL(END_DATE, p_END_DATE) >= p_BEGIN_DATE;

CURSOR c_PERIODS IS
	SELECT DISTINCT PERIOD_ID
	FROM SEASON_TEMPLATE
	WHERE TEMPLATE_ID = v_COMPONENT.TEMPLATE_ID;

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('APPLY_PRODUCT_COMPONENTS');
		LOGS.LOG_DEBUG('PRODUCT_ID=' || TO_CHAR(p_PRODUCT_ID) || ', BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE) || ', END_DATE=' || TO_CHAR(p_END_DATE));
		LOGS.LOG_DEBUG('ENROLLMENT=' || TO_CHAR(p_ENROLLMENT) || ', LOSS_FACTOR=' || TO_CHAR(p_LOSS_FACTOR));
	END IF;

	p_CHARGE_COMPONENTS.DELETE;

	IF p_DETERMINANTS.COUNT = 0 THEN
		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG('NO DETERMINANTS');
		END IF;
		RETURN;
	END IF;

	FOR v_COMPONENTS IN c_COMPONENTS LOOP

		v_COMPONENT := GET_COMPONENT(v_COMPONENTS.COMPONENT_ID);

		IF v_COMPONENT.COMPONENT_ID IS NOT NULL THEN
			IF UPPER(v_COMPONENT.RATE_STRUCTURE) = 'TIME OF USE' THEN
				FOR v_PERIODS IN c_PERIODS LOOP
					APPLY_PRODUCT_COMPONENT_CHARGE(p_PRODUCT_ID, v_COMPONENT, v_PERIODS.PERIOD_ID, p_BEGIN_DATE, p_END_DATE, p_ENROLLMENT, p_LOSS_FACTOR, p_BILL_CYCLE_ID, p_DETERMINANTS, p_CHARGE_COMPONENTS);
				END LOOP;
			ELSE
				APPLY_PRODUCT_COMPONENT_CHARGE(p_PRODUCT_ID, v_COMPONENT, CONSTANTS.ALL_ID, p_BEGIN_DATE, p_END_DATE, p_ENROLLMENT, p_LOSS_FACTOR, p_BILL_CYCLE_ID, p_DETERMINANTS, p_CHARGE_COMPONENTS);
			END IF;
		END IF;

	END LOOP;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('APPLY_PRODUCT_COMPONENTS TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELASPSED));
	END IF;

END APPLY_PRODUCT_COMPONENTS;
---------------------------------------------------------------------------------------------------
PROCEDURE APPLY_PRODUCT_COMPONENTS
	(
	p_PRODUCT_ID IN NUMBER,
	p_DETERMINANTS IN DETERMINANT_TABLE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_ENROLLMENT IN NUMBER,
	p_LOSS_FACTOR IN NUMBER,
	p_TRACE_ON IN BOOLEAN,
	p_CHARGE_COMPONENTS IN OUT NOCOPY CHARGE_COMPONENT_TABLE
	) AS

BEGIN

	 APPLY_PRODUCT_COMPONENTS(p_PRODUCT_ID, p_DETERMINANTS, p_BEGIN_DATE, p_END_DATE, 1, 1, CONSTANTS.NOT_ASSIGNED, p_TRACE_ON, p_CHARGE_COMPONENTS);

END APPLY_PRODUCT_COMPONENTS;
---------------------------------------------------------------------------------------------------
PROCEDURE APPLY_PRODUCT_COMPONENTS
	(
	p_PRODUCT_ID IN NUMBER,
	p_DETERMINANTS IN DETERMINANT_TABLE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TRACE_ON IN BOOLEAN,
	p_CHARGE_COMPONENTS IN OUT NOCOPY CHARGE_COMPONENT_TABLE
	) AS

BEGIN

	 APPLY_PRODUCT_COMPONENTS(p_PRODUCT_ID, p_DETERMINANTS, p_BEGIN_DATE, p_END_DATE, 1, 1, p_TRACE_ON, p_CHARGE_COMPONENTS);

END APPLY_PRODUCT_COMPONENTS;
---------------------------------------------------------------------------------------------------
FUNCTION GET_FORWARD_PRICE
	(
	p_MARKET_PRICE_ID IN NUMBER,
	p_MONTH IN DATE,
	p_TYPE IN CHAR
	) RETURN NUMBER AS
v_FORWARD_PRICE MARKET_FORWARD_PRICE%ROWTYPE;
v_PRICE NUMBER;
BEGIN
	BEGIN
		-- select row for this product with the highest contract_date
		SELECT * INTO v_FORWARD_PRICE
		FROM MARKET_FORWARD_PRICE A
		WHERE MARKET_PRICE_ID = p_MARKET_PRICE_ID
			AND CONTRACT_MONTH = p_MONTH
			AND CONTRACT_TYPE = p_TYPE
			AND CONTRACT_DATE = (SELECT MAX(CONTRACT_DATE) FROM MARKET_FORWARD_PRICE X
							WHERE X.MARKET_PRICE_ID = A.MARKET_PRICE_ID
								AND X.CONTRACT_MONTH = A.CONTRACT_MONTH
								AND X.CONTRACT_TYPE = A.CONTRACT_TYPE);
	EXCEPTION
		WHEN OTHERS THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN 0;
	END;
	-- make sure we are dealing with zeroes instead of nulls
	IF v_FORWARD_PRICE.BID_PRICE IS NULL THEN
		v_FORWARD_PRICE.BID_PRICE := 0;
	END IF;
	IF v_FORWARD_PRICE.ASK_PRICE IS NULL THEN
		v_FORWARD_PRICE.ASK_PRICE := 0;
	END IF;
	-- if they are there, we want to use bid and ask prices
	-- else, we'll use low and high prices
	IF v_FORWARD_PRICE.BID_PRICE = 0 AND v_FORWARD_PRICE.ASK_PRICE = 0 THEN
		-- make sure we are dealing with zeroes instead of nulls
		IF v_FORWARD_PRICE.LOW_PRICE IS NULL THEN
			v_FORWARD_PRICE.LOW_PRICE := 0;
		END IF;
		IF v_FORWARD_PRICE.HIGH_PRICE IS NULL THEN
			v_FORWARD_PRICE.HIGH_PRICE := 0;
		END IF;
		-- if only one, use that one
		IF v_FORWARD_PRICE.LOW_PRICE = 0 OR v_FORWARD_PRICE.HIGH_PRICE = 0 THEN
			SELECT GREATEST(v_FORWARD_PRICE.LOW_PRICE,v_FORWARD_PRICE.HIGH_PRICE)
			INTO v_PRICE FROM DUAL;
			RETURN v_PRICE;
		ELSE
		-- else return average
			RETURN (v_FORWARD_PRICE.LOW_PRICE+v_FORWARD_PRICE.HIGH_PRICE)/2;
		END IF;
	ELSE
		-- if only one, use that one
		IF v_FORWARD_PRICE.BID_PRICE = 0 OR v_FORWARD_PRICE.ASK_PRICE = 0 THEN
			SELECT GREATEST(v_FORWARD_PRICE.BID_PRICE,v_FORWARD_PRICE.ASK_PRICE)
			INTO v_PRICE FROM DUAL;
			RETURN v_PRICE;
		ELSE
		-- else return average
			RETURN (v_FORWARD_PRICE.BID_PRICE+v_FORWARD_PRICE.ASK_PRICE)/2;
		END IF;
	END IF;
END GET_FORWARD_PRICE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_HOURLY_FORWARD_PRICES
	(
	p_MARKET_PRICE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_WORK_ID OUT NUMBER
	) AS
v_MONTH DATE;
v_HOUR DATE;
v_END_HOUR DATE;
v_ONPEAK_PRICE NUMBER;
v_OFFPEAK_PRICE NUMBER;
BEGIN
	v_MONTH := TRUNC(p_BEGIN_DATE,'MONTH');
	UT.GET_RTO_WORK_ID(p_WORK_ID);
	WHILE v_MONTH <= p_END_DATE LOOP
		-- Get On-Peak price info
		v_ONPEAK_PRICE := GET_FORWARD_PRICE(p_MARKET_PRICE_ID, v_MONTH, 'P');
		IF v_ONPEAK_PRICE = 0 THEN
			-- no peak? then get around-the-clock price
			v_ONPEAK_PRICE := GET_FORWARD_PRICE(p_MARKET_PRICE_ID, v_MONTH, 'A');
		END IF;
		-- Get Off-Peak price info
		v_OFFPEAK_PRICE := GET_FORWARD_PRICE(p_MARKET_PRICE_ID, v_MONTH, 'O');
		IF v_OFFPEAK_PRICE = 0 THEN
			-- no off-peak? then get around-the-clock price
			v_OFFPEAK_PRICE := GET_FORWARD_PRICE(p_MARKET_PRICE_ID, v_MONTH, 'A');
		END IF;
		SELECT GREATEST(v_MONTH,p_BEGIN_DATE) INTO v_HOUR FROM DUAL;
		v_END_HOUR := ADD_SECONDS_TO_DATE(ADD_MONTHS(v_MONTH,1),-1);
		SELECT LEAST(v_END_HOUR,p_END_DATE) INTO v_END_HOUR FROM DUAL;
		WHILE v_HOUR <= v_END_HOUR LOOP
			IF TO_CHAR(v_HOUR,'HH24') < 7 OR TO_CHAR(v_HOUR,'HH24') > 23 THEN
				-- off-peak hour
				UT.POST_RTO_WORK(p_WORK_ID,0,p_MARKET_PRICE_ID,v_HOUR,v_OFFPEAK_PRICE);
			ELSE
				-- on-peak hour
				UT.POST_RTO_WORK(p_WORK_ID,0,p_MARKET_PRICE_ID,v_HOUR,v_ONPEAK_PRICE);
			END IF;
			v_HOUR := v_HOUR + 1/24;
		END LOOP;
		v_MONTH := ADD_MONTHS(v_MONTH,1);
	END LOOP;
END GET_HOURLY_FORWARD_PRICES;
---------------------------------------------------------------------------------------------------
END CU;
/
