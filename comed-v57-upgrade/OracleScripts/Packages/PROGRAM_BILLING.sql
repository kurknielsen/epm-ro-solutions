CREATE OR REPLACE PACKAGE PROGRAM_BILLING IS
-- $Revision: 1.6 $

-- Calculates SmartGrid program billing determinants for specified bill cycles or
-- accounts and specified programs for all applicable bill periods in the specified date
-- range.
-- %param p_ENTITY_IDs			List of account or bill cycle entity IDs. This can
--			be a singleton	collection containing
--			CONSTANTS.ALL_ID.
-- %param p_ENTITIES_ARE_ACCOUNTS	Flag indicating whether or not the above entity
--			list contains bill cycles or accounts.
-- %param p_PROGRAM_IDs		List of SmartGrid program entity IDs. This can be a
--			singleton collection containing CONSTANTS.ALL_ID.
-- %param p_BEGIN_DATE			Start of date range to calculate.
-- %param p_END_DATE			End of date range to calculate.
-- %param p_TRACE_ON			Flag indicating whether or not trace/debug data
--			should be emitted during processing.
-- %param p_PROCESS_ID			ID of PROCESS_LOG entry that represents this
--			calculation.
-- %param p_PROCESS_STATUS		Final disposition of process. See LOGS.c_LEVEL_*
--			constants for possible values.
-- %param p_MESSAGE			Process¿s finish message.
FUNCTION WHAT_VERSION RETURN VARCHAR2;

PROCEDURE CALC_PROGRAM_BILLS
	(
	p_ENTITY_IDs IN NUMBER_COLLECTION,
	p_ENTITIES_ARE_ACCOUNTS IN NUMBER,
	p_PROGRAM_IDs IN NUMBER_COLLECTION,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_PROCESS_ID OUT NUMBER,
	p_PROCESS_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR2
	);

END PROGRAM_BILLING;
/
CREATE OR REPLACE PACKAGE BODY PROGRAM_BILLING IS

c_DETERMINANT_TYPE_MONTLY_LIM 	CONSTANT VARCHAR2(32) := 'DLC Monthly Limit';
c_DETERMINANT_TYPE_DLC_ONE_TI 	CONSTANT VARCHAR2(32) := 'DLC One-Time Fixed';
c_DETERMINANT_TYPE_DLC_ANNUAL 	CONSTANT VARCHAR2(32) := 'DLC Annual';
c_DETERMINANT_TYPE_DLC_MONTHLY	CONSTANT VARCHAR2(32) := 'DLC Monthly';
c_DETERMINANT_TYPE_DLC_DAILY		CONSTANT VARCHAR2(32) := 'DLC Daily';
c_DETERMINANT_TYPE_DLC_PER_EVT 	CONSTANT VARCHAR2(32) := 'DLC Per Event';
c_DETERMINANT_TYPE_DLC_EVT_INT 	CONSTANT VARCHAR2(32) := 'DLC Per Event Interval';
c_DETERMINANT_TYPE_PTR_PER_EVT	CONSTANT VARCHAR2(32) := 'Per Event Peak Time Rebate';
c_DETERMINANT_TYPE_PTR_PER_KWH	CONSTANT VARCHAR2(32) := 'Per KWh Peak Time Rebate';
c_DETERMINANT_TYPE_CPP			CONSTANT VARCHAR2(32) := 'Critical Peak Premium';
c_DETERMINANT_TYPE_RTP			CONSTANT VARCHAR2(32) := 'Real-Time Pricing';

FUNCTION WHAT_VERSION RETURN VARCHAR2 IS
BEGIN
    RETURN '$Revision: 1.6 $';
END WHAT_VERSION;
-----------------------------------------------------------------
-- REMOVE EXISTING BILL RESULT AND BILL SUMMARY RECORDS FOR THE SPECIFIED ENTITIES AND
-- PROGRAMS, THIS CLEARS OUT ANY EXISTING BILLING DATA SO WE CAN GENERATE OUR OWN
PROCEDURE REMOVE_EXISTING_BILL_RESULTS
(
	p_ENTITY_IDs IN NUMBER_COLLECTION,
	p_ENTITIES_ARE_ACCOUNTS IN NUMBER,
	p_PROGRAM_IDs IN NUMBER_COLLECTION,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
) AS

BEGIN


	IF p_ENTITIES_ARE_ACCOUNTS = 1 THEN

		DELETE FROM PROGRAM_BILL_RESULT RST
		WHERE RST.ACCOUNT_ID IN (SELECT A.ACCOUNT_ID
								FROM TABLE(CAST(p_ENTITY_IDs AS NUMBER_COLLECTION)) X,
									ACCOUNT A
								WHERE A.ACCOUNT_ID = X.COLUMN_VALUE
									OR X.COLUMN_VALUE = CONSTANTS.ALL_ID)
			AND RST.BILL_SUMMARY_ID IN (SELECT SUM.BILL_SUMMARY_ID
										FROM PROGRAM_BILL_SUMMARY SUM,
											TABLE(CAST(p_PROGRAM_IDs AS NUMBER_COLLECTION)) PROGS
										WHERE (SUM.PROGRAM_ID = PROGS.COLUMN_VALUE OR
													PROGS.COLUMN_VALUE = SD.g_ALL_DATA_ENTITY_ID)
											AND SUM.BEGIN_DATE <= p_END_DATE
											AND SUM.END_DATE >= p_BEGIN_DATE);

	ELSE

		DELETE FROM PROGRAM_BILL_SUMMARY SUM
		WHERE SUM.PROGRAM_ID IN (SELECT P.PROGRAM_ID
								FROM PROGRAM P, TABLE(CAST(p_PROGRAM_IDs AS NUMBER_COLLECTION)) X
								WHERE P.PROGRAM_ID = X.COLUMN_VALUE
									OR X.COLUMN_VALUE = SD.g_ALL_DATA_ENTITY_ID)
			AND SUM.BILL_CYCLE_ID IN (SELECT BC.BILL_CYCLE_ID
									  FROM TABLE(CAST(p_ENTITY_IDs AS NUMBER_COLLECTION)) X,
											BILL_CYCLE BC
									  WHERE BC.BILL_CYCLE_ID = X.COLUMN_VALUE
											OR X.COLUMN_VALUE = CONSTANTS.ALL_ID)
			AND SUM.BEGIN_DATE <= p_END_DATE
			AND SUM.END_DATE >= p_BEGIN_DATE;

	END IF;

END REMOVE_EXISTING_BILL_RESULTS;
-----------------------------------------------------------------
-- SIMPLE SEQUENCE ACCESSOR
FUNCTION GET_PROGRAM_BILL_ID RETURN NUMBER IS

	v_RESULT_ID PROGRAM_BILL_SUMMARY.BILL_SUMMARY_ID%TYPE;

BEGIN

	SELECT PROGRAM_BILL_ID.NEXTVAL
	INTO v_RESULT_ID
	FROM DUAL;

	RETURN v_RESULT_ID;
END GET_PROGRAM_BILL_ID;
-----------------------------------------------------------------
-- IF WE CAN'T FIND THE CORRESPONDING SUMMARY ID, GENERATE IT
-- AND INSERT A CORRESPONDING RECORD INTO PROGRAM_BILL_SUMMARY
FUNCTION GET_BILL_SUMMARY_ID
(
	p_PROGRAM_ID IN NUMBER,
	p_BILL_CYCLE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE
) RETURN NUMBER IS

	v_RESULT_ID PROGRAM_BILL_SUMMARY.BILL_SUMMARY_ID%TYPE;

	v_END_DATE DATE;
	v_BILL_MONTH DATE;

BEGIN

	BEGIN
		SELECT SUM.BILL_SUMMARY_ID
		INTO v_RESULT_ID
		FROM PROGRAM_BILL_SUMMARY SUM
		WHERE SUM.PROGRAM_ID = p_PROGRAM_ID
			AND SUM.BILL_CYCLE_ID = p_BILL_CYCLE_ID
			AND SUM.BEGIN_DATE = p_BEGIN_DATE;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			v_RESULT_ID := GET_PROGRAM_BILL_ID;

			SELECT BCP.BILL_CYCLE_MONTH, BCP.END_DATE
			INTO v_BILL_MONTH, v_END_DATE
			FROM BILL_CYCLE_PERIOD BCP
			WHERE BCP.BILL_CYCLE_ID = p_BILL_CYCLE_ID
				AND BCP.BEGIN_DATE = p_BEGIN_DATE;


			INSERT INTO PROGRAM_BILL_SUMMARY (BILL_SUMMARY_ID, PROGRAM_ID, BILL_CYCLE_ID,
					BEGIN_DATE, END_DATE, BILL_MONTH, NUM_SERVICE_LOCATIONS, ENTRY_DATE)
			VALUES (v_RESULT_ID, p_PROGRAM_ID, p_BILL_CYCLE_ID, p_BEGIN_DATE, v_END_DATE,
				v_BILL_MONTH, 0, SYSDATE);
	END;

	RETURN v_RESULT_ID;
END GET_BILL_SUMMARY_ID;
-----------------------------------------------------------------
-- IF WE CAN'T FIND THE CORRESPONDING RESULT ID, GENERATE IT
-- AND INSERT A CORRESPONDING RECORD INTO PROGRAM_BILL_RESULT
FUNCTION GET_BILL_RESULT_ID
(
	p_SUMMARY_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER
) RETURN NUMBER IS

	v_RESULT_ID PROGRAM_BILL_RESULT.BILL_RESULT_ID%TYPE;

BEGIN

	BEGIN

		SELECT RST.BILL_RESULT_ID
		INTO v_RESULT_ID
		FROM PROGRAM_BILL_RESULT RST
		WHERE RST.BILL_SUMMARY_ID = p_SUMMARY_ID
			AND RST.ACCOUNT_ID = p_ACCOUNT_ID
			AND RST.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			v_RESULT_ID := GET_PROGRAM_BILL_ID;

			INSERT INTO PROGRAM_BILL_RESULT (BILL_RESULT_ID, BILL_SUMMARY_ID, ACCOUNT_ID,
				SERVICE_LOCATION_ID, PROCESS_ID, ENTRY_DATE)
			VALUES ( v_RESULT_ID, p_SUMMARY_ID, p_ACCOUNT_ID, p_SERVICE_LOCATION_ID,
				LOGS.CURRENT_PROCESS_ID, SYSDATE);

	END;

	RETURN v_RESULT_ID;
END GET_BILL_RESULT_ID;
-----------------------------------------------------------------
-- IF WE CAN'T FIND THE CORRESPONDING DETERMINANT ID, GENERATE IT
-- AND INSERT A CORRESPONDING RECORD INTO PROGRAM_BILL_DETERMINANT
FUNCTION GET_BILL_DETERMINANT_ID
	(
	p_BILL_RESULT_ID IN NUMBER,
	p_DETERMINANT_TYPE IN VARCHAR2,
	p_DER_TYPE IN NUMBER,
	p_HAS_SUB_DAILY_DETAILS IN NUMBER,
	p_BILL_QUANTITY_UNIT IN VARCHAR2
	) RETURN NUMBER IS

	v_RESULT_ID PROGRAM_BILL_DETERMINANT.BILL_DETERMINANT_ID%TYPE;

BEGIN

	BEGIN

		SELECT DET.BILL_DETERMINANT_ID
		INTO v_RESULT_ID
		FROM PROGRAM_BILL_DETERMINANT DET
		WHERE DET.BILL_RESULT_ID = p_BILL_RESULT_ID
			AND DET.DETERMINANT_TYPE = p_DETERMINANT_TYPE
			AND DET.DER_TYPE_ID = p_DER_TYPE;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			v_RESULT_ID := GET_PROGRAM_BILL_ID;

			INSERT INTO PROGRAM_BILL_DETERMINANT (BILL_DETERMINANT_ID, BILL_RESULT_ID,
					DETERMINANT_TYPE, DER_TYPE_ID, HAS_SUB_DAILY_DETAILS, BILL_QUANTITY_UNIT)
			VALUES (V_RESULT_ID, p_BILL_RESULT_ID, p_DETERMINANT_TYPE, p_DER_TYPE,
					p_HAS_SUB_DAILY_DETAILS, p_BILL_QUANTITY_UNIT);
	END;

	RETURN v_RESULT_ID;
END GET_BILL_DETERMINANT_ID;
-----------------------------------------------------------------
-- VERIFY THAT THE DER'S TYPE IS SPECIFIED AS AN ELIGIBLE TYPE FOR THE
-- PROGRAM GIVEN, IF NOT LOG A WARNING
FUNCTION VERIFY_DER_PROGRAM
	(
	p_PROGRAM_ID IN NUMBER,
	p_DER_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_PERIOD_BEGIN IN DATE,
	p_RESULT_STATUS IN OUT VARCHAR2
	) RETURN BOOLEAN IS

	v_TEST PLS_INTEGER;

BEGIN

	SELECT COUNT(1)
	INTO v_TEST
	FROM PROGRAM_DER_TYPE PDT,
		DISTRIBUTED_ENERGY_RESOURCE DER
	WHERE DER.DER_ID = p_DER_ID
		AND PDT.PROGRAM_ID = p_PROGRAM_ID
		AND PDT.DER_TYPE_ID = DER.DER_TYPE_ID;

	IF v_TEST = 0 THEN
		LOGS.LOG_WARN(TEXT_UTIL.TO_CHAR_ENTITY(p_DER_ID, EC.ED_DER, TRUE) || ' is assigned to ' ||
			TEXT_UTIL.TO_CHAR_ENTITY(p_PROGRAM_ID, EC.ED_PROGRAM, TRUE) || ' but it is not a valid DER Type '
			|| ' for that program.',
			p_SOURCE_ENTITY_ID => p_SERVICE_LOCATION_ID,
			p_SOURCE_DOMAIN_ID => EC.ED_SERVICE_LOCATION,
			p_SOURCE_DATE => p_PERIOD_BEGIN);
		p_RESULT_STATUS := 'Warning';
		RETURN FALSE;
	END IF;

	RETURN TRUE;

END VERIFY_DER_PROGRAM;
-----------------------------------------------------------------
-- CALC THE DETERMINANT QUANTITY, AMOUNT AND RATE BY LOOKING AT ITS
-- CHILDREN DETAILS
PROCEDURE CALC_DETERMINANT_ROLLUP
(
	p_DETERMINANT_ID IN NUMBER
) AS

	v_BILL_QUANTITY PROGRAM_BILL_DETERMINANT.BILL_QUANTITY%TYPE;
	v_BILL_AMOUNT PROGRAM_BILL_DETERMINANT.BILL_AMOUNT%TYPE;
	v_BILL_RATE PROGRAM_BILL_DETERMINANT.BILL_RATE%TYPE;

BEGIN

	SELECT SUM(NVL(DTL.BILL_QUANTITY,0)) BILL_QUANT,
		CASE WHEN SUM(NVL(DTL.BILL_QUANTITY,0)) = 0 THEN
			AVG(NVL(DTL.BILL_RATE,0))
		ELSE
			SUM(NVL(DTL.BILL_AMOUNT,0))/SUM(NVL(DTL.BILL_QUANTITY,0))
		END,
		SUM(NVL(DTL.BILL_AMOUNT,0))
	INTO v_BILL_QUANTITY, v_BILL_RATE, v_BILL_AMOUNT
	FROM PROGRAM_BILL_DETERMINANT_DTL DTL
	WHERE DTL.BILL_DETERMINANT_ID = p_DETERMINANT_ID;

	UPDATE PROGRAM_BILL_DETERMINANT DT
	SET DT.BILL_QUANTITY = v_BILL_QUANTITY,
		DT.BILL_RATE = v_BILL_RATE,
		DT.BILL_AMOUNT = v_BILL_AMOUNT
	WHERE DT.BILL_DETERMINANT_ID = p_DETERMINANT_ID;

END CALC_DETERMINANT_ROLLUP;
-----------------------------------------------------------------
--  CALC THE RESULT ROLLUP BY LOOKING AT ITS DETERMINANT CHILDREN
-- (FIRST FORCE THE DETERMINANT RECORDS TO ROLLUP)
PROCEDURE CALC_RESULT_ROLLUP
(
	p_BILL_RESULT_ID IN NUMBER,
	p_RESULT_STATUS IN VARCHAR2
) AS

	v_MONTHLY_LIMIT NUMBER;
	v_AMOUNT NUMBER;

BEGIN

	-- FIRST CALC THE DETERMINANT ROLLUPS
	FOR v_DET_REC IN (SELECT DT.BILL_DETERMINANT_ID
				  FROM PROGRAM_BILL_DETERMINANT DT
				  WHERE DT.BILL_RESULT_ID = p_BILL_RESULT_ID
				  	AND DT.DETERMINANT_TYPE <> c_DETERMINANT_TYPE_MONTLY_LIM) LOOP
		CALC_DETERMINANT_ROLLUP(v_DET_REC.BILL_DETERMINANT_ID);
	END LOOP;

	SELECT MIN(DT.BILL_AMOUNT)
	INTO v_MONTHLY_LIMIT
	FROM PROGRAM_BILL_DETERMINANT DT
	WHERE DT.BILL_RESULT_ID = p_BILL_RESULT_ID
		AND DT.DETERMINANT_TYPE = c_DETERMINANT_TYPE_MONTLY_LIM;

	SELECT SUM(NVL(DT.BILL_AMOUNT,0))
	INTO v_AMOUNT
	FROM PROGRAM_BILL_DETERMINANT DT
	WHERE DT.BILL_RESULT_ID = p_BILL_RESULT_ID
		AND DT.DETERMINANT_TYPE <> c_DETERMINANT_TYPE_MONTLY_LIM;

	UPDATE PROGRAM_BILL_RESULT RST
	SET RST.DETERMINANT_AMOUNT = v_AMOUNT,
		RST.BILL_AMOUNT = LEAST(v_AMOUNT, NVL(v_MONTHLY_LIMIT, v_AMOUNT)),
		RST.RESULT_STATUS = p_RESULT_STATUS
	WHERE RST.BILL_RESULT_ID = p_BILL_RESULT_ID;

END CALC_RESULT_ROLLUP;
-----------------------------------------------------------------
-- CALC THE SUMMARY ROLLUP
PROCEDURE CALC_SUMMARY_ROLLUP
(
	p_SUMMARY_ID IN NUMBER
) AS

v_NUM_SL PROGRAM_BILL_SUMMARY.NUM_SERVICE_LOCATIONS%TYPE;
v_NUM_ERR PROGRAM_BILL_SUMMARY.NUM_ERRORS%TYPE;
v_NUM_WARN PROGRAM_BILL_SUMMARY.NUM_WARNINGS%TYPE;
v_BILL_AMT PROGRAM_BILL_SUMMARY.BILL_AMOUNT%TYPE;

BEGIN

	SELECT SUM(CASE WHEN RST.RESULT_STATUS = 'Error' THEN
			1
		   ELSE
		    NULL
		   END),
		   SUM(CASE WHEN RST.RESULT_STATUS = 'Warning' THEN
		    1
		   ELSE
		    NULL
		   END),
		   COUNT(1),
		   SUM(NVL(RST.BILL_AMOUNT,0))
	INTO v_NUM_ERR, v_NUM_WARN, v_NUM_SL, v_BILL_AMT
	FROM PROGRAM_BILL_RESULT RST
	WHERE RST.BILL_SUMMARY_ID = p_SUMMARY_ID;

	UPDATE PROGRAM_BILL_SUMMARY SUMM
	SET SUMM.NUM_SERVICE_LOCATIONS = v_NUM_SL,
		SUMM.NUM_WARNINGS = v_NUM_WARN,
		SUMM.NUM_ERRORS = v_NUM_ERR,
		SUMM.BILL_AMOUNT = v_BILL_AMT
	WHERE SUMM.BILL_SUMMARY_ID = p_SUMMARY_ID;

END CALC_SUMMARY_ROLLUP;
-----------------------------------------------------------------
-- DLC PAYMENTS
PROCEDURE CALC_DLC_PAYMENTS
	(
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_PROGRAM_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SL_TIME_ZONE IN VARCHAR2,
	p_PERIOD_BEGIN IN DATE,
	p_PERIOD_END IN DATE,
	p_BILL_RESULT_ID IN NUMBER,
	p_RESULT_STATUS IN OUT VARCHAR2
	) AS

	v_BEGIN_DATE DATE := GREATEST(p_BEGIN_DATE, p_PERIOD_BEGIN);
	v_END_DATE DATE := LEAST(p_END_DATE, p_PERIOD_END);

	v_BEGIN_TIME DATE;
	v_END_TIME DATE;

	v_ANNIVERSARY DATE;
	v_AMOUNT NUMBER;

	v_DETERMINANT_ID PROGRAM_BILL_DETERMINANT.BILL_DETERMINANT_ID%TYPE;

	v_TEST PLS_INTEGER;

BEGIN

	p_RESULT_STATUS := 'Success';

	UT.CUT_DATE_RANGE(CONSTANTS.ELECTRIC_MODEL, v_BEGIN_DATE, v_END_DATE, p_SL_TIME_ZONE,
		v_BEGIN_TIME, v_END_TIME);

	-- we do one-time payments seperately since we want to pay the first time the
	-- device was ever enrolled and on the anniversary
	FOR v_REC IN ( -- FIRST, GET THE FIRST DAY OF DER ENROLLMENTS
				    SELECT PAY.PAYMENT_TYPE, PAY.DER_TYPE_ID, PAY.AMOUNT,
						MIN(GREATEST(DER.BEGIN_DATE, DP.BEGIN_DATE)) AS BEGIN_DATE,
						DER.DER_ID, NVL(DP.COUNT, 1) AS DER_COUNT
					FROM PROGRAM_DER_PAYMENT PAY,
						DISTRIBUTED_ENERGY_RESOURCE DER,
						DER_PROGRAM DP
					WHERE PAY.PROGRAM_ID = p_PROGRAM_ID
						AND PAY.PAYMENT_TYPE IN (DEMAND_RESPONSE_UTIL.c_PAYMENT_TYPE_ONE_TIME,
													DEMAND_RESPONSE_UTIL.c_PAYMENT_TYPE_ANNUAL)
						AND PAY.DER_TYPE_ID <> CONSTANTS.NOT_ASSIGNED
						AND DER.DER_TYPE_ID = PAY.DER_TYPE_ID
						AND DER.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
						AND DP.DER_ID = DER.DER_ID
						AND DP.PROGRAM_ID = p_PROGRAM_ID
					GROUP BY PAY.PAYMENT_TYPE,
						PAY.DER_TYPE_ID,
						PAY.AMOUNT,
						DER.DER_ID,
						NVL(DP.COUNT, 1)

					UNION ALL

					-- NEXT, GET THE FIRST DAY OF SL ENROLLMENTS (FIRST DAY ANY RESOURCE WAS ENROLLED)
					SELECT PAY.PAYMENT_TYPE, PAY.DER_TYPE_ID, PAY.AMOUNT,
						MIN(GREATEST(DER.BEGIN_DATE, DP.BEGIN_DATE)) AS BEGIN_DATE,
						NULL AS DER_ID, 1 AS DER_COUNT
					FROM PROGRAM_DER_PAYMENT PAY,
						DISTRIBUTED_ENERGY_RESOURCE DER,
						DER_PROGRAM DP,
						PROGRAM_DER_TYPE PDT
					WHERE PAY.PROGRAM_ID = p_PROGRAM_ID
						AND PAY.PAYMENT_TYPE IN (DEMAND_RESPONSE_UTIL.c_PAYMENT_TYPE_ONE_TIME,
													DEMAND_RESPONSE_UTIL.c_PAYMENT_TYPE_ANNUAL)
						AND PAY.DER_TYPE_ID = CONSTANTS.NOT_ASSIGNED
						AND DER.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
						AND PDT.PROGRAM_ID = PAY.PROGRAM_ID
						AND DER.DER_TYPE_ID = PDT.DER_TYPE_ID
						AND DP.DER_ID = DER.DER_ID
						AND DP.PROGRAM_ID = p_PROGRAM_ID
					GROUP BY PAY.PAYMENT_TYPE,
						PAY.DER_TYPE_ID,
						PAY.AMOUNT) LOOP

		IF v_REC.DER_ID IS NULL OR VERIFY_DER_PROGRAM(p_PROGRAM_ID, v_REC.DER_ID,
						p_SERVICE_LOCATION_ID, p_PERIOD_BEGIN, p_RESULT_STATUS) THEN

			-- IF THE SL OR RESOURCE ENROLLED FOR THE FIRST TIME IN THIS PERIOD, GIVE THEM THE ONE TIME PAYMENT
			IF v_REC.PAYMENT_TYPE = DEMAND_RESPONSE_UTIL.c_PAYMENT_TYPE_ONE_TIME THEN
				IF v_REC.BEGIN_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE THEN
					v_DETERMINANT_ID := GET_BILL_DETERMINANT_ID(p_BILL_RESULT_ID,
																c_DETERMINANT_TYPE_DLC_ONE_TI,
																v_REC.DER_TYPE_ID,
																0,
																CASE WHEN v_REC.DER_TYPE_ID > 0 THEN
																	'resources'
																ELSE NULL END);

					INSERT INTO PROGRAM_BILL_DETERMINANT_DTL(BILL_DETERMINANT_ID, EVENT_ID, DER_ID,
							DETERMINANT_DATE, BILL_QUANTITY, BILL_RATE, BILL_AMOUNT)
					VALUES ( v_DETERMINANT_ID, NULL, v_REC.DER_ID, v_REC.BEGIN_DATE, v_REC.DER_COUNT,
							v_REC.AMOUNT, v_REC.DER_COUNT * v_REC.AMOUNT);
				END IF;
			ELSIF  v_REC.PAYMENT_TYPE = DEMAND_RESPONSE_UTIL.c_PAYMENT_TYPE_ANNUAL THEN
				IF DATE_UTIL.IS_ANNIVERSARY_IN_PERIOD(v_REC.BEGIN_DATE, v_BEGIN_DATE, v_END_DATE) THEN


					v_ANNIVERSARY := DATE_UTIL.GET_ANNIVERSARY_IN_PERIOD(v_REC.BEGIN_DATE, v_BEGIN_DATE,
																			v_END_DATE);

					-- MAKE SURE THE RESOURCE (OR SERVICE_LOCATION) IS ACTIVE DURING THE ANNIVERSARY
					SELECT COUNT(1)
					INTO v_TEST
					FROM DISTRIBUTED_ENERGY_RESOURCE DER,
						DER_PROGRAM DP
					WHERE DER.DER_ID = NVL(v_REC.DER_ID, DER.DER_ID)
						AND DER.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
						AND v_ANNIVERSARY BETWEEN DER.BEGIN_DATE AND NVL(DER.END_DATE, CONSTANTS.HIGH_DATE)
						AND DP.DER_ID = DER.DER_ID
						AND DP.PROGRAM_ID = p_PROGRAM_ID
						AND v_ANNIVERSARY BETWEEN DP.BEGIN_DATE AND NVL(DP.END_DATE, CONSTANTS.HIGH_DATE);

					IF v_TEST > 0 THEN
						v_DETERMINANT_ID := GET_BILL_DETERMINANT_ID(p_BILL_RESULT_ID,
																	c_DETERMINANT_TYPE_DLC_ANNUAL,
																	v_REC.DER_TYPE_ID,
																	0,
																	CASE WHEN v_REC.DER_TYPE_ID > 0 THEN
																		'year-resources'
																	ELSE 'years' END);

						INSERT INTO PROGRAM_BILL_DETERMINANT_DTL (BILL_DETERMINANT_ID, EVENT_ID, DER_ID,
								DETERMINANT_DATE, BILL_QUANTITY, BILL_RATE, BILL_AMOUNT)
						VALUES ( v_DETERMINANT_ID, NULL, v_REC.DER_ID, v_ANNIVERSARY, v_REC.DER_COUNT, v_REC.AMOUNT,
									v_REC.AMOUNT * v_REC.DER_COUNT);
					END IF;
				END IF;
			END IF;
		END IF;
	END LOOP;

	FOR v_REC IN (SELECT DISTINCT PAY.PAYMENT_TYPE, PAY.DER_TYPE_ID, PAY.AMOUNT, DP.DER_ID, NVL(DP.COUNT, 1) AS DER_COUNT
					FROM PROGRAM_DER_PAYMENT PAY,
						DISTRIBUTED_ENERGY_RESOURCE DER,
						DER_PROGRAM DP
					WHERE PAY.PROGRAM_ID = p_PROGRAM_ID
						AND PAY.PAYMENT_TYPE NOT IN (DEMAND_RESPONSE_UTIL.c_PAYMENT_TYPE_ONE_TIME,
													DEMAND_RESPONSE_UTIL.c_PAYMENT_TYPE_ANNUAL)
						AND (DER.DER_TYPE_ID (+) = PAY.DER_TYPE_ID
							AND DER.DER_TYPE_ID (+) <> CONSTANTS.NOT_ASSIGNED)
						AND (DP.DER_ID IS NOT NULL OR PAY.DER_TYPE_ID = CONSTANTS.NOT_ASSIGNED)
						AND DER.BEGIN_DATE (+) < v_END_DATE
							AND NVL(DER.END_DATE (+), CONSTANTS.HIGH_DATE) >= v_BEGIN_DATE
						AND DER.SERVICE_LOCATION_ID (+) = p_SERVICE_LOCATION_ID
						AND DP.DER_ID (+) = DER.DER_ID
						AND DP.PROGRAM_ID (+) = p_PROGRAM_ID
						AND DP.BEGIN_DATE (+) < v_END_DATE
							AND NVL(DER.END_DATE(+), CONSTANTS.HIGH_DATE) >= v_BEGIN_DATE) LOOP

		IF v_REC.DER_ID IS NULL OR VERIFY_DER_PROGRAM(p_PROGRAM_ID, v_REC.DER_ID,
								p_SERVICE_LOCATION_ID, p_PERIOD_BEGIN, p_RESULT_STATUS) THEN

			IF v_REC.PAYMENT_TYPE = DEMAND_RESPONSE_UTIL.c_PAYMENT_TYPE_MONTHLY THEN

				-- COUNT THE NUMBER OF DAYS OUT OF THE MONTH FOR WHICH THERE WAS AN ENROLLMENT
				-- THIS IS TO ACCOUNT FOR ENROLLMENTS STARTING AND STOPPING IN THE MIDDLE OF THE MONTH
				SELECT COUNT(DISTINCT X.COLUMN_VALUE)
				INTO v_TEST
				FROM TABLE(CAST(DATE_UTIL.DATES_IN_INTERVAL_RANGE(v_BEGIN_DATE, v_END_DATE, CONSTANTS.INTERVAL_DAY)
						AS DATE_COLLECTION)) X,
					DER_PROGRAM DP,
					DISTRIBUTED_ENERGY_RESOURCE DER
				WHERE DP.PROGRAM_ID = p_PROGRAM_ID
					AND X.COLUMN_VALUE BETWEEN DP.BEGIN_DATE AND NVL(DP.END_DATE, CONSTANTS.HIGH_DATE)
					AND DP.DER_ID = NVL(v_REC.DER_ID, DP.DER_ID)
					AND DER.DER_ID = DP.DER_ID
					AND DER.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
					AND X.COLUMN_VALUE BETWEEN DER.BEGIN_DATE AND NVL(DER.END_DATE, CONSTANTS.HIGH_DATE);

				v_AMOUNT := v_TEST / (p_PERIOD_END - p_PERIOD_BEGIN + 1);

				v_DETERMINANT_ID := GET_BILL_DETERMINANT_ID(p_BILL_RESULT_ID,
																c_DETERMINANT_TYPE_DLC_MONTHLY,
																v_REC.DER_TYPE_ID,
																0,
																CASE WHEN v_REC.DER_TYPE_ID > 0 THEN
																	'month-resources'
																ELSE 'months' END);

				INSERT INTO PROGRAM_BILL_DETERMINANT_DTL (BILL_DETERMINANT_ID, EVENT_ID, DER_ID,
							DETERMINANT_DATE, BILL_QUANTITY, BILL_RATE, BILL_AMOUNT)
				VALUES ( v_DETERMINANT_ID, NULL, v_REC.DER_ID, p_PERIOD_BEGIN, v_AMOUNT * v_REC.DER_COUNT, v_REC.AMOUNT,
							v_REC.AMOUNT * v_AMOUNT * v_REC.DER_COUNT);

				NULL;

			ELSIF v_REC.PAYMENT_TYPE = DEMAND_RESPONSE_UTIL.c_PAYMENT_TYPE_DAILY THEN

				SELECT COUNT(DISTINCT X.COLUMN_VALUE)
				INTO v_TEST
				FROM TABLE(CAST(DATE_UTIL.DATES_IN_INTERVAL_RANGE(v_BEGIN_DATE, v_END_DATE, CONSTANTS.INTERVAL_DAY)
						AS DATE_COLLECTION)) X,
					DER_PROGRAM DP,
					DISTRIBUTED_ENERGY_RESOURCE DER
				WHERE DP.PROGRAM_ID = p_PROGRAM_ID
					AND X.COLUMN_VALUE BETWEEN DP.BEGIN_DATE AND NVL(DP.END_DATE, CONSTANTS.HIGH_DATE)
					AND DP.DER_ID = NVL(v_REC.DER_ID, DP.DER_ID)
					AND DER.DER_ID = DP.DER_ID
					AND DER.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
					AND X.COLUMN_VALUE BETWEEN DER.BEGIN_DATE AND NVL(DER.END_DATE, CONSTANTS.HIGH_DATE);

				-- FIRST TEST TO SEE IF ANY DAYS WILL BE ACCRUED, TO AVOID UNNECESSARILY CREATING A
				-- DETERMINANT ID
				IF v_TEST > 0 THEN

					v_DETERMINANT_ID := GET_BILL_DETERMINANT_ID(p_BILL_RESULT_ID,
																	c_DETERMINANT_TYPE_DLC_DAILY,
																	v_REC.DER_TYPE_ID,
																	0,
																	CASE WHEN v_REC.DER_TYPE_ID > 0 THEN
																		'day-resources'
																	ELSE 'days' END);

					-- PUT ONE DETERMINANT_DTL FOR EACH DAY THE DER OR SERVICE_LOCATION IS ACTIVE AND ENROLLED
					INSERT INTO PROGRAM_BILL_DETERMINANT_DTL (BILL_DETERMINANT_ID, EVENT_ID, DER_ID,
							DETERMINANT_DATE, BILL_QUANTITY, BILL_RATE, BILL_AMOUNT)
					SELECT DISTINCT v_DETERMINANT_ID, NULL, v_REC.DER_ID, X.COLUMN_VALUE, v_REC.DER_COUNT, v_REC.AMOUNT,
							v_REC.AMOUNT * v_REC.DER_COUNT
					FROM TABLE(CAST(DATE_UTIL.DATES_IN_INTERVAL_RANGE(v_BEGIN_DATE, v_END_DATE, CONSTANTS.INTERVAL_DAY)
							AS DATE_COLLECTION)) X,
						DER_PROGRAM DP,
						DISTRIBUTED_ENERGY_RESOURCE DER
					WHERE DP.PROGRAM_ID = p_PROGRAM_ID
					AND X.COLUMN_VALUE BETWEEN DP.BEGIN_DATE AND NVL(DP.END_DATE, CONSTANTS.HIGH_DATE)
					AND DP.DER_ID = NVL(v_REC.DER_ID, DP.DER_ID)
					AND DER.DER_ID = DP.DER_ID
					AND DER.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
					AND X.COLUMN_VALUE BETWEEN DER.BEGIN_DATE AND NVL(DER.END_DATE, CONSTANTS.HIGH_DATE);
				END IF;

			ELSIF v_REC.PAYMENT_TYPE = DEMAND_RESPONSE_UTIL.c_PAYMENT_TYPE_PER_EVENT THEN
				--  PER DER PAYMENTS, GET ALL DER PARTICIPATION
				IF v_REC.DER_TYPE_ID <> CONSTANTS.NOT_ASSIGNED THEN
					FOR v_EVENT_REC IN (SELECT EVT.EVENT_ID, PART.DER_ID, EVT.STOP_TIME
										FROM DR_EVENT EVT, DR_EVENT_PARTICIPATION PART, VIRTUAL_POWER_PLANT VPP
										WHERE EVT.VPP_ID = VPP.VPP_ID
											AND VPP.PROGRAM_ID = p_PROGRAM_ID
											AND EVT.STOP_TIME BETWEEN v_BEGIN_TIME AND v_END_TIME
											AND PART.EVENT_ID = EVT.EVENT_ID
											AND PART.DER_ID = v_REC.DER_ID
											AND NOT EXISTS (SELECT 1
															FROM DR_EVENT_EXCEPTION EXCP
															WHERE EXCP.EVENT_ID = EVT.EVENT_ID
																AND EXCP.DER_ID = PART.DER_ID
																AND EXCP.EXCEPTION_TYPE <> DEMAND_RESPONSE_UTIL.c_EXCEPTION_TYPE_FAILURE)) LOOP

							v_DETERMINANT_ID := GET_BILL_DETERMINANT_ID(p_BILL_RESULT_ID,
																c_DETERMINANT_TYPE_DLC_PER_EVT,
																v_REC.DER_TYPE_ID,
																0,
																'event-resources');

							INSERT INTO PROGRAM_BILL_DETERMINANT_DTL (BILL_DETERMINANT_ID, EVENT_ID, DER_ID,
								DETERMINANT_DATE, BILL_QUANTITY, BILL_RATE, BILL_AMOUNT)
							VALUES (v_DETERMINANT_ID, v_EVENT_REC.EVENT_ID, v_REC.DER_ID, v_EVENT_REC.STOP_TIME, v_REC.DER_COUNT, v_REC.AMOUNT,
								v_REC.AMOUNT * v_REC.DER_COUNT);
					END LOOP;
				ELSE
				-- PER SL PAYMENT, WE JUST CARE THAT AT LEAST ONE DER PARTICIPATED W/O FAILING OUT IN SOME WAY
					FOR v_EVENT_REC IN (SELECT DISTINCT EVT.EVENT_ID, EVT.STOP_TIME
											FROM DR_EVENT EVT, DR_EVENT_PARTICIPATION PART, VIRTUAL_POWER_PLANT VPP,
												DISTRIBUTED_ENERGY_RESOURCE DER
											WHERE EVT.VPP_ID = VPP.VPP_ID
												AND VPP.PROGRAM_ID = p_PROGRAM_ID
												AND EVT.STOP_TIME BETWEEN v_BEGIN_TIME AND v_END_TIME
												AND PART.EVENT_ID = EVT.EVENT_ID
												AND DER.DER_ID = PART.DER_ID
												AND DER.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
												AND NOT EXISTS (SELECT 1
																FROM DR_EVENT_EXCEPTION EXCP
																WHERE EXCP.EVENT_ID = EVT.EVENT_ID
																	AND EXCP.DER_ID = PART.DER_ID
																	AND EXCP.EXCEPTION_TYPE <> DEMAND_RESPONSE_UTIL.c_EXCEPTION_TYPE_FAILURE)) LOOP

								v_DETERMINANT_ID := GET_BILL_DETERMINANT_ID(p_BILL_RESULT_ID,
																	c_DETERMINANT_TYPE_DLC_PER_EVT,
																	v_REC.DER_TYPE_ID,
																	0,
																	'events');

								INSERT INTO PROGRAM_BILL_DETERMINANT_DTL (BILL_DETERMINANT_ID, EVENT_ID, DER_ID,
									DETERMINANT_DATE, BILL_QUANTITY, BILL_RATE, BILL_AMOUNT)
								VALUES (v_DETERMINANT_ID, v_EVENT_REC.EVENT_ID, NULL, v_EVENT_REC.STOP_TIME, 1, v_REC.AMOUNT,
									v_REC.AMOUNT );
						END LOOP;
				END IF;


			ELSIF v_REC.PAYMENT_TYPE = DEMAND_RESPONSE_UTIL.c_PAYMENT_TYPE_PER_EVENT_INTVL THEN
				--  PER DER PAYMENTS, GET ALL DER PARTICIPATION
				IF v_REC.DER_TYPE_ID <> CONSTANTS.NOT_ASSIGNED THEN
					FOR v_EVENT_REC IN (SELECT EVT.EVENT_ID, PART.DER_ID, EVT.START_TIME,
												EVT.STOP_TIME AS STOP_TIME,
												P.PROGRAM_INTERVAL
											FROM DR_EVENT EVT, DR_EVENT_PARTICIPATION PART, VIRTUAL_POWER_PLANT VPP,
												PROGRAM P
											WHERE EVT.VPP_ID = VPP.VPP_ID
												AND VPP.PROGRAM_ID = p_PROGRAM_ID
												AND P.PROGRAM_ID = VPP.PROGRAM_ID
												AND NVL(EVT.STOP_TIME,CONSTANTS.HIGH_DATE) >= v_BEGIN_TIME
												AND EVT.START_TIME <= v_END_TIME
												AND PART.EVENT_ID = EVT.EVENT_ID
												AND PART.DER_ID = v_REC.DER_ID
												AND NOT EXISTS (SELECT 1
																FROM DR_EVENT_EXCEPTION EXCP
																WHERE EXCP.EVENT_ID = EVT.EVENT_ID
																	AND EXCP.DER_ID = PART.DER_ID
																	AND EXCP.EXCEPTION_TYPE <> DEMAND_RESPONSE_UTIL.c_EXCEPTION_TYPE_FAILURE)) LOOP

						v_DETERMINANT_ID := GET_BILL_DETERMINANT_ID(p_BILL_RESULT_ID,
																	c_DETERMINANT_TYPE_DLC_EVT_INT,
																	v_REC.DER_TYPE_ID,
																	DATE_UTIL.IS_SUB_DAILY_NUM(
																		v_EVENT_REC.PROGRAM_INTERVAL),
																	'interval-resources');

						INSERT INTO PROGRAM_BILL_DETERMINANT_DTL (BILL_DETERMINANT_ID, EVENT_ID, DER_ID,
										DETERMINANT_DATE, BILL_QUANTITY, BILL_RATE, BILL_AMOUNT)
						SELECT v_DETERMINANT_ID, v_EVENT_REC.EVENT_ID, v_EVENT_REC.DER_ID, X.COLUMN_VALUE, v_REC.DER_COUNT, v_REC.AMOUNT, v_REC.AMOUNT * v_REC.DER_COUNT
						FROM TABLE(CAST(DATE_UTIL.DATES_IN_INTERVAL_RANGE(GREATEST(v_BEGIN_TIME, v_EVENT_REC.START_TIME),
																		LEAST(v_END_TIME, v_EVENT_REC.STOP_TIME),
																		v_EVENT_REC.PROGRAM_INTERVAL) AS DATE_COLLECTION)) X,
							 DER_DAILY_RESULT DDR, LOAD_RESULT_DATA DATA
						WHERE DDR.DER_ID = v_REC.DER_ID
							AND DDR.IS_EXTERNAL = 1
							AND DDR.SERVICE_CODE = CONSTANTS.CODE_BACKCAST
							AND DDR.SCENARIO_ID = GA.BASE_SCENARIO_ID
							AND X.COLUMN_VALUE BETWEEN DDR.CUT_BEGIN_DATE AND DDR.CUT_END_DATE
							AND DATA.LOAD_RESULT_ID = DDR.LOAD_SHAPE_RESULT_ID
							AND DATA.RESULT_DATE = X.COLUMN_VALUE
							AND DATA.RESULT_VAL > 0;

					END LOOP;
				ELSE
				-- PER SL PAYMENT, WE JUST CARE THAT AT LEAST ONE DER PARTICIPATED W/O FAILING OUT IN SOME WAY
					FOR v_EVENT_REC IN (SELECT DISTINCT EVT.EVENT_ID, EVT.START_TIME, EVT.STOP_TIME, P.PROGRAM_INTERVAL
											FROM DR_EVENT EVT, DR_EVENT_PARTICIPATION PART, VIRTUAL_POWER_PLANT VPP,
												DISTRIBUTED_ENERGY_RESOURCE DER, PROGRAM P
											WHERE EVT.VPP_ID = VPP.VPP_ID
												AND VPP.PROGRAM_ID = p_PROGRAM_ID
												AND P.PROGRAM_ID = VPP.PROGRAM_ID
												AND NVL(EVT.STOP_TIME, CONSTANTS.HIGH_DATE) >= v_BEGIN_TIME
												AND EVT.START_TIME <= v_END_TIME
												AND PART.EVENT_ID = EVT.EVENT_ID
												AND DER.DER_ID = PART.DER_ID
												AND DER.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
												AND NOT EXISTS (SELECT 1
																FROM DR_EVENT_EXCEPTION EXCP
																WHERE EXCP.EVENT_ID = EVT.EVENT_ID
																	AND EXCP.DER_ID = PART.DER_ID
																	AND EXCP.EXCEPTION_TYPE <> DEMAND_RESPONSE_UTIL.c_EXCEPTION_TYPE_FAILURE)) LOOP

						v_DETERMINANT_ID := GET_BILL_DETERMINANT_ID(p_BILL_RESULT_ID,
																	c_DETERMINANT_TYPE_DLC_EVT_INT,
																	v_REC.DER_TYPE_ID,
																	DATE_UTIL.IS_SUB_DAILY_NUM(
																		v_EVENT_REC.PROGRAM_INTERVAL),
																	'intervals');

						-- I'M TRUSTING THAT ONLY ELIGIBLE,
						-- ENROLLED RESOURCES ARE GOING TO BE USED
						INSERT INTO PROGRAM_BILL_DETERMINANT_DTL (BILL_DETERMINANT_ID, EVENT_ID, DER_ID,
										DETERMINANT_DATE, BILL_QUANTITY, BILL_RATE, BILL_AMOUNT)
						SELECT DISTINCT v_DETERMINANT_ID, v_EVENT_REC.EVENT_ID, NULL, X.COLUMN_VALUE, 1, v_REC.AMOUNT, v_REC.AMOUNT
						FROM TABLE(CAST(DATE_UTIL.DATES_IN_INTERVAL_RANGE(GREATEST(v_BEGIN_TIME, v_EVENT_REC.START_TIME),
																		LEAST(v_END_TIME, v_EVENT_REC.STOP_TIME),
																		v_EVENT_REC.PROGRAM_INTERVAL) AS DATE_COLLECTION)) X,
							DER_DAILY_RESULT DDR,
							LOAD_RESULT_DATA DATA
						WHERE DDR.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
							AND DDR.IS_EXTERNAL = 1
							AND DDR.SERVICE_CODE = CONSTANTS.CODE_BACKCAST
							AND DDR.SCENARIO_ID = GA.BASE_SCENARIO_ID
							AND X.COLUMN_VALUE BETWEEN DDR.CUT_BEGIN_DATE AND DDR.CUT_END_DATE
							AND DATA.LOAD_RESULT_ID = DDR.LOAD_SHAPE_RESULT_ID
							AND DATA.RESULT_DATE = X.COLUMN_VALUE
							AND DATA.RESULT_VAL > 0;


					END LOOP;
				END IF;
			ELSE
				LOGS.LOG_WARN(v_REC.PAYMENT_TYPE || ' is an unrecognized payment type.',
					p_SOURCE_ENTITY_ID => p_SERVICE_LOCATION_ID,
					p_SOURCE_DOMAIN_ID => EC.ED_SERVICE_LOCATION,
					p_SOURCE_DATE => p_PERIOD_BEGIN);
				p_RESULT_STATUS := 'Warning';
			END IF;
		END IF;
	END LOOP;

	SELECT MIN(PAY.AMOUNT)
	INTO v_AMOUNT
	FROM PROGRAM_PAYMENT PAY
	WHERE PAY.PROGRAM_ID = p_PROGRAM_ID
		AND PAY.PAYMENT_TYPE = DEMAND_RESPONSE_UTIL.c_PAYMENT_TYPE_MONTHLY_LIMIT
		AND p_PERIOD_BEGIN BETWEEN PAY.BEGIN_DATE AND NVL(PAY.END_DATE, CONSTANTS.HIGH_DATE);

	IF v_AMOUNT IS NOT NULL THEN
		-- add the monthly limit, if found
		v_DETERMINANT_ID := GET_BILL_DETERMINANT_ID(p_BILL_RESULT_ID,
														c_DETERMINANT_TYPE_MONTLY_LIM,
														CONSTANTS.NOT_ASSIGNED,
														NULL,
														NULL);
		UPDATE PROGRAM_BILL_DETERMINANT DT
		SET DT.BILL_AMOUNT = v_AMOUNT
		WHERE DT.BILL_DETERMINANT_ID = v_DETERMINANT_ID;

	END IF;

END CALC_DLC_PAYMENTS;
-----------------------------------------------------------------
PROCEDURE LOG_MISSING_USAGE_DATA
	(
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_BEGIN_TIME IN DATE,
	p_END_TIME IN DATE,
	p_INTERVAL IN VARCHAR2,
	p_TYPE IN VARCHAR2,
	p_SERVICE_CODE IN CHAR,
	p_PERIOD_BEGIN IN DATE,
	p_RESULT_STATUS IN OUT VARCHAR2
	) AS

	v_DATES DATE_COLLECTION;

BEGIN

	SELECT X.COLUMN_VALUE
	BULK COLLECT INTO v_DATES
	FROM TABLE(CAST(DATE_UTIL.DATES_IN_INTERVAL_RANGE(p_BEGIN_TIME,
														p_END_TIME,
														p_INTERVAL) AS DATE_COLLECTION)) X
	WHERE NOT X.COLUMN_VALUE IN (SELECT LD.LOAD_DATE
								 FROM SERVICE SVC, ACCOUNT_SERVICE ACCT_SVC, SERVICE_LOAD LD
								WHERE ACCT_SVC.ACCOUNT_ID = p_ACCOUNT_ID
									AND ACCT_SVC.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
									AND SVC.SCENARIO_ID = GA.BASE_SCENARIO_ID
									AND SVC.ACCOUNT_SERVICE_ID = ACCT_SVC.ACCOUNT_SERVICE_ID
									AND LD.SERVICE_ID = SVC.SERVICE_ID
									AND LD.SERVICE_CODE = p_SERVICE_CODE
									AND LD.LOAD_CODE = '1');

	IF v_DATES.COUNT > 0 THEN

		p_RESULT_STATUS := 'Warning';

		LOGS.LOG_WARN('There is no ' || p_TYPE || ' usage data for ' ||
			TEXT_UTIL.TO_CHAR_ENTITY(p_ACCOUNT_ID, EC.ED_ACCOUNT, TRUE) || ' / ' ||
			TEXT_UTIL.TO_CHAR_ENTITY(p_SERVICE_LOCATION_ID, EC.ED_SERVICE_LOCATION, TRUE) ||
			' on some intervals.  See the attachment for details.',
		    p_SOURCE_ENTITY_ID => p_SERVICE_LOCATION_ID,
			p_SOURCE_DOMAIN_ID => EC.ED_SERVICE_LOCATION,
			p_SOURCE_DATE => p_PERIOD_BEGIN);

		LOGS.POST_EVENT_DETAILS('Missing Usage Data',
								'Intervals Missing',
								CASE WHEN DATE_UTIL.IS_SUB_DAILY(p_INTERVAL) THEN
									TEXT_UTIL.TO_CHAR_TIME_LIST(v_DATES)
								ELSE TEXT_UTIL.TO_CHAR_DATE_LIST(v_DATES) END);

	END IF;

END LOG_MISSING_USAGE_DATA;
-----------------------------------------------------------------
PROCEDURE LOG_WARNING_MISSING_PROG_DATA
	(
	p_PROGRAM_ID IN NUMBER,
	p_EVENT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_TYPE IN VARCHAR2,
	p_DATES IN DATE_COLLECTION,
	p_IS_SUB_DAILY IN BOOLEAN,
	p_PERIOD_BEGIN IN DATE,
	p_RESULT_STATUS IN OUT VARCHAR2
	) AS

	BEGIN

	IF p_DATES.COUNT > 0 THEN
		p_RESULT_STATUS := 'Warning';

		LOGS.LOG_WARN('There is no ' || p_TYPE || ' data for ' ||
			TEXT_UTIL.TO_CHAR_ENTITY(p_PROGRAM_ID, EC.ED_PROGRAM, TRUE) ||
			CASE WHEN p_EVENT_ID IS NOT NULL THEN
				' for the Event: ' || TEXT_UTIL.TO_CHAR_ENTITY(p_EVENT_ID, EC.ED_DR_EVENT)
			ELSE
				NULL
			END ||
			' on some intervals.  ' ||
			'See the attachment for details.',
		    p_SOURCE_ENTITY_ID => p_SERVICE_LOCATION_ID,
			p_SOURCE_DOMAIN_ID => EC.ED_SERVICE_LOCATION,
			p_SOURCE_DATE => p_PERIOD_BEGIN);

		LOGS.POST_EVENT_DETAILS('Missing Program Data',
								'Intervals Missing',
								CASE WHEN p_IS_SUB_DAILY THEN
									TEXT_UTIL.TO_CHAR_TIME_LIST(p_DATES)
								ELSE TEXT_UTIL.TO_CHAR_DATE_LIST(p_DATES) END);
	END IF;

END LOG_WARNING_MISSING_PROG_DATA;
-----------------------------------------------------------------
PROCEDURE CALC_PTR_REBATES
	(
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_PROGRAM_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SL_TIME_ZONE IN VARCHAR2,
	p_PERIOD_BEGIN IN DATE,
	p_PERIOD_END IN DATE,
	p_BILL_RESULT_ID IN NUMBER,
	p_RESULT_STATUS IN OUT VARCHAR2
	) IS

	v_BEGIN_DATE DATE := GREATEST(p_BEGIN_DATE, p_PERIOD_BEGIN);
	v_END_DATE DATE := LEAST(p_END_DATE, p_PERIOD_END);

	v_BEGIN_TIME DATE;
	v_END_TIME DATE;

	v_AMOUNT NUMBER;

	v_DETERMINANT_ID PROGRAM_BILL_DETERMINANT.BILL_DETERMINANT_ID%TYPE;

	v_TEST NUMBER;

BEGIN

	p_RESULT_STATUS := 'Success';

	UT.CUT_DATE_RANGE(CONSTANTS.ELECTRIC_MODEL, v_BEGIN_DATE, v_END_DATE, p_SL_TIME_ZONE,
		v_BEGIN_TIME, v_END_TIME);

	FOR v_REC IN (SELECT EVT.EVENT_ID, NVL(EVT.START_TIME, CONSTANTS.LOW_DATE) AS START_TIME,
						NVL(EVT.STOP_TIME, CONSTANTS.HIGH_DATE) AS STOP_TIME,
						P.PROGRAM_INTERVAL
					FROM DR_EVENT EVT, VIRTUAL_POWER_PLANT VPP, PROGRAM P
					WHERE EVT.VPP_ID = VPP.VPP_ID
						AND VPP.PROGRAM_ID = p_PROGRAM_ID
						AND P.PROGRAM_ID = VPP.PROGRAM_ID
						AND NVL(EVT.START_TIME, CONSTANTS.LOW_DATE) <= v_END_TIME
						AND NVL(EVT.STOP_TIME, CONSTANTS.HIGH_DATE) >= v_BEGIN_TIME) LOOP

		-- FIRST TEST TO SEE IF THERE WERE ANY REDUCTIONS, THEN WE CAN ISSUE PAYMENTS
		SELECT SUM(GREATEST((NVL(BASE_VAL,0) - NVL(MTR_VAL,0)),0))
		INTO v_TEST
		FROM (SELECT LD.LOAD_DATE,
				SUM( CASE WHEN LD.SERVICE_CODE = CONSTANTS.CODE_FORECAST THEN
						LD.LOAD_VAL
					ELSE
						NULL END) AS BASE_VAL,
				SUM( CASE WHEN LD.SERVICE_CODE = CONSTANTS.CODE_ACTUAL THEN
						LD.LOAD_VAL
					ELSE
						NULL END) AS MTR_VAL
			FROM SERVICE SVC, ACCOUNT_SERVICE ACCT_SVC, SERVICE_LOAD LD
			WHERE ACCT_SVC.ACCOUNT_ID = p_ACCOUNT_ID
				AND ACCT_SVC.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
				AND SVC.SCENARIO_ID = GA.BASE_SCENARIO_ID
				AND SVC.ACCOUNT_SERVICE_ID = ACCT_SVC.ACCOUNT_SERVICE_ID
				AND LD.SERVICE_ID = SVC.SERVICE_ID
				AND (LD.SERVICE_CODE = CONSTANTS.CODE_FORECAST
						OR LD.SERVICE_CODE = CONSTANTS.CODE_ACTUAL)
				AND LD.LOAD_CODE = '1'
				AND LD.LOAD_DATE > GREATEST(v_REC.START_TIME, v_BEGIN_TIME)
				AND LD.LOAD_DATE <= LEAST(v_REC.STOP_TIME, v_END_TIME)
			GROUP BY LD.LOAD_DATE);

		IF v_TEST > 0 THEN

			SELECT MAX(PAY.AMOUNT)
			INTO v_AMOUNT
			FROM PROGRAM_PAYMENT PAY
			WHERE PAY.PROGRAM_ID = p_PROGRAM_ID
				AND PAY.PAYMENT_TYPE = DEMAND_RESPONSE_UTIL.c_PAYMENT_TYPE_PER_EVENT
				AND v_REC.STOP_TIME BETWEEN PAY.BEGIN_DATE AND NVL(PAY.END_DATE, CONSTANTS.HIGH_DATE)
				AND v_REC.STOP_TIME BETWEEN v_BEGIN_DATE AND v_END_DATE;

			IF v_AMOUNT IS NOT NULL THEN
				-- ANY REDUCTION DURING THE EVENT? THEN PAY THE PER-EVENT PAYMENT
				v_DETERMINANT_ID := GET_BILL_DETERMINANT_ID(p_BILL_RESULT_ID,
															c_DETERMINANT_TYPE_PTR_PER_EVT,
															CONSTANTS.NOT_ASSIGNED,
															0,
															'events');

				INSERT INTO PROGRAM_BILL_DETERMINANT_DTL (BILL_DETERMINANT_ID, EVENT_ID, DER_ID,
										DETERMINANT_DATE, BILL_QUANTITY, BILL_RATE, BILL_AMOUNT)
				VALUES (v_DETERMINANT_ID, v_REC.EVENT_ID, NULL, v_REC.STOP_TIME, 1, v_AMOUNT, v_AMOUNT);
			END IF;

			v_DETERMINANT_ID := GET_BILL_DETERMINANT_ID(p_BILL_RESULT_ID,
															c_DETERMINANT_TYPE_PTR_PER_KWH,
															CONSTANTS.NOT_ASSIGNED,
															DATE_UTIL.IS_SUB_DAILY_NUM(v_REC.PROGRAM_INTERVAL),
															'kwh');

			LOG_MISSING_USAGE_DATA(p_ACCOUNT_ID,
									p_SERVICE_LOCATION_ID,
									GREATEST(v_REC.START_TIME, v_BEGIN_TIME),
									LEAST(v_REC.STOP_TIME, v_END_TIME),
									v_REC.PROGRAM_INTERVAL,
									'metered',
									CONSTANTS.CODE_ACTUAL,
									p_PERIOD_BEGIN,
									p_RESULT_STATUS);

			LOG_MISSING_USAGE_DATA(p_ACCOUNT_ID,
									p_SERVICE_LOCATION_ID,
									GREATEST(v_REC.START_TIME, v_BEGIN_TIME),
									LEAST(v_REC.STOP_TIME, v_END_TIME),
									v_REC.PROGRAM_INTERVAL,
									'baseline',
									CONSTANTS.CODE_FORECAST,
									p_PERIOD_BEGIN,
									p_RESULT_STATUS);

			-- PER EVENT INTERVAL PAYMENTS
			INSERT INTO PROGRAM_BILL_DETERMINANT_DTL (BILL_DETERMINANT_ID, EVENT_ID, DER_ID,
										DETERMINANT_DATE, BILL_QUANTITY, BILL_RATE, BILL_AMOUNT)
			SELECT v_DETERMINANT_ID, v_REC.EVENT_ID, NULL, LOAD.LOAD_DATE,
				GREATEST((NVL(LOAD.BASE_VAL,0) - NVL(LOAD.MTR_VAL,0)),0), (NVL(SCHED.PRICE,0)/1000 + NVL(PAY.AMOUNT,0)),
				GREATEST((NVL(LOAD.BASE_VAL,0) - NVL(LOAD.MTR_VAL,0)),0) * (NVL(SCHED.PRICE,0)/1000 + NVL(PAY.AMOUNT,0))
			FROM (SELECT LD.LOAD_DATE,
					SUM( CASE WHEN LD.SERVICE_CODE = CONSTANTS.CODE_FORECAST THEN
							LD.LOAD_VAL
						ELSE
							NULL END) AS BASE_VAL,
					SUM( CASE WHEN LD.SERVICE_CODE = CONSTANTS.CODE_ACTUAL THEN
							LD.LOAD_VAL
						ELSE
							NULL END) AS MTR_VAL
				FROM SERVICE SVC, ACCOUNT_SERVICE ACCT_SVC, SERVICE_LOAD LD
				WHERE ACCT_SVC.ACCOUNT_ID = p_ACCOUNT_ID
					AND ACCT_SVC.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
					AND SVC.SCENARIO_ID = GA.BASE_SCENARIO_ID
					AND SVC.ACCOUNT_SERVICE_ID = ACCT_SVC.ACCOUNT_SERVICE_ID
					AND LD.SERVICE_ID = SVC.SERVICE_ID
					AND (LD.SERVICE_CODE = CONSTANTS.CODE_FORECAST
							OR LD.SERVICE_CODE = CONSTANTS.CODE_ACTUAL)
					AND LD.LOAD_CODE = '1'
					AND LD.LOAD_DATE > GREATEST(v_REC.START_TIME, v_BEGIN_TIME)
					AND LD.LOAD_DATE <= LEAST(v_REC.STOP_TIME, v_END_TIME)
				GROUP BY LD.LOAD_DATE) LOAD,
				DR_EVENT_SCHEDULE SCHED,
				PROGRAM_PAYMENT PAY
			WHERE SCHED.EVENT_ID(+) = v_REC.EVENT_ID
				AND SCHED.SCHEDULE_DATE(+) = LOAD.LOAD_DATE
				AND PAY.PROGRAM_ID (+) = p_PROGRAM_ID
				AND PAY.PAYMENT_TYPE (+) = DEMAND_RESPONSE_UTIL.c_PAYMENT_TYPE_PER_KWH
				AND LOAD.LOAD_DATE BETWEEN PAY.BEGIN_DATE (+) AND NVL(PAY.END_DATE (+), CONSTANTS.HIGH_DATE);
		END IF;

	END LOOP;

END CALC_PTR_REBATES;
-----------------------------------------------------------------
PROCEDURE CALC_CPP_PREMIUMS
	(
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_PROGRAM_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SL_TIME_ZONE IN VARCHAR2,
	p_PERIOD_BEGIN IN DATE,
	p_PERIOD_END IN DATE,
	p_BILL_RESULT_ID IN NUMBER,
	p_RESULT_STATUS IN OUT VARCHAR2
	) IS

	v_BEGIN_DATE DATE := GREATEST(p_BEGIN_DATE, p_PERIOD_BEGIN);
	v_END_DATE DATE := LEAST(p_END_DATE, p_PERIOD_END);

	v_BEGIN_TIME DATE;
	v_END_TIME DATE;

	v_DETERMINANT_ID PROGRAM_BILL_DETERMINANT.BILL_DETERMINANT_ID%TYPE;

	v_MISSING_DATES DATE_COLLECTION;

BEGIN

	p_RESULT_STATUS := 'Success';

	UT.CUT_DATE_RANGE(CONSTANTS.ELECTRIC_MODEL, v_BEGIN_DATE, v_END_DATE, p_SL_TIME_ZONE,
		v_BEGIN_TIME, v_END_TIME);

	FOR v_REC IN (SELECT EVT.EVENT_ID, NVL(EVT.START_TIME, CONSTANTS.LOW_DATE) AS START_TIME,
						NVL(EVT.STOP_TIME, CONSTANTS.HIGH_DATE) AS STOP_TIME,
						P.PROGRAM_INTERVAL, P.COMPONENT_ID
					FROM DR_EVENT EVT, VIRTUAL_POWER_PLANT VPP, PROGRAM P
					WHERE EVT.VPP_ID = VPP.VPP_ID
						AND VPP.PROGRAM_ID = p_PROGRAM_ID
						AND P.PROGRAM_ID = VPP.PROGRAM_ID
						AND NVL(EVT.START_TIME, CONSTANTS.LOW_DATE) <= v_END_TIME
						AND NVL(EVT.STOP_TIME, CONSTANTS.HIGH_DATE) >= v_BEGIN_TIME) LOOP

		v_DETERMINANT_ID := GET_BILL_DETERMINANT_ID(p_BILL_RESULT_ID,
														c_DETERMINANT_TYPE_CPP,
														CONSTANTS.NOT_ASSIGNED,
														DATE_UTIL.IS_SUB_DAILY_NUM(v_REC.PROGRAM_INTERVAL),
														'kwh');

		LOG_MISSING_USAGE_DATA(p_ACCOUNT_ID,
							p_SERVICE_LOCATION_ID,
							GREATEST(v_REC.START_TIME, v_BEGIN_TIME),
							LEAST(v_REC.STOP_TIME, v_END_TIME),
							v_REC.PROGRAM_INTERVAL,
							'metered',
							CONSTANTS.CODE_ACTUAL,
							p_PERIOD_BEGIN,
							p_RESULT_STATUS);

		SELECT DATES.COLUMN_VALUE
		BULK COLLECT INTO v_MISSING_DATES
		FROM TABLE(CAST(DATE_UTIL.DATES_IN_INTERVAL_RANGE(GREATEST(v_REC.START_TIME, v_BEGIN_TIME),
															LEAST(v_REC.STOP_TIME, v_END_TIME),
															V_REC.PROGRAM_INTERVAL) AS DATE_COLLECTION)) DATES,
			DR_EVENT_SCHEDULE SCHED,
			PROGRAM_PAYMENT PAY
		WHERE PAY.PROGRAM_ID  = p_PROGRAM_ID
			AND PAY.BEGIN_DATE (+) <= DATES.COLUMN_VALUE
			AND PAY.END_DATE (+) >= DATES.COLUMN_VALUE
			AND PAY.PAYMENT_TYPE (+) = DEMAND_RESPONSE_UTIL.c_PAYMENT_TYPE_CPP_PREMIUM
			AND SCHED.EVENT_ID (+) = v_REC.EVENT_ID
			AND SCHED.SCHEDULE_DATE (+) = DATES.COLUMN_VALUE
			AND PAY.AMOUNT IS NULL
			AND SCHED.PRICE IS NULL;

		LOG_WARNING_MISSING_PROG_DATA(p_PROGRAM_ID,
									v_REC.EVENT_ID,
									p_SERVICE_LOCATION_ID,
									' critical peak price ',
									v_MISSING_DATES,
									DATE_UTIL.IS_SUB_DAILY(v_REC.PROGRAM_INTERVAL),
									p_PERIOD_BEGIN,
									p_RESULT_STATUS);

		-- PER EVENT INTERVAL CHARGES
		INSERT INTO PROGRAM_BILL_DETERMINANT_DTL (BILL_DETERMINANT_ID, EVENT_ID, DER_ID,
			DETERMINANT_DATE, BILL_QUANTITY, BILL_RATE, BILL_AMOUNT)
		SELECT v_DETERMINANT_ID, v_REC.EVENT_ID, NULL, X.COLUMN_VALUE,
			-- PRICES ARE IN MWHS, USAGE IS IN KWH
			NVL(LOAD.LOAD_VAL,0), -(NVL(PAY.AMOUNT,0) + NVL(SCHED.PRICE/1000,0)), 
			-(NVL(LOAD.LOAD_VAL,0)*(NVL(PAY.AMOUNT,0) + NVL(SCHED.PRICE/1000,0)))
		FROM (SELECT LD.LOAD_DATE,
				SUM(LD.LOAD_VAL) AS LOAD_VAL
			FROM SERVICE SVC, ACCOUNT_SERVICE ACCT_SVC, SERVICE_LOAD LD
			WHERE ACCT_SVC.ACCOUNT_ID = p_ACCOUNT_ID
				AND ACCT_SVC.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
				AND SVC.SCENARIO_ID = GA.BASE_SCENARIO_ID
				AND SVC.ACCOUNT_SERVICE_ID = ACCT_SVC.ACCOUNT_SERVICE_ID
				AND LD.SERVICE_ID = SVC.SERVICE_ID
				AND LD.SERVICE_CODE = CONSTANTS.CODE_ACTUAL
				AND LD.LOAD_CODE = '1'
			GROUP BY LD.LOAD_DATE) LOAD,
			TABLE(CAST(DATE_UTIL.DATES_IN_INTERVAL_RANGE(GREATEST(v_REC.START_TIME, v_BEGIN_TIME),
															LEAST(v_REC.STOP_TIME, v_END_TIME),
															V_REC.PROGRAM_INTERVAL) AS DATE_COLLECTION)) X,
			DR_EVENT_SCHEDULE SCHED,
			PROGRAM_PAYMENT PAY
		WHERE PAY.PROGRAM_ID (+) = p_PROGRAM_ID
			AND PAY.PAYMENT_TYPE (+) = DEMAND_RESPONSE_UTIL.c_PAYMENT_TYPE_CPP_PREMIUM
			AND PAY.BEGIN_DATE (+) <= X.COLUMN_VALUE
			AND NVL(PAY.END_DATE(+), CONSTANTS.HIGH_DATE)  >= X.COLUMN_VALUE
			AND SCHED.EVENT_ID (+) = v_REC.EVENT_ID
			AND SCHED.SCHEDULE_DATE (+) = X.COLUMN_VALUE
			AND LOAD.LOAD_DATE (+) = X.COLUMN_VALUE;

	END LOOP;
END CALC_CPP_PREMIUMS;
-----------------------------------------------------------------
PROCEDURE CALC_RTP_CHARGES
	(
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_PROGRAM_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SL_TIME_ZONE IN VARCHAR2,
	p_PERIOD_BEGIN IN DATE,
	p_PERIOD_END IN DATE,
	p_BILL_RESULT_ID IN NUMBER,
	p_RESULT_STATUS IN OUT VARCHAR2
	) IS

	v_BEGIN_DATE DATE := GREATEST(p_BEGIN_DATE, p_PERIOD_BEGIN);
	v_END_DATE DATE := LEAST(p_END_DATE, p_PERIOD_END);

	v_BEGIN_TIME DATE;
	v_END_TIME DATE;


	v_DETERMINANT_ID PROGRAM_BILL_DETERMINANT.BILL_DETERMINANT_ID%TYPE;

	v_COMP_ID COMPONENT.COMPONENT_ID%TYPE;
	v_COMP_TYPE COMPONENT.RATE_STRUCTURE%TYPE;
	v_PROG_INTERVAL PROGRAM.PROGRAM_INTERVAL%TYPE;
	v_MP_ID MARKET_PRICE.MARKET_PRICE_ID%TYPE;

	v_MISSING_DATES DATE_COLLECTION;

BEGIN

	p_RESULT_STATUS := 'Success';

	UT.CUT_DATE_RANGE(CONSTANTS.ELECTRIC_MODEL, v_BEGIN_DATE, v_END_DATE, p_SL_TIME_ZONE,
		v_BEGIN_TIME, v_END_TIME);

	SELECT MAX(COMP.COMPONENT_ID), MAX(COMP.RATE_STRUCTURE), MAX(COMP.MARKET_PRICE_ID),
		MAX(PROG.PROGRAM_INTERVAL)
	INTO v_COMP_ID, v_COMP_TYPE, v_MP_ID, v_PROG_INTERVAL
	FROM PROGRAM PROG, COMPONENT COMP
	WHERE PROG.PROGRAM_ID = p_PROGRAM_ID
		AND COMP.COMPONENT_ID = PROG.COMPONENT_ID;

	IF v_COMP_ID IS NULL THEN
		ERRS.RAISE(MSGCODES.c_ERR_INVALID_PROG_COMP,
				TEXT_UTIL.TO_CHAR_ENTITY(p_PROGRAM_ID, EC.ED_PROGRAM, TRUE) ||
				' does not have an associated charge component.');
	END IF;

	IF NVL(v_COMP_TYPE, 'NOT_MARKET') <> 'Market' THEN
		ERRS.RAISE(MSGCODES.c_ERR_INVALID_PROG_COMP,
				TEXT_UTIL.TO_CHAR_ENTITY(p_PROGRAM_ID, EC.ED_PROGRAM, TRUE) ||
				' has an associated charge component ' || TEXT_UTIL.TO_CHAR_ENTITY(v_COMP_ID, EC.ED_COMPONENT) ||
				' which does not have charge type market rate.');
	END IF;

	IF v_MP_ID IS NULL THEN
		ERRS.RAISE(MSGCODES.c_ERR_INVALID_PROG_COMP,
				TEXT_UTIL.TO_CHAR_ENTITY(p_PROGRAM_ID, EC.ED_PROGRAM, TRUE) ||
				' has an associated charge component ' || TEXT_UTIL.TO_CHAR_ENTITY(v_COMP_ID, EC.ED_COMPONENT) ||
				' which does not have an associated market price.');
	END IF;

	FOR v_REC IN (SELECT EVT.EVENT_ID, NVL(EVT.START_TIME, CONSTANTS.LOW_DATE) AS START_TIME,
						NVL(EVT.STOP_TIME, CONSTANTS.HIGH_DATE) AS STOP_TIME
					FROM DR_EVENT EVT, VIRTUAL_POWER_PLANT VPP, PROGRAM P
					WHERE EVT.VPP_ID = VPP.VPP_ID
						AND VPP.PROGRAM_ID = p_PROGRAM_ID
						AND P.PROGRAM_ID = VPP.PROGRAM_ID
						AND NVL(EVT.START_TIME,CONSTANTS.LOW_DATE) <= v_END_TIME
						AND NVL(EVT.STOP_TIME,CONSTANTS.HIGH_DATE) >= v_BEGIN_TIME) LOOP

		v_DETERMINANT_ID := GET_BILL_DETERMINANT_ID(p_BILL_RESULT_ID,
														c_DETERMINANT_TYPE_RTP,
														CONSTANTS.NOT_ASSIGNED,
														DATE_UTIL.IS_SUB_DAILY_NUM(v_PROG_INTERVAL),
														'kwh');

		LOG_MISSING_USAGE_DATA(p_ACCOUNT_ID,
						p_SERVICE_LOCATION_ID,
						GREATEST(v_REC.START_TIME, v_BEGIN_TIME),
						LEAST(v_REC.STOP_TIME, v_END_TIME),
						v_PROG_INTERVAL,
						'metered',
						CONSTANTS.CODE_ACTUAL,
						p_PERIOD_BEGIN,
						p_RESULT_STATUS);

		SELECT X.COLUMN_VALUE
		BULK COLLECT INTO v_MISSING_DATES
		FROM TABLE(CAST(DATE_UTIL.DATES_IN_INTERVAL_RANGE(GREATEST(v_REC.START_TIME, v_BEGIN_TIME),
															LEAST(v_REC.STOP_TIME, v_END_TIME),
															v_PROG_INTERVAL) AS DATE_COLLECTION)) X
		WHERE X.COLUMN_VALUE NOT IN (SELECT MP.PRICE_DATE
									 FROM MARKET_PRICE_VALUE MP
									 WHERE MP.MARKET_PRICE_ID = v_MP_ID);

		LOG_WARNING_MISSING_PROG_DATA(p_PROGRAM_ID,
									v_REC.EVENT_ID,
									p_SERVICE_LOCATION_ID,
									' market price data ',
									v_MISSING_DATES,
									DATE_UTIL.IS_SUB_DAILY(v_PROG_INTERVAL),
									p_PERIOD_BEGIN,
									p_RESULT_STATUS);

		-- PER EVENT INTERVAL CHARGES
		INSERT INTO PROGRAM_BILL_DETERMINANT_DTL (BILL_DETERMINANT_ID, EVENT_ID, DER_ID,
			DETERMINANT_DATE, BILL_QUANTITY, BILL_RATE, BILL_AMOUNT)
		SELECT v_DETERMINANT_ID, v_REC.EVENT_ID, NULL, X.COLUMN_VALUE,
			NVL(LOAD.LOAD_VAL,0),
			-- PRICES ARE IN MWHS, USAGE IS IN KWH
			-(NVL(MP.PRICE,0)*NVL(CMP.RATE_MULTIPLIER,1) + NVL(CMP.RATE_ADDER,0))/1000,
			-(NVL(LOAD.LOAD_VAL,0)*(NVL(MP.PRICE,0)*NVL(CMP.RATE_MULTIPLIER,1)
										+ NVL(CMP.RATE_ADDER,0))/1000)
		FROM (SELECT LD.LOAD_DATE,
				SUM(LD.LOAD_VAL) AS LOAD_VAL
			FROM SERVICE SVC, ACCOUNT_SERVICE ACCT_SVC, SERVICE_LOAD LD
			WHERE ACCT_SVC.ACCOUNT_ID = p_ACCOUNT_ID
				AND ACCT_SVC.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
				AND SVC.SCENARIO_ID = GA.BASE_SCENARIO_ID
				AND SVC.ACCOUNT_SERVICE_ID = ACCT_SVC.ACCOUNT_SERVICE_ID
				AND LD.SERVICE_ID = SVC.SERVICE_ID
				AND LD.SERVICE_CODE = CONSTANTS.CODE_ACTUAL
				AND LD.LOAD_CODE = '1'
			GROUP BY LD.LOAD_DATE) LOAD,
			TABLE(CAST(DATE_UTIL.DATES_IN_INTERVAL_RANGE(GREATEST(v_REC.START_TIME, v_BEGIN_TIME),
															LEAST(v_REC.STOP_TIME, v_END_TIME),
															v_PROG_INTERVAL) AS DATE_COLLECTION)) X,
			COMPONENT_MARKET_PRICE CMP,
			MARKET_PRICE_VALUE MP
		WHERE LOAD.LOAD_DATE (+) = X.COLUMN_VALUE
			AND MP.MARKET_PRICE_ID (+) = v_MP_ID
			AND MP.PRICE_DATE (+) = X.COLUMN_VALUE
			AND CMP.COMPONENT_ID (+) = v_COMP_ID
			AND CMP.SUB_COMPONENT_TYPE (+) = CONSTANTS.UNDEFINED_ATTRIBUTE
			AND CMP.SUB_COMPONENT_ID (+) = CONSTANTS.NOT_ASSIGNED
			AND X.COLUMN_VALUE BETWEEN CMP.BEGIN_DATE (+) AND NVL(CMP.END_DATE(+), CONSTANTS.HIGH_DATE)
			AND (MP.PRICE_CODE = (SELECT DECODE(MAX(DECODE(PRICE_CODE,'F',1,'P',2,'A',3)),1,'F',2,'P',3,'A')
								FROM MARKET_PRICE_VALUE
								WHERE MARKET_PRICE_ID = MP.MARKET_PRICE_ID
									AND PRICE_CODE IN ('F','P','A')
									AND PRICE_DATE = MP.PRICE_DATE) OR MP.PRICE_CODE IS NULL);

	END LOOP;
END CALC_RTP_CHARGES;
-----------------------------------------------------------------
PROCEDURE CALC_PROGRAM_BILLS
	(
	p_ENTITY_IDs IN NUMBER_COLLECTION,
	p_ENTITIES_ARE_ACCOUNTS IN NUMBER,
	p_PROGRAM_IDs IN NUMBER_COLLECTION,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_PROCESS_ID OUT NUMBER,
	p_PROCESS_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR2
	) AS

	v_NUM_STEPS NUMBER;

	v_ALLOWED_PROGRAMS NUMBER_COLLECTION;

	CURSOR cur_SERVICE_LOCATIONS (p_ALLOWED_PROGRAMS IN NUMBER_COLLECTION) IS
	SELECT ABC.ACCOUNT_ID,
		ASL.SERVICE_LOCATION_ID,
		SLP.PROGRAM_ID,
		PROG.PROGRAM_TYPE,
		MIN(GREATEST(STAT.BEGIN_DATE, ABC.BEGIN_DATE, ASL.BEGIN_DATE, SLP.BEGIN_DATE)) AS BEGIN_DATE,
		MAX(LEAST(NVL(STAT.END_DATE, CONSTANTS.HIGH_DATE), NVL(ABC.END_DATE, CONSTANTS.HIGH_DATE),
				NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE), NVL(SLP.END_DATE, CONSTANTS.HIGH_DATE))) AS END_DATE,
		NVL(SZ.TIME_ZONE, GA.LOCAL_TIME_ZONE) AS SL_TZ,
		ABC.BILL_CYCLE_ID,
		BCP.BILL_CYCLE_MONTH,
		BCP.BEGIN_DATE BILL_MONTH_BEGIN_DATE,
		BCP.END_DATE BILL_MONTH_END_DATE
	FROM ACCOUNT_BILL_CYCLE ABC,
		ACCOUNT_SERVICE_LOCATION ASL,
		ACCOUNT_STATUS STAT,
		ACCOUNT_STATUS_NAME ASN,
		SERVICE_LOCATION_PROGRAM SLP,
		BILL_CYCLE_PERIOD BCP,
		PROGRAM PROG,
		TABLE(CAST(p_ENTITY_IDS AS NUMBER_COLLECTION)) ENTITIES,
		TABLE(CAST(p_ALLOWED_PROGRAMS AS NUMBER_COLLECTION)) PROGRAMS,
		SERVICE_LOCATION SL,
		SERVICE_ZONE SZ
	WHERE (p_ENTITIES_ARE_ACCOUNTS = 1 OR ABC.BILL_CYCLE_ID = ENTITIES.COLUMN_VALUE
				OR ENTITIES.COLUMN_VALUE = CONSTANTS.ALL_ID)
		AND (p_ENTITIES_ARE_ACCOUNTS = 0 OR ABC.ACCOUNT_ID = ENTITIES.COLUMN_VALUE
				OR ENTITIES.COLUMN_VALUE = CONSTANTS.ALL_ID)
		AND ABC.BEGIN_DATE <= p_END_DATE
		AND NVL(ABC.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
		AND ABC.BILL_CYCLE_ID = BCP.BILL_CYCLE_ID
		AND BCP.BEGIN_DATE <= p_END_DATE
		AND NVL(BCP.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
		AND ASL.ACCOUNT_ID = ABC.ACCOUNT_ID
		AND ASL.BEGIN_DATE <= p_END_DATE
		AND NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
		AND SLP.SERVICE_LOCATION_ID = ASL.SERVICE_LOCATION_ID
		AND SLP.BEGIN_DATE <= p_END_DATE
		AND NVL(SLP.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
		AND (SLP.PROGRAM_ID = PROGRAMS.COLUMN_VALUE OR PROGRAMS.COLUMN_VALUE = SD.g_ALL_DATA_ENTITY_ID)
		AND STAT.ACCOUNT_ID = ABC.ACCOUNT_ID
		AND STAT.BEGIN_DATE <= p_END_DATE
		AND NVL(STAT.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
		AND ASN.STATUS_NAME = STAT.STATUS_NAME
		AND ASN.IS_ACTIVE = 1
		AND PROG.PROGRAM_ID = SLP.PROGRAM_ID
		AND SL.SERVICE_LOCATION_ID = ASL.SERVICE_LOCATION_ID
		AND SZ.SERVICE_ZONE_ID (+) = SL.SERVICE_ZONE_ID
	GROUP BY ABC.ACCOUNT_ID, ASL.SERVICE_LOCATION_ID, SLP.PROGRAM_ID, PROG.PROGRAM_TYPE, SZ.TIME_ZONE,
		ABC.BILL_CYCLE_ID, BCP.BILL_CYCLE_MONTH, BCP.BEGIN_DATE, BCP.END_DATE
	ORDER BY ABC.BILL_CYCLE_ID, BCP.BILL_CYCLE_MONTH, SLP.PROGRAM_ID,
		ABC.ACCOUNT_ID, ASL.SERVICE_LOCATION_ID;

	v_RESULT_ID PROGRAM_BILL_RESULT.BILL_RESULT_ID%TYPE;
	v_SUMMARY_ID PROGRAM_BILL_SUMMARY.BILL_SUMMARY_ID%TYPE := NULL;

	v_PREV_PROG_ID PROGRAM.PROGRAM_ID%TYPE := NULL;
	v_PREV_CYCLE_ID BILL_CYCLE.BILL_CYCLE_ID%TYPE := NULL;
	v_PREV_MONTH DATE := NULL;

	v_RESULT_STATUS PROGRAM_BILL_RESULT.RESULT_STATUS%TYPE;

	v_TMP_TBL ID_TABLE;
BEGIN

	LOGS.START_PROCESS('Calculate Program Billing Determinant',
						p_BEGIN_DATE, p_END_DATE);

	LOGS.SET_PROCESS_TARGET_PARAMETER('Entities', TEXT_UTIL.TO_CHAR_ENTITY_LIST(p_ENTITY_IDs,
										CASE WHEN p_ENTITIES_ARE_ACCOUNTS = 1 THEN EC.ED_ACCOUNT
										ELSE EC.ED_BILL_CYCLE END, TRUE));
	LOGS.SET_PROCESS_TARGET_PARAMETER('Trace On', p_TRACE_ON);
	LOGS.SET_PROCESS_TARGET_PARAMETER('Programs', TEXT_UTIL.TO_CHAR_ENTITY_LIST(p_PROGRAM_IDs,
																		EC.ED_PROGRAM));

	IF UT.NUMBER_COLLECTION_CONTAINS(p_PROGRAM_IDs, CONSTANTS.ALL_ID) THEN
		v_TMP_TBL := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_SELECT_PROG_BILLING,
													EC.ED_PROGRAM);
		UT.CONVERT_ID_TABLE_TO_NUM_COLL(v_TMP_TBL, v_ALLOWED_PROGRAMS);
	ELSE
		v_ALLOWED_PROGRAMS := SD.GET_ALLOWED_IDS_FROM_SELECTION(SD.g_ACTION_CALC_PROGRAM_BILLING,
												EC.ED_PROGRAM,
												p_PROGRAM_IDs,
												FALSE);
	END IF;

	-- COUNT THE NUMBER OF ACCOUNT/SERVICE_LOCATION/PROGRAM ROWS TO PROCESS
	SELECT COUNT(1)
	INTO v_NUM_STEPS
	FROM (SELECT 1
		FROM ACCOUNT_BILL_CYCLE ABC,
			ACCOUNT_SERVICE_LOCATION ASL,
			ACCOUNT_STATUS STAT,
			ACCOUNT_STATUS_NAME ASN,
			SERVICE_LOCATION_PROGRAM SLP,
			BILL_CYCLE_PERIOD BCP,
			PROGRAM PROG,
			TABLE(CAST(p_ENTITY_IDS AS NUMBER_COLLECTION)) ENTITIES,
			TABLE(CAST(v_ALLOWED_PROGRAMS AS NUMBER_COLLECTION)) PROGRAMS,
			SERVICE_LOCATION SL,
			SERVICE_ZONE SZ
		WHERE (p_ENTITIES_ARE_ACCOUNTS = 1 OR ABC.BILL_CYCLE_ID = ENTITIES.COLUMN_VALUE
					OR ENTITIES.COLUMN_VALUE = CONSTANTS.ALL_ID)
			AND (p_ENTITIES_ARE_ACCOUNTS = 0 OR ABC.ACCOUNT_ID = ENTITIES.COLUMN_VALUE
					OR ENTITIES.COLUMN_VALUE = CONSTANTS.ALL_ID)
			AND ABC.BEGIN_DATE <= p_END_DATE
			AND NVL(ABC.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND ABC.BILL_CYCLE_ID = BCP.BILL_CYCLE_ID
			AND BCP.BEGIN_DATE <= p_END_DATE
			AND NVL(BCP.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND ASL.ACCOUNT_ID = ABC.ACCOUNT_ID
			AND ASL.BEGIN_DATE <= p_END_DATE
			AND NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND SLP.SERVICE_LOCATION_ID = ASL.SERVICE_LOCATION_ID
			AND SLP.BEGIN_DATE <= p_END_DATE
			AND NVL(SLP.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND (SLP.PROGRAM_ID = PROGRAMS.COLUMN_VALUE OR PROGRAMS.COLUMN_VALUE = SD.g_ALL_DATA_ENTITY_ID)
			AND STAT.ACCOUNT_ID = ABC.ACCOUNT_ID
			AND STAT.BEGIN_DATE <= p_END_DATE
			AND NVL(STAT.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND ASN.STATUS_NAME = STAT.STATUS_NAME
			AND ASN.IS_ACTIVE = 1
			AND PROG.PROGRAM_ID = SLP.PROGRAM_ID
			AND SL.SERVICE_LOCATION_ID = ASL.SERVICE_LOCATION_ID
			AND SZ.SERVICE_ZONE_ID (+) = SL.SERVICE_ZONE_ID
		GROUP BY ABC.ACCOUNT_ID, ASL.SERVICE_LOCATION_ID, SLP.PROGRAM_ID, PROG.PROGRAM_TYPE, SZ.TIME_ZONE,
			ABC.BILL_CYCLE_ID, BCP.BILL_CYCLE_MONTH, BCP.BEGIN_DATE, BCP.END_DATE);

	IF v_NUM_STEPS = 0 THEN
		LOGS.LOG_ERROR('No applicable service locations were found for the given criteria.');
	ELSE
		-- add two for the first step of deleting existing results
		-- and the last step of calculating the last rollup
		v_NUM_STEPS := v_NUM_STEPS + 2;
		LOGS.INIT_PROCESS_PROGRESS(p_TOTAL_WORK => v_NUM_STEPS);

		-- CLEAR OUT THE EXISTING RESULTS
		REMOVE_EXISTING_BILL_RESULTS(p_ENTITY_IDs,
									p_ENTITIES_ARE_ACCOUNTS,
									v_ALLOWED_PROGRAMS,
									p_BEGIN_DATE,
									p_END_DATE);
		LOGS.INCREMENT_PROCESS_PROGRESS;

		-- LOOP OVER THE SERVICE LOCATION / ACCOUNT / PROGRAM / BILL CYCLE RECORDS
		FOR v_REC IN cur_SERVICE_LOCATIONS(v_ALLOWED_PROGRAMS) LOOP
			-- FIRST ITERATION OR DIFFERENT CYCLE, MONTH OR PROGRAM?
			-- GET A NEW SUMMARY ID
			IF v_SUMMARY_ID IS NULL
				OR v_PREV_CYCLE_ID <> v_REC.BILL_CYCLE_ID
				OR v_PREV_MONTH <> v_REC.BILL_CYCLE_MONTH
				OR v_PREV_PROG_ID <> v_REC.PROGRAM_ID THEN

				v_PREV_CYCLE_ID := v_REC.BILL_CYCLE_ID;
				v_PREV_MONTH := v_REC.BILL_CYCLE_MONTH;
				v_PREV_PROG_ID := v_REC.PROGRAM_ID;

				IF v_SUMMARY_ID IS NOT NULL THEN
					CALC_SUMMARY_ROLLUP(v_SUMMARY_ID);
				END IF;

				v_SUMMARY_ID := GET_BILL_SUMMARY_ID(v_REC.PROGRAM_ID,
													v_REC.BILL_CYCLE_ID,
													v_REC.BILL_MONTH_BEGIN_DATE);
			END IF;

			v_RESULT_ID := GET_BILL_RESULT_ID(v_SUMMARY_ID,
											  v_REC.ACCOUNT_ID,
											  v_REC.SERVICE_LOCATION_ID);

			BEGIN

				v_RESULT_STATUS := 'Success';

				IF GREATEST(v_REC.BEGIN_DATE, v_REC.BILL_MONTH_BEGIN_DATE) <
					LEAST(v_REC.END_DATE, v_REC.BILL_MONTH_END_DATE) THEN

					IF v_REC.PROGRAM_TYPE = DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_DLC THEN

						CALC_DLC_PAYMENTS(v_REC.SERVICE_LOCATION_ID,
										  v_REC.PROGRAM_ID,
										  v_REC.BEGIN_DATE,
										  v_REC.END_DATE,
										  v_REC.SL_TZ,
										  v_REC.BILL_MONTH_BEGIN_DATE,
										  v_REC.BILL_MONTH_END_DATE,
										  v_RESULT_ID,
										  v_RESULT_STATUS);

					ELSIF v_REC.PROGRAM_TYPE = DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_PK_TIME_REBATE THEN

						CALC_PTR_REBATES(v_REC.ACCOUNT_ID,
										 v_REC.SERVICE_LOCATION_ID,
										 v_REC.PROGRAM_ID,
										 v_REC.BEGIN_DATE,
										 v_REC.END_DATE,
										 v_REC.SL_TZ,
										 v_REC.BILL_MONTH_BEGIN_DATE,
										 v_REC.BILL_MONTH_END_DATE,
										 v_RESULT_ID,
										 v_RESULT_STATUS);

					ELSIF V_REC.PROGRAM_TYPE = DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_CRIT_PRICING THEN

						CALC_CPP_PREMIUMS(v_REC.ACCOUNT_ID,
										 v_REC.SERVICE_LOCATION_ID,
										 v_REC.PROGRAM_ID,
										 v_REC.BEGIN_DATE,
										 v_REC.END_DATE,
										 v_REC.SL_TZ,
										 v_REC.BILL_MONTH_BEGIN_DATE,
										 v_REC.BILL_MONTH_END_DATE,
										 v_RESULT_ID,
										 v_RESULT_STATUS);

					ELSIF v_REC.PROGRAM_TYPE = DEMAND_RESPONSE_UTIL.c_PROGRAM_TYPE_RT_PRICING THEN

						CALC_RTP_CHARGES(v_REC.ACCOUNT_ID,
										 v_REC.SERVICE_LOCATION_ID,
										 v_REC.PROGRAM_ID,
										 v_REC.BEGIN_DATE,
										 v_REC.END_DATE,
										 v_REC.SL_TZ,
										 v_REC.BILL_MONTH_BEGIN_DATE,
										 v_REC.BILL_MONTH_END_DATE,
										 v_RESULT_ID,
										 v_RESULT_STATUS);

					END IF;
				END IF;
				EXCEPTION
					WHEN OTHERS THEN
						ERRS.LOG_AND_CONTINUE(p_SOURCE_ENTITY_ID => v_REC.SERVICE_LOCATION_ID,
											 p_SOURCE_DOMAIN_ID => EC.ED_SERVICE_LOCATION,
											 p_SOURCE_DATE => v_REC.BILL_MONTH_BEGIN_DATE);
						v_RESULT_STATUS := 'Error';
				END;

			CALC_RESULT_ROLLUP(v_RESULT_ID,
							   v_RESULT_STATUS);

			LOGS.INCREMENT_PROCESS_PROGRESS;
		END LOOP;

		CALC_SUMMARY_ROLLUP(v_SUMMARY_ID);
		LOGS.INCREMENT_PROCESS_PROGRESS;
	END IF;

	p_PROCESS_ID := LOGS.CURRENT_PROCESS_ID;
	LOGS.STOP_PROCESS(p_MESSAGE, p_PROCESS_STATUS);

	EXCEPTION
	WHEN OTHERS THEN
		ERRS.ABORT_PROCESS();
END CALC_PROGRAM_BILLS;
-----------------------------------------------------------------
END PROGRAM_BILLING;
/
