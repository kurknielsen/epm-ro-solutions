CREATE OR REPLACE PACKAGE RETAIL_SETTLEMENT_UI IS
-- $Revision: 1.5 $

c_THRESHOLD_TYPE_CHARGE_TOTAL CONSTANT VARCHAR2(32) := 'Charge Total';
c_THRESHOLD_TYPE_CHARGE_PCT CONSTANT VARCHAR2(32) := 'Charge %';
c_THRESHOLD_TYPE_VOLUME_TOTAL CONSTANT VARCHAR2(32) := 'Volume Total';
c_THRESHOLD_TYPE_VOLUME_PCT CONSTANT VARCHAR2(32) := 'Volume %';

c_SEARCH_BY_NAME CONSTANT VARCHAR2(32) := 'By Name';
c_SEARCH_BY_EXT_IDENT CONSTANT VARCHAR2(32) := 'By External Identifier';

c_SL_DISPUTE_MANAGEMENT_MODULE CONSTANT VARCHAR2(32) := 'Financial Settlements';
c_SL_DISPUTE_MANAGEMENT_KEY1 CONSTANT VARCHAR2(32) := 'Dispute Management';
c_SL_DISPUTE_STATUS_KEY2 CONSTANT VARCHAR2(32) := 'Dispute Status';
c_SL_PROCESS_STATUS_KEY2 CONSTANT VARCHAR2(32) := 'Process Status';

FUNCTION WHAT_VERSION RETURN VARCHAR2;

PROCEDURE INVOICE_SENDER_LIST
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE INVOICE_RECIPIENT_LIST
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SENDER_PSE_ID IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE INVOICE_LIST
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SENDER_PSE_ID IN NUMBER,
	p_RECIPIENT_PSE_ID IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE INVOICE_PRODUCT_LIST
	(
	p_RETAIL_INVOICE_ID IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE INVOICE_COMPONENT_LIST
	(
	p_RETAIL_INVOICE_ID IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE RETAIL_INVOICE_SUMMARY
	(
	p_RETAIL_INVOICE_ID IN NUMBER,
	p_THRESHOLD_TYPE IN VARCHAR2, -- 'Charge Total' or 'Charge %' or 'Volume Total' or 'Volume %'
	p_THRESHOLD_VALUE IN VARCHAR2,
	p_SHOW_PRODUCT_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_SHOW_COMPONENT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_SHOW_SUB_TOTAL IN NUMBER, -- Show Sub-Total rows flag (0 or 1)
	p_STATEMENT_TYPE_NAME OUT VARCHAR2,
	p_SERVICE_CODE OUT VARCHAR2,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE RETAIL_INVOICE_DETAILS
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_RETAIL_INVOICE_ID_TEXT IN VARCHAR2,
	p_RETAIL_INVOICE_ID IN NUMBER,
	p_THRESHOLD_TYPE IN VARCHAR2, -- 'Charge Total', 'Charge %', 'Volume Total' or 'Volume %'
	p_THRESHOLD_VALUE IN VARCHAR2,
	p_SHOW_PRODUCT_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_SHOW_COMPONENT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_SEARCH_OPTION IN VARCHAR2, -- 'Name' or 'External Identifier'
	p_SEARCH_STRING IN VARCHAR2,
	p_SHOW_SUB_TOTAL IN NUMBER, -- Show Sub-Total rows 1 or 0
    p_STATEMENT_TYPE_NAME OUT VARCHAR2,
	p_SERVICE_CODE OUT VARCHAR2,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE PRICING_RESULTS_DETAILS
	(
	p_TIME_ZONE IN VARCHAR2,
	p_RETAIL_INVOICE_LINE_COMP_ID IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);

PROCEDURE FORMULA_CHARGE_DETAIL
    (
	p_TIME_ZONE IN VARCHAR2,
	p_FML_CHARGE_ID IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	);
	
----------------------------------------------------------------------	
-- This is the GET procedure for the Manual Disputes Entry screen.
-- %param p_RETAIL_INVOICE_LINE_COMP_ID IN NUMBER The ID of the invoice/line/product/component from which the screen was opened
-- %param p_INVOICE_DATE_STRING OUT VARCHAR2 Formatted Invoice Date string for the grid label
-- %param p_INVOICE_NUMBER OUT VARCHAR2 Invoice Number for the grid label
-- %param p_CHARGE_BEGIN OUT VARCHAR2 Formatted Charge begin date for the grid label
-- %param p_CHARGE_END OUT VARCHAR2 Formatted Charge end date for the grid label
-- %param p_CURSOR OUT GA.REFCURSOR Cursor to fill the grid with rows
PROCEDURE GET_MANUAL_DISPUTES
    (
	p_RETAIL_INVOICE_LINE_COMP_ID IN NUMBER,
	p_INVOICE_DATE_STRING OUT VARCHAR2,
	p_INVOICE_NUMBER OUT VARCHAR2,
	p_CHARGE_BEGIN OUT VARCHAR2,
	p_CHARGE_END OUT VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	);
	
----------------------------------------------------------------------	
-- This is the PUT procedure for the Manual Disputes Entry screen.
-- %param p_RETAIL_INVOICE_LINE_COMP_ID IN NUMBER The ID of the invoice/line/product/component off which the screen was opened
-- %param p_DISPUTE_ID IN OUT NUMBER The ID of the manual dispute (NULL if new, ID if editing); also OUT parameter to return new ID
-- %param p_DISPUTE_STATUS IN VARCHAR2 User entered Dispute Status
-- %param p_PROCESS_STATUS IN VARCHAR2 User entered Process Status
-- %param p_DISPUTE_CATEGORY IN VARCHAR2 User entered Dispute Category
-- %param p_NOTES IN VARCHAR2 User entered Dispute Notes
PROCEDURE PUT_MANUAL_DISPUTE
    (
	p_RETAIL_INVOICE_LINE_COMP_ID IN NUMBER,
	p_DISPUTE_ID IN OUT NUMBER,
	p_DISPUTE_STATUS IN VARCHAR2,
	p_PROCESS_STATUS IN VARCHAR2,
	p_DISPUTE_CATEGORY IN VARCHAR2,
	p_NOTES IN VARCHAR2
	);

END RETAIL_SETTLEMENT_UI;
/
CREATE OR REPLACE PACKAGE BODY RETAIL_SETTLEMENT_UI IS
----------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR2 IS
BEGIN
    RETURN '$Revision: 1.5 $';
END WHAT_VERSION;
---------------------------------------------------------------------------------------------------
PROCEDURE INVOICE_SENDER_LIST
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT DISTINCT PSE.PSE_NAME, PSE.PSE_ID
		FROM RETAIL_INVOICE I,
			PURCHASING_SELLING_ENTITY PSE
		WHERE TRUNC(I.INVOICE_DATE) BETWEEN p_BEGIN_DATE AND p_END_DATE
			AND PSE.PSE_ID = I.SENDER_PSE_ID
		ORDER BY 1;
END INVOICE_SENDER_LIST;
----------------------------------------------------------------------
PROCEDURE INVOICE_RECIPIENT_LIST
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SENDER_PSE_ID IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT DISTINCT PSE.PSE_NAME, PSE.PSE_ID
		FROM RETAIL_INVOICE I,
			PURCHASING_SELLING_ENTITY PSE
		WHERE TRUNC(I.INVOICE_DATE) BETWEEN p_BEGIN_DATE AND p_END_DATE
			AND (I.SENDER_PSE_ID = p_SENDER_PSE_ID OR CONSTANTS.ALL_ID = p_SENDER_PSE_ID)
			AND PSE.PSE_ID = I.RECIPIENT_PSE_ID
		ORDER BY 1;
END INVOICE_RECIPIENT_LIST;
----------------------------------------------------------------------
PROCEDURE INVOICE_LIST
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_SENDER_PSE_ID IN NUMBER,
	p_RECIPIENT_PSE_ID IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT S.PSE_NAME || ': ' || I.INVOICE_NUMBER || ' (' ||
				TEXT_UTIL.TO_CHAR_DATE(I.INVOICE_DATE) || ') ' AS RETAIL_INVOICE_NAME,
			I.RETAIL_INVOICE_ID
		FROM RETAIL_INVOICE I,
			PURCHASING_SELLING_ENTITY S
		WHERE (I.RECIPIENT_PSE_ID = p_RECIPIENT_PSE_ID OR CONSTANTS.ALL_ID = p_RECIPIENT_PSE_ID)
			AND (I.SENDER_PSE_ID = p_SENDER_PSE_ID OR CONSTANTS.ALL_ID = p_SENDER_PSE_ID)
			AND TRUNC(I.INVOICE_DATE) BETWEEN p_BEGIN_DATE AND p_END_DATE
			AND S.PSE_ID = I.SENDER_PSE_ID
		ORDER BY 1;
END INVOICE_LIST;
----------------------------------------------------------------------
PROCEDURE INVOICE_PRODUCT_LIST
	(
	p_RETAIL_INVOICE_ID IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT DISTINCT P.PRODUCT_NAME, P.PRODUCT_ID
		FROM RETAIL_INVOICE_COMPONENT IC,
			PRODUCT P
		WHERE IC.RETAIL_INVOICE_ID = p_RETAIL_INVOICE_ID
			AND P.PRODUCT_ID = IC.PRODUCT_ID
		ORDER BY 1;
END INVOICE_PRODUCT_LIST;
----------------------------------------------------------------------
PROCEDURE INVOICE_COMPONENT_LIST
	(
	p_RETAIL_INVOICE_ID IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT DISTINCT C.COMPONENT_NAME, C.COMPONENT_ID
		FROM RETAIL_INVOICE_COMPONENT IC,
			COMPONENT C
		WHERE IC.RETAIL_INVOICE_ID = p_RETAIL_INVOICE_ID
			AND C.COMPONENT_ID = IC.COMPONENT_ID
		ORDER BY 1;
END INVOICE_COMPONENT_LIST;
----------------------------------------------------------------------
PROCEDURE RETAIL_INVOICE_SUMMARY
	(
	p_RETAIL_INVOICE_ID IN NUMBER,
	p_THRESHOLD_TYPE IN VARCHAR2, -- 'Charge Total' or 'Charge %' or 'Volume Total' or 'Volume %'
	p_THRESHOLD_VALUE IN VARCHAR2,
	p_SHOW_PRODUCT_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_SHOW_COMPONENT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_SHOW_SUB_TOTAL IN NUMBER, -- Show Sub-Total rows flag (0 or 1)
	p_STATEMENT_TYPE_NAME OUT VARCHAR2,
	p_SERVICE_CODE OUT VARCHAR2,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_THRESHOLD_VALUE NUMBER;

BEGIN
	BEGIN
		v_THRESHOLD_VALUE := CASE WHEN p_THRESHOLD_VALUE IS NULL THEN NULL ELSE TO_NUMBER(p_THRESHOLD_VALUE) END;

	EXCEPTION
		WHEN VALUE_ERROR THEN
			ERRS.RAISE_BAD_ARGUMENT('Threshold Value', v_THRESHOLD_VALUE);
	END;

	-- Get the Statement and Service Code for the Invoice
	SELECT S.STATEMENT_TYPE_NAME,
		CASE I.SERVICE_CODE
			WHEN CONSTANTS.CODE_FORECAST THEN CONSTANTS.SERVICE_CODE_FORECAST_STR
			WHEN CONSTANTS.CODE_BACKCAST THEN CONSTANTS.SERVICE_CODE_BACKCAST_STR
			WHEN CONSTANTS.CODE_ACTUAL THEN CONSTANTS.SERVICE_CODE_ACTUAL_STR
		END
	INTO p_STATEMENT_TYPE_NAME, p_SERVICE_CODE
	FROM RETAIL_INVOICE I, STATEMENT_TYPE S
	WHERE I.RETAIL_INVOICE_ID = p_RETAIL_INVOICE_ID
		AND S.STATEMENT_TYPE_ID(+) = I.STATEMENT_TYPE_ID;

	OPEN p_CURSOR FOR
		SELECT I.RETAIL_INVOICE_ID,
			I.INVOICE_DATE,
			SENDER.PSE_NAME AS SENDER_NAME,
			RECIPIENT.PSE_NAME AS RECIPIENT_NAME,
			P.PRODUCT_ID,
			P.PRODUCT_NAME,
			C.COMPONENT_ID,
			C.COMPONENT_NAME,
			T.PERIOD_NAME,
			SUMM.TOTAL_INTERNAL_QUANTITY,
			SUMM.TOTAL_INTERNAL_AMOUNT,
			SUMM.TOTAL_EXTERNAL_QUANTITY,
			SUMM.TOTAL_EXTERNAL_AMOUNT,
			SUMM.SUMMARY_TYPE,
			SUMM.GROUPING_ID
		FROM RETAIL_INVOICE I,
			PURCHASING_SELLING_ENTITY RECIPIENT,
			PURCHASING_SELLING_ENTITY SENDER,
			(SELECT GROUPING_ID(R.RETAIL_INVOICE_ID, R.PRODUCT_ID, R.COMPONENT_ID, R.PERIOD_ID) AS GROUPING_ID,
				-- Summary Type = 1 implies a Grand Total and Summary Type > 1 implies Sub-Total
				CASE WHEN GROUPING_ID(R.RETAIL_INVOICE_ID, R.PRODUCT_ID, R.COMPONENT_ID, R.PERIOD_ID) = 0 THEN NULL -- No rollup
					WHEN GROUPING_ID(R.RETAIL_INVOICE_ID, R.PRODUCT_ID, R.COMPONENT_ID, R.PERIOD_ID) = 3 AND p_SHOW_COMPONENT_ID = 0 THEN NULL -- Product
					WHEN GROUPING_ID(R.RETAIL_INVOICE_ID, R.PRODUCT_ID, R.COMPONENT_ID, R.PERIOD_ID) = 3 AND p_SHOW_COMPONENT_ID = 1 THEN 3 -- Roll up by Product
					WHEN GROUPING_ID(R.RETAIL_INVOICE_ID, R.PRODUCT_ID, R.COMPONENT_ID, R.PERIOD_ID) = 7 AND p_SHOW_PRODUCT_ID = 0 AND p_SHOW_COMPONENT_ID = 0 THEN NULL -- Invoice Summary
					WHEN GROUPING_ID(R.RETAIL_INVOICE_ID, R.PRODUCT_ID, R.COMPONENT_ID, R.PERIOD_ID) = 7 THEN 1 -- Grand Total
					ELSE 2 -- Product or Component mode
				END AS SUMMARY_TYPE,
				R.RETAIL_INVOICE_ID,
				CASE WHEN p_SHOW_PRODUCT_ID = 1 THEN R.PRODUCT_ID ELSE NULL END PRODUCT_ID,
				CASE WHEN  p_SHOW_COMPONENT_ID = 1 THEN R.COMPONENT_ID ELSE NULL END COMPONENT_ID,
				R.PERIOD_ID,
				NVL(SUM(R.TOTAL_INTERNAL_QUANTITY),0) AS TOTAL_INTERNAL_QUANTITY,
				NVL(SUM(R.TOTAL_INTERNAL_AMOUNT),0) AS TOTAL_INTERNAL_AMOUNT,
				SUM(R.TOTAL_EXTERNAL_QUANTITY) AS TOTAL_EXTERNAL_QUANTITY,
				SUM(R.TOTAL_EXTERNAL_AMOUNT) AS TOTAL_EXTERNAL_AMOUNT
			FROM RETAIL_INVOICE_COMPONENT R
			WHERE (R.PRODUCT_ID = p_PRODUCT_ID OR p_PRODUCT_ID = CONSTANTS.ALL_ID)
				 AND (R.COMPONENT_ID = p_COMPONENT_ID OR p_COMPONENT_ID = CONSTANTS.ALL_ID)
				 AND R.RETAIL_INVOICE_ID = p_RETAIL_INVOICE_ID
				 AND (v_THRESHOLD_VALUE IS NULL OR ((p_THRESHOLD_TYPE = c_THRESHOLD_TYPE_CHARGE_TOTAL AND ABS(NVL(TOTAL_EXTERNAL_AMOUNT,0) - NVL(TOTAL_INTERNAL_AMOUNT,0)) >= v_THRESHOLD_VALUE)
					 OR (p_THRESHOLD_TYPE = c_THRESHOLD_TYPE_CHARGE_PCT AND ((TOTAL_EXTERNAL_AMOUNT IS NULL OR TOTAL_EXTERNAL_AMOUNT = 0) OR (TOTAL_EXTERNAL_AMOUNT IS NOT NULL AND TOTAL_EXTERNAL_AMOUNT != 0 AND
					 		ABS((TOTAL_EXTERNAL_AMOUNT - NVL(TOTAL_INTERNAL_AMOUNT,0))/TOTAL_EXTERNAL_AMOUNT)*100 >= v_THRESHOLD_VALUE)))
					 OR (p_THRESHOLD_TYPE = c_THRESHOLD_TYPE_VOLUME_TOTAL AND ABS(NVL(TOTAL_EXTERNAL_QUANTITY,0) - NVL(TOTAL_INTERNAL_QUANTITY,0))>= v_THRESHOLD_VALUE)
					 OR (p_THRESHOLD_TYPE = c_THRESHOLD_TYPE_VOLUME_PCT AND ((TOTAL_EXTERNAL_QUANTITY IS NULL OR TOTAL_EXTERNAL_QUANTITY = 0) OR (TOTAL_EXTERNAL_QUANTITY IS NOT NULL AND TOTAL_EXTERNAL_QUANTITY != 0 AND
					 		ABS((TOTAL_EXTERNAL_QUANTITY - NVL(TOTAL_INTERNAL_QUANTITY,0))/TOTAL_EXTERNAL_QUANTITY)*100 >= v_THRESHOLD_VALUE)))))
			GROUP BY ROLLUP (R.RETAIL_INVOICE_ID, R.PRODUCT_ID, R.COMPONENT_ID, R.PERIOD_ID)
			HAVING -- No Rollup
				(GROUPING_ID(R.RETAIL_INVOICE_ID, R.PRODUCT_ID, R.COMPONENT_ID, R.PERIOD_ID)=0 AND (p_SHOW_COMPONENT_ID=1)) OR
				-- Product Mode
				(GROUPING_ID(R.RETAIL_INVOICE_ID, R.PRODUCT_ID, R.COMPONENT_ID, R.PERIOD_ID)=3 AND p_SHOW_PRODUCT_ID=1 AND p_SHOW_COMPONENT_ID=0) OR
				-- Component Mode
				(GROUPING_ID(R.RETAIL_INVOICE_ID, R.PRODUCT_ID, R.COMPONENT_ID, R.PERIOD_ID)=3 AND p_SHOW_COMPONENT_ID=1 AND p_SHOW_SUB_TOTAL=1) OR
				-- Invoice Summary Mode
				(GROUPING_ID(R.RETAIL_INVOICE_ID, R.PRODUCT_ID, R.COMPONENT_ID, R.PERIOD_ID)=7)) SUMM,
			PRODUCT P,
			COMPONENT C,
			PERIOD T
		WHERE I.RECIPIENT_PSE_ID = RECIPIENT.PSE_ID
			AND I.SENDER_PSE_ID = SENDER.PSE_ID
			AND SUMM.RETAIL_INVOICE_ID = I.RETAIL_INVOICE_ID
			AND P.PRODUCT_ID(+) = SUMM.PRODUCT_ID
			AND C.COMPONENT_ID(+) = SUMM.COMPONENT_ID
			AND T.PERIOD_ID(+) = SUMM.PERIOD_ID;

END RETAIL_INVOICE_SUMMARY;
----------------------------------------------------------------------
PROCEDURE RETAIL_INVOICE_DETAILS
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_RETAIL_INVOICE_ID_TEXT IN VARCHAR2,
	p_RETAIL_INVOICE_ID IN NUMBER,
	p_THRESHOLD_TYPE IN VARCHAR2, -- 'Charge Total', 'Charge %', 'Volume Total' or 'Volume %'
	p_THRESHOLD_VALUE IN VARCHAR2,
	p_SHOW_PRODUCT_ID IN NUMBER,
	p_PRODUCT_ID IN NUMBER,
	p_SHOW_COMPONENT_ID IN NUMBER,
	p_COMPONENT_ID IN NUMBER,
	p_SEARCH_OPTION IN VARCHAR2, -- 'Name' or 'External Identifier'
	p_SEARCH_STRING IN VARCHAR2,
	p_SHOW_SUB_TOTAL IN NUMBER, -- Show Sub-Total rows 1 or 0
    p_STATEMENT_TYPE_NAME OUT VARCHAR2,
	p_SERVICE_CODE OUT VARCHAR2,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_SEARCH_STRING VARCHAR2(256) := GUI_UTIL.FIX_SEARCH_STRING(p_SEARCH_STRING);
v_THRESHOLD_VALUE NUMBER;

BEGIN
	BEGIN
		v_THRESHOLD_VALUE := CASE WHEN p_THRESHOLD_VALUE IS NULL THEN NULL ELSE TO_NUMBER(p_THRESHOLD_VALUE) END;

	EXCEPTION
		WHEN VALUE_ERROR THEN
			ERRS.RAISE_BAD_ARGUMENT('Threshold Value', v_THRESHOLD_VALUE);
	END;

	-- Get the Statement and Service Code for the Invoice
	SELECT S.STATEMENT_TYPE_NAME,
		CASE I.SERVICE_CODE
			WHEN CONSTANTS.CODE_FORECAST THEN CONSTANTS.SERVICE_CODE_FORECAST_STR
			WHEN CONSTANTS.CODE_BACKCAST THEN CONSTANTS.SERVICE_CODE_BACKCAST_STR
			WHEN CONSTANTS.CODE_ACTUAL THEN CONSTANTS.SERVICE_CODE_ACTUAL_STR
		END
	INTO p_STATEMENT_TYPE_NAME, p_SERVICE_CODE
	FROM RETAIL_INVOICE I, STATEMENT_TYPE S
	WHERE I.RETAIL_INVOICE_ID = p_RETAIL_INVOICE_ID
		AND S.STATEMENT_TYPE_ID(+) = I.STATEMENT_TYPE_ID;

	OPEN p_CURSOR FOR
		SELECT	SUMM.ACCOUNT_ID,
			SUMM.SERVICE_POINT_ID as POD_ID,
			SUMM.INVOICE_DATE,
			SENDER.PSE_NAME AS SENDER_NAME,
			RECIPIENT.PSE_NAME AS RECIPIENT_NAME,
			CASE WHEN SUMM.ACCOUNT_ID <> 0 THEN SUMM.ACCOUNT_NAME
				 WHEN SUMM.SERVICE_POINT_ID <> 0 THEN SUMM.SERVICE_POINT_NAME
				END AS ENTITY_NAME,
			CASE WHEN SUMM.ACCOUNT_ID <> 0 THEN 'Account'
				 WHEN SUMM.SERVICE_POINT_ID <> 0 THEN 'POD'
				END AS ENTITY_TYPE,
			CASE WHEN SUMM.ACCOUNT_ID <> 0
					THEN EI.GET_ENTITY_IDENTIFIER_EXTSYS(EC.ED_ACCOUNT, SUMM.ACCOUNT_ID, EC.ES_TDIE, EI.g_DEFAULT_IDENTIFIER_TYPE, 1)
				WHEN SUMM.SERVICE_POINT_ID <> 0
					THEN EI.GET_ENTITY_IDENTIFIER_EXTSYS(EC.ED_SERVICE_POINT, SUMM.SERVICE_POINT_ID, EC.ES_TDIE, EI.g_DEFAULT_IDENTIFIER_TYPE, 1) END AS ENTITY_EXT_IDENT,
			CASE WHEN NVL(SUMM.METER_ID,CONSTANTS.NOT_ASSIGNED)=CONSTANTS.NOT_ASSIGNED THEN NULL ELSE SUMM.METER_NAME END METER_NAME,
			CASE WHEN NVL(SUMM.METER_ID,CONSTANTS.NOT_ASSIGNED)=CONSTANTS.NOT_ASSIGNED THEN NULL ELSE EI.GET_ENTITY_IDENTIFIER_EXTSYS(EC.ED_METER, SUMM.METER_ID, EC.ES_TDIE, EI.g_DEFAULT_IDENTIFIER_TYPE, 1) END AS METER_SERIAL_NUMBER,
			CASE WHEN SUMM.ACCOUNT_ID <> 0 THEN
				(SELECT NVL(MAX(M.METER_TYPE), 'Interval')
				FROM ACCOUNT_SERVICE_LOCATION ASL,
					SERVICE_LOCATION_METER SLM,
					METER M
				WHERE ASL.ACCOUNT_ID = SUMM.ACCOUNT_ID
					AND ASL.BEGIN_DATE <= p_END_DATE
					AND NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND SLM.SERVICE_LOCATION_ID = ASL.SERVICE_LOCATION_ID
					AND SLM.BEGIN_DATE <= p_END_DATE
					AND NVL(SLM.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND M.METER_ID = SLM.METER_ID)
			ELSE NULL END AS INTERVAL_TYPE,
			P.PRODUCT_ID,
			P.PRODUCT_NAME,
			C.COMPONENT_ID,
			C.COMPONENT_NAME,
			T.PERIOD_NAME,
			SUMM.TOTAL_INTERNAL_QUANTITY,
			SUMM.TOTAL_INTERNAL_AMOUNT,
			SUMM.TOTAL_EXTERNAL_QUANTITY,
			SUMM.TOTAL_EXTERNAL_AMOUNT,
			SUMM.INTERNAL_RATE,
			SUMM.EXTERNAL_RATE,
			SUMM.SUMMARY_TYPE,
			SUMM.GROUPING_ID,
			p_SHOW_COMPONENT_ID AS SHOW_COMPONENT_ID,
			SUMM.RETAIL_INVOICE_LINE_COMP_ID,
			RILC.BEGIN_DATE AS INVOICE_LINE_COMPONENT_BEGIN,
			RILC.END_DATE AS INVOICE_LINE_COMPONENT_END,
			p_RETAIL_INVOICE_ID_TEXT AS RETAIL_INVOICE_NAME
		FROM PURCHASING_SELLING_ENTITY RECIPIENT,
			PURCHASING_SELLING_ENTITY SENDER,
			STATEMENT_TYPE S,
			(SELECT
				GROUPING_ID(I.RECIPIENT_PSE_ID, I.SENDER_PSE_ID, I.INVOICE_DATE, I.STATEMENT_TYPE_ID, R.PRODUCT_ID,
										A.ACCOUNT_NAME, A.ACCOUNT_ID, M.METER_NAME, M.METER_ID, SP.SERVICE_POINT_NAME,
										SP.SERVICE_POINT_ID, R.COMPONENT_ID, R.PERIOD_ID, R.RETAIL_INVOICE_LINE_COMP_ID,
										R.RETAIL_INVOICE_LINE_ID) AS GROUPING_ID,
				-- Summary Type = 1 implies a Grand Total, Summary Type = 2 implies Account Sumamry, Summary Type = 3 implies Product Sub-Total
				CASE WHEN GROUPING_ID(I.RECIPIENT_PSE_ID, I.SENDER_PSE_ID, I.INVOICE_DATE, I.STATEMENT_TYPE_ID, R.PRODUCT_ID,
										A.ACCOUNT_NAME, A.ACCOUNT_ID, M.METER_NAME, M.METER_ID, SP.SERVICE_POINT_NAME,
										SP.SERVICE_POINT_ID, R.COMPONENT_ID, R.PERIOD_ID, R.RETAIL_INVOICE_LINE_COMP_ID,
										R.RETAIL_INVOICE_LINE_ID) = 0 THEN 0 -- No rollup
					WHEN GROUPING_ID(I.RECIPIENT_PSE_ID, I.SENDER_PSE_ID, I.INVOICE_DATE, I.STATEMENT_TYPE_ID, R.PRODUCT_ID,
										A.ACCOUNT_NAME, A.ACCOUNT_ID, M.METER_NAME, M.METER_ID, SP.SERVICE_POINT_NAME,
										SP.SERVICE_POINT_ID, R.COMPONENT_ID, R.PERIOD_ID, R.RETAIL_INVOICE_LINE_COMP_ID,
										R.RETAIL_INVOICE_LINE_ID) = 15 AND p_SHOW_COMPONENT_ID = 0 THEN NULL -- No Conditional formating in Product mode
					WHEN GROUPING_ID(I.RECIPIENT_PSE_ID, I.SENDER_PSE_ID, I.INVOICE_DATE, I.STATEMENT_TYPE_ID, R.PRODUCT_ID,
										A.ACCOUNT_NAME, A.ACCOUNT_ID, M.METER_NAME, M.METER_ID, SP.SERVICE_POINT_NAME,
										SP.SERVICE_POINT_ID, R.COMPONENT_ID, R.PERIOD_ID, R.RETAIL_INVOICE_LINE_COMP_ID,
										R.RETAIL_INVOICE_LINE_ID) = 15 AND p_SHOW_COMPONENT_ID = 1 THEN 3 -- Product rollup in Component mode
					WHEN GROUPING_ID(I.RECIPIENT_PSE_ID, I.SENDER_PSE_ID, I.INVOICE_DATE, I.STATEMENT_TYPE_ID, R.PRODUCT_ID, A.ACCOUNT_NAME,
										A.ACCOUNT_ID, M.METER_NAME, M.METER_ID, SP.SERVICE_POINT_NAME, SP.SERVICE_POINT_ID, R.COMPONENT_ID,
										R.PERIOD_ID, R.RETAIL_INVOICE_LINE_COMP_ID, R.RETAIL_INVOICE_LINE_ID) = 2047 THEN 1 -- Grand total
					WHEN GROUPING_ID(I.RECIPIENT_PSE_ID, I.SENDER_PSE_ID, I.INVOICE_DATE, I.STATEMENT_TYPE_ID, R.PRODUCT_ID,
										A.ACCOUNT_NAME, A.ACCOUNT_ID, M.METER_NAME, M.METER_ID, SP.SERVICE_POINT_NAME,
										SP.SERVICE_POINT_ID, R.COMPONENT_ID, R.PERIOD_ID, R.RETAIL_INVOICE_LINE_COMP_ID,
										R.RETAIL_INVOICE_LINE_ID) = 1023
										AND (p_SHOW_PRODUCT_ID = 1 OR p_SHOW_COMPONENT_ID = 1) THEN 2 -- Total by Account
				END AS SUMMARY_TYPE,
				I.RECIPIENT_PSE_ID,
				I.SENDER_PSE_ID,
				I.INVOICE_DATE,
				I.STATEMENT_TYPE_ID,
				A.ACCOUNT_ID,
				A.ACCOUNT_NAME,
				M.METER_ID,
				M.METER_NAME,
				SP.SERVICE_POINT_ID,
				SP.SERVICE_POINT_NAME,
				R.RETAIL_INVOICE_LINE_ID,
				R.RETAIL_INVOICE_LINE_COMP_ID,
				CASE WHEN p_SHOW_PRODUCT_ID = 1 THEN R.PRODUCT_ID ELSE NULL END PRODUCT_ID,
				CASE WHEN  p_SHOW_COMPONENT_ID = 1 THEN R.COMPONENT_ID ELSE NULL END COMPONENT_ID,
				R.PERIOD_ID,
				NVL(SUM(R.INTERNAL_QUANTITY),0) AS TOTAL_INTERNAL_QUANTITY,
				NVL(SUM(R.INTERNAL_AMOUNT),0) AS TOTAL_INTERNAL_AMOUNT,
				NVL(AVG(R.INTERNAL_RATE),0) AS INTERNAL_RATE,
				SUM(R.EXTERNAL_QUANTITY) AS TOTAL_EXTERNAL_QUANTITY,
				SUM(R.EXTERNAL_AMOUNT) AS TOTAL_EXTERNAL_AMOUNT,
				AVG(R.EXTERNAL_RATE) AS EXTERNAL_RATE
			FROM RETAIL_INVOICE I,
				RETAIL_INVOICE_LINE L,
				RETAIL_INVOICE_LINE_COMPONENT R,
				ACCOUNT A,
				METER M,
				SERVICE_POINT SP
			WHERE I.RETAIL_INVOICE_ID = p_RETAIL_INVOICE_ID
				AND L.RETAIL_INVOICE_ID = I.RETAIL_INVOICE_ID
				AND R.RETAIL_INVOICE_LINE_ID = L.RETAIL_INVOICE_LINE_ID
				AND (R.PRODUCT_ID = p_PRODUCT_ID OR p_PRODUCT_ID = CONSTANTS.ALL_ID)
				AND (R.COMPONENT_ID = p_COMPONENT_ID OR p_COMPONENT_ID = CONSTANTS.ALL_ID)
				AND A.ACCOUNT_ID = L.ACCOUNT_ID
				AND M.METER_ID = L.METER_ID
				AND SP.SERVICE_POINT_ID = L.SERVICE_POINT_ID
			    AND (-- Don't try to filter results for lines which do not have an account or service point
                        (L.ACCOUNT_ID = CONSTANTS.NOT_ASSIGNED AND L.SERVICE_POINT_ID = CONSTANTS.NOT_ASSIGNED) OR
                        -- Search by Name
						(p_SEARCH_OPTION = c_SEARCH_BY_NAME AND
							(A.ACCOUNT_NAME LIKE v_SEARCH_STRING OR
							SP.SERVICE_POINT_NAME LIKE v_SEARCH_STRING))OR
						-- Search By External identifier
						(p_SEARCH_OPTION = c_SEARCH_BY_EXT_IDENT AND
							(CASE WHEN A.ACCOUNT_ID IS NULL THEN NULL ELSE EI.GET_ENTITY_IDENTIFIER_EXTSYS(EC.ED_ACCOUNT, A.ACCOUNT_ID, EC.ES_TDIE, EI.g_DEFAULT_IDENTIFIER_TYPE, 1) END LIKE v_SEARCH_STRING
							 OR CASE WHEN SP.SERVICE_POINT_ID IS NULL THEN NULL ELSE EI.GET_ENTITY_IDENTIFIER_EXTSYS(EC.ED_SERVICE_POINT, SP.SERVICE_POINT_ID, EC.ES_TDIE, EI.g_DEFAULT_IDENTIFIER_TYPE, 1) END LIKE v_SEARCH_STRING)))
				 AND (v_THRESHOLD_VALUE IS NULL OR ((p_THRESHOLD_TYPE = c_THRESHOLD_TYPE_CHARGE_TOTAL AND ABS(NVL(EXTERNAL_AMOUNT,0) - NVL(INTERNAL_AMOUNT,0)) > v_THRESHOLD_VALUE)
					 OR (p_THRESHOLD_TYPE = c_THRESHOLD_TYPE_CHARGE_PCT AND (NVL(EXTERNAL_AMOUNT,0)=0 OR ABS(NVL(EXTERNAL_AMOUNT,0) - NVL(INTERNAL_AMOUNT,0))/NVL(EXTERNAL_AMOUNT,0)*100 > v_THRESHOLD_VALUE))
					 OR (p_THRESHOLD_TYPE = c_THRESHOLD_TYPE_VOLUME_TOTAL AND ABS(NVL(EXTERNAL_QUANTITY,0) - NVL(INTERNAL_QUANTITY,0))> v_THRESHOLD_VALUE)
					 OR (p_THRESHOLD_TYPE = c_THRESHOLD_TYPE_VOLUME_PCT AND (NVL(EXTERNAL_QUANTITY,0)=0 OR ABS(NVL(EXTERNAL_QUANTITY,0) - NVL(INTERNAL_QUANTITY,0))/NVL(EXTERNAL_QUANTITY,0)*100 > v_THRESHOLD_VALUE))))
			GROUP BY ROLLUP (I.RECIPIENT_PSE_ID, I.SENDER_PSE_ID, I.INVOICE_DATE, I.STATEMENT_TYPE_ID, R.PRODUCT_ID,
						A.ACCOUNT_NAME, A.ACCOUNT_ID, M.METER_NAME, M.METER_ID, SP.SERVICE_POINT_NAME, SP.SERVICE_POINT_ID,
						R.COMPONENT_ID, R.PERIOD_ID, R.RETAIL_INVOICE_LINE_COMP_ID, R.RETAIL_INVOICE_LINE_ID)
			HAVING -- No Rollup
				(GROUPING_ID(I.RECIPIENT_PSE_ID, I.SENDER_PSE_ID, I.INVOICE_DATE, I.STATEMENT_TYPE_ID, R.PRODUCT_ID,
					A.ACCOUNT_NAME, A.ACCOUNT_ID, M.METER_NAME, M.METER_ID, SP.SERVICE_POINT_NAME, SP.SERVICE_POINT_ID,
					R.COMPONENT_ID, R.PERIOD_ID, R.RETAIL_INVOICE_LINE_COMP_ID, R.RETAIL_INVOICE_LINE_ID)=0
					AND (p_SHOW_COMPONENT_ID=1)) OR
				-- GRAND TOTAL FOR THE INVOICE (ALWAYS SHOW)
				(GROUPING_ID(I.RECIPIENT_PSE_ID, I.SENDER_PSE_ID, I.INVOICE_DATE, I.STATEMENT_TYPE_ID, R.PRODUCT_ID,
					A.ACCOUNT_NAME, A.ACCOUNT_ID, M.METER_NAME, M.METER_ID, SP.SERVICE_POINT_NAME, SP.SERVICE_POINT_ID,
					R.COMPONENT_ID, R.PERIOD_ID, R.RETAIL_INVOICE_LINE_COMP_ID, R.RETAIL_INVOICE_LINE_ID)=2047) OR
				-- Product Mode
					-- ACCOUNT Roll up
					(GROUPING_ID(I.RECIPIENT_PSE_ID, I.SENDER_PSE_ID, I.INVOICE_DATE, I.STATEMENT_TYPE_ID, R.PRODUCT_ID,
						A.ACCOUNT_NAME, A.ACCOUNT_ID, M.METER_NAME, M.METER_ID, SP.SERVICE_POINT_NAME, SP.SERVICE_POINT_ID,
						R.COMPONENT_ID, R.PERIOD_ID, R.RETAIL_INVOICE_LINE_COMP_ID, R.RETAIL_INVOICE_LINE_ID)=15
						AND p_SHOW_PRODUCT_ID=1 AND p_SHOW_COMPONENT_ID=0) OR
					-- PRODUCT Roll up
					(GROUPING_ID(I.RECIPIENT_PSE_ID, I.SENDER_PSE_ID, I.INVOICE_DATE, I.STATEMENT_TYPE_ID, R.PRODUCT_ID,
						A.ACCOUNT_NAME, A.ACCOUNT_ID, M.METER_NAME, M.METER_ID, SP.SERVICE_POINT_NAME, SP.SERVICE_POINT_ID,
						R.COMPONENT_ID, R.PERIOD_ID, R.RETAIL_INVOICE_LINE_COMP_ID, R.RETAIL_INVOICE_LINE_ID)=1023
						AND p_SHOW_PRODUCT_ID=1 AND p_SHOW_COMPONENT_ID=0 AND p_SHOW_SUB_TOTAL=1) OR
				-- Component Mode
					-- ACCOUNT roll up
				(GROUPING_ID(I.RECIPIENT_PSE_ID, I.SENDER_PSE_ID, I.INVOICE_DATE, I.STATEMENT_TYPE_ID, R.PRODUCT_ID,
					A.ACCOUNT_NAME, A.ACCOUNT_ID, M.METER_NAME, M.METER_ID, SP.SERVICE_POINT_NAME, SP.SERVICE_POINT_ID,
					R.COMPONENT_ID, R.PERIOD_ID, R.RETAIL_INVOICE_LINE_COMP_ID, R.RETAIL_INVOICE_LINE_ID)=15
					AND p_SHOW_COMPONENT_ID=1 AND p_SHOW_SUB_TOTAL=1) OR
					-- PRODUCT roll up
				(GROUPING_ID(I.RECIPIENT_PSE_ID, I.SENDER_PSE_ID, I.INVOICE_DATE, I.STATEMENT_TYPE_ID, R.PRODUCT_ID,
					A.ACCOUNT_NAME, A.ACCOUNT_ID, M.METER_NAME, M.METER_ID, SP.SERVICE_POINT_NAME, SP.SERVICE_POINT_ID,
					R.COMPONENT_ID, R.PERIOD_ID, R.RETAIL_INVOICE_LINE_COMP_ID, R.RETAIL_INVOICE_LINE_ID)=1023
					AND p_SHOW_COMPONENT_ID=1 AND p_SHOW_SUB_TOTAL=1 AND p_SHOW_PRODUCT_ID = 1) OR
				-- ACCOUNT MODE
					-- ACCOUNT ROLL UP
				(GROUPING_ID(I.RECIPIENT_PSE_ID, I.SENDER_PSE_ID, I.INVOICE_DATE, I.STATEMENT_TYPE_ID, R.PRODUCT_ID,
					A.ACCOUNT_NAME, A.ACCOUNT_ID, M.METER_NAME, M.METER_ID, SP.SERVICE_POINT_NAME, SP.SERVICE_POINT_ID,
					R.COMPONENT_ID, R.PERIOD_ID, R.RETAIL_INVOICE_LINE_COMP_ID, R.RETAIL_INVOICE_LINE_ID)=15
					AND p_SHOW_COMPONENT_ID=0 AND p_SHOW_PRODUCT_ID = 0)
					) SUMM,
			PRODUCT P,
			COMPONENT C,
			PERIOD T,
			RETAIL_INVOICE_LINE_COMPONENT RILC
		WHERE RECIPIENT.PSE_ID(+) = SUMM.RECIPIENT_PSE_ID
			AND SENDER.PSE_ID(+) = SUMM.SENDER_PSE_ID
			AND S.STATEMENT_TYPE_ID(+) = SUMM.STATEMENT_TYPE_ID
			AND P.PRODUCT_ID(+) = SUMM.PRODUCT_ID
			AND C.COMPONENT_ID(+) = SUMM.COMPONENT_ID
			AND T.PERIOD_ID(+) = SUMM.PERIOD_ID
			AND RILC.RETAIL_INVOICE_LINE_COMP_ID (+) = SUMM.RETAIL_INVOICE_LINE_COMP_ID
		ORDER BY P.PRODUCT_NAME, SUMM.ACCOUNT_NAME, SUMM.SERVICE_POINT_NAME, SUMM.METER_NAME, C.COMPONENT_NAME NULLS LAST;

END RETAIL_INVOICE_DETAILS;
----------------------------------------------------------------------
PROCEDURE PRICING_RESULTS_DETAILS
	(
	p_TIME_ZONE IN VARCHAR2,
	p_RETAIL_INVOICE_LINE_COMP_ID IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT TPROD.PRODUCT_NAME AS TAXED_PRODUCT_NAME,
			TCOMP.COMPONENT_NAME AS TAXED_COMPONENT_NAME,
			CCOMP.COMPONENT_NAME AS CHILD_COMPONENT_NAME,
			P.PERIOD_NAME,
			R.BAND_TIER_NUMBER,
			CASE WHEN R.DATES_ARE_CUT = 1 THEN FROM_CUT_AS_HED(R.BEGIN_DATE, p_TIME_ZONE, DATE_UTIL.c_ABBR_5MIN)
				ELSE FROM_CUT_AS_HED(R.BEGIN_DATE, p_TIME_ZONE, DATE_UTIL.c_ABBR_DAY, GA.ELECTRIC_MODEL, GA.STANDARD, DATE_UTIL.c_ABBR_DAY)
			END AS BEGIN_DATE,
			CASE WHEN R.DATES_ARE_CUT = 1 THEN FROM_CUT_AS_HED(R.END_DATE, p_TIME_ZONE, DATE_UTIL.c_ABBR_5MIN)
				ELSE FROM_CUT_AS_HED(R.END_DATE, p_TIME_ZONE, DATE_UTIL.c_ABBR_DAY, GA.ELECTRIC_MODEL, GA.STANDARD, DATE_UTIL.c_ABBR_DAY)
			END AS END_DATE,
			R.NUMBER_OF_INTERVALS,
			R.BASE_QUANTITY AS DEMAND_HOURS,
			R.FACTOR,
			R.QUANTITY,
			R.RATE,
			R.AMOUNT,
			CASE R.DETERMINANT_STATUS
				WHEN 0 THEN 'OK' WHEN 1 THEN 'Missing' WHEN 2 THEN 'Partial'
			END AS DETERMINANT_STATUS,
			R.FML_CHARGE_ID
		FROM RETAIL_INVOICE_PRICING_RESULT R,
			PRODUCT TPROD,
			COMPONENT TCOMP,
			COMPONENT CCOMP,
			PERIOD P
		WHERE R.RETAIL_INVOICE_LINE_COMP_ID = p_RETAIL_INVOICE_LINE_COMP_ID
			AND TPROD.PRODUCT_ID(+) = R.TAXED_PRODUCT_ID
			AND TCOMP.COMPONENT_ID(+) = R.TAXED_COMPONENT_ID
			AND CCOMP.COMPONENT_ID(+) = R.CHILD_COMPONENT_ID
			AND P.PERIOD_ID(+) = R.PERIOD_ID;

END PRICING_RESULTS_DETAILS;
---------------------------------------------------------------------------------------------------
PROCEDURE FORMULA_CHARGE_DETAIL
    (
	p_TIME_ZONE IN VARCHAR2,
	p_FML_CHARGE_ID IN NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
v_WORK_ID NUMBER;
BEGIN

	UT.GET_RTO_WORK_ID(v_WORK_ID);

	INSERT INTO RTO_WORK(WORK_ID, WORK_XID)
	VALUES (v_WORK_ID, p_FML_CHARGE_ID);

	CALC_ENGINE_UI.FORMULA_CHARGE_DETAIL(v_WORK_ID,0,1);

	OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(RECORD_DATE, p_TIME_ZONE, DECODE(TO_CHAR(RECORD_DATE,'SS'),'01','DD','MI5'), GA.ELECTRIC_MODEL) as CHARGE_DATE,
			ITERATOR1_NAME, ITERATOR1_VAL ITERATOR1, ITERATOR2_NAME, ITERATOR2_VAL ITERATOR2,
			ITERATOR3_NAME, ITERATOR3_VAL ITERATOR3, ITERATOR4_NAME, ITERATOR4_VAL ITERATOR4,
			ITERATOR5_NAME, ITERATOR5_VAL ITERATOR5, ITERATOR6_NAME, ITERATOR6_VAL ITERATOR6,
			ITERATOR7_NAME, ITERATOR7_VAL ITERATOR7, ITERATOR8_NAME, ITERATOR8_VAL ITERATOR8,
			ITERATOR9_NAME, ITERATOR9_VAL ITERATOR9, ITERATOR10_NAME, ITERATOR10_VAL ITERATOR10,
			VARIABLE_NAME, VARIABLE_VALUE,
			CALC_ORDER, VIEW_ORDER,
			CHARGE_QUANTITY, BILL_QUANTITY,
			CHARGE_RATE, CHARGE_FACTOR,
			CHARGE_AMOUNT, BILL_AMOUNT,
			DISPUTE_STATUS
		FROM FORMULA_CHARGE_DRILL_DOWN_TEMP;

	DELETE FROM FORMULA_CHARGE_DRILL_DOWN_TEMP;

EXCEPTION
	WHEN OTHERS THEN
		DELETE FROM FORMULA_CHARGE_DRILL_DOWN_TEMP;
		ERRS.LOG_AND_RAISE;
END FORMULA_CHARGE_DETAIL;
----------------------------------------------------------------------
-- Answer the number of existing manual disputes for the given key data
-- %param p_RETAIL_INVOICE_DISPUTE_DATA IN t_RETAIL_INVOICE_DISPUTE_DATA Key data used to associate manual disputes with invoice line components
-- %return NUMBER of existing manual disputes
FUNCTION GET_MANUAL_DISPUTE_COUNT
(
    p_RETAIL_INVOICE_DISPUTE_DATA IN RETAIL_SETTLEMENT.t_RETAIL_INVOICE_DISPUTE_DATA
) RETURN NUMBER AS
    v_MANUAL_DISPUTE_COUNT NUMBER;
BEGIN
    SELECT COUNT(*)
	INTO v_MANUAL_DISPUTE_COUNT
	FROM RETAIL_INVOICE_DISPUTE RID
	WHERE RID.DISPUTE_TYPE = RETAIL_SETTLEMENT.c_DISPUTE_TYPE_MANUAL
	  AND RID.RETAIL_INVOICE_ID = p_RETAIL_INVOICE_DISPUTE_DATA.RETAIL_INVOICE_ID
	  AND RID.ACCOUNT_ID = p_RETAIL_INVOICE_DISPUTE_DATA.ACCOUNT_ID
	  AND RID.METER_ID = p_RETAIL_INVOICE_DISPUTE_DATA.METER_ID
	  AND RID.SERVICE_POINT_ID = p_RETAIL_INVOICE_DISPUTE_DATA.SERVICE_POINT_ID
	  AND RID.PRODUCT_ID = p_RETAIL_INVOICE_DISPUTE_DATA.PRODUCT_ID
	  AND RID.COMPONENT_ID = p_RETAIL_INVOICE_DISPUTE_DATA.COMPONENT_ID
	  -- PERIOD can be null so wrap in NVL
	  AND NVL(RID.PERIOD_ID,CONSTANTS.NOT_ASSIGNED) = NVL(p_RETAIL_INVOICE_DISPUTE_DATA.PERIOD_ID,CONSTANTS.NOT_ASSIGNED)
	  AND RID.BEGIN_DATE = p_RETAIL_INVOICE_DISPUTE_DATA.BEGIN_DATE
	  AND RID.END_DATE = p_RETAIL_INVOICE_DISPUTE_DATA.END_DATE;
	  
	RETURN v_MANUAL_DISPUTE_COUNT;
END GET_MANUAL_DISPUTE_COUNT;
----------------------------------------------------------------------	
-- This is the GET procedure for the Manual Disputes Entry screen.
-- %param p_RETAIL_INVOICE_LINE_COMP_ID IN NUMBER The ID of the invoice/line/product/component from which the screen was opened
-- %param p_INVOICE_DATE_STRING OUT VARCHAR2 Formatted Invoice Date string for the grid label
-- %param p_INVOICE_NUMBER OUT VARCHAR2 Invoice Number for the grid label
-- %param p_CHARGE_BEGIN OUT VARCHAR2 Formatted Charge begin date for the grid label
-- %param p_CHARGE_END OUT VARCHAR2 Formatted Charge end date for the grid label
-- %param p_CURSOR OUT GA.REFCURSOR Cursor to fill the grid with rows
PROCEDURE GET_MANUAL_DISPUTES
(
    p_RETAIL_INVOICE_LINE_COMP_ID IN NUMBER,
	p_INVOICE_DATE_STRING OUT VARCHAR2,
	p_INVOICE_NUMBER OUT VARCHAR2,
	p_CHARGE_BEGIN OUT VARCHAR2,
	p_CHARGE_END OUT VARCHAR2,
    p_CURSOR OUT GA.REFCURSOR
) AS
    v_RETAIL_INVOICE_DISPUTE_DATA RETAIL_SETTLEMENT.t_RETAIL_INVOICE_DISPUTE_DATA;
	v_MANUAL_DISPUTE_COUNT NUMBER;
	v_DEFAULT_DISPUTE_STATUS RETAIL_INVOICE_DISPUTE.DISPUTE_STATUS%TYPE;
	v_DEFAULT_PROCESS_STATUS RETAIL_INVOICE_DISPUTE.PROCESS_STATUS%TYPE;
BEGIN
    -- Collect data for a Retail Invoice Dispute from the various Retail Invoice tables
	v_RETAIL_INVOICE_DISPUTE_DATA := RETAIL_SETTLEMENT.GET_RI_DISPUTE_DATA(p_RETAIL_INVOICE_LINE_COMP_ID);
	
	-- Set the grid label values
	p_INVOICE_DATE_STRING := TO_CHAR(v_RETAIL_INVOICE_DISPUTE_DATA.INVOICE_DATE, CONSTANTS.FORMAT_SHORT_DATE_ISO);
	p_INVOICE_NUMBER := v_RETAIL_INVOICE_DISPUTE_DATA.INVOICE_NUMBER;
	p_CHARGE_BEGIN := TO_CHAR(v_RETAIL_INVOICE_DISPUTE_DATA.BEGIN_DATE, CONSTANTS.FORMAT_SHORT_DATE_ISO);
	p_CHARGE_END := TO_CHAR(v_RETAIL_INVOICE_DISPUTE_DATA.END_DATE, CONSTANTS.FORMAT_SHORT_DATE_ISO);
	
	v_MANUAL_DISPUTE_COUNT := GET_MANUAL_DISPUTE_COUNT(v_RETAIL_INVOICE_DISPUTE_DATA);
	IF v_MANUAL_DISPUTE_COUNT = 0 THEN
	    -- If there are no existing manual disputes, we are going to create a new one
		-- So we need the default values for Dispute Status and Process Status
		-- from System Labels to populate the placeholder row in the grid
	    SP.GET_DEFAULT_SYSTEM_LABEL(p_MODEL_ID   => GA.GLOBAL_MODEL,
									p_MODULE     => RETAIL_SETTLEMENT_UI.c_SL_DISPUTE_MANAGEMENT_MODULE,
									p_KEY1       => RETAIL_SETTLEMENT_UI.c_SL_DISPUTE_MANAGEMENT_KEY1,
									p_KEY2       => RETAIL_SETTLEMENT_UI.c_SL_DISPUTE_STATUS_KEY2,
									p_KEY3       => CONSTANTS.UNDEFINED_ATTRIBUTE,
									p_VALUE      => v_DEFAULT_DISPUTE_STATUS);
	    SP.GET_DEFAULT_SYSTEM_LABEL(p_MODEL_ID   => GA.GLOBAL_MODEL,
									p_MODULE     => RETAIL_SETTLEMENT_UI.c_SL_DISPUTE_MANAGEMENT_MODULE,
									p_KEY1       => RETAIL_SETTLEMENT_UI.c_SL_DISPUTE_MANAGEMENT_KEY1,
									p_KEY2       => RETAIL_SETTLEMENT_UI.c_SL_PROCESS_STATUS_KEY2,
									p_KEY3       => CONSTANTS.UNDEFINED_ATTRIBUTE,
									p_VALUE      => v_DEFAULT_PROCESS_STATUS);
	END IF;

    OPEN p_CURSOR FOR
	SELECT RID.DISPUTE_ID,
	       RID.DISPUTE_STATUS,
	       RID.PROCESS_STATUS,
		   RID.DISPUTE_CATEGORY,
		   RID.NOTES,
		   RID.UPDATED_BY,
		   RID.UPDATED_DATE,
		   RID.INTERNAL_QUANTITY,
		   RID.INTERNAL_AMOUNT,
		   RID.EXTERNAL_QUANTITY,
		   RID.EXTERNAL_AMOUNT,
		   RID.SETTLEMENT_RUN_ON
	FROM RETAIL_INVOICE_DISPUTE RID
	WHERE RID.DISPUTE_TYPE = RETAIL_SETTLEMENT.c_DISPUTE_TYPE_MANUAL
	  AND RID.RETAIL_INVOICE_ID = v_RETAIL_INVOICE_DISPUTE_DATA.RETAIL_INVOICE_ID
	  AND RID.ACCOUNT_ID = v_RETAIL_INVOICE_DISPUTE_DATA.ACCOUNT_ID
	  AND RID.METER_ID = v_RETAIL_INVOICE_DISPUTE_DATA.METER_ID
	  AND RID.SERVICE_POINT_ID = v_RETAIL_INVOICE_DISPUTE_DATA.SERVICE_POINT_ID
	  AND RID.PRODUCT_ID = v_RETAIL_INVOICE_DISPUTE_DATA.PRODUCT_ID
	  AND RID.COMPONENT_ID = v_RETAIL_INVOICE_DISPUTE_DATA.COMPONENT_ID
	  -- PERIOD_ID can be null so wrap in NVL for comparison
	  AND NVL(RID.PERIOD_ID,CONSTANTS.NOT_ASSIGNED) = NVL(v_RETAIL_INVOICE_DISPUTE_DATA.PERIOD_ID,CONSTANTS.NOT_ASSIGNED)
	  AND RID.BEGIN_DATE = v_RETAIL_INVOICE_DISPUTE_DATA.BEGIN_DATE
	  AND RID.END_DATE = v_RETAIL_INVOICE_DISPUTE_DATA.END_DATE
	UNION ALL
	-- If there are no existing manual disputes, return placeholder row
	SELECT NULL DISPUTE_ID,
	       v_DEFAULT_DISPUTE_STATUS DISPUTE_STATUS,
	       v_DEFAULT_PROCESS_STATUS PROCESS_STATUS,
		   NULL DISPUTE_CATEGORY,
		   NULL NOTES,
		   NULL UPDATED_BY,
		   NULL UPDATED_DATE,
		   v_RETAIL_INVOICE_DISPUTE_DATA.INTERNAL_QUANTITY INTERNAL_QUANTITY,
		   v_RETAIL_INVOICE_DISPUTE_DATA.INTERNAL_AMOUNT INTERNAL_AMOUNT,
		   v_RETAIL_INVOICE_DISPUTE_DATA.EXTERNAL_QUANTITY EXTERNAL_QUANTITY,
		   v_RETAIL_INVOICE_DISPUTE_DATA.EXTERNAL_AMOUNT EXTERNAL_AMOUNT,
		   v_RETAIL_INVOICE_DISPUTE_DATA.SETTLEMENT_RUN_ON SETTLEMENT_RUN_ON
	FROM DUAL
	WHERE v_MANUAL_DISPUTE_COUNT = 0;
END GET_MANUAL_DISPUTES;
----------------------------------------------------------------------	
-- This is the PUT procedure for the Manual Disputes Entry screen.
-- %param p_RETAIL_INVOICE_LINE_COMP_ID IN NUMBER The ID of the invoice/line/product/component off which the screen was opened
-- %param p_DISPUTE_ID IN OUT NUMBER The ID of the manual dispute (NULL if new, ID if editing); also OUT parameter to return new ID
-- %param p_DISPUTE_STATUS IN VARCHAR2 User entered Dispute Status
-- %param p_PROCESS_STATUS IN VARCHAR2 User entered Process Status
-- %param p_DISPUTE_CATEGORY IN VARCHAR2 User entered Dispute Category
-- %param p_NOTES IN VARCHAR2 User entered Dispute Notes
PROCEDURE PUT_MANUAL_DISPUTE
(
	p_RETAIL_INVOICE_LINE_COMP_ID IN NUMBER,
	p_DISPUTE_ID IN OUT NUMBER,
	p_DISPUTE_STATUS IN VARCHAR2,
	p_PROCESS_STATUS IN VARCHAR2,
	p_DISPUTE_CATEGORY IN VARCHAR2,
	p_NOTES IN VARCHAR2
) AS
    v_RETAIL_INVOICE_DISPUTE_DATA RETAIL_SETTLEMENT.t_RETAIL_INVOICE_DISPUTE_DATA;
BEGIN
    IF p_DISPUTE_ID IS NOT NULL THEN
	    -- Updating; just update manual dispute specific columns
		UPDATE RETAIL_INVOICE_DISPUTE
		   SET DISPUTE_STATUS = p_DISPUTE_STATUS,
		       PROCESS_STATUS = p_PROCESS_STATUS,
			   DISPUTE_CATEGORY = p_DISPUTE_CATEGORY,
			   UPDATED_BY = SECURITY_CONTROLS.GET_CURRENT_USER_DISPLAY_NAME,
			   UPDATED_DATE = SYSDATE,
			   NOTES = p_NOTES
		 WHERE DISPUTE_ID = p_DISPUTE_ID;
	ELSE
	    -- Creating a new manual dispute
		-- Grab the snapshot of Retail Invoice data
		v_RETAIL_INVOICE_DISPUTE_DATA := RETAIL_SETTLEMENT.GET_RI_DISPUTE_DATA(p_RETAIL_INVOICE_LINE_COMP_ID);
		
		SELECT DISPUTE_ID.NEXTVAL
		INTO p_DISPUTE_ID
		FROM DUAL;
		
		INSERT INTO RETAIL_INVOICE_DISPUTE (
		    DISPUTE_ID,
			DISPUTE_TYPE,
			RETAIL_INVOICE_ID,
			ACCOUNT_ID,
			METER_ID,
			SERVICE_POINT_ID,
			PRODUCT_ID,
			COMPONENT_ID,
			PERIOD_ID,
			BEGIN_DATE,
			END_DATE,
			INTERNAL_QUANTITY,
			INTERNAL_AMOUNT,
			EXTERNAL_QUANTITY,
			EXTERNAL_AMOUNT,
			SETTLEMENT_RUN_ON,
			DISPUTE_STATUS,
			PROCESS_STATUS,
			DISPUTE_CATEGORY,
			UPDATED_BY,
			UPDATED_DATE,
			NOTES
		) VALUES (
		    p_DISPUTE_ID,
			RETAIL_SETTLEMENT.c_DISPUTE_TYPE_MANUAL,
			v_RETAIL_INVOICE_DISPUTE_DATA.RETAIL_INVOICE_ID,
			v_RETAIL_INVOICE_DISPUTE_DATA.ACCOUNT_ID,
			v_RETAIL_INVOICE_DISPUTE_DATA.METER_ID,
			v_RETAIL_INVOICE_DISPUTE_DATA.SERVICE_POINT_ID,
			v_RETAIL_INVOICE_DISPUTE_DATA.PRODUCT_ID,
			v_RETAIL_INVOICE_DISPUTE_DATA.COMPONENT_ID,
			v_RETAIL_INVOICE_DISPUTE_DATA.PERIOD_ID,
			v_RETAIL_INVOICE_DISPUTE_DATA.BEGIN_DATE,
			v_RETAIL_INVOICE_DISPUTE_DATA.END_DATE,
			v_RETAIL_INVOICE_DISPUTE_DATA.INTERNAL_QUANTITY,
			v_RETAIL_INVOICE_DISPUTE_DATA.INTERNAL_AMOUNT,
			v_RETAIL_INVOICE_DISPUTE_DATA.EXTERNAL_QUANTITY,
			v_RETAIL_INVOICE_DISPUTE_DATA.EXTERNAL_AMOUNT,
			v_RETAIL_INVOICE_DISPUTE_DATA.SETTLEMENT_RUN_ON,
			p_DISPUTE_STATUS,
			p_PROCESS_STATUS,
			p_DISPUTE_CATEGORY,
			SECURITY_CONTROLS.GET_CURRENT_USER_DISPLAY_NAME,
			SYSDATE,
			p_NOTES
		);
		
	END IF;
END PUT_MANUAL_DISPUTE;
----------------------------------------------------------------------	
END RETAIL_SETTLEMENT_UI;
/
