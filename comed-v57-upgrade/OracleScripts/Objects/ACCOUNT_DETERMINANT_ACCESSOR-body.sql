CREATE OR REPLACE TYPE BODY ACCOUNT_DETERMINANT_ACCESSOR IS
-------------------------------------------------------------------------------
OVERRIDING MEMBER PROCEDURE GET_PEAK_DETERMINANT
	(
	p_INTERVAL IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_UOM IN VARCHAR2 := NULL,
	p_TEMPLATE_ID IN NUMBER := NULL,
	p_PERIOD_ID IN NUMBER := NULL,
	p_LOSS_ADJ_TYPE IN NUMBER := NULL,
	p_INTEGRATION_INTERVAL IN VARCHAR2 := NULL,
	p_RETURN_VALUE OUT NUMBER,
	p_RETURN_STATUS OUT PLS_INTEGER
	) IS
BEGIN
	RETAIL_DETERMINANTS.GET_PEAK_DETERMINANT
							(
							SELF,
							p_INTERVAL,
							p_BEGIN_DATE,
							p_END_DATE,
							NVL(p_UOM, GA.DEFAULT_UNIT_OF_MEASUREMENT),
							p_TEMPLATE_ID,
							p_PERIOD_ID,
							p_LOSS_ADJ_TYPE,
							p_INTEGRATION_INTERVAL,
							p_RETURN_VALUE,
							p_RETURN_STATUS
							);
END GET_PEAK_DETERMINANT;
-------------------------------------------------------------------------------
OVERRIDING MEMBER PROCEDURE GET_SUM_DETERMINANTS
	(
	p_INTERVAL IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_UOM IN VARCHAR2 := NULL,
	p_TEMPLATE_ID IN NUMBER := NULL,
	p_PERIOD_ID IN NUMBER := NULL,
	p_LOSS_ADJ_TYPE IN NUMBER := NULL,
	p_INTERVAL_MINIMUM_QTY IN NUMBER := NULL,
	p_OPERATION_CODE IN VARCHAR2 := NULL,
	p_RETURN_VALUE OUT NUMBER,
	p_RETURN_STATUS OUT PLS_INTEGER
	) IS
BEGIN
	RETAIL_DETERMINANTS.GET_SUM_DETERMINANTS
							(
							SELF,
							p_INTERVAL,
							p_BEGIN_DATE,
							p_END_DATE,
							NVL(p_UOM, GA.DEFAULT_UNIT_OF_MEASUREMENT),
							p_TEMPLATE_ID,
							p_PERIOD_ID,
							p_LOSS_ADJ_TYPE,
							p_INTERVAL_MINIMUM_QTY,
							p_OPERATION_CODE,
							p_RETURN_VALUE,
							p_RETURN_STATUS
							);
END GET_SUM_DETERMINANTS;
-------------------------------------------------------------------------------
OVERRIDING MEMBER PROCEDURE GET_EFFECTIVE_ANC_SVC
	(
	p_DATE IN DATE,
	p_ANCILLARY_SERVICE_ID IN NUMBER,
	p_RETURN_VALUE OUT NUMBER,
	p_RETURN_STATUS OUT PLS_INTEGER
	) IS
v_MODEL			ACCOUNT.ACCOUNT_MODEL_OPTION%TYPE;
v_ACCT_VAL		NUMBER;
v_VAL_COUNT		PLS_INTEGER;
v_METER_VAL		NUMBER;
v_METER_COUNT	PLS_INTEGER;
v_CSB_IS_SUBDAILY CONSTANT NUMBER(1) := CASE WHEN GA.CSB_IS_SUBDAILY THEN 1 ELSE 0 END;
v_AS_IS_SUBDAILY NUMBER(1) := 0;
BEGIN

    SELECT ACCOUNT_MODEL_OPTION
	INTO v_MODEL
	FROM ACCOUNT
	WHERE ACCOUNT_ID = SELF.ACCOUNT_ID;

    IF v_CSB_IS_SUBDAILY = 1 THEN
        SELECT COUNT(1)
        INTO v_VAL_COUNT
        FROM ACCOUNT_ANCILLARY_SERVICE AAS
        WHERE AAS.ACCOUNT_ID = SELF.ACCOUNT_ID
          AND AAS.ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID
          AND AAS.BEGIN_DATE > TRUNC(AAS.BEGIN_DATE, 'MI');

        IF v_VAL_COUNT > 0 THEN
            v_AS_IS_SUBDAILY := 1;
        END IF;
    END IF;

	-- Get value assigned to the account
	SELECT SUM(AAS.SERVICE_VAL)
	INTO v_ACCT_VAL
	FROM ACCOUNT_ANCILLARY_SERVICE AAS
	WHERE AAS.ACCOUNT_ID = SELF.ACCOUNT_ID
		AND AAS.ANCILLARY_SERVICE_ID = p_ANCILLARY_SERVICE_ID
        AND (
            (v_AS_IS_SUBDAILY = 1 AND p_DATE+1/86400 BETWEEN FROM_CUT(AAS.BEGIN_DATE, NVL(SELF.TIME_ZONE, GA.LOCAL_TIME_ZONE)) AND FROM_CUT(NVL(AAS.END_DATE, CONSTANTS.HIGH_DATE), NVL(SELF.TIME_ZONE, GA.LOCAL_TIME_ZONE)))
            OR
            (v_AS_IS_SUBDAILY = 0 AND p_DATE BETWEEN AAS.BEGIN_DATE AND NVL(AAS.END_DATE, CONSTANTS.HIGH_DATE))
            )
        ;

	-- Setup return values based on account values
	IF v_ACCT_VAL IS NOT NULL THEN
		p_RETURN_VALUE := v_ACCT_VAL;
		p_RETURN_STATUS := RETAIL_DETERMINANTS.c_STATUS_OK;
	ELSE
		p_RETURN_VALUE := 0;
		p_RETURN_STATUS := RETAIL_DETERMINANTS.c_STATUS_MISSING;
	END IF;

	-- If meter-modeled, get values assigned to the meters and add them to account values
	IF UPPER(SUBSTR(v_MODEL,1,1)) = 'M' THEN
		SELECT SUM(MAS.SERVICE_VAL),
			COUNT(1),
			COUNT(MAS.METER_ID)
		INTO v_METER_VAL,
			v_METER_COUNT,
			v_VAL_COUNT
		FROM ACCOUNT_SERVICE_LOCATION ASL,
			SERVICE_LOCATION_METER SLM,
			METER_ANCILLARY_SERVICE MAS
		WHERE ASL.ACCOUNT_ID = SELF.ACCOUNT_ID
			AND SELF.SERVICE_LOCATION_ID IN (ASL.SERVICE_LOCATION_ID, CONSTANTS.NOT_ASSIGNED)
			AND p_DATE BETWEEN ASL.BEGIN_DATE AND NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE)
			AND SLM.SERVICE_LOCATION_ID = ASL.SERVICE_LOCATION_ID
			AND SELF.METER_ID IN (SLM.METER_ID, CONSTANTS.NOT_ASSIGNED)
			AND p_DATE BETWEEN SLM.BEGIN_DATE AND NVL(SLM.END_DATE, CONSTANTS.HIGH_DATE)
			AND MAS.METER_ID(+) = SLM.METER_ID
			AND MAS.ANCILLARY_SERVICE_ID(+) = p_ANCILLARY_SERVICE_ID
			AND p_DATE BETWEEN MAS.BEGIN_DATE(+) AND NVL(MAS.END_DATE(+), CONSTANTS.HIGH_DATE);

		-- if account had value, then determinant status is OK (per above assignment)
		-- otherwise, status is OK only if all meters have values.
		IF v_ACCT_VAL IS NULL THEN
			IF v_VAL_COUNT = 0 THEN
				p_RETURN_STATUS := RETAIL_DETERMINANTS.c_STATUS_MISSING;
			ELSIF v_VAL_COUNT <> v_METER_COUNT THEN
				p_RETURN_STATUS := RETAIL_DETERMINANTS.c_STATUS_PARTIAL;
			ELSE
				p_RETURN_STATUS := RETAIL_DETERMINANTS.c_STATUS_OK;
			END IF;
		END IF;
		-- add results together for total anc.svc. result value
		p_RETURN_VALUE := NVL(v_ACCT_VAL,0) + NVL(v_METER_VAL,0);
	END IF;

END GET_EFFECTIVE_ANC_SVC;
-------------------------------------------------------------------------------
OVERRIDING MEMBER FUNCTION GET_METER_TYPE_TEMPLATE_ID
	(
	p_DATE IN DATE
	) RETURN NUMBER IS
BEGIN
	RETURN RETAIL_DETERMINANTS.GET_METER_TYPE_TEMPLATE_ID(SELF, p_DATE);
END GET_METER_TYPE_TEMPLATE_ID;
-------------------------------------------------------------------------------
OVERRIDING MEMBER FUNCTION GET_FORMULA_CONTEXTS RETURN MAP_ENTRY_TABLE IS
v_RET MAP_ENTRY_TABLE := MAP_ENTRY_TABLE();
BEGIN
	v_RET.EXTEND;
	v_RET(v_RET.LAST) := MAP_ENTRY(':account', UT.GET_LITERAL_FOR_NUMBER(SELF.ACCOUNT_ID));
	v_RET.EXTEND;
	v_RET(v_RET.LAST) := MAP_ENTRY(':service_location', UT.GET_LITERAL_FOR_NUMBER(SELF.SERVICE_LOCATION_ID));
	v_RET.EXTEND;
	v_RET(v_RET.LAST) := MAP_ENTRY(':meter', UT.GET_LITERAL_FOR_NUMBER(SELF.METER_ID));
	v_RET.EXTEND;
	v_RET(v_RET.LAST) := MAP_ENTRY(':aggregate', UT.GET_LITERAL_FOR_NUMBER(SELF.AGGREGATE_ID));
	v_RET.EXTEND;
	v_RET(v_RET.LAST) := MAP_ENTRY(':scenario', UT.GET_LITERAL_FOR_NUMBER(SELF.SCENARIO_ID));
	v_RET.EXTEND;
	v_RET(v_RET.LAST) := MAP_ENTRY(':service_code', UT.GET_LITERAL_FOR_STRING(SELF.SERVICE_CODE));
	v_RET.EXTEND;
	v_RET(v_RET.LAST) := MAP_ENTRY(':time_zone', UT.GET_LITERAL_FOR_STRING(SELF.TIME_ZONE));
	v_RET.EXTEND;
	v_RET(v_RET.LAST) := MAP_ENTRY(':services', UT.GET_LITERAL_FOR_NUMBER_COLL(SELF.SERVICE_IDs));

	RETURN v_RET;
END GET_FORMULA_CONTEXTS;
-------------------------------------------------------------------------------
MEMBER FUNCTION GET_ACTIVE_SERVICES
	(
	p_BEGIN_DATE	IN DATE,
	p_END_DATE		IN DATE
	) RETURN NUMBER_COLLECTION IS
BEGIN
	RETURN RETAIL_DETERMINANTS.GET_ACTIVE_SERVICES(SELF, p_BEGIN_DATE, p_END_DATE);
END GET_ACTIVE_SERVICES;
-------------------------------------------------------------------------------
CONSTRUCTOR FUNCTION ACCOUNT_DETERMINANT_ACCESSOR
	(
	p_ACCOUNT_ID			IN NUMBER,
	p_SERVICE_LOCATION_ID	IN NUMBER,
	p_METER_ID				IN NUMBER,
	p_AGGREGATE_ID			IN NUMBER,
	p_SERVICE_CODE			IN CHAR,
	p_TIME_ZONE				IN VARCHAR2,
	p_SCENARIO_ID			IN NUMBER,
    p_ESP_ID                IN NUMBER
	) RETURN SELF AS RESULT IS
BEGIN
	ASSERT(p_ACCOUNT_ID IS NOT NULL, 'Account ID must be specified', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_SERVICE_CODE IS NOT NULL, 'Service Code must be specified', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_SERVICE_CODE IN ('F','B','A'), 'Service Code specified ('||p_SERVICE_CODE||') is invalid', MSGCODES.c_ERR_ARGUMENT);

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('Account Accessor: ACCOUNT_ID = '||p_ACCOUNT_ID||', SERVICE_LOCATION_ID = '||p_SERVICE_LOCATION_ID||', METER_ID = '||p_METER_ID||
					', AGGREGATE_ID = '||p_AGGREGATE_ID||', SERVICE_CODE = '||p_SERVICE_CODE||', TIME_ZONE = '||p_TIME_ZONE||', SCENARIO_ID = '||p_SCENARIO_ID);
	END IF;

	-- Initialize member fields
	SELF.ACCOUNT_ID := p_ACCOUNT_ID;
	SELF.SERVICE_LOCATION_ID := NVL(p_SERVICE_LOCATION_ID, CONSTANTS.NOT_ASSIGNED);
	SELF.METER_ID := NVL(p_METER_ID, CONSTANTS.NOT_ASSIGNED);
	SELF.AGGREGATE_ID := NVL(p_AGGREGATE_ID, CONSTANTS.NOT_ASSIGNED);
	SELF.SERVICE_CODE := p_SERVICE_CODE;

	SELF.TIME_ZONE := NVL(p_TIME_ZONE, GA.LOCAL_TIME_ZONE);
	SELF.SCENARIO_ID := NVL(p_SCENARIO_ID, GA.BASE_SCENARIO_ID);

	SELF.TEMPLATE_ID_EFF_DATE := NULL;
	SELF.TEMPLATE_ID := NULL;

	-- Gather service entries
	SELECT S.SERVICE_ID
	BULK COLLECT INTO SELF.SERVICE_IDs
	FROM ACCOUNT_SERVICE A,
		SERVICE S
	WHERE A.ACCOUNT_ID = SELF.ACCOUNT_ID
		AND SELF.SERVICE_LOCATION_ID IN (A.SERVICE_LOCATION_ID, CONSTANTS.NOT_ASSIGNED)
		AND SELF.METER_ID IN (A.METER_ID, CONSTANTS.NOT_ASSIGNED)
		AND SELF.AGGREGATE_ID IN (A.AGGREGATE_ID, CONSTANTS.NOT_ASSIGNED)
		AND S.MODEL_ID = GA.DEFAULT_MODEL
		AND S.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
		AND S.SCENARIO_ID = SELF.SCENARIO_ID
		AND S.AS_OF_DATE = CONSTANTS.LOW_DATE; -- no support for versioning

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('Account Accessor has '||SELF.SERVICE_IDs.COUNT||' Service IDs');
		IF LOGS.IS_DEBUG_DETAIL_ENABLED THEN
			LOGS.LOG_DEBUG_DETAIL('   Service IDs: '||TEXT_UTIL.TO_CHAR_NUMBER_LIST(SELF.SERVICE_IDs));
		END IF;
	END IF;

    SELF.ESP_ID := p_ESP_ID;

	-- Done!
	RETURN;

END ACCOUNT_DETERMINANT_ACCESSOR;
-------------------------------------------------------------------------------
OVERRIDING MEMBER PROCEDURE GET_AVERAGE_INTERVAL_COUNT
(
	p_INVOICE_LINE_BEGIN_DATE 	IN DATE,
	p_INVOICE_LINE_END_DATE 	IN DATE,
	p_UOM 						IN VARCHAR2 := NULL,
	p_QUALITY_CODE 				IN VARCHAR2 := NULL,
	p_STATUS_CODE 				IN VARCHAR2 := NULL,
	p_DATE_RANGE_INTERVAL		IN VARCHAR2 := NULL,
	p_RETURN_VALUE 				OUT NUMBER,
	p_RETURN_STATUS 			OUT PLS_INTEGER
) IS
BEGIN
	RETAIL_DETERMINANTS.GET_AVERAGE_INTERVAL_COUNT
	(
		SELF,
		p_INVOICE_LINE_BEGIN_DATE,
		p_INVOICE_LINE_END_DATE,
		p_UOM,
		p_QUALITY_CODE,
		p_STATUS_CODE,
		p_DATE_RANGE_INTERVAL,
		p_RETURN_VALUE,
		p_RETURN_STATUS
	);
END GET_AVERAGE_INTERVAL_COUNT;
---------------------------------------------------------------------------------
END;
/
