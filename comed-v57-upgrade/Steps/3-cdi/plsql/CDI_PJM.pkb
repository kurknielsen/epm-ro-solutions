CREATE OR REPLACE EDITIONABLE PACKAGE BODY CDI_PJM AS

-- Package Constants --
c_PACKAGE_NAME                 CONSTANT VARCHAR2(16) := 'CDI_PJM';
c_SUBMIT_PLC_NSPL_TO_PJM       CONSTANT VARCHAR2(64) := 'CDI: Submit PLC/NSPL To PJM';
c_SUBMIT_IN_SCHEDULE_TO_PJM    CONSTANT VARCHAR2(64) := 'CDI: Submit InSchedule To PJM';
c_SAVE_PLC_NSPL_TO_FILE        CONSTANT VARCHAR2(64) := 'CDI: Save PLC/NSPL To File';
c_QUERY_PLC_NSPL_FROM_PJM      CONSTANT VARCHAR2(64) := 'CDI: Query PLC/NSPL From PJM';
c_IMPORT_EXCHANGE_FILE         CONSTANT VARCHAR2(64) := 'CDI: Import Exchange File';
c_QUERY_FINAL_ZONE_LOAD        CONSTANT VARCHAR2(32) := 'Query Final Zone Load';
c_QUERY_500KV_LOSSES           CONSTANT VARCHAR2(32) := 'Query 500kV Losses';
c_500KV_LOSSES                 CONSTANT VARCHAR2(32) := 'EHV LOSSES (PJM-EAST)';
c_LOAD_WITH_LOSSES             CONSTANT VARCHAR2(32) := 'LOAD WITH LOSSES';
c_DERATION_FACTOR              CONSTANT VARCHAR2(32) := 'DERATION FACTOR';
c_500KV_LOSSES_TXN_NAME        CONSTANT VARCHAR2(32) := '500kV Losses';
c_LOAD_WITH_LOSSES_TXN_NAME    CONSTANT VARCHAR2(64) := 'Final Daily eMTR Load With Losses';
c_DERATION_FACTOR_TXN_NAME     CONSTANT VARCHAR2(64) := 'Marginal Loss Deration Factor';
c_LMP_RT_MARKET_PRICE_NAME     CONSTANT VARCHAR2(32) := 'BGE RT';
c_LMP_CONG_MARKET_PRICE_NAME   CONSTANT VARCHAR2(32) := 'BGE CONG';
c_LMP_LOSS_MARKET_PRICE_NAME   CONSTANT VARCHAR2(32) := 'BGE LOSS';
c_LMP_SYS_MARKET_PRICE_NAME    CONSTANT VARCHAR2(32) := 'PJM System Energy Price';
c_PLC_TAG                      CONSTANT VARCHAR2(32) := 'ObligationPeakLoadMW';
c_NSPL_TAG                     CONSTANT VARCHAR2(32) := 'NSPLMW';
c_LMP_DA_TAG                   CONSTANT VARCHAR2(32) := 'system_energy_price_da';
c_LMP_RT_TAG                   CONSTANT VARCHAR2(32) := 'system_energy_price_rt';
c_ANCILLARY                    CONSTANT VARCHAR2(32) := 'Ancillary';
c_DATE_FORMAT                  CONSTANT VARCHAR2(16) := 'MM/DD/YYYY';
c_DATE_TIME_FORMAT             CONSTANT VARCHAR2(32) := 'MM/DD/YYYY HH24:MI:SS';
c_LMP_DATE_TIME_FORMAT         CONSTANT VARCHAR2(32) := 'MM/DD/YYYY HH24:MI';
c_LMP_MONTH_DATE_TIME_FORMAT   CONSTANT VARCHAR2(32) := 'MM/DD/YYYY HH:MI:SS AM';
c_CRLF                         CONSTANT CHAR(2)      := CHR(13) || CHR(10);
c_COMMA                        CONSTANT CHAR(1)      := ',';
c_LOG_ONLY                     CONSTANT PLS_INTEGER  := 0;
c_LOG_TYPE                     CONSTANT PLS_INTEGER  := NULL;

TYPE t_IT_SCHEDULE IS TABLE OF IT_SCHEDULE%ROWTYPE;
TYPE t_MARKET_PRICE_VALUE IS TABLE OF MARKET_PRICE_VALUE%ROWTYPE;
TYPE t_IDENT_MAP IS TABLE OF NUMBER(9) INDEX BY VARCHAR2(128);
l_PROCESS_NAME                 VARCHAR2(64);

FUNCTION FORMAT_EXCEPTION_MESSAGE(p_MESSAGE IN VARCHAR2) RETURN VARCHAR2 AS
v_MESSAGE VARCHAR2(4000) := SUBSTR(p_MESSAGE, 1, INSTR(p_MESSAGE, CHR(10)) - 1);
BEGIN
   RETURN CASE WHEN LENGTH(v_MESSAGE) = 0 THEN p_MESSAGE ELSE SUBSTR(v_MESSAGE, 12) || ' [' || SUBSTR(v_MESSAGE,1,9) || ']' END;
END FORMAT_EXCEPTION_MESSAGE;

PROCEDURE DOWNLOAD_CONTRACT_NAMES(p_BEGIN_DATE IN DATE, p_END_DATE IN DATE) AS
v_STATUS NUMBER;
v_MESSAGE VARCHAR2(1000);
BEGIN
   LOGS.LOG_INFO('Download Contract Names');
   MM_PJM_CE.MARKET_EXCHANGE(p_BEGIN_DATE, p_END_DATE, MM_PJM_CE.g_ET_QUERY_SHORT_NAMES, NULL, NULL, NULL, NULL, 0, v_STATUS, v_MESSAGE);
   IF UPPER(v_MESSAGE) LIKE '%SUCCESS%' THEN
      LOGS.LOG_INFO('Download Contract Names Complete: ' || v_MESSAGE);
   ELSE
      LOGS.LOG_WARN('Download Issue With Contract Names: ' || v_MESSAGE);
   END IF;
END DOWNLOAD_CONTRACT_NAMES;

PROCEDURE GET_LOAD_CONTRIBUTION_XML
   (
   p_BEGIN_DATE    IN DATE,
   p_END_DATE      IN DATE,
   p_MARKET        IN VARCHAR2,
   p_COMPANY_NAME  IN VARCHAR2,
   p_ZONE_NAME     IN VARCHAR2,
   p_AREA_NAME     IN VARCHAR2,
   p_SERVICE_TYPE  IN VARCHAR2,
   p_CONTAINER IN OUT CLOB,
   p_ENTRY_COUNT  OUT PLS_INTEGER
   ) AS
v_BUFFER     VARCHAR2(4000);
v_BEGIN_DATE DATE;
v_END_DATE   DATE;
v_IS_VALID   BOOLEAN := TRUE;
v_COUNT      PLS_INTEGER;
CURSOR c_SELECT IS
   SELECT
      '     <load_contribution>'                                                                   || c_CRLF ||
      '          <load_type>'       || SERVICE_TYPE                         || '</load_type>'      || c_CRLF ||
      '          <zone>'            || p_ZONE_NAME                          || '</zone>'           || c_CRLF ||
      '          <area>'            || p_AREA_NAME                          || '</area>'           || c_CRLF ||
      '          <lse>'             || PJM_SHORT_NAME                       || '</lse>'            || c_CRLF ||
      '          <mw_amount>'       || LTRIM(TO_CHAR(AMOUNT,'999990.0'))    || '</mw_amount>'      || c_CRLF ||
      '          <effective_date>'  || TO_CHAR(SCHEDULE_DATE, 'YYYY-MM-DD') || '</effective_date>' || c_CRLF ||
      '     </load_contribution>'                                                                  || c_CRLF "XML_RECORD"
  FROM
   (
    SELECT PJM_SHORT_NAME, SCHEDULE_DATE, SERVICE_TYPE, SUM(AMOUNT) AMOUNT
    FROM
     (
      SELECT PJM_SHORT_NAME, SCHEDULE_DATE, SERVICE_TYPE, AMOUNT FROM
        (SELECT A.PJM_SHORT_NAME, E.SCHEDULE_DATE SCHEDULE_DATE, 'PEAKLOAD' "SERVICE_TYPE", 0 "AMOUNT"
         FROM
          (SELECT LOCAL_DAY "SCHEDULE_DATE" FROM CDI_LOCAL_DAY$ WHERE LOCAL_DAY BETWEEN v_BEGIN_DATE AND v_END_DATE) E,
             CDI_PJM_SHORT_NAME A
            UNION ALL
            SELECT A.PJM_SHORT_NAME, E.SCHEDULE_DATE, 'NSPL' "SERVICE_TYPE", 0 "AMOUNT"
            FROM
            (SELECT LOCAL_DAY "SCHEDULE_DATE" FROM CDI_LOCAL_DAY$ WHERE LOCAL_DAY BETWEEN v_BEGIN_DATE AND v_END_DATE) E,
             CDI_PJM_SHORT_NAME A)
       UNION
       (SELECT PJM_SHORT_NAME, SCHEDULE_DATE,
             CASE WHEN SERVICE_TYPE = 'PLC' THEN 'PEAKLOAD' ELSE 'NSPL' END "SERVICE_TYPE",
             CASE WHEN PRIOR_INTERNAL_AMOUNT IS NOT NULL AND INTERNAL_AMOUNT IS NULL THEN 0 ELSE INTERNAL_AMOUNT END "AMOUNT"
          FROM
             (SELECT SERVICE_TYPE, SUPPLIER_TYPE, SUPPLIER_NAME, PJM_SHORT_NAME, SCHEDULE_DATE, INTERNAL_AMOUNT,
                LAG(INTERNAL_AMOUNT,1,NULL) OVER (PARTITION BY SERVICE_TYPE, SUPPLIER_TYPE, SUPPLIER_NAME, PJM_SHORT_NAME ORDER BY SCHEDULE_DATE) "PRIOR_INTERNAL_AMOUNT"
             FROM
                (SELECT A.SERVICE_TYPE, A.SUPPLIER_TYPE, A.SUPPLIER_NAME, A.PJM_SHORT_NAME, A.SCHEDULE_DATE, B.INTERNAL_AMOUNT
                FROM (SELECT LOCAL_DAY "SCHEDULE_DATE", TRANSACTION_ID, SERVICE_TYPE, SUPPLIER_TYPE, SUPPLIER_NAME, PJM_SHORT_NAME
                FROM (SELECT LOCAL_DAY FROM CDI_LOCAL_DAY$ WHERE LOCAL_DAY BETWEEN v_BEGIN_DATE-1 AND v_END_DATE),
                (SELECT DISTINCT TRANSACTION_ID, SERVICE_TYPE, SUPPLIER_TYPE, SUPPLIER_NAME, PJM_SHORT_NAME
                   FROM CDI_BGE_PLC_NSPL_SCHEDULE$ WHERE SCHEDULE_DATE BETWEEN v_BEGIN_DATE - 1 AND v_END_DATE AND (SERVICE_TYPE = p_SERVICE_TYPE OR CONSTANTS.ALL_STRING = p_SERVICE_TYPE))) A,
                      CDI_BGE_PLC_NSPL_SCHEDULE$ B
                   WHERE B.SERVICE_TYPE(+) = A.SERVICE_TYPE
                   AND B.TRANSACTION_ID(+) = A.TRANSACTION_ID
                   AND B.SUPPLIER_TYPE(+) = A.SUPPLIER_TYPE
                   AND B.SUPPLIER_NAME(+) = A.SUPPLIER_NAME
                   AND B.PJM_SHORT_NAME(+) = A.PJM_SHORT_NAME
                   AND B.SCHEDULE_DATE(+) = A.SCHEDULE_DATE))
       )
     )
     GROUP BY PJM_SHORT_NAME, SCHEDULE_DATE, SERVICE_TYPE
   )
   WHERE SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
   AND AMOUNT IS NOT NULL
   ORDER BY PJM_SHORT_NAME, SCHEDULE_DATE, SERVICE_TYPE;
CURSOR c_VALIDATE IS
   SELECT PJM_SHORT_NAME, SCHEDULE_DATE, SERVICE_TYPE
   FROM
      (SELECT PJM_SHORT_NAME, SCHEDULE_DATE,
         CASE WHEN SERVICE_TYPE = 'PLC' THEN 'PEAKLOAD' ELSE 'NSPL' END "SERVICE_TYPE",
         CASE WHEN PRIOR_INTERNAL_AMOUNT IS NOT NULL AND INTERNAL_AMOUNT IS NULL THEN 0 ELSE INTERNAL_AMOUNT END "AMOUNT"
      FROM
         (SELECT SERVICE_TYPE, SUPPLIER_TYPE, SUPPLIER_NAME, PJM_SHORT_NAME, SCHEDULE_DATE, INTERNAL_AMOUNT,
            LAG(INTERNAL_AMOUNT,1,NULL) OVER (PARTITION BY SERVICE_TYPE, SUPPLIER_TYPE, SUPPLIER_NAME, PJM_SHORT_NAME ORDER BY SCHEDULE_DATE) "PRIOR_INTERNAL_AMOUNT"
         FROM
            (SELECT A.SERVICE_TYPE, A.SUPPLIER_TYPE, A.SUPPLIER_NAME, A.PJM_SHORT_NAME, A.SCHEDULE_DATE, B.INTERNAL_AMOUNT
            FROM (SELECT LOCAL_DAY "SCHEDULE_DATE", TRANSACTION_ID, SERVICE_TYPE, SUPPLIER_TYPE, SUPPLIER_NAME, PJM_SHORT_NAME FROM (SELECT LOCAL_DAY FROM CDI_LOCAL_DAY$ WHERE LOCAL_DAY BETWEEN v_BEGIN_DATE - 1 AND v_END_DATE), (SELECT DISTINCT TRANSACTION_ID, SERVICE_TYPE, SUPPLIER_TYPE, SUPPLIER_NAME, PJM_SHORT_NAME FROM CDI_BGE_PLC_NSPL_SCHEDULE$ WHERE SCHEDULE_DATE BETWEEN v_BEGIN_DATE - 1 AND v_END_DATE AND SERVICE_TYPE IN (CONSTANTS.ALL_STRING, p_SERVICE_TYPE))) A, CDI_BGE_PLC_NSPL_SCHEDULE$ B
            WHERE B.SERVICE_TYPE(+) = A.SERVICE_TYPE
               AND B.TRANSACTION_ID(+) = A.TRANSACTION_ID
               AND B.SUPPLIER_TYPE(+) = A.SUPPLIER_TYPE
               AND B.SUPPLIER_NAME(+) = A.SUPPLIER_NAME
               AND B.PJM_SHORT_NAME(+) = A.PJM_SHORT_NAME
               AND B.SCHEDULE_DATE(+) = A.SCHEDULE_DATE)))
   WHERE SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
      AND AMOUNT IS NOT NULL
   GROUP BY PJM_SHORT_NAME, SCHEDULE_DATE, SERVICE_TYPE HAVING COUNT(1) > 1;
BEGIN
   LOGS.LOG_INFO('Begin Date: ' || TO_CHAR(p_BEGIN_DATE, c_DATE_TIME_FORMAT) || ', End Date: ' || TO_CHAR(p_END_DATE, c_DATE_TIME_FORMAT));
--@@Begin Implementation Override--
--@@Seed The Short Names When PJM Does Not Return Any Short Names --
--   SELECT COUNT(*) INTO v_COUNT FROM CDI_PJM_SHORT_NAME;
--   IF v_COUNT = 0 THEN
--      LOGS.LOG_WARN('No PJM Short Names Returned From Query Contract Names. Defaulting To PJM Short Names Of Content To Be Submitted.');
--      INSERT INTO CDI_PJM_SHORT_NAME(PJM_SHORT_NAME)
--      SELECT DISTINCT PJM_SHORT_NAME FROM CDI_BGE_PLC_NSPL_SCHEDULE$ WHERE SERVICE_TYPE IN (CONSTANTS.ALL_STRING, p_SERVICE_TYPE);
--      COMMIT;
--   END IF;
--@@End Implementation Override--

-- Select Internal Schedules Defined Over The Specified Date Range --
   SELECT MIN(SCHEDULE_DATE), MAX(SCHEDULE_DATE) INTO v_BEGIN_DATE, v_END_DATE
   FROM CDI_BGE_PLC_NSPL_SCHEDULE$
   WHERE TRUNC(SCHEDULE_DATE) BETWEEN p_BEGIN_DATE AND p_END_DATE
      AND INTERNAL_AMOUNT IS NOT NULL
      AND p_SERVICE_TYPE IN (CONSTANTS.ALL_STRING, SERVICE_TYPE);
   LOGS.LOG_INFO('First Date: ' || TO_CHAR(v_BEGIN_DATE, c_DATE_TIME_FORMAT) || ', Last Date: ' || TO_CHAR(v_END_DATE, c_DATE_TIME_FORMAT));  --@@Implementation Override--

   FOR v_VALIDATE IN c_VALIDATE LOOP
     LOGS.LOG_ERROR('Multiple Schedules Exist For Short Name <' || v_VALIDATE.PJM_SHORT_NAME || '> and Service Type <' || v_VALIDATE.SERVICE_TYPE || '> On Date <' || TO_CHAR(v_VALIDATE.SCHEDULE_DATE,'YYYY/MM/DD') || '>.', 'PJM_LOAD_CONTRIBUTION_SET_XML','Validate Unique Shortnames');
     v_IS_VALID := FALSE;
   END LOOP;
   ASSERT(v_IS_VALID, 'One Or More Shortnames Have Multiple Schedules For The Same Date. See Process Log For Details.');

   p_ENTRY_COUNT := 0;
   DBMS_LOB.CREATETEMPORARY(p_CONTAINER, TRUE);
   DBMS_LOB.OPEN(p_CONTAINER, DBMS_LOB.LOB_READWRITE);

   v_BUFFER := '<?xml version="1.0" encoding="UTF-8" ?>' || c_CRLF;
   IF p_MARKET = 'CE' THEN
      v_BUFFER := v_BUFFER ||
                  '<Envelope xmlns="http://schemas.xmlsoap.org/soap/envelope">' || c_CRLF ||
                  '<Body>' || c_CRLF ||
                  '<SubmitRequest xmlns="http://erpm.pjm.com/rpm/xml">' || c_CRLF ||
                  '<LoadContributionSet>' || c_CRLF;
   ELSIF p_MARKET = 'ERPM' THEN
      v_BUFFER := v_BUFFER ||
                  '<SubmitRequest xmlns="http://erpm.pjm.com/rpm/xml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">' || c_CRLF ||
                  '<LoadContributionSet CompanyName="' || p_COMPANY_NAME || '">' || c_CRLF;
   END IF;

   DBMS_LOB.WRITEAPPEND(p_CONTAINER, LENGTH(v_BUFFER), v_BUFFER);
   FOR v_SELECT IN c_SELECT LOOP
      DBMS_LOB.WRITEAPPEND(p_CONTAINER, LENGTH(v_SELECT.XML_RECORD), v_SELECT.XML_RECORD);
      p_ENTRY_COUNT := p_ENTRY_COUNT + 1;
   END LOOP;
   v_BUFFER := '</LoadContributionSet>' || c_CRLF || '</SubmitRequest>' || c_CRLF || CASE WHEN p_MARKET = 'CE' THEN  '</Body>' || c_CRLF || '</Envelope>' || c_CRLF ELSE '' END;
   DBMS_LOB.WRITEAPPEND(p_CONTAINER, LENGTH(v_BUFFER), v_BUFFER);
   DBMS_LOB.CLOSE(p_CONTAINER);
END GET_LOAD_CONTRIBUTION_XML;

PROCEDURE SUBMIT_PLC_NSPL_TO_PJM(p_BEGIN_DATE IN DATE, p_END_DATE IN DATE, p_SERVICE_TYPE IN VARCHAR2, p_SUBMIT_ONLY IN BOOLEAN) AS
v_BUFFER VARCHAR2(4000);
v_CONTAINER CLOB;
v_ENTRY_COUNT PLS_INTEGER := 0;
v_STATUS NUMBER;
v_MESSAGE VARCHAR2(1000);
BEGIN
   IF NOT p_SUBMIT_ONLY THEN
      DOWNLOAD_CONTRACT_NAMES(p_BEGIN_DATE, p_END_DATE);
   END IF;
   GET_LOAD_CONTRIBUTION_XML(p_BEGIN_DATE, p_END_DATE, 'CE', MM_PJM.c_COMPANY_NAME, MM_PJM.c_EDC_NAME, MM_PJM.c_EDC_NAME, p_SERVICE_TYPE, v_CONTAINER, v_ENTRY_COUNT);
   LOGS.LOG_INFO('XML Entry Count: ' || TO_CHAR(v_ENTRY_COUNT));
   IF v_ENTRY_COUNT > 0 THEN
      LOGS.LOG_INFO('Submit Content To PJM');
      MM_PJM_CE.POST_CONTENT_TO_PJM(v_CONTAINER, v_STATUS, v_MESSAGE);
      IF v_STATUS = MEX_SWITCHBOARD.c_STATUS_SUCCESS THEN
         LOGS.LOG_INFO('PLC/NSPL: Submit To PJM Complete. Number Of Entries Submitted: ' || TO_CHAR(v_ENTRY_COUNT) || '.');
      ELSE
         LOGS.LOG_ERROR('Submit Of Content To PJM Returned Non-Zero Status: '  || v_STATUS);
      END IF;
   ELSE
      LOGS.LOG_WARN('No Content To Submit For The Specified Time Period.');
   END IF;
END SUBMIT_PLC_NSPL_TO_PJM;

PROCEDURE EXPORT_PLC_NSPL_TO_FILE
   (
   p_BEGIN_DATE   IN DATE,
   p_END_DATE     IN DATE,
   p_SERVICE_TYPE IN VARCHAR2,
   p_TRACE_ON     IN NUMBER,
   p_EXPORT_FILE OUT CLOB,
   p_STATUS      OUT NUMBER,
   p_MESSAGE     OUT VARCHAR2
   ) AS
v_BUFFER VARCHAR2(4000);
v_ENTRY_COUNT PLS_INTEGER := 0;
v_MESSAGE VARCHAR2(64);
BEGIN
   LOGS.START_PROCESS(c_SAVE_PLC_NSPL_TO_FILE, p_BEGIN_DATE, p_END_DATE, p_EVENT_LEVEL => CASE WHEN p_TRACE_ON > 0 THEN LOGS.c_LEVEL_DEBUG ELSE NULL END);
   LOGS.LOG_INFO(c_SAVE_PLC_NSPL_TO_FILE);
   LOGS.LOG_INFO('Time Period: ' || TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE) || ' - ' || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE) || ', Service Type:' || p_SERVICE_TYPE);
   DOWNLOAD_CONTRACT_NAMES(p_BEGIN_DATE, p_END_DATE);
   GET_LOAD_CONTRIBUTION_XML(p_BEGIN_DATE, p_END_DATE, 'CE', MM_PJM.c_COMPANY_NAME, MM_PJM.c_EDC_NAME, MM_PJM.c_EDC_NAME, p_SERVICE_TYPE, p_EXPORT_FILE, v_ENTRY_COUNT);
   p_MESSAGE := c_SAVE_PLC_NSPL_TO_FILE || ' Complete. Number Of Entries Written To File: ' || TO_CHAR(v_ENTRY_COUNT) || '.';
   LOGS.LOG_INFO(p_MESSAGE);
   p_MESSAGE := p_MESSAGE || v_MESSAGE;
   p_STATUS := LOGS.GET_PROCESS_SEVERITY;
   LOGS.STOP_PROCESS(p_MESSAGE, p_STATUS);
EXCEPTION
   WHEN OTHERS THEN
      p_MESSAGE := FORMAT_EXCEPTION_MESSAGE(DBMS_UTILITY.FORMAT_ERROR_STACK);
      ERRS.ABORT_PROCESS;
END EXPORT_PLC_NSPL_TO_FILE;

PROCEDURE SUBMIT_PLC_NSPL
   (
   p_BEGIN_DATE   IN DATE,
   p_END_DATE     IN DATE,
   p_SERVICE_TYPE IN VARCHAR2,
   p_SUBMIT_ONLY  IN BOOLEAN,
   p_TRACE_ON     IN NUMBER,
   p_STATUS      OUT NUMBER,
   p_MESSAGE     OUT VARCHAR2
   ) AS
-- This Procedure Combines The Functionality Of Running The Following Data Exchanges Individually One After The Other:
--   PLC/NSPL: Submit To PJM (Submit Only Mode)
--   PLC/NSPL: Query PLC
--   PLC/NSPL: Query NSPL
BEGIN
-- Initiate Process Log --
   LOGS.START_PROCESS(c_SUBMIT_PLC_NSPL_TO_PJM, p_BEGIN_DATE, p_END_DATE, p_EVENT_LEVEL => CASE WHEN p_TRACE_ON > 0 THEN LOGS.c_LEVEL_DEBUG ELSE NULL END);
   LOGS.LOG_INFO(c_SUBMIT_PLC_NSPL_TO_PJM || ' For Time Period: ' || TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE) || ' - ' || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE) || ', Service Type:' || p_SERVICE_TYPE || ', Mode: ' || CASE WHEN p_SUBMIT_ONLY THEN 'Submit Only' ELSE 'Full Process' END);
   p_STATUS := LOGS.c_LEVEL_SUCCESS;
-- Step 1 - Submit The PLC And NSPL Schedules --
   SUBMIT_PLC_NSPL_TO_PJM(p_BEGIN_DATE, p_END_DATE, p_SERVICE_TYPE, p_SUBMIT_ONLY);
   IF NOT p_SUBMIT_ONLY THEN
-- Step 2 - Query Back The The PLC Schedule That Were Submitted In Step 1 --
      IF p_SERVICE_TYPE = CONSTANTS.ALL_STRING THEN
         MM_PJM_CE.MARKET_EXCHANGE(p_BEGIN_DATE, p_END_DATE, MM_PJM_CE.g_ET_QUERY_PLC, NULL, NULL, NULL, NULL, p_TRACE_ON, p_STATUS, p_MESSAGE);
      END IF;
   -- Step 3 - Query Back The The NSPL Schedule That Was Submitted In Step 1 --
      MM_PJM_CE.MARKET_EXCHANGE(p_BEGIN_DATE, p_END_DATE, MM_PJM_CE.g_ET_QUERY_NSPL, NULL, NULL, NULL, NULL, p_TRACE_ON, p_STATUS, p_MESSAGE);
   END IF;
   -- Reply With Successful Confirmation Message --
   p_MESSAGE := 'PLC/NSPL: Submit To And Query From PJM Complete. Check The Process Log For The Details Of Each Processing Step.';
   p_STATUS := LOGS.GET_PROCESS_SEVERITY;
   LOGS.LOG_INFO(c_SUBMIT_PLC_NSPL_TO_PJM || ' Complete.');
   LOGS.STOP_PROCESS(p_MESSAGE, p_STATUS);
EXCEPTION
   WHEN OTHERS THEN
      p_MESSAGE := FORMAT_EXCEPTION_MESSAGE(DBMS_UTILITY.FORMAT_ERROR_STACK);
      ROLLBACK;
      ERRS.ABORT_PROCESS;
      p_STATUS := LOGS.c_LEVEL_FATAL;
END SUBMIT_PLC_NSPL;

PROCEDURE QUERY_PLC_NSPL_FROM_PJM
   (
   p_BEGIN_DATE   IN DATE,
   p_END_DATE     IN DATE,
   p_SERVICE_TYPE IN VARCHAR2,
   p_TRACE_ON     IN NUMBER,
   p_STATUS      OUT NUMBER,
   p_MESSAGE     OUT VARCHAR2
   ) AS
v_BUFFER VARCHAR2(4000);
v_CONTAINER CLOB;
v_ENTRY_COUNT PLS_INTEGER := 0;
BEGIN
-- Initiate Process Log --
   LOGS.START_PROCESS(c_QUERY_PLC_NSPL_FROM_PJM, p_BEGIN_DATE, p_END_DATE, p_EVENT_LEVEL => CASE WHEN p_TRACE_ON > 0 THEN LOGS.c_LEVEL_DEBUG ELSE NULL END);
   LOGS.LOG_INFO(c_QUERY_PLC_NSPL_FROM_PJM || ' For Time Period: ' || TEXT_UTIL.TO_CHAR_DATE(p_BEGIN_DATE) || ' - ' || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE));
   p_STATUS := LOGS.c_LEVEL_SUCCESS;
-- Query The The PLC Schedule From PJM --
   IF p_SERVICE_TYPE = CONSTANTS.ALL_STRING THEN
      MM_PJM_CE.MARKET_EXCHANGE(p_BEGIN_DATE, p_END_DATE, MM_PJM_CE.g_ET_QUERY_PLC, NULL, NULL, NULL, NULL, p_TRACE_ON, p_STATUS, p_MESSAGE);
      IF p_STATUS <> GA.SUCCESS THEN
         RETURN;
      END IF;
   END IF;
-- Query The The NSPL Schedule From PJM --
   MM_PJM_CE.MARKET_EXCHANGE(p_BEGIN_DATE, p_END_DATE, MM_PJM_CE.g_ET_QUERY_NSPL, NULL, NULL, NULL, NULL, p_TRACE_ON, p_STATUS, p_MESSAGE);
   IF p_STATUS <> GA.SUCCESS THEN
      RETURN;
   END IF;
-- Reply With Successful Confirmation Message --
   p_MESSAGE := c_QUERY_PLC_NSPL_FROM_PJM || ' Complete. Check The Process Log For The Details Of Each Processing Step.';
   LOGS.LOG_INFO(p_MESSAGE);
   p_STATUS := LOGS.GET_PROCESS_SEVERITY;
   LOGS.STOP_PROCESS(p_MESSAGE, p_STATUS);
EXCEPTION
   WHEN OTHERS THEN
      p_MESSAGE := FORMAT_EXCEPTION_MESSAGE(DBMS_UTILITY.FORMAT_ERROR_STACK);
      ROLLBACK;
      ERRS.ABORT_PROCESS;
      p_STATUS := LOGS.c_LEVEL_FATAL;
END QUERY_PLC_NSPL_FROM_PJM;

PROCEDURE IMPORT_PLC_NSPL_SCHEDULE_FILE(p_IMPORT_FILE IN CLOB, p_IMPORT_FILE_PATH IN VARCHAR2, p_STATUS OUT NUMBER, p_MESSAGE OUT VARCHAR2) AS
-- PLC CSV File Format --
-- Day,LseName,ZoneName,AreaName,UploadedMW,ScalingFactor,ObligationPeakLoadMW,ElectionType,ForecastPoolRequirement,FinalZonalScalingFactor,DailyUcapObligation
-- 09/25/2020,PEPAG3,BGE,BGE,0,0.0,0.0,RPM,1.0898,0.0,0.0
-- NSPL CSV File Format --
-- Day,LseName,ZoneName,AreaName,UploadedMW,ScalingFactor,NSPLMW
-- 09/25/2020,WGESE,BGE,BGE,0,0.0,0.0
v_CONTAINER      PARSE_UTIL.BIG_STRING_TABLE_MP;
v_TOKENS         PARSE_UTIL.STRING_TABLE;
v_SCHEDULE_DATE  DATE;
v_IMPORT_TYPE    VARCHAR2(32);
v_LSE_NAME       VARCHAR2(32);
v_AMOUNT         NUMBER;
v_TRANSACTION_ID PLS_INTEGER;
v_COUNT          PLS_INTEGER := 0;
BEGIN
-- Parse The File Into Records --
   PARSE_UTIL.PARSE_CLOB_INTO_LINES(p_IMPORT_FILE, v_CONTAINER);
   LOGS.LOG_INFO('Number Of Input Records: ' || TO_CHAR(v_CONTAINER.COUNT));
   IF v_CONTAINER.COUNT > 0 THEN
-- Process Each Line --
      FOR v_INDEX IN v_CONTAINER.FIRST..v_CONTAINER.LAST LOOP
         PARSE_UTIL.PARSE_DELIMITED_STRING(v_CONTAINER(v_INDEX), c_COMMA, v_TOKENS);
         BEGIN
            ASSERT(v_TOKENS.COUNT >= 7, 'Invalid Record Field Count');
            IF v_INDEX = 1 THEN
               v_IMPORT_TYPE := TRIM(v_TOKENS(7));
               ASSERT(v_IMPORT_TYPE IN (c_PLC_TAG, c_NSPL_TAG), 'Invalid File Type Indicator');
               LOGS.LOG_INFO('Import Type: ' || v_IMPORT_TYPE);
            ELSE
               ASSERT(v_TOKENS.COUNT = CASE WHEN v_IMPORT_TYPE = c_PLC_TAG THEN 11 ELSE 7 END, 'Invalid Record Format Field Count');
               v_SCHEDULE_DATE := ADD_SECONDS_TO_DATE(TO_DATE(TRIM(v_TOKENS(1)), c_DATE_FORMAT),1);
               v_LSE_NAME := TRIM(v_TOKENS(2));
               v_AMOUNT := TO_NUMBER(TRIM(v_TOKENS(7)));
               SELECT MAX(TRANSACTION_ID) INTO v_TRANSACTION_ID
               FROM INTERCHANGE_TRANSACTION
               WHERE TRANSACTION_TYPE = c_ANCILLARY
                  AND TRANSACTION_ALIAS = v_LSE_NAME
                  AND TRANSACTION_CODE = CASE WHEN v_IMPORT_TYPE = c_PLC_TAG THEN 'C' ELSE 'N' END;
               IF v_TRANSACTION_ID IS NULL THEN
                  LOGS.LOG_ERROR('Ancillary Transaction Not Found For Record: ' || v_CONTAINER(v_INDEX) || '. Record Skipped.');
               ELSE
                  MERGE INTO IT_SCHEDULE T
                  USING (SELECT v_TRANSACTION_ID "TRANSACTION_ID", CONSTANTS.SCHEDULE_TYPE_FINAL "SCHEDULE_TYPE", CONSTANTS.EXTERNAL_STATE "SCHEDULE_STATE", v_SCHEDULE_DATE "SCHEDULE_DATE", CONSTANTS.LOW_DATE "AS_OF_DATE", v_AMOUNT "AMOUNT" FROM DUAL) S
                  ON (T.TRANSACTION_ID = S.TRANSACTION_ID AND T.SCHEDULE_TYPE = S.SCHEDULE_TYPE AND T.SCHEDULE_STATE = S.SCHEDULE_STATE AND T.SCHEDULE_DATE = S.SCHEDULE_DATE AND T.AS_OF_DATE = S.AS_OF_DATE)
                  WHEN MATCHED THEN
                     UPDATE SET T.AMOUNT = S.AMOUNT
                  WHEN NOT MATCHED THEN
                     INSERT(TRANSACTION_ID, SCHEDULE_TYPE, SCHEDULE_STATE, SCHEDULE_DATE, AS_OF_DATE, AMOUNT)
                     VALUES(S.TRANSACTION_ID, S.SCHEDULE_TYPE, S.SCHEDULE_STATE, S.SCHEDULE_DATE, S.AS_OF_DATE, S.AMOUNT);
                  v_COUNT := v_COUNT + 1;
               END IF;
            END IF;
         EXCEPTION
            WHEN OTHERS THEN
               LOGS.LOG_ERROR('Invalid Format For Record: ' || v_CONTAINER(v_INDEX) || '. Record Skipped.');
         END;
      END LOOP;
   ELSE
      LOGS.LOG_ERROR('No Content Found In Input File.');
   END IF;
   p_STATUS := LOGS.GET_PROCESS_SEVERITY;
   p_MESSAGE := 'Valid Records In File: ' || TO_CHAR(v_COUNT) || ', Invalid Records In File: ' || TO_CHAR(LOGS.GET_ERROR_COUNT);
   LOGS.LOG_INFO(p_MESSAGE);
END IMPORT_PLC_NSPL_SCHEDULE_FILE;

PROCEDURE IMPORT_LMP_MARKET_PRICE_FILE(p_IMPORT_FILE IN CLOB, p_IMPORT_FILE_PATH IN VARCHAR2, p_MONTHLY IN BOOLEAN, p_STATUS OUT NUMBER, p_MESSAGE OUT VARCHAR2) AS
-- DA Daily CSV File Format --
-- datetime_beginning_utc,datetime_beginning_ept,pnode_id,pnode_name,voltage,equipment,type,zone,system_energy_price_da,total_lmp_da,congestion_price_da,marginal_loss_price_da,row_is_current,version_nbr
-- 9/25/2020 4:00,9/25/2020 12:00,51292,BGE,,,ZONE,,14.28,15.207840,0.899834,0.028006,True,1
-- RT Daily CSV File Format --
-- datetime_beginning_utc,datetime_beginning_ept,pnode_id,pnode_name,voltage,equipment,type,zone,system_energy_price_rt,total_lmp_rt,congestion_price_rt,marginal_loss_price_rt,row_is_current,version_nbr
-- 9/24/2020 4:00,9/24/2020 12:00,51292,BGE,,,ZONE,,10.210000,10.231440,0.055689,-0.035082,True,1
-- DA/RT Combined Monthly CSV File Format --
-- datetime_beginning_utc,datetime_beginning_ept,pnode_id,pnode_name,voltage,equipment,type,zone,system_energy_price_rt,total_lmp_rt,congestion_price_rt,marginal_loss_price_rt,system_energy_price_da,total_lmp_da,congestion_price_da,marginal_loss_price_da
-- 9/1/2020 3:00:00 AM,8/31/2020 11:00:00 PM,51292,BGE,,,ZONE,,15.632500,20.337305,4.675566,0.029238,15.260000,17.985955,2.482678,0.243277
v_CONTAINER   PARSE_UTIL.BIG_STRING_TABLE_MP;
v_TOKENS      PARSE_UTIL.STRING_TABLE;
v_PRICE_DATE  DATE;
v_BEGIN_DATE  DATE := CONSTANTS.HIGH_DATE;
v_END_DATE    DATE := CONSTANTS.LOW_DATE;
v_TOKEN_COUNT PLS_INTEGER := CASE WHEN p_MONTHLY THEN 16 ELSE 14 END;
v_TOKEN_LAST  PLS_INTEGER := CASE WHEN p_MONTHLY THEN 16 ELSE 12 END;
v_DATE_FORMAT VARCHAR2(32) := CASE WHEN p_MONTHLY THEN c_LMP_MONTH_DATE_TIME_FORMAT ELSE c_LMP_DATE_TIME_FORMAT END;
v_PRICE_CODE  CHAR(1) := CASE WHEN p_MONTHLY THEN CONSTANTS.CODE_ACTUAL ELSE CONSTANTS.CODE_PRELIM END;
v_LMP_SYS_MARKET_PRICE_ID  NUMBER(9);
v_LMP_RT_MARKET_PRICE_ID   NUMBER(9);
v_LMP_CONG_MARKET_PRICE_ID NUMBER(9);
v_LMP_LOSS_MARKET_PRICE_ID NUMBER(9);
v_MARKET_PRICE_ID          NUMBER(9);
v_MARKET_PRICE_VALUE       t_MARKET_PRICE_VALUE := t_MARKET_PRICE_VALUE();
   FUNCTION GET_MARKET_PRICE_ID(p_MARKET_PRICE_NAME IN VARCHAR2) RETURN NUMBER AS
   v_MARKET_PRICE_ID NUMBER(9);
   BEGIN
      SELECT NVL(MAX(MARKET_PRICE_ID), CONSTANTS.NOT_ASSIGNED) INTO v_MARKET_PRICE_ID FROM MARKET_PRICE WHERE MARKET_PRICE_NAME = p_MARKET_PRICE_NAME;
      ASSERT(v_MARKET_PRICE_ID <> CONSTANTS.NOT_ASSIGNED, 'MARKET PRICE "' || p_MARKET_PRICE_NAME || '" Is Not Defined.');
      RETURN v_MARKET_PRICE_ID;
   END GET_MARKET_PRICE_ID;
   PROCEDURE SET_MARKET_PRICE_VALUE(p_MARKET_PRICE_ID IN NUMBER, p_PRICE_CODE IN CHAR, p_PRICE_DATE IN DATE, p_PRICE IN NUMBER, p_MARKET_PRICE_VALUE IN OUT t_MARKET_PRICE_VALUE) AS
   v_INDEX PLS_INTEGER;
   BEGIN
      p_MARKET_PRICE_VALUE.EXTEND;
      v_INDEX := p_MARKET_PRICE_VALUE.COUNT;
      p_MARKET_PRICE_VALUE(v_INDEX).MARKET_PRICE_ID := p_MARKET_PRICE_ID;
      p_MARKET_PRICE_VALUE(v_INDEX).PRICE_CODE := p_PRICE_CODE;
      p_MARKET_PRICE_VALUE(v_INDEX).PRICE_DATE := p_PRICE_DATE;
      p_MARKET_PRICE_VALUE(v_INDEX).AS_OF_DATE := CONSTANTS.LOW_DATE;
      p_MARKET_PRICE_VALUE(v_INDEX).PRICE := p_PRICE;
      p_MARKET_PRICE_VALUE(v_INDEX).PRICE_DATE := p_PRICE_DATE;
   END SET_MARKET_PRICE_VALUE;
BEGIN
   v_LMP_SYS_MARKET_PRICE_ID  := GET_MARKET_PRICE_ID(c_LMP_SYS_MARKET_PRICE_NAME);
   v_LMP_RT_MARKET_PRICE_ID   := GET_MARKET_PRICE_ID(c_LMP_RT_MARKET_PRICE_NAME);
   v_LMP_CONG_MARKET_PRICE_ID := GET_MARKET_PRICE_ID(c_LMP_CONG_MARKET_PRICE_NAME);
   v_LMP_LOSS_MARKET_PRICE_ID := GET_MARKET_PRICE_ID(c_LMP_LOSS_MARKET_PRICE_NAME);
   PARSE_UTIL.PARSE_CLOB_INTO_LINES(p_IMPORT_FILE, v_CONTAINER);
   LOGS.LOG_INFO('Number Of Input Records: ' || TO_CHAR(v_CONTAINER.COUNT));
   IF TO_CHAR(v_CONTAINER.COUNT) > 0 THEN
-- Process Each Line --
      FOR v_INDEX IN v_CONTAINER.FIRST..v_CONTAINER.LAST LOOP
         PARSE_UTIL.PARSE_DELIMITED_STRING(v_CONTAINER(v_INDEX), c_COMMA, v_TOKENS);
         BEGIN
            ASSERT(v_TOKENS.COUNT = v_TOKEN_COUNT, 'Invalid Record Field Count, Expected: ' || TO_CHAR(v_TOKEN_COUNT)|| ', Observed: ' || TO_CHAR(v_TOKENS.COUNT) || '.');
            IF v_INDEX > 1 THEN
               v_PRICE_DATE := ADD_HOURS_TO_DATE(TO_DATE(v_TOKENS(1), v_DATE_FORMAT),-5);
               v_BEGIN_DATE := LEAST(v_BEGIN_DATE, v_PRICE_DATE);
               v_END_DATE := GREATEST(v_END_DATE, v_PRICE_DATE);
               FOR v_N IN 9..12 LOOP
                  v_MARKET_PRICE_ID := CASE v_N WHEN 9 THEN v_LMP_SYS_MARKET_PRICE_ID WHEN 10 THEN v_LMP_RT_MARKET_PRICE_ID WHEN 11 THEN v_LMP_CONG_MARKET_PRICE_ID WHEN 12 THEN v_LMP_LOSS_MARKET_PRICE_ID ELSE 0 END;
                  SET_MARKET_PRICE_VALUE(v_MARKET_PRICE_ID, v_PRICE_CODE, v_PRICE_DATE, v_TOKENS(v_N), v_MARKET_PRICE_VALUE);
               END LOOP;
            END IF;
         EXCEPTION
            WHEN OTHERS THEN
               ERRS.LOG_AND_CONTINUE('Invalid Record Format: ' || v_CONTAINER(v_INDEX));
         END;
      END LOOP;
      LOGS.LOG_INFO('Number Of Records Staged: ' || TO_CHAR(v_MARKET_PRICE_VALUE.COUNT) || ', Begin Date:' || TO_CHAR(v_BEGIN_DATE, c_DATE_TIME_FORMAT) || ', End Date:' || TO_CHAR(v_END_DATE, c_DATE_TIME_FORMAT));
      DELETE MARKET_PRICE_VALUE
      WHERE MARKET_PRICE_ID IN (v_LMP_SYS_MARKET_PRICE_ID, v_LMP_RT_MARKET_PRICE_ID, v_LMP_CONG_MARKET_PRICE_ID, v_LMP_LOSS_MARKET_PRICE_ID)
         AND PRICE_CODE = v_PRICE_CODE
         AND PRICE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE;
      LOGS.LOG_INFO('Number Of Records Deleted: ' || TO_CHAR(SQL%ROWCOUNT));
      FORALL v_INDEX IN v_MARKET_PRICE_VALUE.FIRST..v_MARKET_PRICE_VALUE.LAST
         INSERT INTO MARKET_PRICE_VALUE VALUES v_MARKET_PRICE_VALUE(v_INDEX);
      p_MESSAGE := 'Number Of Records Imported: ' || TO_CHAR(SQL%ROWCOUNT);
      LOGS.SET_PROCESS_TARGET_PARAMETER('BEGIN_DATE', TO_CHAR(v_BEGIN_DATE, 'YYYY-MM-DD'));
      LOGS.SET_PROCESS_TARGET_PARAMETER('END_DATE',  TO_CHAR(v_END_DATE, 'YYYY-MM-DD'));
      LOGS.LOG_INFO(p_MESSAGE);
   ELSE
      p_MESSAGE := 'No Content Found In Input File.';
      LOGS.LOG_ERROR(p_MESSAGE);
   END IF;
END IMPORT_LMP_MARKET_PRICE_FILE;

PROCEDURE IMPORT_LOAD_SUBMISSION_FILE(p_IMPORT_FILE IN CLOB, p_IMPORT_FILE_PATH IN VARCHAR2, p_CUT_BEGIN_DATE OUT DATE, p_CUT_END_DATE OUT DATE, p_STATUS OUT NUMBER, p_MESSAGE OUT VARCHAR2) AS
--BC Load Submission,0,,,,,,,,,,,,,,,,,,,,,,,,
--,,,,,,,,,,,,,,,,,,,,,,,,,
--,,,,,,,,,,,,,,,,,,,,,,,,,
--Date,9/16/2020,Ending Hours,,,,,,,,,,,,,,,,,,,,,,,
--,Total,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24
--ACTUAL NET METER INTERCHANGE,59233.95,2071.3,1961.13,1907.54,1883.51,1923.24,2056.6,2261.98,2409.69,2513.36,2555.4,2634.02,2673.18,2553.79,2582.17,2617.14,2644.05,2768.31,2837.95,2843.24,2905.07,2853.1,2814.25,2587.66,2376.27
--TOTAL INTERNAL GENERATION,9720.171,354.559,352.967,352.895,354.663,355.13,355.431,353.46,353.874,354.765,345.316,307.899,332.139,495.957,496.024,506.794,529.664,490.252,489.655,492.826,494.973,501.965,358.587,350.521,339.855
--EHV LOSSES (PJM-EAST),366.287,12.623,14.488,11.549,11.895,12.831,15.424,14.626,15.965,11.124,18.307,16.886,13.069,17.501,14.663,16.913,17.927,14.624,19.071,17.859,14.425,15.967,14.686,21.621,12.243
--LOAD WITH LOSSES,69320.408,2438.482,2328.585,2271.984,2250.068,2291.201,2427.455,2630.066,2779.529,2879.249,2919.023,2958.805,3018.388,3067.248,3092.857,3140.847,3191.641,3273.186,3346.676,3353.925,3414.468,3371.032,3187.523,2959.802,2728.368
--DERATED LOSS ADJUSTMENT,1321.187,45.523,48.288,40.949,41.595,43.831,50.524,52.826,50.365,48.124,58.007,58.386,55.969,61.101,56.363,60.213,63.127,59.924,64.571,62.659,61.225,61.967,59.786,63.621,52.243
--LOAD WITHOUT LOSSES,67999.221,2392.959,2280.297,2231.035,2208.473,2247.37,2376.931,2577.24,2729.164,2831.125,2861.016,2900.419,2962.419,3006.147,3036.494,3080.634,3128.514,3213.262,3282.105,3291.266,3353.243,3309.065,3127.737,2896.181,2676.125
--DERATION FACTOR,0.45801648,0.018668582,0.020737057,0.018023454,0.018486108,0.019130142,0.020813568,0.020085428,0.018119976,0.016714081,0.01987206,0.019732967,0.018542679,0.019920463,0.018223604,0.019170943,0.019778854,0.018307545,0.01929407,0.01868229,0.017931051,0.018382205,0.018756257,0.021495019,0.019148077
--
-- DST Spring Transition Day Ending Hours: 1,2,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,
-- DST Fall Transition Day Ending Hours: 1,2,2*,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24
--
v_CONTAINER           PARSE_UTIL.BIG_STRING_TABLE_MP;
v_TOKENS              PARSE_UTIL.STRING_TABLE;
v_LOAD_SUBMISSION_DAY DATE;
v_SCHEDULE_DATE       DATE;
v_BEGIN_DATE          DATE := CONSTANTS.HIGH_DATE;
v_END_DATE            DATE := CONSTANTS.LOW_DATE;
v_TRANSACTION_ID      PLS_INTEGER;
v_HOURS               NUMBER(2);
v_HOUR                NUMBER(2);
v_RECORD_TYPE         VARCHAR2(64);
v_TRANSACTION_NAME    VARCHAR2(128);
v_IT_SCHEDULE         t_IT_SCHEDULE := t_IT_SCHEDULE();
v_IDENT_MAP           t_IDENT_MAP;
   PROCEDURE SET_SCHEDULE(p_TRANSACTION_ID IN PLS_INTEGER, p_LOCAL_DAY IN DATE, p_LOCAL_HOUR IN NUMBER, p_AMOUNT IN NUMBER, p_SCHEDULE IN OUT t_IT_SCHEDULE) AS
   v_INDEX PLS_INTEGER;
   v_SCHEDULE_DATE DATE;
   v_LOCAL_DAY DATE := CASE WHEN IS_IN_DST_TIME_PERIOD(p_LOCAL_DAY) THEN p_LOCAL_DAY - 1/24 ELSE p_LOCAL_DAY END;
   BEGIN
      v_SCHEDULE_DATE := ADD_HOURS_TO_DATE(v_LOCAL_DAY, p_LOCAL_HOUR);
      LOGS.LOG_DEBUG('Local Day: ' || TO_CHAR(p_LOCAL_DAY, c_DATE_FORMAT) || ', Local Hour: ' || TO_CHAR(p_LOCAL_HOUR) || ', Schedule Date: ' || TO_CHAR(v_SCHEDULE_DATE, c_DATE_TIME_FORMAT));
      p_SCHEDULE.EXTEND;
      v_INDEX := p_SCHEDULE.COUNT;
      p_SCHEDULE(v_INDEX).TRANSACTION_ID := p_TRANSACTION_ID;
      p_SCHEDULE(v_INDEX).SCHEDULE_TYPE  := CONSTANTS.SCHEDULE_TYPE_FINAL;
      p_SCHEDULE(v_INDEX).SCHEDULE_STATE := CONSTANTS.INTERNAL_STATE;
      p_SCHEDULE(v_INDEX).SCHEDULE_DATE  := v_SCHEDULE_DATE;
      p_SCHEDULE(v_INDEX).AS_OF_DATE     := CONSTANTS.LOW_DATE;
      p_SCHEDULE(v_INDEX).AMOUNT         := p_AMOUNT;
   END SET_SCHEDULE;
BEGIN
   LOGS.LOG_INFO('Input File Path: ' || p_IMPORT_FILE_PATH);
   PARSE_UTIL.PARSE_CLOB_INTO_LINES(p_IMPORT_FILE, v_CONTAINER);
   LOGS.LOG_INFO('Number Of Input Records: ' || TO_CHAR(v_CONTAINER.COUNT));
   IF v_CONTAINER.COUNT > 0 THEN
-- Process Each Line --
      FOR v_INDEX IN v_CONTAINER.FIRST..v_CONTAINER.LAST LOOP
         LOGS.LOG_DEBUG('Record: ' || v_CONTAINER(v_INDEX));
         PARSE_UTIL.PARSE_DELIMITED_STRING(v_CONTAINER(v_INDEX), c_COMMA, v_TOKENS);
         v_RECORD_TYPE := v_TOKENS(1);
         IF v_RECORD_TYPE = 'Date' THEN
            v_LOAD_SUBMISSION_DAY := TO_DATE(v_TOKENS(2), c_DATE_FORMAT);
            v_BEGIN_DATE := LEAST(v_BEGIN_DATE, v_LOAD_SUBMISSION_DAY);
            v_END_DATE := GREATEST(v_END_DATE, v_LOAD_SUBMISSION_DAY);
-- Determine The Number Of Observed Hours Based On DST Transition Days --
            v_HOURS := CASE v_LOAD_SUBMISSION_DAY WHEN TRUNC(DST_SPRING_AHEAD_DATE(v_LOAD_SUBMISSION_DAY)) THEN 23 WHEN TRUNC(DST_FALL_BACK_DATE(v_LOAD_SUBMISSION_DAY)) THEN 25 ELSE 24 END;
            LOGS.LOG_DEBUG('Load Submission Day: ' || TO_CHAR(v_LOAD_SUBMISSION_DAY, c_DATE_FORMAT) || ', Hours: ' || TO_CHAR(v_HOURS));
         END IF;
         IF v_RECORD_TYPE IN (c_500KV_LOSSES, c_LOAD_WITH_LOSSES, c_DERATION_FACTOR) THEN
            v_TRANSACTION_NAME := CASE v_RECORD_TYPE WHEN c_500KV_LOSSES THEN c_500KV_LOSSES_TXN_NAME WHEN c_LOAD_WITH_LOSSES THEN c_LOAD_WITH_LOSSES_TXN_NAME WHEN c_DERATION_FACTOR THEN c_DERATION_FACTOR_TXN_NAME ELSE CONSTANTS.UNDEFINED_ATTRIBUTE END;
            SELECT NVL(MAX(TRANSACTION_ID), CONSTANTS.NOT_ASSIGNED) INTO v_TRANSACTION_ID FROM INTERCHANGE_TRANSACTION WHERE TRANSACTION_NAME = v_TRANSACTION_NAME;
            ASSERT(v_TRANSACTION_ID <> CONSTANTS.NOT_ASSIGNED, 'Exchange Type Transaction: ' || v_TRANSACTION_NAME || ', Record Type: ' || v_RECORD_TYPE || ', Is Not Defined.');
            v_IDENT_MAP(v_TRANSACTION_NAME) := v_TRANSACTION_ID;
            FOR v_HOUR IN 1..v_HOURS LOOP
               SET_SCHEDULE(v_TRANSACTION_ID, v_LOAD_SUBMISSION_DAY, v_HOUR, v_TOKENS(v_HOUR + 2), v_IT_SCHEDULE);
            END LOOP;
         END IF;
      END LOOP;
      v_TRANSACTION_NAME := v_IDENT_MAP.FIRST;
      WHILE v_TRANSACTION_NAME IS NOT NULL LOOP
         DELETE IT_SCHEDULE
         WHERE TRANSACTION_ID = v_IDENT_MAP(v_TRANSACTION_NAME)
            AND SCHEDULE_DATE BETWEEN TO_CUT(ADD_SECONDS_TO_DATE(v_BEGIN_DATE, 1), GA.LOCAL_TIME_ZONE) AND TO_CUT(v_END_DATE + 1, GA.LOCAL_TIME_ZONE);
         LOGS.LOG_INFO('Target Transaction: ' || v_TRANSACTION_NAME || ', Number Of Records Deleted: ' || TO_CHAR(SQL%ROWCOUNT));
         v_TRANSACTION_NAME := v_IDENT_MAP.NEXT(v_TRANSACTION_NAME);
      END LOOP;
      FORALL v_INDEX IN v_IT_SCHEDULE.FIRST..v_IT_SCHEDULE.LAST
         INSERT INTO IT_SCHEDULE VALUES v_IT_SCHEDULE(v_INDEX);
      FOR v_INDEX IN v_IT_SCHEDULE.FIRST..v_IT_SCHEDULE.LAST LOOP
         v_IT_SCHEDULE(v_INDEX).SCHEDULE_STATE := CONSTANTS.EXTERNAL_STATE;
      END LOOP;
      FORALL v_INDEX IN v_IT_SCHEDULE.FIRST..v_IT_SCHEDULE.LAST
         INSERT INTO IT_SCHEDULE VALUES v_IT_SCHEDULE(v_INDEX);
      p_MESSAGE := 'Number Of Records Imported: ' || TO_CHAR(SQL%ROWCOUNT);
      p_CUT_BEGIN_DATE := v_BEGIN_DATE;
      p_CUT_END_DATE := v_END_DATE;
      LOGS.SET_PROCESS_TARGET_PARAMETER('BEGIN_DATE', TO_CHAR(p_CUT_BEGIN_DATE, 'YYYY-MM-DD'));
      LOGS.SET_PROCESS_TARGET_PARAMETER('END_DATE', TO_CHAR(p_CUT_END_DATE, 'YYYY-MM-DD'));
      LOGS.LOG_INFO(p_MESSAGE);
      p_STATUS := GA.SUCCESS;
   ELSE
      p_MESSAGE := 'No Content Found In Input File.';
      p_STATUS := GA.NO_DATA_FOUND;
      LOGS.LOG_ERROR(p_MESSAGE);
   END IF;
END IMPORT_LOAD_SUBMISSION_FILE;

PROCEDURE POST_SYSTEM_LOAD_WITH_LOSSES(p_BEGIN_DATE IN DATE, p_END_DATE IN DATE) AS
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_AREA_ID PLS_INTEGER;
BEGIN
   ID.ID_FOR_AREA('BGE System', FALSE, v_AREA_ID);
   ASSERT(v_AREA_ID <> GA.NO_DATA_FOUND, 'Area Load "BGE System" Is Not Defined.');
   UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, GA.LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
   DELETE AREA_LOAD WHERE AREA_ID = v_AREA_ID AND LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE;
   INSERT INTO AREA_LOAD(CASE_ID, AREA_ID, LOAD_CODE, LOAD_DATE, AS_OF_DATE, LOAD_VAL)
   SELECT GA.BASE_CASE_ID, v_AREA_ID, CONSTANTS.CODE_ACTUAL, SCHEDULE_DATE, CONSTANTS.LOW_DATE, AMOUNT
   FROM INTERCHANGE_TRANSACTION A
      JOIN IT_SCHEDULE B ON B.TRANSACTION_ID = A.TRANSACTION_ID AND B.SCHEDULE_TYPE = CONSTANTS.SCHEDULE_TYPE_FINAL AND SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE AND SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
   WHERE A.TRANSACTION_NAME = c_LOAD_WITH_LOSSES_TXN_NAME;
   LOGS.LOG_INFO('Number Of System Load Area Records Posted: ' || TO_CHAR(SQL%ROWCOUNT));
END POST_SYSTEM_LOAD_WITH_LOSSES;

PROCEDURE IMPORT_EXCHANGE_TYPE_LIST(p_LABEL OUT VARCHAR2, p_CURSOR OUT GA.REFCURSOR) AS
BEGIN
   p_LABEL := 'Exchange Type';
   OPEN p_CURSOR FOR
      SELECT 'InSchedule'           "OPTION_NAME", 1 "OPTION_ID" FROM DUAL UNION
      SELECT 'LMP Realtime'         "OPTION_NAME", 2 "OPTION_ID" FROM DUAL UNION
      SELECT 'LMP Monthly Realtime' "OPTION_NAME", 3 "OPTION_ID" FROM DUAL UNION
      SELECT 'PLC/NSPL'             "OPTION_NAME", 4 "OPTION_ID" FROM DUAL UNION
      SELECT 'Load Submission'      "OPTION_NAME", 5 "OPTION_ID" FROM DUAL
      ORDER BY OPTION_ID;
END IMPORT_EXCHANGE_TYPE_LIST;

PROCEDURE IMPORT_EXCHANGE_FILE
   (
   p_BEGIN_DATE       IN DATE,
   p_END_DATE         IN DATE,
   p_ENTITY_LIST      IN VARCHAR2,  --Exchange Type Option Id--
   p_IMPORT_FILE      IN CLOB,
   p_IMPORT_FILE_PATH IN VARCHAR2,
   p_LOG_TYPE         IN NUMBER,
   p_TRACE_ON         IN NUMBER,
   p_STATUS          OUT NUMBER,
   p_MESSAGE         OUT VARCHAR2
   ) AS
v_OPTION  PLS_INTEGER := TO_NUMBER(SUBSTR(TRIM(p_ENTITY_LIST),1));
v_MONTHLY BOOLEAN := v_OPTION = 3;
v_CUT_BEGIN_DATE DATE;
v_CUT_END_DATE DATE;
BEGIN
-- Start The Process Log --
   LOGS.START_PROCESS(c_IMPORT_EXCHANGE_FILE);
   LOGS.LOG_INFO('Exchange Type Option: ' || CASE v_OPTION WHEN 1 THEN 'InSchedule' WHEN 2 THEN 'LMP Realtime' WHEN 3 THEN 'LMP Monthly Realtime' WHEN 4 THEN 'PLC/NSPL' WHEN 5 THEN 'Load Submission' ELSE '<unknown>' END);
   LOGS.LOG_INFO('Input File Path: ' || p_IMPORT_FILE_PATH);
-- InSchedule Content --
   IF v_OPTION = 1 THEN
      NULL;
-- Load LMP File Content --
   ELSIF v_OPTION IN (2,3) THEN
      IMPORT_LMP_MARKET_PRICE_FILE(p_IMPORT_FILE, p_IMPORT_FILE_PATH, v_MONTHLY, p_STATUS, p_MESSAGE);
-- Load PLC/NSPL Content --
   ELSIF v_OPTION = 4 THEN
      IMPORT_PLC_NSPL_SCHEDULE_FILE(p_IMPORT_FILE, p_IMPORT_FILE_PATH, p_STATUS, p_MESSAGE);
-- Load Submission Content --
   ELSIF v_OPTION = 5 THEN
      IMPORT_LOAD_SUBMISSION_FILE(p_IMPORT_FILE, p_IMPORT_FILE_PATH, v_CUT_BEGIN_DATE, v_CUT_END_DATE, p_STATUS, p_MESSAGE);
      IF p_STATUS = GA.SUCCESS THEN
         POST_SYSTEM_LOAD_WITH_LOSSES(v_CUT_BEGIN_DATE, v_CUT_END_DATE);
      ELSE
         LOGS.LOG_WARN('System Load With Losses Were Not Posted. The Import Of The Load Submission Exchange File Returned A Non-Zero Status: ' || TO_CHAR(p_STATUS));
      END IF;
   ELSE
      p_MESSAGE := 'Undefined Exchange Type Option.';
   END IF;
-- Stop The Process Log --
   LOGS.LOG_INFO(c_IMPORT_EXCHANGE_FILE || ' Complete. Check Process Log For Details.');
   LOGS.STOP_PROCESS(p_MESSAGE, p_STATUS);
   COMMIT;
EXCEPTION
   WHEN OTHERS THEN
      p_MESSAGE := SQLERRM;
      p_STATUS := SQLCODE;
      ROLLBACK;
      ERRS.ABORT_PROCESS;
END IMPORT_EXCHANGE_FILE;

PROCEDURE QUERY_EXCHANGE_TYPE_LIST(p_LABEL OUT VARCHAR2, p_CURSOR OUT GA.REFCURSOR) AS
BEGIN
   p_LABEL := 'Exchange Type';
   OPEN p_CURSOR FOR
      SELECT 'InSchedule-' || SETTLEMENT_TYPE_NAME "OPTION_NAME", STATEMENT_TYPE_ID "OPTION_ID", TO_CHAR(SETTLEMENT_TYPE_ORDER) "SORT_ORDER" FROM SETTLEMENT_TYPE UNION
      SELECT 'LMP Realtime'          "OPTION_NAME", -2 "OPTION_ID", '92' "SORT_ORDER"  FROM DUAL UNION
      SELECT 'LMP Monthly Realtime'  "OPTION_NAME", -3 "OPTION_ID", '93' "SORT_ORDER"  FROM DUAL UNION
      SELECT 'PLC/NSPL'              "OPTION_NAME", -4 "OPTION_ID", '94' "SORT_ORDER"  FROM DUAL UNION
      SELECT 'NSPL'                  "OPTION_NAME", -5 "OPTION_ID", '95' "SORT_ORDER"  FROM DUAL UNION
      SELECT 'Load Submission'       "OPTION_NAME", -6 "OPTION_ID", '96' "SORT_ORDER"  FROM DUAL
      ORDER BY SORT_ORDER;
END QUERY_EXCHANGE_TYPE_LIST;

PROCEDURE QUERY_EXCHANGE
   (
   p_BEGIN_DATE  IN DATE,
   p_END_DATE    IN DATE,
   p_ENTITY_LIST IN VARCHAR2,  --Exchange Type Option Id--
   p_TRACE_ON    IN NUMBER,
   p_STATUS     OUT NUMBER,
   p_MESSAGE    OUT VARCHAR2
   ) AS
v_OPTION PLS_INTEGER := TO_NUMBER(TRIM(p_ENTITY_LIST));
v_EXCHANGE_TYPE VARCHAR2(64) := CASE v_OPTION WHEN -2 THEN 'Query Real-time LMP' WHEN -3 THEN 'Query Monthly Real-time LMP' ELSE NULL END;
v_COUNT PLS_INTEGER;
BEGIN
-- InSchedule Content --
   SELECT COUNT(*) INTO v_COUNT FROM SETTLEMENT_TYPE WHERE STATEMENT_TYPE_ID = v_OPTION;
   IF v_COUNT > 0 THEN
      CDI_PJM_INSCHEDULE.QUERY_SCHEDULES_FROM_PJM(v_OPTION, p_BEGIN_DATE, p_END_DATE, p_TRACE_ON, p_STATUS, p_MESSAGE);
-- Load LMP File Content --
   ELSIF v_OPTION IN (-2,-3) THEN
      MM_PJM_DM2.MARKET_EXCHANGE(p_BEGIN_DATE, p_END_DATE, v_EXCHANGE_TYPE, NULL, p_TRACE_ON, p_STATUS, p_MESSAGE);
-- PLC/NSPL --
   ELSIF v_OPTION IN (-4,-5) THEN
      QUERY_PLC_NSPL_FROM_PJM(p_BEGIN_DATE, p_END_DATE, CASE WHEN v_OPTION = -5 THEN 'NSPL' ELSE CONSTANTS.ALL_STRING END, p_TRACE_ON, p_STATUS, p_MESSAGE);
-- Load Submission --
   ELSIF v_OPTION = -6 THEN
-- Load Deration Factors --
      MM_PJM_ESCHED.MARKET_EXCHANGE(p_BEGIN_DATE, p_END_DATE, MM_PJM_ESCHED.g_ET_QUERY_DERATION_FACTORS, NULL, NULL, c_LOG_ONLY, c_LOG_TYPE, p_TRACE_ON, p_STATUS, p_MESSAGE);
-- Load Zone Demand --
      MM_PJM_POWERMETER.QUERY_POWERMETER(p_BEGIN_DATE, p_END_DATE, c_QUERY_FINAL_ZONE_LOAD, NULL, NULL, p_TRACE_ON, p_STATUS, p_MESSAGE);
      IF p_STATUS = GA.SUCCESS THEN
         POST_SYSTEM_LOAD_WITH_LOSSES(p_BEGIN_DATE, p_END_DATE);
      ELSE
         LOGS.LOG_WARN('System Load With Losses Were Not Posted. The Query Of Load Submission Content From The Exchange Returned A Non-Zero Status: ' || TO_CHAR(p_STATUS));
      END IF;
-- 500kv Losses --
      MM_PJM_POWERMETER.QUERY_POWERMETER(p_BEGIN_DATE, p_END_DATE, c_QUERY_500KV_LOSSES, NULL, NULL, p_TRACE_ON, p_STATUS, p_MESSAGE);
   ELSE
      p_MESSAGE := 'Undefined Exchange Type Option: ' || NVL(v_OPTION, CONSTANTS.UNDEFINED_ATTRIBUTE) || '.';
   END IF;
END QUERY_EXCHANGE;

PROCEDURE SUBMIT_TO_EXCHANGE_TYPE_LIST(p_LABEL OUT VARCHAR2, p_CURSOR OUT GA.REFCURSOR) AS
BEGIN
   p_LABEL := 'Exchange Type';
   OPEN p_CURSOR FOR
      SELECT 'InSchedule-' || SETTLEMENT_TYPE_NAME "OPTION_NAME", STATEMENT_TYPE_ID "OPTION_ID", TO_CHAR(SETTLEMENT_TYPE_ORDER) "SORT_ORDER" FROM SETTLEMENT_TYPE UNION
      SELECT 'PLC/NSPL-Full Process' "OPTION_NAME", -2 "OPTION_ID", '92' "SORT_ORDER" FROM DUAL UNION
      SELECT 'PLC/NSPL'              "OPTION_NAME", -3 "OPTION_ID", '93' "SORT_ORDER" FROM DUAL UNION
      SELECT 'NSPL-Full Process'     "OPTION_NAME", -4 "OPTION_ID", '94' "SORT_ORDER" FROM DUAL UNION
      SELECT 'NSPL'                  "OPTION_NAME", -5 "OPTION_ID", '95' "SORT_ORDER" FROM DUAL
      ORDER BY SORT_ORDER;
END SUBMIT_TO_EXCHANGE_TYPE_LIST;

PROCEDURE SUBMIT_TO_EXCHANGE
   (
   p_BEGIN_DATE  IN DATE,
   p_END_DATE    IN DATE,
   p_ENTITY_LIST IN VARCHAR2, --Exchange Type Option Id--
   p_TRACE_ON    IN NUMBER,
   p_STATUS     OUT NUMBER,
   p_MESSAGE    OUT VARCHAR2
   ) AS
v_OPTION      PLS_INTEGER := TO_NUMBER(TRIM(p_ENTITY_LIST));
v_COUNT       PLS_INTEGER;
v_SUBMIT_ONLY BOOLEAN := v_OPTION IN(-3,-5);
BEGIN
-- InSchedule Content --
   SELECT COUNT(*) INTO v_COUNT FROM SETTLEMENT_TYPE WHERE STATEMENT_TYPE_ID = v_OPTION;
   IF v_COUNT > 0 THEN
      CDI_PJM_INSCHEDULE.SUBMIT_SCHEDULES_TO_PJM(v_OPTION, p_BEGIN_DATE, p_END_DATE, p_TRACE_ON, p_STATUS, p_MESSAGE);
      CDI_PJM_INSCHEDULE.QUERY_SCHEDULES_FROM_PJM(v_OPTION, p_BEGIN_DATE, p_END_DATE, p_TRACE_ON, p_STATUS, p_MESSAGE);
-- PLC/NSPL-Full Process --
   ELSIF v_OPTION IN (-2,-4) THEN
      SUBMIT_PLC_NSPL(p_BEGIN_DATE, p_END_DATE, CASE WHEN v_OPTION = -4 THEN 'NSPL' ELSE CONSTANTS.ALL_STRING END, v_SUBMIT_ONLY, p_TRACE_ON, p_STATUS, p_MESSAGE);
-- PLC/NSPL-Submit Only --
   ELSIF v_OPTION IN (-3,-5) THEN
      SUBMIT_PLC_NSPL(p_BEGIN_DATE, p_END_DATE, CASE WHEN v_OPTION = -5 THEN 'NSPL' ELSE CONSTANTS.ALL_STRING END, v_SUBMIT_ONLY, p_TRACE_ON, p_STATUS, p_MESSAGE);
   ELSE
      p_MESSAGE := 'Undefined Exchange Type Option: ' || NVL(v_OPTION, CONSTANTS.UNDEFINED_ATTRIBUTE) || '.';
   END IF;
END SUBMIT_TO_EXCHANGE;

PROCEDURE EXPORT_EXCHANGE_TYPE_LIST(p_LABEL OUT VARCHAR2, p_CURSOR OUT GA.REFCURSOR) AS
BEGIN
   p_LABEL := 'Exchange Type';
   OPEN p_CURSOR FOR
      SELECT 'InSchedule-' || SETTLEMENT_TYPE_NAME "OPTION_NAME", STATEMENT_TYPE_ID "OPTION_ID", TO_CHAR(SETTLEMENT_TYPE_ORDER) "SORT_ORDER" FROM SETTLEMENT_TYPE UNION
      SELECT 'PLC/NSPL'   "OPTION_NAME", -2 "OPTION_ID", '92' "SORT_ORDER" FROM DUAL UNION
      SELECT 'NSPL'       "OPTION_NAME", -3 "OPTION_ID", '93' "SORT_ORDER" FROM DUAL
      ORDER BY SORT_ORDER;
END EXPORT_EXCHANGE_TYPE_LIST;

PROCEDURE EXPORT_EXCHANGE_FILE
   (
   p_BEGIN_DATE       IN DATE,
   p_END_DATE         IN DATE,
   p_ENTITY_LIST      IN VARCHAR2,  --Exchange Type Option Id--
   p_EXPORT_FILE_PATH IN VARCHAR2,
   p_TRACE_ON         IN NUMBER,
   p_FILE            OUT CLOB,
   p_STATUS          OUT NUMBER,
   p_MESSAGE         OUT VARCHAR2
   ) AS
v_OPTION PLS_INTEGER := TO_NUMBER(TRIM(p_ENTITY_LIST));
v_COUNT PLS_INTEGER;
BEGIN
-- InSchedule Content --
   SELECT COUNT(*) INTO v_COUNT FROM SETTLEMENT_TYPE WHERE STATEMENT_TYPE_ID = v_OPTION;
   IF v_COUNT > 0 THEN
      CDI_PJM_INSCHEDULE.EXPORT_SCHEDULES_TO_FILE(v_OPTION, p_BEGIN_DATE, p_END_DATE, p_TRACE_ON, p_FILE, p_STATUS, p_MESSAGE);
-- PLC/NSPL --
   ELSIF v_OPTION IN (-2,-3) THEN
      EXPORT_PLC_NSPL_TO_FILE(p_BEGIN_DATE, p_END_DATE, CASE WHEN v_OPTION = -3 THEN 'NSPL' ELSE CONSTANTS.ALL_STRING END, p_TRACE_ON, p_FILE, p_STATUS, p_MESSAGE);
   ELSE
      p_MESSAGE := 'Undefined Exchange Type Option: ' || NVL(v_OPTION, CONSTANTS.UNDEFINED_ATTRIBUTE) || '.';
   END IF;
END EXPORT_EXCHANGE_FILE;

END CDI_PJM;
/
