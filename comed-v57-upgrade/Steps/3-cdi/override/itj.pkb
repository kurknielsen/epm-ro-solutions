CREATE OR REPLACE PACKAGE BODY ITJ AS
----------------------------------------------------------------------------------------------------
c_CANNOT_EDIT_TXN_BLOTTER_MSG CONSTANT VARCHAR2(200) := 'Editing of an existing transaction is not allowed.';
c_SPECIAL_TEMPLATE_TYPE		  CONSTANT NUMBER(1) := 0;
c_NORMAL_TEMPLATE_TYPE		  CONSTANT NUMBER(1) := 1;
----------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
    RETURN '$Revision: 1.40 $';
END WHAT_VERSION;
----------------------------------------------------------------------------------------------------
PROCEDURE NULL_CURSOR
    (
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN

	OPEN p_CURSOR FOR
		SELECT NULL FROM DUAL;

END NULL_CURSOR;
---------------------------------------------------------------------------------------------------
PROCEDURE TRANSACTION_LIST
	(
	p_TIME_ZONE IN VARCHAR,
    p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	)
	AS

BEGIN

p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	SELECT
		i.TRANSACTION_NAME,
		i.TRANSACTION_ID,
        i.TRANSACTION_ALIAS,
		i.transaction_interval,
        TRUNC(FROM_CUT(BEGIN_DATE, p_TIME_ZONE)) "BEGIN_DATE",
        TRUNC(FROM_CUT(END_DATE+1, p_TIME_ZONE)-1/86400) "END_DATE"
	FROM INTERCHANGE_TRANSACTION i
  WHERE i.END_DATE < CONSTANTS.HIGH_DATE
UNION ALL
SELECT
		i.TRANSACTION_NAME,
		i.TRANSACTION_ID,
        i.TRANSACTION_ALIAS,
		i.transaction_interval,
        TRUNC(FROM_CUT(END_DATE, 'EDT')) "BEGIN_DATE",
        END_DATE
	FROM INTERCHANGE_TRANSACTION i
  WHERE TRUNC(FROM_CUT(END_DATE, 'EDT')) = CONSTANTS.HIGH_DATE
  ORDER BY TRANSACTION_NAME;

END TRANSACTION_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE FIND_TRANSACTION_LIST
	(
	p_SEARCH_STRING IN VARCHAR,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_MODEL_ID IN NUMBER,
    p_SEARCH_TYPE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the given entities for the FIND DIALOG
v_IDs ID_TABLE;

BEGIN

--Make sure user has appropriate access.
v_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_TXN_SELECT, EC.ED_TRANSACTION);
p_STATUS := GA.SUCCESS;

CASE
    WHEN p_SEARCH_TYPE = 'By Alias' THEN

        OPEN p_CURSOR FOR
    	SELECT
    		TRANSACTION_NAME "ENTITY_NAME",
    		TRANSACTION_ID "ENTITY_ID",
    		TRANSACTION_ALIAS "ENTITY_ALIAS",
    		'Active' "ENTITY_STATUS"
    	FROM INTERCHANGE_TRANSACTION, TABLE(CAST(v_IDs AS ID_TABLE)) IDs
        WHERE TRANSACTION_ID > 0
            AND UPPER(TRANSACTION_ALIAS) LIKE UPPER(p_SEARCH_STRING)
            AND BEGIN_DATE <= p_END_DATE
            AND END_DATE >= p_BEGIN_DATE
			AND (IDs.ID = SD.g_ALL_DATA_ENTITY_ID OR IDs.ID = TRANSACTION_ID)
    	ORDER BY 1;

    WHEN p_SEARCH_TYPE = 'By OASIS Reference' THEN

        OPEN p_CURSOR FOR
    	SELECT DISTINCT
    		B.TRANSACTION_NAME "ENTITY_NAME",
    		B.TRANSACTION_ID "ENTITY_ID",
    		B.TRANSACTION_ALIAS "ENTITY_ALIAS",
    		'Active' "ENTITY_STATUS"
    	FROM OASIS_RESERVATION A, INTERCHANGE_TRANSACTION B, TABLE(CAST(v_IDs as ID_TABLE)) IDs
        WHERE A.TRANSACTION_ID > 0
            AND UPPER(A.RESERVATON_NBR) LIKE UPPER(p_SEARCH_STRING)
            AND A.TRANSACTION_ID = B.TRANSACTION_ID
            AND BEGIN_DATE <= p_END_DATE
            AND END_DATE >= p_BEGIN_DATE
			AND (IDs.ID = SD.g_ALL_DATA_ENTITY_ID OR IDs.ID = B.TRANSACTION_ID)
    	ORDER BY 1;

    WHEN p_SEARCH_TYPE = 'By Tag Reference' THEN

        OPEN p_CURSOR FOR
    	SELECT DISTINCT
    		B.TRANSACTION_NAME "ENTITY_NAME",
    		B.TRANSACTION_ID "ENTITY_ID",
    		B.TRANSACTION_ALIAS "ENTITY_ALIAS",
    		'Active' "ENTITY_STATUS"
    	FROM ETAG A, INTERCHANGE_TRANSACTION B, ETAG_TRANSACTION C, TABLE(CAST(v_IDs as ID_TABLE)) IDs
    	WHERE B.TRANSACTION_ID > 0
            AND UPPER(A.ETAG_NAME) LIKE UPPER(p_SEARCH_STRING)
            AND A.ETAG_ID = C.ETAG_ID
            AND C.TRANSACTION_ID = B.TRANSACTION_ID
            AND BEGIN_DATE <= p_END_DATE
            AND END_DATE >= p_BEGIN_DATE
			AND (IDs.ID = SD.g_ALL_DATA_ENTITY_ID OR IDs.ID = B.TRANSACTION_ID)
    	ORDER BY 1;

    ELSE -- By Name

        OPEN p_CURSOR FOR
    	SELECT
    		TRANSACTION_NAME "ENTITY_NAME",
    		TRANSACTION_ID "ENTITY_ID",
    		TRANSACTION_ALIAS "ENTITY_ALIAS",
    		'Active' "ENTITY_STATUS"
    	FROM INTERCHANGE_TRANSACTION, TABLE(CAST(v_IDs as ID_TABLE)) IDs
        WHERE TRANSACTION_ID > 0
            AND UPPER(TRANSACTION_NAME) LIKE UPPER(p_SEARCH_STRING)
            AND BEGIN_DATE <= p_END_DATE
            AND END_DATE >= p_BEGIN_DATE
			AND (IDs.ID = SD.g_ALL_DATA_ENTITY_ID OR IDs.ID = TRANSACTION_ID)
    	ORDER BY 1;

END CASE;


END FIND_TRANSACTION_LIST;
----------------------------------------------------------------------------------------------------
FUNCTION SUPPLY_SCHEDULE_TYPE
    (
	p_SCHEDULE_TYPE IN NUMBER
	) RETURN NUMBER IS

BEGIN

	IF GA.ENABLE_SUPPLY_SCHEDULE_TYPES THEN
	    RETURN p_SCHEDULE_TYPE;
	ELSE
	    RETURN CONSTANTS.NOT_ASSIGNED;
	END IF;

END SUPPLY_SCHEDULE_TYPE;
---------------------------------------------------------------------------------------------------
FUNCTION RIGHT_JUSTIFY
    (
	p_STRING IN VARCHAR,
	p_LENGTH IN NUMBER
	) RETURN VARCHAR IS

v_STRING VARCHAR(32);

BEGIN

	v_STRING := '                ' || p_STRING;
	RETURN SUBSTR(v_STRING, LENGTH(v_STRING) - (p_LENGTH - 1));

END RIGHT_JUSTIFY;
---------------------------------------------------------------------------------------------------
FUNCTION GET_TP_CONTRACT_NUMBER
    (
	p_TRANSACTION_ID IN NUMBER,
	p_SERVICE_DATE IN DATE
	) RETURN VARCHAR IS

v_CONTRACT_NUMBER VARCHAR(32);

BEGIN

	SELECT CONTRACT_NUMBER
	INTO v_CONTRACT_NUMBER
	FROM INTERCHANGE_TRANSACTION A,
	    TP_CONTRACT_NUMBER B
	WHERE A.TRANSACTION_ID = p_TRANSACTION_ID
        AND B.CONTRACT_ID = A.CONTRACT_ID
		AND TRUNC(p_SERVICE_DATE) BETWEEN B.BEGIN_DATE AND NVL(B.END_DATE, p_SERVICE_DATE)
		AND ROWNUM = 1;

	RETURN v_CONTRACT_NUMBER;

	EXCEPTION
	    WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		    RETURN 'NO CONTRACT NUMBER DEFINED';

END GET_TP_CONTRACT_NUMBER;
---------------------------------------------------------------------------------------------------
FUNCTION GET_CONTRACT_ID
    (
	p_TRANSACTION_ID IN NUMBER
	) RETURN NUMBER IS

v_CONTRACT_ID NUMBER(9);

BEGIN

	SELECT CONTRACT_ID
	INTO v_CONTRACT_ID
	FROM INTERCHANGE_TRANSACTION
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

	RETURN v_CONTRACT_ID;

EXCEPTION
    WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
	    RETURN CONSTANTS.NOT_ASSIGNED;

END GET_CONTRACT_ID;
---------------------------------------------------------------------------------------------------
FUNCTION GET_PSE_NERC_CODE
	(
	p_PSE_ID IN NUMBER
	) RETURN VARCHAR IS

-- Answer the PSE NERC code for the specified PSE Id.

v_PSE_NERC_CODE VARCHAR(32);

BEGIN

	SELECT DECODE(NVL(PSE_NERC_CODE,'?'), '?', PSE_ALIAS, PSE_NERC_CODE)
	INTO v_PSE_NERC_CODE
	FROM PURCHASING_SELLING_ENTITY
	WHERE PSE_ID = p_PSE_ID;

	RETURN v_PSE_NERC_CODE;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN '';

END GET_PSE_NERC_CODE;
----------------------------------------------------------------------------------------------------
FUNCTION GET_TP_NERC_CODE
	(
	p_TP_ID IN NUMBER
	) RETURN VARCHAR IS

-- Answer the TP NERC code for the specified TP Id.

v_TP_NERC_CODE VARCHAR(32);

BEGIN

	SELECT DECODE(NVL(TP_NERC_CODE,'?'), '?', TP_ALIAS, TP_NERC_CODE)
	INTO v_TP_NERC_CODE
	FROM TRANSMISSION_PROVIDER
	WHERE TP_ID = p_TP_ID;

	RETURN v_TP_NERC_CODE;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN '';

END GET_TP_NERC_CODE;
----------------------------------------------------------------------------------------------------
FUNCTION GET_CA_NERC_CODE
	(
	p_CA_ID IN NUMBER
	) RETURN VARCHAR IS

-- Answer the CA NERC code for the specified CA Id.

v_CA_NERC_CODE VARCHAR(32);

BEGIN

	SELECT DECODE(NVL(CA_NERC_CODE,'?'), '?', CA_ALIAS, CA_NERC_CODE)
	INTO v_CA_NERC_CODE
	FROM CONTROL_AREA
	WHERE CA_ID = p_CA_ID;

	RETURN v_CA_NERC_CODE;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN '';

END GET_CA_NERC_CODE;
----------------------------------------------------------------------------------------------------
FUNCTION GET_PSE_ID_USING_NERC_CODE
	(
	p_PSE_NERC_CODE IN VARCHAR
	) RETURN NUMBER IS

-- Answer the PSE id using the specified NERC code.

v_PSE_ID NUMBER;

BEGIN

    IF p_PSE_NERC_CODE IS NULL THEN
	    RETURN 0;
	END IF;

    v_PSE_ID := ID.ID_FOR_PSE_NERC_CODE(p_PSE_NERC_CODE);
	IF NOT v_PSE_ID  > 0 THEN
	    ID.ID_FOR_PSE(p_PSE_NERC_CODE, FALSE, v_PSE_ID);
		IF v_PSE_ID = GA.NO_DATA_FOUND THEN
	        ID.ID_FOR_PSE(p_PSE_NERC_CODE, TRUE, v_PSE_ID);
			UPDATE PURCHASING_SELLING_ENTITY
			SET PSE_NERC_CODE = p_PSE_NERC_CODE
			WHERE PSE_ID = v_PSE_ID;
		ELSIF v_PSE_ID < 0 THEN
        	v_PSE_ID := 0;
		END IF;
	END IF;

	RETURN v_PSE_ID;

	EXCEPTION
		WHEN OTHERS THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN 0;

END GET_PSE_ID_USING_NERC_CODE;
----------------------------------------------------------------------------------------------------
FUNCTION GET_TP_ID_USING_NERC_CODE
	(
	p_TP_NERC_CODE IN VARCHAR
	) RETURN NUMBER IS

-- Answer the PSE id using the specified NERC code.

v_TP_ID NUMBER;

BEGIN

    IF p_TP_NERC_CODE IS NULL THEN
	    RETURN 0;
	END IF;

	v_TP_ID := ID.ID_FOR_TP_NERC_CODE(p_TP_NERC_CODE);
	IF NOT v_TP_ID  > 0 THEN
	    ID.ID_FOR_TP(p_TP_NERC_CODE, FALSE, v_TP_ID);
		IF v_TP_ID = GA.NO_DATA_FOUND THEN
	        ID.ID_FOR_TP(p_TP_NERC_CODE, TRUE, v_TP_ID);
			UPDATE TRANSMISSION_PROVIDER
			SET TP_NERC_CODE = p_TP_NERC_CODE
			WHERE TP_ID = v_TP_ID;
		ELSIF v_TP_ID < 0 THEN
        	v_TP_ID := 0;
		END IF;
	END IF;

	RETURN v_TP_ID;

	EXCEPTION
		WHEN OTHERS THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN 0;

END GET_TP_ID_USING_NERC_CODE;
----------------------------------------------------------------------------------------------------
FUNCTION GET_CA_ID_USING_NERC_CODE
	(
	p_CA_NERC_CODE IN VARCHAR
	) RETURN NUMBER IS

-- Answer the CA id using the specified NERC code.

v_CA_ID NUMBER;

BEGIN

    IF p_CA_NERC_CODE IS NULL THEN
	    RETURN 0;
	END IF;

    v_CA_ID := ID.ID_FOR_CA_NERC_CODE(p_CA_NERC_CODE);
	IF NOT v_CA_ID  > 0 THEN
	    ID.ID_FOR_CA(p_CA_NERC_CODE, FALSE, v_CA_ID);
		IF v_CA_ID = GA.NO_DATA_FOUND THEN
	        ID.ID_FOR_CA(p_CA_NERC_CODE, TRUE, v_CA_ID);
			UPDATE CONTROL_AREA
			SET CA_NERC_CODE = p_CA_NERC_CODE
			WHERE CA_ID = v_CA_ID;
		ELSIF v_CA_ID < 0 THEN
        	v_CA_ID := 0;
		END IF;
	END IF;

	RETURN v_CA_ID;

	EXCEPTION
		WHEN OTHERS THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN 0;

END GET_CA_ID_USING_NERC_CODE;
----------------------------------------------------------------------------------------------------
FUNCTION GET_SERVICE_POINT_NAME
	(
	p_SERVICE_POINT_ID IN NUMBER
	) RETURN VARCHAR IS

-- Answer the Service Point name for the specified Service Point Id.

v_SERVICE_POINT_NAME VARCHAR(32);

BEGIN

	SELECT SERVICE_POINT_NAME
	INTO v_SERVICE_POINT_NAME
	FROM SERVICE_POINT
	WHERE SERVICE_POINT_ID = p_SERVICE_POINT_ID;

	RETURN v_SERVICE_POINT_NAME;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN '';

END GET_SERVICE_POINT_NAME;
----------------------------------------------------------------------------------------------------
FUNCTION GET_SERVICE_POINT_EDC_ALIAS
	(
	p_SERVICE_POINT_ID IN NUMBER
	) RETURN VARCHAR IS
-- Answer the Service Point name for the specified Service Point Id.
v_EDC_ALIAS VARCHAR(32);
BEGIN
	SELECT A.EDC_ALIAS
	INTO v_EDC_ALIAS
	FROM ENERGY_DISTRIBUTION_COMPANY A,
		 SERVICE_POINT B
	WHERE B.SERVICE_POINT_ID = p_SERVICE_POINT_ID
		  AND A.EDC_ID = B.EDC_ID;
	RETURN v_EDC_ALIAS;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN '';
END GET_SERVICE_POINT_EDC_ALIAS;
----------------------------------------------------------------------------------------------------
FUNCTION GET_SERVICE_POINT_CA_ID
	(
	p_SERVICE_POINT_ID IN NUMBER
	) RETURN NUMBER IS

-- Answer the Service Point name for the specified Service Point Id.

v_CA_ID NUMBER;

BEGIN

	SELECT CA_ID
	INTO v_CA_ID
	FROM SERVICE_POINT
	WHERE SERVICE_POINT_ID = p_SERVICE_POINT_ID;

	RETURN v_CA_ID;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN CONSTANTS.NOT_ASSIGNED;

END GET_SERVICE_POINT_CA_ID;
----------------------------------------------------------------------------------------------------
FUNCTION GET_TRANSACTION_INTERVAL
    (
	p_TRANSACTION_ID IN NUMBER
	) RETURN VARCHAR IS

v_INTERVAL CHAR(2) := 'XX';

BEGIN

	SELECT DECODE(UPPER(SUBSTR(TRANSACTION_INTERVAL,1,2)),'DA','DD','WE','WW','MO','MM','QU','QQ','YE','YY','XX')
	INTO v_INTERVAL
	FROM INTERCHANGE_TRANSACTION
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

	RETURN v_INTERVAL;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN 'XX';

END GET_TRANSACTION_INTERVAL;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_TRANSACTION_MINUTES
    (
	p_TRANSACTION_ID IN NUMBER,
	p_INTERNAL_MINUTES OUT NUMBER,
	p_EXTERNAL_MINUTES OUT NUMBER
	) AS

BEGIN

	SELECT DECODE(UPPER(TRANSACTION_INTERVAL), '5 MINUTE', 5,'10 MINUTE', 10,'15 MINUTE', 15,'20 MINUTE', 20,'30 MINUTE', 30, 60),
		DECODE(UPPER(NVL(EXTERNAL_INTERVAL,TRANSACTION_INTERVAL)), '5 MINUTE', 5,'10 MINUTE', 10,'15 MINUTE', 15,'20 MINUTE', 20,'30 MINUTE', 30, 60)
	INTO p_INTERNAL_MINUTES, p_EXTERNAL_MINUTES
	FROM INTERCHANGE_TRANSACTION
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		p_INTERNAL_MINUTES := 60;
		p_EXTERNAL_MINUTES := 60;

END GET_TRANSACTION_MINUTES;
---------------------------------------------------------------------------------------------------
FUNCTION GET_TRANSACTION_MINUTES
    (
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_USE_LEAST_INTERVAL IN BOOLEAN DEFAULT FALSE
	) RETURN NUMBER IS

v_INTERNAL_MINUTES NUMBER(2);
v_EXTERNAL_MINUTES NUMBER(2);

BEGIN

	GET_TRANSACTION_MINUTES(p_TRANSACTION_ID, v_INTERNAL_MINUTES, v_EXTERNAL_MINUTES);

	IF p_USE_LEAST_INTERVAL THEN
		RETURN LEAST(v_INTERNAL_MINUTES, v_EXTERNAL_MINUTES);
	ELSE
		IF p_SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE THEN
			RETURN v_INTERNAL_MINUTES;
		ELSIF p_SCHEDULE_STATE = CONSTANTS.EXTERNAL_STATE THEN
			RETURN v_EXTERNAL_MINUTES;
		ELSE
		RETURN GREATEST(v_INTERNAL_MINUTES, v_EXTERNAL_MINUTES);
		END IF;
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN 60;

END GET_TRANSACTION_MINUTES;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_SCHEDULE
	(
	p_TRANSACTION_IDS IN VARCHAR,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
    p_TIME_ZONE IN VARCHAR,
	p_SCHEDULE IN OUT NOCOPY CONTRACT_SCHEDULE_TABLE,
	p_ROLL_UP_BY_CONTRACT IN NUMBER := 1,
	p_DELIMITER VARCHAR := ';'
	) AS

v_SCHEDULE_DATE DATE;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_SYSDATE DATE := SYSDATE;
v_LOW_DATE DATE := CONSTANTS.LOW_DATE;
v_INDEX BINARY_INTEGER;
v_MINUTES NUMBER(2);
v_MINUTE_DIVISOR NUMBER;
v_WORK_ID NUMBER;
v_TABLE GA.STRING_TABLE;
v_INDEX BINARY_INTEGER;
v_CONTRACT_ID NUMBER(9);
v_TRANSACTION_ID NUMBER(9);
v_SEQUENCE NUMBER(9) := 0;

BEGIN

	UT.GET_RTO_WORK_ID(v_WORK_ID);
	UT.TOKENS_FROM_STRING(p_TRANSACTION_IDS, p_DELIMITER, v_TABLE);
	FOR v_INDEX IN v_TABLE.FIRST..v_TABLE.LAST LOOP
		v_TRANSACTION_ID := TO_NUMBER(v_TABLE(v_INDEX));
		v_MINUTES := GET_TRANSACTION_MINUTES(v_TRANSACTION_ID, p_SCHEDULE_STATE);
		UT.CUT_DAY_INTERVAL_RANGE(CONSTANTS.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_MINUTES, v_BEGIN_DATE, v_END_DATE);
		v_MINUTE_DIVISOR := v_MINUTES * 60 / 86400;
		v_SCHEDULE_DATE := v_BEGIN_DATE;
		v_CONTRACT_ID := GET_CONTRACT_ID(v_TRANSACTION_ID);
--Make Certain There is a Value for Every Interval.
		WHILE v_SCHEDULE_DATE <= v_END_DATE LOOP
			v_SEQUENCE := v_SEQUENCE + 1;
	    	UT.POST_RTO_WORK(v_WORK_ID, v_SEQUENCE, v_TRANSACTION_ID, v_SCHEDULE_DATE, TO_CHAR(v_CONTRACT_ID));
			COMMIT;
			v_SCHEDULE_DATE := ADD_MINUTES_TO_DATE(v_SCHEDULE_DATE, v_MINUTES);
		END LOOP;

	END LOOP;
	v_TABLE.DELETE;

	IF GA.VERSION_SCHEDULE THEN
		SELECT CONTRACT_SCHEDULE_TYPE(TO_NUMBER(B.WORK_DATA), CASE WHEN p_ROLL_UP_BY_CONTRACT = 1 THEN 0 ELSE B.WORK_XID END, B.WORK_DATE, A.AMOUNT)
		BULK COLLECT INTO p_SCHEDULE
		FROM IT_SCHEDULE A, RTO_WORK B
		WHERE B.WORK_ID = v_WORK_ID
			AND A.TRANSACTION_ID = B.WORK_XID
			AND A.SCHEDULE_TYPE = p_SCHEDULE_TYPE
			AND A.SCHEDULE_STATE = p_SCHEDULE_STATE
			AND A.SCHEDULE_DATE (+) = B.WORK_DATE
			AND A.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM IT_SCHEDULE
				WHERE TRANSACTION_ID = A.TRANSACTION_ID
					AND SCHEDULE_TYPE = A.SCHEDULE_TYPE
					AND SCHEDULE_STATE = A.SCHEDULE_STATE
					AND SCHEDULE_DATE = A.SCHEDULE_DATE
					AND AS_OF_DATE <= v_SYSDATE);
	ELSE
		SELECT CONTRACT_SCHEDULE_TYPE(TO_NUMBER(B.WORK_DATA), CASE WHEN p_ROLL_UP_BY_CONTRACT = 1 THEN 0 ELSE B.WORK_XID END, B.WORK_DATE, A.AMOUNT)
		BULK COLLECT INTO p_SCHEDULE
		FROM IT_SCHEDULE A, RTO_WORK B
		WHERE B.WORK_ID = v_WORK_ID
			AND A.TRANSACTION_ID = B.WORK_XID
			AND A.SCHEDULE_TYPE = p_SCHEDULE_TYPE
			AND A.SCHEDULE_STATE = p_SCHEDULE_STATE
			AND A.SCHEDULE_DATE (+) = B.WORK_DATE
			AND A.AS_OF_DATE = v_LOW_DATE;
	END IF;

	UT.PURGE_RTO_WORK(v_WORK_ID);

EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			UT.PURGE_RTO_WORK(v_WORK_ID);
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE();
		END;
		ERRS.LOG_AND_RAISE();
END GET_SCHEDULE;
--------------------------------------------------------------------------------------------------
PROCEDURE TRACE_SCHEDULE
    (
	p_NAME IN VARCHAR,
	p_SCHEDULE IN CONTRACT_SCHEDULE_TABLE
	) AS

v_INDEX BINARY_INTEGER;

BEGIN

	LOGS.LOG_DEBUG('TRACE ' || p_NAME);
	IF p_SCHEDULE.COUNT = 0 THEN
	    LOGS.LOG_DEBUG('<schedule empty>');
	ELSE
	    FOR v_INDEX IN p_SCHEDULE.FIRST..p_SCHEDULE.LAST LOOP
		    LOGS.LOG_DEBUG(TO_CHAR(v_INDEX) || ',' || TO_CHAR(p_SCHEDULE(v_INDEX).CONTRACT_ID) || ',' || TO_CHAR(p_SCHEDULE(v_INDEX).TRANSACTION_ID) || ',' || UT.TRACE_DATE(p_SCHEDULE(v_INDEX).SCHEDULE_DATE) || ',' || TO_CHAR(p_SCHEDULE(v_INDEX).SCHEDULE_VAL));
		END LOOP;
	END IF;

END TRACE_SCHEDULE;
---------------------------------------------------------------------------------------------------
PROCEDURE COERCE_DATE_RANGE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_USE_LEAST_INTERVAL IN BOOLEAN,
	p_COERCED_BEGIN_DATE OUT DATE,
	p_COERCED_END_DATE OUT DATE,
	p_FORMAT OUT VARCHAR,
	p_MINUTES OUT NUMBER
	) AS

v_INTERVAL CHAR(2);

BEGIN

	v_INTERVAL := GET_TRANSACTION_INTERVAL(p_TRANSACTION_ID);
	p_MINUTES := GET_TRANSACTION_MINUTES(p_TRANSACTION_ID, p_SCHEDULE_STATE, p_USE_LEAST_INTERVAL);

-- Coerce the date range to allow weekly, monthly, and yearly transactions in scope to show up.
	IF v_INTERVAL IN ('DD','WW','MM','QQ','YY') THEN
		IF v_INTERVAL = 'DD' THEN
		   p_COERCED_BEGIN_DATE := TRUNC(p_BEGIN_DATE);
		ELSIF v_INTERVAL = 'WW' THEN
		   p_COERCED_BEGIN_DATE := TRUNC(p_BEGIN_DATE) - 6;
		ELSIF v_INTERVAL = 'MM' THEN
		   p_COERCED_BEGIN_DATE := ADD_MONTHS(TRUNC(p_BEGIN_DATE),-1) + 1;
		ELSIF v_INTERVAL = 'QQ' THEN
		   p_COERCED_BEGIN_DATE := ADD_MONTHS(TRUNC(p_BEGIN_DATE),-3) + 1;
		ELSIF v_INTERVAL = 'YY' THEN
		   p_COERCED_BEGIN_DATE := ADD_MONTHS(TRUNC(p_BEGIN_DATE),-12) + 1;
		END IF;
		p_COERCED_END_DATE := ADD_SECONDS_TO_DATE(TRUNC(p_END_DATE), 1);
		p_FORMAT := v_INTERVAL;
	ELSE
		UT.CUT_DAY_INTERVAL_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_MINUTES, p_COERCED_BEGIN_DATE, p_COERCED_END_DATE);
		IF v_INTERVAL = 'XX' THEN
			IF p_MINUTES = 60 THEN
			   p_FORMAT := NULL;
			ELSE
				p_FORMAT := 'MI' || p_MINUTES;
			END IF;
		END IF;
	END IF;

	IF LOGS.IS_DEBUG_ENABLED() THEN
		LOGS.LOG_DEBUG('COERCE_DATE_RANGE');
		LOGS.LOG_DEBUG('COERCED_BEGIN_DATE=' || UT.TRACE_DATE(p_COERCED_BEGIN_DATE));
		LOGS.LOG_DEBUG('COERCED_END_DATE=' || UT.TRACE_DATE(p_COERCED_END_DATE));
		LOGS.LOG_DEBUG('FORMAT=' || p_FORMAT);
		LOGS.LOG_DEBUG('MINUTES=' || TO_CHAR(p_MINUTES));
	END IF;

END COERCE_DATE_RANGE;
---------------------------------------------------------------------------
PROCEDURE GET_ENTITY_PHONE_NUMBERS
    (
	p_ENTITY_ID IN NUMBER,
	p_ENTITY_DOMAIN_ALIAS IN VARCHAR,
	p_CATEGORY_NAME IN VARCHAR,
	p_WORK_PHONE OUT VARCHAR,
	p_HOME_PHONE OUT VARCHAR,
	p_FAX_PHONE OUT VARCHAR,
	p_CELL_PHONE OUT VARCHAR
	) AS

v_CONTACT_NAME VARCHAR(32);
v_CONTACT_ALIAS VARCHAR(32);
v_EMAIL_ADDRESS VARCHAR(64);
v_STATUS NUMBER;

BEGIN

    RO.GET_ENTITY_CONTACT(p_ENTITY_ID, p_ENTITY_DOMAIN_ALIAS, p_CATEGORY_NAME, v_CONTACT_NAME,
		v_CONTACT_ALIAS, p_WORK_PHONE, p_HOME_PHONE, p_FAX_PHONE, p_CELL_PHONE, v_EMAIL_ADDRESS, v_STATUS);

END GET_ENTITY_PHONE_NUMBERS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_ENTITY_PHONE_NUMBERS
    (
	p_ENTITY_ID IN NUMBER,
	p_ENTITY_DOMAIN_ALIAS IN VARCHAR,
	p_CATEGORY_NAME IN VARCHAR,
	p_CONTACT_NAME IN VARCHAR,
	p_WORK_PHONE IN VARCHAR,
	p_HOME_PHONE IN VARCHAR,
	p_FAX_PHONE IN VARCHAR,
	p_CELL_PHONE IN VARCHAR
	) AS

v_STATUS NUMBER;

BEGIN

    RO.PUT_ENTITY_CONTACT(p_ENTITY_ID, p_ENTITY_DOMAIN_ALIAS, p_CATEGORY_NAME, p_CONTACT_NAME,
		p_WORK_PHONE, p_HOME_PHONE, p_FAX_PHONE, p_CELL_PHONE, NULL, v_STATUS);

END PUT_ENTITY_PHONE_NUMBERS;
---------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_TRANSACTION_PATH
	(
	p_TRANSACTION_PATH IN TRANSACTION_PATH%ROWTYPE,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	UPDATE TRANSACTION_PATH SET
	    CA_ID = p_TRANSACTION_PATH.CA_ID,
		TP_ID = p_TRANSACTION_PATH.TP_ID,
		PSE_ID = p_TRANSACTION_PATH.PSE_ID,
		TP_PRODUCT_CODE = p_TRANSACTION_PATH.TP_PRODUCT_CODE,
		TP_PATH_NAME = p_TRANSACTION_PATH.TP_PATH_NAME,
		TP_ASSIGNMENT_REF = p_TRANSACTION_PATH.TP_ASSIGNMENT_REF,
		TP_PRODUCT_LEVEL = p_TRANSACTION_PATH.TP_PRODUCT_LEVEL,
		MISC_INFO = p_TRANSACTION_PATH.MISC_INFO,
		MISC_REF = p_TRANSACTION_PATH.MISC_REF
	WHERE TRANSACTION_ID = p_TRANSACTION_PATH.TRANSACTION_ID
		AND LEG_NBR = p_TRANSACTION_PATH.LEG_NBR;

	IF SQL%NOTFOUND THEN
		INSERT INTO TRANSACTION_PATH (
	        TRANSACTION_ID,
			LEG_NBR,
			CA_ID,
			TP_ID,
			PSE_ID,
			TP_PRODUCT_CODE,
			TP_PATH_NAME,
			TP_ASSIGNMENT_REF,
			TP_PRODUCT_LEVEL,
			MISC_INFO,
			MISC_REF)
		VALUES (
	        p_TRANSACTION_PATH.TRANSACTION_ID,
	        p_TRANSACTION_PATH.LEG_NBR,
	        p_TRANSACTION_PATH.CA_ID,
			p_TRANSACTION_PATH.TP_ID,
			p_TRANSACTION_PATH.PSE_ID,
			p_TRANSACTION_PATH.TP_PRODUCT_CODE,
			p_TRANSACTION_PATH.TP_PATH_NAME,
			p_TRANSACTION_PATH.TP_ASSIGNMENT_REF,
			p_TRANSACTION_PATH.TP_PRODUCT_LEVEL,
			p_TRANSACTION_PATH.MISC_INFO,
			p_TRANSACTION_PATH.MISC_REF);
	END IF;

	p_STATUS := GA.SUCCESS;


END PUT_TRANSACTION_PATH;
----------------------------------------------------------------------------------------------------
PROCEDURE ZERO_FILL_IT_SCHEDULE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_PRICE IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

v_AS_OF_DATE DATE;
--ONLY FILL THE VALUE IF THERE IS NO EXISTING VALUE.
BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	IF GA.VERSION_SCHEDULE THEN
		v_AS_OF_DATE := CORRECTED_AS_OF_DATE(p_AS_OF_DATE);
	ELSE
		v_AS_OF_DATE := CONSTANTS.LOW_DATE;
	END IF;

	UPDATE IT_SCHEDULE SET
		AMOUNT = AMOUNT
	WHERE TRANSACTION_ID = p_TRANSACTION_ID
		AND SCHEDULE_TYPE = p_SCHEDULE_TYPE
		AND SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE
		AND SCHEDULE_DATE = p_SCHEDULE_DATE
		AND AS_OF_DATE = v_AS_OF_DATE;

	IF SQL%NOTFOUND THEN
		INSERT INTO IT_SCHEDULE (
			TRANSACTION_ID,
			SCHEDULE_TYPE,
			SCHEDULE_STATE,
			SCHEDULE_DATE,
			AS_OF_DATE,
			AMOUNT,
			PRICE)
		VALUES (
			p_TRANSACTION_ID,
			p_SCHEDULE_TYPE,
			CONSTANTS.INTERNAL_STATE,
			p_SCHEDULE_DATE,
			v_AS_OF_DATE,
			0,
			p_PRICE);
	END IF;


END ZERO_FILL_IT_SCHEDULE;
----------------------------------------------------------------------------------------------------
PROCEDURE READ_INTERCHANGE_TRANSACTION
	(
	p_TRANSACTION_ID IN NUMBER,
	p_VIEW_BEGIN IN DATE,
	p_VIEW_END IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TRANSACTION_NAME OUT VARCHAR,
	p_TRANSACTION_ALIAS OUT VARCHAR,
	p_TRANSACTION_DESC OUT VARCHAR,
	p_TRANSACTION_TYPE OUT VARCHAR,
	p_TRANSACTION_IDENTIFIER OUT VARCHAR,
	p_IS_FIRM OUT VARCHAR,
	p_IS_IMPORT_SCHEDULE OUT VARCHAR,
	p_IS_EXPORT_SCHEDULE OUT VARCHAR,
	p_TRANSACTION_STATUS OUT VARCHAR,
	p_TRANSACTION_INTERVAL OUT VARCHAR,
	p_BEGIN_DATE OUT DATE,
	p_END_DATE OUT DATE,
	p_PURCHASER OUT VARCHAR,
	p_SELLER OUT VARCHAR,
	p_CONTRACT OUT VARCHAR,
	p_SC OUT VARCHAR,
	p_POR OUT VARCHAR,
	p_POD OUT VARCHAR,
	p_COMMODITY OUT VARCHAR,
	p_SERVICE_TYPE OUT VARCHAR,
	p_COMMODITY_TYPE OUT VARCHAR,
	p_COMMODITY_UNIT OUT VARCHAR,
	p_COMMODITY_UNIT_FORMAT OUT VARCHAR,
	p_COMMODITY_PRICE_UNIT OUT VARCHAR,
	p_COMMODITY_PRICE_FORMAT OUT VARCHAR,
	p_TP_CONTRACT_NUM OUT VARCHAR,
	p_TP_CONTRACT_NAME OUT VARCHAR,
	p_STATUS OUT NUMBER
	) AS

-- Answer the singleton instance of the entity identified by the specified oid
-- Otherwise answer empty string values if the entity cannot be found

v_TRANSACTION INTERCHANGE_TRANSACTION%ROWTYPE;
v_COMMODITY IT_COMMODITY%ROWTYPE;
v_EMPTY_STRING VARCHAR(1) := ' ';

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

-- Select an existing record
	SELECT *
	INTO v_TRANSACTION
	FROM INTERCHANGE_TRANSACTION
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

-- Set the output parameters of the procedure
	p_TRANSACTION_NAME := v_TRANSACTION.TRANSACTION_NAME;
	p_TRANSACTION_ALIAS := v_TRANSACTION.TRANSACTION_ALIAS;
	p_TRANSACTION_DESC := v_TRANSACTION.TRANSACTION_DESC;
	p_TRANSACTION_TYPE := v_TRANSACTION.TRANSACTION_TYPE;
	p_TRANSACTION_IDENTIFIER := v_TRANSACTION.TRANSACTION_IDENTIFIER;
	SELECT DECODE(v_TRANSACTION.IS_FIRM,0,'No',1,'Yes','No') INTO p_IS_FIRM FROM DUAL;
	SELECT DECODE(v_TRANSACTION.IS_IMPORT_SCHEDULE,0,'No',1,'Yes','No') INTO p_IS_IMPORT_SCHEDULE FROM DUAL;
	SELECT DECODE(v_TRANSACTION.IS_EXPORT_SCHEDULE,0,'No',1,'Yes','No') INTO p_IS_EXPORT_SCHEDULE FROM DUAL;
	p_TRANSACTION_INTERVAL := v_TRANSACTION.TRANSACTION_INTERVAL;
	p_BEGIN_DATE := v_TRANSACTION.BEGIN_DATE;
	p_END_DATE := v_TRANSACTION.END_DATE;
	BEGIN
		SELECT TRANSACTION_STATUS_NAME
		INTO p_TRANSACTION_STATUS
		FROM IT_STATUS
		WHERE TRANSACTION_ID = p_TRANSACTION_ID
			AND AS_OF_DATE = IT_STATUS_AS_OF_DATE(TRANSACTION_ID, p_AS_OF_DATE);
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_TRANSACTION_STATUS := v_EMPTY_STRING;
	END;
	BEGIN
		SELECT PSE_NAME
		INTO p_PURCHASER
		FROM PURCHASING_SELLING_ENTITY
		WHERE PSE_ID = v_TRANSACTION.PURCHASER_ID;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_PURCHASER := v_EMPTY_STRING;
	END;
	BEGIN
		SELECT PSE_NAME
		INTO p_SELLER
		FROM PURCHASING_SELLING_ENTITY
		WHERE PSE_ID = v_TRANSACTION.SELLER_ID;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_SELLER := v_EMPTY_STRING;
	END;
	BEGIN
		SELECT CONTRACT_NAME
		INTO p_CONTRACT
		FROM INTERCHANGE_CONTRACT
		WHERE CONTRACT_ID = v_TRANSACTION.CONTRACT_ID;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_CONTRACT := v_EMPTY_STRING;
	END;
	BEGIN
		SELECT SC_NAME
		INTO p_SC
		FROM SCHEDULE_COORDINATOR
		WHERE SC_ID = v_TRANSACTION.SC_ID;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_SC := v_EMPTY_STRING;
	END;
	BEGIN
		SELECT SERVICE_TYPE_NAME
		INTO p_SERVICE_TYPE
		FROM TX_SERVICE_TYPE
		WHERE SERVICE_TYPE_ID = v_TRANSACTION.SERVICE_TYPE_ID;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_SERVICE_TYPE := v_EMPTY_STRING;
	END;
	BEGIN
		SELECT SERVICE_POINT_NAME
		INTO p_POR
		FROM SERVICE_POINT
		WHERE SERVICE_POINT_ID = v_TRANSACTION.POR_ID;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_POR := v_EMPTY_STRING;
	END;
	BEGIN
		SELECT SERVICE_POINT_NAME
		INTO p_POD
		FROM SERVICE_POINT
		WHERE SERVICE_POINT_ID = v_TRANSACTION.POD_ID;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_POD := v_EMPTY_STRING;
	END;
	BEGIN
		SELECT *
		INTO v_COMMODITY
		FROM IT_COMMODITY
		WHERE COMMODITY_ID = v_TRANSACTION.COMMODITY_ID;
		p_COMMODITY := v_COMMODITY.COMMODITY_NAME;
		p_COMMODITY_TYPE := NVL(v_COMMODITY.COMMODITY_TYPE,v_EMPTY_STRING);
		p_COMMODITY_UNIT := NVL(v_COMMODITY.COMMODITY_UNIT,v_EMPTY_STRING);
		p_COMMODITY_UNIT_FORMAT := NVL(v_COMMODITY.COMMODITY_UNIT_FORMAT,v_EMPTY_STRING);
		p_COMMODITY_PRICE_UNIT := NVL(v_COMMODITY.COMMODITY_PRICE_UNIT,v_EMPTY_STRING);
		p_COMMODITY_PRICE_FORMAT := NVL(v_COMMODITY.COMMODITY_PRICE_FORMAT,v_EMPTY_STRING);
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_COMMODITY := v_EMPTY_STRING;
			p_COMMODITY_TYPE := v_EMPTY_STRING;
			p_COMMODITY_UNIT := v_EMPTY_STRING;
			p_COMMODITY_UNIT_FORMAT := v_EMPTY_STRING;
			p_COMMODITY_PRICE_UNIT := v_EMPTY_STRING;
			p_COMMODITY_PRICE_FORMAT := v_EMPTY_STRING;
	END;
	BEGIN
		SELECT NVL(CONTRACT_NUMBER,v_EMPTY_STRING), NVL(CONTRACT_NAME,v_EMPTY_STRING)
		INTO p_TP_CONTRACT_NUM, p_TP_CONTRACT_NAME
		FROM TP_CONTRACT_NUMBER
		WHERE CONTRACT_ID = v_TRANSACTION.CONTRACT_ID
			AND p_VIEW_BEGIN BETWEEN BEGIN_DATE AND NVL(END_DATE, CONSTANTS.HIGH_DATE)
			AND ROWNUM = 1;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_TP_CONTRACT_NUM := v_EMPTY_STRING;
			p_TP_CONTRACT_NAME := v_EMPTY_STRING;
	END;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		p_TRANSACTION_NAME := v_EMPTY_STRING;
		p_TRANSACTION_ALIAS := v_EMPTY_STRING;
		p_TRANSACTION_DESC := v_EMPTY_STRING;
		p_TRANSACTION_TYPE := v_EMPTY_STRING;
		p_TRANSACTION_IDENTIFIER := v_EMPTY_STRING;
		p_IS_FIRM := v_EMPTY_STRING;
		p_IS_IMPORT_SCHEDULE := v_EMPTY_STRING;
		p_IS_EXPORT_SCHEDULE := v_EMPTY_STRING;
		p_TRANSACTION_STATUS := v_EMPTY_STRING;
		p_TRANSACTION_INTERVAL := v_EMPTY_STRING;
		p_BEGIN_DATE := TRUNC(SYSDATE);
		p_END_DATE := TRUNC(SYSDATE);
		p_PURCHASER := v_EMPTY_STRING;
		p_SELLER := v_EMPTY_STRING;
		p_CONTRACT := v_EMPTY_STRING;
		p_SC := v_EMPTY_STRING;
		p_POR := v_EMPTY_STRING;
		p_POD := v_EMPTY_STRING;
		p_COMMODITY := v_EMPTY_STRING;
		p_SERVICE_TYPE := v_EMPTY_STRING;
		p_COMMODITY_TYPE := v_EMPTY_STRING;
		p_COMMODITY_UNIT := v_EMPTY_STRING;
		p_COMMODITY_UNIT_FORMAT := v_EMPTY_STRING;
		p_COMMODITY_PRICE_UNIT := v_EMPTY_STRING;
		p_COMMODITY_PRICE_FORMAT := v_EMPTY_STRING;
		p_TP_CONTRACT_NUM := v_EMPTY_STRING;
		p_TP_CONTRACT_NAME := v_EMPTY_STRING;
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;

END READ_INTERCHANGE_TRANSACTION;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_IT_SCHEDULE_TO_WORK
	(
    p_WORK_ID IN NUMBER,
    p_WORK_SEQ IN NUMBER,
    p_TRANSACTION_ID IN NUMBER,
    p_WORK_DATE IN DATE,
    p_AMOUNT IN NUMBER,
    p_PRICE IN NUMBER,
    p_AMOUNT2 IN NUMBER DEFAULT NULL
    ) AS
v_AMOUNT VARCHAR2(16);
v_PRICE VARCHAR2(16);
v_AMOUNT2 VARCHAR2(16);
BEGIN
	v_AMOUNT := SUBSTR(TO_CHAR(NVL(p_AMOUNT,0),'999999999D999'),1,14);
	v_PRICE := SUBSTR(TO_CHAR(NVL(p_PRICE,0),'999999999D999'),1,14);
    IF p_AMOUNT2 IS NULL THEN
    	v_AMOUNT2 := NULL;
    ELSE
    	v_AMOUNT2 := SUBSTR(TO_CHAR(NVL(p_AMOUNT2,0),'999999999D999'),1,14);
	END IF;
	UT.POST_RTO_WORK(p_WORK_ID, p_WORK_SEQ, p_TRANSACTION_ID, p_WORK_DATE, v_AMOUNT||v_PRICE||v_AMOUNT2);
END PUT_IT_SCHEDULE_TO_WORK;
----------------------------------------------------------------------------------------------------
PROCEDURE SCHEDULE_FILL
	(
	p_TRANSACTION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_AMOUNT IN VARCHAR,
	p_PRICE IN VARCHAR,
	p_TEMPLATE IN VARCHAR,
	p_BEGIN_HOUR IN NUMBER,
	p_END_HOUR IN NUMBER,
	p_INCLUDE_HOLIDAYS IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATUS OUT NUMBER,
	p_TO_WORK IN NUMBER := 0,
	p_WORK_ID IN NUMBER := 0,
    p_USE_INTERVAL IN VARCHAR2 := NULL,
    p_AMOUNT2 IN NUMBER := NULL
	) AS

v_SCHEDULE_DATE DATE;
v_SCHEDULE_END_DATE DATE;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_TIME_ZONE VARCHAR(3);
v_DELETE BOOLEAN;
v_YES CHAR(1) := '1';
v_COUNT NUMBER;
v_AMOUNT NUMBER;
v_PRICE NUMBER;
v_INTERVAL VARCHAR(16);
v_TRANSACTION_TYPE INTERCHANGE_TRANSACTION.TRANSACTION_TYPE%TYPE;
v_CONTRACT_ID NUMBER;
v_SCHEDULE_TYPE NUMBER(9);
v_EDC_ID NUMBER(9);
v_DELETE_BEGIN_DATE DATE;
v_DELETE_END_DATE DATE;
v_DATA_LOCK_BEHAVIOR VARCHAR2(32);
BEGIN

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_TXN_UPDATE, p_TRANSACTION_ID, EC.ED_TRANSACTION);
	v_DATA_LOCK_BEHAVIOR :=  NVL(GET_DICTIONARY_VALUE('Data Locked Behavior', 0, 'Scheduling', 'Schedule Fill'),'Error');

	IF LOGS.IS_DEBUG_ENABLED() THEN
	    LOGS.LOG_DEBUG('TRANSACTION_ID=' || TO_CHAR(p_TRANSACTION_ID));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || UT.TRACE_DATE(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || UT.TRACE_DATE(p_END_DATE));
		LOGS.LOG_DEBUG('TIME_ZONE=' || p_TIME_ZONE);
		LOGS.LOG_DEBUG('AMOUNT=' || p_AMOUNT);
		LOGS.LOG_DEBUG('PRICE=' || p_PRICE);
		LOGS.LOG_DEBUG('TEMPLATE=' || p_TEMPLATE);
		LOGS.LOG_DEBUG('BEGIN_HOUR=' || TO_CHAR(p_BEGIN_HOUR));
		LOGS.LOG_DEBUG('END_HOUR=' || TO_CHAR(p_END_HOUR));
		LOGS.LOG_DEBUG('INCLUDE_HOLIDAYS=' || TO_CHAR(p_INCLUDE_HOLIDAYS));
	END IF;

	SELECT BEGIN_DATE,END_DATE,UPPER(TRIM(TRANSACTION_INTERVAL)),TRANSACTION_TYPE,CONTRACT_ID
	INTO v_BEGIN_DATE, v_END_DATE, v_INTERVAL, v_TRANSACTION_TYPE, v_CONTRACT_ID
	FROM INTERCHANGE_TRANSACTION
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;
    -- can only specify an interval when putting schedule to RTO_WORK - not to IT_SCHEDULE
    IF NVL(LENGTH(p_USE_INTERVAL),0) > 0 AND p_TO_WORK = 1 THEN
    	v_INTERVAL := UPPER(p_USE_INTERVAL);
    END IF;
	IF NVL(LENGTH(v_INTERVAL),0) = 0 THEN
		p_STATUS := -1;
		RETURN;
	END IF;
	p_STATUS := 0;
	IF p_BEGIN_DATE > v_END_DATE OR p_END_DATE < v_BEGIN_DATE THEN
		p_STATUS := -4;
		RETURN;
	END IF;
	v_AMOUNT := LTRIM(RTRIM(p_AMOUNT));
	v_PRICE := LTRIM(RTRIM(p_PRICE));
	v_TIME_ZONE := LTRIM(RTRIM(p_TIME_ZONE));
	v_SCHEDULE_DATE := TRUNC(GREATEST(p_BEGIN_DATE,v_BEGIN_DATE));
	v_SCHEDULE_END_DATE := TRUNC(LEAST(p_END_DATE,v_END_DATE));
	SELECT NVL(EDC_ID,0) INTO v_EDC_ID FROM INTERCHANGE_TRANSACTION WHERE TRANSACTION_ID = p_TRANSACTION_ID;

	IF GA.ENABLE_SUPPLY_SCHEDULE_TYPES THEN
		v_SCHEDULE_TYPE := p_SCHEDULE_TYPE;
	ELSE
		-- 'Retail Load' and 'Load' Schedules get types, others (supply schedules) get zero
		SELECT DECODE(UPPER(SUBSTR(v_TRANSACTION_TYPE,1,2)),'RE',p_SCHEDULE_TYPE,'LO',p_SCHEDULE_TYPE,0) INTO v_SCHEDULE_TYPE FROM DUAL;
	END IF;

	-- Verify that the whole date range is unlocked.
	DECLARE
		v_VERIFY_BEGIN DATE;
		v_VERIFY_END DATE;
		v_CRITERIA UT.STRING_MAP;
	BEGIN
		IF INTERVAL_IS_ATLEAST_DAILY(v_INTERVAL) THEN
			v_VERIFY_BEGIN := v_SCHEDULE_DATE + 1/86400;
			v_VERIFY_END := v_SCHEDULE_END_DATE + 1/86400;
		ELSE
			UT.CUT_DATE_RANGE(v_SCHEDULE_DATE, v_SCHEDULE_END_DATE, v_TIME_ZONE, v_VERIFY_BEGIN, v_VERIFY_END);
		END IF;
		v_CRITERIA('SCHEDULE_TYPE') := v_SCHEDULE_TYPE;
		v_CRITERIA('SCHEDULE_STATE') := CONSTANTS.INTERNAL_STATE;
		DATA_LOCK.VERIFY_DATA_IS_UNLOCKED(ENTITY_UTIL.TABLE_ID_FOR_DB_TABLE('IT_SCHEDULE'), p_TRANSACTION_ID, v_VERIFY_BEGIN, v_VERIFY_END, v_CRITERIA);
	EXCEPTION
		WHEN MSGCODES.e_ERR_DATA_LOCKED THEN
			DATA_LOCK.HANDLE_DATA_LOCKED_EXCEPTION(v_DATA_LOCK_BEHAVIOR);
	END;

	-- Delete any existing records if the option is specified.
	v_DELETE := SUBSTR(p_TEMPLATE,14,1) = v_YES;
	IF v_DELETE AND NVL(p_TO_WORK, 0) = 0 THEN
		IF v_INTERVAL IN ('DAY','WEEK','MONTH','QUARTER','YEAR') THEN
			IF v_INTERVAL = 'MONTH' THEN
				v_DELETE_BEGIN_DATE := ADD_SECONDS_TO_DATE(TRUNC(v_SCHEDULE_DATE,'MONTH'), 1);
			ELSIF v_INTERVAL = 'QUARTER' THEN
				v_DELETE_BEGIN_DATE := ADD_SECONDS_TO_DATE(TRUNC(v_SCHEDULE_DATE,'Q'), 1);
			ELSIF v_INTERVAL = 'YEAR' THEN
				v_DELETE_BEGIN_DATE := ADD_SECONDS_TO_DATE(TRUNC(v_SCHEDULE_DATE,'YEAR'), 1);
			ELSIF v_INTERVAL = 'WEEK' THEN
				v_DELETE_BEGIN_DATE := ADD_SECONDS_TO_DATE(TRUNC(v_SCHEDULE_DATE,'DY'), 1);
			ELSE
				v_DELETE_BEGIN_DATE := ADD_SECONDS_TO_DATE(TRUNC(v_SCHEDULE_DATE), 1);
			END IF;
		ELSE
			v_DELETE_BEGIN_DATE := ADVANCE_DATE(v_SCHEDULE_DATE, v_INTERVAL);
			v_DELETE_BEGIN_DATE := TO_CUT(v_DELETE_BEGIN_DATE, p_TIME_ZONE);
			v_DELETE_END_DATE := TO_CUT(v_SCHEDULE_END_DATE, p_TIME_ZONE);
		END IF;

		DELETE IT_SCHEDULE
		WHERE TRANSACTION_ID = p_TRANSACTION_ID
			AND SCHEDULE_TYPE = p_SCHEDULE_TYPE
			AND SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE
			AND SCHEDULE_DATE BETWEEN v_DELETE_BEGIN_DATE AND v_DELETE_END_DATE;
	END IF;

	FOR SCHEDULE_DATES IN (SELECT * FROM TABLE(CAST(SP.GET_SCHEDULE_DATES(v_SCHEDULE_DATE,
														v_SCHEDULE_END_DATE,
														v_TIME_ZONE,
														p_TEMPLATE,
														p_BEGIN_HOUR,
														p_END_HOUR,
														p_INCLUDE_HOLIDAYS,
														v_INTERVAL) AS DATE_COLLECTION)))
	LOOP
		IF p_TO_WORK = 1 THEN
			PUT_IT_SCHEDULE_TO_WORK(p_WORK_ID, v_COUNT, p_TRANSACTION_ID, SCHEDULE_DATES.COLUMN_VALUE, v_AMOUNT, v_PRICE, p_AMOUNT2);
		ELSE
			BEGIN
				PUT_IT_SCHEDULE(p_TRANSACTION_ID, v_SCHEDULE_TYPE, SCHEDULE_DATES.COLUMN_VALUE, p_AS_OF_DATE, v_AMOUNT, v_PRICE, p_STATUS);
			EXCEPTION
				WHEN MSGCODES.e_ERR_DATA_LOCKED THEN
					DATA_LOCK.HANDLE_DATA_LOCKED_EXCEPTION(v_DATA_LOCK_BEHAVIOR);
			END;
		END IF;
	END LOOP;
	-- update storage schedule if necessary
	IF v_TRANSACTION_TYPE IN ('Injection','Withdrawal') AND v_INTERVAL = 'DAY' THEN
		CALC_STORAGE_SCHEDULE(p_BEGIN_DATE, p_SCHEDULE_TYPE, CONSTANTS.LOW_DATE, v_CONTRACT_ID);
	END IF;
END SCHEDULE_FILL;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SCHEDULE_FILL_RECORDS
	(
	p_TRANSACTION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_AMOUNT IN VARCHAR,
	p_PRICE IN VARCHAR,
	p_TEMPLATE IN VARCHAR,
	p_BEGIN_HOUR IN NUMBER,
	p_END_HOUR IN NUMBER,
	p_INCLUDE_HOLIDAYS IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_WORK_ID NUMBER;
v_FMT VARCHAR2(8);
BEGIN
	UT.GET_RTO_WORK_ID(v_WORK_ID);

	p_STATUS := GA.SUCCESS;

	SCHEDULE_FILL (p_TRANSACTION_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE, p_AMOUNT, p_PRICE, p_TEMPLATE,
			   p_BEGIN_HOUR, p_END_HOUR, p_INCLUDE_HOLIDAYS, p_SCHEDULE_TYPE, p_STATUS, 1, v_WORK_ID);
	IF p_STATUS < 0 THEN
		NULL_CURSOR(p_CURSOR);
		RETURN;
	END IF;

	SELECT DECODE(UPPER(SUBSTR(TRANSACTION_INTERVAL,1,2)),'5 ','MI5','10','MI5','15','MI5','20','MI5','30','MI5','HO','HH','DA','DD','WE','DD','MO','DD','QU','DD','YE','DD')
    INTO v_FMT
    FROM INTERCHANGE_TRANSACTION
    WHERE TRANSACTION_ID = p_TRANSACTION_ID;

	OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(WORK_DATE,p_TIME_ZONE,v_FMT) "DATE",
			SUBSTR(WORK_DATA,1,14) "AMOUNT"
		FROM RTO_WORK
		WHERE WORK_ID = v_WORK_ID
		ORDER BY 1;

	UT.PURGE_RTO_WORK(v_WORK_ID);

	EXCEPTION
		WHEN OTHERS THEN
			BEGIN
				UT.PURGE_RTO_WORK(v_WORK_ID);
			EXCEPTION
				WHEN OTHERS THEN
					ERRS.LOG_AND_CONTINUE();
			END;
			ERRS.LOG_AND_RAISE();

END GET_SCHEDULE_FILL_RECORDS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_IT_SCHEDULE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SCHEDULE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_AMOUNT IN NUMBER,
	p_PRICE IN NUMBER,
	p_STATUS OUT NUMBER
	) AS
v_AS_OF_DATE DATE;
BEGIN

	p_STATUS := GA.SUCCESS;
	IF GA.VERSION_SCHEDULE THEN
		v_AS_OF_DATE := CORRECTED_AS_OF_DATE(p_AS_OF_DATE);
	ELSE
		v_AS_OF_DATE := CONSTANTS.LOW_DATE;
	END IF;

	IF p_AMOUNT IS NOT NULL OR p_PRICE IS NOT NULL THEN
		UPDATE IT_SCHEDULE SET
			AMOUNT = NVL(p_AMOUNT, AMOUNT),
			PRICE = NVL(p_PRICE, PRICE)
		WHERE TRANSACTION_ID = p_TRANSACTION_ID
			AND SCHEDULE_TYPE = p_SCHEDULE_TYPE
			AND SCHEDULE_STATE = DECODE(p_SCHEDULE_STATE,2,2,1)
			AND SCHEDULE_DATE = p_SCHEDULE_DATE
			AND AS_OF_DATE = v_AS_OF_DATE;
		IF SQL%NOTFOUND THEN
			INSERT INTO IT_SCHEDULE (
				TRANSACTION_ID,
				SCHEDULE_TYPE,
				SCHEDULE_STATE,
				SCHEDULE_DATE,
				AS_OF_DATE,
				AMOUNT,
				PRICE)
			VALUES (
				p_TRANSACTION_ID,
				p_SCHEDULE_TYPE,
				DECODE(p_SCHEDULE_STATE,2,2,1),
				p_SCHEDULE_DATE,
				v_AS_OF_DATE,
				p_AMOUNT,
				p_PRICE);
		END IF;
	END IF;


END PUT_IT_SCHEDULE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_IT_SCHEDULE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_AMOUNT IN NUMBER,
	p_PRICE IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

BEGIN
	PUT_IT_SCHEDULE(p_TRANSACTION_ID, p_SCHEDULE_TYPE, CONSTANTS.INTERNAL_STATE, p_SCHEDULE_DATE, p_AS_OF_DATE, p_AMOUNT, p_PRICE, p_STATUS);
END PUT_IT_SCHEDULE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_IT_SCHEDULE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SCHEDULE_DATES   IN DATE_COLLECTION,
	p_SCHEDULE_AMOUNTS IN NUMBER_COLLECTION,
	p_SCHEDULE_PRICES  IN NUMBER_COLLECTION := NULL,
	p_AS_OF_DATE IN DATE := NULL,
	p_TIME_ZONE IN VARCHAR := NULL
	) AS
v_SCHEDULE_TYPE NUMBER;
v_TRANSACTION_TYPE INTERCHANGE_TRANSACTION.TRANSACTION_TYPE%TYPE;
v_INTERVAL INTERCHANGE_TRANSACTION.TRANSACTION_INTERVAL%TYPE;
v_CONTRACT_ID NUMBER;
v_BEGIN_DATE DATE := CONSTANTS.HIGH_DATE;
v_AS_OF_DATE DATE;
v_SCHEDULE_PRICES NUMBER_COLLECTION;
BEGIN
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_TXN_UPDATE, p_TRANSACTION_ID, EC.ED_TRANSACTION);

	ASSERT(p_SCHEDULE_DATES IS NOT NULL, 'The Dates list must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_SCHEDULE_AMOUNTS IS NOT NULL, 'The Amounts list must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_SCHEDULE_DATES.COUNT = p_SCHEDULE_AMOUNTS.COUNT,
		'The date and amount lists must be of the same size.', MSGCODES.c_ERR_ARGUMENT);

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('SCHEDULE_DATES = ' || TEXT_UTIL.TO_CHAR_TIME_LIST(p_SCHEDULE_DATES));
		LOGS.LOG_DEBUG('SCHEDULE_AMOUNTS = ' || TEXT_UTIL.TO_CHAR_NUMBER_LIST(p_SCHEDULE_AMOUNTS));
	END IF;

	-- Get Transaction Type, Interval, and Contract Id of the TXN
	-- Used to determine if this Transaction requires additional processing
	SELECT TRANSACTION_TYPE, UPPER(TRANSACTION_INTERVAL), CONTRACT_ID
	INTO v_TRANSACTION_TYPE, v_INTERVAL, v_CONTRACT_ID
	FROM INTERCHANGE_TRANSACTION
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

	IF GA.ENABLE_SUPPLY_SCHEDULE_TYPES THEN
		v_SCHEDULE_TYPE := p_SCHEDULE_TYPE;
	ELSE
		-- 'Retail Load' and 'Load' Schedules get types, others (supply schedules) get zero
		IF UPPER(SUBSTR(v_TRANSACTION_TYPE,1,2)) IN ('RE','LO') THEN
			v_SCHEDULE_TYPE := p_SCHEDULE_TYPE;
		ELSE
			v_SCHEDULE_TYPE := 0;
		END IF;
	END IF;

	-- AS_OF_DATE is optional, default is SYSDATE
	IF GA.VERSION_SCHEDULE THEN
		v_AS_OF_DATE := NVL(CORRECTED_AS_OF_DATE(p_AS_OF_DATE), SYSDATE);
	ELSE
		v_AS_OF_DATE := CONSTANTS.LOW_DATE;
	END IF;

	-- PRICES are optional, default is a list of null prices
	IF p_SCHEDULE_PRICES IS NULL THEN
		v_SCHEDULE_PRICES := UT.NEW_NUMBER_COLLECTION(p_SCHEDULE_DATES.COUNT(), NULL);
	ELSE
		ASSERT(p_SCHEDULE_DATES.COUNT = p_SCHEDULE_AMOUNTS.COUNT AND p_SCHEDULE_AMOUNTS.COUNT = p_SCHEDULE_PRICES.COUNT,
			'The date, amount, and price lists must be of the same size.', MSGCODES.c_ERR_ARGUMENT);
		v_SCHEDULE_PRICES := p_SCHEDULE_PRICES;
	END IF;

	-- INSERT or UPDATE IT_SCHEDULE
	FORALL v_IDX IN p_SCHEDULE_DATES.FIRST..p_SCHEDULE_DATES.LAST
		MERGE INTO IT_SCHEDULE TGT
		USING (SELECT p_TRANSACTION_ID AS TRANSACTION_ID,
					  v_SCHEDULE_TYPE AS SCHEDULE_TYPE,
					  p_SCHEDULE_STATE AS SCHEDULE_STATE,
					  v_AS_OF_DATE AS AS_OF_DATE,
					  CASE WHEN p_TIME_ZONE IS NULL THEN p_SCHEDULE_DATES(v_IDX) ELSE TO_CUT(p_SCHEDULE_DATES(v_IDX), p_TIME_ZONE) END AS SCHEDULE_DATE,
					  p_SCHEDULE_AMOUNTS(v_IDX) AS AMOUNT,
					  v_SCHEDULE_PRICES(v_IDX) AS PRICE
			   FROM DUAL) SRC
		ON (TGT.TRANSACTION_ID = SRC.TRANSACTION_ID
		AND TGT.SCHEDULE_TYPE = SRC.SCHEDULE_TYPE
		AND TGT.SCHEDULE_STATE = SRC.SCHEDULE_STATE
		AND TGT.SCHEDULE_DATE = SRC.SCHEDULE_DATE
		AND TGT.AS_OF_DATE = SRC.AS_OF_DATE)
		WHEN MATCHED
		THEN
		UPDATE
		SET TGT.AMOUNT = NVL(SRC.AMOUNT, TGT.AMOUNT),
			TGT.PRICE = NVL(SRC.PRICE, TGT.PRICE)
		WHEN NOT MATCHED
		THEN
		INSERT (TGT.TRANSACTION_ID, TGT.SCHEDULE_TYPE, TGT.SCHEDULE_STATE, TGT.SCHEDULE_DATE, TGT.AS_OF_DATE, TGT.AMOUNT, TGT.PRICE)
		VALUES (SRC.TRANSACTION_ID, SRC.SCHEDULE_TYPE, SRC.SCHEDULE_STATE, SRC.SCHEDULE_DATE, SRC.AS_OF_DATE, SRC.AMOUNT, SRC.PRICE);


	-- Additional Processing:
	-- Update storage schedule if necessary
	IF v_TRANSACTION_TYPE IN ('Injection','Withdrawal') AND v_INTERVAL = 'DAY' THEN
		-- Determine Begin Date
		FOR v_INDEX IN p_SCHEDULE_DATES.FIRST..p_SCHEDULE_DATES.LAST LOOP
				-- and use it to keep track of earliest schedule update date
				IF p_SCHEDULE_DATES(v_INDEX) < v_BEGIN_DATE THEN
					v_BEGIN_DATE := p_SCHEDULE_DATES(v_INDEX);
				END IF;
		END LOOP;
		CALC_STORAGE_SCHEDULE(v_BEGIN_DATE, p_SCHEDULE_TYPE, CONSTANTS.LOW_DATE, v_CONTRACT_ID);
	END IF;
END PUT_IT_SCHEDULE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_IT_SCHEDULES
	(
	p_TRANSACTION_IDS IN NUMBER_COLLECTION,
	p_SCHEDULE_TYPES IN NUMBER_COLLECTION,
	p_SCHEDULE_STATES IN NUMBER_COLLECTION,
	p_SCHEDULE_DATES   IN DATE_COLLECTION_COLLECTION,
	p_SCHEDULE_AMOUNTS IN NUMBER_COLLECTION_COLLECTION,
	p_SCHEDULE_PRICES  IN NUMBER_COLLECTION_COLLECTION := NULL,
	p_AS_OF_DATES IN DATE_COLLECTION := NULL,
	p_TIME_ZONES IN STRING_COLLECTION := NULL
	) AS
BEGIN

	FOR v_IDX IN p_TRANSACTION_IDS.FIRST..p_TRANSACTION_IDS.LAST LOOP
		PUT_IT_SCHEDULE(p_TRANSACTION_IDS(v_IDX),
			p_SCHEDULE_TYPES(v_IDX),
			p_SCHEDULE_STATES(v_IDX),
			p_SCHEDULE_DATES(v_IDX),
			p_SCHEDULE_AMOUNTS(v_IDX),
			CASE WHEN p_SCHEDULE_PRICES IS NULL THEN NULL ELSE p_SCHEDULE_PRICES(v_IDX) END,
			CASE WHEN p_AS_OF_DATES IS NULL THEN NULL ELSE p_AS_OF_DATES(v_IDX) END,
			CASE WHEN p_TIME_ZONES IS NULL THEN NULL ELSE p_TIME_ZONES(v_IDX) END);
	END LOOP;

END PUT_IT_SCHEDULES;
----------------------------------------------------------------------------------------------------
PROCEDURE SCHEDULE_MANAGEMENT_IMPORT
	(
	p_SCHEDULE_IDS          IN STRING_COLLECTION,
	p_DATASOURCES 			IN STRING_COLLECTION,
	p_SCHEDULE_DATES        IN DATE_COLLECTION_COLLECTION,
	p_SCHEDULE_AMOUNTS      IN NUMBER_COLLECTION_COLLECTION,
	p_MESSAGE				OUT VARCHAR2
	) AS
v_STATUS NUMBER;
v_COUNT NUMBER := 0;
v_SCHEDULE_ID IT_SCHEDULE_MANAGEMENT_MAP.SCHED_MGMT_CID%TYPE;
v_DATASOURCE IT_SCHEDULE_MANAGEMENT_MAP.SCHED_MGMT_DATA_SOURCE%TYPE;
v_TRANSACTION_ID IT_SCHEDULE.TRANSACTION_ID%TYPE;
v_SCHEDULE_TYPE IT_SCHEDULE.SCHEDULE_TYPE%TYPE;
v_SCHEDULE_STATE IT_SCHEDULE.SCHEDULE_STATE%TYPE;
BEGIN
	LOGS.START_PROCESS('Schedule Management Import');

	ASSERT(p_SCHEDULE_IDS IS NOT NULL, 'The Schedule Id list must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_DATASOURCES IS NOT NULL, 'The Datasource list must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_SCHEDULE_DATES IS NOT NULL, 'The Dates list must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_SCHEDULE_AMOUNTS IS NOT NULL, 'The Amounts list must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_SCHEDULE_IDS.COUNT = p_DATASOURCES.COUNT AND p_DATASOURCES.COUNT = p_SCHEDULE_DATES.COUNT
		AND p_SCHEDULE_DATES.COUNT = p_SCHEDULE_AMOUNTS.COUNT,
		'The schedule id, datasource, date, and amount lists must be of the same size.', MSGCODES.c_ERR_ARGUMENT);

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('SCHEDULE_IDS = ' || TEXT_UTIL.TO_CHAR_STRING_LIST(p_SCHEDULE_IDS));
		LOGS.LOG_DEBUG('DATASOURCES = ' || TEXT_UTIL.TO_CHAR_STRING_LIST(p_DATASOURCES));
		LOGS.LOG_DEBUG('SCHEDULE_DATES = ' || TEXT_UTIL.TO_CHAR_2D_TIME_LIST(p_SCHEDULE_DATES));
		LOGS.LOG_DEBUG('SCHEDULE_AMOUNTS = ' || TEXT_UTIL.TO_CHAR_2D_NUMBER_LIST(p_SCHEDULE_AMOUNTS));
	END IF;

	LOGS.INIT_PROCESS_PROGRESS(p_TOTAL_WORK => p_SCHEDULE_IDS.COUNT(),
		p_WORK_UNITS => 'Schedules',
		p_CAN_TERMINATE => TRUE);

	FOR v_IDX IN p_SCHEDULE_IDS.FIRST..p_SCHEDULE_IDS.LAST LOOP
		v_SCHEDULE_ID := p_SCHEDULE_IDS(v_IDX);
		v_DATASOURCE := p_DATASOURCES(v_IDX);

		LOGS.LOG_DEBUG('Processing Schedule Import for: '||
					'Schedule Id = ' || v_SCHEDULE_ID ||
					', Datasource = ' || v_DATASOURCE);

		BEGIN
			SELECT M.TRANSACTION_ID, M.STATEMENT_TYPE_ID, M.SCHEDULE_STATE
			INTO v_TRANSACTION_ID, v_SCHEDULE_TYPE, v_SCHEDULE_STATE
			FROM IT_SCHEDULE_MANAGEMENT_MAP M
			WHERE M.SCHED_MGMT_CID = v_SCHEDULE_ID
			  AND M.SCHED_MGMT_DATA_SOURCE = v_DATASOURCE;

			LOGS.LOG_DEBUG('Found Mapping to: '||
					'Transaction Id = ' || TEXT_UTIL.TO_CHAR_ENTITY(v_TRANSACTION_ID, EC.ED_TRANSACTION) ||
					', Schedule Type = ' || TEXT_UTIL.TO_CHAR_ENTITY(v_SCHEDULE_TYPE, EC.ED_STATEMENT_TYPE) ||
					', Statement State = ' || v_SCHEDULE_STATE);

			BEGIN
				PUT_IT_SCHEDULE(v_TRANSACTION_ID,
					v_SCHEDULE_TYPE,
					v_SCHEDULE_STATE,
					p_SCHEDULE_DATES(v_IDX),
					p_SCHEDULE_AMOUNTS(v_IDX));

				v_COUNT := v_COUNT + 1;
			EXCEPTION
				WHEN OTHERS THEN
					ERRS.LOG_AND_CONTINUE('Error occurred updating the schedule for Transaction = ' || TEXT_UTIL.TO_CHAR_ENTITY(v_TRANSACTION_ID, EC.ED_TRANSACTION));
			END;
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				ERRS.LOG_AND_CONTINUE('Could not find a IT_SCHEDULE_MANAGEMENT_MAP for: '||
					'Schedule Id = ' || v_SCHEDULE_ID ||
					', Datasource = ' || v_DATASOURCE, LOGS.c_LEVEL_WARN);
		END;

		LOGS.INCREMENT_PROCESS_PROGRESS();
	END LOOP;

	p_MESSAGE := TO_CHAR(v_COUNT) || ' schedules successfully imported. ' ||
			TO_CHAR(p_SCHEDULE_AMOUNTS.COUNT - v_COUNT) || ' unknown schedules - not imported';

	LOGS.STOP_PROCESS(p_MESSAGE,v_STATUS);
EXCEPTION
	WHEN OTHERS THEN
		ERRS.ABORT_PROCESS();
END SCHEDULE_MANAGEMENT_IMPORT;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_IT_ASSIGNMENT_SCHEDULE
	(
	p_FROM_TRANSACTION_ID IN NUMBER,
	p_TO_TRANSACTION_ID IN NUMBER,
	p_ASSIGNMENT_TYPE IN VARCHAR2,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SCHEDULE_DATE IN DATE,
	p_AMOUNT IN NUMBER,
	p_PRICE IN NUMBER,
	p_STATUS OUT NUMBER,
	p_OPTION_ID IN NUMBER := GA.COMMITTED_OPTION_ID
	) AS
v_ASSIGNMENT_ID NUMBER;
BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	BEGIN
		SELECT ASSIGNMENT_ID
		INTO v_ASSIGNMENT_ID
		FROM IT_ASSIGNMENT
		WHERE FROM_TRANSACTION_ID = p_FROM_TRANSACTION_ID
			AND TO_TRANSACTION_ID = p_TO_TRANSACTION_ID
			AND ASSIGNMENT_TYPE = p_ASSIGNMENT_TYPE;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			SELECT OID.NEXTVAL INTO v_ASSIGNMENT_ID FROM DUAL;
			INSERT INTO IT_ASSIGNMENT
				(ASSIGNMENT_ID, TO_TRANSACTION_ID, FROM_TRANSACTION_ID,
				ASSIGNMENT_TYPE, ENTRY_DATE)
			VALUES
				(v_ASSIGNMENT_ID, p_TO_TRANSACTION_ID, p_FROM_TRANSACTION_ID,
				p_ASSIGNMENT_TYPE, SYSDATE);
	END;

	IF p_AMOUNT IS NOT NULL OR p_PRICE IS NOT NULL THEN
		UPDATE IT_ASSIGNMENT_SCHEDULE SET
			AMOUNT = NVL(p_AMOUNT, AMOUNT),
			PRICE = NVL(p_PRICE, PRICE),
			ENTRY_DATE = SYSDATE
		WHERE ASSIGNMENT_ID = v_ASSIGNMENT_ID
			AND OPTION_ID = p_OPTION_ID
			AND STATEMENT_TYPE_ID = p_SCHEDULE_TYPE
			AND SCHEDULE_STATE = DECODE(p_SCHEDULE_STATE,2,2,1)
			AND SCHEDULE_DATE = p_SCHEDULE_DATE;
		IF SQL%NOTFOUND THEN
			INSERT INTO IT_ASSIGNMENT_SCHEDULE (
				ASSIGNMENT_ID,
				OPTION_ID,
				STATEMENT_TYPE_ID,
				SCHEDULE_STATE,
				SCHEDULE_DATE,
				AMOUNT,
				PRICE,
				ENTRY_DATE)
			VALUES (
				v_ASSIGNMENT_ID,
				p_OPTION_ID,
				p_SCHEDULE_TYPE,
				DECODE(p_SCHEDULE_STATE,2,2,1),
				p_SCHEDULE_DATE,
				p_AMOUNT,
				p_PRICE,
				SYSDATE);
		END IF;
	END IF;


END PUT_IT_ASSIGNMENT_SCHEDULE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_IT_ASSIGNMENT_SCHEDULE
	(
	p_FROM_TRANSACTION_ID IN NUMBER,
	p_TO_TRANSACTION_ID IN NUMBER,
	p_ASSIGNMENT_TYPE IN VARCHAR2,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_DATE IN DATE,
	p_AMOUNT IN NUMBER,
	p_PRICE IN NUMBER,
	p_STATUS OUT NUMBER,
	p_OPTION_ID IN NUMBER := GA.COMMITTED_OPTION_ID
	) AS
BEGIN
	PUT_IT_ASSIGNMENT_SCHEDULE(p_FROM_TRANSACTION_ID, p_TO_TRANSACTION_ID, p_ASSIGNMENT_TYPE, p_SCHEDULE_TYPE, CONSTANTS.INTERNAL_STATE, p_SCHEDULE_DATE, p_AMOUNT, p_PRICE, p_STATUS, p_OPTION_ID);
END PUT_IT_ASSIGNMENT_SCHEDULE;
----------------------------------------------------------------------------------------------------
PROCEDURE COPY_IT_SCHEDULE
	(
	p_SRC_TRANSACTION_ID IN NUMBER,
	p_SRC_BEGIN_DATE IN DATE,
	p_SRC_END_DATE IN DATE,
	p_SRC_AS_OF_DATE IN DATE,
	p_SRC_SCHEDULE_TYPE IN NUMBER,
	p_SRC_SCHEDULE_STATE IN NUMBER,
	p_TRG_TRANSACTION_ID IN NUMBER,
	p_TRG_BEGIN_DATE IN DATE,
	p_TRG_END_DATE IN DATE,
	p_TRG_AS_OF_DATE IN DATE,
	p_TRG_SCHEDULE_TYPE IN NUMBER,
	p_TRG_SCHEDULE_STATE IN NUMBER,
	p_TRG_DELETE IN NUMBER,
	p_COPY_AMOUNT IN NUMBER,
	p_COPY_PRICE IN NUMBER,
	p_STATUS OUT NUMBER
	) AS
v_FIRST BOOLEAN;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_TRG_DATE DATE;
v_SRC_TRG_DIFF NUMBER;
v_SRC_BEGIN_END_DIFF NUMBER;
CURSOR c_SCHEDULE IS
	SELECT SCHEDULE_DATE,
		DECODE(p_COPY_AMOUNT,1,AMOUNT,NULL) "AMOUNT",
		DECODE(p_COPY_PRICE,1,PRICE,NULL) "PRICE"
	FROM IT_SCHEDULE
	WHERE TRANSACTION_ID = p_SRC_TRANSACTION_ID
		AND SCHEDULE_TYPE = p_SRC_SCHEDULE_TYPE
		AND SCHEDULE_STATE = p_SRC_SCHEDULE_STATE
		AND SCHEDULE_DATE BETWEEN p_SRC_BEGIN_DATE AND p_SRC_END_DATE
		AND AS_OF_DATE = SCHEDULE_AS_OF_DATE(TRANSACTION_ID, SCHEDULE_TYPE, SCHEDULE_STATE, SCHEDULE_DATE, p_SRC_AS_OF_DATE);
v_SCHEDULE c_SCHEDULE%ROWTYPE;

BEGIN
	p_STATUS := GA.SUCCESS;
	v_SRC_BEGIN_END_DIFF := p_SRC_END_DATE - p_SRC_BEGIN_DATE;
	v_TRG_DATE := p_TRG_BEGIN_DATE;
	v_BEGIN_DATE := p_TRG_BEGIN_DATE;
	v_END_DATE := p_TRG_BEGIN_DATE + v_SRC_BEGIN_END_DIFF;
	-- update target's begin and end dates to make sure they accomodate the new data
	UPDATE INTERCHANGE_TRANSACTION
	SET BEGIN_DATE = LEAST(BEGIN_DATE,TRUNC(p_TRG_BEGIN_DATE)),
		END_DATE = GREATEST(END_DATE,TRUNC(ADD_SECONDS_TO_DATE(p_TRG_END_DATE,-1)))
	WHERE TRANSACTION_ID = p_TRG_TRANSACTION_ID;
	-- loop through, auto-wrapping in case where target dates further apart than source dates
	WHILE v_BEGIN_DATE <= p_TRG_END_DATE LOOP
		-- update target/source delta for this iteration
		v_SRC_TRG_DIFF := v_BEGIN_DATE - p_SRC_BEGIN_DATE;
		v_FIRST := TRUE;
		OPEN c_SCHEDULE;
		LOOP
			IF v_FIRST THEN
				-- delete here, after cursor is opened, in case delete would wipe out
				-- entries we need for copy (in case of overlapping dates copied into
				-- the same schedule as source)
				IF p_TRG_DELETE = 1 THEN
					DECLARE
						v_TRG_END DATE;
					BEGIN
						SELECT LEAST(v_END_DATE,p_TRG_END_DATE) INTO v_TRG_END FROM DUAL;
						DELETE FROM IT_SCHEDULE
						WHERE TRANSACTION_ID = p_TRG_TRANSACTION_ID
							AND SCHEDULE_TYPE = p_TRG_SCHEDULE_TYPE
							AND SCHEDULE_STATE = p_TRG_SCHEDULE_STATE
							AND SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_TRG_END;
					END;
				END IF;
				v_FIRST := FALSE;
			END IF;
			FETCH c_SCHEDULE INTO v_SCHEDULE;
			EXIT WHEN c_SCHEDULE%NOTFOUND;
			v_TRG_DATE := v_SCHEDULE.SCHEDULE_DATE + v_SRC_TRG_DIFF;
			EXIT WHEN v_TRG_DATE > p_TRG_END_DATE;
			PUT_IT_SCHEDULE(p_TRG_TRANSACTION_ID, p_TRG_SCHEDULE_TYPE, p_TRG_SCHEDULE_STATE, v_TRG_DATE, p_TRG_AS_OF_DATE, v_SCHEDULE.AMOUNT, v_SCHEDULE.PRICE, p_STATUS);
			IF p_STATUS < 0 THEN
				ROLLBACK;
				RETURN;
			END IF;
		END LOOP;
		CLOSE c_SCHEDULE;
		-- set our dates for the next iteration/section
		v_BEGIN_DATE := ADD_SECONDS_TO_DATE(v_END_DATE,1);
		v_END_DATE := v_BEGIN_DATE + v_SRC_BEGIN_END_DIFF;
	END LOOP;

EXCEPTION
	WHEN OTHERS THEN
		ROLLBACK;
		p_STATUS := SQLCODE;
END COPY_IT_SCHEDULE;
----------------------------------------------------------------------------------------------------
PROCEDURE SCHEDULE_COPY
	(
	p_SRC_TRANSACTION_ID IN NUMBER,
	p_SRC_BEGIN_DATE IN DATE,
	p_SRC_END_DATE IN DATE,
	p_SRC_AS_OF_DATE IN DATE,
	p_SRC_SCHEDULE_TYPE IN NUMBER,
	p_SRC_EXTERNAL IN NUMBER,
	p_TRG_TRANSACTION_ID IN NUMBER,
	p_TRG_BEGIN_DATE IN DATE,
	p_TRG_END_DATE IN DATE,
	p_TRG_AS_OF_DATE IN DATE,
	p_TRG_SCHEDULE_TYPE IN NUMBER,
	p_TRG_EXTERNAL IN NUMBER,
	p_TRG_DELETE IN NUMBER,
	p_COPY_AMOUNT IN NUMBER,
	p_COPY_PRICE IN NUMBER,
	p_COPY_BID_OFFER_AMOUNT IN NUMBER,
	p_COPY_BID_OFFER_PRICE IN NUMBER,
	p_STATUS OUT NUMBER
	) AS
v_SRC_STATE NUMBER(1);
v_TRG_STATE NUMBER(1);
BEGIN

	SELECT DECODE(p_SRC_EXTERNAL,1,CONSTANTS.EXTERNAL_STATE,CONSTANTS.INTERNAL_STATE)
	INTO v_SRC_STATE FROM DUAL;
	SELECT DECODE(p_TRG_EXTERNAL,1,CONSTANTS.EXTERNAL_STATE,CONSTANTS.INTERNAL_STATE)
	INTO v_TRG_STATE FROM DUAL;

	COPY_IT_SCHEDULE (p_SRC_TRANSACTION_ID,p_SRC_BEGIN_DATE,p_SRC_END_DATE,
			p_SRC_AS_OF_DATE,p_SRC_SCHEDULE_TYPE,v_SRC_STATE,
			p_TRG_TRANSACTION_ID,p_TRG_BEGIN_DATE,p_TRG_END_DATE,
			p_TRG_AS_OF_DATE,p_TRG_SCHEDULE_TYPE,v_TRG_STATE,
			p_TRG_DELETE,p_COPY_AMOUNT,p_COPY_PRICE,p_STATUS);
	IF p_STATUS <> GA.SUCCESS THEN
		RETURN;
	END IF;

	BO.COPY_BIDS_AND_OFFERS(p_SRC_TRANSACTION_ID,p_SRC_BEGIN_DATE,p_SRC_END_DATE,v_SRC_STATE,
			p_TRG_TRANSACTION_ID,p_TRG_BEGIN_DATE,p_TRG_END_DATE,v_TRG_STATE,p_TRG_AS_OF_DATE,
			p_TRG_DELETE,p_COPY_BID_OFFER_AMOUNT,p_COPY_BID_OFFER_PRICE,p_STATUS);

EXCEPTION
	WHEN OTHERS THEN
		ROLLBACK;
		p_STATUS := SQLCODE;

END SCHEDULE_COPY;
----------------------------------------------------------------------------------------------------
PROCEDURE SCHEDULE_COPY_REQUEST
	(
	p_SRC_TRANSACTION_ID IN NUMBER,
	p_SRC_BEGIN_DATE IN DATE,
	p_SRC_END_DATE IN DATE,
	p_SRC_AS_OF_DATE IN DATE,
	p_SRC_SCHEDULE_TYPE IN NUMBER,
	p_SRC_EXTERNAL IN NUMBER,
    p_SRC_DATA_OPTIONS IN VARCHAR2,
	p_TRG_TRANSACTION_IDs IN VARCHAR2,
	p_TRG_BEGIN_DATE IN DATE,
	p_TRG_END_DATE IN DATE,
	p_TRG_AS_OF_DATE IN DATE,
	p_TRG_SCHEDULE_TYPE IN NUMBER,
	p_TRG_EXTERNAL IN NUMBER,
	p_TRG_DELETE IN NUMBER,
	p_TIME_ZONE IN CHAR,
	p_STATUS OUT NUMBER
	) AS

v_IDs_TABLE GA.STRING_TABLE;
v_SRC_BEGIN_DATE DATE;
v_SRC_END_DATE DATE;
v_TRG_BEGIN_DATE DATE;
v_TRG_END_DATE DATE;

v_DATA_OPTIONS_TABLE string_table;
v_DATA_OPTION string_type;
v_COPY_AMOUNT NUMBER(1) := 0;
v_COPY_PRICE NUMBER(1) := 0;
v_COPY_BID_OFFER_AMOUNT NUMBER(1) := 0;
v_COPY_BID_OFFER_PRICE NUMBER(1) := 0;

BEGIN
	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	ASSERT(p_TRG_TRANSACTION_IDs IS NOT NULL, 'At least one target transaction must be specified', MSGCODES.c_ERR_ARGUMENT);

	UT.CUT_DATE_RANGE (p_SRC_BEGIN_DATE, p_SRC_END_DATE, p_TIME_ZONE, v_SRC_BEGIN_DATE, v_SRC_END_DATE);
	UT.CUT_DATE_RANGE (p_TRG_BEGIN_DATE, p_TRG_END_DATE, p_TIME_ZONE, v_TRG_BEGIN_DATE, v_TRG_END_DATE);

	p_STATUS := GA.SUCCESS;
	UT.TOKENS_FROM_STRING(p_TRG_TRANSACTION_IDs, ';', v_IDs_TABLE);

    -- pbm - 11/17/2004 - Modified the api of this procedure to accept the Data Options as a
    --                    comma-delimited list, instead of individual numeric parameters. I preserved
    --                    the api of the private procedure SCHEDULE_COPY. The strings are converted to
    --                    numeric values that represent the data options and passed to that procedure.

    UT.STRING_TABLE_FROM_STRING(p_SRC_DATA_OPTIONS, ',', v_DATA_OPTIONS_TABLE);

    FOR v_COUNT IN 1..v_DATA_OPTIONS_TABLE.COUNT LOOP

        v_DATA_OPTION := v_DATA_OPTIONS_TABLE(v_COUNT);
        CASE v_DATA_OPTION.STRING_VAL
             WHEN 'Amount' THEN
                  v_COPY_AMOUNT := 1;
             WHEN 'Price' THEN
                  v_COPY_PRICE := 1;
             WHEN 'Bid/Offer Amount' THEN
                  v_COPY_BID_OFFER_AMOUNT := 1;
             WHEN 'Bid/Offer Price' THEN
                  v_COPY_BID_OFFER_PRICE := 1;
        END CASE;

    END LOOP;

	FOR v_INDEX IN v_IDs_TABLE.FIRST..v_IDs_TABLE.LAST LOOP
		SCHEDULE_COPY(p_SRC_TRANSACTION_ID, v_SRC_BEGIN_DATE, v_SRC_END_DATE, p_SRC_AS_OF_DATE, p_SRC_SCHEDULE_TYPE, p_SRC_EXTERNAL,
				v_IDs_TABLE(v_INDEX), v_TRG_BEGIN_DATE, v_TRG_END_DATE, p_TRG_AS_OF_DATE, p_TRG_SCHEDULE_TYPE, p_TRG_EXTERNAL, p_TRG_DELETE,
				v_COPY_AMOUNT, v_COPY_PRICE, v_COPY_BID_OFFER_AMOUNT, v_COPY_BID_OFFER_PRICE, p_STATUS);
	END LOOP;


END SCHEDULE_COPY_REQUEST;
----------------------------------------------------------------------------------------------------
PROCEDURE SCHEDULE_UPDATE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_DATE IN VARCHAR,
	p_TIME IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_AMOUNT IN VARCHAR,
	p_PRICE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_DO_ASSIGNMENT IN BOOLEAN := FALSE,
	p_ASSIGNED IN NUMBER := 0,
	p_TO_TRANSACTION_ID IN NUMBER := 0,
	p_ASSIGNMENT_TYPE IN VARCHAR2 := NULL
	) AS

v_AMOUNT NUMBER;
v_PRICE NUMBER;
v_ASSIGNED NUMBER;
v_CUT_DATE DATE;

BEGIN

	p_STATUS := GA.SUCCESS;

	IF TRIM(p_AMOUNT) IS NULL THEN
		v_AMOUNT := NULL;
	ELSE
		v_AMOUNT := TO_NUMBER(LTRIM(RTRIM(p_AMOUNT)));
	END IF;

	IF TRIM(p_PRICE) IS NULL THEN
		v_PRICE := NULL;
	ELSE
		v_PRICE := TO_NUMBER(LTRIM(RTRIM(p_PRICE)));
	END IF;

	IF TRIM(p_ASSIGNED) IS NULL THEN
		v_ASSIGNED := NULL;
	ELSE
		v_ASSIGNED := TO_NUMBER(LTRIM(RTRIM(p_ASSIGNED)));
	END IF;

	IF TRIM(p_TIME) IS NULL THEN
		v_CUT_DATE := FROM_HED(p_DATE, p_TIME);
	ELSE
		v_CUT_DATE := DATE_TIME_AS_CUT(p_DATE, p_TIME, p_TIME_ZONE);
	END IF;

	PUT_IT_SCHEDULE(p_TRANSACTION_ID, p_SCHEDULE_TYPE, p_SCHEDULE_STATE, v_CUT_DATE, p_AS_OF_DATE, v_AMOUNT, v_PRICE, p_STATUS);
	IF p_DO_ASSIGNMENT THEN
		PUT_IT_ASSIGNMENT_SCHEDULE(p_TRANSACTION_ID, p_TO_TRANSACTION_ID, p_ASSIGNMENT_TYPE, p_SCHEDULE_TYPE, p_SCHEDULE_STATE, v_CUT_DATE, v_ASSIGNED, v_PRICE, p_STATUS);
	END IF;


END SCHEDULE_UPDATE;
----------------------------------------------------------------------------------------------------
PROCEDURE SCHEDULE_UPDATE_REQUEST
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_ARGUMENTS IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_ARGUMENTS_TABLE GA.STRING_TABLE;
v_VALUES_TABLE GA.STRING_TABLE;
v_INDEX NUMBER;
v_SCHEDULE_TYPE NUMBER;
v_TRANSACTION_TYPE INTERCHANGE_TRANSACTION.TRANSACTION_TYPE%TYPE;
v_INTERVAL INTERCHANGE_TRANSACTION.TRANSACTION_INTERVAL%TYPE;
v_CONTRACT_ID NUMBER;
v_BEGIN_DATE DATE := CONSTANTS.HIGH_DATE;
v_DATE DATE;
BEGIN

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_TXN_UPDATE, p_TRANSACTION_ID, EC.ED_TRANSACTION);

	IF GA.ENABLE_SUPPLY_SCHEDULE_TYPES THEN
		v_SCHEDULE_TYPE := p_SCHEDULE_TYPE;
	ELSE
		-- 'Retail Load' and 'Load' Schedules get types, others (supply schedules) get zero
		SELECT DECODE(UPPER(SUBSTR(TRANSACTION_TYPE,1,2)),'RE',p_SCHEDULE_TYPE,'LO',p_SCHEDULE_TYPE,0)
		INTO v_SCHEDULE_TYPE
		FROM INTERCHANGE_TRANSACTION
		WHERE TRANSACTION_ID = p_TRANSACTION_ID;
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.TOKENS_FROM_STRING(p_ARGUMENTS, ';', v_ARGUMENTS_TABLE);

	SELECT TRANSACTION_TYPE, UPPER(TRANSACTION_INTERVAL), CONTRACT_ID
	INTO v_TRANSACTION_TYPE, v_INTERVAL, v_CONTRACT_ID
	FROM INTERCHANGE_TRANSACTION
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

	FOR v_INDEX IN v_ARGUMENTS_TABLE.FIRST..v_ARGUMENTS_TABLE.LAST LOOP
		IF LENGTH(v_ARGUMENTS_TABLE(v_INDEX)) > 0 THEN
			-- jbh - tab-separated - used to be comma-separated, but commas are used as decimal points
			-- with European number settings, so we need an unambiguous separator
			UT.TOKENS_FROM_STRING(v_ARGUMENTS_TABLE(v_INDEX), CHR(9), v_VALUES_TABLE);
			SCHEDULE_UPDATE(p_TRANSACTION_ID, v_SCHEDULE_TYPE, p_SCHEDULE_STATE, v_VALUES_TABLE(1), v_VALUES_TABLE(2),
				p_AS_OF_DATE, p_TIME_ZONE, v_VALUES_TABLE(3), v_VALUES_TABLE(4), p_STATUS);
			-- get day for this schedule
			v_DATE := TO_DATE(v_VALUES_TABLE(1),'YYYY-MM-DD');
			-- and use it to keep track of earliest schedule update date
			IF v_DATE < v_BEGIN_DATE THEN
				v_BEGIN_DATE := v_DATE;
			END IF;
		END IF;
	END LOOP;

	-- update storage schedule if necessary
	IF v_TRANSACTION_TYPE IN ('Injection','Withdrawal') AND v_INTERVAL = 'DAY' THEN
		CALC_STORAGE_SCHEDULE(v_BEGIN_DATE, p_SCHEDULE_TYPE, CONSTANTS.LOW_DATE, v_CONTRACT_ID);
	END IF;
END SCHEDULE_UPDATE_REQUEST;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_TRANSACTION_DATE_RANGE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	) AS

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	UPDATE INTERCHANGE_TRANSACTION SET
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(p_END_DATE),
		ENTRY_DATE = SYSDATE
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

END PUT_TRANSACTION_DATE_RANGE;
----------------------------------------------------------------------------------------------------
PROCEDURE SET_TRANSACTION_DATE_RANGE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	UPDATE INTERCHANGE_TRANSACTION SET
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		ENTRY_DATE = SYSDATE
	WHERE TRANSACTION_ID = p_TRANSACTION_ID
		AND TRUNC(p_BEGIN_DATE) < BEGIN_DATE;

	UPDATE INTERCHANGE_TRANSACTION SET
		END_DATE = TRUNC(p_END_DATE),
		ENTRY_DATE = SYSDATE
	WHERE TRANSACTION_ID = p_TRANSACTION_ID
		AND TRUNC(p_END_DATE) > END_DATE;


END SET_TRANSACTION_DATE_RANGE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_TRANSACTION_IDENTIFIER
	(
	p_TRANSACTION_ID IN NUMBER,
	p_TRANSACTION_IDENTIFIER IN VARCHAR
	) AS

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	UPDATE INTERCHANGE_TRANSACTION SET
		TRANSACTION_IDENTIFIER = p_TRANSACTION_IDENTIFIER,
		ENTRY_DATE = SYSDATE
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

END PUT_TRANSACTION_IDENTIFIER;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_TRANSACTION_COMMODITY
	(
	p_TRANSACTION_ID IN NUMBER,
	p_COMMODITY_NAME IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_COMMODITY_ID NUMBER;

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	ID.ID_FOR_COMMODITY(p_COMMODITY_NAME, FALSE, v_COMMODITY_ID);
	IF v_COMMODITY_ID > 0 THEN
		UPDATE INTERCHANGE_TRANSACTION SET
			COMMODITY_ID = v_COMMODITY_ID,
			ENTRY_DATE = SYSDATE
		WHERE TRANSACTION_ID = p_TRANSACTION_ID;
	END IF;


END PUT_TRANSACTION_COMMODITY;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_SCHEDULE_TEMPLATE
	(
	p_TEMPLATE_NAME IN VARCHAR,
	p_START_HOUR_END IN NUMBER,
	p_STOP_HOUR_END IN NUMBER,
	p_INTERIOR_PERIOD IN NUMBER,
	p_DAY_OF_WEEK IN VARCHAR,
	p_INCLUDE_HOLIDAYS IN NUMBER,
	p_TEMPLATE_ORDER IN NUMBER,
	p_OLD_TEMPLATE_NAME IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_START_HOUR_END NUMBER(2);
v_STOP_HOUR_END NUMBER(2);
v_TEMPLATE_TYPE SCHEDULE_TEMPLATE.TEMPLATE_TYPE%TYPE;

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	-- Cannot update a 'Special' Template Type
	BEGIN
		SELECT TEMPLATE_TYPE INTO v_TEMPLATE_TYPE
		FROM SCHEDULE_TEMPLATE
		WHERE TEMPLATE_NAME = p_TEMPLATE_NAME;

		ASSERT(v_TEMPLATE_TYPE <> 0, 'Cannot update ' || p_TEMPLATE_NAME || ' template.');
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			NULL;
	END;

		v_START_HOUR_END := GREATEST(LEAST(NVL(p_START_HOUR_END, 1), 24), 1);
		v_STOP_HOUR_END := GREATEST(LEAST(GREATEST(NVL(p_STOP_HOUR_END, 24), 1), 24), v_START_HOUR_END);

-- Try to update an existing record
		UPDATE SCHEDULE_TEMPLATE SET
			TEMPLATE_NAME = LTRIM(RTRIM(p_TEMPLATE_NAME)),
			START_HOUR_END = v_START_HOUR_END,
			STOP_HOUR_END = v_STOP_HOUR_END,
			INTERIOR_PERIOD = NVL(p_INTERIOR_PERIOD,1),
			DAY_OF_WEEK = LTRIM(RTRIM(NVL(p_DAY_OF_WEEK,'1111111'))),
			INCLUDE_HOLIDAYS = NVL(p_INCLUDE_HOLIDAYS,1),
			TEMPLATE_ORDER = NVL(p_TEMPLATE_ORDER,999)
		WHERE TEMPLATE_NAME = LTRIM(RTRIM(p_OLD_TEMPLATE_NAME));

-- If the previous update did not find a match, then insert a new record.

		IF SQL%NOTFOUND THEN
			INSERT INTO SCHEDULE_TEMPLATE (
				TEMPLATE_NAME,
				TEMPLATE_TYPE,
				START_HOUR_END,
				STOP_HOUR_END,
				INTERIOR_PERIOD,
				DAY_OF_WEEK,
				INCLUDE_HOLIDAYS,
				TEMPLATE_ORDER)
			VALUES (
				LTRIM(RTRIM(p_TEMPLATE_NAME)),
				1, -- All the templates created by the user are Persisted Template Types
				v_START_HOUR_END,
				v_STOP_HOUR_END,
				NVL(p_INTERIOR_PERIOD,1),
				LTRIM(RTRIM(NVL(p_DAY_OF_WEEK,'1111111'))),
				NVL(p_INCLUDE_HOLIDAYS,1),
				NVL(p_TEMPLATE_ORDER,999));
		END IF;


END PUT_SCHEDULE_TEMPLATE;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_TP_CONTRACT_NUMBER
	(
	p_CONTRACT_ID IN NUMBER,
	p_TP_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CONTRACT_NAME IN VARCHAR2,
	p_CONTRACT_NUMBER IN VARCHAR2,
	p_OLD_TP_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	)
	AS

CURSOR c_TP_CONTRACT_NUMBER IS
	SELECT *
	FROM TP_CONTRACT_NUMBER
	WHERE CONTRACT_ID = p_CONTRACT_ID
		AND TP_ID = p_TP_ID
	ORDER BY BEGIN_DATE DESC;

v_TP_CONTRACT_NUMBER TP_CONTRACT_NUMBER%ROWTYPE;
v_END_DATE DATE;
v_INITIAL BOOLEAN;

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

-- UPDATE THE CURRENT ACCOUNT PRODUCT ASSIGNMENT IF ONE EXISTS

	UPDATE TP_CONTRACT_NUMBER SET
		BEGIN_DATE = TRUNC(p_BEGIN_DATE),
		END_DATE = TRUNC(v_END_DATE),
		CONTRACT_NAME = p_CONTRACT_NAME,
		CONTRACT_NUMBER = p_CONTRACT_NUMBER,
		TP_ID = p_TP_ID,
		ENTRY_DATE = SYSDATE
	WHERE CONTRACT_ID = p_CONTRACT_ID
		AND TP_ID = p_OLD_TP_ID
		AND BEGIN_DATE = TRUNC(p_OLD_BEGIN_DATE);

-- NO ASSIGNMENT UPDATE FOR THIS ACCOUNT AND PRODUCT COMBINATION SO INSERT A NEW ASSIGNMENT

	IF SQL%NOTFOUND THEN
		INSERT INTO TP_CONTRACT_NUMBER
			(
			CONTRACT_ID,
			TP_ID,
			BEGIN_DATE,
			END_DATE,
			CONTRACT_NAME,
			CONTRACT_NUMBER,
			ENTRY_DATE
			)
		VALUES
			(
			p_CONTRACT_ID,
			p_TP_ID,
			TRUNC(p_BEGIN_DATE),
			TRUNC(v_END_DATE),
			p_CONTRACT_NAME,
			p_CONTRACT_NUMBER,
			SYSDATE
			);
	END IF;

	OPEN c_TP_CONTRACT_NUMBER;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_TP_CONTRACT_NUMBER INTO v_TP_CONTRACT_NUMBER;
		EXIT WHEN c_TP_CONTRACT_NUMBER%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_TP_CONTRACT_NUMBER.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE TP_CONTRACT_NUMBER
		SET END_DATE = GREATEST(v_END_DATE, v_TP_CONTRACT_NUMBER.BEGIN_DATE)
		WHERE CONTRACT_ID = v_TP_CONTRACT_NUMBER.CONTRACT_ID
			AND TP_ID = v_TP_CONTRACT_NUMBER.TP_ID
			AND BEGIN_DATE = v_TP_CONTRACT_NUMBER.BEGIN_DATE;
		v_END_DATE := v_TP_CONTRACT_NUMBER.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_TP_CONTRACT_NUMBER;


END PUT_TP_CONTRACT_NUMBER;
----------------------------------------------------------------------------------------------------
PROCEDURE IMPORT_EXPORT_TRANSACTION
	(
	p_OPERATION IN VARCHAR,
	p_TRANSACTION_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_VERSION_ID IN NUMBER,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

-- Handle an import or export request for transaction schedules.
-- This is a stub procedure that is installation dependent.
-- Operation is either "IMPORT" OR "EXPORT".

BEGIN

	IF (UPPER(SUBSTR(p_OPERATION,1,1)) = 'I' AND NOT CAN_WRITE(g_MODULE_NAME)) OR NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

    XS.IMPORT_EXPORT_TRANSACTION(p_OPERATION, p_TRANSACTION_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE, p_STATUS);


END IMPORT_EXPORT_TRANSACTION;
----------------------------------------------------------------------------------------------------
PROCEDURE IMPORT_EXPORT_NAMES
	(
	p_OPERATION IN VARCHAR,
	p_FORMAT IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the transaction names that have either their import or export flags set.
-- Operation is either "IMPORT" OR "EXPORT".
v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	IF UPPER(SUBSTR(p_OPERATION,1,1)) = 'I' THEN
		OPEN p_CURSOR FOR
			SELECT DISTINCT TRANSACTION_NAME, A.TRANSACTION_ID
			FROM INTERCHANGE_TRANSACTION A, IT_SCHEDULE B
			WHERE B.TRANSACTION_ID = A.TRANSACTION_ID
				AND SCHEDULE_TYPE = SCHEDULE_TYPE
				AND SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE
				AND SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND IS_IMPORT_SCHEDULE  = 1
			ORDER BY TRANSACTION_NAME;
	ELSIF UPPER(p_FORMAT) = 'ETAG' THEN
    	OPEN p_CURSOR FOR
			SELECT DISTINCT TRANSACTION_NAME, A.TRANSACTION_ID
			FROM INTERCHANGE_TRANSACTION A, IT_SCHEDULE B
			WHERE B.TRANSACTION_ID = A.TRANSACTION_ID
				AND SCHEDULE_TYPE= SCHEDULE_TYPE
				AND SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE
				AND SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND IS_EXPORT_SCHEDULE  = 1
				AND NOT ETAG_CODE = '?'
			ORDER BY TRANSACTION_NAME;
	ELSE
    	OPEN p_CURSOR FOR
	    	SELECT DISTINCT TRANSACTION_NAME, A.TRANSACTION_ID
			FROM INTERCHANGE_TRANSACTION A, IT_SCHEDULE B
			WHERE B.TRANSACTION_ID = A.TRANSACTION_ID
				AND SCHEDULE_TYPE= SCHEDULE_TYPE
				AND SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE
				AND SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND IS_EXPORT_SCHEDULE  = 1
			ORDER BY TRANSACTION_NAME;
	END IF;

END IMPORT_EXPORT_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE FILE_EXPORT_PJM_FORMAT
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- PJM file export request for transaction schedules.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_WORK_ID NUMBER;
v_SCHEDULE_DATE VARCHAR(32);
v_AMOUNT NUMBER;

CURSOR c_SCHEDULE IS
    SELECT FROM_CUT_AS_HED(SCHEDULE_DATE, p_TIME_ZONE), AMOUNT
	FROM IT_SCHEDULE
	WHERE TRANSACTION_ID = p_TRANSACTION_ID
		AND SCHEDULE_TYPE = p_SCHEDULE_TYPE
		AND SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE
		AND SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND AS_OF_DATE = SCHEDULE_AS_OF_DATE(TRANSACTION_ID, SCHEDULE_TYPE, SCHEDULE_STATE, SCHEDULE_DATE, p_AS_OF_DATE)
	ORDER BY 1;

BEGIN

	p_STATUS := GA.SUCCESS;

	UT.GET_RTO_WORK_ID(v_WORK_ID);
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	UT.POST_RTO_WORK(v_WORK_ID, 1, '*INTSCH*');
	UT.POST_RTO_WORK(v_WORK_ID, 2, GET_TP_CONTRACT_NUMBER(p_TRANSACTION_ID, TRUNC(p_BEGIN_DATE)));
	UT.POST_RTO_WORK(v_WORK_ID, 3, TO_CHAR(p_BEGIN_DATE, 'MM/DD/YYYY'));
	UT.POST_RTO_WORK(v_WORK_ID, 4, TO_CHAR(p_END_DATE, 'MM/DD/YYYY'));

	OPEN c_SCHEDULE;
	LOOP
	    FETCH c_SCHEDULE INTO v_SCHEDULE_DATE, v_AMOUNT;
		EXIT WHEN c_SCHEDULE%NOTFOUND;
	END LOOP;
	CLOSE c_SCHEDULE;


END FILE_EXPORT_PJM_FORMAT;
----------------------------------------------------------------------------------------------------
PROCEDURE FILE_EXPORT_MEC_FORMAT
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- MEC file export request for transaction schedules.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_WORK_ID NUMBER;
v_POD_ID NUMBER;
v_POR_ID NUMBER;
v_LINK_TRANSACTION_ID NUMBER;
v_SCHEDULE_DATE GA.DATE_TABLE;
v_POR_AMOUNT GA.NUMBER_TABLE;
v_POD_AMOUNT GA.NUMBER_TABLE;
v_INDEX BINARY_INTEGER;
v_POD_TOTAL NUMBER := 0;
v_POR_TOTAL NUMBER := 0;
v_COUNT PLS_INTEGER;
v_BUFFER VARCHAR(64);
v_TZ_BEGIN_DATE DATE;

CURSOR c_ENERGY IS
    SELECT SCHEDULE_DATE, AMOUNT
	FROM IT_SCHEDULE
	WHERE TRANSACTION_ID = p_TRANSACTION_ID
	    AND SCHEDULE_TYPE = p_SCHEDULE_TYPE
		AND SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE
		AND SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND AS_OF_DATE = SCHEDULE_AS_OF_DATE(TRANSACTION_ID, SCHEDULE_TYPE, SCHEDULE_STATE, SCHEDULE_DATE, p_AS_OF_DATE);

CURSOR c_LOSS IS
    SELECT SCHEDULE_DATE, AMOUNT
	FROM IT_SCHEDULE
	WHERE TRANSACTION_ID = v_LINK_TRANSACTION_ID
	    AND SCHEDULE_TYPE = p_SCHEDULE_TYPE
		AND SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE
		AND SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND AS_OF_DATE = SCHEDULE_AS_OF_DATE(TRANSACTION_ID, SCHEDULE_TYPE, SCHEDULE_STATE, SCHEDULE_DATE, p_AS_OF_DATE);

BEGIN

	p_STATUS := GA.SUCCESS;
	UT.GET_RTO_WORK_ID(v_WORK_ID);
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

    v_TZ_BEGIN_DATE := NEW_TIME(TRUNC(p_BEGIN_DATE),GA.CUT_TIME_ZONE,p_TIME_ZONE);

	SELECT POR_ID, POD_ID, LINK_TRANSACTION_ID
	INTO v_POR_ID, v_POD_ID, v_LINK_TRANSACTION_ID
	FROM INTERCHANGE_TRANSACTION
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

	IF LOGS.IS_DEBUG_ENABLED() THEN
		LOGS.LOG_DEBUG('FILE_EXPORT_MEC_FORMAT');
		LOGS.LOG_DEBUG('BEGIN_DATE=' || UT.TRACE_DATE(v_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || UT.TRACE_DATE(v_END_DATE));
		LOGS.LOG_DEBUG('WORK_ID=' || TO_CHAR(v_WORK_ID));
		LOGS.LOG_DEBUG('LINK_TRANSACTION_ID=' || TO_CHAR(v_LINK_TRANSACTION_ID));
		LOGS.LOG_DEBUG('POR_ID=' || TO_CHAR(v_POR_ID));
		LOGS.LOG_DEBUG('POD_ID=' || TO_CHAR(v_POD_ID));
	END IF;

	UT.POST_RTO_WORK(v_WORK_ID, 1, '*RETAIL*');
	UT.POST_RTO_WORK(v_WORK_ID, 2, TO_CHAR(p_BEGIN_DATE, 'MMDDYYYY'));
	UT.POST_RTO_WORK(v_WORK_ID, 3, GET_SERVICE_POINT_EDC_ALIAS(v_POD_ID));
	UT.POST_RTO_WORK(v_WORK_ID, 4, GET_SERVICE_POINT_NAME(v_POD_ID));
	SELECT COUNT(TRANSACTION_ID) INTO v_COUNT
	FROM INTERCHANGE_TRANSACTION
	WHERE LINK_TRANSACTION_ID = p_TRANSACTION_ID;
	v_BUFFER := STD_TIME_ZONE(p_TIME_ZONE);
	IF v_COUNT > 0 THEN
		v_BUFFER := v_BUFFER || '           LOSS  ';
	ELSE
		v_BUFFER := v_BUFFER || '           POR   ';
		IF v_LINK_TRANSACTION_ID <> 0 THEN
			v_BUFFER := v_BUFFER || '    POD';
		END IF;
	END IF;
	UT.POST_RTO_WORK(v_WORK_ID, 5, v_BUFFER);

	FOR v_ENERGY IN c_ENERGY LOOP
		v_INDEX := ROUND((v_ENERGY.SCHEDULE_DATE - v_TZ_BEGIN_DATE) / GA.HOUR_DIVISOR);
		v_SCHEDULE_DATE(v_INDEX) := v_ENERGY.SCHEDULE_DATE;
		v_POR_AMOUNT(v_INDEX) := v_ENERGY.AMOUNT;
		v_POD_AMOUNT(v_INDEX) := v_ENERGY.AMOUNT;
		v_POR_TOTAL := v_POR_TOTAL + v_ENERGY.AMOUNT;
	END LOOP;

	v_POD_TOTAL := v_POR_TOTAL;
	FOR v_LOSS IN c_LOSS LOOP
		v_INDEX := ROUND((v_LOSS.SCHEDULE_DATE - v_TZ_BEGIN_DATE) / GA.HOUR_DIVISOR);
        v_POR_AMOUNT(v_INDEX) := v_POD_AMOUNT(v_INDEX) + v_LOSS.AMOUNT;
		v_POR_TOTAL := v_POR_TOTAL + v_LOSS.AMOUNT;
	END LOOP;

 	IF v_SCHEDULE_DATE.COUNT > 0 THEN
		v_COUNT := 6;
        v_INDEX := v_SCHEDULE_DATE.FIRST;
		WHILE v_SCHEDULE_DATE.EXISTS(v_INDEX) LOOP
	    	v_BUFFER := RIGHT_JUSTIFY(SUBSTR(FROM_CUT_AS_HED(v_SCHEDULE_DATE(v_INDEX), p_TIME_ZONE),11,15),10) ||
		    	RIGHT_JUSTIFY(TO_CHAR(v_POR_AMOUNT(v_INDEX)),10);
			IF v_LINK_TRANSACTION_ID > 0 THEN
		    	v_BUFFER := v_BUFFER || RIGHT_JUSTIFY(TO_CHAR(v_POD_AMOUNT(v_INDEX)),10);
			END IF;
			UT.POST_RTO_WORK(v_WORK_ID, v_COUNT, v_BUFFER);
			v_COUNT := v_COUNT + 1;
			IF LOGS.IS_DEBUG_ENABLED() THEN
				LOGS.LOG_DEBUG(v_BUFFER);
			END IF;
            v_INDEX := v_SCHEDULE_DATE.NEXT(v_INDEX);
		END LOOP;
	END IF;

    v_BUFFER := 'TOT       ' || RIGHT_JUSTIFY(TO_CHAR(v_POR_TOTAL),10);
	IF v_LINK_TRANSACTION_ID > 0 THEN
	    v_BUFFER := v_BUFFER || RIGHT_JUSTIFY(TO_CHAR(v_POD_TOTAL),10);
	END IF;
	UT.POST_RTO_WORK(v_WORK_ID, v_COUNT, v_BUFFER);

	OPEN p_CURSOR FOR
	    SELECT WORK_DATA FROM RTO_WORK WHERE WORK_ID = v_WORK_ID ORDER BY WORK_SEQ;

	UT.PURGE_RTO_WORK(v_WORK_ID);

	EXCEPTION
		WHEN OTHERS THEN
			BEGIN
				UT.PURGE_RTO_WORK(v_WORK_ID);
			EXCEPTION
				WHEN OTHERS THEN
					ERRS.LOG_AND_CONTINUE();
			END;
			ERRS.LOG_AND_RAISE();

END FILE_EXPORT_MEC_FORMAT;
----------------------------------------------------------------------------------------------------
PROCEDURE FILE_EXPORT_REQUEST
	(
	p_FILE_FORMAT IN VARCHAR,
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Handle a file export request for transaction schedules.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	IF LOGS.IS_DEBUG_ENABLED() THEN
		LOGS.LOG_DEBUG('FILE_EXPORT_REQUEST');
		LOGS.LOG_DEBUG('FILE_FORMAT=' || p_FILE_FORMAT);
		LOGS.LOG_DEBUG('TRANSACTION_ID=' || TO_CHAR(p_TRANSACTION_ID));
		LOGS.LOG_DEBUG('SCHEDULE_TYPE=' || TO_CHAR(p_SCHEDULE_TYPE));
		LOGS.LOG_DEBUG('BEGIN_DATE =' || UT.TRACE_DATE(p_BEGIN_DATE ));
		LOGS.LOG_DEBUG('END_DATE =' || UT.TRACE_DATE(p_END_DATE ));
		LOGS.LOG_DEBUG('AS_OF_DATE =' || UT.TRACE_DATE(p_AS_OF_DATE ));
		LOGS.LOG_DEBUG('TIME_ZONE=' || p_TIME_ZONE);
		COMMIT;
	END IF;

	IF UPPER(SUBSTR(p_FILE_FORMAT,1,3)) = 'MEC' THEN
		FILE_EXPORT_MEC_FORMAT(p_TRANSACTION_ID, p_SCHEDULE_TYPE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE, p_STATUS, p_CURSOR);
	ELSE
		p_STATUS := -999;
		OPEN p_CURSOR FOR SELECT NULL FROM DUAL;
	END IF;


END FILE_EXPORT_REQUEST;
----------------------------------------------------------------------------------------------------
PROCEDURE PJM_EXPORT_DATA
	(
	p_TRANSACTION_IDS IN VARCHAR2,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_AS_OF_DATE IN DATE,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

v_FORECAST_SCHEDULE CONTRACT_SCHEDULE_TABLE := CONTRACT_SCHEDULE_TABLE();
--@@Begin Implementation Override --
v_BACKCAST_SCHEDULE CONTRACT_SCHEDULE_TABLE := CONTRACT_SCHEDULE_TABLE();
--@@End Implementation Override --
v_FINAL_SCHEDULE CONTRACT_SCHEDULE_TABLE := CONTRACT_SCHEDULE_TABLE();
v_DICT_VAL VARCHAR2(32);
v_AMOUNT NUMBER := 0;
v_INDEX BINARY_INTEGER;
v_SOMETHING_DONE BOOLEAN := FALSE;
v_USE_EXT_ID BOOLEAN := FALSE;

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

	v_USE_EXT_ID := NVL(MODEL_VALUE_AT_KEY(1, 'Scheduling', 'PJM Export', 'Use External ID') = '1',FALSE);

	p_STATUS := GA.SUCCESS;
	IF p_SCHEDULE_TYPE = 3 THEN
		GET_SCHEDULE(p_TRANSACTION_IDS, 1, CONSTANTS.INTERNAL_STATE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, 'EDT', v_FORECAST_SCHEDULE, CASE WHEN v_USE_EXT_ID THEN 0 ELSE 1 END, ',');
--@@Begin Implementation Override --
		GET_SCHEDULE(p_TRANSACTION_IDS, 2, CONSTANTS.INTERNAL_STATE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, 'EDT', v_BACKCAST_SCHEDULE, CASE WHEN v_USE_EXT_ID THEN 0 ELSE 1 END, ',');
--@@End Implementation Override --
		GET_SCHEDULE(p_TRANSACTION_IDS, 3, CONSTANTS.INTERNAL_STATE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, 'EDT', v_FINAL_SCHEDULE, CASE WHEN v_USE_EXT_ID THEN 0 ELSE 1 END, ',');
		IF LOGS.IS_DEBUG_ENABLED() THEN
			TRACE_SCHEDULE('FORECAST SCHEDULE', v_FORECAST_SCHEDULE);
			TRACE_SCHEDULE('FINAL SCHEDULE', v_FINAL_SCHEDULE);
		END IF;

		IF v_USE_EXT_ID THEN
			OPEN p_CURSOR FOR
				SELECT C.TRANSACTION_IDENTIFIER "CONTRACT_NUMBER", ROUND(SUM((A.SCHEDULE_VAL - B.SCHEDULE_VAL) * 1000)) "AMOUNT", TO_HED_AS_DATE(FROM_CUT(A.SCHEDULE_DATE, 'EDT')) "DATE"
				FROM TABLE(CAST(v_FORECAST_SCHEDULE AS CONTRACT_SCHEDULE_TABLE)) A,
					TABLE(CAST(v_FINAL_SCHEDULE AS CONTRACT_SCHEDULE_TABLE)) B,
				    INTERCHANGE_TRANSACTION C
				WHERE B.SCHEDULE_DATE = A.SCHEDULE_DATE
					AND B.CONTRACT_ID = A.CONTRACT_ID
					AND B.TRANSACTION_ID = A.TRANSACTION_ID
					AND C.TRANSACTION_ID = A.TRANSACTION_ID
				GROUP BY C.TRANSACTION_IDENTIFIER, TO_HED_AS_DATE(FROM_CUT(A.SCHEDULE_DATE, 'EDT'))
				ORDER BY 1,3;
		ELSE
			OPEN p_CURSOR FOR
--@@Begin Implementation Override --
            SELECT  C.CONTRACT_NUMBER, ROUND(SUM(A.SCHEDULE_VAL)*1000) AS "AMOUNT", TO_HED_AS_DATE(FROM_CUT(A.SCHEDULE_DATE, 'EDT')) "DATE"
                   FROM
                    (SELECT CONTRACT_ID, TRANSACTION_ID, SCHEDULE_DATE, DECODE(REC_TYPE, 'B', BACK_VAL, FORE_VAL) AS SCHEDULE_VAL
                      FROM
                      (SELECT CONTRACT_ID, TRANSACTION_ID, SCHEDULE_DATE, MIN(REC_TYPE) AS REC_TYPE, SUM(FORE_VAL) AS FORE_VAL, SUM(BACK_VAL) AS BACK_VAL
                        FROM
                            (SELECT 'F' AS REC_TYPE, CONTRACT_ID, TRANSACTION_ID, SCHEDULE_DATE, SCHEDULE_VAL AS FORE_VAL, 0 AS BACK_VAL
                              FROM TABLE(CAST(v_FORECAST_SCHEDULE AS CONTRACT_SCHEDULE_TABLE))
                             UNION ALL
                             SELECT 'B' AS REC_TYPE, CONTRACT_ID, TRANSACTION_ID, SCHEDULE_DATE, 0 AS FORE_VAL, SCHEDULE_VAL AS BACK_VAL
                              FROM TABLE(CAST(v_BACKCAST_SCHEDULE AS CONTRACT_SCHEDULE_TABLE))
                            )
                                  GROUP BY CONTRACT_ID, TRANSACTION_ID, SCHEDULE_DATE
                      )
                      UNION ALL
                      SELECT CONTRACT_ID, TRANSACTION_ID, SCHEDULE_DATE, SCHEDULE_VAL * -1 AS SCHEDULE_VAL
                      FROM TABLE(CAST(v_FINAL_SCHEDULE AS CONTRACT_SCHEDULE_TABLE))
                     ) A, TP_CONTRACT_NUMBER C
                   WHERE C.CONTRACT_ID = A.CONTRACT_ID
                   --RSS 4/27/2009 --
                   --AND TRUNC(A.SCHEDULE_DATE) BETWEEN C.BEGIN_DATE AND NVL(C.END_DATE, c_HIGH_DATE)
                   AND TO_HED_AS_DATE(FROM_CUT(A.SCHEDULE_DATE, 'EDT')) BETWEEN (C.BEGIN_DATE) AND NVL(C.END_DATE, HIGH_DATE)
				GROUP BY C.CONTRACT_NUMBER, TO_HED_AS_DATE(FROM_CUT(A.SCHEDULE_DATE, 'EDT'))
				ORDER BY 1,3;
--@@End Implementation Override --
		END IF;

		-- call this stub to allow project code to do something special w/ these numbers if necessary
		XS.PJM_EXPORT_DATA_MISC (p_SCHEDULE_TYPE, p_BEGIN_DATE, p_END_DATE, 'EDT', p_AS_OF_DATE, p_CURSOR, v_SOMETHING_DONE);

		IF v_SOMETHING_DONE THEN
			-- re-open cursor if XS did something w/ data that could invalidate the recordset for GUI
    		IF v_USE_EXT_ID THEN
    			OPEN p_CURSOR FOR
    				SELECT C.TRANSACTION_IDENTIFIER "CONTRACT_NUMBER", ROUND(SUM((A.SCHEDULE_VAL - B.SCHEDULE_VAL) * 1000)) "AMOUNT", TO_HED_AS_DATE(FROM_CUT(A.SCHEDULE_DATE, 'EDT')) "DATE"
    				FROM TABLE(CAST(v_FORECAST_SCHEDULE AS CONTRACT_SCHEDULE_TABLE)) A,
    					TABLE(CAST(v_FINAL_SCHEDULE AS CONTRACT_SCHEDULE_TABLE)) B,
    				    INTERCHANGE_TRANSACTION C
    				WHERE B.SCHEDULE_DATE = A.SCHEDULE_DATE
    					AND B.CONTRACT_ID = A.CONTRACT_ID
    					AND B.TRANSACTION_ID = A.TRANSACTION_ID
    					AND C.TRANSACTION_ID = A.TRANSACTION_ID
    				GROUP BY C.TRANSACTION_IDENTIFIER, TO_HED_AS_DATE(FROM_CUT(A.SCHEDULE_DATE, 'EDT'))
    				ORDER BY 1,3;
    		ELSE
    			OPEN p_CURSOR FOR
--@@Begin Implementation Override --
               SELECT  C.CONTRACT_NUMBER, ROUND(SUM(A.SCHEDULE_VAL)*1000) AS "AMOUNT", TO_HED_AS_DATE(FROM_CUT(A.SCHEDULE_DATE, 'EDT')) "DATE"
                      FROM
                       (SELECT CONTRACT_ID, TRANSACTION_ID, SCHEDULE_DATE, DECODE(REC_TYPE, 'B', BACK_VAL, FORE_VAL) AS SCHEDULE_VAL
                         FROM
                         (SELECT CONTRACT_ID, TRANSACTION_ID, SCHEDULE_DATE, MIN(REC_TYPE) AS REC_TYPE, SUM(FORE_VAL) AS FORE_VAL, SUM(BACK_VAL) AS BACK_VAL
                           FROM
                               (SELECT 'F' AS REC_TYPE, CONTRACT_ID, TRANSACTION_ID, SCHEDULE_DATE, SCHEDULE_VAL AS FORE_VAL, 0 AS BACK_VAL
                                 FROM TABLE(CAST(v_FORECAST_SCHEDULE AS CONTRACT_SCHEDULE_TABLE))
                                UNION ALL
                                SELECT 'B' AS REC_TYPE, CONTRACT_ID, TRANSACTION_ID, SCHEDULE_DATE, 0 AS FORE_VAL, SCHEDULE_VAL AS BACK_VAL
                                 FROM TABLE(CAST(v_BACKCAST_SCHEDULE AS CONTRACT_SCHEDULE_TABLE))
                               )
                                     GROUP BY CONTRACT_ID, TRANSACTION_ID, SCHEDULE_DATE
                         )
                         UNION ALL
                         SELECT CONTRACT_ID, TRANSACTION_ID, SCHEDULE_DATE, SCHEDULE_VAL * -1 AS SCHEDULE_VAL
                         FROM TABLE(CAST(v_FINAL_SCHEDULE AS CONTRACT_SCHEDULE_TABLE))
                        ) A, TP_CONTRACT_NUMBER C
                      WHERE C.CONTRACT_ID = A.CONTRACT_ID
                      --RSS 4/27/2009 --
                      --AND TRUNC(A.SCHEDULE_DATE) BETWEEN C.BEGIN_DATE AND NVL(C.END_DATE, c_HIGH_DATE)
                      AND TO_HED_AS_DATE(FROM_CUT(A.SCHEDULE_DATE, 'EDT')) BETWEEN (C.BEGIN_DATE) AND NVL(C.END_DATE, HIGH_DATE)
    				GROUP BY C.CONTRACT_NUMBER, TO_HED_AS_DATE(FROM_CUT(A.SCHEDULE_DATE, 'EDT'))
    				ORDER BY 1,3;
--@@End Implementation Override --
    		END IF;
		END IF;
	ELSE
		GET_SCHEDULE(p_TRANSACTION_IDS, p_SCHEDULE_TYPE, CONSTANTS.INTERNAL_STATE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, 'EDT', v_FORECAST_SCHEDULE, CASE WHEN v_USE_EXT_ID THEN 0 ELSE 1 END, ',');
		IF LOGS.IS_DEBUG_ENABLED() THEN
			TRACE_SCHEDULE('SCHEDULE', v_FORECAST_SCHEDULE);
		END IF;
		v_INDEX := v_FORECAST_SCHEDULE.FIRST;
		WHILE v_INDEX <= v_FORECAST_SCHEDULE.LAST LOOP
			v_AMOUNT := v_AMOUNT + v_FORECAST_SCHEDULE(v_INDEX).SCHEDULE_VAL;
			v_INDEX := v_FORECAST_SCHEDULE.NEXT(v_INDEX);
		END LOOP;

        GET_MODEL_VALUE_AT_KEY(1,'Scheduling','PJM Export','Allow All Zeroes',0,v_DICT_VAL);
        IF v_AMOUNT > 0 OR v_DICT_VAL = '1' OR v_DICT_VAL = 'Y' THEN
    		IF v_USE_EXT_ID THEN
    			OPEN p_CURSOR FOR
    				SELECT B.TRANSACTION_IDENTIFIER "CONTRACT_NUMBER", SUM(A.SCHEDULE_VAL) "AMOUNT", TO_HED_AS_DATE(FROM_CUT(A.SCHEDULE_DATE, 'EDT')) "DATE"
    				FROM TABLE(CAST(v_FORECAST_SCHEDULE AS CONTRACT_SCHEDULE_TABLE)) A,
    				    INTERCHANGE_TRANSACTION B
    				WHERE B.TRANSACTION_ID = A.TRANSACTION_ID
    				GROUP BY B.TRANSACTION_IDENTIFIER, TO_HED_AS_DATE(FROM_CUT(A.SCHEDULE_DATE, 'EDT'))
    				ORDER BY 1,3;
    		ELSE
    			OPEN p_CURSOR FOR
    				SELECT B.CONTRACT_NUMBER, SUM(A.SCHEDULE_VAL) "AMOUNT", TO_HED_AS_DATE(FROM_CUT(A.SCHEDULE_DATE, 'EDT')) "DATE"
    				FROM TABLE(CAST(v_FORECAST_SCHEDULE AS CONTRACT_SCHEDULE_TABLE)) A,
    				    TP_CONTRACT_NUMBER B
    				WHERE B.CONTRACT_ID = A.CONTRACT_ID
    					AND TRUNC(A.SCHEDULE_DATE) BETWEEN B.BEGIN_DATE AND NVL(B.END_DATE, A.SCHEDULE_DATE)
    				GROUP BY B.CONTRACT_NUMBER, TO_HED_AS_DATE(FROM_CUT(A.SCHEDULE_DATE, 'EDT'))
    				ORDER BY 1,3;
    		END IF;

			-- call this stub to allow project code to do something special w/ these numbers if necessary
			XS.PJM_EXPORT_DATA_MISC (p_SCHEDULE_TYPE, p_BEGIN_DATE, p_END_DATE, 'EDT', p_AS_OF_DATE, p_CURSOR, v_SOMETHING_DONE);

			IF v_SOMETHING_DONE THEN
				-- re-open cursor if XS did something w/ data that could invalidate the recordset for GUI
        		IF v_USE_EXT_ID THEN
        			OPEN p_CURSOR FOR
        				SELECT B.TRANSACTION_IDENTIFIER "CONTRACT_NUMBER", SUM(A.SCHEDULE_VAL) "AMOUNT", TO_HED_AS_DATE(FROM_CUT(A.SCHEDULE_DATE, 'EDT')) "DATE"
        				FROM TABLE(CAST(v_FORECAST_SCHEDULE AS CONTRACT_SCHEDULE_TABLE)) A,
        				    INTERCHANGE_TRANSACTION B
        				WHERE B.TRANSACTION_ID = A.TRANSACTION_ID
        				GROUP BY B.TRANSACTION_IDENTIFIER, TO_HED_AS_DATE(FROM_CUT(A.SCHEDULE_DATE, 'EDT'))
        				ORDER BY 1,3;
        		ELSE
        			OPEN p_CURSOR FOR
        				SELECT B.CONTRACT_NUMBER, SUM(A.SCHEDULE_VAL) "AMOUNT", TO_HED_AS_DATE(FROM_CUT(A.SCHEDULE_DATE, 'EDT')) "DATE"
        				FROM TABLE(CAST(v_FORECAST_SCHEDULE AS CONTRACT_SCHEDULE_TABLE)) A,
        				    TP_CONTRACT_NUMBER B
        				WHERE B.CONTRACT_ID = A.CONTRACT_ID
        					AND TRUNC(A.SCHEDULE_DATE) BETWEEN B.BEGIN_DATE AND NVL(B.END_DATE, A.SCHEDULE_DATE)
        				GROUP BY B.CONTRACT_NUMBER, TO_HED_AS_DATE(FROM_CUT(A.SCHEDULE_DATE, 'EDT'))
        				ORDER BY 1,3;
        		END IF;
			END IF;
		ELSE
        	-- otherwise return empty recordset
        	OPEN p_CURSOR FOR
				SELECT NULL "CONTRACT_NUMBER", NULL "AMOUNT", NULL "DATE"
                FROM DUAL WHERE 0 = 1;
		END IF;
	END IF;


    	IF p_STATUS > 0 THEN
        	p_STATUS := -p_STATUS;
        END IF;

END PJM_EXPORT_DATA;
----------------------------------------------------------------------------------------------------
PROCEDURE FIX_START_HOUR
    (
    p_FILE IN OUT CLOB,
    p_START_HOUR IN OUT NUMBER,
    p_FIRST_HOUR IN NUMBER
    ) AS

    v_EXPORT_STRING VARCHAR(64) := '';

BEGIN

    IF p_START_HOUR < 0 THEN
        IF p_FIRST_HOUR > 0 THEN
            v_EXPORT_STRING := '00-' || TRIM(TO_CHAR(p_FIRST_HOUR, '00')) || ' 0' || CHR(13) || CHR(10);
            DBMS_LOB.WRITEAPPEND(p_FILE, LENGTH(v_EXPORT_STRING), v_EXPORT_STRING);
        END IF;
        p_START_HOUR := p_FIRST_HOUR;
    END IF;

END FIX_START_HOUR;

----------------------------------------------------------------------------------------------------
PROCEDURE PJM_ESCHEDULE_EXPORT
	(
    p_SCHEDULE_TYPE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_EXCHANGE_TYPE IN VARCHAR,
	p_MODULE_NAME IN VARCHAR,
	p_TRANSACTION_IDS IN VARCHAR2,
    p_TRACE_ON NUMBER,
    p_FILE OUT CLOB,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

v_CURSOR GA.REFCURSOR;
v_CONTRACT_NUM NUMBER(16);
v_AMOUNT NUMBER(14,4);
v_DATE DATE;
v_DST_STRING VARCHAR(64);
v_CLOB_LINE VARCHAR(4000);
v_NUM_RECORDS NUMBER(8);
v_HEADER VARCHAR(16) := '';
v_FOOTER VARCHAR(16) := '';
v_CUR_DATE_STRING VARCHAR(16) := '';
v_PREV_DATE_STRING VARCHAR(16) := '';
v_PREV_CONTRACT_NUM NUMBER(16);
v_CUR_HOUR NUMBER(2);
v_FIRST_HOUR NUMBER(2);
v_START_HOUR NUMBER(2);
v_IS_FINAL BOOLEAN;
v_IS_FALLBACK BOOLEAN;
BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    -- Get Cursor with Export Data
    ITJ.pjm_export_data(
        p_transaction_ids,
        p_schedule_type,
        p_begin_date,
        p_end_date,
        'EDT',
        p_as_of_date,
        p_trace_on,
        p_status,
        v_cursor);

    IF p_STATUS >= 0 THEN
		-- Initialize the CLOB
        DBMS_LOB.CREATETEMPORARY(p_FILE,TRUE);

	    -- Open the clob for writing, and write records to it
        DBMS_LOB.OPEN(p_FILE, DBMS_LOB.LOB_READWRITE);

        -- What Schedule Type
        IF p_SCHEDULE_TYPE = 3 Then
            v_IS_FINAL := TRUE;
        ELSE
            v_IS_FINAL := FALSE;
        END IF;

        -- Get the appropriate Header
        IF v_IS_FINAL Then
            v_HEADER := '*ENGREC*' || CHR(13) || CHR(10);
		    v_FOOTER := '-' || CHR(13) || CHR(10);
        ELSE
            v_HEADER := '*INTSCH*' || CHR(13) || CHR(10);
        END IF;

        v_NUM_RECORDS := 0;

        LOOP
			FETCH v_CURSOR INTO v_CONTRACT_NUM, v_AMOUNT, v_DATE;
			EXIT WHEN v_CURSOR%NOTFOUND;

            v_CUR_DATE_STRING := TO_CHAR(V_DATE, 'MM/DD/YYYY');

            IF (NVL(v_PREV_CONTRACT_NUM, -12345) != v_CONTRACT_NUM) OR (NVL(v_PREV_DATE_STRING, ' ') != v_CUR_DATE_STRING) THEN
                --BEGIN HEADER
                -- Update the Previous Date and Start Hour
                v_PREV_DATE_STRING := v_CUR_DATE_STRING;
                v_PREV_CONTRACT_NUM := v_CONTRACT_NUM;
                v_START_HOUR := -1;
                -- Add Contract Number
                v_CLOB_LINE := v_HEADER || v_CONTRACT_NUM || CHR(13) || CHR(10);
                -- Add Begin Date
                v_CLOB_LINE := v_CLOB_LINE || v_CUR_DATE_STRING || CHR(13) || CHR(10);
                IF NOT v_IS_FINAL THEN
                    -- Add an END DATE to the header if this is not FINAL
                    v_CLOB_LINE := v_CLOB_LINE || v_CUR_DATE_STRING || CHR(13) || CHR(10);
                END IF;
                DBMS_LOB.WRITEAPPEND(p_FILE, LENGTH(v_CLOB_LINE), v_CLOB_LINE);
                --END HEADER
            END IF;

            --Extract the Hour for the Schedule Amount
            v_CUR_HOUR := TO_NUMBER(TO_CHAR(v_DATE, 'HH24'));
            v_FIRST_HOUR := v_CUR_HOUR - 1;

            --BEGIN DATA ENTRY
            IF v_CUR_HOUR > 0 THEN

                IF TO_CHAR(v_DATE, 'HH24:MI:SS') = '02:00:01' THEN
                    -- FALL BACK HOUR
                    v_DST_STRING := '24-25 ' || v_AMOUNT || CHR(13) || CHR(10);
                    v_IS_FALLBACK := TRUE;
                ELSIF TO_CHAR(v_DATE, 'DD-MON-YYYY HH24:MI:SS') = TO_CHAR(DST_SPRING_AHEAD_DATE(v_DATE), 'DD-MON-YYYY HH24:MI:SS') THEN
                    -- SPRING AHEAD HOUR
                    FIX_START_HOUR(p_FILE, v_START_HOUR, 1);
                    v_CLOB_LINE := TRIM(TO_CHAR(v_START_HOUR, '00')) || '-02' || ' ' || v_AMOUNT || CHR(13) || CHR(10);
                    DBMS_LOB.WRITEAPPEND(p_FILE, LENGTH(v_CLOB_LINE), v_CLOB_LINE);
                    v_START_HOUR := 3;

                ELSIF TO_CHAR(v_DATE, 'HH24:MI:SS') = '23:59:59' THEN
                    -- LAST HOUR
                    FIX_START_HOUR(p_FILE, v_START_HOUR, 23);
                    v_CLOB_LINE := TRIM(TO_CHAR(v_START_HOUR, '00')) || '-24' || ' ' || v_AMOUNT || CHR(13) || CHR(10);
                    DBMS_LOB.WRITEAPPEND(p_FILE, LENGTH(v_CLOB_LINE), v_CLOB_LINE);
                    IF v_IS_FALLBACK THEN
                        v_IS_FALLBACK := FALSE;
                        DBMS_LOB.WRITEAPPEND(p_FILE, LENGTH(v_DST_STRING), v_DST_STRING);
                    END IF;
					IF v_IS_FINAL THEN
						DBMS_LOB.WRITEAPPEND(p_FILE, LENGTH(v_FOOTER), v_FOOTER);
					END IF;

                ELSE
                    -- STANDARD HANDLING
                    FIX_START_HOUR(p_FILE, v_START_HOUR, v_FIRST_HOUR);
                    v_CLOB_LINE := TRIM(TO_CHAR(v_START_HOUR, '00')) || '-' || TRIM(TO_CHAR(v_CUR_HOUR, '00')) || ' ' || v_AMOUNT || CHR(13) || CHR(10);
                    DBMS_LOB.WRITEAPPEND(p_FILE, LENGTH(v_CLOB_LINE), v_CLOB_LINE);
                    v_START_HOUR := v_CUR_HOUR;
                END IF;

                v_NUM_RECORDS := v_NUM_RECORDS + 1;

            END IF;
            -- END DATA ENTRY

		END LOOP;

        p_MESSAGE := v_NUM_RECORDS || ' records were exported.';
        p_STATUS := v_NUM_RECORDS;
	END IF;
	IF NOT v_CURSOR IS NULL THEN
        CLOSE v_CURSOR;
    END IF;

    IF NOT p_FILE IS NULL THEN
        DBMS_LOB.CLOSE(p_FILE);
    END IF;

END PJM_ESCHEDULE_EXPORT;
----------------------------------------------------------------------------------------------------
PROCEDURE IMPORT_SPPXML_RECORDS
	(
	p_DATES IN VARCHAR2,
	p_NAMES IN VARCHAR2,
	p_TYPES IN VARCHAR2,
	p_MWS IN VARCHAR2,
	p_PRICES IN VARCHAR2,
	p_SCHEDULE_TYPE IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_AS_OF_DATE IN DATE,
	p_NUM OUT NUMBER,
	p_STATUS OUT NUMBER
	) AS

v_DATES	GA.STRING_TABLE;
v_NAMES	GA.STRING_TABLE;
v_TYPES	GA.STRING_TABLE;
v_MWS		GA.STRING_TABLE;
v_PRICES	GA.STRING_TABLE;
v_ID		NUMBER;
v_LASTNAME	VARCHAR2(64);
v_CURTYPE	VARCHAR2(16);
v_DATE	DATE;
v_STR		VARCHAR2(13);
v_DATESTR	VARCHAR2(10);
v_TIMESTR	VARCHAR2(6);

BEGIN

	p_NUM := 0;
	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;
	p_STATUS := GA.SUCCESS;

	UT.TOKENS_FROM_STRING(p_DATES, ';', v_DATES);
	UT.TOKENS_FROM_STRING(p_NAMES, ';', v_NAMES);
	UT.TOKENS_FROM_STRING(p_TYPES, ';', v_TYPES);
	UT.TOKENS_FROM_STRING(p_MWS, ';', v_MWS);
	UT.TOKENS_FROM_STRING(p_PRICES, ';', v_PRICES);
	v_LASTNAME := ' ';
	v_ID := 0;
	FOR v_INDEX IN v_DATES.FIRST..v_DATES.LAST LOOP
		-- Get TRANSACTION ID, create new one if necessary
		IF SUBSTR(v_NAMES(v_INDEX),1,64) <> v_LASTNAME THEN
			v_ID := 0;
			SELECT DECODE(UPPER(SUBSTR(v_TYPES(v_INDEX),1,3)),'GEN','Generation','CLD','Load','PUR','Purchase','SAL','Sale','PAS','Pass-Thru','Generation')
				INTO v_CURTYPE
				FROM DUAL;
			ID.ID_FOR_TRANSACTION(SUBSTR(v_NAMES(v_INDEX),1,64),v_CURTYPE,TRUE,v_ID);
			v_LASTNAME := SUBSTR(v_NAMES(v_INDEX),1,64);
		END IF;
		IF v_ID > 0 THEN
			v_STR := SUBSTR(v_DATES(v_INDEX),1,13);
			v_DATESTR := SUBSTR(v_STR,1,4)||'-'||SUBSTR(v_STR,5,2)||'-'||SUBSTR(v_STR,7,2);
			v_TIMESTR := SUBSTR(v_STR,9,2)||':'||SUBSTR(v_STR,11);
			v_DATE := DATE_TIME_AS_CUT(v_DATESTR,v_TIMESTR,p_TIME_ZONE);
			-- Extend Date Range if necessary
			UPDATE INTERCHANGE_TRANSACTION SET
				BEGIN_DATE = TRUNC(v_DATE),
				ENTRY_DATE = SYSDATE
			WHERE TRANSACTION_ID = v_ID
				AND TRUNC(v_DATE) < BEGIN_DATE;
			UPDATE INTERCHANGE_TRANSACTION SET
				END_DATE = TRUNC(v_DATE),
				ENTRY_DATE = SYSDATE
			WHERE TRANSACTION_ID = v_ID
				AND TRUNC(v_DATE) > END_DATE;
			-- Put schedule values
			PUT_IT_SCHEDULE (v_ID, p_SCHEDULE_TYPE, v_DATE, p_AS_OF_DATE, v_MWS(v_INDEX), v_PRICES(v_INDEX), p_STATUS);
			IF p_STATUS >= 0 THEN
				p_NUM := p_NUM + 1;
			END IF;
		END IF;
	END LOOP;
	v_DATES.DELETE;
	v_NAMES.DELETE;
	v_TYPES.DELETE;
	v_MWS.DELETE;
	v_PRICES.DELETE;


END IMPORT_SPPXML_RECORDS;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_TRANSACTION_TYPE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_TYPE OUT VARCHAR2
	) AS

BEGIN

	SELECT DECODE(UPPER(SUBSTR(TRANSACTION_TYPE,1,2)),'PA','PAS','LO','CLD','GE','GEN','PU','PUR','SA','SAL','???') INTO p_TYPE
	FROM INTERCHANGE_TRANSACTION
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		p_TYPE := '???';

END GET_TRANSACTION_TYPE;
----------------------------------------------------------------------------------------------------
PROCEDURE POD_NAMES
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
    p_NO_ALL IN NUMBER := 0,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the names of POD service points associated with trasactions.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

    IF p_NO_ALL = 1 THEN
        OPEN p_CURSOR FOR
    	    SELECT B.SERVICE_POINT_NAME, B.SERVICE_POINT_ID
    		FROM (SELECT DISTINCT POD_ID FROM INTERCHANGE_TRANSACTION WHERE BEGIN_DATE <= p_END_DATE AND END_DATE >= p_BEGIN_DATE) A,
    			SERVICE_POINT B
    		WHERE B.SERVICE_POINT_ID = A.POD_ID
            AND B.SERVICE_POINT_ID > 0
    		ORDER BY 1;
    ELSE
    	OPEN p_CURSOR FOR
    	    SELECT CONSTANTS.ALL_STRING, CONSTANTS.ALL_ID FROM DUAL
            UNION ALL
            SELECT B.SERVICE_POINT_NAME, B.SERVICE_POINT_ID
    		FROM (SELECT DISTINCT POD_ID FROM INTERCHANGE_TRANSACTION WHERE BEGIN_DATE <= p_END_DATE AND END_DATE >= p_BEGIN_DATE) A,
    			SERVICE_POINT B
    		WHERE B.SERVICE_POINT_ID = A.POD_ID
            AND B.SERVICE_POINT_ID > 0
    		ORDER BY 1;
    END IF;


END POD_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE POR_NAMES
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
    p_NO_ALL IN NUMBER := 0,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the names of POR service points associated with trasactions.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

    IF p_NO_ALL = 1 THEN
        OPEN p_CURSOR FOR
    	    SELECT B.SERVICE_POINT_NAME, B.SERVICE_POINT_ID
    		FROM (SELECT DISTINCT POR_ID FROM INTERCHANGE_TRANSACTION WHERE BEGIN_DATE <= p_END_DATE AND END_DATE >= p_BEGIN_DATE) A,
    			SERVICE_POINT B
    		WHERE B.SERVICE_POINT_ID = A.POR_ID
            AND B.SERVICE_POINT_ID > 0
    		ORDER BY 1;
    ELSE
    	OPEN p_CURSOR FOR
    	    SELECT CONSTANTS.ALL_STRING, CONSTANTS.ALL_ID FROM DUAL
            UNION ALL
            SELECT B.SERVICE_POINT_NAME, B.SERVICE_POINT_ID
    		FROM (SELECT DISTINCT POR_ID FROM INTERCHANGE_TRANSACTION WHERE BEGIN_DATE <= p_END_DATE AND END_DATE >= p_BEGIN_DATE) A,
    			SERVICE_POINT B
    		WHERE B.SERVICE_POINT_ID = A.POR_ID
            AND B.SERVICE_POINT_ID > 0
    		ORDER BY 1;
    END IF;


END POR_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE PURCHASER_NAMES
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
    p_NO_ALL IN NUMBER := 0,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the names of PSE that are a purchasing party to the transaction.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

    IF p_NO_ALL = 1 THEN
        OPEN p_CURSOR FOR
    	    SELECT PSE_NAME, PSE_ID
    		FROM (SELECT DISTINCT PURCHASER_ID FROM INTERCHANGE_TRANSACTION WHERE BEGIN_DATE <= p_END_DATE AND END_DATE >= p_BEGIN_DATE) A,
    			PURCHASING_SELLING_ENTITY B
    		WHERE B.PSE_ID = A.PURCHASER_ID
            AND B.PSE_ID > 0
    		ORDER BY 1;
    ELSE
    	OPEN p_CURSOR FOR
    	    SELECT CONSTANTS.ALL_STRING, CONSTANTS.ALL_ID FROM DUAL
            UNION ALL
            SELECT PSE_NAME, PSE_ID
    		FROM (SELECT DISTINCT PURCHASER_ID FROM INTERCHANGE_TRANSACTION WHERE BEGIN_DATE <= p_END_DATE AND END_DATE >= p_BEGIN_DATE) A,
    			PURCHASING_SELLING_ENTITY B
    		WHERE B.PSE_ID = A.PURCHASER_ID
            AND B.PSE_ID > 0
    		ORDER BY 1;
    END IF;


END PURCHASER_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE SELLER_NAMES
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
    p_NO_ALL IN NUMBER := 0,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the names of PSE that are a selling party to the transaction.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

    IF p_NO_ALL = 1 THEN
        OPEN p_CURSOR FOR
    	    SELECT PSE_NAME, PSE_ID
    		FROM (SELECT DISTINCT SELLER_ID FROM INTERCHANGE_TRANSACTION WHERE BEGIN_DATE <= p_END_DATE AND END_DATE >= p_BEGIN_DATE) A,
    			PURCHASING_SELLING_ENTITY B
    		WHERE B.PSE_ID = A.SELLER_ID
            AND B.PSE_ID > 0
    		ORDER BY 1;
    ELSE
    	OPEN p_CURSOR FOR
    	    SELECT CONSTANTS.ALL_STRING, CONSTANTS.ALL_ID FROM DUAL
            UNION ALL
            SELECT PSE_NAME, PSE_ID
    		FROM (SELECT DISTINCT SELLER_ID FROM INTERCHANGE_TRANSACTION WHERE BEGIN_DATE <= p_END_DATE AND END_DATE >= p_BEGIN_DATE) A,
    			PURCHASING_SELLING_ENTITY B
    		WHERE B.PSE_ID = A.SELLER_ID
            AND B.PSE_ID > 0
    		ORDER BY 1;
    END IF;


END SELLER_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE PSE_NAMES
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the names of PSE that are a purchasing party to the transaction.

BEGIN

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT DISTINCT PSE_NAME, PSE_ID
		FROM
			(SELECT DISTINCT PURCHASER_ID
			FROM INTERCHANGE_TRANSACTION
			WHERE BEGIN_DATE <= p_END_DATE AND END_DATE >= p_BEGIN_DATE
			UNION
			SELECT DISTINCT SELLER_ID
			FROM INTERCHANGE_TRANSACTION
			WHERE BEGIN_DATE <= p_END_DATE AND END_DATE >= p_BEGIN_DATE
			) A,
			PURCHASING_SELLING_ENTITY B
		WHERE B.PSE_ID = A.PURCHASER_ID
		ORDER BY PSE_NAME;


END PSE_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE CA_NAMES
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the names of CA that are a party to the transaction.

BEGIN

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT DISTINCT B.CA_NAME, B.CA_ID
		FROM
			(SELECT DISTINCT B.CA_ID
			FROM INTERCHANGE_TRANSACTION A,
				SERVICE_POINT B
			WHERE A.BEGIN_DATE <= p_END_DATE AND A.END_DATE >= p_BEGIN_DATE
				AND B.SERVICE_POINT_ID IN(A.POR_ID, A.POD_ID)
				AND B.CA_ID > 0	) A,
			CONTROL_AREA B
		WHERE B.CA_ID = A.CA_ID
		ORDER BY CA_NAME;


END CA_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE EDC_NAMES
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
    p_NO_ALL IN NUMBER := 0,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the names of PSE that are a selling party to the transaction.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

    IF p_NO_ALL = 1 THEN
        OPEN p_CURSOR FOR
    	    SELECT B.EDC_NAME, B.EDC_ID
    		FROM (SELECT DISTINCT B.EDC_ID
    				FROM INTERCHANGE_TRANSACTION A, SERVICE_POINT B
    				WHERE A.BEGIN_DATE <= p_END_DATE AND A.END_DATE >= p_BEGIN_DATE
    					AND A.POD_ID = B.SERVICE_POINT_ID) A,
    			ENERGY_DISTRIBUTION_COMPANY B
    		WHERE B.EDC_ID = A.EDC_ID
            AND B.EDC_ID > 0
    		ORDER BY 1;
    ELSE
    	OPEN p_CURSOR FOR
    	    SELECT CONSTANTS.ALL_STRING, CONSTANTS.ALL_ID FROM DUAL
            UNION ALL
            SELECT B.EDC_NAME, B.EDC_ID
    		FROM (SELECT DISTINCT B.EDC_ID
    				FROM INTERCHANGE_TRANSACTION A, SERVICE_POINT B
    				WHERE A.BEGIN_DATE <= p_END_DATE AND A.END_DATE >= p_BEGIN_DATE
    					AND A.POD_ID = B.SERVICE_POINT_ID) A,
    			ENERGY_DISTRIBUTION_COMPANY B
    		WHERE B.EDC_ID = A.EDC_ID
            AND B.EDC_ID > 0
    		ORDER BY 1;
    END IF;


END EDC_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE TP_NAMES
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_NO_ALL IN NUMBER := 0,
    p_STATUS OUT NUMBER,
    p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the names of PSE that are a selling party to the transaction.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

    IF p_NO_ALL = 1 THEN
        OPEN p_CURSOR FOR
            SELECT B.TP_NAME, B.TP_ID
    		FROM (SELECT DISTINCT B.TP_ID
    				FROM INTERCHANGE_TRANSACTION A, SERVICE_POINT B
    				WHERE A.BEGIN_DATE <= p_END_DATE AND A.END_DATE >= p_BEGIN_DATE
    					AND A.POD_ID = B.SERVICE_POINT_ID) A,
    			TRANSMISSION_PROVIDER B
    		WHERE B.TP_ID = A.TP_ID
            AND B.TP_ID > 0
    		ORDER BY 1;
    ELSE
    	OPEN p_CURSOR FOR
    	    SELECT CONSTANTS.ALL_STRING, CONSTANTS.ALL_ID FROM DUAL
            UNION ALL
            SELECT B.TP_NAME, B.TP_ID
    		FROM (SELECT DISTINCT B.TP_ID
    				FROM INTERCHANGE_TRANSACTION A, SERVICE_POINT B
    				WHERE A.BEGIN_DATE <= p_END_DATE AND A.END_DATE >= p_BEGIN_DATE
    					AND A.POD_ID = B.SERVICE_POINT_ID) A,
    			TRANSMISSION_PROVIDER B
    		WHERE B.TP_ID = A.TP_ID
            AND B.TP_ID > 0
    		ORDER BY 1;
    END IF;


END TP_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE ENTITY_NAMES
    (
	p_ENTITY_TYPE IN VARCHAR,
    p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
    p_NO_ALL IN NUMBER := 0,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

    IF p_ENTITY_TYPE IS NOT NULL THEN
        CASE UPPER(p_ENTITY_TYPE)
            WHEN 'EDC' THEN
                ITJ.EDC_NAMES(p_BEGIN_DATE, p_END_DATE, p_NO_ALL, p_STATUS, p_CURSOR);
            WHEN 'TP' THEN
                ITJ.TP_NAMES(p_BEGIN_DATE, p_END_DATE, p_NO_ALL, p_STATUS, p_CURSOR);
            WHEN 'POR' THEN
                ITJ.POR_NAMES(p_BEGIN_DATE, p_END_DATE, p_NO_ALL, p_STATUS, p_CURSOR);
            WHEN 'POD' THEN
                ITJ.POD_NAMES(p_BEGIN_DATE, p_END_DATE, p_NO_ALL, p_STATUS, p_CURSOR);
            WHEN 'PURCHASER' THEN
                ITJ.PURCHASER_NAMES(p_BEGIN_DATE, p_END_DATE, p_NO_ALL, p_STATUS, p_CURSOR);
            WHEN 'SELLER' THEN
                ITJ.SELLER_NAMES(p_BEGIN_DATE, p_END_DATE, p_NO_ALL, p_STATUS, p_CURSOR);
        END CASE;
    ELSE
        NULL_CURSOR(p_CURSOR);
    END IF;


END ENTITY_NAMES;

---------------------------------------------------------------------------------------------------
PROCEDURE SERVICE_TYPE_NAMES
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the names of PSE that are a selling party to the transaction.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT B.SERVICE_TYPE_NAME, B.SERVICE_TYPE_ID
		FROM (SELECT DISTINCT SERVICE_TYPE_ID FROM INTERCHANGE_TRANSACTION WHERE BEGIN_DATE <= p_END_DATE AND END_DATE >= p_BEGIN_DATE) A,
			TX_SERVICE_TYPE B
		WHERE B.SERVICE_TYPE_ID = A.SERVICE_TYPE_ID
		ORDER BY B.SERVICE_TYPE_NAME;


END SERVICE_TYPE_NAMES;
---------------------------------------------------------------------------------------------------

PROCEDURE SERVICE_ZONE_NAMES(
    p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the names of PSE that are a selling party to the transaction.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		 SELECT DISTINCT B.SERVICE_ZONE_NAME "SERVICE_ZONE_NAME",
		 DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'LO', A.ZOR_ID, 'SA', A.ZOR_ID, 'PU', A.ZOD_ID, 'GE', A.ZOD_ID) "SERVICE_ZONE_ID"
		FROM INTERCHANGE_TRANSACTION A, SERVICE_ZONE B
		WHERE B.SERVICE_ZONE_ID = DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'LO', A.ZOR_ID, 'SA', A.ZOR_ID, 'PU', A.ZOD_ID, 'GE', A.ZOD_ID)
		ORDER BY B.SERVICE_ZONE_NAME;


END SERVICE_ZONE_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE CUSTOM_SCHEDULER_TREE_FIELD
	(
	p_FIELD_NUMBER IN NUMBER,
    p_CUSTOM_FIELD IN VARCHAR2,
    p_SQL_SELECT IN OUT VARCHAR2,
    p_SQL_FROM IN OUT VARCHAR2,
    p_SQL_WHERE IN OUT VARCHAR2
    ) AS
v_FLD CHAR(1) := SUBSTR(UPPER(p_CUSTOM_FIELD),1,1);
BEGIN
	IF v_FLD IS NULL THEN
    	p_SQL_SELECT := p_SQL_SELECT||' NULL AS NULL_'||p_FIELD_NUMBER||', ';
	ELSIF v_FLD = '0' THEN
    	-- schedule coordinator
        p_SQL_SELECT := p_SQL_SELECT||' C.SC_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' SCHEDULE_COORDINATOR C, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND C.SC_ID(+) = A.SC_ID ';
    ELSIF v_FLD = '1' THEN
    	-- transaction type
        p_SQL_SELECT := p_SQL_SELECT||' A.TRANSACTION_TYPE, ';
    ELSIF v_FLD = '2' THEN
    	-- transaction category
        p_SQL_SELECT := p_SQL_SELECT||' DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)),''PU'',''Transaction'',''SA'',''Transaction'',''PA'',''Transaction'',''LO'',''Load'',''RE'',''Load'',A.TRANSACTION_TYPE) AS TRANSACTION_CATEGORY, ';
    ELSIF v_FLD = '3' THEN
    	-- commodity
        p_SQL_SELECT := p_SQL_SELECT||' D.COMMODITY_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' IT_COMMODITY D, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND D.COMMODITY_ID(+) = A.COMMODITY_ID ';
    ELSIF v_FLD = '4' THEN
    	-- commodity type
        p_SQL_SELECT := p_SQL_SELECT||' E.COMMODITY_TYPE, ';
        p_SQL_FROM := p_SQL_FROM||' IT_COMMODITY E, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND E.COMMODITY_ID(+) = A.COMMODITY_ID ';
    ELSIF v_FLD = '5' THEN
    	-- pod
        p_SQL_SELECT := p_SQL_SELECT||' F.SERVICE_POINT_NAME AS POD_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' SERVICE_POINT F, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND F.SERVICE_POINT_ID(+) = A.POD_ID ';
    ELSIF v_FLD = '6' THEN
    	-- pod type
        p_SQL_SELECT := p_SQL_SELECT||' G.SERVICE_POINT_TYPE AS POD_TYPE, ';
        p_SQL_FROM := p_SQL_FROM||' SERVICE_POINT G, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND G.SERVICE_POINT_ID(+) = A.POD_ID ';
    ELSIF v_FLD = '7' THEN
    	-- por
        p_SQL_SELECT := p_SQL_SELECT||' H.SERVICE_POINT_NAME AS POR_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' SERVICE_POINT H, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND H.SERVICE_POINT_ID(+) = A.POR_ID ';
    ELSIF v_FLD = '8' THEN
    	-- por type
        p_SQL_SELECT := p_SQL_SELECT||' I.SERVICE_POINT_TYPE AS POR_TYPE, ';
        p_SQL_FROM := p_SQL_FROM||' SERVICE_POINT I, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND I.SERVICE_POINT_ID(+) = A.POR_ID ';
    ELSIF v_FLD = '9' THEN
    	-- zod
        p_SQL_SELECT := p_SQL_SELECT||' J.SERVICE_ZONE_NAME AS ZOD_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' SERVICE_ZONE J, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND J.SERVICE_ZONE_ID(+) = A.ZOD_ID ';
    ELSIF v_FLD = 'A' THEN
    	-- zor
        p_SQL_SELECT := p_SQL_SELECT||' K.SERVICE_ZONE_NAME AS ZOR_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' SERVICE_ZONE K, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND K.SERVICE_ZONE_ID(+) = A.ZOR_ID ';
    ELSIF v_FLD = 'B' THEN
    	-- source
        p_SQL_SELECT := p_SQL_SELECT||' L.SERVICE_POINT_NAME AS SOURCE_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' SERVICE_POINT L, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND L.SERVICE_POINT_ID(+) = A.SOURCE_ID ';
    ELSIF v_FLD = 'C' THEN
    	-- sink
        p_SQL_SELECT := p_SQL_SELECT||' M.SERVICE_POINT_NAME AS SINK_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' SERVICE_POINT M, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND M.SERVICE_POINT_ID(+) = A.SINK_ID ';
    ELSIF v_FLD = 'D' THEN
    	-- schedule group
        p_SQL_SELECT := p_SQL_SELECT||' N.SCHEDULE_GROUP_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' SCHEDULE_GROUP N, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND N.SCHEDULE_GROUP_ID(+) = A.SCHEDULE_GROUP_ID ';
    ELSIF v_FLD = 'E' THEN
    	-- resource
        p_SQL_SELECT := p_SQL_SELECT||' O.RESOURCE_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' SUPPLY_RESOURCE O, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND O.RESOURCE_ID(+) = A.RESOURCE_ID ';
    ELSIF v_FLD = 'F' THEN
    	-- resource group
        p_SQL_SELECT := p_SQL_SELECT||' Q.RESOURCE_GROUP_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' SUPPLY_RESOURCE P, SUPPLY_RESOURCE_GROUP Q, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND P.RESOURCE_ID(+) = A.RESOURCE_ID ';
        p_SQL_WHERE := p_SQL_WHERE||' AND Q.RESOURCE_GROUP_ID(+) = P.RESOURCE_GROUP_ID ';
    ELSIF v_FLD = 'G' THEN
    	-- contract
        p_SQL_SELECT := p_SQL_SELECT||' R.CONTRACT_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' INTERCHANGE_CONTRACT R, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND R.CONTRACT_ID(+) = A.CONTRACT_ID ';
    ELSIF v_FLD = 'H' THEN
    	-- billing entity
        p_SQL_SELECT := p_SQL_SELECT||' T.PSE_NAME AS COUNTER_PARTY_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' INTERCHANGE_CONTRACT S, PURCHASING_SELLING_ENTITY T, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND S.CONTRACT_ID(+) = A.CONTRACT_ID ';
        p_SQL_WHERE := p_SQL_WHERE||' AND T.PSE_ID(+) = S.BILLING_ENTITY_ID ';
    ELSIF v_FLD = 'I' THEN
    	-- tp contract name
        p_SQL_SELECT := p_SQL_SELECT||' U.CONTRACT_NAME AS TP_CONTRACT_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' TP_CONTRACT_NUMBER U, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND U.CONTRACT_ID(+) = A.CONTRACT_ID ';
        p_SQL_WHERE := p_SQL_WHERE||' AND U.BEGIN_DATE(+) <= SYSDATE ';
        p_SQL_WHERE := p_SQL_WHERE||' AND U.END_DATE(+) >= SYSDATE ';
    ELSIF v_FLD = 'J' THEN
    	-- tp contract number
        p_SQL_SELECT := p_SQL_SELECT||' V.CONTRACT_NUMBER AS TP_CONTRACT_NUMBER, ';
        p_SQL_FROM := p_SQL_FROM||' TP_CONTRACT_NUMBER V, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND V.CONTRACT_ID(+) = A.CONTRACT_ID ';
        p_SQL_WHERE := p_SQL_WHERE||' AND V.BEGIN_DATE(+) <= SYSDATE ';
        p_SQL_WHERE := p_SQL_WHERE||' AND V.END_DATE(+) >= SYSDATE ';
    ELSIF v_FLD = 'K' THEN
    	-- purchaser
        p_SQL_SELECT := p_SQL_SELECT||' W.PSE_NAME AS PURCHASER_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' PURCHASING_SELLING_ENTITY W, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND W.PSE_ID(+) = A.PURCHASER_ID ';
    ELSIF v_FLD = 'L' THEN
    	-- seller
        p_SQL_SELECT := p_SQL_SELECT||' X.PSE_NAME AS SELLER_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' PURCHASING_SELLING_ENTITY X, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND X.PSE_ID(+) = A.SELLER_ID ';
    ELSIF v_FLD = 'M' THEN
    	-- scheduler
        p_SQL_SELECT := p_SQL_SELECT||' Y.SCHEDULER_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' SCHEDULER Y, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND Y.SCHEDULER_ID(+) = A.SCHEDULER_ID ';
    ELSIF v_FLD = 'N' THEN
    	-- agreement type
        p_SQL_SELECT := p_SQL_SELECT||' A.AGREEMENT_TYPE, ';
    ELSIF v_FLD = 'O' THEN
    	-- approval type
        p_SQL_SELECT := p_SQL_SELECT||' A.APPROVAL_TYPE, ';
    ELSIF v_FLD = 'P' THEN
    	-- external id
        p_SQL_SELECT := p_SQL_SELECT||' A.TRANSACTION_IDENTIFIER, ';
    ELSIF v_FLD = 'Q' THEN
    	-- is firm
        p_SQL_SELECT := p_SQL_SELECT||' DECODE(A.IS_FIRM,1,''Firm'',''Non-Firm'') AS IS_FIRM, ';
    ELSIF v_FLD = 'R' THEN
    	-- is import/export
        p_SQL_SELECT := p_SQL_SELECT||' DECODE(A.IS_IMPORT_EXPORT,1,''Export/Import'',NULL) AS IS_IMPORT_EXPORT, ';
    ELSIF v_FLD = 'S' THEN
    	-- interval
        p_SQL_SELECT := p_SQL_SELECT||' A.TRANSACTION_INTERVAL, ';
    ELSE
    	-- unrecognized? ignore
    	p_SQL_SELECT := p_SQL_SELECT||' NULL AS NULL_'||p_FIELD_NUMBER||', ';
    END IF;
END CUSTOM_SCHEDULER_TREE_FIELD;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_SCHEDULER_TREE
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
    p_SYSTEM_VIEW_NAME IN VARCHAR2,
    p_REPORT_NAME IN VARCHAR2,
	p_IS_BID_OFFER IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the scheduler tree for all transactions within the specified temporal scope.

v_SCHEDULER_TREE_HIERARCHY VARCHAR2(32);
v_SCHEDULER_TREE_TYPE CHAR(1);
v_ALLOWED_TXNS ID_TABLE := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_TXN_SELECT);
v_SQL_SELECT VARCHAR2(4000) := '';
v_SQL_FROM VARCHAR2(4000) := '';
v_SQL_WHERE VARCHAR2(4000) := '';
v_SQL_FROM_FILTER VARCHAR2(4000) := '';
v_SQL_WHERE_FILTER VARCHAR2(4000) := '';
v_SQL VARCHAR2(4000);
BEGIN

    p_STATUS := GA.SUCCESS;

	SP.GET_USER_PREFERENCE('Scheduling','Scheduler Tree','?','?','Hierarchy',v_SCHEDULER_TREE_HIERARCHY);
	v_SCHEDULER_TREE_HIERARCHY := NVL(v_SCHEDULER_TREE_HIERARCHY,'A'); -- default
	v_SCHEDULER_TREE_TYPE := SUBSTR(v_SCHEDULER_TREE_HIERARCHY,1,1);

	IF v_SCHEDULER_TREE_TYPE = 'A' THEN
		v_SCHEDULER_TREE_TYPE := '*';
		v_SCHEDULER_TREE_HIERARCHY := '*236';
	ELSIF v_SCHEDULER_TREE_TYPE = 'B' THEN
		v_SCHEDULER_TREE_TYPE := '*';
		v_SCHEDULER_TREE_HIERARCHY := '*023';
	ELSIF v_SCHEDULER_TREE_TYPE = 'C' THEN
		v_SCHEDULER_TREE_TYPE := '*';
		v_SCHEDULER_TREE_HIERARCHY := '*0F3';
	ELSIF v_SCHEDULER_TREE_TYPE NOT IN ('*', 'X') THEN
		-- if no valid hierarchy is specified, then default to tree style A
		v_SCHEDULER_TREE_TYPE := '*';
		v_SCHEDULER_TREE_HIERARCHY := '*236';
	END IF;


	IF v_SCHEDULER_TREE_TYPE = '*' THEN
        FOR v_INDEX IN 2..4 LOOP
        	CUSTOM_SCHEDULER_TREE_FIELD(v_INDEX-1, SUBSTR(v_SCHEDULER_TREE_HIERARCHY,v_INDEX,1),v_SQL_SELECT,v_SQL_FROM,v_SQL_WHERE);
        END LOOP;
	ELSIF v_SCHEDULER_TREE_TYPE = 'X' THEN
    	XS.GET_SCHEDULER_TREE_FIELDS (p_SYSTEM_VIEW_NAME, p_REPORT_NAME, v_SQL_SELECT, v_SQL_FROM, v_SQL_WHERE);
		IF TRIM(v_SQL_SELECT) IS NULL THEN
			v_SQL_SELECT := 'NULL AS NULL_1, NULL AS NULL_2, NULL AS NULL_3, ';
		ELSE
			v_SQL_SELECT := v_SQL_SELECT || ',';
		END IF;
		IF TRIM(v_SQL_FROM) IS NOT NULL THEN
			v_SQL_FROM := v_SQL_FROM || ',';
		END IF;
		IF TRIM(v_SQL_WHERE) IS NOT NULL THEN
			v_SQL_WHERE := ' AND ' || v_SQL_WHERE;
		END IF;
	END IF;

	IF UPPER(p_SYSTEM_VIEW_NAME) IN ( UPPER('Scheduling.Scheduler'), UPPER('Scheduling.BidsNOffers') ) THEN
		NULL; -- default trees - no customization needed
	ELSE
		XS.GET_SCHEDULER_TREE_FILTER (p_SYSTEM_VIEW_NAME, p_REPORT_NAME, v_SQL_FROM_FILTER, v_SQL_WHERE_FILTER);
		IF TRIM(v_SQL_FROM_FILTER) IS NOT NULL THEN
			v_SQL_FROM := v_SQL_FROM || ' ' || v_SQL_FROM_FILTER || ',';
		END IF;
		IF TRIM(v_SQL_WHERE_FILTER) IS NOT NULL THEN
			v_SQL_WHERE := v_SQL_WHERE || ' AND ' || v_SQL_WHERE_FILTER;
		END IF;
	END IF;

    v_SQL := 'SELECT '||v_SQL_SELECT||
                ' A.TRANSACTION_NAME,'||
                ' A.TRANSACTION_ID,'||
                ' B.TRANSACTION_IS_ACTIVE'||
                ' FROM '||v_SQL_FROM||
                        	' INTERCHANGE_TRANSACTION A, IT_STATUS B , TABLE(CAST( :1 AS ID_TABLE)) IDS' ||
                ' WHERE A.BEGIN_DATE <= :2'||
                ' AND A.END_DATE >= :3'||
                            ' AND (:4 = 0 OR :5 IS NULL OR A.IS_BID_OFFER = 1)'||
                ' AND B.TRANSACTION_ID = A.TRANSACTION_ID'||
                ' AND B.AS_OF_DATE ='||
                	' (SELECT MAX(AS_OF_DATE)'||
                	' FROM IT_STATUS'||
                	' WHERE TRANSACTION_ID = B.TRANSACTION_ID'||
                		' AND AS_OF_DATE <= :6) '||
                v_SQL_WHERE||
                ' AND (IDS.ID = :7 OR A.TRANSACTION_ID = IDS.ID)' ||
				' AND A.TRANSACTION_ID <> ' || TO_CHAR(CONSTANTS.NOT_ASSIGNED) ||
                ' ORDER BY 1,2,3,4';

    -- execute query dynamically
	OPEN p_CURSOR FOR
    	v_SQL USING v_ALLOWED_TXNS, p_END_DATE, p_BEGIN_DATE, p_IS_BID_OFFER, p_IS_BID_OFFER, p_AS_OF_DATE, SD.g_ALL_DATA_ENTITY_ID;


END GET_SCHEDULER_TREE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_IT_SCHEDULE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the schedule's detailed data for the specified selection criteria.

v_BEGIN_DATE		DATE;
v_END_DATE			DATE;
v_SCHEDULE_TYPE		NUMBER(9) := SUPPLY_SCHEDULE_TYPE(p_SCHEDULE_TYPE);
v_INTERVAL			INTERCHANGE_TRANSACTION.TRANSACTION_INTERVAL%TYPE;
v_INTERVAL_NUM 		PLS_INTEGER;
v_DATA_INTERVAL_TYPE PLS_INTEGER;
v_LOCKING_ENABLED	NUMBER := AUDIT_TRAIL.IS_TABLE_LOCKING_ENABLED(ENTITY_UTIL.TABLE_ID_FOR_DB_TABLE('IT_SCHEDULE'));
v_STATUS			NUMBER;

NO_TXN_SELECTED		CONSTANT NUMBER(9) := -9;

BEGIN

	IF p_TRANSACTION_ID IS NULL OR p_TRANSACTION_ID = NO_TXN_SELECTED THEN
		NULL_CURSOR(p_CURSOR);
		RETURN;
	END IF;

	IF g_REDIRECT_SCHEDULER THEN
		SCHEDULER_SCHEDULE(p_TRANSACTION_ID, p_SCHEDULE_TYPE, CONSTANTS.EXTERNAL_STATE, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_TIME_ZONE, v_STATUS, p_CURSOR);
		ERRS.VALIDATE_STATUS('ITJ.SCHEDULER_SCHEDULE', v_STATUS);
		RETURN;
	END IF;

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_TXN_SELECT, p_TRANSACTION_ID, EC.ED_TRANSACTION);

	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, p_BEGIN_DATE, p_END_DATE);

	IF LOGS.IS_DEBUG_ENABLED() THEN
	    LOGS.LOG_DEBUG('GET_IT_SCHEDULE');
	    LOGS.LOG_DEBUG('TRANSACTION_ID=' || TO_CHAR(p_TRANSACTION_ID));
	    LOGS.LOG_DEBUG('SCHEDULE_TYPE=' || TO_CHAR(p_SCHEDULE_TYPE));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TO_CHAR(p_END_DATE));
		LOGS.LOG_DEBUG('AS_OF_DATE=' || UT.TRACE_DATE(p_END_DATE));
		LOGS.LOG_DEBUG('TIME_ZONE=' || p_TIME_ZONE);
		LOGS.LOG_DEBUG('SCHEDULE_TYPE=' || TO_CHAR(v_SCHEDULE_TYPE));
	END IF;

	-- get interval information and compute query date range
	SELECT TRANSACTION_INTERVAL INTO v_INTERVAL
	FROM INTERCHANGE_TRANSACTION
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

	IF DATE_UTIL.IS_SUB_DAILY(v_INTERVAL) THEN
		v_DATA_INTERVAL_TYPE := 1;
		UT.CUT_DATE_RANGE(CONSTANTS.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	ELSE
		v_DATA_INTERVAL_TYPE := 2;
		v_BEGIN_DATE := TRUNC(p_BEGIN_DATE, GET_INTERVAL_ABBREVIATION(v_INTERVAL));
		v_END_DATE := p_END_DATE;
	END IF;

	v_INTERVAL_NUM := GET_INTERVAL_NUMBER(v_INTERVAL);

	-- get the data
	OPEN p_CURSOR FOR
		SELECT SUBSTR(SDT.NO_ROLLUP_YYYY_MM_DD, 0, 10) "SCHEDULE_DATE",
			SUBSTR(SDT.NO_ROLLUP_YYYY_MM_DD, 12) "SCHEDULE_TIME",
			MAX(CASE WHEN A.SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE THEN A.AMOUNT	ELSE NULL END) "AMOUNT",
			MAX(CASE WHEN A.SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE THEN A.PRICE	ELSE NULL END) "PRICE",
			SECURITY_CONTROLS.GET_EFFECTIVE_LOCK_STATE(MIN(CASE WHEN A.SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE THEN A.LOCK_STATE ELSE NULL END), v_LOCKING_ENABLED) "LOCK_STATE",
			MAX(CASE WHEN A.SCHEDULE_STATE = CONSTANTS.EXTERNAL_STATE THEN A.AMOUNT	ELSE NULL END) "EXT_AMOUNT",
			MAX(CASE WHEN A.SCHEDULE_STATE = CONSTANTS.EXTERNAL_STATE THEN A.PRICE	ELSE NULL END) "EXT_PRICE",
			SECURITY_CONTROLS.GET_EFFECTIVE_LOCK_STATE(MIN(CASE WHEN A.SCHEDULE_STATE = CONSTANTS.EXTERNAL_STATE THEN A.LOCK_STATE ELSE NULL END), v_LOCKING_ENABLED) "EXT_LOCK_STATE",
			MAX((SELECT AVG(P.PRICE) -- get best available market price value
				FROM MARKET_PRICE_VALUE P, INTERCHANGE_TRANSACTION T
				WHERE T.TRANSACTION_ID = p_TRANSACTION_ID
					AND P.MARKET_PRICE_ID = T.MARKET_PRICE_ID
					AND P.PRICE_DATE = A.SCHEDULE_DATE
					AND P.PRICE_CODE = (SELECT CASE MAX(CASE PRICE_CODE WHEN 'A' THEN 3 WHEN 'P' THEN 2 ELSE 1 END)
											 WHEN 3 THEN 'A'
											 WHEN 2 THEN 'P'
											 ELSE 'F'
											 END
										FROM MARKET_PRICE_VALUE
										WHERE MARKET_PRICE_ID = P.MARKET_PRICE_ID
											AND PRICE_DATE = P.PRICE_DATE))) "MARKET_PRICE"
		FROM IT_SCHEDULE A,
			SYSTEM_DATE_TIME SDT
		WHERE SDT.TIME_ZONE = p_TIME_ZONE
			AND SDT.DATA_INTERVAL_TYPE = v_DATA_INTERVAL_TYPE
			AND SDT.DAY_TYPE = '1'
			AND SDT.CUT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND SDT.MINIMUM_INTERVAL_NUMBER >= v_INTERVAL_NUM
			AND A.TRANSACTION_ID(+) = p_TRANSACTION_ID
			AND A.SCHEDULE_TYPE(+) = v_SCHEDULE_TYPE
			AND A.SCHEDULE_DATE(+) = SDT.CUT_DATE_SCHEDULING
			AND A.AS_OF_DATE(+) = CONSTANTS.LOW_DATE --SCHEDULE_AS_OF_DATE (A.TRANSACTION_ID, A.SCHEDULE_TYPE, A.SCHEDULE_STATE, A.SCHEDULE_DATE, p_AS_OF_DATE)
		GROUP BY SDT.NO_ROLLUP_YYYY_MM_DD
		ORDER BY 1, 2;

END GET_IT_SCHEDULE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_SCHEDULE_COMPARISON_REPORT
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TRANSACTION_INTERVAL IN VARCHAR2,
	p_CATEGORY IN VARCHAR2,
	p_COMMODITY_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_PORPOD_TYPE IN VARCHAR2,
	p_POD_ID IN NUMBER,
	p_POR_ID IN NUMBER,
	p_SCHEDULE_TYPE1 IN NUMBER,
	p_SCHEDULE_STATE1 IN NUMBER,
	p_SCHEDULE_TYPE2 IN NUMBER,
	p_SCHEDULE_STATE2 IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- New procedure for the Java GUI Comparison Tab
-- Old VB gui used to call GET_TRANSACTION_HEADERS to retrieve the TXN Ids then
--   it called GET_TRANSACTION_TOTALS to get the data for the specific Ids.
-- Those procedures have been removed and replaced with this single report procedure.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_TIME_ZONE VARCHAR2(8) := '';
v_ALLOWED_TXNS ID_TABLE := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_TXN_SELECT);
v_ALL_TXNS NUMBER(1) := 0;

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	SP.GET_TIME_ZONE(v_TIME_ZONE);

	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, v_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	IF v_ALLOWED_TXNS(1).ID = SD.g_ALL_DATA_ENTITY_ID THEN v_ALL_TXNS := 1; END IF;

	OPEN p_CURSOR FOR
		SELECT A.TRANSACTION_ID,
			D.TRANSACTION_NAME,
			E.CONTRACT_NAME,
			E.CONTRACT_NUMBER,
			SUM(NVL(CASE WHEN (p_SCHEDULE_TYPE1 = A.SCHEDULE_TYPE AND p_SCHEDULE_STATE1 = A.SCHEDULE_STATE) THEN B.AMOUNT ELSE 0 END,0)) "ALPHA_AMOUNT",
			SUM(NVL(CASE WHEN (p_SCHEDULE_TYPE2 = A.SCHEDULE_TYPE AND p_SCHEDULE_STATE2 = A.SCHEDULE_STATE) THEN C.AMOUNT ELSE 0 END,0)) "BETA_AMOUNT",
			CASE WHEN (p_SCHEDULE_TYPE1 = p_SCHEDULE_TYPE2 AND (p_SCHEDULE_STATE1 = 1 AND p_SCHEDULE_STATE2 = 2)) THEN 0 ELSE NULL END "ACCEPT"
		FROM IT_SCHEDULE A, IT_SCHEDULE B, IT_SCHEDULE C, INTERCHANGE_TRANSACTION D, TP_CONTRACT_NUMBER E,
			SERVICE_POINT G, SERVICE_POINT H, PURCHASING_SELLING_ENTITY I, PURCHASING_SELLING_ENTITY J,
			IT_STATUS K
		WHERE A.TRANSACTION_ID = D.TRANSACTION_ID
                AND A.SCHEDULE_TYPE IN (0, p_SCHEDULE_TYPE1, p_SCHEDULE_TYPE2)
                AND A.SCHEDULE_STATE IN (p_SCHEDULE_STATE1, p_SCHEDULE_STATE2)
                AND A.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
                AND A.AS_OF_DATE = CONSTANTS.LOW_DATE
                AND B.TRANSACTION_ID(+) = A.TRANSACTION_ID
                AND B.SCHEDULE_TYPE(+) = p_SCHEDULE_TYPE1
                AND B.SCHEDULE_STATE(+) = p_SCHEDULE_STATE1
                AND B.SCHEDULE_DATE(+) = A.SCHEDULE_DATE
                AND B.AS_OF_DATE(+) = A.AS_OF_DATE
                AND C.TRANSACTION_ID(+) = A.TRANSACTION_ID
                AND C.SCHEDULE_TYPE(+) = p_SCHEDULE_TYPE2
                AND C.SCHEDULE_STATE(+) = p_SCHEDULE_STATE2
                AND C.SCHEDULE_DATE(+) = A.SCHEDULE_DATE
                AND C.AS_OF_DATE(+) = A.AS_OF_DATE
                AND D.TRANSACTION_ID = A.TRANSACTION_ID
                AND E.CONTRACT_ID(+) = D.CONTRACT_ID
                AND CUT_DATE_BETWEEN(A.SCHEDULE_DATE, E.BEGIN_DATE, E.END_DATE, v_TIME_ZONE) = 'Y'
                AND D.BEGIN_DATE <= p_END_DATE
                AND D.END_DATE >= p_BEGIN_DATE
                AND UPPER(D.TRANSACTION_INTERVAL) = UPPER(p_TRANSACTION_INTERVAL)
                AND UPPER(D.TRANSACTION_TYPE) = UPPER(p_CATEGORY)
                AND D.COMMODITY_ID = p_COMMODITY_ID
                AND G.SERVICE_POINT_ID = D.POR_ID
                AND H.SERVICE_POINT_ID = D.POD_ID
                AND (p_POR_ID = CONSTANTS.ALL_ID OR D.POR_ID = p_POR_ID)
                AND (p_POD_ID = CONSTANTS.ALL_ID OR D.POD_ID = p_POD_ID)
                AND (UPPER(p_PORPOD_TYPE) = '<ALL>' OR UPPER(G.SERVICE_POINT_TYPE) = UPPER(p_PORPOD_TYPE) OR UPPER(H.SERVICE_POINT_TYPE) = UPPER(p_PORPOD_TYPE))
                AND I.PSE_ID = D.PURCHASER_ID
                AND J.PSE_ID = D.SELLER_ID
                AND (p_PSE_ID = CONSTANTS.ALL_ID OR D.PURCHASER_ID = p_PSE_ID OR D.SELLER_ID = p_PSE_ID)
                AND K.TRANSACTION_ID = D.TRANSACTION_ID
                AND K.AS_OF_DATE = IT_STATUS_AS_OF_DATE(K.TRANSACTION_ID, p_AS_OF_DATE)
                AND K.TRANSACTION_IS_ACTIVE = 1
				AND (v_ALL_TXNS = 1 OR D.TRANSACTION_ID IN (SELECT IDS.ID FROM TABLE(v_ALLOWED_TXNS) IDS))
            GROUP BY A.TRANSACTION_ID, D.TRANSACTION_NAME, E.CONTRACT_NAME, E.CONTRACT_NUMBER
            ORDER BY A.TRANSACTION_ID;

END GET_SCHEDULE_COMPARISON_REPORT;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_TRANSACTION_REPORT
    (
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_TRANSACTION_INTERVAL IN VARCHAR2,
	p_CATEGORY IN VARCHAR2,
	p_COMMODITY_ID IN VARCHAR2,
	p_SC_ID IN NUMBER,
    p_CONTRACT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_INTERVAL VARCHAR2(16);
v_MODEL_ID NUMBER(1) := GA.DEFAULT_MODEL;
v_COMMODITY_IDs VARCHAR(4000);
v_CATEGORY VARCHAR(4000);
v_COMMODITY_TABLE ID_TABLE;
v_CATEGORY_TABLE STRING_TABLE;
v_STRING_TYPE STRING_TYPE;
v_ID_TYPE ID_TYPE;
v_CONTRACT_FILTER NUMBER(1) := 0;
v_ALLOWED_TXNS ID_TABLE := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_TXN_SELECT);
v_ALL_TXNS NUMBER(1) := 0;
BEGIN

    IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

	IF v_ALLOWED_TXNS(1).ID = SD.g_ALL_DATA_ENTITY_ID THEN v_ALL_TXNS := 1; END IF;

    v_COMMODITY_IDs := p_COMMODITY_ID;
    v_CATEGORY := p_CATEGORY;

    PARSE_UTIL.ID_TABLE_FROM_STRING(v_COMMODITY_IDs, ',', v_COMMODITY_TABLE);
    UT.STRING_TABLE_FROM_STRING(v_CATEGORY, ',', v_CATEGORY_TABLE);

    IF v_COMMODITY_IDs IS NULL THEN
        v_COMMODITY_TABLE := ID_TABLE();
        v_COMMODITY_TABLE.EXTEND;
        v_ID_TYPE := ID_TYPE(0);
        v_COMMODITY_TABLE(1) := v_ID_TYPE;
    END IF;

    IF v_CATEGORY IS NULL THEN
        v_CATEGORY_TABLE := STRING_TABLE();
        v_CATEGORY_TABLE.EXTEND;
        v_STRING_TYPE := STRING_TYPE(' ');
        v_CATEGORY_TABLE(1) := v_STRING_TYPE;
    END IF;

    IF p_CONTRACT_ID IS NOT NULL AND p_CONTRACT_ID != -1 THEN
       v_CONTRACT_FILTER := 1;
	END IF;

    --DETERMINE THE INTERVAL OF THE TRANSACTIONS (ALL ARE SAME INTERVAL)
	SELECT DECODE(UPPER(p_TRANSACTION_INTERVAL),'15 MINUTE','MI15','30 MINUTE','MI30','DAY','DD','WEEK','DY','MONTH','MM','QUARTER','Q','YEAR','YY','')
	INTO v_INTERVAL
	FROM DUAL;

 	UT.CUT_DATE_RANGE(v_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_INTERVAL, v_BEGIN_DATE, v_END_DATE);

    OPEN p_CURSOR FOR
		SELECT SUBSTR(TRIM(FROM_CUT_AS_HED(SCHEDULE_DATE, p_TIME_ZONE, v_INTERVAL, v_MODEL_ID)), 0, 10) "SCHEDULE_DATE",
            SUBSTR(TRIM(FROM_CUT_AS_HED(SCHEDULE_DATE, p_TIME_ZONE, v_INTERVAL, v_MODEL_ID)), 12) "SCHEDULE_TIME",
            A.TRANSACTION_ID,
            A.TRANSACTION_NAME,
            C.COMMODITY_TYPE,
            A.TRANSACTION_TYPE,
            E.SC_NAME,
			B.AMOUNT,
			B.PRICE
		FROM INTERCHANGE_TRANSACTION A,
			IT_SCHEDULE B,
            IT_COMMODITY C,
			IT_STATUS D,
			SCHEDULE_COORDINATOR E,
            TABLE(CAST(v_COMMODITY_TABLE AS ID_TABLE)) F,
            TABLE(CAST(v_CATEGORY_TABLE AS STRING_TABLE)) G
		WHERE B.TRANSACTION_ID = A.TRANSACTION_ID
            AND A.BEGIN_DATE <= p_END_DATE
            AND A.END_DATE >= p_BEGIN_DATE
            AND UPPER(A.TRANSACTION_INTERVAL) = UPPER(p_TRANSACTION_INTERVAL)
            AND UPPER(A.TRANSACTION_TYPE) = UPPER(G.STRING_VAL)
			AND E.SC_ID = A.SC_ID
			AND p_SC_ID IN (CONSTANTS.ALL_ID, E.SC_ID)
            AND C.COMMODITY_ID = A.COMMODITY_ID
            AND C.COMMODITY_ID = F.ID
			--AND UPPER(C.COMMODITY_TYPE) = UPPER(F.STRING_VAL)
			AND D.TRANSACTION_ID = A.TRANSACTION_ID
            AND D.AS_OF_DATE = IT_STATUS_AS_OF_DATE(D.TRANSACTION_ID, p_AS_OF_DATE)
			AND D.TRANSACTION_IS_ACTIVE = 1
			AND (v_ALL_TXNS = 1 OR A.TRANSACTION_ID IN (SELECT IDS.ID FROM TABLE(v_ALLOWED_TXNS) IDS))
			AND (B.SCHEDULE_TYPE = 0 OR B.SCHEDULE_TYPE = p_SCHEDULE_TYPE)
			AND B.SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE
			AND B.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND B.AS_OF_DATE = SCHEDULE_AS_OF_DATE(B.TRANSACTION_ID, B.SCHEDULE_TYPE, B.SCHEDULE_STATE, B.SCHEDULE_DATE, p_AS_OF_DATE)
      AND (v_CONTRACT_FILTER != 1 OR A.Contract_Id = p_CONTRACT_ID)
        ORDER BY 1, 2, 4, 3;

END GET_TRANSACTION_REPORT;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_STATE_AND_TYPE_FROM_MODE
    (
	p_COMPARISON_MODE IN NUMBER,
	p_ALPHA_SCHEDULE_STATE OUT NUMBER,
	p_BETA_SCHEDULE_STATE OUT NUMBER,
	p_ALPHA_SCHEDULE_TYPE OUT NUMBER,
	p_BETA_SCHEDULE_TYPE OUT NUMBER
	) AS
-- COMPARISON MODE:
-- 1 - Forecast-Preliminary
-- 2 - Forecast-Final
-- 3 - Preliminary-Final
-- 4 - Forecast-External
-- 5 - Preliminary-External
-- 6 - Final-External

BEGIN

	--SET UP SCHEDULE STATES DEPENDING ON COMPARISON MODE
	p_ALPHA_SCHEDULE_STATE := CONSTANTS.INTERNAL_STATE;
	IF p_COMPARISON_MODE IN (1,2,3) THEN
		p_BETA_SCHEDULE_STATE := CONSTANTS.INTERNAL_STATE;
	ELSE
		p_BETA_SCHEDULE_STATE := CONSTANTS.EXTERNAL_STATE;
	END IF;

	--SET UP SCHEDULE TYPES DEPENDING ON COMPARISON MODE
	IF p_COMPARISON_MODE = 1 THEN
		p_ALPHA_SCHEDULE_TYPE := 1; --FORECAST
		p_BETA_SCHEDULE_TYPE := 2; --PRELIMINARY
	ELSIF p_COMPARISON_MODE = 2 THEN
		p_ALPHA_SCHEDULE_TYPE := 1; --FORECAST
		p_BETA_SCHEDULE_TYPE := 3; --FINAL
	ELSIF p_COMPARISON_MODE = 3 THEN
		p_ALPHA_SCHEDULE_TYPE := 2; --PRELIMINARY
		p_BETA_SCHEDULE_TYPE := 3; --FINAL
	ELSIF p_COMPARISON_MODE = 4 THEN
		p_ALPHA_SCHEDULE_TYPE := 1; --FORECAST
		p_BETA_SCHEDULE_TYPE := 1; --FORECAST
	ELSIF p_COMPARISON_MODE = 5 THEN
		p_ALPHA_SCHEDULE_TYPE := 2; --PRELIMINARY
		p_BETA_SCHEDULE_TYPE := 2; --PRELIMINARY
	ELSIF p_COMPARISON_MODE = 6 THEN
		p_ALPHA_SCHEDULE_TYPE := 3; --FINAL
		p_BETA_SCHEDULE_TYPE := 3; --FINAL
	END IF;

END GET_STATE_AND_TYPE_FROM_MODE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_TP_CONTRACT_LOAD_SCHEDULES
    (
	p_PSE_IDS IN VARCHAR,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the schedulers for the specified selection criteria.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_WORK_ID NUMBER;
v_TABLE GA.STRING_TABLE;
v_INDEX BINARY_INTEGER;

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	IF NOT UPPER(SUBSTR(p_PSE_IDS,1,5)) = '<ALL>' THEN

		UT.GET_RTO_WORK_ID(v_WORK_ID);
		UT.TOKENS_FROM_STRING(p_PSE_IDS, ';', v_TABLE);

		FOR v_INDEX IN v_TABLE.FIRST..v_TABLE.LAST LOOP
			UT.POST_RTO_WORK(v_WORK_ID, NULL, TO_NUMBER(v_TABLE(v_INDEX)));
		END LOOP;
		v_TABLE.DELETE;

		IF GA.VERSION_SCHEDULE THEN
			OPEN p_CURSOR FOR
				SELECT A.TRANSACTION_NAME, A.TRANSACTION_ID, D.CONTRACT_NAME, D.CONTRACT_NUMBER, D.BEGIN_DATE, D.END_DATE, FROM_CUT_AS_HED(E.SCHEDULE_DATE, p_TIME_ZONE) "SCHEDULE_DATE", E.AMOUNT "AMOUNT"
				FROM INTERCHANGE_TRANSACTION A, RTO_WORK B, INTERCHANGE_CONTRACT C, TP_CONTRACT_NUMBER D,  IT_SCHEDULE E
				WHERE NVL(A.BEGIN_DATE, CONSTANTS.LOW_DATE) <= TRUNC(p_END_DATE)
					AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
					AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) = 'LO'
					AND B.WORK_ID = v_WORK_ID
					AND (A.PURCHASER_ID = B.WORK_XID OR A.SELLER_ID = B.WORK_XID)
					AND C.CONTRACT_ID = A.CONTRACT_ID
					AND C.BEGIN_DATE <= TRUNC(p_END_DATE)
					AND NVL(C.END_DATE, NVL(A.END_DATE, CONSTANTS.HIGH_DATE)) >= TRUNC(p_BEGIN_DATE)
					AND D.CONTRACT_ID = C.CONTRACT_ID
					AND D.BEGIN_DATE >= C.BEGIN_DATE
					AND NVL(D.END_DATE, NVL(C.END_DATE, NVL(A.END_DATE, CONSTANTS.HIGH_DATE))) <= NVL(C.END_DATE, NVL(A.END_DATE, CONSTANTS.HIGH_DATE))
					AND E.TRANSACTION_ID = A.TRANSACTION_ID
					AND (E.SCHEDULE_TYPE = 0 OR E.SCHEDULE_TYPE = p_SCHEDULE_TYPE)
					AND E.SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE
					AND E.SCHEDULE_DATE BETWEEN GREATEST(v_BEGIN_DATE, BEGIN_CUT_DAY_INTERVAL(D.BEGIN_DATE, p_TIME_ZONE)) AND LEAST(v_END_DATE, END_CUT_DAY_INTERVAL(NVL(D.END_DATE, v_END_DATE), p_TIME_ZONE))
					AND E.AS_OF_DATE =
						(SELECT MAX(AS_OF_DATE)
						FROM IT_SCHEDULE
						WHERE TRANSACTION_ID = E.TRANSACTION_ID
							AND SCHEDULE_TYPE = E.SCHEDULE_TYPE
							AND SCHEDULE_STATE = E.SCHEDULE_STATE
							AND SCHEDULE_DATE = E.SCHEDULE_DATE
							AND AS_OF_DATE <= p_AS_OF_DATE)
				ORDER BY A.TRANSACTION_NAME, A.TRANSACTION_ID, D.BEGIN_DATE, D.CONTRACT_NAME, D.CONTRACT_NUMBER, E.SCHEDULE_DATE;
		ELSE
			OPEN p_CURSOR FOR
				SELECT A.TRANSACTION_NAME, A.TRANSACTION_ID, D.CONTRACT_NAME, D.CONTRACT_NUMBER, D.BEGIN_DATE, D.END_DATE, FROM_CUT_AS_HED(E.SCHEDULE_DATE, p_TIME_ZONE) "SCHEDULE_DATE", E.AMOUNT "AMOUNT"
				FROM INTERCHANGE_TRANSACTION A, RTO_WORK B, INTERCHANGE_CONTRACT C, TP_CONTRACT_NUMBER D,  IT_SCHEDULE E
				WHERE NVL(A.BEGIN_DATE, CONSTANTS.LOW_DATE) <= TRUNC(p_END_DATE)
					AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
					AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) = 'LO'
					AND B.WORK_ID = v_WORK_ID
					AND (A.PURCHASER_ID = B.WORK_XID OR A.SELLER_ID = B.WORK_XID)
					AND C.CONTRACT_ID = A.CONTRACT_ID
					AND C.BEGIN_DATE <= TRUNC(p_END_DATE)
					AND NVL(C.END_DATE, NVL(A.END_DATE, CONSTANTS.HIGH_DATE)) >= TRUNC(p_BEGIN_DATE)
					AND D.CONTRACT_ID = C.CONTRACT_ID
					AND D.BEGIN_DATE >= C.BEGIN_DATE
					AND NVL(D.END_DATE, NVL(C.END_DATE, NVL(A.END_DATE, CONSTANTS.HIGH_DATE))) <= NVL(C.END_DATE, NVL(A.END_DATE, CONSTANTS.HIGH_DATE))
					AND E.TRANSACTION_ID = A.TRANSACTION_ID
					AND (E.SCHEDULE_TYPE = 0 OR E.SCHEDULE_TYPE = p_SCHEDULE_TYPE)
					AND E.SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE
					AND E.SCHEDULE_DATE BETWEEN GREATEST(v_BEGIN_DATE, BEGIN_CUT_DAY_INTERVAL(D.BEGIN_DATE, p_TIME_ZONE)) AND LEAST(v_END_DATE, END_CUT_DAY_INTERVAL(NVL(D.END_DATE, v_END_DATE), p_TIME_ZONE))
					AND E.AS_OF_DATE = CONSTANTS.LOW_DATE
				ORDER BY A.TRANSACTION_NAME, A.TRANSACTION_ID, D.BEGIN_DATE, D.CONTRACT_NAME, D.CONTRACT_NUMBER, E.SCHEDULE_DATE;
		END IF;
		UT.PURGE_RTO_WORK(v_WORK_ID);
	ELSE
		IF GA.VERSION_SCHEDULE THEN
			OPEN p_CURSOR FOR
				SELECT A.TRANSACTION_NAME, A.TRANSACTION_ID, C.CONTRACT_NAME, C.CONTRACT_NUMBER, C.BEGIN_DATE, C.END_DATE, FROM_CUT_AS_HED(D.SCHEDULE_DATE, p_TIME_ZONE) "SCHEDULE_DATE", D.AMOUNT "AMOUNT"
				FROM INTERCHANGE_TRANSACTION A, INTERCHANGE_CONTRACT B, TP_CONTRACT_NUMBER C,  IT_SCHEDULE D
				WHERE NVL(A.BEGIN_DATE, CONSTANTS.LOW_DATE) <= TRUNC(p_END_DATE)
					AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
					AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) = 'LO'
					AND B.CONTRACT_ID = A.CONTRACT_ID
					AND B.BEGIN_DATE <= TRUNC(p_END_DATE)
					AND NVL(B.END_DATE, NVL(A.END_DATE, CONSTANTS.HIGH_DATE)) >= TRUNC(p_BEGIN_DATE)
					AND C.CONTRACT_ID = B.CONTRACT_ID
					AND C.BEGIN_DATE >= B.BEGIN_DATE
					AND NVL(C.END_DATE, NVL(B.END_DATE, NVL(A.END_DATE, CONSTANTS.HIGH_DATE))) <= NVL(B.END_DATE, NVL(A.END_DATE, CONSTANTS.HIGH_DATE))
					AND D.TRANSACTION_ID = A.TRANSACTION_ID
					AND (D.SCHEDULE_TYPE = 0 OR D.SCHEDULE_TYPE = p_SCHEDULE_TYPE)
					AND D.SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE
					AND D.SCHEDULE_DATE BETWEEN GREATEST(v_BEGIN_DATE, BEGIN_CUT_DAY_INTERVAL(C.BEGIN_DATE, p_TIME_ZONE)) AND LEAST(v_END_DATE, END_CUT_DAY_INTERVAL(NVL(C.END_DATE, v_END_DATE), p_TIME_ZONE))
					AND D.AS_OF_DATE =
						(SELECT MAX(AS_OF_DATE)
						FROM IT_SCHEDULE
						WHERE TRANSACTION_ID = D.TRANSACTION_ID
							AND SCHEDULE_TYPE = D.SCHEDULE_TYPE
							AND SCHEDULE_STATE = D.SCHEDULE_STATE
							AND SCHEDULE_DATE = D.SCHEDULE_DATE
							AND AS_OF_DATE <= p_AS_OF_DATE)
				ORDER BY A.TRANSACTION_NAME, A.TRANSACTION_ID, C.BEGIN_DATE, C.CONTRACT_NAME, C.CONTRACT_NUMBER, D.SCHEDULE_DATE;
		ELSE
			OPEN p_CURSOR FOR
				SELECT A.TRANSACTION_NAME, A.TRANSACTION_ID, C.CONTRACT_NAME, C.CONTRACT_NUMBER, C.BEGIN_DATE, C.END_DATE, FROM_CUT_AS_HED(D.SCHEDULE_DATE, p_TIME_ZONE) "SCHEDULE_DATE", D.AMOUNT "AMOUNT"
				FROM INTERCHANGE_TRANSACTION A, INTERCHANGE_CONTRACT B, TP_CONTRACT_NUMBER C,  IT_SCHEDULE D
				WHERE NVL(A.BEGIN_DATE, CONSTANTS.LOW_DATE) <= TRUNC(p_END_DATE)
					AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
					AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) = 'LO'
					AND B.CONTRACT_ID = A.CONTRACT_ID
					AND B.BEGIN_DATE <= TRUNC(p_END_DATE)
					AND NVL(B.END_DATE, NVL(A.END_DATE, CONSTANTS.HIGH_DATE)) >= TRUNC(p_BEGIN_DATE)
					AND C.CONTRACT_ID = B.CONTRACT_ID
					AND C.BEGIN_DATE >= B.BEGIN_DATE
					AND NVL(C.END_DATE, NVL(B.END_DATE, NVL(A.END_DATE, CONSTANTS.HIGH_DATE))) <= NVL(B.END_DATE, NVL(A.END_DATE, CONSTANTS.HIGH_DATE))
					AND D.TRANSACTION_ID = A.TRANSACTION_ID
					AND (D.SCHEDULE_TYPE = 0 OR D.SCHEDULE_TYPE = p_SCHEDULE_TYPE)
					AND D.SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE
					AND D.SCHEDULE_DATE BETWEEN GREATEST(v_BEGIN_DATE, BEGIN_CUT_DAY_INTERVAL(C.BEGIN_DATE, p_TIME_ZONE)) AND LEAST(v_END_DATE, END_CUT_DAY_INTERVAL(NVL(C.END_DATE, v_END_DATE), p_TIME_ZONE))
					AND D.AS_OF_DATE = CONSTANTS.LOW_DATE
				ORDER BY A.TRANSACTION_NAME, A.TRANSACTION_ID, C.BEGIN_DATE, C.CONTRACT_NAME, C.CONTRACT_NUMBER, D.SCHEDULE_DATE;
		END IF;
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			UT.PURGE_RTO_WORK(v_WORK_ID);
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE();
		END;
		ERRS.LOG_AND_RAISE();

END GET_TP_CONTRACT_LOAD_SCHEDULES;
---------------------------------------------------------------------------------------------------
PROCEDURE DATE_RANGE
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_MINUTES IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer a date range of local date and times.
--DEPRECATED.  USE UT.DATE_RANGE INSTEAD.
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_WORK_ID NUMBER;

BEGIN

    p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	UT.GET_RTO_WORK_ID(v_WORK_ID);
	UT.POST_RTO_WORK_DATE_RANGE(v_WORK_ID, v_BEGIN_DATE, v_END_DATE, p_MINUTES);

	OPEN p_CURSOR FOR
	    SELECT FROM_CUT_AS_HED(WORK_DATE, p_TIME_ZONE)
		FROM RTO_WORK
		WHERE WORK_ID = v_WORK_ID
		ORDER BY 1;

	UT.PURGE_RTO_WORK(v_WORK_ID);

EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			UT.PURGE_RTO_WORK(v_WORK_ID);
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE();
		END;
		ERRS.LOG_AND_RAISE();

END DATE_RANGE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_PHYSICAL_POSITION
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_COMMODITY_TYPE IN VARCHAR,
	p_SCHEDULE_TYPE IN NUMBER,
	p_PORPOD_TYPE IN VARCHAR,
	p_POD_ID IN NUMBER,
	p_POR_ID IN NUMBER,
	p_PURCHASER_ID IN NUMBER,
	p_SELLER_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_TP_ID IN NUMBER,
	p_ROLLUP_ID_1 IN NUMBER,
	p_ROLLUP_ID_2 IN NUMBER,
	p_ROLLUP_ID_3 IN NUMBER,
	p_ROLLUP_ID_4 IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the physical position based upon the specified filtering criteria.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_INTERVAL_CODE NUMBER;
v_HED_INTERVAL VARCHAR2(8);

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
    SELECT DECODE(UPPER(SUBSTR(p_INTERVAL,1,2)),'5 ',1,'10',2,'15',3,'30',4,'HO',5,'DA',6,'WE',7,'MO',8,'QU',9,'YE',10,0)
    INTO v_INTERVAL_CODE FROM DUAL;
    SELECT DECODE(UPPER(SUBSTR(p_INTERVAL,1,2)),'5 ','MI5','10','MI10','15','MI15','30','MI30','HO','HH','DA','DD','WE','DY','MO','MM','QU','QQ','YE','YY','HH')
    INTO v_HED_INTERVAL FROM DUAL;

	OPEN p_CURSOR FOR

        SELECT SUBSTR(TRIM(FROM_CUT_AS_HED (SCHEDULE_DATE, p_TIME_ZONE, v_HED_INTERVAL)), 0, 10) "DATE",
            SUBSTR(TRIM(FROM_CUT_AS_HED (SCHEDULE_DATE, p_TIME_ZONE, v_HED_INTERVAL)), 12) "TIME",
            SUM(LOAD) "LOAD",
			SUM(GENERATION) "GENERATION",
			SUM(PURCHASE_AMOUNT) "PURCHASES",
			SUM(SALE_AMOUNT) "SALES",
			SUM(PASS_THRU_AMOUNT) "PASS_THRU_AMOUNT"
		FROM PHYSICAL_POSITION A,
		     IT_STATUS B,
		     SERVICE_POINT C
		WHERE A.COMMODITY_TYPE = p_COMMODITY_TYPE
			AND DECODE(UPPER(SUBSTR(A.TRANSACTION_INTERVAL,1,2)),'5 ',1,'10',2,'15',3,'30',4,'HO',5,'DA',6,'WE',7,'MO',8,'QU',9,'YE',10,0) <= v_INTERVAL_CODE
			AND A.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND (A.SCHEDULE_TYPE = 0 OR A.SCHEDULE_TYPE = p_SCHEDULE_TYPE)
			AND (p_POR_ID = CONSTANTS.ALL_ID OR A.POR_ID = p_POR_ID)
			AND (p_POD_ID = CONSTANTS.ALL_ID OR A.POD_ID = p_POD_ID)
			AND C.SERVICE_POINT_ID = A.POR_ID
			AND (UPPER(p_PORPOD_TYPE) = '<ALL>' OR UPPER(A.SERVICE_POINT_TYPE) = UPPER(p_PORPOD_TYPE) OR UPPER(C.SERVICE_POINT_TYPE) = UPPER(p_PORPOD_TYPE))
			AND (p_PURCHASER_ID = CONSTANTS.ALL_ID OR A.PURCHASER_ID = p_PURCHASER_ID)
			AND (p_SELLER_ID = CONSTANTS.ALL_ID OR A.SELLER_ID = p_SELLER_ID)
			AND (p_EDC_ID = CONSTANTS.ALL_ID OR A.EDC_ID = p_EDC_ID)
			AND (p_TP_ID = CONSTANTS.ALL_ID OR A.TP_ID = p_TP_ID)
			AND (p_ROLLUP_ID_1 = CONSTANTS.ALL_ID OR p_ROLLUP_ID_1 IS NULL OR A.ROLLUP_ID_1 = p_ROLLUP_ID_1)
			AND (p_ROLLUP_ID_2 = CONSTANTS.ALL_ID OR p_ROLLUP_ID_2 IS NULL OR A.ROLLUP_ID_2 = p_ROLLUP_ID_2)
			AND (p_ROLLUP_ID_3 = CONSTANTS.ALL_ID OR p_ROLLUP_ID_3 IS NULL OR A.ROLLUP_ID_3 = p_ROLLUP_ID_3)
			AND (p_ROLLUP_ID_4 = CONSTANTS.ALL_ID OR p_ROLLUP_ID_4 IS NULL OR A.ROLLUP_ID_4 = p_ROLLUP_ID_4)
			AND A.AS_OF_DATE = SCHEDULE_AS_OF_DATE (A.TRANSACTION_ID, A.SCHEDULE_TYPE, A.SCHEDULE_STATE, A.SCHEDULE_DATE, p_AS_OF_DATE)
			AND B.TRANSACTION_ID = A.TRANSACTION_ID
			AND B.AS_OF_DATE = IT_STATUS_AS_OF_DATE (B.TRANSACTION_ID, p_AS_OF_DATE)
			AND B.TRANSACTION_IS_ACTIVE = 1
			AND A.SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE
		GROUP BY FROM_CUT_AS_HED(SCHEDULE_DATE, p_TIME_ZONE, v_HED_INTERVAL)
		ORDER BY 1,2;


END GET_PHYSICAL_POSITION;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_NET_INTERCHANGE
    (
	p_CA_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	OPEN p_CURSOR FOR
		SELECT DECODE(D.IS_INTERCONNECT,1,D.SERVICE_POINT_NAME,C.SERVICE_POINT_NAME) "SERVICE_POINT_NAME",
			DECODE(D.IS_INTERCONNECT,1,D.SERVICE_POINT_ID,C.SERVICE_POINT_ID) "SERVICE_POINT_ID",
			FROM_CUT_AS_HED(E.SCHEDULE_DATE, p_TIME_ZONE),
			SUM(E.AMOUNT * (DECODE(D.IS_INTERCONNECT,1,DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)),'LO',1,'SA',1,-1),
				DECODE(C.IS_INTERCONNECT,1,DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)),'LO',-1,'SA',-1,1),0)))) "NET_AMOUNT"
		FROM INTERCHANGE_TRANSACTION A,
			IT_COMMODITY B,
			SERVICE_POINT C,
			SERVICE_POINT D,
			IT_SCHEDULE E
		WHERE A.BEGIN_DATE <= v_END_DATE
			AND A.END_DATE >= v_BEGIN_DATE
			AND UPPER(A.TRANSACTION_INTERVAL) = 'HOUR'
			AND B.COMMODITY_ID = A.COMMODITY_ID
			AND UPPER(B.COMMODITY_TYPE) = 'ENERGY'
			AND C.SERVICE_POINT_ID = A.POR_ID
			AND D.SERVICE_POINT_ID = A.POD_ID
			AND ((p_CA_ID = CONSTANTS.ALL_ID AND (C.IS_INTERCONNECT = 1 OR D.IS_INTERCONNECT = 1)) OR (C.CA_ID = p_CA_ID AND C.IS_INTERCONNECT = 1) OR (D.CA_ID = p_CA_ID AND D.IS_INTERCONNECT = 1))
			AND E.TRANSACTION_ID =A.TRANSACTION_ID
			AND E.SCHEDULE_TYPE IN (0, p_SCHEDULE_TYPE)
			AND E.SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE
			AND E.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND E.AS_OF_DATE = SCHEDULE_AS_OF_DATE(E.TRANSACTION_ID, E.SCHEDULE_TYPE, E.SCHEDULE_STATE, E.SCHEDULE_DATE, p_AS_OF_DATE)
		GROUP BY DECODE(D.IS_INTERCONNECT,1,D.SERVICE_POINT_NAME,C.SERVICE_POINT_NAME),
			DECODE(D.IS_INTERCONNECT,1,D.SERVICE_POINT_ID,C.SERVICE_POINT_ID),
			E.SCHEDULE_DATE
		ORDER BY 1,3;


END GET_NET_INTERCHANGE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_LOAD_DIFFERENTIAL_FOR_EDC
	(
	p_PSE_ID_LIST IN VARCHAR2,
	p_SCHEDULE_TYPE IN NUMBER,
    p_SCHEDULE_STATE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_AS_OF_DATE IN DATE,
	p_DATE_ADJ IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

v_WORK_ID NUMBER;
v_IDs_TABLE GA.STRING_TABLE;
v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN
	UT.GET_RTO_WORK_ID (v_WORK_ID);

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;
	p_STATUS := GA.SUCCESS;
	IF p_SCHEDULE_TYPE < 0 THEN
		-- if -1 schedule type then return empty recordset
		OPEN p_CURSOR FOR
			SELECT 1 FROM DUAL WHERE 1 < 0;
		RETURN;
	END IF;
	UT.TOKENS_FROM_STRING(p_PSE_ID_LIST, ';', v_IDs_TABLE);
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	FOR v_INDEX IN v_IDs_TABLE.FIRST..v_IDs_TABLE.LAST LOOP
		UT.POST_RTO_WORK (v_WORK_ID, 0, TO_NUMBER(v_IDs_TABLE(v_INDEX)));
	END LOOP;

	OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(D.SCHEDULE_DATE+p_DATE_ADJ,p_TIME_ZONE) "DATE",
			B.PSE_NAME,
			B.PSE_ID,
			SUM(D.AMOUNT) "AMOUNT"
		FROM RTO_WORK A,
			PURCHASING_SELLING_ENTITY B,
			INTERCHANGE_TRANSACTION C,
			IT_SCHEDULE D
		WHERE WORK_ID = v_WORK_ID
			AND B.PSE_ID = WORK_XID
			AND UPPER(SUBSTR(C.TRANSACTION_TYPE,1,2)) IN ('LO', 'RE') -- 'Load' or 'Retail Load'
			AND (C.PURCHASER_ID = B.PSE_ID OR C.SELLER_ID = B.PSE_ID)
			AND D.TRANSACTION_ID = C.TRANSACTION_ID
			AND D.SCHEDULE_TYPE = p_SCHEDULE_TYPE
			AND D.SCHEDULE_STATE = p_SCHEDULE_STATE
			AND D.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND D.AS_OF_DATE = SCHEDULE_AS_OF_DATE(D.TRANSACTION_ID, D.SCHEDULE_TYPE, D.SCHEDULE_STATE, D.SCHEDULE_DATE, p_AS_OF_DATE)
		GROUP BY FROM_CUT_AS_HED(D.SCHEDULE_DATE+p_DATE_ADJ,p_TIME_ZONE), B.PSE_NAME, B.PSE_ID
		ORDER BY 1, 2, 3;

	UT.PURGE_RTO_WORK (v_WORK_ID);

EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			UT.PURGE_RTO_WORK(v_WORK_ID);
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE();
		END;
		ERRS.LOG_AND_RAISE();

END GET_LOAD_DIFFERENTIAL_FOR_EDC;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_LOAD_DIFFERENTIAL_FOR_ESP
	(
	p_EDC_ID_LIST IN VARCHAR2,
	p_SCHEDULE_TYPE IN NUMBER,
    p_SCHEDULE_STATE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_AS_OF_DATE IN DATE,
	p_DATE_ADJ IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

v_WORK_ID NUMBER;
v_IDs_TABLE GA.STRING_TABLE;
v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN
	UT.GET_RTO_WORK_ID (v_WORK_ID);

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;
	p_STATUS := GA.SUCCESS;
	IF p_SCHEDULE_TYPE < 0 THEN
		-- if -1 schedule type then return empty recordset
		OPEN p_CURSOR FOR
			SELECT 1 FROM DUAL WHERE 1 < 0;
		RETURN;
	END IF;
	UT.TOKENS_FROM_STRING(p_EDC_ID_LIST, ';', v_IDs_TABLE);
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	FOR v_INDEX IN v_IDs_TABLE.FIRST..v_IDs_TABLE.LAST LOOP
		UT.POST_RTO_WORK (v_WORK_ID, 0, TO_NUMBER(v_IDs_TABLE(v_INDEX)));
	END LOOP;

	OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(E.SCHEDULE_DATE+p_DATE_ADJ,p_TIME_ZONE) "DATE",
			B.EDC_NAME "PSE_NAME",
			B.EDC_ID "PSE_ID",
			SUM(E.AMOUNT) "AMOUNT"
		FROM RTO_WORK A,
			ENERGY_DISTRIBUTION_COMPANY B,
			SERVICE_POINT C,
			INTERCHANGE_TRANSACTION D,
			IT_SCHEDULE E
		WHERE WORK_ID = v_WORK_ID
			AND B.EDC_ID = WORK_XID
			AND C.EDC_ID = B.EDC_ID
			AND UPPER(SUBSTR(D.TRANSACTION_TYPE,1,2)) IN ('LO', 'RE') -- 'Load' or 'Retail Load'
			AND (D.POR_ID = C.SERVICE_POINT_ID OR D.POD_ID = C.SERVICE_POINT_ID)
			AND E.TRANSACTION_ID = D.TRANSACTION_ID
			AND E.SCHEDULE_TYPE = p_SCHEDULE_TYPE
			AND E.SCHEDULE_STATE = p_SCHEDULE_STATE
			AND E.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND E.AS_OF_DATE = SCHEDULE_AS_OF_DATE(E.TRANSACTION_ID, E.SCHEDULE_TYPE, E.SCHEDULE_STATE, E.SCHEDULE_DATE, p_AS_OF_DATE)
		GROUP BY FROM_CUT_AS_HED(E.SCHEDULE_DATE+p_DATE_ADJ,p_TIME_ZONE), B.EDC_NAME, B.EDC_ID
		ORDER BY 1, 2, 3;

	UT.PURGE_RTO_WORK (v_WORK_ID);

EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			UT.PURGE_RTO_WORK(v_WORK_ID);
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE();
		END;
		ERRS.LOG_AND_RAISE();

END GET_LOAD_DIFFERENTIAL_FOR_ESP;
---------------------------------------------------------------------------------------------------
PROCEDURE ENTITY_ATTRIBUTES
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the names of Entity Attributes that are available as a filter of transactions.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT DISTINCT A.ATTRIBUTE_NAME,
			A.ATTRIBUTE_ID,
			B.ATTRIBUTE_VAL
		FROM ENTITY_ATTRIBUTE A,
			TEMPORAL_ENTITY_ATTRIBUTE B,
			INTERCHANGE_TRANSACTION C
		WHERE A.ENTITY_DOMAIN_ID = -200
			AND UPPER(SUBSTR(A.ATTRIBUTE_TYPE,1,1)) = 'S'
			AND B.ATTRIBUTE_ID = A.ATTRIBUTE_ID
			AND B.OWNER_ENTITY_ID = C.TRANSACTION_ID
			AND C.BEGIN_DATE <= p_END_DATE AND C.END_DATE >= p_BEGIN_DATE
		ORDER BY A.ATTRIBUTE_NAME, B.ATTRIBUTE_VAL;


END ENTITY_ATTRIBUTES;
---------------------------------------------------------------------------------------------------
PROCEDURE POSITION_ROLLUPS
    (
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the names and IDs of Rollups linked to INTERCHANGE_TRANSACTIONS that lie in the given date range

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT DISTINCT C.ROLLUP_1, C.ROLLUP_ID_1,
			C.ROLLUP_2, C.ROLLUP_ID_2,
			C.ROLLUP_3, C.ROLLUP_ID_3,
			C.ROLLUP_4, C.ROLLUP_ID_4
		FROM INTERCHANGE_TRANSACTION A,
			SERVICE_POINT B,
			RTO_ROLLUP_HIERARCHY C
		WHERE A.POD_ID = B.SERVICE_POINT_ID
			AND B.ROLLUP_ID = C.ROLLUP_ID_1
		ORDER BY 1, 3, 5, 7;


END POSITION_ROLLUPS;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_TRANSACTION_POD
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER
	) AS

BEGIN

	UPDATE INTERCHANGE_TRANSACTION SET
		POD_ID = p_SERVICE_POINT_ID,
		ENTRY_DATE = SYSDATE
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

END PUT_TRANSACTION_POD;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_TRANSACTION_POR
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SERVICE_POINT_ID IN NUMBER
	) AS

BEGIN

	UPDATE INTERCHANGE_TRANSACTION SET
		POR_ID = p_SERVICE_POINT_ID,
		ENTRY_DATE = SYSDATE
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

END PUT_TRANSACTION_POR;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_TRANSACTION_PURCHASER
	(
	p_TRANSACTION_ID IN NUMBER,
	p_PSE_ID IN NUMBER
	) AS

BEGIN

	UPDATE INTERCHANGE_TRANSACTION SET
		PURCHASER_ID = p_PSE_ID,
		ENTRY_DATE = SYSDATE
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

END PUT_TRANSACTION_PURCHASER;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_TRANSACTION_SELLER
	(
	p_TRANSACTION_ID IN NUMBER,
	p_PSE_ID IN NUMBER
	) AS

BEGIN

	UPDATE INTERCHANGE_TRANSACTION SET
		SELLER_ID = p_PSE_ID,
		ENTRY_DATE = SYSDATE
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

END PUT_TRANSACTION_SELLER;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_IT_STATUS
	(
	p_TRANSACTION_ID IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_TRANSACTION_STATUS_NAME OUT VARCHAR,
	p_TRANSACTION_IS_ACTIVE OUT NUMBER,
	p_STATUS OUT NUMBER
	) AS

v_AS_OF_DATE DATE := CONSTANTS.LOW_DATE;

BEGIN
	p_STATUS := GA.SUCCESS;

	IF GA.VERSION_SCHEDULE THEN
		BEGIN
			SELECT MAX(AS_OF_DATE)
			INTO v_AS_OF_DATE
			FROM IT_STATUS
			WHERE TRANSACTION_ID = p_TRANSACTION_ID
				AND AS_OF_DATE <= p_AS_OF_DATE;

			EXCEPTION
				WHEN NO_DATA_FOUND THEN
					ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
					v_AS_OF_DATE := p_AS_OF_DATE;
		END;
	END IF;

	SELECT TRANSACTION_STATUS_NAME, TRANSACTION_IS_ACTIVE
		INTO p_TRANSACTION_STATUS_NAME, p_TRANSACTION_IS_ACTIVE
	FROM IT_STATUS
	WHERE TRANSACTION_ID = p_TRANSACTION_ID
		AND AS_OF_DATE = v_AS_OF_DATE;


END GET_IT_STATUS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_IT_STATUS
	(
	p_TRANSACTION_ID IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_TRANSACTION_STATUS_NAME IN VARCHAR,
	p_TRANSACTION_IS_ACTIVE IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

v_AS_OF_DATE DATE;

BEGIN
	p_STATUS := GA.SUCCESS;

	IF GA.VERSION_SCHEDULE THEN
		v_AS_OF_DATE := CORRECTED_AS_OF_DATE(p_AS_OF_DATE);
	ELSE
		v_AS_OF_DATE := CONSTANTS.LOW_DATE;
	END IF;

	UPDATE IT_STATUS
	SET TRANSACTION_STATUS_NAME = p_TRANSACTION_STATUS_NAME,
		TRANSACTION_IS_ACTIVE = p_TRANSACTION_IS_ACTIVE
	WHERE TRANSACTION_ID = p_TRANSACTION_ID
		AND AS_OF_DATE = v_AS_OF_DATE;

	IF SQL%NOTFOUND THEN
		INSERT INTO IT_STATUS (
			TRANSACTION_ID,
			AS_OF_DATE,
			TRANSACTION_STATUS_NAME,
			TRANSACTION_IS_ACTIVE)
		VALUES (
			p_TRANSACTION_ID,
			v_AS_OF_DATE,
			p_TRANSACTION_STATUS_NAME,
			p_TRANSACTION_IS_ACTIVE);
	END IF;


END PUT_IT_STATUS;
----------------------------------------------------------------------------------------------------
PROCEDURE IT_STATUS_LIST
	(
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT TRANSACTION_STATUS_NAME, TRANSACTION_IS_ACTIVE
        FROM INTERCHANGE_TRANSACTION_STATUS
        ORDER BY TRANSACTION_STATUS_NAME;
END IT_STATUS_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE IT_STATUS_NAME_LIST
	(
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT TRANSACTION_STATUS_NAME FROM INTERCHANGE_TRANSACTION_STATUS ORDER BY TRANSACTION_STATUS_NAME;
END IT_STATUS_NAME_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE COMPARE_TRANSACTION_STATE
	(
	p_TRANSACTION_ID IN NUMBER,
    p_SCHEDULE_TYPE1 IN NUMBER,
    p_SCHEDULE_STATE1 IN NUMBER,
    p_SCHEDULE_TYPE2 IN NUMBER,
    p_SCHEDULE_STATE2 IN NUMBER,
	p_CONTRACT_NAME IN VARCHAR,
	p_CONTRACT_NUMBER IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_ALPHA_SCHEDULE_STATE NUMBER;
v_BETA_SCHEDULE_STATE NUMBER;
v_ALPHA_SCHEDULE_TYPE NUMBER;
v_BETA_SCHEDULE_TYPE NUMBER;
v_INTERVAL VARCHAR2(16);

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    IF p_TRANSACTION_ID IS NULL OR p_TRANSACTION_ID = CONSTANTS.NOT_ASSIGNED OR p_TRANSACTION_ID = -1 THEN
		ERRS.RAISE(MSGCODES.c_ERR_ARGUMENT, 'The Transaction ID = ' || p_TRANSACTION_ID || ' is invalid INVALID_TRANSACTION_ID');
	END IF;

	p_STATUS := GA.SUCCESS;
	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

    v_ALPHA_SCHEDULE_TYPE := p_SCHEDULE_TYPE1;
    v_ALPHA_SCHEDULE_STATE := p_SCHEDULE_STATE1;
	v_BETA_SCHEDULE_TYPE := p_SCHEDULE_TYPE2;
    v_BETA_SCHEDULE_STATE := p_SCHEDULE_STATE2;

	SELECT DECODE(UPPER(SUBSTR(TRANSACTION_INTERVAL,1,2)),'5 ','MI5','10','MI5','15','MI5','20','MI5','30','MI5','HO','HH','DA','DD','WE','DD','MO','DD','QU','DD','YE','DD')
	INTO v_INTERVAL
	FROM INTERCHANGE_TRANSACTION
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

	    OPEN p_CURSOR FOR
            SELECT DISTINCT SUBSTR(FROM_CUT_AS_HED(C.SCHEDULE_DATE, p_TIME_ZONE, v_INTERVAL),1,10)  "Date",
                SUBSTR(FROM_CUT_AS_HED(C.SCHEDULE_DATE, p_TIME_ZONE, v_INTERVAL),12) "Time",
                A.TRANSACTION_ID,
                A.TRANSACTION_NAME,
                D.AMOUNT "Alpha",
                E.AMOUNT "Beta",
                NVL(D.AMOUNT,0) - NVL(E.AMOUNT,0) "Difference",
                ROUND(DECODE(NVL(D.AMOUNT,0),0,NULL,(NVL(D.AMOUNT,0)-NVL(E.AMOUNT,0))/D.AMOUNT),16) "Difference_Pct"
            FROM INTERCHANGE_TRANSACTION A, TP_CONTRACT_NUMBER B, IT_SCHEDULE C, IT_SCHEDULE D, IT_SCHEDULE E
            WHERE A.TRANSACTION_ID = p_TRANSACTION_ID
                AND B.CONTRACT_ID(+) = A.CONTRACT_ID
                AND B.CONTRACT_NAME(+) = p_CONTRACT_NAME
                AND B.CONTRACT_NUMBER(+) = p_CONTRACT_NUMBER
                AND B.BEGIN_DATE(+) <= TRUNC(p_END_DATE)
                AND NVL(B.END_DATE(+), CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
                AND C.TRANSACTION_ID = A.TRANSACTION_ID
                AND C.SCHEDULE_TYPE IN (v_ALPHA_SCHEDULE_TYPE, v_BETA_SCHEDULE_TYPE)
                AND C.SCHEDULE_STATE IN (v_ALPHA_SCHEDULE_STATE, v_BETA_SCHEDULE_STATE)
                AND C.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
                AND CUT_DATE_BETWEEN(C.SCHEDULE_DATE, B.BEGIN_DATE, B.END_DATE, p_TIME_ZONE) = 'Y'
                AND C.AS_OF_DATE = CONSTANTS.LOW_DATE
                AND D.TRANSACTION_ID(+) = C.TRANSACTION_ID
                AND D.SCHEDULE_TYPE(+) = v_ALPHA_SCHEDULE_TYPE
                AND D.SCHEDULE_STATE(+) = v_ALPHA_SCHEDULE_STATE
                AND D.SCHEDULE_DATE(+) = C.SCHEDULE_DATE
                AND D.AS_OF_DATE(+) = C.AS_OF_DATE
                AND E.TRANSACTION_ID(+) = C.TRANSACTION_ID
                AND E.SCHEDULE_TYPE(+) = v_BETA_SCHEDULE_TYPE
                AND E.SCHEDULE_STATE(+) = v_BETA_SCHEDULE_STATE
                AND E.SCHEDULE_DATE(+) = C.SCHEDULE_DATE
                AND E.AS_OF_DATE(+) = C.AS_OF_DATE
            ORDER BY 1, 2;


END COMPARE_TRANSACTION_STATE;
----------------------------------------------------------------------------------------------------
PROCEDURE TRANSACTION_ID_FOR_CONTRACT
	(
	p_CONTRACTS IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

v_CONTRACTS GA.STRING_TABLE;
v_WORK_ID NUMBER;
v_INDEX BINARY_INTEGER;

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	UT.TOKENS_FROM_STRING(p_CONTRACTS, ',', v_CONTRACTS);
	UT.GET_RTO_WORK_ID(v_WORK_ID);

	FOR v_INDEX IN v_CONTRACTS.FIRST..v_CONTRACTS.LAST LOOP
		IF v_CONTRACTS.EXISTS(v_INDEX) THEN
			UT.POST_RTO_WORK(v_WORK_ID, v_INDEX, UPPER(v_CONTRACTS(v_INDEX)));
		END IF;
	END LOOP;

	OPEN p_CURSOR FOR
		SELECT DISTINCT A.CONTRACT_NUMBER, C.TRANSACTION_ID
		FROM TP_CONTRACT_NUMBER A,
			INTERCHANGE_CONTRACT B,
			INTERCHANGE_TRANSACTION C
		WHERE UPPER(A.CONTRACT_NUMBER) IN (SELECT WORK_DATA FROM RTO_WORK WHERE WORK_ID = v_WORK_ID)
			AND B.CONTRACT_ID = A.CONTRACT_ID
			AND C.CONTRACT_ID = B.CONTRACT_ID;

	UT.PURGE_RTO_WORK(v_WORK_ID);

EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			UT.PURGE_RTO_WORK(v_WORK_ID);
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE();
		END;
		ERRS.LOG_AND_RAISE();

END TRANSACTION_ID_FOR_CONTRACT;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SUB_STATION_TREE
	(
	p_SEARCH_STRING IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_IDs ID_TABLE;
BEGIN

	v_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_SSMETER_SELECT, EC.ED_SUB_STATION_METER);

	OPEN p_CURSOR FOR
		SELECT DISTINCT SS.SUB_STATION_NAME, SS.SUB_STATION_ID,
			M.METER_NAME, M.METER_ID,
			MP.METER_POINT_NAME, MP.METER_POINT_ID
		FROM TX_SUB_STATION SS,
			TX_SUB_STATION_METER M,
			TABLE(CAST(v_IDs as ID_TABLE)) IDs,
			TX_SUB_STATION_METER_POINT MP
		WHERE SS.BEGIN_DATE <= p_END_DATE
			AND NVL(SS.END_DATE,CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND M.SUB_STATION_ID = SS.SUB_STATION_ID
			AND M.BEGIN_DATE <= p_END_DATE
			AND NVL(M.END_DATE,CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND IDs.ID IN (M.METER_ID, SD.g_ALL_DATA_ENTITY_ID)
			AND MP.SUB_STATION_METER_ID = M.METER_ID
			AND MP.BEGIN_DATE <= p_END_DATE
			AND NVL(MP.END_DATE,CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND (p_SEARCH_STRING IS NULL OR MP.METER_POINT_NAME LIKE p_SEARCH_STRING)
		ORDER BY 1, 2, 3, 4, 5, 6;

END GET_SUB_STATION_TREE;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SUB_STATION_DATA
	(
	p_SUB_STATION_ID NUMBER,
	p_METER_ID NUMBER,
	p_METER_POINT_ID NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_METER_CODE IN VARCHAR2,
	p_INTERVAL IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_LEVEL NUMBER(9);
v_METER_ID		NUMBER(9);
v_IDs			ID_TABLE;
v_INTERVAL		VARCHAR2(16);
v_BEGIN_DATE	DATE;
v_END_DATE		DATE;
v_METER_CODE	CHAR(1) := SUBSTR(p_METER_CODE,1,1);
v_INTERVAL_NUM	NUMBER := GET_INTERVAL_NUMBER('Hour');
v_LOCKING_ENABLED NUMBER := AUDIT_TRAIL.IS_TABLE_LOCKING_ENABLED(ENTITY_UTIL.TABLE_ID_FOR_DB_TABLE('TX_SUB_STATION_METER_PT_VALUE'));
BEGIN

	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, p_BEGIN_DATE, p_END_DATE);

	CASE
		WHEN p_METER_POINT_ID IS NOT NULL THEN
			SELECT SUB_STATION_METER_ID
			INTO v_METER_ID
			FROM TX_SUB_STATION_METER_POINT
			WHERE METER_POINT_ID = p_METER_POINT_ID;
			-- now verify against the data point's meter
			SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SSMETER_SELECT, v_METER_ID, EC.ED_SUB_STATION_METER);
			v_LEVEL := c_LEVEL_SUBSTATION_METER_POINT;
		WHEN p_METER_ID IS NOT NULL THEN
			SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SSMETER_SELECT, p_METER_ID, EC.ED_SUB_STATION_METER);
			v_LEVEL := c_LEVEL_SUBSTATION_METER;
		WHEN p_SUB_STATION_ID IS NOT NULL THEN
			v_LEVEL := c_LEVEL_SUBSTATION;
		ELSE
			NULL_CURSOR(p_CURSOR);
			RETURN;
	END CASE;

	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	v_INTERVAL := NVL(GET_INTERVAL_ABBREVIATION(p_INTERVAL),'HH');

	IF v_LEVEL = c_LEVEL_SUBSTATION THEN
		-- only show allowed meters
		v_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_SSMETER_SELECT, EC.ED_SUB_STATION_METER);

		-- get list of all meters for specified sub-station with their rolled up volumes (i.e. summarize data point values)
		OPEN p_CURSOR FOR
			SELECT M.DISPLAY_DATE,
				M.SUB_STATION_NAME,
				M.METER_NAME,
				M.METER_ID,
				SUM(DECODE(M.OPERATION_CODE,'S',-1,1)*V.METER_VAL) as METER_VAL,
				SUM(DECODE(M.OPERATION_CODE,'S',-1,1)*V.TRUNCATED_VAL) as TRUNCATED_VAL,
				SECURITY_CONTROLS.GET_EFFECTIVE_LOCK_STATE(MIN(V.LOCK_STATE),v_LOCKING_ENABLED) as LOCK_STATE
			FROM (SELECT SS.SUB_STATION_NAME,
						M.METER_NAME,
						M.METER_ID,
						MP.METER_POINT_ID,
						MP.OPERATION_CODE,
						MPS.MEASUREMENT_SOURCE_ID,
						SDT.CUT_DATE,
						-- get formatted roll-up interval
						CASE v_INTERVAL
							WHEN 'DD' THEN SDT.DAY_YYYY_MM_DD
							WHEN 'DY' THEN SDT.WEEK_YYYY_MM_DD
							WHEN 'MM' THEN SDT.MONTH_YYYY_MM_DD
							WHEN 'Q' THEN SDT.QUARTER_YYYY_MM_DD
							WHEN 'YY' THEN SDT.YEAR_YYYY_MM_DD
							WHEN 'HH' THEN SDT.NO_ROLLUP_YYYY_MM_DD
							ELSE '(Unknown roll-up interval)'
							END as DISPLAY_DATE
					FROM SYSTEM_DATE_TIME SDT,
						TX_SUB_STATION SS,
						TABLE(CAST(v_IDs as ID_TABLE)) IDs,
						TX_SUB_STATION_METER M,
						TX_SUB_STATION_METER_POINT MP,
						TX_SUB_STATION_METER_PT_SOURCE MPS
					WHERE SDT.TIME_ZONE = p_TIME_ZONE
						AND SDT.DATA_INTERVAL_TYPE = 1
						AND SDT.DAY_TYPE = '1'
						AND SDT.CUT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
						AND SDT.MINIMUM_INTERVAL_NUMBER >= v_INTERVAL_NUM
						AND SS.SUB_STATION_ID = p_SUB_STATION_ID
						AND M.SUB_STATION_ID = SS.SUB_STATION_ID
						AND IDs.ID IN (M.METER_ID, SD.g_ALL_DATA_ENTITY_ID)
						AND MP.SUB_STATION_METER_ID = M.METER_ID
						AND NVL(MP.OPERATION_CODE,'N') <> 'N' -- don't bother including data points that do not contribute to total
						-- find primary measurement source
						AND MPS.METER_POINT_ID = MP.METER_POINT_ID
						AND SDT.LOCAL_DAY_TRUNC_DATE BETWEEN MPS.BEGIN_DATE AND NVL(MPS.END_DATE,CONSTANTS.HIGH_DATE)
						AND MPS.IS_PRIMARY = 1
					) M,
				TX_SUB_STATION_METER_PT_VALUE V
			WHERE V.METER_POINT_ID(+) = M.METER_POINT_ID
				AND V.MEASUREMENT_SOURCE_ID(+) = M.MEASUREMENT_SOURCE_ID
				AND v.METER_CODE(+) = v_METER_CODE
				AND v.METER_DATE(+) = M.CUT_DATE
			GROUP BY M.DISPLAY_DATE,
				M.SUB_STATION_NAME,
				M.METER_NAME,
				M.METER_ID;

	ELSIF v_LEVEL = c_LEVEL_SUBSTATION_METER THEN

		-- get list of all data points for specified meter and their values
		OPEN p_CURSOR FOR
			SELECT M.DISPLAY_DATE,
				M.METER_NAME,
				M.METER_POINT_NAME,
				M.METER_POINT_ID,
				CASE M.OPERATION_CODE
					WHEN 'A' THEN 1
					WHEN 'S' THEN -1
					ELSE 0
					END as COEFF,
				CASE NVL(M.OPERATION_CODE,'N')
					WHEN 'A' THEN 'Add'
					WHEN 'S' THEN 'Subtract'
					WHEN 'N' THEN '<html><i>None</i></html>'
					ELSE '?'
					END as OPERATION_CODE,
				SUM(V.METER_VAL) as METER_VAL,
				SUM(V.TRUNCATED_VAL) as TRUNCATED_VAL,
				SECURITY_CONTROLS.GET_EFFECTIVE_LOCK_STATE(MIN(V.LOCK_STATE),v_LOCKING_ENABLED) as LOCK_STATE
			FROM (SELECT M.METER_NAME,
						MP.METER_POINT_NAME,
						MP.METER_POINT_ID,
						MP.OPERATION_CODE,
						MPS.MEASUREMENT_SOURCE_ID,
						SDT.CUT_DATE,
						-- get formatted roll-up interval
						CASE v_INTERVAL
							WHEN 'DD' THEN SDT.DAY_YYYY_MM_DD
							WHEN 'DY' THEN SDT.WEEK_YYYY_MM_DD
							WHEN 'MM' THEN SDT.MONTH_YYYY_MM_DD
							WHEN 'Q' THEN SDT.QUARTER_YYYY_MM_DD
							WHEN 'YY' THEN SDT.YEAR_YYYY_MM_DD
							WHEN 'HH' THEN SDT.NO_ROLLUP_YYYY_MM_DD
							ELSE '(Unknown roll-up interval)'
							END as DISPLAY_DATE
					FROM SYSTEM_DATE_TIME SDT,
						TX_SUB_STATION_METER M,
						TX_SUB_STATION_METER_POINT MP,
						TX_SUB_STATION_METER_PT_SOURCE MPS
					WHERE SDT.TIME_ZONE = p_TIME_ZONE
						AND SDT.DATA_INTERVAL_TYPE = 1
						AND SDT.DAY_TYPE = '1'
						AND SDT.CUT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
						AND SDT.MINIMUM_INTERVAL_NUMBER >= v_INTERVAL_NUM
						AND M.METER_ID = p_METER_ID
						AND MP.SUB_STATION_METER_ID = M.METER_ID
						-- find primary measurement source
						AND MPS.METER_POINT_ID = MP.METER_POINT_ID
						AND SDT.LOCAL_DAY_TRUNC_DATE BETWEEN MPS.BEGIN_DATE AND NVL(MPS.END_DATE,CONSTANTS.HIGH_DATE)
						AND MPS.IS_PRIMARY = 1
					) M,
				TX_SUB_STATION_METER_PT_VALUE V
			WHERE V.METER_POINT_ID(+) = M.METER_POINT_ID
				AND V.MEASUREMENT_SOURCE_ID(+) = M.MEASUREMENT_SOURCE_ID
				AND v.METER_CODE(+) = v_METER_CODE
				AND v.METER_DATE(+) = M.CUT_DATE
			GROUP BY M.DISPLAY_DATE,
				M.METER_NAME,
				M.METER_POINT_NAME,
				M.METER_POINT_ID,
				M.OPERATION_CODE;

	ELSE -- c_LEVEL_SUBSTATION_METER_POINT

		-- get list of all sources for specified meter point and corresponding meter values
		OPEN p_CURSOR FOR
			SELECT M.DISPLAY_DATE,
				M.METER_POINT_NAME,
				M.MEASUREMENT_SOURCE_NAME,
				M.MEASUREMENT_SOURCE_ID,
				M.METER_TYPE,
				NVL(MAX(M.IS_PRIMARY),0) as IS_PRIMARY,
				SUM(V.METER_VAL) as METER_VAL,
				CASE WHEN v_INTERVAL = 'HH' THEN MAX(V.METER_VAL_QUAL_CODE) ELSE NULL END as METER_VAL_QUAL_CODE,
				CASE WHEN v_INTERVAL = 'HH' THEN MAX(V.METER_VAL_CARRY_FWD) ELSE NULL END as METER_VAL_CARRY_FWD,
				CASE WHEN v_INTERVAL = 'HH' THEN MAX(V.METER_VAL_ACCUM) ELSE NULL END as METER_VAL_ACCUM,
				SUM(V.TRUNCATED_VAL) as TRUNCATED_VAL,
				CASE WHEN v_INTERVAL = 'HH' THEN MAX(V.TRUNCATED_VAL_QUAL_CODE) ELSE NULL END as TRUNCATED_VAL_QUAL_CODE,
				CASE WHEN v_INTERVAL = 'HH' THEN MAX(V.TRUNCATED_VAL_ACCUM) ELSE NULL END as TRUNCATED_VAL_ACCUM,
				CASE WHEN v_INTERVAL = 'HH' THEN MAX(V.LIFETIME_VAL_ACCUM) ELSE NULL END as LIFETIME_VAL_ACCUM,
				SECURITY_CONTROLS.GET_EFFECTIVE_LOCK_STATE(MIN(V.LOCK_STATE),v_LOCKING_ENABLED) as LOCK_STATE
			FROM (SELECT MP.METER_POINT_NAME,
						MP.METER_POINT_ID,
						MS.MEASUREMENT_SOURCE_NAME,
						MPS.MEASUREMENT_SOURCE_ID,
						MS.METER_TYPE,
						MPS.IS_PRIMARY,
						SDT.CUT_DATE,
						-- get formatted roll-up interval
						CASE v_INTERVAL
							WHEN 'DD' THEN SDT.DAY_YYYY_MM_DD
							WHEN 'DY' THEN SDT.WEEK_YYYY_MM_DD
							WHEN 'MM' THEN SDT.MONTH_YYYY_MM_DD
							WHEN 'Q' THEN SDT.QUARTER_YYYY_MM_DD
							WHEN 'YY' THEN SDT.YEAR_YYYY_MM_DD
							WHEN 'HH' THEN SDT.NO_ROLLUP_YYYY_MM_DD
							ELSE '(Unknown roll-up interval)'
							END as DISPLAY_DATE
					FROM SYSTEM_DATE_TIME SDT,
						TX_SUB_STATION_METER_POINT MP,
						TX_SUB_STATION_METER_PT_SOURCE MPS,
						MEASUREMENT_SOURCE MS
					WHERE SDT.TIME_ZONE = p_TIME_ZONE
						AND SDT.DATA_INTERVAL_TYPE = 1
						AND SDT.DAY_TYPE = '1'
						AND SDT.CUT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
						AND SDT.MINIMUM_INTERVAL_NUMBER >= v_INTERVAL_NUM
						AND MP.METER_POINT_ID = p_METER_POINT_ID
						-- get all measurement sources
						AND MPS.METER_POINT_ID = MP.METER_POINT_ID
						AND SDT.LOCAL_DAY_TRUNC_DATE BETWEEN MPS.BEGIN_DATE AND NVL(MPS.END_DATE,CONSTANTS.HIGH_DATE)
						AND MS.MEASUREMENT_SOURCE_ID = MPS.MEASUREMENT_SOURCE_ID
					) M,
				TX_SUB_STATION_METER_PT_VALUE V
			WHERE V.METER_POINT_ID(+) = M.METER_POINT_ID
				AND V.MEASUREMENT_SOURCE_ID(+) = M.MEASUREMENT_SOURCE_ID
				AND v.METER_CODE(+) = v_METER_CODE
				AND v.METER_DATE(+) = M.CUT_DATE
			GROUP BY M.DISPLAY_DATE,
				M.METER_POINT_NAME,
				M.MEASUREMENT_SOURCE_NAME,
				M.MEASUREMENT_SOURCE_ID,
				M.METER_TYPE;

	END IF;

END GET_SUB_STATION_DATA;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_SUB_STATION_DATA
	(
	p_METER_POINT_ID IN NUMBER,
	p_MEASUREMENT_SOURCE_ID IN NUMBER,
	p_METER_CODE IN VARCHAR2,
	p_DISPLAY_DATE IN VARCHAR2,
    p_TIME_ZONE IN VARCHAR2,
	p_METER_VAL IN NUMBER,
	p_METER_VAL_QUAL_CODE IN VARCHAR2 := NULL,
	p_TRUNCATED_VAL IN NUMBER := NULL,
	p_TRUNCATED_VAL_QUAL_CODE IN VARCHAR2 := NULL,
	p_METER_VAL_CARRY_FWD IN NUMBER := NULL,
	p_METER_VAL_ACCUM IN NUMBER := NULL,
	p_TRUNCATED_VAL_ACCUM IN NUMBER := NULL,
	p_LIFETIME_VAL_ACCUM IN NUMBER := NULL
	) AS
v_CUT_DATE DATE;
BEGIN
	IF p_METER_POINT_ID IS NULL THEN
		ERRS.RAISE_BAD_ARGUMENT('METER_POINT_ID', p_METER_POINT_ID);
	END IF;
	ASSERT(NVL(LENGTH(p_DISPLAY_DATE),0) >= 16, 'Cannot save data for roll-up intervals, only for an interval of "Hour"');

	v_CUT_DATE := DATE_TIME_AS_CUT(SUBSTR(p_DISPLAY_DATE,1,10), SUBSTR(p_DISPLAY_DATE,12), p_TIME_ZONE);
	PUT_SUB_STATION_METER_PT_VALUE(p_METER_POINT_ID, p_MEASUREMENT_SOURCE_ID, SUBSTR(p_METER_CODE,1,1), v_CUT_DATE,
									p_METER_VAL, p_METER_VAL_QUAL_CODE, p_TRUNCATED_VAL, p_TRUNCATED_VAL_QUAL_CODE,
									p_METER_VAL_CARRY_FWD, p_METER_VAL_ACCUM, p_TRUNCATED_VAL_ACCUM, p_LIFETIME_VAL_ACCUM);
END PUT_SUB_STATION_DATA;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_SUB_STATION_METER_PT_VALUE
	(
	p_METER_POINT_ID IN NUMBER,
	p_METER_CODE IN CHAR,
	p_METER_DATE IN DATE,
	p_METER_VAL IN NUMBER,
	p_METER_VAL_QUAL_CODE IN VARCHAR2 := NULL,
	p_TRUNCATED_VAL IN NUMBER := NULL,
	p_TRUNCATED_VAL_QUAL_CODE IN VARCHAR2 := NULL,
	p_METER_VAL_CARRY_FWD IN NUMBER := NULL,
	p_METER_VAL_ACCUM IN NUMBER := NULL,
	p_TRUNCATED_VAL_ACCUM IN NUMBER := NULL,
	p_LIFETIME_VAL_ACCUM IN NUMBER := NULL
	) AS
v_MEASUREMENT_SOURCE_ID NUMBER(9);
BEGIN
	-- use default (aka primary) measurement source
	BEGIN
		SELECT MEASUREMENT_SOURCE_ID
		INTO v_MEASUREMENT_SOURCE_ID
		FROM TX_SUB_STATION_METER_PT_SOURCE
		WHERE METER_POINT_ID = p_METER_POINT_ID
			AND IS_PRIMARY = 1
			AND p_METER_DATE-1/86400 BETWEEN BEGIN_DATE AND NVL(END_DATE,CONSTANTS.HIGH_DATE);
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY,
						'Primary measurement source for '||TEXT_UTIL.TO_CHAR_ENTITY(p_METER_POINT_ID, EC.ED_SUB_STATION_METER_POINT, TRUE)||
							' for '||TEXT_UTIL.TO_CHAR_TIME(p_METER_DATE),
						TRUE);
		WHEN TOO_MANY_ROWS THEN
			ERRS.RAISE(MSGCODES.c_ERR_TOO_MANY_ENTRIES,
						'Primary measurement source for '||TEXT_UTIL.TO_CHAR_ENTITY(p_METER_POINT_ID, EC.ED_SUB_STATION_METER_POINT, TRUE)||
							' for '||TEXT_UTIL.TO_CHAR_TIME(p_METER_DATE),
						TRUE);
	END;

	PUT_SUB_STATION_METER_PT_VALUE(p_METER_POINT_ID, v_MEASUREMENT_SOURCE_ID, p_METER_CODE, p_METER_DATE,
									p_METER_VAL, p_METER_VAL_QUAL_CODE, p_TRUNCATED_VAL, p_TRUNCATED_VAL_QUAL_CODE,
									p_METER_VAL_CARRY_FWD, p_METER_VAL_ACCUM, p_TRUNCATED_VAL_ACCUM, p_LIFETIME_VAL_ACCUM);

END PUT_SUB_STATION_METER_PT_VALUE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_SUB_STATION_METER_PT_VALUE
	(
	p_METER_POINT_ID IN NUMBER,
	p_MEASUREMENT_SOURCE_ID IN NUMBER,
	p_METER_CODE IN CHAR,
	p_METER_DATE IN DATE,
	p_METER_VAL IN NUMBER,
	p_METER_VAL_QUAL_CODE IN VARCHAR2 := NULL,
	p_TRUNCATED_VAL IN NUMBER := NULL,
	p_TRUNCATED_VAL_QUAL_CODE IN VARCHAR2 := NULL,
	p_METER_VAL_CARRY_FWD IN NUMBER := NULL,
	p_METER_VAL_ACCUM IN NUMBER := NULL,
	p_TRUNCATED_VAL_ACCUM IN NUMBER := NULL,
	p_LIFETIME_VAL_ACCUM IN NUMBER := NULL
	) AS
v_METER_ID	NUMBER(9);
BEGIN
	IF SECURITY_CONTROLS.IS_AUTH_ENABLED THEN -- only bother getting meter ID to check security if it's necessary
		SELECT SUB_STATION_METER_ID
		INTO v_METER_ID
		FROM TX_SUB_STATION_METER_POINT
		WHERE METER_POINT_ID = p_METER_POINT_ID;
		-- now verify privileges
		SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SSMETER_UPDATE, v_METER_ID, EC.ED_SUB_STATION_METER);
	END IF;

	-- try update
	UPDATE TX_SUB_STATION_METER_PT_VALUE
		SET METER_VAL = NVL(p_METER_VAL,METER_VAL),
			METER_VAL_QUAL_CODE = NVL(p_METER_VAL_QUAL_CODE,METER_VAL_QUAL_CODE),
			METER_VAL_CARRY_FWD = NVL(p_METER_VAL_CARRY_FWD,METER_VAL_CARRY_FWD),
			METER_VAL_ACCUM = NVL(p_METER_VAL_ACCUM,METER_VAL_ACCUM),
			TRUNCATED_VAL = NVL(p_TRUNCATED_VAL,TRUNCATED_VAL),
			TRUNCATED_VAL_QUAL_CODE = NVL(p_TRUNCATED_VAL_QUAL_CODE,TRUNCATED_VAL_QUAL_CODE),
			TRUNCATED_VAL_ACCUM = NVL(p_TRUNCATED_VAL_ACCUM,TRUNCATED_VAL_ACCUM),
			LIFETIME_VAL_ACCUM = NVL(p_LIFETIME_VAL_ACCUM,LIFETIME_VAL_ACCUM),
			ENTRY_DATE = SYSDATE
	WHERE METER_POINT_ID = p_METER_POINT_ID
		AND MEASUREMENT_SOURCE_ID = p_MEASUREMENT_SOURCE_ID
		AND METER_CODE = p_METER_CODE
		AND METER_DATE = p_METER_DATE;

	-- nothing? then insert
	IF SQL%NOTFOUND THEN
		INSERT INTO TX_SUB_STATION_METER_PT_VALUE
			(METER_POINT_ID, MEASUREMENT_SOURCE_ID, METER_CODE, METER_DATE,
			 METER_VAL, METER_VAL_QUAL_CODE, METER_VAL_CARRY_FWD, METER_VAL_ACCUM,
			 TRUNCATED_VAL, TRUNCATED_VAL_QUAL_CODE, TRUNCATED_VAL_ACCUM,
			 LIFETIME_VAL_ACCUM, ENTRY_DATE)
		VALUES
			(p_METER_POINT_ID, p_MEASUREMENT_SOURCE_ID, p_METER_CODE, p_METER_DATE,
			 p_METER_VAL, p_METER_VAL_QUAL_CODE, p_METER_VAL_CARRY_FWD, p_METER_VAL_ACCUM,
			 p_TRUNCATED_VAL, p_TRUNCATED_VAL_QUAL_CODE, p_TRUNCATED_VAL_ACCUM,
			 p_LIFETIME_VAL_ACCUM, SYSDATE);
	END IF;
END PUT_SUB_STATION_METER_PT_VALUE;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_MEASUREMENT_SRC_TYPE_LIST
	(
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_IDs ID_TABLE;
BEGIN
	p_STATUS := GA.SUCCESS;

	v_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_MSRMNT_SRC_SELECT, EC.ED_MEASUREMENT_SOURCE);

	OPEN p_CURSOR FOR
		SELECT DISTINCT METER_TYPE
		FROM MEASUREMENT_SOURCE MS,
			TABLE(CAST(v_IDs as ID_TABLE)) IDs
		WHERE IDs.ID IN (MS.MEASUREMENT_SOURCE_ID, SD.g_ALL_DATA_ENTITY_ID)
			AND MS.MEASUREMENT_SOURCE_ID <> CONSTANTS.NOT_ASSIGNED
		ORDER BY 1;

END GET_MEASUREMENT_SRC_TYPE_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_MEASUREMENT_SRC_LIST
	(
	p_METER_TYPE IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_IDs ID_TABLE;
BEGIN
	p_STATUS := GA.SUCCESS;

	v_IDs := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_MSRMNT_SRC_SELECT, EC.ED_MEASUREMENT_SOURCE);

	OPEN p_CURSOR FOR
		SELECT MEASUREMENT_SOURCE_NAME, MEASUREMENT_SOURCE_ID
		FROM MEASUREMENT_SOURCE MS,
			TABLE(CAST(v_IDs as ID_TABLE)) IDs
		WHERE IDs.ID IN (MS.MEASUREMENT_SOURCE_ID, SD.g_ALL_DATA_ENTITY_ID)
			AND MS.MEASUREMENT_SOURCE_ID <> CONSTANTS.NOT_ASSIGNED
			AND MS.METER_TYPE = p_METER_TYPE
		ORDER BY 1;

END GET_MEASUREMENT_SRC_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_MEASUREMENT_SOURCE_VALS
	(
	p_MEASUREMENT_SOURCE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_BEGIN_DATE	DATE;
v_END_DATE		DATE;
v_INTERVAL_ABBR VARCHAR2(16);
v_INTERVAL_NUM	NUMBER;
v_LOCKING_ENABLED NUMBER := AUDIT_TRAIL.IS_TABLE_LOCKING_ENABLED(ENTITY_UTIL.TABLE_ID_FOR_DB_TABLE('MEASUREMENT_SOURCE_VALUE'));
BEGIN
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_MSRMNT_SRC_SELECT, p_MEASUREMENT_SOURCE_ID, EC.ED_MEASUREMENT_SOURCE);

	SELECT GET_INTERVAL_NUMBER(MEASUREMENT_SOURCE_INTERVAL),
		GET_INTERVAL_ABBREVIATION(MEASUREMENT_SOURCE_INTERVAL)
	INTO v_INTERVAL_NUM, v_INTERVAL_ABBR
	FROM MEASUREMENT_SOURCE
	WHERE MEASUREMENT_SOURCE_ID = p_MEASUREMENT_SOURCE_ID;

	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	OPEN p_CURSOR FOR
		SELECT SDT.NO_ROLLUP_YYYY_MM_DD as DISPLAY_DATE,
			SDT.CUT_DATE as SOURCE_DATE,
			MSV.SOURCE_VALUE,
			MSV.SOURCE_QUAL_CODE,
			SECURITY_CONTROLS.GET_EFFECTIVE_LOCK_STATE(MSV.LOCK_STATE,v_LOCKING_ENABLED) as LOCK_STATE
		FROM MEASUREMENT_SOURCE_VALUE MSV,
			SYSTEM_DATE_TIME SDT
		WHERE SDT.TIME_ZONE = p_TIME_ZONE
			AND SDT.DATA_INTERVAL_TYPE = 1
			AND SDT.DAY_TYPE = '1'
			AND SDT.CUT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND SDT.MINIMUM_INTERVAL_NUMBER >= v_INTERVAL_NUM
			AND MSV.MEASUREMENT_SOURCE_ID(+) = p_MEASUREMENT_SOURCE_ID
			AND MSV.SOURCE_DATE(+) = SDT.CUT_DATE_SCHEDULING
		ORDER BY SOURCE_DATE;

END GET_MEASUREMENT_SOURCE_VALS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_MEASUREMENT_SOURCE_VALUE
	(
	p_MEASUREMENT_SOURCE_ID IN NUMBER,
	p_SOURCE_DATE IN DATE,
	p_SOURCE_VALUE IN NUMBER,
	p_SOURCE_QUAL_CODE IN VARCHAR2
	) AS
BEGIN
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_MSRMNT_SRC_UPDATE, p_MEASUREMENT_SOURCE_ID, EC.ED_MEASUREMENT_SOURCE);

	UPDATE MEASUREMENT_SOURCE_VALUE
		SET SOURCE_VALUE = NVL(p_SOURCE_VALUE,SOURCE_VALUE),
			SOURCE_QUAL_CODE = NVL(p_SOURCE_QUAL_CODE,SOURCE_QUAL_CODE),
			ENTRY_DATE = SYSDATE
	WHERE MEASUREMENT_SOURCE_ID = p_MEASUREMENT_SOURCE_ID
		AND SOURCE_DATE = p_SOURCE_DATE;

	IF SQL%NOTFOUND THEN
		INSERT INTO MEASUREMENT_SOURCE_VALUE
			(MEASUREMENT_SOURCE_ID, SOURCE_DATE, SOURCE_VALUE, SOURCE_QUAL_CODE, ENTRY_DATE)
		VALUES
			(p_MEASUREMENT_SOURCE_ID, p_SOURCE_DATE, p_SOURCE_VALUE, p_SOURCE_QUAL_CODE, SYSDATE);
	END IF;
END PUT_MEASUREMENT_SOURCE_VALUE;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_CONTRACTS
	(
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT
		  A.CONTRACT_ID,
		  A.CONTRACT_NAME,
		  A.CONTRACT_ALIAS,
		  A.CONTRACT_DESC,
		  A.CONTRACT_TYPE,
		  B.PSE_NAME "BILLING_ENTITY_NAME",
		  A.AGREEMENT_TYPE,
		  A.BEGIN_DATE,
		  A.END_DATE,
		  DECODE(A.IS_EVERGREEN,1,'Yes','No') "IS_EVERGREEN",
		  A.CONTRACT_FILE_NAME,
		  A.ENTRY_DATE
		FROM INTERCHANGE_CONTRACT A,
			PURCHASING_SELLING_ENTITY B
		WHERE A.CONTRACT_ID > 0
			AND B.PSE_ID(+) = A.BILLING_ENTITY_ID
		ORDER BY CONTRACT_NAME;


END GET_CONTRACTS;
----------------------------------------------------------------------------------------------------
PROCEDURE APPLY_EXTERNAL_SCHEDULE (
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS
BEGIN
	-- perform a schedule copy for the specified time period and transaction - from external to internal
    -- pbm - 11/17/2004 - Modified call to pass the Data Options as a comma delimited list instead of
    --                    individual number parameters. Currently 'Amount' is the only data optiong to copy.
	SCHEDULE_COPY_REQUEST(p_TRANSACTION_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_SCHEDULE_TYPE, 1,
				'Amount', p_TRANSACTION_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, p_SCHEDULE_TYPE, 0, 1,
				p_TIME_ZONE, p_STATUS);
END APPLY_EXTERNAL_SCHEDULE;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SERVICE_ZONE_LOAD
   (
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_LOAD_DETAIL IN NUMBER,
	p_PURCHASE_DETAIL IN NUMBER,
	p_SALE_DETAIL IN NUMBER,
	p_GENERATION_DETAIL IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_SCHEDULE_TYPE NUMBER(9) := SUPPLY_SCHEDULE_TYPE(p_SCHEDULE_TYPE);
BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

  	IF GA.VERSION_SCHEDULE THEN
		OPEN p_CURSOR FOR
			SELECT DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'LO', DECODE(p_LOAD_DETAIL,1,A.TRANSACTION_NAME,'LOAD_SUMMARY'), 'UNKNOWN') "TRANSACTION_NAME",
				A.TRANSACTION_TYPE "TRANSACTION_TYPE",
				FROM_CUT_AS_HED(B.SCHEDULE_DATE, p_TIME_ZONE, p_INTERVAL) "SCHEDULE_DATE",
				SUM(B.AMOUNT) "VALUE"
			FROM INTERCHANGE_TRANSACTION A, IT_SCHEDULE B
			WHERE NVL(A.BEGIN_DATE, CONSTANTS.LOW_DATE) <= TRUNC(p_END_DATE)
				AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
				AND p_SERVICE_ZONE_ID = DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'LO', A.ZOR_ID, CONSTANTS.NOT_ASSIGNED)
				AND B.TRANSACTION_ID = A.TRANSACTION_ID
				AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) = 'LO'
				AND B.SCHEDULE_TYPE IN (v_SCHEDULE_TYPE, p_SCHEDULE_TYPE)
				AND B.SCHEDULE_STATE = p_SCHEDULE_STATE
				AND B.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND B.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM IT_SCHEDULE
					WHERE TRANSACTION_ID = B.TRANSACTION_ID
						AND SCHEDULE_TYPE = B.SCHEDULE_TYPE
						AND SCHEDULE_STATE = B.SCHEDULE_STATE
						AND SCHEDULE_DATE = B.SCHEDULE_DATE
						AND AS_OF_DATE <= p_AS_OF_DATE)
			GROUP BY DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'LO', DECODE(p_LOAD_DETAIL,1,A.TRANSACTION_NAME,'LOAD_SUMMARY'), 'UNKNOWN'),
				A.TRANSACTION_TYPE, FROM_CUT_AS_HED(B.SCHEDULE_DATE, p_TIME_ZONE, p_INTERVAL)
			ORDER BY 2,1,3;
	ELSE
		OPEN p_CURSOR FOR
			SELECT DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'LO', DECODE(p_LOAD_DETAIL,1,A.TRANSACTION_NAME,'LOAD_SUMMARY'), 'UNKNOWN') "TRANSACTION_NAME",
				A.TRANSACTION_TYPE "TRANSACTION_TYPE",
				FROM_CUT_AS_HED(B.SCHEDULE_DATE, p_TIME_ZONE, p_INTERVAL) "SCHEDULE_DATE",
				SUM(B.AMOUNT) "VALUE"
			FROM INTERCHANGE_TRANSACTION A, IT_SCHEDULE B
			WHERE NVL(A.BEGIN_DATE, CONSTANTS.LOW_DATE) <= TRUNC(p_END_DATE)
				AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
				AND p_SERVICE_ZONE_ID = DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'LO', A.ZOR_ID, CONSTANTS.NOT_ASSIGNED)
				AND B.TRANSACTION_ID = A.TRANSACTION_ID
				AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) = 'LO'
				AND B.SCHEDULE_TYPE IN (v_SCHEDULE_TYPE, p_SCHEDULE_TYPE)
				AND B.SCHEDULE_STATE = p_SCHEDULE_STATE
				AND B.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND B.AS_OF_DATE =CONSTANTS.LOW_DATE
			GROUP BY DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'LO', DECODE(p_LOAD_DETAIL,1,A.TRANSACTION_NAME,'LOAD_SUMMARY'), 'UNKNOWN'),
				A.TRANSACTION_TYPE, FROM_CUT_AS_HED(B.SCHEDULE_DATE, p_TIME_ZONE, p_INTERVAL)
			ORDER BY 2,1,3;
	END IF;



END GET_SERVICE_ZONE_LOAD;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SERVICE_ZONE_SUPPLY
   (
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SERVICE_ZONE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_LOAD_DETAIL IN NUMBER,
	p_PURCHASE_DETAIL IN NUMBER,
	p_SALE_DETAIL IN NUMBER,
	p_GENERATION_DETAIL IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_SCHEDULE_TYPE NUMBER(9) := SUPPLY_SCHEDULE_TYPE(p_SCHEDULE_TYPE);

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

  	IF GA.VERSION_SCHEDULE THEN
		OPEN p_CURSOR FOR
			SELECT DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'SA', DECODE(p_SALE_DETAIL,1,A.TRANSACTION_NAME,'SALE_SUMMARY'), 'PU', DECODE(p_PURCHASE_DETAIL,1,A.TRANSACTION_NAME,'PURCHASE_SUMMARY'), 'GE', DECODE(p_GENERATION_DETAIL,1,A.TRANSACTION_NAME,'GENERATION_SUMMARY'), 'UNKNOWN') "TRANSACTION_NAME",
				A.TRANSACTION_TYPE "TRANSACTION_TYPE",
				FROM_CUT_AS_HED(B.SCHEDULE_DATE, p_TIME_ZONE, p_INTERVAL) "SCHEDULE_DATE",
				SUM(B.AMOUNT) "VALUE"
			FROM INTERCHANGE_TRANSACTION A, IT_SCHEDULE B
			WHERE NVL(A.BEGIN_DATE, CONSTANTS.LOW_DATE) <= TRUNC(p_END_DATE)
				AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
				AND p_SERVICE_ZONE_ID = DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'SA', A.ZOR_ID, 'PU', A.ZOD_ID, 'GE', A.ZOD_ID, CONSTANTS.NOT_ASSIGNED)
				AND B.TRANSACTION_ID = A.TRANSACTION_ID
				AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) <> 'LO'
				AND B.SCHEDULE_TYPE IN (v_SCHEDULE_TYPE, p_SCHEDULE_TYPE)
				AND B.SCHEDULE_STATE = p_SCHEDULE_STATE
				AND B.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND B.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM IT_SCHEDULE
					WHERE TRANSACTION_ID = B.TRANSACTION_ID
						AND SCHEDULE_TYPE = B.SCHEDULE_TYPE
						AND SCHEDULE_STATE = B.SCHEDULE_STATE
						AND SCHEDULE_DATE = B.SCHEDULE_DATE
						AND AS_OF_DATE <= p_AS_OF_DATE)
			GROUP BY DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'SA', DECODE(p_SALE_DETAIL,1,A.TRANSACTION_NAME,'SALE_SUMMARY'), 'PU', DECODE(p_PURCHASE_DETAIL,1,A.TRANSACTION_NAME,'PURCHASE_SUMMARY'), 'GE', DECODE(p_GENERATION_DETAIL,1,A.TRANSACTION_NAME,'GENERATION_SUMMARY'), 'UNKNOWN'),
				A.TRANSACTION_TYPE, FROM_CUT_AS_HED(B.SCHEDULE_DATE, p_TIME_ZONE, p_INTERVAL)
			ORDER BY 2,1,3;
	ELSE
		OPEN p_CURSOR FOR
			 SELECT DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'SA', DECODE(p_SALE_DETAIL,1,A.TRANSACTION_NAME,'SALE_SUMMARY'), 'PU', DECODE(p_PURCHASE_DETAIL,1,A.TRANSACTION_NAME,'PURCHASE_SUMMARY'), 'GE', DECODE(p_GENERATION_DETAIL,1,A.TRANSACTION_NAME,'GENERATION_SUMMARY'), 'UNKNOWN') "TRANSACTION_NAME",
				A.TRANSACTION_TYPE "TRANSACTION_TYPE",
				FROM_CUT_AS_HED(B.SCHEDULE_DATE, p_TIME_ZONE, p_INTERVAL) "SCHEDULE_DATE",
				SUM(B.AMOUNT) "VALUE"
			FROM INTERCHANGE_TRANSACTION A, IT_SCHEDULE B
			WHERE NVL(A.BEGIN_DATE, CONSTANTS.LOW_DATE) <= TRUNC(p_END_DATE)
				AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= TRUNC(p_BEGIN_DATE)
				AND p_SERVICE_ZONE_ID = DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'SA', A.ZOR_ID, 'PU', A.ZOD_ID, 'GE', A.ZOD_ID, CONSTANTS.NOT_ASSIGNED)
				AND B.TRANSACTION_ID = A.TRANSACTION_ID
				AND UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)) <> 'LO'
				AND B.SCHEDULE_TYPE IN (v_SCHEDULE_TYPE, p_SCHEDULE_TYPE)
				AND B.SCHEDULE_STATE = p_SCHEDULE_STATE
				AND B.SCHEDULE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
				AND B.AS_OF_DATE =CONSTANTS.LOW_DATE
			GROUP BY DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'SA', DECODE(p_SALE_DETAIL,1,A.TRANSACTION_NAME,'SALE_SUMMARY'), 'PU', DECODE(p_PURCHASE_DETAIL,1,A.TRANSACTION_NAME,'PURCHASE_SUMMARY'), 'GE', DECODE(p_GENERATION_DETAIL,1,A.TRANSACTION_NAME,'GENERATION_SUMMARY'), 'UNKNOWN'),
				A.TRANSACTION_TYPE, FROM_CUT_AS_HED(B.SCHEDULE_DATE, p_TIME_ZONE, p_INTERVAL)
			ORDER BY 2,1,3;
	END IF;


END GET_SERVICE_ZONE_SUPPLY;
------------------------------------------------------------------------------------------------------------
PROCEDURE GET_MARKET_PRICE_FOR_ZONE
	(
	p_SERVICE_ZONE_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_MARKET_PRICE_INTERVAL VARCHAR2(16);
BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	--DETERMINE THE INTERVAL OF THE MARKET PRICE
	SELECT DECODE(UPPER(MARKET_PRICE_INTERVAL),'15 MINUTE','MI15','30 MINUTE','MI30','DAY','DD','WEEK','DY','MONTH','MM','QUARTER','Q','YEAR','YY','')
	INTO v_MARKET_PRICE_INTERVAL
	FROM MARKET_PRICE A, SERVICE_ZONE B
	WHERE B.SERVICE_ZONE_ID = p_SERVICE_ZONE_ID
		AND B.MARKET_PRICE_ID = A.MARKET_PRICE_ID;


	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	--RETURN NOTHING IF THIS IS NOT THE RIGHT INTERVAL.
	IF NOT UPPER(p_INTERVAL) = UPPER(v_MARKET_PRICE_INTERVAL) THEN
		NULL_CURSOR(p_CURSOR);
  	ELSIF GA.VERSION_SCHEDULE THEN
		OPEN p_CURSOR FOR
			SELECT A.MARKET_PRICE_NAME,
				   FROM_CUT_AS_HED(B.PRICE_DATE, p_TIME_ZONE, p_INTERVAL) "PRICE_DATE",
				   B.PRICE
			FROM MARKET_PRICE A, MARKET_PRICE_VALUE B, SERVICE_ZONE C
			WHERE C.SERVICE_ZONE_ID = p_SERVICE_ZONE_ID
				AND C.MARKET_PRICE_ID = A.MARKET_PRICE_ID
				AND B.MARKET_PRICE_ID = A.MARKET_PRICE_ID
				AND B.PRICE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		      AND B.AS_OF_DATE =
					(SELECT MAX(AS_OF_DATE)
					FROM MARKET_PRICE_VALUE
					WHERE MARKET_PRICE_ID = A.MARKET_PRICE_ID
					AND AS_OF_DATE <= p_AS_OF_DATE)
			ORDER BY 2, 3;
	ELSE
		  OPEN p_CURSOR FOR
		  	 SELECT A.MARKET_PRICE_NAME,
				   FROM_CUT_AS_HED(B.PRICE_DATE, p_TIME_ZONE, p_INTERVAL) "PRICE_DATE",
				   B.PRICE
			FROM MARKET_PRICE A, MARKET_PRICE_VALUE B, SERVICE_ZONE C
			WHERE C.SERVICE_ZONE_ID = p_SERVICE_ZONE_ID
				AND C.MARKET_PRICE_ID = A.MARKET_PRICE_ID
				AND B.MARKET_PRICE_ID = A.MARKET_PRICE_ID
				AND B.PRICE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		      AND B.AS_OF_DATE = CONSTANTS.LOW_DATE
			ORDER BY 2, 3;
	END IF;


END GET_MARKET_PRICE_FOR_ZONE;
------------------------------------------------------------------------------------------------------------
PROCEDURE GET_SCHEDULE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SCHEDULE IN OUT NOCOPY SCHEDULE_STATE_TABLE
	) AS

-- p_BEGIN_DATE and p_END_DATE are CUT dates.

v_AS_OF_DATE DATE;

BEGIN
	IF GA.VERSION_SCHEDULE THEN
		v_AS_OF_DATE := CORRECTED_AS_OF_DATE(p_AS_OF_DATE);
		SELECT SCHEDULE_STATE_TYPE(A.TRANSACTION_ID, A.SCHEDULE_TYPE, A.SCHEDULE_STATE, A.SCHEDULE_DATE, A.AMOUNT, A.PRICE)
		BULK COLLECT INTO p_SCHEDULE
		FROM IT_SCHEDULE A
		WHERE A.TRANSACTION_ID = p_TRANSACTION_ID
			AND A.SCHEDULE_TYPE = p_SCHEDULE_TYPE
			AND A.SCHEDULE_STATE = p_SCHEDULE_STATE
			AND A.SCHEDULE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
			AND A.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM IT_SCHEDULE
				WHERE TRANSACTION_ID = A.TRANSACTION_ID
					AND SCHEDULE_TYPE = A.SCHEDULE_TYPE
					AND SCHEDULE_STATE = A.SCHEDULE_STATE
					AND SCHEDULE_DATE = A.SCHEDULE_DATE
					AND AS_OF_DATE <= v_AS_OF_DATE);
	ELSE
		v_AS_OF_DATE := CONSTANTS.LOW_DATE;
		SELECT SCHEDULE_STATE_TYPE(A.TRANSACTION_ID, A.SCHEDULE_TYPE, A.SCHEDULE_STATE, A.SCHEDULE_DATE, A.AMOUNT, A.PRICE)
		BULK COLLECT INTO p_SCHEDULE
		FROM IT_SCHEDULE A
		WHERE A.TRANSACTION_ID = p_TRANSACTION_ID
			AND A.SCHEDULE_TYPE = p_SCHEDULE_TYPE
			AND A.SCHEDULE_STATE = p_SCHEDULE_STATE
			AND A.SCHEDULE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
			AND AS_OF_DATE = v_AS_OF_DATE;
	END IF;

END GET_SCHEDULE;
------------------------------------------------------------------------------------------------------------
PROCEDURE SCHEDULE_COMPARISON_FILL
	(
	p_SCHEDULE IN OUT NOCOPY SCHEDULE_COMPARE_TABLE
	) AS

-- no longer used from GUI.  It used to be the Schedule Comparison View.
v_INDEX BINARY_INTEGER;
v_IDX BINARY_INTEGER;
v_START BINARY_INTEGER;
v_QUANTITY NUMBER;
v_PRICE NUMBER;
v_COUNT NUMBER;
v_RESET BOOLEAN;

BEGIN

	IF LOGS.IS_DEBUG_ENABLED() THEN
	    LOGS.LOG_DEBUG('SCHEDULE_COMPARISON_FILL');
	    LOGS.LOG_DEBUG('SCHEDULE.COUNT=' || TO_CHAR(p_SCHEDULE.COUNT));
	    LOGS.LOG_DEBUG('ALPHA');
	END IF;

	v_INDEX := p_SCHEDULE.FIRST;
	v_RESET := TRUE;
	WHILE v_INDEX <= p_SCHEDULE.LAST LOOP
		IF v_RESET THEN
			v_START := v_INDEX;
			v_RESET := FALSE;
		END IF;
		IF p_SCHEDULE(v_INDEX).ALPHA_SCHEDULE_QUANTITY IS NOT NULL THEN
			v_RESET := TRUE;
			IF NOT v_START = v_INDEX THEN
				v_COUNT := v_INDEX - v_START + 1;
				v_QUANTITY := p_SCHEDULE(v_INDEX).ALPHA_SCHEDULE_QUANTITY / v_COUNT;
				v_PRICE := p_SCHEDULE(v_INDEX).ALPHA_SCHEDULE_PRICE;
				IF LOGS.IS_DEBUG_ENABLED() THEN
				    LOGS.LOG_DEBUG('START=' || TO_CHAR(v_START));
				    LOGS.LOG_DEBUG('STOP=' || TO_CHAR(v_INDEX));
				    LOGS.LOG_DEBUG('COUNT=' || TO_CHAR(v_COUNT));
				    LOGS.LOG_DEBUG('QUANTITY=' || TO_CHAR(v_QUANTITY));
				    LOGS.LOG_DEBUG('PRICE=' || TO_CHAR(v_PRICE));
				END IF;
				FOR v_IDX IN v_START..v_INDEX LOOP
					p_SCHEDULE(v_IDX).ALPHA_SCHEDULE_QUANTITY := v_QUANTITY;
					p_SCHEDULE(v_IDX).ALPHA_SCHEDULE_PRICE := v_PRICE;
				END LOOP;
			END IF;
		END IF;
		v_INDEX := p_SCHEDULE.NEXT(v_INDEX);
	END LOOP;

	IF LOGS.IS_DEBUG_ENABLED() THEN
	    LOGS.LOG_DEBUG('BETA');
	END IF;

	v_INDEX := p_SCHEDULE.FIRST;
	v_RESET := TRUE;
	WHILE v_INDEX <= p_SCHEDULE.LAST LOOP
		IF v_RESET THEN
			v_START := v_INDEX;
			v_RESET := FALSE;
		END IF;
		IF p_SCHEDULE(v_INDEX).BETA_SCHEDULE_QUANTITY IS NOT NULL THEN
			v_RESET := TRUE;
			IF NOT v_START = v_INDEX THEN
				v_COUNT := v_INDEX - v_START + 1;
				v_QUANTITY := p_SCHEDULE(v_INDEX).BETA_SCHEDULE_QUANTITY / v_COUNT;
				v_PRICE := p_SCHEDULE(v_INDEX).BETA_SCHEDULE_PRICE;
				IF LOGS.IS_DEBUG_ENABLED() THEN
				    LOGS.LOG_DEBUG('START=' || TO_CHAR(v_START));
				    LOGS.LOG_DEBUG('STOP=' || TO_CHAR(v_INDEX));
				    LOGS.LOG_DEBUG('COUNT=' || TO_CHAR(v_COUNT));
				    LOGS.LOG_DEBUG('QUANTITY=' || TO_CHAR(v_QUANTITY));
				    LOGS.LOG_DEBUG('PRICE=' || TO_CHAR(v_PRICE));
				END IF;
				FOR v_IDX IN v_START..v_INDEX LOOP
					p_SCHEDULE(v_IDX).BETA_SCHEDULE_QUANTITY := v_QUANTITY;
					p_SCHEDULE(v_IDX).BETA_SCHEDULE_PRICE := v_PRICE;
				END LOOP;
			END IF;
		END IF;
		v_INDEX := p_SCHEDULE.NEXT(v_INDEX);
	END LOOP;

END SCHEDULE_COMPARISON_FILL;
------------------------------------------------------------------------------------------------------------
PROCEDURE SCHEDULE_COMPARISON
	(
	p_TRANSACTION_ID IN NUMBER,
	p_COMPARISON_MODE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- COMPARISON MODE:
-- 1 - Forecast-Preliminary
-- 2 - Forecast-Final
-- 3 - Preliminary-Final
-- 4 - Forecast-External
-- 5 - Preliminary-External
-- 6 - Final-External

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_SCHEDULE_DATE DATE;
v_FORMAT VARCHAR(4);
v_MINUTES NUMBER(6);
v_COUNT NUMBER(6) := 0;
v_INDEX BINARY_INTEGER;
v_DELTA_INDEX BINARY_INTEGER;
v_ALPHA_SCHEDULE SCHEDULE_STATE_TABLE := SCHEDULE_STATE_TABLE();
v_BETA_SCHEDULE SCHEDULE_STATE_TABLE := SCHEDULE_STATE_TABLE();
v_DELTA_SCHEDULE SCHEDULE_COMPARE_TABLE := SCHEDULE_COMPARE_TABLE();

-- no longer used from GUI.  It used to be the Schedule Comparison View.

BEGIN

	IF LOGS.IS_DEBUG_ENABLED() THEN
	    LOGS.LOG_DEBUG('SCHEDULE_COMPARISON');
	    LOGS.LOG_DEBUG('TRANSACTION_ID=' || TO_CHAR(p_TRANSACTION_ID));
	    LOGS.LOG_DEBUG('COMPARISON_MODE=' || TO_CHAR(p_COMPARISON_MODE));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TO_CHAR(p_END_DATE));
		LOGS.LOG_DEBUG('AS_OF_DATE=' || UT.TRACE_DATE(p_END_DATE));
		LOGS.LOG_DEBUG('TIME_ZONE=' || p_TIME_ZONE);
	END IF;

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	COERCE_DATE_RANGE(p_TRANSACTION_ID, CONSTANTS.INTERNAL_STATE, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, p_COMPARISON_MODE > 3, v_BEGIN_DATE, v_END_DATE, v_FORMAT, v_MINUTES);
	v_SCHEDULE_DATE := v_BEGIN_DATE;

	WHILE v_SCHEDULE_DATE <= v_END_DATE LOOP
		v_COUNT := v_COUNT + 1;
		v_SCHEDULE_DATE := ADD_MINUTES_TO_DATE(v_SCHEDULE_DATE, v_MINUTES);
	END LOOP;

	v_DELTA_SCHEDULE.EXTEND(v_COUNT);
	v_DELTA_INDEX := v_DELTA_SCHEDULE.FIRST;
	v_SCHEDULE_DATE := v_BEGIN_DATE;
	WHILE v_DELTA_INDEX <= v_DELTA_SCHEDULE.LAST LOOP
		v_DELTA_SCHEDULE(v_DELTA_INDEX) := SCHEDULE_COMPARE_TYPE(v_SCHEDULE_DATE, NULL, NULL, NULL, NULL);
		v_SCHEDULE_DATE := ADD_MINUTES_TO_DATE(v_SCHEDULE_DATE, v_MINUTES);
		v_DELTA_INDEX := v_DELTA_SCHEDULE.NEXT(v_DELTA_INDEX);
	END LOOP;

	IF LOGS.IS_DEBUG_ENABLED() THEN
	    LOGS.LOG_DEBUG('DELTA_SCHEDULE.COUNT=' || TO_CHAR(v_DELTA_SCHEDULE.COUNT));
	END IF;

	IF p_COMPARISON_MODE IN (1,2,4) THEN
		GET_SCHEDULE(p_TRANSACTION_ID, 1, CONSTANTS.INTERNAL_STATE, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, v_ALPHA_SCHEDULE);
	ELSIF p_COMPARISON_MODE IN (3,5) THEN
		GET_SCHEDULE(p_TRANSACTION_ID, 2, CONSTANTS.INTERNAL_STATE, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, v_ALPHA_SCHEDULE);
	ELSE
		GET_SCHEDULE(p_TRANSACTION_ID, 3, CONSTANTS.INTERNAL_STATE, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, v_ALPHA_SCHEDULE);
	END IF;

	IF p_COMPARISON_MODE = 1 THEN
		GET_SCHEDULE(p_TRANSACTION_ID, 2, CONSTANTS.INTERNAL_STATE, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, v_BETA_SCHEDULE);
	ELSIF p_COMPARISON_MODE IN (2,3) THEN
		GET_SCHEDULE(p_TRANSACTION_ID, 3, CONSTANTS.INTERNAL_STATE, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, v_BETA_SCHEDULE);
	ELSE
		GET_SCHEDULE(p_TRANSACTION_ID, p_COMPARISON_MODE - 3, CONSTANTS.EXTERNAL_STATE, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, v_BETA_SCHEDULE);
	END IF;

	IF LOGS.IS_DEBUG_ENABLED() THEN
	    LOGS.LOG_DEBUG('ALPHA_SCHEDULE.COUNT=' || TO_CHAR(v_ALPHA_SCHEDULE.COUNT));
	END IF;

	v_INDEX := v_ALPHA_SCHEDULE.FIRST;
	WHILE v_INDEX <= v_ALPHA_SCHEDULE.LAST LOOP
		v_DELTA_INDEX := v_DELTA_SCHEDULE.FIRST;
		WHILE v_DELTA_INDEX <= v_DELTA_SCHEDULE.LAST LOOP
			IF v_ALPHA_SCHEDULE(v_INDEX).SCHEDULE_DATE = v_DELTA_SCHEDULE(v_DELTA_INDEX).SCHEDULE_DATE THEN
				v_DELTA_SCHEDULE(v_DELTA_INDEX).ALPHA_SCHEDULE_QUANTITY := v_ALPHA_SCHEDULE(v_INDEX).SCHEDULE_QUANTITY;
				v_DELTA_SCHEDULE(v_DELTA_INDEX).ALPHA_SCHEDULE_PRICE := v_ALPHA_SCHEDULE(v_INDEX).SCHEDULE_PRICE;
				EXIT;
			END IF;
			v_DELTA_INDEX := v_DELTA_SCHEDULE.NEXT(v_DELTA_INDEX);
		END LOOP;
		v_INDEX := v_ALPHA_SCHEDULE.NEXT(v_INDEX);
	END LOOP;

	IF LOGS.IS_DEBUG_ENABLED() THEN
	    LOGS.LOG_DEBUG('BETA_SCHEDULE.COUNT=' || TO_CHAR(v_BETA_SCHEDULE.COUNT));
	END IF;

	v_INDEX := v_BETA_SCHEDULE.FIRST;
	WHILE v_INDEX <= v_BETA_SCHEDULE.LAST LOOP
		v_DELTA_INDEX := v_DELTA_SCHEDULE.FIRST;
		WHILE v_DELTA_INDEX <= v_DELTA_SCHEDULE.LAST LOOP
			IF v_BETA_SCHEDULE(v_INDEX).SCHEDULE_DATE = v_DELTA_SCHEDULE(v_DELTA_INDEX).SCHEDULE_DATE THEN
				v_DELTA_SCHEDULE(v_DELTA_INDEX).BETA_SCHEDULE_QUANTITY := v_BETA_SCHEDULE(v_INDEX).SCHEDULE_QUANTITY;
				v_DELTA_SCHEDULE(v_DELTA_INDEX).BETA_SCHEDULE_PRICE := v_BETA_SCHEDULE(v_INDEX).SCHEDULE_PRICE;
				EXIT;
			END IF;
			v_DELTA_INDEX := v_DELTA_SCHEDULE.NEXT(v_DELTA_INDEX);
		END LOOP;
		v_INDEX := v_BETA_SCHEDULE.NEXT(v_INDEX);
	END LOOP;

	SCHEDULE_COMPARISON_FILL(v_DELTA_SCHEDULE);

	OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(A.SCHEDULE_DATE, p_TIME_ZONE, v_FORMAT, GA.ELECTRIC_MODEL) "SCHEDULE_DATE",
			A.ALPHA_SCHEDULE_QUANTITY,
			A.ALPHA_SCHEDULE_PRICE,
			A.ALPHA_SCHEDULE_QUANTITY * A.ALPHA_SCHEDULE_PRICE "ALPHA_COST_REVENUE",
			A.BETA_SCHEDULE_QUANTITY,
			A.BETA_SCHEDULE_PRICE,
			A.BETA_SCHEDULE_QUANTITY * A.BETA_SCHEDULE_PRICE "BETA_COST_REVENUE"
		FROM TABLE(CAST(v_DELTA_SCHEDULE AS SCHEDULE_COMPARE_TABLE)) A
		ORDER BY 1;

END SCHEDULE_COMPARISON;
---------------------------------------------------------------------------------------------------
PROCEDURE SCHEDULE_TEMPLATE_NAMES
    (
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the names of PSE that are a purchasing party to the transaction.

BEGIN

	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		  SELECT TEMPLATE_NAME
		  FROM SCHEDULE_TEMPLATE
		  ORDER BY TEMPLATE_ORDER;


END SCHEDULE_TEMPLATE_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE SCHEDULER_SCHEDULE
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the schedule's detailed data for the specified selection criteria.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_SCHEDULE_DATE DATE;
v_FORMAT VARCHAR(4);
v_MINUTES NUMBER(6);
v_COUNT NUMBER(6) := 0;
v_INDEX BINARY_INTEGER;
v_ALPHA_INDEX BINARY_INTEGER;
v_SCHEDULE SCHEDULE_STATE_TABLE := SCHEDULE_STATE_TABLE();
v_ALPHA_SCHEDULE SCHEDULE_STATE_TABLE := SCHEDULE_STATE_TABLE();

BEGIN

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_TXN_SELECT, p_TRANSACTION_ID, EC.ED_TRANSACTION);

	p_STATUS := GA.SUCCESS;

	IF LOGS.IS_DEBUG_ENABLED() THEN
	    LOGS.LOG_DEBUG('SCHEDULER_SCHEDULE');
	    LOGS.LOG_DEBUG('TRANSACTION_ID=' || TO_CHAR(p_TRANSACTION_ID));
	    LOGS.LOG_DEBUG('SCHEDULE_TYPE=' || TO_CHAR(p_SCHEDULE_TYPE));
	    LOGS.LOG_DEBUG('SCHEDULE_STATE=' || TO_CHAR(p_SCHEDULE_TYPE));
		LOGS.LOG_DEBUG('BEGIN_DATE=' || TO_CHAR(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || TO_CHAR(p_END_DATE));
		LOGS.LOG_DEBUG('AS_OF_DATE=' || UT.TRACE_DATE(p_END_DATE));
		LOGS.LOG_DEBUG('TIME_ZONE=' || p_TIME_ZONE);
	END IF;

	COERCE_DATE_RANGE(p_TRANSACTION_ID, p_SCHEDULE_STATE, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, FALSE, v_BEGIN_DATE, v_END_DATE, v_FORMAT, v_MINUTES);
	v_SCHEDULE_DATE := v_BEGIN_DATE;

	WHILE v_SCHEDULE_DATE <= v_END_DATE LOOP
		v_COUNT := v_COUNT + 1;
		v_SCHEDULE_DATE := ADD_MINUTES_TO_DATE(v_SCHEDULE_DATE, v_MINUTES);
	END LOOP;

	IF LOGS.IS_DEBUG_ENABLED() THEN
	    LOGS.LOG_DEBUG('SCHEDULE COUNT=' || TO_CHAR(v_COUNT));
	END IF;

	v_SCHEDULE.EXTEND(v_COUNT);
	v_INDEX := v_SCHEDULE.FIRST;
	v_SCHEDULE_DATE := v_BEGIN_DATE;
	WHILE v_INDEX <= v_SCHEDULE.LAST LOOP
		v_SCHEDULE(v_INDEX) := SCHEDULE_STATE_TYPE(p_TRANSACTION_ID, p_SCHEDULE_TYPE, p_SCHEDULE_STATE, v_SCHEDULE_DATE, 0, 0);
		v_SCHEDULE_DATE := ADD_MINUTES_TO_DATE(v_SCHEDULE_DATE, v_MINUTES);
		v_INDEX := v_SCHEDULE.NEXT(v_INDEX);
	END LOOP;

	GET_SCHEDULE(p_TRANSACTION_ID, p_SCHEDULE_TYPE, p_SCHEDULE_STATE, v_BEGIN_DATE, v_END_DATE, p_AS_OF_DATE, v_ALPHA_SCHEDULE);

	IF LOGS.IS_DEBUG_ENABLED() THEN
	    LOGS.LOG_DEBUG('ALPHA_SCHEDULE.COUNT=' || TO_CHAR(v_ALPHA_SCHEDULE.COUNT));
	END IF;

	v_ALPHA_INDEX := v_ALPHA_SCHEDULE.FIRST;
	WHILE v_ALPHA_INDEX <= v_ALPHA_SCHEDULE.LAST LOOP
		v_INDEX := v_SCHEDULE.FIRST;
		WHILE v_INDEX <= v_SCHEDULE.LAST LOOP
			IF v_ALPHA_SCHEDULE(v_ALPHA_INDEX).SCHEDULE_DATE = v_SCHEDULE(v_INDEX).SCHEDULE_DATE THEN
				v_SCHEDULE(v_INDEX).SCHEDULE_QUANTITY := v_ALPHA_SCHEDULE(v_ALPHA_INDEX).SCHEDULE_QUANTITY;
				v_SCHEDULE(v_INDEX).SCHEDULE_PRICE := v_ALPHA_SCHEDULE(v_ALPHA_INDEX).SCHEDULE_PRICE;
				EXIT;
			END IF;
			v_INDEX := v_SCHEDULE.NEXT(v_INDEX);
		END LOOP;
		v_ALPHA_INDEX := v_ALPHA_SCHEDULE.NEXT(v_ALPHA_INDEX);
	END LOOP;

	OPEN p_CURSOR FOR
		SELECT FROM_CUT_AS_HED(A.SCHEDULE_DATE, p_TIME_ZONE, v_FORMAT, GA.ELECTRIC_MODEL) "SCHEDULE_DATE",
			A.SCHEDULE_QUANTITY "AMOUNT",
			A.SCHEDULE_PRICE "PRICE",
			A.SCHEDULE_QUANTITY * A.SCHEDULE_PRICE "COST",
 			NULL "EXT_AMOUNT",
			NULL "EXT_PRICE",
			NULL "EXT_COST"
		FROM TABLE(CAST(v_SCHEDULE AS SCHEDULE_STATE_TABLE)) A
		ORDER BY 1;


END SCHEDULER_SCHEDULE;
---------------------------------------------------------------------------
PROCEDURE PUT_IT_SCHEDULE_FOR_HOUR
	(
	p_TRANSACTION_ID IN NUMBER,
	p_SCHEDULE_TYPE IN NUMBER,
	p_SCHEDULE_STATE IN NUMBER,
	p_SCHEDULE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_AMOUNT IN NUMBER,
	p_PRICE IN NUMBER,
	p_MINUTES IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_END_DATE DATE;
v_SCHEDULE_DATE DATE;
v_LOOP_COUNTER NUMBER(5) := 0;
--EXPANDS AND STORES AN HOUR OF DATA TO THE INTERVAL SPECIFIED.
BEGIN

--DLS is checked before data is inserted.

	p_STATUS := GA.SUCCESS;

	v_END_DATE := TO_CUT(p_SCHEDULE_DATE, p_TIME_ZONE);
	v_SCHEDULE_DATE := ADD_MINUTES_TO_DATE(v_END_DATE, p_MINUTES - 60);

	WHILE v_SCHEDULE_DATE <= v_END_DATE LOOP
		PUT_IT_SCHEDULE(p_TRANSACTION_ID, p_SCHEDULE_TYPE, p_SCHEDULE_STATE, v_SCHEDULE_DATE, p_AS_OF_DATE, p_AMOUNT, p_PRICE, p_STATUS);
		v_SCHEDULE_DATE := ADD_MINUTES_TO_DATE(v_SCHEDULE_DATE, p_MINUTES);

		--MAKE SURE WE AREN'T LOOPING FOREVER
		v_LOOP_COUNTER := v_LOOP_COUNTER + 1;
		IF v_LOOP_COUNTER > 1000 THEN
			ERRS.RAISE(MSGCODES.c_ERR_RUNAWAY_LOOP);
		END IF;
	END LOOP;

END PUT_IT_SCHEDULE_FOR_HOUR;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_SUMMARY
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
    p_SCHEDULE_TYPE IN NUMBER,
    p_COMMODITY IN VARCHAR2,
    p_INTERVAL IN VARCHAR2,
    p_TEMPLATE_ID IN NUMBER,
    p_ENTITY_TYPE IN VARCHAR2,
    p_ENTITY_IDs IN NUMBER_COLLECTION,
    p_STATUS OUT NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
v_INTERVAL VARCHAR2(16) := NVL(GET_INTERVAL_ABBREVIATION(p_INTERVAL),'HH');
v_BEGIN_DATE DATE;
v_BEGIN_DATE_SDT DATE;
v_END_DATE DATE;

v_HOLIDAY_SETS NUMBER_COLLECTION;

BEGIN
	IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

	--Make sure we have data in the SYSTEM_DATE_TIME table.  Return an error if not.
	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, p_BEGIN_DATE, p_END_DATE);

    --Make sure we have a valid Commodity
	IF p_COMMODITY IS NULL THEN
		NULL_CURSOR(p_CURSOR);
		RETURN;
	END IF;

    IF p_ENTITY_IDs IS NULL THEN
		NULL_CURSOR(p_CURSOR);
		RETURN;
	END IF;

	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	-- System_Date_Time table does not store daily values a second past midnight, so
	-- in order to capture them we need to tick begin date back a second
	v_BEGIN_DATE_SDT := v_BEGIN_DATE-1/86400;

	SELECT DISTINCT HS.HOLIDAY_SET_ID
	BULK COLLECT INTO v_HOLIDAY_SETS
	FROM (SELECT DECODE(UPPER(p_ENTITY_TYPE),'PURCHASER',A.PURCHASER_ID,
                										'SELLER',A.SELLER_ID,
                                                        'POR',A.POR_ID,
                                                        'POD',A.POD_ID,
                                                        'TP',C.TP_ID,
                                                        'EDC',C.EDC_ID) "ENTITY_ID",
							NVL(H.EDC_HOLIDAY_SET_ID, CONSTANTS.ALL_HOLIDAYS_HOLIDAY_SET) AS HOLIDAY_SET_ID
    					FROM INTERCHANGE_TRANSACTION A,
    						IT_COMMODITY B,
    						SERVICE_POINT C,
    						ENERGY_DISTRIBUTION_COMPANY H
    					WHERE B.COMMODITY_ID = A.COMMODITY_ID
    						AND B.COMMODITY_TYPE = p_COMMODITY
    						AND C.SERVICE_POINT_ID(+) = A.POD_ID
    						AND H.EDC_ID(+) = C.EDC_ID) HS,
         TABLE(CAST(p_ENTITY_IDs AS NUMBER_COLLECTION)) X
	WHERE HS.ENTITY_ID = X.COLUMN_VALUE;

    IF p_TEMPLATE_ID > 0 THEN

		SP.CHECK_TEMPLATE_DATES(NUMBER_COLLECTION(p_TEMPLATE_ID),
							v_HOLIDAY_SETS,
							p_TIME_ZONE,
							p_BEGIN_DATE,
							p_END_DATE);

    	OPEN p_CURSOR FOR
    		SELECT SUBSTR(TRIM(SCHEDULE_DATE), 0, 10) "SCHEDULE_DATE",
                CASE v_INTERVAL
        			WHEN 'HH' THEN SUBSTR(TRIM(SCHEDULE_DATE), 12)
        			ELSE NULL
        		END "SCHEDULE_TIME",
                ENTITY_NAME,
            	ENTITY_ID,
    			0 "IS_TOTAL",
    			PERIOD_NAME,
    			PERIOD_ID,
    			SUM(LOAD) "LOAD",
    			MIN(LOAD_STATISTIC) "MIN_LOAD",
    			MAX(LOAD_STATISTIC) "MAX_LOAD",
    			AVG(LOAD_STATISTIC) "AVG_LOAD",
    			SUM(PURCHASE_AMOUNT-SALE_AMOUNT) "NET_SUPPLY_AMOUNT",
    			SUM(PURCHASE_AMOUNT*PURCHASE_PRICE-SALE_AMOUNT*SALE_PRICE) "NET_SUPPLY_COST",
    			DECODE(NVL(SUM(PURCHASE_AMOUNT-SALE_AMOUNT),0),0,0,SUM(PURCHASE_AMOUNT*PURCHASE_PRICE-SALE_AMOUNT*SALE_PRICE)/SUM(PURCHASE_AMOUNT-SALE_AMOUNT)) "NET_SUPPLY_WACOG",
    			SUM(PURCHASE_AMOUNT) "PURCHASE_AMOUNT",
    			SUM(PURCHASE_AMOUNT*PURCHASE_PRICE) "PURCHASE_COST",
    			DECODE(NVL(SUM(PURCHASE_AMOUNT),0),0,0,SUM(PURCHASE_AMOUNT*PURCHASE_PRICE)/SUM(PURCHASE_AMOUNT)) "PURCHASE_WACOG",
    			SUM(SALE_AMOUNT) "SALE_AMOUNT",
    			SUM(SALE_AMOUNT*SALE_PRICE) "SALE_COST",
    			DECODE(NVL(SUM(SALE_AMOUNT),0),0,0,SUM(SALE_AMOUNT*SALE_PRICE)/SUM(SALE_AMOUNT)) "SALE_WACOG"
    		FROM (SELECT A.ENTITY_ID, A.ENTITY_NAME,
						F.PERIOD_NAME, F.PERIOD_ID,
						CASE v_INTERVAL
							WHEN 'HH' THEN C.HOUR_YYYY_MM_DD
							WHEN 'DD' THEN C.DAY_YYYY_MM_DD
							WHEN 'DY' THEN C.WEEK_YYYY_MM_DD
							WHEN 'MM' THEN C.MONTH_YYYY_MM_DD
							WHEN 'Q' THEN C.QUARTER_YYYY_MM_DD
							WHEN 'YY' THEN C.YEAR_YYYY_MM_DD
							ELSE C.NO_ROLLUP_YYYY_MM_DD
						END "SCHEDULE_DATE",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'LO', B.AMOUNT, 'RE', B.AMOUNT, NULL) "LOAD_STATISTIC",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'LO', NVL(B.AMOUNT,0),'RE', NVL(B.AMOUNT,0), 0) "LOAD",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'PU', NVL(B.AMOUNT,0),0) "PURCHASE_AMOUNT",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'PU', NVL(B.PRICE,0),0) "PURCHASE_PRICE",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'SA', NVL(B.AMOUNT,0),0) "SALE_AMOUNT",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'SA', NVL(B.PRICE,0),0) "SALE_PRICE"
				FROM (SELECT DECODE(UPPER(p_ENTITY_TYPE),'PURCHASER',A.PURCHASER_ID,
                										'SELLER',A.SELLER_ID,
                                                        'POR',A.POR_ID,
                                                        'POD',A.POD_ID,
                                                        'TP',C.TP_ID,
                                                        'EDC',C.EDC_ID) "ENTITY_ID",
    						DECODE(UPPER(p_ENTITY_TYPE),'PURCHASER',E.PSE_NAME,
                										'SELLER',F.PSE_NAME,
                                                        'POR',D.SERVICE_POINT_NAME,
                                                        'POD',C.SERVICE_POINT_ID,
                                                        'TP',G.TP_NAME,
                                                        'EDC',H.EDC_NAME) "ENTITY_NAME",
							A.TRANSACTION_ID,
							A.TRANSACTION_TYPE,
							H.EDC_ID,
							NVL(H.EDC_HOLIDAY_SET_ID, CONSTANTS.ALL_HOLIDAYS_HOLIDAY_SET) AS HOLIDAY_SET_ID
    					FROM INTERCHANGE_TRANSACTION A,
    						IT_COMMODITY B,
    						SERVICE_POINT C,
    						SERVICE_POINT D,
    						PURCHASING_SELLING_ENTITY E,
    						PURCHASING_SELLING_ENTITY F,
    						TRANSMISSION_PROVIDER G,
    						ENERGY_DISTRIBUTION_COMPANY H
    					WHERE B.COMMODITY_ID = A.COMMODITY_ID
    						AND B.COMMODITY_TYPE = p_COMMODITY
    						AND C.SERVICE_POINT_ID(+) = A.POD_ID
    						AND D.SERVICE_POINT_ID(+) = A.POR_ID
    						AND E.PSE_ID(+) = A.PURCHASER_ID
    						AND F.PSE_ID(+) = A.SELLER_ID
    						AND G.TP_ID(+) = C.TP_ID
    						AND H.EDC_ID(+) = C.EDC_ID) A,
	   				IT_SCHEDULE B,
	   				SYSTEM_DATE_TIME C,
	    			TEMPLATE_DATES TD,
					TEMPLATE_DAY_TYPE_PERIOD DT,
	    			PERIOD F,
            		TABLE(CAST(p_ENTITY_IDs AS NUMBER_COLLECTION)) G
	       		WHERE A.ENTITY_ID = G.COLUMN_VALUE
					AND C.TIME_ZONE = p_TIME_ZONE
					AND C.DATA_INTERVAL_TYPE = 1
					AND C.DAY_TYPE = 1
					AND C.CUT_DATE BETWEEN v_BEGIN_DATE_SDT AND v_END_DATE
					AND B.TRANSACTION_ID = A.TRANSACTION_ID
					AND B.SCHEDULE_TYPE = p_SCHEDULE_TYPE
					AND B.SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE
					AND B.SCHEDULE_DATE = C.CUT_DATE_SCHEDULING
					AND B.SCHEDULE_DATE >= v_BEGIN_DATE
					AND B.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
										FROM IT_SCHEDULE
										WHERE TRANSACTION_ID = B.TRANSACTION_ID
											AND SCHEDULE_TYPE = B.SCHEDULE_TYPE
											AND SCHEDULE_STATE = B.SCHEDULE_STATE
											AND SCHEDULE_DATE = B.SCHEDULE_DATE
											AND AS_OF_DATE <= p_AS_OF_DATE)
					AND TD.TEMPLATE_ID = p_TEMPLATE_ID
					AND TD.TIME_ZONE = p_TIME_ZONE
					AND TD.HOLIDAY_SET_ID = A.HOLIDAY_SET_ID
					AND B.SCHEDULE_DATE > TD.CUT_BEGIN_DATE
					AND B.SCHEDULE_DATE <= TD.CUT_END_DATE
	    			AND DT.DAY_TYPE_ID = TD.DAY_TYPE_ID
					AND B.SCHEDULE_DATE = TD.CUT_BEGIN_DATE + DT.TIME_STAMP
	    			AND F.PERIOD_ID = DT.PERIOD_ID)
			GROUP BY SCHEDULE_DATE, ENTITY_ID, ENTITY_NAME, PERIOD_ID, PERIOD_NAME
    		UNION ALL
    		SELECT SUBSTR(TRIM(SCHEDULE_DATE), 0, 10) "SCHEDULE_DATE",
                CASE v_INTERVAL
        			WHEN 'HH' THEN SUBSTR(TRIM(SCHEDULE_DATE), 12)
        			ELSE NULL
        		END "SCHEDULE_TIME",
                ENTITY_NAME,
            	ENTITY_ID,
    			1 "IS_TOTAL",
    			'Total' "PERIOD_NAME",
    			0 "PERIOD_ID",
    			SUM(LOAD) "LOAD",
    			MIN(LOAD_STATISTIC) "MIN_LOAD",
    			MAX(LOAD_STATISTIC) "MAX_LOAD",
    			AVG(LOAD_STATISTIC) "AVG_LOAD",
    			SUM(PURCHASE_AMOUNT-SALE_AMOUNT) "NET_SUPPLY_AMOUNT",
    			SUM(PURCHASE_AMOUNT*PURCHASE_PRICE-SALE_AMOUNT*SALE_PRICE) "NET_SUPPLY_COST",
    			DECODE(NVL(SUM(PURCHASE_AMOUNT-SALE_AMOUNT),0),0,0,SUM(PURCHASE_AMOUNT*PURCHASE_PRICE-SALE_AMOUNT*SALE_PRICE)/SUM(PURCHASE_AMOUNT-SALE_AMOUNT)) "NET_SUPPLY_WACOG",
    			SUM(PURCHASE_AMOUNT) "PURCHASE_AMOUNT",
    			SUM(PURCHASE_AMOUNT*PURCHASE_PRICE) "PURCHASE_COST",
    			DECODE(NVL(SUM(PURCHASE_AMOUNT),0),0,0,SUM(PURCHASE_AMOUNT*PURCHASE_PRICE)/SUM(PURCHASE_AMOUNT)) "PURCHASE_WACOG",
    			SUM(SALE_AMOUNT) "SALE_AMOUNT",
    			SUM(SALE_AMOUNT*SALE_PRICE) "SALE_COST",
    			DECODE(NVL(SUM(SALE_AMOUNT),0),0,0,SUM(SALE_AMOUNT*SALE_PRICE)/SUM(SALE_AMOUNT)) "SALE_WACOG"
    		FROM (SELECT A.ENTITY_ID, A.ENTITY_NAME,
						CASE v_INTERVAL
							WHEN 'HH' THEN C.HOUR_YYYY_MM_DD
							WHEN 'DD' THEN C.DAY_YYYY_MM_DD
							WHEN 'DY' THEN C.WEEK_YYYY_MM_DD
							WHEN 'MM' THEN C.MONTH_YYYY_MM_DD
							WHEN 'Q' THEN C.QUARTER_YYYY_MM_DD
							WHEN 'YY' THEN C.YEAR_YYYY_MM_DD
							ELSE C.NO_ROLLUP_YYYY_MM_DD
						END "SCHEDULE_DATE",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'LO', B.AMOUNT, 'RE', B.AMOUNT, NULL) "LOAD_STATISTIC",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'LO', NVL(B.AMOUNT,0),'RE', NVL(B.AMOUNT,0), 0) "LOAD",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'PU', NVL(B.AMOUNT,0),0) "PURCHASE_AMOUNT",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'PU', NVL(B.PRICE,0),0) "PURCHASE_PRICE",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'SA', NVL(B.AMOUNT,0),0) "SALE_AMOUNT",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'SA', NVL(B.PRICE,0),0) "SALE_PRICE"
				FROM (SELECT DECODE(UPPER(p_ENTITY_TYPE),'PURCHASER',A.PURCHASER_ID,
                										'SELLER',A.SELLER_ID,
                                                        'POR',A.POR_ID,
                                                        'POD',A.POD_ID,
                                                        'TP',C.TP_ID,
                                                        'EDC',C.EDC_ID) "ENTITY_ID",
    						DECODE(UPPER(p_ENTITY_TYPE),'PURCHASER',E.PSE_NAME,
                										'SELLER',F.PSE_NAME,
                                                        'POR',D.SERVICE_POINT_NAME,
                                                        'POD',C.SERVICE_POINT_ID,
                                                        'TP',G.TP_NAME,
                                                        'EDC',H.EDC_NAME) "ENTITY_NAME",
							A.TRANSACTION_ID,
							A.TRANSACTION_TYPE
    					FROM INTERCHANGE_TRANSACTION A,
    						IT_COMMODITY B,
    						SERVICE_POINT C,
    						SERVICE_POINT D,
    						PURCHASING_SELLING_ENTITY E,
    						PURCHASING_SELLING_ENTITY F,
    						TRANSMISSION_PROVIDER G,
    						ENERGY_DISTRIBUTION_COMPANY H
    					WHERE B.COMMODITY_ID = A.COMMODITY_ID
    						AND B.COMMODITY_TYPE = p_COMMODITY
    						AND C.SERVICE_POINT_ID(+) = A.POD_ID
    						AND D.SERVICE_POINT_ID(+) = A.POR_ID
    						AND E.PSE_ID(+) = A.PURCHASER_ID
    						AND F.PSE_ID(+) = A.SELLER_ID
    						AND G.TP_ID(+) = C.TP_ID
    						AND H.EDC_ID(+) = C.EDC_ID) A,
	   				IT_SCHEDULE B,
	   				SYSTEM_DATE_TIME C,
            TABLE(CAST(p_ENTITY_IDs AS NUMBER_COLLECTION)) D
	       		WHERE A.ENTITY_ID = D.COLUMN_VALUE
					AND C.TIME_ZONE = p_TIME_ZONE
					AND C.DATA_INTERVAL_TYPE = 1
					AND C.DAY_TYPE = 1
					AND C.CUT_DATE BETWEEN v_BEGIN_DATE_SDT AND v_END_DATE
					AND B.TRANSACTION_ID = A.TRANSACTION_ID
					AND B.SCHEDULE_TYPE = p_SCHEDULE_TYPE
					AND B.SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE
					AND B.SCHEDULE_DATE = C.CUT_DATE_SCHEDULING
					AND B.SCHEDULE_DATE >= v_BEGIN_DATE
					AND B.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
										FROM IT_SCHEDULE
										WHERE TRANSACTION_ID = B.TRANSACTION_ID
											AND SCHEDULE_TYPE = B.SCHEDULE_TYPE
											AND SCHEDULE_STATE = B.SCHEDULE_STATE
											AND SCHEDULE_DATE = B.SCHEDULE_DATE
											AND AS_OF_DATE <= p_AS_OF_DATE))
			GROUP BY SCHEDULE_DATE, ENTITY_ID, ENTITY_NAME
	    	ORDER BY 5,6,7,1,2,3,4;
	ELSE
    	OPEN p_CURSOR FOR
    		SELECT SUBSTR(TRIM(SCHEDULE_DATE), 0, 10) "SCHEDULE_DATE",
                CASE v_INTERVAL
        			WHEN 'HH' THEN SUBSTR(TRIM(SCHEDULE_DATE), 12)
        			ELSE NULL
        		END "SCHEDULE_TIME",
                ENTITY_NAME,
            	ENTITY_ID,
    			1 "IS_TOTAL",
    			'Total' "PERIOD_NAME",
    			0 "PERIOD_ID",
    			SUM(LOAD) "LOAD",
    			MIN(LOAD_STATISTIC) "MIN_LOAD",
    			MAX(LOAD_STATISTIC) "MAX_LOAD",
    			AVG(LOAD_STATISTIC) "AVG_LOAD",
    			SUM(PURCHASE_AMOUNT-SALE_AMOUNT) "NET_SUPPLY_AMOUNT",
    			SUM(PURCHASE_AMOUNT*PURCHASE_PRICE-SALE_AMOUNT*SALE_PRICE) "NET_SUPPLY_COST",
    			DECODE(NVL(SUM(PURCHASE_AMOUNT-SALE_AMOUNT),0),0,0,SUM(PURCHASE_AMOUNT*PURCHASE_PRICE-SALE_AMOUNT*SALE_PRICE)/SUM(PURCHASE_AMOUNT-SALE_AMOUNT)) "NET_SUPPLY_WACOG",
    			SUM(PURCHASE_AMOUNT) "PURCHASE_AMOUNT",
    			SUM(PURCHASE_AMOUNT*PURCHASE_PRICE) "PURCHASE_COST",
    			DECODE(NVL(SUM(PURCHASE_AMOUNT),0),0,0,SUM(PURCHASE_AMOUNT*PURCHASE_PRICE)/SUM(PURCHASE_AMOUNT)) "PURCHASE_WACOG",
    			SUM(SALE_AMOUNT) "SALE_AMOUNT",
    			SUM(SALE_AMOUNT*SALE_PRICE) "SALE_COST",
    			DECODE(NVL(SUM(SALE_AMOUNT),0),0,0,SUM(SALE_AMOUNT*SALE_PRICE)/SUM(SALE_AMOUNT)) "SALE_WACOG"
    		FROM (SELECT A.ENTITY_ID, A.ENTITY_NAME,
						CASE v_INTERVAL
							WHEN 'HH' THEN C.HOUR_YYYY_MM_DD
							WHEN 'DD' THEN C.DAY_YYYY_MM_DD
							WHEN 'DY' THEN C.WEEK_YYYY_MM_DD
							WHEN 'MM' THEN C.MONTH_YYYY_MM_DD
							WHEN 'Q' THEN C.QUARTER_YYYY_MM_DD
							WHEN 'YY' THEN C.YEAR_YYYY_MM_DD
							ELSE C.NO_ROLLUP_YYYY_MM_DD
						END "SCHEDULE_DATE",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'LO', B.AMOUNT, 'RE', B.AMOUNT, NULL) "LOAD_STATISTIC",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'LO', NVL(B.AMOUNT,0),'RE', NVL(B.AMOUNT,0), 0) "LOAD",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'PU', NVL(B.AMOUNT,0),0) "PURCHASE_AMOUNT",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'PU', NVL(B.PRICE,0),0) "PURCHASE_PRICE",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'SA', NVL(B.AMOUNT,0),0) "SALE_AMOUNT",
						DECODE(UPPER(SUBSTR(A.TRANSACTION_TYPE,1,2)), 'SA', NVL(B.PRICE,0),0) "SALE_PRICE"
				FROM (SELECT DECODE(UPPER(p_ENTITY_TYPE),'PURCHASER',A.PURCHASER_ID,
                										'SELLER',A.SELLER_ID,
                                                        'POR',A.POR_ID,
                                                        'POD',A.POD_ID,
                                                        'TP',C.TP_ID,
                                                        'EDC',C.EDC_ID) "ENTITY_ID",
    						DECODE(UPPER(p_ENTITY_TYPE),'PURCHASER',E.PSE_NAME,
                										'SELLER',F.PSE_NAME,
                                                        'POR',D.SERVICE_POINT_NAME,
                                                        'POD',C.SERVICE_POINT_ID,
                                                        'TP',G.TP_NAME,
                                                        'EDC',H.EDC_NAME) "ENTITY_NAME",
							A.TRANSACTION_ID,
							A.TRANSACTION_TYPE
    					FROM INTERCHANGE_TRANSACTION A,
    						IT_COMMODITY B,
    						SERVICE_POINT C,
    						SERVICE_POINT D,
    						PURCHASING_SELLING_ENTITY E,
    						PURCHASING_SELLING_ENTITY F,
    						TRANSMISSION_PROVIDER G,
    						ENERGY_DISTRIBUTION_COMPANY H
    					WHERE B.COMMODITY_ID = A.COMMODITY_ID
    						AND B.COMMODITY_TYPE = p_COMMODITY
    						AND C.SERVICE_POINT_ID(+) = A.POD_ID
    						AND D.SERVICE_POINT_ID(+) = A.POR_ID
    						AND E.PSE_ID(+) = A.PURCHASER_ID
    						AND F.PSE_ID(+) = A.SELLER_ID
    						AND G.TP_ID(+) = C.TP_ID
    						AND H.EDC_ID(+) = C.EDC_ID) A,
	   				IT_SCHEDULE B,
	   				SYSTEM_DATE_TIME C,
            TABLE(CAST(p_ENTITY_IDs AS NUMBER_COLLECTION)) D
	       		WHERE A.ENTITY_ID = D.COLUMN_VALUE
					AND C.TIME_ZONE = p_TIME_ZONE
					AND C.DATA_INTERVAL_TYPE = 1
					AND C.DAY_TYPE = 1
					AND C.CUT_DATE BETWEEN v_BEGIN_DATE_SDT AND v_END_DATE
					AND B.TRANSACTION_ID = A.TRANSACTION_ID
					AND B.SCHEDULE_TYPE = p_SCHEDULE_TYPE
					AND B.SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE
					AND B.SCHEDULE_DATE = C.CUT_DATE_SCHEDULING
					AND B.SCHEDULE_DATE >= v_BEGIN_DATE
					AND B.AS_OF_DATE = (SELECT MAX(AS_OF_DATE)
										FROM IT_SCHEDULE
										WHERE TRANSACTION_ID = B.TRANSACTION_ID
											AND SCHEDULE_TYPE = B.SCHEDULE_TYPE
											AND SCHEDULE_STATE = B.SCHEDULE_STATE
											AND SCHEDULE_DATE = B.SCHEDULE_DATE
											AND AS_OF_DATE <= p_AS_OF_DATE))
			GROUP BY SCHEDULE_DATE, ENTITY_ID, ENTITY_NAME
	    	--ORDER BY 3,4, 5,6,7,1,2;
            ORDER BY 1,2,3,4,5,6,7;
    END IF;

	p_STATUS := GA.SUCCESS;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_RAISE();
END GET_SUMMARY;
---------------------------------------------------------------------------------------------------
FUNCTION IS_HOLIDAY_S
(
	p_DATE IN DATE,
	p_EDC_ID IN NUMBER DEFAULT 0
	) RETURN NUMBER DETERMINISTIC IS
BEGIN
	IF IS_HOLIDAY(p_DATE,p_EDC_ID) THEN
    	RETURN 1;
	ELSE
    	RETURN 0;
	END IF;
END IS_HOLIDAY_S;
---------------------------------------------------------------------------------------------------
PROCEDURE CALC_STORAGE_SCHEDULES
	(
	p_BEGIN_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_CONTRACT_ID IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR2
	) AS
v_IDs GA.ID_TABLE;
v_IDX BINARY_INTEGER;
BEGIN
	IF TRIM(p_CONTRACT_ID) IS NULL THEN
		p_STATUS := GA.SUCCESS;
		p_MESSAGE := 'No Storage Contract Specified!';
		RETURN;
	END IF;

	UT.IDS_FROM_STRING(p_CONTRACT_ID, ',', v_IDs);
	v_IDX := v_IDs.FIRST;
	WHILE v_IDs.EXISTS(v_IDX) LOOP
		CALC_STORAGE_SCHEDULE(p_BEGIN_DATE, p_SCHEDULE_TYPE, p_AS_OF_DATE, v_IDs(v_IDX));
		v_IDX := v_IDs.NEXT(v_IDX);
	END LOOP;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'Calculations Complete.';

END CALC_STORAGE_SCHEDULES;
---------------------------------------------------------------------------------------------------
PROCEDURE CALC_STORAGE_SCHEDULE
	(
	p_BEGIN_DATE IN DATE,
	p_SCHEDULE_TYPE IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_CONTRACT_ID IN NUMBER
	) AS
v_CONTRACT_BEGIN_DATE DATE;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_REC STORAGE_SCHEDULE%ROWTYPE;
v_INJ_FUEL_PCT NUMBER;
v_WD_FUEL_PCT NUMBER;
BEGIN
	-- query for date range that needs evaluation - from the latest date prior to
	-- p_BEGIN_DATE through the last schedule date
	SELECT LEAST(MAX(SCHEDULE_DATE), TRUNC(IC.END_DATE)+1/86400) INTO v_END_DATE
	FROM INTERCHANGE_CONTRACT IC, INTERCHANGE_TRANSACTION IT, IT_COMMODITY ITC, IT_SCHEDULE ITS
	WHERE IC.CONTRACT_ID = p_CONTRACT_ID
		AND IT.CONTRACT_ID = IC.CONTRACT_ID
		AND IT.TRANSACTION_TYPE IN ('Injection','Withdrawal')
		AND IT.TRANSACTION_INTERVAL = 'Day'
		AND ITC.COMMODITY_ID = IT.COMMODITY_ID
		AND ITC.COMMODITY_TYPE = 'Gas'
		AND ITS.TRANSACTION_ID = IT.TRANSACTION_ID
		AND ITS.SCHEDULE_TYPE = p_SCHEDULE_TYPE
		AND ITS.SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE
		AND ITS.AS_OF_DATE = CONSTANTS.LOW_DATE
	GROUP BY IC.END_DATE;

	-- first thing to do - clean up existing storage schedule
	DELETE STORAGE_SCHEDULE
	WHERE CONTRACT_ID = p_CONTRACT_ID
		AND STATEMENT_TYPE_ID = p_SCHEDULE_TYPE
		AND SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE
		AND AS_OF_DATE = CONSTANTS.LOW_DATE
		AND SCHEDULE_DATE > NVL(v_END_DATE,CONSTANTS.LOW_DATE);

	-- no schedules for this storage? nothing else to do
	IF v_END_DATE IS NULL THEN
		RETURN;
	END IF;

	v_REC.CONTRACT_ID := p_CONTRACT_ID;
	v_REC.STATEMENT_TYPE_ID := p_SCHEDULE_TYPE;
	v_REC.SCHEDULE_STATE := CONSTANTS.INTERNAL_STATE;
	v_REC.AS_OF_DATE := CONSTANTS.LOW_DATE;

	-- get contract begin date
	SELECT BEGIN_DATE INTO v_CONTRACT_BEGIN_DATE
	FROM INTERCHANGE_CONTRACT
	WHERE CONTRACT_ID = p_CONTRACT_ID;

	-- determine begin date for period that needs evaluation
	SELECT MAX(SCHEDULE_DATE) INTO v_BEGIN_DATE
	FROM STORAGE_SCHEDULE SS
	WHERE SS.CONTRACT_ID = p_CONTRACT_ID
		AND SS.STATEMENT_TYPE_ID = p_SCHEDULE_TYPE
		AND SS.SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE
		AND SS.AS_OF_DATE = CONSTANTS.LOW_DATE
		AND SS.SCHEDULE_DATE < p_BEGIN_DATE;

	IF v_BEGIN_DATE IS NULL THEN
		v_REC.BALANCE := 0;
		v_BEGIN_DATE := v_CONTRACT_BEGIN_DATE;
	ELSE
		SELECT BALANCE+TOTAL_INJECTIONS-TOTAL_INJECTION_FUEL-TOTAL_WITHDRAWALS-TOTAL_WITHDRAWAL_FUEL
		INTO v_REC.BALANCE
		FROM STORAGE_SCHEDULE SS
    	WHERE SS.CONTRACT_ID = p_CONTRACT_ID
    		AND SS.STATEMENT_TYPE_ID = p_SCHEDULE_TYPE
    		AND SS.SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE
    		AND SS.AS_OF_DATE = CONSTANTS.LOW_DATE
    		AND SS.SCHEDULE_DATE = v_BEGIN_DATE;
		v_BEGIN_DATE := v_BEGIN_DATE+1; -- start evaluation with the day after this last entry
	END IF;

	v_BEGIN_DATE := TRUNC(v_BEGIN_DATE)+1/86400;
	v_END_DATE := TRUNC(v_END_DATE)+1/86400;
	-- loop over days in the date range and calculate the storage schedule
	WHILE v_BEGIN_DATE <= v_END_DATE LOOP
		v_REC.SCHEDULE_DATE := v_BEGIN_DATE;

		SELECT MAX(SC.INJECTION_FUEL_PCT), MAX(SC.WITHDRAWAL_FUEL_PCT)
		INTO v_INJ_FUEL_PCT, v_WD_FUEL_PCT
		FROM STORAGE_CAPACITY SC
		WHERE SC.CONTRACT_ID = p_CONTRACT_ID
			AND TRUNC(v_BEGIN_DATE) BETWEEN SC.BEGIN_DATE AND NVL(SC.END_DATE,CONSTANTS.HIGH_DATE);

		SELECT NVL(SUM(CASE WHEN (IT.TRANSACTION_TYPE = 'Injection' AND ITS.AMOUNT > 0)
								OR (IT.TRANSACTION_TYPE = 'Withdrawal' AND ITS.AMOUNT < 0)
							THEN ABS(ITS.AMOUNT) ELSE 0 END),0),
			NVL(SUM(CASE WHEN (IT.TRANSACTION_TYPE = 'Withdrawal' AND ITS.AMOUNT > 0)
								OR (IT.TRANSACTION_TYPE = 'Injection' AND ITS.AMOUNT < 0)
							THEN ABS(ITS.AMOUNT) ELSE 0 END),0)
		INTO v_REC.TOTAL_INJECTIONS, v_REC.TOTAL_WITHDRAWALS
    	FROM INTERCHANGE_TRANSACTION IT, IT_COMMODITY ITC, IT_SCHEDULE ITS
    	WHERE IT.CONTRACT_ID = p_CONTRACT_ID
    		AND IT.TRANSACTION_TYPE IN ('Injection','Withdrawal')
    		AND IT.TRANSACTION_INTERVAL = 'Day'
    		AND ITC.COMMODITY_ID = IT.COMMODITY_ID
    		AND ITC.COMMODITY_TYPE = 'Gas'
    		AND ITS.TRANSACTION_ID = IT.TRANSACTION_ID
    		AND ITS.SCHEDULE_TYPE = p_SCHEDULE_TYPE
    		AND ITS.SCHEDULE_STATE = CONSTANTS.INTERNAL_STATE
    		AND ITS.SCHEDULE_DATE = v_BEGIN_DATE
    		AND ITS.AS_OF_DATE = CONSTANTS.LOW_DATE;

		v_REC.TOTAL_INJECTION_FUEL := NVL(v_INJ_FUEL_PCT,0)/100 * v_REC.TOTAL_INJECTIONS;
		v_REC.TOTAL_WITHDRAWAL_FUEL := NVL(v_WD_FUEL_PCT,0)/100 * v_REC.TOTAL_WITHDRAWALS;

		UPDATE STORAGE_SCHEDULE
        SET ROW = v_REC
        WHERE CONTRACT_ID = v_REC.CONTRACT_ID
	        AND STATEMENT_TYPE_ID = v_REC.STATEMENT_TYPE_ID
			AND SCHEDULE_STATE = v_REC.SCHEDULE_STATE
			AND SCHEDULE_DATE = v_REC.SCHEDULE_DATE
			AND AS_OF_DATE = v_REC.AS_OF_DATE;
		IF SQL%NOTFOUND THEN
			INSERT INTO STORAGE_SCHEDULE VALUES v_REC;
		END IF;

		v_BEGIN_DATE := v_BEGIN_DATE+1;
		-- compute starting balance for the next day
		v_REC.BALANCE := v_REC.BALANCE + v_REC.TOTAL_INJECTIONS - v_REC.TOTAL_INJECTION_FUEL
							- v_REC.TOTAL_WITHDRAWALS - v_REC.TOTAL_WITHDRAWAL_FUEL;
	END LOOP;

END CALC_STORAGE_SCHEDULE;
---------------------------------------------------------------------------------------------------
PROCEDURE IT_STATUS_NAME_LIST_FILTER
	(
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
    SELECT CONSTANTS.ALL_STRING As TRANSACTION_STATUS_NAME FROM DUAL
    UNION ALL
		SELECT i.TRANSACTION_STATUS_NAME FROM INTERCHANGE_TRANSACTION_STATUS i ORDER BY TRANSACTION_STATUS_NAME;
END IT_STATUS_NAME_LIST_FILTER;
----------------------------------------------------------------------------------------------------
FUNCTION TXN_TYPE_IS_SUPPLY ( p_TXN_TYPE IN VARCHAR2) RETURN BOOLEAN
IS
	v_COUNT PLS_INTEGER;
BEGIN
	SELECT COUNT(1)
	INTO v_COUNT
	FROM SYSTEM_LABEL
	WHERE MODEL_ID = CONSTANTS.ELECTRIC_MODEL
		AND MODULE = 'Scheduling'
		AND KEY1 = 'Transactions'
		AND KEY2 = 'Supply Transaction Types'
		AND KEY3 = '?'
		AND VALUE = p_TXN_TYPE;

    RETURN v_COUNT>0;
END TXN_TYPE_IS_SUPPLY;
----------------------------------------------------------------------------------------------------
FUNCTION IS_SUPPLY ( p_TRANSACTION_ID IN NUMBER) RETURN BOOLEAN
IS
  v_TXN_TYPE	INTERCHANGE_TRANSACTION.TRANSACTION_TYPE%TYPE;
BEGIN
    SELECT A.TRANSACTION_TYPE INTO v_TXN_TYPE
    FROM INTERCHANGE_TRANSACTION A
    WHERE A.TRANSACTION_ID = p_TRANSACTION_ID;

	RETURN TXN_TYPE_IS_SUPPLY(v_TXN_TYPE);
END IS_SUPPLY;
----------------------------------------------------------------------------------------------------
FUNCTION DETERMINE_COUNTER_PARTY(p_TRANSACTION_ID IN NUMBER) RETURN NUMBER
IS
  v_RETURN NUMBER(9) := 0;
BEGIN
    IF IS_SUPPLY(p_TRANSACTION_ID) THEN
       SELECT A.SELLER_ID INTO v_RETURN
       FROM INTERCHANGE_TRANSACTION A
       WHERE A.TRANSACTION_ID = p_TRANSACTION_ID;
    ELSE
        SELECT A.PURCHASER_ID INTO v_RETURN
        FROM INTERCHANGE_TRANSACTION A
        WHERE A.TRANSACTION_ID = p_TRANSACTION_ID;
    END IF;

     RETURN v_RETURN;

END DETERMINE_COUNTER_PARTY;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_TRANSACTION_BLOTTER_REPORT
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_FB_TRANSACTION_INTERVAL IN VARCHAR2,
	p_FB_CATEGORY IN VARCHAR2,
	p_FB_COMMODITY_ID IN VARCHAR2,
	p_FB_SC_ID IN NUMBER,
	p_FB_CONTRACT_ID IN NUMBER,
	p_FB_IT_STATUS IN VARCHAR2,
	p_REPORT_NAME IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_INTERVAL VARCHAR2(16);
v_INTERVAL_FILTER NUMBER(1) := 0;
v_MODEL_ID NUMBER(1) := GA.DEFAULT_MODEL;
v_COMMODITY_IDs VARCHAR(4000);
v_CATEGORY VARCHAR(4000);
v_COMMODITY_TABLE ID_TABLE;
v_CATEGORY_TABLE STRING_TABLE;
v_STRING_TYPE STRING_TYPE;
v_ID_TYPE ID_TYPE;
v_CONTRACT_FILTER NUMBER(1) := 0;
v_IT_STATUS_FILTER NUMBER(1) := 0;
v_COMM_FILTER NUMBER(1) := 1;
v_CAT_FILTER NUMBER(1) := 1;
v_SC_FILTER NUMBER(1) := 1;
v_CAN_EDIT NUMBER(1);
v_CAN_FILL NUMBER(1);
BEGIN

    IF NOT CAN_READ(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_MODULE_NAME);
	END IF;

    v_COMMODITY_IDs := p_FB_COMMODITY_ID;
    v_CATEGORY := p_FB_CATEGORY;

    PARSE_UTIL.ID_TABLE_FROM_STRING(v_COMMODITY_IDs, ',', v_COMMODITY_TABLE);
    UT.STRING_TABLE_FROM_STRING(v_CATEGORY, ',', v_CATEGORY_TABLE);

    IF p_FB_SC_ID IS NULL OR p_FB_SC_ID = -1 THEN
       v_SC_FILTER := 0;
    END IF;

    IF v_COMMODITY_IDs IS NULL THEN
        v_COMM_FILTER := 0;
        v_COMMODITY_TABLE := ID_TABLE();
        v_COMMODITY_TABLE.EXTEND;
        v_ID_TYPE := ID_TYPE(0);
        v_COMMODITY_TABLE(1) := v_ID_TYPE;
    END IF;

    IF v_CATEGORY IS NULL THEN
        v_CAT_FILTER := 0;
        v_CATEGORY_TABLE := STRING_TABLE();
        v_CATEGORY_TABLE.EXTEND;
        v_STRING_TYPE := STRING_TYPE(' ');
        v_CATEGORY_TABLE(1) := v_STRING_TYPE;
    END IF;

    IF p_FB_CONTRACT_ID IS NOT NULL AND p_FB_CONTRACT_ID != -1 THEN
       v_CONTRACT_FILTER := 1;
    END IF;

    IF p_FB_IT_STATUS IS NOT NULL THEN
       IF p_FB_IT_STATUS != CONSTANTS.ALL_STRING THEN
          v_IT_STATUS_FILTER := 1;
       END IF;
    END IF;

	v_CAN_EDIT := CASE WHEN UT.BOOLEAN_FROM_STRING(GET_DICTIONARY_VALUE('Can Edit Existing Rows', GA.ELECTRIC_MODEL, 'Scheduling', 'Transactions', p_REPORT_NAME)) THEN 1 ELSE 0 END;
	v_CAN_FILL := CASE WHEN UT.BOOLEAN_FROM_STRING(GET_DICTIONARY_VALUE('Can Fill Existing Rows', GA.ELECTRIC_MODEL, 'Scheduling', 'Transactions', p_REPORT_NAME)) THEN 1 ELSE 0 END;

    -- IF THE INTERVAL ISN'T NULL, THEN WE CAN FILTER ON INTERVAL
  IF p_FB_TRANSACTION_INTERVAL IS NOT NULL THEN
     v_INTERVAL_FILTER := 1;
  END IF;

    --DETERMINE THE INTERVAL OF THE TRANSACTIONS (ALL ARE SAME INTERVAL)
	SELECT DECODE(UPPER(p_FB_TRANSACTION_INTERVAL),'15 MINUTE','MI15','30 MINUTE','MI30','DAY','DD','WEEK','DY','MONTH','MM','QUARTER','Q','YEAR','YY','')
	INTO v_INTERVAL
	FROM DUAL;

 	UT.CUT_DATE_RANGE(v_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_INTERVAL, v_BEGIN_DATE, v_END_DATE);

    OPEN p_CURSOR FOR
		SELECT A.TRANSACTION_ID,
           A.TRANSACTION_NAME,
           D.TRANSACTION_STATUS_NAME,
           A.CONTRACT_ID,
           A.TRANSACTION_TYPE,
           A.TRANSACTION_INTERVAL,
           A.IS_IMPORT_SCHEDULE,
           A.IS_EXPORT_SCHEDULE,
           A.COMMODITY_ID,
           A.BEGIN_DATE As BEGIN_DATE_COLUMN,
           A.END_DATE As END_DATE_COLUMN,
           A.SC_ID,
           A.PURCHASER_ID,
           A.SELLER_ID,
           DETERMINE_COUNTER_PARTY(A.TRANSACTION_ID) As COUNTER_PARTY,
           DETERMINE_COUNTER_PARTY(A.TRANSACTION_ID) As OLD_COUNTER_PARTY,
           A.POR_ID,
           A.POD_ID,
           A.SOURCE_ID,
           A.SINK_ID,
           A.AGREEMENT_TYPE,
           A.APPROVAL_TYPE,
           A.LOSS_OPTION,
           A.RESOURCE_ID,
           A.ZOR_ID,
           A.ZOD_ID,
           A.MARKET_PRICE_ID,
           A.IS_FIRM,
           A.IS_BID_OFFER,
           A.IS_BALANCE_TRANSACTION,
           A.IS_DISPATCHABLE,
           A.SCHEDULE_GROUP_ID,
           A.TX_TRANSACTION_ID,
           A.LINK_TRANSACTION_ID,
           A.EDC_ID,
           A.ESP_ID,
           A.PSE_ID,
           A.POOL_ID,
           A.TP_ID,
           A.TRAIT_CATEGORY,
           v_CAN_EDIT As CAN_EDIT,
		   v_CAN_FILL AS CAN_FILL
		FROM INTERCHANGE_TRANSACTION A,
			IT_STATUS D,
            TABLE(CAST(v_COMMODITY_TABLE AS ID_TABLE)) F,
            TABLE(CAST(v_CATEGORY_TABLE AS STRING_TABLE)) G
		WHERE   NVL(A.BEGIN_DATE, p_END_DATE) <= p_END_DATE
            AND (v_SC_FILTER != 1 OR A.SC_ID = p_FB_SC_ID)
            AND NVL(A.END_DATE, p_BEGIN_DATE) >= p_BEGIN_DATE
            AND (v_INTERVAL_FILTER != 1  OR UPPER(A.TRANSACTION_INTERVAL) = UPPER(p_FB_TRANSACTION_INTERVAL) )
            AND (v_COMM_FILTER != 1 OR UPPER(A.TRANSACTION_TYPE) = UPPER(G.STRING_VAL))
            AND (v_CAT_FILTER != 1 OR A.COMMODITY_ID = F.ID)
			      AND D.TRANSACTION_ID = A.TRANSACTION_ID
            AND D.AS_OF_DATE = IT_STATUS_AS_OF_DATE(D.TRANSACTION_ID, p_AS_OF_DATE)
      AND ( (v_IT_STATUS_FILTER != 1 AND D.TRANSACTION_IS_ACTIVE = 1)
            OR (v_IT_STATUS_FILTER = 1 AND D.TRANSACTION_STATUS_NAME = p_FB_IT_STATUS)
            OR (p_FB_IT_STATUS = CONSTANTS.ALL_STRING) )
      AND (v_CONTRACT_FILTER != 1 OR A.Contract_Id = p_FB_CONTRACT_ID)
        ORDER BY 1;

        p_STATUS := GA.SUCCESS;


END GET_TRANSACTION_BLOTTER_REPORT;
----------------------------------------------------------------------------------------------------
FUNCTION GET_TXN_BLOTTER_DEFAULT_AS_STR
	(
	p_REPORT_NAME IN VARCHAR2,
	p_TXN_TYPE IN VARCHAR2,
	p_FIELD_NAME IN VARCHAR2
	) RETURN VARCHAR2 IS

  BEGIN

  	RETURN NVL( GET_DICTIONARY_VALUE(p_FIELD_NAME, CONSTANTS.ELECTRIC_MODEL, 'Scheduling', 'Transactions', p_REPORT_NAME, p_TXN_TYPE),
  				GET_DICTIONARY_VALUE(p_FIELD_NAME, CONSTANTS.ELECTRIC_MODEL, 'Scheduling', 'Transactions', p_REPORT_NAME) );

  END GET_TXN_BLOTTER_DEFAULT_AS_STR;
----------------------------------------------------------------------------------------------------
FUNCTION GET_TXN_BLOTTER_DEFAULT_AS_NUM
	(
	p_REPORT_NAME IN VARCHAR2,
	p_TXN_TYPE IN VARCHAR2,
	p_FIELD_NAME IN VARCHAR2
	) RETURN NUMBER IS


  BEGIN

  	RETURN TO_NUMBER(GET_TXN_BLOTTER_DEFAULT_AS_STR(p_REPORT_NAME, p_TXN_TYPE, p_FIELD_NAME));

  END GET_TXN_BLOTTER_DEFAULT_AS_NUM;
----------------------------------------------------------------------------------------------------
  PROCEDURE RESOLVE_CONTRACT_ID
  (
   p_CONTRACT_OUT OUT NUMBER,
   p_CONTRACT_ID IN NUMBER,
   p_FB_CONTRACT_ID IN NUMBER,
   p_REPORT_NAME IN VARCHAR2,
   p_TRANSACTION_TYPE IN VARCHAR2
  ) AS

  BEGIN

  IF p_CONTRACT_ID IS NULL OR p_CONTRACT_ID < 0 THEN
     IF p_FB_CONTRACT_ID IS NOT NULL AND p_FB_CONTRACT_ID >= 0 THEN
        p_CONTRACT_OUT := p_FB_CONTRACT_ID;
     ELSE
	 	p_CONTRACT_OUT := GET_TXN_BLOTTER_DEFAULT_AS_NUM(p_REPORT_NAME, p_TRANSACTION_TYPE, 'CONTRACT_ID');

        IF p_CONTRACT_OUT IS NULL OR p_CONTRACT_OUT < 0 THEN
           p_CONTRACT_OUT := 0;
        END IF;
     END IF;
  ELSE
      p_CONTRACT_OUT := p_CONTRACT_ID;
  END IF;

  END RESOLVE_CONTRACT_ID;
----------------------------------------------------------------------------------------------------
PROCEDURE RESOLVE_TXN_TYPE
	(
	p_CATEGORY_TABLE IN STRING_TABLE,
	p_TRANSACTION_TYPE IN VARCHAR2,
	p_REPORT_NAME IN VARCHAR2,
	p_TRANSACTION_TYPE_OUT OUT VARCHAR2
	) AS

BEGIN
  IF p_TRANSACTION_TYPE IS NOT NULL THEN
  	  -- use specified transaction type
      p_TRANSACTION_TYPE_OUT := p_TRANSACTION_TYPE;

  ELSIF p_CATEGORY_TABLE IS NOT NULL THEN
  	 -- look at selected transaction types in filter list
     IF p_CATEGORY_TABLE IS NOT NULL AND p_CATEGORY_TABLE.COUNT = 1 THEN
	 	-- only one? default to that
        p_TRANSACTION_TYPE_OUT := p_CATEGORY_TABLE(1).STRING_VAL;
     ELSE
	 	-- is a default spelled out in System Dictionary?
        p_TRANSACTION_TYPE_OUT := GET_TXN_BLOTTER_DEFAULT_AS_STR(p_REPORT_NAME, NULL, 'TRANSACTION_TYPE');
		-- no? then use the first transaction type in the filter list
        IF p_TRANSACTION_TYPE_OUT IS NULL THEN
           p_TRANSACTION_TYPE_OUT := p_CATEGORY_TABLE(1).STRING_VAL;
        END IF;
     END IF;

  ELSE
	-- is a default spelled out in System Dictionary?
	p_TRANSACTION_TYPE_OUT := GET_TXN_BLOTTER_DEFAULT_AS_STR(p_REPORT_NAME, NULL, 'TRANSACTION_TYPE');

  END IF;

  IF p_TRANSACTION_TYPE_OUT IS NULL THEN -- still null?
     ERRS.RAISE(MSGCODES.c_ERR_ARGUMENT, 'Required field TRANSACTION_TYPE was not specified, and a fallback back value could not be determined.');
  END IF;

  END RESOLVE_TXN_TYPE;
----------------------------------------------------------------------------------------------------
PROCEDURE RESOLVE_STATUS
  (
   p_STATUS_OUT OUT VARCHAR2,
   p_STATUS IN VARCHAR2,
   p_STATUS_FILTER IN VARCHAR2,
   p_REPORT_NAME IN VARCHAR2,
   P_TRANSACTION_TYPE IN VARCHAR2
  ) AS

  BEGIN

       IF p_STATUS IS NULL THEN
          IF p_STATUS_FILTER IS NOT NULL AND UPPER(p_STATUS_FILTER) != UPPER(CONSTANTS.ALL_STRING) THEN
             p_STATUS_OUT := p_STATUS_FILTER;
          ELSE
             p_STATUS_OUT := GET_TXN_BLOTTER_DEFAULT_AS_STR(p_REPORT_NAME, p_TRANSACTION_TYPE, 'TRANSACTION_STATUS_NAME');

             IF p_STATUS_OUT IS NULL THEN
                p_STATUS_OUT := 'Active';
             END IF;
          END IF;
       ELSE
          p_STATUS_OUT := p_STATUS;
       END IF;

  END RESOLVE_STATUS;
----------------------------------------------------------------------------------------------------
PROCEDURE RESOLVE_COMMODITY
  (
   p_COMMODITY_ID_OUT OUT NUMBER,
   p_COMMODITY_ID IN NUMBER,
   p_COMMODITY_IDS IN ID_TABLE,
   p_REPORT_NAME IN VARCHAR2,
   p_TRANSACTION_TYPE IN VARCHAR2
  ) AS

  BEGIN

     IF p_COMMODITY_ID IS NULL OR p_COMMODITY_ID < 0 THEN
        IF p_COMMODITY_IDS IS NOT NULL AND p_COMMODITY_IDS.COUNT = 1 THEN

        p_COMMODITY_ID_OUT := p_COMMODITY_IDS(1).ID;
        ELSE
        p_COMMODITY_ID_OUT := GET_TXN_BLOTTER_DEFAULT_AS_STR(p_REPORT_NAME, p_TRANSACTION_TYPE, 'COMMODITY_ID');

        IF p_COMMODITY_ID_OUT IS NULL OR p_COMMODITY_ID_OUT < 0 THEN
           p_COMMODITY_ID_OUT := p_COMMODITY_IDS(1).ID;
        END IF;

        END IF;

     ELSE
         p_COMMODITY_ID_OUT := p_COMMODITY_ID;
     END IF;

 IF p_COMMODITY_ID_OUT IS NULL THEN
     ERRS.RAISE(MSGCODES.c_ERR_ARGUMENT, 'Required field COMMODITY_ID was nott specified, and a fallback back value could not be determined.');
  END IF;

  END RESOLVE_COMMODITY;
----------------------------------------------------------------------------------------------------
PROCEDURE RESOLVE_SC
  (
   p_SC_ID_OUT OUT NUMBER,
   p_SC_ID IN NUMBER,
   p_CONTRACT_ID IN NUMBER,
   p_SC_FILTER_ID IN NUMBER,
   p_REPORT_NAME IN VARCHAR2,
   p_TRANSACTION_TYPE IN VARCHAR2
  ) AS

  BEGIN

       IF p_SC_ID IS NULL OR p_SC_ID < 0 THEN
          IF p_SC_FILTER_ID IS NOT NULL AND p_SC_FILTER_ID >= 0 THEN
                 p_SC_ID_OUT := p_SC_FILTER_ID;
          ELSE
              IF p_CONTRACT_ID IS NOT NULL AND p_CONTRACT_ID > 0 THEN
                 SELECT C.SC_ID INTO p_SC_ID_OUT
                 FROM INTERCHANGE_CONTRACT C
                 WHERE C.CONTRACT_ID = p_CONTRACT_ID;
              ELSE
                 p_SC_ID_OUT := GET_TXN_BLOTTER_DEFAULT_AS_NUM(p_REPORT_NAME, p_TRANSACTION_TYPE, 'SC_ID');
              END IF;
          END IF;
       ELSE
           p_SC_ID_OUT := p_SC_ID;
       END IF;

       IF p_SC_ID_OUT IS NULL OR p_SC_ID_OUT < 0 THEN
          p_SC_ID_OUT := 0;
       END IF;

  END RESOLVE_SC;
----------------------------------------------------------------------------------------------------
 PROCEDURE RESOLVE_FROM_CONTRACT
 (
  p_CONTRACT_ID IN NUMBER,
  p_BEGIN_DATE_OUT OUT DATE,
  p_BEGIN_DATE IN DATE,
  p_END_DATE_OUT OUT DATE,
  p_END_DATE IN DATE,
  p_POR_ID_OUT OUT NUMBER,
  p_POR_ID IN NUMBER,
  p_POD_ID_OUT OUT NUMBER,
  p_POD_ID IN NUMBER,
  p_SOURCE_ID_OUT OUT NUMBER,
  p_SOURCE_ID IN NUMBER,
  p_SINK_ID_OUT OUT NUMBER,
  p_SINK_ID IN NUMBER,
  p_AGREEMENT_TYPE_OUT OUT VARCHAR2,
  p_AGREEMENT_TYPE IN VARCHAR2,
  p_APPROVAL_TYPE_OUT OUT VARCHAR2,
  p_APPROVAL_TYPE IN VARCHAR2,
  p_LOSS_OPTION_OUT OUT VARCHAR2,
  p_LOSS_OPTION IN VARCHAR2,
  p_REPORT_NAME IN VARCHAR2,
  p_TXN_TYPE IN VARCHAR2
  ) AS
    v_DATE_FORMAT VARCHAR2(128) := GET_DICTIONARY_VALUE('Date Format', CONSTANTS.ELECTRIC_MODEL, 'Scheduling', 'Transactions', p_REPORT_NAME);
    v_TEMP VARCHAR2(128);
  BEGIN

  -------------------------p_BEGIN_DATE-------------------------------------------
  p_BEGIN_DATE_OUT := NULL;
  IF p_BEGIN_DATE IS NULL  THEN
     IF p_CONTRACT_ID IS NOT NULL AND p_CONTRACT_ID > 0 THEN
        SELECT C.BEGIN_DATE INTO p_BEGIN_DATE_OUT
        FROM INTERCHANGE_CONTRACT c
        WHERE c.contract_id = p_CONTRACT_ID;
     END IF;

     IF p_BEGIN_DATE_OUT IS NULL THEN
        v_TEMP := GET_TXN_BLOTTER_DEFAULT_AS_STR(p_REPORT_NAME, p_TXN_TYPE, 'BEGIN_DATE_COLUMN');
        p_BEGIN_DATE_OUT := TO_DATE(v_TEMP, v_DATE_FORMAT);
     END IF;
  ELSE
      p_BEGIN_DATE_OUT := p_BEGIN_DATE;
  END IF;

    -------------------------p_END_DATE-------------------------------------------
  p_END_DATE_OUT := NULL;
  IF p_END_DATE IS NULL  THEN
     IF p_CONTRACT_ID IS NOT NULL AND p_CONTRACT_ID > 0 THEN
        SELECT C.END_DATE INTO p_END_DATE_OUT
        FROM INTERCHANGE_CONTRACT c
        WHERE c.contract_id = p_CONTRACT_ID;
     END IF;

     IF p_END_DATE_OUT IS NULL THEN
        v_TEMP := GET_TXN_BLOTTER_DEFAULT_AS_STR(p_REPORT_NAME, p_TXN_TYPE, 'END_DATE_COLUMN');
        p_END_DATE_OUT := TO_DATE(v_TEMP, v_DATE_FORMAT);
     END IF;
  ELSE
      p_END_DATE_OUT := p_END_DATE;
  END IF;

  -------------------------p_POR_ID-------------------------------------------
  p_POR_ID_OUT := NULL;
  IF p_POR_ID IS NULL OR p_POR_ID < 0 THEN
     IF p_CONTRACT_ID IS NOT NULL AND p_CONTRACT_ID > 0 THEN
        SELECT c.Por_Id INTO p_POR_ID_OUT
        FROM INTERCHANGE_CONTRACT c
        WHERE c.contract_id = p_CONTRACT_ID;
     END IF;

     IF p_POR_ID_OUT IS NULL OR p_POR_ID < 0 THEN
        p_POR_ID_OUT := GET_TXN_BLOTTER_DEFAULT_AS_NUM(p_REPORT_NAME, p_TXN_TYPE, 'POR_ID');
     END IF;
  ELSE
      p_POR_ID_OUT := p_POR_ID;
  END IF;

  IF p_POR_ID_OUT IS NULL OR p_POR_ID_OUT < 0 THEN
      p_POR_ID_OUT := 0;
  END IF;

  -------------------------p_POD_ID-------------------------------------------
  p_POD_ID_OUT := NULL;
  IF p_POD_ID IS NULL OR p_POD_ID < 0 THEN
     IF p_CONTRACT_ID IS NOT NULL AND p_CONTRACT_ID > 0 THEN
        SELECT c.Pod_Id INTO p_POD_ID_OUT
        FROM INTERCHANGE_CONTRACT c
        WHERE c.contract_id = p_CONTRACT_ID;
     END IF;

     IF p_POD_ID_OUT IS NULL OR p_POD_ID < 0 THEN
        p_POD_ID_OUT := GET_TXN_BLOTTER_DEFAULT_AS_NUM(p_REPORT_NAME, p_TXN_TYPE, 'POD_ID');
     END IF;
  ELSE
      p_POD_ID_OUT := p_POD_ID;
  END IF;

  IF p_POD_ID_OUT IS NULL OR p_POD_ID_OUT < 0 THEN
      p_POD_ID_OUT := 0;
  END IF;

  -------------------------p_SOURCE_ID-------------------------------------------
  p_SOURCE_ID_OUT := NULL;
  IF p_SOURCE_ID IS NULL OR p_SOURCE_ID < 0 THEN
     IF p_CONTRACT_ID IS NOT NULL AND p_CONTRACT_ID > 0 THEN
        SELECT c.source_id INTO p_SOURCE_ID_OUT
        FROM INTERCHANGE_CONTRACT c
        WHERE c.contract_id = p_CONTRACT_ID;
     END IF;

     IF p_SOURCE_ID_OUT IS NULL OR p_SOURCE_ID < 0 THEN
        p_SOURCE_ID_OUT := GET_TXN_BLOTTER_DEFAULT_AS_NUM(p_REPORT_NAME, p_TXN_TYPE, 'SOURCE_ID');
     END IF;
  ELSE
      p_SOURCE_ID_OUT := p_SOURCE_ID;
  END IF;

  IF p_SOURCE_ID_OUT IS NULL OR p_SOURCE_ID_OUT < 0 THEN
      p_SOURCE_ID_OUT := 0;
  END IF;

  -------------------------p_SINK_ID-------------------------------------------
  p_SINK_ID_OUT := NULL;
  IF p_SINK_ID IS NULL OR p_SINK_ID < 0 THEN
     IF p_CONTRACT_ID IS NOT NULL AND p_CONTRACT_ID > 0 THEN
        SELECT C.SINK_ID INTO p_SINK_ID_OUT
        FROM INTERCHANGE_CONTRACT c
        WHERE c.contract_id = p_CONTRACT_ID;
     END IF;

     IF p_SINK_ID_OUT IS NULL OR p_SINK_ID < 0 THEN
        p_SINK_ID_OUT := GET_TXN_BLOTTER_DEFAULT_AS_NUM(p_REPORT_NAME, p_TXN_TYPE, 'SINK_ID');
     END IF;
  ELSE
      p_SINK_ID_OUT := p_SINK_ID;
  END IF;

  IF p_SINK_ID_OUT IS NULL OR p_SINK_ID_OUT < 0 THEN
      p_SINK_ID_OUT := 0;
  END IF;

  -------------------------p_AGREEMENT_TYPE-------------------------------------------
  p_AGREEMENT_TYPE_OUT := NULL;
  IF p_AGREEMENT_TYPE IS NULL  THEN
     IF p_CONTRACT_ID IS NOT NULL AND p_CONTRACT_ID > 0 THEN
        SELECT C.AGREEMENT_TYPE INTO p_AGREEMENT_TYPE_OUT
        FROM INTERCHANGE_CONTRACT c
        WHERE c.contract_id = p_CONTRACT_ID;
     END IF;

     IF p_AGREEMENT_TYPE_OUT IS NULL THEN
        p_AGREEMENT_TYPE_OUT := GET_TXN_BLOTTER_DEFAULT_AS_STR(p_REPORT_NAME, p_TXN_TYPE, 'AGREEMENT_TYPE');
     END IF;
  ELSE
      p_AGREEMENT_TYPE_OUT := p_AGREEMENT_TYPE;
  END IF;

  -------------------------p_APPROVAL_TYPE-------------------------------------------
  p_APPROVAL_TYPE_OUT := NULL;
  IF p_APPROVAL_TYPE IS NULL  THEN
     IF p_CONTRACT_ID IS NOT NULL AND p_CONTRACT_ID > 0 THEN
        SELECT C.APPROVAL_TYPE INTO p_APPROVAL_TYPE_OUT
        FROM INTERCHANGE_CONTRACT c
        WHERE c.contract_id = p_CONTRACT_ID;
     END IF;

     IF p_APPROVAL_TYPE_OUT IS NULL THEN
        p_APPROVAL_TYPE_OUT := GET_TXN_BLOTTER_DEFAULT_AS_STR(p_REPORT_NAME, p_TXN_TYPE, 'APPROVAL_TYPE');
     END IF;
  ELSE
      p_APPROVAL_TYPE_OUT := p_APPROVAL_TYPE;
  END IF;

    -------------------------p_LOSS_OPTION-------------------------------------------
  p_LOSS_OPTION_OUT := NULL;
  IF p_LOSS_OPTION IS NULL  THEN
     IF p_CONTRACT_ID IS NOT NULL AND p_CONTRACT_ID > 0 THEN
        SELECT C.LOSS_OPTION INTO p_LOSS_OPTION_OUT
        FROM INTERCHANGE_CONTRACT c
        WHERE c.contract_id = p_CONTRACT_ID;
     END IF;

     IF p_LOSS_OPTION_OUT IS NULL THEN
        p_LOSS_OPTION_OUT := GET_TXN_BLOTTER_DEFAULT_AS_STR(p_REPORT_NAME, p_TXN_TYPE, 'LOSS_OPTION');
     END IF;
  ELSE
      p_LOSS_OPTION_OUT := p_LOSS_OPTION;
  END IF;

END RESOLVE_FROM_CONTRACT;
----------------------------------------------------------------------------------------------------
PROCEDURE RESOLVE_TO_NULL
(
  p_RESOURCE_ID_OUT OUT NUMBER,
  p_RESOURCE_ID IN NUMBER,
  p_ZOR_ID_OUT OUT NUMBER,
  p_ZOR_ID IN NUMBER,
  p_ZOD_ID_OUT OUT NUMBER,
  p_ZOD_ID IN NUMBER,
  p_MARKET_PRICE_ID_OUT OUT NUMBER,
  p_MARKET_PRICE_ID IN NUMBER,
  p_IS_FIRM_OUT OUT NUMBER,
  p_IS_FIRM IN NUMBER,
  p_IS_BID_OFFER_OUT OUT NUMBER,
  p_IS_BID_OFFER IN NUMBER,
  p_IS_BALANCE_TRANSACTION_OUT OUT NUMBER,
  p_IS_BALANCE_TRANSACTION IN NUMBER,
  p_IS_DISPATCHABLE_OUT OUT NUMBER,
  p_IS_DISPATCHABLE IN NUMBER,
  p_SCHEDULE_GROUP_ID_OUT OUT NUMBER,
  p_SCHEDULE_GROUP_ID IN NUMBER,
  p_TX_TRANSACTION_ID_OUT OUT NUMBER,
  p_TX_TRANSACTION_ID IN NUMBER,
  p_LINK_TRANSACTION_ID_OUT OUT NUMBER,
  p_LINK_TRANSACTION_ID IN NUMBER,
  p_EDC_ID_OUT OUT NUMBER,
  p_EDC_ID IN NUMBER,
  p_ESP_ID_OUT OUT NUMBER,
  p_ESP_ID IN NUMBER,
  p_PSE_ID_OUT OUT NUMBER,
  p_PSE_ID IN NUMBER,
  p_POOL_ID_OUT OUT NUMBER,
  p_POOL_ID IN NUMBER,
  p_TP_ID_OUT OUT NUMBER,
  p_TP_ID IN NUMBER,
  p_IS_IMPORT_SCHEDULE_OUT OUT NUMBER,
  p_IS_IMPORT_SCHEDULE IN NUMBER,
  p_IS_EXPORT_SCHEDULE_OUT OUT NUMBER,
  p_IS_EXPORT_SCHEDULE IN NUMBER,
  p_IS_IMPORT_EXPORT_OUT OUT NUMBER,
  p_IS_IMPORT_EXPORT IN NUMBER,
  p_TRAIT_CATEGORY_OUT OUT VARCHAR2,
  p_TRAIT_CATEGORY IN VARCHAR2,
  p_REPORT_NAME IN VARCHAR2,
  p_TRANSACTION_TYPE IN VARCHAR2
) AS

-- This method sets a variable to null (or zero for ids) for any param which
-- 1) was not handed in by the put procedure
-- 2) is not specified in the system dictionary (see GET_TXN_BLOTTER_DEFAULT_AS_STR).

BEGIN

--------------p_RESOURCE_ID------------------
IF p_RESOURCE_ID IS NULL OR p_RESOURCE_ID < 0 THEN
   p_RESOURCE_ID_OUT := GET_TXN_BLOTTER_DEFAULT_AS_NUM(p_REPORT_NAME, p_TRANSACTION_TYPE, 'RESOURCE_ID');

   IF p_RESOURCE_ID_OUT IS NULL OR p_RESOURCE_ID_OUT < 0 THEN
      p_RESOURCE_ID_OUT := 0;
   END IF;
ELSE
   P_RESOURCE_ID_OUT := p_RESOURCE_ID;
END IF;

--------------p_ZOR_ID------------------
IF p_ZOR_ID IS NULL OR p_ZOR_ID < 0 THEN
   p_ZOR_ID_OUT := GET_TXN_BLOTTER_DEFAULT_AS_NUM(p_REPORT_NAME, p_TRANSACTION_TYPE, 'ZOR_ID');

   IF p_ZOR_ID_OUT IS NULL OR p_ZOR_ID_OUT < 0 THEN
      p_ZOR_ID_OUT := 0;
   END IF;
ELSE
   P_ZOR_ID_OUT := p_ZOR_ID;
END IF;

--------------p_ZOD_ID------------------
IF p_ZOD_ID IS NULL OR p_ZOD_ID < 0 THEN
   p_ZOD_ID_OUT := GET_TXN_BLOTTER_DEFAULT_AS_NUM(p_REPORT_NAME, p_TRANSACTION_TYPE, 'ZOD_ID');

   IF p_ZOD_ID_OUT IS NULL OR p_ZOD_ID_OUT < 0 THEN
      p_ZOD_ID_OUT := 0;
   END IF;
ELSE
   P_ZOD_ID_OUT := p_ZOD_ID;
END IF;

--------------p_MARKET_PRICE_ID------------------
IF p_MARKET_PRICE_ID IS NULL OR p_MARKET_PRICE_ID < 0 THEN
   p_MARKET_PRICE_ID_OUT := GET_TXN_BLOTTER_DEFAULT_AS_NUM(p_REPORT_NAME, p_TRANSACTION_TYPE, 'MARKET_PRICE_ID');

   IF p_MARKET_PRICE_ID_OUT IS NULL OR p_MARKET_PRICE_ID_OUT < 0 THEN
      p_MARKET_PRICE_ID_OUT := 0;
   END IF;
ELSE
   P_MARKET_PRICE_ID_OUT := p_MARKET_PRICE_ID;
END IF;

--------------p_IS_FIRM------------------
IF p_IS_FIRM IS NULL OR p_IS_FIRM < 0 THEN
   p_IS_FIRM_OUT := GET_TXN_BLOTTER_DEFAULT_AS_NUM(p_REPORT_NAME, p_TRANSACTION_TYPE, 'IS_FIRM');

   IF p_IS_FIRM_OUT IS NULL OR p_IS_FIRM_OUT < 0 THEN
      p_IS_FIRM_OUT := 0;
   END IF;
ELSE
   P_IS_FIRM_OUT := p_IS_FIRM;
END IF;

--------------p_IS_BID_OFFER------------------
IF p_IS_BID_OFFER IS NULL OR p_IS_BID_OFFER < 0 THEN
   p_IS_BID_OFFER_OUT := GET_TXN_BLOTTER_DEFAULT_AS_NUM(p_REPORT_NAME, p_TRANSACTION_TYPE, 'IS_BID_OFFER');

   IF p_IS_BID_OFFER_OUT IS NULL OR p_IS_BID_OFFER_OUT < 0 THEN
      p_IS_BID_OFFER_OUT := 0;
   END IF;
ELSE
   P_IS_BID_OFFER_OUT := p_IS_BID_OFFER;
END IF;

--------------p_IS_BALANCE_TRANSACTION------------------
IF p_IS_BALANCE_TRANSACTION IS NULL OR p_IS_BALANCE_TRANSACTION < 0 THEN
   p_IS_BALANCE_TRANSACTION_OUT := GET_TXN_BLOTTER_DEFAULT_AS_NUM(p_REPORT_NAME, p_TRANSACTION_TYPE, 'IS_BALANCE_TRANSACTION');

   IF p_IS_BALANCE_TRANSACTION_OUT IS NULL OR p_IS_BALANCE_TRANSACTION_OUT < 0 THEN
      p_IS_BALANCE_TRANSACTION_OUT := 0;
   END IF;
ELSE
   P_IS_BALANCE_TRANSACTION_OUT := p_IS_BALANCE_TRANSACTION;
END IF;

--------------p_IS_DISPATCHABLE------------------
IF p_IS_DISPATCHABLE IS NULL OR p_IS_DISPATCHABLE < 0 THEN
   p_IS_DISPATCHABLE_OUT := GET_TXN_BLOTTER_DEFAULT_AS_NUM(p_REPORT_NAME, p_TRANSACTION_TYPE, 'IS_DISPATCHABLE');

   IF p_IS_DISPATCHABLE_OUT IS NULL OR p_IS_DISPATCHABLE_OUT < 0 THEN
      p_IS_DISPATCHABLE_OUT := 0;
   END IF;
ELSE
   P_IS_DISPATCHABLE_OUT := p_IS_DISPATCHABLE;
END IF;

--------------p_SCHEDULE_GROUP_ID------------------
IF p_SCHEDULE_GROUP_ID IS NULL OR p_SCHEDULE_GROUP_ID < 0 THEN
   p_SCHEDULE_GROUP_ID_OUT := GET_TXN_BLOTTER_DEFAULT_AS_NUM(p_REPORT_NAME, p_TRANSACTION_TYPE, 'SCHEDULE_GROUP_ID');

   IF p_SCHEDULE_GROUP_ID_OUT IS NULL OR p_SCHEDULE_GROUP_ID_OUT < 0 THEN
      p_SCHEDULE_GROUP_ID_OUT := 0;
   END IF;
ELSE
   P_SCHEDULE_GROUP_ID_OUT := p_SCHEDULE_GROUP_ID;
END IF;

--------------p_TX_TRANSACTION_ID------------------
IF p_TX_TRANSACTION_ID IS NULL OR p_TX_TRANSACTION_ID < 0 THEN
   p_TX_TRANSACTION_ID_OUT := GET_TXN_BLOTTER_DEFAULT_AS_NUM(p_REPORT_NAME, p_TRANSACTION_TYPE, 'TX_TRANSACTION_ID');

   IF p_TX_TRANSACTION_ID_OUT IS NULL OR p_TX_TRANSACTION_ID_OUT < 0 THEN
      p_TX_TRANSACTION_ID_OUT := 0;
   END IF;
ELSE
   P_TX_TRANSACTION_ID_OUT := p_TX_TRANSACTION_ID;
END IF;

--------------p_LINK_TRANSACTION_ID------------------
IF p_LINK_TRANSACTION_ID IS NULL OR p_LINK_TRANSACTION_ID < 0 THEN
   p_LINK_TRANSACTION_ID_OUT := GET_TXN_BLOTTER_DEFAULT_AS_NUM(p_REPORT_NAME, p_TRANSACTION_TYPE, 'LINK_TRANSACTION_ID');

   IF p_LINK_TRANSACTION_ID_OUT IS NULL OR p_LINK_TRANSACTION_ID_OUT < 0 THEN
      p_LINK_TRANSACTION_ID_OUT := 0;
   END IF;
ELSE
   P_LINK_TRANSACTION_ID_OUT := p_LINK_TRANSACTION_ID;
END IF;

--------------p_EDC_ID------------------
IF p_EDC_ID IS NULL OR p_EDC_ID < 0 THEN
   p_EDC_ID_OUT := GET_TXN_BLOTTER_DEFAULT_AS_NUM(p_REPORT_NAME, p_TRANSACTION_TYPE, 'EDC_ID');

   IF p_EDC_ID_OUT IS NULL OR p_EDC_ID_OUT < 0 THEN
      p_EDC_ID_OUT := 0;
   END IF;
ELSE
   P_EDC_ID_OUT := p_EDC_ID;
END IF;

--------------p_ESP_ID------------------
IF p_ESP_ID IS NULL OR p_ESP_ID < 0 THEN
   p_ESP_ID_OUT := GET_TXN_BLOTTER_DEFAULT_AS_NUM(p_REPORT_NAME, p_TRANSACTION_TYPE, 'ESP_ID');

   IF p_ESP_ID_OUT IS NULL OR p_ESP_ID_OUT < 0 THEN
      p_ESP_ID_OUT := 0;
   END IF;
ELSE
   P_ESP_ID_OUT := p_ESP_ID;
END IF;

--------------p_PSE_ID------------------
IF p_PSE_ID IS NULL OR p_PSE_ID < 0 THEN
   p_PSE_ID_OUT := GET_TXN_BLOTTER_DEFAULT_AS_NUM(p_REPORT_NAME, p_TRANSACTION_TYPE, 'PSE_ID');

   IF p_PSE_ID_OUT IS NULL OR p_PSE_ID_OUT < 0 THEN
      p_PSE_ID_OUT := 0;
   END IF;
ELSE
   P_PSE_ID_OUT := p_PSE_ID;
END IF;

--------------p_POOL_ID------------------
IF p_POOL_ID IS NULL OR p_POOL_ID < 0 THEN
   p_POOL_ID_OUT := GET_TXN_BLOTTER_DEFAULT_AS_NUM(p_REPORT_NAME, p_TRANSACTION_TYPE, 'POOL_ID');

   IF p_POOL_ID_OUT IS NULL OR p_POOL_ID_OUT < 0 THEN
      p_POOL_ID_OUT := 0;
   END IF;
ELSE
   P_POOL_ID_OUT := p_POOL_ID;
END IF;

--------------p_TP_ID------------------
IF p_TP_ID IS NULL OR p_TP_ID < 0 THEN
   p_TP_ID_OUT := GET_TXN_BLOTTER_DEFAULT_AS_NUM(p_REPORT_NAME, p_TRANSACTION_TYPE, 'TP_ID');

   IF p_TP_ID_OUT IS NULL OR p_TP_ID_OUT < 0 THEN
      p_TP_ID_OUT := 0;
   END IF;
ELSE
   P_TP_ID_OUT := p_TP_ID;
END IF;

--------------p_IS_IMPORT_EXPORT------------------
IF p_IS_IMPORT_EXPORT IS NULL OR p_IS_IMPORT_EXPORT < 0 THEN
   p_IS_IMPORT_EXPORT_OUT := GET_TXN_BLOTTER_DEFAULT_AS_NUM(p_REPORT_NAME, p_TRANSACTION_TYPE, 'IS_IMPORT_EXPORT');

   IF p_IS_IMPORT_EXPORT_OUT IS NULL OR p_IS_IMPORT_EXPORT_OUT < 0 THEN
      p_IS_IMPORT_EXPORT_OUT := 0;
   END IF;
ELSE
   P_IS_IMPORT_EXPORT_OUT := p_IS_IMPORT_EXPORT;
END IF;

--------------p_IS_IMPORT_SCHEDULE------------------
IF p_IS_IMPORT_SCHEDULE IS NULL OR p_IS_IMPORT_SCHEDULE < 0 THEN
   p_IS_IMPORT_SCHEDULE_OUT := GET_TXN_BLOTTER_DEFAULT_AS_NUM(p_REPORT_NAME, p_TRANSACTION_TYPE, 'IS_IMPORT_SCHEDULE');

   IF p_IS_IMPORT_SCHEDULE_OUT IS NULL OR p_IS_IMPORT_SCHEDULE_OUT < 0 THEN
      p_IS_IMPORT_SCHEDULE_OUT := 0;
   END IF;
ELSE
   P_IS_IMPORT_SCHEDULE_OUT := p_IS_IMPORT_SCHEDULE;
END IF;

--------------p_IS_EXPORT_SCHEDULE------------------
IF p_IS_EXPORT_SCHEDULE IS NULL OR p_IS_EXPORT_SCHEDULE < 0 THEN
   p_IS_EXPORT_SCHEDULE_OUT := GET_TXN_BLOTTER_DEFAULT_AS_NUM(p_REPORT_NAME, p_TRANSACTION_TYPE, 'IS_EXPORT_SCHEDULE');

   IF p_IS_EXPORT_SCHEDULE_OUT IS NULL OR p_IS_EXPORT_SCHEDULE_OUT < 0 THEN
      p_IS_EXPORT_SCHEDULE_OUT := 0;
   END IF;
ELSE
   P_IS_EXPORT_SCHEDULE_OUT := p_IS_EXPORT_SCHEDULE;
END IF;

-------------------------p_TRAIT_CATEGORY-------------------------------------------
  p_TRAIT_CATEGORY_OUT := NULL;
  IF p_TRAIT_CATEGORY IS NULL  THEN
     IF p_TRAIT_CATEGORY_OUT IS NULL THEN
        p_TRAIT_CATEGORY_OUT := GET_TXN_BLOTTER_DEFAULT_AS_STR(p_REPORT_NAME, p_TRANSACTION_TYPE, 'TRAIT_CATEGORY');
     END IF;
  ELSE
      p_TRAIT_CATEGORY_OUT := p_TRAIT_CATEGORY;
  END IF;

END RESOLVE_TO_NULL;
----------------------------------------------------------------------------------------------------
PROCEDURE RESOLVE_SELLER_PURCH_CP
(
 p_IS_NEW IN BOOLEAN,
 p_SELLER_ID_OUT OUT NUMBER,
 p_SELLER_ID IN NUMBER,
 p_PURCHASER_ID_OUT OUT NUMBER,
 p_PURCHASER_ID IN NUMBER,
 p_COUNTER_PARTY IN NUMBER,
 p_OLD_COUNTER_PARTY IN NUMBER,
 p_CONTRACT_ID IN NUMBER,
 p_REPORT_NAME IN VARCHAR2,
 p_TRANSACTION_TYPE IN VARCHAR2
) AS
 -- This procedure resolves the whole mess of when to use purchaser / seller / counter party fields
 -- to populate a transaction: please see the design doc for the transaction blotter
BEGIN
    IF p_IS_NEW THEN
       IF TXN_TYPE_IS_SUPPLY(p_TRANSACTION_TYPE) THEN
         IF p_COUNTER_PARTY IS NOT NULL AND p_COUNTER_PARTY >= 0 THEN
            p_SELLER_ID_OUT := p_COUNTER_PARTY;
         END IF;
       ELSE
         IF p_COUNTER_PARTY IS NOT NULL AND p_COUNTER_PARTY >0 THEN
            p_PURCHASER_ID_OUT := p_COUNTER_PARTY;
         END IF;
       END IF;

       -- IF NOT POPULATED BY THE COUNTER PARTY, USE THIS ORDER:
       -- 1) USE COLUMN
       -- 2) USE SELLER FROM CONTRACT
       -- 3) IF SUPPLY, USE BILLING ENTITY FROM CONTRACT
       IF p_SELLER_ID_OUT IS NULL OR p_SELLER_ID_OUT < 0 THEN
          IF p_SELLER_ID IS NOT NULL AND p_SELLER_ID >= 0 THEN
             p_SELLER_ID_OUT := p_SELLER_ID;
          ELSE
             IF p_CONTRACT_ID IS NOT NULL AND p_CONTRACT_ID > 0 THEN
                SELECT C.SELLER_ID INTO p_SELLER_ID_OUT
                FROM INTERCHANGE_CONTRACT C
                WHERE C.CONTRACT_ID = p_CONTRACT_ID;

                IF (p_SELLER_ID_OUT IS NULL OR p_SELLER_ID_OUT < 0)
                    AND TXN_TYPE_IS_SUPPLY(p_TRANSACTION_TYPE) THEN
                   SELECT C.BILLING_ENTITY_ID INTO p_SELLER_ID_OUT
                   FROM INTERCHANGE_CONTRACT C
                   WHERE C.CONTRACT_ID = p_CONTRACT_ID;
                END IF;
             END IF;
          END IF;
       END IF;

       -- IF NOT POPULATED BY THE COUNTER PARTY, USE THIS ORDER:
       -- 1) USE COLUMN
       -- 2) USE SELLER FROM CONTRACT
       -- 3) IF NOT SUPPLY, USE BILLING ENTITY FROM CONTRACT
       IF p_PURCHASER_ID_OUT IS NULL OR p_PURCHASER_ID_OUT < 0 THEN
          IF p_PURCHASER_ID IS NOT NULL AND p_PURCHASER_ID >= 0 THEN
             p_PURCHASER_ID_OUT := p_PURCHASER_ID;
          ELSE
             IF p_CONTRACT_ID IS NOT NULL AND p_CONTRACT_ID > 0 THEN
                SELECT C.PURCHASER_ID INTO p_PURCHASER_ID_OUT
                FROM INTERCHANGE_CONTRACT C
                WHERE C.CONTRACT_ID = p_CONTRACT_ID;

                IF (p_PURCHASER_ID_OUT IS NULL OR p_PURCHASER_ID_OUT < 0)
                    AND NOT TXN_TYPE_IS_SUPPLY(p_TRANSACTION_TYPE) THEN
                   SELECT C.BILLING_ENTITY_ID INTO p_PURCHASER_ID_OUT
                   FROM INTERCHANGE_CONTRACT C
                   WHERE C.CONTRACT_ID = p_CONTRACT_ID;
                END IF;
             END IF;
          END IF;
       END IF;
    ELSE
        IF p_COUNTER_PARTY != p_OLD_COUNTER_PARTY THEN
           IF TXN_TYPE_IS_SUPPLY(p_TRANSACTION_TYPE) THEN
              p_SELLER_ID_OUT := p_COUNTER_PARTY;
           ELSE
              p_PURCHASER_ID_OUT := p_COUNTER_PARTY;
           END IF;
        ELSE
          IF p_SELLER_ID IS NOT NULL AND p_SELLER_ID >= 0 THEN
             p_SELLER_ID_OUT := p_SELLER_ID;
          END IF;

          IF p_PURCHASER_ID IS NOT NULL AND p_PURCHASER_ID >= 0 THEN
             p_PURCHASER_ID_OUT := p_PURCHASER_ID;
          END IF;
        END IF;
    END IF;

    IF p_SELLER_ID_OUT IS NULL OR p_SELLER_ID_OUT < 0 THEN
       p_SELLER_ID_OUT := GET_TXN_BLOTTER_DEFAULT_AS_NUM(p_REPORT_NAME, p_TRANSACTION_TYPE, 'SELLER_ID');
    END IF;

    IF p_PURCHASER_ID_OUT IS NULL OR p_PURCHASER_ID_OUT < 0 THEN
       p_PURCHASER_ID_OUT := GET_TXN_BLOTTER_DEFAULT_AS_NUM(p_REPORT_NAME, p_TRANSACTION_TYPE, 'PURCHASER_ID');
    END IF;

    IF p_PURCHASER_ID_OUT IS NULL OR p_PURCHASER_ID_OUT < 0 THEN
       p_PURCHASER_ID_OUT := 0;
    END IF;

    IF p_SELLER_ID_OUT IS NULL OR p_SELLER_ID_OUT < 0 THEN
       p_SELLER_ID_OUT := 0;
    END IF;

END RESOLVE_SELLER_PURCH_CP;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_TRANSACTION_BLOTTER
	(
	p_SCHEDULE_TYPE IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_FB_TRANSACTION_INTERVAL IN VARCHAR2,
	p_FB_CATEGORY IN VARCHAR2,
	p_FB_COMMODITY_ID IN VARCHAR2,
	p_FB_SC_ID IN NUMBER,
	p_FB_CONTRACT_ID IN NUMBER,
	p_FB_IT_STATUS IN VARCHAR2,
	p_REPORT_NAME IN VARCHAR2,
	p_TRANSACTION_ID IN NUMBER,
	p_TRANSACTION_NAME IN VARCHAR2,
	p_TRANSACTION_STATUS_NAME IN VARCHAR2,
	p_CONTRACT_ID IN NUMBER,
	p_TRANSACTION_TYPE IN VARCHAR2,
	p_IS_IMPORT_SCHEDULE IN NUMBER,
	p_IS_EXPORT_SCHEDULE IN NUMBER,
	p_IS_IMPORT_EXPORT IN NUMBER,
	p_TRANSACTION_INTERVAL IN VARCHAR2,
	p_COMMODITY_ID IN NUMBER,
	p_BEGIN_DATE_COLUMN IN DATE,
	p_END_DATE_COLUMN IN DATE,
	p_SCHEDULE_TEMPLATE IN VARCHAR2,
	p_SPECIFY_HOURS IN NUMBER,
	p_IS_ON IN NUMBER,
	p_BEGIN_HOUR IN NUMBER,
	p_END_HOUR IN NUMBER,
	p_AMOUNT IN NUMBER,
	p_PRICE IN NUMBER,
	p_SC_ID IN NUMBER,
	p_PURCHASER_ID IN NUMBER,
	p_SELLER_ID IN NUMBER,
	p_COUNTER_PARTY IN NUMBER,
	p_OLD_COUNTER_PARTY IN NUMBER,
	p_POR_ID IN NUMBER,
	p_POD_ID IN NUMBER,
	p_SOURCE_ID IN NUMBER,
	p_SINK_ID IN NUMBER,
	p_AGREEMENT_TYPE IN VARCHAR2,
	p_APPROVAL_TYPE IN VARCHAR2,
	p_LOSS_OPTION IN VARCHAR2,
	p_RESOURCE_ID IN NUMBER,
	p_ZOR_ID IN NUMBER,
	p_ZOD_ID IN NUMBER,
	p_MARKET_PRICE_ID IN NUMBER,
	p_IS_FIRM IN NUMBER,
	p_IS_BID_OFFER IN NUMBER,
	p_IS_BALANCE_TRANSACTION IN NUMBER,
	p_IS_DISPATCHABLE IN NUMBER,
	p_SCHEDULE_GROUP_ID IN NUMBER,
	p_TX_TRANSACTION_ID IN NUMBER,
	p_LINK_TRANSACTION_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_TP_ID IN NUMBER,
	p_TRAIT_CATEGORY IN VARCHAR2,
	p_STATUS OUT NUMBER
	) AS

  -- All of these input params have default fallbacks
  v_TRANSACTION_ID NUMBER(9);
  v_TRANSACTION_NAME VARCHAR2(64);
  v_TRANSACTION_DESC VARCHAR2(256);
  v_TRANSACTION_ALIAS VARCHAR2(64);
  v_TRANSACTION_STATUS_NAME VARCHAR2(64);
  v_CONTRACT_ID NUMBER(9);
  v_TRANSACTION_TYPE VARCHAR2(64);
  v_IS_IMPORT_SCHEDULE NUMBER(1);
  v_IS_EXPORT_SCHEDULE NUMBER(1);
  v_IS_IMPORT_EXPORT NUMBER(1);
  v_TRANSACTION_INTERVAL VARCHAR2(64) := NVL(p_TRANSACTION_INTERVAL, p_FB_TRANSACTION_INTERVAL);
  v_COMMODITY_ID NUMBER(9);
  v_BEGIN_DATE_COLUMN DATE;
  v_END_DATE_COLUMN DATE;
  v_SC_ID NUMBER(9);
  v_PURCHASER_ID NUMBER(9);
  v_SELLER_ID NUMBER(9);
  v_POR_ID NUMBER(9);
  v_POD_ID NUMBER(9);
  v_SOURCE_ID NUMBER(9);
  v_SINK_ID NUMBER(9);
  v_AGREEMENT_TYPE VARCHAR2(64);
  v_APPROVAL_TYPE VARCHAR2(64);
  v_LOSS_OPTION VARCHAR2(64);
  v_RESOURCE_ID NUMBER(9);
  v_ZOR_ID NUMBER(9);
  v_ZOD_ID NUMBER(9);
  v_MARKET_PRICE_ID NUMBER(9);
  v_IS_FIRM NUMBER(1);
  v_IS_BID_OFFER NUMBER(1);
  v_IS_BALANCE_TRANSACTION NUMBER(1);
  v_IS_DISPATCHABLE NUMBER(1);
  v_SCHEDULE_GROUP_ID NUMBER(9);
  v_TX_TRANSACTION_ID NUMBER(9);
  v_LINK_TRANSACTION_ID NUMBER(9);
  v_EDC_ID NUMBER(9);
  v_ESP_ID NUMBER(9);
  v_PSE_ID NUMBER(9);
  v_POOL_ID NUMBER(9);
  v_TP_ID NUMBER(9);
  v_TRAIT_CATEGORY VARCHAR2(64);

  v_CONTRACT_NAME VARCHAR2(32);

  v_IS_NEW BOOLEAN;

  v_COMMODITY_TABLE ID_TABLE;
  v_CATEGORY_TABLE STRING_TABLE;

  v_CAN_EDIT BOOLEAN;
  v_CAN_FILL BOOLEAN;

  v_TEMPLATE_STRING VARCHAR2(16);
  v_BEGIN_HOUR NUMBER(2);
  v_END_HOUR NUMBER(2);
  v_INCLUDE_HOL NUMBER(1);

  BEGIN

      PARSE_UTIL.ID_TABLE_FROM_STRING(p_FB_COMMODITY_ID, ',', v_COMMODITY_TABLE);
      UT.STRING_TABLE_FROM_STRING(p_fb_category, ',', v_CATEGORY_TABLE);

	  v_IS_NEW := NVL(p_TRANSACTION_ID,0) <= 0;

	  v_CAN_EDIT := UT.BOOLEAN_FROM_STRING(GET_DICTIONARY_VALUE('Can Edit Existing Rows', GA.ELECTRIC_MODEL, 'Scheduling', 'Transactions', p_REPORT_NAME));

      IF NOT v_IS_NEW AND NOT v_CAN_EDIT THEN
         ERRS.RAISE(MSGCODES.c_ERR_GENERAL, c_CANNOT_EDIT_TXN_BLOTTER_MSG);
      END IF;

	  v_CAN_FILL := UT.BOOLEAN_FROM_STRING(GET_DICTIONARY_VALUE('Can Fill Existing Rows', GA.ELECTRIC_MODEL, 'Scheduling', 'Transactions', p_REPORT_NAME));

      RESOLVE_TXN_TYPE(v_CATEGORY_TABLE, p_TRANSACTION_TYPE, p_REPORT_NAME, v_TRANSACTION_TYPE);

      RESOLVE_CONTRACT_ID(v_CONTRACT_ID, p_CONTRACT_ID, p_FB_CONTRACT_ID, p_REPORT_NAME, v_TRANSACTION_TYPE);

      IF v_CONTRACT_ID IS NOT NULL THEN
         SELECT C.CONTRACT_NAME INTO v_CONTRACT_NAME
         FROM INTERCHANGE_CONTRACT C
         WHERE C.CONTRACT_ID = v_CONTRACT_ID;
      END IF;

      IF p_TRANSACTION_NAME IS NOT NULL THEN
         v_TRANSACTION_NAME := p_TRANSACTION_NAME;
	  ELSE
	  	 -- generate a name - use a sequence to make sure name will be unique
	  	 SELECT v_CONTRACT_NAME || ' ' || v_TRANSACTION_TYPE || ' ' || OID.NEXTVAL
		 INTO v_TRANSACTION_NAME
		 FROM DUAL;
      END IF;

      RESOLVE_STATUS(v_TRANSACTION_STATUS_NAME, p_TRANSACTION_STATUS_NAME, p_FB_IT_STATUS, p_REPORT_NAME, v_TRANSACTION_TYPE);

      RESOLVE_COMMODITY(v_COMMODITY_ID, p_COMMODITY_ID, v_COMMODITY_TABLE, p_REPORT_NAME, v_TRANSACTION_TYPE);

      RESOLVE_SC(v_SC_ID, p_SC_ID, v_CONTRACT_ID, p_FB_SC_ID, p_REPORT_NAME, v_TRANSACTION_TYPE);

      RESOLVE_FROM_CONTRACT( v_CONTRACT_ID, v_BEGIN_DATE_COLUMN, p_BEGIN_DATE_COLUMN, v_END_DATE_COLUMN, p_END_DATE_COLUMN, v_POR_ID, p_POR_ID,
                             v_POD_ID, p_POD_ID, v_SOURCE_ID, p_SOURCE_ID, v_SINK_ID, p_SINK_ID, v_AGREEMENT_TYPE, p_AGREEMENT_TYPE,
                              v_APPROVAL_TYPE, p_APPROVAL_TYPE, v_LOSS_OPTION, p_LOSS_OPTION, p_REPORT_NAME, v_TRANSACTION_TYPE);

      RESOLVE_TO_NULL( v_RESOURCE_ID, p_RESOURCE_ID, v_ZOR_ID, p_ZOR_ID, v_ZOD_ID, p_ZOD_ID, v_MARKET_PRICE_ID, p_MARKET_PRICE_ID,
                       v_IS_FIRM, p_IS_FIRM, v_IS_BID_OFFER, p_IS_BID_OFFER, v_IS_BALANCE_TRANSACTION, p_IS_BALANCE_TRANSACTION,
                       v_IS_DISPATCHABLE, p_IS_DISPATCHABLE, v_SCHEDULE_GROUP_ID, p_SCHEDULE_GROUP_ID, v_TX_TRANSACTION_ID, p_TX_TRANSACTION_ID,
                       v_LINK_TRANSACTION_ID, p_LINK_TRANSACTION_ID, v_EDC_ID, p_EDC_ID, v_ESP_ID, p_ESP_ID,
                       v_PSE_ID, p_PSE_ID, v_POOL_ID, p_POOL_ID, v_TP_ID, p_TP_ID, v_IS_IMPORT_EXPORT, p_IS_IMPORT_EXPORT, v_IS_IMPORT_SCHEDULE, p_IS_IMPORT_SCHEDULE,
                       v_IS_EXPORT_SCHEDULE, p_IS_EXPORT_SCHEDULE, v_TRAIT_CATEGORY, P_TRAIT_CATEGORY,
                       p_REPORT_NAME, v_TRANSACTION_TYPE);

      RESOLVE_SELLER_PURCH_CP(v_IS_NEW, v_SELLER_ID, p_SELLER_ID, v_PURCHASER_ID, p_PURCHASER_ID, p_COUNTER_PARTY, p_OLD_COUNTER_PARTY, v_CONTRACT_ID, p_REPORT_NAME, v_TRANSACTION_TYPE);

      IF NOT v_IS_NEW THEN
         SELECT T.TRANSACTION_ALIAS, T.TRANSACTION_DESC INTO v_TRANSACTION_ALIAS, v_TRANSACTION_DESC
         FROM INTERCHANGE_TRANSACTION T
         WHERE T.TRANSACTION_ID = p_TRANSACTION_ID;
	  ELSE
	  	 v_TRANSACTION_ALIAS := v_TRANSACTION_NAME;
		 v_TRANSACTION_DESC := v_TRANSACTION_NAME;
      END IF;

      IF p_TRANSACTION_ID IS NULL THEN
         v_TRANSACTION_ID := 0;
      ELSE
         v_TRANSACTION_ID := p_TRANSACTION_ID;
      END IF;

      EM.PUT_TRANSACTION(v_TRANSACTION_ID, v_TRANSACTION_NAME, v_TRANSACTION_ALIAS, v_TRANSACTION_DESC, v_TRANSACTION_ID,
                                           v_TRANSACTION_STATUS_NAME, v_TRANSACTION_TYPE, NULL, v_IS_FIRM, p_IS_IMPORT_SCHEDULE,
                                           p_IS_EXPORT_SCHEDULE, v_IS_BALANCE_TRANSACTION, v_IS_BID_OFFER, 0, v_IS_IMPORT_EXPORT, v_IS_DISPATCHABLE,
                                           v_TRANSACTION_INTERVAL, null, null, v_BEGIN_DATE_COLUMN, v_END_DATE_COLUMN, v_PURCHASER_ID, v_SELLER_ID, v_CONTRACT_ID,
                                           v_SC_ID, v_POR_ID, v_POD_ID, v_COMMODITY_ID, 0, v_TX_TRANSACTION_ID, 0, v_LINK_TRANSACTION_ID,
                                           v_EDC_ID, v_PSE_ID, v_ESP_ID, v_POOL_ID, v_SCHEDULE_GROUP_ID, v_MARKET_PRICE_ID, v_ZOR_ID, v_ZOD_ID, v_SOURCE_ID,
                                           v_SINK_ID, v_RESOURCE_ID, v_AGREEMENT_TYPE, v_APPROVAL_TYPE, v_LOSS_OPTION, v_TRAIT_CATEGORY, v_TP_ID);

		-- fill the schedule if it is a new transaction or if we are allowing fill operations on existing transactions
      IF NOT v_IS_NEW OR v_CAN_FILL THEN
         IF p_SCHEDULE_TEMPLATE IS NOT NULL AND (p_AMOUNT IS NOT NULL OR p_PRICE IS NOT NULL) THEN

		 	IF NVL(p_SPECIFY_HOURS, 0) = 1 AND p_BEGIN_HOUR IS NOT NULL AND p_END_HOUR IS NOT NULL THEN
				-- specifying hours? use them to override template
			 	GET_TEMPLATE_INFO(p_SCHEDULE_TEMPLATE, p_BEGIN_HOUR, p_END_HOUR, p_IS_ON,
								v_TEMPLATE_STRING, v_BEGIN_HOUR, v_END_HOUR, v_INCLUDE_HOL);
			ELSE
				-- use template as is
				GET_TEMPLATE_INFO(p_SCHEDULE_TEMPLATE, NULL, NULL, NULL,
								v_TEMPLATE_STRING, v_BEGIN_HOUR, v_END_HOUR, v_INCLUDE_HOL);
			END IF;

			ITJ.SCHEDULE_FILL(v_TRANSACTION_ID, v_BEGIN_DATE_COLUMN, v_END_DATE_COLUMN, p_AS_OF_DATE, p_TIME_ZONE, p_AMOUNT, p_PRICE,
							   v_TEMPLATE_STRING, v_BEGIN_HOUR, v_END_HOUR, v_INCLUDE_HOL, p_SCHEDULE_TYPE, p_STATUS);

		 ELSIF p_BEGIN_HOUR IS NOT NULL AND p_END_HOUR IS NOT NULL AND (p_AMOUNT IS NOT NULL OR p_PRICE IS NOT NULL) THEN

			-- fill specified hours for all days in date range
			v_TEMPLATE_STRING := BUILD_TEMPLATE_STRING(c_ANYDAY_STRING, p_IS_ON, p_BEGIN_HOUR, p_END_HOUR);
			ITJ.SCHEDULE_FILL(v_TRANSACTION_ID, v_BEGIN_DATE_COLUMN, v_END_DATE_COLUMN, p_AS_OF_DATE, p_TIME_ZONE, p_AMOUNT, p_PRICE,
							  v_TEMPLATE_STRING, p_BEGIN_HOUR, p_END_HOUR, 1, p_SCHEDULE_TYPE, p_STATUS);

         END IF;
      END IF;

      p_STATUS := GA.SUCCESS;

END PUT_TRANSACTION_BLOTTER;
----------------------------------------------------------------------------------------------------
FUNCTION BUILD_TEMPLATE_STRING
	(
	p_WEEKDAYS_STRING IN VARCHAR2,
	p_IS_ON           IN NUMBER,
	p_BEGIN_HOUR      IN NUMBER,
	p_END_HOUR        IN NUMBER
	) RETURN VARCHAR2 IS

v_ANY_PAT VARCHAR2(1) := '0';
v_WEEKDAY_PAT VARCHAR2(1) := '0';
v_WEEKEND_PAT VARCHAR2(1) := '0';
v_PATTERN_ALL VARCHAR2(1) := '0';
v_PATTERN_ON VARCHAR2(1) := '0';
v_PATTERN_OFF VARCHAR2(1) := '0';

BEGIN

	IF p_WEEKDAYS_STRING = c_ANYDAY_STRING THEN
		v_ANY_PAT := '1';
	END IF;

	IF p_WEEKDAYS_STRING = c_WEEKEND_STRING THEN
		v_WEEKEND_PAT := '1';
	END IF;

	IF p_WEEKDAYS_STRING = c_WEEKDAY_STRING THEN
		v_WEEKDAY_PAT := '1';
	END IF;

	IF p_BEGIN_HOUR = 1 AND p_END_HOUR = 24 THEN
		v_PATTERN_ALL := '1';
	END IF;

	IF p_IS_ON IS NULL THEN
		-- 'is on' unset? then treat begin hour > end hour
		-- to mean 'off'
		IF p_BEGIN_HOUR > p_END_HOUR THEN
			v_PATTERN_OFF := '1';
		ELSE -- p_END_HOUR > p_BEGIN_HOUR
			v_PATTERN_ON := '1';
		END IF;

	ELSIF p_IS_ON = 1 THEN
		v_PATTERN_ON := '1';

	ELSE -- p_IS_ON = 0
		v_PATTERN_OFF := '1';

	END IF;

	-- collect info into a template string that can be passed to
	-- SP.GET_SCHEDULE_DATES
	RETURN v_ANY_PAT || v_WEEKDAY_PAT || v_WEEKEND_PAT || p_WEEKDAYS_STRING
					  || v_PATTERN_ALL || v_PATTERN_ON || v_PATTERN_OFF;

END BUILD_TEMPLATE_STRING;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_TEMPLATE_INFO
	(
	p_SCHEDULE_TEMPLATE_NAME IN VARCHAR2,
	p_OVERRIDE_BEGIN_HOUR IN NUMBER := NULL,
	p_OVERRIDE_END_HOUR IN NUMBER := NULL,
	p_OVERRIDE_IS_ON IN NUMBER := NULL,
	p_TEMPLATE_PATTERN OUT VARCHAR2,
	p_BEGIN_HOUR OUT NUMBER,
	p_END_HOUR OUT NUMBER,
	p_INCLUDE_HOLIDAYS OUT NUMBER
	) IS

v_TYPE				SCHEDULE_TEMPLATE.TEMPLATE_TYPE%TYPE;
v_WEEKDAYS_TEMPLATE	SCHEDULE_TEMPLATE.DAY_OF_WEEK%TYPE;
v_IS_ON				SCHEDULE_TEMPLATE.INTERIOR_PERIOD%TYPE;

BEGIN

	-- Query fields from the specified schedule template
	BEGIN
		SELECT T.TEMPLATE_TYPE,
			T.DAY_OF_WEEK,
			T.INCLUDE_HOLIDAYS,
			NVL(p_OVERRIDE_BEGIN_HOUR,T.START_HOUR_END),
			NVL(p_OVERRIDE_END_HOUR,T.STOP_HOUR_END),
			NVL(p_OVERRIDE_IS_ON,T.INTERIOR_PERIOD)
		INTO v_TYPE,
			v_WEEKDAYS_TEMPLATE,
			p_INCLUDE_HOLIDAYS,
			p_BEGIN_HOUR,
			p_END_HOUR,
			v_IS_ON
		FROM SCHEDULE_TEMPLATE T
		WHERE T.TEMPLATE_NAME = p_SCHEDULE_TEMPLATE_NAME;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.RAISE_BAD_ARGUMENT('Schedule Template Name', p_SCHEDULE_TEMPLATE_NAME,
									'Template does not exist');
	END;

	-- build pattern
	p_TEMPLATE_PATTERN := BUILD_TEMPLATE_STRING(v_WEEKDAYS_TEMPLATE, v_IS_ON, p_BEGIN_HOUR, p_END_HOUR);

	-- Special template?
	IF v_TYPE = c_SPECIAL_TEMPLATE_TYPE THEN
		IF p_SCHEDULE_TEMPLATE_NAME = c_LOCAL_ON_PEAK_TEMPLATE THEN
			p_TEMPLATE_PATTERN := p_TEMPLATE_PATTERN||'010';
		ELSIF p_SCHEDULE_TEMPLATE_NAME = c_LOCAL_OFF_PEAK_TEMPLATE THEN
			p_TEMPLATE_PATTERN := p_TEMPLATE_PATTERN||'001';
		ELSE
			ERRS.RAISE_BAD_ARGUMENT('Schedule Template Name', p_SCHEDULE_TEMPLATE_NAME,
								'Unrecognized name for "special" template');
		END IF;

		-- Can't do "override" values with special templates
		IF p_OVERRIDE_BEGIN_HOUR IS NOT NULL THEN
			ERRS.RAISE_BAD_ARGUMENT('Begin Hour', p_OVERRIDE_BEGIN_HOUR,
								'Cannot specify a begin hour with this template: '||p_SCHEDULE_TEMPLATE_NAME);
		END IF;
		IF p_OVERRIDE_BEGIN_HOUR IS NOT NULL THEN
			ERRS.RAISE_BAD_ARGUMENT('End Hour', p_OVERRIDE_END_HOUR,
								'Cannot specify an end hour with this template: '||p_SCHEDULE_TEMPLATE_NAME);
		END IF;
		IF p_OVERRIDE_IS_ON IS NOT NULL THEN
			ERRS.RAISE_BAD_ARGUMENT('Is On', p_OVERRIDE_IS_ON,
								'Cannot specify hours as on/off with this template: '||p_SCHEDULE_TEMPLATE_NAME);
		END IF;
	END IF;

END GET_TEMPLATE_INFO;
----------------------------------------------------------------------------------------------------
PROCEDURE DELETE_TRANSACTION
	(
	p_TRANSACTION_ID IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

v_CAN_DELETE BOOLEAN;

BEGIN

	XS.CAN_DELETE_TRANSACTION(p_TRANSACTION_ID, v_CAN_DELETE);

	IF v_CAN_DELETE THEN
		DE.DEL_TRANSACTION(p_TRANSACTION_ID, p_STATUS);
	ELSE
	   p_STATUS := -1;
	END IF;

END DELETE_TRANSACTION;
----------------------------------------------------------------------------------------------------
PROCEDURE SUB_STATION_FILL
	(
	p_METER_POINT_ID IN NUMBER,
	p_MEASUREMENT_SOURCE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_METER_CODE IN VARCHAR2,
    p_TIME_ZONE IN VARCHAR2,
	p_METER_VAL IN VARCHAR2,
	p_TRUNCATED_VAL IN VARCHAR2,
	p_TEMPLATE IN VARCHAR,
	p_BEGIN_HOUR IN NUMBER,
	p_END_HOUR IN NUMBER,
	p_INCLUDE_HOLIDAYS IN NUMBER
	) AS

	v_POINT_BEGIN_DATE DATE;
	v_POINT_END_DATE DATE;

	v_BEGIN_DATE DATE;
	v_END_DATE DATE;

	v_DELETE CHAR := SUBSTR(p_TEMPLATE, 14, 1);

	v_METER_VAL NUMBER := LTRIM(RTRIM(p_METER_VAL));
	v_TRUNCATED_VAL NUMBER := LTRIM(RTRIM(p_TRUNCATED_VAL));
	v_METER_CODE CHAR := SUBSTR(p_METER_CODE, 1, 1);

	v_DELETE_BEGIN DATE;
	v_DELETE_END DATE;

BEGIN

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_METER_POINT_ID, EC.ED_SUB_STATION_METER_POINT);

	-- OUR DATE RANGE IS BOUNDED BY THE DATE RANGE OF THE METER POINT
	-- AND THE SPECIFIED MEASUREMENT SOURCE
	SELECT GREATEST(NVL(PT.BEGIN_DATE, CONSTANTS.LOW_DATE), NVL(SRC.BEGIN_DATE, CONSTANTS.LOW_DATE)),
		LEAST(NVL(PT.END_DATE, CONSTANTS.HIGH_DATE), NVL(SRC.END_DATE, CONSTANTS.HIGH_DATE))
	INTO v_POINT_BEGIN_DATE, v_POINT_END_DATE
	FROM TX_SUB_STATION_METER_POINT PT,
		TX_SUB_STATION_METER_PT_SOURCE SRC
	WHERE PT.METER_POINT_ID = p_METER_POINT_ID
		AND SRC.METER_POINT_ID = PT.METER_POINT_ID
		AND SRC.MEASUREMENT_SOURCE_ID = p_MEASUREMENT_SOURCE_ID;

	IF p_BEGIN_DATE > v_POINT_END_DATE OR p_END_DATE < v_POINT_BEGIN_DATE THEN
		ERRS.RAISE_BAD_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, TEXT_UTIL.TO_CHAR_ENTITY(p_METER_POINT_ID,
					EC.ED_SUB_STATION_METER_POINT, TRUE)
					|| ' is only defined for ' || TEXT_UTIL.TO_CHAR_DATE(v_POINT_BEGIN_DATE) || ' -> '
					|| TEXT_UTIL.TO_CHAR_DATE(v_POINT_END_DATE));
	END IF;

	v_BEGIN_DATE := GREATEST(v_POINT_BEGIN_DATE, p_BEGIN_DATE);
	v_END_DATE := LEAST(v_POINT_END_DATE, p_END_DATE);

	IF v_DELETE = '1' THEN
		UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, v_BEGIN_DATE, v_END_DATE, p_TIME_ZONE,
			v_DELETE_BEGIN, v_DELETE_END);

		DELETE FROM TX_SUB_STATION_METER_PT_VALUE VL
		WHERE VL.METER_POINT_ID = p_METER_POINT_ID
			AND VL.MEASUREMENT_SOURCE_ID = p_MEASUREMENT_SOURCE_ID
			AND VL.METER_CODE = v_METER_CODE
			AND VL.METER_DATE BETWEEN v_DELETE_BEGIN AND v_DELETE_END;
	END IF;

	FOR v_FILL_DATE IN (SELECT * FROM TABLE(CAST(SP.GET_SCHEDULE_DATES(v_BEGIN_DATE,
														v_END_DATE,
														p_TIME_ZONE,
														p_TEMPLATE,
														p_BEGIN_HOUR,
														p_END_HOUR,
														p_INCLUDE_HOLIDAYS,
														'Hour', 0) AS DATE_COLLECTION)))
	LOOP
		UPDATE TX_SUB_STATION_METER_PT_VALUE VAL
		SET VAL.METER_VAL = NVL(v_METER_VAL, VAL.METER_VAL),
			VAL.TRUNCATED_VAL = NVL(v_TRUNCATED_VAL, VAL.TRUNCATED_VAL),
			 ENTRY_DATE = SYSDATE
		WHERE VAL.METER_POINT_ID = p_METER_POINT_ID
			AND VAL.MEASUREMENT_SOURCE_ID = p_MEASUREMENT_SOURCE_ID
			AND VAL.METER_CODE = v_METER_CODE
			AND VAL.METER_DATE = v_FILL_DATE.COLUMN_VALUE;

		IF SQL%NOTFOUND THEN
			INSERT INTO TX_SUB_STATION_METER_PT_VALUE (METER_POINT_ID, MEASUREMENT_SOURCE_ID,
				METER_CODE, METER_DATE, METER_VAL, ENTRY_DATE)
			VALUES ( p_METER_POINT_ID, p_MEASUREMENT_SOURCE_ID, v_METER_CODE,
				v_FILL_DATE.COLUMN_VALUE, v_METER_VAL, SYSDATE);
		END IF;
	END LOOP;
END SUB_STATION_FILL;
----------------------------------------------------------------------------------------------------
PROCEDURE IT_SCHEDULE_MANAGEMENT_MAPS
	(
	p_TXN_IDs IN NUMBER_COLLECTION,
	p_SMNT_TYPE_ID IN NUMBER,
	p_SCHED_STATE IN NUMBER,
	p_SCHED_MGMT_CIDs IN STRING_COLLECTION,
	p_SCHED_MGMT_DATA_SOURCE IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT TXN.TRANSACTION_NAME,
			M.TRANSACTION_ID,
			S.STATEMENT_TYPE_NAME,
			M.STATEMENT_TYPE_ID,
			M.SCHEDULE_STATE,
			M.SCHED_MGMT_CID,
			M.SCHED_MGMT_DATA_SOURCE,
			CASE WHEN M.SCHED_MGMT_DATA_SOURCE = 'P' THEN 'Preschedule'
				WHEN M.SCHED_MGMT_DATA_SOURCE = 'I' THEN 'Instruction'
				WHEN M.SCHED_MGMT_DATA_SOURCE = 'A' THEN 'Actual'
				WHEN M.SCHED_MGMT_DATA_SOURCE = 'D' THEN 'Day-Ahead'
				WHEN M.SCHED_MGMT_DATA_SOURCE = 'R' THEN 'Real-Time'
				WHEN M.SCHED_MGMT_DATA_SOURCE = 'O' THEN 'ISO Imported'
				ELSE NULL END AS SCHED_MGMT_DATA_SOURCE_DISP
		FROM IT_SCHEDULE_MANAGEMENT_MAP M,
			TABLE(CAST(p_TXN_IDs AS NUMBER_COLLECTION)) T,
			INTERCHANGE_TRANSACTION TXN,
			STATEMENT_TYPE S,
			TABLE(CAST(p_SCHED_MGMT_CIDs AS STRING_COLLECTION)) SMID
		WHERE (M.TRANSACTION_ID = T.COLUMN_VALUE OR T.COLUMN_VALUE = CONSTANTS.ALL_ID)
			AND TXN.TRANSACTION_ID = M.TRANSACTION_ID
			AND S.STATEMENT_TYPE_ID = M.STATEMENT_TYPE_ID
			AND (M.STATEMENT_TYPE_ID = p_SMNT_TYPE_ID OR p_SMNT_TYPE_ID = CONSTANTS.ALL_ID)
			AND (M.SCHEDULE_STATE = p_SCHED_STATE OR p_SCHED_STATE = CONSTANTS.ALL_ID)
			AND (M.SCHED_MGMT_CID = SMID.COLUMN_VALUE OR SMID.COLUMN_VALUE = CONSTANTS.ALL_STRING)
			AND (M.SCHED_MGMT_DATA_SOURCE = p_SCHED_MGMT_DATA_SOURCE OR p_SCHED_MGMT_DATA_SOURCE = CONSTANTS.ALL_STRING)
		ORDER BY TXN.TRANSACTION_NAME, S.STATEMENT_TYPE_NAME, M.SCHEDULE_STATE, M.SCHED_MGMT_CID, M.SCHED_MGMT_DATA_SOURCE;
END IT_SCHEDULE_MANAGEMENT_MAPS;
----------------------------------------------------------------------------------------------------
PROCEDURE SYNC_WITH_SCHEDULE_MANAGEMENT
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR2,
	p_TRANSACTION_ID IN NUMBER_COLLECTION,
	p_STATEMENT_TYPE_ID IN NUMBER_COLLECTION,
	p_SCHEDULE_STATE IN NUMBER_COLLECTION,
	p_MESSAGE OUT VARCHAR2
) AS
	v_CUT_BEGIN_DATE DATE;
	v_CUT_END_DATE DATE;
	v_IDX1 BINARY_INTEGER;
	v_IDX2 BINARY_INTEGER;
	v_IDX3 BINARY_INTEGER;
BEGIN

	UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_CUT_BEGIN_DATE, v_CUT_END_DATE);

	v_IDX1 := p_TRANSACTION_ID.FIRST;
	v_IDX2 := p_STATEMENT_TYPE_ID.FIRST;
	v_IDX3 := p_SCHEDULE_STATE.FIRST;
	WHILE p_TRANSACTION_ID.EXISTS(v_IDX1)
			AND p_STATEMENT_TYPE_ID.EXISTS(v_IDX2)
			AND p_SCHEDULE_STATE.EXISTS(v_IDX2)
	LOOP
		EXECUTE IMMEDIATE 'TRUNCATE TABLE IT_SCHEDULE_MANAGEMENT_STAGING';

		INSERT INTO IT_SCHEDULE_MANAGEMENT_STAGING
		SELECT M.SCHED_MGMT_CID, M.SCHED_MGMT_DATA_SOURCE, S.SCHEDULE_DATE, NVL(S.AMOUNT,0), T.TRANSACTION_INTERVAL
		FROM IT_SCHEDULE_MANAGEMENT_MAP M, INTERCHANGE_TRANSACTION T, IT_SCHEDULE S
		WHERE M.TRANSACTION_ID = p_TRANSACTION_ID(v_IDX1)
			AND M.STATEMENT_TYPE_ID = p_STATEMENT_TYPE_ID(v_IDX2)
			AND M.SCHEDULE_STATE = p_SCHEDULE_STATE(v_IDX3)
			AND T.TRANSACTION_ID = M.TRANSACTION_ID
			AND S.TRANSACTION_ID = T.TRANSACTION_ID
			AND S.SCHEDULE_TYPE = M.STATEMENT_TYPE_ID
			AND S.SCHEDULE_STATE = M.SCHEDULE_STATE
			AND S.SCHEDULE_DATE BETWEEN v_CUT_BEGIN_DATE AND v_CUT_END_DATE
		ORDER BY 1,2,3;

		-- Next record in the collection
		v_IDX1 := p_TRANSACTION_ID.NEXT(v_IDX1);
		v_IDX2 := p_STATEMENT_TYPE_ID.NEXT(v_IDX2);
		v_IDX3 := p_SCHEDULE_STATE.NEXT(v_IDX3);

		SCHEDULE_MANAGEMENT_SYNC.SUBMIT;
	END LOOP;

	p_MESSAGE := 'Synchronization was successful.';

END SYNC_WITH_SCHEDULE_MANAGEMENT;
----------------------------------------------------------------------------------------------------
PROCEDURE SCHED_MGMT_CID_LIST
	(
	p_SEARCH_STRING IN VARCHAR,
	p_SEARCH_TYPE	IN NUMBER,
	p_FIND_VALUE 	IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	p_STATUS := GA.SUCCESS;
	-- Normal Search
	IF NVL(p_SEARCH_TYPE,  CONSTANTS.SEARCH_TYPE_NORMAL) = CONSTANTS.SEARCH_TYPE_NORMAL THEN
		IF p_SEARCH_STRING = '%' OR p_SEARCH_STRING IS NULL THEN
			OPEN p_CURSOR FOR
				SELECT DISTINCT M.SCHED_MGMT_CID
				FROM IT_SCHEDULE_MANAGEMENT_MAP M
				ORDER BY M.SCHED_MGMT_CID;
		ELSE
			OPEN p_CURSOR FOR
				SELECT DISTINCT M.SCHED_MGMT_CID
				FROM IT_SCHEDULE_MANAGEMENT_MAP M
				WHERE M.SCHED_MGMT_CID LIKE p_SEARCH_STRING
				ORDER BY M.SCHED_MGMT_CID;

		END IF;
    -- Specific Value
	ELSIF p_SEARCH_TYPE = CONSTANTS.SEARCH_TYPE_BY_VAL THEN
		OPEN p_CURSOR FOR
			SELECT M.SCHED_MGMT_CID
			FROM IT_SCHEDULE_MANAGEMENT_MAP M
			WHERE M.SCHED_MGMT_CID = p_FIND_VALUE;
    END IF;

EXCEPTION
	WHEN OTHERS THEN
		p_STATUS := SQLCODE;
END SCHED_MGMT_CID_LIST;
----------------------------------------------------------------------------------------------------
FUNCTION GET_SCHED_MGMT_CID_COUNT RETURN NUMBER
AS
	v_COUNT NUMBER;
BEGIN
	SELECT COUNT(SCHED_MGMT_CID) INTO v_COUNT
	FROM IT_SCHEDULE_MANAGEMENT_MAP
	GROUP BY SCHED_MGMT_CID;

	RETURN v_COUNT;
END GET_SCHED_MGMT_CID_COUNT;
----------------------------------------------------------------------------------------------------
FUNCTION GET_POD_ID(p_TRANSACTION_ID IN NUMBER) RETURN NUMBER AS
v_RET NUMBER;
BEGIN
	SELECT POD_ID
	INTO v_RET
	FROM INTERCHANGE_TRANSACTION
	WHERE TRANSACTION_ID = p_TRANSACTION_ID;

	RETURN v_RET;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
		RETURN NULL;
END GET_POD_ID;
----------------------------------------------------------------------------------------------------
END ITJ;
/

