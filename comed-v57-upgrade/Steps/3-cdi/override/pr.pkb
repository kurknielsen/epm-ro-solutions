CREATE OR REPLACE PACKAGE BODY PR AS
---------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
    RETURN '$Revision: 1.79 $';
END WHAT_VERSION;
----------------------------------------------------------------------------------------------------
PROCEDURE NULL_CURSOR
    (
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT NULL FROM DUAL;
END NULL_CURSOR;
---------------------------------------------------------------------------------------------------
PROCEDURE COMPONENT_FLAT_RATES
	(
	p_COMPONENT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);
    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		  SELECT A.COMPONENT_ID, A.SUB_COMPONENT_TYPE, A.SUB_COMPONENT_ID,
			  	A.BEGIN_DATE, A.END_DATE,
				A.RATE, A.CHARGE_MIN, A.ENTRY_DATE
		  FROM COMPONENT_FLAT_RATE A
		  WHERE COMPONENT_ID = p_COMPONENT_ID
		  ORDER BY BEGIN_DATE;

END COMPONENT_FLAT_RATES;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_COMPONENT_FLAT_RATE
	(
	p_COMPONENT_ID IN NUMBER,
    p_SUB_COMPONENT_TYPE IN VARCHAR2,
    p_SUB_COMPONENT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CHARGE_MIN IN NUMBER,
	p_RATE IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS
CURSOR c_COMPONENT_FLAT_RATE IS
	SELECT *
	FROM COMPONENT_FLAT_RATE
	WHERE COMPONENT_ID = p_COMPONENT_ID
    	AND SUB_COMPONENT_TYPE = p_SUB_COMPONENT_TYPE
        AND SUB_COMPONENT_ID = p_SUB_COMPONENT_ID
	ORDER BY BEGIN_DATE DESC;

v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
v_COMPONENT_FLAT_RATE COMPONENT_FLAT_RATE%ROWTYPE;
v_INITIAL BOOLEAN;
v_END_DATE DATE;
BEGIN
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);
	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

	v_KEY_NEW('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_COMPONENT_ID);
    v_KEY_OLD('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_COMPONENT_ID);
	v_KEY_NEW('SUB_COMPONENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_SUB_COMPONENT_TYPE);
	v_KEY_OLD('SUB_COMPONENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_SUB_COMPONENT_TYPE);
	v_KEY_NEW('SUB_COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SUB_COMPONENT_ID);
	v_KEY_OLD('SUB_COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SUB_COMPONENT_ID);

    v_DATA('CHARGE_MIN') := UT.GET_LITERAL_FOR_NUMBER(p_CHARGE_MIN);
	v_DATA('RATE') := UT.GET_LITERAL_FOR_NUMBER(p_RATE);

	UT.PUT_TEMPORAL_DATA_UI('COMPONENT_FLAT_RATE',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

	OPEN c_COMPONENT_FLAT_RATE;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_COMPONENT_FLAT_RATE INTO v_COMPONENT_FLAT_RATE;
		EXIT WHEN c_COMPONENT_FLAT_RATE%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_COMPONENT_FLAT_RATE.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE COMPONENT_FLAT_RATE
		SET END_DATE = GREATEST(v_END_DATE, v_COMPONENT_FLAT_RATE.BEGIN_DATE)
		WHERE COMPONENT_ID = v_COMPONENT_FLAT_RATE.COMPONENT_ID
        	AND SUB_COMPONENT_TYPE = v_COMPONENT_FLAT_RATE.SUB_COMPONENT_TYPE
            AND SUB_COMPONENT_ID = v_COMPONENT_FLAT_RATE.SUB_COMPONENT_ID
			AND BEGIN_DATE = v_COMPONENT_FLAT_RATE.BEGIN_DATE;
		v_END_DATE := v_COMPONENT_FLAT_RATE.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_COMPONENT_FLAT_RATE;

END PUT_COMPONENT_FLAT_RATE;
---------------------------------------------------------------------------------------------------
PROCEDURE COMPONENT_MARKET_RATES
	(
	p_COMPONENT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);
    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		  SELECT A.COMPONENT_ID, A.SUB_COMPONENT_TYPE, A.SUB_COMPONENT_ID,
			  	A.BEGIN_DATE, A.END_DATE,
				A.RATE_ADDER, A.RATE_MULTIPLIER, A.ENTRY_DATE
		  FROM COMPONENT_MARKET_PRICE A
		  WHERE COMPONENT_ID = p_COMPONENT_ID
		  ORDER BY BEGIN_DATE;

END COMPONENT_MARKET_RATES;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_COMPONENT_MARKET_PRICE
	(
	p_COMPONENT_ID IN NUMBER,
    p_SUB_COMPONENT_TYPE IN VARCHAR2,
    p_SUB_COMPONENT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_RATE_ADDER IN NUMBER,
	p_RATE_MULTIPLIER IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	)AS
CURSOR c_COMPONENT_MARKET_PRICE IS
	SELECT *
	FROM COMPONENT_MARKET_PRICE
	WHERE COMPONENT_ID = p_COMPONENT_ID
    	AND SUB_COMPONENT_TYPE = p_SUB_COMPONENT_TYPE
        AND SUB_COMPONENT_ID = p_SUB_COMPONENT_ID
	ORDER BY BEGIN_DATE DESC;

v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
v_COMPONENT_MARKET_PRICE COMPONENT_MARKET_PRICE%ROWTYPE;
v_INITIAL BOOLEAN;
v_END_DATE DATE;
BEGIN
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);
	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

	v_KEY_NEW('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_COMPONENT_ID);
    v_KEY_OLD('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_COMPONENT_ID);
	v_KEY_NEW('SUB_COMPONENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_SUB_COMPONENT_TYPE);
	v_KEY_OLD('SUB_COMPONENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_SUB_COMPONENT_TYPE);
	v_KEY_NEW('SUB_COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SUB_COMPONENT_ID);
	v_KEY_OLD('SUB_COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SUB_COMPONENT_ID);

    v_DATA('RATE_ADDER') := UT.GET_LITERAL_FOR_NUMBER(p_RATE_ADDER);
	v_DATA('RATE_MULTIPLIER') := UT.GET_LITERAL_FOR_NUMBER(p_RATE_MULTIPLIER);

	UT.PUT_TEMPORAL_DATA_UI('COMPONENT_MARKET_PRICE',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

	OPEN c_COMPONENT_MARKET_PRICE;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_COMPONENT_MARKET_PRICE INTO v_COMPONENT_MARKET_PRICE;
		EXIT WHEN c_COMPONENT_MARKET_PRICE%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_COMPONENT_MARKET_PRICE.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE COMPONENT_MARKET_PRICE
		SET END_DATE = GREATEST(v_END_DATE, v_COMPONENT_MARKET_PRICE.BEGIN_DATE)
		WHERE COMPONENT_ID = v_COMPONENT_MARKET_PRICE.COMPONENT_ID
	    	AND SUB_COMPONENT_TYPE = v_COMPONENT_MARKET_PRICE.SUB_COMPONENT_TYPE
	        AND SUB_COMPONENT_ID = v_COMPONENT_MARKET_PRICE.SUB_COMPONENT_ID
			AND BEGIN_DATE = v_COMPONENT_MARKET_PRICE.BEGIN_DATE;
		v_END_DATE := v_COMPONENT_MARKET_PRICE.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_COMPONENT_MARKET_PRICE;

END PUT_COMPONENT_MARKET_PRICE;
---------------------------------------------------------------------------------------------------
PROCEDURE COMPONENT_TOU_RATES
	(
	p_COMPONENT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);
    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		  SELECT A.COMPONENT_ID, A.SUB_COMPONENT_TYPE, A.SUB_COMPONENT_ID,
			  	A.PERIOD_ID, B.PERIOD_NAME, A.BEGIN_DATE, A.END_DATE,
				A.RATE, A.CHARGE_MIN, A.ENTRY_DATE
		  FROM COMPONENT_TOU_RATE A, PERIOD B
		  WHERE COMPONENT_ID = p_COMPONENT_ID
			  	AND B.PERIOD_ID = A.PERIOD_ID
		  ORDER BY PERIOD_NAME, BEGIN_DATE;

END COMPONENT_TOU_RATES;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_COMPONENT_TOU_RATE
	(
	p_COMPONENT_ID IN NUMBER,
    p_SUB_COMPONENT_TYPE IN VARCHAR2,
    p_SUB_COMPONENT_ID IN NUMBER,
	p_PERIOD_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_RATE IN NUMBER,
	p_CHARGE_MIN IN NUMBER,
	p_OLD_PERIOD_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	)AS
CURSOR c_COMPONENT_TOU_RATE IS
	SELECT *
	FROM COMPONENT_TOU_RATE
	WHERE COMPONENT_ID = p_COMPONENT_ID
    	AND SUB_COMPONENT_TYPE = p_SUB_COMPONENT_TYPE
        AND SUB_COMPONENT_ID = p_SUB_COMPONENT_ID
		AND PERIOD_ID = p_PERIOD_ID
	ORDER BY BEGIN_DATE DESC;

v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
v_COMPONENT_TOU_RATE COMPONENT_TOU_RATE%ROWTYPE;
v_INITIAL BOOLEAN;
v_END_DATE DATE;
BEGIN
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);
	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

	v_KEY_NEW('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_COMPONENT_ID);
    v_KEY_OLD('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_COMPONENT_ID);
	v_KEY_NEW('SUB_COMPONENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_SUB_COMPONENT_TYPE);
	v_KEY_OLD('SUB_COMPONENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_SUB_COMPONENT_TYPE);
	v_KEY_NEW('SUB_COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SUB_COMPONENT_ID);
	v_KEY_OLD('SUB_COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SUB_COMPONENT_ID);
	v_KEY_NEW('PERIOD_ID') := UT.GET_LITERAL_FOR_NUMBER(p_PERIOD_ID);
	v_KEY_OLD('PERIOD_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_PERIOD_ID);

    v_DATA('CHARGE_MIN') := UT.GET_LITERAL_FOR_NUMBER(p_CHARGE_MIN);
	v_DATA('RATE') := UT.GET_LITERAL_FOR_NUMBER(p_RATE);

	UT.PUT_TEMPORAL_DATA_UI('COMPONENT_TOU_RATE',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

	OPEN c_COMPONENT_TOU_RATE;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_COMPONENT_TOU_RATE INTO v_COMPONENT_TOU_RATE;
		EXIT WHEN c_COMPONENT_TOU_RATE%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_COMPONENT_TOU_RATE.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE COMPONENT_TOU_RATE
		SET END_DATE = GREATEST(v_END_DATE, v_COMPONENT_TOU_RATE.BEGIN_DATE)
		WHERE COMPONENT_ID = v_COMPONENT_TOU_RATE.COMPONENT_ID
        	AND SUB_COMPONENT_TYPE = v_COMPONENT_TOU_RATE.SUB_COMPONENT_TYPE
            AND SUB_COMPONENT_ID = v_COMPONENT_TOU_RATE.SUB_COMPONENT_ID
			AND PERIOD_ID = v_COMPONENT_TOU_RATE.PERIOD_ID
			AND BEGIN_DATE = v_COMPONENT_TOU_RATE.BEGIN_DATE;
		v_END_DATE := v_COMPONENT_TOU_RATE.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_COMPONENT_TOU_RATE;

END PUT_COMPONENT_TOU_RATE;
---------------------------------------------------------------------------------------------------
PROCEDURE COMPONENT_IMBALANCES
	(
	p_COMPONENT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);
    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		  SELECT A.COMPONENT_ID, A.SUB_COMPONENT_TYPE, A.SUB_COMPONENT_ID,
			  	A.BEGIN_DATE, A.END_DATE,
				SERVICE_POINT_ID,
				UNDER_UNDER_PRICE_ID, UNDER_OVER_PRICE_ID,
				OVER_UNDER_PRICE_ID, OVER_OVER_PRICE_ID,
				IS_PERCENT, IS_PRORATE, SETTLEMENT_AGENT, IMBALANCE_ID,
				A.ENTRY_DATE
		  FROM COMPONENT_IMBALANCE A
		  WHERE COMPONENT_ID = p_COMPONENT_ID
		  ORDER BY BEGIN_DATE;

END COMPONENT_IMBALANCES;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_COMPONENT_IMBALANCE
	(
	p_COMPONENT_ID IN NUMBER,
    p_SUB_COMPONENT_TYPE IN VARCHAR2,
    p_SUB_COMPONENT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_UNDER_UNDER_PRICE_ID IN NUMBER,
	p_UNDER_OVER_PRICE_ID IN NUMBER,
	p_OVER_UNDER_PRICE_ID IN NUMBER,
	p_OVER_OVER_PRICE_ID IN NUMBER,
	p_IS_PERCENT IN NUMBER,
	p_IS_PRORATE IN NUMBER,
	p_SETTLEMENT_AGENT IN VARCHAR,
	p_SERVICE_POINT_ID IN NUMBER,
	p_IMBALANCE_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	)AS
CURSOR c_COMPONENT_IMBALANCE IS
	SELECT *
	FROM COMPONENT_IMBALANCE
	WHERE COMPONENT_ID = p_COMPONENT_ID
    	AND SUB_COMPONENT_TYPE = p_SUB_COMPONENT_TYPE
        AND SUB_COMPONENT_ID = p_SUB_COMPONENT_ID
	ORDER BY BEGIN_DATE DESC;

v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
v_COMPONENT_IMBALANCE COMPONENT_IMBALANCE%ROWTYPE;
v_INITIAL BOOLEAN;
v_END_DATE DATE;
BEGIN
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);
	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

	v_KEY_NEW('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_COMPONENT_ID);
    v_KEY_OLD('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_COMPONENT_ID);
	v_KEY_NEW('SUB_COMPONENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_SUB_COMPONENT_TYPE);
	v_KEY_OLD('SUB_COMPONENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_SUB_COMPONENT_TYPE);
	v_KEY_NEW('SUB_COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SUB_COMPONENT_ID);
	v_KEY_OLD('SUB_COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SUB_COMPONENT_ID);

    v_DATA('UNDER_UNDER_PRICE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_UNDER_UNDER_PRICE_ID);
	v_DATA('UNDER_OVER_PRICE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_UNDER_OVER_PRICE_ID);
	v_DATA('OVER_UNDER_PRICE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OVER_UNDER_PRICE_ID);
	v_DATA('OVER_OVER_PRICE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OVER_OVER_PRICE_ID);
	v_DATA('IS_PERCENT') := UT.GET_LITERAL_FOR_NUMBER(p_IS_PERCENT);
	v_DATA('IS_PRORATE') := UT.GET_LITERAL_FOR_NUMBER(p_IS_PRORATE);
	v_DATA('SETTLEMENT_AGENT') := UT.GET_LITERAL_FOR_STRING(p_SETTLEMENT_AGENT);
	v_DATA('SERVICE_POINT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SERVICE_POINT_ID);
	v_DATA('IMBALANCE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_IMBALANCE_ID);

	UT.PUT_TEMPORAL_DATA_UI('COMPONENT_IMBALANCE',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

	OPEN c_COMPONENT_IMBALANCE;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_COMPONENT_IMBALANCE INTO v_COMPONENT_IMBALANCE;
		EXIT WHEN c_COMPONENT_IMBALANCE%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_COMPONENT_IMBALANCE.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE COMPONENT_IMBALANCE
		SET END_DATE = GREATEST(v_END_DATE, v_COMPONENT_IMBALANCE.BEGIN_DATE)
		WHERE COMPONENT_ID = v_COMPONENT_IMBALANCE.COMPONENT_ID
        	AND SUB_COMPONENT_TYPE = v_COMPONENT_IMBALANCE.SUB_COMPONENT_TYPE
            AND SUB_COMPONENT_ID = v_COMPONENT_IMBALANCE.SUB_COMPONENT_ID
			AND BEGIN_DATE = v_COMPONENT_IMBALANCE.BEGIN_DATE;
		v_END_DATE := v_COMPONENT_IMBALANCE.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_COMPONENT_IMBALANCE;

END PUT_COMPONENT_IMBALANCE;
---------------------------------------------------------------------------------------------------
PROCEDURE COMPONENT_IMBALANCE_BANDS
	(
	p_COMPONENT_ID IN NUMBER,
	p_BAND_TYPE IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);
    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		  SELECT A.IMBALANCE_ID,
				BAND_TYPE, BAND_NUMBER, BAND_MINIMUM, BAND_THRESHOLD,
				BAND_MULTIPLIER, BAND_CHARGE, A.ENTRY_DATE
		  FROM COMPONENT_IMBALANCE_BAND A, COMPONENT_IMBALANCE B
		  WHERE B.COMPONENT_ID = p_COMPONENT_ID
		  		AND A.IMBALANCE_ID = B.IMBALANCE_ID
		  		AND A.BAND_TYPE = p_BAND_TYPE
		  ORDER BY BEGIN_DATE;

END COMPONENT_IMBALANCE_BANDS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_COMPONENT_IMBALANCE_BAND
	(
	p_IMBALANCE_ID IN NUMBER,
	p_BAND_TYPE IN VARCHAR,
	p_BAND_NUMBER IN NUMBER,
	p_BAND_MINIMUM IN NUMBER,
	p_BAND_THRESHOLD IN NUMBER,
	p_BAND_MULTIPLIER IN NUMBER,
	p_BAND_CHARGE IN NUMBER,
	p_OLD_BAND_TYPE IN VARCHAR,
	p_OLD_BAND_NUMBER IN NUMBER,
	p_STATUS OUT NUMBER
	)AS
	v_COMPONENT_ID NUMBER;
BEGIN
	SELECT COMPONENT_ID INTO v_COMPONENT_ID FROM COMPONENT_IMBALANCE WHERE IMBALANCE_ID = p_IMBALANCE_ID;
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, v_COMPONENT_ID, EC.ED_COMPONENT);
	p_STATUS := GA.SUCCESS;
-- UPDATE THE CURRENT RATE ASSIGNMENT IF ONE EXISTS
		UPDATE COMPONENT_IMBALANCE_BAND SET
			BAND_NUMBER = LTRIM(RTRIM(p_BAND_NUMBER)),
			BAND_TYPE = p_BAND_TYPE,
			BAND_MINIMUM = p_BAND_MINIMUM,
			BAND_THRESHOLD = p_BAND_THRESHOLD,
			BAND_MULTIPLIER = p_BAND_MULTIPLIER,
			BAND_CHARGE = p_BAND_CHARGE,
			ENTRY_DATE = SYSDATE
		WHERE IMBALANCE_ID = p_IMBALANCE_ID
			AND UPPER(BAND_TYPE) = UPPER(LTRIM(RTRIM(p_OLD_BAND_TYPE)))
			AND BAND_NUMBER = p_OLD_BAND_NUMBER;
	-- THIS IS A NEW BAND_NUMBER AND BAND_ID COMBINATION.  INSERT A NEW RECORD.
	   IF SQL%NOTFOUND THEN
		INSERT INTO COMPONENT_IMBALANCE_BAND
			(
			IMBALANCE_ID,
			BAND_TYPE,
			BAND_NUMBER,
			BAND_MINIMUM,
			BAND_THRESHOLD,
			BAND_MULTIPLIER,
			BAND_CHARGE,
			ENTRY_DATE
			)
		VALUES
			(
			p_IMBALANCE_ID,
			LTRIM(RTRIM(p_BAND_TYPE)),
			p_BAND_NUMBER,
			p_BAND_MINIMUM,
			p_BAND_THRESHOLD,
			p_BAND_MULTIPLIER,
			p_BAND_CHARGE,
			SYSDATE
			);
	   END IF;

END PUT_COMPONENT_IMBALANCE_BAND;
---------------------------------------------------------------------------------------------------
PROCEDURE COMPONENT_COINCIDENT_PK_RATES
	(
	p_COMPONENT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);
    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		  SELECT A.COMPONENT_ID, A.SUB_COMPONENT_TYPE, A.SUB_COMPONENT_ID,
			  	A.BEGIN_DATE, A.END_DATE, A.A_SYSTEM_LOAD_ID, A.B_SYSTEM_LOAD_ID,
				A.RATE, A.ENTRY_DATE
		  FROM COMPONENT_COINCIDENT_PEAK A
		  WHERE COMPONENT_ID = p_COMPONENT_ID
		  ORDER BY BEGIN_DATE;

END COMPONENT_COINCIDENT_PK_RATES;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_COMPONENT_COINCIDENT_PEAK
	(
	p_COMPONENT_ID IN NUMBER,
    p_SUB_COMPONENT_TYPE IN VARCHAR2,
    p_SUB_COMPONENT_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_A_SYSTEM_LOAD_ID IN NUMBER,
	p_B_SYSTEM_LOAD_ID IN NUMBER,
	p_RATE IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	)AS
CURSOR c_COMPONENT_COINCIDENT_PEAK IS
	SELECT *
	FROM COMPONENT_COINCIDENT_PEAK
	WHERE COMPONENT_ID = p_COMPONENT_ID
	ORDER BY BEGIN_DATE DESC;

v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
v_COMPONENT_COINCIDENT_PEAK COMPONENT_COINCIDENT_PEAK%ROWTYPE;
v_INITIAL BOOLEAN;
v_END_DATE DATE;
BEGIN
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);
	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

	v_KEY_NEW('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_COMPONENT_ID);
    v_KEY_OLD('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_COMPONENT_ID);
	v_KEY_NEW('SUB_COMPONENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_SUB_COMPONENT_TYPE);
	v_KEY_OLD('SUB_COMPONENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_SUB_COMPONENT_TYPE);
	v_KEY_NEW('SUB_COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SUB_COMPONENT_ID);
	v_KEY_OLD('SUB_COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SUB_COMPONENT_ID);

    v_DATA('A_SYSTEM_LOAD_ID') := UT.GET_LITERAL_FOR_NUMBER(p_A_SYSTEM_LOAD_ID);
	v_DATA('B_SYSTEM_LOAD_ID') := UT.GET_LITERAL_FOR_NUMBER(p_B_SYSTEM_LOAD_ID);
	v_DATA('RATE') := UT.GET_LITERAL_FOR_NUMBER(p_RATE);

	UT.PUT_TEMPORAL_DATA_UI('COMPONENT_COINCIDENT_PEAK',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

	OPEN c_COMPONENT_COINCIDENT_PEAK;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_COMPONENT_COINCIDENT_PEAK INTO v_COMPONENT_COINCIDENT_PEAK;
		EXIT WHEN c_COMPONENT_COINCIDENT_PEAK%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_COMPONENT_COINCIDENT_PEAK.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE COMPONENT_COINCIDENT_PEAK
		SET END_DATE = GREATEST(v_END_DATE, v_COMPONENT_COINCIDENT_PEAK.BEGIN_DATE)
		WHERE COMPONENT_ID = v_COMPONENT_COINCIDENT_PEAK.COMPONENT_ID
        	AND SUB_COMPONENT_TYPE = v_COMPONENT_COINCIDENT_PEAK.SUB_COMPONENT_TYPE
            AND SUB_COMPONENT_ID = v_COMPONENT_COINCIDENT_PEAK.SUB_COMPONENT_ID
			AND BEGIN_DATE = v_COMPONENT_COINCIDENT_PEAK.BEGIN_DATE;
		v_END_DATE := v_COMPONENT_COINCIDENT_PEAK.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_COMPONENT_COINCIDENT_PEAK;

END PUT_COMPONENT_COINCIDENT_PEAK;
---------------------------------------------------------------------------------------------------
PROCEDURE ENTITY_ATTRIBUTE_VALUES
	(
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT A.ATTRIBUTE_ID,
				A.ENTITY_DOMAIN_ID,
				OWNER_ENTITY_ID,
				ENTITY_NAME_FROM_IDS(A.ENTITY_DOMAIN_ID,OWNER_ENTITY_ID) "OWNER_ENTITY_NAME",
				B.BEGIN_DATE,
				B.END_DATE,
				ATTRIBUTE_VAL,
				B.ENTRY_DATE
		FROM ENTITY_ATTRIBUTE A, TEMPORAL_ENTITY_ATTRIBUTE B
		WHERE B.ENTITY_DOMAIN_ID = A.ENTITY_DOMAIN_ID
			AND B.ATTRIBUTE_ID = A.ATTRIBUTE_ID
		ORDER BY OWNER_ENTITY_NAME, BEGIN_DATE;
END ENTITY_ATTRIBUTE_VALUES;
---------------------------------------------------------------------------------------------------
PROCEDURE COMPONENT_ENTITY_ATTR_RATES
	(
	p_COMPONENT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);
    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		  SELECT A.COMPONENT_ID, A.SUB_COMPONENT_TYPE, A.SUB_COMPONENT_ID,
			  	A.ENTITY_DOMAIN_ID, B.ENTITY_DOMAIN_NAME,
				A.ENTITY_ATTRIBUTE_ID "ATTRIBUTE_ID", C.ATTRIBUTE_NAME,
				A.BEGIN_DATE, A.END_DATE, A.ENTRY_DATE
		  FROM COMPONENT_ENTITY_ATTRIBUTE A, ENTITY_DOMAIN B, ENTITY_ATTRIBUTE C
		  WHERE A.COMPONENT_ID = p_COMPONENT_ID
			  	AND B.ENTITY_DOMAIN_ID = A.ENTITY_DOMAIN_ID
				AND C.ENTITY_DOMAIN_ID = A.ENTITY_DOMAIN_ID
				AND C.ATTRIBUTE_ID = A.ENTITY_ATTRIBUTE_ID
		  ORDER BY ENTITY_DOMAIN_NAME, ATTRIBUTE_NAME, BEGIN_DATE;

END COMPONENT_ENTITY_ATTR_RATES;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_COMPONENT_ENTITY_ATTRIBUTE
	(
	p_COMPONENT_ID IN NUMBER,
    p_SUB_COMPONENT_TYPE IN VARCHAR2,
    p_SUB_COMPONENT_ID IN NUMBER,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ATTRIBUTE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_ENTITY_DOMAIN_ID IN NUMBER,
	p_OLD_ATTRIBUTE_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	)AS
CURSOR c_COMPONENT_ENTITY_ATTRIBUTE IS
	SELECT *
	FROM COMPONENT_ENTITY_ATTRIBUTE
	WHERE COMPONENT_ID = p_COMPONENT_ID
    	AND SUB_COMPONENT_TYPE = p_SUB_COMPONENT_TYPE
        AND SUB_COMPONENT_ID = p_SUB_COMPONENT_ID
	ORDER BY BEGIN_DATE DESC;

v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
v_COMPONENT_ENTITY_ATTRIBUTE COMPONENT_ENTITY_ATTRIBUTE%ROWTYPE;
v_INITIAL BOOLEAN;
v_END_DATE DATE;
BEGIN
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);
	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

	v_KEY_NEW('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_COMPONENT_ID);
    v_KEY_OLD('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_COMPONENT_ID);
	v_KEY_NEW('SUB_COMPONENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_SUB_COMPONENT_TYPE);
	v_KEY_OLD('SUB_COMPONENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_SUB_COMPONENT_TYPE);
	v_KEY_NEW('SUB_COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SUB_COMPONENT_ID);
	v_KEY_OLD('SUB_COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SUB_COMPONENT_ID);
	v_KEY_NEW('ENTITY_DOMAIN_ID') := UT.GET_LITERAL_FOR_NUMBER(p_ENTITY_DOMAIN_ID);
	v_KEY_OLD('ENTITY_DOMAIN_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_ENTITY_DOMAIN_ID);
	v_KEY_NEW('ENTITY_ATTRIBUTE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_ATTRIBUTE_ID);
	v_KEY_OLD('ENTITY_ATTRIBUTE_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_ATTRIBUTE_ID);

	UT.PUT_TEMPORAL_DATA_UI('COMPONENT_ENTITY_ATTRIBUTE',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,  --Empty in this case - no data columns
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

	OPEN c_COMPONENT_ENTITY_ATTRIBUTE;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_COMPONENT_ENTITY_ATTRIBUTE INTO v_COMPONENT_ENTITY_ATTRIBUTE;
		EXIT WHEN c_COMPONENT_ENTITY_ATTRIBUTE%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_COMPONENT_ENTITY_ATTRIBUTE.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE COMPONENT_ENTITY_ATTRIBUTE
		SET END_DATE = GREATEST(v_END_DATE, v_COMPONENT_ENTITY_ATTRIBUTE.BEGIN_DATE)
		WHERE COMPONENT_ID = v_COMPONENT_ENTITY_ATTRIBUTE.COMPONENT_ID
        	AND SUB_COMPONENT_TYPE = v_COMPONENT_ENTITY_ATTRIBUTE.SUB_COMPONENT_TYPE
            AND SUB_COMPONENT_ID = v_COMPONENT_ENTITY_ATTRIBUTE.SUB_COMPONENT_ID
			AND BEGIN_DATE = v_COMPONENT_ENTITY_ATTRIBUTE.BEGIN_DATE;
		v_END_DATE := v_COMPONENT_ENTITY_ATTRIBUTE.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_COMPONENT_ENTITY_ATTRIBUTE;

END PUT_COMPONENT_ENTITY_ATTRIBUTE;
----------------------------------------------------------------------------------------------------
PROCEDURE COMPONENT_BLOCK_RATES
	(
	p_COMPONENT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);
    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		  SELECT A.COMPONENT_ID, A.SUB_COMPONENT_TYPE, A.SUB_COMPONENT_ID,
			  	A.BEGIN_DATE, A.END_DATE, A.BLOCK_MIN, A.BLOCK_MAX,
				A.RATE, A.CHARGE_MIN, A.ENTRY_DATE
		  FROM COMPONENT_BLOCK_RATE A
		  WHERE COMPONENT_ID = p_COMPONENT_ID
		  ORDER BY BEGIN_DATE, BLOCK_MIN;

END COMPONENT_BLOCK_RATES;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_COMPONENT_BLOCK_RATE
	(
    p_COMPONENT_ID IN NUMBER,
    p_SUB_COMPONENT_TYPE IN VARCHAR2,
    p_SUB_COMPONENT_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
	p_BLOCK_MIN IN NUMBER,
	p_BLOCK_MAX IN NUMBER,
	p_CHARGE_MIN IN NUMBER,
	p_RATE IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_OLD_BLOCK_MIN IN NUMBER,
	p_STATUS OUT NUMBER
	)AS

v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
v_END_DATE DATE;
BEGIN
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);
	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

	v_KEY_NEW('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_COMPONENT_ID);
    v_KEY_OLD('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_COMPONENT_ID);
	v_KEY_NEW('SUB_COMPONENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_SUB_COMPONENT_TYPE);
	v_KEY_OLD('SUB_COMPONENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_SUB_COMPONENT_TYPE);
	v_KEY_NEW('SUB_COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SUB_COMPONENT_ID);
	v_KEY_OLD('SUB_COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SUB_COMPONENT_ID);
	v_KEY_NEW('BLOCK_MIN') := UT.GET_LITERAL_FOR_NUMBER(p_BLOCK_MIN);
	v_KEY_OLD('BLOCK_MIN') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_BLOCK_MIN);

	v_DATA('BLOCK_MAX') := UT.GET_LITERAL_FOR_NUMBER(p_BLOCK_MAX);
	v_DATA('CHARGE_MIN') := UT.GET_LITERAL_FOR_NUMBER(p_CHARGE_MIN);
	v_DATA('RATE') := UT.GET_LITERAL_FOR_NUMBER(p_RATE);

	UT.PUT_TEMPORAL_DATA_UI('COMPONENT_BLOCK_RATE',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

END PUT_COMPONENT_BLOCK_RATE;
----------------------------------------------------------------------------------------------------
PROCEDURE MARKET_PRICE_VALUES
	(
	p_MARKET_PRICE_ID IN NUMBER,
	p_PRICE_CODE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
-- ANSWER THE DATE, BASIS, AND PRICE OF THE APPROPRIATE ENTRIES IN MARKET_PRICE_VALUE
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_INTERVAL VARCHAR(16);
BEGIN
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_MKT_PRICE_SELECT, p_MARKET_PRICE_ID, EC.ED_MARKET_PRICE);
    p_STATUS := GA.SUCCESS;

	SELECT DECODE(UPPER(MARKET_PRICE_INTERVAL),'YEAR','YYYY','QUARTER','Q','MONTH','MM','WEEK','DY','DAY','DD','HOUR', '', '15 MINUTE', 'MI15', '30 MINUTE', 'MI30', '10 MINUTE', 'MI10', '5 MINUTE', 'MI5', '')
	INTO v_INTERVAL FROM MARKET_PRICE WHERE MARKET_PRICE_ID = p_MARKET_PRICE_ID;

	UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	IF SUBSTR(v_INTERVAL,1,2) = 'MI' OR v_INTERVAL IS NULL THEN
	  OPEN p_CURSOR FOR
	    SELECT FROM_CUT_AS_HED(PRICE_DATE, p_TIME_ZONE, v_INTERVAL) AS PRICE_DATE,
	    	 PRICE_BASIS,
	    	 PRICE
		FROM MARKET_PRICE_VALUE
	    WHERE MARKET_PRICE_ID = p_MARKET_PRICE_ID
	    	AND UPPER(PRICE_CODE) = UPPER(p_PRICE_CODE)
			AND PRICE_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND AS_OF_DATE = MARKET_PRICE_AS_OF_DATE(MARKET_PRICE_ID, PRICE_CODE, PRICE_DATE, p_AS_OF_DATE)
		ORDER BY PRICE_DATE;
	ELSE
		OPEN p_CURSOR FOR
			  SELECT FROM_CUT_AS_HED(PRICE_DATE, p_TIME_ZONE, v_INTERVAL, 2) AS PRICE_DATE,
	    	 PRICE_BASIS,
	    	 PRICE
		FROM MARKET_PRICE_VALUE
	    WHERE MARKET_PRICE_ID = p_MARKET_PRICE_ID
	    	AND UPPER(PRICE_CODE) = UPPER(p_PRICE_CODE)
			AND PRICE_DATE BETWEEN TRUNC(p_BEGIN_DATE) AND TRUNC(p_END_DATE)
			AND AS_OF_DATE = MARKET_PRICE_AS_OF_DATE(MARKET_PRICE_ID, PRICE_CODE, PRICE_DATE, p_AS_OF_DATE)
		ORDER BY PRICE_DATE;
	END IF;

END MARKET_PRICE_VALUES;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_MARKET_PRICE_VALUES
	(
	p_MARKET_PRICE_ID IN NUMBER,
	p_PRICE_CODE IN VARCHAR,
	p_DATA_VALUES IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

-- Accept market price values for the specified market price and code.
-- The values are comma delimited terminated by a semi-colon: <date>, <basis>, <price>;

v_STRING_TABLE GA.STRING_TABLE;
v_LINE_TABLE GA.STRING_TABLE;
v_INDEX BINARY_INTEGER;
v_DATE VARCHAR(32);
v_TIME VARCHAR(32);
v_PRICE_BASIS MARKET_PRICE_VALUE.PRICE_BASIS%TYPE;
v_PRICE MARKET_PRICE_VALUE.PRICE%TYPE;

BEGIN

	p_STATUS := GA.SUCCESS;

	UT.TOKENS_FROM_STRING(p_DATA_VALUES,';', v_STRING_TABLE);
 	FOR v_INDEX IN v_STRING_TABLE.FIRST..v_STRING_TABLE.LAST LOOP
		UT.TOKENS_FROM_STRING(v_STRING_TABLE(v_INDEX),',', v_LINE_TABLE);
		v_DATE := LTRIM(RTRIM(v_LINE_TABLE(1)));
		v_TIME := LTRIM(RTRIM(v_LINE_TABLE(2)));
		v_PRICE_BASIS := TO_NUMBER(v_LINE_TABLE(3));
		v_PRICE := TO_NUMBER(v_LINE_TABLE(4));
		PUT_MARKET_PRICE_VALUE(p_MARKET_PRICE_ID, v_DATE, v_TIME, p_PRICE_CODE,
						v_PRICE_BASIS, v_PRICE, p_TIME_ZONE, p_STATUS);
		IF NOT p_STATUS = GA.SUCCESS THEN
			ROLLBACK;
			RETURN;
		END IF;
	END LOOP;

END PUT_MARKET_PRICE_VALUES;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_MARKET_PRICE_VALUE
	(
	p_MARKET_PRICE_ID IN NUMBER,
	p_PRICE_CODE      IN VARCHAR,
	p_DATES           IN DATE_COLLECTION,
	p_PRICES          IN NUMBER_COLLECTION,
	p_PRICE_BASIS     IN NUMBER_COLLECTION,
	p_TIME_ZONE       IN VARCHAR
	) AS
v_PRICE_BASIS NUMBER_COLLECTION;
v_AS_OF_DATE DATE;
BEGIN
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_MKT_PRICE_UPDATE, p_MARKET_PRICE_ID, EC.ED_MARKET_PRICE);

	ASSERT(p_MARKET_PRICE_ID <> 0, 'You cannot set the price values '
		|| 'for the Not Assigned market price.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_PRICE_CODE IS NOT NULL, 'The Price Code must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_DATES IS NOT NULL, 'The Dates list must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_PRICES IS NOT NULL, 'The Prices list must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_DATES.COUNT = p_PRICES.COUNT,
		'The dates and prices lists must be of the same size.', MSGCODES.c_ERR_ARGUMENT);

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('Inside PUT_MARKET_PRICE_VALUE: ');
		LOGS.LOG_DEBUG('MARKET_PRICE_ID = ' || p_MARKET_PRICE_ID);
		LOGS.LOG_DEBUG('PRICE_CODE = ' ||  p_PRICE_CODE);
		LOGS.LOG_DEBUG('DATES = ' || TEXT_UTIL.TO_CHAR_TIME_LIST(p_DATES));
		LOGS.LOG_DEBUG('PRICES = ' || TEXT_UTIL.TO_CHAR_NUMBER_LIST(p_PRICES));
		LOGS.LOG_DEBUG('PRICE_BASIS = ' || TEXT_UTIL.TO_CHAR_NUMBER_LIST(p_PRICE_BASIS));
	END IF;

	IF GA.VERSION_MARKET_PRICE THEN
		v_AS_OF_DATE := SYSDATE;
	ELSE
		v_AS_OF_DATE := CONSTANTS.LOW_DATE;
	END IF;

	-- PRICE_BASIS is optional, default is a list of 0 values
	IF p_PRICE_BASIS IS NULL THEN
		v_PRICE_BASIS := UT.NEW_NUMBER_COLLECTION(p_DATES.COUNT(), 0);
	ELSE
		ASSERT(p_DATES.COUNT = p_PRICES.COUNT AND p_PRICES.COUNT = p_PRICE_BASIS.COUNT,
			'The dates, prices, and price basis lists must be of the same size.', MSGCODES.c_ERR_ARGUMENT);
		v_PRICE_BASIS := p_PRICE_BASIS;
	END IF;

	FORALL v_IDX IN 1..p_PRICES.COUNT()
		MERGE INTO MARKET_PRICE_VALUE TGT
		USING (SELECT p_MARKET_PRICE_ID AS MARKET_PRICE_ID,
					  p_PRICE_CODE AS PRICE_CODE,
					  v_AS_OF_DATE AS AS_OF_DATE,
					  CASE WHEN p_TIME_ZONE IS NULL THEN p_DATES(v_IDX) ELSE TO_CUT(p_DATES(v_IDX), p_TIME_ZONE) END AS PRICE_DATE,
					  p_PRICES(v_IDX) AS PRICE,
					  v_PRICE_BASIS(v_IDX) AS PRICE_BASIS
			   FROM DUAL) SRC
		ON (TGT.MARKET_PRICE_ID = SRC.MARKET_PRICE_ID
		AND TGT.PRICE_CODE = SRC.PRICE_CODE
		AND TGT.PRICE_DATE = SRC.PRICE_DATE
		AND TGT.AS_OF_DATE = SRC.AS_OF_DATE)
		WHEN MATCHED
		THEN
		UPDATE
		SET TGT.PRICE = NVL(SRC.PRICE, 0),
			TGT.PRICE_BASIS = NVL(SRC.PRICE_BASIS, 0)
		WHEN NOT MATCHED
		THEN
		INSERT (TGT.MARKET_PRICE_ID, TGT.PRICE_CODE, TGT.PRICE_DATE, TGT.AS_OF_DATE, TGT.PRICE, TGT.PRICE_BASIS)
		VALUES (SRC.MARKET_PRICE_ID, SRC.PRICE_CODE, SRC.PRICE_DATE, SRC.AS_OF_DATE, NVL(SRC.PRICE, 0), NVL(SRC.PRICE_BASIS, 0));

END PUT_MARKET_PRICE_VALUE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_MARKET_PRICE_VALUES
	(
	p_MARKET_PRICE_IDS IN NUMBER_COLLECTION,
	p_PRICE_CODES      IN STRING_COLLECTION,
	p_DATES        	   IN DATE_COLLECTION_COLLECTION,
	p_PRICES       	   IN NUMBER_COLLECTION_COLLECTION,
	p_PRICE_BASIS  	   IN NUMBER_COLLECTION_COLLECTION,
	p_TIME_ZONES       IN STRING_COLLECTION := NULL
	) AS
BEGIN

	ASSERT(p_MARKET_PRICE_IDS IS NOT NULL, 'The Market Price list must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_PRICE_CODES IS NOT NULL, 'The Price Codes list must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_DATES IS NOT NULL, 'The Dates list must not be null.', MSGCODES.c_ERR_ARGUMENT);
	ASSERT(p_PRICES IS NOT NULL, 'The Prices list must not be null.', MSGCODES.c_ERR_ARGUMENT);

	IF p_PRICE_BASIS IS NOT NULL THEN
		ASSERT(p_MARKET_PRICE_IDS.COUNT = p_PRICE_CODES.COUNT AND p_PRICE_CODES.COUNT = p_DATES.COUNT
			AND p_DATES.COUNT = p_PRICES.COUNT AND p_PRICES.COUNT = p_PRICE_BASIS.COUNT,
			'The market prices, price codes, dates, prices, and price basis lists must be of the same size.', MSGCODES.c_ERR_ARGUMENT);
	ELSE
		ASSERT(p_MARKET_PRICE_IDS.COUNT = p_PRICE_CODES.COUNT AND p_PRICE_CODES.COUNT = p_DATES.COUNT
			AND p_DATES.COUNT = p_PRICES.COUNT,
			'The market prices, price codes, dates, and prices lists must be of the same size.', MSGCODES.c_ERR_ARGUMENT);
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('Inside PUT_MARKET_PRICE_VALUES: ');
		LOGS.LOG_DEBUG('MARKET_PRICE_IDS = ' || TEXT_UTIL.TO_CHAR_NUMBER_LIST(p_MARKET_PRICE_IDS));
		LOGS.LOG_DEBUG('PRICE_CODES = ' ||  TEXT_UTIL.TO_CHAR_STRING_LIST(p_PRICE_CODES));
		LOGS.LOG_DEBUG('DATES = ' || TEXT_UTIL.TO_CHAR_2D_DATE_LIST(p_DATES));
		LOGS.LOG_DEBUG('PRICES = ' || TEXT_UTIL.TO_CHAR_2D_NUMBER_LIST(p_PRICES));
		LOGS.LOG_DEBUG('PRICE_BASIS = ' || TEXT_UTIL.TO_CHAR_2D_NUMBER_LIST(p_PRICE_BASIS));
	END IF;

	FOR v_IDX IN p_MARKET_PRICE_IDS.FIRST..p_MARKET_PRICE_IDS.LAST LOOP
		PUT_MARKET_PRICE_VALUE(p_MARKET_PRICE_IDS(v_IDX),
			p_PRICE_CODES(v_IDX),
			p_DATES(v_IDX),
			p_PRICES(v_IDX),
			CASE WHEN p_PRICE_BASIS IS NULL THEN NULL ELSE p_PRICE_BASIS(v_IDX) END,
			CASE WHEN p_TIME_ZONES IS NULL THEN NULL ELSE p_TIME_ZONES(v_IDX) END);
	END LOOP;

END PUT_MARKET_PRICE_VALUES;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_MARKET_PRICE_VALUE
	(
	p_MARKET_PRICE_ID IN NUMBER,
	p_PRICE_DATE IN VARCHAR,
	p_PRICE_TIME IN VARCHAR,
	p_PRICE_CODE IN CHAR,
	p_PRICE_BASIS IN NUMBER,
	p_PRICE IN NUMBER,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_AS_OF_DATE DATE;
v_PRICE_DATE DATE;

BEGIN
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_MKT_PRICE_UPDATE, p_MARKET_PRICE_ID, EC.ED_MARKET_PRICE);

	ASSERT(p_MARKET_PRICE_ID <> 0, 'You cannot set the price values '
		|| 'for the Not Assigned market price.', MSGCODES.c_ERR_ARGUMENT);

	IF GA.VERSION_MARKET_PRICE THEN
		v_AS_OF_DATE := SYSDATE;
	ELSE
		v_AS_OF_DATE := CONSTANTS.LOW_DATE;
	END IF;

-- Update an existing record, typically a non-versioned entry.
	p_STATUS := GA.SUCCESS;
	IF LTRIM(RTRIM(p_PRICE_TIME)) IS NULL THEN
		v_PRICE_DATE := TRUNC(TO_DATE(p_PRICE_DATE, 'YYYY-MM-DD'));
	ELSE
		v_PRICE_DATE := DATE_TIME_AS_CUT(p_PRICE_DATE,p_PRICE_TIME,p_TIME_ZONE);
	END IF;

	UPDATE MARKET_PRICE_VALUE SET
		PRICE_BASIS = NVL(p_PRICE_BASIS,0),
		PRICE = NVL(p_PRICE,0)
	WHERE MARKET_PRICE_ID = p_MARKET_PRICE_ID
		AND PRICE_CODE = p_PRICE_CODE
		AND PRICE_DATE = v_PRICE_DATE
		AND AS_OF_DATE = v_AS_OF_DATE;

-- If the previous update did not find a match, then insert a new record.
	IF SQL%NOTFOUND THEN
		INSERT INTO MARKET_PRICE_VALUE (
			MARKET_PRICE_ID,
			PRICE_CODE,
			PRICE_DATE,
			AS_OF_DATE,
			PRICE_BASIS,
			PRICE)
		VALUES (
			p_MARKET_PRICE_ID,
			p_PRICE_CODE,
			v_PRICE_DATE,
			v_AS_OF_DATE,
			NVL(p_PRICE_BASIS,0),
			NVL(p_PRICE,0));
	END IF;

END PUT_MARKET_PRICE_VALUE;
----------------------------------------------------------------------------------------------------
PROCEDURE MARKET_PRICE_VALUE_FILL
	(
	p_MARKET_PRICE_ID IN NUMBER,
	p_PRICE_CODE IN CHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_PRICE_BASIS IN NUMBER,
	p_PRICE IN NUMBER,
	p_STATUS OUT NUMBER
	) AS
v_DAYLIGHT_SAVINGS BOOLEAN := FALSE;
v_SPRING_AHEAD_DATE DATE;
v_FALL_BACK_DATE DATE;
v_STD_TIME_ZONE VARCHAR(3);
v_DST_TIME_ZONE VARCHAR(3);
v_TIME_ZONE VARCHAR(3);
v_CURRENT_TIME_ZONE VARCHAR(3);
v_PARAMETER_DATE DATE;
v_DATE DATE;
v_HOUR_OF_DAY NUMBER(2);
v_SEEN_FALL_BACK_HOUR BOOLEAN := FALSE;
v_INTERVAL VARCHAR(16) := 'HOUR';
v_ADVANCE_DATE BOOLEAN;
v_CUT_DATE DATE;
v_IS_HOURLY BOOLEAN;
v_AS_OF_DATE DATE;
	-- Use all the parameters from the main procedure to update the
	-- market price value for the specified date.
	PROCEDURE UPDATE_MARKET_PRICE_VALUE
		(
		p_PRICE_DATE IN DATE
		) AS
	BEGIN

		UPDATE MARKET_PRICE_VALUE
		SET	PRICE_BASIS = p_PRICE_BASIS,
			PRICE = p_PRICE
		WHERE MARKET_PRICE_ID = p_MARKET_PRICE_ID
			AND PRICE_CODE = p_PRICE_CODE
			AND PRICE_DATE = p_PRICE_DATE
			AND AS_OF_DATE = v_AS_OF_DATE;

		IF SQL%NOTFOUND THEN
			INSERT INTO MARKET_PRICE_VALUE
				(
				MARKET_PRICE_ID,
				PRICE_CODE,
				PRICE_DATE,
				AS_OF_DATE,
				PRICE_BASIS,
				PRICE
				)
			VALUES
				(
				p_MARKET_PRICE_ID,
				p_PRICE_CODE,
				p_PRICE_DATE,
				v_AS_OF_DATE,
				p_PRICE_BASIS,
				p_PRICE
				);
		END IF;
	END UPDATE_MARKET_PRICE_VALUE;

BEGIN
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_MKT_PRICE_UPDATE, p_MARKET_PRICE_ID, EC.ED_MARKET_PRICE);

	p_STATUS := GA.SUCCESS;

	IF GA.VERSION_MARKET_PRICE THEN
		v_AS_OF_DATE := SYSDATE;
	ELSE
		v_AS_OF_DATE := CONSTANTS.LOW_DATE;
	END IF;

	SELECT UPPER(NVL(MARKET_PRICE_INTERVAL,'HOUR')) INTO v_INTERVAL FROM MARKET_PRICE WHERE MARKET_PRICE_ID = p_MARKET_PRICE_ID;
	v_TIME_ZONE := LTRIM(RTRIM(p_TIME_ZONE));
	v_CURRENT_TIME_ZONE := v_TIME_ZONE;

	--DETERMINE WHETHER THIS IS HOURLY(SUB-HOURLY) OR DAILY AND ABOVE
	IF INSTR(v_INTERVAL, 'MINUTE') > 0 OR v_INTERVAL = 'HOUR' THEN
		v_IS_HOURLY := TRUE;
	ELSE
		v_IS_HOURLY := FALSE;
	END IF;

	IF NOT v_IS_HOURLY THEN
		v_PARAMETER_DATE := TRUNC(p_BEGIN_DATE);
	ELSE
		v_PARAMETER_DATE := ADVANCE_DATE(TRUNC(p_BEGIN_DATE), v_INTERVAL);
	END IF;

	IF SUBSTR(v_TIME_ZONE,2,1) = 'D' AND v_IS_HOURLY THEN
		v_DAYLIGHT_SAVINGS := TRUE;
		v_SPRING_AHEAD_DATE := TRUNC(DST_SPRING_AHEAD_DATE(v_PARAMETER_DATE));
		v_FALL_BACK_DATE := TRUNC(DST_FALL_BACK_DATE(v_PARAMETER_DATE));
		v_STD_TIME_ZONE := STD_TIME_ZONE(v_TIME_ZONE);
		v_DST_TIME_ZONE := DST_TIME_ZONE(v_TIME_ZONE);
	ELSE
		v_DAYLIGHT_SAVINGS := FALSE;
		v_SPRING_AHEAD_DATE := NULL;
		v_FALL_BACK_DATE := NULL;
		v_STD_TIME_ZONE := NULL;
		v_DST_TIME_ZONE := NULL;
	END IF;
-- Loop over the intervals of the specified time period.
	WHILE v_PARAMETER_DATE <= TRUNC(p_END_DATE) + 1 LOOP
-- Determine the proper date and time zone for the parameter date
		v_ADVANCE_DATE := TRUE;
		IF v_DAYLIGHT_SAVINGS THEN
			v_CURRENT_TIME_ZONE := v_STD_TIME_ZONE;
			v_DATE := TRUNC(v_PARAMETER_DATE);
			IF v_DATE BETWEEN v_SPRING_AHEAD_DATE AND v_FALL_BACK_DATE THEN
				v_CURRENT_TIME_ZONE := v_DST_TIME_ZONE;
				IF v_DATE = v_SPRING_AHEAD_DATE THEN
					v_HOUR_OF_DAY := TO_NUMBER(TO_CHAR(v_PARAMETER_DATE,'HH24'));
					IF v_HOUR_OF_DAY < 2 THEN
						v_CURRENT_TIME_ZONE := v_STD_TIME_ZONE;
					ELSE
						IF v_HOUR_OF_DAY = 2 THEN
							v_PARAMETER_DATE := ADVANCE_DATE(v_PARAMETER_DATE, v_INTERVAL);
						END IF;
						v_CURRENT_TIME_ZONE := v_DST_TIME_ZONE;
					END IF;
				ELSIF v_DATE = v_FALL_BACK_DATE THEN
					v_HOUR_OF_DAY := TO_NUMBER(TO_CHAR(v_PARAMETER_DATE,'HH24'));
					v_CURRENT_TIME_ZONE := v_STD_TIME_ZONE;
					IF v_HOUR_OF_DAY <= 2 THEN
						IF v_HOUR_OF_DAY = 2 AND NOT v_SEEN_FALL_BACK_HOUR THEN
								v_ADVANCE_DATE := FALSE;
								v_SEEN_FALL_BACK_HOUR := TRUE;
								v_CURRENT_TIME_ZONE := v_DST_TIME_ZONE;
							END IF;
						IF v_HOUR_OF_DAY < 2 THEN
							v_CURRENT_TIME_ZONE := v_DST_TIME_ZONE;
						END IF;
					END IF;
				END IF;
			END IF;
		END IF;
-- Use CUT date to store to database.
		IF NOT v_IS_HOURLY THEN
			v_CUT_DATE := TRUNC(v_PARAMETER_DATE);
		ELSE
			 v_CUT_DATE := TO_CUT(v_PARAMETER_DATE,v_CURRENT_TIME_ZONE);
		END IF;

-- Update an existing schedule or insert a new schedule.
		UPDATE_MARKET_PRICE_VALUE(v_CUT_DATE);
		IF v_ADVANCE_DATE THEN
		    v_PARAMETER_DATE := ADVANCE_DATE(v_PARAMETER_DATE, v_INTERVAL);
		END IF;
	END LOOP;
END MARKET_PRICE_VALUE_FILL;
----------------------------------------------------------------------------------------------------
PROCEDURE COMPONENT_DATE_RANGE
	(
	p_COMPONENT_ID IN NUMBER,
	p_EARLIEST_BEGIN_DATE OUT DATE,
	p_LATEST_END_DATE OUT DATE
	) AS

-- RETURNS THE EARLIEST AND LATEST DATE ASSOCIATED WITH THIS COMPONENT.

v_EARLIEST_DATE DATE;
v_LATEST_DATE DATE;
v_RATE_STRUCTURE COMPONENT.RATE_STRUCTURE%TYPE;

BEGIN

	v_EARLIEST_DATE := CONSTANTS.LOW_DATE;
	v_LATEST_DATE := CONSTANTS.HIGH_DATE;

	SELECT UPPER(RATE_STRUCTURE)
	INTO v_RATE_STRUCTURE
	FROM COMPONENT
	WHERE COMPONENT_ID = p_COMPONENT_ID;

	IF v_RATE_STRUCTURE = 'FLAT' THEN
		SELECT MIN(BEGIN_DATE), MAX(NVL(END_DATE,CONSTANTS.HIGH_DATE))
		INTO v_EARLIEST_DATE, v_LATEST_DATE
		FROM COMPONENT_FLAT_RATE
		WHERE COMPONENT_ID = p_COMPONENT_ID;
	ELSIF v_RATE_STRUCTURE = 'BLOCK' THEN
		SELECT MIN(BEGIN_DATE), MAX(NVL(END_DATE,CONSTANTS.HIGH_DATE))
		INTO v_EARLIEST_DATE, v_LATEST_DATE
		FROM COMPONENT_BLOCK_RATE
		WHERE COMPONENT_ID = p_COMPONENT_ID;
	ELSIF v_RATE_STRUCTURE = 'TIME OF USE' THEN
		SELECT MIN(BEGIN_DATE), MAX(NVL(END_DATE,CONSTANTS.HIGH_DATE))
		INTO v_EARLIEST_DATE, v_LATEST_DATE
		FROM COMPONENT_TOU_RATE
		WHERE COMPONENT_ID = p_COMPONENT_ID;
	ELSIF v_RATE_STRUCTURE = 'MARKET' THEN
		SELECT MIN(BEGIN_DATE), MAX(NVL(END_DATE,CONSTANTS.HIGH_DATE))
		INTO v_EARLIEST_DATE, v_LATEST_DATE
		FROM COMPONENT_MARKET_PRICE
		WHERE COMPONENT_ID = p_COMPONENT_ID;
	ELSIF v_RATE_STRUCTURE = 'IMBALANCE' THEN
		SELECT MIN(BEGIN_DATE), MAX(NVL(END_DATE,CONSTANTS.HIGH_DATE))
		INTO v_EARLIEST_DATE, v_LATEST_DATE
		FROM COMPONENT_IMBALANCE
		WHERE COMPONENT_ID = p_COMPONENT_ID;
	ELSIF v_RATE_STRUCTURE = 'ENTITY ATTRIBUTE' THEN
		SELECT MIN(BEGIN_DATE), MAX(NVL(END_DATE,CONSTANTS.HIGH_DATE))
		INTO v_EARLIEST_DATE, v_LATEST_DATE
		FROM COMPONENT_ENTITY_ATTRIBUTE
		WHERE COMPONENT_ID = p_COMPONENT_ID;
	ELSIF v_RATE_STRUCTURE = 'COINCIDENT PEAK SHARE' THEN
		SELECT MIN(BEGIN_DATE), MAX(NVL(END_DATE,CONSTANTS.HIGH_DATE))
		INTO v_EARLIEST_DATE, v_LATEST_DATE
		FROM COMPONENT_COINCIDENT_PEAK
		WHERE COMPONENT_ID = p_COMPONENT_ID;
	END IF;

	p_EARLIEST_BEGIN_DATE := v_EARLIEST_DATE;
	p_LATEST_END_DATE := v_LATEST_DATE;

	EXCEPTION
		WHEN OTHERS THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			p_EARLIEST_BEGIN_DATE := CONSTANTS.LOW_DATE;
			p_LATEST_END_DATE := CONSTANTS.HIGH_DATE;

END COMPONENT_DATE_RANGE;
----------------------------------------------------------------------------------------------------
PROCEDURE PRODUCT_COMPONENT_DATE_RANGE
	(
	p_COMPONENT_ID IN NUMBER,
	p_EARLIEST_BEGIN_DATE OUT DATE,
	p_LATEST_END_DATE OUT DATE
	) AS

-- RETURNS THE EARLIEST AND LATEST DATE ASSOCIATED WITH THIS COMPONENT.
BEGIN

	SELECT MIN(BEGIN_DATE), MAX(NVL(END_DATE,CONSTANTS.HIGH_DATE))
	INTO p_EARLIEST_BEGIN_DATE, p_LATEST_END_DATE
	FROM PRODUCT_COMPONENT
	WHERE COMPONENT_ID = p_COMPONENT_ID;

	EXCEPTION
		WHEN OTHERS THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			p_EARLIEST_BEGIN_DATE := NULL;
			p_LATEST_END_DATE := NULL;

END PRODUCT_COMPONENT_DATE_RANGE;
----------------------------------------------------------------------------------------------------
PROCEDURE PRODUCT_COMPONENT_WARNING
	(
	p_PRODUCT_ID IN NUMBER,
	p_ASSOCIATIONS IN VARCHAR,
	p_DATE_FORMAT IN VARCHAR,
	p_WARNING_TYPE IN VARCHAR,
	p_WARNING OUT VARCHAR
	) AS

v_RECORDS GA.STRING_TABLE;
v_RECORD GA.STRING_TABLE;
v_COMPONENT_ID NUMBER(9);
v_EARLIEST_COMPONENT_DATE DATE := CONSTANTS.LOW_DATE;
v_LATEST_COMPONENT_DATE DATE := CONSTANTS.HIGH_DATE;
v_EARLIEST_PRODUCT_DATE DATE := NULL;
v_LATEST_PRODUCT_DATE DATE := NULL;
v_INITIAL BOOLEAN;
BEGIN
--RETURNS A WARNING TO THE USER IF THE PRODUCT-COMPONENT ASSOCIATIONS ARE INAPPROPRIATE.
--WARNING TYPE IS EITHER 'Product' OR 'Component' DEPENDING ON FROM WHAT DIRECTION WE ARE SAVING.
	p_WARNING := '';
	UT.TOKENS_FROM_STRING(p_ASSOCIATIONS,';', v_RECORDS);

	IF SUBSTR(p_WARNING_TYPE,1,1) = 'P' THEN --SAVING A PRODUCT.
		FOR v_INDEX IN v_RECORDS.FIRST..v_RECORDS.LAST LOOP
		   UT.TOKENS_FROM_STRING(v_RECORDS(v_INDEX),',', v_RECORD);
	 		v_COMPONENT_ID := TO_NUMBER(LTRIM(RTRIM(v_RECORD(1))));
	 		v_EARLIEST_PRODUCT_DATE := TO_DATE(v_RECORD(2), p_DATE_FORMAT);
	 		v_LATEST_PRODUCT_DATE := TO_DATE(v_RECORD(3), p_DATE_FORMAT);

			COMPONENT_DATE_RANGE(v_COMPONENT_ID,v_EARLIEST_COMPONENT_DATE,v_LATEST_COMPONENT_DATE);
			IF v_EARLIEST_COMPONENT_DATE > NVL(v_EARLIEST_PRODUCT_DATE,CONSTANTS.HIGH_DATE) THEN
				p_WARNING := 'A Product-Component association begins before meaningful data exists in the Component.';
				RETURN;
			ELSIF v_LATEST_COMPONENT_DATE < NVL(v_LATEST_PRODUCT_DATE,CONSTANTS.LOW_DATE) THEN
				p_WARNING := 'A Product-Component association ends later than associated data in the Component.';
				RETURN;
			END IF;
		END LOOP;

	ELSE -- SAVING A COMPONENT
		v_INITIAL := TRUE;
		FOR v_INDEX IN v_RECORDS.FIRST..v_RECORDS.LAST LOOP
		   UT.TOKENS_FROM_STRING(v_RECORDS(v_INDEX),',', v_RECORD);
			IF v_INITIAL THEN
		 		v_COMPONENT_ID := TO_NUMBER(LTRIM(RTRIM(v_RECORD(1))));
		 		v_EARLIEST_COMPONENT_DATE := TO_DATE(v_RECORD(2), p_DATE_FORMAT);
		 		v_LATEST_COMPONENT_DATE := TO_DATE(v_RECORD(3), p_DATE_FORMAT);
				v_INITIAL := FALSE;
			ELSE
		 		v_EARLIEST_COMPONENT_DATE := LEAST(TO_DATE(v_RECORD(2), p_DATE_FORMAT),v_EARLIEST_COMPONENT_DATE);
		 		v_LATEST_COMPONENT_DATE := GREATEST(TO_DATE(v_RECORD(3), p_DATE_FORMAT),v_LATEST_COMPONENT_DATE);
			END IF;
		END LOOP;

		PRODUCT_COMPONENT_DATE_RANGE(v_COMPONENT_ID,v_EARLIEST_PRODUCT_DATE,v_LATEST_PRODUCT_DATE);
		IF v_EARLIEST_COMPONENT_DATE > NVL(v_EARLIEST_PRODUCT_DATE,CONSTANTS.HIGH_DATE) THEN
			p_WARNING := 'A Product-Component association begins before meaningful data exists in the Component.';
			RETURN;
		ELSIF v_LATEST_COMPONENT_DATE < NVL(v_LATEST_PRODUCT_DATE,CONSTANTS.LOW_DATE) THEN
			p_WARNING := 'A Product-Component association ends later than associated data in the Component.';
			RETURN;
		END IF;

	END IF;

	EXCEPTION
		WHEN OTHERS THEN
			ERRS.LOG_AND_CONTINUE();
			p_WARNING := SQLERRM;

END PRODUCT_COMPONENT_WARNING;
----------------------------------------------------------------------------------------------------
FUNCTION IS_DATE_OF_FORMAT
	(
	p_DATE IN VARCHAR,
	p_DATE_FORMAT IN VARCHAR
	) RETURN BOOLEAN IS

v_DATE DATE;

BEGIN
	 v_DATE := TO_DATE(p_DATE, p_DATE_FORMAT);
	 RETURN TRUE;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN FALSE;
END IS_DATE_OF_FORMAT;
---------------------------------------------------------------------------------------------------

PROCEDURE GET_CONTRACT_MONTHS
	(
	p_CONTRACT_MONTHS_CHAR IN VARCHAR,
	p_CONTRACT_MONTHS OUT GA.DATE_TABLE
	) AS

v_MONTH_INDEX BINARY_INTEGER := 0;
v_CUR_DATE DATE;
v_LAST_DATE DATE;
BEGIN

	--FIRST HANDLE MMMYY FORMAT
	IF LENGTH(p_CONTRACT_MONTHS_CHAR) = 5 THEN
		IF IS_DATE_OF_FORMAT(p_CONTRACT_MONTHS_CHAR, 'MONRR') THEN
			p_CONTRACT_MONTHS(0) := TRUNC(TO_DATE(p_CONTRACT_MONTHS_CHAR, 'MONRR'), 'MM');
		END IF;
	--NOW MMM-MMMYY FORMAT
	ELSIF LENGTH(p_CONTRACT_MONTHS_CHAR) = 9 THEN
		v_CUR_DATE := TO_DATE(SUBSTR(p_CONTRACT_MONTHS_CHAR,1,3) || SUBSTR(p_CONTRACT_MONTHS_CHAR,8,2), 'MONRR');
		v_LAST_DATE := TO_DATE(SUBSTR(p_CONTRACT_MONTHS_CHAR,5,5), 'MONRR');
		WHILE v_CUR_DATE <= v_LAST_DATE LOOP
			p_CONTRACT_MONTHS(v_MONTH_INDEX) := v_CUR_DATE;
			v_CUR_DATE := ADVANCE_DATE(v_CUR_DATE, 'MONTH');
			v_MONTH_INDEX := v_MONTH_INDEX + 1;
		END LOOP;
	--NOW #QYY FORMAT
-- 	ELSIF LENGTH(p_CONTRACT_MONTHS_CHAR) = 4 THEN
-- 		v_CUR_DATE := TO_DATE(SUBSTR(p_CONTRACT_MONTHS_CHAR,1,1) || SUBSTR(p_CONTRACT_MONTHS_CHAR,3,2), 'QYY');
-- 		FOR v_MONTH_INDEX IN 1 .. 3 LOOP
-- 			 p_CONTRACT_MONTHS(v_MONTH_INDEX) := v_CUR_DATE;
-- 			 v_CUR_DATE := v_CUR_DATE + 1;
-- 		END LOOP;
	ELSE
		LOGS.LOG_WARN('Unsupported Contract Month format: ' || p_CONTRACT_MONTHS_CHAR || ' Record was skipped.');
	END IF;

END GET_CONTRACT_MONTHS;
---------------------------------------------------------------------------------------------------
PROCEDURE IMPORT_MARKET_FORWARD_PRICES
	(
	p_DATE_FORMAT IN VARCHAR,
	p_RECORDS IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_RECORDS GA.STRING_TABLE;
v_RECORD GA.STRING_TABLE;
v_INDEX BINARY_INTEGER;
v_CONTRACT_MONTHS_CHAR VARCHAR(32);
v_MARKET_PRICE_NAME VARCHAR(32);
v_MARKET_PRICE_ID NUMBER(9);
v_CONTRACT_DATE DATE;
v_CONTRACT_TYPE CHAR(1);
v_BID_PRICE MARKET_FORWARD_PRICE.BID_PRICE%TYPE;
v_ASK_PRICE MARKET_FORWARD_PRICE.ASK_PRICE%TYPE;
v_LOW_PRICE MARKET_FORWARD_PRICE.LOW_PRICE%TYPE;
v_HIGH_PRICE MARKET_FORWARD_PRICE.HIGH_PRICE%TYPE;
v_CONTRACT_MONTHS GA.DATE_TABLE;
v_MONTH_INDEX BINARY_INTEGER;
v_DATE_FORMAT VARCHAR(32);
BEGIN

	-- Data Level Security is checked inside the EM procedure before any data is saved.

	p_STATUS := GA.SUCCESS;
	UT.TOKENS_FROM_STRING(p_RECORDS,';', v_RECORDS);
	v_DATE_FORMAT := 'MM/DD/RR';

	IF LOGS.IS_DEBUG_ENABLED() THEN
		LOGS.LOG_DEBUG('<months>,<date>,<name>,<type>,<bid>,<ask>,<low>,<high>');
	END IF;

	FOR v_INDEX IN v_RECORDS.FIRST..v_RECORDS.LAST LOOP
	   UT.TOKENS_FROM_STRING(v_RECORDS(v_INDEX),',', v_RECORD);
 		v_CONTRACT_MONTHS_CHAR := LTRIM(RTRIM(v_RECORD(1)));
 		v_CONTRACT_DATE := TRUNC(TO_DATE(v_RECORD(2), v_DATE_FORMAT));
		v_MARKET_PRICE_NAME := LTRIM(RTRIM(v_RECORD(5)));
		v_CONTRACT_TYPE := UPPER(SUBSTR(LTRIM(RTRIM(v_RECORD(6))),1,1));
		v_BID_PRICE := TO_NUMBER(NVL(v_RECORD(7),0));
		v_ASK_PRICE := TO_NUMBER(NVL(v_RECORD(8),0));
		v_LOW_PRICE := TO_NUMBER(NVL(v_RECORD(9),0));
		v_HIGH_PRICE := TO_NUMBER(NVL(v_RECORD(10),0));

		IF LOGS.IS_DEBUG_ENABLED() THEN
			LOGS.LOG_DEBUG(v_CONTRACT_MONTHS_CHAR || ',' || UT.TRACE_DATE(v_CONTRACT_DATE) || ',' ||
				v_MARKET_PRICE_NAME || ',' || v_CONTRACT_TYPE || ',' || TO_CHAR(v_BID_PRICE) || ',' ||
				TO_CHAR(v_ASK_PRICE) || ',' || TO_CHAR(v_LOW_PRICE) || ',' || TO_CHAR(v_HIGH_PRICE));
		END IF;

		ID.ID_FOR_MARKET_PRICE(v_MARKET_PRICE_NAME,TRUE,v_MARKET_PRICE_ID);
		GET_CONTRACT_MONTHS(v_CONTRACT_MONTHS_CHAR,v_CONTRACT_MONTHS);
		IF v_CONTRACT_MONTHS.COUNT > 0 THEN
			FOR v_MONTH_INDEX IN v_CONTRACT_MONTHS.FIRST .. v_CONTRACT_MONTHS.LAST LOOP
				 EM.PUT_MARKET_FORWARD_PRICE(v_MARKET_PRICE_ID,
				 			v_CONTRACT_MONTHS(v_MONTH_INDEX),
							v_CONTRACT_TYPE,
							v_CONTRACT_DATE,
							v_BID_PRICE,
							v_ASK_PRICE,
							v_LOW_PRICE,
							v_HIGH_PRICE,
				 			v_CONTRACT_MONTHS(v_MONTH_INDEX),
							v_CONTRACT_TYPE,
							v_CONTRACT_DATE);
			END LOOP;
		END IF;


	END LOOP;

END IMPORT_MARKET_FORWARD_PRICES;
---------------------------------------------------------------------------------------------------
PROCEDURE COMPONENT_COMBINATION_RATES
	(
	p_COMPONENT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);
    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		  SELECT A.COMPONENT_ID, A.SUB_COMPONENT_TYPE, A.SUB_COMPONENT_ID,
			  	A.COMBINED_COMPONENT_ID, B.COMPONENT_NAME "COMBINED_COMPONENT_NAME",
				A.COEFFICIENT, A.BEGIN_DATE, A.END_DATE,
				A.ENTRY_DATE
		  FROM COMPONENT_COMBINATION A, COMPONENT B
		  WHERE A.COMPONENT_ID = p_COMPONENT_ID
		  	AND B.COMPONENT_ID = A.COMBINED_COMPONENT_ID
		  ORDER BY COMPONENT_NAME, BEGIN_DATE;

END COMPONENT_COMBINATION_RATES;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_COMPONENT_COMBINATION
	(
    p_COMPONENT_ID IN NUMBER,
    p_SUB_COMPONENT_TYPE IN VARCHAR2,
    p_SUB_COMPONENT_ID IN NUMBER,
	p_COMBINED_COMPONENT_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
	p_COEFFICIENT IN NUMBER,
	p_OLD_COMBINED_COMPONENT_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS

CURSOR c_COMPONENT_COMBINATION IS
	SELECT *
	FROM COMPONENT_COMBINATION
	WHERE COMPONENT_ID = p_COMPONENT_ID
    	AND SUB_COMPONENT_TYPE = p_SUB_COMPONENT_TYPE
        AND SUB_COMPONENT_ID = p_SUB_COMPONENT_ID
		AND COMBINED_COMPONENT_ID = p_COMBINED_COMPONENT_ID
	ORDER BY BEGIN_DATE DESC;

v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
v_COMPONENT_COMBINATION COMPONENT_COMBINATION%ROWTYPE;
v_INITIAL BOOLEAN;
v_END_DATE DATE;
BEGIN
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);
	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

	v_KEY_NEW('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_COMPONENT_ID);
    v_KEY_OLD('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_COMPONENT_ID);
	v_KEY_NEW('SUB_COMPONENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_SUB_COMPONENT_TYPE);
	v_KEY_OLD('SUB_COMPONENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_SUB_COMPONENT_TYPE);
	v_KEY_NEW('SUB_COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SUB_COMPONENT_ID);
	v_KEY_OLD('SUB_COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SUB_COMPONENT_ID);
	v_KEY_NEW('COMBINED_COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_COMBINED_COMPONENT_ID);
	v_KEY_OLD('COMBINED_COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_COMBINED_COMPONENT_ID);

	v_DATA('COEFFICIENT') := UT.GET_LITERAL_FOR_NUMBER(p_COEFFICIENT);

	UT.PUT_TEMPORAL_DATA_UI('COMPONENT_COMBINATION',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

	OPEN c_COMPONENT_COMBINATION;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_COMPONENT_COMBINATION INTO v_COMPONENT_COMBINATION;
		EXIT WHEN c_COMPONENT_COMBINATION%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_COMPONENT_COMBINATION.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE COMPONENT_COMBINATION
		SET END_DATE = GREATEST(v_END_DATE, v_COMPONENT_COMBINATION.BEGIN_DATE)
		WHERE COMPONENT_ID = v_COMPONENT_COMBINATION.COMPONENT_ID
        	AND SUB_COMPONENT_TYPE = v_COMPONENT_COMBINATION.SUB_COMPONENT_TYPE
        	AND SUB_COMPONENT_ID = v_COMPONENT_COMBINATION.SUB_COMPONENT_ID
			AND COMBINED_COMPONENT_ID = v_COMPONENT_COMBINATION.COMBINED_COMPONENT_ID
			AND BEGIN_DATE = v_COMPONENT_COMBINATION.BEGIN_DATE;
		v_END_DATE := v_COMPONENT_COMBINATION.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_COMPONENT_COMBINATION;

END PUT_COMPONENT_COMBINATION;
---------------------------------------------------------------------------------------------------
PROCEDURE COMPONENT_COMPOSITE_RATES
	(
	p_COMPONENT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);
    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		  SELECT A.COMPONENT_ID, A.SUB_COMPONENT_TYPE, A.SUB_COMPONENT_ID,
			  	A.BEGIN_DATE, A.END_DATE, A.BLOCK_MIN, A.BLOCK_MAX,
				A.COMPOSITE_COMPONENT_ID, B.COMPONENT_NAME "COMPOSITE_COMPONENT_NAME",
				A.ENTRY_DATE
		  FROM COMPONENT_COMPOSITE A, COMPONENT B
		  WHERE A.COMPONENT_ID = p_COMPONENT_ID
		  	AND B.COMPONENT_ID = A.COMPOSITE_COMPONENT_ID
		  ORDER BY BEGIN_DATE, BLOCK_MIN;

END COMPONENT_COMPOSITE_RATES;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_COMPONENT_COMPOSITE
	(
    p_COMPONENT_ID IN NUMBER,
    p_SUB_COMPONENT_TYPE IN VARCHAR2,
    p_SUB_COMPONENT_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
	p_BLOCK_MIN IN NUMBER,
	p_BLOCK_MAX IN NUMBER,
	p_COMPOSITE_COMPONENT_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_OLD_BLOCK_MIN IN NUMBER,
	p_STATUS OUT NUMBER
	)AS

v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
v_END_DATE DATE;
BEGIN
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);
	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

	v_KEY_NEW('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_COMPONENT_ID);
    v_KEY_OLD('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_COMPONENT_ID);
	v_KEY_NEW('SUB_COMPONENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_SUB_COMPONENT_TYPE);
	v_KEY_OLD('SUB_COMPONENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_SUB_COMPONENT_TYPE);
	v_KEY_NEW('SUB_COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SUB_COMPONENT_ID);
	v_KEY_OLD('SUB_COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SUB_COMPONENT_ID);
	v_KEY_NEW('BLOCK_MIN') := UT.GET_LITERAL_FOR_NUMBER(p_BLOCK_MIN);
	v_KEY_OLD('BLOCK_MIN') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_BLOCK_MIN);

	v_DATA('BLOCK_MAX') := UT.GET_LITERAL_FOR_NUMBER(p_BLOCK_MAX);
	v_DATA('COMPOSITE_COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_COMPOSITE_COMPONENT_ID);

	UT.PUT_TEMPORAL_DATA_UI('COMPONENT_COMPOSITE',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

END PUT_COMPONENT_COMPOSITE;
----------------------------------------------------------------------------------------------------
PROCEDURE PERIOD_NAMES_FOR_TEMPLATE
	(
	p_TEMPLATE_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
-- ANSWER THE APPROPRIATE ENTRIES FROM SEASON_TEMPLATE TABLE.
BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		  SELECT DISTINCT A.PERIOD_ID, B.PERIOD_NAME
		  FROM SEASON_TEMPLATE A, PERIOD B
		  WHERE A.TEMPLATE_ID = p_TEMPLATE_ID
		  	  AND B.PERIOD_ID = A.PERIOD_ID
		  ORDER BY 2;

END PERIOD_NAMES_FOR_TEMPLATE;
---------------------------------------------------------------------------------------------------
PROCEDURE TREE_NODES_COMPONENT_ACCOUNT
    (
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the account services available
v_DATE DATE := TRUNC(SYSDATE);
BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT E.EDC_NAME AS PARENT_NAME,
			E.EDC_ID AS PARENT_ID,
			B.ACCOUNT_DISPLAY_NAME AS ACCOUNT_NAME,
			B.ACCOUNT_ID,
			C.SERVICE_LOCATION_NAME,
			C.SERVICE_LOCATION_ID,
			D.METER_NAME,
			D.METER_ID,
			A.AGGREGATE_ID,
			DECODE(A.AGGREGATE_ID,0,DECODE(D.METER_ID,0,'B','C'),'A') AS ORDER_BY_TYPE,
			A.ACCOUNT_SERVICE_ID,
			B.MODEL_ID "METER_MODEL_ID"
		FROM
			(SELECT DISTINCT A.ACCOUNT_ID, A.SERVICE_LOCATION_ID, A.METER_ID, A.AGGREGATE_ID, E.EDC_ID, A.ACCOUNT_SERVICE_ID
			FROM ACCOUNT_SERVICE A, ACCOUNT_STATUS B, ACCOUNT_STATUS_NAME STATUS_NAME, METER C, ACCOUNT_EDC E, ACCOUNT_STATUS_NAME MSN
			WHERE STATUS_NAME.STATUS_NAME = B.STATUS_NAME
				AND STATUS_NAME.IS_ACTIVE = 1
				AND v_DATE BETWEEN B.BEGIN_DATE AND NVL(B.END_DATE,CONSTANTS.HIGH_DATE)
				AND B.ACCOUNT_ID = A.ACCOUNT_ID
				AND MSN.STATUS_NAME = C.METER_STATUS
				AND (MSN.IS_ACTIVE = 1 OR C.METER_ID = 0)
				AND C.METER_ID = A.METER_ID
				AND v_DATE BETWEEN E.BEGIN_DATE AND NVL(E.END_DATE,CONSTANTS.HIGH_DATE)
				AND E.ACCOUNT_ID = A.ACCOUNT_ID ) A,
			ACCOUNT B,
			SERVICE_LOCATION C,
			METER D,
			ENERGY_DISTRIBUTION_COMPANY E
		WHERE B.ACCOUNT_ID = A.ACCOUNT_ID
			AND C.SERVICE_LOCATION_ID = A.SERVICE_LOCATION_ID
			AND D.METER_ID(+) = A.METER_ID
			AND E.EDC_ID = A.EDC_ID
		ORDER BY 1,2,10,3,4,5,6,7,8;

END TREE_NODES_COMPONENT_ACCOUNT;
---------------------------------------------------------------------------------------------------
PROCEDURE QUANTITY_TYPES
	(
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the HOLIDAYS for the given SET.

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	   SELECT SERVICE_LOAD_TYPE_NAME,
	    	SERVICE_LOAD_TYPE_CODE
		FROM SERVICE_LOAD_TYPE
		WHERE SERVICE_LOAD_TYPE_RESERVED = 0
		ORDER BY SERVICE_LOAD_TYPE_ORDER;

END QUANTITY_TYPES;
---------------------------------------------------------------------------------------------------
PROCEDURE TREE_NODES_COMPONENT_TAX
   (
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer a recordset containing the TAX AREAS available
BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
        SELECT SYS_CONNECT_BY_PATH(NVL(DISPLAY_NAME,GEOGRAPHY_NAME),'\') "PATH",
        	GEOGRAPHY_ID,
            PARENT_GEOGRAPHY_ID,
            GEOGRAPHY_TYPE,
            NVL(DISPLAY_NAME,GEOGRAPHY_NAME) "NAME"
        FROM GEOGRAPHY
        START WITH PARENT_GEOGRAPHY_ID = 0
        CONNECT BY PRIOR GEOGRAPHY_ID = PARENT_GEOGRAPHY_ID
        ORDER BY 1;

END TREE_NODES_COMPONENT_TAX;
---------------------------------------------------------------------------------------------------
PROCEDURE PRODUCT_COMPONENTS
	(
	p_PRODUCT_ID IN NUMBER,
	p_ENTITY_TYPE IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the HOLIDAYS for the given SET.
v_ENTITY_TYPE VARCHAR(16);
BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;
	 SELECT DECODE(UPPER(p_ENTITY_TYPE),'<ALL>','%',UPPER(p_ENTITY_TYPE)) INTO v_ENTITY_TYPE FROM DUAL;

	 OPEN p_CURSOR FOR
	 	 	SELECT A.COMPONENT_ID,
		 		B.COMPONENT_NAME,
				A.BEGIN_DATE,
				A.END_DATE,
				A.ENTRY_DATE
			FROM PRODUCT_COMPONENT A, COMPONENT B
			WHERE A.COMPONENT_ID = B.COMPONENT_ID
				AND A.PRODUCT_ID = p_PRODUCT_ID
				AND UPPER(B.COMPONENT_ENTITY) LIKE v_ENTITY_TYPE;

END PRODUCT_COMPONENTS;
---------------------------------------------------------------------------------------------------
PROCEDURE SERVICE_POINT_NAMES
	(
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	 OPEN p_CURSOR FOR
	 		SELECT SERVICE_POINT_NAME, SERVICE_POINT_ID
			FROM SERVICE_POINT
			ORDER BY 1;

END SERVICE_POINT_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE COMPONENT_CONVERSION_RATES
	(
	p_COMPONENT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);
    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		  SELECT COMPONENT_ID, SUB_COMPONENT_TYPE, SUB_COMPONENT_ID,
          		A.SCHEDULE_GROUP_ID, A.BEGIN_DATE, A.END_DATE,
		  		COEFF_X3, COEFF_X2, COEFF_X1, CONST_K, RATE, CHARGE_MIN, A.ENTRY_DATE
		  FROM COMPONENT_CONVERSION_RATE A, SCHEDULE_GROUP B
		  WHERE COMPONENT_ID = p_COMPONENT_ID
		  		AND B.SCHEDULE_GROUP_ID = A.SCHEDULE_GROUP_ID
		  ORDER BY SCHEDULE_GROUP_NAME, BEGIN_DATE;

END COMPONENT_CONVERSION_RATES;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_COMPONENT_CONVERSION_RATE
	(
	p_COMPONENT_ID IN NUMBER,
	p_SUB_COMPONENT_TYPE IN VARCHAR2,
	p_SUB_COMPONENT_ID IN NUMBER,
	p_SCHEDULE_GROUP_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_COEFF_X3 IN NUMBER,
	p_COEFF_X2 IN NUMBER,
	p_COEFF_X1 IN NUMBER,
	p_CONST_K IN NUMBER,
	p_CHARGE_MIN IN NUMBER,
	p_RATE IN NUMBER,
	p_OLD_SCHEDULE_GROUP_ID IN NUMBER,
	p_OLD_BEGIN_DATE IN DATE,
	p_STATUS OUT NUMBER
	)AS

CURSOR c_COMPONENT_CONVERSION_RATE IS
	SELECT *
	FROM COMPONENT_CONVERSION_RATE
	WHERE COMPONENT_ID = p_COMPONENT_ID
    	AND SUB_COMPONENT_TYPE = p_SUB_COMPONENT_TYPE
        AND SUB_COMPONENT_ID = p_SUB_COMPONENT_ID
		AND SCHEDULE_GROUP_ID = p_SCHEDULE_GROUP_ID
	ORDER BY BEGIN_DATE DESC;

v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
v_COMPONENT_CONVERSION_RATE COMPONENT_CONVERSION_RATE%ROWTYPE;
v_INITIAL BOOLEAN;
v_END_DATE DATE;
BEGIN
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);
	p_STATUS := GA.SUCCESS;
	v_END_DATE := NULL_DATE(p_END_DATE);

	v_KEY_NEW('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_COMPONENT_ID);
    v_KEY_OLD('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_COMPONENT_ID);
	v_KEY_NEW('SUB_COMPONENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_SUB_COMPONENT_TYPE);
	v_KEY_OLD('SUB_COMPONENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_SUB_COMPONENT_TYPE);
	v_KEY_NEW('SUB_COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SUB_COMPONENT_ID);
	v_KEY_OLD('SUB_COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SUB_COMPONENT_ID);
	v_KEY_NEW('SCHEDULE_GROUP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SCHEDULE_GROUP_ID);
	v_KEY_OLD('SCHEDULE_GROUP_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_SCHEDULE_GROUP_ID);

	v_DATA('COEFF_X3') := UT.GET_LITERAL_FOR_NUMBER(p_COEFF_X3);
	v_DATA('COEFF_X2') := UT.GET_LITERAL_FOR_NUMBER(p_COEFF_X2);
	v_DATA('COEFF_X1') := UT.GET_LITERAL_FOR_NUMBER(p_COEFF_X1);
	v_DATA('CONST_K') := UT.GET_LITERAL_FOR_NUMBER(p_CONST_K);
	v_DATA('CHARGE_MIN') := UT.GET_LITERAL_FOR_NUMBER(p_CHARGE_MIN);
	v_DATA('RATE') := UT.GET_LITERAL_FOR_NUMBER(p_RATE);

	UT.PUT_TEMPORAL_DATA_UI('COMPONENT_CONVERSION_RATE',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

	OPEN c_COMPONENT_CONVERSION_RATE;
	v_INITIAL := TRUE;
	LOOP
		FETCH c_COMPONENT_CONVERSION_RATE INTO v_COMPONENT_CONVERSION_RATE;
		EXIT WHEN c_COMPONENT_CONVERSION_RATE%NOTFOUND;
		IF v_INITIAL THEN
			v_END_DATE := v_COMPONENT_CONVERSION_RATE.END_DATE;
			v_INITIAL := FALSE;
		END IF;
		UPDATE COMPONENT_CONVERSION_RATE
		SET END_DATE = GREATEST(v_END_DATE, v_COMPONENT_CONVERSION_RATE.BEGIN_DATE)
		WHERE COMPONENT_ID = v_COMPONENT_CONVERSION_RATE.COMPONENT_ID
        	AND SUB_COMPONENT_TYPE = v_COMPONENT_CONVERSION_RATE.SUB_COMPONENT_TYPE
        	AND SUB_COMPONENT_ID = v_COMPONENT_CONVERSION_RATE.SUB_COMPONENT_ID
			AND SCHEDULE_GROUP_ID = v_COMPONENT_CONVERSION_RATE.SCHEDULE_GROUP_ID
			AND BEGIN_DATE = v_COMPONENT_CONVERSION_RATE.BEGIN_DATE;
		v_END_DATE := v_COMPONENT_CONVERSION_RATE.BEGIN_DATE - 1;
	END LOOP;
	CLOSE c_COMPONENT_CONVERSION_RATE;

END PUT_COMPONENT_CONVERSION_RATE;
----------------------------------------------------------------------------------------------------
PROCEDURE BASE_COMPONENT_NAMES
	(
	p_COMPONENT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN
    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT COMPONENT_NAME, COMPONENT_ID
		FROM COMPONENT
		WHERE RATE_STRUCTURE IN ('Flat', 'Market', 'Block', 'Tiered')
			AND COMPONENT_ID <> p_COMPONENT_ID
			AND COMPONENT_ID > 0
			AND COMPONENT_ENTITY <> 'Calc.Process' -- exclude calculation components
		ORDER BY 1;

END BASE_COMPONENT_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE BASE_LIMIT_NAMES
	(
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN
    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT LIMIT_NAME, LIMIT_ID
		FROM CONTRACT_LIMIT
		WHERE LIMIT_ID > 0
		ORDER BY 1;

END BASE_LIMIT_NAMES;
---------------------------------------------------------------------------------------------------
PROCEDURE COMPONENT_FORMULA_ITERATORS
    (
    p_COMPONENT_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);

    OPEN p_CURSOR FOR
        SELECT COMPONENT_ID,
            SUB_COMPONENT_TYPE,
            SUB_COMPONENT_ID,
            ITERATOR_NAME,
            BEGIN_DATE,
            END_DATE,
            ITERATOR_QUERY,
            IS_MULTICOLUMN,
            IDENT_COLUMNS,
            IS_INNER_LOOP,
            COMMENTS,
            ROW_NUMBER,
            ENTRY_DATE
        FROM COMPONENT_FORMULA_ITERATOR
        WHERE COMPONENT_ID = p_COMPONENT_ID
        ORDER BY ROW_NUMBER, ITERATOR_NAME,
            BEGIN_DATE;

END COMPONENT_FORMULA_ITERATORS;
---------------------------------------------------------------------------------------------------
PROCEDURE COMPONENT_FORMULA_INPUTS
    (
    p_COMPONENT_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);

    OPEN p_CURSOR FOR
        SELECT COMPONENT_ID,
            SUB_COMPONENT_TYPE,
            SUB_COMPONENT_ID,
            INPUT_NAME,
            BEGIN_DATE,
            END_DATE,
            FUNCTION,
            WHERE_CLAUSE,
            ENTITY_DOMAIN_ID,
			SIGN(ENTITY_ID) * (ABS(ENTITY_ID)*10 + CASE ENTITY_TYPE
													WHEN 'G' THEN c_FML_ID_IS_GROUP
													WHEN 'R' THEN c_FML_ID_IS_REALM
													ELSE c_FML_ID_IS_ENTITY END) as ENTITY_ID,
            TRANSLATE_FORMULA_INPUT_FIELD(WHAT_FIELD, 1) as WHAT_FIELD,
            COMMENTS,
            ROW_NUMBER,
			VIEW_ORDER,
            PERSIST_VALUE,
            ENTRY_DATE
        FROM COMPONENT_FORMULA_INPUT
        WHERE COMPONENT_ID = p_COMPONENT_ID
        ORDER BY ROW_NUMBER, INPUT_NAME,
            BEGIN_DATE;

END COMPONENT_FORMULA_INPUTS;
---------------------------------------------------------------------------------------------------
-- Set Number column is needed only where domain is Transaction, field starts with TRAIT_VAL
-- and indicated trait group is a series
FUNCTION NEEDS_SET_NUMBER
	(
	p_ENTITY_DOMAIN IN ENTITY_DOMAIN.ENTITY_DOMAIN_ID%TYPE,
	p_WHAT_FIELD IN VARCHAR2
	) RETURN NUMBER IS

v_TG_ID TRANSACTION_TRAIT_GROUP.TRAIT_GROUP_ID%TYPE;
v_RESULT NUMBER(1) := 0;
v_IS_SERIES TRANSACTION_TRAIT_GROUP.IS_SERIES%TYPE;
v_TOKENS  GA.STRING_TABLE;

BEGIN
	IF p_ENTITY_DOMAIN = EC.ED_TRANSACTION AND SUBSTR(p_WHAT_FIELD,1,9) = 'TRAIT_VAL' THEN
		UT.TOKENS_FROM_STRING(p_WHAT_FIELD,':',v_TOKENS);
		-- Second token is group ID
		v_TG_ID := v_TOKENS(v_TOKENS.NEXT(v_TOKENS.FIRST));
		-- Determine if the trait is a series
		SELECT IS_SERIES
		INTO v_IS_SERIES
		FROM TRANSACTION_TRAIT_GROUP
		WHERE TRAIT_GROUP_ID = v_TG_ID;

		IF v_IS_SERIES = 1 THEN
			v_RESULT := 1;
		END IF;
	END IF;

  	RETURN v_RESULT;
END NEEDS_SET_NUMBER;
---------------------------------------------------------------------------------------------------
-- Schedule Type column is needed only when domain is Transaction except when the field starts
-- with TRAIT_VAL and the indicated trait is not statement-type specific
FUNCTION NEEDS_SCHEDULE_TYPE
	(
	p_ENTITY_DOMAIN IN ENTITY_DOMAIN.ENTITY_DOMAIN_ID%TYPE,
	p_WHAT_FIELD IN VARCHAR2
	) RETURN NUMBER IS

v_TG_ID TRANSACTION_TRAIT_GROUP.TRAIT_GROUP_ID%TYPE;
v_RESULT NUMBER(1) := 0;
v_IS_STATEMENT_TYPE_SPECIFIC TRANSACTION_TRAIT_GROUP.IS_STATEMENT_TYPE_SPECIFIC%TYPE;
v_TOKENS  GA.STRING_TABLE;

BEGIN
	IF p_ENTITY_DOMAIN = EC.ED_TRANSACTION AND SUBSTR(p_WHAT_FIELD,1,9) <> 'TRAIT_VAL' THEN
		v_RESULT := 1;
	ELSIF p_ENTITY_DOMAIN = EC.ED_TRANSACTION AND SUBSTR(p_WHAT_FIELD,1,9) = 'TRAIT_VAL' THEN
		UT.TOKENS_FROM_STRING(p_WHAT_FIELD,':',v_TOKENS);
		-- Second token is group ID
		v_TG_ID := v_TOKENS(v_TOKENS.NEXT(v_TOKENS.FIRST));
		-- Determine if the trait is a series
		SELECT IS_STATEMENT_TYPE_SPECIFIC
		INTO v_IS_STATEMENT_TYPE_SPECIFIC
		FROM TRANSACTION_TRAIT_GROUP
		WHERE TRAIT_GROUP_ID = v_TG_ID;

		IF v_IS_STATEMENT_TYPE_SPECIFIC = 1 THEN
			v_RESULT := 1;
		END IF;
	END IF;

  	RETURN v_RESULT;
END NEEDS_SCHEDULE_TYPE;
---------------------------------------------------------------------------------------------------
PROCEDURE COMPONENT_FORMULA_INPUT_DETAIL
	(
    p_COMPONENT_ID IN NUMBER,
    p_SUB_COMPONENT_TYPE IN VARCHAR2,
    p_SUB_COMPONENT_ID IN NUMBER,
    p_INPUT_NAME IN VARCHAR2,
    p_BEGIN_DATE IN DATE,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
	OPEN p_CURSOR FOR
		-- Don't return NULL values for columns we want to show - use NVL(val, ' '). That way we can use
		-- hidden when null on all columns.
		SELECT COMPONENT_ID, SUB_COMPONENT_TYPE, SUB_COMPONENT_ID, INPUT_NAME, BEGIN_DATE,
			-- state applies to transactions
			CASE WHEN ENTITY_DOMAIN_ID = EC.ED_TRANSACTION THEN NVL(STATE_FML,' ') ELSE NULL END as STATE_FML,
			-- statement type applies to transactions except when the field starts with TRAIT_VAL and the indicated trait is not statement-type specific
			CASE WHEN NEEDS_SCHEDULE_TYPE(ENTITY_DOMAIN_ID, WHAT_FIELD) = 1 THEN NVL(STATEMENT_TYPE_FML,' ') ELSE NULL END as STATEMENT_TYPE_FML,
			-- set Number applies to transactions only when field starts with TRAIT_VAL and indicated trait group is a series
			CASE WHEN NEEDS_SET_NUMBER(ENTITY_DOMAIN_ID, WHAT_FIELD) = 1 THEN NVL(SET_NUMBER_FML,' ') ELSE NULL END as SET_NUMBER_FML,
			-- code applies to both prices and sub-station entities
			CASE WHEN ENTITY_DOMAIN_ID IN (EC.ED_MARKET_PRICE, EC.ED_SUB_STATION, EC.ED_SUB_STATION_METER, EC.ED_SUB_STATION_METER_POINT) THEN NVL(CODE_FML,' ') ELSE NULL END as CODE_FML,
			-- measurement source only applies to sub-station entities
			CASE WHEN ENTITY_DOMAIN_ID IN (EC.ED_SUB_STATION, EC.ED_SUB_STATION_METER, EC.ED_SUB_STATION_METER_POINT) THEN NVL(MEASUREMENT_SOURCE_FML,' ') ELSE NULL END as MEASUREMENT_SOURCE_FML
		FROM COMPONENT_FORMULA_INPUT
		WHERE COMPONENT_ID = p_COMPONENT_ID
			AND SUB_COMPONENT_TYPE = p_SUB_COMPONENT_TYPE
			AND SUB_COMPONENT_ID = p_SUB_COMPONENT_ID
			AND INPUT_NAME = p_INPUT_NAME
			AND BEGIN_DATE = p_BEGIN_DATE;
END COMPONENT_FORMULA_INPUT_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_COMPONENT_FML_INPUT_DETAIL
	(
    p_COMPONENT_ID IN NUMBER,
    p_SUB_COMPONENT_TYPE IN VARCHAR2,
    p_SUB_COMPONENT_ID IN NUMBER,
    p_INPUT_NAME IN VARCHAR2,
    p_BEGIN_DATE IN DATE,
	p_STATE_FML IN VARCHAR2,
	p_STATEMENT_TYPE_FML IN VARCHAR2,
	p_SET_NUMBER_FML IN VARCHAR2,
	p_CODE_FML IN VARCHAR2,
	p_MEASUREMENT_SOURCE_FML IN VARCHAR2
    ) AS
BEGIN

	UPDATE COMPONENT_FORMULA_INPUT
		SET STATE_FML = TRIM(p_STATE_FML),
			STATEMENT_TYPE_FML = TRIM(p_STATEMENT_TYPE_FML),
			SET_NUMBER_FML = TRIM(p_SET_NUMBER_FML),
			CODE_FML = TRIM(p_CODE_FML),
			MEASUREMENT_SOURCE_FML = TRIM(p_MEASUREMENT_SOURCE_FML)
	WHERE COMPONENT_ID = p_COMPONENT_ID
		AND SUB_COMPONENT_TYPE = p_SUB_COMPONENT_TYPE
		AND SUB_COMPONENT_ID = p_SUB_COMPONENT_ID
		AND INPUT_NAME = p_INPUT_NAME
		AND BEGIN_DATE = p_BEGIN_DATE;

END PUT_COMPONENT_FML_INPUT_DETAIL;
---------------------------------------------------------------------------------------------------
FUNCTION GET_FML_INPUT_ENTITY_TYPE
	(
	p_ENTITY_ID IN NUMBER,
	p_ENTITY_DOMAIN_ID IN NUMBER
	) RETURN VARCHAR2 IS
v_RET				ENTITY_DOMAIN.ENTITY_DOMAIN_TABLE_ALIAS%TYPE;
v_TYPE				PLS_INTEGER;
v_REALM_CALC_TYPE 	SYSTEM_REALM.REALM_CALC_TYPE%TYPE;
v_DOMAIN_ID			ENTITY_DOMAIN.ENTITY_DOMAIN_ID%TYPE;
BEGIN
	IF p_ENTITY_ID IS NULL THEN
		RETURN NULL;
	END IF;

	v_TYPE := ABS(MOD(p_ENTITY_ID, 10));

	IF v_TYPE = c_FML_ID_IS_GROUP THEN
		v_DOMAIN_ID := EC.ED_ENTITY_GROUP;
	ELSIF v_TYPE = c_FML_ID_IS_REALM THEN
		BEGIN
			SELECT REALM_CALC_TYPE
			INTO v_REALM_CALC_TYPE
			FROM SYSTEM_REALM
			WHERE REALM_ID = TRUNC(p_ENTITY_ID / 10);

			v_DOMAIN_ID := CASE v_REALM_CALC_TYPE
							WHEN EM.c_REALM_CALC_TYPE_CALC THEN EC.ED_CALC_REALM
							WHEN EM.c_REALM_CALC_TYPE_FML THEN EC.ED_FORMULA_REALM
							ELSE /* EM.c_REALM_CALC_TYPE_SYSTEM */ EC.ED_SYSTEM_REALM
							END;
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
				v_DOMAIN_ID := p_ENTITY_DOMAIN_ID;
		END;
	ELSE -- c_FML_ID_IS_ENTITY
		v_DOMAIN_ID := p_ENTITY_DOMAIN_ID;
	END IF;

	SELECT MAX(ENTITY_DOMAIN_TABLE_ALIAS)
	INTO v_RET
	FROM ENTITY_DOMAIN
	WHERE ENTITY_DOMAIN_ID = v_DOMAIN_ID;

	RETURN v_RET;

END GET_FML_INPUT_ENTITY_TYPE;
---------------------------------------------------------------------------------------------------
PROCEDURE COMPONENT_FORMULA_VARIABLES
    (
    p_COMPONENT_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);

    OPEN p_CURSOR FOR
        SELECT COMPONENT_ID,
            SUB_COMPONENT_TYPE,
            SUB_COMPONENT_ID,
            VARIABLE_NAME,
            BEGIN_DATE,
            END_DATE,
            FORMULA,
            IS_MULTICOLUMN,
            IS_PLSQL,
            COMMENTS,
            ROW_NUMBER,
			VIEW_ORDER,
            PERSIST_VALUE,
            ENTRY_DATE
        FROM COMPONENT_FORMULA_VARIABLE
        WHERE COMPONENT_ID = p_COMPONENT_ID
			AND VARIABLE_NAME NOT IN ('#CHARGE QUANTITY#','#CHARGE RATE#')
        ORDER BY ROW_NUMBER, VARIABLE_NAME,
            BEGIN_DATE;

END COMPONENT_FORMULA_VARIABLES;
---------------------------------------------------------------------------------------------------
PROCEDURE COMPONENT_FML_FIXED_VARIABLES
	(
    p_COMPONENT_ID IN NUMBER,
	p_VARIABLE_NAME IN VARCHAR2,
    p_STATUS OUT NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);
    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		  SELECT COMPONENT_ID, SUB_COMPONENT_TYPE, SUB_COMPONENT_ID,
          		VARIABLE_NAME, FORMULA
		  FROM COMPONENT_FORMULA_VARIABLE
		  WHERE COMPONENT_ID = p_COMPONENT_ID
		  	AND VARIABLE_NAME = p_VARIABLE_NAME;

END COMPONENT_FML_FIXED_VARIABLES;
---------------------------------------------------------------------------------------------------
PROCEDURE COMPONENT_FORMULA_RESULTS
    (
    p_COMPONENT_ID IN NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);

    OPEN p_CURSOR FOR
        SELECT COMPONENT_ID,
            SUB_COMPONENT_TYPE,
            SUB_COMPONENT_ID,
            ENTITY_DOMAIN_ID,
			SIGN(ENTITY_ID) * (ABS(ENTITY_ID)*10 + CASE ENTITY_TYPE WHEN 'R' THEN 1 ELSE 0 END) as ENTITY_ID,
            ENTITY_ID,
            BEGIN_DATE,
            END_DATE,
            TRANSLATE_FORMULA_INPUT_FIELD(WHAT_FIELD, 1) as WHAT_FIELD,
            FORMULA,
            COMMENTS,
            ENTRY_DATE
        FROM COMPONENT_FORMULA_RESULT C
        WHERE COMPONENT_ID = p_COMPONENT_ID
        ORDER BY BEGIN_DATE,
			ENTITY_NAME_FROM_IDS(EC.ED_ENTITY_DOMAIN, ENTITY_DOMAIN_ID),
			ENTITY_NAME_FROM_IDS(CASE ENTITY_TYPE WHEN 'R' THEN EC.ED_SYSTEM_REALM ELSE ENTITY_DOMAIN_ID END, C.ENTITY_ID),
			WHAT_FIELD;

END COMPONENT_FORMULA_RESULTS;
---------------------------------------------------------------------------------------------------
PROCEDURE COMPONENT_FML_RESULT_DETAIL
	(
    p_COMPONENT_ID IN NUMBER,
    p_SUB_COMPONENT_TYPE IN VARCHAR2,
    p_SUB_COMPONENT_ID IN NUMBER,
	p_ENTITY_DOMAIN_ID IN VARCHAR2,
	p_ENTITY_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
	p_WHAT_FIELD IN VARCHAR2,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
v_ENTITY_ID		COMPONENT_FORMULA_RESULT.ENTITY_ID%TYPE;
v_ENTITY_TYPE	COMPONENT_FORMULA_RESULT.ENTITY_TYPE%TYPE;
v_WHAT_FIELD	COMPONENT_FORMULA_RESULT.WHAT_FIELD%TYPE;
BEGIN
	v_ENTITY_ID := TRUNC(p_ENTITY_ID / 10);
	v_ENTITY_TYPE := CASE ABS(MOD(p_ENTITY_ID, 10))
					 WHEN c_FML_ID_IS_REALM THEN 'R'
					 ELSE /* c_FML_ID_IS_ENTITY */ 'E'
					 END;
	v_WHAT_FIELD := TRANSLATE_FORMULA_INPUT_FIELD(p_WHAT_FIELD,0);

	OPEN p_CURSOR FOR
		-- Don't return NULL values for columns we want to show - use NVL(val, ' '). That way we can use
		-- hidden when null on all columns.
		SELECT COMPONENT_ID, SUB_COMPONENT_TYPE, SUB_COMPONENT_ID,
			ENTITY_DOMAIN_ID, ENTITY_TYPE, ENTITY_ID, BEGIN_DATE, WHAT_FIELD,
			-- state applies to transactions
			CASE WHEN ENTITY_DOMAIN_ID = EC.ED_TRANSACTION THEN NVL(STATE_FML,' ') ELSE NULL END as STATE_FML,
			-- statement type applies to transactions except when the field starts with TRAIT_VAL and the indicated trait is not statement-type specific
			CASE WHEN NEEDS_SCHEDULE_TYPE(ENTITY_DOMAIN_ID, WHAT_FIELD) = 1 THEN NVL(STATEMENT_TYPE_FML,' ') ELSE NULL END as STATEMENT_TYPE_FML,
			-- set Number applies to transactions only when field starts with TRAIT_VAL and indicated trait group is a series
			CASE WHEN NEEDS_SET_NUMBER(ENTITY_DOMAIN_ID, WHAT_FIELD) = 1 THEN NVL(SET_NUMBER_FML,' ') ELSE NULL END as SET_NUMBER_FML,
			-- code applies to both prices and sub-station entities
			CASE WHEN ENTITY_DOMAIN_ID IN (EC.ED_MARKET_PRICE, EC.ED_SUB_STATION, EC.ED_SUB_STATION_METER, EC.ED_SUB_STATION_METER_POINT) THEN NVL(CODE_FML,' ') ELSE NULL END as CODE_FML,
			-- measurement source only applies to sub-station entities
			CASE WHEN ENTITY_DOMAIN_ID IN (EC.ED_SUB_STATION, EC.ED_SUB_STATION_METER, EC.ED_SUB_STATION_METER_POINT) THEN NVL(MEASUREMENT_SOURCE_FML,' ') ELSE NULL END as MEASUREMENT_SOURCE_FML
		FROM COMPONENT_FORMULA_RESULT
		WHERE COMPONENT_ID = p_COMPONENT_ID
			AND SUB_COMPONENT_TYPE = p_SUB_COMPONENT_TYPE
			AND SUB_COMPONENT_ID = p_SUB_COMPONENT_ID
			AND ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID
			AND ENTITY_TYPE = v_ENTITY_TYPE
			AND ENTITY_ID = v_ENTITY_ID
			AND BEGIN_DATE = p_BEGIN_DATE
			AND WHAT_FIELD = v_WHAT_FIELD;

END COMPONENT_FML_RESULT_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_COMPONENT_FML_RESLT_DETAIL
	(
    p_COMPONENT_ID IN NUMBER,
    p_SUB_COMPONENT_TYPE IN VARCHAR2,
    p_SUB_COMPONENT_ID IN NUMBER,
	p_ENTITY_DOMAIN_ID IN VARCHAR2,
	p_ENTITY_TYPE IN VARCHAR2,
	p_ENTITY_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
	p_WHAT_FIELD IN VARCHAR2,
	p_STATE_FML IN VARCHAR2,
	p_STATEMENT_TYPE_FML IN VARCHAR2,
	p_SET_NUMBER_FML IN VARCHAR2,
	p_CODE_FML IN VARCHAR2,
	p_MEASUREMENT_SOURCE_FML IN VARCHAR2
    ) AS
BEGIN

	UPDATE COMPONENT_FORMULA_RESULT
		SET STATE_FML = TRIM(p_STATE_FML),
			STATEMENT_TYPE_FML = TRIM(p_STATEMENT_TYPE_FML),
			SET_NUMBER_FML = TRIM(p_SET_NUMBER_FML),
			CODE_FML = TRIM(p_CODE_FML),
			MEASUREMENT_SOURCE_FML = TRIM(p_MEASUREMENT_SOURCE_FML)
	WHERE COMPONENT_ID = p_COMPONENT_ID
		AND SUB_COMPONENT_TYPE = p_SUB_COMPONENT_TYPE
		AND SUB_COMPONENT_ID = p_SUB_COMPONENT_ID
		AND ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID
		AND ENTITY_TYPE = p_ENTITY_TYPE
		AND ENTITY_ID = p_ENTITY_ID
		AND BEGIN_DATE = p_BEGIN_DATE
		AND WHAT_FIELD = p_WHAT_FIELD;

END PUT_COMPONENT_FML_RESLT_DETAIL;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_COMPONENT_FORMULA_ITERATOR
    (
    p_COMPONENT_ID IN NUMBER,
    p_SUB_COMPONENT_TYPE IN VARCHAR2,
    p_SUB_COMPONENT_ID IN NUMBER,
    p_ITERATOR_NAME IN VARCHAR2,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_ITERATOR_QUERY IN VARCHAR2,
    p_IS_MULTICOLUMN IN NUMBER,
    p_IDENT_COLUMNS IN NUMBER,
    p_IS_INNER_LOOP IN NUMBER,
    p_COMMENTS IN VARCHAR2,
    p_ROW_NUMBER IN NUMBER,
    p_OLD_ITERATOR_NAME IN VARCHAR2,
    p_OLD_BEGIN_DATE IN DATE
    ) AS
v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);

    v_KEY_NEW('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_COMPONENT_ID);
    v_KEY_OLD('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_COMPONENT_ID);
    v_KEY_NEW('SUB_COMPONENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_SUB_COMPONENT_TYPE);
    v_KEY_OLD('SUB_COMPONENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_SUB_COMPONENT_TYPE);
    v_KEY_NEW('SUB_COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SUB_COMPONENT_ID);
    v_KEY_OLD('SUB_COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SUB_COMPONENT_ID);
    v_KEY_NEW('ITERATOR_NAME') := UT.GET_LITERAL_FOR_STRING(p_ITERATOR_NAME);
    v_KEY_OLD('ITERATOR_NAME') := UT.GET_LITERAL_FOR_STRING(p_OLD_ITERATOR_NAME);
    v_DATA('ITERATOR_QUERY') := UT.GET_LITERAL_FOR_STRING(p_ITERATOR_QUERY);
    v_DATA('IS_MULTICOLUMN') := UT.GET_LITERAL_FOR_NUMBER(p_IS_MULTICOLUMN);
    v_DATA('IDENT_COLUMNS') := UT.GET_LITERAL_FOR_NUMBER(p_IDENT_COLUMNS);
    v_DATA('IS_INNER_LOOP') := UT.GET_LITERAL_FOR_NUMBER(p_IS_INNER_LOOP);
    v_DATA('COMMENTS') := UT.GET_LITERAL_FOR_STRING(p_COMMENTS);
    v_DATA('ROW_NUMBER') := UT.GET_LITERAL_FOR_NUMBER(p_ROW_NUMBER);

    UT.PUT_TEMPORAL_DATA_UI('COMPONENT_FORMULA_ITERATOR',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

END PUT_COMPONENT_FORMULA_ITERATOR;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_ENTITY_ID_AND_TYPE_FROM_UI
	(
	p_UI_ENTITY_ID IN NUMBER,
	p_INCLUDE_ENTITY_GROUP IN BOOLEAN,
	p_ENTITY_ID OUT NUMBER,
	p_ENTITY_TYPE OUT VARCHAR2
	) AS
BEGIN
	p_ENTITY_ID := TRUNC(p_UI_ENTITY_ID / 10);
	p_ENTITY_TYPE := CASE
		 WHEN ABS(MOD(p_UI_ENTITY_ID, 10)) = c_FML_ID_IS_GROUP AND p_INCLUDE_ENTITY_GROUP THEN 'G'
		 WHEN ABS(MOD(p_UI_ENTITY_ID, 10)) = c_FML_ID_IS_REALM THEN 'R'
		 ELSE /* c_FML_ID_IS_ENTITY */ 'E'
		 END;

END GET_ENTITY_ID_AND_TYPE_FROM_UI;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_COMPONENT_FORMULA_INPUT
    (
    p_COMPONENT_ID IN NUMBER,
    p_SUB_COMPONENT_TYPE IN VARCHAR2,
    p_SUB_COMPONENT_ID IN NUMBER,
    p_INPUT_NAME IN VARCHAR2,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_FUNCTION IN VARCHAR2,
    p_WHERE_CLAUSE IN VARCHAR2,
    p_ENTITY_DOMAIN_ID IN NUMBER,
    p_ENTITY_ID IN NUMBER,
    p_WHAT_FIELD IN VARCHAR2,
    p_COMMENTS IN VARCHAR2,
    p_ROW_NUMBER IN NUMBER,
	p_VIEW_ORDER IN NUMBER,
    p_PERSIST_VALUE IN NUMBER,
    p_OLD_INPUT_NAME IN VARCHAR2,
    p_OLD_BEGIN_DATE IN DATE
    ) AS
v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
v_ENTITY_ID COMPONENT_FORMULA_INPUT.ENTITY_ID%TYPE;
v_ENTITY_TYPE COMPONENT_FORMULA_INPUT.ENTITY_TYPE%TYPE;
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);

	GET_ENTITY_ID_AND_TYPE_FROM_UI(p_ENTITY_ID, TRUE, v_ENTITY_ID, v_ENTITY_TYPE);

    v_KEY_NEW('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_COMPONENT_ID);
    v_KEY_OLD('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_COMPONENT_ID);
    v_KEY_NEW('SUB_COMPONENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_SUB_COMPONENT_TYPE);
    v_KEY_OLD('SUB_COMPONENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_SUB_COMPONENT_TYPE);
    v_KEY_NEW('SUB_COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SUB_COMPONENT_ID);
    v_KEY_OLD('SUB_COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SUB_COMPONENT_ID);
    v_KEY_NEW('INPUT_NAME') := UT.GET_LITERAL_FOR_STRING(p_INPUT_NAME);
    v_KEY_OLD('INPUT_NAME') := UT.GET_LITERAL_FOR_STRING(p_OLD_INPUT_NAME);
    v_DATA('FUNCTION') := UT.GET_LITERAL_FOR_STRING(p_FUNCTION);
    v_DATA('WHERE_CLAUSE') := UT.GET_LITERAL_FOR_STRING(p_WHERE_CLAUSE);
    v_DATA('ENTITY_DOMAIN_ID') := UT.GET_LITERAL_FOR_NUMBER(p_ENTITY_DOMAIN_ID);
    v_DATA('ENTITY_TYPE') := UT.GET_LITERAL_FOR_STRING(v_ENTITY_TYPE);
    v_DATA('ENTITY_ID') := UT.GET_LITERAL_FOR_NUMBER(v_ENTITY_ID);
    v_DATA('WHAT_FIELD') := UT.GET_LITERAL_FOR_STRING(TRANSLATE_FORMULA_INPUT_FIELD(p_WHAT_FIELD,0));
    v_DATA('COMMENTS') := UT.GET_LITERAL_FOR_STRING(p_COMMENTS);
    v_DATA('ROW_NUMBER') := UT.GET_LITERAL_FOR_NUMBER(p_ROW_NUMBER);
	v_DATA('VIEW_ORDER') := UT.GET_LITERAL_FOR_NUMBER(p_VIEW_ORDER);
    v_DATA('PERSIST_VALUE') := UT.GET_LITERAL_FOR_NUMBER(p_PERSIST_VALUE);

    UT.PUT_TEMPORAL_DATA_UI('COMPONENT_FORMULA_INPUT',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

END PUT_COMPONENT_FORMULA_INPUT;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_COMPONENT_FORMULA_VARIABLE
    (
    p_COMPONENT_ID IN NUMBER,
    p_SUB_COMPONENT_TYPE IN VARCHAR2,
    p_SUB_COMPONENT_ID IN NUMBER,
    p_VARIABLE_NAME IN VARCHAR2,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_FORMULA IN VARCHAR2,
    p_IS_MULTICOLUMN IN NUMBER,
    p_IS_PLSQL IN NUMBER,
    p_COMMENTS IN VARCHAR2,
    p_ROW_NUMBER IN NUMBER,
	p_VIEW_ORDER IN NUMBER,
    p_PERSIST_VALUE IN NUMBER,
    p_OLD_VARIABLE_NAME IN VARCHAR2,
    p_OLD_BEGIN_DATE IN DATE
    ) AS
v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);

    v_KEY_NEW('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_COMPONENT_ID);
    v_KEY_OLD('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_COMPONENT_ID);
    v_KEY_NEW('SUB_COMPONENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_SUB_COMPONENT_TYPE);
    v_KEY_OLD('SUB_COMPONENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_SUB_COMPONENT_TYPE);
    v_KEY_NEW('SUB_COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SUB_COMPONENT_ID);
    v_KEY_OLD('SUB_COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SUB_COMPONENT_ID);
    v_KEY_NEW('VARIABLE_NAME') := UT.GET_LITERAL_FOR_STRING(p_VARIABLE_NAME);
    v_KEY_OLD('VARIABLE_NAME') := UT.GET_LITERAL_FOR_STRING(p_OLD_VARIABLE_NAME);
    v_DATA('FORMULA') := UT.GET_LITERAL_FOR_STRING(p_FORMULA);
    v_DATA('IS_MULTICOLUMN') := UT.GET_LITERAL_FOR_NUMBER(p_IS_MULTICOLUMN);
    v_DATA('IS_PLSQL') := UT.GET_LITERAL_FOR_NUMBER(p_IS_PLSQL);
    v_DATA('COMMENTS') := UT.GET_LITERAL_FOR_STRING(p_COMMENTS);
    v_DATA('ROW_NUMBER') := UT.GET_LITERAL_FOR_NUMBER(p_ROW_NUMBER);
	v_DATA('VIEW_ORDER') := UT.GET_LITERAL_FOR_NUMBER(p_VIEW_ORDER);
    v_DATA('PERSIST_VALUE') := UT.GET_LITERAL_FOR_NUMBER(p_PERSIST_VALUE);

    UT.PUT_TEMPORAL_DATA_UI('COMPONENT_FORMULA_VARIABLE',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

END PUT_COMPONENT_FORMULA_VARIABLE;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_COMPONENT_FML_FIXED_VAR
	(
    p_COMPONENT_ID IN NUMBER,
    p_SUB_COMPONENT_TYPE IN VARCHAR2,
    p_SUB_COMPONENT_ID IN NUMBER,
    p_VARIABLE_NAME IN VARCHAR,
    p_FORMULA IN VARCHAR,
    p_STATUS OUT NUMBER
    ) AS
BEGIN
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);
	p_STATUS := GA.SUCCESS;

-- UPDATE THE CURRENT RATE ASSIGNMENT IF ONE EXISTS
	UPDATE COMPONENT_FORMULA_VARIABLE SET
		VARIABLE_NAME = p_VARIABLE_NAME,
		BEGIN_DATE = CONSTANTS.LOW_DATE,
		END_DATE = NULL,
        FORMULA = p_FORMULA,
        COMMENTS = NULL,
        PERSIST_VALUE = 1,
        ROW_NUMBER = 0,
		ENTRY_DATE = SYSDATE
	WHERE COMPONENT_ID = p_COMPONENT_ID
    	AND SUB_COMPONENT_TYPE = p_SUB_COMPONENT_TYPE
        AND SUB_COMPONENT_ID = p_SUB_COMPONENT_ID
		AND VARIABLE_NAME = p_VARIABLE_NAME
		AND BEGIN_DATE = CONSTANTS.LOW_DATE;

-- NO ASSIGNMENT UPDATE FOR THIS COMBINATION SO INSERT A NEW ASSIGNMENT
	IF SQL%NOTFOUND THEN
		INSERT INTO COMPONENT_FORMULA_VARIABLE
			(
			COMPONENT_ID,
            SUB_COMPONENT_TYPE,
            SUB_COMPONENT_ID,
            VARIABLE_NAME,
			BEGIN_DATE,
			END_DATE,
            FORMULA,
            COMMENTS,
            PERSIST_VALUE,
            ROW_NUMBER,
			ENTRY_DATE
			)
		VALUES
			(
			p_COMPONENT_ID,
            p_SUB_COMPONENT_TYPE,
            p_SUB_COMPONENT_ID,
			p_VARIABLE_NAME,
			CONSTANTS.LOW_DATE,
			NULL,
            p_FORMULA,
            NULL,
            1,
			0,
			SYSDATE
			);
	END IF;

END PUT_COMPONENT_FML_FIXED_VAR;
--------------------------------------------------------------------------------
PROCEDURE PUT_COMPONENT_FORMULA_RESULT
    (
    p_COMPONENT_ID IN NUMBER,
    p_SUB_COMPONENT_TYPE IN VARCHAR2,
    p_SUB_COMPONENT_ID IN NUMBER,
    p_ENTITY_DOMAIN_ID IN NUMBER,
    p_ENTITY_ID IN NUMBER,
    p_BEGIN_DATE IN DATE,
    p_END_DATE IN DATE,
    p_WHAT_FIELD IN VARCHAR2,
    p_FORMULA IN VARCHAR2,
    p_COMMENTS IN VARCHAR2,
    p_OLD_ENTITY_DOMAIN_ID IN NUMBER,
    p_OLD_ENTITY_ID IN NUMBER,
    p_OLD_BEGIN_DATE IN DATE,
    p_OLD_WHAT_FIELD IN VARCHAR2
    ) AS
v_KEY_NEW UT.STRING_MAP;
v_KEY_OLD UT.STRING_MAP;
v_DATA UT.STRING_MAP;
v_ENTITY_ID COMPONENT_FORMULA_INPUT.ENTITY_ID%TYPE;
v_ENTITY_TYPE COMPONENT_FORMULA_INPUT.ENTITY_TYPE%TYPE;
v_OLD_ENTITY_ID COMPONENT_FORMULA_INPUT.ENTITY_ID%TYPE;
v_OLD_ENTITY_TYPE COMPONENT_FORMULA_INPUT.ENTITY_TYPE%TYPE;
BEGIN
-- Data-Level Security
    SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_COMPONENT_ID, EC.ED_COMPONENT);

	GET_ENTITY_ID_AND_TYPE_FROM_UI(p_ENTITY_ID, FALSE, v_ENTITY_ID, v_ENTITY_TYPE);
	GET_ENTITY_ID_AND_TYPE_FROM_UI(p_OLD_ENTITY_ID, FALSE, v_OLD_ENTITY_ID, v_OLD_ENTITY_TYPE);

    v_KEY_NEW('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_COMPONENT_ID);
    v_KEY_OLD('COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_COMPONENT_ID);
    v_KEY_NEW('SUB_COMPONENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_SUB_COMPONENT_TYPE);
    v_KEY_OLD('SUB_COMPONENT_TYPE') := UT.GET_LITERAL_FOR_STRING(p_SUB_COMPONENT_TYPE);
    v_KEY_NEW('SUB_COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SUB_COMPONENT_ID);
    v_KEY_OLD('SUB_COMPONENT_ID') := UT.GET_LITERAL_FOR_NUMBER(p_SUB_COMPONENT_ID);
    v_KEY_NEW('ENTITY_DOMAIN_ID') := UT.GET_LITERAL_FOR_NUMBER(p_ENTITY_DOMAIN_ID);
    v_KEY_OLD('ENTITY_DOMAIN_ID') := UT.GET_LITERAL_FOR_NUMBER(p_OLD_ENTITY_DOMAIN_ID);
    v_KEY_NEW('ENTITY_TYPE') := UT.GET_LITERAL_FOR_STRING(v_ENTITY_TYPE);
    v_KEY_OLD('ENTITY_TYPE') := UT.GET_LITERAL_FOR_STRING(v_OLD_ENTITY_TYPE);
    v_KEY_NEW('ENTITY_ID') := UT.GET_LITERAL_FOR_NUMBER(v_ENTITY_ID);
    v_KEY_OLD('ENTITY_ID') := UT.GET_LITERAL_FOR_NUMBER(v_OLD_ENTITY_ID);
    v_KEY_NEW('WHAT_FIELD') := UT.GET_LITERAL_FOR_STRING(TRANSLATE_FORMULA_INPUT_FIELD(p_WHAT_FIELD,0));
    v_KEY_OLD('WHAT_FIELD') := UT.GET_LITERAL_FOR_STRING(p_OLD_WHAT_FIELD);
    v_DATA('FORMULA') := UT.GET_LITERAL_FOR_STRING(p_FORMULA);
    v_DATA('COMMENTS') := UT.GET_LITERAL_FOR_STRING(p_COMMENTS);

    UT.PUT_TEMPORAL_DATA_UI('COMPONENT_FORMULA_RESULT',
                            p_BEGIN_DATE,
                            p_END_DATE,
                            p_OLD_BEGIN_DATE,
                            TRUE,
                            v_KEY_NEW,
                            v_KEY_OLD,
                            v_DATA,
                            '',
                            '',
                            'BEGIN_DATE',
                            'END_DATE'
                            );

END PUT_COMPONENT_FORMULA_RESULT;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_FML_DOMAINS
	(
	p_IS_INPUT IN NUMBER,
	p_STATUS OUT NUMBER,
    p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT NVL(DISPLAY_NAME,ENTITY_DOMAIN_NAME) "ENTITY_DOMAIN_NAME",
        	ENTITY_DOMAIN_ID
        FROM ENTITY_DOMAIN
        WHERE ENTITY_DOMAIN_ID IN (EC.ED_TRANSACTION, EC.ED_MARKET_PRICE,
								   EC.ED_SUB_STATION_METER_POINT, EC.ED_MEASUREMENT_SOURCE)
			-- sub-station and sub-station meter are only allowed for inputs, not for results
			OR (p_IS_INPUT = 1 AND ENTITY_DOMAIN_ID IN (EC.ED_SUB_STATION,
														EC.ED_SUB_STATION_METER))
        ORDER BY 1;
END GET_FML_DOMAINS;
----------------------------------------------------------------------------------------------------
PROCEDURE FORMULA_INPUT_FIELDS
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
    ) AS
BEGIN
	p_STATUS := GA.SUCCESS;

	IF p_ENTITY_DOMAIN_ID = EC.ED_TRANSACTION THEN
		OPEN p_CURSOR FOR
			SELECT COLUMN_VALUE
			FROM TABLE(CAST(
				STRING_COLLECTION('AMOUNT', 'PRICE') as STRING_COLLECTION
				))
			UNION ALL
			SELECT 'TRAIT_VAL ('||NVL(TG.DISPLAY_NAME,TG.TRAIT_GROUP_NAME)||': '||NVL(SO.OBJECT_DISPLAY_NAME,SO.OBJECT_NAME)||')'
			FROM TRANSACTION_TRAIT_GROUP TG, TRANSACTION_TRAIT T, SYSTEM_OBJECT SO
			WHERE T.TRAIT_GROUP_ID = TG.TRAIT_GROUP_ID
				AND NVL(TG.IS_SPARSE,0) = 0 -- cannot use sparse traits
				AND SO.OBJECT_ID = T.SYSTEM_OBJECT_ID
			ORDER BY 1;
	ELSIF p_ENTITY_DOMAIN_ID = EC.ED_MARKET_PRICE THEN
		OPEN p_CURSOR FOR
			SELECT COLUMN_VALUE
			FROM TABLE(CAST(
				STRING_COLLECTION('PRICE', 'PRICE_BASIS') as STRING_COLLECTION
				));
	ELSIF p_ENTITY_DOMAIN_ID IN (EC.ED_SUB_STATION, EC.ED_SUB_STATION_METER, EC.ED_SUB_STATION_METER_POINT) THEN
		OPEN p_CURSOR FOR
			SELECT COLUMN_VALUE
			FROM TABLE(CAST(
				STRING_COLLECTION('METER_VAL','METER_VAL_CARRY_FWD','METER_VAL_ACCUM',
								  'TRUNCATED_VAL','TRUNCATED_VAL_ACCUM',
								  'LIFETIME_VAL_ACCUM', 'METER_VAL (raw)',
								  'METER_VAL_CARRY_FWD (raw)','METER_VAL_ACCUM (raw)',
								  'TRUNCATED_VAL (raw)','TRUNCATED_VAL_ACCUM (raw)',
								  'LIFETIME_VAL_ACCUM (raw)', 'METER_VAL Loss-Adjusted',
								  'TRUNCATED_VAL Loss-Adjusted', 'METER_VAL Loss Energy',
								  'TRUNCATED_VAL Loss Energy', 'METER_VAL Loss-Adjusted (raw)',
								  'TRUNCATED_VAL Loss-Adjusted (raw)', 'METER_VAL Loss Energy (raw)',
								  'TRUNCATED_VAL Loss Energy (raw)') as STRING_COLLECTION
				))
			UNION ALL
			-- only add loss factor types for sub-station meter points
			SELECT 'LOSS_FACTOR - '||VALUE
			FROM (SELECT VALUE
					FROM SYSTEM_LABEL L
					WHERE p_ENTITY_DOMAIN_ID = EC.ED_SUB_STATION_METER_POINT
						AND L.MODEL_ID = CONSTANTS.GLOBAL_MODEL
						AND L.MODULE = 'Entity Manager'
						AND L.KEY1 = 'Loss Factor'
						AND L.KEY2 = 'Loss Type'
						AND L.KEY3 = '?'
				  	ORDER BY POSITION);
	ELSIF p_ENTITY_DOMAIN_ID = EC.ED_MEASUREMENT_SOURCE THEN
		OPEN p_CURSOR FOR
			SELECT COLUMN_VALUE
			FROM TABLE(CAST(
				STRING_COLLECTION('SOURCE_VALUE') as STRING_COLLECTION
				));
	ELSE
		--return empty list if this is not a valid entity domain
		OPEN p_CURSOR FOR
			SELECT '' as VALUE
			FROM DUAL
			WHERE 0=1;
	END IF;

END FORMULA_INPUT_FIELDS;
----------------------------------------------------------------------------------------------------
FUNCTION TRANSLATE_FORMULA_INPUT_FIELD
	(
	p_FIELD IN VARCHAR2,
	p_TO_DISPLAY IN NUMBER := 1
	) RETURN VARCHAR2 IS
v_TG_ID TRANSACTION_TRAIT_GROUP.TRAIT_GROUP_ID%TYPE;
v_T_IDX TRANSACTION_TRAIT.TRAIT_INDEX%TYPE;
v_TOKENS  GA.STRING_TABLE;
v_TG_NAME TRANSACTION_TRAIT_GROUP.DISPLAY_NAME%TYPE;
v_T_NAME  SYSTEM_OBJECT.OBJECT_NAME%TYPE;
v_POS1 PLS_INTEGER;
v_POS2 PLS_INTEGER;
v_POS3 PLS_INTEGER;
BEGIN
	-- not trait value strings, then just check for raw suffixes
	IF NVL(SUBSTR(p_FIELD,1,9),'?') != 'TRAIT_VAL' THEN
		IF p_TO_DISPLAY = 1 THEN
			-- CHANGE SUFFIX * to (raw)
			--    and SUFFIX :A to Loss-Adjusted
			--    and SUFFIX :L to Loss Energy
			--    and PREFIX LOSS_FACTOR: to 'LOSS_FACTOR - '
			RETURN REPLACE(REPLACE(REPLACE(REPLACE(p_FIELD, '*', ' (raw)'),':A',' Loss-Adjusted'), ':L', ' Loss Energy'), 'LOSS_FACTOR:', 'LOSS_FACTOR - ');
		ELSE
			-- CHANGE SUFFIX (raw) to *
			--    and SUFFIX Loss-Adjusted to :A
			--    and SUFFIX Loss Energy to :L
			--    and PREFIX 'LOSS_FACTOR - ' to LOSS_FACTOR:
			RETURN REPLACE(REPLACE(REPLACE(REPLACE(p_FIELD, ' (raw)', '*'), ' Loss-Adjusted', ':A'), ' Loss Energy', ':L'), 'LOSS_FACTOR - ', 'LOSS_FACTOR:');
		END IF;

		RETURN p_FIELD;
	END IF;

	IF p_TO_DISPLAY = 1 THEN
		UT.TOKENS_FROM_STRING(p_FIELD,':',v_TOKENS);
		-- second and third token are group ID and trait index
		v_TG_ID := v_TOKENS(v_TOKENS.NEXT(v_TOKENS.FIRST));
		v_T_IDX := v_TOKENS(v_TOKENS.NEXT(v_TOKENS.NEXT(v_TOKENS.FIRST)));
		-- query for the trait names
		SELECT NVL(TG.DISPLAY_NAME,TG.TRAIT_GROUP_NAME), NVL(SO.OBJECT_DISPLAY_NAME,SO.OBJECT_NAME)
		INTO v_TG_NAME, v_T_NAME
		FROM TRANSACTION_TRAIT_GROUP TG, TRANSACTION_TRAIT T, SYSTEM_OBJECT SO
		WHERE TG.TRAIT_GROUP_ID = v_TG_ID
			AND T.TRAIT_GROUP_ID = TG.TRAIT_GROUP_ID
			AND T.TRAIT_INDEX = v_T_IDX
			AND SO.OBJECT_ID = T.SYSTEM_OBJECT_ID;
		-- return the display text
		RETURN 'TRAIT_VAL ('||v_TG_NAME||': '||v_T_NAME||')';
	ELSE
		-- find delimiters for names
		v_POS1 := INSTR(p_FIELD, '(', 1);
		v_POS2 := INSTR(p_FIELD, ':', v_POS1+1);
		v_POS3 := INSTR(p_FIELD, ')', v_POS2+1);
		-- extract names from the string
		v_TG_NAME := TRIM(SUBSTR(p_FIELD, v_POS1+1, v_POS2-v_POS1-1));
		v_T_NAME := TRIM(SUBSTR(p_FIELD, v_POS2+1, v_POS3-v_POS2-1));
		-- query for the IDs
		SELECT TG.TRAIT_GROUP_ID, T.TRAIT_INDEX
		INTO v_TG_ID, v_T_IDX
		FROM TRANSACTION_TRAIT_GROUP TG, TRANSACTION_TRAIT T, SYSTEM_OBJECT SO
		WHERE (TG.DISPLAY_NAME = v_TG_NAME OR (TG.DISPLAY_NAME IS NULL AND TG.TRAIT_GROUP_NAME = v_TG_NAME))
			AND T.TRAIT_GROUP_ID = TG.TRAIT_GROUP_ID
			AND SO.OBJECT_ID = T.SYSTEM_OBJECT_ID
			AND (SO.OBJECT_DISPLAY_NAME = v_T_NAME OR (SO.OBJECT_DISPLAY_NAME IS NULL AND UPPER(SO.OBJECT_NAME) = UPPER(v_T_NAME)));
		-- return the persisted field value
		RETURN 'TRAIT_VAL:'||v_TG_ID||':'||v_T_IDX;
	END IF;
END TRANSLATE_FORMULA_INPUT_FIELD;
----------------------------------------------------------------------------------------------------
-- These VB procedures are here for back-compatibility
-- with the prices tab in the Forcebasing module, once
-- forecasting has been migrated they can be removed.
-- (CUSTOM_MARKET_PRICE_TREE_FIELD, CUSTOM_MARKET_PRICE_TREE,
--	GET_MARKET_PRICE_TREE_VB, MARKET_PRICES_VB)
PROCEDURE MARKET_PRICES_VB
	(
	p_MARKET_PRICE_IDs IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_PRICE_CODE IN CHAR,
	p_INTERVAL IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
	-- @todo: remove interval parameter

-- Answer the market price data.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_CANDIDATES VARCHAR(2000);
v_DAY_INTERVAL_TYPE NUMBER(1);
v_INTERVAL_NUMBER NUMBER := GET_INTERVAL_NUMBER(p_INTERVAL);
v_USE_ALIAS VARCHAR2(3) := NVL(MODEL_VALUE_AT_KEY(0,'Product','Market Prices','Use Alias In Grid'),'0');
v_IDS NUMBER_COLLECTION;
BEGIN
	--Make sure we have data in the SYSTEM_DATE_TIME table.  Return an error if not.
	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, p_BEGIN_DATE, p_END_DATE);

    p_STATUS := GA.SUCCESS;

    IF v_INTERVAL_NUMBER < GET_INTERVAL_NUMBER('DD') THEN
        v_DAY_INTERVAL_TYPE := 1;
        UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
    ELSE
        v_DAY_INTERVAL_TYPE := 2;
        UT.CUT_DATE_RANGE(v_DAY_INTERVAL_TYPE, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, get_interval_abbreviation(p_INTERVAL), v_BEGIN_DATE, v_END_DATE);
    END IF;

	IF v_CANDIDATES = '<All>' THEN
		v_IDS := SD.GET_ALLOWED_IDS_FROM_SELECTION(SD.g_ACTION_MKT_PRICE_SELECT, EC.ED_MARKET_PRICE, SD.g_ALL_DATA_ENTITY_ID, ',', FALSE);
	ELSE
		v_IDS := SD.GET_ALLOWED_IDS_FROM_SELECTION(SD.g_ACTION_MKT_PRICE_SELECT, EC.ED_MARKET_PRICE, p_MARKET_PRICE_IDs, ',');
	END IF;

	OPEN p_CURSOR FOR
        SELECT A.MARKET_PRICE_NAME,
	        A.MARKET_PRICE_ID,
	        CASE WHEN v_DAY_INTERVAL_TYPE=1 THEN A.NO_ROLLUP_YYYY_MM_DD ELSE A.DAY_YYYY_MM_DD END "PRICE_DATE",
	        B.PRICE_BASIS,
	        B.PRICE,
	        CASE WHEN UPPER(SUBSTR(A.MARKET_PRICE_TYPE,1,9))='COMPOSITE' THEN 0 ELSE 1 END "ALLOW_EDIT"
        FROM (SELECT CASE WHEN v_USE_ALIAS = '1' THEN MARKET_PRICE_ALIAS ELSE MARKET_PRICE_NAME END "MARKET_PRICE_NAME",
			MARKET_PRICE_ID, MARKET_PRICE_TYPE, CUT_DATE, NO_ROLLUP_YYYY_MM_DD, DAY_YYYY_MM_DD
	        FROM MARKET_PRICE,
				SYSTEM_DATE_TIME,
				TABLE(CAST(v_IDS AS NUMBER_COLLECTION)) X
	        WHERE (X.COLUMN_VALUE = SD.g_ALL_DATA_ENTITY_ID OR MARKET_PRICE_ID = X.COLUMN_VALUE)
		        AND TIME_ZONE = p_TIME_ZONE
		        AND DATA_INTERVAL_TYPE = v_DAY_INTERVAL_TYPE
		        AND DAY_TYPE = 1
		        AND CUT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		        AND MINIMUM_INTERVAL_NUMBER >= v_INTERVAL_NUMBER) A,
	        MARKET_PRICE_VALUE B
        WHERE B.MARKET_PRICE_ID(+) = A.MARKET_PRICE_ID
	        AND B.PRICE_CODE(+) = p_PRICE_CODE
	        AND B.PRICE_DATE(+) = A.CUT_DATE
	        AND B.AS_OF_DATE(+) = MARKET_PRICE_AS_OF_DATE(A.MARKET_PRICE_ID,p_PRICE_CODE,A.CUT_DATE,p_AS_OF_DATE)
        ORDER BY 1,3;

END MARKET_PRICES_VB;
---------------------------------------------------------------------------------------------------
PROCEDURE MARKET_PRICES
	(
	p_MARKET_PRICE_ID IN NUMBER_COLLECTION,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_PRICE_CODE IN CHAR,
	p_INTERVAL IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
	-- @todo: remove interval parameter

-- Answer the market price data.

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_DAY_INTERVAL_TYPE NUMBER(1);
v_INTERVAL_NUMBER NUMBER := GET_INTERVAL_NUMBER(p_INTERVAL);
v_USE_ALIAS VARCHAR2(3) := NVL(MODEL_VALUE_AT_KEY(0,'Product','Market Prices','Use Alias In Grid'),'0');
v_IDS NUMBER_COLLECTION;
v_LOCKING_ENABLED NUMBER := AUDIT_TRAIL.IS_TABLE_LOCKING_ENABLED(ENTITY_UTIL.TABLE_ID_FOR_DB_TABLE('MARKET_PRICE_VALUE'));
BEGIN
	v_IDS := SD.GET_ALLOWED_IDS_FROM_SELECTION(SD.g_ACTION_MKT_PRICE_SELECT, EC.ED_MARKET_PRICE, p_MARKET_PRICE_ID);

	--Make sure we have data in the SYSTEM_DATE_TIME table.  Return an error if not.
	SP.CHECK_SYSTEM_DATE_TIME(p_TIME_ZONE, p_BEGIN_DATE, p_END_DATE);

    p_STATUS := GA.SUCCESS;

    IF v_INTERVAL_NUMBER < GET_INTERVAL_NUMBER('DD') THEN
        v_DAY_INTERVAL_TYPE := 1;
        UT.CUT_DATE_RANGE(p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
    ELSE
        v_DAY_INTERVAL_TYPE := 2;
        UT.CUT_DATE_RANGE(v_DAY_INTERVAL_TYPE, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE, get_interval_abbreviation(p_INTERVAL), v_BEGIN_DATE, v_END_DATE);
    END IF;

	OPEN p_CURSOR FOR
        SELECT A.MARKET_PRICE_NAME,
	        A.MARKET_PRICE_ID,
	        CASE WHEN v_DAY_INTERVAL_TYPE=1 THEN A.NO_ROLLUP_YYYY_MM_DD ELSE A.DAY_YYYY_MM_DD END "PRICE_DATE",
	        B.PRICE_BASIS,
	        B.PRICE,
	        CASE WHEN UPPER(SUBSTR(A.MARKET_PRICE_TYPE,1,9))='COMPOSITE' THEN 0 ELSE 1 END "ALLOW_EDIT",
			SECURITY_CONTROLS.GET_EFFECTIVE_LOCK_STATE(B.LOCK_STATE,v_LOCKING_ENABLED) "LOCK_STATE"
        FROM (SELECT CASE WHEN v_USE_ALIAS = '1' THEN MARKET_PRICE_ALIAS ELSE MARKET_PRICE_NAME END "MARKET_PRICE_NAME",
			MARKET_PRICE_ID, MARKET_PRICE_TYPE, CUT_DATE, NO_ROLLUP_YYYY_MM_DD, DAY_YYYY_MM_DD
	        FROM MARKET_PRICE MP, SYSTEM_DATE_TIME SDT, TABLE(CAST(v_IDS AS NUMBER_COLLECTION)) IDS
	        WHERE (IDS.COLUMN_VALUE = SD.g_ALL_DATA_ENTITY_ID OR MP.MARKET_PRICE_ID = IDS.COLUMN_VALUE)
		        AND SDT.TIME_ZONE = p_TIME_ZONE
		        AND SDT.DATA_INTERVAL_TYPE = v_DAY_INTERVAL_TYPE
		        AND SDT.DAY_TYPE = 1
		        AND SDT.CUT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		        AND SDT.MINIMUM_INTERVAL_NUMBER >= v_INTERVAL_NUMBER) A,
	        MARKET_PRICE_VALUE B
        WHERE B.MARKET_PRICE_ID(+) = A.MARKET_PRICE_ID
	        AND B.PRICE_CODE(+) = p_PRICE_CODE
	        AND B.PRICE_DATE(+) = A.CUT_DATE
	        AND B.AS_OF_DATE(+) = MARKET_PRICE_AS_OF_DATE(A.MARKET_PRICE_ID,p_PRICE_CODE,A.CUT_DATE,p_AS_OF_DATE)
        ORDER BY 1,3;

END MARKET_PRICES;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_MARKET_PRICE_VALUE_UI
	(
	p_MARKET_PRICE_ID IN NUMBER,
	p_PRICE_DATE IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR2,
	p_PRICE_CODE IN VARCHAR2,
	p_PRICE IN NUMBER,
	p_PRICE_BASIS IN NUMBER,
	p_ALLOW_EDIT IN NUMBER,
	p_STATUS OUT NUMBER
	) AS
BEGIN

	IF NVL(p_ALLOW_EDIT,0) <> 0 THEN
		-- only store price if we are allowed to edit
		-- i.e. this is not a composite price
		PUT_MARKET_PRICE_VALUE(p_MARKET_PRICE_ID,SUBSTR(p_PRICE_DATE,1,10),SUBSTR(p_PRICE_DATE,12),p_PRICE_CODE,p_PRICE_BASIS,p_PRICE,p_TIME_ZONE,p_STATUS);
	ELSE
		p_STATUS := GA.SUCCESS;
	END IF;

END PUT_MARKET_PRICE_VALUE_UI;
-- These VB procedures are here for back-compatibility
-- with the prices tab in the Forcebasing module, once
-- forecasting has been migrated they can be removed.
-- (CUSTOM_MARKET_PRICE_TREE_FIELD, CUSTOM_MARKET_PRICE_TREE,
--	GET_MARKET_PRICE_TREE_VB, MARKET_PRICES_VB)
---------------------------------------------------------------------------------------------------
PROCEDURE CUSTOM_MARKET_PRICE_TREE_FIELD
	(
    p_CUSTOM_FIELD IN VARCHAR2,
    p_SQL_SELECT IN OUT VARCHAR2,
    p_SQL_FROM IN OUT VARCHAR2,
    p_SQL_WHERE IN OUT VARCHAR2
    ) AS
v_FLD CHAR(1) := SUBSTR(UPPER(p_CUSTOM_FIELD),1,1);
BEGIN
	IF v_FLD IS NULL THEN
    	p_SQL_SELECT := p_SQL_SELECT||' NULL, ';
	ELSIF v_FLD = '0' THEN
    	-- energy distribution company
        p_SQL_SELECT := p_SQL_SELECT||' B.EDC_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' ENERGY_DISTRIBUTION_COMPANY B, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND B.EDC_ID(+) = A.EDC_ID ';
	ELSIF v_FLD = '1' THEN
    	-- schedule coordinator
        p_SQL_SELECT := p_SQL_SELECT||' C.SC_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' SCHEDULE_COORDINATOR C, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND C.SC_ID(+) = A.SC_ID ';
    ELSIF v_FLD = '2' THEN
    	-- price type
        p_SQL_SELECT := p_SQL_SELECT||' A.MARKET_PRICE_TYPE, ';
    ELSIF v_FLD = '3' THEN
    	-- market type
        p_SQL_SELECT := p_SQL_SELECT||' A.MARKET_TYPE, ';
    ELSIF v_FLD = '4' THEN
    	-- service point type
        p_SQL_SELECT := p_SQL_SELECT||' A.SERVICE_POINT_TYPE, ';
	ELSIF v_FLD = '5' THEN
    	-- service point
        p_SQL_SELECT := p_SQL_SELECT||' D.SERVICE_POINT_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' SERVICE_POINT D, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND D.SERVICE_POINT_ID(+) = A.POD_ID ';
	ELSIF v_FLD = '6' THEN
    	-- service zone
        p_SQL_SELECT := p_SQL_SELECT||' F.SERVICE_ZONE_NAME, ';
        p_SQL_FROM := p_SQL_FROM||' SERVICE_POINT E, SERVICE_ZONE F, ';
        p_SQL_WHERE := p_SQL_WHERE||' AND E.SERVICE_POINT_ID(+) = A.POD_ID ';
        p_SQL_WHERE := p_SQL_WHERE||' AND F.SERVICE_ZONE_ID(+) = E.SERVICE_ZONE_ID ';
    ELSE
    	-- unrecognized? ignore
    	p_SQL_SELECT := p_SQL_SELECT||' NULL, ';
    END IF;
END CUSTOM_MARKET_PRICE_TREE_FIELD;
---------------------------------------------------------------------------------------------------
PROCEDURE CUSTOM_MARKET_PRICE_TREE
    (
    p_CUSTOM_FIELDS IN VARCHAR2,
	p_INTERVAL IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_SQL_SELECT VARCHAR2(1000) := '';
v_SQL_FROM VARCHAR2(1000) := '';
v_SQL_WHERE VARCHAR2(1000) := '';
v_SQL VARCHAR2(4000);
v_IDS ID_TABLE;
BEGIN
	v_IDS := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_MKT_PRICE_SELECT, EC.ED_MARKET_PRICE);
	p_STATUS := GA.SUCCESS;

    FOR v_INDEX IN 1..3 LOOP
    	CUSTOM_MARKET_PRICE_TREE_FIELD(SUBSTR(p_CUSTOM_FIELDS,v_INDEX,1),v_SQL_SELECT,v_SQL_FROM,v_SQL_WHERE);
    END LOOP;

    v_SQL := 'SELECT '||v_SQL_SELECT||
				' A.MARKET_PRICE_NAME,'||
				' A.MARKET_PRICE_ID'||
			' FROM '||v_SQL_FROM||
            	' MARKET_PRICE A, TABLE(CAST(:1 AS ID_TABLE)) X'||
			' WHERE (X.ID = '||SD.g_ALL_DATA_ENTITY_ID||' OR A.MARKET_PRICE_ID = X.ID)
				AND A.MARKET_PRICE_INTERVAL = :2'||
				v_SQL_WHERE||
			' ORDER BY 1,2,3,4';

    -- execute query dynamically
	OPEN p_CURSOR FOR
    	v_SQL USING v_IDS, p_INTERVAL;

END CUSTOM_MARKET_PRICE_TREE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_MARKET_PRICE_TREE_VB
    (
	p_INTERVAL IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the market prices tree

v_TREE_HIERARCHY VARCHAR2(32);
v_TREE_TYPE CHAR(1);
v_IDS ID_TABLE;
BEGIN

	v_IDS := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_MKT_PRICE_SELECT, EC.ED_MARKET_PRICE);
    p_STATUS := GA.SUCCESS;

	SP.GET_USER_PREFERENCE('Product','Market Prices','?','?','Hierarchy',v_TREE_HIERARCHY);
	v_TREE_HIERARCHY := NVL(v_TREE_HIERARCHY,'A'); -- default
	v_TREE_TYPE := SUBSTR(v_TREE_HIERARCHY,1,1);

	IF v_TREE_TYPE = 'A' THEN
		OPEN p_CURSOR FOR
			SELECT B.EDC_NAME,
				A.SERVICE_POINT_TYPE,
				A.MARKET_PRICE_TYPE,
				A.MARKET_PRICE_NAME,
				A.MARKET_PRICE_ID
			FROM MARKET_PRICE A, ENERGY_DISTRIBUTION_COMPANY B, TABLE(CAST(v_IDS AS ID_TABLE)) X
			WHERE (X.ID = SD.g_ALL_DATA_ENTITY_ID OR A.MARKET_PRICE_ID = X.ID)
				AND A.MARKET_PRICE_INTERVAL = p_INTERVAL
				AND B.EDC_ID(+) = A.EDC_ID
				AND A.MARKET_PRICE_ID > 0
			ORDER BY 1, 2, 3, 4;
	ELSIF v_TREE_TYPE = 'B' THEN
		OPEN p_CURSOR FOR
			SELECT B.SC_NAME,
				A.MARKET_TYPE,
				A.MARKET_PRICE_TYPE,
				A.MARKET_PRICE_NAME,
				A.MARKET_PRICE_ID
			FROM MARKET_PRICE A, SCHEDULE_COORDINATOR B, TABLE(CAST(v_IDS AS ID_TABLE)) X
			WHERE (X.ID = SD.g_ALL_DATA_ENTITY_ID OR A.MARKET_PRICE_ID = X.ID)
				AND A.MARKET_PRICE_INTERVAL = p_INTERVAL
				AND B.SC_ID(+) = A.SC_ID
				AND A.MARKET_PRICE_ID > 0
			ORDER BY 1, 2, 3, 4;
	ELSIF v_TREE_TYPE = 'C' THEN
		OPEN p_CURSOR FOR
			SELECT A.MARKET_TYPE,
				A.SERVICE_POINT_TYPE,
				B.SERVICE_POINT_NAME,
				A.MARKET_PRICE_NAME,
				A.MARKET_PRICE_ID
			FROM MARKET_PRICE A, SERVICE_POINT B, TABLE(CAST(v_IDS AS ID_TABLE)) X
			WHERE (X.ID = SD.g_ALL_DATA_ENTITY_ID OR A.MARKET_PRICE_ID = X.ID)
				AND A.MARKET_PRICE_INTERVAL = p_INTERVAL
				AND B.SERVICE_POINT_ID(+) = A.POD_ID
				AND A.MARKET_PRICE_ID > 0
			ORDER BY 1, 2, 3, 4;
	ELSIF v_TREE_TYPE = 'X' THEN
		XS.GET_MARKET_PRICE_TREE(p_INTERVAL, p_STATUS, p_CURSOR);
	ELSIF v_TREE_TYPE = '*' THEN
    	CUSTOM_MARKET_PRICE_TREE(SUBSTR(v_TREE_HIERARCHY,2),p_INTERVAL,p_STATUS,p_CURSOR);
	END IF;

END GET_MARKET_PRICE_TREE_VB;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_MARKET_PRICE_TREE
    (
	p_INTERVAL IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
-- Answer the market prices tree
	v_IDS ID_TABLE;
BEGIN

	v_IDS := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_MKT_PRICE_SELECT, EC.ED_MARKET_PRICE);

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT DISTINCT NVL(B.EDC_NAME, CONSTANTS.NOT_ASSIGNED_STRING) "EDC_NAME",
			NVL(C.SC_NAME, CONSTANTS.NOT_ASSIGNED_STRING) "SC_NAME",
			NVL(D.SERVICE_POINT_NAME, CONSTANTS.NOT_ASSIGNED_STRING) "POD_NAME",
			NVL(E.SERVICE_ZONE_NAME, CONSTANTS.NOT_ASSIGNED_STRING) "POD_ZONE",
			NVL(F.SERVICE_ZONE_NAME, CONSTANTS.NOT_ASSIGNED_STRING) "ZOD",
			NVL(A.MARKET_TYPE, CONSTANTS.NOT_ASSIGNED_STRING) "MARKET_TYPE",
			NVL(A.SERVICE_POINT_TYPE, CONSTANTS.NOT_ASSIGNED_STRING) "SERVICE_POINT_TYPE",
			NVL(A.MARKET_PRICE_TYPE, CONSTANTS.NOT_ASSIGNED_STRING) "MARKET_PRICE_TYPE"
		FROM MARKET_PRICE A, ENERGY_DISTRIBUTION_COMPANY B, SCHEDULE_COORDINATOR C, SERVICE_POINT D, SERVICE_ZONE E, SERVICE_ZONE F,
			TABLE(CAST(v_IDS AS ID_TABLE)) X
		WHERE (X.ID = SD.g_ALL_DATA_ENTITY_ID OR A.MARKET_PRICE_ID = X.ID)
			AND A.MARKET_PRICE_INTERVAL = p_INTERVAL
			AND B.EDC_ID(+) = A.EDC_ID
			AND C.SC_ID(+) = A.SC_ID
			AND D.SERVICE_POINT_ID(+) = A.POD_ID
			AND E.SERVICE_ZONE_ID(+) = D.SERVICE_ZONE_ID
			AND F.SERVICE_ZONE_ID(+) = A.ZOD_ID
      ORDER BY 6, 1, 2, 3, 4, 5,/* 6,*/ 7, 8; -- JY Change 7/13/12 - defect 1310: sort order of Locational Marginal price folder not alphabetical
END GET_MARKET_PRICE_TREE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_MARKET_PRICE_SUB_TREE
    (
	p_EDC_NAME IN VARCHAR,
	p_SC_NAME IN VARCHAR,
	p_POD_NAME IN VARCHAR,
	p_POD_ZONE IN VARCHAR,
	p_ZOD IN VARCHAR,
	p_MARKET_TYPE IN VARCHAR,
	p_SERVICE_POINT_TYPE IN VARCHAR,
	p_MARKET_PRICE_TYPE IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
-- Answer the market prices tree
BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT A.MARKET_PRICE_NAME,
			A.MARKET_PRICE_ALIAS,
			A.MARKET_PRICE_ID
		FROM MARKET_PRICE A
		WHERE A.MARKET_PRICE_INTERVAL = p_INTERVAL
		    AND ((p_MARKET_TYPE IS NULL) OR (p_MARKET_TYPE = CONSTANTS.NOT_ASSIGNED_STRING AND A.MARKET_TYPE IS NULL) OR (A.MARKET_TYPE = p_MARKET_TYPE))
			AND ((p_SERVICE_POINT_TYPE IS NULL) OR (p_SERVICE_POINT_TYPE = CONSTANTS.NOT_ASSIGNED_STRING AND A.SERVICE_POINT_TYPE IS NULL) OR (A.SERVICE_POINT_TYPE = p_SERVICE_POINT_TYPE))
			AND ((p_MARKET_PRICE_TYPE IS NULL) OR (p_MARKET_PRICE_TYPE = CONSTANTS.NOT_ASSIGNED_STRING AND A.MARKET_TYPE IS NULL) OR (A.MARKET_PRICE_TYPE = p_MARKET_PRICE_TYPE))
			AND (p_EDC_NAME IS NULL OR (p_EDC_NAME = CONSTANTS.NOT_ASSIGNED_STRING AND A.EDC_ID IS NULL) OR EXISTS (SELECT 1 FROM ENERGY_DISTRIBUTION_COMPANY B WHERE B.EDC_NAME = p_EDC_NAME AND B.EDC_ID = A.EDC_ID))
			AND (p_SC_NAME IS NULL OR (p_SC_NAME = CONSTANTS.NOT_ASSIGNED_STRING AND A.SC_ID IS NULL) OR EXISTS (SELECT 1 FROM SCHEDULE_COORDINATOR C WHERE C.SC_NAME = p_SC_NAME AND C.SC_ID = A.SC_ID))
			AND (p_POD_NAME IS NULL OR (p_POD_NAME = CONSTANTS.NOT_ASSIGNED_STRING AND A.POD_ID IS NULL) OR EXISTS (SELECT 1 FROM SERVICE_POINT D WHERE D.SERVICE_POINT_NAME = p_POD_NAME AND D.SERVICE_POINT_ID = A.POD_ID))
			AND (p_POD_ZONE IS NULL OR EXISTS (SELECT 1 FROM SERVICE_POINT D, SERVICE_ZONE E WHERE ((p_POD_ZONE = CONSTANTS.NOT_ASSIGNED AND E.SERVICE_ZONE_NAME IS NULL) OR (E.SERVICE_ZONE_NAME = p_POD_ZONE)) AND E.SERVICE_ZONE_ID = D.SERVICE_ZONE_ID AND D.SERVICE_POINT_ID = A.POD_ID))
			AND (p_ZOD IS NULL OR (p_ZOD = CONSTANTS.NOT_ASSIGNED_STRING AND A.ZOD_ID IS NULL) OR EXISTS (SELECT 1 FROM SERVICE_ZONE F WHERE F.SERVICE_ZONE_NAME = p_ZOD AND F.SERVICE_ZONE_ID = A.ZOD_ID))
		ORDER BY 1,2;

END GET_MARKET_PRICE_SUB_TREE;
---------------------------------------------------------------------------------------------------
PROCEDURE FIND_MARKET_PRICES
    (
	p_SEARCH_STRING IN VARCHAR,
	p_SEARCH_OPTION IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
-- Answer the market prices tree
BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT B.EDC_NAME,
			C.SC_NAME,
			D.SERVICE_POINT_NAME "POD_NAME",
			E.SERVICE_ZONE_NAME "POD_ZONE",
			F.SERVICE_ZONE_NAME "ZOD",
			A.MARKET_TYPE,
			A.SERVICE_POINT_TYPE,
			A.MARKET_PRICE_TYPE,
			A.MARKET_PRICE_ALIAS,
			A.MARKET_PRICE_NAME,
			A.MARKET_PRICE_ID
		FROM MARKET_PRICE A, ENERGY_DISTRIBUTION_COMPANY B, SCHEDULE_COORDINATOR C, SERVICE_POINT D, SERVICE_ZONE E, SERVICE_ZONE F
		WHERE A.MARKET_PRICE_INTERVAL = p_INTERVAL
			AND ((p_SEARCH_STRING IS NULL)
				 OR (p_SEARCH_OPTION = 'By Alias' AND A.MARKET_PRICE_ALIAS LIKE p_SEARCH_STRING)
        		 OR (p_SEARCH_OPTION = 'By Name' AND A.MARKET_PRICE_NAME LIKE p_SEARCH_STRING))
			AND B.EDC_ID(+) = A.EDC_ID
			AND C.SC_ID(+) = A.SC_ID
			AND D.SERVICE_POINT_ID(+) = A.POD_ID
			AND E.SERVICE_ZONE_ID(+) = D.SERVICE_ZONE_ID
			AND F.SERVICE_ZONE_ID(+) = A.ZOD_ID
			AND A.MARKET_PRICE_ID > 0
		ORDER BY 1, 2, 3, 4, 5, 6, 7;
END FIND_MARKET_PRICES;
---------------------------------------------------------------------------------------------------
PROCEDURE SEASONS
    (
	p_TEMPLATE_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the list of seasons for the Time Period Template view

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT DISTINCT 1 "IS_DEFINED", A.SEASON_NAME, A.SEASON_ID, A.BEGIN_DATE
		FROM SEASON A, SEASON_TEMPLATE B
		WHERE B.TEMPLATE_ID = p_TEMPLATE_ID
			AND A.SEASON_ID = B.SEASON_ID

		UNION ALL

		SELECT 0 "IS_DEFINED", A.SEASON_NAME, A.SEASON_ID, A.BEGIN_DATE
		FROM SEASON A
		WHERE NOT EXISTS(SELECT 1 FROM SEASON_TEMPLATE WHERE TEMPLATE_ID = p_TEMPLATE_ID AND SEASON_ID = A.SEASON_ID)

		ORDER BY 4, 2;

END SEASONS;
---------------------------------------------------------------------------------------------------
PROCEDURE PERIODS
    (
	p_TEMPLATE_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

-- Answer the list of periods for the Time Period Template view

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	--Template ID is not used currently, but maybe it should be.
	OPEN p_CURSOR FOR
		SELECT PERIOD_NAME, PERIOD_COLOR, PERIOD_ID
		FROM PERIOD
		ORDER BY 1;

END PERIODS;
----------------------------------------------------------------------------------------------------
PROCEDURE ENTITY_ATTRIBUTES_FOR_DOMAIN
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
    	SELECT ATTRIBUTE_NAME, ATTRIBUTE_ID
    	FROM ENTITY_ATTRIBUTE
    	WHERE ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID
			AND ATTRIBUTE_TYPE = 'Float'
    	ORDER BY ATTRIBUTE_NAME;

END ENTITY_ATTRIBUTES_FOR_DOMAIN;
----------------------------------------------------------------------------------------------------
PROCEDURE ENTITIES_FOR_DOMAIN
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_DOMAIN_ALIAS VARCHAR2(32);
v_DOMAIN_TABLE VARCHAR2(32);
BEGIN
	p_STATUS := GA.SUCCESS;

	SELECT A.ENTITY_DOMAIN_TABLE,
			SUBSTR(B.PRIMARY_ID_COLUMN,1,LENGTH(TRIM(B.PRIMARY_ID_COLUMN))-3)
	INTO v_DOMAIN_TABLE, v_DOMAIN_ALIAS
	FROM ENTITY_DOMAIN A,
		NERO_TABLE_PROPERTY_INDEX B
	WHERE A.ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID
		AND TRIM(B.TABLE_NAME) = TRIM(A.ENTITY_DOMAIN_TABLE);

	OPEN p_CURSOR FOR
		'SELECT '||v_DOMAIN_ALIAS||'_NAME, '||v_DOMAIN_ALIAS||'_ID FROM '||v_DOMAIN_TABLE||' ORDER BY 1';

END ENTITIES_FOR_DOMAIN;
----------------------------------------------------------------------------------------------------
FUNCTION COUNT_ITERATORS
	(
	p_COMPONENT_ID IN NUMBER,
	p_DATE IN DATE
	) RETURN BINARY_INTEGER IS
v_ITERATORS BINARY_INTEGER;
BEGIN
	SELECT LEAST(NVL(SUM(IDENT_COLUMNS),0), FML_UTIL.c_MAX_ITERATORS)
	INTO v_ITERATORS
	FROM COMPONENT_FORMULA_ITERATOR
	WHERE COMPONENT_ID = p_COMPONENT_ID
		AND p_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE,CONSTANTS.HIGH_DATE);

	RETURN v_ITERATORS;
END COUNT_ITERATORS;
----------------------------------------------------------------------------------------------------
PROCEDURE ENTITIES_FOR_FML_DOMAIN
	(
	p_COMPONENT_ID IN NUMBER,
	p_DATE IN DATE,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_REALM_CALC_TYPE IN NUMBER,
	p_IS_INPUT IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_DOMAIN_ALIAS VARCHAR2(32);
v_DOMAIN_TABLE VARCHAR2(32);
v_SQL VARCHAR2(32767) := '';
BEGIN
	p_STATUS := GA.SUCCESS;

	SELECT A.ENTITY_DOMAIN_TABLE,
			SUBSTR(B.PRIMARY_ID_COLUMN,1,LENGTH(TRIM(B.PRIMARY_ID_COLUMN))-3)
	INTO v_DOMAIN_TABLE, v_DOMAIN_ALIAS
	FROM ENTITY_DOMAIN A,
		NERO_TABLE_PROPERTY_INDEX B
	WHERE A.ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID
		AND TRIM(B.TABLE_NAME) = TRIM(A.ENTITY_DOMAIN_TABLE);

	-- include entities
	v_SQL := v_SQL||'SELECT ''<html><b>Entity:</b> ''||'||v_DOMAIN_ALIAS||'_NAME||''</html>'' as ENTITY_NAME, '
						||v_DOMAIN_ALIAS||'_ID*10+'||c_FML_ID_IS_ENTITY||' as ENTITY_ID '
						||'FROM '||v_DOMAIN_TABLE||' WHERE ' || v_DOMAIN_ALIAS || '_ID > 0 '
						|| CASE WHEN p_ENTITY_DOMAIN_ID = EC.ED_SUB_STATION_METER_POINT
							THEN 'AND RETAIL_METER_ID IS NULL ' ELSE NULL END
						|| 'UNION ALL ';

	-- include groups
	IF p_IS_INPUT = 1 THEN
		v_SQL := v_SQL||'SELECT ''<html><b>Group:</b> ''||ENTITY_GROUP_NAME||''</html>'' as ENTITY_NAME, '
							||'ENTITY_GROUP_ID*10+'||c_FML_ID_IS_GROUP||' as ENTITY_ID '
							||'FROM ENTITY_GROUP '
							||'WHERE ENTITY_DOMAIN_ID = '||p_ENTITY_DOMAIN_ID|| ' AND NVL(IS_MATRIX,0) = 0 UNION ALL ';
	END IF;

	-- and, finally, include realms
	v_SQL := v_SQL||'SELECT ''<html><b>''||DECODE(REALM_CALC_TYPE,' ||EM.c_REALM_CALC_TYPE_SYSTEM || ', '''|| TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_SYSTEM_REALM, EC.ED_ENTITY_DOMAIN)||''','
														||EM.c_REALM_CALC_TYPE_FML || ', '''|| TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_FORMULA_REALM, EC.ED_ENTITY_DOMAIN)||''','
														||EM.c_REALM_CALC_TYPE_CALC || ', '''|| TEXT_UTIL.TO_CHAR_ENTITY(EC.ED_CALC_REALM, EC.ED_ENTITY_DOMAIN)||''''
														||')||'':</b> ''||REALM_NAME||''</html>'' as ENTITY_NAME, '
						||'REALM_ID*10+'||c_FML_ID_IS_REALM||' as ENTITY_ID '
						||'FROM SYSTEM_REALM '
						||'WHERE (ENTITY_DOMAIN_ID = '||p_ENTITY_DOMAIN_ID||' '
						||'AND REALM_CALC_TYPE IN ('||EM.c_REALM_CALC_TYPE_SYSTEM||','||p_REALM_CALC_TYPE||')) '
						||'OR REALM_ID = '||SD.g_ALL_DATA_REALM_ID;

	-- add the final ORDER BY clause
	v_SQL := v_SQL||'ORDER BY 1';

	-- and
	OPEN p_CURSOR FOR v_SQL;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		NULL_CURSOR(p_CURSOR);

END ENTITIES_FOR_FML_DOMAIN;
----------------------------------------------------------------------------------------------------
PROCEDURE NON_COMPOSITE_COMPONENTS
	(
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
    	SELECT COMPONENT_NAME, COMPONENT_ID
    	FROM COMPONENT
    	WHERE RATE_STRUCTURE <> 'Composite'
			AND COMPONENT_ENTITY <> 'Calc.Process' -- exclude calculation components
		ORDER BY COMPONENT_NAME;

END NON_COMPOSITE_COMPONENTS;
----------------------------------------------------------------------------------------------------
PROCEDURE IMBALANCE_SETTLEMENT_AGENTS
	(
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
    	SELECT SETTLEMENT_AGENT_NAME
    	FROM EDC_SETTLEMENT_AGENT
    	ORDER BY 1;

END IMBALANCE_SETTLEMENT_AGENTS;
----------------------------------------------------------------------------------------------------
PROCEDURE PERIODS_FOR_TEMPLATE
	(
	p_TEMPLATE_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
    	SELECT DISTINCT B.PERIOD_NAME, B.PERIOD_ID
    	FROM SEASON_TEMPLATE A,
    		PERIOD B
    	WHERE A.TEMPLATE_ID = p_TEMPLATE_ID
			AND B.PERIOD_ID = A.PERIOD_ID
		ORDER BY 1;

END PERIODS_FOR_TEMPLATE;
----------------------------------------------------------------------------------------------------
PROCEDURE PRODUCT_CATEGORIES
	(
	p_ENTITY_TYPE IN VARCHAR2,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	p_STATUS := GA.SUCCESS;

	IF p_ENTITY_TYPE = CONSTANTS.ALL_STRING THEN
		OPEN p_CURSOR FOR
			SELECT DISTINCT PRODUCT_CATEGORY
			FROM PRODUCT
			WHERE PRODUCT_CATEGORY <> '?'
				AND NOT PRODUCT_CATEGORY IS NULL
			ORDER BY 1;
	ELSE
		OPEN p_CURSOR FOR
			SELECT DISTINCT P.PRODUCT_CATEGORY
			FROM PRODUCT P, COMPONENT C, PRODUCT_COMPONENT PC
			WHERE P.PRODUCT_CATEGORY <> '?'
				AND NOT P.PRODUCT_CATEGORY IS NULL
				AND (C.COMPONENT_ENTITY = p_ENTITY_TYPE)
				AND PC.COMPONENT_ID = C.COMPONENT_ID
				AND PC.PRODUCT_ID = P.PRODUCT_ID
			ORDER BY 1;
	END IF;

END PRODUCT_CATEGORIES;
----------------------------------------------------------------------------------------------------
PROCEDURE COMPONENT_CATEGORIES
	(
	p_IS_CALC IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
    	SELECT DISTINCT COMPONENT_CATEGORY
		FROM COMPONENT
		WHERE COMPONENT_CATEGORY <> '?'
			AND NOT COMPONENT_CATEGORY IS NULL
			AND ((COMPONENT_ENTITY <> 'Calc.Process' AND NVL(p_IS_CALC,0) = 0)
				OR (COMPONENT_ENTITY = 'Calc.Process' AND NVL(p_IS_CALC,0) = 1))
		ORDER BY 1;

END COMPONENT_CATEGORIES;
----------------------------------------------------------------------------------------------------
PROCEDURE COMPONENTS_FOR_PRODUCT
	(
	p_PRODUCT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
BEGIN
	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT '<All>' COMPONENT_NAME, -1 COMPONENT_ID
		FROM DUAL
		UNION ALL
    	SELECT DISTINCT COMPONENT_NAME, A.COMPONENT_ID
		FROM PRODUCT_COMPONENT A, COMPONENT B
		WHERE A.PRODUCT_ID = p_PRODUCT_ID
			AND B.COMPONENT_ID = A.COMPONENT_ID
		ORDER BY 1;

END COMPONENTS_FOR_PRODUCT;
----------------------------------------------------------------------------------------------------
PROCEDURE FILL_MARKET_PRICE
	(
	p_MARKET_PRICE_ID IN NUMBER,
	p_TIME_ZONE IN VARCHAR2,
	p_PRICE_CODE IN VARCHAR2,
	p_PRICE IN VARCHAR2,
	p_PRICE_BASIS IN VARCHAR2,
	p_INTERVAL IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_TEMPLATE IN VARCHAR,
	p_BEGIN_HOUR IN NUMBER,
	p_END_HOUR IN NUMBER,
	p_INCLUDE_HOLIDAYS IN NUMBER
	) AS

	v_DELETE CHAR := SUBSTR(p_TEMPLATE, 14, 1);

	v_PRICE NUMBER := LTRIM(RTRIM(p_PRICE));
	v_PRICE_BASIS NUMBER := LTRIM(RTRIM(p_PRICE_BASIS));
	v_PRICE_CODE CHAR := SUBSTR(p_PRICE_CODE, 1, 1);

	v_DELETE_BEGIN DATE;
	v_DELETE_END DATE;

	v_MARKET_PRICE_TYPE VARCHAR2(10);

BEGIN

	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, p_MARKET_PRICE_ID, EC.ED_MARKET_PRICE);

	SELECT UPPER(SUBSTR(PR.MARKET_PRICE_TYPE,1,9))
	INTO v_MARKET_PRICE_TYPE
	FROM MARKET_PRICE PR
	WHERE PR.MARKET_PRICE_ID = p_MARKET_PRICE_ID;

	IF v_MARKET_PRICE_TYPE = 'COMPOSITE' THEN
		ERRS.RAISE_BAD_ARGUMENT('MARKET PRICE', TEXT_UTIL.TO_CHAR_ENTITY(p_MARKET_PRICE_ID,
													EC.ED_MARKET_PRICE, FALSE),
												'You cannot fill a composite market price.');
	END IF;

	IF v_DELETE = '1' THEN
		UT.CUT_DATE_RANGE(GA.ELECTRIC_MODEL, p_BEGIN_DATE, p_END_DATE, p_TIME_ZONE,
			v_DELETE_BEGIN, v_DELETE_END);

		DELETE FROM MARKET_PRICE_VALUE VAL
		WHERE VAL.MARKET_PRICE_ID = p_MARKET_PRICE_ID
			AND VAL.PRICE_CODE = v_PRICE_CODE
			AND vAL.Price_Date BETWEEN v_DELETE_BEGIN AND v_DELETE_END;

	END IF;

	FOR v_FILL_DATE IN (SELECT * FROM TABLE(CAST(SP.GET_SCHEDULE_DATES(p_BEGIN_DATE,
														p_END_DATE,
														p_TIME_ZONE,
														p_TEMPLATE,
														p_BEGIN_HOUR,
														p_END_HOUR,
														p_INCLUDE_HOLIDAYS,
														p_INTERVAL, 0) AS DATE_COLLECTION)))
	LOOP

		UPDATE MARKET_PRICE_VALUE VAL
		SET VAL.PRICE = NVL(v_PRICE, VAL.PRICE),
			VAL.PRICE_BASIS = NVL(v_PRICE_BASIS, VAL.PRICE_BASIS)
		WHERE VAL.MARKET_PRICE_ID = p_MARKET_PRICE_ID
			AND VAL.PRICE_CODE = v_PRICE_CODE
			AND VAL.PRICE_DATE = v_FILL_DATE.COLUMN_VALUE;

		IF SQL%NOTFOUND THEN
			INSERT INTO MARKET_PRICE_VALUE (MARKET_PRICE_ID, PRICE_CODE,
				PRICE_DATE, AS_OF_DATE, PRICE, PRICE_BASIS)
			VALUES (p_MARKET_PRICE_ID, v_PRICE_CODE, v_FILL_DATE.COLUMN_VALUE,
				CONSTANTS.LOW_DATE, NVL(v_PRICE, 0), NVL(v_PRICE_BASIS, 0));
		END IF;
	END LOOP;
END FILL_MARKET_PRICE;
----------------------------------------------------------------------------------------------------
PROCEDURE PRODUCT_LIST
	(
	p_ENTITY_TYPE IN VARCHAR2,
	p_CATEGORY IN VARCHAR2,
	p_SEARCH_STRING IN VARCHAR2,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_SEARCH_STRING VARCHAR2(64) := GUI_UTIL.FIX_SEARCH_STRING(p_SEARCH_STRING);
BEGIN
	OPEN p_CURSOR FOR
		SELECT DISTINCT P.PRODUCT_NAME, P.PRODUCT_ID
		FROM PRODUCT P, COMPONENT C, PRODUCT_COMPONENT PC
		WHERE NVL(p_CATEGORY,CONSTANTS.ALL_STRING) IN (CONSTANTS.ALL_STRING, P.PRODUCT_CATEGORY)
			AND P.PRODUCT_NAME LIKE v_SEARCH_STRING
			AND p_ENTITY_TYPE IN (C.COMPONENT_ENTITY, CONSTANTS.ALL_STRING)
			AND PC.COMPONENT_ID = C.COMPONENT_ID
			AND PC.PRODUCT_ID = P.PRODUCT_ID
			AND (UPPER(C.RATE_STRUCTURE) IN (c_TOU_RATE_STRUCTURE, c_FLAT_RATE_STRUCTURE)
				OR (UPPER(C.RATE_STRUCTURE) = c_FORMULA_RATE_STRUCTURE AND
						EXISTS (SELECT 1
								FROM COMPONENT_FORMULA_VARIABLE CFV
								WHERE CFV.COMPONENT_ID = C.COMPONENT_ID
									AND UPPER(CFV.VARIABLE_NAME) = 'RATE')))
		ORDER BY 1;
END PRODUCT_LIST;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_RATE_MANAGEMENT_DETAILS
	(
	p_PRODUCT_ID IN NUMBER_COLLECTION,
	p_ENTITY_TYPE IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CURSOR OUT GA.REFCURSOR
	) AS

v_WORK_ID		NUMBER;
v_ENTITY_TYPE	COMPONENT.COMPONENT_ENTITY%TYPE := p_ENTITY_TYPE;

BEGIN
	IF p_ENTITY_TYPE IS NULL OR p_ENTITY_TYPE = CONSTANTS.ALL_STRING THEN
		v_ENTITY_TYPE := '%';
	END IF;

	-- Get all components associated with specified products. Show 'various' for product
	-- name and category if/when a single component is associated with more than one fo the
	-- selected products
	UT.GET_RTO_WORK_ID(v_WORK_ID);

	/* (SP)(BUG 26636) - THE COMINBINATION COMPONENTS IN THE RATE MANAGEMENT SCREEN IS NOT BRINGING IN ALL OF THE COMBINATION CHARGES IN THE DETAILS.
     * THIS CHANGE IS BASED ON SHELLY LINCOLN'S CUSTOM CHANGE IN BGE. SEE HERE MESSAGE BELOW
     */
        --SBL  ADD TO THE TABLE THE SUBCOMPONENTS THAT MAKE UP COMBINATION COMPONENTS
    --11/3/2010
    INSERT INTO RTO_WORK(WORK_ID, WORK_SEQ, WORK_XID, WORK_DATA, WORK_DATA2)
    SELECT DISTINCT v_WORK_ID,
        COMPONENT_ID,
        CASE WHEN PRODUCT_ID1 <> PRODUCT_ID2 THEN -1 ELSE PRODUCT_ID1 END as PRODUCT_ID,
        CASE WHEN PRODUCT_ID1 <> PRODUCT_ID2 THEN '<Multiple>' ELSE PRODUCT_NAME END as PRODUCT_NAME,
        CASE WHEN CATEGORY1 <> CATEGORY2 THEN '<Multiple>' ELSE CATEGORY1 END as PRODUCT_CATEGORY
    FROM (SELECT PC.COMPONENT_ID,
            MIN(P.PRODUCT_ID) as PRODUCT_ID1,
            MAX(P.PRODUCT_ID) as PRODUCT_ID2,
            MAX(P.PRODUCT_NAME) as PRODUCT_NAME,
            MIN(P.PRODUCT_CATEGORY) as CATEGORY1,
            MAX(P.PRODUCT_CATEGORY) as CATEGORY2
        FROM TABLE(CAST(p_PRODUCT_ID AS NUMBER_COLLECTION)) X,
            PRODUCT_COMPONENT PC,
            PRODUCT P,
            COMPONENT C
        WHERE PC.PRODUCT_ID = X.COLUMN_VALUE
            AND P.PRODUCT_ID = PC.PRODUCT_ID
            AND PC.COMPONENT_ID = C.COMPONENT_ID
            AND C.RATE_STRUCTURE <> 'Combination'
        GROUP BY PC.COMPONENT_ID)

    UNION ALL

    SELECT DISTINCT v_WORK_ID,
        COMPONENT_ID,
        CASE WHEN PRODUCT_ID1 <> PRODUCT_ID2 THEN -1 ELSE PRODUCT_ID1 END as PRODUCT_ID,
        CASE WHEN PRODUCT_ID1 <> PRODUCT_ID2 THEN '<Multiple>' ELSE PRODUCT_NAME END as PRODUCT_NAME,
        CASE WHEN CATEGORY1 <> CATEGORY2 THEN '<Multiple>' ELSE CATEGORY1 END as PRODUCT_CATEGORY
    FROM (SELECT C2.COMPONENT_ID,
            MIN(P.PRODUCT_ID) as PRODUCT_ID1,
            MAX(P.PRODUCT_ID) as PRODUCT_ID2,
            MAX(P.PRODUCT_NAME) as PRODUCT_NAME,
            MIN(P.PRODUCT_CATEGORY) as CATEGORY1,
            MAX(P.PRODUCT_CATEGORY) as CATEGORY2
        FROM TABLE(CAST(p_PRODUCT_ID AS NUMBER_COLLECTION)) X,
            PRODUCT_COMPONENT PC,
            PRODUCT P,
            COMPONENT C1,
            COMPONENT C2,
            COMPONENT_COMBINATION CC
        WHERE PC.PRODUCT_ID = X.COLUMN_VALUE
            AND P.PRODUCT_ID = PC.PRODUCT_ID
            AND PC.COMPONENT_ID = C1.COMPONENT_ID
            AND C1.RATE_STRUCTURE = 'Combination'
            AND C1.COMPONENT_ID = CC.COMPONENT_ID
            AND CC.COMBINED_COMPONENT_ID = C2.COMPONENT_ID
        GROUP BY C2.COMPONENT_ID);

	-- Select Component rate information
	OPEN p_CURSOR FOR
		SELECT WRK.WORK_DATA2 PRODUCT_CATEGORY,
			WRK.WORK_XID PRODUCT_ID,
			WRK.WORK_DATA PRODUCT_NAME,
			C.COMPONENT_ID,
			C.COMPONENT_NAME,
			C.COMPONENT_ENTITY,
			C.RATE_STRUCTURE,
			C.CHARGE_TYPE,
			C.RATE_INTERVAL,
			C.QUANTITY_UNIT,
			C.CURRENCY_UNIT,
			C.IS_TAXED,
			NULL PERIOD_ID,
			'NA' PERIOD_NAME,
			CFR.RATE,
			CFR.CHARGE_MIN,
			NULL as VAR_NAME,
			CFR.BEGIN_DATE,
			CFR.END_DATE,
			AUDIT_TRAIL.GET_WHEN_CHANGED('COMPONENT_FLAT_RATE',
				'COMPONENT_ID', NULL, CFR.COMPONENT_ID, NULL,
				'SUB_COMPONENT_TYPE', CONSTANTS.UNDEFINED_ATTRIBUTE, NULL, NULL,
				'SUB_COMPONENT_ID', NULL, CONSTANTS.NOT_ASSIGNED, NULL,
				'BEGIN_DATE', NULL, NULL, CFR.BEGIN_DATE) as LAST_CHANGED,
			AUDIT_TRAIL.GET_WHO_CHANGED('COMPONENT_FLAT_RATE',
				'COMPONENT_ID', NULL, CFR.COMPONENT_ID, NULL,
				'SUB_COMPONENT_TYPE', CONSTANTS.UNDEFINED_ATTRIBUTE, NULL, NULL,
				'SUB_COMPONENT_ID', NULL, CONSTANTS.NOT_ASSIGNED, NULL,
				'BEGIN_DATE', NULL, NULL, CFR.BEGIN_DATE) as LAST_CHANGED_BY
		FROM COMPONENT C,
			COMPONENT_FLAT_RATE CFR,
			RTO_WORK WRK
		WHERE C.COMPONENT_ID = WRK.WORK_SEQ
			AND UPPER(C.RATE_STRUCTURE) = c_FLAT_RATE_STRUCTURE
			AND UPPER(C.CHARGE_TYPE) != 'TAX'
			AND C.IS_CUSTOM_CHARGE = 0
			AND C.COMPONENT_ENTITY LIKE v_ENTITY_TYPE
			AND CFR.COMPONENT_ID = C.COMPONENT_ID
			AND CFR.SUB_COMPONENT_TYPE = CONSTANTS.UNDEFINED_ATTRIBUTE
			AND CFR.SUB_COMPONENT_ID = CONSTANTS.NOT_ASSIGNED
			AND CFR.BEGIN_DATE <= p_END_DATE
			AND NVL(CFR.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
		UNION
		SELECT WRK.WORK_DATA2 PRODUCT_CATEGORY,
			WRK.WORK_XID PRODUCT_ID,
			WRK.WORK_DATA PRODUCT_NAME,
			C.COMPONENT_ID,
			C.COMPONENT_NAME,
			C.COMPONENT_ENTITY,
			C.RATE_STRUCTURE,
			C.CHARGE_TYPE,
			C.RATE_INTERVAL,
			C.QUANTITY_UNIT,
			C.CURRENCY_UNIT,
			C.IS_TAXED,
			P.PERIOD_ID, -- period
			P.PERIOD_NAME,
			CTR.RATE,
			CTR.CHARGE_MIN,
			NULL as VAR_NAME,
			CTR.BEGIN_DATE,
			CTR.END_DATE,
			AUDIT_TRAIL.GET_WHEN_CHANGED('COMPONENT_TOU_RATE',
				'COMPONENT_ID', NULL, CTR.COMPONENT_ID, NULL,
				'SUB_COMPONENT_TYPE', CONSTANTS.UNDEFINED_ATTRIBUTE, NULL, NULL,
				'SUB_COMPONENT_ID', NULL, CONSTANTS.NOT_ASSIGNED, NULL,
				'PERIOD_ID', NULL, CTR.PERIOD_ID, NULL,
				'BEGIN_DATE', NULL, NULL, CTR.BEGIN_DATE) as LAST_CHANGED,
			AUDIT_TRAIL.GET_WHO_CHANGED('COMPONENT_TOU_RATE',
				'COMPONENT_ID', NULL, CTR.COMPONENT_ID, NULL,
				'SUB_COMPONENT_TYPE', CONSTANTS.UNDEFINED_ATTRIBUTE, NULL, NULL,
				'SUB_COMPONENT_ID', NULL, CONSTANTS.NOT_ASSIGNED, NULL,
				'PERIOD_ID', NULL, CTR.PERIOD_ID, NULL,
				'BEGIN_DATE', NULL, NULL, CTR.BEGIN_DATE) as LAST_CHANGED_BY
		FROM COMPONENT C,
			COMPONENT_TOU_RATE CTR,
			RTO_WORK WRK,
			PERIOD P
		WHERE C.COMPONENT_ID = WRK.WORK_SEQ
			AND UPPER(C.RATE_STRUCTURE) = c_TOU_RATE_STRUCTURE
			AND UPPER(C.CHARGE_TYPE) != 'TAX'
			AND C.IS_CUSTOM_CHARGE = 0
			AND C.COMPONENT_ENTITY LIKE v_ENTITY_TYPE
			AND CTR.COMPONENT_ID = C.COMPONENT_ID
			AND CTR.SUB_COMPONENT_TYPE = CONSTANTS.UNDEFINED_ATTRIBUTE
			AND CTR.SUB_COMPONENT_ID = CONSTANTS.NOT_ASSIGNED
			AND CTR.BEGIN_DATE <= p_END_DATE
			AND NVL(CTR.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND P.PERIOD_ID = CTR.PERIOD_ID
		UNION
		SELECT WRK.WORK_DATA2 PRODUCT_CATEGORY,
			WRK.WORK_XID PRODUCT_ID,
			WRK.WORK_DATA PRODUCT_NAME,
			C.COMPONENT_ID,
			C.COMPONENT_NAME,
			C.COMPONENT_ENTITY,
			C.RATE_STRUCTURE,
			C.CHARGE_TYPE,
			C.RATE_INTERVAL,
			C.QUANTITY_UNIT,
			C.CURRENCY_UNIT,
			C.IS_TAXED,
			NULL as PERIOD_ID,
			'NA' as PERIOD_NAME,
			UT.CUSTOM_TO_NUMBER(CFV.FORMULA) RATE,
			NULL as CHARGE_MIN,
			CFV.VARIABLE_NAME as VAR_NAME,
			CFV.BEGIN_DATE,
			CFV.END_DATE,
			AUDIT_TRAIL.GET_WHEN_CHANGED('COMPONENT_FORMULA_VARIABLE',
				'COMPONENT_ID', NULL, CFV.COMPONENT_ID, NULL,
				'SUB_COMPONENT_TYPE', CONSTANTS.UNDEFINED_ATTRIBUTE, NULL, NULL,
				'SUB_COMPONENT_ID', NULL, CONSTANTS.NOT_ASSIGNED, NULL,
				'VARIABLE_NAME', CFV.VARIABLE_NAME, NULL, NULL,
				'BEGIN_DATE', NULL, NULL, CFV.BEGIN_DATE) as LAST_CHANGED,
			AUDIT_TRAIL.GET_WHO_CHANGED('COMPONENT_FORMULA_VARIABLE',
				'COMPONENT_ID', NULL, CFV.COMPONENT_ID, NULL,
				'SUB_COMPONENT_TYPE', CONSTANTS.UNDEFINED_ATTRIBUTE, NULL, NULL,
				'SUB_COMPONENT_ID', NULL, CONSTANTS.NOT_ASSIGNED, NULL,
				'VARIABLE_NAME', CFV.VARIABLE_NAME, NULL, NULL,
				'BEGIN_DATE', NULL, NULL, CFV.BEGIN_DATE) as LAST_CHANGED_BY
		FROM COMPONENT C,
			COMPONENT_FORMULA_VARIABLE CFV,
			RTO_WORK WRK
		WHERE C.COMPONENT_ID = WRK.WORK_SEQ
			AND UPPER(C.RATE_STRUCTURE) = c_FORMULA_RATE_STRUCTURE
			AND UPPER(C.CHARGE_TYPE) != 'TAX'
			AND C.IS_CUSTOM_CHARGE = 0
			AND C.COMPONENT_ENTITY LIKE v_ENTITY_TYPE
			AND CFV.COMPONENT_ID = C.COMPONENT_ID
			AND CFV.SUB_COMPONENT_TYPE = CONSTANTS.UNDEFINED_ATTRIBUTE
			AND CFV.SUB_COMPONENT_ID = CONSTANTS.NOT_ASSIGNED
			AND UPPER(CFV.VARIABLE_NAME) = 'RATE'
			AND CFV.BEGIN_DATE <= p_END_DATE
			AND NVL(CFV.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
			AND UT.CUSTOM_TO_NUMBER(CFV.FORMULA) IS NOT NULL;

		UT.PURGE_RTO_WORK(v_WORK_ID);

END GET_RATE_MANAGEMENT_DETAILS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_RATE_MANAGEMENT
	(
	p_COMPONENT_ID IN NUMBER,
	p_PERIOD_ID IN VARCHAR2,
	p_RATE IN NUMBER,
	p_CHARGE_MIN IN NUMBER,
	p_VAR_NAME IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_OLD_BEGIN_DATE IN DATE,
	p_OLD_PERIOD_ID IN NUMBER
	) AS

v_RATE_STRUCTURE	COMPONENT.RATE_STRUCTURE%TYPE;
v_STATUS			NUMBER;

BEGIN

	SELECT C.RATE_STRUCTURE
	INTO v_RATE_STRUCTURE
	FROM COMPONENT C
	WHERE C.COMPONENT_ID = p_COMPONENT_ID;

	IF UPPER(v_RATE_STRUCTURE) = c_TOU_RATE_STRUCTURE THEN
		PUT_COMPONENT_TOU_RATE(p_COMPONENT_ID, CONSTANTS.UNDEFINED_ATTRIBUTE, CONSTANTS.NOT_ASSIGNED, p_PERIOD_ID, p_BEGIN_DATE,
			p_END_DATE, p_RATE, p_CHARGE_MIN, p_OLD_PERIOD_ID, p_OLD_BEGIN_DATE, v_STATUS);
		ERRS.VALIDATE_STATUS('PR.PUT_COMPONENT_TOU_RATE', v_STATUS);
	ELSIF UPPER(v_RATE_STRUCTURE) = c_FLAT_RATE_STRUCTURE THEN
		PUT_COMPONENT_FLAT_RATE(p_COMPONENT_ID, CONSTANTS.UNDEFINED_ATTRIBUTE, CONSTANTS.NOT_ASSIGNED, p_BEGIN_DATE, p_END_DATE, p_CHARGE_MIN, p_RATE, p_OLD_BEGIN_DATE, v_STATUS);
		ERRS.VALIDATE_STATUS('PR.PUT_COMPONENT_FLAT_RATE', v_STATUS);
	ELSIF UPPER(v_RATE_STRUCTURE) = c_FORMULA_RATE_STRUCTURE THEN
		DECLARE
			v_COMMENTS	COMPONENT_FORMULA_VARIABLE.COMMENTS%TYPE;
			v_ROWNBR	COMPONENT_FORMULA_VARIABLE.ROW_NUMBER%TYPE;
			v_VWORDER	COMPONENT_FORMULA_VARIABLE.VIEW_ORDER%TYPE;
			v_PERSIST	COMPONENT_FORMULA_VARIABLE.PERSIST_VALUE%TYPE;
			v_COUNT		PLS_INTEGER := 0;
		BEGIN
			IF p_OLD_BEGIN_DATE IS NOT NULL THEN
				-- look up other values from specified record
				SELECT MAX(COMMENTS), MAX(ROW_NUMBER), MAX(VIEW_ORDER), MAX(PERSIST_VALUE), COUNT(1)
				INTO v_COMMENTS, v_ROWNBR, v_VWORDER, v_PERSIST, v_COUNT
				FROM COMPONENT_FORMULA_VARIABLE
				WHERE COMPONENT_ID = p_COMPONENT_ID
					AND SUB_COMPONENT_TYPE = CONSTANTS.UNDEFINED_ATTRIBUTE
					AND SUB_COMPONENT_ID = CONSTANTS.NOT_ASSIGNED
					AND VARIABLE_NAME = p_VAR_NAME
					AND BEGIN_DATE = p_OLD_BEGIN_DATE;
			END IF;
			-- no record(s) found? find latest entry for this variable, and get values from there
			IF v_COUNT = 0 THEN
				SELECT MAX(COMMENTS), MAX(ROW_NUMBER), MAX(VIEW_ORDER), MAX(PERSIST_VALUE)
				INTO v_COMMENTS, v_ROWNBR, v_VWORDER, v_PERSIST
				FROM (SELECT COMMENTS, ROW_NUMBER, VIEW_ORDER, PERSIST_VALUE
						FROM COMPONENT_FORMULA_VARIABLE
						WHERE COMPONENT_ID = p_COMPONENT_ID
							AND SUB_COMPONENT_TYPE = CONSTANTS.UNDEFINED_ATTRIBUTE
							AND SUB_COMPONENT_ID = CONSTANTS.NOT_ASSIGNED
							AND VARIABLE_NAME = p_VAR_NAME
						ORDER BY BEGIN_DATE DESC)
				WHERE ROWNUM=1;
			END IF;

			PUT_COMPONENT_FORMULA_VARIABLE(p_COMPONENT_ID, CONSTANTS.UNDEFINED_ATTRIBUTE, CONSTANTS.NOT_ASSIGNED, p_VAR_NAME, p_BEGIN_DATE, p_END_DATE, p_RATE, 0, 0, v_COMMENTS, v_ROWNBR, v_VWORDER, v_PERSIST, p_VAR_NAME, p_OLD_BEGIN_DATE);
		END;
	END IF;

END PUT_RATE_MANAGEMENT;
----------------------------------------------------------------------------------------------------
PROCEDURE DELETE_RATE_MANAGEMENT
	(
	p_COMPONENT_ID IN NUMBER,
	p_PERIOD_ID IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_VAR_NAME IN VARCHAR2
	) AS

v_RATE_STRUCTURE	COMPONENT.RATE_STRUCTURE%TYPE;
v_STATUS			NUMBER;

BEGIN

	SELECT C.RATE_STRUCTURE
	INTO v_RATE_STRUCTURE
	FROM COMPONENT C
	WHERE C.COMPONENT_ID = p_COMPONENT_ID;

	IF UPPER(v_RATE_STRUCTURE) = c_TOU_RATE_STRUCTURE THEN
		DX.REMOVE_COMPONENT_TOU_RATE(p_COMPONENT_ID, CONSTANTS.UNDEFINED_ATTRIBUTE, CONSTANTS.NOT_ASSIGNED, p_PERIOD_ID, p_BEGIN_DATE, v_STATUS);
		ERRS.VALIDATE_STATUS('DX.REMOVE_COMPONENT_TOU_RATE', v_STATUS);
	ELSIF UPPER(v_RATE_STRUCTURE) = c_FLAT_RATE_STRUCTURE THEN
		DX.REMOVE_COMPONENT_FLAT_RATE(p_COMPONENT_ID, CONSTANTS.UNDEFINED_ATTRIBUTE, CONSTANTS.NOT_ASSIGNED, p_BEGIN_DATE, v_STATUS);
		ERRS.VALIDATE_STATUS('DX.REMOVE_COMPONENT_FLAT_RATE', v_STATUS);
	ELSIF UPPER(v_RATE_STRUCTURE) = c_FORMULA_RATE_STRUCTURE THEN
		DX.REMOVE_COMPONENT_FORMULA_VAR(p_COMPONENT_ID, CONSTANTS.UNDEFINED_ATTRIBUTE, CONSTANTS.NOT_ASSIGNED, p_VAR_NAME, p_BEGIN_DATE);
	END IF;

END DELETE_RATE_MANAGEMENT;
----------------------------------------------------------------------------------------------------
PROCEDURE PERIOD_LIST_FOR_COMPONENT
	(
	p_COMPONENT_ID IN NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS
v_RATE_STRUCTURE VARCHAR2(32);
BEGIN

	SELECT C.RATE_STRUCTURE
	INTO v_RATE_STRUCTURE
	FROM COMPONENT C
	WHERE C.COMPONENT_ID = p_COMPONENT_ID;

	IF UPPER(v_RATE_STRUCTURE) = c_TOU_RATE_STRUCTURE THEN
		OPEN p_CURSOR FOR
			SELECT DISTINCT P.PERIOD_NAME, P.PERIOD_ID
			FROM COMPONENT C,
				SEASON_TEMPLATE S,
				PERIOD P
			WHERE C.COMPONENT_ID = p_COMPONENT_ID
				AND S.TEMPLATE_ID = C.TEMPLATE_ID
				AND P.PERIOD_ID = S.PERIOD_ID;
	ELSE
		OPEN p_CURSOR FOR
			SELECT 'NA' as PERIOD_NAME, NULL as PERIOD_ID FROM DUAL;
	END IF;

END PERIOD_LIST_FOR_COMPONENT;
---------------------------------------------------------------------------------------------------
END PR;
/

