CREATE OR REPLACE PACKAGE BODY AUDIT_TRAIL IS

c_AUDIT_PREFIX CONSTANT VARCHAR2(4) := 'ZAU_';
---------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR2 IS
BEGIN
    RETURN '$Revision: 1.11 $';
END WHAT_VERSION;
---------------------------------------------------------------------------------------------------
FUNCTION CREATE_AUDIT_TABLE_NAME(p_ORIGINAL_TABLE_NAME IN VARCHAR2) RETURN VARCHAR2 AS
	v_MIRROR_TABLE_NAME SYSTEM_TABLE.DB_TABLE_NAME%TYPE;
	v_TABLE_NAME_EXISTS NUMBER(1) := 1;
	v_TABLE_COUNT       NUMBER(3) := 0;
BEGIN
	WHILE v_TABLE_NAME_EXISTS > 0 LOOP
		v_MIRROR_TABLE_NAME := SUBSTR(c_AUDIT_PREFIX || p_ORIGINAL_TABLE_NAME, 1, 27) || TO_CHAR(v_TABLE_COUNT);
		-- Look for name collision
		SELECT COUNT(T.TABLE_NAME)
		INTO v_TABLE_NAME_EXISTS
		FROM USER_TABLES T
		WHERE T.TABLE_NAME = v_MIRROR_TABLE_NAME;

		IF v_TABLE_NAME_EXISTS > 0 THEN
			v_TABLE_COUNT := v_TABLE_COUNT + 1;
		END IF;
	END LOOP;
	RETURN v_MIRROR_TABLE_NAME;
END CREATE_AUDIT_TABLE_NAME;
---------------------------------------------------------------------
PROCEDURE VALIDATE_SYSTEM_TABLE_PRIVS AS
v_COUNT NUMBER(9);
BEGIN
	-- Check CREATE TABLE
	SELECT COUNT(1)
	INTO v_COUNT
	FROM USER_SYS_PRIVS
	WHERE PRIVILEGE = 'CREATE TABLE';

	IF v_COUNT < 1 THEN
		ERRS.RAISE(MSGCODES.c_ERR_AUDIT_PRIVS, 'Unable to create Audit Table');
	END IF;

	-- Check CREATE TRIGGER
	SELECT COUNT(1)
	INTO v_COUNT
	FROM USER_SYS_PRIVS
	WHERE PRIVILEGE = 'CREATE TRIGGER';

	IF v_COUNT < 1 THEN
		ERRS.RAISE(MSGCODES.c_ERR_AUDIT_PRIVS, 'Unable to create Audit Trigger');
	END IF;

	-- Check CREATE PROCEDURE
	SELECT COUNT(1)
	INTO v_COUNT
	FROM USER_SYS_PRIVS
	WHERE PRIVILEGE = 'CREATE PROCEDURE';

	IF v_COUNT < 1 THEN
		ERRS.RAISE(MSGCODES.c_ERR_AUDIT_PRIVS, 'Unable to create Reactor Procedure');
	END IF;

END VALIDATE_SYSTEM_TABLE_PRIVS;
---------------------------------------------------------------------
FUNCTION IS_AUDIT_ENABLED
	(
	p_DB_TABLE_NAME     IN VARCHAR2,
	p_MIRROR_TABLE_NAME IN VARCHAR2
	) RETURN NUMBER AS
	v_TRIGGER_STATUS VARCHAR(10);
BEGIN
	SELECT MAX(T.STATUS)
	INTO v_TRIGGER_STATUS
	FROM USER_TRIGGERS T
	WHERE T.TRIGGER_NAME = p_MIRROR_TABLE_NAME
		  AND T.TABLE_NAME = p_DB_TABLE_NAME;
	RETURN CASE WHEN v_TRIGGER_STATUS = 'ENABLED' THEN 1 ELSE 0 END;
END IS_AUDIT_ENABLED;
---------------------------------------------------------------------
PROCEDURE GET_TABLE_LOCK_STATUS
	(
	p_TABLE_ID IN NUMBER,
	p_LOCKABLE OUT NUMBER,
	p_LOCKING_ENABLED OUT NUMBER
	) AS
	v_TRIGGER_STATUS VARCHAR(10);
	v_TABLE SYSTEM_TABLE%ROWTYPE;
	v_HAS_LOCK_STATE_COL BINARY_INTEGER;
BEGIN
	SELECT * INTO v_TABLE FROM SYSTEM_TABLE WHERE TABLE_ID = p_TABLE_ID;

	-- Guilty until proven innocent
	p_LOCKABLE := 0;
	p_LOCKING_ENABLED := 0;

	SELECT COUNT(1)
	INTO v_HAS_LOCK_STATE_COL
	FROM USER_TAB_COLUMNS
	WHERE TABLE_NAME = v_TABLE.DB_TABLE_NAME
		AND COLUMN_NAME = 'LOCK_STATE';

	IF v_HAS_LOCK_STATE_COL = 1 THEN
		SELECT MAX(T.STATUS)
		INTO v_TRIGGER_STATUS
		FROM USER_TRIGGERS T
		WHERE T.TRIGGER_NAME LIKE 'ZLK!_%' ESCAPE '!'
			AND T.TABLE_NAME = v_TABLE.DB_TABLE_NAME;

		IF v_TRIGGER_STATUS IS NOT NULL THEN
			-- A table is "Lockable" if it has the ZLK trigger and the LOCK_STATE column.
			p_LOCKABLE := 1;
			-- Locking is Enabled if the ZLK trigger is enabled.
			p_LOCKING_ENABLED := CASE WHEN v_TRIGGER_STATUS = 'ENABLED' THEN 1 ELSE 0 END;
		END IF;
	END IF;

END GET_TABLE_LOCK_STATUS;
---------------------------------------------------------------------
FUNCTION IS_TABLE_LOCKABLE
	(
	p_TABLE_ID IN NUMBER
	) RETURN NUMBER IS
	v_LOCKABLE BINARY_INTEGER;
	v_LOCKING_ENABLED BINARY_INTEGER;
BEGIN
	GET_TABLE_LOCK_STATUS(p_TABLE_ID, v_LOCKABLE, v_LOCKING_ENABLED);
	RETURN v_LOCKABLE;
END IS_TABLE_LOCKABLE;
---------------------------------------------------------------------
FUNCTION IS_TABLE_LOCKING_ENABLED
	(
	p_TABLE_ID IN NUMBER
	) RETURN NUMBER IS
	v_LOCKABLE BINARY_INTEGER;
	v_LOCKING_ENABLED BINARY_INTEGER;
BEGIN
	GET_TABLE_LOCK_STATUS(p_TABLE_ID, v_LOCKABLE, v_LOCKING_ENABLED);
	RETURN v_LOCKING_ENABLED;
END IS_TABLE_LOCKING_ENABLED;
---------------------------------------------------------------------
PROCEDURE GET_TABLES
	(
	p_TABLE_ID 	IN NUMBER,
	p_CURSOR 	OUT GA.REFCURSOR
	) AS
BEGIN

	OPEN p_CURSOR FOR
		SELECT T.TABLE_NAME AS NAME
		FROM USER_TABLES T
		WHERE T.TEMPORARY = 'N'
			AND NOT EXISTS
				(SELECT 1 FROM SYSTEM_TABLE X
				WHERE X.TABLE_ID <> p_TABLE_ID
					AND (X.DB_TABLE_NAME = T.TABLE_NAME OR X.LOCK_SUMMARY_TABLE_NAME = T.TABLE_NAME))
		ORDER BY 1;

END GET_TABLES;
---------------------------------------------------------------------
PROCEDURE GET_LOCK_SUMMARY_TABLES
	(
	p_TABLE_ID 	IN NUMBER,
	p_CURSOR 	OUT GA.REFCURSOR
	) AS
	v_PATTERN VARCHAR2(64);
BEGIN
	-- A new Entity does not yet have a table id.
	IF p_TABLE_ID <= 0 THEN
		OPEN p_CURSOR FOR
			SELECT NULL FROM DUAL
			WHERE 1 = 0;
		RETURN;
	END IF;

	--Get the pattern that the Lock Summary table needs to match.
	-- For example, the pattern created for IT_ASSIGNMENT_SCHEDULE
	-- would be I.*_A.*_S.*_L.*_S.*
	-- (Notice it is getting the first character after each underscore or the beginning
	--   of the string and tossing the rest.)
	SELECT '^'||REGEXP_REPLACE(DB_TABLE_NAME,'(^|_)(.)[^_]*','\1\2[^_]*') || '_L.*_S.*'
	INTO v_PATTERN
	FROM SYSTEM_TABLE
	WHERE TABLE_ID = p_TABLE_ID;

	OPEN p_CURSOR FOR
		SELECT T.TABLE_NAME AS NAME
		FROM USER_TABLES T
		WHERE T.TEMPORARY = 'N'
			AND REGEXP_LIKE(T.TABLE_NAME, v_PATTERN)
			AND NOT EXISTS
				(SELECT 1 FROM SYSTEM_TABLE X
				WHERE X.TABLE_ID <> p_TABLE_ID
					AND (X.DB_TABLE_NAME = T.TABLE_NAME OR X.LOCK_SUMMARY_TABLE_NAME = T.TABLE_NAME))
		ORDER BY 1;

END GET_LOCK_SUMMARY_TABLES;
---------------------------------------------------------------------
PROCEDURE GET_KEY_CONSTRAINTS
	(
	p_TABLE_NAME IN VARCHAR2,
	p_CURSOR     OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT A.INDEX_NAME
		FROM USER_INDEXES A, USER_IND_COLUMNS B
		WHERE A.TABLE_NAME = p_TABLE_NAME
			  AND A.UNIQUENESS = 'UNIQUE'
			  AND B.INDEX_NAME = A.INDEX_NAME
		GROUP BY A.INDEX_NAME
		ORDER BY COUNT(1) DESC, A.INDEX_NAME DESC;
END GET_KEY_CONSTRAINTS;
---------------------------------------------------------------------
PROCEDURE GET_TABLE_KEY_COLUMNS
	(
	p_TABLE_NAME          IN VARCHAR2,
	p_KEY_CONSTRAINT_NAME IN VARCHAR2,
	p_CURSOR              OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT C.COLUMN_NAME
		FROM USER_IND_COLUMNS C
		WHERE C.INDEX_NAME = p_KEY_CONSTRAINT_NAME
			  AND C.TABLE_NAME = p_TABLE_NAME
		ORDER BY 1 DESC;
END GET_TABLE_KEY_COLUMNS;
---------------------------------------------------------------------
PROCEDURE GET_TABLE_DATE_COLUMNS
	(
	p_TABLE_NAME          IN VARCHAR2,
	p_CURSOR              OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT C.COLUMN_NAME
		FROM USER_TAB_COLUMNS C
		WHERE C.TABLE_NAME = p_TABLE_NAME
			AND C.DATA_TYPE = 'DATE'
		ORDER BY 1 DESC;
END GET_TABLE_DATE_COLUMNS;
---------------------------------------------------------------------
PROCEDURE CREATE_AUDIT_TABLE
	(
	p_DB_TABLE_NAME     IN VARCHAR2,
	p_MIRROR_TABLE_NAME IN VARCHAR2
	) AS
	v_SQL VARCHAR2(4000);
BEGIN
	-- TODO: include other characteristics for the database table in the future (ie. tablespace)
	-- Create Table
	-- Start with the standard Audit Columns
	v_SQL := 'CREATE TABLE ' || p_MIRROR_TABLE_NAME || ' ';
	v_SQL := v_SQL || '(ZAU_ID NUMBER(18) NOT NULL,ZAU_OPERATION CHAR(1) NOT NULL,';
	v_SQL := v_SQL ||
			 'ZAU_TIMESTAMP TIMESTAMP NOT NULL,ZAU_PROCESS_ID NUMBER(12) NOT NULL,ZAU_SIBLING_ID NUMBER(18)';

	-- Fetch all columns from the original table
	FOR v_COL IN (SELECT C.COLUMN_NAME, C.DATA_TYPE, C.DATA_LENGTH, C.DATA_PRECISION, C.DATA_SCALE, C.NULLABLE
				  FROM USER_TAB_COLS C
				  WHERE C.TABLE_NAME = p_DB_TABLE_NAME
				  ORDER BY C.COLUMN_ID) LOOP
		v_SQL := v_SQL || ', ' || TRIM(v_COL.COLUMN_NAME);
		v_SQL := v_SQL || ' ' || TRIM(v_COL.DATA_TYPE);

		IF v_COL.DATA_PRECISION > 0 THEN
			v_SQL := v_SQL || '(' || TRIM(v_COL.DATA_PRECISION);
			IF v_COL.DATA_SCALE > 0 THEN
				v_SQL := v_SQL || ',' || TRIM(v_COL.DATA_SCALE);
			END IF;
			v_SQL := v_SQL || ')';
		ELSIF v_COL.DATA_LENGTH > 0 AND INSTR(v_COL.DATA_TYPE, 'CHAR') > 0 THEN
			v_SQL := v_SQL || '(' || TRIM(v_COL.DATA_LENGTH) || ')';
		END IF;

		IF v_COL.NULLABLE = 'N' THEN
			v_SQL := v_SQL || ' ' || 'NOT NULL';
		END IF;
	END LOOP;

	v_SQL := v_SQL || ')';
	LOGS.LOG_INFO_MORE_DETAIL('Audit Trail - Create Table: ' || v_SQL);
	EXECUTE IMMEDIATE v_SQL;
END CREATE_AUDIT_TABLE;
---------------------------------------------------------------------
PROCEDURE CREATE_AUDIT_TABLE_PK(p_MIRROR_TABLE_NAME IN VARCHAR2) AS
	v_SQL VARCHAR2(128);
BEGIN
	-- TODO: include other characteristics for the primary key in the future (ie. tablespace)
	SELECT 'ALTER TABLE ' || p_MIRROR_TABLE_NAME || ' ADD CONSTRAINT PK_ZAU_' || AUDIT_KEY.NEXTVAL ||
		   ' PRIMARY KEY (ZAU_ID)'
	INTO v_SQL
	FROM DUAL;
	LOGS.LOG_INFO_MORE_DETAIL('Audit Trail - Create PK: ' || v_SQL);
	EXECUTE IMMEDIATE v_SQL;
END CREATE_AUDIT_TABLE_PK;
---------------------------------------------------------------------
PROCEDURE CREATE_AUDIT_TABLE_FK(p_MIRROR_TABLE_NAME IN VARCHAR2) AS
	v_SQL VARCHAR2(256);
BEGIN
	-- TODO: include other characteristics for the foreign key in the future (ie. tablespace)
	SELECT 'ALTER TABLE ' || p_MIRROR_TABLE_NAME || ' ADD CONSTRAINT FK_ZAU_' || AUDIT_KEY.NEXTVAL ||
		   ' FOREIGN KEY (ZAU_PROCESS_ID) REFERENCES PROCESS_LOG(PROCESS_ID)'
	INTO v_SQL
	FROM DUAL;
	LOGS.LOG_INFO_MORE_DETAIL('Audit Trail - Create FK: ' || v_SQL);
	EXECUTE IMMEDIATE v_SQL;
END CREATE_AUDIT_TABLE_FK;
---------------------------------------------------------------------
PROCEDURE CREATE_AUDIT_TABLE_PID_INDEX(p_MIRROR_TABLE_NAME IN VARCHAR2) AS
	v_SQL VARCHAR2(128);
BEGIN
	-- TODO: include other characteristics for the index in the future (ie. tablespace)
	SELECT 'CREATE INDEX ZAU_PROCESS_ID_IX' || AUDIT_KEY.NEXTVAL || ' ON ' || p_MIRROR_TABLE_NAME ||
		   '(ZAU_PROCESS_ID)'
	INTO v_SQL
	FROM DUAL;
	LOGS.LOG_INFO_MORE_DETAIL('Audit Trail - Create Process Id Index: ' || v_SQL);
	EXECUTE IMMEDIATE v_SQL;
END CREATE_AUDIT_TABLE_PID_INDEX;
---------------------------------------------------------------------
PROCEDURE CREATE_AUDIT_TABLE_INDEX
	(
	p_SYSTEM_TABLE IN SYSTEM_TABLE%ROWTYPE
	) AS
	v_SQL                VARCHAR2(512);
	v_COLS               VARCHAR(128);
	v_IDX                NUMBER(9);
	v_EXCLUDE_COLS       STRING_COLLECTION;
	v_CONSTRAINT_COLUMNS STRING_COLLECTION := STRING_COLLECTION();
BEGIN
	-- TODO: include other characteristics for the index in the future (ie. tablespace)
	v_SQL := 'CREATE INDEX ' || p_SYSTEM_TABLE.MIRROR_TABLE_NAME || ' ON ' || p_SYSTEM_TABLE.MIRROR_TABLE_NAME || '(';

	IF NOT p_SYSTEM_TABLE.ENTITY_ID_COLUMN_NAME IS NULL THEN
		v_COLS := p_SYSTEM_TABLE.ENTITY_ID_COLUMN_NAME;
	END IF;

	IF NOT p_SYSTEM_TABLE.DATE1_COLUMN_NAME IS NULL THEN
		IF v_COLS IS NOT NULL THEN
			v_COLS := v_COLS || ',';
		END IF;
		v_COLS := v_COLS || p_SYSTEM_TABLE.DATE1_COLUMN_NAME;
	END IF;

	IF NOT p_SYSTEM_TABLE.DATE2_COLUMN_NAME IS NULL THEN
		IF LENGTH(v_COLS) > 0 THEN
			v_COLS := v_COLS || ',';
		END IF;
		v_COLS := v_COLS || p_SYSTEM_TABLE.DATE2_COLUMN_NAME;
	END IF;

	v_SQL := v_SQL || v_COLS;

	UT.STRING_COLLECTION_FROM_STRING(v_COLS, ',', v_EXCLUDE_COLS);

	-- Get a list of all key constraint columns in the original table
	-- NOTE: This collection will exclude the p_ENTITY_ID_COLUMN_NAME, p_DATE1_COLUMN_NAME, and p_DATE2_COLUMN_NAME
	SELECT C.COLUMN_NAME BULK COLLECT
	INTO v_CONSTRAINT_COLUMNS
	FROM USER_IND_COLUMNS C
	WHERE C.TABLE_NAME = p_SYSTEM_TABLE.DB_TABLE_NAME
		  AND C.INDEX_NAME = p_SYSTEM_TABLE.KEY_CONSTRAINT_NAME
		  AND C.COLUMN_NAME NOT IN (SELECT COLUMN_VALUE FROM TABLE(CAST(v_EXCLUDE_COLS AS STRING_COLLECTION)))
	ORDER BY C.COLUMN_POSITION;

	IF v_CONSTRAINT_COLUMNS.COUNT > 0 THEN
		-- Loop over the remaining columns in the key and add to the SQL text
		v_IDX := v_CONSTRAINT_COLUMNS.FIRST;
		WHILE v_CONSTRAINT_COLUMNS.EXISTS(v_IDX) LOOP

			-- IT'S POSSIBLE WE DIDN'T HAVE ANY COLUMNS PRIOR TO THIS, SO DON'T START WITH A ','
			IF v_COLS IS NOT NULL OR v_IDX <> v_CONSTRAINT_COLUMNS.FIRST THEN
				v_SQL := v_SQL || ',';
			END IF;

			v_SQL := v_SQL || v_CONSTRAINT_COLUMNS(v_IDX);
			v_IDX := v_CONSTRAINT_COLUMNS.NEXT(v_IDX);
		END LOOP;
	END IF;

	v_SQL := v_SQL || ')';

	LOGS.LOG_INFO_MORE_DETAIL('Audit Trail - Create Non-Unique Index: ' || v_SQL);
	EXECUTE IMMEDIATE v_SQL;
END CREATE_AUDIT_TABLE_INDEX;
---------------------------------------------------------------------
PROCEDURE SET_AUDIT_TRIGGER_ENABLED
	(
	p_MIRROR_TABLE_NAME IN VARCHAR2,
	p_AUDIT_ENABLED     IN NUMBER
	) AS
	v_SQL VARCHAR2(128);
BEGIN
	v_SQL := 'ALTER TRIGGER ' || p_MIRROR_TABLE_NAME || ' ' || CASE WHEN p_AUDIT_ENABLED = 1 THEN 'ENABLE' ELSE 'DISABLE' END;
	LOGS.LOG_INFO_MORE_DETAIL('Audit Trail - Enable/Disable Audit Trigger: ' || v_SQL);
	EXECUTE IMMEDIATE v_SQL;
END SET_AUDIT_TRIGGER_ENABLED;
---------------------------------------------------------------------
PROCEDURE SET_LOCK_TRIGGER_ENABLED
	(
	p_DB_TABLE_NAME IN VARCHAR2,
	p_LOCKING_ENABLED IN NUMBER
	) AS
	v_TRIGGER_NAME VARCHAR2(30);
	v_SQL VARCHAR2(128);
BEGIN

	BEGIN
		SELECT TRIGGER_NAME INTO v_TRIGGER_NAME
		FROM USER_TRIGGERS T
		WHERE T.TRIGGER_NAME LIKE 'ZLK!_%' ESCAPE '!'
			AND T.TABLE_NAME = p_DB_TABLE_NAME;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			--If there is no lock trigger, that's okay.
			ERRS.LOG_AND_CONTINUE('Lock trigger starting with ZLK_ for table '||p_DB_TABLE_NAME||' does not exist.', LOGS.c_LEVEL_DEBUG);
			RETURN;
	END;

	v_SQL := 'ALTER TRIGGER ' || v_TRIGGER_NAME || ' ' || CASE WHEN p_LOCKING_ENABLED = 1 THEN 'ENABLE' ELSE 'DISABLE' END;
	LOGS.LOG_INFO_MORE_DETAIL('Audit Trail - Enable/Disable Lock Trigger: ' || v_SQL);
	EXECUTE IMMEDIATE v_SQL;
END SET_LOCK_TRIGGER_ENABLED;
---------------------------------------------------------------------
PROCEDURE CREATE_AUDIT_TRIGGER
	(
	p_SYSTEM_TABLE IN SYSTEM_TABLE%ROWTYPE
	) AS
	v_SQL                    VARCHAR2(32767);
	v_IDX                    NUMBER(9);
	v_COLUMNS                STRING_COLLECTION := STRING_COLLECTION();
	v_CONSTRAINT_COLUMNS     STRING_COLLECTION := STRING_COLLECTION();
	v_NON_CONSTRAINT_COLUMNS STRING_COLLECTION := STRING_COLLECTION();
	v_DEBUG_CLOB             CLOB;
	v_TRIGGER_ENABLED        NUMBER(1);

	-- Helper for adding a line of text to the trigger.
	PROCEDURE PUT
	(
		p_TEXT    IN VARCHAR2 := NULL,
		p_NEWLINE IN BOOLEAN := TRUE
	) AS
		v_TEXT VARCHAR2(32767) := CASE WHEN p_NEWLINE THEN p_TEXT || CHR(10) ELSE p_TEXT END;
	BEGIN
		IF v_TEXT IS NULL THEN
			RETURN;
		END IF;
		v_SQL := v_SQL || v_TEXT;
	END PUT;

	PROCEDURE BUILD_INSERT_STMT
	(
		v_OLD_OR_NEW     IN VARCHAR2,
		v_OPERATION      IN CHAR,
		v_INDENT         IN VARCHAR2 := '		',
		v_ZAU_ID_VAR     IN VARCHAR2 := 'AID.NEXTVAL',
		v_SIBLING_ID_VAR IN VARCHAR2 := 'NULL'
	) AS
	BEGIN
		PUT(v_INDENT || 'INSERT INTO ' || p_SYSTEM_TABLE.MIRROR_TABLE_NAME);
		PUT(v_INDENT || '	(ZAU_ID,');
		PUT(v_INDENT || ' 	 ZAU_OPERATION,');
		PUT(v_INDENT || ' 	 ZAU_TIMESTAMP,');
		PUT(v_INDENT || ' 	 ZAU_PROCESS_ID,');
		PUT(v_INDENT || ' 	 ZAU_SIBLING_ID,');

		-- Remaining Orginal Table Columns
		v_IDX := v_COLUMNS.FIRST;
		WHILE v_COLUMNS.EXISTS(v_IDX) LOOP
			PUT(v_INDENT || ' 	 ' || v_COLUMNS(v_IDX) || CASE WHEN v_IDX = v_COLUMNS.LAST THEN ')' ELSE ',' END);
			v_IDX := v_COLUMNS.NEXT(v_IDX);
		END LOOP;

		PUT(v_INDENT || 'VALUES');
		PUT(v_INDENT || '	(' || v_ZAU_ID_VAR || ',');
		PUT(v_INDENT || '	 ''' || v_OPERATION || ''',');
		PUT(v_INDENT || '	 v_TS,');
		PUT(v_INDENT || '	 v_PROC_ID,');
		PUT(v_INDENT || '	 ' || v_SIBLING_ID_VAR || ',');

		-- Remaining Orginal Columns Values
		v_IDX := v_COLUMNS.FIRST;
		WHILE v_COLUMNS.EXISTS(v_IDX) LOOP
			PUT(v_INDENT || ' 	 :' || v_OLD_OR_NEW || '.' || v_COLUMNS(v_IDX) || CASE WHEN v_IDX = v_COLUMNS.LAST THEN ');' ELSE ',' END);
			v_IDX := v_COLUMNS.NEXT(v_IDX);
		END LOOP;

		-- Handle Reactor Table insert if this is a Reactive System Table.
		IF UT.BOOLEAN_FROM_NUMBER(p_SYSTEM_TABLE.IS_REACTIVE) THEN
			PUT(v_INDENT||'INSERT INTO REACTOR_PENDING (TABLE_ID, ZAU_ID) VALUES('||p_SYSTEM_TABLE.TABLE_ID||', '||REPLACE(v_ZAU_ID_VAR, '.NEXTVAL','.CURRVAL')||');');
		END IF;

	END BUILD_INSERT_STMT;

BEGIN
	-- Get a list of all columns in the original table
	SELECT C.COLUMN_NAME BULK COLLECT INTO v_COLUMNS FROM USER_TAB_COLUMNS C WHERE C.TABLE_NAME = p_SYSTEM_TABLE.DB_TABLE_NAME;

	-- Get a list of all key constraint columns in the original table
	SELECT C.COLUMN_NAME BULK COLLECT
	INTO v_CONSTRAINT_COLUMNS
	FROM USER_IND_COLUMNS C
	WHERE C.TABLE_NAME = p_SYSTEM_TABLE.DB_TABLE_NAME
		  AND C.INDEX_NAME = p_SYSTEM_TABLE.KEY_CONSTRAINT_NAME
	ORDER BY C.COLUMN_POSITION;

	-- Get a list of all NON key constraint columns in the original table
	SELECT A.COLUMN_NAME BULK COLLECT
	INTO v_NON_CONSTRAINT_COLUMNS
	FROM (SELECT C.COLUMN_NAME
		  FROM USER_TAB_COLUMNS C
		  WHERE C.TABLE_NAME = p_SYSTEM_TABLE.DB_TABLE_NAME
		  MINUS
		  SELECT C.COLUMN_NAME
		  FROM USER_IND_COLUMNS C
		  WHERE C.TABLE_NAME = p_SYSTEM_TABLE.DB_TABLE_NAME
				AND C.INDEX_NAME = p_SYSTEM_TABLE.KEY_CONSTRAINT_NAME) A;

	-- If the trigger already exists, get its state so we do not lose it.  Default to disabled.
	SELECT CASE NVL(MAX(STATUS), 'DISABLED') WHEN 'ENABLED' THEN 1 ELSE 0 END
	INTO v_TRIGGER_ENABLED
	FROM USER_TRIGGERS T
	WHERE T.TRIGGER_NAME = p_SYSTEM_TABLE.MIRROR_TABLE_NAME;

	-- Create Trigger
	-- Trigger Header
	PUT('CREATE OR REPLACE TRIGGER ' || p_SYSTEM_TABLE.MIRROR_TABLE_NAME);
	PUT('	AFTER INSERT OR UPDATE OR DELETE ON ' || p_SYSTEM_TABLE.DB_TABLE_NAME);
	PUT('	FOR EACH ROW');
	PUT('DECLARE');
	PUT('	v_TS      TIMESTAMP;');
	PUT('	v_PROC_ID PROCESS_LOG.PROCESS_ID%TYPE;');
	PUT('BEGIN');
	PUT('	v_TS := SYSTIMESTAMP;');
	PUT('	v_PROC_ID := LOGS.CURRENT_PROCESS_ID;');
	-- Handle Inserts
	PUT('	IF INSERTING THEN');
	PUT('		-- Handle Insert.');
	BUILD_INSERT_STMT('NEW', 'I');
	-- Handle Updates
	PUT('	ELSIF UPDATING THEN');
	PUT('		-- Handle Update.');
	-- Handle Updates: Create an IF statement that checks to see if any of the Key Columns changed
	PUT('		-- Check to see if any key columns changed.');
	v_IDX := v_CONSTRAINT_COLUMNS.FIRST;
	WHILE v_CONSTRAINT_COLUMNS.EXISTS(v_IDX) LOOP
		PUT('		' || CASE WHEN v_IDX = v_CONSTRAINT_COLUMNS.FIRST THEN 'IF ' ELSE ''
			END || '((:NEW.' || v_CONSTRAINT_COLUMNS(v_IDX) || ' IS NULL AND :OLD.' || v_CONSTRAINT_COLUMNS(v_IDX) ||
			' IS NULL) ' || 'OR :NEW.' || v_CONSTRAINT_COLUMNS(v_IDX) || ' = :OLD.' || v_CONSTRAINT_COLUMNS(v_IDX) || ')' || CASE WHEN
			v_IDX = v_CONSTRAINT_COLUMNS.LAST THEN ' THEN' ELSE ' AND' END);
		v_IDX := v_CONSTRAINT_COLUMNS.NEXT(v_IDX);
	END LOOP;
	-- Handle Updates: Create an IF statement that checks for no-op updates
	PUT('			-- Check no-op update.');
	v_IDX := v_NON_CONSTRAINT_COLUMNS.FIRST;
	WHILE v_NON_CONSTRAINT_COLUMNS.EXISTS(v_IDX) LOOP
		PUT('			' || CASE WHEN v_IDX = v_NON_CONSTRAINT_COLUMNS.FIRST THEN 'IF ' ELSE ''
			END || 'NOT ((:NEW.' || v_NON_CONSTRAINT_COLUMNS(v_IDX) || ' IS NULL AND :OLD.' ||
			v_NON_CONSTRAINT_COLUMNS(v_IDX) || ' IS NULL) ' || 'OR :NEW.' || v_NON_CONSTRAINT_COLUMNS(v_IDX) ||
			' = :OLD.' || v_NON_CONSTRAINT_COLUMNS(v_IDX) || ')' || CASE WHEN
			v_IDX = v_NON_CONSTRAINT_COLUMNS.LAST THEN ' THEN' ELSE ' OR' END);
		v_IDX := v_NON_CONSTRAINT_COLUMNS.NEXT(v_IDX);
	END LOOP;
	BUILD_INSERT_STMT('NEW', 'U', '				');
	PUT('			END IF;');
	PUT('		ELSE');
	PUT('			DECLARE');
	PUT('				v_ID1 ' || p_SYSTEM_TABLE.MIRROR_TABLE_NAME || '.ZAU_ID%TYPE;');
	PUT('				v_ID2 ' || p_SYSTEM_TABLE.MIRROR_TABLE_NAME || '.ZAU_ID%TYPE;');
	PUT('			BEGIN');
	PUT('				SELECT AID.NEXTVAL INTO v_ID1 FROM DUAL;');
	PUT('				SELECT AID.NEXTVAL INTO v_ID2 FROM DUAL;');
	BUILD_INSERT_STMT('OLD', 'X', '				', 'v_ID1', 'v_ID2');
	BUILD_INSERT_STMT('NEW', 'K', '				', 'v_ID2', 'v_ID1');
	PUT('			END;');
	PUT('		END IF;');
	-- Handle Deletes
	PUT('	ELSE');
	PUT('		-- Handle Delete.');
	BUILD_INSERT_STMT('OLD', 'D');
	PUT('	END IF;');
	PUT('END;');

	DBMS_LOB.CREATETEMPORARY(v_DEBUG_CLOB, TRUE);
	DBMS_LOB.OPEN(v_DEBUG_CLOB, DBMS_LOB.LOB_READWRITE);
	LOGS.LOG_INFO_MORE_DETAIL('Audit Trail - Creating Audit Trigger (see Attachment).');
	DBMS_LOB.WRITEAPPEND(v_DEBUG_CLOB, LENGTH(v_SQL), v_SQL);
	LOGS.POST_EVENT_DETAILS('TRIGGER', CONSTANTS.MIME_TYPE_TEXT, v_DEBUG_CLOB);
	DBMS_LOB.CLOSE(v_DEBUG_CLOB);

	EXECUTE IMMEDIATE v_SQL;

	--Set the state to whatever it was before, or DISABLED if this is a new trigger.
	SET_AUDIT_TRIGGER_ENABLED(p_SYSTEM_TABLE.MIRROR_TABLE_NAME, v_TRIGGER_ENABLED);

END CREATE_AUDIT_TRIGGER;
---------------------------------------------------------------------
PROCEDURE CREATE_REACTOR_PROC
	(
	p_SYSTEM_TABLE IN SYSTEM_TABLE%ROWTYPE
	) AS
	v_SQL                    VARCHAR2(32767);
	v_IDX                    NUMBER(9);
	v_COLUMNS                STRING_COLLECTION := STRING_COLLECTION();
	v_COLUMN_TYPES           STRING_COLLECTION := STRING_COLLECTION();
	v_DEBUG_CLOB             CLOB;

	-- Helper for adding a line of text.
	PROCEDURE PUT
	(
		p_TEXT    IN VARCHAR2 := NULL,
		p_NEWLINE IN BOOLEAN := TRUE
	) AS
		v_TEXT VARCHAR2(32767) := CASE WHEN p_NEWLINE THEN p_TEXT || CHR(10) ELSE p_TEXT END;
	BEGIN
		IF v_TEXT IS NULL THEN
			RETURN;
		END IF;
		v_SQL := v_SQL || v_TEXT;
	END PUT;

BEGIN
	-- Get a list of all columns in the original table
	SELECT C.COLUMN_NAME,
		CASE WHEN C.DATA_TYPE IN ('DATE', 'NUMBER') THEN C.DATA_TYPE ELSE 'STRING' END
	BULK COLLECT INTO v_COLUMNS, v_COLUMN_TYPES
	FROM USER_TAB_COLUMNS C WHERE C.TABLE_NAME = p_SYSTEM_TABLE.DB_TABLE_NAME;

	-- Create Procedure
	-- Procedure Header
	PUT('CREATE OR REPLACE FUNCTION ZRE_' || SUBSTR(p_SYSTEM_TABLE.MIRROR_TABLE_NAME,5) ||' RETURN BINARY_INTEGER IS ');
	PUT('	v_MAP UT.STRING_MAP;');
	PUT('	v_COUNT BINARY_INTEGER := 0;');
	-- Cursor definition
	PUT('CURSOR v_DATA IS');
	PUT('	SELECT A.*', FALSE);
	v_IDX := v_COLUMNS.FIRST;
	WHILE v_COLUMNS.EXISTS(v_IDX) LOOP
		PUT(', ', FALSE);
		PUT('B.'||v_COLUMNS(v_IDX),FALSE);
		v_IDX := v_COLUMNS.NEXT(v_IDX);
	END LOOP;
	PUT('');
	PUT('	FROM REACTOR_PENDING A, '||p_SYSTEM_TABLE.MIRROR_TABLE_NAME||' B');
	PUT('	WHERE A.TABLE_ID='||p_SYSTEM_TABLE.TABLE_ID);
	PUT('		AND A.ZAU_ID = B.ZAU_ID');
	-- Ordered by ENTITY_ID to take advantage of caching of info for each entity in REACTOR package.
	IF p_SYSTEM_TABLE.ENTITY_ID_COLUMN_NAME IS NOT NULL THEN
		PUT('	ORDER BY B.'||p_SYSTEM_TABLE.ENTITY_ID_COLUMN_NAME);
	END IF;
	PUT('	FOR UPDATE OF A.TABLE_ID, A.ZAU_ID;');
	-- Procedure Body
	PUT('BEGIN');
	PUT('	FOR v_ROW IN v_DATA LOOP');
	v_IDX := v_COLUMNS.FIRST;
	WHILE v_COLUMNS.EXISTS(v_IDX) LOOP
		PUT('		v_MAP('''||v_COLUMNS(v_IDX)||''') := UT.GET_LITERAL_FOR_'||v_COLUMN_TYPES(v_IDX)||'(v_ROW.'||v_COLUMNS(v_IDX)||');');
		v_IDX := v_COLUMNS.NEXT(v_IDX);
	END LOOP;
	PUT('');
	PUT('		REACTOR.GENERATE_PROCEDURE_CALLS('''||p_SYSTEM_TABLE.DB_TABLE_NAME
		||CASE WHEN p_SYSTEM_TABLE.ENTITY_ID_COLUMN_NAME IS NULL THEN ''',NULL' ELSE ''',v_ROW.'||p_SYSTEM_TABLE.ENTITY_ID_COLUMN_NAME END
		||CASE WHEN p_SYSTEM_TABLE.DATE1_COLUMN_NAME IS NULL THEN ',NULL' ELSE ',v_ROW.'||p_SYSTEM_TABLE.DATE1_COLUMN_NAME END
		||CASE WHEN p_SYSTEM_TABLE.DATE2_COLUMN_NAME IS NULL AND p_SYSTEM_TABLE.DATE1_COLUMN_NAME IS NULL THEN ',NULL' ELSE ',v_ROW.'||NVL(p_SYSTEM_TABLE.DATE2_COLUMN_NAME,p_SYSTEM_TABLE.DATE1_COLUMN_NAME) END
		||',v_MAP);');
	PUT('		DELETE FROM REACTOR_PENDING WHERE CURRENT OF v_DATA;');
	PUT('		v_COUNT := v_COUNT + 1;');
	PUT('	END LOOP;');
	PUT('	RETURN v_COUNT;');
	PUT('END;');

	DBMS_LOB.CREATETEMPORARY(v_DEBUG_CLOB, TRUE);
	DBMS_LOB.OPEN(v_DEBUG_CLOB, DBMS_LOB.LOB_READWRITE);
	LOGS.LOG_INFO_MORE_DETAIL('Audit Trail - Creating Reactor Procedure (see Attachment).');
	DBMS_LOB.WRITEAPPEND(v_DEBUG_CLOB, LENGTH(v_SQL), v_SQL);
	LOGS.POST_EVENT_DETAILS('PROCEDURE', CONSTANTS.MIME_TYPE_TEXT, v_DEBUG_CLOB);
	DBMS_LOB.CLOSE(v_DEBUG_CLOB);

	EXECUTE IMMEDIATE v_SQL;

END CREATE_REACTOR_PROC;
---------------------------------------------------------------------
PROCEDURE DROP_REACTOR_PROC(p_MIRROR_TABLE_NAME IN VARCHAR2) AS
	v_SQL VARCHAR2(128);
	v_COUNT BINARY_INTEGER;
	v_PROC_NAME VARCHAR2(32) := 'ZRE_'||SUBSTR(p_MIRROR_TABLE_NAME,5);
BEGIN
	SELECT COUNT(1)
	INTO v_COUNT
	FROM USER_PROCEDURES P
	WHERE P.PROCEDURE_NAME = v_PROC_NAME;

	IF v_COUNT > 0 THEN
		v_SQL := 'DROP FUNCTION '||v_PROC_NAME;
		LOGS.LOG_INFO_MORE_DETAIL('Audit Trail - Dropping Reactor Procedure: ' || v_SQL);
		EXECUTE IMMEDIATE v_SQL;
		COMMIT;
	ELSE
		LOGS.LOG_DEBUG('DROP_REACTOR_PROC: Function ''' || v_PROC_NAME || ''' does not exist');
	END IF;

END DROP_REACTOR_PROC;
---------------------------------------------------------------------
PROCEDURE DROP_AUDIT_TABLE(p_MIRROR_TABLE_NAME IN VARCHAR2) AS
	v_SQL VARCHAR2(128);
	v_COUNT BINARY_INTEGER;
BEGIN
	SELECT COUNT(1)
	INTO v_COUNT
	FROM USER_TABLES T
	WHERE T.TABLE_NAME = p_MIRROR_TABLE_NAME;

	IF v_COUNT > 0 THEN
		v_SQL := 'DROP TABLE ' || p_MIRROR_TABLE_NAME;
		LOGS.LOG_INFO_MORE_DETAIL('Audit Trail - Dropping Audit Table: ' || v_SQL);
		EXECUTE IMMEDIATE v_SQL;
		COMMIT;
	ELSE
		LOGS.LOG_DEBUG('DROP_AUDIT_TABLE: Table ''' || p_MIRROR_TABLE_NAME || ''' does not exist');
	END IF;

END DROP_AUDIT_TABLE;
---------------------------------------------------------------------
PROCEDURE DROP_AUDIT_TABLE_INDEX(p_MIRROR_TABLE_NAME IN VARCHAR2) AS
	v_SQL VARCHAR2(128);
	v_COUNT BINARY_INTEGER;
BEGIN
	SELECT COUNT(1)
	INTO v_COUNT
	FROM USER_INDEXES I
	WHERE I.INDEX_NAME = p_MIRROR_TABLE_NAME;

	IF v_COUNT > 0 THEN
		v_SQL := 'DROP INDEX ' || p_MIRROR_TABLE_NAME;
		LOGS.LOG_INFO_MORE_DETAIL('Audit Trail - Dropping Audit Table Index: ' || v_SQL);
		EXECUTE IMMEDIATE v_SQL;
		COMMIT;
	ELSE
		LOGS.LOG_DEBUG('DROP_AUDIT_TABLE_INDEX: Index ''' || p_MIRROR_TABLE_NAME || ''' does not exist');
	END IF;

END DROP_AUDIT_TABLE_INDEX;
---------------------------------------------------------------------
PROCEDURE DROP_AUDIT_TRIGGER(p_MIRROR_TABLE_NAME IN VARCHAR2) AS
	v_SQL VARCHAR2(128);
	v_TRIGGER_COUNT NUMBER(1);
BEGIN
	SELECT COUNT(1)
	INTO v_TRIGGER_COUNT
	FROM USER_TRIGGERS T
	WHERE T.TRIGGER_NAME = p_MIRROR_TABLE_NAME;

	IF v_TRIGGER_COUNT > 0 THEN
		v_SQL := 'DROP TRIGGER ' || p_MIRROR_TABLE_NAME;
		LOGS.LOG_INFO_MORE_DETAIL('Audit Trail - Dropping Audit Trigger: ' || v_SQL);
		EXECUTE IMMEDIATE v_SQL;
		COMMIT;
	ELSE
		LOGS.LOG_DEBUG('DROP_AUDIT_TRIGGER: Trigger ''' || p_MIRROR_TABLE_NAME || ''' does not exist');
	END IF;

END DROP_AUDIT_TRIGGER;
---------------------------------------------------------------------
-- Rebuild the Index, Procedures, and Triggers for a System Table.
PROCEDURE REBUILD_TABLE_OBJECTS
	(
	p_SYSTEM_TABLE IN SYSTEM_TABLE%ROWTYPE,
	p_REBUILD_TRIGGER IN BOOLEAN,
	p_REBUILD_OTHER_OBJECTS IN BOOLEAN
	) AS
	v_STEP                      VARCHAR2(128);
BEGIN

	-- Update existing System Table entity and changed one of the key columns
	IF p_REBUILD_OTHER_OBJECTS THEN
		v_STEP := 'Dropping Old Audit Index for Key Constraint';
		DROP_AUDIT_TABLE_INDEX(p_SYSTEM_TABLE.MIRROR_TABLE_NAME);

		v_STEP := 'Recreating Audit Table Index for Key Constraint';
		CREATE_AUDIT_TABLE_INDEX(p_SYSTEM_TABLE);

		v_STEP := 'Recreating Reactor Procedure';
		CREATE_REACTOR_PROC(p_SYSTEM_TABLE);
	END IF;
	-- Rebuild trigger if reactive flag changed.
	IF p_REBUILD_TRIGGER THEN
		v_STEP := 'Recreating Audit Trigger for changed Is Reactive Flag';
		CREATE_AUDIT_TRIGGER(p_SYSTEM_TABLE);
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_RAISE('Error occurred while ' || v_STEP || ' for ' || p_SYSTEM_TABLE.TABLE_NAME || '.');
END REBUILD_TABLE_OBJECTS;
---------------------------------------------------------------------
-- Rebuilds the audit table index, procedure, and trigger for specified tables.
PROCEDURE REBUILD_TABLE_OBJECTS
	(
	p_DB_TABLE_NAMES	IN STRING_COLLECTION
	) AS
	CURSOR c_TABLES IS
		SELECT ST.*
		FROM SYSTEM_TABLE ST,
			TABLE(CAST(p_DB_TABLE_NAMES AS STRING_COLLECTION)) N
		WHERE ST.DB_TABLE_NAME = N.COLUMN_VALUE;
BEGIN
	-- first verify security
	FOR v_TABLE IN c_TABLES LOOP
		SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, v_TABLE.TABLE_ID, EC.ED_SYSTEM_TABLE);
	END LOOP;

	-- then, perform rebuild
	FOR v_TABLE IN c_TABLES LOOP
        BEGIN
	        REBUILD_TABLE_OBJECTS(v_TABLE, TRUE, TRUE);
        EXCEPTION
            WHEN OTHERS THEN
                ERRS.LOG_AND_CONTINUE('Error occurred while rebuilding objects for ' || v_TABLE.TABLE_NAME || '.');
        END;
	END LOOP;
END REBUILD_TABLE_OBJECTS;
---------------------------------------------------------------------
-- Rebuilds the audit table index, procedure, and trigger for all system tables.
PROCEDURE REBUILD_ALL_TABLE_OBJECTS AS
	CURSOR c_TABLES IS SELECT * FROM SYSTEM_TABLE;
BEGIN
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_ENT, SD.g_ALL_DATA_ENTITY_ID, EC.ED_SYSTEM_TABLE);
	FOR v_TABLE IN c_TABLES LOOP
        BEGIN
	        REBUILD_TABLE_OBJECTS(v_TABLE, TRUE, TRUE);
        EXCEPTION
            WHEN OTHERS THEN
                ERRS.LOG_AND_CONTINUE('Error occurred while rebuilding objects for ' || v_TABLE.TABLE_NAME || '.');
        END;
	END LOOP;
END REBUILD_ALL_TABLE_OBJECTS;
---------------------------------------------------------------------
PROCEDURE PUT_SYSTEM_TABLE
	(
	O_OID                     OUT NUMBER,
	p_TABLE_NAME              IN VARCHAR2,
	p_TABLE_ALIAS             IN VARCHAR2,
	p_TABLE_DESC              IN VARCHAR2,
	p_TABLE_ID                IN NUMBER,
	p_DB_TABLE_NAME           IN VARCHAR2,
	p_ENTITY_DOMAIN_ID        IN NUMBER,
	p_KEY_CONSTRAINT_NAME     IN VARCHAR2,
	p_ENTITY_ID_COLUMN_NAME   IN VARCHAR2,
	p_DATE1_COLUMN_NAME       IN VARCHAR2,
	p_DATE2_COLUMN_NAME       IN VARCHAR2,
	p_AUDIT_ENABLED           IN NUMBER,
	p_IS_REACTIVE             IN NUMBER,
	p_LOCK_SUMMARY_TABLE_NAME IN VARCHAR2,
	p_LOCKING_ENABLED         IN NUMBER
	) AS
	v_SYSTEM_TABLE              SYSTEM_TABLE%ROWTYPE;
	v_KEY_CONSTRAINT_NAME       SYSTEM_TABLE.KEY_CONSTRAINT_NAME%TYPE;
	v_MIRROR_TABLE_NAME         SYSTEM_TABLE.MIRROR_TABLE_NAME%TYPE;
	v_ENTITY_DOMAIN_ID          ENTITY_DOMAIN.ENTITY_DOMAIN_ID%TYPE;
	v_STEP                      VARCHAR2(128);
	v_REBUILD_INDEX             BOOLEAN := FALSE;
	v_REBUILD_TRIGGER           BOOLEAN := FALSE;
	v_TABLE_CREATED             BOOLEAN := FALSE;
	v_TRIGGER_CREATED           BOOLEAN := FALSE;
	v_PROC_CREATED              BOOLEAN := FALSE;
	v_STATUS                    NUMBER(9);
	v_TMP_COUNT					BINARY_INTEGER;
BEGIN
	v_ENTITY_DOMAIN_ID := p_ENTITY_DOMAIN_ID;
	v_KEY_CONSTRAINT_NAME := p_KEY_CONSTRAINT_NAME;
	v_STEP := 'Preparing for System Table';

	-- DB Table Name may not be null.
	ASSERT(p_DB_TABLE_NAME IS NOT NULL, 'The DB Table Name cannot be null.');

	-- Make sure Lock Summary Table Name does not match any DB Table Name.
	SELECT COUNT(1) INTO v_TMP_COUNT FROM SYSTEM_TABLE WHERE DB_TABLE_NAME = p_LOCK_SUMMARY_TABLE_NAME AND TABLE_ID <> p_TABLE_ID;
	IF v_TMP_COUNT > 0 OR p_LOCK_SUMMARY_TABLE_NAME = p_DB_TABLE_NAME THEN
		ERRS.RAISE_BAD_ARGUMENT('Lock Summary Table Name', p_LOCK_SUMMARY_TABLE_NAME, 'The Lock Summary Table Name cannot match the DB Table Name of any existing System Table.');
	END IF;

	-- Make sure DB Table Name does not match any Lock Summary Table Name.
	SELECT COUNT(1) INTO v_TMP_COUNT FROM SYSTEM_TABLE WHERE LOCK_SUMMARY_TABLE_NAME = p_DB_TABLE_NAME AND TABLE_ID <> p_TABLE_ID;
	IF v_TMP_COUNT > 0 THEN
		ERRS.RAISE_BAD_ARGUMENT('DB Table Name', p_DB_TABLE_NAME, 'The DB Table Name cannot match the Lock Summary Table Name of any existing System Table.');
	END IF;

	-- If we are updating an existing SYSTEM_TABLE then we need to check to see if the user
	-- is changing any of the key columns. If any of the key columns change then we need to
	-- rebuild the non-unique index on the existing audit table.
	IF p_TABLE_ID > 0 THEN
		SELECT * INTO v_SYSTEM_TABLE FROM SYSTEM_TABLE S WHERE S.TABLE_ID = p_TABLE_ID;

		IF p_DB_TABLE_NAME <> v_SYSTEM_TABLE.DB_TABLE_NAME THEN
			ERRS.RAISE_BAD_ARGUMENT('Database Table Name', p_DB_TABLE_NAME, 'The Database Table Name cannot be changed. You must delete the System Table and recreate it.');
		END IF;

		IF NOT ((p_ENTITY_ID_COLUMN_NAME IS NULL AND v_SYSTEM_TABLE.ENTITY_ID_COLUMN_NAME IS NULL) OR
			p_ENTITY_ID_COLUMN_NAME = v_SYSTEM_TABLE.ENTITY_ID_COLUMN_NAME) OR
		   NOT ((p_DATE1_COLUMN_NAME IS NULL AND v_SYSTEM_TABLE.DATE1_COLUMN_NAME IS NULL) OR
			p_DATE1_COLUMN_NAME = v_SYSTEM_TABLE.DATE1_COLUMN_NAME) OR
		   NOT ((p_DATE2_COLUMN_NAME IS NULL AND v_SYSTEM_TABLE.DATE2_COLUMN_NAME IS NULL) OR
			p_DATE2_COLUMN_NAME = v_SYSTEM_TABLE.DATE2_COLUMN_NAME) THEN
			v_REBUILD_INDEX := TRUE;
		END IF;

		--If the reactive flag is being changed, we must rebuild the trigger.
		IF v_SYSTEM_TABLE.IS_REACTIVE <> p_IS_REACTIVE THEN
			v_REBUILD_TRIGGER := TRUE;
		END IF;

		-- Since we are modifying an existing SYSTEM_TABLE, fetch the existing MIRROR_TABLE_NAME
		v_MIRROR_TABLE_NAME := v_SYSTEM_TABLE.MIRROR_TABLE_NAME;
	ELSE
		-- This be a new SYSTEM_TABLE, Generate a MIRROR_TABLE_NAME for the selected Table Name
		v_MIRROR_TABLE_NAME := CREATE_AUDIT_TABLE_NAME(p_DB_TABLE_NAME);
	END IF;

	-- Try to guess the Entity Domain if the user leaves it blank and specifies an ENTITY_COLUMN_NAME
	IF (v_ENTITY_DOMAIN_ID IS NULL OR v_ENTITY_DOMAIN_ID = CONSTANTS.NOT_ASSIGNED) AND
	   NOT p_ENTITY_ID_COLUMN_NAME IS NULL THEN

		v_ENTITY_DOMAIN_ID := ENTITY_UTIL.GET_REFERRED_DOMAIN_ID(p_ENTITY_ID_COLUMN_NAME, p_DB_TABLE_NAME);
	END IF;

	-- Try to guess at the KEY_CONSTRAINT_NAME if the user leaves it blank
	IF v_KEY_CONSTRAINT_NAME IS NULL THEN
		BEGIN
			SELECT INDEX_NAME
			INTO v_KEY_CONSTRAINT_NAME
			FROM (SELECT A.INDEX_NAME
				  FROM USER_INDEXES A, USER_IND_COLUMNS B
				  WHERE A.TABLE_NAME = p_DB_TABLE_NAME
						AND A.UNIQUENESS = 'UNIQUE'
						AND B.INDEX_NAME = A.INDEX_NAME
				  GROUP BY A.INDEX_NAME
				  ORDER BY COUNT(1) DESC, A.INDEX_NAME DESC)
			WHERE ROWNUM = 1;
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				ERRS.RAISE_BAD_ARGUMENT('p_KEY_CONSTRAINT_NAME', v_KEY_CONSTRAINT_NAME);
		END;
	END IF;

	v_STEP := 'Updating the System Table Entity';
	-- Update the SYSTEM_TABLE
	IO.PUT_SYSTEM_TABLE(O_OID,
						p_TABLE_NAME,
						p_TABLE_ALIAS,
						p_TABLE_DESC,
						p_TABLE_ID,
						p_DB_TABLE_NAME,
						v_MIRROR_TABLE_NAME,
						NVL(v_ENTITY_DOMAIN_ID, CONSTANTS.NOT_ASSIGNED),
						p_KEY_CONSTRAINT_NAME,
						p_ENTITY_ID_COLUMN_NAME,
						p_DATE1_COLUMN_NAME,
						p_DATE2_COLUMN_NAME,
						p_IS_REACTIVE,
						p_LOCK_SUMMARY_TABLE_NAME);

	SELECT * INTO v_SYSTEM_TABLE FROM SYSTEM_TABLE S WHERE S.TABLE_ID = O_OID;

	-- New System Table entity
	IF p_TABLE_ID = 0 THEN
		v_STEP := 'Validating Object Creation Privileges';
		VALIDATE_SYSTEM_TABLE_PRIVS();

		v_STEP := 'Creating Audit Table';
		CREATE_AUDIT_TABLE(p_DB_TABLE_NAME, v_MIRROR_TABLE_NAME);
		v_TABLE_CREATED := TRUE;

		v_STEP := 'Creating Audit Table Primary Key';
		CREATE_AUDIT_TABLE_PK(v_MIRROR_TABLE_NAME);

		v_STEP := 'Creating Audit Table Foriegn Key';
		CREATE_AUDIT_TABLE_FK(v_MIRROR_TABLE_NAME);

		v_STEP := 'Creating Audit Table Index for Process Id';
		CREATE_AUDIT_TABLE_PID_INDEX(v_MIRROR_TABLE_NAME);

		v_STEP := 'Creating Audit Table Index for Key Constraint';
		CREATE_AUDIT_TABLE_INDEX(v_SYSTEM_TABLE);

		v_STEP := 'Creating Audit Trigger';
		CREATE_AUDIT_TRIGGER(v_SYSTEM_TABLE);
		v_TRIGGER_CREATED := TRUE;

		v_STEP := 'Creating Reactor Procedure';
		CREATE_REACTOR_PROC(v_SYSTEM_TABLE);
		v_PROC_CREATED := TRUE;
	ELSE
		v_STEP := 'Rebuilding table objects';
		REBUILD_TABLE_OBJECTS(v_SYSTEM_TABLE, v_REBUILD_TRIGGER, v_REBUILD_INDEX);
	END IF;

	-- Enable or Disable the Audit Trigger based on the flag.
	v_STEP := 'Enabling/Disabling the Audit Trigger';
	SET_AUDIT_TRIGGER_ENABLED(v_MIRROR_TABLE_NAME, p_AUDIT_ENABLED);

	-- Enable or Disable the Lock Trigger based on the flag.
	v_STEP := 'Enabling/Disabling the Lock Trigger';
	SET_LOCK_TRIGGER_ENABLED(p_DB_TABLE_NAME, p_LOCKING_ENABLED);

EXCEPTION
	WHEN MSGCODES.e_ERR_AUDIT_PRIVS THEN
		RAISE;
	WHEN OTHERS THEN
		IF p_TABLE_ID = 0 THEN
			-- Programattically rollback the new SYSTEM_TABLE entity
			BEGIN
				IF O_OID > 0 THEN
					DE.DEL_SYSTEM_TABLE(O_OID, v_STATUS);
					COMMIT;
					LOGS.LOG_INFO_MORE_DETAIL('Deleted the SYSTEM TABLE with Id = ' || O_OID || ' and Status = ' ||
											  v_STATUS);
				END IF;
			EXCEPTION
				WHEN OTHERS THEN
					ERRS.LOG_AND_CONTINUE();
			END;

			IF v_TABLE_CREATED THEN
				-- Drop the table
				BEGIN
					DROP_AUDIT_TABLE(v_MIRROR_TABLE_NAME);
				EXCEPTION
					WHEN OTHERS THEN
						ERRS.LOG_AND_CONTINUE();
				END;
			END IF;

			IF v_TRIGGER_CREATED THEN
				-- Drop the trigger
				BEGIN
					DROP_AUDIT_TRIGGER(v_MIRROR_TABLE_NAME);
				EXCEPTION
					WHEN OTHERS THEN
						ERRS.LOG_AND_CONTINUE();
				END;
			END IF;

			IF v_PROC_CREATED THEN
				-- Drop the procedure
				BEGIN
					DROP_REACTOR_PROC(v_MIRROR_TABLE_NAME);
				EXCEPTION
					WHEN OTHERS THEN
						ERRS.LOG_AND_CONTINUE();
				END;
			END IF;
		END IF;
		ERRS.LOG_AND_CONTINUE();
		ERRS.RAISE(MSGCODES.c_ERR_GENERAL, 'Error occurred while ' || v_STEP || '.', TRUE);
END PUT_SYSTEM_TABLE;
---------------------------------------------------------------------
PROCEDURE GET_SYSTEM_TABLE
	(
	p_TABLE_ID                IN NUMBER,
	p_TABLE_NAME              OUT VARCHAR2,
	p_TABLE_ALIAS             OUT VARCHAR2,
	p_TABLE_DESC              OUT VARCHAR2,
	p_DB_TABLE_NAME           OUT VARCHAR2,
	p_MIRROR_TABLE_NAME       OUT VARCHAR2,
	p_ENTITY_DOMAIN_ID        OUT NUMBER,
	p_ENTITY_DOMAIN_DISP 	  OUT VARCHAR2,
	p_KEY_CONSTRAINT_NAME     OUT VARCHAR2,
	p_ENTITY_ID_COLUMN_NAME   OUT VARCHAR2,
	p_DATE1_COLUMN_NAME       OUT VARCHAR2,
	p_DATE2_COLUMN_NAME       OUT VARCHAR2,
	p_AUDIT_ENABLED           OUT NUMBER,
	p_IS_REACTIVE             OUT NUMBER,
	p_LOCKABLE                OUT NUMBER,
	p_LOCK_SUMMARY_TABLE_NAME OUT VARCHAR2,
	p_LOCKING_ENABLED         OUT NUMBER
	) AS
BEGIN

	EM_GET.SYSTEM_TABLE(p_TABLE_ID,
						p_TABLE_NAME,
						p_TABLE_ALIAS,
						p_TABLE_DESC,
						p_DB_TABLE_NAME,
						p_MIRROR_TABLE_NAME,
						p_ENTITY_DOMAIN_ID,
						p_ENTITY_DOMAIN_DISP,
						p_KEY_CONSTRAINT_NAME,
						p_ENTITY_ID_COLUMN_NAME,
						p_DATE1_COLUMN_NAME,
						p_DATE2_COLUMN_NAME,
						p_IS_REACTIVE,
						p_LOCK_SUMMARY_TABLE_NAME);

	p_AUDIT_ENABLED := IS_AUDIT_ENABLED(p_DB_TABLE_NAME, p_MIRROR_TABLE_NAME);
	GET_TABLE_LOCK_STATUS(p_TABLE_ID, p_LOCKABLE, p_LOCKING_ENABLED);

END GET_SYSTEM_TABLE;
---------------------------------------------------------------------
PROCEDURE DELETE_SYSTEM_TABLE
	(
	p_TABLE_ID          IN NUMBER,
	p_MESSAGE           OUT VARCHAR2
	) AS
v_MIRROR_TABLE_NAME	SYSTEM_TABLE.MIRROR_TABLE_NAME%TYPE;
v_STATUS			NUMBER;
BEGIN
	SELECT MIRROR_TABLE_NAME
	INTO v_MIRROR_TABLE_NAME
	FROM SYSTEM_TABLE
	WHERE TABLE_ID = p_TABLE_ID;

	DE.DEL_SYSTEM_TABLE(p_TABLE_ID, v_STATUS);
	ERRS.VALIDATE_STATUS('AUDIT_TRAIL.DELETE_SYSTEM_TABLE', v_STATUS);

	DROP_AUDIT_TRIGGER(v_MIRROR_TABLE_NAME);
	DROP_REACTOR_PROC(v_MIRROR_TABLE_NAME);
	p_MESSAGE := 'The System Table was deleted successfully. The ' || v_MIRROR_TABLE_NAME ||
				 ' Audit Table was preserved for historical purposes. The database administrator can drop this table if it is no longer needed.';
END DELETE_SYSTEM_TABLE;
---------------------------------------------------------------------
PROCEDURE ENTITY_DOMAIN_LIST
	(
	p_ALLOW_ALL IN NUMBER,
	p_CURSOR    OUT GA.REFCURSOR
	) AS
BEGIN

	IF p_ALLOW_ALL = 1 THEN
		OPEN p_CURSOR FOR
			SELECT CONSTANTS.ALL_STRING, CONSTANTS.ALL_ID
			FROM DUAL
			UNION ALL
			SELECT DISTINCT D.ENTITY_DOMAIN_NAME, D.ENTITY_DOMAIN_ID
			FROM SYSTEM_TABLE T, ENTITY_DOMAIN D
			WHERE T.ENTITY_DOMAIN_ID = D.ENTITY_DOMAIN_ID
              AND IS_AUDIT_ENABLED(T.DB_TABLE_NAME, T.MIRROR_TABLE_NAME) = 1
            ORDER BY 1;
	ELSE
		OPEN p_CURSOR FOR
			SELECT DISTINCT D.ENTITY_DOMAIN_NAME, D.ENTITY_DOMAIN_ID
			FROM SYSTEM_TABLE T, ENTITY_DOMAIN D
			WHERE T.ENTITY_DOMAIN_ID = D.ENTITY_DOMAIN_ID
              AND IS_AUDIT_ENABLED(T.DB_TABLE_NAME, T.MIRROR_TABLE_NAME) = 1
            ORDER BY 1;
	END IF;

END ENTITY_DOMAIN_LIST;
---------------------------------------------------------------------
PROCEDURE ENTITY_LIST
	(
	p_ALLOW_ALL         IN NUMBER,
	p_ENTITY_DOMAIN_IDS IN VARCHAR2,
	p_CURSOR            OUT GA.REFCURSOR
	) AS
	v_SQL                       VARCHAR2(4000) := CASE WHEN p_ALLOW_ALL = 1 THEN 'SELECT ''<All>'', -1 FROM DUAL' ELSE '' END;
	v_SINGLE_ENTITY_DOMAIN_ID   NUMBER(9);
	v_ENTITY_DOMAIN_TABLE       ENTITY_DOMAIN.ENTITY_DOMAIN_TABLE%TYPE;
	v_PRIMARY_ID_COLUMN			ENTITY_DOMAIN_PROPERTY.PRIMARY_ID_COLUMN%TYPE;
	v_PRIMARY_NAME_COLUMN		ENTITY_DOMAIN_PROPERTY.PRIMARY_NAME_COLUMN%TYPE;
BEGIN

	-- Only retrieve teh list of entities if a single Entity_Domain is selected, otherwise just return a single value for <All> entities
	IF p_ENTITY_DOMAIN_IDS IS NOT NULL AND INSTR(p_ENTITY_DOMAIN_IDS, ',') = 0 AND
	   REGEXP_INSTR(p_ENTITY_DOMAIN_IDS, '(,|^)' || CONSTANTS.ALL_STRING || '(,|$)') = 0 THEN

		BEGIN
			v_SINGLE_ENTITY_DOMAIN_ID := TO_NUMBER(TRIM(p_ENTITY_DOMAIN_IDS));
		EXCEPTION
			WHEN OTHERS THEN
				v_SINGLE_ENTITY_DOMAIN_ID := NULL;
		END;

		IF v_SINGLE_ENTITY_DOMAIN_ID IS NOT NULL AND v_SINGLE_ENTITY_DOMAIN_ID <> CONSTANTS.NOT_ASSIGNED THEN
			-- Since we need to build this query dynamically,
			-- fetch the name of the table and table alias for the selected ENTITY_DOMAIN
			SELECT MAX(P.ENTITY_DOMAIN_TABLE), MAX(P.PRIMARY_ID_COLUMN), MAX(P.PRIMARY_NAME_COLUMN)
			INTO v_ENTITY_DOMAIN_TABLE, v_PRIMARY_ID_COLUMN, v_PRIMARY_NAME_COLUMN
			FROM ENTITY_DOMAIN_PROPERTY P
			WHERE P.ENTITY_DOMAIN_ID = v_SINGLE_ENTITY_DOMAIN_ID;

			-- Check to see if we found a valid ENTITY_DOMAIN
			IF NOT v_ENTITY_DOMAIN_TABLE IS NULL AND NOT v_ENTITY_DOMAIN_TABLE IS NULL THEN
				IF p_ALLOW_ALL = 1 THEN
					v_SQL := v_SQL || ' UNION ALL ';
				END IF;
				v_SQL := v_SQL || 'SELECT ' || v_PRIMARY_NAME_COLUMN || ', ' ||
						 v_PRIMARY_ID_COLUMN || ' FROM (';
				v_SQL := v_SQL || 'SELECT ' || v_PRIMARY_NAME_COLUMN || ', ' ||
						 v_PRIMARY_ID_COLUMN;
				v_SQL := v_SQL || ' FROM ' || v_ENTITY_DOMAIN_TABLE || ' ORDER BY 1)';
			END IF;
		END IF;
	ELSE
		v_SQL := 'SELECT NULL FROM DUAL';
	END IF;

	OPEN p_CURSOR FOR v_SQL;

END ENTITY_LIST;
---------------------------------------------------------------------
PROCEDURE PURGE_AUDIT_TRAIL_WORK(p_WORK_ID IN NUMBER) AS
BEGIN
	DELETE AUDIT_TRAIL_WORK WHERE WORK_ID = p_WORK_ID;
END PURGE_AUDIT_TRAIL_WORK;
---------------------------------------------------------------------
FUNCTION GET_DISPLAY_EXPRESSION
	(
	p_TABLE_NAME IN VARCHAR2,
	p_COLUMN_NAME IN VARCHAR2,
	p_TBL_ALIAS IN VARCHAR2 := NULL,
	p_NAME_SUFFIX IN VARCHAR2 := '_NAME',
	p_ALLOW_ALL_ID IN BOOLEAN := FALSE
	) RETURN VARCHAR2 AS
	v_PREFIX				VARCHAR2(4000) := CASE WHEN p_TBL_ALIAS IS NULL THEN NULL ELSE p_TBL_ALIAS||'.' END;
	v_ENTITY_DOMAIN_INFO	ENTITY_UTIL.ENTITY_DOMAIN_INFO;
	FUNCTION ADD_ALL_EXPRESSION(p_EXPRESSION IN VARCHAR2) RETURN VARCHAR2 IS
	BEGIN
		IF p_ALLOW_ALL_ID THEN
			RETURN 'CASE WHEN '||v_PREFIX||p_COLUMN_NAME||' = '||CONSTANTS.ALL_ID||
					' THEN '''||CONSTANTS.ALL_STRING||''' ELSE '||p_EXPRESSION||' END';
		ELSE
			RETURN p_EXPRESSION;
		END IF;
	END ADD_ALL_EXPRESSION;
BEGIN
	CASE
	-- Custom mapping for STATEMENT_TYPE and SCHEDULE_TYPE
	WHEN p_COLUMN_NAME IN ('STATEMENT_TYPE', 'SCHEDULE_TYPE') THEN
		RETURN ADD_ALL_EXPRESSION('(SELECT ST.STATEMENT_TYPE_NAME FROM STATEMENT_TYPE ST WHERE ST.STATEMENT_TYPE_ID = '||
				 					v_PREFIX||p_COLUMN_NAME|| ')')
					||' AS '||p_COLUMN_NAME||p_NAME_SUFFIX;

	-- Custom mapping for STATEMENT_STATE and SCHEDULE_STATE
	WHEN p_COLUMN_NAME IN ('STATEMENT_STATE','SCHEDULE_STATE') THEN
		RETURN ADD_ALL_EXPRESSION('CASE WHEN '||v_PREFIX||p_COLUMN_NAME||
								 ' = 1 THEN ''Internal'' ELSE ''External'' END')
					||' AS '||p_COLUMN_NAME;

	-- Resolve entity references
	WHEN SUBSTR(p_COLUMN_NAME,-3) = '_ID' THEN
		v_ENTITY_DOMAIN_INFO := ENTITY_UTIL.GET_REFERRED_DOMAIN_INFO(p_COLUMN_NAME, p_TABLE_NAME);
		IF v_ENTITY_DOMAIN_INFO.ENTITY_DOMAIN_ID IS NOT NULL THEN
			RETURN ADD_ALL_EXPRESSION('ENTITY_NAME_FROM_IDS('||v_ENTITY_DOMAIN_INFO.ENTITY_DOMAIN_ID|| ', '||
									v_PREFIX||p_COLUMN_NAME||')')
						||' AS '||SUBSTR(p_COLUMN_NAME,1,LENGTH(p_COLUMN_NAME)-3)||p_NAME_SUFFIX;
		ELSE
			RETURN ADD_ALL_EXPRESSION(v_PREFIX||p_COLUMN_NAME)||' AS '||p_COLUMN_NAME;
		END IF;

	-- Just show raw value if we can't map it to a display name
	ELSE
		RETURN v_PREFIX||p_COLUMN_NAME;

	END CASE;
END GET_DISPLAY_EXPRESSION;
---------------------------------------------------------------------
PROCEDURE SUMMARY_MASTER_REPORT
	(
	p_BEGIN_DATE        IN DATE,
	p_END_DATE          IN DATE,
	p_ENTITY_DOMAIN_IDS IN VARCHAR2,
	p_ENTITY_IDS        IN VARCHAR2,
	p_USER_ID           IN NUMBER,
	p_PROCESS_ID        IN VARCHAR2,
	p_CURSOR            OUT GA.REFCURSOR
	) AS
	v_USER_ID                PROCESS_LOG.USER_ID%TYPE;
	v_PROCESS_ID             PROCESS_LOG.PROCESS_ID%TYPE;
	v_ENTITY_DOMAIN_ID_TABLE ID_TABLE;
	v_SQL                    VARCHAR2(4000);
	v_WORK_ID                AUDIT_TRAIL_WORK.WORK_ID%TYPE;
	v_ALL_ENTITIES			 BOOLEAN := FALSE;
	v_BY_PROCESS_ID			 BOOLEAN := FALSE;
	v_CURRENT_USER_ID		 NUMBER(9) := SECURITY_CONTROLS.CURRENT_USER_ID;
	v_ROLES 				 ID_TABLE := SECURITY_CONTROLS.CURRENT_ROLES;
	v_USING_DLS				 BOOLEAN;
	v_ALLOWED_ENTITIES 		 ID_TABLE;
	v_CUR_ENTITY_DOMAIN		 NUMBER(9);
	v_LAST_ENTITY_DOMAIN 	 NUMBER(9);

	CURSOR c_SYSTEM_TABLES IS
		SELECT A.MIRROR_TABLE_NAME, A.ENTITY_DOMAIN_ID, A.ENTITY_ID_COLUMN_NAME
		FROM SYSTEM_TABLE A, TABLE(CAST(v_ENTITY_DOMAIN_ID_TABLE AS ID_TABLE)) IDS
		WHERE IDS.ID IN (A.ENTITY_DOMAIN_ID, CONSTANTS.ALL_ID)
		ORDER BY A.ENTITY_DOMAIN_ID;
BEGIN
-- Default the User Id and Process Id to <All> if null
	v_USER_ID := NVL(p_USER_ID, CONSTANTS.ALL_ID);
	v_PROCESS_ID := NVL(TO_NUMBER(p_PROCESS_ID), CONSTANTS.ALL_ID);

-- Determine if we are querying by Process Id Only
	IF p_BEGIN_DATE IS NULL AND p_END_DATE IS NULL AND v_USER_ID = CONSTANTS.ALL_ID AND v_PROCESS_ID IS NOT NULL AND NOT v_PROCESS_ID = CONSTANTS.ALL_ID THEN
		v_BY_PROCESS_ID := TRUE;
	END IF;

-- Build Table of Entity Domains
	IF (p_ENTITY_DOMAIN_IDS IS NOT NULL) AND
	   REGEXP_INSTR(p_ENTITY_DOMAIN_IDS, '(,|^)' || CONSTANTS.ALL_ID || '(,|$)') = 0 THEN
		UT.ID_TABLE_FROM_STRING(p_ENTITY_DOMAIN_IDS, ',', v_ENTITY_DOMAIN_ID_TABLE);
	ELSE
		-- Use <All>
		v_ENTITY_DOMAIN_ID_TABLE := ID_TABLE();
		v_ENTITY_DOMAIN_ID_TABLE.EXTEND();
		v_ENTITY_DOMAIN_ID_TABLE(1) := ID_TYPE(CONSTANTS.ALL_ID);
	END IF;

-- Check to see if we have a list of enitites or are we including <All> entities
	IF p_ENTITY_IDS IS NULL OR
	   REGEXP_INSTR(p_ENTITY_IDS, '(,|^)' || CONSTANTS.ALL_ID || '(,|$)') > 0 THEN
		v_ALL_ENTITIES := TRUE;
	END IF;

-- Begin Building Dynamic Query
	UT.GET_RTO_WORK_ID(v_WORK_ID);

	-- Loop over each SYSTEM_TABLE and Insert the AUDIT_DATE, ENTITY_DOMAIN_ID, NUM_CHANGES
	FOR v_SYSTEM_TABLE IN c_SYSTEM_TABLES LOOP
		v_CUR_ENTITY_DOMAIN := v_SYSTEM_TABLE.ENTITY_DOMAIN_ID;

		-- Only fetch a new list of entities if this is a different Entity Domain
		IF v_LAST_ENTITY_DOMAIN IS NULL OR v_LAST_ENTITY_DOMAIN <> v_CUR_ENTITY_DOMAIN THEN
			-- First, Get the list of entities that this user has access to
			v_ALLOWED_ENTITIES := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_SELECT_AUDIT, v_CUR_ENTITY_DOMAIN);
			-- Check to see if this user has access to All Entities
			v_USING_DLS := v_ALLOWED_ENTITIES IS NULL OR v_ALLOWED_ENTITIES.COUNT = 0 OR v_ALLOWED_ENTITIES(v_ALLOWED_ENTITIES.FIRST).ID <> SD.g_ALL_DATA_ENTITY_ID;
		END IF;

		v_SQL := 'INSERT INTO AUDIT_TRAIL_WORK(WORK_ID, AUDIT_DATE, ENTITY_DOMAIN_ID, NUM_CHANGES)';
		-- Query to rollup the number of entities affected by date and entity_domain
		v_SQL := v_SQL || ' SELECT ' || v_WORK_ID || ', A.AUDIT_DATE, ' || v_CUR_ENTITY_DOMAIN ||
				 ', COUNT(A.ENTITY_ID)';
		v_SQL := v_SQL || ' FROM (';
		-- Inner Query to get the distinct Entities that were affected
		v_SQL := v_SQL || 'SELECT DISTINCT TRUNC(X.ZAU_TIMESTAMP) AS AUDIT_DATE, X.' ||
				 v_SYSTEM_TABLE.ENTITY_ID_COLUMN_NAME || ' AS ENTITY_ID';
		v_SQL := v_SQL || ' FROM ' || v_SYSTEM_TABLE.MIRROR_TABLE_NAME || ' X';

		IF v_BY_PROCESS_ID THEN
			IF v_USING_DLS THEN
				v_SQL := v_SQL || ', PROCESS_LOG P';
				v_SQL := v_SQL || ' WHERE X.ZAU_PROCESS_ID = P.PROCESS_ID';
				v_SQL := v_SQL || ' AND (P.USER_ID = ' || v_CURRENT_USER_ID || ' OR';
				v_SQL := v_SQL || ' X.' || v_SYSTEM_TABLE.ENTITY_ID_COLUMN_NAME || ' = IDS.ID)';
				v_SQL := v_SQL || ' AND X.ZAU_PROCESS_ID = ' || v_PROCESS_ID;
			ELSE
				v_SQL := v_SQL || ' WHERE X.ZAU_PROCESS_ID = ' || v_PROCESS_ID;
			END IF;
		ELSE
			-- Inner Query to get the matching processes
			v_SQL := v_SQL ||  ', (SELECT PROCESS_ID, USER_ID FROM PROCESS_LOG';
			v_SQL := v_SQL || ' WHERE PROCESS_START_TIME <= :END_DATE + 1';
			v_SQL := v_SQL || ' AND PROCESS_STOP_TIME >= :BEGIN_DATE';

			-- Only include User Id and Process Id if they are not <All>
			IF v_USER_ID <> CONSTANTS.ALL_ID THEN
				v_SQL := v_SQL || ' AND USER_ID = ' || v_USER_ID;
			END IF;
			IF v_PROCESS_ID <> CONSTANTS.ALL_ID THEN
				v_SQL := v_SQL || ' AND PROCESS_ID = ' || v_PROCESS_ID;
			END IF;

			-- Use union to include Processes that have not stopped yet
			v_SQL := v_SQL || ' UNION ALL';
			v_SQL := v_SQL || ' SELECT PROCESS_ID, USER_ID FROM PROCESS_LOG';
			v_SQL := v_SQL || ' WHERE PROCESS_START_TIME <= :END_DATE + 1';
			v_SQL := v_SQL || '  AND PROCESS_STOP_TIME IS NULL';

			-- Only include User Id and Process Id if they are not <All>
			IF v_USER_ID <> CONSTANTS.ALL_ID THEN
				v_SQL := v_SQL || ' AND USER_ID = ' || v_USER_ID;
			END IF;
			IF v_PROCESS_ID <> CONSTANTS.ALL_ID THEN
				v_SQL := v_SQL || ' AND PROCESS_ID = ' || v_PROCESS_ID;
			END IF;
		v_SQL := v_SQL || ') P';
		v_SQL := v_SQL || ' WHERE X.ZAU_PROCESS_ID = P.PROCESS_ID';

		IF v_USING_DLS THEN
				v_SQL := v_SQL || ' AND (P.USER_ID = ' || v_CURRENT_USER_ID || ' OR';
				v_SQL := v_SQL || ' EXISTS (SELECT 1 FROM TABLE(CAST(:IDS AS ID_TABLE)) IDS WHERE X.' || v_SYSTEM_TABLE.ENTITY_ID_COLUMN_NAME || ' = IDS.ID';
				v_SQL := v_SQL || ' UNION ALL SELECT 1';
				v_SQL := v_SQL || ' FROM SYSTEM_ACTION SA, SYSTEM_ACTION_ROLE AR, ENTITY_GRAVEYARD_REALM B, TABLE(CAST(:ROLES AS ID_TABLE)) C';
            	v_SQL := v_SQL || ' WHERE AR.ACTION_ID = SA.ACTION_ID';
				v_SQL := v_SQL || ' AND SA.ACTION_NAME = ''' || SD.g_ACTION_SELECT_AUDIT ||'''';
            	v_SQL := v_SQL || ' AND AR.ENTITY_DOMAIN_ID = ' || v_CUR_ENTITY_DOMAIN;
            	v_SQL := v_SQL || ' AND AR.ROLE_ID = C.ID';
            	v_SQL := v_SQL || ' AND B.REALM_ID = AR.REALM_ID';
            	v_SQL := v_SQL || ' AND B.ENTITY_DOMAIN_ID = AR.ENTITY_DOMAIN_ID';
            	v_SQL := v_SQL || ' AND B.ENTITY_ID = X.' || v_SYSTEM_TABLE.ENTITY_ID_COLUMN_NAME || '))';
		END IF;

		v_SQL := v_SQL || ' AND TRUNC(X.ZAU_TIMESTAMP) BETWEEN :BEGIN_DATE';
		v_SQL := v_SQL ||' AND :END_DATE + 1';

		END IF;

		IF NOT v_ALL_ENTITIES THEN
			v_SQL := v_SQL || ' AND X.' || v_SYSTEM_TABLE.ENTITY_ID_COLUMN_NAME || ' IN (' || p_ENTITY_IDS || ')';
		END IF;

		v_SQL := v_SQL || ') A';
		v_SQL := v_SQL || ' GROUP BY A.AUDIT_DATE';

		IF v_BY_PROCESS_ID THEN
			IF v_USING_DLS THEN
				EXECUTE IMMEDIATE v_SQL USING v_ALLOWED_ENTITIES, v_ROLES;
			ELSE
				EXECUTE IMMEDIATE v_SQL;
			END IF;
		ELSE
			IF v_USING_DLS THEN
				EXECUTE IMMEDIATE v_SQL USING p_END_DATE, p_BEGIN_DATE, p_END_DATE, v_ALLOWED_ENTITIES, v_ROLES, p_BEGIN_DATE, p_END_DATE;
			ELSE
				EXECUTE IMMEDIATE v_SQL
					USING p_END_DATE, p_BEGIN_DATE, p_END_DATE, p_BEGIN_DATE, p_END_DATE;
			END IF;
		END IF;
		v_LAST_ENTITY_DOMAIN := v_CUR_ENTITY_DOMAIN;
	END LOOP;

	-- Report Cursor
	OPEN p_CURSOR FOR
		SELECT A.AUDIT_DATE, A.ENTITY_DOMAIN_ID, D.ENTITY_DOMAIN_NAME, SUM(A.NUM_CHANGES) AS NUM_CHANGES
		FROM AUDIT_TRAIL_WORK A, ENTITY_DOMAIN D
		WHERE A.ENTITY_DOMAIN_ID = D.ENTITY_DOMAIN_ID
		GROUP BY A.AUDIT_DATE, A.ENTITY_DOMAIN_ID, D.ENTITY_DOMAIN_NAME
		ORDER BY 1 DESC;

	PURGE_AUDIT_TRAIL_WORK(v_WORK_ID);

EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			PURGE_AUDIT_TRAIL_WORK(v_WORK_ID);
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE();
		END;
		ERRS.LOG_AND_RAISE();

END SUMMARY_MASTER_REPORT;
---------------------------------------------------------------------
PROCEDURE SUMMARY_DETAIL_REPORT
	(
	p_AUDIT_DATE       IN DATE,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ENTITY_IDS	   IN VARCHAR2,
	p_USER_ID          IN NUMBER,
	p_PROCESS_ID       IN VARCHAR2,
	p_CURSOR           OUT GA.REFCURSOR
	) AS
	v_USER_ID    PROCESS_LOG.USER_ID%TYPE;
	v_PROCESS_ID PROCESS_LOG.PROCESS_ID%TYPE;
	v_SQL        VARCHAR2(4000);
	v_WORK_ID    AUDIT_TRAIL_WORK.WORK_ID%TYPE;
	v_ALL_ENTITIES			 BOOLEAN := FALSE;
	v_BY_PROCESS_ID			 BOOLEAN := FALSE;
	v_CURRENT_USER_ID		 NUMBER(9) := SECURITY_CONTROLS.CURRENT_USER_ID;
	v_ROLES 				 ID_TABLE := SECURITY_CONTROLS.CURRENT_ROLES;
	v_USING_DLS				 BOOLEAN;
	v_ALLOWED_ENTITIES 		 ID_TABLE;
	v_CUR_ENTITY_DOMAIN		 NUMBER(9);
	v_LAST_ENTITY_DOMAIN 	 NUMBER(9);

	CURSOR c_SYSTEM_TABLES IS
		SELECT A.TABLE_ID, A.TABLE_NAME, A.MIRROR_TABLE_NAME, A.ENTITY_DOMAIN_ID, A.ENTITY_ID_COLUMN_NAME
		FROM SYSTEM_TABLE A
		WHERE A.ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID
		ORDER BY A.ENTITY_DOMAIN_ID;
BEGIN
-- Default the User Id and Process Id to <All> if null
	v_USER_ID := NVL(p_USER_ID, CONSTANTS.ALL_ID);
	v_PROCESS_ID := NVL(TO_NUMBER(p_PROCESS_ID), CONSTANTS.ALL_ID);

-- Determine if we are querying by Process Id Only
	IF p_AUDIT_DATE IS NULL AND p_ENTITY_IDS IS NULL AND v_USER_ID = CONSTANTS.ALL_ID AND v_PROCESS_ID IS NOT NULL AND NOT v_PROCESS_ID = CONSTANTS.ALL_ID THEN
		v_BY_PROCESS_ID := TRUE;
	END IF;

-- Check to see if we have a list of enitites or are we including <All> entities
	IF p_ENTITY_IDS IS NULL OR
	   REGEXP_INSTR(p_ENTITY_IDS, '(,|^)' || CONSTANTS.ALL_ID || '(,|$)') > 0 THEN
		v_ALL_ENTITIES := TRUE;
	END IF;

-- Begin Building Dynamic Query
	UT.GET_RTO_WORK_ID(v_WORK_ID);

	-- Loop over each SYSTEM_TABLE
	FOR v_SYSTEM_TABLE IN c_SYSTEM_TABLES LOOP
		v_CUR_ENTITY_DOMAIN := v_SYSTEM_TABLE.ENTITY_DOMAIN_ID;

		-- Only fetch a new list of entities if this is a different Entity Domain
		IF v_LAST_ENTITY_DOMAIN IS NULL OR v_LAST_ENTITY_DOMAIN <> v_CUR_ENTITY_DOMAIN THEN
			-- First, Get the list of entities that this user has access to
			v_ALLOWED_ENTITIES := SD.GET_ALLOWED_ENTITY_ID_TABLE(SD.g_ACTION_SELECT_AUDIT, v_CUR_ENTITY_DOMAIN);
			-- Check to see if this user has access to All Entities
			v_USING_DLS := v_ALLOWED_ENTITIES IS NULL OR v_ALLOWED_ENTITIES.COUNT = 0 OR v_ALLOWED_ENTITIES(v_ALLOWED_ENTITIES.FIRST).ID <> SD.g_ALL_DATA_ENTITY_ID;
		END IF;

		v_SQL := 'INSERT INTO AUDIT_TRAIL_WORK(WORK_ID, ENTITY_DOMAIN_ID, ENTITY_ID, USER_ID, SYSTEM_TABLE_NAME, SYSTEM_TABLE_ID, NUM_CHANGES)';
		v_SQL := v_SQL || ' SELECT ' || v_WORK_ID || ', ' || v_CUR_ENTITY_DOMAIN || ', A.' ||
				 v_SYSTEM_TABLE.ENTITY_ID_COLUMN_NAME || ' AS ENTITY_ID, P.USER_ID, ''' ||
				 v_SYSTEM_TABLE.TABLE_NAME || ''' AS SYSTEM_TABLE_NAME, ' || v_SYSTEM_TABLE.TABLE_ID ||
				 ' AS SYSTEM_TABLE_ID, COUNT(1) AS NUM_CHANGES';
		v_SQL := v_SQL || ' FROM ' || v_SYSTEM_TABLE.MIRROR_TABLE_NAME || ' A , (';
		v_SQL := v_SQL || 'SELECT PROCESS_ID, USER_ID FROM PROCESS_LOG';

		IF v_BY_PROCESS_ID THEN
			v_SQL := v_SQL || ' WHERE PROCESS_ID = ' || v_PROCESS_ID;
		ELSE
			v_SQL := v_SQL || ' WHERE PROCESS_START_TIME <= :AUDIT_DATE + 1';
			v_SQL := v_SQL || '  AND PROCESS_STOP_TIME >= :AUDIT_DATE';

			-- Only include User Id and Process Id if they are not <All>
			IF v_USER_ID <> CONSTANTS.ALL_ID THEN
				v_SQL := v_SQL || ' AND USER_ID = ' || v_USER_ID;
			END IF;
			IF v_PROCESS_ID <> CONSTANTS.ALL_ID THEN
				v_SQL := v_SQL || ' AND PROCESS_ID = ' || v_PROCESS_ID;
			END IF;

			-- Use union to include Processes that have not stopped yet
			v_SQL := v_SQL || ' UNION ALL';
			v_SQL := v_SQL || ' SELECT PROCESS_ID, USER_ID FROM PROCESS_LOG';
			v_SQL := v_SQL || ' WHERE PROCESS_START_TIME <= :AUDIT_DATE + 1';
			v_SQL := v_SQL || '  AND PROCESS_STOP_TIME IS NULL';

			-- Only include User Id and Process Id if they are not <All>
			IF v_USER_ID <> CONSTANTS.ALL_ID THEN
				v_SQL := v_SQL || ' AND USER_ID = ' || v_USER_ID;
			END IF;
			IF v_PROCESS_ID <> CONSTANTS.ALL_ID THEN
				v_SQL := v_SQL || ' AND PROCESS_ID = ' || v_PROCESS_ID;
			END IF;
		END IF;

		v_SQL := v_SQL || ') P';

		v_SQL := v_SQL || ' WHERE A.ZAU_PROCESS_ID = P.PROCESS_ID';

		IF v_USING_DLS THEN
			v_SQL := v_SQL || ' AND (P.USER_ID = ' || v_CURRENT_USER_ID || ' OR';
			v_SQL := v_SQL || ' EXISTS (SELECT 1 FROM TABLE(CAST( :IDS AS ID_TABLE)) IDS WHERE A.' || v_SYSTEM_TABLE.ENTITY_ID_COLUMN_NAME || ' = IDS.ID';
			v_SQL := v_SQL || ' UNION ALL SELECT 1';
			v_SQL := v_SQL || ' FROM SYSTEM_ACTION SA, SYSTEM_ACTION_ROLE AR, ENTITY_GRAVEYARD_REALM B, TABLE(CAST(:ROLES AS ID_TABLE)) C';
			v_SQL := v_SQL || ' WHERE AR.ACTION_ID = SA.ACTION_ID';
			v_SQL := v_SQL || ' AND SA.ACTION_NAME = ''' || SD.g_ACTION_SELECT_AUDIT ||'''';
			v_SQL := v_SQL || ' AND AR.ENTITY_DOMAIN_ID = ' || v_CUR_ENTITY_DOMAIN;
			v_SQL := v_SQL || ' AND AR.ROLE_ID = C.ID';
			v_SQL := v_SQL || ' AND B.REALM_ID = AR.REALM_ID';
			v_SQL := v_SQL || ' AND B.ENTITY_DOMAIN_ID = AR.ENTITY_DOMAIN_ID';
			v_SQL := v_SQL || ' AND B.ENTITY_ID = A.' || v_SYSTEM_TABLE.ENTITY_ID_COLUMN_NAME || '))';
		END IF;

		IF NOT v_BY_PROCESS_ID THEN
			v_SQL := v_SQL || ' AND TRUNC(A.ZAU_TIMESTAMP) = :AUDIT_DATE';
		END IF;

		IF NOT v_ALL_ENTITIES THEN
			v_SQL := v_SQL || ' AND A.' || v_SYSTEM_TABLE.ENTITY_ID_COLUMN_NAME || ' IN (' || p_ENTITY_IDS || ')';
		END IF;

		v_SQL := v_SQL || ' GROUP BY A.' || v_SYSTEM_TABLE.ENTITY_ID_COLUMN_NAME || ', P.USER_ID';

		LOGS.LOG_INFO_MORE_DETAIL('Detail Query for ' || v_SYSTEM_TABLE.MIRROR_TABLE_NAME || ': ' || v_SQL);

		-- Execute the SQL
		IF v_BY_PROCESS_ID THEN
			IF v_USING_DLS THEN
				EXECUTE IMMEDIATE v_SQL
					USING v_ALLOWED_ENTITIES, v_ROLES;
			ELSE
				EXECUTE IMMEDIATE v_SQL;
			END IF;
		ELSE
			IF v_USING_DLS THEN
				EXECUTE IMMEDIATE v_SQL
					USING p_AUDIT_DATE, p_AUDIT_DATE, p_AUDIT_DATE, v_ALLOWED_ENTITIES, v_ROLES, p_AUDIT_DATE;
			ELSE
				EXECUTE IMMEDIATE v_SQL
					USING p_AUDIT_DATE, p_AUDIT_DATE, p_AUDIT_DATE, p_AUDIT_DATE;
			END IF;
		END IF;

		v_LAST_ENTITY_DOMAIN := v_CUR_ENTITY_DOMAIN;
	END LOOP;

	-- Report Cursor
	OPEN p_CURSOR FOR
		SELECT A.SYSTEM_TABLE_NAME,
			   A.SYSTEM_TABLE_ID,
			   A.ENTITY_ID,
			   ENTITY_NAME_FROM_IDS(A.ENTITY_DOMAIN_ID, A.ENTITY_ID) AS ENTITY_NAME,
			   A.USER_ID,
			   NVL(U.USER_DISPLAY_NAME, U.USER_NAME) AS USER_NAME,
			   A.NUM_CHANGES AS NUM_CHANGES
		FROM AUDIT_TRAIL_WORK A, APPLICATION_USER U
		WHERE A.USER_ID = U.USER_ID;

	PURGE_AUDIT_TRAIL_WORK(v_WORK_ID);

EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			PURGE_AUDIT_TRAIL_WORK(v_WORK_ID);
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE();
		END;
		ERRS.LOG_AND_RAISE();

END SUMMARY_DETAIL_REPORT;
---------------------------------------------------------------------
PROCEDURE DETAIL_BY_DATE_MASTER_REPORT
	(
	p_AUDIT_DATE       IN DATE,
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_USER_ID          IN NUMBER,
	p_PROCESS_ID       IN VARCHAR2,
	p_CURSOR           OUT GA.REFCURSOR
	) AS
BEGIN
	SUMMARY_DETAIL_REPORT(p_AUDIT_DATE, p_ENTITY_DOMAIN_ID, CONSTANTS.ALL_ID, p_USER_ID, p_PROCESS_ID, p_CURSOR);
END DETAIL_BY_DATE_MASTER_REPORT;
---------------------------------------------------------------------
PROCEDURE DETAIL_BY_DATE_DETAIL_REPORT
	(
	p_AUDIT_DATE      IN DATE,
	p_ENTITY_ID       IN NUMBER,
	p_SYSTEM_TABLE_ID IN NUMBER,
	p_USER_ID         IN NUMBER,
	p_PROCESS_ID	  IN VARCHAR2,
	p_CURSOR          OUT GA.REFCURSOR
	) AS
	v_SQL               			VARCHAR2(4000);
	v_IDX               			NUMBER(9);
	v_COLUMNS           			STRING_COLLECTION;
	v_ENTITY_ID_COLUMN  			SYSTEM_TABLE.ENTITY_ID_COLUMN_NAME%TYPE;
	v_DB_TABLE_NAME     			SYSTEM_TABLE.DB_TABLE_NAME%TYPE;
	v_MIRROR_TABLE_NAME 			SYSTEM_TABLE.MIRROR_TABLE_NAME%TYPE;
	v_PROCESS_ID 					PROCESS_LOG.PROCESS_ID%TYPE;
	v_USER_ID    					PROCESS_LOG.USER_ID%TYPE;
	v_SYS_TABLE_ENTITY_DOMAIN_ID 	SYSTEM_TABLE.ENTITY_DOMAIN_ID%TYPE;
	v_CURRENT_USER_ID		 		NUMBER := SECURITY_CONTROLS.CURRENT_USER_ID;
	v_ROLES 				 ID_TABLE := SECURITY_CONTROLS.CURRENT_ROLES;
	v_ENTITY_IS_ALLOWED 		 	BOOLEAN;
	v_ALLOWED_IN_GRAVEYARD			NUMBER(1);
BEGIN
	v_USER_ID := NVL(p_USER_ID, CONSTANTS.ALL_ID);
	v_PROCESS_ID := NVL(TO_NUMBER(p_PROCESS_ID), CONSTANTS.ALL_ID);

	-- Get the EntityIdColumnName, DBTableName, MirrorTableName, EntityDomainId from the System Table
	BEGIN
		SELECT S.ENTITY_ID_COLUMN_NAME, S.DB_TABLE_NAME, S.MIRROR_TABLE_NAME, S.ENTITY_DOMAIN_ID
		INTO v_ENTITY_ID_COLUMN, v_DB_TABLE_NAME, v_MIRROR_TABLE_NAME, v_SYS_TABLE_ENTITY_DOMAIN_ID
		FROM SYSTEM_TABLE S
		WHERE S.TABLE_ID = p_SYSTEM_TABLE_ID;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'SYSTEM_TABLE with Id = ' || p_SYSTEM_TABLE_ID);
	END;

	-- Check Data Level Security
	--  First Check the Graveyard
	SELECT COUNT(1)
	INTO v_ALLOWED_IN_GRAVEYARD
	FROM SYSTEM_ACTION SA, SYSTEM_ACTION_ROLE AR, ENTITY_GRAVEYARD_REALM B, TABLE(CAST(v_ROLES AS ID_TABLE)) C
	WHERE AR.ACTION_ID = SA.ACTION_ID
		AND SA.ACTION_NAME = SD.g_ACTION_SELECT_AUDIT
		AND AR.ENTITY_DOMAIN_ID = v_SYS_TABLE_ENTITY_DOMAIN_ID
		AND AR.ROLE_ID = C.ID
		AND B.REALM_ID = AR.REALM_ID
		AND B.ENTITY_DOMAIN_ID = AR.ENTITY_DOMAIN_ID
		AND B.ENTITY_ID = p_ENTITY_ID;

	v_ENTITY_IS_ALLOWED := v_ALLOWED_IN_GRAVEYARD > 0 OR SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_AUDIT, p_ENTITY_ID, v_SYS_TABLE_ENTITY_DOMAIN_ID);

	-- Get the Column Names from the ZAU table
	SELECT C.COLUMN_NAME BULK COLLECT
	INTO v_COLUMNS
	FROM USER_TAB_COLUMNS C
	WHERE C.TABLE_NAME = v_MIRROR_TABLE_NAME
		  AND NOT C.COLUMN_NAME LIKE 'ZAU_%';

	v_SQL := 'SELECT ';

	-- Original Table Columns
	v_IDX := v_COLUMNS.FIRST;
	WHILE v_COLUMNS.EXISTS(v_IDX) LOOP
		v_SQL := v_SQL||GET_DISPLAY_EXPRESSION(v_DB_TABLE_NAME, v_COLUMNS(v_IDX), 'A')||', ';
		v_IDX := v_COLUMNS.NEXT(v_IDX);
	END LOOP;

	-- ZAU Operation
	v_SQL := v_SQL ||
			 'CASE A.ZAU_OPERATION WHEN ''I'' THEN ''Insert'' WHEN ''U'' THEN ''Update'' WHEN ''K'' THEN ''Insert [Key Update]'' WHEN ''X'' THEN ''Delete [Key Update]'' WHEN ''D'' THEN ''Delete'' ELSE ''Unknown'' END AS OPERATION, ';
	-- ZAU_TIMESTAMP
	v_SQL := v_SQL || 'A.ZAU_TIMESTAMP, ';
	-- WHY_CHANGED, Outer Join on the AUDIT_CHANGE_COMMENT table
	v_SQL := v_SQL || 'B.WHY_CHANGED, ';
	-- PROCESS_NAME based on ZAU_PROCESS_ID
	v_SQL := v_SQL || 'A.PROCESS_NAME, ';
	-- USER_NAME based on ZAU_PROCESS_ID
	v_SQL := v_SQL || 'NVL(A.USER_DISPLAY_NAME, A.USER_NAME) AS USER_NAME, ';
	-- ZAU Id and ZAU_PROCESS_ID
	v_SQL := v_SQL || 'TO_CHAR(A.ZAU_ID) AS ZAU_ID, TO_CHAR(A.ZAU_PROCESS_ID) AS PROCESS_ID ';

	-- Inner query joins the ZAU_* table with PROCESS_LOG and APPLICATION_USER
	v_SQL := v_SQL || 'FROM (SELECT X.*, Y.PROCESS_NAME, Y.USER_ID, Z.USER_DISPLAY_NAME, Z.USER_NAME ';
		  v_SQL := v_SQL || 'FROM ' || v_MIRROR_TABLE_NAME || ' X, PROCESS_LOG Y, APPLICATION_USER Z ';
	      v_SQL := v_SQL || 'WHERE X.ZAU_PROCESS_ID = Y.PROCESS_ID ';
		  v_SQL := v_SQL || 'AND Y.USER_ID = Z.USER_ID ';
		  IF v_USER_ID <> CONSTANTS.ALL_ID THEN
				v_SQL := v_SQL || ' AND Z.USER_ID = ' || v_USER_ID;
		  END IF;
		  IF v_PROCESS_ID <> CONSTANTS.ALL_ID THEN
				v_SQL := v_SQL || ' AND X.ZAU_PROCESS_ID = ' || v_PROCESS_ID;
		  END IF;
		  v_SQL := v_SQL || ') A, ';
	v_SQL := v_SQL || 'AUDIT_CHANGE_COMMENT B ';
	v_SQL := v_SQL || 'WHERE B.ZAU_ID(+) = A.ZAU_ID ';
	v_SQL := v_SQL || 'AND TRUNC(A.ZAU_TIMESTAMP) = :1 ';
	IF NOT v_ENTITY_IS_ALLOWED THEN
		v_SQL := v_SQL || 'AND A.USER_ID = ' || v_CURRENT_USER_ID || ' ';
	END IF;
	v_SQL := v_SQL || 'AND A.' || v_ENTITY_ID_COLUMN || ' = :2 ';
	v_SQL := v_SQL || 'ORDER BY A.ZAU_TIMESTAMP DESC';

	-- Report Cursor
	OPEN p_CURSOR FOR v_SQL
		USING p_AUDIT_DATE, p_ENTITY_ID;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_RAISE();

END DETAIL_BY_DATE_DETAIL_REPORT;
---------------------------------------------------------------------
PROCEDURE DETAIL_BY_ENTITY_MASTER_REPORT
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ENTITY_ID        IN NUMBER,
	p_USER_ID          IN NUMBER,
	p_PROCESS_ID       IN VARCHAR2,
	p_CURSOR           OUT GA.REFCURSOR
	) AS
	v_USER_ID    			PROCESS_LOG.USER_ID%TYPE;
	v_PROCESS_ID 			PROCESS_LOG.PROCESS_ID%TYPE;
	v_SQL        			VARCHAR2(4000);
	v_WORK_ID    			AUDIT_TRAIL_WORK.WORK_ID%TYPE;
	v_USE_AND    			BOOLEAN := FALSE;
	v_CURRENT_USER_ID		NUMBER := SECURITY_CONTROLS.CURRENT_USER_ID;
	v_ROLES 				ID_TABLE := SECURITY_CONTROLS.CURRENT_ROLES;
	v_ENTITY_IS_ALLOWED 	BOOLEAN;
	v_ALLOWED_IN_GRAVEYARD	NUMBER(1);

	CURSOR c_SYSTEM_TABLES IS
		SELECT A.TABLE_ID, A.TABLE_NAME, A.MIRROR_TABLE_NAME, A.ENTITY_DOMAIN_ID, A.ENTITY_ID_COLUMN_NAME
		FROM SYSTEM_TABLE A
		WHERE A.ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID;
BEGIN
	v_USER_ID := NVL(p_USER_ID, CONSTANTS.ALL_ID);
	v_PROCESS_ID := NVL(TO_NUMBER(p_PROCESS_ID), CONSTANTS.ALL_ID);

	UT.GET_RTO_WORK_ID(v_WORK_ID);

	-- Check Data Level Security
	--  First Check the Graveyard
	SELECT COUNT(1)
	INTO v_ALLOWED_IN_GRAVEYARD
	FROM SYSTEM_ACTION SA, SYSTEM_ACTION_ROLE AR, ENTITY_GRAVEYARD_REALM B, TABLE(CAST(v_ROLES AS ID_TABLE)) C
	WHERE AR.ACTION_ID = SA.ACTION_ID
		AND SA.ACTION_NAME = SD.g_ACTION_SELECT_AUDIT
		AND AR.ENTITY_DOMAIN_ID = p_ENTITY_DOMAIN_ID
		AND AR.ROLE_ID = C.ID
		AND B.REALM_ID = AR.REALM_ID
		AND B.ENTITY_DOMAIN_ID = AR.ENTITY_DOMAIN_ID
		AND B.ENTITY_ID = p_ENTITY_ID;

	v_ENTITY_IS_ALLOWED := v_ALLOWED_IN_GRAVEYARD > 0 OR SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_AUDIT, p_ENTITY_ID, p_ENTITY_DOMAIN_ID);

	-- Loop over each SYSTEM_TABLE and Insert the AUDIT_DATE, ENTITY_DOMAIN_ID, NUM_CHANGES
	FOR v_SYSTEM_TABLE IN c_SYSTEM_TABLES LOOP

		v_SQL := 'INSERT INTO AUDIT_TRAIL_WORK(WORK_ID, AUDIT_DATE, USER_ID, SYSTEM_TABLE_NAME, SYSTEM_TABLE_ID, NUM_CHANGES)';
		v_SQL := v_SQL || ' SELECT ' || v_WORK_ID || ', TRUNC(A.ZAU_TIMESTAMP) AS AUDIT_DATE , P.USER_ID, ''' ||
				 v_SYSTEM_TABLE.TABLE_NAME || ''' AS SYSTEM_TABLE_NAME, ' || v_SYSTEM_TABLE.TABLE_ID ||
				 ' AS SYSTEM_TABLE_ID, COUNT(1) AS NUM_CHANGES';
		v_SQL := v_SQL || ' FROM ' || v_SYSTEM_TABLE.MIRROR_TABLE_NAME || ' A , (';
		v_SQL := v_SQL || 'SELECT PROCESS_ID, USER_ID FROM PROCESS_LOG';

		IF v_USER_ID <> CONSTANTS.ALL_ID THEN
			v_SQL := v_SQL || ' WHERE';
			v_SQL := v_SQL || ' USER_ID = ' || v_USER_ID;
			v_USE_AND := TRUE;
		END IF;

		IF v_PROCESS_ID <> CONSTANTS.ALL_ID THEN
			v_SQL := v_SQL || CASE WHEN v_USE_AND THEN ' AND' ELSE ' WHERE' END;
			v_SQL := v_SQL || ' PROCESS_ID = ' || v_PROCESS_ID;
		END IF;

		v_SQL := v_SQL || ') P';
		v_SQL := v_SQL || ' WHERE A.ZAU_PROCESS_ID = P.PROCESS_ID';
		IF NOT v_ENTITY_IS_ALLOWED THEN
			v_SQL := v_SQL || ' AND P.USER_ID = ' || v_CURRENT_USER_ID;
		END IF;
		v_SQL := v_SQL || ' AND A.' || v_SYSTEM_TABLE.ENTITY_ID_COLUMN_NAME || ' = :1 ';
		v_SQL := v_SQL || ' GROUP BY TRUNC(A.ZAU_TIMESTAMP), P.USER_ID';

		EXECUTE IMMEDIATE v_SQL
			USING p_ENTITY_ID;

	END LOOP;

	-- Report Cursor
	OPEN p_CURSOR FOR
		SELECT A.SYSTEM_TABLE_NAME,
			   A.SYSTEM_TABLE_ID,
			   A.AUDIT_DATE,
			   A.USER_ID,
			   NVL(U.USER_DISPLAY_NAME, U.USER_NAME) AS USER_NAME,
			   A.NUM_CHANGES AS NUM_CHANGES
		FROM AUDIT_TRAIL_WORK A, APPLICATION_USER U
		WHERE A.USER_ID = U.USER_ID;

	PURGE_AUDIT_TRAIL_WORK(v_WORK_ID);

EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			PURGE_AUDIT_TRAIL_WORK(v_WORK_ID);
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE();
		END;
		ERRS.LOG_AND_RAISE();
END DETAIL_BY_ENTITY_MASTER_REPORT;
---------------------------------------------------------------------
PROCEDURE DETAIL_BY_ENTITY_DETAIL_REPORT
	(
	p_AUDIT_DATE      IN DATE,
	p_ENTITY_ID       IN NUMBER,
	p_SYSTEM_TABLE_ID IN NUMBER,
	p_USER_ID         IN NUMBER,
	p_PROCESS_ID	  IN VARCHAR2,
	p_CURSOR          OUT GA.REFCURSOR
	) AS
BEGIN
	DETAIL_BY_DATE_DETAIL_REPORT(p_AUDIT_DATE, p_ENTITY_ID, p_SYSTEM_TABLE_ID, p_USER_ID, p_PROCESS_ID, p_CURSOR);
END DETAIL_BY_ENTITY_DETAIL_REPORT;
---------------------------------------------------------------------
PROCEDURE SUMMARY_BY_PROCESS_REPORT
	(
	p_PROCESS_ID        IN VARCHAR2,
	p_CURSOR            OUT GA.REFCURSOR
	) AS
BEGIN
	SUMMARY_MASTER_REPORT(NULL,NULL,NULL,NULL,CONSTANTS.ALL_ID,p_PROCESS_ID,p_CURSOR);
END SUMMARY_BY_PROCESS_REPORT;
---------------------------------------------------------------------
PROCEDURE DETAIL_BY_PROCESS_REPORT
	(
	p_ENTITY_DOMAIN_ID  IN NUMBER,
	p_PROCESS_ID        IN VARCHAR2,
	p_CURSOR            OUT GA.REFCURSOR
	) AS
BEGIN
	SUMMARY_DETAIL_REPORT(NULL,p_ENTITY_DOMAIN_ID,NULL,CONSTANTS.ALL_ID,p_PROCESS_ID,p_CURSOR);
END DETAIL_BY_PROCESS_REPORT;
---------------------------------------------------------------------
PROCEDURE PUT_WHY_CHANGED
	(
	p_SYSTEM_TABLE_ID 	IN NUMBER,
	p_ZAU_ID      		IN VARCHAR2,
	p_WHY_CHANGED 		IN VARCHAR2
	) AS
	v_ZAU_ID 				NUMBER(18);
	v_MIRROR_TABLE_NAME		SYSTEM_TABLE.MIRROR_TABLE_NAME%TYPE;
	v_ENTITY_ID_COLUMN_NAME	SYSTEM_TABLE.ENTITY_ID_COLUMN_NAME%TYPE;
	v_ENTITY_DOMAIN_ID 		SYSTEM_TABLE.ENTITY_DOMAIN_ID%TYPE;
	v_CURRENT_USER_ID		NUMBER(9) := SECURITY_CONTROLS.CURRENT_USER_ID;
	v_USER_ID				NUMBER(9);
	v_ENTITY_ID 			NUMBER(9);
	v_ENTITY_IS_ALLOWED		BOOLEAN;
	v_SQL VARCHAR2(4000);
BEGIN

	BEGIN
		SELECT S.MIRROR_TABLE_NAME, S.ENTITY_ID_COLUMN_NAME, S.ENTITY_DOMAIN_ID
		INTO v_MIRROR_TABLE_NAME, v_ENTITY_ID_COLUMN_NAME, v_ENTITY_DOMAIN_ID
		FROM SYSTEM_TABLE S
		WHERE S.TABLE_ID = p_SYSTEM_TABLE_ID;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'SYSTEM_TABLE with Id = ' || p_SYSTEM_TABLE_ID);
	END;

	v_ZAU_ID := TO_NUMBER(p_ZAU_ID);

	v_SQL := 'SELECT P.USER_ID, X.' || v_ENTITY_ID_COLUMN_NAME || ' FROM PROCESS_LOG P, ' || v_MIRROR_TABLE_NAME || ' X WHERE X.ZAU_PROCESS_ID = P.PROCESS_ID AND X.ZAU_ID = ' || v_ZAU_ID;

	BEGIN
		EXECUTE IMMEDIATE v_SQL INTO v_USER_ID, v_ENTITY_ID;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'Entity Id in Table = ' || v_MIRROR_TABLE_NAME || ', with Entity Column Name = ' || v_ENTITY_ID_COLUMN_NAME || ', and ZAU Id = ' || v_ZAU_ID);
	END;

	v_ENTITY_IS_ALLOWED := SD.GET_ENTITY_IS_ALLOWED(SD.g_ACTION_UPDATE_AUDIT, v_ENTITY_ID, v_ENTITY_DOMAIN_ID);

	IF v_ENTITY_IS_ALLOWED OR v_USER_ID = v_CURRENT_USER_ID THEN
		UPDATE AUDIT_CHANGE_COMMENT
		SET ZAU_ID      = v_ZAU_ID,
			WHY_CHANGED = p_WHY_CHANGED
		WHERE ZAU_ID = v_ZAU_ID;

		IF SQL%NOTFOUND THEN
			INSERT INTO AUDIT_CHANGE_COMMENT (ZAU_ID, WHY_CHANGED) VALUES (v_ZAU_ID, p_WHY_CHANGED);
		END IF;
	ELSE
		ERRS.RAISE_NO_PRIVILEGE_ACTION(SD.g_ACTION_UPDATE_AUDIT, v_ENTITY_ID, v_ENTITY_DOMAIN_ID);
	END IF;
END PUT_WHY_CHANGED;
---------------------------------------------------------------------
PROCEDURE GET_SYSTEM_TABLE_DETAILS
	(
	p_DB_TABLE_NAME IN VARCHAR2,
	p_SYSTEM_TABLE_ID OUT NUMBER,
	p_ENTITY_ID_COLUMN OUT VARCHAR2,
	p_MIRROR_TABLE_NAME OUT VARCHAR2
	) AS

BEGIN
		SELECT S.TABLE_ID, S.ENTITY_ID_COLUMN_NAME, S.MIRROR_TABLE_NAME
		INTO p_SYSTEM_TABLE_ID, p_ENTITY_ID_COLUMN, p_MIRROR_TABLE_NAME
		FROM SYSTEM_TABLE S
		WHERE S.DB_TABLE_NAME = p_DB_TABLE_NAME;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'SYSTEM_TABLE with Name = ' || p_DB_TABLE_NAME);
END GET_SYSTEM_TABLE_DETAILS;
---------------------------------------------------------------------
PROCEDURE GET_ENTITY_RECORDS
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- GET THE AUDIT TRAIL RECORDS FOR THE ENTITY DOMAIN'S DB TABLE
v_DOMAIN_INFO ENTITY_UTIL.ENTITY_DOMAIN_INFO;
v_SYSTEM_TABLE_ID NUMBER(9);
v_DB_TABLE_NAME VARCHAR2(32);
v_ENTITY_ID_COLUMN VARCHAR2(32);
v_MIRROR_TABLE_NAME VARCHAR2(32);
v_COLUMNS STRING_COLLECTION;
v_SQL VARCHAR2(4000);
v_IDX NUMBER(9);

BEGIN

	-- VERIFY THE USER HAS AUDITING PRIVILEGES
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_AUDIT, p_ENTITY_ID,
		p_ENTITY_DOMAIN_ID);

	-- GET DOMAIN INFO
	v_DOMAIN_INFO := ENTITY_UTIL.GET_DOMAIN_INFO(p_ENTITY_DOMAIN_ID);

	v_DB_TABLE_NAME := v_DOMAIN_INFO.ENTITY_DOMAIN_TABLE_NAME;

	-- GET THE SYSTEM TABLE FOR THE ENTITY DOMAIN'S DB TABLE, ALSO VERIFY THAT SUCH
	-- A SYSTEM TABLE EXISTS
	GET_SYSTEM_TABLE_DETAILS(v_DB_TABLE_NAME, v_SYSTEM_TABLE_ID, v_ENTITY_ID_COLUMN,
		v_MIRROR_TABLE_NAME);

	-- VERIFY THAT AUDITING IS ENABLED ON THE SYSTEM TABLE
	ASSERT(IS_AUDIT_ENABLED(v_DB_TABLE_NAME, v_MIRROR_TABLE_NAME) = 1,
			'Auditing is not enabled for ' ||
			TEXT_UTIL.TO_CHAR_ENTITY(v_SYSTEM_TABLE_ID, EC.ED_SYSTEM_TABLE),
		MSGCODES.c_ERR_AUDIT_ENABLED);

	-- NOW GRAB ALL THE AUDIT TRAIL RECORDS FOR THAT ENTITY
		-- Get the Column Names from the ZAU table
	SELECT C.COLUMN_NAME BULK COLLECT
	INTO v_COLUMNS
	FROM USER_TAB_COLUMNS C
	WHERE C.TABLE_NAME = v_MIRROR_TABLE_NAME
		  AND NOT C.COLUMN_NAME LIKE 'ZAU_%';

	v_SQL := 'SELECT ';

	-- Original Table Columns
	v_IDX := v_COLUMNS.FIRST;
	WHILE v_COLUMNS.EXISTS(v_IDX) LOOP
		v_SQL := v_SQL||GET_DISPLAY_EXPRESSION(v_DB_TABLE_NAME, v_COLUMNS(v_IDX), 'A')||', ';
		v_IDX := v_COLUMNS.NEXT(v_IDX);
	END LOOP;

	-- ZAU Operation
	v_SQL := v_SQL ||
			 'CASE A.ZAU_OPERATION WHEN ''I'' THEN ''Insert'' WHEN ''U'' THEN ''Update'' WHEN ''K'' THEN ''Insert [Key Update]'' WHEN ''X'' THEN ''Delete [Key Update]'' WHEN ''D'' THEN ''Delete'' ELSE ''Unknown'' END AS OPERATION, ';
	-- ZAU_TIMESTAMP
	v_SQL := v_SQL || 'A.ZAU_TIMESTAMP, ';
	-- WHY_CHANGED, Outer Join on the AUDIT_CHANGE_COMMENT table
	v_SQL := v_SQL || 'B.WHY_CHANGED, ';
	-- SYSTEM TABLE ID NEEDED FOR PUT_WHY_CHANGED
	v_SQL := v_SQL || v_SYSTEM_TABLE_ID || ' SYSTEM_TABLE_ID,' ;
	-- PROCESS_NAME based on ZAU_PROCESS_ID
	v_SQL := v_SQL || 'A.PROCESS_NAME, ';
	-- USER_NAME based on ZAU_PROCESS_ID
	v_SQL := v_SQL || 'NVL(A.USER_DISPLAY_NAME, A.USER_NAME) AS USER_NAME, ';
	-- ZAU Id and ZAU_PROCESS_ID
	v_SQL := v_SQL || 'TO_CHAR(A.ZAU_ID) AS ZAU_ID, TO_CHAR(A.ZAU_PROCESS_ID) AS PROCESS_ID ';

	-- Inner query joins the ZAU_* table with PROCESS_LOG and APPLICATION_USER
	v_SQL := v_SQL || 'FROM (SELECT X.*, Y.PROCESS_NAME, Y.USER_ID, Z.USER_DISPLAY_NAME, Z.USER_NAME ';
		  v_SQL := v_SQL || 'FROM ' || v_MIRROR_TABLE_NAME || ' X, PROCESS_LOG Y, APPLICATION_USER Z ';
	      v_SQL := v_SQL || 'WHERE X.ZAU_PROCESS_ID = Y.PROCESS_ID ';
		  v_SQL := v_SQL || 'AND Y.USER_ID = Z.USER_ID ';
		  v_SQL := v_SQL || ') A, ';
	v_SQL := v_SQL || 'AUDIT_CHANGE_COMMENT B ';
	v_SQL := v_SQL || 'WHERE B.ZAU_ID(+) = A.ZAU_ID ';
	v_SQL := v_SQL || 'AND A.ZAU_TIMESTAMP BETWEEN :1 AND :2';
	v_SQL := v_SQL || 'AND A.' || v_ENTITY_ID_COLUMN || ' = :3 ';
	v_SQL := v_SQL || 'ORDER BY A.ZAU_TIMESTAMP DESC';

		-- Report Cursor
	-- DATE FILTERING IS OPTIONAL
	OPEN p_CURSOR FOR v_SQL
		USING NVL(p_BEGIN_DATE, CONSTANTS.LOW_DATE), NVL(p_END_DATE, CONSTANTS.HIGH_DATE), p_ENTITY_ID;

END GET_ENTITY_RECORDS;
---------------------------------------------------------------------
FUNCTION GET_LAST_ENTITY_COMMENT
	(
	p_ENTITY_DOMAIN_ID IN NUMBER,
	p_ENTITY_ID IN NUMBER
	) RETURN VARCHAR2 IS

v_DOMAIN_INFO ENTITY_UTIL.ENTITY_DOMAIN_INFO;

v_RESULT AUDIT_CHANGE_COMMENT.WHY_CHANGED%TYPE;

v_SQL VARCHAR2(4000);

v_MIRROR_TABLE_NAME VARCHAR2(32);
v_ENTITY_ID_COLUMN VARCHAR2(32);

BEGIN

	-- VERIFY THE USER HAS AUDITING PRIVILEGES
	SD.VERIFY_ENTITY_IS_ALLOWED(SD.g_ACTION_SELECT_AUDIT, p_ENTITY_ID,
		p_ENTITY_DOMAIN_ID);

	-- GET DOMAIN INFO
	v_DOMAIN_INFO := ENTITY_UTIL.GET_DOMAIN_INFO(p_ENTITY_DOMAIN_ID);

	BEGIN
		SELECT S.ENTITY_ID_COLUMN_NAME, S.MIRROR_TABLE_NAME
		INTO v_ENTITY_ID_COLUMN, v_MIRROR_TABLE_NAME
		FROM SYSTEM_TABLE S
		WHERE UPPER(S.DB_TABLE_NAME) = UPPER(v_DOMAIN_INFO.ENTITY_DOMAIN_TABLE_NAME);

		v_SQL := 'SELECT * FROM (SELECT CMMT.WHY_CHANGED FROM ' || v_MIRROR_TABLE_NAME
			|| ' MIRROR, AUDIT_CHANGE_COMMENT CMMT ' || 'WHERE CMMT.ZAU_ID = MIRROR.ZAU_ID'
			|| ' AND MIRROR.' || v_ENTITY_ID_COLUMN || ' = ' || p_ENTITY_ID
			|| ' ORDER BY MIRROR.ZAU_TIMESTAMP DESC'
			|| ') WHERE ROWNUM = 1 ';

		EXECUTE IMMEDIATE v_SQL INTO v_RESULT;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			RETURN NULL; -- JUST SWALLOW IT AND RETURN NULL FOR COMMENTS
	END;

	RETURN v_RESULT;

END GET_LAST_ENTITY_COMMENT;
---------------------------------------------------------------------
PROCEDURE GET_LAST_AUDIT_ENTRY
	(
	p_SYSTEM_TABLE_ID IN NUMBER,
	p_COLUMN_VALUES IN UT.STRING_MAP,
	p_ZAU_ID OUT NUMBER,
	p_ZAU_OPERATION OUT CHAR,
	p_ZAU_TIMESTAMP OUT TIMESTAMP,
	p_ZAU_PROCESS_ID OUT NUMBER,
	p_ZAU_SIBLING_ID OUT NUMBER
	) AS

v_TABLE_NAME	SYSTEM_TABLE.MIRROR_TABLE_NAME%TYPE;
v_QUERY VARCHAR2(4000);
v_WHERE_CLAUSE VARCHAR2(4000);

BEGIN

	SELECT ST.MIRROR_TABLE_NAME
	INTO v_TABLE_NAME
	FROM SYSTEM_TABLE ST
	WHERE ST.TABLE_ID = p_SYSTEM_TABLE_ID;

	v_WHERE_CLAUSE := UT.MAP_TO_WHERE_CLAUSE(p_COLUMN_VALUES);

 	v_QUERY := 'SELECT ZAU_ID, ZAU_OPERATION, ZAU_TIMESTAMP, ZAU_PROCESS_ID, ZAU_SIBLING_ID FROM
	( SELECT ZAU_ID, ZAU_OPERATION, ZAU_TIMESTAMP, ZAU_PROCESS_ID, ZAU_SIBLING_ID FROM ' ||
		v_TABLE_NAME || ' WHERE ' || v_WHERE_CLAUSE || ' ORDER BY ZAU_TIMESTAMP DESC, ZAU_ID DESC) WHERE ROWNUM = 1';

	BEGIN
		EXECUTE IMMEDIATE v_QUERY INTO p_ZAU_ID, p_ZAU_OPERATION, p_ZAU_TIMESTAMP, p_ZAU_PROCESS_ID, p_ZAU_SIBLING_ID;
	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			p_ZAU_ID := NULL;
			p_ZAU_OPERATION := NULL;
			p_ZAU_TIMESTAMP := NULL;
			p_ZAU_PROCESS_ID := NULL;
			p_ZAU_SIBLING_ID := NULL;
	END;

END GET_LAST_AUDIT_ENTRY;
---------------------------------------------------------------------
PROCEDURE GET_LAST_AUDIT_ENTRY
	(
	p_TABLE_NAME IN VARCHAR2,
	p_COLUMN_VALUES IN UT.STRING_MAP,
	p_ZAU_ID OUT NUMBER,
	p_ZAU_OPERATION OUT CHAR,
	p_ZAU_TIMESTAMP OUT TIMESTAMP,
	p_ZAU_PROCESS_ID OUT NUMBER,
	p_ZAU_SIBLING_ID OUT NUMBER
	) AS

v_TABLE_ID	SYSTEM_TABLE.TABLE_ID%TYPE;

BEGIN

	SELECT ST.TABLE_ID
	INTO v_TABLE_ID
	FROM SYSTEM_TABLE ST
	WHERE ST.DB_TABLE_NAME = p_TABLE_NAME;

	GET_LAST_AUDIT_ENTRY(v_TABLE_ID,
		p_COLUMN_VALUES,
		p_ZAU_ID,
		p_ZAU_OPERATION,
		p_ZAU_TIMESTAMP,
		p_ZAU_PROCESS_ID,
		p_ZAU_SIBLING_ID);

END GET_LAST_AUDIT_ENTRY;
---------------------------------------------------------------------
PROCEDURE GET_LAST_AUDIT_ENTRY
	(
	p_SYSTEM_TABLE_ID IN NUMBER,
	p_COLUMN_NAME1 IN VARCHAR2,
	p_COLUMN_VAL1 IN VARCHAR2,
	p_COLUMN_NAME2 IN VARCHAR2 := NULL,
	p_COLUMN_VAL2 IN VARCHAR2 := NULL,
	p_COLUMN_NAME3 IN VARCHAR2 := NULL,
	p_COLUMN_VAL3 IN VARCHAR2 := NULL,
	p_COLUMN_NAME4 IN VARCHAR2 := NULL,
	p_COLUMN_VAL4 IN VARCHAR2 := NULL,
	p_COLUMN_NAME5 IN VARCHAR2 := NULL,
	p_COLUMN_VAL5 IN VARCHAR2 := NULL,
	p_ZAU_ID OUT NUMBER,
	p_ZAU_OPERATION OUT CHAR,
	p_ZAU_TIMESTAMP OUT TIMESTAMP,
	p_ZAU_PROCESS_ID OUT NUMBER,
	p_ZAU_SIBLING_ID OUT NUMBER
	) AS

v_MAP UT.STRING_MAP;

BEGIN

	v_MAP(p_COLUMN_NAME1) := p_COLUMN_VAL1;

	-- Others are optional
	IF p_COLUMN_NAME2 IS NOT NULL THEN
		v_MAP(p_COLUMN_NAME2) := p_COLUMN_VAL2;
	END IF;
	IF p_COLUMN_NAME3 IS NOT NULL THEN
		v_MAP(p_COLUMN_NAME3) := p_COLUMN_VAL3;
	END IF;
	IF p_COLUMN_NAME4 IS NOT NULL THEN
		v_MAP(p_COLUMN_NAME4) := p_COLUMN_VAL4;
	END IF;
	IF p_COLUMN_NAME5 IS NOT NULL THEN
		v_MAP(p_COLUMN_NAME5) := p_COLUMN_VAL5;
	END IF;

	GET_LAST_AUDIT_ENTRY(p_SYSTEM_TABLE_ID,
		v_MAP,
		p_ZAU_ID,
		p_ZAU_OPERATION,
		p_ZAU_TIMESTAMP,
		p_ZAU_PROCESS_ID,
		p_ZAU_SIBLING_ID);

END GET_LAST_AUDIT_ENTRY;
---------------------------------------------------------------------
PROCEDURE GET_LAST_AUDIT_ENTRY
	(
	p_TABLE_NAME IN VARCHAR2,
	p_COLUMN_NAME1 IN VARCHAR2,
	p_COLUMN_VAL1 IN VARCHAR2,
	p_COLUMN_NAME2 IN VARCHAR2 := NULL,
	p_COLUMN_VAL2 IN VARCHAR2 := NULL,
	p_COLUMN_NAME3 IN VARCHAR2 := NULL,
	p_COLUMN_VAL3 IN VARCHAR2 := NULL,
	p_COLUMN_NAME4 IN VARCHAR2 := NULL,
	p_COLUMN_VAL4 IN VARCHAR2 := NULL,
	p_COLUMN_NAME5 IN VARCHAR2 := NULL,
	p_COLUMN_VAL5 IN VARCHAR2 := NULL,
	p_ZAU_ID OUT NUMBER,
	p_ZAU_OPERATION OUT CHAR,
	p_ZAU_TIMESTAMP OUT TIMESTAMP,
	p_ZAU_PROCESS_ID OUT NUMBER,
	p_ZAU_SIBLING_ID OUT NUMBER
	) AS

v_MAP UT.STRING_MAP;

BEGIN

	v_MAP(p_COLUMN_NAME1) := p_COLUMN_VAL1;

	-- Others are optional
	IF p_COLUMN_NAME2 IS NOT NULL THEN
		v_MAP(p_COLUMN_NAME2) := p_COLUMN_VAL2;
	END IF;
	IF p_COLUMN_NAME3 IS NOT NULL THEN
		v_MAP(p_COLUMN_NAME3) := p_COLUMN_VAL3;
	END IF;
	IF p_COLUMN_NAME4 IS NOT NULL THEN
		v_MAP(p_COLUMN_NAME4) := p_COLUMN_VAL4;
	END IF;
	IF p_COLUMN_NAME5 IS NOT NULL THEN
		v_MAP(p_COLUMN_NAME5) := p_COLUMN_VAL5;
	END IF;

	GET_LAST_AUDIT_ENTRY(p_TABLE_NAME,
		v_MAP,
		p_ZAU_ID,
		p_ZAU_OPERATION,
		p_ZAU_TIMESTAMP,
		p_ZAU_PROCESS_ID,
		p_ZAU_SIBLING_ID);

END GET_LAST_AUDIT_ENTRY;
---------------------------------------------------------------------
FUNCTION GET_LITERAL_VALUE
	(
	p_COLUMN_NAME IN VARCHAR2,
	p_COLUMN_STRING_VAL IN VARCHAR2 := NULL,
	p_COLUMN_NUMBER_VAL IN NUMBER := NULL,
	p_COLUMN_DATE_VAL IN DATE := NULL
	) RETURN VARCHAR2 IS

BEGIN

	IF p_COLUMN_STRING_VAL IS NULL AND p_COLUMN_NUMBER_VAL IS NULL AND p_COLUMN_DATE_VAL IS NULL THEN
		RETURN CONSTANTS.LITERAL_NULL;
	ELSE
		-- only one non-null value allowed
		ASSERT((p_COLUMN_STRING_VAL IS NOT NULL AND p_COLUMN_NUMBER_VAL IS NULL AND p_COLUMN_DATE_VAL IS NULL)
				OR (p_COLUMN_STRING_VAL IS NULL AND p_COLUMN_NUMBER_VAL IS NOT NULL AND p_COLUMN_DATE_VAL IS NULL)
				OR (p_COLUMN_STRING_VAL IS NULL AND p_COLUMN_NUMBER_VAL IS NULL AND p_COLUMN_DATE_VAL IS NOT NULL),
			p_COLUMN_NAME||' column cannot map to more than one value',
			MSGCODES.c_ERR_ARGUMENT);

		IF p_COLUMN_STRING_VAL IS NOT NULL THEN
			RETURN UT.GET_LITERAL_FOR_STRING(p_COLUMN_STRING_VAL);
		ELSIF p_COLUMN_NUMBER_VAL IS NOT NULL THEN
			RETURN UT.GET_LITERAL_FOR_NUMBER(p_COLUMN_NUMBER_VAL);
		ELSE
			RETURN UT.GET_LITERAL_FOR_DATE(p_COLUMN_DATE_VAL);
		END IF;
	END IF;

END GET_LITERAL_VALUE;
---------------------------------------------------------------------
FUNCTION GET_WHO_CHANGED
	(
	p_TABLE_NAME IN VARCHAR2,
	p_COLUMN1_NAME IN VARCHAR2,
	p_COLUMN1_STRING_VAL IN VARCHAR2 := NULL,
	p_COLUMN1_NUMBER_VAL IN NUMBER := NULL,
	p_COLUMN1_DATE_VAL IN DATE := NULL,
	p_COLUMN2_NAME IN VARCHAR2 := NULL,
	p_COLUMN2_STRING_VAL IN VARCHAR2 := NULL,
	p_COLUMN2_NUMBER_VAL IN NUMBER := NULL,
	p_COLUMN2_DATE_VAL IN DATE := NULL,
	p_COLUMN3_NAME IN VARCHAR2 := NULL,
	p_COLUMN3_STRING_VAL IN VARCHAR2 := NULL,
	p_COLUMN3_NUMBER_VAL IN NUMBER := NULL,
	p_COLUMN3_DATE_VAL IN DATE := NULL,
	p_COLUMN4_NAME IN VARCHAR2 := NULL,
	p_COLUMN4_STRING_VAL IN VARCHAR2 := NULL,
	p_COLUMN4_NUMBER_VAL IN NUMBER := NULL,
	p_COLUMN4_DATE_VAL IN DATE := NULL,
	p_COLUMN5_NAME IN VARCHAR2 := NULL,
	p_COLUMN5_STRING_VAL IN VARCHAR2 := NULL,
	p_COLUMN5_NUMBER_VAL IN NUMBER := NULL,
	p_COLUMN5_DATE_VAL IN DATE := NULL
	) RETURN VARCHAR2 IS

v_MAP UT.STRING_MAP;

v_ZAU_ID NUMBER;
v_ZAU_OPERATION CHAR;
v_ZAU_TIMESTAMP TIMESTAMP;
v_ZAU_PROCESS_ID NUMBER;
v_ZAU_SIBLING_ID NUMBER;

v_USER_NAME APPLICATION_USER.USER_DISPLAY_NAME%TYPE;

BEGIN

	v_MAP(p_COLUMN1_NAME) := GET_LITERAL_VALUE(p_COLUMN1_NAME, p_COLUMN1_STRING_VAL, p_COLUMN1_NUMBER_VAL, p_COLUMN1_DATE_VAL);

	-- Others are optional
	IF p_COLUMN2_NAME IS NOT NULL THEN
		v_MAP(p_COLUMN2_NAME) :=  GET_LITERAL_VALUE(p_COLUMN2_NAME, p_COLUMN2_STRING_VAL, p_COLUMN2_NUMBER_VAL, p_COLUMN2_DATE_VAL);
	END IF;
	IF p_COLUMN3_NAME IS NOT NULL THEN
		v_MAP(p_COLUMN3_NAME) :=  GET_LITERAL_VALUE(p_COLUMN3_NAME, p_COLUMN3_STRING_VAL, p_COLUMN3_NUMBER_VAL, p_COLUMN3_DATE_VAL);
	END IF;
	IF p_COLUMN4_NAME IS NOT NULL THEN
		v_MAP(p_COLUMN4_NAME) := GET_LITERAL_VALUE(p_COLUMN4_NAME, p_COLUMN4_STRING_VAL, p_COLUMN4_NUMBER_VAL, p_COLUMN4_DATE_VAL);
	END IF;
	IF p_COLUMN5_NAME IS NOT NULL THEN
		v_MAP(p_COLUMN5_NAME) :=  GET_LITERAL_VALUE(p_COLUMN5_NAME, p_COLUMN5_STRING_VAL, p_COLUMN5_NUMBER_VAL, p_COLUMN5_DATE_VAL);
	END IF;

	GET_LAST_AUDIT_ENTRY(p_TABLE_NAME, v_MAP,
						v_ZAU_ID, v_ZAU_OPERATION, v_ZAU_TIMESTAMP,
						v_ZAU_PROCESS_ID, v_ZAU_SIBLING_ID);

	-- Get the username from the Process Id
	SELECT MAX(NVL(U.USER_DISPLAY_NAME, U.USER_NAME))
	INTO v_USER_NAME
	FROM PROCESS_LOG P, APPLICATION_USER U
	WHERE P.PROCESS_ID = v_ZAU_PROCESS_ID
		AND U.USER_ID = P.USER_ID;

	RETURN v_USER_NAME;

END GET_WHO_CHANGED;
---------------------------------------------------------------------
FUNCTION GET_WHEN_CHANGED
	(
	p_TABLE_NAME IN VARCHAR2,
	p_COLUMN1_NAME IN VARCHAR2,
	p_COLUMN1_STRING_VAL IN VARCHAR2 := NULL,
	p_COLUMN1_NUMBER_VAL IN NUMBER := NULL,
	p_COLUMN1_DATE_VAL IN DATE := NULL,
	p_COLUMN2_NAME IN VARCHAR2 := NULL,
	p_COLUMN2_STRING_VAL IN VARCHAR2 := NULL,
	p_COLUMN2_NUMBER_VAL IN NUMBER := NULL,
	p_COLUMN2_DATE_VAL IN DATE := NULL,
	p_COLUMN3_NAME IN VARCHAR2 := NULL,
	p_COLUMN3_STRING_VAL IN VARCHAR2 := NULL,
	p_COLUMN3_NUMBER_VAL IN NUMBER := NULL,
	p_COLUMN3_DATE_VAL IN DATE := NULL,
	p_COLUMN4_NAME IN VARCHAR2 := NULL,
	p_COLUMN4_STRING_VAL IN VARCHAR2 := NULL,
	p_COLUMN4_NUMBER_VAL IN NUMBER := NULL,
	p_COLUMN4_DATE_VAL IN DATE := NULL,
	p_COLUMN5_NAME IN VARCHAR2 := NULL,
	p_COLUMN5_STRING_VAL IN VARCHAR2 := NULL,
	p_COLUMN5_NUMBER_VAL IN NUMBER := NULL,
	p_COLUMN5_DATE_VAL IN DATE := NULL
	) RETURN TIMESTAMP IS

v_MAP UT.STRING_MAP;

v_ZAU_ID NUMBER;
v_ZAU_OPERATION CHAR;
v_ZAU_TIMESTAMP TIMESTAMP;
v_ZAU_PROCESS_ID NUMBER;
v_ZAU_SIBLING_ID NUMBER;

BEGIN

	v_MAP(p_COLUMN1_NAME) := GET_LITERAL_VALUE(p_COLUMN1_NAME, p_COLUMN1_STRING_VAL, p_COLUMN1_NUMBER_VAL, p_COLUMN1_DATE_VAL);

	-- Others are optional
	IF p_COLUMN2_NAME IS NOT NULL THEN
		v_MAP(p_COLUMN2_NAME) :=  GET_LITERAL_VALUE(p_COLUMN2_NAME, p_COLUMN2_STRING_VAL, p_COLUMN2_NUMBER_VAL, p_COLUMN2_DATE_VAL);
	END IF;
	IF p_COLUMN3_NAME IS NOT NULL THEN
		v_MAP(p_COLUMN3_NAME) :=  GET_LITERAL_VALUE(p_COLUMN3_NAME, p_COLUMN3_STRING_VAL, p_COLUMN3_NUMBER_VAL, p_COLUMN3_DATE_VAL);
	END IF;
	IF p_COLUMN4_NAME IS NOT NULL THEN
		v_MAP(p_COLUMN4_NAME) := GET_LITERAL_VALUE(p_COLUMN4_NAME, p_COLUMN4_STRING_VAL, p_COLUMN4_NUMBER_VAL, p_COLUMN4_DATE_VAL);
	END IF;
	IF p_COLUMN5_NAME IS NOT NULL THEN
		v_MAP(p_COLUMN5_NAME) :=  GET_LITERAL_VALUE(p_COLUMN5_NAME, p_COLUMN5_STRING_VAL, p_COLUMN5_NUMBER_VAL, p_COLUMN5_DATE_VAL);
	END IF;

	GET_LAST_AUDIT_ENTRY(p_TABLE_NAME, v_MAP,
						v_ZAU_ID, v_ZAU_OPERATION, v_ZAU_TIMESTAMP,
						v_ZAU_PROCESS_ID, v_ZAU_SIBLING_ID);

	RETURN v_ZAU_TIMESTAMP;

END GET_WHEN_CHANGED;
---------------------------------------------------------------------
END AUDIT_TRAIL;
/

