CREATE OR REPLACE PACKAGE BODY PI AS
---------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
    RETURN '$Revision: 1.72 $';
END WHAT_VERSION;
----------------------------------------------------------------------------------------------------
PROCEDURE NULL_CURSOR
	(
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
BEGIN
	OPEN p_CURSOR FOR
		SELECT NULL FROM DUAL WHERE ROWNUM < 0;  --Returns no rows!
END NULL_CURSOR;
---------------------------------------------------------------------------------------------------
FUNCTION GET_PROFILE_VERSION_ID
	(
	p_AS_OF_DATE IN DATE
	) RETURN NUMBER IS

v_VERSION_ID NUMBER;

BEGIN

	SELECT VERSION_ID
	INTO v_VERSION_ID
	FROM VERSION
	WHERE UPPER(VERSION_DOMAIN) = 'PROFILING'
		AND AS_OF_DATE = p_AS_OF_DATE;

	RETURN v_VERSION_ID;

	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			RETURN CONSTANTS.NOT_ASSIGNED;

END GET_PROFILE_VERSION_ID;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_PROFILE_NAME_FROM_LIB_ID
	(
  p_LIBRARY_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- ANSWER WITH ALL LOAD PROFILES FOR A SPECIFIC LIBRARY ID
BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT PROFILE_ID, PROFILE_NAME
		  FROM  LOAD_PROFILE
      WHERE PROFILE_LIBRARY_ID = p_LIBRARY_ID
  		ORDER BY 2;


END GET_PROFILE_NAME_FROM_LIB_ID;
----------------------------------------------------------------------------------------------------
FUNCTION GET_PROFILE_NAME
	(
	p_PROFILE_ID IN NUMBER
	) RETURN VARCHAR IS

v_PROFILE_NAME VARCHAR(128);

BEGIN

	SELECT PROFILE_NAME
	INTO v_PROFILE_NAME
	FROM LOAD_PROFILE
	WHERE PROFILE_ID = p_PROFILE_ID;

	RETURN v_PROFILE_NAME;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN '?';

END GET_PROFILE_NAME;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_ACCOUNTS_INTERNAL_EXTERNAL
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- 2893R3_CR
v_acct_filter VARCHAR2(64);
-- ANSWER THE ACCOUNT NAMES IN THE RETAIL_ACCOUNT TABLE with 'INTERNAL' or 'EXTERNAL' appended as appropriate.
BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

   v_acct_filter := nvl( get_dictionary_value('AccountListFilter',
                                             1,
                                             'Profiling',
                                             'Summary',
                                             '?'),
                         '%');
   OPEN p_cursor FOR
      SELECT a.account_id,
             a.account_name ||
             decode(a.is_external_interval_usage, 1, ' External', ' Internal') "NAME_INTERNAL_EXTERNAL"
        FROM account        a,
             account_status s
       WHERE a.account_id = s.account_id
         AND SYSDATE >= s.begin_date
         AND (s.end_date IS NULL OR SYSDATE <= s.end_date)
--@@Begin Implementation Override --
         AND account_name LIKE v_acct_filter
--@@End Implementation Override --
  		ORDER BY 2;

EXCEPTION
   WHEN OTHERS THEN
      p_status := SQLCODE;
      RAISE;
	END GET_ACCOUNTS_INTERNAL_EXTERNAL;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_ACTIVE_ACCOUNTS_NAMES_IDS
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS
v_ACCT_FILTER VARCHAR2(64);

-- ANSWER THE ACCOUNT NAMES AND IDS IN THE ACCOUNT TABLE THAT ARE ACTIVE TODAY.
BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

    v_ACCT_FILTER := NVL(GET_DICTIONARY_VALUE ('AccountListFilter',1,'Profiling','Summary','?'),'%');
	OPEN p_CURSOR FOR
	    SELECT A.ACCOUNT_ID,
			  A.ACCOUNT_NAME
		FROM  ACCOUNT A ,ACCOUNT_STATUS S
		WHERE
			  A.ACCOUNT_ID=S.ACCOUNT_ID
			  AND SYSDATE >= S.BEGIN_DATE
			  AND (S.END_DATE IS NULL OR SYSDATE <= S.END_DATE)
        AND ACCOUNT_NAME LIKE v_ACCT_FILTER
  		ORDER BY 2;

	END GET_ACTIVE_ACCOUNTS_NAMES_IDS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_IS_AGGREGATE_ACCOUNT
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ACCOUNT_NAME IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer IS_AGGREGATE_ACCOUNT along with ACCOUNT NAME and ID
-- for the Account matching either the p_ACCOUNT_NAME or p_ACCOUNT_ID.
-- To avoid multiple hits, pass in only NAME or ID, not both;
-- set the other param to 0 or an empty string as appropriate.
BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT ACCOUNT_ID,
			  ACCOUNT_NAME,
			  IS_AGGREGATE_ACCOUNT
		FROM  ACCOUNT
		WHERE
			  (ACCOUNT_ID = p_ACCOUNT_ID OR ACCOUNT_NAME = p_ACCOUNT_NAME)
			  AND ACCOUNT_ID <> 0;

	END GET_IS_AGGREGATE_ACCOUNT;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_USAGE_WRF_TEMPLATE
	(
	P_WRF_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR OUT GA.REFCURSOR
	) AS

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	OPEN P_CURSOR FOR
	SELECT A.WRF_NAME,
		   A.WRF_ALIAS,
		   A.WRF_DESC,
		   A.PARAMETER_ID,
		   A.STATION_ID,
		   C.TEMPLATE_NAME,
		   B.TEMPLATE_ID,
		   B.ALPHA,
		   B.BETA,
		   B.EXTEND_BEGIN_DAYS,
		   B.EXTEND_END_DAYS,
		   B.PARAMETER_MIN,
		   B.PARAMETER_MAX,
		   B.PARAMETER_MIN_TOLERANCE,
		   B.PARAMETER_MAX_TOLERANCE,
		   B.ENTRY_DATE
	FROM USAGE_WRF A,
		USAGE_WRF_TEMPLATE B,
		TEMPLATE C
	WHERE A.WRF_ID = p_WRF_ID
		AND B.WRF_ID = A.WRF_ID
		AND C.TEMPLATE_ID = B.TEMPLATE_ID(+)
		AND C.TEMPLATE_ID > 0;


END GET_USAGE_WRF_TEMPLATE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_USAGE_WRF_TEMPLATE
	(
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_ALPHA IN NUMBER,
	p_BETA IN NUMBER,
	p_EXTEND_BEGIN_DAYS IN NUMBER,
	p_EXTEND_END_DAYS IN NUMBER,
	p_PARAMETER_MIN IN NUMBER,
	p_PARAMETER_MAX IN NUMBER,
	p_PARAMETER_MIN_TOLERANCE IN NUMBER,
	p_PARAMETER_MAX_TOLERANCE IN NUMBER,
	p_OLD_TEMPLATE_ID IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	UPDATE USAGE_WRF_TEMPLATE SET
		TEMPLATE_ID = p_TEMPLATE_ID,
		ALPHA = p_ALPHA,
		BETA = p_BETA,
		EXTEND_BEGIN_DAYS = p_EXTEND_BEGIN_DAYS,
		EXTEND_END_DAYS = p_EXTEND_END_DAYS,
		PARAMETER_MIN = p_PARAMETER_MIN,
		PARAMETER_MAX = p_PARAMETER_MAX,
		PARAMETER_MIN_TOLERANCE = p_PARAMETER_MIN_TOLERANCE,
		PARAMETER_MAX_TOLERANCE = p_PARAMETER_MAX_TOLERANCE,
		ENTRY_DATE = SYSDATE
	WHERE WRF_ID = p_WRF_ID
		AND TEMPLATE_ID = p_OLD_TEMPLATE_ID;

	IF SQL%NOTFOUND THEN
		INSERT INTO USAGE_WRF_TEMPLATE (
			WRF_ID,
			TEMPLATE_ID,
			ALPHA,
			BETA,
			EXTEND_BEGIN_DAYS,
			EXTEND_END_DAYS,
			PARAMETER_MIN,
			PARAMETER_MAX,
			PARAMETER_MIN_TOLERANCE,
			PARAMETER_MAX_TOLERANCE,
			ENTRY_DATE)
		VALUES (
			p_WRF_ID,
			p_TEMPLATE_ID,
			p_ALPHA,
			p_BETA,
			p_EXTEND_BEGIN_DAYS,
			p_EXTEND_END_DAYS,
			p_PARAMETER_MIN,
			p_PARAMETER_MAX,
			p_PARAMETER_MIN_TOLERANCE,
			p_PARAMETER_MAX_TOLERANCE,
			SYSDATE);
	END IF;

END PUT_USAGE_WRF_TEMPLATE;
---------------------------------------------------------------------------------------------------
PROCEDURE INIT_USAGE_WRF_STATISTICS
	(
	p_WRF_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	UPDATE USAGE_WRF_STATISTICS SET AS_OF_DATE = p_AS_OF_DATE
	WHERE
		WRF_ID = p_WRF_ID AND
		TEMPLATE_ID = p_TEMPLATE_ID AND
		SEGMENT_NBR = 1;
	IF SQL%NOTFOUND THEN
		INSERT INTO USAGE_WRF_STATISTICS(WRF_ID,TEMPLATE_ID,SEGMENT_NBR,AS_OF_DATE)
		VALUES(p_WRF_ID,p_TEMPLATE_ID, 1,p_AS_OF_DATE);
	END IF;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_RAISE();
END INIT_USAGE_WRF_STATISTICS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_RATE_CLASS
	(
	p_LIBRARY_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- ANSWER WITH A UNIQUE SET OF RATE CLASSES
BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

		OPEN p_CURSOR FOR
		    SELECT DISTINCT PROFILE_RATE_CLASS
			FROM LOAD_PROFILE
			WHERE (PROFILE_LIBRARY_ID = p_LIBRARY_ID OR p_LIBRARY_ID = CONSTANTS.ALL_ID)
	  		ORDER BY 1;



END GET_RATE_CLASS;
---------------------------------------------------------------------------------------------------

PROCEDURE GET_LOAD_PROFILE_LIBRARIES
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- ANSWER WITH ALL LOAD PROFILE LIBRARIES
BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT PROFILE_LIBRARY_NAME, PROFILE_LIBRARY_ID
		FROM  LOAD_PROFILE_LIBRARY
  		ORDER BY 2;


END GET_LOAD_PROFILE_LIBRARIES;
---------------------------------------------------------------------------------------------------

PROCEDURE GET_ORDERED_PROFILE_LIBRARIES
	(
  p_FILTER IN VARCHAR,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- ANSWER WITH ALL LOAD PROFILE LIBRARIES
BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
	    SELECT PROFILE_LIBRARY_NAME, PROFILE_LIBRARY_ID
		  FROM  LOAD_PROFILE_LIBRARY
      WHERE UPPER(PROFILE_LIBRARY_NAME)
      LIKE UPPER(p_FILTER)
  		ORDER BY 1;


END GET_ORDERED_PROFILE_LIBRARIES;
---------------------------------------------------------------------------------------------------

PROCEDURE GET_WEATHER_STATIONS
	(
	p_LIBRARY_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- ANSWER WITH ALL WEATHER STATIONS
BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

		OPEN p_CURSOR FOR
		    SELECT DISTINCT WS.STATION_NAME, WS.STATION_ID
			FROM WEATHER_STATION WS, LOAD_PROFILE LP
			WHERE
				  (LP.PROFILE_LIBRARY_ID = p_LIBRARY_ID OR p_LIBRARY_ID = CONSTANTS.ALL_ID)
				  AND WS.STATION_ID = LP.PROFILE_STATION_ID
	  		ORDER BY 2;



END GET_WEATHER_STATIONS;
---------------------------------------------------------------------------------------------------

PROCEDURE GET_LOAD_RESEARCH_PROFILES
	(
	p_PROFILE_SET_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_LIBRARY_ID IN NUMBER,
	p_RATE_CLASS IN VARCHAR,
	p_WEATHER_STATION_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

	v_HIGH_NUMBER NUMBER := 999999;
	v_BEGIN_DATE DATE;
	v_END_DATE DATE;

-- Answer the profile data for populating the Load Research grid,
-- based on the profiles in the selected p_PROFILE_SET_ID, and also
-- the profiles matching the filters for library, rate class, and W. Station.
-- Modified 3/4/2004 - wjc,abx,msg - Depending on system_dictionary setting, 'QueryResultSetMembersOnly',
--          either query Result Set only, or Result Set AND other Profiles meeting filter criteria.

BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	UT.CUT_DATE_RANGE(TRUNC(p_BEGIN_DATE), TRUNC(p_END_DATE), LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

    IF '0' = NVL(MODEL_VALUE_AT_KEY(GA.DEFAULT_MODEL, g_DOMAIN_NAME, 'LoadResearch', 'QueryResultSetMembersOnly'), '0') THEN
        --Query Result Set AND other Profiles meeting filter criteria
        OPEN p_CURSOR FOR
        	SELECT /*+ ORDERED INDEX(LPP) USE_NL(LPL,LP) USE_NL(LP,WS) USE_NL(LP,LPSM) */
        	    LPL.PROFILE_LIBRARY_NAME "Library",
        		LP.PROFILE_RATE_CLASS "Rate Class",
        		WS.STATION_NAME "W. Station",
        		LP.PROFILE_ID "ID",
        		LP.PROFILE_NAME "Name (Meter)",
        		LPSM.BEGIN_DATE "Begin",
        		LPSM.END_DATE "End",
        		LPSM.WEIGHT_FACTOR "Weight",
        		0 "Graph",
        		MAX(LPP.POINT_VAL) "Max",
        		MIN(DECODE(LPP.POINT_VAL, 0, v_HIGH_NUMBER, LPP.POINT_VAL)) "Min",
        		SUM(DECODE(LPP.POINT_VAL, 0, 1, 0)) "# Zeros",
        		SUM(LPP.POINT_VAL) "Total Load",
        		DECODE(MAX(LPP.POINT_VAL),0,'N/A',TO_CHAR(AVG(LPP.POINT_VAL) / MAX(LPP.POINT_VAL),'0.99999999')) "Load Factor",
        		LP.PROFILE_SOURCE_BEGIN_DATE "Source Begin",
        		LP.PROFILE_SOURCE_END_DATE "Source End"
        	FROM
        		LOAD_PROFILE_LIBRARY LPL,
        		LOAD_PROFILE LP,
        		WEATHER_STATION WS,
        		LOAD_PROFILE_SET_MEMBER LPSM,
        		LOAD_PROFILE_POINT LPP
        	WHERE LPP.PROFILE_ID = LP.PROFILE_ID
        	  AND LP.PROFILE_LIBRARY_ID = LPL.PROFILE_LIBRARY_ID
        	  AND LP.PROFILE_STATION_ID = WS.STATION_ID
        	  AND LPP.AS_OF_DATE = p_AS_OF_DATE
        	  AND LPP.POINT_INDEX = 1
        	  AND LPP.POINT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
        	  AND LPSM.PROFILE_SET_ID(+) = p_PROFILE_SET_ID
        	  AND LP.PROFILE_ID = LPSM.PROFILE_ID(+)
        	  AND (LP.PROFILE_ID = LPSM.PROFILE_ID
        	   	   OR (
        		   	  (LP.PROFILE_LIBRARY_ID = p_LIBRARY_ID OR p_LIBRARY_ID = CONSTANTS.ALL_ID)
        		   	  AND (LP.PROFILE_RATE_CLASS = p_RATE_CLASS OR p_RATE_CLASS = '<ALL>')
        		   	  AND (LP.PROFILE_STATION_ID = p_WEATHER_STATION_ID OR p_WEATHER_STATION_ID = CONSTANTS.ALL_ID)
        			  )
        		   )
        	GROUP BY LPL.PROFILE_LIBRARY_NAME, LP.PROFILE_RATE_CLASS, WS.STATION_NAME, LP.PROFILE_ID,
        		  	 LP.PROFILE_NAME, LPSM.WEIGHT_FACTOR, LPSM.BEGIN_DATE, LPSM.END_DATE, LP.PROFILE_SOURCE_BEGIN_DATE, LP.PROFILE_SOURCE_END_DATE;

    ELSE
        --Query Result Set ONLY
        OPEN p_CURSOR FOR
        	SELECT /*+ ORDERED INDEX(LPP) USE_NL(LPL,LP) USE_NL(LP,WS) USE_NL(LP,LPSM) */
        	    LPL.PROFILE_LIBRARY_NAME "Library",
        		LP.PROFILE_RATE_CLASS "Rate Class",
        		WS.STATION_NAME "W. Station",
        		LP.PROFILE_ID "ID",
        		LP.PROFILE_NAME "Name (Meter)",
        		LPSM.BEGIN_DATE "Begin",
        		LPSM.END_DATE "End",
        		LPSM.WEIGHT_FACTOR "Weight",
        		0 "Graph",
        		MAX(LPP.POINT_VAL) "Max",
        		MIN(DECODE(LPP.POINT_VAL, 0, v_HIGH_NUMBER, LPP.POINT_VAL)) "Min",
        		SUM(DECODE(LPP.POINT_VAL, 0, 1, 0)) "# Zeros",
        		SUM(LPP.POINT_VAL) "Total Load",
        		DECODE(MAX(LPP.POINT_VAL),0,'N/A',TO_CHAR(AVG(LPP.POINT_VAL) / MAX(LPP.POINT_VAL),'0.99999999')) "Load Factor",
        		LP.PROFILE_SOURCE_BEGIN_DATE "Source Begin",
        		LP.PROFILE_SOURCE_END_DATE "Source End"
        	FROM
        		LOAD_PROFILE_LIBRARY LPL,
        		LOAD_PROFILE LP,
        		WEATHER_STATION WS,
        		LOAD_PROFILE_SET_MEMBER LPSM,
        		LOAD_PROFILE_POINT LPP
        	WHERE LPP.PROFILE_ID = LP.PROFILE_ID
        	  AND LP.PROFILE_LIBRARY_ID = LPL.PROFILE_LIBRARY_ID
        	  AND LP.PROFILE_STATION_ID = WS.STATION_ID
        	  AND LPP.AS_OF_DATE = p_AS_OF_DATE
        	  AND LPP.POINT_INDEX = 1
        	  AND LPP.POINT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
        	  AND LPSM.PROFILE_SET_ID = p_PROFILE_SET_ID
        	  AND LP.PROFILE_ID = LPSM.PROFILE_ID
        	  AND (LP.PROFILE_LIBRARY_ID = p_LIBRARY_ID OR p_LIBRARY_ID = CONSTANTS.ALL_ID)
        		AND (LP.PROFILE_RATE_CLASS = p_RATE_CLASS OR p_RATE_CLASS = '<ALL>')
        		AND (LP.PROFILE_STATION_ID = p_WEATHER_STATION_ID OR p_WEATHER_STATION_ID = CONSTANTS.ALL_ID)
        	GROUP BY LPL.PROFILE_LIBRARY_NAME, LP.PROFILE_RATE_CLASS, WS.STATION_NAME, LP.PROFILE_ID,
        		  	 LP.PROFILE_NAME, LPSM.WEIGHT_FACTOR, LPSM.BEGIN_DATE, LPSM.END_DATE, LP.PROFILE_SOURCE_BEGIN_DATE, LP.PROFILE_SOURCE_END_DATE;
	END IF;


END GET_LOAD_RESEARCH_PROFILES;
---------------------------------------------------------------------------------------------------

PROCEDURE GET_LR_RESULTANT_PROFILE
	(
	p_MODEL_ID IN NUMBER,
	p_PROFILE_SET_ID IN NUMBER,
	p_ROLLUP_INTERVAL IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_WANT_AVG IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Compute and answer the Load Research Resultant Profile
-- by combining the historical profiles that are members of the profile set,
-- using either the average of the profiles or a sum of the profiles at each date.

-- The Resultant profile can be rolled up to hourly or daily values,
-- from member profiles having more intervals per day,
-- by passing in 'Hour' or 'Day' as the p_ROLLUP_INTERVAL,
-- otherwise it is rolled up by MInute, which is effectively no rollup.

-- Note: this procedure assumes that the profile set, and the profile members
-- have been saved before this call!!

v_BEGIN_ADJUST NUMBER;
v_END_ADJUST NUMBER;
v_DATE_ADJUST NUMBER;
v_INTERVAL_ABBREV VARCHAR(2);

BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	--
    IF UPPER(p_ROLLUP_INTERVAL) = 'DAY' THEN  --Rolling up to daily profile
        IF p_MODEL_ID = GA.ELECTRIC_MODEL THEN  --Source profiles are hourly or subhourly
           v_BEGIN_ADJUST := g_SECOND;  --Start just after midnight
           v_END_ADJUST := 1;                 --End at midnight of the next day
           v_DATE_ADJUST := 0 - g_SECOND;  --Get midnight into proper day for trunc
        ELSE   --GAS MODEL  --Source profiles are daily
           v_BEGIN_ADJUST := 0;  --No adjustment needed
           v_END_ADJUST := 0;    --No adjustment needed
           v_DATE_ADJUST := 0;  --No adjustment needed
        END IF;
        v_INTERVAL_ABBREV := 'DD';
    ELSE   --hourly or no rollup
        v_BEGIN_ADJUST := g_SECOND;  --Start just after midnight
        v_END_ADJUST := 1;                 --End at midnight of the next day
        IF UPPER(p_ROLLUP_INTERVAL) = 'HOUR' THEN   --'HOUR'  --Rolling up to hourly profile
           v_DATE_ADJUST :=  + 0.0416;  --Get subhourly intervals into proper hour-ending hour by addiing a few seconds less than an hour
           v_INTERVAL_ABBREV := 'HH';
        ELSE   --No rollup
           v_DATE_ADJUST := 0;  --No adjustment needed
           v_INTERVAL_ABBREV := 'MI';
       END IF;
    END IF;


	-- Get either the average profile or a sum of the profile at each date.
	OPEN p_CURSOR FOR
			SELECT TRUNC(LPP.POINT_DATE + v_DATE_ADJUST, v_INTERVAL_ABBREV) "PT_DATE",
			DECODE(p_WANT_AVG,
				   1, SUM(LPP.POINT_VAL * LPSM.WEIGHT_FACTOR) / SUM(LPSM.WEIGHT_FACTOR),
				   SUM(LPP.POINT_VAL )) "RESULT"
			FROM LOAD_PROFILE_POINT LPP,
	            LOAD_PROFILE_SET_MEMBER LPSM
			WHERE LPSM.PROFILE_SET_ID = p_PROFILE_SET_ID
				  AND LPP.PROFILE_ID = LPSM.PROFILE_ID
				  AND LPSM.WEIGHT_FACTOR <> 0
                  AND LPP.AS_OF_DATE = p_AS_OF_DATE
				  AND LPP.POINT_DATE BETWEEN LPSM.BEGIN_DATE + v_BEGIN_ADJUST
				  	  				 	AND LPSM.END_DATE + v_END_ADJUST
			GROUP BY TRUNC(LPP.POINT_DATE + v_DATE_ADJUST, v_INTERVAL_ABBREV);



END GET_LR_RESULTANT_PROFILE;
---------------------------------------------------------------------------------------------------
PROCEDURE CREATE_LR_RESULTANT_PROFILE
	(
	p_MODEL_ID IN NUMBER,
	p_PROFILE_SET_ID IN NUMBER,
	p_RESULTANT_PROFILE_ID IN NUMBER,
	p_PROFILE_STATUS IN VARCHAR,
	p_PROFILE_INTERVALS_PER_DAY IN NUMBER,
	p_ROLLUP_INTERVAL IN VARCHAR,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_WANT_AVG IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

-- Replaces GET_PUT_LR_RESULTANT_PROFILE at 2.5
-- Creates and saves the Load Research Resultant Profile and Statistics
-- by combining the historical profiles that are members of the profile set,
-- using either the average of the profiles or a sum of the profiles at each date.

-- The Resultant profile can be rolled up to hourly or daily values,
-- from member profiles having more intervals per day,
-- by passing in 'Hour' or 'Day' as the p_ROLLUP_INTERVAL,
-- otherwise it is rolled up by MInute, which is effectively no rollup.

-- Note: this procedure assumes that the profile set, and the profile members
-- have been saved before this call!!

v_RESULTANT_BEGIN_DATE DATE;
v_RESULTANT_END_DATE DATE;
v_PT_DATE DATE;
v_RESULT NUMBER;
c_RESULTANT GA.REFCURSOR;

BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	-- Get the Resultant profile.
	GET_LR_RESULTANT_PROFILE
    	(
    	p_MODEL_ID,
    	p_PROFILE_SET_ID,
    	p_ROLLUP_INTERVAL,
    	p_AS_OF_DATE,
    	p_WANT_AVG,
    	p_STATUS,
    	c_RESULTANT
    	);

    --Make sure Load_Profile_Set has the correct resultant Profile_ID
    UPDATE LOAD_PROFILE_SET SET
        PROFILE_ID = p_RESULTANT_PROFILE_ID,
        ENTRY_DATE = SYSDATE
    WHERE PROFILE_SET_ID = p_PROFILE_SET_ID;

    --Set Profile_Interval, dates in Profile
    UPDATE LOAD_PROFILE SET
        PROFILE_TYPE = 'Historical',
        PROFILE_INTERVAL = p_PROFILE_INTERVALS_PER_DAY,
        PROFILE_SOURCE_BEGIN_DATE = TRUNC(p_BEGIN_DATE),
        PROFILE_SOURCE_END_DATE = TRUNC(p_END_DATE),
        ENTRY_DATE = SYSDATE
    WHERE PROFILE_ID = p_RESULTANT_PROFILE_ID;

   --Delete old Resultant profile points
    DELETE LOAD_PROFILE_POINT
    WHERE PROFILE_ID = p_RESULTANT_PROFILE_ID;

    --Save the Resultant profile points
    LOOP
        FETCH c_RESULTANT INTO v_PT_DATE, v_RESULT;
        EXIT WHEN c_RESULTANT%NOTFOUND;

        PF.PUT_LOAD_PROFILE_POINT
            (
            p_RESULTANT_PROFILE_ID,
            1,
            v_PT_DATE,
            p_AS_OF_DATE,
            v_RESULT,
            p_STATUS
			);
    END LOOP;
    CLOSE c_RESULTANT;

    -- Create and store the Resultant profile's statistics
    SELECT MIN(POINT_DATE), MAX(POINT_DATE)
    INTO v_RESULTANT_BEGIN_DATE, v_RESULTANT_END_DATE
    FROM LOAD_PROFILE_POINT
    WHERE PROFILE_ID = p_RESULTANT_PROFILE_ID
    AND AS_OF_DATE  = p_AS_OF_DATE;

    PUT_LP_RESULTANT_STATISTICS
    	(
        p_RESULTANT_PROFILE_ID,
        p_PROFILE_STATUS,
    	p_AS_OF_DATE,
    	TRUNC(v_RESULTANT_BEGIN_DATE),
    	TRUNC(v_RESULTANT_END_DATE),
    	p_STATUS
        );



END CREATE_LR_RESULTANT_PROFILE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_PUT_LR_RESULTANT_PROFILE
	(
	p_PROFILE_SET_ID IN NUMBER,
	p_RESULTANT_PROFILE_ID IN NUMBER,
	p_PROFILE_STATUS IN VARCHAR,
	p_PROFILE_INTERVAL IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_WANT_AVG IN NUMBER,
	p_WANT_SAVE IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- DEPRECATED at 2.5
-- Replaced by GET_SAVE_LR_RESULTANT_PROFILE

	v_BEGIN_DATE DATE;
	v_END_DATE DATE;
	v_RESULTANT_BEGIN_DATE DATE;
	v_RESULTANT_END_DATE DATE;

	CURSOR RESULTANT_cur IS
			SELECT LPP.POINT_DATE "PT_DATE",
			DECODE(p_WANT_AVG,
				   1, SUM(LPP.POINT_VAL * LPSM.WEIGHT_FACTOR) / SUM(LPSM.WEIGHT_FACTOR),
				   SUM(LPP.POINT_VAL )) "RESULT"
			FROM LOAD_PROFILE_POINT LPP,
	            LOAD_PROFILE_SET_MEMBER LPSM
			WHERE LPSM.PROFILE_SET_ID = p_PROFILE_SET_ID
				  AND LPP.PROFILE_ID = LPSM.PROFILE_ID
				  AND LPSM.WEIGHT_FACTOR <> 0
				  AND LPP.POINT_DATE BETWEEN LPSM.BEGIN_DATE+.00001
				  	  				 	AND LPSM.END_DATE+1
			GROUP BY LPP.POINT_DATE;


BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	--In VB(store profile set, and profile members)

	UT.CUT_DATE_RANGE(TRUNC(p_BEGIN_DATE), TRUNC(p_END_DATE), LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	-- Get either the average profile or a sum of the profile at each date.
	OPEN p_CURSOR FOR
			SELECT LPP.POINT_DATE "PT_DATE",
			DECODE(p_WANT_AVG,
				   1, SUM(LPP.POINT_VAL * LPSM.WEIGHT_FACTOR) / SUM(LPSM.WEIGHT_FACTOR),
				   SUM(LPP.POINT_VAL )) "RESULT"
			FROM LOAD_PROFILE_POINT LPP,
	            LOAD_PROFILE_SET_MEMBER LPSM
			WHERE LPSM.PROFILE_SET_ID = p_PROFILE_SET_ID
				  AND LPP.PROFILE_ID = LPSM.PROFILE_ID
				  AND LPSM.WEIGHT_FACTOR <> 0
				  AND LPP.POINT_DATE BETWEEN LPSM.BEGIN_DATE+.00001
				  	  				 	AND LPSM.END_DATE+1
			GROUP BY LPP.POINT_DATE;


	IF p_WANT_SAVE = 1 THEN
		--Make sure Load_Profile_Set has the correct resultant Profile_ID
		UPDATE LOAD_PROFILE_SET SET
			PROFILE_ID = p_RESULTANT_PROFILE_ID,
			ENTRY_DATE = SYSDATE
		WHERE PROFILE_SET_ID = p_PROFILE_SET_ID;

		--Set Profile_Interval, dates in Profile
		UPDATE LOAD_PROFILE SET
			PROFILE_TYPE = 'Historical',
			PROFILE_INTERVAL = p_PROFILE_INTERVAL,
			PROFILE_SOURCE_BEGIN_DATE = TRUNC(p_BEGIN_DATE),
			PROFILE_SOURCE_END_DATE = TRUNC(p_END_DATE),
			ENTRY_DATE = SYSDATE
		WHERE PROFILE_ID = p_RESULTANT_PROFILE_ID;

		--Save the resultant profile points
		FOR v_Resultant IN RESULTANT_cur
		LOOP

			PF.PUT_LOAD_PROFILE_POINT(p_RESULTANT_PROFILE_ID,
				1,
				v_Resultant.PT_DATE,
				p_AS_OF_DATE,
				v_Resultant.RESULT,
				p_STATUS
			);

		END LOOP;

		-- Create and store the resultant profile's statistics
		SELECT MIN(POINT_DATE), MAX(POINT_DATE)
		INTO v_RESULTANT_BEGIN_DATE, v_RESULTANT_END_DATE
		FROM LOAD_PROFILE_POINT
		WHERE PROFILE_ID = p_RESULTANT_PROFILE_ID
		AND AS_OF_DATE  = p_AS_OF_DATE;

		PUT_LP_RESULTANT_STATISTICS(p_RESULTANT_PROFILE_ID,
					p_PROFILE_STATUS,
					p_AS_OF_DATE,
					TRUNC(v_RESULTANT_BEGIN_DATE),
					TRUNC(v_RESULTANT_END_DATE),
					p_STATUS);

	END IF;


END GET_PUT_LR_RESULTANT_PROFILE;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_LP_SET_MEMBER
	(
	p_PROFILE_SET_ID IN NUMBER,
	p_PROFILE_ID IN NUMBER,
	p_WEIGHT_FACTOR IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_MEMBER_ID IN NUMBER,
	p_STATUS OUT NUMBER
	)
	AS


-- PUT a LOAD_PROFILE_SET_MEMBER record.

v_COUNT NUMBER := 0;
v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

	--MAKE SURE USER HAS APPROPRIATE ACCESS

	IF NOT CAN_WRITE('Data Setup') THEN
		ERRS.RAISE_NO_WRITE_MODULE('Data Setup');
	END IF;

	p_STATUS := GA.SUCCESS;

	-- Use whole days for Begin and End dates
	v_BEGIN_DATE := TRUNC(p_BEGIN_DATE);
	v_END_DATE := TRUNC(p_END_DATE);

	-- CHECK IF THIS RECORD EXISTS
	SELECT COUNT(*)
	INTO v_COUNT
	FROM LOAD_PROFILE_SET_MEMBER
	WHERE PROFILE_SET_ID = p_PROFILE_SET_ID
		AND PROFILE_ID = p_PROFILE_ID
		AND BEGIN_DATE = v_BEGIN_DATE;


	IF v_COUNT > 0 THEN
		UPDATE LOAD_PROFILE_SET_MEMBER SET
			WEIGHT_FACTOR = p_WEIGHT_FACTOR,
			END_DATE = v_END_DATE,
			ENTRY_DATE = SYSDATE
		WHERE PROFILE_SET_ID = p_PROFILE_SET_ID
			AND PROFILE_ID = p_PROFILE_ID
			AND BEGIN_DATE = v_BEGIN_DATE;	   -- wjc: Can have different weights for different periods

		p_STATUS := p_PROFILE_SET_ID;

	ELSE --INSERT A NEW RECORD

		INSERT INTO LOAD_PROFILE_SET_MEMBER (
			PROFILE_SET_ID,
			PROFILE_ID,
			WEIGHT_FACTOR,
			BEGIN_DATE,
			END_DATE,
			ENTRY_DATE)
		VALUES (
			p_PROFILE_SET_ID,
			p_PROFILE_ID,
			p_WEIGHT_FACTOR,
			v_BEGIN_DATE,
			v_END_DATE,
			SYSDATE);

		RETURN;
	END IF;



END PUT_LP_SET_MEMBER;

---------------------------------------------------------------------------------------------------

PROCEDURE GET_LP_SET_MEMBER
	(
	p_PROFILE_SET_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	)
	AS


BEGIN

--MAKE SURE USER HAS APPROPRIATE ACCESS

	IF NOT CAN_READ('Data Setup') THEN
		ERRS.RAISE_NO_READ_MODULE('Data Setup');
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT PROFILE_SET_ID, PROFILE_ID, WEIGHT_FACTOR,
			BEGIN_DATE, END_DATE, ENTRY_DATE
		FROM LOAD_PROFILE_SET_MEMBER
		WHERE PROFILE_SET_ID = p_PROFILE_SET_ID;

END GET_LP_SET_MEMBER;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_LP_RESULTANT_STATISTICS
	(
	p_RESULTANT_PROFILE_ID IN NUMBER,
	p_PROFILE_STATUS IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER
	)
	AS

	v_HIGH_NUMBER NUMBER := 999;
	-- Create stats (USe the ID)

	CURSOR c_RESULTANT_STATS IS
		SELECT COUNT(POINT_VAL) "RCOUNT",
     --- rss 2016/02/23   (AVG(POINT_VAL) / MAX(POINT_VAL)) "RLOADFACTOR",
      decode (  max(point_val), 0, 0 ,(AVG(POINT_VAL) / MAX(POINT_VAL))) "RLOADFACTOR",
			MIN(POINT_VAL) "RMIN",
			MIN(DECODE(POINT_VAL, 0, v_HIGH_NUMBER, POINT_VAL)) "RNZ_MIN",
			MAX(POINT_VAL) "RMAX",
			SUM(POINT_VAL) "RSUM"
		FROM LOAD_PROFILE_POINT
		WHERE PROFILE_ID = p_RESULTANT_PROFILE_ID;
	c_RESULTANT_STATS_rec c_RESULTANT_STATS%ROWTYPE;

BEGIN

--MAKE SURE USER HAS APPROPRIATE ACCESS

	IF NOT CAN_WRITE('Data Setup') THEN
		ERRS.RAISE_NO_WRITE_MODULE('Data Setup');
	END IF;

	p_STATUS := GA.SUCCESS;

	OPEN c_RESULTANT_STATS;
	FETCH c_RESULTANT_STATS INTO c_RESULTANT_STATS_rec;

	-- Save stats (Use the ID)
	PF.PUT_LOAD_PROFILE_STATISTICS(p_RESULTANT_PROFILE_ID,
				GET_PROFILE_VERSION_ID(p_AS_OF_DATE),
				p_AS_OF_DATE,
				TRUNC(p_BEGIN_DATE),
				TRUNC(p_END_DATE),
				c_RESULTANT_STATS_rec.RCOUNT,
				c_RESULTANT_STATS_rec.RLOADFACTOR,
				c_RESULTANT_STATS_rec.RMIN,
				c_RESULTANT_STATS_rec.RNZ_MIN,
				c_RESULTANT_STATS_rec.RMAX,
				c_RESULTANT_STATS_rec.RSUM,
    			0, -- PROFILE_MEAN_APE,
    			0, -- PROFILE_AVG_DEV_APE,
    			0, -- PROFILE_TOTAL_ERROR_PCT,
    			0, -- R_SQUARED_MIN,
    			0, -- R_SQUARED_MAX,
    			0, -- R_SQUARED_FAIL_PCT,
    			0, -- T_STAT_TEMP_FAIL_PCT,
    			0, -- T_STAT_HUMID_FAIL_PCT,
    			0, -- T_STAT_WIND_FAIL_PCT,
				p_PROFILE_STATUS,
				p_STATUS
				);



END PUT_LP_RESULTANT_STATISTICS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_LP_POINTS_TO_GRAPH
	(
	p_PROFILE_IDS IN VARCHAR,
	p_AS_OF_DATE IN DATE,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

	 v_BEGIN_DATE DATE;
	 v_END_DATE DATE;

	 v_BEGIN_DATE_STRING VARCHAR(32);
	 v_END_DATE_STRING VARCHAR(32);

	 v_SELECT VARCHAR(400);
	 v_SQL VARCHAR(4000);

BEGIN

	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;


	UT.CUT_DATE_RANGE(TRUNC(p_BEGIN_DATE), TRUNC(p_END_DATE), LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

	 v_BEGIN_DATE_STRING := TO_CHAR(v_BEGIN_DATE, 'DD-Mon-YYYY HH24:MI:SS');
	 v_END_DATE_STRING := TO_CHAR(v_END_DATE, 'DD-Mon-YYYY HH24:MI:SS');

	v_SELECT := 'SELECT LP.PROFILE_NAME, LPP.POINT_DATE, LPP.POINT_VAL FROM LOAD_PROFILE_POINT LPP, LOAD_PROFILE LP WHERE LP.PROFILE_ID = LPP.PROFILE_ID AND LPP.POINT_DATE BETWEEN TO_DATE(''' || v_BEGIN_DATE_STRING || ''',''DD-Mon-YYYY HH24:MI:SS'') AND TO_DATE(''' || v_END_DATE_STRING || ''',''DD-Mon-YYYY HH24:MI:SS'') AND LP.PROFILE_ID IN ';
    v_SQL := v_SELECT || p_PROFILE_IDS;

	--v_SELECT := 'SELECT LP.PROFILE_NAME, LPP.POINT_DATE, LPP.POINT_VAL FROM LOAD_PROFILE_POINT LPP, LOAD_PROFILE LP WHERE LP.PROFILE_ID = LPP.PROFILE_ID AND LPP.POINT_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE';
	--v_SQL := v_SELECT;

	--INSERT INTO TRACE_BIG VALUES(v_SELECT);
	--COMMIT;
	OPEN p_CURSOR FOR
		v_SQL;


	END GET_LP_POINTS_TO_GRAPH;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_NUM_ZEROS_FROM_PROFILE
	(
	p_PROFILE_ID IN NUMBER,
	p_NUM_ZEROS OUT NUMBER,
	p_STATUS OUT NUMBER
	) AS

-- Answer number of zeros in a profile.
BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	    SELECT SUM(DECODE(LOAD_PROFILE_POINT.POINT_VAL, 0, 1, 0))
		INTO p_NUM_ZEROS
		FROM LOAD_PROFILE_POINT
		WHERE LOAD_PROFILE_POINT.PROFILE_ID = p_PROFILE_ID;



END GET_NUM_ZEROS_FROM_PROFILE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_RESULT_PROFILE_FROM_SET
	(
	p_PROFILE_SET_ID IN NUMBER,
	p_R_PROFILE_ID OUT NUMBER,
	p_R_PROFILE_NAME OUT VARCHAR2,
	p_STATUS OUT NUMBER
	) AS

-- Answer the resultant profile ID and name associated with the Profile Set.
BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	SELECT PROFILE_ID
	INTO p_R_PROFILE_ID
	FROM LOAD_PROFILE_SET
	WHERE LOAD_PROFILE_SET.PROFILE_SET_ID = p_PROFILE_SET_ID;

	p_R_PROFILE_NAME := GET_PROFILE_NAME(p_R_PROFILE_ID );


END GET_RESULT_PROFILE_FROM_SET;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_PROFILE_ID_BY_ACCOUNT_REF
	(
	p_ACCOUNT_ID IN NUMBER,
	p_PROFILE_COUNT OUT NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer cursor with PROFILE_IDs linked to given account.
BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	SELECT COUNT(PROFILE_ID)
	INTO p_PROFILE_COUNT
	FROM LOAD_PROFILE
	WHERE PROFILE_ACCOUNT_REF = TO_CHAR(p_ACCOUNT_ID);

	OPEN p_CURSOR FOR
		SELECT PROFILE_ID
		FROM LOAD_PROFILE
		WHERE PROFILE_ACCOUNT_REF = TO_CHAR(p_ACCOUNT_ID);


END GET_PROFILE_ID_BY_ACCOUNT_REF;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_PROFILE_STATISTICS_CUR
	(
	p_PROFILE_ID IN NUMBER,
	p_VERSION_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer cursor with PROFILE_STATISTICS for a given PROFILE.
BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT *
		FROM LOAD_PROFILE_STATISTICS
		WHERE PROFILE_ID = p_PROFILE_ID
		  AND VERSION_ID = p_VERSION_ID;


END GET_PROFILE_STATISTICS_CUR;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_PROFILE_LIBRARY_STATS
	(
	p_LIBRARY_NAME_FILTER IN VARCHAR,
	p_PROFILE_STATUS IN VARCHAR,
	p_VERSION_ID IN NUMBER,
	p_EXCLUDE_USAGE_WRFS IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer cursor with Summary Profile Statistics for matching LIBRARY names.

v_PROFILE_STATUS VARCHAR(16);

BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

    v_PROFILE_STATUS := UPPER(p_PROFILE_STATUS);

	OPEN p_CURSOR FOR
        SELECT C.PROFILE_LIBRARY_NAME "LIBRARY_NAME",
        	   A.PROFILE_LIBRARY_ID "PROFILE_LIBRARY_ID",
        	   COUNT(B.PROFILE_MAX) "PROFILE_COUNT",
        	   MAX(B.PROFILE_MAX) "PROFILE_MAX",
        	   MIN(B.PROFILE_MIN) "PROFILE_MIN",
        	   MIN(B.PROFILE_NZ_MIN) "PROFILE_NZ_MIN",
        	   SUM(B.PROFILE_SUM) "PROFILE_SUM",
        	   MAX(B.R_SQUARED_MAX) "R_SQUARED_MAX",
        	   MIN(B.R_SQUARED_MIN) "R_SQUARED_MIN",
        	   MAX(B.R_SQUARED_FAIL_PCT) "R_SQUARED_FAILED_MAX",
        	   MIN(B.R_SQUARED_FAIL_PCT) "R_SQUARED_FAILED_MIN",
        	   MAX(B.T_STAT_TEMP_FAIL_PCT) "T_STAT_TEMP_MAX",
        	   MIN(B.T_STAT_TEMP_FAIL_PCT) "T_STAT_TEMP_MIN",
        	   MAX(B.T_STAT_HUMID_FAIL_PCT) "T_STAT_HUMID_MAX",
        	   MIN(B.T_STAT_HUMID_FAIL_PCT) "T_STAT_HUMID_MIN",
        	   MAX(B.T_STAT_WIND_FAIL_PCT) "T_STAT_WIND_MAX",
        	   MIN(B.T_STAT_WIND_FAIL_PCT) "T_STAT_WIND_MIN",
        	   B.VERSION_ID "VERSION_ID"
        FROM LOAD_PROFILE A,
        	 LOAD_PROFILE_STATISTICS B,
        	 LOAD_PROFILE_LIBRARY C
        WHERE A.PROFILE_ID = B.PROFILE_ID
            AND A.PROFILE_LIBRARY_ID = C.PROFILE_LIBRARY_ID
            AND (p_LIBRARY_NAME_FILTER IS NULL OR C.PROFILE_LIBRARY_NAME Like p_LIBRARY_NAME_FILTER)
            AND (v_PROFILE_STATUS = 'ALL' OR UPPER(B.PROFILE_STATUS) = v_PROFILE_STATUS)
            AND (p_EXCLUDE_USAGE_WRFS = 0 OR A.PROFILE_TYPE <> 'UsageWRF')
            AND B.VERSION_ID = p_VERSION_ID
        GROUP BY A.PROFILE_LIBRARY_ID, C.PROFILE_LIBRARY_NAME, B.VERSION_ID
        ORDER BY A.PROFILE_LIBRARY_ID;


END GET_PROFILE_LIBRARY_STATS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_WRF_PARAMETER_CATEGORIES
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer cursor with DISTINCT UPPER(WEATHER_PARAMETER.PARAMETER_CATEGORY)
-- for parameters used in WRFs.
BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT DISTINCT UPPER(WP.PARAMETER_CATEGORY) PARAMETER_CATEGORY
		FROM LOAD_PROFILE LP, LOAD_PROFILE_WRF_WEATHER LPW, WEATHER_PARAMETER WP
		WHERE LPW.PROFILE_ID  = LP.PROFILE_ID
		  AND WP.PARAMETER_ID  = LPW.PARAMETER_ID;


END GET_WRF_PARAMETER_CATEGORIES;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_WRF_PROFILE_PARAMETERS
	(
	p_PROFILE_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer cursor with WRF WEATHER PARAMETERS for a given PROFILE.
BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT LP.PROFILE_NAME ,
			   LP.PROFILE_ID,
			   WP.PARAMETER_NAME,
			   UPPER(WP.PARAMETER_CATEGORY) "PARAMETER_CATEGORY",
			   NVL(WP.PARAMETER_ID, 0) "PARAMETER_ID"
		FROM LOAD_PROFILE LP, LOAD_PROFILE_STATISTICS S, LOAD_PROFILE_WRF_WEATHER W, WEATHER_PARAMETER WP
		WHERE LP.PROFILE_ID = p_PROFILE_ID
		  AND S.PROFILE_ID  = LP.PROFILE_ID
		  AND W.PROFILE_ID  = LP.PROFILE_ID
		  AND WP.PARAMETER_ID  = W.PARAMETER_ID;


END GET_WRF_PROFILE_PARAMETERS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_WRF_PROFILE_BREAKPOINTS
	(
	p_PROFILE_ID IN NUMBER,
	p_WRF_HOUR IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the 4 values per hour that were used in creating the given WRF (PROFILE_ID),
-- at the given hour, or all hours if p_WRF_HOUR = CONSTANTS.ALL_ID (-1).
-- Note: If there are hourly values in SEGMENT_MIN and SEGMENT_MAX in
-- the LOAD_PROFILE_WRF_LINE table (as there will be for DB regression), they are used;
-- otherwise, the non-hourly values in LOAD_PROFILE_WRF will be returned for all hours requested.

BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
        --Note: The DECODEs effectively transpose the values in the
        --WRF_LINE_NBR column to the PT_n columns in the resultant cursor.
        SELECT B.WRF_HOUR,
			   SUM(DECODE(WRF_LINE_NBR,1,NVL(B.SEGMENT_MIN, A.SEGMENT_MIN),0)) "PT_1",
			   SUM(DECODE(WRF_LINE_NBR,2,NVL(B.SEGMENT_MIN, A.SEGMENT_MIN),0)) "PT_2",
			   SUM(DECODE(WRF_LINE_NBR,3,NVL(B.SEGMENT_MIN, A.SEGMENT_MIN),0)) "PT_3",
			   SUM(DECODE(WRF_LINE_NBR,3,NVL(B.SEGMENT_MAX, A.SEGMENT_MAX),0)) "PT_4"
        FROM LOAD_PROFILE_WRF A, LOAD_PROFILE_WRF_LINE B
        WHERE A.WRF_ID = B.WRF_ID
            AND A.PROFILE_ID = p_PROFILE_ID
            AND (p_WRF_HOUR = CONSTANTS.ALL_ID OR B.WRF_HOUR = p_WRF_HOUR)
        GROUP BY B.WRF_HOUR;

	END GET_WRF_PROFILE_BREAKPOINTS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_VALUES_FOR_BREAKPOINT
	(
	p_BREAKPOINT_ID IN NUMBER,
	p_BREAKPOINT_HOUR IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the 4 values per hour for the given breakpoint,
-- at the given hour, or all hours if p_BREAKPOINT_HOUR = CONSTANTS.ALL_ID (-1).
-- Note:The display names for the "PT_n" columns should match
-- the parameter names for the 4 points in PUT_VALUES_FOR_BREAKPOINT_HOUR,
-- to enable MightyGrid.SaveRow to automate saving.

BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
        --Note: The DECODEs effectively transpose the values in the
        --BREAKPOINT_NBR column to the PT_n columns in the resultant cursor.
		SELECT DISTINCT BREAKPOINT_HOUR,
			   SUM(DECODE(BREAKPOINT_NBR,1,BREAKPOINT_VAL,0)) "PT_1",
			   SUM(DECODE(BREAKPOINT_NBR,2,BREAKPOINT_VAL,0)) "PT_2",
			   SUM(DECODE(BREAKPOINT_NBR,3,BREAKPOINT_VAL,0)) "PT_3",
			   SUM(DECODE(BREAKPOINT_NBR,4,BREAKPOINT_VAL,0)) "PT_4"
		FROM BREAKPOINT_VALUE
		WHERE BREAKPOINT_ID = p_BREAKPOINT_ID
            AND (p_BREAKPOINT_HOUR = CONSTANTS.ALL_ID OR BREAKPOINT_HOUR = p_BREAKPOINT_HOUR)
		GROUP BY BREAKPOINT_HOUR;

	END GET_VALUES_FOR_BREAKPOINT;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_BREAKPOINT_VALUE
	(
	p_BREAKPOINT_ID IN NUMBER,
	p_BREAKPOINT_HOUR IN NUMBER,
	p_BREAKPOINT_NBR IN NUMBER,
	p_BREAKPOINT_VAL IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

-- SAVE THE GIVEN BREAKPOINT_VAL.
BEGIN
    p_STATUS := GA.SUCCESS;

	UPDATE BREAKPOINT_VALUE
	SET BREAKPOINT_VAL = p_BREAKPOINT_VAL,
		ENTRY_DATE = SYSDATE
	WHERE BREAKPOINT_ID = p_BREAKPOINT_ID
	  AND BREAKPOINT_HOUR = p_BREAKPOINT_HOUR
	  AND BREAKPOINT_NBR = p_BREAKPOINT_NBR;

	IF SQL%NOTFOUND THEN
		INSERT INTO BREAKPOINT_VALUE (
			BREAKPOINT_ID,
			BREAKPOINT_HOUR,
			BREAKPOINT_NBR,
			BREAKPOINT_VAL,
			ENTRY_DATE)
		VALUES (
			p_BREAKPOINT_ID,
			p_BREAKPOINT_HOUR,
			p_BREAKPOINT_NBR,
			p_BREAKPOINT_VAL,
			SYSDATE);
	END IF;


	END PUT_BREAKPOINT_VALUE;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_VALUES_FOR_BREAKPOINT_HOUR
	(
	p_BREAKPOINT_ID IN NUMBER,
	p_BREAKPOINT_HOUR IN NUMBER,
	p_PT_1 IN NUMBER,
	p_PT_2 IN NUMBER,
	p_PT_3 IN NUMBER,
	p_PT_4 IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

-- SAVE THE 4 VALUES PER HOUR FOR THE GIVEN BREAKPOINT.
-- PARAMETER NAMES FOR THE 4 POINTS SHOULD MATCH THE DISPLAY NAMES IN GET_VALUES_FOR_BREAKPOINT
-- TO ENABLE MIGHTYGRID.SAVEROW TO AUTOMATE SAVING.

v_INDEX BINARY_INTEGER;
v_PT_VALUES GA.NUMBER_TABLE;

BEGIN
	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	v_PT_VALUES(1) := p_PT_1;
	v_PT_VALUES(2) := p_PT_2;
	v_PT_VALUES(3) := p_PT_3;
	v_PT_VALUES(4) := p_PT_4;

	FOR v_INDEX IN v_PT_VALUES.FIRST .. v_PT_VALUES.LAST
	LOOP
		PUT_BREAKPOINT_VALUE(p_BREAKPOINT_ID,p_BREAKPOINT_HOUR,v_INDEX,v_PT_VALUES(v_INDEX),p_STATUS);
	END LOOP;

	END PUT_VALUES_FOR_BREAKPOINT_HOUR;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_SEASON_BREAKPOINTS
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- ANSWER THE HOURLY_BREAKPOINTS.
BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT DISTINCT A.SEASON_ID, C.PARAMETER_ID,
			   D.BREAKPOINT_ID,
			   SUM(DECODE(BREAKPOINT_NBR,1,BREAKPOINT_VAL,0)) "PT_1",
			   SUM(DECODE(BREAKPOINT_NBR,2,BREAKPOINT_VAL,0)) "PT_2",
			   SUM(DECODE(BREAKPOINT_NBR,3,BREAKPOINT_VAL,0)) "PT_3",
			   SUM(DECODE(BREAKPOINT_NBR,4,BREAKPOINT_VAL,0)) "PT_4"
		FROM SEASON A,SEASON_BREAKPOINT C, BREAKPOINT D, BREAKPOINT_VALUE E
		WHERE A.SEASON_ID = C.SEASON_ID
		  AND D.BREAKPOINT_ID = NVL(C.BREAKPOINT_ID,0)
		  AND E.BREAKPOINT_ID = D.BREAKPOINT_ID
		  AND E.BREAKPOINT_HOUR = 0
		GROUP BY A.SEASON_ID, C.PARAMETER_ID,
			   D.BREAKPOINT_ID;


	END GET_SEASON_BREAKPOINTS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_TEMPLATE_BREAKPOINTS
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- ANSWER THE templates and DEFAULT BREAKPOINTS for populating the Template/Breakpoints grid with daily breakpoints.
-- MODIFIED:
--     11/20/03 WJC- Return NULL for hourly breakpoints instead of the (incorrect) hour 0 breakpoints, which are valid only for daily breakpoints.
BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
        --Note: The DECODEs effectively transpose the values in the
        --BREAKPOINT_NBR column to the PT_n columns in the resultant cursor, returning daily breakpoints only.
		SELECT DISTINCT A.TEMPLATE_ID, A.PARAMETER_1_ID, A.PARAMETER_2_ID, A.PARAMETER_3_ID, A.PARAMETER_4_ID, A.PARAMETER_5_ID,
			   B.BREAKPOINT_ID,
			   SUM(DECODE(C.BREAKPOINT_NBR,1,DECODE(D.MAX_HOUR,0,C.BREAKPOINT_VAL,NULL),NULL)) "PT_1",
			   SUM(DECODE(C.BREAKPOINT_NBR,2,DECODE(D.MAX_HOUR,0,C.BREAKPOINT_VAL,NULL),NULL)) "PT_2",
			   SUM(DECODE(C.BREAKPOINT_NBR,3,DECODE(D.MAX_HOUR,0,C.BREAKPOINT_VAL,NULL),NULL)) "PT_3",
			   SUM(DECODE(C.BREAKPOINT_NBR,4,DECODE(D.MAX_HOUR,0,C.BREAKPOINT_VAL,NULL),NULL)) "PT_4"
		FROM
			(SELECT TEMPLATE_ID,
    				MAX(DECODE(VARIABLE_NBR,1,PARAMETER_ID,0)) "PARAMETER_1_ID",
    				MAX(DECODE(VARIABLE_NBR,2,PARAMETER_ID,0)) "PARAMETER_2_ID",
    				MAX(DECODE(VARIABLE_NBR,3,PARAMETER_ID,0)) "PARAMETER_3_ID",
    				MAX(DECODE(VARIABLE_NBR,4,PARAMETER_ID,0)) "PARAMETER_4_ID",
    				MAX(DECODE(VARIABLE_NBR,5,PARAMETER_ID,0)) "PARAMETER_5_ID"
    			FROM TEMPLATE_BREAKPOINT
    			GROUP BY TEMPLATE_ID) A,
            TEMPLATE_BREAKPOINT B,
            BREAKPOINT_VALUE C,
            (SELECT BREAKPOINT_ID, MAX(BREAKPOINT_HOUR) "MAX_HOUR"
                FROM BREAKPOINT_VALUE
                GROUP BY BREAKPOINT_ID ) D
		WHERE B.TEMPLATE_ID = A.TEMPLATE_ID
			AND B.VARIABLE_NBR = 1
			AND C.BREAKPOINT_ID = B.BREAKPOINT_ID
			AND D.BREAKPOINT_ID = B.BREAKPOINT_ID
			AND C.BREAKPOINT_HOUR = 0
		GROUP BY A.TEMPLATE_ID, A.PARAMETER_1_ID, A.PARAMETER_2_ID, A.PARAMETER_3_ID, A.PARAMETER_4_ID, A.PARAMETER_5_ID, B.BREAKPOINT_ID
        ORDER BY 1,2,3,4,5,6;

	END GET_TEMPLATE_BREAKPOINTS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_EDIT_WRF_BREAKPOINTS
	(
	p_BREAKPOINT_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- ANSWER THE values of the given BREAKPOINTs for populating the EditWRF Breakpoints grid with daily breakpoints.

BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
        --Note: The DECODEs effectively transpose the values in the
        --BREAKPOINT_NBR column to the PT_n columns in the resultant cursor, returning daily breakpoints only.
		SELECT DISTINCT
			   B.BREAKPOINT_ID,
			   SUM(DECODE(C.BREAKPOINT_NBR,1,DECODE(D.MAX_HOUR,0,C.BREAKPOINT_VAL,NULL),NULL)) "PT_1",
			   SUM(DECODE(C.BREAKPOINT_NBR,2,DECODE(D.MAX_HOUR,0,C.BREAKPOINT_VAL,NULL),NULL)) "PT_2",
			   SUM(DECODE(C.BREAKPOINT_NBR,3,DECODE(D.MAX_HOUR,0,C.BREAKPOINT_VAL,NULL),NULL)) "PT_3",
			   SUM(DECODE(C.BREAKPOINT_NBR,4,DECODE(D.MAX_HOUR,0,C.BREAKPOINT_VAL,NULL),NULL)) "PT_4"
		FROM
            BREAKPOINT B,
            BREAKPOINT_VALUE C,
            (SELECT BREAKPOINT_ID, MAX(BREAKPOINT_HOUR) "MAX_HOUR"
                FROM BREAKPOINT_VALUE
                GROUP BY BREAKPOINT_ID ) D
		WHERE (p_BREAKPOINT_ID = CONSTANTS.ALL_ID OR B.BREAKPOINT_ID = p_BREAKPOINT_ID)
			AND C.BREAKPOINT_ID = B.BREAKPOINT_ID
			AND D.BREAKPOINT_ID = B.BREAKPOINT_ID
			AND C.BREAKPOINT_HOUR = 0
		GROUP BY B.BREAKPOINT_ID;

	END GET_EDIT_WRF_BREAKPOINTS;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_WRF_LINE_VALUES
	(
	p_PROFILE_ID IN NUMBER,
	p_SEGMENT_NUMBER IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- ANSWER THE values of the given BREAKPOINTs for populating the EditWRF Breakpoints grid with daily breakpoints.

BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
        SELECT
               B.WRF_HOUR,
               A.PROFILE_ID,
               A.WRF_LINE_NBR "Segment",
               B.SEGMENT_MIN, B.SEGMENT_MAX,
               B.R_SQUARED,
               B.COEFF_0 "Constant",
               B.COEFF_1, B.COEFF_2, B.COEFF_3, B.COEFF_4, B.COEFF_5,
               B.TSTAT_0 "Constant T-Stat",
               B.TSTAT_1, B.TSTAT_2, B.TSTAT_3, B.TSTAT_4, B.TSTAT_5,
               B.TSTAT_CRITICAL
        FROM LOAD_PROFILE_WRF A,
             LOAD_PROFILE_WRF_LINE B
        WHERE B.WRF_ID = A.WRF_ID
              AND A.PROFILE_ID = p_PROFILE_ID --185 --TEST
              AND (p_SEGMENT_NUMBER = CONSTANTS.ALL_ID OR A.WRF_LINE_NBR = p_SEGMENT_NUMBER)
        ORDER BY 2,3,1;


	END GET_WRF_LINE_VALUES;
---------------------------------------------------------------------------------------------------
PROCEDURE PUT_TEMPLATE_BREAKPOINT
	(
	p_TEMPLATE_ID IN NUMBER,
	p_PARAMETER_1_ID IN NUMBER,
	p_PARAMETER_2_ID IN NUMBER,
	p_PARAMETER_3_ID IN NUMBER,
	p_PARAMETER_4_ID IN NUMBER,
	p_PARAMETER_5_ID IN NUMBER,
	p_BREAKPOINT_ID IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

v_INDEX BINARY_INTEGER;
v_VIDS GA.ID_TABLE;
v_PIDS GA.ID_TABLE;
v_SYSDATE DATE := SYSDATE;

BEGIN

	IF NOT CAN_WRITE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	DELETE TEMPLATE_BREAKPOINT WHERE TEMPLATE_ID = p_TEMPLATE_ID;

    IF p_BREAKPOINT_ID >= 0 THEN     -- If p_BREAKPOINT_ID < 0 then DELETE only
    	v_PIDS(1) := p_PARAMETER_1_ID;
    	v_PIDS(2) := p_PARAMETER_2_ID;
    	v_PIDS(3) := p_PARAMETER_3_ID;
    	v_PIDS(4) := p_PARAMETER_4_ID;
    	v_PIDS(5) := p_PARAMETER_5_ID;

    	v_VIDS(1) := 1;
    	v_VIDS(2) := 2;
    	v_VIDS(3) := 3;
    	v_VIDS(4) := 4;
    	v_VIDS(5) := 5;

    	FORALL v_INDEX IN 1..v_VIDS.COUNT
    		INSERT INTO TEMPLATE_BREAKPOINT(TEMPLATE_ID, VARIABLE_NBR, PARAMETER_ID, BREAKPOINT_ID, ENTRY_DATE)
    		VALUES(p_TEMPLATE_ID, v_VIDS(v_INDEX), v_PIDS(v_INDEX), p_BREAKPOINT_ID, v_SYSDATE);
    END IF;

END PUT_TEMPLATE_BREAKPOINT;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_SEASON_TEMPLATE_DATES
	(
	p_TEMPLATE_ID IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- ANSWER THE SEASON DATES FOR THE GIVEN TEMPLATE.
BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
		SELECT DISTINCT B.TEMPLATE_NAME, C.SEASON_NAME, C.SEASON_ID, C.BEGIN_DATE, C.END_DATE
		FROM TEMPLATE_SEASON_DAY_NAME TSDN, TEMPLATE B, SEASON C
		WHERE B.TEMPLATE_ID = p_TEMPLATE_ID
		  AND TSDN.SEASON_ID = C.SEASON_ID
		  AND TSDN.TEMPLATE_ID = B.TEMPLATE_ID
		ORDER BY B.TEMPLATE_NAME, C.BEGIN_DATE;

	END GET_SEASON_TEMPLATE_DATES;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_SEASON_TEMPLATE_DAYTYPES
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- ANSWER THE SEASON DAYTYPES.

BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
        SELECT UNIQUE B.TEMPLATE_NAME, TSDN.DAY_NAME, C.BEGIN_DATE, C.END_DATE, C.SEASON_ID, B.TEMPLATE_ID
        FROM TEMPLATE_SEASON_DAY_NAME TSDN, TEMPLATE B, SEASON C
        WHERE TSDN.TEMPLATE_ID = B.TEMPLATE_ID
          AND TSDN.SEASON_ID = C.SEASON_ID
          AND NVL(B.IS_DAY_TYPE, 1) = 1
        ORDER BY B.TEMPLATE_NAME, C.BEGIN_DATE;

	END GET_SEASON_TEMPLATE_DAYTYPES;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_TYPICAL_DAY_BY_ACCOUNT
	(
	p_MODEL_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_SEASON_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_APP_LOG_DOMAIN_NAME IN VARCHAR DEFAULT 'Profiling',
	p_APP_LOG_APP_NAME IN VARCHAR DEFAULT 'PI',
	p_APP_LOG_EVENT_NAME IN VARCHAR DEFAULT 'GET_TYPICAL_DAY_BY_ACCOUNT',
	p_APP_LOG_EVENT_USER_NAME IN VARCHAR DEFAULT 'UNKNOWN',
	p_SOURCE_PROFILE_ID OUT NUMBER,
	p_PROFILE_INTERVAL OUT NUMBER,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_PROFILE_COUNT NUMBER;
c_PROFILE_IDS GA.REFCURSOR;

-- Answer cursor with Typical Day values based on account, season, and template.

BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	GET_PROFILE_ID_BY_ACCOUNT_REF(p_ACCOUNT_ID,v_PROFILE_COUNT,p_STATUS, c_PROFILE_IDS);

	IF p_STATUS >= 0 THEN
		--LOOP	-- No loop for now, just return the 1st profile_Id found
		--Get Profile_Id of the source profile
		FETCH c_PROFILE_IDS INTO p_SOURCE_PROFILE_ID;
			--EXIT WHEN c_PROFILE_IDS%NOTFOUND;
		--END LOOP;

		IF v_PROFILE_COUNT > 1 THEN
		    LOGS.LOG_WARN('More than one profile has ACCOUNT_REF='||TO_CHAR(p_ACCOUNT_ID)||'. Only first profile used');
		END IF;

		--Get Intervals per day for this profile
		SELECT PROFILE_INTERVAL
		INTO p_PROFILE_INTERVAL
		FROM LOAD_PROFILE
		WHERE PROFILE_ID = p_SOURCE_PROFILE_ID;

		GET_TYPICAL_DAY_FROM_PROFILE(p_MODEL_ID,p_SOURCE_PROFILE_ID,p_TEMPLATE_ID,p_SEASON_ID,p_BEGIN_DATE,p_END_DATE,p_AS_OF_DATE,p_STATUS, p_CURSOR);
	ELSE
		NULL_CURSOR(p_CURSOR);
	END IF;

	CLOSE c_PROFILE_IDS;



END GET_TYPICAL_DAY_BY_ACCOUNT;
---------------------------------------------------------------------------------------------------
PROCEDURE CREATE_TYPICAL_DAYS_FOR_ACCT
	(
	p_MODEL_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_SEASON_ID IN NUMBER,
    p_DAY_TYPE_TEXT IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
    p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER
	) AS

v_PROCESS_NAME VARCHAR2(32) := 'PI.CREATE_TYPICAL_DAYS_FOR_ACCT';
v_PROFILE_COUNT NUMBER;
c_PROFILE_IDS GA.REFCURSOR;
v_PROFILE_ID NUMBER;
v_NEW_PROFILE_ID NUMBER;
v_NEW_LIBRARY_ID NUMBER;
v_PREFIX_NAME VARCHAR2(64);
v_IS_METER_MODELED NUMBER;
v_METER_IDS GA.ID_TABLE;
v_METER_ID NUMBER;
v_METER_NAME METER.METER_NAME%TYPE;
v_ACCOUNT_NAME VARCHAR2(64);
v_INDEX NUMBER;
v_ERR_MSG VARCHAR2(265);
v_ERR_ACCT VARCHAR2(128);

-- Answer cursor with Typical Day values based on account, season, and template.

BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

    v_ACCOUNT_NAME := CS.GET_ACCOUNT_NAME(p_ACCOUNT_ID);
    v_ERR_ACCT := 'Error in Typical Day for Account '||v_ACCOUNT_NAME;
    v_ERR_MSG := v_ERR_ACCT;

    --Determine if Meter-Modeled WRFs are allowed
    v_IS_METER_MODELED := TO_NUMBER(MODEL_VALUE_AT_KEY(GA.DEFAULT_MODEL, g_DOMAIN_NAME, 'Batch', 'AllowMeterModeledWRFs'));

    IF v_IS_METER_MODELED = 1 THEN
        --Determine if this Account is Meter-Modeled
        SELECT DECODE(SUBSTR(A.ACCOUNT_MODEL_OPTION,1,1),'M', 1, 0)
        INTO v_IS_METER_MODELED
        FROM ACCOUNT A
        WHERE ACCOUNT_ID = p_ACCOUNT_ID;
    END IF;

    IF v_IS_METER_MODELED = 1 THEN
    	v_METER_IDS := PF.GET_METER_IDS_FOR_ACCOUNT(p_ACCOUNT_ID);
        --Create one profile for each meter assigned to this account
        FOR v_INDEX IN v_METER_IDS.FIRST..v_METER_IDS.LAST LOOP
            v_METER_ID := v_METER_IDS(v_INDEX);
            v_METER_NAME := PF.GET_METER_NAME(v_METER_ID);
            v_ERR_MSG := v_ERR_ACCT || ', Meter: '||v_METER_NAME;

            v_PROFILE_ID := PF.GET_PROFILE_ID_FROM_METER_REF(v_METER_ID);

            IF v_PROFILE_ID > 0 THEN
              --@@Begin Implementation Override --
                 -- Begin BRC Change 4/27/2006: add system date to end of typical day profile names
                 --  v_PREFIX_NAME := 'TYPICAL_' || v_METER_NAME || '_METER';
                v_PREFIX_NAME := 'TYPICAL_' || v_METER_NAME || '_METER_'|| TO_CHAR(SYSDATE,'YYYY_MM_DD');
              --@@End Implementation Override --End BRC Change 4/27/2006

				-- ignore season parameter and compute typical day profile for all seasons in template
                 PF.CREATE_TYPICAL_DAY_FOR_PROF(p_MODEL_ID,v_PROFILE_ID,p_ACCOUNT_ID,v_METER_ID,v_PREFIX_NAME,p_TEMPLATE_ID,CONSTANTS.ALL_ID,
            			p_DAY_TYPE_TEXT,p_BEGIN_DATE,p_END_DATE,p_AS_OF_DATE,p_TRACE_ON,v_NEW_PROFILE_ID,v_NEW_LIBRARY_ID,p_STATUS);
            ELSE
        	  	LOGS.LOG_WARN(v_ERR_MSG || ' - No Profile assigned (METER_ID: ' || TO_CHAR(v_METER_ID) || ')');
            END IF;
        END LOOP;
    ELSE  --ACCOUNT MODELED
    	v_PROFILE_ID := PF.GET_PROFILE_ID(p_ACCOUNT_ID);

        v_METER_ID := NULL;

       --@@Begin Implementation Override --
       -- Begin BRC Change 4/27/2006: add system date to end of typical day profile names
       -- v_PREFIX_NAME := 'TYPICAL_' || v_ACCOUNT_NAME;
          v_PREFIX_NAME := 'TYPICAL_' || v_ACCOUNT_NAME || '_' || TO_CHAR(SYSDATE,'YYYY_MM_DD');
      --@@End Implementation Override --End BRC Change 4/27/2006

        -- ignore season parameter and compute typical day profile for all seasons in template
        PF.CREATE_TYPICAL_DAY_FOR_PROF(p_MODEL_ID,v_PROFILE_ID,p_ACCOUNT_ID,v_METER_ID,v_PREFIX_NAME,p_TEMPLATE_ID,CONSTANTS.ALL_ID,
    			p_DAY_TYPE_TEXT,p_BEGIN_DATE,p_END_DATE,p_AS_OF_DATE,p_TRACE_ON,v_NEW_PROFILE_ID,v_NEW_LIBRARY_ID,p_STATUS);
    END IF;



END CREATE_TYPICAL_DAYS_FOR_ACCT;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_TYPICAL_DAY_FROM_PROFILE
	(
	p_MODEL_ID IN NUMBER,
	p_PROFILE_ID IN NUMBER,
	p_TEMPLATE_ID IN NUMBER,
	p_SEASON_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_ADJUST NUMBER(6,5);
v_ADD_INTERVAL NUMBER;

-- Answer cursor with Typical Day values based on season template dates and day_names.

BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	UT.CUT_DATE_RANGE(p_MODEL_ID,p_BEGIN_DATE, p_END_DATE, LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);
	--v_BEGIN_DATE := TO_DATE('01-JAN-1999','DD-MON-YYYY hh24:mi:ss'); --TESTING
	--v_END_DATE := TO_DATE('07-JAN-1999','DD-MON-YYYY hh24:mi:ss'); --TESTING

	IF p_MODEL_ID = GA.GAS_MODEL THEN
		v_ADJUST := 0;
		v_ADD_INTERVAL := 0;
	ELSE
		v_ADJUST := g_SECOND;	--Adjustment to get midnite into proper HED day
		v_ADD_INTERVAL := 1;	--
	END IF;

	OPEN p_CURSOR FOR
		SELECT
		  --Add seconds of POINT_DATE to TRUNC(LOW_DATE) to get same intervals in Typical Day dates
		  TRUNC(LOW_DATE) + ((TO_NUMBER(TO_CHAR(d.POINT_DATE - v_ADJUST, 'SSSSS')))/86400 + v_ADJUST) "TYPICAL_DAY_DATE", --
		  AVG(d.POINT_VAL) "TYPICAL_DAY_VALUE"
		  --,COUNT(d.POINT_VAL) "COUNT"
		  --,SUM(d.POINT_VAL)
		FROM
		  (SELECT UNIQUE TEMPLATE_ID, SEASON_ID FROM TEMPLATE_SEASON_DAY_NAME) a,
		  SEASON c,
		  LOAD_PROFILE_POINT d
		WHERE
		  d.PROFILE_ID = p_PROFILE_ID
		  AND a.SEASON_ID = c.SEASON_ID
		  AND d.POINT_INDEX = 1
		  AND d.POINT_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		  AND d.POINT_DATE BETWEEN
		  	--Adjust season dates to desired year - ADD_MONTHS adjusts for Feb 29 in leap year!
		  	--Add months to season begin AND end dates based on difference between BEGIN year and season BEGIN year!
		    v_ADJUST + ADD_MONTHS(c.BEGIN_DATE,12*(TO_NUMBER(TO_CHAR(v_BEGIN_DATE,'yyyy'))-TO_NUMBER(TO_CHAR(c.BEGIN_DATE,'YYYY'))))
			AND v_ADD_INTERVAL + ADD_MONTHS(c.END_DATE,12*(TO_NUMBER(TO_CHAR(v_BEGIN_DATE,'yyyy'))-TO_NUMBER(TO_CHAR(c.BEGIN_DATE,'YYYY'))))
			--Get points that match day_names
		  AND TO_CHAR(d.POINT_DATE - v_ADJUST, 'DY') IN
		  	  (SELECT UNIQUE UPPER(DAY_NAME)
			   FROM SEASON_TEMPLATE
			   WHERE
	    	       TEMPLATE_ID = p_TEMPLATE_ID --2 --
	    		   AND SEASON_ID = p_SEASON_ID --1 --
			   )
			--Handle Holidays
			AND (
				 (TRUNC(d.POINT_DATE - v_ADJUST) NOT IN (SELECT HOLIDAY_DATE FROM HOLIDAY_OBSERVANCE))
				OR
				 (TRUNC(d.POINT_DATE - v_ADJUST) IN (SELECT HOLIDAY_DATE FROM HOLIDAY_OBSERVANCE)
				  AND 'HOL' IN (SELECT UNIQUE UPPER(DAY_NAME) FROM SEASON_TEMPLATE
									WHERE TEMPLATE_ID = p_TEMPLATE_ID AND  SEASON_ID = p_SEASON_ID) --
	    	       	 	   	   	  	--WHERE TEMPLATE_ID=2 AND SEASON_ID=1)
				  )
				 )
		GROUP BY
		  TRUNC(LOW_DATE) + ((TO_NUMBER(TO_CHAR(d.POINT_DATE - v_ADJUST, 'SSSSS')))/86400 + v_ADJUST)
		ORDER BY 1
		;



END GET_TYPICAL_DAY_FROM_PROFILE;
---------------------------------------------------------------------------------------------------
PROCEDURE GET_PRIMARY_PARAMETERS
	(
	p_STATUS OUT NUMBER,
	p_CURSOR IN OUT GA.REFCURSOR
	) AS

-- Answer the parameters whose category is g_PRIMARY_PARAMETER_CATEGORY (Temperature)

BEGIN
	IF NOT CAN_READ(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_READ_MODULE(g_DOMAIN_NAME);
	END IF;

    p_STATUS := GA.SUCCESS;

	OPEN p_CURSOR FOR
         SELECT PARAMETER_NAME, PARAMETER_ID
         FROM WEATHER_PARAMETER
         WHERE UPPER(PARAMETER_CATEGORY) = UPPER(g_PRIMARY_PARAMETER_CATEGORY);

	END GET_PRIMARY_PARAMETERS;
---------------------------------------------------------------------------------------------------
END PI;
/

