CREATE OR REPLACE PACKAGE BODY MS AS

gc_PACKAGE_NAME            CONSTANT VARCHAR(30)  := 'MS';
gc_ANYTIME_TOU_TEMPLATE_ID CONSTANT NUMBER(1)    := CONSTANTS.ANYTIME_TOU_TEMPLATE_ID;
gc_ANYTIME_SD_TEMPLATE_ID  CONSTANT NUMBER(1)    := CONSTANTS.ANYTIME_SD_TEMPLATE_ID;
gc_NOT_ASSIGNED            CONSTANT NUMBER(1)    := CONSTANTS.NOT_ASSIGNED;
gc_GLOBAL_MODEL            CONSTANT NUMBER(1)    := CONSTANTS.GLOBAL_MODEL;
gc_CRLF                    CONSTANT VARCHAR2(10) := UTL_TCP.CRLF;
gc_HIGH_DATE               CONSTANT DATE         := CONSTANTS.HIGH_DATE;

$if $$UNIT_TEST_MODE = 0 OR $$UNIT_TEST_MODE IS NULL $THEN

c_USAGE_FACTOR_HORIZON_ELEC 	NUMBER := NVL(GET_DICTIONARY_VALUE('Calculated Usage Factor Horizon', CONSTANTS.ELECTRIC_MODEL, 'Load Management', 'Usage Factors'), 10);
c_USAGE_FACTOR_HORIZON_GAS 		NUMBER := NVL(GET_DICTIONARY_VALUE('Calculated Usage Factor Horizon', CONSTANTS.GAS_MODEL, 'Load Management', 'Usage Factors'), 10);
c_IS_PROCESSING_UF_ELECTRIC 	BOOLEAN := UT.BOOLEAN_FROM_STRING(NVL(GET_DICTIONARY_VALUE('Calculate Usage Factors on Consumption Import', CONSTANTS.ELECTRIC_MODEL, 'Load Management', 'Usage Factors'), '1'));
c_IS_PROCESSING_UF_GAS 			BOOLEAN := UT.BOOLEAN_FROM_STRING(NVL(GET_DICTIONARY_VALUE('Calculate Usage Factors on Consumption Import', CONSTANTS.GAS_MODEL, 'Load Management', 'Usage Factors'), '1'));

$end
----------------------------------------------------------------------------------------------------
FUNCTION WHAT_VERSION RETURN VARCHAR IS
BEGIN
    RETURN '$Revision: 1.4 $';
END WHAT_VERSION;
----------------------------------------------------------------------------------------------------
FUNCTION GET_NEXT_CUT_DATE
	(
	p_CUT_DATE IN DATE,
	p_SECONDS IN NUMBER,
	p_IS_ADJUSTED_DAY IN BOOLEAN
	) RETURN DATE IS

-- Add the interval (in seconds) to the date and return the next cut date depending
-- on the dst options.
v_NEXT_DATE DATE;
BEGIN

	  v_NEXT_DATE := ADD_SECONDS_TO_DATE(p_CUT_DATE, p_SECONDS);

	  IF p_IS_ADJUSTED_DAY THEN
		-- A IS THE DEFAULT, EASY ONE.  NOTHING DIFFERENT NEEDED.
			IF GA.DST_SPRING_AHEAD_OPTION = 'B' THEN
				IF TO_CHAR(v_NEXT_DATE,'HH24') = '02' THEN
					v_NEXT_DATE := v_NEXT_DATE + 1/24;
				END IF;
			ELSIF GA.DST_SPRING_AHEAD_OPTION = 'C' THEN
				IF TO_CHAR(v_NEXT_DATE,'HH24') = '01' THEN
					v_NEXT_DATE := v_NEXT_DATE - 1/24;
				END IF;
			END IF;
		END IF;

	  RETURN v_NEXT_DATE;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN v_NEXT_DATE;

END GET_NEXT_CUT_DATE;
----------------------------------------------------------------------------------------------------
FUNCTION GET_SETTLEMENT_CALENDAR_ID
	(
	p_MODEL_OPTION IN CHAR,
	p_ENTITY_ID IN NUMBER,
	p_SERVICE_DATE IN DATE
	) RETURN NUMBER IS

-- Answer the account or meter settlement calendar id assignment for the specified day.
-- Answer CONSTANTS.NOT_ASSIGNED when there is not an assigned settlement calendar.

v_CALENDAR_ID NUMBER;

BEGIN

    IF p_MODEL_OPTION = 'A' THEN
	    SELECT CALENDAR_ID
		INTO v_CALENDAR_ID
		FROM ACCOUNT_CALENDAR
		WHERE ACCOUNT_ID = p_ENTITY_ID
		    AND UPPER(SUBSTR(CALENDAR_TYPE,1,1)) = 'S'
			AND p_SERVICE_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE);
    ELSIF p_MODEL_OPTION = 'M' THEN
	    SELECT CALENDAR_ID
		INTO v_CALENDAR_ID
		FROM METER_CALENDAR
		WHERE METER_ID = p_ENTITY_ID
		    AND UPPER(SUBSTR(CALENDAR_TYPE,1,1)) = 'S'
			AND p_SERVICE_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE);
	END IF;

	RETURN v_CALENDAR_ID;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN CONSTANTS.NOT_ASSIGNED;

END GET_SETTLEMENT_CALENDAR_ID;
----------------------------------------------------------------------------------------------------
FUNCTION GET_CALENDAR_PROFILE_ID
	(
	p_CALENDAR_ID IN NUMBER,
	p_SERVICE_DATE IN DATE
	) RETURN NUMBER IS

-- Answer the profile id in effect for the specified calendar and service date.
-- Select the first entry for multiple entries: the assumption is that the profile
-- is a historical settlement profile and that only one can be in effect.

v_PROFILE_ID NUMBER;

BEGIN

	SELECT PROFILE_ID
	INTO v_PROFILE_ID
	FROM CALENDAR_PROFILE
	WHERE CALENDAR_ID = p_CALENDAR_ID
		AND p_SERVICE_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE);

	RETURN v_PROFILE_ID;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN CONSTANTS.NOT_ASSIGNED;

END GET_CALENDAR_PROFILE_ID;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SETTLEMENT_PROFILE_ID
	(
	p_ACCOUNT_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_PROFILE_ID OUT NUMBER
	) AS

-- Answer the assigned settlement profile id fro the account or meter model.

v_CALENDAR_ID NUMBER;

BEGIN

	IF p_METER_ID = 0 THEN
	    v_CALENDAR_ID := GET_SETTLEMENT_CALENDAR_ID('A', p_ACCOUNT_ID, p_SERVICE_DATE);
	ELSE
	    v_CALENDAR_ID := GET_SETTLEMENT_CALENDAR_ID('M', p_METER_ID, p_SERVICE_DATE);
	END IF;

	IF v_CALENDAR_ID = CONSTANTS.NOT_ASSIGNED THEN
	    p_PROFILE_ID := CONSTANTS.NOT_ASSIGNED;
	ELSE
		p_PROFILE_ID := GET_CALENDAR_PROFILE_ID(v_CALENDAR_ID, p_SERVICE_DATE);
	END IF;

END GET_SETTLEMENT_PROFILE_ID;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_SETTLEMENT_PROFILE_ID
	(
	p_ACCOUNT_SERVICE_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_PROFILE_ID OUT NUMBER
	) AS

-- Answer the assigned settlement profile id for the account or meter model.

v_ACCOUNT_SERVICE ACCOUNT_SERVICE%ROWTYPE;

BEGIN

	v_ACCOUNT_SERVICE := CS.GET_ACCOUNT_SERVICE(p_ACCOUNT_SERVICE_ID);

	GET_SETTLEMENT_PROFILE_ID(v_ACCOUNT_SERVICE.ACCOUNT_ID, v_ACCOUNT_SERVICE.METER_ID, p_SERVICE_DATE, p_PROFILE_ID);

END GET_SETTLEMENT_PROFILE_ID;
----------------------------------------------------------------------------------------------------
FUNCTION IS_AGGREGATE_ACCOUNT
	(
	p_ACCOUNT_ID IN NUMBER
	) RETURN BOOLEAN IS

-- Answer the aggregate account option for the specified account name
-- Answer CONSTANTS.NOT_ASSIGNED when there is not an account.

v_IS_AGGREGATE_ACCOUNT NUMBER(1);

BEGIN
	SELECT IS_AGGREGATE_ACCOUNT
	INTO v_IS_AGGREGATE_ACCOUNT
	FROM ACCOUNT
	WHERE ACCOUNT_ID = p_ACCOUNT_ID;

	RETURN v_IS_AGGREGATE_ACCOUNT = 1;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN FALSE;

END IS_AGGREGATE_ACCOUNT;
----------------------------------------------------------------------------------------------------
FUNCTION GET_ACCOUNT_MODEL_OPTION
	(
	p_ACCOUNT_ID IN VARCHAR
	) RETURN CHAR IS

-- Answer the account model option for the specified account id
-- Answer CONSTANTS.NOT_ASSIGNED when there is not an account.

v_ACCOUNT_MODEL_OPTION CHAR(1);

BEGIN

	SELECT UPPER(SUBSTR(ACCOUNT_MODEL_OPTION,1,1))
	INTO v_ACCOUNT_MODEL_OPTION
	FROM ACCOUNT
	WHERE ACCOUNT_ID = p_ACCOUNT_ID;

	RETURN v_ACCOUNT_MODEL_OPTION;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN CONSTANTS.NOT_ASSIGNED;

END GET_ACCOUNT_MODEL_OPTION;
----------------------------------------------------------------------------------------------------
FUNCTION GET_AGGREGATE_ID
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_POOL_ID IN NUMBER := CONSTANTS.ALL_ID
	) RETURN NUMBER IS

-- Answer the aggregate account service id assignment for the specified day and esp.
-- Answer CONSTANTS.NOT_ASSIGNED when there is not an assigned service location.

v_AGGREGATE_ID NUMBER;

BEGIN

	SELECT AGGREGATE_ID
	INTO v_AGGREGATE_ID
	FROM AGGREGATE_ACCOUNT_ESP
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND ESP_ID = p_ESP_ID
		AND (p_POOL_ID = CONSTANTS.ALL_ID OR POOL_ID = p_POOL_ID)
		AND p_SERVICE_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE);

	RETURN v_AGGREGATE_ID;

EXCEPTION
	WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN CONSTANTS.NOT_ASSIGNED;

END GET_AGGREGATE_ID;
----------------------------------------------------------------------------------------------------
FUNCTION GET_AGGREGATE_ID
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_POOL_ID IN NUMBER := CONSTANTS.ALL_ID
	) RETURN NUMBER IS

-- Answer the aggregate account service id continuous assignment for the specified begin end date range and ESP.
-- Answer CONSTANTS.NOT_ASSIGNED when there is not a continuous assigned aggregate id over the time range

v_AGGREGATE_ID NUMBER;

BEGIN

	SELECT AGGREGATE_ID
	INTO v_AGGREGATE_ID
	FROM AGGREGATE_ACCOUNT_ESP
	WHERE ACCOUNT_ID = p_ACCOUNT_ID
		AND ESP_ID = p_ESP_ID
		AND (p_POOL_ID = CONSTANTS.ALL_ID OR POOL_ID = p_POOL_ID)
		AND p_BEGIN_DATE >= BEGIN_DATE
		AND p_END_DATE <= NVL(END_DATE, p_END_DATE);

	RETURN v_AGGREGATE_ID;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN CONSTANTS.NOT_ASSIGNED;

END GET_AGGREGATE_ID;
----------------------------------------------------------------------------------------------------
FUNCTION GET_AGGREGATE_ID
	(
	p_MODEL_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE
	) RETURN NUMBER IS

-- Answer the aggregate account service id  used from a prior forecast.

v_AGGREGATE_ID NUMBER := CONSTANTS.NOT_ASSIGNED;
v_AS_OF_DATE DATE;

BEGIN

	IF GA.VERSION_FORECAST THEN
		v_AS_OF_DATE := SYSDATE;
		SELECT A.AGGREGATE_ID
		INTO v_AGGREGATE_ID
		FROM ACCOUNT_SERVICE A, PROVIDER_SERVICE B, SERVICE C, SERVICE_DELIVERY D, SERVICE_STATE E
		WHERE A.ACCOUNT_ID = p_ACCOUNT_ID
			AND A.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
			AND A.METER_ID = CONSTANTS.NOT_ASSIGNED
			AND A.AGGREGATE_ID > 0
			AND B.EDC_ID = p_EDC_ID
			AND B.ESP_ID = p_ESP_ID
			AND B.PSE_ID = p_PSE_ID
			AND C.MODEL_ID = p_MODEL_ID
			AND C.SCENARIO_ID = GA.BASE_SCENARIO_ID
			AND C.AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM SERVICE
				WHERE MODEL_ID = C.MODEL_ID
					AND SCENARIO_ID = C.SCENARIO_ID
					AND AS_OF_DATE <= v_AS_OF_DATE
					AND PROVIDER_SERVICE_ID = C.PROVIDER_SERVICE_ID
					AND ACCOUNT_SERVICE_ID = C.ACCOUNT_SERVICE_ID
					AND SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID)
			AND C.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
			AND C.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
			AND D.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
			AND D.POOL_ID = p_POOL_ID
			AND E.SERVICE_ID = C.SERVICE_ID
			AND E.SERVICE_CODE = GA.FORECAST_SERVICE
			AND E.SERVICE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
			AND ROWNUM = 1;
	ELSE
		v_AS_OF_DATE := LOW_DATE;
		SELECT A.AGGREGATE_ID
		INTO v_AGGREGATE_ID
		FROM ACCOUNT_SERVICE A, PROVIDER_SERVICE B, SERVICE C, SERVICE_DELIVERY D, SERVICE_STATE E
		WHERE A.ACCOUNT_ID = p_ACCOUNT_ID
			AND A.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
			AND A.METER_ID = CONSTANTS.NOT_ASSIGNED
			AND A.AGGREGATE_ID > 0
			AND B.EDC_ID = p_EDC_ID
			AND B.ESP_ID = p_ESP_ID
			AND B.PSE_ID = p_PSE_ID
			AND C.MODEL_ID = p_MODEL_ID
			AND C.SCENARIO_ID = GA.BASE_SCENARIO_ID
			AND C.AS_OF_DATE = v_AS_OF_DATE
			AND C.ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
			AND C.PROVIDER_SERVICE_ID = B.PROVIDER_SERVICE_ID
			AND D.SERVICE_DELIVERY_ID = C.SERVICE_DELIVERY_ID
			AND D.POOL_ID = p_POOL_ID
			AND E.SERVICE_ID = C.SERVICE_ID
			AND E.SERVICE_CODE = GA.FORECAST_SERVICE
			AND E.SERVICE_DATE BETWEEN p_BEGIN_DATE AND p_END_DATE
			AND ROWNUM = 1;
	END IF;

	RETURN v_AGGREGATE_ID;

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN CONSTANTS.NOT_ASSIGNED;

END GET_AGGREGATE_ID;
----------------------------------------------------------------------------------------------------
FUNCTION GET_METER_OWNER
	(
	p_METER_ID IN NUMBER,
	p_SERVICE_DATE DATE
	) RETURN NUMBER IS

-- Answer the Service Location owner of the Meter.

v_SERVICE_LOCATION_ID NUMBER;

BEGIN

    SELECT SERVICE_LOCATION_ID
	INTO v_SERVICE_LOCATION_ID
	FROM SERVICE_LOCATION_METER
	WHERE METER_ID = p_METER_ID
	    AND p_SERVICE_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE);

	RETURN v_SERVICE_LOCATION_ID;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN CONSTANTS.NOT_ASSIGNED;

END GET_METER_OWNER;
----------------------------------------------------------------------------------------------------
FUNCTION GET_SERVICE_LOCATION_OWNER
	(
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_SERVICE_DATE DATE
	) RETURN NUMBER IS

-- Answer the Account owner of the Service Location.

v_ACCOUNT_ID NUMBER;

BEGIN

    SELECT ACCOUNT_ID
	INTO v_ACCOUNT_ID
	FROM ACCOUNT_SERVICE_LOCATION
	WHERE SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
	    AND p_SERVICE_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE);

	RETURN v_ACCOUNT_ID;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN CONSTANTS.NOT_ASSIGNED;

END GET_SERVICE_LOCATION_OWNER;
----------------------------------------------------------------------------------------------------
FUNCTION GET_METER_ID
	(
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_SERVICE_DATE DATE
	) RETURN NUMBER IS

-- Answer the Service Location owner of the Meter.

v_METER_ID NUMBER;

BEGIN

    SELECT METER_ID
	INTO v_METER_ID
	FROM SERVICE_LOCATION_METER
	WHERE SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
	    AND p_SERVICE_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE, p_SERVICE_DATE);

	RETURN v_METER_ID;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN CONSTANTS.NOT_ASSIGNED;

END GET_METER_ID;
----------------------------------------------------------------------------------------------------
FUNCTION GET_METER_ID
	(
	p_METER_NAME IN VARCHAR,
	p_IDENT_TYPE IN CHAR DEFAULT 'N'
	) RETURN NUMBER IS

-- Answer the id of the Meter.

v_METER_ID NUMBER;

BEGIN

	IF p_IDENT_TYPE ='N' THEN
		SELECT METER_ID INTO v_METER_ID FROM METER
		WHERE METER_NAME = p_METER_NAME;
	ELSIF p_IDENT_TYPE = 'X' THEN
		SELECT METER_ID INTO v_METER_ID FROM METER
		WHERE METER_EXTERNAL_IDENTIFIER = p_METER_NAME;
	END IF;

	RETURN v_METER_ID;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN CONSTANTS.NOT_ASSIGNED;

END GET_METER_ID;
----------------------------------------------------------------------------------------------------
FUNCTION SCENARIO_FOR_SETTLEMENT_TYPE
	(
	p_SETTLEMENT_TYPE_NAME IN VARCHAR2
	) RETURN NUMBER IS

-- Answer the Scenario ID associated with the Settlement Type name.
-- If none is found, return GA.BASE_SCENARIO_ID.

v_SCENARIO_ID NUMBER;

BEGIN

	SELECT NVL(SCENARIO_ID, GA.BASE_SCENARIO_ID)
	INTO v_SCENARIO_ID
	FROM SETTLEMENT_TYPE
	WHERE UPPER(SETTLEMENT_TYPE_NAME) = UPPER(p_SETTLEMENT_TYPE_NAME);

	RETURN v_SCENARIO_ID;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN GA.BASE_SCENARIO_ID;

END SCENARIO_FOR_SETTLEMENT_TYPE;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_SERVICE_LOAD
	(
	p_SERVICE_LOAD IN SERVICE_LOAD%ROWTYPE,
	p_OP_CODE IN CHAR DEFAULT 'U'
	) AS

-- OP CODES:
-- A - Append, D - Delete, O - Override, U - Update standard processing (do not replace a non-zero reading with a zero or null reading).

BEGIN

	IF p_OP_CODE = 'D' THEN
		DELETE SERVICE_LOAD
		WHERE SERVICE_ID = p_SERVICE_LOAD.SERVICE_ID
			AND SERVICE_CODE = p_SERVICE_LOAD.SERVICE_CODE
			AND LOAD_CODE = p_SERVICE_LOAD.LOAD_CODE
			AND LOAD_DATE  = p_SERVICE_LOAD.LOAD_DATE;
	ELSE
		UPDATE SERVICE_LOAD
		SET	LOAD_VAL = DECODE(p_OP_CODE, 'A', LOAD_VAL + NVL(p_SERVICE_LOAD.LOAD_VAL, 0), 'O', p_SERVICE_LOAD.LOAD_VAL, DECODE(p_SERVICE_LOAD.LOAD_VAL, 0, LOAD_VAL, NULL, LOAD_VAL, p_SERVICE_LOAD.LOAD_VAL)),
			TX_LOSS_VAL = DECODE(p_OP_CODE, 'A', TX_LOSS_VAL + NVL(p_SERVICE_LOAD.TX_LOSS_VAL, 0), 'O', p_SERVICE_LOAD.TX_LOSS_VAL, DECODE(p_SERVICE_LOAD.TX_LOSS_VAL, 0, TX_LOSS_VAL, NULL, TX_LOSS_VAL, p_SERVICE_LOAD.TX_LOSS_VAL)),
			DX_LOSS_VAL = DECODE(p_OP_CODE, 'A', DX_LOSS_VAL + NVL(p_SERVICE_LOAD.DX_LOSS_VAL, 0), 'O', p_SERVICE_LOAD.DX_LOSS_VAL, DECODE(p_SERVICE_LOAD.DX_LOSS_VAL, 0, DX_LOSS_VAL, NULL, DX_LOSS_VAL, p_SERVICE_LOAD.DX_LOSS_VAL)),
			UE_LOSS_VAL = DECODE(p_OP_CODE, 'A', UE_LOSS_VAL + NVL(p_SERVICE_LOAD.UE_LOSS_VAL, 0), 'O', p_SERVICE_LOAD.UE_LOSS_VAL, DECODE(p_SERVICE_LOAD.UE_LOSS_VAL, 0, UE_LOSS_VAL, NULL, UE_LOSS_VAL, p_SERVICE_LOAD.UE_LOSS_VAL))
		WHERE SERVICE_ID = p_SERVICE_LOAD.SERVICE_ID
			AND SERVICE_CODE = p_SERVICE_LOAD.SERVICE_CODE
			AND LOAD_CODE = p_SERVICE_LOAD.LOAD_CODE
			AND LOAD_DATE  = p_SERVICE_LOAD.LOAD_DATE;

		IF SQL%NOTFOUND THEN
			INSERT INTO SERVICE_LOAD (
				SERVICE_ID,
				SERVICE_CODE,
				LOAD_CODE,
				LOAD_DATE,
				LOAD_VAL,
				TX_LOSS_VAL,
				DX_LOSS_VAL,
				UE_LOSS_VAL)
			VALUES (
				p_SERVICE_LOAD.SERVICE_ID,
				p_SERVICE_LOAD.SERVICE_CODE,
				p_SERVICE_LOAD.LOAD_CODE,
				p_SERVICE_LOAD.LOAD_DATE,
				NVL(p_SERVICE_LOAD.LOAD_VAL,0),
				NVL(p_SERVICE_LOAD.TX_LOSS_VAL,0),
				NVL(p_SERVICE_LOAD.DX_LOSS_VAL,0),
				NVL(p_SERVICE_LOAD.UE_LOSS_VAL,0));
		END IF;
	END IF;

END PUT_SERVICE_LOAD;
----------------------------------------------------------------------------------------------------
FUNCTION GET_SERVICE_ID
	(
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_ACCOUNT_SERVICE_ID IN NUMBER,
	p_PROVIDER_SERVICE_ID IN NUMBER,
	p_SERVICE_DELIVERY_ID IN NUMBER,
	p_AS_OF_DATE IN DATE
	) RETURN NUMBER IS

v_SERVICE_ID NUMBER(9);
v_AS_OF_DATE DATE;

BEGIN

	IF GA.VERSION_CONSUMPTION THEN
		v_AS_OF_DATE := p_AS_OF_DATE;
		SELECT SERVICE_ID
		INTO v_SERVICE_ID
		FROM SERVICE A
		WHERE MODEL_ID = p_MODEL_ID
			AND SCENARIO_ID = p_SCENARIO_ID
			AND PROVIDER_SERVICE_ID = p_PROVIDER_SERVICE_ID
			AND ACCOUNT_SERVICE_ID = p_ACCOUNT_SERVICE_ID
			AND SERVICE_DELIVERY_ID = p_SERVICE_DELIVERY_ID
			AND AS_OF_DATE =
				(SELECT MAX(AS_OF_DATE)
				FROM SERVICE
				WHERE MODEL_ID = A.MODEL_ID
					AND SCENARIO_ID = A.SCENARIO_ID
					AND PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID
					AND ACCOUNT_SERVICE_ID = A.ACCOUNT_SERVICE_ID
					AND SERVICE_DELIVERY_ID = A.SERVICE_DELIVERY_ID
					AND AS_OF_DATE <= v_AS_OF_DATE);
	ELSE
		v_AS_OF_DATE := LOW_DATE;
		SELECT SERVICE_ID
		INTO v_SERVICE_ID
		FROM SERVICE A
		WHERE MODEL_ID = p_MODEL_ID
			AND SCENARIO_ID = p_SCENARIO_ID
			AND PROVIDER_SERVICE_ID = p_PROVIDER_SERVICE_ID
			AND ACCOUNT_SERVICE_ID = p_ACCOUNT_SERVICE_ID
			AND SERVICE_DELIVERY_ID = p_SERVICE_DELIVERY_ID
			AND AS_OF_DATE = v_AS_OF_DATE;
	END IF;
	RETURN v_SERVICE_ID;


	EXCEPTION
		WHEN NO_DATA_FOUND THEN
			ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
			SELECT SID.NEXTVAL INTO v_SERVICE_ID FROM DUAL;
			INSERT INTO SERVICE (
				SERVICE_ID,
				MODEL_ID,
				SCENARIO_ID,
				AS_OF_DATE,
				PROVIDER_SERVICE_ID,
				ACCOUNT_SERVICE_ID,
				SERVICE_DELIVERY_ID,
				ENTRY_DATE)
			VALUES (
				v_SERVICE_ID,
				p_MODEL_ID,
				p_SCENARIO_ID,
				v_AS_OF_DATE,
				p_PROVIDER_SERVICE_ID,
				p_ACCOUNT_SERVICE_ID,
				p_SERVICE_DELIVERY_ID,
				SYSDATE);
			RETURN v_SERVICE_ID;

END GET_SERVICE_ID;
----------------------------------------------------------------------------------------------------
FUNCTION IS_PROCESSING_USAGE_FACTORS(p_SERVICE_CONSUMPTION IN SERVICE_CONSUMPTION%ROWTYPE) RETURN BOOLEAN AS
v_IS_PROCESSING_UF BOOLEAN := TRUE;
v_MODEL_ID SERVICE.MODEL_ID%TYPE;
v_ACCOUNT_NAME ACCOUNT.ACCOUNT_NAME%TYPE;
v_MODEL_OPTION ACCOUNT.ACCOUNT_MODEL_OPTION%TYPE;
v_ACCOUNT_USE_TOU NUMBER(1);
v_METER_USE_TOU  NUMBER(1);
v_MESSAGE VARCHAR2(4000);
BEGIN
-- Get the MODEL_ID for looking up the System Dictionary flag
	SELECT S.MODEL_ID INTO v_MODEL_ID FROM SERVICE S WHERE S.SERVICE_ID = p_SERVICE_CONSUMPTION.SERVICE_ID;

-- Check the "Calculate Usage Factors on Consumption Import" on processing flag in System Dictionary, Default to 1
	v_IS_PROCESSING_UF := CASE WHEN v_MODEL_ID = CONSTANTS.GAS_MODEL THEN c_IS_PROCESSING_UF_GAS ELSE c_IS_PROCESSING_UF_ELECTRIC END;

	IF v_IS_PROCESSING_UF THEN
-- Get Account/Meter Info
		SELECT A.ACCOUNT_NAME, A.ACCOUNT_MODEL_OPTION, A.USE_TOU_USAGE_FACTOR,
			   (SELECT M.USE_TOU_USAGE_FACTOR
			    FROM METER M
			    WHERE M.METER_ID = X.METER_ID) AS METER_USE_TOU_USAGE_FACTOR
		INTO v_ACCOUNT_NAME, v_MODEL_OPTION, v_ACCOUNT_USE_TOU, v_METER_USE_TOU
		FROM SERVICE S, ACCOUNT_SERVICE X, ACCOUNT A
		WHERE A.ACCOUNT_ID = X.ACCOUNT_ID
		  AND X.ACCOUNT_SERVICE_ID = S.ACCOUNT_SERVICE_ID
		  AND S.SERVICE_ID = p_SERVICE_CONSUMPTION.SERVICE_ID;

		v_MESSAGE := 'Skip processing of Usage Factors for Account ' || v_ACCOUNT_NAME || '.';

		--Check UOM, only allow Default UOM, ignore case
		IF v_IS_PROCESSING_UF AND v_MODEL_OPTION = ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_AGGREGATE THEN
			v_IS_PROCESSING_UF := FALSE;
			v_MESSAGE := v_MESSAGE || ' The Account''s Model Option is set to ''Aggregate''. Aggregate Accounts are not supported.';
		END IF;

		--Check UOM, only allow Default UOM, ignore case
		IF v_IS_PROCESSING_UF AND UPPER(NVL(p_SERVICE_CONSUMPTION.UNIT_OF_MEASUREMENT, GA.DEFAULT_UNIT_OF_MEASUREMENT)) <> UPPER(GA.DEFAULT_UNIT_OF_MEASUREMENT) THEN
			v_IS_PROCESSING_UF := FALSE;
			v_MESSAGE := v_MESSAGE || ' The Unit of Measurement, ' || p_SERVICE_CONSUMPTION.UNIT_OF_MEASUREMENT
				|| ', did not match the default, ' || GA.DEFAULT_UNIT_OF_MEASUREMENT;
		END IF;

		--Check Template, only allow Not Assigned, Anytime, & Anytime TOU
		IF v_IS_PROCESSING_UF AND NVL(p_SERVICE_CONSUMPTION.TEMPLATE_ID,CONSTANTS.NOT_ASSIGNED) NOT IN (CONSTANTS.NOT_ASSIGNED, CONSTANTS.ANYTIME_TOU_TEMPLATE_ID, CONSTANTS.ANYTIME_SD_TEMPLATE_ID) THEN
			v_IS_PROCESSING_UF := FALSE;
			v_MESSAGE := v_MESSAGE || ' TOU Usage Factors are not supported. The Template provided was '
				|| TEXT_UTIL.TO_CHAR_ENTITY(p_SERVICE_CONSUMPTION.TEMPLATE_ID, EC.ED_TEMPLATE) || '.';
		END IF;

		--Check the ACCOUNT.USE_TOU_USAGE_FACTOR flag, only allow non TOU Accounts
		IF v_IS_PROCESSING_UF AND v_MODEL_OPTION = ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_ACCOUNT AND v_ACCOUNT_USE_TOU = 1 THEN
			v_IS_PROCESSING_UF := FALSE;
			v_MESSAGE := v_MESSAGE || ' The Account''s Use TOU Usage Factor flag was set to true.';
		END IF;

		--Check the METER.USE_TOU_USAGE_FACTOR flag, only allow non TOU Meters
		IF v_IS_PROCESSING_UF AND v_MODEL_OPTION = ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_METER AND v_METER_USE_TOU = 1 THEN
			v_IS_PROCESSING_UF := FALSE;
			v_MESSAGE := v_MESSAGE || ' The Meter''s Use TOU Usage Factor flag was set to true.';
		END IF;

		IF NOT v_IS_PROCESSING_UF THEN
		    -- CAUTION: Do not revert this to WARNING or other message-type. TDIE process may be affected.
			LOGS.LOG_INFO_MORE_DETAIL(v_MESSAGE);
		END IF;
	END IF;

	RETURN v_IS_PROCESSING_UF;

END IS_PROCESSING_USAGE_FACTORS;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_SERVICE_CONSUMPTION
	(
	p_SERVICE_CONSUMPTION IN SERVICE_CONSUMPTION%ROWTYPE,
	p_CONSUMPTION_ID OUT NUMBER
	) AS
BEGIN

    -- DELETE SERVICE_CONSUMPTION RECORDS WHICH HAVE THE SAME BEGIN AND END DATE,
    -- ACCOUNT_SERVICE_IDs AND SCENARIO_IDs, BUT DIFFERENT SERVICE_IDs
    -- (THE ACCOUNT / SERVICE LOCATION / METER WAS REASSIGNED TO A DIFFERENT EDC, ESP, POOL, PSE, ETC)
    DELETE FROM SERVICE_CONSUMPTION SC
    WHERE SC.SERVICE_ID <> p_SERVICE_CONSUMPTION.SERVICE_ID
        AND SC.SERVICE_ID IN (SELECT S2.SERVICE_ID
                                FROM SERVICE S,
                                    SERVICE S2
                                WHERE S.SERVICE_ID = p_SERVICE_CONSUMPTION.SERVICE_ID
                                    AND S2.ACCOUNT_SERVICE_ID = S.ACCOUNT_SERVICE_ID
                                    AND S2.SCENARIO_ID = S.SCENARIO_ID)
       AND SC.BEGIN_DATE = p_SERVICE_CONSUMPTION.BEGIN_DATE
       AND SC.END_DATE = p_SERVICE_CONSUMPTION.END_DATE
	   AND SC.CONSUMPTION_CODE = p_SERVICE_CONSUMPTION.CONSUMPTION_CODE;


	UPDATE SERVICE_CONSUMPTION SET
		METER_TYPE = p_SERVICE_CONSUMPTION.METER_TYPE,
		METER_READING = p_SERVICE_CONSUMPTION.METER_READING,
		BILLED_USAGE = p_SERVICE_CONSUMPTION.BILLED_USAGE,
		BILLED_DEMAND = p_SERVICE_CONSUMPTION.BILLED_DEMAND,
		METERED_USAGE = p_SERVICE_CONSUMPTION.METERED_USAGE,
		METERED_DEMAND = p_SERVICE_CONSUMPTION.METERED_DEMAND,
		METERS_READ = p_SERVICE_CONSUMPTION.METERS_READ,
		CONVERSION_FACTOR = p_SERVICE_CONSUMPTION.CONVERSION_FACTOR,
		IGNORE_CONSUMPTION = p_SERVICE_CONSUMPTION.IGNORE_CONSUMPTION,
        BILL_CYCLE_MONTH = p_SERVICE_CONSUMPTION.BILL_CYCLE_MONTH,
		BILL_PROCESSED_DATE = p_SERVICE_CONSUMPTION.BILL_PROCESSED_DATE,
		ENTRY_DATE = p_SERVICE_CONSUMPTION.ENTRY_DATE
	WHERE SERVICE_ID = p_SERVICE_CONSUMPTION.SERVICE_ID
		AND BEGIN_DATE = p_SERVICE_CONSUMPTION.BEGIN_DATE
		AND END_DATE = p_SERVICE_CONSUMPTION.END_DATE
		AND BILL_CODE = p_SERVICE_CONSUMPTION.BILL_CODE
		AND CONSUMPTION_CODE = p_SERVICE_CONSUMPTION.CONSUMPTION_CODE
		AND RECEIVED_DATE = p_SERVICE_CONSUMPTION.RECEIVED_DATE
		AND TEMPLATE_ID = p_SERVICE_CONSUMPTION.TEMPLATE_ID
		AND PERIOD_ID = p_SERVICE_CONSUMPTION.PERIOD_ID
		AND UNIT_OF_MEASUREMENT = NVL(p_SERVICE_CONSUMPTION.UNIT_OF_MEASUREMENT, GA.DEFAULT_UNIT_OF_MEASUREMENT);

	IF SQL%NOTFOUND THEN
		SELECT CID.NEXTVAL INTO p_CONSUMPTION_ID FROM DUAL;
		INSERT INTO SERVICE_CONSUMPTION (
			SERVICE_ID,
			BEGIN_DATE,
			END_DATE,
			BILL_CODE,
			CONSUMPTION_CODE,
			RECEIVED_DATE,
			TEMPLATE_ID,
			PERIOD_ID,
			UNIT_OF_MEASUREMENT,
			METER_TYPE,
			METER_READING,
			BILLED_USAGE,
			BILLED_DEMAND,
			METERED_USAGE,
			METERED_DEMAND,
			METERS_READ,
			CONVERSION_FACTOR,
			IGNORE_CONSUMPTION,
            BILL_CYCLE_MONTH,
			BILL_PROCESSED_DATE,
			CONSUMPTION_ID,
			READ_BEGIN_DATE,
			READ_END_DATE,
			ENTRY_DATE)
		VALUES (
			p_SERVICE_CONSUMPTION.SERVICE_ID,
			p_SERVICE_CONSUMPTION.BEGIN_DATE,
			p_SERVICE_CONSUMPTION.END_DATE,
			p_SERVICE_CONSUMPTION.BILL_CODE,
			p_SERVICE_CONSUMPTION.CONSUMPTION_CODE,
			p_SERVICE_CONSUMPTION.RECEIVED_DATE,
			p_SERVICE_CONSUMPTION.TEMPLATE_ID,
			p_SERVICE_CONSUMPTION.PERIOD_ID,
			NVL(p_SERVICE_CONSUMPTION.UNIT_OF_MEASUREMENT, GA.DEFAULT_UNIT_OF_MEASUREMENT),
			p_SERVICE_CONSUMPTION.METER_TYPE,
			p_SERVICE_CONSUMPTION.METER_READING,
			p_SERVICE_CONSUMPTION.BILLED_USAGE,
			p_SERVICE_CONSUMPTION.BILLED_DEMAND,
			p_SERVICE_CONSUMPTION.METERED_USAGE,
			p_SERVICE_CONSUMPTION.METERED_DEMAND,
			p_SERVICE_CONSUMPTION.METERS_READ,
			p_SERVICE_CONSUMPTION.CONVERSION_FACTOR,
			p_SERVICE_CONSUMPTION.IGNORE_CONSUMPTION,
            p_SERVICE_CONSUMPTION.BILL_CYCLE_MONTH,
			p_SERVICE_CONSUMPTION.BILL_PROCESSED_DATE,
			p_CONSUMPTION_ID,
			p_SERVICE_CONSUMPTION.READ_BEGIN_DATE,
			p_SERVICE_CONSUMPTION.READ_END_DATE,
			p_SERVICE_CONSUMPTION.ENTRY_DATE);
	END IF;

	IF IS_PROCESSING_USAGE_FACTORS(p_SERVICE_CONSUMPTION) THEN
		PROCESS_USAGE_FACTORS(p_SERVICE_CONSUMPTION);
	END IF;

END PUT_SERVICE_CONSUMPTION;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_SERVICE_CONSUMPTION
	(
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_ACCOUNT_SERVICE_ID IN NUMBER,
	p_PROVIDER_SERVICE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_METER_TYPE IN CHAR,
	p_BILLED_USAGE IN NUMBER,
	p_BILLED_DEMAND IN NUMBER,
	p_METERED_USAGE IN NUMBER,
	p_METERED_DEMAND IN NUMBER,
	p_METERS_READ IN NUMBER,
	p_BILL_CODE IN CHAR,
	p_CONSUMPTION_CODE IN CHAR,
	p_IGNORE_CONSUMPTION IN NUMBER,
	p_RECEIVED_DATE IN DATE,
	p_TEMPLATE_ID IN NUMBER,
	p_PERIOD_ID IN NUMBER,
	p_METER_READING IN VARCHAR,
	p_CONSUMPTION_ID OUT NUMBER
	) AS

v_SERVICE_DELIVERY_ID NUMBER(9);
v_SERVICE_CONSUMPTION SERVICE_CONSUMPTION%ROWTYPE;

BEGIN

	CS.GET_SERVICE_DELIVERY_ID(p_ACCOUNT_SERVICE_ID, p_PROVIDER_SERVICE_ID, p_END_DATE, v_SERVICE_DELIVERY_ID);
	v_SERVICE_CONSUMPTION.SERVICE_ID := GET_SERVICE_ID(p_MODEL_ID, p_SCENARIO_ID, p_ACCOUNT_SERVICE_ID, p_PROVIDER_SERVICE_ID, v_SERVICE_DELIVERY_ID, p_RECEIVED_DATE);

	v_SERVICE_CONSUMPTION.BEGIN_DATE := p_BEGIN_DATE;
	v_SERVICE_CONSUMPTION.END_DATE := p_END_DATE;
	v_SERVICE_CONSUMPTION.BILL_CODE := p_BILL_CODE;
	v_SERVICE_CONSUMPTION.CONSUMPTION_CODE := p_CONSUMPTION_CODE;
	v_SERVICE_CONSUMPTION.RECEIVED_DATE := p_RECEIVED_DATE;
	v_SERVICE_CONSUMPTION.TEMPLATE_ID := p_TEMPLATE_ID;
	v_SERVICE_CONSUMPTION.PERIOD_ID := p_PERIOD_ID;
	v_SERVICE_CONSUMPTION.METER_TYPE := p_METER_TYPE;
	v_SERVICE_CONSUMPTION.METER_READING := p_METER_READING;
	v_SERVICE_CONSUMPTION.BILLED_USAGE := p_BILLED_USAGE;
	v_SERVICE_CONSUMPTION.BILLED_DEMAND := p_BILLED_DEMAND;
	v_SERVICE_CONSUMPTION.METERED_USAGE := p_METERED_USAGE;
	v_SERVICE_CONSUMPTION.METERED_DEMAND := p_METERED_DEMAND;
	v_SERVICE_CONSUMPTION.METERS_READ := p_METERS_READ;
	v_SERVICE_CONSUMPTION.CONVERSION_FACTOR := CONSTANTS.NOT_ASSIGNED;
	v_SERVICE_CONSUMPTION.IGNORE_CONSUMPTION := p_IGNORE_CONSUMPTION;
	v_SERVICE_CONSUMPTION.READ_BEGIN_DATE := NULL;
	v_SERVICE_CONSUMPTION.READ_END_DATE := NULL;
	v_SERVICE_CONSUMPTION.BILL_PROCESSED_DATE := NULL;
	v_SERVICE_CONSUMPTION.ENTRY_DATE := SYSDATE;

	PUT_SERVICE_CONSUMPTION(v_SERVICE_CONSUMPTION, p_CONSUMPTION_ID);

END PUT_SERVICE_CONSUMPTION;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_SERVICE_CONSUMPTION
	(
	p_SCENARIO_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
    p_SERVICE_LOCATION_ID IN NUMBER,
    p_METER_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_BILL_CODE IN CHAR,
	p_CONSUMPTION_CODE IN CHAR,
	p_RECEIVED_DATE IN DATE,
	p_TEMPLATE_ID IN NUMBER,
	p_PERIOD_ID IN NUMBER,
    p_UNIT_OF_MEASUREMENT VARCHAR2,
	p_METER_TYPE IN CHAR,
    p_METER_READING IN VARCHAR2,
	p_BILLED_USAGE IN NUMBER,
	p_BILLED_DEMAND IN NUMBER,
	p_METERED_USAGE IN NUMBER,
	p_METERED_DEMAND IN NUMBER,
	p_METERS_READ IN NUMBER,
    p_CONVERSION_FACTOR IN NUMBER,
	p_IGNORE_CONSUMPTION IN NUMBER,
    p_BILL_CYCLE_MONTH IN DATE,
    p_BILL_PROCESSED_DATE IN DATE,
    p_READ_BEGIN_DATE IN DATE,
    p_READ_END_DATE IN DATE,
	p_CONSUMPTION_ID OUT NUMBER,
    p_PERFORM_VALIDATION IN BOOLEAN := TRUE,
    p_AGGREGATE_ID IN NUMBER := CONSTANTS.NOT_ASSIGNED
	) AS

    v_ACCOUNT_SERVICE_ID ACCOUNT_SERVICE.ACCOUNT_SERVICE_ID%TYPE;
    v_PROVIDER_SERVICE_ID PROVIDER_SERVICE.PROVIDER_SERVICE_ID%TYPE;
    v_SERVICE_DELIVERY_ID SERVICE_DELIVERY.SERVICE_DELIVERY_ID%TYPE;
    v_SERVICE_ID SERVICE.SERVICE_ID%TYPE;

    v_TEST PLS_INTEGER;

    v_SERVICE_CONSUMPTION SERVICE_CONSUMPTION%ROWTYPE;

v_ACCOUNT_MODEL_ID NUMBER(1);

BEGIN
	BEGIN
        SELECT MODEL_ID
        INTO v_ACCOUNT_MODEL_ID
        FROM ACCOUNT
        WHERE ACCOUNT_ID = p_ACCOUNT_ID;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'ACCOUNT_ID = ' || p_ACCOUNT_ID);
    END;

    IF p_PERFORM_VALIDATION THEN
        ASSERT(v_ACCOUNT_MODEL_ID IS NOT NULL, 'Invalid Account MODEL_ID. MODEL_ID must be non-null.');
        ASSERT(v_ACCOUNT_MODEL_ID IN (CONSTANTS.ELECTRIC_MODEL, CONSTANTS.GAS_MODEL), 'Invalid Account MODEL_ID. MODEL_ID must be set to Gas or Electric.');

        SELECT COUNT(1)
        INTO v_TEST
        FROM ACCOUNT_SERVICE_LOCATION ASL
        WHERE ASL.ACCOUNT_ID = p_ACCOUNT_ID
            AND ASL.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
            AND p_END_DATE BETWEEN ASL.BEGIN_DATE AND NVL(ASL.END_DATE, CONSTANTS.HIGH_DATE);

        IF v_TEST <= 0 THEN
            ERRS.RAISE_BAD_ARGUMENT('ACCOUNT/SERVICE_LOCATION: BEGIN_DATE', TEXT_UTIL.TO_CHAR_ENTITY(p_ACCOUNT_ID, EC.ED_ACCOUNT) || ' / '
                || TEXT_UTIL.TO_CHAR_ENTITY(p_SERVICE_LOCATION_ID, EC.ED_SERVICE_LOCATION) || ': ' || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE),
                'The supplied service location is not assigned to the Account on the given date.');
        END IF;

        IF p_METER_ID <> CONSTANTS.NOT_ASSIGNED THEN

            SELECT COUNT(1)
            INTO v_TEST
            FROM SERVICE_LOCATION_METER SLM
            WHERE SLM.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
                AND p_END_DATE BETWEEN SLM.BEGIN_DATE AND NVL(SLM.END_DATE, CONSTANTS.HIGH_DATE)
                AND SLM.METER_ID = p_METER_ID;

            IF v_TEST <= 0 THEN
                ERRS.RAISE_BAD_ARGUMENT('SERVICE_LOCATION/METER: BEGIN_DATE', TEXT_UTIL.TO_CHAR_ENTITY(p_SERVICE_LOCATION_ID, EC.ED_SERVICE_LOCATION) || ' / '
                    || TEXT_UTIL.TO_CHAR_ENTITY(p_METER_ID, EC.ED_METER) || ': ' || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE),
                    'The supplied meter is not assigned to the service location on the given date.');
            END IF;

        END IF;
    END IF;

    CS.GET_ACCOUNT_SERVICE_ID(p_ACCOUNT_ID,p_SERVICE_LOCATION_ID,p_METER_ID,p_AGGREGATE_ID,v_ACCOUNT_SERVICE_ID);
    v_PROVIDER_SERVICE_ID := CS.GET_PROVIDER_SERVICE_ID(v_ACCOUNT_SERVICE_ID,p_END_DATE);
    CS.GET_SERVICE_DELIVERY_ID(v_ACCOUNT_SERVICE_ID, v_PROVIDER_SERVICE_ID, p_END_DATE, v_SERVICE_DELIVERY_ID);
    v_SERVICE_ID := CS.GET_SERVICE_ID(v_ACCOUNT_MODEL_ID,p_SCENARIO_ID,CONSTANTS.LOW_DATE,v_PROVIDER_SERVICE_ID,v_ACCOUNT_SERVICE_ID,v_SERVICE_DELIVERY_ID);

    v_SERVICE_CONSUMPTION.SERVICE_ID := v_SERVICE_ID;
    v_SERVICE_CONSUMPTION.BEGIN_DATE := p_BEGIN_DATE;
	v_SERVICE_CONSUMPTION.END_DATE := p_END_DATE;
	v_SERVICE_CONSUMPTION.BILL_CODE := p_BILL_CODE;
	v_SERVICE_CONSUMPTION.CONSUMPTION_CODE := p_CONSUMPTION_CODE;
	v_SERVICE_CONSUMPTION.RECEIVED_DATE := p_RECEIVED_DATE;
	v_SERVICE_CONSUMPTION.TEMPLATE_ID := p_TEMPLATE_ID;
	v_SERVICE_CONSUMPTION.PERIOD_ID := p_PERIOD_ID;
    v_SERVICE_CONSUMPTION.UNIT_OF_MEASUREMENT := p_UNIT_OF_MEASUREMENT;
	v_SERVICE_CONSUMPTION.METER_TYPE := p_METER_TYPE;
	v_SERVICE_CONSUMPTION.METER_READING := p_METER_READING;
	v_SERVICE_CONSUMPTION.BILLED_USAGE := p_BILLED_USAGE;
	v_SERVICE_CONSUMPTION.BILLED_DEMAND := p_BILLED_DEMAND;
	v_SERVICE_CONSUMPTION.METERED_USAGE := p_METERED_USAGE;
	v_SERVICE_CONSUMPTION.METERED_DEMAND := p_METERED_DEMAND;
	v_SERVICE_CONSUMPTION.METERS_READ := p_METERS_READ;
	v_SERVICE_CONSUMPTION.CONVERSION_FACTOR := CONSTANTS.NOT_ASSIGNED;
	v_SERVICE_CONSUMPTION.IGNORE_CONSUMPTION := p_IGNORE_CONSUMPTION;
    v_SERVICE_CONSUMPTION.BILL_CYCLE_MONTH := p_BILL_CYCLE_MONTH;
	v_SERVICE_CONSUMPTION.BILL_PROCESSED_DATE := p_BILL_PROCESSED_DATE;
	v_SERVICE_CONSUMPTION.READ_BEGIN_DATE := p_READ_BEGIN_DATE;
	v_SERVICE_CONSUMPTION.READ_END_DATE := p_READ_END_DATE;
	v_SERVICE_CONSUMPTION.ENTRY_DATE := SYSDATE;

    PUT_SERVICE_CONSUMPTION(v_SERVICE_CONSUMPTION, p_CONSUMPTION_ID);

END PUT_SERVICE_CONSUMPTION;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_SERVICE_CONSUMPTION
	(
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_ACCOUNT_SERVICE_ID IN NUMBER,
	p_PROVIDER_SERVICE_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_METER_TYPE IN CHAR,
	p_BILLED_USAGE IN NUMBER,
	p_BILLED_DEMAND IN NUMBER,
	p_METERED_USAGE IN NUMBER,
	p_METERED_DEMAND IN NUMBER,
	p_METERS_READ IN NUMBER,
	p_BILL_CODE IN CHAR,
	p_CONSUMPTION_CODE IN CHAR,
	p_IGNORE_CONSUMPTION IN NUMBER,
	p_RECEIVED_DATE IN DATE,
	p_TEMPLATE_ID IN NUMBER,
	p_PERIOD_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_METER_READING IN VARCHAR,
	p_CONSUMPTION_ID OUT NUMBER
	) AS

v_SERVICE_DELIVERY_ID NUMBER(9);
v_SERVICE_CONSUMPTION SERVICE_CONSUMPTION%ROWTYPE;

BEGIN

	CS.GET_SERVICE_DELIVERY_ID(p_ACCOUNT_SERVICE_ID, p_PROVIDER_SERVICE_ID, p_POOL_ID, p_END_DATE, v_SERVICE_DELIVERY_ID);
	v_SERVICE_CONSUMPTION.SERVICE_ID := GET_SERVICE_ID(p_MODEL_ID, p_SCENARIO_ID, p_ACCOUNT_SERVICE_ID, p_PROVIDER_SERVICE_ID, v_SERVICE_DELIVERY_ID, p_RECEIVED_DATE);

	v_SERVICE_CONSUMPTION.BEGIN_DATE := p_BEGIN_DATE;
	v_SERVICE_CONSUMPTION.END_DATE := p_END_DATE;
	v_SERVICE_CONSUMPTION.BILL_CODE := p_BILL_CODE;
	v_SERVICE_CONSUMPTION.CONSUMPTION_CODE := p_CONSUMPTION_CODE;
	v_SERVICE_CONSUMPTION.RECEIVED_DATE := p_RECEIVED_DATE;
	v_SERVICE_CONSUMPTION.TEMPLATE_ID := p_TEMPLATE_ID;
	v_SERVICE_CONSUMPTION.PERIOD_ID := p_PERIOD_ID;
	v_SERVICE_CONSUMPTION.METER_TYPE := p_METER_TYPE;
	v_SERVICE_CONSUMPTION.METER_READING := p_METER_READING;
	v_SERVICE_CONSUMPTION.BILLED_USAGE := p_BILLED_USAGE;
	v_SERVICE_CONSUMPTION.BILLED_DEMAND := p_BILLED_DEMAND;
	v_SERVICE_CONSUMPTION.METERED_USAGE := p_METERED_USAGE;
	v_SERVICE_CONSUMPTION.METERED_DEMAND := p_METERED_DEMAND;
	v_SERVICE_CONSUMPTION.METERS_READ := p_METERS_READ;
	v_SERVICE_CONSUMPTION.CONVERSION_FACTOR := CONSTANTS.NOT_ASSIGNED;
	v_SERVICE_CONSUMPTION.IGNORE_CONSUMPTION := p_IGNORE_CONSUMPTION;
	v_SERVICE_CONSUMPTION.BILL_PROCESSED_DATE := NULL;
	v_SERVICE_CONSUMPTION.ENTRY_DATE := SYSDATE;

	PUT_SERVICE_CONSUMPTION(v_SERVICE_CONSUMPTION, p_CONSUMPTION_ID);

END PUT_SERVICE_CONSUMPTION;

----------------------------------------------------------------------------------------------------
PROCEDURE PUT_AGGREGATE_ACCOUNT_ESP
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AGGREGATE_ID IN OUT NUMBER
	) AS

BEGIN

	IF p_AGGREGATE_ID = CONSTANTS.NOT_ASSIGNED OR p_AGGREGATE_ID IS NULL THEN
		SELECT OID.NEXTVAL INTO p_AGGREGATE_ID FROM DUAL;
	END IF;

	INSERT INTO AGGREGATE_ACCOUNT_ESP (
		ACCOUNT_ID,
		ESP_ID,
		POOL_ID,
		BEGIN_DATE,
		END_DATE,
		AGGREGATE_ID,
		ENTRY_DATE)
	VALUES (
		p_ACCOUNT_ID,
		p_ESP_ID,
		p_POOL_ID,
		p_BEGIN_DATE,
		p_END_DATE,
		p_AGGREGATE_ID,
		SYSDATE);

END PUT_AGGREGATE_ACCOUNT_ESP;
----------------------------------------------------------------------------------------------------
PROCEDURE SET_AGGREGATE_ACCOUNT_SERVICE
	(
	p_AGGREGATE_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_SERVICE_ACCOUNTS IN NUMBER,
	p_USAGE_FACTOR IN NUMBER
	) AS

BEGIN

	INSERT INTO AGGREGATE_ACCOUNT_SERVICE (
		CASE_ID,
		AGGREGATE_ID,
		SERVICE_DATE,
		AS_OF_DATE,
		SERVICE_ACCOUNTS,
		USAGE_FACTOR)
	SELECT GA.BASE_CASE_ID,
		p_AGGREGATE_ID,
		p_SERVICE_DATE,
		p_AS_OF_DATE,
		p_SERVICE_ACCOUNTS,
		p_USAGE_FACTOR
	FROM DUAL
	WHERE NOT EXISTS
		(SELECT 1
		FROM AGGREGATE_ACCOUNT_SERVICE
		WHERE AGGREGATE_ID = p_AGGREGATE_ID
			AND CASE_ID = GA.BASE_CASE_ID  --Specify CASE_ID
			AND SERVICE_DATE = p_SERVICE_DATE
			AND AS_OF_DATE = p_AS_OF_DATE);

END SET_AGGREGATE_ACCOUNT_SERVICE;
----------------------------------------------------------------------------------------------------
PROCEDURE AGG_POST_ESP_ASSIGNMENT
	(
	p_MODEL_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AGGREGATE_ID OUT NUMBER
	) AS

v_SERVICE_DATE DATE;
v_AS_OF_DATE DATE;

CURSOR c_ASSIGNMENT IS
	SELECT AGGREGATE_ID, BEGIN_DATE, NVL(END_DATE, HIGH_DATE) "END_DATE", ROWID
	FROM AGGREGATE_ACCOUNT_ESP
	WHERE  ACCOUNT_ID = p_ACCOUNT_ID
		AND ESP_ID = p_ESP_ID
		AND POOL_ID = p_POOL_ID;

BEGIN

	IF GA.VERSION_AGGREGATE_ACCOUNT_SVC THEN
		v_AS_OF_DATE := SYSDATE;
	ELSE
		v_AS_OF_DATE := LOW_DATE;
	END IF;

-- Extend the Account ESP service period to accomodate the specified begin and end date range.
	FOR v_ASSIGNMENT IN c_ASSIGNMENT LOOP
		IF p_BEGIN_DATE < v_ASSIGNMENT.BEGIN_DATE THEN
			v_SERVICE_DATE := p_BEGIN_DATE;
			WHILE v_SERVICE_DATE < v_ASSIGNMENT.BEGIN_DATE LOOP
				SET_AGGREGATE_ACCOUNT_SERVICE(v_ASSIGNMENT.AGGREGATE_ID, v_SERVICE_DATE, v_AS_OF_DATE, 0, 0);
				v_SERVICE_DATE := v_SERVICE_DATE + 1;
			END LOOP;
			UPDATE AGGREGATE_ACCOUNT_ESP SET BEGIN_DATE = p_BEGIN_DATE, ENTRY_DATE = SYSDATE WHERE ROWID = v_ASSIGNMENT.ROWID;
		END IF;
		IF p_END_DATE > v_ASSIGNMENT.END_DATE THEN
			v_SERVICE_DATE := v_ASSIGNMENT.END_DATE + 1;
			WHILE v_SERVICE_DATE <= p_END_DATE LOOP
				SET_AGGREGATE_ACCOUNT_SERVICE(v_ASSIGNMENT.AGGREGATE_ID, v_SERVICE_DATE, v_AS_OF_DATE, 0, 0);
				v_SERVICE_DATE := v_SERVICE_DATE + 1;
			END LOOP;
			UPDATE AGGREGATE_ACCOUNT_ESP SET END_DATE = p_END_DATE WHERE ROWID = v_ASSIGNMENT.ROWID;
		END IF;
		p_AGGREGATE_ID := v_ASSIGNMENT.AGGREGATE_ID;
		RETURN;
	END LOOP;

-- If above logic does not return the Aggregate Id then there is no Account ESP assignment.
-- Check if there is an Aggregate Id associated with a Forecast within the Consumption period.
	p_AGGREGATE_ID := GET_AGGREGATE_ID(p_MODEL_ID, p_ACCOUNT_ID, p_SERVICE_LOCATION_ID, p_EDC_ID, p_ESP_ID, p_PSE_ID, p_POOL_ID, p_BEGIN_DATE, p_END_DATE);

-- Create the entries necessary to reflect the Aggregate Account ESP relationship over this time period.
	PUT_AGGREGATE_ACCOUNT_ESP(p_ACCOUNT_ID, p_ESP_ID, p_POOL_ID, p_BEGIN_DATE, p_END_DATE, p_AGGREGATE_ID);
	v_SERVICE_DATE := p_BEGIN_DATE;
	WHILE v_SERVICE_DATE <= p_END_DATE LOOP
		SET_AGGREGATE_ACCOUNT_SERVICE(p_AGGREGATE_ID, v_SERVICE_DATE, v_AS_OF_DATE, 0, 0);
		v_SERVICE_DATE := v_SERVICE_DATE + 1;
	END LOOP;

END AGG_POST_ESP_ASSIGNMENT;
----------------------------------------------------------------------------------------------------
FUNCTION GET_SERVICE_STATE
	(
	p_SCENARIO_ID IN NUMBER,
	p_SERVICE_CODE IN CHAR,
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_AGGREGATE_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_REQUESTOR IN VARCHAR,
	p_DELETE_FIRST IN NUMBER := 0
	) RETURN SERVICE_STATE%ROWTYPE IS

v_SERVICE_STATE SERVICE_STATE%ROWTYPE;

BEGIN

	v_SERVICE_STATE := CS.GET_SERVICE_STATE(GA.DEFAULT_MODEL, p_SCENARIO_ID, p_ACCOUNT_ID, p_SERVICE_LOCATION_ID, p_METER_ID, p_AGGREGATE_ID, p_SERVICE_CODE, p_SERVICE_DATE, p_AS_OF_DATE,
											p_EDC_ID, p_ESP_ID, p_PSE_ID, p_POOL_ID, g_APPLY_UFE_CODE, p_REQUESTOR);

    IF NOT GA.CSB_IS_SUBDAILY THEN
		DELETE FROM SERVICE_STATE SS WHERE
			SS.SERVICE_ID IN (SELECT SRV.SERVICE_ID
								FROM SERVICE CURR_SRV,
									 ACCOUNT_SERVICE ASRV,
									 SERVICE SRV
								WHERE CURR_SRV.SERVICE_ID = v_SERVICE_STATE.SERVICE_ID
									AND ASRV.ACCOUNT_SERVICE_ID = CURR_SRV.ACCOUNT_SERVICE_ID
									AND SRV.ACCOUNT_SERVICE_ID = ASRV.ACCOUNT_SERVICE_ID
									AND SRV.MODEL_ID = CURR_SRV.MODEL_ID
									AND SRV.SCENARIO_ID = p_SCENARIO_ID
									AND SRV.AS_OF_DATE = CONSTANTS.LOW_DATE
									AND SRV.SERVICE_ID <> v_SERVICE_STATE.SERVICE_ID)
			AND SS.SERVICE_CODE = v_SERVICE_STATE.SERVICE_CODE
			AND SS.SERVICE_DATE = v_SERVICE_STATE.SERVICE_DATE;
	END IF;

	IF p_DELETE_FIRST = 1 THEN
		DELETE FROM SERVICE_STATE SS WHERE
			SS.SERVICE_ID = v_SERVICE_STATE.SERVICE_ID
				AND SS.SERVICE_CODE = v_SERVICE_STATE.SERVICE_CODE
				AND SS.SERVICE_DATE = v_SERVICE_STATE.SERVICE_DATE;
	END IF;

	v_SERVICE_STATE.PROFILE_TYPE := CASE WHEN p_SERVICE_CODE = GA.ACTUAL_SERVICE THEN FS.g_ACTUAL_USAGE_PROFILE
											ELSE FS.g_EXTERNAL_PROFILE END;
	v_SERVICE_STATE.PROFILE_SOURCE_DATE := p_SERVICE_DATE;
	v_SERVICE_STATE.PROFILE_ZERO_COUNT := 0;
	CS.PUT_SERVICE_STATE(v_SERVICE_STATE);

	RETURN v_SERVICE_STATE;

END GET_SERVICE_STATE;
----------------------------------------------------------------------------------------------------
FUNCTION GET_SERVICE_STATE
	(
	p_SCENARIO_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_AGGREGATE_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_REQUESTOR IN VARCHAR
	) RETURN SERVICE_STATE%ROWTYPE IS

BEGIN

	RETURN GET_SERVICE_STATE(p_SCENARIO_ID, GA.ACTUAL_SERVICE, p_ACCOUNT_ID, p_SERVICE_LOCATION_ID, p_METER_ID, p_AGGREGATE_ID,
							CONSTANTS.NOT_ASSIGNED, CONSTANTS.NOT_ASSIGNED, CONSTANTS.NOT_ASSIGNED, CONSTANTS.NOT_ASSIGNED,
							p_SERVICE_DATE, p_AS_OF_DATE, p_REQUESTOR);

END GET_SERVICE_STATE;
----------------------------------------------------------------------------------------------------
FUNCTION GET_SERVICE_STATE
	(
	p_SCENARIO_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_REQUESTOR IN VARCHAR
	) RETURN SERVICE_STATE%ROWTYPE IS

v_ACCOUNT_ID NUMBER(9);
v_SERVICE_LOCATION_ID NUMBER(9);
v_AGGREGATE_ID NUMBER(1) := CONSTANTS.NOT_ASSIGNED;

BEGIN

	v_SERVICE_LOCATION_ID := GET_METER_OWNER(p_METER_ID, p_SERVICE_DATE);
	v_ACCOUNT_ID := GET_SERVICE_LOCATION_OWNER(v_SERVICE_LOCATION_ID, p_SERVICE_DATE);

	RETURN GET_SERVICE_STATE(p_SCENARIO_ID, v_ACCOUNT_ID, v_SERVICE_LOCATION_ID, p_METER_ID, v_AGGREGATE_ID, p_SERVICE_DATE, p_AS_OF_DATE, p_REQUESTOR);

END GET_SERVICE_STATE;
--------------------------------------------------------------------------------------------------
PROCEDURE STORE_SERVICE_LOAD
	(
	p_SERVICE_ID IN NUMBER,
	p_SERVICE_CODE IN CHAR,
	p_LOAD_DATE IN GA.DATE_TABLE,
	p_LOAD IN GA.FLOAT_TABLE,
	p_TX_LOSS IN GA.FACTOR_TABLE,
	p_DX_LOSS IN GA.FACTOR_TABLE,
	p_UE_LOSS IN GA.FACTOR_TABLE
	) AS

v_INDEX BINARY_INTEGER;
v_LOAD_CODE CHAR(1) := GA.STANDARD;
v_BEGIN_DATE DATE;
v_END_DATE DATE;

BEGIN

	v_BEGIN_DATE := p_LOAD_DATE(p_LOAD_DATE.FIRST);
	v_END_DATE := p_LOAD_DATE(p_LOAD_DATE.LAST);

	DELETE SERVICE_LOAD
	WHERE SERVICE_ID = p_SERVICE_ID
		AND SERVICE_CODE = p_SERVICE_CODE
		AND LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
		AND LOAD_CODE = v_LOAD_CODE;

	FORALL v_INDEX IN 1..p_LOAD_DATE.COUNT
		INSERT INTO SERVICE_LOAD(SERVICE_ID, SERVICE_CODE, LOAD_DATE, LOAD_CODE, LOAD_VAL, TX_LOSS_VAL, DX_LOSS_VAL, UE_LOSS_VAL)
		VALUES (p_SERVICE_ID, p_SERVICE_CODE, p_LOAD_DATE(v_INDEX), v_LOAD_CODE, p_LOAD(v_INDEX), p_TX_LOSS(v_INDEX),  p_DX_LOSS(v_INDEX), p_UE_LOSS(v_INDEX));

END STORE_SERVICE_LOAD;
----------------------------------------------------------------------------------------------------
FUNCTION GET_PROVIDER_SERVICE_STATE
	(
	p_ACCOUNT_SERVICE_ID IN NUMBER,
	p_PROVIDER_SERVICE_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
   p_AS_OF_DATE IN DATE,
-- Begin Implementation Override --
   p_POOL_ID IN NUMBER DEFAULT NULL
-- End Implementation Override --
	) RETURN SERVICE_STATE %ROWTYPE IS

v_SERVICE_STATE SERVICE_STATE%ROWTYPE;

BEGIN

   --v_SERVICE_STATE := CS.GET_PROVIDER_SERVICE_STATE(GA.DEFAULT_MODEL, GA.BASE_SCENARIO_ID, p_ACCOUNT_SERVICE_ID, p_PROVIDER_SERVICE_ID, p_SERVICE_DATE, p_AS_OF_DATE);
   v_SERVICE_STATE := CS.GET_PROVIDER_SERVICE_STATE(GA.DEFAULT_MODEL, GA.BASE_SCENARIO_ID, p_ACCOUNT_SERVICE_ID, p_PROVIDER_SERVICE_ID, p_POOL_ID, p_SERVICE_DATE, p_AS_OF_DATE); --@@Implementation Override --
	CS.PUT_SERVICE_STATE(v_SERVICE_STATE);
	RETURN v_SERVICE_STATE;

END GET_PROVIDER_SERVICE_STATE;
----------------------------------------------------------------------------------------------------
FUNCTION GET_LOSS_FACTOR_VAL
	(
	p_SERVICE_DATE IN DATE,
	p_LOSS_FACTOR_PATTERN IN GA.NUMBER_TABLE
	) RETURN NUMBER AS

v_COUNT NUMBER(3);
v_HOUR NUMBER(2);
v_MINUTES NUMBER(2);
v_INDEX BINARY_INTEGER;
BEGIN

	v_COUNT := p_LOSS_FACTOR_PATTERN.COUNT;
	IF v_COUNT = 0 THEN
	  	RETURN CONSTANTS.NOT_ASSIGNED;
	ELSIF v_COUNT = 1 THEN
		v_INDEX := p_LOSS_FACTOR_PATTERN.FIRST;
	ELSE
		v_HOUR := TO_NUMBER(TO_CHAR(p_SERVICE_DATE,'HH24'));
		v_MINUTES := TO_NUMBER(TO_CHAR(p_SERVICE_DATE,'MI'));
		v_INDEX := (v_COUNT/24) * v_HOUR + TRUNC(v_MINUTES * v_COUNT / 1440);
	END IF;

	RETURN p_LOSS_FACTOR_PATTERN(v_INDEX);

EXCEPTION
	WHEN OTHERS THEN
		ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
		RETURN CONSTANTS.NOT_ASSIGNED;
END GET_LOSS_FACTOR_VAL;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_LOSS_FACTORS
	(
	p_ACCOUNT_SERVICE_ID IN NUMBER,
	p_EDC_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_INTERVAL IN NUMBER,
	p_STRING_TABLE IN GA.STRING_TABLE,
	p_USAGE_DATE OUT GA.DATE_TABLE,
	p_USAGE_VAL OUT GA.FLOAT_TABLE,
	p_TX_LOSS OUT GA.FACTOR_TABLE,
	p_DX_LOSS OUT GA.FACTOR_TABLE,
	p_UE_LOSS OUT GA.FACTOR_TABLE,
	p_FAULT_CACHE IN BOOLEAN DEFAULT FALSE
	) AS

v_INDEX BINARY_INTEGER;
v_TX_LOSS_FACTOR_PATTERN GA.NUMBER_TABLE;
v_DX_LOSS_FACTOR_PATTERN GA.NUMBER_TABLE;
v_UE_LOSS_FACTOR_PATTERN GA.NUMBER_TABLE;
v_SERVICE_LOAD SERVICE_LOAD%ROWTYPE;

BEGIN

	v_TX_LOSS_FACTOR_PATTERN := CX.GET_LOSS_FACTOR_PATTERN(p_ACCOUNT_SERVICE_ID, p_EDC_ID, p_SERVICE_DATE, 'Transmission', p_FAULT_CACHE);
	v_DX_LOSS_FACTOR_PATTERN := CX.GET_LOSS_FACTOR_PATTERN(p_ACCOUNT_SERVICE_ID, p_EDC_ID, p_SERVICE_DATE, 'Distribution', p_FAULT_CACHE);
	v_UE_LOSS_FACTOR_PATTERN := CX.GET_LOSS_FACTOR_PATTERN(p_ACCOUNT_SERVICE_ID, p_EDC_ID, p_SERVICE_DATE, 'UFE', p_FAULT_CACHE);
	v_SERVICE_LOAD.LOAD_DATE := p_SERVICE_DATE;
	FOR v_INDEX IN p_STRING_TABLE.FIRST..p_STRING_TABLE.LAST LOOP
		IF p_STRING_TABLE.EXISTS(v_INDEX) THEN
     		v_SERVICE_LOAD.LOAD_VAL := TO_NUMBER(p_STRING_TABLE(v_INDEX));
    		p_USAGE_DATE(v_INDEX)   := v_SERVICE_LOAD.LOAD_DATE;
    		p_USAGE_VAL(v_INDEX)	:= v_SERVICE_LOAD.LOAD_VAL;
    		IF v_SERVICE_LOAD.LOAD_VAL < 20000000 THEN -- filter out the dates that might get in here.
    		    p_DX_LOSS(v_INDEX) := v_SERVICE_LOAD.LOAD_VAL * GET_LOSS_FACTOR_VAL(p_SERVICE_DATE, v_DX_LOSS_FACTOR_PATTERN);
    			p_TX_LOSS(v_INDEX) := (v_SERVICE_LOAD.LOAD_VAL + p_DX_LOSS(v_INDEX)) * GET_LOSS_FACTOR_VAL(p_SERVICE_DATE, v_TX_LOSS_FACTOR_PATTERN);
    			p_UE_LOSS(v_INDEX) := (v_SERVICE_LOAD.LOAD_VAL + p_DX_LOSS(v_INDEX) + p_TX_LOSS(v_INDEX)) * GET_LOSS_FACTOR_VAL(p_SERVICE_DATE, v_UE_LOSS_FACTOR_PATTERN);
    		END IF;
    		v_SERVICE_LOAD.LOAD_DATE := ADD_SECONDS_TO_DATE(v_SERVICE_LOAD.LOAD_DATE, p_INTERVAL);
		END IF;
	END LOOP;
END GET_LOSS_FACTORS;
----------------------------------------------------------------------------------------------------
PROCEDURE SAVE_METER_INTERVAL_USAGE
	(
	p_SERVICE_STATE IN SERVICE_STATE%ROWTYPE,
	p_USAGE_DATE IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_DATE_FORMAT IN VARCHAR,
	p_INTERVAL IN VARCHAR,
	p_USAGE_VALUES IN VARCHAR
	) AS

v_TIME_ZONE VARCHAR(3);
v_LOCAL_DATE DATE;

v_INTERVAL NUMBER;
v_STRING_TABLE GA.STRING_TABLE;
v_SERVICE_LOAD SERVICE_LOAD%ROWTYPE;
v_ACCOUNT_SERVICE_ID NUMBER(9);
v_EDC_ID NUMBER(9);
v_TX_LOSS GA.FACTOR_TABLE;
v_DX_LOSS GA.FACTOR_TABLE;
v_UE_LOSS GA.FACTOR_TABLE;
v_USAGE_DATE GA.DATE_TABLE;
v_USAGE_VAL GA.FLOAT_TABLE;
BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	v_LOCAL_DATE := TO_DATE(p_USAGE_DATE, p_DATE_FORMAT);

-- Determine the correct Time Zone
	IF p_TIME_ZONE = STD_TIME_ZONE(p_TIME_ZONE) THEN
		v_TIME_ZONE := p_TIME_ZONE;
	ELSIF IS_IN_DST_TIME_PERIOD(v_LOCAL_DATE) THEN
		v_TIME_ZONE := DST_TIME_ZONE(p_TIME_ZONE);
	ELSE
		v_TIME_ZONE := STD_TIME_ZONE(p_TIME_ZONE);
	END IF;

	v_SERVICE_LOAD.SERVICE_ID := p_SERVICE_STATE.SERVICE_ID;
	v_SERVICE_LOAD.SERVICE_CODE := GA.ACTUAL_SERVICE;
	v_SERVICE_LOAD.LOAD_CODE := GA.STANDARD;
	v_SERVICE_LOAD.LOAD_DATE := NEW_TIME(v_LOCAL_DATE, v_TIME_ZONE, CUT_TIME_ZONE);
	v_INTERVAL := TO_NUMBER(LTRIM(RTRIM(p_INTERVAL)));

	SELECT ACCOUNT_SERVICE_ID, EDC_ID
	INTO v_ACCOUNT_SERVICE_ID, v_EDC_ID
	FROM SERVICE A, PROVIDER_SERVICE B
	WHERE A.SERVICE_ID = v_SERVICE_LOAD.SERVICE_ID
		AND B.PROVIDER_SERVICE_ID = A.PROVIDER_SERVICE_ID;

	UT.TOKENS_FROM_STRING(p_USAGE_VALUES,',', v_STRING_TABLE);

	GET_LOSS_FACTORS(v_ACCOUNT_SERVICE_ID, v_EDC_ID, v_SERVICE_LOAD.LOAD_DATE,v_INTERVAL,v_STRING_TABLE, v_USAGE_DATE, v_USAGE_VAL, v_TX_LOSS, v_DX_LOSS, v_UE_LOSS, TRUE);

	STORE_SERVICE_LOAD(v_SERVICE_LOAD.SERVICE_ID, GA.ACTUAL_SERVICE, v_USAGE_DATE, v_USAGE_VAL, v_TX_LOSS, v_DX_LOSS, v_UE_LOSS);

END SAVE_METER_INTERVAL_USAGE;

----------------------------------------------------------------------------------------------------

PROCEDURE IMPORT_METER_INTERVAL_USAGE
	(
	p_MRSP_NAME IN VARCHAR DEFAULT NULL,
	p_METER_EXTERNAL_IDENTIFIER IN VARCHAR,
	p_USAGE_DATE IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_DATE_FORMAT IN VARCHAR DEFAULT 'DD-MON-YYYY',
	p_INTERVAL IN VARCHAR DEFAULT 3600,
	p_USAGE_VALUES IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_MRSP_ID NUMBER;
v_METER_ID NUMBER;
v_MRSP_NAME METER_READING_SERVICE_PROVIDER.MRSP_NAME%TYPE;
v_LOCAL_DATE DATE;
v_AS_OF_DATE DATE := SYSDATE;
v_SERVICE_STATE SERVICE_STATE%ROWTYPE;
v_SCENARIO_ID NUMBER(9) := GA.BASE_SCENARIO_ID;
BEGIN

	v_MRSP_NAME := LTRIM(RTRIM(p_MRSP_NAME));
	IF v_MRSP_NAME IS NOT NULL THEN
	    IF v_MRSP_NAME = '?' THEN
		    v_MRSP_ID := NULL;
		ELSE
			ID.ID_FOR_MRSP(v_MRSP_NAME, v_MRSP_ID);
		END IF;
	ELSE
		v_MRSP_ID := NULL;
	END IF;

	ID.ID_FOR_METER_EXTERNAL_IDENT(v_MRSP_ID, p_METER_EXTERNAL_IDENTIFIER, FALSE, v_METER_ID);

	IF v_METER_ID <= 0 THEN
		ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'Meter with External Identifier = ' || p_METER_EXTERNAL_IDENTIFIER);
	END IF;

	v_LOCAL_DATE := TO_DATE(p_USAGE_DATE, p_DATE_FORMAT);
	g_APPLY_UFE_CODE := 0;
	v_SERVICE_STATE := GET_SERVICE_STATE(v_SCENARIO_ID, v_METER_ID, TRUNC(v_LOCAL_DATE), v_AS_OF_DATE, g_UNKNOWN);

	IF v_SERVICE_STATE.SERVICE_ID <= 0 THEN
		ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'Service with External Identifier = ' || p_METER_EXTERNAL_IDENTIFIER);
	END IF;

	p_STATUS := GA.SUCCESS;
	SAVE_METER_INTERVAL_USAGE(v_SERVICE_STATE, p_USAGE_DATE, p_TIME_ZONE, p_DATE_FORMAT, p_INTERVAL, p_USAGE_VALUES);


END IMPORT_METER_INTERVAL_USAGE;
----------------------------------------------------------------------------------------------------
PROCEDURE IMPORT_METER_NM_INTERVAL_USAGE
	(
	p_MRSP_NAME IN VARCHAR DEFAULT NULL,
	p_METER_NAME IN VARCHAR,
	p_USAGE_DATE IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_DATE_FORMAT IN VARCHAR DEFAULT 'DD-MON-YYYY',
	p_INTERVAL IN VARCHAR DEFAULT 3600,
	p_USAGE_VALUES IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_MRSP_ID NUMBER;
v_METER_ID NUMBER;
v_MRSP_NAME METER_READING_SERVICE_PROVIDER.MRSP_NAME%TYPE;
v_LOCAL_DATE DATE;
v_AS_OF_DATE DATE := SYSDATE;
v_SERVICE_STATE SERVICE_STATE%ROWTYPE;
v_SCENARIO_ID NUMBER(9) := GA.BASE_SCENARIO_ID;

-- This procedure is used by Central Services.  Do not change without coordinating
-- with the Central Services owner.

BEGIN

	v_MRSP_NAME := LTRIM(RTRIM(p_MRSP_NAME));
	IF v_MRSP_NAME IS NOT NULL THEN
	    IF v_MRSP_NAME = '?' THEN
		    v_MRSP_ID := NULL;
		ELSE
			ID.ID_FOR_MRSP(v_MRSP_NAME, v_MRSP_ID);
		END IF;
	ELSE
		v_MRSP_ID := NULL;
	END IF;

	ID.ID_FOR_METER(v_MRSP_ID, p_METER_NAME, FALSE, v_METER_ID);

	IF v_METER_ID <= 0 THEN
		ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'METER NOT DEFINED FOR ' || p_METER_NAME);
	END IF;

	v_LOCAL_DATE := TO_DATE(p_USAGE_DATE, p_DATE_FORMAT);
	g_APPLY_UFE_CODE := 0;
	v_SERVICE_STATE := GET_SERVICE_STATE(v_SCENARIO_ID, v_METER_ID, TRUNC(v_LOCAL_DATE), v_AS_OF_DATE, g_UNKNOWN);

	IF v_SERVICE_STATE.SERVICE_ID <= 0 THEN
		ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'ACCOUNT SERVICE NOT DEFINED FOR ' || p_METER_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	SAVE_METER_INTERVAL_USAGE(v_SERVICE_STATE, p_USAGE_DATE, p_TIME_ZONE, p_DATE_FORMAT, p_INTERVAL, p_USAGE_VALUES);


END IMPORT_METER_NM_INTERVAL_USAGE;
----------------------------------------------------------------------------------------------------
PROCEDURE IMPORT_ACCOUNT_INTERVAL_USAGE
	(
	p_MODEL_ID IN NUMBER,
	p_ACCOUNT_EXTERNAL_IDENTIFIER IN VARCHAR,
	p_USAGE_DATE IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_DATE_FORMAT IN VARCHAR DEFAULT 'DD-MON-YYYY',
	p_INTERVAL IN VARCHAR DEFAULT 3600,
	p_USAGE_VALUES IN VARCHAR,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

v_ACCOUNT_ID NUMBER;
v_SERVICE_LOCATION_ID NUMBER;
v_SERVICE_DATE DATE;
v_CUT_DATE DATE;
v_INTERVAL NUMBER;
v_STRING_TABLE GA.STRING_TABLE;
v_AS_OF_DATE DATE := SYSDATE;
v_IS_DST BOOLEAN := INSTR(p_TIME_ZONE,'D') > 0;
v_ACCOUNT_SERVICE_ID NUMBER;
v_PROVIDER_SERVICE_ID NUMBER;
v_PROVIDER_SERVICE PROVIDER_SERVICE%ROWTYPE;
v_SERVICE_STATE SERVICE_STATE%ROWTYPE;
v_INDEX BINARY_INTEGER;
v_USAGE_DATE GA.DATE_TABLE;
v_USAGE_VAL GA.FLOAT_TABLE;
v_TX_LOSS GA.FACTOR_TABLE;
v_DX_LOSS GA.FACTOR_TABLE;
v_UE_LOSS GA.FACTOR_TABLE;
v_IS_ADJUSTED_DAY BOOLEAN;

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK';
	g_MODEL_ID := p_MODEL_ID;
	v_SERVICE_DATE := TO_DATE(p_USAGE_DATE, p_DATE_FORMAT);
	v_CUT_DATE := TO_CUT(v_SERVICE_DATE, p_TIME_ZONE);
	IF p_MODEL_ID = GA.GAS_MODEL THEN
		v_CUT_DATE := TRUNC(v_CUT_DATE);
	END IF;
	v_INTERVAL := TO_NUMBER(LTRIM(RTRIM(p_INTERVAL)));

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('IMPORT_ACCOUNT_INTERVAL_USAGE');
		LOGS.LOG_DEBUG('ACCOUNT_EXTERNAL_IDENTIFIER=' || p_ACCOUNT_EXTERNAL_IDENTIFIER);
		LOGS.LOG_DEBUG('USAGE_DATE=' || p_USAGE_DATE);
		LOGS.LOG_DEBUG('TIME_ZONE=' || p_TIME_ZONE);
		LOGS.LOG_DEBUG('DATE_FORMAT=' || p_DATE_FORMAT);
		LOGS.LOG_DEBUG('INTERVAL=' || p_INTERVAL);
		LOGS.LOG_DEBUG('<index>,<service id>,<date>,<load>,<tx loss>,<dx loss>');
	END IF;

	ID.ID_FOR_ACCOUNT_EXTERNAL_IDENT(p_ACCOUNT_EXTERNAL_IDENTIFIER, FALSE, v_ACCOUNT_ID);

	IF v_ACCOUNT_ID <= 0 THEN
		ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'ACCOUNT NOT DEFINED FOR ' || p_ACCOUNT_EXTERNAL_IDENTIFIER);
	END IF;

	v_SERVICE_LOCATION_ID := CS.GET_SERVICE_LOCATION_ID(v_ACCOUNT_ID, TRUNC(v_SERVICE_DATE));
	IF v_SERVICE_LOCATION_ID <= 0 THEN
	    ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'SERVICE LOCATION NOT DEFINED FOR ' || p_ACCOUNT_EXTERNAL_IDENTIFIER);
	END IF;

	IF GA.VERSION_ACTUAL THEN
		v_AS_OF_DATE := CORRECTED_AS_OF_DATE('Settlement', SYSDATE);
	ELSE
		v_AS_OF_DATE := LOW_DATE;
	END IF;

	CS.GET_ACCOUNT_SERVICE_ID(v_ACCOUNT_ID, v_SERVICE_LOCATION_ID, CONSTANTS.NOT_ASSIGNED, CONSTANTS.NOT_ASSIGNED, v_ACCOUNT_SERVICE_ID);
	CS.GET_PROVIDER_SERVICE_ID(v_ACCOUNT_ID, CONSTANTS.NOT_ASSIGNED, v_SERVICE_DATE, v_PROVIDER_SERVICE_ID);
	v_PROVIDER_SERVICE := CS.GET_PROVIDER_SERVICE(v_PROVIDER_SERVICE_ID);
	v_SERVICE_STATE := GET_PROVIDER_SERVICE_STATE(v_ACCOUNT_SERVICE_ID, v_PROVIDER_SERVICE_ID, TRUNC(v_SERVICE_DATE), v_AS_OF_DATE);
	IF v_SERVICE_STATE.SERVICE_ID <= 0 THEN
		ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'ACCOUNT SERVICE NOT DEFINED FOR ' || p_ACCOUNT_EXTERNAL_IDENTIFIER);
	END IF;

	UT.TOKENS_FROM_STRING(p_USAGE_VALUES,',', v_STRING_TABLE);

	v_IS_ADJUSTED_DAY := FALSE;
	IF v_IS_DST AND v_STRING_TABLE.COUNT = 24 THEN
		IF TRUNC(v_CUT_DATE) = TRUNC(DST_SPRING_AHEAD_DATE(v_CUT_DATE)) THEN
			v_IS_ADJUSTED_DAY := TRUE;
			IF GA.DST_SPRING_AHEAD_OPTION = 'A' THEN
				v_STRING_TABLE.DELETE(2);
			ELSIF GA.DST_SPRING_AHEAD_OPTION = 'B' THEN
				v_STRING_TABLE.DELETE(3);
			ELSIF GA.DST_SPRING_AHEAD_OPTION = 'C' THEN
				v_STRING_TABLE.DELETE(24);
			END IF;
		ELSIF TRUNC(v_CUT_DATE) = TRUNC(DST_FALL_BACK_DATE(v_CUT_DATE)) THEN
			IF GA.DST_FALL_BACK_OPTION = 'A' THEN
				FOR v_INDEX IN REVERSE 3..25 LOOP
					v_STRING_TABLE(v_INDEX) := v_STRING_TABLE(v_INDEX-1);
				END LOOP;
			ELSIF GA.DST_FALL_BACK_OPTION = 'B' THEN
				v_STRING_TABLE(25) := 0;
			END IF;
		END IF;
	END IF;

	FOR v_INDEX IN v_STRING_TABLE.FIRST..v_STRING_TABLE.LAST LOOP
		IF v_STRING_TABLE.EXISTS(v_INDEX) THEN
			v_USAGE_DATE(v_INDEX) := v_CUT_DATE;
	 		v_USAGE_VAL(v_INDEX) := TO_NUMBER(v_STRING_TABLE(v_INDEX));
			v_CUT_DATE := GET_NEXT_CUT_DATE(v_CUT_DATE, v_INTERVAL, v_IS_ADJUSTED_DAY);
			IF LOGS.IS_DEBUG_ENABLED THEN
				LOGS.LOG_DEBUG(TO_CHAR(v_INDEX) || ',' || TO_CHAR(v_SERVICE_STATE.SERVICE_ID) || ',' || UT.TRACE_DATE(v_USAGE_DATE(v_INDEX)) || ',' || TO_CHAR(v_USAGE_VAL(v_INDEX)) || ',' || TO_CHAR(v_TX_LOSS(v_INDEX)) || ',' || TO_CHAR(v_DX_LOSS(v_INDEX)));
			END IF;
		END IF;
	END LOOP;

	FS.APPLY_LOSS_FACTORS(v_ACCOUNT_SERVICE_ID, v_PROVIDER_SERVICE.EDC_ID, v_SERVICE_DATE, v_USAGE_VAL, v_TX_LOSS, v_DX_LOSS, v_UE_LOSS, TRUE);
	STORE_SERVICE_LOAD(v_SERVICE_STATE.SERVICE_ID, GA.ACTUAL_SERVICE, v_USAGE_DATE, v_USAGE_VAL, v_TX_LOSS, v_DX_LOSS, v_UE_LOSS);


END IMPORT_ACCOUNT_INTERVAL_USAGE;
----------------------------------------------------------------------------------------------------
PROCEDURE IMPORT_PROVIDER_INTERVAL_USAGE
	(
	p_MODEL_ID IN NUMBER,
	p_ACCOUNT_EXTERNAL_IDENTIFIER IN VARCHAR,
	p_EDC_EXTERNAL_IDENTIFIER IN VARCHAR,
	p_ESP_EXTERNAL_IDENTIFIER IN VARCHAR,
	p_PSE_EXTERNAL_IDENTIFIER IN VARCHAR,
-- Begin Implementation Override --
   p_POOL_EXTERNAL_IDENTIFIER IN VARCHAR,
-- End Implementation Override --
	p_USAGE_DATE IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_DATE_FORMAT IN VARCHAR DEFAULT 'DD-MON-YYYY',
	p_INTERVAL IN VARCHAR DEFAULT 3600,
	p_USAGE_VALUES IN VARCHAR,
	p_TRANSMISSION_LOSS_FACTOR IN NUMBER,
	p_DISTRIBUTION_LOSS_FACTOR IN NUMBER,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

v_ACCOUNT_ID NUMBER;
v_SERVICE_LOCATION_ID NUMBER;
v_EDC_ID NUMBER;
v_ESP_ID NUMBER;
v_PSE_ID NUMBER;
-- Begin Implementation Override --
v_POOL_ID NUMBER;
-- End Implementation Override --
v_LOCAL_DATE DATE;
v_CUT_DATE DATE;
v_INTERVAL NUMBER;
v_STRING_TABLE GA.STRING_TABLE;
v_AS_OF_DATE DATE := SYSDATE;
v_IS_DST BOOLEAN := INSTR(p_TIME_ZONE,'D') > 0;
v_ACCOUNT_SERVICE_ID NUMBER;
v_PROVIDER_SERVICE_ID NUMBER;
v_SERVICE_STATE SERVICE_STATE%ROWTYPE;
v_INDEX BINARY_INTEGER;
v_USAGE_DATE GA.DATE_TABLE;
v_USAGE_VAL GA.FLOAT_TABLE;
v_TX_LOSS GA.FACTOR_TABLE;
v_DX_LOSS GA.FACTOR_TABLE;
v_UE_LOSS GA.FACTOR_TABLE;
v_IS_ADJUSTED_DAY BOOLEAN;

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK';
	g_MODEL_ID := p_MODEL_ID;
	v_LOCAL_DATE := TO_DATE(p_USAGE_DATE, p_DATE_FORMAT);
	v_CUT_DATE := TO_CUT(v_LOCAL_DATE, p_TIME_ZONE);
	IF p_MODEL_ID = GA.GAS_MODEL THEN
		v_CUT_DATE := TRUNC(v_CUT_DATE);
	END IF;
	v_INTERVAL := TO_NUMBER(LTRIM(RTRIM(p_INTERVAL)));

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('IMPORT_PROVIDER_INTERVAL_USAGE');
		LOGS.LOG_DEBUG('ACCOUNT_EXTERNAL_IDENTIFIER=' || p_ACCOUNT_EXTERNAL_IDENTIFIER);
		LOGS.LOG_DEBUG('EDC_EXTERNAL_IDENTIFIER=' || p_EDC_EXTERNAL_IDENTIFIER);
		LOGS.LOG_DEBUG('ESP_EXTERNAL_IDENTIFIER=' || p_ESP_EXTERNAL_IDENTIFIER);
		LOGS.LOG_DEBUG('PSE_EXTERNAL_IDENTIFIER=' || p_PSE_EXTERNAL_IDENTIFIER);
		LOGS.LOG_DEBUG('USAGE_DATE=' || p_USAGE_DATE);
		LOGS.LOG_DEBUG('TIME_ZONE=' || p_TIME_ZONE);
		LOGS.LOG_DEBUG('DATE_FORMAT=' || p_DATE_FORMAT);
		LOGS.LOG_DEBUG('INTERVAL=' || p_INTERVAL);
		LOGS.LOG_DEBUG('<index>,<service id>,<date>,<load>,<tx loss>,<dx loss>');
	END IF;

	ID.ID_FOR_ACCOUNT_EXTERNAL_IDENT(p_ACCOUNT_EXTERNAL_IDENTIFIER, FALSE, v_ACCOUNT_ID);

	IF v_ACCOUNT_ID <= 0 THEN
		ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'ACCOUNT NOT DEFINED FOR ' || p_ACCOUNT_EXTERNAL_IDENTIFIER);
	END IF;

	v_EDC_ID := ID.ID_FOR_EDC_EXTERNAL_IDENTIFIER(p_EDC_EXTERNAL_IDENTIFIER);
	IF v_EDC_ID <= 0 THEN
		ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'EDC NOT DEFINED FOR ' || p_EDC_EXTERNAL_IDENTIFIER);
	END IF;

	v_ESP_ID := ID.ID_FOR_ESP_EXTERNAL_IDENTIFIER(p_ESP_EXTERNAL_IDENTIFIER);
	IF v_ESP_ID <= 0 THEN
	    ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'ESP NOT DEFINED FOR ' || p_ESP_EXTERNAL_IDENTIFIER);
	END IF;

	v_PSE_ID := ID.ID_FOR_PSE_EXTERNAL_IDENTIFIER(p_PSE_EXTERNAL_IDENTIFIER);
	IF v_PSE_ID <= 0 THEN
	    ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'PSE NOT DEFINED FOR ' || p_PSE_EXTERNAL_IDENTIFIER);
	END IF;

	v_SERVICE_LOCATION_ID := CS.GET_SERVICE_LOCATION_ID(v_ACCOUNT_ID, TRUNC(v_LOCAL_DATE));
	IF v_SERVICE_LOCATION_ID <= 0 THEN
	    ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'SERVICE LOCATION NOT DEFINED FOR ' || p_ACCOUNT_EXTERNAL_IDENTIFIER);
	END IF;

-- Begin Implementation Override --
   IF p_POOL_EXTERNAL_IDENTIFIER IS NOT NULL THEN
      v_POOL_ID := ID.ID_FOR_POOL_EXTERNAL_IDENT(p_POOL_EXTERNAL_IDENTIFIER);
      IF v_POOL_ID <= 0 THEN
         RAISE_APPLICATION_ERROR(-20315,'POOL NOT DEFINED FOR ' || p_POOL_EXTERNAL_IDENTIFIER);
      END IF;
   END IF;
-- End Implementation Override --
	IF GA.VERSION_ACTUAL THEN
		v_AS_OF_DATE := CORRECTED_AS_OF_DATE('Settlement', SYSDATE);
	ELSE
		v_AS_OF_DATE := LOW_DATE;
	END IF;

	CS.GET_ACCOUNT_SERVICE_ID(v_ACCOUNT_ID, v_SERVICE_LOCATION_ID, CONSTANTS.NOT_ASSIGNED, CONSTANTS.NOT_ASSIGNED, v_ACCOUNT_SERVICE_ID);
	CS.GET_PROVIDER_SERVICE_ID(v_EDC_ID, v_ESP_ID, v_PSE_ID, v_PROVIDER_SERVICE_ID);
	v_SERVICE_STATE := GET_PROVIDER_SERVICE_STATE(v_ACCOUNT_SERVICE_ID, v_PROVIDER_SERVICE_ID, TRUNC(v_LOCAL_DATE), v_AS_OF_DATE);
	IF v_SERVICE_STATE.SERVICE_ID <= 0 THEN
		ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'ACCOUNT SERVICE NOT DEFINED FOR ' || p_ACCOUNT_EXTERNAL_IDENTIFIER);
	END IF;

	UT.TOKENS_FROM_STRING(p_USAGE_VALUES,',', v_STRING_TABLE);

	v_IS_ADJUSTED_DAY := FALSE;
	IF v_IS_DST AND v_STRING_TABLE.COUNT = 24 THEN
		IF TRUNC(v_CUT_DATE) = TRUNC(DST_SPRING_AHEAD_DATE(v_CUT_DATE)) THEN
			v_IS_ADJUSTED_DAY := TRUE;
			IF GA.DST_SPRING_AHEAD_OPTION = 'A' THEN
				v_STRING_TABLE.DELETE(2);
			ELSIF GA.DST_SPRING_AHEAD_OPTION = 'B' THEN
				v_STRING_TABLE.DELETE(3);
			ELSIF GA.DST_SPRING_AHEAD_OPTION = 'C' THEN
				v_STRING_TABLE.DELETE(24);
			END IF;
		ELSIF TRUNC(v_CUT_DATE) = TRUNC(DST_FALL_BACK_DATE(v_CUT_DATE)) THEN
			IF GA.DST_FALL_BACK_OPTION = 'A' THEN
				FOR v_INDEX IN REVERSE 3..25 LOOP
					v_STRING_TABLE(v_INDEX) := v_STRING_TABLE(v_INDEX-1);
				END LOOP;
			ELSIF GA.DST_FALL_BACK_OPTION = 'B' THEN
				v_STRING_TABLE(25) := 0;
			END IF;
		END IF;
	END IF;

	FOR v_INDEX IN v_STRING_TABLE.FIRST..v_STRING_TABLE.LAST LOOP
		IF v_STRING_TABLE.EXISTS(v_INDEX) THEN
			v_USAGE_DATE(v_INDEX) := v_CUT_DATE;
	 		v_USAGE_VAL(v_INDEX) := TO_NUMBER(v_STRING_TABLE(v_INDEX));
			v_DX_LOSS(v_INDEX) := (v_USAGE_VAL(v_INDEX)) * p_DISTRIBUTION_LOSS_FACTOR;
			v_TX_LOSS(v_INDEX) := (v_USAGE_VAL(v_INDEX) + v_DX_LOSS(v_INDEX)) * p_TRANSMISSION_LOSS_FACTOR;
			v_UE_LOSS(v_INDEX) := CONSTANTS.NOT_ASSIGNED;
			v_CUT_DATE := GET_NEXT_CUT_DATE(v_CUT_DATE, v_INTERVAL, v_IS_ADJUSTED_DAY);
			IF LOGS.IS_DEBUG_ENABLED THEN
				LOGS.LOG_DEBUG(TO_CHAR(v_INDEX) || ',' || TO_CHAR(v_SERVICE_STATE.SERVICE_ID) || ',' || UT.TRACE_DATE(v_USAGE_DATE(v_INDEX)) || ',' || TO_CHAR(v_USAGE_VAL(v_INDEX)) || ',' || TO_CHAR(v_TX_LOSS(v_INDEX)) || ',' || TO_CHAR(v_DX_LOSS(v_INDEX)));
			END IF;
		END IF;
	END LOOP;

	STORE_SERVICE_LOAD(v_SERVICE_STATE.SERVICE_ID, GA.ACTUAL_SERVICE, v_USAGE_DATE, v_USAGE_VAL, v_TX_LOSS, v_DX_LOSS, v_UE_LOSS);


END IMPORT_PROVIDER_INTERVAL_USAGE;
----------------------------------------------------------------------------------------------------
PROCEDURE IMPORT_METER_BILLED_USAGE
	(
	p_METER_ID IN NUMBER,
	p_BEGIN_DATE IN VARCHAR,
	p_END_DATE IN VARCHAR,
	p_DATE_FORMAT IN VARCHAR,
	p_BILLED_USAGE IN VARCHAR,
	p_METERS_READ IN VARCHAR,
	p_METERED_USAGE IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_BEGIN_DATE DATE := TRUNC(TO_DATE(p_BEGIN_DATE, p_DATE_FORMAT));
v_END_DATE DATE := TRUNC(TO_DATE(p_END_DATE, p_DATE_FORMAT));
v_ACCOUNT_ID NUMBER(9);
v_SERVICE_LOCATION_ID NUMBER(9);
v_ACCOUNT_SERVICE_ID NUMBER(9);
v_PROVIDER_SERVICE_ID NUMBER(9);
v_CONSUMPTION_ID NUMBER(9);
v_METER_TYPE CHAR(1);
v_SCENARIO_ID NUMBER(9) := GA.BASE_SCENARIO_ID;

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	v_SERVICE_LOCATION_ID := GET_METER_OWNER(p_METER_ID, v_BEGIN_DATE);
	v_ACCOUNT_ID := GET_SERVICE_LOCATION_OWNER(v_SERVICE_LOCATION_ID, v_BEGIN_DATE);
	CS.GET_ACCOUNT_SERVICE_ID(v_ACCOUNT_ID, v_SERVICE_LOCATION_ID, p_METER_ID, CONSTANTS.NOT_ASSIGNED, v_ACCOUNT_SERVICE_ID);
	CS.GET_PROVIDER_SERVICE_ID(v_ACCOUNT_ID, CONSTANTS.NOT_ASSIGNED, TRUNC(v_BEGIN_DATE), v_PROVIDER_SERVICE_ID);
	v_METER_TYPE := CS.GET_METER_TYPE(v_ACCOUNT_ID, p_METER_ID);

	PUT_SERVICE_CONSUMPTION(GA.DEFAULT_MODEL, v_SCENARIO_ID, v_ACCOUNT_SERVICE_ID, v_PROVIDER_SERVICE_ID, v_BEGIN_DATE, v_END_DATE, v_METER_TYPE, p_BILLED_USAGE, NULL, p_METERED_USAGE, NULL, p_METERS_READ, GA.BILL_CONSUMPTION, GA.ACTUAL_CONSUMPTION, CONSTANTS.NOT_ASSIGNED, LOW_DATE, CONSTANTS.ANYTIME_TOU_TEMPLATE_ID, CONSTANTS.ANYTIME_PERIOD_ID, NULL, v_CONSUMPTION_ID);


END IMPORT_METER_BILLED_USAGE;
----------------------------------------------------------------------------------------------------
PROCEDURE IMPORT_METER_BILLED_USAGE
	(
	p_METER_NAME IN VARCHAR,
	p_BEGIN_DATE IN VARCHAR,
	p_END_DATE IN VARCHAR,
	p_DATE_FORMAT IN VARCHAR,
	p_BILLED_USAGE IN VARCHAR,
	p_METERS_READ IN VARCHAR,
	p_METERED_USAGE IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_METER_ID NUMBER;

BEGIN

	ID.ID_FOR_METER(NULL, p_METER_NAME, FALSE, v_METER_ID);
	IF v_METER_ID <= 0 THEN
		ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'METER NOT DEFINED FOR ' || p_METER_NAME);
	END IF;

	IMPORT_METER_BILLED_USAGE(v_METER_ID, p_BEGIN_DATE, p_END_DATE, p_DATE_FORMAT, p_BILLED_USAGE, p_METERS_READ, p_METERED_USAGE, p_STATUS);

END IMPORT_METER_BILLED_USAGE;
---------------------------------------------------------------------
PROCEDURE IMPORT_METER_NM_BILLED_USAGE
	(
	p_METER_NAME IN VARCHAR,
	p_BEGIN_DATE IN VARCHAR,
	p_END_DATE IN VARCHAR,
	p_DATE_FORMAT IN VARCHAR,
	p_BILLED_USAGE IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

-- This procedure is used by Central Services.  Do not change without coordinating
-- with the Central Services owner.
BEGIN

	IMPORT_METER_BILLED_USAGE(p_METER_NAME, p_BEGIN_DATE, p_END_DATE, p_DATE_FORMAT, p_BILLED_USAGE, NULL, NULL, p_STATUS);

END IMPORT_METER_NM_BILLED_USAGE;
---------------------------------------------------------------------
PROCEDURE IMPORT_ACCOUNT_BILLED_USAGE
	(
	p_ACCOUNT_EXTERNAL_IDENTIFIER IN VARCHAR,
	p_ESP_EXTERNAL_IDENTIFIER IN VARCHAR,
	p_BEGIN_DATE IN VARCHAR,
	p_END_DATE IN VARCHAR,
	p_DATE_FORMAT IN VARCHAR,
	p_BILLED_USAGE IN VARCHAR,
	p_METERS_READ IN VARCHAR,
	p_METERED_USAGE IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_ACCOUNT_ID NUMBER;
v_SERVICE_LOCATION_ID NUMBER;
v_METER_ID NUMBER := 0;
v_AGGREGATE_ID NUMBER := 0;
v_ESP_ID NUMBER;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_BILLED_USAGE NUMBER;
v_METERS_READ NUMBER;
v_METERED_USAGE NUMBER;
v_ACCOUNT_SERVICE_ID NUMBER;
v_PROVIDER_SERVICE_ID NUMBER;
v_METER_TYPE CHAR(1);
v_CONSUMPTION_ID NUMBER(9);
v_SCENARIO_ID NUMBER(9) := GA.BASE_SCENARIO_ID;

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	v_BEGIN_DATE := TRUNC(TO_DATE(p_BEGIN_DATE, p_DATE_FORMAT));
	v_END_DATE := TRUNC(TO_DATE(p_END_DATE, p_DATE_FORMAT));
	v_BILLED_USAGE := TO_NUMBER(p_BILLED_USAGE);
	v_METERS_READ := TO_NUMBER(p_METERS_READ);
	v_METERED_USAGE := TO_NUMBER(p_METERED_USAGE);

	ID.ID_FOR_ACCOUNT_EXTERNAL_IDENT(p_ACCOUNT_EXTERNAL_IDENTIFIER, FALSE, v_ACCOUNT_ID);

	IF v_ACCOUNT_ID <= 0 THEN
	    ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'ACCOUNT NOT DEFINED FOR ' || p_ACCOUNT_EXTERNAL_IDENTIFIER);
	END IF;

	IF p_ESP_EXTERNAL_IDENTIFIER IS NOT NULL THEN
		v_ESP_ID := ID.ID_FOR_ESP_EXTERNAL_IDENTIFIER(p_ESP_EXTERNAL_IDENTIFIER);
		IF v_ESP_ID <= 0 THEN
	    	ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'ESP NOT DEFINED FOR ' || p_ESP_EXTERNAL_IDENTIFIER);
		END IF;
	END IF;

	v_SERVICE_LOCATION_ID := CS.GET_SERVICE_LOCATION_ID(v_ACCOUNT_ID, v_BEGIN_DATE);
	CS.GET_ACCOUNT_SERVICE_ID(v_ACCOUNT_ID, v_SERVICE_LOCATION_ID, v_METER_ID, v_AGGREGATE_ID, v_ACCOUNT_SERVICE_ID);
	IF p_ESP_EXTERNAL_IDENTIFIER IS NULL THEN
		CS.GET_PROVIDER_SERVICE_ID(v_ACCOUNT_ID, v_AGGREGATE_ID, TRUNC(v_BEGIN_DATE), v_PROVIDER_SERVICE_ID);
	ELSE
		CS.GET_ESP_PROVIDER_SERVICE_ID(v_ACCOUNT_ID, v_ESP_ID, TRUNC(v_BEGIN_DATE), v_PROVIDER_SERVICE_ID);
	END IF;

	v_METER_TYPE := CS.GET_METER_TYPE(v_ACCOUNT_ID, v_METER_ID);

	PUT_SERVICE_CONSUMPTION(GA.DEFAULT_MODEL, v_SCENARIO_ID, v_ACCOUNT_SERVICE_ID, v_PROVIDER_SERVICE_ID, v_BEGIN_DATE, v_END_DATE, v_METER_TYPE, v_BILLED_USAGE, NULL, v_METERED_USAGE, NULL, v_METERS_READ, GA.BILL_CONSUMPTION, GA.ACTUAL_CONSUMPTION, CONSTANTS.NOT_ASSIGNED, LOW_DATE, CONSTANTS.ANYTIME_TOU_TEMPLATE_ID, CONSTANTS.ANYTIME_PERIOD_ID, NULL, v_CONSUMPTION_ID);


END IMPORT_ACCOUNT_BILLED_USAGE;
----------------------------------------------------------------------------------------------------
PROCEDURE IMPORT_ACCOUNT_BILLED_USAGE
	(
	p_ACCOUNT_EXTERNAL_IDENTIFIER IN VARCHAR,
	p_BEGIN_DATE IN VARCHAR,
	p_END_DATE IN VARCHAR,
	p_DATE_FORMAT IN VARCHAR,
	p_BILLED_USAGE IN VARCHAR,
	p_METERS_READ IN VARCHAR,
	p_METERED_USAGE IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	IMPORT_ACCOUNT_BILLED_USAGE(p_ACCOUNT_EXTERNAL_IDENTIFIER, NULL, p_BEGIN_DATE,
		p_END_DATE, p_DATE_FORMAT, p_BILLED_USAGE, p_METERS_READ, p_METERED_USAGE, p_STATUS);

END IMPORT_ACCOUNT_BILLED_USAGE;
----------------------------------------------------------------------------------------------------
PROCEDURE IMPORT_ACCOUNT_BILLED_USAGE
	(
	p_ACCOUNT_EXTERNAL_IDENTIFIER IN VARCHAR,
	p_BEGIN_DATE IN VARCHAR,
	p_END_DATE IN VARCHAR,
	p_DATE_FORMAT IN VARCHAR,
	p_BILLED_USAGE IN VARCHAR,
	p_METERS_READ IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	IMPORT_ACCOUNT_BILLED_USAGE(p_ACCOUNT_EXTERNAL_IDENTIFIER, NULL, p_BEGIN_DATE,
		p_END_DATE, p_DATE_FORMAT, p_BILLED_USAGE, p_METERS_READ, NULL, p_STATUS);

END IMPORT_ACCOUNT_BILLED_USAGE;
----------------------------------------------------------------------------------------------------
PROCEDURE IMPORT_AGGREGATE_BILLED_USAGE
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_BEGIN_DATE IN VARCHAR,
	p_END_DATE IN VARCHAR,
	p_DATE_FORMAT IN VARCHAR,
	p_BILLED_USAGE IN VARCHAR,
	p_METERS_READ IN VARCHAR,
	p_METERED_USAGE IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_AGGREGATE_ID NUMBER;
v_SERVICE_LOCATION_ID NUMBER;
v_METER_ID NUMBER := 0;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_BILLED_USAGE NUMBER;
v_METERS_READ NUMBER;
v_METERED_USAGE NUMBER;
v_ACCOUNT_SERVICE_ID NUMBER;
v_PROVIDER_SERVICE_ID NUMBER;
v_METER_TYPE CHAR(1);
v_CONSUMPTION_ID NUMBER(9);
v_SCENARIO_ID NUMBER(9) := GA.BASE_SCENARIO_ID;

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	v_BEGIN_DATE := TRUNC(TO_DATE(p_BEGIN_DATE, p_DATE_FORMAT));
	v_END_DATE := TRUNC(TO_DATE(p_END_DATE, p_DATE_FORMAT));
	v_BILLED_USAGE := TO_NUMBER(p_BILLED_USAGE);
	v_METERS_READ := TO_NUMBER(p_METERS_READ);
	v_METERED_USAGE := TO_NUMBER(p_METERED_USAGE);

	v_SERVICE_LOCATION_ID := CS.GET_SERVICE_LOCATION_ID(p_ACCOUNT_ID, v_BEGIN_DATE);
	IF v_SERVICE_LOCATION_ID <= 0 THEN
	    ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'SERVICE LOCATION NOT DEFINED FOR ACCOUNT' || p_ACCOUNT_ID);
	END IF;

	v_AGGREGATE_ID := GET_AGGREGATE_ID(p_ACCOUNT_ID, p_ESP_ID, v_BEGIN_DATE, p_POOL_ID);
	IF v_AGGREGATE_ID <= 0 THEN
	    ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'AGGREGATE ESP NOT DEFINED FOR ESP' || p_ESP_ID);
	END IF;

	CS.GET_ACCOUNT_SERVICE_ID(p_ACCOUNT_ID, v_SERVICE_LOCATION_ID, v_METER_ID, v_AGGREGATE_ID, v_ACCOUNT_SERVICE_ID);
	CS.GET_PROVIDER_SERVICE_ID(p_ACCOUNT_ID, v_AGGREGATE_ID, v_BEGIN_DATE, v_PROVIDER_SERVICE_ID);
	v_METER_TYPE := CS.GET_METER_TYPE(p_ACCOUNT_ID, v_METER_ID);

	PUT_SERVICE_CONSUMPTION(GA.DEFAULT_MODEL, v_SCENARIO_ID, v_ACCOUNT_SERVICE_ID, v_PROVIDER_SERVICE_ID, v_BEGIN_DATE, v_END_DATE, v_METER_TYPE, v_BILLED_USAGE, NULL, v_METERED_USAGE, NULL, v_METERS_READ, GA.BILL_CONSUMPTION, GA.ACTUAL_CONSUMPTION, CONSTANTS.NOT_ASSIGNED, LOW_DATE, CONSTANTS.ANYTIME_TOU_TEMPLATE_ID, CONSTANTS.ANYTIME_PERIOD_ID, NULL, v_CONSUMPTION_ID);


END IMPORT_AGGREGATE_BILLED_USAGE;
----------------------------------------------------------------------------------------------------
PROCEDURE IMPORT_AGGREGATE_BILLED_USAGE
	(
	p_ACCOUNT_EXTERNAL_IDENTIFIER IN VARCHAR,
	p_ESP_IDENTIFIER IN VARCHAR,
	p_ESP_IDENTIFIER_TYPE IN VARCHAR,
	p_BEGIN_DATE IN VARCHAR,
	p_END_DATE IN VARCHAR,
	p_DATE_FORMAT IN VARCHAR,
	p_BILLED_USAGE IN VARCHAR,
	p_METERS_READ IN VARCHAR,
	p_METERED_USAGE IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_ESP_ID NUMBER;
v_ACCOUNT_ID NUMBER;
v_ESP_IDENTIFIER_TYPE CHAR(1) := UPPER(SUBSTR(p_ESP_IDENTIFIER_TYPE,1,1));

BEGIN

   ID.ID_FOR_ACCOUNT_EXTERNAL_IDENT(p_ACCOUNT_EXTERNAL_IDENTIFIER, FALSE, v_ACCOUNT_ID);

	IF v_ACCOUNT_ID <= 0 THEN
	    ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'ACCOUNT NOT DEFINED FOR ' || p_ACCOUNT_EXTERNAL_IDENTIFIER);
	END IF;

	IF v_ESP_IDENTIFIER_TYPE IN ('Y','D') THEN
		v_ESP_ID := ID.ID_FOR_ESP_DUNS_NUMBER(p_ESP_IDENTIFIER);
	ELSIF v_ESP_IDENTIFIER_TYPE = 'X' THEN
		v_ESP_ID := ID.ID_FOR_ESP_EXTERNAL_IDENTIFIER(p_ESP_IDENTIFIER);
	ELSE
		ID.ID_FOR_ESP(p_ESP_IDENTIFIER, FALSE, v_ESP_ID);
	END IF;

	IF v_ESP_ID <= 0 THEN
	    ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'ESP NOT DEFINED FOR ' || p_ESP_IDENTIFIER);
	END IF;

	IMPORT_AGGREGATE_BILLED_USAGE(v_ACCOUNT_ID, v_ESP_ID, CONSTANTS.NOT_ASSIGNED, p_BEGIN_DATE, p_END_DATE,
		p_DATE_FORMAT, p_BILLED_USAGE, p_METERS_READ, p_METERED_USAGE, p_STATUS);


END IMPORT_AGGREGATE_BILLED_USAGE;
----------------------------------------------------------------------------------------------------
PROCEDURE IMPORT_AGGREGATE_BILLED_USAGE
	(
	p_ACCOUNT_EXTERNAL_IDENTIFIER IN VARCHAR,
	p_ESP_NAME IN VARCHAR,
	p_BEGIN_DATE IN VARCHAR,
	p_END_DATE IN VARCHAR,
	p_DATE_FORMAT IN VARCHAR,
	p_BILLED_USAGE IN VARCHAR,
	p_METERS_READ IN VARCHAR,
	p_METERED_USAGE IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

BEGIN

	IMPORT_AGGREGATE_BILLED_USAGE(p_ACCOUNT_EXTERNAL_IDENTIFIER, p_ESP_NAME, 'N', p_BEGIN_DATE,
		p_END_DATE, p_DATE_FORMAT, p_BILLED_USAGE, p_METERS_READ, p_METERED_USAGE, p_STATUS);

END IMPORT_AGGREGATE_BILLED_USAGE;
----------------------------------------------------------------------------------------------------
PROCEDURE IMPORT_PROVIDER_CONSUMPTION
	(
	p_ACCOUNT_EXTERNAL_IDENTIFIER IN VARCHAR,
	p_EDC_EXTERNAL_IDENTIFIER IN VARCHAR,
	p_ESP_EXTERNAL_IDENTIFIER IN VARCHAR,
	p_PSE_EXTERNAL_IDENTIFIER IN VARCHAR,
	p_POOL_EXTERNAL_IDENTIFIER IN VARCHAR,
	p_BEGIN_DATE IN VARCHAR,
	p_END_DATE IN VARCHAR,
	p_DATE_FORMAT IN VARCHAR,
	p_BILLED_USAGE IN VARCHAR,
	p_METERS_READ IN VARCHAR,
	p_METERED_USAGE IN VARCHAR,
	p_TRACE_ON IN NUMBER,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

v_ACCOUNT_ID NUMBER;
v_EDC_ID NUMBER;
v_ESP_ID NUMBER;
v_PSE_ID NUMBER;
v_POOL_ID NUMBER := CONSTANTS.NOT_ASSIGNED;
v_AGGREGATE_ID NUMBER;
v_SERVICE_LOCATION_ID NUMBER;
v_METER_ID NUMBER := 0;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_BILLED_USAGE NUMBER;
v_METERS_READ NUMBER;
v_METERED_USAGE NUMBER;
v_ACCOUNT_SERVICE_ID NUMBER;
v_PROVIDER_SERVICE_ID NUMBER;
v_METER_TYPE CHAR(1);
v_CONSUMPTION_ID NUMBER(9);
v_IS_AGGREGATE_ACCOUNT NUMBER(1);
v_SCENARIO_ID NUMBER(9) := GA.BASE_SCENARIO_ID;

BEGIN
    p_STATUS := 0;
	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('IMPORT_PROVIDER_CONSUMPTION');
		LOGS.LOG_DEBUG('ACCOUNT_EXTERNAL_IDENTIFIER=' || p_ACCOUNT_EXTERNAL_IDENTIFIER);
		LOGS.LOG_DEBUG('EDC_EXTERNAL_IDENTIFIER=' || p_EDC_EXTERNAL_IDENTIFIER);
		LOGS.LOG_DEBUG('ESP_EXTERNAL_IDENTIFIER=' || p_ESP_EXTERNAL_IDENTIFIER);
		LOGS.LOG_DEBUG('PSE_EXTERNAL_IDENTIFIER=' || p_PSE_EXTERNAL_IDENTIFIER);
		LOGS.LOG_DEBUG('BEGIN_DATE=' || p_BEGIN_DATE);
		LOGS.LOG_DEBUG('END_DATE=' || p_BEGIN_DATE);
		LOGS.LOG_DEBUG('DATE_FORMAT=' || p_DATE_FORMAT);
		LOGS.LOG_DEBUG('BILLED_USAGE=' || p_BILLED_USAGE);
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK';
	v_BEGIN_DATE := TRUNC(TO_DATE(p_BEGIN_DATE, p_DATE_FORMAT));
	v_END_DATE := TRUNC(TO_DATE(p_END_DATE, p_DATE_FORMAT));
	v_BILLED_USAGE := TO_NUMBER(p_BILLED_USAGE);
	v_METERS_READ := TO_NUMBER(p_METERS_READ);
	v_METERED_USAGE := TO_NUMBER(p_METERED_USAGE);

	ID.ID_FOR_ACCOUNT_EXTERNAL_IDENT(p_ACCOUNT_EXTERNAL_IDENTIFIER, FALSE, v_ACCOUNT_ID);
	IF v_ACCOUNT_ID <= 0 THEN
	    ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'ACCOUNT NOT DEFINED FOR ' || p_ACCOUNT_EXTERNAL_IDENTIFIER);
	END IF;

	v_EDC_ID := ID.ID_FOR_EDC_EXTERNAL_IDENTIFIER(p_EDC_EXTERNAL_IDENTIFIER);
	IF v_EDC_ID <= 0 THEN
		ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'EDC NOT DEFINED FOR ' || p_EDC_EXTERNAL_IDENTIFIER);
	END IF;

	v_ESP_ID := ID.ID_FOR_ESP_EXTERNAL_IDENTIFIER(p_ESP_EXTERNAL_IDENTIFIER);
	IF v_ESP_ID <= 0 THEN
	    ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'ESP NOT DEFINED FOR ' || p_ESP_EXTERNAL_IDENTIFIER);
	END IF;

	v_PSE_ID := ID.ID_FOR_PSE_EXTERNAL_IDENTIFIER(p_PSE_EXTERNAL_IDENTIFIER);
	IF v_PSE_ID <= 0 THEN
	    ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'PSE NOT DEFINED FOR ' || p_PSE_EXTERNAL_IDENTIFIER);
	END IF;

	-- ABX --
	v_POOL_ID := ID.ID_FOR_POOL_EXTERNAL_IDENT(p_POOL_EXTERNAL_IDENTIFIER);
	IF v_POOL_ID <= 0 THEN
	    ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'POOL NOT DEFINED FOR ' || p_POOL_EXTERNAL_IDENTIFIER);
	END IF;

	v_SERVICE_LOCATION_ID := CS.GET_SERVICE_LOCATION_ID(v_ACCOUNT_ID, v_BEGIN_DATE);
	IF v_SERVICE_LOCATION_ID <= 0 THEN
	    ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'SERVICE LOCATION NOT DEFINED FOR ' || p_ACCOUNT_EXTERNAL_IDENTIFIER);
	END IF;

	-- SKIP AGGREGATE_ID STUFF IF ACCOUNT ISN'T AGGREGATE --
	SELECT IS_AGGREGATE_ACCOUNT
	INTO v_IS_AGGREGATE_ACCOUNT
	FROM ACCOUNT
	WHERE ACCOUNT_ID = v_ACCOUNT_ID;

	IF v_IS_AGGREGATE_ACCOUNT = 0 THEN
	    v_AGGREGATE_ID := 0;
	ELSE
    	v_AGGREGATE_ID := GET_AGGREGATE_ID(v_ACCOUNT_ID, v_ESP_ID, v_BEGIN_DATE, v_END_DATE, v_POOL_ID);
    	IF v_AGGREGATE_ID = CONSTANTS.NOT_ASSIGNED THEN
    		IF GA.ENABLE_AGG_POST_ESP_ASSIGNMENT THEN
    			AGG_POST_ESP_ASSIGNMENT(GA.DEFAULT_MODEL,
				v_ACCOUNT_ID, v_SERVICE_LOCATION_ID, v_EDC_ID, v_ESP_ID, v_PSE_ID, v_POOL_ID,
				v_BEGIN_DATE, v_END_DATE, v_AGGREGATE_ID);
    		ELSE
    	    	ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'AGGREGATE ESP NOT DEFINED FOR ' || p_ESP_EXTERNAL_IDENTIFIER);
    		END IF;
    	END IF;
	END IF;

	CS.GET_ACCOUNT_SERVICE_ID(v_ACCOUNT_ID, v_SERVICE_LOCATION_ID, v_METER_ID, v_AGGREGATE_ID, v_ACCOUNT_SERVICE_ID);
	CS.GET_PROVIDER_SERVICE_ID(v_EDC_ID, v_ESP_ID, v_PSE_ID, v_PROVIDER_SERVICE_ID);
	v_METER_TYPE := CS.GET_METER_TYPE(v_ACCOUNT_ID, v_METER_ID);

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('ACCOUNT_SERVICE_ID=' || TO_CHAR(v_ACCOUNT_SERVICE_ID) || ', PROVIDER_SERVICE_ID=' || TO_CHAR(v_PROVIDER_SERVICE_ID));
	END IF;

	PUT_SERVICE_CONSUMPTION(GA.DEFAULT_MODEL, v_SCENARIO_ID, v_ACCOUNT_SERVICE_ID,
		v_PROVIDER_SERVICE_ID, v_BEGIN_DATE, v_END_DATE, v_METER_TYPE, v_BILLED_USAGE,
		NULL, v_METERED_USAGE, NULL, v_METERS_READ, GA.BILL_CONSUMPTION,
		GA.ACTUAL_CONSUMPTION, CONSTANTS.NOT_ASSIGNED, LOW_DATE, CONSTANTS.ANYTIME_TOU_TEMPLATE_ID,
        CONSTANTS.ANYTIME_PERIOD_ID, v_POOL_ID, NULL, v_CONSUMPTION_ID);


END IMPORT_PROVIDER_CONSUMPTION;
----------------------------------------------------------------------------------------------------
PROCEDURE IMPORT_SERVICE_CONSUMPTION
	(
	p_MODEL_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_BEGIN_DATE DATE,
	p_END_DATE IN DATE,
	p_BILL_CODE IN CHAR,
	p_CONSUMPTION_CODE IN CHAR,
	p_BILLED_USAGE IN NUMBER,
	p_BILLED_DEMAND IN NUMBER,
	p_METERED_USAGE IN NUMBER,
	p_METERED_DEMAND IN NUMBER,
	p_METERS_READ IN NUMBER,
	p_METER_READING IN VARCHAR,
	p_RECEIVED_DATE IN DATE,
	p_IGNORE_CONSUMPTION IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CONSUMPTION_ID OUT NUMBER
	) AS

v_SERVICE_LOCATION_ID NUMBER(9);
v_ACCOUNT_SERVICE_ID NUMBER(9);
v_PROVIDER_SERVICE_ID NUMBER(9);
v_SERVICE_DELIVERY_ID NUMBER(9);
v_SERVICE_ID NUMBER(9);
v_SERVICE_CONSUMPTION SERVICE_CONSUMPTION%ROWTYPE;
v_SCENARIO_ID NUMBER(9) := GA.BASE_SCENARIO_ID;

--THIS PROCEDURE HANDLES NON-AGGREGATE ACCOUNTS ONLY.
--IT ALWAYS PASSES A ZERO FOR AGGREGATE ID.
--SEE IMPORT_PROVIDER_CONSUMPTION FOR AN AGGREGATE OPTION.
BEGIN

	p_STATUS := GA.SUCCESS;

	v_SERVICE_LOCATION_ID := CS.GET_SERVICE_LOCATION_ID(p_ACCOUNT_ID, p_BEGIN_DATE);
	CS.GET_ACCOUNT_SERVICE_ID(p_ACCOUNT_ID,v_SERVICE_LOCATION_ID,p_METER_ID,0,v_ACCOUNT_SERVICE_ID);
	CS.GET_PROVIDER_SERVICE_ID(p_ACCOUNT_ID,0,p_BEGIN_DATE,v_PROVIDER_SERVICE_ID);
	CS.GET_SERVICE_DELIVERY_ID(v_ACCOUNT_SERVICE_ID, v_PROVIDER_SERVICE_ID, p_BEGIN_DATE, v_SERVICE_DELIVERY_ID);
	v_SERVICE_ID := GET_SERVICE_ID(p_MODEL_ID, v_SCENARIO_ID, v_ACCOUNT_SERVICE_ID, v_PROVIDER_SERVICE_ID, v_SERVICE_DELIVERY_ID, p_RECEIVED_DATE);

	v_SERVICE_CONSUMPTION.SERVICE_ID := v_SERVICE_ID;
	v_SERVICE_CONSUMPTION.BEGIN_DATE := p_BEGIN_DATE;
	v_SERVICE_CONSUMPTION.END_DATE := p_END_DATE;
	v_SERVICE_CONSUMPTION.BILL_CODE := p_BILL_CODE;
	v_SERVICE_CONSUMPTION.CONSUMPTION_CODE := p_CONSUMPTION_CODE;
	v_SERVICE_CONSUMPTION.RECEIVED_DATE := p_RECEIVED_DATE;
	v_SERVICE_CONSUMPTION.TEMPLATE_ID := CONSTANTS.ANYTIME_TOU_TEMPLATE_ID;
	v_SERVICE_CONSUMPTION.PERIOD_ID := CONSTANTS.ANYTIME_PERIOD_ID;
	v_SERVICE_CONSUMPTION.METER_TYPE := CS.GET_METER_TYPE(p_ACCOUNT_ID, p_METER_ID);
	v_SERVICE_CONSUMPTION.METER_READING := p_METER_READING;
	v_SERVICE_CONSUMPTION.BILLED_USAGE := p_BILLED_USAGE;
	v_SERVICE_CONSUMPTION.BILLED_DEMAND := p_BILLED_DEMAND;
	v_SERVICE_CONSUMPTION.METERED_USAGE := p_METERED_USAGE;
	v_SERVICE_CONSUMPTION.METERED_DEMAND := p_METERED_DEMAND;
	v_SERVICE_CONSUMPTION.METERS_READ := p_METERS_READ;
	v_SERVICE_CONSUMPTION.CONVERSION_FACTOR := CONSTANTS.NOT_ASSIGNED;
	v_SERVICE_CONSUMPTION.IGNORE_CONSUMPTION := p_IGNORE_CONSUMPTION;
	v_SERVICE_CONSUMPTION.BILL_PROCESSED_DATE := NULL;
	v_SERVICE_CONSUMPTION.ENTRY_DATE := SYSDATE;

	PUT_SERVICE_CONSUMPTION(v_SERVICE_CONSUMPTION, p_CONSUMPTION_ID);


END IMPORT_SERVICE_CONSUMPTION;
----------------------------------------------------------------------------------------------------
PROCEDURE IMPORT_SERVICE_CONSUMP_READ
	(
	p_MODEL_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_READ_BEGIN_DATE IN DATE,
	p_READ_END_DATE IN DATE,
    p_BILL_CODE IN CHAR,
	p_CONSUMPTION_CODE IN CHAR,
	p_BILLED_USAGE IN NUMBER,
	p_BILLED_DEMAND IN NUMBER,
	p_METERED_USAGE IN NUMBER,
	p_METERED_DEMAND IN NUMBER,
	p_METERS_READ IN NUMBER,
	p_METER_READING IN VARCHAR,
	p_RECEIVED_DATE IN DATE,
	p_IGNORE_CONSUMPTION IN NUMBER,
	p_STATUS OUT NUMBER,
	p_CONSUMPTION_ID OUT NUMBER
	) AS

v_SERVICE_LOCATION_ID NUMBER(9);
v_ACCOUNT_SERVICE_ID NUMBER(9);
v_PROVIDER_SERVICE_ID NUMBER(9);
v_SERVICE_DELIVERY_ID NUMBER(9);
v_SERVICE_ID NUMBER(9);
v_SERVICE_CONSUMPTION SERVICE_CONSUMPTION%ROWTYPE;
v_SCENARIO_ID NUMBER(9) := GA.BASE_SCENARIO_ID;

BEGIN

	p_STATUS := GA.SUCCESS;

	v_SERVICE_LOCATION_ID := CS.GET_SERVICE_LOCATION_ID(p_ACCOUNT_ID, p_BEGIN_DATE);
	CS.GET_ACCOUNT_SERVICE_ID(p_ACCOUNT_ID,v_SERVICE_LOCATION_ID,p_METER_ID,0,v_ACCOUNT_SERVICE_ID);
	CS.GET_PROVIDER_SERVICE_ID(p_ACCOUNT_ID,0,p_BEGIN_DATE,v_PROVIDER_SERVICE_ID);
	CS.GET_SERVICE_DELIVERY_ID(v_ACCOUNT_SERVICE_ID, v_PROVIDER_SERVICE_ID, p_BEGIN_DATE, v_SERVICE_DELIVERY_ID);
	v_SERVICE_ID := GET_SERVICE_ID(p_MODEL_ID, v_SCENARIO_ID, v_ACCOUNT_SERVICE_ID, v_PROVIDER_SERVICE_ID, v_SERVICE_DELIVERY_ID, p_RECEIVED_DATE);

	v_SERVICE_CONSUMPTION.SERVICE_ID := v_SERVICE_ID;
	v_SERVICE_CONSUMPTION.BEGIN_DATE := p_BEGIN_DATE;
	v_SERVICE_CONSUMPTION.END_DATE := p_END_DATE;
	v_SERVICE_CONSUMPTION.BILL_CODE := p_BILL_CODE;
	v_SERVICE_CONSUMPTION.CONSUMPTION_CODE := p_CONSUMPTION_CODE;
	v_SERVICE_CONSUMPTION.RECEIVED_DATE := p_RECEIVED_DATE;
	v_SERVICE_CONSUMPTION.TEMPLATE_ID := CONSTANTS.ANYTIME_TOU_TEMPLATE_ID;
	v_SERVICE_CONSUMPTION.PERIOD_ID := CONSTANTS.ANYTIME_PERIOD_ID;
	v_SERVICE_CONSUMPTION.METER_TYPE := CS.GET_METER_TYPE(p_ACCOUNT_ID, p_METER_ID);
	v_SERVICE_CONSUMPTION.METER_READING := p_METER_READING;
	v_SERVICE_CONSUMPTION.BILLED_USAGE := p_BILLED_USAGE;
	v_SERVICE_CONSUMPTION.BILLED_DEMAND := p_BILLED_DEMAND;
	v_SERVICE_CONSUMPTION.METERED_USAGE := p_METERED_USAGE;
	v_SERVICE_CONSUMPTION.METERED_DEMAND := p_METERED_DEMAND;
	v_SERVICE_CONSUMPTION.METERS_READ := p_METERS_READ;
	v_SERVICE_CONSUMPTION.CONVERSION_FACTOR := CONSTANTS.NOT_ASSIGNED;
	v_SERVICE_CONSUMPTION.IGNORE_CONSUMPTION := p_IGNORE_CONSUMPTION;
	v_SERVICE_CONSUMPTION.READ_BEGIN_DATE := p_READ_BEGIN_DATE;
	v_SERVICE_CONSUMPTION.READ_END_DATE := p_READ_END_DATE;
	v_SERVICE_CONSUMPTION.BILL_PROCESSED_DATE := NULL;
	v_SERVICE_CONSUMPTION.ENTRY_DATE := SYSDATE;

	PUT_SERVICE_CONSUMPTION(v_SERVICE_CONSUMPTION, p_CONSUMPTION_ID);


END IMPORT_SERVICE_CONSUMP_READ;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_ACCOUNT_INTERVAL_USAGE
	(
	p_MODEL_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_USAGE_DATE IN DATE,
	p_TIME_ZONE IN VARCHAR,
	p_USAGE_VALUES IN GA.NUMBER_TABLE
	) AS

v_TIME_ZONE VARCHAR(3);
v_CUT_DATE DATE;
v_INTERVAL NUMBER := 3600;
v_DST_SKIP BOOLEAN := FALSE;
v_DST_REPEAT BOOLEAN := FALSE;
v_AS_OF_DATE DATE := SYSDATE;
v_SERVICE_STATE SERVICE_STATE%ROWTYPE;
v_INDEX BINARY_INTEGER;
v_USAGE_DATE GA.DATE_TABLE;
v_USAGE_VAL GA.NUMBER_TABLE;
v_SCENARIO_ID NUMBER(9) := GA.BASE_SCENARIO_ID;
BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	g_MODEL_ID := p_MODEL_ID;
	v_TIME_ZONE := TIME_ZONE_FOR_DAY(p_USAGE_DATE, p_TIME_ZONE);
	v_CUT_DATE := NEW_TIME(p_USAGE_DATE, v_TIME_ZONE, CUT_TIME_ZONE);

	v_SERVICE_STATE := GET_SERVICE_STATE(v_SCENARIO_ID, p_ACCOUNT_ID, CONSTANTS.NOT_ASSIGNED, CONSTANTS.NOT_ASSIGNED, CONSTANTS.NOT_ASSIGNED, TRUNC(p_USAGE_DATE), v_AS_OF_DATE, g_UNKNOWN);

	IF v_SERVICE_STATE.SERVICE_ID <= 0 THEN
		ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'ACCOUNT SERVICE NOT DEFINED FOR ' || TO_CHAR(p_ACCOUNT_ID));
	END IF;

	IF TRUNC(DST_SPRING_AHEAD_DATE(v_CUT_DATE)) = TRUNC(p_USAGE_DATE) AND p_USAGE_VALUES.COUNT = 24 THEN
		v_DST_SKIP := TRUE;
	ELSIF TRUNC(DST_FALL_BACK_DATE(v_CUT_DATE)) = TRUNC(p_USAGE_DATE) AND p_USAGE_VALUES.COUNT = 24 THEN
		v_DST_REPEAT := TRUE;
	END IF;

	FOR v_INDEX IN p_USAGE_VALUES.FIRST..p_USAGE_VALUES.LAST LOOP
		IF p_USAGE_VALUES.EXISTS(v_INDEX) THEN
			IF NOT (v_INDEX = 2 AND v_DST_SKIP) THEN
				v_USAGE_VAL(v_INDEX) := p_USAGE_VALUES(v_INDEX);
				v_USAGE_DATE(v_INDEX) := v_CUT_DATE;
				v_CUT_DATE := ADD_SECONDS_TO_DATE(v_CUT_DATE, v_INTERVAL);
			END IF;
			IF v_INDEX = 2 AND v_DST_REPEAT THEN
				v_USAGE_VAL(v_INDEX) := p_USAGE_VALUES(v_INDEX);
				v_USAGE_DATE(v_INDEX) := v_CUT_DATE;
				v_CUT_DATE := ADD_SECONDS_TO_DATE(v_CUT_DATE, v_INTERVAL);
			END IF;
		END IF;
	END LOOP;

END PUT_ACCOUNT_INTERVAL_USAGE;
----------------------------------------------------------------------------------------------------
PROCEDURE ACCEPT_BILLED_USAGE_RECORD
	(
	p_DATE_FORMAT IN VARCHAR,
	p_USE_EXTERNAL_IDENTIFIER IN NUMBER,
	p_LINE IN VARCHAR2,
	p_DELIMITER IN VARCHAR,
	p_SUCCESS IN OUT BOOLEAN
	) AS

--FILE FORMAT:
--<ACCOUNT_NAME/IDENT>;<METER_NAME/IDENT>;<ESP_NAME/IDENT>;
--<BEGIN_DATE>;<END_DATE>;<BILLED_USAGE>;<METERS_READ>;
--<METERED_USAGE>;<SETTLEMENT_TYPE_NAME>

v_ACCOUNT_NAME ACCOUNT.ACCOUNT_NAME%TYPE;
v_METER_NAME METER.METER_NAME%TYPE;
v_ESP_NAME ENERGY_SERVICE_PROVIDER.ESP_NAME%TYPE;
v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_BILLED_USAGE NUMBER;
v_METERS_READ NUMBER;
v_METERED_USAGE NUMBER;
v_RECORD PARSE_UTIL.STRING_TABLE;
v_ACCOUNT_ID NUMBER;
v_SERVICE_LOCATION_ID NUMBER;
v_METER_ID NUMBER;
v_AGGREGATE_ID NUMBER;
v_ACCOUNT_MODEL_OPTION CHAR(1);
v_ESP_ID NUMBER;
v_ACCOUNT_SERVICE_ID NUMBER;
v_PROVIDER_SERVICE_ID NUMBER;
v_METER_TYPE CHAR(1);
v_CONSUMPTION_ID NUMBER(9);
v_IDENT_TYPE CHAR(1);
v_CALC_ON_IMPORT CHAR(1);
v_YEARS_TO_APPLY NUMBER(1);
v_SEASONAL_USAGE_FACTOR CHAR(1);
v_ESP_OF_RECORD NUMBER;
v_CALENDAR_ID NUMBER(9);
v_SCENARIO_ID NUMBER(9);

BEGIN
	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	SELECT DECODE(p_USE_EXTERNAL_IDENTIFIER, 1, 'X', 'N') INTO v_IDENT_TYPE FROM DUAL;

	--Get system dictionary keys to determine if/how to calculate and apply usage factors
	v_CALC_ON_IMPORT := SUBSTR(NVL(MODEL_VALUE_AT_KEY(0,'Usage Import','Usage Factors','Calc on Import',0),'N'),1,1);--msg 08/08/2003
	v_SEASONAL_USAGE_FACTOR := SUBSTR(NVL(MODEL_VALUE_AT_KEY(0,'Usage Import','Usage Factors','Seasonal',0),'N'),1,1);--msg 08/08/2003
	IF v_SEASONAL_USAGE_FACTOR = 'Y' THEN
		v_YEARS_TO_APPLY := TO_NUMBER(SUBSTR(NVL(MODEL_VALUE_AT_KEY(0,'Usage Import','Usage Factors','Years to apply',0),'1'),1,1));--msg 08/08/2003
	END IF;

	PARSE_UTIL.TOKENS_FROM_STRING(p_LINE, p_DELIMITER, v_RECORD);
	v_ACCOUNT_NAME := LTRIM(RTRIM(v_RECORD(1)));
	v_METER_NAME := LTRIM(RTRIM(v_RECORD(2)));
	v_ESP_NAME := LTRIM(RTRIM(v_RECORD(3)));

	v_BEGIN_DATE := DATA_IMPORT.IMPORT_DATE(v_RECORD(4),
										  p_DATE_FORMAT,
										  'Begin Date',
										  p_SUCCESS);

	v_END_DATE := DATA_IMPORT.IMPORT_DATE(v_RECORD(5),
										  p_DATE_FORMAT,
										  'End Date',
										  p_SUCCESS);

	v_BILLED_USAGE := 0;
	IF v_RECORD.EXISTS(6) AND TRIM(v_RECORD(6)) IS NOT NULL THEN
		v_BILLED_USAGE := DATA_IMPORT.IMPORT_NUMBER(TRIM(v_RECORD(6)),
												  'Billed Usage: ',
												  p_SUCCESS);
	END IF;

	v_METERS_READ := 1;
	IF v_RECORD.EXISTS(7) AND TRIM(v_RECORD(7)) IS NOT NULL THEN
		v_METERS_READ := DATA_IMPORT.IMPORT_NUMBER(TRIM(v_RECORD(7)),
												  'Meters Read: ',
												  p_SUCCESS);
	END IF;

	v_METERED_USAGE := v_BILLED_USAGE;
	IF v_RECORD.EXISTS(8) AND TRIM(v_RECORD(8)) IS NOT NULL THEN
		v_METERED_USAGE := DATA_IMPORT.IMPORT_NUMBER(TRIM(v_RECORD(8)),
												  'Metered Usage: ',
												  p_SUCCESS);
	END IF;

	v_SCENARIO_ID := GA.BASE_SCENARIO_ID;
	IF v_RECORD.EXISTS(9) AND TRIM(v_RECORD(9)) IS NOT NULL THEN
		v_SCENARIO_ID := SCENARIO_FOR_SETTLEMENT_TYPE(TRIM(v_RECORD(9)));
	END IF;

	v_ACCOUNT_ID := CS.GET_ACCOUNT_ID(v_ACCOUNT_NAME, v_IDENT_TYPE);

	IF v_ACCOUNT_ID <= 0 THEN
	  DATA_IMPORT.LOG_IMPORT_ERROR('Account not found: ' || v_ACCOUNT_NAME,
		  p_SUCCESS);
	ELSIF p_USE_EXTERNAL_IDENTIFIER = 1 THEN
		SELECT ACCOUNT_NAME INTO v_ACCOUNT_NAME
		FROM ACCOUNT
		WHERE ACCOUNT_ID = v_ACCOUNT_ID;
	END IF;

	v_ACCOUNT_MODEL_OPTION := GET_ACCOUNT_MODEL_OPTION(v_ACCOUNT_ID);
	v_AGGREGATE_ID := 0;

	IF v_ACCOUNT_MODEL_OPTION = 'M' THEN
		v_METER_ID := GET_METER_ID(v_METER_NAME, v_IDENT_TYPE);

		IF v_METER_ID <= 0 THEN
		  DATA_IMPORT.LOG_IMPORT_ERROR('Meter not found: ' || v_METER_NAME,
			  p_SUCCESS);
		ELSIF p_USE_EXTERNAL_IDENTIFIER = 1 THEN
		  SELECT METER_NAME INTO v_METER_NAME
		  FROM METER
		  WHERE METER_ID = v_METER_ID;
		END IF;

		v_SERVICE_LOCATION_ID := GET_METER_OWNER(v_METER_ID, v_END_DATE);
		v_ESP_OF_RECORD := CS.GET_ESP_OF_RECORD(v_ACCOUNT_ID,v_END_DATE);
	ELSE
		v_SERVICE_LOCATION_ID := CS.GET_SERVICE_LOCATION_ID(v_ACCOUNT_ID, v_END_DATE);
		v_METER_ID := 0;
		v_ESP_ID := CS.GET_ESP_ID(v_ESP_NAME, v_IDENT_TYPE);

		IF v_ESP_ID <= 0 THEN
			DATA_IMPORT.LOG_IMPORT_ERROR('ESP not found: ' || v_ESP_NAME,
			  p_SUCCESS);
		ELSIF p_USE_EXTERNAL_IDENTIFIER = 1 THEN
			SELECT ESP_NAME INTO v_ESP_NAME
			FROM ENERGY_SERVICE_PROVIDER
			WHERE ESP_ID = v_ESP_ID;
		END IF;

		IF IS_AGGREGATE_ACCOUNT(v_ACCOUNT_ID) THEN
		  v_AGGREGATE_ID := GET_AGGREGATE_ID(v_ACCOUNT_ID, v_ESP_ID, v_END_DATE);

		  IF v_AGGREGATE_ID <= 0 THEN
			DATA_IMPORT.LOG_IMPORT_ERROR('Aggregate not not found: '
				|| 'for the given Account (' || v_ACCOUNT_NAME || ') and ESP (' || v_ESP_NAME || ') '
				|| 'on ' || v_END_DATE,
				p_SUCCESS);
		  END IF;
		  --Get RO's esp assignment for the usage record based on erollment data
		  v_ESP_OF_RECORD := CS.GET_ESP_OF_RECORD(v_ACCOUNT_ID,v_AGGREGATE_ID,v_END_DATE);
		ELSE
		  --msg check to see if esp in file matches esp of record for same date.
		  v_ESP_OF_RECORD := CS.GET_ESP_OF_RECORD(v_ACCOUNT_ID,v_END_DATE);
		END IF;
	END IF;

	IF v_SERVICE_LOCATION_ID <= 0 AND v_ACCOUNT_ID > 0 THEN
	DATA_IMPORT.LOG_IMPORT_ERROR('Service location not found for the given Account (' || v_ACCOUNT_NAME
		|| ') on the given date: ' || v_END_DATE,
		p_SUCCESS);
	END IF;

	IF LOGS.IS_DEBUG_ENABLED THEN
	  LOGS.LOG_DEBUG(p_LINE);
	  LOGS.LOG_DEBUG(v_ACCOUNT_NAME || ',' || v_METER_NAME || ',' || UT.TRACE_DATE(v_BEGIN_DATE) || ',' || UT.TRACE_DATE(v_END_DATE) || ',' ||
		  TO_CHAR(v_ACCOUNT_ID) || ',' || TO_CHAR(v_SERVICE_LOCATION_ID) || ',' || v_ACCOUNT_MODEL_OPTION || ',' ||
		  TO_CHAR(v_METER_ID) || ',' || TO_CHAR(V_AGGREGATE_ID) || ',' || TO_CHAR(v_ESP_ID) || ',' ||
		  TO_CHAR(v_BILLED_USAGE) || ',' || TO_CHAR(v_METERS_READ) || ',' || TO_CHAR(v_METERED_USAGE));
	END IF;

	CS.GET_ACCOUNT_SERVICE_ID(v_ACCOUNT_ID, v_SERVICE_LOCATION_ID, v_METER_ID, v_AGGREGATE_ID, v_ACCOUNT_SERVICE_ID);

	--Attempt to get esp of record for sysdate if no esp assignment exists in RO for date of usage record
	--    also use the same qualifier to deterine date from which to get provider_service_id
	--    this prevents provider service id's with no esp association being created if usage imported is historical
	IF v_ESP_OF_RECORD = 0 THEN
		IF v_AGGREGATE_ID = 0 THEN
			v_ESP_OF_RECORD := CS.GET_ESP_OF_RECORD(v_ACCOUNT_ID,TRUNC(SYSDATE));
		ELSE
		  	v_ESP_OF_RECORD := CS.GET_ESP_OF_RECORD(v_ACCOUNT_ID,v_AGGREGATE_ID,TRUNC(SYSDATE));
		END IF;

		IF v_ESP_OF_RECORD = 0 AND v_ACCOUNT_ID > 0 THEN
		  	DATA_IMPORT.LOG_IMPORT_ERROR('No ESP found for Account id (object ref id) on '
						  ||TO_CHAR(SYSDATE,'MM/DD/YYYY')||' Consumption not posted',
						  p_SUCCESS);
		ELSE
			--Get calendar id for passing to usage factor calc stub
			IF v_CALC_ON_IMPORT = 'Y' THEN
				BEGIN
				  SELECT NVL(CALENDAR_ID,0) INTO v_CALENDAR_ID FROM ACCOUNT_CALENDAR
				  WHERE SYSDATE BETWEEN BEGIN_DATE AND NVL(END_DATE,HIGH_DATE)
					  AND ACCOUNT_ID = v_ACCOUNT_ID
					  AND CASE_ID = 1
					  AND CALENDAR_TYPE = 'Forecast';
				END;
			END IF;
			CS.GET_PROVIDER_SERVICE_ID(v_ACCOUNT_ID, v_AGGREGATE_ID, TRUNC(SYSDATE), v_PROVIDER_SERVICE_ID);
		END IF;
	ELSE
		--msg get calendar id for passing to usage factor calc stub
		IF v_CALC_ON_IMPORT = 'Y' THEN
			BEGIN
			  SELECT NVL(CALENDAR_ID,0) INTO v_CALENDAR_ID FROM ACCOUNT_CALENDAR
			  WHERE v_END_DATE BETWEEN BEGIN_DATE AND NVL(END_DATE,HIGH_DATE)
				  AND ACCOUNT_ID = v_ACCOUNT_ID
				  AND CASE_ID = 1
				  AND CALENDAR_TYPE = 'Forecast';
			END;
		END IF;
		CS.GET_PROVIDER_SERVICE_ID(v_ACCOUNT_ID, v_AGGREGATE_ID, TRUNC(v_END_DATE), v_PROVIDER_SERVICE_ID);
	END IF;

	IF v_ESP_OF_RECORD <> 0 THEN
		--Check to see if esp in file matches esp of record if not write warning to event log
		IF v_ESP_OF_RECORD <> v_ESP_ID THEN
		  DATA_IMPORT.LOG_IMPORT_ERROR('Usage record does '
						  || 'not match ESP of Record for Account id (object ref id) on '
						  ||TO_CHAR(SYSDATE,'MM/DD/YYYY')||' or '||TO_CHAR(v_END_DATE,'MM/DD/YYYY'),
						  p_SUCCESS);
		END IF;

		v_METER_TYPE := CS.GET_METER_TYPE(v_ACCOUNT_ID, v_METER_ID);

		--Test for dynamic calculation of usage factors.
		IF v_CALC_ON_IMPORT = 'Y' AND p_SUCCESS THEN
		  XS.UPDATE_USAGE_FACTOR(v_CALENDAR_ID,v_ACCOUNT_ID, v_METER_ID,v_BEGIN_DATE,v_END_DATE,v_BILLED_USAGE,v_SEASONAL_USAGE_FACTOR,v_YEARS_TO_APPLY);
		END IF;

		IF p_SUCCESS THEN
		  PUT_SERVICE_CONSUMPTION(GA.DEFAULT_MODEL, v_SCENARIO_ID, v_ACCOUNT_SERVICE_ID, v_PROVIDER_SERVICE_ID, v_BEGIN_DATE, v_END_DATE, v_METER_TYPE, v_BILLED_USAGE, NULL, v_METERED_USAGE, NULL, v_METERS_READ, GA.BILL_CONSUMPTION, GA.ACTUAL_CONSUMPTION, CONSTANTS.NOT_ASSIGNED, LOW_DATE, CONSTANTS.ANYTIME_TOU_TEMPLATE_ID, CONSTANTS.ANYTIME_PERIOD_ID, NULL, v_CONSUMPTION_ID);
		END IF;
	END IF;

END ACCEPT_BILLED_USAGE_RECORD;
----------------------------------------------------------------------------------------------------
PROCEDURE VALIDATE_SVC_FOR_USAGE_DATA
	(
	p_ACCOUNT_ID IN NUMBER,
	p_ACCOUNT_NAME IN VARCHAR2,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_METER_NAME IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_EDC_ID IN NUMBER,
	p_ESP_ID IN NUMBER,
	p_PSE_ID IN NUMBER,
	p_POOL_ID IN NUMBER,
	p_INTERVAL_DATA IN BOOLEAN,
    p_IS_HISTORICAL_DATA IN BOOLEAN,
	p_AGGREGATE_ID OUT NUMBER,
	p_ACCOUNT_MODEL_OPTION OUT VARCHAR2,
	p_SUCCESS IN OUT BOOLEAN,
	p_LOAD_SETTLEMENT_PROF IN OUT BOOLEAN,
	p_LOAD_USAGE_DATA IN OUT BOOLEAN
	) AS

	v_METER_TYPE	CHAR(1);
	v_IS_ACTIVE 	PLS_INTEGER;

BEGIN
	-- account ID is required
	IF p_ACCOUNT_ID IS NULL OR p_ACCOUNT_ID <= 0 THEN
		DATA_IMPORT.LOG_IMPORT_ERROR('No account specified for importing usage data', p_SUCCESS);
		p_LOAD_SETTLEMENT_PROF := FALSE;
		RETURN;
	END IF;

	v_METER_TYPE := CS.GET_METER_TYPE(p_ACCOUNT_ID, NVL(p_METER_ID, CONSTANTS.NOT_ASSIGNED));

	IF p_INTERVAL_DATA AND v_METER_TYPE <> 'I' THEN
		DATA_IMPORT.LOG_IMPORT_ERROR('Meter Type must be "Interval" for Account: '||p_ACCOUNT_NAME
				|| CASE NVL(p_METER_ID, CONSTANTS.NOT_ASSIGNED)
					WHEN CONSTANTS.NOT_ASSIGNED THEN NULL
					ELSE ', Meter:' || p_METER_NAME
					END,
			p_SUCCESS);
		p_LOAD_SETTLEMENT_PROF := FALSE; -- don't load any data if we see an error
	ELSIF NOT p_INTERVAL_DATA AND v_METER_TYPE <> 'P' THEN
		DATA_IMPORT.LOG_IMPORT_ERROR('Meter Type must be "Period" for Account: '||p_ACCOUNT_NAME
				|| CASE NVL(p_METER_ID, CONSTANTS.NOT_ASSIGNED)
					WHEN CONSTANTS.NOT_ASSIGNED THEN NULL
					ELSE ', Meter:' || p_METER_NAME
					END,
			p_SUCCESS);
		p_LOAD_SETTLEMENT_PROF := FALSE; -- don't load any data if we see an error
	END IF;

	p_LOAD_USAGE_DATA := TRUE;

	-- Get model option for specified account for some validation
	SELECT A.ACCOUNT_MODEL_OPTION INTO p_ACCOUNT_MODEL_OPTION
	FROM ACCOUNT A
	WHERE A.ACCOUNT_ID = p_ACCOUNT_ID;

	-- DETERMINE AGGREGATE_ID IF NEEDED

	IF UPPER(SUBSTR(p_ACCOUNT_MODEL_OPTION,1,2)) = 'AG' THEN -- Aggregate model
		BEGIN
			SELECT AGGREGATE_ID
			INTO p_AGGREGATE_ID
			FROM AGGREGATE_ACCOUNT_ESP
			WHERE ACCOUNT_ID = p_ACCOUNT_ID
				AND NVL(p_ESP_ID, CONSTANTS.NOT_ASSIGNED) IN (CONSTANTS.NOT_ASSIGNED, ESP_ID)
				AND NVL(p_POOL_ID, CONSTANTS.NOT_ASSIGNED) IN (CONSTANTS.NOT_ASSIGNED, POOL_ID)
				AND BEGIN_DATE <= p_BEGIN_DATE
				AND NVL(END_DATE,CONSTANTS.HIGH_DATE) >= p_END_DATE;
		EXCEPTION
			WHEN NO_DATA_FOUND THEN
				IF GA.ENABLE_AGG_POST_ESP_ASSIGNMENT THEN
					AGG_POST_ESP_ASSIGNMENT(GA.DEFAULT_MODEL,
						p_ACCOUNT_ID, p_SERVICE_LOCATION_ID, p_EDC_ID, p_ESP_ID, p_PSE_ID, p_POOL_ID,
						p_BEGIN_DATE, p_END_DATE, p_AGGREGATE_ID);
				ELSE
					DATA_IMPORT.LOG_IMPORT_ERROR('Account: '||p_ACCOUNT_NAME||' has no enrollment'
							||CASE NVL(p_ESP_ID, CONSTANTS.NOT_ASSIGNED)
								WHEN CONSTANTS.NOT_ASSIGNED THEN NULL
								ELSE ' with '||TEXT_UTIL.TO_CHAR_ENTITY(p_ESP_ID, EC.ED_ESP, TRUE)
								END
							||CASE NVL(p_POOL_ID, CONSTANTS.NOT_ASSIGNED)
								WHEN CONSTANTS.NOT_ASSIGNED THEN NULL
								ELSE ' with '||TEXT_UTIL.TO_CHAR_ENTITY(p_POOL_ID, EC.ED_POOL, TRUE)
								END,
						p_SUCCESS);
				END IF;
			WHEN TOO_MANY_ROWS THEN
				DATA_IMPORT.LOG_IMPORT_ERROR('Account: '||p_ACCOUNT_NAME||' has a model option of aggregate'
						||' but insufficient parameters were provided to identify enrollment. Please specify'
						||' ESP and/or Pool to import usage for this account',
					p_SUCCESS);
		END;
		p_LOAD_SETTLEMENT_PROF := FALSE; -- don't load settlement profiles for aggregate accounts
										-- since incoming interval data may not be properly "normalized"
	ELSE
		p_AGGREGATE_ID := CONSTANTS.NOT_ASSIGNED;
	END IF;

	-- CHECK SERVICE LOCATION RELATIONSHIP
    -- Check if an explicit service location was specified
    IF NOT p_IS_HISTORICAL_DATA THEN
        IF NVL(p_SERVICE_LOCATION_ID, CONSTANTS.NOT_ASSIGNED) = CONSTANTS.NOT_ASSIGNED THEN
            SELECT COUNT(1) INTO v_IS_ACTIVE
            FROM ACCOUNT_SERVICE_LOCATION SERV_LOC
            WHERE ACCOUNT_ID = p_ACCOUNT_ID
                AND p_END_DATE BETWEEN SERV_LOC.BEGIN_DATE AND NVL(SERV_LOC.END_DATE, CONSTANTS.HIGH_DATE);

            IF v_IS_ACTIVE <> 1 AND SUBSTR(p_ACCOUNT_MODEL_OPTION,1,1) = 'A' THEN -- Account Model
                DATA_IMPORT.LOG_IMPORT_ERROR('The given Account (' || p_ACCOUNT_NAME
                || ') should have one and exactly one Service Location for the given date '
                || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE) || '.  No usage data will be loaded for this date.', p_SUCCESS);
                p_LOAD_USAGE_DATA := FALSE;
            END IF;

            IF v_IS_ACTIVE <= 0  AND
                (SUBSTR(p_ACCOUNT_MODEL_OPTION,1,1) = 'M' OR SUBSTR(p_ACCOUNT_MODEL_OPTION,1,2) = 'AG') THEN -- Meter and Aggregate Model
                 DATA_IMPORT.LOG_IMPORT_ERROR('The given Account (' || p_ACCOUNT_NAME
                || ') should have at least one Service Location for the given date '
                || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE) || '.  No usage data will be loaded for this date.', p_SUCCESS);
                p_LOAD_USAGE_DATA := FALSE;
            END IF;
        ELSE
            SELECT COUNT(1) INTO v_IS_ACTIVE
            FROM ACCOUNT_SERVICE_LOCATION SERV_LOC
            WHERE ACCOUNT_ID = p_ACCOUNT_ID
                AND SERV_LOC.SERVICE_LOCATION_ID = p_SERVICE_LOCATION_ID
                AND p_END_DATE BETWEEN SERV_LOC.BEGIN_DATE AND NVL(SERV_LOC.END_DATE, CONSTANTS.HIGH_DATE);

             IF v_IS_ACTIVE <= 0 THEN
                DATA_IMPORT.LOG_IMPORT_ERROR('The given Account (' || p_ACCOUNT_NAME
                    || ') and Service location (' || EI.GET_ENTITY_NAME(EC.ED_SERVICE_LOCATION, p_SERVICE_LOCATION_ID)
                    || ') does not have a relationship for the given date '
                    || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE) || '.  No usage data will be loaded for this date.', p_SUCCESS);
                p_LOAD_USAGE_DATA := FALSE;
            END IF;
        END IF;
    END IF;

	-- CHECK METER RELATIONSHIP
	IF SUBSTR(p_ACCOUNT_MODEL_OPTION,1,1) = 'M' THEN -- Meter model
		IF NVL(p_METER_ID, CONSTANTS.NOT_ASSIGNED) = CONSTANTS.NOT_ASSIGNED THEN
			-- meter-modeled but zero/null meter ID?
			DATA_IMPORT.LOG_IMPORT_ERROR('Account: '||p_ACCOUNT_NAME||' has a model option of meter'
					|| ' but no meter was specified',
					p_SUCCESS);
			p_LOAD_SETTLEMENT_PROF := FALSE; -- don't load any data if we see an error
		ELSE
            IF NOT p_IS_HISTORICAL_DATA THEN
                SELECT COUNT(1) INTO v_IS_ACTIVE
                FROM ACCOUNT_SERVICE_LOCATION SERV_LOC,
                    SERVICE_LOCATION_METER METER
                WHERE SERV_LOC.ACCOUNT_ID = p_ACCOUNT_ID
                    AND p_END_DATE BETWEEN SERV_LOC.BEGIN_DATE AND NVL(SERV_LOC.END_DATE, CONSTANTS.HIGH_DATE)
                    AND NVL(p_SERVICE_LOCATION_ID, CONSTANTS.NOT_ASSIGNED) IN (CONSTANTS.NOT_ASSIGNED, SERV_LOC.SERVICE_LOCATION_ID)
                    AND METER.SERVICE_LOCATION_ID = SERV_LOC.SERVICE_LOCATION_ID
                    AND p_END_DATE BETWEEN METER.BEGIN_DATE AND NVL(METER.END_DATE, CONSTANTS.HIGH_DATE)
                    AND METER.METER_ID = p_METER_ID;

                IF v_IS_ACTIVE <= 0 THEN
                    DATA_IMPORT.LOG_IMPORT_ERROR('The given account (' || p_ACCOUNT_NAME
                    || ') does not have a valid Meter relationship for the given date '
                    || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE) || '.  No usage data will be loaded for this date.'
                    || CASE WHEN p_LOAD_SETTLEMENT_PROF THEN ' However settlement profile data will be loaded.' ELSE '' END, p_SUCCESS);
                    p_LOAD_USAGE_DATA := FALSE;
                END IF;
            END IF;
		END IF;
	ELSIF NVL(p_METER_ID, CONSTANTS.NOT_ASSIGNED) <> CONSTANTS.NOT_ASSIGNED THEN
		-- not meter-modeled, but non-zero meter ID
		DATA_IMPORT.LOG_IMPORT_ERROR('Account: '||p_ACCOUNT_NAME||' does not have a model option of meter'
				|| ' but Meter: '||p_METER_NAME|| ' was specified',
				p_SUCCESS);
		p_LOAD_SETTLEMENT_PROF := FALSE; -- don't load any data if we see an error
	END IF;

	-- VERIFY THAT THE ACCOUNT IS ACTIVE FOR THE GIVEN DATE
    IF NOT p_IS_HISTORICAL_DATA THEN
        SELECT COUNT(1) INTO v_IS_ACTIVE
        FROM ACCOUNT_STATUS STAT,
            ACCOUNT_STATUS_NAME STN
        WHERE STAT.ACCOUNT_ID = p_ACCOUNT_ID
            AND p_END_DATE BETWEEN STAT.BEGIN_DATE AND NVL(STAT.END_DATE, CONSTANTS.HIGH_DATE)
            AND STN.STATUS_NAME = STAT.STATUS_NAME
            AND STN.IS_ACTIVE = 1;
        IF v_IS_ACTIVE <= 0 THEN
            DATA_IMPORT.LOG_IMPORT_ERROR('Account: ' || p_ACCOUNT_NAME
                || ' is not active for the given date '
                || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE) || '.  No usage data will be loaded for this date.'
                || CASE WHEN p_LOAD_SETTLEMENT_PROF THEN ' However settlement profile data will be loaded.' ELSE '' END,
                p_SUCCESS);
            p_LOAD_USAGE_DATA := FALSE;
        END IF;

        -- CHECK THE EDC / ESP RELATIONSHIPS

        -- don't worry about the check if an explicit settlement EDC was specified
        IF NVL(p_EDC_ID, CONSTANTS.NOT_ASSIGNED) = CONSTANTS.NOT_ASSIGNED THEN
            SELECT COUNT(1) INTO v_IS_ACTIVE
            FROM ACCOUNT_EDC EDC
            WHERE EDC.ACCOUNT_ID = p_ACCOUNT_ID
                AND p_END_DATE BETWEEN EDC.BEGIN_DATE AND NVL(EDC.END_DATE, CONSTANTS.HIGH_DATE);

            IF v_IS_ACTIVE <= 0 THEN
                DATA_IMPORT.LOG_IMPORT_ERROR('The given account (' || p_ACCOUNT_NAME
                    || ') does not have a valid EDC relationship for the given date '
                    || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE) || '.  No usage data will be loaded for this date.'
                    || CASE WHEN p_LOAD_SETTLEMENT_PROF THEN ' However settlement profile data will be loaded.' ELSE '' END,
                    p_SUCCESS);
                p_LOAD_USAGE_DATA := FALSE;
            END IF;
        END IF;

        -- don't worry about the check if an explicit settlement ESP was specified
        IF NVL(p_ESP_ID, CONSTANTS.NOT_ASSIGNED) = CONSTANTS.NOT_ASSIGNED THEN
            -- don't worry about Aggregate model - already checked when determining
            -- value for p_AGGREGATE ID above
            IF UPPER(SUBSTR(p_ACCOUNT_MODEL_OPTION,1,2)) <> 'AG' THEN
                SELECT COUNT(1) INTO v_IS_ACTIVE
                FROM ACCOUNT_ESP ESP
                WHERE ESP.ACCOUNT_ID = p_ACCOUNT_ID
                    AND p_END_DATE BETWEEN ESP.BEGIN_DATE AND NVL(ESP.END_DATE, CONSTANTS.HIGH_DATE);

                IF v_IS_ACTIVE <= 0 THEN
                    DATA_IMPORT.LOG_IMPORT_ERROR('The given account (' || p_ACCOUNT_NAME
                        || ') does not have a valid ESP relationship for the given date '
                        || TEXT_UTIL.TO_CHAR_DATE(p_END_DATE) || '.  No usage data will be loaded for this date.'
                        || CASE WHEN p_LOAD_SETTLEMENT_PROF THEN ' However settlement profile data will be loaded.' ELSE '' END,
                        p_SUCCESS);
                    p_LOAD_USAGE_DATA := FALSE;
                END IF;
            END IF;
        END IF;
    END IF;
END VALIDATE_SVC_FOR_USAGE_DATA;
----------------------------------------------------------------------------------------------------
PROCEDURE UPDATE_SL_SUBDAILY
    (
    p_ACCOUNT_ID IN NUMBER,
    p_SERVICE_LOCATION_ID IN NUMBER,
    p_METER_ID IN NUMBER,
    p_SERVICE_DATE IN DATE,
    p_SCENARIO_ID IN NUMBER,
    p_SERVICE_CODE IN CHAR,
    p_AGGREGATE_ID IN NUMBER,
    p_EDC_ID IN NUMBER,
    p_PSE_ID IN NUMBER,
    p_POOL_ID IN NUMBER,
    p_AS_OF_DATE IN DATE
	) AS

	v_ESP_IDS NUMBER_COLLECTION;
	v_POOL_IDS NUMBER_COLLECTION;
	v_BEGIN_DATE DATE;
	v_END_DATE DATE;
	v_SERVICE_STATE1 SERVICE_STATE%ROWTYPE;
	v_SERVICE_STATE2 SERVICE_STATE%ROWTYPE;
	v_ESP_BEGIN_DATE DATE;
	v_SERVICE_ID1 SERVICE_STATE.SERVICE_ID%TYPE;
	v_SERVICE_ID2 SERVICE_STATE.SERVICE_ID%TYPE;

BEGIN

    -- get cut date range for service date
	-- e.g., 1/1/2011 -> 1/1/2011 00:00:01 - 1/2/2011 00:00:00
	UT.CUT_DATE_RANGE(CONSTANTS.ELECTRIC_MODEL, p_SERVICE_DATE, p_SERVICE_DATE,
		GA.LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

    -- get the ESP IDs and associated POOL IDs for this account and service date
	SELECT AESP.ESP_ID, AESP.POOL_ID
	BULK COLLECT INTO v_ESP_IDS, v_POOL_IDS
	FROM ACCOUNT_ESP AESP
	WHERE AESP.ACCOUNT_ID = p_ACCOUNT_ID
	  AND v_END_DATE >= AESP.BEGIN_DATE
	  AND v_BEGIN_DATE <= NVL(AESP.END_DATE, CONSTANTS.HIGH_DATE)
	ORDER BY AESP.BEGIN_DATE;

	-- We only need to update service load for subdaily for service dates where there
	-- is a change in ESPs.
	-- As a rule, an ESP assignment must last at least 24 hours, so there will either be 1 or 2
	-- If there aren't 2 ESPs on this day, then there is nothing to worry about
	IF v_ESP_IDS.COUNT <> 2 THEN
        RETURN;
	END IF;

	-- get the service state row for the first ESP
	-- this should always already exist
	v_SERVICE_STATE1 := GET_SERVICE_STATE(p_SCENARIO_ID,
	                                      p_SERVICE_CODE,
										  p_ACCOUNT_ID,
										  p_SERVICE_LOCATION_ID,
										  p_METER_ID,
										  p_AGGREGATE_ID,
										  p_EDC_ID,
										  v_ESP_IDS(1),
										  p_PSE_ID,
										  v_POOL_IDS(1),
										  p_SERVICE_DATE,
										  p_AS_OF_DATE,
										  g_UNKNOWN);

	-- get the service state row for the second ESP
	-- this has a potential not to exist and get created in the call
	v_SERVICE_STATE2 := GET_SERVICE_STATE(p_SCENARIO_ID,
	                                      p_SERVICE_CODE,
										  p_ACCOUNT_ID,
										  p_SERVICE_LOCATION_ID,
										  p_METER_ID,
										  p_AGGREGATE_ID,
										  p_EDC_ID,
										  v_ESP_IDS(2),
										  p_PSE_ID,
										  v_POOL_IDS(2),
										  p_SERVICE_DATE,
										  p_AS_OF_DATE,
										  g_UNKNOWN);

	-- get the two service IDs
	v_SERVICE_ID1 := v_SERVICE_STATE1.SERVICE_ID;
	v_SERVICE_ID2 := v_SERVICE_STATE2.SERVICE_ID;

	-- get the begin date of the second ESP
	-- the starting point from which we need to update
	SELECT AESP.BEGIN_DATE
	INTO v_ESP_BEGIN_DATE
	FROM ACCOUNT_ESP AESP
	WHERE AESP.ESP_ID = v_ESP_IDS(2)
	  AND AESP.ACCOUNT_ID = p_ACCOUNT_ID;

	-- cleanup any previous service load for ESP2's service ID
	DELETE FROM SERVICE_LOAD SL
	WHERE SL.SERVICE_ID = v_SERVICE_ID2
	  AND SL.LOAD_DATE >= v_ESP_BEGIN_DATE
	  AND SL.LOAD_DATE <= v_END_DATE
	  AND SL.SERVICE_CODE = p_SERVICE_CODE
	  AND SL.LOAD_CODE = GA.ELECTRIC_MODEL;

	-- update the service load generated for ESP1 but which is really for ESP2
	-- from ESP2's begin date to the end of the service day
	UPDATE SERVICE_LOAD SL
	SET SL.SERVICE_ID = v_SERVICE_ID2
	WHERE SL.SERVICE_ID = v_SERVICE_ID1
	  AND SL.LOAD_DATE >= v_ESP_BEGIN_DATE
	  AND SL.LOAD_DATE <= v_END_DATE
	  AND SL.SERVICE_CODE = p_SERVICE_CODE
	  AND SL.LOAD_CODE = GA.ELECTRIC_MODEL;

END UPDATE_SL_SUBDAILY;
----------------------------------------------------------------------------------------------------
PROCEDURE IMPORT_SERVICE_LOAD_DATA
	(
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_INTERVAL_ABBR IN VARCHAR2,
	p_AS_OF_DATE IN DATE,
	p_USAGE_DATA IN GA.FLOAT_TABLE,
	p_USAGE_DATES IN GA.DATE_TABLE,
	p_SUCCESS IN OUT BOOLEAN,
	p_SCENARIO_ID IN NUMBER := GA.BASE_SCENARIO_ID,
	p_SERVICE_CODE IN CHAR := GA.ACTUAL_SERVICE,
	p_EDC_ID IN NUMBER := NULL,
	p_ESP_ID IN NUMBER := NULL,
	p_PSE_ID IN NUMBER := NULL,
	p_POOL_ID IN NUMBER := NULL,
	p_DELETE_FIRST IN NUMBER := 0,
    p_SKIP_PROCESSING_LOSS_FACTOR IN BOOLEAN := FALSE
	) AS

	v_AGGREGATE_ID 			NUMBER;
	v_ACCOUNT_MODEL_OPTION 	ACCOUNT.ACCOUNT_MODEL_OPTION%TYPE;
	v_TX_LOSS 				GA.FACTOR_TABLE;
	v_DX_LOSS 				GA.FACTOR_TABLE;
	v_UE_LOSS 				GA.FACTOR_TABLE;
	v_SETT_DATA 			GA.NUMBER_TABLE;
	v_SERVICE 				SERVICE%ROWTYPE;
	v_SERVICE_STATE 		SERVICE_STATE%ROWTYPE;
	v_PROVIDER_SERVICE 		PROVIDER_SERVICE%ROWTYPE;
	v_SCENARIO_ID 			SERVICE.SCENARIO_ID%TYPE := NVL(p_SCENARIO_ID, GA.BASE_SCENARIO_ID);

	v_LOAD_SETT_SETTING 	SYSTEM_DICTIONARY.VALUE%TYPE;
	v_LOAD_SETTLEMENT_PROF	BOOLEAN;
	v_LOAD_USAGE_DATA 		BOOLEAN := TRUE;

	v_PROFILE_ID 			NUMBER(9);
	v_PROFILE_NAME 			LOAD_PROFILE.PROFILE_NAME%TYPE;
	v_PROFILE_LIB_NAME 		LOAD_PROFILE_LIBRARY.PROFILE_LIBRARY_NAME%TYPE;
	v_CALENDAR_ID 			NUMBER(9);

	v_STATUS	NUMBER;
	v_TEST		PLS_INTEGER;

	v_INTERVAL_DIVISOR NUMBER := DATE_UTIL.GET_INTERVAL_DIVISOR(CONSTANTS.INTERVAL_DAY,
									p_INTERVAL_ABBR, p_SERVICE_DATE, CUT_TIME_ZONE, NULL);

	v_ACCOUNT_NAME	ACCOUNT.ACCOUNT_NAME%TYPE := TEXT_UTIL.TO_CHAR_ENTITY(p_ACCOUNT_ID,
																		EC.ED_ACCOUNT);
	v_METER_NAME	METER.METER_NAME%TYPE := TEXT_UTIL.TO_CHAR_ENTITY(p_METER_ID,
																	EC.ED_METER);

BEGIN

	SP.GET_SYSTEM_DICTIONARY_VALUE(0, 'Data Import', 'Import Interval Usage Data', '?', '?', 'Load Settlement Profile',
			v_LOAD_SETT_SETTING);

	v_LOAD_SETTLEMENT_PROF := UT.BOOLEAN_FROM_STRING(v_LOAD_SETT_SETTING);

	-- Validate parameters and account relationships for this date
	VALIDATE_SVC_FOR_USAGE_DATA(p_ACCOUNT_ID, v_ACCOUNT_NAME, p_SERVICE_LOCATION_ID,
								p_METER_ID, v_METER_NAME, p_SERVICE_DATE, p_SERVICE_DATE,
								p_EDC_ID, p_ESP_ID,	p_PSE_ID, p_POOL_ID, TRUE, p_SERVICE_CODE = GA.HISTORICAL_SERVICE,
                                v_AGGREGATE_ID, v_ACCOUNT_MODEL_OPTION, p_SUCCESS,
								v_LOAD_SETTLEMENT_PROF, v_LOAD_USAGE_DATA);

	IF p_SUCCESS THEN

		IF v_LOAD_USAGE_DATA THEN
			v_SERVICE_STATE := GET_SERVICE_STATE(v_SCENARIO_ID, p_SERVICE_CODE,
								p_ACCOUNT_ID, p_SERVICE_LOCATION_ID, p_METER_ID, v_AGGREGATE_ID,
								p_EDC_ID, p_ESP_ID, p_PSE_ID, p_POOL_ID,
								TRUNC(p_SERVICE_DATE), p_AS_OF_DATE, g_UNKNOWN, p_DELETE_FIRST);
			v_SERVICE := CS.GET_SERVICE(v_SERVICE_STATE.SERVICE_ID);
			v_PROVIDER_SERVICE := CS.GET_PROVIDER_SERVICE(v_SERVICE.PROVIDER_SERVICE_ID);
            IF NOT p_SKIP_PROCESSING_LOSS_FACTOR THEN
	  		    FS.APPLY_LOSS_FACTORS(v_SERVICE.ACCOUNT_SERVICE_ID, v_PROVIDER_SERVICE.EDC_ID, p_SERVICE_DATE, p_USAGE_DATA, v_TX_LOSS, v_DX_LOSS, v_UE_LOSS, TRUE);
            ELSE
                FOR v_INDEX IN 1..p_USAGE_DATA.COUNT LOOP
					v_TX_LOSS(v_INDEX) := 0;
					v_DX_LOSS(v_INDEX) := 0;
					v_UE_LOSS(v_INDEX) := 0;
				END LOOP;
            END IF;
	  		STORE_SERVICE_LOAD(v_SERVICE.SERVICE_ID, p_SERVICE_CODE, p_USAGE_DATES, p_USAGE_DATA, v_TX_LOSS, v_DX_LOSS, v_UE_LOSS);
		END IF;

		IF v_LOAD_SETTLEMENT_PROF THEN
		-- LOAD THE SETTLEMENT PROFILE
			v_PROFILE_NAME := CASE WHEN SUBSTR(v_ACCOUNT_MODEL_OPTION,1,1) = 'M' THEN v_METER_NAME ELSE v_ACCOUNT_NAME END;

			BEGIN
				v_PROFILE_ID := EI.GET_ID_FROM_NAME(v_PROFILE_NAME, EC.ED_LOAD_PROFILE);
			EXCEPTION
				WHEN MSGCODES.e_ERR_NO_SUCH_ENTRY THEN
					ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
					IO.PUT_LOAD_PROFILE(o_oid => v_PROFILE_ID,
                         p_PROFILE_LIBRARY_ID => CONSTANTS.NOT_ASSIGNED,
                         p_PROFILE_NAME => v_PROFILE_NAME,
                         p_PROFILE_ALIAS => v_PROFILE_NAME,
                         p_PROFILE_DESC => v_PROFILE_NAME,
                         p_PROFILE_ID => CONSTANTS.NOT_ASSIGNED,
                         p_PROFILE_TYPE => 'Historical',
                         p_PROFILE_OPERATION => NULL,
                         p_PROFILE_ORIGIN => NULL,
                         p_PROFILE_RATE_CLASS => NULL,
                         p_PROFILE_DAY_TYPE => NULL,
                         p_PROFILE_ACCOUNT_REF => p_ACCOUNT_ID,
                         p_PROFILE_METER_REF => p_METER_ID,
                         p_PROFILE_SIC_CODE => NULL,
                         p_PROFILE_SEASON => NULL,
                         p_PROFILE_SYSTEM_LOAD => NULL,
                         p_PROFILE_ADJUSTMENT_OPTION => NULL,
                         p_PROFILE_STATION_ID => CONSTANTS.NOT_ASSIGNED,
                         p_PROFILE_TEMPLATE_ID => CONSTANTS.NOT_ASSIGNED,
                         p_PROFILE_SOURCE_BEGIN_DATE => NULL,
                         p_PROFILE_SOURCE_END_DATE => NULL,
                         p_PROFILE_SOURCE_ID => CONSTANTS.NOT_ASSIGNED,
                         p_PROFILE_INTERVAL => v_INTERVAL_DIVISOR,
                         p_PROFILE_SOURCE_VERSION => NULL,
                         p_PROFILE_BREAKPOINT_INTERVAL => NULL,
                         p_IS_EXTERNAL_PROFILE => 0);
			END;

			ID.ID_FOR_CALENDAR(v_ACCOUNT_NAME,TRUE,v_CALENDAR_ID);
			DATA_IMPORT.PUT_CALENDAR_PROFILE(v_CALENDAR_ID,
											v_PROFILE_ID);

			IF SUBSTR(v_ACCOUNT_MODEL_OPTION,1,1) = 'M' THEN
				SELECT COUNT(1) INTO v_TEST
				FROM METER_CALENDAR MTR
				WHERE MTR.METER_ID = p_METER_ID
					AND p_SERVICE_DATE BETWEEN MTR.BEGIN_DATE
						AND NVL(MTR.END_DATE, HIGH_DATE)
					AND MTR.CALENDAR_TYPE = 'Forecast';

				IF v_TEST <= 0 THEN
					PM.PUT_METER_CALENDAR(GA.BASE_CASE_ID,
						p_METER_ID,
						v_CALENDAR_ID,
						'Forecast',
						p_SERVICE_DATE,
						NULL,
						GA.BASE_CASE_ID,
						v_CALENDAR_ID,
						'Forecast',
						p_SERVICE_DATE,
						v_STATUS);

					ERRS.VALIDATE_STATUS('PM.PUT_METER_CALENDAR',
										v_STATUS);
				END IF;
			ELSE
				SELECT COUNT(1) INTO v_TEST
				FROM ACCOUNT_CALENDAR CAL
				WHERE CAL.ACCOUNT_ID = p_ACCOUNT_ID
					AND CAL.CALENDAR_TYPE = 'Forecast'
					AND p_SERVICE_DATE BETWEEN CAL.BEGIN_DATE
						AND NVL(CAL.END_DATE, HIGH_DATE);

				IF v_TEST <= 0 THEN
					RA.PUT_ACCOUNT_CALENDAR(GA.BASE_CASE_ID,
						p_ACCOUNT_ID,
						v_CALENDAR_ID,
						'Forecast',
						p_SERVICE_DATE,
						NULL,
						GA.BASE_CASE_ID,
						v_CALENDAR_ID,
						'Forecast',
						p_SERVICE_DATE,
						v_STATUS);

					ERRS.VALIDATE_STATUS('RA.PUT_ACCOUNT_CALENDAR',
						v_STATUS);
				END IF;
			 END IF;

			 PF.g_ALLOW_COMMIT_ROLLBACK := FALSE;
			 v_SETT_DATA := UT.CONVERT_FLT_TABLE_TO_NUM_TABLE(p_USAGE_DATA);
			 PF.PUT_HISTORICAL_PROFILE_TBL(v_PROFILE_LIB_NAME, v_PROFILE_NAME, v_SETT_DATA, p_SERVICE_DATE,
			 	GA.LOCAL_TIME_ZONE, v_INTERVAL_DIVISOR, v_STATUS, p_INTERVAL_IS_NUM_MIN => FALSE);
			 ERRS.VALIDATE_STATUS('PF.PUT_HISTORICAL_PROFILE_TBL',
				v_STATUS);
		END IF;

        IF GA.CSB_IS_SUBDAILY THEN
            UPDATE_SL_SUBDAILY(p_ACCOUNT_ID, p_SERVICE_LOCATION_ID, p_METER_ID,
                               p_SERVICE_DATE, v_SCENARIO_ID, p_SERVICE_CODE, v_AGGREGATE_ID,
                               p_EDC_ID, p_PSE_ID, p_POOL_ID, p_AS_OF_DATE);
        END IF;
	END IF;

END IMPORT_SERVICE_LOAD_DATA;
----------------------------------------------------------------------------------------------------
PROCEDURE IMPORT_SERVICE_LOAD_DATA
	(
	p_SETTLEMENT_TYPE_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_SERVICE_DATE IN DATE,
	p_INTERVAL_ABBR IN VARCHAR2,
	p_AS_OF_DATE IN DATE,
	p_USAGE_DATA IN GA.FLOAT_TABLE,
	p_USAGE_DATES IN GA.DATE_TABLE,
	p_SUCCESS IN OUT BOOLEAN,
	p_EDC_ID IN NUMBER := NULL,
	p_ESP_ID IN NUMBER := NULL,
	p_PSE_ID IN NUMBER := NULL,
	p_POOL_ID IN NUMBER := NULL,
	p_DELETE_FIRST IN NUMBER := 0
	) AS
v_SCENARIO_ID	NUMBER;
v_SERVICE_CODE	CHAR(1);
BEGIN
	SELECT SCENARIO_ID, SERVICE_CODE
	INTO v_SCENARIO_ID, v_SERVICE_CODE
	FROM SETTLEMENT_TYPE
	WHERE SETTLEMENT_TYPE_ID = p_SETTLEMENT_TYPE_ID;

	IMPORT_SERVICE_LOAD_DATA(p_ACCOUNT_ID, p_SERVICE_LOCATION_ID, p_METER_ID, p_SERVICE_DATE,
							 p_INTERVAL_ABBR, p_AS_OF_DATE, p_USAGE_DATA, p_USAGE_DATES,
							 p_SUCCESS, v_SCENARIO_ID, v_SERVICE_CODE,
							 p_EDC_ID, p_ESP_ID, p_PSE_ID, p_POOL_ID, p_DELETE_FIRST);

END IMPORT_SERVICE_LOAD_DATA;
----------------------------------------------------------------------------------------------------
FUNCTION GET_BILL_CYCLE_MONTH
	(
	p_ACCOUNT_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_READ_DATE IN DATE
	) RETURN DATE IS
v_RET DATE;
BEGIN
	-- check meter bill cycle
	IF NVL(p_METER_ID,CONSTANTS.NOT_ASSIGNED) <> CONSTANTS.NOT_ASSIGNED THEN
		SELECT NVL(MAX(BP.BILL_CYCLE_MONTH), TRUNC(p_READ_DATE,'MM')) -- default to month of read date
		INTO v_RET
		FROM METER_BILL_CYCLE MB,
			BILL_CYCLE_PERIOD BP
		WHERE MB.METER_ID = p_METER_ID
			AND p_READ_DATE BETWEEN MB.BEGIN_DATE AND NVL(MB.END_DATE, CONSTANTS.HIGH_DATE)
			AND BP.BILL_CYCLE_ID = MB.BILL_CYCLE_ID
			AND p_READ_DATE BETWEEN BP.BEGIN_DATE AND BP.END_DATE;

	-- or check account
	ELSE
		SELECT NVL(MAX(BP.BILL_CYCLE_MONTH), TRUNC(p_READ_DATE,'MM')) -- default to month of read date
		INTO v_RET
		FROM ACCOUNT_BILL_CYCLE AB,
			BILL_CYCLE_PERIOD BP
		WHERE AB.ACCOUNT_ID = p_ACCOUNT_ID
			AND p_READ_DATE BETWEEN AB.BEGIN_DATE AND NVL(AB.END_DATE, CONSTANTS.HIGH_DATE)
			AND BP.BILL_CYCLE_ID = AB.BILL_CYCLE_ID
			AND p_READ_DATE BETWEEN BP.BEGIN_DATE AND BP.END_DATE;

	END IF;

	RETURN v_RET;
END GET_BILL_CYCLE_MONTH;
----------------------------------------------------------------------------------------------------
PROCEDURE PUT_USAGE_FACTOR
	(
	p_ACCOUNT_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_ACCOUNT_MODEL_OPTION IN VARCHAR2,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_USAGE_FACTOR IN NUMBER,
    p_SOURCE_CALENDAR_ID IN NUMBER,
    p_SOURCE_BEGIN_DATE IN DATE,
    p_SOURCe_END_DATE IN DATE
	) AS
BEGIN
	IF p_ACCOUNT_MODEL_OPTION = ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_ACCOUNT THEN
		UT.PUT_TEMPORAL_DATA('ACCOUNT_USAGE_FACTOR',
									 p_BEGIN_DATE,
									 p_END_DATE,
									 TRUE,
									 TRUE,
									 'ACCOUNT_ID',
									 p_ACCOUNT_ID,
									 TRUE,
									 'CASE_ID',
									 GA.BASE_CASE_ID,
									 TRUE,
									 'FACTOR_VAL',
									 p_USAGE_FACTOR,
									 FALSE);

       UPDATE ACCOUNT_USAGE_FACTOR AUF
       SET AUF.SOURCE_CALENDAR_ID = p_SOURCE_CALENDAR_ID,
           AUF.SOURCE_BEGIN_DATE = p_SOURCE_BEGIN_DATE,
           AUF.SOURCE_END_DATE = p_SOURCE_END_DATE
       WHERE AUF.CASE_ID = GA.BASE_CASE_ID
        AND AUF.ACCOUNT_ID = p_ACCOUNT_ID
        AND AUF.BEGIN_DATE = p_BEGIN_DATE;

	ELSIF p_ACCOUNT_MODEL_OPTION = ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_METER THEN
		UT.PUT_TEMPORAL_DATA('METER_USAGE_FACTOR',
                                 p_BEGIN_DATE,
                                 p_END_DATE,
                                 TRUE,
                                 TRUE,
                                 'METER_ID',
                                 p_METER_ID,
                                 TRUE,
                                 'CASE_ID',
                                 GA.BASE_CASE_ID,
                                 TRUE,
                                 'FACTOR_VAL',
                                 p_USAGE_FACTOR,
                                 FALSE);

       UPDATE METER_USAGE_FACTOR MUF
       SET MUF.SOURCE_CALENDAR_ID = p_SOURCE_CALENDAR_ID,
           MUF.SOURCE_BEGIN_DATE = p_SOURCE_BEGIN_DATE,
           MUF.SOURCE_END_DATE = p_SOURCE_END_DATE
       WHERE MUF.CASE_ID = GA.BASE_CASE_ID
        AND MUF.METER_ID = p_METER_ID
        AND MUF.BEGIN_DATE = p_BEGIN_DATE;

	ELSE
		ERRS.RAISE_BAD_ARGUMENT('Account Model Option', p_ACCOUNT_MODEL_OPTION);
	END IF;
END PUT_USAGE_FACTOR;
----------------------------------------------------------------------------------------------------
PROCEDURE VALIDATE_CALENDAR_PROFILE_DATA
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_CALENDAR_ID IN NUMBER
	) AS
v_COUNT NUMBER := 0;
BEGIN
	FOR v_REC IN (SELECT P.PROFILE_ID, S.FROM_DATE, S.TO_DATE, P.PROFILE_TYPE
				  FROM CALENDAR_PROFILE X, LOAD_PROFILE P, LOAD_PROFILE_STATISTICS S
				  WHERE X.CALENDAR_ID = p_CALENDAR_ID
				    AND X.BEGIN_DATE <= p_END_DATE
					AND NVL(X.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND P.PROFILE_ID = X.PROFILE_ID
					AND S.PROFILE_ID = P.PROFILE_ID
					AND S.AS_OF_DATE = CONSTANTS.LOW_DATE
				  UNION
				  SELECT P.PROFILE_ID, S.FROM_DATE, S.TO_DATE, P.PROFILE_TYPE
				  FROM CALENDAR_PROFILE_LIBRARY X, LOAD_PROFILE P, LOAD_PROFILE_STATISTICS S
				  WHERE X.CALENDAR_ID = p_CALENDAR_ID
				    AND X.BEGIN_DATE <= p_END_DATE
					AND NVL(X.END_DATE, CONSTANTS.HIGH_DATE) >= p_BEGIN_DATE
					AND P.PROFILE_LIBRARY_ID = X.PROFILE_LIBRARY_ID
					AND S.PROFILE_ID = P.PROFILE_ID
					AND S.AS_OF_DATE = CONSTANTS.LOW_DATE) LOOP

		IF v_REC.PROFILE_TYPE = 'Historical' THEN
			IF v_REC.FROM_DATE > p_BEGIN_DATE OR v_REC.TO_DATE < p_END_DATE THEN
				ERRS.RAISE(MSGCODES.c_ERR_MISSING_PROFILE_DATA, 'Profile ' || TEXT_UTIL.TO_CHAR_ENTITY(v_REC.PROFILE_ID,EC.ED_LOAD_PROFILE)
					|| ' only includes history for ' || TEXT_UTIL.TO_CHAR_DATE_RANGE(v_REC.FROM_DATE , v_REC.TO_DATE ));
			END IF;
		END IF;

		v_COUNT := v_COUNT + 1;
	END LOOP;

	IF v_COUNT = 0 THEN
		ERRS.RAISE(MSGCODES.c_ERR_MISSING_PROFILE_DATA, 'Calendar ' || TEXT_UTIL.TO_CHAR_ENTITY(p_CALENDAR_ID,EC.ED_CALENDAR)
				|| ' does not have any Profiles assigned to it.');
	END IF;
END VALIDATE_CALENDAR_PROFILE_DATA;
----------------------------------------------------------------------------------------------------
PROCEDURE GET_TOTAL_PROFILE_VALUE
(
   p_WEATHER_STATION_ID 	IN WEATHER_STATION.STATION_ID%TYPE,
   p_CALENDAR_ID			IN CALENDAR.CALENDAR_ID%TYPE,
   p_EDC_ID					IN EDC.EDC_ID%TYPE,
   p_PROFILE_DATE			IN DATE ,
   p_PROFILE_VALUE			OUT NUMBER,
   b_PROFILE_DATA_EXISTS	OUT BOOLEAN
)
IS
BEGIN
   BEGIN
      SELECT A.PROFILE_VALUE
	  INTO p_PROFILE_VALUE
	  FROM  CALENDAR_PROFILE_VALUE A
	  WHERE A.WEATHER_STATION_ID = p_WEATHER_STATION_ID
	  AND   A.CALENDAR_ID = p_CALENDAR_ID
	  AND   A.EDC_ID = p_EDC_ID
	  AND   A.PROFILE_DATE = p_PROFILE_DATE;

	  b_PROFILE_DATA_EXISTS := TRUE;
   EXCEPTION
      WHEN NO_DATA_FOUND THEN
	     p_PROFILE_VALUE       := NULL;
	     b_PROFILE_DATA_EXISTS := FALSE;
   END;
END GET_TOTAL_PROFILE_VALUE;
----------------------------------------------------------------------------------------------------
PROCEDURE PURGE_CALENDAR_PROFILE_VALUE
IS
BEGIN
   EXECUTE IMMEDIATE 'TRUNCATE TABLE CALENDAR_PROFILE_VALUE';
END PURGE_CALENDAR_PROFILE_VALUE;
----------------------------------------------------------------------------------------------------
PROCEDURE PROCESS_USAGE_FACTORS(p_SERVICE_CONSUMPTION IN SERVICE_CONSUMPTION%ROWTYPE) AS
v_ACCOUNT_ID 			ACCOUNT.ACCOUNT_ID%TYPE;
v_SERVICE_LOCATION_ID 	SERVICE_LOCATION.SERVICE_LOCATION_ID%TYPE;
v_METER_ID 				METER.METER_ID%TYPE;
v_MODEL_ID 				SERVICE.MODEL_ID%TYPE;
v_MODEL_OPTION 			ACCOUNT.ACCOUNT_MODEL_OPTION%TYPE;
v_ACCOUNT_USE_TOU 		ACCOUNT.USE_TOU_USAGE_FACTOR%TYPE;
v_METER_USE_TOU  		METER.USE_TOU_USAGE_FACTOR%TYPE;
v_WEATHER_STATION_ID 	WEATHER_STATION.STATION_ID%TYPE;
v_EDC_ID 				EDC.EDC_ID%TYPE;
v_USAGE_FACTOR_HORIZON 	NUMBER := 10;
v_UF_BEGIN_DATE 		DATE;
v_UF_END_DATE 			DATE;
v_CURRENT_DATE 			DATE;
v_TOTAL_PROFILE 		NUMBER;
v_USAGE_FACTOR_VAL 		NUMBER;
v_PROFILE 				GA.NUMBER_TABLE;
v_PROFILE_INDEX 		NUMBER;
v_CALENDAR_COUNT 		NUMBER;
v_COUNT 				NUMBER := 0;
TYPE PROFILE_CACHE IS TABLE OF NUMBER INDEX BY BINARY_INTEGER;
v_PROFILE_CACHE 		PROFILE_CACHE;
v_SKIP_USAGE_FACTOR		BOOLEAN;
b_PROFILE_DATA_EXISTS_ALREADY BOOLEAN;
v_PROFILE_VALUE_FOR_DATE NUMBER;
b_IS_DEBUG_ENABLED CONSTANT BOOLEAN := LOGS.IS_DEBUG_ENABLED;
BEGIN

    $IF $$UNIT_TEST_MODE = 1 $THEN
      IF UNIT_TEST_UTIL.g_CURRENT_TEST_PROCEDURE LIKE '%T_BPUF_%' THEN
        -- Columns with _ID and ENTRY_DATE will be excluded from the list.
        INSERT INTO RTO_WORK(WORK_DATA)
        SELECT 'BEGIN_DATE = '|| TO_CHAR(p_SERVICE_CONSUMPTION.BEGIN_DATE,'YYYY-MM-DD') || gc_CRLF ||
               'END_DATE = '|| TO_CHAR(p_SERVICE_CONSUMPTION.END_DATE,'YYYY-MM-DD') || gc_CRLF ||
               'BILL_CODE = '|| p_SERVICE_CONSUMPTION.BILL_CODE || gc_CRLF ||
               'CONSUMPTION_CODE = '|| p_SERVICE_CONSUMPTION.CONSUMPTION_CODE || gc_CRLF ||
               'RECEIVED_DATE = '|| TO_CHAR(p_SERVICE_CONSUMPTION.RECEIVED_DATE,'YYYY-MM-DD') || gc_CRLF ||
               'UNIT_OF_MEASUREMENT = '|| p_SERVICE_CONSUMPTION.UNIT_OF_MEASUREMENT || gc_CRLF ||
               'METER_TYPE = '|| p_SERVICE_CONSUMPTION.METER_TYPE || gc_CRLF ||
               'METER_READING = '|| p_SERVICE_CONSUMPTION.METER_READING || gc_CRLF ||
               'BILLED_USAGE = '|| TO_CHAR(p_SERVICE_CONSUMPTION.BILLED_USAGE) || gc_CRLF ||
               'BILLED_DEMAND = '|| TO_CHAR(p_SERVICE_CONSUMPTION.BILLED_DEMAND) || gc_CRLF ||
               'METERED_USAGE = '|| TO_CHAR(p_SERVICE_CONSUMPTION.METERED_USAGE) || gc_CRLF ||
               'METERED_DEMAND = '|| TO_CHAR(p_SERVICE_CONSUMPTION.METERED_DEMAND) || gc_CRLF ||
               'METERS_READ = '|| TO_CHAR(p_SERVICE_CONSUMPTION.METERS_READ) || gc_CRLF ||
               'CONVERSION_FACTOR = '|| TO_CHAR(p_SERVICE_CONSUMPTION.CONVERSION_FACTOR) || gc_CRLF ||
               'IGNORE_CONSUMPTION = '|| TO_CHAR(p_SERVICE_CONSUMPTION.IGNORE_CONSUMPTION) || gc_CRLF ||
               'BILL_CYCLE_MONTH = '|| TO_CHAR(p_SERVICE_CONSUMPTION.BILL_CYCLE_MONTH,'YYYY-MM-DD') || gc_CRLF ||
               'BILL_PROCESSED_DATE = '|| TO_CHAR(p_SERVICE_CONSUMPTION.BILL_PROCESSED_DATE,'YYYY-MM-DD') || gc_CRLF ||
               'READ_BEGIN_DATE = '|| TO_CHAR(p_SERVICE_CONSUMPTION.READ_BEGIN_DATE,'YYYY-MM-DD') || gc_CRLF ||
               'READ_END_DATE = '|| TO_CHAR(p_SERVICE_CONSUMPTION.READ_END_DATE,'YYYY-MM-DD') || gc_CRLF
        FROM DUAL;
        GOTO PROCESS_USAGE_FACTOR_END;
    END IF;
    $END

    -- Log message under DEBUG level.
	IF b_IS_DEBUG_ENABLED THEN
		LOGS.LOG_INFO_MORE_DETAIL(p_EVENT_TEXT => 'Processing Usage Factors...');
    END IF;

-- Get Account/Meter Info
	SELECT A.ACCOUNT_ID,
		   A.ACCOUNT_MODEL_OPTION,
		   A.USE_TOU_USAGE_FACTOR,
		   X.SERVICE_LOCATION_ID,
		   X.METER_ID,
		   P.EDC_ID,
		   S.MODEL_ID,
		   (SELECT M.USE_TOU_USAGE_FACTOR
			    FROM METER M
			    WHERE M.METER_ID = X.METER_ID) AS METER_USE_TOU_USAGE_FACTOR
	INTO v_ACCOUNT_ID, v_MODEL_OPTION, v_ACCOUNT_USE_TOU, v_SERVICE_LOCATION_ID, v_METER_ID, v_EDC_ID, v_MODEL_ID, v_METER_USE_TOU
	FROM SERVICE S, ACCOUNT_SERVICE X, ACCOUNT A, PROVIDER_SERVICE P
	WHERE A.ACCOUNT_ID = X.ACCOUNT_ID
	  AND X.ACCOUNT_SERVICE_ID = S.ACCOUNT_SERVICE_ID
	  AND P.PROVIDER_SERVICE_ID = S.PROVIDER_SERVICE_ID
	  AND S.SERVICE_ID = p_SERVICE_CONSUMPTION.SERVICE_ID;

-- Check the "Calculated Usage Factor Horizon" setting, Default to 10 if blank
	v_USAGE_FACTOR_HORIZON := CASE WHEN v_MODEL_ID = CONSTANTS.GAS_MODEL THEN c_USAGE_FACTOR_HORIZON_GAS ELSE c_USAGE_FACTOR_HORIZON_ELEC END;

-- Validate - NOT Aggregate Account
	ASSERT(v_MODEL_OPTION IS NOT NULL AND v_MODEL_OPTION IN (ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_ACCOUNT, ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_METER),
		'Account Model Option must be ''' || ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_ACCOUNT || ''' or ''' ||
		ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_METER || ''' in order to Process Usage Factors. Model Option = ' ||
		v_MODEL_OPTION, MSGCODES.c_ERR_ARGUMENT);

-- Validate - Only default UOM
	ASSERT(UPPER(NVL(p_SERVICE_CONSUMPTION.UNIT_OF_MEASUREMENT, GA.DEFAULT_UNIT_OF_MEASUREMENT)) = UPPER(GA.DEFAULT_UNIT_OF_MEASUREMENT),
		'Unit of Measurement must be ''' || GA.DEFAULT_UNIT_OF_MEASUREMENT || '''. Unit of Measurement = ' ||
		p_SERVICE_CONSUMPTION.UNIT_OF_MEASUREMENT, MSGCODES.c_ERR_ARGUMENT);

-- Only allow non TOU. Otherwise skip and log a warning.
	IF NVL(p_SERVICE_CONSUMPTION.TEMPLATE_ID,CONSTANTS.NOT_ASSIGNED) IN (CONSTANTS.NOT_ASSIGNED, CONSTANTS.ANYTIME_TOU_TEMPLATE_ID, CONSTANTS.ANYTIME_SD_TEMPLATE_ID)
		AND (v_MODEL_OPTION = ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_ACCOUNT AND v_ACCOUNT_USE_TOU = 0
		OR v_MODEL_OPTION = ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_METER AND v_METER_USE_TOU = 0) THEN

	-- Get the Service Locations Weather station
		SELECT NVL(MAX(A.WEATHER_STATION_ID), CONSTANTS.NOT_ASSIGNED)
		INTO v_WEATHER_STATION_ID
		FROM SERVICE_LOCATION A
		WHERE A.SERVICE_LOCATION_ID = v_SERVICE_LOCATION_ID;

	-- Loop over Years in the Horizon
		FOR v_YR IN 0..v_USAGE_FACTOR_HORIZON LOOP

			-- Set up the dates per the spec (BZ26619) to handle Leap Year calculations correctly
			-- End Dates: ADD_MONTHS handles the Leap Year issues for us as it pertains to END_DATE.
			--            2/28 in a non-leap year will become 2/29 in a leap year.
			--			  2/29 in a leap year will become 2/28 in a non-leap year.
			-- Begin Dates: If Begin Date is 2/28 in non-leap years, it must remain 2/28 in leap-years so that it does not leave a gap.
			--              If Begin Date is 2/29 in leap year, it must begin 3/1 in non-leap years.
			-- When the consumption period is 1 day that occurs on 2/29 in a leap year,
			-- the below adjustment will result in a new Begin Date = 3/1 and a new End Date = 2/28.
			-- In this case, since 3/1 is after 2/28, we will skip saving that Usage Factor.
			v_UF_BEGIN_DATE := ADD_MONTHS(p_SERVICE_CONSUMPTION.BEGIN_DATE - 1, v_YR * 12) + 1;
			v_UF_END_DATE := ADD_MONTHS(p_SERVICE_CONSUMPTION.END_DATE, v_YR * 12);

			IF v_UF_BEGIN_DATE <= v_UF_END_DATE THEN
				-- Loop over Calendar assignments
				v_CALENDAR_COUNT := 0;
				FOR v_CALENDAR_ASSIGNMENT IN (SELECT *
											  FROM ACCOUNT_CALENDAR A
											  WHERE A.CASE_ID = GA.BASE_CASE_ID
												AND A.ACCOUNT_ID = v_ACCOUNT_ID
												AND A.CALENDAR_TYPE = ACCOUNTS_METERS.c_CALENDAR_TYPE_FORECAST
												AND A.BEGIN_DATE <= v_UF_END_DATE
												AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= v_UF_BEGIN_DATE
												AND v_MODEL_OPTION = ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_ACCOUNT
											  UNION
											  SELECT *
											  FROM METER_CALENDAR A
											  WHERE A.CASE_ID = GA.BASE_CASE_ID
												AND A.METER_ID = v_METER_ID
												AND A.CALENDAR_TYPE = ACCOUNTS_METERS.c_CALENDAR_TYPE_FORECAST
												AND A.BEGIN_DATE <= v_UF_END_DATE
												AND NVL(A.END_DATE, CONSTANTS.HIGH_DATE) >= v_UF_BEGIN_DATE
												AND v_MODEL_OPTION = ACCOUNTS_METERS.c_ACCT_MODEL_OPTION_METER) LOOP
					-- Reset the total profile value
					v_TOTAL_PROFILE := 0;
					v_PROFILE.DELETE;

					-- Validate
					BEGIN
						-- Check the "Skip Usage Factors without Current History" setting, Default to 0 if blank
						v_SKIP_USAGE_FACTOR := UT.BOOLEAN_FROM_STRING(NVL(GET_DICTIONARY_VALUE('Skip Usage Factors without Current History', v_MODEL_ID, 'Load Management', 'Usage Factors'), '0'));

						IF v_SKIP_USAGE_FACTOR THEN
							VALIDATE_CALENDAR_PROFILE_DATA(p_SERVICE_CONSUMPTION.BEGIN_DATE,
								p_SERVICE_CONSUMPTION.END_DATE,
								v_CALENDAR_ASSIGNMENT.CALENDAR_ID);
						END IF;

						-- Get Current Date
							v_CURRENT_DATE := p_SERVICE_CONSUMPTION.BEGIN_DATE;

						-- Loop for Date Range within Consumption Record
							WHILE v_CURRENT_DATE <= p_SERVICE_CONSUMPTION.END_DATE LOOP

						   -- Does this data already exist in the cache?
						   GET_TOTAL_PROFILE_VALUE(v_WEATHER_STATION_ID,
												   v_CALENDAR_ASSIGNMENT.CALENDAR_ID,
												   v_EDC_ID,
												   v_CURRENT_DATE,
												   v_PROFILE_VALUE_FOR_DATE,
												   b_PROFILE_DATA_EXISTS_ALREADY);

  							-- If it does not exist, then query FS and FP package
							IF NOT b_PROFILE_DATA_EXISTS_ALREADY THEN
								-- Get the profile value for each day
								FS.COMPOSITE_PROFILE_FOR_CALENDAR(v_WEATHER_STATION_ID,
															  v_CALENDAR_ASSIGNMENT.CALENDAR_ID,
															  v_EDC_ID,
															  v_CURRENT_DATE,
															  v_PROFILE,
															  b_IS_DEBUG_ENABLED,
															  CONSTANTS.CODE_ACTUAL);

								-- Calculate total for the day
								v_PROFILE_INDEX := v_PROFILE.FIRST;
								WHILE v_PROFILE.EXISTS(v_PROFILE_INDEX) LOOP
								    -- Calculate profile value for the day
								    v_PROFILE_VALUE_FOR_DATE := NVL(v_PROFILE_VALUE_FOR_DATE, 0) + v_PROFILE(v_PROFILE_INDEX);
									v_PROFILE_INDEX := v_PROFILE.NEXT(v_PROFILE_INDEX);
								END LOOP;

								-- Increment total profile value
								v_TOTAL_PROFILE := v_TOTAL_PROFILE + v_PROFILE_VALUE_FOR_DATE;

								-- Update the lookup cache
								INSERT INTO CALENDAR_PROFILE_VALUE(WEATHER_STATION_ID,
																	 CALENDAR_ID,
																	 EDC_ID,
																	 PROFILE_DATE,
																	 PROFILE_VALUE
																	)
								VALUES(v_WEATHER_STATION_ID,
									   v_CALENDAR_ASSIGNMENT.CALENDAR_ID,
									   v_EDC_ID,
									   v_CURRENT_DATE,
									   v_PROFILE_VALUE_FOR_DATE);
						    ELSE -- this is looked-up value from Cache
							    v_TOTAL_PROFILE := v_TOTAL_PROFILE + v_PROFILE_VALUE_FOR_DATE;
							END IF;-- if condition for recalculating profile data

							-- Advance the Current Date
							v_CURRENT_DATE := v_CURRENT_DATE + 1;
							v_PROFILE_VALUE_FOR_DATE := 0;
						END LOOP; -- consumption period

						-- Put Usage Factor for this Calendar period
						IF v_TOTAL_PROFILE <> 0 THEN
							v_USAGE_FACTOR_VAL := p_SERVICE_CONSUMPTION.METERED_USAGE / v_TOTAL_PROFILE;

							PUT_USAGE_FACTOR(v_ACCOUNT_ID,
								v_METER_ID,
								v_MODEL_OPTION,
								GREATEST(v_CALENDAR_ASSIGNMENT.BEGIN_DATE,v_UF_BEGIN_DATE),
								LEAST(NVL(v_CALENDAR_ASSIGNMENT.END_DATE, CONSTANTS.HIGH_DATE),v_UF_END_DATE),
								v_USAGE_FACTOR_VAL,
								v_CALENDAR_ASSIGNMENT.CALENDAR_ID,
								p_SERVICE_CONSUMPTION.BEGIN_DATE,
								p_SERVICE_CONSUMPTION.END_DATE);

							v_COUNT := v_COUNT + 1;
						ELSE
							LOGS.LOG_WARN('PROCESS_USAGE_FACTORS - Total Calendar Profile value was 0 for ' || TEXT_UTIL.TO_CHAR_ENTITY(v_CALENDAR_ASSIGNMENT.CALENDAR_ID, EC.ED_CALENDAR));
						END IF;
						v_CALENDAR_COUNT := v_CALENDAR_COUNT + 1;
					EXCEPTION
						WHEN OTHERS THEN
							ERRS.LOG_AND_CONTINUE('Skipping Usage Factor for Account (Ext Id): ' || TEXT_UTIL.TO_CHAR_ENTITY(v_ACCOUNT_ID,EC.ED_ACCOUNT, p_IDENTIFIER_TYPE => EI.g_DEFAULT_IDENTIFIER_TYPE)
							 || ', Consumption Date Range: ' || TEXT_UTIL.TO_CHAR_DATE_RANGE(p_SERVICE_CONSUMPTION.BEGIN_DATE, p_SERVICE_CONSUMPTION.END_DATE)
							 || ', Calendar: ' || TEXT_UTIL.TO_CHAR_ENTITY(v_CALENDAR_ASSIGNMENT.CALENDAR_ID, EC.ED_CALENDAR) || '.'
							 , LOGS.c_LEVEL_INFO);
					END;
				END LOOP; -- calendars

				IF v_CALENDAR_COUNT = 0 THEN
					LOGS.LOG_DEBUG('No Usage Factors processed for ' || TEXT_UTIL.TO_CHAR_DATE_RANGE(v_UF_BEGIN_DATE,v_UF_END_DATE) || '. No Calendars are assigned during this time period.');
				END IF;

			END IF; -- date condition
		END LOOP; -- years
	ELSE -- 'use tou' is true
		LOGS.LOG_WARN('Skipping PROCESS_USAGE_FACTORS. TOU Usage Factors are not currently supported. '
			|| 'Consumption Template = ' || TEXT_UTIL.TO_CHAR_ENTITY(p_SERVICE_CONSUMPTION.TEMPLATE_ID,EC.ED_TEMPLATE)
			|| ', Account Use TOU flag = ' || v_ACCOUNT_USE_TOU
			|| ', Meter Use TOU flag = ' || v_METER_USE_TOU);
	END IF;


  <<PROCESS_USAGE_FACTOR_END>>
  NULL;

    IF b_IS_DEBUG_ENABLED THEN
	   LOGS.LOG_INFO_MORE_DETAIL(p_EVENT_TEXT => 'Updated ' || v_COUNT || ' Usage Factor records.');
	END IF;

END PROCESS_USAGE_FACTORS;
----------------------------------------------------------------------------------------------------
PROCEDURE IMPORT_SERVICE_CONS_DATA
	(
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_BEGIN_DATE DATE,
	p_END_DATE IN DATE,
	p_BILLED_USAGE IN NUMBER,
	p_BILLED_DEMAND IN NUMBER,
	p_METERED_USAGE IN NUMBER,
	p_METERED_DEMAND IN NUMBER,
	p_METERS_READ IN NUMBER,
	p_METER_READING IN VARCHAR,
	p_RECEIVED_DATE IN DATE,
	p_IGNORE_CONSUMPTION IN NUMBER,
	p_SUCCESS IN OUT BOOLEAN,
	p_CONSUMPTION_ID OUT NUMBER,
	p_TEMPLATE_ID IN NUMBER := CONSTANTS.NOT_ASSIGNED,
	p_PERIOD_ID IN NUMBER := CONSTANTS.NOT_ASSIGNED,
	p_BILL_CODE IN CHAR := GA.BILL_CONSUMPTION,
	p_CONSUMPTION_CODE IN CHAR := GA.ACTUAL_CONSUMPTION,
	p_UNIT_OF_MEASURE IN VARCHAR2 := NULL,
	p_SCENARIO_ID IN NUMBER := GA.BASE_SCENARIO_ID,
	p_EDC_ID IN NUMBER := NULL,
	p_ESP_ID IN NUMBER := NULL,
	p_PSE_ID IN NUMBER := NULL,
	p_POOL_ID IN NUMBER := NULL,
	p_READ_BEGIN_DATE IN DATE := NULL,
	p_READ_END_DATE IN DATE := NULL,
	p_CONVERSION_FACTOR IN NUMBER := NULL,
	p_BILL_CYCLE_MONTH IN DATE := NULL,
	p_BILL_PROCESSED_DATE IN DATE := NULL
	) AS

	v_AGGREGATE_ID 			NUMBER;
	v_ACCOUNT_MODEL_OPTION 	ACCOUNT.ACCOUNT_MODEL_OPTION%TYPE;

	v_LOAD_SETTLEMENT_PROF	BOOLEAN := FALSE; -- not applicable for non-interval data
	v_LOAD_USAGE_DATA 		BOOLEAN := TRUE;

	v_ACCOUNT_NAME	ACCOUNT.ACCOUNT_NAME%TYPE := TEXT_UTIL.TO_CHAR_ENTITY(p_ACCOUNT_ID,
																		EC.ED_ACCOUNT);
	v_METER_NAME	METER.METER_NAME%TYPE := TEXT_UTIL.TO_CHAR_ENTITY(p_METER_ID,
																EC.ED_METER);
	v_SERVICE_STATE	SERVICE_STATE%ROWTYPE;
	v_CONS			SERVICE_CONSUMPTION%ROWTYPE;

	v_MODEL_ID NUMBER(1);
	v_UNIT_OF_MEASURE SERVICE_CONSUMPTION.UNIT_OF_MEASUREMENT%TYPE;
BEGIN

	-- Validate parameters and account relationships for this date
	VALIDATE_SVC_FOR_USAGE_DATA(p_ACCOUNT_ID, v_ACCOUNT_NAME, p_SERVICE_LOCATION_ID,
								p_METER_ID, v_METER_NAME, p_BEGIN_DATE, p_END_DATE,
								p_EDC_ID, p_ESP_ID,	p_PSE_ID, p_POOL_ID, FALSE, p_CONSUMPTION_CODE = GA.HISTORICAL_CONSUMPTION,
                                v_AGGREGATE_ID, v_ACCOUNT_MODEL_OPTION, p_SUCCESS,
								v_LOAD_SETTLEMENT_PROF, v_LOAD_USAGE_DATA);

	IF p_SUCCESS AND v_LOAD_USAGE_DATA THEN
		v_SERVICE_STATE := CS.GET_SERVICE_STATE(GA.DEFAULT_MODEL, p_SCENARIO_ID, p_ACCOUNT_ID, p_SERVICE_LOCATION_ID, p_METER_ID, v_AGGREGATE_ID, GA.ACTUAL_SERVICE,
												p_END_DATE, p_AS_OF_DATE, p_EDC_ID, p_ESP_ID, p_PSE_ID, p_POOL_ID, g_APPLY_UFE_CODE, g_UNKNOWN);

		-- Default the UOM to that of the Account when null
		IF p_UNIT_OF_MEASURE IS NULL THEN
			SELECT MIN(A.MODEL_ID)
			INTO v_MODEL_ID
			FROM ACCOUNT A
			WHERE A.ACCOUNT_ID = p_ACCOUNT_ID;

			IF v_MODEL_ID = CONSTANTS.GAS_MODEL THEN
				v_UNIT_OF_MEASURE := GA.GAS_UNIT_OF_MEASURMENT;
			ELSIF v_MODEL_ID = CONSTANTS.ELECTRIC_MODEL THEN
				v_UNIT_OF_MEASURE := GA.ELECTRIC_UNIT_OF_MEASURMENT;
			END IF;
		ELSE
			v_UNIT_OF_MEASURE := p_UNIT_OF_MEASURE;
		END IF;

		v_CONS.SERVICE_ID := v_SERVICE_STATE.SERVICE_ID;
		v_CONS.BEGIN_DATE := p_BEGIN_DATE;
		v_CONS.END_DATE := p_END_DATE;
		v_CONS.BILL_CODE := p_BILL_CODE;
		v_CONS.CONSUMPTION_CODE := p_CONSUMPTION_CODE;
		v_CONS.RECEIVED_DATE := p_RECEIVED_DATE;
		v_CONS.TEMPLATE_ID := p_TEMPLATE_ID;
		v_CONS.PERIOD_ID := p_PERIOD_ID;
		v_CONS.UNIT_OF_MEASUREMENT := v_UNIT_OF_MEASURE;
		v_CONS.METER_TYPE := CS.GET_METER_TYPE(p_ACCOUNT_ID, p_METER_ID);
		v_CONS.METER_READING := p_METER_READING;
		v_CONS.BILLED_USAGE := NVL(p_BILLED_USAGE, p_METERED_USAGE);
		v_CONS.BILLED_DEMAND := NVL(p_BILLED_DEMAND, p_METERED_DEMAND);
		v_CONS.METERED_USAGE := NVL(p_METERED_USAGE, p_BILLED_USAGE);
		v_CONS.METERED_DEMAND := NVL(p_METERED_DEMAND, p_BILLED_DEMAND);
		v_CONS.METERS_READ := p_METERS_READ;
		v_CONS.CONVERSION_FACTOR := NVL(p_CONVERSION_FACTOR, 0);
		v_CONS.IGNORE_CONSUMPTION := p_IGNORE_CONSUMPTION;
		v_CONS.BILL_CYCLE_MONTH := CASE WHEN p_BILL_CYCLE_MONTH = c_AUTO_BILL_CYCLE THEN
											GET_BILL_CYCLE_MONTH(p_ACCOUNT_ID, p_METER_ID, p_END_DATE)
										ELSE
											p_BILL_CYCLE_MONTH
										END;
		v_CONS.BILL_PROCESSED_DATE := p_BILL_PROCESSED_DATE;
		v_CONS.READ_BEGIN_DATE := NVL(p_READ_BEGIN_DATE, p_BEGIN_DATE);
		v_CONS.READ_END_DATE := NVL(p_READ_END_DATE, p_END_DATE);
		v_CONS.ENTRY_DATE := SYSDATE;

		PUT_SERVICE_CONSUMPTION(v_CONS, p_CONSUMPTION_ID);
	END IF;

	-- If we are not loading Usage Data then we want to indicate not successful
	p_SUCCESS := p_SUCCESS AND v_LOAD_USAGE_DATA;

END IMPORT_SERVICE_CONS_DATA;
----------------------------------------------------------------------------------------------------
PROCEDURE IMPORT_SERVICE_CONS_DATA
	(
	p_SETTLEMENT_TYPE_ID IN NUMBER,
	p_ACCOUNT_ID IN NUMBER,
	p_SERVICE_LOCATION_ID IN NUMBER,
	p_METER_ID IN NUMBER,
	p_AS_OF_DATE IN DATE,
	p_BEGIN_DATE DATE,
	p_END_DATE IN DATE,
	p_BILLED_USAGE IN NUMBER,
	p_BILLED_DEMAND IN NUMBER,
	p_METERED_USAGE IN NUMBER,
	p_METERED_DEMAND IN NUMBER,
	p_METERS_READ IN NUMBER,
	p_METER_READING IN VARCHAR,
	p_RECEIVED_DATE IN DATE,
	p_IGNORE_CONSUMPTION IN NUMBER,
	p_SUCCESS IN OUT BOOLEAN,
	p_CONSUMPTION_ID OUT NUMBER,
	p_TEMPLATE_ID IN NUMBER := CONSTANTS.NOT_ASSIGNED,
	p_PERIOD_ID IN NUMBER := CONSTANTS.NOT_ASSIGNED,
	p_BILL_CODE IN CHAR := GA.BILL_CONSUMPTION,
	p_UNIT_OF_MEASURE IN VARCHAR2 := NULL,
	p_EDC_ID IN NUMBER := NULL,
	p_ESP_ID IN NUMBER := NULL,
	p_PSE_ID IN NUMBER := NULL,
	p_POOL_ID IN NUMBER := NULL,
	p_READ_BEGIN_DATE IN DATE := NULL,
	p_READ_END_DATE IN DATE := NULL,
	p_CONVERSION_FACTOR IN NUMBER := NULL,
	p_BILL_CYCLE_MONTH IN DATE := NULL,
	p_BILL_PROCESSED_DATE IN DATE := NULL
	) AS
v_SCENARIO_ID	NUMBER;
v_CONS_CODE	CHAR(1);
BEGIN
	SELECT SCENARIO_ID,
		CASE SERVICE_CODE
			WHEN GA.BACKCAST_SERVICE THEN GA.PRELIMINARY_CONSUMPTION
			ELSE SERVICE_CODE
			END
	INTO v_SCENARIO_ID, v_CONS_CODE
	FROM SETTLEMENT_TYPE
	WHERE SETTLEMENT_TYPE_ID = p_SETTLEMENT_TYPE_ID;

	IMPORT_SERVICE_CONS_DATA(p_ACCOUNT_ID, p_SERVICE_LOCATION_ID, p_METER_ID,
						p_AS_OF_DATE, p_BEGIN_DATE, p_END_DATE, p_BILLED_USAGE, p_BILLED_DEMAND,
						p_METERED_USAGE, p_METERED_DEMAND, p_METERS_READ,
						p_METER_READING, p_RECEIVED_DATE, p_IGNORE_CONSUMPTION,
						p_SUCCESS, p_CONSUMPTION_ID, p_TEMPLATE_ID, p_PERIOD_ID,
						p_BILL_CODE, v_CONS_CODE, p_UNIT_OF_MEASURE, v_SCENARIO_ID,
						p_EDC_ID, p_ESP_ID, p_PSE_ID, p_POOL_ID,
						p_READ_BEGIN_DATE, p_READ_END_DATE, p_CONVERSION_FACTOR,
						p_BILL_CYCLE_MONTH, p_BILL_PROCESSED_DATE);
END IMPORT_SERVICE_CONS_DATA;
----------------------------------------------------------------------------------------------------
PROCEDURE ACCEPT_INTERVAL_USAGE_INTERNAL
	(
	p_AS_OF_DATE IN DATE,
	p_DATE_FORMAT IN VARCHAR,
	p_USE_EXTERNAL_IDENTIFIER IN NUMBER,
	p_RECORD IN PARSE_UTIL.BIG_STRING_TABLE_MP,
	p_TIME_ZONE IN VARCHAR,
	p_SUCCESS IN OUT BOOLEAN
	) AS

	-- Accept Interval Usage for an Account/Meter and determine the Service Providers
	-- from internal sources.

	v_ACCOUNT_NAME ACCOUNT.ACCOUNT_NAME%TYPE;
	v_METER_NAME METER.METER_NAME%TYPE;
	v_SERVICE_DATE DATE;
	v_SCENARIO_ID SCENARIO.SCENARIO_ID%TYPE;

	v_LOAD_DATE DATE;

	v_INTERVAL_TYPE VARCHAR2(32);
	v_DATA_FLD_COUNT NUMBER(9);

	v_INTERVAL_DIVISOR NUMBER(9);

	v_IDENT_TYPE CHAR;

	v_ACCOUNT_ID ACCOUNT.ACCOUNT_NAME%TYPE;
	v_METER_ID METER.METER_ID%TYPE;
	v_SERVICE_LOCATION_ID SERVICE_LOCATION.SERVICE_LOCATION_ID%TYPE;
	v_ACCOUNT_MODEL_OPTION ACCOUNT.ACCOUNT_MODEL_OPTION%TYPE;

	v_OLD_SUCCESS BOOLEAN;

	v_USAGE_VAL GA.FLOAT_TABLE;
	v_USAGE_DATE GA.DATE_TABLE;

BEGIN

	SELECT DECODE(p_USE_EXTERNAL_IDENTIFIER, 1, 'X', 'N') INTO v_IDENT_TYPE FROM DUAL;

	v_ACCOUNT_NAME := LTRIM(RTRIM(p_RECORD(1)));
	v_METER_NAME := LTRIM(RTRIM(p_RECORD(2)));
	v_SERVICE_DATE := DATA_IMPORT.IMPORT_DATE(p_RECORD(3),
											 p_DATE_FORMAT,
											 'Service Date',
											 p_SUCCESS);

	v_ACCOUNT_ID := CS.GET_ACCOUNT_ID(v_ACCOUNT_NAME, v_IDENT_TYPE);

	IF v_ACCOUNT_ID <= 0 THEN
		DATA_IMPORT.LOG_IMPORT_ERROR('Account not found: ' || v_ACCOUNT_NAME,
					p_SUCCESS);
	ELSIF p_USE_EXTERNAL_IDENTIFIER = 1 THEN
		SELECT ACCOUNT_NAME INTO v_ACCOUNT_NAME
		FROM ACCOUNT
		WHERE ACCOUNT_ID = v_ACCOUNT_ID;
	END IF;

	IF v_ACCOUNT_ID > 0 THEN
		SELECT A.ACCOUNT_MODEL_OPTION INTO v_ACCOUNT_MODEL_OPTION
		FROM ACCOUNT A
		WHERE A.ACCOUNT_ID = v_ACCOUNT_ID;
	END IF;

	IF SUBSTR(v_ACCOUNT_MODEL_OPTION,1,1) = 'M' THEN
		v_METER_ID := GET_METER_ID(v_METER_NAME, v_IDENT_TYPE);

		IF v_METER_ID <= 0 THEN
			DATA_IMPORT.LOG_IMPORT_ERROR('Meter not found: ' || v_METER_NAME,
					p_SUCCESS);
		ELSIF p_USE_EXTERNAL_IDENTIFIER = 1 THEN
			SELECT METER_NAME INTO v_METER_NAME
			FROM METER
			WHERE METER_ID = v_METER_ID;
		END IF;

		v_SERVICE_LOCATION_ID := GET_METER_OWNER(v_METER_ID, v_SERVICE_DATE);

		IF v_SERVICE_LOCATION_ID <= 0 AND v_METER_ID > 0 THEN
			DATA_IMPORT.LOG_IMPORT_ERROR('Service location not found for the given Meter (' || v_METER_NAME
				|| ') on the given date: ' || v_SERVICE_DATE,
				p_SUCCESS);
		END IF;
	ELSE
		IF v_METER_NAME IS NOT NULL AND v_ACCOUNT_ID > 0 THEN
			DATA_IMPORT.LOG_IMPORT_ERROR('Meter (' || v_METER_NAME
						|| ') given, but the account model option is not meter.',
					p_SUCCESS);
		END IF;

		v_METER_ID := 0;
		v_SERVICE_LOCATION_ID := CS.GET_SERVICE_LOCATION_ID(v_ACCOUNT_ID, v_SERVICE_DATE);

		IF v_SERVICE_LOCATION_ID <= 0 AND v_ACCOUNT_ID > 0 THEN
			DATA_IMPORT.LOG_IMPORT_ERROR('Service location not found for the given Account (' || v_ACCOUNT_NAME
				|| ') on the given date: ' || v_SERVICE_DATE,
				p_SUCCESS);
		END IF;
	END IF;

	v_LOAD_DATE := BEGIN_HOUR_ENDING_CUT_DAY(v_SERVICE_DATE, p_TIME_ZONE);
	v_DATA_FLD_COUNT := p_RECORD.COUNT - 3;

	IF GA.DEFAULT_MODEL = GA.GAS_MODEL THEN
		-- 10/5/09 - BZ 21532 - DDZ - v_INTERVAL_TYPE was never being set for Gas Model
        v_INTERVAL_TYPE := 'DD';
		v_LOAD_DATE := TRUNC(v_LOAD_DATE);
		v_INTERVAL_DIVISOR := 1;
		IF v_DATA_FLD_COUNT <> 1 THEN
			DATA_IMPORT.LOG_IMPORT_ERROR('The file ' ||
								'has an unexpected number of data fields (' || v_DATA_FLD_COUNT ||
								'). Gas data is expected to have 1 data field per day.',
								p_SUCCESS);
		END IF;
	ELSE
		IF v_DATA_FLD_COUNT >= 23 AND v_DATA_FLD_COUNT <= 25 THEN
			v_INTERVAL_TYPE := 'HH'; -- HOURLY
		ELSIF v_DATA_FLD_COUNT >= 46 AND v_DATA_FLD_COUNT <= 50 THEN
			v_INTERVAL_TYPE := 'MI30'; -- HALF-HOURLY
		ELSIF v_DATA_FLD_COUNT >= 92 AND v_DATA_FLD_COUNT <= 100 THEN
			v_INTERVAL_TYPE := 'MI15'; -- QUARTER-HOURLY
		ELSE
			DATA_IMPORT.LOG_IMPORT_ERROR('The file ' ||
									'has an unexpected number of data fields (' || v_DATA_FLD_COUNT ||
									'). The data interval could not be determined.',
									p_SUCCESS);

			RETURN; -- NO POINT IN CONTINUING W/ NO INTERVAL
		END IF;
		v_INTERVAL_DIVISOR := DATE_UTIL.GET_INTERVAL_DIVISOR(CONSTANTS.INTERVAL_DAY, v_INTERVAL_TYPE, v_SERVICE_DATE, CUT_TIME_ZONE, NULL);
	END IF;

	FOR v_INDEX IN 4..p_RECORD.COUNT LOOP
		BEGIN
			v_OLD_SUCCESS := p_SUCCESS;
			v_USAGE_VAL(v_INDEX - 3) := DATA_IMPORT.IMPORT_NUMBER( p_RECORD(v_INDEX),
															'Usage Val',
															p_SUCCESS);

			EXIT WHEN v_OLD_SUCCESS <> p_SUCCESS;
			v_USAGE_DATE(v_INDEX - 3) := v_LOAD_DATE;
			v_LOAD_DATE := v_LOAD_DATE + 1/v_INTERVAL_DIVISOR;
		EXCEPTION
			--CHECK FOR SETTLEMENT_TYPE_NAME AT END OF LIST
			WHEN VALUE_ERROR THEN
				ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
				v_SCENARIO_ID := SCENARIO_FOR_SETTLEMENT_TYPE(p_RECORD(v_INDEX));
		END;
	END LOOP;

	IMPORT_SERVICE_LOAD_DATA(v_ACCOUNT_ID,
							v_SERVICE_LOCATION_ID,
							v_METER_ID,
							v_SERVICE_DATE,
							v_INTERVAL_TYPE,
							p_AS_OF_DATE,
							v_USAGE_VAL,
							v_USAGE_DATE,
							p_SUCCESS,
							v_SCENARIO_ID);

END ACCEPT_INTERVAL_USAGE_INTERNAL;
----------------------------------------------------------------------------------------------------
PROCEDURE ACCEPT_INTERVAL_USAGE_EXTERNAL
	(
	p_AS_OF_DATE IN DATE,
	p_DATE_FORMAT IN VARCHAR,
	p_RECORD IN OUT NOCOPY PARSE_UTIL.BIG_STRING_TABLE_MP,
	p_TIME_ZONE IN VARCHAR
	) AS

-- Accept Interval Usage for an Account/Meter and determine the Service Providers from external sources provided in the file stream.
-- TODO: This method was not updated as part of the Standard Import design item
-- 	We should update it in the future.

v_ACCOUNT_NAME ACCOUNT.ACCOUNT_NAME%TYPE;
v_EDC_NAME ENERGY_DISTRIBUTION_COMPANY.EDC_NAME%TYPE;
v_ESP_NAME ENERGY_SERVICE_PROVIDER.ESP_NAME%TYPE;
v_PSE_NAME PURCHASING_SELLING_ENTITY.PSE_NAME%TYPE;
v_LOSS_FACTOR_NAME LOSS_FACTOR.LOSS_FACTOR_NAME%TYPE;
v_SERVICE_DATE DATE;
v_LOAD_DATE DATE;
v_INDEX BINARY_INTEGER;
v_SERVICE_ID NUMBER;
v_ACCOUNT_ID NUMBER;
v_SERVICE_LOCATION_ID NUMBER;
v_ACCOUNT_SERVICE_ID NUMBER;
v_PROVIDER_SERVICE_ID NUMBER;
v_EDC_ID NUMBER;
v_ESP_ID NUMBER;
v_PSE_ID NUMBER;
v_LOSS_FACTOR_ID NUMBER;
v_AS_OF_DATE DATE;
v_IS_DST BOOLEAN := INSTR(p_TIME_ZONE,'D') > 0;
v_METER_TYPE CHAR(1);
v_USAGE_DATE GA.DATE_TABLE;
v_USAGE_VAL GA.FLOAT_TABLE;
v_TX_LOSS GA.FACTOR_TABLE;
v_DX_LOSS GA.FACTOR_TABLE;
v_UE_LOSS GA.FACTOR_TABLE;
v_SERVICE SERVICE%ROWTYPE;
v_SERVICE_STATE SERVICE_STATE%ROWTYPE;
v_PROVIDER_SERVICE PROVIDER_SERVICE%ROWTYPE;
v_IS_ADJUSTED_DAY BOOLEAN := FALSE;

BEGIN

	IF LOGS.IS_DEBUG_ENABLED THEN
		LOGS.LOG_DEBUG('ACCEPT_INTERVAL_USAGE_EXTERNAL');
		v_INDEX := p_RECORD.FIRST;
		WHILE v_INDEX <= p_RECORD.LAST LOOP
			LOGS.LOG_DEBUG(TO_CHAR(v_INDEX) || ',' || p_RECORD(v_INDEX));
			v_INDEX := p_RECORD.NEXT(v_INDEX);
		END LOOP;
	END IF;

	v_ACCOUNT_NAME := LTRIM(RTRIM(p_RECORD(2)));
	v_EDC_NAME := LTRIM(RTRIM(p_RECORD(3)));
	v_ESP_NAME := LTRIM(RTRIM(p_RECORD(4)));
	v_PSE_NAME := LTRIM(RTRIM(p_RECORD(5)));
	v_LOSS_FACTOR_NAME := LTRIM(RTRIM(p_RECORD(6)));
	v_SERVICE_DATE := TRUNC(TO_DATE(p_RECORD(7), p_DATE_FORMAT));

	ID.ID_FOR_ACCOUNT_EXTERNAL_IDENT(v_ACCOUNT_NAME, FALSE, v_ACCOUNT_ID);

	IF v_ACCOUNT_ID <= 0 THEN
		ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'ACCOUNT NOT DEFINED FOR ' || v_ACCOUNT_NAME);
	END IF;

	v_METER_TYPE := CS.GET_METER_TYPE(v_ACCOUNT_ID,0);
	IF v_METER_TYPE <> 'I' THEN
		ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'METER TYPE NOT INTERVAL FOR ACCOUNT ' || v_ACCOUNT_NAME);
	END IF;

	v_EDC_ID := ID.ID_FOR_EDC_EXTERNAL_IDENTIFIER(v_EDC_NAME);
	IF v_EDC_ID <= 0 THEN
		ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'EDC NOT DEFINED FOR ' || v_EDC_NAME);
	END IF;

	v_ESP_ID := ID.ID_FOR_ESP_EXTERNAL_IDENTIFIER(v_ESP_NAME);
	IF v_ESP_ID <= 0 THEN
	    ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'ESP NOT DEFINED FOR ' || v_ESP_NAME);
	END IF;

	v_PSE_ID := ID.ID_FOR_PSE_EXTERNAL_IDENTIFIER(v_PSE_NAME);
	IF v_PSE_ID <= 0 THEN
	    ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'PSE NOT DEFINED FOR ' || v_PSE_NAME);
	END IF;

	v_SERVICE_LOCATION_ID := CS.GET_SERVICE_LOCATION_ID(v_ACCOUNT_ID, TRUNC(v_SERVICE_DATE));
	IF v_SERVICE_LOCATION_ID <= 0 THEN
	    ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'SERVICE LOCATION NOT DEFINED FOR ' || v_ACCOUNT_NAME);
	END IF;

	ID.ID_FOR_LOSS_FACTOR(v_LOSS_FACTOR_NAME, FALSE, v_LOSS_FACTOR_ID);
	IF v_LOSS_FACTOR_ID <= 0 THEN
	    ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'LOSS FACTOR NOT DEFINED FOR ' || v_LOSS_FACTOR_NAME);
	END IF;

	IF GA.VERSION_ACTUAL THEN
		v_AS_OF_DATE := CORRECTED_AS_OF_DATE('SETTLEMENT', p_AS_OF_DATE);
	ELSE
		v_AS_OF_DATE := LOW_DATE;
	END IF;

	CS.GET_ACCOUNT_SERVICE_ID(v_ACCOUNT_ID, v_SERVICE_LOCATION_ID, CONSTANTS.NOT_ASSIGNED, CONSTANTS.NOT_ASSIGNED, v_ACCOUNT_SERVICE_ID);
	CS.GET_PROVIDER_SERVICE_ID(v_EDC_ID, v_ESP_ID, v_PSE_ID, v_PROVIDER_SERVICE_ID);
	v_SERVICE_STATE := GET_PROVIDER_SERVICE_STATE(v_ACCOUNT_SERVICE_ID, v_PROVIDER_SERVICE_ID, TRUNC(v_SERVICE_DATE), v_AS_OF_DATE);
	IF v_SERVICE_STATE.SERVICE_ID <= 0 THEN
		ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'ACCOUNT SERVICE NOT DEFINED FOR ' || v_ACCOUNT_NAME);
	END IF;

-- Data is in positions 8..31 (24 values).
	v_IS_ADJUSTED_DAY := FALSE;
	IF v_IS_DST AND p_RECORD.COUNT = 31 THEN
		IF TRUNC(v_SERVICE_DATE) = TRUNC(DST_SPRING_AHEAD_DATE(v_SERVICE_DATE)) THEN
			v_IS_ADJUSTED_DAY := TRUE;
			IF GA.DST_SPRING_AHEAD_OPTION = 'A' THEN
				p_RECORD.DELETE(9);
			ELSIF GA.DST_SPRING_AHEAD_OPTION = 'B' THEN
				p_RECORD.DELETE(10);
			ELSIF GA.DST_SPRING_AHEAD_OPTION = 'C' THEN
				p_RECORD.DELETE(31);
			END IF;
		ELSIF TRUNC(v_SERVICE_DATE) = TRUNC(DST_FALL_BACK_DATE(v_SERVICE_DATE)) THEN
			IF GA.DST_FALL_BACK_OPTION = 'A' THEN
				FOR v_INDEX IN REVERSE 10..32 LOOP
					p_RECORD(v_INDEX) := p_RECORD(v_INDEX-1);
				END LOOP;
			ELSIF GA.DST_FALL_BACK_OPTION = 'B' THEN
				p_RECORD(32) := 0;
			END IF;
		END IF;
	END IF;

	v_LOAD_DATE := BEGIN_HOUR_ENDING_CUT_DAY(v_SERVICE_DATE, p_TIME_ZONE);
	v_INDEX := 8;
    WHILE v_INDEX <= p_RECORD.LAST LOOP
		IF LOGS.IS_DEBUG_ENABLED THEN
			LOGS.LOG_DEBUG(TO_CHAR(v_SERVICE_ID) || ',' || UT.TRACE_DATE(v_LOAD_DATE) || ',' || p_RECORD(v_INDEX));
		END IF;
		v_USAGE_VAL(v_INDEX - 7) := p_RECORD(v_INDEX);
		v_USAGE_DATE(v_INDEX - 7) := v_LOAD_DATE;
		v_LOAD_DATE := GET_NEXT_CUT_DATE(v_LOAD_DATE, 3600, v_IS_ADJUSTED_DAY);
		v_INDEX := p_RECORD.NEXT(v_INDEX);
	END LOOP;

	v_SERVICE := CS.GET_SERVICE(v_SERVICE_STATE.SERVICE_ID);
	v_PROVIDER_SERVICE := CS.GET_PROVIDER_SERVICE(v_SERVICE.PROVIDER_SERVICE_ID);

	FS.APPLY_LOSS_FACTORS(v_SERVICE.ACCOUNT_SERVICE_ID, v_PROVIDER_SERVICE.EDC_ID, v_SERVICE_DATE, v_USAGE_VAL, v_TX_LOSS, v_DX_LOSS, v_UE_LOSS, TRUE);
	STORE_SERVICE_LOAD(v_SERVICE.SERVICE_ID, GA.ACTUAL_SERVICE, v_USAGE_DATE, v_USAGE_VAL, v_TX_LOSS, v_DX_LOSS, v_UE_LOSS);

END ACCEPT_INTERVAL_USAGE_EXTERNAL;
----------------------------------------------------------------------------------------------------
PROCEDURE ACCEPT_INTERVAL_USAGE_RECORD
	(
	p_AS_OF_DATE IN DATE,
	p_DATE_FORMAT IN VARCHAR,
	p_USE_EXTERNAL_IDENTIFIER IN NUMBER,
	p_LINE IN VARCHAR2,
	p_TIME_ZONE IN VARCHAR,
	p_DELIMITER IN VARCHAR,
	p_SUCCESS IN OUT BOOLEAN
	) AS

v_RECORD PARSE_UTIL.BIG_STRING_TABLE_MP;

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	PARSE_UTIL.TOKENS_FROM_BIG_STRING(p_LINE,p_DELIMITER, v_RECORD);
	IF v_RECORD.COUNT > 0 THEN
		IF v_RECORD(v_RECORD.FIRST)  = '@' THEN
			ACCEPT_INTERVAL_USAGE_EXTERNAL(p_AS_OF_DATE, p_DATE_FORMAT, v_RECORD, p_TIME_ZONE);
		ELSE
			ACCEPT_INTERVAL_USAGE_INTERNAL(p_AS_OF_DATE, p_DATE_FORMAT, p_USE_EXTERNAL_IDENTIFIER, v_RECORD, p_TIME_ZONE, p_SUCCESS);
		END IF;
	END IF;

END ACCEPT_INTERVAL_USAGE_RECORD;
----------------------------------------------------------------------------------------------------
PROCEDURE ALLOCATION_DELETE
	(
	p_MODEL_ID IN NUMBER,
	p_SCENARIO_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_METER_TYPE IN CHAR
	) AS

v_BEGIN_DATE DATE;
v_END_DATE DATE;
v_DAYS NUMBER(9);
v_BLOCK_BEGIN_DATE DATE;
v_BLOCK_END_DATE DATE;
v_AS_OF_DATE DATE := LOW_DATE;

BEGIN

	IF GA.VERSION_ACTUAL THEN
		v_AS_OF_DATE := CORRECTED_AS_OF_DATE(p_AS_OF_DATE,'Usage Allocation');
	END IF;

	v_DAYS := TO_NUMBER(MODEL_VALUE_AT_KEY(p_MODEL_ID,	'Forecasting',	'Delete', 'Days Per Transaction'));
	IF v_DAYS IS NULL THEN v_DAYS := p_END_DATE - p_BEGIN_DATE + 2; END IF;

	v_BLOCK_BEGIN_DATE := p_BEGIN_DATE;
	SELECT LEAST(p_BEGIN_DATE + v_DAYS, p_END_DATE) INTO v_BLOCK_END_DATE FROM DUAL;

	WHILE v_BLOCK_BEGIN_DATE < p_END_DATE LOOP

			UT.CUT_DATE_RANGE(p_MODEL_ID, v_BLOCK_BEGIN_DATE, v_BLOCK_END_DATE, g_LOCAL_TIME_ZONE, v_BEGIN_DATE, v_END_DATE);

		DELETE SERVICE_STATE
		WHERE SERVICE_ID IN
			(SELECT SERVICE_ID
			FROM SERVICE
			WHERE MODEL_ID = p_MODEL_ID
				AND SCENARIO_ID = p_SCENARIO_ID
				AND AS_OF_DATE = v_AS_OF_DATE)
			AND SERVICE_CODE = GA.ACTUAL_SERVICE
			AND SERVICE_DATE BETWEEN v_BLOCK_BEGIN_DATE AND v_BLOCK_END_DATE
			AND (METER_TYPE = p_METER_TYPE OR p_METER_TYPE = '*');

		DELETE PROCESS_STATUS
		WHERE PROCESS_NAME = 'Usage Allocation'
			AND PROCESS_DATE BETWEEN v_BLOCK_BEGIN_DATE AND v_BLOCK_END_DATE
			AND PROCESS_AS_OF_DATE = v_AS_OF_DATE;

		DELETE SERVICE_OBLIGATION_LOAD
		WHERE SERVICE_OBLIGATION_ID IN
			(SELECT SERVICE_OBLIGATION_ID
			FROM SERVICE_OBLIGATION
			WHERE MODEL_ID = p_MODEL_ID
				AND SCENARIO_ID = p_SCENARIO_ID
				AND AS_OF_DATE = v_AS_OF_DATE)
			AND SERVICE_CODE = GA.ACTUAL_SERVICE
			AND LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND LOAD_CODE = GA.STANDARD;

		DELETE EDC_SYSTEM_UFE_LOAD
		WHERE MODEL_ID = p_MODEL_ID
			AND SCENARIO_ID = p_SCENARIO_ID
			AND AS_OF_DATE = v_AS_OF_DATE
			AND SERVICE_CODE = GA.ACTUAL_SERVICE
			AND LOAD_DATE BETWEEN v_BEGIN_DATE AND v_END_DATE
			AND LOAD_CODE = GA.STANDARD
			AND EDC_ID = EDC_ID;

		COMMIT;
		v_BLOCK_BEGIN_DATE := v_BLOCK_END_DATE + 1;
		SELECT LEAST(v_BLOCK_BEGIN_DATE + v_DAYS, p_END_DATE) INTO v_BLOCK_END_DATE FROM DUAL;
	END LOOP;

END ALLOCATION_DELETE;
----------------------------------------------------------------------------------------------------
PROCEDURE CONSUMPTION_DELETE
	(
	p_MODEL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_METER_TYPE IN CHAR
	) AS

BEGIN

	IF p_BEGIN_DATE = LOW_DATE AND p_END_DATE = HIGH_DATE AND p_METER_TYPE = '*' THEN
		EXECUTE IMMEDIATE 'TRUNCATE TABLE SERVICE_CONSUMPTION';
	ELSE
		DELETE SERVICE_CONSUMPTION
		WHERE SERVICE_ID IN
			(SELECT DISTINCT SERVICE_ID
			FROM SERVICE
			WHERE MODEL_ID = p_MODEL_ID
				AND SCENARIO_ID = GA.BASE_SCENARIO_ID
				AND AS_OF_DATE = p_AS_OF_DATE)
			AND BEGIN_DATE <= p_END_DATE
			AND END_DATE >= p_BEGIN_DATE
			AND (METER_TYPE = p_METER_TYPE OR p_METER_TYPE = '*')
		AND UNIT_OF_MEASUREMENT = GA.DEFAULT_UNIT_OF_MEASUREMENT;
	END IF;

END CONSUMPTION_DELETE;
----------------------------------------------------------------------------------------------------
PROCEDURE IMPORT_AREA_LOAD
	(
	p_AREA_NAME IN VARCHAR,
	p_LOAD_CODE IN VARCHAR,
	p_LOAD_DATE IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_DATE_FORMAT IN VARCHAR DEFAULT 'DD-MON-YYYY',
	p_INTERVAL IN VARCHAR DEFAULT 3600,
	p_LOAD_VALUES IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_TIME_ZONE VARCHAR(3);
v_LOCAL_DATE DATE;
v_INTERVAL NUMBER;
v_STRING_TABLE GA.STRING_TABLE;
v_INDEX BINARY_INTEGER;
v_AREA_LOAD AREA_LOAD%ROWTYPE;

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	v_LOCAL_DATE := TO_DATE(p_LOAD_DATE, p_DATE_FORMAT);
	v_TIME_ZONE := TIME_ZONE_FOR_DAY(v_LOCAL_DATE, p_TIME_ZONE);
	v_AREA_LOAD.CASE_ID := GA.BASE_CASE_ID;
	v_AREA_LOAD.LOAD_DATE := NEW_TIME(v_LOCAL_DATE, v_TIME_ZONE, CUT_TIME_ZONE);
	v_AREA_LOAD.AS_OF_DATE := SYSDATE;
	v_INTERVAL := TO_NUMBER(LTRIM(RTRIM(p_INTERVAL)));

	ID.ID_FOR_AREA(p_AREA_NAME, FALSE, v_AREA_LOAD.AREA_ID);
	IF v_AREA_LOAD.AREA_ID <= 0 THEN
		ERRS.RAISE(MSGCODES.c_ERR_NO_SUCH_ENTRY, 'AREA NOT DEFINED FOR ' || p_AREA_NAME);
	END IF;

	SELECT DECODE(UPPER(SUBSTR(p_LOAD_CODE,1,1)), 'A','A','F') INTO v_AREA_LOAD.LOAD_CODE FROM DUAL;
	UT.TOKENS_FROM_STRING(p_LOAD_VALUES,',', v_STRING_TABLE);
	v_INDEX := v_STRING_TABLE.FIRST;

	FOR v_INDEX IN v_STRING_TABLE.FIRST..v_STRING_TABLE.LAST LOOP
 		v_AREA_LOAD.LOAD_VAL := TO_NUMBER(v_STRING_TABLE(v_INDEX));
		CS.PUT_AREA_LOAD(v_AREA_LOAD, p_STATUS);
		IF p_STATUS < GA.SUCCESS THEN
			ROLLBACK;
			RETURN;
		END IF;
		v_AREA_LOAD.LOAD_DATE := ADD_SECONDS_TO_DATE(v_AREA_LOAD.LOAD_DATE, v_INTERVAL);
	END LOOP;
	COMMIT;

END IMPORT_AREA_LOAD;
----------------------------------------------------------------------------------------------------
PROCEDURE ACCEPT_ACCOUNT_SERVICE
	(
	p_ACCOUNT_NAME IN VARCHAR,
	p_METER_NAME IN VARCHAR,
	p_ESP_NAME IN VARCHAR,
	p_SERVICE_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS

v_ACCOUNT_ID NUMBER;
v_SERVICE_LOCATION_ID NUMBER;
v_METER_ID NUMBER;
v_AGGREGATE_ID NUMBER;
v_ACCOUNT_MODEL_OPTION CHAR(1);
v_ESP_ID NUMBER;
v_SERVICE_STATE SERVICE_STATE%ROWTYPE;
v_SCENARIO_ID NUMBER(9) := GA.BASE_SCENARIO_ID;

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	v_ACCOUNT_ID := CS.GET_ACCOUNT_ID(p_ACCOUNT_NAME);
	v_ACCOUNT_MODEL_OPTION := GET_ACCOUNT_MODEL_OPTION(v_ACCOUNT_ID);
	v_AGGREGATE_ID := 0;

	IF v_ACCOUNT_MODEL_OPTION = 'M' THEN
	    v_METER_ID := GET_METER_ID(p_METER_NAME);
		v_SERVICE_LOCATION_ID := GET_METER_OWNER(v_METER_ID, p_SERVICE_DATE);
	ELSE
		v_SERVICE_LOCATION_ID := CS.GET_SERVICE_LOCATION_ID(v_ACCOUNT_ID,	p_SERVICE_DATE);
	    v_METER_ID := 0;
		v_ESP_ID := CS.GET_ESP_ID(p_ESP_NAME);
		IF IS_AGGREGATE_ACCOUNT(v_ACCOUNT_ID) THEN
		    v_AGGREGATE_ID := GET_AGGREGATE_ID(v_ACCOUNT_ID, v_ESP_ID, p_SERVICE_DATE);
		END IF;
	END IF;

	v_SERVICE_STATE := GET_SERVICE_STATE(v_SCENARIO_ID, v_ACCOUNT_ID, v_SERVICE_LOCATION_ID, v_METER_ID, v_AGGREGATE_ID, p_SERVICE_DATE, p_AS_OF_DATE, g_UNKNOWN);

END ACCEPT_ACCOUNT_SERVICE;
----------------------------------------------------------------------------------------------------
PROCEDURE DELETE_REQUEST
	(
	p_REQUEST_TYPE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_METER_TYPE IN CHAR,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

BEGIN

	IF NOT CAN_DELETE(g_DOMAIN_NAME) THEN
		ERRS.RAISE_NO_DELETE_MODULE(g_DOMAIN_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;
	p_MESSAGE := 'OK';

	IF UPPER(SUBSTR(p_REQUEST_TYPE,1,1)) = 'U' THEN
		ALLOCATION_DELETE(p_MODEL_ID, GA.BASE_SCENARIO_ID, TRUNC(p_BEGIN_DATE), TRUNC(p_END_DATE), p_AS_OF_DATE, 'P');
	ELSIF UPPER(SUBSTR(p_REQUEST_TYPE,1,1)) = 'X' THEN
		ALLOCATION_DELETE(p_MODEL_ID, GA.BASE_SCENARIO_ID, TRUNC(p_BEGIN_DATE), TRUNC(p_END_DATE), p_AS_OF_DATE, p_METER_TYPE);
	ELSIF UPPER(SUBSTR(p_REQUEST_TYPE,1,1)) = 'C' THEN
		CONSUMPTION_DELETE(p_MODEL_ID, TRUNC(p_BEGIN_DATE), TRUNC(p_END_DATE), p_AS_OF_DATE, p_METER_TYPE);
	END IF;

END DELETE_REQUEST;
----------------------------------------------------------------------------------------------------
PROCEDURE DELETE_REQUEST
	(
	p_REQUEST_TYPE IN VARCHAR,
	p_MODEL_ID IN NUMBER,
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER,
	p_MESSAGE OUT VARCHAR
	) AS

BEGIN

	DELETE_REQUEST(p_REQUEST_TYPE, p_MODEL_ID, p_BEGIN_DATE, p_END_DATE, p_AS_OF_DATE, '*', p_STATUS, p_MESSAGE);

END DELETE_REQUEST;
----------------------------------------------------------------------------------------------------
PROCEDURE INTERVAL_METERED_USAGE
	(
	p_BEGIN_DATE IN DATE,
	p_END_DATE IN DATE,
	p_AS_OF_DATE IN DATE,
	p_STATUS OUT NUMBER
	) AS

-- Sum metered usage for each interval meter.

v_ELASPSED PLS_INTEGER := DBMS_UTILITY.GET_TIME;

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('INTERVAL_METERED_USAGE');
		LOGS.LOG_DEBUG('BEGIN_DATE=' || UT.TRACE_DATE(p_BEGIN_DATE));
		LOGS.LOG_DEBUG('END_DATE=' || UT.TRACE_DATE(p_END_DATE));
		LOGS.LOG_DEBUG('AS_OF_DATE=' || UT.TRACE_DATE(p_AS_OF_DATE));
	END IF;

	UPDATE SERVICE_CONSUMPTION A
	SET A.METERED_USAGE =
		(SELECT SUM(LOAD_VAL)
		FROM SERVICE_LOAD
		WHERE SERVICE_ID = A.SERVICE_ID
			AND SERVICE_CODE = GA.ACTUAL_SERVICE
			AND LOAD_DATE BETWEEN DECODE(GA.DEFAULT_MODEL, GA.ELECTRIC_MODEL, ADD_SECONDS_TO_DATE(TO_CUT(TRUNC(A.BEGIN_DATE), g_LOCAL_TIME_ZONE), 1), TRUNC(A.BEGIN_DATE))
				AND DECODE(GA.DEFAULT_MODEL, GA.ELECTRIC_MODEL, TO_CUT(TRUNC(p_END_DATE) + 1, g_LOCAL_TIME_ZONE), TRUNC(A.BEGIN_DATE))
			AND LOAD_CODE = GA.STANDARD)
	WHERE A.SERVICE_ID IN (SELECT SERVICE_ID FROM SERVICE WHERE MODEL_ID = GA.DEFAULT_MODEL AND SCENARIO_ID = GA.BASE_SCENARIO_ID AND AS_OF_DATE = p_AS_OF_DATE)
		AND A.BEGIN_DATE <= TRUNC(p_END_DATE)
		AND A.END_DATE >= TRUNC(p_BEGIN_DATE)
		AND A.METER_TYPE = 'I'
		AND A.UNIT_OF_MEASUREMENT = GA.DEFAULT_UNIT_OF_MEASUREMENT;

	IF LOGS.IS_DEBUG_ENABLED THEN
	    LOGS.LOG_DEBUG('INTERVAL_METER_USAGE_REQUEST ELAPSED TIME=' || TO_CHAR(DBMS_UTILITY.GET_TIME - v_ELASPSED));
	END IF;

END INTERVAL_METERED_USAGE;
----------------------------------------------------------------------------------------------------
-- ACCEPT_INTERVAL_USG_INTRN_VB and ACCEPT_INTERNAL_USAGE_RECORDS
-- are both needed by the Settlement Module for the Metered Usage tab
-- they can be removed once that module is migrated to JAVA, but until then
-- we need them. -- ABG -- BZ 17785
PROCEDURE ACCEPT_INTERVAL_USG_INTRN_VB
	(
	p_AS_OF_DATE IN DATE,
	p_DATE_FORMAT IN VARCHAR,
	p_USE_EXTERNAL_IDENTIFIER IN NUMBER,
	p_RECORD IN PARSE_UTIL.BIG_STRING_TABLE_MP,
	p_TIME_ZONE IN VARCHAR
	) AS

-- Accept Interval Usage for an Account/Meter and determine the Service Providers from internal sources.

v_ACCOUNT_NAME ACCOUNT.ACCOUNT_NAME%TYPE;
v_METER_NAME METER.METER_NAME%TYPE;
v_SERVICE_DATE DATE;
v_LOAD_DATE DATE;
v_INDEX BINARY_INTEGER;
v_ACCOUNT_ID NUMBER;
v_SERVICE_LOCATION_ID NUMBER;
v_METER_ID NUMBER;
v_AGGREGATE_ID NUMBER;
v_ACCOUNT_MODEL_OPTION CHAR(1);
v_IDENT_TYPE CHAR(1);
v_METER_TYPE CHAR(1);
v_USAGE_DATE GA.DATE_TABLE;
v_USAGE_VAL GA.FLOAT_TABLE;
v_TX_LOSS GA.FACTOR_TABLE;
v_DX_LOSS GA.FACTOR_TABLE;
v_UE_LOSS GA.FACTOR_TABLE;
v_SERVICE SERVICE%ROWTYPE;
v_SERVICE_STATE SERVICE_STATE%ROWTYPE;
v_PROVIDER_SERVICE PROVIDER_SERVICE%ROWTYPE;
v_SCENARIO_ID NUMBER(9) := GA.BASE_SCENARIO_ID;
BEGIN

	SELECT DECODE(p_USE_EXTERNAL_IDENTIFIER, 1, 'X', 'N') INTO v_IDENT_TYPE FROM DUAL;

	v_ACCOUNT_NAME := LTRIM(RTRIM(p_RECORD(1)));
	v_METER_NAME := LTRIM(RTRIM(p_RECORD(2)));
	v_SERVICE_DATE := TRUNC(TO_DATE(p_RECORD(3), p_DATE_FORMAT));

	v_ACCOUNT_ID := CS.GET_ACCOUNT_ID(v_ACCOUNT_NAME, v_IDENT_TYPE);
	v_SERVICE_LOCATION_ID := CS.GET_SERVICE_LOCATION_ID(v_ACCOUNT_ID,	v_SERVICE_DATE);
	v_ACCOUNT_MODEL_OPTION := GET_ACCOUNT_MODEL_OPTION(v_ACCOUNT_ID);
	v_AGGREGATE_ID := 0;

	IF v_ACCOUNT_MODEL_OPTION = 'M' THEN
		v_METER_ID := GET_METER_ID(v_METER_NAME, v_IDENT_TYPE);
		v_SERVICE_LOCATION_ID := GET_METER_OWNER(v_METER_ID, v_SERVICE_DATE);
	ELSE
		v_METER_ID := 0;
		v_SERVICE_LOCATION_ID := CS.GET_SERVICE_LOCATION_ID(v_ACCOUNT_ID,	v_SERVICE_DATE);
	END IF;

	v_METER_TYPE := CS.GET_METER_TYPE(v_ACCOUNT_ID,v_METER_ID);

	ASSERT(v_METER_TYPE = 'I', 'Meter Type must be "Interval" for ' || CASE WHEN v_METER_ID = 0 THEN 'Account:' || v_ACCOUNT_NAME ELSE 'Meter:' || v_METER_NAME END);

	v_LOAD_DATE := BEGIN_HOUR_ENDING_CUT_DAY(v_SERVICE_DATE, p_TIME_ZONE);

	IF GA.DEFAULT_MODEL = GA.GAS_MODEL THEN
		v_LOAD_DATE := TRUNC(v_LOAD_DATE);
	END IF;

	FOR v_INDEX IN 4..p_RECORD.COUNT LOOP
		BEGIN
			v_USAGE_VAL(v_INDEX - 3) := p_RECORD(v_INDEX);
			v_USAGE_DATE(v_INDEX - 3) := v_LOAD_DATE;
			v_LOAD_DATE := ADD_HOURS_TO_DATE(v_LOAD_DATE, 1);
		EXCEPTION
			--CHECK FOR SETTLEMENT_TYPE_NAME AT END OF LIST
			WHEN VALUE_ERROR THEN
				ERRS.LOG_AND_CONTINUE(p_LOG_LEVEL => LOGS.c_LEVEL_DEBUG);
				v_SCENARIO_ID := SCENARIO_FOR_SETTLEMENT_TYPE(p_RECORD(v_INDEX));
		END;
	END LOOP;

	v_SERVICE_STATE := GET_SERVICE_STATE(v_SCENARIO_ID, v_ACCOUNT_ID, v_SERVICE_LOCATION_ID, v_METER_ID, v_AGGREGATE_ID, TRUNC(v_SERVICE_DATE), p_AS_OF_DATE, g_UNKNOWN);
	v_SERVICE := CS.GET_SERVICE(v_SERVICE_STATE.SERVICE_ID);
	v_PROVIDER_SERVICE := CS.GET_PROVIDER_SERVICE(v_SERVICE.PROVIDER_SERVICE_ID);

	FS.APPLY_LOSS_FACTORS(v_SERVICE.ACCOUNT_SERVICE_ID, v_PROVIDER_SERVICE.EDC_ID, v_SERVICE_DATE, v_USAGE_VAL, v_TX_LOSS, v_DX_LOSS, v_UE_LOSS, TRUE);
	STORE_SERVICE_LOAD(v_SERVICE.SERVICE_ID, GA.ACTUAL_SERVICE, v_USAGE_DATE, v_USAGE_VAL, v_TX_LOSS, v_DX_LOSS, v_UE_LOSS);

END ACCEPT_INTERVAL_USG_INTRN_VB;
----------------------------------------------------------------------------------------------------
PROCEDURE ACCEPT_INTERVAL_USAGE_RECORDS
	(
	p_AS_OF_DATE IN DATE,
	p_DATE_FORMAT IN VARCHAR,
	p_USE_EXTERNAL_IDENTIFIER IN NUMBER,
	p_RECORD_STREAM IN VARCHAR,
	p_TIME_ZONE IN VARCHAR,
	p_STATUS OUT NUMBER
	) AS

v_INDEX BINARY_INTEGER;
v_RECORDS PARSE_UTIL.BIG_STRING_TABLE_MP;
v_RECORD PARSE_UTIL.BIG_STRING_TABLE_MP;

v_LAST_LEVEL NUMBER(3);

BEGIN

	IF NOT CAN_WRITE(g_MODULE_NAME) THEN
		ERRS.RAISE_NO_WRITE_MODULE(g_MODULE_NAME);
	END IF;

	p_STATUS := GA.SUCCESS;

	PARSE_UTIL.TOKENS_FROM_BIG_STRING(p_RECORD_STREAM, ';', v_RECORDS);

	v_LAST_LEVEL := LOGS.CURRENT_LOG_LEVEL();

	v_INDEX := v_RECORDS.FIRST;
	WHILE v_INDEX <= v_RECORDS.LAST LOOP
		IF SUBSTR(UPPER(LTRIM(RTRIM(v_RECORDS(v_INDEX)))),1,10) = '@@TRACE_ON' THEN
			LOGS.SET_CURRENT_LOG_LEVEL(LOGS.c_LEVEL_DEBUG);
		ELSE
			IF LOGS.IS_DEBUG_ENABLED THEN
				LOGS.LOG_DEBUG(v_RECORDS(v_INDEX));
			END IF;
			PARSE_UTIL.TOKENS_FROM_BIG_STRING(v_RECORDS(v_INDEX), ';', v_RECORDS);
			IF v_RECORD.COUNT > 0 THEN
				IF v_RECORD(v_RECORD.FIRST)  = '@' THEN
					ACCEPT_INTERVAL_USAGE_EXTERNAL(p_AS_OF_DATE, p_DATE_FORMAT, v_RECORD, p_TIME_ZONE);
				ELSE
					ACCEPT_INTERVAL_USG_INTRN_VB(p_AS_OF_DATE, p_DATE_FORMAT, p_USE_EXTERNAL_IDENTIFIER, v_RECORD, p_TIME_ZONE);
				END IF;
			END IF;
		END IF;
		v_INDEX := v_RECORDS.NEXT(v_INDEX);
	END LOOP;

	LOGS.SET_CURRENT_LOG_LEVEL(v_LAST_LEVEL);

EXCEPTION
	WHEN OTHERS THEN
		BEGIN
			LOGS.SET_CURRENT_LOG_LEVEL(v_LAST_LEVEL);
		EXCEPTION
			WHEN OTHERS THEN
				ERRS.LOG_AND_CONTINUE();
		END;
		ERRS.LOG_AND_RAISE();

END ACCEPT_INTERVAL_USAGE_RECORDS;
---------------------------------------------------------------------------------------------------
PROCEDURE BULK_PROCESS_USAGE_FACTORS(
  p_BEGIN_DATE     IN DATE,
  p_END_DATE       IN DATE,
  p_ENTITY_IDS      IN NUMBER_COLLECTION,
  p_TRACE_ON       IN NUMBER,
  p_MESSAGE        OUT VARCHAR2,
  p_PROCESS_ID     OUT VARCHAR2,
  p_PROCESS_STATUS OUT NUMBER
	)
IS
   c_PROCEDURE_NAME CONSTANT VARCHAR(30) := 'BULK_PROCESS_USAGE_FACTORS';
   v_CALENDAR_CNT            NUMBER := p_ENTITY_IDS.COUNT;
   v_CONS_REC_CNT            NUMBER := 0;
   v_PROGRESS_RANGE          PLS_INTEGER := 0;
   v_COMMIT_EVERY_N_ROWS     PLS_INTEGER;
   v_CURRENT_ROWCOUNT        PLS_INTEGER := 0;
   v_DEFAULT_UOM             VARCHAR2(512) := GA.DEFAULT_UNIT_OF_MEASUREMENT;

BEGIN
  	-- Set the Transaction SETPOINT
	SAVEPOINT SP_BULK_PROC_USAGE_FACTORS;

   LOGS.START_PROCESS(p_PROCESS_NAME => 'Calculate Usage Factors by Calendar',p_TRACE_ON => p_TRACE_ON);
   p_PROCESS_ID := LOGS.CURRENT_PROCESS_ID;

      LOGS.LOG_DEBUG(gc_PACKAGE_NAME||'.'||c_PROCEDURE_NAME);
      LOGS.LOG_DEBUG('START: Calculate Usage Factors by Calendar...');
      LOGS.LOG_DEBUG('p_BEGIN_DATE = '||TO_CHAR(p_BEGIN_DATE, 'YYYY-MM-DD'));
      LOGS.LOG_DEBUG('p_END_DATE = '||TO_CHAR(p_END_DATE, 'YYYY-MM-DD'));
      LOGS.LOG_DEBUG('p_ENTITY_IDS.COUNT = '||TO_CHAR(p_ENTITY_IDS.COUNT));

 	-- Get System Setting Value
	BEGIN
	   v_COMMIT_EVERY_N_ROWS := NVL(GET_DICTIONARY_VALUE(p_MODEL_ID => gc_GLOBAL_MODEL,
                                                        p_MODULE => 'Load Management',
                                                        p_KEY1 => 'Usage Factors',
                                                        p_KEY2 => '?',
                                                        p_KEY3 => '?',
                                                        p_SETTING_NAME => 'Usage Factor Calc Commit Every N Rows'),0);
	EXCEPTION
	   WHEN VALUE_ERROR THEN
	      ERRS.LOG_AND_RAISE(p_EXTRA_MESSAGE => '"Usage Factor Calc Commit Every N Rows" System Setting ' ||
		                                        'under Global->Load Management->Usage Factors has an invalid value.'||
                                              ' The value must be numeric. If set to zero it will commit once.');
	END;

   IF p_ENTITY_IDS IS NULL OR p_ENTITY_IDS.COUNT = 0 OR p_ENTITY_IDS(1) = 0 THEN
      v_CALENDAR_CNT := 0;
      LOGS.LOG_WARN(p_EVENT_TEXT => 'Must select at least one calendar from the list for processing.');
   ELSE--IF p_ENTITY_ID IS NULL THEN
     v_CALENDAR_CNT := 0;
     LOGS.INIT_PROCESS_PROGRESS(p_TOTAL_WORK => p_ENTITY_IDS.COUNT);

     PURGE_CALENDAR_PROFILE_VALUE;
     -- Outer loop of calendars, process will commit work after each calendar.
     FOR C IN p_ENTITY_IDS.FIRST..p_ENTITY_IDS.LAST LOOP
        v_CALENDAR_CNT := v_CALENDAR_CNT + 1;
        LOGS.LOG_INFO('Processing Calendar ' || EI.GET_ENTITY_NAME(p_ENTITY_DOMAIN_ID => -1100,
                                                                   p_ENTITY_ID => p_ENTITY_IDS(C)));
           LOGS.LOG_DEBUG('Calendar('||TO_CHAR(C)||'):: CALENDAR_ID = '||TO_CHAR(p_ENTITY_IDS(C)));

        SELECT COUNT(SC.SERVICE_ID) INTO v_CONS_REC_CNT
          FROM SERVICE_CONSUMPTION SC,
               (-- Accounts / Meters for given calendar and date range --
                SELECT AC.ACCOUNT_ID  AS ACCOUNT_ID,
                       AC.CALENDAR_ID AS CALENDAR_ID,
                       AC.BEGIN_DATE  AS BEGIN_DATE,
                       AC.END_DATE    AS END_DATE,
                       S.SERVICE_ID   AS SERVICE_ID
                  FROM SERVICE                  S,
                       ACCOUNT_SERVICE          ASX,
                       ACCOUNT_SERVICE_LOCATION ASL,
                       ACCOUNT_CALENDAR         AC
                 WHERE AC.CALENDAR_ID   = p_ENTITY_IDS(c)
                   AND AC.CASE_ID       = ga.BASE_CASE_ID
                   AND AC.CALENDAR_TYPE = 'Forecast'
                   AND AC.BEGIN_DATE    < p_END_DATE
                   AND NVL(AC.END_DATE,gc_HIGH_DATE) >= p_BEGIN_DATE
                   AND ASL.ACCOUNT_ID   = AC.ACCOUNT_ID
                   AND ASL.BEGIN_DATE  <= NVL(AC.END_DATE,gc_HIGH_DATE)
                   AND NVL(ASL.END_DATE,gc_HIGH_DATE) >= AC.BEGIN_DATE
                   AND ASX.ACCOUNT_ID   = ASL.ACCOUNT_ID
                   AND ASX.ACCOUNT_SERVICE_ID = S.ACCOUNT_SERVICE_ID
                   AND EXISTS (SELECT NULL
                                 FROM ACCOUNT A
                                WHERE A.ACCOUNT_MODEL_OPTION <> 'Aggregate'
                                  AND A.ACCOUNT_ID = ASX.ACCOUNT_ID
                                  AND NVL(A.USE_TOU_USAGE_FACTOR,gc_NOT_ASSIGNED) = gc_NOT_ASSIGNED)
                UNION ALL
                SELECT ASX.ACCOUNT_ID AS ACCOUNT_ID,
                       MC.CALENDAR_ID AS CALENDAR_ID,
                       MC.BEGIN_DATE  AS BEGIN_DATE,
                       MC.END_DATE    AS END_DATE,
                       S.SERVICE_ID   AS SERVICE_ID
                  FROM SERVICE                S,
                       ACCOUNT_SERVICE        ASX,
                       SERVICE_LOCATION_METER SLM,
                       METER_CALENDAR MC
                 WHERE MC.CALENDAR_ID   = p_ENTITY_IDS(c)
                   AND MC.CASE_ID       = ga.BASE_CASE_ID
                   AND MC.CALENDAR_TYPE = 'Forecast'
                   AND MC.BEGIN_DATE    < p_END_DATE
                   AND NVL(MC.END_DATE,gc_HIGH_DATE) >= p_BEGIN_DATE
                   AND SLM.METER_ID     = MC.METER_ID
                   AND SLM.BEGIN_DATE   < NVL(MC.END_DATE,gc_HIGH_DATE)
                   AND NVL(SLM.END_DATE,gc_HIGH_DATE) >= MC.BEGIN_DATE
                   AND ASX.METER_ID     = SLM.METER_ID
                   AND ASX.ACCOUNT_SERVICE_ID = S.ACCOUNT_SERVICE_ID
                   AND EXISTS (SELECT NULL
                                 FROM METER M
                                WHERE M.METER_TYPE = 'Period'
                                  AND M.METER_ID = ASX.METER_ID
                                  AND NVL(M.USE_TOU_USAGE_FACTOR,gc_NOT_ASSIGNED) = gc_NOT_ASSIGNED)

              ) TBL
        WHERE NVL(SC.IGNORE_CONSUMPTION, gc_NOT_ASSIGNED ) = gc_NOT_ASSIGNED
          AND UPPER(SC.UNIT_OF_MEASUREMENT) = v_DEFAULT_UOM
          AND NVL(SC.TEMPLATE_ID,gc_NOT_ASSIGNED) IN (gc_NOT_ASSIGNED,
                                                          gc_ANYTIME_TOU_TEMPLATE_ID,
                                                          gc_ANYTIME_SD_TEMPLATE_ID)
          AND SC.SERVICE_ID = TBL.SERVICE_ID
          AND NVL(SC.END_DATE,gc_HIGH_DATE) BETWEEN p_BEGIN_DATE AND p_END_DATE;

        IF v_CONS_REC_CNT >= 1 THEN
         v_PROGRESS_RANGE := LOGS.PUSH_PROGRESS_RANGE(p_MAX_VALUE => v_CONS_REC_CNT);
         v_CURRENT_ROWCOUNT := 0;
         -- Accounts/Meters Consumption Records for calendar.
         FOR cur_CONS_REC IN
                 (SELECT SC.*
                    FROM SERVICE_CONSUMPTION SC,
                         (-- Accounts / Meters for given calendar and date range --
                          SELECT AC.ACCOUNT_ID  AS ACCOUNT_ID,
                                 AC.CALENDAR_ID AS CALENDAR_ID,
                                 AC.BEGIN_DATE  AS BEGIN_DATE,
                                 AC.END_DATE    AS END_DATE,
                                 S.SERVICE_ID   AS SERVICE_ID
                            FROM SERVICE                  S,
                                 ACCOUNT_SERVICE          ASX,
                                 ACCOUNT_SERVICE_LOCATION ASL,
                                 ACCOUNT_CALENDAR         AC
                           WHERE AC.CALENDAR_ID   = p_ENTITY_IDS(c)
                             AND AC.CASE_ID       = ga.BASE_CASE_ID
                             AND AC.CALENDAR_TYPE = 'Forecast'
                             AND AC.BEGIN_DATE    < p_END_DATE
                             AND NVL(AC.END_DATE,gc_HIGH_DATE) >= p_BEGIN_DATE
                             AND ASL.ACCOUNT_ID   = AC.ACCOUNT_ID
                             AND ASL.BEGIN_DATE  <= NVL(AC.END_DATE,gc_HIGH_DATE)
                             AND NVL(ASL.END_DATE,gc_HIGH_DATE) >= AC.BEGIN_DATE
                             AND ASX.ACCOUNT_ID   = ASL.ACCOUNT_ID
                             AND ASX.ACCOUNT_SERVICE_ID = S.ACCOUNT_SERVICE_ID
                             AND EXISTS (SELECT NULL
                                           FROM ACCOUNT A
                                          WHERE A.ACCOUNT_MODEL_OPTION <> 'Aggregate'
                                            AND A.ACCOUNT_ID = ASX.ACCOUNT_ID
                                            AND NVL(A.USE_TOU_USAGE_FACTOR,gc_NOT_ASSIGNED) = gc_NOT_ASSIGNED)
                          UNION ALL
                          SELECT ASX.ACCOUNT_ID AS ACCOUNT_ID,
                                 MC.CALENDAR_ID AS CALENDAR_ID,
                                 MC.BEGIN_DATE  AS BEGIN_DATE,
                                 MC.END_DATE    AS END_DATE,
                                 S.SERVICE_ID   AS SERVICE_ID
                            FROM SERVICE                S,
                                 ACCOUNT_SERVICE        ASX,
                                 SERVICE_LOCATION_METER SLM,
                                 METER_CALENDAR MC
                           WHERE MC.CALENDAR_ID   = p_ENTITY_IDS(c)
                             AND MC.CASE_ID       = ga.BASE_CASE_ID
                             AND MC.CALENDAR_TYPE = 'Forecast'
                             AND MC.BEGIN_DATE    < p_END_DATE
                             AND NVL(MC.END_DATE,gc_HIGH_DATE) >= p_BEGIN_DATE
                             AND SLM.METER_ID     = MC.METER_ID
                             AND SLM.BEGIN_DATE   < NVL(MC.END_DATE,gc_HIGH_DATE)
                             AND NVL(SLM.END_DATE,gc_HIGH_DATE) >= MC.BEGIN_DATE
                             AND ASX.METER_ID     = SLM.METER_ID
                             AND ASX.ACCOUNT_SERVICE_ID = S.ACCOUNT_SERVICE_ID
                             AND EXISTS (SELECT NULL
                                           FROM METER M
                                          WHERE M.METER_TYPE = 'Period'
                                            AND M.METER_ID = ASX.METER_ID
                                            AND NVL(M.USE_TOU_USAGE_FACTOR,gc_NOT_ASSIGNED) = gc_NOT_ASSIGNED)

                        ) TBL
                  WHERE NVL(SC.IGNORE_CONSUMPTION, gc_NOT_ASSIGNED ) = gc_NOT_ASSIGNED
                    AND UPPER(SC.UNIT_OF_MEASUREMENT) = v_DEFAULT_UOM
                      AND NVL(SC.TEMPLATE_ID,gc_NOT_ASSIGNED) IN (gc_NOT_ASSIGNED,
                                                                    gc_ANYTIME_TOU_TEMPLATE_ID,
                                                                    gc_ANYTIME_SD_TEMPLATE_ID)
                    AND SC.SERVICE_ID = TBL.SERVICE_ID
                      AND NVL(SC.END_DATE,gc_HIGH_DATE) BETWEEN p_BEGIN_DATE AND p_END_DATE
                  ) LOOP

			  v_CURRENT_ROWCOUNT := v_CURRENT_ROWCOUNT + 1;
               LOGS.LOG_DEBUG('Consumption Record:: SERVICE_ID = '||TO_CHAR(cur_CONS_REC.SERVICE_ID));

            PROCESS_USAGE_FACTORS(p_SERVICE_CONSUMPTION => cur_CONS_REC);

 				-- Check if Periodic Commit is required based on System Setting and redefine Savepoint immediately
				IF v_COMMIT_EVERY_N_ROWS <> 0 AND MOD(v_CURRENT_ROWCOUNT, v_COMMIT_EVERY_N_ROWS) = 0 THEN
				   COMMIT;
				   SAVEPOINT SP_BULK_PROC_USAGE_FACTORS;
                 LOGS.LOG_DEBUG('Processed ' || TO_CHAR(v_CURRENT_ROWCOUNT) || ' rows out of ' || TO_CHAR(v_CONS_REC_CNT) || ' rows');
				END IF;

            LOGS.INCREMENT_PROCESS_PROGRESS;
         END LOOP;

         LOGS.POP_PROGRESS_RANGE;

         END IF;--IF v_CONS_REC_CNT >= 1 THEN

         LOGS.INCREMENT_PROCESS_PROGRESS;
         PURGE_CALENDAR_PROFILE_VALUE;
         -- Log this debug message only if it is committed for the calendar
         -- or final commit for periodic-commit cycle, if it was not committed within the INNER LOOP previously
         IF v_COMMIT_EVERY_N_ROWS = 0 OR ((v_COMMIT_EVERY_N_ROWS <> 0) AND MOD(v_CURRENT_ROWCOUNT, v_COMMIT_EVERY_N_ROWS) <> 0) THEN
             LOGS.LOG_DEBUG('Processed ' || TO_CHAR(v_CURRENT_ROWCOUNT) || ' rows out of ' || TO_CHAR(v_CONS_REC_CNT) || ' rows.');
            COMMIT;
         END IF;

     END LOOP;--FOR C IN v_CALENDAR_ID.FIRST..v_CALENDAR_ID.LAST LOOP

   END IF;--IF p_ENTITY_ID IS NULL THEN

   LOGS.LOG_DEBUG('Process completed processing ' || TO_CHAR(v_CALENDAR_CNT) || ' calendar(s).');
   p_MESSAGE := 'Process completed processing ' || TO_CHAR(v_CALENDAR_CNT) || ' calendar(s).';
   LOGS.STOP_PROCESS(p_MESSAGE, p_PROCESS_STATUS);

  EXCEPTION
    WHEN OTHERS THEN
         ERRS.ABORT_PROCESS;
END BULK_PROCESS_USAGE_FACTORS;
----------------------------------------------------------------------------------------------------
END MS;
/

